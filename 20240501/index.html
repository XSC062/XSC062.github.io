<!DOCTYPE html>
<html>
<head>
    <!-- 网站图标 -->
<link rel="icon" type="image/png" sizes="32x32" href="/images/icon.svg">
<!-- 其他图标支持 -->
<link rel="stylesheet" href="/css/facss/fa-brands.min.css">
<link rel="stylesheet" href="/css/facss/fa-regular.min.css">
<link rel="stylesheet" href="/css/facss/fa-solid.min.css">
<link rel="stylesheet" href="/css/facss/fontawesome.min.css">
<link rel="stylesheet" href="/css/facss/fontawesome-all.css">
<link href="https://use.fontawesome.com/releases/v5.0.4/css/all.css" rel="stylesheet">
<!-- 网站标题 -->
<title>
	
		五一杂题 -
	
	XSC062 的博客
</title>
<!-- js 引入 -->
<script>
const searchPath = "/search.xml"
</script>

<script src="/js/afterloaded.js"></script>


<script src="/js/jQuery.js"></script>

<!-- 载入 Valine -->

<script src="/js/Valine.min.js"></script>

<!-- css 引入 -->

<link rel="stylesheet" href="/css/layout.css">


<link rel="stylesheet" href="/css/prcss/prism.css">



<meta charset="utf-8"> 
<meta name="generator" content="Hexo 7.2.0"></head>
<body class="line-numbers match-braces no-brace-select rainbow-braces">
	
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
          tex2jax: {
            inlineMath: [ ['$','$'], ["\\(","\\)"] ],
            processEscapes: true
          }
        });
      </script>
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
            tex2jax: {
              skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
            }
          });
      </script>
    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
              var all = MathJax.Hub.getAllJax(), i;
              for(i=0; i < all.length; i += 1) {
                  all[i].SourceElement().parentNode.className += ' has-jax';
              }
          });
      </script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.6/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

	<!-- 搜索 -->
<div id="search-bg">
	<div id="search-box">
		<input type="text" id="search-input" placeholder="Type to search...">
		<div id="search-results"></div>
		<p>恭喜你触发了这个 box，由于我还没有写关闭键，你只能通过刷新页面来关闭它。非常抱歉 ;-)</p>
		<p>为了证明我没有摆烂，在这里放一个进度：</p>
		<p>- 250715：尝试实现搜索功能，初步成功，能够搜索到包含关键词的文章了（<strong>也能关掉了</strong>）。不知道为啥输入 123 可以匹配所有文章，但是输入 1234 就一篇都匹配不上。（250814 upd：搜索的是 html 源码，<code>{</code> 的 ASCII 码为 123 / <code>&</code><code>#123;</code>）</p>
		<p>- 250716：尝试加入关键词上下文来 de 上面的 bug，然后把 js 写成史了，现在这个框框并不具备搜索功能（也不具备关闭功能） :-(</p>
		<p>- 250814：<strong>能关了</strong>，我很勤勉</p>
		<p>什么？居然还能搜索！还能高亮关键词？谢谢你，hexo-generator-searchdb！但是你为什么没有注释，让我阅读理解了半天 :-(</p>
		<p>css 等有空了再写吧，能用就行</p>
		<p>**为什么有 bug？试着找一个关键词发现有的文章没有匹配上**/p>
	</div>
</div>
<!-- 顶栏整体导航菜单 -->
<div class="ui top menu">
	<!-- 左对齐 logo -->
	<a class="logo" href="/">
		<img src="/images/icon.png"></img>
		<div id="bartitle">
			XSC062 的博客
		</div>
	</a>
	<!-- 右对齐部分导航 -->
	<div id="rightali">
		<a class="item" id="Search" type="button">
			<i class="btn text-muted fa fa-search" id="search-icon" disabled></i>
		</a>
		<a class="item" id="Home" href="/">
			Home
		</a>
		<a class="item" id="Arch" href="/archives">
			Archives
		</a>
		<!-- <a class="item" id="Cate" href="/categories">
			Categories
		</a> -->
		<a class="item" id="Tags" href="/tags">
			Tags
		</a>
		<a class="item" id="Frie" href="/friends">
			Friends
		</a>
		<a class="item" id="Abou" href="/about">
			About
		</a>
	</div>
</div>
    
<link rel="stylesheet" href="/css/post.css">


<script src="/js/post.js"></script>


<div class="main">
	<div id="sidebar">
		<aside id="toc">
			<span id="toctitle">
				<i class="fas fa-list"></i>
				目录
			</span>
			<ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#d.-%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">D. 字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#f.-security"><span class="toc-text">F. Security</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#a.-%E5%85%AD%E5%87%BA%E7%A5%81%E5%B1%B1"><span class="toc-text">A. 六出祁山</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#b.-%E6%B0%B4%E6%B7%B9%E4%B8%83%E5%86%9B"><span class="toc-text">B. 水淹七军</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#c.-%E7%85%AE%E9%85%92%E8%AE%BA%E8%8B%B1%E9%9B%84"><span class="toc-text">C. 煮酒论英雄</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#a.-%E6%8D%8F%E6%96%91%E9%A9%AC"><span class="toc-text">A. 捏斑马</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#d.-%E9%93%BE%E7%8A%B6%E9%97%AA%E7%94%B5"><span class="toc-text">D. 链状闪电</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#f.-%E5%BC%B9%E9%A3%9E%E7%BB%B5%E7%BE%8A"><span class="toc-text">F. 弹飞绵羊</span></a></li></ol>
		</aside>
	</div>
	<div class="ui post container">
		<div class="ui text container">
			<span id="postcon">
				<span id="postinfo">
					<div class="ui post title">
						<div id="fortitle" data-content="五一杂题">
							五一杂题
						</div>
						<div class="ui title background">
						</div>
					</div>
					<span id="date">
						<i class="fas fa-calendar-alt" style="margin-right: 4px;"></i>
						2024-05-01
					</span>
				</span>
			</span>
			<div id="posttags" class="dotted border">
				
					
						<a href="/tags/DP/" class="citem">DP</a>
					
						<a href="/tags/状压/" class="citem">状压</a>
					
						<a href="/tags/SAM/" class="citem">SAM</a>
					
						<a href="/tags/分块/" class="citem">分块</a>
					
						<a href="/tags/可持久化/" class="citem">可持久化</a>
					
						<a href="/tags/笛卡尔树/" class="citem">笛卡尔树</a>
					
				
			</div>
			<!-- 本来用的是 fromNow 然后字符串判断，没想到可以直接调用 moment() -->
			
			<div id="content">
				<p><a target="_blank" rel="noopener" href="http://222.180.160.110:61235/contest/5169">SAM 杂题</a> + <a target="_blank" rel="noopener" href="http://222.180.160.110:61235/contest/5170">NOIPS8</a> + <a target="_blank" rel="noopener" href="http://222.180.160.110:61235/contest/5175">周考</a> 选讲。</p>
<p>看看这个标签列表长度就知道这三天做的题有多杂。</p>
<span id="more"></span>
<hr />
<h3 id="d.-字符串">D. 字符串</h3>
<p><a target="_blank" rel="noopener" href="http://222.180.160.110:61235/contest/5169/problem/4" class="uri">http://222.180.160.110:61235/contest/5169/problem/4</a></p>
<p>和 SA 的做法一样，先二分 <span class="math inline">\(s_{c\sim d}\)</span> 的前缀长度 <span class="math inline">\(mid\)</span>，只需 check <span class="math inline">\(s_{c \sim c + mid - 1}\)</span> 是否在 <span class="math inline">\(s_{a\sim b}\)</span> 中出现过。</p>
<p>考虑怎么快速 check。从 <span class="math inline">\(c\)</span> 一步一步跳到 <span class="math inline">\(c+mid-1\)</span> 显然会起飞，考虑到查询是静态的，我们事先预处理一下然后倍增地跳即可。</p>
<p>此时只需看当前状态的 <span class="math inline">\(\text {endpos}\)</span> 是否在 <span class="math inline">\([a + mid - 1, b]\)</span> 出现过。</p>
<p>因为这个不能用最大最小简单代替，所以就到了我们喜闻乐见的线段树合并环节。将插入后的每个单点 <span class="math inline">\(\text {endpos}\)</span> 在权值线段树上更新，在 parent tree 上暴力线段树合并即可。</p>
<p>之前一直有一个误区，就是觉得线段树合并是一次性的，比如用 A 树和 B 树并出来了 C 树之后，A 树和 B 树的数据就无效了。</p>
<p>但这显然是很荒谬的，同样因为我们的查询是静态的，所以完全可以用一种类似于可持久化的方式，建立一些新的点表示合并后的信息状态点，一些可以保留的点就保留作儿子。</p>
<p>在对应的状态上查询即可。</p>
<details>
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;
const int maxm = 35;
const int maxn = 6e5 + 5;
const int maxk = 8e7 + 5;
struct _ &#123;
    int l, f;
    int ne[maxm]; 
    _() &#123;&#125;
    _(int l1, int f1): l(l1), f(f1) &#123;&#125;
&#125;;
_ t[maxn &lt;&lt; 1];
int vis[maxn &lt;&lt; 1];
int fa[maxn][maxm];
int n, la, tot, siz;
struct &#123; int l, r, u; &#125; t1[maxk];
int tab[maxn &lt;&lt; 1], cnt[maxn &lt;&lt; 1];
void Init(void) &#123;
    la = tot = 1;
    t[1] = _(0, 0);
    return;
&#125;
void ext(int c) &#123;
    int p = la, np = ++tot;
    la = tot;
    t[np] = _(t[p].l + 1, 0);
    while (p &amp;&amp; !t[p].ne[c])
        t[p].ne[c] = np, p = t[p].f;
    if (!p)
        t[np].f = 1;
    else &#123;
        int q = t[p].ne[c];
        if (t[q].l == t[p].l + 1)
            t[np].f = q;
        else &#123;
            int nq = ++tot;
            t[nq] = _(t[p].l + 1, t[q].f);
            std::copy(t[q].ne, t[q].ne + 26, t[nq].ne);
            while (p &amp;&amp; t[p].ne[c] == q)
                t[p].ne[c] = nq, p = t[p].f;
            t[q].f = nq;
            t[np].f = nq;
        &#125;
    &#125;
    return;
&#125;
int now = 0;
void ins(int &amp;p, int l, int r, int v) &#123;
    if (!p)
        p = ++now;
    ++t1[p].u;
    if (l == r)
        return;
    int mid = (l + r) &gt;&gt; 1;
    if (v &lt;= mid)
        ins(t1[p].l, l, mid, v);
    else
        ins(t1[p].r, mid + 1, r, v);
    return;
&#125;
int ask(int p, int l, int r, int ql, int qr) &#123;
    if (ql &lt;= l &amp;&amp; r &lt;= qr)
        return t1[p].u;
    int mid = (l + r) &gt;&gt; 1, res = 0;
    if (ql &lt;= mid)
        res = ask(t1[p].l, l, mid, ql, qr);
    if (qr &gt; mid)
        res += ask(t1[p].r, mid + 1, r, ql, qr);
    return res;
&#125;
int merge(int p, int q, int l, int r) &#123;
    if (!p || !q)
        return p + q;
    int np = ++now, mid = (l + r) &gt;&gt; 1;
    t1[np].u = t1[p].u + t1[q].u;
    if (l == r) return np;
    t1[np].l = merge(t1[p].l, t1[q].l, l, mid);
    t1[np].r = merge(t1[p].r, t1[q].r, mid + 1, r);
    return np;
&#125;
int pos[maxn], rt[maxn &lt;&lt; 1];
bool check(int x, int a, int b, int c, int d) &#123;
    assert(c + x - 1 &gt;= 0);
    int p = pos[c + x - 1];
    for (int i = siz; ~i; --i)
        if (fa[p][i] &amp;&amp; t[fa[p][i]].l &gt;= x)
            p = fa[p][i];
    return ask(rt[p], 0, n - 1, a + x - 1, b) &gt; 0;
&#125;
int solve(int a, int b, int c, int d) &#123;
    int l = 1, r = std::min(d - c + 1, b - a + 1), res = 0;
    while (l &lt;= r) &#123;
        int mid = (l + r) &gt;&gt; 1;
        if (check(mid, a, b, c, d))
            l = mid + 1, res = mid;
        else
            r = mid - 1;
    &#125;
    return res;
&#125;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    std::cout.tie(nullptr);
#endif
    int m;
    std::string s;
    std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; s;
    Init();
    for (int i = 0; i &lt; n; ++i) &#123;
        ext(s[i] - &#39;a&#39;);
        pos[i] = la;
        ins(rt[la], 0, n - 1, i);
    &#125;
    siz = log(tot) / log(2.0);
    for (int i = 1; i &lt;= tot; ++i)
        ++cnt[t[i].l];
    std::partial_sum(cnt + 1, cnt + tot + 1, cnt + 1);
    for (int i = 1; i &lt;= tot; ++i)
        tab[cnt[t[i].l]--] = i;
    for (int i = 1; i &lt;= tot; ++i) &#123;
        int u = tab[i];
        fa[u][0] = t[u].f;
        for (int j = 1; j &lt;= siz; ++j)
            fa[u][j] = fa[fa[u][j - 1]][j - 1];
    &#125;
    for (int i = tot; i; --i) &#123;
        int u = tab[i];
        if (t[u].f)
            rt[t[u].f] = merge(rt[t[u].f], rt[u], 0, n - 1);
    &#125;
    while (m--) &#123;
        int a, b, c, d;
        std::cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;
        std::cout &lt;&lt; solve(a - 1, b - 1, c - 1, d - 1) &lt;&lt; &#39;\n&#39;;
    &#125;
    return 0;
&#125;</code></pre>
</details>
<hr />
<h3 id="f.-security">F. Security</h3>
<p><a target="_blank" rel="noopener" href="http://222.180.160.110:61235/contest/5169/problem/6" class="uri">http://222.180.160.110:61235/contest/5169/problem/6</a></p>
<p>对我们来说应该是会 D 就会 F 的。所以只打了 10min。</p>
<p>首先考虑一个大家喜闻乐见的 DFS 求最小字典序。显然地，如果存在和当前位相等的字符，那么优先跳相等字符，进入下一层深搜；否则找到最小的更大字符，然后直接 out。</p>
<p>此时 SAM 就是我们用来判断 <span class="math inline">\(S_{l, r}\)</span> 中是否存在某状态的工具了。甚至比上一题简单，因为不用写二分和倍增。</p>
<p>值得注意的是如果 <span class="math inline">\(S_{l, r}\)</span> 包含 <span class="math inline">\(T\)</span> 那么还要在后面随便加一个字符以字典序保证严格大于 <span class="math inline">\(T\)</span>。</p>
<details>
<p>值得注意的是因为我写的太丑了以至于在 CF 上会光荣 MLE #46。然后分屏左半边看我代码右半边写的 zwb 却没有。啧。为什么呢。</p>
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;
const int maxm = 35;
const int maxn = 6e5 + 5;
const int maxk = 8e7 + 5;
struct _ &#123;
    int l, f;
    int ne[maxm]; 
    _() &#123;&#125;
    _(int l1, int f1): l(l1), f(f1) &#123;&#125;
&#125;;
_ t[maxn &lt;&lt; 1];
int vis[maxn &lt;&lt; 1];
int fa[maxn][maxm];
int n, la, tot, siz;
struct &#123; int l, r, u; &#125; t1[maxk];
int tab[maxn &lt;&lt; 1], cnt[maxn &lt;&lt; 1];
void Init(void) &#123;
    la = tot = 1;
    t[1] = _(0, 0);
    return;
&#125;
void ext(int c) &#123;
    int p = la, np = ++tot;
    la = tot;
    t[np] = _(t[p].l + 1, 0);
    while (p &amp;&amp; !t[p].ne[c])
        t[p].ne[c] = np, p = t[p].f;
    if (!p)
        t[np].f = 1;
    else &#123;
        int q = t[p].ne[c];
        if (t[q].l == t[p].l + 1)
            t[np].f = q;
        else &#123;
            int nq = ++tot;
            t[nq] = _(t[p].l + 1, t[q].f);
            std::copy(t[q].ne, t[q].ne + 26, t[nq].ne);
            while (p &amp;&amp; t[p].ne[c] == q)
                t[p].ne[c] = nq, p = t[p].f;
            t[q].f = nq;
            t[np].f = nq;
        &#125;
    &#125;
    return;
&#125;
int now = 0;
void ins(int &amp;p, int l, int r, int v) &#123;
    if (!p)
        p = ++now;
    ++t1[p].u;
    if (l == r)
        return;
    int mid = (l + r) &gt;&gt; 1;
    if (v &lt;= mid)
        ins(t1[p].l, l, mid, v);
    else
        ins(t1[p].r, mid + 1, r, v);
    return;
&#125;
int ask(int p, int l, int r, int ql, int qr) &#123;
    if (ql &lt;= l &amp;&amp; r &lt;= qr)
        return t1[p].u;
    int mid = (l + r) &gt;&gt; 1, res = 0;
    if (ql &lt;= mid)
        res = ask(t1[p].l, l, mid, ql, qr);
    if (qr &gt; mid)
        res += ask(t1[p].r, mid + 1, r, ql, qr);
    return res;
&#125;
int merge(int p, int q, int l, int r) &#123;
    if (!p || !q)
        return p + q;
    int np = ++now, mid = (l + r) &gt;&gt; 1;
    t1[np].u = t1[p].u + t1[q].u;
    if (l == r) return np;
    t1[np].l = merge(t1[p].l, t1[q].l, l, mid);
    t1[np].r = merge(t1[p].r, t1[q].r, mid + 1, r);
    return np;
&#125;
int pos[maxn], rt[maxn &lt;&lt; 1];
bool check(int p, int ch, int l, int r) &#123;
    return ask(rt[t[p].ne[ch]], 0, n - 1, l, r) &gt; 0;
&#125;
bool fun(std::string &amp;res, std::string now, std::string &amp;t, int x, int p, int l, int r) &#123;
    // std::cout &lt;&lt; &quot;x = &quot; &lt;&lt; x &lt;&lt; &quot;, now = \&quot;&quot; &lt;&lt; now &lt;&lt; &quot;\&quot;;\n&quot;;
    if (x != (int)t.length() &amp;&amp; check(p, t[x] - &#39;a&#39;, l + x, r) &amp;&amp; fun(res, now + t[x], t, x + 1, ::t[p].ne[t[x] - &#39;a&#39;], l, r))
        return 1;
    for (int i = (x == (int)t.length()) ? 0 : t[x] - &#39;a&#39; + 1; i &lt; 26; ++i) &#123;
        if (check(p, i, l + x, r)) &#123;
            now += i + &#39;a&#39;;
            res = now;
            return 1;
        &#125;
    &#125;
    return 0;
&#125;
std::string solve(std::string &amp;t, int l, int r) &#123;
    std::string res;
    return fun(res, &quot;&quot;, t, 0, 1, l, r) ? res : &quot;-1&quot;;
&#125;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    std::cout.tie(nullptr);
#endif
    int q;
    std::string s;
    std::cin &gt;&gt; s &gt;&gt; q;
    n = (int)s.length();
    Init();
    for (int i = 0; i &lt; n; ++i) &#123;
        ext(s[i] - &#39;a&#39;);
        pos[i] = la;
        ins(rt[la], 0, n - 1, i);
    &#125;
    siz = log(tot) / log(2.0);
    for (int i = 1; i &lt;= tot; ++i)
        ++cnt[t[i].l];
    std::partial_sum(cnt + 1, cnt + tot + 1, cnt + 1);
    for (int i = 1; i &lt;= tot; ++i)
        tab[cnt[t[i].l]--] = i;
    for (int i = 1; i &lt;= tot; ++i) &#123;
        int u = tab[i];
        fa[u][0] = t[u].f;
        for (int j = 1; j &lt;= siz; ++j)
            fa[u][j] = fa[fa[u][j - 1]][j - 1];
    &#125;
    for (int i = tot; i; --i) &#123;
        int u = tab[i];
        if (t[u].f)
            rt[t[u].f] = merge(rt[t[u].f], rt[u], 0, n - 1);
    &#125;
    while (q--) &#123;
        int l, r;
        std::string t;
        std::cin &gt;&gt; l &gt;&gt; r &gt;&gt; t;
        std::cout &lt;&lt; solve(t, l - 1, r - 1) &lt;&lt; &#39;\n&#39;;
    &#125;
    return 0;
&#125;</code></pre>
</details>
<hr />
<h3 id="a.-六出祁山">A. 六出祁山</h3>
<p><a target="_blank" rel="noopener" href="http://222.180.160.110:61235/contest/5170/problem/1" class="uri">http://222.180.160.110:61235/contest/5170/problem/1</a></p>
<p>是能用贪心拿 60pts 的 DP 题 /tuu</p>
<p>需要先把暴力的式子写出来。设 <span class="math inline">\(f_{i, j}\)</span> 为将 <span class="math inline">\(i\)</span> 山修改高度为 <span class="math inline">\(j\)</span> 的代价，则：</p>
<p><span class="math display">\[
f_{i, j} = \min\limits_{k\in [j-d, j+d]}\left\{f_{i-1, k}\right\} + |h_i - j|
\]</span></p>
<p>注意到可以单调队列优化。但是这样做复杂度还是 <span class="math inline">\(O(nV)\)</span> 的，根本原因在于第二维这个 <span class="math inline">\(V\)</span> 的状态数太多了。</p>
<p>根据直觉，最后 <span class="math inline">\(j\)</span> 的值应为 <span class="math inline">\(k+d\)</span> 或 <span class="math inline">\(k-d\)</span> 或 <span class="math inline">\(a_i\)</span>。也就是说，我们可以认为，合法的状态数为所有的 <span class="math inline">\(a_i+x\times d, x\in[-n, n]\)</span>。</p>
<details>
<p><summary>正确性证明……</summary></p>
<p>考虑全部更改完后的结束状态，即最后的最优状态。</p>
<p>考虑所有山中最矮的山 <span class="math inline">\(i\)</span>，此山的高度要么为 <span class="math inline">\(h_i\)</span>，要么为前一座山的高度 <span class="math inline">\(-d\)</span>，要么为后一座山的高度 <span class="math inline">\(-d\)</span>。</p>
<p>考虑第二矮的山，以此类推即可。</p>
</details>
<p>将第二维的状态集大小减少为 <span class="math inline">\(O(n^2)\)</span>，总时间复杂度为 <span class="math inline">\(O(n^3)\)</span>。</p>
<details>
<p>需注意到因为 <span class="math inline">\(a_i+x\times d\)</span> 中的 <span class="math inline">\(x\)</span> 范围为 <span class="math inline">\([-n, n]\)</span> 共 <span class="math inline">\(2\times n\)</span>，所以 DP 数组第二维大小一定要开 <span class="math inline">\(2\times n^2\)</span> 呀！！！</p>
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;
using ll = long long;
const int maxn = 305;
const int maxm = 18e4 + 5;
const ll inf = 0x3f3f3f3f3f3f3f3f;
ll d;
int n;
ll h[maxn];
ll f[maxn][maxm];
int main() &#123;
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    std::cout.tie(nullptr);
    memset(f, 0x3f, sizeof (f));
    std::cin &gt;&gt; n &gt;&gt; d;
    std::vector&lt;ll&gt; st;
    for (int i = 1; i &lt;= n; ++i) &#123;
        std::cin &gt;&gt; h[i];
        for (ll j = -n; j &lt;= n; ++j)
            st.push_back(h[i] + j * d);
    &#125;
    std::sort(st.begin(), st.end());
    st.erase(std::unique(st.begin(), st.end()), st.end());
    auto abs = [&amp;](ll x) -&gt; ll &#123; return x &gt;= 0 ? x : -x; &#125;;
    f[1][lower_bound(st.begin(), st.end(), h[1]) - st.begin()] = 0;
    for (int i = 2; i &lt;= n; ++i) &#123;
        int h(1), t(0), p(-1);
        static int q[maxm];
        for (int j = 0; j &lt; (int)st.size(); ++j) &#123;
            while (p &lt; (int)st.size() &amp;&amp; st[p + 1] &lt;= st[j] + d) &#123;
                ++p;
                while (h &lt;= t &amp;&amp; f[i - 1][p] &lt;= f[i - 1][q[t]])
                    --t;
                q[++t] = p;
            &#125;
            while (h &lt;= t &amp;&amp; st[q[h]] &lt; st[j] - d)
                ++h;
            if (h &lt;= t)
                f[i][j] = std::min(inf, f[i - 1][q[h]] + abs(st[j] - ::h[i]));
        &#125;
    &#125;
    ll res = f[n][std::lower_bound(st.begin(), st.end(), h[n]) - st.begin()];
    std::cout &lt;&lt; (res == inf ? -1 : res) &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;</code></pre>
</details>
<hr />
<h3 id="b.-水淹七军">B. 水淹七军</h3>
<p><a target="_blank" rel="noopener" href="http://222.180.160.110:61235/contest/5170/problem/2" class="uri">http://222.180.160.110:61235/contest/5170/problem/2</a></p>
<p>容易发现最后连出来一定是没有环的。所以一定是一个 DAG。</p>
<p>我们知道状态压缩是会遍历到每一种情况的，所以我们可以假设当前的 DAG 就是该状态下的最优。</p>
<p>至于这个「最优」如何定义就要交给我们了。我们不妨强制认为这个 DAG 是按层序遍历得到的，也就是说连续遍历到的点属于同一层（这里的层是指某点到任意源点的最长路长度）。</p>
<p>显然只有一组相互之间没有任何连边的点才能组成同一层。不妨枚举点集然后暴力转移，转移时记录路径即可。</p>
<details>
<p>注意到在写这玩意儿的时候我还不会 <a href="/2024/05/17/20240517/">状压枚举子集</a>，所以枚举子集的部分可能打得比较抽象。</p>
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;
const int maxn = 25;
const int inf = 0x3f3f3f3f;
const int maxm = (1 &lt;&lt; 16) + 5;
int n, res;
int tag[maxn][maxn];
int f[maxn], g[maxn];
int solve(std::vector&lt;int&gt;&amp; a) &#123;
    static int g[maxn];
    static int f[maxm], p[maxm];
    int n(a.size()), siz(1 &lt;&lt; n);
    std::fill(g, g + n, 0);
    std::fill(p, p + siz + 1, 0);
    std::fill(f, f + siz + 1, inf);
    std::vector&lt;int&gt; st;
    for (int i = 0; i &lt; n; ++i) &#123;
        for (int j = 0; j &lt; n; ++j) &#123;
            if (::g[a[i]] &amp; (1 &lt;&lt; a[j]))
                g[i] |= 1 &lt;&lt; j;
        &#125;
    &#125;
    for (int i = 1; i &lt; siz; ++i) &#123;
        int now = 0;
        for (int j = 0; j &lt; n; ++j) &#123;
            if (i &amp; (1 &lt;&lt; j))
                now |= g[j];
        &#125;
        if (!(now &amp; i))
            st.push_back(i), f[i] = 0, p[i] = i;
        for (auto j : st) &#123;
            if (!(i &amp; j)) &#123;
                if (f[i | j] &gt; f[i] + 1)
                    f[i | j] = f[i] + 1, p[i | j] = j;
            &#125;
        &#125;
    &#125;
    int now = siz - 1;
    while (now) &#123;
        int fa = now ^ p[now];
        for (int i = 0; i &lt; n; ++i)
            if (p[now] &amp; (1 &lt;&lt; i))
                for (int j = 0; j &lt; n; ++j)
                    if ((fa &amp; (1 &lt;&lt; j)) &amp;&amp; tag[a[j]][a[i]] == 2)
                        tag[a[j]][a[i]] = 1, tag[a[i]][a[j]] = -1;
        now = fa;
    &#125;
    return f[siz - 1];
&#125;
int find(int x) &#123;
    return x == f[x] ? x : f[x] = find(f[x]);
&#125;
int main() &#123;
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    std::cout.tie(nullptr);
    int m;
    std::cin &gt;&gt; n &gt;&gt; m;
    std::vector&lt;std::pair&lt;int, int&gt; &gt; edge;
    for (int i = 0; i &lt; n; ++i)
        f[i] = i;
    while (m--) &#123;
        int x, y;
        std::cin &gt;&gt; x &gt;&gt; y;
        edge.emplace_back(--x, --y);
        f[find(x)] = find(y);
        g[x] |= 1 &lt;&lt; y;
        g[y] |= 1 &lt;&lt; x;
        tag[x][y] = tag[y][x] = 2;
    &#125;
    std::vector&lt;int&gt; ver[maxn];
    for (int i = 0; i &lt; n; ++i) &#123;
        ver[find(i)].push_back(i);
    &#125;
    for (int i = 0; i &lt; n; ++i) &#123;
        if (f[i] == i)
            res = std::max(res, solve(ver[i]));
    &#125;
    std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
    for (auto i : edge) &#123;
        if (tag[i.first][i.second] == 1)
            std::cout &lt;&lt; i.first + 1 &lt;&lt; &#39; &#39; &lt;&lt; i.second + 1 &lt;&lt; &#39;\n&#39;;
        else std::cout &lt;&lt; i.second + 1 &lt;&lt; &#39; &#39; &lt;&lt; i.first + 1 &lt;&lt; &#39;\n&#39;;
    &#125;
    return 0;
&#125;</code></pre>
</details>
<hr />
<h3 id="c.-煮酒论英雄">C. 煮酒论英雄</h3>
<p><a target="_blank" rel="noopener" href="http://222.180.160.110:61235/contest/5170/problem/3" class="uri">http://222.180.160.110:61235/contest/5170/problem/3</a></p>
<p>注意到如果存在串被其他串包含那么直接将其毙掉就可以了。</p>
<p>对于相互不完全包含的串，我们令 <span class="math inline">\(mx_{i, j, 0/1, 0/1}\)</span> 表示将正序 / 逆序的 <span class="math inline">\(i\)</span> 串拼到正序 / 逆序的 <span class="math inline">\(j\)</span> 串之前，两者共用相接公共部分的串长。这个可以用字符串哈希暴力求。</p>
<p>用状压枚举拼接顺序，求得最小总串长即可。</p>
<p>注意如果去掉被包含串后 <span class="math inline">\(n=1\)</span> 时需直接输出串的 border；以及答案需和 <span class="math inline">\(2\)</span> 取 <span class="math inline">\(\max\)</span>。</p>
<p>实现起来又臭又长，但实际上思路确实非常简单。</p>
<details>
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;
using ll = long long;
const int p = 131;
const int maxn = 25;
const int lim = 2e4;
const int maxl = 2e4 + 5;
const int mod = 998244353;
const int inf = 0x3f3f3f3f;
const int maxm = (1 &lt;&lt; 16) + 5;
int n;
std::vector&lt;std::string&gt; s;
std::vector&lt;std::vector&lt;ll&gt; &gt; h[2];
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    std::cout.tie(nullptr);
#endif
    std::cin &gt;&gt; n;
    s.resize(n);
    h[0].resize(n);
    h[1].resize(n);
    static ll base[maxl];
    static bool del[maxn];
    base[0] = 1;
    for (int i = 1; i &lt;= lim; ++i)
        base[i] = base[i - 1] * p % mod;

    for (int i = 0; i &lt; n; ++i) &#123;
        std::cin &gt;&gt; s[i];
        h[0][i].resize((int)s[i].length());
        h[1][i].resize((int)s[i].length());
        ll x = 0;
        for (int j = 0; j &lt; (int)s[i].length(); ++j, (x *= p) %= mod)
            h[0][i][j] = ((x += s[i][j]) %= mod);
        std::reverse(s[i].begin(), s[i].end());
        x = 0;
        for (int j = 0; j &lt; (int)s[i].length(); ++j, (x *= p) %= mod)
            h[1][i][j] = ((x += s[i][j]) %= mod);
        std::reverse(s[i].begin(), s[i].end());
    &#125;

    std::vector&lt;int&gt; tab;
    auto gethash = [&amp;](int i, int l, int r, bool t) -&gt; ll &#123;
        if (l &gt; r) return 0;
        ll res = (h[t][i][r] - (l ? h[t][i][l - 1] : 0) * base[r - l + 1] % mod);
        return (res % mod + mod) % mod;
    &#125;;
    // ll now = 0;
    // for (int i = 0; i &lt;= 4; ++i)
    //     now = (now * p + s[1][i]) % mod;
    // printf(&quot;now = %lld\n&quot;, now);
    // now = 0;
    // for (int i = 3; i &lt;= 7; ++i)
    //     now = (now * p + s[0][i]) % mod;
    // printf(&quot;now = %lld\n&quot;, now);
    // printf(&quot;# %lld\n&quot;, h[0][0].back());
    for (int i = 0; i &lt; n; ++i) &#123;
        tab.push_back(i);
        for (int j = 0; j &lt; n; ++j)
            if (!del[j] &amp;&amp; i != j)
                for (int k = 0; k &lt;= ((int)s[j].length()) - ((int)s[i].length()); ++k) &#123;
                    // printf(&quot;i = %d, j = %d, k = %d, %lld / %lld\n&quot;, i, j, k,
                    //         gethash(i, 0, ((int)s[i].length()) - 1, 0), gethash(j, k, k + ((int)s[i].length()) - 1, 0));
                    if (h[0][i].back() == gethash(j, k, k + ((int)s[i].length()) - 1, 0)) &#123;
                        tab.pop_back();
                        del[i] = 1;
                        goto outo;
                    &#125;
                &#125;
        outo: ;
    &#125;
    n = (int)tab.size();
    if (n == 1) &#123;
        int border;
        for (border = ((int)s[tab[0]].length()) - 1; ~border; --border) &#123;
            if (gethash(tab[0], 0, border - 1, 0) == gethash(tab[0], ((int)s[tab[0]].length()) - border, ((int)s[tab[0]].length()) - 1, 0))
                break;
        &#125;
        std::cout &lt;&lt; std::max(2, ((int)s[tab[0]].length()) - border) &lt;&lt; &#39;\n&#39;;
    &#125;
    else &#123;
        static int mx[maxn][maxn][2][2];
        for (int i = 0; i &lt; n; ++i)
            for (int j = 0; j &lt; n; ++j)
                for (int a = 0; a &lt; 2; ++a)
                    for (int b = 0; b &lt; 2; ++b)
                        for (int k = std::min((int)s[tab[i]].length(), (int)s[tab[j]].length()); ~k; --k) &#123;
                            if (gethash(tab[i], ((int)s[tab[i]].length()) - k, ((int)s[tab[i]].length()) - 1, a) ==
                                                                                            gethash(tab[j], 0, k - 1, b)) &#123;
                                mx[i][j][a][b] = (int)s[tab[j]].length() - k;
                                // printf(&quot;%d(%d) + %d(%d) = %d, k = %d\n&quot;, i, a, j, b, mx[i][j][a][b], k);
                                break;
                            &#125;
                        &#125;
        static int f[maxm][maxn][2];
        memset(f, 0x3f, sizeof (f));

        int siz = 1 &lt;&lt; n, res = inf;
        f[1][0][0] = (int)s[tab[0]].length();
        for (int i = 1; i &lt; siz; ++i)
            for (int j = 0; j &lt; n; ++j)
                if (i &amp; (1 &lt;&lt; j))
                    for (int a = 0; a &lt; 2; ++a) &#123;
                        // printf(&quot;f[%d][%d][%d] = %d\n&quot;, i, j, a, f[i][j][a]);
                        for (int k = 0; k &lt; n; ++k)
                            if (!(i &amp; (1 &lt;&lt; k)))
                                for (int b = 0; b &lt; 2; ++b)
                                    f[i | (1 &lt;&lt; k)][k][b] = std::min(f[i | (1 &lt;&lt; k)][k][b], f[i][j][a] + mx[j][k][a][b]);
                        if (i == siz - 1)
                            res = std::min(res, f[i][j][a] - (int)s[tab[0]].length() + mx[j][0][a][0]);
                    &#125;
        
        std::cout &lt;&lt; std::max(2, res) &lt;&lt; &#39;\n&#39;;
    &#125;
    return 0;
&#125;</code></pre>
</details>
<hr />
<h3 id="a.-捏斑马">A. 捏斑马</h3>
<p><a target="_blank" rel="noopener" href="http://222.180.160.110:61235/contest/5175/problem/1" class="uri">http://222.180.160.110:61235/contest/5175/problem/1</a></p>
<p>我甚至不会（）</p>
<p>翻转 + 拼接本质上就是首尾相接。我们把字符串整个拼到自己后边儿，然后任取一段长度为 <span class="math inline">\(n\)</span> 的串就可以得到一个倒过来的操作后的字符串。</p>
<p>注意到可以操作很多次。但是既然我们操作后的串也可以在这个拼接后的串中找到了，那么其实多次操作后的也行。</p>
<p>所以呢我们在拼接后的串种枚举每一个长度为 <span class="math inline">\(n\)</span> 的串计算答案即可。</p>
<p>具体怎么算呢？注意到只看开头，也就是在新串中只看离我们当前枚举的右端点最近的那一段，所以我们打一个双指针，看这一段是否在右移后仍然合法，如果非法就把答案区间左端点更新为右端点自己。以及注意到左右端点的距离不能超过 <span class="math inline">\(n\)</span>。</p>
<details>
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;
int res;
std::string s;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    std::cout.tie(nullptr);
#endif
    std::cin &gt;&gt; s;
    int l = 0, r = -1, n = (int)s.length();
    char la = 0;
    s += s;
    while (++r &lt; (int)s.length()) &#123;
        if (s[r] == la)
            l = r;
        while (r - l + 1 &gt; n) ++l;
        la = s[r];
        res = std::max(res, r - l + 1);
    &#125;
    std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;</code></pre>
</details>
<hr />
<h3 id="d.-链状闪电">D. 链状闪电</h3>
<p><a target="_blank" rel="noopener" href="http://222.180.160.110:61235/contest/5175/problem/4" class="uri">http://222.180.160.110:61235/contest/5175/problem/4</a></p>
<p>莫名其妙且又臭又长的根号做法。</p>
<p>容易发现一个怪被杀掉了序列就会裂开成两段连续子序列，以及最先被杀掉的怪物一定血量最少。在裂开来的两段连续子序列中也满足此规律，以此类推。</p>
<p>考虑对序列建立笛卡尔树。令树根为 <span class="math inline">\(rt\)</span>，当前攻击力为 <span class="math inline">\(k\)</span>，记 <span class="math inline">\(t_{x, k}=\left\lceil \dfrac {h_x}k \right\rceil\)</span>，即不考虑其他条件时击倒 <span class="math inline">\(x\)</span> 所需次数。</p>
<p>那么对于 <span class="math inline">\(rt\)</span> 的左、右儿子 <span class="math inline">\(l,r\)</span>，单考虑这三个怪物所需的总击倒次数，容易发现为 <span class="math inline">\(t_{rt,k}+(t_{l,k}-t_{rt,k})+(t_{r,k}-t_{rt,k})\)</span>。</p>
<p>对于 <span class="math inline">\(l\)</span> 引导的子树，此时的实际已攻击次数为 <span class="math inline">\(t_{l,k}\)</span>；所以对于 <span class="math inline">\(l\)</span> 的左右儿子 <span class="math inline">\(l&#39;,r&#39;\)</span>，击倒这两个怪物的所需次数为 <span class="math inline">\((t_{l&#39;,k} - t_{l,k})+(t_{r&#39;,k}-t_{l,k})\)</span>。<span class="math inline">\(r\)</span> 引导的子树同理。</p>
<p>所以我们就可以知道，如果存在树边 <span class="math inline">\(u\to v\)</span>，那么击倒 <span class="math inline">\(v\)</span> 的所需次数为 <span class="math inline">\(t_{v,k}-t_{u,k}\)</span>；特别地，击倒 <span class="math inline">\(rt\)</span> 的所需次数为 <span class="math inline">\(t_{rt,k}\)</span>。</p>
<p>那么我们就可以通过一次 <span class="math inline">\(O(n)\)</span> 的树上 DFS 对于一个 <span class="math inline">\(k\)</span> 找到答案了。</p>
<p>那么对于 <span class="math inline">\(2\times 10^4\)</span> 范围内的所有 <span class="math inline">\(k\)</span>，应该怎么办呢？这个时候就要利用 <span class="math inline">\(t\)</span> 的性质进行根号分治了。</p>
<ul>
<li><p>对于 <span class="math inline">\(k\le \sqrt {2\times 10^4}\)</span>，我们大可以直接做这么多次 DFS 得到答案；</p></li>
<li><p>对于 <span class="math inline">\(k&gt;\sqrt {2\times 10^4}\)</span>：</p>
<p>我们容易发现最终的结果是若干个 <span class="math inline">\(t\)</span> 的值相加减得到的，而每个 <span class="math inline">\(t\)</span> 的权值 <span class="math inline">\(cnt\)</span> 取决于其在笛卡尔树上的儿子个数，有多少就在 <span class="math inline">\(1\)</span> 的基础上减去多少。</p>
<p>由于 <span class="math inline">\(t\)</span> 实在过于特殊，考虑整除分块 / 数论分块。对于每个 <span class="math inline">\(x\)</span>，对于任意 <span class="math inline">\(k&#39;\in (\sqrt {2\times 10^4}, 2\times 10^4]\)</span>，可能的 <span class="math inline">\(t\)</span> 值只有 <span class="math inline">\(\sqrt {2\times 10^4 }\)</span> 种。计算出对于每个 <span class="math inline">\(t&#39;\)</span>，满足 <span class="math inline">\(\left\lceil \dfrac {h_x}{k&#39;} \right\rceil=t&#39;\)</span> 的 <span class="math inline">\(k&#39;\)</span> 范围，对该范围 <span class="math inline">\(k&#39;\)</span> 的答案区间加上 <span class="math inline">\(t&#39;\times cnt\)</span> 即可，可以使用差分。</p>
<p>至此，就可以在一次 DFS 内解决这种情况下的问题。</p></li>
</ul>
<p>总时间复杂度为 <span class="math inline">\(O(n\sqrt {2\times 10^4})\)</span>。</p>
<details>
<p>值得注意的是，我在做这道题的时候并没有意识到自己用到了笛卡尔树，</p>
<p>所以代码中笛卡尔树的建树部分可能长得特别抽象（</p>
<p>这里是使用了下标上的 ST 表带 log 地求解了左右儿子。</p>
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;
const int maxm = 35;
const int maxn = 1e5 + 5;
using ll = long long;
ll res;
int n, k, l;
int g[maxn][2];
int f[maxn][maxm];
int a[maxn], t[maxn];
ll dif[maxn], cnt[maxn];
int ask(int l, int r) &#123;
    if (l &gt; r) return 0;
    int k = log(r - l + 1) / log(2.0);
    return (a[f[l][k]] &lt; a[f[r - (1 &lt;&lt; k) + 1][k]]) ? f[l][k] : f[r - (1 &lt;&lt; k) + 1][k];
&#125;
void bld(int rt, int l, int r) &#123;
    if (rt != l) &#123;
        g[rt][0] = ask(l, rt - 1);
        bld(g[rt][0], l, rt - 1);
    &#125;
    if (rt != r) &#123;
        g[rt][1] = ask(rt + 1, r);
        bld(g[rt][1], rt + 1, r);
    &#125;
    return;
&#125;
// k &lt;= sqrt(lim)
void DFS(int x, int k, int fa) &#123;
    t[x] = (a[x] + k - 1) / k;
    res += t[x] - t[fa];
    for (int i = 0; i &lt; 2; ++i) &#123;
        if (g[x][i])
            DFS(g[x][i], k, x);
    &#125;
    return;
&#125;
// k &gt; sqrt(lim)
void DFS(int x, int fa) &#123;
    ++cnt[x];
    --cnt[fa];
    for (int i = 0; i &lt; 2; ++i) &#123;
        if (g[x][i])
            DFS(g[x][i], x);
    &#125;
    int l = k + 1, r;
    // 注意这里 i 的范围判定，如果直接写成 i * i &lt;= k 会少计算一些情况
    for (int i = 1; (i - 1) * (i - 1) &lt; k; ++i) &#123;
        r = l - 1;
        l = (a[x] + i - 1) / i;
        // fprintf(stderr, &quot;%d: [%d, %d] += %d * %d\n&quot;, a[x], l, r, cnt[x], i);
        dif[l] += i * cnt[x], dif[r + 1] -= i * cnt[x];
    &#125;
    return;
&#125;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    std::cout.tie(nullptr);
#endif
    std::cin &gt;&gt; n;
    for (int i = 1; i &lt;= n; ++i) &#123;
        std::cin &gt;&gt; a[i];
        f[i][0] = i;
        k = std::max(k, a[i]);
    &#125;
    for (int j = 1; (1 &lt;&lt; j) &lt;= n; ++j)
        for (int i = 1; i + (1 &lt;&lt; j) - 1 &lt;= n; ++i)
            f[i][j] = (a[f[i][j - 1]] &lt; a[f[i + (1 &lt;&lt; (j - 1))][j - 1]]) ? f[i][j - 1] : f[i + (1 &lt;&lt; (j - 1))][j - 1];
    int rt = ask(1, n);
    bld(rt, 1, n);
    for (int i = 1; i * i &lt;= k; ++i) &#123;
        res = 0;
        DFS(rt, i, 0);
        std::cout &lt;&lt; res &lt;&lt; &#39; &#39;;
        l = i + 1;
    &#125;
    // fputs(&quot;\n&quot;, stderr);
    DFS(rt, 0);
    std::partial_sum(dif + 1, dif + k + 1, dif + 1);
    for (int i = l; i &lt;= k; ++i)
        std::cout &lt;&lt; dif[i] &lt;&lt; &#39; &#39;;
    std::cout &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;</code></pre>
</details>
<hr />
<h3 id="f.-弹飞绵羊">F. 弹飞绵羊</h3>
<p><a target="_blank" rel="noopener" href="http://222.180.160.110:61235/contest/5175/problem/6" class="uri">http://222.180.160.110:61235/contest/5175/problem/6</a></p>
<p>很棒可持久化分块，使我 lxl 旋转。</p>
<p>笑话：赛后 5s 才交上去。然后 A 了。</p>
<p>我们猜大家都会普通的弹飞绵羊这道题。就是块间暴力跳嘛。</p>
<p>这里给一个我自己整的简单实现方法。</p>
<p>我们把分出来的块视作若干个无关联的散块并纳入块集合；对于每一个版本，用一个大小为 <span class="math inline">\(\sqrt n\)</span> 的 <span class="math inline">\(id\)</span> 数组记录每一位置的块在块集合中对应的位置。</p>
<p>然后该怎么搞怎么搞即可。</p>
<p>P.S. zwb 坚定不移信仰 lxl 神教于是决定用可持久化平衡树实现可持久化分块，结果当然是因为多了个 <span class="math inline">\(\log\)</span> 被卡飞了，最后气急败坏慌不择路恼羞成怒抄起了我的代码。</p>
<details>
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;
const int maxk = 320;
const int maxn = 2e5 + 5;
class devicer &#123;
public:
    int l, r;
    std::vector&lt;int&gt; ne, u, a;
    int &amp;nex(int x);
    int &amp;val(int x);
&#125;;
int id[maxn][maxk];
std::vector&lt;devicer&gt; b;
int n, q, ty, siz, k, la;
int a[maxn], tab[maxn], blk[maxn];
void upd(int x, int a, devicer &amp;p) &#123;
    if (x + a &gt; n)
        p.nex(x) = -1, p.val(x) = 1;
    else if (x + a &gt; p.r)
        p.nex(x) = x + a, p.val(x) = 1;
    else
        p.nex(x) = p.nex(x + a), p.val(x) = p.val(x + a) + 1;
    // printf(&quot;x = %d, a = %d, r = %d, upd ne[%d] to %d\n&quot;, x, a, p.r, x, p.nex(x));
    return;
&#125;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    std::cout.tie(nullptr);
#endif
    std::cin &gt;&gt; n &gt;&gt; q &gt;&gt; ty;
    siz = sqrt(n);
    k = (n + siz - 1) / siz;
    b.resize(k);
    int la = 0, now = k - 1;
    for (auto &amp;i : b)
        i.l = la + 1, la = i.r = i.l + siz - 1;
    b.back().r = n;
    for (int i = 0; i &lt; k; ++i) &#123;
        id[0][i] = i;
        b[i].a.resize(b[i].r - b[i].l + 1);
        b[i].u.resize(b[i].r - b[i].l + 1);
        b[i].ne.resize(b[i].r - b[i].l + 1);
        for (int j = b[i].l; j &lt;= b[i].r; ++j)
            tab[j] = j - b[i].l, blk[j] = i;
    &#125;
    for (int i = 1; i &lt;= n; ++i)
        std::cin &gt;&gt; b[blk[i]].a[tab[i]];
    for (int i = n; i; --i)
        upd(i, b[blk[i]].a[tab[i]], b[blk[i]]);
    int ver = 0;
    while (q--) &#123;
        int op, pr, x;
        static int res = 0;
        std::cin &gt;&gt; op &gt;&gt; pr &gt;&gt; x;
        if (!ty)
            res = 0;
        x ^= res;
        if (op == 1) &#123;
            std::copy(id[pr], id[pr] + k, id[++ver]);
            b.push_back(b[id[ver][blk[x]]]);
            id[ver][blk[x]] = ++now;
            std::cin &gt;&gt; b.back().a[tab[x]];
            b.back().a[tab[x]] ^= res;
            for (int i = x; i &gt;= b.back().l; --i)
                upd(i, b.back().a[tab[i]], b.back());
        &#125;
        else &#123;
            int p = x;
            res = 0;
            while (~p) &#123;
                // printf(&quot;p = %d\n&quot;, p);
                res += b[id[pr][blk[p]]].u[tab[p]];
                p = b[id[pr][blk[p]]].ne[tab[p]];
            &#125;
            std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
        &#125;
    &#125;
    return 0;
&#125;
int&amp; devicer::nex(int x) &#123;
    return ne[tab[x]];
&#125;
int&amp; devicer::val(int x) &#123;
    return u[tab[x]];
&#125;</code></pre>
</details>

			</div>
			<hr class="dotted">
			<div class="post footer">
				<div id="hitokoto">
					<h3 id="hitokoto-title">
						言论
					</h3>
					<div id="hitokoto-content">
					</div>
					<div id="hitokoto-from">
					</div>
				</div>
				<div class="button flex">
					<div id="prev">
						
							<!-- 吐槽，为啥还需要加 / -->
							<a href="/20240517/">
								<i class="fas fa-angle-double-left" style="margin-right: 10px;"></i>
								状压枚举子集 + 高维前缀和
							</a>
						
					</div>
					<div id="next">
						
							<a href="/20240206/">
								曼哈顿最小距离生成树
								<i class="fas fa-angle-double-right" style="margin-left: 10px;"></i>
							</a>
						
					</div>
				</div>
				<div id="vcomments" class="yahei"></div>
<script>
	new Valine({
		el: '#vcomments',
		appId: 'OlmvQ0a2Zw7xo3no2bwabOzx-gzGzoHsz',
		appKey: 'TW6t8mFeGLmhPjWisvmllvvo',
		recordIP: true,
		enableQQ: true, 
		// 目前 Valine 的 QQ 自动获取昵称似乎不可用 故不建议开启
		pageSize: 10,
		requiredFields:
			
				['nick']
			,
		placeholder: "The world is but a little place after all...\n能够根据邮箱获取你的 Gravatar 头像。昵称是必填项，长度需不低于 3。",
		avatar: 'mp',
		avatar_cdn: 'https://cravatar.cn/avatar/',
		emojiCDN: 'https://xsc062.netlify.app/em/', 
		emojiMaps: {
			
				"微笑": "wx.gif",
			
				"龇牙": "cy.gif",
			
				"流泪": "ll.gif",
			
				"笑哭": "xk.gif",
			
				"流汗": "lh.gif",
			
				"擦汗": "ch.gif",
			
				"亲亲": "qq.gif",
			
				"色": "se.gif",
			
				"疑问": "yiw.gif",
			
				"发呆": "fd.gif",
			
				"晕": "yun.gif",
			
				"鼓掌": "gz.gif",
			
				"憨笑": "hanx.gif",
			
				"快哭了": "kk.gif",
			
				"得意": "dy.gif",
			
				"狂笑": "kx.gif",
			
				"害羞": "hx.gif",
			
				"妈妈生的": "dz.gif",
			
				"糗大了": "qd.gif",
			
				"吃瓜": "cg.gif",
			
				"睁眼": "zy.webp",
			
				"辣眼睛": "lyj.gif",
			
				"酸了": "nm.gif",
			
				"滚": "gun.webp",
			
				"惊恐": "jk.gif",
			
				"幽灵": "youl.gif",
			
				"无聊": "wul.gif",
			
				"吃": "eat.gif",
			
				"你很棒棒": "bb.gif",
			
				"赞": "qiang.gif",
			
				"踩": "ruo.gif",
			
				"握手": "wsh.gif",
			
				"发抖": "fad.gif",
			
				"挥手": "hsh.gif",
			
				"磕头": "kt.gif",
			
				"怄火": "oh.gif",
			
		},
	})
</script>
			</div>
			<script>setHitokoto();</script>
		</div> 
	</div>
</div>
    <!-- 页脚开始 -->
<div id="footer" class="yahei">
    Powered by
    <a target="_blank" rel="noopener" href="https://hexo.io">
        Hexo
    </a>
    &
    <a href="/about-this-theme">
        iwll
    </a>
    <p style="margin-top: 5px;">
        2021 - 2025
    </p>
</div>
<!-- Valine 相关配置 -->
<script>
    const getValineDomTimer = setInterval(() => {
        // 不知道为什么 我从原博客 js 文件粘过来的参数是
        // "#valine .vcards .vcard"
        // DEBUG 了半天才定位到这个问题。。。
        const vcards =
            document.querySelectorAll('#valine, .vcards, .vcard');
        if (vcards.length > 0) {
            let author = 'XSC062';
            for (let vcard of vcards) {
                const vnick_dom = vcard.querySelector('.vhead .vnick');
                if (vnick_dom != null) {
                    const vnick = vnick_dom.innerHTML;
                    if (vnick === author) {
                        vnick_dom.innerHTML =
                        `${vnick} <span id="rootitem" class="fira">root</span>`
                    }
                }
            }
        }
        else {
            clearInterval(getValineDomTimer);
        }
    }, 2000);
    SetActiveItem();
    setDetailsSummary();
    setTitleAnchor();
    setEmptyToc();
    setCodeClassName();
</script>


<!-- js -->
<!-- 搜索功能相关配置 -->

<script src="/js/search.js"></script>


<script src="/js/local-search.js"></script>

</script>
<!-- prism 相关配置 -->
<script type="text/javascript" src="/js/prism.js" defer></script>
<!-- 代码块复制功能 -->
<script type="text/javascript" src="/js/clipboard.min.js"></script>
<script type="text/javascript" src="/js/clipboard-use.js"></script>
<!-- 页脚结束 -->
</body>
</html>