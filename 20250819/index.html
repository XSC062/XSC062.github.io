<!DOCTYPE html>
<html>
<head>
    <!-- 网站图标 -->
<link rel="icon" type="image/png" sizes="32x32" href="/images/icon.svg">
<!-- 其他图标支持 -->
<link rel="stylesheet" href="/css/facss/fa-brands.min.css">
<link rel="stylesheet" href="/css/facss/fa-regular.min.css">
<link rel="stylesheet" href="/css/facss/fa-solid.min.css">
<link rel="stylesheet" href="/css/facss/fontawesome.min.css">
<link rel="stylesheet" href="/css/facss/fontawesome-all.css">
<link href="https://use.fontawesome.com/releases/v5.0.4/css/all.css" rel="stylesheet">
<!-- 网站标题 -->
<title>
	
		杂题选谈：log 数据结构 -
	
	XSC062 的博客
</title>
<!-- js 引入 -->
<script>
const searchPath = "/search.xml"
</script>

<script src="/js/afterloaded.js"></script>


<script src="/js/jQuery.js"></script>

<!-- 载入 Valine -->

<script src="/js/Valine.min.js"></script>

<!-- css 引入 -->

<link rel="stylesheet" href="/css/layout.css">


<link rel="stylesheet" href="/css/prcss/prism.css">



<!-- rss -->
<link rel="alternate" type="application/rss+xml" title="" href="https://xsc062.netlify.app/rss.xml" />
<link rel="alternate" type="application/atom+xml" title="" href="https://xsc062.netlify.app/atom.xml" />
<link rel="alternate" type="application/json" title="" href="https://xsc062.netlify.app/feed.json" />

<meta charset="utf-8"> 
    
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
          tex2jax: {
            inlineMath: [ ['$','$'], ["\\(","\\)"] ],
            processEscapes: true
          }
        });
      </script>
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
            tex2jax: {
              skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
            }
          });
      </script>
    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
              var all = MathJax.Hub.getAllJax(), i;
              for(i=0; i < all.length; i += 1) {
                  all[i].SourceElement().parentNode.className += ' has-jax';
              }
          });
      </script>
    <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS_CHTML"></script>

<meta name="generator" content="Hexo 7.2.0"></head>
<body class="line-numbers match-braces no-brace-select rainbow-braces">
	<!-- 搜索 -->
<script>
	function closeSearchBox() {
		$("#search-bg").css("transition", "null"); 
		$("#search-bg").css("z-index", "-1"); 
		$("#search-bg").css("opacity", "0%");
		return;
	}
</script>
<div id="search-bg">
	<div id="search-box">
		<button id="close-button" onclick="closeSearchBox()">
			<i class="fas fa-times"></i>
		</button>
		<input type="text" id="search-input" placeholder="Type to search...">
		<div id="search-results">
			<div id="emptyInput">
				<p>键入以搜索…</p>
				<p><i>匹配算法</i>：把输入按空格拆分，单独<strong>匹配</strong>每一段输入（不区分大小写，仅匹配文章文本内容），输出取或后的结果。</p>
				<p>模糊搜索似乎很难搞，目前没有相关打算。</p>
			</div>
		</div>
	</div>
</div>
<!-- 顶栏整体导航菜单 -->
<div class="ui top menu">
	<!-- 左对齐 logo -->
	<a class="logo" href="/">
		<img width="25px" height="25px" style="border: solid transparent 2.5px" src="/images/icon.svg"></img>
		<div id="bartitle" class="text">
			XSC062 的博客
		</div>
	</a>
	<!-- 右对齐部分导航 -->
	<div id="rightali" class="serif">
		<a class="item" id="Search" type="button">
			<i class="btn text-muted fa fa-search" id="search-icon" disabled></i>
		</a>
		<a class="item" id="Home" href="/">
			Home
		</a>
		<a class="item" id="Arch" href="/archives">
			Archives
		</a>
		<!-- <a class="item" id="Cate" href="/categories">
			Categories
		</a> -->
		<a class="item" id="Tags" href="/tags">
			Tags
		</a>
		<a class="item" id="Frie" href="/friends">
			Friends
		</a>
		<a class="item" id="Abou" href="/about">
			About
		</a>
	</div>
</div>
    
<link rel="stylesheet" href="/css/post.css">


<script src="/js/post.js"></script>


<div class="main">
	<div id="sidebar" class="text">
		<aside id="toc">
			<span id="toctitle">
				<i class="fas fa-list"></i>
				目录
			</span>
			<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E6%AE%B5%E6%A0%91"><span class="toc-text">线段树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%B4%E6%8A%A4%E7%89%B9%E6%AE%8A%E4%BF%A1%E6%81%AF"><span class="toc-text">维护特殊信息</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%91%E9%B1%BC%E8%8D%89-curtains%E5%8C%BA%E9%97%B4%E8%A6%86%E7%9B%96%E4%BF%A1%E6%81%AF"><span class="toc-text">金鱼草 &#x2F; Curtains（区间覆盖信息）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E6%97%A5-zapatak%E5%93%88%E5%B8%8C"><span class="toc-text">题日 Zapatak（哈希）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%B8%A6%E4%B8%80%E7%82%B9%E9%80%92%E6%8E%A8%E6%80%A7%E8%B4%A8"><span class="toc-text">简单数据结构（带一点递推性质）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%BD%E8%BF%90%E5%88%A9%E7%94%A8%E7%BA%BF%E6%AE%B5%E6%A0%91%E7%9A%84%E5%88%86%E6%B2%BB%E7%BB%93%E6%9E%84%E9%80%92%E6%8E%A8"><span class="toc-text"># 命运（利用线段树的分治结构递推）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E7%88%B1%E7%BB%B4%E6%8A%A4%E5%87%BD%E6%95%B0"><span class="toc-text">* 对数据结构的爱（维护函数）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#compounds%E6%A8%A1%E6%84%8F%E4%B9%89%E4%B8%8B%E9%97%AE%E9%A2%98"><span class="toc-text">* COmPoUNdS（模意义下问题）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%B9%E8%BF%9B%E4%BB%A3%E7%A0%81%E6%A8%A1%E6%84%8F%E4%B9%89%E4%B8%8B%E9%97%AE%E9%A2%98"><span class="toc-text">* 改进代码（模意义下问题）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%BB%91%E7%99%BD%E6%A0%91%E5%BE%88%E6%96%B0%E7%9A%84%E4%B8%9C%E8%A5%BF"><span class="toc-text">黑白树（很新的东西）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A5%E6%A5%BC%E6%88%BF%E9%87%8D%E5%BB%BA%E4%B8%BA%E4%BB%A3%E8%A1%A8%E7%9A%84-log2-%E4%B8%80%E7%B1%BB%E5%89%8D%E7%BC%80%E4%BF%A1%E6%81%AF%E7%BB%B4%E6%8A%A4"><span class="toc-text">以楼房重建为代表的 \(\log^2\) 一类前缀信息维护</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A5%BC%E6%88%BF%E9%87%8D%E5%BB%BA"><span class="toc-text">楼房重建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-text">二叉搜索树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#nastya-and-cbs"><span class="toc-text">Nastya and CBS</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#hungry-cow-p"><span class="toc-text"># Hungry Cow P</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%9B%E5%AE%A2noip%E8%B5%9B%E5%89%8D%E9%9B%86%E8%AE%AD%E8%90%A5-%E6%8F%90%E9%AB%98%E7%BB%84%E7%AC%AC%E5%85%AD%E5%9C%BA%E7%89%9B%E5%8D%8A%E4%BB%99%E7%9A%84%E5%A6%B9%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-text"># 2020牛客NOIP赛前集训营-提高组（第六场）牛半仙的妹子序列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#organizing-a-race"><span class="toc-text"># Organizing a Race</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AC%E7%9B%98"><span class="toc-text"># 转盘</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%8D%E8%BF%9B%E5%9B%9B%E6%A5%BC%E6%88%BF%E9%87%8D%E5%BB%BA-ver"><span class="toc-text"># 前进四（楼房重建 ver）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E7%BA%BF%E6%AE%B5%E6%A0%91"><span class="toc-text">可持久化线段树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#card-game"><span class="toc-text"># Card Game</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%86%E5%8F%B2%E4%BF%A1%E6%81%AF"><span class="toc-text">历史信息</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%93%83%E5%8E%9F%E9%9C%B2%E9%9C%B2"><span class="toc-text">铃原露露</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#prof.-pangs-sequence-test_90"><span class="toc-text">Prof. Pang’s sequence &#x2F; TEST_90</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AF%94%E8%B5%9B"><span class="toc-text"># 比赛</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#v"><span class="toc-text"># V</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#cartesian-tree"><span class="toc-text"># Cartesian Tree</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#rprmq1"><span class="toc-text"># rprmq1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#rpfrdtzls"><span class="toc-text"># rpfrdtzls</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%90%88%E5%B9%B6"><span class="toc-text">线段树合并</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%81%E7%A7%BB%E8%AE%A1%E5%88%92-migration-plan"><span class="toc-text"># 迁移计划 &#x2F; Migration Plan</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B0%B8%E6%97%A0%E4%B9%A1"><span class="toc-text"># 永无乡</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%AD%E8%A8%80"><span class="toc-text"># 语言</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A2%A6%E5%B9%BB%E5%B8%83%E4%B8%81"><span class="toc-text"># 梦幻布丁</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%AB%E6%8F%8F%E7%BA%BF"><span class="toc-text">扫描线</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AD%89%E5%B7%AE%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-text">等差子序列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E5%A5%87%E7%9A%84%E7%B3%96%E6%9E%9C"><span class="toc-text">小奇的糖果</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#rmscne"><span class="toc-text">rmscne</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%9C%E8%89%B2"><span class="toc-text"># 颜色</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E6%AE%B5%E6%A0%91-%E5%8A%BF%E8%83%BD"><span class="toc-text">线段树 + 势能</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%82%E5%9C%BA"><span class="toc-text"># 市场</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#segment-tree-beats"><span class="toc-text"># Segment Tree Beats!</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#segment-tree-beats-plus"><span class="toc-text"># Segment Tree Beats! Plus</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E5%81%87%E5%A5%B3%E9%80%89%E6%89%8B"><span class="toc-text"># 最假女选手</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mzl-loves-segment-tree"><span class="toc-text"># Mzl loves segment tree</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ctsn-loves-segment-tree"><span class="toc-text"># CTSN loves segment tree</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%8D%E8%BF%9B%E5%9B%9Bsegment-tree-beats-ver"><span class="toc-text"># 前进四（segment tree beats ver）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BB%83%E4%B9%A0%E9%A2%98"><span class="toc-text"># 基础数据结构练习题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E6%AE%B5%E6%A0%91-3"><span class="toc-text"># 线段树 3</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B5%9B%E6%A0%BC%E8%92%99%E7%89%B9%E5%BD%BC%E8%8C%A8"><span class="toc-text"># 赛格蒙特彼茨</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A0%95%E5%A4%A9%E4%BD%9C%E6%88%98-test_98"><span class="toc-text"># 堕天作战 TEST_98</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%88%86%E6%B2%BB"><span class="toc-text">线段树分治</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#meetings-%E4%BC%9A%E8%AE%AE"><span class="toc-text"># meetings 会议</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%AB%E7%BA%B5%E5%85%AB%E6%A8%AA"><span class="toc-text"># 八纵八横</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%9B%E5%8D%A1%E5%B0%94%E6%A0%91"><span class="toc-text">笛卡尔树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%B1%E4%B9%83%E6%95%91%E7%88%B7%E7%88%B7"><span class="toc-text">* 由乃救爷爷</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%83%85%E6%99%AF%E5%89%A7%E6%9C%80%E5%80%BC%E7%9A%84%E6%80%A7%E8%B4%A8%E7%BB%B4%E6%8A%A4%E6%96%B9%E5%BC%8F%E7%9A%84%E5%8F%96%E8%88%8D"><span class="toc-text">* 情景剧（最值的性质，维护方式的取舍）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E8%93%9D%E7%9A%84%E5%A5%BD%E5%8F%8B"><span class="toc-text"># 小蓝的好友</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%9F%E7%99%BD-by-ttpandas%E7%AC%9B%E5%8D%A1%E5%B0%94%E6%A0%91-dsu-on-tree"><span class="toc-text">星白 by TTpandaS（笛卡尔树 + dsu on tree）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#periodni"><span class="toc-text"># PERIODNI</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cdq-%E5%88%86%E6%B2%BB"><span class="toc-text">CDQ 分治</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#coloring-nodes%E5%81%8F%E5%BA%8F%E5%BE%88%E9%9A%90%E7%A7%98"><span class="toc-text"># Coloring Nodes（偏序很隐秘）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E5%85%B8%E6%A0%91"><span class="toc-text">字典树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E6%88%96%E7%B2%BD%E5%AD%90"><span class="toc-text"># 异或粽子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#friends"><span class="toc-text"># Friends</span></a></li></ol></li></ol>
		</aside>
	</div>
	<div class="ui post container">
		<div class="ui text container">
			<span id="postcon">
				<span id="postinfo">
					<div class="ui post title serif">
						<div id="fortitle" data-content="杂题选谈：log 数据结构">
							杂题选谈：log 数据结构
						</div>
						<div class="ui title background">
						</div>
					</div>
					<span id="date">
						<i class="fas fa-calendar-alt" style="margin-right: 4px;"></i>
						2025-08-19
					</span>
				</span>
			</span>
			<div id="posttags" class="dotted border">
				
					
						<a href="/tags/线段树/" class="citem">线段树</a>
					
				
			</div>
			<!-- 本来用的是 fromNow 然后字符串判断，没想到可以直接调用 moment() -->
			
			<div id="content">
				<p>线段树、树状数组、倍增、分治（朴素分治 / CDQ / 整体二分）、平衡树、字典树、笛卡尔树</p>
<p>多乎哉？不多也。</p>
<span id="more"></span>
<hr />
<p>题目来源：</p>
<ol type="1">
<li><p>llsw’s pdf</p>
<p>caijianhong /bx /bx</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/caijianhong/p/18709963">【笔记】数据结构选讲-李雷思问 2025.2.10</a></p></li>
<li>洛谷文章广场题解区搜索对应算法</li>
<li><p>自己以前的一些零散题解</p></li>
</ol>
<p>找了一些有数据结构方面思维难点的题，实现难度通常不会很大，也有少许粑粑夹杂其中</p>
<hr />
<p><code>#</code> 是缺题解，<code>*</code> 是缺代码</p>
<hr />
<h2 id="线段树">线段树</h2>
<h3 id="维护特殊信息">维护特殊信息</h3>
<h4 id="金鱼草-curtains区间覆盖信息">金鱼草 / Curtains（区间覆盖信息）</h4>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P11536" class="uri">https://www.luogu.com.cn/problem/P11536</a></p>
<blockquote>
<p>给定 <span class="math inline">\(n\)</span> 个区间 <span class="math inline">\([l,r]\)</span>，给出 <span class="math inline">\(q\)</span> 个询问，每次询问 <span class="math inline">\([L,R]\)</span> 是否能被表示为若干 <span class="math inline">\([l,r]\)</span> 的并集。注意不能覆盖到 <span class="math inline">\([L,R]\)</span> 之外的点。</p>
<p><span class="math inline">\(n,q\le 5\times 10^5,|V|\le 10^9\)</span>。</p>
</blockquote>
<ul>
<li>题目所求等价于 check 满足 <span class="math inline">\(l\ge L\land r\le R\)</span> 的所有区间是否能够覆盖 <span class="math inline">\([L,R]\)</span></li>
<li>这个很简单，需要区间修改的做法就不提了。可以想一下有没有只需要单点修改的做法</li>
<li><p>发现权值线段树可以维护「一段连续左端点对应区间的并」是否是连续的：</p>
维护位于区间内的左端点最后一个覆盖到的点 <span class="math inline">\(rv\)</span>（可以在区间外；发现从区间左端点到 <span class="math inline">\(rv\)</span> 会被连续覆盖），<strong>区间内</strong>最后一个没有被覆盖到的点 <span class="math inline">\(p\)</span>，和表示区间是否能被完整覆盖的标记 flag。pushup 是容易的。</li>
<li><p>容易发现如果我们在树上询问 <span class="math inline">\([L,R]\)</span> 中所有左端点的 flag，无法保证参与覆盖的 <span class="math inline">\(r\le R\)</span>。故离线下来扫描线即可。</p>
<p>实际上由于未知原因跑得很可能不如区间修改的方法快 TAT</p></li>
</ul>
<details>
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;
const int maxn = 5e5 + 5;
struct _ &#123;
    bool flag;
    int l, r, rv, p;
&#125; t[maxn &lt;&lt; 2];
#define lt (p &lt;&lt; 1)
#define rt (lt | 1)
void pushup(int p) &#123;
    t[p].rv = std::max(t[lt].rv, t[rt].rv);
    if (!t[lt].flag) &#123;
        t[p].flag = 0;
        if (!t[rt].flag &amp;&amp; t[lt].rv &lt; t[rt].p)
            t[p].p = t[rt].p;
        else
            t[p].p = t[lt].p;
    &#125;
    else if (!t[rt].flag &amp;&amp; t[lt].rv &lt; t[rt].p)
        t[p].flag = 0, t[p].p = t[rt].p;
    else
        t[p].flag = 1, t[p].p = 0;
    return;
&#125;
void bld(int p, int l, int r) &#123;
    t[p].l = l, t[p].r = t[p].p = r;
    if (l == r)
        return;
    int mid = (l + r) &gt;&gt; 1;
    bld(lt, l, mid), bld(rt, mid + 1, r);
    return;
&#125;
void add(int p, int x, int v) &#123;
    if(t[p].l == t[p].r) &#123;
        t[p].flag = 1, t[p].p = 0;
        t[p].rv = std::max(t[p].rv, v);
        return;
    &#125;
    int mid = (t[p].l + t[p].r) &gt;&gt; 1;
    if (x &lt;= mid)
        add(lt, x, v);
    else
        add(rt, x, v);
    pushup(p);
    return;
&#125;
_ ask(int p, int l, int r) &#123;
    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r)
        return t[p];
    int mid = (t[p].l + t[p].r) &gt;&gt; 1;
    if (r &lt;= mid)
        return ask(lt, l, r);
    if (l &gt; mid)
        return ask(rt, l, r);
    auto ls(ask(lt, l, r)), rs(ask(rt, l, r));
    if (!ls.flag) &#123;
        if (!rs.flag &amp;&amp; ls.rv &lt; rs.p)
            ls.p = rs.p;
    &#125;
    else if (!rs.flag &amp;&amp; ls.rv &lt; rs.p)
        ls.flag = 0, ls.p = rs.p;
    ls.rv = std::max(ls.rv, rs.rv);
    return ls;
&#125;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n, m, q;
    std::cin &gt;&gt; m &gt;&gt; n &gt;&gt; q;
    bld(1, 1, m);
    std::vector&lt;std::vector&lt;int&gt; &gt; t(m + 1);
    for (int i = 1, l, r; i &lt;= n; ++i) &#123;
        std::cin &gt;&gt; l &gt;&gt; r;
        t[r].push_back(l);
    &#125;
    std::vector&lt;int&gt; res(q + 1);
    std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; tq(m + 1);
    for (int i = 1, l, r; i &lt;= q; ++i) &#123;
        std::cin &gt;&gt; l &gt;&gt; r;
        tq[r].emplace_back(l, i);
    &#125;
    for (int i = 1; i &lt;= m; ++i) &#123;
        for (auto l : t[i])
            add(1, l, i);
        for (auto [l, id] : tq[i])
            res[id] = ask(1, l, i).flag;
    &#125;
    for (int i = 1; i &lt;= q; ++i)
        std::cout &lt;&lt; (res[i] ? &quot;YES&quot; : &quot;NO&quot;) &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;</code></pre>
</details>
<h4 id="题日-zapatak哈希">题日 Zapatak（哈希）</h4>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P11262" class="uri">https://www.luogu.com.cn/problem/P11262</a></p>
<blockquote>
<p>给定 <span class="math inline">\(A_{1\cdots n}\)</span> 和 <span class="math inline">\(B_{1\cdots n}\)</span>，给定 <span class="math inline">\(m\)</span> 次询问，行如：</p>
<ul>
<li>给定 <span class="math inline">\(l_1,r_1,l_2,r_2\)</span>，问 <span class="math inline">\(A_{l_1\cdots r_1}\)</span> 是否能通过重排，与 <span class="math inline">\(B_{l_2\cdots r_2}\)</span> 有<strong>恰好一个</strong>元素不同。</li>
</ul>
<p><span class="math inline">\(n,m\le 10^5\)</span>。</p>
</blockquote>
<ul>
<li><p>『重排』体现：不重视下标，但重视值本身的性质。</p>
<p>要么用主席树（这样 pushup 信息时会利用值本身的性质），要么用普通线段树 + 哈希（理论上一种哈希和就对应一种数的组合方式）。</p></li>
<li><p>『全等』的处理一般是哈希。</p></li>
<li><p>考虑主席树解决『重排』。</p></li>
<li><p>可以发现性质：如果区间合法，不同的位置是可以主席树上二分出来的。</p>
<p>换句话说，如果可以二分，那么区间合法。哈希判定全等即可。</p></li>
<li><p>另一个不用权值数据结构的随机化做法：给每个数随机赋权 <span class="math inline">\(0\)</span> 或 <span class="math inline">\(1\)</span>，每次 check 时统计区间内所有哈希和。</p>
<p>随机赋 100 次，要求这 100 次中，每次两个区间的差绝对值都为 0 或 1，且存在至少一个 1。本质上利用了第二种『重排』的解决方式。</p></li>
</ul>
<details>
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;
const int inf = 1e9;
const int p = 1e9 + 7;
const int mod = 2e9 + 11;
const int maxn = 1e5 + 5;
const int maxm = 2e7 + 5;
struct &#123; int l, r; long long h, u; &#125; t[maxm];
int sum, tot;
#define plt t[p].l
#define prt t[p].r
#define qlt t[q].l
#define qrt t[q].r
long long qkp(long long x, int y) &#123;
    long long res = 1ll;
    for (; y; (x *= x) %= mod, y &gt;&gt;= 1)
        if (y &amp; 1)
            (res *= x) %= mod;
    return res;
&#125;
void pushup(int p) &#123;
    t[p].h = 0ll;
    if (plt)
        t[p].h = t[plt].h;
    if (prt)
        (t[p].h += t[prt].h) %= mod;
    return;
&#125;
void add(int &amp;p, int q, int l, int r, int x, long long base) &#123;
    p = ++tot, t[p] = t[q];
    if (l == r) &#123;
        (t[p].h += base) %= mod, ++t[p].u;
        return;
    &#125;
    int mid = (l + r) &gt;&gt; 1;
    if (x &lt;= mid)
        add(plt, qlt, l, mid, x, base);
    else
        add(prt, qrt, mid + 1, r, x, base);
    pushup(p);
    return;
&#125;
void ask(int p1, int q1, int p2, int q2, int l, int r) &#123;
    if (l == r) &#123;
        sum += std::abs((t[p1].u - t[q1].u) - (t[p2].u - t[q2].u));
        return;
    &#125;
    int mid = (l + r) &gt;&gt; 1;
    if ((t[t[p1].l].h + mod - t[t[q1].l].h) % mod != (t[t[p2].l].h + mod - t[t[q2].l].h) % mod) &#123;
        if (sum &lt; 2)
            ask(t[p1].l, t[q1].l, t[p2].l, t[q2].l, l, mid);
        else
            sum = inf;
    &#125;
    if ((t[t[p1].r].h + mod - t[t[q1].r].h) % mod != (t[t[p2].r].h + mod - t[t[q2].r].h) % mod) &#123;
        if (sum &lt; 2)
            ask(t[p1].r, t[q1].r, t[p2].r, t[q2].r, mid + 1, r);
        else
            sum = inf;
    &#125;
    return;
&#125;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n, m;
    std::cin &gt;&gt; n &gt;&gt; m;
    std::map&lt;int, int&gt; t;
    std::mt19937 rnd(time(nullptr));
    std::vector&lt;int&gt; a(n + 1), rt(n + 1);
    for (int i = 1; i &lt;= n; ++i) &#123;
        std::cin &gt;&gt; a[i];
        if (!t.count(a[i]))
            t[a[i]] = qkp(p, std::abs((int)(rnd())));
        add(rt[i], rt[i - 1], 0, inf, a[i], t[a[i]]);
    &#125;
    auto ask = [&amp;](int l1, int r1, int l2, int r2) &#123;
        sum = 0;
        ::ask(rt[r1], rt[l1 - 1], rt[r2], rt[l2 - 1], 0, inf);
        return (sum == 2);
    &#125;;
    for (int l1, r1, l2, r2; m--; ) &#123;
        std::cin &gt;&gt; l1 &gt;&gt; r1 &gt;&gt; l2 &gt;&gt; r2;
        std::cout &lt;&lt; (ask(l1, r1, l2, r2) ? &quot;DA&quot; : &quot;NE&quot;) &lt;&lt; &#39;\n&#39;;
        // assert(0);
    &#125;
    return 0;
&#125;</code></pre>
</details>
<h4 id="简单数据结构带一点递推性质">简单数据结构（带一点递推性质）</h4>
<p><a target="_blank" rel="noopener" href="https://pjudge.ac/problem/21636" class="uri">https://pjudge.ac/problem/21636</a></p>
<blockquote>
<p>给定初始为空的多重集 <span class="math inline">\(p\)</span>, <span class="math inline">\(q\)</span>，这两个多重集中的元素都有 <span class="math inline">\(a,b\)</span> 两种属性。需要需要维护 <span class="math inline">\(p\)</span> 和 <span class="math inline">\(q\)</span> 的加点和删点操作，询问 <span class="math inline">\(\forall \,i\in p,j\in q\)</span>，<span class="math inline">\(\max(i_x + j_x, i_y + j_y)\)</span> 的最小值。</p>
<p><span class="math inline">\(m\le 10^6,V\le 10^9\)</span>。</p>
</blockquote>
<ul>
<li>考虑<strong>对不等式恒等变形，转化为偏序问题</strong>。若 <span class="math inline">\(a_{i,0}+b_{j,0}\ge a_{i,1}+b_{j,1}\)</span>，则 <span class="math inline">\(a_{i,0}-a_{i,1}\ge b_{j,1}-b_{j,0}\)</span>。</li>
<li><p>把 <span class="math inline">\(a\)</span> 按照 <span class="math inline">\(a_{i,0}-a_{i,1}\)</span> 排序、把 <span class="math inline">\(b\)</span> 按照 <span class="math inline">\(b_{j,1}-b_{j,0}\)</span> 排序。</p>
<p>要求某个时刻的答案，需要对于每一个 <span class="math inline">\(i\)</span> 找到最小的 <span class="math inline">\(b_{j,0}\)</span>，使得 <span class="math inline">\(b_{j,1}-b_{j,0}\)</span> 在 <span class="math inline">\([-\infty, a_{i,0}-a_{i,1}]\)</span> 中，同时找到最小的 <span class="math inline">\(b_{j,1}\)</span>，使得 <span class="math inline">\(b_{j,1}-b_{j,0}\)</span> 在 <span class="math inline">\([a_{i, 0}-a_{i,1},+\infty]\)</span> 中。</p>
<p>这个带有一点递推的性质，在线段树 pushup 的时候，用左边的 <span class="math inline">\(b_{j,0}\)</span> 结合右边的答案得到父亲的答案。</p></li>
</ul>
<p><em>听说我之前赛时切了这题？怎么没印象。llsw 讲题的时候说要离线，但是没想到离线做法 orz</em></p>
<details>
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;
const int inf = 2e9 + 1;
struct _ &#123; long long aa, ab, ba, bb, u; int l, r, id; &#125;;
std::vector&lt;_&gt; t(1);
std::vector&lt;std::multiset&lt;long long&gt; &gt; aa(1), ab(1), ba(1), bb(1);
int tot, cnt;
#define lt t[p].l
#define rt t[p].r
void pushup(int p) &#123;
    t[p].aa = t[p].ab = t[p].ba = t[p].bb = t[p].u = inf;
    if (lt) &#123;
        t[p].u = t[lt].u;
        t[p].aa = t[lt].aa, t[p].ab = t[lt].ab, t[p].ba = t[lt].ba, t[p].bb = t[lt].bb;
    &#125;
    if (rt) &#123;
        t[p].u = std::min(t[p].u, t[rt].u);
        t[p].aa = std::min(t[p].aa, t[rt].aa);
        t[p].ab = std::min(t[p].ab, t[rt].ab);
        t[p].ba = std::min(t[p].ba, t[rt].ba);
        t[p].bb = std::min(t[p].bb, t[rt].bb);
    &#125;
    if (lt &amp;&amp; rt)
        t[p].u = std::min(&#123; t[p].u, t[lt].ba + t[rt].aa, t[lt].ab + t[rt].bb &#125;);
    return;
&#125;
int adda(int p, long long l, long long r, int x, int a, int b) &#123;
    if (!p)
        p = ++tot, t.emplace_back(), t[p].aa = t[p].ab = t[p].ba = t[p].bb = t[p].u = inf;
    if (l == r) &#123;
        if (!t[p].id)
            t[p].id = ++cnt, aa.emplace_back(), ab.emplace_back(), ba.emplace_back(), bb.emplace_back();
        int id = t[p].id;
        aa[id].insert(a), ab[id].insert(b);
        t[p].aa = *aa[id].begin(), t[p].ab = *ab[id].begin();
        if (!aa[id].empty() &amp;&amp; !ba[id].empty())
            t[p].u = std::min(*aa[id].begin() + *ba[id].begin(), *ab[id].begin() + *bb[id].begin());
        else
            t[p].u = inf;
        return p;
    &#125;
    long long mid = (l + r) &gt;&gt; 1;
    if (x &lt;= mid) &#123;
        auto s(adda(lt, l, mid, x, a, b));
        lt = s;
    &#125;
    else &#123;
        auto s(adda(rt, mid + 1, r, x, a, b));
        rt = s;
    &#125;
    pushup(p);
    return p;
&#125;
int addb(int p, long long l, long long r, int x, int a, int b) &#123;
    if (!p)
        p = ++tot, t.emplace_back(), t[p].aa = t[p].ab = t[p].ba = t[p].bb = t[p].u = inf;
    if (l == r) &#123;
        if (!t[p].id)
            t[p].id = ++cnt, aa.emplace_back(), ab.emplace_back(), ba.emplace_back(), bb.emplace_back();
        int id = t[p].id;
        ba[id].insert(a), bb[id].insert(b);
        t[p].ba = *ba[id].begin(), t[p].bb = *bb[id].begin();
        if (!aa[id].empty() &amp;&amp; !ba[id].empty())
            t[p].u = std::min(*aa[id].begin() + *ba[id].begin(), *ab[id].begin() + *bb[id].begin());
        else
            t[p].u = inf;
        return p;
    &#125;
    long long mid = (l + r) &gt;&gt; 1;
    if (x &lt;= mid) &#123;
        auto s(addb(lt, l, mid, x, a, b));
        lt = s;
    &#125;
    else &#123;
        auto s(addb(rt, mid + 1, r, x, a, b));
        rt = s;
    &#125;
    pushup(p);
    return p;
&#125;
void dela(int p, long long l, long long r, int x, int a, int b) &#123;
    if (l == r) &#123;
        int id = t[p].id;
        aa[id].erase(aa[id].find(a)), ab[id].erase(ab[id].find(b));
        t[p].aa = (aa[id].empty() ? inf : *aa[id].begin());
        t[p].ab = (ab[id].empty() ? inf : *ab[id].begin());
        if (!aa[id].empty() &amp;&amp; !ba[id].empty())
            t[p].u = std::min(*aa[id].begin() + *ba[id].begin(), *ab[id].begin() + *bb[id].begin());
        else
            t[p].u = inf;
        return;
    &#125;
    long long mid = (l + r) &gt;&gt; 1;
    if (x &lt;= mid)
        dela(lt, l, mid, x, a, b);
    else
        dela(rt, mid + 1, r, x, a, b);
    pushup(p);
    return;
&#125;
void delb(int p, long long l, long long r, int x, int a, int b) &#123;
    if (l == r) &#123;
        int id = t[p].id;
        ba[id].erase(ba[id].find(a)), bb[id].erase(bb[id].find(b));
        t[p].ba = (ba[id].empty() ? inf : *ba[id].begin());
        t[p].bb = (bb[id].empty() ? inf : *bb[id].begin());
        if (!aa[id].empty() &amp;&amp; !ba[id].empty())
            t[p].u = std::min(*aa[id].begin() + *ba[id].begin(), *ab[id].begin() + *bb[id].begin());
        else
            t[p].u = inf;
        return;
    &#125;
    long long mid = (l + r) &gt;&gt; 1;
    if (x &lt;= mid)
        delb(lt, l, mid, x, a, b);
    else
        delb(rt, mid + 1, r, x, a, b);
    pushup(p);
    return;
&#125;
#undef lt
#undef rt
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
    std::freopen(&quot;set.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;set.out&quot;, &quot;w&quot;, stdout);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int q, rt = 0;
    std::cin &gt;&gt; q;
    for (int i = 1; i &lt;= q; ++i) &#123;
        int op, d, a, b;
        std::cin &gt;&gt; op &gt;&gt; d &gt;&gt; a &gt;&gt; b;
        if (op == 0 &amp;&amp; d == 0)
            dela(rt, -inf, inf, a - b, a, b);
        else if (op == 0)
            delb(rt, -inf, inf, b - a, a, b);
        else if (d == 0)
            rt = adda(rt, -inf, inf, a - b, a, b);
        else
            rt = addb(rt, -inf, inf, b - a, a, b);
        std::cout &lt;&lt; (t[1].u == inf ? -1 : t[1].u) &lt;&lt; &#39;\n&#39;;
    &#125;
    return 0;
&#125;</code></pre>
</details>
<hr />
<h4 id="命运利用线段树的分治结构递推"># 命运（利用线段树的分治结构递推）</h4>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P6773" class="uri">https://www.luogu.com.cn/problem/P6773</a></p>
<hr />
<h4 id="对数据结构的爱维护函数">* 对数据结构的爱（维护函数）</h4>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P5609" class="uri">https://www.luogu.com.cn/problem/P5609</a></p>
<blockquote>
<p>给定长度为 <span class="math inline">\(n\)</span> 的数组 <span class="math inline">\(a\)</span> 和模数 <span class="math inline">\(p\)</span>（<span class="math inline">\(a_i\)</span> 初始可能比 <span class="math inline">\(p\)</span> 大很多，还有可能为负），给定 <span class="math inline">\(m\)</span> 次询问，每次问区间 <span class="math inline">\([l,r]\)</span>，进行这样的操作：</p>
<p>初始 <span class="math inline">\(sum=0\)</span>，从 <span class="math inline">\(l\)</span> 到 <span class="math inline">\(r\)</span>，依次令 <span class="math inline">\(sum\gets sum+a_i\)</span>，当且仅当 <span class="math inline">\(sum\ge p\)</span> 时令 <span class="math inline">\(sum\gets sum-p\)</span>（注意这不是取模，减完之后还是可能 <span class="math inline">\(\ge p\)</span>）。</p>
<p>问最终 <span class="math inline">\(sum\)</span> 的值。<span class="math inline">\(n\le 10^6,m\le 2\times 10^5\)</span>。</p>
</blockquote>
<p>考虑线段树维护函数。定义 <span class="math inline">\(f(x)\)</span> 表示区间上想要减去 <span class="math inline">\(x\)</span> 次 <span class="math inline">\(p\)</span> 需要的最小初始值（这样才能让定义域和区间长有关），查询时直接二分即可；考虑初始化时如何合并。</p>
<p>首先思考较为暴力的做法，对于左侧点 <span class="math inline">\(a\)</span> 和右侧点 <span class="math inline">\(b\)</span>，若 <span class="math inline">\(f(a+1)-1+s_l-a\cdot p\ge f(b)\)</span>，也即可以减去 <span class="math inline">\(a+b\)</span> 次，就可以用 <span class="math inline">\(\max(f(a),f(b)-s_l+a\cdot p)\)</span> 来更新 <span class="math inline">\(f(a+b)\)</span>。</p>
<p>发现 <span class="math inline">\((a,b)\)</span> 的贡献一定小于 <span class="math inline">\((a+1,b-1)\)</span> 的贡献；具体地，发现 <span class="math inline">\(f(x+1)-f(x)\ge p\)</span> 后就很显然了。采用双指针，优先移动 <span class="math inline">\(b\)</span>，就能把最短区间扫一遍。</p>
<details>
<p><summary>关于线段树维护函数</summary></p>
<p>维护一个函数，形如 <span class="math inline">\(f_{[l,r]}(x)\)</span> 表示在 <span class="math inline">\([l,r]\)</span> 区间上，<span class="math inline">\(x\)</span> 的一个映射</p>
<p>如果相邻区间的函数可以用某种方式合并，就可以用线段树来维护</p>
<p>把树建在值域上，就可以在节点内把这段区间每个点对应的函数值存下来。一般来说是静态的，因为这是一个类前缀和的形式，没办法修改</p>
<p>每个点的点值数组会在当前层被扫一遍，上一层被扫一遍，如果合并能够做到线性，总复杂度就是单 <span class="math inline">\(\log\)</span> 的。</p>
<p>实际情形下函数本身可能很隐秘、很抽象，怎么优化到线性合并也不太好想</p>
</details>
<hr />
<h4 id="compounds模意义下问题">* COmPoUNdS（模意义下问题）</h4>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P12389" class="uri">https://www.luogu.com.cn/problem/P12389</a></p>
<blockquote>
<p>给定常数模数，维护模意义下的区间加、区间哈希（即判断两段区间是否全等）。<span class="math inline">\(n\le 10^6\)</span>。</p>
</blockquote>
<ul>
<li><p><strong>线段树哈希是可以维护区间加的</strong>，但是没办法维护区间取模</p></li>
<li><p>类似 <a href="/20250816/#e---subarray-sum-divisibility">ABC419E</a> 里面用到的，模意义下序列全等可以转化成差分全等，区间修改就可以简化成单点修改了</p></li>
<li><p>额外判一下开头的元素（维护原数组或者是差分数组之和）是否相等就可以了</p></li>
</ul>
<hr />
<h4 id="改进代码模意义下问题">* 改进代码（模意义下问题）</h4>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P4635" class="uri">https://www.luogu.com.cn/problem/P4635</a></p>
<blockquote>
<p>给定序列 <span class="math inline">\(a_{1\sim n}\)</span> 和常数 <span class="math inline">\(p\)</span>，维护:</p>
<ul>
<li>修改：模 <span class="math inline">\(p\)</span> 意义下区间加；</li>
<li>询问：区间中 <span class="math inline">\(\sum\limits_{i=l}^{r-1}[a_i&gt;a_{i+1}]\)</span>。</li>
</ul>
<p><span class="math inline">\(n\le 10^5,p\le 10^6\)</span>。</p>
</blockquote>
<p>询问也和模意义差分有关系，假如 <span class="math inline">\(s\)</span> 为当前差分数组前缀和模 <span class="math inline">\(p\)</span> 的值（也就是原数），发现<strong>前一个数 <span class="math inline">\(&gt;\)</span> 后一个数当且仅当 <span class="math inline">\(s\)</span> 加爆了</strong>。维护原数组用来确定 <span class="math inline">\(s\)</span> 的初值。再维护区间内差分数组之和（不取模），<strong>在这个和里有多少个 <span class="math inline">\(p\)</span> 就会爆多少次</strong>。</p>
<h4 id="黑白树很新的东西">黑白树（很新的东西）</h4>
<p><a target="_blank" rel="noopener" href="https://www.becoder.com.cn/problem/46907" class="uri">https://www.becoder.com.cn/problem/46907</a></p>
<hr />
<h3 id="以楼房重建为代表的-log2-一类前缀信息维护">以楼房重建为代表的 <span class="math inline">\(\log^2\)</span> 一类前缀信息维护</h3>
<p>特点：pushup 时需要先获得一边的信息，在另一边进行线段树上二分，单次操作是 <span class="math inline">\(O(\log^2)\)</span> 的</p>
<p>本质是一类具有<strong>单调性</strong>的前 / 后缀信息，<strong>区间对全局的贡献</strong>和<strong>区间外的信息</strong>有关，故不能直接维护对全局的贡献，只能维护区间内的答案。但由于两个子区间答案可以合并出大区间答案（通过线段树上二分得到需要的信息），所以只需要逐层向上合并就可以得到全局答案</p>
<p>一个名字是『线段树维护前缀信息』，感觉不很精确。log 方线段树又是什么鬼名字？兔队线段树又是谁起的（upd：疑似皎月半洒花）？更多还是叫的楼房重建线段树吧</p>
<hr />
<h4 id="楼房重建">楼房重建</h4>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P4198" class="uri">https://www.luogu.com.cn/problem/P4198</a></p>
<blockquote>
<p>给定 <span class="math inline">\(a_{1\sim n}\)</span>，维护 <span class="math inline">\(q\)</span> 次操作：</p>
<ul>
<li>单点修改；</li>
<li>查询 <span class="math inline">\(\dfrac{a_i}i\)</span> 的前缀最大值序列长度。</li>
</ul>
<p><span class="math inline">\(n,q\le 10^5\)</span>。</p>
</blockquote>
<p>Fractures 说当年（初一）是他力荐 gm 给我们拉这个题的。dashena！</p>
<ul>
<li>线段树维护单调栈，或者说前缀最值，维护方式过于经典，使得『楼房重建』成为该 trick 称呼之一</li>
<li><p>考虑 pushup。保留左边整段区间，对于左区间序列末的元素 <code>l.rv</code>，我们在右区间内找到第一个大于之的元素 <span class="math inline">\(x\)</span>，从它开始的序列就是答案。</p>
反证法易得 <span class="math inline">\(x\)</span> 一定在右区间答案序列内：若 <span class="math inline">\(x\)</span> 不在答案序列内，则右区间内存在一个 <span class="math inline">\(&gt;x\)</span> 且位于 <span class="math inline">\(x\)</span> 之前的元素，那么 <span class="math inline">\(x\)</span> 就不是第一个 <code>&gt; l.rv</code> 的元素，矛盾。</li>
<li><p>故在右区间中二分能够接上去的区间长度，加起来即可。</p>
<p>题目只要求总区间答案，故不需要查询。动态开点可能需要小心处理一下。</p></li>
</ul>
<details>
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;
const int maxn = 1e5 + 5;
struct &#123;
    int l, r, u;
    double lv, rv, mv;
&#125; t[maxn &lt;&lt; 2];
int tot;
#define lt t[p].l
#define rt t[p].r
int askt(int p, int l, int r, double v) &#123;
    if (l == r)
        return t[p].u;
    int mid = (l + r) &gt;&gt; 1;
    if (lt &amp;&amp; t[p].mv &gt; v)
        return t[p].u - t[lt].u + askt(lt, l, mid, v);
    return askt(rt, mid + 1, r, v);
&#125;
void pushup(int p, int l, int r) &#123;
    t[p].mv = t[lt].rv;
    if (lt &amp;&amp; rt) &#123;
        t[p].lv = t[lt].lv;
        t[p].rv = std::max(t[lt].rv, t[rt].rv);
        if (t[lt].rv &lt; t[rt].lv)
            t[p].u = t[lt].u + t[rt].u;
        else if (t[lt].rv &gt;= t[rt].rv)
            t[p].u = t[lt].u;
        else &#123;
            int mid = (l + r) &gt;&gt; 1;
            t[p].u = t[lt].u + askt(rt, mid + 1, r, t[lt].rv);
        &#125;
    &#125;
    else &#123;
        t[p].u = t[lt + rt].u;
        t[p].lv = t[lt + rt].lv, t[p].rv = t[lt + rt].rv;
    &#125;
    return;
&#125;
void upd(int &amp;p, int l, int r, int x, double v) &#123;
    if (!p)
        p = ++tot;
    if (l == r) &#123;
        t[p].lv = t[p].rv = v, t[p].u = 1;
        return;
    &#125;
    int mid = (l + r) &gt;&gt; 1;
    if (x &lt;= mid)
        upd(lt, l, mid, x, v);
    else
        upd(rt, mid + 1, r, x, v);
    pushup(p, l, r);
    return;
&#125;
#undef lt
#undef rt
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;P4198_2.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n, m, rt = 0;
    std::cin &gt;&gt; n &gt;&gt; m;
    std::vector&lt;double&gt; a(n + 1);
    for (int x; m--; ) &#123;
        double y;
        std::cin &gt;&gt; x &gt;&gt; y;
        a[x] = y / x;
        upd(rt, 1, n, x, y / x);
        std::cout &lt;&lt; t[1].u &lt;&lt; &#39;\n&#39;;
    &#125;
    return 0;
&#125;</code></pre>
</details>
<hr />
<h4 id="二叉搜索树">二叉搜索树</h4>
<p><a target="_blank" rel="noopener" href="https://pjudge.ac/problem/21889" class="uri">https://pjudge.ac/problem/21889</a></p>
<blockquote>
<p>给定一个大小为 <span class="math inline">\(n\)</span> 的树，树上每个元素是一个 BST，你需要维护 <span class="math inline">\(q\)</span> 次操作：</p>
<ol type="1">
<li>对于树上的一条路径 <span class="math inline">\((u,v)\)</span>，在经过的所有节点上的 BST 插入 <span class="math inline">\(x\)</span>，保证任意时刻 BST 中无相同值</li>
<li>在点 <span class="math inline">\(u\)</span> 查找 <span class="math inline">\(x\)</span>，如果 <span class="math inline">\(x\)</span> 存在则返回其到 BST 根的元素和，否则返回查找时最远走到的那个点，到 BST 根的元素和。</li>
</ol>
<p><span class="math inline">\(n,q\le 2\times 10^5\)</span>。</p>
</blockquote>
<ul>
<li>考虑链上问题。差分，把更新 <span class="math inline">\([l, r]\)</span> 看作在差分数组 <span class="math inline">\(l\)</span> 处插入，在 <span class="math inline">\(r+1\)</span> 处删除，离线下来再从左到右扫一遍操作就能更新。</li>
<li>考虑查询。<span class="math inline">\(i\)</span> 树上存在过的所有元素是已知的，考虑如何基于此获取 <span class="math inline">\(i\)</span> 树上 <span class="math inline">\(t_0\)</span> 时刻，<span class="math inline">\(x\)</span> 的所有祖先。</li>
<li><p>对于比 <span class="math inline">\(x\)</span> 大的元素，考虑祖先 <span class="math inline">\(p_a\)</span> 和非祖先 <span class="math inline">\(p\)</span> 的区别：</p>
<p>根据 BST 的性质易得，对于最低的右侧祖先 <span class="math inline">\({p_a}_0\)</span>，其是 <span class="math inline">\(\ge x\)</span> 的最小的元素（加入时刻 <span class="math inline">\(t_a&lt;t_0\)</span>）；</p>
同理可以找到 <span class="math inline">\({p_a}_0\)</span> 右侧最低的祖先（其左侧的祖先显然也在 <span class="math inline">\(x\)</span> 左侧），该祖先满足 <span class="math inline">\(t&lt;t_a\)</span>。从左右两边分别得到 <span class="math inline">\(x\)</span> 的所有祖先。容易证明该过程对于不在树上的 <span class="math inline">\(x\)</span> 也是正确的。</li>
<li>具体地，需要能够求出 <span class="math inline">\(\ge x\)</span> 的元素中，以 <span class="math inline">\(t_0\)</span> 为起点的前缀最小值序列的区间和。线段树维护单调栈容易解决不带 <span class="math inline">\(t_0\)</span> 限制的答案；再次利用性质就能满足限制。</li>
<li><p>对于树的情况，把差分放到树上，线段树合并即可。</p></li>
</ul>
<details>
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;
const int lim = 2e5;
const int maxn = 2e7 + 5;
const int inf = 0x3f3f3f3f;
struct &#123;
    int l, r, rv;
    long long u;
&#125; t[maxn];
std::vector&lt;int&gt; tr;
#define lt t[p].l
#define rt t[p].r
int newnode(void) &#123;
    static int tot = 0;
    if (tr.empty())
        return ++tot;
    auto p(tr.back());
    t[p].l = t[p].r = 0;
    tr.pop_back();
    return p;
&#125;
long long askv(int p, int l, int r, int v) &#123;
    if (l == r)
        return t[p].rv &lt; v ? t[p].u : 0;
    int mid = (l + r) &gt;&gt; 1;
    if (v &gt; t[lt].rv)
        return t[p].u - t[lt].u + askv(lt, l, mid, v);
    return askv(rt, mid + 1, r, v);
&#125;
void pushup(int p, int l, int r) &#123;
    t[p].rv = std::min(t[lt].rv, t[rt].rv);
    int mid = (l + r) &gt;&gt; 1;
    t[p].u = t[lt].u + askv(rt, mid + 1, r, t[lt].rv);
    return;
&#125;
void upd(int &amp;p, int l, int r, int x, int v, int u) &#123;
    if (!p)
        p = newnode();
    if (l == r) &#123;
        t[p].rv = v, t[p].u = u;
        return;
    &#125;
    int mid = (l + r) &gt;&gt; 1;
    if (x &lt;= mid)
        upd(lt, l, mid, x, v, u);
    else
        upd(rt, mid + 1, r, x, v, u);
    pushup(p, l, r);
    return;
&#125;
void merge(int &amp;p, int q, int l, int r) &#123;
    if (!p || !q) &#123;
        p += q;
        return;
    &#125;
    if (l == r) &#123;
        t[p].rv = std::min(t[p].rv, t[q].rv);
        t[p].u = std::max(t[p].u, t[q].u);
        return;
    &#125;
    int mid = (l + r) &gt;&gt; 1;
    merge(t[p].l, t[q].l, l, mid), merge(t[p].r, t[q].r, mid + 1, r);
    pushup(p, l, r), tr.push_back(q);
    return;
&#125;
int qv = inf;
long long ask(int p, int l, int r, int ql, int qr) &#123;
    if (ql &lt;= l &amp;&amp; r &lt;= qr) &#123;
        auto s(askv(p, l, r, qv));
        qv = std::min(qv, t[p].rv);
        return s;
    &#125;
    int mid = (l + r) &gt;&gt; 1;
    long long res = 0ll;
    if (ql &lt;= mid)
        res = ask(lt, l, mid, ql, qr);
    if (qr &gt; mid)
        res += ask(rt, mid + 1, r, ql, qr);
    return res;
&#125;
#undef lt
#undef rt
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;ex_problem4.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n, m;
    std::cin &gt;&gt; n &gt;&gt; m;
    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);
    for (int i = 1, x, y; i &lt; n; ++i) &#123;
        std::cin &gt;&gt; x &gt;&gt; y;
        g[x].push_back(y), g[y].push_back(x);
    &#125;
    std::vector&lt;int&gt; top(n + 1), fa(n + 1), siz(n + 1), son(n + 1), dep(n + 1);
    std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int faa) &#123;
        siz[x] = 1;
        for (auto i : g[x])
            if (i != faa) &#123;
                fa[i] = x, dep[i] = dep[x] + 1;
                DFS(i, x), siz[x] += siz[i];
                if (siz[i] &gt; siz[son[x]])
                    son[x] = i;
            &#125;
        return;
    &#125;;
    DFS(1, -1);
    DFS = [&amp;](int x, int topp) &#123;
        top[x] = topp;
        if (son[x])
            DFS(son[x], topp);
        for (auto i : g[x])
            if (i != fa[x] &amp;&amp; i != son[x])
                DFS(i, i);
        return;
    &#125;;
    DFS(1, 1);
    auto getLCA = [&amp;](int x, int y) &#123;
        for (; top[x] != top[y]; x = fa[top[x]])
            if (dep[top[y]] &gt; dep[top[x]])
                std::swap(x, y);
        return (dep[x] &lt; dep[y] ? x : y);
    &#125;;
    std::vector&lt;std::vector&lt;int&gt; &gt; d(n + 1);
    std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; u(n + 1);
    std::vector&lt;std::vector&lt;std::tuple&lt;int, int, int&gt; &gt; &gt; q(n + 1);
    int cnt = 0;
    for (int i = 1; i &lt;= m; ++i) &#123;
        int op;
        std::cin &gt;&gt; op;
        if (op == 0) &#123;
            int x, v;
            std::cin &gt;&gt; x &gt;&gt; v;
            q[x].emplace_back(++cnt, i, v);
        &#125; else &#123;
            int x, y, v;
            std::cin &gt;&gt; x &gt;&gt; y &gt;&gt; v;
            int faa = getLCA(x, y);
            u[x].emplace_back(i, v), u[y].emplace_back(i, v);
            if (fa[faa])
                d[fa[faa]].emplace_back(v);
        &#125;
    &#125;
    std::vector&lt;long long&gt; res(cnt + 1);
    std::vector&lt;std::vector&lt;int&gt; &gt; rt(2, std::vector&lt;int&gt; (n + 1));
    t[0].rv = inf;
    DFS = [&amp;](int x, int fa) &#123;
        for (auto i : g[x])
            if (i != fa) &#123;
                DFS(i, x);
                merge(rt[0][x], rt[0][i], 1, lim);
                merge(rt[1][x], rt[1][i], 1, lim);
            &#125;
        for (auto [t, v] : u[x]) &#123;
            upd(rt[0][x], 1, lim, v, t, v);
            upd(rt[1][x], 1, lim, lim - v + 1, t, v);
        &#125;
        for (auto v : d[x]) &#123;
            upd(rt[0][x], 1, lim, v, inf, 0);
            upd(rt[1][x], 1, lim, lim - v + 1, inf, 0);
        &#125;
        for (auto [id, t, v] : q[x]) &#123;
            qv = t, res[id] = ask(rt[0][x], 1, lim, v, lim);
            qv = t, res[id] += ask(rt[1][x], 1, lim, lim - v + 1, lim);
            qv = t, res[id] -= ask(rt[0][x], 1, lim, v, v);
        &#125;
    &#125;;
    DFS(1, -1);
    for (int i = 1; i &lt;= cnt; ++i)
        std::cout &lt;&lt; res[i] &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;</code></pre>
</details>
<hr />
<h4 id="nastya-and-cbs">Nastya and CBS</h4>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/CF1340F" class="uri">https://www.luogu.com.cn/problem/CF1340F</a></p>
<blockquote>
<p>给定长度为 <span class="math inline">\(n\)</span> 的括号序列，由 <span class="math inline">\(k\)</span> 种括号对（<span class="math inline">\(-i,i\)</span> 表示第 <span class="math inline">\(i\)</span> 种左、右括号）组成，你需要维护单点修改元素、区间查询是否为合法括号序列。</p>
<p><span class="math inline">\(1\le k\le n\le 10^5,q\le 10^5\)</span>。</p>
</blockquote>
<ul>
<li>考虑不带修且允许 <span class="math inline">\(O(n)\)</span> 询问的情景，经典题，扫一遍，用栈维护即可；</li>
<li><p><span class="math inline">\(k=1\)</span> 时是线段树经典题，可以类比这个经典题，从刻画合法的条件入手。</p>
如果存在相邻且可以匹配的可以直接消掉，一直重复这样的操作，此时要么包含不能匹配的子串，如 <code>&#123;[)&#125;</code>，要么是 <code>)]&#125; (&#123;[&#123;&#123;</code> 的形式。</li>
<li>考虑怎么 pushup，发现中间生成的一段 <code>([()])</code> 必须完全匹配，消掉它们之后，大区间又变成 <code>)]&#125; (&#123;[&#123;&#123;</code> 的形式。</li>
<li>每次 pushup 要合并的区间很长，考虑怎么快速地做『消除相邻匹配括号』这一步。容易想到记录一段括号（例：<code>([&#123;</code>）及其对应反括号（例：<code>&#125;])</code>）的哈希值，check 是否相等，然后就可以不管它们了，并不是真的要删去。</li>
<li><p>线段树不能维护每个前后缀的哈希值，但需要的只是在<strong>删除连续匹配括号后</strong>长度为 <span class="math inline">\(len\)</span> 的哈希值，可以线段树上二分。</p>
这个过程有点困难，需要在询问的同时匹配、消除；但发现所谓消除就是对位相减，注意一下什么时候移位，还是好写的。</li>
<li><p>询问看似不太可做，因为中途的答案不是线段树的节点；如果把询问看成一次修改，就可以用类似可持久化的方式实现。</p>
<p>由于并不是真的要可持久化，询问新建的点可以重复利用。如果不重复利用，每次询问最多新建 <span class="math inline">\(O(\log n)\)</span> 个点，空间复杂度 <span class="math inline">\(O(q\log n)\)</span>，在 CF 上有点卡，也是能过的。</p></li>
</ul>
<details>
<p>Hint：有卡 998244353 的 Hack，故可以用 1e9 + 7 当模数；WA on 7 是正确性有巨大问题，WA on 8 可能是 long long 没开完 / 数组开小了 / 哈希方向有问题 / 线段树上二分写挂了（通常是消括号消错了）。前人踩坑后人嘲笑。</p>
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;
const int mod = 1e9 + 7;
const int base = 1e5 + 3;
const int maxn = 7e5 + 5;
struct Node &#123;
    bool flag;
    long long hr0, hl1;
    int l, r, lc, rc, ll, rl;
    Node&amp; operator= (const Node &amp;q) &#123;
        flag = q.flag, hr0 = q.hr0, hl1 = q.hl1;
        l = q.l, r = q.r, ll = q.ll, rl = q.rl;
        return *this;
    &#125;
    Node operator+ (const Node &amp;q) const;
&#125; t[maxn &lt;&lt; 2];
int tot;
int a[maxn];
long long bpow[maxn], inv[maxn];
long long askhl1(const Node &amp;p, int k) &#123;
    if (k == 0)
        return 0ll;
    if (k &gt; p.ll)
        return -1ll;
    if (p.ll == k)
        return p.hl1;
    int ll = t[p.lc].ll, rl = t[p.lc].rl;
    if (ll &gt;= k)
        return askhl1(t[p.lc], k);
    k -= ll, k += rl;
    auto hl1 = askhl1(t[p.rc], k);
    hl1 = ((hl1 + mod - t[p.lc].hr0) * inv[rl] % mod * bpow[ll] % mod + t[p.lc].hl1) % mod;
    return hl1;
&#125;
long long askhr0(const Node &amp;p, int k) &#123;
    if (k == 0)
        return 0ll;
    if (k &gt; p.rl)
        return -1ll;
    if (p.rl == k)
        return p.hr0;
    int rl = t[p.rc].rl, ll = t[p.rc].ll;
    if (rl &gt;= k)
        return askhr0(t[p.rc], k);
    k -= rl, k += ll;
    auto hr0 = askhr0(t[p.lc], k);
    hr0 = ((hr0 + mod - t[p.rc].hl1) * inv[ll] % mod * bpow[rl] % mod + t[p.rc].hr0) % mod;
    return hr0;
&#125;
Node Node::operator+ (const Node &amp;q) const  &#123;
    Node res;
    res.l = l, res.r = q.r;
    if (flag || q.flag)
        res.flag = 1;
    else &#123;
        if (rl == q.ll) &#123;
            if (hr0 == q.hl1) &#123;
                res.flag = 0;
                res.ll = ll, res.rl = q.rl;
                res.hl1 = hl1, res.hr0 = q.hr0;
            &#125;
            else
                res.flag = 1;
        &#125;
        else if (rl &lt; q.ll) &#123;
            auto qhl1 = askhl1(q, rl);
            if (hr0 == qhl1) &#123;
                res.flag = 0;
                res.ll = ll + q.ll - rl, res.rl = q.rl;
                res.hl1 = ((q.hl1 + mod - qhl1) % mod * inv[rl] % mod * bpow[ll] % mod + hl1) % mod;
                res.hr0 = q.hr0;
            &#125;
            else
                res.flag = 1;
        &#125;
        else &#123;
            auto phr0 = askhr0(*this, q.ll);
            if (phr0 == q.hl1) &#123;
                res.flag = 0;
                res.ll = ll, res.rl = rl - q.ll + q.rl;
                res.hl1 = hl1;
                res.hr0 = ((hr0 + mod - phr0) % mod * inv[q.ll] % mod * bpow[q.rl] % mod + q.hr0) % mod;
            &#125;
            else
                res.flag = 1;
        &#125;
    &#125;
    return res;
&#125;
void bld(int &amp;p, int l, int r) &#123;
    p = ++tot;
    if (l == r) &#123;
        t[p].l = t[p].r = l;
        if (a[l] &lt; 0)
            t[p].ll = 1, t[p].hl1 = -a[l];
        else
            t[p].rl = 1, t[p].hr0 = a[l];
        return;
    &#125;
    int mid = (l + r) &gt;&gt; 1;
    bld(t[p].lc, l, mid), bld(t[p].rc, mid + 1, r);
    t[p] = t[t[p].lc] + t[t[p].rc];
    return;
&#125;
void add(int p, int x, int v) &#123;
    if (t[p].l == t[p].r) &#123;
        if (v &lt; 0) &#123;
            t[p].rl = 0, t[p].hr0 = 0ll;
            t[p].ll = 1, t[p].hl1 = -v;
        &#125;
        else &#123;
            t[p].ll = 0, t[p].hl1 = 0ll;
            t[p].rl = 1, t[p].hr0 = v;
        &#125;
        return;
    &#125;
    int mid = (t[p].l + t[p].r) &gt;&gt; 1;
    if (x &lt;= mid)
        add(t[p].lc, x, v);
    else
        add(t[p].rc, x, v);
    t[p] = t[t[p].lc] + t[t[p].rc];
    return;
&#125;
int ask(int p, int l, int r) &#123;
    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r)
        return p;
    int mid = (t[p].l + t[p].r) &gt;&gt; 1;
    if (r &lt;= mid)
        return ask(t[p].lc, l, r);
    if (l &gt; mid)
        return ask(t[p].rc, l, r);
    int q = ++tot;
    t[q].lc = ask(t[p].lc, l, r);
    t[q].rc = ask(t[p].rc, l, r);
    t[q] = t[t[q].lc] + t[t[q].rc];
    return q;
&#125;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, k, rt = 0;
    std::cin &gt;&gt; n &gt;&gt; k;
    bpow[0] = inv[0] = 1ll;
    auto qkp = [&amp;](long long x, int y) &#123;
        auto res(1ll);
        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)
            if (y &amp; 1)
                (res *= x) %= mod;
        return res;
    &#125;;
    inv[1] = qkp(base, mod - 2);
    for (int i = 1; i &lt;= n; ++i) &#123;
        std::cin &gt;&gt; a[i];
        bpow[i] = bpow[i - 1] * base % mod;
        if (i &gt;= 2)
            inv[i] = inv[i - 1] * inv[1] % mod;
    &#125;
    bld(rt, 1, n);
    int q;
    std::cin &gt;&gt; q;
    for (int op; q--; ) &#123;
        std::cin &gt;&gt; op;
        if (op == 1) &#123;
            int x, v;
            std::cin &gt;&gt; x &gt;&gt; v;
            add(1, x, v);
        &#125;
        else &#123;
            int l, r;
            std::cin &gt;&gt; l &gt;&gt; r;
            if ((r - l + 1) &amp; 1)
                std::cout &lt;&lt; &quot;No&quot; &lt;&lt; &#39;\n&#39;;
            else &#123;
                auto s(ask(1, l, r));
                std::cout &lt;&lt; ((!t[s].flag &amp;&amp; !t[s].ll &amp;&amp; !t[s].rl) ? &quot;Yes&quot; : &quot;No&quot;) &lt;&lt; &#39;\n&#39;;
            &#125;
        &#125;
    &#125;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;</code></pre>
</details>
<hr />
<h4 id="hungry-cow-p"># Hungry Cow P</h4>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P9130" class="uri">https://www.luogu.com.cn/problem/P9130</a></p>
<hr />
<h4 id="牛客noip赛前集训营-提高组第六场牛半仙的妹子序列"># 2020牛客NOIP赛前集训营-提高组（第六场）牛半仙的妹子序列</h4>
<p><a target="_blank" rel="noopener" href="https://www.becoder.com.cn/problem/29550" class="uri">https://www.becoder.com.cn/problem/29550</a> / <a target="_blank" rel="noopener" href="https://ac.nowcoder.com/acm/contest/7615/D" class="uri">https://ac.nowcoder.com/acm/contest/7615/D</a></p>
<p>要用自己的号登录牛客才能看到 /qd</p>
<hr />
<h4 id="organizing-a-race"># Organizing a Race</h4>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/CF671E" class="uri">https://www.luogu.com.cn/problem/CF671E</a></p>
<p>这个题不太应该放在这里的，因为存在只用一只 log 的纯线段树上二分做法，用楼房重建显得有点唐了</p>
<hr />
<h4 id="转盘"># 转盘</h4>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P4425" class="uri">https://www.luogu.com.cn/problem/P4425</a></p>
<hr />
<h4 id="前进四楼房重建-ver"># 前进四（楼房重建 ver）</h4>
<p><a target="_blank" rel="noopener" href="https://uoj.ac/problem/515" class="uri">https://uoj.ac/problem/515</a></p>
<p>另见 <a href="#-前进四segment-tree-beats-ver">segment tree beats ver</a></p>
<h3 id="可持久化线段树">可持久化线段树</h3>
<h4 id="card-game"># Card Game</h4>
<p><a target="_blank" rel="noopener" href="https://qoj.ac/problem/8240" class="uri">https://qoj.ac/problem/8240</a></p>
<hr />
<h3 id="历史信息">历史信息</h3>
<ul>
<li>一类形如『询问 <span class="math inline">\([l,r]\)</span> 内合法子区间数量』的题目是可以考虑历史信息的</li>
<li>具体地，扫描线，对于每个 <span class="math inline">\(r\)</span>，把合法的 <span class="math inline">\(l\)</span> 答案加一</li>
<li>在每个 <span class="math inline">\(r\)</span> 处查询 <span class="math inline">\([l,r]\)</span> 的区间和就可以得出答案</li>
</ul>
<h4 id="铃原露露">铃原露露</h4>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P8528" class="uri">https://www.luogu.com.cn/problem/P8528</a></p>
<ul>
<li>题目形式满足树上支配对，考虑寻找支配关系</li>
<li><p>固定一个 LCA <span class="math inline">\(z\)</span>，讨论 <span class="math inline">\(a_z\)</span> 与 <span class="math inline">\(a_x,a_y\)</span> 的大小关系给 <span class="math inline">\([1,a_x]\)</span> 间的 <span class="math inline">\(l\)</span> 带来的限制：</p>
<ul>
<li><span class="math inline">\(a_z\in[a_x,a_y]\)</span>，<span class="math inline">\((x,y)\)</span> 总是合法，无限制。</li>
<li><span class="math inline">\(a_z&lt;a_x\)</span>，对于 <span class="math inline">\(r\ge a_y\)</span>，当 <span class="math inline">\(l\in(a_z,a_x]\)</span> 时，<span class="math inline">\((x,y)\)</span> 非法。</li>
<li><span class="math inline">\(a_z&gt;a_y\)</span>，当 <span class="math inline">\(r\in[a_y,a_z)\)</span> 时，<span class="math inline">\((x,y)\)</span> 总是非法。此时所有 <span class="math inline">\(l\in[1,a_x]\)</span> 不可选。</li>
</ul></li>
<li>发现固定 <span class="math inline">\(a_z,a_x\)</span>，那么当 <span class="math inline">\(a_y\)</span> 越靠近 <span class="math inline">\(a_x\)</span> 时给出的限制越紧，反之亦然，就可以得到这样的支配关系</li>
<li>容易发现当 <span class="math inline">\(a_z\notin [a_x,a_y]\)</span> 时，<span class="math inline">\((x,y)\)</span> 不合法；故只需要在 dsu on tree 上找到 <span class="math inline">\(a_x\)</span> 的前驱、后继并统计支配对即可</li>
<li><p>考虑询问，发现需要维护区间加、区间历史 0 个数，是好做的（这里的区间加并不对应 summary 中提到的区间加；对 0 的更新才是）。</p></li>
</ul>
<p>历史标记的下传需要格外注意一下，应该只保证标记期间存在 0 的区间拥有懒标记；具体地，<strong>只应将其下传到和当前区间最小值相同的子区间</strong>（具体可以看代码），容易证明是对的。</p>
<details>
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;
const int maxn = 2e5 + 5;
struct node &#123;
    long long s;
    int l, r, u, c, d, d1;
    node operator+ (const node q) const &#123;
        node res;
        res.s = s + q.s;
        res.l = l, res.r = q.r;
        res.u = std::min(u, q.u);
        res.d = res.d1 = res.c = 0;
        if (u == res.u)
            res.c = c;
        if (q.u == res.u)
            res.c += q.c;
        return res;
    &#125;
&#125; t[maxn &lt;&lt; 2];
#define lt (p &lt;&lt; 1)
#define rt (lt | 1)
void bld(int p, int l, int r) &#123;
    t[p].c = r - l + 1;
    t[p].l = l, t[p].r = r;
    if (l == r)
        return;
    int mid = (l + r) &gt;&gt; 1;
    bld(lt, l, mid), bld(rt, mid + 1, r);
    return;
&#125;
void pushdown(int p) &#123;
    if (t[p].d) &#123;
        t[lt].d += t[p].d, t[lt].u += t[p].d;
        t[rt].d += t[p].d, t[rt].u += t[p].d;
        t[p].d = 0;
    &#125;
    if (t[p].d1) &#123;
        if (t[lt].u == t[p].u) &#123;
            t[lt].s += (long long)t[lt].c * t[p].d1;
            t[lt].d1 += t[p].d1;
        &#125;
        if (t[rt].u == t[p].u) &#123;
            t[rt].s += (long long)t[rt].c * t[p].d1;
            t[rt].d1 += t[p].d1;
        &#125;
        t[p].d1 = 0;
    &#125;
    return;
&#125;
void add(int p, int l, int r, int v) &#123;
    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r) &#123;
        t[p].d += v, t[p].u += v;
        return;
    &#125;
    pushdown(p);
    int mid = (t[p].l + t[p].r) &gt;&gt; 1;
    if (l &lt;= mid)
        add(lt, l, r, v);
    if (r &gt; mid)
        add(rt, l, r, v);
    t[p] = t[lt] + t[rt];
    return;
&#125;
void upd(int p, int l, int r) &#123;
    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r) &#123;
        if (!t[p].u)
            t[p].s += t[p].c, ++t[p].d1;
        return;
    &#125;
    pushdown(p);
    int mid = (t[p].l + t[p].r) &gt;&gt; 1;
    if (l &lt;= mid)
        upd(lt, l, r);
    if (r &gt; mid)
        upd(rt, l, r);
    t[p] = t[lt] + t[rt];
    return;
&#125;
long long ask(int p, int l, int r) &#123;
    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r)
        return t[p].s;
    pushdown(p);
    auto res(0ll);
    int mid = (t[p].l + t[p].r) &gt;&gt; 1;
    if (l &lt;= mid)
        res = ask(lt, l, r);
    if (r &gt; mid)
        res += ask(rt, l, r);
    return res;
&#125;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, m;
    std::cin &gt;&gt; n &gt;&gt; m;
    std::vector&lt;int&gt; a(n + 1);
    for (int i = 1; i &lt;= n; ++i)
        std::cin &gt;&gt; a[i];
    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1); 
    for (int i = 2, x; i &lt;= n; ++i)
        std::cin &gt;&gt; x, g[x].push_back(i);
    std::vector&lt;int&gt; siz(n + 1), son(n + 1);
    std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;
        siz[x] = 1;
        for (auto i : g[x]) &#123;
            DFS(i);
            siz[x] += siz[i];
            if (siz[i] &gt; siz[son[x]])
                son[x] = i;
        &#125;
        return;
    &#125;;
    DFS(1);
    std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; u1(n + 1), u2(n + 1);
    std::function&lt;void(int, int, std::set&lt;int&gt; &amp;)&gt; DFS2 = [&amp;](int col, int x, std::set&lt;int&gt; &amp;t) &#123;
        auto p = t.lower_bound(a[x]);
        if (col == -1)
            t.insert(a[x]);
        else &#123;
            if (p != t.begin()) &#123;
                int y = *std::prev(p);
                if (col &lt; y)
                    u1[a[x]].emplace_back(col + 1, y);
                else if (col &gt; a[x]) &#123;
                    u1[a[x]].emplace_back(1, y);
                    u2[col].emplace_back(1, y);
                &#125;
            &#125;
            if (p != t.end()) &#123;
                int y = *p;
                if (col &lt; a[x])
                    u1[y].emplace_back(col + 1, a[x]);
                else if (col &gt; y) &#123;
                    u1[y].emplace_back(1, a[x]);
                    u2[col].emplace_back(1, a[x]);
                &#125;
            &#125;
        &#125;
        for (auto i : g[x])
            DFS2(col, i, t);
        return;
    &#125;;
    std::function&lt;void(int, std::set&lt;int&gt; &amp;)&gt; DFS1 = [&amp;](int x, std::set&lt;int&gt; &amp;t) &#123;
        if (son[x])
            DFS1(son[x], t);
        for (auto i : g[x])
            if (i != son[x]) &#123;
                std::set&lt;int&gt; nt;
                DFS1(i, nt);
            &#125;
        t.insert(a[x]);
        for (auto i : g[x])
            if (i != son[x])
                DFS2(a[x], i, t), DFS2(-1, i, t);
        return;
    &#125;;
    &#123;
        std::set&lt;int&gt; t;
        DFS1(1, t);
    &#125;
    std::vector&lt;long long&gt; res(m + 1);
    std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; t(n + 1);
    for (int i = 1, l, r; i &lt;= m; ++i) &#123;
        std::cin &gt;&gt; l &gt;&gt; r;
        t[r].emplace_back(l, i);
    &#125;
    bld(1, 1, n);
    for (int i = 1; i &lt;= n; ++i) &#123;
        for (auto [l, r] : u1[i])
            add(1, l, r, 1);
        for (auto [l, r] : u2[i])
            add(1, l, r, -1);
        upd(1, 1, i);
        for (auto [l, id] : t[i])
            res[id] = ask(1, l, i);
    &#125;
    for (int i = 1; i &lt;= m; ++i)
        std::cout &lt;&lt; res[i] &lt;&lt; &#39;\n&#39;;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;</code></pre>
</details>
<hr />
<h4 id="prof.-pangs-sequence-test_90">Prof. Pang’s sequence / TEST_90</h4>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P10822" class="uri">https://www.luogu.com.cn/problem/P10822</a> / <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P9990" class="uri">https://www.luogu.com.cn/problem/P9990</a></p>
<ul>
<li>离线扫描线，对于当前右端点 <span class="math inline">\(r\)</span>，记录每种数最后一次出现的位置 <span class="math inline">\(pos\)</span>。令 <span class="math inline">\(r\)</span> 的颜色为 <code>1</code>，从右到左，每碰到一个新的 <span class="math inline">\(pos\)</span> 就切换颜色。</li>
<li>显然对于当前 <span class="math inline">\(r\)</span>，应该被加一的 <span class="math inline">\(l\)</span> 就是颜色为 <code>1</code> 的这些位置。</li>
<li>考虑更快地维护这个过程，也就是在 <span class="math inline">\(r\)</span> 的颜色和 <span class="math inline">\(r-1\)</span> 不同时就可以对 <span class="math inline">\([1,r)\)</span> 做一次 flip，是可行的</li>
<li>在每个 <span class="math inline">\(r\)</span> 处查询 <span class="math inline">\([l,r]\)</span> 的区间和即可。</li>
</ul>
<details>
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;
const int maxn = 5e5 + 5;
struct &#123;
    long long s;
    int l, r, d0, d1, df, ds, u0, u1;
&#125; t[maxn &lt;&lt; 2];
#define lt (p &lt;&lt; 1)
#define rt (lt | 1)
void pushup(int p) &#123;
    t[p].u0 = t[lt].u0 + t[rt].u0;
    t[p].u1 = t[lt].u1 + t[rt].u1;
    return;
&#125;
void pushval(int p, long long v0, long long v1, bool f) &#123;
    if (f) &#123;
        t[p].df ^= 1;
        std::swap(t[p].u0, t[p].u1);
        std::swap(t[p].d0, t[p].d1);
    &#125;
    t[p].d0 += v0, t[p].d1 += v1;
    t[p].s += t[p].u0 * v0 + t[p].u1 * v1;
    return;
&#125;
void pushdown(int p) &#123;
    pushval(lt, t[p].d0, t[p].d1, t[p].df);
    pushval(rt, t[p].d0, t[p].d1, t[p].df);
    t[p].d0 = t[p].d1 = t[p].df = 0;
    return;
&#125;
void bld(int p, int l, int r) &#123;
    t[p].l = l, t[p].r = r;
    t[p].u0 = r - l + 1;
    if (l == r)
        return;
    int mid = (l + r) &gt;&gt; 1;
    bld(lt, l, mid), bld(rt, mid + 1, r);
    return;
&#125;
void flip(int p, int l, int r) &#123;
    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r) &#123;
        pushval(p, 0, 0, 1);
        return;
    &#125;
    pushdown(p);
    int mid = (t[p].l + t[p].r) &gt;&gt; 1;
    if (l &lt;= mid)
        flip(lt, l, r);
    if (r &gt; mid)
        flip(rt, l, r);
    pushup(p);
    return;
&#125;
long long ask(int p, int l, int r) &#123;
    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r)
        return t[p].s;
    pushdown(p);
    auto res(0ll);
    int mid = (t[p].l + t[p].r) &gt;&gt; 1;
    if (l &lt;= mid)
        res = ask(lt, l, r);
    if (r &gt; mid)
        res += ask(rt, l, r);
    return res;
&#125;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n;
    std::cin &gt;&gt; n;
    std::vector&lt;int&gt; a(n + 1), la(n + 1);
    for (int i = 1; i &lt;= n; ++i)
        std::cin &gt;&gt; a[i];
    int m;
    std::cin &gt;&gt; m;
    std::vector&lt;long long&gt; res(m + 1);
    std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; u(n + 1);
    for (int i = 1, l, r; i &lt;= m; ++i) &#123;
        std::cin &gt;&gt; l &gt;&gt; r;
        u[r].emplace_back(l, i);
    &#125;
    bld(1, 1, n);
    for (int r = 1; r &lt;= n; ++r) &#123;
        flip(1, la[a[r]] + 1, r);
        pushval(1, 0, 1, 0);
        for (auto [l, id] : u[r])
            res[id] = ask(1, l, r);
        la[a[r]] = r;
    &#125;
    for (int i = 1; i &lt;= m; ++i)
        std::cout &lt;&lt; res[i] &lt;&lt; &#39;\n&#39;;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;</code></pre>
</details>
<hr />
<h4 id="比赛"># 比赛</h4>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P8868" class="uri">https://www.luogu.com.cn/problem/P8868</a></p>
<hr />
<h4 id="v"># V</h4>
<p><a target="_blank" rel="noopener" href="https://uoj.ac/problem/164" class="uri">https://uoj.ac/problem/164</a></p>
<hr />
<h4 id="cartesian-tree"># Cartesian Tree</h4>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/CF1290E" class="uri">https://www.luogu.com.cn/problem/CF1290E</a></p>
<hr />
<h4 id="rprmq1"># rprmq1</h4>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P6109" class="uri">https://www.luogu.com.cn/problem/P6109</a></p>
<hr />
<h4 id="rpfrdtzls"># rpfrdtzls</h4>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P9057" class="uri">https://www.luogu.com.cn/problem/P9057</a></p>
<hr />
<h3 id="线段树合并">线段树合并</h3>
<p>树上的线段树合并都很熟悉了，利用了线段树合并是线性的，以及 dsu on tree</p>
<p>不如说绝大多数线段树合并都有树上背景，因为自带合并顺序和复杂度保证</p>
<p>Tip：树上合并的背景下，线段树合并的表现会比主席树优秀很多，因为前者跑不满</p>
<p>不在树上的问题，题目可能会通过各种方式保证复杂度，比如保证每个点只会被合并一次之类</p>
<hr />
<h4 id="迁移计划-migration-plan"># 迁移计划 / Migration Plan</h4>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P11993" class="uri">https://www.luogu.com.cn/problem/P11993</a></p>
<hr />
<h4 id="永无乡"># 永无乡</h4>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3224" class="uri">https://www.luogu.com.cn/problem/P3224</a></p>
<hr />
<h4 id="语言"># 语言</h4>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P5327" class="uri">https://www.luogu.com.cn/problem/P5327</a></p>
<hr />
<h4 id="梦幻布丁"># 梦幻布丁</h4>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3201" class="uri">https://www.luogu.com.cn/problem/P3201</a></p>
<hr />
<p>还有两个比较屎的 P7563 和 P7963</p>
<h3 id="扫描线">扫描线</h3>
<p>离线，按照下标排序，扫一遍处理询问，就可以利用『所有更靠前的下标都以被计算过』来处理问题</p>
<p>不只局限于区间询问，单点的可能反而更难一点，需要发现和下标大小有关的性质</p>
<h4 id="等差子序列">等差子序列</h4>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2757" class="uri">https://www.luogu.com.cn/problem/P2757</a></p>
<blockquote>
<p>给定一个 <span class="math inline">\(n\)</span> 的排列，问是否能找到 <span class="math inline">\(len\ge 3\)</span> 的子序列，使得其是等差的。</p>
<p><span class="math inline">\(n\le 5\times 10^5\)</span>。</p>
</blockquote>
<p>根据单调性，可以简化为 <span class="math inline">\(len=3\)</span> 时的答案</p>
<p>也就是对于中项 <span class="math inline">\(j\)</span>，能不能找到 <span class="math inline">\(i&lt;j&lt;k\)</span>，使得 <span class="math inline">\(a_j-a_i=a_k-a_j\)</span>。从下标出发，差值是不好维护的；注意到是排列，可以从值出发，转化成是否存在一个 <span class="math inline">\(d\)</span>，使得 <span class="math inline">\(a_j-d\)</span> 在之前出现，<span class="math inline">\(a_j+d\)</span> 在之后出现。</p>
<p>利用下标『之前』和『之后』的限制，做扫描线，查看是否存在 <span class="math inline">\(d\)</span> 使 <span class="math inline">\(a_j-d\)</span> 出现过但是 <span class="math inline">\(a_j+d\)</span> 没有出现过；还是因为是排列，数量只会为 <span class="math inline">\(0\)</span> 或 <span class="math inline">\(1\)</span>，如果非法说明 <span class="math inline">\(a_j-d\)</span> 和 <span class="math inline">\(a_j+d\)</span> 都是 <span class="math inline">\(0\)</span> 或者都是 <span class="math inline">\(1\)</span>，发现是关于 <span class="math inline">\(a_j\)</span> 的回文，故权值线段树维护哈希，如果 <span class="math inline">\(a_j\)</span> 两侧全部回文，说明 <span class="math inline">\(j\)</span> 不是合法中项。</p>
<details>
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;
namespace fastIO &#123;
const int LEN = (1 &lt;&lt; 20);
#ifdef ONLINE_JUDGE
inline int nec(void) &#123;
    static char buf[LEN], *p = buf, *e = buf;
    if (p == e) &#123;
        e = buf + fread(buf, 1, LEN, stdin);
        if (e == buf)
            return EOF;
        p = buf;
    &#125;
    return *p++;
&#125;
#else
#define nec getchar
#endif
inline bool read(int &amp;x) &#123;
    x = 0;
    bool f = 0;
    char ch = nec();
    while (ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123;
        if (ch == EOF)
            return 0;
        if (ch == &#39;-&#39;)
            f = 1;
        ch = nec();
    &#125;
    while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) &#123;
        x = x * 10 + ch - &#39;0&#39;;
        ch = nec();
    &#125;
    if (f)
        x = -x;
    return 1;
&#125;
void print(int x) &#123;
    if (x &lt; 0) &#123;
        putchar(&#39;-&#39;);
        x = -x;
    &#125;
    if (x &gt;= 10)
        print(x / 10);
    putchar(x % 10 + &#39;0&#39;);
    return;
&#125;
void print(int x, char ch) &#123;
    print(x);
    putchar(ch);
    return;
&#125;
&#125; // namespace fastIO
namespace XSC062 &#123;
using namespace fastIO;
#define lt (p &lt;&lt; 1)
#define rt (lt | 1)
using sc = unsigned long long;
const int p = 13331; // 0103 ¿É°®µÎÄó 
const int lim = 5e5;
const int maxn = 5e5 + 5;
struct _ &#123;
    int l, r;
    sc lh, rh;
&#125;;
int T, n;
int a[maxn];
sc base[maxn];
_ t[maxn &lt;&lt; 2];
int min(int x, int y) &#123;
    return x &lt; y ? x : y;
&#125;
int max(int x, int y) &#123;
    return x &gt; y ? x : y;
&#125;
void pushup(int p) &#123;
    int ll = t[lt].r - t[lt].l + 1;
    int rl = t[rt].r - t[rt].l + 1;
    t[p].lh = t[lt].lh * base[rl] + t[rt].lh;
    t[p].rh = t[rt].rh * base[ll] + t[lt].rh;
    return;
&#125;
void bld(int p, int l, int r) &#123;
    t[p].lh = t[p].rh = 0;
    t[p].l = l, t[p].r = r;
    if (l == r)
        return;
    int mid = (l + r) &gt;&gt; 1;
    bld(lt, l, mid);
    bld(rt, mid + 1, r);
    return;
&#125;
void upd(int p, int x, int v) &#123;
    if (t[p].l == t[p].r) &#123;
        t[p].lh = t[p].rh = v;
        return;
    &#125;
    int mid = (t[p].l + t[p].r) &gt;&gt; 1;
    if (x &lt;= mid)
        upd(lt, x, v);
    else upd(rt, x, v);
    pushup(p);
    return;
&#125;
sc qryl(int p, int l, int r) &#123;
    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r)
        return t[p].lh;
    sc ans = 0;
    int mid = (t[p].l + t[p].r) &gt;&gt; 1;
    if (l &lt;= mid)
        ans = qryl(lt, l, r);
    if (r &gt; mid) &#123;
        ans *= base[min(r, t[p].r) - mid];
        ans += qryl(rt, l, r);
    &#125;
    return ans;
&#125;
sc qryr(int p, int l, int r) &#123;
    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r)
        return t[p].rh;
    sc ans = 0;
    int mid = (t[p].l + t[p].r) &gt;&gt; 1;
    if (r &gt; mid)
        ans = qryr(rt, l, r);
    if (l &lt;= mid) &#123;
        ans *= base[mid - max(l, t[p].l) + 1];
        ans += qryr(lt, l, r);
    &#125;
    return ans;
&#125;
int main() &#123;
    read(T);
    base[0] = 1;
    for (int i = 1; i &lt;= lim; ++i)
        base[i] = base[i - 1] * p;
    while (T--) &#123;
        read(n);
        bld(1, 1, n);
        for (int i = 1; i &lt;= n; ++i)
            read(a[i]);
        for (int i = 1; i &lt;= n; ++i) &#123;
            int len = min(n - a[i], a[i] - 1);
            if (i &gt; 1) &#123;
                upd(1, a[i - 1], 1);
            &#125;
            if (len == 0)
                continue;
            int l = a[i] - len;
            int r = a[i] + len;
            if (qryl(1, l, a[i] - 1) !=
                qryr(1, a[i] + 1, r)) &#123;
                puts(&quot;Y&quot;);
                goto isSol;
            &#125;
        &#125;
        puts(&quot;N&quot;);
        isSol: ;
    &#125;
    return 0;
&#125;
&#125; // namespace XSC062
int main() &#123;
    XSC062::main();
    return 0;
&#125;</code></pre>
</details>
<h4 id="小奇的糖果">小奇的糖果</h4>
<p><a target="_blank" rel="noopener" href="https://hydro.ac/p/bzoj-P4548" class="uri">https://hydro.ac/p/bzoj-P4548</a></p>
<blockquote>
<p>有 <span class="math inline">\(N\)</span> 个有颜色（<span class="math inline">\(M\)</span> 种）的点在平面上，在平面上取一条水平的线段，可以选择线段上方的所有点，也可以选择下方的所有点。找出一条线段和选取的方向，使得在选取的点不包含所有颜色的前提下，最大化选到点的数量。</p>
<p><span class="math inline">\(N,M\le 10^6,|x|,|y|\le 10^9\)</span>。</p>
</blockquote>
<p>先离散化 + 按 <span class="math inline">\(y\)</span> 排序降一维，贪心地枚举某种颜色 <span class="math inline">\(c\)</span> 不选。考虑线段在平面最底部时的答案，取出所有颜色为 <span class="math inline">\(c\)</span> 的点的 <span class="math inline">\(x\)</span> 坐标，只能选择相邻的 <span class="math inline">\(x\)</span> 之间的所有点。枚举每一对相邻的点计算答案。把线段上移，如果碰到了一个颜色为 <span class="math inline">\(c\)</span> 的点，就说明这个点不再参与限制，删去即可，该点原前驱和后继围出来的区间就能够更新答案。用链表 / 单调栈就能很快地维护。</p>
<p>先枚举颜色再跑扫描线是 <span class="math inline">\(O(n^2\log n)\)</span> 的，考虑优化。注意到数据结构里存在当前颜色没有影响，因为一定不在询问区间内。整体做扫描线，复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p>
<details>
<pre class="cpp"><code>namespace XSC062 &#123;
using namespace fastIO;
const int maxn = 2e5 + 5;
struct _ &#123;
    int x, y, c;
    bool operator&lt; (const _ &amp;q) const &#123;
        return y &lt; q.y;
    &#125;
&#125;;
_ a[maxn];
int s[maxn], t[maxn];
int ls[maxn], rs[maxn];
int cp[maxn], cn[maxn];
int pre[maxn], nex[maxn];
std::vector&lt;int&gt; g[maxn];
int div[maxn], Bit[maxn];
int T, n, k, tot, cnt, now, res;
int max(int x, int y) &#123; return x &gt; y ? x : y; &#125;
int lowbit(int x) &#123; return x &amp; -x; &#125;
void add(int x, int v) &#123;
    for (; x &lt;= n; x += lowbit(x)) Bit[x] += v;
    return;
&#125;
int ask(int x) &#123;
    int res = 0;
    for (; x; x -= lowbit(x)) res += Bit[x];
    return res;
&#125;
int ask(int l, int r) &#123;
    if (l &gt; r) return 0;
    return ask(r) - ask(l - 1);
&#125;
int main() &#123;
//  freopen(&quot;1.in&quot;, &quot;r&quot;, stdin); 
    read(T);
    while (T--) &#123;
        read(n), read(k), now = res = 0;
        for (int i = 1; i &lt;= k; ++i) &#123;
            s[i] = ++now, t[i] = ++now;
            div[s[i]] = 0, div[t[i]] = n + 1;
            nex[s[i]] = t[i], pre[t[i]] = s[i];
            pre[s[i]] = nex[t[i]] = 0;
        &#125;
        for (int i = 1; i &lt;= n; ++i) &#123;
            read(a[i].x), read(a[i].y), read(a[i].c);
            ls[i] = a[i].x, rs[i] = a[i].y;
        &#125;
        std::sort(a + 1, a + n + 1, [&amp;](_ x, _ y) &#123; return x.x &lt; y.x; &#125;);
        std::sort(ls + 1, ls + n + 1);
        std::sort(rs + 1, rs + n + 1);
        tot = std::unique(ls + 1, ls + n + 1) - ls - 1;
        cnt = std::unique(rs + 1, rs + n + 1) - rs - 1;
        for (int i = 1; i &lt;= n; ++i) &#123;
            a[i].x = std::lower_bound(ls + 1, ls + tot + 1, a[i].x) - ls;
            a[i].y = std::lower_bound(rs + 1, rs + cnt + 1, a[i].y) - rs;
        &#125;
        for (int i = 1; i &lt;= n; ++i) &#123;
            div[++now] = a[i].x;
            add(a[i].x, 1), g[a[i].y].push_back(now);
            pre[now] = pre[t[a[i].c]], nex[pre[t[a[i].c]]] = now;
            pre[t[a[i].c]] = now, nex[now] = t[a[i].c];
        &#125;
        memcpy(cp, pre, sizeof (cp));
        memcpy(cn, nex, sizeof (cn));
        for (int i = 1; i &lt;= k; ++i) &#123;
            for (int j = s[i]; j != t[i]; j = nex[j])
                res = max(res, ask(div[j] + 1, div[nex[j]] - 1));
        &#125;
        for (int i = 1; i &lt;= n; ++i) &#123;
            for (auto j : g[i]) add(div[j], -1);
            for (auto j : g[i]) &#123;
                res = max(res, ask(div[pre[j]] + 1, div[nex[j]] - 1));
                nex[pre[j]] = nex[j], pre[nex[j]] = pre[j];
            &#125;
        &#125;
        for (int i = 1; i &lt;= n; ++i) add(a[i].x, 1);
        for (int i = n; i; --i) &#123;
            for (auto j : g[i]) add(div[j], -1);
            for (auto j : g[i]) &#123;
                res = max(res, ask(div[cp[j]] + 1, div[cn[j]] - 1));
                cn[cp[j]] = cn[j], cp[cn[j]] = cp[j];
            &#125;
        &#125;
        print(res, &#39;\n&#39;);
        for (int i = 1; i &lt;= n; ++i)
            g[i].clear(), g[i].shrink_to_fit();
    &#125;
    return 0;
&#125;
&#125; // namespace XSC062</code></pre>
</details>
<hr />
<h4 id="rmscne">rmscne</h4>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P7907" class="uri">https://www.luogu.com.cn/problem/P7907</a></p>
<blockquote>
<p>给定长为 <span class="math inline">\(n\)</span> 的序列，<span class="math inline">\(q\)</span> 次询问 <span class="math inline">\([l,r]\)</span> 中的最短子区间 <span class="math inline">\([l&#39;,r&#39;]\)</span>，使得其包含 <span class="math inline">\([l,r]\)</span> 中出现的全部值。输出长度即可。</p>
<p><span class="math inline">\(n,q,V\le 2\times 10^6\)</span>。</p>
</blockquote>
<p>区间里面找子区间也是扫描线经典问题。</p>
<p>区间种类数会有几种思路：集合哈希、前驱后继、莫队之类。PS：这个题用 ODT 可以拿到最优解</p>
<p>对于 <span class="math inline">\(i=1\sim n\)</span>，依次考虑 <span class="math inline">\(i\)</span> 作为右端点的情况。线段树维护每个 <span class="math inline">\(j\)</span> 作为左端点时的 <span class="math inline">\(i-r_j\)</span>，其中 <span class="math inline">\([j, r_j]\)</span> 是与 <span class="math inline">\([j,i]\)</span> 种类相同的最小区间。</p>
<p>询问的时候，只需要找到最大的 <span class="math inline">\(j&#39;\)</span>，满足 <span class="math inline">\([j, r]\)</span> 与 <span class="math inline">\([l, r]\)</span> 种类相同，求 <span class="math inline">\([l, j&#39;]\)</span> 的区间和即可。找 <span class="math inline">\(j&#39;\)</span> 可以记录前驱后继，初始每个 <span class="math inline">\(l\)</span> 对应的 <span class="math inline">\(j&#39;\)</span> 就是自己。若加入了一个与 <span class="math inline">\(l\)</span> 相同的新元素，那么 <span class="math inline">\(l\)</span> 就不再有贡献，此时 <span class="math inline">\(l\)</span> 的 <span class="math inline">\(j&#39;\)</span> 就会继承 <span class="math inline">\(l+1\)</span> 的 <span class="math inline">\(j&#39;\)</span>，这个过程用并查集即可简单维护。</p>
<details>
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;
const int lim = 2e6;
const int maxn = 2e6 + 5;
const int maxm = 5e7 + 5;
const int inf = 0x3f3f3f3f;
struct &#123; int l, r, u, d; &#125; t[maxn &lt;&lt; 2];
int tot;
#define lt (p &lt;&lt; 1)
#define rt (lt | 1)
void pushdown(int p) &#123;
    if (~t[p].d) &#123;
        t[lt].d = t[rt].d = t[p].d;
        t[lt].u = t[p].d - t[lt].r + 1;
        t[rt].u = t[p].d - t[rt].r + 1;
        t[p].d = -1;
    &#125;
    return;
&#125;
void bld(int p, int l, int r) &#123;
    t[p].l = l, t[p].r = r, t[p].d = -1;
    if (l == r)
        return;
    int mid = (l + r) &gt;&gt; 1;
    bld(lt, l, mid), bld(rt, mid + 1, r);
    return;
&#125;
void upd(int p, int l, int r, int v) &#123;
    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r) &#123;
        t[p].d = v, t[p].u = v - t[p].r + 1;
        return;
    &#125;
    pushdown(p);
    int mid = (t[p].l + t[p].r) &gt;&gt; 1;
    if (l &lt;= mid)
        upd(lt, l, r, v);
    if (r &gt; mid)
        upd(rt, l, r, v);
    t[p].u = std::min(t[lt].u, t[rt].u);
    return;
&#125;
int ask(int p, int l, int r) &#123;
    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r)
        return t[p].u;
    pushdown(p);
    int mid = (t[p].l + t[p].r) &gt;&gt; 1, res = inf;
    if (l &lt;= mid)
        res = ask(lt, l, r);
    if (r &gt; mid)
        res = std::min(res, ask(rt, l, r));
    return res;
&#125;
#undef lt
#undef rt
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n, q;
    std::cin &gt;&gt; n;
    std::vector&lt;int&gt; a(n + 1), la(lim + 1), pre(n + 1), f(n + 1);
    for (int i = 1; i &lt;= n; ++i) &#123;
        std::cin &gt;&gt; a[i];
        pre[i] = la[a[i]], la[a[i]] = i, f[i] = i;
    &#125;
    std::cin &gt;&gt; q;
    std::vector&lt;int&gt; res(q + 1);
    std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; t(n + 1);
    for (int i = 1, l, r; i &lt;= q; ++i) &#123;
        std::cin &gt;&gt; l &gt;&gt; r;
        t[r].emplace_back(l, i);
    &#125;
    bld(1, 1, n);
    std::function&lt;int(int)&gt; find = [&amp;](int x) &#123;
        return x == f[x] ? x : f[x] = find(f[x]);
    &#125;;
    auto merge = [&amp;](int x, int y) &#123;
        x = find(x), y = find(y);
        f[std::min(x, y)] = std::max(x, y);
        return;
    &#125;;
    for (int r = 1; r &lt;= n; ++r) &#123;
        if (pre[r])
            merge(pre[r], pre[r] + 1);
        upd(1, pre[r] + 1, r, r);
        for (auto [l, i] : t[r])
            res[i] = ask(1, l, find(l));
    &#125;
    for (int i = 1; i &lt;= q; ++i)
        std::cout &lt;&lt; res[i] &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;</code></pre>
</details>
<hr />
<h4 id="颜色"># 颜色</h4>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P4065" class="uri">https://www.luogu.com.cn/problem/P4065</a></p>
<blockquote>
<p>给定 <span class="math inline">\(n\)</span> 个元素，每个元素有一个颜色。选择若干颜色（不能全选或全不选），问有多少种选取方案使得拥有这些颜色的点是一段连续的区间。</p>
<p><span class="math inline">\(n\le 3\times 10^5\)</span>。</p>
</blockquote>
<hr />
<h3 id="线段树-势能">线段树 + 势能</h3>
<h4 id="市场"># 市场</h4>
<p><a target="_blank" rel="noopener" href="https://loj.ac/p/6029" class="uri">https://loj.ac/p/6029</a></p>
<hr />
<h4 id="segment-tree-beats"># Segment Tree Beats!</h4>
<blockquote>
<p>维护区间取 min，区间求和。</p>
</blockquote>
<p>pdf P57</p>
<hr />
<h4 id="segment-tree-beats-plus"># Segment Tree Beats! Plus</h4>
<blockquote>
<p>维护区间加，区间取 min，区间求和。</p>
</blockquote>
<p>pdf P60</p>
<hr />
<h4 id="最假女选手"># 最假女选手</h4>
<p><a target="_blank" rel="noopener" href="https://loj.ac/p/6565" class="uri">https://loj.ac/p/6565</a></p>
<hr />
<h4 id="mzl-loves-segment-tree"># Mzl loves segment tree</h4>
<p><a target="_blank" rel="noopener" href="https://www.becoder.com.cn/problem/10203" class="uri">https://www.becoder.com.cn/problem/10203</a></p>
<p>pdf P66</p>
<hr />
<h4 id="ctsn-loves-segment-tree"># CTSN loves segment tree</h4>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/U180387" class="uri">https://www.luogu.com.cn/problem/U180387</a></p>
<hr />
<h4 id="前进四segment-tree-beats-ver"># 前进四（segment tree beats ver）</h4>
<p><a target="_blank" rel="noopener" href="https://uoj.ac/problem/515" class="uri">https://uoj.ac/problem/515</a></p>
<p>另见 <a href="#-前进四楼房重建-ver">楼房重建 ver</a></p>
<hr />
<h4 id="基础数据结构练习题"># 基础数据结构练习题</h4>
<p><a target="_blank" rel="noopener" href="https://uoj.ac/problem/228" class="uri">https://uoj.ac/problem/228</a></p>
<hr />
<h4 id="线段树-3"># 线段树 3</h4>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P6242" class="uri">https://www.luogu.com.cn/problem/P6242</a></p>
<hr />
<h4 id="赛格蒙特彼茨"># 赛格蒙特彼茨</h4>
<p>pdf P70</p>
<hr />
<h4 id="堕天作战-test_98"># 堕天作战 TEST_98</h4>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P9069" class="uri">https://www.luogu.com.cn/problem/P9069</a></p>
<hr />
<h3 id="线段树分治">线段树分治</h3>
<h4 id="meetings-会议"># meetings 会议</h4>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P5044" class="uri">https://www.luogu.com.cn/problem/P5044</a></p>
<h4 id="八纵八横"># 八纵八横</h4>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3733" class="uri">https://www.luogu.com.cn/problem/P3733</a></p>
<h2 id="笛卡尔树">笛卡尔树</h2>
<p>一些思考方式和 trick 吧</p>
<h3 id="由乃救爷爷">* 由乃救爷爷</h3>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3793" class="uri">https://www.luogu.com.cn/problem/P3793</a></p>
<blockquote>
<p>尽可能快地维护随机序列区间最值。</p>
</blockquote>
<p>随机序列笛卡尔树期望深度是 <span class="math inline">\(\log\)</span>。就可以做了。</p>
<p>来自 <a target="_blank" rel="noopener" href="https://www.luogu.com/article/hj9ci08q">UnyieldingTrilobite 的文章</a>：同样可以用悬线！<a href="/20231117/#随机序列悬线结合分块">悬线 + 分块</a> 就可以做了。</p>
<hr />
<h3 id="情景剧最值的性质维护方式的取舍">* 情景剧（最值的性质，维护方式的取舍）</h3>
<p><a target="_blank" rel="noopener" href="https://www.becoder.com.cn/contest/4273/problem/1" class="uri">https://www.becoder.com.cn/contest/4273/problem/1</a></p>
<blockquote>
<p>给定长度为 <span class="math inline">\(n\)</span> 的序列 <span class="math inline">\(a_{1\sim n}\)</span>，找到一个区间，使得 区间长度 <span class="math inline">\(\times\)</span> 区间最大值 <span class="math inline">\(\times\)</span> 区间最小值 最大。输出最大值。</p>
<p><span class="math inline">\(n\le 10^6,V\le 10^9\)</span>。</p>
</blockquote>
<ul>
<li>容易想到建笛卡尔树。这里的 最大值 和 最小值 地位相等吗？为什么？</li>
<li>如果我们是钦定最大值，再去最大化『最小值 <span class="math inline">\(\times\)</span> 区间长』，好像没办法做，因为这个最大贡献没什么性质</li>
<li><p>但如果钦定最小值，能取到的最长区间就是在小根笛卡尔树上的管辖区间，显然区间越长取到的最大值也越大，直接取这里的最大值即可</p>
所以最大值和最小值地位不等是因为，区间长和最大值大小是正相关的，所以只需要最大化区间长，最大值也就最大化了</li>
<li><p>所以在小根笛卡尔树上维护区间最大值即可</p></li>
</ul>
<hr />
<h3 id="小蓝的好友"># 小蓝的好友</h3>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2611" class="uri">https://www.luogu.com.cn/problem/P2611</a></p>
<hr />
<h3 id="星白-by-ttpandas笛卡尔树-dsu-on-tree">星白 by TTpandaS（笛卡尔树 + dsu on tree）</h3>
<p><a target="_blank" rel="noopener" href="https://www.becoder.com.cn/contest/6517/problem/3" class="uri">https://www.becoder.com.cn/contest/6517/problem/3</a></p>
<blockquote>
<p>给定 <span class="math inline">\(n\)</span> 的排列 <span class="math inline">\(a_{1\sim n}\)</span>，回答 <span class="math inline">\(q\)</span> 个询问：</p>
<ul>
<li><p>给定 <span class="math inline">\([l,r]\)</span>，是否存在 <span class="math inline">\(l\le x&lt;y\le r\)</span>，使得：</p>
<ul>
<li><span class="math inline">\(a_x&lt;a_y\)</span>，且 <span class="math inline">\(a_x\)</span> 不为 <span class="math inline">\([x,y]\)</span> 中最小值；</li>
<li>令 <span class="math inline">\(a_i\)</span> 为 <span class="math inline">\([x, y]\)</span> 中最小值，则 <span class="math inline">\(a_i\mid (a_x\cdot a_y)\)</span>。</li>
</ul></li>
</ul>
<p><span class="math inline">\(n\le 3\times 10^5,q\le10^6\)</span>。</p>
</blockquote>
<ul>
<li>容易想到对于 <span class="math inline">\(i\)</span> 反过来找 <span class="math inline">\([x,y]\)</span>。如果建立小根笛卡尔树，在 <span class="math inline">\(i\)</span> 的左边找 <span class="math inline">\(x\)</span>、右边找 <span class="math inline">\(y\)</span>。</li>
<li><p>一个自然的想法是对于左侧的每个 <span class="math inline">\(x\)</span>，维护最近的合法 <span class="math inline">\(y\)</span>；或是对于右侧的每个 <span class="math inline">\(y\)</span>，维护最近的合法 <span class="math inline">\(x\)</span>。</p>
做一个 DSU on Tree，哪边区间短就维护哪边，是单 <span class="math inline">\(\log\)</span> 的。</li>
<li><p>需要解决点内预处理，以 <span class="math inline">\(x\)</span> 为例，对于每个 <span class="math inline">\(x\)</span> 和当前点 <span class="math inline">\((p,l,r)\)</span>，需要查询 <span class="math inline">\((p, r]\)</span> 中最小的 <span class="math inline">\(y\)</span>，使得 <span class="math inline">\(a_y\)</span> 是 <span class="math inline">\(\dfrac {a_p}{\gcd(a_x,a_p)}\)</span> 的倍数。离线下来扫描线，<del>开 <span class="math inline">\(n\)</span> 棵线段树</del>，跑 <span class="math inline">\(n\)</span> 次树状数组，用 <span class="math inline">\(y\)</span> 更新所有 <span class="math inline">\(a_y\)</span> 因数在 <span class="math inline">\(a_y\)</span> 处的 min / max，可以在两个 log 内获得支配对类似物。</p>
不是很理解为什么题目要再加一个偏序限制，除了增加代码量和用时外似乎并没有什么作用？</li>
<li><p>查询时直接 rmq（这里唐了写了 st 表，实际上只需要前后缀）即可。整体复杂度 <span class="math inline">\(O(n\log^2 n)\)</span>。</p></li>
</ul>
<details>
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;
const int LEN = (1 &lt;&lt; 20);
#ifdef ONLINE_JUDGE
int nec(void) &#123;
    static char buf[LEN], *p = buf, *e = buf;
    if (p == e) &#123;
        e = buf + fread(buf, 1, LEN, stdin);
        if (e == buf) return EOF;
        p = buf;
    &#125;
    return *p++;
&#125;
#else
#define nec getchar
#endif
bool read(int &amp;x) &#123;
    x = 0;
    bool f = 0;
    char ch = nec();
    while (ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123;
        if (ch == EOF) return 0;
        if (ch == &#39;-&#39;) f = 1;
        ch = nec();
    &#125;
    while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) &#123;
        x = x * 10 + ch - &#39;0&#39;;
        ch = nec();
    &#125;
    if (f) x = -x;
    return 1;
&#125;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n;
    read(n);
    std::vector&lt;std::vector&lt;int&gt; &gt; mul(n + 1);
    std::vector&lt;int&gt; a(n + 1), l(n + 1), r(n + 1), pos(n + 1);
    for (int i = 1; i &lt;= n; ++i) &#123;
        read(a[i]), pos[a[i]] = i;
        for (l[i] = i; l[i] != 1 &amp;&amp; a[i] &lt; a[l[i] - 1]; l[i] = l[l[i] - 1]);
    &#125;
    for (int i = 1; i &lt;= n; ++i) &#123;
        for (int j = i; j &lt;= n; j += i)
            mul[i].push_back(pos[j]);
        std::sort(mul[i].begin(), mul[i].end());
    &#125;
    for (int i = n; i; --i)
        for (r[i] = i; r[i] != n &amp;&amp; a[i] &lt; a[r[i] + 1]; r[i] = r[r[i] + 1]);
    struct query &#123; int id, l, r; &#125;;
    std::vector&lt;std::vector&lt;query&gt; &gt; ql(n + 1), qr(n + 1);
    for (int i = 1; i &lt;= n; ++i)
        if (i - l[i] &lt; r[i] - i)
            for (int j = l[i]; j &lt; i; ++j)
                qr[a[i] / std::__gcd(a[i], a[j])].push_back(&#123; j, i + 1, r[i] &#125;);
        else
            for (int j = i + 1; j &lt;= r[i]; ++j)
                ql[a[i] / std::__gcd(a[i], a[j])].push_back(&#123; j, l[i], i - 1 &#125;);
    std::vector&lt;int&gt; u(n + 1), rt(n + 1), bit(n + 1);
    auto lowbit = [](int x) &#123;
        return x &amp; -x;
    &#125;;
    auto add = [&amp;](int x, int v) &#123;
        for (; x &lt;= n; x += lowbit(x))
            bit[x] = v;
        return;
    &#125;;
    std::function&lt;int(int)&gt; ask = [&amp;](int x) &#123;
        int res = 0;
        for (; x; x -= lowbit(x))
            res = std::max(res, bit[x]);
        return res;
    &#125;;
    for (int fac = 1; fac &lt;= n; ++fac) &#123;
        std::sort(ql[fac].begin(), ql[fac].end(), [&amp;](query x, query y) &#123; return x.r &lt; y.r; &#125;);
        auto i = mul[fac].begin();
        for (auto [id, l, r] : ql[fac]) &#123;
            for (; i != mul[fac].end() &amp;&amp; *i &lt;= r; ++i)
                add(a[*i], *i);
            auto mx(ask(a[id]));
            if (mx &gt;= l)
                u[id] = std::max(u[id], mx);
        &#125;
        for (auto i : mul[fac])
            add(a[i], 0);
    &#125;
    bit.assign(n + 1, 0x3f3f3f3f);
    ask = [&amp;](int x) &#123;
        int res = 0x3f3f3f3f;
        for (; x; x -= lowbit(x))
            res = std::min(res, bit[x]);
        return res;
    &#125;;
    for (int fac = 1; fac &lt;= n; ++fac) &#123;
        std::sort(qr[fac].begin(), qr[fac].end(), [&amp;](query x, query y) &#123; return x.l &gt; y.l; &#125;);
        std::reverse(mul[fac].begin(), mul[fac].end());
        auto i = mul[fac].begin();
        for (auto [id, l, r] : qr[fac]) &#123;
            for (; i != mul[fac].end() &amp;&amp; *i &gt;= l; ++i)
                add(n - a[*i] + 1, *i);
            auto mn(ask(n - a[id] + 1));
            if (mn &lt;= r)
                u[mn] = std::max(u[mn], id);
        &#125;
        for (auto i : mul[fac])
            add(n - a[i] + 1, 0x3f3f3f3f);
    &#125;
    std::vector&lt;std::vector&lt;int&gt; &gt; st(20, std::vector&lt;int&gt; (n + 1));
    for (int i = 1; i &lt;= n; ++i) &#123;
        // if (u[i] != 0)
        //     printf(&quot;%d %d\n&quot;, u[i], i);
        st[0][i] = u[i];
    &#125;
    for (int j = 1; (1 &lt;&lt; j) &lt;= n; ++j)
        for (int i = 1; i + (1 &lt;&lt; j) - 1 &lt;= n; ++i)
            st[j][i] = std::max(st[j - 1][i], st[j - 1][i + (1 &lt;&lt; (j - 1))]);
    auto askmx = [&amp;](int l, int r) &#123;
        int k = std::__lg(r - l + 1);
        return std::max(st[k][l], st[k][r - (1 &lt;&lt; k) + 1]);
    &#125;;
    int q;
    read(q);
    for (int l, r; q--; ) &#123;
        read(l), read(r);
        std::cout &lt;&lt; (askmx(l, r) &gt;= l ? &quot;Yes&quot; : &quot;No&quot;) &lt;&lt; &#39;\n&#39;;
    &#125;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;</code></pre>
</details>
<hr />
<h3 id="periodni"># PERIODNI</h3>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P6453" class="uri">https://www.luogu.com.cn/problem/P6453</a></p>
<hr />
<h2 id="cdq-分治">CDQ 分治</h2>
<h3 id="coloring-nodes偏序很隐秘"># Coloring Nodes（偏序很隐秘）</h3>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P12423" class="uri">https://www.luogu.com.cn/problem/P12423</a></p>
<hr />
<h2 id="字典树">字典树</h2>
<p>字典树作为 log 数据结构的时候，等价权值线段树，而且支持合并、分裂（权值线段树 also OK，强调一下而已）</p>
<p>有些情景 Trie 写起来会比权值线段树舒服一些，比如值域操作、二进制操作之类</p>
<h3 id="异或粽子"># 异或粽子</h3>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P5283" class="uri">https://www.luogu.com.cn/problem/P5283</a></p>
<hr />
<h3 id="friends"># Friends</h3>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/CF241B" class="uri">https://www.luogu.com.cn/problem/CF241B</a></p>

			</div>
			<hr class="dotted">
			<div class="post footer">
				<div id="hitokoto">
					<h3 id="hitokoto-title">
						言论
					</h3>
					<div id="hitokoto-content">
					</div>
					<div id="hitokoto-from">
					</div>
				</div>
				<div class="button flex">
					<div id="prev">
						
							<!-- 吐槽，为啥还需要加 / -->
							<a href="/20250820/">
								<i class="fas fa-angle-double-left" style="margin-right: 10px;"></i>
								杂题选谈
							</a>
						
					</div>
					<div id="next">
						
							<a href="/20250816/">
								杂题选谈
								<i class="fas fa-angle-double-right" style="margin-left: 10px;"></i>
							</a>
						
					</div>
				</div>
				<div id="vcomments" class="text"></div>
<script>
	new Valine({
		el: '#vcomments',
		appId: 'OlmvQ0a2Zw7xo3no2bwabOzx-gzGzoHsz',
		appKey: 'TW6t8mFeGLmhPjWisvmllvvo',
		recordIP: true,
		enableQQ: true, 
		// [EDITED] 目前 Valine 的 QQ 自动获取昵称似乎不可用
		// 该问题在 v1.5.3 中已修复
		pageSize: 10,
		requiredFields:
			
				['nick']
			,
		placeholder: "The world is but a little place after all...\n能够根据邮箱获取你的 Gravatar 头像。昵称是必填项，长度需不低于 3。",
		avatar: 'identicon',
		avatar_cdn: 'https://cravatar.cn/avatar/',
		emojiCDN: 'https://xsc062.netlify.app/em/', 
		emojiMaps: {
			
				"微笑": "wx.gif",
			
				"龇牙": "cy.gif",
			
				"流泪": "ll.gif",
			
				"笑哭": "xk.gif",
			
				"流汗": "lh.gif",
			
				"擦汗": "ch.gif",
			
				"亲亲": "qq.gif",
			
				"色": "se.gif",
			
				"疑问": "yiw.gif",
			
				"发呆": "fd.gif",
			
				"晕": "yun.gif",
			
				"鼓掌": "gz.gif",
			
				"憨笑": "hanx.gif",
			
				"快哭了": "kk.gif",
			
				"得意": "dy.gif",
			
				"狂笑": "kx.gif",
			
				"害羞": "hx.gif",
			
				"妈妈生的": "dz.gif",
			
				"糗大了": "qd.gif",
			
				"吃瓜": "cg.gif",
			
				"睁眼": "zy.webp",
			
				"辣眼睛": "lyj.gif",
			
				"酸了": "nm.gif",
			
				"滚": "gun.webp",
			
				"惊恐": "jk.gif",
			
				"幽灵": "youl.gif",
			
				"无聊": "wul.gif",
			
				"吃": "eat.gif",
			
				"你很棒棒": "bb.gif",
			
				"赞": "qiang.gif",
			
				"踩": "ruo.gif",
			
				"握手": "wsh.gif",
			
				"发抖": "fad.gif",
			
				"挥手": "hsh.gif",
			
				"磕头": "kt.gif",
			
				"怄火": "oh.gif",
			
		},
		mathjax: true,
	})
</script>
			</div>
			<script>setHitokoto();</script>
		</div> 
	</div>
</div>
    <!-- 页脚开始 -->
<div id="footer" class="serif">
    Powered by
    <a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a>
    &
    <a href="/about-this-theme">
        iwll
    </a>
    <p style="margin-top: 5px;">
        2021 - 2025
    </p>
    <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/" id="CCTAG"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/big/by_nc_sa.svg"></a>
</div>
<!-- Valine 相关配置 -->
<script>
    const getValineDomTimer = setInterval(() => {
        // 不知道为什么 我从原博客 js 文件粘过来的参数是
        // "#valine .vcards .vcard"
        // DEBUG 了半天才定位到这个问题。。。
        const vcards =
            document.querySelectorAll('#valine, .vcards, .vcard');
        if (vcards.length > 0) {
            let author = 'XSC062';
            for (let vcard of vcards) {
                const vnick_dom = vcard.querySelector('.vhead .vnick');
                if (vnick_dom != null) {
                    const vnick = vnick_dom.innerHTML;
                    if (vnick === author) {
                        vnick_dom.innerHTML =
                        `${vnick} <span id="rootitem" class="code">root</span>`
                    }
                }
            }
        }
        else {
            clearInterval(getValineDomTimer);
        }
    }, 2000);
    SetActiveItem();
    setDetailsSummary();
    setTitleAnchor();
    setEmptyToc();
    setCodeClassName();
</script>


<!-- js -->
<!-- 搜索功能相关配置 -->

<script src="/js/search.js"></script>


<script src="/js/local-search.js"></script>

</script>
<!-- prism 相关配置 -->
<script type="text/javascript" src="/js/prism.js" defer></script>
<!-- 代码块复制功能 -->
<script type="text/javascript" src="/js/clipboard.min.js"></script>
<script type="text/javascript" src="/js/clipboard-use.js"></script>
<!-- 页脚结束 -->
</body>
</html>