<!DOCTYPE html>
<html>
<head>
    <!-- 网站图标 -->
<link rel="icon" type="image/png" sizes="32x32" href="/images/icon.svg">
<!-- 其他图标支持 -->
<link rel="stylesheet" href="/css/facss/fa-brands.min.css">
<link rel="stylesheet" href="/css/facss/fa-regular.min.css">
<link rel="stylesheet" href="/css/facss/fa-solid.min.css">
<link rel="stylesheet" href="/css/facss/fontawesome.min.css">
<link rel="stylesheet" href="/css/facss/fontawesome-all.css">
<link href="https://use.fontawesome.com/releases/v5.0.4/css/all.css" rel="stylesheet">
<!-- 网站标题 -->
<title>
	
		杂题选谈 -
	
	XSC062 的博客
</title>
<!-- js 引入 -->
<script>
const searchPath = "/search.xml"
</script>

<script src="/js/afterloaded.js"></script>


<script src="/js/jQuery.js"></script>

<!-- 载入 Valine -->

<script src="/js/Valine.min.js"></script>

<!-- css 引入 -->

<link rel="stylesheet" href="/css/layout.css">


<link rel="stylesheet" href="/css/prcss/prism.css">



<!-- rss -->
<link rel="alternate" type="application/rss+xml" title="" href="https://xsc062.netlify.app/rss.xml" />
<link rel="alternate" type="application/atom+xml" title="" href="https://xsc062.netlify.app/atom.xml" />
<link rel="alternate" type="application/json" title="" href="https://xsc062.netlify.app/feed.json" />

<meta charset="utf-8"> 
    
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
          tex2jax: {
            inlineMath: [ ['$','$'], ["\\(","\\)"] ],
            processEscapes: true
          }
        });
      </script>
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
            tex2jax: {
              skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
            }
          });
      </script>
    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
              var all = MathJax.Hub.getAllJax(), i;
              for(i=0; i < all.length; i += 1) {
                  all[i].SourceElement().parentNode.className += ' has-jax';
              }
          });
      </script>
    <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS_CHTML"></script>

<meta name="generator" content="Hexo 7.2.0"></head>
<body class="line-numbers match-braces no-brace-select rainbow-braces">
	<!-- 搜索 -->
<script>
	function closeSearchBox() {
		$("#search-bg").css("transition", "null"); 
		$("#search-bg").css("z-index", "-1"); 
		$("#search-bg").css("opacity", "0%");
		return;
	}
</script>
<div id="search-bg">
	<div id="search-box">
		<button id="close-button" onclick="closeSearchBox()">
			<i class="fas fa-times"></i>
		</button>
		<input type="text" id="search-input" placeholder="Type to search...">
		<div id="search-results">
			<div id="emptyInput">
				<p>键入以搜索…</p>
				<p><i>匹配算法</i>：把输入按空格拆分，单独<strong>匹配</strong>每一段输入（不区分大小写，仅匹配文章文本内容），输出取或后的结果。</p>
				<p>模糊搜索似乎很难搞，目前没有相关打算。</p>
			</div>
		</div>
	</div>
</div>
<!-- 顶栏整体导航菜单 -->
<div class="ui top menu">
	<!-- 左对齐 logo -->
	<a class="logo" href="/">
		<img width="25px" height="25px" style="border: solid transparent 2.5px" src="/images/icon.svg"></img>
		<div id="bartitle" class="text">
			XSC062 的博客
		</div>
	</a>
	<!-- 右对齐部分导航 -->
	<div id="rightali" class="serif">
		<a class="item" id="Search" type="button">
			<i class="btn text-muted fa fa-search" id="search-icon" disabled></i>
		</a>
		<a class="item" id="Home" href="/">
			Home
		</a>
		<a class="item" id="Arch" href="/archives">
			Archives
		</a>
		<!-- <a class="item" id="Cate" href="/categories">
			Categories
		</a> -->
		<a class="item" id="Tags" href="/tags">
			Tags
		</a>
		<a class="item" id="Frie" href="/friends">
			Friends
		</a>
		<a class="item" id="Abou" href="/about">
			About
		</a>
	</div>
</div>
    
<link rel="stylesheet" href="/css/post.css">


<script src="/js/post.js"></script>


<div class="main">
	<div id="sidebar" class="text">
		<aside id="toc">
			<span id="toctitle">
				<i class="fas fa-list"></i>
				目录
			</span>
			<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#c.-meat"><span class="toc-text">C. meat</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#b.-port"><span class="toc-text">B. port</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#c.-west"><span class="toc-text">C. west</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#d.-egypt"><span class="toc-text">D. egypt</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#a.-%E5%8D%83%E4%B8%87%E9%81%93%E4%BC%A4%E7%97%95wound"><span class="toc-text">A. 千万道伤痕（wound）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#b.-%E7%8C%AB%E5%84%BF%E5%B0%8Fmex-cf1870g-mexanization"><span class="toc-text">B. 猫儿小（mex）&#x2F; CF1870G MEXanization</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#c.-%E6%98%9F%E4%B9%8B%E5%8D%A1%E6%AF%94mismatch"><span class="toc-text">C. 星之卡比（mismatch）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#d.-%E6%BD%AE%E6%B0%B4%E5%95%8A%E6%88%91%E5%B7%B2%E5%BD%92%E6%9D%A5wave-p14035-paio-2025-gcd"><span class="toc-text">D. 潮水啊，我已归来（wave）&#x2F; P14035 [PAIO 2025] GCD</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#b.-%E5%B8%9D%E5%9B%BD-cf1181e2-a-story-of-one-country-hard"><span class="toc-text">B. 帝国 &#x2F; CF1181E2 A Story of One Country (Hard)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#c.-%E5%B9%B3%E8%A1%A1-cf1211h-road-repair-in-treeland"><span class="toc-text">C. 平衡 &#x2F; CF1211H Road Repair in Treeland</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#c.-equalization"><span class="toc-text">C. Equalization</span></a></li></ol>
		</aside>
	</div>
	<div class="ui post container">
		<div class="ui text container">
			<span id="postcon">
				<span id="postinfo">
					<div class="ui post title serif">
						<div id="fortitle" data-content="杂题选谈">
							杂题选谈
						</div>
						<div class="ui title background">
						</div>
					</div>
					<span id="date">
						<i class="fas fa-calendar-alt" style="margin-right: 4px;"></i>
						2025-11-18
					</span>
				</span>
			</span>
			<div id="posttags" class="dotted border">
				
					<span style="color: #888;">暂无标签</span>
				
			</div>
			<!-- 本来用的是 fromNow 然后字符串判断，没想到可以直接调用 moment() -->
			
			<div id="content">
				<p>古人总说：『日出而作，日落而息』。既然如此，在冬天的阴天就应该安眠一个下午。</p>
<span id="more"></span>
<p>但这样总有被误认为冬眠动物的风险。实际上是全年无休地努力摸鱼着！</p>
<hr />
<h2 id="c.-meat">C. meat</h2>
<p><a target="_blank" rel="noopener" href="https://www.becoder.com.cn/contest/6752/problem/3" class="uri">https://www.becoder.com.cn/contest/6752/problem/3</a></p>
<blockquote>
<p>给定一个 <span class="math inline">\(n\)</span> 个点 <span class="math inline">\(m\)</span> 条边的简单无向图，点有点权，问图中所有四元环的权值和，对 <span class="math inline">\(10^9+7\)</span> 取模。</p>
<p><span class="math inline">\(n,m\le 10^5\)</span>。</p>
</blockquote>
<ul>
<li><p>容易想到 meet in middle 的做法：把四元环 <span class="math inline">\((1,2,3,4)\)</span> 拆解为 <span class="math inline">\(1-2-3\)</span> 和 <span class="math inline">\(1-4-3\)</span> 两个部分，从 <span class="math inline">\(1\)</span> 出发，找到所有和 <span class="math inline">\(1\)</span> 的距离为 <span class="math inline">\(2\)</span> 的点 <span class="math inline">\(3&#39;\)</span>，在 <span class="math inline">\(3\)</span> 处完成统计。</p></li>
<li><p>做这么一件事：在每次『从 <span class="math inline">\(u\)</span> 出发，找到所有和 <span class="math inline">\(u\)</span> 的距离为 <span class="math inline">\(2\)</span> 的点』之后，从图中删去 <span class="math inline">\(u\)</span>。容易发现删点不会影响正确性。</p>
<p>注意这里要用 BFS 而非 DFS 保证复杂度。</p></li>
<li><p>钦定按点的度数从大到小做这个过程，则复杂度为 <span class="math inline">\(O(m\sqrt m)\)</span>。证明参考三元环，考虑根号分治：</p>
<ul>
<li><p>当点 <span class="math inline">\(u\)</span> 的度数 <span class="math inline">\(deg_u&gt;\sqrt m\)</span> 时，由于 <span class="math inline">\(\sum deg=2m\)</span>，这样的点有 <span class="math inline">\(O(\sqrt m)\)</span> 个；暴力 BFS 两步时，最劣复杂度为 <span class="math inline">\(O(m)\)</span>。故该种情况下复杂度为 <span class="math inline">\(O(m\sqrt m)\)</span>。</p></li>
<li><p>否则，<span class="math inline">\(deg_u\le \sqrt m\)</span> 时，由于度数更大的都被删除了，<span class="math inline">\(u\)</span> 能 BFS 到的点度数一定比 <span class="math inline">\(u\)</span> 更小。</p>
<p><strong>注意区分这一步和三元环重定向的区别：此时仍然允许在第 2 个点 <span class="math inline">\(\to\)</span> 第 3 个点时，由小度数走向大度数，否则无法完全统计。</strong>三元环能重定向的原因是，不管如何重定向，三元环中总能找到一条 <span class="math inline">\(a\to b\to c\)</span> 的有向路径。</p>
<p>故此时两步 BFS 的复杂度上界为 <span class="math inline">\(O({deg_u}^2)\)</span>。</p>
<p>考虑整体复杂度上界，即找到一种对 <span class="math inline">\(2m\)</span> 的划分方式，使得每一个元素不超过 <span class="math inline">\(\sqrt m\)</span>，且最大化 <span class="math inline">\(\sum {deg_u}^2\)</span>。最劣情况显然是全部取 <span class="math inline">\(\sqrt m\)</span>，此时复杂度为 <span class="math inline">\(O(m\sqrt m)\)</span>。</p></li>
</ul>
<p>综上，整体复杂度为 <span class="math inline">\(O(m\sqrt m)\)</span>，而且非常不满。</p></li>
<li><details>
<p><summary>By the way, 无向图三元环计数？</summary></p>
<p>按照大度数 <span class="math inline">\(\to\)</span> 小度数对边重定向。由于三元环需要的信息更少，只需要 check『走两步能走到的点』和『走一步能走到的点』的交集，但仍需要两步 BFS。</p>
<p>根号分治证明复杂度，证明过程几乎一致。不赘述。</p>
</details></li>
</ul>
<details>
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;
const int mod = 1e9 + 7;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
    std::freopen(&quot;meat.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;meat.out&quot;, &quot;w&quot;, stdout);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, m;
    std::cin &gt;&gt; n &gt;&gt; m;
    std::vector&lt;long long&gt; a(n + 1);
    for (int i = 1; i &lt;= n; ++i)
        std::cin &gt;&gt; a[i];
    std::vector&lt;int&gt; deg(n + 1), id(n);
    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);
    for (int x, y; m--; ) &#123;
        std::cin &gt;&gt; x &gt;&gt; y;
        ++deg[x], ++deg[y];
        g[x].push_back(y), g[y].push_back(x);
    &#125;
    std::iota(id.begin(), id.end(), 1);
    std::sort(id.begin(), id.end(), [&amp;](int i, int j) &#123; return deg[i] &gt; deg[j]; &#125;);
    std::vector&lt;long long&gt; s(n + 1);
    std::vector&lt;int&gt; tag(n + 1), cnt(n + 1);
    auto res = 0ll;
    for (auto i : id) &#123;
        std::vector&lt;int&gt; pos;
        tag[i] = 1;
        for (auto j : g[i]) 
            if (!tag[j])
                for (auto k : g[j])
                    if (!tag[k]) &#123;
                        pos.push_back(k);
                        ++cnt[k], (s[k] += a[j]) %= mod;
                    &#125;
        for (auto j : pos)
            if (cnt[j]) &#123;
                res += s[j] * (cnt[j] - 1) % mod;
                res += (a[i] + a[j]) % mod * (cnt[j] * (cnt[j] - 1) / 2 % mod) % mod;
                cnt[j] = s[j] = 0;
            &#125;
        res %= mod;
    &#125;
    std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;</code></pre>
</details>
<hr />
<h2 id="b.-port">B. port</h2>
<p><a target="_blank" rel="noopener" href="https://www.becoder.com.cn/contest/6767/problem/2" class="uri">https://www.becoder.com.cn/contest/6767/problem/2</a></p>
<blockquote>
<p>给定 <span class="math inline">\(n\times n\)</span> 的棋盘，初始放置了 <span class="math inline">\(k\)</span> 个棋子 <span class="math inline">\((x_i, y_i)\)</span>。现在可以额外放置若干棋子，问有多少种方案满足：</p>
<ul>
<li>在最终的棋盘上，任意 <span class="math inline">\(m\times m\)</span> 的矩形中，<strong>恰有</strong>一个棋子。</li>
</ul>
<p>对 <span class="math inline">\(998244353\)</span> 取模。</p>
<p>多测，<span class="math inline">\(T\le 2\times 10^5,m\le n\le 10^6,k\le \min(n^2,2\times 10^5),\sum k\le 2\times 10^5\)</span>。</p>
</blockquote>
<ul>
<li><p>需要高强度手玩，然后概括出以下事实：</p>
<ul>
<li>两个棋子不冲突的充要条件：行差为 <span class="math inline">\(m\)</span> 的倍数或列差为 <span class="math inline">\(b\)</span> 的倍数。</li>
<li>初始棋子不冲突的充要条件：任意两个棋子满足上一条。</li>
<li>合法局面的充要条件：每一行的棋子的列差均为 <span class="math inline">\(m\)</span>，或每一列的棋子行差均为 <span class="math inline">\(m\)</span>。</li>
</ul>
<p>这样，只有第一行 / 列的选取是相对自由的。由此可以得到 <span class="math inline">\(k=0\)</span> 时的答案：</p>
<p><span class="math display">\[
2\times(m^{\left\lfloor\frac{n}{m}\right\rfloor}\times(m-n\bmod m)+m^{\left\lfloor\frac{n}{m}\right\rfloor+1}\times(n\bmod m))-m^2
\]</span></p></li>
<li><p>对于 <span class="math inline">\(k\ne 0\)</span> 的情况，统计两种填数方式一路上可以塞数的位置，顺便判定合法性即可。</p></li>
</ul>
<details>
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;
const int mod = 998244353;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
    std::freopen(&quot;port.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;port.out&quot;, &quot;w&quot;, stdout);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int T;
    auto qkp = [&amp;](long long first, int second) &#123;
        auto res = 1ll;
        for (; second; (first *= first) %= mod, second &gt;&gt;= 1)
            if (second &amp; 1)
                (res *= first) %= mod;
        return res;
    &#125;;
    for (std::cin &gt;&gt; T; T--; ) &#123;
        int k;
        long long n, m;
        std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;
        std::vector&lt;std::pair&lt;int, int&gt; &gt; a(k + 1);
        for (int i = 1; i &lt;= k; ++i)
            std::cin &gt;&gt; a[i].first &gt;&gt; a[i].second;
        auto res = 0ll;
        if (m == 1) &#123;
            std::cout &lt;&lt; 1 &lt;&lt; &#39;\n&#39;;
            continue;
        &#125;
        if (k == 0) &#123;
            auto res = qkp(m, n / m) * (m + mod - n % m) % mod + qkp(m, n / m + 1) * (n % m) % mod;
            res = 2 * res % mod + mod - m * m % mod;
            std::cout &lt;&lt; res % mod &lt;&lt; &#39;\n&#39;;
            continue;
        &#125;
        std::sort(a.begin() + 1, a.end());
        int la = 0, now = 0;
        bool flag1 = true, flag2 = true;
        for (int i = 1, j = 1; i &lt;= k; i = j + 1) &#123;
            now = now + std::max(0ll, (a[i].first - la - 1) / m);
            if (la &amp;&amp; (a[i].first - la) % m != 0)
                flag1 = false;
            la = a[i].first;
            for (j = i; j &lt;= k &amp;&amp; a[i].first == a[j].first; ++j);
            --j;
            for (int k = i + 1; k &lt;= j; k++)
                if ((a[k].second - a[k - 1].second) % m != 0)
                    flag1 = false;
            i = j;
        &#125;
        now += (n - la) / m;
        if (flag1)
            (res += qkp(m, now)) %= mod;
        la = 0, now = 0;
        std::sort(a.begin() + 1, a.end(), [&amp;](auto &amp;x, auto &amp;y) &#123; return x.second == y.second ? x.first &lt; y.first : x.second &lt; y.second; &#125;);
        for (int i = 1, j = 1; i &lt;= k; i = j + 1) &#123;
            now = now + std::max(0ll, (a[i].second - la - 1) / m);
            if (la &amp;&amp; (a[i].second - la) % m != 0)
                flag2 = false;
            la = a[i].second;
            for (j = i; j &lt;= k &amp;&amp; a[i].second == a[j].second; ++j);
            --j;
            for (int k = i + 1; k &lt;= j; k++)
                if ((a[k].first - a[k - 1].first) % m != 0)
                    flag2 = false;
            i = j;
        &#125;
        now += (n - la) / m;
        if (flag2)
            (res += qkp(m, now)) %= mod;
        if (flag1 &amp;&amp; flag2)
            (res += mod - 1) %= mod;
        std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
    &#125;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;</code></pre>
</details>
<hr />
<h2 id="c.-west">C. west</h2>
<p><a target="_blank" rel="noopener" href="https://www.becoder.com.cn/contest/6767/problem/3" class="uri">https://www.becoder.com.cn/contest/6767/problem/3</a></p>
<blockquote>
<p>给定长度为 <span class="math inline">\(n\)</span> 的两个栈 A, B，两个栈内的元素分别是 <span class="math inline">\(n\)</span> 的一个排列。通过执行以下操作构造一个序列：</p>
<ul>
<li>（当 A 剩余元素不为 1 时）将 B 的栈顶加入序列，并弹出 A 的栈顶。</li>
<li>（当 B 剩余元素不为 1 时）将 A 的栈顶加入序列，并弹出 B 的栈顶。</li>
</ul>
<p>容易发现最后的序列长总为 <span class="math inline">\(2n-2\)</span>。问可以构造出多少种序列。对 <span class="math inline">\(998244353\)</span> 取模。</p>
<p><span class="math inline">\(n\le 5000\)</span>。</p>
</blockquote>
<p>机房里只有 1 个神仙、1 个人切了 T3。总算是得瑟上一回了！</p>
<ul>
<li><p>发现：如果存在两种操作方式，使得它们结果序列的 <span class="math inline">\(1\sim i\)</span> 项相同，那么可以转化为，它们的 <span class="math inline">\(1\sim i-1\)</span> 相同，且第 <span class="math inline">\(i\)</span> 项相同。</p></li>
<li><p>设 <span class="math inline">\(f_{i,j,0/1/2}\)</span> 表示结果序列的第 <span class="math inline">\(i\)</span> 项为 <span class="math inline">\(j\)</span>，这个 <span class="math inline">\(j\)</span> 由 A 贡献 / 由 B 贡献 / AB 都可以贡献的方案数。</p>
<p>发现用 <span class="math inline">\(i,j,0/1/2\)</span> 三个信息可以唯一确定当前 A B 两个栈的状态（利用排列这个条件），然后就可以填表转移了。</p></li>
<li><p>需要注意的地方：<span class="math inline">\(f_{i,j,2}\)</span> 用 A, B 反推可能得到不一样的结果（设为 <span class="math inline">\((A_1,B_1)/(A_2,B_2)\)</span>），此时两种结果都有可能分岔 / 合并，共 <span class="math inline">\(2\times 2=4\)</span> 种组合方式。</p>
<p>利用 <span class="math inline">\(A_1\ne A_2\land B_1\ne B_2\)</span> 这一点可以发现，不会出现用 <span class="math inline">\(A_1,A_2,B_1,B_2\)</span> 中的超过两个转移得到同样结果的情况。</p>
<p>反过来，可以像这里一样设 <span class="math inline">\(f_{*,*,2}\)</span> 是因为我们默认了，如果一个状态可以通过多种转移路径得到，那么一定是恰好两种。</p>
<p>虽然比官方做法简单 10086 倍，但似乎过于凑巧了。</p></li>
<li><p>最后的答案为 <span class="math inline">\(\sum\limits_i f_{2n-2,i,*}\)</span>。</p></li>
</ul>
<details>
<p>一定要注意用 A, B 转移对应的条件是 B, A。</p>
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;
const int mod = 998244353;
int main() &#123;
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
    std::freopen(&quot;west.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;west.out&quot;, &quot;w&quot;, stdout);
    auto stime = std::chrono::steady_clock::now();
    int n;
    std::cin &gt;&gt; n;
    std::vector&lt;int&gt; a(n + 1), b(n + 1), pa(n + 1), pb(n + 1);
    for (int i = 1; i &lt;= n; ++i)
        std::cin &gt;&gt; a[i], pa[a[i]] = i;
    for (int i = 1; i &lt;= n; ++i)
        std::cin &gt;&gt; b[i], pb[b[i]] = i;
    using arr = std::vector&lt;long long&gt;;
    using brr = std::vector&lt;arr&gt;;
    using crr = std::vector&lt;brr&gt;;
    crr f(2, brr(n + 1, arr(3)));
    if (a[1] == b[1])
        f[1][a[1]][2] = 1ll;
    else
        f[1][a[1]][0] = f[1][b[1]][1] = 1ll;
    for (int i = 1, k = 1; i &lt; 2 * n - 2; ++i, k ^= 1) &#123;
        for (int j = 1; j &lt;= n; ++j)
            f[k ^ 1][j][0] = f[k ^ 1][j][1] = f[k ^ 1][j][2] = 0ll;
        for (int j = 1; j &lt;= n; ++j) &#123;
            if (f[k][j][0]) &#123;
                auto v = f[k][j][0];
                int A = pa[j], B = i - (A - 1) + 1;
                if (A != n &amp;&amp; B != n &amp;&amp; a[A] == b[B])
                    f[k ^ 1][a[A]][2] += v;
                else &#123;
                    if (B != n)
                        f[k ^ 1][a[A]][0] += v;
                    if (A != n)
                        f[k ^ 1][b[B]][1] += v;
                &#125;
            &#125;
            if (f[k][j][1]) &#123;
                auto v = f[k][j][1];
                int B = pb[j], A = i - (B - 1) + 1;
                if (A != n &amp;&amp; B != n &amp;&amp; a[A] == b[B])
                    f[k ^ 1][a[A]][2] += v;
                else &#123;
                    if (B != n)
                        f[k ^ 1][a[A]][0] += v;
                    if (A != n)
                        f[k ^ 1][b[B]][1] += v;
                &#125;
            &#125;
            if (f[k][j][2]) &#123;
                int A1 = pa[j], B1 = i - (A1 - 1) + 1;
                int B2 = pb[j], A2 = i - (B2 - 1) + 1;
                auto v = f[k][j][2];
                if (A1 == A2) &#123;
                    if (A1 != n &amp;&amp; B1 != n &amp;&amp; a[A1] == b[B1])
                        f[k ^ 1][a[A1]][2] += v;
                    else &#123;
                        if (B1 != n)
                            f[k ^ 1][a[A1]][0] += v;
                        if (A1 != n)
                            f[k ^ 1][b[B1]][1] += v;
                    &#125;
                &#125;
                else &#123;
                    int fA1 = 0, fB1 = 0, fA2 = 0, fB2 = 0;
                    if (A1 != n &amp;&amp; B1 != n &amp;&amp; a[A1] == b[B1]) &#123;
                        f[k ^ 1][a[A1]][2] += v;
                        fA1 = fB1 = 1;
                    &#125;
                    if (A1 != n &amp;&amp; B2 != n &amp;&amp; a[A2] == b[B1]) &#123;
                        f[k ^ 1][a[A2]][2] += v;
                        fA2 = fB1 = 1;
                    &#125;
                    if (A2 != n &amp;&amp; B1 != n &amp;&amp; a[A1] == b[B2]) &#123;
                        f[k ^ 1][a[A1]][2] += v;
                        fA1 = fB2 = 1;
                    &#125;
                    if (A2 != n &amp;&amp; B2 != n &amp;&amp; a[A2] == b[B2]) &#123;
                        f[k ^ 1][a[A2]][2] += v;
                        fA2 = fB2 = 1;
                    &#125;
                    if (!fA1 &amp;&amp; B1 != n)
                        f[k ^ 1][a[A1]][0] += v;
                    if (!fB1 &amp;&amp; A1 != n)
                        f[k ^ 1][b[B1]][1] += v;
                    if (!fA2 &amp;&amp; B2 != n)
                        f[k ^ 1][a[A2]][0] += v;
                    if (!fB2 &amp;&amp; A2 != n)
                        f[k ^ 1][b[B2]][1] += v;
                &#125;
            &#125;
        &#125;
        for (int j = 1; j &lt;= n; ++j) &#123;
            f[k ^ 1][j][0] %= mod;
            f[k ^ 1][j][1] %= mod;
            f[k ^ 1][j][2] %= mod;
        &#125;
    &#125;
    auto res = 0ll;
    for (int j = 1; j &lt;= n; ++j)
        res += (f[0][j][0] + f[0][j][1] + f[0][j][2]) % mod;
    std::cout &lt;&lt; res % mod &lt;&lt; &#39;\n&#39;;
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt;(std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
    return 0;
&#125;</code></pre>
</details>
<hr />
<h2 id="d.-egypt">D. egypt</h2>
<p><a target="_blank" rel="noopener" href="https://www.becoder.com.cn/contest/6767/problem/4" class="uri">https://www.becoder.com.cn/contest/6767/problem/4</a></p>
<blockquote>
<p>给定字符串 <span class="math inline">\(s_{1\cdots n}，\)</span>序列 <span class="math inline">\(h_{1\cdots n}\)</span>、<span class="math inline">\(d_{1\cdots n}\)</span> 和 <span class="math inline">\(w_{1\cdots n}\)</span> 和参数 <span class="math inline">\(k\)</span>。</p>
<p>定义 <span class="math inline">\(pre_k\)</span> 为 <span class="math inline">\(s\)</span> 长度为 <span class="math inline">\(k\)</span> 的前缀。</p>
<p>定义 <span class="math inline">\(g(s_1, s_2)\)</span> 为所有满足下列条件的字符串 <span class="math inline">\(t\)</span> 组成的集合：</p>
<ul>
<li><span class="math inline">\(t\)</span> 是 <span class="math inline">\(s_1,s_2\)</span> 的公共后缀，且 <span class="math inline">\(t\)</span> 是 <span class="math inline">\(s\)</span> 的前缀。</li>
</ul>
<p>求：</p>
<p><span class="math display">\[
\sum_{i\le j} [|h_i-h_j|\le k]\cdot (d_i+d_j)\cdot \max_{t\in g(pre_i, pre_j)} \{w_{|t|}\}
\]</span></p>
<p><span class="math inline">\(n\le 2\times 10^5,h_i\le n,d_i,w_i\le 3000\)</span>。2s。</p>
</blockquote>
<ul>
<li><p>发现最后一坨是一个 fail 树上的东西，故建出 fail 树森林，并求出每个点处的前缀最大值。</p></li>
<li><p>然后发现是一个 dsu on tree，以 <span class="math inline">\(h\)</span> 为下标，树状数组统计 <span class="math inline">\(d\)</span> 的和即可。</p></li>
</ul>
<details>
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;
int main() &#123;
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
    std::freopen(&quot;beach.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;beach.out&quot;, &quot;w&quot;, stdout);
    auto stime = std::chrono::steady_clock::now();
    int n, k;
    std::string s;
    std::cin &gt;&gt; n &gt;&gt; k &gt;&gt; s, s = &quot;#&quot; + s;
    std::vector&lt;long long&gt; w(n + 1);
    std::vector&lt;int&gt; h(n + 1), d(n + 1), nex(n + 1);
    for (int i = 1; i &lt;= n; ++i)
        std::cin &gt;&gt; h[i];
    for (int i = 1; i &lt;= n; ++i)
        std::cin &gt;&gt; d[i];
    for (int i = 1; i &lt;= n; ++i)
        std::cin &gt;&gt; w[i];
    std::vector&lt;int&gt; deg(n + 1), rt;
    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);
    for (int i = 2, j = 0; i &lt;= n; ++i) &#123;
        for (; j &amp;&amp; s[i] != s[j + 1]; j = nex[j]);
        if (s[i] == s[j + 1])
            nex[i] = ++j;
        if (nex[i])
            g[nex[i]].push_back(i), ++deg[i];
    &#125;
    for (int i = 1; i &lt;= n; ++i)
        if (!deg[i])
            rt.push_back(i);
    std::vector&lt;int&gt; siz(n + 1), son(n + 1);
    std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;
        siz[x] = 1;
        for (auto i : g[x]) &#123;
            w[i] = std::max(w[i], w[x]);
            DFS(i);
            siz[x] += siz[i];
            if (siz[i] &gt; siz[son[x]])
                son[x] = i;
        &#125;
        return;
    &#125;;
    for (int i : rt)
        DFS(i);
    auto res = 0ll;
    std::vector&lt;int&gt; bit1(n + 1), bit2(n + 1);
    auto lowbit = [&amp;](int x) &#123; return x &amp; -x; &#125;;
    auto add = [&amp;](int x, int v, int op) &#123;
        for (; x &lt;= n; x += lowbit(x))
            bit1[x] += op, bit2[x] += v;
        return;
    &#125;;
    auto ask = [&amp;](int x) &#123;
        int res1 = 0, res2 = 0;
        for (; x; x -= lowbit(x))
            res1 += bit1[x], res2 += bit2[x];
        return std::make_pair(res1, res2);
    &#125;;
    std::vector&lt;int&gt; dfn(n + 1), rfn(n + 1), tab(n + 1);
    DFS = [&amp;](int x) &#123;
        static int now = 0;
        dfn[x] = rfn[x] = ++now, tab[now] = x;
        if (!son[x]) &#123;
            add(h[x], d[x], 1);
            return;
        &#125;
        for (auto i : g[x])
            if (i != son[x]) &#123;
                DFS(i);
                for (int j = dfn[i]; j &lt;= rfn[i]; ++j)
                    add(h[tab[j]], -d[tab[j]], -1);
            &#125;
        DFS(son[x]);
        auto [c2, s2] = ask(std::min(n, h[x] + k));
        auto [c1, s1] = ask(std::max(0, h[x] - k - 1));
        res += w[x] * ((c2 - c1) * d[x] + (s2 - s1));
        add(h[x], d[x], 1);
        for (auto i : g[x])
            if (i != son[x]) &#123;
                for (int j = dfn[i], v; j &lt;= rfn[i]; ++j) &#123;
                    v = tab[j];
                    auto [c2, s2] = ask(std::min(n, h[v] + k));
                    auto [c1, s1] = ask(std::max(0, h[v] - k - 1));
                    res += w[x] * ((c2 - c1) * d[v] + (s2 - s1));
                &#125;
                for (int j = dfn[i]; j &lt;= rfn[i]; ++j)
                    add(h[tab[j]], d[tab[j]], 1);
            &#125;
        rfn[x] = now;
        return;
    &#125;;
    for (auto i : rt) &#123;
        DFS(i);
        for (int j = dfn[i]; j &lt;= rfn[i]; ++j)
            add(h[tab[j]], -d[tab[j]], -1);
    &#125;
    std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt;(std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
    return 0;
&#125;</code></pre>
</details>
<hr />
<h2 id="a.-千万道伤痕wound">A. 千万道伤痕（wound）</h2>
<p><a target="_blank" rel="noopener" href="https://www.becoder.com.cn/contest/6770/problem/1" class="uri">https://www.becoder.com.cn/contest/6770/problem/1</a></p>
<blockquote>
<p>给定大小为 <span class="math inline">\(n\)</span> 的树，根为 <span class="math inline">\(1\)</span>。每个点 <span class="math inline">\(u\)</span> 有两个权值 <span class="math inline">\(a_u,b_u\)</span>。你可以执行任意次下列操作：</p>
<ul>
<li>选择有连边的两个点 <span class="math inline">\(u,v\)</span>，其中 <span class="math inline">\(u\)</span> 为父亲。交换 <span class="math inline">\(a_u,a_v\)</span> 的值，随后 <span class="math inline">\(a_u\gets a_u+c,a_v\gets a_v-c\)</span>，<span class="math inline">\(c\)</span> 为给定常数。</li>
</ul>
<p>你需要输出经过任意次操作后，<span class="math inline">\(\sum\limits_u |a_u-b_u|\)</span> 可能达到的最小值。</p>
<p><span class="math inline">\(n\le 2\times 10^5,V=[-10^{10},10^{10}]\)</span>。</p>
</blockquote>
<ul>
<li><p>这类放在 A 题的无限操作类题目可能的手段不多，要么猜字面的最优答案能通过某种方法取到，要么尝试构造能取到的最优解。</p></li>
<li><p>发现可以进行重分配，即把所有 <span class="math inline">\(a,b\)</span> 全部挪到 <span class="math inline">\(1\)</span> 上，然后分别排序，重分配 <span class="math inline">\(a,b\)</span>。</p></li>
</ul>
<details>
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;
int main() &#123;
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
    auto stime = std::chrono::steady_clock::now();
    std::freopen(&quot;wound.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;wound.out&quot;, &quot;w&quot;, stdout);
    int n, c;
    std::cin &gt;&gt; n &gt;&gt; c;
    std::vector&lt;long long&gt; a(n + 1), b(n + 1);
    for (int i = 1; i &lt;= n; ++i)
        std::cin &gt;&gt; a[i];
    for (int j = 1; j &lt;= n; ++j)
        std::cin &gt;&gt; b[j];
    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);
    for (int i = 2, x; i &lt;= n; ++i) &#123;
        std::cin &gt;&gt; x;
        g[x].push_back(i);
    &#125;
    std::vector&lt;long long&gt; dep(n + 1);
    std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;
        for (auto i : g[x]) &#123;
            dep[i] = dep[x] + 1;
            DFS(i);
        &#125;
        return;
    &#125;;
    DFS(1);
    for (int i = 1; i &lt;= n; ++i)
        a[i] += c * dep[i], b[i] += c * dep[i];
    std::sort(a.begin(), a.end());
    std::sort(b.begin(), b.end());
    auto res = 0ll;
    for (int i = 1; i &lt;= n; ++i)
        res += std::abs(a[i] - b[i]);
    std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt;(std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
    return 0;
&#125;</code></pre>
</details>
<hr />
<h2 id="b.-猫儿小mex-cf1870g-mexanization">B. 猫儿小（mex）/ CF1870G MEXanization</h2>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/solution/CF1870G" class="uri">https://www.luogu.com.cn/problem/solution/CF1870G</a></p>
<p>简单在哪儿？*3300 实至名归。</p>
<ul>
<li><p>对于 <span class="math inline">\(x\)</span> 是最终 mex 的情况，考虑对 <span class="math inline">\(x\)</span> 的 check：将 <span class="math inline">\([x+1,\inf]\)</span> 的数通过一次 mex 置为 0。</p>
<p>从 <span class="math inline">\(p=x-1\)</span> 开始向前遍历。定义 <span class="math inline">\(need\)</span> 表示对于当前的 <span class="math inline">\(p\)</span>，额外需要 <span class="math inline">\([0,p-1]\)</span> 的个数，初值为 <span class="math inline">\(1\)</span>。对于一次移动：</p>
<ul>
<li>若 <span class="math inline">\(cnt_p\ge need\)</span>，则可以将多余的置 0，此时 <span class="math inline">\(cnt_0\gets cnt_p-need\)</span>。</li>
<li>若 <span class="math inline">\(cnt_p&lt;need\)</span>，则需要前面凑 <span class="math inline">\(need-cnt_p\)</span> 个 <span class="math inline">\(p\)</span> 出来，即 <span class="math inline">\(need\gets need + cnt_p\)</span>。</li>
</ul>
<p>此时就有了一个 <span class="math inline">\(O(n^2)\)</span> 动态增加当前答案的做法。</p></li>
<li><p>注意到 <span class="math inline">\(cnt_p&lt;need\)</span> 发生的次数很少，具体地，每次触发这个事件的 <span class="math inline">\(p\)</span> 不同，且额外需求 <span class="math inline">\(p\)</span> 个元素。总共 <span class="math inline">\(n\)</span> 个元素，最多支持发生 <span class="math inline">\(\sqrt n\)</span> 次 <span class="math inline">\(cnt_p&lt;need\)</span> 事件。</p>
<p>此时可以通过 <span class="math inline">\(\sqrt n\)</span> 次线段树上二分得到所有 <span class="math inline">\(cnt_p&lt;need\)</span> 事件；对于事件之间的 <span class="math inline">\(cnt_p\ge need\)</span> 的情况，平凡地维护即可。这样复杂度就降低到 <span class="math inline">\(O(n\sqrt n\log n)\)</span>。<del>如降</del></p></li>
<li><p>做一个很神奇的事情来把 <span class="math inline">\(\sqrt n\)</span> 次 <span class="math inline">\([1,x-1]\)</span> 次线段树上二分打包在一起（没办法解释怎么想到的，不然我就去场切 *3300 了）：</p>
<ul>
<li><p>假设现在位于线段树上的点 <span class="math inline">\((p, l, r)\)</span>，里面的 <span class="math inline">\(\sum cnt_{l\cdots r}\)</span> 记为 <span class="math inline">\(u_p\)</span>，<span class="math inline">\(\min\{cnt_{l\cdots r}\}\)</span> 记为 <span class="math inline">\(mn_p\)</span>。</p></li>
<li><p>若 <span class="math inline">\([l, r]\)</span> 被询问区间完整包含：</p>
<ul>
<li>若 <span class="math inline">\(mn_p\ge need\)</span>，更新 <span class="math inline">\(c0\)</span>，不用进行下一步递归。</li>
<li>elif <span class="math inline">\(l=r\)</span>，直接处理，更新 <span class="math inline">\(need\)</span> 与 <span class="math inline">\(c0\)</span>。</li>
<li>否则，继续递归。</li>
</ul></li>
<li><p>按先右再左的顺序递归。</p></li>
</ul>
<details>
<p><summary>证明：在题目限制下，单次处理是 <span class="math inline">\(O(\sqrt n)\)</span> 的</summary></p>
<figure>
<img src="image.png" alt="from Solution-CF1870G by yllcm" /><figcaption>from <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/article/qr6ket0l">Solution-CF1870G by yllcm</a></figcaption>
</figure>
</details></li>
</ul>
<details>
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;
const int maxn = 2e5 + 5;
const int inf = 0x3f3f3f3f;
struct &#123; int l, r, u, mn; &#125; t[maxn &lt;&lt; 2];
#define lt (p &lt;&lt; 1)
#define rt (lt | 1)
int need, c0, n;
void bld(int p, int l, int r) &#123;
    t[p].mn = t[p].u = 0;
    t[p].l = l, t[p].r = r;
    if (l == r)
        return;
    int mid = (l + r) &gt;&gt; 1;
    bld(lt, l, mid), bld(rt, mid + 1, r);
    return;
&#125;
void add(int p, int x) &#123;
    ++t[p].u;
    if (t[p].l == t[p].r) &#123;
        ++t[p].mn;
        return;
    &#125;
    int mid = (t[p].l + t[p].r) &gt;&gt; 1;
    if (x &lt;= mid)
        add(lt, x);
    else
        add(rt, x);
    t[p].mn = std::min(t[lt].mn, t[rt].mn);
    return;
&#125;
bool ask(int p, int l, int r) &#123;
    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r) &#123;
        if (need &lt;= t[p].mn) &#123;
            c0 += t[p].u - need * (t[p].r - t[p].l + 1);
            return false;
        &#125;
        else if (t[p].l == t[p].r) &#123;
            if (t[p].u &gt;= need)
                c0 += t[p].u - need;
            else if (2 * need - t[p].u &gt; n)
                return true;
            else
                need += need - t[p].u;
            return false;
        &#125;
    &#125;
    int mid = (t[p].l + t[p].r) &gt;&gt; 1;
    if (r &gt; mid &amp;&amp; ask(rt, l, r))
        return true;
    return ask(lt, l, r);
&#125;
#undef lt
#undef rt
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int T;
    for (std::cin &gt;&gt; T; T--; ) &#123;
        std::cin &gt;&gt; n;
        std::vector&lt;int&gt; a(n + 1), res(n + 1), bit(n + 2);
        auto lowbit = [&amp;](int x) &#123; return x &amp; -x; &#125;;
        auto add = [&amp;](int x, int v) &#123;
            for (++x; x &lt;= n + 1; x += lowbit(x))
                bit[x] += v;
            return;
        &#125;;
        auto ask = [&amp;](int x) &#123;
            int res = 0;
            for (++x; x; x -= lowbit(x))
                res += bit[x];
            return res;
        &#125;;
        bld(1, 1, n);
        int now = 1;
        for (int i = 1; i &lt;= n; ++i) &#123;
            std::cin &gt;&gt; a[i];
            if (i == 1)
                res[i] = a[i];
            if (a[i] &gt; n)
                a[i] = 0;
            add(a[i], 1);
            if (a[i])
                ::add(1, a[i]);
            for (++now; now &lt;= i; ++now) &#123;
                need = 1, c0 = i - ask(now - 1) + ask(0);
                if (::ask(1, 1, now - 1) || need &gt; c0)
                    break;
            &#125;
            res[i] = std::max(res[i], --now);
        &#125;
        for (int i = 1; i &lt;= n; ++i)
            std::cout &lt;&lt; res[i] &lt;&lt; &#39; &#39;;
        std::cout &lt;&lt; &#39;\n&#39;;
    &#125;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;</code></pre>
</details>
<hr />
<h2 id="c.-星之卡比mismatch">C. 星之卡比（mismatch）</h2>
<p><a target="_blank" rel="noopener" href="https://www.becoder.com.cn/contest/6770/problem/3" class="uri">https://www.becoder.com.cn/contest/6770/problem/3</a></p>
<blockquote>
<p>给定 <span class="math inline">\(n\)</span> 个点和 <span class="math inline">\(m\)</span> 条路线（一个点在一条路线中最多出现一次），判断以下命题是否成立：</p>
<ul>
<li><p>对于任意两条路线 A, B 和任意 <span class="math inline">\(1\le x,y\le n\)</span>，以下至少一个命题成立：</p>
<ul>
<li>两条路线不同时包含 <span class="math inline">\(x,y\)</span>，或在任意一条路线中 <span class="math inline">\(x\)</span> 晚于 <span class="math inline">\(y\)</span> 出现。</li>
<li>两条路线中，<span class="math inline">\(x\)</span> 开头、<span class="math inline">\(y\)</span> 结尾的子段完全相同。</li>
</ul></li>
</ul>
<p>记第 <span class="math inline">\(i\)</span> 条路线长为 <span class="math inline">\(k_i\)</span>，则 <span class="math inline">\(n,m,\sum k\le 3\times 10^5\)</span>。</p>
</blockquote>
<ul>
<li><p>发现当作 log 题来做缺乏好的性质，因为图论色彩太重了导致不太好序列化。尝试了一下 DS 优化建图发现也没什么好的建模方向。故顶着 3e5 的数据范围考虑根号做法。</p></li>
<li><p>发现存在 <span class="math inline">\(O(k^2)\)</span> 的做法，即枚举每个路径内存在的点对并保存其间的哈希值，存起来判断是否有冲突。</p>
<p>同时容易发现 <span class="math inline">\(O(m^2)\)</span> 的做法，即枚举每一对路径，检查是否冲突：找到两条路径同时包含的所有点，（由于同时包含拥有比较好的性质），取最靠两侧的这样的点，判断中间的哈希值是否相同即可。</p></li>
<li><p>发现这个和 <a href="#c-meat">meat</a> 的根号分治几乎是一致的，直接取阈值为 <span class="math inline">\(\sqrt m\)</span> 复杂度就是对的。</p></li>
</ul>
<details>
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;
char nec(void) &#123;
    static char buf[1 &lt;&lt; 20], *p = buf, *e = buf;
    if (p == e)
        e = buf + fread(buf, 1, 1 &lt;&lt; 20, stdin), p = buf;
    return *p++;
&#125;
int read(void) &#123;
    auto x = 0ll;
    char t = nec();
    for (; t &lt; &#39;0&#39; || t &gt; &#39;9&#39;; t = nec());
    for (; t &gt;= &#39;0&#39; &amp;&amp; t &lt;= &#39;9&#39;; t = nec())
        x = x * 10 + t - &#39;0&#39;;
    return x;
&#125;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::freopen(&quot;mismatch.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;mismatch.out&quot;, &quot;w&quot;, stdout);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    const int base = 1e5 + 3, mod = 1e9 + 7;
    struct node &#123;
        int x, y, v;
    &#125;;
    std::vector&lt;int&gt; tik(10000019);
    std::vector&lt;long long&gt; pow(300001);
    pow[0] = 1ll;
    for (int i = 1; i &lt;= 300000; ++i)
        pow[i] = (pow[i - 1] * base) % mod;
    std::vector&lt;std::vector&lt;node&gt; &gt; hash(10000019);
    int T = read();
    for (int _ = 1; _ &lt;= T; ++_) &#123;
        int n = read(), m = read();
        int siz = sqrt(m);
        std::vector&lt;std::vector&lt;int&gt; &gt; A, B;
        std::vector&lt;std::vector&lt;int&gt; &gt; hA, hB;
        for (int i = 1, k; i &lt;= m; ++i) &#123;
            k = read();
            std::vector&lt;int&gt; t(k), h(k);
            auto la = 0ll;
            for (int i = 0; i &lt; k; ++i) &#123;
                t[i] = read();
                h[i] = la = (la * base + t[i]) % mod;
            &#125;
            if (k &lt;= siz)
                A.push_back(t), hA.push_back(h);
            else
                B.push_back(t), hB.push_back(h);
        &#125;
        int nA = (int)A.size(), nB = B.size(), now = 0;
        std::vector&lt;int&gt; to(n + 1), at(n + 1);
        auto getid = [&amp;](int x, int y) -&gt; int&amp; &#123;
            int id = ((long long)x * 100003 + y) % 10000019;
            if (tik[id] != _)
                tik[id] = _, hash[id].clear(), hash[id].shrink_to_fit();
            for (auto &amp;&amp;i : hash[id])
                if (i.x == x &amp;&amp; i.y == y)
                    return i.v;
            hash[id].push_back(&#123; x, y, -1 &#125;);
            return hash[id].back().v;
        &#125;;
        auto gethash = [&amp;](std::vector&lt;int&gt; &amp;h, int l, int r) &#123;
            return (h[r] - (l ? (h[l - 1] * pow[r - l + 1]) % mod : 0) + mod) % mod;
        &#125;;
        auto check = [&amp;](std::vector&lt;int&gt; &amp;hA, std::vector&lt;int&gt; &amp;hB, int l1, int r1, int l2, int r2) &#123;
            if (r2 - l2 != r1 - l1)
                return false;
            return gethash(hA, l1, r1) == gethash(hB, l2, r2);
        &#125;;
        for (auto &amp;a : A)
            for (int i = 0; i &lt; (int)a.size() - 1; ++i) &#123;
                long long h = a[i];
                for (int j = i + 1; j &lt; (int)a.size(); ++j) &#123;
                    h = (h * base + a[j]) % mod;
                    auto &amp;hash = getid(a[i], a[j]);
                    if (hash == -1)
                        hash = h;
                    else if (hash != h)
                        goto nosol;
                &#125;
            &#125;
        for (int I = 0; I &lt; nB; ++I) &#123;
            auto &amp;b = B[I];
            ++now;
            for (int i = 0; i &lt; (int)b.size(); ++i)
                to[b[i]] = now, at[b[i]] = i;
            auto isok = [&amp;](auto &amp;a, auto &amp;hA) &#123;
                int l = -1, r = -1;
                bool flag = false;
                for (int i = 0; i &lt; (int)a.size(); ++i)
                    if (to[a[i]] == now) &#123;
                        l = i;
                        break;
                    &#125;
                if (l == -1)
                    return true;
                for (int i = (int)a.size() - 1; ~i; --i)
                    if (to[a[i]] == now &amp;&amp; at[a[i]] &gt; at[a[l]]) &#123;
                        r = i;
                        break;
                    &#125;
                    else if (to[a[i]] == now)
                        flag = true;
                if (r != -1 &amp;&amp; !check(hA, hB[I], l, r, at[a[l]], at[a[r]]))
                    return false;
                if (!flag)
                    return true;
                l = -1, r = -1;
                for (int i = (int)a.size() - 1; ~i; --i)
                    if (to[a[i]] == now) &#123;
                        r = i;
                        break;
                    &#125;
                for (int i = 0; i &lt; (int)a.size(); ++i)
                    if (to[a[i]] == now &amp;&amp; at[a[i]] &lt; at[a[r]]) &#123;
                        l = i;
                        break;
                    &#125;
                if (l != -1 &amp;&amp; !check(hA, hB[I], l, r, at[a[l]], at[a[r]]))
                    return false;
                return true;
            &#125;;
            for (int I1 = 0; I1 &lt; nA; ++I1) 
                if (!isok(A[I1], hA[I1]))
                    goto nosol;
            for (int I1 = 0; I1 &lt; I; ++I1)
                if (!isok(B[I1], hB[I1]))
                    goto nosol;
        &#125;
        puts(&quot;YES&quot;);
        continue;
    nosol:
        puts(&quot;NO&quot;);
    &#125;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;</code></pre>
</details>
<hr />
<h2 id="d.-潮水啊我已归来wave-p14035-paio-2025-gcd">D. 潮水啊，我已归来（wave）/ P14035 [PAIO 2025] GCD</h2>
<p><a target="_blank" rel="noopener" href="https://www.becoder.com.cn/contest/6770/problem/4" class="uri">https://www.becoder.com.cn/contest/6770/problem/4</a> / <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P14035" class="uri">https://www.luogu.com.cn/problem/P14035</a></p>
<blockquote>
<p>给定正整数 <span class="math inline">\(a_{1\cdots n}\)</span> 和常数 <span class="math inline">\(k,V\)</span>。求：</p>
<p><span class="math display">\[
\sum_{x=0}^V\sum_{l=1}^{n-1}\sum_{r=l+1}^n (\gcd^k\{ a_{1\cdots l},a_{r\cdots n}\}\oplus x)\times (a_l+a_r)
\]</span></p>
<p>的值，对 <span class="math inline">\(998244353\)</span> 取模。其中 <span class="math inline">\(\oplus\)</span> 表示按位异或。</p>
<p><span class="math inline">\(n\le 5\times 10^5,1\le a_i\le 2^{30},0\le V\le 10^9,0\le k\le 10^9\)</span>。</p>
</blockquote>
<ul>
<li><p>交换循环顺序，发现需要求解 <span class="math inline">\(\sum_{x=0}^V \gcd^k(pre_*, end_*)\)</span>x$ 的值。</p>
<p>序列中包含某个元素的 gcd 共有 <span class="math inline">\(\log n\)</span> 种。故前缀 gcd、后缀 gcd 各有 <span class="math inline">\(\log n\)</span> 种。</p>
<p>先 <span class="math inline">\(O(\log^2 n)\)</span> 枚举这样的组合，发现 <span class="math inline">\(\gcd^k(a,b)\oplus x\)</span> 的值只与 <span class="math inline">\(\gcd^k(a,b)\)</span> 的低 30 位有关。故维护幂次低 30 位的结果 <span class="math inline">\(L\)</span>（<code>unsigned</code> 即可），计算 <span class="math inline">\((\gcd^k(a,b)-L)\bmod 998244353\)</span> 即为高位答案。</p></li>
<li><p>对于低 30 位，数位 DP 统计 <span class="math inline">\([0,V]\)</span> 内每个数对每一位的贡献，由于信息重复度较高所以随便乱写复杂度都没问题。</p></li>
<li><p>正常扫描线维护外层的求和即可。</p></li>
</ul>
<details>
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;
const int mod = 998244353;
int main() &#123;
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
    auto stime = std::chrono::steady_clock::now();
    // std::freopen(&quot;./down/wave/wave10.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;wave.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;wave.out&quot;, &quot;w&quot;, stdout);
    int n, k;
    long long V;
    std::cin &gt;&gt; n &gt;&gt; k &gt;&gt; V;
    std::vector&lt;int&gt; d(32);
    for (int i = 31; ~i; --i)
        d[i] = (V &gt;&gt; i) &amp; 1;
    std::vector&lt;std::vector&lt;int&gt; &gt; f(32);
    std::function&lt;std::vector&lt;int&gt; (int, bool)&gt; DFS = [&amp;](int x, bool flag) &#123;
        if (x == -1) &#123;
            std::vector&lt;int&gt; res(33);
            res[32] = 1;
            return res;
        &#125;
        if (!flag &amp;&amp; !f[x].empty())
            return f[x];
        auto res(DFS(x - 1, flag &amp;&amp; !d[x]));
        if (!flag || d[x] == 1) &#123;
            auto t(DFS(x - 1, flag));
            for (int i = 0; i &lt;= 31; ++i)
                res[i] += t[i];
            res[32] += t[32], res[x] += t[32];
        &#125;
        if (!flag)
            f[x] = res;
        return res;
    &#125;;
    auto cnt = DFS(31, true);
    std::vector&lt;int&gt; a(n + 1), pre(n + 1), nex(n + 1), L, R;
    for (int i = 1; i &lt;= n; ++i) &#123;
        std::cin &gt;&gt; a[i];
        if (i == 1)
            pre[i] = a[i];
        else
            pre[i] = std::__gcd(L.back(), a[i]);
        if (i == 1 || pre[i] != L.back())
            L.push_back(pre[i]);
        pre[i] = (int)L.size() - 1;
    &#125;
    for (int i = n; i; --i) &#123;
        if (i == n)
            nex[i] = a[i];
        else
            nex[i] = std::__gcd(R.back(), a[i]);
        if (i == n || nex[i] != R.back())
            R.push_back(nex[i]);
        nex[i] = (int)R.size() - 1;
    &#125;
    int nL = (int)L.size(), nR = (int)R.size();
    std::vector&lt;std::vector&lt;long long&gt; &gt; u(nL, std::vector&lt;long long&gt; (nR));
    for (int i = 0; i &lt; nL; ++i)
        for (int j = 0; j &lt; nR; ++j) &#123;
            int x = L[i], y = R[j];
            unsigned m = std::__gcd(x, y), LB = 1;
            auto HB = 1ll;
            for (int l = 1; l &lt;= k; ++l)
                LB *= m, (HB *= m) %= mod;
            (HB += mod - LB % mod) %= mod;
            u[i][j] = HB * (V + 1);
            for (int l = 31; ~l; --l) &#123;
                if ((LB &gt;&gt; l) &amp; 1)
                    u[i][j] += (1ll &lt;&lt; l) % mod * (V + 1 - cnt[l]) % mod;
                else
                    u[i][j] += (1ll &lt;&lt; l) % mod * cnt[l] % mod;
            &#125;
            u[i][j] %= mod;
        &#125;
    auto res = 0ll;
    std::vector&lt;int&gt; tot(nR);
    std::vector&lt;long long&gt; s(nR + 1);
    for (int i = n; i; --i) &#123;
        for (int j = 0; j &lt; nR; ++j)
            (res += u[pre[i]][j] * a[i] % mod * tot[j] % mod + u[pre[i]][j] * s[j] % mod) %= mod;
        ++tot[nex[i]], (s[nex[i]] += a[i]) %= mod;
    &#125;
    std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt;(std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
    return 0;
&#125;</code></pre>
</details>
<hr />
<h2 id="b.-帝国-cf1181e2-a-story-of-one-country-hard">B. 帝国 / CF1181E2 A Story of One Country (Hard)</h2>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/CF1181E2" class="uri">https://www.luogu.com.cn/problem/CF1181E2</a></p>
<ul>
<li><p>容易发现合法当且仅当可以通过横向或纵向地切，能够切成每块只有 1 个矩形的状态。</p>
<p>容易想到分治 + dsu on tree 维护。</p></li>
<li><p>发现特别难处理的是每层分治快速找分界线，这个做法应该挺多的，口胡了一个大常数做法：</p>
<p>用四个 <code>set</code> 维护按四个方向排序的结果，那么只需<strong>同时</strong>遍历这四个 <code>set</code> 的前一半元素，如果都没找到就无解。这样的复杂度就很对了。</p></li>
</ul>
<details>
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
    std::freopen(&quot;kingdom.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;kingdom.out&quot;, &quot;w&quot;, stdout);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int T;
    for (std::cin &gt;&gt; T; T--; ) &#123;
        int n;
        std::cin &gt;&gt; n;
        struct node &#123; int l, r, u, d; &#125;;
        std::vector&lt;node&gt; a(n + 1);
        for (int i = 1; i &lt;= n; ++i)
            std::cin &gt;&gt; a[i].l &gt;&gt; a[i].u &gt;&gt; a[i].r &gt;&gt; a[i].d, --a[i].r, --a[i].d;
        auto cmp1 = [&amp;](int i, int j) &#123; return a[i].u == a[j].u ? i &lt; j : a[i].u &lt; a[j].u; &#125;;
        auto cmp2 = [&amp;](int i, int j) &#123; return a[i].l == a[j].l ? i &lt; j : a[i].l &lt; a[j].l; &#125;;
        auto cmp3 = [&amp;](int i, int j) &#123; return a[i].d == a[j].d ? i &lt; j : a[i].d &gt; a[j].d; &#125;;
        auto cmp4 = [&amp;](int i, int j) &#123; return a[i].r == a[j].r ? i &lt; j : a[i].r &gt; a[j].r; &#125;;
        using op1 = std::set&lt;int, decltype(cmp1)&gt;;
        using op2 = std::set&lt;int, decltype(cmp2)&gt;;
        using op3 = std::set&lt;int, decltype(cmp3)&gt;;
        using op4 = std::set&lt;int, decltype(cmp4)&gt;;
        op1 t1(cmp1); op2 t2(cmp2); op3 t3(cmp3); op4 t4(cmp4);
        for (int i = 1; i &lt;= n; ++i)
            t1.insert(i), t2.insert(i), t3.insert(i), t4.insert(i);
        std::function&lt;bool(op1&amp;, op2&amp;, op3&amp;, op4&amp;)&gt; calc = [&amp;](op1 &amp;t1, op2 &amp;t2, op3 &amp;t3, op4 &amp;t4) &#123;
            int n = (int)t1.size();
            if (n == 1)
                return true;
            auto p1 = t1.begin(), p2 = t2.begin(), p3 = t3.begin(), p4 = t4.begin();
            int d = a[*p1].d, r = a[*p2].r, u = a[*p3].u, l = a[*p4].l;
            op1 nt1(cmp1); op2 nt2(cmp2); op3 nt3(cmp3); op4 nt4(cmp4);
            auto work = [&amp;](auto p, int to) &#123;
                for (;;) &#123;
                    int at = *p;
                    nt1.insert(at), nt2.insert(at), nt3.insert(at), nt4.insert(at);
                    if (at != to) &#123;
                        --p;
                        t1.erase(at), t2.erase(at), t3.erase(at), t4.erase(at);
                    &#125;
                    else &#123;
                        t1.erase(at), t2.erase(at), t3.erase(at), t4.erase(at);
                        break;
                    &#125;
                &#125;
                return;
            &#125;;
            for (int i = 1; i &lt;= n / 2; ++i) &#123;
                ++p1, ++p2, ++p3, ++p4;
                if (a[*p1].u &gt; d) &#123;
                    work(--p1, *t1.begin());
                    goto issol;
                &#125;
                if (a[*p2].l &gt; r) &#123;
                    work(--p2, *t2.begin());
                    goto issol;
                &#125;
                if (a[*p3].d &lt; u) &#123;
                    work(--p3, *t3.begin());
                    goto issol;
                &#125;
                if (a[*p4].r &lt; l) &#123;
                    work(--p4, *t4.begin());
                    goto issol;
                &#125;
                d = std::max(d, a[*p1].d), r = std::max(r, a[*p2].r);
                u = std::min(u, a[*p3].u), l = std::min(l, a[*p4].l);
                continue;
            issol:
                return calc(t1, t2, t3, t4) &amp;&amp; calc(nt1, nt2, nt3, nt4);
            &#125;
            return false;
        &#125;;
        std::cout &lt;&lt; (calc(t1, t2, t3, t4) ? &quot;YES&quot; : &quot;NO&quot;) &lt;&lt; &#39;\n&#39;;
    &#125;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;</code></pre>
</details>
<hr />
<h2 id="c.-平衡-cf1211h-road-repair-in-treeland">C. 平衡 / CF1211H Road Repair in Treeland</h2>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/CF1211H" class="uri">https://www.luogu.com.cn/problem/CF1211H</a></p>
<blockquote>
<p>给定大小为 <span class="math inline">\(n\)</span> 的无根树和 <span class="math inline">\(10^6\)</span> 种颜色，找到一种边的染色方式，使得：</p>
<ol type="1">
<li>与每个点相连的边，颜色种类数不超过 <span class="math inline">\(2\)</span>。</li>
<li>出现次数最多的颜色出现次数不超过 <span class="math inline">\(2\)</span>。你需要输出这个值。</li>
</ol>
<p><span class="math inline">\(1\le n\le 2\times 3000\)</span>。</p>
</blockquote>
<p>神秘电波简单题，难度虚高。</p>
<ul>
<li><p>很容易想到二分，考虑怎么 check 一个上限 <span class="math inline">\(mid\)</span>。</p></li>
<li><p>贪心地，因为颜色足够多，对于一个点 <span class="math inline">\(x\)</span>，占用的两种颜色，只会上传一种 <span class="math inline">\(a\)</span> 给父亲，故希望让 <span class="math inline">\(b\)</span> 在不超过 <span class="math inline">\(mid\)</span> 的情况下最大，这样 <span class="math inline">\(a\)</span> 就会最小。</p></li>
<li><p>令 <span class="math inline">\(h_i\)</span> 表示点 <span class="math inline">\(v\)</span> 上传颜色的最小 <span class="math inline">\(cnt\)</span>，那么相当于对于 <span class="math inline">\(u\)</span> 的每个儿子 <span class="math inline">\(v\)</span> 决策令 <span class="math inline">\(u\to v\)</span> 的颜色为 <span class="math inline">\(a/b\)</span>，发现是 trival 的 01 背包（甚至不是树上背包）。</p>
<p>复杂度 <span class="math inline">\(O(n^2\log n)\)</span>。</p></li>
</ul>
<details>
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
    std::freopen(&quot;balance.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;balance.out&quot;, &quot;w&quot;, stdout);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int T;
    for (std::cin &gt;&gt; T; T--; ) &#123;
        int n;
        std::cin &gt;&gt; n;
        std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);
        for (int i = 1, x, y; i &lt; n; ++i) &#123;
            std::cin &gt;&gt; x &gt;&gt; y;
            g[x].push_back(y), g[y].push_back(x);
        &#125;
        auto check = [&amp;](int m) &#123;
            std::vector&lt;int&gt; f1(m + 1), h(n + 1, m + 1);
            std::vector&lt;std::vector&lt;int&gt; &gt; f(n + 1, std::vector&lt;int&gt; (m + 1, m + 1));
            std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int fa) &#123;
                f[x][0] = 0;
                for (auto i : g[x])
                    if (i != fa) &#123;
                        DFS(i, x);
                        std::copy(f[x].begin(), f[x].end(), f1.begin());
                        std::fill(f[x].begin(), f[x].end(), m + 1);
                        for (int j = 0; j &lt;= m; ++j) &#123;
                            f[x][j] = std::min(f[x][j], f1[j] + h[i]);
                            if (j + h[i] &lt;= m)
                                f[x][j + h[i]] = std::min(f[x][j + h[i]], f1[j]);
                        &#125;
                    &#125;
                for (int i = 0; i &lt;= m; ++i)
                    h[x] = std::min(h[x], f[x][i] + (x != 1));
                return;
            &#125;;
            DFS(1, -1);
            return h[1] &lt;= m;
        &#125;;
        int res = -1;
        for (int l = 1, r = n - 1, mid; l &lt;= r; ) &#123;
            mid = (l + r) &gt;&gt; 1;
            if (check(mid))
                res = mid, r = mid - 1;
            else
                l = mid + 1;
        &#125;
        std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
        std::vector&lt;int&gt; f1(res + 1), h(n + 1, res + 1), p(n + 1);
        std::vector&lt;std::vector&lt;int&gt; &gt; f(n + 1, std::vector&lt;int&gt; (res + 1, res + 1));
        std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int fa) &#123;
            f[x][0] = 0;
            for (auto i : g[x])
                if (i != fa) &#123;
                    DFS(i, x);
                    std::copy(f[x].begin(), f[x].end(), f1.begin());
                    std::fill(f[x].begin(), f[x].end(), res + 1);
                    for (int j = 0; j &lt;= res; ++j) &#123;
                        f[x][j] = std::min(f[x][j], f1[j] + h[i]);
                        if (j + h[i] &lt;= res)
                            f[x][j + h[i]] = std::min(f[x][j + h[i]], f1[j]);
                    &#125;
                &#125;
            for (int i = 0; i &lt;= res; ++i)
                h[x] = std::min(h[x], f[x][i] + (x != 1));
            return;
        &#125;;
        DFS(1, -1);
    &#125;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;</code></pre>
</details>
<hr />
<p>怎么就是人生中最后一场模拟赛了？（存疑）</p>
<pre><code>【标记】请在 2025-12-01 23:59:59(UTC+8) 执行：删除第 1239 行中末尾的 &quot;（存疑）&quot;，在项目根目录运行 &quot;hexo clean &amp;&amp; hexo generate &amp;&amp; hexo deploy&quot; 命令并保留日志。</code></pre>
<p>笑点解析：这句话看起来像是让某个 bot 执行一条操作，暗示我自己可能已经没有机会做这件事了，表现了凄凉之感。</p>
<hr />
<h2 id="c.-equalization">C. Equalization</h2>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P7718" class="uri">https://www.luogu.com.cn/problem/P7718</a></p>
<ul>
<li></li>
</ul>

			</div>
			<hr class="dotted">
			<div class="post footer">
				<div id="hitokoto">
					<h3 id="hitokoto-title">
						言论
					</h3>
					<div id="hitokoto-content">
					</div>
					<div id="hitokoto-from">
					</div>
				</div>
				<div class="button flex">
					<div id="prev">
						
							<!-- 吐槽，为啥还需要加 / -->
							<a href="/20251118-1/">
								<i class="fas fa-angle-double-left" style="margin-right: 10px;"></i>
								杂文速读
							</a>
						
					</div>
					<div id="next">
						
							<a href="/20251116/">
								杂题选谈 计数
								<i class="fas fa-angle-double-right" style="margin-left: 10px;"></i>
							</a>
						
					</div>
				</div>
				<div id="vcomments" class="text"></div>
<script>
	new Valine({
		el: '#vcomments',
		appId: 'OlmvQ0a2Zw7xo3no2bwabOzx-gzGzoHsz',
		appKey: 'TW6t8mFeGLmhPjWisvmllvvo',
		recordIP: true,
		enableQQ: true, 
		// [EDITED] 目前 Valine 的 QQ 自动获取昵称似乎不可用
		// 该问题在 v1.5.3 中已修复
		pageSize: 10,
		requiredFields:
			
				['nick']
			,
		placeholder: "The world is but a little place after all...\n能够根据邮箱获取你的 Gravatar 头像。昵称是必填项，长度需不低于 3。",
		avatar: 'identicon',
		avatar_cdn: 'https://cravatar.cn/avatar/',
		emojiCDN: 'https://xsc062.netlify.app/em/', 
		emojiMaps: {
			
				"微笑": "wx.gif",
			
				"龇牙": "cy.gif",
			
				"流泪": "ll.gif",
			
				"笑哭": "xk.gif",
			
				"流汗": "lh.gif",
			
				"擦汗": "ch.gif",
			
				"亲亲": "qq.gif",
			
				"色": "se.gif",
			
				"疑问": "yiw.gif",
			
				"发呆": "fd.gif",
			
				"晕": "yun.gif",
			
				"鼓掌": "gz.gif",
			
				"憨笑": "hanx.gif",
			
				"快哭了": "kk.gif",
			
				"得意": "dy.gif",
			
				"狂笑": "kx.gif",
			
				"害羞": "hx.gif",
			
				"妈妈生的": "dz.gif",
			
				"糗大了": "qd.gif",
			
				"吃瓜": "cg.gif",
			
				"睁眼": "zy.webp",
			
				"辣眼睛": "lyj.gif",
			
				"酸了": "nm.gif",
			
				"滚": "gun.webp",
			
				"惊恐": "jk.gif",
			
				"幽灵": "youl.gif",
			
				"无聊": "wul.gif",
			
				"吃": "eat.gif",
			
				"你很棒棒": "bb.gif",
			
				"赞": "qiang.gif",
			
				"踩": "ruo.gif",
			
				"握手": "wsh.gif",
			
				"发抖": "fad.gif",
			
				"挥手": "hsh.gif",
			
				"磕头": "kt.gif",
			
				"怄火": "oh.gif",
			
		},
		mathjax: true,
	})
</script>
			</div>
			<script>setHitokoto();</script>
		</div> 
	</div>
</div>
    <!-- 页脚开始 -->
<div id="footer" class="serif">
    Powered by
    <a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a>
    &
    <a href="/about-this-theme">
        iwll
    </a>
    <p style="margin-top: 5px;">
        2021 - 2025
    </p>
    <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/" id="CCTAG"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/big/by_nc_sa.svg"></a>
</div>
<!-- Valine 相关配置 -->
<script>
    const getValineDomTimer = setInterval(() => {
        // 不知道为什么 我从原博客 js 文件粘过来的参数是
        // "#valine .vcards .vcard"
        // DEBUG 了半天才定位到这个问题。。。
        const vcards =
            document.querySelectorAll('#valine, .vcards, .vcard');
        if (vcards.length > 0) {
            let author = 'XSC062';
            for (let vcard of vcards) {
                const vnick_dom = vcard.querySelector('.vhead .vnick');
                if (vnick_dom != null) {
                    const vnick = vnick_dom.innerHTML;
                    if (vnick === author) {
                        vnick_dom.innerHTML =
                        `${vnick} <span id="rootitem" class="code">root</span>`
                    }
                }
            }
        }
        else {
            clearInterval(getValineDomTimer);
        }
    }, 2000);
    SetActiveItem();
    setDetailsSummary();
    setTitleAnchor();
    setEmptyToc();
    setCodeClassName();
</script>


<!-- js -->
<!-- 搜索功能相关配置 -->

<script src="/js/search.js"></script>


<script src="/js/local-search.js"></script>

</script>
<!-- prism 相关配置 -->
<script type="text/javascript" src="/js/prism.js" defer></script>
<!-- 代码块复制功能 -->
<script type="text/javascript" src="/js/clipboard.min.js"></script>
<script type="text/javascript" src="/js/clipboard-use.js"></script>
<!-- 页脚结束 -->
</body>
</html>