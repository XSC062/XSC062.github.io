<!DOCTYPE html>
<html>
<head>
    <!-- 网站图标 -->
<link rel="icon" type="image/png" sizes="32x32" href="/images/icon.svg">
<!-- 其他图标支持 -->
<link rel="stylesheet" href="/css/facss/fa-brands.min.css">
<link rel="stylesheet" href="/css/facss/fa-regular.min.css">
<link rel="stylesheet" href="/css/facss/fa-solid.min.css">
<link rel="stylesheet" href="/css/facss/fontawesome.min.css">
<link rel="stylesheet" href="/css/facss/fontawesome-all.css">
<link href="https://use.fontawesome.com/releases/v5.0.4/css/all.css" rel="stylesheet">
<!-- 网站标题 -->
<title>
	
		杂题选谈 -
	
	XSC062 的博客
</title>
<!-- js 引入 -->
<script>
const searchPath = "/search.xml"
</script>

<script src="/js/afterloaded.js"></script>


<script src="/js/jQuery.js"></script>

<!-- 载入 Valine -->

<script src="/js/Valine.min.js"></script>

<!-- css 引入 -->

<link rel="stylesheet" href="/css/layout.css">


<link rel="stylesheet" href="/css/prcss/prism.css">



<!-- rss -->
<link rel="alternate" type="application/rss+xml" title="" href="https://xsc062.netlify.app/rss.xml" />
<link rel="alternate" type="application/atom+xml" title="" href="https://xsc062.netlify.app/atom.xml" />
<link rel="alternate" type="application/json" title="" href="https://xsc062.netlify.app/feed.json" />

<meta charset="utf-8"> 
    
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
          tex2jax: {
            inlineMath: [ ['$','$'], ["\\(","\\)"] ],
            processEscapes: true
          }
        });
      </script>
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
            tex2jax: {
              skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
            }
          });
      </script>
    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
              var all = MathJax.Hub.getAllJax(), i;
              for(i=0; i < all.length; i += 1) {
                  all[i].SourceElement().parentNode.className += ' has-jax';
              }
          });
      </script>
    <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS_CHTML"></script>

<meta name="generator" content="Hexo 7.2.0"></head>
<body class="line-numbers match-braces no-brace-select rainbow-braces">
	<!-- 搜索 -->
<script>
	function closeSearchBox() {
		$("#search-bg").css("transition", "null"); 
		$("#search-bg").css("z-index", "-1"); 
		$("#search-bg").css("opacity", "0%");
		return;
	}
</script>
<div id="search-bg">
	<div id="search-box">
		<button id="close-button" onclick="closeSearchBox()">
			<i class="fas fa-times"></i>
		</button>
		<input type="text" id="search-input" placeholder="Type to search...">
		<div id="search-results">
			<div id="emptyInput">
				<p>键入以搜索…</p>
				<p><i>匹配算法</i>：把输入按空格拆分，单独<strong>匹配</strong>每一段输入（不区分大小写，仅匹配文章文本内容），输出取或后的结果。</p>
				<p>模糊搜索似乎很难搞，目前没有相关打算。</p>
			</div>
		</div>
	</div>
</div>
<!-- 顶栏整体导航菜单 -->
<div class="ui top menu">
	<!-- 左对齐 logo -->
	<a class="logo" href="/">
		<img width="25px" height="25px" style="border: solid transparent 2.5px" src="/images/icon.svg"></img>
		<div id="bartitle" class="text">
			XSC062 的博客
		</div>
	</a>
	<!-- 右对齐部分导航 -->
	<div id="rightali" class="serif">
		<a class="item" id="Search" type="button">
			<i class="btn text-muted fa fa-search" id="search-icon" disabled></i>
		</a>
		<a class="item" id="Home" href="/">
			Home
		</a>
		<a class="item" id="Arch" href="/archives">
			Archives
		</a>
		<!-- <a class="item" id="Cate" href="/categories">
			Categories
		</a> -->
		<a class="item" id="Tags" href="/tags">
			Tags
		</a>
		<a class="item" id="Frie" href="/friends">
			Friends
		</a>
		<a class="item" id="Abou" href="/about">
			About
		</a>
	</div>
</div>
    
<link rel="stylesheet" href="/css/post.css">


<script src="/js/post.js"></script>


<div class="main">
	<div id="sidebar" class="text">
		<aside id="toc">
			<span id="toctitle">
				<i class="fas fa-list"></i>
				目录
			</span>
			<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#a.-%E6%8E%92%E5%BA%8F"><span class="toc-text">A. 排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#b.-%E9%87%8D%E6%8E%92"><span class="toc-text">B. 重排</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#c.-%E6%95%B4%E5%BC%8F%E6%AF%94%E8%BE%83-qoj10506.-waga"><span class="toc-text">C. 整式比较 &#x2F; qoj#10506. Waga</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#b.-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2"><span class="toc-text">B. 字符串转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#c.-%E7%9B%91%E6%8E%A7"><span class="toc-text">C. 监控</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#g---range-set-modifying-query"><span class="toc-text">G - Range Set Modifying Query</span></a></li></ol>
		</aside>
	</div>
	<div class="ui post container">
		<div class="ui text container">
			<span id="postcon">
				<span id="postinfo">
					<div class="ui post title serif">
						<div id="fortitle" data-content="杂题选谈">
							杂题选谈
						</div>
						<div class="ui title background">
						</div>
					</div>
					<span id="date">
						<i class="fas fa-calendar-alt" style="margin-right: 4px;"></i>
						2025-10-28
					</span>
				</span>
			</span>
			<div id="posttags" class="dotted border">
				
					
						<a href="/tags/分治/" class="citem">分治</a>
					
						<a href="/tags/分块/" class="citem">分块</a>
					
						<a href="/tags/背包/" class="citem">背包</a>
					
				
			</div>
			<!-- 本来用的是 fromNow 然后字符串判断，没想到可以直接调用 moment() -->
			
			<div id="content">
				<p>模拟赛的密度正在威胁其他文章的生存环境。</p>
<span id="more"></span>
<hr />
<h2 id="a.-排序">A. 排序</h2>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P14352" class="uri">https://www.luogu.com.cn/problem/P14352</a></p>
<blockquote>
<p>对于一个长度为 <span class="math inline">\(n\)</span> 的排列 <span class="math inline">\(p\)</span>，定义一轮冒泡：</p>
<pre class="python"><code>for i in range(1, n):
    if p[i] &gt; p[i + 1]:
        swap(p[i], p[i + 1])</code></pre>
<p>给定 <span class="math inline">\(n,k\)</span>，问在所有长度为 <span class="math inline">\(n\)</span> 的排列中，可以在 <span class="math inline">\(k\)</span> 轮冒泡后单增的排列数量。对 <span class="math inline">\(998244353\)</span> 取模。</p>
<p><span class="math inline">\(n\le 10^{18},k\le 2\times 10^7\)</span>。</p>
</blockquote>
<ul>
<li><p>反序表。令 <span class="math inline">\(a_i\)</span> 表示 <span class="math inline">\(i\)</span> 结尾的逆序对数，那么限制相当于说 <span class="math inline">\(\max\{a\}\le k\)</span>。</p></li>
<li><p>也即限制一个元素之前大于之的元素数不超过 <span class="math inline">\(k\)</span>，可以直接计数。想象把 <span class="math inline">\(1\sim n\)</span> 依次填入排列的过程：</p>
<ul>
<li><p>对于 <span class="math inline">\(1\sim n-k\)</span>，只能填在剩余空位的左 <span class="math inline">\(k+1\)</span> 个（因为填完它后，剩下的空位都比它大）；</p></li>
<li><p>对于 <span class="math inline">\(n-k+1\sim n\)</span>，可以填在剩余任意一个空位。</p></li>
</ul>
<p>故答案为 <span class="math inline">\((k+1)^{n-k}\cdot k!\)</span>。</p></li>
</ul>
<details>
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;
const int mod = 998244353;
int main() &#123;
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
    std::freopen(&quot;sorting.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;sorting.out&quot;, &quot;w&quot;, stdout);
    auto stime = std::chrono::steady_clock::now();
    long long n;
    int k;
    std::cin &gt;&gt; n &gt;&gt; k, k = std::min((long long)k, n);
    auto qkp = [&amp;](long long x, int y) &#123;
        auto res = 1ll;
        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)
            if (y &amp; 1)
                (res *= x) %= mod;
        return res;
    &#125;;
    auto res = qkp(k + 1, (n - k) % (mod - 1));
    for (int i = 1; i &lt;= k; ++i)
        (res *= i) %= mod;
    std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt;(std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s \n&quot;;
    return 0;
&#125;</code></pre>
</details>
<hr />
<h2 id="b.-重排">B. 重排</h2>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P14353" class="uri">https://www.luogu.com.cn/problem/P14353</a></p>
<blockquote>
<p>给定一个初始为空的数组 <span class="math inline">\(a\)</span>，再给出 <span class="math inline">\(n\)</span> 次加数操作，每次加数后输出：</p>
<p>任意排列 <span class="math inline">\(a\)</span>，得到的 <span class="math inline">\(\sum\limits_{i=2}^n |a_{i+1}-a_{i}|\)</span> 的最大值。</p>
<p><span class="math inline">\(n\le 3\times 10^6\)</span>。</p>
</blockquote>
<ul>
<li><p>显然从小到大排列，答案是后 <span class="math inline">\(\left\lfloor \dfrac n2\right\rfloor\)</span> 个数的和减去前 <span class="math inline">\(\left\lfloor \dfrac n2\right\rfloor\)</span> 的和的差的二倍，再减去位于中间 2 / 3 个数中，相邻两个差的最小值。</p>
<p>这家伙在说什么呢.jpg</p></li>
<li><p>用大根堆 + 小根堆维护即可，因为 pbds 过不去</p></li>
</ul>
<details>
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;
int main() &#123;
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
    std::freopen(&quot;rearrange.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;rearrange.out&quot;, &quot;w&quot;, stdout);
    auto stime = std::chrono::steady_clock::now();
    int n, T;
    std::cin &gt;&gt; n &gt;&gt; T;
    auto res = 0ll, la = 0ll, sL = 0ll, sR = 0ll;
    std::priority_queue&lt;int&gt; L;
    std::priority_queue&lt;int, std::vector&lt;int&gt;, std::greater&lt;int&gt; &gt; R;
    for (int i = 1, mid = 0; i &lt;= n; ++i) &#123;
        long long x;
        std::cin &gt;&gt; x;
        int b =  T ? x ^ la : x;
        if (i == 1)
            mid = b, la = 0ll;
        else if (i &amp; 1) &#123;
            if (b &lt; L.top()) &#123;
                mid = L.top(), sL -= mid;
                L.pop();
                sL += b, L.push(b);
            &#125;
            else if (b &gt; R.top()) &#123;
                mid = R.top(), sR -= mid;
                R.pop();
                sR += b, R.push(b);
            &#125;
            else
                mid = b;
            la = 2 * (sR - sL) - std::min(R.top() - mid, mid - L.top());
        &#125;
        else &#123;
            if (b &lt;= mid) &#123;
                sL += b, sR += mid;
                L.push(b), R.push(mid);
            &#125;
            else &#123;
                sL += mid, sR += b;
                L.push(mid), R.push(b);
            &#125;
            la = 2 * (sR - sL) - (R.top() - L.top());
        &#125;
        res ^= la;
    &#125;
    printf(&quot;%lld\n&quot;, res);
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt;(std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s \n&quot;;
    return 0;
&#125;</code></pre>
</details>
<hr />
<h2 id="c.-整式比较-qoj10506.-waga">C. 整式比较 / qoj#10506. Waga</h2>
<p><a target="_blank" rel="noopener" href="https://www.becoder.com.cn/contest/6685/problem/3" class="uri">https://www.becoder.com.cn/contest/6685/problem/3</a> / <a target="_blank" rel="noopener" href="https://qoj.ac/problem/10506" class="uri">https://qoj.ac/problem/10506</a></p>
<blockquote>
<p>给定 <span class="math inline">\(a_{1\cdots n}\)</span>，和一个称，如下操作称为一次『称重』：</p>
<ul>
<li>选中 <span class="math inline">\(a\)</span> 的一个子集，输入给称。记它们的和为 <span class="math inline">\(s\)</span>，那么称会返回 <span class="math inline">\(\min(k,\left\lfloor \dfrac sc \right\rfloor)\)</span>，其中，<span class="math inline">\(c\)</span> 为给定常数。</li>
</ul>
<p>现在对于每个无序对 <span class="math inline">\((i,j)\)</span>（<span class="math inline">\(i\ne j\)</span>），你需要判断：</p>
<ul>
<li>在已知 <span class="math inline">\(a\)</span> 中除 <span class="math inline">\(a_i,a_j\)</span> 外所有元素值，且 <span class="math inline">\(a_i,a_j\)</span> 数值未知的前提下，是否可以通过若干次称重确定 <span class="math inline">\(a_i,a_j\)</span> 的大小关系。</li>
</ul>
<p><span class="math inline">\(n,c\le 8000,k\le 10^5,1\le a_i&lt; kc\)</span>。</p>
</blockquote>
<ul>
<li><p>显然，<span class="math inline">\(a_i\)</span> 和 <span class="math inline">\(a_j\)</span> 能区分，当且仅当 <span class="math inline">\(\left\lfloor\dfrac {a_i}c\right\rfloor\ne \left\lfloor\dfrac {a_j}c\right\rfloor\)</span>，或者存在一个其他元素的子集 <span class="math inline">\(s\)</span>，使得 <span class="math inline">\(\left\lfloor\dfrac {a_i+s}c\right\rfloor\ne \left\lfloor\dfrac {a_j + s}c\right\rfloor\)</span>。</p>
<p>反过来，如果 <span class="math inline">\(a_i\)</span> 和 <span class="math inline">\(a_j\)</span> 不能区分，一个前提是 <span class="math inline">\(\left\lfloor\dfrac {a_i}c\right\rfloor =\left\lfloor\dfrac {a_j}c\right\rfloor\)</span>。</p></li>
<li><p>下意识猜要排序，排序后打表发现使 <span class="math inline">\(i\)</span> 不合法的 <span class="math inline">\(j\)</span> 总是连续的。</p>
<details>
<p><summary>证明</summary></p>
<ol type="1">
<li><p>需要证：对于 <span class="math inline">\(x&lt;y&lt;z\)</span>，若 <span class="math inline">\(x,y\)</span> 不可区分，且 <span class="math inline">\(y,z\)</span> 不可区分，那么 <span class="math inline">\(x,z\)</span> 不可区分。</p>
<p>记 <span class="math inline">\(\left\lfloor\dfrac {x}c\right\rfloor=\left\lfloor\dfrac {y}c\right\rfloor=\left\lfloor\dfrac {z}c\right\rfloor=w\)</span>，不存在 <span class="math inline">\(s\le c\cdot (k-w)\)</span>，使得 <span class="math inline">\(y\)</span> 可以进位但 <span class="math inline">\(x\)</span> 不可，也不存在这样的 <span class="math inline">\(s\)</span> 使得 <span class="math inline">\(z\)</span> 可以进位但 <span class="math inline">\(y\)</span> 不可。</p>
<p>合并不等式容易得到不存在这样的 <span class="math inline">\(x\)</span> 使得 <span class="math inline">\(z\)</span> 可以进位但 <span class="math inline">\(x\)</span> 不可。</p></li>
<li><p>需要证：对于 <span class="math inline">\(x&lt;y&lt;z\)</span>，若 <span class="math inline">\(x,y\)</span> 可区分或 <span class="math inline">\(y,z\)</span> 可区分，则 <span class="math inline">\(x,z\)</span> 可区分。</p>
<p>调整法易得。</p></li>
</ol>
</details></li>
<li><p>故发现只需要讨论相邻两个元素是否可区分。需要知道所有可能的子集和用于 check，可以用分治预处理『只有某相邻两个元素不选』时的前后缀背包数组（到达某个余数时需要的最小整倍数），就可以 <span class="math inline">\(O(nc\log n)\)</span> 解决问题。</p>
<p>考虑在做什么：删点在 <span class="math inline">\([l,mid]\)</span>，那么 <span class="math inline">\([mid+1,r]\)</span> 的 DP 数组不会受到影响；删点在 <span class="math inline">\([mid + 1, r]\)</span>，那么 <span class="math inline">\([l,mid]\)</span> 的 DP 数组不会受到影响。背包的物品是无顺序的，所以有正确性。</p>
<p>也就是说大部分信息是可继承的。<em>为什么题解管这个叫 CDQ？是因为普通分治总会被叫 CDQ 吗？</em></p>
<p>做一个类似 01 背包滚动数组的东西，维护每个点前 / 后可以凑出来的背包值，在最后下传到单点时统计答案即可。</p></li>
</ul>
<details>
<p>相邻两个的处理略显烧脑，但意外地简洁。</p>
<p><code>&gt;=</code> 不要写成除，不然会慢成唐诗</p>
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;
const int maxn = 8e3 + 5;
char nec(void) &#123;
    static char buf[1 &lt;&lt; 20], *p = buf, *e = buf;
    if (p == e) &#123;
        e = buf + fread(buf, 1, 1 &lt;&lt; 20, stdin);
        p = buf;
    &#125;
    return *p++;
&#125;
int read(void) &#123;
    auto x = 0ll;
    char t = nec();
    for (; t &lt; &#39;0&#39; || t &gt; &#39;9&#39;; t = nec());
    for (; t &gt;= &#39;0&#39; &amp;&amp; t &lt;= &#39;9&#39;; t = nec())
        x = x * 10 + t - &#39;0&#39;;
    return x;
&#125;
int ok[maxn], m, k;
std::pair&lt;int, int&gt; a[maxn];
void calc(int l, int r, const std::vector&lt;int&gt; f) &#123;
    if (l &gt; r)
        return;
    if (l == r) &#123;
        if (a[l].first == a[l + 1].first)
            ok[l] = 1;
        else if (a[l].first / m == a[l + 1].first / m)
            ok[l] = (*std::min_element(f.begin() + m - a[l + 1].first % m, f.begin() + m - a[l].first % m) + a[l].first / m &gt;= k);
        return;
    &#125;
    int mid = (l + r) &gt;&gt; 1;
    auto g = f;
    for (int i = mid + 2; i &lt;= r + 1; ++i) &#123;
        auto h = g;
        for (int j = 0, k; j &lt; m; ++j) &#123;
            k = (j + m - a[i].first % m) % m;
            h[j] = std::min(h[j], g[k] + a[i].first / m + (k + a[i].first % m &gt;= m));
        &#125;
        h.swap(g);
    &#125;
    calc(l, mid, g);
    g = f;
    for (int i = l; i &lt;= mid; ++i) &#123;
        auto h = g;
        for (int j = 0, k; j &lt; m; ++j) &#123;
            k = (j + m - a[i].first % m) % m;
            h[j] = std::min(h[j], g[k] + a[i].first / m + (k + a[i].first % m &gt;= m));
        &#125;
        h.swap(g);
    &#125;
    calc(mid + 1, r, g);
    return;
&#125;;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
    std::freopen(&quot;intcmp.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;intcmp.out&quot;, &quot;w&quot;, stdout);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n = read();
    m = read(), k = read();
    for (int i = 1; i &lt;= n; ++i)
        a[i].first = read(), a[i].second = i;
    std::sort(a + 1, a + n + 1);
    std::vector&lt;int&gt; f(m, 0x3f3f3f3f);
    f[0] = 0;
    calc(1, n - 1, f);
    std::vector&lt;int&gt; resL(n + 1), resR(n + 1);
    int now = 0;
    for (int i = 1; i &lt;= n; ++i) &#123;
        resR[a[i].second] = i - 1 - now;
        if (i != n &amp;&amp; ok[i])
            ++now;
        else
            now = 0;
    &#125;
    now = 0;
    for (int i = n; i; --i) &#123;
        resL[a[i].second] = n - i - now;
        if (ok[i - 1])
            ++now;
        else
            now = 0;
    &#125;
    for (int i = 1; i &lt;= n; ++i)
        printf(&quot;%d %d \n&quot;, resL[i], resR[i]);
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;</code></pre>
</details>
<hr />
<h2 id="b.-字符串转换">B. 字符串转换</h2>
<p><a target="_blank" rel="noopener" href="https://www.becoder.com.cn/problem/52055" class="uri">https://www.becoder.com.cn/problem/52055</a></p>
<blockquote>
<p>给定等长 01 串 <span class="math inline">\(S,T\)</span>，维护 <span class="math inline">\(Q\)</span> 次操作：</p>
<ul>
<li>修改：Flip <span class="math inline">\(S\)</span> 的某个字符。</li>
<li>修改：Flip <span class="math inline">\(T\)</span> 的某个字符。</li>
</ul>
<p>每次操作后，问 <span class="math inline">\(S\)</span> 能否通过若干次下列操作变为 <span class="math inline">\(T\)</span>：</p>
<ul>
<li>选择 <span class="math inline">\(S\)</span> 中的一个 <code>00</code>，变为 <code>10</code>。</li>
<li>选择 <span class="math inline">\(S\)</span> 中的一个 <code>11</code>，变为 <code>01</code>。</li>
</ul>
<p><span class="math inline">\(|S|,Q\le 3\times 10^5\)</span>。</p>
</blockquote>
<ul>
<li><p>连续 00 / 11 操作，考虑奇数位取反。取反之后发现原操作等价于 <span class="math inline">\(a_i\gets a_{i+1}\)</span>。</p></li>
<li><p>这个操作只会使连续段的数量减少，故要求每一个后缀，<span class="math inline">\(S\)</span> 的连续段个数不少于 <span class="math inline">\(T\)</span> 的连续段个数，而且二者结尾相同。</p>
<p>线段树维护即可。</p></li>
</ul>
<details>
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;
const int maxn = 3e5 + 5;
struct &#123; int l, r, mn, d; &#125; t[maxn &lt;&lt; 2];
#define lt (p &lt;&lt; 1)
#define rt (lt | 1)
void bld(int p, int l, int r) &#123;
    t[p].l = l, t[p].r = r;
    t[p].mn = t[p].d = 0;
    if (l == r)
        return;
    int mid = (l + r) &gt;&gt; 1;
    bld(lt, l, mid), bld(rt, mid + 1, r);
    return;
&#125;
void pushdown(int p) &#123;
    if (t[p].d) &#123;
        t[lt].mn += t[p].d, t[lt].d += t[p].d;
        t[rt].mn += t[p].d, t[rt].d += t[p].d;
        t[p].d = 0;
    &#125;
    return;
&#125;
void add(int p, int l, int r, int v) &#123;
    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r) &#123;
        t[p].mn += v, t[p].d += v;
        return;
    &#125;
    pushdown(p);
    int mid = (t[p].l + t[p].r) &gt;&gt; 1;
    if (l &lt;= mid)
        add(lt, l, r, v);
    if (r &gt; mid)
        add(rt, l, r, v);
    t[p].mn = std::min(t[lt].mn, t[rt].mn);
    return;
&#125;
#undef lt
#undef rt
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
    std::freopen(&quot;string.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;string.out&quot;, &quot;w&quot;, stdout);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int T;
    for (std::cin &gt;&gt; T; T--; ) &#123;
        int n, q;
        std::cin &gt;&gt; n &gt;&gt; q;
        std::vector&lt;int&gt; a(n + 1), b(n + 1);
        bld(1, 1, n);
        for (int i = 1; i &lt;= n; ++i) &#123;
            char t;
            std::cin &gt;&gt; t, a[i] = (t == &#39;B&#39;);
            if (i &amp; 1)
                a[i] ^= 1;
        &#125;
        for (int i = 1; i &lt;= n; ++i) &#123;
            char t;
            std::cin &gt;&gt; t, b[i] = (t == &#39;B&#39;);
            if (i &amp; 1)
                b[i] ^= 1;
        &#125;
        for (int i = 1; i &lt;= n; ++i) &#123;
            int v = 0;
            v += (i == n || a[i] != a[i + 1]);
            v -= (i == n || b[i] != b[i + 1]);
            if (v)
                add(1, 1, i, v);
        &#125;
        for (char op; q--; ) &#123;
            int i;
            std::cin &gt;&gt; op &gt;&gt; i;
            if (op == &#39;X&#39;) &#123;
                int v = 0, v1 = 0;
                v -= (i == n || a[i] != a[i + 1]);
                v1 -= (i != 1 &amp;&amp; a[i] != a[i - 1]);
                a[i] ^= 1;
                v += (i == n || a[i] != a[i + 1]);
                v1 += (i != 1 &amp;&amp; a[i] != a[i - 1]);
                if (v)
                    add(1, 1, i, v);
                if (v1)
                    add(1, 1, i - 1, v1);
            &#125;
            else &#123;
                int v = 0, v1 = 0;
                v += (i == n || b[i] != b[i + 1]);
                v1 += (i != 1 &amp;&amp; b[i] != b[i - 1]);
                b[i] ^= 1;
                v -= (i == n || b[i] != b[i + 1]);
                v1 -= (i != 1 &amp;&amp; b[i] != b[i - 1]);
                if (v)
                    add(1, 1, i, v);
                if (v1)
                    add(1, 1, i - 1, v1);
            &#125;
            std::cout &lt;&lt; ((a[n] == b[n] &amp;&amp; t[1].mn &gt;= 0) ? &quot;YES&quot; : &quot;NO&quot;) &lt;&lt; &#39;\n&#39;;
        &#125;
    &#125;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;</code></pre>
</details>
<hr />
<h2 id="c.-监控">C. 监控</h2>
<p><a target="_blank" rel="noopener" href="https://www.becoder.com.cn/problem/52057" class="uri">https://www.becoder.com.cn/problem/52057</a></p>
<blockquote>
<p>给定 <span class="math inline">\(n\)</span> 个怪，每个怪有 <span class="math inline">\(B_i\)</span> 滴血，也就是说每个怪能被打 <span class="math inline">\(\le B_i\)</span> 次。</p>
<p>要求每个怪必须被打 <span class="math inline">\(\ge A_i\)</span> 次，并认为被打恰好 <span class="math inline">\(A_i\)</span> 次时这个怪是好的。</p>
<p>对于每个 <span class="math inline">\(1\le x\le \sum B_i\)</span>，求：在攻击次数只能为 <span class="math inline">\(x\)</span> 的倍数的前提下，不好的怪的最小值。你只需要输出答案的和。</p>
<p><span class="math inline">\(N\le 10^5,1\le A_i&lt; B_i\le 10^5\)</span>。</p>
</blockquote>
<ul>
<li><p>记 <span class="math inline">\(c_i=B_i-A_i\)</span>，把 <span class="math inline">\(c_i\)</span> 降序排列，记 <span class="math inline">\(s=\sum A_i\)</span>，那么一个 <span class="math inline">\(x\)</span> 的答案为：</p>
<p><span class="math display">\[
\min\left\{i\mid{\left\lceil \frac{s}x \right\rceil\cdot x - s\ge c_i}\right\}
\]</span></p></li>
<li><p>容易想到整除分块，枚举 <span class="math inline">\(\left\lceil \dfrac{s}x \right\rceil\)</span> 的值 <span class="math inline">\(k\)</span>，那么相当于想要找到 <span class="math inline">\([L_i,R_i]\)</span> 中的每个 <span class="math inline">\(x\)</span>，<span class="math inline">\(x\cdot k-s\)</span> 会落在哪个 <span class="math inline">\(c\)</span> 的管辖范围里。</p>
<p>不妨记 <span class="math inline">\(c_i\)</span> 的管辖范围为 <span class="math inline">\([cL_i,cR_i]\)</span>，那么转化为 <span class="math inline">\(x\cdot k-s\in [cL_i,cR_i]\)</span>，枚举 <span class="math inline">\(c\)</span> 解不等式即可。</p></li>
<li><p>但发现一个严重的问题：外层整除分块复杂度是 <span class="math inline">\(\sqrt(s)\)</span> 的，最劣 <span class="math inline">\(10^5\)</span> 级别，很坏了。</p>
<p>发现枚举商数劣的原因是使 <span class="math inline">\(\left\lceil \dfrac{s}x \right\rceil\)</span> 很大的 <span class="math inline">\(x\)</span> 并不多，却占用了很多枚举次数</p>
<p>如果做经典的整除分块同样会发现到后期块内元素远远少于 <span class="math inline">\(n\)</span>，却要花费 <span class="math inline">\(n\)</span> 次操作来处理它们。所以对于这部分数我们直接朴素二分。</p></li>
<li><p>取阈值为 1500 即可。</p></li>
</ul>
<details>
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;
const int B = 1500;
const long long inf = 1e18;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n;
    std::cin &gt;&gt; n;
    std::vector&lt;long long&gt; c(n + 1);
    auto sa = 0ll, sb = 0ll;
    for (int i = 1, a, b; i &lt;= n; ++i) &#123;
        std::cin &gt;&gt; a &gt;&gt; b;
        sa += a, sb += b, c[i] = b - a;
    &#125;
    std::sort(c.begin() + 1, c.end(), std::greater&lt;int&gt; ());
    std::partial_sum(c.begin() + 1, c.end(), c.begin() + 1);
    auto L = sb + 1;
    std::stack&lt;std::pair&lt;long long, int&gt; &gt; st;
    for (int k = 1; k &lt;= 1500; ++k) &#123;
        auto l = (sa + k - 1) / k, r = L - 1;
        if (l &gt; r)
            continue;
        L = l;
        st.emplace(r, n + 1);
        for (int i = n; ~i; --i)
            st.emplace(std::min(r, (c[i] + sa) / k), i);
    &#125;
    for (int i = L - 1; i; --i)
        st.emplace(i, std::lower_bound(c.begin(), c.end(), ((sa + i - 1) / i) * i - sa) - c.begin());
    auto res = 0ll;
    for (auto l = 1ll; !st.empty(); ) &#123;
        auto [r, v] = st.top();
        st.pop();
        if (l &gt; r)
            continue;
        if (v == n + 1)
            v = 0;
        res += (r - l + 1) * v;
        l = r + 1;
    &#125;
    std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;</code></pre>
</details>
<hr />
<h2 id="g---range-set-modifying-query">G - Range Set Modifying Query</h2>
<p><a target="_blank" rel="noopener" href="https://atcoder.jp/contests/abc430/tasks/abc430_g" class="uri">https://atcoder.jp/contests/abc430/tasks/abc430_g</a></p>
<ul>
<li><p>发现开 60 个线段树非常合理</p></li>
<li><p>接着发现是 beats 板子题。看似需要三只 log，其实只有两只。</p></li>
<li><p>参见 abc426，最近 abc 都喜欢 beats 板子题吗？</p></li>
</ul>

			</div>
			<hr class="dotted">
			<div class="post footer">
				<div id="hitokoto">
					<h3 id="hitokoto-title">
						言论
					</h3>
					<div id="hitokoto-content">
					</div>
					<div id="hitokoto-from">
					</div>
				</div>
				<div class="button flex">
					<div id="prev">
						
							<!-- 吐槽，为啥还需要加 / -->
							<a href="/20251029/">
								<i class="fas fa-angle-double-left" style="margin-right: 10px;"></i>
								学习笔记：CDQ 分治
							</a>
						
					</div>
					<div id="next">
						
							<a href="/20251023/">
								杂题选谈：图论思维题
								<i class="fas fa-angle-double-right" style="margin-left: 10px;"></i>
							</a>
						
					</div>
				</div>
				<div id="vcomments" class="text"></div>
<script>
	new Valine({
		el: '#vcomments',
		appId: 'OlmvQ0a2Zw7xo3no2bwabOzx-gzGzoHsz',
		appKey: 'TW6t8mFeGLmhPjWisvmllvvo',
		recordIP: true,
		enableQQ: true, 
		// [EDITED] 目前 Valine 的 QQ 自动获取昵称似乎不可用
		// 该问题在 v1.5.3 中已修复
		pageSize: 10,
		requiredFields:
			
				['nick']
			,
		placeholder: "The world is but a little place after all...\n能够根据邮箱获取你的 Gravatar 头像。昵称是必填项，长度需不低于 3。",
		avatar: 'identicon',
		avatar_cdn: 'https://cravatar.cn/avatar/',
		emojiCDN: 'https://xsc062.netlify.app/em/', 
		emojiMaps: {
			
				"微笑": "wx.gif",
			
				"龇牙": "cy.gif",
			
				"流泪": "ll.gif",
			
				"笑哭": "xk.gif",
			
				"流汗": "lh.gif",
			
				"擦汗": "ch.gif",
			
				"亲亲": "qq.gif",
			
				"色": "se.gif",
			
				"疑问": "yiw.gif",
			
				"发呆": "fd.gif",
			
				"晕": "yun.gif",
			
				"鼓掌": "gz.gif",
			
				"憨笑": "hanx.gif",
			
				"快哭了": "kk.gif",
			
				"得意": "dy.gif",
			
				"狂笑": "kx.gif",
			
				"害羞": "hx.gif",
			
				"妈妈生的": "dz.gif",
			
				"糗大了": "qd.gif",
			
				"吃瓜": "cg.gif",
			
				"睁眼": "zy.webp",
			
				"辣眼睛": "lyj.gif",
			
				"酸了": "nm.gif",
			
				"滚": "gun.webp",
			
				"惊恐": "jk.gif",
			
				"幽灵": "youl.gif",
			
				"无聊": "wul.gif",
			
				"吃": "eat.gif",
			
				"你很棒棒": "bb.gif",
			
				"赞": "qiang.gif",
			
				"踩": "ruo.gif",
			
				"握手": "wsh.gif",
			
				"发抖": "fad.gif",
			
				"挥手": "hsh.gif",
			
				"磕头": "kt.gif",
			
				"怄火": "oh.gif",
			
		},
		mathjax: true,
	})
</script>
			</div>
			<script>setHitokoto();</script>
		</div> 
	</div>
</div>
    <!-- 页脚开始 -->
<div id="footer" class="serif">
    Powered by
    <a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a>
    &
    <a href="/about-this-theme">
        iwll
    </a>
    <p style="margin-top: 5px;">
        2021 - 2025
    </p>
    <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/" id="CCTAG"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/big/by_nc_sa.svg"></a>
</div>
<!-- Valine 相关配置 -->
<script>
    const getValineDomTimer = setInterval(() => {
        // 不知道为什么 我从原博客 js 文件粘过来的参数是
        // "#valine .vcards .vcard"
        // DEBUG 了半天才定位到这个问题。。。
        const vcards =
            document.querySelectorAll('#valine, .vcards, .vcard');
        if (vcards.length > 0) {
            let author = 'XSC062';
            for (let vcard of vcards) {
                const vnick_dom = vcard.querySelector('.vhead .vnick');
                if (vnick_dom != null) {
                    const vnick = vnick_dom.innerHTML;
                    if (vnick === author) {
                        vnick_dom.innerHTML =
                        `${vnick} <span id="rootitem" class="code">root</span>`
                    }
                }
            }
        }
        else {
            clearInterval(getValineDomTimer);
        }
    }, 2000);
    SetActiveItem();
    setDetailsSummary();
    setTitleAnchor();
    setEmptyToc();
    setCodeClassName();
</script>


<!-- js -->
<!-- 搜索功能相关配置 -->

<script src="/js/search.js"></script>


<script src="/js/local-search.js"></script>

</script>
<!-- prism 相关配置 -->
<script type="text/javascript" src="/js/prism.js" defer></script>
<!-- 代码块复制功能 -->
<script type="text/javascript" src="/js/clipboard.min.js"></script>
<script type="text/javascript" src="/js/clipboard-use.js"></script>
<!-- 页脚结束 -->
</body>
</html>