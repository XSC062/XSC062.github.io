<!DOCTYPE html>
<html>
<head>
    <!-- 网站图标 -->
<link rel="icon" type="image/png" sizes="32x32" href="/images/icon.svg">
<!-- 其他图标支持 -->
<link rel="stylesheet" href="/css/facss/fa-brands.min.css">
<link rel="stylesheet" href="/css/facss/fa-regular.min.css">
<link rel="stylesheet" href="/css/facss/fa-solid.min.css">
<link rel="stylesheet" href="/css/facss/fontawesome.min.css">
<link rel="stylesheet" href="/css/facss/fontawesome-all.css">
<link href="https://use.fontawesome.com/releases/v5.0.4/css/all.css" rel="stylesheet">
<!-- 网站标题 -->
<title>
	
		杂题 -
	
	XSC062 的博客
</title>
<!-- js 引入 -->
<script>
const searchPath = "/search.xml"
</script>

<script src="/js/afterloaded.js"></script>


<script src="/js/jQuery.js"></script>

<!-- 载入 Valine -->

<script src="/js/Valine.min.js"></script>

<!-- css 引入 -->

<link rel="stylesheet" href="/css/layout.css">


<link rel="stylesheet" href="/css/prcss/prism.css">



<!-- rss -->
<link rel="alternate" type="application/rss+xml" title="" href="https://xsc062.netlify.app/rss.xml" />
<link rel="alternate" type="application/atom+xml" title="" href="https://xsc062.netlify.app/atom.xml" />
<link rel="alternate" type="application/json" title="" href="https://xsc062.netlify.app/feed.json" />

<meta charset="utf-8"> 
<meta name="generator" content="Hexo 7.2.0"></head>
<body class="line-numbers match-braces no-brace-select rainbow-braces">
	
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
          tex2jax: {
            inlineMath: [ ['$','$'], ["\\(","\\)"] ],
            processEscapes: true
          }
        });
      </script>
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
            tex2jax: {
              skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
            }
          });
      </script>
    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
              var all = MathJax.Hub.getAllJax(), i;
              for(i=0; i < all.length; i += 1) {
                  all[i].SourceElement().parentNode.className += ' has-jax';
              }
          });
      </script>
    <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS_CHTML"></script>

	<!-- 搜索 -->
<script>
	function closeSearchBox() {
		$("#search-bg").css("transition", "null"); 
		$("#search-bg").css("z-index", "-1"); 
		$("#search-bg").css("opacity", "0%");
		return;
	}
</script>
<div id="search-bg">
	<div id="search-box">
		<button id="close-button" onclick="closeSearchBox()">
			<i class="fas fa-times"></i>
		</button>
		<input type="text" id="search-input" placeholder="Type to search...">
		<div id="search-results">
			<div id="emptyInput">
				<p>键入以搜索…</p>
				<p><i>匹配算法</i>：把输入按空格拆分，单独<strong>匹配</strong>每一段输入（不区分大小写，仅匹配文章文本内容），输出取或后的结果。</p>
				<p>模糊搜索似乎很难搞，目前没有相关打算。</p>
			</div>
		</div>
	</div>
</div>
<!-- 顶栏整体导航菜单 -->
<div class="ui top menu">
	<!-- 左对齐 logo -->
	<a class="logo" href="/">
		<img width="25px" height="25px" style="border: solid transparent 2.5px" src="/images/icon.svg"></img>
		<div id="bartitle" class="text">
			XSC062 的博客
		</div>
	</a>
	<!-- 右对齐部分导航 -->
	<div id="rightali" class="serif">
		<a class="item" id="Search" type="button">
			<i class="btn text-muted fa fa-search" id="search-icon" disabled></i>
		</a>
		<a class="item" id="Home" href="/">
			Home
		</a>
		<a class="item" id="Arch" href="/archives">
			Archives
		</a>
		<!-- <a class="item" id="Cate" href="/categories">
			Categories
		</a> -->
		<a class="item" id="Tags" href="/tags">
			Tags
		</a>
		<a class="item" id="Frie" href="/friends">
			Friends
		</a>
		<a class="item" id="Abou" href="/about">
			About
		</a>
	</div>
</div>
    
<link rel="stylesheet" href="/css/post.css">


<script src="/js/post.js"></script>


<div class="main">
	<div id="sidebar" class="text">
		<aside id="toc">
			<span id="toctitle">
				<i class="fas fa-list"></i>
				目录
			</span>
			<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#g---set-list"><span class="toc-text">G - Set list</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#b---slime-swap"><span class="toc-text">B - Slime Swap</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#d---lis-lds"><span class="toc-text">D - LIS ∩ LDS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bubble-sort"><span class="toc-text">#3761. Bubble Sort</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#f.-bubble-sort"><span class="toc-text">F. Bubble Sort</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#e.-limited-edition-shop"><span class="toc-text">E. Limited Edition Shop</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#a.-%E5%B0%8F%E7%8C%AA%E7%9B%96%E6%88%BF%E5%AD%90"><span class="toc-text">A. 小猪盖房子</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#b.-%E6%8D%A2%E4%B9%98%E6%97%85%E8%A1%8C"><span class="toc-text">B. 换乘旅行</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#c.-%E4%BC%98%E7%BE%8E%E7%9A%84%E8%A1%97%E6%99%AF"><span class="toc-text">C. 优美的街景</span></a></li></ol>
		</aside>
	</div>
	<div class="ui post container">
		<div class="ui text container">
			<span id="postcon">
				<span id="postinfo">
					<div class="ui post title serif">
						<div id="fortitle" data-content="杂题">
							杂题
						</div>
						<div class="ui title background">
						</div>
					</div>
					<span id="date">
						<i class="fas fa-calendar-alt" style="margin-right: 4px;"></i>
						2025-09-22
					</span>
				</span>
			</span>
			<div id="posttags" class="dotted border">
				
					
						<a href="/tags/DP/" class="citem">DP</a>
					
				
			</div>
			<!-- 本来用的是 fromNow 然后字符串判断，没想到可以直接调用 moment() -->
			
			<div id="content">
				<p>最近的几场 abc, arc, cf, 模拟赛题</p>
<span id="more"></span>
<hr />
<h2 id="g---set-list">G - Set list</h2>
<p><a target="_blank" rel="noopener" href="https://atcoder.jp/contests/abc424/tasks/abc424_g" class="uri">https://atcoder.jp/contests/abc424/tasks/abc424_g</a></p>
<hr />
<h2 id="b---slime-swap">B - Slime Swap</h2>
<p><a target="_blank" rel="noopener" href="https://atcoder.jp/contests/arc206/tasks/arc206_b" class="uri">https://atcoder.jp/contests/arc206/tasks/arc206_b</a></p>
<hr />
<h2 id="d---lis-lds">D - LIS ∩ LDS</h2>
<p><a target="_blank" rel="noopener" href="https://atcoder.jp/contests/arc206/tasks/arc206_d" class="uri">https://atcoder.jp/contests/arc206/tasks/arc206_d</a></p>
<hr />
<h2 id="bubble-sort">#3761. Bubble Sort</h2>
<p><a target="_blank" rel="noopener" href="http://poj.org/problem?id=3761" class="uri">http://poj.org/problem?id=3761</a></p>
<hr />
<h2 id="f.-bubble-sort">F. Bubble Sort</h2>
<p><a target="_blank" rel="noopener" href="https://codeforces.com/contest/2146/problem/F" class="uri">https://codeforces.com/contest/2146/problem/F</a></p>
<hr />
<h2 id="e.-limited-edition-shop">E. Limited Edition Shop</h2>
<p><a target="_blank" rel="noopener" href="https://codeforces.com/contest/2151/problem/E" class="uri">https://codeforces.com/contest/2151/problem/E</a></p>
<ul>
<li>构造几个 <span class="math inline">\(n=2,3\)</span> 的例子手玩一下，会发现对于 <span class="math inline">\(a,b\)</span> 两个元素，如果在 A 里的相对顺序是 ab，在 B 里的相对顺序是 ba，那么要选 b 就必须选 a。</li>
<li>那么会想到把 A 变成 <span class="math inline">\(1\sim n\)</span>，那么对于 B 中的一个元素，如果其后方有更小的元素，那么必须选了它才能选这个数。</li>
<li>考虑在 B 中 DP 最后选出来的集合，那么对于当前的 <span class="math inline">\(x\)</span>，<strong>若不选，则不允许『已选集合』中存在 <span class="math inline">\(&gt;x\)</span> 的数。</strong></li>
<li><p>故令 <span class="math inline">\(f_{i,j}\)</span> 表示 DP 到 <span class="math inline">\(i\)</span>，当前已选集合最大值为 <span class="math inline">\(j\)</span> 的最大集合大小，那么有：</p>
<p><span class="math display">\[
f_{i,B_i}\gets f_{i-1,j}+v, j&lt;B_i\\
f_{i,j}\gets f_{i-1, j}+v, j &gt; B_i\\
f_{i,j}\gets f_{i-1,j}, j &lt; B_i
\]</span></p></li>
<li><p>显然可以线段树优化转移</p></li>
</ul>
<details>
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;
const int maxn = 2e5 + 5;
const long long inf = 1e18;
struct &#123;
    int l, r;
    long long u, d;
&#125; t[maxn &lt;&lt; 2];
#define lt (p &lt;&lt; 1)
#define rt (lt | 1)
void pushval(int p, long long v) &#123;
    t[p].d += v, t[p].u += v;
    return;
&#125;
void pushdown(int p) &#123;
    pushval(lt, t[p].d), pushval(rt, t[p].d);
    t[p].d = 0ll;
    return;
&#125;
void pushup(int p) &#123;
    t[p].u = std::max(t[lt].u, t[rt].u);
    return;
&#125;
void bld(int p, int l, int r) &#123;
    t[p].l = l, t[p].r = r;
    t[p].u = -inf, t[p].d = 0ll;
    if (l == r)
        return;
    int mid = (t[p].l + t[p].r) &gt;&gt; 1;
    bld(lt, l, mid), bld(rt, mid + 1, r);
    return;
&#125;
void upd(int p, int x, long long v) &#123;
    t[p].u = std::max(t[p].u, v);
    if (t[p].l == t[p].r)
        return;
    pushdown(p);
    int mid = (t[p].l + t[p].r) &gt;&gt; 1;
    if (x &lt;= mid)
        upd(lt, x, v);
    else
        upd(rt, x, v);
    return;
&#125;
void add(int p, int l, int r, long long v) &#123;
    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r) &#123;
        pushval(p, v);
        return;
    &#125;
    pushdown(p);
    int mid = (t[p].l + t[p].r) &gt;&gt; 1;
    if (l &lt;= mid)
        add(lt, l, r, v);
    if (r &gt; mid)
        add(rt, l, r, v);
    pushup(p);
    return;
&#125;
long long ask(int p, int l, int r) &#123;
    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r)
        return t[p].u;
    pushdown(p);
    long long res = -inf;
    int mid = (t[p].l + t[p].r) &gt;&gt; 1;
    if (l &lt;= mid)
        res = ask(lt, l, r);
    if (r &gt; mid)
        res = std::max(res, ask(rt, l, r));
    return res;
&#125;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int T;
    for (std::cin &gt;&gt; T; T--; ) &#123;
        int n;
        std::cin &gt;&gt; n;
        std::vector&lt;int&gt; w(n + 1), k(n + 1), a(n + 1), b(n + 1), tab(n + 1);
        for (int i = 1; i &lt;= n; ++i)
            std::cin &gt;&gt; w[i];
        for (int i = 1; i &lt;= n; ++i)
            std::cin &gt;&gt; a[i], tab[a[i]] = i;
        for (int i = 1; i &lt;= n; ++i)
            k[i] = w[a[i]];
        for (int i = 1; i &lt;= n; ++i)
            std::cin &gt;&gt; b[i], b[i] = tab[b[i]];
        bld(1, 0, n), upd(1, 0, 0);
        for (int i = 1; i &lt;= n; ++i) &#123;
            if (b[i] != n)
                add(1, b[i] + 1, n, k[b[i]]);
            upd(1, b[i], ask(1, 0, b[i] - 1) + k[b[i]]);
        &#125;
        std::cout &lt;&lt; t[1].u &lt;&lt; &#39;\n&#39;;
    &#125;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;</code></pre>
</details>
<hr />
<h2 id="a.-小猪盖房子">A. 小猪盖房子</h2>
<p><a target="_blank" rel="noopener" href="https://www.becoder.com.cn/problem/51898" class="uri">https://www.becoder.com.cn/problem/51898</a></p>
<blockquote>
<p>给定一个 <span class="math inline">\(n\times m\)</span> 的 01 矩阵，每一行有 2 个 1 或没有 1。现需选择两个<strong>相邻的</strong>行区间，并为<strong>范围内的空行</strong>选择两个位置改为 1，使得这两个区间是全等的。</p>
<p>求可能的方案。当空行的涂色方式不同或选择范围不同看作不同的方案。对 <span class="math inline">\(998244353\)</span> 取模。</p>
<p><span class="math inline">\(n,m\le 5000\)</span>。</p>
</blockquote>
<ul>
<li>第一反应是枚举分界线 + 上端点，发现没有办法做：当上端点移动的时候，下部矩形会整体平移。</li>
<li><strong>进一步考虑导致这个问题的原因</strong>，感受到一个因素是长度在变。</li>
<li>故固定长度枚举，前缀和统计 <span class="math inline">\(\dfrac {m(m-1)}2\)</span> 的幂次即可。</li>
</ul>
<details>
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;
const int mod = 998244353;
int main() &#123;
    std::freopen(&quot;piggy.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;piggy.out&quot;, &quot;w&quot;, stdout);
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
    const auto stime = std::chrono::steady_clock::now();
    int n, m;
    std::cin &gt;&gt; n &gt;&gt; m;
    std::vector&lt;std::array&lt;int, 2&gt; &gt; a(n + 1);
    std::vector&lt;long long&gt; ps(n + 1);
    const int s = m * (m - 1) / 2;
    ps[0] = 1ll;
    for (int i = 1; i &lt;= n; ++i) &#123;
        std::cin &gt;&gt; a[i][0] &gt;&gt; a[i][1];
        ps[i] = ps[i - 1] * s % mod;
    &#125;
    auto res = 0ll;
    for (int i = 1; i &lt;= n / 2; ++i) &#123;
        std::vector&lt;int&gt; cnt0(n + 1), cnts(n + 1);
        for (int u = 1; u &lt;= n - i; ++u) &#123;
            int d = u + i;
            if (!a[u][0] &amp;&amp; !a[d][0])
                cnts[u] = 1;
            else if (a[u][0] &amp;&amp; a[d][0] &amp;&amp; (a[u][0] != a[d][0] || a[u][1] != a[d][1]))
                cnt0[u] = 1;
            cnts[u] += cnts[u - 1], cnt0[u] += cnt0[u - 1];
        &#125;
        for (int u = 1; u &lt;= n - 2 * i + 1; ++u) &#123;
            int ss = cnts[u + i - 1] - cnts[u - 1], s0 = cnt0[u + i - 1] - cnt0[u - 1];
            if (!s0)
                (res += ps[ss] % mod) %= mod;
        &#125;
    &#125;
    std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
    return 0;
&#125;</code></pre>
</details>
<hr />
<h2 id="b.-换乘旅行">B. 换乘旅行</h2>
<p><a target="_blank" rel="noopener" href="https://www.becoder.com.cn/problem/51900" class="uri">https://www.becoder.com.cn/problem/51900</a></p>
<ul>
<li>手玩可以发现『环』在题目中是一个很重要的东西</li>
<li>重要性质：考虑一个环第一次被访问的点，一定会从这个点出发把这个环访问一遍，反证法易证。</li>
<li><p>故可以把每个环给『删除』。可以用下图概括所有情况。</p>
<p><img src="image.png" /></p>
<p>假设当前以 <span class="math inline">\(s\)</span> 为起点，终点为 <span class="math inline">\(t\)</span>，且之前已经在以 <span class="math inline">\(s&#39;\)</span> 为起点时访问过了一部分路径上的点。</p>
<p>那么此时 <span class="math inline">\(m\to t\)</span> 是有答案的，而 <span class="math inline">\(s\to m\)</span> 都可以继承 <span class="math inline">\(m\)</span> 的答案。</p></li>
</ul>
<details>
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::freopen(&quot;travel.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;travel.out&quot;, &quot;w&quot;, stdout);
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n;
    std::cin &gt;&gt; n;
    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);
    std::vector&lt;std::vector&lt;int&gt;::iterator&gt; it(n + 1);
    for (int i = 1, k; i &lt;= n; ++i) &#123;
        std::cin &gt;&gt; k;
        for (int x; k--; )
            std::cin &gt;&gt; x, g[i].push_back(x);
        it[i] = g[i].begin();
    &#125;
    std::vector&lt;int&gt; res(n + 1), inq(n + 1);
    for (int i = 1; i &lt;= n; ++i)
        if (!res[i]) &#123;
            std::stack&lt;int&gt; st;
            for (int x = i; ; ) &#123;
                if (it[x] == g[x].end() || res[x]) &#123;
                    if (!res[x])
                        res[x] = x;
                    res[i] = res[x];
                    for (; !st.empty(); st.pop())
                        res[st.top()] = res[x], inq[st.top()] = 0;
                    break;
                &#125;
                st.push(x), inq[x] = 1, x = *it[x];
                if (inq[x])
                    for (int p = -1; p != x; ) &#123;
                        p = st.top(), st.pop();
                        inq[p] = 0, ++it[p];
                    &#125;
            &#125;
        &#125;
    for (int i = 1; i &lt;= n; ++i)
        std::cout &lt;&lt; res[i] &lt;&lt; &#39;\n&#39;;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;</code></pre>
</details>
<hr />
<h2 id="c.-优美的街景">C. 优美的街景</h2>
<p>no link</p>
<blockquote>
<p>给定 <span class="math inline">\(n\)</span> 的排列 <span class="math inline">\(a_{1\cdots n}\)</span>，现定义『优美子段』<span class="math inline">\([l,r]\)</span>：存在 <span class="math inline">\(l\le t&lt;r\)</span>，使得 <span class="math inline">\(\max\{a_{l\sim t}\}&lt;\min\{a_{t+1\sim r}\}\)</span>。</p>
<p>求出该排列『优美子段』的个数，<span class="math inline">\(n\le 3\times 10^5\)</span>。</p>
</blockquote>
<ul>
<li><p>由经典 trick 出发，一个想法是从小到大枚举分解值 <span class="math inline">\(v\)</span>，并把 <span class="math inline">\(\le v\)</span> 的值涂成白色，剩下的涂成黑色。</p>
<p>那么此时一个前白后黑的子段是优美的。</p></li>
<li><p>令值为 <span class="math inline">\(v\)</span> 的元素必须参与子段组成。枚举 <span class="math inline">\(v\)</span> 时，序列每个点颜色已知，即 <span class="math inline">\(v\)</span> 所在的优美子段被包含于 <span class="math inline">\(v\)</span> 所在的白黑子段中。</p>
<p>求出该子段，则包含 <span class="math inline">\(v\)</span> 的优美子段，左右端点各有范围，且不会相互影响。</p></li>
<li><p>此时不可直接计数：一个优美子段会被其中所有合法分割点统计。故做一个 <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P5490">亚特兰蒂斯</a> 即可。</p>
<p>如果像我一样没有甚区间问题经验，可以用 0 覆盖次数这个 trick 来反向求。<del>因而被群嘲了</del></p></li>
</ul>
<details>
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;
const int maxn = 3e5 + 5;
struct &#123;
    int l, r, mn, u, d;
&#125; t[maxn &lt;&lt; 2];
#define lt (p &lt;&lt; 1)
#define rt (lt | 1)
void bld(int p, int l, int r) &#123;
    t[p].l = l, t[p].r = r;
    t[p].u = r - l + 1;
    if (l == r)
        return;
    int mid = (l + r) &gt;&gt; 1;
    bld(lt, l, mid), bld(rt, mid + 1, r);
    return;
&#125;
void pushval(int p, int v) &#123;
    t[p].d += v, t[p].mn += v;
    return;
&#125;
void pushdown(int p) &#123;
    pushval(lt, t[p].d), pushval(rt, t[p].d);
    t[p].d = 0;
    return;
&#125;
void pushup(int p) &#123;
    t[p].u = 0;
    t[p].mn = std::min(t[lt].mn, t[rt].mn);
    if (t[lt].mn == t[p].mn)
        t[p].u = t[lt].u;
    if (t[rt].mn == t[p].mn)
        t[p].u += t[rt].u;
    return;
&#125;
void add(int p, int l, int r, int v) &#123;
    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r) &#123;
        pushval(p, v);
        return;
    &#125;
    pushdown(p);
    int mid = (t[p].l + t[p].r) &gt;&gt; 1;
    if (l &lt;= mid)
        add(lt, l, r, v);
    if (r &gt; mid)
        add(rt, l, r, v);
    pushup(p);
    return;
&#125;
#undef lt
#undef rt
int main() &#123;
    std::freopen(&quot;street.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;street.out&quot;, &quot;w&quot;, stdout);
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
    const auto stime = std::chrono::steady_clock::now();
    int n;
    std::cin &gt;&gt; n;
    std::vector&lt;int&gt; a(n + 1), tab(n + 1);
    std::vector&lt;std::vector&lt;int&gt; &gt; mn(20, std::vector&lt;int&gt; (n + 1)), mx(20, std::vector&lt;int&gt; (n + 1));
    for (int i = 1; i &lt;= n; ++i) &#123;
        std::cin &gt;&gt; a[i];
        tab[a[i]] = i, mn[0][i] = mx[0][i] = a[i];
    &#125;
    for (int j = 1; (1 &lt;&lt; j) &lt;= n; ++j)
        for (int i = 1; i + (1 &lt;&lt; j) - 1 &lt;= n; ++i) &#123;
            mn[j][i] = std::min(mn[j - 1][i], mn[j - 1][i + (1 &lt;&lt; (j - 1))]);
            mx[j][i] = std::max(mx[j - 1][i], mx[j - 1][i + (1 &lt;&lt; (j - 1))]);
        &#125;
    auto askmn = [&amp;](int l, int r) &#123;
        int k = std::__lg(r - l + 1);
        return std::min(mn[k][l], mn[k][r - (1 &lt;&lt; k) + 1]);
    &#125;;
    auto askmx = [&amp;](int l, int r) &#123;
        int k = std::__lg(r - l + 1);
        return std::max(mx[k][l], mx[k][r - (1 &lt;&lt; k) + 1]);
    &#125;;
    auto res = 0ll;
    std::vector&lt;std::vector&lt;std::tuple&lt;int, int, int&gt; &gt; &gt; t(n + 1);
    auto ask1 = [&amp;](int x, int v) &#123; // 找到 x 左侧最后一个 &lt;= v 的
        int res = x;
        for (int l = 1, r = x, mid; l &lt;= r; ) &#123;
            mid = (l + r) &gt;&gt; 1;
            if (askmx(mid, x) &lt;= v)
                r = mid - 1, res = mid;
            else
                l = mid + 1;
        &#125;
        return res;
    &#125;;
    auto ask2 = [&amp;](int x, int v) &#123; // 找到 x 右侧第一个 &gt; v 的
        int res = -1;
        for (int l = x + 1, r = n, mid; l &lt;= r; ) &#123;
            mid = (l + r) &gt;&gt; 1;
            if (askmx(x, mid) &gt; v)
                r = mid - 1, res = mid;
            else
                l = mid + 1;
        &#125;
        return res;
    &#125;;
    auto ask3 = [&amp;](int x, int v) &#123; // 找到 x 右侧最后一个 &gt; v 的
        int res = x;
        for (int l = x, r = n, mid; l &lt;= r; ) &#123;
            mid = (l + r) &gt;&gt; 1;
            if (askmn(x, mid) &gt; v)
                l = mid + 1, res = mid;
            else
                r = mid - 1;
        &#125;
        return res;
    &#125;;
    for (int i = 1; i &lt;= n; ++i) &#123;
        int cr = ask1(tab[i], i), tl = ask2(tab[i], i);
        if (tl != -1) &#123;
            int tr = ask3(tl, i);
            t[cr].emplace_back(1, tl, tr);
            if (tab[i] != n)
                t[tab[i] + 1].emplace_back(-1, tl, tr);
        &#125;
    &#125;
    bld(1, 0, n);
    std::vector&lt;int&gt; cnt(n + 1);
    for (int i = 1; i &lt;= n; ++i) &#123;
        std::sort(t[i].begin(), t[i].end(), std::greater&lt;std::tuple&lt;int, int, int&gt; &gt; ());
        for (auto [k, l, r] : t[i])
            add(1, l, r, k);
        res += n + 1 - ::t[1].u;
    &#125;
    std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
    return 0;
&#125;</code></pre>
</details>

			</div>
			<hr class="dotted">
			<div class="post footer">
				<div id="hitokoto">
					<h3 id="hitokoto-title">
						言论
					</h3>
					<div id="hitokoto-content">
					</div>
					<div id="hitokoto-from">
					</div>
				</div>
				<div class="button flex">
					<div id="prev">
						
							<!-- 吐槽，为啥还需要加 / -->
							<a href="/20250924/">
								<i class="fas fa-angle-double-left" style="margin-right: 10px;"></i>
								最短路练习
							</a>
						
					</div>
					<div id="next">
						
							<a href="/20250921/">
								线段树杂题
								<i class="fas fa-angle-double-right" style="margin-left: 10px;"></i>
							</a>
						
					</div>
				</div>
				<div id="vcomments" class="text"></div>
<script>
	new Valine({
		el: '#vcomments',
		appId: 'OlmvQ0a2Zw7xo3no2bwabOzx-gzGzoHsz',
		appKey: 'TW6t8mFeGLmhPjWisvmllvvo',
		recordIP: true,
		enableQQ: true, 
		// [EDITED] 目前 Valine 的 QQ 自动获取昵称似乎不可用
		// 该问题在 v1.5.3 中已修复
		pageSize: 10,
		requiredFields:
			
				['nick']
			,
		placeholder: "The world is but a little place after all...\n能够根据邮箱获取你的 Gravatar 头像。昵称是必填项，长度需不低于 3。",
		avatar: 'identicon',
		avatar_cdn: 'https://cravatar.cn/avatar/',
		emojiCDN: 'https://xsc062.netlify.app/em/', 
		emojiMaps: {
			
				"微笑": "wx.gif",
			
				"龇牙": "cy.gif",
			
				"流泪": "ll.gif",
			
				"笑哭": "xk.gif",
			
				"流汗": "lh.gif",
			
				"擦汗": "ch.gif",
			
				"亲亲": "qq.gif",
			
				"色": "se.gif",
			
				"疑问": "yiw.gif",
			
				"发呆": "fd.gif",
			
				"晕": "yun.gif",
			
				"鼓掌": "gz.gif",
			
				"憨笑": "hanx.gif",
			
				"快哭了": "kk.gif",
			
				"得意": "dy.gif",
			
				"狂笑": "kx.gif",
			
				"害羞": "hx.gif",
			
				"妈妈生的": "dz.gif",
			
				"糗大了": "qd.gif",
			
				"吃瓜": "cg.gif",
			
				"睁眼": "zy.webp",
			
				"辣眼睛": "lyj.gif",
			
				"酸了": "nm.gif",
			
				"滚": "gun.webp",
			
				"惊恐": "jk.gif",
			
				"幽灵": "youl.gif",
			
				"无聊": "wul.gif",
			
				"吃": "eat.gif",
			
				"你很棒棒": "bb.gif",
			
				"赞": "qiang.gif",
			
				"踩": "ruo.gif",
			
				"握手": "wsh.gif",
			
				"发抖": "fad.gif",
			
				"挥手": "hsh.gif",
			
				"磕头": "kt.gif",
			
				"怄火": "oh.gif",
			
		},
	})
</script>
			</div>
			<script>setHitokoto();</script>
		</div> 
	</div>
</div>
    <!-- 页脚开始 -->
<div id="footer" class="serif">
    Powered by
    <a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a>
    &
    <a href="/about-this-theme">
        iwll
    </a>
    <p style="margin-top: 5px;">
        2021 - 2025
    </p>
    <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/" id="CCTAG"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/big/by_nc_sa.svg"></a>
</div>
<!-- Valine 相关配置 -->
<script>
    const getValineDomTimer = setInterval(() => {
        // 不知道为什么 我从原博客 js 文件粘过来的参数是
        // "#valine .vcards .vcard"
        // DEBUG 了半天才定位到这个问题。。。
        const vcards =
            document.querySelectorAll('#valine, .vcards, .vcard');
        if (vcards.length > 0) {
            let author = 'XSC062';
            for (let vcard of vcards) {
                const vnick_dom = vcard.querySelector('.vhead .vnick');
                if (vnick_dom != null) {
                    const vnick = vnick_dom.innerHTML;
                    if (vnick === author) {
                        vnick_dom.innerHTML =
                        `${vnick} <span id="rootitem" class="code">root</span>`
                    }
                }
            }
        }
        else {
            clearInterval(getValineDomTimer);
        }
    }, 2000);
    SetActiveItem();
    setDetailsSummary();
    setTitleAnchor();
    setEmptyToc();
    setCodeClassName();
</script>


<!-- js -->
<!-- 搜索功能相关配置 -->

<script src="/js/search.js"></script>


<script src="/js/local-search.js"></script>

</script>
<!-- prism 相关配置 -->
<script type="text/javascript" src="/js/prism.js" defer></script>
<!-- 代码块复制功能 -->
<script type="text/javascript" src="/js/clipboard.min.js"></script>
<script type="text/javascript" src="/js/clipboard-use.js"></script>
<!-- 页脚结束 -->
</body>
</html>