<!DOCTYPE html>
<html>
<head>
    <!-- 网站图标 -->
<link rel="icon" type="image/png" sizes="32x32" href="/images/icon.svg">
<!-- 其他图标支持 -->
<link rel="stylesheet" href="/css/facss/fa-brands.min.css">
<link rel="stylesheet" href="/css/facss/fa-regular.min.css">
<link rel="stylesheet" href="/css/facss/fa-solid.min.css">
<link rel="stylesheet" href="/css/facss/fontawesome.min.css">
<link rel="stylesheet" href="/css/facss/fontawesome-all.css">
<link href="https://use.fontawesome.com/releases/v5.0.4/css/all.css" rel="stylesheet">
<!-- 网站标题 -->
<title>
	
		杂题选谈：生成树 III -
	
	XSC062 的博客
</title>
<!-- js 引入 -->
<script>
const searchPath = "/search.xml"
</script>

<script src="/js/afterloaded.js"></script>


<script src="/js/jQuery.js"></script>

<!-- 载入 Valine -->

<script src="/js/Valine.min.js"></script>

<!-- css 引入 -->

<link rel="stylesheet" href="/css/layout.css">


<link rel="stylesheet" href="/css/prcss/prism.css">



<!-- rss -->
<link rel="alternate" type="application/rss+xml" title="" href="https://xsc062.netlify.app/rss.xml" />
<link rel="alternate" type="application/atom+xml" title="" href="https://xsc062.netlify.app/atom.xml" />
<link rel="alternate" type="application/json" title="" href="https://xsc062.netlify.app/feed.json" />

<meta charset="utf-8"> 
    
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
          tex2jax: {
            inlineMath: [ ['$','$'], ["\\(","\\)"] ],
            processEscapes: true
          }
        });
      </script>
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
            tex2jax: {
              skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
            }
          });
      </script>
    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
              var all = MathJax.Hub.getAllJax(), i;
              for(i=0; i < all.length; i += 1) {
                  all[i].SourceElement().parentNode.className += ' has-jax';
              }
          });
      </script>
    <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS_CHTML"></script>

<meta name="generator" content="Hexo 7.2.0"></head>
<body class="line-numbers match-braces no-brace-select rainbow-braces">
	<!-- 搜索 -->
<script>
	function closeSearchBox() {
		$("#search-bg").css("transition", "null"); 
		$("#search-bg").css("z-index", "-1"); 
		$("#search-bg").css("opacity", "0%");
		return;
	}
</script>
<div id="search-bg">
	<div id="search-box">
		<button id="close-button" onclick="closeSearchBox()">
			<i class="fas fa-times"></i>
		</button>
		<input type="text" id="search-input" placeholder="Type to search...">
		<div id="search-results">
			<div id="emptyInput">
				<p>键入以搜索…</p>
				<p><i>匹配算法</i>：把输入按空格拆分，单独<strong>匹配</strong>每一段输入（不区分大小写，仅匹配文章文本内容），输出取或后的结果。</p>
				<p>模糊搜索似乎很难搞，目前没有相关打算。</p>
			</div>
		</div>
	</div>
</div>
<!-- 顶栏整体导航菜单 -->
<div class="ui top menu">
	<!-- 左对齐 logo -->
	<a class="logo" href="/">
		<img width="25px" height="25px" style="border: solid transparent 2.5px" src="/images/icon.svg"></img>
		<div id="bartitle" class="text">
			XSC062 的博客
		</div>
	</a>
	<!-- 右对齐部分导航 -->
	<div id="rightali" class="serif">
		<a class="item" id="Search" type="button">
			<i class="btn text-muted fa fa-search" id="search-icon" disabled></i>
		</a>
		<a class="item" id="Home" href="/">
			Home
		</a>
		<a class="item" id="Arch" href="/archives">
			Archives
		</a>
		<!-- <a class="item" id="Cate" href="/categories">
			Categories
		</a> -->
		<a class="item" id="Tags" href="/tags">
			Tags
		</a>
		<a class="item" id="Frie" href="/friends">
			Friends
		</a>
		<a class="item" id="Abou" href="/about">
			About
		</a>
	</div>
</div>
    
<link rel="stylesheet" href="/css/post.css">


<script src="/js/post.js"></script>


<div class="main">
	<div id="sidebar" class="text">
		<aside id="toc">
			<span id="toctitle">
				<i class="fas fa-list"></i>
				目录
			</span>
			<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#boruvka"><span class="toc-text">Boruvka</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#a---jumping-around"><span class="toc-text">A - Jumping Around</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#b---parametric-mst"><span class="toc-text">B - Parametric MST</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#c---star-mst"><span class="toc-text">C - Star MST</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#d---smooth-sailing-hard-version"><span class="toc-text">D - Smooth Sailing (Hard Version)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#e---turtle-and-intersected-segments"><span class="toc-text">E - Turtle and Intersected Segments</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#f---digital-village-extreme-version"><span class="toc-text">F - Digital Village (Extreme Version)</span></a></li></ol>
		</aside>
	</div>
	<div class="ui post container">
		<div class="ui text container">
			<span id="postcon">
				<span id="postinfo">
					<div class="ui post title serif">
						<div id="fortitle" data-content="杂题选谈：生成树 III">
							杂题选谈：生成树 III
						</div>
						<div class="ui title background">
						</div>
					</div>
					<span id="date">
						<i class="fas fa-calendar-alt" style="margin-right: 4px;"></i>
						2025-10-13
					</span>
				</span>
			</span>
			<div id="posttags" class="dotted border">
				
					
						<a href="/tags/最小生成树/" class="citem">最小生成树</a>
					
						<a href="/tags/Kruskal-重构树/" class="citem">Kruskal 重构树</a>
					
				
			</div>
			<!-- 本来用的是 fromNow 然后字符串判断，没想到可以直接调用 moment() -->
			
			<div id="content">
				<p>mst，以及 mst related</p>
<span id="more"></span>
<hr />
<h2 id="boruvka">Boruvka</h2>
<ul>
<li>用途：<span class="math inline">\(O(m\log n)\)</span> 求 mst。</li>
<li><p>过程：</p>
<ul>
<li>考虑和 Kruskal、Prim 类似的孤立点 <span class="math inline">\(\to\)</span> 加边 <span class="math inline">\(\to\)</span> 树。</li>
<li>每一轮算法，对于当前的每个连通块，找到其连向其它连通块的边中最小的一条，并在这一轮后加入边集（用并查集维护连通块合并）。</li>
<li>重复执行该算法，最终找到 mst。</li>
</ul>
<figure>
<img src="mst-1.apng" alt="图源 OI Wiki">
<figcaption>
图源 OI Wiki
</figcaption>
</figure></li>
<li>复杂度：每一轮中，每个连通块都会被合并一次，故一轮之后现存连通块数量最坏情况下变为原来的一半。也即共执行 <span class="math inline">\(\log n\)</span> 轮。复杂度 <span class="math inline">\(O(m\log n)\)</span>。</li>
<li><p>优势：对于<strong>特殊边权</strong>的完全图 / 稠密图，边权并不由输入直接给定，而是由顶点计算得到，此时若可以依据性质直接找到连通块的最小边，则复杂度降低至 <span class="math inline">\(O(n\log n)\)</span> 之类非常优秀的级别（注意并查集的 log 和 Boruvka 本身的 log 是平行的）。</p>
<p>『依据性质找到最小的边』的一个 Bonus：见 KDT + Boruvka 做法的 <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P6362">平面欧几里得最小生成树</a>。</p></li>
</ul>
<hr />
<h2 id="a---jumping-around">A - Jumping Around</h2>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/CF1550F" class="uri">https://www.luogu.com.cn/problem/CF1550F</a></p>
<ul>
<li>本题就是『特殊边权完全图』的体现。定义任意两个点之间的边权为两个点相互跳需要的最小的 <span class="math inline">\(k=||x_0-x_1|-d|\)</span>，那么只需求瓶颈路。</li>
<li><p>做 Boruvka 即可。考虑怎么求某个连通块的最小边，预处理出每个位置（包括空位）前 / 后第一个和自己颜色不同的非空位，每次 check <span class="math inline">\(i\pm d\)</span>：</p>
<ul>
<li>若该位置存在和当前位置不同颜色的点：连边。</li>
<li>否则，若该位置和当前位置颜色相同：转到刚刚求出的前驱、后继，选更小者连边。</li>
<li>否则该位为空。前驱、后继则转化为上面两种情况。</li>
</ul></li>
<li><p>和双指针做法不同，似乎并不支持离散化，只能做到 <span class="math inline">\(O(V\log n)\)</span>。</p></li>
</ul>
<details>
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;
const int V = 1e6;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, q, s, d;
    std::cin &gt;&gt; n &gt;&gt; q &gt;&gt; s &gt;&gt; d;
    std::vector&lt;int&gt; a(n + 1), tab(V + 1);
    for (int i = 1; i &lt;= n; ++i)
        std::cin &gt;&gt; a[i], tab[a[i]] = i;
    std::vector&lt;std::pair&lt;int, int&gt; &gt; to(n + 1);
    std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; g(n + 1);
    std::vector&lt;int&gt; u(V + 1), pre(V + 1), nex(V + 1), mn(n + 1), f(n + 1), pos;
    std::iota(f.begin() + 1, f.end(), 1);
    std::function&lt;int(int)&gt; find = [&amp;](int x) &#123;
        return x == f[x] ? x : f[x] = find(f[x]);
    &#125;;
    for (int tot = n; tot != 1; ) &#123;
        pos.clear();
        for (int i = 1; i &lt;= n; ++i) &#123;
            if (f[i] == i) &#123;
                mn[i] = 0x3f3f3f3f, to[i] = &#123; 0, 0 &#125;;
                pos.push_back(i);
            &#125;
            u[a[i]] = find(i);
            if (u[a[i - 1]] == u[a[i]])
                pre[a[i]] = pre[a[i - 1]];
            else
                pre[a[i]] = a[i - 1];
        &#125;
        for (int i = 1; i &lt;= V; ++i)
            if (!u[i])
                pre[i] = u[i - 1] ? i - 1 : pre[i - 1];
        nex[a[n]] = V + 1;
        for (int i = n - 1; i; --i)
            if (u[a[i + 1]] == u[a[i]])
                nex[a[i]] = nex[a[i + 1]];
            else
                nex[a[i]] = a[i + 1];
        nex[V] = V + 1;
        for (int i = V - 1; i; --i)
            if (!u[i])
                nex[i] = u[i + 1] ? i + 1 : nex[i + 1];
        for (int i = 1; i &lt;= n; ++i) &#123;
            int x = a[i], now = 0x3f3f3f3f, pos = 0;
            auto upd = [&amp;](int x1) &#123;
                if (std::abs(std::abs(x - x1) - d) &lt; now)
                    now = std::abs(std::abs(x - x1) - d), pos = x1;
                return;
            &#125;;
            auto trans = [&amp;](int x1) &#123;
                if (pre[x1])
                    upd(pre[x1]);
                if (nex[x1] != V + 1)
                    upd(nex[x1]);
                return;
            &#125;;
            std::function&lt;void(int)&gt; work = [&amp;](int x1) &#123;
                if (u[x1] &amp;&amp; u[x1] != u[x])
                    upd(x1);
                else if (u[x1])
                    trans(x1);
                else &#123;
                    if (pre[x1])
                        work(pre[x1]);
                    if (nex[x1] != V + 1)
                        work(nex[x1]);
                &#125;
                return;
            &#125;;
            work(std::max(1, x - d)), work(std::min(V, x + d));
            if (now &lt; mn[u[x]])
                mn[u[x]] = now, to[u[x]] = &#123; i, tab[pos] &#125;;
        &#125;
        for (auto i : pos) &#123;
            int j = u[a[to[i].second]], x = to[i].first, y = to[i].second;
            if (find(i) != find(j)) &#123;
                --tot;
                f[find(i)] = find(j);
                g[x].emplace_back(y, mn[i]), g[y].emplace_back(x, mn[i]);
            &#125;
        &#125;
    &#125;
    std::vector&lt;int&gt; res(n + 1);
    std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int fa) &#123;
        for (auto [i, w] : g[x])
            if (i != fa) &#123;
                res[i] = std::max(res[x], w);
                DFS(i, x);
            &#125;
        return;
    &#125;;
    DFS(s, -1);
    for (int x, k; q--; ) &#123;
        std::cin &gt;&gt; x &gt;&gt; k;
        std::cout &lt;&lt; ((res[x] &lt;= k) ? &quot;Yes&quot; : &quot;No&quot;) &lt;&lt; &#39;\n&#39;;
    &#125;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;</code></pre>
</details>
<hr />
<h2 id="b---parametric-mst">B - Parametric MST</h2>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/CF1656F" class="uri">https://www.luogu.com.cn/problem/CF1656F</a></p>
<ul>
<li>可以猜到能够把答案写出来，但是发现太抽象了以至于不太好模拟。</li>
<li>首先需要猜到题目给的 <span class="math inline">\(w\)</span> 是可以继续化的，注意到 <span class="math inline">\(a_i\cdot a_j+t(a_i+a_j)\)</span> 可以写成 <span class="math inline">\((a_j+t)\cdot a_i+t\cdot a_i\)</span> 的一次函数形式，一个很重要的思路是放弃模拟 mst 转而<strong>从点出发贪心</strong></li>
<li><p><span class="math inline">\(t\)</span> 会影响的是斜率 <span class="math inline">\(a_j+t\)</span>，所以<strong>应该根据 <span class="math inline">\(a_j+t\)</span> 的正负情况选择贪心策略</strong>。</p>
<p>当 <span class="math inline">\(a_j+t\le 0\)</span> 时，使 <span class="math inline">\(a_j\)</span> 向 <span class="math inline">\(a_{\max}\)</span> 连边，否则向 <span class="math inline">\(a_{\min}\)</span> 连边。</p>
<p>这其实是 Boruvka 第一轮的过程；此时只剩至多两个连通块，连边方式也就讨论一下 <span class="math inline">\(a_1+t\)</span> 和 <span class="math inline">\(a_n+t\)</span> 的正负，然后很显然了。</p></li>
<li><p>当 <span class="math inline">\(t\)</span> 足够小时，所有点都会连向 <span class="math inline">\(a_{\max}\)</span>；反之，当 <span class="math inline">\(t\)</span> 足够大时，所有点都会连向 <span class="math inline">\(a_{\min}\)</span>。</p>
<p>对于第一种情况，mst 的权为 <span class="math inline">\(a_{\max}\cdot (s - a_{\max}) + t\cdot ((n-1)\cdot a_{\max}+s-a_{\max})\)</span>；第二种情况，mst 的权为 <span class="math inline">\(a_{\min}\cdot (s - a_{\min}) + t\cdot ((n-1)\cdot a_{\min}+s-a_{\min})\)</span>，check <span class="math inline">\(t\)</span> 的系数即可判 <code>INF</code>。</p></li>
<li><p>通过上面一种情况，可以注意到 <span class="math inline">\(t\in[-a_{\max},-a_{\min}]\)</span>，进一步需要猜到 <span class="math inline">\(t\)</span> 取某个 <span class="math inline">\(-a_i\)</span>。由于连的边是很已知的，可以发现当 <span class="math inline">\(t\)</span> 夹在两个连续的 <span class="math inline">\(-a\)</span> 之间时，mst 的连边情况是不变的。</p>
<p>显然此时 mst 的权是一个关于 <span class="math inline">\(t\)</span> 的一次函数，故 check 两端点即可。排序即可快速 check。</p>
<p>由于此时第二轮 Boruvka 要连的边一定是 <span class="math inline">\((a_1,a_n)\)</span>，连上即可。</p></li>
</ul>
<details>
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int T;
    for (std::cin &gt;&gt; T; T--; ) &#123;
        int n;
        std::cin &gt;&gt; n;
        std::vector&lt;long long&gt; a(n + 1), s(n + 1);
        for (int i = 1; i &lt;= n; ++i)
            std::cin &gt;&gt; a[i];
        std::sort(a.begin() + 1, a.end());
        std::partial_sum(a.begin() + 1, a.end(), s.begin() + 1);
        if ((n - 1) * a[n] + s[n - 1] &lt; 0ll || (n - 1) * a[1] + s[n] - a[1] &gt; 0ll)
            std::cout &lt;&lt; &quot;INF\n&quot;;
        else &#123;
            long long res = -1e18;
            for (int i = 1; i &lt;= n; ++i) &#123;
                auto t = -a[i], sl = s[i] - a[1], sr = s[n - 1] - s[i];
                res = std::max(res, a[n] * sl + a[1] * sr + t * ((i - 1) * a[n] + (n - 1 - i) * a[1] + sl + sr) + a[1] * a[n] + t * (a[1] + a[n]));
            &#125;
            std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
        &#125;
    &#125;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;</code></pre>
</details>
<hr />
<h2 id="c---star-mst">C - Star MST</h2>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/CF1657E" class="uri">https://www.luogu.com.cn/problem/CF1657E</a></p>
<ul>
<li>模拟 Kruskal 的过程，在边权 <span class="math inline">\(w\)</span> 处出现 <span class="math inline">\((1,x)\)</span>，那么允许在 <span class="math inline">\(\ge w\)</span> 处出现其他与 <span class="math inline">\(x\)</span> 相关的边。</li>
<li>会有一个比较暴力的想法，设 <span class="math inline">\(f_{i,j,l}\)</span> 表示已经分配完边权 <span class="math inline">\(i\)</span>，共分配了 <span class="math inline">\(j\)</span> 条与 <span class="math inline">\(1\)</span> 相关的边，还剩下 <span class="math inline">\(l\)</span> 条空闲边可以放，会有一个 <span class="math inline">\(O(k\cdot n^4)\)</span> 的转移。</li>
<li><p>考虑优化。容易注意到没必要存 <span class="math inline">\(l\)</span> 而是可以当场完成分配，但这样就导致 <span class="math inline">\(i\)</span> 维的限制转化为『恰好』，需要额外枚举一轮。总之可以得到：</p>
<p><span class="math display">\[
f_{i,j}=\sum_{d_i=1}^{i}\sum_{d_j=1}^{j} C_{n-(j-d_j)}^{d_j}\times f_{i-d_i,j-d_j}\times (k-i+1)^{C_{d_j}^2+d_j\times (j-d_j)}
\]</span></p>
<p>此时复杂度为 <span class="math inline">\(O(k^2n^2\log k)\)</span>，依然不够看；注意到交换求和顺序可以前缀和优化，故：</p>
<p><span class="math display">\[
f_{j, i}=\sum_{d_j=1}^{j} C_{n-(j-d_j)}^{d_j}\times (k-i+1)^{C_{d_j}^2+d_j\times (j-d_j)}\times \sum_{d_i=1}^{i}f_{j - d_j,i-d_i}
\]</span></p>
<p>复杂度 <span class="math inline">\(O(kn^2\log k)\)</span>。<span class="math inline">\(\log\)</span> 来源于快速幂。当然可以考虑预处理优化掉 log，whatever.</p></li>
</ul>
<details>
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;
const int mod = 998244353;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, k;
    std::cin &gt;&gt; n &gt;&gt; k;
    std::vector&lt;std::vector&lt;long long&gt; &gt; C(n + 1, std::vector&lt;long long&gt; (n + 1));
    for (int i = 0; i &lt;= n; ++i) &#123;
        C[i][0] = 1ll;
        for (int j = 1; j &lt;= i; ++j)
            C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % mod;
    &#125;
    auto qkp = [&amp;](long long x, int y) &#123;
        auto res = 1ll;
        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)
            if (y &amp; 1)
                (res *= x) %= mod;
        return res;
    &#125;;
    std::vector&lt;std::vector&lt;long long&gt; &gt; s(n, std::vector&lt;long long&gt; (k + 1));
    for (int i = 0; i &lt;= k; ++i)
        s[0][i] = 1ll;
    for (int j = 1; j &lt; n; ++j)
        for (int i = 1; i &lt;= k; ++i) &#123;
            for (int dj = 1; dj &lt;= j; ++dj) 
                s[j][i] += C[n - (j - dj) - 1][dj] * qkp(k - i + 1, (C[dj][2] + dj * (j - dj)) % mod) % mod * s[j - dj][i - 1] % mod;
            (s[j][i] += s[j][i - 1]) %= mod;
        &#125;
    std::cout &lt;&lt; s[n - 1][k] &lt;&lt; &#39;\n&#39;;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;</code></pre>
</details>
<hr />
<h2 id="d---smooth-sailing-hard-version">D - Smooth Sailing (Hard Version)</h2>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/CF1920F2" class="uri">https://www.luogu.com.cn/problem/CF1920F2</a></p>
<ul>
<li><p>实在十分熟悉，之前在哪道 CF 题遇到过这个 trick，然而没什么回忆线索，遂放弃</p>
<p>一个连通块被包围的充要条件：从连通块边缘任意一个点向任意方向发一条射线，<em>垂直</em>经过路径奇数次。</p>
<p><em>垂直</em>：即切线不切换奇偶状态。</p>
<p>这个东西其实来源于计算几何，但是我的数学水平只停留在听说过计算几何四个字的水平，故不深究了。</p>
<p>这种网格图上的图论问题，可以往欧拉定理（<span class="math inline">\(v-e+f=2\)</span>），计算几何考虑，</p></li>
<li><p>怎么在保证这一点的前提下求 mst 呢？答案是丢到状态里。</p>
<p>找一个最靠左的点往左边引一条射线并标记沿路经过的点。令 <span class="math inline">\((x, y, 0/1)\)</span> 表示走到 <span class="math inline">\((x, y)\)</span>，经过关键点偶数次 / 奇数次。边权啥的也没什么好说的，点权前移即可。</p></li>
<li><p>询问的转化反而不太好想，其实就是问 <span class="math inline">\((x,y,0)\)</span> 到 <span class="math inline">\((x,y,1)\)</span> 的瓶颈路。</p>
<p>巧得有些不太自然，然而并没找到合理的解释。</p></li>
<li><p>询问建个 Kruskal 重构树找 LCA 即可，复杂度 <span class="math inline">\(O(nm\log nm)\)</span>。</p></li>
</ul>
<details>
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;
const int dir[][2] = &#123;&#123; -1, 0 &#125;, &#123; 1, 0 &#125;, &#123; 0, -1 &#125;, &#123; 0, 1 &#125;&#125;;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, m, q;
    std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;
    int cnt = 2 * n * m;
    std::vector&lt;int&gt; W(1);
    std::vector&lt;std::vector&lt;int&gt; &gt; g(2 * n * m + 1);
    auto fun = [&amp;](int i, int j, int k) &#123;
        return k * n * m + (i - 1) * m + j;
    &#125;;
    &#123;
        int px = 0, py = m + 1;
        std::vector&lt;std::vector&lt;char&gt; &gt; a(n + 1, std::vector&lt;char&gt; (m + 1));
        for (int i = 1; i &lt;= n; ++i)
            for (int j = 1; j &lt;= m; ++j) &#123;
                std::cin &gt;&gt; a[i][j];
                if (a[i][j] == &#39;#&#39; &amp;&amp; j &lt; py)
                    px = i, py = j;
            &#125;
        std::vector&lt;std::vector&lt;int&gt; &gt; w(n + 1, std::vector&lt;int&gt; (m + 1, 0x3f3f3f3f));
        &#123;
            std::queue&lt;std::pair&lt;int, int&gt; &gt; q;
            for (int i = 1; i &lt;= n; ++i)
                for (int j = 1; j &lt;= m; ++j)
                    if (a[i][j] == &#39;v&#39;)
                        q.emplace(i, j), w[i][j] = 0;
            for (; !q.empty(); ) &#123;
                auto [x, y] = q.front();
                q.pop();
                for (auto [fx, fy] : dir) &#123;
                    int nx = x + fx, ny = y + fy;
                    if (nx &gt;= 1 &amp;&amp; nx &lt;= n &amp;&amp; ny &gt;= 1 &amp;&amp; ny &lt;= m &amp;&amp; w[nx][ny] == 0x3f3f3f3f) &#123;
                        w[nx][ny] = w[x][y] + 1;
                        q.emplace(nx, ny);
                    &#125;
                &#125;
            &#125;
        &#125;
        struct edge &#123; int u, v, w; &#125;;
        std::vector&lt;edge&gt; e;
        for (int i = 1; i &lt;= n; ++i)
            for (int j = 1; j &lt;= m; ++j)
                if (a[i][j] != &#39;#&#39;) &#123;
                    if (j != m &amp;&amp; a[i][j + 1] != &#39;#&#39;) &#123;
                        e.push_back(&#123; fun(i, j, 0), fun(i, j + 1, 0), std::min(w[i][j], w[i][j + 1]) &#125;);
                        e.push_back(&#123; fun(i, j, 1), fun(i, j + 1, 1), std::min(w[i][j], w[i][j + 1]) &#125;);
                    &#125;
                    if (i != n &amp;&amp; a[i + 1][j] != &#39;#&#39;) &#123;
                        if (i + 1 == px &amp;&amp; j &lt;= py) &#123;
                            e.push_back(&#123; fun(i, j, 0), fun(i + 1, j, 1), std::min(w[i][j], w[i + 1][j]) &#125;);
                            e.push_back(&#123; fun(i, j, 1), fun(i + 1, j, 0), std::min(w[i][j], w[i + 1][j]) &#125;);
                        &#125;
                        else &#123;
                            e.push_back(&#123; fun(i, j, 0), fun(i + 1, j, 0), std::min(w[i][j], w[i + 1][j]) &#125;);
                            e.push_back(&#123; fun(i, j, 1), fun(i + 1, j, 1), std::min(w[i][j], w[i + 1][j]) &#125;);
                        &#125;
                    &#125;
                &#125;
        std::sort(e.begin(), e.end(), [&amp;](edge &amp;x, edge &amp;y) &#123; return x.w &gt; y.w; &#125;);
        std::vector&lt;int&gt; f(2 * n * m + 1);
        std::iota(f.begin() + 1, f.end(), 1);
        std::function&lt;int(int)&gt; find = [&amp;](int x) &#123;
            return x == f[x] ? x : f[x] = find(f[x]);
        &#125;;
        for (auto [x, y, w] : e)
            if (find(x) != find(y)) &#123;
                f.push_back(++cnt);
                W.push_back(w), g.emplace_back();
                g[cnt].push_back(find(x)), g[cnt].push_back(find(y));
                f[find(x)] = f[find(y)] = cnt;
            &#125;
    &#125;
    std::vector&lt;int&gt; fa(cnt + 1), siz(cnt + 1), dep(cnt + 1), son(cnt + 1), top(cnt + 1);
    std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;
        siz[x] = 1;
        for (auto i : g[x]) &#123;
            dep[i] = dep[x] + 1;
            DFS(i), fa[i] = x;
            siz[x] += siz[i];
            if (siz[i] &gt; siz[son[x]])
                son[x] = i;
        &#125;
        return;
    &#125;;
    dep[1] = 1, DFS(cnt);
    DFS = [&amp;](int x) &#123;
        if (son[x])
            top[son[x]] = top[x], DFS(son[x]);
        for (auto i : g[x])
            if (i != son[x])
                top[i] = i, DFS(i);
        return;
    &#125;;
    top[cnt] = cnt, DFS(cnt);
    auto ask = [&amp;](int x, int y) &#123;
        for (; top[x] != top[y]; x = fa[top[x]])
            if (dep[top[x]] &lt; dep[top[y]])
                std::swap(x, y);
        return dep[x] &lt; dep[y] ? x : y;
    &#125;;
    for (int x, y; q--; ) &#123;
        std::cin &gt;&gt; x &gt;&gt; y;
        std::cout &lt;&lt; W[ask(fun(x, y, 0), fun(x, y, 1)) - 2 * n * m] &lt;&lt; &#39;\n&#39;;
    &#125;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;</code></pre>
</details>
<hr />
<h2 id="e---turtle-and-intersected-segments">E - Turtle and Intersected Segments</h2>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/CF1981E" class="uri">https://www.luogu.com.cn/problem/CF1981E</a></p>
<ul>
<li><p>考虑绝对值的几何意义，很容易发现有的边注定是无效的：</p>
<figure>
<img src="image.png" alt="如图中三条线段形成一个环，权值如图，排除掉权值最大的边，发现只会连权值相邻的边" /><figcaption>如图中三条线段形成一个环，权值如图，排除掉权值最大的边，发现只会连权值相邻的边</figcaption>
</figure></li>
<li>换句话说，对于数轴上的这个点，仅需把覆盖之的所有<em>线段序列</em>按 <span class="math inline">\(a\)</span> 排序，连接相邻者即可。怎么更快地实现这个过程呢？</li>
<li><p>发现只需要在这个<em>线段序列</em>变化的时候连新的边，故用 multiset 维护这个序列，扫一遍，在加入新线段时连接它和前驱后继即可（结合前文论述发现删除的时候不用管）。</p></li>
</ul>
<details>
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int T;
    for (std::cin &gt;&gt; T; T--; ) &#123;
        int n;
        std::cin &gt;&gt; n;
        struct node &#123; int l, r, v; &#125;;
        struct edge &#123; int u, v, w; &#125;;
        std::vector&lt;edge&gt; e;
        std::vector&lt;node&gt; a(n + 1);
        for (int i = 1; i &lt;= n; ++i)
            std::cin &gt;&gt; a[i].l &gt;&gt; a[i].r &gt;&gt; a[i].v;
        std::sort(a.begin() + 1, a.end(), [&amp;](node &amp;x, node &amp;y) &#123; return x.l &lt; y.l; &#125;);
        std::set&lt;std::tuple&lt;int, int, int&gt; &gt; t;
        std::set&lt;std::pair&lt;int, int&gt; &gt; now;
        for (int i = 1; i &lt;= n; ++i) &#123;
            for (; !t.empty();) &#123;
                auto [r, v, id] = *t.begin();
                if (r &gt;= a[i].l)
                    break;
                now.erase(std::make_pair(v, id));
                t.erase(t.begin());
            &#125;
            auto p = now.lower_bound(std::make_pair(a[i].v, i));
            if (p != now.end())
                e.push_back(&#123; i, p-&gt;second, p-&gt;first - a[i].v &#125;);
            if (p != now.begin()) &#123;
                --p;
                e.push_back(&#123; i, p-&gt;second, a[i].v - p-&gt;first &#125;);
            &#125;
            t.emplace(a[i].r, a[i].v, i), now.emplace(a[i].v, i);
        &#125;
        std::sort(e.begin(), e.end(), [&amp;](edge &amp;x, edge &amp;y) &#123; return x.w &lt; y.w; &#125;);
        auto res = 0ll;
        std::vector&lt;int&gt; f(n + 1);
        std::iota(f.begin() + 1, f.end(), 1);
        std::function&lt;int(int)&gt; find = [&amp;](int x) &#123;
            return x == f[x] ? x : f[x] = find(f[x]);
        &#125;;
        int cntm = 0;
        for (auto [u, v, w] : e)
            if (find(u) != find(v)) &#123;
                f[find(u)] = find(v);
                res += w, ++cntm;
            &#125;
        if (cntm == n - 1)
            std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
        else
            std::cout &lt;&lt; -1 &lt;&lt; &#39;\n&#39;;
    &#125;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;</code></pre>
</details>
<hr />
<h2 id="f---digital-village-extreme-version">F - Digital Village (Extreme Version)</h2>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/CF2021E3" class="uri">https://www.luogu.com.cn/problem/CF2021E3</a></p>
<ul>
<li>为啥会想到 DP（。）前面不都是神秘建图题吗（。）</li>
<li><p>会发现待求即为重构树上 LCA 的权值，但题设中的 Key 是设置了服务器的结点，二者不匹配。如果直接设 <span class="math inline">\(f_{x,j}\)</span> 表示 <span class="math inline">\(x\)</span> 子树内设了 <span class="math inline">\(j\)</span> 个服务器，感觉不太可行。</p>
<p>当然也可能是因为我没做过重构树上的 DP。Whatever.</p></li>
<li><p>实际上需要结合重构树的性质考虑。发现一个子树内部不能消化，当且仅当</p></li>
</ul>

			</div>
			<hr class="dotted">
			<div class="post footer">
				<div id="hitokoto">
					<h3 id="hitokoto-title">
						言论
					</h3>
					<div id="hitokoto-content">
					</div>
					<div id="hitokoto-from">
					</div>
				</div>
				<div class="button flex">
					<div id="prev">
						
							<!-- 吐槽，为啥还需要加 / -->
							<a href="/20251019/">
								<i class="fas fa-angle-double-left" style="margin-right: 10px;"></i>
								杂题选谈
							</a>
						
					</div>
					<div id="next">
						
							<a href="/20251010/">
								学习笔记：树状数组
								<i class="fas fa-angle-double-right" style="margin-left: 10px;"></i>
							</a>
						
					</div>
				</div>
				<div id="vcomments" class="text"></div>
<script>
	new Valine({
		el: '#vcomments',
		appId: 'OlmvQ0a2Zw7xo3no2bwabOzx-gzGzoHsz',
		appKey: 'TW6t8mFeGLmhPjWisvmllvvo',
		recordIP: true,
		enableQQ: true, 
		// [EDITED] 目前 Valine 的 QQ 自动获取昵称似乎不可用
		// 该问题在 v1.5.3 中已修复
		pageSize: 10,
		requiredFields:
			
				['nick']
			,
		placeholder: "The world is but a little place after all...\n能够根据邮箱获取你的 Gravatar 头像。昵称是必填项，长度需不低于 3。",
		avatar: 'identicon',
		avatar_cdn: 'https://cravatar.cn/avatar/',
		emojiCDN: 'https://xsc062.netlify.app/em/', 
		emojiMaps: {
			
				"微笑": "wx.gif",
			
				"龇牙": "cy.gif",
			
				"流泪": "ll.gif",
			
				"笑哭": "xk.gif",
			
				"流汗": "lh.gif",
			
				"擦汗": "ch.gif",
			
				"亲亲": "qq.gif",
			
				"色": "se.gif",
			
				"疑问": "yiw.gif",
			
				"发呆": "fd.gif",
			
				"晕": "yun.gif",
			
				"鼓掌": "gz.gif",
			
				"憨笑": "hanx.gif",
			
				"快哭了": "kk.gif",
			
				"得意": "dy.gif",
			
				"狂笑": "kx.gif",
			
				"害羞": "hx.gif",
			
				"妈妈生的": "dz.gif",
			
				"糗大了": "qd.gif",
			
				"吃瓜": "cg.gif",
			
				"睁眼": "zy.webp",
			
				"辣眼睛": "lyj.gif",
			
				"酸了": "nm.gif",
			
				"滚": "gun.webp",
			
				"惊恐": "jk.gif",
			
				"幽灵": "youl.gif",
			
				"无聊": "wul.gif",
			
				"吃": "eat.gif",
			
				"你很棒棒": "bb.gif",
			
				"赞": "qiang.gif",
			
				"踩": "ruo.gif",
			
				"握手": "wsh.gif",
			
				"发抖": "fad.gif",
			
				"挥手": "hsh.gif",
			
				"磕头": "kt.gif",
			
				"怄火": "oh.gif",
			
		},
		mathjax: true,
	})
</script>
			</div>
			<script>setHitokoto();</script>
		</div> 
	</div>
</div>
    <!-- 页脚开始 -->
<div id="footer" class="serif">
    Powered by
    <a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a>
    &
    <a href="/about-this-theme">
        iwll
    </a>
    <p style="margin-top: 5px;">
        2021 - 2025
    </p>
    <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/" id="CCTAG"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/big/by_nc_sa.svg"></a>
</div>
<!-- Valine 相关配置 -->
<script>
    const getValineDomTimer = setInterval(() => {
        // 不知道为什么 我从原博客 js 文件粘过来的参数是
        // "#valine .vcards .vcard"
        // DEBUG 了半天才定位到这个问题。。。
        const vcards =
            document.querySelectorAll('#valine, .vcards, .vcard');
        if (vcards.length > 0) {
            let author = 'XSC062';
            for (let vcard of vcards) {
                const vnick_dom = vcard.querySelector('.vhead .vnick');
                if (vnick_dom != null) {
                    const vnick = vnick_dom.innerHTML;
                    if (vnick === author) {
                        vnick_dom.innerHTML =
                        `${vnick} <span id="rootitem" class="code">root</span>`
                    }
                }
            }
        }
        else {
            clearInterval(getValineDomTimer);
        }
    }, 2000);
    SetActiveItem();
    setDetailsSummary();
    setTitleAnchor();
    setEmptyToc();
    setCodeClassName();
</script>


<!-- js -->
<!-- 搜索功能相关配置 -->

<script src="/js/search.js"></script>


<script src="/js/local-search.js"></script>

</script>
<!-- prism 相关配置 -->
<script type="text/javascript" src="/js/prism.js" defer></script>
<!-- 代码块复制功能 -->
<script type="text/javascript" src="/js/clipboard.min.js"></script>
<script type="text/javascript" src="/js/clipboard-use.js"></script>
<!-- 页脚结束 -->
</body>
</html>