<?xml version="1.0"?>
<rss version="2.0">
    <channel>
        <title></title>
        <link>https://xsc062.netlify.app</link>
        <description></description>
        <language>zh-CN</language>
        <pubDate>Fri, 07 Nov 2025 20:24:16 +0800</pubDate>
        <lastBuildDate>Fri, 07 Nov 2025 20:24:16 +0800</lastBuildDate>
        <category>并查集</category>
        <category>斜率优化</category>
        <category>悬线法</category>
        <category>哈希</category>
        <category>字典树</category>
        <category>DP</category>
        <category>单调队列</category>
        <category>分治</category>
        <category>计数</category>
        <category>容斥</category>
        <category>二分图</category>
        <category>CRT / exCRT</category>
        <category>排列组合</category>
        <category>网络流</category>
        <category>二分</category>
        <category>容斥原理</category>
        <category>线段树</category>
        <category>树状数组</category>
        <category>区间 DP</category>
        <category>构造</category>
        <category>数据结构</category>
        <category>Tarjan</category>
        <category>下饭</category>
        <category>李超线段树</category>
        <category>树链剖分</category>
        <category>LCA</category>
        <category>倍增</category>
        <category>鸽巢原理</category>
        <category>数学</category>
        <category>调和级数</category>
        <category>差分</category>
        <category>思维</category>
        <category>树形 DP</category>
        <category>最小生成树</category>
        <category>状压</category>
        <category>高维前缀和</category>
        <category>SAM</category>
        <category>分块</category>
        <category>可持久化</category>
        <category>笛卡尔树</category>
        <category>闲话</category>
        <category>欧拉回路</category>
        <category>长链剖分</category>
        <category>KMP</category>
        <category>border</category>
        <category>随机化</category>
        <category>字符串</category>
        <category>AC 自动机</category>
        <category>SA</category>
        <category>树上差分</category>
        <category>FWT</category>
        <category>堆</category>
        <category>树的重心</category>
        <category>贪心</category>
        <category>均摊</category>
        <category>优化建图</category>
        <category>反悔贪心</category>
        <category>调整法</category>
        <category>背包</category>
        <category>博弈论</category>
        <category>DP 优化</category>
        <category>虚树</category>
        <category>点分治</category>
        <category>四边形不等式</category>
        <category>支配对</category>
        <category>DDP</category>
        <category>CDQ 分治</category>
        <category>猫树</category>
        <category>DP 套 DP</category>
        <category>Kruskal 重构树</category>
        <category>高精度</category>
        <category>最短路</category>
        <category>树套树</category>
        <category>二项式反演</category>
        <category>搜索</category>
        <item>
            <guid isPermalink="true">https://xsc062.netlify.app/20251107/</guid>
            <title>一类序列区间排序问题</title>
            <link>https://xsc062.netlify.app/20251107/</link>
            <category>线段树</category>
            <pubDate>Fri, 07 Nov 2025 20:24:16 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;答辩题做累了，做点轻松愉快的数据结构&lt;/p&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;排序&#34;&gt;排序&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P2824&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P2824&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定排列 &lt;span class=&#34;math inline&#34;&gt;\(a_{1\cdots n}\)&lt;/span&gt;，维护 &lt;span class=&#34;math inline&#34;&gt;\(m\)&lt;/span&gt; 次操作，形如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;0/1 l r&lt;/code&gt;，将 &lt;span class=&#34;math inline&#34;&gt;\(a_{l\cdots r}\)&lt;/span&gt; 按升序 / 降序排列。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最后给定一个 &lt;span class=&#34;math inline&#34;&gt;\(p\)&lt;/span&gt;，问最终 &lt;span class=&#34;math inline&#34;&gt;\(a_p\)&lt;/span&gt; 的值。&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(n,m\le 10^5\)&lt;/span&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;发现问题是类静态的，考虑离线做法。&lt;/p&gt;
&lt;p&gt;在线做法放到后面的在线题目再讲，原因：在线做法 too dirty，杀鸡焉用牛刀。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;发现如果值域为 &lt;span class=&#34;math inline&#34;&gt;\(\{0, 1\}\)&lt;/span&gt;，那么这样的排序是很简单的，直接统计区间内 0/1 个数然后推平即可。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;这种转化后为 0/1 的情况，很容易想到二分答案：把 &lt;span class=&#34;math inline&#34;&gt;\(\le mid\)&lt;/span&gt; 的元素赋为 &lt;span class=&#34;math inline&#34;&gt;\(0\)&lt;/span&gt;，&lt;span class=&#34;math inline&#34;&gt;\(&amp;gt;mid\)&lt;/span&gt; 的元素赋为 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt; 即可 &lt;span class=&#34;math inline&#34;&gt;\(O(n\log^2 n)\)&lt;/span&gt; 解决问题。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;p&gt;推平时操作区间长可能为 &lt;span class=&#34;math inline&#34;&gt;\(0\)&lt;/span&gt;，不判掉这个会 RE&lt;/p&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int maxn = 1e5 + 5;
struct &amp;#123; int l, r, u, d; &amp;#125; t[maxn &amp;lt;&amp;lt; 2];
int a[maxn];
#define lt (p &amp;lt;&amp;lt; 1)
#define rt (lt | 1)
void pushup(int p) &amp;#123;
    t[p].u = t[lt].u + t[rt].u;
    return;
&amp;#125;
void pushdown(int p) &amp;#123;
    if (~t[p].d) &amp;#123;
        t[lt].d = t[rt].d = t[p].d;
        t[lt].u = (t[lt].r - t[lt].l + 1) * t[p].d;
        t[rt].u = (t[rt].r - t[rt].l + 1) * t[p].d;
        t[p].d = -1;
    &amp;#125;
    return;
&amp;#125;
void bld(int p, int l, int r, int k) &amp;#123;
    t[p].l = l, t[p].r = r;
    t[p].d = -1;
    if (l == r) &amp;#123;
        t[p].u = (a[l] &amp;gt;= k);
        return;
    &amp;#125;
    int mid = (l + r) &amp;gt;&amp;gt; 1;
    bld(lt, l, mid, k);
    bld(rt, mid + 1, r, k);
    pushup(p);
    return;
&amp;#125;
void upd(int p, int l, int r, int v) &amp;#123;
    if (l &amp;lt;= t[p].l &amp;amp;&amp;amp; t[p].r &amp;lt;= r) &amp;#123;
        t[p].d = v;
        t[p].u = (t[p].r - t[p].l + 1) * v;
        return;
    &amp;#125;
    pushdown(p);
    int mid = (t[p].l + t[p].r) &amp;gt;&amp;gt; 1;
    if (l &amp;lt;= mid)
        upd(lt, l, r, v);
    if (r &amp;gt; mid)
        upd(rt, l, r, v);
    pushup(p);
    return;
&amp;#125;
int ask(int p, int l, int r) &amp;#123;
    if (l &amp;lt;= t[p].l &amp;amp;&amp;amp; t[p].r &amp;lt;= r)
        return t[p].u;
    pushdown(p);
    int mid = (t[p].l + t[p].r) &amp;gt;&amp;gt; 1, res = 0;
    if (l &amp;lt;= mid)
        res = ask(lt, l, r);
    if (r &amp;gt; mid)
        res += ask(rt, l, r);
    return res;
&amp;#125;
#undef lt
#undef rt
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, m;
    std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
    std::vector&amp;lt;std::tuple&amp;lt;int, int, int&amp;gt; &amp;gt; q(m);;
    for (int i = 1; i &amp;lt;= n; ++i)
        std::cin &amp;gt;&amp;gt; a[i];
    for (int i = 0, op, l, r; i &amp;lt; m; ++i) &amp;#123;
        std::cin &amp;gt;&amp;gt; op &amp;gt;&amp;gt; l &amp;gt;&amp;gt; r;
        q[i] = &amp;#123; op, l, r &amp;#125;;
    &amp;#125;
    int p;
    std::cin &amp;gt;&amp;gt; p;
    auto check = [&amp;amp;](int mid) &amp;#123;
        bld(1, 1, n, mid);
        for (int i = 0; i &amp;lt; m; ++i) &amp;#123;
            auto &amp;amp;[op, l, r] = q[i];
            int t = ask(1, l, r);
            if (op == 0) &amp;#123;
                t = (r - l + 1) - t;
                if (t &amp;gt;= 1)
                    upd(1, l, l + t - 1, 0);
                if (l + t &amp;lt;= r)
                    upd(1, l + t, r, 1);
            &amp;#125;
            else &amp;#123;
                if (t &amp;gt;= 1)
                    upd(1, l, l + t - 1, 1);
                if (l + t &amp;lt;= r)
                    upd(1, l + t, r, 0);
            &amp;#125;
        &amp;#125;
        return ask(1, p, p);
    &amp;#125;;
    int res = -1;
    for (int l = 1, r = n, mid; l &amp;lt;= r; ) &amp;#123;
        mid = (l + r) &amp;gt;&amp;gt; 1;
        if (check(mid))
            res = mid, l = mid + 1;
        else
            r = mid - 1;
    &amp;#125;
    std::cout &amp;lt;&amp;lt; res &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;range-sort-query&#34;&gt;Range Sort Query&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/AT_abc237_g&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/AT_abc237_g&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定排列 &lt;span class=&#34;math inline&#34;&gt;\(a_{1\cdots n}\)&lt;/span&gt;，维护 &lt;span class=&#34;math inline&#34;&gt;\(m\)&lt;/span&gt; 次操作，形如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;0/1 l r&lt;/code&gt;，将 &lt;span class=&#34;math inline&#34;&gt;\(a_{l\cdots r}\)&lt;/span&gt; 按升序 / 降序排列。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最后给定一个 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt;，求满足 &lt;span class=&#34;math inline&#34;&gt;\(a_p=x\)&lt;/span&gt; 的 &lt;span class=&#34;math inline&#34;&gt;\(p\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(n,m\le 2\times 10^5\)&lt;/span&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;发现这个问题不可二分，但根据 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 设 0/1 的想法显然可以沿用。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;有一个形似&lt;a href=&#34;/20250819/#等差子序列&#34;&gt;等差子序列&lt;/a&gt;的想法：&lt;/p&gt;
&lt;p&gt;发现对于 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt;，它是 0 或 1 无所谓，且两种设法中，被影响到的只有 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 这个值。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;故对于两种设法分别做一次，最后不同的位置即为 &lt;span class=&#34;math inline&#34;&gt;\(p\)&lt;/span&gt;。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int maxn = 2e5 + 5;
struct &amp;#123; int l, r, u, d; &amp;#125; t[maxn &amp;lt;&amp;lt; 2];
int a[maxn];
#define lt (p &amp;lt;&amp;lt; 1)
#define rt (lt | 1)
void pushup(int p) &amp;#123;
    t[p].u = t[lt].u + t[rt].u;
    return;
&amp;#125;
void pushdown(int p) &amp;#123;
    if (~t[p].d) &amp;#123;
        t[lt].d = t[rt].d = t[p].d;
        t[lt].u = (t[lt].r - t[lt].l + 1) * t[p].d;
        t[rt].u = (t[rt].r - t[rt].l + 1) * t[p].d;
        t[p].d = -1;
    &amp;#125;
    return;
&amp;#125;
void bld(int p, int l, int r, int k) &amp;#123;
    t[p].l = l, t[p].r = r;
    t[p].d = -1;
    if (l == r) &amp;#123;
        t[p].u = (a[l] &amp;gt;= k);
        return;
    &amp;#125;
    int mid = (l + r) &amp;gt;&amp;gt; 1;
    bld(lt, l, mid, k);
    bld(rt, mid + 1, r, k);
    pushup(p);
    return;
&amp;#125;
void upd(int p, int l, int r, int v) &amp;#123;
    if (l &amp;lt;= t[p].l &amp;amp;&amp;amp; t[p].r &amp;lt;= r) &amp;#123;
        t[p].d = v;
        t[p].u = (t[p].r - t[p].l + 1) * v;
        return;
    &amp;#125;
    pushdown(p);
    int mid = (t[p].l + t[p].r) &amp;gt;&amp;gt; 1;
    if (l &amp;lt;= mid)
        upd(lt, l, r, v);
    if (r &amp;gt; mid)
        upd(rt, l, r, v);
    pushup(p);
    return;
&amp;#125;
int ask(int p, int l, int r) &amp;#123;
    if (l &amp;lt;= t[p].l &amp;amp;&amp;amp; t[p].r &amp;lt;= r)
        return t[p].u;
    pushdown(p);
    int mid = (t[p].l + t[p].r) &amp;gt;&amp;gt; 1, res = 0;
    if (l &amp;lt;= mid)
        res = ask(lt, l, r);
    if (r &amp;gt; mid)
        res += ask(rt, l, r);
    return res;
&amp;#125;
#undef lt
#undef rt
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, m, k;
    std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m &amp;gt;&amp;gt; k;
    std::vector&amp;lt;int&amp;gt; b(n + 1);
    std::vector&amp;lt;std::tuple&amp;lt;int, int, int&amp;gt; &amp;gt; q(m);
    for (int i = 1; i &amp;lt;= n; ++i)
        std::cin &amp;gt;&amp;gt; a[i];
    bld(1, 1, n, k + 1);
    for (int i = 0, op, l, r; i &amp;lt; m; ++i) &amp;#123;
        std::cin &amp;gt;&amp;gt; op &amp;gt;&amp;gt; l &amp;gt;&amp;gt; r;
        q[i] = &amp;#123; op, l, r &amp;#125;;
        int t = ask(1, l, r);
        if (op == 1) &amp;#123;
            t = (r - l + 1) - t;
            if (t &amp;gt;= 1)
                upd(1, l, l + t - 1, 0);
            if (l + t &amp;lt;= r)
                upd(1, l + t, r, 1);
        &amp;#125;
        else &amp;#123;
            if (t &amp;gt;= 1)
                upd(1, l, l + t - 1, 1);
            if (l + t &amp;lt;= r)
                upd(1, l + t, r, 0);
        &amp;#125;
    &amp;#125;
    for (int i = 1; i &amp;lt;= n; ++i)
        b[i] = ask(1, i, i);
    bld(1, 1, n, k);
    for (auto &amp;amp;[op, l, r] : q) &amp;#123;
        int t = ask(1, l, r);
        if (op == 1) &amp;#123;
            t = (r - l + 1) - t;
            if (t &amp;gt;= 1)
                upd(1, l, l + t - 1, 0);
            if (l + t &amp;lt;= r)
                upd(1, l + t, r, 1);
        &amp;#125;
        else &amp;#123;
            if (t &amp;gt;= 1)
                upd(1, l, l + t - 1, 1);
            if (l + t &amp;lt;= r)
                upd(1, l + t, r, 0);
        &amp;#125;
    &amp;#125;
    for (int i = 1; i &amp;lt;= n; ++i)
        if (ask(1, i, i) != b[i]) &amp;#123;
            std::cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
            break;
        &amp;#125;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;a-simple-task&#34;&gt;A Simple Task&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/CF558E&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/CF558E&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定&lt;strong&gt;字符串&lt;/strong&gt; &lt;span class=&#34;math inline&#34;&gt;\(s_{1\cdots n}\)&lt;/span&gt;，维护 &lt;span class=&#34;math inline&#34;&gt;\(m\)&lt;/span&gt; 次操作，形如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;0/1 l r&lt;/code&gt;，将 &lt;span class=&#34;math inline&#34;&gt;\(s_{l\cdots r}\)&lt;/span&gt; 按升序 / 降序排列。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;输出所有操作后的 &lt;span class=&#34;math inline&#34;&gt;\(s\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(n\le 10^5, m\le 5\times 10^4\)&lt;/span&gt;，&lt;span class=&#34;math inline&#34;&gt;\(s\)&lt;/span&gt; 由小写字母组成。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;发现需要全局查询，上面设 0/1 的套路无法沿用&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;但发现这题本身值域就很小&lt;/p&gt;
&lt;p&gt;所以只需要开 26 个线段树，暴力按 &lt;code&gt;a ~ z&lt;/code&gt; 排序，做区间覆盖即可。&lt;/p&gt;
&lt;p&gt;询问带 26 倍常数，故 &lt;span class=&#34;math inline&#34;&gt;\(m\)&lt;/span&gt; 会比 &lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt; 小。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;from-one-to-six&#34;&gt;From one to six&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://vjudge.net/problem/Gym-104254I#author=GPT_zh&#34; class=&#34;uri&#34;&gt;https://vjudge.net/problem/Gym-104254I#author=GPT_zh&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定序列 &lt;span class=&#34;math inline&#34;&gt;\(a_{1\cdots n}\)&lt;/span&gt;，&lt;strong&gt;只包含 &lt;span class=&#34;math inline&#34;&gt;\(1,2,3,4,5,6\)&lt;/span&gt;&lt;/strong&gt;，维护 &lt;span class=&#34;math inline&#34;&gt;\(m\)&lt;/span&gt; 次操作，形如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;1 l r&lt;/code&gt;，将 &lt;span class=&#34;math inline&#34;&gt;\(a_{l\cdots r}\)&lt;/span&gt; 升序排列。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;2 l r&lt;/code&gt;，输出 &lt;span class=&#34;math inline&#34;&gt;\([l, r]\)&lt;/span&gt; 内的 LIS。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最后给定一个 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt;，求满足 &lt;span class=&#34;math inline&#34;&gt;\(a_p=x\)&lt;/span&gt; 的 &lt;span class=&#34;math inline&#34;&gt;\(p\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(n,m\le 2\times 10^5\)&lt;/span&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;和上一题相似的，只需需要额外开一个新线段树记录当前的 &lt;span class=&#34;math inline&#34;&gt;\(a\)&lt;/span&gt;，同样只需区间覆盖即可。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;转移直接套用朴素 LIS 的 DP 方式，很容易维护。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;philosopher&#34;&gt;Philosopher&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://loj.ac/p/6189&#34; class=&#34;uri&#34;&gt;https://loj.ac/p/6189&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定 &lt;span class=&#34;math inline&#34;&gt;\(a_{1\cdots n}\)&lt;/span&gt;，维护 &lt;span class=&#34;math inline&#34;&gt;\(m\)&lt;/span&gt; 次操作，形如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;1 l r 0/1&lt;/code&gt;，将 &lt;span class=&#34;math inline&#34;&gt;\(a_{l\cdots r}\)&lt;/span&gt; 按升序 / 降序排列。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;2 l r&lt;/code&gt;，询问区间内元素和。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(1\le n,m\le 2\times 10^5,V=10^9\)&lt;/span&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;在线区间排序的通解：用若干个权值线段树维护连续段（递增 / 递减）。外层用一个同样支持分裂 &amp;amp; 合并 &amp;amp; reverse 的结构，fhq，又一个线段树什么的，记录权值线段树的分布情况及增减状态，&lt;strong&gt;以及每个树的元素和&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;这样查询时就可以通过类似分块的方法求解。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;一次排序，线段树分裂 + 线段树合并。一次操作中的分裂至多增加 2 势能，合并至少减少 1 势能。线段树分裂 &amp;amp; 合并均摊单 log，故总复杂度单 log。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;为何内层不用 fhq？不经过特殊处理的 fhq 在有交合并时带两只 log。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;point-set-range-sort-range-composite&#34;&gt;Point Set Range Sort Range Composite&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://vjudge.net/problem/Yosupo-point_set_range_sort_range_composite#author=GPT_zh&#34; class=&#34;uri&#34;&gt;https://vjudge.net/problem/Yosupo-point_set_range_sort_range_composite#author=GPT_zh&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定 &lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt; 个二元组，由函数 &lt;span class=&#34;math inline&#34;&gt;\(f_{1\cdots n}=k_i\cdot x+b_i\)&lt;/span&gt; 和排序权值 &lt;span class=&#34;math inline&#34;&gt;\(p_{1\cdots n}\)&lt;/span&gt; 组成，维护 &lt;span class=&#34;math inline&#34;&gt;\(m\)&lt;/span&gt; 次操作，形如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;0 i p k b&lt;/code&gt;，修改当前的第 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 个元素的 &lt;span class=&#34;math inline&#34;&gt;\(f_i\)&lt;/span&gt; 和 &lt;span class=&#34;math inline&#34;&gt;\(p_i\)&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;1 l r x&lt;/code&gt;，询问 &lt;span class=&#34;math inline&#34;&gt;\(f_{r-1}(f_{r-2}(\cdots f_l(x)))\bmod 998244353\)&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;2/3 l r&lt;/code&gt;，将当前第 &lt;span class=&#34;math inline&#34;&gt;\(l\sim r\)&lt;/span&gt; 个元素按照 &lt;span class=&#34;math inline&#34;&gt;\(p\)&lt;/span&gt; 值升序 / 降序排列。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(1\le n,m\le 10^5,V=10^9\)&lt;/span&gt;。保证任意时刻，每个 &lt;span class=&#34;math inline&#34;&gt;\(p_i\)&lt;/span&gt; 互不相同。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;和上一题没什么本质区别，换成了维护矩阵而已。额外注意矩阵 + reverse 的那些东西即可。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;齐齐排序&#34;&gt;齐齐排序&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://ac.nowcoder.com/acm/problem/21439&#34; class=&#34;uri&#34;&gt;https://ac.nowcoder.com/acm/problem/21439&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定序列 &lt;span class=&#34;math inline&#34;&gt;\(a_{1\cdots n}\)&lt;/span&gt;，维护 &lt;span class=&#34;math inline&#34;&gt;\(m\)&lt;/span&gt; 次操作，形如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;0 x&lt;/code&gt;，将 &lt;span class=&#34;math inline&#34;&gt;\(a_{1\cdots x}\)&lt;/span&gt; 按降序排列。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;1 x&lt;/code&gt;，将 &lt;span class=&#34;math inline&#34;&gt;\(a_{1\cdots x}\)&lt;/span&gt; 按升序排列。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;输出操作完成后的序列。&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(n,m\le 2\times 10^5,V=10^9\)&lt;/span&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;诈骗题&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;发现只存在前缀操作，显然 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 较大的会覆盖 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 较小的操作&lt;/p&gt;
&lt;p&gt;容易发现有效操作的 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 形成一个后缀最大值序列。用这些操作给数打升序 / 降序标记。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;先填完没有被操作过的位置（显然这样的位置在序列末），然后用一个 &lt;code&gt;multiset&lt;/code&gt; 装剩下所有数。倒序遍历还未填的位置，若这个位置上的标记是升序，则填最大值；否则填最小值。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, m;
    std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
    std::vector&amp;lt;int&amp;gt; a(n + 1);
    for (int i = 1; i &amp;lt;= n; ++i)
        std::cin &amp;gt;&amp;gt; a[i];
    std::vector&amp;lt;std::pair&amp;lt;int, int&amp;gt; &amp;gt; q(m + 1);
    for (int i = 1; i &amp;lt;= m; ++i)
        std::cin &amp;gt;&amp;gt; q[i].first &amp;gt;&amp;gt; q[i].second;
    int mx = 0;
    std::vector&amp;lt;int&amp;gt; tag(n + 1);
    for (int i = m; i; --i)
        if (q[i].second &amp;gt; mx) &amp;#123;
            mx = q[i].second;
            tag[q[i].second] = q[i].first;
        &amp;#125;
    std::multiset&amp;lt;int&amp;gt; t;
    for (int i = 1; i &amp;lt;= mx; ++i)
        t.insert(a[i]);
    for (int i = mx, st = 0; i; --i) &amp;#123;
        if (tag[i])
            st = tag[i];
        if (st == 1)
            a[i] = *--t.end(), t.erase(--t.end());
        else
            a[i] = *t.begin(), t.erase(t.begin());
    &amp;#125;
    for (int i = 1; i &amp;lt;= n; ++i)
        std::cout &amp;lt;&amp;lt; a[i] &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
    std::cout &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;정렬-게임&#34;&gt;정렬 게임&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://vjudge.net/problem/Baekjoon-13415#author=GPT_zh&#34; class=&#34;uri&#34;&gt;https://vjudge.net/problem/Baekjoon-13415#author=GPT_zh&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定序列 &lt;span class=&#34;math inline&#34;&gt;\(a_{1\cdots n}\)&lt;/span&gt;，维护 &lt;span class=&#34;math inline&#34;&gt;\(m\)&lt;/span&gt; 次操作，形如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;x y&lt;/code&gt;，将 &lt;span class=&#34;math inline&#34;&gt;\(a_{1\cdots x}\)&lt;/span&gt; 按升序排列，接着，对 &lt;span class=&#34;math inline&#34;&gt;\(a_{1\cdots y}\)&lt;/span&gt; 按降序排列。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;输出操作完成后的序列。&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(n,m\le 10^5,|V|=10^4\)&lt;/span&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;发现这个题严格弱于上一个题，没啥说的。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;入れ替えと並び替え&#34;&gt;入れ替えと並び替え&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/AT_past202005_n&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/AT_past202005_n&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定序列 &lt;span class=&#34;math inline&#34;&gt;\(a_{1\cdots n}\)&lt;/span&gt;，&lt;strong&gt;初始为 &lt;span class=&#34;math inline&#34;&gt;\(1,2,\cdots,n\)&lt;/span&gt;&lt;/strong&gt;，维护 &lt;span class=&#34;math inline&#34;&gt;\(m\)&lt;/span&gt; 次操作，形如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;0 x&lt;/code&gt;，交换 &lt;span class=&#34;math inline&#34;&gt;\(a_x\)&lt;/span&gt; 与 &lt;span class=&#34;math inline&#34;&gt;\(a_{x+1}\)&lt;/span&gt;。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;1 l r&lt;/code&gt;，将 &lt;span class=&#34;math inline&#34;&gt;\(a_{l\cdots r}\)&lt;/span&gt; 按升序排列。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;输出操作完成后的序列。&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(n,m\le 2\times 10^5\)&lt;/span&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;诈骗题⨉2&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;初始是有序的，保证了仅需要复原被打乱的项即可完成排序。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;维护每次&lt;strong&gt;交换&lt;/strong&gt;在 &lt;span class=&#34;math inline&#34;&gt;\((x-1,x)\)&lt;/span&gt;、&lt;span class=&#34;math inline&#34;&gt;\((x,x+1)\)&lt;/span&gt;、&lt;span class=&#34;math inline&#34;&gt;\((x+1,x+2)\)&lt;/span&gt; 三个位置创建 / 删除的逆序对。&lt;/p&gt;
&lt;p&gt;手玩发现操作给出的&lt;strong&gt;交换&lt;/strong&gt;和目的为复原的&lt;strong&gt;交换&lt;/strong&gt;都有可能带来新的逆序对。考虑势能分析。&lt;/p&gt;
&lt;p&gt;操作给出的&lt;strong&gt;交换&lt;/strong&gt;至多增加一个逆序对（势能），而一次目的为复原的&lt;strong&gt;交换&lt;/strong&gt;至少减少一个逆序对（势能）。&lt;/p&gt;
&lt;p&gt;故直接暴力复原范围内逆序对，复杂度 &lt;span class=&#34;math inline&#34;&gt;\(O(Q\log Q)\)&lt;/span&gt;。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;双向排序&#34;&gt;双向排序&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P8747&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P8747&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定排列 &lt;span class=&#34;math inline&#34;&gt;\(a_{1\cdots n}\)&lt;/span&gt;，&lt;strong&gt;初始为 &lt;span class=&#34;math inline&#34;&gt;\(1,2,\cdots,n\)&lt;/span&gt;&lt;/strong&gt;，维护 &lt;span class=&#34;math inline&#34;&gt;\(m\)&lt;/span&gt; 次操作，形如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;0 x&lt;/code&gt;，将 &lt;span class=&#34;math inline&#34;&gt;\(a_{1\cdots x}\)&lt;/span&gt; 按降序排列。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;1 x&lt;/code&gt;，将 &lt;span class=&#34;math inline&#34;&gt;\(a_{x\cdots n}\)&lt;/span&gt; 按升序排列。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;输出操作完成后的序列。&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(n,m\le 2\times 10^5\)&lt;/span&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;发现题目给的限制非常有意思，保证了最终序列一定满足前半截降序，后半截升序。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;需要发现一个可怕的事实：操作相当于选取分割点 &lt;span class=&#34;math inline&#34;&gt;\(pos\)&lt;/span&gt; 左 / 右侧最小的数并挪到对侧。&lt;/p&gt;
&lt;p&gt;维护每个点的 0/1 状态，线段树上二分并区间推平即可。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;另一个很强的线性做法：只维护 &lt;span class=&#34;math inline&#34;&gt;\(pos\)&lt;/span&gt; 左边的点值，那么操作可以看作：&lt;/p&gt;
&lt;p&gt;加入若干个最小的、不存在于左边的点 / 删除若干个存在于左边，且最小的点&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;用栈维护左边从小到大的所有连续段，每次加点暴力合并，删点则暴力删&lt;/p&gt;
&lt;p&gt;发现加点只会增加最多一个连续段，且枚举连续段合并之后会减少对应的势能；删点同理。&lt;/p&gt;
&lt;p&gt;故均摊线性。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://xsc062.netlify.app/20251104/</guid>
            <title>杂题</title>
            <link>https://xsc062.netlify.app/20251104/</link>
            <category>计数</category>
            <category>二分图</category>
            <category>DP 套 DP</category>
            <category>搜索</category>
            <pubDate>Tue, 04 Nov 2025 15:01:11 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;这么爱计数&lt;/p&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;a.-图-hdu4903-the-only-survival&#34;&gt;A. 图 / HDU4903 The only survival&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://vjudge.net/problem/HDU-4903#author=DeepSeek_zh&#34; class=&#34;uri&#34;&gt;https://vjudge.net/problem/HDU-4903#author=DeepSeek_zh&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;很容易想到基于按 dis 从小到大枚举的做法&lt;/p&gt;
&lt;p&gt;但是发现算方案就必须要知道每个点的具体 dis，就导致难以 DP，只能搜索，这样复杂度就不太好看。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;一个显然的观察：&lt;strong&gt;并不关心 &lt;span class=&#34;math inline&#34;&gt;\(1,n\)&lt;/span&gt; 以外点的标号&lt;/strong&gt;，所以可以把 &lt;span class=&#34;math inline&#34;&gt;\(O(n^k)\)&lt;/span&gt; 的暴搜优化到 &lt;span class=&#34;math inline&#34;&gt;\(O(\binom{n+k}k\cdot (n+k))\)&lt;/span&gt;，然后做多重集排列即可。&lt;/p&gt;
&lt;p&gt;模数非质时的多重集排列：&lt;a href=&#34;/20231117/#数学&#34;&gt;link&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
    std::freopen(&amp;quot;graph.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;graph.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, k, L, mod;
    std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; k &amp;gt;&amp;gt; L &amp;gt;&amp;gt; mod;
    if (L &amp;lt; k) &amp;#123;
        std::cout &amp;lt;&amp;lt; 0 &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
        return 0;
    &amp;#125;
    std::vector&amp;lt;std::vector&amp;lt;long long&amp;gt; &amp;gt; C(n + 1, std::vector&amp;lt;long long&amp;gt; (n + 1));
    C[0][0] = 1ll;
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        C[i][0] = 1ll;
        for (int j = 1; j &amp;lt;= i; ++j)
            C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % mod;
    &amp;#125;
    std::vector&amp;lt;int&amp;gt; dis(n + 1), s;
    int res = 0;
    std::function&amp;lt;void(int, int, long long)&amp;gt; DFS = [&amp;amp;](int x, int d, long long now) &amp;#123;
        if (x == n) &amp;#123;
            auto s0 = now, s1 = now;
            for (int i = 1; i &amp;lt; n; ++i)
                if (dis[i] &amp;gt;= k)
                    (s0 *= L) %= mod, (s1 *= L) %= mod;
                else if (L - (k - dis[i] - 1)) &amp;#123;
                    (s0 *= L - (k - dis[i] - 1)) %= mod;
                    (s1 *= L - (k - dis[i] - 1) - 1) %= mod;
                &amp;#125;
                else &amp;#123;
                    s0 = s1 = 0ll;
                    break;
                &amp;#125;
            dis[x] = k;
            auto u = 1ll;
            int cnt = n - 2;
            for (auto i : s)
                (u *= C[cnt][i]) %= mod, cnt -= i;
            (res += u * (s0 + mod - s1) % mod) %= mod;
            return;
        &amp;#125;
        for (int i = d; i &amp;lt;= k + 1; ++i) &amp;#123;
            auto s0 = now, s1 = now;
            for (int j = 1; j &amp;lt; x; ++j)
                if (dis[j] &amp;gt;= i)
                    (s0 *= L) %= mod, (s1 *= L) %= mod;
                else if (L - (i - dis[j] - 1)) &amp;#123;
                    (s0 *= L - (i - dis[j] - 1)) %= mod;
                    (s1 *= L - (i - dis[j] - 1) - 1) %= mod;
                &amp;#125;
                else &amp;#123;
                    s0 = s1 = 0ll;
                    break;
                &amp;#125;
            dis[x] = i;
            if (dis[x] != dis[x - 1])
                s.push_back(1);
            else
                ++s.back();
            if (i == k + 1)
                s1 = 0ll;
            DFS(x + 1, i, (s0 + mod - s1) % mod);
            if (dis[x] != dis[x - 1])
                s.pop_back();
            else
                --s.back();
        &amp;#125;
        return;
    &amp;#125;;
    DFS(2, 1, 1);
    std::cout &amp;lt;&amp;lt; res % mod &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;b.-路线-arc136e-non-coprime-dag&#34;&gt;B. 路线 / ARC136E Non-coprime DAG&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/AT_arc136_e&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/AT_arc136_e&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;做过 &lt;a href=&#34;https://www.luogu.com.cn/problem/CF870F&#34;&gt;CF870F Paths&lt;/a&gt; 可以很快反应过来：&lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 和 &lt;span class=&#34;math inline&#34;&gt;\(y\)&lt;/span&gt; 是否可以同时被选，取决于它们各自的最小质因子是否能在 &lt;span class=&#34;math inline&#34;&gt;\(x,y\)&lt;/span&gt; 之间交汇（或用 &lt;span class=&#34;math inline&#34;&gt;\(2\)&lt;/span&gt; 作跳板）。&lt;/p&gt;
&lt;p&gt;接着就发现由于 &lt;span class=&#34;math inline&#34;&gt;\(2\)&lt;/span&gt; 间隔出现，此时再分奇偶性就会显得非常合理。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;两个偶数总是不能同时被选；对于奇数 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 和偶数 &lt;span class=&#34;math inline&#34;&gt;\(y\)&lt;/span&gt;，要求 &lt;span class=&#34;math inline&#34;&gt;\(y\in [x-f(x)+1,x+f(x)-1]\)&lt;/span&gt;。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;考察奇数的选取。容易发现，钦定用 &lt;span class=&#34;math inline&#34;&gt;\(2\)&lt;/span&gt; 作跳板，则两个奇数 &lt;span class=&#34;math inline&#34;&gt;\(x,y(x&amp;lt;y)\)&lt;/span&gt; 能同时被选，当且仅当：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;记 &lt;span class=&#34;math inline&#34;&gt;\(f(i)\)&lt;/span&gt; 为 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 的最小质因子，则 &lt;span class=&#34;math inline&#34;&gt;\(x+f(x)&amp;gt; y-f(y)\)&lt;/span&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;发现实际上可以认为 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 代表区间 &lt;span class=&#34;math inline&#34;&gt;\([x-f(x),x+f(x)-1]\)&lt;/span&gt;。那么两个点可以同时被选当且仅当它们代表的区间有交（这样就去掉了 &lt;span class=&#34;math inline&#34;&gt;\(x,y\)&lt;/span&gt; 之间的偏序条件）&lt;/p&gt;
&lt;p&gt;这样发现对『代表区间』的定义，在奇数视角和偶数视角下是冲突的，可以发现偶数视角的区间更紧；事实上，应该采用 &lt;span class=&#34;math inline&#34;&gt;\([x-f(x)+1,x+f(x)-1]\)&lt;/span&gt; 这个看似充分不必要的定义，因为端点总是奇数，导致 &lt;span class=&#34;math inline&#34;&gt;\(x+f(x)&amp;gt; y-f(y)\)&lt;/span&gt; 和 &lt;span class=&#34;math inline&#34;&gt;\(x+f(x)-1&amp;lt;y-f(y)+1\)&lt;/span&gt; 不能同时成立。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;进一步推广结论，容易发现多个奇数可以同时被选，当且仅当它们代表的区间有交。故可以枚举值域中的点，找加权覆盖次数最大值。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n;
    std::cin &amp;gt;&amp;gt; n;
    std::vector&amp;lt;int&amp;gt; fac(n + 1), l(n + 1), r(n + 1);
    for (int i = 2; i &amp;lt;= n; ++i) &amp;#123;
        if (!fac[i]) &amp;#123;
            fac[i] = i;
            for (int j = 2 * i; j &amp;lt;= n; j += i)
                if (!fac[j])
                   fac[j] = i;
        &amp;#125;
        l[i] = std::max(1, i - fac[i] + 1);
        r[i] = std::min(i + fac[i] - 1, n);
    &amp;#125;
    std::vector&amp;lt;int&amp;gt; a(n + 1);
    std::vector&amp;lt;long long&amp;gt; dif(n + 1);
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        std::cin &amp;gt;&amp;gt; a[i];
        if (i == 1 || i % 2 == 0)
            continue;
        dif[l[i]] += a[i];
        if (r[i] != n)
            dif[r[i] + 1] -= a[i];
    &amp;#125;
    auto res = 0ll;
    std::partial_sum(dif.begin(), dif.end(), dif.begin());
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        auto now = a[1] + dif[i];
        if (i % 2 == 0)
            now += a[i];
        res = std::max(res, now);
    &amp;#125;
    std::cout &amp;lt;&amp;lt; res &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;a.-列车扫除&#34;&gt;A. 列车扫除&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.becoder.com.cn/contest/6708/problem/1&#34; class=&#34;uri&#34;&gt;https://www.becoder.com.cn/contest/6708/problem/1&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;绝对聪明的 A, B, C 在一起玩 Nim，有三堆石子 &lt;span class=&#34;math inline&#34;&gt;\(c_{1,2,3}\)&lt;/span&gt;，每次可以任选一堆拿走正整数个，不能拿的人扣一分，他的上一个人加一分。&lt;/p&gt;
&lt;p&gt;给定 &lt;span class=&#34;math inline&#34;&gt;\(q\)&lt;/span&gt; 次询问，形如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;现在知道 &lt;span class=&#34;math inline&#34;&gt;\(\forall \, i=1,2,3,c_i\in[l_i,r_i]\)&lt;/span&gt;。对于这 &lt;span class=&#34;math inline&#34;&gt;\(\prod_{i=1,2,3}r_i-l_i+1\)&lt;/span&gt; 种可能的情况，对于每个人，求出分数之和。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(q\le 10^6,V=10^9\)&lt;/span&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;容易发现，胜，平，负三个状态会被分给三个人，且一共只有三种分配方式。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;当只剩一堆石头时，操作者胜；石头状态为 &lt;span class=&#34;math inline&#34;&gt;\((0,1,1)\)&lt;/span&gt; 时，操作者负。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;b.-换来换去&#34;&gt;B. 换来换去&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.becoder.com.cn/contest/6708/problem/2&#34; class=&#34;uri&#34;&gt;https://www.becoder.com.cn/contest/6708/problem/2&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;对 &lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt; 个有标号的球任意分成任意组，组是无顺序的，且要求每组球个数 &lt;span class=&#34;math inline&#34;&gt;\(\ge 2\)&lt;/span&gt;，求方案数，对质数取模。&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(n\le 10^7\)&lt;/span&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;发现这是一个类斯特林数的问题，二项式反演得到答案式为：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
\sum_{i=0}^n (-1)^{n-i}\binom ni \sum_{j=0}^i \begin{Bmatrix} i\\ j\end{Bmatrix}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;用斯特林数通项展开：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
\sum_{i=0}^n (-1)^{n-i}\binom ni \sum_{j=0}^i \sum_{k=0}^j(-1)^{j-k}\dfrac {k^i}{(j-k)!\cdot k!}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;很容易注意到一个二项式定理的结构，故交换求和顺序：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
\sum_{j=0}^n \sum_{k=0}^j \dfrac {(-1)^{j-k}}{(j-k)!\cdot k!}\cdot \sum_{i=j}^n \binom ni (-1)^{n-i}k^i
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;发现一个很严重的问题在于 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 的起始范围是 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; 而不是 &lt;span class=&#34;math inline&#34;&gt;\(0\)&lt;/span&gt;，但如果我们把一开始的式子改写成这样：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
\sum_{i=0}^n (-1)^{n-i}\binom ni \sum_{j=0}^n \begin{Bmatrix} i\\ j\end{Bmatrix}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;容易发现当 &lt;span class=&#34;math inline&#34;&gt;\(j&amp;gt;i\)&lt;/span&gt; 时 &lt;span class=&#34;math inline&#34;&gt;\(\begin{Bmatrix} i\\ j\end{Bmatrix}=0\)&lt;/span&gt;，和原式的值相同，且斯特林数通项对于 &lt;span class=&#34;math inline&#34;&gt;\(j&amp;gt;i\)&lt;/span&gt; 也是成立的，故原式等价于&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
\begin{aligned}
&amp;amp;\sum_{j=0}^n \sum_{k=0}^j \dfrac {(-1)^{j-k}}{(j-k)!\cdot k!}\cdot \sum_{i=0}^n \binom ni (-1)^{n-i}k^i\\
=&amp;amp;\sum_{j=0}^n \sum_{k=0}^j \dfrac {(-1)^{j-k}}{(j-k)!\cdot k!}\cdot (k-1)^n\\
=&amp;amp;\sum_{k=0}^n \dfrac {(k-1)^n}{k!}\cdot \sum_{j=0}^{n-k} \dfrac {(-1)^j}{j!}\\
\end{aligned}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;后者内部与 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 无关，是可前缀和计算的，只需要考虑在 &lt;span class=&#34;math inline&#34;&gt;\(O(1)\)&lt;/span&gt; 内求出 &lt;span class=&#34;math inline&#34;&gt;\((k-1)^n\)&lt;/span&gt; 的值，筛一下，对于质数（约 &lt;span class=&#34;math inline&#34;&gt;\(\dfrac n{\ln n}\)&lt;/span&gt; 个）快速幂，合数用积性函数之类即可。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
    std::freopen(&amp;quot;card.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;card.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int T;
    for (std::cin &amp;gt;&amp;gt; T; T--; ) &amp;#123;
        int n, mod;
        std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; mod;
        std::vector&amp;lt;int&amp;gt; tag(n + 1), p, pw(n + 1);
        auto qkp = [&amp;amp;](long long x, int y) &amp;#123;
            auto res = 1ll;
            for (; y; (x *= x) %= mod, y &amp;gt;&amp;gt;= 1)
                if (y &amp;amp; 1)
                    (res *= x) %= mod;
            return res;
        &amp;#125;;
        pw[1] = 1ll;
        for (int i = 2; i &amp;lt;= n; ++i) &amp;#123;
            if (!tag[i]) &amp;#123;
                pw[i] = qkp(i, n);
                p.push_back(i);
            &amp;#125;
            for (auto j : p) &amp;#123;
                if (i &amp;gt; n / j)
                    break;
                tag[i * j] = 1;
                pw[i * j] = (long long)pw[i] * pw[j] % mod;
                if (i % j == 0)
                    break;
            &amp;#125;
        &amp;#125;
        std::vector&amp;lt;int&amp;gt; inv(n + 1), s(n + 1);
        inv[0] = 1ll;
        for (int j = 1; j &amp;lt;= n; ++j)
            inv[j] = (long long)inv[j - 1] * j % mod;
        inv[n] = qkp(inv[n], mod - 2);
        for (int j = n - 1; j; --j)
            inv[j] = (long long)inv[j + 1] * (j + 1) % mod;
        s[0] = inv[0];
        for (int j = 1; j &amp;lt;= n; ++j) &amp;#123;
            if (j &amp;amp; 1)
                s[j] = s[j - 1] + mod - inv[j];
            else
                s[j] = s[j - 1] + inv[j];
            if (s[j] &amp;gt;= mod)
                s[j] -= mod;
        &amp;#125;
        auto res = (long long)s[n] * ((n &amp;amp; 1) ? mod - 1 : 1);
        for (int k = 1; k &amp;lt;= n; ++k)
            res += (long long)pw[k - 1] * inv[k] % mod * s[n - k] % mod;
        std::cout &amp;lt;&amp;lt; res % mod &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    &amp;#125;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;c.-画家&#34;&gt;C. 画家&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.becoder.com.cn/contest/6714/problem/3&#34; class=&#34;uri&#34;&gt;https://www.becoder.com.cn/contest/6714/problem/3&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;ARC 特供删十字，故时光倒流，转化成在图上删相同颜色的十字 / 行 / 列。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;令 &lt;span class=&#34;math inline&#34;&gt;\(f_{i,j}\)&lt;/span&gt; 表示合法的 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 行 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; 列地图。发现同颜色的删行 + 删列会和直接删十字算重，&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;b.-灯光秀-cf1545c-aquamoon-and-permutations&#34;&gt;B. 灯光秀 / CF1545C AquaMoon and Permutations&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/CF1545C&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/CF1545C&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;第一步需要想到，如果某一列的某个数，只有一个排列有，那么这个排列必须被选入拉丁方；&lt;/p&gt;
&lt;p&gt;用这个必选的排列，可以排除掉一些与之冲突、不能选入拉丁方的排列。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;a.-bot-的能量堆&#34;&gt;A. bot 的能量堆&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.becoder.com.cn/contest/6731/problem/1&#34; class=&#34;uri&#34;&gt;https://www.becoder.com.cn/contest/6731/problem/1&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;⚡&lt;strong&gt;超越一切震慑凡人&lt;/strong&gt;⚡&lt;/p&gt;
&lt;p&gt;给定正整数 &lt;span class=&#34;math inline&#34;&gt;\(x,y\)&lt;/span&gt;，你可以执行下面三种操作：&lt;/p&gt;
&lt;ol type=&#34;1&#34;&gt;
&lt;li&gt;将 &lt;span class=&#34;math inline&#34;&gt;\(x,y\)&lt;/span&gt; 同时加 1；&lt;/li&gt;
&lt;li&gt;将 &lt;span class=&#34;math inline&#34;&gt;\(x,y\)&lt;/span&gt; 同时减一；&lt;/li&gt;
&lt;li&gt;对于 &lt;span class=&#34;math inline&#34;&gt;\(\gcd(x,y)\)&lt;/span&gt; 的一个质因子 &lt;span class=&#34;math inline&#34;&gt;\(p\)&lt;/span&gt;，将 &lt;span class=&#34;math inline&#34;&gt;\(x,y\)&lt;/span&gt; 同时除以 &lt;span class=&#34;math inline&#34;&gt;\(p\)&lt;/span&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;问最少花费多少次操作使得 &lt;span class=&#34;math inline&#34;&gt;\(\min(x,y)=1\)&lt;/span&gt;。多测。&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(T\le 300,1\le x,y\le 10^9\)&lt;/span&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;不妨先考虑 &lt;span class=&#34;math inline&#34;&gt;\(x\ne y\)&lt;/span&gt; 的情况，发现三种操作都不会使 &lt;span class=&#34;math inline&#34;&gt;\(x,y\)&lt;/span&gt; 的相对大小关系改变。故令 &lt;span class=&#34;math inline&#34;&gt;\(x&amp;lt;y\)&lt;/span&gt;，考虑让 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 变为 1。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;记 &lt;span class=&#34;math inline&#34;&gt;\(d=y-x\)&lt;/span&gt;， 很容易注意到 &lt;span class=&#34;math inline&#34;&gt;\(d\)&lt;/span&gt; 的值不会在前两种操作中改变，由辗转相减，&lt;span class=&#34;math inline&#34;&gt;\(\gcd(x,y)=\gcd(d, x)\)&lt;/span&gt;，即操作三每次选取的 &lt;span class=&#34;math inline&#34;&gt;\(p\)&lt;/span&gt; 总是 &lt;span class=&#34;math inline&#34;&gt;\(d\)&lt;/span&gt; 的质因子，且总能通过若干次操作 1/2 让 &lt;span class=&#34;math inline&#34;&gt;\(p\)&lt;/span&gt; 能够执行。&lt;/p&gt;
&lt;p&gt;每次执行操作 3 后，&lt;span class=&#34;math inline&#34;&gt;\(d\gets d\div p\)&lt;/span&gt;，每次只需让 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 变为 &lt;span class=&#34;math inline&#34;&gt;\(\lfloor \frac xp\rfloor\)&lt;/span&gt; 或 &lt;span class=&#34;math inline&#34;&gt;\(\lceil \frac xp\rceil\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;直接记搜的话，容易发现状态总数是 V 因数总数。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;对于 &lt;span class=&#34;math inline&#34;&gt;\(x=y\)&lt;/span&gt; 的情况，答案至多为 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 的质因子数量。暴搜 + 剪枝非常可过。&lt;/p&gt;
&lt;details&gt;
&lt;p&gt;&lt;summary&gt;有一种神秘的处理方式…&lt;/summary&gt;&lt;/p&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;if (x == y) &amp;#123;
    auto calc = [&amp;amp;](int x) &amp;#123;
        int cnt = 0;
        for (int i = 2; i * i &amp;lt;= x; ++i)
            for (; x % i == 0; ++cnt, x /= i);
        return cnt + (x != 1);
    &amp;#125;;
    int to = calc(x), res = to;
    for (int i = std::max(x - to, 1); i &amp;lt;= x + to; ++i)
        res = std::min(res, calc(i) + std::abs(i - x));
    std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    continue;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;容易发现这东西没什么道理，反例大概率存在但在小范围内确实难以构造。总之数据没卡到。&lt;/p&gt;
&lt;/details&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;b.-bot-的矩阵&#34;&gt;B. bot 的矩阵&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.becoder.com.cn/contest/6731/problem/2&#34; class=&#34;uri&#34;&gt;https://www.becoder.com.cn/contest/6731/problem/2&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;有一个 &lt;span class=&#34;math inline&#34;&gt;\(n\times n\)&lt;/span&gt; 的二维数组，初始只知道 &lt;span class=&#34;math inline&#34;&gt;\(m\)&lt;/span&gt; 个位置的数 &lt;span class=&#34;math inline&#34;&gt;\(a_{x,y}\)&lt;/span&gt;，以及每行、每列的元素和 &lt;span class=&#34;math inline&#34;&gt;\(sx_{1\cdots n},sy_{1\cdots n}\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;构造出一个合法的解，每个数在 &lt;span class=&#34;math inline&#34;&gt;\([-2^63,2^63)\)&lt;/span&gt; 内。&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(n\le 2000\)&lt;/span&gt;,&lt;span class=&#34;math inline&#34;&gt;\(a_{x,y},sx_i,sy_i\in [-10^9,10^9]\)&lt;/span&gt;，&lt;span class=&#34;math inline&#34;&gt;\(m\le n^2\)&lt;/span&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;听说很容易想到二分图，但实在反应不过来。但在乱填的时候发现，如果出现了『必填』的情况，是一个行列交错的链式反应，这样就很容易想到二分图了&lt;/p&gt;
&lt;p&gt;原理是同时影响行 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 列 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; 的元素只有 &lt;span class=&#34;math inline&#34;&gt;\((i, j)\)&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;相当于给一个 &lt;span class=&#34;math inline&#34;&gt;\(2n\)&lt;/span&gt; 个点 &lt;span class=&#34;math inline&#34;&gt;\(n^2\)&lt;/span&gt; 条边的二分图，其中一些边权是已知的，那么不妨认为这些边被删除了&lt;/p&gt;
&lt;p&gt;同时也是一个 &lt;span class=&#34;math inline&#34;&gt;\(n^2\)&lt;/span&gt; 个元，&lt;span class=&#34;math inline&#34;&gt;\(2n-1\)&lt;/span&gt; 个方程的方程组（&lt;span class=&#34;math inline&#34;&gt;\(sx=sy\)&lt;/span&gt; 会消掉一条方程）；故很多元其实可以直接赋 &lt;span class=&#34;math inline&#34;&gt;\(0\)&lt;/span&gt;，只拿 &lt;span class=&#34;math inline&#34;&gt;\(2n-1\)&lt;/span&gt; 个元出来解方程。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在挖掉已知边的二分图上任意找生成树（森林）就可以满足 &lt;span class=&#34;math inline&#34;&gt;\(2n-1\)&lt;/span&gt; 的限制，结合树上高斯消元，从叶子开始解方程即可。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
#define int long long
#define nec getchar
void read(int &amp;amp;x) &amp;#123;
    x = 0;
    char ch = nec();
    bool flag = false;
    for (; ch &amp;lt; &amp;#39;0&amp;#39; || ch &amp;gt; &amp;#39;9&amp;#39;; ch = nec())
        if (ch == &amp;#39;-&amp;#39;)
            flag = true;
    for (; ch &amp;gt;= &amp;#39;0&amp;#39; &amp;amp;&amp;amp; ch &amp;lt;= &amp;#39;9&amp;#39;; ch = nec())
        x = x * 10 + ch - &amp;#39;0&amp;#39;;
    if (flag)
        x = -x;
    return;
&amp;#125;
signed main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;matrix3.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int T;
    for (read(T); T--; ) &amp;#123;
        int n, m;
        read(n), read(m);
        std::vector&amp;lt;int&amp;gt; sx(n + 1), sy(n + 1);
        for (int i = 1; i &amp;lt;= n; ++i)
            read(sx[i]);
        for (int i = 1; i &amp;lt;= n; ++i)
            read(sy[i]);
        std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; vis(n + 1, std::vector&amp;lt;int&amp;gt; (n + 1));
        std::vector&amp;lt;std::vector&amp;lt;long long&amp;gt; &amp;gt; a(n + 1, std::vector&amp;lt;long long&amp;gt; (n + 1));
        std::vector&amp;lt;int&amp;gt; tx(n + 1), ty(n + 1);
        auto work = [&amp;amp;](int i, int j, int c) &amp;#123;
            vis[i][j] = 1;
            ++tx[i], ++ty[j];
            sx[i] -= c, sy[j] -= c, a[i][j] = c;
            return;
        &amp;#125;;
        for (int x, y, c; m--; ) &amp;#123;
            read(x), read(y), read(c);
            work(x, y, c);
        &amp;#125;
        if (std::accumulate(sx.begin() + 1, sx.end(), 0ll) != std::accumulate(sy.begin() + 1, sy.end(), 0ll)) &amp;#123;
            std::cout &amp;lt;&amp;lt; &amp;quot;NoSolution!&amp;quot; &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
            continue;
        &amp;#125;
        std::vector&amp;lt;int&amp;gt; fx(n + 1), fy(n + 1);
        std::function&amp;lt;bool(void)&amp;gt; check = [&amp;amp;](void) &amp;#123;
            for (int x = 1; x &amp;lt;= n; ++x)
                if (!fx[x]) &amp;#123;
                    if (tx[x] == n) &amp;#123;
                        if (sx[x] != 0)
                            return false;
                        fx[x] = 1;
                        if (!check())
                            return false;
                    &amp;#125;
                    else if (tx[x] == n - 1) &amp;#123;
                        for (int y = 1; y &amp;lt;= n; ++y)
                            if (!vis[x][y]) &amp;#123;
                                work(x, y, sx[x]);
                                fx[x] = 1;
                                if (!check())
                                    return false;
                            &amp;#125;
                    &amp;#125;
                &amp;#125;
            for (int y = 1; y &amp;lt;= n; ++y)
                if (!fy[y]) &amp;#123;
                    if (ty[y] == n) &amp;#123;
                        if (sy[y] != 0)
                            return false;
                        fy[y] = 1;
                        if (!check())
                            return false;
                    &amp;#125;
                    else if (ty[y] == n - 1) &amp;#123;
                        for (int x = 1; x &amp;lt;= n; ++x)
                            if (!vis[x][y]) &amp;#123;
                                work(x, y, sy[y]);
                                fy[y] = 1;
                                if (!check())
                                    return false;
                            &amp;#125;
                    &amp;#125;
                &amp;#125;
            return true;
        &amp;#125;;
        if (!check()) &amp;#123;
            std::cout &amp;lt;&amp;lt; &amp;quot;NoSolution!&amp;quot; &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
            continue;
        &amp;#125;
        std::function&amp;lt;void(int, int)&amp;gt; DFS = [&amp;amp;](int x, int op) &amp;#123;
            if (op == 0) &amp;#123;
                fx[x] = 1;
                for (int i = 1; i &amp;lt;= n; ++i)
                    if (!vis[x][i] &amp;amp;&amp;amp; !fy[i]) &amp;#123;
                        DFS(i, 1);
                        work(x, i, sy[i]);
                    &amp;#125;
            &amp;#125;
            else &amp;#123;
                fy[x] = 1;
                for (int i = 1; i &amp;lt;= n; ++i)
                    if (!vis[i][x] &amp;amp;&amp;amp; !fx[i]) &amp;#123;
                        DFS(i, 0);
                        work(i, x, sx[i]);
                    &amp;#125;
            &amp;#125;
            return;
        &amp;#125;;
        for (int i = 1; i &amp;lt;= n; ++i)
            if (!fx[i])
                DFS(i, 0);
        for (int i = 1; i &amp;lt;= n; ++i)
            if (!fy[i])
                DFS(i, 1);
        std::cout &amp;lt;&amp;lt; &amp;quot;Botany!&amp;quot; &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
        for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
            for (int j = 1; j &amp;lt;= n; ++j)
                std::cout &amp;lt;&amp;lt; a[i][j] &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
            std::cout &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
        &amp;#125;
    &amp;#125;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;a.-数码串&#34;&gt;A. 数码串&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.becoder.com.cn/contest/6736/problem/1&#34; class=&#34;uri&#34;&gt;https://www.becoder.com.cn/contest/6736/problem/1&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定一个长度为 &lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt; 的数字串，现在需要给它分为若干段，问在所有 &lt;span class=&#34;math inline&#34;&gt;\(2^{n-1}\)&lt;/span&gt; 种分段方式中，有多少种满足：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在任意相邻的两段中，有至少一段，其对应的十进制数是 &lt;span class=&#34;math inline&#34;&gt;\(D\)&lt;/span&gt; 的倍数。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;答案对 &lt;span class=&#34;math inline&#34;&gt;\(10^9+7\)&lt;/span&gt; 取模。&lt;/p&gt;
&lt;p&gt;多测，&lt;span class=&#34;math inline&#34;&gt;\(n\le 2\times 10^5,D\le 10^6,T\le 100\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;部分分特殊性质&lt;/strong&gt;：&lt;span class=&#34;math inline&#34;&gt;\(\gcd(D,10)=1\)&lt;/span&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;发现若 &lt;span class=&#34;math inline&#34;&gt;\(a_{l\cdots r}\)&lt;/span&gt; 是 &lt;span class=&#34;math inline&#34;&gt;\(D\)&lt;/span&gt; 的倍数，记 &lt;span class=&#34;math inline&#34;&gt;\(s_i=s_{i+1}+a_i\times 10^{n-i}\)&lt;/span&gt;，那么 &lt;span class=&#34;math inline&#34;&gt;\(\dfrac{s_l-s_{r+1}}{10^{n-r}}\bmod D=0\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;题目要求，这个转移点和上个转移点，至少有一个满足该式。显然可以类 DP 地做。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;对于 &lt;span class=&#34;math inline&#34;&gt;\(D\)&lt;/span&gt; 与 &lt;span class=&#34;math inline&#34;&gt;\(10\)&lt;/span&gt; 互质的情况，原条件等价于 &lt;span class=&#34;math inline&#34;&gt;\(s_l\equiv s_{r+1}\pmod D\)&lt;/span&gt;，用一个桶记录 DP 值即可&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;记 &lt;span class=&#34;math inline&#34;&gt;\(D=2^*\times 5^?\times m\)&lt;/span&gt;，发现 &lt;span class=&#34;math inline&#34;&gt;\(m\)&lt;/span&gt; 与 &lt;span class=&#34;math inline&#34;&gt;\(10\)&lt;/span&gt; 互质，或许可以套用上方的做法&lt;/p&gt;
&lt;p&gt;&lt;mark&gt;由于 &lt;span class=&#34;math inline&#34;&gt;\(D\le 10^6 &amp;lt; 2^{20}\)&lt;/span&gt;，对于一个固定的 &lt;span class=&#34;math inline&#34;&gt;\(r\)&lt;/span&gt;，所有 &lt;span class=&#34;math inline&#34;&gt;\(l\le r-20\)&lt;/span&gt; 项的 &lt;span class=&#34;math inline&#34;&gt;\(a_l\)&lt;/span&gt; 对 &lt;span class=&#34;math inline&#34;&gt;\(a_{l\cdots r}\bmod (2^*\times 5^?)\)&lt;/span&gt; 的贡献总是 &lt;span class=&#34;math inline&#34;&gt;\(0\)&lt;/span&gt;&lt;/mark&gt;，故在只考虑 &lt;span class=&#34;math inline&#34;&gt;\(2^*\times 5^?\)&lt;/span&gt; 时， &lt;span class=&#34;math inline&#34;&gt;\(l\le r-20\)&lt;/span&gt; 的可选性和 &lt;span class=&#34;math inline&#34;&gt;\(l=r-20\)&lt;/span&gt; 的可选性相同。只需要对于 &lt;span class=&#34;math inline&#34;&gt;\(\bmod m\)&lt;/span&gt; 沿用桶做法即可。&lt;/p&gt;
&lt;p&gt;对于 &lt;span class=&#34;math inline&#34;&gt;\(l\ge r-20\)&lt;/span&gt;，暴力即可，复杂度 &lt;span class=&#34;math inline&#34;&gt;\(O(T(n+D))\)&lt;/span&gt;。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;p&gt;注意 &lt;span class=&#34;math inline&#34;&gt;\(s_l-s_{r+1}\)&lt;/span&gt; 里的 &lt;span class=&#34;math inline&#34;&gt;\(r+1\)&lt;/span&gt;，调成鸲了&lt;/p&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int mod = 1e9 + 7;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
    std::freopen(&amp;quot;digit.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;digit.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#else
    std::freopen(&amp;quot;./test/20251113/digit/ex_digit1.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int T;
    std::vector&amp;lt;std::array&amp;lt;long long, 2&amp;gt; &amp;gt; c(1e6);
    for (std::cin &amp;gt;&amp;gt; T; T--; ) &amp;#123;
        std::string a;
        int d, n, m, p;
        std::cin &amp;gt;&amp;gt; a &amp;gt;&amp;gt; d, n = (int)a.length();
        a = &amp;quot;#&amp;quot; + a;
        std::vector&amp;lt;std::vector&amp;lt;long long&amp;gt; &amp;gt; f(n + 1, std::vector&amp;lt;long long&amp;gt; (2));
        f[0][0] = 1ll;
        m = d;
        for (; m % 2 == 0; m /= 2);
        for (; m % 5 == 0; m /= 5);
        p = d / m;
        for (int i = 0; i &amp;lt; m; ++i)
            c[i][0] = c[i][1] = 0ll;
        std::vector&amp;lt;int&amp;gt; s(n + 2);
        for (int i = n, k = 1; i; --i, (k *= 10) %= m)
            s[i] = (s[i + 1] + (a[i] - &amp;#39;0&amp;#39;) * k) % m;
        auto s0 = 0ll;
        for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
            int now = 0;
            for (int j = i, k = 1; j &amp;gt; i - 20 &amp;amp;&amp;amp; j; --j, (k *= 10) %= d) &amp;#123;
                (now += (a[j] - &amp;#39;0&amp;#39;) * k) %= d;
                if (now == 0)
                    (f[i][0] += f[j - 1][0] + f[j - 1][1]) %= mod;
                else
                    (f[i][1] += f[j - 1][0]) %= mod;
            &amp;#125;
            if (i &amp;gt; 20) &amp;#123;
                (c[s[i - 20]][0] += f[i - 21][0]) %= mod;
                (c[s[i - 20]][1] += f[i - 21][1]) %= mod;
                (s0 += f[i - 21][0]) %= mod;
                int now = 0;
                for (int j = i, k = 1; j &amp;gt;= i - 20; --j, (k *= 10) %= p)
                    (now += (a[j] - &amp;#39;0&amp;#39;) * k) %= p;
                if (now == 0) &amp;#123;
                    (f[i][0] += c[s[i + 1]][0] + c[s[i + 1]][1]) %= mod;
                    (f[i][1] += s0 + mod - c[s[i + 1]][0]) %= mod;
                &amp;#125;
                else
                    (f[i][1] += s0) %= mod;
            &amp;#125;
        &amp;#125;
        std::cout &amp;lt;&amp;lt; (f[n][0] + f[n][1]) % mod &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    &amp;#125;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;b.-背包&#34;&gt;B. 背包&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.becoder.com.cn/contest/6736/problem/2&#34; class=&#34;uri&#34;&gt;https://www.becoder.com.cn/contest/6736/problem/2&lt;/a&gt;&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://xsc062.netlify.app/20251103/</guid>
            <title>练习：数数 &amp; 容斥</title>
            <link>https://xsc062.netlify.app/20251103/</link>
            <category>计数</category>
            <category>容斥</category>
            <category>二项式反演</category>
            <pubDate>Mon, 03 Nov 2025 11:59:00 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;数数，但是性质题&lt;/p&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;a---reversi-2&#34;&gt;A - Reversi 2&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/AT_arc189_a&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/AT_arc189_a&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;操作可以看成，任选一个点，找到两侧最近的颜色相异的点，进行推平。&lt;/p&gt;
&lt;p&gt;或，任选一个极长连续段，推平为其两端的颜色。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;很容易注意到最终序列被分为若干个极长连续段，彼此独立。对于起始序列，容易发现任意区间中的任意操作会减少 2 的不同段数量（故显然最终序列连续段长度应该为奇数，且两端颜色和目标颜色一致）。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;令 &lt;span class=&#34;math inline&#34;&gt;\(f_i\)&lt;/span&gt; 为长度为 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 的连续段被推平的方案数（&lt;span class=&#34;math inline&#34;&gt;\(i\bmod2=1\)&lt;/span&gt;），那么有 &lt;span class=&#34;math inline&#34;&gt;\(f_i=(i - 2)\times f_{i-2}\)&lt;/span&gt;。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;最终方案数应为所有极长段方案的多重集排列乘上它们各自独立方案数之积。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int mod = 998244353;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::syns_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n;
    std::cin &amp;gt;&amp;gt; n;
    std::vector&amp;lt;int&amp;gt; a(n + 1);
    std::vector&amp;lt;long long&amp;gt; f(n + 1), fac(n + 1), inv(n + 1);
    fac[0] = inv[0] = 1ll;
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        std::cin &amp;gt;&amp;gt; a[i];
        fac[i] = fac[i - 1] * i % mod;
    &amp;#125;
    auto qkp = [&amp;amp;](long long x, int y) &amp;#123;
        auto res = 1ll;
        for (; y; (x *= x) %= mod, y &amp;gt;&amp;gt;= 1)
            if (y &amp;amp; 1)
                (res *= x) %= mod;
        return res;
    &amp;#125;;
    inv[n] = qkp(fac[n], mod - 2);
    for (int i = n - 1; i; --i)
        inv[i] = inv[i + 1] * (i + 1) % mod;
    f[1] = 1;
    for (int i = 3; i &amp;lt;= n; i += 2)
        f[i] = f[i - 2] * (i - 2) % mod;
    auto res = 1ll;
    int L = 1, cnt = 0;
    for (int i = 1; i &amp;lt;= n; ++i)
        if (i == n || a[i + 1] != a[i]) &amp;#123;
            if (a[i] != i % 2 || (i - L + 1) % 2 == 0) &amp;#123;
                std::cout &amp;lt;&amp;lt; 0 &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
                return 0;
            &amp;#125;
            (res *= f[i - L + 1]) %= mod;
            (res *= inv[(i - L) / 2]) %= mod;
            cnt += (i - L) / 2;
            L = i + 1;
        &amp;#125;
    std::cout &amp;lt;&amp;lt; res * fac[cnt] % mod &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;b---cigar-box&#34;&gt;B - Cigar Box&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/AT_arc112_e&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/AT_arc112_e&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;发现一个数的状态只取决于，最后一次以它为主体的操作，及这次操作之后的所有操作&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;进一步地发现，按最后一次操作分类，可以分为，向左（&lt;code&gt;L&lt;/code&gt;）、向右（&lt;code&gt;R&lt;/code&gt;）、没被操作过（&lt;code&gt;M&lt;/code&gt;）三种类型。&lt;/p&gt;
&lt;p&gt;可以很显然地注意到，最终序列一定是 &lt;code&gt;LLLMMMRRR&lt;/code&gt; 的形式，其中，仅要求 &lt;code&gt;M&lt;/code&gt; 是递增的；现在需要计算有多少长度为 &lt;span class=&#34;math inline&#34;&gt;\(m\)&lt;/span&gt; 的操作序列对应所有的 &lt;code&gt;LMR&lt;/code&gt; 序列（如果认为所有的 &lt;code&gt;M&lt;/code&gt; 始终是不动的可能会更好理解）。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;发现同种类数间，『最后一次操作』的相对顺序是固定的。进一步会发现这其实是&lt;a href=&#34;https://oi-wiki.org/math/combinatorics/stirling/&#34;&gt;第二类斯特林数&lt;/a&gt;，最后答案为：&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
\sum_{L,R}\binom{L+R}{L}\cdot \begin{Bmatrix}m\\ L+R\end{Bmatrix}\cdot 2^{m-L-R}
\]&lt;/span&gt;&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int mod = 998244353;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::syns_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, m;
    std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
    using arr = std::vector&amp;lt;long long&amp;gt;;
    arr pw(m + 1), fac(m + 1), inv(m + 1);
    std::vector&amp;lt;arr&amp;gt; f(m + 1, arr(m + 1));
    std::vector&amp;lt;int&amp;gt; a(n + 1);
    std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; ok(n + 1, std::vector&amp;lt;int&amp;gt; (n + 1));
    for (int i = 1; i &amp;lt;= n; ++i)
        std::cin &amp;gt;&amp;gt; a[i];
    for (int l = 1; l &amp;lt;= n; ++l)
        for (int r = l; r &amp;lt;= n; ++r)
            if (r == l || a[r] &amp;gt; a[r - 1])
                ok[l][r] = 1;
            else
                break;
    f[1][1] = 1ll, pw[0] = fac[0] = inv[0] = 1ll;
    for (int i = 2; i &amp;lt;= m; ++i)
        for (int j = 1; j &amp;lt;= i; ++j)
            f[i][j] = (f[i - 1][j - 1] + f[i - 1][j] * j) % mod;
    for (int i = 1; i &amp;lt;= m; ++i) &amp;#123;
        pw[i] = pw[i - 1] * 2 % mod;
        fac[i] = fac[i - 1] * i % mod;
    &amp;#125;
    auto qkp = [&amp;amp;](long long x, int y) &amp;#123;
        auto res = 1ll;
        for (; y; (x *= x) %= mod, y &amp;gt;&amp;gt;= 1)
            if (y &amp;amp; 1)
                (res *= x) %= mod;
        return res;
    &amp;#125;;
    inv[m] = qkp(fac[m], mod - 2);
    for (int i = m - 1; i; --i)
        inv[i] = inv[i + 1] * (i + 1) % mod;
    auto C = [&amp;amp;](int n, int m) &amp;#123;
        return fac[n] * inv[m] % mod * inv[n - m] % mod;
    &amp;#125;;
    auto res = 0ll;
    for (int L = 0; L &amp;lt;= m &amp;amp;&amp;amp; L &amp;lt;= n; ++L)
        for (int R = 0; L + R &amp;lt;= m &amp;amp;&amp;amp; L + R &amp;lt;= n; ++R)
            if (L + 1 &amp;gt; n - R || ok[L + 1][n - R])
                res += C(L + R, L) * f[m][L + R] % mod * pw[m - L - R] % mod;
    std::cout &amp;lt;&amp;lt; res % mod &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;c---swap-characters&#34;&gt;C - Swap Characters&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/AT_arc168_c&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/AT_arc168_c&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;考虑值域为 &lt;span class=&#34;math inline&#34;&gt;\(0\)&lt;/span&gt; 和 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt; 的情况&lt;/p&gt;
&lt;p&gt;发现这个很唐 &lt;del&gt;好险，AI 差点比我先做出来了&lt;/del&gt;，转化成枚举操作次数 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt;，答案是&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
\sum_{i\le\min(s_0,s_1)}\binom{s_0}{i}\cdot\binom{s_1}{i}
\]&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;根据这个可以得到启发，发现所谓任意交换可以转化为，每个字母的支出和收入相等，故考虑画个表：&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;a---leq-and-neq-non-equal-neighbours&#34;&gt;A - LEQ and NEQ / Non-equal Neighbours&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/AT_arc115_e&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/AT_arc115_e&lt;/a&gt; / &lt;a href=&#34;https://www.luogu.com.cn/problem/CF1591F&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/CF1591F&lt;/a&gt; / &lt;a href=&#34;https://www.luogu.com.cn/problem/CF1585F&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/CF1585F&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;容斥，钦定有 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 对相同元素，那么答案为 &lt;span class=&#34;math inline&#34;&gt;\(\sum\limits_{i=0}^{n-1} (-1)^{n-1-i} \cdot g_i\)&lt;/span&gt;，其中 &lt;span class=&#34;math inline&#34;&gt;\(g_i\)&lt;/span&gt; 表示至少有 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 对相同元素的方案数。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;考虑 &lt;span class=&#34;math inline&#34;&gt;\(g_i\)&lt;/span&gt; 的计算，朴素的做法是二维 DP，令 &lt;span class=&#34;math inline&#34;&gt;\(f_{i, j}\)&lt;/span&gt; 表示 DP 到 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt;，已经有了至多 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; 对不同元素的方案数（发现这样才更好 DP）。发现没啥好的 &lt;span class=&#34;math inline&#34;&gt;\(O(n^2)\)&lt;/span&gt; 转移，只能 &lt;span class=&#34;math inline&#34;&gt;\(O(n^3)\)&lt;/span&gt;：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
f_{i,j}=\sum_{k&amp;lt;i}f_{k, j-1}\times \min\{A_{k+1\cdots i}\}
\]&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;一个适用于容斥 DP 的 nb 优化：发现系数只取决于 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; 维的奇偶性，发现转移也只关注奇偶性，故设 &lt;span class=&#34;math inline&#34;&gt;\(f_{i,0/1}\)&lt;/span&gt; 减少一维。&lt;/p&gt;
&lt;p&gt;同时，很显然存在一个单调栈优化的结构，这样就可以在 &lt;span class=&#34;math inline&#34;&gt;\(O(n)\)&lt;/span&gt; 内完成 DP。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int mod = 998244353;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n;
    std::cin &amp;gt;&amp;gt; n;
    std::vector&amp;lt;int&amp;gt; a(n + 1);
    for (int i = 1; i &amp;lt;= n; ++i)
        std::cin &amp;gt;&amp;gt; a[i];
    struct node &amp;#123; int mn; long long c0, c1; &amp;#125;;
    std::stack&amp;lt;node&amp;gt; st;
    std::vector&amp;lt;std::array&amp;lt;long long, 2&amp;gt; &amp;gt; f(n + 1);
    f[0][0] = 1ll, f[0][1] = 0ll;
    auto s0 = 0x3f3f3f3fll, s1 = 0ll;
    st.push(&amp;#123; 0x3f3f3f3f, 1ll, 0ll &amp;#125;);
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        auto p0 = 0ll, p1 = 0ll;
        for (; !st.empty(); ) &amp;#123;
            auto [mn, c0, c1] = st.top();
            if (mn &amp;lt;= a[i])
                break;
            st.pop();
            p0 += c0, p1 += c1;
            (s0 += mod - c0 * (mn - a[i]) % mod) %= mod;
            (s1 += mod - c1 * (mn - a[i]) % mod) %= mod;
        &amp;#125;
        st.push(&amp;#123; a[i], p0 % mod, p1 % mod &amp;#125;);
        f[i][0] = s1, f[i][1] = s0;
        (s0 += f[i][0] * 0x3f3f3f3f % mod) %= mod;
        (s1 += f[i][1] * 0x3f3f3f3f % mod) %= mod;
        st.push(&amp;#123; 0x3f3f3f3f, f[i][0], f[i][1] &amp;#125;);
    &amp;#125;
    std::cout &amp;lt;&amp;lt; (f[n][n &amp;amp; 1] + mod - f[n][(n &amp;amp; 1) ^ 1]) % mod &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;b---unbranched&#34;&gt;B - Unbranched&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/AT_abc180_f&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/AT_abc180_f&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;注意到只会有环和链两种情况。发现消耗的点数和边数是不同的，再加上题目有边数限制，令 &lt;span class=&#34;math inline&#34;&gt;\(f_{i,j}\)&lt;/span&gt; 表示消耗了 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 个点 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; 条边时的方案数。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;转移是显然的：&lt;/p&gt;
&lt;p&gt;对于环的情况，答案为圆排列去掉翻折，即 &lt;span class=&#34;math inline&#34;&gt;\(\dfrac {(k-1)!}2\)&lt;/span&gt;。特别地，二元环的圆排列不存在翻折，故答案为 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;对于链的情况，去掉翻折即可，答案为 &lt;span class=&#34;math inline&#34;&gt;\(\dfrac {k!}2\)&lt;/span&gt;。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;去重，参考典型的图计数问题，钦定没被选的点中，标号最小的必须被选，所以会有 &lt;span class=&#34;math inline&#34;&gt;\(C(n-(i-k)-1,k-1)\)&lt;/span&gt; 的系数。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;显然对于最大值恰好为 &lt;span class=&#34;math inline&#34;&gt;\(L\)&lt;/span&gt; 的限制可以直接记一个 &lt;code&gt;bool&lt;/code&gt; 量在状态里；尊重一下容斥的标题，用 &lt;span class=&#34;math inline&#34;&gt;\(L\)&lt;/span&gt; 的答案减去 &lt;span class=&#34;math inline&#34;&gt;\(L-1\)&lt;/span&gt; 的答案亦可。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int mod = 1e9 + 7;
const int inv2 = (mod + 1) &amp;gt;&amp;gt; 1;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, m, L;
    std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m &amp;gt;&amp;gt; L;
    using arr = std::vector&amp;lt;long long&amp;gt;;
    using brr = std::vector&amp;lt;arr&amp;gt;;
    using crr = std::vector&amp;lt;brr&amp;gt;;
    arr fac(n + 1);
    brr C(n + 1, arr(n + 1));
    fac[0] = 1ll, C[0][0] = 1ll;
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        C[i][0] = 1ll;
        fac[i] = fac[i - 1] * i % mod;
        for (int j = 1; j &amp;lt;= i; ++j)
            C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % mod;
    &amp;#125;
    crr f(n + 1, brr(m + 1, arr(2)));
    f[0][0][0] = 1ll;
    auto work = [&amp;amp;](int i, int j, int k, int p1, int p2) &amp;#123;
        if (k == 1)
            f[i][j][p2] += f[i - 1][j][p1];
        else if (k == 2) &amp;#123;
            if (j &amp;gt;= 2)
                f[i][j][p2] += f[i - 2][j - 2][p1] * C[n - (i - k) - 1][k - 1] % mod; 
            if (j &amp;gt;= 1)
                f[i][j][p2] += f[i - 2][j - 1][p1] * C[n - (i - k) - 1][k - 1] % mod;
        &amp;#125;
        else &amp;#123;
            if (j &amp;gt;= k)
                f[i][j][p2] += f[i - k][j - k][p1] * C[n - (i - k) - 1][k - 1] % mod * fac[k - 1] % mod * inv2 % mod;
            if (j &amp;gt;= k - 1)
                f[i][j][p2] += f[i - k][j - k + 1][p1] * C[n - (i - k) - 1][k - 1] % mod * fac[k] % mod * inv2 % mod;
        &amp;#125;
        return;
    &amp;#125;;
    for (int i = 1; i &amp;lt;= n; ++i)
        for (int j = 0; j &amp;lt;= m; ++j) &amp;#123;
            for (int k = 1; k &amp;lt;= i &amp;amp;&amp;amp; k &amp;lt;= L; ++k)
                if (k == L)
                    work(i, j, k, 0, 1), work(i, j, k, 1, 1);
                else
                    work(i, j, k, 0, 0), work(i, j, k, 1, 1);
            f[i][j][0] %= mod, f[i][j][1] %= mod;
        &amp;#125;
    std::cout &amp;lt;&amp;lt; f[n][m][1] &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;c---局部极小值&#34;&gt;C - 局部极小值&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P3160&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P3160&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;重要性质：一个合法棋盘，&lt;code&gt;X&lt;/code&gt; 的数量不会超过八个，故一个想法是只考虑 &lt;code&gt;X&lt;/code&gt; 填的数，进而想到容斥&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;钦定至少有某些位置是 &lt;code&gt;X&lt;/code&gt; 进行容斥，结合上面的性质发现空棋盘上的合法超集共 1000 多个，故可做，考虑单步钦定状态下的答案。&lt;/p&gt;
&lt;p&gt;令 &lt;span class=&#34;math inline&#34;&gt;\(f_{i,S}\)&lt;/span&gt; 表示填了 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; 个数，目前 &lt;code&gt;X&lt;/code&gt; 集合已经填完了 &lt;span class=&#34;math inline&#34;&gt;\(S\)&lt;/span&gt; 内元素的方案数。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;a---数列&#34;&gt;A - 数列&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P7961&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P7961&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;发现比较合理的 DP 方式是，令 &lt;span class=&#34;math inline&#34;&gt;\(f_{i,j,k,l}\)&lt;/span&gt; 表示当前正在 DP &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 这个值，已经填了 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; 个数，&lt;span class=&#34;math inline&#34;&gt;\(2^i\)&lt;/span&gt; 的个数，加上『进位』上来的，一共有 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 个，&lt;span class=&#34;math inline&#34;&gt;\(2^0\sim 2^i\)&lt;/span&gt; 总共有 &lt;span class=&#34;math inline&#34;&gt;\(l\)&lt;/span&gt; 个 1 的答案。那么有：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
f_{i+1,j+c,\left\lfloor\frac k2\right\rfloor+c,l+\left(\left\lfloor\frac k2\right\rfloor+c\right)\bmod 2}\gets f_{i,j,k,l}\times {v_{i + 1}}^c\times (c!)^{-1}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其中 &lt;span class=&#34;math inline&#34;&gt;\((c!)^{-1}\)&lt;/span&gt; 为多重集排列。最后乘上 &lt;span class=&#34;math inline&#34;&gt;\(n!\)&lt;/span&gt; 即可。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;最后若 &lt;span class=&#34;math inline&#34;&gt;\(l+\text{ctz}\left(\left\lfloor\frac k2\right\rfloor\right)\le K\)&lt;/span&gt; 即可统计 &lt;span class=&#34;math inline&#34;&gt;\(f_{m,n,k,l}\)&lt;/span&gt; 的贡献。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;注意到 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 维始终不超过 &lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt;，故复杂度 &lt;span class=&#34;math inline&#34;&gt;\(O(mn^3K)\)&lt;/span&gt;，非常可过。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int mod = 998244353;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, m, s;
    std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m &amp;gt;&amp;gt; s;
    using arr = std::vector&amp;lt;long long&amp;gt;;
    using brr = std::vector&amp;lt;arr&amp;gt;;
    brr v(m + 1, arr(n + 1));
    for (int i = 0; i &amp;lt;= m; ++i) &amp;#123;
        v[i][0] = 1ll;
        std::cin &amp;gt;&amp;gt; v[i][1];
        for (int j = 2; j &amp;lt;= n; ++j)
            v[i][j] = v[i][j - 1] * v[i][1] % mod;
    &amp;#125;
    arr inv(n + 1);
    inv[0] = 1ll;
    auto fac = 1ll;
    auto qkp = [&amp;amp;](long long x, int y) &amp;#123;
        auto res = 1ll;
        for (; y; (x *= x) %= mod, y &amp;gt;&amp;gt;= 1)
            if (y &amp;amp; 1)
                (res *= x) %= mod;
        return res;
    &amp;#125;;
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        (fac *= i) %= mod;
        inv[i] = qkp(fac, mod - 2);
    &amp;#125;
    using crr = std::vector&amp;lt;brr&amp;gt;;
    std::vector&amp;lt;crr&amp;gt; f(m + 1, crr(n + 1, brr(n + 1, arr(s + 1))));
    for (int i = 0; i &amp;lt;= n; ++i)
        f[0][i][i][i &amp;amp; 1] = v[0][i] * inv[i] % mod;
    for (int i = 0; i &amp;lt; m; ++i)
      for (int j = 0; j &amp;lt;= n; ++j)
        for (int k = 0; k &amp;lt;= n; ++k)
          for (int l = 0; l &amp;lt;= s; ++l) &amp;#123;
            f[i][j][k][l] %= mod;
            for (int c = 0; j + c &amp;lt;= n &amp;amp;&amp;amp; k / 2 + c &amp;lt;= n &amp;amp;&amp;amp; l + (k / 2 + c) % 2 &amp;lt;= s; ++c)
                f[i + 1][j + c][k / 2 + c][l + (k / 2 + c) % 2] += f[i][j][k][l] * v[i + 1][c] % mod * inv[c] % mod;
          &amp;#125;
    auto res = 0ll;
    for (int k = 0; k &amp;lt;= n; ++k)
        for (int l = 0; l &amp;lt;= s; ++l)
            if (l + __builtin_popcount(k / 2) &amp;lt;= s)
                res += f[m][n][k][l] % mod;
    std::cout &amp;lt;&amp;lt; res % mod * fac % mod &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;b---vasya-and-array&#34;&gt;B - Vasya and Array&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/CF1093F&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/CF1093F&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;发现正着做避免不了记录相同段长度，所以考虑反过来容斥。&lt;/p&gt;
&lt;p&gt;会发现这是一个类似于&lt;a href=&#34;/20230418/&#34;&gt;两双手&lt;/a&gt;的容斥结构。&lt;del&gt;两双手还在输出&lt;/del&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;令 &lt;span class=&#34;math inline&#34;&gt;\(f_{i,j}\)&lt;/span&gt; 表示前 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 个均合法，且第 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 个元素为 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; 的方案数，考虑什么时候会出现『前 &lt;span class=&#34;math inline&#34;&gt;\(i-1\)&lt;/span&gt; 个元素合法，到了第 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 个非法』的情况&lt;/p&gt;
&lt;p&gt;发现即当前 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 前面有 &lt;span class=&#34;math inline&#34;&gt;\(len-1\)&lt;/span&gt; 个相同元素，且第 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 个成为第 &lt;span class=&#34;math inline&#34;&gt;\(len\)&lt;/span&gt; 个相同元素的情况。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;显然有转移：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
f_{i,j}\gets \left(\sum_l f_{i-1,l}\right)-\left(\sum_{l\ne j} f_{i-len,l}\right)\times [a_{i-len+1\cdots i} = j\text{ is available}]
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;记录一下 &lt;span class=&#34;math inline&#34;&gt;\(s_i=\sum\limits_{j}f_{i,j}\)&lt;/span&gt; 的值即可做到 &lt;span class=&#34;math inline&#34;&gt;\(O(nk)\)&lt;/span&gt;。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int mod = 998244353;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, k, L;
    std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; k &amp;gt;&amp;gt; L;
    std::vector&amp;lt;int&amp;gt; a(n + 1);
    std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; cnt(n + 1, std::vector&amp;lt;int&amp;gt; (k + 1));
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        std::cin &amp;gt;&amp;gt; a[i];
        for (int j = 1; j &amp;lt;= k; ++j)
            cnt[i][j] = cnt[i - 1][j] + (a[i] == j);
        cnt[i][0] = cnt[i - 1][0] + (a[i] == -1);
    &amp;#125;
    using arr = std::vector&amp;lt;long long&amp;gt;;
    using brr = std::vector&amp;lt;arr&amp;gt;;
    arr s(n + 1);
    brr f(n + 1, arr(k + 1));
    s[0] = 1ll;
    for (int i = 1; i &amp;lt;= n; ++i)
        for (int j = 1; j &amp;lt;= k; ++j)
            if (a[i] == -1 || a[i] == j) &amp;#123;
                f[i][j] = s[i - 1];
                if (i &amp;gt;= L &amp;amp;&amp;amp; (cnt[i][j] - cnt[i - L][j]) + (cnt[i][0] - cnt[i - L][0]) == L) &amp;#123;
                    f[i][j] += mod - (s[i - L] - f[i - L][j]);
                    if (s[i - L] &amp;lt; f[i - L][j])
                        f[i][j] -= mod;
                    if (f[i][j] &amp;gt;= mod)
                        f[i][j] -= mod;
                &amp;#125;
                s[i] += f[i][j];
                if (s[i] &amp;gt;= mod)
                    s[i] -= mod;
            &amp;#125;
    std::cout &amp;lt;&amp;lt; s[n] &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;c---road-of-the-king&#34;&gt;C - Road of the King&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/AT_codefestival_2016_final_f&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/AT_codefestival_2016_final_f&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;发现最后的图是强连通的，当且仅当&lt;strong&gt;所有点都能走到 1&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;最开始转化成『所有点都能通过操作序列走到 1』，错麻了 /qd&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;令 &lt;span class=&#34;math inline&#34;&gt;\(f_{i,j,k}\)&lt;/span&gt; 表示前 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 步，已经使得 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; 个点能走到 1，当前已经访问过了 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 个不能走到 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt; 的点。&lt;/p&gt;
&lt;p&gt;如果再次访问 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; 个点中的其中一个，那么这 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 个点就能走到 1。转移是容易的。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int mod = 1e9 + 7;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, m;
    std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
    using arr = std::vector&amp;lt;long long&amp;gt;;
    using brr = std::vector&amp;lt;arr&amp;gt;;
    std::vector&amp;lt;brr&amp;gt; f(m + 1, brr(n + 1, arr(n + 1)));
    f[0][1][0] = 1ll;
    for (int i = 0; i &amp;lt; m; ++i)
        for (int j = 1; j &amp;lt;= n; ++j) &amp;#123;
            for (int k = 0; k + j &amp;lt;= n &amp;amp;&amp;amp; k + j &amp;lt;= i + 1; ++k) &amp;#123;
                f[i][j][k] %= mod;
                f[i + 1][j][k] += f[i][j][k] * k % mod;
                f[i + 1][j + k][0] += f[i][j][k] * j % mod;
                if (j + k != n)
                    f[i + 1][j][k + 1] += f[i][j][k] * (n - j - k) % mod;
            &amp;#125;
        &amp;#125;
    std::cout &amp;lt;&amp;lt; f[m][n][0] % mod &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;d---チーム分け&#34;&gt;D - チーム分け&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/AT_mujin_pc_2018_f&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/AT_mujin_pc_2018_f&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;很容易得到一个 &lt;span class=&#34;math inline&#34;&gt;\(O(n^3)\)&lt;/span&gt; 的做法：给 &lt;span class=&#34;math inline&#34;&gt;\(a\)&lt;/span&gt; 排序，从大到小选每个组的『限制者』。&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(f_{i,j}\)&lt;/span&gt; 表示选到 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt;，还剩 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; 个 &lt;span class=&#34;math inline&#34;&gt;\(\ge a_i\)&lt;/span&gt; 的人没有分组，则：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
f_{i-1,j+1-k}\gets f_{i,j}\quad(1\le k\le a_i)\\
f_{i-1,j+1}\gets f_{i,j}
\]&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;后面这个优化还是很难想的…… 主要是要注意到，可以不必在某个 &lt;span class=&#34;math inline&#34;&gt;\(a_i\)&lt;/span&gt; 处钦定其为『限制者』；而是在某个 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 处，给『未分组』的人分大小为 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 的组，而不关心具体谁是限制者，甚至不关心限制者的 &lt;span class=&#34;math inline&#34;&gt;\(a\)&lt;/span&gt; 值。&lt;/p&gt;
&lt;p&gt;记 &lt;span class=&#34;math inline&#34;&gt;\(c_i\)&lt;/span&gt; 表示 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 处有几个 &lt;span class=&#34;math inline&#34;&gt;\(a\)&lt;/span&gt;，做多重集组合。仍然记录未分组人数 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt;，那么一个固定的 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; 能贡献的大小为 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 的组满足调和级数，枚举组数 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt;，有：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
f_{i-1,j+c_i-k\cdot i}\gets f_{i+1,j}\times \binom{j+c_i}{i\cdot k}\times \frac{(i\cdot k)!}{(i!)^k\times k!}\quad\left(k\le \frac{j+c_i}i\right)
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一定要注意分母里的 &lt;span class=&#34;math inline&#34;&gt;\(k!\)&lt;/span&gt; 的含义（消序）！组是无序的。&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;复杂度 &lt;span class=&#34;math inline&#34;&gt;\(O(n^2\log n)\)&lt;/span&gt;。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int mod = 998244353;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n;
    std::cin &amp;gt;&amp;gt; n;
    std::vector&amp;lt;int&amp;gt; c(n + 1);
    for (int i = 1, x; i &amp;lt;= n; ++i)
        std::cin &amp;gt;&amp;gt; x, ++c[x];
    using arr = std::vector&amp;lt;long long&amp;gt;;
    using brr = std::vector&amp;lt;arr&amp;gt;;
    brr C(n + 1, arr(n + 1));
    C[0][0] = 1ll;
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        C[i][0] = 1ll;
        for (int j = 1; j &amp;lt;= i; ++j)
            C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % mod;
    &amp;#125;
    arr fac(n + 1);
    fac[0] = 1ll;
    for (int i = 1; i &amp;lt;= n; ++i)
        fac[i] = fac[i - 1] * i % mod;
    auto qkp = [&amp;amp;](long long x, int y) &amp;#123;
        auto res = 1ll;
        for (; y; (x *= x) %= mod, y &amp;gt;&amp;gt;= 1)
            if (y &amp;amp; 1)
                (res *= x) %= mod;
        return res;
    &amp;#125;;
    brr pw(n + 1, arr(n + 1));
    for (int i = 0; i &amp;lt;= n; ++i) &amp;#123;
        pw[i][0] = 1ll, pw[i][1] = qkp(fac[i], mod - 2);
        for (int j = 2; j &amp;lt;= n; ++j)
            pw[i][j] = pw[i][j - 1] * pw[i][1] % mod;
    &amp;#125;
    brr f(n + 2, arr(n + 1));
    f[n + 1][0] = 1ll;
    for (int i = n; i; --i)
        for (int j = 0; j + c[i] &amp;lt;= n; ++j)
            for (int k = 0, l = (j + c[i]) / i; k &amp;lt;= l; ++k)
                (f[i][j + c[i] - k * i] += f[i + 1][j] * C[j + c[i]][i * k] % mod * fac[i * k] % mod * pw[i][k] % mod * pw[k][1] % mod) %= mod;
    std::cout &amp;lt;&amp;lt; f[1][0] &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;e---random-isolation&#34;&gt;E - Random Isolation&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/AT_arc165_e&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/AT_arc165_e&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;发现期望可以拆贡献，每个局面下，每个大小 &lt;span class=&#34;math inline&#34;&gt;\(&amp;gt;K\)&lt;/span&gt; 的连通块恰好贡献 1 次操作次数。&lt;/p&gt;
&lt;p&gt;这里提一下，一开始有这样的想法：每个存在 &lt;span class=&#34;math inline&#34;&gt;\(&amp;gt;K\)&lt;/span&gt; 连通块的局面都可以操作 1 次，所以一个局面有 1 的贡献；这是否和上面得到的结论矛盾？&lt;/p&gt;
&lt;p&gt;答案是，统计局面的方案数权值和连通块的方案数权值是不一样的，但总和是一样的。且局面没什么好的统计方法，故统计连通块。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;令 &lt;span class=&#34;math inline&#34;&gt;\(f_{x,i,j}\)&lt;/span&gt; 表示 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 为根，子树内选了大小为 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 的连通块，一共需要删除 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; 个点。那么相当于要求这 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; 个点的删除时间早于 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 内所有点。树上背包统计方案数，每个点处计算权值与贡献即可。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;最后算权值的时候，把操作序列看成后几项无效的排列，那么要求这 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; 个点的操作序列需要在所有 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 个点的前面&lt;/p&gt;
&lt;p&gt;可以猜到一个答案：&lt;span class=&#34;math inline&#34;&gt;\(\dfrac {i!\times j!}{(i+j)!}\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;但仔细想来并站不住脚：每个连通块的后几项在实际操作序列里是不存在的，整个操作序列的长短甚至都是未知的，好像没什么道理。&lt;/p&gt;
&lt;p&gt;问了一圈没人说出来个靠谱的证明。算了。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int mod = 998244353;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, k;
    std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; k;
    std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; g(n + 1);
    for (int i = 1, x, y; i &amp;lt; n; ++i) &amp;#123;
        std::cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; y;
        g[x].push_back(y), g[y].push_back(x);
    &amp;#125;
    using arr = std::vector&amp;lt;long long&amp;gt;;
    using brr = std::vector&amp;lt;arr&amp;gt;;
    brr C(n + 1, arr(n + 1));
    for (int i = 0; i &amp;lt;= n; ++i) &amp;#123;
        C[i][0] = 1ll;
        for (int j = 1; j &amp;lt;= i; ++j)
            C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % mod;
    &amp;#125;
    auto qkp = [&amp;amp;](long long x, int y) &amp;#123;
        auto res = 1ll;
        for (; y; (x *= x) %= mod, y &amp;gt;&amp;gt;= 1)
            if (y &amp;amp; 1)
                (res *= x) %= mod;
        return res;
    &amp;#125;;
    arr fac(n + 1), inv(n + 1);
    fac[0] = inv[0] = 1ll;
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        fac[i] = fac[i - 1] * i % mod;
        inv[i] = qkp(fac[i], mod - 2);
    &amp;#125;
    std::vector&amp;lt;int&amp;gt; siz(n + 1);
    brr h(n + 1, arr(n + 1));
    std::vector&amp;lt;brr&amp;gt; f(n + 1, brr(n + 1, arr(n + 1)));
    auto res = 0ll;
    std::function&amp;lt;void(int, int)&amp;gt; DFS = [&amp;amp;](int x, int fa) &amp;#123;
        f[x][1][(int)g[x].size()] = 1ll;
        siz[x] = 1;
        for (auto i : g[x])
            if (i != fa) &amp;#123;
                DFS(i, x);
                h = f[x];
                for (int j = siz[x]; j; --j)
                  for (int a = 0; a &amp;lt; n; ++a)
                    if (f[x][j][a + 1])
                      for (int k = siz[i]; ~k; --k)
                        for (int b = 0; a + b &amp;lt; n; ++b)
                          f[x][j + k][a + b] += h[j][a + 1] * f[i][k][b + 1] % mod;
                siz[x] += siz[i];
            &amp;#125;
        for (int i = 1; i &amp;lt;= siz[x]; ++i)
            for (int j = 0; j &amp;lt;= n; ++j)
                f[x][i][j] %= mod;
        for (int i = k + 1; i &amp;lt;= siz[x]; ++i)
            for (int j = 0; i + j &amp;lt;= n; ++j)
                res += f[x][i][j] * fac[i] % mod * fac[j] % mod * inv[i + j] % mod;
        res %= mod;
        return;
    &amp;#125;;
    DFS(1, -1);
    std::cout &amp;lt;&amp;lt; res &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;a---染色问题&#34;&gt;A - 染色问题&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P6076&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P6076&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;题述转化成：恰好 &lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt; 行，恰好 &lt;span class=&#34;math inline&#34;&gt;\(m\)&lt;/span&gt; 列，恰好 &lt;span class=&#34;math inline&#34;&gt;\(c\)&lt;/span&gt; 种颜色即可容斥&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;将无色视为一个不参与容斥的颜色，容易写出答案式：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
\sum_{i=0}^{n}\sum_{j=0}^{m}\sum_{k=0}^{c} (-1)^{i+j+k}\times \binom ni\times \binom mj\times \binom ck\times (c-k+1)^{(n-i)(m-j)}
\]&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;预处理幂次即可。复杂度 &lt;span class=&#34;math inline&#34;&gt;\(O(nmc)\)&lt;/span&gt;。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int mod = 1e9 + 7;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, m, c;
    std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m &amp;gt;&amp;gt; c;
    std::vector&amp;lt;long long&amp;gt; fac(n * m + 1), inv(n * m + 1);
    fac[0] = inv[0] = 1ll;
    for (int i = 1; i &amp;lt;= n * m; ++i)
        fac[i] = fac[i - 1] * i % mod;
    auto qkp = [&amp;amp;](long long x, int y) &amp;#123;
        auto res = 1ll;
        for (; y; (x *= x) %= mod, y &amp;gt;&amp;gt;= 1)
            if (y &amp;amp; 1)
                (res *= x) %= mod;
        return res;
    &amp;#125;;
    inv[n * m] = qkp(fac[n * m], mod - 2);
    for (int i = n * m - 1; i; --i)
        inv[i] = inv[i + 1] * (i + 1) % mod;
    auto C = [&amp;amp;](int n, int m) &amp;#123;
        if (n &amp;lt; m || m &amp;lt; 0)
            return 0ll;
        return fac[n] * inv[m] % mod * inv[n - m] % mod;
    &amp;#125;;
    std::vector&amp;lt;std::vector&amp;lt;long long&amp;gt; &amp;gt; pw(c + 2, std::vector&amp;lt;long long&amp;gt; (n * m + 1));
    for (int i = 1; i &amp;lt;= c + 1; ++i) &amp;#123;
        pw[i][0] = 1ll;
        for (int j = 1; j &amp;lt;= n * m; ++j)
            pw[i][j] = pw[i][j - 1] * i % mod;
    &amp;#125;
    auto res = 0ll;
    for (int i = 0; i &amp;lt;= n; ++i)
        for (int j = 0; j &amp;lt;= m; ++j)
            for (int k = 0; k &amp;lt;= c; ++k) &amp;#123;
                int op = ((i + j + k) &amp;amp; 1) ? mod - 1 : 1;
                res += op * C(n, i) % mod * C(m, j) % mod * C(c, k) % mod * pw[c - k + 1][(n - i) * (m - j)] % mod;
            &amp;#125;
    std::cout &amp;lt;&amp;lt; res % mod &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;b---painting-the-wall&#34;&gt;B - Painting The Wall&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/CF398B&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/CF398B&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;观察到初始被标记的行列之间等价，相似地，初始未被标记的行列之间等价。故可以粗暴地塞到状态里。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;参照 &lt;a href=&#34;/20240111/&#34;&gt;Game with Probability Problem&lt;/a&gt; 中解决自转移的思路，考虑解方程。&lt;/p&gt;
&lt;p&gt;设 &lt;span class=&#34;math inline&#34;&gt;\(f_{i,j}\)&lt;/span&gt; 表示剩余 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 行 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; 列时的期望操作数，列出 DP 式：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
f_{i,j}
\]&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://xsc062.netlify.app/20251030/</guid>
            <title>图论思维题 II</title>
            <link>https://xsc062.netlify.app/20251030/</link>
            <category>反悔贪心</category>
            <pubDate>Thu, 30 Oct 2025 21:57:54 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;有哪道图论没有思维吗&lt;/p&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;a---friend-朋友&#34;&gt;A - friend 朋友&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P5875&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P5875&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;第一眼：一般图带权最大独立集&lt;/p&gt;
&lt;p&gt;为什么会想到时光倒流？并非典型的时光倒流，而是表现为反贪 + 删边。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://xsc062.netlify.app/20251029/</guid>
            <title>CDQ 小记</title>
            <link>https://xsc062.netlify.app/20251029/</link>
            <category>CDQ 分治</category>
            <pubDate>Wed, 29 Oct 2025 15:36:06 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;日常不理解算法本质&lt;/p&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;
&lt;hr /&gt;
&lt;p&gt;周末给 afewdgre 讲题，偶遇简单时间轴问题，拼尽全力勉强战胜&lt;/p&gt;
&lt;h2 id=&#34;何为时间轴&#34;&gt;何为时间轴&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;特点：单向。&lt;/p&gt;
&lt;p&gt;前面的修改会影响后面的查询；反过来，后面的修改不会影响前面的查询。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在大部分 DS 题目中，顺序操作是满足这个条件的。考虑不存在明显操作时间轴的问题，通常处理方式是扫描线：即用坐标轴当时间轴，这样做的前提条件也是『前面的修改影响后面的查询，但后面的修改不影响前面的查询』。这里拿给 afewdgre 讲的矩形面积并举例。&lt;/p&gt;
&lt;p&gt;矩形面积并中，把一段 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 坐标上，每个 &lt;span class=&#34;math inline&#34;&gt;\(y\)&lt;/span&gt; 上矩形存在的状态转化成『某个时刻，一段 &lt;span class=&#34;math inline&#34;&gt;\(y\)&lt;/span&gt; 是否被覆盖』，矩形的增删则用差分的方式维护。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;cdq-分治&#34;&gt;CDQ 分治&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;在需求时间轴的需求上，额外要求：&lt;/p&gt;
&lt;p&gt;修改之间无依赖，或者说，&lt;strong&gt;单次修改对询问的影响是可求的。&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;这样就可以分治。大部分分治的基本目标都是，使相同的计算不用被多次进行。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;每层 CDQ 会统计每个 &lt;span class=&#34;math inline&#34;&gt;\([l,mid]\)&lt;/span&gt; 的修改对 &lt;span class=&#34;math inline&#34;&gt;\([mid+1,r]\)&lt;/span&gt; 询问的影响。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;好像讲完了？&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://xsc062.netlify.app/20251028/</guid>
            <title>杂题</title>
            <link>https://xsc062.netlify.app/20251028/</link>
            <category>分治</category>
            <category>分块</category>
            <category>背包</category>
            <pubDate>Tue, 28 Oct 2025 17:06:42 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;模拟赛的密度正在威胁其他文章的生存环境。&lt;/p&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;a.-排序&#34;&gt;A. 排序&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P14352&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P14352&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;对于一个长度为 &lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt; 的排列 &lt;span class=&#34;math inline&#34;&gt;\(p\)&lt;/span&gt;，定义一轮冒泡：&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;for i in range(1, n):
    if p[i] &amp;gt; p[i + 1]:
        swap(p[i], p[i + 1])&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;给定 &lt;span class=&#34;math inline&#34;&gt;\(n,k\)&lt;/span&gt;，问在所有长度为 &lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt; 的排列中，可以在 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 轮冒泡后单增的排列数量。对 &lt;span class=&#34;math inline&#34;&gt;\(998244353\)&lt;/span&gt; 取模。&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(n\le 10^{18},k\le 2\times 10^7\)&lt;/span&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;反序表。令 &lt;span class=&#34;math inline&#34;&gt;\(a_i\)&lt;/span&gt; 表示 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 结尾的逆序对数，那么限制相当于说 &lt;span class=&#34;math inline&#34;&gt;\(\max\{a\}\le k\)&lt;/span&gt;。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;也即限制一个元素之前大于之的元素数不超过 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt;，可以直接计数。想象把 &lt;span class=&#34;math inline&#34;&gt;\(1\sim n\)&lt;/span&gt; 依次填入排列的过程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;对于 &lt;span class=&#34;math inline&#34;&gt;\(1\sim n-k\)&lt;/span&gt;，只能填在剩余空位的左 &lt;span class=&#34;math inline&#34;&gt;\(k+1\)&lt;/span&gt; 个（因为填完它后，剩下的空位都比它大）；&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;对于 &lt;span class=&#34;math inline&#34;&gt;\(n-k+1\sim n\)&lt;/span&gt;，可以填在剩余任意一个空位。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;故答案为 &lt;span class=&#34;math inline&#34;&gt;\((k+1)^{n-k}\cdot k!\)&lt;/span&gt;。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int mod = 998244353;
int main() &amp;#123;
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
    std::freopen(&amp;quot;sorting.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;sorting.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    auto stime = std::chrono::steady_clock::now();
    long long n;
    int k;
    std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; k, k = std::min((long long)k, n);
    auto qkp = [&amp;amp;](long long x, int y) &amp;#123;
        auto res = 1ll;
        for (; y; (x *= x) %= mod, y &amp;gt;&amp;gt;= 1)
            if (y &amp;amp; 1)
                (res *= x) %= mod;
        return res;
    &amp;#125;;
    auto res = qkp(k + 1, (n - k) % (mod - 1));
    for (int i = 1; i &amp;lt;= k; ++i)
        (res *= i) %= mod;
    std::cout &amp;lt;&amp;lt; res &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt;(std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s \n&amp;quot;;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;b.-重排&#34;&gt;B. 重排&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P14353&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P14353&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定一个初始为空的数组 &lt;span class=&#34;math inline&#34;&gt;\(a\)&lt;/span&gt;，再给出 &lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt; 次加数操作，每次加数后输出：&lt;/p&gt;
&lt;p&gt;任意排列 &lt;span class=&#34;math inline&#34;&gt;\(a\)&lt;/span&gt;，得到的 &lt;span class=&#34;math inline&#34;&gt;\(\sum\limits_{i=2}^n |a_{i+1}-a_{i}|\)&lt;/span&gt; 的最大值。&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(n\le 3\times 10^6\)&lt;/span&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;显然从小到大排列，答案是后 &lt;span class=&#34;math inline&#34;&gt;\(\left\lfloor \dfrac n2\right\rfloor\)&lt;/span&gt; 个数的和减去前 &lt;span class=&#34;math inline&#34;&gt;\(\left\lfloor \dfrac n2\right\rfloor\)&lt;/span&gt; 的和的差的二倍，再减去位于中间 2 / 3 个数中，相邻两个差的最小值。&lt;/p&gt;
&lt;p&gt;这家伙在说什么呢.jpg&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;用大根堆 + 小根堆维护即可，因为 pbds 过不去&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
int main() &amp;#123;
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
    std::freopen(&amp;quot;rearrange.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;rearrange.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    auto stime = std::chrono::steady_clock::now();
    int n, T;
    std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; T;
    auto res = 0ll, la = 0ll, sL = 0ll, sR = 0ll;
    std::priority_queue&amp;lt;int&amp;gt; L;
    std::priority_queue&amp;lt;int, std::vector&amp;lt;int&amp;gt;, std::greater&amp;lt;int&amp;gt; &amp;gt; R;
    for (int i = 1, mid = 0; i &amp;lt;= n; ++i) &amp;#123;
        long long x;
        std::cin &amp;gt;&amp;gt; x;
        int b =  T ? x ^ la : x;
        if (i == 1)
            mid = b, la = 0ll;
        else if (i &amp;amp; 1) &amp;#123;
            if (b &amp;lt; L.top()) &amp;#123;
                mid = L.top(), sL -= mid;
                L.pop();
                sL += b, L.push(b);
            &amp;#125;
            else if (b &amp;gt; R.top()) &amp;#123;
                mid = R.top(), sR -= mid;
                R.pop();
                sR += b, R.push(b);
            &amp;#125;
            else
                mid = b;
            la = 2 * (sR - sL) - std::min(R.top() - mid, mid - L.top());
        &amp;#125;
        else &amp;#123;
            if (b &amp;lt;= mid) &amp;#123;
                sL += b, sR += mid;
                L.push(b), R.push(mid);
            &amp;#125;
            else &amp;#123;
                sL += mid, sR += b;
                L.push(mid), R.push(b);
            &amp;#125;
            la = 2 * (sR - sL) - (R.top() - L.top());
        &amp;#125;
        res ^= la;
    &amp;#125;
    printf(&amp;quot;%lld\n&amp;quot;, res);
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt;(std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s \n&amp;quot;;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;c.-整式比较-qoj10506.-waga&#34;&gt;C. 整式比较 / qoj#10506. Waga&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.becoder.com.cn/contest/6685/problem/3&#34; class=&#34;uri&#34;&gt;https://www.becoder.com.cn/contest/6685/problem/3&lt;/a&gt; / &lt;a href=&#34;https://qoj.ac/problem/10506&#34; class=&#34;uri&#34;&gt;https://qoj.ac/problem/10506&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定 &lt;span class=&#34;math inline&#34;&gt;\(a_{1\cdots n}\)&lt;/span&gt;，和一个称，如下操作称为一次『称重』：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;选中 &lt;span class=&#34;math inline&#34;&gt;\(a\)&lt;/span&gt; 的一个子集，输入给称。记它们的和为 &lt;span class=&#34;math inline&#34;&gt;\(s\)&lt;/span&gt;，那么称会返回 &lt;span class=&#34;math inline&#34;&gt;\(\min(k,\left\lfloor \dfrac sc \right\rfloor)\)&lt;/span&gt;，其中，&lt;span class=&#34;math inline&#34;&gt;\(c\)&lt;/span&gt; 为给定常数。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;现在对于每个无序对 &lt;span class=&#34;math inline&#34;&gt;\((i,j)\)&lt;/span&gt;（&lt;span class=&#34;math inline&#34;&gt;\(i\ne j\)&lt;/span&gt;），你需要判断：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在已知 &lt;span class=&#34;math inline&#34;&gt;\(a\)&lt;/span&gt; 中除 &lt;span class=&#34;math inline&#34;&gt;\(a_i,a_j\)&lt;/span&gt; 外所有元素值，且 &lt;span class=&#34;math inline&#34;&gt;\(a_i,a_j\)&lt;/span&gt; 数值未知的前提下，是否可以通过若干次称重确定 &lt;span class=&#34;math inline&#34;&gt;\(a_i,a_j\)&lt;/span&gt; 的大小关系。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(n,c\le 8000,k\le 10^5,1\le a_i&amp;lt; kc\)&lt;/span&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;显然，&lt;span class=&#34;math inline&#34;&gt;\(a_i\)&lt;/span&gt; 和 &lt;span class=&#34;math inline&#34;&gt;\(a_j\)&lt;/span&gt; 能区分，当且仅当 &lt;span class=&#34;math inline&#34;&gt;\(\left\lfloor\dfrac {a_i}c\right\rfloor\ne \left\lfloor\dfrac {a_j}c\right\rfloor\)&lt;/span&gt;，或者存在一个其他元素的子集 &lt;span class=&#34;math inline&#34;&gt;\(s\)&lt;/span&gt;，使得 &lt;span class=&#34;math inline&#34;&gt;\(\left\lfloor\dfrac {a_i+s}c\right\rfloor\ne \left\lfloor\dfrac {a_j + s}c\right\rfloor\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;反过来，如果 &lt;span class=&#34;math inline&#34;&gt;\(a_i\)&lt;/span&gt; 和 &lt;span class=&#34;math inline&#34;&gt;\(a_j\)&lt;/span&gt; 不能区分，一个前提是 &lt;span class=&#34;math inline&#34;&gt;\(\left\lfloor\dfrac {a_i}c\right\rfloor =\left\lfloor\dfrac {a_j}c\right\rfloor\)&lt;/span&gt;。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;下意识猜要排序，排序后打表发现使 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 不合法的 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; 总是连续的。&lt;/p&gt;
&lt;details&gt;
&lt;p&gt;&lt;summary&gt;证明&lt;/summary&gt;&lt;/p&gt;
&lt;ol type=&#34;1&#34;&gt;
&lt;li&gt;&lt;p&gt;需要证：对于 &lt;span class=&#34;math inline&#34;&gt;\(x&amp;lt;y&amp;lt;z\)&lt;/span&gt;，若 &lt;span class=&#34;math inline&#34;&gt;\(x,y\)&lt;/span&gt; 不可区分，且 &lt;span class=&#34;math inline&#34;&gt;\(y,z\)&lt;/span&gt; 不可区分，那么 &lt;span class=&#34;math inline&#34;&gt;\(x,z\)&lt;/span&gt; 不可区分。&lt;/p&gt;
&lt;p&gt;记 &lt;span class=&#34;math inline&#34;&gt;\(\left\lfloor\dfrac {x}c\right\rfloor=\left\lfloor\dfrac {y}c\right\rfloor=\left\lfloor\dfrac {z}c\right\rfloor=w\)&lt;/span&gt;，不存在 &lt;span class=&#34;math inline&#34;&gt;\(s\le c\cdot (k-w)\)&lt;/span&gt;，使得 &lt;span class=&#34;math inline&#34;&gt;\(y\)&lt;/span&gt; 可以进位但 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 不可，也不存在这样的 &lt;span class=&#34;math inline&#34;&gt;\(s\)&lt;/span&gt; 使得 &lt;span class=&#34;math inline&#34;&gt;\(z\)&lt;/span&gt; 可以进位但 &lt;span class=&#34;math inline&#34;&gt;\(y\)&lt;/span&gt; 不可。&lt;/p&gt;
&lt;p&gt;合并不等式容易得到不存在这样的 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 使得 &lt;span class=&#34;math inline&#34;&gt;\(z\)&lt;/span&gt; 可以进位但 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 不可。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;需要证：对于 &lt;span class=&#34;math inline&#34;&gt;\(x&amp;lt;y&amp;lt;z\)&lt;/span&gt;，若 &lt;span class=&#34;math inline&#34;&gt;\(x,y\)&lt;/span&gt; 可区分或 &lt;span class=&#34;math inline&#34;&gt;\(y,z\)&lt;/span&gt; 可区分，则 &lt;span class=&#34;math inline&#34;&gt;\(x,z\)&lt;/span&gt; 可区分。&lt;/p&gt;
&lt;p&gt;调整法易得。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/details&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;故发现只需要讨论相邻两个元素是否可区分。需要知道所有可能的子集和用于 check，可以用分治预处理『只有某相邻两个元素不选』时的前后缀背包数组（到达某个余数时需要的最小整倍数），就可以 &lt;span class=&#34;math inline&#34;&gt;\(O(nc\log n)\)&lt;/span&gt; 解决问题。&lt;/p&gt;
&lt;p&gt;考虑在做什么：删点在 &lt;span class=&#34;math inline&#34;&gt;\([l,mid]\)&lt;/span&gt;，那么 &lt;span class=&#34;math inline&#34;&gt;\([mid+1,r]\)&lt;/span&gt; 的 DP 数组不会受到影响；删点在 &lt;span class=&#34;math inline&#34;&gt;\([mid + 1, r]\)&lt;/span&gt;，那么 &lt;span class=&#34;math inline&#34;&gt;\([l,mid]\)&lt;/span&gt; 的 DP 数组不会受到影响。背包的物品是无顺序的，所以有正确性。&lt;/p&gt;
&lt;p&gt;也就是说大部分信息是可继承的。&lt;em&gt;为什么题解管这个叫 CDQ？是因为普通分治总会被叫 CDQ 吗？&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;做一个类似 01 背包滚动数组的东西，维护每个点前 / 后可以凑出来的背包值，在最后下传到单点时统计答案即可。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;p&gt;相邻两个的处理略显烧脑，但意外地简洁。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;gt;=&lt;/code&gt; 不要写成除，不然会慢成唐诗&lt;/p&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int maxn = 8e3 + 5;
char nec(void) &amp;#123;
    static char buf[1 &amp;lt;&amp;lt; 20], *p = buf, *e = buf;
    if (p == e) &amp;#123;
        e = buf + fread(buf, 1, 1 &amp;lt;&amp;lt; 20, stdin);
        p = buf;
    &amp;#125;
    return *p++;
&amp;#125;
int read(void) &amp;#123;
    auto x = 0ll;
    char t = nec();
    for (; t &amp;lt; &amp;#39;0&amp;#39; || t &amp;gt; &amp;#39;9&amp;#39;; t = nec());
    for (; t &amp;gt;= &amp;#39;0&amp;#39; &amp;amp;&amp;amp; t &amp;lt;= &amp;#39;9&amp;#39;; t = nec())
        x = x * 10 + t - &amp;#39;0&amp;#39;;
    return x;
&amp;#125;
int ok[maxn], m, k;
std::pair&amp;lt;int, int&amp;gt; a[maxn];
void calc(int l, int r, const std::vector&amp;lt;int&amp;gt; f) &amp;#123;
    if (l &amp;gt; r)
        return;
    if (l == r) &amp;#123;
        if (a[l].first == a[l + 1].first)
            ok[l] = 1;
        else if (a[l].first / m == a[l + 1].first / m)
            ok[l] = (*std::min_element(f.begin() + m - a[l + 1].first % m, f.begin() + m - a[l].first % m) + a[l].first / m &amp;gt;= k);
        return;
    &amp;#125;
    int mid = (l + r) &amp;gt;&amp;gt; 1;
    auto g = f;
    for (int i = mid + 2; i &amp;lt;= r + 1; ++i) &amp;#123;
        auto h = g;
        for (int j = 0, k; j &amp;lt; m; ++j) &amp;#123;
            k = (j + m - a[i].first % m) % m;
            h[j] = std::min(h[j], g[k] + a[i].first / m + (k + a[i].first % m &amp;gt;= m));
        &amp;#125;
        h.swap(g);
    &amp;#125;
    calc(l, mid, g);
    g = f;
    for (int i = l; i &amp;lt;= mid; ++i) &amp;#123;
        auto h = g;
        for (int j = 0, k; j &amp;lt; m; ++j) &amp;#123;
            k = (j + m - a[i].first % m) % m;
            h[j] = std::min(h[j], g[k] + a[i].first / m + (k + a[i].first % m &amp;gt;= m));
        &amp;#125;
        h.swap(g);
    &amp;#125;
    calc(mid + 1, r, g);
    return;
&amp;#125;;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
    std::freopen(&amp;quot;intcmp.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;intcmp.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n = read();
    m = read(), k = read();
    for (int i = 1; i &amp;lt;= n; ++i)
        a[i].first = read(), a[i].second = i;
    std::sort(a + 1, a + n + 1);
    std::vector&amp;lt;int&amp;gt; f(m, 0x3f3f3f3f);
    f[0] = 0;
    calc(1, n - 1, f);
    std::vector&amp;lt;int&amp;gt; resL(n + 1), resR(n + 1);
    int now = 0;
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        resR[a[i].second] = i - 1 - now;
        if (i != n &amp;amp;&amp;amp; ok[i])
            ++now;
        else
            now = 0;
    &amp;#125;
    now = 0;
    for (int i = n; i; --i) &amp;#123;
        resL[a[i].second] = n - i - now;
        if (ok[i - 1])
            ++now;
        else
            now = 0;
    &amp;#125;
    for (int i = 1; i &amp;lt;= n; ++i)
        printf(&amp;quot;%d %d \n&amp;quot;, resL[i], resR[i]);
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;b.-字符串转换&#34;&gt;B. 字符串转换&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.becoder.com.cn/problem/52055&#34; class=&#34;uri&#34;&gt;https://www.becoder.com.cn/problem/52055&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定等长 01 串 &lt;span class=&#34;math inline&#34;&gt;\(S,T\)&lt;/span&gt;，维护 &lt;span class=&#34;math inline&#34;&gt;\(Q\)&lt;/span&gt; 次操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;修改：Flip &lt;span class=&#34;math inline&#34;&gt;\(S\)&lt;/span&gt; 的某个字符。&lt;/li&gt;
&lt;li&gt;修改：Flip &lt;span class=&#34;math inline&#34;&gt;\(T\)&lt;/span&gt; 的某个字符。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;每次操作后，问 &lt;span class=&#34;math inline&#34;&gt;\(S\)&lt;/span&gt; 能否通过若干次下列操作变为 &lt;span class=&#34;math inline&#34;&gt;\(T\)&lt;/span&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;选择 &lt;span class=&#34;math inline&#34;&gt;\(S\)&lt;/span&gt; 中的一个 &lt;code&gt;00&lt;/code&gt;，变为 &lt;code&gt;10&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;选择 &lt;span class=&#34;math inline&#34;&gt;\(S\)&lt;/span&gt; 中的一个 &lt;code&gt;11&lt;/code&gt;，变为 &lt;code&gt;01&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(|S|,Q\le 3\times 10^5\)&lt;/span&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;连续 00 / 11 操作，考虑奇数位取反。取反之后发现原操作等价于 &lt;span class=&#34;math inline&#34;&gt;\(a_i\gets a_{i+1}\)&lt;/span&gt;。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;这个操作只会使连续段的数量减少，故要求每一个后缀，&lt;span class=&#34;math inline&#34;&gt;\(S\)&lt;/span&gt; 的连续段个数不少于 &lt;span class=&#34;math inline&#34;&gt;\(T\)&lt;/span&gt; 的连续段个数，而且二者结尾相同。&lt;/p&gt;
&lt;p&gt;线段树维护即可。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int maxn = 3e5 + 5;
struct &amp;#123; int l, r, mn, d; &amp;#125; t[maxn &amp;lt;&amp;lt; 2];
#define lt (p &amp;lt;&amp;lt; 1)
#define rt (lt | 1)
void bld(int p, int l, int r) &amp;#123;
    t[p].l = l, t[p].r = r;
    t[p].mn = t[p].d = 0;
    if (l == r)
        return;
    int mid = (l + r) &amp;gt;&amp;gt; 1;
    bld(lt, l, mid), bld(rt, mid + 1, r);
    return;
&amp;#125;
void pushdown(int p) &amp;#123;
    if (t[p].d) &amp;#123;
        t[lt].mn += t[p].d, t[lt].d += t[p].d;
        t[rt].mn += t[p].d, t[rt].d += t[p].d;
        t[p].d = 0;
    &amp;#125;
    return;
&amp;#125;
void add(int p, int l, int r, int v) &amp;#123;
    if (l &amp;lt;= t[p].l &amp;amp;&amp;amp; t[p].r &amp;lt;= r) &amp;#123;
        t[p].mn += v, t[p].d += v;
        return;
    &amp;#125;
    pushdown(p);
    int mid = (t[p].l + t[p].r) &amp;gt;&amp;gt; 1;
    if (l &amp;lt;= mid)
        add(lt, l, r, v);
    if (r &amp;gt; mid)
        add(rt, l, r, v);
    t[p].mn = std::min(t[lt].mn, t[rt].mn);
    return;
&amp;#125;
#undef lt
#undef rt
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
    std::freopen(&amp;quot;string.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;string.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int T;
    for (std::cin &amp;gt;&amp;gt; T; T--; ) &amp;#123;
        int n, q;
        std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; q;
        std::vector&amp;lt;int&amp;gt; a(n + 1), b(n + 1);
        bld(1, 1, n);
        for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
            char t;
            std::cin &amp;gt;&amp;gt; t, a[i] = (t == &amp;#39;B&amp;#39;);
            if (i &amp;amp; 1)
                a[i] ^= 1;
        &amp;#125;
        for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
            char t;
            std::cin &amp;gt;&amp;gt; t, b[i] = (t == &amp;#39;B&amp;#39;);
            if (i &amp;amp; 1)
                b[i] ^= 1;
        &amp;#125;
        for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
            int v = 0;
            v += (i == n || a[i] != a[i + 1]);
            v -= (i == n || b[i] != b[i + 1]);
            if (v)
                add(1, 1, i, v);
        &amp;#125;
        for (char op; q--; ) &amp;#123;
            int i;
            std::cin &amp;gt;&amp;gt; op &amp;gt;&amp;gt; i;
            if (op == &amp;#39;X&amp;#39;) &amp;#123;
                int v = 0, v1 = 0;
                v -= (i == n || a[i] != a[i + 1]);
                v1 -= (i != 1 &amp;amp;&amp;amp; a[i] != a[i - 1]);
                a[i] ^= 1;
                v += (i == n || a[i] != a[i + 1]);
                v1 += (i != 1 &amp;amp;&amp;amp; a[i] != a[i - 1]);
                if (v)
                    add(1, 1, i, v);
                if (v1)
                    add(1, 1, i - 1, v1);
            &amp;#125;
            else &amp;#123;
                int v = 0, v1 = 0;
                v += (i == n || b[i] != b[i + 1]);
                v1 += (i != 1 &amp;amp;&amp;amp; b[i] != b[i - 1]);
                b[i] ^= 1;
                v -= (i == n || b[i] != b[i + 1]);
                v1 -= (i != 1 &amp;amp;&amp;amp; b[i] != b[i - 1]);
                if (v)
                    add(1, 1, i, v);
                if (v1)
                    add(1, 1, i - 1, v1);
            &amp;#125;
            std::cout &amp;lt;&amp;lt; ((a[n] == b[n] &amp;amp;&amp;amp; t[1].mn &amp;gt;= 0) ? &amp;quot;YES&amp;quot; : &amp;quot;NO&amp;quot;) &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
        &amp;#125;
    &amp;#125;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;c.-监控&#34;&gt;C. 监控&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.becoder.com.cn/problem/52057&#34; class=&#34;uri&#34;&gt;https://www.becoder.com.cn/problem/52057&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定 &lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt; 个怪，每个怪有 &lt;span class=&#34;math inline&#34;&gt;\(B_i\)&lt;/span&gt; 滴血，也就是说每个怪能被打 &lt;span class=&#34;math inline&#34;&gt;\(\le B_i\)&lt;/span&gt; 次。&lt;/p&gt;
&lt;p&gt;要求每个怪必须被打 &lt;span class=&#34;math inline&#34;&gt;\(\ge A_i\)&lt;/span&gt; 次，并认为被打恰好 &lt;span class=&#34;math inline&#34;&gt;\(A_i\)&lt;/span&gt; 次时这个怪是好的。&lt;/p&gt;
&lt;p&gt;对于每个 &lt;span class=&#34;math inline&#34;&gt;\(1\le x\le \sum B_i\)&lt;/span&gt;，求：在攻击次数只能为 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 的倍数的前提下，不好的怪的最小值。你只需要输出答案的和。&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(N\le 10^5,1\le A_i&amp;lt; B_i\le 10^5\)&lt;/span&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;记 &lt;span class=&#34;math inline&#34;&gt;\(c_i=B_i-A_i\)&lt;/span&gt;，把 &lt;span class=&#34;math inline&#34;&gt;\(c_i\)&lt;/span&gt; 降序排列，记 &lt;span class=&#34;math inline&#34;&gt;\(s=\sum A_i\)&lt;/span&gt;，那么一个 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 的答案为：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
\min\left\{i\mid{\left\lceil \frac{s}x \right\rceil\cdot x - s\ge c_i}\right\}
\]&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;容易想到整除分块，枚举 &lt;span class=&#34;math inline&#34;&gt;\(\left\lceil \dfrac{s}x \right\rceil\)&lt;/span&gt; 的值 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt;，那么相当于想要找到 &lt;span class=&#34;math inline&#34;&gt;\([L_i,R_i]\)&lt;/span&gt; 中的每个 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt;，&lt;span class=&#34;math inline&#34;&gt;\(x\cdot k-s\)&lt;/span&gt; 会落在哪个 &lt;span class=&#34;math inline&#34;&gt;\(c\)&lt;/span&gt; 的管辖范围里。&lt;/p&gt;
&lt;p&gt;不妨记 &lt;span class=&#34;math inline&#34;&gt;\(c_i\)&lt;/span&gt; 的管辖范围为 &lt;span class=&#34;math inline&#34;&gt;\([cL_i,cR_i]\)&lt;/span&gt;，那么转化为 &lt;span class=&#34;math inline&#34;&gt;\(x\cdot k-s\in [cL_i,cR_i]\)&lt;/span&gt;，枚举 &lt;span class=&#34;math inline&#34;&gt;\(c\)&lt;/span&gt; 解不等式即可。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;但发现一个严重的问题：外层整除分块复杂度是 &lt;span class=&#34;math inline&#34;&gt;\(\sqrt(s)\)&lt;/span&gt; 的，最劣 &lt;span class=&#34;math inline&#34;&gt;\(10^5\)&lt;/span&gt; 级别，很坏了。&lt;/p&gt;
&lt;p&gt;发现枚举商数劣的原因是使 &lt;span class=&#34;math inline&#34;&gt;\(\left\lceil \dfrac{s}x \right\rceil\)&lt;/span&gt; 很大的 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 并不多，却占用了很多枚举次数&lt;/p&gt;
&lt;p&gt;如果做经典的整除分块同样会发现到后期块内元素远远少于 &lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt;，却要花费 &lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt; 次操作来处理它们。所以对于这部分数我们直接朴素二分。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;取阈值为 1500 即可。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int B = 1500;
const long long inf = 1e18;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n;
    std::cin &amp;gt;&amp;gt; n;
    std::vector&amp;lt;long long&amp;gt; c(n + 1);
    auto sa = 0ll, sb = 0ll;
    for (int i = 1, a, b; i &amp;lt;= n; ++i) &amp;#123;
        std::cin &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b;
        sa += a, sb += b, c[i] = b - a;
    &amp;#125;
    std::sort(c.begin() + 1, c.end(), std::greater&amp;lt;int&amp;gt; ());
    std::partial_sum(c.begin() + 1, c.end(), c.begin() + 1);
    auto L = sb + 1;
    std::stack&amp;lt;std::pair&amp;lt;long long, int&amp;gt; &amp;gt; st;
    for (int k = 1; k &amp;lt;= 1500; ++k) &amp;#123;
        auto l = (sa + k - 1) / k, r = L - 1;
        if (l &amp;gt; r)
            continue;
        L = l;
        st.emplace(r, n + 1);
        for (int i = n; ~i; --i)
            st.emplace(std::min(r, (c[i] + sa) / k), i);
    &amp;#125;
    for (int i = L - 1; i; --i)
        st.emplace(i, std::lower_bound(c.begin(), c.end(), ((sa + i - 1) / i) * i - sa) - c.begin());
    auto res = 0ll;
    for (auto l = 1ll; !st.empty(); ) &amp;#123;
        auto [r, v] = st.top();
        st.pop();
        if (l &amp;gt; r)
            continue;
        if (v == n + 1)
            v = 0;
        res += (r - l + 1) * v;
        l = r + 1;
    &amp;#125;
    std::cout &amp;lt;&amp;lt; res &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;g---range-set-modifying-query&#34;&gt;G - Range Set Modifying Query&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/abc430/tasks/abc430_g&#34; class=&#34;uri&#34;&gt;https://atcoder.jp/contests/abc430/tasks/abc430_g&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;发现开 60 个线段树非常合理&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;接着发现是 beats 板子题。看似需要三只 log，其实只有两只。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;参见 abc426，最近 abc 都喜欢 beats 板子题吗？&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://xsc062.netlify.app/20251023/</guid>
            <title>图论思维题</title>
            <link>https://xsc062.netlify.app/20251023/</link>
            <category>并查集</category>
            <category>二分图</category>
            <category>构造</category>
            <category>思维</category>
            <category>随机化</category>
            <pubDate>Thu, 23 Oct 2025 11:32:05 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;人类智慧题&lt;/p&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;a---train-splitting&#34;&gt;A - Train Splitting&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/CF1776F&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/CF1776F&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;神秘构造题，猜 &lt;span class=&#34;math inline&#34;&gt;\(k=2\)&lt;/span&gt; 一定能构造&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;考虑直接从图上抠一个点下来，与之相关的边全部染成 1，剩下的染成 2&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;发现如果恰好选中了菊花的根就不行&lt;/p&gt;
&lt;p&gt;需要找到一个度数不为 &lt;span class=&#34;math inline&#34;&gt;\(n-1\)&lt;/span&gt; 的点。完全图的话，从菊花的根上抠一条当颜色 3 即可。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int T;
    for (std::cin &amp;gt;&amp;gt; T; T--; ) &amp;#123;
        int n, m;
        std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
        std::vector&amp;lt;int&amp;gt; deg(n + 1);
        std::vector&amp;lt;std::pair&amp;lt;int, int&amp;gt; &amp;gt; e(m + 1);
        int pos = -1;
        for (int i = 1; i &amp;lt;= m; ++i) &amp;#123;
            std::cin &amp;gt;&amp;gt; e[i].first &amp;gt;&amp;gt; e[i].second;
            ++deg[e[i].first], ++deg[e[i].second];
        &amp;#125;
        for (int i = 1; i &amp;lt;= n; ++i)
            if (deg[i] != n - 1) &amp;#123;
                pos = i;
                break;
            &amp;#125;
        if (pos != -1) &amp;#123;
            std::cout &amp;lt;&amp;lt; 2 &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
            for (int i = 1; i &amp;lt;= m; ++i)
                if (e[i].first == pos || e[i].second == pos)
                    std::cout &amp;lt;&amp;lt; 1 &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
                else
                    std::cout &amp;lt;&amp;lt; 2 &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
            std::cout &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
        &amp;#125;
        else &amp;#123;
            std::cout &amp;lt;&amp;lt; 3 &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
            pos = 1;
            bool flag = true;
            for (int i = 1; i &amp;lt;= m; ++i)
                if (e[i].first == pos || e[i].second == pos) &amp;#123;
                    if (flag)
                        std::cout &amp;lt;&amp;lt; 3 &amp;lt;&amp;lt; &amp;#39; &amp;#39;, flag = false;
                    else
                        std::cout &amp;lt;&amp;lt; 1 &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
                &amp;#125;
                else
                    std::cout &amp;lt;&amp;lt; 2 &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
        &amp;#125;
    &amp;#125;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;b---graph-partition&#34;&gt;B - Graph Partition&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/AT_agc039_b&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/AT_agc039_b&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;考虑二分图染色什么时候不行，即有奇环时&lt;/li&gt;
&lt;li&gt;考虑有多少种颜色时能染奇环，发现都不行，故二分图染色即可判定。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;真的只有绿吗？观察样例，猜测答案为图的直径。考虑构造：&lt;/p&gt;
&lt;p&gt;枚举每个点并钦定其为唯一一个 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt;，然后依次向下染色。显然最后构造出来的是合法的。最大为直径长度 + 1。&lt;/p&gt;
&lt;p&gt;也可以从差分约束的角度理解，但无甚必要。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n;
    std::cin &amp;gt;&amp;gt; n;
    std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; g(n + 1), g1(n + 1, std::vector&amp;lt;int&amp;gt; (n + 1, 0x3f3f3f3f));
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        g1[i][i] = 0;
        for (int j = 1; j &amp;lt;= n; ++j) &amp;#123;
            char t;
            std::cin &amp;gt;&amp;gt; t;
            if (t == &amp;#39;1&amp;#39;)
                g[i].push_back(j), g1[i][j] = 1;
        &amp;#125;
    &amp;#125;
    std::vector&amp;lt;int&amp;gt; col(n + 1);
    std::function&amp;lt;bool(int, int)&amp;gt; DFS = [&amp;amp;](int x, int now) &amp;#123;
        col[x] = now;
        for (auto i : g[x])
            if (!col[i]) &amp;#123;
                if (!DFS(i, 3 - now))
                    return false;
            &amp;#125;
            else if (col[i] == now)
                return false;
        return true;
    &amp;#125;;
    if (!DFS(1, 1))
        std::cout &amp;lt;&amp;lt; -1 &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    else &amp;#123;
        for (int k = 1; k &amp;lt;= n; ++k)
            for (int i = 1; i &amp;lt;= n; ++i)
                for (int j = 1; j &amp;lt;= n; ++j)
                    g1[i][j] = std::min(g1[i][j], g1[i][k] + g1[k][j]);
        int mx = 0;
        for (int i = 1; i &amp;lt;= n; ++i)
            for (int j = 1; j &amp;lt;= n; ++j)
                mx = std::max(mx, g1[i][j] + 1);
        std::cout &amp;lt;&amp;lt; mx &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    &amp;#125;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;c---strange-housing&#34;&gt;C - Strange Housing&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/CF1470D&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/CF1470D&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一反应是随便找一个生成树然后二分图染色，但是发现有当且仅当奇环时行为不太正确&lt;/li&gt;
&lt;li&gt;考虑打个补丁，抛弃二分图染色的想法，不断尝试染成黑色，如果染了下一个点会出现黑黑边，那就不染它，对得比较显然。&lt;/li&gt;
&lt;li&gt;当且仅当不连通时无解。&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int T;
    for (std::cin &amp;gt;&amp;gt; T; T--; ) &amp;#123;
        int n, m;
        std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
        std::vector&amp;lt;int&amp;gt; f(n + 1);
        std::iota(f.begin() + 1, f.end(), 1);
        std::function&amp;lt;int(int)&amp;gt; find = [&amp;amp;](int x) &amp;#123;
            return x == f[x] ? x : f[x] = find(f[x]);
        &amp;#125;;
        std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; g(n + 1), g1(n + 1);
        int cnt = 0;
        for (int x, y; m--; ) &amp;#123;
            std::cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; y;
            g1[x].push_back(y), g1[y].push_back(x);
            if (find(x) != find(y)) &amp;#123;
                f[find(x)] = find(y);
                ++cnt, g[x].push_back(y), g[y].push_back(x);
            &amp;#125;
        &amp;#125;
        if (cnt != n - 1) &amp;#123;
            std::cout &amp;lt;&amp;lt; &amp;quot;NO\n&amp;quot;;
            continue;
        &amp;#125;
        std::vector&amp;lt;int&amp;gt; col(n + 1);
        std::function&amp;lt;void(int, int)&amp;gt; DFS = [&amp;amp;](int x, int fa) &amp;#123;
            for (auto i : g[x])
                if (i != fa) &amp;#123;
                    bool flag = true;
                    for (auto j : g1[i])
                        if (col[j] == 2) &amp;#123;
                            flag = false;
                            break;
                        &amp;#125;
                    if (flag)
                        col[i] = 2;
                    else
                        col[i] = 1;
                    DFS(i, x);
                &amp;#125;
            return;
        &amp;#125;;
        col[1] = 2, DFS(1, -1);
        std::vector&amp;lt;int&amp;gt; res;
        for (int i = 1; i &amp;lt;= n; ++i)
            if (col[i] == 2)
                res.push_back(i);
        std::cout &amp;lt;&amp;lt; &amp;quot;YES\n&amp;quot; &amp;lt;&amp;lt; (int)res.size() &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
        for (auto i : res)
            std::cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
        std::cout &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    &amp;#125;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;d---defender-of-childhood-dreams&#34;&gt;D - Defender of Childhood Dreams&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/CF1583F&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/CF1583F&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;考虑把每连续 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 个点分为一个一级组，每个一级组内全部连 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt; 边。显然组内边最长不超过 &lt;span class=&#34;math inline&#34;&gt;\(k-1\)&lt;/span&gt;。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;接着把每连续 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 个一级组分为一个二级组，二级组内空闲边全部涂成颜色 &lt;span class=&#34;math inline&#34;&gt;\(2\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;此时 &lt;span class=&#34;math inline&#34;&gt;\(a&amp;lt;b\)&lt;/span&gt; 的条件就会派上用场：每个一级组的值域是没有交的，一级组之间的边都是同一个朝向。&lt;/p&gt;
&lt;p&gt;这样就保证由颜色为 &lt;span class=&#34;math inline&#34;&gt;\(2\)&lt;/span&gt; 的边构成的连链来自不同的一级组，长度最多为 &lt;span class=&#34;math inline&#34;&gt;\(k-1\)&lt;/span&gt;。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;依次类推，&lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 级组是大小为 &lt;span class=&#34;math inline&#34;&gt;\(k^i\)&lt;/span&gt; 的团，故 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 最大为 &lt;span class=&#34;math inline&#34;&gt;\(\left\lceil \log_kn\right\rceil\)&lt;/span&gt;。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;按上述流程构造，即可 &lt;span class=&#34;math inline&#34;&gt;\(O(n^2)\)&lt;/span&gt; 完成。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, k;
    std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; k;
    using arr = std::vector&amp;lt;int&amp;gt;;
    using brr = std::vector&amp;lt;arr&amp;gt;;
    brr pos;
    for (int i = 1; i &amp;lt;= n; ++i)
        pos.push_back(&amp;#123; i &amp;#125;);
    brr g(n + 1, arr(n + 1));
    std::function&amp;lt;void(brr&amp;amp;, int)&amp;gt; calc = [&amp;amp;](brr &amp;amp;pos, int now) &amp;#123;
        if ((int)pos.size() == 1) &amp;#123;
            std::cout &amp;lt;&amp;lt; now &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
            for (int i = 1; i &amp;lt;= n; ++i)
                for (int j = i + 1; j &amp;lt;= n; ++j)
                    std::cout &amp;lt;&amp;lt; g[i][j] &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
            std::cout &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
            return;
        &amp;#125;
        brr p;
        ++now;
        for (int i = 0; i &amp;lt; (int)pos.size(); i += k) &amp;#123;
            p.emplace_back();
            for (int j = i; j &amp;lt; i + k &amp;amp;&amp;amp; j &amp;lt; (int)pos.size(); ++j) &amp;#123;
                for (auto a : p.back())
                    for (auto b : pos[j])
                        g[a][b] = now;
                for (auto b : pos[j])
                    p.back().push_back(b);
            &amp;#125;
        &amp;#125;
        calc(p, now);
        return;
    &amp;#125;;
    calc(pos, 0);
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;e---edge-split&#34;&gt;E - Edge Split&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/CF1726D&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/CF1726D&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;题意有些许歧义，『红色连通块』其实是指删掉蓝边之后的连通块。考虑到 &lt;span class=&#34;math inline&#34;&gt;\(m\le n+2\)&lt;/span&gt; 而不是更多，考虑直接分讨。&lt;/li&gt;
&lt;li&gt;考虑树的情况，对于任意颜色，删一条边就会带来 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt; 个连通块的代价，随便染色即可。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;考虑基环树的情况，发现如果环上有某个颜色，那么钦定这个颜色第一次删边删的是环边，就会发现第一次删边不会有代价，故强制环上有两种颜色即可。&lt;/p&gt;
&lt;p&gt;考虑 &lt;span class=&#34;math inline&#34;&gt;\(m=n+1\)&lt;/span&gt; 的情况，环可能有下面三种形态：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;对于第一、二种，保证两个环上都有两种颜色即可，第三种乍一看有点复杂，其实还是一样的，保证两个环都有两种颜色即可，这样三个环显然都会有两种颜色。站在不饱和度的角度，第三个环其实是无意义的。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;由此类推 &lt;span class=&#34;math inline&#34;&gt;\(m=n+2\)&lt;/span&gt; 的情况，发现只需要在并查集连边时令树边为蓝，反祖边为红即可。发现这样会且仅会在第一组样例的情况出问题：&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&#34;image-1.png&#34; alt=&#34;如果中间的三角形在最后输入就不能得到最优解&#34; /&gt;&lt;figcaption&gt;如果中间的三角形在最后输入就不能得到最优解&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;怎么处理这个问题呢，我们使用人类智慧，发现这种情况最后三条红边构成三角形，我们只要发现构造出来的解是这样的三角形，由于造成这一点的顺序很苛刻，故一直 &lt;code&gt;random_shuffle&lt;/code&gt; 输入，继续构造直到合法即可。&lt;/p&gt;
&lt;p&gt;（？怎么最优解全是这么做的，我还以为只有我一个人会乱搞。）&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;当不饱和度为 4 的时候就会出现这种结构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image-2.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;此时按照刚刚的方法就一定构造不出合法解了。这或许也是 &lt;span class=&#34;math inline&#34;&gt;\(m\le n+2\)&lt;/span&gt; 的原因。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    std::mt19937 rand(0xabcdef);
    int T;
    for (std::cin &amp;gt;&amp;gt; T; T--; ) &amp;#123;
        int n, m;
        std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
        std::vector&amp;lt;int&amp;gt; res(m + 1);
        std::vector&amp;lt;std::tuple&amp;lt;int, int, int&amp;gt; &amp;gt; e(m + 1);
        for (int i = 1, x, y; i &amp;lt;= m; ++i) &amp;#123;
            std::cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; y;
            e[i] = &amp;#123; x, y, i &amp;#125;;
        &amp;#125;
        auto work = [&amp;amp;](std::vector&amp;lt;std::tuple&amp;lt;int, int, int&amp;gt; &amp;gt; &amp;amp;e) &amp;#123;
            std::vector&amp;lt;int&amp;gt; f(n + 1);
            std::iota(f.begin() + 1, f.end(), 1);
            std::function&amp;lt;int(int)&amp;gt; find = [&amp;amp;](int x) &amp;#123;
                return x == f[x] ? x : f[x] = find(f[x]);
            &amp;#125;;
            std::set&amp;lt;int&amp;gt; t;
            for (int i = 1; i &amp;lt;= m; ++i) &amp;#123;
                auto [x, y, id] = e[i];
                if (find(x) == find(y)) &amp;#123;
                    t.insert(x), t.insert(y);
                    res[id] = 1;
                &amp;#125;
                else &amp;#123;
                    res[id] = 0;
                    f[find(x)] = find(y);
                &amp;#125;
            &amp;#125;
            return (int)t.size() != 3;
        &amp;#125;;
        for (; !work(e); std::shuffle(e.begin() + 1, e.end(), rand));
        for (int i = 1; i &amp;lt;= m; ++i)
            std::cout &amp;lt;&amp;lt; res[i];
        std::cout &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    &amp;#125;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;f---fair-share&#34;&gt;F - Fair Share&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/CF1634E&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/CF1634E&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;原来 &lt;span class=&#34;math inline&#34;&gt;\(L=R\)&lt;/span&gt; 是说两个可重集相等 不是说和相等&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;考虑把所有元素排得整齐一点：同一组的在同一行，同一值的在同一列（显然这就要求每列元素个数为偶）。这样要求就转化为：分组，并满足每行每组各占一半、每列每组各占一半。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;参考 &lt;a href=&#34;https://vjudge.net/problem/OpenJ_POJ-C19A&#34;&gt;Ball&lt;/a&gt;，用连边可以体现二选一的操作，发现其实二选一就是一选二分之一，故在行列中连边，按照 &lt;span class=&#34;math inline&#34;&gt;\((1,2)\)&lt;/span&gt;，&lt;span class=&#34;math inline&#34;&gt;\((3,4)\)&lt;/span&gt; 这样连边，就可以满足一选二分之一。&lt;/p&gt;
&lt;p&gt;因为元素可重，所以一行一列可能会有多个元素，这不太好；实际实现时，不妨记输入的第 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 个数组第 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; 个元素为 &lt;span class=&#34;math inline&#34;&gt;\(a_{i,j}\)&lt;/span&gt;，实际上连的是 &lt;span class=&#34;math inline&#34;&gt;\((a_{i,j},a_{i,j\oplus 1})\)&lt;/span&gt;；记值为 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 的第 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; 个元素为 &lt;span class=&#34;math inline&#34;&gt;\(b_{i,j}\)&lt;/span&gt;，实际上连的是 &lt;span class=&#34;math inline&#34;&gt;\((b_{i,j},b_{i,j\oplus 1})\)&lt;/span&gt;。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;还是参照 Ball 中二分图的观点，发现这个图很能二分图染色。如果这个解法是足够优的，我们当然希望不包含奇环。由于一个点在 &lt;span class=&#34;math inline&#34;&gt;\(a\)&lt;/span&gt; 中至多被连一条边，在 &lt;span class=&#34;math inline&#34;&gt;\(b\)&lt;/span&gt; 中也至多被连一条边，所以一条路径一定是 a b 交错的，由此证毕。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, tot = 0, N = 0;
    std::cin &amp;gt;&amp;gt; n;
    std::unordered_map&amp;lt;int, int&amp;gt; tab;
    std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; a(n + 1), b(1);
    for (int i = 1, m; i &amp;lt;= n; ++i) &amp;#123;
        std::cin &amp;gt;&amp;gt; m;
        for (int x; m--; ) &amp;#123;
            std::cin &amp;gt;&amp;gt; x, ++N;
            if (!tab.count(x))
                tab[x] = ++tot, b.emplace_back();
            a[i].push_back(N);
            b[tab[x]].push_back(N);
        &amp;#125;
    &amp;#125;
    std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; g(N + 1);
    for (int i = 1; i &amp;lt;= n; ++i)
        for (int j = 0; j &amp;lt; (int)a[i].size(); ++j)
            g[a[i][j]].push_back(a[i][j ^ 1]);
    for (int i = 1; i &amp;lt;= tot; ++i) &amp;#123;
        if ((int)b[i].size() &amp;amp; 1) &amp;#123;
            std::cout &amp;lt;&amp;lt; &amp;quot;NO\n&amp;quot;;
            return 0;
        &amp;#125;
        for (int j = 0; j &amp;lt; (int)b[i].size(); ++j)
            g[b[i][j]].push_back(b[i][j ^ 1]);
    &amp;#125;
    std::cout &amp;lt;&amp;lt; &amp;quot;YES\n&amp;quot;;
    std::vector&amp;lt;int&amp;gt; col(N + 1);
    std::function&amp;lt;void(int, int)&amp;gt; DFS = [&amp;amp;](int x, int now) &amp;#123;
        col[x] = now;
        for (auto i : g[x])
            if (!col[i])
                DFS(i, 3 - now);
            else
                assert(col[i] != col[x]);
        return;
    &amp;#125;;
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        for (auto j : a[i]) &amp;#123;
            if (!col[j])
                DFS(j, 1);
            std::cout &amp;lt;&amp;lt; (col[j] == 1 ? &amp;#39;L&amp;#39; : &amp;#39;R&amp;#39;);
        &amp;#125;
        std::cout &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    &amp;#125;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;g---lenient-vertex-cover&#34;&gt;G - Lenient Vertex Cover&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/CF1680F&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/CF1680F&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;对于边不被完全覆盖的限制把问题转换成了一个近似二分图染色的形态，一个朴素的做法是枚举这样的边并染色，但似乎没什么优化前途，考虑更加二分图的做法。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;从非法的角度考虑，相当于是问能不能抠掉 &lt;span class=&#34;math inline&#34;&gt;\(\le 1\)&lt;/span&gt; 条边使图变为二分图。显然这条边（如果存在）在奇环上且是所有奇环的交。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;从合法的角度考虑&lt;/strong&gt;，因为不是真的删边，而是相当于把所在的所有环长度 &lt;span class=&#34;math inline&#34;&gt;\(-1\)&lt;/span&gt;，所以这条边不能被任何一个偶环包含。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;容易想到找生成树，标记偶环边并统计奇环。但显然没办法标记到所有偶环边，也没办法统计到所有奇环：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image-3.png&#34; /&gt;&lt;/p&gt;
&lt;details&gt;
&lt;p&gt;&lt;summary&gt;实际上这个做法可以证明是正确的，因为有一个前提：&lt;strong&gt;非树边总是可以和树边成环&lt;/strong&gt;。&lt;/summary&gt;&lt;/p&gt;
&lt;p&gt;考虑两个疑点：&lt;/p&gt;
&lt;ol type=&#34;1&#34;&gt;
&lt;li&gt;&lt;p&gt;无法标记到所有偶环：当且仅当存在偶环需要 &lt;span class=&#34;math inline&#34;&gt;\(\ge 2\)&lt;/span&gt; 条非树边参与形成。需要证明这样的偶环上的树边不会被选中。&lt;/p&gt;
&lt;p&gt;单看这个环上的树边，形成 &lt;span class=&#34;math inline&#34;&gt;\(\ge 2\)&lt;/span&gt; 个条分立的链。考虑它们在树上是怎么连通的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;中间相隔奇数条树边。那么会被另一条非树边标记为偶环。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;中间相隔偶数条树边。那么这两条链一定不会被认定为可选的奇环边，因为一条非树边 + 这偶数条边会形成一个新的、与当前偶环分立的奇环。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image-4.png&#34; /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;无法判定到所有奇环：当且仅当存在奇环需要 &lt;span class=&#34;math inline&#34;&gt;\(\ge 2\)&lt;/span&gt; 条非树边参与形成。需要证明被选中的边被包含在这样的奇环中。&lt;/p&gt;
&lt;p&gt;相似地，单看这个环上的树边，形成 &lt;span class=&#34;math inline&#34;&gt;\(\ge 2\)&lt;/span&gt; 个条分立的链。考虑它们在树上是怎么连通的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;中间相隔偶数条树边。上帝视角下共两个奇环，且公共边为这个奇环中除了另一条非树边以外的所有边。&lt;/p&gt;
&lt;p&gt;实际上的行为也是正确的，另一条非树边参与形成并标记一个偶环，当前非树边形成并标记一个奇环。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;中间相隔奇数条树边。那么会被另一条非树边标记为偶环，当前奇环中唯一可选的边为当前非树边。&lt;/p&gt;
&lt;p&gt;实际行为也是正确的。比较显然。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;image-5.png&#34; /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/details&gt;
&lt;p&gt;故树上差分维护即可。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int T;
    for (std::cin &amp;gt;&amp;gt; T; T--; ) &amp;#123;
        int n, m;
        std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
        std::vector&amp;lt;std::pair&amp;lt;int, int&amp;gt; &amp;gt; e;
        std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; g(n + 1), g1(n + 1);
        for (int i = 1, x, y; i &amp;lt;= m; ++i) &amp;#123;
            std::cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; y;
            e.emplace_back(x, y);
            g1[x].push_back(y), g1[y].push_back(x);
        &amp;#125;
        std::vector&amp;lt;int&amp;gt; col(n + 1);
        std::function&amp;lt;bool(int, int)&amp;gt; DFS = [&amp;amp;](int x, int now) &amp;#123;
            col[x] = now;
            for (auto i : g1[x])
                if (!col[i]) &amp;#123;
                    if (!DFS(i, 3 - now))
                        return false;
                &amp;#125;
                else if (col[i] == now)
                    return false;
            return true;
        &amp;#125;;
        if (DFS(1, 1)) &amp;#123;
            std::cout &amp;lt;&amp;lt; &amp;quot;YES\n&amp;quot;;
            for (int i = 1; i &amp;lt;= n; ++i)
                std::cout &amp;lt;&amp;lt; col[i] - 1;
            std::cout &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
            continue;
        &amp;#125;
        std::vector&amp;lt;int&amp;gt; f(n + 1);
        std::iota(f.begin() + 1, f.end(), 1);
        std::vector&amp;lt;std::pair&amp;lt;int, int&amp;gt; &amp;gt; r;
        std::function&amp;lt;int(int)&amp;gt; find = [&amp;amp;](int x) &amp;#123; return x == f[x] ? x : f[x] = find(f[x]); &amp;#125;;
        for (auto [u, v] : e)
            if (find(u) != find(v)) &amp;#123;
                f[find(u)] = find(v);
                // printf(&amp;quot;%d %d \n&amp;quot;, u, v);
                g[u].push_back(v), g[v].push_back(u);
            &amp;#125;
            else
                r.emplace_back(u, v);
        std::vector&amp;lt;int&amp;gt; dep(n + 1), son(n + 1), siz(n + 1), fa(n + 1);
        std::function&amp;lt;void(int)&amp;gt; DFS1 = [&amp;amp;](int x) &amp;#123;
            siz[x] = 1;
            for (auto i : g[x])
                if (i != fa[x]) &amp;#123;
                    dep[i] = dep[x] + 1;
                    fa[i] = x, DFS1(i);
                    siz[x] += siz[i];
                    if (siz[i] &amp;gt; siz[son[x]])
                        son[x] = i;
                &amp;#125;
            return;
        &amp;#125;;
        dep[1] = 1, DFS1(1);
        std::vector&amp;lt;int&amp;gt; top(n + 1);
        DFS1 = [&amp;amp;](int x) &amp;#123;
            if (son[x])
                top[son[x]] = top[x], DFS1(son[x]);
            for (auto i : g[x])
                if (i != fa[x] &amp;amp;&amp;amp; i != son[x])
                    top[i] = i, DFS1(i);
            return;
        &amp;#125;;
        top[1] = 1, DFS1(1);
        auto askLCA = [&amp;amp;](int x, int y) &amp;#123;
            for (; top[x] != top[y]; x = fa[top[x]])
                if (dep[top[x]] &amp;lt; dep[top[y]])
                    std::swap(x, y);
            return dep[x] &amp;lt; dep[y] ? x : y;
        &amp;#125;;
        int cnt = 0;
        std::pair&amp;lt;int, int&amp;gt; res;
        std::vector&amp;lt;int&amp;gt; tag(n + 1), s(n + 1);
        for (auto [u, v] : r) &amp;#123;
            int fa = askLCA(u, v), dis = dep[u] + dep[v] - 2 * dep[fa];
            if (dis &amp;amp; 1)
                ++tag[u], ++tag[v], tag[fa] -= 2;
            else &amp;#123;
                res = &amp;#123; 0, 0 &amp;#125;;
                ++cnt, ++s[u], ++s[v], s[fa] -= 2;
                if (cnt == 1)
                    res = &amp;#123; u, v &amp;#125;;
            &amp;#125;
        &amp;#125;
        DFS1 = [&amp;amp;](int x) &amp;#123;
            for (auto i : g[x])
                if (i != fa[x]) &amp;#123;
                    DFS1(i);
                    tag[x] += tag[i], s[x] += s[i];
                &amp;#125;
            if (!tag[x] &amp;amp;&amp;amp; s[x] == cnt &amp;amp;&amp;amp; x != 1)
                res = &amp;#123; fa[x], x &amp;#125;;
            return;
        &amp;#125;;
        DFS1(1);
        // printf(&amp;quot;# %d %d \n&amp;quot;, res.first, res.second);
        if (res.first) &amp;#123;
            std::cout &amp;lt;&amp;lt; &amp;quot;YES\n&amp;quot;;
            std::fill(col.begin() + 1, col.end(), 0);
            std::function&amp;lt;void(int, int)&amp;gt; DFS = [&amp;amp;](int x, int now) &amp;#123;
                col[x] = now;
                for (auto i : g1[x])
                    if (!col[i])
                        DFS(i, 3 - now);
                return;
            &amp;#125;;
            col[res.first] = col[res.second] = 2;
            DFS(res.first, 2), DFS(res.second, 2);
            for (int i = 1; i &amp;lt;= n; ++i)
                std::cout &amp;lt;&amp;lt; col[i] - 1;
            std::cout &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
        &amp;#125;
        else
            std::cout &amp;lt;&amp;lt; &amp;quot;NO\n&amp;quot;;
    &amp;#125;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;h---four-coloring&#34;&gt;H - Four Coloring&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/AT_code_festival_2017_quala_d&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/AT_code_festival_2017_quala_d&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;参见&lt;a href=&#34;/20231117/#杂项&#34;&gt;切比雪夫距离&lt;/a&gt;，则问题转化为，任意点为中心的边长为 &lt;span class=&#34;math inline&#34;&gt;\(2d+1\)&lt;/span&gt; 的正方形的边不能和这个点同色&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;直接按照 &lt;span class=&#34;math inline&#34;&gt;\(d\times d\)&lt;/span&gt; 进行划分即可。注意负数除法会影响正确性，故平移到正数即可。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, m, d;
    std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m &amp;gt;&amp;gt; d;
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        for (int j = n + 1; j &amp;lt;= n + m; ++j) &amp;#123;
            int x = (i + j) / d, y = (j - i) / d;
            if (x % 2 == 0 &amp;amp;&amp;amp; y % 2 == 0)
                std::cout &amp;lt;&amp;lt; &amp;#39;R&amp;#39;;
            else if (x % 2 == 0)
                std::cout &amp;lt;&amp;lt; &amp;#39;Y&amp;#39;;
            else if (y % 2 == 0)
                std::cout &amp;lt;&amp;lt; &amp;#39;G&amp;#39;;
            else
                std::cout &amp;lt;&amp;lt; &amp;#39;B&amp;#39;;
        &amp;#125;
        std::cout &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    &amp;#125;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;i---diverse-coloring&#34;&gt;I - Diverse Coloring&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://vjudge.net/contest/759882#problem/I&#34; class=&#34;uri&#34;&gt;https://vjudge.net/contest/759882#problem/I&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可以很简单地猜到答案为 &lt;span class=&#34;math inline&#34;&gt;\(n\bmod 2\)&lt;/span&gt;，且唯一的例外是样例中 &lt;span class=&#34;math inline&#34;&gt;\(n=4\)&lt;/span&gt; 的菊花；&lt;/li&gt;
&lt;li&gt;&lt;p&gt;很难理解怎么想到构造方法的：从根节点开始 DFS，先向下递归处理儿子，如果儿子传上来未配对的点则与之配对，否则上传自己。&lt;/p&gt;
&lt;p&gt;这样做之后，除了根可能为孤岛之外，树会被分为若干个大小为 2 或 3 的连通块，此时的染色策略就很明显了。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1 的连通块的存在价值是保证每个点在包含其的连通块内都能解决掉限制，大小 &lt;span class=&#34;math inline&#34;&gt;\(=3\)&lt;/span&gt; 的连通块是为了提供 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt; 或 &lt;span class=&#34;math inline&#34;&gt;\(-1\)&lt;/span&gt; 的代价用于调整。&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;对于孤岛根，一个很好的性质是其儿子所在连通块一定是下面的两层，故大力讨论前三层形态（实际上是前五层）：&lt;/p&gt;
&lt;details&gt;
&lt;p&gt;&lt;summary&gt;神秘枚举&lt;/summary&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image-6.png&#34; /&gt;&lt;/p&gt;
&lt;/details&gt;
&lt;p&gt;分讨即可。似乎并不用分这么多类，但是实现难度并不高。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int T;
    for (std::cin &amp;gt;&amp;gt; T; T--; ) &amp;#123;
        int n;
        std::cin &amp;gt;&amp;gt; n;
        std::vector&amp;lt;int&amp;gt; deg(n + 1);
        std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; g(n + 1);
        for (int i = 2, fa; i &amp;lt;= n; ++i) &amp;#123;
            std::cin &amp;gt;&amp;gt; fa;
            ++deg[fa], ++deg[i];
            g[fa].push_back(i);
            if (i == 4 &amp;amp;&amp;amp; *std::max_element(deg.begin() + 1, deg.begin() + 5) == 3)
                std::cout &amp;lt;&amp;lt; 2 &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
            else
                std::cout &amp;lt;&amp;lt; i % 2 &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
        &amp;#125;
        std::vector&amp;lt;int&amp;gt; siz(n + 1);
        std::vector&amp;lt;std::pair&amp;lt;int, int&amp;gt; &amp;gt; p2;
        std::vector&amp;lt;std::tuple&amp;lt;int, int, int&amp;gt; &amp;gt; p3;
        std::function&amp;lt;int(int)&amp;gt; DFS = [&amp;amp;](int x) &amp;#123;
            std::vector&amp;lt;int&amp;gt; p;
            p.push_back(x);
            for (auto i : g[x])
                if (DFS(i) == 1)
                    p.push_back(i);
            if ((int)p.size() == 2)
                p2.emplace_back(p[0], p[1]);
            else if ((int)p.size() == 3)
                p3.emplace_back(p[0], p[1], p[2]);
            siz[x] = (int)p.size();
            return siz[x];
        &amp;#125;;
        std::vector&amp;lt;int&amp;gt; col(n + 1);
        auto work = [&amp;amp;](int now) &amp;#123;
            for (auto [x, y] : p2)
                if (!col[x] &amp;amp;&amp;amp; !col[y])
                    col[x] = 1;
            for (auto [x, y, z] : p3)
                if (!col[x] &amp;amp;&amp;amp; !col[y] &amp;amp;&amp;amp; !col[z]) &amp;#123;
                    if (now &amp;gt;= 0)
                        col[x] = 1, --now;
                    else
                        col[y] = col[z] = 1, ++now;
                &amp;#125;
            for (int i = 1; i &amp;lt;= n; ++i)
                std::cout &amp;lt;&amp;lt; (col[i] ? &amp;#39;b&amp;#39; : &amp;#39;w&amp;#39;);
            std::cout &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
            return;
        &amp;#125;;
        DFS(1);
        int now = 0;
        if (siz[1] == 1) &amp;#123;
            if ((int)g[1].size() == 1) &amp;#123;
                int p2 = g[1][0];
                if (siz[p2] == 2)
                    col[p2] = 1, now = -1;
                else if (n == 4)
                    col[p2] = 1, now = -1;
                else &amp;#123;
                    int p3 = g[g[p2][0]].empty() ? g[p2][1] : g[p2][0], p5 = g[p3][0];
                    col[p2] = col[p3] = 1;
                    if (siz[p5] == 2) &amp;#123;
                        int p6 = siz[g[p5][0]] == 1 ? g[p5][0] : g[p5][1];
                        col[p6] = 1, now = 0;
                    &amp;#125;
                    else &amp;#123;
                        int p6 = g[p5][0], p7 = g[p5][1];
                        col[p6] = col[p7] = 1, now = 1;
                    &amp;#125;
                &amp;#125;
            &amp;#125;
            else &amp;#123;
                int p2 = g[1][0], p3 = g[1][1];
                if (siz[p2] &amp;gt; siz[p3])
                    std::swap(p2, p3);
                if (siz[p2] == 2 &amp;amp;&amp;amp; siz[p3] == 2)
                    col[p2] = col[p3] = 1, now = -1;
                else if (siz[p2] == 2 &amp;amp;&amp;amp; siz[p3] == 3) &amp;#123;
                    int p4 = siz[g[p2][0]] == 1 ? g[p2][0] : g[p2][1];
                    col[1] = col[p3] = col[p4] = 1, now = 0;
                &amp;#125;
                else &amp;#123;
                    int p4 = g[p2][0], p5 = g[p2][1];
                    col[1] = col[p3] = col[p4] = col[p5] = 1, now = 1;
                &amp;#125;
            &amp;#125;
        &amp;#125;
        work(now);
    &amp;#125;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;j---graph-coloring&#34;&gt;J - Graph Coloring&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/CF662B&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/CF662B&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;首先需要意识到，翻奇数次 / 偶数次可以归到翻 / 不翻的范畴里。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;不妨枚举最后所有边颜色，那么就可以限定每条边的两端点翻转情况，发现这是并查集，但怎么求最小？难道要 2-SAT 吗？&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;发现最终的并查集一定是两两对应的，对应每一对，取最小开销者即可。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, m;
    std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
    std::vector&amp;lt;std::tuple&amp;lt;int, int, int&amp;gt; &amp;gt; e;
    for (int i = 1, x, y; i &amp;lt;= m; ++i) &amp;#123;
        char t;
        std::cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; y &amp;gt;&amp;gt; t;
        e.emplace_back(x, y, t == &amp;#39;R&amp;#39;);
    &amp;#125;
    std::vector&amp;lt;int&amp;gt; res1, res2;
    auto calc = [&amp;amp;](std::vector&amp;lt;int&amp;gt; &amp;amp;res) &amp;#123;
        std::vector&amp;lt;int&amp;gt; f(2 * n + 1), siz(2 * n + 1);
        std::iota(f.begin() + 1, f.end(), 1);
        std::function&amp;lt;int(int)&amp;gt; find = [&amp;amp;](int x) &amp;#123;
            return x == f[x] ? x : f[x] = find(f[x]);
        &amp;#125;;
        auto merge = [&amp;amp;](int x, int y) &amp;#123;
            f[find(x)] = find(y);
            return;
        &amp;#125;;
        for (auto [x, y, w] : e)
            if (w)
                merge(x, y), merge(x + n, y + n);
            else
                merge(x, y + n), merge(x + n, y);
        for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
            ++siz[find(i)];
            if (find(i) == find(n + i))
                return false;
        &amp;#125;
        std::vector&amp;lt;int&amp;gt; tag(2 * n + 1);
        for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
            if (!tag[find(i)]) &amp;#123;
                tag[find(i)] = tag[find(i + n)] = 1;
                if (siz[find(i)] &amp;lt;= siz[find(i + n)])
                    ++tag[find(i)];
                else
                    ++tag[find(i + n)];
            &amp;#125;
            if (tag[find(i)] == 2)
                res.push_back(i);
        &amp;#125;
        return true;
    &amp;#125;;
    auto flag1 = calc(res1);
    for (auto &amp;amp;[x, y, w] : e)
        w ^= 1;
    auto flag2 = calc(res2);
    if (!flag1 &amp;amp;&amp;amp; !flag2)
        std::cout &amp;lt;&amp;lt; -1 &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    else if (!flag2 || (flag1 &amp;amp;&amp;amp; res1.size() &amp;lt; res2.size())) &amp;#123;
        std::cout &amp;lt;&amp;lt; (int)res1.size() &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
        for (auto i : res1)
            std::cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
        std::cout &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    &amp;#125;
    else &amp;#123;
        std::cout &amp;lt;&amp;lt; (int)res2.size() &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
        for (auto i : res2)
            std::cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
        std::cout &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    &amp;#125;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://xsc062.netlify.app/20251020/</guid>
            <title>Spanning Tree Again</title>
            <link>https://xsc062.netlify.app/20251020/</link>
            <category>最小生成树</category>
            <pubDate>Mon, 20 Oct 2025 17:10:11 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;mst，怎么还有 mst related&lt;/p&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;a---st-spanning-tree&#34;&gt;A - st-Spanning Tree&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/CF723F&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/CF723F&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;看起来形似最小度限制生成树，但没有边权导致失去了凸性，wqs 二分不再可行。&lt;/li&gt;
&lt;li&gt;这也启示我们放弃 mst 算法，重新回到连通性看待本题。即尝试在不影响连通性的前提下，让 &lt;span class=&#34;math inline&#34;&gt;\(s,t\)&lt;/span&gt; 在原图上的度数减少到对应值。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;发现 &lt;span class=&#34;math inline&#34;&gt;\(s,t\)&lt;/span&gt; 的决策会相互影响：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;好消息是有且仅有这两种情况会干扰决策。胡乱贪心即可。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;考虑忽略与 &lt;span class=&#34;math inline&#34;&gt;\(s,t\)&lt;/span&gt; 有关的边跑一遍 DFS，得到若干连通块，显然它们会分为只与 &lt;span class=&#34;math inline&#34;&gt;\(s,t\)&lt;/span&gt; 中一者有关 / 与二者都有关两类。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;连通块内部：建 DFS 树即可。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;先&lt;/strong&gt;处理对于只与 &lt;span class=&#34;math inline&#34;&gt;\(s,t\)&lt;/span&gt; 中的一个有关的连通块：将其与对应 &lt;span class=&#34;math inline&#34;&gt;\(s,t\)&lt;/span&gt; 相连。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;再&lt;/strong&gt;处理对于与二者都有关的连通块：若 &lt;span class=&#34;math inline&#34;&gt;\((s, t)\)&lt;/span&gt; 不连通，则先找一个把 &lt;span class=&#34;math inline&#34;&gt;\(s\)&lt;/span&gt; 和 &lt;span class=&#34;math inline&#34;&gt;\(t\)&lt;/span&gt; 连通起来；剩下的看看哪个能连就连哪个。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;最后&lt;/strong&gt;看看是否存在边 &lt;span class=&#34;math inline&#34;&gt;\((s, t)\)&lt;/span&gt; 且不存在上一种情况（也就是 &lt;span class=&#34;math inline&#34;&gt;\(s,t\)&lt;/span&gt; 不连通），如果满足就连起来。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;为什么是这个连边顺序呢，发现 &lt;span class=&#34;math inline&#34;&gt;\((s,t)\)&lt;/span&gt; 会用一条边消耗两次度数，故放在最后；其他两者先解决更严格的一者。故有。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, m;
    std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
    std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; g(n + 1), ps(n + 1), pt(n + 1);
    for (int x, y; m--; ) &amp;#123;
        std::cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; y;
        g[x].push_back(y), g[y].push_back(x);
    &amp;#125;
    int s, t, ds, dt;
    std::cin &amp;gt;&amp;gt; s &amp;gt;&amp;gt; t &amp;gt;&amp;gt; ds &amp;gt;&amp;gt; dt;
    std::vector&amp;lt;int&amp;gt; col(n + 1);
    std::vector&amp;lt;std::pair&amp;lt;int, int&amp;gt; &amp;gt; res;
    int now = 0;
    std::function&amp;lt;void(int)&amp;gt; DFS = [&amp;amp;](int x) &amp;#123;
        col[x] = now;
        for (auto i : g[x])
            if (i == s)
                ps[now].push_back(x);
            else if (i == t)
                pt[now].push_back(x);
            else if (!col[i])
                res.emplace_back(x, i), DFS(i);
        return;
    &amp;#125;;
    for (int i = 1; i &amp;lt;= n; ++i)
        if (i != s &amp;amp;&amp;amp; i != t &amp;amp;&amp;amp; !col[i])
            ++now, DFS(i);
    for (int i = 1; i &amp;lt;= now; ++i)
        if (!ps[i].empty() &amp;amp;&amp;amp; !pt[i].empty());
        else if (!ps[i].empty())
            res.emplace_back(ps[i].back(), s), --ds;
        else
            res.emplace_back(pt[i].back(), t), --dt;
    if (ds &amp;lt;= 0 || dt &amp;lt;= 0) &amp;#123;
        std::cout &amp;lt;&amp;lt; &amp;quot;No&amp;quot; &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
        return 0;
    &amp;#125;
    bool flag = false;
    for (int i = 1; i &amp;lt;= now; ++i)
        if (!ps[i].empty() &amp;amp;&amp;amp; !pt[i].empty()) &amp;#123;
            if (flag == false) &amp;#123;
                res.emplace_back(ps[i].back(), s), --ds;
                res.emplace_back(pt[i].back(), t), --dt;
                flag = true;
            &amp;#125;
            else if (ds)
                res.emplace_back(ps[i].back(), s), --ds;
            else if (dt)
                res.emplace_back(pt[i].back(), t), --dt;
            else &amp;#123;
                std::cout &amp;lt;&amp;lt; &amp;quot;No&amp;quot; &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
                return 0;
            &amp;#125;
        &amp;#125;
    if (flag == false)
        for (auto i : g[s])
            if (i == t) &amp;#123;
                res.emplace_back(s, t);
                --ds, --dt, flag = true;
            &amp;#125;
    if (flag == false) &amp;#123;
        std::cout &amp;lt;&amp;lt; &amp;quot;No&amp;quot; &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
        return 0;
    &amp;#125;
    assert((int)res.size() == n - 1);
    std::cout &amp;lt;&amp;lt; &amp;quot;Yes&amp;quot; &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    for (auto [u, v] : res)
        std::cout &amp;lt;&amp;lt; u &amp;lt;&amp;lt; &amp;#39; &amp;#39; &amp;lt;&amp;lt; v &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;b---0-1-mst&#34;&gt;B - 0-1 MST&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/CF1242B&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/CF1242B&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;发现实际上是在问删掉这 &lt;span class=&#34;math inline&#34;&gt;\(m\)&lt;/span&gt; 条边后还剩多少个连通块。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;容易发现删的边相对来说比较少，或者说在 &lt;span class=&#34;math inline&#34;&gt;\(10^5\)&lt;/span&gt; 这个限制下很难分成很多个很大的连通块。&lt;/p&gt;
&lt;p&gt;正解利用了鸽巢原理证明这个事情：相当于把 &lt;span class=&#34;math inline&#34;&gt;\(m\)&lt;/span&gt; 次删边分配给 &lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt; 个点，那么至少存在一个点，被删掉的边不超过 &lt;span class=&#34;math inline&#34;&gt;\(\left\lfloor \frac mn\right\rfloor\)&lt;/span&gt; 条。那么这个点带领的菊花形成了一个大小至少为 &lt;span class=&#34;math inline&#34;&gt;\(n-\left\lfloor \frac mn\right\rfloor\)&lt;/span&gt; 的连通子图。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;剩余的 &lt;span class=&#34;math inline&#34;&gt;\(\left\lfloor \frac mn\right\rfloor\)&lt;/span&gt; 个点，目测不是很大，事实上又是神秘不等式：&lt;span class=&#34;math inline&#34;&gt;\(\left\lfloor \frac mn\right\rfloor^2&amp;lt;n\times \left\lfloor \frac mn\right\rfloor=m\)&lt;/span&gt;。可以暴力枚举点对查看是否有边。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;对于菊花上可能的其他连边，仍然神秘不等式，&lt;span class=&#34;math inline&#34;&gt;\(\left\lfloor \frac mn\right\rfloor\times (n-\left\lfloor \frac mn\right\rfloor)=\left\lfloor \frac mn\right\rfloor\times n-\left\lfloor \frac mn\right\rfloor^2&amp;lt;\left\lfloor \frac mn\right\rfloor\times n=m\)&lt;/span&gt;，仍然暴力枚举即可。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, m;
    std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
    std::vector&amp;lt;int&amp;gt; f(n + 1);
    std::iota(f.begin() + 1, f.end(), 1);
    std::function&amp;lt;int(int)&amp;gt; find = [&amp;amp;](int x) &amp;#123;
        return x == f[x] ? x : f[x] = find(f[x]);
    &amp;#125;;
    auto merge = [&amp;amp;](int x, int y) &amp;#123;
        if (find(x) == find(y))
            return false;
        f[find(x)] = find(y);
        return true;
    &amp;#125;;
    std::vector&amp;lt;int&amp;gt; deg(n + 1, n - 1);
    std::set&amp;lt;std::pair&amp;lt;int, int&amp;gt; &amp;gt; t;
    for (int u, v; m--; ) &amp;#123;
        std::cin &amp;gt;&amp;gt; u &amp;gt;&amp;gt; v;
        t.emplace(std::min(u, v), std::max(u, v)), --deg[u], --deg[v];
    &amp;#125;
    int u = std::max_element(deg.begin() + 1, deg.end()) - deg.begin();
    std::vector&amp;lt;int&amp;gt; p1, p2;
    for (int i = 1; i &amp;lt;= n; ++i)
        if (i == u || !t.count(&amp;#123; std::min(u, i), std::max(u, i) &amp;#125;))
            p1.push_back(i), merge(u, i);
        else
            p2.push_back(i);
    int cnt = 1 + (int)p2.size();
    for (int i = 0; i &amp;lt; (int)p2.size(); ++i) &amp;#123;
        for (int j = 0; j &amp;lt; i; ++j)
            if (!t.count(&amp;#123; std::min(p2[i], p2[j]), std::max(p2[i], p2[j]) &amp;#125;))
                cnt -= merge(p2[i], p2[j]);
        for (int j = 0; j &amp;lt; (int)p1.size(); ++j)
            if (!t.count(&amp;#123; std::min(p2[i], p1[j]), std::max(p2[i], p1[j]) &amp;#125;))
                cnt -= merge(p2[i], p1[j]);
    &amp;#125;
    std::cout &amp;lt;&amp;lt; cnt - 1 &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;c---magic-matrix&#34;&gt;C - Magic Matrix&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/CF632F&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/CF632F&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;神秘不等式。若边 &lt;span class=&#34;math inline&#34;&gt;\(A,B,C\)&lt;/span&gt; 组成三元环，显然有 &lt;span class=&#34;math inline&#34;&gt;\(A\le \max(A,B,C)\)&lt;/span&gt;。考虑 &lt;span class=&#34;math inline&#34;&gt;\(B\)&lt;/span&gt; 参与形成的另一个三元环 &lt;span class=&#34;math inline&#34;&gt;\(B,D,E\)&lt;/span&gt;，那么显然有 &lt;span class=&#34;math inline&#34;&gt;\(A\le \max(A,C,D,E)\)&lt;/span&gt;，（需要注意到此时仍是一个环，很容易证明），etc.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;更可视化地叙述，令 &lt;span class=&#34;math inline&#34;&gt;\((x,y)\)&lt;/span&gt; 为边 &lt;span class=&#34;math inline&#34;&gt;\(A\)&lt;/span&gt; 的两端，则 &lt;span class=&#34;math inline&#34;&gt;\(A\)&lt;/span&gt; 参与构成的所有简单环，&lt;span class=&#34;math inline&#34;&gt;\(A\)&lt;/span&gt; 不大于环上边权最大值。反过来，若存在一个路径最大值小于 &lt;span class=&#34;math inline&#34;&gt;\(A\)&lt;/span&gt; 则判定失败。故 Kruskal 乱 check 一下即可，复杂度 &lt;span class=&#34;math inline&#34;&gt;\(O(n^2\log n)\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;谁家好人写 &lt;span class=&#34;math inline&#34;&gt;\(O(n^2\log n^2)\)&lt;/span&gt; 的？咋看咋不对劲，好在发现问题，保住了高中生的名头。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n;
    std::cin &amp;gt;&amp;gt; n;
    std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; a(n + 1, std::vector&amp;lt;int&amp;gt; (n + 1));
    auto nosol = [&amp;amp;](void) &amp;#123;
        std::cout &amp;lt;&amp;lt; &amp;quot;NOT MAGIC\n&amp;quot;;
        exit(0);
        return;
    &amp;#125;;
    for (int i = 1; i &amp;lt;= n; ++i)
        for (int j = 1; j &amp;lt;= n; ++j)
            std::cin &amp;gt;&amp;gt; a[i][j];
    std::vector&amp;lt;int&amp;gt; l(1);
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        if (a[i][i] != 0)
            nosol();
        for (int j = 1; j &amp;lt; i; ++j) &amp;#123;
            l.push_back(a[i][j]);
            if (a[i][j] != a[j][i])
                nosol();
        &amp;#125;
    &amp;#125;
    std::sort(l.begin() + 1, l.end());
    l.erase(std::unique(l.begin() + 1, l.end()), l.end());
    int m = (int)l.size() - 1;
    std::vector&amp;lt;std::vector&amp;lt;std::pair&amp;lt;int, int&amp;gt; &amp;gt; &amp;gt; e(m + 1);
    for (int i = 1; i &amp;lt;= n; ++i)
        for (int j = 1; j &amp;lt; i; ++j) &amp;#123;
            a[i][j] = std::lower_bound(l.begin() + 1, l.end(), a[i][j]) - l.begin();
            e[a[i][j]].emplace_back(i, j);
        &amp;#125;
    std::vector&amp;lt;int&amp;gt; f(n + 1);
    std::iota(f.begin() + 1, f.end(), 1);
    std::function&amp;lt;int(int)&amp;gt; find = [&amp;amp;](int x) &amp;#123;
        return x == f[x] ? x : f[x] = find(f[x]);
    &amp;#125;;
    for (int i = 1; i &amp;lt;= m; ++i) &amp;#123;
        for (auto [u, v] : e[i])
            if (find(u) == find(v))
                nosol();
        for (auto [u, v] : e[i])
            if (find(u) != find(v))
                f[find(u)] = find(v);
    &amp;#125;
    std::cout &amp;lt;&amp;lt; &amp;quot;MAGIC\n&amp;quot;;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;k---jumbled-trees&#34;&gt;K - Jumbled Trees&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/CF1773J&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/CF1773J&lt;/a&gt;&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://xsc062.netlify.app/20251019/</guid>
            <title>杂题</title>
            <link>https://xsc062.netlify.app/20251019/</link>
            <category>线段树</category>
            <category>最小生成树</category>
            <category>贪心</category>
            <category>优化建图</category>
            <category>DP 优化</category>
            <category>点分治</category>
            <pubDate>Sun, 19 Oct 2025 14:17:38 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;模拟赛 and so on&lt;/p&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;cf1923f-shrink-reverse&#34;&gt;CF1923F Shrink-Reverse&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/CF1923F&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/CF1923F&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;需要想到贪心策略，但正确的策略并没有&lt;strong&gt;那么&lt;/strong&gt;显然。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;观察样例可以大胆猜测，&lt;code&gt;SHRINK_REVERSE&lt;/code&gt; 只会用最多一次。尝试理解这一点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;只考虑 &lt;code&gt;SHRINK&lt;/code&gt;，那么发现只有最后一次 &lt;code&gt;SHRINK&lt;/code&gt; 是有效的。&lt;/li&gt;
&lt;li&gt;只考虑 &lt;code&gt;REVERSE&lt;/code&gt;，那么只需要将两次 &lt;code&gt;REVERSE&lt;/code&gt; 中间的 &lt;code&gt;SWAP&lt;/code&gt; 进行翻转，并删除这两次 &lt;code&gt;REVERSE&lt;/code&gt;，就可以达到相同的作用。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;综上，只需要保留最后一次 &lt;code&gt;SHRINK_REVERSE&lt;/code&gt;，剩下的可以通过翻转对应的 &lt;code&gt;SWAP&lt;/code&gt; 操作达到相同的效果，节省操作次数。且显然这次 &lt;code&gt;SHRINK_REVERSE&lt;/code&gt; 应该放在操作序列的末尾。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;因此，只需要讨论不 &lt;code&gt;SHRINK_REVERSE&lt;/code&gt;、在最后 &lt;code&gt;SHRINK_REVERSE&lt;/code&gt; 两种情况。&lt;/p&gt;
&lt;p&gt;对于不 &lt;code&gt;SHRINK_REVERSE&lt;/code&gt; 的情况，直接贪心即可。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;对于最后再 &lt;code&gt;SHRINK_REVERSE&lt;/code&gt; 的情况，不妨先 &lt;code&gt;REVERSE&lt;/code&gt;，考虑找到 &lt;code&gt;SHRINK&lt;/code&gt; 后对应的原始字符串上的区间。&lt;/p&gt;
&lt;p&gt;也即考虑找到一个最短的子串，使得能够通过 &lt;span class=&#34;math inline&#34;&gt;\(k-1\)&lt;/span&gt; 次 &lt;code&gt;SWAP&lt;/code&gt; 把子串外的 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt; 全部换到子串内。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;问题具有一定的单调性，故可以双指针对于每个 &lt;span class=&#34;math inline&#34;&gt;\(l\)&lt;/span&gt; 找到最小的 &lt;span class=&#34;math inline&#34;&gt;\(r\)&lt;/span&gt;。接下来仍然可以贪心最小化答案。&lt;/p&gt;
&lt;p&gt;很容易说明区间长最短的才能竞争最优：要么 &lt;span class=&#34;math inline&#34;&gt;\(l\)&lt;/span&gt; 初始为 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt;，要么区间长就是 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt; 总数；&lt;/p&gt;
&lt;p&gt;很容易说明相同长度的参与竞争的区间，字典序最小的最优。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;故接下来需要比较这 &lt;span class=&#34;math inline&#34;&gt;\(O(n)\)&lt;/span&gt; 个长度相同的答案区间的字典序。SA 即可。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int mod = 1e9 + 7;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, k;
    std::string s, res1, res2;
    std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; k &amp;gt;&amp;gt; s, s = &amp;#39;#&amp;#39; + s;
    res1 = s;
    for (int i = 1, j = n, l = 1; l &amp;lt;= k &amp;amp;&amp;amp; i &amp;lt; j; ++i, --j, ++l) &amp;#123;
        for (; i &amp;lt; j &amp;amp;&amp;amp; res1[i] != &amp;#39;1&amp;#39;; ++i);
        for (; i &amp;lt; j &amp;amp;&amp;amp; res1[j] != &amp;#39;0&amp;#39;; --j);
        if (i &amp;lt; j)
            std::swap(res1[i], res1[j]);
    &amp;#125;
    for (int i = 1; i &amp;lt;= n; ++i)
        if (res1[i] == &amp;#39;1&amp;#39;) &amp;#123;
            res1 = &amp;#39;#&amp;#39; + res1.substr(i, n - i + 1);
            break;
        &amp;#125;
    std::reverse(s.begin() + 1, s.end());
    std::vector&amp;lt;int&amp;gt; pos;
    const int s1 = std::count(s.begin() + 1, s.end(), &amp;#39;1&amp;#39;);
    int len = n;
    for (int l = 1, r = 0, c1 = 0, c0 = 0; l &amp;lt;= n; ++l) &amp;#123;
        for (; r &amp;lt; n &amp;amp;&amp;amp; (c0 &amp;lt; s1 - c1 || s1 - c1 &amp;gt; k - 1); )
            if (s[++r] == &amp;#39;1&amp;#39;) ++c1;
            else ++c0;
        if (c0 &amp;gt;= s1 - c1 &amp;amp;&amp;amp; s1 - c1 &amp;lt;= k - 1) &amp;#123;
            if (r - l + 1 &amp;lt; len)
                len = r - l + 1, pos.clear();
            if (r - l + 1 == len)
                pos.push_back(l);
        &amp;#125;
        if (s[l] == &amp;#39;1&amp;#39;) --c1;
        else --c0;
    &amp;#125;
    std::vector&amp;lt;int&amp;gt; sa(n + 1), rk(2 * n + 1);
    &amp;#123;
        int m = 128;
        std::vector&amp;lt;int&amp;gt; c(std::max(n, m) + 1), id, la(2 * n + 1);
        std::copy(s.begin() + 1, s.end(), rk.begin() + 1);
        for (int i = 1; i &amp;lt;= n; ++i)
            ++c[rk[i]];
        std::partial_sum(c.begin() + 1, c.begin() + m + 1, c.begin() + 1);
        for (int i = n; i; --i)
            sa[c[rk[i]]--] = i;
        for (int w = 1, p; ; w &amp;lt;&amp;lt;= 1, m = p) &amp;#123;
            id.clear(), id.push_back(-1);
            for (int i = n - w + 1; i &amp;lt;= n; ++i)
                id.push_back(i);
            for (int i = 1; i &amp;lt;= n; ++i)
                if (sa[i] &amp;gt; w)
                    id.push_back(sa[i] - w);
            std::fill(c.begin() + 1, c.begin() + m + 1, 0);
            for (int i = 1; i &amp;lt;= n; ++i)
                ++c[rk[i]];
            std::partial_sum(c.begin() + 1, c.begin() + m + 1, c.begin() + 1);
            for (int i = n; i; --i)
                sa[c[rk[id[i]]]--] = id[i];
            p = 0;
            std::copy(rk.begin() + 1, rk.end(), la.begin() + 1);
            for (int i = 1; i &amp;lt;= n; ++i)
                if (i != 1 &amp;amp;&amp;amp; la[sa[i]] == la[sa[i - 1]] &amp;amp;&amp;amp; la[sa[i] + w] == la[sa[i - 1] + w])
                    rk[sa[i]] = p;
                else
                    rk[sa[i]] = ++p;
            if (p == n)
                break;
        &amp;#125;
    &amp;#125;
    int id = 0;
    for (auto i : pos)
        if (id == 0 || rk[i] &amp;lt; rk[id])
            id = i;
    if (id == 0)
        assert(len == n), id = 1;
    res2 = &amp;#39;#&amp;#39; + s.substr(id, len);
    int tot = s1 - std::count(res2.begin() + 1, res2.end(), &amp;#39;1&amp;#39;);
    for (int i = len; tot--; --i) &amp;#123;
        for (; res2[i] != &amp;#39;0&amp;#39;; --i);
        res2[i] = &amp;#39;1&amp;#39;;
    &amp;#125;
    if (res1.length() == res2.length())
        s = std::min(res1, res2);
    else if (res1.length() &amp;lt; res2.length())
        s = res1;
    else
        s = res2;
    auto res = 0ll;
    for (int i = 1; i &amp;lt; (int)s.size(); ++i)
        res = (res * 2 + s[i] - &amp;#39;0&amp;#39;) % mod;
    std::cout &amp;lt;&amp;lt; res &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;cf1859f-teleportation-in-byteland&#34;&gt;CF1859F Teleportation in Byteland&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/CF1859F&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/CF1859F&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;题设让树自然呈现一个分层图的结构。贪心地，最优的路径一定为 &lt;span class=&#34;math inline&#34;&gt;\(a_i\to u\)&lt;/span&gt;，（在 &lt;span class=&#34;math inline&#34;&gt;\(u\)&lt;/span&gt; 学习若干次），&lt;span class=&#34;math inline&#34;&gt;\(u\to b_i\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;枚举一个学习次数 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt;（显然 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 不会超过 &lt;span class=&#34;math inline&#34;&gt;\(\left\lceil\log_2n\right\rceil\)&lt;/span&gt;），并令 &lt;span class=&#34;math inline&#34;&gt;\(d_k(u,v)\)&lt;/span&gt; 表示在学习 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 次后的分层图上 &lt;span class=&#34;math inline&#34;&gt;\(u\)&lt;/span&gt; 与 &lt;span class=&#34;math inline&#34;&gt;\(v\)&lt;/span&gt; 的距离。最后的答案可以表示为 &lt;span class=&#34;math inline&#34;&gt;\(\min\limits_{u,k}\{d_0(a_i,u)+d_k(u,b_i)+k\cdot T\}\)&lt;/span&gt;。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;现在希望能够快速地找到，对于一个固定的 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt;，使答案最小的 &lt;span class=&#34;math inline&#34;&gt;\(u\)&lt;/span&gt;。询问与路径相关，所以期望一种能和路径挂钩的答案表示方法（似乎是经典 trick）。容易想到链 &lt;span class=&#34;math inline&#34;&gt;\((a_i,b_i)\)&lt;/span&gt; 上离 &lt;span class=&#34;math inline&#34;&gt;\(u\)&lt;/span&gt; 最近的点 &lt;span class=&#34;math inline&#34;&gt;\(v\)&lt;/span&gt;，答案可以改写成：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
\min\limits_{u,v}\{d_0(a_i,v)+d_k(v,b_i)+d_0(v,u)+d_k(u,v)\}+k\cdot T
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其中，&lt;span class=&#34;math inline&#34;&gt;\(d_0(v,u)+d_k(u,v)\)&lt;/span&gt; 与具体的 &lt;span class=&#34;math inline&#34;&gt;\(a,b\)&lt;/span&gt; 无关，可以用一次多源 Dij 预处理出每个 &lt;span class=&#34;math inline&#34;&gt;\(v\)&lt;/span&gt; 的答案（记为 &lt;span class=&#34;math inline&#34;&gt;\(s_k(v)\)&lt;/span&gt;）（需要注意到 &lt;span class=&#34;math inline&#34;&gt;\(d_0(v,u)\)&lt;/span&gt; 和 &lt;span class=&#34;math inline&#34;&gt;\(d_k(u,v)\)&lt;/span&gt; 可能不同时取最小，可以用 &lt;span class=&#34;math inline&#34;&gt;\(w_0+w_k\)&lt;/span&gt; 作边权）；&lt;span class=&#34;math inline&#34;&gt;\(d_0(a_i,v)+d_k(v,b_i)\)&lt;/span&gt; 则可以通过讨论 LCA 直接用深度表示，求出最值。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;记 &lt;span class=&#34;math inline&#34;&gt;\(fa=\text{LCA}(a_i,b_i)\)&lt;/span&gt;，当 &lt;span class=&#34;math inline&#34;&gt;\(v\)&lt;/span&gt; 在 &lt;span class=&#34;math inline&#34;&gt;\(fa\to a_i\)&lt;/span&gt; 上时，答案为：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
(dep_k(v)+s_k(v)-dep_0(v))+(dep_k(b_i)-2dep_k(fa)+dep_0(a_i)+k\cdot T)
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;当 &lt;span class=&#34;math inline&#34;&gt;\(v\)&lt;/span&gt; 在 &lt;span class=&#34;math inline&#34;&gt;\(fa\to b_i\)&lt;/span&gt; 上时，答案为：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
(dep_0(v)+s_k(v)-dep_k(v))+(dep_0(a_i)-2dep_0(fa)+dep_k(b_i)+k\cdot T)
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;维护链上 &lt;span class=&#34;math inline&#34;&gt;\(dep_k(v)+s_k(v)-dep_0(v)\)&lt;/span&gt; 和 &lt;span class=&#34;math inline&#34;&gt;\(dep_0(v)+s_k(v)-dep_k(v)\)&lt;/span&gt; 的最小值即可。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;由于是完全静态的树上路径问题，可以用倍增完成。注意考虑学 &lt;span class=&#34;math inline&#34;&gt;\(0\)&lt;/span&gt; 次的情况。复杂度 &lt;span class=&#34;math inline&#34;&gt;\(O(n\log^2 n)\)&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;咦你怎么 MLE 了？只需要把所有询问离线下来，每个 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 就可以共用数组了。&lt;/p&gt;
&lt;p&gt;看到 Limury 的做法是树剖 + st 表，薄纱所有人。Rosmist 树剖 + bit 三只 log 也薄纱倍增做法，我怎么会做这样的梦。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int maxn = 1e5 + 5;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int T;
    for (std::cin &amp;gt;&amp;gt; T; T--; ) &amp;#123;
        int n, t;
        std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; t;
        std::vector&amp;lt;std::vector&amp;lt;std::pair&amp;lt;int, int&amp;gt; &amp;gt; &amp;gt; g(n + 1);
        for (int i = 1, x, y, w; i &amp;lt; n; ++i) &amp;#123;
            std::cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; y &amp;gt;&amp;gt; w;
            g[x].emplace_back(y, w), g[y].emplace_back(x, w);
        &amp;#125;
        std::vector&amp;lt;int&amp;gt; tag(n + 1);
        for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
            char t;
            std::cin &amp;gt;&amp;gt; t, tag[i] = t - &amp;#39;0&amp;#39;;
        &amp;#125;
        auto fun = [&amp;amp;](int w, int k) &amp;#123;
            return (w + (1 &amp;lt;&amp;lt; k) - 1) &amp;gt;&amp;gt; k;
        &amp;#125;;
        std::vector&amp;lt;long long&amp;gt; s(n + 1);
        std::vector&amp;lt;int&amp;gt; dep(n + 1), vis(n + 1);
        std::vector&amp;lt;std::array&amp;lt;int, 17&amp;gt; &amp;gt; fa(n + 1);
        std::vector&amp;lt;std::array&amp;lt;long long, 17&amp;gt; &amp;gt; f1(n + 1), f2(n + 1);
        std::vector&amp;lt;std::vector&amp;lt;long long&amp;gt; &amp;gt; dis(2, std::vector&amp;lt;long long&amp;gt; (n + 1));
        std::function&amp;lt;void(int)&amp;gt; DFS = [&amp;amp;](int x) &amp;#123;
            for (auto [i, w] : g[x])
                if (i != fa[x][0]) &amp;#123;
                    dep[i] = dep[x] + 1;
                    dis[0][i] = dis[0][x] + w;
                    fa[i][0] = x;
                    for (int j = 1; j &amp;lt; 17; ++j)
                        fa[i][j] = fa[fa[i][j - 1]][j - 1];
                    DFS(i);
                &amp;#125;
            return;
        &amp;#125;;
        dep[1] = 1, DFS(1);
        auto getLCA = [&amp;amp;](int x, int y) &amp;#123;
            if (dep[x] &amp;lt; dep[y])
                std::swap(x, y);
            for (int i = 16; ~i; --i)
                if (dep[fa[x][i]] &amp;gt;= dep[y])
                    x = fa[x][i];
            if (x == y)
                return x;
            for (int i = 16; ~i; --i)
                if (fa[x][i] != fa[y][i])
                    x = fa[x][i], y = fa[y][i];
            return fa[x][0];
        &amp;#125;;
        int m;
        std::cin &amp;gt;&amp;gt; m;
        std::vector&amp;lt;long long&amp;gt; res(m + 1);
        std::vector&amp;lt;std::pair&amp;lt;int, int&amp;gt; &amp;gt; q(m + 1);
        for (int i = 1, u, v; i &amp;lt;= m; ++i) &amp;#123;
            std::cin &amp;gt;&amp;gt; u &amp;gt;&amp;gt; v;
            res[i] = dis[0][u] + dis[0][v] - 2 * dis[0][getLCA(u, v)];;
            q[i] = &amp;#123; u, v &amp;#125;;
        &amp;#125;
        for (int j = 0; j &amp;lt; 17; ++j)
            f1[0][j] = f2[0][j] = 1e18;
        for (int k = 1; k &amp;lt;= 20; ++k) &amp;#123;
            &amp;#123;
                std::priority_queue&amp;lt;std::pair&amp;lt;long long, int&amp;gt; &amp;gt; q;
                for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
                    vis[i] = 0;
                    if (tag[i])
                        s[i] = 0ll, q.emplace(0ll, i);
                    else
                        s[i] = 1e18;
                &amp;#125;
                for (; !q.empty(); ) &amp;#123;
                    int x = q.top().second;
                    q.pop();
                    if (vis[x])
                        continue;
                    vis[x] = 1;
                    for (auto [v, w] : g[x])
                        if (s[v] &amp;gt; s[x] + fun(w, k) + w) &amp;#123;
                            s[v] = s[x] + fun(w, k) + w;
                            q.emplace(-s[v], v);
                        &amp;#125;
                &amp;#125;
            &amp;#125;
            DFS = [&amp;amp;](int x) &amp;#123;
                for (auto [i, w] : g[x])
                    if (i != fa[x][0]) &amp;#123;
                        dis[1][i] = dis[1][x] + fun(w, k);
                        f1[i][0] = dis[1][i] + s[i] - dis[0][i];
                        f2[i][0] = dis[0][i] + s[i] - dis[1][i];
                        for (int j = 1; j &amp;lt; 17; ++j) &amp;#123;
                            f1[i][j] = std::min(f1[i][j - 1], f1[fa[i][j - 1]][j - 1]);
                            f2[i][j] = std::min(f2[i][j - 1], f2[fa[i][j - 1]][j - 1]);
                        &amp;#125;
                        DFS(i);
                    &amp;#125;
                return;
            &amp;#125;;
            DFS(1);
            for (int i = 1; i &amp;lt;= m; ++i) &amp;#123;
                auto [u, v] = q[i];
                int x = u, y = v;
                long long s1 = 1e18, s2 = 1e18;
                if (dep[x] &amp;gt; dep[y]) &amp;#123;
                    for (int i = 16; ~i; --i)
                        if (dep[fa[x][i]] &amp;gt;= dep[y]) &amp;#123;
                            s1 = std::min(s1, f1[x][i]);
                            x = fa[x][i];
                        &amp;#125;
                &amp;#125;
                else &amp;#123;
                    for (int i = 16; ~i; --i)
                        if (dep[fa[y][i]] &amp;gt;= dep[x]) &amp;#123;
                            s2 = std::min(s2, f2[y][i]);
                            y = fa[y][i];
                        &amp;#125;
                &amp;#125;
                if (x != y) &amp;#123;
                    for (int i = 16; ~i; --i)
                        if (fa[x][i] != fa[y][i]) &amp;#123;
                            s1 = std::min(s1, f1[x][i]);
                            s2 = std::min(s2, f2[y][i]);
                            x = fa[x][i], y = fa[y][i];
                        &amp;#125;
                    s1 = std::min(s1, f1[x][0]);
                    s2 = std::min(s2, f2[y][0]);
                    x = fa[x][0];
                &amp;#125;
                s1 = std::min(s1, dis[1][x] + s[x] - dis[0][x]);
                s2 = std::min(s2, dis[0][x] + s[x] - dis[1][x]);
                res[i] = std::min(res[i], k * t + dis[0][u] + dis[1][v] + std::min(s1 - 2 * dis[1][x], s2 - 2 * dis[0][x]));
            &amp;#125;
        &amp;#125;
        for (int i = 1; i &amp;lt;= m; ++i)
            std::cout &amp;lt;&amp;lt; res[i] &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    &amp;#125;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;cf1556g-gates-to-another-world&#34;&gt;CF1556G Gates to Another World&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/CF1556G&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/CF1556G&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;快速做出来需要一定运气，需要把点顺序排布而不是像题目一样画晶胞（。）手玩一下 &lt;span class=&#34;math inline&#34;&gt;\(n=4\)&lt;/span&gt; 时的情况：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;看到两个相邻点间连的边就应激想到线段树了，事实上把不同层的边提起来发现就是线段树的结构。&lt;/p&gt;
&lt;details&gt;
&lt;p&gt;&lt;summary&gt;为什么这个图这么大（没啥用故折起来了）&lt;/summary&gt;&lt;/p&gt;
&lt;p&gt;tip：实际上那些相邻 / 相反的尖尖是重合的，为了好看一点故错开。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image-1.png&#34; /&gt;&lt;/p&gt;
&lt;/details&gt;
&lt;p&gt;发现形成一个&lt;strong&gt;相邻子树对位连边&lt;/strong&gt;的结构。这里线段树其实只有底层点是有意义的，其他点只起结构辅助作用。&lt;/p&gt;
&lt;p&gt;实际上，对于两个有连边的点，它们『LCA』的高度是被 flip 的位。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;很容易注意到一个线段树子树内的底层点是连通的，这一点也很容易递归地证明。&lt;/p&gt;
&lt;p&gt;考虑动态开点线段树优化建图，对于动态开点出来的叶子（注意不是底层点），容易发现在题目限制下每个叶子内部都没有点被删除，是连通的（那么此时不妨认为叶子就代表了这个连通块）。&lt;/p&gt;
&lt;p&gt;故将某个点进行连边时，并不要求找到对位的那个点（不一定存在），和走到头的叶子连边就可以达到相同的连通效果。这样就把底层点之间的连边转化为了&lt;strong&gt;叶子间&lt;/strong&gt;的连边。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;不妨先时光倒流 + 预处理出每个叶子最后（最早）存在的时间戳，考虑暴力连出来这些叶子间的边（对于每个点，将对位的叶子连边）并计算出边最后（最早）存在的时间戳。&lt;/p&gt;
&lt;p&gt;发现暴力对位连边这个操作，是形似线段树合并但比线段树合并更劣的东西。咋分析复杂度。&lt;/p&gt;
&lt;p&gt;边是双向的，考虑更深的叶子的贡献。那么其枚举 lca + flip 对应位（不存在则取路径上的叶子），一共会有 &lt;span class=&#34;math inline&#34;&gt;\(O(n)\)&lt;/span&gt; 次连边。共有 &lt;span class=&#34;math inline&#34;&gt;\(O(nm)\)&lt;/span&gt; 个叶子，摊下来暴力连边复杂度为 &lt;span class=&#34;math inline&#34;&gt;\(O(n^2m)\)&lt;/span&gt;。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;p&gt;空间很卡…… 不要把离线的加边数组开成 &lt;code&gt;long long&lt;/code&gt; 了。&lt;/p&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int maxn = 32e5 + 5;
using ll = long long;
struct &amp;#123; int l, r, d; &amp;#125; t[maxn];
int tot;
#define lt t[p].l
#define rt t[p].r
#define leaf(p) (!t[p].l &amp;amp;&amp;amp; !t[p].r)
int newnode(void) &amp;#123;
    ++tot, t[tot].l = t[tot].r = t[tot].d = 0;
    return tot;
&amp;#125;
void pushdown(int p) &amp;#123;
    if (t[p].d) &amp;#123;
        if (!lt)
            lt = newnode();
        if (!rt)
            rt = newnode();
        t[lt].d = t[rt].d = t[p].d;
        t[p].d = 0;
    &amp;#125;
    return;
&amp;#125;
void upd(int &amp;amp;p, ll l, ll r, ll ql, ll qr, int v) &amp;#123;
    if (!p)
        p = newnode();
    if (ql &amp;lt;= l &amp;amp;&amp;amp; r &amp;lt;= qr) &amp;#123;
        t[p].d = v;
        return;
    &amp;#125;
    pushdown(p);
    auto mid = (l + r) &amp;gt;&amp;gt; 1;
    if (ql &amp;lt;= mid)
        upd(lt, l, mid, ql, qr, v);
    if (qr &amp;gt; mid)
        upd(rt, mid + 1, r, ql, qr, v);
    return;
&amp;#125;
int ask(int p, ll l, ll r, ll x) &amp;#123;
    if (leaf(p))
        return p;
    ll mid = (l + r) &amp;gt;&amp;gt; 1;
    if (x &amp;lt;= mid)
        return ask(lt, l, mid, x);
    return ask(rt, mid + 1, r, x);
&amp;#125;
#undef lt
#undef rt
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, m, rt = newnode();
    std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
    t[rt].d = m + 1;
    const auto N = (1ll &amp;lt;&amp;lt; n) - 1;
    struct query &amp;#123; int op; ll s, t; &amp;#125;;
    std::vector&amp;lt;query&amp;gt; q(m + 1);
    for (int i = 1; i &amp;lt;= m; ++i) &amp;#123;
        std::string op;
        std::cin &amp;gt;&amp;gt; op;
        q[i].op = (op == &amp;quot;ask&amp;quot;) + 1;
        std::cin &amp;gt;&amp;gt; q[i].s &amp;gt;&amp;gt; q[i].t;
        if (q[i].op == 1)
            upd(rt, 0ll, N, q[i].s, q[i].t, i);
    &amp;#125;
    std::vector&amp;lt;int&amp;gt; f(tot + 1);
    std::iota(f.begin() + 1, f.end(), 1);
    std::function&amp;lt;int(int)&amp;gt; find = [&amp;amp;](int x) &amp;#123;
        return x == f[x] ? x : f[x] = find(f[x]);
    &amp;#125;;
    auto merge = [&amp;amp;](int x, int y) &amp;#123;
        f[find(x)] = find(y);
        return;
    &amp;#125;;
    std::vector&amp;lt;std::vector&amp;lt;std::pair&amp;lt;int, int&amp;gt; &amp;gt; &amp;gt; u(m + 2);
    std::function&amp;lt;void(int, int)&amp;gt; link = [&amp;amp;](int p, int q) &amp;#123;
        if (leaf(p) &amp;amp;&amp;amp; leaf(q)) &amp;#123;
            u[std::min(t[p].d, t[q].d)].emplace_back(p, q);
            return;
        &amp;#125;
        else if (leaf(p))
            link(p, t[q].l), link(p, t[q].r);
        else if (leaf(q))
            link(t[p].l, q), link(t[p].r, q);
        else
            link(t[p].l, t[q].l), link(t[p].r, t[q].r);
        return;
    &amp;#125;;
    for (int i = 1; i &amp;lt;= tot; ++i)
        if (t[i].l &amp;amp;&amp;amp; t[i].r)
            link(t[i].l, t[i].r);
    for (auto [p, q] : u[m + 1])
        merge(p, q);
    std::vector&amp;lt;int&amp;gt; res;
    for (int i = m; i; --i)
        if (q[i].op == 2)
            res.push_back(find(ask(rt, 0, N, q[i].s)) == find(ask(rt, 0, N, q[i].t)));
        else
            for (auto [p, q] : u[i])
                merge(p, q);
    for (; !res.empty(); res.pop_back())
        std::cout &amp;lt;&amp;lt; res.back() &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;c.-小-z-爱优化&#34;&gt;C. 小 Z 爱优化&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.becoder.com.cn/contest/6662/problem/3&#34; class=&#34;uri&#34;&gt;https://www.becoder.com.cn/contest/6662/problem/3&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定 &lt;span class=&#34;math inline&#34;&gt;\(a_{1\sim n}\)&lt;/span&gt;，将其分为若干连续段，满足每段长度为 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt; 或 &lt;span class=&#34;math inline&#34;&gt;\(2\)&lt;/span&gt;，定义一段的权值为元素之和，最小化段权值的极差并输出之。&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(n\le 2\times 10^5,V=10^9\)&lt;/span&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;令 &lt;span class=&#34;math inline&#34;&gt;\(f_{i,j}\)&lt;/span&gt; 表示这一段以 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 结尾，最小值为 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; 时的最大值。把最小值当状态是自然的想法，实际似乎差不多（。）得到（&lt;strong&gt;不重要&lt;/strong&gt;）：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
f_{i,a_i}\gets f_{i-1,j},j\ge a_i\\
f_{i,a_i+a_{i-1}}\gets f_{i-2,j},j\ge a_i+a_{i-1}\\
f_{i,j}\gets \max(f_{i-1,j},a_i) ,j\le a_i\\
f_{i,j}\gets \max(f_{i-2,j},a_i+a_{i-1}) ,j\le a_i
\]&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;这个状态很矩阵，可以考虑下标分奇偶性继承，用线段树优化，矩阵作为元素；然而同时涉及两个维度，尤其是第一维的变化，实在是答辩啊！&lt;/p&gt;
&lt;details&gt;
&lt;p&gt;&lt;summary&gt;By the way，广义矩乘的结合律？&lt;/summary&gt;&lt;/p&gt;
&lt;p&gt;对于一个 &lt;span class=&#34;math inline&#34;&gt;\(\oplus-\otimes\)&lt;/span&gt; 矩阵（内层为 &lt;span class=&#34;math inline&#34;&gt;\(\otimes\)&lt;/span&gt;，外层为 &lt;span class=&#34;math inline&#34;&gt;\(\oplus\)&lt;/span&gt;），其有结合律当且仅当同时满足：&lt;/p&gt;
&lt;ol type=&#34;1&#34;&gt;
&lt;li&gt;&lt;span class=&#34;math inline&#34;&gt;\(\oplus\)&lt;/span&gt; 有交换律；&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;math inline&#34;&gt;\(\otimes\)&lt;/span&gt; 有结合律；&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;math inline&#34;&gt;\(\otimes\)&lt;/span&gt; 对 &lt;span class=&#34;math inline&#34;&gt;\(\oplus\)&lt;/span&gt; 有分配律。&lt;/li&gt;
&lt;/ol&gt;
&lt;figure&gt;
&lt;img src=&#34;image-2.png&#34; alt=&#34;来自 qkhm 关于广义矩阵乘法常见误区的一点纠正&#34; /&gt;&lt;figcaption&gt;来自 qkhm &lt;a href=&#34;https://www.cnblogs.com/qkhm/p/19055513/ddp&#34;&gt;关于广义矩阵乘法常见误区的一点纠正&lt;/a&gt;&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/details&gt;
&lt;p&gt;发现第二维其实不会怎么变，或者说第二维其实起的是一个&lt;strong&gt;限制&lt;/strong&gt;性的作用，可以考虑把第二维放到外层循环，相当于枚举&lt;strong&gt;限制&lt;/strong&gt;。我们知道上面的做法可以很快地优化，所以拿出去了之后大概也能做。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;若限制当前最小值不能小于 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt;，那么有：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
f_i\gets \max(f_{i-1},a_i),a_j\ge j\\
f_i\gets \max(f_{i-2},a_i+a_{i-1}),a_i+a_{i-1}\ge j
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;发现这就很显然是一个 DDP 的形式了，每次 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; 改变时，只需要改动对应位置的矩阵（即是否能进行转移），总修改次数是 &lt;span class=&#34;math inline&#34;&gt;\(O(n)\)&lt;/span&gt; 的。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int maxn = 2e5 + 5;
const int inf = 0x7fffffff;
using mat = std::array&amp;lt;std::array&amp;lt;int, 2&amp;gt;, 2&amp;gt;;
int m[maxn][2][2];
void mul(mat &amp;amp;res, mat &amp;amp;p, mat &amp;amp;q) &amp;#123;
    res[0][0] = std::min(std::max(p[0][0], q[0][0]), std::max(p[0][1], q[1][0]));
    res[0][1] = std::min(std::max(p[0][0], q[0][1]), std::max(p[0][1], q[1][1]));
    res[1][0] = std::min(std::max(p[1][0], q[0][0]), std::max(p[1][1], q[1][0]));
    res[1][1] = std::min(std::max(p[1][0], q[0][1]), std::max(p[1][1], q[1][1]));
    return;
&amp;#125;
struct &amp;#123;
    int l, r;
    mat u;
&amp;#125; t[maxn &amp;lt;&amp;lt; 2];
#define lt (p &amp;lt;&amp;lt; 1)
#define rt (lt | 1)
void bld(int p, int l, int r) &amp;#123;
    t[p].l = l, t[p].r = r;
    if (l == r) &amp;#123;
        t[p].u[0][0] = m[l][0][0];
        t[p].u[0][1] = m[l][0][1];
        t[p].u[1][0] = m[l][1][0];
        t[p].u[1][1] = m[l][1][1];
        return;
    &amp;#125;
    int mid = (l + r) &amp;gt;&amp;gt; 1;
    bld(lt, l, mid), bld(rt, mid + 1, r);
    mul(t[p].u, t[lt].u, t[rt].u);
    return;
&amp;#125;
void upd(int p, int x) &amp;#123;
    if (t[p].l == t[p].r) &amp;#123;
        t[p].u[0][1] = m[x][0][1];
        t[p].u[1][1] = m[x][1][1];
        return;
    &amp;#125;
    int mid = (t[p].l + t[p].r) &amp;gt;&amp;gt; 1;
    if (x &amp;lt;= mid)
        upd(lt, x);
    else
        upd(rt, x);
    mul(t[p].u, t[lt].u, t[rt].u);
    return;
&amp;#125;
#undef lt
#undef rt
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
    std::freopen(&amp;quot;opti.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;opti.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#else
    std::freopen(&amp;quot;./test/20251021/opti/1.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    auto stime = std::chrono::steady_clock::now();
#endif
    int T;
    for (std::cin &amp;gt;&amp;gt; T; T--; ) &amp;#123;
        int n;
        std::cin &amp;gt;&amp;gt; n;
        std::vector&amp;lt;int&amp;gt; a(n + 1), b(n + 1), l(1);
        for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
            std::cin &amp;gt;&amp;gt; a[i];
            l.push_back(a[i]);
            if (i &amp;gt; 1)
                b[i] = a[i] + a[i - 1], l.push_back(b[i]);
        &amp;#125;
        std::sort(l.begin() + 1, l.end());
        l.erase(std::unique(l.begin() + 1, l.end()), l.end());
        int m = (int)l.size() - 1;
        std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; ida(m + 1), idb(m + 1);
        for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
            a[i] = std::lower_bound(l.begin() + 1, l.end(), a[i]) - l.begin();
            ::m[i][1][1] = a[i], ida[a[i]].push_back(i);
            if (i &amp;gt; 1) &amp;#123;
                b[i] = std::lower_bound(l.begin() + 1, l.end(), b[i]) - l.begin();
                ::m[i][0][1] = b[i], idb[b[i]].push_back(i);
            &amp;#125;
            else
                ::m[i][0][1] = inf;
            ::m[i][0][0] = inf, ::m[i][1][0] = 0;
        &amp;#125;
        bld(1, 1, n);
        auto res = inf;
        for (int i = 1; i &amp;lt;= m; ++i) &amp;#123;
            if (std::min(t[1].u[0][1], t[1].u[1][1]) != inf)
                res = std::min(res, l[std::min(t[1].u[0][1], t[1].u[1][1])] - l[i]);
            for (auto j : ida[i])
                ::m[j][1][1] = inf, upd(1, j);
            for (auto j : idb[i])
                ::m[j][0][1] = inf, upd(1, j);
        &amp;#125;
        std::cout &amp;lt;&amp;lt; res &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    &amp;#125;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt;(std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s \n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;d.-小-z-爱考试&#34;&gt;D. 小 Z 爱考试&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.becoder.com.cn/contest/6662/problem/4&#34; class=&#34;uri&#34;&gt;https://www.becoder.com.cn/contest/6662/problem/4&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定一个大小为 &lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt; 的内向基环树森林，每个点 &lt;span class=&#34;math inline&#34;&gt;\(u\)&lt;/span&gt; 上附有点权 &lt;span class=&#34;math inline&#34;&gt;\(a_u\)&lt;/span&gt;、收益 &lt;span class=&#34;math inline&#34;&gt;\(w_u\)&lt;/span&gt; 和一个进程，内容为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;若 &lt;span class=&#34;math inline&#34;&gt;\(u\)&lt;/span&gt; 指向的结点 &lt;span class=&#34;math inline&#34;&gt;\(fa\)&lt;/span&gt; 满足 &lt;span class=&#34;math inline&#34;&gt;\(a_{fa}&amp;gt;a_u\)&lt;/span&gt;，则令 &lt;span class=&#34;math inline&#34;&gt;\(a_u\gets a_u+w_u\)&lt;/span&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;给定 &lt;span class=&#34;math inline&#34;&gt;\(m\)&lt;/span&gt; 次操作，形如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单点修改 &lt;span class=&#34;math inline&#34;&gt;\(a_u,w_u\)&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;给定一个 &lt;span class=&#34;math inline&#34;&gt;\(u\)&lt;/span&gt;，输出：在 &lt;span class=&#34;math inline&#34;&gt;\(n!\)&lt;/span&gt; 种进程的执行序列中，&lt;span class=&#34;math inline&#34;&gt;\(a_u\)&lt;/span&gt; 最终值的期望。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(n,m\le 2\times 10^5\)&lt;/span&gt;。&lt;strong&gt;保证每个点的入度 &lt;span class=&#34;math inline&#34;&gt;\(\le 3\)&lt;/span&gt;&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;可以感受到操作的『后效性』是非常弱的，进一步感受到点可以粗暴地分为三种类型：&lt;/p&gt;
&lt;ol type=&#34;1&#34;&gt;
&lt;li&gt;&lt;span class=&#34;math inline&#34;&gt;\(a_{fa}&amp;gt;a_x\)&lt;/span&gt; 的；&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;math inline&#34;&gt;\(a_{fa}+w_{fa} \le a_x\)&lt;/span&gt; 的；&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;math inline&#34;&gt;\(a_{fa}\le a_x&amp;lt;a_{fa} + w_{fa}\)&lt;/span&gt; 的；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;点的类型是无依赖，可直接求的。显然，若 &lt;span class=&#34;math inline&#34;&gt;\(u\)&lt;/span&gt; 最终想取到 &lt;span class=&#34;math inline&#34;&gt;\(a_u+w_u\)&lt;/span&gt;，相当于走一条 &lt;span class=&#34;math inline&#34;&gt;\(u\)&lt;/span&gt; 开头，经过若干 3 类点，在 1 类点结尾的路径（这显然是确定的），假设路径包含 &lt;span class=&#34;math inline&#34;&gt;\(len\)&lt;/span&gt; 个点，答案为 &lt;span class=&#34;math inline&#34;&gt;\(\dfrac {(n-len)!\cdot C_{n}^{len}}{n!}=\dfrac 1{len!}\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;换句话说，&lt;span class=&#34;math inline&#34;&gt;\(u\)&lt;/span&gt; 取不到 &lt;span class=&#34;math inline&#34;&gt;\(a_u+w_u\)&lt;/span&gt;，当且仅当路径上在出现 1 类点前出现了 2 类点或 3 类点的环（基环）。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;考虑静态的情况，先处理所有基环：若只存在 3 类点，则标记全部非法；否则，任选一个 1 类点或者 2 类点开头，就可以 DP 出环上的 &lt;span class=&#34;math inline&#34;&gt;\(len\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;对于所有树，直接大力 DP 即可。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;接着考虑带修的情况，修改相当于改变点及其后继的状态（原来入度限制是拿来做这个的）。&lt;/p&gt;
&lt;p&gt;发现没啥办法很好地做这个类 DDP 的问题。考虑到一场比赛不应该出现两道 DDP，故如果灵感迸发可能会想到干脆放弃预处理的想法，上重链，线段树维护区间 1 类点或 2 类点深度 max，即可做到两只 log。&lt;/p&gt;
&lt;p&gt;如果发现树上没有这样的点，在环上也可以类似地找到第一个 1 类点或 2 类点。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;p&gt;感觉写复杂了，瞻仰了一下别人的代码又感觉流程上没什么区别&lt;/p&gt;
&lt;p&gt;喜提最长代码，喜提最优解&lt;/p&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int mod = 1e9 + 7;
const int maxn = 6e5 + 5;
struct &amp;#123;
    int l, r, lc, rc, u1, u2;
&amp;#125; t[maxn &amp;lt;&amp;lt; 2];
#define lt t[p].lc
#define rt t[p].rc
int tot;
int ty[maxn], dep[maxn];
void bld(int &amp;amp;p, int l, int r) &amp;#123;
    p = ++tot;
    t[p].l = l, t[p].r = r;
    if (l == r) &amp;#123;
        t[p].u1 = t[p].u2 = 0;
        if (ty[l] == 1)
            t[p].u1 = dep[l];
        else if (ty[l] == 2)
            t[p].u2 = dep[l];
        return;
    &amp;#125;
    int mid = (l + r) &amp;gt;&amp;gt; 1;
    bld(lt, l, mid), bld(rt, mid + 1, r);
    t[p].u1 = std::max(t[lt].u1, t[rt].u1);
    t[p].u2 = std::max(t[lt].u2, t[rt].u2);
    return;
&amp;#125;
void upd(int p, int x) &amp;#123;
    if (t[p].l == t[p].r) &amp;#123;
        t[p].u1 = t[p].u2 = 0;
        if (ty[x] == 1)
            t[p].u1 = dep[x];
        else if (ty[x] == 2)
            t[p].u2 = dep[x];
        return;
    &amp;#125;
    int mid = (t[p].l + t[p].r) &amp;gt;&amp;gt; 1;
    if (x &amp;lt;= mid)
        upd(lt, x);
    else
        upd(rt, x);
    t[p].u1 = std::max(t[lt].u1, t[rt].u1);
    t[p].u2 = std::max(t[lt].u2, t[rt].u2);
    return;
&amp;#125;
std::pair&amp;lt;int, int&amp;gt; ask(int p, int l, int r) &amp;#123;
    if (l &amp;lt;= t[p].l &amp;amp;&amp;amp; t[p].r &amp;lt;= r)
        return std::make_pair(t[p].u1, t[p].u2);
    int mid = (t[p].l + t[p].r) &amp;gt;&amp;gt; 1;
    std::pair&amp;lt;int, int&amp;gt; res(0, 0);
    if (l &amp;lt;= mid)
        res = ask(lt, l, r);
    if (r &amp;gt; mid) &amp;#123;
        auto s(ask(rt, l, r));
        res.first = std::max(res.first, s.first);
        res.second = std::max(res.second, s.second);
    &amp;#125;
    return res;
&amp;#125;
#undef lt
#undef rt
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
    std::freopen(&amp;quot;exam.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    std::freopen(&amp;quot;exam.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
#else
    std::freopen(&amp;quot;./test/20251021/exam/3.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int T;
    for (std::cin &amp;gt;&amp;gt; T; T--; ) &amp;#123;
        int n, m;
        std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
        std::vector&amp;lt;int&amp;gt; f(n + 1);
        std::iota(f.begin() + 1, f.end(), 1);
        std::function&amp;lt;int(int)&amp;gt; find = [&amp;amp;](int x) &amp;#123;
            return x == f[x] ? x : f[x] = find(f[x]);
        &amp;#125;;
        auto merge = [&amp;amp;](int x, int y) &amp;#123;
            f[find(x)] = find(y);
            return;
        &amp;#125;;
        std::vector&amp;lt;long long&amp;gt; fac(n + 1), inv(n + 1);
        fac[0] = inv[0] = 1ll;
        for (int i = 1; i &amp;lt;= n; ++i)
            fac[i] = fac[i - 1] * i % mod;
        auto qkp = [&amp;amp;](long long x, int y) &amp;#123;
            auto res = 1ll;
            for (; y; (x *= x) %= mod, y &amp;gt;&amp;gt;= 1)
                if (y &amp;amp; 1)
                    (res *= x) %= mod;
            return res;
        &amp;#125;;
        inv[n] = qkp(fac[n], mod - 2);
        for (int i = n - 1; i; --i)
            inv[i] = inv[i + 1] * (i + 1) % mod;
        std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; g(n + 1);
        std::vector&amp;lt;int&amp;gt; a(n + 1), w(n + 1), to(n + 1), col(2 * n + 1);
        for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
            std::cin &amp;gt;&amp;gt; a[i] &amp;gt;&amp;gt; to[i] &amp;gt;&amp;gt; w[i];
            merge(i, to[i]);
            g[to[i]].push_back(i);
        &amp;#125;
        int now = 0, tot = n;
        std::vector&amp;lt;int&amp;gt; tab(n + 1), tad(n + 1), vis(n + 1), L(2 * n + 1), R(2 * n + 1);
        auto getty = [&amp;amp;](int x) &amp;#123;
            if (a[to[x]] &amp;gt; a[x])
                return 1;
            if (a[to[x]] + w[to[x]] &amp;lt;= a[x])
                return 2;
            return 3;
        &amp;#125;;
        for (int i = 1; i &amp;lt;= n; ++i)
            if (f[i] == i) &amp;#123;
                std::vector&amp;lt;int&amp;gt; vis(n + 1), t(1);
                std::stack&amp;lt;int&amp;gt; st;
                for (int x = i; ; ) &amp;#123;
                    st.push(x);
                    if (!vis[to[x]])
                        vis[to[x]] = 1, x = to[x];
                    else &amp;#123;
                        for (;;) &amp;#123;
                            t.push_back(st.top());
                            if (st.top() == to[x])
                                break;
                            st.pop();
                        &amp;#125;
                        break;
                    &amp;#125;
                &amp;#125;
                int k = (int)t.size() - 1;
                std::reverse(t.begin() + 1, t.end());
                t.resize(2 * k + 1);
                L[++tot] = now + 1;
                for (int i = 1; i &amp;lt;= k; ++i) &amp;#123;
                    tab[t[i]] = ++now;
                    col[t[i]] = tot;
                    ::dep[tab[t[i]]] = 2 * k - i + 1;
                    ::ty[tab[t[i]]] = getty(t[i]);
                &amp;#125;
                for (int i = k + 1; i &amp;lt;= 2 * k; ++i) &amp;#123;
                    t[i] = t[i - k];
                    tad[t[i]] = ++now;
                    ::dep[tad[t[i]]] = 2 * k - i + 1;
                    ::ty[tad[t[i]]] = getty(t[i]);
                &amp;#125;
                R[tot] = now;
            &amp;#125;
        std::vector&amp;lt;int&amp;gt; fa(n + 1), siz(n + 1), son(n + 1), dep(n + 1);
        std::function&amp;lt;void(int)&amp;gt; DFS = [&amp;amp;](int x) &amp;#123;
            siz[x] = 1;
            for (auto i : g[x])
                if (!tab[i]) &amp;#123;
                    dep[i] = dep[x] + 1;
                    fa[i] = x, DFS(i);
                    siz[x] += siz[i];
                    if (siz[i] &amp;gt; siz[son[x]])
                        son[x] = i;
                &amp;#125;
            return;
        &amp;#125;;
        for (int i = 1; i &amp;lt;= n; ++i)
            if (tab[i])
                dep[i] = 1, DFS(i);
        std::vector&amp;lt;int&amp;gt; rt(2 * n + 1), dfn(n + 1), top(n + 1), bot(n + 1);
        DFS = [&amp;amp;](int x) &amp;#123;
            dfn[x] = ++now;
            ty[dfn[x]] = getty(x);
            ::dep[dfn[x]] = dep[x];
            bot[top[x]] = x;
            if (son[x])
                top[son[x]] = top[x], DFS(son[x]);
            for (auto i : g[x])
                if (i != son[x] &amp;amp;&amp;amp; !tab[i])
                    top[i] = i, DFS(i);
            if (x == top[x])
                bld(rt[x], dfn[x], dfn[bot[x]]);
            return;
        &amp;#125;;
        for (int i = 1; i &amp;lt;= n; ++i)
            if (tab[i])
                top[i] = i, DFS(i);
        for (int i = n + 1; i &amp;lt;= tot; ++i)
            bld(rt[i], L[i], R[i]);
        auto work = [&amp;amp;](int x) &amp;#123;
            ty[dfn[x]] = getty(x);
            upd(rt[top[x]], dfn[x]);
            if (tab[x]) &amp;#123;
                ty[tab[x]] = ty[tad[x]] = getty(x);
                upd(rt[col[x]], tab[x]), upd(rt[col[x]], tad[x]);
            &amp;#125;
            return;
        &amp;#125;;
        for (int op; m--; ) &amp;#123;
            std::cin &amp;gt;&amp;gt; op;
            if (op == 1) &amp;#123;
                int x;
                std::cin &amp;gt;&amp;gt; x, std::cin &amp;gt;&amp;gt; a[x];
                work(x);
                for (auto i : g[x])
                    work(i);
            &amp;#125;
            else if (op == 2) &amp;#123;
                int x;
                std::cin &amp;gt;&amp;gt; x, std::cin &amp;gt;&amp;gt; w[x];
                work(x);
                for (auto i : g[x])
                    work(i);
            &amp;#125;
            else &amp;#123;
                int x;
                std::cin &amp;gt;&amp;gt; x;
                auto calc = [&amp;amp;](int x) &amp;#123;
                    int len = 0, toq = 0;
                    for (; x; x = fa[top[x]]) &amp;#123;
                        auto [u1, u2] = ask(rt[top[x]], dfn[top[x]], dfn[x]);
                        if (u1 &amp;gt; u2)
                            return len + dep[x] - u1 + 1;
                        if (u2 &amp;gt; u1)
                            return -1;
                        len += dep[x] - dep[fa[top[x]]], toq = top[x];
                    &amp;#125;
                    auto [u1, u2] = ask(rt[col[toq]], tab[toq], R[col[toq]]);
                    if (u1 &amp;gt; u2)
                        return len + ::dep[tab[toq]] - u1;
                    return -1;
                &amp;#125;;
                auto t(calc(x));
                if (t == -1)
                    std::cout &amp;lt;&amp;lt; a[x] &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
                else &amp;#123;
                    // std::cout &amp;lt;&amp;lt; &amp;quot;len = &amp;quot; &amp;lt;&amp;lt; t &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
                    std::cout &amp;lt;&amp;lt; ((a[x] + w[x]) * inv[t] % mod + (1ll + mod - inv[t]) % mod * a[x] % mod) % mod &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
                &amp;#125;
            &amp;#125;
        &amp;#125;
    &amp;#125;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;b.-炒鱿鱼&#34;&gt;B. 炒鱿鱼&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.becoder.com.cn/contest/6666/problem/2&#34; class=&#34;uri&#34;&gt;https://www.becoder.com.cn/contest/6666/problem/2&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;现在有一个栈。在接下来的 &lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt; 个时刻，每个时刻会发生一次事件，形如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;删除栈顶的 &lt;span class=&#34;math inline&#34;&gt;\(a_i\)&lt;/span&gt; 个元素，然后向栈顶加入 &lt;span class=&#34;math inline&#34;&gt;\(b_i\)&lt;/span&gt; 个元素。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;现在每个时刻都让一个人去执行事件，需要满足每个元素，加入它的和删除它的不能是同一个人。问最少需要多少个人才能实现这一点。输出方案。有 SPJ。&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(n\le 10^5,V=10^9\)&lt;/span&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;可以猜到答案只会为 1 2 3，尝试从图染色的角度考虑这个问题（&lt;strong&gt;怎么想到这一点？&lt;/strong&gt;）。&lt;/li&gt;
&lt;li&gt;一个元素在哪个时刻被加入 / 删除是固定的，故如果两天有冲突，可以考虑直接连边。考虑模拟，能够线性地求出来所有冲突关系，故边数是 &lt;span class=&#34;math inline&#34;&gt;\(O(n)\)&lt;/span&gt; 的。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;由于这个栈的结构，发现不存在交错的边，或者说不同时存在 &lt;span class=&#34;math inline&#34;&gt;\((x_1,y_1)\)&lt;/span&gt; 和 &lt;span class=&#34;math inline&#34;&gt;\((x_2,y_2)\)&lt;/span&gt;，使得 &lt;span class=&#34;math inline&#34;&gt;\(x_1&amp;lt;x_2&amp;lt;y_1&amp;lt;y_2\)&lt;/span&gt;。考虑构造解：&lt;/p&gt;
&lt;p&gt;首先对于 &lt;span class=&#34;math inline&#34;&gt;\(1,n\)&lt;/span&gt; 任意涂色，忽略 &lt;span class=&#34;math inline&#34;&gt;\((1,n)\)&lt;/span&gt; 这条边（如果有），显然可以找到一个 &lt;span class=&#34;math inline&#34;&gt;\(mid\)&lt;/span&gt; 使得没有边跨过之，给其赋一个合法的颜色，接着就可以分治构造。&lt;/p&gt;
&lt;p&gt;感觉这种构造不算太显然，只能算是能想到（实际上并没有）。&lt;/p&gt;
&lt;p&gt;具体分治，由于性质比较好，直接取左端点对应范围内最远的边即可。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;需要注意上述构造方案能保证可以构造出 &lt;span class=&#34;math inline&#34;&gt;\(k=3\)&lt;/span&gt; 的解，但不能保证是最优的（即不能保证 &lt;span class=&#34;math inline&#34;&gt;\(k=1\)&lt;/span&gt; 或 &lt;span class=&#34;math inline&#34;&gt;\(k=2\)&lt;/span&gt; 也能构造出对应的解），故需要特判没有边 + 二分图两种情况。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
    std::freopen(&amp;quot;fire.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;fire.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#else
    // std::freopen(&amp;quot;./test/20251022/fire/fire2.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n;
    std::cin &amp;gt;&amp;gt; n;
    std::vector&amp;lt;std::pair&amp;lt;int, int&amp;gt; &amp;gt; a(n + 1);
    for (int i = 1; i &amp;lt;= n; ++i)
        std::cin &amp;gt;&amp;gt; a[i].first &amp;gt;&amp;gt; a[i].second;
    bool flag = true;
    std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; g(n + 1), g1(n + 1);
    std::stack&amp;lt;std::pair&amp;lt;int, int&amp;gt; &amp;gt; st;
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        for (int j = 0; j &amp;lt; a[i].first; ) &amp;#123;
            g[st.top().second].push_back(i);
            g1[st.top().second].push_back(i);
            g1[i].push_back(st.top().second);
            flag = false;
            int to = std::min(st.top().first, a[i].first - j);
            j += to, st.top().first -= to;
            if (st.top().first == 0)
                st.pop();
        &amp;#125;
        if (a[i].second)
            st.emplace(a[i].second, i);
    &amp;#125;
    if (flag == true) &amp;#123;
        std::cout &amp;lt;&amp;lt; 1 &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
        for (int i = 1; i &amp;lt;= n; ++i)
            std::cout &amp;lt;&amp;lt; 1 &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
        std::cout &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
        return 0;
    &amp;#125;
    std::vector&amp;lt;int&amp;gt; col(n + 1);
    std::function&amp;lt;bool(int, int)&amp;gt; DFS = [&amp;amp;](int x, int now) &amp;#123;
        col[x] = now;
        for (auto i : g1[x])
            if (!col[i]) &amp;#123;
                if (!DFS(i, 3 - now))
                    return false;
            &amp;#125;
            else if (col[i] == now)
                return false;
        return true;
    &amp;#125;;
    for (int i = 1; i &amp;lt;= n; ++i)
        if (!col[i] &amp;amp;&amp;amp; !DFS(i, 1))
            goto nosol;
    std::cout &amp;lt;&amp;lt; 2 &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    for (int i = 1; i &amp;lt;= n; ++i)
        std::cout &amp;lt;&amp;lt; col[i] &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
    std::cout &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    return 0;
nosol: ;
    col[1] = 1, col[n] = 2;
    std::function&amp;lt;void(int, int)&amp;gt; calc = [&amp;amp;](int l, int r) &amp;#123;
        if (r - l + 1 &amp;lt;= 2)
            return;
        if (!g[l].empty() &amp;amp;&amp;amp; g[l].back() == r)
            g[l].pop_back();
        int pos = g[l].empty() ? l + 1 : g[l].back();
        col[pos] = 6 - col[l] - col[r];
        calc(l, pos), calc(pos, r);
        return;
    &amp;#125;;
    calc(1, n);
    std::cout &amp;lt;&amp;lt; 3 &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    for (int i = 1; i &amp;lt;= n; ++i)
        std::cout &amp;lt;&amp;lt; col[i] &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
    std::cout &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;c.-适格者&#34;&gt;C. 适格者&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.becoder.com.cn/contest/6666/problem/3&#34; class=&#34;uri&#34;&gt;https://www.becoder.com.cn/contest/6666/problem/3&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定长度为 &lt;span class=&#34;math inline&#34;&gt;\(2^n\)&lt;/span&gt; 的数组 &lt;span class=&#34;math inline&#34;&gt;\(a_{0,\cdots,2^n-1}\)&lt;/span&gt;，维护 &lt;span class=&#34;math inline&#34;&gt;\(q\)&lt;/span&gt; 次操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;修改：单点加；&lt;/li&gt;
&lt;li&gt;修改：高维前缀加；&lt;/li&gt;
&lt;li&gt;修改：高维后缀加；&lt;/li&gt;
&lt;li&gt;询问：高维前缀和，对 &lt;span class=&#34;math inline&#34;&gt;\(998244353\)&lt;/span&gt; 取模；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(n\le 20,q\le 10^5\)&lt;/span&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;单点加 + 高维前缀和会反应出 &lt;a href=&#34;/20250907/#e---subset-product-problem&#34;&gt;ARC205E&lt;/a&gt; 的 trick&lt;/li&gt;
&lt;li&gt;&lt;p&gt;考虑怎么做后缀加，会反应过来和 &lt;a href=&#34;/20251010/#区间修改区间查询&#34;&gt;bit 的区间修改&lt;/a&gt; 有一致性，修改相当于单点修改差分数组。考虑类似的推导：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
\begin{aligned}
\sum_{s\subseteq S}a_s&amp;amp;=\sum_{s\subseteq S} \sum_{i\subseteq s} d_i\\
&amp;amp;=\sum_{i\subseteq S} 2^{|S|-|i|}\times d_i
\end{aligned}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;故维护 &lt;span class=&#34;math inline&#34;&gt;\(2^{-|i|}\cdot d_i\)&lt;/span&gt; 即可（原来取模是拿来搞这个的）。类似地可以推导前缀加：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
\begin{aligned}
\sum_{s\subseteq S}a_s&amp;amp;=\sum_{s\subseteq S} \sum_{i\supseteq s} d_i\\
&amp;amp;=\sum_{i\subseteq S} 2^{|S \text{ bitand } i|}\times d_i
\end{aligned}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;发现这个 bitand 不太好搞，不过 bitand 是对位的，所以依然可以套在分块上&lt;/p&gt;
&lt;p&gt;同时，因为问的是前缀和，所以单点的 &lt;span class=&#34;math inline&#34;&gt;\(S\text{ bitand } i\)&lt;/span&gt; 其实就是 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt;。这里有点囿于 fmt 的思维定势了，实际上可以直接认为 &lt;span class=&#34;math inline&#34;&gt;\(f_{s_1, s_2}\)&lt;/span&gt; 维护的是这个点处的答案，每次更新对 &lt;span class=&#34;math inline&#34;&gt;\(f_{s_1,*}\)&lt;/span&gt; 的贡献即可。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;p&gt;不知为何很慢&lt;/p&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int mod = 998244353;
const int inv2 = (mod + 1) &amp;gt;&amp;gt; 1;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
    std::freopen(&amp;quot;gene.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;gene.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#else
    // std::freopen(&amp;quot;./test/20251022/gene/gene5.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, q;
    std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; q;
    const int N1 = n / 2, N2 = n - N1, lim = 1 &amp;lt;&amp;lt; N2;
    std::vector&amp;lt;long long&amp;gt; inv(n + 1);
    inv[0]= 1ll;
    for (int i = 1; i &amp;lt;= n; ++i)
        inv[i] = inv[i - 1] * inv2 % mod;
    std::vector&amp;lt;std::vector&amp;lt;long long&amp;gt; &amp;gt; s(1 &amp;lt;&amp;lt; N1, std::vector&amp;lt;long long&amp;gt; (lim));
    auto s1(s), s2(s);
    for (int op, x; q--; ) &amp;#123;
        std::cin &amp;gt;&amp;gt; op &amp;gt;&amp;gt; x;
        int X1 = x &amp;gt;&amp;gt; N2, X2 = x &amp;amp; (lim - 1);
        if (op == 0) &amp;#123;
            auto res = 0ll, res1 = 0ll, res2 = 0ll;
            for (int i = 0; i &amp;lt; (1 &amp;lt;&amp;lt; N1); ++i)
                res2 += (1 &amp;lt;&amp;lt; __builtin_popcount(i &amp;amp; X1)) * s2[i][X2] % mod;
            for (int i = X1; ; i = X1 &amp;amp; (i - 1)) &amp;#123;
                res += s[i][X2];
                res1 += s1[i][X2] * (1 &amp;lt;&amp;lt; __builtin_popcount(x)) % mod;
                if (i == 0)
                    break;
            &amp;#125;
            std::cout &amp;lt;&amp;lt; (res + res1 + res2) % mod &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
        &amp;#125;
        else if (op == 1) &amp;#123;
            int v;
            std::cin &amp;gt;&amp;gt; v;
            int X3 = (lim - 1) ^ X2;
            for (int i = X3; ; i = X3 &amp;amp; (i - 1)) &amp;#123;
                (s[X1][(lim - 1) ^ i] += v) %= mod;
                if (i == 0)
                    break;
            &amp;#125;
        &amp;#125;
        else if (op == 2) &amp;#123;
            long long v;
            std::cin &amp;gt;&amp;gt; v, (v *= inv[__builtin_popcount(x)]) %= mod;
            int X3 = (lim - 1) ^ X2;
            for (int i = X3; ; i = X3 &amp;amp; (i - 1)) &amp;#123;
                (s1[X1][(lim - 1) ^ i] += v) %= mod;
                if (i == 0)
                    break;
            &amp;#125;
        &amp;#125;
        else &amp;#123;
            long long v;
            std::cin &amp;gt;&amp;gt; v;
            for (int i = 0; i &amp;lt; lim; ++i)
                (s2[X1][i] += v * (1 &amp;lt;&amp;lt; __builtin_popcount(i &amp;amp; X2))) %= mod;
        &amp;#125;
    &amp;#125;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;cf1784c-monsters-hard-version&#34;&gt;CF1784C Monsters (hard version)&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/CF1784C&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/CF1784C&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;通过若干次 1 操作，把数列的值域变成包含 1 且连续的，然后执行 2 操作，一定不劣&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;考虑怎么快速维护这个东西，发现只关心初始序列和目标序列（从计算代价的式子可以看出来），故考虑这样一个构造最终序列的方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从前到后遍历值域上的每个空位，找到第一个大于之的元素，并放过来，重复执行直到上述步骤不能执行为止。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;直接考虑一次加点带来的影响似乎非常复杂，但如果时光倒流，发现有贪心策略，直接把最后一次操作挪到这个新的空位即可。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;电波题！用 set 维护即可。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int T;
    for (std::cin &amp;gt;&amp;gt; T; T--; ) &amp;#123;
        int n;
        std::cin &amp;gt;&amp;gt; n;
        std::set&amp;lt;std::pair&amp;lt;int, int&amp;gt; &amp;gt; t;
        std::vector&amp;lt;long long&amp;gt; res(n + 1);
        std::vector&amp;lt;int&amp;gt; a(n + 1), to(n + 1), at(n + 1);
        for (int i = 1; i &amp;lt;= n; ++i)
            std::cin &amp;gt;&amp;gt; a[i], t.emplace(a[i], i);
        int now;
        for (now = 1; ; ++now) &amp;#123;
            auto p(t.lower_bound(&amp;#123; now, 0 &amp;#125;));
            if (p == t.end())
                break;
            at[now] = p-&amp;gt;second;
            to[p-&amp;gt;second] = now;
            res[n] += p-&amp;gt;first - now;
            t.erase(p);
        &amp;#125;
        --now;
        for (int i = n - 1; i; --i) &amp;#123;
            res[i] = res[i + 1];
            if (to[i + 1]) &amp;#123;
                res[i] -= a[i + 1] - to[i + 1];
                auto p = t.lower_bound(&amp;#123; to[i + 1], 0 &amp;#125;);
                if (p != t.end()) &amp;#123;
                    at[to[i + 1]] = p-&amp;gt;second;
                    to[p-&amp;gt;second] = to[i + 1];
                    res[i] += a[p-&amp;gt;second] - to[i + 1];
                    t.erase(p);
                &amp;#125;
                else &amp;#123;
                    res[i] -= a[at[now]] - to[at[now]];
                    res[i] += a[at[now]] - to[i + 1];
                    to[at[now]] = to[i + 1];
                    at[to[i + 1]] = at[now];
                    --now;
                &amp;#125;
            &amp;#125;
            else
                t.erase(&amp;#123; a[i + 1], i + 1 &amp;#125;);
        &amp;#125;
        for (int i = 1; i &amp;lt;= n; ++i)
            std::cout &amp;lt;&amp;lt; res[i] &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
        std::cout &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    &amp;#125;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;cf891c-envy&#34;&gt;CF891C Envy&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/CF891C&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/CF891C&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;mobai ddxrS&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;经典结论：在做完权值 &lt;span class=&#34;math inline&#34;&gt;\(&amp;lt;w\)&lt;/span&gt; 的 Kruskal 后，权值 &lt;span class=&#34;math inline&#34;&gt;\(=w\)&lt;/span&gt; 的边以任意顺序加入 Kruskal 后，并查集连通性完全一致。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Another 经典结论：一条权值为 &lt;span class=&#34;math inline&#34;&gt;\(w\)&lt;/span&gt; 的边可以属于 mst，当且仅当在做完权值 &lt;span class=&#34;math inline&#34;&gt;\(&amp;lt;w\)&lt;/span&gt; 的 Kruskal 后，这条边加入不形成环。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;重要事实：把并查集的 &lt;code&gt;merge&lt;/code&gt; 操作打乱，连通性不变。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;结合起来得到这个神秘做法：按照边权做 Kruskal 检验每条边是否可以加入 mst，如果可以则记录合并的两个根，作为&lt;strong&gt;新边&lt;/strong&gt;（不带权）。&lt;/p&gt;
&lt;p&gt;&lt;mark&gt;重要事实：对于 &lt;span class=&#34;math inline&#34;&gt;\(n-1\)&lt;/span&gt; 条&lt;strong&gt;新边&lt;/strong&gt;，要么有环，要么形成 mst。&lt;/mark&gt;&lt;/p&gt;
&lt;p&gt;推广：对于任意条&lt;strong&gt;新边&lt;/strong&gt;，要么有环，要么可以通过某种选取其他&lt;strong&gt;新边&lt;/strong&gt;的方式形成 mst。&lt;/p&gt;
&lt;p&gt;故 check 给定边的&lt;strong&gt;新边&lt;/strong&gt;是否成环即可。算是一个 trick 吗？&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    const int M = 5e5;
    int n, m;
    std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
    std::vector&amp;lt;std::pair&amp;lt;int, int&amp;gt; &amp;gt; ne(m + 1);
    std::vector&amp;lt;std::vector&amp;lt;std::tuple&amp;lt;int, int, int&amp;gt; &amp;gt; &amp;gt; e(M + 1); 
    for (int i = 1, x, y, w; i &amp;lt;= m; ++i) &amp;#123;
        std::cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; y &amp;gt;&amp;gt; w;
        e[w].emplace_back(x, y, i);
    &amp;#125;
    std::vector&amp;lt;int&amp;gt; f(n + 1);
    std::iota(f.begin() + 1, f.end(), 1);
    std::function&amp;lt;int(int)&amp;gt; find = [&amp;amp;](int x) &amp;#123;
        return x == f[x] ? x : f[x] = find(f[x]);
    &amp;#125;;
    for (int i = 1; i &amp;lt;= M; ++i) &amp;#123;
        for (auto [u, v, id] : e[i])
            ne[id] = &amp;#123; find(u), find(v) &amp;#125;;
        for (auto [u, v, id] : e[i])
            f[find(u)] = find(v);
    &amp;#125;
    std::iota(f.begin() + 1, f.end(), 1);
    int q;
    for (std::cin &amp;gt;&amp;gt; q; q--; ) &amp;#123;
        int k;
        std::cin &amp;gt;&amp;gt; k;
        std::vector&amp;lt;int&amp;gt; pos;
        bool flag = true;
        for (int id; k--; ) &amp;#123;
            std::cin &amp;gt;&amp;gt; id;
            if (find(ne[id].first) == find(ne[id].second))
                flag = false;
            f[find(ne[id].first)] = find(ne[id].second);
            pos.push_back(ne[id].first);
            pos.push_back(ne[id].second);
        &amp;#125;
        std::cout &amp;lt;&amp;lt; (flag ? &amp;quot;YES&amp;quot; : &amp;quot;NO&amp;quot;) &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
        for (auto i : pos)
            f[i] = i;
    &amp;#125;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;c.-山月记&#34;&gt;C. 山月记&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.becoder.com.cn/problem/52034&#34; class=&#34;uri&#34;&gt;https://www.becoder.com.cn/problem/52034&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定一棵大小为 &lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt; 的带权无根树 &lt;span class=&#34;math inline&#34;&gt;\(T\)&lt;/span&gt;，再给定 &lt;span class=&#34;math inline&#34;&gt;\(m\)&lt;/span&gt; 条额外的边，和 &lt;span class=&#34;math inline&#34;&gt;\(T\)&lt;/span&gt; 一起形成一个图 &lt;span class=&#34;math inline&#34;&gt;\(G\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;定义一个点 &lt;span class=&#34;math inline&#34;&gt;\(u\)&lt;/span&gt; 是好的，当且仅当对于&lt;strong&gt;每一个&lt;/strong&gt; &lt;span class=&#34;math inline&#34;&gt;\(1\le v\le n\)&lt;/span&gt;，&lt;strong&gt;&lt;span class=&#34;math inline&#34;&gt;\(T\)&lt;/span&gt; 上的&lt;/strong&gt;简单路径 &lt;span class=&#34;math inline&#34;&gt;\((u,v)\)&lt;/span&gt; 都可以被 &lt;span class=&#34;math inline&#34;&gt;\(G\)&lt;/span&gt; 的某个 MST &lt;strong&gt;完整&lt;/strong&gt;包含。&lt;/p&gt;
&lt;p&gt;输出任意一个好的点。无解输出 &lt;span class=&#34;math inline&#34;&gt;\(0\)&lt;/span&gt;。有 SPJ。&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(n,m\le 10^5\)&lt;/span&gt;，&lt;span class=&#34;math inline&#34;&gt;\(w\le 10^9\)&lt;/span&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;参考上一题，朴素做法是 &lt;span class=&#34;math inline&#34;&gt;\(O(n^2)\)&lt;/span&gt; 枚举某个 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 开头的路径，然后 &lt;span class=&#34;math inline&#34;&gt;\(O(len)\)&lt;/span&gt; 地 check；&lt;/p&gt;
&lt;p&gt;注意到这个结构能很好地和 DFS + 回溯结合，用可撤销并查集维护即可在 &lt;span class=&#34;math inline&#34;&gt;\(O(n\log n)\)&lt;/span&gt; 内完成对一个 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 所有路径的 check。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;发现：如果一条路径 &lt;span class=&#34;math inline&#34;&gt;\((u,v)\)&lt;/span&gt; 是非法的，进一步所有完整包含 &lt;span class=&#34;math inline&#34;&gt;\((u,v)\)&lt;/span&gt; 的路径都是非法的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;从路径反映到点上&lt;/strong&gt;，会发现 &lt;span class=&#34;math inline&#34;&gt;\((u,v)\)&lt;/span&gt; 两侧的点都是非法的。下意识考虑不在 &lt;span class=&#34;math inline&#34;&gt;\((u,v)\)&lt;/span&gt; 两侧，但在 &lt;span class=&#34;math inline&#34;&gt;\((u,v)\)&lt;/span&gt; 之外的点，发现它们仍然有可能合法，只要满足如下情况：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image-3.png&#34; /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;也就是说，对于 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt;，如果它出发的所有路径都合法，那么 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 自己就是答案；&lt;/p&gt;
&lt;p&gt;如果存在 &lt;span class=&#34;math inline&#34;&gt;\(\ge 2\)&lt;/span&gt; 条非法路径，那么无解；&lt;/p&gt;
&lt;p&gt;否则，存在恰好一条边，在非法边所在的子树中递归求解，发现这很点分治，故可以 &lt;span class=&#34;math inline&#34;&gt;\(O(n\log^2 n)\)&lt;/span&gt; 解决。log 分别来自点分治和撤销并查集。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;注：这里唐唐的，check 写成点分树子树内 check 了。点分治在这里只起保证递归层数的作用。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;p&gt;怎么跑得这么快？推测因为写的是按秩合并。&lt;/p&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;./test/20251024/beast/beast1.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int T;
    for (std::cin &amp;gt;&amp;gt; T; T--; ) &amp;#123;
        int n, m;
        std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
        std::vector&amp;lt;int&amp;gt; l(1);
        std::vector&amp;lt;std::pair&amp;lt;int, int&amp;gt; &amp;gt; ne(m + 1);
        std::vector&amp;lt;std::tuple&amp;lt;int, int, int&amp;gt; &amp;gt; se(m + 1);
        std::vector&amp;lt;std::vector&amp;lt;std::pair&amp;lt;int, int&amp;gt; &amp;gt; &amp;gt; g(n + 1);
        std::vector&amp;lt;std::vector&amp;lt;std::tuple&amp;lt;int, int, int&amp;gt; &amp;gt; &amp;gt; e(m + 1); 
        for (int i = 1, x, y, w; i &amp;lt;= m; ++i) &amp;#123;
            std::cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; y &amp;gt;&amp;gt; w;
            se[i] = &amp;#123; x, y, w &amp;#125;, l.push_back(w);
            if (i &amp;lt; n)
                g[x].emplace_back(y, i), g[y].emplace_back(x, i);
        &amp;#125;
        std::sort(l.begin() + 1, l.end());
        l.erase(std::unique(l.begin() + 1, l.end()), l.end());
        for (int i = 1; i &amp;lt;= m; ++i) &amp;#123;
            auto [x, y, w] = se[i];
            w = std::lower_bound(l.begin() + 1, l.end(), w) - l.begin();
            e[w].emplace_back(x, y, i);
        &amp;#125;
        std::vector&amp;lt;int&amp;gt; f(n + 1);
        std::iota(f.begin() + 1, f.end(), 1);
        std::function&amp;lt;int(int)&amp;gt; find = [&amp;amp;](int x) &amp;#123;
            return x == f[x] ? x : f[x] = find(f[x]);
        &amp;#125;;
        for (int i = 1; i &amp;lt;= m; ++i) &amp;#123;
            for (auto [u, v, id] : e[i])
                ne[id] = &amp;#123; find(u), find(v) &amp;#125;;
            for (auto [u, v, id] : e[i])
                f[find(u)] = find(v);
        &amp;#125;
        std::vector&amp;lt;int&amp;gt; tag(n + 1), p, siz(n + 1), mx(n + 1);
        std::function&amp;lt;void(int, int)&amp;gt; DFS1 = [&amp;amp;](int x, int fa) &amp;#123;
            p.push_back(x);
            siz[x] = 1, mx[x] = 0;
            for (auto [i, id] : g[x])
                if (i != fa &amp;amp;&amp;amp; !tag[i]) &amp;#123;
                    DFS1(i, x);
                    siz[x] += siz[i];
                    mx[x] = std::max(mx[x], siz[i]);
                &amp;#125;
            return;
        &amp;#125;;
        auto findrt = [&amp;amp;](int x) &amp;#123;
            p.clear(), DFS1(x, -1);
            int n = (int)p.size();
            for (auto i : p)
                if (mx[i] &amp;lt;= n / 2 &amp;amp;&amp;amp; n - siz[i] &amp;lt;= n / 2)
                    return i;
            assert(0);
            return -1;
        &amp;#125;;
        std::vector&amp;lt;int&amp;gt; rank(n + 1);
        std::stack&amp;lt;std::tuple&amp;lt;int, int, int&amp;gt; &amp;gt; st;
        find = [&amp;amp;](int x) &amp;#123;
            return x == f[x] ? x : find(f[x]);
        &amp;#125;;
        auto merge = [&amp;amp;](int x, int y) &amp;#123;
            x = find(x), y = find(y);
            if (x == y)
                return true;
            if (rank[x] &amp;lt;= rank[y])
                st.emplace(x, y, rank[y]), f[x] = y;
            else 
                st.emplace(y, x, rank[x]), f[y] = x;
            if (rank[x] == rank[y])
                ++rank[y];
            return false;
        &amp;#125;;
        auto undo = [&amp;amp;](void) &amp;#123;
            assert(!st.empty());
            auto [x, y, ry] = st.top();
            st.pop();
            f[x] = x, rank[y] = ry;
            return;
        &amp;#125;;
        std::function&amp;lt;bool(int, int)&amp;gt; DFS2 = [&amp;amp;](int x, int fa) &amp;#123;
            for (auto [i, id] : g[x])
                if (i != fa &amp;amp;&amp;amp; (merge(ne[id].first, ne[id].second) || DFS2(i, x))) &amp;#123;
                    undo();
                    return true;
                &amp;#125;
            undo();
            return false;
        &amp;#125;;
        std::function&amp;lt;bool(int)&amp;gt; DFS = [&amp;amp;](int x) &amp;#123;
            x = findrt(x);
            int to = 0;
            for (auto [i, id] : g[x])
                if (merge(ne[id].first, ne[id].second) || DFS2(i, x)) &amp;#123;
                    if (!to) to = i;
                    else &amp;#123;
                        std::cout &amp;lt;&amp;lt; 0 &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
                        return true;
                    &amp;#125;
                &amp;#125;
            assert(st.empty());
            tag[x] = 1;
            if (to) &amp;#123;
                if (tag[to]) &amp;#123;
                    std::cout &amp;lt;&amp;lt; 0 &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
                    return true;
                &amp;#125;
                return DFS(to);
            &amp;#125;
            std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
            return true;
        &amp;#125;;
        std::iota(f.begin() + 1, f.end(), 1);
        assert(DFS(1));
    &amp;#125;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;b.-电报-a.-神灵庙-cf2068d-morse-code&#34;&gt;B. 电报 / A. 神灵庙 / CF2068D Morse Code&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.becoder.com.cn/contest/6676/problem/2&#34; class=&#34;uri&#34;&gt;https://www.becoder.com.cn/contest/6676/problem/2&lt;/a&gt; / &lt;a href=&#34;https://www.becoder.com.cn/contest/5527/problem/1&#34; class=&#34;uri&#34;&gt;https://www.becoder.com.cn/contest/5527/problem/1&lt;/a&gt; / &lt;a href=&#34;https://www.luogu.com.cn/problem/CF2068D&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/CF2068D&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一个无限大的完全二叉树，根节点权值为 &lt;span class=&#34;math inline&#34;&gt;\(0\)&lt;/span&gt;，一个点的左儿子权值是这个点的权值 &lt;span class=&#34;math inline&#34;&gt;\(+1\)&lt;/span&gt;，右儿子为 &lt;span class=&#34;math inline&#34;&gt;\(+2\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;给定 &lt;span class=&#34;math inline&#34;&gt;\(c_1,\cdots, c_n\)&lt;/span&gt;，挑选 &lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt; 个互不为祖孙的点，最终代价为点权 &lt;span class=&#34;math inline&#34;&gt;\(\times\)&lt;/span&gt; 对应的 &lt;span class=&#34;math inline&#34;&gt;\(c\)&lt;/span&gt; 之和。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;一个基本的观察：权值对应相邻两种值的结点数总是构成类似斐波那契的结构。显然应该把权值和点权逆大小对应。&lt;/p&gt;
&lt;p&gt;朴素 DP：令 &lt;span class=&#34;math inline&#34;&gt;\(f_{i,j,a,b}\)&lt;/span&gt; 表示当前枚举到权值 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt;，已经选了 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; 个点，&lt;span class=&#34;math inline&#34;&gt;\(i-1\)&lt;/span&gt;、&lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 分别剩余 &lt;span class=&#34;math inline&#34;&gt;\(a,b\)&lt;/span&gt; 个点的最小代价，可以得到 &lt;span class=&#34;math inline&#34;&gt;\(n^5\)&lt;/span&gt; 的惊人转移。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;经典 trick：最后一层循环的枚举是无必要的，可以一个一个转移（类似完全背包）。这样就少了一个 &lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt;。如果观察到最深取到 1.5 log（斐波那契）能砍成 &lt;span class=&#34;math inline&#34;&gt;\(O(n^3\log n)\)&lt;/span&gt;。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;接着，发现可以费用提前计算（这里我觉得更像是算贡献），少枚举一个 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt;，这样就是 &lt;span class=&#34;math inline&#34;&gt;\(O(n^3)\)&lt;/span&gt; 的了。&lt;/p&gt;
&lt;p&gt;发现没什么实现的头绪。目前有：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
f_{j,a,b}\to f_{j+1,a,b-1}\\
f_{j,a,b}+suf_{j+1}\to f_{j,b,a+b}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;以前没有注意到过，其实&lt;strong&gt;枚举顺序是由转移方程决定的&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一种转移中，&lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; 是递增的，&lt;span class=&#34;math inline&#34;&gt;\(a\)&lt;/span&gt; 水平，&lt;span class=&#34;math inline&#34;&gt;\(b\)&lt;/span&gt; 递减；&lt;/li&gt;
&lt;li&gt;第二种转移中，&lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; 水平，&lt;span class=&#34;math inline&#34;&gt;\(a\)&lt;/span&gt; 无法确定，&lt;span class=&#34;math inline&#34;&gt;\(b\)&lt;/span&gt; 不递减；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以想到一个转移顺序：正序枚举 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt;，正序枚举 &lt;span class=&#34;math inline&#34;&gt;\(b\)&lt;/span&gt;；正序枚举 &lt;span class=&#34;math inline&#34;&gt;\(a\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;此时第二种会有点问题，&lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; 水平且 &lt;span class=&#34;math inline&#34;&gt;\(b\)&lt;/span&gt; 水平时，若 &lt;span class=&#34;math inline&#34;&gt;\(a\)&lt;/span&gt; 变小怎么办？发现这要求 &lt;span class=&#34;math inline&#34;&gt;\(b&amp;lt;a\)&lt;/span&gt;，则 &lt;span class=&#34;math inline&#34;&gt;\(a+b&amp;gt;b\)&lt;/span&gt; 恒成立，&lt;span class=&#34;math inline&#34;&gt;\(b\)&lt;/span&gt; 一定不水平。挺牛的这个。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;卡空间了，滚动一下即可。复杂度 &lt;span class=&#34;math inline&#34;&gt;\(O(n^3)\)&lt;/span&gt;。绅士写了神秘玄学&lt;a href=&#34;https://www.becoder.com.cn/submission/3177578&#34;&gt;做法&lt;/a&gt;，瞻仰无果。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
    std::freopen(&amp;quot;telegram.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;telegram.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n;
    std::cin &amp;gt;&amp;gt; n;
    std::vector&amp;lt;int&amp;gt; c(n + 1);
    for (int i = 1; i &amp;lt;= n; ++i)
        std::cin &amp;gt;&amp;gt; c[i];
    std::sort(c.begin() + 1, c.end(), std::greater&amp;lt;int&amp;gt; ());
    std::partial_sum(c.rbegin(), c.rend(), c.rbegin());
    using arr = std::vector&amp;lt;int&amp;gt;;
    using brr = std::vector&amp;lt;arr&amp;gt;;
    using crr = std::vector&amp;lt;brr&amp;gt;;
    crr f(2, brr(n + 1, arr(n + 1))), tag(2, brr(n + 1, arr(n + 1, -1)));
    f[0][1][1] = c[1], tag[0][1][1] = 0;
    auto upd = [&amp;amp;](int i, int &amp;amp;t, int &amp;amp;x, int y) &amp;#123;
        if (t == i)
            x = std::min(x, y);
        else
            x = y, t = i;
        return;
    &amp;#125;;
    for (int j = 0, k = 0; j &amp;lt; n; ++j, k ^= 1) &amp;#123;
        for (int b = 0; b &amp;lt;= n; ++b)
            for (int a = 0; a &amp;lt;= n; ++a)
                if (tag[k][b][a] == j) &amp;#123;
                    if (b)
                        upd(j + 1, tag[k ^ 1][b - 1][a], f[k ^ 1][b - 1][a], f[k][b][a]);
                    if (a + b &amp;lt;= n)
                        upd(j, tag[k][a + b][b], f[k][a + b][b], f[k][b][a] + c[j + 1]);
                &amp;#125;
    &amp;#125;
    auto res = 0x3f3f3f3f;
    for (int b = 0; b &amp;lt;= n; ++b)
        for (int a = 0; a &amp;lt;= n; ++a)
            if (tag[n &amp;amp; 1][b][a] == n)
                res = std::min(res, f[n &amp;amp; 1][b][a]);
    std::cout &amp;lt;&amp;lt; res &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;coi-2019-tenis&#34;&gt;[COI 2019] TENIS&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P11340&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P11340&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;观察一：&lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 能获胜，当且仅当存在一个 &lt;span class=&#34;math inline&#34;&gt;\(y\)&lt;/span&gt;，使得 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 能战胜 &lt;span class=&#34;math inline&#34;&gt;\(y\)&lt;/span&gt;，且 &lt;span class=&#34;math inline&#34;&gt;\(y\)&lt;/span&gt; 能在剩下 &lt;span class=&#34;math inline&#34;&gt;\(n-1\)&lt;/span&gt; 个人中获胜。&lt;/p&gt;
&lt;p&gt;发现这是一个递归，或者说链式的关系。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;观察二：不妨把三个数组视为三条链，那么发现任意一个链首在任意局面总是能获胜。如果一个人能战胜链首，显然这个人能获胜。反过来，若不能通过任何方式战胜链首，显然无法获胜。&lt;/p&gt;
&lt;p&gt;然后就变成连通性问题了。但很容易猜到带删边连通性没什么优化的前途。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;只有加边的带修连通性问题：&lt;a href=&#34;https://www.luogu.com.cn/article/taefjy3d&#34;&gt;整体二分&lt;/a&gt;&lt;/em&gt;。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;观察三：链首不能被 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 战胜，当且仅当存在一个 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt;，三条链的前 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 个元素集相同，且 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 位于最小的 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 之后。&lt;/p&gt;
&lt;p&gt;这个看起来和 &lt;a href=&#34;https://www.luogu.com.cn/problem/CF526F&#34;&gt;Puuding Monsters&lt;/a&gt; / &lt;a href=&#34;https://www.luogu.com.cn/problem/CF997E&#34;&gt;Good Subsegments&lt;/a&gt; 比较像，实际上思路上也有共通之处：&lt;strong&gt;如果合法区间的值域是连续的，可以把条件转化为 min / max 问题。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;考虑先使其&lt;strong&gt;询问区间内值域连续&lt;/strong&gt;以套用这样的方法。可以对链 1 重标号为 &lt;span class=&#34;math inline&#34;&gt;\(1\cdots n\)&lt;/span&gt;，维护链 2、3 的答案；也可以维护三个 rank 上的答案。法一实现起来有很多不必要的令人讨厌的地方，故写法二。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;相当于求一个最小的 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 使得链 1、2、3 在 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 之前的所有元素 rank 都不能比 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 大。主体为 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 时，（因为最小这个限制，和依次改动会带来很大的偏移），所以不太好维护；&lt;/p&gt;
&lt;p&gt;但是正确的维护方式很难想到！令 &lt;span class=&#34;math inline&#34;&gt;\(f_i,g_i\)&lt;/span&gt; 分别表示链 2、3 的每个 &lt;span class=&#34;math inline&#34;&gt;\(1\le j\le n\)&lt;/span&gt;，满足 &lt;span class=&#34;math inline&#34;&gt;\(\min(r_{1/2/3,j})\)&lt;/span&gt;、&lt;span class=&#34;math inline&#34;&gt;\(\max(r_{1/2/3,j})= i\)&lt;/span&gt; 的 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; 的数量。如果二者在 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 处的前缀和相等，那么 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 就是合法的。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Fractures（新角色）：这是个很常见的 trick。&lt;/p&gt;
&lt;p&gt;Fractures：这个和 Pudding Monsters 哪里像了。是你唐。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;维护 &lt;span class=&#34;math inline&#34;&gt;\(f_i-g_i\)&lt;/span&gt; 的前缀和；线段树维护区间修改和全局 min 即可。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;p&gt;莫名很慢。和 TTpandaS 相比多了一次建树（但不应该有这么大的影响才对）。&lt;/p&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int maxn = 1e5 + 5;
struct &amp;#123; int l, r, mn, at, d; &amp;#125; t[maxn &amp;lt;&amp;lt; 2];
#define lt (p &amp;lt;&amp;lt; 1)
#define rt (lt | 1)
void pushup(int p) &amp;#123;
    t[p].mn = std::min(t[lt].mn, t[rt].mn);
    if (t[lt].mn == t[p].mn)
        t[p].at = t[lt].at;
    else
        t[p].at = t[rt].at;
    return;
&amp;#125;
void pushdown(int p) &amp;#123;
    if (t[p].d) &amp;#123;
        t[lt].d += t[p].d, t[lt].mn += t[p].d;
        t[rt].d += t[p].d, t[rt].mn += t[p].d;
        t[p].d = 0;
    &amp;#125;
    return;
&amp;#125;
void bld(int p, int l, int r) &amp;#123;
    t[p].l = l, t[p].r = r;
    if (l == r) &amp;#123;
        t[p].at = l;
        return;
    &amp;#125;
    int mid = (l + r) &amp;gt;&amp;gt; 1;
    bld(lt, l, mid), bld(rt, mid + 1, r);
    pushup(p);
    return;
&amp;#125;
void add(int p, int l, int r, int v) &amp;#123;
    if (l &amp;lt;= t[p].l &amp;amp;&amp;amp; t[p].r &amp;lt;= r) &amp;#123;
        t[p].d += v, t[p].mn += v;
        return;
    &amp;#125;
    pushdown(p);
    int mid = (t[p].l + t[p].r) &amp;gt;&amp;gt; 1;
    if (l &amp;lt;= mid)
        add(lt, l, r, v);
    if (r &amp;gt; mid)
        add(rt, l, r, v);
    pushup(p);
    return;
&amp;#125;
#undef lt
#undef rt
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
    std::freopen(&amp;quot;match.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;match.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, q;
    std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; q;
    std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; p(3, std::vector&amp;lt;int&amp;gt; (n + 1));
    for (int k = 0; k &amp;lt; 3; ++k)
        for (int i = 1, x; i &amp;lt;= n; ++i)
            std::cin &amp;gt;&amp;gt; x, p[k][x] = i;
    bld(1, 1, n);
    auto upd = [&amp;amp;](int i, int k) &amp;#123;
        add(1, std::min(&amp;#123; p[0][i], p[1][i], p[2][i] &amp;#125;), n, k);
        add(1, std::max(&amp;#123; p[0][i], p[1][i], p[2][i] &amp;#125;), n, -k);
        return;
    &amp;#125;;
    for (int i = 1; i &amp;lt;= n; ++i)
        upd(i, 1);
    int now = t[1].at;
    // printf(&amp;quot;now = %d \n&amp;quot;, now);
    for (int op; q--; ) &amp;#123;
        std::cin &amp;gt;&amp;gt; op;
        if (op == 1) &amp;#123;
            int x;
            std::cin &amp;gt;&amp;gt; x;
            std::cout &amp;lt;&amp;lt; (std::min(&amp;#123; p[0][x], p[1][x], p[2][x] &amp;#125;) &amp;lt;= now ? &amp;quot;Yes&amp;quot; : &amp;quot;No&amp;quot;) &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
        &amp;#125;
        else &amp;#123;
            int k, i, j;
            std::cin &amp;gt;&amp;gt; k &amp;gt;&amp;gt; i &amp;gt;&amp;gt; j, --k;
            upd(i, -1), upd(j, -1);
            std::swap(p[k][i], p[k][j]);
            upd(i, 1), upd(j, 1);
            now = t[1].at;
            // printf(&amp;quot;now = %d \n&amp;quot;, now);
        &amp;#125;
    &amp;#125;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://xsc062.netlify.app/20251013/</guid>
            <title>生成树 III</title>
            <link>https://xsc062.netlify.app/20251013/</link>
            <category>最小生成树</category>
            <category>Kruskal 重构树</category>
            <pubDate>Mon, 13 Oct 2025 10:35:14 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;mst，以及 mst related&lt;/p&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;boruvka&#34;&gt;Boruvka&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;用途：&lt;span class=&#34;math inline&#34;&gt;\(O(m\log n)\)&lt;/span&gt; 求 mst。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;过程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;考虑和 Kruskal、Prim 类似的孤立点 &lt;span class=&#34;math inline&#34;&gt;\(\to\)&lt;/span&gt; 加边 &lt;span class=&#34;math inline&#34;&gt;\(\to\)&lt;/span&gt; 树。&lt;/li&gt;
&lt;li&gt;每一轮算法，对于当前的每个连通块，找到其连向其它连通块的边中最小的一条，并在这一轮后加入边集（用并查集维护连通块合并）。&lt;/li&gt;
&lt;li&gt;重复执行该算法，最终找到 mst。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure&gt;
&lt;img src=&#34;mst-1.apng&#34; alt=&#34;图源 OI Wiki&#34;&gt;
&lt;figcaption&gt;
图源 OI Wiki
&lt;/figcaption&gt;
&lt;/figure&gt;&lt;/li&gt;
&lt;li&gt;复杂度：每一轮中，每个连通块都会被合并一次，故一轮之后现存连通块数量最坏情况下变为原来的一半。也即共执行 &lt;span class=&#34;math inline&#34;&gt;\(\log n\)&lt;/span&gt; 轮。复杂度 &lt;span class=&#34;math inline&#34;&gt;\(O(m\log n)\)&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;优势：对于&lt;strong&gt;特殊边权&lt;/strong&gt;的完全图 / 稠密图，边权并不由输入直接给定，而是由顶点计算得到，此时若可以依据性质直接找到连通块的最小边，则复杂度降低至 &lt;span class=&#34;math inline&#34;&gt;\(O(n\log n)\)&lt;/span&gt; 之类非常优秀的级别（注意并查集的 log 和 Boruvka 本身的 log 是平行的）。&lt;/p&gt;
&lt;p&gt;『依据性质找到最小的边』的一个 Bonus：见 KDT + Boruvka 做法的 &lt;a href=&#34;https://www.luogu.com.cn/problem/P6362&#34;&gt;平面欧几里得最小生成树&lt;/a&gt;。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;a---jumping-around&#34;&gt;A - Jumping Around&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/CF1550F&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/CF1550F&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;本题就是『特殊边权完全图』的体现。定义任意两个点之间的边权为两个点相互跳需要的最小的 &lt;span class=&#34;math inline&#34;&gt;\(k=||x_0-x_1|-d|\)&lt;/span&gt;，那么只需求瓶颈路。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;做 Boruvka 即可。考虑怎么求某个连通块的最小边，预处理出每个位置（包括空位）前 / 后第一个和自己颜色不同的非空位，每次 check &lt;span class=&#34;math inline&#34;&gt;\(i\pm d\)&lt;/span&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;若该位置存在和当前位置不同颜色的点：连边。&lt;/li&gt;
&lt;li&gt;否则，若该位置和当前位置颜色相同：转到刚刚求出的前驱、后继，选更小者连边。&lt;/li&gt;
&lt;li&gt;否则该位为空。前驱、后继则转化为上面两种情况。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;和双指针做法不同，似乎并不支持离散化，只能做到 &lt;span class=&#34;math inline&#34;&gt;\(O(V\log n)\)&lt;/span&gt;。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int V = 1e6;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, q, s, d;
    std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; q &amp;gt;&amp;gt; s &amp;gt;&amp;gt; d;
    std::vector&amp;lt;int&amp;gt; a(n + 1), tab(V + 1);
    for (int i = 1; i &amp;lt;= n; ++i)
        std::cin &amp;gt;&amp;gt; a[i], tab[a[i]] = i;
    std::vector&amp;lt;std::pair&amp;lt;int, int&amp;gt; &amp;gt; to(n + 1);
    std::vector&amp;lt;std::vector&amp;lt;std::pair&amp;lt;int, int&amp;gt; &amp;gt; &amp;gt; g(n + 1);
    std::vector&amp;lt;int&amp;gt; u(V + 1), pre(V + 1), nex(V + 1), mn(n + 1), f(n + 1), pos;
    std::iota(f.begin() + 1, f.end(), 1);
    std::function&amp;lt;int(int)&amp;gt; find = [&amp;amp;](int x) &amp;#123;
        return x == f[x] ? x : f[x] = find(f[x]);
    &amp;#125;;
    for (int tot = n; tot != 1; ) &amp;#123;
        pos.clear();
        for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
            if (f[i] == i) &amp;#123;
                mn[i] = 0x3f3f3f3f, to[i] = &amp;#123; 0, 0 &amp;#125;;
                pos.push_back(i);
            &amp;#125;
            u[a[i]] = find(i);
            if (u[a[i - 1]] == u[a[i]])
                pre[a[i]] = pre[a[i - 1]];
            else
                pre[a[i]] = a[i - 1];
        &amp;#125;
        for (int i = 1; i &amp;lt;= V; ++i)
            if (!u[i])
                pre[i] = u[i - 1] ? i - 1 : pre[i - 1];
        nex[a[n]] = V + 1;
        for (int i = n - 1; i; --i)
            if (u[a[i + 1]] == u[a[i]])
                nex[a[i]] = nex[a[i + 1]];
            else
                nex[a[i]] = a[i + 1];
        nex[V] = V + 1;
        for (int i = V - 1; i; --i)
            if (!u[i])
                nex[i] = u[i + 1] ? i + 1 : nex[i + 1];
        for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
            int x = a[i], now = 0x3f3f3f3f, pos = 0;
            auto upd = [&amp;amp;](int x1) &amp;#123;
                if (std::abs(std::abs(x - x1) - d) &amp;lt; now)
                    now = std::abs(std::abs(x - x1) - d), pos = x1;
                return;
            &amp;#125;;
            auto trans = [&amp;amp;](int x1) &amp;#123;
                if (pre[x1])
                    upd(pre[x1]);
                if (nex[x1] != V + 1)
                    upd(nex[x1]);
                return;
            &amp;#125;;
            std::function&amp;lt;void(int)&amp;gt; work = [&amp;amp;](int x1) &amp;#123;
                if (u[x1] &amp;amp;&amp;amp; u[x1] != u[x])
                    upd(x1);
                else if (u[x1])
                    trans(x1);
                else &amp;#123;
                    if (pre[x1])
                        work(pre[x1]);
                    if (nex[x1] != V + 1)
                        work(nex[x1]);
                &amp;#125;
                return;
            &amp;#125;;
            work(std::max(1, x - d)), work(std::min(V, x + d));
            if (now &amp;lt; mn[u[x]])
                mn[u[x]] = now, to[u[x]] = &amp;#123; i, tab[pos] &amp;#125;;
        &amp;#125;
        for (auto i : pos) &amp;#123;
            int j = u[a[to[i].second]], x = to[i].first, y = to[i].second;
            if (find(i) != find(j)) &amp;#123;
                --tot;
                f[find(i)] = find(j);
                g[x].emplace_back(y, mn[i]), g[y].emplace_back(x, mn[i]);
            &amp;#125;
        &amp;#125;
    &amp;#125;
    std::vector&amp;lt;int&amp;gt; res(n + 1);
    std::function&amp;lt;void(int, int)&amp;gt; DFS = [&amp;amp;](int x, int fa) &amp;#123;
        for (auto [i, w] : g[x])
            if (i != fa) &amp;#123;
                res[i] = std::max(res[x], w);
                DFS(i, x);
            &amp;#125;
        return;
    &amp;#125;;
    DFS(s, -1);
    for (int x, k; q--; ) &amp;#123;
        std::cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; k;
        std::cout &amp;lt;&amp;lt; ((res[x] &amp;lt;= k) ? &amp;quot;Yes&amp;quot; : &amp;quot;No&amp;quot;) &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    &amp;#125;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;b---parametric-mst&#34;&gt;B - Parametric MST&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/CF1656F&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/CF1656F&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可以猜到能够把答案写出来，但是发现太抽象了以至于不太好模拟。&lt;/li&gt;
&lt;li&gt;首先需要猜到题目给的 &lt;span class=&#34;math inline&#34;&gt;\(w\)&lt;/span&gt; 是可以继续化的，注意到 &lt;span class=&#34;math inline&#34;&gt;\(a_i\cdot a_j+t(a_i+a_j)\)&lt;/span&gt; 可以写成 &lt;span class=&#34;math inline&#34;&gt;\((a_j+t)\cdot a_i+t\cdot a_i\)&lt;/span&gt; 的一次函数形式，一个很重要的思路是放弃模拟 mst 转而&lt;strong&gt;从点出发贪心&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(t\)&lt;/span&gt; 会影响的是斜率 &lt;span class=&#34;math inline&#34;&gt;\(a_j+t\)&lt;/span&gt;，所以&lt;strong&gt;应该根据 &lt;span class=&#34;math inline&#34;&gt;\(a_j+t\)&lt;/span&gt; 的正负情况选择贪心策略&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;当 &lt;span class=&#34;math inline&#34;&gt;\(a_j+t\le 0\)&lt;/span&gt; 时，使 &lt;span class=&#34;math inline&#34;&gt;\(a_j\)&lt;/span&gt; 向 &lt;span class=&#34;math inline&#34;&gt;\(a_{\max}\)&lt;/span&gt; 连边，否则向 &lt;span class=&#34;math inline&#34;&gt;\(a_{\min}\)&lt;/span&gt; 连边。&lt;/p&gt;
&lt;p&gt;这其实是 Boruvka 第一轮的过程；此时只剩至多两个连通块，连边方式也就讨论一下 &lt;span class=&#34;math inline&#34;&gt;\(a_1+t\)&lt;/span&gt; 和 &lt;span class=&#34;math inline&#34;&gt;\(a_n+t\)&lt;/span&gt; 的正负，然后很显然了。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;当 &lt;span class=&#34;math inline&#34;&gt;\(t\)&lt;/span&gt; 足够小时，所有点都会连向 &lt;span class=&#34;math inline&#34;&gt;\(a_{\max}\)&lt;/span&gt;；反之，当 &lt;span class=&#34;math inline&#34;&gt;\(t\)&lt;/span&gt; 足够大时，所有点都会连向 &lt;span class=&#34;math inline&#34;&gt;\(a_{\min}\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;对于第一种情况，mst 的权为 &lt;span class=&#34;math inline&#34;&gt;\(a_{\max}\cdot (s - a_{\max}) + t\cdot ((n-1)\cdot a_{\max}+s-a_{\max})\)&lt;/span&gt;；第二种情况，mst 的权为 &lt;span class=&#34;math inline&#34;&gt;\(a_{\min}\cdot (s - a_{\min}) + t\cdot ((n-1)\cdot a_{\min}+s-a_{\min})\)&lt;/span&gt;，check &lt;span class=&#34;math inline&#34;&gt;\(t\)&lt;/span&gt; 的系数即可判 &lt;code&gt;INF&lt;/code&gt;。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;通过上面一种情况，可以注意到 &lt;span class=&#34;math inline&#34;&gt;\(t\in[-a_{\max},-a_{\min}]\)&lt;/span&gt;，进一步需要猜到 &lt;span class=&#34;math inline&#34;&gt;\(t\)&lt;/span&gt; 取某个 &lt;span class=&#34;math inline&#34;&gt;\(-a_i\)&lt;/span&gt;。由于连的边是很已知的，可以发现当 &lt;span class=&#34;math inline&#34;&gt;\(t\)&lt;/span&gt; 夹在两个连续的 &lt;span class=&#34;math inline&#34;&gt;\(-a\)&lt;/span&gt; 之间时，mst 的连边情况是不变的。&lt;/p&gt;
&lt;p&gt;显然此时 mst 的权是一个关于 &lt;span class=&#34;math inline&#34;&gt;\(t\)&lt;/span&gt; 的一次函数，故 check 两端点即可。排序即可快速 check。&lt;/p&gt;
&lt;p&gt;由于此时第二轮 Boruvka 要连的边一定是 &lt;span class=&#34;math inline&#34;&gt;\((a_1,a_n)\)&lt;/span&gt;，连上即可。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int T;
    for (std::cin &amp;gt;&amp;gt; T; T--; ) &amp;#123;
        int n;
        std::cin &amp;gt;&amp;gt; n;
        std::vector&amp;lt;long long&amp;gt; a(n + 1), s(n + 1);
        for (int i = 1; i &amp;lt;= n; ++i)
            std::cin &amp;gt;&amp;gt; a[i];
        std::sort(a.begin() + 1, a.end());
        std::partial_sum(a.begin() + 1, a.end(), s.begin() + 1);
        if ((n - 1) * a[n] + s[n - 1] &amp;lt; 0ll || (n - 1) * a[1] + s[n] - a[1] &amp;gt; 0ll)
            std::cout &amp;lt;&amp;lt; &amp;quot;INF\n&amp;quot;;
        else &amp;#123;
            long long res = -1e18;
            for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
                auto t = -a[i], sl = s[i] - a[1], sr = s[n - 1] - s[i];
                res = std::max(res, a[n] * sl + a[1] * sr + t * ((i - 1) * a[n] + (n - 1 - i) * a[1] + sl + sr) + a[1] * a[n] + t * (a[1] + a[n]));
            &amp;#125;
            std::cout &amp;lt;&amp;lt; res &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
        &amp;#125;
    &amp;#125;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;c---star-mst&#34;&gt;C - Star MST&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/CF1657E&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/CF1657E&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;模拟 Kruskal 的过程，在边权 &lt;span class=&#34;math inline&#34;&gt;\(w\)&lt;/span&gt; 处出现 &lt;span class=&#34;math inline&#34;&gt;\((1,x)\)&lt;/span&gt;，那么允许在 &lt;span class=&#34;math inline&#34;&gt;\(\ge w\)&lt;/span&gt; 处出现其他与 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 相关的边。&lt;/li&gt;
&lt;li&gt;会有一个比较暴力的想法，设 &lt;span class=&#34;math inline&#34;&gt;\(f_{i,j,l}\)&lt;/span&gt; 表示已经分配完边权 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt;，共分配了 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; 条与 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt; 相关的边，还剩下 &lt;span class=&#34;math inline&#34;&gt;\(l\)&lt;/span&gt; 条空闲边可以放，会有一个 &lt;span class=&#34;math inline&#34;&gt;\(O(k\cdot n^4)\)&lt;/span&gt; 的转移。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;考虑优化。容易注意到没必要存 &lt;span class=&#34;math inline&#34;&gt;\(l\)&lt;/span&gt; 而是可以当场完成分配，但这样就导致 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 维的限制转化为『恰好』，需要额外枚举一轮。总之可以得到：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
f_{i,j}=\sum_{d_i=1}^{i}\sum_{d_j=1}^{j} C_{n-(j-d_j)}^{d_j}\times f_{i-d_i,j-d_j}\times (k-i+1)^{C_{d_j}^2+d_j\times (j-d_j)}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;此时复杂度为 &lt;span class=&#34;math inline&#34;&gt;\(O(k^2n^2\log k)\)&lt;/span&gt;，依然不够看；注意到交换求和顺序可以前缀和优化，故：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
f_{j, i}=\sum_{d_j=1}^{j} C_{n-(j-d_j)}^{d_j}\times (k-i+1)^{C_{d_j}^2+d_j\times (j-d_j)}\times \sum_{d_i=1}^{i}f_{j - d_j,i-d_i}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;复杂度 &lt;span class=&#34;math inline&#34;&gt;\(O(kn^2\log k)\)&lt;/span&gt;。&lt;span class=&#34;math inline&#34;&gt;\(\log\)&lt;/span&gt; 来源于快速幂。当然可以考虑预处理优化掉 log，whatever.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int mod = 998244353;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, k;
    std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; k;
    std::vector&amp;lt;std::vector&amp;lt;long long&amp;gt; &amp;gt; C(n + 1, std::vector&amp;lt;long long&amp;gt; (n + 1));
    for (int i = 0; i &amp;lt;= n; ++i) &amp;#123;
        C[i][0] = 1ll;
        for (int j = 1; j &amp;lt;= i; ++j)
            C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % mod;
    &amp;#125;
    auto qkp = [&amp;amp;](long long x, int y) &amp;#123;
        auto res = 1ll;
        for (; y; (x *= x) %= mod, y &amp;gt;&amp;gt;= 1)
            if (y &amp;amp; 1)
                (res *= x) %= mod;
        return res;
    &amp;#125;;
    std::vector&amp;lt;std::vector&amp;lt;long long&amp;gt; &amp;gt; s(n, std::vector&amp;lt;long long&amp;gt; (k + 1));
    for (int i = 0; i &amp;lt;= k; ++i)
        s[0][i] = 1ll;
    for (int j = 1; j &amp;lt; n; ++j)
        for (int i = 1; i &amp;lt;= k; ++i) &amp;#123;
            for (int dj = 1; dj &amp;lt;= j; ++dj) 
                s[j][i] += C[n - (j - dj) - 1][dj] * qkp(k - i + 1, (C[dj][2] + dj * (j - dj)) % mod) % mod * s[j - dj][i - 1] % mod;
            (s[j][i] += s[j][i - 1]) %= mod;
        &amp;#125;
    std::cout &amp;lt;&amp;lt; s[n - 1][k] &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;d---smooth-sailing-hard-version&#34;&gt;D - Smooth Sailing (Hard Version)&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/CF1920F2&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/CF1920F2&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;实在十分熟悉，之前在哪道 CF 题遇到过这个 trick，然而没什么回忆线索，遂放弃&lt;/p&gt;
&lt;p&gt;一个连通块被包围的充要条件：从连通块边缘任意一个点向任意方向发一条射线，&lt;em&gt;垂直&lt;/em&gt;经过路径奇数次。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;垂直&lt;/em&gt;：即切线不切换奇偶状态。&lt;/p&gt;
&lt;p&gt;这个东西其实来源于计算几何，但是我的数学水平只停留在听说过计算几何四个字的水平，故不深究了。&lt;/p&gt;
&lt;p&gt;这种网格图上的图论问题，可以往欧拉定理（&lt;span class=&#34;math inline&#34;&gt;\(v-e+f=2\)&lt;/span&gt;），计算几何考虑，&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;怎么在保证这一点的前提下求 mst 呢？答案是丢到状态里。&lt;/p&gt;
&lt;p&gt;找一个最靠左的点往左边引一条射线并标记沿路经过的点。令 &lt;span class=&#34;math inline&#34;&gt;\((x, y, 0/1)\)&lt;/span&gt; 表示走到 &lt;span class=&#34;math inline&#34;&gt;\((x, y)\)&lt;/span&gt;，经过关键点偶数次 / 奇数次。边权啥的也没什么好说的，点权前移即可。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;询问的转化反而不太好想，其实就是问 &lt;span class=&#34;math inline&#34;&gt;\((x,y,0)\)&lt;/span&gt; 到 &lt;span class=&#34;math inline&#34;&gt;\((x,y,1)\)&lt;/span&gt; 的瓶颈路。&lt;/p&gt;
&lt;p&gt;巧得有些不太自然，然而并没找到合理的解释。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;询问建个 Kruskal 重构树找 LCA 即可，复杂度 &lt;span class=&#34;math inline&#34;&gt;\(O(nm\log nm)\)&lt;/span&gt;。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int dir[][2] = &amp;#123;&amp;#123; -1, 0 &amp;#125;, &amp;#123; 1, 0 &amp;#125;, &amp;#123; 0, -1 &amp;#125;, &amp;#123; 0, 1 &amp;#125;&amp;#125;;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, m, q;
    std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m &amp;gt;&amp;gt; q;
    int cnt = 2 * n * m;
    std::vector&amp;lt;int&amp;gt; W(1);
    std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; g(2 * n * m + 1);
    auto fun = [&amp;amp;](int i, int j, int k) &amp;#123;
        return k * n * m + (i - 1) * m + j;
    &amp;#125;;
    &amp;#123;
        int px = 0, py = m + 1;
        std::vector&amp;lt;std::vector&amp;lt;char&amp;gt; &amp;gt; a(n + 1, std::vector&amp;lt;char&amp;gt; (m + 1));
        for (int i = 1; i &amp;lt;= n; ++i)
            for (int j = 1; j &amp;lt;= m; ++j) &amp;#123;
                std::cin &amp;gt;&amp;gt; a[i][j];
                if (a[i][j] == &amp;#39;#&amp;#39; &amp;amp;&amp;amp; j &amp;lt; py)
                    px = i, py = j;
            &amp;#125;
        std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; w(n + 1, std::vector&amp;lt;int&amp;gt; (m + 1, 0x3f3f3f3f));
        &amp;#123;
            std::queue&amp;lt;std::pair&amp;lt;int, int&amp;gt; &amp;gt; q;
            for (int i = 1; i &amp;lt;= n; ++i)
                for (int j = 1; j &amp;lt;= m; ++j)
                    if (a[i][j] == &amp;#39;v&amp;#39;)
                        q.emplace(i, j), w[i][j] = 0;
            for (; !q.empty(); ) &amp;#123;
                auto [x, y] = q.front();
                q.pop();
                for (auto [fx, fy] : dir) &amp;#123;
                    int nx = x + fx, ny = y + fy;
                    if (nx &amp;gt;= 1 &amp;amp;&amp;amp; nx &amp;lt;= n &amp;amp;&amp;amp; ny &amp;gt;= 1 &amp;amp;&amp;amp; ny &amp;lt;= m &amp;amp;&amp;amp; w[nx][ny] == 0x3f3f3f3f) &amp;#123;
                        w[nx][ny] = w[x][y] + 1;
                        q.emplace(nx, ny);
                    &amp;#125;
                &amp;#125;
            &amp;#125;
        &amp;#125;
        struct edge &amp;#123; int u, v, w; &amp;#125;;
        std::vector&amp;lt;edge&amp;gt; e;
        for (int i = 1; i &amp;lt;= n; ++i)
            for (int j = 1; j &amp;lt;= m; ++j)
                if (a[i][j] != &amp;#39;#&amp;#39;) &amp;#123;
                    if (j != m &amp;amp;&amp;amp; a[i][j + 1] != &amp;#39;#&amp;#39;) &amp;#123;
                        e.push_back(&amp;#123; fun(i, j, 0), fun(i, j + 1, 0), std::min(w[i][j], w[i][j + 1]) &amp;#125;);
                        e.push_back(&amp;#123; fun(i, j, 1), fun(i, j + 1, 1), std::min(w[i][j], w[i][j + 1]) &amp;#125;);
                    &amp;#125;
                    if (i != n &amp;amp;&amp;amp; a[i + 1][j] != &amp;#39;#&amp;#39;) &amp;#123;
                        if (i + 1 == px &amp;amp;&amp;amp; j &amp;lt;= py) &amp;#123;
                            e.push_back(&amp;#123; fun(i, j, 0), fun(i + 1, j, 1), std::min(w[i][j], w[i + 1][j]) &amp;#125;);
                            e.push_back(&amp;#123; fun(i, j, 1), fun(i + 1, j, 0), std::min(w[i][j], w[i + 1][j]) &amp;#125;);
                        &amp;#125;
                        else &amp;#123;
                            e.push_back(&amp;#123; fun(i, j, 0), fun(i + 1, j, 0), std::min(w[i][j], w[i + 1][j]) &amp;#125;);
                            e.push_back(&amp;#123; fun(i, j, 1), fun(i + 1, j, 1), std::min(w[i][j], w[i + 1][j]) &amp;#125;);
                        &amp;#125;
                    &amp;#125;
                &amp;#125;
        std::sort(e.begin(), e.end(), [&amp;amp;](edge &amp;amp;x, edge &amp;amp;y) &amp;#123; return x.w &amp;gt; y.w; &amp;#125;);
        std::vector&amp;lt;int&amp;gt; f(2 * n * m + 1);
        std::iota(f.begin() + 1, f.end(), 1);
        std::function&amp;lt;int(int)&amp;gt; find = [&amp;amp;](int x) &amp;#123;
            return x == f[x] ? x : f[x] = find(f[x]);
        &amp;#125;;
        for (auto [x, y, w] : e)
            if (find(x) != find(y)) &amp;#123;
                f.push_back(++cnt);
                W.push_back(w), g.emplace_back();
                g[cnt].push_back(find(x)), g[cnt].push_back(find(y));
                f[find(x)] = f[find(y)] = cnt;
            &amp;#125;
    &amp;#125;
    std::vector&amp;lt;int&amp;gt; fa(cnt + 1), siz(cnt + 1), dep(cnt + 1), son(cnt + 1), top(cnt + 1);
    std::function&amp;lt;void(int)&amp;gt; DFS = [&amp;amp;](int x) &amp;#123;
        siz[x] = 1;
        for (auto i : g[x]) &amp;#123;
            dep[i] = dep[x] + 1;
            DFS(i), fa[i] = x;
            siz[x] += siz[i];
            if (siz[i] &amp;gt; siz[son[x]])
                son[x] = i;
        &amp;#125;
        return;
    &amp;#125;;
    dep[1] = 1, DFS(cnt);
    DFS = [&amp;amp;](int x) &amp;#123;
        if (son[x])
            top[son[x]] = top[x], DFS(son[x]);
        for (auto i : g[x])
            if (i != son[x])
                top[i] = i, DFS(i);
        return;
    &amp;#125;;
    top[cnt] = cnt, DFS(cnt);
    auto ask = [&amp;amp;](int x, int y) &amp;#123;
        for (; top[x] != top[y]; x = fa[top[x]])
            if (dep[top[x]] &amp;lt; dep[top[y]])
                std::swap(x, y);
        return dep[x] &amp;lt; dep[y] ? x : y;
    &amp;#125;;
    for (int x, y; q--; ) &amp;#123;
        std::cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; y;
        std::cout &amp;lt;&amp;lt; W[ask(fun(x, y, 0), fun(x, y, 1)) - 2 * n * m] &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    &amp;#125;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;e---turtle-and-intersected-segments&#34;&gt;E - Turtle and Intersected Segments&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/CF1981E&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/CF1981E&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;考虑绝对值的几何意义，很容易发现有的边注定是无效的：&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&#34;image.png&#34; alt=&#34;如图中三条线段形成一个环，权值如图，排除掉权值最大的边，发现只会连权值相邻的边&#34; /&gt;&lt;figcaption&gt;如图中三条线段形成一个环，权值如图，排除掉权值最大的边，发现只会连权值相邻的边&lt;/figcaption&gt;
&lt;/figure&gt;&lt;/li&gt;
&lt;li&gt;换句话说，对于数轴上的这个点，仅需把覆盖之的所有&lt;em&gt;线段序列&lt;/em&gt;按 &lt;span class=&#34;math inline&#34;&gt;\(a\)&lt;/span&gt; 排序，连接相邻者即可。怎么更快地实现这个过程呢？&lt;/li&gt;
&lt;li&gt;&lt;p&gt;发现只需要在这个&lt;em&gt;线段序列&lt;/em&gt;变化的时候连新的边，故用 multiset 维护这个序列，扫一遍，在加入新线段时连接它和前驱后继即可（结合前文论述发现删除的时候不用管）。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int T;
    for (std::cin &amp;gt;&amp;gt; T; T--; ) &amp;#123;
        int n;
        std::cin &amp;gt;&amp;gt; n;
        struct node &amp;#123; int l, r, v; &amp;#125;;
        struct edge &amp;#123; int u, v, w; &amp;#125;;
        std::vector&amp;lt;edge&amp;gt; e;
        std::vector&amp;lt;node&amp;gt; a(n + 1);
        for (int i = 1; i &amp;lt;= n; ++i)
            std::cin &amp;gt;&amp;gt; a[i].l &amp;gt;&amp;gt; a[i].r &amp;gt;&amp;gt; a[i].v;
        std::sort(a.begin() + 1, a.end(), [&amp;amp;](node &amp;amp;x, node &amp;amp;y) &amp;#123; return x.l &amp;lt; y.l; &amp;#125;);
        std::set&amp;lt;std::tuple&amp;lt;int, int, int&amp;gt; &amp;gt; t;
        std::set&amp;lt;std::pair&amp;lt;int, int&amp;gt; &amp;gt; now;
        for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
            for (; !t.empty();) &amp;#123;
                auto [r, v, id] = *t.begin();
                if (r &amp;gt;= a[i].l)
                    break;
                now.erase(std::make_pair(v, id));
                t.erase(t.begin());
            &amp;#125;
            auto p = now.lower_bound(std::make_pair(a[i].v, i));
            if (p != now.end())
                e.push_back(&amp;#123; i, p-&amp;gt;second, p-&amp;gt;first - a[i].v &amp;#125;);
            if (p != now.begin()) &amp;#123;
                --p;
                e.push_back(&amp;#123; i, p-&amp;gt;second, a[i].v - p-&amp;gt;first &amp;#125;);
            &amp;#125;
            t.emplace(a[i].r, a[i].v, i), now.emplace(a[i].v, i);
        &amp;#125;
        std::sort(e.begin(), e.end(), [&amp;amp;](edge &amp;amp;x, edge &amp;amp;y) &amp;#123; return x.w &amp;lt; y.w; &amp;#125;);
        auto res = 0ll;
        std::vector&amp;lt;int&amp;gt; f(n + 1);
        std::iota(f.begin() + 1, f.end(), 1);
        std::function&amp;lt;int(int)&amp;gt; find = [&amp;amp;](int x) &amp;#123;
            return x == f[x] ? x : f[x] = find(f[x]);
        &amp;#125;;
        int cntm = 0;
        for (auto [u, v, w] : e)
            if (find(u) != find(v)) &amp;#123;
                f[find(u)] = find(v);
                res += w, ++cntm;
            &amp;#125;
        if (cntm == n - 1)
            std::cout &amp;lt;&amp;lt; res &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
        else
            std::cout &amp;lt;&amp;lt; -1 &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    &amp;#125;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;f---digital-village-extreme-version&#34;&gt;F - Digital Village (Extreme Version)&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/CF2021E3&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/CF2021E3&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;为啥会想到 DP（。）前面不都是神秘建图题吗（。）&lt;/li&gt;
&lt;li&gt;&lt;p&gt;会发现待求即为重构树上 LCA 的权值，但题设中的 Key 是设置了服务器的结点，二者不匹配。如果直接设 &lt;span class=&#34;math inline&#34;&gt;\(f_{x,j}\)&lt;/span&gt; 表示 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 子树内设了 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; 个服务器，感觉不太可行。&lt;/p&gt;
&lt;p&gt;当然也可能是因为我没做过重构树上的 DP。Whatever.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;实际上需要结合重构树的性质考虑。发现一个子树内部不能消化，当且仅当&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://xsc062.netlify.app/20251010/</guid>
            <title>树状数组</title>
            <link>https://xsc062.netlify.app/20251010/</link>
            <category>树状数组</category>
            <category>倍增</category>
            <pubDate>Fri, 10 Oct 2025 08:12:01 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;我有一个朋友今天才会树状数组（存疑）&lt;/p&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;
&lt;p&gt;因为到了今天还是不会&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;单点修改区间查询&#34;&gt;单点修改，区间查询&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;树状数组本身是一个多叉树结构。每个点 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 上保存 &lt;span class=&#34;math inline&#34;&gt;\([i-\text{lowbit}(i)+1,i]\)&lt;/span&gt; 的和，并指向若干个更小的子区间（彼此不重，且拼起来是自身）&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&#34;image-1.png&#34; alt=&#34;图源 OI Wiki&#34; /&gt;&lt;figcaption&gt;图源 OI Wiki&lt;/figcaption&gt;
&lt;/figure&gt;&lt;/li&gt;
&lt;li&gt;修改 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt;：从包含 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 的最低点（id 为 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 且右端点为 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt;）一直向上修改包含 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 的区间。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;查询 &lt;span class=&#34;math inline&#34;&gt;\([1, x]\)&lt;/span&gt;：从右端点为 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 的区间（id 为 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt;）出发，不断找到前方紧邻的区间（&lt;span class=&#34;math inline&#34;&gt;\(id\)&lt;/span&gt; 差为 lowbit），累加进答案。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;区间修改单点查询&#34;&gt;区间修改，单点查询&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;运用序列问题上的技巧，转化为差分数组上的单点修改、前缀查询。&lt;/li&gt;
&lt;li&gt;事实上除了基本结构以外的内容，树状数组本身并没有参与，只需当作&lt;strong&gt;一个输入单点修改，输出前缀和的黑盒&lt;/strong&gt;即可。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;区间修改区间查询&#34;&gt;区间修改，区间查询&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;考虑沿用差分的方法实现区间修改。考虑数学推导表达区间前缀和。&lt;/p&gt;
&lt;p&gt;已知 &lt;span class=&#34;math inline&#34;&gt;\(d_i=a_i-a_{i-1}\)&lt;/span&gt;，则：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
\begin{aligned}
\sum\limits_{i=1}^x a_i=&amp;amp;\sum\limits_{i=1}^x\sum_{j=1}^i d_j\\
=&amp;amp;\sum\limits_{i=1}^x d_i\cdot (x-i+1)\\
=&amp;amp;(x+1)\cdot \left(\sum\limits_{i=1}^x d_i\right) - \left(\sum\limits_{i=1}^x i\cdot d_i\right)
\end{aligned}
\]&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;故只需要在黑盒中维护 &lt;span class=&#34;math inline&#34;&gt;\(d_i\)&lt;/span&gt; 和 &lt;span class=&#34;math inline&#34;&gt;\(i\cdot d_i\)&lt;/span&gt; 的单点修改即可。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在实现时感到违和：对 &lt;span class=&#34;math inline&#34;&gt;\([l, r]\)&lt;/span&gt; 做区间修改时，对于 &lt;span class=&#34;math inline&#34;&gt;\(l\)&lt;/span&gt; 处的 &lt;span class=&#34;math inline&#34;&gt;\(i\cdot d_i\)&lt;/span&gt; 作出了 &lt;span class=&#34;math inline&#34;&gt;\(l\cdot \Delta\)&lt;/span&gt; 的修改，为何在 &lt;span class=&#34;math inline&#34;&gt;\(r+1\)&lt;/span&gt; 处作 &lt;span class=&#34;math inline&#34;&gt;\((r + 1)\cdot \Delta\)&lt;/span&gt; 的修改（而非也是 &lt;span class=&#34;math inline&#34;&gt;\(l\cdot \Delta\)&lt;/span&gt;？）&lt;/p&gt;
&lt;p&gt;事实上，对于 &lt;span class=&#34;math inline&#34;&gt;\(i\cdot d_i\)&lt;/span&gt; 的修改是对 &lt;span class=&#34;math inline&#34;&gt;\(d_i\)&lt;/span&gt; 修改的字面反映，这个量本身并没有具体的含义。&lt;/p&gt;
&lt;p&gt;感觉有点唐唐的，也就只有我会有这种疑惑了……&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;excercise&#34;&gt;Excercise&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;维护 &lt;span class=&#34;math inline&#34;&gt;\(a_i\)&lt;/span&gt; 的区间加、&lt;span class=&#34;math inline&#34;&gt;\(a_i\)&lt;/span&gt; 的区间和查询、&lt;span class=&#34;math inline&#34;&gt;\(i\cdot a_i\)&lt;/span&gt; 的区间和查询。&lt;/p&gt;
&lt;p&gt;令 &lt;span class=&#34;math inline&#34;&gt;\(d_i=a_i-a_{i-1}\)&lt;/span&gt;，考虑变形：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
\begin{aligned}
\sum\limits_{i=1}^x i\cdot a_i=&amp;amp;\sum\limits_{i=1}^xi\cdot \sum_{j=1}^i d_j\\
=&amp;amp;\sum\limits_{i=1}^x d_i\cdot \left(i+(i+1)+\cdots +x\right)\\
=&amp;amp;\sum\limits_{i=1}^x d_i\cdot \dfrac {(x+i)\cdot (x-i+1)}2\\
=&amp;amp;\sum\limits_{i=1}^x d_i\cdot \dfrac {x^2+x-i^2+i}2\\
=&amp;amp;\dfrac{(x^2+x)\cdot \left(\sum\limits_{i=1}^x d_i\right) + \left(\sum\limits_{i=1}^x i\cdot d_i\right) - \left(\sum\limits_{i=1}^x i^2\cdot d_i\right)}2
\end{aligned}
\]&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;故只需要在黑盒中维护 &lt;span class=&#34;math inline&#34;&gt;\(d_i\)&lt;/span&gt;、&lt;span class=&#34;math inline&#34;&gt;\(i\cdot d_i\)&lt;/span&gt; 和 &lt;span class=&#34;math inline&#34;&gt;\(i^2\cdot d_i\)&lt;/span&gt; 的单点修改即可。&lt;/p&gt;
&lt;p&gt;见 &lt;a href=&#34;/20251007/#c.-相互抵消&#34;&gt;相互抵消&lt;/a&gt;。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;ex.-北校门外的回忆&#34;&gt;Ex. 北校门外的回忆&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://loj.ac/p/510&#34; class=&#34;uri&#34;&gt;https://loj.ac/p/510&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;定义 &lt;span class=&#34;math inline&#34;&gt;\(\text{lowbit}_K(x)\)&lt;/span&gt; 为 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 在 &lt;span class=&#34;math inline&#34;&gt;\(K\)&lt;/span&gt; 进制下最低非零位的值。有一个异或和树状数组，把原本代码中的 &lt;span class=&#34;math inline&#34;&gt;\(\text{lowbit}_2(x)\)&lt;/span&gt; 全部替换为 &lt;span class=&#34;math inline&#34;&gt;\(\text{lowbit}_K(x)\)&lt;/span&gt;，得到一个正确性和复杂度均错误的『树状数组』，现在给定若干次 &lt;code&gt;add&lt;/code&gt; 和 &lt;code&gt;ask&lt;/code&gt; 操作，你需要输出错误的代码运行的结果。&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(m\le 2\times 10^5\)&lt;/span&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;需要意识到并不是真的要用树状数组模拟这个操作，一边转化一边要想办法把这个错误代码用正常 DS 的操作表述出来。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;add&lt;/code&gt; 的本质是对于非零最低位乘二并进位。手玩可以发现，有的时候『非零最低位』的位置是不变的，有的时候『非零最低位』变成 &lt;span class=&#34;math inline&#34;&gt;\(0\)&lt;/span&gt; 了，就会前移。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;这显然是个 &lt;span class=&#34;math inline&#34;&gt;\(x\to 2x\bmod K\)&lt;/span&gt; 的内向基环树森林，且当存在自环 &lt;span class=&#34;math inline&#34;&gt;\(0\)&lt;/span&gt; 时，一个树中的最大跳跃次数为 &lt;span class=&#34;math inline&#34;&gt;\(\log_2K\)&lt;/span&gt;。&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&#34;image-2.png&#34; alt=&#34;mobai Grisses&#34; /&gt;&lt;figcaption&gt;mobai Grisses&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;故这个时候（即 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 包含了『&lt;span class=&#34;math inline&#34;&gt;\(K\)&lt;/span&gt; 除了 &lt;span class=&#34;math inline&#34;&gt;\(2\)&lt;/span&gt; 之外的因子』时 ）暴力跳即可。对于每一位都这么跳是可以接受的。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(0\)&lt;/span&gt; 不在树中，最终会有一个循环节。不妨把经过的所有点拉出来成为一条链。&lt;/p&gt;
&lt;p&gt;这个时候可以停下来想一想题目给的两个操作是在做什么。显然每个叶子会引导一条无限长的链，则 &lt;code&gt;add&lt;/code&gt; 就是给这个链做了一个后缀加（&lt;span class=&#34;math inline&#34;&gt;\(N\)&lt;/span&gt; 的限制是没影响的），&lt;code&gt;ask&lt;/code&gt; 则是问了 log 个点值。&lt;/p&gt;
&lt;p&gt;则如果这个链真的可以被处理出来，只需要 bit 维护差分即可。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;考虑倍增预处理 &lt;span class=&#34;math inline&#34;&gt;\(f(i,j)\)&lt;/span&gt; 表示 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 走了 &lt;span class=&#34;math inline&#34;&gt;\(2^j\)&lt;/span&gt; 步后到的点，模拟跳 &lt;span class=&#34;math inline&#34;&gt;\(0\)&lt;/span&gt;、倍增跳循环节即可。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;bit-上倍增&#34;&gt;BIT 上倍增&lt;/h2&gt;
&lt;p&gt;更偏数据结构技巧了，也重新回到结构上面。&lt;/p&gt;
&lt;p&gt;对标线段树上二分，缺陷在于能维护的数据限制很大，优势在于常数很小。在出题人刻意只放树状数组过，或者&lt;strong&gt;树套树&lt;/strong&gt;外层为树状数组的时候用处比较明显。&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;冰火战士&#34;&gt;冰火战士&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P6619&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P6619&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定初始为空的二元组数组 &lt;span class=&#34;math inline&#34;&gt;\(A, B\)&lt;/span&gt;。对于阈值 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt;，令 &lt;span class=&#34;math inline&#34;&gt;\(s_A\)&lt;/span&gt; 表示 &lt;span class=&#34;math inline&#34;&gt;\(A\)&lt;/span&gt; 中关键字一 &lt;span class=&#34;math inline&#34;&gt;\(\le k\)&lt;/span&gt; 的元素关键字二之和，&lt;span class=&#34;math inline&#34;&gt;\(s_B\)&lt;/span&gt; 表示 &lt;span class=&#34;math inline&#34;&gt;\(B\)&lt;/span&gt; 中关键字一 &lt;span class=&#34;math inline&#34;&gt;\(\ge k\)&lt;/span&gt; 的元素关键字二之和。&lt;/p&gt;
&lt;p&gt;维护若干次 &lt;span class=&#34;math inline&#34;&gt;\(A,B\)&lt;/span&gt; 的加点、删点操作，每次操作后输出：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;自由选取 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt;，求 &lt;span class=&#34;math inline&#34;&gt;\(\min\{s_A,s_B\}\)&lt;/span&gt; 的最大值。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(m\le 2\times 10^6\)&lt;/span&gt;，&lt;span class=&#34;math inline&#34;&gt;\(V\le 10^9\)&lt;/span&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;不妨考虑固定状态下的询问。容易想到将 &lt;span class=&#34;math inline&#34;&gt;\(A,B\)&lt;/span&gt; 按关键字一&lt;strong&gt;升序排序&lt;/strong&gt;。随着 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 的增大，&lt;span class=&#34;math inline&#34;&gt;\(s_A\)&lt;/span&gt; 是 &lt;span class=&#34;math inline&#34;&gt;\(A\)&lt;/span&gt; 关键字二的前缀和，&lt;span class=&#34;math inline&#34;&gt;\(s_B\)&lt;/span&gt; 是 &lt;span class=&#34;math inline&#34;&gt;\(B\)&lt;/span&gt; 关键字二的后缀和。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;我并不会三分，但题解说因为有平台所以三分做不了。&lt;/p&gt;
&lt;p&gt;但由于最高点同时是交点，可以二分找到最值点。离散化元素后维护此处的前缀和即可。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;容易想到线段树上二分，然而常数太大难以通过。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果改用树状数组呢？树状数组有办法进行类似线段树上二分的操作吗？&lt;/p&gt;
&lt;p&gt;事实上，bit 的结构更适合倍增。其出发点和线段树上二分是相同的，在于规避重复询问。&lt;/p&gt;
&lt;p&gt;假设当前在一个合法位置 &lt;span class=&#34;math inline&#34;&gt;\(p\)&lt;/span&gt;，已经累加到 &lt;span class=&#34;math inline&#34;&gt;\(s\)&lt;/span&gt;，要验证 &lt;span class=&#34;math inline&#34;&gt;\(p+2^k\)&lt;/span&gt;（&lt;span class=&#34;math inline&#34;&gt;\(\text{lowbit}(p+2^k)=2^k\)&lt;/span&gt;）是否仍然合法，仅需 check &lt;span class=&#34;math inline&#34;&gt;\(s+c_{p+2^k}\)&lt;/span&gt; 是否合法（结合树状数组结构想一想）。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;p&gt;其实 Peace 是有点难判的…… 我写了个结构题维护了数量用来判断。&lt;/p&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int m;
    std::cin &amp;gt;&amp;gt; m;
    struct query &amp;#123; int op, k, x, y; &amp;#125;;
    std::vector&amp;lt;query&amp;gt; a(m + 1);
    std::vector&amp;lt;int&amp;gt; l(1);
    for (int i = 1; i &amp;lt;= m; ++i) &amp;#123;
        std::cin &amp;gt;&amp;gt; a[i].op &amp;gt;&amp;gt; a[i].k;
        if (a[i].op == 1) &amp;#123;
            std::cin &amp;gt;&amp;gt; a[i].x &amp;gt;&amp;gt; a[i].y;
            l.push_back(a[i].x);
        &amp;#125;
        else &amp;#123;
            int k = a[i].k;
            a[i].op = -1;
            a[i].k = a[k].k, a[i].x = a[k].x, a[i].y = a[k].y;
        &amp;#125;
    &amp;#125;
    std::sort(l.begin() + 1, l.end());
    l.erase(std::unique(l.begin() + 1, l.end()), l.end());
    int n = (int)l.size();
    std::vector&amp;lt;int&amp;gt; cnt(2);
    std::vector&amp;lt;long long&amp;gt; sum(2);
    struct node &amp;#123;
        int c;
        long long v;
        node(void): c(0), v(0ll) &amp;#123;&amp;#125;
        node(int c1, long long v1): c(c1), v(v1) &amp;#123;&amp;#125;
        node operator+ (const node &amp;amp;q) const &amp;#123;
            return node(c + q.c, v + q.v);
        &amp;#125;
        node operator- (const node &amp;amp;q) const &amp;#123;
            return node(c - q.c, v - q.v);
        &amp;#125;
        node&amp;amp; operator+= (const node q) &amp;#123;
            return *this = *this + q;
        &amp;#125;
        node &amp;amp;operator-= (const node &amp;amp;q) &amp;#123;
            return *this = *this - q;
        &amp;#125;
    &amp;#125;;
    std::vector&amp;lt;std::vector&amp;lt;node&amp;gt; &amp;gt; bit(2, std::vector&amp;lt;node&amp;gt; (n + 1)), s(2, std::vector&amp;lt;node&amp;gt; (n + 1));
    auto lowbit = [&amp;amp;](int x) &amp;#123; return x &amp;amp; -x; &amp;#125;;
    for (int i = 1; i &amp;lt;= m; ++i) &amp;#123;
        a[i].x = std::lower_bound(l.begin() + 1, l.end(), a[i].x) - l.begin() + a[i].k;
        cnt[a[i].k] += a[i].op, sum[a[i].k] += a[i].op * a[i].y;
        s[a[i].k][a[i].x] += node(a[i].op, a[i].op * a[i].y);
        for (int j = a[i].x; j &amp;lt;= n; j += lowbit(j))
            bit[a[i].k][j] += node(a[i].op, a[i].op * a[i].y);
        if (std::min(cnt[0], cnt[1]) == 0)
            std::cout &amp;lt;&amp;lt; &amp;quot;Peace\n&amp;quot;;
        else &amp;#123;
            int p = 0;
            node s0(0, 0ll), s1(cnt[1], sum[1]);
            for (int i = 20; ~i; --i)
                if (p + (1 &amp;lt;&amp;lt; i) &amp;lt;= n &amp;amp;&amp;amp; (s0 + bit[0][p + (1 &amp;lt;&amp;lt; i)]).v &amp;lt;= (s1 - bit[1][p + (1 &amp;lt;&amp;lt; i)]).v)
                    p += (1 &amp;lt;&amp;lt; i), s0 += bit[0][p], s1 -= bit[1][p];
            if (p + 1 &amp;lt;= n &amp;amp;&amp;amp; s1.c != s[1][p + 1].c &amp;amp;&amp;amp; (s1 - s[1][p + 1]).v &amp;gt;= s0.v) &amp;#123;
                s1 -= s[1][p + 1], s0 = node(cnt[1], sum[1]), p = 0;
                for (int i = 20; ~i; --i)
                    if (p + (1 &amp;lt;&amp;lt; i) &amp;lt;= n &amp;amp;&amp;amp; (s0 - bit[1][p + (1 &amp;lt;&amp;lt; i)]).v &amp;gt;= s1.v)
                        p += (1 &amp;lt;&amp;lt; i), s0 -= bit[1][p];
                std::cout &amp;lt;&amp;lt; l[p] &amp;lt;&amp;lt; &amp;#39; &amp;#39; &amp;lt;&amp;lt; 2 * s1.v &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
            &amp;#125;
            else if (s0.c)
                std::cout &amp;lt;&amp;lt; l[p] &amp;lt;&amp;lt; &amp;#39; &amp;#39; &amp;lt;&amp;lt; 2 * s0.v &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
            else
                std::cout &amp;lt;&amp;lt; &amp;quot;Peace\n&amp;quot;;
        &amp;#125;
    &amp;#125;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;sails-船帆&#34;&gt;sails 船帆&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P4647&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P4647&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;需要意识到&lt;strong&gt;帆的顺序对答案没有影响，同一行帆的个数对答案有影响&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;从这一点出发会有一个比较显然的贪心：把柱状图斜过来，把柱子按 &lt;span class=&#34;math inline&#34;&gt;\(h\)&lt;/span&gt; 从小到大&lt;strong&gt;排序&lt;/strong&gt;，问题变为对于第 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 次操作，选 &lt;span class=&#34;math inline&#34;&gt;\(1\sim h_i\)&lt;/span&gt; 里最矮的几列使其高度 +1。&lt;/p&gt;
&lt;p&gt;其实会有一些其他的贪心方法，比如我一开始想的是不排序，在 &lt;span class=&#34;math inline&#34;&gt;\(1\sim h_i\)&lt;/span&gt; 内，优先使最矮的高度 +1，高度相同的使编号更大的柱子高度 +1。这个的正确性也比较好证明，但是太复杂了，没什么好的优化。&lt;strong&gt;把贪心策略中的偏序关系提前到一次排序&lt;/strong&gt;就会简单很多。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;现在需要找到最矮的这几列。&lt;del&gt;我会文艺平衡树&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;考虑更加天才的做法。如果我们需要用 bit，线段树这样的结构来维护操作，就会有一些问题： 为了快速修改，需要保证修改的元素是连续的。简单的方法是让元素有序地在 ds 中排列。但修改操作本身会破坏这样的偏序关系。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;不妨假设元素降序排列（和后方的 0 衔接），那么需要把 &lt;span class=&#34;math inline&#34;&gt;\([h-k+1,h]\)&lt;/span&gt; 这段元素 +1，但这会造成部分元素的前移，考虑前移的过程到底发生了什么。&lt;/p&gt;
&lt;p&gt;考虑这样的场景：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;由于 delta 为 1，至多只会有一段数发生这样的前移。&lt;/strong&gt;先 ask 一下 &lt;span class=&#34;math inline&#34;&gt;\(h-k+1\)&lt;/span&gt; 处的值，假设这一段的左右端点为 &lt;span class=&#34;math inline&#34;&gt;\([l,r]\)&lt;/span&gt;，只需要修改 &lt;span class=&#34;math inline&#34;&gt;\([l,l+(r-(h-k+1))]\)&lt;/span&gt; 和 &lt;span class=&#34;math inline&#34;&gt;\([r+1,h]\)&lt;/span&gt; 两段区间即可。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\([l,r]\)&lt;/span&gt; 是可以通过 bit 上倍增求出的。复杂度 &lt;span class=&#34;math inline&#34;&gt;\(O(n\log n)\)&lt;/span&gt;。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;insert&#34;&gt;Insert&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/AT_abc392_f&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/AT_abc392_f&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;维护每个数的位置，相当于给值在 &lt;span class=&#34;math inline&#34;&gt;\([P_i,i-1]\)&lt;/span&gt; 的元素做区间 +1，显然右端点是单增的，那么就转化为上一题。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;买宝石&#34;&gt;买宝石&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.becoder.com.cn/contest/6620/problem/4&#34; class=&#34;uri&#34;&gt;https://www.becoder.com.cn/contest/6620/problem/4&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;见 &lt;a href=&#34;/20251007-1/#买宝石&#34;&gt;树套树&lt;/a&gt;。&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://xsc062.netlify.app/20251007-1/</guid>
            <title>学习笔记 树套树</title>
            <link>https://xsc062.netlify.app/20251007-1/</link>
            <category>树套树</category>
            <pubDate>Tue, 07 Oct 2025 16:29:52 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;第一次学树套树时，并没有什么特别的感觉，因为属于我的离线分治，我早已遇见&lt;/p&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;
&lt;p&gt;并非第一次学&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;线段树&#34;&gt;线段树&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;考虑线段树的本质，即给定序列，能够返回关键字在 &lt;span class=&#34;math inline&#34;&gt;\([l,r]\)&lt;/span&gt; 内的可加信息之和&lt;/li&gt;
&lt;li&gt;仅需要保证信息是&lt;strong&gt;可加&lt;/strong&gt;的（如众数，mex 等显然不在此列）&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;树状数组&#34;&gt;树状数组&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;给定序列，能够返回任意关键字处的前缀和 / 后缀和，需要保证信息是&lt;strong&gt;可加&lt;/strong&gt;的&lt;/li&gt;
&lt;li&gt;如果要求任意区间内关键字的信息之和，会用到差分，此时还需额外保证信息是&lt;strong&gt;可减&lt;/strong&gt;的（如 min / max 显然不在此列）&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;主席树-可持久化线段树&#34;&gt;主席树 / 可持久化线段树&lt;/h2&gt;
&lt;p&gt;之前有人在争论『主席树』是否等价于『可持久化线段树』，其实从当前 OI 环境的语境下我觉得是等价的&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;给定序列，存在关键字 A 和关键字 B，能够求出 &lt;span class=&#34;math inline&#34;&gt;\(([0, A&amp;#39;], [B_1, B_2])\)&lt;/span&gt; 这个矩形的信息和（这里的矩形可能是 DAG 状的）&lt;/p&gt;
&lt;p&gt;也就是说主席树本身存的是关于 A 的信息前缀和&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;要求 A 只能来源于先前的 A（即 A 具有&lt;strong&gt;单调性&lt;/strong&gt;），且底层信息的 delta 为 1&lt;/p&gt;
&lt;p&gt;需要发现这个条件是相当苛刻的，所以这里的 A 通常以时间 / 版本 / DAG 的形式出现&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果信息具有&lt;strong&gt;可减&lt;/strong&gt;性，对于 &lt;span class=&#34;math inline&#34;&gt;\(A_2\)&lt;/span&gt; 和其某个祖先 &lt;span class=&#34;math inline&#34;&gt;\(A_1\)&lt;/span&gt;，能够求出 &lt;span class=&#34;math inline&#34;&gt;\(([A_1,A_2],[B_1,B_2])\)&lt;/span&gt; 这个矩形的信息和。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;考虑为什么主席树不能解决三维偏序&lt;/li&gt;
&lt;li&gt;现在已经对关键字 C 排完序了，我们需要求出 &lt;span class=&#34;math inline&#34;&gt;\(([0, A], [0, B])\)&lt;/span&gt; 这个矩形的信息和&lt;/li&gt;
&lt;li&gt;发现 A 是不具备&lt;strong&gt;单调性&lt;/strong&gt;的，有没有什么 DS 能够不要求 A 的单调性呢？&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;树状数组套线段树&#34;&gt;树状数组套线段树&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;用 &lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt; 棵线段树维护 B 的偏序关系，用类主席树的方式来排列这些树&lt;/li&gt;
&lt;li&gt;&lt;p&gt;发现一次修改需要改一段后缀&lt;/p&gt;
&lt;p&gt;这一点我们前面说过了，主席树本身存储的是 A 维的前缀和。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;所以直接解决这个问题：维护信息的差分。这样就可以通过询问前缀得到原始信息&lt;/li&gt;
&lt;li&gt;&lt;p&gt;这个结构和树状数组是很吻合的，考虑在树状数组的每个点上维护动态开点线段树&lt;/p&gt;
&lt;p&gt;这样就可以只用修改 log 个线段树&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;考虑怎么询问&lt;/p&gt;
&lt;p&gt;我最初的想法是，做一个线段树合并，利用 DS 本身的树形结构可以有一个 dsu on tree 的复杂度（即 &lt;span class=&#34;math inline&#34;&gt;\(O(nq\log^2 n)\)&lt;/span&gt;），但显然这个太糖了&lt;/p&gt;
&lt;p&gt;正常的做法是，注意到每个点的权值线段树结构相同，所以在 log 个线段树上同时维护，当作包含长度 log 的数组的结构体即可&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;同树状数组，要求信息有&lt;strong&gt;可减性&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;但由于外层的 DS 本质上舍弃了主席树 DAG 的结构&lt;/p&gt;
&lt;p&gt;导致不能直接简单用于树上问题，而是需要在 &lt;strong&gt;DFS 序&lt;/strong&gt;上作文章&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;实际上常数很大，超过 &lt;span class=&#34;math inline&#34;&gt;\(10^5\)&lt;/span&gt; 就不太能跑得动了&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;dynamic-rankings-k大数查询&#34;&gt;Dynamic Rankings / K大数查询&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P2617&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P2617&lt;/a&gt; / &lt;a href=&#34;https://www.luogu.com.cn/problem/P3332&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P3332&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;全局第 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 大就是普通的权值线段树上二分，抑或平衡树，抑或 01-Trie（三者等价）&lt;/li&gt;
&lt;li&gt;这里的权值线段树上二分，其实是矩形第二维限制的变体&lt;/li&gt;
&lt;li&gt;发现这里只需要简单地维护元素个数，是具有可减性的。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;三维偏序陌上花开&#34;&gt;三维偏序（陌上花开）&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P3810&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P3810&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;树状数组套权值线段树即可&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;二逼平衡树&#34;&gt;二逼平衡树&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://loj.ac/p/106&#34; class=&#34;uri&#34;&gt;https://loj.ac/p/106&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;和 k 大数差不多，都是权值线段树那些东西&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;网络管理&#34;&gt;网络管理&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P4175&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P4175&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;维护带修树上简单路径第 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 大。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;做树上差分即可转化为序列第 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 大。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;买宝石&#34;&gt;买宝石&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.becoder.com.cn/contest/6620/problem/4&#34; class=&#34;uri&#34;&gt;https://www.becoder.com.cn/contest/6620/problem/4&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定根为 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt; 的树，每个点 &lt;span class=&#34;math inline&#34;&gt;\(u\)&lt;/span&gt; 上有 &lt;span class=&#34;math inline&#34;&gt;\(k_u\)&lt;/span&gt; 个价钱为 &lt;span class=&#34;math inline&#34;&gt;\(w_u\)&lt;/span&gt; 的物品，可以在时间 &lt;span class=&#34;math inline&#34;&gt;\(t_u\)&lt;/span&gt; 及之后获得&lt;/p&gt;
&lt;p&gt;给定 &lt;span class=&#34;math inline&#34;&gt;\(Q\)&lt;/span&gt; 次询问，从问 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 出发到根的路径上所有在时刻 &lt;span class=&#34;math inline&#34;&gt;\(T\)&lt;/span&gt; 可以获得的物品全部拿出来排成一列，拥有 &lt;span class=&#34;math inline&#34;&gt;\(K\)&lt;/span&gt; 金钱时，按照价值从小到大购买，买到的最后一个物品价值。&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(n\le 10^5\)&lt;/span&gt;，价钱：&lt;span class=&#34;math inline&#34;&gt;\(10^{15}\)&lt;/span&gt;，时间：&lt;span class=&#34;math inline&#34;&gt;\(10^5\)&lt;/span&gt;，个数：&lt;span class=&#34;math inline&#34;&gt;\(10^5\)&lt;/span&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;信息自带一个有序的时间偏序维 &lt;span class=&#34;math inline&#34;&gt;\(T\)&lt;/span&gt; 且原生有序，所以不能整体二分，必须处理 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 偏序维和 &lt;span class=&#34;math inline&#34;&gt;\(w\)&lt;/span&gt; 二分维。&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;总的来说，就是维护了两个关键字，或者说一个矩形&lt;/li&gt;
&lt;li&gt;根据在 A，B 维需要做的操作选择，以及需要维护的信息类型，选择相应的数据结构&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;关于整体二分&#34;&gt;关于整体二分&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;考虑动态区间第 K 大这一类的问题，特征是 A 维『求和』，B 维&lt;strong&gt;二分&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;此时可以把对 B 维的二分提到外层一起进行，反过来对 A 维应用数据结构&lt;/li&gt;
&lt;li&gt;考虑到树套树常数过大，所以在能用整体二分的时候不推荐用树套树&lt;/li&gt;
&lt;/ul&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://xsc062.netlify.app/20251007/</guid>
            <title>杂题</title>
            <link>https://xsc062.netlify.app/20251007/</link>
            <category>DP</category>
            <category>树状数组</category>
            <category>倍增</category>
            <category>贪心</category>
            <pubDate>Tue, 07 Oct 2025 16:29:43 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;近期模拟赛&lt;/p&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;a.-考试&#34;&gt;A. 考试&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.becoder.com.cn/contest/6624/problem/1&#34; class=&#34;uri&#34;&gt;https://www.becoder.com.cn/contest/6624/problem/1&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(m\)&lt;/span&gt; 道题，分数是一个 &lt;span class=&#34;math inline&#34;&gt;\(m\)&lt;/span&gt; 的排列（初始未知），做对得满分，做错得 0 分&lt;/p&gt;
&lt;p&gt;给定 &lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt; 个人对于这 &lt;span class=&#34;math inline&#34;&gt;\(m\)&lt;/span&gt; 个题的过题情况矩阵，且第 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 个人有一个预期分数 &lt;span class=&#34;math inline&#34;&gt;\(x_i\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;求每到题的分数，使得每个人实际得分与期望的分差的绝对值之和最大。输出该排列。&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(n\le 10,m\le 10^4\)&lt;/span&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;绝对值是贪心一个很大的阻碍&lt;/li&gt;
&lt;li&gt;&lt;p&gt;一个典型的『钦定』型贪心，枚举每个人的绝对值是否取反，就可以得到每个题对应的系数。&lt;/p&gt;
&lt;p&gt;因为『就算错了也不会影响最优解』，所以是对的。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
int main() &amp;#123;
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
    std::freopen(&amp;quot;test.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;test.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    int T;
    for (std::cin &amp;gt;&amp;gt; T; T--; ) &amp;#123;
        int n, m;
        std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
        std::vector&amp;lt;int&amp;gt; s(n + 1);
        for (int i = 1; i &amp;lt;= n; ++i)
            std::cin &amp;gt;&amp;gt; s[i];
        std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; pos(n + 1);
        for (int i = 1; i &amp;lt;= n; ++i)
            for (int j = 1; j &amp;lt;= m; ++j) &amp;#123;
                char t;
                std::cin &amp;gt;&amp;gt; t;
                if (t == &amp;#39;1&amp;#39;)
                    pos[i].push_back(j);
            &amp;#125;
        auto res = 0ll;
        int siz = 1 &amp;lt;&amp;lt; n;
        std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; id(2 * n + 1);
        std::vector&amp;lt;int&amp;gt; cnt(m + 1), ans(m + 1), p(m + 1);
        for (int i = 0; i &amp;lt; siz; ++i) &amp;#123;
            std::fill(cnt.begin() + 1, cnt.end(), 0);
            for (int j = 0; j &amp;lt;= 2 * n; ++j)
                id[j].clear();
            for (int j = 1; j &amp;lt;= n; ++j)
                if ((i &amp;gt;&amp;gt; (j - 1)) &amp;amp; 1)
                    for (auto k : pos[j])
                        ++cnt[k];
                else
                    for (auto k : pos[j])
                        --cnt[k];
            for (int j = 1; j &amp;lt;= m; ++j)
                id[cnt[j] + n].push_back(j);
            for (int i = 2 * n, k = m; ~i; --i)
                for (auto j : id[i])
                    p[j] = k--;
            auto now = 0ll;
            for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
                int sum = 0;
                for (auto j : pos[i])
                    sum += p[j];
                now += std::abs(sum - s[i]);
            &amp;#125;
            if (now &amp;gt;= res)
                res = now, ans = p;
        &amp;#125;
        // std::cout &amp;lt;&amp;lt; res &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
        for (int i = 1; i &amp;lt;= m; ++i)
            std::cout &amp;lt;&amp;lt; ans[i] &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
        std::cout &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    &amp;#125;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;b.-围棋&#34;&gt;B. 围棋&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.becoder.com.cn/contest/6624/problem/2&#34; class=&#34;uri&#34;&gt;https://www.becoder.com.cn/contest/6624/problem/2&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定 &lt;span class=&#34;math inline&#34;&gt;\(n \times n\)&lt;/span&gt; 的棋盘，上面有黑棋、白棋和空地，定义白棋的『气』为四个方向空地的数量，若一个白棋四连通块中所有白棋的『气』都为 0，则认为这个白棋四连通块中的所有白棋是『死的』。&lt;/p&gt;
&lt;p&gt;现枚举每个棋子，并将其反转颜色，问『死的』白棋数量。操作是独立的。&lt;/p&gt;
&lt;p&gt;3s，&lt;span class=&#34;math inline&#34;&gt;\(n\le 10^3\)&lt;/span&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;分讨题，需要想清楚。首先需要一次 floodfill 完成染色，记录哪些连通块死了。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;若反转黑棋：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;若黑棋自己有气，或和黑棋相连的白棋四连通块有气，那么黑棋自己，以及所有和黑棋相连的白棋四连通块都是活的。&lt;/p&gt;
&lt;p&gt;此时需要找到所有和黑棋相连的，且死了的白棋四连通块的大小，答案需要减去之。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;否则，黑棋自身贡献 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt; 的答案。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;若反转白棋：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;若白棋本身是死的：答案 &lt;span class=&#34;math inline&#34;&gt;\(-1\)&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;否则，需要考虑有多少个原本是活的白棋此时与有气的白棋不连通，这种情况发生当且仅当有气的白棋是被反转的白棋自身，或者被反转的白棋是割点。&lt;/p&gt;
&lt;p&gt;很奇妙的一个想法是建立超级源点，向所有空地连边，再建圆方树，这样这个点的所有儿子就是待求。圆方树并不需要显式地建出来。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;代码：不会&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;c.-相互抵消&#34;&gt;C. 相互抵消&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.becoder.com.cn/contest/6624/problem/3&#34; class=&#34;uri&#34;&gt;https://www.becoder.com.cn/contest/6624/problem/3&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定 &lt;span class=&#34;math inline&#34;&gt;\(a_{1\sim n}\)&lt;/span&gt;，维护 &lt;span class=&#34;math inline&#34;&gt;\(m\)&lt;/span&gt; 次操作：&lt;/p&gt;
&lt;ol type=&#34;1&#34;&gt;
&lt;li&gt;区间加。&lt;/li&gt;
&lt;li&gt;给定 &lt;span class=&#34;math inline&#34;&gt;\(l,r\)&lt;/span&gt;，查询 &lt;span class=&#34;math inline&#34;&gt;\(\left(\sum\limits_{i=l}^r\sum\limits_{j=i}^r ((\sum_{k=i}^j a_k)^2 + (r-l+2)\times(j-i)\times a_i\times a_j)\right) \bmod 998244353\)&lt;/span&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(n,m\le 5\times 10^5\)&lt;/span&gt;，强制在线。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;题目名字是真在降低难度吧，强制在线就排除离线历史和了；猜测询问所求可以化成一个比较简单的东西。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;推一下：&lt;/p&gt;
&lt;p&gt;（省略）&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
=-\left(\sum_{i=l}^r i\cdot a_i\right)^2 + (1-l)(r+1)\left(\sum_{i=l}^r a_i\right)^2+(l+r)\left(\sum_{i=l}^r i\cdot a_i\right)\left(\sum_{i=l}^r a_i\right)
\]&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;故线段树维护 &lt;span class=&#34;math inline&#34;&gt;\(\sum a_i\)&lt;/span&gt; 和 &lt;span class=&#34;math inline&#34;&gt;\(\sum i\cdot a_i\)&lt;/span&gt; 即可。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;/20251010/#excercise&#34;&gt;实际上可以用树状数组维护&lt;/a&gt;。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;p&gt;喜提最优解，不得不说 bit 的速度优势还是很明显的。&lt;/p&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int mod = 998244353; 
const int inv2 = (mod + 1) &amp;gt;&amp;gt; 1;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
    std::freopen(&amp;quot;offset.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;offset.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#else
    std::freopen(&amp;quot;./test/20251008/offset/ex_offset5.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int T, n, q;
    std::cin &amp;gt;&amp;gt; T &amp;gt;&amp;gt; n &amp;gt;&amp;gt; q;
    std::vector&amp;lt;long long&amp;gt; bit(n + 1), bit1(n + 1), bit2(n + 1);
    auto lowbit = [&amp;amp;](int x) &amp;#123;
        return x &amp;amp; -x;
    &amp;#125;;
    auto add = [&amp;amp;](long long x, long long v) &amp;#123;
        auto v1 = x * v % mod, v2 = x * x % mod * v % mod;
        for (; x &amp;lt;= n; x += lowbit(x)) &amp;#123;
            (bit[x] += v) %= mod;
            (bit1[x] += v1) %= mod;
            (bit2[x] += v2) %= mod;
        &amp;#125;
        return;
    &amp;#125;;
    auto ask = [&amp;amp;](long long x) &amp;#123;
        auto res = 0ll, res1 = 0ll, res2 = 0ll;
        for (int i = x; i; i -= lowbit(i))
            (res += bit[i]) %= mod, (res1 += bit1[i]) %= mod, (res2 += bit2[i]) %= mod;
        return std::make_pair(((x + 1) * res + mod - res1) % mod, (x * (x + 1) % mod * res % mod + res1 + mod - res2) * inv2 % mod);
    &amp;#125;;
    for (int i = 1, x; i &amp;lt;= n; ++i)
        std::cin &amp;gt;&amp;gt; x, add(i, x), add(i + 1, mod - x);
    for (int op; q--; ) &amp;#123;
        static auto la = 0ll;
        std::cin &amp;gt;&amp;gt; op;
        if (op == 1) &amp;#123;
            int l, r, d;
            std::cin &amp;gt;&amp;gt; l &amp;gt;&amp;gt; r &amp;gt;&amp;gt; d;
            if (T == 1)
                l ^= la, r ^= la, d ^= la;
            add(l, d), add(r + 1, mod - d);
        &amp;#125;
        else &amp;#123;
            long long l, r;
            std::cin &amp;gt;&amp;gt; l &amp;gt;&amp;gt; r;
            if (T == 1)
                l ^= la, r ^= la;
            auto t1 = ask(r), t2 = ask(l - 1);
            auto res1 = t1.first + mod - t2.first, res2 = t1.second + mod - t2.second;
            la = (mod - res2 * res2 % mod + mod - (l - 1) * (r + 1) % mod * res1 % mod * res1 % mod + (l + r) * res1 % mod * res2 % mod) % mod;
            std::cout &amp;lt;&amp;lt; la &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
        &amp;#125;
    &amp;#125;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;a.-happylovelyeveryday&#34;&gt;A. Happy·Lovely·Everyday!&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.becoder.com.cn/contest/6639/problem/1&#34; class=&#34;uri&#34;&gt;https://www.becoder.com.cn/contest/6639/problem/1&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定一个长为 &lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt; 的 01 序列，可以执行任意次（可以为 &lt;span class=&#34;math inline&#34;&gt;\(0\)&lt;/span&gt;）『把相邻两个数合并为其异或值』的操作，问最终能得到的本质不同的序列个数。&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(n\le 2\times 10^6\)&lt;/span&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;对于一个最终序列，如果认为它是由某个存活元素『吞并』它左侧的连续死亡元素得到的，会发现最终序列中，此处的前缀异或值就是原序列的前缀异或值。&lt;/li&gt;
&lt;li&gt;经典 trick：前缀和可以唯一对应原数组。所以『最终本质不同序列』会和『包含第 &lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt; 个元素的，原序列前缀异或和的本质不同子序列』形成双射。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;统计包含第 &lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt; 个元素的，原序列前缀异或和的本质不同子序列即可。复杂度 &lt;span class=&#34;math inline&#34;&gt;\(O(n)\)&lt;/span&gt;。&lt;/p&gt;
&lt;details&gt;
&lt;p&gt;&lt;summary&gt;How to 本质不同子序列？&lt;/summary&gt;&lt;/p&gt;
&lt;p&gt;令 &lt;span class=&#34;math inline&#34;&gt;\(f_i\)&lt;/span&gt; 表示 DP 到 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt;，且强制选 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 的本质不同子序列数量，记 &lt;span class=&#34;math inline&#34;&gt;\(pre_i\)&lt;/span&gt; 为 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 的前驱（没有则为 &lt;span class=&#34;math inline&#34;&gt;\(0\)&lt;/span&gt;）。令 &lt;span class=&#34;math inline&#34;&gt;\(f_0=1\)&lt;/span&gt;，那么：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
f_i\gets \sum\limits_{j=pre_i}^{i-1} f_{j}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;或，令 &lt;span class=&#34;math inline&#34;&gt;\(f_i\)&lt;/span&gt; 表示 DP 到 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 时（不强制选 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt;）本质不同子序列数量，记 &lt;span class=&#34;math inline&#34;&gt;\(pre_i\)&lt;/span&gt; 为 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 的前驱（没有则为 &lt;span class=&#34;math inline&#34;&gt;\(0\)&lt;/span&gt;）。令 &lt;span class=&#34;math inline&#34;&gt;\(f_0=0\)&lt;/span&gt;，那么：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
f_i=\begin{cases}
2\cdot f_{i-1}+1&amp;amp;pre_i= 0\\
2\cdot f_{i-1}-f_{pre_i-1}&amp;amp;\text{otherwise}
\end{cases}
\]&lt;/span&gt;&lt;/p&gt;
&lt;/details&gt;
&lt;details&gt;
&lt;p&gt;&lt;summary&gt;How to 强制选第 &lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt; 个元素的本质不同子序列？&lt;/summary&gt;&lt;/p&gt;
&lt;p&gt;令 &lt;span class=&#34;math inline&#34;&gt;\(f_i\)&lt;/span&gt; 表示 DP 到 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt;，且强制选 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 的本质不同子序列数量，则答案为：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
\sum\limits_{a_i=a_n} f_i
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;或，令 &lt;span class=&#34;math inline&#34;&gt;\(f_i\)&lt;/span&gt; 表示 DP 到 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt;，且不强制选 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 的本质不同子序列数量，则答案为：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
\sum\limits_{a_i=a_n}\begin{cases}
f_{i-1}+1&amp;amp;pre_i= 0\\
f_{i-1}-f_{pre_i-1}&amp;amp;\text{otherwise}
\end{cases}
\]&lt;/span&gt;&lt;/p&gt;
&lt;/details&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int mod = 998244353;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
    std::freopen(&amp;quot;a.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;a.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#else
    std::freopen(&amp;quot;./test/20251014/a/a1.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int T;
    for (std::cin &amp;gt;&amp;gt; T; T--; ) &amp;#123;
        std::string s;
        std::cin &amp;gt;&amp;gt; s;
        int n = (int)s.length();
        s = &amp;quot;#&amp;quot; + s;
        std::vector&amp;lt;int&amp;gt; a(n + 1);
        for (int i = 1; i &amp;lt;= n; ++i)
            a[i] = a[i - 1] ^ (s[i] - &amp;#39;0&amp;#39;);
        auto res = 0ll;
        std::vector&amp;lt;long long&amp;gt; f(n + 1), la(2);
        for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
            if (la[a[i]])
                f[i] = (2 * f[i - 1] + mod - f[la[a[i]] - 1]) % mod;
            else
                f[i] = (2 * f[i - 1] + 1) % mod;
            if (a[i] == a[n]) &amp;#123;
                if (la[a[i]])
                    res += (f[i - 1] + mod - f[la[a[i]] - 1]) % mod;
                else
                    res += f[i - 1] + 1;
            &amp;#125;
            la[a[i]] = i;
        &amp;#125;
        std::cout &amp;lt;&amp;lt; res % mod &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    &amp;#125;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;b.-敬启致那时的我&#34;&gt;B. 敬启，致那时的我&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.becoder.com.cn/contest/6639/problem/2&#34; class=&#34;uri&#34;&gt;https://www.becoder.com.cn/contest/6639/problem/2&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;定义 &lt;span class=&#34;math inline&#34;&gt;\(f_0=f_1=1,f_i=f_{i-1}+f_{i-2}\)&lt;/span&gt;，给定 &lt;span class=&#34;math inline&#34;&gt;\(n,k\)&lt;/span&gt;，求：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
\left(\sum_{i=0}^n f_{i}\cdot [\text{popcount}(i)=k]\right)\bmod 10^9+7
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(n\le 2^{2000},0\le k\le \log_2(n)\)&lt;/span&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;考虑数位 DP，那么需要能够由 &lt;code&gt;...xxx&lt;/code&gt; 向 &lt;code&gt;...0xxx&lt;/code&gt; 和 &lt;code&gt;...1xxx&lt;/code&gt; 转移。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;显然只关心向 &lt;code&gt;...1xxx&lt;/code&gt; 的转移，那么需要再转移 &lt;span class=&#34;math inline&#34;&gt;\(2^{?}\)&lt;/span&gt; 次，记录转移矩阵的 &lt;span class=&#34;math inline&#34;&gt;\(2^{?}\)&lt;/span&gt; 次方即可。&lt;/p&gt;
&lt;p&gt;这一步也可以不用矩阵，而是用斐波那契 &lt;span class=&#34;math inline&#34;&gt;\(f(ab)=...\)&lt;/span&gt; 的性质，但显然二者是等价的，无甚必要&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;根据数位 DP 的实现方式，常数上顺序结构肯定是会吊打递归的。然而并不惯写顺序结构的数位 DP，whatever.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int mod = 1e9 + 7;
struct matrix &amp;#123;
    long long a[2][2];
    matrix() &amp;#123;
        a[0][0] = a[0][1] = a[1][0] = a[1][1] = 0ll;
        return;
    &amp;#125;
    long long* operator[] (const int q) &amp;#123;
        return a[q];
    &amp;#125;
    matrix operator* (matrix &amp;amp;q) const &amp;#123;
        matrix res;
        res[0][0] = (a[0][0] * q[0][0] + a[0][1] * q[1][0]) % mod;
        res[0][1] = (a[0][0] * q[0][1] + a[0][1] * q[1][1]) % mod;
        res[1][0] = (a[1][0] * q[0][0] + a[1][1] * q[1][0]) % mod;
        res[1][1] = (a[1][0] * q[0][1] + a[1][1] * q[1][1]) % mod;
        return res;
    &amp;#125;
    matrix&amp;amp; operator+= (matrix q) &amp;#123;
        if ((a[0][0] += q[0][0]) &amp;gt;= mod) a[0][0] -= mod;
        if ((a[0][1] += q[0][1]) &amp;gt;= mod) a[0][1] -= mod;
        if ((a[1][0] += q[1][0]) &amp;gt;= mod) a[1][0] -= mod;
        if ((a[1][1] += q[1][1]) &amp;gt;= mod) a[1][1] -= mod;
        return *this;
    &amp;#125;
&amp;#125;;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
    std::freopen(&amp;quot;b.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;b.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#else
    std::freopen(&amp;quot;./test/20251014/b/b4.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, k;
    std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; k;
    std::vector&amp;lt;int&amp;gt; up(n);
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        char t;
        std::cin &amp;gt;&amp;gt; t, up[n - i] = t - &amp;#39;0&amp;#39;;
    &amp;#125;
    matrix init, zmat;
    init[0][0] = init[0][1] = 1ll;
    std::vector&amp;lt;matrix&amp;gt; mat(n);
    mat[0][0][1] = mat[0][1][0] = mat[0][1][1] = 1ll;
    for (int i = 1; i &amp;lt; n; ++i)
        mat[i] = mat[i - 1] * mat[i - 1];
    std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; tag(n, std::vector&amp;lt;int&amp;gt; (k + 1));
    std::vector&amp;lt;std::vector&amp;lt;matrix&amp;gt; &amp;gt; f(n, std::vector&amp;lt;matrix&amp;gt; (k + 1));
    std::function&amp;lt;matrix(int, int, int)&amp;gt; DFS = [&amp;amp;](int x, int k, int fl) &amp;#123;
        if (x == -1) &amp;#123;
            if (k == 0)
                return init;
            return zmat;
        &amp;#125;
        if (!fl &amp;amp;&amp;amp; tag[x][k])
            return f[x][k];
        matrix res = DFS(x - 1, k, fl &amp;amp;&amp;amp; !up[x]);
        if (k &amp;amp;&amp;amp; (!fl || up[x]))
            res += DFS(x - 1, k - 1, fl) * mat[x];
        if (!fl)
            tag[x][k] = 1, f[x][k] = res;
        return res;
    &amp;#125;;
    std::cout &amp;lt;&amp;lt; DFS(n - 1, k, 1)[0][0] &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;c.-lead-to-shine-more&#34;&gt;C. Lead to shine more&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.becoder.com.cn/contest/6639/problem/3&#34; class=&#34;uri&#34;&gt;https://www.becoder.com.cn/contest/6639/problem/3&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;第 &lt;span class=&#34;math inline&#34;&gt;\(0\)&lt;/span&gt; 次操作时变量 &lt;span class=&#34;math inline&#34;&gt;\(x=1\)&lt;/span&gt;，此后每次操作使 &lt;span class=&#34;math inline&#34;&gt;\(x\gets x+\text{popcount}(x)\)&lt;/span&gt;，给定 &lt;span class=&#34;math inline&#34;&gt;\(m\)&lt;/span&gt; 次询问：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;给定 &lt;span class=&#34;math inline&#34;&gt;\(x&amp;#39;\)&lt;/span&gt;，问 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 在第几次操作后变为 &lt;span class=&#34;math inline&#34;&gt;\(x&amp;#39;\)&lt;/span&gt;，或报告 &lt;span class=&#34;math inline&#34;&gt;\(x&amp;#39;\)&lt;/span&gt; 不会被经过。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(m\le 10^5,x&amp;#39;\le 10^{18}\)&lt;/span&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;一个朴素的想法是分高低位，则因为每次操作带来的变化量不超过 60，远远低于低位的 &lt;span class=&#34;math inline&#34;&gt;\(2^30\)&lt;/span&gt;，所以一次操作至多给高位带来 1 的变化量。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;高位对整体的贡献只取决于其 popcount，所以可以枚举高位 1 的数量，再枚举初始值，找到第一次让高位变化花的次数。&lt;/p&gt;
&lt;p&gt;初始值的可能值有 &lt;span class=&#34;math inline&#34;&gt;\(60\)&lt;/span&gt; 个，而外层循环有 &lt;span class=&#34;math inline&#34;&gt;\(30\)&lt;/span&gt; 次，内层循环大概是 &lt;span class=&#34;math inline&#34;&gt;\(\dfrac {2^{30}}{60}\)&lt;/span&gt; 的，总之无法通过。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;题解说方法是对上面的拓展。理解不能。出发点大概是考虑到让第 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 位变化相当于让 &lt;span class=&#34;math inline&#34;&gt;\(i+1\)&lt;/span&gt; 位变化两次，所以会有一个递推的关系。&lt;/p&gt;
&lt;p&gt;令 &lt;span class=&#34;math inline&#34;&gt;\(f_{i, s, d}\)&lt;/span&gt; 为前 &lt;span class=&#34;math inline&#34;&gt;\(i-1\)&lt;/span&gt; 位的 popcount 为 &lt;span class=&#34;math inline&#34;&gt;\(d\)&lt;/span&gt;，初始值为 &lt;span class=&#34;math inline&#34;&gt;\(s\)&lt;/span&gt;，让 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 位变化一次的操作次数；&lt;span class=&#34;math inline&#34;&gt;\(g_{i,s,d}\)&lt;/span&gt; 为上述变化后 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 的值。记 &lt;span class=&#34;math inline&#34;&gt;\(pos=g_{i-1,s,d}\)&lt;/span&gt;，那么有：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
g_{i,pos,d}=g_{i-1,pos,d+1}\\
f_{i,pos,d}=f_{i-1,s,d}+f_{i-1,pos,d+1}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其实是一个类似&lt;strong&gt;倍增&lt;/strong&gt;的结构。但恕我实在无法解释怎么想到的。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;显然这个式子在 &lt;span class=&#34;math inline&#34;&gt;\(i\le 5\)&lt;/span&gt; 时是有问题的，这部分我们暴力跑即可。忽略这一部分常数，预处理总复杂度 &lt;span class=&#34;math inline&#34;&gt;\(O(\log^3 n)\)&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;考虑查询，按照类似数位 DP 的方法从高位到低位模拟进位过程即可。复杂度 &lt;span class=&#34;math inline&#34;&gt;\(O(\log n)\)&lt;/span&gt;。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
    std::freopen(&amp;quot;c.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;c.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#else
    std::freopen(&amp;quot;./test/20251014/c/c1.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    using arr = std::vector&amp;lt;long long&amp;gt;;
    using brr = std::vector&amp;lt;arr&amp;gt;;
    using crr = std::vector&amp;lt;brr&amp;gt;;
    crr f(61, brr(256, arr(61))), g(61, brr(256, arr(61)));
    for (int s = 0; s &amp;lt; 256; ++s)
        for (int d = 0; d &amp;lt;= 60; ++d)
            if (d || s) &amp;#123;
                int x = s, cnt = 0;
                for (; x &amp;lt; 256; x += __builtin_popcount(x) + d, ++cnt);
                f[8][s][d] = cnt, g[8][s][d] = x &amp;amp; 255;
            &amp;#125;
    for (int i = 9; i &amp;lt;= 60; ++i)
        for (int s = 0; s &amp;lt; 256; ++s)
            for (int d = 0; d &amp;lt; 60; ++d) &amp;#123;
                int pos = g[i - 1][s][d];
                g[i][s][d] = g[i - 1][pos][d + 1];
                f[i][s][d] = f[i - 1][s][d] + f[i - 1][pos][d + 1];
            &amp;#125;
    int m;
    std::cin &amp;gt;&amp;gt; m;
    for (long long x; m--; ) &amp;#123;
        std::cin &amp;gt;&amp;gt; x;
        auto pos = 1ll, cnt = 0ll, tot = 0ll;
        for (int i = 60; i &amp;gt;= 8; --i)
            if ((x &amp;gt;&amp;gt; i) &amp;amp; 1) &amp;#123;
                cnt += f[i][pos][tot];
                pos = g[i][pos][tot++];
            &amp;#125;
        for (; pos &amp;lt; (x &amp;amp; 255); pos += __builtin_popcountll(pos) + tot, ++cnt);
        // std::cout &amp;lt;&amp;lt; pos &amp;lt;&amp;lt; &amp;#39; &amp;#39; &amp;lt;&amp;lt; cnt &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
        if (pos == (x &amp;amp; 255))
            std::cout &amp;lt;&amp;lt; cnt &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
        else
            std::cout &amp;lt;&amp;lt; -1 &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    &amp;#125;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;c.-query-on-a-tree-17&#34;&gt;C. Query On A Tree 17&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://codeforces.com/gym/102759/problem/I&#34; class=&#34;uri&#34;&gt;https://codeforces.com/gym/102759/problem/I&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定一个以 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt; 为根的树，点权初始为全 &lt;span class=&#34;math inline&#34;&gt;\(0\)&lt;/span&gt;。维护 &lt;span class=&#34;math inline&#34;&gt;\(m\)&lt;/span&gt; 次修改：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;1 u&lt;/code&gt;，表示把 &lt;span class=&#34;math inline&#34;&gt;\(u\)&lt;/span&gt; 子树内的点权加一。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;2 u v&lt;/code&gt;，表示把 &lt;span class=&#34;math inline&#34;&gt;\(u,v\)&lt;/span&gt; 简单路径上的点权加一。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;每次修改后，输出树深度最小的带权重心。&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(n,m\le 10^5\)&lt;/span&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;考虑链上的问题，考虑一点小奥做法，把所有点重复其出现次数次，从左到右排列，发现答案在中位数上。&lt;/p&gt;
&lt;p&gt;（据组题人所言），这是用来提示正解的。事实上，这是一个和带权重心有关的 trick：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;若一个点 &lt;span class=&#34;math inline&#34;&gt;\(u\)&lt;/span&gt; 是&lt;strong&gt;深度最小的&lt;/strong&gt;带权重心，则其子树权值和必须&lt;strong&gt;严格大于&lt;/strong&gt;总权值的一半。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;证明显然，但结论不显然。Whatever.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;由这一点会得到，（参照链上的做法），把点重复点权次，并按 dfn 排成一行，取中位数，那么取到的一定在&lt;strong&gt;深度最小的&lt;/strong&gt;重心子树内，（这就是组题人说的提示正解）。&lt;/p&gt;
&lt;p&gt;这一点反而没那么显然，推导过程是，&lt;strong&gt;深度最小的&lt;/strong&gt;重心的子树占了大于一半，而其 dfn 又是连续的，（类似滑动窗口），故总能够到中位数。&lt;/p&gt;
&lt;p&gt;考虑非深度最小的重心，此时就从&lt;strong&gt;严格大于&lt;/strong&gt;变为&lt;strong&gt;不严格大于&lt;/strong&gt;，导致没有办法很好地精准找到，需要从中位数左右偏移一位，显然是很丑陋的。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;因此可以考虑线段树上二分找到中位数（容易发现线段树的 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 轴本来就是 dfn），然后从这个中位数往上跳，一直跳到满足『子树权值和严格大于总权值一半』的点，就是最浅的重心。&lt;/p&gt;
&lt;p&gt;这一点采用倍增即可。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://xsc062.netlify.app/20251005/</guid>
            <title>贪心 Problem Set</title>
            <link>https://xsc062.netlify.app/20251005/</link>
            <category>贪心</category>
            <pubDate>Sun, 05 Oct 2025 08:17:32 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;不会做的简单题&lt;/p&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;贪心的『策略』是一种很模糊的东西&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果能找到一种清晰的操作流程，自然是很好的，但如果要从数学角度进行推导，可能有些困难&lt;/li&gt;
&lt;li&gt;否则，如果没办法找到一种确定的操作方式，需要确定答案的上 / 下界是可以取到的&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;饥饿的狐狸&#34;&gt;饥饿的狐狸&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P4801&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P4801&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;第一问，发现不喝水一定不劣，故大小顺序吃饼干即可。&lt;/p&gt;
&lt;p&gt;具体地，若 &lt;span class=&#34;math inline&#34;&gt;\(W&amp;lt;a_1\)&lt;/span&gt;，把 &lt;span class=&#34;math inline&#34;&gt;\(W\)&lt;/span&gt; 视作 &lt;span class=&#34;math inline&#34;&gt;\(a_0\)&lt;/span&gt; 即可；若 &lt;span class=&#34;math inline&#34;&gt;\(W&amp;gt;a_n\)&lt;/span&gt;，把 &lt;span class=&#34;math inline&#34;&gt;\(W\)&lt;/span&gt; 视作 &lt;span class=&#34;math inline&#34;&gt;\(a_{n+1}\)&lt;/span&gt; 即可；&lt;/p&gt;
&lt;p&gt;若 &lt;span class=&#34;math inline&#34;&gt;\(a_1&amp;lt;W&amp;lt;a_n\)&lt;/span&gt;，那么由于喝水是没有代价的，可以从 &lt;span class=&#34;math inline&#34;&gt;\(W\)&lt;/span&gt; 一直吃到 &lt;span class=&#34;math inline&#34;&gt;\(a_1\)&lt;/span&gt;，再喝水，再从 &lt;span class=&#34;math inline&#34;&gt;\(W\)&lt;/span&gt; 一直吃到 &lt;span class=&#34;math inline&#34;&gt;\(a_n\)&lt;/span&gt;。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;第二问，我们希望 &lt;span class=&#34;math inline&#34;&gt;\(a_i-a_j\)&lt;/span&gt; 这个代价中的 &lt;span class=&#34;math inline&#34;&gt;\(a_i\)&lt;/span&gt; 尽可能大，&lt;span class=&#34;math inline&#34;&gt;\(a_j\)&lt;/span&gt; 尽可能小。故尝试让前一半当 &lt;span class=&#34;math inline&#34;&gt;\(a_j\)&lt;/span&gt;，后一半当 &lt;span class=&#34;math inline&#34;&gt;\(a_i\)&lt;/span&gt; 即可，那么顺序其实无所谓，只是需要讨论一下和第一次 &lt;span class=&#34;math inline&#34;&gt;\(W\)&lt;/span&gt; 接壤的是 &lt;span class=&#34;math inline&#34;&gt;\(a_1\)&lt;/span&gt; 还是 &lt;span class=&#34;math inline&#34;&gt;\(a_n\)&lt;/span&gt;。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n;
    long long w;
    std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; w;
    std::vector&amp;lt;long long&amp;gt; a(n + 1);
    for (int i = 1; i &amp;lt;= n; ++i)
        std::cin &amp;gt;&amp;gt; a[i];
    std::sort(a.begin() + 1, a.end());
    std::cout &amp;lt;&amp;lt; std::max(w - a[1], 0ll) + std::max(a[n] - w, 0ll) &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
    auto calc = [&amp;amp;](int op) &amp;#123;
        long long res = 0ll, now = w;
        for (int i = 1, l = 1, r = n; i &amp;lt;= n; ++i)
            if (i % 2 == op)
                res += std::max(std::abs(a[l] - now), std::abs(a[l] - w)), now = a[l++];
            else
                res += std::max(std::abs(a[r] - now), std::abs(a[r] - w)), now = a[r--];
        return res;
    &amp;#125;;
    std::cout &amp;lt;&amp;lt; std::max(calc(0), calc(1)) &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;sam-toy-cars&#34;&gt;SAM-Toy Cars&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P3419&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P3419&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;有一个大概的感受是每次丢弃『下次出现时间』最晚的一个。&lt;/li&gt;
&lt;li&gt;tip：玩具在地上的时候不会更新队列中的 nex。需要特别处理。&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, k, p;
    std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; k &amp;gt;&amp;gt; p;
    std::vector&amp;lt;int&amp;gt; a(p + 1);
    for (int i = 1; i &amp;lt;= p; ++i)
        std::cin &amp;gt;&amp;gt; a[i];
    std::vector&amp;lt;int&amp;gt; nex(p + 1), la(n + 1, p + 1);
    for (int i = p; i; --i)
        nex[i] = la[a[i]], la[a[i]] = i;
    std::priority_queue&amp;lt;std::pair&amp;lt;int, int&amp;gt; &amp;gt; q;
    std::vector&amp;lt;int&amp;gt; inq(n + 1);
    int cnt = 0;
    for (int i = 1; i &amp;lt;= p; ++i)
        if (!inq[a[i]]) &amp;#123;
            if ((int)q.size() == k) &amp;#123;
                auto [nex, v] = q.top();
                q.pop();
                inq[v] = 0;
            &amp;#125;
            ++cnt, q.emplace(nex[i], a[i]);
            inq[a[i]] = 1;
        &amp;#125;
        else
            q.emplace(nex[i], a[i]), ++k;
    std::cout &amp;lt;&amp;lt; cnt &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;sports-festival&#34;&gt;Sports Festival&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/AT_agc018_b&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/AT_agc018_b&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;会有一个显然的二分做法&lt;/li&gt;
&lt;li&gt;其实可以不用二分，每次删最大的，每次更新答案&lt;/li&gt;
&lt;li&gt;用带一点反证的思路是好证的&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, m;
    std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
    std::vector&amp;lt;std::queue&amp;lt;int&amp;gt; &amp;gt; a(n + 1);
    std::vector&amp;lt;int&amp;gt; del(m + 1), cnt(m + 1);
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        for (int j = 1, x; j &amp;lt;= m; ++j)
            std::cin &amp;gt;&amp;gt; x, a[i].push(x);
        ++cnt[a[i].front()];
    &amp;#125;
    int res = n + 1;
    for (int i = 1; i &amp;lt;= m; ++i) &amp;#123;
        int mx = 0, id = 0;
        for (int i = 1; i &amp;lt;= m; ++i)
            if (cnt[i] &amp;gt; mx)
                mx = cnt[i], id = i;
        res = std::min(res, mx);
        if (i == m)
            break;
        del[id] = 1;
        for (int j = 1; j &amp;lt;= n; ++j) &amp;#123;
            --cnt[a[j].front()];
            for (; del[a[j].front()]; a[j].pop());
            ++cnt[a[j].front()];
        &amp;#125;
    &amp;#125;
    std::cout &amp;lt;&amp;lt; res &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;linguistics&#34;&gt;Linguistics&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/CF1685B&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/CF1685B&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;找到每一段极长交错段，把 &lt;code&gt;AB&lt;/code&gt; 和 &lt;code&gt;BA&lt;/code&gt; ；处理掉&lt;/li&gt;
&lt;li&gt;发现 ABABA 和 BABAB 对于 &lt;code&gt;AB&lt;/code&gt; 和 &lt;code&gt;BA&lt;/code&gt; 是等价的，考虑 ABABAB 和 BABABA。发现后二者要么匹配 AB / BA，要么删去首尾后转化为另一者。但这样就会浪费掉一个消去 &lt;code&gt;AB&lt;/code&gt; 或 &lt;code&gt;BA&lt;/code&gt; 的机会。&lt;/li&gt;
&lt;li&gt;故优先对后二者匹配 AB / BA，实在有多余再删头尾。&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int T;
    for (std::cin &amp;gt;&amp;gt; T; T--; ) &amp;#123;
        int A, B, AB, BA;
        std::string a;
        std::cin &amp;gt;&amp;gt; A &amp;gt;&amp;gt; B &amp;gt;&amp;gt; AB &amp;gt;&amp;gt; BA &amp;gt;&amp;gt; a;
        int n = (int)a.length();
        a = &amp;quot;#&amp;quot; + a;
        char l = a[1];
        int len = 0;
        std::vector&amp;lt;int&amp;gt; ab, ba, c;
        for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
            if (i == 1 || a[i] != a[i - 1])
                ++len;
            if (i == n || a[i] == a[i - 1]) &amp;#123;
                if (len != 1) &amp;#123;
                    // fprintf(stderr, &amp;quot;#1 len = %d, l = %c \n&amp;quot;, len, l);
                    if (l == &amp;#39;A&amp;#39; &amp;amp;&amp;amp; a[i] == &amp;#39;B&amp;#39;)
                        ab.push_back(len);
                    else if (l == &amp;#39;A&amp;#39;) &amp;#123;
                        if (!A)
                            goto nosol;
                        else
                            --A, c.push_back(len - 1);
                    &amp;#125;
                    else if (a[i] == &amp;#39;A&amp;#39;)
                        ba.push_back(len);
                    else if (!B)
                        goto nosol;
                    else
                        --B, c.push_back(len - 1);
                &amp;#125;
                else &amp;#123;
                    // fprintf(stderr, &amp;quot;#2 len = %d, l = %c \n&amp;quot;, 1, l);
                    if (l == &amp;#39;A&amp;#39;) &amp;#123;
                        if (!A)
                            goto nosol;
                        --A;
                    &amp;#125;
                    else &amp;#123;
                        if (!B)
                            goto nosol;
                        --B;
                    &amp;#125;
                &amp;#125;
                if (i == n &amp;amp;&amp;amp; a[i] == a[i - 1]) &amp;#123;
                    // fprintf(stderr, &amp;quot;#3 len = %d, l = %c \n&amp;quot;, 1, a[i]);
                    if (a[i] == &amp;#39;A&amp;#39;) &amp;#123;
                        if (!A)
                            goto nosol;
                        --A;
                    &amp;#125;
                    else &amp;#123;
                        if (!B)
                            goto nosol;
                        --B;
                    &amp;#125;
                &amp;#125;
                len = 1, l = a[i];
            &amp;#125;
        &amp;#125;
        std::sort(ab.begin(), ab.end(), std::greater&amp;lt;int&amp;gt; ());
        std::sort(ba.begin(), ba.end(), std::greater&amp;lt;int&amp;gt; ());
        for (; !ab.empty() &amp;amp;&amp;amp; AB; ) &amp;#123;
            int x = std::min(AB, ab.back() / 2);
            AB -= x, ab.back() -= x * 2;
            if (!ab.back())
                ab.pop_back();
        &amp;#125;
        for (; !ba.empty() &amp;amp;&amp;amp; BA; ) &amp;#123;
            int x = std::min(BA, ba.back() / 2);
            BA -= x, ba.back() -= x * 2;
            if (!ba.back())
                ba.pop_back();
        &amp;#125;
        // fprintf(stderr, &amp;quot;AB = %d, BA = %d, A = %d, B = %d \n&amp;quot;, AB, BA, A, B);
        for (; !ab.empty() &amp;amp;&amp;amp; BA; ) &amp;#123;
            if (!A || !B)
                goto nosol;
            ab.back() -= 2, --A, --B;
            int x = std::min(BA, ab.back() / 2);
            BA -= x, ab.back() -= x * 2;
            if (!ab.back())
                ab.pop_back();
        &amp;#125;
        for (; !ab.empty(); ) &amp;#123;
            A -= ab.back() / 2, B -= ab.back() / 2;
            ab.pop_back();
        &amp;#125;
        if (A &amp;lt; 0 || B &amp;lt; 0)
            goto nosol;
        for (; !ba.empty() &amp;amp;&amp;amp; AB; ) &amp;#123;
            if (!A || !B)
                goto nosol;
            ba.back() -= 2, --A, --B;
            int x = std::min(AB, ba.back() / 2);
            AB -= x, ba.back() -= x * 2;
            if (!ba.back())
                ba.pop_back();
        &amp;#125;
        for (; !ba.empty(); ) &amp;#123;
            A -= ba.back() / 2, B -= ba.back() / 2;
            ba.pop_back();
        &amp;#125;
        if (A &amp;lt; 0 || B &amp;lt; 0)
            goto nosol;
        for (; !c.empty() &amp;amp;&amp;amp; AB; ) &amp;#123;
            int x = std::min(AB, c.back() / 2);
            AB -= x, c.back() -= x * 2;
            if (!c.back())
                c.pop_back();
        &amp;#125;
        for (; !c.empty() &amp;amp;&amp;amp; BA; ) &amp;#123;
            int x = std::min(BA, c.back() / 2);
            BA -= x, c.back() -= x * 2;
            if (!c.back())
                c.pop_back();
        &amp;#125;
        if (AB || BA)
            goto nosol;
        for (; !c.empty(); ) &amp;#123;
            A -= c.back() / 2, B -= c.back() / 2;
            c.pop_back();
        &amp;#125;
        if (A || B)
            goto nosol;
        std::cout &amp;lt;&amp;lt; &amp;quot;YES\n&amp;quot;;
        continue;
    nosol: ;
        std::cout &amp;lt;&amp;lt; &amp;quot;NO\n&amp;quot;;
    &amp;#125;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;sunnys-crystals&#34;&gt;Sunny’s Crystals&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P5584&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P5584&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果某一时刻同时存在多个可以被删除的数，显然应该删最后一个&lt;/li&gt;
&lt;li&gt;否则，发现删每一个位置对于后方关键点的贡献完全相同，故删第一个即可。&lt;/li&gt;
&lt;li&gt;发现线段树没办法很好地维护『有哪些点是二的次方』，但是我们知道一个很相似的结构『有哪些点是 &lt;span class=&#34;math inline&#34;&gt;\(0\)&lt;/span&gt;』，结合起来可以马上反映出来实时维护每个点到最近一个二的此方位置的距离。&lt;/li&gt;
&lt;li&gt;把非关键点 / 被删去的点赋为 inf 即可方便维护。&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int maxn = 3e6 + 5;
const int inf = 0x3f3f3f3f;
struct &amp;#123;
    int l, r, u, x, d;
&amp;#125; t[maxn &amp;lt;&amp;lt; 2];
int tot = 0;
#define lt t[p].l
#define rt t[p].r
void pushval(int p, int v) &amp;#123;
    if (p)
        t[p].d += v, t[p].u += v;
    return;
&amp;#125;
void pushdown(int p) &amp;#123;
    pushval(lt, t[p].d), pushval(rt, t[p].d);
    t[p].d = 0;
    return;
&amp;#125;
void pushup(int p) &amp;#123;
    t[p].u = std::min(t[lt].u, t[rt].u);
    if (t[rt].u == t[p].u)
        t[p].x = t[rt].x;
    else
        t[p].x = t[lt].x;
    return;
&amp;#125;
void upd(int &amp;amp;p, int l, int r, int x, int v) &amp;#123;
    if (!p)
        p = ++tot;
    if (l == r) &amp;#123;
        t[p].u = v, t[p].x = l;
        return;
    &amp;#125;
    pushdown(p);
    int mid = (l + r) &amp;gt;&amp;gt; 1;
    if (x &amp;lt;= mid)
        upd(lt, l, mid, x, v);
    else
        upd(rt, mid + 1, r, x, v);
    pushup(p);
    return;
&amp;#125;
void add(int p, int l, int r, int ql, int qr, int v) &amp;#123;
    if (!p)
        return;
    if (ql &amp;lt;= l &amp;amp;&amp;amp; r &amp;lt;= qr) &amp;#123;
        pushval(p, v);
        return;
    &amp;#125;
    pushdown(p);
    int mid = (l + r) &amp;gt;&amp;gt; 1;
    if (ql &amp;lt;= mid)
        add(lt, l, mid, ql, qr, v);
    if (qr &amp;gt; mid)
        add(rt, mid + 1, r, ql, qr, v);
    pushup(p);
    return;
&amp;#125;
#undef lt
#undef rt
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, w, m = 0, rt = 0;
    std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; w, t[0].u = inf;
    auto to = [&amp;amp;](int x) &amp;#123;
        return 1 &amp;lt;&amp;lt; std::__lg(x);
    &amp;#125;;
    for (int i = 1, x; i &amp;lt;= n; ++i) &amp;#123;
        std::cin &amp;gt;&amp;gt; x;
        if (x == w)
            ++m, upd(rt, 1, n, i, i - to(i));
    &amp;#125;
    std::vector&amp;lt;int&amp;gt; res, del(n + 1);
    for (int i = 1, now = 1; i &amp;lt;= m; ++i) &amp;#123;
        for (int j = 1; j &amp;lt;= t[1].u; ++j) &amp;#123;
            for (; del[now]; ++now);
            del[now] = 1, res.push_back(now++);
        &amp;#125;
        pushval(rt, -t[1].u);
        int pos = t[1].x;
        del[pos] = 1, res.push_back(pos);
        upd(rt, 1, n, pos, inf);
        if (pos + 1 &amp;lt;= n)
            add(rt, 1, n, pos + 1, n, -1);
    &amp;#125;
    std::cout &amp;lt;&amp;lt; (int)res.size() &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    for (auto i : res)
        std::cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
    std::cout &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;section&#34;&gt;&lt;/h2&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://xsc062.netlify.app/20251004/</guid>
            <title>生成树 II</title>
            <link>https://xsc062.netlify.app/20251004/</link>
            <category>最小生成树</category>
            <pubDate>Sat, 04 Oct 2025 15:07:22 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;为什么要定义最小瓶颈路？似乎并不是很有意义&lt;/p&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;a---水筒&#34;&gt;A - 水筒&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/AT_joisc2014_e&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/AT_joisc2014_e&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;即求重构树，考虑 BFS 建图&lt;/li&gt;
&lt;li&gt;代码略&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;b---difference-of-distance&#34;&gt;B - Difference of Distance&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/AT_abc301_h&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/AT_abc301_h&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;有一个很奇怪的想法，就是当存在多种 Kruskal 重构树时，最大边权最小值是不会变的&lt;/li&gt;
&lt;li&gt;也就是说如果拿掉了这条边，但仍然存在另一条边权相同的边可以『代替』自己时，最大边权最小值不变&lt;/li&gt;
&lt;li&gt;否则，从另一个角度想，就可以仍然选自己，那么答案就会增加 1。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;因此，只需要对于不在生成树上的每一条边，标记环上和自己相同的边即可。&lt;/p&gt;
&lt;p&gt;树上差分 + dsu on tree 即可，注意线段树合并是线性的，如果忘了这一点就会和我一样想出虚树 + 树剖的诡异双 log 做法&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://xsc062.netlify.app/20250929/</guid>
            <title>生成树练习</title>
            <link>https://xsc062.netlify.app/20250929/</link>
            <category>最小生成树</category>
            <pubDate>Mon, 29 Sep 2025 16:55:28 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;zyz /bx /bx /bx&lt;/p&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;
&lt;details&gt;
&lt;p&gt;&lt;summary&gt;图论杂谈 by Para.pdf&lt;/summary&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;图论杂谈%20by%20Para.pdf&#34;&gt;link&lt;/a&gt;&lt;/p&gt;
&lt;iframe src=&#34;图论杂谈%20by%20Para.pdf&#34; width=&#34;100%&#34; height=&#34;500px&#34;&gt;
&lt;/iframe&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;最小公倍树&#34;&gt;最小公倍树&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P8207&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P8207&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;会想到从数论角度优化。需要想到&lt;strong&gt;最小化 lcm &lt;span class=&#34;math inline&#34;&gt;\(\to\)&lt;/span&gt; 最大化 gcd。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;枚举 gcd &lt;span class=&#34;math inline&#34;&gt;\(u\)&lt;/span&gt;，那么 &lt;span class=&#34;math inline&#34;&gt;\(u\)&lt;/span&gt; 的倍数在 &lt;span class=&#34;math inline&#34;&gt;\([L,R]\)&lt;/span&gt; 中呈现为 &lt;span class=&#34;math inline&#34;&gt;\(k\cdot u,(k+1)\cdot u,(k+2)\cdot u,\cdots\)&lt;/span&gt;。&lt;strong&gt;虽然这些数两两之间的 gcd 并不一定为 &lt;span class=&#34;math inline&#34;&gt;\(u\)&lt;/span&gt;，但我们在枚举时『钦定』&lt;span class=&#34;math inline&#34;&gt;\(u\)&lt;/span&gt; 就是 gcd，故贪心地将所有 &lt;span class=&#34;math inline&#34;&gt;\(k+i\)&lt;/span&gt; 和 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 连边。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这种钦定的思想是很重要但我不太容易想到的。许多关于『最优化』的转化都会用到这种钦定的想法。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;优化建图后跑 Kruskal 即可。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;p&gt;古老代码&lt;/p&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
#define int long long
namespace fastIO &amp;#123;
const int LEN = (1 &amp;lt;&amp;lt; 20);
#ifdef ONLINE_JUDGE
inline int nec(void) &amp;#123;
    static char buf[LEN], *p = buf, *e = buf;
    if (p == e) &amp;#123;
        e = buf + fread(buf, 1, LEN, stdin);
        if (e == buf) return EOF;
        p = buf;
    &amp;#125;
    return *p++;
&amp;#125;
#else
#define nec getchar
#endif
inline bool read(int &amp;amp;x) &amp;#123;
    x = 0;
    bool f = 0;
    char ch = nec();
    while (ch &amp;lt; &amp;#39;0&amp;#39; || ch &amp;gt; &amp;#39;9&amp;#39;) &amp;#123;
        if (ch == EOF) return 0;
        if (ch == &amp;#39;-&amp;#39;) f = 1;
        ch = nec();
    &amp;#125;
    while (ch &amp;gt;= &amp;#39;0&amp;#39; &amp;amp;&amp;amp; ch &amp;lt;= &amp;#39;9&amp;#39;) &amp;#123;
        x = x * 10 + ch - &amp;#39;0&amp;#39;;
        ch = nec();
    &amp;#125;
    if (f) x = -x;
    return 1;
&amp;#125;
void print(int x) &amp;#123;
    if (x &amp;lt; 0)
        putchar(&amp;#39;-&amp;#39;), x = -x;
    if (x &amp;gt;= 10) print(x / 10);
    putchar(x % 10 + &amp;#39;0&amp;#39;);
    return;
&amp;#125;
void print(int x, char ch) &amp;#123;
    print(x), putchar(ch);
    return;
&amp;#125;
&amp;#125; // namespace fastIO
namespace XSC062 &amp;#123;
using namespace fastIO;
const int maxn = 1e6 + 5;
struct _ &amp;#123;
    int x, y, w;
    _() &amp;#123;&amp;#125;
    _(int x1, int y1, int w1) &amp;#123;
        x = x1, y = y1, w = w1;
    &amp;#125;
    bool operator&amp;lt; (const _ &amp;amp;q) const &amp;#123;
        return w &amp;lt; q.w;
    &amp;#125;
&amp;#125;;
int f[maxn];
std::vector&amp;lt;_&amp;gt; e;
int n, res, l, r;
int find(int x) &amp;#123; return x == f[x] ? x : f[x] = find(f[x]); &amp;#125;
void merge(int x, int y) &amp;#123; f[find(x)] = find(y); &amp;#125;
int gcd(int x, int y) &amp;#123; return y ? gcd(y, x % y) : x; &amp;#125;
int lcm(int x, int y) &amp;#123; return x / gcd(x, y) * y; &amp;#125;
int main() &amp;#123;
    read(l), read(r);
    for (int i = 1; i &amp;lt;= r; ++i) &amp;#123;
        f[i] = i;
        int x = ((l + i - 1) / i) * i;
        for(int y = x + i; y &amp;lt;= r; y += i)
            e.emplace_back(x, y, lcm(x, y));
    &amp;#125;
    std::sort(e.begin(), e.end());
    for (auto i : e) &amp;#123;
        if (find(i.x) != find(i.y))
            merge(i.x, i.y), res += i.w;
    &amp;#125;
    print(res, &amp;#39;\n&amp;#39;);
    return 0;
&amp;#125;
&amp;#125; // namespace XSC062
#undef int
int main() &amp;#123;
    XSC062::main();
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;色&#34;&gt;色&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.becoder.com.cn/problem/46791&#34; class=&#34;uri&#34;&gt;https://www.becoder.com.cn/problem/46791&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;容易发现相当于在问最短的边，满足两端颜色不同&lt;/li&gt;
&lt;li&gt;&lt;p&gt;进一步地，&lt;strong&gt;『最短边』问题应该思考边是否一定在 mst 上&lt;/strong&gt;，就可以借助树的结构。考虑证明：&lt;/p&gt;
&lt;p&gt;若 Kruskal 时，边两端的连通块内部都是同色的，且二者不同色，则这条边是最短的异色边。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;问题转化为问树上最短异色边。乍一看好像和图没什么区别，困境还是『一次修改影响边数太多』，或『无法简单判定边的类型转化』。&lt;/p&gt;
&lt;p&gt;树上问题经验不足。可以&lt;strong&gt;分为儿子和父亲维护&lt;/strong&gt;，儿子&lt;strong&gt;整体维护&lt;/strong&gt;每个颜色的个数，对父亲&lt;strong&gt;暴力修改&lt;/strong&gt;即可。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;另一种做法是，忽略 mst 性质，对图上的&lt;strong&gt;边序列排序后分块&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;询问时枚举所有块，如果该块中存在异色边，则暴力枚举块中边然后 break。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;修改则是祖传哈希，给每条边、每个颜色赋一个随机系数并&lt;strong&gt;强行有向化，起点为加终点为减&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;记录每个块中的系数和，最后总和为 0 则块不可选。&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;p&gt;古老代码&lt;/p&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
using ull = unsigned long long;
const int maxk = 555;
const int maxn = 2e5 + 5;
const int maxm = 3e5 + 5;
struct _ &amp;#123; int u, v, w; &amp;#125;;
_ g[maxm];
int l[maxk], r[maxk], a[maxn];
ull hash[maxm], w[maxk], to[maxn], val[maxk][maxn];
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    std::cout.tie(nullptr);
#else
    freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#endif
    int n, m, q;
    std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m &amp;gt;&amp;gt; q &amp;gt;&amp;gt; q;
    std::mt19937_64 rnd(0xabcdef);
    for (int i = 1; i &amp;lt;= m; ++i) &amp;#123;
        std::cin &amp;gt;&amp;gt; g[i].u &amp;gt;&amp;gt; g[i].v &amp;gt;&amp;gt; g[i].w;
        hash[i] = rnd();
    &amp;#125;
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        std::cin &amp;gt;&amp;gt; a[i];
        for (; !to[a[i]]; to[a[i]] = rnd());
    &amp;#125;
    std::sort(g + 1, g + m + 1, [](_ x, _ y) &amp;#123; return x.w &amp;lt; y.w; &amp;#125;);
    int siz = sqrt(m), k = (m + siz - 1) / siz;
    for (int i = 1; i &amp;lt;= k; ++i) &amp;#123;
        l[i] = r[i - 1] + 1, r[i] = std::min(l[i] + siz - 1, m);
        for (int j = l[i]; j &amp;lt;= r[i]; ++j) &amp;#123;
            val[i][g[j].u] += hash[j];
            val[i][g[j].v] -= hash[j];
            w[i] += hash[j] * (to[a[g[j].u]] - to[a[g[j].v]]);
        &amp;#125;
    &amp;#125;
    for (int x, y; q--; ) &amp;#123;
        std::cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; y;
        for (; !to[y]; to[y] = rnd());
        for (int i = 1; i &amp;lt;= k; ++i)
            w[i] += val[i][x] * (to[y] - to[a[x]]);
        a[x] = y;
        for (int i = 1; i &amp;lt;= k; ++i) &amp;#123;
            if (w[i]) &amp;#123;
                for (int j = l[i]; j &amp;lt;= r[i]; ++j)
                    if (a[g[j].u] != a[g[j].v]) &amp;#123;
                        std::cout &amp;lt;&amp;lt; g[j].w &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
                        break;
                    &amp;#125;
                break;
            &amp;#125;
        &amp;#125;
    &amp;#125;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;dfs-trees&#34;&gt;DFS Trees&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/CF1707C&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/CF1707C&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;一个结论：若图中边权两两不同，则图的最小生成树唯一。&lt;/p&gt;
&lt;details&gt;
&lt;p&gt;&lt;summary&gt;借鉴次小生成树的思路证明…&lt;/summary&gt;&lt;/p&gt;
&lt;p&gt;对于两个 mst &lt;span class=&#34;math inline&#34;&gt;\(T_1,T_2\)&lt;/span&gt;，假设二者边集不同但权值相同，对于其对称差 &lt;span class=&#34;math inline&#34;&gt;\(S\)&lt;/span&gt;，设 &lt;span class=&#34;math inline&#34;&gt;\(e\)&lt;/span&gt; 是其中最小的边，且 &lt;span class=&#34;math inline&#34;&gt;\(e\in T_1,e\notin T_2\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;将 &lt;span class=&#34;math inline&#34;&gt;\(e\)&lt;/span&gt; 加入 &lt;span class=&#34;math inline&#34;&gt;\(T_2\)&lt;/span&gt;，则形成的环上存在 &lt;span class=&#34;math inline&#34;&gt;\(e&amp;#39;\)&lt;/span&gt; 使得 &lt;span class=&#34;math inline&#34;&gt;\(e&amp;#39;\in T_2,e&amp;#39;\notin T_1\)&lt;/span&gt;，那么 &lt;span class=&#34;math inline&#34;&gt;\(e&amp;#39;\in S\)&lt;/span&gt;。删掉 &lt;span class=&#34;math inline&#34;&gt;\(e&amp;#39;\)&lt;/span&gt; 并加入 &lt;span class=&#34;math inline&#34;&gt;\(e\)&lt;/span&gt;，得到 &lt;span class=&#34;math inline&#34;&gt;\(T_2&amp;#39;\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;由于 &lt;span class=&#34;math inline&#34;&gt;\(e\)&lt;/span&gt; 是 &lt;span class=&#34;math inline&#34;&gt;\(S\)&lt;/span&gt; 中最小边，那么 &lt;span class=&#34;math inline&#34;&gt;\(e&amp;lt;e&amp;#39;\)&lt;/span&gt;。也即 &lt;span class=&#34;math inline&#34;&gt;\(T_2&amp;#39;&amp;lt;T_1\)&lt;/span&gt;，与前提矛盾。&lt;/p&gt;
&lt;/details&gt;
&lt;p&gt;知道了这一点，就很好从 DFS 树的方向下手了。考虑如何什么时候 DFS 树就是 mst。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;对于一条非 mst 树边 &lt;span class=&#34;math inline&#34;&gt;\((u,v,w)\)&lt;/span&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;由 DFS 树的性质，&lt;strong&gt;若其为横叉边，必被经过。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;由 mst 的性质，&lt;span class=&#34;math inline&#34;&gt;\(w\)&lt;/span&gt; 一定比 &lt;span class=&#34;math inline&#34;&gt;\(u,v\)&lt;/span&gt; 简单路径上的所有边边权更大，也即，当可以走这条路径时，一定不走 &lt;span class=&#34;math inline&#34;&gt;\(w\)&lt;/span&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;结合起来，&lt;span class=&#34;math inline&#34;&gt;\(w\)&lt;/span&gt; 不被经过，当且仅当 &lt;span class=&#34;math inline&#34;&gt;\(u,v\)&lt;/span&gt; 间存在祖孙关系。对应子树即为合法根。实现时还是需要倍增来找到差分范围，较为难受。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, m;
    std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
    std::vector&amp;lt;std::pair&amp;lt;int, int&amp;gt; &amp;gt; e(m + 1);
    for (int i = 1; i &amp;lt;= m; ++i)
        std::cin &amp;gt;&amp;gt; e[i].first &amp;gt;&amp;gt; e[i].second;
    std::vector&amp;lt;int&amp;gt; f(n + 1);
    std::iota(f.begin() + 1, f.end(), 1);
    std::function&amp;lt;int(int)&amp;gt; find = [&amp;amp;](int x) &amp;#123;
        return x == f[x] ? x : f[x] = find(f[x]);
    &amp;#125;;
    auto merge = [&amp;amp;](int x, int y) &amp;#123;
        f[find(x)] = find(y);
        return;
    &amp;#125;;
    std::vector&amp;lt;std::pair&amp;lt;int, int&amp;gt; &amp;gt; u;
    std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; g(n + 1);
    for (int i = 1; i &amp;lt;= m; ++i) &amp;#123;
        auto &amp;amp;[x, y] = e[i];
        if (find(x) != find(y)) &amp;#123;
            g[x].push_back(y), g[y].push_back(x);
            merge(x, y);
        &amp;#125;
        else
            u.push_back(e[i]);
    &amp;#125;
    std::vector&amp;lt;int&amp;gt; dep(n + 1);
    std::vector&amp;lt;std::array&amp;lt;int, 19&amp;gt; &amp;gt; fa(n + 1);
    std::function&amp;lt;void(int)&amp;gt; DFS = [&amp;amp;](int x) &amp;#123;
        for (auto i : g[x])
            if (i != fa[x][0]) &amp;#123;
                dep[i] = dep[x] + 1;
                fa[i][0] = x;
                for (int j = 1; j &amp;lt; 19; ++j)
                    fa[i][j] = fa[fa[i][j - 1]][j - 1];
                DFS(i);
            &amp;#125;
        return;
    &amp;#125;;
    dep[1] = 1, DFS(1);
    auto ask = [&amp;amp;](int x, int y) &amp;#123;
        if (dep[x] &amp;lt; dep[y])
            std::swap(x, y);
        for (int i = 18; ~i; --i)
            if (dep[fa[x][i]] &amp;gt;= dep[y])
                x = fa[x][i];
        if (x == y)
            return x;
        for (int i = 18; ~i; --i)
            if (fa[x][i] != fa[y][i])
                x = fa[x][i], y = fa[y][i];
        return fa[x][0];
    &amp;#125;;
    std::vector&amp;lt;int&amp;gt; diff(n + 1);
    for (auto [x, y] : u) &amp;#123;
        ++diff[x], ++diff[y];
        if (dep[x] &amp;lt; dep[y])
            std::swap(x, y);
        if (ask(x, y) == y) &amp;#123;
            for (int i = 18; ~i; --i)
                if (dep[fa[x][i]] &amp;gt; dep[y])
                    x = fa[x][i];
            --diff[x];
        &amp;#125;
    &amp;#125;
    std::vector&amp;lt;int&amp;gt; res(n + 1);
    std::function&amp;lt;void(int, int)&amp;gt; DFS1 = [&amp;amp;](int x, int s) &amp;#123;
        s += diff[x];
        res[x] = (s == (int)u.size());
        for (auto i : g[x])
            if (i != fa[x][0])
                DFS1(i, s);
        return;
    &amp;#125;;
    DFS1(1, 0);
    for (int i = 1; i &amp;lt;= n; ++i)
        std::cout &amp;lt;&amp;lt; res[i];
    std::cout &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;minimum-spanning-tree-for-each-edge&#34;&gt;Minimum spanning tree for each edge&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/CF609E&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/CF609E&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;挺没意思的题…… 略了。&lt;/p&gt;
&lt;p&gt;考虑这个题的孪生版本：&lt;/p&gt;
&lt;h2 id=&#34;minimum-spanning-tree&#34;&gt;Minimum Spanning Tree&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/AT_icpc2013spring_e&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/AT_icpc2013spring_e&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;用非树边更新环上每条树边的最小取代边即可。类似树上差分。代码略。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;power-tree&#34;&gt;Power Tree&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/CF1120D&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/CF1120D&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;容易想到把原问题转化为叶子序列上的差分。那么对于任意一个初始差分序列，我们都需要把它通过这样的差分操作变为 &lt;span class=&#34;math inline&#34;&gt;\(1\sim n\)&lt;/span&gt; 全 0，第 &lt;span class=&#34;math inline&#34;&gt;\(n+1\)&lt;/span&gt; 位为 &lt;span class=&#34;math inline&#34;&gt;\(-s\)&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;联想到&lt;strong&gt;差分和连有向边的转化&lt;/strong&gt;，那么要求连一个 &lt;span class=&#34;math inline&#34;&gt;\(n+1\)&lt;/span&gt; 为唯一汇点的树出来。显然就是原图的 mst。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;考虑怎么求出可能被 mst 包含的边。对于每一条非树边，若环上存在边权相同的边，那么这条非树边也能成为树边。&lt;/p&gt;
&lt;p&gt;考虑一个孪生问题：怎么求出一定被 mst 包含的边？&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/CF160D&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/CF160D&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;树上差分 + 线段树合并即可，注意单次线段树合并只有线性，直接做 DSU on tree 的复杂度是单 log 的。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;关于具体实现，可以参考 &lt;a href=&#34;https://oi-wiki.org/graph/mst/#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%9A%84%E5%94%AF%E4%B8%80%E6%80%A7&#34;&gt;最小生成树的唯一性 - OI Wiki&lt;/a&gt;。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
#define int long long
namespace fastIO &amp;#123;
const int LEN = (1 &amp;lt;&amp;lt; 20);
#ifdef ONLINE_JUDGE
inline int nec(void) &amp;#123;
    static char buf[LEN], *p = buf, *e = buf;
    if (p == e) &amp;#123;
        e = buf + fread(buf, 1, LEN, stdin);
        if (e == buf) return EOF;
        p = buf;
    &amp;#125;
    return *p++;
&amp;#125;
#else
#define nec getchar
#endif
inline bool read(int &amp;amp;x) &amp;#123;
    x = 0;
    bool f = 0;
    char ch = nec();
    while (ch &amp;lt; &amp;#39;0&amp;#39; || ch &amp;gt; &amp;#39;9&amp;#39;) &amp;#123;
        if (ch == EOF) return 0;
        if (ch == &amp;#39;-&amp;#39;) f = 1;
        ch = nec();
    &amp;#125;
    while (ch &amp;gt;= &amp;#39;0&amp;#39; &amp;amp;&amp;amp; ch &amp;lt;= &amp;#39;9&amp;#39;) &amp;#123;
        x = x * 10 + ch - &amp;#39;0&amp;#39;;
        ch = nec();
    &amp;#125;
    if (f) x = -x;
    return 1;
&amp;#125;
void print(int x) &amp;#123;
    if (x &amp;lt; 0)
        putchar(&amp;#39;-&amp;#39;), x = -x;
    if (x &amp;gt;= 10) print(x / 10);
    putchar(x % 10 + &amp;#39;0&amp;#39;);
    return;
&amp;#125;
void print(int x, char ch) &amp;#123;
    print(x), putchar(ch);
    return;
&amp;#125;
&amp;#125; // namespace fastIO
namespace XSC062 &amp;#123;
using namespace fastIO;
const int maxn = 2e5 + 5;
struct _ &amp;#123;
    int x, y, i;
    _() &amp;#123;&amp;#125;
    _(int x1, int y1, int i1) &amp;#123;
        x = x1, y = y1, i = i1;
    &amp;#125;
    bool operator&amp;lt; (const _ &amp;amp;q) const;
&amp;#125;;
_ t[maxn];
int a[maxn], f[maxn];
std::vector&amp;lt;int&amp;gt; res;
int n, now, x, y, sum; 
int beg[maxn], to[maxn];
std::vector&amp;lt;int&amp;gt; g[maxn];
bool _::operator&amp;lt; (const _ &amp;amp;q) const &amp;#123;
    return a[i] &amp;lt; a[q.i];
&amp;#125;
int find(int x) &amp;#123; return x == f[x] ? x : f[x] = find(f[x]); &amp;#125;
void merge(int x, int y) &amp;#123;
    f[find(x)] = find(y);
    return;
&amp;#125;
void DFS(int x, int fa) &amp;#123;
    if (~fa &amp;amp;&amp;amp; (int)g[x].size() == 1)
        beg[x] = to[x] = ++now;
    for (auto i : g[x]) &amp;#123;
        if (i == fa) continue;
        DFS(i, x);
        if (!beg[x]) beg[x] = beg[i];
        to[x] = to[i];
    &amp;#125;
    t[x] = _(beg[x], to[x] + 1, x);
    return;
&amp;#125;
void add(int x, int y) &amp;#123;
    g[x].push_back(y);
    return;
&amp;#125;
int main() &amp;#123;
    read(n);
    for (int i = 1; i &amp;lt;= n; ++i) read(a[i]);
    for (int i = 1; i &amp;lt;= n + 1; ++i) f[i] = i;
    for (int i = 1; i &amp;lt; n; ++i) &amp;#123;
        read(x), read(y);
        add(x, y), add(y, x);
    &amp;#125;
    DFS(1, -1);
    std::sort(t + 1, t + n + 1);
    for (int l = 1, r = 0; l &amp;lt;= n; l = r + 1) &amp;#123;
        while (r &amp;lt; n &amp;amp;&amp;amp; a[t[r + 1].i] == a[t[l].i]) ++r;
        for (int i = l; i &amp;lt;= r; ++i) &amp;#123;
            if (find(t[i].x) != find(t[i].y))
                res.push_back(t[i].i);
        &amp;#125;
        for (int i = l; i &amp;lt;= r; ++i) &amp;#123;
            if (find(t[i].x) != find(t[i].y))
                sum += a[t[i].i], merge(t[i].x, t[i].y);
        &amp;#125;
    &amp;#125;
    std::sort(res.begin(), res.end());
    print(sum, &amp;#39; &amp;#39;), print(res.size(), &amp;#39;\n&amp;#39;);
    for (auto i : res) print(i, &amp;#39; &amp;#39;);
    putchar(&amp;#39;\n&amp;#39;);
    return 0;
&amp;#125;
&amp;#125; // namespace XSC062
#undef int
int main() &amp;#123;
    XSC062::main();
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;another-minimum-spanning-tree&#34;&gt;Another Minimum Spanning Tree&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.becoder.com.cn/problem/29212&#34; class=&#34;uri&#34;&gt;https://www.becoder.com.cn/problem/29212&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;goto &lt;a href=&#34;/20240206/&#34;&gt;曼哈顿最小距离生成树&lt;/a&gt;。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;a---design-tutorial-inverse-the-problem&#34;&gt;A - Design Tutorial: Inverse the Problem&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/CF472D&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/CF472D&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;发现给出的完全图的最小生成树就是原树。check 一下是否合法即可。&lt;/li&gt;
&lt;li&gt;图较稠密，需要用 Prim。&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n;
    std::cin &amp;gt;&amp;gt; n;
    std::vector&amp;lt;std::vector&amp;lt;std::pair&amp;lt;int, int&amp;gt; &amp;gt; &amp;gt; g(n + 1);
    std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; g0(n + 1, std::vector&amp;lt;int&amp;gt; (n + 1));
    for (int i = 1; i &amp;lt;= n; ++i)
        for (int j = 1; j &amp;lt;= n; ++j)
            std::cin &amp;gt;&amp;gt; g0[i][j];
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        if (g0[i][i] != 0) &amp;#123;
            std::cout &amp;lt;&amp;lt; &amp;quot;NO\n&amp;quot;;
            return 0;
        &amp;#125;
        for (int j = 1; j &amp;lt; i; ++j)
            if (g0[i][j] != g0[j][i] || !g0[i][j]) &amp;#123;
                std::cout &amp;lt;&amp;lt; &amp;quot;NO\n&amp;quot;;
                return 0;
            &amp;#125;
    &amp;#125;
    std::vector&amp;lt;int&amp;gt; pos(n + 1), tag(n + 1);
    tag[1] = 1;
    for (int _ = 1, s = 1; _ &amp;lt; n; ++_) &amp;#123;
        for (int i = 1; i &amp;lt;= n; ++i)
            if (!tag[i] &amp;amp;&amp;amp; (!pos[i] || g0[s][i] &amp;lt; g0[pos[i]][i]))
                pos[i] = s;
        s = 0;
        int t = 0;
        for (int i = 1; i &amp;lt;= n; ++i)
            if (!tag[i] &amp;amp;&amp;amp; pos[i] &amp;amp;&amp;amp; (!s || g0[pos[i]][i] &amp;lt; g0[pos[s]][s]))
                s = i, t = pos[i];
        tag[s] = 1;
        g[s].emplace_back(t, g0[s][t]), g[t].emplace_back(s, g0[s][t]);
    &amp;#125;
    std::vector&amp;lt;int&amp;gt; tab(n + 1), dis(n + 1);
    std::function&amp;lt;void(int, int)&amp;gt; DFS = [&amp;amp;](int x, int fa) &amp;#123;
        static int now = 0;
        tab[++now] = x;
        int L = now, R = now;
        for (auto [i, w] : g[x])
            if (i != fa) &amp;#123;
                dis[i] = dis[x] + w;
                DFS(i, x);
                for (int p = L; p &amp;lt;= R; ++p)
                    for (int q = R + 1; q &amp;lt;= now; ++q) &amp;#123;
                        if (g0[tab[p]][tab[q]] != dis[tab[p]] + dis[tab[q]] - 2 * dis[x]) &amp;#123;
                            std::cout &amp;lt;&amp;lt; &amp;quot;NO\n&amp;quot;;
                            exit(0); // extremely ugly
                        &amp;#125;
                    &amp;#125;
                R = now;
            &amp;#125;
        return;
    &amp;#125;;
    DFS(1, -1);
    std::cout &amp;lt;&amp;lt; &amp;quot;YES\n&amp;quot;;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;b---phoenix-and-earthquake&#34;&gt;B - Phoenix and Earthquake&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/CF1515F&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/CF1515F&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;会想到，有解的充要条件是的点权之和 &lt;span class=&#34;math inline&#34;&gt;\(\ge (n-1)\cdot x\)&lt;/span&gt;。证明方法很广泛，但规约的思想对破题是决定性的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;对于 &lt;span class=&#34;math inline&#34;&gt;\(u\ge x\)&lt;/span&gt;，将 &lt;span class=&#34;math inline&#34;&gt;\(u\)&lt;/span&gt; 和任意相邻点合并后缩点，规约为更小规模的问题。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;对于 &lt;span class=&#34;math inline&#34;&gt;\(u&amp;lt;x\)&lt;/span&gt;，一次合并使点权和减少 &lt;span class=&#34;math inline&#34;&gt;\(u\)&lt;/span&gt;，点权需求减少 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt;，故子问题合法则该问题合法。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;条件是充要的，则可以任意合并，但这样不太好做，考虑借助规约的结构，若 &lt;span class=&#34;math inline&#34;&gt;\(u\ge x\)&lt;/span&gt; 则直接合并，否则等到其他部分合并完后再合并这一条边。这是一个栈的结构。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, m, k;
    std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m &amp;gt;&amp;gt; k;
    std::vector&amp;lt;long long&amp;gt; a(n + 1);
    for (int i = 1; i &amp;lt;= n; ++i)
        std::cin &amp;gt;&amp;gt; a[i];
    if (std::accumulate(a.begin() + 1, a.end(), 0ll) &amp;lt; (long long)k * (n - 1)) &amp;#123;
        std::cout &amp;lt;&amp;lt; &amp;quot;NO\n&amp;quot;;
        return 0;
    &amp;#125;
    std::cout &amp;lt;&amp;lt; &amp;quot;YES\n&amp;quot;;
    std::vector&amp;lt;int&amp;gt; f(n + 1);
    std::iota(f.begin() + 1, f.end(), 1);
    std::function&amp;lt;int(int)&amp;gt; find = [&amp;amp;](int x) &amp;#123;
        return x == f[x] ? x : f[x] = find(f[x]);
    &amp;#125;;
    auto merge = [&amp;amp;](int x, int y) &amp;#123;
        f[find(x)] = find(y);
        return;
    &amp;#125;;
    std::vector&amp;lt;std::vector&amp;lt;std::pair&amp;lt;int, int&amp;gt; &amp;gt; &amp;gt; g(n + 1);
    for (int i = 1, x, y; m--; ++i) &amp;#123;
        std::cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; y;
        if (find(x) != find(y)) &amp;#123;
            g[x].emplace_back(y, i);
            g[y].emplace_back(x, i);
            merge(x, y);
        &amp;#125;
    &amp;#125;
    std::vector&amp;lt;int&amp;gt; t;
    std::function&amp;lt;void(int, int)&amp;gt; DFS = [&amp;amp;](int x, int fa) &amp;#123;
        for (auto [i, id] : g[x])
            if (i != fa) &amp;#123;
                DFS(i, x);
                if (a[i] &amp;gt;= k) &amp;#123;
                    a[x] += a[i] - k;
                    std::cout &amp;lt;&amp;lt; id &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
                &amp;#125;
                else
                    t.push_back(id);
            &amp;#125;
        return;
    &amp;#125;;
    DFS(1, -1);
    for (; !t.empty(); t.pop_back())
        std::cout &amp;lt;&amp;lt; t.back() &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;最小度限制生成树-easy-version&#34;&gt;最小度限制生成树 (Easy Version)&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P5633&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P5633&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;要求：两只 log。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;wqs 二分即可。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;最小度限制生成树-hard-version&#34;&gt;最小度限制生成树 (Hard Version)&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;要求：一只 log。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;注意到涉及的边是固定的，且偏移量相同，故对于『与 &lt;span class=&#34;math inline&#34;&gt;\(s\)&lt;/span&gt; 有关的边』和『与 &lt;span class=&#34;math inline&#34;&gt;\(s\)&lt;/span&gt; 无关的边』先分别排序作为预处理，二分内部仅需归并即可。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;最小度限制生成树-extreme-version&#34;&gt;最小度限制生成树 (Extreme Version)&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;要求：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一只 log；&lt;/li&gt;
&lt;li&gt;对于 &lt;span class=&#34;math inline&#34;&gt;\(k=1,2,\cdots,n\)&lt;/span&gt;，分别输出答案。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;观看 &lt;a href=&#34;https://www.luogu.com.cn/article/ym8ixzr8&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/article/ym8ixzr8&lt;/a&gt;。&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://xsc062.netlify.app/20250924/</guid>
            <title>最短路练习</title>
            <link>https://xsc062.netlify.app/20250924/</link>
            <category>DP</category>
            <category>二分</category>
            <category>倍增</category>
            <category>调整法</category>
            <category>最短路</category>
            <pubDate>Wed, 24 Sep 2025 14:27:15 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;最短路为背景的题 + 做法是最短路的题&lt;/p&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;a---minimum-path&#34;&gt;A - Minimum Path&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/CF1473E&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/CF1473E&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;经典套路，发现可以把 max 和 min 换成任意路径中的边，然后 max 和 min 就会最小化这个式子&lt;/li&gt;
&lt;li&gt;故写一个 Dijkstra + DP，求这个式子的最小值即可&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, m;
    std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
    using arr = std::vector&amp;lt;long long&amp;gt;;
    using brr = std::vector&amp;lt;arr&amp;gt;;
    std::vector&amp;lt;std::vector&amp;lt;std::pair&amp;lt;int, int&amp;gt; &amp;gt; &amp;gt; g(n + 1);
    std::vector&amp;lt;brr&amp;gt; dis(2, brr(2, arr(n + 1, 1e18))), vis(2, brr(2, arr(n + 1)));
    for (int x, y, w; m--; ) &amp;#123;
        std::cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; y &amp;gt;&amp;gt; w;
        g[x].emplace_back(y, w);
        g[y].emplace_back(x, w);
    &amp;#125;
    dis[0][0][1] = 0;
    std::array&amp;lt;std::array&amp;lt;std::priority_queue&amp;lt;std::pair&amp;lt;long long, int&amp;gt; &amp;gt;, 2&amp;gt;, 2&amp;gt; q;
    q[0][0].emplace(0, 1);
    for (int i = 0; i &amp;lt; 2; ++i) &amp;#123;
        for (int j = 0; j &amp;lt; 2; ++j) &amp;#123;
            for (; !q[i][j].empty(); ) &amp;#123;
                int f = q[i][j].top().second;
                q[i][j].pop();
                if (vis[i][j][f])
                    continue;
                vis[i][j][f] = 1;
                for (auto k : g[f]) &amp;#123;
                    if (dis[i][j][k.first] &amp;gt; dis[i][j][f] + k.second) &amp;#123;
                        dis[i][j][k.first] = dis[i][j][f] + k.second;
                        q[i][j].emplace(-dis[i][j][k.first], k.first);
                    &amp;#125;
                    if (!i &amp;amp;&amp;amp; dis[1][j][k.first] &amp;gt; dis[i][j][f]) &amp;#123;
                        dis[1][j][k.first] = dis[i][j][f];
                        q[1][j].emplace(-dis[1][j][k.first], k.first);
                    &amp;#125;
                    if (!j &amp;amp;&amp;amp; dis[i][1][k.first] &amp;gt; dis[i][j][f] + 2 * k.second) &amp;#123;
                        dis[i][1][k.first] = dis[i][j][f] + 2 * k.second;
                        q[i][1].emplace(-dis[i][1][k.first], k.first);
                    &amp;#125;
                &amp;#125;
            &amp;#125;
        &amp;#125;
    &amp;#125;
    for (int i = 2; i &amp;lt;= n; ++i)
        std::cout &amp;lt;&amp;lt; std::min(&amp;#123; dis[0][0][i], dis[1][1][i] &amp;#125;) &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
    std::cout &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;b---train-delay&#34;&gt;B - Train Delay&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://vjudge.net/contest/750645#problem/B&#34; class=&#34;uri&#34;&gt;https://vjudge.net/contest/750645#problem/B&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;简化题目很重要的一个转化是&lt;strong&gt;由于 &lt;span class=&#34;math inline&#34;&gt;\(S\le T\)&lt;/span&gt; 带来的 &lt;span class=&#34;math inline&#34;&gt;\(S\)&lt;/span&gt; 和 &lt;span class=&#34;math inline&#34;&gt;\(T\)&lt;/span&gt; 地位平等，考虑把出发和到达分别看作一次事件处理。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;按照所有事件的发生时刻排序，有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于一次出发事件，可以得到在其之前该站点所有到达事件的 &lt;span class=&#34;math inline&#34;&gt;\(\max\{T&amp;#39;\}\)&lt;/span&gt;，用之更新 &lt;span class=&#34;math inline&#34;&gt;\(X\)&lt;/span&gt; 即可。&lt;/li&gt;
&lt;li&gt;对于一次到达事件，由于对应的 &lt;span class=&#34;math inline&#34;&gt;\(X\)&lt;/span&gt; 已经确定，更新该站点当前最大值即可。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, m;
    std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
    std::vector&amp;lt;int&amp;gt; d(m + 1);
    std::cin &amp;gt;&amp;gt; d[1];
    struct event &amp;#123;
        int t, op, id, x;
    &amp;#125;;
    std::vector&amp;lt;event&amp;gt; a;
    std::vector&amp;lt;int&amp;gt; mx(n + 1);
    for (int i = 1, x, y, s, t; i &amp;lt;= m; ++i) &amp;#123;
        std::cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; y &amp;gt;&amp;gt; s &amp;gt;&amp;gt; t;
        a.push_back(&amp;#123; s, 0, i, x &amp;#125;);
        a.push_back(&amp;#123; t, 1, i, y &amp;#125;);
    &amp;#125;
    std::sort(a.begin(), a.end(), [&amp;amp;](event &amp;amp;x, event &amp;amp;y) &amp;#123; return x.t == y.t ? x.op &amp;gt; y.op : x.t &amp;lt; y.t; &amp;#125;);
    for (auto [t, op, id, x] : a)
        if (op == 1)
            mx[x] = std::max(mx[x], t + d[id]);
        else if (id != 1)
            d[id] = std::max(mx[x] - t, 0);
    for (int i = 2; i &amp;lt;= m; ++i)
        std::cout &amp;lt;&amp;lt; d[i] &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
    std::cout &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;c---complete-the-graph&#34;&gt;C - Complete The Graph&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/CF715B&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/CF715B&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;神仙二分&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果初始把所有白边置为 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt;，那么会想到调整法构造&lt;/li&gt;
&lt;li&gt;但是不知道应该在哪些边上调整，确定调整多少似乎也没有什么简单的做法&lt;/li&gt;
&lt;li&gt;&lt;p&gt;故&lt;strong&gt;平均用力&lt;/strong&gt;，构造一个 边1 += 1，边2 += 1，边3 += 1, …, 边cnt0 += 1, 边1 += 1, 边2 += 1, … 的操作序列&lt;/p&gt;
容易&lt;strong&gt;发现每次操作最多让当前最短路长度增加 1&lt;/strong&gt;，而且有单调性&lt;/li&gt;
&lt;li&gt;&lt;p&gt;故二分答案即可&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const __int128 inf = 1e18;
const __int128 inff = 1e23;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, m, s, t, l, cnt = 0;
    std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m &amp;gt;&amp;gt; l &amp;gt;&amp;gt; s &amp;gt;&amp;gt; t, ++s, ++t;
    std::vector&amp;lt;std::tuple&amp;lt;int, int, long long&amp;gt; &amp;gt; u(m + 1);
    std::vector&amp;lt;std::vector&amp;lt;std::pair&amp;lt;int, long long&amp;gt; &amp;gt; &amp;gt; g(n + 1);
    for (int i = 1, x, y; i &amp;lt;= m; ++i) &amp;#123;
        long long w;
        std::cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; y &amp;gt;&amp;gt; w, ++x, ++y;
        if (w == 0)
            w = -(++cnt);
        g[x].emplace_back(y, w), g[y].emplace_back(x, w);
        u[i] = &amp;#123; x, y, w &amp;#125;;
    &amp;#125;
    std::vector&amp;lt;int&amp;gt; vis(n + 1);
    std::vector&amp;lt;__int128&amp;gt; dis(n + 1);
    std::vector&amp;lt;long long&amp;gt; k(cnt + 1);
    __int128 res = -1;
    auto check = [&amp;amp;](__int128 x) &amp;#123;
        for (int i = 1; i &amp;lt;= cnt; ++i)
            k[i] = x / cnt + (i &amp;lt;= x % cnt);
        std::fill(vis.begin() + 1, vis.end(), 0);
        std::fill(dis.begin() + 1, dis.end(), inf);
        std::priority_queue&amp;lt;std::pair&amp;lt;__int128, int&amp;gt; &amp;gt; q;
        dis[s] = 0, q.emplace(0, s);
        for (; !q.empty(); ) &amp;#123;
            int f = q.top().second;
            q.pop();
            if (vis[f])
                continue;
            vis[f] = 1;
            for (auto [v, w] : g[f]) &amp;#123;
                if (w &amp;lt; 0)
                    w = k[-w];
                if (dis[v] &amp;gt; dis[f] + w) &amp;#123;
                    dis[v] = dis[f] + w;
                    q.emplace(-dis[v], v);
                &amp;#125;
            &amp;#125;
        &amp;#125;
        return dis[t] &amp;lt;= l;
    &amp;#125;;
    for (__int128 l = cnt, r = cnt * inf, mid; l &amp;lt;= r; ) &amp;#123;
        mid = (l + r) &amp;gt;&amp;gt; 1;
        if (check(mid))
            res = mid, l = mid + 1;
        else
            r = mid - 1;
    &amp;#125;
    if (res == -1)
        std::cout &amp;lt;&amp;lt; &amp;quot;NO\n&amp;quot;;
    else &amp;#123;
        check(res);
        if (dis[t] != l)
            std::cout &amp;lt;&amp;lt; &amp;quot;NO\n&amp;quot;;
        else &amp;#123;
            std::cout &amp;lt;&amp;lt; &amp;quot;YES\n&amp;quot;;
            for (int i = 1; i &amp;lt;= m; ++i) &amp;#123;
                auto [x, y, w] = u[i];
                if (w &amp;lt; 0)
                    w = k[-w];
                std::cout &amp;lt;&amp;lt; x - 1 &amp;lt;&amp;lt; &amp;#39; &amp;#39; &amp;lt;&amp;lt; y - 1 &amp;lt;&amp;lt; &amp;#39; &amp;#39; &amp;lt;&amp;lt; w &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
            &amp;#125;
        &amp;#125;
    &amp;#125;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;a---重力球&#34;&gt;A - 重力球&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P7473&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P7473&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class=&#34;math inline&#34;&gt;\(m\)&lt;/span&gt; 相对很小，看看有没有什么基于 &lt;span class=&#34;math inline&#34;&gt;\(m\)&lt;/span&gt; 的做法&lt;/li&gt;
&lt;li&gt;每次球停下的位置一定是某个障碍物（或边界）上 / 下 / 左 / 右的格子，故可以在这 &lt;span class=&#34;math inline&#34;&gt;\(O(n + m)\)&lt;/span&gt; 个点上建图&lt;/li&gt;
&lt;li&gt;怎么同时维护两个球的信息呢，发现 &lt;span class=&#34;math inline&#34;&gt;\(m\)&lt;/span&gt; 还是很小，所以可以把两个球塞一起作为一个状态&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(m^2\)&lt;/span&gt; 次 Dij 还是太激进了 进一步思考发现可能的终点共 &lt;span class=&#34;math inline&#34;&gt;\(m\)&lt;/span&gt; 个 并且彼此不区分&lt;/p&gt;
&lt;p&gt;故以这 &lt;span class=&#34;math inline&#34;&gt;\(m\)&lt;/span&gt; 个终点跑多源最短路即可&lt;/p&gt;
&lt;p&gt;但 5e6 跑 Dij 还是太勉强了。&lt;strong&gt;发现边权为 1，为什么不 BFS 呢 😅&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;发现起点可能不在我们限定的点上，但可以人为选择一次重力方向，然后就回到刚刚的问题了&lt;/p&gt;
&lt;p&gt;或者离线也是一种方法&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;疑似常数太大，拼尽全力勉强卡过&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int LEN = (1 &amp;lt;&amp;lt; 20);
#ifdef ONLINE_JUDGE
inline int nec(void) &amp;#123;
    static char buf[LEN], *p = buf, *e = buf;
    if (p == e) &amp;#123;
        e = buf + fread(buf, 1, LEN, stdin);
        if (e == buf)
            return EOF;
        p = buf;
    &amp;#125;
    return *p++;
&amp;#125;
#else
#define nec getchar
#endif
inline bool read(int &amp;amp;x) &amp;#123;
    x = 0;
    bool f = 0;
    char ch = nec();
    while (ch &amp;lt; &amp;#39;0&amp;#39; || ch &amp;gt; &amp;#39;9&amp;#39;) &amp;#123;
        if (ch == EOF)
            return 0;
        if (ch == &amp;#39;-&amp;#39;)
            f = 1;
        ch = nec();
    &amp;#125;
    while (ch &amp;gt;= &amp;#39;0&amp;#39; &amp;amp;&amp;amp; ch &amp;lt;= &amp;#39;9&amp;#39;) &amp;#123;
        x = x * 10 + ch - &amp;#39;0&amp;#39;;
        ch = nec();
    &amp;#125;
    if (f)
        x = -x;
    return 1;
&amp;#125;
void print(int x) &amp;#123;
    if (x &amp;lt; 0) &amp;#123;
        putchar(&amp;#39;-&amp;#39;);
        x = -x;
    &amp;#125;
    if (x &amp;gt;= 10)
        print(x / 10);
    putchar(x % 10 + &amp;#39;0&amp;#39;);
    return;
&amp;#125;
void print(int x, char ch) &amp;#123;
    print(x);
    putchar(ch);
    return;
&amp;#125;
const int inf = 0x3f3f3f3f;
const int dir[][2] = &amp;#123;&amp;#123; -1, 0 &amp;#125;, &amp;#123; 1, 0 &amp;#125;, &amp;#123; 0, -1 &amp;#125;, &amp;#123; 0, 1 &amp;#125;&amp;#125;;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, m, q;
    read(n), read(m), read(q);
    std::vector&amp;lt;std::pair&amp;lt;int, int&amp;gt; &amp;gt; pos(m + 1);
    std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; a(n + 1, std::vector&amp;lt;int&amp;gt; (n + 1));
    for (int i = 1, x, y; i &amp;lt;= m; ++i) &amp;#123;
        read(x), read(y);
        pos[i] = &amp;#123; x, y &amp;#125;, a[x][y] = -1;
    &amp;#125;
    for (int i = 1; i &amp;lt;= n; ++i)
        pos.emplace_back(0, i), ++m;
    for (int i = 1; i &amp;lt;= n; ++i)
        pos.emplace_back(i, n + 1), ++m;
    for (int i = 1; i &amp;lt;= n; ++i)
        pos.emplace_back(n + 1, i), ++m;
    for (int i = 1; i &amp;lt;= n; ++i)
        pos.emplace_back(i, 0), ++m;
    int cnt = 0;
    std::vector&amp;lt;std::pair&amp;lt;int, int&amp;gt; &amp;gt; u(1);
    for (int i = 1; i &amp;lt;= m; ++i)
        for (auto [fx, fy] : dir) &amp;#123;
            int nx = pos[i].first + fx, ny = pos[i].second + fy;
            if (nx &amp;gt;= 1 &amp;amp;&amp;amp; nx &amp;lt;= n &amp;amp;&amp;amp; ny &amp;gt;= 1 &amp;amp;&amp;amp; ny &amp;lt;= n &amp;amp;&amp;amp; !a[nx][ny])
                a[nx][ny] = ++cnt, u.emplace_back(nx, ny);
        &amp;#125;
    std::vector&amp;lt;std::vector&amp;lt;std::array&amp;lt;int, 4&amp;gt; &amp;gt; &amp;gt; top(n + 1, std::vector&amp;lt;std::array&amp;lt;int, 4&amp;gt; &amp;gt; (n + 1));
    for (int j = 1; j &amp;lt;= n; ++j) &amp;#123;
        for (int i = 1; i &amp;lt;= n; ++i)
            if (a[i][j] != -1) &amp;#123;
                if (i == 1 || a[i - 1][j] == -1)
                    top[i][j][0] = a[i][j];
                else
                    top[i][j][0] = top[i - 1][j][0];
            &amp;#125;
        for (int i = n; i; --i)
            if (a[i][j] != -1) &amp;#123;
                if (i == n || a[i + 1][j] == -1)
                    top[i][j][1] = a[i][j];
                else
                    top[i][j][1] = top[i + 1][j][1];
            &amp;#125;
    &amp;#125;
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        for (int j = 1; j &amp;lt;= n; ++j)
            if (a[i][j] != -1) &amp;#123;
                if (j == 1 || a[i][j - 1] == -1)
                    top[i][j][2] = a[i][j];
                else
                    top[i][j][2] = top[i][j - 1][2];
            &amp;#125;
        for (int j = n; j; --j)
            if (a[i][j] != -1) &amp;#123;
                if (j == n || a[i][j + 1] == -1)
                    top[i][j][3] = a[i][j];
                else
                    top[i][j][3] = top[i][j + 1][3];
            &amp;#125;
    &amp;#125;
    const int N = cnt * cnt;
    std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; g(N + 1);
    auto encode = [&amp;amp;](int x, int y) &amp;#123;
        return (x - 1) * cnt + y;
    &amp;#125;;
    auto decode = [&amp;amp;](int id) &amp;#123;
        return std::make_pair((id - 1) / cnt + 1, (id - 1) % cnt + 1);
    &amp;#125;;
    for (int i = 1; i &amp;lt;= N; ++i)
        for (int j = 0; j &amp;lt; 4; ++j) &amp;#123;
            auto [a, b] = decode(i);
            g[encode(top[u[a].first][u[a].second][j], top[u[b].first][u[b].second][j])].emplace_back(i);
        &amp;#125;
    std::vector&amp;lt;int&amp;gt; dis(N + 1, inf), vis(N + 1);
    &amp;#123;
        std::queue&amp;lt;int&amp;gt; q;
        for (int i = 1; i &amp;lt;= cnt; ++i)
            dis[encode(i, i)] = 0, q.push(encode(i, i)), vis[encode(i, i)] = 1;
        for (; !q.empty(); ) &amp;#123;
            int x = q.front();
            q.pop();
            for (auto i : g[x])
                if (!vis[i])
                    dis[i] = dis[x] + 1, vis[i] = 1, q.push(i);
        &amp;#125;
    &amp;#125;
    for (int a, b, c, d; q--; ) &amp;#123;
        read(a), read(b), read(c), read(d);
        if (a == c &amp;amp;&amp;amp; b == d)
            print(0, &amp;#39;\n&amp;#39;);
        else &amp;#123;
            int res = inf;
            for (int j = 0; j &amp;lt; 4; ++j)
                res = std::min(res, dis[encode(top[a][b][j], top[c][d][j])] + 1);
            if (res == inf)
                print(-1, &amp;#39;\n&amp;#39;);
            else
                print(res, &amp;#39;\n&amp;#39;);
        &amp;#125;
    &amp;#125;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;b---矩阵游戏&#34;&gt;B - 矩阵游戏&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P7515&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P7515&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;把问题形式化一下，现在有 &lt;span class=&#34;math inline&#34;&gt;\(n\times m\)&lt;/span&gt; 个未知数和 &lt;span class=&#34;math inline&#34;&gt;\((n-1)\times (m-1)\)&lt;/span&gt; 个方程&lt;/p&gt;
&lt;p&gt;那么可以对边上一圈任意赋值，限制是左上角这 &lt;span class=&#34;math inline&#34;&gt;\((n-1)\times (m-1)\)&lt;/span&gt; 个未知数必须落在 &lt;span class=&#34;math inline&#34;&gt;\([0,10^6]\)&lt;/span&gt; 上&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;有一个很容易观察到的性质，对于一个 &lt;span class=&#34;math inline&#34;&gt;\(a\)&lt;/span&gt;，选取一个 &lt;span class=&#34;math inline&#34;&gt;\(v\)&lt;/span&gt;，并把棋盘黑白染色，那么把所有黑格 &lt;span class=&#34;math inline&#34;&gt;\(+=v\)&lt;/span&gt;，白格 &lt;span class=&#34;math inline&#34;&gt;\(-=v\)&lt;/span&gt;，对应的 &lt;span class=&#34;math inline&#34;&gt;\(b\)&lt;/span&gt; 是不会变的。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;这个操作是涉及全局的，太苛刻了&lt;/strong&gt;，有没有什么更 mild 的构造？&lt;/p&gt;
&lt;p&gt;发现只对一行 / 列黑白染色并操作也可以得到相同的结果。能感受到&lt;strong&gt;操作无法再简化了&lt;/strong&gt;。考虑用这个版本的操作&lt;strong&gt;调整&lt;/strong&gt;。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;故大力令周围一圈的临时解 &lt;span class=&#34;math inline&#34;&gt;\(a&amp;#39;\)&lt;/span&gt; 为 &lt;span class=&#34;math inline&#34;&gt;\(0\)&lt;/span&gt;，令每行、列的调整 delta 为 &lt;span class=&#34;math inline&#34;&gt;\(r_i,c_i\)&lt;/span&gt;，可以得到若干个关于 &lt;span class=&#34;math inline&#34;&gt;\(0\)&lt;/span&gt; 和 &lt;span class=&#34;math inline&#34;&gt;\(10^6\)&lt;/span&gt; 的约束。最后建出来一个完全二分图状物，跑差分约束即可，容易发现复杂度正确。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;实现技巧：规划一下 &lt;span class=&#34;math inline&#34;&gt;\(r\)&lt;/span&gt; 和 &lt;span class=&#34;math inline&#34;&gt;\(c\)&lt;/span&gt; 的染色方式，使得它们错开，可以把所有位置都写作 &lt;span class=&#34;math inline&#34;&gt;\(a&amp;#39;_{i,j}+c-r\)&lt;/span&gt; 或 &lt;span class=&#34;math inline&#34;&gt;\(a&amp;#39;_{i,j}+r-c\)&lt;/span&gt; 的形式，便于差分约束&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;c---tax&#34;&gt;C - Tax&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P6822&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P6822&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;容易想到分类讨论，如果钦定是入边贡献边权，那么出边边权不能大于入边边权；否则，出边贡献边权。&lt;/li&gt;
&lt;li&gt;考虑把每个点上的出边按边权从小到大排序，显然需要入边贡献的是一段前缀，需要出边贡献的是一段后缀，就可以做一个前后缀优化建图。&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const long long inf = 1e18;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, m;
    std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
    struct edge &amp;#123; int v, w, id, pi, si; &amp;#125;;
    std::vector&amp;lt;std::vector&amp;lt;edge&amp;gt; &amp;gt; g1(n + 2);
    std::vector&amp;lt;std::vector&amp;lt;std::pair&amp;lt;int, int&amp;gt; &amp;gt; &amp;gt; g(1);
    int cnt = 0;
    for (int x, y, w; m--; ) &amp;#123;
        std::cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; y &amp;gt;&amp;gt; w;
        g1[x].push_back(&amp;#123; y, w, ++cnt, 0, 0 &amp;#125;);
        g1[y].push_back(&amp;#123; x, w, ++cnt, 0, 0 &amp;#125;);
        g.emplace_back(), g.emplace_back();
    &amp;#125;
    int s = ++cnt, t = ++cnt;
    g1[0].push_back(&amp;#123; 1, 0, s, 0, 0 &amp;#125;), g1[n].push_back(&amp;#123; n + 1, 0, t, 0, 0 &amp;#125;);
    g.emplace_back(), g.emplace_back();
    for (int i = 0; i &amp;lt;= n + 1; ++i)
        if (!g1[i].empty()) &amp;#123;
            std::sort(g1[i].begin(), g1[i].end(), [&amp;amp;](edge &amp;amp;x, edge &amp;amp;y) &amp;#123; return x.w &amp;lt; y.w; &amp;#125;);
            for (int j = 0; j &amp;lt; (int)g1[i].size(); ++j) &amp;#123;
                g1[i][j].pi = ++cnt, g.emplace_back();
                if (j != 0)
                    g[cnt].emplace_back(cnt - 1, 0);
                g[cnt].emplace_back(g1[i][j].id, 0);
            &amp;#125;
            for (int j = (int)g1[i].size() - 1; ~j; --j) &amp;#123;
                g1[i][j].si = ++cnt, g.emplace_back();
                if (j != (int)g1[i].size() - 1)
                    g[cnt].emplace_back(cnt - 1, 0);
                g[cnt].emplace_back(g1[i][j].id, g1[i][j].w);
            &amp;#125;
        &amp;#125;
    for (int i = 0; i &amp;lt;= n + 1; ++i)
        for (auto &amp;amp;[v, w, id, pi, si] : g1[i]) &amp;#123;
            auto to = std::upper_bound(g1[v].begin(), g1[v].end(), w, [&amp;amp;](int x, edge &amp;amp;y) &amp;#123; return x &amp;lt; y.w; &amp;#125;);
            if (to != g1[v].end())
                g[id].emplace_back(to-&amp;gt;si, 0);
            if (to != g1[v].begin())
                g[id].emplace_back((--to)-&amp;gt;pi, w);
        &amp;#125;
    std::vector&amp;lt;int&amp;gt; vis(cnt + 1, 0);
    std::vector&amp;lt;long long&amp;gt; dis(cnt + 1, inf);
    std::priority_queue&amp;lt;std::pair&amp;lt;long long, int&amp;gt; &amp;gt; q;
    dis[s] = 0, q.emplace(0, s);
    for (; !q.empty(); ) &amp;#123;
        int f = q.top().second;
        q.pop();
        if (vis[f])
            continue;
        vis[f] = 1;
        for (auto [v, w] : g[f])
            if (dis[v] &amp;gt; dis[f] + w) &amp;#123;
                dis[v] = dis[f] + w;
                q.emplace(-dis[v], v);
            &amp;#125;
    &amp;#125;
    std::cout &amp;lt;&amp;lt; dis[t] &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;d---travelling-through-the-snow-queens-kingdom&#34;&gt;D - Travelling Through the Snow Queen’s Kingdom&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/CF685E&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/CF685E&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;目前见过的数据范围提示性极弱（误导性极强）的循环结构题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;[BZOJ3620] 似乎在梦中见过的样子&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/20240906/#字符合并&#34;&gt;字符合并&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/20250907/#e---subset-product-problem&#34;&gt;[ARC205E] Subset Product Problem&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;正赛因为有部分分，应该不会出现不敢写的问题&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;考虑离线询问，逆序加边；原文无边权；边的通行时刻只决定到达点的时刻。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;借鉴 &lt;a href=&#34;/20231113/#b.-商人&#34;&gt;merchant&lt;/a&gt; 中的思路，只需要更新当前边两侧点为起点的 DP 数组。&lt;/p&gt;
&lt;p&gt;需要注意边从某种意义上说是『有向』的。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int inf = 0x3f3f3f3f;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, m, q;
    std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m &amp;gt;&amp;gt; q;
    struct query &amp;#123; int r, s, t, id; &amp;#125;;
    std::vector&amp;lt;int&amp;gt; res(q + 1);
    std::vector&amp;lt;std::vector&amp;lt;query&amp;gt; &amp;gt; u(m + 1);
    std::vector&amp;lt;std::pair&amp;lt;int, int&amp;gt; &amp;gt; e(m + 1);
    for (int i = 1; i &amp;lt;= m; ++i)
        std::cin &amp;gt;&amp;gt; e[i].first &amp;gt;&amp;gt; e[i].second;
    for (int i = 1, l, r, s, t; i &amp;lt;= q; ++i) &amp;#123;
        std::cin &amp;gt;&amp;gt; l &amp;gt;&amp;gt; r &amp;gt;&amp;gt; s &amp;gt;&amp;gt; t;
        u[l].push_back(&amp;#123; r, s, t, i &amp;#125;);
    &amp;#125;
    std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; g(n + 1, std::vector&amp;lt;int&amp;gt; (n + 1, inf));
    for (int i = m; i; --i) &amp;#123;
        auto [x, y] = e[i];
        g[x][y] = g[y][x] = i;
        for (int j = 1; j &amp;lt;= n; ++j)
            g[x][j] = g[y][j] = std::min(g[x][j], g[y][j]);
        for (auto [r, s, t, id] : u[i])
            if (g[s][t] &amp;lt;= r)
                res[id] = 1;
    &amp;#125;
    for (int i = 1; i &amp;lt;= q; ++i)
        std::cout &amp;lt;&amp;lt; (res[i] ? &amp;quot;Yes&amp;quot; : &amp;quot;No&amp;quot;) &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;e---culture-code&#34;&gt;E - Culture Code&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/CF1197E&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/CF1197E&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;先按 &lt;span class=&#34;math inline&#34;&gt;\(out\)&lt;/span&gt; 排序，做一个前缀优化建图。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;容易发现除了最外层，每一个套娃都会提供 &lt;span class=&#34;math inline&#34;&gt;\(in_i-out_i\)&lt;/span&gt; 的代价，而最外层会提供 &lt;span class=&#34;math inline&#34;&gt;\(in_x\)&lt;/span&gt; 的代价。&lt;/p&gt;
&lt;del&gt;好在要求的是最长路，这样就可以 Dij 了&lt;/del&gt;，并不需要真正把图建出来，发现这个形式更序列，直接在序列上二分前缀 + DP 即可。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;求方案是容易的。最后统计 DP 值最大，&lt;strong&gt;且不能被其他套娃包含的元素&lt;/strong&gt;即可。&lt;/p&gt;
&lt;p&gt;Tip：在求解过程中并不用考虑当前元素和前缀 min 元素间能否加入其他套娃，因为保证 &lt;span class=&#34;math inline&#34;&gt;\(out&amp;gt;in\)&lt;/span&gt;，如果存在这样的套娃，其 DP 值会比前缀 min 更小，矛盾。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int mod = 1e9 + 7;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n;
    std::cin &amp;gt;&amp;gt; n;
    std::vector&amp;lt;std::pair&amp;lt;int, int&amp;gt; &amp;gt; a(n + 1);
    int mxi = 0;
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        std::cin &amp;gt;&amp;gt; a[i].first &amp;gt;&amp;gt; a[i].second;
        mxi = std::max(mxi, a[i].second);
    &amp;#125;
    std::sort(a.begin() + 1, a.end());
    std::vector&amp;lt;long long&amp;gt; g(n + 1), mxg(n + 1), f(n + 1), mx(n + 1);
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        int j = std::upper_bound(a.begin() + 1, a.begin() + i, std::make_pair(a[i].second, 0x3f3f3f3f)) - a.begin() - 1;
        if (j == 0)
            f[i] = a[i].second, g[i] = 1ll;
        else
            f[i] = mx[j] + a[i].second, g[i] = mxg[j];
        long long now = f[i] - a[i].first;
        if (now &amp;lt; mx[i - 1])
            mx[i] = now, mxg[i] = g[i];
        else if (now == mx[i - 1])
            mx[i] = now, mxg[i] = (mxg[i - 1] + g[i]) % mod;
        else
            mx[i] = mx[i - 1], mxg[i] = mxg[i - 1];
    &amp;#125;
    auto now = 0x3f3f3f3fll, res = 0ll;
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        if (a[i].first &amp;lt;= mxi)
            continue;
        if (f[i] &amp;lt; now)
            now = f[i], res = g[i];
        else if (f[i] == now)
            (res += g[i]) %= mod;
    &amp;#125;
    std::cout &amp;lt;&amp;lt; res &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;a---awesome-arrowland-adventure&#34;&gt;A - Awesome Arrowland Adventure&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P6233&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P6233&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;没什么好说的建图，注意只能顺时针转&lt;/li&gt;
&lt;li&gt;代码略&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;b---地铁线路&#34;&gt;B - 地铁线路&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P6096&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P6096&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;考虑做一个神秘拆点，把每个点附上线路和运行方向的信息（所以是单向的）&lt;/li&gt;
&lt;li&gt;认为路径代价是二元组，那么同条线路中的点通行代价为 &lt;span class=&#34;math inline&#34;&gt;\((0,-1)\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;换乘需要优化建图，每个点可以花 &lt;span class=&#34;math inline&#34;&gt;\((0,0)\)&lt;/span&gt; 的代价走到这个点的『换乘点』，再花 &lt;span class=&#34;math inline&#34;&gt;\((1,0)\)&lt;/span&gt; 的代价走到另一个分点&lt;/li&gt;
&lt;li&gt;&lt;p&gt;但 &lt;strong&gt;15 年的时候 SPFA 已经死了&lt;/strong&gt;，所以需要好好考虑怎么实现最短路。&lt;/p&gt;
&lt;p&gt;分两问是有提示性在的，可以想到 01 BFS 解决第一个关键字，比较对的想法是&lt;strong&gt;把所有最短路拿出来形成 DAG，在 DAG 上对第二关键字 DP&lt;/strong&gt;。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, m;
    std::cin &amp;gt;&amp;gt; m &amp;gt;&amp;gt; n;
    std::unordered_map&amp;lt;std::string, int&amp;gt; tab;
    std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; l(n + 1);
    std::vector&amp;lt;std::vector&amp;lt;std::tuple&amp;lt;int, int, int&amp;gt; &amp;gt; &amp;gt; g0(n + 1), g1(n + 1);
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        std::string s;
        std::cin &amp;gt;&amp;gt; s, tab[s] = i;
    &amp;#125;
    int tot = n;
    for (int i = 1, k; i &amp;lt;= m; ++i) &amp;#123;
        std::cin &amp;gt;&amp;gt; k;
        int lp = 0, lq = 0;
        for (std::string s; k--; ) &amp;#123;
            std::cin &amp;gt;&amp;gt; s;
            int p = ++tot, q = ++tot, id = tab[s];
            g0.emplace_back(), g0.emplace_back();
            g1.emplace_back(), g1.emplace_back();
            if (lp) &amp;#123;
                g0[p].emplace_back(lp, 0, 1), g0[lq].emplace_back(q, 0, 1);
                g1[lp].emplace_back(p, 0, 1), g1[q].emplace_back(lq, 0, 1);
            &amp;#125;
            g0[p].emplace_back(id, 0, 0), g0[id].emplace_back(p, 1, 0);
            g1[id].emplace_back(p, 0, 0), g1[p].emplace_back(id, 1, 0);
            g0[q].emplace_back(id, 0, 0), g0[id].emplace_back(q, 1, 0);
            g1[id].emplace_back(q, 0, 0), g1[q].emplace_back(id, 1, 0);
            l[id].push_back(p), l[id].push_back(q);
            lp = p, lq = q;
        &amp;#125;
    &amp;#125;
    int s, t;
    &amp;#123;
        std::string s1, s2;
        std::cin &amp;gt;&amp;gt; s1 &amp;gt;&amp;gt; s2;
        s = ++tot, t = tab[s2];
        g0.emplace_back(), g1.emplace_back();
        int p = tab[s1];
        for (auto i : l[p])
            g0[s].emplace_back(i, 1, 0), g1[i].emplace_back(s, 1, 0);
    &amp;#125;
    std::vector&amp;lt;int&amp;gt; dis0(tot + 1, 0x3f3f3f3f), dis1(tot + 1, 0x3f3f3f3f);
    auto BFS = [&amp;amp;](decltype(g0) &amp;amp;g, decltype(dis0) &amp;amp;dis, int s) &amp;#123;
        std::deque&amp;lt;int&amp;gt; q;
        std::vector&amp;lt;int&amp;gt; vis(tot + 1);
        q.push_back(s), dis[s] = 0;
        for (; !q.empty(); ) &amp;#123;
            int x = q.front();
            q.pop_front();
            if (vis[x])
                continue;
            vis[x] = 1;
            for (auto [v, w1, w2] : g[x])
                if (dis[x] + w1 &amp;lt; dis[v]) &amp;#123;
                    dis[v] = dis[x] + w1;
                    if (w1 == 0)
                        q.push_front(v);
                    else
                        q.push_back(v);
                &amp;#125;
        &amp;#125;
        return;
    &amp;#125;;
    BFS(g0, dis0, s), BFS(g1, dis1, t);
    std::cout &amp;lt;&amp;lt; dis0[t] &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    std::vector&amp;lt;int&amp;gt; deg(tot + 1);
    std::vector&amp;lt;std::vector&amp;lt;std::pair&amp;lt;int, int&amp;gt; &amp;gt; &amp;gt; g(tot + 1);
    for (int i = 1; i &amp;lt;= tot; ++i)
        for (auto [j, w1, w2] : g0[i])
            if (dis0[i] + dis1[j] + w1 == dis0[t])
                g[i].emplace_back(j, w2), ++deg[j];
    std::queue&amp;lt;int&amp;gt; q;
    for (int i = 1; i &amp;lt;= tot; ++i)
        if (!deg[i])
            q.push(i);
    std::vector&amp;lt;int&amp;gt; f(tot + 1);
    for (; !q.empty(); ) &amp;#123;
        int x = q.front();
        q.pop();
        for (auto [v, w] : g[x]) &amp;#123;
            f[v] = std::max(f[v], f[x] + w);
            if (!--deg[v])
                q.push(v);
        &amp;#125;
    &amp;#125;
    std::cout &amp;lt;&amp;lt; f[t] &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;c---droga-do-domu&#34;&gt;C - Droga do domu&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P9402&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P9402&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;还是做一个和上一题类似的优化建图&lt;/li&gt;
&lt;li&gt;此外就是一个普通的 Dij 上 DP 了。&lt;strong&gt;图没有环&lt;/strong&gt;，直接拓扑即可。&lt;/li&gt;
&lt;li&gt;可以滚动优化空间，但似乎并无必要。代码略。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;d---tickets-p&#34;&gt;D - Tickets P&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P7984&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P7984&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;没什么好说的线段树优化建图，难点在于如何同时获取 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt; 和 &lt;span class=&#34;math inline&#34;&gt;\(N\)&lt;/span&gt; 的信息&lt;/li&gt;
&lt;li&gt;&lt;p&gt;发现从某个点走到 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt; 和 &lt;span class=&#34;math inline&#34;&gt;\(N\)&lt;/span&gt;，有一种不劣的走法：&lt;/p&gt;
&lt;img src=&#34;image.png&#34; /&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;维护一下每个点单独走到 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt;，&lt;span class=&#34;math inline&#34;&gt;\(N\)&lt;/span&gt; 的最小代价和同时走到 &lt;span class=&#34;math inline&#34;&gt;\(1,N\)&lt;/span&gt; 的最小代价&lt;/p&gt;
看到一种更加对的写法是&lt;strong&gt;令 &lt;span class=&#34;math inline&#34;&gt;\(f_u\)&lt;/span&gt; 表示 &lt;span class=&#34;math inline&#34;&gt;\(v\)&lt;/span&gt; 的答案，那么可以用 &lt;span class=&#34;math inline&#34;&gt;\(f_v+w(u,v)\)&lt;/span&gt; 更新 &lt;span class=&#34;math inline&#34;&gt;\(f_u\)&lt;/span&gt;&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;那么可以从 &lt;span class=&#34;math inline&#34;&gt;\(1,N\)&lt;/span&gt; 出发做一个 Dij。代码略。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;e---监狱&#34;&gt;E - 监狱&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P9520&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P9520&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;注意要走简单路径，也就是说不存在绕路让道的可能性。容易推出：若输入合法，总能找到一种方式使得每个人受到的指令是连续给出的。&lt;/p&gt;
&lt;p&gt;P.S. 这个结论挪到图上就不成立了，很容易举出反例。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image-1.png&#34; /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;若一个人的起点 / 终点在另一个人的路径上，那么这两个人之间存在先后关系。建图后检查是否为 DAG 即可。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;但建图显然是比较困难的，容易构造出数据使得边数来到 &lt;span class=&#34;math inline&#34;&gt;\(n^2\)&lt;/span&gt; 级别。考虑优化建图。&lt;/p&gt;
&lt;p&gt;发现可以用一个树剖 / 倍增的结构来建图。&lt;/p&gt;
Tips：这一点同样是一个树上路径问题。参见 &lt;a href=&#34;/20231117/#树上问题&#34;&gt;树上问题，倍增和树剖的选择？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;这里的路径要求两端都是开的，这就导致倍增写着很困难（虽然树剖可能也是），不排除我写丑了&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int K = 19;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;01-02.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int T;
    for (std::cin &amp;gt;&amp;gt; T; T--; ) &amp;#123;
        int n, m;
        std::cin &amp;gt;&amp;gt; n;
        std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; g1(n + 1);
        std::vector&amp;lt;int&amp;gt; s(n + 1), t(n + 1);
        for (int i = 1, x, y; i &amp;lt; n; ++i) &amp;#123;
            std::cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; y;
            g1[x].push_back(y), g1[y].push_back(x);
        &amp;#125;
        std::cin &amp;gt;&amp;gt; m;
        std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; g(m + 1);
        std::vector&amp;lt;std::pair&amp;lt;int, int&amp;gt; &amp;gt; a(m + 1);
        for (int i = 1; i &amp;lt;= m; ++i) &amp;#123;
            std::cin &amp;gt;&amp;gt; a[i].first &amp;gt;&amp;gt; a[i].second;
            s[a[i].first] = i;
            t[a[i].second] = i;
        &amp;#125;
        int cnt = m;
        struct node &amp;#123; int fa, i0, i1; &amp;#125;;
        std::vector&amp;lt;std::array&amp;lt;node, K + 1&amp;gt; &amp;gt; p(n + 1);
        std::vector&amp;lt;int&amp;gt; i0(n + 1), i1(n + 1), dep(n + 1), deg(m + 1);
        auto init = [&amp;amp;](void) &amp;#123;
            g.emplace_back(), deg.emplace_back();
            return ++cnt;
        &amp;#125;;
        auto add = [&amp;amp;](int x, int y) &amp;#123;
            g[x].push_back(y), ++deg[y];
            return;
        &amp;#125;;
        for (int i = 1; i &amp;lt;= n; ++i)
            i0[i] = init(), i1[i] = init();
        std::function&amp;lt;void(int, int)&amp;gt; DFS = [&amp;amp;](int x, int fa) &amp;#123;
            if (s[x])
                add(s[x], i1[x]);
            if (t[x])
                add(i0[x], t[x]);
            for (auto i : g1[x])
                if (i != fa) &amp;#123;
                    dep[i] = dep[x] + 1;
                    p[i][0].fa = x;
                    p[i][0].i0 = init(), p[i][0].i1 = init();
                    add(p[i][0].i0, i0[i]), add(i1[i], p[i][0].i1);
                    for (int j = 1; j &amp;lt;= K; ++j) &amp;#123;
                        p[i][j].fa = p[p[i][j - 1].fa][j - 1].fa;
                        if (!p[i][j].fa)
                            break;
                        p[i][j].i0 = init(), p[i][j].i1 = init();
                        add(p[i][j].i0, p[i][j - 1].i0);
                        add(p[i][j].i0, p[p[i][j - 1].fa][j - 1].i0);
                        add(p[i][j - 1].i1, p[i][j].i1);
                        add(p[p[i][j - 1].fa][j - 1].i1, p[i][j].i1);
                    &amp;#125;
                    DFS(i, x);
                &amp;#125;
            return;
        &amp;#125;;
        dep[1] = 1, DFS(1, -1);
        for (int i = 1; i &amp;lt;= m; ++i) &amp;#123;
            auto [x, y] = a[i];
            if (x == y)
                continue;
            if (t[x])
                add(i, t[x]);
            if (s[y])
                add(s[y], i);
            if (dep[x] &amp;lt; dep[y])
                std::swap(x, y);
            x = p[x][0].fa;
            if (dep[x] &amp;gt;= dep[y]) &amp;#123;
                for (int j = K; ~j; --j)
                    if (dep[p[x][j].fa] &amp;gt;= dep[y]) &amp;#123;
                        add(i, p[x][j].i0), add(p[x][j].i1, i);
                        x = p[x][j].fa;
                    &amp;#125;
                if (x == y)
                    continue;
                add(i, p[x][0].i0), add(p[x][0].i1, i);
                x = p[x][0].fa;
            &amp;#125;
            y = p[y][0].fa;
            if (x != y) &amp;#123;
                for (int j = K; ~j; --j)
                    if (p[x][j].fa != p[y][j].fa) &amp;#123;
                        add(i, p[x][j].i0), add(i, p[y][j].i0);
                        add(p[x][j].i1, i), add(p[y][j].i1, i);
                        x = p[x][j].fa, y = p[y][j].fa;
                    &amp;#125;
                add(i, p[x][0].i0), add(i, p[y][0].i0);
                add(p[x][0].i1, i), add(p[y][0].i1, i);
                x = p[x][0].fa;
            &amp;#125;
            add(i, i0[x]), add(i1[x], i);
        &amp;#125;
        std::queue&amp;lt;int&amp;gt; q;
        for (int i = 1; i &amp;lt;= cnt; ++i)
            if (!deg[i])
                q.push(i);
        int tot = 0;
        for (; !q.empty(); ) &amp;#123;
            int x = q.front();
            q.pop(), ++tot;
            for (auto i : g[x])
                if (!--deg[i])
                    q.push(i);
        &amp;#125;
        std::cout &amp;lt;&amp;lt; (tot == cnt ? &amp;quot;Yes&amp;quot; : &amp;quot;No&amp;quot;) &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    &amp;#125;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://xsc062.netlify.app/20250922/</guid>
            <title>杂题</title>
            <link>https://xsc062.netlify.app/20250922/</link>
            <category>DP</category>
            <pubDate>Mon, 22 Sep 2025 18:37:38 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;最近的几场 abc, arc, cf, 模拟赛题&lt;/p&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;g---set-list&#34;&gt;G - Set list&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/abc424/tasks/abc424_g&#34; class=&#34;uri&#34;&gt;https://atcoder.jp/contests/abc424/tasks/abc424_g&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;b---slime-swap&#34;&gt;B - Slime Swap&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/arc206/tasks/arc206_b&#34; class=&#34;uri&#34;&gt;https://atcoder.jp/contests/arc206/tasks/arc206_b&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;d---lis-lds&#34;&gt;D - LIS ∩ LDS&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/arc206/tasks/arc206_d&#34; class=&#34;uri&#34;&gt;https://atcoder.jp/contests/arc206/tasks/arc206_d&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;bubble-sort&#34;&gt;#3761. Bubble Sort&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://poj.org/problem?id=3761&#34; class=&#34;uri&#34;&gt;http://poj.org/problem?id=3761&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;f.-bubble-sort&#34;&gt;F. Bubble Sort&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://codeforces.com/contest/2146/problem/F&#34; class=&#34;uri&#34;&gt;https://codeforces.com/contest/2146/problem/F&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;e.-limited-edition-shop&#34;&gt;E. Limited Edition Shop&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://codeforces.com/contest/2151/problem/E&#34; class=&#34;uri&#34;&gt;https://codeforces.com/contest/2151/problem/E&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;构造几个 &lt;span class=&#34;math inline&#34;&gt;\(n=2,3\)&lt;/span&gt; 的例子手玩一下，会发现对于 &lt;span class=&#34;math inline&#34;&gt;\(a,b\)&lt;/span&gt; 两个元素，如果在 A 里的相对顺序是 ab，在 B 里的相对顺序是 ba，那么要选 b 就必须选 a。&lt;/li&gt;
&lt;li&gt;那么会想到把 A 变成 &lt;span class=&#34;math inline&#34;&gt;\(1\sim n\)&lt;/span&gt;，那么对于 B 中的一个元素，如果其后方有更小的元素，那么必须选了它才能选这个数。&lt;/li&gt;
&lt;li&gt;考虑在 B 中 DP 最后选出来的集合，那么对于当前的 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt;，&lt;strong&gt;若不选，则不允许『已选集合』中存在 &lt;span class=&#34;math inline&#34;&gt;\(&amp;gt;x\)&lt;/span&gt; 的数。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;故令 &lt;span class=&#34;math inline&#34;&gt;\(f_{i,j}\)&lt;/span&gt; 表示 DP 到 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt;，当前已选集合最大值为 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; 的最大集合大小，那么有：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
f_{i,B_i}\gets f_{i-1,j}+v, j&amp;lt;B_i\\
f_{i,j}\gets f_{i-1, j}+v, j &amp;gt; B_i\\
f_{i,j}\gets f_{i-1,j}, j &amp;lt; B_i
\]&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;显然可以线段树优化转移&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int maxn = 2e5 + 5;
const long long inf = 1e18;
struct &amp;#123;
    int l, r;
    long long u, d;
&amp;#125; t[maxn &amp;lt;&amp;lt; 2];
#define lt (p &amp;lt;&amp;lt; 1)
#define rt (lt | 1)
void pushval(int p, long long v) &amp;#123;
    t[p].d += v, t[p].u += v;
    return;
&amp;#125;
void pushdown(int p) &amp;#123;
    pushval(lt, t[p].d), pushval(rt, t[p].d);
    t[p].d = 0ll;
    return;
&amp;#125;
void pushup(int p) &amp;#123;
    t[p].u = std::max(t[lt].u, t[rt].u);
    return;
&amp;#125;
void bld(int p, int l, int r) &amp;#123;
    t[p].l = l, t[p].r = r;
    t[p].u = -inf, t[p].d = 0ll;
    if (l == r)
        return;
    int mid = (t[p].l + t[p].r) &amp;gt;&amp;gt; 1;
    bld(lt, l, mid), bld(rt, mid + 1, r);
    return;
&amp;#125;
void upd(int p, int x, long long v) &amp;#123;
    t[p].u = std::max(t[p].u, v);
    if (t[p].l == t[p].r)
        return;
    pushdown(p);
    int mid = (t[p].l + t[p].r) &amp;gt;&amp;gt; 1;
    if (x &amp;lt;= mid)
        upd(lt, x, v);
    else
        upd(rt, x, v);
    return;
&amp;#125;
void add(int p, int l, int r, long long v) &amp;#123;
    if (l &amp;lt;= t[p].l &amp;amp;&amp;amp; t[p].r &amp;lt;= r) &amp;#123;
        pushval(p, v);
        return;
    &amp;#125;
    pushdown(p);
    int mid = (t[p].l + t[p].r) &amp;gt;&amp;gt; 1;
    if (l &amp;lt;= mid)
        add(lt, l, r, v);
    if (r &amp;gt; mid)
        add(rt, l, r, v);
    pushup(p);
    return;
&amp;#125;
long long ask(int p, int l, int r) &amp;#123;
    if (l &amp;lt;= t[p].l &amp;amp;&amp;amp; t[p].r &amp;lt;= r)
        return t[p].u;
    pushdown(p);
    long long res = -inf;
    int mid = (t[p].l + t[p].r) &amp;gt;&amp;gt; 1;
    if (l &amp;lt;= mid)
        res = ask(lt, l, r);
    if (r &amp;gt; mid)
        res = std::max(res, ask(rt, l, r));
    return res;
&amp;#125;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int T;
    for (std::cin &amp;gt;&amp;gt; T; T--; ) &amp;#123;
        int n;
        std::cin &amp;gt;&amp;gt; n;
        std::vector&amp;lt;int&amp;gt; w(n + 1), k(n + 1), a(n + 1), b(n + 1), tab(n + 1);
        for (int i = 1; i &amp;lt;= n; ++i)
            std::cin &amp;gt;&amp;gt; w[i];
        for (int i = 1; i &amp;lt;= n; ++i)
            std::cin &amp;gt;&amp;gt; a[i], tab[a[i]] = i;
        for (int i = 1; i &amp;lt;= n; ++i)
            k[i] = w[a[i]];
        for (int i = 1; i &amp;lt;= n; ++i)
            std::cin &amp;gt;&amp;gt; b[i], b[i] = tab[b[i]];
        bld(1, 0, n), upd(1, 0, 0);
        for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
            if (b[i] != n)
                add(1, b[i] + 1, n, k[b[i]]);
            upd(1, b[i], ask(1, 0, b[i] - 1) + k[b[i]]);
        &amp;#125;
        std::cout &amp;lt;&amp;lt; t[1].u &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    &amp;#125;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;a.-小猪盖房子&#34;&gt;A. 小猪盖房子&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.becoder.com.cn/problem/51898&#34; class=&#34;uri&#34;&gt;https://www.becoder.com.cn/problem/51898&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定一个 &lt;span class=&#34;math inline&#34;&gt;\(n\times m\)&lt;/span&gt; 的 01 矩阵，每一行有 2 个 1 或没有 1。现需选择两个&lt;strong&gt;相邻的&lt;/strong&gt;行区间，并为&lt;strong&gt;范围内的空行&lt;/strong&gt;选择两个位置改为 1，使得这两个区间是全等的。&lt;/p&gt;
&lt;p&gt;求可能的方案。当空行的涂色方式不同或选择范围不同看作不同的方案。对 &lt;span class=&#34;math inline&#34;&gt;\(998244353\)&lt;/span&gt; 取模。&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(n,m\le 5000\)&lt;/span&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;第一反应是枚举分界线 + 上端点，发现没有办法做：当上端点移动的时候，下部矩形会整体平移。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;进一步考虑导致这个问题的原因&lt;/strong&gt;，感受到一个因素是长度在变。&lt;/li&gt;
&lt;li&gt;故固定长度枚举，前缀和统计 &lt;span class=&#34;math inline&#34;&gt;\(\dfrac {m(m-1)}2\)&lt;/span&gt; 的幂次即可。&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int mod = 998244353;
int main() &amp;#123;
    std::freopen(&amp;quot;piggy.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;piggy.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
    const auto stime = std::chrono::steady_clock::now();
    int n, m;
    std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
    std::vector&amp;lt;std::array&amp;lt;int, 2&amp;gt; &amp;gt; a(n + 1);
    std::vector&amp;lt;long long&amp;gt; ps(n + 1);
    const int s = m * (m - 1) / 2;
    ps[0] = 1ll;
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        std::cin &amp;gt;&amp;gt; a[i][0] &amp;gt;&amp;gt; a[i][1];
        ps[i] = ps[i - 1] * s % mod;
    &amp;#125;
    auto res = 0ll;
    for (int i = 1; i &amp;lt;= n / 2; ++i) &amp;#123;
        std::vector&amp;lt;int&amp;gt; cnt0(n + 1), cnts(n + 1);
        for (int u = 1; u &amp;lt;= n - i; ++u) &amp;#123;
            int d = u + i;
            if (!a[u][0] &amp;amp;&amp;amp; !a[d][0])
                cnts[u] = 1;
            else if (a[u][0] &amp;amp;&amp;amp; a[d][0] &amp;amp;&amp;amp; (a[u][0] != a[d][0] || a[u][1] != a[d][1]))
                cnt0[u] = 1;
            cnts[u] += cnts[u - 1], cnt0[u] += cnt0[u - 1];
        &amp;#125;
        for (int u = 1; u &amp;lt;= n - 2 * i + 1; ++u) &amp;#123;
            int ss = cnts[u + i - 1] - cnts[u - 1], s0 = cnt0[u + i - 1] - cnt0[u - 1];
            if (!s0)
                (res += ps[ss] % mod) %= mod;
        &amp;#125;
    &amp;#125;
    std::cout &amp;lt;&amp;lt; res &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;b.-换乘旅行&#34;&gt;B. 换乘旅行&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.becoder.com.cn/problem/51900&#34; class=&#34;uri&#34;&gt;https://www.becoder.com.cn/problem/51900&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;手玩可以发现『环』在题目中是一个很重要的东西&lt;/li&gt;
&lt;li&gt;重要性质：考虑一个环第一次被访问的点，一定会从这个点出发把这个环访问一遍，反证法易证。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;故可以把每个环给『删除』。可以用下图概括所有情况。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;假设当前以 &lt;span class=&#34;math inline&#34;&gt;\(s\)&lt;/span&gt; 为起点，终点为 &lt;span class=&#34;math inline&#34;&gt;\(t\)&lt;/span&gt;，且之前已经在以 &lt;span class=&#34;math inline&#34;&gt;\(s&amp;#39;\)&lt;/span&gt; 为起点时访问过了一部分路径上的点。&lt;/p&gt;
&lt;p&gt;那么此时 &lt;span class=&#34;math inline&#34;&gt;\(m\to t\)&lt;/span&gt; 是有答案的，而 &lt;span class=&#34;math inline&#34;&gt;\(s\to m\)&lt;/span&gt; 都可以继承 &lt;span class=&#34;math inline&#34;&gt;\(m\)&lt;/span&gt; 的答案。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::freopen(&amp;quot;travel.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;travel.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n;
    std::cin &amp;gt;&amp;gt; n;
    std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; g(n + 1);
    std::vector&amp;lt;std::vector&amp;lt;int&amp;gt;::iterator&amp;gt; it(n + 1);
    for (int i = 1, k; i &amp;lt;= n; ++i) &amp;#123;
        std::cin &amp;gt;&amp;gt; k;
        for (int x; k--; )
            std::cin &amp;gt;&amp;gt; x, g[i].push_back(x);
        it[i] = g[i].begin();
    &amp;#125;
    std::vector&amp;lt;int&amp;gt; res(n + 1), inq(n + 1);
    for (int i = 1; i &amp;lt;= n; ++i)
        if (!res[i]) &amp;#123;
            std::stack&amp;lt;int&amp;gt; st;
            for (int x = i; ; ) &amp;#123;
                if (it[x] == g[x].end() || res[x]) &amp;#123;
                    if (!res[x])
                        res[x] = x;
                    res[i] = res[x];
                    for (; !st.empty(); st.pop())
                        res[st.top()] = res[x], inq[st.top()] = 0;
                    break;
                &amp;#125;
                st.push(x), inq[x] = 1, x = *it[x];
                if (inq[x])
                    for (int p = -1; p != x; ) &amp;#123;
                        p = st.top(), st.pop();
                        inq[p] = 0, ++it[p];
                    &amp;#125;
            &amp;#125;
        &amp;#125;
    for (int i = 1; i &amp;lt;= n; ++i)
        std::cout &amp;lt;&amp;lt; res[i] &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;c.-优美的街景&#34;&gt;C. 优美的街景&lt;/h2&gt;
&lt;p&gt;no link&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定 &lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt; 的排列 &lt;span class=&#34;math inline&#34;&gt;\(a_{1\cdots n}\)&lt;/span&gt;，现定义『优美子段』&lt;span class=&#34;math inline&#34;&gt;\([l,r]\)&lt;/span&gt;：存在 &lt;span class=&#34;math inline&#34;&gt;\(l\le t&amp;lt;r\)&lt;/span&gt;，使得 &lt;span class=&#34;math inline&#34;&gt;\(\max\{a_{l\sim t}\}&amp;lt;\min\{a_{t+1\sim r}\}\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;求出该排列『优美子段』的个数，&lt;span class=&#34;math inline&#34;&gt;\(n\le 3\times 10^5\)&lt;/span&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;由经典 trick 出发，一个想法是从小到大枚举分解值 &lt;span class=&#34;math inline&#34;&gt;\(v\)&lt;/span&gt;，并把 &lt;span class=&#34;math inline&#34;&gt;\(\le v\)&lt;/span&gt; 的值涂成白色，剩下的涂成黑色。&lt;/p&gt;
&lt;p&gt;那么此时一个前白后黑的子段是优美的。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;令值为 &lt;span class=&#34;math inline&#34;&gt;\(v\)&lt;/span&gt; 的元素必须参与子段组成。枚举 &lt;span class=&#34;math inline&#34;&gt;\(v\)&lt;/span&gt; 时，序列每个点颜色已知，即 &lt;span class=&#34;math inline&#34;&gt;\(v\)&lt;/span&gt; 所在的优美子段被包含于 &lt;span class=&#34;math inline&#34;&gt;\(v\)&lt;/span&gt; 所在的白黑子段中。&lt;/p&gt;
&lt;p&gt;求出该子段，则包含 &lt;span class=&#34;math inline&#34;&gt;\(v\)&lt;/span&gt; 的优美子段，左右端点各有范围，且不会相互影响。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;此时不可直接计数：一个优美子段会被其中所有合法分割点统计。故做一个 &lt;a href=&#34;https://www.luogu.com.cn/problem/P5490&#34;&gt;亚特兰蒂斯&lt;/a&gt; 即可。&lt;/p&gt;
&lt;p&gt;如果像我一样没有甚区间问题经验，可以用 0 覆盖次数这个 trick 来反向求。&lt;del&gt;因而被群嘲了&lt;/del&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int maxn = 3e5 + 5;
struct &amp;#123;
    int l, r, mn, u, d;
&amp;#125; t[maxn &amp;lt;&amp;lt; 2];
#define lt (p &amp;lt;&amp;lt; 1)
#define rt (lt | 1)
void bld(int p, int l, int r) &amp;#123;
    t[p].l = l, t[p].r = r;
    t[p].u = r - l + 1;
    if (l == r)
        return;
    int mid = (l + r) &amp;gt;&amp;gt; 1;
    bld(lt, l, mid), bld(rt, mid + 1, r);
    return;
&amp;#125;
void pushval(int p, int v) &amp;#123;
    t[p].d += v, t[p].mn += v;
    return;
&amp;#125;
void pushdown(int p) &amp;#123;
    pushval(lt, t[p].d), pushval(rt, t[p].d);
    t[p].d = 0;
    return;
&amp;#125;
void pushup(int p) &amp;#123;
    t[p].u = 0;
    t[p].mn = std::min(t[lt].mn, t[rt].mn);
    if (t[lt].mn == t[p].mn)
        t[p].u = t[lt].u;
    if (t[rt].mn == t[p].mn)
        t[p].u += t[rt].u;
    return;
&amp;#125;
void add(int p, int l, int r, int v) &amp;#123;
    if (l &amp;lt;= t[p].l &amp;amp;&amp;amp; t[p].r &amp;lt;= r) &amp;#123;
        pushval(p, v);
        return;
    &amp;#125;
    pushdown(p);
    int mid = (t[p].l + t[p].r) &amp;gt;&amp;gt; 1;
    if (l &amp;lt;= mid)
        add(lt, l, r, v);
    if (r &amp;gt; mid)
        add(rt, l, r, v);
    pushup(p);
    return;
&amp;#125;
#undef lt
#undef rt
int main() &amp;#123;
    std::freopen(&amp;quot;street.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;street.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
    const auto stime = std::chrono::steady_clock::now();
    int n;
    std::cin &amp;gt;&amp;gt; n;
    std::vector&amp;lt;int&amp;gt; a(n + 1), tab(n + 1);
    std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; mn(20, std::vector&amp;lt;int&amp;gt; (n + 1)), mx(20, std::vector&amp;lt;int&amp;gt; (n + 1));
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        std::cin &amp;gt;&amp;gt; a[i];
        tab[a[i]] = i, mn[0][i] = mx[0][i] = a[i];
    &amp;#125;
    for (int j = 1; (1 &amp;lt;&amp;lt; j) &amp;lt;= n; ++j)
        for (int i = 1; i + (1 &amp;lt;&amp;lt; j) - 1 &amp;lt;= n; ++i) &amp;#123;
            mn[j][i] = std::min(mn[j - 1][i], mn[j - 1][i + (1 &amp;lt;&amp;lt; (j - 1))]);
            mx[j][i] = std::max(mx[j - 1][i], mx[j - 1][i + (1 &amp;lt;&amp;lt; (j - 1))]);
        &amp;#125;
    auto askmn = [&amp;amp;](int l, int r) &amp;#123;
        int k = std::__lg(r - l + 1);
        return std::min(mn[k][l], mn[k][r - (1 &amp;lt;&amp;lt; k) + 1]);
    &amp;#125;;
    auto askmx = [&amp;amp;](int l, int r) &amp;#123;
        int k = std::__lg(r - l + 1);
        return std::max(mx[k][l], mx[k][r - (1 &amp;lt;&amp;lt; k) + 1]);
    &amp;#125;;
    auto res = 0ll;
    std::vector&amp;lt;std::vector&amp;lt;std::tuple&amp;lt;int, int, int&amp;gt; &amp;gt; &amp;gt; t(n + 1);
    auto ask1 = [&amp;amp;](int x, int v) &amp;#123; // 找到 x 左侧最后一个 &amp;lt;= v 的
        int res = x;
        for (int l = 1, r = x, mid; l &amp;lt;= r; ) &amp;#123;
            mid = (l + r) &amp;gt;&amp;gt; 1;
            if (askmx(mid, x) &amp;lt;= v)
                r = mid - 1, res = mid;
            else
                l = mid + 1;
        &amp;#125;
        return res;
    &amp;#125;;
    auto ask2 = [&amp;amp;](int x, int v) &amp;#123; // 找到 x 右侧第一个 &amp;gt; v 的
        int res = -1;
        for (int l = x + 1, r = n, mid; l &amp;lt;= r; ) &amp;#123;
            mid = (l + r) &amp;gt;&amp;gt; 1;
            if (askmx(x, mid) &amp;gt; v)
                r = mid - 1, res = mid;
            else
                l = mid + 1;
        &amp;#125;
        return res;
    &amp;#125;;
    auto ask3 = [&amp;amp;](int x, int v) &amp;#123; // 找到 x 右侧最后一个 &amp;gt; v 的
        int res = x;
        for (int l = x, r = n, mid; l &amp;lt;= r; ) &amp;#123;
            mid = (l + r) &amp;gt;&amp;gt; 1;
            if (askmn(x, mid) &amp;gt; v)
                l = mid + 1, res = mid;
            else
                r = mid - 1;
        &amp;#125;
        return res;
    &amp;#125;;
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        int cr = ask1(tab[i], i), tl = ask2(tab[i], i);
        if (tl != -1) &amp;#123;
            int tr = ask3(tl, i);
            t[cr].emplace_back(1, tl, tr);
            if (tab[i] != n)
                t[tab[i] + 1].emplace_back(-1, tl, tr);
        &amp;#125;
    &amp;#125;
    bld(1, 0, n);
    std::vector&amp;lt;int&amp;gt; cnt(n + 1);
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        std::sort(t[i].begin(), t[i].end(), std::greater&amp;lt;std::tuple&amp;lt;int, int, int&amp;gt; &amp;gt; ());
        for (auto [k, l, r] : t[i])
            add(1, l, r, k);
        res += n + 1 - ::t[1].u;
    &amp;#125;
    std::cout &amp;lt;&amp;lt; res &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://xsc062.netlify.app/20250921/</guid>
            <title>线段树杂题</title>
            <link>https://xsc062.netlify.app/20250921/</link>
            <category>线段树</category>
            <pubDate>Sun, 21 Sep 2025 16:44:54 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;信息转化为主&lt;/p&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;b---into-blocks-hard-version&#34;&gt;B - Into Blocks (hard version)&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/CF1209G2&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/CF1209G2&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;trick：考察每个颜色出现的区间 &lt;span class=&#34;math inline&#34;&gt;\([s_{col},t_{col}]\)&lt;/span&gt;，对每个 &lt;span class=&#34;math inline&#34;&gt;\([s_{col},t_{col})\)&lt;/span&gt; 打标记，则没有被打过标记的点后能够进行一次分段。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;对于每一段，其代价为段长度 - 众数出现次数。&lt;/p&gt;
这个众数乍一看有点吓人，实际上发现由于每个元素出现的所有位置都在这个段里，所以可以记录每个元素的个数，对于每个元素只钦定其中一个位置来记录即可快速维护。&lt;/li&gt;
&lt;li&gt;发现线段树能够比较容易地维护全局查询：维护 &lt;span class=&#34;math inline&#34;&gt;\(0\)&lt;/span&gt; 位置是经典 trick；且容易发现『段长』之和为 &lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt;，故只需维护众数。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;实现技巧：单点本身就是自己的最小值，从这一点出发可以规避很多边界情况。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int lim = 2e5;
const int maxn = 2e5 + 5;
struct node &amp;#123;
    int l, r, u, d;
    int lu, ru, mn, mx;
    node operator+ (const node &amp;amp;q) const &amp;#123;
        node res;
        res.d = 0;
        res.l = l, res.r = q.r;
        res.mx = std::max(mx, q.mx);
        res.mn = std::min(mn, q.mn);
        if (mn &amp;lt; q.mn) &amp;#123;
            res.mn = mn, res.u = u;
            res.lu = lu, res.ru = std::max(q.mx, ru);
        &amp;#125;
        else if (q.mn &amp;lt; mn) &amp;#123;
            res.mn = q.mn, res.u = q.u;
            res.lu = std::max(mx, q.lu), res.ru = q.ru;
        &amp;#125;
        else &amp;#123;
            res.lu = lu, res.ru = q.ru;
            res.u = u + q.u + std::max(ru, q.lu);
        &amp;#125;
        return res;
    &amp;#125;
&amp;#125; t[maxn &amp;lt;&amp;lt; 2];
#define lt (p &amp;lt;&amp;lt; 1)
#define rt (lt | 1)
void bld(int p, int l, int r) &amp;#123;
    t[p].l = l, t[p].r = r;
    if (l == r)
        return;
    int mid = (l + r) &amp;gt;&amp;gt; 1;
    bld(lt, l, mid), bld(rt, mid + 1, r);
    return;
&amp;#125;
void pushval(int p, int d) &amp;#123;
    t[p].mn += d, t[p].d += d;
    return;
&amp;#125;
void pushdown(int p) &amp;#123;
    pushval(lt, t[p].d), pushval(rt, t[p].d);
    t[p].d = 0;
    return;
&amp;#125;
void upd(int p, int x, int v) &amp;#123;
    if (t[p].l == t[p].r) &amp;#123;
        t[p].u = t[p].mx = v;
        return;
    &amp;#125;
    pushdown(p);
    int mid = (t[p].l + t[p].r) &amp;gt;&amp;gt; 1;
    if (x &amp;lt;= mid)
        upd(lt, x, v);
    else
        upd(rt, x, v);
    t[p] = t[lt] + t[rt];
    return;
&amp;#125;
void add(int p, int l, int r, int v) &amp;#123;
    if (l &amp;lt;= t[p].l &amp;amp;&amp;amp; t[p].r &amp;lt;= r) &amp;#123;
        pushval(p, v);
        return;
    &amp;#125;
    pushdown(p);
    int mid = (t[p].l + t[p].r) &amp;gt;&amp;gt; 1;
    if (l &amp;lt;= mid)
        add(lt, l, r, v);
    if (r &amp;gt; mid)
        add(rt, l, r, v);
    t[p] = t[lt] + t[rt];
    return;
&amp;#125;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, q;
    std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; q;
    std::vector&amp;lt;int&amp;gt; a(n + 1);
    std::vector&amp;lt;std::set&amp;lt;int&amp;gt; &amp;gt; st(lim + 1);
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        std::cin &amp;gt;&amp;gt; a[i];
        st[a[i]].emplace(i);
    &amp;#125;
    bld(1, 1, n);
    for (int i = 1; i &amp;lt;= lim; ++i)
        if (!st[i].empty()) &amp;#123;
            int s = *st[i].begin(), t = *--st[i].end();
            if (s &amp;lt;= t - 1)
                add(1, s, t - 1, 1);
            upd(1, s, (int)st[i].size());
        &amp;#125;
    std::cout &amp;lt;&amp;lt; n - ::t[1].u - ::t[1].lu - ::t[1].ru  &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    auto work = [&amp;amp;](int v, int k) &amp;#123;
        if (st[v].empty())
            return;
        int s = *st[v].begin(), t = *--st[v].end();
        if (s &amp;lt;= t - 1)
            add(1, s, t - 1, k);
        upd(1, s, k == 1 ? (int)st[v].size() : 0);
        return;
    &amp;#125;;
    for (int i, x; q--; ) &amp;#123;
        std::cin &amp;gt;&amp;gt; i &amp;gt;&amp;gt; x;
        work(a[i], -1), st[a[i]].erase(i), work(a[i], 1);
        a[i] = x;
        work(a[i], -1), st[a[i]].insert(i), work(a[i], 1);
        std::cout &amp;lt;&amp;lt; n - ::t[1].u - ::t[1].lu - ::t[1].ru  &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    &amp;#125;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;c---seats-排座位&#34;&gt;C - seats 排座位&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P4898&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P4898&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;很有价值的一个题&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;对于一个固定的 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt;，考虑怎么刻画合法矩形&lt;/p&gt;
&lt;p&gt;发现『前 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 个元素构成矩形』比『大小为 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 的矩形包含前 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 个元素』更合理&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;考虑前 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 个元素在满足什么条件时构成矩形&lt;/p&gt;
&lt;p&gt;我最开始的想法是『记录这 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 个元素占据的最大、最小、最左、最右，如果乘起来为 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt;，那么合法』&lt;/p&gt;
&lt;p&gt;但会发现这个转化是不好做的，或者说就又往上面那个错误的判定转化（大小为 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 的矩形包含前 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 个元素）靠了。两个都有一个共同的问题，就是过于依赖这个 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt;，限制太具体了，导致不能很好地应用到每个 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;现在这个判定的转化比较合理的地方就在于，对矩形本身不存在约束，只是要求构成矩形。这样就允许直接从图形出发，&lt;strong&gt;更多地考虑怎样用单点信息合并出矩形与否&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;把 &lt;span class=&#34;math inline&#34;&gt;\([0,k)\)&lt;/span&gt; 染成黑色，其他为白色，那么有一个粗暴但简单的方法来刻画『矩形』这个要求：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;图形存在四个『角』。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;再刻画一下『角』：黑点左上 / 左下 / 右上 / 右下两个点都为白。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;当然这样是很荒谬的，因为下图显然不只有四个角。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image-1.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;所以我们不得不把一个凹角也算作角，不难发现把上方凸角的定义中的主体换成白点即可定义凹角。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;优化：算贡献&lt;/p&gt;
&lt;p&gt;维护当前时刻，所有 &lt;span class=&#34;math inline&#34;&gt;\(4nm\)&lt;/span&gt; 个角在 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 处是否存在&lt;/p&gt;
&lt;p&gt;此时要用一个类似维护 &lt;span class=&#34;math inline&#34;&gt;\(0\)&lt;/span&gt; 个数的方法来维护有 &lt;span class=&#34;math inline&#34;&gt;\(4\)&lt;/span&gt; 个角个数的 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 个数。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;考虑这么一个可能的角：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;其存在当且仅当 &lt;span class=&#34;math inline&#34;&gt;\(A\)&lt;/span&gt; 为黑，&lt;span class=&#34;math inline&#34;&gt;\(B,C\)&lt;/span&gt; 为白（凸角），或 &lt;span class=&#34;math inline&#34;&gt;\(A\)&lt;/span&gt; 为白，&lt;span class=&#34;math inline&#34;&gt;\(B,C\)&lt;/span&gt; 为黑（凹角）。&lt;/p&gt;
&lt;p&gt;考察 &lt;span class=&#34;math inline&#34;&gt;\(A,B,C\)&lt;/span&gt; 第一次变黑的时间 &lt;span class=&#34;math inline&#34;&gt;\(k_A,k_B,k_C\)&lt;/span&gt;，那么 &lt;span class=&#34;math inline&#34;&gt;\(A\)&lt;/span&gt; 能够对所有 &lt;span class=&#34;math inline&#34;&gt;\(k\in[k_A,\min\{k_B,k_C\})\)&lt;/span&gt; 和 &lt;span class=&#34;math inline&#34;&gt;\(k\in[\max\{k_B,k_C\},k_A)\)&lt;/span&gt; 造成贡献。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;每次修改只会做 &lt;span class=&#34;math inline&#34;&gt;\(O(1)\)&lt;/span&gt; 次区间加，是可维护的。注意两个被交换的点可能会有公共的相邻点，需要特别处理一下。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;这个东西本质上可以看作一个 2⨉2 的&lt;a href=&#34;https://blog.csdn.net/asplh/article/details/136652197&#34;&gt;Soble 算子&lt;/a&gt;，所以可以抠出来一般定义上的角&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;p&gt;non-interactive version:&lt;/p&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int dir[][2] = &amp;#123; &amp;#123; 0, -1 &amp;#125;, &amp;#123; 0, 1 &amp;#125;, &amp;#123; -1, 0 &amp;#125;, &amp;#123; 1, 0 &amp;#125; &amp;#125;;
const int maxn = 1e6 + 5;
struct node &amp;#123;
    int l, r, u, d, mn;
    node operator+ (const node &amp;amp;q) const &amp;#123;
        node res;
        res.l = l, res.r = q.r, res.d = 0;
        res.mn = std::min(mn, q.mn), res.u = 0;
        if (mn == res.mn)
            res.u = u;
        if (q.mn == res.mn)
            res.u += q.u;
        return res;
    &amp;#125;
&amp;#125; t[maxn &amp;lt;&amp;lt; 2];
#define lt (p &amp;lt;&amp;lt; 1)
#define rt (lt | 1)
void bld(int p, int l, int r) &amp;#123;
    t[p].l = l, t[p].r = r, t[p].u = r - l + 1;
    if (l == r)
        return;
    int mid = (l + r) &amp;gt;&amp;gt; 1;
    bld(lt, l, mid), bld(rt, mid + 1, r);
    return;
&amp;#125;
void pushval(int p, int v) &amp;#123;
    t[p].mn += v, t[p].d += v;
    return;
&amp;#125;
void pushdown(int p) &amp;#123;
    pushval(lt, t[p].d), pushval(rt, t[p].d);
    t[p].d = 0;
    return;
&amp;#125;
void add(int p, int l, int r, int v) &amp;#123;
    if (l &amp;lt;= t[p].l &amp;amp;&amp;amp; t[p].r &amp;lt;= r) &amp;#123;
        pushval(p, v);
        return;
    &amp;#125;
    pushdown(p);
    int mid = (t[p].l + t[p].r) &amp;gt;&amp;gt; 1;
    if (l &amp;lt;= mid)
        add(lt, l, r, v);
    if (r &amp;gt; mid)
        add(rt, l, r, v);
    t[p] = t[lt] + t[rt];
    return;
&amp;#125;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, m, q;
    std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m &amp;gt;&amp;gt; q;
    const int N = n * m;
    std::vector&amp;lt;std::pair&amp;lt;int, int&amp;gt; &amp;gt; pos(N + 1);
    std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; id(n + 2, std::vector&amp;lt;int&amp;gt; (m + 2, N + 1));
    for (int i = 1, x, y; i &amp;lt;= N; ++i) &amp;#123;
        std::cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; y, ++x, ++y;
        id[x][y] = i, pos[i] = &amp;#123; x, y &amp;#125;;
    &amp;#125;
    bld(1, 1, N);
    auto work = [&amp;amp;](int x, int y, int k) &amp;#123;
        for (int i = 0; i &amp;lt; 2; ++i)
            for (int j = 2; j &amp;lt; 4; ++j) &amp;#123;
                int x1 = x + dir[j][0], y1 = y + dir[i][1];
                if (id[x][y] &amp;lt; std::min(id[x1][y], id[x][y1]))
                    add(1, id[x][y], std::min(id[x1][y], id[x][y1]) - 1, k);
                if (std::max(id[x1][y], id[x][y1]) &amp;lt; id[x][y])
                    add(1, std::max(id[x1][y], id[x][y1]), id[x][y] - 1, k);
            &amp;#125;
        return;
    &amp;#125;;
    for (int i = 1; i &amp;lt;= n; ++i)
        for (int j = 1; j &amp;lt;= m; ++j)
            work(i, j, 1);
    for (int i1, i2; q--; ) &amp;#123;
        std::cin &amp;gt;&amp;gt; i1 &amp;gt;&amp;gt; i2, ++i1, ++i2;
        auto [x1, y1] = pos[i1];
        auto [x2, y2] = pos[i2];
        std::set&amp;lt;std::pair&amp;lt;int, int&amp;gt; &amp;gt; st;
        st.emplace(x1, y1);
        for (auto [fx, fy] : dir) &amp;#123;
            int x = x1 + fx, y = y1 + fy;
            if (x &amp;gt;= 1 &amp;amp;&amp;amp; x &amp;lt;= n &amp;amp;&amp;amp; y &amp;gt;= 1 &amp;amp;&amp;amp; y &amp;lt;= m)
                st.emplace(x, y);
        &amp;#125;
        st.emplace(x2, y2);
        for (auto [fx, fy] : dir) &amp;#123;
            int x = x2 + fx, y = y2 + fy;
            if (x &amp;gt;= 1 &amp;amp;&amp;amp; x &amp;lt;= n &amp;amp;&amp;amp; y &amp;gt;= 1 &amp;amp;&amp;amp; y &amp;lt;= m)
                st.emplace(x, y);
        &amp;#125;
        for (auto [x, y] : st)
            work(x, y, -1);
        std::swap(id[x1][y1], id[x2][y2]), std::swap(pos[i1], pos[i2]);
        for (auto [x, y] : st)
            work(x, y, 1);
        std::cout &amp;lt;&amp;lt; t[1].u &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    &amp;#125;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;interactive version:&lt;/p&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
#ifdef ONLINE_JUDGE
#include &amp;quot;seats.h&amp;quot;
#endif
const int dir[][2] = &amp;#123; &amp;#123; 0, -1 &amp;#125;, &amp;#123; 0, 1 &amp;#125;, &amp;#123; -1, 0 &amp;#125;, &amp;#123; 1, 0 &amp;#125; &amp;#125;;
const int maxn = 1e6 + 5;
struct node &amp;#123;
    int l, r, u, d, mn;
    node operator+ (const node &amp;amp;q) const &amp;#123;
        node res;
        res.l = l, res.r = q.r, res.d = 0;
        res.mn = std::min(mn, q.mn), res.u = 0;
        if (mn == res.mn)
            res.u = u;
        if (q.mn == res.mn)
            res.u += q.u;
        return res;
    &amp;#125;
&amp;#125; t[maxn &amp;lt;&amp;lt; 2];
#define lt (p &amp;lt;&amp;lt; 1)
#define rt (lt | 1)
void bld(int p, int l, int r) &amp;#123;
    t[p].l = l, t[p].r = r, t[p].u = r - l + 1;
    if (l == r)
        return;
    int mid = (l + r) &amp;gt;&amp;gt; 1;
    bld(lt, l, mid), bld(rt, mid + 1, r);
    return;
&amp;#125;
void pushval(int p, int v) &amp;#123;
    t[p].mn += v, t[p].d += v;
    return;
&amp;#125;
void pushdown(int p) &amp;#123;
    pushval(lt, t[p].d), pushval(rt, t[p].d);
    t[p].d = 0;
    return;
&amp;#125;
void add(int p, int l, int r, int v) &amp;#123;
    if (l &amp;lt;= t[p].l &amp;amp;&amp;amp; t[p].r &amp;lt;= r) &amp;#123;
        pushval(p, v);
        return;
    &amp;#125;
    pushdown(p);
    int mid = (t[p].l + t[p].r) &amp;gt;&amp;gt; 1;
    if (l &amp;lt;= mid)
        add(lt, l, r, v);
    if (r &amp;gt; mid)
        add(rt, l, r, v);
    t[p] = t[lt] + t[rt];
    return;
&amp;#125;
int n, m, N;
std::vector&amp;lt;std::pair&amp;lt;int, int&amp;gt; &amp;gt; pos;
std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; id(n + 2, std::vector&amp;lt;int&amp;gt; (m + 2, N + 1));
void work(int x, int y, int k) &amp;#123;
    for (int i = 0; i &amp;lt; 2; ++i)
        for (int j = 2; j &amp;lt; 4; ++j) &amp;#123;
            int x1 = x + dir[j][0], y1 = y + dir[i][1];
            if (id[x][y] &amp;lt; std::min(id[x1][y], id[x][y1]))
                add(1, id[x][y], std::min(id[x1][y], id[x][y1]) - 1, k);
            if (std::max(id[x1][y], id[x][y1]) &amp;lt; id[x][y])
                add(1, std::max(id[x1][y], id[x][y1]), id[x][y] - 1, k);
        &amp;#125;
    return;
&amp;#125;;
void give_initial_chart(int n, int m, std::vector&amp;lt;int&amp;gt; R, std::vector&amp;lt;int&amp;gt; C) &amp;#123;
    ::n = n, ::m = m, N = n * m;
    pos.resize(N + 1);
    id.assign(n + 2, std::vector&amp;lt;int&amp;gt; (m + 2, N + 1));
    for (int i = 0; i &amp;lt; N; ++i) &amp;#123;
        int x = R[i] + 1, y = C[i] + 1;
        id[x][y] = i + 1, pos[i + 1] = &amp;#123; x, y &amp;#125;;
    &amp;#125;
    bld(1, 1, N);
    for (int i = 1; i &amp;lt;= n; ++i)
        for (int j = 1; j &amp;lt;= m; ++j)
            work(i, j, 1);
    return;
&amp;#125;
int swap_seats(int i1, int i2) &amp;#123;
    ++i1, ++i2;
    auto [x1, y1] = pos[i1];
    auto [x2, y2] = pos[i2];
    std::set&amp;lt;std::pair&amp;lt;int, int&amp;gt; &amp;gt; st;
    st.emplace(x1, y1);
    for (auto [fx, fy] : dir) &amp;#123;
        int x = x1 + fx, y = y1 + fy;
        if (x &amp;gt;= 1 &amp;amp;&amp;amp; x &amp;lt;= n &amp;amp;&amp;amp; y &amp;gt;= 1 &amp;amp;&amp;amp; y &amp;lt;= m)
            st.emplace(x, y);
    &amp;#125;
    st.emplace(x2, y2);
    for (auto [fx, fy] : dir) &amp;#123;
        int x = x2 + fx, y = y2 + fy;
        if (x &amp;gt;= 1 &amp;amp;&amp;amp; x &amp;lt;= n &amp;amp;&amp;amp; y &amp;gt;= 1 &amp;amp;&amp;amp; y &amp;lt;= m)
            st.emplace(x, y);
    &amp;#125;
    for (auto [x, y] : st)
        work(x, y, -1);
    std::swap(id[x1][y1], id[x2][y2]), std::swap(pos[i1], pos[i2]);
    for (auto [x, y] : st)
        work(x, y, 1);
    return t[1].u;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;d---单旋&#34;&gt;D - 单旋&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P3721&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P3721&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;发现任意时刻参与旋转的都是最值，简单分析可以发现做的这件事情是把最值移到根，其他点相对关系不变，转化为维护深度&lt;/li&gt;
&lt;li&gt;考虑新加入点，可以利用 BST 的性质，直接查询 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 的前驱、后继，则二者存在祖孙关系，把 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 接在矮的下面即可&lt;/li&gt;
&lt;li&gt;考虑做一个先删再加的过程，删会影响儿子的深度（显然只有一侧儿子），加会影响全树深度&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;e---nekameleoni&#34;&gt;E - NEKAMELEONI&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P7230&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P7230&lt;/a&gt;&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://xsc062.netlify.app/20250911/</guid>
            <title>吉司机 + 历史和练习</title>
            <link>https://xsc062.netlify.app/20250911/</link>
            <category>线段树</category>
            <pubDate>Thu, 11 Sep 2025 17:27:05 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;并非所有历史和都是吉司机&lt;/p&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;a---just-another-game-of-stones&#34;&gt;A - Just Another Game of Stones&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P9631&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P9631&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;发现如果选定了这一步取的位置 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt;，那么要拿的石子是定值 &lt;span class=&#34;math inline&#34;&gt;\(a_i-a_i\oplus s\)&lt;/span&gt;，当 &lt;span class=&#34;math inline&#34;&gt;\(a_i\le a_i\oplus s\)&lt;/span&gt; 时不合法。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;可以用吉司机维护修改和区间异或和，那么询问需要转化。&lt;/p&gt;
答案为 &lt;span class=&#34;math inline&#34;&gt;\(a_i&amp;gt;a_i\oplus s\)&lt;/span&gt; 的次数，结合&lt;strong&gt;异或是不带进位的区间加&lt;/strong&gt;的观点，考察『加数』&lt;span class=&#34;math inline&#34;&gt;\(s\)&lt;/span&gt; 的最高位，当且仅当 &lt;span class=&#34;math inline&#34;&gt;\(a_i\)&lt;/span&gt; 在这一位为 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt; 时有贡献。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;故再维护一下每一位为 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt; 的个数即可。复杂度 &lt;span class=&#34;math inline&#34;&gt;\(O(q\log n\log V)\)&lt;/span&gt;。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int inf = 1 &amp;lt;&amp;lt; 30;
const int maxn = 2e5 + 5;
struct &amp;#123;
    std::array&amp;lt;int, 30&amp;gt; u;
    int l, r, cnt, mn, se, d, s;
&amp;#125; t[maxn &amp;lt;&amp;lt; 2];
#define lt (p &amp;lt;&amp;lt; 1)
#define rt (lt | 1)
int a[maxn];
void pushup(int p) &amp;#123;
    if (t[lt].mn == t[rt].mn) &amp;#123;
        t[p].mn = t[lt].mn, t[p].cnt = t[lt].cnt + t[rt].cnt;
        t[p].se = std::min(t[lt].se, t[rt].se);
    &amp;#125;
    else if (t[lt].mn &amp;lt; t[rt].mn) &amp;#123;
        t[p].mn = t[lt].mn, t[p].cnt = t[lt].cnt;
        t[p].se = std::min(t[lt].se, t[rt].mn);
    &amp;#125;
    else &amp;#123;
        t[p].mn = t[rt].mn, t[p].cnt = t[rt].cnt;
        t[p].se = std::min(t[lt].mn, t[rt].se);
    &amp;#125;
    t[p].s = t[lt].s ^ t[rt].s;
    for (int i = 0; i &amp;lt; 30; ++i)
        t[p].u[i] = t[lt].u[i] + t[rt].u[i];
    return;
&amp;#125;
void bld(int p, int l, int r) &amp;#123;
    t[p].d = -inf;
    t[p].l = l, t[p].r = r;
    if (l == r) &amp;#123;
        for (int i = 0; i &amp;lt; 30; ++i)
            t[p].u[i] = (a[l] &amp;gt;&amp;gt; i) &amp;amp; 1;
        t[p].s = t[p].mn = a[l], t[p].cnt = 1, t[p].se = inf;
        return;
    &amp;#125;
    int mid = (l + r) &amp;gt;&amp;gt; 1;
    bld(lt, l, mid), bld(rt, mid + 1, r);
    pushup(p);
    return;
&amp;#125;
void pushval(int p, int v) &amp;#123;
    if (v &amp;gt; t[p].mn) &amp;#123;
        for (int i = 0; i &amp;lt; 30; ++i) &amp;#123;
            if ((t[p].mn &amp;gt;&amp;gt; i) &amp;amp; 1)
                t[p].u[i] -= t[p].cnt;
            if ((v &amp;gt;&amp;gt; i) &amp;amp; 1)
                t[p].u[i] += t[p].cnt;
        &amp;#125;
        if (t[p].cnt &amp;amp; 1)
            t[p].s ^= t[p].mn ^ v;
        t[p].mn = t[p].d = v;
    &amp;#125;
    return;
&amp;#125;
void pushdown(int p) &amp;#123;
    if (t[p].d != -inf) &amp;#123;
        pushval(lt, t[p].d), pushval(rt, t[p].d);
        t[p].d = -inf;
    &amp;#125;
    return;
&amp;#125;
void add(int p, int l, int r, int v) &amp;#123;
    if (t[p].mn &amp;gt;= v)
        return;
    if (l &amp;lt;= t[p].l &amp;amp;&amp;amp; t[p].r &amp;lt;= r &amp;amp;&amp;amp; v &amp;lt; t[p].se) &amp;#123;
        pushval(p, v);
        return;
    &amp;#125;
    pushdown(p);
    int mid = (t[p].l + t[p].r) &amp;gt;&amp;gt; 1;
    if (l &amp;lt;= mid)
        add(lt, l, r, v);
    if (r &amp;gt; mid)
        add(rt, l, r, v);
    pushup(p);
    return;
&amp;#125;
int askt(int p, int l, int r, int i) &amp;#123;
    if (l &amp;lt;= t[p].l &amp;amp;&amp;amp; t[p].r &amp;lt;= r)
        return t[p].u[i];
    pushdown(p);
    int mid = (t[p].l + t[p].r) &amp;gt;&amp;gt; 1, res = 0;
    if (l &amp;lt;= mid)
        res = askt(lt, l, r, i);
    if (r &amp;gt; mid)
        res += askt(rt, l, r, i);
    return res;
&amp;#125;
int asks(int p, int l, int r) &amp;#123;
    if (l &amp;lt;= t[p].l &amp;amp;&amp;amp; t[p].r &amp;lt;= r)
        return t[p].s;
    pushdown(p);
    int mid = (t[p].l + t[p].r) &amp;gt;&amp;gt; 1, res = 0;
    if (l &amp;lt;= mid)
        res = asks(lt, l, r);
    if (r &amp;gt; mid)
        res ^= asks(rt, l, r);
    return res;
&amp;#125;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, m;
    std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
    for (int i = 1; i &amp;lt;= n; ++i)
        std::cin &amp;gt;&amp;gt; a[i];
    bld(1, 1, n);
    for (int op, l, r, v; m--; ) &amp;#123;
        std::cin &amp;gt;&amp;gt; op &amp;gt;&amp;gt; l &amp;gt;&amp;gt; r &amp;gt;&amp;gt; v;
        if (op == 1)
            add(1, l, r, v);
        else &amp;#123;
            int s = asks(1, l, r) ^ v;
            if (s == 0) &amp;#123;
                std::cout &amp;lt;&amp;lt; 0 &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
                continue;
            &amp;#125;
            int t = std::__lg(s);
            std::cout &amp;lt;&amp;lt; askt(1, l, r, t) + ((v &amp;gt;&amp;gt; t) &amp;amp; 1) &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
        &amp;#125;
    &amp;#125;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;b---prof.-pangs-sequence-c---test_90&#34;&gt;B - Prof. Pang’s sequence / C - TEST_90&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P10822&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P10822&lt;/a&gt; / &lt;a href=&#34;https://www.luogu.com.cn/problem/P9990&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P9990&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;历史和维护子区间问题是一个固定的 trick，只需要对于每一个 &lt;span class=&#34;math inline&#34;&gt;\(r\)&lt;/span&gt;，给合法的 &lt;span class=&#34;math inline&#34;&gt;\(l\)&lt;/span&gt; 加一。&lt;/li&gt;
&lt;li&gt;离线扫描线，对于当前右端点 &lt;span class=&#34;math inline&#34;&gt;\(r\)&lt;/span&gt;，记录每种数最后一次出现的位置 &lt;span class=&#34;math inline&#34;&gt;\(pos\)&lt;/span&gt;。令 &lt;span class=&#34;math inline&#34;&gt;\(r\)&lt;/span&gt; 的颜色为 &lt;code&gt;1&lt;/code&gt;，从右到左，每碰到一个新的 &lt;span class=&#34;math inline&#34;&gt;\(pos\)&lt;/span&gt; 就切换颜色&lt;/li&gt;
&lt;li&gt;显然对于当前 &lt;span class=&#34;math inline&#34;&gt;\(r\)&lt;/span&gt;，应该被加一的 &lt;span class=&#34;math inline&#34;&gt;\(l\)&lt;/span&gt; 就是颜色为 &lt;code&gt;1&lt;/code&gt; 的这些位置。&lt;/li&gt;
&lt;li&gt;考虑更快地维护这个过程，也就是在 &lt;span class=&#34;math inline&#34;&gt;\(r\)&lt;/span&gt; 的颜色和 &lt;span class=&#34;math inline&#34;&gt;\(r-1\)&lt;/span&gt; 不同时就可以对 &lt;span class=&#34;math inline&#34;&gt;\([1,r)\)&lt;/span&gt; 做一次 flip，是可行的&lt;/li&gt;
&lt;li&gt;在每个 &lt;span class=&#34;math inline&#34;&gt;\(r\)&lt;/span&gt; 处查询 &lt;span class=&#34;math inline&#34;&gt;\([l,r]\)&lt;/span&gt; 的区间和即可。&lt;/li&gt;
&lt;li&gt;吐槽：并非所有历史和都是吉司机&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int maxn = 5e5 + 5;
struct &amp;#123;
    long long s;
    int l, r, d0, d1, df, ds, u0, u1;
&amp;#125; t[maxn &amp;lt;&amp;lt; 2];
#define lt (p &amp;lt;&amp;lt; 1)
#define rt (lt | 1)
void pushup(int p) &amp;#123;
    t[p].u0 = t[lt].u0 + t[rt].u0;
    t[p].u1 = t[lt].u1 + t[rt].u1;
    return;
&amp;#125;
void pushval(int p, long long v0, long long v1, bool f) &amp;#123;
    if (f) &amp;#123;
        t[p].df ^= 1;
        std::swap(t[p].u0, t[p].u1);
        std::swap(t[p].d0, t[p].d1);
    &amp;#125;
    t[p].d0 += v0, t[p].d1 += v1;
    t[p].s += t[p].u0 * v0 + t[p].u1 * v1;
    return;
&amp;#125;
void pushdown(int p) &amp;#123;
    pushval(lt, t[p].d0, t[p].d1, t[p].df);
    pushval(rt, t[p].d0, t[p].d1, t[p].df);
    t[p].d0 = t[p].d1 = t[p].df = 0;
    return;
&amp;#125;
void bld(int p, int l, int r) &amp;#123;
    t[p].l = l, t[p].r = r;
    t[p].u0 = r - l + 1;
    if (l == r)
        return;
    int mid = (l + r) &amp;gt;&amp;gt; 1;
    bld(lt, l, mid), bld(rt, mid + 1, r);
    return;
&amp;#125;
void flip(int p, int l, int r) &amp;#123;
    if (l &amp;lt;= t[p].l &amp;amp;&amp;amp; t[p].r &amp;lt;= r) &amp;#123;
        pushval(p, 0, 0, 1);
        return;
    &amp;#125;
    pushdown(p);
    int mid = (t[p].l + t[p].r) &amp;gt;&amp;gt; 1;
    if (l &amp;lt;= mid)
        flip(lt, l, r);
    if (r &amp;gt; mid)
        flip(rt, l, r);
    pushup(p);
    return;
&amp;#125;
long long ask(int p, int l, int r) &amp;#123;
    if (l &amp;lt;= t[p].l &amp;amp;&amp;amp; t[p].r &amp;lt;= r)
        return t[p].s;
    pushdown(p);
    auto res(0ll);
    int mid = (t[p].l + t[p].r) &amp;gt;&amp;gt; 1;
    if (l &amp;lt;= mid)
        res = ask(lt, l, r);
    if (r &amp;gt; mid)
        res += ask(rt, l, r);
    return res;
&amp;#125;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n;
    std::cin &amp;gt;&amp;gt; n;
    std::vector&amp;lt;int&amp;gt; a(n + 1), la(n + 1);
    for (int i = 1; i &amp;lt;= n; ++i)
        std::cin &amp;gt;&amp;gt; a[i];
    int m;
    std::cin &amp;gt;&amp;gt; m;
    std::vector&amp;lt;long long&amp;gt; res(m + 1);
    std::vector&amp;lt;std::vector&amp;lt;std::pair&amp;lt;int, int&amp;gt; &amp;gt; &amp;gt; u(n + 1);
    for (int i = 1, l, r; i &amp;lt;= m; ++i) &amp;#123;
        std::cin &amp;gt;&amp;gt; l &amp;gt;&amp;gt; r;
        u[r].emplace_back(l, i);
    &amp;#125;
    bld(1, 1, n);
    for (int r = 1; r &amp;lt;= n; ++r) &amp;#123;
        flip(1, la[a[r]] + 1, r);
        pushval(1, 0, 1, 0);
        for (auto [l, id] : u[r])
            res[id] = ask(1, l, r);
        la[a[r]] = r;
    &amp;#125;
    for (int i = 1; i &amp;lt;= m; ++i)
        std::cout &amp;lt;&amp;lt; res[i] &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;d---stations&#34;&gt;D - Stations&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/CF1572F&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/CF1572F&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不太能直接维护 &lt;span class=&#34;math inline&#34;&gt;\(b\)&lt;/span&gt;，但发现如果维护每个 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 最远能到达的点，发现每次更新 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; 会把 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; 左边的所有点值和 &lt;span class=&#34;math inline&#34;&gt;\(j-1\)&lt;/span&gt; 取 min。&lt;/li&gt;
&lt;li&gt;发现吉司机能够在取 min 的同时在另一个树状树组里维护差分&lt;/li&gt;
&lt;li&gt;需要注意更新的时机，应该是每次线段树更新函数访问到完整节点时。&lt;/li&gt;
&lt;li&gt;复杂度 &lt;span class=&#34;math inline&#34;&gt;\(O(q\log^2n)\)&lt;/span&gt;。但真的吗？单点修改似乎对势能有影响？然而并不会相关分析。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;看起来有点激进了，没想到确实是正解。&lt;/p&gt;
&lt;details&gt;
&lt;p&gt;可以发现树状数组在时间上确实是有优势的&lt;/p&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int maxn = 2e5 + 5;
const int inf = 0x3f3f3f3f;
struct &amp;#123;
    int l, r, mx, se, d, cnt;
&amp;#125; t[maxn &amp;lt;&amp;lt; 2];
#define lt (p &amp;lt;&amp;lt; 1)
#define rt (lt | 1)
int n;
long long bit[maxn][2];
int lowbit(int x) &amp;#123; return x &amp;amp; -x; &amp;#125;
void add(int x, long long v) &amp;#123;
    for (int i = x; i &amp;lt;= n; i += lowbit(i))
        bit[i][0] += v, bit[i][1] += v * (x - 1);
    return;
&amp;#125;
long long ask(int x) &amp;#123;
    auto res = 0ll;
    for (int i = x; i; i -= lowbit(i))
        res += bit[i][0] * x - bit[i][1];
    return res;
&amp;#125;
void pushup(int p) &amp;#123;
    if (t[lt].mx == t[rt].mx) &amp;#123;
        t[p].mx = t[lt].mx, t[p].cnt = t[lt].cnt + t[rt].cnt;
        t[p].se = std::max(t[lt].se, t[rt].se);
    &amp;#125;
    else if (t[lt].mx &amp;gt; t[rt].mx) &amp;#123;
        t[p].mx = t[lt].mx, t[p].cnt = t[lt].cnt;
        t[p].se = std::max(t[lt].se, t[rt].mx);
    &amp;#125;
    else &amp;#123;
        t[p].mx = t[rt].mx, t[p].cnt = t[rt].cnt;
        t[p].se = std::max(t[lt].mx, t[rt].se);
    &amp;#125;
    return;
&amp;#125;
void bld(int p, int l, int r) &amp;#123;
    t[p].d = inf;
    t[p].l = l, t[p].r = r;
    if (l == r) &amp;#123;
        add(l, 1), add(l + 1, -1);
        t[p].mx = l, t[p].se = -1, t[p].cnt = 1;
        return;
    &amp;#125;
    int mid = (l + r) &amp;gt;&amp;gt; 1;
    bld(lt, l, mid), bld(rt, mid + 1, r);
    pushup(p);
    return;
&amp;#125;
void pushval(int p, int v) &amp;#123;
    if (v &amp;lt;= t[p].mx)
        t[p].mx = t[p].d = v;
    return;
&amp;#125;
void pushdown(int p) &amp;#123;
    if (t[p].d != inf) &amp;#123;
        pushval(lt, t[p].d), pushval(rt, t[p].d);
        t[p].d = inf;
    &amp;#125;
    return;
&amp;#125;
void add(int p, int l, int r, int v) &amp;#123;
    if (t[p].mx &amp;lt;= v)
        return;
    if (l &amp;lt;= t[p].l &amp;amp;&amp;amp; t[p].r &amp;lt;= r &amp;amp;&amp;amp; v &amp;gt; t[p].se) &amp;#123;
        add(t[p].mx + 1, t[p].cnt);
        add(v + 1, -t[p].cnt);
        pushval(p, v);
        return;
    &amp;#125;
    pushdown(p);
    int mid = (t[p].l + t[p].r) &amp;gt;&amp;gt; 1;
    if (l &amp;lt;= mid)
        add(lt, l, r, v);
    if (r &amp;gt; mid)
        add(rt, l, r, v);
    pushup(p);
    return;
&amp;#125;
void upd(int p, int x, int v) &amp;#123;
    if (t[p].l == t[p].r) &amp;#123;
        add(t[p].mx + 1, 1), add(v + 1, -1);
        t[p].mx = v;
        return;
    &amp;#125;
    pushdown(p);
    int mid = (t[p].l + t[p].r) &amp;gt;&amp;gt; 1;
    if (x &amp;lt;= mid)
        upd(lt, x, v);
    else
        upd(rt, x, v);
    pushup(p);
    return;
&amp;#125;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int m;
    std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
    bld(1, 1, n);
    for (int op; m--; ) &amp;#123;
        std::cin &amp;gt;&amp;gt; op;
        if (op == 1) &amp;#123;
            int x, v;
            std::cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; v;
            if (x != 1)
                add(1, 1, x - 1, x - 1);
            upd(1, x, v);
            // for (int i = 1; i &amp;lt;= n; ++i)
            //     std::cout &amp;lt;&amp;lt; ask(i) - ask(i - 1) &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
            // std::cout &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
        &amp;#125;
        else &amp;#123;
            int l, r;
            std::cin &amp;gt;&amp;gt; l &amp;gt;&amp;gt; r;
            std::cout &amp;lt;&amp;lt; ask(r) - ask(l - 1) &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
        &amp;#125;
    &amp;#125;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;e---luotianyi-and-the-function&#34;&gt;E - LuoTianyi and the Function&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://codeforces.com/problemset/problem/1824/D&#34; class=&#34;uri&#34;&gt;https://codeforces.com/problemset/problem/1824/D&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;由于 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; 和函数关联更强，考虑把 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; 这一维扫描线 + 差分掉&lt;/li&gt;
&lt;li&gt;经典套路，维护每个 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 从右向左第一次出现的位置 &lt;span class=&#34;math inline&#34;&gt;\(pos_x\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;每次 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; 移动一下，会更新一段区间（可能不存在）的 &lt;span class=&#34;math inline&#34;&gt;\(g\)&lt;/span&gt; 值，它们原本为 &lt;span class=&#34;math inline&#34;&gt;\(pos_{a_j}\)&lt;/span&gt;，需要被更新为下一个 &lt;span class=&#34;math inline&#34;&gt;\(pos\)&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;记录值为 &lt;span class=&#34;math inline&#34;&gt;\(pos_x\)&lt;/span&gt; 的区间，做区间赋值历史和即可。&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int maxn = 1e6 + 5;
struct &amp;#123;
    int l, r;
    long long d1, d2, d3, u, s;
&amp;#125; t[maxn &amp;lt;&amp;lt; 2];
#define lt (p &amp;lt;&amp;lt; 1)
#define rt (lt | 1)
void pushup(int p) &amp;#123;
    t[p].u = t[lt].u + t[rt].u;
    t[p].s = t[lt].s + t[rt].s;
    return;
&amp;#125;
void pushval(int p, long long d1, long long d2, long long d3) &amp;#123;
    t[p].s += t[p].u * d2 + d3 * (t[p].r - t[p].l + 1);
    t[p].d3 += d3;
    if (t[p].d1)
        t[p].d3 += t[p].d1 * d2;
    else
        t[p].d2 += d2;
    if (d1) &amp;#123;
        t[p].u = d1 * (t[p].r - t[p].l + 1);
        t[p].d1 = d1;
    &amp;#125;
    return;
&amp;#125;
void pushdown(int p) &amp;#123;
    pushval(lt, t[p].d1, t[p].d2, t[p].d3);
    pushval(rt, t[p].d1, t[p].d2, t[p].d3);
    t[p].d1 = t[p].d2 = t[p].d3 = 0ll;
    return;
&amp;#125;
void bld(int p, int l, int r) &amp;#123;
    t[p].l = l, t[p].r = r;
    if (l == r)
        return;
    int mid = (t[p].l + t[p].r) &amp;gt;&amp;gt; 1;
    bld(lt, l, mid), bld(rt, mid + 1, r);
    return;
&amp;#125;
void upd(int p, int l, int r, long long v) &amp;#123;
    if (l &amp;lt;= t[p].l &amp;amp;&amp;amp; t[p].r &amp;lt;= r) &amp;#123;
        pushval(p, v, 0ll, 0ll);
        return;
    &amp;#125;
    pushdown(p);
    int mid = (t[p].l + t[p].r) &amp;gt;&amp;gt; 1;
    if (l &amp;lt;= mid)
        upd(lt, l, r, v);
    if (r &amp;gt; mid)
        upd(rt, l, r, v);
    pushup(p);
    return;
&amp;#125;
long long ask(int p, int l, int r) &amp;#123;
    if (l &amp;lt;= t[p].l &amp;amp;&amp;amp; t[p].r &amp;lt;= r)
        return t[p].s;
    pushdown(p);
    int mid = (t[p].l + t[p].r) &amp;gt;&amp;gt; 1;
    auto res = 0ll;
    if (l &amp;lt;= mid)
        res = ask(lt, l, r);
    if (r &amp;gt; mid)
        res += ask(rt, l, r);
    return res;
&amp;#125;
signed main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, q;
    std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; q;
    std::vector&amp;lt;int&amp;gt; a(n + 1), la(n + 1);
    for (int i = 1; i &amp;lt;= n; ++i)
        std::cin &amp;gt;&amp;gt; a[i];
    struct query &amp;#123; int l, r, id, k; &amp;#125;;
    std::vector&amp;lt;long long&amp;gt; res(q + 1);
    std::vector&amp;lt;std::vector&amp;lt;query&amp;gt; &amp;gt; u(n + 1);
    for (int i = 1, l, r, x, y; i &amp;lt;= q; ++i) &amp;#123;
        std::cin &amp;gt;&amp;gt; l &amp;gt;&amp;gt; r &amp;gt;&amp;gt; x &amp;gt;&amp;gt; y;
        if (x != 1)
            u[x - 1].push_back(&amp;#123; l, r, i, -1 &amp;#125;);
        u[y].push_back(&amp;#123; l, r, i, 1 &amp;#125;);
    &amp;#125;
    bld(1, 1, n);
    std::vector&amp;lt;int&amp;gt; pre(n + 2), nex(n + 2), l(n + 2);
    pre[n + 1] = 0, nex[0] = n + 1;
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        int p = la[a[i]];
        nex[pre[n + 1]] = i, pre[i] = pre[n + 1], pre[n + 1] = i, nex[i] = n + 1;
        l[i] = i;
        if (p != 0) &amp;#123;
            upd(1, l[p], p, nex[p]);
            l[nex[p]] = l[p];
            pre[nex[p]] = pre[p], nex[pre[p]] = nex[p];
        &amp;#125;
        upd(1, i, i, i);
        pushval(1, 0, 1, 0);
        for (auto [l, r, id, k] : u[i])
            res[id] += k * ask(1, l, r);
        la[a[i]] = i;
    &amp;#125;
    for (int i = 1; i &amp;lt;= q; ++i)
        std::cout &amp;lt;&amp;lt; res[i] &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;f---yunlis-subarray-queries-extreme-version&#34;&gt;F - Yunli’s Subarray Queries (extreme version)&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://codeforces.com/problemset/problem/2009/G3&#34; class=&#34;uri&#34;&gt;https://codeforces.com/problemset/problem/2009/G3&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;考虑对 &lt;span class=&#34;math inline&#34;&gt;\(\forall i\)&lt;/span&gt;，令 &lt;span class=&#34;math inline&#34;&gt;\(a_i\gets a_i-i\)&lt;/span&gt;，那么能够参与同一个连续子段的元素值应相同&lt;/li&gt;
&lt;li&gt;&lt;p&gt;显然对于任意一个长度为 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 的子段，其答案为 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 减去众数出现次数（&lt;span class=&#34;math inline&#34;&gt;\([l, r]\)&lt;/span&gt; 处答案记为 &lt;span class=&#34;math inline&#34;&gt;\(g_r\)&lt;/span&gt;）&lt;/p&gt;
这一点可以用类似莫队的方法来做&lt;/li&gt;
&lt;li&gt;&lt;p&gt;那么对于更长的子段 &lt;span class=&#34;math inline&#34;&gt;\([l, r]\)&lt;/span&gt;，其 &lt;span class=&#34;math inline&#34;&gt;\(f\)&lt;/span&gt; 就是 &lt;span class=&#34;math inline&#34;&gt;\(\min\limits_{l+k-1\le i\le r}\{g_i\}\)&lt;/span&gt;&lt;/p&gt;
原问题中的一次 &lt;span class=&#34;math inline&#34;&gt;\([l, r]\)&lt;/span&gt; 的询问就可以转化为 &lt;span class=&#34;math inline&#34;&gt;\(\sum\limits_{i=l+k-1}^r\sum\limits_{j=i}^r\min\{ g_{i\sim j}\}\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;这里有一个 trick：扫描线时可以用单调栈的想法来维护最小值操作，那么就把最值操作转化为一般的区间加历史和了。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int maxn = 1e6 + 5;
struct &amp;#123;
    int l, r;
    long long d1, d2, d3, u, s;
&amp;#125; t[maxn &amp;lt;&amp;lt; 2];
#define lt (p &amp;lt;&amp;lt; 1)
#define rt (lt | 1)
void pushup(int p) &amp;#123;
    t[p].u = t[lt].u + t[rt].u;
    t[p].s = t[lt].s + t[rt].s;
    return;
&amp;#125;
void pushval(int p, long long d1, long long d2, long long d3) &amp;#123;
    t[p].s += t[p].u * d2 + d3 * (t[p].r - t[p].l + 1);
    t[p].d3 += d3 + t[p].d1 * d2;
    t[p].d2 += d2;
    t[p].u += d1 * (t[p].r - t[p].l + 1);
    t[p].d1 += d1;
    return;
&amp;#125;
void pushdown(int p) &amp;#123;
    pushval(lt, t[p].d1, t[p].d2, t[p].d3);
    pushval(rt, t[p].d1, t[p].d2, t[p].d3);
    t[p].d1 = t[p].d2 = t[p].d3 = 0ll;
    return;
&amp;#125;
void bld(int p, int l, int r) &amp;#123;
    t[p].l = l, t[p].r = r;
    t[p].u = t[p].s = 0ll;
    t[p].d1 = t[p].d2 = t[p].d3 = 0;
    if (l == r)
        return;
    int mid = (t[p].l + t[p].r) &amp;gt;&amp;gt; 1;
    bld(lt, l, mid), bld(rt, mid + 1, r);
    return;
&amp;#125;
void add(int p, int l, int r, long long v) &amp;#123;
    if (l &amp;lt;= t[p].l &amp;amp;&amp;amp; t[p].r &amp;lt;= r) &amp;#123;
        pushval(p, v, 0ll, 0ll);
        return;
    &amp;#125;
    pushdown(p);
    int mid = (t[p].l + t[p].r) &amp;gt;&amp;gt; 1;
    if (l &amp;lt;= mid)
        add(lt, l, r, v);
    if (r &amp;gt; mid)
        add(rt, l, r, v);
    pushup(p);
    return;
&amp;#125;
long long ask(int p, int l, int r) &amp;#123;
    if (l &amp;lt;= t[p].l &amp;amp;&amp;amp; t[p].r &amp;lt;= r)
        return t[p].s;
    pushdown(p);
    int mid = (t[p].l + t[p].r) &amp;gt;&amp;gt; 1;
    auto res = 0ll;
    if (l &amp;lt;= mid)
        res = ask(lt, l, r);
    if (r &amp;gt; mid)
        res += ask(rt, l, r);
    return res;
&amp;#125;
signed main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int T;
    for (std::cin &amp;gt;&amp;gt; T; T--; ) &amp;#123;
        int n, k, q;
        std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; k &amp;gt;&amp;gt; q;
        std::vector&amp;lt;int&amp;gt; a(n + 1);
        for (int i = 1; i &amp;lt;= n; ++i)
            std::cin &amp;gt;&amp;gt; a[i], a[i] -= i;
        bld(1, 1, n);
        std::vector&amp;lt;int&amp;gt; g(n + 1);
        std::unordered_map&amp;lt;int, int&amp;gt; cnt;
        std::multiset&amp;lt;int&amp;gt; t;
        for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
            if (i &amp;gt; k) &amp;#123;
                t.erase(t.find(cnt[a[i - k]]));
                if (--cnt[a[i - k]])
                    t.insert(cnt[a[i - k]]);
            &amp;#125;
            if (cnt[a[i]])
                t.erase(t.find(cnt[a[i]]));
            t.insert(++cnt[a[i]]);
            if (i &amp;gt;= k)
                g[i] = k - *--t.end();
        &amp;#125;
        std::vector&amp;lt;long long&amp;gt; res(q + 1);
        std::vector&amp;lt;std::vector&amp;lt;std::pair&amp;lt;int, int&amp;gt; &amp;gt; &amp;gt; u(n + 1);
        for (int i = 1, l, r; i &amp;lt;= q; ++i) &amp;#123;
            std::cin &amp;gt;&amp;gt; l &amp;gt;&amp;gt; r;
            u[r].emplace_back(l + k - 1, i);
        &amp;#125;
        std::stack&amp;lt;std::pair&amp;lt;int, int&amp;gt; &amp;gt; st;
        for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
            std::pair&amp;lt;int, int&amp;gt; now(g[i], i);
            add(1, i, i, g[i]);
            for (; !st.empty() &amp;amp;&amp;amp; st.top() &amp;gt; now; st.pop()) &amp;#123;
                auto [v, p] = st.top();
                add(1, p, now.second - 1, g[i] - v);
                now.second = p;
            &amp;#125;
            st.push(now);
            pushval(1, 0ll, 1ll, 0ll);
            for (auto [l, id] : u[i])
                res[id] = ask(1, l, i);
        &amp;#125;
        for (int i = 1; i &amp;lt;= q; ++i)
            std::cout &amp;lt;&amp;lt; res[i] &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    &amp;#125;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
 ]]></description>
        </item>
    </channel>
</rss>
