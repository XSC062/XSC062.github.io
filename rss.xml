<?xml version="1.0"?>
<rss version="2.0">
    <channel>
        <title></title>
        <link>https://xsc062.netlify.app</link>
        <description></description>
        <language>zh-CN</language>
        <pubDate>Mon, 29 Sep 2025 16:55:28 +0800</pubDate>
        <lastBuildDate>Mon, 29 Sep 2025 16:55:28 +0800</lastBuildDate>
        <category>并查集</category>
        <category>斜率优化</category>
        <category>悬线法</category>
        <category>哈希</category>
        <category>字典树</category>
        <category>DP</category>
        <category>单调队列</category>
        <category>分治</category>
        <category>二分图</category>
        <category>CRT / exCRT</category>
        <category>排列组合</category>
        <category>网络流</category>
        <category>费用流</category>
        <category>二分</category>
        <category>上下界网络流</category>
        <category>容斥原理</category>
        <category>线段树</category>
        <category>树状数组</category>
        <category>区间 DP</category>
        <category>构造</category>
        <category>数据结构</category>
        <category>Tarjan</category>
        <category>下饭</category>
        <category>LCA</category>
        <category>倍增</category>
        <category>鸽巢原理</category>
        <category>概率期望</category>
        <category>调和级数</category>
        <category>差分</category>
        <category>思维</category>
        <category>树形 DP</category>
        <category>最小生成树</category>
        <category>SAM</category>
        <category>状压</category>
        <category>分块</category>
        <category>可持久化</category>
        <category>笛卡尔树</category>
        <category>高维前缀和</category>
        <category>闲话</category>
        <category>欧拉回路</category>
        <category>树链剖分</category>
        <category>长链剖分</category>
        <category>KMP</category>
        <category>border</category>
        <category>字符串</category>
        <category>AC 自动机</category>
        <category>SA</category>
        <category>数学</category>
        <category>树上差分</category>
        <category>FWT</category>
        <category>堆</category>
        <category>树的重心</category>
        <category>二项式定理</category>
        <category>二项式反演</category>
        <category>贪心</category>
        <category>均摊</category>
        <category>计数</category>
        <category>优化建图</category>
        <category>反悔贪心</category>
        <category>调整法</category>
        <category>背包</category>
        <category>博弈论</category>
        <category>DP 优化</category>
        <category>虚树</category>
        <category>点分治</category>
        <category>WQS 二分</category>
        <category>闵可夫斯基和</category>
        <category>slope trick</category>
        <category>四边形不等式</category>
        <category>状压 DP</category>
        <category>组合数学</category>
        <category>支配对</category>
        <category>DDP</category>
        <category>容斥</category>
        <category>Kruskal 重构树</category>
        <category>高精度</category>
        <category>最短路</category>
        <category>李超线段树</category>
        <item>
            <guid isPermalink="true">https://xsc062.netlify.app/20250929/</guid>
            <title>生成树练习</title>
            <link>https://xsc062.netlify.app/20250929/</link>
            <pubDate>Mon, 29 Sep 2025 16:55:28 +0800</pubDate>
            <description><![CDATA[ 
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://xsc062.netlify.app/20250924/</guid>
            <title>最短路练习</title>
            <link>https://xsc062.netlify.app/20250924/</link>
            <category>DP</category>
            <category>二分</category>
            <category>倍增</category>
            <category>调整法</category>
            <category>最短路</category>
            <pubDate>Wed, 24 Sep 2025 14:27:15 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;最短路为背景的题 + 做法是最短路的题&lt;/p&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;a---minimum-path&#34;&gt;A - Minimum Path&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/CF1473E&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/CF1473E&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;经典套路，发现可以把 max 和 min 换成任意路径中的边，然后 max 和 min 就会最小化这个式子&lt;/li&gt;
&lt;li&gt;故写一个 Dijkstra + DP，求这个式子的最小值即可&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, m;
    std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
    using arr = std::vector&amp;lt;long long&amp;gt;;
    using brr = std::vector&amp;lt;arr&amp;gt;;
    std::vector&amp;lt;std::vector&amp;lt;std::pair&amp;lt;int, int&amp;gt; &amp;gt; &amp;gt; g(n + 1);
    std::vector&amp;lt;brr&amp;gt; dis(2, brr(2, arr(n + 1, 1e18))), vis(2, brr(2, arr(n + 1)));
    for (int x, y, w; m--; ) &amp;#123;
        std::cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; y &amp;gt;&amp;gt; w;
        g[x].emplace_back(y, w);
        g[y].emplace_back(x, w);
    &amp;#125;
    dis[0][0][1] = 0;
    std::array&amp;lt;std::array&amp;lt;std::priority_queue&amp;lt;std::pair&amp;lt;long long, int&amp;gt; &amp;gt;, 2&amp;gt;, 2&amp;gt; q;
    q[0][0].emplace(0, 1);
    for (int i = 0; i &amp;lt; 2; ++i) &amp;#123;
        for (int j = 0; j &amp;lt; 2; ++j) &amp;#123;
            for (; !q[i][j].empty(); ) &amp;#123;
                int f = q[i][j].top().second;
                q[i][j].pop();
                if (vis[i][j][f])
                    continue;
                vis[i][j][f] = 1;
                for (auto k : g[f]) &amp;#123;
                    if (dis[i][j][k.first] &amp;gt; dis[i][j][f] + k.second) &amp;#123;
                        dis[i][j][k.first] = dis[i][j][f] + k.second;
                        q[i][j].emplace(-dis[i][j][k.first], k.first);
                    &amp;#125;
                    if (!i &amp;amp;&amp;amp; dis[1][j][k.first] &amp;gt; dis[i][j][f]) &amp;#123;
                        dis[1][j][k.first] = dis[i][j][f];
                        q[1][j].emplace(-dis[1][j][k.first], k.first);
                    &amp;#125;
                    if (!j &amp;amp;&amp;amp; dis[i][1][k.first] &amp;gt; dis[i][j][f] + 2 * k.second) &amp;#123;
                        dis[i][1][k.first] = dis[i][j][f] + 2 * k.second;
                        q[i][1].emplace(-dis[i][1][k.first], k.first);
                    &amp;#125;
                &amp;#125;
            &amp;#125;
        &amp;#125;
    &amp;#125;
    for (int i = 2; i &amp;lt;= n; ++i)
        std::cout &amp;lt;&amp;lt; std::min(&amp;#123; dis[0][0][i], dis[1][1][i] &amp;#125;) &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
    std::cout &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;b---train-delay&#34;&gt;B - Train Delay&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://vjudge.net/contest/750645#problem/B&#34; class=&#34;uri&#34;&gt;https://vjudge.net/contest/750645#problem/B&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;简化题目很重要的一个转化是&lt;strong&gt;由于 &lt;span class=&#34;math inline&#34;&gt;\(S\le T\)&lt;/span&gt; 带来的 &lt;span class=&#34;math inline&#34;&gt;\(S\)&lt;/span&gt; 和 &lt;span class=&#34;math inline&#34;&gt;\(T\)&lt;/span&gt; 地位平等，考虑把出发和到达分别看作一次事件处理。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;按照所有事件的发生时刻排序，有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于一次出发事件，可以得到在其之前该站点所有到达事件的 &lt;span class=&#34;math inline&#34;&gt;\(\max\{T&amp;#39;\}\)&lt;/span&gt;，用之更新 &lt;span class=&#34;math inline&#34;&gt;\(X\)&lt;/span&gt; 即可。&lt;/li&gt;
&lt;li&gt;对于一次到达事件，由于对应的 &lt;span class=&#34;math inline&#34;&gt;\(X\)&lt;/span&gt; 已经确定，更新该站点当前最大值即可。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, m;
    std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
    std::vector&amp;lt;int&amp;gt; d(m + 1);
    std::cin &amp;gt;&amp;gt; d[1];
    struct event &amp;#123;
        int t, op, id, x;
    &amp;#125;;
    std::vector&amp;lt;event&amp;gt; a;
    std::vector&amp;lt;int&amp;gt; mx(n + 1);
    for (int i = 1, x, y, s, t; i &amp;lt;= m; ++i) &amp;#123;
        std::cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; y &amp;gt;&amp;gt; s &amp;gt;&amp;gt; t;
        a.push_back(&amp;#123; s, 0, i, x &amp;#125;);
        a.push_back(&amp;#123; t, 1, i, y &amp;#125;);
    &amp;#125;
    std::sort(a.begin(), a.end(), [&amp;amp;](event &amp;amp;x, event &amp;amp;y) &amp;#123; return x.t == y.t ? x.op &amp;gt; y.op : x.t &amp;lt; y.t; &amp;#125;);
    for (auto [t, op, id, x] : a)
        if (op == 1)
            mx[x] = std::max(mx[x], t + d[id]);
        else if (id != 1)
            d[id] = std::max(mx[x] - t, 0);
    for (int i = 2; i &amp;lt;= m; ++i)
        std::cout &amp;lt;&amp;lt; d[i] &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
    std::cout &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;c---complete-the-graph&#34;&gt;C - Complete The Graph&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/CF715B&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/CF715B&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;神仙二分&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果初始把所有白边置为 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt;，那么会想到调整法构造&lt;/li&gt;
&lt;li&gt;但是不知道应该在哪些边上调整，确定调整多少似乎也没有什么简单的做法&lt;/li&gt;
&lt;li&gt;&lt;p&gt;故&lt;strong&gt;平均用力&lt;/strong&gt;，构造一个 边1 += 1，边2 += 1，边3 += 1, …, 边cnt0 += 1, 边1 += 1, 边2 += 1, … 的操作序列&lt;/p&gt;
容易&lt;strong&gt;发现每次操作最多让当前最短路长度增加 1&lt;/strong&gt;，而且有单调性&lt;/li&gt;
&lt;li&gt;&lt;p&gt;故二分答案即可&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const __int128 inf = 1e18;
const __int128 inff = 1e23;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, m, s, t, l, cnt = 0;
    std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m &amp;gt;&amp;gt; l &amp;gt;&amp;gt; s &amp;gt;&amp;gt; t, ++s, ++t;
    std::vector&amp;lt;std::tuple&amp;lt;int, int, long long&amp;gt; &amp;gt; u(m + 1);
    std::vector&amp;lt;std::vector&amp;lt;std::pair&amp;lt;int, long long&amp;gt; &amp;gt; &amp;gt; g(n + 1);
    for (int i = 1, x, y; i &amp;lt;= m; ++i) &amp;#123;
        long long w;
        std::cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; y &amp;gt;&amp;gt; w, ++x, ++y;
        if (w == 0)
            w = -(++cnt);
        g[x].emplace_back(y, w), g[y].emplace_back(x, w);
        u[i] = &amp;#123; x, y, w &amp;#125;;
    &amp;#125;
    std::vector&amp;lt;int&amp;gt; vis(n + 1);
    std::vector&amp;lt;__int128&amp;gt; dis(n + 1);
    std::vector&amp;lt;long long&amp;gt; k(cnt + 1);
    __int128 res = -1;
    auto check = [&amp;amp;](__int128 x) &amp;#123;
        for (int i = 1; i &amp;lt;= cnt; ++i)
            k[i] = x / cnt + (i &amp;lt;= x % cnt);
        std::fill(vis.begin() + 1, vis.end(), 0);
        std::fill(dis.begin() + 1, dis.end(), inf);
        std::priority_queue&amp;lt;std::pair&amp;lt;__int128, int&amp;gt; &amp;gt; q;
        dis[s] = 0, q.emplace(0, s);
        for (; !q.empty(); ) &amp;#123;
            int f = q.top().second;
            q.pop();
            if (vis[f])
                continue;
            vis[f] = 1;
            for (auto [v, w] : g[f]) &amp;#123;
                if (w &amp;lt; 0)
                    w = k[-w];
                if (dis[v] &amp;gt; dis[f] + w) &amp;#123;
                    dis[v] = dis[f] + w;
                    q.emplace(-dis[v], v);
                &amp;#125;
            &amp;#125;
        &amp;#125;
        return dis[t] &amp;lt;= l;
    &amp;#125;;
    for (__int128 l = cnt, r = cnt * inf, mid; l &amp;lt;= r; ) &amp;#123;
        mid = (l + r) &amp;gt;&amp;gt; 1;
        if (check(mid))
            res = mid, l = mid + 1;
        else
            r = mid - 1;
    &amp;#125;
    if (res == -1)
        std::cout &amp;lt;&amp;lt; &amp;quot;NO\n&amp;quot;;
    else &amp;#123;
        check(res);
        if (dis[t] != l)
            std::cout &amp;lt;&amp;lt; &amp;quot;NO\n&amp;quot;;
        else &amp;#123;
            std::cout &amp;lt;&amp;lt; &amp;quot;YES\n&amp;quot;;
            for (int i = 1; i &amp;lt;= m; ++i) &amp;#123;
                auto [x, y, w] = u[i];
                if (w &amp;lt; 0)
                    w = k[-w];
                std::cout &amp;lt;&amp;lt; x - 1 &amp;lt;&amp;lt; &amp;#39; &amp;#39; &amp;lt;&amp;lt; y - 1 &amp;lt;&amp;lt; &amp;#39; &amp;#39; &amp;lt;&amp;lt; w &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
            &amp;#125;
        &amp;#125;
    &amp;#125;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;a---重力球&#34;&gt;A - 重力球&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P7473&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P7473&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class=&#34;math inline&#34;&gt;\(m\)&lt;/span&gt; 相对很小，看看有没有什么基于 &lt;span class=&#34;math inline&#34;&gt;\(m\)&lt;/span&gt; 的做法&lt;/li&gt;
&lt;li&gt;每次球停下的位置一定是某个障碍物（或边界）上 / 下 / 左 / 右的格子，故可以在这 &lt;span class=&#34;math inline&#34;&gt;\(O(n + m)\)&lt;/span&gt; 个点上建图&lt;/li&gt;
&lt;li&gt;怎么同时维护两个球的信息呢，发现 &lt;span class=&#34;math inline&#34;&gt;\(m\)&lt;/span&gt; 还是很小，所以可以把两个球塞一起作为一个状态&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(m^2\)&lt;/span&gt; 次 Dij 还是太激进了 进一步思考发现可能的终点共 &lt;span class=&#34;math inline&#34;&gt;\(m\)&lt;/span&gt; 个 并且彼此不区分&lt;/p&gt;
&lt;p&gt;故以这 &lt;span class=&#34;math inline&#34;&gt;\(m\)&lt;/span&gt; 个终点跑多源最短路即可&lt;/p&gt;
&lt;p&gt;但 5e6 跑 Dij 还是太勉强了。&lt;strong&gt;发现边权为 1，为什么不 BFS 呢 😅&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;发现起点可能不在我们限定的点上，但可以人为选择一次重力方向，然后就回到刚刚的问题了&lt;/p&gt;
&lt;p&gt;或者离线也是一种方法&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;疑似常数太大，拼尽全力勉强卡过&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int LEN = (1 &amp;lt;&amp;lt; 20);
#ifdef ONLINE_JUDGE
inline int nec(void) &amp;#123;
    static char buf[LEN], *p = buf, *e = buf;
    if (p == e) &amp;#123;
        e = buf + fread(buf, 1, LEN, stdin);
        if (e == buf)
            return EOF;
        p = buf;
    &amp;#125;
    return *p++;
&amp;#125;
#else
#define nec getchar
#endif
inline bool read(int &amp;amp;x) &amp;#123;
    x = 0;
    bool f = 0;
    char ch = nec();
    while (ch &amp;lt; &amp;#39;0&amp;#39; || ch &amp;gt; &amp;#39;9&amp;#39;) &amp;#123;
        if (ch == EOF)
            return 0;
        if (ch == &amp;#39;-&amp;#39;)
            f = 1;
        ch = nec();
    &amp;#125;
    while (ch &amp;gt;= &amp;#39;0&amp;#39; &amp;amp;&amp;amp; ch &amp;lt;= &amp;#39;9&amp;#39;) &amp;#123;
        x = x * 10 + ch - &amp;#39;0&amp;#39;;
        ch = nec();
    &amp;#125;
    if (f)
        x = -x;
    return 1;
&amp;#125;
void print(int x) &amp;#123;
    if (x &amp;lt; 0) &amp;#123;
        putchar(&amp;#39;-&amp;#39;);
        x = -x;
    &amp;#125;
    if (x &amp;gt;= 10)
        print(x / 10);
    putchar(x % 10 + &amp;#39;0&amp;#39;);
    return;
&amp;#125;
void print(int x, char ch) &amp;#123;
    print(x);
    putchar(ch);
    return;
&amp;#125;
const int inf = 0x3f3f3f3f;
const int dir[][2] = &amp;#123;&amp;#123; -1, 0 &amp;#125;, &amp;#123; 1, 0 &amp;#125;, &amp;#123; 0, -1 &amp;#125;, &amp;#123; 0, 1 &amp;#125;&amp;#125;;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, m, q;
    read(n), read(m), read(q);
    std::vector&amp;lt;std::pair&amp;lt;int, int&amp;gt; &amp;gt; pos(m + 1);
    std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; a(n + 1, std::vector&amp;lt;int&amp;gt; (n + 1));
    for (int i = 1, x, y; i &amp;lt;= m; ++i) &amp;#123;
        read(x), read(y);
        pos[i] = &amp;#123; x, y &amp;#125;, a[x][y] = -1;
    &amp;#125;
    for (int i = 1; i &amp;lt;= n; ++i)
        pos.emplace_back(0, i), ++m;
    for (int i = 1; i &amp;lt;= n; ++i)
        pos.emplace_back(i, n + 1), ++m;
    for (int i = 1; i &amp;lt;= n; ++i)
        pos.emplace_back(n + 1, i), ++m;
    for (int i = 1; i &amp;lt;= n; ++i)
        pos.emplace_back(i, 0), ++m;
    int cnt = 0;
    std::vector&amp;lt;std::pair&amp;lt;int, int&amp;gt; &amp;gt; u(1);
    for (int i = 1; i &amp;lt;= m; ++i)
        for (auto [fx, fy] : dir) &amp;#123;
            int nx = pos[i].first + fx, ny = pos[i].second + fy;
            if (nx &amp;gt;= 1 &amp;amp;&amp;amp; nx &amp;lt;= n &amp;amp;&amp;amp; ny &amp;gt;= 1 &amp;amp;&amp;amp; ny &amp;lt;= n &amp;amp;&amp;amp; !a[nx][ny])
                a[nx][ny] = ++cnt, u.emplace_back(nx, ny);
        &amp;#125;
    std::vector&amp;lt;std::vector&amp;lt;std::array&amp;lt;int, 4&amp;gt; &amp;gt; &amp;gt; top(n + 1, std::vector&amp;lt;std::array&amp;lt;int, 4&amp;gt; &amp;gt; (n + 1));
    for (int j = 1; j &amp;lt;= n; ++j) &amp;#123;
        for (int i = 1; i &amp;lt;= n; ++i)
            if (a[i][j] != -1) &amp;#123;
                if (i == 1 || a[i - 1][j] == -1)
                    top[i][j][0] = a[i][j];
                else
                    top[i][j][0] = top[i - 1][j][0];
            &amp;#125;
        for (int i = n; i; --i)
            if (a[i][j] != -1) &amp;#123;
                if (i == n || a[i + 1][j] == -1)
                    top[i][j][1] = a[i][j];
                else
                    top[i][j][1] = top[i + 1][j][1];
            &amp;#125;
    &amp;#125;
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        for (int j = 1; j &amp;lt;= n; ++j)
            if (a[i][j] != -1) &amp;#123;
                if (j == 1 || a[i][j - 1] == -1)
                    top[i][j][2] = a[i][j];
                else
                    top[i][j][2] = top[i][j - 1][2];
            &amp;#125;
        for (int j = n; j; --j)
            if (a[i][j] != -1) &amp;#123;
                if (j == n || a[i][j + 1] == -1)
                    top[i][j][3] = a[i][j];
                else
                    top[i][j][3] = top[i][j + 1][3];
            &amp;#125;
    &amp;#125;
    const int N = cnt * cnt;
    std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; g(N + 1);
    auto encode = [&amp;amp;](int x, int y) &amp;#123;
        return (x - 1) * cnt + y;
    &amp;#125;;
    auto decode = [&amp;amp;](int id) &amp;#123;
        return std::make_pair((id - 1) / cnt + 1, (id - 1) % cnt + 1);
    &amp;#125;;
    for (int i = 1; i &amp;lt;= N; ++i)
        for (int j = 0; j &amp;lt; 4; ++j) &amp;#123;
            auto [a, b] = decode(i);
            g[encode(top[u[a].first][u[a].second][j], top[u[b].first][u[b].second][j])].emplace_back(i);
        &amp;#125;
    std::vector&amp;lt;int&amp;gt; dis(N + 1, inf), vis(N + 1);
    &amp;#123;
        std::queue&amp;lt;int&amp;gt; q;
        for (int i = 1; i &amp;lt;= cnt; ++i)
            dis[encode(i, i)] = 0, q.push(encode(i, i)), vis[encode(i, i)] = 1;
        for (; !q.empty(); ) &amp;#123;
            int x = q.front();
            q.pop();
            for (auto i : g[x])
                if (!vis[i])
                    dis[i] = dis[x] + 1, vis[i] = 1, q.push(i);
        &amp;#125;
    &amp;#125;
    for (int a, b, c, d; q--; ) &amp;#123;
        read(a), read(b), read(c), read(d);
        if (a == c &amp;amp;&amp;amp; b == d)
            print(0, &amp;#39;\n&amp;#39;);
        else &amp;#123;
            int res = inf;
            for (int j = 0; j &amp;lt; 4; ++j)
                res = std::min(res, dis[encode(top[a][b][j], top[c][d][j])] + 1);
            if (res == inf)
                print(-1, &amp;#39;\n&amp;#39;);
            else
                print(res, &amp;#39;\n&amp;#39;);
        &amp;#125;
    &amp;#125;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;b---矩阵游戏&#34;&gt;B - 矩阵游戏&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P7515&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P7515&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;把问题形式化一下，现在有 &lt;span class=&#34;math inline&#34;&gt;\(n\times m\)&lt;/span&gt; 个未知数和 &lt;span class=&#34;math inline&#34;&gt;\((n-1)\times (m-1)\)&lt;/span&gt; 个方程&lt;/p&gt;
&lt;p&gt;那么可以对边上一圈任意赋值，限制是左上角这 &lt;span class=&#34;math inline&#34;&gt;\((n-1)\times (m-1)\)&lt;/span&gt; 个未知数必须落在 &lt;span class=&#34;math inline&#34;&gt;\([0,10^6]\)&lt;/span&gt; 上&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;有一个很容易观察到的性质，对于一个 &lt;span class=&#34;math inline&#34;&gt;\(a\)&lt;/span&gt;，选取一个 &lt;span class=&#34;math inline&#34;&gt;\(v\)&lt;/span&gt;，并把棋盘黑白染色，那么把所有黑格 &lt;span class=&#34;math inline&#34;&gt;\(+=v\)&lt;/span&gt;，白格 &lt;span class=&#34;math inline&#34;&gt;\(-=v\)&lt;/span&gt;，对应的 &lt;span class=&#34;math inline&#34;&gt;\(b\)&lt;/span&gt; 是不会变的。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;这个操作是涉及全局的，太苛刻了&lt;/strong&gt;，有没有什么更 mild 的构造？&lt;/p&gt;
&lt;p&gt;发现只对一行 / 列黑白染色并操作也可以得到相同的结果。能感受到&lt;strong&gt;操作无法再简化了&lt;/strong&gt;。考虑用这个版本的操作&lt;strong&gt;调整&lt;/strong&gt;。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;故大力令周围一圈的临时解 &lt;span class=&#34;math inline&#34;&gt;\(a&amp;#39;\)&lt;/span&gt; 为 &lt;span class=&#34;math inline&#34;&gt;\(0\)&lt;/span&gt;，令每行、列的调整 delta 为 &lt;span class=&#34;math inline&#34;&gt;\(r_i,c_i\)&lt;/span&gt;，可以得到若干个关于 &lt;span class=&#34;math inline&#34;&gt;\(0\)&lt;/span&gt; 和 &lt;span class=&#34;math inline&#34;&gt;\(10^6\)&lt;/span&gt; 的约束。最后建出来一个完全二分图状物，跑差分约束即可，容易发现复杂度正确。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;实现技巧：规划一下 &lt;span class=&#34;math inline&#34;&gt;\(r\)&lt;/span&gt; 和 &lt;span class=&#34;math inline&#34;&gt;\(c\)&lt;/span&gt; 的染色方式，使得它们错开，可以把所有位置都写作 &lt;span class=&#34;math inline&#34;&gt;\(a&amp;#39;_{i,j}+c-r\)&lt;/span&gt; 或 &lt;span class=&#34;math inline&#34;&gt;\(a&amp;#39;_{i,j}+r-c\)&lt;/span&gt; 的形式，便于差分约束&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;c---tax&#34;&gt;C - Tax&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P6822&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P6822&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;容易想到分类讨论，如果钦定是入边贡献边权，那么出边边权不能大于入边边权；否则，出边贡献边权。&lt;/li&gt;
&lt;li&gt;考虑把每个点上的出边按边权从小到大排序，显然需要入边贡献的是一段前缀，需要出边贡献的是一段后缀，就可以做一个前后缀优化建图。&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const long long inf = 1e18;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, m;
    std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
    struct edge &amp;#123; int v, w, id, pi, si; &amp;#125;;
    std::vector&amp;lt;std::vector&amp;lt;edge&amp;gt; &amp;gt; g1(n + 2);
    std::vector&amp;lt;std::vector&amp;lt;std::pair&amp;lt;int, int&amp;gt; &amp;gt; &amp;gt; g(1);
    int cnt = 0;
    for (int x, y, w; m--; ) &amp;#123;
        std::cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; y &amp;gt;&amp;gt; w;
        g1[x].push_back(&amp;#123; y, w, ++cnt, 0, 0 &amp;#125;);
        g1[y].push_back(&amp;#123; x, w, ++cnt, 0, 0 &amp;#125;);
        g.emplace_back(), g.emplace_back();
    &amp;#125;
    int s = ++cnt, t = ++cnt;
    g1[0].push_back(&amp;#123; 1, 0, s, 0, 0 &amp;#125;), g1[n].push_back(&amp;#123; n + 1, 0, t, 0, 0 &amp;#125;);
    g.emplace_back(), g.emplace_back();
    for (int i = 0; i &amp;lt;= n + 1; ++i)
        if (!g1[i].empty()) &amp;#123;
            std::sort(g1[i].begin(), g1[i].end(), [&amp;amp;](edge &amp;amp;x, edge &amp;amp;y) &amp;#123; return x.w &amp;lt; y.w; &amp;#125;);
            for (int j = 0; j &amp;lt; (int)g1[i].size(); ++j) &amp;#123;
                g1[i][j].pi = ++cnt, g.emplace_back();
                if (j != 0)
                    g[cnt].emplace_back(cnt - 1, 0);
                g[cnt].emplace_back(g1[i][j].id, 0);
            &amp;#125;
            for (int j = (int)g1[i].size() - 1; ~j; --j) &amp;#123;
                g1[i][j].si = ++cnt, g.emplace_back();
                if (j != (int)g1[i].size() - 1)
                    g[cnt].emplace_back(cnt - 1, 0);
                g[cnt].emplace_back(g1[i][j].id, g1[i][j].w);
            &amp;#125;
        &amp;#125;
    for (int i = 0; i &amp;lt;= n + 1; ++i)
        for (auto &amp;amp;[v, w, id, pi, si] : g1[i]) &amp;#123;
            auto to = std::upper_bound(g1[v].begin(), g1[v].end(), w, [&amp;amp;](int x, edge &amp;amp;y) &amp;#123; return x &amp;lt; y.w; &amp;#125;);
            if (to != g1[v].end())
                g[id].emplace_back(to-&amp;gt;si, 0);
            if (to != g1[v].begin())
                g[id].emplace_back((--to)-&amp;gt;pi, w);
        &amp;#125;
    std::vector&amp;lt;int&amp;gt; vis(cnt + 1, 0);
    std::vector&amp;lt;long long&amp;gt; dis(cnt + 1, inf);
    std::priority_queue&amp;lt;std::pair&amp;lt;long long, int&amp;gt; &amp;gt; q;
    dis[s] = 0, q.emplace(0, s);
    for (; !q.empty(); ) &amp;#123;
        int f = q.top().second;
        q.pop();
        if (vis[f])
            continue;
        vis[f] = 1;
        for (auto [v, w] : g[f])
            if (dis[v] &amp;gt; dis[f] + w) &amp;#123;
                dis[v] = dis[f] + w;
                q.emplace(-dis[v], v);
            &amp;#125;
    &amp;#125;
    std::cout &amp;lt;&amp;lt; dis[t] &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;d---travelling-through-the-snow-queens-kingdom&#34;&gt;D - Travelling Through the Snow Queen’s Kingdom&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/CF685E&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/CF685E&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;目前见过的数据范围提示性极弱（误导性极强）的循环结构题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;[BZOJ3620] 似乎在梦中见过的样子&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/20240906/#字符合并&#34;&gt;字符合并&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/20250907/#e---subset-product-problem&#34;&gt;[ARC205E] Subset Product Problem&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;正赛因为有部分分，应该不会出现不敢写的问题&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;考虑离线询问，逆序加边；原文无边权；边的通行时刻只决定到达点的时刻。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;借鉴 &lt;a href=&#34;/20231113/#b.-商人&#34;&gt;merchant&lt;/a&gt; 中的思路，只需要更新当前边两侧点为起点的 DP 数组。&lt;/p&gt;
&lt;p&gt;需要注意边从某种意义上说是『有向』的。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int inf = 0x3f3f3f3f;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, m, q;
    std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m &amp;gt;&amp;gt; q;
    struct query &amp;#123; int r, s, t, id; &amp;#125;;
    std::vector&amp;lt;int&amp;gt; res(q + 1);
    std::vector&amp;lt;std::vector&amp;lt;query&amp;gt; &amp;gt; u(m + 1);
    std::vector&amp;lt;std::pair&amp;lt;int, int&amp;gt; &amp;gt; e(m + 1);
    for (int i = 1; i &amp;lt;= m; ++i)
        std::cin &amp;gt;&amp;gt; e[i].first &amp;gt;&amp;gt; e[i].second;
    for (int i = 1, l, r, s, t; i &amp;lt;= q; ++i) &amp;#123;
        std::cin &amp;gt;&amp;gt; l &amp;gt;&amp;gt; r &amp;gt;&amp;gt; s &amp;gt;&amp;gt; t;
        u[l].push_back(&amp;#123; r, s, t, i &amp;#125;);
    &amp;#125;
    std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; g(n + 1, std::vector&amp;lt;int&amp;gt; (n + 1, inf));
    for (int i = m; i; --i) &amp;#123;
        auto [x, y] = e[i];
        g[x][y] = g[y][x] = i;
        for (int j = 1; j &amp;lt;= n; ++j)
            g[x][j] = g[y][j] = std::min(g[x][j], g[y][j]);
        for (auto [r, s, t, id] : u[i])
            if (g[s][t] &amp;lt;= r)
                res[id] = 1;
    &amp;#125;
    for (int i = 1; i &amp;lt;= q; ++i)
        std::cout &amp;lt;&amp;lt; (res[i] ? &amp;quot;Yes&amp;quot; : &amp;quot;No&amp;quot;) &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;e---culture-code&#34;&gt;E - Culture Code&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/CF1197E&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/CF1197E&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;先按 &lt;span class=&#34;math inline&#34;&gt;\(out\)&lt;/span&gt; 排序，做一个前缀优化建图。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;容易发现除了最外层，每一个套娃都会提供 &lt;span class=&#34;math inline&#34;&gt;\(in_i-out_i\)&lt;/span&gt; 的代价，而最外层会提供 &lt;span class=&#34;math inline&#34;&gt;\(in_x\)&lt;/span&gt; 的代价。&lt;/p&gt;
&lt;del&gt;好在要求的是最长路，这样就可以 Dij 了&lt;/del&gt;，并不需要真正把图建出来，发现这个形式更序列，直接在序列上二分前缀 + DP 即可。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;求方案是容易的。最后统计 DP 值最大，&lt;strong&gt;且不能被其他套娃包含的元素&lt;/strong&gt;即可。&lt;/p&gt;
&lt;p&gt;Tip：在求解过程中并不用考虑当前元素和前缀 min 元素间能否加入其他套娃，因为保证 &lt;span class=&#34;math inline&#34;&gt;\(out&amp;gt;in\)&lt;/span&gt;，如果存在这样的套娃，其 DP 值会比前缀 min 更小，矛盾。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int mod = 1e9 + 7;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n;
    std::cin &amp;gt;&amp;gt; n;
    std::vector&amp;lt;std::pair&amp;lt;int, int&amp;gt; &amp;gt; a(n + 1);
    int mxi = 0;
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        std::cin &amp;gt;&amp;gt; a[i].first &amp;gt;&amp;gt; a[i].second;
        mxi = std::max(mxi, a[i].second);
    &amp;#125;
    std::sort(a.begin() + 1, a.end());
    std::vector&amp;lt;long long&amp;gt; g(n + 1), mxg(n + 1), f(n + 1), mx(n + 1);
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        int j = std::upper_bound(a.begin() + 1, a.begin() + i, std::make_pair(a[i].second, 0x3f3f3f3f)) - a.begin() - 1;
        if (j == 0)
            f[i] = a[i].second, g[i] = 1ll;
        else
            f[i] = mx[j] + a[i].second, g[i] = mxg[j];
        long long now = f[i] - a[i].first;
        if (now &amp;lt; mx[i - 1])
            mx[i] = now, mxg[i] = g[i];
        else if (now == mx[i - 1])
            mx[i] = now, mxg[i] = (mxg[i - 1] + g[i]) % mod;
        else
            mx[i] = mx[i - 1], mxg[i] = mxg[i - 1];
    &amp;#125;
    auto now = 0x3f3f3f3fll, res = 0ll;
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        if (a[i].first &amp;lt;= mxi)
            continue;
        if (f[i] &amp;lt; now)
            now = f[i], res = g[i];
        else if (f[i] == now)
            (res += g[i]) %= mod;
    &amp;#125;
    std::cout &amp;lt;&amp;lt; res &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;a---awesome-arrowland-adventure&#34;&gt;A - Awesome Arrowland Adventure&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P6233&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P6233&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;没什么好说的建图，注意只能顺时针转&lt;/li&gt;
&lt;li&gt;代码略&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;b---地铁线路&#34;&gt;B - 地铁线路&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P6096&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P6096&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;考虑做一个神秘拆点，把每个点附上线路和运行方向的信息（所以是单向的）&lt;/li&gt;
&lt;li&gt;认为路径代价是二元组，那么同条线路中的点通行代价为 &lt;span class=&#34;math inline&#34;&gt;\((0,-1)\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;换乘需要优化建图，每个点可以花 &lt;span class=&#34;math inline&#34;&gt;\((0,0)\)&lt;/span&gt; 的代价走到这个点的『换乘点』，再花 &lt;span class=&#34;math inline&#34;&gt;\((1,0)\)&lt;/span&gt; 的代价走到另一个分点&lt;/li&gt;
&lt;li&gt;&lt;p&gt;但 &lt;strong&gt;15 年的时候 SPFA 已经死了&lt;/strong&gt;，所以需要好好考虑怎么实现最短路。&lt;/p&gt;
&lt;p&gt;分两问是有提示性在的，可以想到 01 BFS 解决第一个关键字，比较对的想法是&lt;strong&gt;把所有最短路拿出来形成 DAG，在 DAG 上对第二关键字 DP&lt;/strong&gt;。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, m;
    std::cin &amp;gt;&amp;gt; m &amp;gt;&amp;gt; n;
    std::unordered_map&amp;lt;std::string, int&amp;gt; tab;
    std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; l(n + 1);
    std::vector&amp;lt;std::vector&amp;lt;std::tuple&amp;lt;int, int, int&amp;gt; &amp;gt; &amp;gt; g0(n + 1), g1(n + 1);
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        std::string s;
        std::cin &amp;gt;&amp;gt; s, tab[s] = i;
    &amp;#125;
    int tot = n;
    for (int i = 1, k; i &amp;lt;= m; ++i) &amp;#123;
        std::cin &amp;gt;&amp;gt; k;
        int lp = 0, lq = 0;
        for (std::string s; k--; ) &amp;#123;
            std::cin &amp;gt;&amp;gt; s;
            int p = ++tot, q = ++tot, id = tab[s];
            g0.emplace_back(), g0.emplace_back();
            g1.emplace_back(), g1.emplace_back();
            if (lp) &amp;#123;
                g0[p].emplace_back(lp, 0, 1), g0[lq].emplace_back(q, 0, 1);
                g1[lp].emplace_back(p, 0, 1), g1[q].emplace_back(lq, 0, 1);
            &amp;#125;
            g0[p].emplace_back(id, 0, 0), g0[id].emplace_back(p, 1, 0);
            g1[id].emplace_back(p, 0, 0), g1[p].emplace_back(id, 1, 0);
            g0[q].emplace_back(id, 0, 0), g0[id].emplace_back(q, 1, 0);
            g1[id].emplace_back(q, 0, 0), g1[q].emplace_back(id, 1, 0);
            l[id].push_back(p), l[id].push_back(q);
            lp = p, lq = q;
        &amp;#125;
    &amp;#125;
    int s, t;
    &amp;#123;
        std::string s1, s2;
        std::cin &amp;gt;&amp;gt; s1 &amp;gt;&amp;gt; s2;
        s = ++tot, t = tab[s2];
        g0.emplace_back(), g1.emplace_back();
        int p = tab[s1];
        for (auto i : l[p])
            g0[s].emplace_back(i, 1, 0), g1[i].emplace_back(s, 1, 0);
    &amp;#125;
    std::vector&amp;lt;int&amp;gt; dis0(tot + 1, 0x3f3f3f3f), dis1(tot + 1, 0x3f3f3f3f);
    auto BFS = [&amp;amp;](decltype(g0) &amp;amp;g, decltype(dis0) &amp;amp;dis, int s) &amp;#123;
        std::deque&amp;lt;int&amp;gt; q;
        std::vector&amp;lt;int&amp;gt; vis(tot + 1);
        q.push_back(s), dis[s] = 0;
        for (; !q.empty(); ) &amp;#123;
            int x = q.front();
            q.pop_front();
            if (vis[x])
                continue;
            vis[x] = 1;
            for (auto [v, w1, w2] : g[x])
                if (dis[x] + w1 &amp;lt; dis[v]) &amp;#123;
                    dis[v] = dis[x] + w1;
                    if (w1 == 0)
                        q.push_front(v);
                    else
                        q.push_back(v);
                &amp;#125;
        &amp;#125;
        return;
    &amp;#125;;
    BFS(g0, dis0, s), BFS(g1, dis1, t);
    std::cout &amp;lt;&amp;lt; dis0[t] &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    std::vector&amp;lt;int&amp;gt; deg(tot + 1);
    std::vector&amp;lt;std::vector&amp;lt;std::pair&amp;lt;int, int&amp;gt; &amp;gt; &amp;gt; g(tot + 1);
    for (int i = 1; i &amp;lt;= tot; ++i)
        for (auto [j, w1, w2] : g0[i])
            if (dis0[i] + dis1[j] + w1 == dis0[t])
                g[i].emplace_back(j, w2), ++deg[j];
    std::queue&amp;lt;int&amp;gt; q;
    for (int i = 1; i &amp;lt;= tot; ++i)
        if (!deg[i])
            q.push(i);
    std::vector&amp;lt;int&amp;gt; f(tot + 1);
    for (; !q.empty(); ) &amp;#123;
        int x = q.front();
        q.pop();
        for (auto [v, w] : g[x]) &amp;#123;
            f[v] = std::max(f[v], f[x] + w);
            if (!--deg[v])
                q.push(v);
        &amp;#125;
    &amp;#125;
    std::cout &amp;lt;&amp;lt; f[t] &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;c---droga-do-domu&#34;&gt;C - Droga do domu&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P9402&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P9402&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;还是做一个和上一题类似的优化建图&lt;/li&gt;
&lt;li&gt;此外就是一个普通的 Dij 上 DP 了。&lt;strong&gt;图没有环&lt;/strong&gt;，直接拓扑即可。&lt;/li&gt;
&lt;li&gt;可以滚动优化空间，但似乎并无必要。代码略。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;d---tickets-p&#34;&gt;D - Tickets P&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P7984&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P7984&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;没什么好说的线段树优化建图，难点在于如何同时获取 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt; 和 &lt;span class=&#34;math inline&#34;&gt;\(N\)&lt;/span&gt; 的信息&lt;/li&gt;
&lt;li&gt;&lt;p&gt;发现从某个点走到 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt; 和 &lt;span class=&#34;math inline&#34;&gt;\(N\)&lt;/span&gt;，有一种不劣的走法：&lt;/p&gt;
&lt;img src=&#34;image.png&#34; /&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;维护一下每个点单独走到 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt;，&lt;span class=&#34;math inline&#34;&gt;\(N\)&lt;/span&gt; 的最小代价和同时走到 &lt;span class=&#34;math inline&#34;&gt;\(1,N\)&lt;/span&gt; 的最小代价&lt;/p&gt;
看到一种更加对的写法是&lt;strong&gt;令 &lt;span class=&#34;math inline&#34;&gt;\(f_u\)&lt;/span&gt; 表示 &lt;span class=&#34;math inline&#34;&gt;\(v\)&lt;/span&gt; 的答案，那么可以用 &lt;span class=&#34;math inline&#34;&gt;\(f_v+w(u,v)\)&lt;/span&gt; 更新 &lt;span class=&#34;math inline&#34;&gt;\(f_u\)&lt;/span&gt;&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;那么可以从 &lt;span class=&#34;math inline&#34;&gt;\(1,N\)&lt;/span&gt; 出发做一个 Dij。代码略。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;e---监狱&#34;&gt;E - 监狱&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P9520&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P9520&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;注意要走简单路径，也就是说不存在绕路让道的可能性。容易推出：若输入合法，总能找到一种方式使得每个人受到的指令是连续给出的。&lt;/p&gt;
&lt;p&gt;P.S. 这个结论挪到图上就不成立了，很容易举出反例。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image-1.png&#34; /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;若一个人的起点 / 终点在另一个人的路径上，那么这两个人之间存在先后关系。建图后检查是否为 DAG 即可。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;但建图显然是比较困难的，容易构造出数据使得边数来到 &lt;span class=&#34;math inline&#34;&gt;\(n^2\)&lt;/span&gt; 级别。考虑优化建图。&lt;/p&gt;
&lt;p&gt;发现可以用一个树剖 / 倍增的结构来建图。&lt;/p&gt;
Tips：这一点同样是一个树上路径问题。参见 &lt;a href=&#34;/20231117/#树上问题&#34;&gt;树上问题，倍增和树剖的选择？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;这里的路径要求两端都是开的，这就导致倍增写着很困难（虽然树剖可能也是），不排除我写丑了&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int K = 19;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;01-02.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int T;
    for (std::cin &amp;gt;&amp;gt; T; T--; ) &amp;#123;
        int n, m;
        std::cin &amp;gt;&amp;gt; n;
        std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; g1(n + 1);
        std::vector&amp;lt;int&amp;gt; s(n + 1), t(n + 1);
        for (int i = 1, x, y; i &amp;lt; n; ++i) &amp;#123;
            std::cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; y;
            g1[x].push_back(y), g1[y].push_back(x);
        &amp;#125;
        std::cin &amp;gt;&amp;gt; m;
        std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; g(m + 1);
        std::vector&amp;lt;std::pair&amp;lt;int, int&amp;gt; &amp;gt; a(m + 1);
        for (int i = 1; i &amp;lt;= m; ++i) &amp;#123;
            std::cin &amp;gt;&amp;gt; a[i].first &amp;gt;&amp;gt; a[i].second;
            s[a[i].first] = i;
            t[a[i].second] = i;
        &amp;#125;
        int cnt = m;
        struct node &amp;#123; int fa, i0, i1; &amp;#125;;
        std::vector&amp;lt;std::array&amp;lt;node, K + 1&amp;gt; &amp;gt; p(n + 1);
        std::vector&amp;lt;int&amp;gt; i0(n + 1), i1(n + 1), dep(n + 1), deg(m + 1);
        auto init = [&amp;amp;](void) &amp;#123;
            g.emplace_back(), deg.emplace_back();
            return ++cnt;
        &amp;#125;;
        auto add = [&amp;amp;](int x, int y) &amp;#123;
            g[x].push_back(y), ++deg[y];
            return;
        &amp;#125;;
        for (int i = 1; i &amp;lt;= n; ++i)
            i0[i] = init(), i1[i] = init();
        std::function&amp;lt;void(int, int)&amp;gt; DFS = [&amp;amp;](int x, int fa) &amp;#123;
            if (s[x])
                add(s[x], i1[x]);
            if (t[x])
                add(i0[x], t[x]);
            for (auto i : g1[x])
                if (i != fa) &amp;#123;
                    dep[i] = dep[x] + 1;
                    p[i][0].fa = x;
                    p[i][0].i0 = init(), p[i][0].i1 = init();
                    add(p[i][0].i0, i0[i]), add(i1[i], p[i][0].i1);
                    for (int j = 1; j &amp;lt;= K; ++j) &amp;#123;
                        p[i][j].fa = p[p[i][j - 1].fa][j - 1].fa;
                        if (!p[i][j].fa)
                            break;
                        p[i][j].i0 = init(), p[i][j].i1 = init();
                        add(p[i][j].i0, p[i][j - 1].i0);
                        add(p[i][j].i0, p[p[i][j - 1].fa][j - 1].i0);
                        add(p[i][j - 1].i1, p[i][j].i1);
                        add(p[p[i][j - 1].fa][j - 1].i1, p[i][j].i1);
                    &amp;#125;
                    DFS(i, x);
                &amp;#125;
            return;
        &amp;#125;;
        dep[1] = 1, DFS(1, -1);
        for (int i = 1; i &amp;lt;= m; ++i) &amp;#123;
            auto [x, y] = a[i];
            if (x == y)
                continue;
            if (t[x])
                add(i, t[x]);
            if (s[y])
                add(s[y], i);
            if (dep[x] &amp;lt; dep[y])
                std::swap(x, y);
            x = p[x][0].fa;
            if (dep[x] &amp;gt;= dep[y]) &amp;#123;
                for (int j = K; ~j; --j)
                    if (dep[p[x][j].fa] &amp;gt;= dep[y]) &amp;#123;
                        add(i, p[x][j].i0), add(p[x][j].i1, i);
                        x = p[x][j].fa;
                    &amp;#125;
                if (x == y)
                    continue;
                add(i, p[x][0].i0), add(p[x][0].i1, i);
                x = p[x][0].fa;
            &amp;#125;
            y = p[y][0].fa;
            if (x != y) &amp;#123;
                for (int j = K; ~j; --j)
                    if (p[x][j].fa != p[y][j].fa) &amp;#123;
                        add(i, p[x][j].i0), add(i, p[y][j].i0);
                        add(p[x][j].i1, i), add(p[y][j].i1, i);
                        x = p[x][j].fa, y = p[y][j].fa;
                    &amp;#125;
                add(i, p[x][0].i0), add(i, p[y][0].i0);
                add(p[x][0].i1, i), add(p[y][0].i1, i);
                x = p[x][0].fa;
            &amp;#125;
            add(i, i0[x]), add(i1[x], i);
        &amp;#125;
        std::queue&amp;lt;int&amp;gt; q;
        for (int i = 1; i &amp;lt;= cnt; ++i)
            if (!deg[i])
                q.push(i);
        int tot = 0;
        for (; !q.empty(); ) &amp;#123;
            int x = q.front();
            q.pop(), ++tot;
            for (auto i : g[x])
                if (!--deg[i])
                    q.push(i);
        &amp;#125;
        std::cout &amp;lt;&amp;lt; (tot == cnt ? &amp;quot;Yes&amp;quot; : &amp;quot;No&amp;quot;) &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    &amp;#125;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://xsc062.netlify.app/20250922/</guid>
            <title>杂题</title>
            <link>https://xsc062.netlify.app/20250922/</link>
            <pubDate>Mon, 22 Sep 2025 18:37:38 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;最近的几场 abc, arc, cf, 模拟赛题&lt;/p&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;g---set-list&#34;&gt;G - Set list&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/abc424/tasks/abc424_g&#34; class=&#34;uri&#34;&gt;https://atcoder.jp/contests/abc424/tasks/abc424_g&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;b---slime-swap&#34;&gt;B - Slime Swap&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/arc206/tasks/arc206_b&#34; class=&#34;uri&#34;&gt;https://atcoder.jp/contests/arc206/tasks/arc206_b&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;d---lis-lds&#34;&gt;D - LIS ∩ LDS&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/arc206/tasks/arc206_d&#34; class=&#34;uri&#34;&gt;https://atcoder.jp/contests/arc206/tasks/arc206_d&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;bubble-sort&#34;&gt;#3761. Bubble Sort&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://poj.org/problem?id=3761&#34; class=&#34;uri&#34;&gt;http://poj.org/problem?id=3761&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;f.-bubble-sort&#34;&gt;F. Bubble Sort&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://codeforces.com/contest/2146/problem/F&#34; class=&#34;uri&#34;&gt;https://codeforces.com/contest/2146/problem/F&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;e.-limited-edition-shop&#34;&gt;E. Limited Edition Shop&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://codeforces.com/contest/2151/problem/E&#34; class=&#34;uri&#34;&gt;https://codeforces.com/contest/2151/problem/E&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;构造几个 &lt;span class=&#34;math inline&#34;&gt;\(n=2,3\)&lt;/span&gt; 的例子手玩一下，会发现对于 &lt;span class=&#34;math inline&#34;&gt;\(a,b\)&lt;/span&gt; 两个元素，如果在 A 里的相对顺序是 ab，在 B 里的相对顺序是 ba，那么要选 b 就必须选 a。&lt;/li&gt;
&lt;li&gt;那么会想到把 A 变成 &lt;span class=&#34;math inline&#34;&gt;\(1\sim n\)&lt;/span&gt;，那么对于 B 中的一个元素，如果其后方有更小的元素，那么必须选了它才能选这个数。&lt;/li&gt;
&lt;li&gt;考虑在 B 中 DP 最后选出来的集合，那么对于当前的 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt;，&lt;strong&gt;若不选，则不允许『已选集合』中存在 &lt;span class=&#34;math inline&#34;&gt;\(&amp;gt;x\)&lt;/span&gt; 的数。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;故令 &lt;span class=&#34;math inline&#34;&gt;\(f_{i,j}\)&lt;/span&gt; 表示 DP 到 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt;，当前已选集合最大值为 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; 的最大集合大小，那么有：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
f_{i,B_i}\gets f_{i-1,j}+v, j&amp;lt;B_i\\
f_{i,j}\gets f_{i-1, j}+v, j &amp;gt; B_i\\
f_{i,j}\gets f_{i-1,j}, j &amp;lt; B_i
\]&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;显然可以线段树优化转移&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int maxn = 2e5 + 5;
const long long inf = 1e18;
struct &amp;#123;
    int l, r;
    long long u, d;
&amp;#125; t[maxn &amp;lt;&amp;lt; 2];
#define lt (p &amp;lt;&amp;lt; 1)
#define rt (lt | 1)
void pushval(int p, long long v) &amp;#123;
    t[p].d += v, t[p].u += v;
    return;
&amp;#125;
void pushdown(int p) &amp;#123;
    pushval(lt, t[p].d), pushval(rt, t[p].d);
    t[p].d = 0ll;
    return;
&amp;#125;
void pushup(int p) &amp;#123;
    t[p].u = std::max(t[lt].u, t[rt].u);
    return;
&amp;#125;
void bld(int p, int l, int r) &amp;#123;
    t[p].l = l, t[p].r = r;
    t[p].u = -inf, t[p].d = 0ll;
    if (l == r)
        return;
    int mid = (t[p].l + t[p].r) &amp;gt;&amp;gt; 1;
    bld(lt, l, mid), bld(rt, mid + 1, r);
    return;
&amp;#125;
void upd(int p, int x, long long v) &amp;#123;
    t[p].u = std::max(t[p].u, v);
    if (t[p].l == t[p].r)
        return;
    pushdown(p);
    int mid = (t[p].l + t[p].r) &amp;gt;&amp;gt; 1;
    if (x &amp;lt;= mid)
        upd(lt, x, v);
    else
        upd(rt, x, v);
    return;
&amp;#125;
void add(int p, int l, int r, long long v) &amp;#123;
    if (l &amp;lt;= t[p].l &amp;amp;&amp;amp; t[p].r &amp;lt;= r) &amp;#123;
        pushval(p, v);
        return;
    &amp;#125;
    pushdown(p);
    int mid = (t[p].l + t[p].r) &amp;gt;&amp;gt; 1;
    if (l &amp;lt;= mid)
        add(lt, l, r, v);
    if (r &amp;gt; mid)
        add(rt, l, r, v);
    pushup(p);
    return;
&amp;#125;
long long ask(int p, int l, int r) &amp;#123;
    if (l &amp;lt;= t[p].l &amp;amp;&amp;amp; t[p].r &amp;lt;= r)
        return t[p].u;
    pushdown(p);
    long long res = -inf;
    int mid = (t[p].l + t[p].r) &amp;gt;&amp;gt; 1;
    if (l &amp;lt;= mid)
        res = ask(lt, l, r);
    if (r &amp;gt; mid)
        res = std::max(res, ask(rt, l, r));
    return res;
&amp;#125;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int T;
    for (std::cin &amp;gt;&amp;gt; T; T--; ) &amp;#123;
        int n;
        std::cin &amp;gt;&amp;gt; n;
        std::vector&amp;lt;int&amp;gt; w(n + 1), k(n + 1), a(n + 1), b(n + 1), tab(n + 1);
        for (int i = 1; i &amp;lt;= n; ++i)
            std::cin &amp;gt;&amp;gt; w[i];
        for (int i = 1; i &amp;lt;= n; ++i)
            std::cin &amp;gt;&amp;gt; a[i], tab[a[i]] = i;
        for (int i = 1; i &amp;lt;= n; ++i)
            k[i] = w[a[i]];
        for (int i = 1; i &amp;lt;= n; ++i)
            std::cin &amp;gt;&amp;gt; b[i], b[i] = tab[b[i]];
        bld(1, 0, n), upd(1, 0, 0);
        for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
            if (b[i] != n)
                add(1, b[i] + 1, n, k[b[i]]);
            upd(1, b[i], ask(1, 0, b[i] - 1) + k[b[i]]);
        &amp;#125;
        std::cout &amp;lt;&amp;lt; t[1].u &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    &amp;#125;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;a.-小猪盖房子&#34;&gt;A. 小猪盖房子&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://222.180.160.110:61235/problem/51898&#34; class=&#34;uri&#34;&gt;http://222.180.160.110:61235/problem/51898&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定一个 &lt;span class=&#34;math inline&#34;&gt;\(n\times m\)&lt;/span&gt; 的 01 矩阵，每一行有 2 个 1 或没有 1。现需选择两个&lt;strong&gt;相邻的&lt;/strong&gt;行区间，并为&lt;strong&gt;范围内的空行&lt;/strong&gt;选择两个位置改为 1，使得这两个区间是全等的。&lt;/p&gt;
&lt;p&gt;求可能的方案。当空行的涂色方式不同或选择范围不同看作不同的方案。对 &lt;span class=&#34;math inline&#34;&gt;\(998244353\)&lt;/span&gt; 取模。&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(n,m\le 5000\)&lt;/span&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;第一反应是枚举分界线 + 上端点，发现没有办法做：当上端点移动的时候，下部矩形会整体平移。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;进一步考虑导致这个问题的原因&lt;/strong&gt;，感受到一个因素是长度在变。&lt;/li&gt;
&lt;li&gt;故固定长度枚举，前缀和统计 &lt;span class=&#34;math inline&#34;&gt;\(\dfrac {m(m-1)}2\)&lt;/span&gt; 的幂次即可。&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int mod = 998244353;
int main() &amp;#123;
    std::freopen(&amp;quot;piggy.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;piggy.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
    const auto stime = std::chrono::steady_clock::now();
    int n, m;
    std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
    std::vector&amp;lt;std::array&amp;lt;int, 2&amp;gt; &amp;gt; a(n + 1);
    std::vector&amp;lt;long long&amp;gt; ps(n + 1);
    const int s = m * (m - 1) / 2;
    ps[0] = 1ll;
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        std::cin &amp;gt;&amp;gt; a[i][0] &amp;gt;&amp;gt; a[i][1];
        ps[i] = ps[i - 1] * s % mod;
    &amp;#125;
    auto res = 0ll;
    for (int i = 1; i &amp;lt;= n / 2; ++i) &amp;#123;
        std::vector&amp;lt;int&amp;gt; cnt0(n + 1), cnts(n + 1);
        for (int u = 1; u &amp;lt;= n - i; ++u) &amp;#123;
            int d = u + i;
            if (!a[u][0] &amp;amp;&amp;amp; !a[d][0])
                cnts[u] = 1;
            else if (a[u][0] &amp;amp;&amp;amp; a[d][0] &amp;amp;&amp;amp; (a[u][0] != a[d][0] || a[u][1] != a[d][1]))
                cnt0[u] = 1;
            cnts[u] += cnts[u - 1], cnt0[u] += cnt0[u - 1];
        &amp;#125;
        for (int u = 1; u &amp;lt;= n - 2 * i + 1; ++u) &amp;#123;
            int ss = cnts[u + i - 1] - cnts[u - 1], s0 = cnt0[u + i - 1] - cnt0[u - 1];
            if (!s0)
                (res += ps[ss] % mod) %= mod;
        &amp;#125;
    &amp;#125;
    std::cout &amp;lt;&amp;lt; res &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;b.-换乘旅行&#34;&gt;B. 换乘旅行&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://222.180.160.110:61235/problem/51900&#34; class=&#34;uri&#34;&gt;http://222.180.160.110:61235/problem/51900&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;手玩可以发现『环』在题目中是一个很重要的东西&lt;/li&gt;
&lt;li&gt;重要性质：考虑一个环第一次被访问的点，一定会从这个点出发把这个环访问一遍，反证法易证。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;故可以把每个环给『删除』。可以用下图概括所有情况。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;假设当前以 &lt;span class=&#34;math inline&#34;&gt;\(s\)&lt;/span&gt; 为起点，终点为 &lt;span class=&#34;math inline&#34;&gt;\(t\)&lt;/span&gt;，且之前已经在以 &lt;span class=&#34;math inline&#34;&gt;\(s&amp;#39;\)&lt;/span&gt; 为起点时访问过了一部分路径上的点。&lt;/p&gt;
&lt;p&gt;那么此时 &lt;span class=&#34;math inline&#34;&gt;\(m\to t\)&lt;/span&gt; 是有答案的，而 &lt;span class=&#34;math inline&#34;&gt;\(s\to m\)&lt;/span&gt; 都可以继承 &lt;span class=&#34;math inline&#34;&gt;\(m\)&lt;/span&gt; 的答案。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::freopen(&amp;quot;travel.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;travel.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n;
    std::cin &amp;gt;&amp;gt; n;
    std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; g(n + 1);
    std::vector&amp;lt;std::vector&amp;lt;int&amp;gt;::iterator&amp;gt; it(n + 1);
    for (int i = 1, k; i &amp;lt;= n; ++i) &amp;#123;
        std::cin &amp;gt;&amp;gt; k;
        for (int x; k--; )
            std::cin &amp;gt;&amp;gt; x, g[i].push_back(x);
        it[i] = g[i].begin();
    &amp;#125;
    std::vector&amp;lt;int&amp;gt; res(n + 1), inq(n + 1);
    for (int i = 1; i &amp;lt;= n; ++i)
        if (!res[i]) &amp;#123;
            std::stack&amp;lt;int&amp;gt; st;
            for (int x = i; ; ) &amp;#123;
                if (it[x] == g[x].end() || res[x]) &amp;#123;
                    if (!res[x])
                        res[x] = x;
                    res[i] = res[x];
                    for (; !st.empty(); st.pop())
                        res[st.top()] = res[x], inq[st.top()] = 0;
                    break;
                &amp;#125;
                st.push(x), inq[x] = 1, x = *it[x];
                if (inq[x])
                    for (int p = -1; p != x; ) &amp;#123;
                        p = st.top(), st.pop();
                        inq[p] = 0, ++it[p];
                    &amp;#125;
            &amp;#125;
        &amp;#125;
    for (int i = 1; i &amp;lt;= n; ++i)
        std::cout &amp;lt;&amp;lt; res[i] &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://xsc062.netlify.app/20250921/</guid>
            <title>线段树杂题</title>
            <link>https://xsc062.netlify.app/20250921/</link>
            <category>线段树</category>
            <pubDate>Sun, 21 Sep 2025 16:44:54 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;信息转化为主&lt;/p&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;b---into-blocks-hard-version&#34;&gt;B - Into Blocks (hard version)&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/CF1209G2&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/CF1209G2&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;trick：考察每个颜色出现的区间 &lt;span class=&#34;math inline&#34;&gt;\([s_{col},t_{col}]\)&lt;/span&gt;，对每个 &lt;span class=&#34;math inline&#34;&gt;\([s_{col},t_{col})\)&lt;/span&gt; 打标记，则没有被打过标记的点后能够进行一次分段。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;对于每一段，其代价为段长度 - 众数出现次数。&lt;/p&gt;
这个众数乍一看有点吓人，实际上发现由于每个元素出现的所有位置都在这个段里，所以可以记录每个元素的个数，对于每个元素只钦定其中一个位置来记录即可快速维护。&lt;/li&gt;
&lt;li&gt;发现线段树能够比较容易地维护全局查询：维护 &lt;span class=&#34;math inline&#34;&gt;\(0\)&lt;/span&gt; 位置是经典 trick；且容易发现『段长』之和为 &lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt;，故只需维护众数。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;实现技巧：单点本身就是自己的最小值，从这一点出发可以规避很多边界情况。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int lim = 2e5;
const int maxn = 2e5 + 5;
struct node &amp;#123;
    int l, r, u, d;
    int lu, ru, mn, mx;
    node operator+ (const node &amp;amp;q) const &amp;#123;
        node res;
        res.d = 0;
        res.l = l, res.r = q.r;
        res.mx = std::max(mx, q.mx);
        res.mn = std::min(mn, q.mn);
        if (mn &amp;lt; q.mn) &amp;#123;
            res.mn = mn, res.u = u;
            res.lu = lu, res.ru = std::max(q.mx, ru);
        &amp;#125;
        else if (q.mn &amp;lt; mn) &amp;#123;
            res.mn = q.mn, res.u = q.u;
            res.lu = std::max(mx, q.lu), res.ru = q.ru;
        &amp;#125;
        else &amp;#123;
            res.lu = lu, res.ru = q.ru;
            res.u = u + q.u + std::max(ru, q.lu);
        &amp;#125;
        return res;
    &amp;#125;
&amp;#125; t[maxn &amp;lt;&amp;lt; 2];
#define lt (p &amp;lt;&amp;lt; 1)
#define rt (lt | 1)
void bld(int p, int l, int r) &amp;#123;
    t[p].l = l, t[p].r = r;
    if (l == r)
        return;
    int mid = (l + r) &amp;gt;&amp;gt; 1;
    bld(lt, l, mid), bld(rt, mid + 1, r);
    return;
&amp;#125;
void pushval(int p, int d) &amp;#123;
    t[p].mn += d, t[p].d += d;
    return;
&amp;#125;
void pushdown(int p) &amp;#123;
    pushval(lt, t[p].d), pushval(rt, t[p].d);
    t[p].d = 0;
    return;
&amp;#125;
void upd(int p, int x, int v) &amp;#123;
    if (t[p].l == t[p].r) &amp;#123;
        t[p].u = t[p].mx = v;
        return;
    &amp;#125;
    pushdown(p);
    int mid = (t[p].l + t[p].r) &amp;gt;&amp;gt; 1;
    if (x &amp;lt;= mid)
        upd(lt, x, v);
    else
        upd(rt, x, v);
    t[p] = t[lt] + t[rt];
    return;
&amp;#125;
void add(int p, int l, int r, int v) &amp;#123;
    if (l &amp;lt;= t[p].l &amp;amp;&amp;amp; t[p].r &amp;lt;= r) &amp;#123;
        pushval(p, v);
        return;
    &amp;#125;
    pushdown(p);
    int mid = (t[p].l + t[p].r) &amp;gt;&amp;gt; 1;
    if (l &amp;lt;= mid)
        add(lt, l, r, v);
    if (r &amp;gt; mid)
        add(rt, l, r, v);
    t[p] = t[lt] + t[rt];
    return;
&amp;#125;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, q;
    std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; q;
    std::vector&amp;lt;int&amp;gt; a(n + 1);
    std::vector&amp;lt;std::set&amp;lt;int&amp;gt; &amp;gt; st(lim + 1);
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        std::cin &amp;gt;&amp;gt; a[i];
        st[a[i]].emplace(i);
    &amp;#125;
    bld(1, 1, n);
    for (int i = 1; i &amp;lt;= lim; ++i)
        if (!st[i].empty()) &amp;#123;
            int s = *st[i].begin(), t = *--st[i].end();
            if (s &amp;lt;= t - 1)
                add(1, s, t - 1, 1);
            upd(1, s, (int)st[i].size());
        &amp;#125;
    std::cout &amp;lt;&amp;lt; n - ::t[1].u - ::t[1].lu - ::t[1].ru  &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    auto work = [&amp;amp;](int v, int k) &amp;#123;
        if (st[v].empty())
            return;
        int s = *st[v].begin(), t = *--st[v].end();
        if (s &amp;lt;= t - 1)
            add(1, s, t - 1, k);
        upd(1, s, k == 1 ? (int)st[v].size() : 0);
        return;
    &amp;#125;;
    for (int i, x; q--; ) &amp;#123;
        std::cin &amp;gt;&amp;gt; i &amp;gt;&amp;gt; x;
        work(a[i], -1), st[a[i]].erase(i), work(a[i], 1);
        a[i] = x;
        work(a[i], -1), st[a[i]].insert(i), work(a[i], 1);
        std::cout &amp;lt;&amp;lt; n - ::t[1].u - ::t[1].lu - ::t[1].ru  &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    &amp;#125;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;c---seats-排座位&#34;&gt;C - seats 排座位&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P4898&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P4898&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;很有价值的一个题&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;对于一个固定的 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt;，考虑怎么刻画合法矩形&lt;/p&gt;
&lt;p&gt;发现『前 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 个元素构成矩形』比『大小为 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 的矩形包含前 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 个元素』更合理&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;考虑前 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 个元素在满足什么条件时构成矩形&lt;/p&gt;
&lt;p&gt;我最开始的想法是『记录这 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 个元素占据的最大、最小、最左、最右，如果乘起来为 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt;，那么合法』&lt;/p&gt;
&lt;p&gt;但会发现这个转化是不好做的，或者说就又往上面那个错误的判定转化（大小为 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 的矩形包含前 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 个元素）靠了。两个都有一个共同的问题，就是过于依赖这个 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt;，限制太具体了，导致不能很好地应用到每个 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;现在这个判定的转化比较合理的地方就在于，对矩形本身不存在约束，只是要求构成矩形。这样就允许直接从图形出发，&lt;strong&gt;更多地考虑怎样用单点信息合并出矩形与否&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;把 &lt;span class=&#34;math inline&#34;&gt;\([0,k)\)&lt;/span&gt; 染成黑色，其他为白色，那么有一个粗暴但简单的方法来刻画『矩形』这个要求：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;图形存在四个『角』。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;再刻画一下『角』：黑点左上 / 左下 / 右上 / 右下两个点都为白。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;当然这样是很荒谬的，因为下图显然不只有四个角。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image-1.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;所以我们不得不把一个凹角也算作角，不难发现把上方凸角的定义中的主体换成白点即可定义凹角。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;优化：算贡献&lt;/p&gt;
&lt;p&gt;维护当前时刻，所有 &lt;span class=&#34;math inline&#34;&gt;\(4nm\)&lt;/span&gt; 个角在 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 处是否存在&lt;/p&gt;
&lt;p&gt;此时要用一个类似维护 &lt;span class=&#34;math inline&#34;&gt;\(0\)&lt;/span&gt; 个数的方法来维护有 &lt;span class=&#34;math inline&#34;&gt;\(4\)&lt;/span&gt; 个角个数的 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 个数。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;考虑这么一个可能的角：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;其存在当且仅当 &lt;span class=&#34;math inline&#34;&gt;\(A\)&lt;/span&gt; 为黑，&lt;span class=&#34;math inline&#34;&gt;\(B,C\)&lt;/span&gt; 为白（凸角），或 &lt;span class=&#34;math inline&#34;&gt;\(A\)&lt;/span&gt; 为白，&lt;span class=&#34;math inline&#34;&gt;\(B,C\)&lt;/span&gt; 为黑（凹角）。&lt;/p&gt;
&lt;p&gt;考察 &lt;span class=&#34;math inline&#34;&gt;\(A,B,C\)&lt;/span&gt; 第一次变黑的时间 &lt;span class=&#34;math inline&#34;&gt;\(k_A,k_B,k_C\)&lt;/span&gt;，那么 &lt;span class=&#34;math inline&#34;&gt;\(A\)&lt;/span&gt; 能够对所有 &lt;span class=&#34;math inline&#34;&gt;\(k\in[k_A,\min\{k_B,k_C\})\)&lt;/span&gt; 和 &lt;span class=&#34;math inline&#34;&gt;\(k\in[\max\{k_B,k_C\},k_A)\)&lt;/span&gt; 造成贡献。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;每次修改只会做 &lt;span class=&#34;math inline&#34;&gt;\(O(1)\)&lt;/span&gt; 次区间加，是可维护的。注意两个被交换的点可能会有公共的相邻点，需要特别处理一下。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;这个东西本质上可以看作一个 2⨉2 的&lt;a href=&#34;https://blog.csdn.net/asplh/article/details/136652197&#34;&gt;Soble 算子&lt;/a&gt;，所以可以抠出来一般定义上的角&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;p&gt;non-interactive version:&lt;/p&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int dir[][2] = &amp;#123; &amp;#123; 0, -1 &amp;#125;, &amp;#123; 0, 1 &amp;#125;, &amp;#123; -1, 0 &amp;#125;, &amp;#123; 1, 0 &amp;#125; &amp;#125;;
const int maxn = 1e6 + 5;
struct node &amp;#123;
    int l, r, u, d, mn;
    node operator+ (const node &amp;amp;q) const &amp;#123;
        node res;
        res.l = l, res.r = q.r, res.d = 0;
        res.mn = std::min(mn, q.mn), res.u = 0;
        if (mn == res.mn)
            res.u = u;
        if (q.mn == res.mn)
            res.u += q.u;
        return res;
    &amp;#125;
&amp;#125; t[maxn &amp;lt;&amp;lt; 2];
#define lt (p &amp;lt;&amp;lt; 1)
#define rt (lt | 1)
void bld(int p, int l, int r) &amp;#123;
    t[p].l = l, t[p].r = r, t[p].u = r - l + 1;
    if (l == r)
        return;
    int mid = (l + r) &amp;gt;&amp;gt; 1;
    bld(lt, l, mid), bld(rt, mid + 1, r);
    return;
&amp;#125;
void pushval(int p, int v) &amp;#123;
    t[p].mn += v, t[p].d += v;
    return;
&amp;#125;
void pushdown(int p) &amp;#123;
    pushval(lt, t[p].d), pushval(rt, t[p].d);
    t[p].d = 0;
    return;
&amp;#125;
void add(int p, int l, int r, int v) &amp;#123;
    if (l &amp;lt;= t[p].l &amp;amp;&amp;amp; t[p].r &amp;lt;= r) &amp;#123;
        pushval(p, v);
        return;
    &amp;#125;
    pushdown(p);
    int mid = (t[p].l + t[p].r) &amp;gt;&amp;gt; 1;
    if (l &amp;lt;= mid)
        add(lt, l, r, v);
    if (r &amp;gt; mid)
        add(rt, l, r, v);
    t[p] = t[lt] + t[rt];
    return;
&amp;#125;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, m, q;
    std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m &amp;gt;&amp;gt; q;
    const int N = n * m;
    std::vector&amp;lt;std::pair&amp;lt;int, int&amp;gt; &amp;gt; pos(N + 1);
    std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; id(n + 2, std::vector&amp;lt;int&amp;gt; (m + 2, N + 1));
    for (int i = 1, x, y; i &amp;lt;= N; ++i) &amp;#123;
        std::cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; y, ++x, ++y;
        id[x][y] = i, pos[i] = &amp;#123; x, y &amp;#125;;
    &amp;#125;
    bld(1, 1, N);
    auto work = [&amp;amp;](int x, int y, int k) &amp;#123;
        for (int i = 0; i &amp;lt; 2; ++i)
            for (int j = 2; j &amp;lt; 4; ++j) &amp;#123;
                int x1 = x + dir[j][0], y1 = y + dir[i][1];
                if (id[x][y] &amp;lt; std::min(id[x1][y], id[x][y1]))
                    add(1, id[x][y], std::min(id[x1][y], id[x][y1]) - 1, k);
                if (std::max(id[x1][y], id[x][y1]) &amp;lt; id[x][y])
                    add(1, std::max(id[x1][y], id[x][y1]), id[x][y] - 1, k);
            &amp;#125;
        return;
    &amp;#125;;
    for (int i = 1; i &amp;lt;= n; ++i)
        for (int j = 1; j &amp;lt;= m; ++j)
            work(i, j, 1);
    for (int i1, i2; q--; ) &amp;#123;
        std::cin &amp;gt;&amp;gt; i1 &amp;gt;&amp;gt; i2, ++i1, ++i2;
        auto [x1, y1] = pos[i1];
        auto [x2, y2] = pos[i2];
        std::set&amp;lt;std::pair&amp;lt;int, int&amp;gt; &amp;gt; st;
        st.emplace(x1, y1);
        for (auto [fx, fy] : dir) &amp;#123;
            int x = x1 + fx, y = y1 + fy;
            if (x &amp;gt;= 1 &amp;amp;&amp;amp; x &amp;lt;= n &amp;amp;&amp;amp; y &amp;gt;= 1 &amp;amp;&amp;amp; y &amp;lt;= m)
                st.emplace(x, y);
        &amp;#125;
        st.emplace(x2, y2);
        for (auto [fx, fy] : dir) &amp;#123;
            int x = x2 + fx, y = y2 + fy;
            if (x &amp;gt;= 1 &amp;amp;&amp;amp; x &amp;lt;= n &amp;amp;&amp;amp; y &amp;gt;= 1 &amp;amp;&amp;amp; y &amp;lt;= m)
                st.emplace(x, y);
        &amp;#125;
        for (auto [x, y] : st)
            work(x, y, -1);
        std::swap(id[x1][y1], id[x2][y2]), std::swap(pos[i1], pos[i2]);
        for (auto [x, y] : st)
            work(x, y, 1);
        std::cout &amp;lt;&amp;lt; t[1].u &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    &amp;#125;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;interactive version:&lt;/p&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
#ifdef ONLINE_JUDGE
#include &amp;quot;seats.h&amp;quot;
#endif
const int dir[][2] = &amp;#123; &amp;#123; 0, -1 &amp;#125;, &amp;#123; 0, 1 &amp;#125;, &amp;#123; -1, 0 &amp;#125;, &amp;#123; 1, 0 &amp;#125; &amp;#125;;
const int maxn = 1e6 + 5;
struct node &amp;#123;
    int l, r, u, d, mn;
    node operator+ (const node &amp;amp;q) const &amp;#123;
        node res;
        res.l = l, res.r = q.r, res.d = 0;
        res.mn = std::min(mn, q.mn), res.u = 0;
        if (mn == res.mn)
            res.u = u;
        if (q.mn == res.mn)
            res.u += q.u;
        return res;
    &amp;#125;
&amp;#125; t[maxn &amp;lt;&amp;lt; 2];
#define lt (p &amp;lt;&amp;lt; 1)
#define rt (lt | 1)
void bld(int p, int l, int r) &amp;#123;
    t[p].l = l, t[p].r = r, t[p].u = r - l + 1;
    if (l == r)
        return;
    int mid = (l + r) &amp;gt;&amp;gt; 1;
    bld(lt, l, mid), bld(rt, mid + 1, r);
    return;
&amp;#125;
void pushval(int p, int v) &amp;#123;
    t[p].mn += v, t[p].d += v;
    return;
&amp;#125;
void pushdown(int p) &amp;#123;
    pushval(lt, t[p].d), pushval(rt, t[p].d);
    t[p].d = 0;
    return;
&amp;#125;
void add(int p, int l, int r, int v) &amp;#123;
    if (l &amp;lt;= t[p].l &amp;amp;&amp;amp; t[p].r &amp;lt;= r) &amp;#123;
        pushval(p, v);
        return;
    &amp;#125;
    pushdown(p);
    int mid = (t[p].l + t[p].r) &amp;gt;&amp;gt; 1;
    if (l &amp;lt;= mid)
        add(lt, l, r, v);
    if (r &amp;gt; mid)
        add(rt, l, r, v);
    t[p] = t[lt] + t[rt];
    return;
&amp;#125;
int n, m, N;
std::vector&amp;lt;std::pair&amp;lt;int, int&amp;gt; &amp;gt; pos;
std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; id(n + 2, std::vector&amp;lt;int&amp;gt; (m + 2, N + 1));
void work(int x, int y, int k) &amp;#123;
    for (int i = 0; i &amp;lt; 2; ++i)
        for (int j = 2; j &amp;lt; 4; ++j) &amp;#123;
            int x1 = x + dir[j][0], y1 = y + dir[i][1];
            if (id[x][y] &amp;lt; std::min(id[x1][y], id[x][y1]))
                add(1, id[x][y], std::min(id[x1][y], id[x][y1]) - 1, k);
            if (std::max(id[x1][y], id[x][y1]) &amp;lt; id[x][y])
                add(1, std::max(id[x1][y], id[x][y1]), id[x][y] - 1, k);
        &amp;#125;
    return;
&amp;#125;;
void give_initial_chart(int n, int m, std::vector&amp;lt;int&amp;gt; R, std::vector&amp;lt;int&amp;gt; C) &amp;#123;
    ::n = n, ::m = m, N = n * m;
    pos.resize(N + 1);
    id.assign(n + 2, std::vector&amp;lt;int&amp;gt; (m + 2, N + 1));
    for (int i = 0; i &amp;lt; N; ++i) &amp;#123;
        int x = R[i] + 1, y = C[i] + 1;
        id[x][y] = i + 1, pos[i + 1] = &amp;#123; x, y &amp;#125;;
    &amp;#125;
    bld(1, 1, N);
    for (int i = 1; i &amp;lt;= n; ++i)
        for (int j = 1; j &amp;lt;= m; ++j)
            work(i, j, 1);
    return;
&amp;#125;
int swap_seats(int i1, int i2) &amp;#123;
    ++i1, ++i2;
    auto [x1, y1] = pos[i1];
    auto [x2, y2] = pos[i2];
    std::set&amp;lt;std::pair&amp;lt;int, int&amp;gt; &amp;gt; st;
    st.emplace(x1, y1);
    for (auto [fx, fy] : dir) &amp;#123;
        int x = x1 + fx, y = y1 + fy;
        if (x &amp;gt;= 1 &amp;amp;&amp;amp; x &amp;lt;= n &amp;amp;&amp;amp; y &amp;gt;= 1 &amp;amp;&amp;amp; y &amp;lt;= m)
            st.emplace(x, y);
    &amp;#125;
    st.emplace(x2, y2);
    for (auto [fx, fy] : dir) &amp;#123;
        int x = x2 + fx, y = y2 + fy;
        if (x &amp;gt;= 1 &amp;amp;&amp;amp; x &amp;lt;= n &amp;amp;&amp;amp; y &amp;gt;= 1 &amp;amp;&amp;amp; y &amp;lt;= m)
            st.emplace(x, y);
    &amp;#125;
    for (auto [x, y] : st)
        work(x, y, -1);
    std::swap(id[x1][y1], id[x2][y2]), std::swap(pos[i1], pos[i2]);
    for (auto [x, y] : st)
        work(x, y, 1);
    return t[1].u;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;d---单旋&#34;&gt;D - 单旋&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P3721&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P3721&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;发现任意时刻参与旋转的都是最值，简单分析可以发现做的这件事情是把最值移到根，其他点相对关系不变，转化为维护深度&lt;/li&gt;
&lt;li&gt;考虑新加入点，可以利用 BST 的性质，直接查询 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 的前驱、后继，则二者存在祖孙关系，把 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 接在矮的下面即可&lt;/li&gt;
&lt;li&gt;考虑做一个先删再加的过程，删会影响儿子的深度（显然只有一侧儿子），加会影响全树深度&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;e---nekameleoni&#34;&gt;E - NEKAMELEONI&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P7230&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P7230&lt;/a&gt;&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://xsc062.netlify.app/20250911/</guid>
            <title>吉司机 + 历史和练习</title>
            <link>https://xsc062.netlify.app/20250911/</link>
            <category>线段树</category>
            <pubDate>Thu, 11 Sep 2025 17:27:05 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;并非所有历史和都是吉司机&lt;/p&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;a---just-another-game-of-stones&#34;&gt;A - Just Another Game of Stones&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P9631&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P9631&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;发现如果选定了这一步取的位置 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt;，那么要拿的石子是定值 &lt;span class=&#34;math inline&#34;&gt;\(a_i-a_i\oplus s\)&lt;/span&gt;，当 &lt;span class=&#34;math inline&#34;&gt;\(a_i\le a_i\oplus s\)&lt;/span&gt; 时不合法。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;可以用吉司机维护修改和区间异或和，那么询问需要转化。&lt;/p&gt;
答案为 &lt;span class=&#34;math inline&#34;&gt;\(a_i&amp;gt;a_i\oplus s\)&lt;/span&gt; 的次数，结合&lt;strong&gt;异或是不带进位的区间加&lt;/strong&gt;的观点，考察『加数』&lt;span class=&#34;math inline&#34;&gt;\(s\)&lt;/span&gt; 的最高位，当且仅当 &lt;span class=&#34;math inline&#34;&gt;\(a_i\)&lt;/span&gt; 在这一位为 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt; 时有贡献。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;故再维护一下每一位为 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt; 的个数即可。复杂度 &lt;span class=&#34;math inline&#34;&gt;\(O(q\log n\log V)\)&lt;/span&gt;。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int inf = 1 &amp;lt;&amp;lt; 30;
const int maxn = 2e5 + 5;
struct &amp;#123;
    std::array&amp;lt;int, 30&amp;gt; u;
    int l, r, cnt, mn, se, d, s;
&amp;#125; t[maxn &amp;lt;&amp;lt; 2];
#define lt (p &amp;lt;&amp;lt; 1)
#define rt (lt | 1)
int a[maxn];
void pushup(int p) &amp;#123;
    if (t[lt].mn == t[rt].mn) &amp;#123;
        t[p].mn = t[lt].mn, t[p].cnt = t[lt].cnt + t[rt].cnt;
        t[p].se = std::min(t[lt].se, t[rt].se);
    &amp;#125;
    else if (t[lt].mn &amp;lt; t[rt].mn) &amp;#123;
        t[p].mn = t[lt].mn, t[p].cnt = t[lt].cnt;
        t[p].se = std::min(t[lt].se, t[rt].mn);
    &amp;#125;
    else &amp;#123;
        t[p].mn = t[rt].mn, t[p].cnt = t[rt].cnt;
        t[p].se = std::min(t[lt].mn, t[rt].se);
    &amp;#125;
    t[p].s = t[lt].s ^ t[rt].s;
    for (int i = 0; i &amp;lt; 30; ++i)
        t[p].u[i] = t[lt].u[i] + t[rt].u[i];
    return;
&amp;#125;
void bld(int p, int l, int r) &amp;#123;
    t[p].d = -inf;
    t[p].l = l, t[p].r = r;
    if (l == r) &amp;#123;
        for (int i = 0; i &amp;lt; 30; ++i)
            t[p].u[i] = (a[l] &amp;gt;&amp;gt; i) &amp;amp; 1;
        t[p].s = t[p].mn = a[l], t[p].cnt = 1, t[p].se = inf;
        return;
    &amp;#125;
    int mid = (l + r) &amp;gt;&amp;gt; 1;
    bld(lt, l, mid), bld(rt, mid + 1, r);
    pushup(p);
    return;
&amp;#125;
void pushval(int p, int v) &amp;#123;
    if (v &amp;gt; t[p].mn) &amp;#123;
        for (int i = 0; i &amp;lt; 30; ++i) &amp;#123;
            if ((t[p].mn &amp;gt;&amp;gt; i) &amp;amp; 1)
                t[p].u[i] -= t[p].cnt;
            if ((v &amp;gt;&amp;gt; i) &amp;amp; 1)
                t[p].u[i] += t[p].cnt;
        &amp;#125;
        if (t[p].cnt &amp;amp; 1)
            t[p].s ^= t[p].mn ^ v;
        t[p].mn = t[p].d = v;
    &amp;#125;
    return;
&amp;#125;
void pushdown(int p) &amp;#123;
    if (t[p].d != -inf) &amp;#123;
        pushval(lt, t[p].d), pushval(rt, t[p].d);
        t[p].d = -inf;
    &amp;#125;
    return;
&amp;#125;
void add(int p, int l, int r, int v) &amp;#123;
    if (t[p].mn &amp;gt;= v)
        return;
    if (l &amp;lt;= t[p].l &amp;amp;&amp;amp; t[p].r &amp;lt;= r &amp;amp;&amp;amp; v &amp;lt; t[p].se) &amp;#123;
        pushval(p, v);
        return;
    &amp;#125;
    pushdown(p);
    int mid = (t[p].l + t[p].r) &amp;gt;&amp;gt; 1;
    if (l &amp;lt;= mid)
        add(lt, l, r, v);
    if (r &amp;gt; mid)
        add(rt, l, r, v);
    pushup(p);
    return;
&amp;#125;
int askt(int p, int l, int r, int i) &amp;#123;
    if (l &amp;lt;= t[p].l &amp;amp;&amp;amp; t[p].r &amp;lt;= r)
        return t[p].u[i];
    pushdown(p);
    int mid = (t[p].l + t[p].r) &amp;gt;&amp;gt; 1, res = 0;
    if (l &amp;lt;= mid)
        res = askt(lt, l, r, i);
    if (r &amp;gt; mid)
        res += askt(rt, l, r, i);
    return res;
&amp;#125;
int asks(int p, int l, int r) &amp;#123;
    if (l &amp;lt;= t[p].l &amp;amp;&amp;amp; t[p].r &amp;lt;= r)
        return t[p].s;
    pushdown(p);
    int mid = (t[p].l + t[p].r) &amp;gt;&amp;gt; 1, res = 0;
    if (l &amp;lt;= mid)
        res = asks(lt, l, r);
    if (r &amp;gt; mid)
        res ^= asks(rt, l, r);
    return res;
&amp;#125;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, m;
    std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
    for (int i = 1; i &amp;lt;= n; ++i)
        std::cin &amp;gt;&amp;gt; a[i];
    bld(1, 1, n);
    for (int op, l, r, v; m--; ) &amp;#123;
        std::cin &amp;gt;&amp;gt; op &amp;gt;&amp;gt; l &amp;gt;&amp;gt; r &amp;gt;&amp;gt; v;
        if (op == 1)
            add(1, l, r, v);
        else &amp;#123;
            int s = asks(1, l, r) ^ v;
            if (s == 0) &amp;#123;
                std::cout &amp;lt;&amp;lt; 0 &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
                continue;
            &amp;#125;
            int t = std::__lg(s);
            std::cout &amp;lt;&amp;lt; askt(1, l, r, t) + ((v &amp;gt;&amp;gt; t) &amp;amp; 1) &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
        &amp;#125;
    &amp;#125;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;b---prof.-pangs-sequence-c---test_90&#34;&gt;B - Prof. Pang’s sequence / C - TEST_90&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P10822&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P10822&lt;/a&gt; / &lt;a href=&#34;https://www.luogu.com.cn/problem/P9990&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P9990&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;历史和维护子区间问题是一个固定的 trick，只需要对于每一个 &lt;span class=&#34;math inline&#34;&gt;\(r\)&lt;/span&gt;，给合法的 &lt;span class=&#34;math inline&#34;&gt;\(l\)&lt;/span&gt; 加一。&lt;/li&gt;
&lt;li&gt;离线扫描线，对于当前右端点 &lt;span class=&#34;math inline&#34;&gt;\(r\)&lt;/span&gt;，记录每种数最后一次出现的位置 &lt;span class=&#34;math inline&#34;&gt;\(pos\)&lt;/span&gt;。令 &lt;span class=&#34;math inline&#34;&gt;\(r\)&lt;/span&gt; 的颜色为 &lt;code&gt;1&lt;/code&gt;，从右到左，每碰到一个新的 &lt;span class=&#34;math inline&#34;&gt;\(pos\)&lt;/span&gt; 就切换颜色&lt;/li&gt;
&lt;li&gt;显然对于当前 &lt;span class=&#34;math inline&#34;&gt;\(r\)&lt;/span&gt;，应该被加一的 &lt;span class=&#34;math inline&#34;&gt;\(l\)&lt;/span&gt; 就是颜色为 &lt;code&gt;1&lt;/code&gt; 的这些位置。&lt;/li&gt;
&lt;li&gt;考虑更快地维护这个过程，也就是在 &lt;span class=&#34;math inline&#34;&gt;\(r\)&lt;/span&gt; 的颜色和 &lt;span class=&#34;math inline&#34;&gt;\(r-1\)&lt;/span&gt; 不同时就可以对 &lt;span class=&#34;math inline&#34;&gt;\([1,r)\)&lt;/span&gt; 做一次 flip，是可行的&lt;/li&gt;
&lt;li&gt;在每个 &lt;span class=&#34;math inline&#34;&gt;\(r\)&lt;/span&gt; 处查询 &lt;span class=&#34;math inline&#34;&gt;\([l,r]\)&lt;/span&gt; 的区间和即可。&lt;/li&gt;
&lt;li&gt;吐槽：并非所有历史和都是吉司机&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int maxn = 5e5 + 5;
struct &amp;#123;
    long long s;
    int l, r, d0, d1, df, ds, u0, u1;
&amp;#125; t[maxn &amp;lt;&amp;lt; 2];
#define lt (p &amp;lt;&amp;lt; 1)
#define rt (lt | 1)
void pushup(int p) &amp;#123;
    t[p].u0 = t[lt].u0 + t[rt].u0;
    t[p].u1 = t[lt].u1 + t[rt].u1;
    return;
&amp;#125;
void pushval(int p, long long v0, long long v1, bool f) &amp;#123;
    if (f) &amp;#123;
        t[p].df ^= 1;
        std::swap(t[p].u0, t[p].u1);
        std::swap(t[p].d0, t[p].d1);
    &amp;#125;
    t[p].d0 += v0, t[p].d1 += v1;
    t[p].s += t[p].u0 * v0 + t[p].u1 * v1;
    return;
&amp;#125;
void pushdown(int p) &amp;#123;
    pushval(lt, t[p].d0, t[p].d1, t[p].df);
    pushval(rt, t[p].d0, t[p].d1, t[p].df);
    t[p].d0 = t[p].d1 = t[p].df = 0;
    return;
&amp;#125;
void bld(int p, int l, int r) &amp;#123;
    t[p].l = l, t[p].r = r;
    t[p].u0 = r - l + 1;
    if (l == r)
        return;
    int mid = (l + r) &amp;gt;&amp;gt; 1;
    bld(lt, l, mid), bld(rt, mid + 1, r);
    return;
&amp;#125;
void flip(int p, int l, int r) &amp;#123;
    if (l &amp;lt;= t[p].l &amp;amp;&amp;amp; t[p].r &amp;lt;= r) &amp;#123;
        pushval(p, 0, 0, 1);
        return;
    &amp;#125;
    pushdown(p);
    int mid = (t[p].l + t[p].r) &amp;gt;&amp;gt; 1;
    if (l &amp;lt;= mid)
        flip(lt, l, r);
    if (r &amp;gt; mid)
        flip(rt, l, r);
    pushup(p);
    return;
&amp;#125;
long long ask(int p, int l, int r) &amp;#123;
    if (l &amp;lt;= t[p].l &amp;amp;&amp;amp; t[p].r &amp;lt;= r)
        return t[p].s;
    pushdown(p);
    auto res(0ll);
    int mid = (t[p].l + t[p].r) &amp;gt;&amp;gt; 1;
    if (l &amp;lt;= mid)
        res = ask(lt, l, r);
    if (r &amp;gt; mid)
        res += ask(rt, l, r);
    return res;
&amp;#125;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n;
    std::cin &amp;gt;&amp;gt; n;
    std::vector&amp;lt;int&amp;gt; a(n + 1), la(n + 1);
    for (int i = 1; i &amp;lt;= n; ++i)
        std::cin &amp;gt;&amp;gt; a[i];
    int m;
    std::cin &amp;gt;&amp;gt; m;
    std::vector&amp;lt;long long&amp;gt; res(m + 1);
    std::vector&amp;lt;std::vector&amp;lt;std::pair&amp;lt;int, int&amp;gt; &amp;gt; &amp;gt; u(n + 1);
    for (int i = 1, l, r; i &amp;lt;= m; ++i) &amp;#123;
        std::cin &amp;gt;&amp;gt; l &amp;gt;&amp;gt; r;
        u[r].emplace_back(l, i);
    &amp;#125;
    bld(1, 1, n);
    for (int r = 1; r &amp;lt;= n; ++r) &amp;#123;
        flip(1, la[a[r]] + 1, r);
        pushval(1, 0, 1, 0);
        for (auto [l, id] : u[r])
            res[id] = ask(1, l, r);
        la[a[r]] = r;
    &amp;#125;
    for (int i = 1; i &amp;lt;= m; ++i)
        std::cout &amp;lt;&amp;lt; res[i] &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;d---stations&#34;&gt;D - Stations&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/CF1572F&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/CF1572F&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不太能直接维护 &lt;span class=&#34;math inline&#34;&gt;\(b\)&lt;/span&gt;，但发现如果维护每个 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 最远能到达的点，发现每次更新 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; 会把 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; 左边的所有点值和 &lt;span class=&#34;math inline&#34;&gt;\(j-1\)&lt;/span&gt; 取 min。&lt;/li&gt;
&lt;li&gt;发现吉司机能够在取 min 的同时在另一个树状树组里维护差分&lt;/li&gt;
&lt;li&gt;需要注意更新的时机，应该是每次线段树更新函数访问到完整节点时。&lt;/li&gt;
&lt;li&gt;复杂度 &lt;span class=&#34;math inline&#34;&gt;\(O(q\log^2n)\)&lt;/span&gt;。但真的吗？单点修改似乎对势能有影响？然而并不会相关分析。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;看起来有点激进了，没想到确实是正解。&lt;/p&gt;
&lt;details&gt;
&lt;p&gt;可以发现树状数组在时间上确实是有优势的&lt;/p&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int maxn = 2e5 + 5;
const int inf = 0x3f3f3f3f;
struct &amp;#123;
    int l, r, mx, se, d, cnt;
&amp;#125; t[maxn &amp;lt;&amp;lt; 2];
#define lt (p &amp;lt;&amp;lt; 1)
#define rt (lt | 1)
int n;
long long bit[maxn][2];
int lowbit(int x) &amp;#123; return x &amp;amp; -x; &amp;#125;
void add(int x, long long v) &amp;#123;
    for (int i = x; i &amp;lt;= n; i += lowbit(i))
        bit[i][0] += v, bit[i][1] += v * (x - 1);
    return;
&amp;#125;
long long ask(int x) &amp;#123;
    auto res = 0ll;
    for (int i = x; i; i -= lowbit(i))
        res += bit[i][0] * x - bit[i][1];
    return res;
&amp;#125;
void pushup(int p) &amp;#123;
    if (t[lt].mx == t[rt].mx) &amp;#123;
        t[p].mx = t[lt].mx, t[p].cnt = t[lt].cnt + t[rt].cnt;
        t[p].se = std::max(t[lt].se, t[rt].se);
    &amp;#125;
    else if (t[lt].mx &amp;gt; t[rt].mx) &amp;#123;
        t[p].mx = t[lt].mx, t[p].cnt = t[lt].cnt;
        t[p].se = std::max(t[lt].se, t[rt].mx);
    &amp;#125;
    else &amp;#123;
        t[p].mx = t[rt].mx, t[p].cnt = t[rt].cnt;
        t[p].se = std::max(t[lt].mx, t[rt].se);
    &amp;#125;
    return;
&amp;#125;
void bld(int p, int l, int r) &amp;#123;
    t[p].d = inf;
    t[p].l = l, t[p].r = r;
    if (l == r) &amp;#123;
        add(l, 1), add(l + 1, -1);
        t[p].mx = l, t[p].se = -1, t[p].cnt = 1;
        return;
    &amp;#125;
    int mid = (l + r) &amp;gt;&amp;gt; 1;
    bld(lt, l, mid), bld(rt, mid + 1, r);
    pushup(p);
    return;
&amp;#125;
void pushval(int p, int v) &amp;#123;
    if (v &amp;lt;= t[p].mx)
        t[p].mx = t[p].d = v;
    return;
&amp;#125;
void pushdown(int p) &amp;#123;
    if (t[p].d != inf) &amp;#123;
        pushval(lt, t[p].d), pushval(rt, t[p].d);
        t[p].d = inf;
    &amp;#125;
    return;
&amp;#125;
void add(int p, int l, int r, int v) &amp;#123;
    if (t[p].mx &amp;lt;= v)
        return;
    if (l &amp;lt;= t[p].l &amp;amp;&amp;amp; t[p].r &amp;lt;= r &amp;amp;&amp;amp; v &amp;gt; t[p].se) &amp;#123;
        add(t[p].mx + 1, t[p].cnt);
        add(v + 1, -t[p].cnt);
        pushval(p, v);
        return;
    &amp;#125;
    pushdown(p);
    int mid = (t[p].l + t[p].r) &amp;gt;&amp;gt; 1;
    if (l &amp;lt;= mid)
        add(lt, l, r, v);
    if (r &amp;gt; mid)
        add(rt, l, r, v);
    pushup(p);
    return;
&amp;#125;
void upd(int p, int x, int v) &amp;#123;
    if (t[p].l == t[p].r) &amp;#123;
        add(t[p].mx + 1, 1), add(v + 1, -1);
        t[p].mx = v;
        return;
    &amp;#125;
    pushdown(p);
    int mid = (t[p].l + t[p].r) &amp;gt;&amp;gt; 1;
    if (x &amp;lt;= mid)
        upd(lt, x, v);
    else
        upd(rt, x, v);
    pushup(p);
    return;
&amp;#125;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int m;
    std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
    bld(1, 1, n);
    for (int op; m--; ) &amp;#123;
        std::cin &amp;gt;&amp;gt; op;
        if (op == 1) &amp;#123;
            int x, v;
            std::cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; v;
            if (x != 1)
                add(1, 1, x - 1, x - 1);
            upd(1, x, v);
            // for (int i = 1; i &amp;lt;= n; ++i)
            //     std::cout &amp;lt;&amp;lt; ask(i) - ask(i - 1) &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
            // std::cout &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
        &amp;#125;
        else &amp;#123;
            int l, r;
            std::cin &amp;gt;&amp;gt; l &amp;gt;&amp;gt; r;
            std::cout &amp;lt;&amp;lt; ask(r) - ask(l - 1) &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
        &amp;#125;
    &amp;#125;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;e---luotianyi-and-the-function&#34;&gt;E - LuoTianyi and the Function&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://codeforces.com/problemset/problem/1824/D&#34; class=&#34;uri&#34;&gt;https://codeforces.com/problemset/problem/1824/D&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;由于 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; 和函数关联更强，考虑把 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; 这一维扫描线 + 差分掉&lt;/li&gt;
&lt;li&gt;经典套路，维护每个 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 从右向左第一次出现的位置 &lt;span class=&#34;math inline&#34;&gt;\(pos_x\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;每次 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; 移动一下，会更新一段区间（可能不存在）的 &lt;span class=&#34;math inline&#34;&gt;\(g\)&lt;/span&gt; 值，它们原本为 &lt;span class=&#34;math inline&#34;&gt;\(pos_{a_j}\)&lt;/span&gt;，需要被更新为下一个 &lt;span class=&#34;math inline&#34;&gt;\(pos\)&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;记录值为 &lt;span class=&#34;math inline&#34;&gt;\(pos_x\)&lt;/span&gt; 的区间，做区间赋值历史和即可。&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int maxn = 1e6 + 5;
struct &amp;#123;
    int l, r;
    long long d1, d2, d3, u, s;
&amp;#125; t[maxn &amp;lt;&amp;lt; 2];
#define lt (p &amp;lt;&amp;lt; 1)
#define rt (lt | 1)
void pushup(int p) &amp;#123;
    t[p].u = t[lt].u + t[rt].u;
    t[p].s = t[lt].s + t[rt].s;
    return;
&amp;#125;
void pushval(int p, long long d1, long long d2, long long d3) &amp;#123;
    t[p].s += t[p].u * d2 + d3 * (t[p].r - t[p].l + 1);
    t[p].d3 += d3;
    if (t[p].d1)
        t[p].d3 += t[p].d1 * d2;
    else
        t[p].d2 += d2;
    if (d1) &amp;#123;
        t[p].u = d1 * (t[p].r - t[p].l + 1);
        t[p].d1 = d1;
    &amp;#125;
    return;
&amp;#125;
void pushdown(int p) &amp;#123;
    pushval(lt, t[p].d1, t[p].d2, t[p].d3);
    pushval(rt, t[p].d1, t[p].d2, t[p].d3);
    t[p].d1 = t[p].d2 = t[p].d3 = 0ll;
    return;
&amp;#125;
void bld(int p, int l, int r) &amp;#123;
    t[p].l = l, t[p].r = r;
    if (l == r)
        return;
    int mid = (t[p].l + t[p].r) &amp;gt;&amp;gt; 1;
    bld(lt, l, mid), bld(rt, mid + 1, r);
    return;
&amp;#125;
void upd(int p, int l, int r, long long v) &amp;#123;
    if (l &amp;lt;= t[p].l &amp;amp;&amp;amp; t[p].r &amp;lt;= r) &amp;#123;
        pushval(p, v, 0ll, 0ll);
        return;
    &amp;#125;
    pushdown(p);
    int mid = (t[p].l + t[p].r) &amp;gt;&amp;gt; 1;
    if (l &amp;lt;= mid)
        upd(lt, l, r, v);
    if (r &amp;gt; mid)
        upd(rt, l, r, v);
    pushup(p);
    return;
&amp;#125;
long long ask(int p, int l, int r) &amp;#123;
    if (l &amp;lt;= t[p].l &amp;amp;&amp;amp; t[p].r &amp;lt;= r)
        return t[p].s;
    pushdown(p);
    int mid = (t[p].l + t[p].r) &amp;gt;&amp;gt; 1;
    auto res = 0ll;
    if (l &amp;lt;= mid)
        res = ask(lt, l, r);
    if (r &amp;gt; mid)
        res += ask(rt, l, r);
    return res;
&amp;#125;
signed main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, q;
    std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; q;
    std::vector&amp;lt;int&amp;gt; a(n + 1), la(n + 1);
    for (int i = 1; i &amp;lt;= n; ++i)
        std::cin &amp;gt;&amp;gt; a[i];
    struct query &amp;#123; int l, r, id, k; &amp;#125;;
    std::vector&amp;lt;long long&amp;gt; res(q + 1);
    std::vector&amp;lt;std::vector&amp;lt;query&amp;gt; &amp;gt; u(n + 1);
    for (int i = 1, l, r, x, y; i &amp;lt;= q; ++i) &amp;#123;
        std::cin &amp;gt;&amp;gt; l &amp;gt;&amp;gt; r &amp;gt;&amp;gt; x &amp;gt;&amp;gt; y;
        if (x != 1)
            u[x - 1].push_back(&amp;#123; l, r, i, -1 &amp;#125;);
        u[y].push_back(&amp;#123; l, r, i, 1 &amp;#125;);
    &amp;#125;
    bld(1, 1, n);
    std::vector&amp;lt;int&amp;gt; pre(n + 2), nex(n + 2), l(n + 2);
    pre[n + 1] = 0, nex[0] = n + 1;
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        int p = la[a[i]];
        nex[pre[n + 1]] = i, pre[i] = pre[n + 1], pre[n + 1] = i, nex[i] = n + 1;
        l[i] = i;
        if (p != 0) &amp;#123;
            upd(1, l[p], p, nex[p]);
            l[nex[p]] = l[p];
            pre[nex[p]] = pre[p], nex[pre[p]] = nex[p];
        &amp;#125;
        upd(1, i, i, i);
        pushval(1, 0, 1, 0);
        for (auto [l, r, id, k] : u[i])
            res[id] += k * ask(1, l, r);
        la[a[i]] = i;
    &amp;#125;
    for (int i = 1; i &amp;lt;= q; ++i)
        std::cout &amp;lt;&amp;lt; res[i] &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;f---yunlis-subarray-queries-extreme-version&#34;&gt;F - Yunli’s Subarray Queries (extreme version)&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://codeforces.com/problemset/problem/2009/G3&#34; class=&#34;uri&#34;&gt;https://codeforces.com/problemset/problem/2009/G3&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;考虑对 &lt;span class=&#34;math inline&#34;&gt;\(\forall i\)&lt;/span&gt;，令 &lt;span class=&#34;math inline&#34;&gt;\(a_i\gets a_i-i\)&lt;/span&gt;，那么能够参与同一个连续子段的元素值应相同&lt;/li&gt;
&lt;li&gt;&lt;p&gt;显然对于任意一个长度为 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 的子段，其答案为 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 减去众数出现次数（&lt;span class=&#34;math inline&#34;&gt;\([l, r]\)&lt;/span&gt; 处答案记为 &lt;span class=&#34;math inline&#34;&gt;\(g_r\)&lt;/span&gt;）&lt;/p&gt;
这一点可以用类似莫队的方法来做&lt;/li&gt;
&lt;li&gt;&lt;p&gt;那么对于更长的子段 &lt;span class=&#34;math inline&#34;&gt;\([l, r]\)&lt;/span&gt;，其 &lt;span class=&#34;math inline&#34;&gt;\(f\)&lt;/span&gt; 就是 &lt;span class=&#34;math inline&#34;&gt;\(\min\limits_{l+k-1\le i\le r}\{g_i\}\)&lt;/span&gt;&lt;/p&gt;
原问题中的一次 &lt;span class=&#34;math inline&#34;&gt;\([l, r]\)&lt;/span&gt; 的询问就可以转化为 &lt;span class=&#34;math inline&#34;&gt;\(\sum\limits_{i=l+k-1}^r\sum\limits_{j=i}^r\min\{ g_{i\sim j}\}\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;这里有一个 trick：扫描线时可以用单调栈的想法来维护最小值操作，那么就把最值操作转化为一般的区间加历史和了。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int maxn = 1e6 + 5;
struct &amp;#123;
    int l, r;
    long long d1, d2, d3, u, s;
&amp;#125; t[maxn &amp;lt;&amp;lt; 2];
#define lt (p &amp;lt;&amp;lt; 1)
#define rt (lt | 1)
void pushup(int p) &amp;#123;
    t[p].u = t[lt].u + t[rt].u;
    t[p].s = t[lt].s + t[rt].s;
    return;
&amp;#125;
void pushval(int p, long long d1, long long d2, long long d3) &amp;#123;
    t[p].s += t[p].u * d2 + d3 * (t[p].r - t[p].l + 1);
    t[p].d3 += d3 + t[p].d1 * d2;
    t[p].d2 += d2;
    t[p].u += d1 * (t[p].r - t[p].l + 1);
    t[p].d1 += d1;
    return;
&amp;#125;
void pushdown(int p) &amp;#123;
    pushval(lt, t[p].d1, t[p].d2, t[p].d3);
    pushval(rt, t[p].d1, t[p].d2, t[p].d3);
    t[p].d1 = t[p].d2 = t[p].d3 = 0ll;
    return;
&amp;#125;
void bld(int p, int l, int r) &amp;#123;
    t[p].l = l, t[p].r = r;
    t[p].u = t[p].s = 0ll;
    t[p].d1 = t[p].d2 = t[p].d3 = 0;
    if (l == r)
        return;
    int mid = (t[p].l + t[p].r) &amp;gt;&amp;gt; 1;
    bld(lt, l, mid), bld(rt, mid + 1, r);
    return;
&amp;#125;
void add(int p, int l, int r, long long v) &amp;#123;
    if (l &amp;lt;= t[p].l &amp;amp;&amp;amp; t[p].r &amp;lt;= r) &amp;#123;
        pushval(p, v, 0ll, 0ll);
        return;
    &amp;#125;
    pushdown(p);
    int mid = (t[p].l + t[p].r) &amp;gt;&amp;gt; 1;
    if (l &amp;lt;= mid)
        add(lt, l, r, v);
    if (r &amp;gt; mid)
        add(rt, l, r, v);
    pushup(p);
    return;
&amp;#125;
long long ask(int p, int l, int r) &amp;#123;
    if (l &amp;lt;= t[p].l &amp;amp;&amp;amp; t[p].r &amp;lt;= r)
        return t[p].s;
    pushdown(p);
    int mid = (t[p].l + t[p].r) &amp;gt;&amp;gt; 1;
    auto res = 0ll;
    if (l &amp;lt;= mid)
        res = ask(lt, l, r);
    if (r &amp;gt; mid)
        res += ask(rt, l, r);
    return res;
&amp;#125;
signed main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int T;
    for (std::cin &amp;gt;&amp;gt; T; T--; ) &amp;#123;
        int n, k, q;
        std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; k &amp;gt;&amp;gt; q;
        std::vector&amp;lt;int&amp;gt; a(n + 1);
        for (int i = 1; i &amp;lt;= n; ++i)
            std::cin &amp;gt;&amp;gt; a[i], a[i] -= i;
        bld(1, 1, n);
        std::vector&amp;lt;int&amp;gt; g(n + 1);
        std::unordered_map&amp;lt;int, int&amp;gt; cnt;
        std::multiset&amp;lt;int&amp;gt; t;
        for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
            if (i &amp;gt; k) &amp;#123;
                t.erase(t.find(cnt[a[i - k]]));
                if (--cnt[a[i - k]])
                    t.insert(cnt[a[i - k]]);
            &amp;#125;
            if (cnt[a[i]])
                t.erase(t.find(cnt[a[i]]));
            t.insert(++cnt[a[i]]);
            if (i &amp;gt;= k)
                g[i] = k - *--t.end();
        &amp;#125;
        std::vector&amp;lt;long long&amp;gt; res(q + 1);
        std::vector&amp;lt;std::vector&amp;lt;std::pair&amp;lt;int, int&amp;gt; &amp;gt; &amp;gt; u(n + 1);
        for (int i = 1, l, r; i &amp;lt;= q; ++i) &amp;#123;
            std::cin &amp;gt;&amp;gt; l &amp;gt;&amp;gt; r;
            u[r].emplace_back(l + k - 1, i);
        &amp;#125;
        std::stack&amp;lt;std::pair&amp;lt;int, int&amp;gt; &amp;gt; st;
        for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
            std::pair&amp;lt;int, int&amp;gt; now(g[i], i);
            add(1, i, i, g[i]);
            for (; !st.empty() &amp;amp;&amp;amp; st.top() &amp;gt; now; st.pop()) &amp;#123;
                auto [v, p] = st.top();
                add(1, p, now.second - 1, g[i] - v);
                now.second = p;
            &amp;#125;
            st.push(now);
            pushval(1, 0ll, 1ll, 0ll);
            for (auto [l, id] : u[i])
                res[id] = ask(1, l, i);
        &amp;#125;
        for (int i = 1; i &amp;lt;= q; ++i)
            std::cout &amp;lt;&amp;lt; res[i] &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    &amp;#125;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://xsc062.netlify.app/20250909/</guid>
            <title>吉司机线段树</title>
            <link>https://xsc062.netlify.app/20250909/</link>
            <category>线段树</category>
            <pubDate>Tue, 09 Sep 2025 22:24:31 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;势能，但仅限于势能吗？&lt;/p&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;
&lt;hr /&gt;
&lt;p&gt;需要知道线段树并非万能，很多看起来兼容的操作其实是不兼容的。举例：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;区间取 min, max、区间查询 min, max&lt;/p&gt;
&lt;p&gt;发现在涉及最值操作的时候，把区间元素值看作分段函数和取最值的性质是比较贴的。&lt;/p&gt;
那么相当于把所有大于 / 小于 &lt;span class=&#34;math inline&#34;&gt;\(v\)&lt;/span&gt; 的部分推平。查询是好做的。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;区间加、区间查询 min, max&lt;/p&gt;
相当于竖直方向平移。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;区间加等差数列、区间查询 min, max&lt;/p&gt;
发现是和另一个固定的一次函数做线性加；发现是不可做的。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;区间取 min、区间求和&lt;/p&gt;
&lt;p&gt;也即把所有大于 / 小于 &lt;span class=&#34;math inline&#34;&gt;\(v\)&lt;/span&gt; 的部分推平，还要求点值之和。&lt;/p&gt;
&lt;p&gt;看起来不可做，因为求和没办法用这样的语言体系简单阐释，只能考虑脱离这个语言体系，真的去找到这样的凸起。这样看起来是特别慢的。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;但实际上最后一条是可做的，吉如一发明了一种特定的方法，并证明了在仅有区间取 min / max + 区间求和操作时，复杂度是 &lt;span class=&#34;math inline&#34;&gt;\(O(q\log n)\)&lt;/span&gt; 的；如果再增加其他任何区间操作，复杂度是 &lt;span class=&#34;math inline&#34;&gt;\(O(q\log^2 n)\)&lt;/span&gt; 的。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;区间取-min-区间求和&#34;&gt;区间取 min / 区间求和&lt;/h2&gt;
&lt;p&gt;例：&lt;a href=&#34;https://acm.hdu.edu.cn/showproblem.php?pid=5306&#34;&gt;Gorgeous Sequence&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;记录最大值 &lt;span class=&#34;math inline&#34;&gt;\(mx\)&lt;/span&gt;、次大值 &lt;span class=&#34;math inline&#34;&gt;\(se\)&lt;/span&gt;、最大值出现次数 &lt;span class=&#34;math inline&#34;&gt;\(cnt\)&lt;/span&gt;。当 &lt;span class=&#34;math inline&#34;&gt;\(v\in(se,mx)\)&lt;/span&gt; 时，发现只有 &lt;span class=&#34;math inline&#34;&gt;\(mx\)&lt;/span&gt; 需要被更新。此时 &lt;span class=&#34;math inline&#34;&gt;\(s\gets s-(mx-v)\cdot cnt\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;否则，&lt;span class=&#34;math inline&#34;&gt;\(se\)&lt;/span&gt; 也需要被更新，暴力递归直到满足上一条后停止。复杂度 &lt;span class=&#34;math inline&#34;&gt;\(O(q\log n)\)&lt;/span&gt;。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int maxn = 1e6 + 5;
const int inf = 0x3f3f3f3f;
struct &amp;#123;
    long long s;
    int l, r, mx, se, d, cnt;
&amp;#125; t[maxn &amp;lt;&amp;lt; 2];
#define lt (p &amp;lt;&amp;lt; 1)
#define rt (lt | 1)
int a[maxn];
void pushup(int p) &amp;#123;
    if (t[lt].mx == t[rt].mx) &amp;#123;
        t[p].mx = t[lt].mx, t[p].cnt = t[lt].cnt + t[rt].cnt;
        t[p].se = std::max(t[lt].se, t[rt].se);
    &amp;#125;
    else if (t[lt].mx &amp;gt; t[rt].mx) &amp;#123;
        t[p].mx = t[lt].mx, t[p].cnt = t[lt].cnt;
        t[p].se = std::max(t[lt].se, t[rt].mx);
    &amp;#125;
    else &amp;#123;
        t[p].mx = t[rt].mx, t[p].cnt = t[rt].cnt;
        t[p].se = std::max(t[lt].mx, t[rt].se);
    &amp;#125;
    t[p].s = t[lt].s + t[rt].s;
    return;
&amp;#125;
void bld(int p, int l, int r) &amp;#123;
    t[p].d = inf;
    t[p].l = l, t[p].r = r;
    if (l == r) &amp;#123;
        t[p].s = t[p].mx = a[l], t[p].cnt = 1, t[p].se = 0;
        return;
    &amp;#125;
    int mid = (l + r) &amp;gt;&amp;gt; 1;
    bld(lt, l, mid), bld(rt, mid + 1, r);
    pushup(p);
    return;
&amp;#125;
void pushval(int p, int v) &amp;#123;
    if (v &amp;lt;= t[p].mx) &amp;#123;
        t[p].s -= (long long)(t[p].mx - v) * t[p].cnt;
        t[p].mx = t[p].d = v;
    &amp;#125;
    return;
&amp;#125;
void pushdown(int p) &amp;#123;
    if (t[p].d != inf) &amp;#123;
        pushval(lt, t[p].d), pushval(rt, t[p].d);
        t[p].d = inf;
    &amp;#125;
    return;
&amp;#125;
void add(int p, int l, int r, int v) &amp;#123;
    if (t[p].mx &amp;lt;= v)
        return;
    if (l &amp;lt;= t[p].l &amp;amp;&amp;amp; t[p].r &amp;lt;= r &amp;amp;&amp;amp; v &amp;gt; t[p].se) &amp;#123;
        pushval(p, v);
        return;
    &amp;#125;
    pushdown(p);
    int mid = (t[p].l + t[p].r) &amp;gt;&amp;gt; 1;
    if (l &amp;lt;= mid)
        add(lt, l, r, v);
    if (r &amp;gt; mid)
        add(rt, l, r, v);
    pushup(p);
    return;
&amp;#125;
int askmx(int p, int l, int r) &amp;#123;
    if (l &amp;lt;= t[p].l &amp;amp;&amp;amp; t[p].r &amp;lt;= r)
        return t[p].mx;
    pushdown(p);
    int mid = (t[p].l + t[p].r) &amp;gt;&amp;gt; 1, res = 0;
    if (l &amp;lt;= mid)
        res = askmx(lt, l, r);
    if (r &amp;gt; mid)
        res = std::max(res, askmx(rt, l, r));
    return res;
&amp;#125;
long long asks(int p, int l, int r) &amp;#123;
    if (l &amp;lt;= t[p].l &amp;amp;&amp;amp; t[p].r &amp;lt;= r)
        return t[p].s;
    pushdown(p);
    int mid = (t[p].l + t[p].r) &amp;gt;&amp;gt; 1;
    auto res = 0ll;
    if (l &amp;lt;= mid)
        res = asks(lt, l, r);
    if (r &amp;gt; mid)
        res += asks(rt, l, r);
    return res;
&amp;#125;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int T;
    for (std::cin &amp;gt;&amp;gt; T; T--; ) &amp;#123;
        int n, m;
        std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
        for (int i = 1; i &amp;lt;= n; ++i)
            std::cin &amp;gt;&amp;gt; a[i];
        bld(1, 1, n);
        for (int op, l, r; m--; ) &amp;#123;
            std::cin &amp;gt;&amp;gt; op &amp;gt;&amp;gt; l &amp;gt;&amp;gt; r;
            if (op == 0) &amp;#123;
                int v;
                std::cin &amp;gt;&amp;gt; v;
                add(1, l, r, v);
            &amp;#125;
            else if (op == 1)
                std::cout &amp;lt;&amp;lt; askmx(1, l, r) &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
            else
                std::cout &amp;lt;&amp;lt; asks(1, l, r) &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
        &amp;#125;
    &amp;#125;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;区间取-min区间操作区间求和&#34;&gt;区间取 min、区间操作、区间求和&lt;/h2&gt;
&lt;p&gt;例：&lt;a href=&#34;https://loj.ac/p/6565&#34;&gt;最假女选手&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可以用相似的方法来维护；&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://xsc062.netlify.app/20250907/</guid>
            <title>近期杂题</title>
            <link>https://xsc062.netlify.app/20250907/</link>
            <pubDate>Sun, 07 Sep 2025 16:13:09 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;突围&lt;/p&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;e---colinear&#34;&gt;E - Colinear&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/abc422/tasks/abc422_e&#34; class=&#34;uri&#34;&gt;https://atcoder.jp/contests/abc422/tasks/abc422_e&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;看到题目会有一个乱搞的想法：随机取一对点，那么是有 &lt;span class=&#34;math inline&#34;&gt;\(\dfrac 14\)&lt;/span&gt; 的概率都在直线上的。带进去暴力 check 一下，多来几次正确率就比较高。&lt;/p&gt;
&lt;p&gt;什么，这是正解？abc 的风格真是越来越奇怪了。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;f---eat-and-ride&#34;&gt;F - Eat and Ride&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/abc422/tasks/abc422_f&#34; class=&#34;uri&#34;&gt;https://atcoder.jp/contests/abc422/tasks/abc422_f&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;考虑一个费用提前计算的分层图，就可以跑 Dij 了。&lt;/p&gt;
&lt;p&gt;官解给出了一个优化：&lt;strong&gt;搜索实际上是在给边定向；这样图就转化为 DAG&lt;/strong&gt;（实际上反向边并不会产生有效更新，故直接朴素转移即可）。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;b---triangle-toggle&#34;&gt;B - Triangle Toggle&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/arc205/tasks/arc205_b&#34; class=&#34;uri&#34;&gt;https://atcoder.jp/contests/arc205/tasks/arc205_b&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;现场是打表找规律做出来的 😅&lt;/p&gt;
&lt;p&gt;发现这样一次操作之后每个点上黑边的奇偶性是不会变的，所以会有一个上界，难点在于是否可以达到这个上界。&lt;/p&gt;
&lt;p&gt;发现只要存在一个点上连有两条白边，就可以把 001 反转为 110，一次操作至少可以新增一条黑边。故是可以达到的。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;d---non-ancestor-matching&#34;&gt;D - Non-Ancestor Matching&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/arc205/tasks/arc205_d&#34; class=&#34;uri&#34;&gt;https://atcoder.jp/contests/arc205/tasks/arc205_d&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;没啥好说的摩尔投票，有一个非常简单的优先队列做法&lt;/p&gt;
&lt;p&gt;但 Rosmist 打了另一个看起来有点玄学的东西：可以感受到每次只向最大的子树递归是合理的，尝试证明一下发现确实比较显然&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;e---subset-product-problem&#34;&gt;E - Subset Product Problem&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/AT_arc205_e&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/AT_arc205_e&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;奇怪题目&lt;/p&gt;
&lt;p&gt;高维前缀和 + 分块其实不算特别罕见的 trick&lt;/p&gt;
&lt;p&gt;用 &lt;span class=&#34;math inline&#34;&gt;\(f_{i,j}\)&lt;/span&gt; 表示前 &lt;span class=&#34;math inline&#34;&gt;\(10\)&lt;/span&gt; 位为 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt;，后 &lt;span class=&#34;math inline&#34;&gt;\(10\)&lt;/span&gt; 位的高维前缀和&lt;/p&gt;
&lt;p&gt;每次查询 / 更新都是 &lt;span class=&#34;math inline&#34;&gt;\(O(2^{10})\)&lt;/span&gt; 的，可以接受（吗）&lt;/p&gt;
&lt;p&gt;然后还有一个科研性的做法 见 &lt;a href=&#34;https://www.luogu.com.cn/article/1uyz0hn2&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/article/1uyz0hn2&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;c.-by-the-assignment&#34;&gt;C. By the Assignment&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://codeforces.com/contest/2135/problem/C&#34; class=&#34;uri&#34;&gt;https://codeforces.com/contest/2135/problem/C&lt;/a&gt;&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://xsc062.netlify.app/20250906/</guid>
            <title>学习笔记：压位高精</title>
            <link>https://xsc062.netlify.app/20250906/</link>
            <category>高精度</category>
            <pubDate>Sat, 06 Sep 2025 15:02:56 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;把 ddxrS 吓到了，发出惊世疑问：『为什么高二机房正在激烈地讨论怎么写高精度？』&lt;/p&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;
&lt;hr /&gt;
&lt;p&gt;考虑 10-base 高精度，单次运算复杂度为 &lt;span class=&#34;math inline&#34;&gt;\(O(\log_{10}V)\)&lt;/span&gt;。使用 10-base 的主要原因是 &lt;code&gt;std::to_string&lt;/code&gt; 很方便、输出也很简单。&lt;/p&gt;
&lt;p&gt;但效率太低。实际上，一般打高精度都是 1e4-base，或更激进地，1e9-base。&lt;/p&gt;
&lt;p&gt;注意高精乘低精是 &lt;span class=&#34;math inline&#34;&gt;\(O(len)\)&lt;/span&gt; 而非 &lt;span class=&#34;math inline&#34;&gt;\(O(len^2)\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;需要考虑输出。由于用的是 10-power 作为 base，所以只需要把每四位直接输出即可。注意除首位外需要补前导 0 直到四位。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;struct BI &amp;#123;
    std::vector&amp;lt;int&amp;gt; s;
    BI() &amp;#123;&amp;#125;
    BI(int x) &amp;#123;
        for (; x; s.push_back(x % 10000), x /= 10000);
        return;
    &amp;#125;
    BI&amp;amp; operator= (int q) &amp;#123;
        return *this = (BI)q;
    &amp;#125;
    bool operator&amp;gt; (const BI &amp;amp;q) &amp;#123;
        if (s.size() != q.s.size())
            return s.size() &amp;gt; q.s.size();
        for (int i = (int)s.size() - 1; ~i; --i)
            if (s[i] != q.s[i])
                return s[i] &amp;gt; q.s[i];
        return 0;
    &amp;#125;
    BI operator* (int q) const &amp;#123;
        int lx = s.size();
        std::vector&amp;lt;long long&amp;gt; res(lx + 3);
        for (int i = 0; i &amp;lt; lx; ++i)
            res[i] = (long long)s[i] * q;
        BI p;
        for (int j = 0; j &amp;lt; lx + 2; ++j)
            res[j + 1] += res[j] / 10000, res[j] %= 10000;
        int len = lx + 2;
        for (; ~len &amp;amp;&amp;amp; !res[len]; --len);
        for (int j = 0; j &amp;lt;= len; ++j)
            p.s.push_back(res[j]);
        return p;
    &amp;#125;
    void out(void) &amp;#123;
        for (int i = (int)s.size() - 1; ~i; --i) &amp;#123;
            auto p = std::to_string(s[i]);
            if (i != (int)s.size() - 1)
                for (; (int)p.size() &amp;lt; 4; p = &amp;quot;0&amp;quot; + p);
            std::cout &amp;lt;&amp;lt; p;
        &amp;#125;
        std::cout &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
        return;
    &amp;#125;
&amp;#125;;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://xsc062.netlify.app/20250824/</guid>
            <title>杂题</title>
            <link>https://xsc062.netlify.app/20250824/</link>
            <category>倍增</category>
            <category>树形 DP</category>
            <category>Kruskal 重构树</category>
            <pubDate>Sun, 24 Aug 2025 15:37:55 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;不会的东西越来越多了&lt;/p&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;b.-k-set-tree&#34;&gt;B. K-Set Tree&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/CF1691F&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/CF1691F&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;令 &lt;span class=&#34;math inline&#34;&gt;\(F_i\)&lt;/span&gt; 表示以 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt; 为根时，&lt;span class=&#34;math inline&#34;&gt;\(S\)&lt;/span&gt; 在 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 子树内的答案。则：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
F_u=\left(C_{siz_u}^k-\sum C_{siz_v}^k\right)\cdot siz_u+\sum F_v\\
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;直接换根是很复杂的；把 &lt;span class=&#34;math inline&#34;&gt;\(\sum C_{siz_v}^k\)&lt;/span&gt; 记作 &lt;span class=&#34;math inline&#34;&gt;\(dp_u\)&lt;/span&gt;，把 &lt;span class=&#34;math inline&#34;&gt;\(\sum F_v\)&lt;/span&gt; 记作 &lt;span class=&#34;math inline&#34;&gt;\(f_u\)&lt;/span&gt;，那么：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
res=\sum(C_n^k-dp_u)\cdot n+f_u\\
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这样做是为了把两个和 &lt;span class=&#34;math inline&#34;&gt;\(v\)&lt;/span&gt; 有关的乘项拆开来换根&lt;/strong&gt;，实际换根的时候就只用分别换 &lt;span class=&#34;math inline&#34;&gt;\(f,dp\)&lt;/span&gt; 两个值，不用考虑二次项等问题，计算量会少很多&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int mod = 1e9 + 7;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, k;
    std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; k;
    std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; g(n + 1);
    for (int i = 1, x, y; i &amp;lt; n; ++i) &amp;#123;
        std::cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; y;
        g[x].push_back(y), g[y].push_back(x);
    &amp;#125;
    std::vector&amp;lt;long long&amp;gt; fac(n + 1), inv(n + 1);
    fac[0] = inv[0] = 1ll;
    for (int i = 1; i &amp;lt;= n; ++i)
        fac[i] = fac[i - 1] * i % mod;
    auto qkp = [](long long x, int y) &amp;#123;
        auto res(1ll);
        for (; y; (x *= x) %= mod, y &amp;gt;&amp;gt;= 1)
            if (y &amp;amp; 1)
                (res *= x) %= mod;
        return res;
    &amp;#125;;
    inv[n] = qkp(fac[n], mod - 2);
    for (int i = n - 1; i; --i)
        inv[i] = inv[i + 1] * (i + 1) % mod;
    auto C = [&amp;amp;](int n, int m) &amp;#123;
        if (m &amp;gt; n)
            return 0ll;
        return fac[n] * inv[m] % mod * inv[n - m] % mod;
    &amp;#125;;
    auto res(0ll);
    std::vector&amp;lt;int&amp;gt; siz(n + 1), ss(n + 1);
    std::vector&amp;lt;long long&amp;gt; f(n + 1), dp(n + 1);
    std::function&amp;lt;void(int, int)&amp;gt; DFS = [&amp;amp;](int x, int fa) &amp;#123;
        siz[x] = 1;
        for (auto i : g[x])
            if (i != fa) &amp;#123;
                DFS(i, x);
                (f[x] += (C(siz[i], k) - dp[i]) * siz[i] + f[i]) %= mod;
                (dp[x] += C(siz[i], k)) %= mod;
                siz[x] += siz[i];
            &amp;#125;
        return;
    &amp;#125;;
    DFS(1, -1);
    DFS = [&amp;amp;](int x, int fa) &amp;#123;
        (res += (C(n, k) - dp[x]) * n + f[x]) %= mod;
        for (auto i : g[x])
            if (i != fa) &amp;#123;
                (f[i] += (C(n - siz[i], k) - (dp[x] - C(siz[i], k))) * (n - siz[i]) + f[x] - f[i] - (C(siz[i], k) - dp[i]) * siz[i]) %= mod;
                (dp[i] += C(n - siz[i], k)) %= mod;
                DFS(i, x);
            &amp;#125;
        return;
    &amp;#125;;
    DFS(1, -1);
    std::cout &amp;lt;&amp;lt; (res + mod) % mod &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;c.-li-hua-and-path&#34;&gt;C. Li Hua and Path&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/CF1797F&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/CF1797F&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;考虑&lt;strong&gt;容斥&lt;/strong&gt;，分别求解满足 1、满足 2、满足 12（注意要减两倍）就能计算答案&lt;/p&gt;
&lt;p&gt;发现题目所求点对形式很符合 Kruskal 重构树的要求，考虑以对应点权为边权，分别建立 min，max Kruskal 点权多叉重构树。&lt;/p&gt;
&lt;details&gt;
&lt;p&gt;&lt;summary&gt;点权多叉重构树？&lt;/summary&gt;&lt;/p&gt;
&lt;p&gt;在点权上做 Kruskal 重构树时，发现边的虚点是不必要的，可以直接将更优点作为父亲。&lt;/p&gt;
&lt;p&gt;写的时候有点难想清楚…… 可以画画图，仔细确定一下 Kruskal 重构树的具体性质&lt;/p&gt;
&lt;p&gt;这样做的优势是没有虚点，一些问题会方便一些；但同时放弃了二叉树的结构，一些题可能没那么好做。&lt;/p&gt;
&lt;p&gt;这道题只用经典 Kruskal 重构树也可以解决。&lt;/p&gt;
&lt;/details&gt;
&lt;p&gt;发现 1 2 均可以转化成两棵树在两棵树上的祖孙关系要求，可以轻松地分别统计满足 1、满足 2 的点对数量&lt;/p&gt;
&lt;p&gt;考虑怎么处理同时满足 12 的，发现要求在两棵树上二者应该都具有祖孙关系，且是相反的。&lt;del&gt;可以考虑在一棵树上 DFS 的同时用主席树存储祖先，在另一颗树上 ask&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;考虑从更容易用 dfn 表示的子树问题思考，在 min 树上分配 dfn 后，在 max 树上用 DFS + 回溯得到每个点实时祖先序列，存在树状数组里；ask 该点被分配的 dfn 子树区间就能得到答案。&lt;/p&gt;
&lt;p&gt;考虑询问，由于每次加入的都是编号最大的点，对于满足 1、满足 2 的贡献是显然的，而同时满足 12 的点就是在 min 树上的祖先，都是好做的。&lt;/p&gt;
&lt;p&gt;实现的时候一定要把 min / max 树对应的性质思考清楚，不然会很麻烦&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n;
    std::cin &amp;gt;&amp;gt; n;
    std::vector&amp;lt;int&amp;gt; f1(n + 1), f2(n + 1);
    std::iota(f1.begin() + 1, f1.end(), 1);
    std::iota(f2.begin() + 1, f2.end(), 1);
    std::function&amp;lt;int(int)&amp;gt; find1 = [&amp;amp;](int x) &amp;#123;
        return x == f1[x] ? x : f1[x] = find1(f1[x]);
    &amp;#125;;
    std::function&amp;lt;int(int)&amp;gt; find2 = [&amp;amp;](int x) &amp;#123;
        return x == f2[x] ? x : f2[x] = find2(f2[x]);
    &amp;#125;;
    std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; g1(n + 1), g2(n + 1), adj1(n + 1), adj2(n + 1);
    for (int i = 1, x, y; i &amp;lt; n; ++i) &amp;#123;
        std::cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; y;
        if (x &amp;gt; y)
            std::swap(x, y);
        adj1[y].push_back(x);
        adj2[x].push_back(y);
    &amp;#125;
    for (int i = 1; i &amp;lt;= n; ++i)
        for (auto j : adj1[i]) &amp;#123;
            int fi = find1(i), fj = find1(j);
            g1[fi].push_back(fj), f1[fj] = fi;
        &amp;#125;
    for (int i = n; i; --i)
        for (auto j : adj2[i]) &amp;#123;
            int fi = find2(i), fj = find2(j);
            g2[fi].push_back(fj), f2[fj] = fi;
        &amp;#125;
    std::vector&amp;lt;int&amp;gt; bit(n + 1), dfn(n + 1), rfn(n + 1);
    auto lowbit = [](int x) &amp;#123;
        return x &amp;amp; -x;
    &amp;#125;;
    auto add = [&amp;amp;](int x, int v) &amp;#123;
        for (; x &amp;lt;= n; x += lowbit(x))
            bit[x] += v;
        return;
    &amp;#125;;
    auto ask = [&amp;amp;](int x) &amp;#123;
        int res = 0;
        for (; x; x -= lowbit(x))
            res += bit[x];
        return res;
    &amp;#125;;
    int rt1 = 0, rt2 = 0;
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        if (f1[i] == i)
            rt1 = i;
        if (f2[i] == i)
            rt2 = i;
    &amp;#125;
    int q;
    std::cin &amp;gt;&amp;gt; q;
    std::vector&amp;lt;int&amp;gt; dep1(n + 1), dep2(n + q + 1);
    long long res = 0ll;
    std::function&amp;lt;void(int)&amp;gt; DFS = [&amp;amp;](int x) &amp;#123;
        static int now = 0;
        dfn[x] = ++now;
        res += dep1[x];
        for (auto i : g1[x]) &amp;#123;
            dep1[i] = dep1[x] + 1;
            DFS(i);
        &amp;#125;
        rfn[x] = now;
        return;
    &amp;#125;;
    DFS(rt1);
    DFS = [&amp;amp;](int x) &amp;#123;
        res += dep2[x];
        res -= 2 * (ask(rfn[x]) - ask(dfn[x] - 1));
        add(dfn[x], 1);
        for (auto i : g2[x]) &amp;#123;
            dep2[i] = dep2[x] + 1;
            DFS(i);
        &amp;#125;
        add(dfn[x], -1);
        return;
    &amp;#125;;
    DFS(rt2);
    std::cout &amp;lt;&amp;lt; res &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    for (int fa; q--; ) &amp;#123;
        std::cin &amp;gt;&amp;gt; fa;
        dep2[++n] = dep2[fa] + 1;
        res += (n - 1) - dep2[n];
        std::cout &amp;lt;&amp;lt; res &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    &amp;#125;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;d.-团队选拔&#34;&gt;D. 团队选拔&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://222.180.160.110:61235/contest/6534/problem/4&#34; class=&#34;uri&#34;&gt;http://222.180.160.110:61235/contest/6534/problem/4&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定 &lt;span class=&#34;math inline&#34;&gt;\(a_{1\sim n}\)&lt;/span&gt;，从中任选一些互不相交的区间，满足每个区间内元素的 gcd 相同。&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(n\le 10^5,V\le 10^7\)&lt;/span&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;注意到固定一个左端点后，移动右端点，gcd 每次至多减小到原来的一半；也就是说，其种类有 &lt;span class=&#34;math inline&#34;&gt;\(\log V\)&lt;/span&gt; 种。故全序列的 gcd 总数是 &lt;span class=&#34;math inline&#34;&gt;\(O(n\log V)\)&lt;/span&gt; 的。&lt;/p&gt;
&lt;p&gt;很容易想到与此原理类似的全局答案求法：对于每个 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt;，向左处理出每一段 &lt;span class=&#34;math inline&#34;&gt;\([l,r]\)&lt;/span&gt;，满足 &lt;span class=&#34;math inline&#34;&gt;\(\gcd(a_{l\cdots i})=\gcd(a_r\cdots i)\)&lt;/span&gt;，并记录该 &lt;span class=&#34;math inline&#34;&gt;\(\gcd\)&lt;/span&gt;。这样求出来的 &lt;span class=&#34;math inline&#34;&gt;\((i,l,r)\)&lt;/span&gt; 共有 &lt;span class=&#34;math inline&#34;&gt;\(O(n\log V)\)&lt;/span&gt; 段。&lt;/p&gt;
&lt;p&gt;对于每个 gcd 有 &lt;span class=&#34;math inline&#34;&gt;\(f_{i}=f_{i-1}+\sum\limits_{j=l_i}^{r_i} f_{j - 1}\)&lt;/span&gt;，可以做一个扫描线，得到全局答案；向前向后分别做到 &lt;span class=&#34;math inline&#34;&gt;\(i-1,i+1\)&lt;/span&gt;，相乘就能得到 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 未被选取时的答案&lt;/p&gt;
&lt;p&gt;考虑怎么完成『相乘』这个动作：最后的 &lt;span class=&#34;math inline&#34;&gt;\(f\)&lt;/span&gt; 在每个右端点处发生变化，可以转化成若干段 &lt;span class=&#34;math inline&#34;&gt;\(f\)&lt;/span&gt;；反过来的 &lt;span class=&#34;math inline&#34;&gt;\(f&amp;#39;\)&lt;/span&gt; 亦可以这样转化。将 &lt;span class=&#34;math inline&#34;&gt;\(f\)&lt;/span&gt; 整体后移一位、&lt;span class=&#34;math inline&#34;&gt;\(f&amp;#39;\)&lt;/span&gt; 整体前移一位，就可以对齐。二者的端点总数是均摊单 log 的，区间总数也就是均摊单 log 的（归并就能快速寻找到区间），用差分做一个区间加即可。&lt;/p&gt;
&lt;p&gt;用二分勉强单 log 解决了转移；还看到 &lt;span class=&#34;citation&#34; data-cites=&#34;spdarkle&#34;&gt;@spdarkle&lt;/span&gt; 疑似在 &lt;span class=&#34;math inline&#34;&gt;\(1\sim n\)&lt;/span&gt; 上直接做的&lt;a href=&#34;http://222.180.160.110:61235/submission/3108272&#34;&gt;做法&lt;/a&gt;，和 &lt;span class=&#34;citation&#34; data-cites=&#34;Rosmist&#34;&gt;@Rosmist&lt;/span&gt; 疑似直接在每个 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 上做的&lt;a href=&#34;http://222.180.160.110:61235/submission/3108581&#34;&gt;做法&lt;/a&gt;。官解是个看不懂的做法&lt;/p&gt;
&lt;p&gt;呃，好像一不小心拿了最优解。而且优势很明显（怎么总用时比别人一个点还少？），这是为什么？&lt;/p&gt;
&lt;p&gt;可能因为大家都看不懂官解，做法比较多样？除了我之外比较快的 lwz 和 &lt;span class=&#34;citation&#34; data-cites=&#34;GoldSpade&#34;&gt;@GoldSpade&lt;/span&gt; 都用归并完成最后一步；我较他们的额外优势大概是用二分换掉了树状数组？迷惑&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int mod = 998244353;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
    std::freopen(&amp;quot;selection.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;selection.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#else
    std::freopen(&amp;quot;ex_selection2.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n;
    std::cin &amp;gt;&amp;gt; n;
    std::vector&amp;lt;int&amp;gt; a(n + 1);
    std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; st(20, std::vector&amp;lt;int&amp;gt; (n + 1));
    for (int i = 1; i &amp;lt;= n; ++i)
        std::cin &amp;gt;&amp;gt; a[i], st[0][i] = a[i];
    for (int j = 1; (1 &amp;lt;&amp;lt; j) &amp;lt;= n; ++j)
        for (int i = 1; i + (1 &amp;lt;&amp;lt; j) - 1 &amp;lt;= n; ++i)
            st[j][i] = std::__gcd(st[j - 1][i], st[j - 1][i + (1 &amp;lt;&amp;lt; (j - 1))]);
    auto askgcd = [&amp;amp;](int l, int r) &amp;#123;
        int k = std::__lg(r - l + 1);
        return std::__gcd(st[k][l], st[k][r - (1 &amp;lt;&amp;lt; k) + 1]);
    &amp;#125;;
    std::unordered_map&amp;lt;int, int&amp;gt; tab;
    struct node &amp;#123;
        int i, l, r;
        bool operator&amp;lt; (const int q) const &amp;#123;
            return i &amp;lt; q;
        &amp;#125;
        bool operator&amp;lt;= (const int q) const &amp;#123;
            return i &amp;lt;= q;
        &amp;#125;
    &amp;#125;;
    std::vector&amp;lt;std::vector&amp;lt;node&amp;gt; &amp;gt; p1, p2;
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        for (int to = i; to &amp;gt;= 1; ) &amp;#123;
            int at = i, g = askgcd(to, i);
            for (int l = 1, r = to, mid; l &amp;lt;= r; ) &amp;#123;
                mid = (l + r) &amp;gt;&amp;gt; 1;
                if (askgcd(mid, i) == g)
                    at = mid, r = mid - 1;
                else
                    l = mid + 1;
            &amp;#125;
            if (!tab.count(g)) &amp;#123;
                tab[g] = (int)p1.size();
                p1.emplace_back(), p2.emplace_back();
            &amp;#125;
            p1[tab[g]].push_back(&amp;#123; i, at, to &amp;#125;);
            to = at - 1;
        &amp;#125;
        for (int to = i; to &amp;lt;= n; ) &amp;#123;
            int at = i, g = askgcd(i, to);
            for (int l = to, r = n, mid; l &amp;lt;= r; ) &amp;#123;
                mid = (l + r) &amp;gt;&amp;gt; 1;
                if (askgcd(i, mid) == g)
                    at = mid, l = mid + 1;
                else
                    r = mid - 1;
            &amp;#125;
            if (!tab.count(g)) &amp;#123;
                tab[g] = (int)p2.size();
                p1.emplace_back(), p2.emplace_back();
            &amp;#125;
            p2[tab[g]].push_back(&amp;#123; i, to, at &amp;#125;);
            to = at + 1;
        &amp;#125;
    &amp;#125;
    auto s(0ll);
    std::vector&amp;lt;int&amp;gt; x1(n + 1), x2(n + 2), pos(2 * n + 3);
    std::vector&amp;lt;long long&amp;gt; f1(n + 1), f2(n + 2), s1(n + 1), s2(n + 2), diff(n + 1);
    for (auto [g, id] : tab) &amp;#123;
        // printf(&amp;quot;g = %d: \n&amp;quot;, g);
        int n1 = (int)p1[id].size();
        x1[0] = 0, f1[0] = s1[0] = 1ll;
        for (int i = 1; i &amp;lt;= n1; ++i) &amp;#123;
            auto [x, L, R] = p1[id][i - 1];
            --L, --R;
            x1[i] = x, f1[i] = f1[i - 1];
            int l = std::upper_bound(x1.begin() + 1, x1.begin() + i + 1, L) - x1.begin() - 1,
                r = std::upper_bound(x1.begin() + 1, x1.begin() + i + 1, R) - x1.begin() - 1;
            if (l == r)
                (f1[i] += f1[l] * (R - L + 1)) %= mod;
            else &amp;#123;
                f1[i] += s1[r - 1] + mod - s1[l];
                f1[i] += f1[r] * (R - x1[r] + 1);
                f1[i] += f1[l] * (x1[l + 1] - L);
                f1[i] %= mod;
            &amp;#125;
            // printf(&amp;quot;  r = %d, l = [%d, %d]: %lld\n&amp;quot;, x, L, R, f1[i]);
            if (i != n1)
                s1[i] = (s1[i - 1] + f1[i] * (p1[id][i].i - x)) % mod;
        &amp;#125;
        (s += f1[n1] - 1) %= mod;
        int n2 = (int)p2[id].size();
        x2[n2 + 1] = n + 1, f2[n2 + 1] = s2[n2 + 1] = 1ll;
        for (int i = n2; i; --i) &amp;#123;
            auto [x, L, R] = p2[id][i - 1];
            ++L, ++R;
            x2[i] = x, f2[i] = f2[i + 1];
            int l = std::lower_bound(x2.begin() + i, x2.begin() + n2 + 1, L) - x2.begin(),
                r = std::lower_bound(x2.begin() + i, x2.begin() + n2 + 1, R) - x2.begin();
            if (l == r)
                (f2[i] += f2[l] * (R - L + 1)) %= mod;
            else&amp;#123;
                f2[i] += s2[l + 1] + mod - s2[r];
                f2[i] += f2[r] * (R - x2[r - 1]);
                f2[i] += f2[l] * (x2[l] - L + 1);
                f2[i] %= mod;
            &amp;#125;
            // printf(&amp;quot;  l = %d, r = [%d, %d]: %lld\n&amp;quot;, x, L, R, f2[i]);
            if (i != 1)
                s2[i] = (s2[i + 1] + f2[i] * (x - p2[id][i - 2].i)) % mod;
        &amp;#125;
        for (int i = 0; i &amp;lt; n1; ++i)
            x1[i] = x1[i + 1];
        x1[n1] = n;
        int t = (x2[1] == 1) + 1;
        for (int i = 1; i &amp;lt;= n2 + 1; ++i)
            --x2[i];
        std::merge(x1.begin(), x1.begin() + n1 + 1, x2.begin() + t, x2.begin() + n2 + 2, pos.begin() + 1);
        int m = std::unique(pos.begin() + 1, pos.begin() + n1 + n2 + 4 - t) - pos.begin() - 1;
        for (int i = 1, p1 = 0, p2 = t, la = 0; i &amp;lt;= m; ++i) &amp;#123;
            for (; p1 + 1 &amp;lt;= n1 &amp;amp;&amp;amp; x1[p1] &amp;lt; pos[i]; ++p1);
            for (; p2 + 1 &amp;lt;= n2 + 1 &amp;amp;&amp;amp; x2[p2] &amp;lt; pos[i]; ++p2);
            (diff[la + 1] += f1[p1] * f2[p2] + mod - 1) %= mod;
            // printf(&amp;quot;  [%d, %d]: %lld, %lld\n&amp;quot;, la + 1, pos[i], f1[p1], f2[p2]);
            if (pos[i] + 1 &amp;lt;= n)
                (diff[pos[i] + 1] += mod - f1[p1] * f2[p2] + 1) %= mod;
            la = pos[i];
        &amp;#125;
    &amp;#125;
    // std::cout &amp;lt;&amp;lt; s &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        (diff[i] += diff[i - 1]) %= mod;
        std::cout &amp;lt;&amp;lt; (s + mod - diff[i]) % mod &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
    &amp;#125;
    std::cout &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;p&gt;我一开始将 &lt;span class=&#34;math inline&#34;&gt;\(f\)&lt;/span&gt; 定义为单点答案而非前缀和，会导致需要线段树维护等差序列，还丢失了答案段数不多这个性质，非常麻烦。将 &lt;span class=&#34;math inline&#34;&gt;\(f\)&lt;/span&gt; 的意义替换为前缀和后，就可以很轻松地做了。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;a.-宇宙&#34;&gt;A. 宇宙&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://222.180.160.110:61235/contest/6535/problem/1&#34; class=&#34;uri&#34;&gt;http://222.180.160.110:61235/contest/6535/problem/1&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定 &lt;span class=&#34;math inline&#34;&gt;\(a_{1\sim n}\)&lt;/span&gt;，对于 &lt;span class=&#34;math inline&#34;&gt;\(k=1,2,\cdots,n-1\)&lt;/span&gt;，回答：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;令 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 从 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt; 开始自增，对于每个 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt;，都可以选取 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 个互不相同的下标，并使它们对应的元素增加 1。此时，若存在元素不大于 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt;，停止。输出停止时 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 可能的最大值。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(n\le 10^6,V\le 10^9\)&lt;/span&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;发现不大于这个 condition 有些反人类，先将 &lt;span class=&#34;math inline&#34;&gt;\(a\)&lt;/span&gt; 全部减 1，转化成小于来考虑&lt;/p&gt;
&lt;p&gt;考虑能坚持到 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 的一个必要条件，即 &lt;span class=&#34;math inline&#34;&gt;\(\sum\limits_{a_j&amp;lt;i} i-a_j\le k\cdot i\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;容易发现该条件同时是充分的，可以朝摩尔投票思考&lt;/p&gt;
&lt;p&gt;对 &lt;span class=&#34;math inline&#34;&gt;\(a\)&lt;/span&gt; 排序，停止时参与运算的 &lt;span class=&#34;math inline&#34;&gt;\(a_j\)&lt;/span&gt; 是越来越多的，故记录最后一个参与运算的下标，逐步挪动（当发现解出来的 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 比下一个更大时就需要挪动），同时解不等式即可。&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;citation&#34; data-cites=&#34;Quack&#34;&gt;@Quack&lt;/span&gt; 云我在场上能想出官解对我来说是非常了不起的（其实场上写正解的人少得出奇），我也不得不承认我能做出来确实有一定运气成分，也能从中一窥我令人眼前一黑的数学素养！&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
int main() &amp;#123;
    std::freopen(&amp;quot;universe.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;universe.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
    int n;
    std::cin &amp;gt;&amp;gt; n, std::cin &amp;gt;&amp;gt; n;
    std::vector&amp;lt;int&amp;gt; a(n + 1);
    for (int i = 1; i &amp;lt;= n; ++i)
        std::cin &amp;gt;&amp;gt; a[i], --a[i];
    std::sort(a.begin() + 1, a.end());
    int id = 1;
    long long s = a[1];
    for (int i = 1; i &amp;lt; n; ++i) &amp;#123;
        if (id &amp;lt; i + 1)
            s += a[++id];
        long long x = s / (id - i);
        for (; id != n &amp;amp;&amp;amp; x &amp;gt; a[id + 1]; s += a[++id], x = s / (id - i));
        std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
    &amp;#125;
    std::cout &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;b.-跳跃&#34;&gt;B. 跳跃&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://222.180.160.110:61235/contest/6535/problem/2&#34; class=&#34;uri&#34;&gt;http://222.180.160.110:61235/contest/6535/problem/2&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定长度为 &lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt; 的 01 序列和跳跃上限 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt;。给定 &lt;span class=&#34;math inline&#34;&gt;\(q\)&lt;/span&gt; 个询问，回答：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从 &lt;span class=&#34;math inline&#34;&gt;\(a\)&lt;/span&gt; 跳到 &lt;span class=&#34;math inline&#34;&gt;\(b\)&lt;/span&gt;，保证 &lt;span class=&#34;math inline&#34;&gt;\(a,b\)&lt;/span&gt; 的颜色均为 1，每次不能跳超过 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 格或跳出去，在最小化踩到 0 数量的前提下，最小化跳跃次数，输出这两个值。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(n,q\le5\times10^5\)&lt;/span&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;容易发现只能往一个方向跳，那么不妨令 &lt;span class=&#34;math inline&#34;&gt;\(a&amp;lt;b\)&lt;/span&gt;。有一个贪心的想法是能往右就往右，手玩发现&lt;strong&gt;是对的&lt;/strong&gt;（我场上手玩过后坚定地认为是错的；可能和没时间了兵荒马乱有关）。这样就很好想到第二问需要倍增；但把两个问结合起来考虑是有点困难的，赛时就意识到这两问的联系没有看起来那么大，甚至很可能是割裂的。&lt;/p&gt;
&lt;p&gt;单独考虑第一问，发现对于一段长度为 &lt;span class=&#34;math inline&#34;&gt;\(len\)&lt;/span&gt; 的 0，需要踩到恰好 &lt;span class=&#34;math inline&#34;&gt;\(\left\lfloor\dfrac {len}k\right\rfloor\)&lt;/span&gt; 个 0。答案容易计算。&lt;/p&gt;
&lt;p&gt;单独考虑第二问，考虑一个第一问答案固定为 0 的情况，也即每个 len 都比 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 小。则问题转化成在不踩 0 的情况下最小的步数。容易用倍增解决。&lt;/p&gt;
&lt;p&gt;本题最令人印象深刻的点在于二者的结合，发现这 &lt;span class=&#34;math inline&#34;&gt;\(\left\lfloor\dfrac {len}k\right\rfloor\cdot k\)&lt;/span&gt; 个 0 是无论如何都会被经过的，所以可以在原始数组里删掉它们，转化成只考虑第二问的情况&lt;/p&gt;
&lt;details&gt;
&lt;p&gt;？？？&lt;/p&gt;
&lt;p&gt;我对于自己莫名其妙跑得比别人快一大截这件事情已经快要见怪不怪了，这次又是什么原理，我预处理写得比较漂亮吗？？&lt;/p&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
    std::freopen(&amp;quot;jump.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;jump.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, k, q, op;
    std::cin &amp;gt;&amp;gt; n, std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; q &amp;gt;&amp;gt; k &amp;gt;&amp;gt; op;
    std::vector&amp;lt;int&amp;gt; tmp(n + 1), a(1), s(1), to(n + 2);
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        char t;
        std::cin &amp;gt;&amp;gt; t;
        tmp[i] = t - &amp;#39;0&amp;#39;;
    &amp;#125;
    tmp.push_back(1), ++n;
    int cnt = 0;
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        if (tmp[i] == 1) &amp;#123;
            a.push_back(1), to[i] = (int)a.size() - 1;
            s.push_back(s.back() + cnt), cnt = 0;
        &amp;#125;
        else &amp;#123;
            ++cnt;
            if (i == n || tmp[i + 1] == 1) &amp;#123;
                for (int j = 1; j &amp;lt;= cnt % k; ++j)
                    a.push_back(0), s.push_back(s.back());
                cnt /= k;
            &amp;#125;
        &amp;#125;
    &amp;#125;
    n = (int)a.size() - 1;
    std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; f(20, std::vector&amp;lt;int&amp;gt; (n + 1));
    for (int i = 0; i &amp;lt; 20; ++i)
        f[i][n] = n;
    for (int i = n - 1; i; --i) &amp;#123;
        f[0][i] = std::min(&amp;#123; n, i + k, f[0][i + 1] &amp;#125;);
        for (; !a[f[0][i]]; --f[0][i]);
        if (a[i] == 1) &amp;#123;
            for (int j = 1; j &amp;lt; 20; ++j)
                f[j][i] = f[j - 1][f[j - 1][i]];
        &amp;#125;
    &amp;#125;
    for (int a, b; q--; ) &amp;#123;
        std::cin &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b;
        if (a &amp;gt; b)
            std::swap(a, b);
        a = to[a], b = to[b];
        std::cout &amp;lt;&amp;lt; s[b] - s[a];
        if (op == 1) &amp;#123;
            int res = s[b] - s[a];
            for (int i = 19; ~i; --i)
                if (f[i][a] &amp;lt; b)
                    a = f[i][a], res += (1 &amp;lt;&amp;lt; i);
            std::cout &amp;lt;&amp;lt; &amp;#39; &amp;#39; &amp;lt;&amp;lt; res + 1;
        &amp;#125;
        std::cout &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    &amp;#125;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;d.-jongmah&#34;&gt;D. Jongmah&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://codeforces.com/contest/1110/problem/D&#34; class=&#34;uri&#34;&gt;https://codeforces.com/contest/1110/problem/D&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;容易发现当连续出现三次 &lt;span class=&#34;math inline&#34;&gt;\((i-1,i,i+1)\)&lt;/span&gt; 时，可以被三次相同代替；&lt;/p&gt;
&lt;p&gt;容易发现需要使用 &lt;span class=&#34;math inline&#34;&gt;\(f_{i,a,b}\)&lt;/span&gt; 来代表 DP 到 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 时，用了 &lt;span class=&#34;math inline&#34;&gt;\(a\)&lt;/span&gt; 组 &lt;span class=&#34;math inline&#34;&gt;\((i-1,i,i+1)\)&lt;/span&gt; 和 &lt;span class=&#34;math inline&#34;&gt;\(b\)&lt;/span&gt; 组 &lt;span class=&#34;math inline&#34;&gt;\((i,i+1,i+2)\)&lt;/span&gt; 时的最大组数；&lt;/p&gt;
&lt;p&gt;但是并没有想到要将二者结合起来！感觉应该是能比较快做出来的水平。能察觉到不太认真。悔过！&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int inf = 0x3f3f3f3f;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, m;
    std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
    std::vector&amp;lt;int&amp;gt; cnt(m + 1);
    for (int i = 1, x; i &amp;lt;= n; ++i)
        std::cin &amp;gt;&amp;gt; x, ++cnt[x];
    std::vector&amp;lt;std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; &amp;gt; f(m + 1, std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; (3, std::vector&amp;lt;int&amp;gt; (3, -inf)));
    f[0][0][0] = 0ll;
    for (int i = 1; i &amp;lt;= m; ++i)
        for (int a = 0; a &amp;lt;= 2; ++a) // i - 1, i, i + 1
            for (int b = 0; b &amp;lt;= 2; ++b) // i, i + 1, i + 2
                for (int c = 0; c &amp;lt;= 2; ++c) &amp;#123; // i - 2, i - 1, i
                    if (a + b + c &amp;gt; cnt[i]) continue;
                    f[i][a][b] = std::max(f[i][a][b], f[i - 1][c][a] + b + (cnt[i] - a - b - c) / 3);
                &amp;#125;
    std::cout &amp;lt;&amp;lt; f[m][0][0] &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;e.-magic-stones&#34;&gt;E. Magic Stones&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://codeforces.com/contest/1110/problem/F&#34; class=&#34;uri&#34;&gt;https://codeforces.com/contest/1110/problem/F&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;容易想到考察差分数组，发现这个操作就是交换了差分数组的相邻两个元素。故对于 &lt;span class=&#34;math inline&#34;&gt;\(c\)&lt;/span&gt; 和 &lt;span class=&#34;math inline&#34;&gt;\(t\)&lt;/span&gt; 的差分数组分别排序，然后 check 是否相等即可。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n;
    std::cin &amp;gt;&amp;gt; n;
    std::vector&amp;lt;int&amp;gt; a(n + 1), b(n + 1);
    for (int i = 1; i &amp;lt;= n; ++i)
        std::cin &amp;gt;&amp;gt; a[i];
    for (int i = 1; i &amp;lt;= n; ++i)
        std::cin &amp;gt;&amp;gt; b[i];
    if (a[1] != b[1] || a[n] != b[n]) &amp;#123;
        std::cout &amp;lt;&amp;lt; &amp;quot;No&amp;quot; &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
        return 0;
    &amp;#125;
    std::vector&amp;lt;int&amp;gt; da(n), db(n);
    std::adjacent_difference(a.begin() + 1, a.end(), da.begin());
    std::adjacent_difference(b.begin() + 1, b.end(), db.begin());
    std::sort(da.begin(), da.end());
    std::sort(db.begin(), db.end());
    std::cout &amp;lt;&amp;lt; (da == db ? &amp;quot;Yes&amp;quot; : &amp;quot;No&amp;quot;) &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://xsc062.netlify.app/20250820/</guid>
            <title>杂题</title>
            <link>https://xsc062.netlify.app/20250820/</link>
            <category>DP</category>
            <category>容斥</category>
            <pubDate>Wed, 20 Aug 2025 20:26:44 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;困难&lt;/p&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;b.-beauty拆贡献&#34;&gt;B. beauty（拆贡献）&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;http://222.180.160.110:61235/contest/6513/problem/2&#34; class=&#34;uri&#34;&gt;http://222.180.160.110:61235/contest/6513/problem/2&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定 &lt;span class=&#34;math inline&#34;&gt;\(n,V\)&lt;/span&gt;，求出对于所有长度为 &lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt;，值域为 &lt;span class=&#34;math inline&#34;&gt;\([1,V]\)&lt;/span&gt; 的序列 &lt;span class=&#34;math inline&#34;&gt;\(a_{1\sim n}\)&lt;/span&gt;，&lt;span class=&#34;math inline&#34;&gt;\(\sum_{i=1}^n |a_i-a_{n-i+1}|\)&lt;/span&gt; 的和。&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(n,V\le 5000\)&lt;/span&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;容易想到算贡献，会有一个 &lt;span class=&#34;math inline&#34;&gt;\(O(n^2V)\)&lt;/span&gt; 的做法。但是想 &lt;span class=&#34;math inline&#34;&gt;\(O(nV)\)&lt;/span&gt; 做是很抽象的，和 &lt;span class=&#34;math inline&#34;&gt;\(O(n^2V)\)&lt;/span&gt; 的思路已经很不一样了&lt;/li&gt;
&lt;li&gt;经典 trick，&lt;span class=&#34;math inline&#34;&gt;\(a_{i+n/2}-a_i=\sum\limits_{x=0}^{+\infty} [a_i\le x&amp;lt;a_{i+n/2}]\)&lt;/span&gt; 拆贡献 。故要算 &lt;span class=&#34;math inline&#34;&gt;\(a_{i}-a_{i+n/2}\)&lt;/span&gt;，只需要对于每个 &lt;span class=&#34;math inline&#34;&gt;\(x\in[a_i,a_{i+n/2})\)&lt;/span&gt; 计算贡献。&lt;/li&gt;
&lt;li&gt;枚举 &lt;span class=&#34;math inline&#34;&gt;\(x\in [1,V)\)&lt;/span&gt;，再枚举最大的 &lt;span class=&#34;math inline&#34;&gt;\(t\)&lt;/span&gt;，满足 &lt;span class=&#34;math inline&#34;&gt;\(a_t\ge x\)&lt;/span&gt;。那么有 &lt;span class=&#34;math inline&#34;&gt;\(t\)&lt;/span&gt; 个 &lt;span class=&#34;math inline&#34;&gt;\(a_i\le x\)&lt;/span&gt;，同时有 &lt;span class=&#34;math inline&#34;&gt;\(n-t\)&lt;/span&gt; 个 &lt;span class=&#34;math inline&#34;&gt;\(a_i&amp;gt;x\)&lt;/span&gt;；满足 &lt;span class=&#34;math inline&#34;&gt;\(i\le n/2\)&lt;/span&gt; 的 &lt;span class=&#34;math inline&#34;&gt;\(a_{i},a_{i+n/2}\)&lt;/span&gt; 对数应该是 &lt;span class=&#34;math inline&#34;&gt;\(\min(t,n-t)\)&lt;/span&gt;。故对于一个确定的序列，&lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 共有 &lt;span class=&#34;math inline&#34;&gt;\(\min(t,n-t)\)&lt;/span&gt; 的贡献。&lt;/li&gt;
&lt;li&gt;考虑计数满足 &lt;span class=&#34;math inline&#34;&gt;\(a_t\le x\)&lt;/span&gt; 的 &lt;span class=&#34;math inline&#34;&gt;\(a\)&lt;/span&gt;，这要求第 &lt;span class=&#34;math inline&#34;&gt;\(t\)&lt;/span&gt; 大的数 &lt;span class=&#34;math inline&#34;&gt;\(\le x\)&lt;/span&gt; 而第 &lt;span class=&#34;math inline&#34;&gt;\(t+1\)&lt;/span&gt; 大的数 &lt;span class=&#34;math inline&#34;&gt;\(&amp;gt;x\)&lt;/span&gt;，也即在 &lt;span class=&#34;math inline&#34;&gt;\([1,x]\)&lt;/span&gt; 里找 &lt;span class=&#34;math inline&#34;&gt;\(t\)&lt;/span&gt; 个数再在 &lt;span class=&#34;math inline&#34;&gt;\((x,V]\)&lt;/span&gt; 里找 &lt;span class=&#34;math inline&#34;&gt;\(n-t\)&lt;/span&gt; 个数，注意还要再乘上这两种数拼起来的方案数。&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int mod = 998244353;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
    std::freopen(&amp;quot;beauty.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;beauty.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int T;
    std::vector&amp;lt;long long&amp;gt; fac(5001), inv(5001);
    std::vector&amp;lt;std::vector&amp;lt;long long&amp;gt; &amp;gt; pw(5001, std::vector&amp;lt;long long&amp;gt; (5001));
    fac[0] = inv[0] = 1ll;
    for (int i = 1; i &amp;lt;= 5000; ++i) &amp;#123;
        fac[i] = fac[i - 1] * i % mod;
        pw[i][0] = 1ll;
        for (int j = 1; j &amp;lt;= 5000; ++j)
            pw[i][j] = pw[i][j - 1] * i % mod;
    &amp;#125;
    auto qkp = [](long long x, int y) &amp;#123;
        auto res(1ll);
        for (; y; (x *= x) %= mod, y &amp;gt;&amp;gt;= 1)
            if (y &amp;amp; 1)
                (res *= x) %= mod;
        return res;
    &amp;#125;;
    inv[5000] = qkp(fac[5000], mod - 2);
    for (int i = 4999; i; --i)
        inv[i] = inv[i + 1] * (i + 1) % mod;
    auto C = [&amp;amp;](int n, int m) &amp;#123;
        return fac[n] * inv[m] % mod * inv[n - m] % mod;
    &amp;#125;;
    for (std::cin &amp;gt;&amp;gt; T; T--; ) &amp;#123;
        int n, V;
        std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; V;
        auto res(0ll);
        for (int x = 1; x &amp;lt; V; ++x)
            for (int t = 1; t &amp;lt; n; ++t) &amp;#123;
                int k = std::min(t, n - t);
                (res += k * pw[x][t] % mod * pw[V - x][n - t] % mod * C(n, t) % mod) %= mod;
            &amp;#125;
        std::cout &amp;lt;&amp;lt; res * 2 % mod &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    &amp;#125;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;c.-drink-bar容斥-偏序&#34;&gt;C. Drink Bar（容斥 + 偏序）&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/AT_snuke21_j&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/AT_snuke21_j&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;三个属性都是排列，可以推理出只要两个三元组中，作出贡献的元素不完全相同，两个三元组就不同。讨论作出贡献的元素数量。&lt;/li&gt;
&lt;li&gt;只有一个元素作出贡献，答案为 &lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;有两个元素作出贡献，任选的话答案为 &lt;span class=&#34;math inline&#34;&gt;\(C_n^2\)&lt;/span&gt;，要减去一个元素严格优于另一个元素的情况，三维偏序即可。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;有三个元素作出贡献，是个有点复杂的容斥，不妨设三元组为 &lt;span class=&#34;math inline&#34;&gt;\((i,j,k)\)&lt;/span&gt;，其中贡献次数最多的为 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt;&lt;/p&gt;
&lt;ol type=&#34;1&#34;&gt;
&lt;li&gt;&lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 贡献了 &lt;span class=&#34;math inline&#34;&gt;\(\ge 1\)&lt;/span&gt; 次，方案数为 &lt;span class=&#34;math inline&#34;&gt;\(C_n^3\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 贡献了 &lt;span class=&#34;math inline&#34;&gt;\(\ge 2\)&lt;/span&gt; 次，枚举作出两次贡献的属性，以 &lt;span class=&#34;math inline&#34;&gt;\(a,b\)&lt;/span&gt; 为例，那么有 &lt;span class=&#34;math inline&#34;&gt;\(a_j,a_k&amp;lt;a_i\)&lt;/span&gt;，以及 &lt;span class=&#34;math inline&#34;&gt;\(b_j,b_k&amp;lt;b_i\)&lt;/span&gt;，二维偏序即可&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 贡献了 &lt;span class=&#34;math inline&#34;&gt;\(\ge 3\)&lt;/span&gt; 次，依然是三维偏序，可以用『两个元素做出贡献』中 cdq 得到的值算出答案。记得乘 2，因为被多减了 2 次。&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n;
    std::cin &amp;gt;&amp;gt; n;
    struct node &amp;#123; int a, b, c, res; &amp;#125;;
    std::vector&amp;lt;node&amp;gt; a(n + 1);
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        std::cin &amp;gt;&amp;gt; a[i].a &amp;gt;&amp;gt; a[i].b &amp;gt;&amp;gt; a[i].c;
        a[i].res = 0;
    &amp;#125;
    long long res = n;
    res += (long long)n * (n - 1) / 2;
    std::vector&amp;lt;int&amp;gt; bit(n + 1);
    auto lowbit = [](int x) &amp;#123;
        return x &amp;amp; -x;
    &amp;#125;;
    auto add = [&amp;amp;](int x, int v) &amp;#123;
        for (; x &amp;lt;= n; x += lowbit(x))
            bit[x] += v;
        return;
    &amp;#125;;
    auto ask = [&amp;amp;](int x) &amp;#123;
        int res = 0;
        for (; x; x -= lowbit(x))
            res += bit[x];
        return res;
    &amp;#125;;
    std::function&amp;lt;void(int, int)&amp;gt; calc = [&amp;amp;](int l, int r) &amp;#123;
        if (l == r)
            return;
        int mid = (l + r) &amp;gt;&amp;gt; 1;
        calc(l, mid), calc(mid + 1, r);
        int j = l;
        for (int i = mid + 1; i &amp;lt;= r; ++i) &amp;#123;
            for (; j &amp;lt;= mid &amp;amp;&amp;amp; a[j].b &amp;lt; a[i].b; ++j)
                add(a[j].c, 1);
            a[i].res += ask(a[i].c);
        &amp;#125;
        for (int i = l; i &amp;lt; j; ++i)
            add(a[i].c, -1);
        std::inplace_merge(a.begin() + l, a.begin() + mid + 1, a.begin() + r + 1, [&amp;amp;](node x, node y) &amp;#123; return x.b &amp;lt; y.b; &amp;#125;);
        return;
    &amp;#125;;
    std::sort(a.begin() + 1, a.end(), [&amp;amp;](node x, node y) &amp;#123; return x.a &amp;lt; y.a; &amp;#125;);
    calc(1, n);
    for (int i = 1; i &amp;lt;= n; ++i)
        res -= a[i].res;
    res += (long long)n * (n - 1) * (n - 2) / 6;
    for (int k = 0; k &amp;lt; 3; ++k) &amp;#123;
        std::sort(a.begin() + 1, a.end(), [&amp;amp;](node x, node y) &amp;#123; return x.a &amp;lt; y.a; &amp;#125;);
        std::fill(bit.begin() + 1, bit.end(), 0);
        for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
            int t = ask(a[i].b);
            res -= (long long)t * (t - 1) / 2;
            add(a[i].b, 1);
            std::tie(a[i].a, a[i].b, a[i].c) = std::make_tuple(a[i].b, a[i].c, a[i].a);
        &amp;#125;
    &amp;#125;
    for (int i = 1; i &amp;lt;= n; ++i)
        res += (long long)a[i].res * (a[i].res - 1);
    std::cout &amp;lt;&amp;lt; res &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;c.-星白-by-ttpandas笛卡尔树-dsu-on-tree&#34;&gt;C. 星白 by TTpandaS（笛卡尔树 + dsu on tree）&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;/20250819/#星白-by-ttpandas笛卡尔树-dsu-on-tree&#34;&gt;link&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;c.-isn&#34;&gt;C. isn&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://hydro.ac/p/bzoj-P4361&#34; class=&#34;uri&#34;&gt;https://hydro.ac/p/bzoj-P4361&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;最后一个删去的一定是连接 &lt;code&gt;&amp;gt;&lt;/code&gt; 的数，可以 DP 还剩一个数没删时可能的序列。&lt;/p&gt;
令 &lt;span class=&#34;math inline&#34;&gt;\(f_{i,j,0/1}\)&lt;/span&gt; 表示最后一个元素为 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt;，序列长为 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt;，最后一个被删去的数（未）被确定的方案数。&lt;strong&gt;注意确定最后一个被删去的数要在转移过程中进行，而不是作为一个 DP 节点&lt;/strong&gt;，很容易发现后者是错的。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;优化的思路就不一样了。因为要乘上 &lt;span class=&#34;math inline&#34;&gt;\((n-j)!\)&lt;/span&gt;，所以 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; 的这一维是省不掉的&lt;/p&gt;
考虑不管最后一个被删掉的数，直接令 &lt;span class=&#34;math inline&#34;&gt;\(f_{i,j}\)&lt;/span&gt; 表示最后一个元素为 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt;，序列长为 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; 的方案数。有 &lt;span class=&#34;math inline&#34;&gt;\(f_{i,j}=\sum\limits_{a_k\le a_i}f_{k,j - 1}\)&lt;/span&gt;，可以 DS 优化。但这样会产生不合法的情况。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;考察什么样的序列合法，发现&lt;strong&gt;删去的最后一个数一定是非法的，也就是包含之的序列都是非法的；反之易得被合法序列包含的序列都非法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;明白了这一点过后就会知道长度为 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; 的合法序列系数都为 &lt;span class=&#34;math inline&#34;&gt;\((n-j)!\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;故容斥，令 &lt;span class=&#34;math inline&#34;&gt;\(g_i\)&lt;/span&gt; 表示序列长为 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 的方案数，&lt;span class=&#34;math inline&#34;&gt;\(h_i\)&lt;/span&gt; 表示序列长为 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 的合法方案数。从异或角度考虑，易得 &lt;span class=&#34;math inline&#34;&gt;\(h_i=g_i-\sum\limits_{j=i+1}h_j\times (j-i)!\times C_j^i\)&lt;/span&gt;。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int mod = 1e9 + 7;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
    std::freopen(&amp;quot;isn.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;isn.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n;
    std::cin &amp;gt;&amp;gt; n;
    std::vector&amp;lt;int&amp;gt; a(n + 1), l(1);
    std::vector&amp;lt;long long&amp;gt; fac(n + 1), inv(n + 1);
    fac[0] = inv[0] = 1ll;
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        std::cin &amp;gt;&amp;gt; a[i], l.push_back(a[i]);
        fac[i] = fac[i - 1] * i % mod;
    &amp;#125;
    auto qkp = [](long long x, int y) &amp;#123;
        auto res(1ll);
        for (; y; (x *= x) %= mod, y &amp;gt;&amp;gt;= 1)
            if (y &amp;amp; 1)
                (res *= x) %= mod;
        return res;
    &amp;#125;;
    inv[n] = qkp(fac[n], mod - 2);
    for (int i = n - 1; i; --i)
        inv[i] = inv[i + 1] * (i + 1) % mod;
    auto C = [&amp;amp;](int n, int m) &amp;#123;
        return fac[n] * inv[m] % mod * inv[n - m] % mod;
    &amp;#125;;
    std::sort(l.begin(), l.end());
    l.erase(std::unique(l.begin(), l.end()), l.end());
    for (int i = 0; i &amp;lt;= n; ++i)
        a[i] = std::lower_bound(l.begin(), l.end(), a[i]) - l.begin() + 1;
    int m = (int)l.size();
    std::vector&amp;lt;std::vector&amp;lt;long long&amp;gt; &amp;gt; bit(n + 1, std::vector&amp;lt;long long&amp;gt; (m + 1));
    auto lowbit = [](int x) &amp;#123;
        return x &amp;amp; -x;
    &amp;#125;;
    auto add = [&amp;amp;](int id, int x, long long v) &amp;#123;
        for (; x &amp;lt;= m; x += lowbit(x))
            (bit[id][x] += v) %= mod;
        return;
    &amp;#125;;
    auto ask = [&amp;amp;](int id, int x) &amp;#123;
        auto res(0ll);
        for (; x; x -= lowbit(x))
            (res += bit[id][x]) %= mod;
        return res;
    &amp;#125;;
    std::vector&amp;lt;long long&amp;gt; g(n + 1), h(n + 1);
    std::vector&amp;lt;std::vector&amp;lt;long long&amp;gt; &amp;gt; f(n + 1, std::vector&amp;lt;long long&amp;gt; (n + 1));
    add(0, a[0], 1ll), f[0][0] = 1ll;
    for (int i = 1; i &amp;lt;= n; ++i)
        for (int j = n; j; --j) &amp;#123;
            f[i][j] = ask(j - 1, a[i]);
            add(j, a[i], f[i][j]);
            (g[j] += f[i][j] * fac[n - j]) %= mod;
        &amp;#125;
    auto res(0ll);
    for (int i = n; i; --i) &amp;#123;
        h[i] = g[i];
        for (int j = i + 1; j &amp;lt;= n; ++j)
            (h[i] += mod - h[j] * fac[j - i] % mod * C(j, i) % mod) %= mod;
        (res += h[i]) %= mod;
    &amp;#125;
    std::cout &amp;lt;&amp;lt; res &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;d.-thepowers&#34;&gt;D. ThePowers&lt;/h3&gt;
&lt;p&gt;TopCoder - 12185，原题交不了故不放链接了&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://222.180.160.110:61235/contest/6522/problem/4&#34; class=&#34;uri&#34;&gt;http://222.180.160.110:61235/contest/6522/problem/4&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定 &lt;span class=&#34;math inline&#34;&gt;\(A,B\)&lt;/span&gt;，对于所有 &lt;span class=&#34;math inline&#34;&gt;\(X\le A,Y\le B\)&lt;/span&gt;，求 &lt;span class=&#34;math inline&#34;&gt;\(X^Y\)&lt;/span&gt; 的可能取值数量。&lt;span class=&#34;math inline&#34;&gt;\(A,B\le10^9\)&lt;/span&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;考虑什么时候算重。发现当且仅当 &lt;span class=&#34;math inline&#34;&gt;\(x^a=y^b\)&lt;/span&gt;，此时记 &lt;span class=&#34;math inline&#34;&gt;\(a&amp;#39;=a\div\gcd(a,b),b&amp;#39;=b\div \gcd(a,b)\)&lt;/span&gt;，那么 &lt;span class=&#34;math inline&#34;&gt;\(t=\sqrt[a&amp;#39;]x=\sqrt[b&amp;#39;]y\)&lt;/span&gt; 为整（写成质因数乘积是易证的），则 &lt;span class=&#34;math inline&#34;&gt;\(x=t^b,y=t^a\)&lt;/span&gt;，是同一个数的不同次幂&lt;/li&gt;
&lt;li&gt;&lt;p&gt;故把 &lt;span class=&#34;math inline&#34;&gt;\(A\)&lt;/span&gt; 内所有数分组，记 &lt;span class=&#34;math inline&#34;&gt;\(S_x\)&lt;/span&gt; 表示所有 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 的次幂，其中 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 不是其他数的次幂&lt;/p&gt;
发现一个对于 &lt;span class=&#34;math inline&#34;&gt;\(&amp;gt;\sqrt A\)&lt;/span&gt; 的数 &lt;span class=&#34;math inline&#34;&gt;\(y\)&lt;/span&gt;，只有可能属于 &lt;span class=&#34;math inline&#34;&gt;\(S_y\)&lt;/span&gt;，或一个 &lt;span class=&#34;math inline&#34;&gt;\(x\le \sqrt A\)&lt;/span&gt; 的 &lt;span class=&#34;math inline&#34;&gt;\(S_x\)&lt;/span&gt;。每组最多有 &lt;span class=&#34;math inline&#34;&gt;\(30\)&lt;/span&gt; 个，故扫一遍 &lt;span class=&#34;math inline&#34;&gt;\(\le\sqrt A\)&lt;/span&gt; 的数即可完成分组。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;这样就只用考虑同组内的计数。即对于 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 和 &lt;span class=&#34;math inline&#34;&gt;\(p\le |S_x|,y\le B\)&lt;/span&gt;，&lt;span class=&#34;math inline&#34;&gt;\(x^{py}\)&lt;/span&gt; 有多少种取值，也即 &lt;span class=&#34;math inline&#34;&gt;\(py\)&lt;/span&gt; 有多少种取值&lt;/p&gt;
发现因为值域是连续的，对于一个 &lt;span class=&#34;math inline&#34;&gt;\(p\)&lt;/span&gt;，只要 &lt;span class=&#34;math inline&#34;&gt;\(pB\)&lt;/span&gt; 范围内某个数是 &lt;span class=&#34;math inline&#34;&gt;\(p\)&lt;/span&gt; 的倍数就可以取到，枚举 &lt;span class=&#34;math inline&#34;&gt;\([(p-1)B+1,pB]\)&lt;/span&gt;，对于每个 &lt;span class=&#34;math inline&#34;&gt;\(p\)&lt;/span&gt; 容斥，就需要计算 &lt;span class=&#34;math inline&#34;&gt;\(p\sim |S_x|\)&lt;/span&gt; 的每个子集，复杂度会爆炸。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;对于 &lt;span class=&#34;math inline&#34;&gt;\(x,y\in[p,|S_x|]\)&lt;/span&gt;，如果 &lt;span class=&#34;math inline&#34;&gt;\(y\)&lt;/span&gt; 是 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 的倍数，就可以 skip，只在剩下的元素里枚举子集，可以代码验证一下 &lt;span class=&#34;math inline&#34;&gt;\(30\)&lt;/span&gt; 以内最多剩下 &lt;span class=&#34;math inline&#34;&gt;\(15\)&lt;/span&gt; 个数，可以接受，注意子集信息类似高维前缀和地 &lt;span class=&#34;math inline&#34;&gt;\(O(1)\)&lt;/span&gt; 求就行了&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
    std::freopen(&amp;quot;power.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;power.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    long long A, B, mx = 1ll;
    std::cin &amp;gt;&amp;gt; A &amp;gt;&amp;gt; B;
    if (A == 1) &amp;#123;
        std::cout &amp;lt;&amp;lt; 1 &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
        return 0;
    &amp;#125;
    int cnt = 1;
    long long res = 1ll;
    for (; (mx + 1) * (mx + 1) &amp;lt;= A; ++mx);
    std::vector&amp;lt;int&amp;gt; tag(mx + 1);
    for (int i = 2; i &amp;lt;= mx; ++i)
        if (!tag[i]) &amp;#123;
            int siz = 1;
            for (long long j = i; j &amp;lt;= A; j *= i, ++siz)
                if (j &amp;lt;= mx)
                    tag[j] = 1;
            cnt += --siz;
            for (int j = 1; j &amp;lt;= siz; ++j) &amp;#123;
                std::vector&amp;lt;int&amp;gt; p(&amp;#123; j &amp;#125;);
                for (int k = j + 1; k &amp;lt;= siz; ++k) &amp;#123;
                    bool flag = 1;
                    for (auto l : p)
                        if (k % l == 0) &amp;#123;
                            flag = 0;
                            break;
                        &amp;#125;
                    if (flag)
                        p.push_back(k);
                &amp;#125;
                int m = (int)p.size(), s = 1 &amp;lt;&amp;lt; m;
                std::vector&amp;lt;long long&amp;gt; mul(s);
                mul[0] = 1ll;
                auto lcm = [&amp;amp;](long long x, long long y) &amp;#123;
                    return x / std::__gcd(x, y) * y;
                &amp;#125;;
                for (int k = 1; k &amp;lt; s; ++k) &amp;#123;
                    mul[k] = lcm(p[std::__lg(k ^ ((k - 1) &amp;amp; k))], mul[(k - 1) &amp;amp; k]);
                    if (__builtin_popcount(k) &amp;amp; 1)
                        res += j * B / mul[k] - (j - 1) * B / mul[k];
                    else
                        res -= j * B / mul[k] - (j - 1) * B / mul[k];
                &amp;#125;
            &amp;#125;
        &amp;#125;
    res += (A - cnt) * B;
    std::cout &amp;lt;&amp;lt; res &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;p&gt;搜索做法本质上是一样的，就不赘述了&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://xsc062.netlify.app/20250819/</guid>
            <title>log 数据结构的一些题</title>
            <link>https://xsc062.netlify.app/20250819/</link>
            <category>线段树</category>
            <pubDate>Tue, 19 Aug 2025 09:44:25 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;线段树、树状数组、倍增、分治（朴素分治 / CDQ / 整体二分）、平衡树、字典树、笛卡尔树&lt;/p&gt;
&lt;p&gt;多乎哉？不多也。&lt;/p&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;
&lt;hr /&gt;
&lt;p&gt;题目来源：&lt;/p&gt;
&lt;ol type=&#34;1&#34;&gt;
&lt;li&gt;llsw’s pdf&lt;/li&gt;
&lt;li&gt;洛谷文章广场题解区搜索对应算法&lt;/li&gt;
&lt;li&gt;自己以前的一些零散题解&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;找了一些有数据结构方面思维难点的题，实现难度通常不会很大，也有少许粑粑夹杂其中&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;code&gt;#&lt;/code&gt; 是缺题解，&lt;code&gt;*&lt;/code&gt; 是缺代码&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;线段树&#34;&gt;线段树&lt;/h2&gt;
&lt;h3 id=&#34;维护特殊信息&#34;&gt;维护特殊信息&lt;/h3&gt;
&lt;h4 id=&#34;金鱼草-curtains区间覆盖信息&#34;&gt;金鱼草 / Curtains（区间覆盖信息）&lt;/h4&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P11536&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P11536&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定 &lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt; 个区间 &lt;span class=&#34;math inline&#34;&gt;\([l,r]\)&lt;/span&gt;，给出 &lt;span class=&#34;math inline&#34;&gt;\(q\)&lt;/span&gt; 个询问，每次询问 &lt;span class=&#34;math inline&#34;&gt;\([L,R]\)&lt;/span&gt; 是否能被表示为若干 &lt;span class=&#34;math inline&#34;&gt;\([l,r]\)&lt;/span&gt; 的并集。注意不能覆盖到 &lt;span class=&#34;math inline&#34;&gt;\([L,R]\)&lt;/span&gt; 之外的点。&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(n,q\le 5\times 10^5,|V|\le 10^9\)&lt;/span&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;题目所求等价于 check 满足 &lt;span class=&#34;math inline&#34;&gt;\(l\ge L\land r\le R\)&lt;/span&gt; 的所有区间是否能够覆盖 &lt;span class=&#34;math inline&#34;&gt;\([L,R]\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;这个很简单，需要区间修改的做法就不提了。可以想一下有没有只需要单点修改的做法&lt;/li&gt;
&lt;li&gt;&lt;p&gt;发现权值线段树可以维护「一段连续左端点对应区间的并」是否是连续的：&lt;/p&gt;
维护位于区间内的左端点最后一个覆盖到的点 &lt;span class=&#34;math inline&#34;&gt;\(rv\)&lt;/span&gt;（可以在区间外；发现从区间左端点到 &lt;span class=&#34;math inline&#34;&gt;\(rv\)&lt;/span&gt; 会被连续覆盖），&lt;strong&gt;区间内&lt;/strong&gt;最后一个没有被覆盖到的点 &lt;span class=&#34;math inline&#34;&gt;\(p\)&lt;/span&gt;，和表示区间是否能被完整覆盖的标记 flag。pushup 是容易的。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;容易发现如果我们在树上询问 &lt;span class=&#34;math inline&#34;&gt;\([L,R]\)&lt;/span&gt; 中所有左端点的 flag，无法保证参与覆盖的 &lt;span class=&#34;math inline&#34;&gt;\(r\le R\)&lt;/span&gt;。故离线下来扫描线即可。&lt;/p&gt;
&lt;p&gt;实际上由于未知原因跑得很可能不如区间修改的方法快 TAT&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int maxn = 5e5 + 5;
struct _ &amp;#123;
    bool flag;
    int l, r, rv, p;
&amp;#125; t[maxn &amp;lt;&amp;lt; 2];
#define lt (p &amp;lt;&amp;lt; 1)
#define rt (lt | 1)
void pushup(int p) &amp;#123;
    t[p].rv = std::max(t[lt].rv, t[rt].rv);
    if (!t[lt].flag) &amp;#123;
        t[p].flag = 0;
        if (!t[rt].flag &amp;amp;&amp;amp; t[lt].rv &amp;lt; t[rt].p)
            t[p].p = t[rt].p;
        else
            t[p].p = t[lt].p;
    &amp;#125;
    else if (!t[rt].flag &amp;amp;&amp;amp; t[lt].rv &amp;lt; t[rt].p)
        t[p].flag = 0, t[p].p = t[rt].p;
    else
        t[p].flag = 1, t[p].p = 0;
    return;
&amp;#125;
void bld(int p, int l, int r) &amp;#123;
    t[p].l = l, t[p].r = t[p].p = r;
    if (l == r)
        return;
    int mid = (l + r) &amp;gt;&amp;gt; 1;
    bld(lt, l, mid), bld(rt, mid + 1, r);
    return;
&amp;#125;
void add(int p, int x, int v) &amp;#123;
    if(t[p].l == t[p].r) &amp;#123;
        t[p].flag = 1, t[p].p = 0;
        t[p].rv = std::max(t[p].rv, v);
        return;
    &amp;#125;
    int mid = (t[p].l + t[p].r) &amp;gt;&amp;gt; 1;
    if (x &amp;lt;= mid)
        add(lt, x, v);
    else
        add(rt, x, v);
    pushup(p);
    return;
&amp;#125;
_ ask(int p, int l, int r) &amp;#123;
    if (l &amp;lt;= t[p].l &amp;amp;&amp;amp; t[p].r &amp;lt;= r)
        return t[p];
    int mid = (t[p].l + t[p].r) &amp;gt;&amp;gt; 1;
    if (r &amp;lt;= mid)
        return ask(lt, l, r);
    if (l &amp;gt; mid)
        return ask(rt, l, r);
    auto ls(ask(lt, l, r)), rs(ask(rt, l, r));
    if (!ls.flag) &amp;#123;
        if (!rs.flag &amp;amp;&amp;amp; ls.rv &amp;lt; rs.p)
            ls.p = rs.p;
    &amp;#125;
    else if (!rs.flag &amp;amp;&amp;amp; ls.rv &amp;lt; rs.p)
        ls.flag = 0, ls.p = rs.p;
    ls.rv = std::max(ls.rv, rs.rv);
    return ls;
&amp;#125;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#endif
    int n, m, q;
    std::cin &amp;gt;&amp;gt; m &amp;gt;&amp;gt; n &amp;gt;&amp;gt; q;
    bld(1, 1, m);
    std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; t(m + 1);
    for (int i = 1, l, r; i &amp;lt;= n; ++i) &amp;#123;
        std::cin &amp;gt;&amp;gt; l &amp;gt;&amp;gt; r;
        t[r].push_back(l);
    &amp;#125;
    std::vector&amp;lt;int&amp;gt; res(q + 1);
    std::vector&amp;lt;std::vector&amp;lt;std::pair&amp;lt;int, int&amp;gt; &amp;gt; &amp;gt; tq(m + 1);
    for (int i = 1, l, r; i &amp;lt;= q; ++i) &amp;#123;
        std::cin &amp;gt;&amp;gt; l &amp;gt;&amp;gt; r;
        tq[r].emplace_back(l, i);
    &amp;#125;
    for (int i = 1; i &amp;lt;= m; ++i) &amp;#123;
        for (auto l : t[i])
            add(1, l, i);
        for (auto [l, id] : tq[i])
            res[id] = ask(1, l, i).flag;
    &amp;#125;
    for (int i = 1; i &amp;lt;= q; ++i)
        std::cout &amp;lt;&amp;lt; (res[i] ? &amp;quot;YES&amp;quot; : &amp;quot;NO&amp;quot;) &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h4 id=&#34;题日-zapatak哈希&#34;&gt;# 题日 Zapatak（哈希）&lt;/h4&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P11262&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P11262&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&#34;简单数据结构带一点递推性质&#34;&gt;简单数据结构（带一点递推性质）&lt;/h4&gt;
&lt;p&gt;&lt;a href=&#34;https://pjudge.ac/problem/21636&#34; class=&#34;uri&#34;&gt;https://pjudge.ac/problem/21636&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定初始为空的多重集 &lt;span class=&#34;math inline&#34;&gt;\(p\)&lt;/span&gt;, &lt;span class=&#34;math inline&#34;&gt;\(q\)&lt;/span&gt;，这两个多重集中的元素都有 &lt;span class=&#34;math inline&#34;&gt;\(a,b\)&lt;/span&gt; 两种属性。需要需要维护 &lt;span class=&#34;math inline&#34;&gt;\(p\)&lt;/span&gt; 和 &lt;span class=&#34;math inline&#34;&gt;\(q\)&lt;/span&gt; 的加点和删点操作，询问 &lt;span class=&#34;math inline&#34;&gt;\(\forall \,i\in p,j\in q\)&lt;/span&gt;，&lt;span class=&#34;math inline&#34;&gt;\(\max(i_x + j_x, i_y + j_y)\)&lt;/span&gt; 的最小值。&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(m\le 10^6,V\le 10^9\)&lt;/span&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;考虑&lt;strong&gt;对不等式恒等变形，转化为偏序问题&lt;/strong&gt;。若 &lt;span class=&#34;math inline&#34;&gt;\(a_{i,0}+b_{j,0}\ge a_{i,1}+b_{j,1}\)&lt;/span&gt;，则 &lt;span class=&#34;math inline&#34;&gt;\(a_{i,0}-a_{i,1}\ge b_{j,1}-b_{j,0}\)&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;把 &lt;span class=&#34;math inline&#34;&gt;\(a\)&lt;/span&gt; 按照 &lt;span class=&#34;math inline&#34;&gt;\(a_{i,0}-a_{i,1}\)&lt;/span&gt; 排序、把 &lt;span class=&#34;math inline&#34;&gt;\(b\)&lt;/span&gt; 按照 &lt;span class=&#34;math inline&#34;&gt;\(b_{j,1}-b_{j,0}\)&lt;/span&gt; 排序。&lt;/p&gt;
&lt;p&gt;要求某个时刻的答案，需要对于每一个 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 找到最小的 &lt;span class=&#34;math inline&#34;&gt;\(b_{j,0}\)&lt;/span&gt;，使得 &lt;span class=&#34;math inline&#34;&gt;\(b_{j,1}-b_{j,0}\)&lt;/span&gt; 在 &lt;span class=&#34;math inline&#34;&gt;\([-\infty, a_{i,0}-a_{i,1}]\)&lt;/span&gt; 中，同时找到最小的 &lt;span class=&#34;math inline&#34;&gt;\(b_{j,1}\)&lt;/span&gt;，使得 &lt;span class=&#34;math inline&#34;&gt;\(b_{j,1}-b_{j,0}\)&lt;/span&gt; 在 &lt;span class=&#34;math inline&#34;&gt;\([a_{i, 0}-a_{i,1},+\infty]\)&lt;/span&gt; 中。&lt;/p&gt;
&lt;p&gt;这个带有一点递推的性质，在线段树 pushup 的时候，用左边的 &lt;span class=&#34;math inline&#34;&gt;\(b_{j,0}\)&lt;/span&gt; 结合右边的答案得到父亲的答案。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;听说我之前赛时切了这题？怎么没印象。llsw 讲题的时候说要离线，但是没想到离线做法 orz&lt;/em&gt;&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int inf = 2e9 + 1;
struct _ &amp;#123; long long aa, ab, ba, bb, u; int l, r, id; &amp;#125;;
std::vector&amp;lt;_&amp;gt; t(1);
std::vector&amp;lt;std::multiset&amp;lt;long long&amp;gt; &amp;gt; aa(1), ab(1), ba(1), bb(1);
int tot, cnt;
#define lt t[p].l
#define rt t[p].r
void pushup(int p) &amp;#123;
    t[p].aa = t[p].ab = t[p].ba = t[p].bb = t[p].u = inf;
    if (lt) &amp;#123;
        t[p].u = t[lt].u;
        t[p].aa = t[lt].aa, t[p].ab = t[lt].ab, t[p].ba = t[lt].ba, t[p].bb = t[lt].bb;
    &amp;#125;
    if (rt) &amp;#123;
        t[p].u = std::min(t[p].u, t[rt].u);
        t[p].aa = std::min(t[p].aa, t[rt].aa);
        t[p].ab = std::min(t[p].ab, t[rt].ab);
        t[p].ba = std::min(t[p].ba, t[rt].ba);
        t[p].bb = std::min(t[p].bb, t[rt].bb);
    &amp;#125;
    if (lt &amp;amp;&amp;amp; rt)
        t[p].u = std::min(&amp;#123; t[p].u, t[lt].ba + t[rt].aa, t[lt].ab + t[rt].bb &amp;#125;);
    return;
&amp;#125;
int adda(int p, long long l, long long r, int x, int a, int b) &amp;#123;
    if (!p)
        p = ++tot, t.emplace_back(), t[p].aa = t[p].ab = t[p].ba = t[p].bb = t[p].u = inf;
    if (l == r) &amp;#123;
        if (!t[p].id)
            t[p].id = ++cnt, aa.emplace_back(), ab.emplace_back(), ba.emplace_back(), bb.emplace_back();
        int id = t[p].id;
        aa[id].insert(a), ab[id].insert(b);
        t[p].aa = *aa[id].begin(), t[p].ab = *ab[id].begin();
        if (!aa[id].empty() &amp;amp;&amp;amp; !ba[id].empty())
            t[p].u = std::min(*aa[id].begin() + *ba[id].begin(), *ab[id].begin() + *bb[id].begin());
        else
            t[p].u = inf;
        return p;
    &amp;#125;
    long long mid = (l + r) &amp;gt;&amp;gt; 1;
    if (x &amp;lt;= mid) &amp;#123;
        auto s(adda(lt, l, mid, x, a, b));
        lt = s;
    &amp;#125;
    else &amp;#123;
        auto s(adda(rt, mid + 1, r, x, a, b));
        rt = s;
    &amp;#125;
    pushup(p);
    return p;
&amp;#125;
int addb(int p, long long l, long long r, int x, int a, int b) &amp;#123;
    if (!p)
        p = ++tot, t.emplace_back(), t[p].aa = t[p].ab = t[p].ba = t[p].bb = t[p].u = inf;
    if (l == r) &amp;#123;
        if (!t[p].id)
            t[p].id = ++cnt, aa.emplace_back(), ab.emplace_back(), ba.emplace_back(), bb.emplace_back();
        int id = t[p].id;
        ba[id].insert(a), bb[id].insert(b);
        t[p].ba = *ba[id].begin(), t[p].bb = *bb[id].begin();
        if (!aa[id].empty() &amp;amp;&amp;amp; !ba[id].empty())
            t[p].u = std::min(*aa[id].begin() + *ba[id].begin(), *ab[id].begin() + *bb[id].begin());
        else
            t[p].u = inf;
        return p;
    &amp;#125;
    long long mid = (l + r) &amp;gt;&amp;gt; 1;
    if (x &amp;lt;= mid) &amp;#123;
        auto s(addb(lt, l, mid, x, a, b));
        lt = s;
    &amp;#125;
    else &amp;#123;
        auto s(addb(rt, mid + 1, r, x, a, b));
        rt = s;
    &amp;#125;
    pushup(p);
    return p;
&amp;#125;
void dela(int p, long long l, long long r, int x, int a, int b) &amp;#123;
    if (l == r) &amp;#123;
        int id = t[p].id;
        aa[id].erase(aa[id].find(a)), ab[id].erase(ab[id].find(b));
        t[p].aa = (aa[id].empty() ? inf : *aa[id].begin());
        t[p].ab = (ab[id].empty() ? inf : *ab[id].begin());
        if (!aa[id].empty() &amp;amp;&amp;amp; !ba[id].empty())
            t[p].u = std::min(*aa[id].begin() + *ba[id].begin(), *ab[id].begin() + *bb[id].begin());
        else
            t[p].u = inf;
        return;
    &amp;#125;
    long long mid = (l + r) &amp;gt;&amp;gt; 1;
    if (x &amp;lt;= mid)
        dela(lt, l, mid, x, a, b);
    else
        dela(rt, mid + 1, r, x, a, b);
    pushup(p);
    return;
&amp;#125;
void delb(int p, long long l, long long r, int x, int a, int b) &amp;#123;
    if (l == r) &amp;#123;
        int id = t[p].id;
        ba[id].erase(ba[id].find(a)), bb[id].erase(bb[id].find(b));
        t[p].ba = (ba[id].empty() ? inf : *ba[id].begin());
        t[p].bb = (bb[id].empty() ? inf : *bb[id].begin());
        if (!aa[id].empty() &amp;amp;&amp;amp; !ba[id].empty())
            t[p].u = std::min(*aa[id].begin() + *ba[id].begin(), *ab[id].begin() + *bb[id].begin());
        else
            t[p].u = inf;
        return;
    &amp;#125;
    long long mid = (l + r) &amp;gt;&amp;gt; 1;
    if (x &amp;lt;= mid)
        delb(lt, l, mid, x, a, b);
    else
        delb(rt, mid + 1, r, x, a, b);
    pushup(p);
    return;
&amp;#125;
#undef lt
#undef rt
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
    std::freopen(&amp;quot;set.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;set.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#endif
    int q, rt = 0;
    std::cin &amp;gt;&amp;gt; q;
    for (int i = 1; i &amp;lt;= q; ++i) &amp;#123;
        int op, d, a, b;
        std::cin &amp;gt;&amp;gt; op &amp;gt;&amp;gt; d &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b;
        if (op == 0 &amp;amp;&amp;amp; d == 0)
            dela(rt, -inf, inf, a - b, a, b);
        else if (op == 0)
            delb(rt, -inf, inf, b - a, a, b);
        else if (d == 0)
            rt = adda(rt, -inf, inf, a - b, a, b);
        else
            rt = addb(rt, -inf, inf, b - a, a, b);
        std::cout &amp;lt;&amp;lt; (t[1].u == inf ? -1 : t[1].u) &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    &amp;#125;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h4 id=&#34;命运利用线段树的分治结构递推&#34;&gt;# 命运（利用线段树的分治结构递推）&lt;/h4&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P6773&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P6773&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&#34;对数据结构的爱维护函数&#34;&gt;* 对数据结构的爱（维护函数）&lt;/h4&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P5609&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P5609&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定长度为 &lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt; 的数组 &lt;span class=&#34;math inline&#34;&gt;\(a\)&lt;/span&gt; 和模数 &lt;span class=&#34;math inline&#34;&gt;\(p\)&lt;/span&gt;（&lt;span class=&#34;math inline&#34;&gt;\(a_i\)&lt;/span&gt; 初始可能比 &lt;span class=&#34;math inline&#34;&gt;\(p\)&lt;/span&gt; 大很多，还有可能为负），给定 &lt;span class=&#34;math inline&#34;&gt;\(m\)&lt;/span&gt; 次询问，每次问区间 &lt;span class=&#34;math inline&#34;&gt;\([l,r]\)&lt;/span&gt;，进行这样的操作：&lt;/p&gt;
&lt;p&gt;初始 &lt;span class=&#34;math inline&#34;&gt;\(sum=0\)&lt;/span&gt;，从 &lt;span class=&#34;math inline&#34;&gt;\(l\)&lt;/span&gt; 到 &lt;span class=&#34;math inline&#34;&gt;\(r\)&lt;/span&gt;，依次令 &lt;span class=&#34;math inline&#34;&gt;\(sum\gets sum+a_i\)&lt;/span&gt;，当且仅当 &lt;span class=&#34;math inline&#34;&gt;\(sum\ge p\)&lt;/span&gt; 时令 &lt;span class=&#34;math inline&#34;&gt;\(sum\gets sum-p\)&lt;/span&gt;（注意这不是取模，减完之后还是可能 &lt;span class=&#34;math inline&#34;&gt;\(\ge p\)&lt;/span&gt;）。&lt;/p&gt;
&lt;p&gt;问最终 &lt;span class=&#34;math inline&#34;&gt;\(sum\)&lt;/span&gt; 的值。&lt;span class=&#34;math inline&#34;&gt;\(n\le 10^6,m\le 2\times 10^5\)&lt;/span&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;考虑线段树维护函数。定义 &lt;span class=&#34;math inline&#34;&gt;\(f(x)\)&lt;/span&gt; 表示区间上想要减去 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 次 &lt;span class=&#34;math inline&#34;&gt;\(p\)&lt;/span&gt; 需要的最小初始值（这样才能让定义域和区间长有关），查询时直接二分即可；考虑初始化时如何合并。&lt;/p&gt;
&lt;p&gt;首先思考较为暴力的做法，对于左侧点 &lt;span class=&#34;math inline&#34;&gt;\(a\)&lt;/span&gt; 和右侧点 &lt;span class=&#34;math inline&#34;&gt;\(b\)&lt;/span&gt;，若 &lt;span class=&#34;math inline&#34;&gt;\(f(a+1)-1+s_l-a\cdot p\ge f(b)\)&lt;/span&gt;，也即可以减去 &lt;span class=&#34;math inline&#34;&gt;\(a+b\)&lt;/span&gt; 次，就可以用 &lt;span class=&#34;math inline&#34;&gt;\(\max(f(a),f(b)-s_l+a\cdot p)\)&lt;/span&gt; 来更新 &lt;span class=&#34;math inline&#34;&gt;\(f(a+b)\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;发现 &lt;span class=&#34;math inline&#34;&gt;\((a,b)\)&lt;/span&gt; 的贡献一定小于 &lt;span class=&#34;math inline&#34;&gt;\((a+1,b-1)\)&lt;/span&gt; 的贡献；具体地，发现 &lt;span class=&#34;math inline&#34;&gt;\(f(x+1)-f(x)\ge p\)&lt;/span&gt; 后就很显然了。采用双指针，优先移动 &lt;span class=&#34;math inline&#34;&gt;\(b\)&lt;/span&gt;，就能把最短区间扫一遍。&lt;/p&gt;
&lt;details&gt;
&lt;p&gt;&lt;summary&gt;关于线段树维护函数&lt;/summary&gt;&lt;/p&gt;
&lt;p&gt;维护一个函数，形如 &lt;span class=&#34;math inline&#34;&gt;\(f_{[l,r]}(x)\)&lt;/span&gt; 表示在 &lt;span class=&#34;math inline&#34;&gt;\([l,r]\)&lt;/span&gt; 区间上，&lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 的一个映射&lt;/p&gt;
&lt;p&gt;如果相邻区间的函数可以用某种方式合并，就可以用线段树来维护&lt;/p&gt;
&lt;p&gt;把树建在值域上，就可以在节点内把这段区间每个点对应的函数值存下来。一般来说是静态的，因为这是一个类前缀和的形式，没办法修改&lt;/p&gt;
&lt;p&gt;每个点的点值数组会在当前层被扫一遍，上一层被扫一遍，如果合并能够做到线性，总复杂度就是单 &lt;span class=&#34;math inline&#34;&gt;\(\log\)&lt;/span&gt; 的。&lt;/p&gt;
&lt;p&gt;实际情形下函数本身可能很隐秘、很抽象，怎么优化到线性合并也不太好想&lt;/p&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h4 id=&#34;compounds模意义下问题&#34;&gt;* COmPoUNdS（模意义下问题）&lt;/h4&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P12389&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P12389&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定常数模数，维护模意义下的区间加、区间哈希。&lt;span class=&#34;math inline&#34;&gt;\(n\le 10^6\)&lt;/span&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;线段树哈希是可以维护区间加的&lt;/strong&gt;，但是没办法维护区间取模&lt;/p&gt;
&lt;p&gt;类似 &lt;a href=&#34;/20250816/#e---subarray-sum-divisibility&#34;&gt;ABC419E&lt;/a&gt; 里面用到的，模意义下序列全等可以转化成差分全等，区间修改就可以简化成单点修改了&lt;/p&gt;
&lt;p&gt;额外判一下开头的元素（维护原数组或者是差分数组之和）是否相等就可以了&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&#34;改进代码模意义下问题&#34;&gt;* 改进代码（模意义下问题）&lt;/h4&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P4635&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P4635&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定序列 &lt;span class=&#34;math inline&#34;&gt;\(a_{1\sim n}\)&lt;/span&gt; 和常数 &lt;span class=&#34;math inline&#34;&gt;\(p\)&lt;/span&gt;，维护:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;修改：模 &lt;span class=&#34;math inline&#34;&gt;\(p\)&lt;/span&gt; 意义下区间加；&lt;/li&gt;
&lt;li&gt;询问：区间中 &lt;span class=&#34;math inline&#34;&gt;\(\sum\limits_{i=l}^{r-1}[a_i&amp;gt;a_{i+1}]\)&lt;/span&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(n\le 10^5,p\le 10^6\)&lt;/span&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;询问也和模意义差分有关系，假如 &lt;span class=&#34;math inline&#34;&gt;\(s\)&lt;/span&gt; 为当前差分数组前缀和模 &lt;span class=&#34;math inline&#34;&gt;\(p\)&lt;/span&gt; 的值（也就是原数），发现&lt;strong&gt;前一个数 &lt;span class=&#34;math inline&#34;&gt;\(&amp;gt;\)&lt;/span&gt; 后一个数当且仅当 &lt;span class=&#34;math inline&#34;&gt;\(s\)&lt;/span&gt; 加爆了&lt;/strong&gt;。维护原数组用来确定 &lt;span class=&#34;math inline&#34;&gt;\(s\)&lt;/span&gt; 的初值。再维护区间内差分数组之和（不取模），&lt;strong&gt;在这个和里有多少个 &lt;span class=&#34;math inline&#34;&gt;\(p\)&lt;/span&gt; 就会爆多少次&lt;/strong&gt;。&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&#34;黑白树很新的东西&#34;&gt;黑白树（很新的东西）&lt;/h4&gt;
&lt;p&gt;&lt;a href=&#34;http://222.180.160.110:61235/problem/46907&#34; class=&#34;uri&#34;&gt;http://222.180.160.110:61235/problem/46907&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;以楼房重建为代表的-log2-一类前缀信息维护&#34;&gt;以楼房重建为代表的 &lt;span class=&#34;math inline&#34;&gt;\(\log^2\)&lt;/span&gt; 一类前缀信息维护&lt;/h3&gt;
&lt;p&gt;特点：pushup 时需要先获得一边的信息，在另一边进行线段树上二分，单次操作是 &lt;span class=&#34;math inline&#34;&gt;\(O(\log^2)\)&lt;/span&gt; 的&lt;/p&gt;
&lt;p&gt;本质是一类具有&lt;strong&gt;单调性&lt;/strong&gt;的前 / 后缀信息，&lt;strong&gt;区间对全局的贡献&lt;/strong&gt;和&lt;strong&gt;区间外的信息&lt;/strong&gt;有关，故不能直接维护对全局的贡献，只能维护区间内的答案。但由于两个子区间答案可以合并出大区间答案（通过线段树上二分得到需要的信息），所以只需要逐层向上合并就可以得到全局答案&lt;/p&gt;
&lt;p&gt;一个名字是『线段树维护前缀信息』，感觉不很精确。log 方线段树又是什么鬼名字？兔队线段树又是谁起的（upd：疑似皎月半洒花）？更多还是叫的楼房重建线段树吧&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&#34;楼房重建&#34;&gt;楼房重建&lt;/h4&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P4198&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P4198&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定 &lt;span class=&#34;math inline&#34;&gt;\(a_{1\sim n}\)&lt;/span&gt;，维护 &lt;span class=&#34;math inline&#34;&gt;\(q\)&lt;/span&gt; 次操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单点修改；&lt;/li&gt;
&lt;li&gt;查询 &lt;span class=&#34;math inline&#34;&gt;\(\dfrac{a_i}i\)&lt;/span&gt; 的前缀最大值序列长度。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(n,q\le 10^5\)&lt;/span&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Fractures 说当年（初一）是他力荐 gm 给我们拉这个题的。dashena！&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;线段树维护单调栈，或者说前缀最值，维护方式过于经典，使得『楼房重建』成为该 trick 称呼之一&lt;/li&gt;
&lt;li&gt;&lt;p&gt;考虑 pushup。保留左边整段区间，对于左区间序列末的元素 &lt;code&gt;l.rv&lt;/code&gt;，我们在右区间内找到第一个大于之的元素 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt;，从它开始的序列就是答案。&lt;/p&gt;
反证法易得 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 一定在右区间答案序列内：若 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 不在答案序列内，则右区间内存在一个 &lt;span class=&#34;math inline&#34;&gt;\(&amp;gt;x\)&lt;/span&gt; 且位于 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 之前的元素，那么 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 就不是第一个 &lt;code&gt;&amp;gt; l.rv&lt;/code&gt; 的元素，矛盾。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;故在右区间中二分能够接上去的区间长度，加起来即可。&lt;/p&gt;
&lt;p&gt;题目只要求总区间答案，故不需要查询。动态开点可能需要小心处理一下。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int maxn = 1e5 + 5;
struct &amp;#123;
    int l, r, u;
    double lv, rv, mv;
&amp;#125; t[maxn &amp;lt;&amp;lt; 2];
int tot;
#define lt t[p].l
#define rt t[p].r
int askt(int p, int l, int r, double v) &amp;#123;
    if (l == r)
        return t[p].u;
    int mid = (l + r) &amp;gt;&amp;gt; 1;
    if (lt &amp;amp;&amp;amp; t[p].mv &amp;gt; v)
        return t[p].u - t[lt].u + askt(lt, l, mid, v);
    return askt(rt, mid + 1, r, v);
&amp;#125;
void pushup(int p, int l, int r) &amp;#123;
    t[p].mv = t[lt].rv;
    if (lt &amp;amp;&amp;amp; rt) &amp;#123;
        t[p].lv = t[lt].lv;
        t[p].rv = std::max(t[lt].rv, t[rt].rv);
        if (t[lt].rv &amp;lt; t[rt].lv)
            t[p].u = t[lt].u + t[rt].u;
        else if (t[lt].rv &amp;gt;= t[rt].rv)
            t[p].u = t[lt].u;
        else &amp;#123;
            int mid = (l + r) &amp;gt;&amp;gt; 1;
            t[p].u = t[lt].u + askt(rt, mid + 1, r, t[lt].rv);
        &amp;#125;
    &amp;#125;
    else &amp;#123;
        t[p].u = t[lt + rt].u;
        t[p].lv = t[lt + rt].lv, t[p].rv = t[lt + rt].rv;
    &amp;#125;
    return;
&amp;#125;
void upd(int &amp;amp;p, int l, int r, int x, double v) &amp;#123;
    if (!p)
        p = ++tot;
    if (l == r) &amp;#123;
        t[p].lv = t[p].rv = v, t[p].u = 1;
        return;
    &amp;#125;
    int mid = (l + r) &amp;gt;&amp;gt; 1;
    if (x &amp;lt;= mid)
        upd(lt, l, mid, x, v);
    else
        upd(rt, mid + 1, r, x, v);
    pushup(p, l, r);
    return;
&amp;#125;
#undef lt
#undef rt
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;P4198_2.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#endif
    int n, m, rt = 0;
    std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
    std::vector&amp;lt;double&amp;gt; a(n + 1);
    for (int x; m--; ) &amp;#123;
        double y;
        std::cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; y;
        a[x] = y / x;
        upd(rt, 1, n, x, y / x);
        std::cout &amp;lt;&amp;lt; t[1].u &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    &amp;#125;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h4 id=&#34;二叉搜索树&#34;&gt;二叉搜索树&lt;/h4&gt;
&lt;p&gt;&lt;a href=&#34;https://pjudge.ac/problem/21889&#34; class=&#34;uri&#34;&gt;https://pjudge.ac/problem/21889&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定一个大小为 &lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt; 的树，树上每个元素是一个 BST，你需要维护 &lt;span class=&#34;math inline&#34;&gt;\(q\)&lt;/span&gt; 次操作：&lt;/p&gt;
&lt;ol type=&#34;1&#34;&gt;
&lt;li&gt;对于树上的一条路径 &lt;span class=&#34;math inline&#34;&gt;\((u,v)\)&lt;/span&gt;，在经过的所有节点上的 BST 插入 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt;，保证任意时刻 BST 中无相同值&lt;/li&gt;
&lt;li&gt;在点 &lt;span class=&#34;math inline&#34;&gt;\(u\)&lt;/span&gt; 查找 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt;，如果 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 存在则返回其到 BST 根的元素和，否则返回查找时最远走到的那个点，到 BST 根的元素和。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(n,q\le 2\times 10^5\)&lt;/span&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;考虑链上问题。差分，把更新 &lt;span class=&#34;math inline&#34;&gt;\([l, r]\)&lt;/span&gt; 看作在差分数组 &lt;span class=&#34;math inline&#34;&gt;\(l\)&lt;/span&gt; 处插入，在 &lt;span class=&#34;math inline&#34;&gt;\(r+1\)&lt;/span&gt; 处删除，离线下来再从左到右扫一遍操作就能更新。&lt;/li&gt;
&lt;li&gt;考虑查询。&lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 树上存在过的所有元素是已知的，考虑如何基于此获取 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 树上 &lt;span class=&#34;math inline&#34;&gt;\(t_0\)&lt;/span&gt; 时刻，&lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 的所有祖先。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;对于比 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 大的元素，考虑祖先 &lt;span class=&#34;math inline&#34;&gt;\(p_a\)&lt;/span&gt; 和非祖先 &lt;span class=&#34;math inline&#34;&gt;\(p\)&lt;/span&gt; 的区别：&lt;/p&gt;
&lt;p&gt;根据 BST 的性质易得，对于最低的右侧祖先 &lt;span class=&#34;math inline&#34;&gt;\({p_a}_0\)&lt;/span&gt;，其是 &lt;span class=&#34;math inline&#34;&gt;\(\ge x\)&lt;/span&gt; 的最小的元素（加入时刻 &lt;span class=&#34;math inline&#34;&gt;\(t_a&amp;lt;t_0\)&lt;/span&gt;）；&lt;/p&gt;
同理可以找到 &lt;span class=&#34;math inline&#34;&gt;\({p_a}_0\)&lt;/span&gt; 右侧最低的祖先（其左侧的祖先显然也在 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 左侧），该祖先满足 &lt;span class=&#34;math inline&#34;&gt;\(t&amp;lt;t_a\)&lt;/span&gt;。从左右两边分别得到 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 的所有祖先。容易证明该过程对于不在树上的 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 也是正确的。&lt;/li&gt;
&lt;li&gt;具体地，需要能够求出 &lt;span class=&#34;math inline&#34;&gt;\(\ge x\)&lt;/span&gt; 的元素中，以 &lt;span class=&#34;math inline&#34;&gt;\(t_0\)&lt;/span&gt; 为起点的前缀最小值序列的区间和。线段树维护单调栈容易解决不带 &lt;span class=&#34;math inline&#34;&gt;\(t_0\)&lt;/span&gt; 限制的答案；再次利用性质就能满足限制。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;对于树的情况，把差分放到树上，线段树合并即可。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int lim = 2e5;
const int maxn = 2e7 + 5;
const int inf = 0x3f3f3f3f;
struct &amp;#123;
    int l, r, rv;
    long long u;
&amp;#125; t[maxn];
std::vector&amp;lt;int&amp;gt; tr;
#define lt t[p].l
#define rt t[p].r
int newnode(void) &amp;#123;
    static int tot = 0;
    if (tr.empty())
        return ++tot;
    auto p(tr.back());
    t[p].l = t[p].r = 0;
    tr.pop_back();
    return p;
&amp;#125;
long long askv(int p, int l, int r, int v) &amp;#123;
    if (l == r)
        return t[p].rv &amp;lt; v ? t[p].u : 0;
    int mid = (l + r) &amp;gt;&amp;gt; 1;
    if (v &amp;gt; t[lt].rv)
        return t[p].u - t[lt].u + askv(lt, l, mid, v);
    return askv(rt, mid + 1, r, v);
&amp;#125;
void pushup(int p, int l, int r) &amp;#123;
    t[p].rv = std::min(t[lt].rv, t[rt].rv);
    int mid = (l + r) &amp;gt;&amp;gt; 1;
    t[p].u = t[lt].u + askv(rt, mid + 1, r, t[lt].rv);
    return;
&amp;#125;
void upd(int &amp;amp;p, int l, int r, int x, int v, int u) &amp;#123;
    if (!p)
        p = newnode();
    if (l == r) &amp;#123;
        t[p].rv = v, t[p].u = u;
        return;
    &amp;#125;
    int mid = (l + r) &amp;gt;&amp;gt; 1;
    if (x &amp;lt;= mid)
        upd(lt, l, mid, x, v, u);
    else
        upd(rt, mid + 1, r, x, v, u);
    pushup(p, l, r);
    return;
&amp;#125;
void merge(int &amp;amp;p, int q, int l, int r) &amp;#123;
    if (!p || !q) &amp;#123;
        p += q;
        return;
    &amp;#125;
    if (l == r) &amp;#123;
        t[p].rv = std::min(t[p].rv, t[q].rv);
        t[p].u = std::max(t[p].u, t[q].u);
        return;
    &amp;#125;
    int mid = (l + r) &amp;gt;&amp;gt; 1;
    merge(t[p].l, t[q].l, l, mid), merge(t[p].r, t[q].r, mid + 1, r);
    pushup(p, l, r), tr.push_back(q);
    return;
&amp;#125;
int qv = inf;
long long ask(int p, int l, int r, int ql, int qr) &amp;#123;
    if (ql &amp;lt;= l &amp;amp;&amp;amp; r &amp;lt;= qr) &amp;#123;
        auto s(askv(p, l, r, qv));
        qv = std::min(qv, t[p].rv);
        return s;
    &amp;#125;
    int mid = (l + r) &amp;gt;&amp;gt; 1;
    long long res = 0ll;
    if (ql &amp;lt;= mid)
        res = ask(lt, l, mid, ql, qr);
    if (qr &amp;gt; mid)
        res += ask(rt, mid + 1, r, ql, qr);
    return res;
&amp;#125;
#undef lt
#undef rt
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;ex_problem4.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#endif
    int n, m;
    std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
    std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; g(n + 1);
    for (int i = 1, x, y; i &amp;lt; n; ++i) &amp;#123;
        std::cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; y;
        g[x].push_back(y), g[y].push_back(x);
    &amp;#125;
    std::vector&amp;lt;int&amp;gt; top(n + 1), fa(n + 1), siz(n + 1), son(n + 1), dep(n + 1);
    std::function&amp;lt;void(int, int)&amp;gt; DFS = [&amp;amp;](int x, int faa) &amp;#123;
        siz[x] = 1;
        for (auto i : g[x])
            if (i != faa) &amp;#123;
                fa[i] = x, dep[i] = dep[x] + 1;
                DFS(i, x), siz[x] += siz[i];
                if (siz[i] &amp;gt; siz[son[x]])
                    son[x] = i;
            &amp;#125;
        return;
    &amp;#125;;
    DFS(1, -1);
    DFS = [&amp;amp;](int x, int topp) &amp;#123;
        top[x] = topp;
        if (son[x])
            DFS(son[x], topp);
        for (auto i : g[x])
            if (i != fa[x] &amp;amp;&amp;amp; i != son[x])
                DFS(i, i);
        return;
    &amp;#125;;
    DFS(1, 1);
    auto getLCA = [&amp;amp;](int x, int y) &amp;#123;
        for (; top[x] != top[y]; x = fa[top[x]])
            if (dep[top[y]] &amp;gt; dep[top[x]])
                std::swap(x, y);
        return (dep[x] &amp;lt; dep[y] ? x : y);
    &amp;#125;;
    std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; d(n + 1);
    std::vector&amp;lt;std::vector&amp;lt;std::pair&amp;lt;int, int&amp;gt; &amp;gt; &amp;gt; u(n + 1);
    std::vector&amp;lt;std::vector&amp;lt;std::tuple&amp;lt;int, int, int&amp;gt; &amp;gt; &amp;gt; q(n + 1);
    int cnt = 0;
    for (int i = 1; i &amp;lt;= m; ++i) &amp;#123;
        int op;
        std::cin &amp;gt;&amp;gt; op;
        if (op == 0) &amp;#123;
            int x, v;
            std::cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; v;
            q[x].emplace_back(++cnt, i, v);
        &amp;#125; else &amp;#123;
            int x, y, v;
            std::cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; y &amp;gt;&amp;gt; v;
            int faa = getLCA(x, y);
            u[x].emplace_back(i, v), u[y].emplace_back(i, v);
            if (fa[faa])
                d[fa[faa]].emplace_back(v);
        &amp;#125;
    &amp;#125;
    std::vector&amp;lt;long long&amp;gt; res(cnt + 1);
    std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; rt(2, std::vector&amp;lt;int&amp;gt; (n + 1));
    t[0].rv = inf;
    DFS = [&amp;amp;](int x, int fa) &amp;#123;
        for (auto i : g[x])
            if (i != fa) &amp;#123;
                DFS(i, x);
                merge(rt[0][x], rt[0][i], 1, lim);
                merge(rt[1][x], rt[1][i], 1, lim);
            &amp;#125;
        for (auto [t, v] : u[x]) &amp;#123;
            upd(rt[0][x], 1, lim, v, t, v);
            upd(rt[1][x], 1, lim, lim - v + 1, t, v);
        &amp;#125;
        for (auto v : d[x]) &amp;#123;
            upd(rt[0][x], 1, lim, v, inf, 0);
            upd(rt[1][x], 1, lim, lim - v + 1, inf, 0);
        &amp;#125;
        for (auto [id, t, v] : q[x]) &amp;#123;
            qv = t, res[id] = ask(rt[0][x], 1, lim, v, lim);
            qv = t, res[id] += ask(rt[1][x], 1, lim, lim - v + 1, lim);
            qv = t, res[id] -= ask(rt[0][x], 1, lim, v, v);
        &amp;#125;
    &amp;#125;;
    DFS(1, -1);
    for (int i = 1; i &amp;lt;= cnt; ++i)
        std::cout &amp;lt;&amp;lt; res[i] &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h4 id=&#34;nastya-and-cbs&#34;&gt;Nastya and CBS&lt;/h4&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/CF1340F&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/CF1340F&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定长度为 &lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt; 的括号序列，由 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 种括号对（&lt;span class=&#34;math inline&#34;&gt;\(-i,i\)&lt;/span&gt; 表示第 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 种左、右括号）组成，你需要维护单点修改元素、区间查询是否为合法括号序列。&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(1\le k\le n\le 10^5,q\le 10^5\)&lt;/span&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;考虑不带修且允许 &lt;span class=&#34;math inline&#34;&gt;\(O(n)\)&lt;/span&gt; 询问的情景，经典题，扫一遍，用栈维护即可；&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(k=1\)&lt;/span&gt; 时是线段树经典题，可以类比这个经典题，从刻画合法的条件入手。&lt;/p&gt;
如果存在相邻且可以匹配的可以直接消掉，一直重复这样的操作，此时要么包含不能匹配的子串，如 &lt;code&gt;&amp;#123;[)&amp;#125;&lt;/code&gt;，要么是 &lt;code&gt;)]&amp;#125; (&amp;#123;[&amp;#123;&amp;#123;&lt;/code&gt; 的形式。&lt;/li&gt;
&lt;li&gt;考虑怎么 pushup，发现中间生成的一段 &lt;code&gt;([()])&lt;/code&gt; 必须完全匹配，消掉它们之后，大区间又变成 &lt;code&gt;)]&amp;#125; (&amp;#123;[&amp;#123;&amp;#123;&lt;/code&gt; 的形式。&lt;/li&gt;
&lt;li&gt;每次 pushup 要合并的区间很长，考虑怎么快速地做『消除相邻匹配括号』这一步。容易想到记录一段括号（例：&lt;code&gt;([&amp;#123;&lt;/code&gt;）及其对应反括号（例：&lt;code&gt;&amp;#125;])&lt;/code&gt;）的哈希值，check 是否相等，然后就可以不管它们了，并不是真的要删去。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;线段树不能维护每个前后缀的哈希值，但需要的只是在&lt;strong&gt;删除连续匹配括号后&lt;/strong&gt;长度为 &lt;span class=&#34;math inline&#34;&gt;\(len\)&lt;/span&gt; 的哈希值，可以线段树上二分。&lt;/p&gt;
这个过程有点困难，需要在询问的同时匹配、消除；但发现所谓消除就是对位相减，注意一下什么时候移位，还是好写的。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;询问看似不太可做，因为中途的答案不是线段树的节点；如果把询问看成一次修改，就可以用类似可持久化的方式实现。&lt;/p&gt;
&lt;p&gt;由于并不是真的要可持久化，询问新建的点可以重复利用。如果不重复利用，每次询问最多新建 &lt;span class=&#34;math inline&#34;&gt;\(O(\log n)\)&lt;/span&gt; 个点，空间复杂度 &lt;span class=&#34;math inline&#34;&gt;\(O(q\log n)\)&lt;/span&gt;，在 CF 上有点卡，也是能过的。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;p&gt;Hint：有卡 998244353 的 Hack，故可以用 1e9 + 7 当模数；WA on 7 是正确性有巨大问题，WA on 8 可能是 long long 没开完 / 数组开小了 / 哈希方向有问题 / 线段树上二分写挂了（通常是消括号消错了）。前人踩坑后人嘲笑。&lt;/p&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int mod = 1e9 + 7;
const int base = 1e5 + 3;
const int maxn = 7e5 + 5;
struct Node &amp;#123;
    bool flag;
    long long hr0, hl1;
    int l, r, lc, rc, ll, rl;
    Node&amp;amp; operator= (const Node &amp;amp;q) &amp;#123;
        flag = q.flag, hr0 = q.hr0, hl1 = q.hl1;
        l = q.l, r = q.r, ll = q.ll, rl = q.rl;
        return *this;
    &amp;#125;
    Node operator+ (const Node &amp;amp;q) const;
&amp;#125; t[maxn &amp;lt;&amp;lt; 2];
int tot;
int a[maxn];
long long bpow[maxn], inv[maxn];
long long askhl1(const Node &amp;amp;p, int k) &amp;#123;
    if (k == 0)
        return 0ll;
    if (k &amp;gt; p.ll)
        return -1ll;
    if (p.ll == k)
        return p.hl1;
    int ll = t[p.lc].ll, rl = t[p.lc].rl;
    if (ll &amp;gt;= k)
        return askhl1(t[p.lc], k);
    k -= ll, k += rl;
    auto hl1 = askhl1(t[p.rc], k);
    hl1 = ((hl1 + mod - t[p.lc].hr0) * inv[rl] % mod * bpow[ll] % mod + t[p.lc].hl1) % mod;
    return hl1;
&amp;#125;
long long askhr0(const Node &amp;amp;p, int k) &amp;#123;
    if (k == 0)
        return 0ll;
    if (k &amp;gt; p.rl)
        return -1ll;
    if (p.rl == k)
        return p.hr0;
    int rl = t[p.rc].rl, ll = t[p.rc].ll;
    if (rl &amp;gt;= k)
        return askhr0(t[p.rc], k);
    k -= rl, k += ll;
    auto hr0 = askhr0(t[p.lc], k);
    hr0 = ((hr0 + mod - t[p.rc].hl1) * inv[ll] % mod * bpow[rl] % mod + t[p.rc].hr0) % mod;
    return hr0;
&amp;#125;
Node Node::operator+ (const Node &amp;amp;q) const  &amp;#123;
    Node res;
    res.l = l, res.r = q.r;
    if (flag || q.flag)
        res.flag = 1;
    else &amp;#123;
        if (rl == q.ll) &amp;#123;
            if (hr0 == q.hl1) &amp;#123;
                res.flag = 0;
                res.ll = ll, res.rl = q.rl;
                res.hl1 = hl1, res.hr0 = q.hr0;
            &amp;#125;
            else
                res.flag = 1;
        &amp;#125;
        else if (rl &amp;lt; q.ll) &amp;#123;
            auto qhl1 = askhl1(q, rl);
            if (hr0 == qhl1) &amp;#123;
                res.flag = 0;
                res.ll = ll + q.ll - rl, res.rl = q.rl;
                res.hl1 = ((q.hl1 + mod - qhl1) % mod * inv[rl] % mod * bpow[ll] % mod + hl1) % mod;
                res.hr0 = q.hr0;
            &amp;#125;
            else
                res.flag = 1;
        &amp;#125;
        else &amp;#123;
            auto phr0 = askhr0(*this, q.ll);
            if (phr0 == q.hl1) &amp;#123;
                res.flag = 0;
                res.ll = ll, res.rl = rl - q.ll + q.rl;
                res.hl1 = hl1;
                res.hr0 = ((hr0 + mod - phr0) % mod * inv[q.ll] % mod * bpow[q.rl] % mod + q.hr0) % mod;
            &amp;#125;
            else
                res.flag = 1;
        &amp;#125;
    &amp;#125;
    return res;
&amp;#125;
void bld(int &amp;amp;p, int l, int r) &amp;#123;
    p = ++tot;
    if (l == r) &amp;#123;
        t[p].l = t[p].r = l;
        if (a[l] &amp;lt; 0)
            t[p].ll = 1, t[p].hl1 = -a[l];
        else
            t[p].rl = 1, t[p].hr0 = a[l];
        return;
    &amp;#125;
    int mid = (l + r) &amp;gt;&amp;gt; 1;
    bld(t[p].lc, l, mid), bld(t[p].rc, mid + 1, r);
    t[p] = t[t[p].lc] + t[t[p].rc];
    return;
&amp;#125;
void add(int p, int x, int v) &amp;#123;
    if (t[p].l == t[p].r) &amp;#123;
        if (v &amp;lt; 0) &amp;#123;
            t[p].rl = 0, t[p].hr0 = 0ll;
            t[p].ll = 1, t[p].hl1 = -v;
        &amp;#125;
        else &amp;#123;
            t[p].ll = 0, t[p].hl1 = 0ll;
            t[p].rl = 1, t[p].hr0 = v;
        &amp;#125;
        return;
    &amp;#125;
    int mid = (t[p].l + t[p].r) &amp;gt;&amp;gt; 1;
    if (x &amp;lt;= mid)
        add(t[p].lc, x, v);
    else
        add(t[p].rc, x, v);
    t[p] = t[t[p].lc] + t[t[p].rc];
    return;
&amp;#125;
int ask(int p, int l, int r) &amp;#123;
    if (l &amp;lt;= t[p].l &amp;amp;&amp;amp; t[p].r &amp;lt;= r)
        return p;
    int mid = (t[p].l + t[p].r) &amp;gt;&amp;gt; 1;
    if (r &amp;lt;= mid)
        return ask(t[p].lc, l, r);
    if (l &amp;gt; mid)
        return ask(t[p].rc, l, r);
    int q = ++tot;
    t[q].lc = ask(t[p].lc, l, r);
    t[q].rc = ask(t[p].rc, l, r);
    t[q] = t[t[q].lc] + t[t[q].rc];
    return q;
&amp;#125;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, k, rt = 0;
    std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; k;
    bpow[0] = inv[0] = 1ll;
    auto qkp = [&amp;amp;](long long x, int y) &amp;#123;
        auto res(1ll);
        for (; y; (x *= x) %= mod, y &amp;gt;&amp;gt;= 1)
            if (y &amp;amp; 1)
                (res *= x) %= mod;
        return res;
    &amp;#125;;
    inv[1] = qkp(base, mod - 2);
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        std::cin &amp;gt;&amp;gt; a[i];
        bpow[i] = bpow[i - 1] * base % mod;
        if (i &amp;gt;= 2)
            inv[i] = inv[i - 1] * inv[1] % mod;
    &amp;#125;
    bld(rt, 1, n);
    int q;
    std::cin &amp;gt;&amp;gt; q;
    for (int op; q--; ) &amp;#123;
        std::cin &amp;gt;&amp;gt; op;
        if (op == 1) &amp;#123;
            int x, v;
            std::cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; v;
            add(1, x, v);
        &amp;#125;
        else &amp;#123;
            int l, r;
            std::cin &amp;gt;&amp;gt; l &amp;gt;&amp;gt; r;
            if ((r - l + 1) &amp;amp; 1)
                std::cout &amp;lt;&amp;lt; &amp;quot;No&amp;quot; &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
            else &amp;#123;
                auto s(ask(1, l, r));
                std::cout &amp;lt;&amp;lt; ((!t[s].flag &amp;amp;&amp;amp; !t[s].ll &amp;amp;&amp;amp; !t[s].rl) ? &amp;quot;Yes&amp;quot; : &amp;quot;No&amp;quot;) &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
            &amp;#125;
        &amp;#125;
    &amp;#125;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h4 id=&#34;hungry-cow-p&#34;&gt;# Hungry Cow P&lt;/h4&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P9130&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P9130&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&#34;牛半仙的妹子序列&#34;&gt;# 牛半仙的妹子序列&lt;/h4&gt;
&lt;p&gt;&lt;a href=&#34;http://222.180.160.110:61235/problem/29550&#34; class=&#34;uri&#34;&gt;http://222.180.160.110:61235/problem/29550&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&#34;organizing-a-race&#34;&gt;# Organizing a Race&lt;/h4&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/CF671E&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/CF671E&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这个题不太应该放在这里的，因为存在只用一只 log 的纯线段树上二分做法，用楼房重建显得有点唐了&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&#34;转盘&#34;&gt;# 转盘&lt;/h4&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P4425&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P4425&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&#34;前进四楼房重建-ver&#34;&gt;# 前进四（楼房重建 ver）&lt;/h4&gt;
&lt;p&gt;&lt;a href=&#34;https://uoj.ac/problem/515&#34; class=&#34;uri&#34;&gt;https://uoj.ac/problem/515&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;另见 &lt;a href=&#34;#-前进四segment-tree-beats-ver&#34;&gt;segment tree beats ver&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;可持久化线段树&#34;&gt;可持久化线段树&lt;/h3&gt;
&lt;h4 id=&#34;card-game&#34;&gt;# Card Game&lt;/h4&gt;
&lt;p&gt;&lt;a href=&#34;https://qoj.ac/problem/8240&#34; class=&#34;uri&#34;&gt;https://qoj.ac/problem/8240&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;历史信息&#34;&gt;历史信息&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;一类形如『询问 &lt;span class=&#34;math inline&#34;&gt;\([l,r]\)&lt;/span&gt; 内合法子区间数量』的题目是可以考虑历史信息的&lt;/li&gt;
&lt;li&gt;具体地，扫描线，对于每个 &lt;span class=&#34;math inline&#34;&gt;\(r\)&lt;/span&gt;，把合法的 &lt;span class=&#34;math inline&#34;&gt;\(l\)&lt;/span&gt; 答案加一&lt;/li&gt;
&lt;li&gt;在每个 &lt;span class=&#34;math inline&#34;&gt;\(r\)&lt;/span&gt; 处查询 &lt;span class=&#34;math inline&#34;&gt;\([l,r]\)&lt;/span&gt; 的区间和就可以得出答案&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;铃原露露&#34;&gt;铃原露露&lt;/h4&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P8528&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P8528&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;题目形式满足树上支配对，考虑寻找支配关系&lt;/li&gt;
&lt;li&gt;&lt;p&gt;固定一个 LCA &lt;span class=&#34;math inline&#34;&gt;\(z\)&lt;/span&gt;，讨论 &lt;span class=&#34;math inline&#34;&gt;\(a_z\)&lt;/span&gt; 与 &lt;span class=&#34;math inline&#34;&gt;\(a_x,a_y\)&lt;/span&gt; 的大小关系给 &lt;span class=&#34;math inline&#34;&gt;\([1,a_x]\)&lt;/span&gt; 间的 &lt;span class=&#34;math inline&#34;&gt;\(l\)&lt;/span&gt; 带来的限制：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class=&#34;math inline&#34;&gt;\(a_z\in[a_x,a_y]\)&lt;/span&gt;，&lt;span class=&#34;math inline&#34;&gt;\((x,y)\)&lt;/span&gt; 总是合法，无限制。&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;math inline&#34;&gt;\(a_z&amp;lt;a_x\)&lt;/span&gt;，对于 &lt;span class=&#34;math inline&#34;&gt;\(r\ge a_y\)&lt;/span&gt;，当 &lt;span class=&#34;math inline&#34;&gt;\(l\in(a_z,a_x]\)&lt;/span&gt; 时，&lt;span class=&#34;math inline&#34;&gt;\((x,y)\)&lt;/span&gt; 非法。&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;math inline&#34;&gt;\(a_z&amp;gt;a_y\)&lt;/span&gt;，当 &lt;span class=&#34;math inline&#34;&gt;\(r\in[a_y,a_z)\)&lt;/span&gt; 时，&lt;span class=&#34;math inline&#34;&gt;\((x,y)\)&lt;/span&gt; 总是非法。此时所有 &lt;span class=&#34;math inline&#34;&gt;\(l\in[1,a_x]\)&lt;/span&gt; 不可选。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;发现固定 &lt;span class=&#34;math inline&#34;&gt;\(a_z,a_x\)&lt;/span&gt;，那么当 &lt;span class=&#34;math inline&#34;&gt;\(a_y\)&lt;/span&gt; 越靠近 &lt;span class=&#34;math inline&#34;&gt;\(a_x\)&lt;/span&gt; 时给出的限制越紧，反之亦然，就可以得到这样的支配关系&lt;/li&gt;
&lt;li&gt;容易发现当 &lt;span class=&#34;math inline&#34;&gt;\(a_z\notin [a_x,a_y]\)&lt;/span&gt; 时，&lt;span class=&#34;math inline&#34;&gt;\((x,y)\)&lt;/span&gt; 不合法；故只需要在 dsu on tree 上找到 &lt;span class=&#34;math inline&#34;&gt;\(a_x\)&lt;/span&gt; 的前驱、后继并统计支配对即可&lt;/li&gt;
&lt;li&gt;&lt;p&gt;考虑询问，发现需要维护区间加、区间历史 0 个数，是好做的（这里的区间加并不对应 summary 中提到的区间加；对 0 的更新才是）。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;历史标记的下传需要格外注意一下，应该只保证标记期间存在 0 的区间拥有懒标记；具体地，&lt;strong&gt;只应将其下传到和当前区间最小值相同的子区间&lt;/strong&gt;（具体可以看代码），容易证明是对的。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int maxn = 2e5 + 5;
struct node &amp;#123;
    long long s;
    int l, r, u, c, d, d1;
    node operator+ (const node q) const &amp;#123;
        node res;
        res.s = s + q.s;
        res.l = l, res.r = q.r;
        res.u = std::min(u, q.u);
        res.d = res.d1 = res.c = 0;
        if (u == res.u)
            res.c = c;
        if (q.u == res.u)
            res.c += q.c;
        return res;
    &amp;#125;
&amp;#125; t[maxn &amp;lt;&amp;lt; 2];
#define lt (p &amp;lt;&amp;lt; 1)
#define rt (lt | 1)
void bld(int p, int l, int r) &amp;#123;
    t[p].c = r - l + 1;
    t[p].l = l, t[p].r = r;
    if (l == r)
        return;
    int mid = (l + r) &amp;gt;&amp;gt; 1;
    bld(lt, l, mid), bld(rt, mid + 1, r);
    return;
&amp;#125;
void pushdown(int p) &amp;#123;
    if (t[p].d) &amp;#123;
        t[lt].d += t[p].d, t[lt].u += t[p].d;
        t[rt].d += t[p].d, t[rt].u += t[p].d;
        t[p].d = 0;
    &amp;#125;
    if (t[p].d1) &amp;#123;
        if (t[lt].u == t[p].u) &amp;#123;
            t[lt].s += (long long)t[lt].c * t[p].d1;
            t[lt].d1 += t[p].d1;
        &amp;#125;
        if (t[rt].u == t[p].u) &amp;#123;
            t[rt].s += (long long)t[rt].c * t[p].d1;
            t[rt].d1 += t[p].d1;
        &amp;#125;
        t[p].d1 = 0;
    &amp;#125;
    return;
&amp;#125;
void add(int p, int l, int r, int v) &amp;#123;
    if (l &amp;lt;= t[p].l &amp;amp;&amp;amp; t[p].r &amp;lt;= r) &amp;#123;
        t[p].d += v, t[p].u += v;
        return;
    &amp;#125;
    pushdown(p);
    int mid = (t[p].l + t[p].r) &amp;gt;&amp;gt; 1;
    if (l &amp;lt;= mid)
        add(lt, l, r, v);
    if (r &amp;gt; mid)
        add(rt, l, r, v);
    t[p] = t[lt] + t[rt];
    return;
&amp;#125;
void upd(int p, int l, int r) &amp;#123;
    if (l &amp;lt;= t[p].l &amp;amp;&amp;amp; t[p].r &amp;lt;= r) &amp;#123;
        if (!t[p].u)
            t[p].s += t[p].c, ++t[p].d1;
        return;
    &amp;#125;
    pushdown(p);
    int mid = (t[p].l + t[p].r) &amp;gt;&amp;gt; 1;
    if (l &amp;lt;= mid)
        upd(lt, l, r);
    if (r &amp;gt; mid)
        upd(rt, l, r);
    t[p] = t[lt] + t[rt];
    return;
&amp;#125;
long long ask(int p, int l, int r) &amp;#123;
    if (l &amp;lt;= t[p].l &amp;amp;&amp;amp; t[p].r &amp;lt;= r)
        return t[p].s;
    pushdown(p);
    auto res(0ll);
    int mid = (t[p].l + t[p].r) &amp;gt;&amp;gt; 1;
    if (l &amp;lt;= mid)
        res = ask(lt, l, r);
    if (r &amp;gt; mid)
        res += ask(rt, l, r);
    return res;
&amp;#125;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, m;
    std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
    std::vector&amp;lt;int&amp;gt; a(n + 1);
    for (int i = 1; i &amp;lt;= n; ++i)
        std::cin &amp;gt;&amp;gt; a[i];
    std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; g(n + 1); 
    for (int i = 2, x; i &amp;lt;= n; ++i)
        std::cin &amp;gt;&amp;gt; x, g[x].push_back(i);
    std::vector&amp;lt;int&amp;gt; siz(n + 1), son(n + 1);
    std::function&amp;lt;void(int)&amp;gt; DFS = [&amp;amp;](int x) &amp;#123;
        siz[x] = 1;
        for (auto i : g[x]) &amp;#123;
            DFS(i);
            siz[x] += siz[i];
            if (siz[i] &amp;gt; siz[son[x]])
                son[x] = i;
        &amp;#125;
        return;
    &amp;#125;;
    DFS(1);
    std::vector&amp;lt;std::vector&amp;lt;std::pair&amp;lt;int, int&amp;gt; &amp;gt; &amp;gt; u1(n + 1), u2(n + 1);
    std::function&amp;lt;void(int, int, std::set&amp;lt;int&amp;gt; &amp;amp;)&amp;gt; DFS2 = [&amp;amp;](int col, int x, std::set&amp;lt;int&amp;gt; &amp;amp;t) &amp;#123;
        auto p = t.lower_bound(a[x]);
        if (col == -1)
            t.insert(a[x]);
        else &amp;#123;
            if (p != t.begin()) &amp;#123;
                int y = *std::prev(p);
                if (col &amp;lt; y)
                    u1[a[x]].emplace_back(col + 1, y);
                else if (col &amp;gt; a[x]) &amp;#123;
                    u1[a[x]].emplace_back(1, y);
                    u2[col].emplace_back(1, y);
                &amp;#125;
            &amp;#125;
            if (p != t.end()) &amp;#123;
                int y = *p;
                if (col &amp;lt; a[x])
                    u1[y].emplace_back(col + 1, a[x]);
                else if (col &amp;gt; y) &amp;#123;
                    u1[y].emplace_back(1, a[x]);
                    u2[col].emplace_back(1, a[x]);
                &amp;#125;
            &amp;#125;
        &amp;#125;
        for (auto i : g[x])
            DFS2(col, i, t);
        return;
    &amp;#125;;
    std::function&amp;lt;void(int, std::set&amp;lt;int&amp;gt; &amp;amp;)&amp;gt; DFS1 = [&amp;amp;](int x, std::set&amp;lt;int&amp;gt; &amp;amp;t) &amp;#123;
        if (son[x])
            DFS1(son[x], t);
        for (auto i : g[x])
            if (i != son[x]) &amp;#123;
                std::set&amp;lt;int&amp;gt; nt;
                DFS1(i, nt);
            &amp;#125;
        t.insert(a[x]);
        for (auto i : g[x])
            if (i != son[x])
                DFS2(a[x], i, t), DFS2(-1, i, t);
        return;
    &amp;#125;;
    &amp;#123;
        std::set&amp;lt;int&amp;gt; t;
        DFS1(1, t);
    &amp;#125;
    std::vector&amp;lt;long long&amp;gt; res(m + 1);
    std::vector&amp;lt;std::vector&amp;lt;std::pair&amp;lt;int, int&amp;gt; &amp;gt; &amp;gt; t(n + 1);
    for (int i = 1, l, r; i &amp;lt;= m; ++i) &amp;#123;
        std::cin &amp;gt;&amp;gt; l &amp;gt;&amp;gt; r;
        t[r].emplace_back(l, i);
    &amp;#125;
    bld(1, 1, n);
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        for (auto [l, r] : u1[i])
            add(1, l, r, 1);
        for (auto [l, r] : u2[i])
            add(1, l, r, -1);
        upd(1, 1, i);
        for (auto [l, id] : t[i])
            res[id] = ask(1, l, i);
    &amp;#125;
    for (int i = 1; i &amp;lt;= m; ++i)
        std::cout &amp;lt;&amp;lt; res[i] &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h4 id=&#34;prof.-pangs-sequence-test_90&#34;&gt;Prof. Pang’s sequence / TEST_90&lt;/h4&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P10822&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P10822&lt;/a&gt; / &lt;a href=&#34;https://www.luogu.com.cn/problem/P9990&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P9990&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;离线扫描线，对于当前右端点 &lt;span class=&#34;math inline&#34;&gt;\(r\)&lt;/span&gt;，记录每种数最后一次出现的位置 &lt;span class=&#34;math inline&#34;&gt;\(pos\)&lt;/span&gt;。令 &lt;span class=&#34;math inline&#34;&gt;\(r\)&lt;/span&gt; 的颜色为 &lt;code&gt;1&lt;/code&gt;，从右到左，每碰到一个新的 &lt;span class=&#34;math inline&#34;&gt;\(pos\)&lt;/span&gt; 就切换颜色。&lt;/li&gt;
&lt;li&gt;显然对于当前 &lt;span class=&#34;math inline&#34;&gt;\(r\)&lt;/span&gt;，应该被加一的 &lt;span class=&#34;math inline&#34;&gt;\(l\)&lt;/span&gt; 就是颜色为 &lt;code&gt;1&lt;/code&gt; 的这些位置。&lt;/li&gt;
&lt;li&gt;考虑更快地维护这个过程，也就是在 &lt;span class=&#34;math inline&#34;&gt;\(r\)&lt;/span&gt; 的颜色和 &lt;span class=&#34;math inline&#34;&gt;\(r-1\)&lt;/span&gt; 不同时就可以对 &lt;span class=&#34;math inline&#34;&gt;\([1,r)\)&lt;/span&gt; 做一次 flip，是可行的&lt;/li&gt;
&lt;li&gt;在每个 &lt;span class=&#34;math inline&#34;&gt;\(r\)&lt;/span&gt; 处查询 &lt;span class=&#34;math inline&#34;&gt;\([l,r]\)&lt;/span&gt; 的区间和即可。&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int maxn = 5e5 + 5;
struct &amp;#123;
    long long s;
    int l, r, d0, d1, df, ds, u0, u1;
&amp;#125; t[maxn &amp;lt;&amp;lt; 2];
#define lt (p &amp;lt;&amp;lt; 1)
#define rt (lt | 1)
void pushup(int p) &amp;#123;
    t[p].u0 = t[lt].u0 + t[rt].u0;
    t[p].u1 = t[lt].u1 + t[rt].u1;
    return;
&amp;#125;
void pushval(int p, long long v0, long long v1, bool f) &amp;#123;
    if (f) &amp;#123;
        t[p].df ^= 1;
        std::swap(t[p].u0, t[p].u1);
        std::swap(t[p].d0, t[p].d1);
    &amp;#125;
    t[p].d0 += v0, t[p].d1 += v1;
    t[p].s += t[p].u0 * v0 + t[p].u1 * v1;
    return;
&amp;#125;
void pushdown(int p) &amp;#123;
    pushval(lt, t[p].d0, t[p].d1, t[p].df);
    pushval(rt, t[p].d0, t[p].d1, t[p].df);
    t[p].d0 = t[p].d1 = t[p].df = 0;
    return;
&amp;#125;
void bld(int p, int l, int r) &amp;#123;
    t[p].l = l, t[p].r = r;
    t[p].u0 = r - l + 1;
    if (l == r)
        return;
    int mid = (l + r) &amp;gt;&amp;gt; 1;
    bld(lt, l, mid), bld(rt, mid + 1, r);
    return;
&amp;#125;
void flip(int p, int l, int r) &amp;#123;
    if (l &amp;lt;= t[p].l &amp;amp;&amp;amp; t[p].r &amp;lt;= r) &amp;#123;
        pushval(p, 0, 0, 1);
        return;
    &amp;#125;
    pushdown(p);
    int mid = (t[p].l + t[p].r) &amp;gt;&amp;gt; 1;
    if (l &amp;lt;= mid)
        flip(lt, l, r);
    if (r &amp;gt; mid)
        flip(rt, l, r);
    pushup(p);
    return;
&amp;#125;
long long ask(int p, int l, int r) &amp;#123;
    if (l &amp;lt;= t[p].l &amp;amp;&amp;amp; t[p].r &amp;lt;= r)
        return t[p].s;
    pushdown(p);
    auto res(0ll);
    int mid = (t[p].l + t[p].r) &amp;gt;&amp;gt; 1;
    if (l &amp;lt;= mid)
        res = ask(lt, l, r);
    if (r &amp;gt; mid)
        res += ask(rt, l, r);
    return res;
&amp;#125;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n;
    std::cin &amp;gt;&amp;gt; n;
    std::vector&amp;lt;int&amp;gt; a(n + 1), la(n + 1);
    for (int i = 1; i &amp;lt;= n; ++i)
        std::cin &amp;gt;&amp;gt; a[i];
    int m;
    std::cin &amp;gt;&amp;gt; m;
    std::vector&amp;lt;long long&amp;gt; res(m + 1);
    std::vector&amp;lt;std::vector&amp;lt;std::pair&amp;lt;int, int&amp;gt; &amp;gt; &amp;gt; u(n + 1);
    for (int i = 1, l, r; i &amp;lt;= m; ++i) &amp;#123;
        std::cin &amp;gt;&amp;gt; l &amp;gt;&amp;gt; r;
        u[r].emplace_back(l, i);
    &amp;#125;
    bld(1, 1, n);
    for (int r = 1; r &amp;lt;= n; ++r) &amp;#123;
        flip(1, la[a[r]] + 1, r);
        pushval(1, 0, 1, 0);
        for (auto [l, id] : u[r])
            res[id] = ask(1, l, r);
        la[a[r]] = r;
    &amp;#125;
    for (int i = 1; i &amp;lt;= m; ++i)
        std::cout &amp;lt;&amp;lt; res[i] &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h4 id=&#34;比赛&#34;&gt;# 比赛&lt;/h4&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P8868&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P8868&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&#34;v&#34;&gt;# V&lt;/h4&gt;
&lt;p&gt;&lt;a href=&#34;https://uoj.ac/problem/164&#34; class=&#34;uri&#34;&gt;https://uoj.ac/problem/164&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&#34;cartesian-tree&#34;&gt;# Cartesian Tree&lt;/h4&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/CF1290E&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/CF1290E&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&#34;rprmq1&#34;&gt;# rprmq1&lt;/h4&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P6109&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P6109&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&#34;rpfrdtzls&#34;&gt;# rpfrdtzls&lt;/h4&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P9057&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P9057&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;线段树合并&#34;&gt;线段树合并&lt;/h3&gt;
&lt;p&gt;树上的线段树合并都很熟悉了，利用了线段树合并是线性的，以及 dsu on tree&lt;/p&gt;
&lt;p&gt;不如说绝大多数线段树合并都有树上背景，因为自带合并顺序和复杂度保证&lt;/p&gt;
&lt;p&gt;Tip：树上合并的背景下，线段树合并的表现会比主席树优秀很多，因为前者跑不满&lt;/p&gt;
&lt;p&gt;不在树上的问题，题目可能会通过各种方式保证复杂度，比如保证每个点只会被合并一次之类&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&#34;迁移计划-migration-plan&#34;&gt;# 迁移计划 / Migration Plan&lt;/h4&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P11993&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P11993&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&#34;永无乡&#34;&gt;# 永无乡&lt;/h4&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P3224&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P3224&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&#34;语言&#34;&gt;# 语言&lt;/h4&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P5327&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P5327&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&#34;梦幻布丁&#34;&gt;# 梦幻布丁&lt;/h4&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P3201&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P3201&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;还有两个比较屎的 P7563 和 P7963&lt;/p&gt;
&lt;h3 id=&#34;扫描线&#34;&gt;扫描线&lt;/h3&gt;
&lt;p&gt;离线，按照下标排序，扫一遍处理询问，就可以利用『所有更靠前的下标都以被计算过』来处理问题&lt;/p&gt;
&lt;p&gt;不只局限于区间询问，单点的可能反而更难一点，需要发现和下标大小有关的性质&lt;/p&gt;
&lt;h4 id=&#34;等差子序列&#34;&gt;等差子序列&lt;/h4&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P2757&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P2757&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定一个 &lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt; 的排列，问是否能找到 &lt;span class=&#34;math inline&#34;&gt;\(len\ge 3\)&lt;/span&gt; 的子序列，使得其是等差的。&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(n\le 5\times 10^5\)&lt;/span&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;根据单调性，可以简化为 &lt;span class=&#34;math inline&#34;&gt;\(len=3\)&lt;/span&gt; 时的答案&lt;/p&gt;
&lt;p&gt;也就是对于中项 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt;，能不能找到 &lt;span class=&#34;math inline&#34;&gt;\(i&amp;lt;j&amp;lt;k\)&lt;/span&gt;，使得 &lt;span class=&#34;math inline&#34;&gt;\(a_j-a_i=a_k-a_j\)&lt;/span&gt;。从下标出发，差值是不好维护的；注意到是排列，可以从值出发，转化成是否存在一个 &lt;span class=&#34;math inline&#34;&gt;\(d\)&lt;/span&gt;，使得 &lt;span class=&#34;math inline&#34;&gt;\(a_j-d\)&lt;/span&gt; 在之前出现，&lt;span class=&#34;math inline&#34;&gt;\(a_j+d\)&lt;/span&gt; 在之后出现。&lt;/p&gt;
&lt;p&gt;利用下标『之前』和『之后』的限制，做扫描线，查看是否存在 &lt;span class=&#34;math inline&#34;&gt;\(d\)&lt;/span&gt; 使 &lt;span class=&#34;math inline&#34;&gt;\(a_j-d\)&lt;/span&gt; 出现过但是 &lt;span class=&#34;math inline&#34;&gt;\(a_j+d\)&lt;/span&gt; 没有出现过；还是因为是排列，数量只会为 &lt;span class=&#34;math inline&#34;&gt;\(0\)&lt;/span&gt; 或 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt;，如果非法说明 &lt;span class=&#34;math inline&#34;&gt;\(a_j-d\)&lt;/span&gt; 和 &lt;span class=&#34;math inline&#34;&gt;\(a_j+d\)&lt;/span&gt; 都是 &lt;span class=&#34;math inline&#34;&gt;\(0\)&lt;/span&gt; 或者都是 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt;，发现是关于 &lt;span class=&#34;math inline&#34;&gt;\(a_j\)&lt;/span&gt; 的回文，故权值线段树维护哈希，如果 &lt;span class=&#34;math inline&#34;&gt;\(a_j\)&lt;/span&gt; 两侧全部回文，说明 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; 不是合法中项。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
namespace fastIO &amp;#123;
const int LEN = (1 &amp;lt;&amp;lt; 20);
#ifdef ONLINE_JUDGE
inline int nec(void) &amp;#123;
    static char buf[LEN], *p = buf, *e = buf;
    if (p == e) &amp;#123;
        e = buf + fread(buf, 1, LEN, stdin);
        if (e == buf)
            return EOF;
        p = buf;
    &amp;#125;
    return *p++;
&amp;#125;
#else
#define nec getchar
#endif
inline bool read(int &amp;amp;x) &amp;#123;
    x = 0;
    bool f = 0;
    char ch = nec();
    while (ch &amp;lt; &amp;#39;0&amp;#39; || ch &amp;gt; &amp;#39;9&amp;#39;) &amp;#123;
        if (ch == EOF)
            return 0;
        if (ch == &amp;#39;-&amp;#39;)
            f = 1;
        ch = nec();
    &amp;#125;
    while (ch &amp;gt;= &amp;#39;0&amp;#39; &amp;amp;&amp;amp; ch &amp;lt;= &amp;#39;9&amp;#39;) &amp;#123;
        x = x * 10 + ch - &amp;#39;0&amp;#39;;
        ch = nec();
    &amp;#125;
    if (f)
        x = -x;
    return 1;
&amp;#125;
void print(int x) &amp;#123;
    if (x &amp;lt; 0) &amp;#123;
        putchar(&amp;#39;-&amp;#39;);
        x = -x;
    &amp;#125;
    if (x &amp;gt;= 10)
        print(x / 10);
    putchar(x % 10 + &amp;#39;0&amp;#39;);
    return;
&amp;#125;
void print(int x, char ch) &amp;#123;
    print(x);
    putchar(ch);
    return;
&amp;#125;
&amp;#125; // namespace fastIO
namespace XSC062 &amp;#123;
using namespace fastIO;
#define lt (p &amp;lt;&amp;lt; 1)
#define rt (lt | 1)
using sc = unsigned long long;
const int p = 13331; // 0103 ¿É°®µÎÄó 
const int lim = 5e5;
const int maxn = 5e5 + 5;
struct _ &amp;#123;
    int l, r;
    sc lh, rh;
&amp;#125;;
int T, n;
int a[maxn];
sc base[maxn];
_ t[maxn &amp;lt;&amp;lt; 2];
int min(int x, int y) &amp;#123;
    return x &amp;lt; y ? x : y;
&amp;#125;
int max(int x, int y) &amp;#123;
    return x &amp;gt; y ? x : y;
&amp;#125;
void pushup(int p) &amp;#123;
    int ll = t[lt].r - t[lt].l + 1;
    int rl = t[rt].r - t[rt].l + 1;
    t[p].lh = t[lt].lh * base[rl] + t[rt].lh;
    t[p].rh = t[rt].rh * base[ll] + t[lt].rh;
    return;
&amp;#125;
void bld(int p, int l, int r) &amp;#123;
    t[p].lh = t[p].rh = 0;
    t[p].l = l, t[p].r = r;
    if (l == r)
        return;
    int mid = (l + r) &amp;gt;&amp;gt; 1;
    bld(lt, l, mid);
    bld(rt, mid + 1, r);
    return;
&amp;#125;
void upd(int p, int x, int v) &amp;#123;
    if (t[p].l == t[p].r) &amp;#123;
        t[p].lh = t[p].rh = v;
        return;
    &amp;#125;
    int mid = (t[p].l + t[p].r) &amp;gt;&amp;gt; 1;
    if (x &amp;lt;= mid)
        upd(lt, x, v);
    else upd(rt, x, v);
    pushup(p);
    return;
&amp;#125;
sc qryl(int p, int l, int r) &amp;#123;
    if (l &amp;lt;= t[p].l &amp;amp;&amp;amp; t[p].r &amp;lt;= r)
        return t[p].lh;
    sc ans = 0;
    int mid = (t[p].l + t[p].r) &amp;gt;&amp;gt; 1;
    if (l &amp;lt;= mid)
        ans = qryl(lt, l, r);
    if (r &amp;gt; mid) &amp;#123;
        ans *= base[min(r, t[p].r) - mid];
        ans += qryl(rt, l, r);
    &amp;#125;
    return ans;
&amp;#125;
sc qryr(int p, int l, int r) &amp;#123;
    if (l &amp;lt;= t[p].l &amp;amp;&amp;amp; t[p].r &amp;lt;= r)
        return t[p].rh;
    sc ans = 0;
    int mid = (t[p].l + t[p].r) &amp;gt;&amp;gt; 1;
    if (r &amp;gt; mid)
        ans = qryr(rt, l, r);
    if (l &amp;lt;= mid) &amp;#123;
        ans *= base[mid - max(l, t[p].l) + 1];
        ans += qryr(lt, l, r);
    &amp;#125;
    return ans;
&amp;#125;
int main() &amp;#123;
    read(T);
    base[0] = 1;
    for (int i = 1; i &amp;lt;= lim; ++i)
        base[i] = base[i - 1] * p;
    while (T--) &amp;#123;
        read(n);
        bld(1, 1, n);
        for (int i = 1; i &amp;lt;= n; ++i)
            read(a[i]);
        for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
            int len = min(n - a[i], a[i] - 1);
            if (i &amp;gt; 1) &amp;#123;
                upd(1, a[i - 1], 1);
            &amp;#125;
            if (len == 0)
                continue;
            int l = a[i] - len;
            int r = a[i] + len;
            if (qryl(1, l, a[i] - 1) !=
                qryr(1, a[i] + 1, r)) &amp;#123;
                puts(&amp;quot;Y&amp;quot;);
                goto isSol;
            &amp;#125;
        &amp;#125;
        puts(&amp;quot;N&amp;quot;);
        isSol: ;
    &amp;#125;
    return 0;
&amp;#125;
&amp;#125; // namespace XSC062
int main() &amp;#123;
    XSC062::main();
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h4 id=&#34;小奇的糖果&#34;&gt;小奇的糖果&lt;/h4&gt;
&lt;p&gt;&lt;a href=&#34;https://hydro.ac/p/bzoj-P4548&#34; class=&#34;uri&#34;&gt;https://hydro.ac/p/bzoj-P4548&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;有 &lt;span class=&#34;math inline&#34;&gt;\(N\)&lt;/span&gt; 个有颜色（&lt;span class=&#34;math inline&#34;&gt;\(M\)&lt;/span&gt; 种）的点在平面上，在平面上取一条水平的线段，可以选择线段上方的所有点，也可以选择下方的所有点。找出一条线段和选取的方向，使得在选取的点不包含所有颜色的前提下，最大化选到点的数量。&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(N,M\le 10^6,|x|,|y|\le 10^9\)&lt;/span&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;先离散化 + 按 &lt;span class=&#34;math inline&#34;&gt;\(y\)&lt;/span&gt; 排序降一维，贪心地枚举某种颜色 &lt;span class=&#34;math inline&#34;&gt;\(c\)&lt;/span&gt; 不选。考虑线段在平面最底部时的答案，取出所有颜色为 &lt;span class=&#34;math inline&#34;&gt;\(c\)&lt;/span&gt; 的点的 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 坐标，只能选择相邻的 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 之间的所有点。枚举每一对相邻的点计算答案。把线段上移，如果碰到了一个颜色为 &lt;span class=&#34;math inline&#34;&gt;\(c\)&lt;/span&gt; 的点，就说明这个点不再参与限制，删去即可，该点原前驱和后继围出来的区间就能够更新答案。用链表 / 单调栈就能很快地维护。&lt;/p&gt;
&lt;p&gt;先枚举颜色再跑扫描线是 &lt;span class=&#34;math inline&#34;&gt;\(O(n^2\log n)\)&lt;/span&gt; 的，考虑优化。注意到数据结构里存在当前颜色没有影响，因为一定不在询问区间内。整体做扫描线，复杂度 &lt;span class=&#34;math inline&#34;&gt;\(O(n\log n)\)&lt;/span&gt;。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;namespace XSC062 &amp;#123;
using namespace fastIO;
const int maxn = 2e5 + 5;
struct _ &amp;#123;
    int x, y, c;
    bool operator&amp;lt; (const _ &amp;amp;q) const &amp;#123;
        return y &amp;lt; q.y;
    &amp;#125;
&amp;#125;;
_ a[maxn];
int s[maxn], t[maxn];
int ls[maxn], rs[maxn];
int cp[maxn], cn[maxn];
int pre[maxn], nex[maxn];
std::vector&amp;lt;int&amp;gt; g[maxn];
int div[maxn], Bit[maxn];
int T, n, k, tot, cnt, now, res;
int max(int x, int y) &amp;#123; return x &amp;gt; y ? x : y; &amp;#125;
int lowbit(int x) &amp;#123; return x &amp;amp; -x; &amp;#125;
void add(int x, int v) &amp;#123;
    for (; x &amp;lt;= n; x += lowbit(x)) Bit[x] += v;
    return;
&amp;#125;
int ask(int x) &amp;#123;
    int res = 0;
    for (; x; x -= lowbit(x)) res += Bit[x];
    return res;
&amp;#125;
int ask(int l, int r) &amp;#123;
    if (l &amp;gt; r) return 0;
    return ask(r) - ask(l - 1);
&amp;#125;
int main() &amp;#123;
//  freopen(&amp;quot;1.in&amp;quot;, &amp;quot;r&amp;quot;, stdin); 
    read(T);
    while (T--) &amp;#123;
        read(n), read(k), now = res = 0;
        for (int i = 1; i &amp;lt;= k; ++i) &amp;#123;
            s[i] = ++now, t[i] = ++now;
            div[s[i]] = 0, div[t[i]] = n + 1;
            nex[s[i]] = t[i], pre[t[i]] = s[i];
            pre[s[i]] = nex[t[i]] = 0;
        &amp;#125;
        for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
            read(a[i].x), read(a[i].y), read(a[i].c);
            ls[i] = a[i].x, rs[i] = a[i].y;
        &amp;#125;
        std::sort(a + 1, a + n + 1, [&amp;amp;](_ x, _ y) &amp;#123; return x.x &amp;lt; y.x; &amp;#125;);
        std::sort(ls + 1, ls + n + 1);
        std::sort(rs + 1, rs + n + 1);
        tot = std::unique(ls + 1, ls + n + 1) - ls - 1;
        cnt = std::unique(rs + 1, rs + n + 1) - rs - 1;
        for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
            a[i].x = std::lower_bound(ls + 1, ls + tot + 1, a[i].x) - ls;
            a[i].y = std::lower_bound(rs + 1, rs + cnt + 1, a[i].y) - rs;
        &amp;#125;
        for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
            div[++now] = a[i].x;
            add(a[i].x, 1), g[a[i].y].push_back(now);
            pre[now] = pre[t[a[i].c]], nex[pre[t[a[i].c]]] = now;
            pre[t[a[i].c]] = now, nex[now] = t[a[i].c];
        &amp;#125;
        memcpy(cp, pre, sizeof (cp));
        memcpy(cn, nex, sizeof (cn));
        for (int i = 1; i &amp;lt;= k; ++i) &amp;#123;
            for (int j = s[i]; j != t[i]; j = nex[j])
                res = max(res, ask(div[j] + 1, div[nex[j]] - 1));
        &amp;#125;
        for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
            for (auto j : g[i]) add(div[j], -1);
            for (auto j : g[i]) &amp;#123;
                res = max(res, ask(div[pre[j]] + 1, div[nex[j]] - 1));
                nex[pre[j]] = nex[j], pre[nex[j]] = pre[j];
            &amp;#125;
        &amp;#125;
        for (int i = 1; i &amp;lt;= n; ++i) add(a[i].x, 1);
        for (int i = n; i; --i) &amp;#123;
            for (auto j : g[i]) add(div[j], -1);
            for (auto j : g[i]) &amp;#123;
                res = max(res, ask(div[cp[j]] + 1, div[cn[j]] - 1));
                cn[cp[j]] = cn[j], cp[cn[j]] = cp[j];
            &amp;#125;
        &amp;#125;
        print(res, &amp;#39;\n&amp;#39;);
        for (int i = 1; i &amp;lt;= n; ++i)
            g[i].clear(), g[i].shrink_to_fit();
    &amp;#125;
    return 0;
&amp;#125;
&amp;#125; // namespace XSC062&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h4 id=&#34;rmscne&#34;&gt;rmscne&lt;/h4&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P7907&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P7907&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定长为 &lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt; 的序列，&lt;span class=&#34;math inline&#34;&gt;\(q\)&lt;/span&gt; 次询问 &lt;span class=&#34;math inline&#34;&gt;\([l,r]\)&lt;/span&gt; 中的最短子区间 &lt;span class=&#34;math inline&#34;&gt;\([l&amp;#39;,r&amp;#39;]\)&lt;/span&gt;，使得其包含 &lt;span class=&#34;math inline&#34;&gt;\([l,r]\)&lt;/span&gt; 中出现的全部值。输出长度即可。&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(n,q,V\le 2\times 10^6\)&lt;/span&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;区间里面找子区间也是扫描线经典问题。&lt;/p&gt;
&lt;p&gt;区间种类数会有几种思路：集合哈希、前驱后继、莫队之类。PS：这个题用 ODT 可以拿到最优解&lt;/p&gt;
&lt;p&gt;对于 &lt;span class=&#34;math inline&#34;&gt;\(i=1\sim n\)&lt;/span&gt;，依次考虑 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 作为右端点的情况。线段树维护每个 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; 作为左端点时的 &lt;span class=&#34;math inline&#34;&gt;\(i-r_j\)&lt;/span&gt;，其中 &lt;span class=&#34;math inline&#34;&gt;\([j, r_j]\)&lt;/span&gt; 是与 &lt;span class=&#34;math inline&#34;&gt;\([j,i]\)&lt;/span&gt; 种类相同的最小区间。&lt;/p&gt;
&lt;p&gt;询问的时候，只需要找到最大的 &lt;span class=&#34;math inline&#34;&gt;\(j&amp;#39;\)&lt;/span&gt;，满足 &lt;span class=&#34;math inline&#34;&gt;\([j, r]\)&lt;/span&gt; 与 &lt;span class=&#34;math inline&#34;&gt;\([l, r]\)&lt;/span&gt; 种类相同，求 &lt;span class=&#34;math inline&#34;&gt;\([l, j&amp;#39;]\)&lt;/span&gt; 的区间和即可。找 &lt;span class=&#34;math inline&#34;&gt;\(j&amp;#39;\)&lt;/span&gt; 可以记录前驱后继，初始每个 &lt;span class=&#34;math inline&#34;&gt;\(l\)&lt;/span&gt; 对应的 &lt;span class=&#34;math inline&#34;&gt;\(j&amp;#39;\)&lt;/span&gt; 就是自己。若加入了一个与 &lt;span class=&#34;math inline&#34;&gt;\(l\)&lt;/span&gt; 相同的新元素，那么 &lt;span class=&#34;math inline&#34;&gt;\(l\)&lt;/span&gt; 就不再有贡献，此时 &lt;span class=&#34;math inline&#34;&gt;\(l\)&lt;/span&gt; 的 &lt;span class=&#34;math inline&#34;&gt;\(j&amp;#39;\)&lt;/span&gt; 就会继承 &lt;span class=&#34;math inline&#34;&gt;\(l+1\)&lt;/span&gt; 的 &lt;span class=&#34;math inline&#34;&gt;\(j&amp;#39;\)&lt;/span&gt;，这个过程用并查集即可简单维护。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int lim = 2e6;
const int maxn = 2e6 + 5;
const int maxm = 5e7 + 5;
const int inf = 0x3f3f3f3f;
struct &amp;#123; int l, r, u, d; &amp;#125; t[maxn &amp;lt;&amp;lt; 2];
int tot;
#define lt (p &amp;lt;&amp;lt; 1)
#define rt (lt | 1)
void pushdown(int p) &amp;#123;
    if (~t[p].d) &amp;#123;
        t[lt].d = t[rt].d = t[p].d;
        t[lt].u = t[p].d - t[lt].r + 1;
        t[rt].u = t[p].d - t[rt].r + 1;
        t[p].d = -1;
    &amp;#125;
    return;
&amp;#125;
void bld(int p, int l, int r) &amp;#123;
    t[p].l = l, t[p].r = r, t[p].d = -1;
    if (l == r)
        return;
    int mid = (l + r) &amp;gt;&amp;gt; 1;
    bld(lt, l, mid), bld(rt, mid + 1, r);
    return;
&amp;#125;
void upd(int p, int l, int r, int v) &amp;#123;
    if (l &amp;lt;= t[p].l &amp;amp;&amp;amp; t[p].r &amp;lt;= r) &amp;#123;
        t[p].d = v, t[p].u = v - t[p].r + 1;
        return;
    &amp;#125;
    pushdown(p);
    int mid = (t[p].l + t[p].r) &amp;gt;&amp;gt; 1;
    if (l &amp;lt;= mid)
        upd(lt, l, r, v);
    if (r &amp;gt; mid)
        upd(rt, l, r, v);
    t[p].u = std::min(t[lt].u, t[rt].u);
    return;
&amp;#125;
int ask(int p, int l, int r) &amp;#123;
    if (l &amp;lt;= t[p].l &amp;amp;&amp;amp; t[p].r &amp;lt;= r)
        return t[p].u;
    pushdown(p);
    int mid = (t[p].l + t[p].r) &amp;gt;&amp;gt; 1, res = inf;
    if (l &amp;lt;= mid)
        res = ask(lt, l, r);
    if (r &amp;gt; mid)
        res = std::min(res, ask(rt, l, r));
    return res;
&amp;#125;
#undef lt
#undef rt
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#endif
    int n, q;
    std::cin &amp;gt;&amp;gt; n;
    std::vector&amp;lt;int&amp;gt; a(n + 1), la(lim + 1), pre(n + 1), f(n + 1);
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        std::cin &amp;gt;&amp;gt; a[i];
        pre[i] = la[a[i]], la[a[i]] = i, f[i] = i;
    &amp;#125;
    std::cin &amp;gt;&amp;gt; q;
    std::vector&amp;lt;int&amp;gt; res(q + 1);
    std::vector&amp;lt;std::vector&amp;lt;std::pair&amp;lt;int, int&amp;gt; &amp;gt; &amp;gt; t(n + 1);
    for (int i = 1, l, r; i &amp;lt;= q; ++i) &amp;#123;
        std::cin &amp;gt;&amp;gt; l &amp;gt;&amp;gt; r;
        t[r].emplace_back(l, i);
    &amp;#125;
    bld(1, 1, n);
    std::function&amp;lt;int(int)&amp;gt; find = [&amp;amp;](int x) &amp;#123;
        return x == f[x] ? x : f[x] = find(f[x]);
    &amp;#125;;
    auto merge = [&amp;amp;](int x, int y) &amp;#123;
        x = find(x), y = find(y);
        f[std::min(x, y)] = std::max(x, y);
        return;
    &amp;#125;;
    for (int r = 1; r &amp;lt;= n; ++r) &amp;#123;
        if (pre[r])
            merge(pre[r], pre[r] + 1);
        upd(1, pre[r] + 1, r, r);
        for (auto [l, i] : t[r])
            res[i] = ask(1, l, find(l));
    &amp;#125;
    for (int i = 1; i &amp;lt;= q; ++i)
        std::cout &amp;lt;&amp;lt; res[i] &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h4 id=&#34;颜色&#34;&gt;# 颜色&lt;/h4&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P4065&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P4065&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定 &lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt; 个元素，每个元素有一个颜色。选择若干颜色（不能全选或全不选），问有多少种选取方案使得拥有这些颜色的点是一段连续的区间。&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(n\le 3\times 10^5\)&lt;/span&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;势能线段树&#34;&gt;势能线段树&lt;/h3&gt;
&lt;h4 id=&#34;市场&#34;&gt;# 市场&lt;/h4&gt;
&lt;p&gt;&lt;a href=&#34;https://loj.ac/p/6029&#34; class=&#34;uri&#34;&gt;https://loj.ac/p/6029&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&#34;segment-tree-beats&#34;&gt;# Segment Tree Beats!&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;维护区间取 min，区间求和。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;pdf P57&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&#34;segment-tree-beats-plus&#34;&gt;# Segment Tree Beats! Plus&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;维护区间加，区间取 min，区间求和。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;pdf P60&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&#34;最假女选手&#34;&gt;# 最假女选手&lt;/h4&gt;
&lt;p&gt;&lt;a href=&#34;https://loj.ac/p/6565&#34; class=&#34;uri&#34;&gt;https://loj.ac/p/6565&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&#34;mzl-loves-segment-tree&#34;&gt;# Mzl loves segment tree&lt;/h4&gt;
&lt;p&gt;&lt;a href=&#34;http://222.180.160.110:61235/problem/10203&#34; class=&#34;uri&#34;&gt;http://222.180.160.110:61235/problem/10203&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;pdf P66&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&#34;ctsn-loves-segment-tree&#34;&gt;# CTSN loves segment tree&lt;/h4&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/U180387&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/U180387&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&#34;前进四segment-tree-beats-ver&#34;&gt;# 前进四（segment tree beats ver）&lt;/h4&gt;
&lt;p&gt;&lt;a href=&#34;https://uoj.ac/problem/515&#34; class=&#34;uri&#34;&gt;https://uoj.ac/problem/515&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;另见 &lt;a href=&#34;#-前进四楼房重建-ver&#34;&gt;楼房重建 ver&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&#34;基础数据结构练习题&#34;&gt;# 基础数据结构练习题&lt;/h4&gt;
&lt;p&gt;&lt;a href=&#34;https://uoj.ac/problem/228&#34; class=&#34;uri&#34;&gt;https://uoj.ac/problem/228&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&#34;线段树-3&#34;&gt;# 线段树 3&lt;/h4&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P6242&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P6242&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&#34;赛格蒙特彼茨&#34;&gt;# 赛格蒙特彼茨&lt;/h4&gt;
&lt;p&gt;pdf P70&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&#34;堕天作战-test_98&#34;&gt;# 堕天作战 TEST_98&lt;/h4&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P9069&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P9069&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;线段树分治&#34;&gt;线段树分治&lt;/h3&gt;
&lt;h4 id=&#34;meetings-会议&#34;&gt;# meetings 会议&lt;/h4&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P5044&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P5044&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&#34;八纵八横&#34;&gt;# 八纵八横&lt;/h4&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P3733&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P3733&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;笛卡尔树&#34;&gt;笛卡尔树&lt;/h2&gt;
&lt;p&gt;一些思考方式和 trick 吧&lt;/p&gt;
&lt;h3 id=&#34;由乃救爷爷&#34;&gt;* 由乃救爷爷&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P3793&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P3793&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;尽可能快地维护随机序列区间最值。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;随机序列笛卡尔树期望深度是 &lt;span class=&#34;math inline&#34;&gt;\(\log\)&lt;/span&gt;。就可以做了。&lt;/p&gt;
&lt;p&gt;来自 &lt;a href=&#34;https://www.luogu.com/article/hj9ci08q&#34;&gt;UnyieldingTrilobite 的文章&lt;/a&gt;：同样可以用悬线！&lt;a href=&#34;/20231117/#随机序列悬线结合分块&#34;&gt;悬线 + 分块&lt;/a&gt; 就可以做了。&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;情景剧最值的性质维护方式的取舍&#34;&gt;* 情景剧（最值的性质，维护方式的取舍）&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;http://222.180.160.110:61235/contest/4273/problem/1&#34; class=&#34;uri&#34;&gt;http://222.180.160.110:61235/contest/4273/problem/1&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定长度为 &lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt; 的序列 &lt;span class=&#34;math inline&#34;&gt;\(a_{1\sim n}\)&lt;/span&gt;，找到一个区间，使得 区间长度 &lt;span class=&#34;math inline&#34;&gt;\(\times\)&lt;/span&gt; 区间最大值 &lt;span class=&#34;math inline&#34;&gt;\(\times\)&lt;/span&gt; 区间最小值 最大。输出最大值。&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(n\le 10^6,V\le 10^9\)&lt;/span&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;容易想到建笛卡尔树。这里的 最大值 和 最小值 地位相等吗？为什么？&lt;/li&gt;
&lt;li&gt;如果我们是钦定最大值，再去最大化『最小值 &lt;span class=&#34;math inline&#34;&gt;\(\times\)&lt;/span&gt; 区间长』，好像没办法做，因为这个最大贡献没什么性质&lt;/li&gt;
&lt;li&gt;&lt;p&gt;但如果钦定最小值，能取到的最长区间就是在小根笛卡尔树上的管辖区间，显然区间越长取到的最大值也越大，直接取这里的最大值即可&lt;/p&gt;
所以最大值和最小值地位不等是因为，区间长和最大值大小是正相关的，所以只需要最大化区间长，最大值也就最大化了&lt;/li&gt;
&lt;li&gt;&lt;p&gt;所以在小根笛卡尔树上维护区间最大值即可&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;小蓝的好友&#34;&gt;# 小蓝的好友&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P2611&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P2611&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;星白-by-ttpandas笛卡尔树-dsu-on-tree&#34;&gt;星白 by TTpandaS（笛卡尔树 + dsu on tree）&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;http://222.180.160.110:61235/contest/6517/problem/3&#34; class=&#34;uri&#34;&gt;http://222.180.160.110:61235/contest/6517/problem/3&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定 &lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt; 的排列 &lt;span class=&#34;math inline&#34;&gt;\(a_{1\sim n}\)&lt;/span&gt;，回答 &lt;span class=&#34;math inline&#34;&gt;\(q\)&lt;/span&gt; 个询问：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;给定 &lt;span class=&#34;math inline&#34;&gt;\([l,r]\)&lt;/span&gt;，是否存在 &lt;span class=&#34;math inline&#34;&gt;\(l\le x&amp;lt;y\le r\)&lt;/span&gt;，使得：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class=&#34;math inline&#34;&gt;\(a_x&amp;lt;a_y\)&lt;/span&gt;，且 &lt;span class=&#34;math inline&#34;&gt;\(a_x\)&lt;/span&gt; 不为 &lt;span class=&#34;math inline&#34;&gt;\([x,y]\)&lt;/span&gt; 中最小值；&lt;/li&gt;
&lt;li&gt;令 &lt;span class=&#34;math inline&#34;&gt;\(a_i\)&lt;/span&gt; 为 &lt;span class=&#34;math inline&#34;&gt;\([x, y]\)&lt;/span&gt; 中最小值，则 &lt;span class=&#34;math inline&#34;&gt;\(a_i\mid (a_x\cdot a_y)\)&lt;/span&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(n\le 3\times 10^5,q\le10^6\)&lt;/span&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;容易想到对于 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 反过来找 &lt;span class=&#34;math inline&#34;&gt;\([x,y]\)&lt;/span&gt;。如果建立小根笛卡尔树，在 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 的左边找 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt;、右边找 &lt;span class=&#34;math inline&#34;&gt;\(y\)&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;一个自然的想法是对于左侧的每个 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt;，维护最近的合法 &lt;span class=&#34;math inline&#34;&gt;\(y\)&lt;/span&gt;；或是对于右侧的每个 &lt;span class=&#34;math inline&#34;&gt;\(y\)&lt;/span&gt;，维护最近的合法 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt;。&lt;/p&gt;
做一个 DSU on Tree，哪边区间短就维护哪边，是单 &lt;span class=&#34;math inline&#34;&gt;\(\log\)&lt;/span&gt; 的。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;需要解决点内预处理，以 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 为例，对于每个 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 和当前点 &lt;span class=&#34;math inline&#34;&gt;\((p,l,r)\)&lt;/span&gt;，需要查询 &lt;span class=&#34;math inline&#34;&gt;\((p, r]\)&lt;/span&gt; 中最小的 &lt;span class=&#34;math inline&#34;&gt;\(y\)&lt;/span&gt;，使得 &lt;span class=&#34;math inline&#34;&gt;\(a_y\)&lt;/span&gt; 是 &lt;span class=&#34;math inline&#34;&gt;\(\dfrac {a_p}{\gcd(a_x,a_p)}\)&lt;/span&gt; 的倍数。离线下来扫描线，&lt;del&gt;开 &lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt; 棵线段树&lt;/del&gt;，跑 &lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt; 次树状数组，用 &lt;span class=&#34;math inline&#34;&gt;\(y\)&lt;/span&gt; 更新所有 &lt;span class=&#34;math inline&#34;&gt;\(a_y\)&lt;/span&gt; 因数在 &lt;span class=&#34;math inline&#34;&gt;\(a_y\)&lt;/span&gt; 处的 min / max，可以在两个 log 内获得支配对类似物。&lt;/p&gt;
不是很理解为什么题目要再加一个偏序限制，除了增加代码量和用时外似乎并没有什么作用？&lt;/li&gt;
&lt;li&gt;&lt;p&gt;查询时直接 rmq（这里唐了写了 st 表，实际上只需要前后缀）即可。整体复杂度 &lt;span class=&#34;math inline&#34;&gt;\(O(n\log^2 n)\)&lt;/span&gt;。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int LEN = (1 &amp;lt;&amp;lt; 20);
#ifdef ONLINE_JUDGE
int nec(void) &amp;#123;
    static char buf[LEN], *p = buf, *e = buf;
    if (p == e) &amp;#123;
        e = buf + fread(buf, 1, LEN, stdin);
        if (e == buf) return EOF;
        p = buf;
    &amp;#125;
    return *p++;
&amp;#125;
#else
#define nec getchar
#endif
bool read(int &amp;amp;x) &amp;#123;
    x = 0;
    bool f = 0;
    char ch = nec();
    while (ch &amp;lt; &amp;#39;0&amp;#39; || ch &amp;gt; &amp;#39;9&amp;#39;) &amp;#123;
        if (ch == EOF) return 0;
        if (ch == &amp;#39;-&amp;#39;) f = 1;
        ch = nec();
    &amp;#125;
    while (ch &amp;gt;= &amp;#39;0&amp;#39; &amp;amp;&amp;amp; ch &amp;lt;= &amp;#39;9&amp;#39;) &amp;#123;
        x = x * 10 + ch - &amp;#39;0&amp;#39;;
        ch = nec();
    &amp;#125;
    if (f) x = -x;
    return 1;
&amp;#125;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n;
    read(n);
    std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; mul(n + 1);
    std::vector&amp;lt;int&amp;gt; a(n + 1), l(n + 1), r(n + 1), pos(n + 1);
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        read(a[i]), pos[a[i]] = i;
        for (l[i] = i; l[i] != 1 &amp;amp;&amp;amp; a[i] &amp;lt; a[l[i] - 1]; l[i] = l[l[i] - 1]);
    &amp;#125;
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        for (int j = i; j &amp;lt;= n; j += i)
            mul[i].push_back(pos[j]);
        std::sort(mul[i].begin(), mul[i].end());
    &amp;#125;
    for (int i = n; i; --i)
        for (r[i] = i; r[i] != n &amp;amp;&amp;amp; a[i] &amp;lt; a[r[i] + 1]; r[i] = r[r[i] + 1]);
    struct query &amp;#123; int id, l, r; &amp;#125;;
    std::vector&amp;lt;std::vector&amp;lt;query&amp;gt; &amp;gt; ql(n + 1), qr(n + 1);
    for (int i = 1; i &amp;lt;= n; ++i)
        if (i - l[i] &amp;lt; r[i] - i)
            for (int j = l[i]; j &amp;lt; i; ++j)
                qr[a[i] / std::__gcd(a[i], a[j])].push_back(&amp;#123; j, i + 1, r[i] &amp;#125;);
        else
            for (int j = i + 1; j &amp;lt;= r[i]; ++j)
                ql[a[i] / std::__gcd(a[i], a[j])].push_back(&amp;#123; j, l[i], i - 1 &amp;#125;);
    std::vector&amp;lt;int&amp;gt; u(n + 1), rt(n + 1), bit(n + 1);
    auto lowbit = [](int x) &amp;#123;
        return x &amp;amp; -x;
    &amp;#125;;
    auto add = [&amp;amp;](int x, int v) &amp;#123;
        for (; x &amp;lt;= n; x += lowbit(x))
            bit[x] = v;
        return;
    &amp;#125;;
    std::function&amp;lt;int(int)&amp;gt; ask = [&amp;amp;](int x) &amp;#123;
        int res = 0;
        for (; x; x -= lowbit(x))
            res = std::max(res, bit[x]);
        return res;
    &amp;#125;;
    for (int fac = 1; fac &amp;lt;= n; ++fac) &amp;#123;
        std::sort(ql[fac].begin(), ql[fac].end(), [&amp;amp;](query x, query y) &amp;#123; return x.r &amp;lt; y.r; &amp;#125;);
        auto i = mul[fac].begin();
        for (auto [id, l, r] : ql[fac]) &amp;#123;
            for (; i != mul[fac].end() &amp;amp;&amp;amp; *i &amp;lt;= r; ++i)
                add(a[*i], *i);
            auto mx(ask(a[id]));
            if (mx &amp;gt;= l)
                u[id] = std::max(u[id], mx);
        &amp;#125;
        for (auto i : mul[fac])
            add(a[i], 0);
    &amp;#125;
    bit.assign(n + 1, 0x3f3f3f3f);
    ask = [&amp;amp;](int x) &amp;#123;
        int res = 0x3f3f3f3f;
        for (; x; x -= lowbit(x))
            res = std::min(res, bit[x]);
        return res;
    &amp;#125;;
    for (int fac = 1; fac &amp;lt;= n; ++fac) &amp;#123;
        std::sort(qr[fac].begin(), qr[fac].end(), [&amp;amp;](query x, query y) &amp;#123; return x.l &amp;gt; y.l; &amp;#125;);
        std::reverse(mul[fac].begin(), mul[fac].end());
        auto i = mul[fac].begin();
        for (auto [id, l, r] : qr[fac]) &amp;#123;
            for (; i != mul[fac].end() &amp;amp;&amp;amp; *i &amp;gt;= l; ++i)
                add(n - a[*i] + 1, *i);
            auto mn(ask(n - a[id] + 1));
            if (mn &amp;lt;= r)
                u[mn] = std::max(u[mn], id);
        &amp;#125;
        for (auto i : mul[fac])
            add(n - a[i] + 1, 0x3f3f3f3f);
    &amp;#125;
    std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; st(20, std::vector&amp;lt;int&amp;gt; (n + 1));
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        // if (u[i] != 0)
        //     printf(&amp;quot;%d %d\n&amp;quot;, u[i], i);
        st[0][i] = u[i];
    &amp;#125;
    for (int j = 1; (1 &amp;lt;&amp;lt; j) &amp;lt;= n; ++j)
        for (int i = 1; i + (1 &amp;lt;&amp;lt; j) - 1 &amp;lt;= n; ++i)
            st[j][i] = std::max(st[j - 1][i], st[j - 1][i + (1 &amp;lt;&amp;lt; (j - 1))]);
    auto askmx = [&amp;amp;](int l, int r) &amp;#123;
        int k = std::__lg(r - l + 1);
        return std::max(st[k][l], st[k][r - (1 &amp;lt;&amp;lt; k) + 1]);
    &amp;#125;;
    int q;
    read(q);
    for (int l, r; q--; ) &amp;#123;
        read(l), read(r);
        std::cout &amp;lt;&amp;lt; (askmx(l, r) &amp;gt;= l ? &amp;quot;Yes&amp;quot; : &amp;quot;No&amp;quot;) &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    &amp;#125;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;periodni&#34;&gt;# PERIODNI&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P6453&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P6453&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;cdq-分治&#34;&gt;CDQ 分治&lt;/h2&gt;
&lt;h3 id=&#34;coloring-nodes偏序很隐秘&#34;&gt;# Coloring Nodes（偏序很隐秘）&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P12423&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P12423&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;字典树&#34;&gt;字典树&lt;/h2&gt;
&lt;p&gt;字典树作为 log 数据结构的时候，等价权值线段树，而且支持合并、分裂（权值线段树 also OK，强调一下而已）&lt;/p&gt;
&lt;p&gt;有些情景 Trie 写起来会比权值线段树舒服一些，比如值域操作、二进制操作之类&lt;/p&gt;
&lt;h3 id=&#34;异或粽子&#34;&gt;# 异或粽子&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P5283&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P5283&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;friends&#34;&gt;# Friends&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/CF241B&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/CF241B&lt;/a&gt;&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://xsc062.netlify.app/20250816/</guid>
            <title>近期杂题 II</title>
            <link>https://xsc062.netlify.app/20250816/</link>
            <category>线段树</category>
            <category>AC 自动机</category>
            <category>贪心</category>
            <category>DP 优化</category>
            <category>虚树</category>
            <pubDate>Sat, 16 Aug 2025 16:14:12 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;和 Aug 9th 的杂题不太能合并，所以分开了&lt;/p&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;b.-gas-fire-extinguishers&#34;&gt;B. GAS-Fire Extinguishers&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P3479&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P3479&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;显然可以贪心，不妨从下到上，记录当前遍历过的、空余出来的灭火器（其实算的是可以供给的房间数）和还未分配灭火器的房间，按距离为 &lt;span class=&#34;math inline&#34;&gt;\(0\sim k\)&lt;/span&gt; 分组。&lt;/p&gt;
&lt;p&gt;不难发现如果在某个点 &lt;span class=&#34;math inline&#34;&gt;\(u\)&lt;/span&gt; 处存在距离为 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 的空闲灭火器，可以贪心地分配给 &lt;span class=&#34;math inline&#34;&gt;\(u\)&lt;/span&gt;；如果存在距离为 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 的未分配房间，也可以在 &lt;span class=&#34;math inline&#34;&gt;\(u\)&lt;/span&gt; 处放置灭火器并分配给这些房间。类似地，进行两两配对一定是不劣的。&lt;/p&gt;
&lt;p&gt;发现同子树内距离为 &lt;span class=&#34;math inline&#34;&gt;\(k-1\)&lt;/span&gt; 的点对留到 &lt;span class=&#34;math inline&#34;&gt;\(fa\)&lt;/span&gt; 再匹配是不行的，因为这时距离会变成 &lt;span class=&#34;math inline&#34;&gt;\(k+1\)&lt;/span&gt;，不能匹配上；可以感受到这样是更劣的。&lt;/p&gt;
&lt;p&gt;然后就可以做了，根节点特殊乱贪心一下就行了。记得开 long long。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
#define int long long
signed main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, s, k, res = 0;
    std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; s &amp;gt;&amp;gt; k;
    std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; g(n + 1), p(n + 1, std::vector&amp;lt;int&amp;gt; (k + 1)), q(n + 1, std::vector&amp;lt;int&amp;gt; (k + 1));
    for (int i = 1, x, y; i &amp;lt; n; ++i) &amp;#123;
        std::cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; y;
        g[x].push_back(y), g[y].push_back(x);
    &amp;#125;
    std::function&amp;lt;void(int, int)&amp;gt; DFS = [&amp;amp;](int x, int fa) &amp;#123;
        for (auto i : g[x])
            if (i != fa)  &amp;#123;
                DFS(i, x);
                for (int j = 0; j &amp;lt; k; ++j)
                    p[x][j + 1] += p[i][j], q[x][j + 1] += q[i][j];
            &amp;#125;
        ++q[x][0];
        if (x != 1) &amp;#123;
            int v = (q[x][k] + s - 1) / s;
            p[x][0] = v * s, res += v;
            for (int i = 0; i &amp;lt;= k; ++i) &amp;#123;
                int v = std::min(p[x][i], q[x][k - i]);
                p[x][i] -= v, q[x][k - i] -= v;
            &amp;#125;
            for (int i = 0; i &amp;lt; k; ++i) &amp;#123;
                int v = std::min(p[x][i], q[x][k - 1 - i]);
                p[x][i] -= v, q[x][k - 1 - i] -= v;
            &amp;#125;
        &amp;#125;
        else &amp;#123;
            // std::cerr &amp;lt;&amp;lt; res &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
            int sum = 0ll, r = 0;
            for (int i = k; ~i; --i) &amp;#123;
                sum += p[x][k - i];
                // std::cerr &amp;lt;&amp;lt; sum &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
                int v = std::min(sum, q[x][i]);
                sum -= v, q[x][i] -= v;
                r += q[x][i];
            &amp;#125;
            res += (r + s - 1) / s;
        &amp;#125;
        return;
    &amp;#125;;
    DFS(1, -1);
    std::cout &amp;lt;&amp;lt; res &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;c.-扫地机器人&#34;&gt;C. 扫地机器人&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://222.180.160.110:61235/contest/6502/problem/3&#34; class=&#34;uri&#34;&gt;http://222.180.160.110:61235/contest/6502/problem/3&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;题意：给定 &lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt; 堆货物，每堆货物有重量 &lt;span class=&#34;math inline&#34;&gt;\(v_i\)&lt;/span&gt; 和一个参数 &lt;span class=&#34;math inline&#34;&gt;\(a_i\)&lt;/span&gt;。有一个初始负载为 &lt;span class=&#34;math inline&#34;&gt;\(0\)&lt;/span&gt;、负载上限为 &lt;span class=&#34;math inline&#34;&gt;\(c\)&lt;/span&gt; 的机器人，从 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt; 到 &lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt; 遍历这些货物，对每一处货物执行以下操作，直到清空这堆货物：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当前负载未满：可以选择进行装载直到达到负载上限，或货物清空。花费 &lt;span class=&#34;math inline&#34;&gt;\(a_i\)&lt;/span&gt; 的代价。&lt;/li&gt;
&lt;li&gt;不管当前负载满没满：可以选择清空当前负载，花费 &lt;span class=&#34;math inline&#34;&gt;\(b\)&lt;/span&gt; 的代价。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;每一处可以任意操作，要求遍历完之后机器人负载为 &lt;span class=&#34;math inline&#34;&gt;\(0\)&lt;/span&gt;，问最小代价。&lt;span class=&#34;math inline&#34;&gt;\(n\le 2\times 10^5,c\le 10^9\)&lt;/span&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;em&gt;题面是重构过的，原来的题面太有歧义了。绝大多数人没做出来就是因为没看懂题吧！&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;考虑暴力，可以想到令 &lt;span class=&#34;math inline&#34;&gt;\(f_{i,j}\)&lt;/span&gt; 表示处理完 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 过后负载为 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; 的最小代价（显然 &lt;span class=&#34;math inline&#34;&gt;\(f_{i,c}\)&lt;/span&gt; 和 &lt;span class=&#34;math inline&#34;&gt;\(f_{i,0}\)&lt;/span&gt; 是等效的，故舍弃前者）。记 &lt;span class=&#34;math inline&#34;&gt;\(k=\left\lceil\dfrac {v_i}c\right\rceil,w=(v_i\bmod c - 1)\bmod c+1\)&lt;/span&gt;，那么有：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
f_{i,(j+v_i)\bmod c}\gets f_{i-1,j}+k\cdot a_i+(k-1)\cdot b +
\begin{cases}
b&amp;amp;j+w=c\\
a_i+b&amp;amp;j+w&amp;gt; c\\
0&amp;amp;\text{otherwise}
\end{cases}\\
f_{i,0}\gets f_{i,j}+b
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;发现 &lt;span class=&#34;math inline&#34;&gt;\(f_{i-1}\)&lt;/span&gt; 和 &lt;span class=&#34;math inline&#34;&gt;\(f_i\)&lt;/span&gt; 之间是存在对应关系的，所以考虑直接继承（真实的 &lt;span class=&#34;math inline&#34;&gt;\(0\)&lt;/span&gt; 应该位于 &lt;span class=&#34;math inline&#34;&gt;\(-s_i\)&lt;/span&gt; 的位置），再做全局加、区间加，&lt;span class=&#34;math inline&#34;&gt;\(f_{i,0}\)&lt;/span&gt; 的转移是全局 min，线段树维护即可；每次只会新增一个状态，动态开点即可。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int maxn = 5e6 + 5;
const __int128 inf = 1e18;
struct &amp;#123;
    int l, r;
    __int128 u, d;
&amp;#125; t[maxn];
#define lt t[p].l
#define rt t[p].r
int tot;
void pushdown(int p) &amp;#123;
    if (t[p].d) &amp;#123;
        t[lt].d += t[p].d, t[lt].u += t[p].d;
        t[rt].d += t[p].d, t[rt].u += t[p].d;
        t[p].d = 0ll;
    &amp;#125;
    return;
&amp;#125;
void upd(int &amp;amp;p, int l, int r, int x, __int128 v) &amp;#123;
    if (!p)
        p = ++tot, t[p].u = v;
    else
        t[p].u = std::min(t[p].u, v);
    if (l == r)
        return;
    pushdown(p);
    int mid = (l + r) &amp;gt;&amp;gt; 1;
    if (x &amp;lt;= mid)
        upd(lt, l, mid, x, v);
    else
        upd(rt, mid + 1, r, x, v);
    return;
&amp;#125;
void add(int p, int l, int r, int ql, int qr, __int128 v) &amp;#123;
    if (!p)
        return;
    if (ql &amp;lt;= l &amp;amp;&amp;amp; r &amp;lt;= qr) &amp;#123;
        t[p].d += v, t[p].u += v;
        return;
    &amp;#125;
    int mid = (l + r) &amp;gt;&amp;gt; 1;
    pushdown(p);
    if (ql &amp;lt;= mid)
        add(lt, l, mid, ql, qr, v);
    if (qr &amp;gt; mid)
        add(rt, mid + 1, r, ql, qr, v);
    t[p].u = std::min(t[lt].u, t[rt].u);
    return;
&amp;#125;
__int128 ask(int p, int l, int r, int x) &amp;#123;
    if (l == r)
        return t[p].u;
    int mid = (l + r) &amp;gt;&amp;gt; 1;
    pushdown(p);
    if (x &amp;lt;= mid)
        return ask(lt, l, mid, x);
    return ask(rt, mid + 1, r, x);
&amp;#125;
#undef lt
#undef rt
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
    std::freopen(&amp;quot;robot.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;robot.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#else
    std::freopen(&amp;quot;ex_robot4.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    t[0].u = inf;
    int n, b, c, p0 = 0, rt = 0;
    std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; c &amp;gt;&amp;gt; b;
    std::vector&amp;lt;int&amp;gt; a(n + 1), v(n + 1);
    for (int i = 1; i &amp;lt;= n; ++i)
        std::cin &amp;gt;&amp;gt; a[i];
    for (int i = 1; i &amp;lt;= n; ++i)
        std::cin &amp;gt;&amp;gt; v[i];
    upd(rt, 0, c - 1, 0, 0ll);
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        __int128 k = (v[i] + c - 1) / c, w = (v[i] % c == 0 ? c : v[i] % c);
        t[rt].d += k * a[i] + (k - 1) * b;
        t[rt].u += k * a[i] + (k - 1) * b;
        if (w &amp;lt;= c)
            add(rt, 0, c - 1, (c - w + p0) % c, (c - w + p0) % c, b);
        if (w != 1) &amp;#123;
            int l = (c - w + p0 + 1) % c, r = (p0 + c - 1) % c;
            if (l &amp;lt;= r)
                add(rt, 0, c - 1, l, r, a[i] + b);
            else &amp;#123;
                add(rt, 0, c - 1, 0, r, a[i] + b);
                add(rt, 0, c - 1, l, c - 1, a[i] + b);
            &amp;#125;
        &amp;#125;
        p0 = (p0 + c - v[i] % c) % c;
        upd(rt, 0, c - 1, p0, t[rt].u + b);
    &amp;#125;
    std::cout &amp;lt;&amp;lt; (long long)ask(rt, 0, c - 1, p0) &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;d.-套娃&#34;&gt;D. 套娃&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://222.180.160.110:61235/contest/6502/problem/4&#34; class=&#34;uri&#34;&gt;http://222.180.160.110:61235/contest/6502/problem/4&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;题意：给定初始为全 &lt;span class=&#34;math inline&#34;&gt;\(0\)&lt;/span&gt; 的数组 &lt;span class=&#34;math inline&#34;&gt;\(a_{1\sim n + 1}\)&lt;/span&gt; 和 &lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt; 次单点 +1 操作，每次操作后，求解：&lt;/p&gt;
&lt;p&gt;令 &lt;span class=&#34;math inline&#34;&gt;\(a\)&lt;/span&gt; 的前缀和数组为 &lt;span class=&#34;math inline&#34;&gt;\(s\)&lt;/span&gt;，找到一个最小的 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt;，使得对于每个 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt;，均有 &lt;span class=&#34;math inline&#34;&gt;\(k\cdot i\ge s_i\)&lt;/span&gt; 成立。&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(n\le 10^6\)&lt;/span&gt;，时限 0.5s。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;details&gt;
&lt;p&gt;&lt;summary&gt;趣事一则&lt;/summary&gt;&lt;/p&gt;
&lt;p&gt;考场上最后 10min 拿到题，憋了一个能拿到 96pts 的假做法：注意到前缀和是单增的，需要维护最大的 &lt;span class=&#34;math inline&#34;&gt;\(\dfrac {s_i}i\)&lt;/span&gt;，由于后缀 +1 带来的影响很小，所以可以猜测在大多数情况下最大的 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 只会在原来的和修改的点之间变化。只用 10 行的核心代码就能拿到很多分。但是居然有这么多，可能出题人都没有想到真有人敢交这种做法吧。&lt;/p&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
int main() &amp;#123;
    std::freopen(&amp;quot;doll.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;doll.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
    auto stime = std::chrono::steady_clock::now();
    int n, res = 0;
    std::cin &amp;gt;&amp;gt; n;
    std::vector&amp;lt;int&amp;gt; bit(n + 2);
    auto lowbit = [](int x) &amp;#123;
        return x &amp;amp; -x;
    &amp;#125;;
    auto add = [&amp;amp;](int x) &amp;#123;
        for (; x &amp;lt;= n + 1; x += lowbit(x))
            ++bit[x];
        return;
    &amp;#125;;
    auto ask = [&amp;amp;](int x) &amp;#123;
        int res = 0;
        for (; x; x -= lowbit(x))
            res += bit[x];
        return res;
    &amp;#125;;
    int p = 1;
    for (int i = 1, x; i &amp;lt;= n; ++i) &amp;#123;
        std::cin &amp;gt;&amp;gt; x, add(++x);
        long long s = ask(x), t = ask(p);
        if (s * p == t * x ? x &amp;gt; p : s * p &amp;gt; t * x)
            p = x;
        else
            s = t;
        if (s &amp;gt; p * res)
            ++res;
        std::cout &amp;lt;&amp;lt; res &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
    &amp;#125;
    std::cout &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    std::cerr &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt;(std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;p&gt;很容易写出暴力，观察样例就能发现每次修改后答案最多增加 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt;。记当前答案为 &lt;span class=&#34;math inline&#34;&gt;\(res\)&lt;/span&gt;，线段树维护 &lt;span class=&#34;math inline&#34;&gt;\(s_i-res\cdot i\)&lt;/span&gt; 的最小值，若其为负则 res++，然后重构线段树（等差数列和 min 不兼容）。&lt;/p&gt;
&lt;p&gt;怎么又有不等式 😱&lt;/p&gt;
&lt;p&gt;目的是在本来合法的范围里找到新的不合法值。考虑合法范围：&lt;span class=&#34;math inline&#34;&gt;\(s_i-res\cdot i\ge 0\)&lt;/span&gt;，解一下得到 &lt;span class=&#34;math inline&#34;&gt;\(i\le \dfrac {s_i}{res}\)&lt;/span&gt;，放缩得到 &lt;span class=&#34;math inline&#34;&gt;\(i\le\dfrac {n}{res}\)&lt;/span&gt;，每次 &lt;span class=&#34;math inline&#34;&gt;\(res\)&lt;/span&gt; 变化时只重构 &lt;span class=&#34;math inline&#34;&gt;\(\dfrac {n}{res}\)&lt;/span&gt; 以前的位置，重构的总长是 &lt;span class=&#34;math inline&#34;&gt;\(O(n\ln n)\)&lt;/span&gt; 的。（线段树建树是线性的）&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int maxn = 1e6 + 5;
const int inf = 0x3f3f3f3f;
struct &amp;#123;
    int l, r, u, d;
&amp;#125; t[maxn &amp;lt;&amp;lt; 2];
#define lt (p &amp;lt;&amp;lt; 1)
#define rt (lt | 1)
void bld(int p, int l, int r) &amp;#123;
    t[p].u = t[p].l = l, t[p].r = r;
    if (l == r)
        return;
    int mid = (l + r) &amp;gt;&amp;gt; 1;
    bld(lt, l, mid), bld(rt, mid + 1, r);
    return;
&amp;#125;
void pushdown(int p) &amp;#123;
    if (t[p].d) &amp;#123;
        t[lt].d += t[p].d, t[rt].d += t[p].d;
        t[lt].u -= t[p].d, t[rt].u -= t[p].d;
        t[p].d = 0;
    &amp;#125;
    return;
&amp;#125;
void add(int p, int x) &amp;#123;
    if (x &amp;lt;= t[p].l) &amp;#123;
        ++t[p].d, --t[p].u;
        return;
    &amp;#125;
    pushdown(p);
    int mid = (t[p].l + t[p].r) &amp;gt;&amp;gt; 1;
    if (x &amp;lt;= mid)
        add(lt, x);
    add(rt, x);
    t[p].u = std::min(t[lt].u, t[rt].u);
    // printf(&amp;quot;[%d, %d]: %d, [%d, %d]: %d\n&amp;quot;, t[p].l, mid, t[lt].u, mid + 1, t[p].r, t[rt].u);
    return;
&amp;#125;
void rem(int p, int r) &amp;#123;
    if (t[p].l == t[p].r) &amp;#123;
        t[p].u += t[p].l;
        return;
    &amp;#125;
    pushdown(p);
    int mid = (t[p].l + t[p].r) &amp;gt;&amp;gt; 1;
    if (r &amp;lt;= mid)
        rem(lt, r), t[rt].u = inf;
    else
        rem(lt, r), rem(rt, r);
    t[p].u = std::min(t[lt].u, t[rt].u);
    return;
&amp;#125;
#undef lt
#undef rt
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
    std::freopen(&amp;quot;doll.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;doll.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n;
    std::cin &amp;gt;&amp;gt; n;
    bld(1, 1, n + 1);
    for (int i = 1, x, res = 1, now = n; i &amp;lt;= n; ++i) &amp;#123;
        std::cin &amp;gt;&amp;gt; x;
        if (x &amp;lt;= now)
            add(1, ++x);
        if (t[1].u &amp;lt; 0) &amp;#123;
            std::cout &amp;lt;&amp;lt; ++res &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
            rem(1, now = n / res);
        &amp;#125;
        else
            std::cout &amp;lt;&amp;lt; res &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
        // puts(&amp;quot;&amp;quot;);
    &amp;#125;
    std::cout &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;e---subarray-sum-divisibility&#34;&gt;E - Subarray Sum Divisibility&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/abc419/tasks/abc419_e&#34; class=&#34;uri&#34;&gt;https://atcoder.jp/contests/abc419/tasks/abc419_e&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;模意义下的数列全等，可以对应原数组全等、差分全等、前缀和全等（都是模意义下的，还有其他的一些线性和非线性的变换也可以）&lt;/p&gt;
&lt;p&gt;本着修改的点尽量少的想法，如果题目给定单点修改就可以在原数组上做文章，给定区间修改可以考虑差分数组，前缀和对于一些区间查询有优势&lt;/p&gt;
&lt;p&gt;其他两种用得也很多，像这题只需要用原数组全等就可以做了&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int inf = 0x3f3f3f3f;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, m, l;
    std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m &amp;gt;&amp;gt; l;
    std::vector&amp;lt;int&amp;gt; a(n + 1);
    for (int i = 1; i &amp;lt;= n; ++i)
        std::cin &amp;gt;&amp;gt; a[i];
    std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; u(l + 1, std::vector&amp;lt;int&amp;gt; (m));
    for (int i = 1; i &amp;lt;= l; ++i)
        for (int j = 0; j &amp;lt; m; ++j)
            for (int k = i; k &amp;lt;= n; k += l)
                u[i][j] += (j + m - a[k]) % m;
    std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; f(l + 1, std::vector&amp;lt;int&amp;gt; (m, inf));
    f[0][0] = 0;
    for (int i = 1; i &amp;lt;= l; ++i)
        for (int j = 0; j &amp;lt; m; ++j)
            for (int k = 0; k &amp;lt; m; ++k)
                f[i][(j + k) % m] = std::min(f[i][(j + k) % m], f[i - 1][j] + u[i][k]);
    std::cout &amp;lt;&amp;lt; f[l][0] &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;f---all-included&#34;&gt;F - All Included&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/abc419/tasks/abc419_f&#34; class=&#34;uri&#34;&gt;https://atcoder.jp/contests/abc419/tasks/abc419_f&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;原题意转化为在 AC 自动机上走 &lt;span class=&#34;math inline&#34;&gt;\(L\)&lt;/span&gt; 步，要求经过 &lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt; 个叶子的方案数。不太可做，转化成容斥（令字符串终点不可达）。在外层枚举步数暴力游走。&lt;/p&gt;
&lt;p&gt;要求恰好走 &lt;span class=&#34;math inline&#34;&gt;\(L\)&lt;/span&gt; 步，也可以用矩阵；但原图很稀疏，所以矩阵并没有优势。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int mod = 998244353;
int tot = 1, T[805][26], fail[805];
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, l;
    std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; l;
    std::vector&amp;lt;std::string&amp;gt; a;
    &amp;#123;
        std::vector&amp;lt;std::string&amp;gt; s(n + 1);
        for (int i = 1; i &amp;lt;= n; ++i)
            std::cin &amp;gt;&amp;gt; s[i];
        for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
            bool flag = 1;
            for (int j = 1; j &amp;lt;= n; ++j)
                if (j != i)
                    if (s[j].find(s[i]) != std::string::npos) &amp;#123;
                        flag = 0;
                        break;
                    &amp;#125;
            if (flag)
                a.push_back(s[i]);
        &amp;#125;
        n = (int)a.size();
    &amp;#125;
    std::vector&amp;lt;int&amp;gt; pos(n);
    for (int i = 0; i &amp;lt; n; ++i) &amp;#123;
        int &amp;amp;p = pos[i];
        for (auto j : a[i]) &amp;#123;
            if (!T[p][j - &amp;#39;a&amp;#39;])
                T[p][j - &amp;#39;a&amp;#39;] = tot++;
            p = T[p][j - &amp;#39;a&amp;#39;];
        &amp;#125;
    &amp;#125;
    &amp;#123;
        std::queue&amp;lt;int&amp;gt; q;
        for (int i = 0; i &amp;lt; 26; ++i)
            if (T[0][i])
                q.push(T[0][i]);
        for (; !q.empty(); ) &amp;#123;
            int u = q.front();
            q.pop();
            for (int i = 0; i &amp;lt; 26; ++i)
                if (T[u][i]) &amp;#123;
                    int v = T[u][i];
                    fail[v] = T[fail[u]][i];
                    q.push(v);
                &amp;#125;
                else
                    T[u][i] = T[fail[u]][i];
        &amp;#125;
    &amp;#125;
    auto res = 0ll;
    int siz = 1 &amp;lt;&amp;lt; n;
    for (int i = 0; i &amp;lt; siz; ++i) &amp;#123;
        std::vector&amp;lt;int&amp;gt; tag(tot);
        for (int j = 0; j &amp;lt; n; ++j)
            if ((i &amp;gt;&amp;gt; j) &amp;amp; 1)
                tag[pos[j]] = 1;
        std::vector&amp;lt;std::vector&amp;lt;long long&amp;gt; &amp;gt; f(l + 1, std::vector&amp;lt;long long&amp;gt; (tot));
        f[0][0] = 1ll;
        for (int j = 0; j &amp;lt; l; ++j)
            for (int k = 0; k &amp;lt; tot; ++k)
                for (int a = 0; a &amp;lt; 26; ++a) &amp;#123;
                    if (!tag[T[k][a]])
                        (f[j + 1][T[k][a]] += f[j][k]) %= mod;
                &amp;#125;
        int k = (__builtin_popcount(i) &amp;amp; 1 ? mod - 1 : 1);
        auto s = 0ll;
        for (int j = 0; j &amp;lt; tot; ++j)
            if (!tag[j])
                (s += f[l][j]) %= mod;
        (res += k * s) %= mod;
    &amp;#125;
    std::cout &amp;lt;&amp;lt; res &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;g---count-simple-paths-2&#34;&gt;G - Count Simple Paths 2&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/abc419/tasks/abc419_g&#34; class=&#34;uri&#34;&gt;https://atcoder.jp/contests/abc419/tasks/abc419_g&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;很新的性质。考虑『以 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt; 为起点的简单路径数』和反祖边数量的关系：选定一条反祖边必须被经过时（显然只有一种可能的经过方向），树的形态发生变化：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;也就是说，一种反祖边的选取方案对应一种树，遍历其从 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt; 开始的简单路径复杂度为 &lt;span class=&#34;math inline&#34;&gt;\(O(n)\)&lt;/span&gt;。设反祖边数量为 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt;，那么合法的方案数不超过 &lt;span class=&#34;math inline&#34;&gt;\(2^k\)&lt;/span&gt;，暴力 DFS 的整个图复杂度为 &lt;span class=&#34;math inline&#34;&gt;\(O(2^k\cdot n)\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;发现很多跟反祖边无关的遍历是不必要的（只有一种走法，可以设成边权），考虑对所有连接反祖边的点建立虚树，并把原树上的反祖边也移到虚树上，就能 &lt;span class=&#34;math inline&#34;&gt;\(O(2^k\cdot k)\)&lt;/span&gt; 解决问题。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, m;
    std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
    std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; g(n + 1), g1(n + 1);
    std::vector&amp;lt;std::vector&amp;lt;std::pair&amp;lt;int, int&amp;gt; &amp;gt; &amp;gt; g2(n + 1);
    for (int x, y; m--; ) &amp;#123;
        std::cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; y;
        g[x].push_back(y), g[y].push_back(x);
    &amp;#125;
    std::vector&amp;lt;int&amp;gt; tag(n + 1), vis(n + 1);
    std::vector&amp;lt;std::pair&amp;lt;int, int&amp;gt; &amp;gt; be;
    std::function&amp;lt;void(int, int)&amp;gt; DFS = [&amp;amp;](int x, int fa) &amp;#123;
        static int now = 0;
        tag[x] = 1, vis[x] = ++now;
        for (auto i : g[x])
            if (!tag[i]) &amp;#123;
                // fprintf(stderr, &amp;quot;%d -&amp;gt; %d\n&amp;quot;, x, i);
                g1[x].push_back(i), DFS(i, x);
            &amp;#125;
            else if (i != fa &amp;amp;&amp;amp; vis[i] &amp;lt; vis[x])
                be.emplace_back(i, x);
        return;
    &amp;#125;;
    DFS(1, -1);
    &amp;#123; // 求虚树
        std::vector&amp;lt;int&amp;gt; dep(n + 1), fa(n + 1), top(n + 1), siz(n + 1), son(n + 1), dfn(n + 1), rfn(n + 1);
        std::function&amp;lt;void(int)&amp;gt; DFS = [&amp;amp;](int x) &amp;#123;
            siz[x] = 1;
            for (auto i : g1[x]) &amp;#123;
                dep[i] = dep[x] + 1;
                fa[i] = x, DFS(i);
                siz[x] += siz[i];
                if (siz[i] &amp;gt; siz[son[x]])
                    son[x] = i;
            &amp;#125;
            return;
        &amp;#125;;
        DFS(1);
        DFS = [&amp;amp;](int x) &amp;#123;
            static int now = 0;
            dfn[x] = ++now;
            if (son[x])
                top[son[x]] = top[x], DFS(son[x]);
            for (auto i : g1[x])
                if (i != son[x])
                    top[i] = i, DFS(i);
            rfn[x] = now;
            // printf(&amp;quot;%d: [%d, %d]\n&amp;quot;, x, dfn[x], rfn[x]);
            return;
        &amp;#125;;
        top[1] = 1, DFS(1);
        auto getLCA = [&amp;amp;](int x, int y) &amp;#123;
            for (; top[x] != top[y]; x = fa[top[x]])
                if (dep[top[x]] &amp;lt; dep[top[y]])
                    std::swap(x, y);
            return dep[x] &amp;lt; dep[y] ? x : y;
        &amp;#125;;
        tag.assign(n + 1, 0);
        tag[1] = tag[n] = 1;
        for (auto [u, v] : be)
            tag[u] = 1, tag[v] = 1;
        std::vector&amp;lt;int&amp;gt; p;
        for (int i = 1; i &amp;lt;= n; ++i)
            if (tag[i])
                p.push_back(i);
        std::sort(p.begin(), p.end(), [&amp;amp;](int i, int j) &amp;#123; return dfn[i] &amp;lt; dfn[j]; &amp;#125;);
        for (int i = 1; i &amp;lt; (int)p.size(); ++i) &amp;#123;
            int fa = getLCA(p[i], p[i - 1]);
            if (!tag[fa])
                tag[fa] = 1;
        &amp;#125;
        p.clear();
        for (int i = 1; i &amp;lt;= n; ++i)
            if (tag[i])
                p.push_back(i);
        std::sort(p.begin(), p.end(), [&amp;amp;](int i, int j) &amp;#123; return dfn[i] &amp;lt; dfn[j]; &amp;#125;);
        std::vector&amp;lt;int&amp;gt; st;
        for (auto i : p) &amp;#123;
            if (st.empty())
                st.push_back(i);
            else &amp;#123;
                for (; rfn[st.back()] &amp;lt; dfn[i]; st.pop_back());
                g2[st.back()].emplace_back(i, dep[i] - dep[st.back()]);
                g2[i].emplace_back(st.back(), dep[i] - dep[st.back()]);
                // printf(&amp;quot;add (%d, %d): %d\n&amp;quot;, st.back(), i, dep[i] - dep[st.back()]);
                st.push_back(i);
            &amp;#125;
        &amp;#125;
        for (auto [u, v] : be) &amp;#123;
            g2[u].emplace_back(v, 1), g2[v].emplace_back(u, 1);
            // printf(&amp;quot;# add(%d, %d): 1\n&amp;quot;, u, v);
        &amp;#125;
    &amp;#125;
    tag.assign(n + 1, 0);
    std::vector&amp;lt;int&amp;gt; res(n + 1);
    DFS = [&amp;amp;](int x, int s) &amp;#123;
        if (x == n)
            ++res[s];
        tag[x] = 1;
        for (auto [i, w] : g2[x])
            if (!tag[i])
                DFS(i, s + w);
        tag[x] = 0;
        return;
    &amp;#125;;
    DFS(1, 0);
    for (int i = 1; i &amp;lt; n; ++i)
        std::cout &amp;lt;&amp;lt; res[i] &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
    std::cout &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://xsc062.netlify.app/20250814/</guid>
            <title>DDP 与 GBT 练习</title>
            <link>https://xsc062.netlify.app/20250814/</link>
            <category>线段树</category>
            <category>DDP</category>
            <pubDate>Thu, 14 Aug 2025 17:08:21 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;线段树是对的（存疑）&lt;/p&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;a---数据传输&#34;&gt;A - 数据传输&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P8820&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P8820&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我在上一篇文章中提到了 &lt;a href=&#34;/20250812/#树上路径查询&#34;&gt;DDP &amp;amp; 路径查询问题&lt;/a&gt;，在这个题中就有体现。&lt;/p&gt;
&lt;p&gt;设 &lt;span class=&#34;math inline&#34;&gt;\(f_{u,0/1/2}\)&lt;/span&gt; 表示数据保存在 &lt;span class=&#34;math inline&#34;&gt;\(u\)&lt;/span&gt; 往下数 &lt;span class=&#34;math inline&#34;&gt;\(0/1/2\)&lt;/span&gt; 个点处的最小代价，手玩容易发现 &lt;span class=&#34;math inline&#34;&gt;\(k=3\)&lt;/span&gt; 时&lt;strong&gt;最优路径可能会往某个 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 或 &lt;span class=&#34;math inline&#34;&gt;\(fa\)&lt;/span&gt; 处的最小代价儿子处绕一圈来避免这个 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 或 &lt;span class=&#34;math inline&#34;&gt;\(fa\)&lt;/span&gt; 的代价&lt;/strong&gt;。但该值是定值，问题还是纯路径问题，就可以 DDP 了。&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&#34;image.png&#34; alt=&#34;共两种可能性（任意一个箭头长度不为 3 时绕一圈一定不比直接走更优）&#34; /&gt;&lt;figcaption&gt;共两种可能性（任意一个箭头长度不为 &lt;span class=&#34;math inline&#34;&gt;\(3\)&lt;/span&gt; 时绕一圈一定不比直接走更优）&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
struct mat &amp;#123;
    long long a[3][3];
    long long* operator[] (const int q) &amp;#123;
        return a[q];
    &amp;#125;
    mat() &amp;#123;
        memset(a, 0x3f, sizeof (a));
        return;
    &amp;#125;
    mat(int flag) &amp;#123;
        memset(a, 0x3f, sizeof (a));
        a[0][0] = a[1][1] = a[2][2] = 0ll;
        return;
    &amp;#125;
    mat operator* (mat &amp;amp;q) const &amp;#123;
        mat res;
        for (int i = 0; i &amp;lt; 3; ++i)
            for (int k = 0; k &amp;lt; 3; ++k)
                for (int j = 0; j &amp;lt; 3; ++j)
                    res[i][k] = std::min(res[i][k], a[i][j] + q[j][k]);
        return res;
    &amp;#125;
    mat&amp;amp; operator*= (mat &amp;amp;q) &amp;#123;
        return *this = *this * q;
    &amp;#125;
&amp;#125;;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, q, k;
    std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; q &amp;gt;&amp;gt; k;
    std::vector&amp;lt;int&amp;gt; a(n + 1);
    for (int i = 1; i &amp;lt;= n; ++i)
        std::cin &amp;gt;&amp;gt; a[i];
    std::vector&amp;lt;int&amp;gt; mx(n + 1, 0x3f3f3f3f);
    std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; g1(n + 1);
    for (int i = 1, x, y; i &amp;lt; n; ++i) &amp;#123;
        std::cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; y;
        mx[x] = std::min(mx[x], a[y]);
        mx[y] = std::min(mx[y], a[x]);
        g1[x].push_back(y), g1[y].push_back(x);
    &amp;#125;
    std::vector&amp;lt;int&amp;gt; dep(n + 1);
    std::vector&amp;lt;std::array&amp;lt;int, 18&amp;gt; &amp;gt; f(n + 1);
    std::vector&amp;lt;std::array&amp;lt;mat, 18&amp;gt; &amp;gt; u(n + 1), d(n + 1);
    u[0][0] = d[0][0] = mat(1);
    std::function&amp;lt;void(int)&amp;gt; DFS = [&amp;amp;](int x) &amp;#123;
        for (auto i : g1[x])
            if (i != f[x][0]) &amp;#123;
                f[i][0] = x;
                &amp;#123;
                    mat s;
                    s[0][0] = a[x];
                    if (k &amp;gt;= 2) &amp;#123;
                        s[0][1] = 0;
                        s[1][0] = a[x];
                    &amp;#125;
                    if (k &amp;gt;= 3) &amp;#123;
                        s[1][2] = 0;
                        s[2][0] = a[x];
                        s[1][1] = mx[x];
                        s[2][2] = mx[i];
                    &amp;#125;
                    u[i][0] = s; 
                    s[0][0] = a[i];
                    if (k &amp;gt;= 2)
                        s[1][0] = a[i];
                    if (k &amp;gt;= 3) &amp;#123;
                        s[2][0] = a[i];
                        s[1][1] = mx[i];
                        s[2][2] = mx[x];
                    &amp;#125;
                    d[i][0] = s; 
                &amp;#125;
                for (int j = 1; j &amp;lt; 18; ++j) &amp;#123;
                    f[i][j] = f[f[i][j - 1]][j - 1];
                    u[i][j] = u[i][j - 1] * u[f[i][j - 1]][j - 1];
                    d[i][j] = d[f[i][j - 1]][j - 1] * d[i][j - 1];
                &amp;#125;
                dep[i] = dep[x] + 1;
                DFS(i);
            &amp;#125;
        return;
    &amp;#125;;
    dep[1] = 1, DFS(1);
    for (int x, y; q--; ) &amp;#123;
        std::cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; y;
        long long res = a[x];
        mat r1(1), r2(1);
        if (dep[x] &amp;gt; dep[y]) &amp;#123;
            for (int i = 17; ~i; --i)
                if (dep[f[x][i]] &amp;gt;= dep[y]) &amp;#123;
                    r1 = r1 * u[x][i];
                    x = f[x][i];
                &amp;#125;
        &amp;#125;
        else if (dep[y] &amp;gt; dep[x]) &amp;#123;
            for (int i = 17; ~i; --i)
                if (dep[f[y][i]] &amp;gt;= dep[x]) &amp;#123;
                    r2 = d[y][i] * r2;
                    y = f[y][i];
                &amp;#125;
        &amp;#125;
        if (x != y) &amp;#123;
            for (int i = 17; ~i; --i)
                if (f[x][i] != f[y][i]) &amp;#123;
                    r1 = r1 * u[x][i];
                    r2 = d[y][i] * r2;
                    x = f[x][i], y = f[y][i];
                &amp;#125;
            r1 = r1 * u[x][0], r2 = d[y][0] * r2;
        &amp;#125;
        std::cout &amp;lt;&amp;lt; res + (r1 * r2)[0][0] &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    &amp;#125;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;b---the-silk-road-with-robots&#34;&gt;B - The Silk Road … with Robots!&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://qoj.ac/problem/10410&#34; class=&#34;uri&#34;&gt;https://qoj.ac/problem/10410&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;题意：初始有一个长为 &lt;span class=&#34;math inline&#34;&gt;\(10^8\)&lt;/span&gt; 的空数轴，给定 &lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt; 次操作，每次操作在数轴上的一个空位放一个 A 类点或 B 类点。每个 A 类点有其&lt;strong&gt;价值&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;任意在数轴上移动这些 B 类点，&lt;strong&gt;总价值&lt;/strong&gt;为所有被经过的 A 类点的&lt;strong&gt;价值&lt;/strong&gt; - B 类点移动总路程。每次操作后输出最大&lt;strong&gt;总价值&lt;/strong&gt;，重复经过的 A 类点只计一次。&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(n\le 2\times 10^5\)&lt;/span&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这个题确实可以带来很多启发，我一开始直接设 &lt;span class=&#34;math inline&#34;&gt;\(f_j\)&lt;/span&gt; 为状态，这样对于暴力是可做的，但是会出现一些需要被区间修改的系数，比如&lt;strong&gt;前缀和&lt;/strong&gt;。最好设计状态，让转移的时候只需要用到常数、差分值等修改次数很少的系数。&lt;/p&gt;
&lt;p&gt;设 &lt;span class=&#34;math inline&#34;&gt;\(f_{i,0/1/2/3}\)&lt;/span&gt; 分别表示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image-1.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;那么可以写出转移式：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
f_{i,0}=\max(mx+a_i+x_i,f_{i-1,0}+a_i)\\
f_{i,1}=\max(mx+a_i+2x_i,f_{i-1,1}+a_i)\\
f_{i,2}=f_{i-1,2}-(x_i-x_{i-1}) + a_i\\
f_{i,3}=f_{i-1,3}-2(x_i-x_{i-1})+a_i
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其中 &lt;span class=&#34;math inline&#34;&gt;\(mx\)&lt;/span&gt; 为 &lt;span class=&#34;math inline&#34;&gt;\(f_{i,2/3}\)&lt;/span&gt; 的前缀最大值。在 B 类点处可以让 &lt;span class=&#34;math inline&#34;&gt;\(f_{2/3}\)&lt;/span&gt; 继承对应的 &lt;span class=&#34;math inline&#34;&gt;\(f_{0/1}\)&lt;/span&gt;，新开一维记录 &lt;span class=&#34;math inline&#34;&gt;\(mx\)&lt;/span&gt; 就可以维护矩乘了。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int lim = 1e8;
const int maxn = 5e6 + 5;
const long long inf = 1e12;
struct mat &amp;#123;
    long long a[5][5];
    mat() &amp;#123;&amp;#125;
    long long* operator[] (const int q) &amp;#123;
        return a[q];
    &amp;#125;
    mat operator* (mat &amp;amp;q) const &amp;#123;
        mat res;
        for (int i = 0; i &amp;lt; 5; ++i)
            for (int k = 0; k &amp;lt; 5; ++k) &amp;#123;
                auto u(-inf);
                for (int j = 0; j &amp;lt; 5; ++j)
                    u = std::max(u, a[i][j] + q[j][k]);
                res[i][k] = u;
            &amp;#125;
        return res;
    &amp;#125;
    mat&amp;amp; operator*= (mat &amp;amp;q) &amp;#123;
        return *this = *this * q;
    &amp;#125;
&amp;#125;;
struct &amp;#123; int l, r; mat u; &amp;#125; t[maxn];
#define lt t[p].l
#define rt t[p].r
void add(int &amp;amp;p, int l, int r, int x, mat &amp;amp;v) &amp;#123;
    static int tot = 0;
    if (!p)
        p = ++tot;
    if (l == r) &amp;#123;
        t[p].u = v;
        return;
    &amp;#125;
    int mid = (l + r) &amp;gt;&amp;gt; 1;
    if (x &amp;lt;= mid)
        add(lt, l, mid, x, v);
    else
        add(rt, mid + 1, r, x, v);
    t[p].u = t[lt].u * t[rt].u;
    return;
&amp;#125;
#undef lt
#undef rt
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    &amp;#123;
        mat &amp;amp;u = t[0].u;
        for (int i = 0; i &amp;lt; 5; ++i)
            for (int j = 0; j &amp;lt; 5; ++j)
                u[i][j] = -inf;
        u[0][0] = u[1][1] = u[2][2] = u[3][3] = u[4][4] = 0ll;
    &amp;#125;
    int m, rt = 0;
    std::cin &amp;gt;&amp;gt; m;
    std::vector&amp;lt;mat&amp;gt; a(m + 1);
    std::vector&amp;lt;int&amp;gt; ty(m + 1);
    std::set&amp;lt;std::pair&amp;lt;long long, int&amp;gt; &amp;gt; s;
    s.emplace(-inf, 0);
    for (int op, x, i = 1; i &amp;lt;= m; ++i) &amp;#123;
        std::cin &amp;gt;&amp;gt; op &amp;gt;&amp;gt; x;
        auto &amp;amp;u = a[i];
        for (int i = 0; i &amp;lt; 5; ++i)
            for (int j = 0; j &amp;lt; 5; ++j)
                u[i][j] = -inf;
        auto p = --s.lower_bound(std::make_pair(x, 0)), q = s.upper_bound(std::make_pair(x, 0));
        int v = 0;
        if (op == 2)
            std::cin &amp;gt;&amp;gt; v;
        u[0][0] = v, u[1][1] = v, u[4][0] = v + x, u[4][1] = v + 2 * x;
        if (op == 1) &amp;#123;
            ty[i] = 0;
            u[4][2] = u[4][1] - 2 * x;
            u[1][2] = u[1][1] - 2 * x;
            u[4][3] = u[4][0] - x;
            u[0][3] = u[0][0] - x;
        &amp;#125;
        else &amp;#123;
            ty[i] = 1;
            u[2][2] = v - (x - p-&amp;gt;first);
            u[3][3] = v - 2 * (x - p-&amp;gt;first);
        &amp;#125;
        u[4][4] = std::max(&amp;#123; 0ll, u[4][2], u[4][3] &amp;#125;);
        u[1][4] = u[1][2], u[0][4] = u[0][3], u[2][4] = u[2][2], u[3][4] = u[3][3];
        add(rt, 0, lim, x, u);
        if (q != s.end() &amp;amp;&amp;amp; ty[q-&amp;gt;second] == 1) &amp;#123;
            auto &amp;amp;u = a[q-&amp;gt;second];
            u[2][2] -= p-&amp;gt;first, u[2][2] += x;
            u[3][3] -= 2 * p-&amp;gt;first, u[3][3] += 2 * x;
            u[2][4] = u[2][2], u[3][4] = u[3][3];
            add(rt, 0, lim, q-&amp;gt;first, a[q-&amp;gt;second]);
        &amp;#125;
        s.emplace(x, i);
        std::cout &amp;lt;&amp;lt; t[1].u[4][4] &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
        // for (int i = 0; i &amp;lt; 5; ++i, puts(&amp;quot;&amp;quot;))
        //     for (int j = 0; j &amp;lt; 5; ++j)
        //         if (t[1].u[i][j] &amp;lt; -200)
        //             printf(&amp;quot;  x &amp;quot;);
        //         else
        //             printf(&amp;quot;%3lld &amp;quot;, t[1].u[i][j]);
        // puts(&amp;quot;=============&amp;quot;);
    &amp;#125;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;c---密码箱&#34;&gt;C - 密码箱&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;/20250818/#c---%E5%AF%86%E7%A0%81%E7%AE%B1&#34;&gt;link&lt;/a&gt;;&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://xsc062.netlify.app/20250812/</guid>
            <title>DDP 与全局平衡二叉树</title>
            <link>https://xsc062.netlify.app/20250812/</link>
            <category>线段树</category>
            <category>DDP</category>
            <pubDate>Tue, 12 Aug 2025 08:16:52 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;其实动态 DP 不是动态树 DP 的同义词&lt;/p&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;动态-dp&#34;&gt;动态 DP&lt;/h2&gt;
&lt;p&gt;对于转移只依赖前几项的 DP，可以放进矩阵。&lt;/p&gt;
&lt;p&gt;默认转移范围是 &lt;span class=&#34;math inline&#34;&gt;\([1,n]\)&lt;/span&gt;；如果我们需要改变求解范围，发现如果能获取转移矩阵的乘积就很快了。考虑存下来。&lt;/p&gt;
&lt;p&gt;如果需要单点修改，等价于修改其所在矩阵，则想要尽可能少地修改存储的答案，考虑使用线段树优化该过程。&lt;/p&gt;
&lt;h3 id=&#34;例海报&#34;&gt;例：海报&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P9790&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P9790&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;容易列出暴力 DP 式：令 &lt;span class=&#34;math inline&#34;&gt;\(f_{i,j}\)&lt;/span&gt; 表示枚举到 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 时，包含 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 在内已经有 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; 个连续的人举起海报，易得：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
f_{i,0}=\max(f_{i-1,0},f_{i-1,1},f_{i-1,2},f_{i-1,3})\\
f_{i,j}=f_{i-1,j-1}+a_i \forall 1\le j\le 3
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;发现满足 + / max &lt;strong&gt;矩阵乘法&lt;/strong&gt; 的形式；想到用线段树保存每段区间对应矩阵（对应性质：结合律），每次修改 / 查询就能在 &lt;span class=&#34;math inline&#34;&gt;\(O(\log n)\)&lt;/span&gt; 之内完成。&lt;/p&gt;
&lt;p&gt;原问题是环形的，可以再加一维 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 表示钦定选了前 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 个且不选第 &lt;span class=&#34;math inline&#34;&gt;\(k+1\)&lt;/span&gt; 个时的答案。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int maxn = 4e4 + 5;
const long long inf = 1e18;
struct mat &amp;#123;
    int n, m;
    long long a[4][4];
    mat() &amp;#123;&amp;#125;
    mat(int n1, int m1): n(n1), m(m1) &amp;#123;
        for (int i = 0; i &amp;lt; n; ++i)
            for (int j = 0; j &amp;lt; m; ++j)
                a[i][j] = -inf;
        return;
    &amp;#125;
    long long* operator[] (const int q) &amp;#123;
        return a[q];
    &amp;#125;
    mat operator* (mat &amp;amp;q) const &amp;#123;
        mat res(n, q.m);
        for (int i = 0; i &amp;lt; n; ++i)
            for (int k = 0; k &amp;lt; q.m; ++k)
                for (int j = 0; j &amp;lt; m; ++j)
                    res[i][k] = std::max(res[i][k], a[i][j] + q[j][k]);
        return res;
    &amp;#125;
    mat&amp;amp; operator*= (mat &amp;amp;q) &amp;#123;
        return *this = *this * q;
    &amp;#125;
&amp;#125;;
struct &amp;#123; int l, r; mat u[4]; &amp;#125; t[maxn &amp;lt;&amp;lt; 2];
int a[maxn];
#define lt (p &amp;lt;&amp;lt; 1)
#define rt (lt | 1)
#define c t[p].u[i]
void bld(int p, int l, int r) &amp;#123;
    t[p].l = l, t[p].r = r;
    if (l == r) &amp;#123;
        for (int i = 0; i &amp;lt;= 3; ++i) &amp;#123;
            c = mat(4, 4);
            if (l &amp;gt; i + 1) &amp;#123;
                c[0][0] = c[1][0] = c[2][0] = c[3][0] = 0;
                c[0][1] = c[1][2] = c[2][3] = a[l];
            &amp;#125;
            else if (l == i + 1)
                c[0][0] = c[1][0] = c[2][0] = c[3][0] = 0;
            else
                c[0][1] = c[1][2] = c[2][3] = a[l];
        &amp;#125;
        return;
    &amp;#125;
    int mid = (l + r) &amp;gt;&amp;gt; 1;
    bld(lt, l, mid), bld(rt, mid + 1, r);
    for (int i = 0; i &amp;lt;= 3; ++i)
        t[p].u[i] = t[lt].u[i] * t[rt].u[i];
    return;
&amp;#125;
void add(int p, int x, int v) &amp;#123;
    if (t[p].l == t[p].r) &amp;#123;
        for (int i = 0; i &amp;lt;= 3; ++i)
            if (t[p].l != i + 1) 
                c[0][1] = c[1][2] = c[2][3] = v;
        return;
    &amp;#125;
    int mid = (t[p].l + t[p].r) &amp;gt;&amp;gt; 1;
    if (x &amp;lt;= mid)
        add(lt, x, v);
    else
        add(rt, x, v);
    for (int i = 0; i &amp;lt;= 3; ++i)
        t[p].u[i] = t[lt].u[i] * t[rt].u[i];
    return;
&amp;#125;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n;
    std::cin &amp;gt;&amp;gt; n;
    for (int i = 1; i &amp;lt;= n; ++i)
        std::cin &amp;gt;&amp;gt; a[i];
    bld(1, 1, n);
    auto calc = [&amp;amp;](void) &amp;#123;
        mat f(1, 4);
        f[0][0] = 0;
        auto res = -inf;
        for (int i = 0; i &amp;lt;= 3; ++i) &amp;#123;
            auto r = (f * t[1].u[i]);
            for (int j = 0; j &amp;lt;= 3; ++j)
                if (i + j &amp;lt;= 3) &amp;#123;
                    res = std::max(res, r[0][j]);
                    // printf(&amp;quot;f[%d][%d] = %lld\n&amp;quot;, i, j, f[i][j]);
                &amp;#125;
        &amp;#125;
        return res;
    &amp;#125;;
    std::cout &amp;lt;&amp;lt; calc() &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    int q;
    std::cin &amp;gt;&amp;gt; q;
    for (int x, v; q--; ) &amp;#123;
        std::cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; v;
        add(1, x, v);
        std::cout &amp;lt;&amp;lt; calc() &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    &amp;#125;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;p&gt;发现矩阵本身和 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 无关，还可以可以共用一个线段树上的信息，就可以只开一个线段树了。&lt;/p&gt;
&lt;details&gt;
&lt;p&gt;我写这一版本的原因是 &lt;code&gt;maxn&lt;/code&gt; 开大了导致 MLE，实际上四个线段树是没有任何空间压力的 😅&lt;/p&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int maxn = 4e5 + 5;
const long long inf = 1e18;
struct mat &amp;#123;
    int n, m;
    long long a[4][4];
    mat() &amp;#123;&amp;#125;
    mat(int n1, int m1): n(n1), m(m1) &amp;#123;
        for (int i = 0; i &amp;lt; n; ++i)
            for (int j = 0; j &amp;lt; m; ++j)
                a[i][j] = -inf;
        return;
    &amp;#125;
    long long* operator[] (const int q) &amp;#123;
        return a[q];
    &amp;#125;
    mat operator* (mat q) const &amp;#123;
        mat res(n, q.m);
        for (int i = 0; i &amp;lt; n; ++i)
            for (int k = 0; k &amp;lt; q.m; ++k)
                for (int j = 0; j &amp;lt; m; ++j)
                    res[i][k] = std::max(res[i][k], a[i][j] + q[j][k]);
        return res;
    &amp;#125;
    mat&amp;amp; operator*= (mat &amp;amp;q) &amp;#123;
        return *this = *this * q;
    &amp;#125;
&amp;#125;;
struct &amp;#123; int l, r; mat u; &amp;#125; t[maxn &amp;lt;&amp;lt; 2];
int a[maxn];
#define lt (p &amp;lt;&amp;lt; 1)
#define rt (lt | 1)
void bld(int p, int l, int r) &amp;#123;
    t[p].l = l, t[p].r = r;
    if (l == r) &amp;#123;
        t[p].u = mat(4, 4);
        t[p].u[0][0] = t[p].u[1][0] = t[p].u[2][0] = t[p].u[3][0] = 0;
        t[p].u[0][1] = t[p].u[1][2] = t[p].u[2][3] = a[l];
        return;
    &amp;#125;
    int mid = (l + r) &amp;gt;&amp;gt; 1;
    bld(lt, l, mid), bld(rt, mid + 1, r);
    t[p].u = t[lt].u * t[rt].u;
    return;
&amp;#125;
void add(int p, int x, int v) &amp;#123;
    if (t[p].l == t[p].r) &amp;#123;
        t[p].u[0][1] = t[p].u[1][2] = t[p].u[2][3] = v;
        return;
    &amp;#125;
    int mid = (t[p].l + t[p].r) &amp;gt;&amp;gt; 1;
    if (x &amp;lt;= mid)
        add(lt, x, v);
    else
        add(rt, x, v);
    t[p].u = t[lt].u * t[rt].u;
    return;
&amp;#125;
mat ask(int p, int l, int r) &amp;#123;
    if (l &amp;lt;= t[p].l &amp;amp;&amp;amp; t[p].r &amp;lt;= r)
        return t[p].u;
    int mid = (t[p].l + t[p].r) &amp;gt;&amp;gt; 1;
    if (r &amp;lt;= mid)
        return ask(lt, l, r);
    if (l &amp;gt; mid)
        return ask(rt, l, r);
    return ask(lt, l, r) * ask(rt, l, r);
&amp;#125;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n;
    std::cin &amp;gt;&amp;gt; n;
    for (int i = 1; i &amp;lt;= n; ++i)
        std::cin &amp;gt;&amp;gt; a[i];
    bld(1, 1, n);
    auto calc = [&amp;amp;](void) &amp;#123;
        mat f(1, 4);
        f[0][0] = 0, f[0][1] = f[0][2] = f[0][3] = -inf;
        auto r(f * ask(1, 2, n));
        auto res(*std::max_element(r[0], r[0] + 4));
        mat z(4, 4);
        z[0][0] = z[1][0] = z[2][0] = z[3][0] = 0ll;
        for (int i = 1; i &amp;lt;= 3; ++i) &amp;#123;
            mat op(4, 4);
            op[0][1] = op[1][2] = op[2][3] = a[i];
            f *= op;
            if (i + 2 &amp;lt;= n)
                r = f * z * ask(1, i + 2, n);
            else
                r = f * z;
            res = std::max(res, *std::max_element(r[0], r[0] + 4 - i));
        &amp;#125;
        return res;
    &amp;#125;;
    std::cout &amp;lt;&amp;lt; calc() &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    int q;
    std::cin &amp;gt;&amp;gt; q;
    for (int x, v; q--; ) &amp;#123;
        std::cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; v, a[x] = v;
        add(1, x, v);
        std::cout &amp;lt;&amp;lt; calc() &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    &amp;#125;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;经典题gss3&#34;&gt;经典题：GSS3&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/SP1716&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/SP1716&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;怎么是子段和 😓&lt;/p&gt;
&lt;p&gt;同样列出能够矩阵乘法的 DP 式，发现限制在于至少要选一个数。设 &lt;span class=&#34;math inline&#34;&gt;\(f_{i}\)&lt;/span&gt; 表示选了 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 的最大值，&lt;span class=&#34;math inline&#34;&gt;\(g_i\)&lt;/span&gt; 表示历史最大值，则：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
f_i=\max(f_{i-1}+a_i,0+a_i)\\
g_i=\max(g_{i-1}+0,f_{i-1}+a_i,0+a_i)
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;容易发现是一个 + / max 矩乘，线段树维护即可。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int maxn = 4e5 + 5;
const long long inf = 1e18;
struct mat &amp;#123;
    int n, m;
    long long a[3][3];
    mat() &amp;#123;&amp;#125;
    mat(int n1, int m1): n(n1), m(m1) &amp;#123;
        for (int i = 0; i &amp;lt; n; ++i)
            for (int j = 0; j &amp;lt; m; ++j)
                a[i][j] = -inf;
        return;
    &amp;#125;
    long long* operator[] (const int q) &amp;#123;
        return a[q];
    &amp;#125;
    mat operator* (mat q) const &amp;#123;
        mat res(n, q.m);
        for (int i = 0; i &amp;lt; n; ++i)
            for (int k = 0; k &amp;lt; q.m; ++k)
                for (int j = 0; j &amp;lt; m; ++j)
                    res[i][k] = std::max(res[i][k], a[i][j] + q[j][k]);
        return res;
    &amp;#125;
    mat&amp;amp; operator*= (mat &amp;amp;q) &amp;#123;
        return *this = *this * q;
    &amp;#125;
&amp;#125;;
struct &amp;#123; int l, r; mat u; &amp;#125; t[maxn &amp;lt;&amp;lt; 2]; 
int a[maxn];
#define lt (p &amp;lt;&amp;lt; 1)
#define rt (lt | 1)
void bld(int p, int l, int r) &amp;#123;
    t[p].l = l, t[p].r = r;
    if (l == r) &amp;#123;
        t[p].u = mat(3, 3);
        t[p].u[0][0] = t[p].u[2][0] = a[l];
        t[p].u[0][1] = a[l], t[p].u[1][1] = 0ll, t[p].u[2][1] = a[l];
        t[p].u[2][2] = 0ll;
        return;
    &amp;#125;
    int mid = (l + r) &amp;gt;&amp;gt; 1;
    bld(lt, l, mid), bld(rt, mid + 1, r);
    t[p].u = t[lt].u * t[rt].u;
    return;
&amp;#125;
void add(int p, int x, int v) &amp;#123;
    if (t[p].l == t[p].r) &amp;#123;
        t[p].u[0][0] = t[p].u[2][0] = t[p].u[0][1] = t[p].u[2][1] = v;
        return;
    &amp;#125;
    int mid = (t[p].l + t[p].r) &amp;gt;&amp;gt; 1;
    if (x &amp;lt;= mid)
        add(lt, x, v);
    else
        add(rt, x, v);
    t[p].u = t[lt].u * t[rt].u;
    return;
&amp;#125;
mat ask(int p, int l, int r) &amp;#123;
    if (l &amp;lt;= t[p].l &amp;amp;&amp;amp; t[p].r &amp;lt;= r)
        return t[p].u;
    int mid = (t[p].l + t[p].r) &amp;gt;&amp;gt; 1;
    if (r &amp;lt;= mid)
        return ask(lt, l, r);
    if (l &amp;gt; mid)
        return ask(rt, l, r);
    return ask(lt, l, r) * ask(rt, l, r);
&amp;#125;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n;
    std::cin &amp;gt;&amp;gt; n;
    for (int i = 1; i &amp;lt;= n; ++i)
        std::cin &amp;gt;&amp;gt; a[i];
    bld(1, 1, n);
    auto calc = [&amp;amp;](int l, int r) &amp;#123;
        mat f(1, 3);
        f[0][2] = 0ll;
        auto res(f * ask(1, l, r));
        return res[0][1];
    &amp;#125;;
    int q;
    std::cin &amp;gt;&amp;gt; q;
    for (int op; q--; ) &amp;#123;
        std::cin &amp;gt;&amp;gt; op;
        if (op == 1) &amp;#123;
            int l, r;
            std::cin &amp;gt;&amp;gt; l &amp;gt;&amp;gt; r;
            std::cout &amp;lt;&amp;lt; calc(l, r) &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
        &amp;#125;
        else &amp;#123;
            int x, v;
            std::cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; v;
            a[x] = v, add(1, x, v);
        &amp;#125;
    &amp;#125;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;动态树-dp&#34;&gt;动态树 DP&lt;/h2&gt;
&lt;p&gt;把上述过程放到树上，很容易想到树剖 + 线段树。&lt;/p&gt;
&lt;p&gt;由于认为线段树上的矩乘只能进行从重儿子到父亲的转移，轻儿子的转移会被合并为一个新函数（同时是矩阵的系数），在跳重链的时候被单独更新。&lt;/p&gt;
&lt;p&gt;由于两个函数相互依赖，需要思考清楚更新的先后顺序。&lt;/p&gt;
&lt;h3 id=&#34;模板动态-dp&#34;&gt;【模板】动态 DP&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P4719&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P4719&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;令 &lt;span class=&#34;math inline&#34;&gt;\(f_{u,0/1}\)&lt;/span&gt; 表示在 &lt;span class=&#34;math inline&#34;&gt;\(u\)&lt;/span&gt; 上，选 / 不选 &lt;span class=&#34;math inline&#34;&gt;\(u\)&lt;/span&gt; 的最大价值。容易得出转移：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
f_{u,0}=\sum\max(f_{v,0},f_{v,1})\\
f_{u,1}=a_i+\sum f_{v,0}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;把转移矩阵放到树剖上后，考虑更新，发现求和这一步很困难。解决方案是&lt;strong&gt;直接将求和用另一个函数代替&lt;/strong&gt;。定义 &lt;span class=&#34;math inline&#34;&gt;\(g_{u,0}\)&lt;/span&gt; 表示取 &lt;span class=&#34;math inline&#34;&gt;\(u\)&lt;/span&gt;、不取 &lt;span class=&#34;math inline&#34;&gt;\(u\)&lt;/span&gt; 的所有轻儿子的答案，&lt;span class=&#34;math inline&#34;&gt;\(g_{u,1}\)&lt;/span&gt; 不取 &lt;span class=&#34;math inline&#34;&gt;\(u\)&lt;/span&gt;，轻儿子可选可不选的答案。&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(g\)&lt;/span&gt; 是可求的，且只需要在跳重链的时候更新 &lt;span class=&#34;math inline&#34;&gt;\(g\)&lt;/span&gt;。具体更新起来非常绞，因为 &lt;span class=&#34;math inline&#34;&gt;\(g\)&lt;/span&gt; 和 &lt;span class=&#34;math inline&#34;&gt;\(f\)&lt;/span&gt; 是相互依赖的，需要分清楚先后关系。&lt;/p&gt;
&lt;p&gt;首先 &lt;span class=&#34;math inline&#34;&gt;\(g_u\)&lt;/span&gt; 和 &lt;span class=&#34;math inline&#34;&gt;\(f_u\)&lt;/span&gt; 都会被更新；接着，重链上其它的 &lt;span class=&#34;math inline&#34;&gt;\(g\)&lt;/span&gt; 不会被影响，而链顶的 &lt;span class=&#34;math inline&#34;&gt;\(f\)&lt;/span&gt; 需要被新的 &lt;span class=&#34;math inline&#34;&gt;\(g_u\)&lt;/span&gt; 更新；由此链顶父亲的 &lt;span class=&#34;math inline&#34;&gt;\(g\)&lt;/span&gt; 被更新；依次类推。注意到对于一个链顶，其 &lt;span class=&#34;math inline&#34;&gt;\(f\)&lt;/span&gt; 值是整条重链的乘积，故需要记录链底。&lt;/p&gt;
&lt;p&gt;复杂度 &lt;span class=&#34;math inline&#34;&gt;\(O(q\log ^2n)\)&lt;/span&gt;。注意很重要的一点是线段树内乘法应从右往左。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int maxn = 1e5 + 5;
const int inf = 0x3f3f3f3f;
struct mat &amp;#123;
    int n, m, a[2][2];
    mat() &amp;#123;&amp;#125;
    mat(int n1, int m1): n(n1), m(m1) &amp;#123;
        for (int i = 0; i &amp;lt; n; ++i)
            for (int j = 0; j &amp;lt; m; ++j)
                a[i][j] = -inf;
        return;
    &amp;#125;
    int* operator[] (const int q) &amp;#123;
        return a[q];
    &amp;#125;
    mat operator* (mat q) const &amp;#123;
        mat res(n, q.m);
        for (int i = 0; i &amp;lt; n; ++i)
            for (int k = 0; k &amp;lt; q.m; ++k)
                for (int j = 0; j &amp;lt; m; ++j)
                    res[i][k] = std::max(res[i][k], a[i][j] + q[j][k]);
        return res;
    &amp;#125;
    mat&amp;amp; operator*= (mat &amp;amp;q) &amp;#123;
        return *this = *this * q;
    &amp;#125;
&amp;#125;;
struct &amp;#123; int l, r; mat u; &amp;#125; t[maxn &amp;lt;&amp;lt; 2]; 
int g[maxn][2], tab[maxn];
#define lt (p &amp;lt;&amp;lt; 1)
#define rt (lt | 1)
void bld(int p, int l, int r) &amp;#123;
    t[p].l = l, t[p].r = r;
    if (l == r) &amp;#123;
        int u = tab[l];
        t[p].u = mat(2, 2);
        t[p].u[0][0] = t[p].u[1][0] = g[u][1];
        t[p].u[0][1] = g[u][0];
        return;
    &amp;#125;
    int mid = (l + r) &amp;gt;&amp;gt; 1;
    bld(lt, l, mid), bld(rt, mid + 1, r);
    t[p].u = t[rt].u * t[lt].u;
    return;
&amp;#125;
void add(int p, int x) &amp;#123;
    if (t[p].l == t[p].r) &amp;#123;
        int u = tab[x];
        t[p].u[0][0] = t[p].u[1][0] = g[u][1];
        t[p].u[0][1] = g[u][0];
        return;
    &amp;#125;
    int mid = (t[p].l + t[p].r) &amp;gt;&amp;gt; 1;
    if (x &amp;lt;= mid)
        add(lt, x);
    else
        add(rt, x);
    t[p].u = t[rt].u * t[lt].u;
    return;
&amp;#125;
mat ask(int p, int l, int r) &amp;#123;
    if (l &amp;lt;= t[p].l &amp;amp;&amp;amp; t[p].r &amp;lt;= r)
        return t[p].u;
    int mid = (t[p].l + t[p].r) &amp;gt;&amp;gt; 1;
    if (r &amp;lt;= mid)
        return ask(lt, l, r);
    if (l &amp;gt; mid)
        return ask(rt, l, r);
    return ask(rt, l, r) * ask(lt, l, r);
&amp;#125;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, q;
    std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; q;
    std::vector&amp;lt;int&amp;gt; a(n + 1);
    for (int i = 1; i &amp;lt;= n; ++i)
        std::cin &amp;gt;&amp;gt; a[i];
    std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; g1(n + 1);
    for (int i = 1, x, y; i &amp;lt; n; ++i) &amp;#123;
        std::cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; y;
        g1[x].push_back(y), g1[y].push_back(x);
    &amp;#125;
    std::vector&amp;lt;int&amp;gt; siz(n + 1), son(n + 1), fa(n + 1);
    std::function&amp;lt;void(int)&amp;gt; DFS = [&amp;amp;](int x) &amp;#123;
        siz[x] = 1;
        for (auto i : g1[x])
            if (i != fa[x]) &amp;#123;
                fa[i] = x, DFS(i);
                siz[x] += siz[i];
                if (siz[i] &amp;gt; siz[son[x]])
                    son[x] = i;
            &amp;#125;
        return;
    &amp;#125;;
    DFS(1);
    std::vector&amp;lt;std::array&amp;lt;int, 2&amp;gt; &amp;gt; f(n + 1);
    std::vector&amp;lt;int&amp;gt; top(n + 1), bot(n + 1), dfn(n + 1);
    DFS = [&amp;amp;](int x) &amp;#123;
        static int now = 0;
        dfn[x] = ++now, tab[now] = x;
        if (son[x]) &amp;#123;
            top[son[x]] = top[x], DFS(son[x]);
            bot[x] = bot[son[x]];
            g[x][0] = a[x];
            for (auto i : g1[x])
                if (i != son[x] &amp;amp;&amp;amp; i != fa[x]) &amp;#123;
                    top[i] = i, DFS(i);
                    g[x][0] += f[i][0];
                    g[x][1] += std::max(f[i][1], f[i][0]);
                &amp;#125;
            f[x][0] = g[x][1] + std::max(f[son[x]][0], f[son[x]][1]);
            f[x][1] = g[x][0] + f[son[x]][0];
        &amp;#125;
        else
            f[x][1] = g[x][0] = a[x], bot[x] = x;
        return;
    &amp;#125;;
    top[1] = 1, DFS(1);
    bld(1, 1, n);
    for (int x, v; q--; ) &amp;#123;
        std::cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; v;
        g[x][0] -= a[x], g[x][0] += v, a[x] = v;
        for (; top[x] != 1; ) &amp;#123;
            auto r = ask(1, dfn[top[x]], dfn[bot[x]]);
            f[top[x]][0] = r[0][0], f[top[x]][1] = r[0][1];
            g[fa[top[x]]][0] -= f[top[x]][0];
            g[fa[top[x]]][1] -= std::max(f[top[x]][0], f[top[x]][1]);
            add(1, dfn[x]);
            r = ask(1, dfn[top[x]], dfn[bot[x]]);
            f[top[x]][0] = r[0][0], f[top[x]][1] = r[0][1];
            g[fa[top[x]]][0] += f[top[x]][0];
            g[fa[top[x]]][1] += std::max(f[top[x]][0], f[top[x]][1]);
            x = fa[top[x]];
        &amp;#125;
        add(1, dfn[x]);
        auto r = ask(1, dfn[1], dfn[bot[1]]);
        f[1][0] = r[0][0], f[1][1] = r[0][1];
        std::cout &amp;lt;&amp;lt; std::max(f[1][0], f[1][1]) &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    &amp;#125;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;全局平衡二叉树&#34;&gt;全局平衡二叉树&lt;/h2&gt;
&lt;p&gt;回顾树剖（重剖），功能在于解决路径问题，单次操作能够在 &lt;span class=&#34;math inline&#34;&gt;\(O(\log^2 n)\)&lt;/span&gt; 的时间内完成。这个功能可以被&lt;strong&gt;全局平衡二叉树（GBT）&lt;/strong&gt;上位替代。GBT 能够在单次 &lt;span class=&#34;math inline&#34;&gt;\(O(\log n)\)&lt;/span&gt; 的复杂度内完成链操作、子树操作。&lt;em&gt;&lt;a href=&#34;QTREE解法的一些研究.pdf&#34;&gt;Yang Zhe - SPOJ375 QTREE 解法的一些研究&lt;/a&gt; 中更为详细严谨地对 GBT 进行了说明，我传了份文件上来。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;考虑树剖能被卡的原因：每次线段树询问都会卡满 &lt;span class=&#34;math inline&#34;&gt;\(O(\log n)\)&lt;/span&gt;，找一条卡得满 &lt;span class=&#34;math inline&#34;&gt;\(O(\log n)\)&lt;/span&gt; 次跳重链次数的路径一直薅，就可以卡到 &lt;span class=&#34;math inline&#34;&gt;\(O(\log^2 n)\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;在实现线段树时发现，对于&lt;strong&gt;路径操作&lt;/strong&gt;和&lt;strong&gt;单点操作&lt;/strong&gt;，树剖只需要维护同一条重链的信息，建一个大线段树会产生许多重链间的无效维护。故一种经典的树剖卡常技巧是对于每一条重链建出线段树。&lt;/p&gt;
&lt;p&gt;在本文中定义&lt;strong&gt;全局二叉树&lt;/strong&gt;：将单个线段树按照在原树上重链顶的相对祖孙关系连边得到的模型。这里为了和&lt;strong&gt;全局平衡二叉树&lt;/strong&gt;形成照应而命名，实际上模型并不是二叉树。容易发现&lt;strong&gt;修改某个点花费的操作次数和其在全局二叉树中的深度相同&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;考虑本方法理论上仍可卡到 &lt;span class=&#34;math inline&#34;&gt;\(O(\log^2 n)\)&lt;/span&gt; 单次操作的原因，虽然单个线段树平衡，但&lt;strong&gt;全局二叉树&lt;/strong&gt;并不平衡；能够构造数据使得树高达到 &lt;span class=&#34;math inline&#34;&gt;\(\log^2 n\)&lt;/span&gt;。考虑使得全局二叉树平衡，即调整线段树结构使得任何一个点在全局二叉树上的左右儿子大小最接近。发现是易做的，只需在建线段树时移动左右儿子分割点使得两边子树大小均为全树的一半即可。&lt;/p&gt;
&lt;p&gt;法一：求出每个点的轻子树大小 &lt;span class=&#34;math inline&#34;&gt;\(ls_u=1+\sum siz_v\)&lt;/span&gt;，作为加权在线段树上找 mid 就能满足全局平衡；证明可以见上面的论文。这里用线段树代替了 BST，常数很大。&lt;/p&gt;
&lt;p&gt;法二：用一个 BST 实现上述功能，需要满足：任意子树的根为子树的带权 mid；BST 的中序遍历为原重链。显然有：树高为 log 级别。这就决定了所有问题都可以通过暴力爬山解决。&lt;/p&gt;
&lt;p&gt;GBT 能够快速维护&lt;strong&gt;普通树剖操作&lt;/strong&gt;和 &lt;strong&gt;DDP 信息&lt;/strong&gt;。&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;维护-ddp模板动态-dp加强版&#34;&gt;维护 DDP：【模板】动态 DP（加强版）&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P4751&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P4751&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;和未加强版类似，把所有线段树操作替换为 BST 即可。如果写得丑可能需要一些额外的卡常技巧。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int maxn = 1e6 + 5;
const int inf = 0x3f3f3f3f;
const int LEN = (1 &amp;lt;&amp;lt; 20);
int nec(void) &amp;#123;
    static char buf[LEN], *p = buf, *e = buf;
    if (p == e) &amp;#123;
        e = buf + fread(buf, 1, LEN, stdin);
        if (e == buf) return EOF;
        p = buf;
    &amp;#125;
    return *p++;
&amp;#125;
bool read(int &amp;amp;x) &amp;#123;
    x = 0;
    bool f = 0;
    char ch = nec();
    while (ch &amp;lt; &amp;#39;0&amp;#39; || ch &amp;gt; &amp;#39;9&amp;#39;) &amp;#123;
        if (ch == EOF) return 0;
        if (ch == &amp;#39;-&amp;#39;) f = 1;
        ch = nec();
    &amp;#125;
    while (ch &amp;gt;= &amp;#39;0&amp;#39; &amp;amp;&amp;amp; ch &amp;lt;= &amp;#39;9&amp;#39;) &amp;#123;
        x = x * 10 + ch - &amp;#39;0&amp;#39;;
        ch = nec();
    &amp;#125;
    if (f) x = -x;
    return 1;
&amp;#125;
void print(int x) &amp;#123;
    if (x &amp;lt; 0)
        putchar(&amp;#39;-&amp;#39;), x = -x;
    if (x &amp;gt;= 10) print(x / 10);
    putchar(x % 10 + &amp;#39;0&amp;#39;);
    return;
&amp;#125;
void print(int x, char ch) &amp;#123;
    print(x), putchar(ch);
    return;
&amp;#125;
struct mat &amp;#123;
    int a[2][2];
    int* operator[] (const int q) &amp;#123; 
        return a[q];
    &amp;#125;
    mat operator* (mat &amp;amp;q) const &amp;#123;
        mat res;
        res[0][0] = res[0][1] = res[1][0] = res[1][1] = -inf;
        for (int i = 0; i &amp;lt; 2; ++i)
            for (int k = 0; k &amp;lt; 2; ++k)
                for (int j = 0; j &amp;lt; 2; ++j)
                    res[i][k] = std::max(res[i][k], a[i][j] + q[j][k]);
        return res;
    &amp;#125;
    mat&amp;amp; operator*= (mat &amp;amp;q) &amp;#123;
        return *this = *this * q;
    &amp;#125;
&amp;#125;;
struct &amp;#123; int lc, rc, fa; mat u; &amp;#125; t[maxn]; 
int g[maxn][2], tab[maxn], ls[maxn];
mat p[maxn];
void pushup(int x) &amp;#123;
    t[x].u = t[t[x].rc].u * p[x] * t[t[x].lc].u;
    return;
&amp;#125;
void bld(int &amp;amp;x, int l, int r) &amp;#123;
    if (l &amp;gt; r)
        return;
    int s = 0, k = 0;
    for (int i = l; i &amp;lt;= r; ++i)
        s += ls[tab[i]];
    for (int i = l; i &amp;lt;= r; ++i, k += ls[tab[i]])
        if ((k + ls[tab[i]]) * 2 &amp;gt; s) &amp;#123;
            x = tab[i];
            bld(t[x].lc, l, i - 1), t[t[x].lc].fa = x;
            bld(t[x].rc, i + 1, r), t[t[x].rc].fa = x;
            pushup(x);
            break;
        &amp;#125;
    return;
&amp;#125;
#undef lt
#undef rt
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    t[0].u[0][0] = t[0].u[1][1] = 0, t[0].u[0][1] = t[0].u[1][0] = -inf;
    int n, q;
    read(n), read(q);
    std::vector&amp;lt;int&amp;gt; a(n + 1), rt(n + 1);
    for (int i = 1; i &amp;lt;= n; ++i)
        read(a[i]);
    std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; g1(n + 1);
    for (int i = 1, x, y; i &amp;lt; n; ++i) &amp;#123;
        read(x), read(y);
        g1[x].push_back(y), g1[y].push_back(x);
    &amp;#125;
    std::vector&amp;lt;int&amp;gt; son(n + 1), fa(n + 1), siz(n + 1);
    std::function&amp;lt;void(int)&amp;gt; DFS = [&amp;amp;](int x) &amp;#123;
        siz[x] = 1;
        for (auto i : g1[x])
            if (i != fa[x]) &amp;#123;
                fa[i] = x, DFS(i);
                siz[x] += siz[i];
                if (siz[i] &amp;gt; siz[son[x]])
                    son[x] = i;
            &amp;#125;
        return;
    &amp;#125;;
    DFS(1);
    std::vector&amp;lt;std::array&amp;lt;int, 2&amp;gt; &amp;gt; f(n + 1);
    std::vector&amp;lt;int&amp;gt; top(n + 1), bot(n + 1), dfn(n + 1);
    DFS = [&amp;amp;](int x) &amp;#123;
        static int now = 0;
        dfn[x] = ++now, tab[now] = x, ls[x] = 1;
        if (son[x]) &amp;#123;
            top[son[x]] = top[x], DFS(son[x]);
            bot[x] = bot[son[x]];
            g[x][0] = a[x];
            for (auto i : g1[x])
                if (i != son[x] &amp;amp;&amp;amp; i != fa[x]) &amp;#123;
                    top[i] = i, DFS(i), t[rt[i]].fa = x;
                    ls[x] += siz[i];
                    g[x][0] += f[i][0];
                    g[x][1] += std::max(f[i][1], f[i][0]);
                &amp;#125;
            f[x][0] = g[x][1] + std::max(f[son[x]][0], f[son[x]][1]);
            f[x][1] = g[x][0] + f[son[x]][0];
        &amp;#125;
        else
            f[x][1] = g[x][0] = a[x], bot[x] = x;
        p[x][0][0] = p[x][1][0] = g[x][1];
        p[x][0][1] = g[x][0], p[x][1][1] = -inf;
        if (x == top[x])
            bld(rt[x], dfn[x], dfn[bot[x]]);
        return;
    &amp;#125;;
    top[1] = 1, DFS(1);
    for (int x, v, la = 0; q--; ) &amp;#123;
        read(x), read(v), x ^= la;
        p[x][0][1] += v - a[x], a[x] = v;
        for (; x; ) &amp;#123;
            int fa = t[x].fa;
            if (fa &amp;amp;&amp;amp; x != t[fa].lc &amp;amp;&amp;amp; x != t[fa].rc) &amp;#123;
                int f0 = t[x].u[0][0], f1 = std::max(f0, t[x].u[0][1]);
                pushup(x);
                int F0 = t[x].u[0][0], F1 = std::max(F0, t[x].u[0][1]);
                p[fa][0][0] += F1 - f1, p[fa][1][0] += F1 - f1;
                p[fa][0][1] += F0 - f0;
            &amp;#125;
            else
                pushup(x);
            x = fa;
        &amp;#125;
        print(la = std::max(t[rt[1]].u[0][0], t[rt[1]].u[0][1]), &amp;#39;\n&amp;#39;);
    &amp;#125;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;p&gt;也给出一个线段树版本的&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int maxn = 1e6 + 5;
const int inf = 0x3f3f3f3f;
const int LEN = (1 &amp;lt;&amp;lt; 20);
int nec(void) &amp;#123;
    static char buf[LEN], *p = buf, *e = buf;
    if (p == e) &amp;#123;
        e = buf + fread(buf, 1, LEN, stdin);
        if (e == buf) return EOF;
        p = buf;
    &amp;#125;
    return *p++;
&amp;#125;
bool read(int &amp;amp;x) &amp;#123;
    x = 0;
    bool f = 0;
    char ch = nec();
    while (ch &amp;lt; &amp;#39;0&amp;#39; || ch &amp;gt; &amp;#39;9&amp;#39;) &amp;#123;
        if (ch == EOF) return 0;
        if (ch == &amp;#39;-&amp;#39;) f = 1;
        ch = nec();
    &amp;#125;
    while (ch &amp;gt;= &amp;#39;0&amp;#39; &amp;amp;&amp;amp; ch &amp;lt;= &amp;#39;9&amp;#39;) &amp;#123;
        x = x * 10 + ch - &amp;#39;0&amp;#39;;
        ch = nec();
    &amp;#125;
    if (f) x = -x;
    return 1;
&amp;#125;
void print(int x) &amp;#123;
    if (x &amp;lt; 0)
        putchar(&amp;#39;-&amp;#39;), x = -x;
    if (x &amp;gt;= 10) print(x / 10);
    putchar(x % 10 + &amp;#39;0&amp;#39;);
    return;
&amp;#125;
void print(int x, char ch) &amp;#123;
    print(x), putchar(ch);
    return;
&amp;#125;
struct mat &amp;#123;
    int a[2][2];
    int* operator[] (const int q) &amp;#123;
        return a[q];
    &amp;#125;
    mat operator* (mat q) const &amp;#123;
        mat res;
        res[0][0] = res[0][1] = res[1][0] = res[1][1] = -inf;
        for (int i = 0; i &amp;lt; 2; ++i)
            for (int k = 0; k &amp;lt; 2; ++k)
                for (int j = 0; j &amp;lt; 2; ++j)
                    res[i][k] = std::max(res[i][k], a[i][j] + q[j][k]);
        return res;
    &amp;#125;
    mat&amp;amp; operator*= (mat &amp;amp;q) &amp;#123;
        return *this = *this * q;
    &amp;#125;
&amp;#125;;
struct &amp;#123; int lc, rc, l, r, mid; mat u; &amp;#125; t[maxn &amp;lt;&amp;lt; 2]; 
int g[maxn][2], tab[maxn], ls[maxn];
#define lt t[p].lc
#define rt t[p].rc
void bld(int &amp;amp;p, int l, int r) &amp;#123;
    static int tot = 0;
    p = ++tot, t[p].l = l, t[p].r = r;
    if (l == r) &amp;#123;
        int u = tab[l];
        t[p].u[0][0] = t[p].u[1][0] = g[u][1];
        t[p].u[0][1] = g[u][0], t[p].u[1][1] = -inf;
        return;
    &amp;#125;
    int s = 0, u = ls[tab[l]];
    for (int i = l; i &amp;lt;= r; ++i)
        s += ls[tab[i]];
    s &amp;gt;&amp;gt;= 1;
    t[p].mid = r - 1;
    for (int i = l + 1; i &amp;lt; r; ++i) &amp;#123;
        u += ls[tab[i]];
        if (u + ls[tab[i + 1]] &amp;gt; s) &amp;#123;
            t[p].mid = i;
            break;
        &amp;#125;
    &amp;#125;
    bld(lt, l, t[p].mid), bld(rt, t[p].mid + 1, r);
    t[p].u = t[rt].u * t[lt].u;
    return;
&amp;#125;
void add(int p, int x) &amp;#123;
    if (t[p].l == t[p].r) &amp;#123;
        int u = tab[x];
        t[p].u[0][0] = t[p].u[1][0] = g[u][1];
        t[p].u[0][1] = g[u][0];
        return;
    &amp;#125;
    if (x &amp;lt;= t[p].mid)
        add(lt, x);
    else
        add(rt, x);
    t[p].u = t[rt].u * t[lt].u;
    return;
&amp;#125;
mat ask(int p, int l, int r) &amp;#123;
    if (l &amp;lt;= t[p].l &amp;amp;&amp;amp; t[p].r &amp;lt;= r)
        return t[p].u;
    if (r &amp;lt;= t[p].mid)
        return ask(lt, l, r);
    if (l &amp;gt; t[p].mid)
        return ask(rt, l, r);
    return ask(rt, l, r) * ask(lt, l, r);
&amp;#125;
#undef lt
#undef rt
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, q;
    read(n), read(q);
    std::vector&amp;lt;int&amp;gt; a(n + 1), rt(n + 1);
    for (int i = 1; i &amp;lt;= n; ++i)
        read(a[i]);
    std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; g1(n + 1);
    for (int i = 1, x, y; i &amp;lt; n; ++i) &amp;#123;
        read(x), read(y);
        g1[x].push_back(y), g1[y].push_back(x);
    &amp;#125;
    std::vector&amp;lt;int&amp;gt; siz(n + 1), son(n + 1), fa(n + 1);
    std::function&amp;lt;void(int)&amp;gt; DFS = [&amp;amp;](int x) &amp;#123;
        siz[x] = 1;
        for (auto i : g1[x])
            if (i != fa[x]) &amp;#123;
                fa[i] = x, DFS(i);
                siz[x] += siz[i];
                if (siz[i] &amp;gt; siz[son[x]])
                    son[x] = i;
            &amp;#125;
        return;
    &amp;#125;;
    DFS(1);
    std::vector&amp;lt;std::array&amp;lt;int, 2&amp;gt; &amp;gt; f(n + 1);
    std::vector&amp;lt;int&amp;gt; top(n + 1), bot(n + 1), dfn(n + 1);
    DFS = [&amp;amp;](int x) &amp;#123;
        static int now = 0;
        dfn[x] = ++now, tab[now] = x;
        ls[x] = 1;
        if (son[x]) &amp;#123;
            top[son[x]] = top[x], DFS(son[x]);
            bot[x] = bot[son[x]];
            g[x][0] = a[x];
            for (auto i : g1[x])
                if (i != son[x] &amp;amp;&amp;amp; i != fa[x]) &amp;#123;
                    top[i] = i, DFS(i);
                    ls[x] += siz[i];
                    g[x][0] += f[i][0];
                    g[x][1] += std::max(f[i][1], f[i][0]);
                &amp;#125;
            f[x][0] = g[x][1] + std::max(f[son[x]][0], f[son[x]][1]);
            f[x][1] = g[x][0] + f[son[x]][0];
        &amp;#125;
        else
            f[x][1] = g[x][0] = a[x], bot[x] = x;
        if (x == top[x])
            bld(rt[x], dfn[x], dfn[bot[x]]);
        return;
    &amp;#125;;
    top[1] = 1, DFS(1);
    for (int x, v, la = 0; q--; ) &amp;#123;
        read(x), read(v), x ^= la;
        g[x][0] -= a[x], g[x][0] += v, a[x] = v;
        for (; top[x] != 1; ) &amp;#123;
            auto r = t[rt[top[x]]].u;
            f[top[x]][0] = r[0][0], f[top[x]][1] = r[0][1];
            g[fa[top[x]]][0] -= f[top[x]][0];
            g[fa[top[x]]][1] -= std::max(f[top[x]][0], f[top[x]][1]);
            add(rt[top[x]], dfn[x]);
            r = t[rt[top[x]]].u;
            f[top[x]][0] = r[0][0], f[top[x]][1] = r[0][1];
            g[fa[top[x]]][0] += f[top[x]][0];
            g[fa[top[x]]][1] += std::max(f[top[x]][0], f[top[x]][1]);
            x = fa[top[x]];
        &amp;#125;
        add(rt[1], dfn[x]);
        auto r =  t[rt[1]].u;
        f[1][0] = r[0][0], f[1][1] = r[0][1];
        std::cout &amp;lt;&amp;lt; (la = std::max(f[1][0], f[1][1])) &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    &amp;#125;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;树上路径问题染色&#34;&gt;树上路径问题：染色&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P2486&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P2486&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;GBT 上的&lt;strong&gt;路径问题&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;BST：首先暴力爬山到 LCA，统计一路上的答案；然后跳到当前 BST 的根。由于本题有标记，所以需要在跳的同时想办法把标记问题解决一下。&lt;/p&gt;
&lt;p&gt;线段树：把树剖的线段树略改一下就过了。从上一行模棱两可的描述就可以看出来 BST 实现起来不太轻松；还是线段树更轮椅啊！&lt;/p&gt;
&lt;details&gt;
&lt;p&gt;跑得没纯树剖快，因为数据没有刻意构造导致树高很低，再加上常数的影响吧。&lt;/p&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int maxn = 1e5 + 5;
const int LEN = (1 &amp;lt;&amp;lt; 20);
int nec(void) &amp;#123;
    static char buf[LEN], *p = buf, *e = buf;
    if (p == e) &amp;#123;
        e = buf + fread(buf, 1, LEN, stdin);
        if (e == buf) return EOF;
        p = buf;
    &amp;#125;
    return *p++;
&amp;#125;
bool read(int &amp;amp;x) &amp;#123;
    x = 0;
    bool f = 0;
    char ch = nec();
    while (ch &amp;lt; &amp;#39;0&amp;#39; || ch &amp;gt; &amp;#39;9&amp;#39;) &amp;#123;
        if (ch == EOF) return 0;
        if (ch == &amp;#39;-&amp;#39;) f = 1;
        ch = nec();
    &amp;#125;
    while (ch &amp;gt;= &amp;#39;0&amp;#39; &amp;amp;&amp;amp; ch &amp;lt;= &amp;#39;9&amp;#39;) &amp;#123;
        x = x * 10 + ch - &amp;#39;0&amp;#39;;
        ch = nec();
    &amp;#125;
    if (f) x = -x;
    return 1;
&amp;#125;
void read(char &amp;amp;x) &amp;#123;
    for (x = nec(); x != &amp;#39;C&amp;#39; &amp;amp;&amp;amp; x != &amp;#39;Q&amp;#39;; x = nec());
    return;
&amp;#125;
void print(int x) &amp;#123;
    if (x &amp;lt; 0)
        putchar(&amp;#39;-&amp;#39;), x = -x;
    if (x &amp;gt;= 10) print(x / 10);
    putchar(x % 10 + &amp;#39;0&amp;#39;);
    return;
&amp;#125;
void print(int x, char ch) &amp;#123;
    print(x), putchar(ch);
    return;
&amp;#125;
class node &amp;#123;
private:
    int lt, rt;
public:
    int l, r, mid, lc, rc, u, d;
    node(): u(-1) &amp;#123;&amp;#125;
    inline int&amp;amp; ls(void) &amp;#123; return lt; &amp;#125;
    inline int&amp;amp; rs(void) &amp;#123; return rt; &amp;#125;
    node&amp;amp; operator= (const node &amp;amp;q) &amp;#123;
        lc = q.lc, rc = q.rc, u = q.u;
        return *this;
    &amp;#125;
    node operator+ (const node &amp;amp;q) const &amp;#123;
        if (u == -1)
            return q;
        if (q.u == -1)
            return *this;
        node res;
        res.lc = lc, res.rc = q.rc, res.u = u + q.u - (rc == q.lc);
        return res;
    &amp;#125;
    inline void swap(void) &amp;#123;
        if (~u)
            lc ^= rc ^= lc ^= rc;
        return;
    &amp;#125;
&amp;#125; t[maxn &amp;lt;&amp;lt; 2]; 
int tab[maxn], ls[maxn], a[maxn];
#define lt t[p].ls()
#define rt t[p].rs()
void bld(int &amp;amp;p, int l, int r) &amp;#123;
    static int tot = 0;
    p = ++tot, t[p].l = l, t[p].r = r;
    if (l == r) &amp;#123;
        t[p].u = 1;
        t[p].lc = t[p].rc = a[tab[l]];
        return;
    &amp;#125;
    int s = 0, u = ls[tab[l]];
    for (int i = l; i &amp;lt;= r; ++i)
        s += ls[tab[i]];
    s &amp;gt;&amp;gt;= 1;
    t[p].mid = r - 1;
    for (int i = l + 1; i &amp;lt; r; ++i) &amp;#123;
        u += ls[tab[i]];
        if (u + ls[tab[i + 1]] &amp;gt; s) &amp;#123;
            t[p].mid = i;
            break;
        &amp;#125;
    &amp;#125;
    bld(lt, l, t[p].mid), bld(rt, t[p].mid + 1, r);
    t[p] = t[lt] + t[rt];
    return;
&amp;#125;
void pushdown(int p) &amp;#123;
    if (t[p].d) &amp;#123;
        t[lt].d = t[lt].lc = t[lt].rc = t[rt].d = t[rt].lc = t[rt].rc = t[p].d;
        t[lt].u = t[rt].u = 1;
        t[p].d = 0;
    &amp;#125;
    return;
&amp;#125;
void add(int p, int l, int r, int v) &amp;#123;
    if (l &amp;lt;= t[p].l &amp;amp;&amp;amp; t[p].r &amp;lt;= r) &amp;#123;
        t[p].u = 1;
        t[p].lc = t[p].rc = t[p].d = v;
        return;
    &amp;#125;
    pushdown(p);
    if (l &amp;lt;= t[p].mid)
        add(lt, l, r, v);
    if (r &amp;gt; t[p].mid)
        add(rt, l, r, v);
    t[p] = t[lt] + t[rt];
    return;
&amp;#125;
node ask(int p, int l, int r) &amp;#123;
    if (l &amp;lt;= t[p].l &amp;amp;&amp;amp; t[p].r &amp;lt;= r)
        return t[p];
    pushdown(p);
    if (r &amp;lt;= t[p].mid)
        return ask(lt, l, r);
    if (l &amp;gt; t[p].mid)
        return ask(rt, l, r);
    return ask(lt, l, r) + ask(rt, l, r);
&amp;#125;
#undef lt
#undef rt
int main() &amp;#123;
#ifdef ONLINE_JUDGE
#else
    std::freopen(&amp;quot;paint17.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, q;
    read(n), read(q);
    std::vector&amp;lt;int&amp;gt; rt(n + 1);
    for (int i = 1; i &amp;lt;= n; ++i)
        read(a[i]);
    std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; g(n + 1);
    for (int i = 1, x, y; i &amp;lt; n; ++i) &amp;#123;
        read(x), read(y);
        g[x].push_back(y), g[y].push_back(x);
    &amp;#125;
    std::vector&amp;lt;int&amp;gt; siz(n + 1), son(n + 1), fa(n + 1), dep(n + 1);
    std::function&amp;lt;void(int)&amp;gt; DFS = [&amp;amp;](int x) &amp;#123;
        siz[x] = 1;
        for (auto i : g[x])
            if (i != fa[x]) &amp;#123;
                dep[i] = dep[x] + 1;
                fa[i] = x, DFS(i);
                siz[x] += siz[i];
                if (siz[i] &amp;gt; siz[son[x]])
                    son[x] = i;
            &amp;#125;
        return;
    &amp;#125;;
    DFS(1);
    std::vector&amp;lt;std::array&amp;lt;int, 2&amp;gt; &amp;gt; f(n + 1);
    std::vector&amp;lt;int&amp;gt; top(n + 1), bot(n + 1), dfn(n + 1);
    DFS = [&amp;amp;](int x) &amp;#123;
        static int now = 0;
        dfn[x] = ++now, tab[now] = x, ls[x] = 1;
        if (son[x]) &amp;#123;
            top[son[x]] = top[x], DFS(son[x]);
            bot[x] = bot[son[x]];
        &amp;#125;
        else
            bot[x] = x;
        for (auto i : g[x])
            if (i != son[x] &amp;amp;&amp;amp; i != fa[x]) &amp;#123;
                top[i] = i;
                DFS(i);
                ls[x] += siz[i];
            &amp;#125;
        if (x == top[x])
            bld(rt[x], dfn[x], dfn[bot[x]]);
        return;
    &amp;#125;;
    top[1] = 1, DFS(1);
    for (char op; q--; ) &amp;#123;
        read(op);
        if (op == &amp;#39;C&amp;#39;) &amp;#123;
            int x, y, c;
            read(x), read(y), read(c);
            for (; top[x] != top[y]; x = fa[top[x]]) &amp;#123;
                if (dep[top[x]] &amp;lt; dep[top[y]])
                    std::swap(x, y);
                add(rt[top[x]], dfn[top[x]], dfn[x], c);
            &amp;#125;
            if (dep[x] &amp;gt; dep[y])
                std::swap(x, y);
            add(rt[top[x]], dfn[x], dfn[y], c);
        &amp;#125;
        else &amp;#123;
            int x, y;
            read(x), read(y);
            node res1, res2;
            for (; top[x] != top[y]; )
                if (dep[top[x]] &amp;lt; dep[top[y]]) &amp;#123;
                    res2 = ask(rt[top[y]], dfn[top[y]], dfn[y]) + res2;
                    y = fa[top[y]];
                &amp;#125;
                else &amp;#123;
                    res1 = ask(rt[top[x]], dfn[top[x]], dfn[x]) + res1;
                    x = fa[top[x]];
                &amp;#125;
            if (dep[x] &amp;gt; dep[y])
                res1 = ask(rt[top[y]], dfn[y], dfn[x]) + res1;
            else
                res2 = ask(rt[top[x]], dfn[x], dfn[y]) + res2;
            res1.swap();
            print((res1 + res2).u, &amp;#39;\n&amp;#39;);
        &amp;#125;
    &amp;#125;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;树上路径查询&#34;&gt;树上路径查询？&lt;/h3&gt;
&lt;p&gt;做题的时候可以感受到，路径询问的存在很诡异，因为只需要一条链的操作，更偏向链上 DDP 而非树上的；&lt;strong&gt;轻儿子的信息是不用维护的&lt;/strong&gt;，形式上更像树剖（DS）；当成链上的 DDP 就可以解决了。&lt;/p&gt;
&lt;p&gt;可以用倍增维护 DDP（不用考虑轻重儿子，只用维护父子关系，进一步向序列 DDP 靠近），就不用打 GBT 了，常数也会小一些。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;习题&#34;&gt;习题&lt;/h2&gt;
&lt;p&gt;GBT 就统一用线段树了。DDP 也就可以顺带用 GBT 优化了。&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;e---猫或狗-cats-or-dogs&#34;&gt;E - 猫或狗 / Cats or Dogs&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P9597&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P9597&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;设 &lt;span class=&#34;math inline&#34;&gt;\(f_{u,0/1}\)&lt;/span&gt; 表示从根上颜色为 &lt;span class=&#34;math inline&#34;&gt;\(0/1\)&lt;/span&gt; 时的最小断边数，显然无色可以视作任选一个颜色。那么有：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
f_{u,a}=\sum\limits_v\min\limits_{b\in\{0,1\}}\{f_{v,b}+[a\ne b]\}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;直接把轻儿子的项提出来，记 &lt;span class=&#34;math inline&#34;&gt;\(g_{u,0/1}\)&lt;/span&gt; 表示 &lt;span class=&#34;math inline&#34;&gt;\(f_{u,0/1}\)&lt;/span&gt; 对应的轻儿子贡献即可。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int maxn = 1e5 + 5;
const int inf = 0x3f3f3f3f;
struct mat &amp;#123;
    int a[2][2];
    int* operator[] (const int q) &amp;#123; 
        return a[q];
    &amp;#125;
    mat operator* (mat &amp;amp;q) const &amp;#123;
        mat res;
        res[0][0] = res[0][1] = res[1][0] = res[1][1] = inf;
        for (int i = 0; i &amp;lt; 2; ++i)
            for (int k = 0; k &amp;lt; 2; ++k)
                for (int j = 0; j &amp;lt; 2; ++j)
                    res[i][k] = std::min(res[i][k], a[i][j] + q[j][k]);
        return res;
    &amp;#125;
    mat&amp;amp; operator*= (mat &amp;amp;q) &amp;#123;
        return *this = *this * q;
    &amp;#125;
&amp;#125; p[maxn];
struct &amp;#123; int lc, rc, l, r, mid; mat u; &amp;#125; t[maxn &amp;lt;&amp;lt; 2]; 
int ls[maxn], tab[maxn], g[maxn][2], rt[maxn], top[maxn], dfn[maxn], fa[maxn];
std::vector&amp;lt;int&amp;gt; a;
#define lt t[p].lc
#define rt t[p].rc
void bld(int &amp;amp;p, int l, int r) &amp;#123;
    static int tot = 0;
    p = ++tot, t[p].l = l, t[p].r = r;
    if (l == r) &amp;#123;
        t[p].u[0][1] = t[p].u[1][0] = 1;
        return;
    &amp;#125;
    int s = 0, u = ls[tab[l]];
    for (int i = l; i &amp;lt;= r; ++i)
        s += ls[tab[i]];
    s &amp;gt;&amp;gt;= 1;
    t[p].mid = r - 1;
    for (int i = l + 1; i &amp;lt; r; ++i) &amp;#123;
        u += ls[tab[i]];
        if (u + ls[tab[i + 1]] &amp;gt; s) &amp;#123;
            t[p].mid = i;
            break;
        &amp;#125;
    &amp;#125;
    bld(lt, l, t[p].mid), bld(rt, t[p].mid + 1, r);
    t[p].u = t[rt].u * t[lt].u;
    return;
&amp;#125;
void add(int p, int x) &amp;#123;
    if (t[p].l == t[p].r) &amp;#123;
        int u = tab[x], g0 = (a[u] == 1 ? inf : g[u][0]), g1 = (a[u] == 0 ? inf : g[u][1]);
        t[p].u[0][0] = g0, t[p].u[0][1] = g1 + 1;
        t[p].u[1][0] = g0 + 1, t[p].u[1][1] = g1;
        return;
    &amp;#125;
    if (x &amp;lt;= t[p].mid)
        add(lt, x);
    else
        add(rt, x);
    t[p].u = t[rt].u * t[lt].u;
    return;
&amp;#125;
#undef lt
#undef rt
void initialize(int n, std::vector&amp;lt;int&amp;gt; A, std::vector&amp;lt;int&amp;gt; B) &amp;#123;
    a.assign(n + 1, -1);
    std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; g1(n + 1);
    for (int i = 0; i &amp;lt; n - 1; ++i)
        g1[A[i]].push_back(B[i]), g1[B[i]].push_back(A[i]);
    std::vector&amp;lt;int&amp;gt; siz(n + 1), son(n + 1);
    std::function&amp;lt;void(int)&amp;gt; DFS = [&amp;amp;](int x) &amp;#123;
        siz[x] = 1;
        for (auto i : g1[x])
            if (i != fa[x]) &amp;#123;
                fa[i] = x, DFS(i);
                siz[x] += siz[i];
                if (siz[i] &amp;gt; siz[son[x]])
                    son[x] = i;
            &amp;#125;
        return;
    &amp;#125;;
    DFS(1);
    std::vector&amp;lt;int&amp;gt; bot(n + 1);
    DFS = [&amp;amp;](int x) &amp;#123;
        static int now = 0;
        dfn[x] = ++now, tab[now] = x, ls[x] = 1;
        if (son[x]) &amp;#123;
            top[son[x]] = top[x], DFS(son[x]);
            bot[x] = bot[son[x]];
            for (auto i : g1[x])
                if (i != son[x] &amp;amp;&amp;amp; i != fa[x]) &amp;#123;
                    top[i] = i, DFS(i);
                    ls[x] += siz[i];
                &amp;#125;
        &amp;#125;
        else
            bot[x] = x;
        if (x == top[x])
            bld(rt[x], dfn[x], dfn[bot[x]]);
        return;
    &amp;#125;;
    top[1] = 1, DFS(1);
    return;
&amp;#125;
int upd(int x) &amp;#123;
    for (; top[x] != 1; ) &amp;#123;
        int faa = fa[top[x]];
        auto &amp;amp;id = t[rt[top[x]]].u;
        int f0 = std::min(id[0][0], id[1][0]), f1 = std::min(id[0][1], id[1][1]);
        g[faa][0] -= std::min(f0, f1 + 1);
        g[faa][1] -= std::min(f0 + 1, f1);
        add(rt[top[x]], dfn[x]);
        f0 = std::min(id[0][0], id[1][0]), f1 = std::min(id[0][1], id[1][1]);
        // printf(&amp;quot;%d: f0 = %d, f1 = %d\n&amp;quot;, top[x], f0, f1);
        g[faa][0] += std::min(f0, f1 + 1);
        g[faa][1] += std::min(f0 + 1, f1);
        x = faa;
    &amp;#125;
    add(rt[1], dfn[x]);
    auto &amp;amp;id = t[rt[1]].u;
    int f0 = std::min(id[0][0], id[1][0]), f1 = std::min(id[0][1], id[1][1]);
    // printf(&amp;quot;%d: f0 = %d, f1 = %d\n&amp;quot;, 1, f0, f1);
    return std::min(f0, f1);
&amp;#125;
int cat(int x) &amp;#123;
    a[x] = 0;
    return upd(x);
&amp;#125;
int dog(int x) &amp;#123;
    a[x] = 1;
    return upd(x);
&amp;#125;
int neighbor(int x) &amp;#123;
    a[x] = -1;
    return upd(x);
&amp;#125;
#ifndef ONLINE_JUDGE
int main() &amp;#123;
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
    int n;
    std::cin &amp;gt;&amp;gt; n;
    std::vector&amp;lt;int&amp;gt; A(n - 1), B(n - 1);
    for (int i = 0; i &amp;lt; n - 1; ++i)
        std::cin &amp;gt;&amp;gt; A[i] &amp;gt;&amp;gt; B[i];
    initialize(n, A, B);
    int q;
    std::cin &amp;gt;&amp;gt; q;
    for (int op, x; q--; ) &amp;#123;
        std::cin &amp;gt;&amp;gt; op &amp;gt;&amp;gt; x;
        std::cout &amp;lt;&amp;lt; (op == 1 ? cat(x) : (op == 2 ? dog(x) : neighbor(x))) &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    &amp;#125;
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
    return 0;
&amp;#125;
#endif&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;f---hash-on-tree&#34;&gt;F - Hash on Tree&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/AT_abc351_g&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/AT_abc351_g&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;记 &lt;span class=&#34;math inline&#34;&gt;\(g_x\)&lt;/span&gt; 为轻儿子的哈希值之积，则 &lt;span class=&#34;math inline&#34;&gt;\(f_u=A_u+f_{son}\cdot g_u\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;然后开一个常数维即可。快速幂的 log 省不掉，所以是双 log 的。&lt;/p&gt;
&lt;p&gt;初值和修改都有可能为 &lt;span class=&#34;math inline&#34;&gt;\(0\)&lt;/span&gt;，需要维护实际哈希值和去掉 &lt;span class=&#34;math inline&#34;&gt;\(0\)&lt;/span&gt; 的哈希值。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int maxn = 1e6 + 5;
const int LEN = (1 &amp;lt;&amp;lt; 20);
const int mod = 998244353;
int nec(void) &amp;#123;
    static char buf[LEN], *p = buf, *e = buf;
    if (p == e) &amp;#123;
        e = buf + fread(buf, 1, LEN, stdin);
        if (e == buf) return EOF;
        p = buf;
    &amp;#125;
    return *p++;
&amp;#125;
bool read(int &amp;amp;x) &amp;#123;
    x = 0;
    bool f = 0;
    char ch = nec();
    while (ch &amp;lt; &amp;#39;0&amp;#39; || ch &amp;gt; &amp;#39;9&amp;#39;) &amp;#123;
        if (ch == EOF) return 0;
        if (ch == &amp;#39;-&amp;#39;) f = 1;
        ch = nec();
    &amp;#125;
    while (ch &amp;gt;= &amp;#39;0&amp;#39; &amp;amp;&amp;amp; ch &amp;lt;= &amp;#39;9&amp;#39;) &amp;#123;
        x = x * 10 + ch - &amp;#39;0&amp;#39;;
        ch = nec();
    &amp;#125;
    if (f) x = -x;
    return 1;
&amp;#125;
void print(int x) &amp;#123;
    if (x &amp;lt; 0)
        putchar(&amp;#39;-&amp;#39;), x = -x;
    if (x &amp;gt;= 10) print(x / 10);
    putchar(x % 10 + &amp;#39;0&amp;#39;);
    return;
&amp;#125;
void print(int x, char ch) &amp;#123;
    print(x), putchar(ch);
    return;
&amp;#125;
struct mat &amp;#123;
    int n, m;
    long long a[2][2];
    long long* operator[] (const int q) &amp;#123;
        return a[q];
    &amp;#125;
    mat operator* (mat &amp;amp;q) const &amp;#123;
        mat res;
        res.n = n, res.m = q.m;
        res[0][0] = res[0][1] = res[1][0] = res[1][1] = 0ll;
        for (int i = 0; i &amp;lt; n; ++i)
            for (int k = 0; k &amp;lt; q.m; ++k) &amp;#123;
                for (int j = 0; j &amp;lt; m; ++j)
                    res[i][k] += a[i][j] * q[j][k];
                res[i][k] %= mod;
            &amp;#125;
        return res;
    &amp;#125;
    mat&amp;amp; operator*= (mat &amp;amp;q) &amp;#123;
        return *this = *this * q;
    &amp;#125;
&amp;#125;;
struct &amp;#123; int lc, rc, l, r, mid; mat u; &amp;#125; t[maxn &amp;lt;&amp;lt; 2]; 
long long g[maxn];
int tab[maxn], ls[maxn], a[maxn];
#define lt t[p].lc
#define rt t[p].rc
void bld(int &amp;amp;p, int l, int r) &amp;#123;
    static int tot = 0;
    p = ++tot, t[p].l = l, t[p].r = r;
    if (l == r) &amp;#123;
        int u = tab[l];
        t[p].u.n = t[p].u.m = 2;
        t[p].u[0][0] = g[u];
        t[p].u[0][1] = 0ll;
        t[p].u[1][0] = a[u];
        t[p].u[1][1] = 1ll;
        return;
    &amp;#125;
    int s = 0, u = ls[tab[l]];
    for (int i = l; i &amp;lt;= r; ++i)
        s += ls[tab[i]];
    s &amp;gt;&amp;gt;= 1;
    t[p].mid = r - 1;
    for (int i = l + 1; i &amp;lt; r; ++i) &amp;#123;
        u += ls[tab[i]];
        if (u + ls[tab[i + 1]] &amp;gt; s) &amp;#123;
            t[p].mid = i;
            break;
        &amp;#125;
    &amp;#125;
    bld(lt, l, t[p].mid), bld(rt, t[p].mid + 1, r);
    t[p].u = t[rt].u * t[lt].u;
    return;
&amp;#125;
void add(int p, int x) &amp;#123;
    if (t[p].l == t[p].r) &amp;#123;
        int u = tab[x];
        t[p].u[0][0] = g[u];
        t[p].u[1][0] = a[u];
        return;
    &amp;#125;
    if (x &amp;lt;= t[p].mid)
        add(lt, x);
    else
        add(rt, x);
    t[p].u = t[rt].u * t[lt].u;
    return;
&amp;#125;
#undef lt
#undef rt
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, q;
    read(n), read(q);
    std::vector&amp;lt;int&amp;gt; rt(n + 1);
    std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; g1(n + 1);
    for (int i = 2, x; i &amp;lt;= n; ++i) &amp;#123;
        read(x);
        g1[i].push_back(x), g1[x].push_back(i);
    &amp;#125;
    for (int i = 1; i &amp;lt;= n; ++i)
        read(a[i]);
    std::vector&amp;lt;int&amp;gt; siz(n + 1), son(n + 1), fa(n + 1);
    std::function&amp;lt;void(int)&amp;gt; DFS = [&amp;amp;](int x) &amp;#123;
        siz[x] = 1;
        for (auto i : g1[x])
            if (i != fa[x]) &amp;#123;
                fa[i] = x, DFS(i);
                siz[x] += siz[i];
                if (siz[i] &amp;gt; siz[son[x]])
                    son[x] = i;
            &amp;#125;
        return;
    &amp;#125;;
    DFS(1);
    std::vector&amp;lt;long long&amp;gt; f(n + 1);
    std::vector&amp;lt;int&amp;gt; top(n + 1), bot(n + 1), dfn(n + 1), la(n + 1), cnt(n + 1);
    DFS = [&amp;amp;](int x) &amp;#123;
        static int now = 0;
        dfn[x] = ++now, tab[now] = x, ls[x] = 1;
        if (son[x]) &amp;#123;
            top[son[x]] = top[x], DFS(son[x]);
            bot[x] = bot[son[x]];
            g[x] = 1ll;
            for (auto i : g1[x])
                if (i != son[x] &amp;amp;&amp;amp; i != fa[x]) &amp;#123;
                    top[i] = i, DFS(i);
                    ls[x] += siz[i];
                    if (f[i] == 0ll)
                        ++cnt[x];
                    else
                        (la[x] *= f[i]) %= mod;
                    (g[x] *= f[i]) %= mod;
                &amp;#125;
            f[x] = (a[x] + g[x] * f[son[x]]) % mod;
        &amp;#125;
        else
            f[x] = a[x], bot[x] = x;
        // printf(&amp;quot;f[%d] = %lld\n&amp;quot;, x, f[x]);
        if (x == top[x])
            bld(rt[x], dfn[x], dfn[bot[x]]);
        return;
    &amp;#125;;
    top[1] = 1, DFS(1);
    mat init;
    init.n = 1, init.m = 2;
    init[0][0] = 0ll, init[0][1] = 1ll;
    auto qkp = [&amp;amp;](long long x, int y) &amp;#123;
        auto res(1ll);
        for (; y; (x *= x) %= mod, y &amp;gt;&amp;gt;= 1)
            if (y &amp;amp; 1)
                (res *= x) %= mod;
        return res;
    &amp;#125;;
    auto inv = [&amp;amp;](int x) &amp;#123;
        return qkp(x, mod - 2);
    &amp;#125;;
    for (int x, v; q--; ) &amp;#123;
        read(x), read(v);
        a[x] = v;
        for (; top[x] != 1; ) &amp;#123;
            int faa = fa[top[x]];
            auto &amp;amp;id = t[rt[top[x]]].u;
            int f = (init * id)[0][0];
            if (f == 0) &amp;#123;
                if (--cnt[faa] == 0)
                    g[faa] = la[faa];
            &amp;#125;
            else &amp;#123;
                f = inv(f);
                (g[faa] *= f) %= mod;
                (la[faa] *= f) %= mod;
            &amp;#125;
            add(rt[top[x]], dfn[x]);
            f = (init * id)[0][0];
            if (f == 0) &amp;#123;
                if (cnt[faa]++ == 0)
                    la[faa] = g[faa];
                g[faa] = 0ll;
            &amp;#125;
            else &amp;#123;
                (g[faa] *= f) %= mod;
                (la[faa] *= f) %= mod;
            &amp;#125;
            x = faa;
        &amp;#125;
        add(rt[1], dfn[x]);
        auto &amp;amp;id = t[rt[1]].u;
        int f = (init * id)[0][0];
        std::cout &amp;lt;&amp;lt; f &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    &amp;#125;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;g---考试-2&#34;&gt;G - 考试 2&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P10626&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P10626&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;运算均是线性的，容易想到『按位』维护，即只维护某个特定点值。如果将询问离线下来排序，每个函数的点值只会变化 &lt;span class=&#34;math inline&#34;&gt;\(O(1)\)&lt;/span&gt; 次。&lt;/p&gt;
&lt;p&gt;建出符号二叉树，进行 DDP 即可。具体地，令 &lt;span class=&#34;math inline&#34;&gt;\(f_u\)&lt;/span&gt; 表示在运算 &lt;span class=&#34;math inline&#34;&gt;\(u\)&lt;/span&gt; 处的答案，计算 &lt;span class=&#34;math inline&#34;&gt;\(g_u\)&lt;/span&gt; 为轻儿子的答案，按照 &lt;span class=&#34;math inline&#34;&gt;\(u\)&lt;/span&gt; 处的符号写矩阵即可。叶子不是一次运算，应该直接填入点值（注意线段树上的叶子不一定是原树上的叶子）。&lt;/p&gt;
&lt;p&gt;建树和矩阵更新有点史，适当封装一下感觉会好一点&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int maxn = 1e6 + 5;
const char mp[] = &amp;quot;x!&amp;amp;|^&amp;quot;;
const int LEN = (1 &amp;lt;&amp;lt; 20);
#define nec getchar
inline bool read(int &amp;amp;x) &amp;#123;
    x = 0;
    bool f = 0;
    char ch = nec();
    while (ch &amp;lt; &amp;#39;0&amp;#39; || ch &amp;gt; &amp;#39;9&amp;#39;) &amp;#123;
        if (ch == EOF) return 0;
        if (ch == &amp;#39;-&amp;#39;) f = 1;
        ch = nec();
    &amp;#125;
    while (ch &amp;gt;= &amp;#39;0&amp;#39; &amp;amp;&amp;amp; ch &amp;lt;= &amp;#39;9&amp;#39;) &amp;#123;
        x = x * 10 + ch - &amp;#39;0&amp;#39;;
        ch = nec();
    &amp;#125;
    if (f) x = -x;
    return 1;
&amp;#125;
void print(int x) &amp;#123;
    if (x &amp;lt; 0)
        putchar(&amp;#39;-&amp;#39;), x = -x;
    if (x &amp;gt;= 10) print(x / 10);
    putchar(x % 10 + &amp;#39;0&amp;#39;);
    return;
&amp;#125;
void print(int x, char ch) &amp;#123;
    print(x), putchar(ch);
    return;
&amp;#125;
struct mat &amp;#123;
    int n, m;
    int a[2][2];
    int* operator[] (const int q) &amp;#123;
        return a[q];
    &amp;#125;
    inline mat operator* (mat &amp;amp;q) const &amp;#123;
        mat res;
        res.n = n, res.m = q.m;
        res[0][0] = res[0][1] = res[1][0] = res[1][1] = 0ll;
        for (int i = 0; i &amp;lt; n; ++i)
            for (int k = 0; k &amp;lt; q.m; ++k)
                for (int j = 0; j &amp;lt; m; ++j)
                    res[i][k] += a[i][j] * q[j][k];
        return res;
    &amp;#125;
    mat&amp;amp; operator*= (mat &amp;amp;q) &amp;#123;
        return *this = *this * q;
    &amp;#125;
&amp;#125;;
struct &amp;#123; int lc, rc, l, r, mid; mat u; &amp;#125; t[maxn &amp;lt;&amp;lt; 2]; 
int g1[maxn][2];
int g[maxn], ty[maxn];
int tab[maxn], ls[maxn], lim[maxn];
#define lt t[p].lc
#define rt t[p].rc
void fillmat(mat &amp;amp;a, int op, int g) &amp;#123;
    if (op == 0) &amp;#123;
        a.n = 1, a.m = 2;
        a[0][!g] = 0, a[0][g] = 1;
        return;
    &amp;#125;
    a.n = 2, a.m = 2;
    switch (op) &amp;#123;
    case 1: // !
        a[0][0] = 0, a[0][1] = 1;
        a[1][0] = 1, a[1][1] = 0;
        break;
    case 2: // &amp;amp;
        a[0][0] = 1, a[0][1] = 0;
        a[1][0] = !g, a[1][1] = g;
        break;
    case 3: // |
        a[0][0] = !g, a[0][1] = g;
        a[1][0] = 0, a[1][1] = 1;
        break;
    case 4: // ^
        a[0][0] = !g, a[0][1] = g;
        a[1][0] = g, a[1][1] = !g;
        break;
    default:
        assert(0);
    &amp;#125;
    return;
&amp;#125;
void bld(int &amp;amp;p, int l, int r) &amp;#123;
    static int tot = 0;
    p = ++tot, t[p].l = l, t[p].r = r;
    if (l == r) &amp;#123;
        fillmat(t[p].u, ty[tab[l]], g[tab[l]]);
        return;
    &amp;#125;
    int s = 0, u = ls[tab[l]];
    for (int i = l; i &amp;lt;= r; ++i)
        s += ls[tab[i]];
    s &amp;gt;&amp;gt;= 1;
    t[p].mid = r - 1;
    for (int i = l + 1; i &amp;lt; r; ++i) &amp;#123;
        u += ls[tab[i]];
        if (u + ls[tab[i + 1]] &amp;gt; s) &amp;#123;
            t[p].mid = i;
            break;
        &amp;#125;
    &amp;#125;
    bld(lt, l, t[p].mid), bld(rt, t[p].mid + 1, r);
    t[p].u = t[rt].u * t[lt].u;
    return;
&amp;#125;
void add(int p, int x) &amp;#123;
    if (t[p].l == t[p].r) &amp;#123;
        fillmat(t[p].u, ty[tab[t[p].l]], g[tab[t[p].l]]);
        return;
    &amp;#125;
    if (x &amp;lt;= t[p].mid)
        add(lt, x);
    else
        add(rt, x);
    t[p].u = t[rt].u * t[lt].u;
    return;
&amp;#125;
#undef lt
#undef rt
int main() &amp;#123;
#ifndef ONLINE_JUDGE
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n = 0, q, p;
    read(q), read(q);
    &amp;#123;
        std::string s;
        std::cin &amp;gt;&amp;gt; s;
        std::stringstream in(s);
        std::stack&amp;lt;char&amp;gt; op;
        std::stack&amp;lt;int&amp;gt; id;
        auto trans = [&amp;amp;](char t) &amp;#123;
            switch (t) &amp;#123;
            case &amp;#39;!&amp;#39;:
                return 1;
            case &amp;#39;&amp;amp;&amp;#39;:
                return 2;
            case &amp;#39;|&amp;#39;:
                return 3;
            case &amp;#39;^&amp;#39;:
                return 4;
            &amp;#125;
            assert(0);
            return -1;
        &amp;#125;;
        auto calcNot = [&amp;amp;](void) &amp;#123;
            for (; !op.empty() &amp;amp;&amp;amp; op.top() == &amp;#39;!&amp;#39;; ) &amp;#123;
                ty[++n] = trans(op.top());
                g1[n][0] = id.top(), id.pop(), id.push(n);
                op.pop();
            &amp;#125;
            return;
        &amp;#125;;
        auto opt = [&amp;amp;](void) &amp;#123;
            ty[++n] = trans(op.top());
            g1[n][0] = id.top(), id.pop();
            g1[n][1] = id.top(), id.pop();
            id.push(n), op.pop();
            return;
        &amp;#125;;
        for (char t; in &amp;gt;&amp;gt; t; )
            if (t == &amp;#39;[&amp;#39;) &amp;#123;
                int x;
                in &amp;gt;&amp;gt; x, in &amp;gt;&amp;gt; t;
                lim[++n] = x - 1;
                id.push(n), calcNot();
            &amp;#125;
            else if (t == &amp;#39;(&amp;#39;)
                op.push(t);
            else if (t == &amp;#39;)&amp;#39;) &amp;#123;
                for (; op.top() != &amp;#39;(&amp;#39;; opt());
                op.pop(), calcNot();
            &amp;#125;
            else if (t == &amp;#39;&amp;amp;&amp;#39;)
                op.push(t);
            else if (t == &amp;#39;^&amp;#39;) &amp;#123;
                for (; !op.empty() &amp;amp;&amp;amp; op.top() == &amp;#39;&amp;amp;&amp;#39;; opt());
                op.push(t);
            &amp;#125;
            else if (t == &amp;#39;|&amp;#39;) &amp;#123;
                for (; !op.empty() &amp;amp;&amp;amp; (op.top() == &amp;#39;&amp;amp;&amp;#39; || op.top() == &amp;#39;^&amp;#39;); opt());
                op.push(t);
            &amp;#125;
            else &amp;#123;
                assert(t == &amp;#39;!&amp;#39;);
                op.push(t);
            &amp;#125;
        for (; !op.empty(); opt());
        p = id.top();
    &amp;#125;
    std::vector&amp;lt;int&amp;gt; rt(n + 1);
    std::vector&amp;lt;int&amp;gt; siz(n + 1), son(n + 1), fa(n + 1);
    std::function&amp;lt;void(int)&amp;gt; DFS = [&amp;amp;](int x) &amp;#123;
        siz[x] = 1;
        for (auto i : g1[x])
            if (i != 0) &amp;#123;
                fa[i] = x, DFS(i);
                siz[x] += siz[i];
                if (siz[i] &amp;gt; siz[son[x]])
                    son[x] = i;
            &amp;#125;
        return;
    &amp;#125;;
    DFS(p);
    std::vector&amp;lt;long long&amp;gt; f(n + 1);
    std::vector&amp;lt;int&amp;gt; top(n + 1), bot(n + 1), dfn(n + 1);
    DFS = [&amp;amp;](int x) &amp;#123;
        static int now = 0;
        dfn[x] = ++now, tab[now] = x, ls[x] = 1;
        if (son[x]) &amp;#123;
            top[son[x]] = top[x], DFS(son[x]);
            bot[x] = bot[son[x]];
            for (auto i : g1[x])
                if (i != son[x] &amp;amp;&amp;amp; i != 0) &amp;#123;
                    top[i] = i, DFS(i);
                    ls[x] += siz[i], g[x] = f[i];
                &amp;#125;
            switch (ty[x]) &amp;#123;
            case 1:
                f[x] = !f[son[x]];
                break;
            case 2:
                f[x] = g[x] &amp;amp; f[son[x]];
                break;
            case 3:
                f[x] = g[x] | f[son[x]];
                break;
            case 4:
                f[x] = g[x] ^ f[son[x]];
                break;
            default:
                assert(0);
                break;
            &amp;#125;
        &amp;#125;
        else
            assert(!ty[x]), f[x] = g[x] = 0, bot[x] = x;
        if (x == top[x])
            bld(rt[x], dfn[x], dfn[bot[x]]);
        return;
    &amp;#125;;
    top[p] = p, DFS(p);
    std::vector&amp;lt;int&amp;gt; a(q + 1), res(q + 1);
    for (int i = 1; i &amp;lt;= q; ++i)
        read(a[i]);
    std::vector&amp;lt;int&amp;gt; qid(q), nid;
    for (int i = 1; i &amp;lt;= n; ++i)
        if (ty[i] == 0)
            nid.push_back(i);
    std::iota(qid.begin(), qid.end(), 1);
    std::sort(qid.begin(), qid.end(), [&amp;amp;](int x, int y) &amp;#123; return a[x] &amp;lt; a[y]; &amp;#125;);
    std::sort(nid.begin(), nid.end(), [&amp;amp;](int x, int y) &amp;#123; return lim[x] &amp;gt; lim[y]; &amp;#125;);
    for (auto i : qid) &amp;#123;
        for (; !nid.empty() &amp;amp;&amp;amp; lim[nid.back()] &amp;lt; a[i]; ) &amp;#123;
            int x = nid.back();
            nid.pop_back();
            g[x] = 1;
            for (; top[x] != p; ) &amp;#123;
                add(rt[top[x]], dfn[x]);
                g[fa[top[x]]] = t[rt[top[x]]].u[0][1];
                x = fa[top[x]];
            &amp;#125;
            add(rt[p], dfn[x]);
        &amp;#125;
        res[i] = t[rt[p]].u[0][1];
    &amp;#125;
    for (int i = 1; i &amp;lt;= q; ++i)
        if (res[i])
            std::cout &amp;lt;&amp;lt; &amp;quot;True\n&amp;quot;;
        else
            std::cout &amp;lt;&amp;lt; &amp;quot;False\n&amp;quot;;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://xsc062.netlify.app/20250809/</guid>
            <title>近期杂题</title>
            <link>https://xsc062.netlify.app/20250809/</link>
            <category>字典树</category>
            <category>字符串</category>
            <category>组合数学</category>
            <category>支配对</category>
            <pubDate>Sat, 09 Aug 2025 12:33:17 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;这段时间比赛的一些题 和 nKessi、duanyu 讲的题目。太偏计数、数学的基本上没办法做了。&lt;/p&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;a.-出关&#34;&gt;A. 出关&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://222.180.160.110:61235/contest/6462/problem/1&#34; class=&#34;uri&#34;&gt;http://222.180.160.110:61235/contest/6462/problem/1&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定 &lt;span class=&#34;math inline&#34;&gt;\(s\)&lt;/span&gt;，对于一个空串，任意利用下列三种操作，使其变为 &lt;span class=&#34;math inline&#34;&gt;\(s\)&lt;/span&gt;，求最小代价：&lt;/p&gt;
&lt;ol type=&#34;1&#34;&gt;
&lt;li&gt;在末尾添加字符 &lt;span class=&#34;math inline&#34;&gt;\(c\)&lt;/span&gt;，代价为 &lt;span class=&#34;math inline&#34;&gt;\(t_{0,c}\)&lt;/span&gt;；&lt;/li&gt;
&lt;li&gt;复制整个字符串并粘贴在末尾，代价为 &lt;span class=&#34;math inline&#34;&gt;\(t_1\)&lt;/span&gt;；&lt;/li&gt;
&lt;li&gt;删除末尾字符，代价为 &lt;span class=&#34;math inline&#34;&gt;\(t_2\)&lt;/span&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(|s|\le 10^6\)&lt;/span&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可以预处理出对于每个 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 结尾，最多可以复制到哪个地方，发现要求 &lt;span class=&#34;math inline&#34;&gt;\(z_i=lcp(s_{1\dots n},s_{i+1\dots n})\)&lt;/span&gt;。那么一个 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 的最远转移点 &lt;span class=&#34;math inline&#34;&gt;\(r_i=i+z_{i+1}\)&lt;/span&gt;，用单调队列就能维护，会 exkmp 就能线性；&lt;/p&gt;
&lt;p&gt;否则可以二分 + 哈希多个 log，后面也有理由偷懒用优先队列了。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int p = 31;
const int mod = 998244353;
int main() &amp;#123;
    std::freopen(&amp;quot;laozi.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;laozi.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
    std::string s;
    std::cin &amp;gt;&amp;gt; s;
    int n = (int)s.length(), t1, t2;
    std::vector&amp;lt;long long&amp;gt; h(n + 1), base(n + 1);
    std::vector&amp;lt;int&amp;gt; a(n + 1), t0(27), z(n + 1), r(n + 1);
    base[0] = 1ll;
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        a[i] = s[i - 1] - &amp;#39;a&amp;#39; + 1;
        h[i] = (h[i - 1] * p + a[i]) % mod;
        base[i] = base[i - 1] * p % mod;
    &amp;#125;
    auto gethash = [&amp;amp;](int l, int r) &amp;#123;
        return (h[r] - h[l - 1] * base[r - l + 1] % mod + mod) % mod;
    &amp;#125;;
    for (int i = 1; i &amp;lt;= n; ++i)
        for (int l = 1, r = std::min(i - 1, n - i + 1), mid; l &amp;lt;= r; ) &amp;#123;
            mid = (l + r) &amp;gt;&amp;gt; 1;
            if (gethash(1, mid) == gethash(i, i + mid - 1))
                z[i] = mid, l = mid + 1;
            else
                r = mid - 1;
        &amp;#125;
    for (int i = 1; i &amp;lt; n; ++i)
        r[i] = i + std::min(i, z[i + 1]);
    for (int i = 1; i &amp;lt;= 26; ++i)
        std::cin &amp;gt;&amp;gt; t0[i];
    std::cin &amp;gt;&amp;gt; t1 &amp;gt;&amp;gt; t2;
    std::vector&amp;lt;long long&amp;gt; f(n + 1);
    std::priority_queue&amp;lt;std::pair&amp;lt;long long, int&amp;gt; &amp;gt; q;
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        f[i] = f[i - 1] + t0[a[i]];
        for (; !q.empty() &amp;amp;&amp;amp; r[q.top().second] &amp;lt; i; q.pop());
        if (!q.empty())
            f[i] = std::min(f[i], t1 - q.top().first - (long long)t2 * i);
        if (i != n)
            q.emplace(-(f[i] + 2ll * t2 * i), i);
    &amp;#125;
    std::cout &amp;lt;&amp;lt; f[n] &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;d.-非攻&#34;&gt;D. 非攻&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://222.180.160.110:61235/contest/6462/problem/4&#34; class=&#34;uri&#34;&gt;http://222.180.160.110:61235/contest/6462/problem/4&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定 &lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt;，对于一个 &lt;span class=&#34;math inline&#34;&gt;\(1\sim n\)&lt;/span&gt; 的排列，使用最小的交换次数使得其单增。在该前提下，定义代价为每次交换的两个数之积。对于所有 &lt;span class=&#34;math inline&#34;&gt;\(n!\)&lt;/span&gt; 个排列，计算最小代价之和。&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(n\le 10^7\)&lt;/span&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;转化成，把 &lt;span class=&#34;math inline&#34;&gt;\(1\sim n\)&lt;/span&gt; 分成无标号的若干组，每组的代价是 最小值 &lt;span class=&#34;math inline&#34;&gt;\(\times\)&lt;/span&gt; 其他元素的和，还有一个项链问题的系数，发现组间的符号是求和，考虑计算贡献。&lt;/p&gt;
&lt;p&gt;枚举 &lt;span class=&#34;math inline&#34;&gt;\(i,j\)&lt;/span&gt; 并钦定两个同属一个环，且 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 为最小值，枚举环大小 &lt;span class=&#34;math inline&#34;&gt;\(s+2\)&lt;/span&gt;，那么有：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
\begin{aligned}
res&amp;amp;=\sum_{i=1}^{n-1}\sum_{j=i+1}^n i\cdot j \cdot \sum_{s=0}^{n-i-1}\binom{n-i-1}s \cdot (s+1)!\cdot (n-s-2)!\\
&amp;amp;=\sum_{i=1}^{n-1}i\cdot \dfrac {(i+n+1)(n-i)}2 \cdot \sum_{s=0}^{n-i-1}\binom{n-i-1}s\cdot (s+1)!\cdot (n-s-2)!\\
&amp;amp;=\frac 12\times\sum_{i=1}^{n-1}i\cdot (i+n+1)\cdot (n-i)!\cdot\sum_{s=0}^{n-i-1}\dfrac {(s + 1)\cdot (n-s-2)!}{(n-i-1-s)!}\\
\end{aligned}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;令 &lt;span class=&#34;math inline&#34;&gt;\(T=n-i-1\)&lt;/span&gt;，发现我们需要快速计算 &lt;span class=&#34;math inline&#34;&gt;\(f_T=\sum\limits_{i=0}^T \dfrac{(i+1)\cdot (n-i-2)!}{(T-i)!}\)&lt;/span&gt;。记 &lt;span class=&#34;math inline&#34;&gt;\(m=n-2\)&lt;/span&gt;，变形得 &lt;span class=&#34;math inline&#34;&gt;\(f_T=(m-T)!\cdot \sum\limits_{i=0}^{T} (i+1) \binom{m-i}{m-T}\)&lt;/span&gt;，发现似乎可以简化，令 &lt;span class=&#34;math inline&#34;&gt;\(k=m-T,t=T+1\)&lt;/span&gt;，则 &lt;span class=&#34;math inline&#34;&gt;\(f_T=\sum\limits_{i=1}^T i\cdot \binom {k+t-i}k\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;然后是经典的组合意义保平安环节，即从 &lt;span class=&#34;math inline&#34;&gt;\(k+t\)&lt;/span&gt; 个有标号小球中选择一条分界线，分界线左边选一个球、右边选 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 个球的方案数。发现分界线的存在很诡异，故用分界线后方的第一个球代替，在 &lt;span class=&#34;math inline&#34;&gt;\(t+1\)&lt;/span&gt; 处新建一个虚球，规定在前 &lt;span class=&#34;math inline&#34;&gt;\(t+1\)&lt;/span&gt; 个球中选两个球，并令后一个为分界线，且令前 &lt;span class=&#34;math inline&#34;&gt;\(t+1\)&lt;/span&gt; 个中的其他球为实球，就能建立双射。在分界线后再选 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 个球，容易发现直接在范围内选 &lt;span class=&#34;math inline&#34;&gt;\(k+2\)&lt;/span&gt; 个球就能满足条件，故 &lt;span class=&#34;math inline&#34;&gt;\(f_T=(n-T-2)!\cdot \binom{t+k+1}{k+2}\)&lt;/span&gt;。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int mod = 1e9 + 7;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
    std::freopen(&amp;quot;mozi.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;mozi.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#endif
    int n;
    std::cin &amp;gt;&amp;gt; n;
    std::vector&amp;lt;long long&amp;gt; fac(n + 1), inv(n + 1), f(n + 1);
    fac[0] = inv[0] = 1ll;
    for (int i = 1; i &amp;lt;= n; ++i)
        fac[i] = fac[i - 1] * i % mod;
    auto qkp = [&amp;amp;](long long x, int y) &amp;#123;
        auto res(1ll);
        for (; y; (x *= x) %= mod, y &amp;gt;&amp;gt;= 1)
            if (y &amp;amp; 1)
                (res *= x) %= mod;
        return res;
    &amp;#125;;
    inv[n] = qkp(fac[n], mod - 2);
    for (int i = n - 1; i; --i)
        inv[i] = inv[i + 1] * (i + 1) % mod;
    auto C = [&amp;amp;](int n, int m) &amp;#123;
        return fac[n] * inv[n - m] % mod * inv[m] % mod;
    &amp;#125;;
    int m = n - 2;
    for (int T = 0; T &amp;lt;= n - 2; ++T) &amp;#123;
        int k = m - T, t = T + 1;
        f[T] = C(t + k + 1, k + 2) * fac[m - T] % mod;
    &amp;#125;
    auto res = 0ll;
    for (int i = 1; i &amp;lt;= n - 1; ++i)
        (res += (long long)i * (i + n + 1) % mod * fac[n - i] % mod * f[n - i - 1] % mod) %= mod;
    std::cout &amp;lt;&amp;lt; res * inv[2] % mod &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;c---destruction-of-walls&#34;&gt;C - Destruction of Walls&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/arc203/tasks/arc203_c&#34; class=&#34;uri&#34;&gt;https://atcoder.jp/contests/arc203/tasks/arc203_c&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;d---insert-xor&#34;&gt;D - Insert XOR&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/arc203/tasks/arc203_d&#34; class=&#34;uri&#34;&gt;https://atcoder.jp/contests/arc203/tasks/arc203_d&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;a---记忆&#34;&gt;A - 记忆&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://ac.nowcoder.com/acm/problem/274793&#34; class=&#34;uri&#34;&gt;https://ac.nowcoder.com/acm/problem/274793&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;需要意识到问题是静态的，并且不能用线段树之类维护；故考虑离线下来，想办法在 LCA 处统计答案。&lt;/p&gt;
&lt;p&gt;这个时候发现需要合并子树状态、整体异或、整体 +1，很容易想到 Trie。把 &lt;span class=&#34;math inline&#34;&gt;\(u\to\)&lt;/span&gt; LCA 的答案保存在 LCA 处，然后再用 DFS + 回溯统计 LCA &lt;span class=&#34;math inline&#34;&gt;\(\to v\)&lt;/span&gt; 的答案。想了半天没想到把上下拆开来做也是神了 😅&lt;/p&gt;
&lt;p&gt;可能比较考验对字典树的理解？做个比喻，字典树的 id 就相当于对这个点上信息的『引用』。&lt;/p&gt;
&lt;details&gt;
&lt;p&gt;字典树合并的时候可以考虑回收废弃点，不然可能有点卡。&lt;/p&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int X = 50;
const int maxn = 2e7 + 5;
long long d[maxn];
int tot, T[maxn][2], f[maxn], fa[maxn];
#define lc(p) T[p][0]
#define rc(p) T[p][1]
int find(int x) &amp;#123; return x == f[x] ? x : f[x] = find(f[x]); &amp;#125;
int newnode(void) &amp;#123;
    int p = ++tot;
    assert(p &amp;lt; maxn);
    d[p] = lc(p) = rc(p) = 0, f[p] = p;
    return p;
&amp;#125;
void pushdown(int p) &amp;#123;
    if (d[p]) &amp;#123;
        if (d[p] &amp;amp; 1)
            std::swap(lc(p), rc(p));
        d[p] &amp;gt;&amp;gt;= 1;
        if (lc(p))
            d[lc(p)] ^= d[p];
        if (rc(p))
            d[rc(p)] ^= d[p];
        d[p] = 0;
    &amp;#125;
    return;
&amp;#125;
int ins(int p, long long x) &amp;#123;
    for (int i = 0; i &amp;lt; X; ++i) &amp;#123;
        pushdown(p);
        if (!T[p][(x &amp;gt;&amp;gt; i) &amp;amp; 1]) &amp;#123;
            T[p][(x &amp;gt;&amp;gt; i) &amp;amp; 1] = newnode();
            fa[T[p][(x &amp;gt;&amp;gt; i) &amp;amp; 1]] = p;
        &amp;#125;
        p = T[p][(x &amp;gt;&amp;gt; i) &amp;amp; 1];
    &amp;#125;
    return p;
&amp;#125;
void merge(int &amp;amp;p, int q) &amp;#123;
    if (!q)
        return;
    if (!p) &amp;#123;
        p = q;
        return;
    &amp;#125;
    pushdown(p), pushdown(q);
    fa[lc(q)] = p, fa[rc(q)] = p;
    merge(lc(p), lc(q)), merge(rc(p), rc(q));
    assert(f[p] == p), assert(f[q] == q), f[q] = p;
    return;
&amp;#125;
long long ask(int p) &amp;#123;
    std::vector&amp;lt;int&amp;gt; st;
    for (int i = 0, j = p; i &amp;lt; X; ++i)
        st.push_back(fa[j]), j = fa[j];
    for (int i = 0; i &amp;lt; X; ++i)
        pushdown(st.back()), st.pop_back();
    long long x = 0;
    for (int i = 0; i &amp;lt; X; ++i) &amp;#123;
        x = x * 2 + (p == rc(fa[p]));
        p = fa[p];
    &amp;#125;
    return x;
&amp;#125;
void add(int p) &amp;#123;
    for (int i = 0; p &amp;amp;&amp;amp; i &amp;lt; X; ++i) &amp;#123;
        pushdown(p);
        std::swap(lc(p), rc(p));
        p = lc(p);
    &amp;#125;
    return;
&amp;#125;
void del(int p) &amp;#123;
    for (int i = 0; p &amp;amp;&amp;amp; i &amp;lt; X; ++i) &amp;#123;
        pushdown(p);
        std::swap(lc(p), rc(p));
        p = rc(p);
    &amp;#125;
    return;
&amp;#125;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#endif
    int n, m;
    std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
    std::vector&amp;lt;int&amp;gt; a(n + 1);
    for (int i = 1; i &amp;lt;= n; ++i)
        std::cin &amp;gt;&amp;gt; a[i];
    std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; g(n + 1);
    for (int i = 1, x, y; i &amp;lt; n; ++i) &amp;#123;
        std::cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; y;
        g[x].push_back(y), g[y].push_back(x);
    &amp;#125;
    std::vector&amp;lt;int&amp;gt; siz(n + 1), son(n + 1), top(n + 1), fa(n + 1), dep(n + 1);
    std::function&amp;lt;void(int)&amp;gt; DFS = [&amp;amp;](int x) &amp;#123;
        siz[x] = 1;
        for (auto i : g[x])
            if (i != fa[x]) &amp;#123;
                dep[i] = dep[x] + 1;
                fa[i] = x, DFS(i);
                siz[x] += siz[i];
                if (siz[i] &amp;gt; siz[son[x]])
                    son[x] = i;
            &amp;#125;
        return;
    &amp;#125;;
    DFS(1);
    DFS = [&amp;amp;](int x) &amp;#123;
        if (son[x])
            top[son[x]] = top[x], DFS(son[x]);
        for (auto i : g[x])
            if (i != son[x] &amp;amp;&amp;amp; i != fa[x])
                top[i] = i, DFS(i);
        return;
    &amp;#125;;
    top[1] = 1, DFS(1);
    auto askLCA = [&amp;amp;](int x, int y) &amp;#123;
        for (; top[x] != top[y]; x = fa[top[x]])
            if (dep[top[x]] &amp;lt; dep[top[y]])
                std::swap(x, y);
        return dep[x] &amp;lt; dep[y] ? x : y;
    &amp;#125;;
    struct node &amp;#123; long long x; int u, v; &amp;#125;;
    std::vector&amp;lt;node&amp;gt; q(m + 1);
    std::vector&amp;lt;int&amp;gt; id(m + 1);
    std::vector&amp;lt;long long&amp;gt; res(m + 1), ans(m + 1);
    std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; up(n + 1), dn(n + 1), ed(n + 1);
    for (int i = 1, x, u, v; i &amp;lt;= m; ++i) &amp;#123;
        std::cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; u &amp;gt;&amp;gt; v;
        q[i] = &amp;#123; x, u, v &amp;#125;;
        up[u].push_back(i), dn[askLCA(u, v)].push_back(i), ed[v].push_back(i);
    &amp;#125;
    std::vector&amp;lt;int&amp;gt; rt(n + 1);
    DFS = [&amp;amp;](int x) &amp;#123;
        rt[x] = newnode();
        for (auto i : g[x])
            if (i != fa[x]) &amp;#123;
                DFS(i);
                merge(rt[x], rt[i]);
            &amp;#125;
        add(rt[x]);
        for (auto i : up[x])
            id[i] = ins(rt[x], q[i].x);
        d[rt[x]] ^= a[x];
        for (auto i : dn[x])
            res[i] = ask(find(id[i]));
        return;
    &amp;#125;;
    DFS(1);
    tot = 0, rt[0] = newnode();
    std::fill(id.begin() + 1, id.end(), 0);
    DFS = [&amp;amp;](int x) &amp;#123;
        d[rt[0]] ^= a[x];
        for (auto i : dn[x])
            id[i] = ins(rt[0], res[i]);
        for (auto i : ed[x])
            ans[i] = ask(id[i]);
        add(rt[0]);
        for (auto i : g[x])
            if (i != fa[x])
                DFS(i);
        del(rt[0]);
        d[rt[0]] ^= a[x];
        return;
    &amp;#125;;
    DFS(1);
    for (int i = 1; i &amp;lt;= m; ++i)
        std::cout &amp;lt;&amp;lt; ans[i] &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;b---ビーバーの会合-2-meetings-2&#34;&gt;B - ビーバーの会合 2 (Meetings 2)&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/AT_joisc2021_j&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/AT_joisc2021_j&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;定义所求点为『局部重心』；类似树的重心，容易发现当关键点数量为奇时，只存在一个局部重心；否则，局部重心组成一条链。&lt;/p&gt;
&lt;p&gt;即对于每一个 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt;，需要找到一条最长链，使得其两端存在大小为 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 的子树（容易发现取后缀 max 即可得到真实答案）。使用点分治，精细实现容易做到 &lt;span class=&#34;math inline&#34;&gt;\(O(n\log n)\)&lt;/span&gt;。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#endif
    int n;
    std::cin &amp;gt;&amp;gt; n;
    std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; g(n + 1);
    for (int i = 1, x, y; i &amp;lt; n; ++i) &amp;#123;
        std::cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; y;
        g[x].push_back(y), g[y].push_back(x);
    &amp;#125;
    std::vector&amp;lt;int&amp;gt; mx(n + 1), siz(n + 1), p, tag(n + 1), res(n + 1, 1);
    std::function&amp;lt;void(int, int)&amp;gt; DFS1 = [&amp;amp;](int x, int fa) &amp;#123;
        p.push_back(x);
        siz[x] = 1, mx[x] = 0;
        for (auto i : g[x])
            if (!tag[i] &amp;amp;&amp;amp; i != fa) &amp;#123;
                DFS1(i, x);
                siz[x] += siz[i];
                mx[x] = std::max(mx[x], siz[i]);
            &amp;#125;
        return;
    &amp;#125;;
    auto findrt = [&amp;amp;](int x) &amp;#123;
        p.clear(), DFS1(x, -1);
        int n = (int)p.size();
        for (auto i : p)
            if (mx[i] &amp;lt;= n / 2 &amp;amp;&amp;amp; n - siz[i] &amp;lt;= n / 2)
                return i;
        assert(0);
        return -1;
    &amp;#125;;
    struct node &amp;#123;
        int u1, u2, id1, id2;
        node(): u1(0), u2(0), id1(0), id2(0) &amp;#123;&amp;#125;
        void upd(int u, int id) &amp;#123;
            if (id1 == id)
                u1 = std::max(u1, u);
            else if (u &amp;gt;= u1)
                u2 = u1, id2 = id1, u1 = u, id1 = id;
            else if (u &amp;gt;= u2)
                u2 = u, id2 = id;
            return;
        &amp;#125;
    &amp;#125;;
    std::vector&amp;lt;node&amp;gt; s(n + 1);
    std::function&amp;lt;void(int, int, int, int)&amp;gt; DFS2 = [&amp;amp;](int x, int fa, int dep, int anc) &amp;#123;
        s[siz[x]].upd(dep, anc);
        for (auto i : g[x])
            if (!tag[i] &amp;amp;&amp;amp; i != fa)
                DFS2(i, x, dep + 1, anc);
        return;
    &amp;#125;;
    std::function&amp;lt;void(int, int, int, int)&amp;gt; DFS3 = [&amp;amp;](int x, int fa, int dep, int anc) &amp;#123;
        int v = ((s[siz[x]].id1 == anc) ? s[siz[x]].u2 : s[siz[x]].u1);
        res[2 * siz[x]] = std::max(res[2 * siz[x]], dep + 1 + v);
        for (auto i : g[x])
            if (!tag[i] &amp;amp;&amp;amp; i != fa)
                DFS3(i, x, dep + 1, anc);
        return;
    &amp;#125;;
    std::function&amp;lt;void(int)&amp;gt; DFS = [&amp;amp;](int x) &amp;#123;
        x = findrt(x), p.clear(), DFS1(x, -1);
        // printf(&amp;quot;rt = %d\n&amp;quot;, x);
        for (auto i : g[x])
            if (!tag[i])
                DFS2(i, x, 1, i);
        for (int i = siz[x] - 1; i; --i) &amp;#123;
            s[i].upd(s[i + 1].u1, s[i + 1].id1);
            s[i].upd(s[i + 1].u2, s[i + 1].id2);
        &amp;#125;
        for (auto i : g[x])
            if (!tag[i])
                DFS3(i, x, 1, i);
        tag[x] = 1;
        for (int i = 1; i &amp;lt; siz[x]; ++i)
            s[i] = node();
        for (auto i : g[x])
            if (!tag[i])
                DFS(i);
        return;
    &amp;#125;;
    DFS(1);
    for (int i = (n &amp;gt;&amp;gt; 1) * 2; i; --i)
        if (i + 2 &amp;lt;= n)
            res[i] = std::max(res[i], res[i + 2]);
    for (int i = 1; i &amp;lt;= n; ++i)
        std::cout &amp;lt;&amp;lt; res[i] &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;c---the-closest-pair&#34;&gt;C - The Closest Pair&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://ac.nowcoder.com/acm/problem/262593&#34; class=&#34;uri&#34;&gt;https://ac.nowcoder.com/acm/problem/262593&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;常规方法&lt;/strong&gt;：考虑&lt;strong&gt;支配对&lt;/strong&gt;，对于每个 &lt;span class=&#34;math inline&#34;&gt;\(a_i\)&lt;/span&gt;，找到所有合法的 &lt;span class=&#34;math inline&#34;&gt;\(a_j\)&lt;/span&gt;。容易想到枚举 &lt;span class=&#34;math inline&#34;&gt;\(a_i\div a_j\)&lt;/span&gt; 来做；假设存在 &lt;span class=&#34;math inline&#34;&gt;\(a_k\div a_i=a_j\div a_i\)&lt;/span&gt; 且 &lt;span class=&#34;math inline&#34;&gt;\(k&amp;gt;j\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;不妨设 &lt;span class=&#34;math inline&#34;&gt;\(a_j=K\cdot a_i+p,a_k=K\cdot a_i+q\)&lt;/span&gt;，&lt;span class=&#34;math inline&#34;&gt;\((a_i,a_j),(a_i,a_k)\)&lt;/span&gt; 均合法当且仅当下列条件全部成立：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class=&#34;math inline&#34;&gt;\(a_j\bmod a_i&amp;gt;a_k\bmod a_i\)&lt;/span&gt;； 则 &lt;span class=&#34;math inline&#34;&gt;\(a_j&amp;gt;a_k\)&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;math inline&#34;&gt;\(a_j\bmod a_k&amp;gt;a_k\bmod a_i\)&lt;/span&gt;；又 &lt;span class=&#34;math inline&#34;&gt;\(p-q\ge a_j\bmod a_k\)&lt;/span&gt;（&lt;strong&gt;太牛了这一步&lt;/strong&gt;），即 &lt;span class=&#34;math inline&#34;&gt;\(p-q&amp;gt;q\iff p&amp;gt;2q\)&lt;/span&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;证得只关心同一个 &lt;span class=&#34;math inline&#34;&gt;\(a_j\div a_i\)&lt;/span&gt; 时的支配对数量为 &lt;span class=&#34;math inline&#34;&gt;\(\log n\)&lt;/span&gt; 级别；总对数 &lt;span class=&#34;math inline&#34;&gt;\(O(n\log n\ln n)\)&lt;/span&gt;。离线下来扫描线就行了。&lt;/p&gt;
&lt;details&gt;
&lt;p&gt;对着 单点修改 区间最值 想了 1h 的单 log 做法 😰 果然小脑掉线太可怕了，第二天早上重置大脑 1s 发现自己是斯波 😓&lt;/p&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int LEN = (1 &amp;lt;&amp;lt; 20);
int nec(void) &amp;#123;
    static char buf[LEN], *p = buf, *e = buf;
    if (p == e) &amp;#123;
        e = buf + fread(buf, 1, LEN, stdin);
        if (e == buf) return EOF;
        p = buf;
    &amp;#125;
    return *p++;
&amp;#125;
bool read(int &amp;amp;x) &amp;#123;
    x = 0;
    bool f = 0;
    char ch = nec();
    while (ch &amp;lt; &amp;#39;0&amp;#39; || ch &amp;gt; &amp;#39;9&amp;#39;) &amp;#123;
        if (ch == EOF) return 0;
        if (ch == &amp;#39;-&amp;#39;) f = 1;
        ch = nec();
    &amp;#125;
    while (ch &amp;gt;= &amp;#39;0&amp;#39; &amp;amp;&amp;amp; ch &amp;lt;= &amp;#39;9&amp;#39;) &amp;#123;
        x = x * 10 + ch - &amp;#39;0&amp;#39;;
        ch = nec();
    &amp;#125;
    if (f) x = -x;
    return 1;
&amp;#125;
void print(int x) &amp;#123;
    if (x &amp;lt; 0)
        putchar(&amp;#39;-&amp;#39;), x = -x;
    if (x &amp;gt;= 10) print(x / 10);
    putchar(x % 10 + &amp;#39;0&amp;#39;);
    return;
&amp;#125;
void print(int x, char ch) &amp;#123;
    print(x), putchar(ch);
    return;
&amp;#125;
const int maxn = 4e6 + 5;
struct &amp;#123; int l, r, u[2]; &amp;#125; t[maxn];
#define lt (t[p].l)
#define rt (t[p].r)
int tot[2];
void add(int &amp;amp;p, int l, int r, int x, int v, int i) &amp;#123;
    if (!p)
        p = ++tot[i], t[p].u[0] = -1, t[p].u[1] = 0x3f3f3f3f;
    if (i == 0)
        t[p].u[0] = std::max(t[p].u[0], v);
    else
        t[p].u[1] = std::min(t[p].u[1], v);
    if (l == r)
        return;
    int mid = (l + r) &amp;gt;&amp;gt; 1;
    if (x &amp;lt;= mid)
        add(lt, l, mid, x, v, i);
    else
        add(rt, mid + 1, r, x, v, i);
    return;
&amp;#125;
int ask(int p, int l, int r, int ql, int qr, int i) &amp;#123;
    if (!p || (ql &amp;lt;= l &amp;amp;&amp;amp; r &amp;lt;= qr))
        return t[p].u[i];
    int mid = (l + r) &amp;gt;&amp;gt; 1;
    if (qr &amp;lt;= mid)
        return ask(lt, l, mid, ql, qr, i);
    if (ql &amp;gt; mid)
        return ask(rt, mid + 1, r, ql, qr, i);
    if (i == 0)
        return std::max(ask(lt, l, mid, ql, qr, 0), ask(rt, mid + 1, r, ql, qr, 0));
    return std::min(ask(lt, l, mid, ql, qr, 1), ask(rt, mid + 1, r, ql, qr, 1));
&amp;#125;
#undef lt
#undef rt
int main() &amp;#123;
#ifndef ONLINE_JUDGE
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    const int m = 1e6;
    int rt[2] = &amp;#123; 0 &amp;#125;, n;
    t[0].u[0] = -1, t[0].u[1] = 0x3f3f3f3f;
    read(n);
    std::vector&amp;lt;int&amp;gt; a(n + 1);
    for (int i = 1; i &amp;lt;= n; ++i)
        read(a[i]);
    std::vector&amp;lt;std::vector&amp;lt;std::pair&amp;lt;int, int&amp;gt; &amp;gt; &amp;gt; t(n + 1);
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        if (i != 1) &amp;#123;
            for (int K = a[i]; K &amp;lt;= m; K += a[i]) &amp;#123;
                for (int mx = std::min(a[i] - 1, m - K); ; ) &amp;#123;
                    int k = ask(rt[0], 1, m, K, K + mx, 0);
                    if (k == -1)
                        break;
                    t[i].emplace_back(k, a[k] - K);
                    if (k == 1 || !(a[k] - K))
                        break;
                    mx = (a[k] - K - 1) / 2;
                &amp;#125;
            &amp;#125;
        &amp;#125;
        add(rt[0], 1, m, a[i], i, 0);
    &amp;#125;
    for (int i = n; i; --i) &amp;#123;
        if (i != n)
            for (int K = a[i]; K &amp;lt;= m; K += a[i])
                for (int mx = std::min(a[i] - 1, m - K); ; ) &amp;#123;
                    int k = ask(rt[1], 1, m, K, K + mx, 1);
                    if (k == 0x3f3f3f3f)
                        break;
                    t[k].emplace_back(i, a[k] - K);
                    if (k == n || !(a[k] - K))
                        break;
                    mx = (a[k] - K - 1) / 2;
                &amp;#125;
        add(rt[1], 1, m, a[i], i, 1);
    &amp;#125;
    int q;
    read(q);
    std::vector&amp;lt;int&amp;gt; res(q + 1);
    std::vector&amp;lt;std::vector&amp;lt;std::pair&amp;lt;int, int&amp;gt; &amp;gt; &amp;gt; u(n + 1);
    for (int i = 1, l, r; i &amp;lt;= q; ++i) &amp;#123;
        read(l), read(r);
        if (l &amp;gt; r)
            std::swap(l, r);
        u[r].emplace_back(l, i);
    &amp;#125;
    std::vector&amp;lt;int&amp;gt; bit(n + 1, 0x3f3f3f3f);
    auto lowbit = [&amp;amp;](int x) &amp;#123; return x &amp;amp; -x; &amp;#125;;
    auto add = [&amp;amp;](int x, int v) &amp;#123;
        for (; x &amp;lt;= n; x += lowbit(x))
            bit[x] = std::min(bit[x], v);
        return;
    &amp;#125;;
    auto ask = [&amp;amp;](int x) &amp;#123;
        auto res = 0x3f3f3f3f;
        for (; x; x -= lowbit(x))
            res = std::min(res, bit[x]);
        return res;
    &amp;#125;;
    for (int r = 1; r &amp;lt;= n; ++r) &amp;#123;
        for (auto [l, v] : t[r])
            add(n - l + 1, v);
        for (auto [l, i] : u[r])
            res[i] = ask(n - l + 1);
    &amp;#125;
    for (int i = 1; i &amp;lt;= q; ++i)
        print(res[i], &amp;#39;\n&amp;#39;);
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;p&gt;求支配对的过程也要带 log（线段树），再加上扫描线的 3log，总共是常数比较大的 3log（卡了一个上午的常也是有了）。所以接下来讲解另一种奇技淫巧。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;暴力分治&lt;/strong&gt;：注意到对于比较长（&lt;span class=&#34;math inline&#34;&gt;\(len&amp;gt; B\)&lt;/span&gt;）的区间，答案比较小；故考虑分治。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于长询问（&lt;span class=&#34;math inline&#34;&gt;\(len&amp;gt;B\)&lt;/span&gt;），从小到大枚举答案并 check；预处理某个范围（&lt;span class=&#34;math inline&#34;&gt;\(V\)&lt;/span&gt;）内的 &lt;span class=&#34;math inline&#34;&gt;\(res\)&lt;/span&gt; 出现的所有位置，平衡的时候还要算上调和级数和 bit。&lt;/li&gt;
&lt;li&gt;对于短询问（&lt;span class=&#34;math inline&#34;&gt;\(len\le B\)&lt;/span&gt;），发现每次区间内暴力是 &lt;span class=&#34;math inline&#34;&gt;\(O(B^2q)\)&lt;/span&gt; 的；把询问离线下来，精细实现，利用询问的公共部分使得&lt;strong&gt;每一对数只被枚举一次&lt;/strong&gt;就能达到 &lt;span class=&#34;math inline&#34;&gt;\(O(B^2 + Bq)\)&lt;/span&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最优解取 &lt;span class=&#34;math inline&#34;&gt;\(B=333,V=483\)&lt;/span&gt;，不自己实现一遍了。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;d---仙人掌&#34;&gt;D - 仙人掌&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P3687&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P3687&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;把边双从图中删除、问题转化为树上&lt;strong&gt;边&lt;/strong&gt;不交的链覆盖，使得&lt;strong&gt;所有链长 &lt;span class=&#34;math inline&#34;&gt;\(\ge 2\)&lt;/span&gt;&lt;/strong&gt; 的方案数。发现由于&lt;strong&gt;边可以不被覆盖&lt;/strong&gt;，常规 DP 会使得在父节点处合并时需要额外的数量维，参考树上背包，复杂度 &lt;span class=&#34;math inline&#34;&gt;\(O(n^2)\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;思考时会注意到两个限制可以抵消——如果认为长为 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt; 的链就是不被覆盖的边，覆盖所有树边，显然可以建立和合法解的双射。此时合并是非常方便的，注意到每个儿子的系数一定都参与『分步』，只需要求出『分类』的系数。这个可以预处理（和 &lt;a href=&#34;/20250407/#a.-二分图染色&#34;&gt;二分图染色&lt;/a&gt; 这个题有点像），令 &lt;span class=&#34;math inline&#34;&gt;\(f_i\)&lt;/span&gt; 表示一个点度数为 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 时的答案，参考错排的思路，则 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 可以不参与配对，也可以乱选一个点配对，如果选中了已配对的点就令其和 &lt;span class=&#34;math inline&#34;&gt;\(i-1\)&lt;/span&gt; 交换，可以建立和合法解的双射。则 &lt;span class=&#34;math inline&#34;&gt;\(f_i=f_{i-1}+(n-1)f_{i-2}\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;首先需要 check 原图是否为仙人掌，顺带回忆一下连通性的知识——在 DFS 树上差分，检查是否有边被覆盖两次即可。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int mod = 998244353;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int T;
    for (std::cin &amp;gt;&amp;gt; T; T--; ) &amp;#123;
        int n, m;
        std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
        std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; g1(n + 1);
        for (int x, y; m--; ) &amp;#123;
            std::cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; y;
            g1[x].push_back(y), g1[y].push_back(x);
        &amp;#125;
        bool flag = 1;
        int now = 0, cnt = 0;
        std::vector&amp;lt;int&amp;gt; st, dfn(n + 1), low(n + 1), col(n + 1), diff(n + 1);
        std::function&amp;lt;void(int, int)&amp;gt; DFS = [&amp;amp;](int x, int fa) &amp;#123;
            st.push_back(x);
            dfn[x] = low[x] = ++now;
            for (auto i : g1[x])
                if (!dfn[i]) &amp;#123;
                    // printf(&amp;quot;x = %d, %d -&amp;gt; %d\n&amp;quot;, x, x, i);
                    DFS(i, x);
                    diff[x] += diff[i];
                    // printf(&amp;quot;x = %d, diff[%d] += diff[%d]\n&amp;quot;, x, x, i);
                    low[x] = std::min(low[x], low[i]);
                &amp;#125;
                else if (i != fa &amp;amp;&amp;amp; dfn[i] &amp;lt; dfn[x]) &amp;#123;
                    low[x] = std::min(low[x], dfn[i]);
                    ++diff[x], --diff[i];
                    // printf(&amp;quot;x = %d, ++diff[%d], --diff[%d]\n&amp;quot;, x, x, i);
                &amp;#125;
            if (diff[x] &amp;gt;= 2)
                flag = 0;
            // printf(&amp;quot;x = %d, diff[%d] = %d\n&amp;quot;, x, x, diff[x]);
            if (low[x] == dfn[x]) &amp;#123;
                ++cnt;
                for (int p = -1; p != x; ) &amp;#123;
                    p = st.back(), st.pop_back();
                    col[p] = cnt;
                &amp;#125;
            &amp;#125;
            return;
        &amp;#125;;
        DFS(1, -1);
        if (!flag) &amp;#123;
            std::cout &amp;lt;&amp;lt; 0 &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
            continue;
        &amp;#125;
        std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; g(n + 1);
        for (int i = 1; i &amp;lt;= n; ++i)
            for (auto j : g1[i])
                if (col[i] != col[j])
                    g[i].push_back(j);
        std::vector&amp;lt;long long&amp;gt; f(n + 1), dp(n + 1);
        dp[0] = 1ll, dp[1] = 1ll;
        for (int i = 2; i &amp;lt;= n; ++i)
            dp[i] = (dp[i - 1] + (i - 1) * dp[i - 2]) % mod;
        std::vector&amp;lt;int&amp;gt; tag(n + 1);
        DFS = [&amp;amp;](int x, int fa) &amp;#123;
            f[x] = 1ll, tag[x] = 1;
            for (auto i : g[x])
                if (i != fa) &amp;#123;
                    DFS(i, x);
                    (f[x] *= f[i]) %= mod;
                &amp;#125;
            (f[x] *= dp[(int)g[x].size()]) %= mod;
            return;
        &amp;#125;;
        auto res(1ll);
        for (int i = 1; i &amp;lt;= n; ++i)
            if (!tag[i])
                DFS(i, -1), (res *= f[i]) %= mod;
        std::cout &amp;lt;&amp;lt; res &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    &amp;#125;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;p&gt;E. Many Minimizations 是数学题，跳了。&lt;/p&gt;
&lt;hr /&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;无名题&#34;&gt;无名题&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;背景：给定 &lt;span class=&#34;math inline&#34;&gt;\(n,k\)&lt;/span&gt;，对于 &lt;span class=&#34;math inline&#34;&gt;\(\forall\, 1\le i\le n\)&lt;/span&gt;，令 &lt;span class=&#34;math inline&#34;&gt;\(a_i=i\bmod k\)&lt;/span&gt;，问一共有多少个本质不同的子序列？对于 &lt;span class=&#34;math inline&#34;&gt;\(k=1,2,\cdots,n\)&lt;/span&gt; 分别求出答案。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;maimai&#34;&gt;maimai&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://ac.nowcoder.com/acm/contest/66112/F&#34; class=&#34;uri&#34;&gt;https://ac.nowcoder.com/acm/contest/66112/F&lt;/a&gt;&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://xsc062.netlify.app/20250807/</guid>
            <title>学习笔记：分拆数与 Ferrers 图</title>
            <link>https://xsc062.netlify.app/20250807/</link>
            <category>DP</category>
            <pubDate>Thu, 07 Aug 2025 16:20:45 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;需要知道概念和求法，有一定的用处&lt;/p&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;分拆数与互异分拆数&#34;&gt;分拆数与互异分拆数&lt;/h2&gt;
&lt;p&gt;要求：给定一个正整数 &lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt;，要求将其划分为 &lt;span class=&#34;math inline&#34;&gt;\(m\)&lt;/span&gt; 个可重 / 不可重的正整数，问本质不同的方案数。（显然 &lt;span class=&#34;math inline&#34;&gt;\(m\)&lt;/span&gt; 与 &lt;span class=&#34;math inline&#34;&gt;\(\sqrt n\)&lt;/span&gt; 同阶。）&lt;/p&gt;
&lt;p&gt;不妨令划分结果单调不降，则有两种 DP 路径：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;法一：令 &lt;span class=&#34;math inline&#34;&gt;\(f_{i,j}\)&lt;/span&gt; 表示把 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 分成 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; 个正整数的方案数。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不可重：考虑将这 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; 个数减去 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt;。最多一个元素由 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt; 变为 &lt;span class=&#34;math inline&#34;&gt;\(0\)&lt;/span&gt;，组数减少 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt;；其他时候还是 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; 组。故云 &lt;span class=&#34;math inline&#34;&gt;\(f_{i,j}=f_{i-j,j-1}+f_{i-j,j}\)&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;可重：如果存在 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt;，可以删除之然后转移；否则仍整体减 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt; 转移。故曰 &lt;span class=&#34;math inline&#34;&gt;\(f_{i,j}=f_{i-1,j-1}+f_{i-j,j}\)&lt;/span&gt;。&lt;/li&gt;
&lt;/ul&gt;
该转移方法唯一性很显然。&lt;strong&gt;注意到第二维只和 &lt;span class=&#34;math inline&#34;&gt;\(j,j-1\)&lt;/span&gt; 有关；可以交换前后两维顺序然后滚动。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;法二：令 &lt;span class=&#34;math inline&#34;&gt;\(n=\sum a_i\)&lt;/span&gt;，建立 &lt;span class=&#34;math inline&#34;&gt;\(a\)&lt;/span&gt; 的差分数组 &lt;span class=&#34;math inline&#34;&gt;\(d\)&lt;/span&gt;，则有 &lt;span class=&#34;math inline&#34;&gt;\(n=\sum\limits_{i=1}^m \sum\limits_{j=1}^i c_j=\sum\limits_{i=1}^m (n-i+1)\times a_i\)&lt;/span&gt;。发现 &lt;span class=&#34;math inline&#34;&gt;\(a_i\)&lt;/span&gt; 每增大 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt;，答案会增大 &lt;span class=&#34;math inline&#34;&gt;\(n-i+1\)&lt;/span&gt;。故转化为『第 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 个物品重量为 &lt;span class=&#34;math inline&#34;&gt;\(n-i+1\)&lt;/span&gt;』的完全背包。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不可重：要求每个物品至少选一次。&lt;/li&gt;
&lt;li&gt;可重：无限制。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;该方法唯一性更显然。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;复杂度均为 &lt;span class=&#34;math inline&#34;&gt;\(O(nm)\)&lt;/span&gt;，即 &lt;span class=&#34;math inline&#34;&gt;\(O(V\sqrt V)\)&lt;/span&gt;。&lt;/p&gt;
&lt;h3 id=&#34;例sets-of-complementary-sums&#34;&gt;例：Sets of Complementary Sums&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;/20250723/#e.-sets-of-complementary-sums&#34;&gt;link&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;ferrers-图&#34;&gt;Ferrers 图&lt;/h2&gt;
&lt;p&gt;将 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 个分拆出来的数用横向柱状图表示并单调不增排列，得到 Ferrers 图。&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&#34;image-1.png&#34; alt=&#34;例：12=5+4+2+1 的 Ferrers 图（图源 OI Wiki）&#34; /&gt;&lt;figcaption&gt;例：&lt;span class=&#34;math inline&#34;&gt;\(12=5+4+2+1\)&lt;/span&gt; 的 Ferrers 图（图源 OI Wiki）&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;将图像斜向翻折得到一组共轭解，原图中的 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 即为共轭解中的元素最值。故亦可限定分拆结果的最值为 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt;，则结果仍为 &lt;span class=&#34;math inline&#34;&gt;\(f_{n,k}\)&lt;/span&gt;。同时适用于分拆数与互异分拆数。&lt;/p&gt;
&lt;p&gt;顺带提一嘴杨表：把点替换成 &lt;span class=&#34;math inline&#34;&gt;\(1\sim n\)&lt;/span&gt;，并使得一个点同时大于左侧和上方的值。&lt;/p&gt;
&lt;p&gt;似乎就不是很有用了。计数题可能会考。&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://xsc062.netlify.app/20250805/</guid>
            <title>状压 DP</title>
            <link>https://xsc062.netlify.app/20250805/</link>
            <category>DP</category>
            <category>状压 DP</category>
            <pubDate>Tue, 05 Aug 2025 14:33:55 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;没补完（1/3），动作还是太慢了&lt;/p&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;a---只不过是长的领带-2-just-long-neckties-2&#34;&gt;A - 只不过是长的领带 2 / Just Long Neckties 2&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P11665&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P11665&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;需要观察到，任意时刻 &lt;span class=&#34;math inline&#34;&gt;\(B\)&lt;/span&gt; 中不存在重复元素。把 &lt;span class=&#34;math inline&#34;&gt;\(B\)&lt;/span&gt; 压出来，令 &lt;span class=&#34;math inline&#34;&gt;\(f_{i,S}\)&lt;/span&gt; 表示选了 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt;，当前 &lt;span class=&#34;math inline&#34;&gt;\(B\)&lt;/span&gt; 为 &lt;span class=&#34;math inline&#34;&gt;\(S\)&lt;/span&gt; 是否可行，能够 &lt;span class=&#34;math inline&#34;&gt;\(O(n\cdot 2^V)\)&lt;/span&gt;。对于某个 &lt;span class=&#34;math inline&#34;&gt;\(S\)&lt;/span&gt;，只关心它最远能到达哪个 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt;，故令 &lt;span class=&#34;math inline&#34;&gt;\(f_S\)&lt;/span&gt; 记录之。对于每一个 &lt;span class=&#34;math inline&#34;&gt;\(S\)&lt;/span&gt;，都可以找到 &lt;span class=&#34;math inline&#34;&gt;\(f_S\)&lt;/span&gt; 后第一对 &lt;span class=&#34;math inline&#34;&gt;\(a_i,a_{i+1}\notin S\)&lt;/span&gt;，用其刷表。&lt;/p&gt;
&lt;p&gt;发现『找 &lt;span class=&#34;math inline&#34;&gt;\(f_S\)&lt;/span&gt; 后第一对非法元素』是很慢的，考虑优化；对于每个 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 维护 &lt;span class=&#34;math inline&#34;&gt;\(p\)&lt;/span&gt; 在其后第一次出现的位置 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt;，对于每个 &lt;span class=&#34;math inline&#34;&gt;\(a_x=p\)&lt;/span&gt; 维护 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 后方 &lt;span class=&#34;math inline&#34;&gt;\(a_y=p,a_{y+1}=q\)&lt;/span&gt; 第一次出现的位置，相当于&lt;strong&gt;先找 &lt;span class=&#34;math inline&#34;&gt;\(p\)&lt;/span&gt; 再找 &lt;span class=&#34;math inline&#34;&gt;\((p,q)\)&lt;/span&gt;&lt;/strong&gt;，就可以做到 &lt;span class=&#34;math inline&#34;&gt;\(O(V^2\cdot 2^V+n\cdot V)\)&lt;/span&gt;。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#endif
    int n;
    std::cin &amp;gt;&amp;gt; n;
    std::vector&amp;lt;int&amp;gt; a(n + 1);
    int V = 0;
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        std::cin &amp;gt;&amp;gt; a[i];
        V = std::max(V, a[i]--);
    &amp;#125;
    std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; tx(n + 1, std::vector&amp;lt;int&amp;gt; (V)), ty(n + 1, std::vector&amp;lt;int&amp;gt; (V));
    std::vector&amp;lt;int&amp;gt; lp(V);
    std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; lpq(V, std::vector&amp;lt;int&amp;gt; (V));
    for (int i = n; ~i; --i) &amp;#123;
        if (i &amp;amp;&amp;amp; i != n)
            lpq[a[i]][a[i + 1]] = i;
        for (int j = 0; j &amp;lt; V; ++j) &amp;#123;
            tx[i][j] = lp[j];
            if (i != n)
                ty[i][j] = lpq[a[i]][j];
        &amp;#125;
        if (i != 0)
            lp[a[i]] = i;
    &amp;#125;
    int siz = 1 &amp;lt;&amp;lt; V, res = 21;
    std::vector&amp;lt;int&amp;gt; f(siz);
    for (int i = 0; i &amp;lt; siz; ++i) &amp;#123;
        std::vector&amp;lt;int&amp;gt; p0, p1;
        for (int j = 0; j &amp;lt; V; ++j)
            if ((i &amp;gt;&amp;gt; j) &amp;amp; 1)
                p1.push_back(j);
            else
                p0.push_back(j);
        int j = n;
        for (auto p : p0)
            if (tx[f[i]][p])
                for (auto q : p0)
                    if (ty[tx[f[i]][p]][q])
                        j = std::min(j, ty[tx[f[i]][p]][q]);
        if (j != n) &amp;#123;
            f[i ^ (1 &amp;lt;&amp;lt; a[j])] = std::max(f[i ^ (1 &amp;lt;&amp;lt; a[j])], j);
            f[i ^ (1 &amp;lt;&amp;lt; a[j + 1])] = std::max(f[i ^ (1 &amp;lt;&amp;lt; a[j + 1])], j + 1);
            for (auto k : p1) &amp;#123;
                f[i ^ (1 &amp;lt;&amp;lt; k) ^ (1 &amp;lt;&amp;lt; a[j])] = std::max(f[i ^ (1 &amp;lt;&amp;lt; k) ^ (1 &amp;lt;&amp;lt; a[j])], j);
                f[i ^ (1 &amp;lt;&amp;lt; k) ^ (1 &amp;lt;&amp;lt; a[j + 1])] = std::max(f[i ^ (1 &amp;lt;&amp;lt; k) ^ (1 &amp;lt;&amp;lt; a[j + 1])], j + 1);
            &amp;#125;
        &amp;#125;
        else
            res = std::min(res, __builtin_popcount(i));
    &amp;#125;
    std::cout &amp;lt;&amp;lt; res &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;b---cut-and-reorder&#34;&gt;B - Cut and Reorder&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/abc328/tasks/abc328_g&#34; class=&#34;uri&#34;&gt;https://atcoder.jp/contests/abc328/tasks/abc328_g&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;不妨先重排再修改，令 &lt;span class=&#34;math inline&#34;&gt;\(f_{i,S}\)&lt;/span&gt; 表示已经重排好新序列的前 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 个元素，对应原序列状态 &lt;span class=&#34;math inline&#34;&gt;\(S\)&lt;/span&gt; 的最小代价。枚举新区间容易转移。可以发现枚举 &lt;span class=&#34;math inline&#34;&gt;\(i,S\)&lt;/span&gt; 的实际复杂度为 &lt;span class=&#34;math inline&#34;&gt;\(O(2^n)\)&lt;/span&gt;（空间也可以这么优化），预处理之后总时间复杂度 &lt;span class=&#34;math inline&#34;&gt;\(O(n^2\cdot 2^n)\)&lt;/span&gt;，跑不满，可以通过。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const long long inf = 1e18;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#endif
    int n;
    long long c;
    std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; c;
    std::vector&amp;lt;long long&amp;gt; a(n), b(n);
    for (int i = 0; i &amp;lt; n; ++i)
        std::cin &amp;gt;&amp;gt; a[i];
    for (int i = 0; i &amp;lt; n; ++i)
        std::cin &amp;gt;&amp;gt; b[i];
    using arr = std::vector&amp;lt;long long&amp;gt;;
    using brr = std::vector&amp;lt;arr&amp;gt;;
    using crr = std::vector&amp;lt;brr&amp;gt;;
    brr p(n, arr(n));
    crr g(n, brr(n, arr(n)));
    for (int l = 0; l &amp;lt; n; ++l)
        for (int r = l; r &amp;lt; n; ++r) &amp;#123;
            for (int k = l; k &amp;lt;= r; ++k)
                p[l][r] ^= (1 &amp;lt;&amp;lt; k);
            for (int R = r - l; R &amp;lt; n; ++R)
                for (int L = R, j = r; j &amp;gt;= l; --L, --j)
                    g[l][r][R] += std::abs(b[L] - a[j]);
        &amp;#125;
    int siz = 1 &amp;lt;&amp;lt; n;
    std::vector&amp;lt;long long&amp;gt; f(siz, inf);
    f[0] = 0ll;
    for (int j = 1; j &amp;lt; siz; ++j) &amp;#123;
        int i = __builtin_popcount(j) - 1;
        for (int r = 0; r &amp;lt; n; ++r)
            for (int l = r; ~l &amp;amp;&amp;amp; ((j &amp;gt;&amp;gt; l) &amp;amp; 1); --l)
                f[j] = std::min(f[j], f[j ^ p[l][r]] + g[l][r][i] + c);
    &amp;#125;
    std::cout &amp;lt;&amp;lt; f[siz - 1] - c &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;c---electric-circuit&#34;&gt;C - Electric Circuit&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/abc321/tasks/abc321_g&#34; class=&#34;uri&#34;&gt;https://atcoder.jp/contests/abc321/tasks/abc321_g&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;很像&lt;a href=&#34;/20250430/#有标号无向图计数&#34;&gt;无向图容斥&lt;/a&gt;？令 &lt;span class=&#34;math inline&#34;&gt;\(f_S\)&lt;/span&gt; 表示让 &lt;span class=&#34;math inline&#34;&gt;\(S\)&lt;/span&gt; 内部完成配对，可以不连通的方案数，那么当且仅当 &lt;span class=&#34;math inline&#34;&gt;\(S\)&lt;/span&gt; 内部点出、入度之和相等（记为 &lt;span class=&#34;math inline&#34;&gt;\(cnt\)&lt;/span&gt;）时，&lt;span class=&#34;math inline&#34;&gt;\(f_S\)&lt;/span&gt; 有值 &lt;span class=&#34;math inline&#34;&gt;\(cnt!\)&lt;/span&gt;。相似地，设 &lt;span class=&#34;math inline&#34;&gt;\(g_S\)&lt;/span&gt; 表示让 &lt;span class=&#34;math inline&#34;&gt;\(S\)&lt;/span&gt; 完成配对，成为一个连通块的方案数，得到 &lt;span class=&#34;math inline&#34;&gt;\(g_S=f_S-\sum\limits_{v\in S} f_{S\oplus v}\cdot g_v\)&lt;/span&gt;。让 &lt;span class=&#34;math inline&#34;&gt;\(v\)&lt;/span&gt; 必须包含 &lt;span class=&#34;math inline&#34;&gt;\(S\)&lt;/span&gt; 中编号最小的点就可以去重。&lt;/p&gt;
&lt;p&gt;从贡献的角度出发，&lt;span class=&#34;math inline&#34;&gt;\(S\)&lt;/span&gt; 带来的贡献就是 &lt;span class=&#34;math inline&#34;&gt;\(g_S\cdot f_{U\oplus S}\)&lt;/span&gt;，其中 &lt;span class=&#34;math inline&#34;&gt;\(U\)&lt;/span&gt; 是全集。最后除以 &lt;span class=&#34;math inline&#34;&gt;\(M!\)&lt;/span&gt; 求出期望。&lt;/p&gt;
&lt;p&gt;复杂度 &lt;span class=&#34;math inline&#34;&gt;\(O(3^n)\)&lt;/span&gt;。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int mod = 998244353;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#endif
    int n, m;
    std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
    std::vector&amp;lt;int&amp;gt; ci(n), co(n);
    for (int i = 1, x; i &amp;lt;= m; ++i)
        std::cin &amp;gt;&amp;gt; x, ++ci[x - 1];
    for (int i = 1, x; i &amp;lt;= m; ++i)
        std::cin &amp;gt;&amp;gt; x, ++co[x - 1];
    std::vector&amp;lt;long long&amp;gt; fac(m + 1);
    fac[0] = 1ll;
    for (int i = 1; i &amp;lt;= m; ++i)
        fac[i] = fac[i - 1] * i % mod;
    auto qkp = [&amp;amp;](long long x, int y) &amp;#123;
        auto res(1ll);
        for (; y; (x *= x) %= mod, y &amp;gt;&amp;gt;= 1)
            if (y &amp;amp; 1)
                (res *= x) %= mod;
        return res;
    &amp;#125;;
    int siz = 1 &amp;lt;&amp;lt; n;
    std::vector&amp;lt;long long&amp;gt; f(siz), g(siz);
    for (int i = 1; i &amp;lt; siz; ++i) &amp;#123;
        int si = 0, so = 0;
        for (int j = 0; j &amp;lt; n; ++j)
            if ((i &amp;gt;&amp;gt; j) &amp;amp; 1)
                si += ci[j], so += co[j];
        if (si == so)
            f[i] = fac[si];
    &amp;#125;
    auto res(0ll);
    for (int i = 1; i &amp;lt; siz; ++i) &amp;#123;
        g[i] = f[i];
        int mn = 0;
        for (int j = 0; j &amp;lt; n; ++j)
            if ((i &amp;gt;&amp;gt; j) &amp;amp; 1) &amp;#123;
                mn = j;
                break;
            &amp;#125;
        int s = i ^ (1 &amp;lt;&amp;lt; mn);
        (g[i] += mod - g[1 &amp;lt;&amp;lt; mn] * f[s] % mod) %= mod;
        for (int j = (s - 1) &amp;amp; s; j; j = (j - 1) &amp;amp; s)
            (g[i] += mod - g[j ^ (1 &amp;lt;&amp;lt; mn)] * f[s ^ j] % mod) %= mod;
        if (i != siz - 1)
            (res += g[i] * f[(siz - 1) ^ i]) %= mod;
        else
            (res += g[i]) %= mod;
    &amp;#125;
    std::cout &amp;lt;&amp;lt; res * qkp(fac[m], mod - 2) % mod &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;d---count-grid-3-coloring&#34;&gt;D - Count Grid 3-coloring&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/abc379/tasks/abc379_g&#34; class=&#34;uri&#34;&gt;https://atcoder.jp/contests/abc379/tasks/abc379_g&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;轮廓线 DP。把每一列已经确定的最靠下的元素压起来，每行逐个确定即可。&lt;/p&gt;
&lt;p&gt;发现有效状态中只能容许最多一对相邻相同元素，这样复杂度就能降下来了。注意特判 &lt;span class=&#34;math inline&#34;&gt;\(1\times 1\)&lt;/span&gt; 的情况。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int mod = 998244353;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#endif
    int n, m;
    std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
    std::array&amp;lt;int, 15&amp;gt; p;
    p[0] = 1;
    for (int i = 1; i &amp;lt; 15; ++i)
        p[i] = p[i - 1] * 3;
    std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; a;
    if (n &amp;gt;= m) &amp;#123;
        a.assign(n + 1, std::vector&amp;lt;int&amp;gt; (m + 1));
        for (int i = 1; i &amp;lt;= n; ++i) 
            for (int j = 1; j &amp;lt;= m; ++j) &amp;#123;
                char t;
                std::cin &amp;gt;&amp;gt; t, a[i][j] = (t == &amp;#39;?&amp;#39; ? -1 : t - &amp;#39;1&amp;#39;);
            &amp;#125;
    &amp;#125;
    else &amp;#123;
        std::swap(n, m);
        a.assign(n + 1, std::vector&amp;lt;int&amp;gt; (m + 1));
        for (int i = 1; i &amp;lt;= m; ++i)
            for (int j = 1; j &amp;lt;= n; ++j) &amp;#123;
                char t;
                std::cin &amp;gt;&amp;gt; t, a[j][i] = (t == &amp;#39;?&amp;#39; ? -1 : t - &amp;#39;1&amp;#39;);
            &amp;#125;
    &amp;#125;
    int siz = p[m];
    using arr = std::vector&amp;lt;long long&amp;gt;;
    using brr = std::vector&amp;lt;arr&amp;gt;;
    using crr = std::vector&amp;lt;brr&amp;gt;;
    std::vector&amp;lt;int&amp;gt; s, tab(siz, -1);
    auto getv_1 = [&amp;amp;](int j, int i) &amp;#123;
        return (j / p[i - 1]) % 3;
    &amp;#125;;
    auto getv = [&amp;amp;](int j, int i) &amp;#123;
        return (s[j] / p[i - 1]) % 3;
    &amp;#125;;
    auto chg = [&amp;amp;](int j, int i, int v) &amp;#123;
        return tab[s[j] - p[i - 1] * getv(j, i) + p[i - 1] * v];
    &amp;#125;;
    auto out = [&amp;amp;](int i) &amp;#123;
        std::string s;
        for (int j = 1; j &amp;lt;= m; ++j)
            s += &amp;#39;1&amp;#39; + getv_1(i, j);
        return s.c_str();
    &amp;#125;;
    for (int i = 0; i &amp;lt; siz; ++i) &amp;#123;
        s.push_back(i);
        int cnt = 0;
        for (int j = 2; j &amp;lt;= m; ++j)
            if (getv_1(i, j - 1) == getv_1(i, j) &amp;amp;&amp;amp; ++cnt &amp;gt;= 2) &amp;#123;
                s.pop_back();
                break;
            &amp;#125;
    &amp;#125;
    for (int i = 0; i &amp;lt; (int)s.size(); ++i)
        tab[s[i]] = i;
    siz = (int)s.size();
    if (n == 1) &amp;#123;
        std::cout &amp;lt;&amp;lt; (a[1][1] == -1 ? 3 : 1) &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
        return 0;
    &amp;#125;
    crr f(n + 1, brr(m + 1, arr(siz)));
    for (int i = 0; i &amp;lt; siz; ++i)
        if ([&amp;amp;](int i, int s) &amp;#123;
            for (int j = 1; j &amp;lt;= m; ++j) &amp;#123;
                if (a[i][j] != -1 &amp;amp;&amp;amp; a[i][j] != getv(s, j))
                    return false;
                if (j != 1 &amp;amp;&amp;amp; getv(s, j) == getv(s, j - 1))
                    return false;
            &amp;#125;
            return true;
        &amp;#125; (1, i)) &amp;#123;
            for (int p = 0; p &amp;lt; 3; ++p)
                if ((a[2][1] == -1 || a[2][1] == p) &amp;amp;&amp;amp; getv(i, 1) != p &amp;amp;&amp;amp; ~chg(i, 1, p))
                    (++f[2][1][chg(i, 1, p)]) %= mod;
        &amp;#125;
    for (int i = 2; i &amp;lt;= n; ++i) &amp;#123;
        for (int k = 1; k &amp;lt; m; ++k)
            for (int j = 0; j &amp;lt; siz; ++j)
                if (f[i][k][j]) &amp;#123;
                    // printf(&amp;quot;f[%d][%d][%s] = %lld\n&amp;quot;, i, k, out(s[j]), f[i][k][j]);
                    for (int p = 0; p &amp;lt; 3; ++p)
                        if ((a[i][k + 1] == -1 || a[i][k + 1] == p) &amp;amp;&amp;amp; getv(j, k) != p &amp;amp;&amp;amp; getv(j, k + 1) != p &amp;amp;&amp;amp; ~chg(j, k + 1, p))
                            (f[i][k + 1][chg(j, k + 1, p)] += f[i][k][j]) %= mod;
                &amp;#125;
        for (int j = 0; j &amp;lt; siz; ++j)
            if (i != n &amp;amp;&amp;amp; f[i][m][j])
                for (int p = 0; p &amp;lt; 3; ++p)
                    if ((a[i + 1][1] == -1 || a[i + 1][1] == p) &amp;amp;&amp;amp; getv(j, 1) != p &amp;amp;&amp;amp; ~chg(j, 1, p))
                        (f[i + 1][1][chg(j, 1, p)] += f[i][m][j]) %= mod;
    &amp;#125;
    auto res = 0ll;
    for (int i = 0; i &amp;lt; siz; ++i)
        (res += f[n][m][i]) %= mod;
    std::cout &amp;lt;&amp;lt; res &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;e---pure-straight&#34;&gt;E - Pure Straight&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/arc126/tasks/arc126_d&#34; class=&#34;uri&#34;&gt;https://atcoder.jp/contests/arc126/tasks/arc126_d&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;手玩发现只要最终序列确定，那么移动的顺序不影响答案。故考虑确定目标位置和移动序列。考虑绝对值的几何意义，不妨令目标子序列中元素集中到被选中位置的中间元素，此时的代价可以计算。用点二进制技巧和库函数可以 &lt;span class=&#34;math inline&#34;&gt;\(O(1)\)&lt;/span&gt; 算代价。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#endif
    int n, k;
    std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; k;
    int siz = 1 &amp;lt;&amp;lt; k;
    std::vector&amp;lt;int&amp;gt; a(n + 1), f(siz, 0x3f3f3f3f);
    auto out = [&amp;amp;](int j) &amp;#123;
        std::string s;
        for (int i = 0; i &amp;lt; k; ++i)
            s += (&amp;#39;0&amp;#39; + ((j &amp;gt;&amp;gt; i) &amp;amp; 1));
        return s.c_str();
    &amp;#125;;
    f[0] = 0;
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        std::cin &amp;gt;&amp;gt; a[i], --a[i];
        for (int j = siz - 1; j &amp;gt;= 0; --j) &amp;#123;
            if (!((j &amp;gt;&amp;gt; a[i]) &amp;amp; 1))
                f[j | (1 &amp;lt;&amp;lt; a[i])] = std::min(f[j | (1 &amp;lt;&amp;lt; a[i])], f[j] + __builtin_popcount(j &amp;amp; (~((1 &amp;lt;&amp;lt; a[i]) - 1))));
            f[j] += std::min(__builtin_popcount(j), k - __builtin_popcount(j));
        &amp;#125;
    &amp;#125;
    std::cout &amp;lt;&amp;lt; f[siz - 1] &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;f---123-set&#34;&gt;F - 123 Set&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/arc184/tasks/arc184_b&#34; class=&#34;uri&#34;&gt;https://atcoder.jp/contests/arc184/tasks/arc184_b&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;做过 &lt;a href=&#34;https://www.luogu.com.cn/problem/P3226&#34;&gt;集合选数&lt;/a&gt;（这个 trick 见过很多次了，应该不只这一道，但我想不起来了）很容易想到画一个表格或者 DAG 出来，其实都能做&lt;/p&gt;
&lt;p&gt;对于表格左上角和 DAG 的源点，肯定是一个 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt;，其不是 &lt;span class=&#34;math inline&#34;&gt;\(2\)&lt;/span&gt; 或 &lt;span class=&#34;math inline&#34;&gt;\(3\)&lt;/span&gt; 的倍数。如果画表，横乘 3 竖乘 2，观察一下是包含了 &lt;span class=&#34;math inline&#34;&gt;\(1\sim n\)&lt;/span&gt; 恰好一次的很多个杨表（没什么用，提一嘴而已），考虑转化目标，发现是用一个不可旋转的倒 L 形骨牌可叠放地铺满异形表格，可以考虑轮廓线 DP&lt;/p&gt;
&lt;p&gt;具体地，用 1 来表示拐角处，0 表示其他，叠放的时候 1 的优先级比 0 高，然后就可以做了。以 3 为行，悲观估计单个表格大概有 &lt;span class=&#34;math inline&#34;&gt;\(31\times 2^{19}\)&lt;/span&gt; 个状态，运算次数差不多 &lt;span class=&#34;math inline&#34;&gt;\(31\times 19\times 2^{19}\)&lt;/span&gt;；再发现长得一模一样的表格肯定方案数是一样的，如果把任意一个表格全部除以 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt;，就会得到 &lt;span class=&#34;math inline&#34;&gt;\(n=10^9\div x\)&lt;/span&gt; 时 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt; 为左上角的杨表，就是说长相只和 &lt;span class=&#34;math inline&#34;&gt;\(10^9\div x\)&lt;/span&gt; 的值有关，可以整除分块 😱 可预计的跑得非常不满，实践下来是可以过的（但是很慢）&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#endif
    int n;
    std::cin &amp;gt;&amp;gt; n;
    auto calc = [&amp;amp;](int r) &amp;#123;
        return r - r / 2 - r / 3 + r / 6;
    &amp;#125;;
    auto dp = [&amp;amp;](int lim) &amp;#123;
        if (lim == 1) &amp;#123;
            // printf(&amp;quot;lim = 1, ret 1&amp;quot;);
            return 1;
        &amp;#125;
        int n = 1, m = 1;
        for (int k = 1; k * 2 &amp;lt;= lim; ++n, k *= 2);
        for (int k = 1; k * 3 &amp;lt;= lim; ++m, k *= 3);
        int siz = 1 &amp;lt;&amp;lt; m;
        std::vector&amp;lt;std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; &amp;gt; f(2, std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; (2, std::vector&amp;lt;int&amp;gt; (siz))), p(n + 1, std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; (m));
        std::vector&amp;lt;std::vector&amp;lt;std::vector&amp;lt;std::pair&amp;lt;int, int&amp;gt; &amp;gt; &amp;gt; &amp;gt; t(2, std::vector&amp;lt;std::vector&amp;lt;std::pair&amp;lt;int, int&amp;gt; &amp;gt; &amp;gt; (2, std::vector&amp;lt;std::pair&amp;lt;int, int&amp;gt; &amp;gt; (siz))); // sb
        auto upd = [&amp;amp;](int i, int k, int j, int v) &amp;#123;
            if (t[i &amp;amp; 1][k &amp;amp; 1][j] != std::make_pair(i, k)) &amp;#123;
                p[i][k].push_back(j);
                t[i &amp;amp; 1][k &amp;amp; 1][j] = &amp;#123; i, k &amp;#125;, f[i &amp;amp; 1][k &amp;amp; 1][j] = v;
            &amp;#125;
            else
                f[i &amp;amp; 1][k &amp;amp; 1][j] = std::min(f[i &amp;amp; 1][k &amp;amp; 1][j], v);
            return;
        &amp;#125;;
        auto chg = [&amp;amp;](int i, int j, int v) &amp;#123;
            return i ^ (((i &amp;gt;&amp;gt; j) &amp;amp; 1) &amp;lt;&amp;lt; j) ^ (v &amp;lt;&amp;lt; j);
        &amp;#125;;
        for (int i = 0; i &amp;lt; siz; ++i) &amp;#123;
            bool flag = 0;
            for (int j = 0; j &amp;lt; m; ++j)
                if (((i &amp;gt;&amp;gt; j) &amp;amp; 1) || (j &amp;amp;&amp;amp; ((i &amp;gt;&amp;gt; (j - 1)) &amp;amp; 1)));
                else &amp;#123;
                    flag = 1;
                    break;
                &amp;#125;
            if (!flag)
                upd(1, m - 1, i, __builtin_popcount(i));
        &amp;#125;
        for (int i = 2; i &amp;lt;= n; i++) &amp;#123;
            int m1 = 1;
            for (int x = (1 &amp;lt;&amp;lt; (i - 1)); x * 3ll &amp;lt;= lim; ++m1, x *= 3);
            int siz1 = 1 &amp;lt;&amp;lt; m1;
            for (auto j : p[i - 1][m - 1]) &amp;#123;
                if (j &amp;amp; 1)
                    upd(i, 0, chg(j &amp;amp; (siz1 - 1), 0, 0), f[(i - 1) &amp;amp; 1][(m - 1) &amp;amp; 1][j]);
                upd(i, 0, chg(j &amp;amp; (siz1 - 1), 0, 1), f[(i - 1) &amp;amp; 1][(m - 1) &amp;amp; 1][j] + 1);
            &amp;#125;
            m = m1, siz = siz1;
            for (int k = 0; k &amp;lt; m - 1; ++k)
                for (auto j : p[i][k]) &amp;#123;
                    if (((j &amp;gt;&amp;gt; k) &amp;amp; 1) || ((j &amp;gt;&amp;gt; (k + 1)) &amp;amp; 1))
                        upd(i, k + 1, chg(j, k + 1, 0), f[i &amp;amp; 1][k &amp;amp; 1][j]);
                    upd(i, k + 1, chg(j, k + 1, 1), f[i &amp;amp; 1][k &amp;amp; 1][j] + 1);
                &amp;#125;
        &amp;#125;
        int res = 0x3f3f3f3f;
        for (auto i : p[n][m - 1])
            res = std::min(res, f[n &amp;amp; 1][(m - 1) &amp;amp; 1][i]);
        return res;
    &amp;#125;;
    int res = 0;
    for (int l = 1, r; l &amp;lt;= n; l = r + 1) &amp;#123;
        r = n / (n / l);
        if (calc(r) - calc(l - 1))
            res += (calc(r) - calc(l - 1)) * dp(n / l);
    &amp;#125;
    std::cout &amp;lt;&amp;lt; res &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://xsc062.netlify.app/20250803/</guid>
            <title>树 DP</title>
            <link>https://xsc062.netlify.app/20250803/</link>
            <category>DP</category>
            <category>树形 DP</category>
            <category>长链剖分</category>
            <pubDate>Sun, 03 Aug 2025 11:44:54 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;树上的 DP 以及 和树有关的 DP&lt;/p&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;a---svjetlo&#34;&gt;A - Svjetlo&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P7163&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P7163&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;很容易想到一种状态设计，即令 &lt;span class=&#34;math inline&#34;&gt;\(f_{x,0/1/2}\)&lt;/span&gt; 分别表示有 &lt;span class=&#34;math inline&#34;&gt;\(0/1/2\)&lt;/span&gt; 个端点在子树内部的情况；然后就开始思考，如何满足对于开关状态的要求？&lt;/p&gt;
&lt;p&gt;还是想少了。如果再加一维，从『状态为开或关』思考就会轻松很多，令 &lt;span class=&#34;math inline&#34;&gt;\(f_{x,0/1/2,0/1}\)&lt;/span&gt; 表示有 &lt;span class=&#34;math inline&#34;&gt;\(0/1/2\)&lt;/span&gt; 个端点再子树外部，且子树内操作完后 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 为关 / 开的最少步数。然后分类讨论转移方式即可。&lt;/p&gt;
&lt;p&gt;一个比较方便的讨论方式是，先确定某种情况下，访问 &lt;span class=&#34;math inline&#34;&gt;\(u\)&lt;/span&gt; 与 &lt;span class=&#34;math inline&#34;&gt;\(v\)&lt;/span&gt; 的次数，然后就可以得到它们原本的状态。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#endif
    int n, rt = -1;
    std::cin &amp;gt;&amp;gt; n;
    std::vector&amp;lt;int&amp;gt; a(n + 1);
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        char t;
        std::cin &amp;gt;&amp;gt; t;
        a[i] = t - &amp;#39;0&amp;#39;;
        if (!a[i])
            rt = i;
    &amp;#125;
    if (rt == -1) &amp;#123;
        std::cout &amp;lt;&amp;lt; 0 &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
        return 0;
    &amp;#125;
    std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; g(n + 1);
    for (int i = 1, x, y; i &amp;lt; n; ++i) &amp;#123;
        std::cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; y;
        g[x].push_back(y), g[y].push_back(x);
    &amp;#125;
    std::vector&amp;lt;int&amp;gt; tag(n + 1);
    std::function&amp;lt;void(int, int)&amp;gt; DFS = [&amp;amp;](int x, int fa) &amp;#123;
        tag[x] = a[x];
        for (auto i : g[x])
            if (i != fa)
                DFS(i, x), tag[x] &amp;amp;= tag[i];
        return;
    &amp;#125;;
    DFS(rt, -1);
    std::vector&amp;lt;std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; &amp;gt; f(n + 1, std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; (3, std::vector&amp;lt;int&amp;gt; (2, 0x3f3f3f3f)));
    DFS = [&amp;amp;](int x, int fa) &amp;#123;
        f[x][0][a[x]] = 0;
        for (auto i : g[x])
            if (i != fa &amp;amp;&amp;amp; !tag[i]) &amp;#123;
                DFS(i, x);
                auto g = f[x];
                f[x][0][0] = std::min(g[0][0] + f[i][0][1] + 4, g[0][1] + f[i][0][0] + 2);
                f[x][0][1] = std::min(g[0][1] + f[i][0][1] + 4, g[0][0] + f[i][0][0] + 2);
                f[x][1][0] = std::min(&amp;#123; g[1][0] + f[i][0][1] + 4, g[1][1] + f[i][0][0] + 2, g[0][0] + f[i][1][0] + 3, g[0][1] + f[i][1][1] + 1 &amp;#125;);
                f[x][1][1] = std::min(&amp;#123; g[1][1] + f[i][0][1] + 4, g[1][0] + f[i][0][0] + 2, g[0][1] + f[i][1][0] + 3, g[0][0] + f[i][1][1] + 1 &amp;#125;);
                f[x][2][0] = std::min(&amp;#123; g[2][0] + f[i][0][1] + 4, g[2][1] + f[i][0][0] + 2, g[1][0] + f[i][1][1], g[1][1] + f[i][1][0] + 2, g[0][0] + f[i][2][1] + 4, g[0][1] + f[i][2][0] + 2 &amp;#125;);
                f[x][2][1] = std::min(&amp;#123; g[2][1] + f[i][0][1] + 4, g[2][0] + f[i][0][0] + 2, g[1][1] + f[i][1][1], g[1][0] + f[i][1][0] + 2, g[0][1] + f[i][2][1] + 4, g[0][0] + f[i][2][0] + 2 &amp;#125;);
            &amp;#125;
        f[x][1][0] = std::min(f[x][1][0], f[x][0][1] + 1);
        f[x][1][1] = std::min(f[x][1][1], f[x][0][0] + 1);
        f[x][2][0] = std::min(f[x][2][0], f[x][1][0]);
        f[x][2][1] = std::min(f[x][2][1], f[x][1][1]);
        // for (int i = 0; i &amp;lt; 3; ++i)
        //     for (int j = 0; j &amp;lt; 2; ++j)
        //         printf(&amp;quot;f[%d][%d][%d] = %d\n&amp;quot;, x, i, j, f[x][i][j]);
        return;
    &amp;#125;;
    DFS(rt, -1);
    std::cout &amp;lt;&amp;lt; f[rt][2][1] &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;b---one-to-one&#34;&gt;B - One to One&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/arc140/tasks/arc140_d&#34; class=&#34;uri&#34;&gt;https://atcoder.jp/contests/arc140/tasks/arc140_d&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;观察原图上连通块，发现要么是没有未确定边的基环树，要么是有恰好一条未确定边的树。缩点，任意为未确定边赋值，考察最后得到的连通块，发现要么是以『基环树点』为根的树，要么是不包含『基环树点』的（内向）基环树。&lt;/p&gt;
&lt;p&gt;这里要用到贡献的思想。考虑将全局划分为若干个部分，保证每部分的单步价值是可确定的。将第一步，即对树和基环树的讨论拆开，对于树，其数量确定；对于基环树，发现环的数量即为基环树的数量，进一步将所有步中的『环』这一类分开，统计成环的方案数就可以得到基环树的贡献。具体地，令 &lt;span class=&#34;math inline&#34;&gt;\(f_{i,j}\)&lt;/span&gt; 为在前 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 个点中选择 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; 个成一个环的方案数，则有：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
f_{i,j}=f_{i-1,j}+f_{i-1,j-1}\times siz_i
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;最后计算每个环的贡献即可。注意还要算上环内部的排列（注意循环位移）。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int mod = 998244353;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#endif
    int n;
    std::cin &amp;gt;&amp;gt; n;
    std::vector&amp;lt;int&amp;gt; a(n + 1), tag(n + 1), s(n + 1, 1), fa(n + 1), siz(n + 1);
    std::iota(fa.begin() + 1, fa.end(), 1);
    std::function&amp;lt;int(int)&amp;gt; find = [&amp;amp;](int x) &amp;#123;
        return x == fa[x] ? x : fa[x] = find(fa[x]);
    &amp;#125;;
    auto merge = [&amp;amp;](int x, int y) &amp;#123;
        x = find(x), y = find(y);
        if (x != y) &amp;#123;
            tag[y] += tag[x];
            s[y] += s[x];
            fa[x] = y;
        &amp;#125;
        return;
    &amp;#125;;
    for (int i = 1; i &amp;lt;= n; ++i)  &amp;#123;
        std::cin &amp;gt;&amp;gt; a[i], fa[i] = i;
        if (a[i] == -1)
            tag[i] = 1;
        else
            merge(i, a[i]);
    &amp;#125;
    int cnt1 = 0, cnt2 = 0;
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        cnt1 += (fa[i] == i &amp;amp;&amp;amp; !tag[i]);
        if (fa[i] == i &amp;amp;&amp;amp; tag[i])
            siz[++cnt2] = s[i];
    &amp;#125;
    auto qkp = [&amp;amp;](long long x, int y) &amp;#123;
        auto res(1ll);
        for (; y; (x *= x) %= mod, y &amp;gt;&amp;gt;= 1)
            if (y &amp;amp; 1)
                (res *= x) %= mod;
        return res;
    &amp;#125;;
    auto res(cnt1 * qkp(n, cnt2) % mod);
    std::vector&amp;lt;std::vector&amp;lt;long long&amp;gt; &amp;gt; f(cnt2 + 1, std::vector&amp;lt;long long&amp;gt; (cnt2 + 1));
    f[0][0] = 1ll;
    for (int i = 1; i &amp;lt;= cnt2; ++i) &amp;#123;
        // printf(&amp;quot;i = %d, siz = %d: \n&amp;quot;, i, siz[i]);
        for (int j = 0; j &amp;lt;= i; ++j) &amp;#123;
            f[i][j] = f[i - 1][j];
            if (j != 0)
                (f[i][j] += f[i - 1][j - 1] * siz[i]) %= mod;
            // printf(&amp;quot;  f[%d][%d] = %lld\n&amp;quot;, i, j, f[i][j]);
        &amp;#125;
    &amp;#125;
    for (int i = 1; i &amp;lt;= cnt2; ++i) &amp;#123;
        static auto fac(1ll);
        (res += f[cnt2][i] * fac % mod * qkp(n, cnt2 - i) % mod) %= mod;
        (fac *= i) %= mod;
    &amp;#125;
    std::cout &amp;lt;&amp;lt; res &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;c---diameter-cuts&#34;&gt;C - Diameter Cuts&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://codeforces.com/problemset/problem/1499/F&#34; class=&#34;uri&#34;&gt;https://codeforces.com/problemset/problem/1499/F&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;令 &lt;span class=&#34;math inline&#34;&gt;\(f_{x,i}\)&lt;/span&gt; 表示 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 上的最长链长为 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 的方案数，就可以用一个类似背包的过程求答案了。发现这个背包满足可以被优化的形式，故能在 &lt;span class=&#34;math inline&#34;&gt;\(O(nk)\)&lt;/span&gt; 内解决问题。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int mod = 998244353;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#endif
    int n, k;
    std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; k, ++k;
    if (k == 0) &amp;#123;
        std::cout &amp;lt;&amp;lt; 1 &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
        return 0;
    &amp;#125;
    std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; g(n + 1);
    for (int i = 1, x, y; i &amp;lt; n; ++i) &amp;#123;
        std::cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; y;
        g[x].push_back(y), g[y].push_back(x);
    &amp;#125;
    std::vector&amp;lt;int&amp;gt; h(n + 1);
    std::vector&amp;lt;std::vector&amp;lt;long long&amp;gt; &amp;gt; f(n + 1, std::vector&amp;lt;long long&amp;gt; (k + 1));
    std::function&amp;lt;void(int, int)&amp;gt; DFS = [&amp;amp;](int x, int fa) &amp;#123;
        f[x][1] = 1ll, h[x] = 1;
        for (auto i : g[x])
            if (i != fa) &amp;#123;
                DFS(i, x);
                std::vector&amp;lt;long long&amp;gt; g(k + 1);
                g.swap(f[x]);
                for (int j = std::min(h[x], k); j; --j)
                    for (int l = std::min(h[i], k - j); ~l; --l)
                        (f[x][std::max(j, l + 1)] += g[j] * f[i][l] % mod) %= mod;
                h[x] = std::max(h[x], h[i] + 1);
            &amp;#125;
        for (int i = 1; i &amp;lt;= h[x] &amp;amp;&amp;amp; i &amp;lt;= k; ++i)
            (f[x][0] += f[x][i]) %= mod;
        // for (int i = 0; i &amp;lt;= h[x] &amp;amp;&amp;amp; i &amp;lt;= k; ++i)
        //     printf(&amp;quot;f[%d][%d] = %lld\n&amp;quot;, x, i, f[x][i]);
        return;
    &amp;#125;;
    DFS(1, -1);
    auto res(0ll);
    for (int i = 1; i &amp;lt;= k; ++i)
        (res += f[1][i]) %= mod;
    std::cout &amp;lt;&amp;lt; res &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;d---leaf-partition&#34;&gt;D - Leaf Partition&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://codeforces.com/problemset/problem/1146/F&#34; class=&#34;uri&#34;&gt;https://codeforces.com/problemset/problem/1146/F&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;假设已经完成分组，欲判定这种方式是否合法，容易想到对每一组叶子建立虚树，则该分组方式合法，当且仅当没有一个点被多个虚树占用。也即，我们需要在总的虚树上选出一些点，让它们可以覆盖所有叶子。&lt;/p&gt;
&lt;p&gt;虚树上 DP，容易发现当且仅当存在 &lt;span class=&#34;math inline&#34;&gt;\(\ge 2\)&lt;/span&gt; 个儿子想要分进同一个虚树时，&lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 会被选到。故令 &lt;span class=&#34;math inline&#34;&gt;\(f_{i, 0/1/2}\)&lt;/span&gt; 表示当前有 &lt;span class=&#34;math inline&#34;&gt;\(0/1/\ge 2\)&lt;/span&gt; 个儿子想要选择 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 时的方案数，DP 即可。&lt;/p&gt;
&lt;p&gt;在实现的过程中就会发现根本不需要求虚树，原树上 DP 就可以了。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int mod = 998244353;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#endif
    int n;
    std::cin &amp;gt;&amp;gt; n;
    std::vector&amp;lt;int&amp;gt; fa(n + 1);
    std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; g(n + 1);
    for (int i = 2; i &amp;lt;= n; ++i)
        std::cin &amp;gt;&amp;gt; fa[i], g[fa[i]].push_back(i);
    std::vector&amp;lt;std::array&amp;lt;long long, 3&amp;gt; &amp;gt; f(n + 1);
    std::function&amp;lt;void(int)&amp;gt; DFS = [&amp;amp;](int x) &amp;#123;
        if (g[x].empty())
            f[x][2] = 1ll;
        else
            f[x][0] = 1ll;
        for (auto i : g[x]) &amp;#123;
            DFS(i);
            auto F0 = (f[i][0] + f[i][2]) % mod, F1 = (f[i][1] + f[i][2]) % mod;
            f[x][2] = (f[x][2] * F0 % mod + f[x][2] * F1 % mod + f[x][1] * F1 % mod) % mod;
            f[x][1] = (f[x][1] * F0 % mod + f[x][0] * F1 % mod) % mod;
            (f[x][0] *= F0) %= mod;
        &amp;#125;
        // printf(&amp;quot;%d: %lld / %lld / %lld\n&amp;quot;, x, f[x][0], f[x][1], f[x][2]);
        return;
    &amp;#125;;
    DFS(1);
    std::cout &amp;lt;&amp;lt; (f[1][0] + f[1][2]) % mod &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;e---uniformly-branched-trees&#34;&gt;E - Uniformly Branched Trees&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://codeforces.com/problemset/problem/724/F&#34; class=&#34;uri&#34;&gt;https://codeforces.com/problemset/problem/724/F&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;感觉是很常见的套路，但是我不会 😱&lt;/p&gt;
&lt;p&gt;在手玩样例的时候可以感性认知到，每个树会被每种点作为根的情况统计一次。且如果固定以某种（化学环境）的点为根，可以通过按 siz 从小到大排列唯一求解出该树。&lt;/p&gt;
&lt;p&gt;发现以重心为根（即钦定根为重心）可以带来很多优美的性质。因为 siz 是好确定的，且是儿子的排序依据，所以选重心便于统计，同时满足每种树最多被统计两次（当且仅当有两个重心）。&lt;/p&gt;
&lt;p&gt;发现这就变成了多重集的组合数，设 &lt;span class=&#34;math inline&#34;&gt;\(f_{i,j,k}\)&lt;/span&gt; 表示已经花费 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 个点组成一个子树，子树的根节点当前已经确认了 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; 个儿子，最靠右的一个 siz &lt;span class=&#34;math inline&#34;&gt;\(\le k\)&lt;/span&gt; 的方案数。得到 &lt;span class=&#34;math inline&#34;&gt;\(f_{i,j,k}=\sum_{x=0} f_{i-x\cdot k,j-x,k-1}\cdot \binom{f_{k,d-1,k}+x-1}{x}\)&lt;/span&gt;（相当于将 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 个无标号的位置 / 球分配给 &lt;span class=&#34;math inline&#34;&gt;\(f_{k,d-1,k}\)&lt;/span&gt; 个有标号的选项 / 盒子，插板即可）。&lt;/p&gt;
&lt;p&gt;若 &lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt; 为奇数，则可直接输出 &lt;span class=&#34;math inline&#34;&gt;\(f_{n,d,\lfloor\frac n2\rfloor}\)&lt;/span&gt;；若 &lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt; 为偶数，则可能存在两个重心，即需要统计拥有两个重心，且以两个重心分别为根时长相不同的树种类。这种情况下显然存在一条边，左右两边 siz 相同且长相不同。故数量为 &lt;span class=&#34;math inline&#34;&gt;\(\binom{f_{\lfloor \frac n2\rfloor, d-1,\lfloor \frac n2\rfloor}}{2}\)&lt;/span&gt;，容斥掉即可。&lt;/p&gt;
&lt;p&gt;需要特判 &lt;span class=&#34;math inline&#34;&gt;\(n\le2\)&lt;/span&gt; 的情况。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#endif
    int n, d, mod;
    std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; d &amp;gt;&amp;gt; mod;
    if (n &amp;lt;= 2) &amp;#123;
        std::cout &amp;lt;&amp;lt; 1 &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
        return 0;
    &amp;#125;
    using arr = std::vector&amp;lt;long long&amp;gt;;
    using brr = std::vector&amp;lt;arr&amp;gt;;
    using crr = std::vector&amp;lt;brr&amp;gt;;
    auto qkp = [&amp;amp;](long long x, int y) &amp;#123;
        auto res(1ll);
        for (; y; (x *= x) %= mod, y &amp;gt;&amp;gt;= 1)
            if (y &amp;amp; 1)
                (res *= x) %= mod;
        return res;
    &amp;#125;;
    arr inv(d + 1);
    inv[0] = inv[1] = 1ll;
    auto fac = 1ll;
    for (int i = 2; i &amp;lt;= d; ++i) &amp;#123;
        (fac *= i) %= mod;
        inv[i] = qkp(fac, mod - 2);
    &amp;#125;
    auto C = [&amp;amp;](long long n, int m) &amp;#123;
        if (m == 0)
            return 1ll;
        if (m &amp;gt; n)
            return 0ll;
        auto res(1ll);
        for (auto i = 0; i &amp;lt; m; ++i)
            (res *= n - i) %= mod;
        return res * inv[m] % mod;
    &amp;#125;;
    crr f(n + 1, brr(d + 1, arr(n / 2 + 1)));
    f[1][0][0] = 1ll;
    for (int i = 1; i &amp;lt;= n; ++i)
        for (int j = 0; j &amp;lt;= d &amp;amp;&amp;amp; 1 + j &amp;lt;= i; ++j) &amp;#123;
            for (int x = 0; x &amp;lt;= j &amp;amp;&amp;amp; x &amp;lt;= i; ++x)
                f[i][j][1] += f[i - x][j - x][0];
            f[i][j][1] %= mod;
            for (int k = 2; k &amp;lt;= n / 2; ++k) &amp;#123;
                // bool flag = (i == 10 &amp;amp;&amp;amp; j == 3 &amp;amp;&amp;amp; k == 3);
                for (int x = 0; x &amp;lt;= j &amp;amp;&amp;amp; x * k &amp;lt;= i; ++x) &amp;#123;
                    f[i][j][k] += f[i - x * k][j - x][k - 1] * C(f[k][d - 1][k - 1] + x - 1, x);
                    // if (flag)
                    //     printf(&amp;quot;x = %d, f[%d][%d][%d](%lld) * C(%lld, %d)(%lld)\n&amp;quot;, x, i - x * k, j - x, k - 1, f[i - x * k][j - x][k - 1], f[k][d - 1][k - 1] + x - 1, x, C(f[k][d - 1][k - 1] + x - 1, x));
                &amp;#125;
                f[i][j][k] %= mod;
            &amp;#125;
        &amp;#125;
    // for (int i = 1; i &amp;lt;= n; ++i)
    //     for (int j = 0; j &amp;lt;= d &amp;amp;&amp;amp; j &amp;lt;= i - 1; ++j, puts(&amp;quot;&amp;quot;))
    //         for (int k = 0; k &amp;lt;= n / 2; ++k) &amp;#123;
    //             printf(&amp;quot;f[%d][%d][%d] = %lld\n&amp;quot;, i, j, k, f[i][j][k]);
    //         &amp;#125;
    if (n &amp;amp; 1)
        std::cout &amp;lt;&amp;lt; f[n][d][n / 2] &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    else &amp;#123;
        auto res(f[n][d][n / 2]);
        res = (res + mod - C(f[n / 2][d - 1][n / 2 - 1], 2)) % mod;
        std::cout &amp;lt;&amp;lt; res &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    &amp;#125;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;a---dominant-indices&#34;&gt;A - Dominant Indices&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://codeforces.com/problemset/problem/1009/F&#34; class=&#34;uri&#34;&gt;https://codeforces.com/problemset/problem/1009/F&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;长剖板子；难点在于可能要复习一下长剖怎么写。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#endif
    int n;
    std::cin &amp;gt;&amp;gt; n;
    std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; g(n + 1);
    for (int i = 1, x, y; i &amp;lt; n; ++i) &amp;#123;
        std::cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; y;
        g[x].push_back(y), g[y].push_back(x);
    &amp;#125;
    std::vector&amp;lt;int&amp;gt; h(n + 1), son(n + 1);
    std::function&amp;lt;void(int, int)&amp;gt; DFS = [&amp;amp;](int x, int fa) &amp;#123;
        h[x] = 1;
        for (auto i : g[x])
            if (i != fa) &amp;#123;
                DFS(i, x);
                h[x] = std::max(h[x], h[i] + 1);
                if (h[i] &amp;gt; h[son[x]])
                    son[x] = i;
            &amp;#125;
        return;
    &amp;#125;;
    DFS(1, -1);
    std::vector&amp;lt;int&amp;gt; _f(2 * n + 1), res(n + 1);
    auto pos(_f.begin());
    std::vector&amp;lt;decltype(pos)&amp;gt; f(n + 1);
    DFS = [&amp;amp;](int x, int fa) &amp;#123;
        ++f[x][0];
        if (!son[x]) &amp;#123;
            res[x] = 0;
            return;
        &amp;#125;
        f[son[x]] = std::next(f[x]);
        DFS(son[x], x);
        int mx = -std::max(std::make_pair(f[x][res[son[x]] + 1], -(res[son[x]] + 1)), std::make_pair(1, 0)).second;
        for (auto i : g[x])
            if (i != fa &amp;amp;&amp;amp; i != son[x]) &amp;#123;
                f[i] = pos, pos = std::next(pos, h[i] + 1);
                DFS(i, x);
                for (int j = 0; j &amp;lt;= h[i]; ++j) &amp;#123;
                    f[x][j + 1] += f[i][j];
                    if (j + 1 != mx &amp;amp;&amp;amp; std::make_pair(f[x][j + 1], -(j + 1)) &amp;gt; std::make_pair(f[x][mx], -mx))
                        mx = j + 1;
                &amp;#125;
            &amp;#125;
        // printf(&amp;quot;%d: &amp;quot;, x);
        // for (int i = 0; i &amp;lt;= h[x]; ++i)
        //     printf(&amp;quot;%d &amp;quot;, f[x][i]);
        // puts(&amp;quot;&amp;quot;);
        res[x] = mx;
        return;
    &amp;#125;;
    f[1] = pos, pos = std::next(pos, h[1]);
    DFS(1, -1);
    for (int i = 1; i &amp;lt;= n; ++i)
        std::cout &amp;lt;&amp;lt; res[i] &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;b---树上异或&#34;&gt;B - 树上异或&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P9745&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P9745&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;和 &lt;a href=&#34;#a---svjetlo&#34;&gt;Svjetlo&lt;/a&gt; 很像，把连通块的异或和放到状态里，拆位后令 &lt;span class=&#34;math inline&#34;&gt;\(f_{i,j,0/1}\)&lt;/span&gt; 表示点 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 所在的连通块在第 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; 位异或和为 &lt;span class=&#34;math inline&#34;&gt;\(0/1\)&lt;/span&gt; 的权值（&lt;strong&gt;不计 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 所在连通块&lt;/strong&gt;），转移即可。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int mod = 998244353;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#endif
    int n;
    std::cin &amp;gt;&amp;gt; n;
    std::vector&amp;lt;long long&amp;gt; a(n + 1);
    for (int i = 1; i &amp;lt;= n; ++i)
        std::cin &amp;gt;&amp;gt; a[i];
    std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; g(n + 1);
    for (int i = 2, x; i &amp;lt;= n; ++i) &amp;#123;
        std::cin &amp;gt;&amp;gt; x;
        g[x].push_back(i), g[i].push_back(x);
    &amp;#125;
    std::vector&amp;lt;long long&amp;gt; dp(n + 1);
    std::vector&amp;lt;std::array&amp;lt;std::array&amp;lt;long long, 2&amp;gt;, 60&amp;gt; &amp;gt; f(n + 1);
    std::function&amp;lt;void(int, int)&amp;gt; DFS = [&amp;amp;](int x, int fa) &amp;#123;
        for (int i = 0; i &amp;lt; 60; ++i)
            f[x][i][(a[x] &amp;gt;&amp;gt; i) &amp;amp; 1] = 1ll;
        for (auto i : g[x])
            if (i != fa) &amp;#123;
                DFS(i, x);
                for (int j = 0; j &amp;lt; 60; ++j) &amp;#123;
                    auto f1 = f[x][j];
                    f[x][j][0] = (f1[0] * dp[i] % mod + f1[0] * f[i][j][0] % mod + f1[1] * f[i][j][1] % mod) % mod;
                    f[x][j][1] = (f1[1] * dp[i] % mod + f1[0] * f[i][j][1] % mod + f1[1] * f[i][j][0] % mod) % mod;
                &amp;#125;
            &amp;#125;
        for (int i = 0; i &amp;lt; 60; ++i)
            dp[x] += (1ll &amp;lt;&amp;lt; i) % mod * f[x][i][1] % mod;
        dp[x] %= mod;
        return;
    &amp;#125;;
    DFS(1, -1);
    std::cout &amp;lt;&amp;lt; dp[1] &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;c---一个网的路&#34;&gt;C - 一个网的路&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P8595&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P8595&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;首先需要意识到，树和链的边数是一样的，炸掉了多少条边，在之后就会花多少代价补回来。故炸一个点的代价为度数 +1。对于一个点 &lt;span class=&#34;math inline&#34;&gt;\(u\)&lt;/span&gt;，分为四种可能性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;被炸了，单独作为一个连通块。&lt;/li&gt;
&lt;li&gt;没被炸，儿子全部被炸了。&lt;/li&gt;
&lt;li&gt;没被炸，有 1 个儿子没被炸。&lt;/li&gt;
&lt;li&gt;没被炸，有 2 个儿子没被炸。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;分别用 &lt;span class=&#34;math inline&#34;&gt;\(f_{u,0/1/2/3}\)&lt;/span&gt; 代表上面四种可能性，转移即可。&lt;/p&gt;
&lt;p&gt;贺了个 fread，擦边跑过了。这个不是 &lt;span class=&#34;math inline&#34;&gt;\(O(n)\)&lt;/span&gt; 的吗？&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int LEN = (1 &amp;lt;&amp;lt; 20);
#ifdef ONLINE_JUDGE
int nec(void) &amp;#123;
    static char buf[LEN], *p = buf, *e = buf;
    if (p == e) &amp;#123;
        e = buf + fread(buf, 1, LEN, stdin);
        if (e == buf) return EOF;
        p = buf;
    &amp;#125;
    return *p++;
&amp;#125;
#else
#define nec getchar

#endif
bool read(int &amp;amp;x) &amp;#123;
    x = 0;
    bool f = 0;
    char ch = nec();
    while (ch &amp;lt; &amp;#39;0&amp;#39; || ch &amp;gt; &amp;#39;9&amp;#39;) &amp;#123;
        if (ch == EOF) return 0;
        if (ch == &amp;#39;-&amp;#39;) f = 1;
        ch = nec();
    &amp;#125;
    while (ch &amp;gt;= &amp;#39;0&amp;#39; &amp;amp;&amp;amp; ch &amp;lt;= &amp;#39;9&amp;#39;) &amp;#123;
        x = x * 10 + ch - &amp;#39;0&amp;#39;;
        ch = nec();
    &amp;#125;
    if (f) x = -x;
    return 1;
&amp;#125;
void print(int x) &amp;#123;
    if (x &amp;lt; 0)
        putchar(&amp;#39;-&amp;#39;), x = -x;
    if (x &amp;gt;= 10) print(x / 10);
    putchar(x % 10 + &amp;#39;0&amp;#39;);
    return;
&amp;#125;
void print(int x, char ch) &amp;#123;
    print(x), putchar(ch);
    return;
&amp;#125;
int main() &amp;#123;
    int n, m;
    read(n), read(m);
    int res = (n - 1) - m;
    std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; g(n + 1);
    for (int x, y; m--; ) &amp;#123;
        read(x), read(y);
        g[x].push_back(y), g[y].push_back(x);
    &amp;#125;
    std::vector&amp;lt;int&amp;gt; tag(n + 1);
    std::vector&amp;lt;std::array&amp;lt;int, 4&amp;gt; &amp;gt; f(n + 1);
    std::function&amp;lt;void(int, int)&amp;gt; DFS = [&amp;amp;](int x, int fa) &amp;#123;
        tag[x] = 1;
        f[x][0] = (fa != -1) + 1;
        f[x][2] = f[x][3] = 0x3f3f3f3f;
        for (auto i : g[x])
            if (i != fa) &amp;#123;
                DFS(i, x);
                f[x][3] = std::min(f[x][3] + f[i][0], f[x][2] + std::min(f[i][1], f[i][2]));
                f[x][2] = std::min(f[x][2] + f[i][0], f[x][1] + std::min(f[i][1], f[i][2]));
                f[x][1] += f[i][0];
                f[x][0] += std::min(&amp;#123; f[i][0] - 1, f[i][1], f[i][2], f[i][3] &amp;#125;) + 1;
            &amp;#125;
        return;
    &amp;#125;;
    for (int i = 1; i &amp;lt;= n; ++i)
        if (!tag[i]) &amp;#123;
            DFS(i, -1);
            res += *std::min_element(f[i].begin(), f[i].end());
        &amp;#125;
    print(res, &amp;#39;\n&amp;#39;);
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;d---随机树&#34;&gt;D - 随机树&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P3830&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P3830&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;对于第一问，令 &lt;span class=&#34;math inline&#34;&gt;\(f_x\)&lt;/span&gt; 表示共有 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 个叶子时的期望深度，两个新叶子的期望深度为 &lt;span class=&#34;math inline&#34;&gt;\(f_{x-1}+1\)&lt;/span&gt;，delta 为 &lt;span class=&#34;math inline&#34;&gt;\(f_{x-1}+2\)&lt;/span&gt;，故有 &lt;span class=&#34;math inline&#34;&gt;\(f_x=\dfrac {(x-1)f_{x-1}+f_{x-1}+2}x\)&lt;/span&gt;，递推即可。&lt;/p&gt;
&lt;p&gt;对于第二问，令 &lt;span class=&#34;math inline&#34;&gt;\(f_{x,k}\)&lt;/span&gt; 表示有 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 个叶子，深度 &lt;span class=&#34;math inline&#34;&gt;\(\ge k\)&lt;/span&gt; 的概率（一种理解是从整数概率公式的角度出发）。则考虑枚举左、右叶子数，对于左侧叶子数为 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 的情况，&lt;strong&gt;为了去重，只选择深度为 &lt;span class=&#34;math inline&#34;&gt;\(k-1\)&lt;/span&gt; 的叶子展开&lt;/strong&gt;。只考虑某种组合的出现概率，为 &lt;span class=&#34;math inline&#34;&gt;\(f_{i,k-1}+f_{x-i,k-1}-f_{i,k-1}\cdot f_{x-i,k-1}\)&lt;/span&gt;。数归可以证明，对于任意 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt;，深度为 &lt;span class=&#34;math inline&#34;&gt;\(k-1\)&lt;/span&gt; 的叶子被选中的概率均为 &lt;span class=&#34;math inline&#34;&gt;\(\dfrac 1{x-1}\)&lt;/span&gt;。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#endif
    int q, n;
    std::cin &amp;gt;&amp;gt; q &amp;gt;&amp;gt; n;
    std::cout &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6);
    if (q == 1) &amp;#123;
        std::vector&amp;lt;double&amp;gt; f(n + 1);
        for (int i = 2; i &amp;lt;= n; ++i)
            f[i] = (f[i - 1] * (i - 1) + f[i - 1] + 2.) / i;
        std::cout &amp;lt;&amp;lt; f[n] &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    &amp;#125;
    else &amp;#123;
        std::vector&amp;lt;std::vector&amp;lt;double&amp;gt; &amp;gt; f(n + 1, std::vector&amp;lt;double&amp;gt; (n + 1));
        for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
            f[i][0] = 1.;
            for (int j = 1; j &amp;lt; i; ++j) &amp;#123;
                auto s(0.);
                for (int k = 1; k &amp;lt; i; ++k)
                    s += f[k][j - 1] + f[i - k][j - 1] - f[k][j - 1] * f[i - k][j - 1];
                f[i][j] = s / (i - 1);
            &amp;#125;
        &amp;#125;
        auto res(0.);
        for (int i = 1; i &amp;lt; n; ++i)
            res += f[n][i];
        std::cout &amp;lt;&amp;lt; res &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    &amp;#125;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;e---complete-compress&#34;&gt;E - Complete Compress&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/agc034/tasks/agc034_e&#34; class=&#34;uri&#34;&gt;https://atcoder.jp/contests/agc034/tasks/agc034_e&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;对于链，发现可以枚举最后聚集的点，答案与配对方式无关，check 是否能配对即可。&lt;/p&gt;
&lt;p&gt;如果不是链，则相比链，还可以选择同一子树中不存在祖孙关系的两个点，将它们都向 LCA 移一步。&lt;/p&gt;
&lt;p&gt;故而，可以在链的做法上打一个补丁，观察到先『内部消化』，再在子树间配对一定不劣，且答案仍然和配对方式无关。故令 &lt;span class=&#34;math inline&#34;&gt;\(f_x\)&lt;/span&gt; 表示点 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 内最多消掉多少对，就可以 check 了。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const long long inf = 1e18;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;line_02.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#endif
    int n;
    std::cin &amp;gt;&amp;gt; n;
    std::vector&amp;lt;int&amp;gt; a(n + 1);
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        char t;
        std::cin &amp;gt;&amp;gt; t;
        a[i] = t - &amp;#39;0&amp;#39;;
    &amp;#125;
    std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; g(n + 1);
    for (int i = 1, x, y; i &amp;lt; n; ++i) &amp;#123;
        std::cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; y;
        g[x].push_back(y), g[y].push_back(x);
    &amp;#125;
    auto res(inf);
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        std::vector&amp;lt;int&amp;gt; s(n + 1);
        std::vector&amp;lt;long long&amp;gt; f(n + 1), cnt(n + 1);
        std::function&amp;lt;void(int, int)&amp;gt; DFS = [&amp;amp;](int x, int fa) &amp;#123;
            s[x] = a[x];
            int son = 0;
            auto sum(0ll);
            for (auto i : g[x])
                if (i != fa) &amp;#123;
                    DFS(i, x), s[x] += s[i];
                    sum += cnt[i];
                    if (cnt[i] &amp;gt; cnt[son])
                        son = i;
                &amp;#125;
            if (son) &amp;#123;
                if (cnt[son] * 2 &amp;lt;= sum)
                    f[x] = sum / 2;
                else
                    f[x] = sum - cnt[son] + std::min(f[son], (cnt[son] - (sum - cnt[son])) / 2);
            &amp;#125;
            cnt[x] = sum;
            if (x != i)
                cnt[x] += s[x];
            return;
        &amp;#125;;
        DFS(i, -1);
        if (cnt[i] % 2 == 0 &amp;amp;&amp;amp; f[i] == cnt[i] / 2)
            res = std::min(res, cnt[i] / 2);
    &amp;#125;
    if (res == inf)
        std::cout &amp;lt;&amp;lt; -1 &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    else
        std::cout &amp;lt;&amp;lt; res &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://xsc062.netlify.app/20250723/</guid>
            <title>vp 记录 edu 181</title>
            <link>https://xsc062.netlify.app/20250723/</link>
            <category>差分</category>
            <category>背包</category>
            <pubDate>Wed, 23 Jul 2025 15:06:07 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;tzl 太强了！真挚的膜拜&lt;/p&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;
&lt;p&gt;lhy 太强了！真挚的膜拜&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;e.-sets-of-complementary-sums&#34;&gt;E. Sets of Complementary Sums&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://codeforces.com/contest/2125/problem/E&#34; class=&#34;uri&#34;&gt;https://codeforces.com/contest/2125/problem/E&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;分拆数、其实是个不牛的东西，但是写假了 😅&lt;/p&gt;
&lt;p&gt;令集合元素升序排列为 &lt;span class=&#34;math inline&#34;&gt;\(b_{1\sim n}\)&lt;/span&gt;。显然有结论 &lt;span class=&#34;math inline&#34;&gt;\(\sum b\geqslant (n-1)(b_n+1)\)&lt;/span&gt;，化一下就有 &lt;span class=&#34;math inline&#34;&gt;\(b_n\geqslant \left(\sum\limits_{i=1}^{n-1} b_n-b_i\right)+(n-1)\)&lt;/span&gt;。发现 RSH 取值对 LSH 无影响（从取等开始，RSH 不变，若 &lt;span class=&#34;math inline&#34;&gt;\(b_n\gets b_n+1\)&lt;/span&gt;，只需将每个 &lt;span class=&#34;math inline&#34;&gt;\(b_i\gets b_i+1\)&lt;/span&gt; 即可构造出一组解），故只用考虑 RSH 的每种取值下的方案。&lt;/p&gt;
&lt;p&gt;然后就可以做 &lt;a href=&#34;/20250807/&#34;&gt;分拆数&lt;/a&gt; 了。发现会 MLE，滚动即可。每次暴力 assign 会很慢，可以用一点巧思清空滚动数组。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int mod = 998244353;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#endif
    int T;
    for (std::cin &amp;gt;&amp;gt; T; T--; ) &amp;#123;
        long long n, m;
        std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
        if (n * (n - 1) / 2 &amp;gt; m) &amp;#123;
            std::cout &amp;lt;&amp;lt; 0 &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
            continue;
        &amp;#125;
        if (n == 1) &amp;#123;
            std::cout &amp;lt;&amp;lt; m &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
            continue;
        &amp;#125;
        --n;
        std::vector&amp;lt;std::vector&amp;lt;long long&amp;gt; &amp;gt; f(2, std::vector &amp;lt;long long&amp;gt; (m + 1));
        f[0][0] = 1ll;
        for (int j = 1, at = 1; j &amp;lt;= n; ++j, at ^= 1)
            for (int i = 0; i &amp;lt;= m; ++i) &amp;#123;
                if (i &amp;lt; j)
                    f[at][i] = 0;
                else
                    f[at][i] = (f[at ^ 1][i - j] + f[at][i - j]) % mod;
            &amp;#125;
        auto res(0ll);
        for (int i = 1; i &amp;lt;= m - n; ++i)
            (res += f[n &amp;amp; 1][i] * (m - (i + n) + 1)) %= mod;
        std::cout &amp;lt;&amp;lt; res &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    &amp;#125;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;vp-记录&#34;&gt;vp 记录&lt;/h2&gt;
&lt;h3 id=&#34;a&#34;&gt;A&lt;/h3&gt;
&lt;p&gt;1:43 切。打 &lt;code&gt;std::&lt;/code&gt; 还是太费时间了。&lt;/p&gt;
&lt;h3 id=&#34;b&#34;&gt;B&lt;/h3&gt;
&lt;p&gt;5:46 切，看完题没想到 gcd，输出的时候想到了。莼菜。&lt;/p&gt;
&lt;h3 id=&#34;c&#34;&gt;C&lt;/h3&gt;
&lt;p&gt;11:23 切，原因是容斥符号乱写。&lt;/p&gt;
&lt;h3 id=&#34;d&#34;&gt;D&lt;/h3&gt;
&lt;p&gt;24:21 切，中间重构了一次并且前缀和的部分考虑得有点问题。绅士（38:35）问我为啥做这么快。&lt;/p&gt;
&lt;h3 id=&#34;e.0&#34;&gt;E.0&lt;/h3&gt;
&lt;p&gt;看了一眼感觉不太可做。quack 说 F 板板，故跳。&lt;/p&gt;
&lt;h3 id=&#34;f&#34;&gt;F&lt;/h3&gt;
&lt;p&gt;01:13:41 草完。奇怪的 WQS 二分板板。吃了一发罚时，原因是没人合法的时候要输出 &lt;span class=&#34;math inline&#34;&gt;\(0\)&lt;/span&gt;。但和 maimai 的 30 发比起来还是相形见绌。绅士考虑了这个，但是没判目标 &lt;span class=&#34;math inline&#34;&gt;\(&amp;lt;\)&lt;/span&gt; 当前的情况遗憾 4 题离场。&lt;/p&gt;
&lt;p&gt;场下看了 Diagnostics，发现其实第二发有个地方是 RE 了的（长度不足 &lt;span class=&#34;math inline&#34;&gt;\(6\)&lt;/span&gt; 我的 &lt;code&gt;*std::max_element&lt;/code&gt; 会飞起来），但是不知道为啥就是 A 了。&lt;/p&gt;
&lt;h3 id=&#34;e.1&#34;&gt;E.1&lt;/h3&gt;
&lt;p&gt;猜到结论之后止步于此。试着打了分拆数然后（实际上是）写挂了，怀疑自己结论出错直到 5 题招笑离场 😅&lt;/p&gt;
&lt;h3 id=&#34;b.1&#34;&gt;B.1&lt;/h3&gt;
&lt;p&gt;哈哈 B 的 gcd 没开 &lt;code&gt;long long&lt;/code&gt; 被 hack 了，rk55 to 6000+&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://xsc062.netlify.app/20250721/</guid>
            <title>解题报告 CF1804F Approximate Diameter</title>
            <link>https://xsc062.netlify.app/20250721/</link>
            <category>二分</category>
            <pubDate>Mon, 21 Jul 2025 22:00:00 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;唉确实没见过这种二分形式。&lt;/p&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;a href=&#34;https://codeforces.com/problemset/problem/1804/F&#34; class=&#34;uri&#34;&gt;https://codeforces.com/problemset/problem/1804/F&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;注意到这个范围基本上就是 &lt;a href=&#34;/20231117/#树的直径图的直径&#34;&gt;图直径的这个性质&lt;/a&gt;，但是我不认识 😅&lt;/p&gt;
&lt;p&gt;每次修改做一次 BFS 过于抽象，发现这个上界多了个 &lt;span class=&#34;math inline&#34;&gt;\(2\)&lt;/span&gt; 的系数，把主元换成 &lt;span class=&#34;math inline&#34;&gt;\(d\)&lt;/span&gt; 可以得到 &lt;span class=&#34;math inline&#34;&gt;\(d\in[0.5s,2s]\)&lt;/span&gt;。有一个很牛的操作，假设在当前图上求出来了一个 &lt;span class=&#34;math inline&#34;&gt;\(s&amp;#39;\)&lt;/span&gt;，显然一直加边，&lt;span class=&#34;math inline&#34;&gt;\(2s\)&lt;/span&gt; 这个上界是在变小的，但只要 &lt;span class=&#34;math inline&#34;&gt;\(s&amp;#39;\le 2s\)&lt;/span&gt; 成立，&lt;span class=&#34;math inline&#34;&gt;\(s&amp;#39;\)&lt;/span&gt; 就一直可以作为区间里的一个估值。如果不成立，发现除以二就成立了。&lt;/p&gt;
&lt;p&gt;转化成二分 &lt;span class=&#34;math inline&#34;&gt;\(s&amp;#39;\)&lt;/span&gt; 最远可以达到的距离即可。每次 &lt;span class=&#34;math inline&#34;&gt;\(s&amp;#39;\)&lt;/span&gt; 除以二，共除了 &lt;span class=&#34;math inline&#34;&gt;\(\log n\)&lt;/span&gt; 次；复杂度 &lt;span class=&#34;math inline&#34;&gt;\(O(n\log^2 n)\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;然后注意不要每次 check 都复制一遍原数组然后加边；应该预先在原图上加好所有边，记录版本。原因是申请空间特别费时间。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#endif
    int n, m, q;
    std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m &amp;gt;&amp;gt; q;
    std::vector&amp;lt;std::vector&amp;lt;std::pair&amp;lt;int, int&amp;gt; &amp;gt; &amp;gt; g(n + 1);
    for (int x, y; m--; ) &amp;#123;
        std::cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; y;
        g[x].emplace_back(y, 0), g[y].emplace_back(x, 0);
    &amp;#125;
    for (int i = 1, x, y; i &amp;lt;= q; ++i) &amp;#123;
        std::cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; y;
        g[x].emplace_back(y, i), g[y].emplace_back(x, i);
    &amp;#125;
    std::vector&amp;lt;int&amp;gt; mem(q + 1, -1);
    auto calc = [&amp;amp;](int id) &amp;#123;
        if (~mem[id])
            return mem[id];
        std::queue&amp;lt;std::pair&amp;lt;int, int&amp;gt; &amp;gt; q;
        std::vector&amp;lt;int&amp;gt; tag(n + 1);
        q.emplace(1, 0), tag[1] = 1;
        int mx = 0;
        for (; !q.empty(); ) &amp;#123;
            auto [x, w] = q.front();
            q.pop(), mx = w;
            for (auto [i, ver] : g[x])
                if (ver &amp;lt;= id &amp;amp;&amp;amp; !tag[i]) &amp;#123;
                    tag[i] = 1;
                    q.emplace(i, w + 1);
                &amp;#125;
        &amp;#125;
        return mem[id] = mx;
    &amp;#125;;
    int s = calc(0);
    for (int i = 0; i &amp;lt;= q; ) &amp;#123;
        int j = i;
        for (int l = i + 1, r = q, mid; l &amp;lt;= r; ) &amp;#123;
            mid = (l + r) &amp;gt;&amp;gt; 1;
            if (s &amp;lt;= 2 * calc(mid))
                j = mid, l = mid + 1;
            else
                r = mid - 1;
        &amp;#125;
        for (; i &amp;lt;= j; ++i)
            std::cout &amp;lt;&amp;lt; s &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
        s /= 2;
    &amp;#125;
    std::cout &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
 ]]></description>
        </item>
    </channel>
</rss>
