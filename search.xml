<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>练习 树的各种性质 II</title>
      <link href="/20250717/"/>
      <url>/20250717/</url>
      
        <content type="html"><![CDATA[<p>好像确实比斜优做着舒服。</p><span id="more"></span><hr /><h2 id="a---perfect-matching-on-a-tree">A - Perfect Matching on a Tree</h2><p><a href="https://atcoder.jp/contests/abc362/tasks/abc362_f" class="uri">https://atcoder.jp/contests/abc362/tasks/abc362_f</a></p><p>肯定直接猜以重心为根。</p><p>至于咋求答案，（显然值是所有点的深度之和），这个我去年在场上就被卡住了，还是太菜了。</p><p>随便乱胡一下，发现就是把若干条线段陈列到两个上下对齐、长度为 <span class="math inline">\(n\div 2\)</span> 的盒子里。容易想到哪边更空放哪边的贪心策略，当最后还剩一条线段的时候，两个盒子都会剩下一截。</p><p>如果直接塞进去肯定是非法的，这个时候想到把下面的这一节放到下面盒子的开头，其他的依次后移即可。由于重心的每个儿子大小不超过盒子长度，所以移了之后肯定不重合。且容易发现只会换行一次。</p><p>感觉自己似乎有些倾向于这种模型？（突然想起自己在幼年时期也在某题中抽象出这个模型，试图给幼年时期的高手传教然后由于语言能力太弱失败了！）</p><details><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;int main() &#123;#ifdef ONLINE_JUDGE    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr), std::cout.tie(nullptr);#else    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);#endif    int n;    std::cin &gt;&gt; n;    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);    for (int i = 1, x, y; i &lt; n; ++i) &#123;        std::cin &gt;&gt; x &gt;&gt; y;        g[x].push_back(y), g[y].push_back(x);    &#125;    std::vector&lt;int&gt; siz(n + 1);    int rt = 0;    std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int fa) &#123;        siz[x] = 1;        bool flag = 1;        for (auto i : g[x])            if (i != fa) &#123;                DFS(i, x);                siz[x] += siz[i];                if (siz[i] &gt; n / 2)                    flag = 0;            &#125;        if (flag &amp;&amp; n - siz[x] &lt;= n / 2)            rt = x;        return;    &#125;;    DFS(1, -1);    std::vector&lt;std::vector&lt;int&gt; &gt; t(n + 1);    for (auto i : g[rt]) &#123;        DFS = [&amp;](int x, int fa) &#123;            t[i].push_back(x);            for (auto i : g[x])                if (i != fa)                    DFS(i, x);            return;        &#125;;        DFS(i, rt);    &#125;    std::deque&lt;int&gt; p1, p2;    int to = n / 2;    for (auto i : g[rt]) &#123;        auto &amp;q1 = (p1.size() &gt; p2.size() ? p2 : p1), &amp;q2 = (p1.size() &gt; p2.size() ? p1 : p2);        for (; !t[i].empty() &amp;&amp; (int)q1.size() &lt; to; q1.push_back(t[i].back()), t[i].pop_back());        for (; !t[i].empty() &amp;&amp; (int)q2.size() &lt; to; q2.push_front(t[i].back()), t[i].pop_back());    &#125;    if (n % 2 == 0)        (p1.size() &lt; p2.size() ? p1 : p2).push_back(rt);    for (; to--; ) &#123;        std::cout &lt;&lt; p1.back() &lt;&lt; &#39; &#39; &lt;&lt; p2.back() &lt;&lt; &#39;\n&#39;;        p1.pop_back(), p2.pop_back();    &#125;    return 0;&#125;</code></pre></details><hr /><h2 id="b---miracle-tree">B - ⭐ Miracle Tree</h2><p><a href="https://atcoder.jp/contests/arc117/tasks/arc117_d" class="uri">https://atcoder.jp/contests/arc117/tasks/arc117_d</a></p><blockquote><p>⭐ <strong>不等式相关推理</strong></p><p>给定一棵大小为 <span class="math inline">\(n\)</span> 的树，边权为 <span class="math inline">\(1\)</span>，给每个点 <span class="math inline">\(u\)</span> 指定正整数点权 <span class="math inline">\(E(u)\)</span>，满足 <span class="math inline">\(\forall \,u,v,|E(u)-E(v)|\ge d(u,v)\)</span>。最小化点权最大值。</p><p><span class="math inline">\(n\le 2\times 10^5\)</span>。</p></blockquote><p>容易发现任取 <span class="math inline">\(a,b,c\)</span> 三点，由于它们之间只有一条简单路径，可以视为一条线段，即退化的三角形。那么由三角形三边关系，任取两边之和都大于等于第三边。</p><p>不妨令 <span class="math inline">\(E(a)&gt;E(b)&gt;E(c)\)</span>，以 <span class="math inline">\(d(b,a)+d(b,c)\ge d(a,c)\)</span> 举例，有 <span class="math inline">\(E(a)-E(b)+E(b)-E(c)\ge d(a,c)\)</span> 成立；即，若 <span class="math inline">\((b,a)\)</span> 和 <span class="math inline">\((b,c)\)</span> 分别已经找到可行解，则 <span class="math inline">\((a,c)\)</span> 合法。</p><p>从而推断出，按点权将所有点从小到大排序后，只需让任意相邻两点合法，则全树合法。易发现答案是所有相邻两点 <span class="math inline">\(dis\)</span> 之和；也即，从任意一点出发，经过全树所有点的路径和。这种问题我们很熟悉，由欧拉序可知是从 <span class="math inline">\(2(n-1)\)</span> 个 <span class="math inline">\(w\)</span> 中抠走一段路径长（终点到起点）。想要最小化答案就要最大化这段路径长，取直径即可。</p><p>最后的答案序列按照欧拉序直接求即可（注意直径的端点要在序列两端），实现上应该可以有一些 <span class="math inline">\(O(n)\)</span> 小巧思。</p><details><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;int main() &#123;#ifdef ONLINE_JUDGE    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr), std::cout.tie(nullptr);#else    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);#endif    int n;    std::cin &gt;&gt; n;    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);    for (int i = 1, x, y; i &lt; n; ++i) &#123;        std::cin &gt;&gt; x &gt;&gt; y;        g[x].push_back(y), g[y].push_back(x);    &#125;    std::vector&lt;int&gt; dep(n + 1);    std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int fa) &#123;        for (auto i : g[x])            if (i != fa) &#123;                dep[i] = dep[x] + 1;                DFS(i, x);            &#125;        return;    &#125;;    dep[1] = 1, DFS(1, -1);    int p = std::max_element(dep.begin() + 1, dep.end()) - dep.begin();    dep[p] = 1, DFS(p, -1);    int q = std::max_element(dep.begin() + 1, dep.end()) - dep.begin();    std::vector&lt;int&gt; tag(n + 1);    std::function&lt;bool(int, int)&gt; DFS1 = [&amp;](int x, int fa) &#123;        if (x == q) &#123;            tag[x] = 1;            return true;        &#125;        for (auto i : g[x])            if (i != fa &amp;&amp; DFS1(i, x)) &#123;                tag[x] = 1;                return true;            &#125;        return false;    &#125;;    DFS1(p, -1);    std::vector&lt;int&gt; res(n + 1);    DFS = [&amp;](int x, int fa) &#123;        static int now = 1;        int son = 0;        if (x != p)            res[x] = now;        for (auto i : g[x])            if (i != fa) &#123;                if (tag[i])                    son = i;                else                    ++now, DFS(i, x), ++now;            &#125;        if (son)            ++now, DFS(son, x); // 回不来了，故可以不加 ;-)        return;    &#125;;    res[p] = 1, DFS(p, -1);    for (int i = 1; i &lt;= n; ++i)        std::cout &lt;&lt; res[i] &lt;&lt; &#39; &#39;;    std::cout &lt;&lt; &#39;\n&#39;;    return 0;&#125;</code></pre></details><hr /><h2 id="c---树的计数">C - 树的计数</h2><p><a href="https://www.luogu.com.cn/problem/P1232" class="uri">https://www.luogu.com.cn/problem/P1232</a></p><p>需要意识到 DFS 和 BFS 地位是不等价的：二者都有自己相应的性质，但 BFS 的深度性质更易于上手。</p><p>不妨进行重标号，令 BFS 序为 <span class="math inline">\(1\sim n\)</span>。可以在 BFS 中不断进行『分层』得到点的深度信息。发现 <span class="math inline">\(1\)</span> 后必须分割一次，除此之外没有 BFS 序本身带来的限制。考虑 DFS 序对深度带来的额外限制：</p><ul><li>对于 <span class="math inline">\(D_i\)</span> 和 <span class="math inline">\(D_{i+1}\)</span>，则 <span class="math inline">\(D_{i+1}\)</span> 的插入位点位于 <span class="math inline">\(1\sim D_i\)</span> 的链上，则 <span class="math inline">\(dep_{D_{i+1}}\le dep_{D_i}+1\)</span>，即 BFS 序中，<span class="math inline">\([D_i,D_{i+1})\)</span> 间有至多一个分段点。</li><li>虽然题面没说，但是这里 BFS 和 DFS 遍历儿子的顺序是相同的；由于在 BFS 序中 <span class="math inline">\(i\)</span> 先于 <span class="math inline">\(i+1\)</span> 被遍历，（由于 <span class="math inline">\(dep_i\le dep_{i+1}\le dep_i+1\)</span>），故而若 <span class="math inline">\(dep_i= dep_{i+1}\)</span>，则 DFS 先遍历 <span class="math inline">\(i\)</span>；反之，若 DFS 序中 <span class="math inline">\(i+1\)</span> 早于 <span class="math inline">\(i\)</span> 出现，BFS 序中 <span class="math inline">\(i\)</span> 处必须分层。</li></ul><p>则得到若干条限制，形如某处必须断、某区间必须恰好断一次之类。发现比较难处理的是区间内没有要求『某个点必须断』的情况；<del>可以差分约束</del> 惊讶地发现，这种情况下有 <span class="math inline">\(D_{i+1}=D_i+1\)</span>（可以考察第一个满足 <span class="math inline">\(D_i\ne i\)</span> 的点来思考）。这点其实是比较难论证的，所以我也没有想得很清楚；好在信息也不是很要求证明这一块就是了。</p><p>用差分处理『恰好一次』的限制，标记某些点不能断。初始高度为 <span class="math inline">\(1\)</span>；每次『必须分段』会带来 <span class="math inline">\(1\)</span> 的高度；每次『可能分段』会带来 <span class="math inline">\(0.5\)</span> 的高度。加起来就可以了。</p><details><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;int main() &#123;#ifdef ONLINE_JUDGE    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr), std::cout.tie(nullptr);#else    std::freopen(&quot;P1232_2.in&quot;, &quot;r&quot;, stdin);    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);#endif    int n;    std::cin &gt;&gt; n;    std::vector&lt;int&gt; d(n + 1), b(n + 1), p(n + 1);    for (int i = 1; i &lt;= n; ++i)        std::cin &gt;&gt; d[i];    for (int i = 1; i &lt;= n; ++i)        std::cin &gt;&gt; b[i], p[b[i]] = i;    for (int i = 1; i &lt;= n; ++i)        d[i] = p[d[i]];    for (int i = 1; i &lt;= n; ++i)        p[d[i]] = i;    int res = 4;    std::vector&lt;int&gt; tag(n + 1), forbid(n + 1);    for (int i = 2; i &lt; n; ++i)        if (p[i + 1] &lt; p[i])            tag[i] = 1;    std::partial_sum(tag.begin() + 1, tag.end(), tag.begin() + 1);    for (int i = 2; i &lt; n; ++i)        if (d[i + 1] &gt; d[i] &amp;&amp; tag[d[i + 1] - 1] - tag[d[i] - 1]) &#123;            // fprintf(stderr, &quot;forbid [%d, %d)\n&quot;, d[i], d[i + 1]);            forbid[d[i]] += 1, forbid[d[i + 1]] -= 1;        &#125;    std::partial_sum(forbid.begin() + 1, forbid.end(), forbid.begin() + 1);    for (int i = 2; i &lt; n; ++i)        if (p[i] &gt; p[i + 1])            res += 2;        else if (!forbid[i] &amp;&amp; p[i + 1] == p[i] + 1)            res += 1;    std::cout &lt;&lt; res / 2;    if (res &amp; 1)        std::cout &lt;&lt; &quot;.500&quot;;    else        std::cout &lt;&lt; &quot;.000&quot;;    std::cout &lt;&lt; &#39;\n&#39;;    return 0;&#125;</code></pre></details><hr /><h2 id="d---alice-and-bob">D - Alice and Bob</h2><p><a href="https://www.luogu.com.cn/problem/P3971" class="uri">https://www.luogu.com.cn/problem/P3971</a></p><p>远离假结论天坑笛卡尔树。如果觉得一个题是一个显然的简单笛卡尔树，那么大概率伪证。</p><p><span class="math inline">\(a=\{1,2,1,3,3,4\},x=\{2,3,1,5,4,6\}\)</span> 可以 hack 掉基于『左侧祖先数量』的笛卡尔树。</p><p>但是可以从 BST 入手思考。显然 <span class="math inline">\(a_i\)</span> 和 <span class="math inline">\(b_i\)</span> 都和顺序 / 位置有关；所以可以从 <span class="math inline">\(1\sim n\)</span> 依次把点加入 BST。发现 <span class="math inline">\(a_i\)</span> 的值是右拐的次数 <span class="math inline">\(+1\)</span>。会发现 <span class="math inline">\(x\)</span> 是有多解的，因为只对右拐的次数作出了限制。为了尽可能地构造出合法解，即最大化每次加入的成功率，猜一个先向右走到需要的地方、再向左走到底的策略，发现看起来挺对的。维护全树最右边一条链和这条链上每个点最左的叶子就可以 <span class="math inline">\(O(n)\)</span> 构造。</p><p><span class="math inline">\(b_i\)</span> 的值没办法直接在这个树上求（因为顺序不对），所以可以从 BST 还原出一个合法序列后反过来构造找答案。我不会线性，所以直接线段树维护了。</p><p>好像不是最优，有点完蛋。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>练习 树的各种性质 I</title>
      <link href="/20250716/"/>
      <url>/20250716/</url>
      
        <content type="html"><![CDATA[<p>这不比斜优做着爽。</p><span id="more"></span><hr /><h2 id="a---tree">A - Tr/ee</h2><p><a href="https://atcoder.jp/contests/arc103/tasks/arc103_c" class="uri">https://atcoder.jp/contests/arc103/tasks/arc103_c</a></p><p>可以发现，类似删边的问题，删出来的连通块当中，靠下的是一个完整的子树；就可以转化为子树问题了。</p><p>容易想到枚举 <span class="math inline">\(i-1\)</span> 时树的状态，尝试转化为 <span class="math inline">\(i\)</span> 时的状态；进一步可以胡出来一堆方案（大概），这里我胡的是，初始设置一个单点，<span class="math inline">\(0\to 1\)</span> 啥也不干，<span class="math inline">\(0\to 0\)</span> 在当前根上再加一个叶子，<span class="math inline">\(1\to 0\)</span> 新建一个带叶子的根并令其成为当前根的父亲，<span class="math inline">\(1\to 1\)</span> 加一个父亲。</p><p>然后特判一下 <span class="math inline">\(s_1=0\)</span> 和 <span class="math inline">\(s_n=1\)</span> 和 <span class="math inline">\(s_i\ne s_{n-i}\)</span> 的情况，发现其他时候都有解。</p><details><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;int main() &#123;#ifdef ONLINE_JUDGE    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr), std::cout.tie(nullptr);#else    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);#endif    int n;    std::string s;    std::cin &gt;&gt; s, n = (int)s.length();    s = &quot;#&quot; + s;    if (s[1] == &#39;0&#39; || s[n] == &#39;1&#39;) &#123;        std::cout &lt;&lt; -1 &lt;&lt; &#39;\n&#39;;        return 0;    &#125;    for (int i = 1; i &lt; n; ++i)        if (s[i] != s[n - i]) &#123;            std::cout &lt;&lt; -1 &lt;&lt; &#39;\n&#39;;            return 0;        &#125;    int tot = 1, rt = 1;    for (int i = 2; i &lt; n; ++i) &#123;        if (tot == i - 1) &#123;            if (s[i] == &#39;0&#39;) &#123;                std::cout &lt;&lt; rt &lt;&lt; &#39; &#39; &lt;&lt; ++tot &lt;&lt; &#39;\n&#39;;                rt = tot;                std::cout &lt;&lt; rt &lt;&lt; &#39; &#39; &lt;&lt; ++tot &lt;&lt; &#39;\n&#39;;            &#125;            else &#123;                std::cout &lt;&lt; rt &lt;&lt; &#39; &#39; &lt;&lt; ++tot &lt;&lt; &#39;\n&#39;;                rt = tot;            &#125;        &#125;        else if (s[i] == &#39;0&#39;)            std::cout &lt;&lt; rt &lt;&lt; &#39; &#39; &lt;&lt; ++tot &lt;&lt; &#39;\n&#39;;    &#125;    if (tot != n)        std::cout &lt;&lt; rt &lt;&lt; &#39; &#39; &lt;&lt; n &lt;&lt; &#39;\n&#39;;    return 0;&#125;</code></pre></details><hr /><h2 id="b---keep-perfectly-matched">B - ⭐ Keep Perfectly Matched</h2><p><a href="https://atcoder.jp/contests/arc183/tasks/arc183_d" class="uri">https://atcoder.jp/contests/arc183/tasks/arc183_d</a></p><blockquote><p>⭐ <strong>奇偶性、重心的分析</strong></p><p>给定大小为 <span class="math inline">\(2n\)</span> 的树，定义完美匹配为，在树上选 <span class="math inline">\(n\)</span> 条边，满足每个点被覆盖恰好一次。</p><p>保证初始存在完美匹配，接下来你需要进行 <span class="math inline">\(n\)</span> 次操作，每次删掉两个叶子，保证删完之后仍存在完美匹配，最大化每次删掉的两个点的距离之和。输出每次删除的点。</p><p><span class="math inline">\(2n\le 2.5\times 10^5\)</span>。</p></blockquote><p>发现这个『完美匹配』就是在树上给每个点找相邻点配对，看看能不能配上；继而发现由于点的总数为偶，一个点有且仅能有一个 siz 为奇的子树（不然非法），再发现对于任意一个点，删掉的点对要么来自其同一个子树；要么一个来自其奇子树，另一个来自其偶子树。</p><p>发现要求最大化距离，又只能删叶子，所以需要最小化 LCA 深度；有没有办法让每次的 LCA 都是根呢？让重心成为根，并保证每次操作的两个点都不来自同一个儿子即可（显然这样是完全可能的）。</p><p>接着写了一发发现过不了样例，原因是发现在偶子树中会出现『一个中途的节点本来有一个奇儿子，删去偶子树中的一个叶子后非法』的情况。显然这样的节点是一个偶儿子。确保每个偶儿子的奇儿子先被删掉就可以解决问题。</p><p>对重心的每个儿子，提前规划其节点被删除的顺序即可。</p><details><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;int main() &#123;#ifdef ONLINE_JUDGE    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr), std::cout.tie(nullptr);#else    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);#endif    int n;    std::cin &gt;&gt; n;    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);    for (int i = 1, x, y; i &lt; n; ++i) &#123;        std::cin &gt;&gt; x &gt;&gt; y;        g[x].push_back(y), g[y].push_back(x);    &#125;    std::vector&lt;int&gt; siz(n + 1);    int rt = 0;    std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int fa) &#123;        siz[x] = 1;        bool flag = 1;        for (auto i : g[x])            if (i != fa) &#123;                DFS(i, x);                siz[x] += siz[i];                if (siz[i] &gt; n / 2)                    flag = 0;            &#125;        if (flag &amp;&amp; n - siz[x] &lt;= n / 2)            rt = x;        return;    &#125;;    DFS(1, -1);    std::vector&lt;std::vector&lt;int&gt; &gt; lf(n + 1);    int f1 = -1;    auto comp = [&amp;](int i, int j) &#123; return siz[i] &lt; siz[j]; &#125;;    std::priority_queue&lt;int, std::vector&lt;int&gt;, decltype(comp)&gt; f0(comp);    siz.assign(n + 1, 0);    for (auto t : g[rt]) &#123;        DFS = [&amp;](int x, int fa) &#123;            siz[x] = 1;            for (auto i : g[x])                if (i != fa) &#123;                    DFS(i, x);                    siz[x] += siz[i];                &#125;            return;        &#125;;        DFS(t, rt);        DFS = [&amp;](int x, int fa) &#123;            if (siz[x] % 2 == 0) &#123;                for (auto i : g[x])                    if (i != fa &amp;&amp; siz[x] % 2 == 1)                        DFS(i, x);                for (auto i : g[x])                    if (i != fa &amp;&amp; siz[x] % 2 == 0)                        DFS(i, x);            &#125;            else                for (auto i : g[x])                    if (i != fa)                        DFS(i, x);            lf[t].push_back(x);            return;        &#125;;        DFS(t, rt);        if (siz[t] &amp; 1)            assert(f1 == -1), f1 = t;        else            f0.push(t);        std::reverse(lf[t].begin(), lf[t].end());    &#125;    fprintf(stderr, &quot;rt = %d\n&quot;, rt);    assert(~f1);    for (int _ = n / 2; _--; ) &#123;        assert(~f1);        if (!_ &amp;&amp; f0.empty()) &#123;            std::cout &lt;&lt; f1 &lt;&lt; &#39; &#39; &lt;&lt; rt &lt;&lt; &#39;\n&#39;;            break;        &#125;        assert(!f0.empty());        int t = f0.top();        f0.pop();        assert(!lf[f1].empty());        assert(!lf[t].empty());        std::cout &lt;&lt; lf[f1].back() &lt;&lt; &#39; &#39; &lt;&lt; lf[t].back() &lt;&lt; &#39;\n&#39;;        lf[f1].pop_back(), --siz[f1];        lf[t].pop_back(), --siz[t];        if (siz[f1])            f0.push(f1);        f1 = t;    &#125;    return 0;&#125;</code></pre></details><hr /><h2 id="c---fiolki">C - Fiolki</h2><p><a href="https://www.luogu.com.cn/problem/P5578" class="uri">https://www.luogu.com.cn/problem/P5578</a></p><p>难点在于判断每一步有哪些反应发生；显然一个反应只会在某一步发生。</p><p>发现将倒水的操作视为连边 <span class="math inline">\(b_i\to a_i\)</span>，那么形成了森林，把每个反应丢到 LCA 处等待 check。</p><p>发现在 LCA 之外，两种试剂不可能相遇；故最后遍历一遍反应序列，维护每种药水当前数量，在每个点处 check 即可。</p><p>再发现如果每次加边都在父亲处 check 所有可能发生的反应，复杂度肯定是错的；故用倍增求出两个点在 LCA 下方的点作为『检查点』，当『检查点』被合并到其父亲时，就可以 check 一下检查点上面挂的所有询问。显然每个点上的询问只会被检查一次；复杂度线性。</p><p>加上倍增 LCA 的复杂度，就可以 <span class="math inline">\(O(n\log n)\)</span> 地完成。</p><details><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;int main() &#123;#ifdef ONLINE_JUDGE    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr), std::cout.tie(nullptr);#else    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);#endif    int n, m, k;    std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);    std::vector&lt;int&gt; f(n + 1), deg(n + 1), now(n + 1);    for (int i = 1; i &lt;= n; ++i)        std::cin &gt;&gt; now[i];    std::iota(f.begin() + 1, f.end(), 1);    std::function&lt;int(int)&gt; find = [&amp;](int x) &#123;        return x == f[x] ? x : f[x] = find(f[x]);    &#125;;    auto merge = [&amp;](int x, int y) &#123;        f[find(x)] = find(y);        return;    &#125;;    std::vector&lt;std::pair&lt;int, int&gt; &gt; a(m + 1);    for (int i = 1; i &lt;= m; ++i) &#123;        auto &amp;[x, y] = a[i];        std::cin &gt;&gt; x &gt;&gt; y, ++deg[x];        g[y].push_back(x), merge(x, y);    &#125;    std::vector&lt;int&gt; dep(n + 1);    std::vector&lt;std::vector&lt;int&gt; &gt; fa(n + 1, std::vector&lt;int&gt; (21));    for (int i = 1; i &lt;= n; ++i)        if (!deg[i]) &#123;            std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;                for (auto i : g[x]) &#123;                    fa[i][0] = x;                    for (int j = 1; j &lt;= 20; ++j)                        fa[i][j] = fa[fa[i][j - 1]][j - 1];                    dep[i] = dep[x] + 1, DFS(i);                &#125;                return;            &#125;;            dep[i] = 1, DFS(i);        &#125;    std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; t(n + 1);    for (int x, y; k--; ) &#123;        std::cin &gt;&gt; x &gt;&gt; y;        if (find(x) == find(y)) &#123;            std::pair&lt;int, int&gt; p(x, y);            if (dep[x] != dep[y]) &#123;                if (dep[x] &lt; dep[y])                    std::swap(x, y);                for (int i = 20; ~i; --i)                    if (dep[fa[x][i]] &gt; dep[y])                        x = fa[x][i];                if (fa[x][0] == y) &#123;                    t[x].push_back(p);                    // printf(&quot;add (%d, %d) to %d\n&quot;, p.first, p.second, x);                    continue;                &#125;                x = fa[x][0];            &#125;            for (int i = 20; ~i; --i)                if (fa[x][i] != fa[y][i])                    x = fa[x][i], y = fa[y][i];            t[x].push_back(p), t[y].push_back(p);        &#125;    &#125;    std::iota(f.begin() + 1, f.end(), 1);    auto res(0ll);    for (int i = 1; i &lt;= m; ++i) &#123;        auto [x, y] = a[i];        merge(x, y);        for (auto [p, q] : t[x])            if (find(p) == find(x) &amp;&amp; find(q) == find(x)) &#123;                int u = std::min(now[p], now[q]);                res += 2 * u, now[p] -= u, now[q] -= u;            &#125;    &#125;    std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;    return 0;&#125; </code></pre></details><hr /><h2 id="d---permutation-tree">D - Permutation Tree</h2><p><a href="https://atcoder.jp/contests/arc095/tasks/arc095_d" class="uri">https://atcoder.jp/contests/arc095/tasks/arc095_d</a></p><p>随便画图，会发现，如果按层数从小到大标号，一个点的儿子只有最多一个不是叶子。一言以蔽之：毛毛虫。</p><p>然后就可以判断可行性了（直径就是虫身）。接下来需要考虑最小化答案字典序的问题，发现对于一个点的儿子，必须是虫足在其左、虫身在其右且必须严格按照层数标号。</p><p>字典序是个偏贪心的东西，所以可以开始瞎搞：发现虫足越多，标号更小的父亲就会越靠后，所以依次比较用两端开头的情况，如果到了虫身的某一段，哪种的儿子更少就选谁，然后直接按最小来标号即可。</p><p>实际上由于只有两种方案，你也可以两边都试试（）</p><details><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;int main() &#123;#ifdef ONLINE_JUDGE    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr), std::cout.tie(nullptr);#else    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);#endif    int n;    std::cin &gt;&gt; n;    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);    for (int i = 1, x, y; i &lt; n; ++i) &#123;        std::cin &gt;&gt; x &gt;&gt; y;        g[x].push_back(y), g[y].push_back(x);    &#125;    std::vector&lt;int&gt; dep(n + 1);    std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int fa) &#123;        for (auto i : g[x])            if (i != fa) &#123;                dep[i] = dep[x] + 1;                DFS(i, x);            &#125;        return;    &#125;;    dep[1] = 1, DFS(1, -1);    int p = std::max_element(dep.begin() + 1, dep.end()) - dep.begin();    bool flag = 0;    std::vector&lt;int&gt; node, cnt(n + 1), siz(n + 1);    DFS = [&amp;](int x, int fa) &#123;        siz[x] = 1;        for (auto i : g[x])            if (i != fa) &#123;                DFS(i, x);                siz[x] += siz[i], ++cnt[x];            &#125;        if (siz[x] &gt; 1) &#123;            node.push_back(0), --cnt[x];            for (auto i : g[x]) &#123;                if (i != fa &amp;&amp; siz[node.back()] &gt; 1 &amp;&amp; siz[i] &gt; 1)                    flag = 1;                if (i != fa &amp;&amp; siz[i] &gt; siz[node.back()])                    node.back() = i;            &#125;        &#125;        return;    &#125;;    DFS(p, -1), node.push_back(p);    if (flag) &#123;        std::cout &lt;&lt; -1 &lt;&lt; &#39;\n&#39;;        return 0;    &#125;    for (int i = 0, j = (int)node.size() - 1; i &lt;= j; ++i, --j)        if (cnt[node[i]] &gt; cnt[node[j]]) &#123;            std::reverse(node.begin(), node.end());            break;        &#125;        else if (cnt[node[i]] &lt; cnt[node[j]])            break;    int now = 0;    for (auto i : node) &#123;        int rt = ++now;        for (; cnt[i]--; std::cout &lt;&lt; ++now &lt;&lt; &#39; &#39;);        std::cout &lt;&lt; rt &lt;&lt; &#39; &#39;;    &#125;    std::cout &lt;&lt; &#39;\n&#39;;    return 0;&#125;</code></pre></details><hr /><h2 id="e---isomorphism-freak">E - Isomorphism Freak</h2><p><a href="https://atcoder.jp/contests/agc024/tasks/agc024_d" class="uri">https://atcoder.jp/contests/agc024/tasks/agc024_d</a></p><p><del>像在数有多少种化学环境的 H 是可以说的吗</del></p><p>鉴于这个，高中化学选择性必修三，给我们打下的坚实基础，我们可以非常迅速地注意到答案就是半径长。</p><p>然后最少叶子，发现一眼瞪不出来，糟糕！没关系，观察样例输出，发现这些答案的因数都挺多，故猜测是若干个数乘起来的；然后再发现是每层最大儿子数的乘积。</p><p>枚举中间的边（仅当直径长度为偶时）、点（奇偶都行）作为对称轴 / 对称中心的情况取 min 即可（原因是要尽量取靠近中心的 <strong>点</strong>），注意边两端算两个儿子数。</p><p><del>所以为啥 <span class="math inline">\(n\)</span> 这么小</del></p><details><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;const long long inf = 1e18;int main() &#123;#ifdef ONLINE_JUDGE    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr), std::cout.tie(nullptr);#else    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);#endif    int n;    std::cin &gt;&gt; n;    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);    for (int i = 1, x, y; i &lt; n; ++i) &#123;        std::cin &gt;&gt; x &gt;&gt; y;        g[x].push_back(y), g[y].push_back(x);    &#125;    std::vector&lt;int&gt; dep(n + 1);    std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int fa) &#123;        for (auto i : g[x])        if (i != fa) &#123;            dep[i] = dep[x] + 1;            DFS(i, x);        &#125;        return;    &#125;;    dep[1] = 1, DFS(1, -1);    int p = std::max_element(dep.begin() + 1, dep.end()) - dep.begin();    dep[p] = 1, DFS(p, -1);    int q = std::max_element(dep.begin() + 1, dep.end()) - dep.begin();    std::cout &lt;&lt; (dep[q] + 1) / 2 &lt;&lt; &#39; &#39;;    std::vector&lt;int&gt; node;    std::vector&lt;std::pair&lt;int, int&gt; &gt; edge;    if (dep[q] &amp; 1) &#123;        DFS = [&amp;](int x, int fa) &#123;            for (auto i : g[x])                if (i != fa)                    DFS(i, x);            if (dep[x] == (dep[q] + 1) / 2)                node.push_back(x), edge.emplace_back(x, fa);            if (dep[x] == (dep[q] + 1) / 2 + 1)                edge.emplace_back(x, fa);            return;        &#125;;        DFS(p, -1);    &#125;    else &#123;        std::function&lt;bool(int, int)&gt; DFS = [&amp;](int x, int fa) &#123;            if (x == q)                return true;            bool ret = false;            for (auto i : g[x])                if (i != fa)                    ret |= DFS(i, x);            if (ret &amp;&amp; dep[x] == dep[q] / 2 + 1)                edge.emplace_back(x, fa);            return ret;        &#125;;        DFS(p, -1);    &#125;    long long res = inf;    for (auto [x, y] : edge) &#123;        std::vector&lt;int&gt; cnt(n + 1);        std::function&lt;void(int, int, int)&gt; DFS = [&amp;](int x, int fa, int dep) &#123;            int son = 0;            for (auto i : g[x])                if (i != fa)                    ++son, DFS(i, x, dep + 1);            cnt[dep] = std::max(cnt[dep], son);            return;        &#125;;        DFS(x, y, 1), DFS(y, x, 1);        auto now(2ll);        for (int i = 1; i &lt;= n &amp;&amp; cnt[i]; ++i)            now *= cnt[i];        res = std::min(res, now);    &#125;    for (auto rt : node) &#123;        std::vector&lt;int&gt; cnt(n + 1);        std::function&lt;void(int, int, int)&gt; DFS = [&amp;](int x, int fa, int dep) &#123;            int son = 0;            for (auto i : g[x])                if (i != fa)                    ++son, DFS(i, x, dep + 1);            cnt[dep] = std::max(cnt[dep], son);            return;        &#125;;        DFS(rt, -1, 1);        auto now(1ll);        for (int i = 1; i &lt;= n &amp;&amp; cnt[i]; ++i)            now *= cnt[i];        res = std::min(res, now);    &#125;    std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;    return 0;&#125;</code></pre></details>]]></content>
      
      
      
        <tags>
            
            <tag> 思维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>练习 决策单调性</title>
      <link href="/20250715/"/>
      <url>/20250715/</url>
      
        <content type="html"><![CDATA[<p>『心静自然凉』大抵是因为情绪平和时副交感神经兴奋，体温略有降低导致的。吗？</p><span id="more"></span><p>其实是因为心脏停跳后血液循环终止、代谢中断，导致产热低于散热（？）</p><hr /><h2 id="a---征途">A - 征途</h2><p><a href="https://www.luogu.com.cn/problem/P4072" class="uri">https://www.luogu.com.cn/problem/P4072</a></p><p>用完全平方公式展开得到 <span class="math inline">\(m^2\sigma^2=m\left(\sum {x_i}^2\right)-S^2\)</span>，其中 <span class="math inline">\(S\)</span> 为求和。</p><p>所以目标是最小化 <span class="math inline">\(\sum {x_i}^2\)</span> 这个东西。令 <span class="math inline">\(f_{i,j}\)</span> 表示第 <span class="math inline">\(i\)</span> 天走到 <span class="math inline">\(j\)</span>，得到：</p><p><span class="math display">\[\begin{aligned}f_{i,j}&amp;=\min\{f_{i-1,k}+(s_j-s_k)^2\}\\&amp;=\min\{f_{i-1,k}-2\times s_j\times s_k+{s_k}^2\}+{s_j}^2\end{aligned}\]</span></p><p>最后得到的斜率式子是 <span class="math inline">\(\dfrac {f_{i - 1, a}-f_{i - 1, b}+{s_a}^2-{s_b}^2}{2(s_a-s_b)}&lt;s_j\)</span>，由于 <span class="math inline">\(s_j\)</span> 单增，<del>单调队列维护递减斜率即可</del> <strong>更正：是递增斜率。原因是 <span class="math inline">\(&lt;\)</span> 是弹出条件，而非保留条件……</strong></p><details><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;const long long inf = 1e9;int main() &#123;#ifdef ONLINE_JUDGE    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr), std::cout.tie(nullptr);#else    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);#endif    int n, m;    std::cin &gt;&gt; n &gt;&gt; m;    std::vector&lt;int&gt; a(n + 1);    std::vector&lt;long long&gt; s(n + 1);    auto sum(0ll);    for (int i = 1; i &lt;= n; ++i) &#123;        std::cin &gt;&gt; a[i];        s[i] = s[i - 1] + a[i];        sum += a[i];    &#125;    std::vector&lt;std::vector&lt;long long&gt; &gt; f(m + 1, std::vector&lt;long long&gt; (n + 1, inf));    f[0][0] = 0ll;    for (int i = 1; i &lt;= m; ++i) &#123;        auto f1 = [&amp;](int a, int b) &#123;            return f[i - 1][a] - f[i - 1][b] + s[a] * s[a] - s[b] * s[b];        &#125;;        auto f2 = [&amp;](int a, int b) &#123;            return 2 * (s[a] - s[b]);        &#125;;        std::vector&lt;int&gt; q(n + 1);        int h = 0, t = -1;        q[++t] = i - 1;        for (int j = i; j &lt;= n; ++j) &#123;            for (; h &lt; t &amp;&amp; f1(q[h + 1], q[h]) &lt; s[j] * f2(q[h + 1], q[h]); ++h);            f[i][j] = f[i - 1][q[h]] + (s[j] - s[q[h]]) * (s[j] - s[q[h]]);            for (; h &lt; t &amp;&amp; f1(j, q[t]) * f2(q[t], q[t - 1]) &lt; f1(q[t], q[t - 1]) * f2(j, q[t]); --t);            q[++t] = j;        &#125;    &#125;    std::cout &lt;&lt; m * f[m][n] - sum * sum &lt;&lt; &#39;\n&#39;;    return 0;&#125;</code></pre></details><hr /><h2 id="b---刷野-iii">B - ⭐ 刷野 III</h2><p><a href="https://www.luogu.com.cn/problem/P10074" class="uri">https://www.luogu.com.cn/problem/P10074</a></p><blockquote><p>⭐ <strong>抽象问题的 DP 式</strong></p><p>已知怪物的血量是一个长度为 <span class="math inline">\(n\)</span> 的序列的 random_shuffle；你的 ATK 为 <span class="math inline">\(1\)</span>，需要击杀 <span class="math inline">\(m\)</span> 只怪物，找到一种策略，最小化最劣情况下的攻击次数，求该次数。</p><p>例：若血量序列为 <span class="math inline">\(\{10,15\}\)</span>，<span class="math inline">\(m=1\)</span>，答案为 <span class="math inline">\(15\)</span>；若序列为 <span class="math inline">\(\{10,30\}\)</span>，<span class="math inline">\(m=1\)</span>，答案为 <span class="math inline">\(20\)</span>。</p><p><span class="math inline">\(n\le 2000\)</span>。</p></blockquote><p>发现最坏情况就是每次『试探』都不中的情况，再试探中最坏的那一个。为啥呢，相当于我们每次攻击的一定是未知元素中血最多的一个。既然已经试探出了比阈值大的所有元素，那么下一个攻击的就一定是阈值本身，如果这次跳过它，它就会成为下一次试探失败的元素。这显然不如一开始就直接用新阈值试探。</p><p>从大到小排序。令 <span class="math inline">\(f_{j, i}\)</span> 表示只确定了前 <span class="math inline">\(i\)</span> 大的数，已经杀了 <span class="math inline">\(j\)</span> 个人的最坏情况最小代价。那么显然这一次的阈值是 <span class="math inline">\(a_i\)</span>。随便选出上一次的阈值 <span class="math inline">\(a_k\)</span>，那么中间这一段待确定的元素数量为 <span class="math inline">\(i-k\)</span>。那么有：</p><p><span class="math display">\[\begin{aligned}f_{j, i}&amp;=\min\limits_{k&lt;i}\{f_{j-1,k}+(i-k)\times a_i\}\\&amp;=\min\limits_{k&lt;i}\{f_{j-1,k}-k\times a_i\}+i\times a_i\end{aligned}\]</span></p><p>经过验证，虽然这个式子和题解长得不一样，但是是对的 <del>因为我 n^3 暴力 A 了</del></p><p>推出斜优形式 <span class="math inline">\(\dfrac {f_{j-1,A}-f_{j-1,B}}{A-B}&lt;a_i\)</span>，但我的朋友，<span class="math inline">\(a_i\)</span> 是递减的。所以用单调栈维护递增斜率即可。<del>或者你也可以学习 grisses 打一个单调队列上二分</del></p><details><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;const long long inf = 1e12;int main() &#123;#ifdef ONLINE_JUDGE    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr), std::cout.tie(nullptr);#else    std::freopen(&quot;P10074_4.in&quot;, &quot;r&quot;, stdin);    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);#endif    int n, m;    std::cin &gt;&gt; n &gt;&gt; m;    std::vector&lt;long long&gt; a(n + 1);    for (int i = 1; i &lt;= n; ++i)        std::cin &gt;&gt; a[i];    std::sort(a.begin() + 1, a.end(), std::greater&lt;long long&gt; ());    std::vector&lt;std::vector&lt;long long&gt; &gt; f(m + 1, std::vector&lt;long long&gt; (n + 1, inf));    f[0][0] = 0ll;    for (int j = 1; j &lt;= m; ++j) &#123;        std::vector&lt;int&gt; q(n + 1);        int t = -1;        q[++t] = j - 1;        auto f1 = [&amp;](int A, int B) &#123;            return f[j - 1][A] - f[j - 1][B];        &#125;;        auto f2 =[&amp;](int A, int B) &#123;            return A - B;        &#125;;        for (int i = j; i &lt;= n; ++i) &#123;            for (; t &gt;= 1 &amp;&amp; f1(q[t], q[t - 1]) &gt; a[i] * f2(q[t], q[t - 1]); --t);            f[j][i] = f[j - 1][q[t]] + (i - q[t]) * a[i];            for (; t &gt;= 1 &amp;&amp; f1(i, q[t]) * f2(q[t], q[t - 1]) &lt; f1(q[t], q[t - 1]) * f2(i, q[t]); --t);            q[++t] = i;        &#125;    &#125;    auto res(inf);    for (int i = m; i &lt;= n; ++i)        res = std::min(res, f[m][i]);    std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;    return 0;&#125;</code></pre></details><hr /><h2 id="c---traka">C - ⭐ TRAKA</h2><p><a href="https://www.luogu.com.cn/problem/P7747" class="uri">https://www.luogu.com.cn/problem/P7747</a></p><blockquote><p>⭐ <strong>不等式到 DP 的转化</strong></p><p>现在有 <span class="math inline">\(m\)</span> 辆车需要被<strong>依次</strong>安装，每辆车都需要<strong>无间隔时间地、依次</strong>经过工人 <span class="math inline">\(1\sim n\)</span>。每辆车有一个系数 <span class="math inline">\(f_j\)</span>，每个人有一个系数 <span class="math inline">\(t_i\)</span>，则人 <span class="math inline">\(i\)</span> 操作车 <span class="math inline">\(j\)</span> 的时间为 <span class="math inline">\(t_i\times f_j\)</span>。</p><p>最小化第 <span class="math inline">\(m\)</span> 辆车被装完的时间。</p><p><span class="math inline">\(n,m\le 10^5\)</span>。</p></blockquote><p>稍微手玩一下就可以发现，假如第 <span class="math inline">\(j\)</span> 个人在第 <span class="math inline">\(i\)</span> 次的工作时间为 <span class="math inline">\([L_{j,i},R_{j,i}]\)</span>，第 <span class="math inline">\(i-1\)</span> 次为 <span class="math inline">\([L_{j,i-1},R_{j,i-1}]\)</span>，那么要求 <span class="math inline">\(L_{j,i}\ge R_{j,i-1}\)</span>。</p><p>令 <span class="math inline">\(s_j\)</span> 为 <span class="math inline">\(t\)</span> 的前缀和。假设第 <span class="math inline">\(i-1\)</span> 次加工于 <span class="math inline">\(x_{i-1}\)</span> 开始，那么我们可以把上式转写为 <span class="math inline">\(x_{i}+s_{j-1}\times f_{i}\ge x_{i-1}+s_j\times f_{i-1}\)</span>。也即 <span class="math inline">\(x_i-x_{i-1}\ge s_j\times f_{i-1}-s_{j-1}\times f_i\)</span>。</p><p>显然需要找到一个 <span class="math inline">\(j\)</span> 使得 RSH 取得最大值；现在就可以考虑斜率优化了。由于所有项都和 <span class="math inline">\(i\)</span> 有关，想到两边同除 <span class="math inline">\(f_{i}\)</span> 消掉一个 <span class="math inline">\(i\)</span> 有关的系数，最后化出来的斜优形式是 <span class="math inline">\(\dfrac {s_A-s_B}{s_{A-1}-s_{B-1}}&gt;\dfrac {f_{i-1}}{f_i}\)</span>。由于 RSH 不单调，把所有 <span class="math inline">\(j\)</span> 塞到队列里维护递减斜率，打二分即可。</p><details><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;int main() &#123;#ifdef ONLINE_JUDGE    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr), std::cout.tie(nullptr);#else    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);#endif    int n, m;    std::cin &gt;&gt; n &gt;&gt; m;    std::vector&lt;long long&gt; a(n + 1), w(m + 1), s(n + 1);    for (int i = 1; i &lt;= n; ++i)        std::cin &gt;&gt; a[i], s[i] = s[i - 1] + a[i];    for (int i = 1; i &lt;= m; ++i)        std::cin &gt;&gt; w[i];    std::vector&lt;long long&gt; f(m + 1);    std::vector&lt;int&gt; q(n + 1);    int h = 0, t = -1;    q[++t] = 1;    for (int i = 2; i &lt;= n; ++i) &#123;        for (; h &lt; t &amp;&amp; (s[i] - s[q[t]]) * (s[q[t] - 1] - s[q[t - 1] - 1]) &gt; (s[q[t]] - s[q[t - 1]]) * (s[i - 1] - s[q[t] - 1]); --t);        q[++t] = i;    &#125;    for (int i = 2; i &lt;= m; ++i) &#123;        int to = q[h];        for (int l = h + 1, r = t, mid; l &lt;= r; ) &#123;            mid = (l + r) &gt;&gt; 1;            if ((s[q[mid]] - s[q[mid - 1]]) * w[i - 1] &gt; w[i] * (s[q[mid] - 1] - s[q[mid - 1] - 1]))                to = q[mid], l = mid + 1;            else                r = mid - 1;        &#125;        f[i] = f[i - 1] + s[to] * w[i - 1] - s[to - 1] * w[i];    &#125;    std::cout &lt;&lt; f[m] + w[m] * s[n] &lt;&lt; &#39;\n&#39;;    return 0;&#125;</code></pre></details><hr /><h2 id="d---柠檬">D - ⭐ 柠檬</h2><p><a href="https://www.luogu.com.cn/problem/P5504" class="uri">https://www.luogu.com.cn/problem/P5504</a></p><blockquote><p>⭐ <strong>斜优式子中的代换</strong></p><p>给定一个序列，每次可以从两端取走一段元素，你每次可以任选一个值 <span class="math inline">\(k\)</span>，若其在这一段中出现次数为 <span class="math inline">\(c_k\)</span>，则这次操作的收益为 <span class="math inline">\(k\times {c_k}^2\)</span>。求取空后的最大收益。</p><p><span class="math inline">\(n\le 10^5\)</span>。</p></blockquote><ul><li>观察零：原问题『从两端取』可以转化为分段问题，故从其中一端考虑即可。</li><li>观察一：若有一段连续的 <span class="math inline">\(x\)</span>，完整的比拆开的更优。</li><li>观察二：如果一段 <span class="math inline">\(x\)</span> 中夹杂了一些其他元素，那么在哪里分段是说不准的。</li><li>观察三：如果选取的区间是 <span class="math inline">\([1,r]\)</span>，那么贪心地想，<span class="math inline">\(a_r\)</span> 一定是关键值，不然取 <span class="math inline">\(a_r\)</span> 就浪费了。</li><li>观察四：如果选取的区间是 <span class="math inline">\([l,r]\)</span>，那么由观察四，<span class="math inline">\(a_l=a_r\)</span>，且该值为关键值。</li></ul><p>结合这几个观察，令 <span class="math inline">\(c_i\)</span> 表示 <span class="math inline">\(a_i\)</span> 在 <span class="math inline">\([1,i]\)</span> 中出现次数，<span class="math inline">\(f_i\)</span> 表示这一段以 <span class="math inline">\(i\)</span> 结尾的最大价值：</p><p><span class="math display">\[\begin{aligned}f_i&amp;=\max\limits_{j&lt;i,a_{j+1}=a_i}\{f_j+a_i\times (c_i-c_{j + 1} + 1)^2\}\\&amp;=\max\limits_{j&lt;i,a_{j+1}=a_i}\{f_j+a_{j+1}\times {c_{j+1}}^2-2\times c_i\times a_{j+1}\times c_{j+1}-2\times c_{j+1}\times a_{j+1}\}+a_i\times(c_i-1)^2\end{aligned}\]</span></p><p>（怎么这么大一堆。）最后可以化出 <span class="math inline">\(\dfrac {f_A-f_B+a_{A+1}\cdot c_{A+1}\cdot (c_{A+1}-2)-a_{B+1}\cdot c_{B+1}\cdot (c_{B+1}-2)}{2(c_{A+1} - c_{B+1})}&gt;c_i\times a_i\)</span>。发现对于每一种 <span class="math inline">\(a_i\)</span>，<span class="math inline">\(c_i\times a_i\)</span> 是单增的。单调栈维护即可。</p><p><em>这其实提醒我们关于代换的问题——显然，当与 <span class="math inline">\(i\)</span> 的项、与 <span class="math inline">\(j\)</span> 有关的项之间存在代换关系时，应该尽量往 <span class="math inline">\(j\)</span> 的方向靠。</em></p><details><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;int main() &#123;#ifdef ONLINE_JUDGE    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr), std::cout.tie(nullptr);#else    std::freopen(&quot;7.in&quot;, &quot;r&quot;, stdin);    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);#endif    int n;    std::cin &gt;&gt; n;    std::vector&lt;long long&gt; a(n + 1), c(n + 1), la(10001);    for (int i = 1; i &lt;= n; ++i) &#123;        std::cin &gt;&gt; a[i];        c[i] = c[la[a[i]]] + 1, la[a[i]] = i;    &#125;    std::vector&lt;long long&gt; f(n + 1);    std::vector&lt;int&gt; _t(10001, -1);    std::vector&lt;std::vector&lt;int&gt; &gt; _q(10001);    auto f1 = [&amp;](int A, int B) &#123;        return f[A] - f[B] + a[A + 1] * c[A + 1] * (c[A + 1] - 2) - a[B + 1] * c[B + 1] * (c[B + 1] - 2);    &#125;;    auto f2 = [&amp;](int A, int B) &#123;        return 2 * (c[A + 1] - c[B + 1]);    &#125;;    ++_t[a[1]], _q[a[1]].push_back(0);    for (int i = 1; i &lt;= n; ++i) &#123;        &#123;            auto &amp;t = _t[a[i]];            auto &amp;q = _q[a[i]];            for (; t &gt;= 1 &amp;&amp; f1(q[t], q[t - 1]) &lt; c[i] * a[i] * f2(q[t], q[t - 1]); --t);            f[i] = f[q[t]] + a[i] * (c[i] - c[q[t] + 1] + 1) * (c[i] - c[q[t] + 1] + 1);        &#125;        if (i &lt; n) &#123;            auto &amp;t = _t[a[i + 1]];            auto &amp;q = _q[a[i + 1]];            for (; t &gt;= 1 &amp;&amp; f1(i, q[t]) * f2(q[t], q[t - 1]) &gt; f1(q[t], q[t - 1]) * f2(i, q[t]); --t);            q.resize(++t + 1), q[t] = i;        &#125;    &#125;    std::cout &lt;&lt; f[n] &lt;&lt; &#39;\n&#39;;    return 0;&#125;</code></pre></details><hr /><h2 id="e---knapsack-with-diminishing-values">E - Knapsack with Diminishing Values</h2><p><a href="https://atcoder.jp/contests/abc373/tasks/abc373_f" class="uri">https://atcoder.jp/contests/abc373/tasks/abc373_f</a></p><p>发现和 <a href="/20250707-1/#例单调队列优化多重背包">单调队列优化多重背包</a> 有异曲同工之妙。</p><p>不妨令 <span class="math inline">\(v_i\)</span> 表示体积，<span class="math inline">\(w_i\)</span> 表示价值。对于每一个 <span class="math inline">\(i\)</span>，把所有体积按模 <span class="math inline">\(v_i\)</span> 的余数分类，设为 <span class="math inline">\(j\cdot v_i+x\)</span>。对于 <span class="math inline">\(k\cdot v_i+x\)</span>，有：</p><p><span class="math display">\[\begin{aligned}f_{i,j\cdot v_i+x}&amp;=\max\limits_{k&lt;j}\{f_{i-1,k\cdot v_i+x}+(j-k)\cdot w_i-(j-k)^2\}\\&amp;=\max\limits_{k&lt;j}\{f_{i-1,k\cdot v_i+x}-k\cdot w_i-k^2+2\times j\times k\}-j^2+j\cdot w_i\end{aligned}\]</span></p><p>则得到 <span class="math inline">\(\dfrac {f_{i-1,A\cdot v_i+x}-f_{i-1,B\cdot v_i+x}+(B-A)\cdot w_i - A^2+B^2}{2(B-A)}&lt;j\)</span>。注意分母为负。总之单调队列维护递增斜率即可。</p><details><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;int main() &#123;#ifdef ONLINE_JUDGE    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr), std::cout.tie(nullptr);#else    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);#endif    int n, m;    std::cin &gt;&gt; n &gt;&gt; m;    std::vector&lt;long long&gt; v(n + 1), w(n + 1);    std::vector&lt;std::vector&lt;long long&gt; &gt; f(n + 1, std::vector&lt;long long&gt; (m + 1));    for (int i = 1; i &lt;= n; ++i) &#123;        std::cin &gt;&gt; v[i] &gt;&gt; w[i];        for (int x = 0; x &lt; v[i]; ++x) &#123;            int h = 0, t = -1;            std::vector&lt;int&gt; q;            auto f1 = [&amp;](int A, int B) &#123;                return f[i - 1][A * v[i] + x] - f[i - 1][B * v[i] + x] + (B - A) * w[i] - A * A + B * B;            &#125;;            auto f2 = [&amp;](int A, int B) &#123;                return 2 * (B - A);            &#125;;            for (int j = 0, J = x; J &lt;= m; ++j, J += v[i]) &#123;                for (; h &lt; t &amp;&amp; f1(q[h + 1], q[h]) &gt; j * f2(q[h + 1], q[h]); ++h);                f[i][J] = f[i - 1][J];                if (h &lt;= t)                    f[i][J] = std::max(f[i][J], f[i - 1][q[h] * v[i] + x] + (j - q[h]) * w[i] - (j - q[h]) * (j - q[h]));                for (; h &lt; t &amp;&amp; f1(j, q[t]) * f2(q[t], q[t - 1]) &lt; f1(q[t], q[t - 1]) * f2(j, q[t]); --t);                q.resize(++t + 1), q[t] = j;            &#125;        &#125;    &#125;    std::cout &lt;&lt; f[n][m] &lt;&lt; &#39;\n&#39;;    return 0;&#125;</code></pre></details><hr /><h2 id="f---managing-telephone-poles">F - Managing Telephone Poles</h2><p><a href="https://codeforces.com/problemset/problem/1575/M" class="uri">https://codeforces.com/problemset/problem/1575/M</a></p><p>？观察到性质然后被自己忽略了。非常值得批评。</p><p>不难写出类似斜率优化的式子 <span class="math inline">\(S(i,j)=\min\{ {x_k}^2-2\times i\times x_k+{y_k}^2-2\times j \times y_k\}+i^2+j^2\)</span>。</p><p>会下意识尝试固定 <span class="math inline">\(i\)</span>，就可以 <span class="math inline">\(O(n^2m)\)</span> 完成任务，似乎不太行。顺着这个想法会观察到，固定 <span class="math inline">\(i\)</span> 之后，每一列的 poles 中只有和第 <span class="math inline">\(i\)</span> 行最近的才会有贡献。</p><p>这个是好做的，且这样的相邻点数量是 <span class="math inline">\(O(m)\)</span> 的；于是将 <span class="math inline">\(i\)</span> 视为常数进行变形，若将所有 poles 按 <span class="math inline">\(y\)</span> 从小到大排序就能得到斜率形式 <span class="math inline">\(\dfrac { {x_A}^2-{x_B}^2+{y_A}^2-{y_B}^2-2\times i\times(x_A-x_B)}{2(y_A-y_B)}&lt;j\)</span>。维护递增斜率就能 <span class="math inline">\(O(n^2)\)</span> 完成问题。</p><p>那么找相邻点这一步大可以摆烂写二分。所以总共是 <span class="math inline">\(O(nm\log m)\)</span> 的。</p><p>不要像我一样把两边最近的都加进队列，不然你会有分母为 <span class="math inline">\(0\)</span> 的斜率 <img src="/em/hsh.gif" /></p><details><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;int main() &#123;#ifdef ONLINE_JUDGE    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr), std::cout.tie(nullptr);#else    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);#endif    int n, m;    std::cin &gt;&gt; n &gt;&gt; m, ++n, ++m;    std::vector&lt;std::vector&lt;int&gt; &gt; tag(n + 1, std::vector&lt;int&gt; (m + 1));    std::vector&lt;std::vector&lt;int&gt; &gt; g(m + 1);    for (int i = 1; i &lt;= n; ++i)        for (int j = 1; j &lt;= m; ++j) &#123;            char t;            std::cin &gt;&gt; t;            if (t == &#39;1&#39;)                g[j].push_back(i), tag[i][j] = 1;        &#125;    struct node &#123; long long x, y; &#125;;    auto res(0ll);    for (int i = 1; i &lt;= n; ++i) &#123;        std::vector&lt;node&gt; p;        for (int j = 1; j &lt;= m; ++j) &#123;            int to = std::lower_bound(g[j].begin(), g[j].end(), i) - g[j].begin();            if (to &lt; (int)g[j].size()) &#123;                p.push_back(&#123; g[j][to], j &#125;);                if (g[j][to] != i &amp;&amp; to != 0 &amp;&amp; g[j][to] - i &gt; i - g[j][to - 1])                    p.back() = &#123; g[j][to - 1], j &#125;;            &#125;            else if (to != 0)                p.push_back(&#123; g[j][to - 1], j &#125;);        &#125;        std::vector&lt;int&gt; q(m + 1);        int h = 0, t = -1;        auto f1 = [&amp;](node A, node B) &#123;            return A.x * A.x - B.x * B.x + A.y * A.y - B.y * B.y - 2 * i * (A.x - B.x);        &#125;;        auto f2 = [&amp;](node A, node B) &#123;            return 2 * (A.y - B.y);        &#125;;        for (int j = 0; j &lt; (int)p.size(); ++j) &#123;            for (; h &lt; t &amp;&amp; f1(p[j], p[q[t]]) * f2(p[q[t]], p[q[t - 1]]) &lt; f1(p[q[t]], p[q[t - 1]]) * f2(p[j], p[q[t]]); --t);            q[++t] = j;        &#125;        for (int j = 1; j &lt;= m; ++j) &#123;              for (; h &lt; t &amp;&amp; f1(p[q[h + 1]], p[q[h]]) &lt; j * f2(p[q[h + 1]], p[q[h]]); ++h);            res += (p[q[h]].x - i) * (p[q[h]].x - i) + (p[q[h]].y - j) * (p[q[h]].y - j);        &#125;    &#125;    std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;    return 0;&#125;</code></pre></details><hr /><h2 id="g---partition-game">G - Partition Game</h2><p><a href="https://codeforces.com/problemset/problem/1527/E" class="uri">https://codeforces.com/problemset/problem/1527/E</a></p><p>发现不太斜优，终于给我浸泡了两天斜优内容的大脑加了勺新的底物。</p><p>令 <span class="math inline">\(f_{i,j}\)</span> 表示第 <span class="math inline">\(i\)</span> 段以 <span class="math inline">\(j\)</span> 结尾的最小代价；对 <span class="math inline">\(w\)</span> 套用四边形不等式变式 <span class="math inline">\(w(l-1,r+1)+w(l,r)\ge w(l-1,r)+w(l,r+1)\)</span> 发现成立（其中大多数时候能取等；部分特殊情况取到大于号）。</p><p>那么发现可以用分治优化。发现 <span class="math inline">\(w\)</span> 不那么能快速求；还是套用 <a href="/20250707-1/#例yet-another-minimization-problem">Yet Another Minimization Problem</a> 中的方法，用类似莫队的方式求解。</p><p>发现这个莫队套路也很熟悉了，直接用双端队列维护即可。复杂度 <span class="math inline">\(O(nk\log n)\)</span>，看着不太安全。但注意到我们在 20 个月前的提交中使用了 <span class="math inline">\(O(nk\log n)\)</span> 的线段树，所以能过的兄弟。</p><details><p>鉴于 deque 的时空常数都大得吓人，所以我用静态 vector 模拟 deque 了。</p><p>跑得比我之前线段树的一半还快，兄弟。</p><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;const int inf = 1e18;int main() &#123;#ifdef ONLINE_JUDGE    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr), std::cout.tie(nullptr);#else    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);#endif    int n, m;    std::cin &gt;&gt; n &gt;&gt; m;    std::vector&lt;std::vector&lt;int&gt; &gt; pos(n + 1);    std::vector&lt;int&gt; a(n + 1), _h(n + 1), _t(n + 1, -1);    for (int i = 1; i &lt;= n; ++i)        std::cin &gt;&gt; a[i], pos[a[i]].push_back(i);    std::vector&lt;std::vector&lt;long long&gt; &gt; f(m + 1, std::vector&lt;long long&gt; (n + 1, inf));    f[0][0] = 0ll;    auto w = [&amp;](int ql, int qr) &#123;        static int l = 1, r = 0;        static auto res(0ll);        for (; l &gt; ql; ) &#123;            --l;            auto &amp;h = _h[a[l]], &amp;t = _t[a[l]];            auto &amp;q = pos[a[l]];            if (h &lt;= t)                res -= q[t] - q[h];            res += q[t] - q[--h];        &#125;        for (; r &gt; qr; ) &#123;            auto &amp;h = _h[a[r]], &amp;t = _t[a[r]];            auto &amp;q = pos[a[r]];            res -= q[t--] - q[h];            if (h &lt;= t)                res += q[t] - q[h];            --r;        &#125;        for (; r &lt; qr; ) &#123;            ++r;            auto &amp;h = _h[a[r]], &amp;t = _t[a[r]];            auto &amp;q = pos[a[r]];            if (h &lt;= t)                res -= q[t] - q[h];            res += q[++t] - q[h];        &#125;        for (; l &lt; ql; ) &#123;            auto &amp;h = _h[a[l]], &amp;t = _t[a[l]];            auto &amp;q = pos[a[l]];            res -= q[t] - q[h++];            if (h &lt;= t)                res += q[t] - q[h];            ++l;        &#125;        return res;    &#125;;    for (int t = 1; t &lt;= m; ++t) &#123;        std::function&lt;void(int, int, int, int)&gt; calc = [&amp;](int l, int r, int lp, int rp) &#123;            if (l &gt; r)                return;            if (l == r) &#123;                for (int i = lp; i &lt;= rp &amp;&amp; i &lt; l; ++i)                    f[t][l] = std::min(f[t][l], f[t - 1][i] + w(i + 1, l));                return;            &#125;            int mid = (l + r) &gt;&gt; 1, p = -1;            for (int i = lp; i &lt;= rp &amp;&amp; i &lt; mid; ++i)                if (f[t - 1][i] + w(i + 1, mid) &lt; f[t][mid])                    f[t][mid] = f[t - 1][i] + w(i + 1, mid), p = i;            calc(l, mid - 1, lp, p), calc(mid + 1, r, p, rp);            return;        &#125;;        calc(t, n, t - 1, n - 1);    &#125;    std::cout &lt;&lt; f[m][n] &lt;&lt; &#39;\n&#39;;    return 0;&#125;</code></pre></details><hr /><h2 id="h---battle-lemmings">H - Battle Lemmings</h2><p><a href="https://codeforces.com/problemset/problem/1420/E" class="uri">https://codeforces.com/problemset/problem/1420/E</a></p><p>容易发现 <span class="math inline">\(0\)</span> 的数目不变，答案就是 <span class="math inline">\(0\)</span> 的对数 - 连续 <span class="math inline">\(0\)</span> 的对数。</p><p>然后有一个我们很熟悉的 trick，随便找一个目标序列，那么花费的操作次数就是每个对应的 <span class="math inline">\(1\)</span> 的位置差。令 <span class="math inline">\(f_{i,j,k}\)</span> 表示用了 <span class="math inline">\(i\)</span> 次操作、<span class="math inline">\(j\)</span> 个 <span class="math inline">\(1\)</span>、最后一个 <span class="math inline">\(1\)</span> 在 <span class="math inline">\(k\)</span> 的最小连续 <span class="math inline">\(0\)</span> 对数。那么有：</p><p><span class="math display">\[\begin{aligned}f_{i,j,k}&amp;=\min\limits_{p&lt;k}\left\{f_{i-|k-pos_j|,j-1,p}+\dfrac {(k-p-1)(k-p-2)}2\right\}\\&amp;=\min\left\{f_{i-|k-pos_j|,j-1,p}-k\cdot p+\dfrac {p(p + 2)}2\right\}+\dfrac {k^2-3k+2}2\end{aligned}\]</span></p><p>发现这个式子是 <span class="math inline">\(O(n^5)\)</span> 的，而且看起来很斜优，化为斜率形式 <span class="math inline">\(\dfrac{2\times f_A-2\times f_B+A(A+2)-B(B+2)}{2(A-B)}&lt;k\)</span>。维护递增斜率就可以 <span class="math inline">\(O(n^4)\)</span> 做了。</p><p>Tip：当时写着写着愣住了，比如这个 <span class="math inline">\(i-|k-pos_j|\)</span> 不是一直在动吗。解决方案？同时维护很多个队列即可。</p><details><p>注意还要把最后一个 <span class="math inline">\(1\)</span> 之后连续 <span class="math inline">\(0\)</span> 的代价算上。</p><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;const long long inf = 1e9;int main() &#123;#ifdef ONLINE_JUDGE    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr), std::cout.tie(nullptr);#else    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);#endif    int n;    std::cin &gt;&gt; n;    std::vector&lt;int&gt; a(n + 1);    std::vector&lt;long long&gt; pos(1);    for (int i = 1; i &lt;= n; ++i) &#123;        std::cin &gt;&gt; a[i];        if (a[i] == 1)            pos.push_back(i);    &#125;    int m = n * (n - 1) / 2;    std::vector&lt;std::vector&lt;std::vector&lt;long long&gt; &gt; &gt; f(pos.size(), std::vector&lt;std::vector&lt;long long&gt; &gt; (m + 1, std::vector&lt;long long&gt; (n + 1, inf)));    f[0][0][0] = 0ll;    for (int j = 1; j &lt; (int)pos.size(); ++j) &#123;        std::vector&lt;std::vector&lt;int&gt; &gt; _q(m + 1, std::vector&lt;int&gt; (n + 1));        std::vector&lt;int&gt; _h(m + 1), _t(m + 1, -1);        for (int k = 0; k &lt;= n; ++k)            for (int i = m; i &gt;= 0; --i) &#123;                if (i &gt;= std::abs(k - pos[j])) &#123;                    auto f1 = [&amp;](long long A, long long B) &#123;                        return 2 * f[j - 1][i - std::abs(k - pos[j])][A] - 2 * f[j - 1][i - std::abs(k - pos[j])][B] + A * (A + 2) - B * (B + 2);                    &#125;;                    auto f2 = [&amp;](long long A, long long B) &#123;                        return 2 * (A - B);                    &#125;;                    auto &amp;h = _h[i - std::abs(k - pos[j])], &amp;t = _t[i - std::abs(k - pos[j])];                    auto &amp;q = _q[i - std::abs(k - pos[j])];                    for (; h &lt; t &amp;&amp; f1(q[h + 1], q[h]) &lt; k * f2(q[h + 1], q[h]); ++h) &#123;&#125;                    if (h &lt;= t)                        f[j][i][k] = std::min(inf, f[j - 1][i - std::abs(k - pos[j])][q[h]] + (k - q[h] - 1) * (k - q[h] - 2) / 2);                &#125;                auto f1 = [&amp;](long long A, long long B) &#123;                    return 2 * f[j - 1][i][A] - 2 * f[j - 1][i][B] + A * (A + 2) - B * (B + 2);                &#125;;                auto f2 = [&amp;](long long A, long long B) &#123;                    return 2 * (A - B);                &#125;;                auto &amp;h = _h[i], &amp;t = _t[i];                auto &amp;q = _q[i];                for (; h &lt; t &amp;&amp; f1(k, q[t]) * f2(q[t], q[t - 1]) &lt; f1(q[t], q[t - 1]) * f2(k, q[t]); --t);                q[++t] = k;            &#125;    &#125;    auto res(-inf);    int cnt = n - (int)pos.size() + 1;    cnt = cnt * (cnt - 1) / 2;    for (int i = 0; i &lt;= m; ++i) &#123;        for (int k = 0; k &lt;= n; ++k)            res = std::max(res, cnt - f.back()[i][k] - (n - k) * (n - k - 1) / 2);        std::cout &lt;&lt; res &lt;&lt; &#39; &#39;;    &#125;    std::cout &lt;&lt; &#39;\n&#39;;    return 0;&#125;</code></pre></details><hr /><h2 id="a---yakiniku-restaurants">A - ⭐ Yakiniku Restaurants</h2><p><a href="https://atcoder.jp/contests/arc067/tasks/arc067_d" class="uri">https://atcoder.jp/contests/arc067/tasks/arc067_d</a></p><blockquote><p>⭐ <strong>单调栈在决策单调性中的应用</strong></p><p>给定 <span class="math inline">\(n\times m\)</span> 的矩阵 <span class="math inline">\(a\)</span>、长度为 <span class="math inline">\(n\)</span> 的数组 <span class="math inline">\(d\)</span>。选定一段区间 <span class="math inline">\([l,r]\)</span>，最大化 <span class="math inline">\(\left(\sum\limits_{j=1^m}\max\limits_{i\in[l,r]}\{a_{i,j}\}\right)-\sum\limits_{i=l}^r d_i\)</span>。</p><p><span class="math inline">\(n\le 5\times 10^3,m\le 200\)</span>。</p></blockquote><p>发现固定左右端点后，收益是可以贪心算的；下意识想到只固定左端点，那么右端点应该就可以用单调队列之类的搞一搞。</p><p>先提前把所有东西塞到队列里。左端点一开始在最右边；往左边动一下之后，就可以更新每种菜的队列；发现在所有元素中作决策点的不总是队头；这个地方用 <strong>单调递减的单调栈</strong> 是极好的。这里的单调栈其实就类似 <a href="/20250707-1/#优化-dp单调数据结构">四边形不等式中的单调数据结构</a> 了。</p><p>维护单调栈中每个决策点的影响区间；显然每个右端点的答案变化量相同；用个类似于差分的东西记录一下就好了。</p><p>复杂度 <span class="math inline">\(O(n^2)\)</span>。</p><details><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;const long long inf = 1e18;int main() &#123;#ifdef ONLINE_JUDGE    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr), std::cout.tie(nullptr);#else    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);#endif    int n, m;    std::cin &gt;&gt; n &gt;&gt; m;    std::vector&lt;long long&gt; s(n + 1), f(n + 1);    for (int i = 2; i &lt;= n; ++i) &#123;        std::cin &gt;&gt; s[i], s[i] += s[i - 1];        f[i] = -s[i];    &#125;    std::vector&lt;std::vector&lt;int&gt; &gt; a(n + 1, std::vector&lt;int&gt; (m + 1));    for (int i = 1; i &lt;= n; ++i)        for (int j = 1; j &lt;= m; ++j)            std::cin &gt;&gt; a[i][j];    struct node &#123; int j, l, r; &#125;;    std::vector&lt;std::stack&lt;node&gt; &gt; _q(m + 1);    auto res(-inf);    for (int l = n; l; --l) &#123;        std::vector&lt;long long&gt; d(n + 1);        auto add = [&amp;](int l, int r, long long v) &#123;            d[l] += v;            if (r != n)                d[r + 1] -= v;            return;        &#125;;        for (int j = 1; j &lt;= m; ++j) &#123;            auto &amp;q = _q[j];            node now = &#123; j, l, l &#125;;            add(l, l, a[l][j]);            for (; !q.empty() &amp;&amp; a[l][j] &gt;= a[q.top().l][q.top().j]; q.pop()) &#123;                now.r = q.top().r;                add(q.top().l, q.top().r, a[l][j] - a[q.top().l][q.top().j]);            &#125;            q.push(now);        &#125;        std::partial_sum(d.begin() + 1, d.end(), d.begin() + 1);        for (int r = l; r &lt;= n; ++r) &#123;            f[r] += d[r];            res = std::max(res, f[r] + s[l]);        &#125;    &#125;    std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;    return 0;&#125;</code></pre></details><hr /><h2 id="b---jellyfish-and-miku">B - Jellyfish and Miku</h2><p><a href="https://codeforces.com/problemset/problem/1874/D" class="uri">https://codeforces.com/problemset/problem/1874/D</a></p><p>唉数列。唉概统。在数学讲义上折磨了我一遍之后还要到这儿来折磨我。</p><p>假设已经知道了 <span class="math inline">\(a\)</span>，考虑求期望步数。设 <span class="math inline">\(E_i\)</span> 为从 <span class="math inline">\(i\)</span> 出发走到 <span class="math inline">\(n\)</span> 的期望步数。那么有：</p><p><span class="math display">\[E_i=\begin{cases}E_1+1&amp;i=0\\0&amp;i=n\\E_i=(E_{i-1}+1)\cdot \dfrac {a_i}{a_{i+1}+a_i}+(E_{i+1}+1)\cdot \dfrac {a_{i+1}}{a_{i+1}+a_{i}}&amp;\text{otherwise}\end{cases}\]</span></p><p>（提示：从『<span class="math inline">\(i\)</span> 下一步会走哪个方向』考虑。）</p><p>接下来就可以利用你的高中数学知识进行一个 <span class="math inline">\(f_0\)</span> 的求，（一堆过程），得到 <span class="math inline">\(E_0=n+2\times \sum\limits_{i=1}^n\dfrac {\sum_{j\le i}a_j}{a_i}\)</span>，然后想要最小化这个东西。</p><p>不妨令 <span class="math inline">\(f_{i,j}\)</span> 表示到 <span class="math inline">\(i\)</span> 时已经分配走了 <span class="math inline">\(j\)</span> 体积，<span class="math inline">\(\sum_{k=1}^i \dfrac {\sum_{l\le k}a_l}{a_k}\)</span> 的最小值，有 <span class="math inline">\(f_{i,j}=\min\limits_{k&lt;j}\left\{f_{i-1,k}+\dfrac {k}{j - k}\right\}\)</span>。发现它大抵是满足四边形不等式的，按照 <a href="/20250707-1/#d1d-dp-优化">2D/1D DP 优化的结论</a>，代入 <span class="math inline">\(p_{i,j-1}&lt;p_{i,j}&lt;p_{i+1,j}\)</span> 可以 <span class="math inline">\(O(nm)\)</span> 解决问题。</p><details><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;int main() &#123;#ifdef ONLINE_JUDGE    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr), std::cout.tie(nullptr);#else    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);#endif    int n, m;    std::cin &gt;&gt; n &gt;&gt; m;    std::vector&lt;std::vector&lt;int&gt; &gt; p(n + 1, std::vector&lt;int&gt; (m + 1));    std::vector&lt;std::vector&lt;long double&gt; &gt; f(n + 1, std::vector&lt;long double&gt; (m + 1, 1e18));    f[0][0] = 0ll;    for (int j = 1; j &lt;= m; ++j)        for (int i = std::min(j, n); i; --i) &#123;            int to = ((i == std::min(j, n)) ? j : std::min(p[i + 1][j], j));            for (int k = p[i][j - 1]; k &lt;= to; ++k)                if (f[i - 1][k] + k * 1. / (j - k) &lt; f[i][j])                    f[i][j] = f[i - 1][k] + k * 1. / (j - k), p[i][j] = k;            // printf(&quot;f[%d][%d] = %Lf, p = %d\n&quot;, i, j, f[i][j], p[i][j]);        &#125;    std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(10) &lt;&lt; n + 2 * f[n][m] &lt;&lt; &#39;\n&#39;;    return 0;&#125;</code></pre></details>]]></content>
      
      
      
        <tags>
            
            <tag> 斜率优化 </tag>
            
            <tag> DP </tag>
            
            <tag> 四边形不等式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>杂题</title>
      <link href="/20250712/"/>
      <url>/20250712/</url>
      
        <content type="html"><![CDATA[<p>我生待明日，万事成蹉跎。</p><span id="more"></span><hr /><h2 id="town">town</h2><p><a href="http://222.180.160.110:61235/contest/6407/problem/1" class="uri">http://222.180.160.110:61235/contest/6407/problem/1</a></p><blockquote><p>给定一棵大小为 <span class="math inline">\(n\)</span> 的树，点有点权，欲将树划分为若干个连通块，使得每个块内的点权异或和都为 <span class="math inline">\(x\)</span>，求方案数，模 <span class="math inline">\(998244353\)</span>。</p><p><span class="math inline">\(n\le 10^6,0\le x\le 10^9\)</span>。</p></blockquote><p>记 <span class="math inline">\(u\)</span> 引导的子树异或和为 <span class="math inline">\(s_u\)</span>。把连通块转化为对断边的讨论。考察一条最末端的边，其下方子树的异或和一定为 <span class="math inline">\(x\)</span>。</p><p>简单数归可得断掉的每一条边，其下方子树异或和为 <span class="math inline">\(x\)</span> 或 <span class="math inline">\(0\)</span>（那么显然有解的充要条件是 <span class="math inline">\(s_1=0\lor s_1=x\)</span>）。考虑树形 DP，令 <span class="math inline">\(f_{u,0/1}\)</span> 表示当前 DP 到 <span class="math inline">\(u\)</span> 子树头上那条边，它连接了一个异或和为 <span class="math inline">\(s_u\)</span> （或 <span class="math inline">\(s_u\oplus x\)</span>）的连通块的合法方案数，分别代表已经『断』掉了偶数 / 奇数个合法连通块。</p><p>首先自然可以一条边都不断，<span class="math inline">\(f_{u,0}=1\)</span>。那么更新就应为：</p><p><span class="math display">\[f&#39;_{u,0}=f_{u,0}\cdot f_{v,0}+f_{u,1}\cdot f_{v,1}\\f&#39;_{u,1}=f_{u,0}\cdot f_{v,1}+f_{u,1}\cdot f_{v,0}\]</span></p><p>接着，如果 <span class="math inline">\(s_u\)</span> 恰好为 <span class="math inline">\(0\)</span> 或 <span class="math inline">\(x\)</span>，这条边连接的连通块的异或和就可以是 <span class="math inline">\(x\)</span>，那么就可以在这条边处断开，提供一个空连通块（加入异或和为 <span class="math inline">\(0\)</span> 的方案）。</p><p>最后注意 <span class="math inline">\(x\)</span> 可能为 <span class="math inline">\(0\)</span>，需要特殊处理——每个 <span class="math inline">\(s_u=0\)</span> 处都可以断开。</p><p>这个 DP 状态实在非常新奇；同时 DP 和删边又是分开的，显得非常割裂。看 sol、听 grisses 讲解的时候都完全一头雾水。quack 说这是因为我没做过连通块 DP /ll</p><details><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;const int mod = 998244353;int main() &#123;#ifdef ONLINE_JUDGE    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr), std::cout.tie(nullptr);#else    std::freopen(&quot;ex_town1.in&quot;, &quot;r&quot;, stdin);    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);#endif    int n, m;    std::cin &gt;&gt; n &gt;&gt; m;    std::vector&lt;int&gt; a(n + 1), s(n + 1);    for (int i = 1; i &lt;= n; ++i)        std::cin &gt;&gt; a[i];    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);    for (int i = 1, x, y; i &lt; n; ++i) &#123;        std::cin &gt;&gt; x &gt;&gt; y;        g[x].push_back(y), g[y].push_back(x);    &#125;    std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int fa) &#123;        s[x] = a[x];        for (auto i : g[x])            if (i != fa) &#123;                DFS(i, x);                s[x] ^= s[i];            &#125;        return;    &#125;;    DFS(1, -1);    if (s[1] != 0 &amp;&amp; s[1] != m) &#123;        std::cout &lt;&lt; 0 &lt;&lt; &#39;\n&#39;;        return 0;    &#125;    if (m == 0) &#123;        auto res(1ll);        for (int i = 2; i &lt;= n; ++i)            if (s[i] == 0)                (res *= 2) %= mod;        std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;    &#125;    else &#123;        std::vector&lt;std::array&lt;long long, 2&gt; &gt; f(n + 1);        DFS = [&amp;](int x, int fa) &#123;            f[x][0] = 1ll;            for (auto i : g[x])                if (i != fa) &#123;                    DFS(i, x);                    std::tie(f[x][0], f[x][1]) = std::make_tuple((f[x][0] * f[i][0] + f[x][1] * f[i][1]) % mod, (f[x][0] * f[i][1] + f[x][1] * f[i][0]) % mod);                &#125;            if (x != 1) &#123;                if (s[x] == m)                    (f[x][1] += f[x][0]) %= mod;                if (s[x] == 0)                    (f[x][0] += f[x][1]) %= mod;            &#125;            // printf(&quot;f[%d][0] = %lld, f[%d][1] = %lld\n&quot;, x, f[x][0], x, f[x][1]);            return;        &#125;;        DFS(1, -1);        std::cout &lt;&lt; (s[1] == m ? f[1][0] : f[1][1]) &lt;&lt; &#39;\n&#39;;    &#125;    return 0;&#125;</code></pre></details><hr /><h2 id="perm">perm</h2><p><a href="http://222.180.160.110:61235/contest/6407/problem/3" class="uri">http://222.180.160.110:61235/contest/6407/problem/3</a></p><blockquote><p>给定一个长度为 <span class="math inline">\(n\)</span>、元素两两不同的序列，你可以交换任意两个元素。试使用最少交换次数使得序列有序，问方案数。</p><p><span class="math inline">\(n\le 10^6\)</span>。</p></blockquote><p>对于一个下标，将它和它上面元素的 rank 连有向边，那么每个下标的出、入度都为 <span class="math inline">\(1\)</span>，则图由若干个简单环组成。</p><p>接着，考虑一次任意一次交换 <span class="math inline">\((x,y)\)</span> 的操作会带来什么：</p><ul><li><p>若 <span class="math inline">\(x,y\)</span> 不在同一环上：</p>该操作使得 <span class="math inline">\(x,y\)</span> 所在的环合为一个大环。</li><li><p>若 <span class="math inline">\(x,y\)</span> 在同一环上：</p><p>该操作使得环以 <span class="math inline">\(x,y\)</span> 为分界线裂成两个小环。</p></li></ul><p>以得到 <span class="math inline">\(n\)</span> 个自环为目标，数归得到，对于最优方案，当且仅当每次交换的目标都在同一环上。</p><p>考虑方案数。把一个大小为 <span class="math inline">\(k\)</span> 的环，欲将其拆成 <span class="math inline">\(k\)</span> 个自环，共需 <span class="math inline">\(k-1\)</span> 次 <em>有序</em> 的拆解。</p><p>考虑 DP，令 <span class="math inline">\(f_k\)</span> 为方案数，那么 <span class="math inline">\(f_k=\dfrac {k\sum\limits_{j=1}^{k-1} f_j\cdot f_{k-j}\cdot C_{k-2}^j}2\)</span>。尝试打表，（惊讶地）发现 <span class="math inline">\(f_k=k^{k-2}\)</span>。</p><p>不同的环之间的操作可以交错，看作多重集排列即可。</p><details><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;const int mod = 998244353;int main() &#123;    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr), std::cout.tie(nullptr);    int n;    std::cin &gt;&gt; n;    std::vector&lt;int&gt; a(n + 1), p(n + 1);    for (int i = 1; i &lt;= n; ++i)        std::cin &gt;&gt; a[i], p[i] = i;    std::sort(p.begin() + 1, p.end(), [&amp;](int i, int j) &#123; return a[i] &lt; a[j]; &#125;);    std::vector&lt;int&gt; f(n + 1), siz(n + 1, 1);    std::iota(f.begin() + 1, f.end(), 1);    std::function&lt;int(int)&gt; find = [&amp;](int x) &#123;        return x == f[x] ? x : f[x] = find(f[x]);    &#125;;    auto merge = [&amp;](int x, int y) &#123;        x = find(x), y = find(y);        if (x != y)            siz[y] += siz[x], f[x] = y;        return;    &#125;;    for (int i = 1; i &lt;= n; ++i)        merge(i, p[i]);    std::vector&lt;long long&gt; g(n + 1), fac(n + 1), inv(n + 1);    g[1] = g[2] = 1ll, fac[0] = inv[0] = 1ll;    for (int i = 1; i &lt;= n; ++i)        fac[i] = fac[i - 1] * i % mod;    auto qkp = [&amp;](long long x, int y) &#123;        auto res(1ll);        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)            if (y &amp; 1)                (res *= x) %= mod;        return res;    &#125;;    inv[n] = qkp(fac[n], mod - 2);    for (int i = n - 1; i; --i)        inv[i] = inv[i + 1] * (i + 1) % mod;    for (int i = 3; i &lt;= n; ++i)        g[i] = qkp(i, i - 2);    int cnt(0);    auto res(1ll);    for (int i = 1; i &lt;= n; ++i)        if (f[i] == i) &#123;            cnt += siz[i] - 1;            (res *= g[siz[i]]) %= mod;            (res *= inv[siz[i] - 1]) %= mod;        &#125;    (res *= fac[cnt]) %= mod;    std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;    return 0;&#125;</code></pre></details><hr /><h2 id="彩排">彩排</h2><p><a href="http://222.180.160.110:61235/contest/6439/problem/3" class="uri">http://222.180.160.110:61235/contest/6439/problem/3</a></p><blockquote><p>构造一个长度 <span class="math inline">\(\le 5.5\times 10^5\)</span>、只由 <span class="math inline">\(1\sim n\)</span> 组成的序列，使其由 <span class="math inline">\(1\sim n\)</span> 开头，<span class="math inline">\(a_i\sim a_n\)</span> 结尾，且任意相同元素距离不小于 <span class="math inline">\(n-1\)</span>。</p><p><span class="math inline">\(n\le 1000\)</span>，保证 <span class="math inline">\(a\)</span> 随机生成。</p></blockquote><p>发现可以花费 <span class="math inline">\(2n\)</span> 的代价交换任意两个元素。例，让 <code>a b X c d Y e f ...</code> 中 <code>X</code> 和 <code>Y</code> 交换，只需要：</p><pre class="plain"><code>a b X c d Y e f ... a b X c d e f ... a b Y c d X e f ...</code></pre><p>其实不是很牛，但是无效思考花费的时间太多了导致没愿意继续想。现在想要用尽量小的交换次数完成排序。把每个数朝它该在的位置连边，（出题人声称）因为目标序列是随机的导致不怎么会出现环。所以大部分情况可以直接交换；如果有环</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>练习 - DP 凸优化</title>
      <link href="/20250709/"/>
      <url>/20250709/</url>
      
        <content type="html"><![CDATA[<figure><img src="/20250709/pre.jpg"><figcaption>还是我的猫</figcaption></figure><span id="more"></span><hr /><h2 id="d.-akvizna">D. Akvizna</h2><p><a href="http://222.180.160.110:61235/contest/6393/problem/4" class="uri">http://222.180.160.110:61235/contest/6393/problem/4</a></p><p>其实到这里应该发现了，WQS 的奖励都以一次项系数出现，原因也很显然，奖励的对象是一次项系数嘛。此外，WQS 内层 DP 数组的维度都应和操作次数无关，而 DP 值应为最大收益。这个也很显然。</p><p>令一轮比赛的惩罚是 <span class="math inline">\(mid\)</span> 然后二分。令 <span class="math inline">\(f_{j}\)</span> 表示剩余人数为 <span class="math inline">\(j\)</span> 时的最大收益，那么有 <span class="math inline">\(f_{j}=\max\limits_{k\ge j}\left\{f_k+\frac {k-j}k\right\}-mid\)</span>。最后在 <span class="math inline">\(f_0\)</span> 处找答案即可。</p><p>然后就发现一个很可怕的问题，内层 DP 咋写。发现把 <span class="math inline">\(\frac {k-j}k\)</span> 改写成 <span class="math inline">\(1-\frac jk\)</span> 后出现交叉项，考虑斜优。令 <span class="math inline">\(a&lt;b\)</span>，那么 <span class="math inline">\(a\)</span> 优于 <span class="math inline">\(b\)</span> 当且仅当 <span class="math inline">\(\dfrac {f_a-f_b}{\frac 1a - \frac 1b} &gt; j\)</span>。维护单减的斜率即可。</p><details><p>笑话：二分 50 次不够，需要 60 次。</p><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;int main() &#123;#ifdef ONLINE_JUDGE    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr), std::cout.tie(nullptr);#else    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);#endif    int n, k;    std::cin &gt;&gt; n &gt;&gt; k;    double l = 0., r = 1e5, mid;    auto calc = [&amp;](double mid) &#123;        std::vector&lt;double&gt; f(n + 1, -1e18);        f[n] = 0.;        int h = 1, t = 0;        std::vector&lt;int&gt; q(n + 1), p(n + 1);        q[++t] = n;        // printf(&quot;mid = %.3lf: \n&quot;, mid);        for (int i = n - 1; ~i; --i) &#123;            for (; h &lt; t &amp;&amp; (f[q[h + 1]] - f[q[h]]) / (1. / q[h + 1] - 1. / q[h]) &gt;= i; ++h);            f[i] = f[q[h]] + 1. - i * 1.0 / q[h] - mid, p[i] = p[q[h]] + 1;            // printf(&quot;  %d: f = %.3lf, p = %d, q[h] = %d(%.3lf / %d)\n&quot;, i, f[i], p[i], q[h], f[q[h]], p[q[h]]);            if (i) &#123;                for (; h &lt; t &amp;&amp; (f[i] - f[q[t]]) / (1. / i - 1. / q[t]) &gt;= (f[q[t]] - f[q[t - 1]]) / (1. / q[t] - 1. / q[t - 1]); --t);                q[++t] = i;            &#125;        &#125;        // printf(&quot;res = %.3lf\n&quot;, f[0] + p[0] * mid);        return std::make_pair(f[0], p[0]);    &#125;;    // calc(0.);    // return 0;    double res(0.);    for (int i = 1; i &lt;= 60; ++i) &#123;        mid = (l + r) / 2.;        auto t(calc(mid));        if (t.second &gt;= k)            l = mid, res = t.first + k * mid;        else            r = mid;    &#125;    std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(8) &lt;&lt; res &lt;&lt; &#39;\n&#39;;    return 0;&#125;</code></pre></details><hr /><h2 id="e.-poborcy-podatkowi">E. Poborcy podatkowi</h2><p><a href="http://222.180.160.110:61235/contest/6393/problem/5" class="uri">http://222.180.160.110:61235/contest/6393/problem/5</a></p><p>首先令 <span class="math inline">\(f_{u,l}(i),l=0,1,2,3\)</span> 表示在 <span class="math inline">\(u\)</span> 上挂了长度为 <span class="math inline">\(l\)</span> 的半条链，共有 <span class="math inline">\(i\)</span> 条整链的最大收益。</p><p>可以观察到是凸的。那么不难发现需要闽可夫斯基和，考虑 <span class="math inline">\(u\)</span> 位置上的合并。<strong>首先需要注意到儿子上长度为 <span class="math inline">\(l\)</span> 的链到父亲上会变成 <span class="math inline">\(l+1\)</span></strong>。显然每条可以不选；如果选了 <span class="math inline">\(cnt_a\)</span> 条长度为 <span class="math inline">\(a\)</span> 的半链，那么合并出来的结果是 <span class="math inline">\(cnt_1-cnt_3\)</span> 条长度为 <span class="math inline">\(1\)</span> 或 <span class="math inline">\(3\)</span> 的链、<span class="math inline">\(cnt_2\bmod 2\)</span> 条长度为 <span class="math inline">\(2\)</span> 的链，并且要求两者不同时出现。发现这个东西基本上处理不了。</p><p>接着注意到这个形式有点像背包。但怎么处理 <span class="math inline">\(cnt_1\)</span> 和 <span class="math inline">\(cnt_3\)</span> 配对的这个要求呢？有个非常精妙的在物品体积上做文章的方法：</p><p>首先注意到我们最后的查询的答案肯定要求把所有儿子用完。那么不妨设体积之和为儿子总数 <span class="math inline">\(tot\)</span>。接着，对 <span class="math inline">\(cnt_0\)</span>（同时也是 <span class="math inline">\(cnt_4\)</span>）没有限制，直接令其体积为 <span class="math inline">\(1\)</span>。<span class="math inline">\(cnt_2\)</span> 单独处理（等会儿会说），为了不对现在的问题产生影响也令其体积为 <span class="math inline">\(1\)</span>。对于 <span class="math inline">\(cnt_1\)</span> 和 <span class="math inline">\(cnt_3\)</span>，显然两者平均体积需要为 <span class="math inline">\(1\)</span>；你可以令 <span class="math inline">\(cnt_3\)</span> 体积为 <span class="math inline">\(2\)</span>，令 <span class="math inline">\(cnt_1\)</span> 体积为 <span class="math inline">\(0\)</span>。</p><p>接下来就有个很好的性质：<span class="math inline">\(cnt_1\)</span> 必须和 <span class="math inline">\(cnt_3\)</span> 配对才能让平均体积为 <span class="math inline">\(1\)</span>。在 <span class="math inline">\(tot\)</span> 处查找的答案，由 <span class="math inline">\(x\)</span> 个体积不为 <span class="math inline">\(0\)</span> 的物品和 <span class="math inline">\(tot-x\)</span> 个体积为 <span class="math inline">\(0\)</span> 的物品（<span class="math inline">\(cnt_1\)</span>）组成，原因是背包会贪心地在所有『剩余』的分组中选择体积为 <span class="math inline">\(0\)</span> 的一项。再计算一下 <span class="math inline">\(cnt_3\)</span>，发现显然为 <span class="math inline">\(tot-x\)</span>。符合目的。</p><p>在 <span class="math inline">\(dp_{tot}\)</span> 处查找可以找到 <span class="math inline">\(cnt_1=cnt_3\)</span> 时的答案；同理，在 <span class="math inline">\(dp_{tot-1},dp_{tot1+1}\)</span> 处可以查找到 <span class="math inline">\(cnt_1=cnt_3\pm 1\)</span> 的答案。</p><p>接下来再考虑 <span class="math inline">\(cnt_2\)</span>，解决『<span class="math inline">\(cnt\bmod2=1\)</span> 和 <span class="math inline">\(cnt_1\ne cnt_3\)</span> 不能同时成立』的限制。那太好了，直接多开一维记录 <span class="math inline">\(cnt_2\bmod 2\)</span> 即可。</p><p>啊啊太妙了。像利用体积为 <span class="math inline">\(-1,1\)</span> 的随机数据背包期望最大体积不超过 <span class="math inline">\(\sqrt V\)</span> 的那个方法，显然就没有办法利用凸性了。所以这或许是闽可夫斯基和做法的唯一解？</p><p>需要知道，如果设 <span class="math inline">\(cnt_1\)</span> 为 <span class="math inline">\(2\)</span> 而 <span class="math inline">\(cnt_3\)</span> 为 <span class="math inline">\(0\)</span>，始终会出一些问题。这个我和 yly 讨论了一下没啥结果。</p><details><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;const long long inf = 1e12;int main() &#123;#ifdef ONLINE_JUDGE    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr), std::cout.tie(nullptr);#else    std::freopen(&quot;1.in&quot;, &quot;r&quot;, stdin);    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);#endif    int n;    std::cin &gt;&gt; n;    std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; g(n + 1);    for (int i = 1, x, y, w; i &lt; n; ++i) &#123;        std::cin &gt;&gt; x &gt;&gt; y &gt;&gt; w;        g[x].emplace_back(y, w), g[y].emplace_back(x, w);    &#125;    using arr = std::vector&lt;long long&gt;;    std::vector&lt;arr&gt; f(n + 1, arr(4));    struct node &#123;        std::vector&lt;arr&gt; f;        node(): f(2) &#123;&#125;        node(std::vector&lt;arr&gt; f1): f(f1) &#123;&#125;        arr&amp; operator[](int q) &#123;            return f[q];        &#125;    &#125;;    auto getmax = [&amp;](arr p, arr q) &#123;        arr res(p);        if (q.size() &gt; p.size())            res.resize(q.size());        for (int i = 0; i &lt; (int)q.size(); ++i)            res[i] = std::max(res[i], q[i]);        return res;    &#125;;    auto merge = [&amp;](arr &amp;p, arr &amp;q) &#123;        arr res(p.size() + q.size() - 1), dp(p.size()), dq(q.size());        std::adjacent_difference(p.begin(), p.end(), dp.begin());        std::adjacent_difference(q.begin(), q.end(), dq.begin());        std::merge(dp.begin() + 1, dp.end(), dq.begin() + 1, dq.end(), res.begin() + 1, std::greater&lt;long long&gt; ());        res[0] = p[0] + q[0];        std::partial_sum(res.begin(), res.end(), res.begin());        return res;    &#125;;     std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int fa) &#123;        if ((int)g[x].size() == 1 &amp;&amp; x != 1) &#123;            f[x][1] = f[x][2] = f[x][3] = -inf;            return;        &#125;        int tot = (int)g[x].size() - (x != 1);        std::vector&lt;arr&gt; w1(1), w2(1);        for (auto [i, w] : g[x])            if (i != fa) &#123;                DFS(i, x);                w1.push_back(&#123; f[i][0] + w, std::max(f[i][0], f[i][3] + w), f[i][2] + w &#125;);                w2.push_back(&#123; -inf, f[i][1] + w &#125;);            &#125;        auto fun = [&amp;](arr &amp;p, arr &amp;q) &#123;            arr res(p.size() + q.size() - 1, -inf);            for (int ip = 0; ip &lt; 2; ++ip)                for (int iq = 0; iq &lt; 2; ++iq) &#123;                    arr tp, tq;                    for (int i = ip; i &lt; (int)p.size(); i += 2)                        tp.push_back(p[i]);                    for (int i = iq; i &lt; (int)q.size(); i += 2)                        tq.push_back(q[i]);                    auto t = merge(tp, tq);                    for (int i = 0; i &lt; (int)t.size(); ++i)                        if (i * 2 + ip + iq &lt; (int)res.size())                            res[i * 2 + ip + iq] = std::max(res[i * 2 + ip + iq], t[i]);                &#125;            return res;        &#125;;         std::function&lt;node(int, int)&gt; calc = [&amp;](int l, int r) &#123;            if (l == r)                return node(&#123; w1[l], w2[l] &#125;);            int mid = (l + r) &gt;&gt; 1;            node t1(calc(l, mid)), t2(calc(mid + 1, r));            return node(&#123; getmax(fun(t1[0], t2[0]), fun(t1[1], t2[1])),                          getmax(fun(t1[0], t2[1]), fun(t1[1], t2[0])) &#125;);        &#125;;        auto t(calc(1, tot));        f[x][0] = t[0][tot], f[x][1] = t[0][tot - 1], f[x][2] = t[1][tot], f[x][3] = t[0][tot + 1];        return;    &#125;;    DFS(1, -1);    std::cout &lt;&lt; f[1][0] &lt;&lt; &#39;\n&#39;;    return 0;&#125;</code></pre></details>]]></content>
      
      
      
        <tags>
            
            <tag> DP </tag>
            
            <tag> DP 优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>决策单调性</title>
      <link href="/20250707-1/"/>
      <url>/20250707-1/</url>
      
        <content type="html"><![CDATA[<figure><img src="/20250707-1/pre.jpg"><figcaption>给你看看我的猫</figcaption></figure><span id="more"></span><hr /><h2 id="什么是-xdyd-dp">什么是 xD/yD DP</h2><p>即 DP 数组共有 <span class="math inline">\(x\)</span> 维，一次转移复杂度为 <span class="math inline">\(O(n^y)\)</span>。</p><p><del>为什么要给一句话单开一个标题</del></p><p>下面设通式 <span class="math inline">\(f_i=\max\left\{f_j+w(i,j)\right\}\)</span>。</p><hr /><h2 id="单调队列优化-dp">单调队列优化 DP</h2><p><span class="math inline">\(w(i,j)\)</span> 仅包含 <span class="math inline">\(i,j\)</span> 的最高一次项。</p><ul><li>如果要求 <span class="math inline">\(j\in [1,i]\)</span>，前缀最小值即可。</li><li>若 <span class="math inline">\(j\)</span> 的取值范围在到处乱动，可以写 DS =_=</li><li><p>若 <span class="math inline">\(j\)</span> 的取值范围 <span class="math inline">\([l,r]\)</span> 随着 <span class="math inline">\(i\)</span> 增大而 <span class="math inline">\(l,r\)</span> 都不减小，那么可以使用单调队列。</p><p>顺带一提，和这种的单调队列用法相似的『单调栈』主要在斜优里出现。</p></li></ul><p>具体过程被 grizzly bear 吃掉了 <img src="/em/eat.gif" /></p><h3 id="例单调队列优化多重背包">例：单调队列优化多重背包</h3><p>朴素的多重背包式子是 <span class="math inline">\(f_{i,j}=\max\left\{f_{i-1,j-k\times v_i}+k\times w_i\right\}\)</span>，因为 <span class="math inline">\(i\)</span> 和整个式子无关，所以是关于 <span class="math inline">\(j\)</span> 的 1D/1D。</p><p>为了套用单调队列，需要把查询的项变成连续的。发现 <span class="math inline">\(j-k\times v_i\)</span> 和 <span class="math inline">\(j\)</span> 关于 <span class="math inline">\(v_i\)</span> 同余；且随着 <span class="math inline">\(k\)</span> 的增大，查询的位置不断移动 <span class="math inline">\(v_i\)</span>。那么不妨把所有 <span class="math inline">\(j\)</span> 按照模 <span class="math inline">\(v_i\)</span> 的余数分开做。具体地，不妨设 <span class="math inline">\(j=a\times v_i+b\)</span>，将 <span class="math inline">\(j-k\times v_i\)</span> 替换为余数写法，那么有：</p><p><span class="math display">\[\begin{aligned}f_{i,j}&amp;=\max\{f_{i-1,x\times v_i+b}+(a-x)\times v_i\}\\&amp;=\max\{f_{i-1,x\times v_i+b}-x\times v_i\}+a\times v_i\end{aligned}\]</span></p><p>在不同模数下按 <span class="math inline">\(x\)</span> 从小到大进行单调队列优化即可。容易发现会不重不漏枚举所有体积；复杂度 <span class="math inline">\(O(nV)\)</span>。</p><hr /><h2 id="斜率优化-dp">斜率优化 DP</h2><p>若 <span class="math inline">\(w(i,j)\)</span> 种含有 <span class="math inline">\(i,j\)</span> 的交叉项，可以考虑斜优。</p><p>具体过程，（如果你愿意），可以看这篇 <a href="/20210214/">四年半前的博客</a>。</p><p>关于符号等问题，分享一下我的做法：</p><ul><li><p>单调队列维护：适用于符号和右侧斜率要求单调性相反的情况。</p><ul><li>首先，讨论队头维护。不妨假设 <span class="math inline">\(a\)</span> 为队头第二个元素，<span class="math inline">\(b\)</span> 为队头第一个元素。</li><li>如果队头 <span class="math inline">\(b\)</span> 需要被弹出，说明 <span class="math inline">\(a\)</span> 优于 <span class="math inline">\(b\)</span>；假设式子要求 max，则用 <span class="math inline">\(a\)</span> 转移得到的答案 &gt; 用 <span class="math inline">\(b\)</span> 转移得到的答案。</li><li>化式子，注意 <span class="math inline">\(a&gt;b\)</span>；且负数乘除要变号。</li><li><p>最后得到的式子中间的不等号就决定了需要维护的斜率单调情况。以此决定队尾维护方式即可。</p><strong>注意这个式子的不等号体现的是弹出条件；保留条件和其相反</strong> <img src="/em/ll.gif" /></li></ul></li><li><p>单调栈维护：适用于符号和右侧斜率要求单调性相同的情况；需要清楚，维护合法性、维护单调和取答案都在栈顶进行。</p><ul><li>首先，都知道要用单调栈了，说明斜优形式已经被化出来了；以此维护合法性即可。</li><li>维护一个从底到顶，『优』得越来越小的斜率序列。找到从更优到更劣的临界点，更新答案。</li></ul></li></ul><p>啊，果然高中文化学科是非常有用的。算是明白为什么我小学 / 初中基本没弄懂过斜优，而旁边的大佬已经在乱杀了 <img src="/em/hsh.gif" /></p><hr /><p>现在假设正在维护一个上凸包，可以进行一些思考：</p><ul><li><p>如果查询区间不单增？</p>搞不了啊这个。废了。</li><li><p>查询的斜率不单增？</p>写个二分 + 单调栈。参见 <a href="https://www.luogu.com.cn/problem/P5785">任务安排</a>、<a href="#例traka">TRAKA</a>。</li><li><p>加入斜率的位置不单增？</p><p>李超 / CDQ / 平衡树。</p></li></ul><hr /><h2 id="四边形不等式优化-dp">四边形不等式优化 DP</h2><h3 id="关于四边形不等式">关于四边形不等式</h3><p>对于代价矩阵 <span class="math inline">\(w\)</span> 和定义域内 <span class="math inline">\(\forall\,a\le b\le c\le d\)</span>，若 <span class="math inline">\(w(a,d)+w(b,c)\ge w(a,c)+w(b,d)\)</span>，认为 <span class="math inline">\(w\)</span> 满足四边形不等式。简记为重叠大于交叉。</p><p>命名来源是四边形对角线之和大于对边之和；将恒大于改为恒小于也能得到相似的性质。</p><p>就会发现单调队列优化和斜优其实是四边形不等式的特化，导致它们可以少一个 log。</p><hr /><h3 id="性质">性质</h3><p>用于证明：</p><ul><li>对于任意 <span class="math inline">\(c\le l\le r\)</span>，若 <span class="math inline">\(w(l-c,r+c) + w(l,r)\le w(l-c,r)+ w(l,r+c)\)</span>，则 <span class="math inline">\(w\)</span> 满足四边形不等式。</li></ul><p>用于题目：</p><ul><li><strong>性质一</strong>：若 <span class="math inline">\(f_i\)</span> 满足四边形不等式（或其反式），那么最优决策点 <span class="math inline">\(p_i\)</span> 与 <span class="math inline">\(i\)</span> 有单调关系。</li><li><strong>性质二</strong>：当 <span class="math inline">\(i\)</span> 变化时，每个 <span class="math inline">\(j\)</span> 带来贡献的相对大小 rank 不变。亦作：若 <span class="math inline">\(j_1\)</span> 相对于 <span class="math inline">\(j_2\)</span> 对 <span class="math inline">\(i\)</span> 更优，对于任意 <span class="math inline">\(i&#39;\)</span>，<span class="math inline">\(j_1\)</span> 相对于 <span class="math inline">\(j_2\)</span> 对 <span class="math inline">\(i&#39;\)</span> 更优。</li></ul><hr /><h3 id="在优化-dp-之前">在优化 DP 之前</h3><ul><li><p>首先我必须要提一嘴。由于我第一次接触『四边形不等式』是在四年前，看到『石子合并的 <span class="math inline">\(n^2\)</span> 做法』时。然而，这一题的 DP 本身有一个特殊性质，即贡献是一个以决策点为极值的凸函数；这直接导致我误以为这是四边形不等式本身带来的性质，导致我在理解上浪费了很多时间。<strong>四边形不等式带来的性质，只有上述两条！</strong></p>当然这也告诉我们，如果你发现『贡献是一个以决策点为极值的凸函数』，你就可以用类似石子合并中的线性转移完成问题。</li><li><p>『满足四边形不等式』并不能等价于『决策单调性』。决策单调性并不具备性质二。</p><p>也就是说，如果只满足决策单调性，只有最优决策点是单调的，但贡献函数随着 <span class="math inline">\(i\)</span> 的变化，其形状会有很大的变动。</p></li></ul><hr /><h3 id="优化-dp分治">优化 DP：分治</h3><p>主要适用于 <span class="math inline">\(f_{i}=g_j+w(j,i)\)</span> 的场景，其中 <span class="math inline">\(g\)</span> 是与 <span class="math inline">\(f\)</span> 无关的函数。</p><p>对于分治范围 <span class="math inline">\([l,r]\)</span> 和其决策点范围 <span class="math inline">\([L_p,R_p]\)</span>，首先把暴力 <span class="math inline">\(mid\)</span> 的决策点 <span class="math inline">\(p_{mid}\)</span> 找出来。</p><p>接着对于 <span class="math inline">\([l,mid)\)</span> 和 <span class="math inline">\((mid,R]\)</span>，分别在 <span class="math inline">\([L_p,p_{mid}]\)</span> 和 <span class="math inline">\([p_{mid},R_p]\)</span> 里找决策点（注意两边都是闭的）。递归地做。</p><p>这时候你肯定就会怀疑了，主播主播，虽然你的区间每次在减半，但决策点范围并不是均分的，还会被共用，复杂度真的对吗？</p><p>对的兄弟，对的。观察搜索树，你会发现虽然 <span class="math inline">\(p_{mid}\)</span> 会被给两个儿子共用，但是在任何一层中，被重复经过的点只会出现在两个区间的交界处。也就是说每整层大概遍历 <span class="math inline">\(2n\)</span> 次。是不是很对了。</p><hr /><h4 id="例yet-another-minimization-problem">例：Yet Another Minimization Problem</h4><p><a href="https://codeforces.com/problemset/problem/868/F" class="uri">https://codeforces.com/problemset/problem/868/F</a></p><details><p><summary>我的天哪！是罕见的四级标题！</summary></p><p>笑点解析：这个人因为懒得写 CSS 所以只写了经常用的 h2 和 h3 的样式，现在迫不得已用 h4 被倒逼去写了 h4 的 CSS。</p></details><p>发现 <span class="math inline">\(k\le 20\)</span>，所以可以不用写 WQS 二分。令 <span class="math inline">\(f_{i,j}\)</span> 表示第 <span class="math inline">\(i\)</span> 段分在 <span class="math inline">\(j\)</span> 处的代价，那么有 <span class="math inline">\(f_{i,j}=\min\{f_{i-1,l}+w(l+1,j)\}\)</span>，分治解决。</p><p>接着发现问题：<span class="math inline">\(w(l+1,j)\)</span> 并不能很快地求出来；然后注意到这个代价的形式很莫队（其实在看到这个题的时候就会有莫队的想法），考虑使用莫队移动端点的方式解决问题。由于分治中查询的区间两端单增，每层的总移动次数是 <span class="math inline">\(O(n)\)</span> 的，总复杂度就是 <span class="math inline">\(O(nk\log n)\)</span> 的。</p><details><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;const long long inf = 1e12;int main() &#123;#ifdef ONLINE_JUDGE    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr), std::cout.tie(nullptr);#else    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);#endif    int n, k;    std::cin &gt;&gt; n &gt;&gt; k;    std::vector&lt;int&gt; a(n + 1);    for (int i = 1; i &lt;= n; ++i)        std::cin &gt;&gt; a[i];    std::vector&lt;long long&gt; cnt(n + 1);    std::vector&lt;std::vector&lt;int&gt; &gt; p(k + 1, std::vector&lt;int&gt; (n + 1));    std::vector&lt;std::vector&lt;long long&gt; &gt; f(k + 1, std::vector&lt;long long&gt; (n + 1, inf));    auto w = [&amp;](int l, int r) &#123;        static int L = 1, R = 0;        static long long res = 0ll;        for (; L &gt; l; --L, res -= cnt[a[L]] * (cnt[a[L]] - 1) / 2, ++cnt[a[L]], res += cnt[a[L]] * (cnt[a[L]] - 1) / 2);        for (; R &gt; r; res -= cnt[a[R]] * (cnt[a[R]] - 1) / 2, --cnt[a[R]], res += cnt[a[R]] * (cnt[a[R]] - 1) / 2, --R);        for (; R &lt; r; ++R, res -= cnt[a[R]] * (cnt[a[R]] - 1) / 2, ++cnt[a[R]], res += cnt[a[R]] * (cnt[a[R]] - 1) / 2);        for (; L &lt; l; res -= cnt[a[L]] * (cnt[a[L]] - 1) / 2, --cnt[a[L]], res += cnt[a[L]] * (cnt[a[L]] - 1) / 2, ++L);        return res;    &#125;;    f[0][0] = 0ll;    for (int t = 1; t &lt;= k; ++t) &#123;        std::function&lt;void(int, int, int, int)&gt; calc = [&amp;](int l, int r, int lp, int rp) &#123;            if (l &gt; r)                return;            if (l == r) &#123;                for (int i = lp; i &lt;= rp &amp;&amp; i &lt; l; ++i)                    if (f[t - 1][i] + w(i + 1, l) &lt; f[t][l])                        f[t][l] = f[t - 1][i] + w(i + 1, l), p[t][l] = i;                return;            &#125;            int mid = (l + r) &gt;&gt; 1;            for (int i = lp; i &lt;= rp &amp;&amp; i &lt; mid; ++i)                if (f[t - 1][i] + w(i + 1, mid) &lt; f[t][mid])                    f[t][mid] = f[t - 1][i] + w(i + 1, mid), p[t][mid] = i;            calc(l, mid - 1, lp, p[t][mid]), calc(mid + 1, r, p[t][mid], rp);            return;        &#125;;        calc(1, n, 0, n - 1);    &#125;    std::cout &lt;&lt; f[k][n] &lt;&lt; &#39;\n&#39;;    return 0;&#125;</code></pre></details><hr /><h3 id="优化-dp单调数据结构">优化 DP：单调数据结构</h3><p>有的时候会出现 <span class="math inline">\(f_{i}=f_{j}+w(j,i)\)</span> 的结构，也就是 <span class="math inline">\(f\)</span> 的取值与自己有关。</p><p>这种情况我们通常选择填表法，求出 <span class="math inline">\(f_i\)</span> 后找到 <span class="math inline">\(i\)</span> 是哪些点的最优决策（那么显然这些点是一段连续区间）。用 <span class="math inline">\((i,l_i,r_i)\)</span> 这个三元组表示当前算出来的 <span class="math inline">\(i\)</span> 管辖的范围。</p><p>这是什么意思呢？结合性质二，每当我们手上拿到一个新的 <span class="math inline">\(i\)</span>，那么推出来其管辖范围右端点就会是 <span class="math inline">\(n\)</span>。接着想办法找到左端点，同样利用性质二，二分出最靠左的一个 <span class="math inline">\(j\)</span>，满足之前算出来的决策点没有 <span class="math inline">\(i\)</span> 优，那么 <span class="math inline">\([j,n]\)</span> 就是当前条件下 <span class="math inline">\(i\)</span> 的管辖范围。</p><p>在队列里加入当前版本的整个三元组序列就可以方便地完成这个过程。为寻找当前元素的答案，需要将队头上，管辖范围完全早于当前元素的弹出去。由于维护的过程和单调队列很像，所以也有人直接把这里的队列叫单调队列。</p><p>视题目不同，也可能用到单调栈，也有可能不用二分（例如满足前两种特化的情况）。goto <a href="/20250715/#a---yakiniku-restaurants">Yakiniku Restaurants</a>。</p><hr /><h4 id="例诗人小g">例：诗人小G</h4><p><a href="https://www.luogu.com.cn/problem/P1912" class="uri">https://www.luogu.com.cn/problem/P1912</a></p><p><del>我觉得给出字符串内容的唯一价值是让出题人欣赏白日依山尽</del></p><p>令 <span class="math inline">\(f_{j}\)</span> 为某一行分在第 <span class="math inline">\(j\)</span> 句处的代价，那么有 <span class="math inline">\(f_{j}=\min\limits_{k&lt;j}\left\{f_{k}+|(s_j-s_k+j-k-1)-L|^P\right\}\)</span>。</p><p>那么就可以考虑单调队列 + 二分了。需要注意无穷大之间的大小比较，我写这个写红温了，直接用指数项相对大小来代替了，似乎可以过。</p><details><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;const long long inf = 1000000000000000001ll;int main() &#123;#ifdef ONLINE_JUDGE    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr), std::cout.tie(nullptr);#else    std::freopen(&quot;P1912_2.in&quot;, &quot;r&quot;, stdin);    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);#endif    int T;    for (std::cin &gt;&gt; T; T--; ) &#123;        int n, l, p;        std::cin &gt;&gt; n &gt;&gt; l &gt;&gt; p;        long long to;        switch (p) &#123; // 会有精度问题        case 1:            to = 1e18;            break;        case 2:            to = 1e9;            break;        case 3:            to = 1e6;            break;        case 4:            to = 31622;            break;        case 5:            to = 3981;            break;        case 6:            to = 1e3;            break;        case 7:            to = 372;            break;        case 8:            to = 177;            break;        case 9:            to = 100;            break;        default:            to = 63;            break;        &#125;        std::vector&lt;int&gt; s(n + 1);        std::vector&lt;std::string&gt; a(n + 1);        for (int i = 1; i &lt;= n; ++i)            std::cin &gt;&gt; a[i], s[i] = (int)a[i].length();        std::partial_sum(s.begin() + 1, s.end(), s.begin() + 1);        struct node &#123; int i, l, r; &#125;;        std::vector&lt;node&gt; q(n + 1);        int h = 0, t = -1;        q[++t] = &#123; 0, 1, n &#125;;        auto qkp = [&amp;](long long x, int y) &#123;            if (x &gt; to)                return inf;            auto res(1ll);            for (; y--; res *= x);            return res;        &#125;;        std::vector&lt;int&gt; pre(n + 1);        std::vector&lt;long long&gt; f(n + 1);        auto calc = [&amp;](int k, int j) &#123;            return std::min(inf, f[k] + qkp(std::abs(s[j] - s[k] + j - k - 1 - l), p));        &#125;;        auto less = [&amp;](int k1, int j1, int k2, int j2) &#123;            auto t1(calc(k1, j1)), t2(calc(k2, j2));            if (t1 == inf &amp;&amp; t2 == inf)                return std::abs(s[j1] - s[k1] + j1 - k1 - 1 - l) &lt; std::abs(s[j2] - s[k2] + j2 - k2 - 1 - l);            return t1 &lt; t2;        &#125;;        for (int i = 1; i &lt;= n; ++i) &#123;            for (; h &lt;= t &amp;&amp; q[h].r &lt; i; ++h);            f[i] = calc(q[h].i, i), pre[i] = q[h].i;            for (; h &lt;= t &amp;&amp; q[t].l &gt; i &amp;&amp; less(i, q[t].l, q[t].i, q[t].l); --t)                q[t - 1].r = q[t].r;            for (int l = std::max(q[t].l, i + 1), r = q[t].r, mid; l &lt;= r; ) &#123;                mid = (l + r) &gt;&gt; 1;                if (less(i, mid, q[t].i, mid))                    r = q[t].r = mid - 1, q[t + 1] = &#123; i, mid, n &#125;;                else                    l = mid + 1;            &#125;            if (q[t + 1].i == i)                ++t;        &#125;        if (f[n] &gt;= inf)            std::cout &lt;&lt; &quot;Too hard to arrange&quot; &lt;&lt; &#39;\n&#39;;        else &#123;            std::cout &lt;&lt; f[n] &lt;&lt; &#39;\n&#39;;            std::function&lt;void(int)&gt; print = [&amp;](int x) &#123;                if (x == 0)                    return;                print(pre[x]);                for (int i = pre[x] + 1; i &lt;= x; ++i) &#123;                    std::cout &lt;&lt; a[i];                    if (i != x)                        std::cout &lt;&lt; &#39; &#39;;                &#125;                std::cout &lt;&lt; &#39;\n&#39;;                return;            &#125;;            print(n);        &#125;        std::cout &lt;&lt; &quot;--------------------&quot;;        if (T)            std::cout &lt;&lt; &#39;\n&#39;;    &#125;    return 0;&#125;</code></pre></details><p>需要注意，本题也可以再加一个『恰好分 <span class="math inline">\(k\)</span> 段』的限制，直接在外层套一个 WQS 二分就好了，参见 <a href="https://www.luogu.com.cn/problem/P6246">邮局 加强版 加强版</a>。</p><h3 id="d1d-dp-优化">2D/1D DP 优化</h3><p>若存在 <span class="math inline">\(f(i,j)=\min\limits_{k&lt;j} f(i-1,k)+w(k+1,j)\)</span>，且 <span class="math inline">\(w\)</span> 满足四边形不等式：</p><ul><li><p>设 <span class="math inline">\(p(i,j)\)</span> 为最优决策点，那么有 <span class="math inline">\(p(i,j)\le p(i,j+1)\le p(i+1,j+1)\)</span>，亦作 <span class="math inline">\(p(i,j-1)\le p(i,j)\le p(i+1,j)\)</span>。</p><p>此时可以 <span class="math inline">\(O(nm)\)</span> 解决问题：</p><p><img src="image.png" /></p></li><li><p>若 <span class="math inline">\(i\)</span> 固定，<span class="math inline">\(f_i(j)\)</span> 为凸函数。（例：邮局 加强版 加强版）</p><p>goto <a href="/20250707/">DP 凸优化</a>。</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> DP </tag>
            
            <tag> DP 优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DP 凸优化</title>
      <link href="/20250707/"/>
      <url>/20250707/</url>
      
        <content type="html"><![CDATA[<p>袜，这篇文章一下子创建了三个新 tag。</p><span id="more"></span><hr /><h2 id="什么是凸函数">什么是凸函数</h2><h3 id="定义">定义</h3><p>在信息学中研究的凸函数大抵是只在正整数域上有定义的，所以只能直接摒弃导函数的概念了。</p><p>若斜率递增，换言之，差分数组递增，认为函数是凸的（好反直觉）。</p><p>或者看看符号化的定义：若对于任意 <span class="math inline">\(\lambda\in[0,1]\)</span>，函数 <span class="math inline">\(f(x)\)</span> 均满足：</p><p><span class="math display">\[f(\lambda x+(1-\lambda) y)\le \lambda f(x)+(1-\lambda) f(y).\]</span></p><p>或等价地：</p><p><span class="math display">\[f(x)-f(x - 1)\le f(x + 1) - f(x)\]</span></p><p>那么认为 <span class="math inline">\(f\)</span> 是凸函数。</p><p>因为凹凸在性质上没区别，所以 <strong>下文施行暴政，将凹函数和凸函数统称为凸函数</strong>。</p><hr /><h3 id="判定">判定</h3><p>对于具体情境下的问题，怎么判断 DP 数组是否关于其某一维为凸函数？</p><ul><li>相信相信的力量（最常用）。</li><li><p>对于分段问题，证明分出来的每一段满足四边形不等式。</p><em>值得一提的是，数学上不认为满足四边形不等式能够推出函数为凸。但这是信息学.jpg</em></li><li><p>其由两个凸函数线性相加得到：</p><p>对于 <span class="math inline">\(\forall\, \lambda,\mu\ge 0\)</span> 和凸函数 <span class="math inline">\(f,g\)</span>，若 <span class="math inline">\(h=\lambda f+\mu g\)</span>，则 <span class="math inline">\(h\)</span> 为凸函数。</p>此外，此时 <span class="math inline">\(h\)</span> 的差分数组和 <span class="math inline">\(f,g\)</span> 差分数组也满足上述关系。</li><li>其是两个凸函数的 <a href="#闽可夫斯基和">闽可夫斯基和</a>。</li><li><p>其由两个凸函数线性 max 得到。</p><p>对于两个凸函数的线性 min，一般不是凸函数，甚至可能是凹的。</p></li></ul><hr /><h3 id="性质">性质</h3><ul><li>最值为唯一极值。</li><li>斜率 / 差分数组具有单调性。</li></ul><p>在解题中主要用到的大概就是上面两条。</p><hr /><h2 id="wqs-二分">WQS 二分</h2><h3 id="主要任务">主要任务</h3><blockquote><p>例：把 <span class="math inline">\(a_{1\sim n}\)</span> 分为恰好 <span class="math inline">\(k\)</span> 段，每段的代价为 <span class="math inline">\(sum^2+c\)</span>（<span class="math inline">\(c\)</span> 为给定的常数），问最小代价。<span class="math inline">\(n\le 2\times 10^5,a_i\le 10^9\)</span>。</p></blockquote><p>如果对段数没有要求，可以用斜优 <span class="math inline">\(O(n)\)</span> 做。</p><p>加上了 <span class="math inline">\(k\)</span> 的限制，DP 变成二维的，令 <span class="math inline">\(f_{i,j}\)</span> 表示在 <span class="math inline">\(i\)</span> 处分第 <span class="math inline">\(j\)</span> 段，可以在第一维斜率优化，做到 <span class="math inline">\(O(nk)\)</span>；亦或发现 <span class="math inline">\((i,j)\)</span> 有决策单调性，然后四边形不等式优化到 <span class="math inline">\(O(n^2)\)</span>。</p><p>我们发现 <span class="math inline">\(f\)</span> 关于 <span class="math inline">\(j\)</span> 这一维是凸的（而非上文的 <span class="math inline">\((i,j)\)</span>），故将 <span class="math inline">\(f(n,j)\)</span> 关于 <span class="math inline">\(j\)</span> 的函数提取出来（记为 <span class="math inline">\(f_n(j)\)</span>）。发现只有最高点是可以一次斜优快速求出来的，故可以认为在当前复杂度限制下，整个函数除了最高点以外都是未知的（注意可以在 DP 时记录极值点的横坐标，即分了几段）。</p><p>我们给每个 <span class="math inline">\(f_n(j)\)</span> 加上 <span class="math inline">\(\alpha\cdot j\)</span>（在本题中即将 <span class="math inline">\(c\gets c+k\)</span>），勉强可以认为 <span class="math inline">\(\alpha\cdot j\)</span> 是凸的，所以新函数 <span class="math inline">\(f&#39;_n(j)\)</span> 也是凸的。若 <span class="math inline">\(k&gt;0\)</span>，可以感受到极值点向左偏移，且随着 <span class="math inline">\(k\)</span> 的增大，极值点不会右移；<span class="math inline">\(k&lt;0\)</span> 时同理。</p><p>结合几何观点，在 <span class="math inline">\(f_n\)</span> 上的极值点可以用斜率为 <span class="math inline">\(0\)</span> 的直线切到；而加上 <span class="math inline">\(\alpha\cdot j\)</span> 的过程，其实就是切线斜率减去 <span class="math inline">\(\alpha\)</span> 的过程。相当于令切线斜率为 <span class="math inline">\(-\alpha\)</span>，看看能切到哪里。</p><p>故可以二分一个合适的 <span class="math inline">\(k\)</span>，使得极值点的横坐标为 <span class="math inline">\(k\)</span>。此时 <span class="math inline">\(f&#39;_n(k)-\alpha\cdot k\)</span> 即为待求。</p><hr /><p>WQS 二分参与的问题一般以如下形式呈现：</p><blockquote><p>给定序列，将其恰好分为 <span class="math inline">\(k\)</span> 段 / 恰好选 <span class="math inline">\(k\)</span> 个，求最大 / 最小代价。</p></blockquote><p>题目要求最大 / 最小值一般能够反映函数的凹凸性，可以根据这一点来猜。</p><hr /><h3 id="细节处理">细节处理</h3><p>考虑如下凸函数：</p><p><img src="1.png" /></p><ul><li>显然对于『凸出来』的点（即图中除了 <span class="math inline">\(E,H\)</span> 以外的点），能切到的直线斜率为一个范围；而位于直线上的点（途中 <span class="math inline">\(E,H\)</span>），能切到的直线斜率更是定死了。所以这要求你的二分精度需要略高一点。</li><li><p>对于 <span class="math inline">\(E\)</span>（或 <span class="math inline">\(H\)</span>），不能找到只过它一点的切线。根据 DP 的写法，记录的横坐标可能是最小的 <span class="math inline">\(D\)</span>，也可能是最大的 <span class="math inline">\(F\)</span>，此时你可以：</p><ul><li>同时记录最小和最大的横坐标，看看 <span class="math inline">\(k\)</span> 在不在中间。</li><li><p>题目要求最大代价时，记录最大横坐标，二分到一个极值点 <span class="math inline">\(k&#39;\ge k\)</span> 时，显然 <span class="math inline">\(\alpha&#39;\ge \alpha\)</span>，用 <span class="math inline">\(f&#39;_n(k&#39;)-\alpha&#39;\cdot k\)</span> 更新答案（是赋值而不是取最值）；求最小代价时同理。</p><p>主要是需要记住斜率是 <span class="math inline">\(\alpha\)</span> 的相反数，<del>实在搞不清对应关系可以都试一试</del></p></li></ul></li></ul><hr /><h3 id="例种树">例：种树</h3><p><a href="https://www.luogu.com.cn/problem/P1484" class="uri">https://www.luogu.com.cn/problem/P1484</a></p><p>首先，函数是凸的——感性理解即可。</p><p>接着，要求的是 <span class="math inline">\(\le k\)</span> 时的最值。分为两种情况：<span class="math inline">\(k\)</span> 是否右于原函数极值点。</p><ul><li>若 <span class="math inline">\(k\)</span> 右于原函数极值点，则原函数极值点为答案。</li><li>否则，<span class="math inline">\(k\)</span> 为答案。</li></ul><p>好消息是整数域上一定有解（最后答案为整、倒推即可），所以不用打浮点数二分了。</p><details><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;const int lim = 1e6;const long long inf = 1e18;int main() &#123;#ifdef ONLINE_JUDGE    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr), std::cout.tie(nullptr);#else    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);#endif    int n, k;    std::cin &gt;&gt; n &gt;&gt; k;    std::vector&lt;long long&gt; a(n + 1);    for (int i = 1; i &lt;= n; ++i)        std::cin &gt;&gt; a[i];    auto calc = [&amp;](int c) &#123;        std::vector&lt;std::pair&lt;long long, int&gt; &gt; f(n + 1);        auto mx = f.front();        auto upd = [&amp;](auto &amp;x, auto y) &#123;            if (y.first &gt; x.first || (y.first == x.first &amp;&amp; y.second &lt; x.second))                x = y;            return;        &#125;;        for (int i = 1; i &lt;= n; ++i) &#123;            f[i].first = mx.first + a[i] + c;            f[i].second = mx.second + 1;            upd(mx, f[i - 1]);        &#125;        upd(mx, f[n]);        return mx;    &#125;;    auto t(calc(0));    if (t.second &lt;= k) &#123;        std::cout &lt;&lt; t.first &lt;&lt; &#39;\n&#39;;        return 0;    &#125;    auto res(-inf);    for (int l = -lim, r = lim, mid; l &lt;= r; ) &#123;        mid = (l + r) &gt;&gt; 1;        auto t = calc(mid);        if (t.second &lt;= k)            res = t.first - (long long)mid * k, l = mid + 1;        else            r = mid - 1;    &#125;    std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;    return 0;&#125;</code></pre></details><hr /><h3 id="例raper">例：Raper</h3><p><a href="https://www.luogu.com.cn/problem/P4694" class="uri">https://www.luogu.com.cn/problem/P4694</a></p><p>给所有光盘附一个奖励 <span class="math inline">\(mid\)</span>，进行 WQS 二分。</p><p>然后内层就和 <a href="#例序列-sequence">sequence</a> 差得不是特别多，所以考虑反悔贪心。（？）</p><p>把路过的 <span class="math inline">\(-a_j\)</span> 丢到大根堆里，尝试和 <span class="math inline">\(b_i\)</span> 配对。如果 <span class="math inline">\(mid-a_i-b_i\ge 0\)</span> 那么暂时配对，顺便把 <span class="math inline">\(b_i-mid\)</span> 丢进去用于反悔，若 <span class="math inline">\(b_{i&#39;}\)</span> 选中了 <span class="math inline">\(b_i-mid\)</span> 说明反悔，将 <span class="math inline">\(a_j\)</span> 与 <span class="math inline">\(b_{i&#39;}\)</span> 配对。</p><p>贪心的时候需要记录已经配的对数，优先队列中需要对 <span class="math inline">\(-a_j\)</span> 和 <span class="math inline">\(b_i-mid\)</span> 打标记进行区分，匹配到前者时才增加成功对数。</p><p>发现整数域上仍然必有解（答案为整，倒推），不用打浮点数二分 neiher.</p><details><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;const long long inf = 2e9 + 5;int main() &#123;#ifdef ONLINE_JUDGE    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr), std::cout.tie(nullptr);#else    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);#endif    int n, k;    std::cin &gt;&gt; n &gt;&gt; k;    std::vector&lt;int&gt; a(n + 1), b(n + 1);    for (int i = 1; i &lt;= n; ++i)        std::cin &gt;&gt; a[i];    for (int i = 1; i &lt;= n; ++i)        std::cin &gt;&gt; b[i];    auto calc = [&amp;](long long mid) &#123;        std::priority_queue&lt;std::pair&lt;long long, int&gt; &gt; q;        int cnt = 0;        auto res(0ll);        for (int i = 1; i &lt;= n; ++i) &#123;            q.emplace(-a[i], 1);            auto [v, ty] = q.top();            if (mid + v - b[i] &gt;= 0) &#123;                q.pop(), cnt += ty;                res += mid + v - b[i], q.emplace(b[i] - mid, 0);            &#125;        &#125;        return std::make_pair(cnt, res);    &#125;;    auto res(inf);    for (long long l = 1ll, r = inf, mid; l &lt;= r; ) &#123;        mid = (l + r) &gt;&gt; 1;        auto t(calc(mid));        if (t.first &gt;= k)            r = mid - 1, res = -(t.second - k * mid);        else            l = mid + 1;    &#125;    std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;    return 0;&#125;</code></pre></details><hr /><h3 id="区间分拆问题">区间分拆问题</h3><p>目标：尝试将 <span class="math inline">\(a_{1\sim n}\)</span> 分割成恰好 <span class="math inline">\(k\)</span> 段，定义 <span class="math inline">\(w(i,j)\)</span> 为将 <span class="math inline">\([i,j]\)</span> 作为一段的代价，求代价最值。其中 <span class="math inline">\(w(i,j)\)</span> 满足四边形不等式。</p><p>不妨设求最小代价。定义 <span class="math inline">\(f(i,j)\)</span> 在 <span class="math inline">\(i\)</span> 处分第 <span class="math inline">\(j\)</span> 段，那么有：</p><p><span class="math display">\[f(i,j)=\min(f(i-1,p-1)+w(p,j)).\]</span></p><blockquote><p>有定理：若 <span class="math inline">\(w(i,j)\)</span> 满足四边形不等式，那么有 <span class="math inline">\(f(i-1,j)\le f(i,j)\le f(i,j+1)\)</span>，从 <span class="math inline">\(f\)</span> 定义出发很好感性理解。</p></blockquote><p>那么可以从这一点出发，<span class="math inline">\(p\)</span> 这一维就可以被摊掉，做到 <span class="math inline">\(O(n(n+m))\)</span>。</p><blockquote><p>有定理：若 <span class="math inline">\(w(i,j)\)</span> 满足四边形不等式，那么 <span class="math inline">\(f_i(j)\)</span> 是凸函数。</p></blockquote><p>那很好了。直接冲刺 WQS 即可。</p><hr /><h2 id="闽可夫斯基和">闽可夫斯基和</h2><p>给定两个凸函数（当然是指 OI 中那种长得很直的函数），将它们的『边』拆下来过后，以某种方式拼在一起，使得最后得到一个新的凸函数。</p><p>按每条『边』的斜率归并一下就可以得到，显然答案存在且唯一，这个过程被称为闽可夫斯基和。可以发现这是一种最值 - 加卷积。</p><p>假设我们要求的 DP 数组是两个已知的子数组以类似的方法卷起来的，最后要求完整的 DP 数组（而非 WQS 中的单点值），就可以考虑闽可夫斯基和。</p><p>发现这个结构是很适合归并的，使用归并要求状态中含有版本维、因变量维。</p><hr /><h3 id="例its-mooin-time-p">例：It's Mooin' Time P</h3><p><a href="https://www.luogu.com.cn/problem/P11459" class="uri">https://www.luogu.com.cn/problem/P11459</a></p><p>定义 <span class="math inline">\(w_i\)</span> 为将 <span class="math inline">\([i,i+L)\)</span> 改为 <code>MOO</code> 的代价，问题转化为选取 <span class="math inline">\(1\sim \frac nL\)</span> 个不重区间的最小代价和。</p><p>尝试归并，每次将 <span class="math inline">\([l,mid]\)</span> 和 <span class="math inline">\((mid, r]\)</span> 卷起来。但是会有一点问题：如果恰好有区间卡在中间呢？</p><p>可以令 <span class="math inline">\(f_{l,r,0/1/2,0/1/2}(i)\)</span> 表示在 <span class="math inline">\([l,r]\)</span> 内选了 <span class="math inline">\(i\)</span> 个 <code>MOO</code>，且两侧最远的被选点距离端点为 <span class="math inline">\(0/1/\ge 2\)</span> 的 DP 值。然后可以进行相应的讨论、平移、闽可夫斯基和，最后将所有情况线性取 max 得到这一层的答案，容易发现得到的答案也是凸的。</p><details><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;const long long inf = 1e18;int L;int main() &#123;#ifdef ONLINE_JUDGE    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr), std::cout.tie(nullptr);#else    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);#endif    int n;    std::cin &gt;&gt; L &gt;&gt; n;    std::vector&lt;int&gt; a(n + 1);    std::vector&lt;char&gt; t(n + 1);    std::vector&lt;long long&gt; w(n + 1);    for (int i = 1; i &lt;= n; ++i)        std::cin &gt;&gt; t[i];    for (int i = 1; i &lt;= n; ++i)        std::cin &gt;&gt; a[i];    for (int i = 1; i &lt;= n - L + 1; ++i) &#123;        w[i] = a[i] * (t[i] != &#39;M&#39;);        for (int j = i + 1; j &lt; i + L; ++j)            w[i] += a[j] * (t[j] != &#39;O&#39;);        // printf(&quot;[%d, %d]: %lld\n&quot;, i, i + L - 1, w[i]);    &#125;    if (L == 1) &#123;        std::sort(w.begin() + 1, w.end());        auto s(0ll);        for (int i = 1; i &lt;= n; ++i) &#123;            s += w[i];            std::cout &lt;&lt; s &lt;&lt; &#39;\n&#39;;        &#125;        return 0;    &#125;    using arr = std::vector&lt;long long&gt;;    using brr = std::vector&lt;arr&gt;;    using crr = std::vector&lt;brr&gt;;    struct node &#123;        crr f;        node(int len): f(L, brr(L, arr(len, inf))) &#123;            for (int i = 0; i &lt; L; ++i)                for (int j = 0; j &lt; L; ++j)                    f[i][j][0] = 0ll;            return;        &#125;        brr&amp; operator[] (int q) &#123; return f[q]; &#125;    &#125;;    auto upd = [&amp;](arr &amp;x, arr y) &#123;        if (x.size() &lt; y.size())            x.resize(y.size(), inf);        for (int i = 0; i &lt; (int)y.size(); ++i)            x[i] = std::min(x[i], y[i]);        return;    &#125;;    auto merge = [&amp;](arr l, arr r) &#123;        arr out((int)(l.size() + r.size()) - 1), dl(l.size()), dr(r.size());        for (int i = 1; i &lt; (int)l.size(); ++i)            dl[i] = l[i] - l[i - 1];        for (int i = 1; i &lt; (int)r.size(); ++i)            dr[i] = r[i] - r[i - 1];        std::merge(dl.begin() + 1, dl.end(), dr.begin() + 1, dr.end(), out.begin() + 1);        out[0] = l[0] + r[0];        std::partial_sum(out.begin(), out.end(), out.begin());        return out;    &#125;;    std::function&lt;node(int, int)&gt; calc = [&amp;](int l, int r) &#123;        if (r - l + 1 &lt; 2 * L) &#123;            node res(1);            for (int ll = 0; ll &lt; L; ++ll)                for (int rr = 0; rr &lt; L; ++rr)                    if (l + ll &lt;= r - rr - L + 1) &#123;                        res[ll][rr].resize(2, inf);                        for (int i = l + ll; i &lt;= r - rr - L + 1; ++i)                            res[ll][rr][1] = std::min(res[ll][rr][1], w[i]);                        // printf(&quot;[%d, %d]: (%d, %d) = %lld\n&quot;, l, r, ll, rr, res[ll][rr][1]);                    &#125;            // for (int i = 0; i &lt; L; ++i)            //     if (l + i + L - 1 &lt;= r) &#123;            //         printf(&quot;[%d, %d]: (%d, %d) = %lld\n&quot;, l, r, i, r - (l + i + L - 1), w[l + i]);            //         res[i][r - (l + i + L - 1)].emplace_back(w[l + i]);            //     &#125;            return res;        &#125;           int mid = (l + r) &gt;&gt; 1;        node tl(calc(l, mid)), tr(calc(mid + 1, r)), res((r - l + 1) / L + 1);        for (int ll = 0; ll &lt; L; ++ll)            for (int rr = 0; rr &lt; L; ++rr)                res[ll][rr] = merge(tl[ll][0], tr[0][rr]);        for (int ll = 0; ll &lt; L; ++ll)            for (int rr = 0; rr &lt; L; ++rr)                for (int i = 1; i &lt; L &amp;&amp; i &lt; mid; ++i)                    upd(res[ll][rr], merge(merge(tl[ll][i], tr[L - i][rr]), &#123; 0, w[mid - i + 1] &#125;));        for (int ll = 0; ll &lt; L; ++ll)            for (int rr = L - 1; rr; --rr)                upd(res[ll][rr - 1], res[ll][rr]);        for (int rr = 0; rr &lt; L; ++rr)            for (int ll = L - 1; ll; --ll)                upd(res[ll - 1][rr], res[ll][rr]);        // for (int i = 0; i &lt; L; ++i)        //     for (int j = 0; j &lt; L; ++j) &#123;        //         printf(&quot;  (%d, %d): &quot;, i, j);        //         for (auto p : res[i][j])        //             printf(&quot;%lld &quot;, p);        //         puts(&quot;&quot;);        //     &#125;        return res;    &#125;;    auto res(calc(1, n));    for (int i = 1; i &lt;= n / L; ++i)        std::cout &lt;&lt; res[0][0][i] &lt;&lt; &#39;\n&#39;;    return 0;&#125;</code></pre></details><hr /><h3 id="例假人">例：假人</h3><p><a href="http://222.180.160.110:61235/problem/47728" class="uri">http://222.180.160.110:61235/problem/47728</a></p><p>令 <span class="math inline">\(f_{i,j}\)</span> 表示前 <span class="math inline">\(i\)</span> 组选完占了 <span class="math inline">\(j\)</span> 体积的最大价值。那么有 <span class="math inline">\(f_{i,j}=\max\{f_{i-1,k}+a_{i,j-k}\}\)</span>。</p><p><em>袜，这个东西好凸的样子！啊？居然不是凸的？</em></p><p>事实上，有结论：若干个体积为 <span class="math inline">\(0\sim 4\)</span> 的物品做背包，可以凑出值域内任意 <span class="math inline">\(24\)</span> 的倍数。所以先把体积全部 <span class="math inline">\(-1\)</span>，然后就可以得到体积为 <span class="math inline">\(0\sim 4\)</span> 的物品。然后会发现他们按照模 <span class="math inline">\(12\)</span> 的余数分别是凸的。</p><p>能感受到恶意了。然后就可以枚举体积，再闽可夫斯基和了。同样需要在状态中引入作为版本号的 <span class="math inline">\([l,r]\)</span> 维，显然因变量是体积、版本号是组数。</p><details><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;const long long inf = 1e18;int main() &#123;#ifdef ONLINE_JUDGE    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr), std::cout.tie(nullptr);#else    std::freopen(&quot;fake2.in&quot;, &quot;r&quot;, stdin);    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);#endif    int n, m = 0;    std::cin &gt;&gt; n;    std::vector&lt;int&gt; siz(n + 1);    std::vector&lt;std::vector&lt;int&gt; &gt; a(n + 1);    for (int i = 1; i &lt;= n; ++i) &#123;        std::cin &gt;&gt; siz[i], m += siz[i];        a[i].resize(siz[i] + 1);        for (int j = 1; j &lt;= siz[i]; ++j)            std::cin &gt;&gt; a[i][j];    &#125;    using arr = std::vector&lt;long long&gt;;    struct node &#123;        std::vector&lt;arr&gt; f;        node(): f(12) &#123;&#125;        arr &amp;operator[] (int q) &#123;            return f[q];        &#125;    &#125;;    auto merge = [&amp;](arr &amp;p, arr &amp;q) &#123;        arr res((int)(p.size() + q.size()) - 1), dp(p.size()), dq(q.size());        std::adjacent_difference(p.begin(), p.end(), dp.begin());        std::adjacent_difference(q.begin(), q.end(), dq.begin());        std::merge(dp.begin() + 1, dp.end(), dq.begin() + 1, dq.end(), res.begin() + 1, std::greater&lt;long long&gt; ());        res[0] = p[0] + q[0];        std::partial_sum(res.begin(), res.end(), res.begin());        return res;    &#125;;    auto upd = [&amp;](arr y, arr &amp;x, int tag) &#123;        if (tag)            y.insert(y.begin(), -inf);        if (y.size() &gt; x.size())            x.resize(y.size(), -inf);        for (int i = 0; i &lt; (int)y.size(); ++i)            x[i] = std::max(x[i], y[i]);        return;    &#125;;    std::function&lt;node(int, int)&gt; calc = [&amp;](int l, int r) &#123;        if (l == r) &#123;            node res;            for (int i = 1; i &lt;= siz[l]; ++i)                res[i - 1].push_back(a[l][i]);            return res;        &#125;        int mid = (l + r) &gt;&gt; 1;        node tl(calc(l, mid)), tr(calc(mid + 1, r)), res;        for (int p = 0; p &lt; 12; ++p)            for (int q = 0; q &lt; 12; ++q)                if (!tl[p].empty() &amp;&amp; !tr[q].empty())                    upd(merge(tl[p], tr[q]), res[(p + q) % 12], p + q &gt;= 12);        return res;    &#125;;    auto res(calc(1, n));    for (int i = 0; i &lt;= m - n; ++i)        std::cout &lt;&lt; res[i % 12][i / 12] &lt;&lt; &#39; &#39;;    std::cout &lt;&lt; &#39;\n&#39;;    return 0;&#125;</code></pre></details><hr /><h2 id="slope-trick">slope trick</h2><p>对于一个 OI 中的凸函数，它是由一些斜率单调的线段拼接成的图形。</p><p>在这个前提下，发现可以用整个函数的左 / 右端点值（截距）和 <span class="math inline">\((n-1)\)</span> 个斜率 / 差分信息描述函数。而这有时比直接维护 <span class="math inline">\(n\)</span> 个点值有着更优美的性质，唤其为 slope trick。</p><p>例如，关于斜率序列，如果定义域不大，可以直接维护；如果它的变化次数不多，可以利用它的单调性质，用单调数据结构维护；如果它的值域很小，可以直接维护拐点。</p><p>注意前两种方法一般关注横坐标对应的函数值，所以自变量一般是和操作次数一类有关的；而这里关注函数最值而弱化了具体横坐标，操作次数一般会作为待最优化的因变量，例如：</p><ul><li>我想要将数列通过若干次单点修改使序列单调，但不关心序列最终形态，问最小操作次数。</li><li>我想要让树上所有叶子到根的路径边权和相等，但不关心这个值是多少，问最小操作次数。</li></ul><p>下面依次解决上述问题。</p><hr /><h3 id="例序列-sequence">例：序列 sequence</h3><p><a href="https://www.luogu.com.cn/problem/P4597" class="uri">https://www.luogu.com.cn/problem/P4597</a></p><p>暴力地，令 <span class="math inline">\(f_{i,j}\)</span> 表示 <span class="math inline">\(a_i\)</span> 最终被修改为 <span class="math inline">\(j\)</span>，容易写出 DP 式子 <span class="math inline">\(f_{i,j}=\min\limits_{k\le j}\{f_{i-1,k}\}+|a_i-j|\)</span>。</p><p>然后就会发现它的定义域实在是太大了！那如果关注斜率的变化情况呢？</p><p>令 <span class="math inline">\(f_{i-1}(k)\)</span> 的极值点为 <span class="math inline">\(k_m\)</span>，分类讨论拆绝对值和 min：</p><ul><li><p>当 <span class="math inline">\(j\le a_i\)</span> 时，<span class="math inline">\(f_i(j)=\min\limits_{k\le j}\{f_{i-1}(k)\}+a_i - j\)</span>。</p><ul><li>当 <span class="math inline">\(j &lt; k_m\)</span> 时，<span class="math inline">\(f_i(j)=f_{i-1}(j)+a_i-j\)</span>，斜率相对于 <span class="math inline">\(f_{i-1}(j)\)</span> 整体减 <span class="math inline">\(1\)</span>。<del>我就说导数没白学吧</del></li><li>当 <span class="math inline">\(j \ge k_m\)</span> 时，<span class="math inline">\(f_i(j)=f_{i-1}(k_m)+a_i-j\)</span>，斜率为 <span class="math inline">\(-1\)</span>。</li></ul></li><li><p>当 <span class="math inline">\(j &gt; a_i\)</span> 时，<span class="math inline">\(f_i(j)=\min\limits_{k\le j}\{f_{i-1}(k)\}+j-a_i\)</span>。</p><ul><li>当 <span class="math inline">\(j &lt; k_m\)</span> 时，<span class="math inline">\(f_i(j)=f_{i-1}(j)+j-a_i\)</span>，斜率相对于 <span class="math inline">\(f_{i-1}(j)\)</span> 整体加 <span class="math inline">\(1\)</span>。</li><li>当 <span class="math inline">\(j\ge k_m\)</span> 时，<span class="math inline">\(f_i(j) = f_{i-1}(k_m)+j-a_i\)</span>，斜率为 <span class="math inline">\(1\)</span>。</li></ul></li></ul><p>如果现在我们掏一个支持区间加斜率、区间推平斜率且维护区间函数最值点的数据结构，那就太逆天了。一个经典的解决方案是用堆维护线段斜率的差分（也就是差分的差分）。</p><p>发现整体修改次数是 <span class="math inline">\(O(n)\)</span> 的，且如果只看比 <span class="math inline">\(k_m\)</span> 更左的 <span class="math inline">\(j\)</span>（更靠右的已经与极值无关所以不用维护），那么就只需要维护区间减法。</p><p>如果将一次区间前缀减法看作一次前缀右端点入队，显然左侧某点 <span class="math inline">\(a\)</span> 的实际被减次数为 <span class="math inline">\(a\)</span> 入队的次数 + 所有右于 <span class="math inline">\(a\)</span> 点的元素的入队次数。用大根堆维护这些元素，就可以快速维护整个斜率序列。例如 <code>3 2 2 1</code>，代表 <span class="math inline">\(3\)</span> 处斜率为 <span class="math inline">\(-1\)</span>，<span class="math inline">\(2\)</span> 处斜率为 <span class="math inline">\(-3\)</span>，<span class="math inline">\(1\)</span> 处斜率为 <span class="math inline">\(-4\)</span>。</p><ul><li><p>当 <span class="math inline">\(a_i\ge k_m\)</span> 时（容易发现它会成为新的 <span class="math inline">\(k_m\)</span>），直接把 <span class="math inline">\(a_i\)</span> 加入大根堆，就可以把 <span class="math inline">\(\le a_i\)</span> 的所有位置斜率减去 <span class="math inline">\(1\)</span>。</p>什么你问在 <span class="math inline">\(k_m\)</span> 和 <span class="math inline">\(a_i\)</span> 之间的推平怎么办？由于唯一右于它们的拐点 <span class="math inline">\(a_i\)</span> 入了一次队，所以中间的元素斜率自然是 <span class="math inline">\(-1\)</span> 啊。</li><li><p>当 <span class="math inline">\(a_i&lt;k_m\)</span> 时，我们需要：</p><ol type="1"><li>将 <span class="math inline">\(a_i\)</span> 以左的位置斜率减去 <span class="math inline">\(1\)</span>，直接将 <span class="math inline">\(a_i\)</span> 入队即可。</li><li>将 <span class="math inline">\(a_i\)</span> 和 <span class="math inline">\(k_m\)</span> 之间的位置斜率加上 <span class="math inline">\(1\)</span>，把 <span class="math inline">\(k_m\)</span> 弹出（太好了就在队首）再把 <span class="math inline">\(a_i\)</span> 加入即可。由于 <span class="math inline">\(k_m\)</span> 显然是一个拐点，所以删除 <span class="math inline">\(k_m\)</span> 并非虚空索敌，但注意 <span class="math inline">\(k_m\)</span> 可能会变化成其后继。</li></ol></li></ul><p>其实就会发现还有一些有趣的小性质，比如 <span class="math inline">\(k_m\)</span> 与队首等价（用于实现）；<span class="math inline">\(k_m\)</span> 右侧斜率全部为 <span class="math inline">\(1\)</span>，也是唯一可以取到的正斜率。</p><details><p>袜写起来好简单。</p><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;int main() &#123;#ifdef ONLINE_JUDGE    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr), std::cout.tie(nullptr);#else    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);#endif    int n;    std::cin &gt;&gt; n;    std::vector&lt;int&gt; a(n + 1);    long long res = 0ll;    std::priority_queue&lt;int&gt; q;    for (int i = 1; i &lt;= n; ++i) &#123;        std::cin &gt;&gt; a[i];        if (i == 1 || a[i] &gt;= q.top())            q.push(a[i]);        else &#123;            res += q.top() - a[i];            q.pop(), q.push(a[i]), q.push(a[i]);        &#125;    &#125;    std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;    return 0;&#125;</code></pre></details><hr /><h3 id="例烟花表演">例：烟花表演</h3><p><a href="https://www.luogu.com.cn/problem/P3642" class="uri">https://www.luogu.com.cn/problem/P3642</a></p><p>设 <span class="math inline">\(f_{u,d}\)</span> 表示在 <span class="math inline">\(u\)</span> 子树中所有叶子距根均为 <span class="math inline">\(d\)</span> 的最小代价。那么有：</p><p><span class="math display">\[f_{u,d}=\sum\limits_{(v, w)\in u}\min\limits_{0\le w&#39;\le d}\{f_{v,d-w&#39;}+|w-w&#39;|\}.\]</span></p><p>可以归纳证明 <span class="math inline">\(f_{u,d}\)</span> 为凸；和上一题相似地，考虑用 <span class="math inline">\(f_v\)</span> 的堆得到 <span class="math inline">\(f_u\)</span> 的堆。</p><p>首先最外层是一个线性加，这其实就是把差分数组 / 斜率加起来，放到我们这个堆里面就是合并两个堆。虽然你可能和我一样不认识可并堆，但是你可以和我一样不会 pd_ds。</p><p>再看内层，发现和上一题长得像但其实不一样，呜呜呜。发现 <span class="math inline">\(|w-w&#39;|\)</span> 是一个左右斜率分别为 <span class="math inline">\(-1,1\)</span> 的分段函数，而左边类比可得斜率最大为 <span class="math inline">\(1\)</span>。</p><p>由闽可夫斯基和，内层函数斜率 <span class="math inline">\(&lt;-1\)</span> 的部分来自 <span class="math inline">\(f_{v,d-w&#39;}\)</span>；<span class="math inline">\(=-1\)</span> 的部分来自 <span class="math inline">\(f_{v,d-w&#39;}\)</span> 和 <span class="math inline">\(|w-w&#39;|\)</span> 的左半边（感谢 <span class="math inline">\(w&#39;\)</span> 是有下确界的）；<span class="math inline">\(=0\)</span> 的部分来自 <span class="math inline">\(f_{v,d-w&#39;}\)</span>；<span class="math inline">\(&gt;0\)</span> 的部分我们不关心。</p><p>最终函数图像的变化：水平部分的左端点右移了 <span class="math inline">\(w\)</span>。找到 <span class="math inline">\(f_{v,d}\)</span> 中的水平线段和斜率为 <span class="math inline">\(1\)</span> 的线段，令其在堆中的值 <span class="math inline">\(+w\)</span> 就能达到平移的目的。</p><p>但需要注意，此时仍然需要 <strong>保留内层函数中斜率为 <span class="math inline">\(1\)</span> 的部分，但斜率 <span class="math inline">\(&gt;1\)</span> 的部分被删除</strong>。原因如下：</p><ul><li>绝对值函数与内层函数定义域相同，作闽可夫斯基和后，斜率为 <span class="math inline">\(1\)</span> 的右侧线段会将 <span class="math inline">\(f_{v,d-w&#39;}\)</span> 中原有的 <span class="math inline">\(&gt;1\)</span> 的部分『挤』出定义域，故可以将其直接删除。</li><li>斜率为 <span class="math inline">\(1\)</span> 的部分，虽然对内层函数中极值点无贡献，但在外层函数中极值点可能向右偏移，此时会对其产生影响，需要维护。</li></ul><p>容易发现由于 <span class="math inline">\(w&#39;\)</span> 的取值上限是 <span class="math inline">\(d\)</span>，但 <span class="math inline">\(d\)</span> 没有上界，所以每个内层函数的右侧都一定是一条斜率为 <span class="math inline">\(1\)</span> 的射线；也就是说，每个外层函数一定有（儿子个数）个拐点（堆中元素），弹出这么多个就可以删除外层函数中斜率 <span class="math inline">\(&gt;1\)</span> 的线段，顺便找到斜率为 <span class="math inline">\(0\)</span> 和 <span class="math inline">\(1\)</span> 的线段。</p><details><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;#include &lt;ext/pb_ds/priority_queue.hpp&gt;const int inf= 0x3f3f3f3f;int main() &#123;#ifdef ONLINE_JUDGE    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr), std::cout.tie(nullptr);#else    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);#endif    int n, m;    std::cin &gt;&gt; n &gt;&gt; m, n += m;    std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; g(n + 1);    auto res(0ll);    for (int i = 2, fa, w; i &lt;= n; ++i) &#123;        std::cin &gt;&gt; fa &gt;&gt; w, res += w;        g[fa].emplace_back(i, w);    &#125;    std::vector&lt;__gnu_pbds::priority_queue&lt;long long&gt; &gt; q(n + 1);    std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;        if (g[x].empty())            q[x].push(0), q[x].push(0);        else            for (auto [i, w] : g[x]) &#123;                DFS(i);                for (int j = 1; j &lt; (int)g[i].size(); ++j)                    q[i].pop();                long long t1 = q[i].top(), t0;                q[i].pop(), t0 = q[i].top(), q[i].pop();                q[i].push(t1 + w), q[i].push(t0 + w);                q[x].join(q[i]);            &#125;        // fprintf(stderr, &quot;size(%d) = %d\n&quot;, x, (int)q[x].size());        return;    &#125;;    DFS(1);    for (int i = 1; i &lt;= (int)g[1].size(); ++i)        q[1].pop();    for (; !q[1].empty(); q[1].pop())        res -= q[1].top();    std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;    return 0;&#125;</code></pre></details><hr /><h3 id="例buy-low-sell-high">例：Buy Low Sell High</h3><p><a href="https://codeforces.com/problemset/problem/865/D" class="uri">https://codeforces.com/problemset/problem/865/D</a></p><p>令 <span class="math inline">\(f_{i,j}\)</span> 表示在第 <span class="math inline">\(i\)</span> 天结束后持有 <span class="math inline">\(j\)</span> 支股票的最大收益。则 <span class="math inline">\(f_{i,j}=\max\{f_{i-1,j},f_{i-1,j-1}-a_i,f_{i-1,j+1}+a_i\}\)</span>。</p><p>（由于这里和 max 有关所以需要精细描述凹凸了）发现就是把三个（可能）经过平移的（可能）凹的函数做线性 max。虽然实际上的结论『函数在整点上是凹的』不算太显然，但是可以猜是凹的。</p><p>线性 max 在 slope trick 中是不太能体现的，但我们发现这里是同一个凹函数向左上、右下平移同一个向量，希望得到新的凹函数不管是从差分角度还是图象，都能得到新函数由左上部分斜率 <span class="math inline">\(&gt;-a_i\)</span> 的线段、两段斜率 <span class="math inline">\(=-a_i\)</span> 的线段、右下部分斜率 <span class="math inline">\(&lt;-a_i\)</span> 的线段组成。此外，由于向左上平移的函数有一处离开了定义域，还需将其剔除。</p><p>值得注意的是，当 <span class="math inline">\(-a_i\)</span> 比最小斜率还要小时会有变化，可以画图看一下。</p><p><img src="2.png" /></p><p>发现定义域是相对小的（<span class="math inline">\(0\le j\le n\)</span>），故用优先队列维护整个斜率序列就可以快速插入两个 <span class="math inline">\(k=-a_i\)</span> 的线段。容易发现顶点在 <span class="math inline">\(j=0\)</span> 处取得（从图象和定义都易知），最右侧是只买不卖的最劣方案，可以倒推。</p><details><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;int main() &#123;#ifdef ONLINE_JUDGE    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr), std::cout.tie(nullptr);#else    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);#endif    int n;    std::cin &gt;&gt; n;    std::vector&lt;int&gt; a(n + 1);    auto res = 0ll;    for (int i = 1; i &lt;= n; ++i)        std::cin &gt;&gt; a[i], res -= a[i];    std::priority_queue&lt;int&gt; q;    q.push(-a[1]);    for (int i = 2; i &lt;= n; ++i)        if (a[i] &lt; -q.top())            q.push(-a[i]);        else            q.pop(), q.push(-a[i]), q.push(-a[i]);    for (; !q.empty(); res -= q.top(), q.pop());    std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;    return 0;&#125;</code></pre></details>]]></content>
      
      
      
        <tags>
            
            <tag> DP </tag>
            
            <tag> 反悔贪心 </tag>
            
            <tag> DP 优化 </tag>
            
            <tag> WQS 二分 </tag>
            
            <tag> 闽可夫斯基和 </tag>
            
            <tag> slope trick </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>点分治</title>
      <link href="/20250612/"/>
      <url>/20250612/</url>
      
        <content type="html"><![CDATA[<p>一时兴起在自己的博客中搜索『点分治』，发现没有匹配项。</p><span id="more"></span><hr /><h3 id="定义">定义</h3><p>适用于解决和点对、路径相关的问题。</p><p>对于任意点 <span class="math inline">\(x\)</span>，树上任意简单路径 <span class="math inline">\((u,v)\)</span> 被分为几类：</p><ol type="1"><li>不经过 <span class="math inline">\(x\)</span>。</li><li>经过 <span class="math inline">\(x\)</span>：<ul><li>一个端点为 <span class="math inline">\(x\)</span>。</li><li>两个端点都不为 <span class="math inline">\(x\)</span>：可以由上一种情况拼接得到。</li></ul></li></ol><p>如果我们把每个点作为 <span class="math inline">\(x\)</span> 的情况都枚举一遍，再统计不重复的 <span class="math inline">\((u,v)\)</span>，在一种特定的枚举顺序下可以做到 <span class="math inline">\(O(n\log n)\)</span> 完成所有点对的枚举。</p><p>证明略，总之每次取子树重心，只遍历没遍历过的点即可。</p><hr /><h3 id="cf1575e-eye-pleasing-city-park-tour">CF1575E Eye-Pleasing City Park Tour</h3><p><a href="https://codeforces.com/problemset/problem/1575/E" class="uri">https://codeforces.com/problemset/problem/1575/E</a></p><p>随便用线段树维护一下就行了。复杂度 <span class="math inline">\(O(n\log^2 n)\)</span>。</p><details><p>随便维护一下 <img src="/em/ll.gif" /></p><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;const int mod = 1e9 + 7;int main() &#123;#ifdef ONLINE_JUDGE    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr), std::cout.tie(nullptr);#else    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);#endif    int n, k;    std::cin &gt;&gt; n &gt;&gt; k;    std::vector&lt;int&gt; a(n + 1);    for (int i = 1; i &lt;= n; ++i)        std::cin &gt;&gt; a[i];    std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; g(n + 1);    for (int i = 1, x, y, c; i &lt; n; ++i) &#123;        std::cin &gt;&gt; x &gt;&gt; y &gt;&gt; c;        g[x].emplace_back(y, c), g[y].emplace_back(x, c);    &#125;    std::vector&lt;std::vector&lt;std::pair&lt;int, long long&gt; &gt; &gt; bit(2, std::vector&lt;std::pair&lt;int, long long&gt; &gt; (n + 1));    auto lowbit = [&amp;](int x) &#123;        return x &amp; -x;    &#125;;    auto add = [&amp;](int id, int x, long long v, int type) &#123;        for (++x; x &lt;= n; x += lowbit(x))            bit[id][x].first += type, (bit[id][x].second += v * type) %= mod;        return;    &#125;;    auto ask = [&amp;](int id, int x) &#123;        std::pair&lt;int, long long&gt; res;        for (++x; x; x -= lowbit(x))            res.first += bit[id][x].first, (res.second += bit[id][x].second) %= mod;        return res;    &#125;;    std::vector&lt;int&gt; p, siz(n + 1), mx(n + 1), tag(n + 1);    std::function&lt;void(int, int)&gt; findp = [&amp;](int x, int fa) &#123;        p.push_back(x);        siz[x] = 1, mx[x] = 0;        for (auto [i, c] : g[x])            if (i != fa &amp;&amp; !tag[i]) &#123;                findp(i, x);                siz[x] += siz[i];                mx[x] = std::max(mx[x], siz[i]);            &#125;        return;    &#125;;    auto findrt = [&amp;](int x) &#123;        std::vector&lt;int&gt;().swap(p), findp(x, -1);        int n = (int)p.size();        for (auto i : p)            if (mx[i] &lt;= n / 2 &amp;&amp; n - siz[i] &lt;= n / 2)                return i;        return -1;    &#125;;    auto res(0ll);    std::function&lt;void(int, int, int, int, int, long long, int, int)&gt; calc = [&amp;](int x, int fa, int oc, int la, int cnt, long long s, int os, int type) &#123;        if (cnt &gt; k)            return;        if (type == 0) &#123;            auto t0(ask(oc, k - cnt)), t1(ask(!oc, k - cnt - 1));            // auto lr(res);            (res += t0.first * (s - os) + t0.second) %= mod;            (res += t1.first * (s - os) + t1.second) %= mod;            // printf(&quot;  %d(%d, %lld): ask[0](%d) = (%d, %lld), ask[1](%d) = (%d, %lld), res += %lld\n&quot;, x, cnt, s - os, k - cnt, t0.first, t0.second, k - cnt - 1, t1.first, t1.second, res - lr);        &#125;        else if (type != 0) &#123;            // printf(&quot;  %d(%d, %lld): add(%d, %lld)\n&quot;, x, cnt, s - os, oc, s * type);            add(oc, cnt, s, type);        &#125;        for (auto [i, c] : g[x])            if (i != fa &amp;&amp; !tag[i])                calc(i, x, oc, c, cnt + (la != c), (s + a[i]) % mod, os, type);        return;    &#125;;    std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;        x = findrt(x);        // printf(&quot;DFS %d\n&quot;, x);        for (auto [i, c] : g[x])            if (!tag[i]) &#123;                calc(i, x, c, c, 0, (a[x] + a[i]) % mod, a[x], 0);                calc(i, x, c, c, 0, (a[x] + a[i]) % mod, a[x], 1);            &#125;        (res += ask(0, k).second + ask(1, k).second) %= mod;        (res += a[x]) %= mod;        // printf(&quot;res += %lld + %lld\n&quot;, ask(0, k).second, ask(1, k).second);        for (auto [i, c] : g[x])            if (!tag[i])                calc(i, x, c, c, 0, (a[x] + a[i]) % mod, a[x], -1);        // assert(!ask(0, k).second);        tag[x] = 1;        for (auto [i, c] : g[x])            if (!tag[i])                DFS(i);        return;    &#125;;    DFS(1);    std::cout &lt;&lt; (res + mod) % mod &lt;&lt; &#39;\n&#39;;    return 0;&#125;</code></pre></details>]]></content>
      
      
      
        <tags>
            
            <tag> 点分治 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚树</title>
      <link href="/20250603/"/>
      <url>/20250603/</url>
      
        <content type="html"><![CDATA[<p>凡所有相，皆是虚妄①。</p><p><em>注释：①虚妄：犹言虚树是狂妄的算法。</em></p><span id="more"></span><hr /><h2 id="定义">定义</h2><p>给定一个大小为 <span class="math inline">\(n\)</span> 的树和树上 <span class="math inline">\(k\)</span> 个关键点。取出这 <span class="math inline">\(k\)</span> 个关键点和它们任意两个间的 LCA 作为虚树的点集，按照原树上的祖孙关系连边得到虚树。</p><p><img src="1.png" /></p><hr /><h2 id="求虚树">求虚树</h2><p>按照 DFN 排序，相邻两点 LCA 加入虚树。复杂度为 <span class="math inline">\(O(k\log k)\)</span>。</p><p>至少两个实点对应一个虚点，故而虚树大小为 <span class="math inline">\(O(k)\)</span>。</p><hr /><h2 id="用途">用途</h2><p>注意到无论是构建还是遍历虚树复杂度都与 <span class="math inline">\(n\)</span> 无关。因而适用于对 <span class="math inline">\(\sum k\)</span> 有限制的题目。</p><hr /><h3 id="b---leaf-color">B - Leaf Color</h3><p><a href="https://atcoder.jp/contests/abc340/tasks/abc340_g" class="uri">https://atcoder.jp/contests/abc340/tasks/abc340_g</a></p><p>枚举所有颜色，每次对该颜色对应的所有点建立虚树，发现不能选虚树外的其他点，虚树上 DP 即可。</p><p>注意根有可能是叶子。需要特判一下。</p><details><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;const int mod = 998244353;int main() &#123;#ifdef ONLINE_JUDGE    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr), std::cout.tie(nullptr);#else    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);#endif    int n;    std::cin &gt;&gt; n;    std::vector&lt;int&gt; a(n + 1);    std::vector&lt;std::vector&lt;int&gt; &gt; g1(n + 1), t(n + 1), g(n + 1);    for (int i = 1; i &lt;= n; ++i)        std::cin &gt;&gt; a[i], t[a[i]].push_back(i);    for (int i = 1, x, y; i &lt; n; ++i) &#123;        std::cin &gt;&gt; x &gt;&gt; y;        g1[x].push_back(y), g1[y].push_back(x);    &#125;    std::vector&lt;int&gt; siz(n + 1), son(n + 1), dep(n + 1), fa(n + 1);    std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int faa) &#123;        siz[x] = 1;        for (auto i : g1[x])            if (i != faa) &#123;                dep[i] = dep[x] + 1;                fa[i] = x;                DFS(i, x);                if (siz[i] &gt; siz[son[x]])                    son[x] = i;            &#125;        return;    &#125;;    DFS(1, -1);    std::vector&lt;int&gt; dfn(n + 1), rfn(n + 1), top(n + 1);    DFS = [&amp;](int x, int fa) &#123;        static int now = 0;        dfn[x] = ++now;        if (son[x])            top[son[x]] = top[x], DFS(son[x], x);        for (auto i : g1[x])            if (i != fa &amp;&amp; i != son[x])                top[i] = i, DFS(i, x);        rfn[x] = now;        return;    &#125;;    top[1] = 1, DFS(1, -1);    auto getLCA = [&amp;](int x, int y) &#123;        for (; top[x] != top[y]; x = fa[top[x]])            if (dep[top[x]] &lt; dep[top[y]])                std::swap(x, y);        return dep[x] &lt; dep[y] ? x : y;    &#125;;    std::vector&lt;int&gt; tag(n + 1);    std::vector&lt;long long&gt; f(n + 1);    auto res(0ll);    for (int k = 1; k &lt;= n; ++k)        if (!t[k].empty()) &#123;            std::sort(t[k].begin(), t[k].end(), [&amp;](int x, int y) &#123; return dfn[x] &lt; dfn[y]; &#125;);            std::vector&lt;int&gt; p;            for (auto i : t[k])                tag[i] = 1, p.push_back(i);            for (int i = 1; i &lt; (int)t[k].size(); ++i) &#123;                int fa = getLCA(t[k][i - 1], t[k][i]);                if (!tag[fa])                    tag[fa] = 1, p.push_back(fa);            &#125;            std::sort(p.begin(), p.end(), [&amp;](int x, int y) &#123; return dfn[x] &lt; dfn[y]; &#125;);            std::vector&lt;int&gt; tmp;            for (auto i : p) &#123;                if (!tmp.empty()) &#123;                    for (; rfn[tmp.back()] &lt; dfn[i]; tmp.pop_back());                    g[tmp.back()].push_back(i);                &#125;                tmp.push_back(i);            &#125;            std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;                f[x] = 1ll;                auto s(1ll);                for (auto i : g[x]) &#123;                    DFS(i), (s += f[i]) %= mod;                    (f[x] *= f[i] + 1) %= mod;                &#125;                if (a[x] != k)                    (f[x] += mod - s) %= mod;                // printf(&quot;color = %d, res += f[%d](%lld)\n&quot;, k, x, f[x]);                (res += f[x]) %= mod;                if (a[x] != k)                    --s, (f[x] += s) %= mod;                return;            &#125;;            DFS(p.front());            for (auto i : p) &#123;                tag[i] = 0, f[i] = 0ll;                std::vector&lt;int&gt;().swap(g[i]);            &#125;        &#125;    std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;    return 0;&#125;</code></pre></details><hr /><h3 id="c---watching-cowflix-p">C - Watching Cowflix P</h3><p><a href="https://www.luogu.com.cn/problem/P9132" class="uri">https://www.luogu.com.cn/problem/P9132</a></p><p>会想到钦定 <span class="math inline">\(k\)</span> 再来做。发现任意情况下都有：假如两个连通块距离 <span class="math inline">\(\le k\)</span>，那么合并起来不劣。所以把距离 <span class="math inline">\(\le k\)</span> 的所有点都合并起来发现只剩下 <span class="math inline">\(O(\frac nk)\)</span> 个点了，想到用虚树。</p><p>然后虚树上枚举点选不选，DP 一下就完了。</p><p>但是实现起来好史啊。合并需要用并查集维护父亲（而非本身），特别打脑壳。</p><details><p>我的天哪滔天巨史。</p><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;const int inf = 0x3f3f3f3f;int main() &#123;#ifdef ONLINE_JUDGE    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr), std::cout.tie(nullptr);#else    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);#endif    int n, rt;    std::cin &gt;&gt; n;    std::vector&lt;int&gt; p, tag(n + 1);    for (int i = 1; i &lt;= n; ++i) &#123;        char t;        std::cin &gt;&gt; t;        if (t == &#39;1&#39;)            p.push_back(i), tag[i] = 1;    &#125;    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1), g1(n + 1);    for (int i = 1, x, y; i &lt; n; ++i) &#123;        std::cin &gt;&gt; x &gt;&gt; y;        g1[x].push_back(y), g1[y].push_back(x);    &#125;    std::set&lt;int&gt; st;    std::vector&lt;int&gt; to(n + 1), len(n + 1), cnt(n + 1), dfn(n + 1);    &#123;        std::vector&lt;int&gt; siz(n + 1), son(n + 1), fa(n + 1), dep(n + 1);        std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int faa) &#123;            siz[x] = 1;            for (auto i : g1[x])                if (i != faa) &#123;                    dep[i] = dep[x] + 1;                    fa[i] = x, DFS(i, x);                    siz[x] += siz[i];                    if (siz[i] &gt; siz[son[x]])                        son[x] = i;                &#125;            return;        &#125;;        DFS(1, -1);        std::vector&lt;int&gt; rfn(n + 1), top(n + 1);        DFS = [&amp;](int x, int fa) &#123;            static int now = 0;            dfn[x] = ++now;            if (son[x])                top[son[x]] = top[x], DFS(son[x], x);            for (auto i : g1[x])                if (i != son[x] &amp;&amp; i != fa)                    top[i] = i, DFS(i, x);            rfn[x] = now;            return;        &#125;;        DFS(1, -1);        auto getLCA = [&amp;](int x, int y) &#123;            for (; top[x] != top[y]; x = fa[top[x]])                if (dep[top[x]] &lt; dep[top[y]])                    std::swap(x, y);            return dep[x] &lt; dep[y] ? x : y;        &#125;;        std::sort(p.begin(), p.end(), [&amp;](int x, int y) &#123; return dfn[x] &lt; dfn[y]; &#125;);        std::vector&lt;int&gt; vis(tag), t(p);        for (int i = 1; i &lt; (int)p.size(); ++i) &#123;            int fa = getLCA(p[i - 1], p[i]);            if (!vis[fa])                vis[fa] = 1, t.push_back(fa);        &#125;        std::sort(t.begin(), t.end(), [&amp;](int x, int y) &#123; return dfn[x] &lt; dfn[y]; &#125;);        rt = t.front();        std::vector&lt;int&gt; stk;        for (auto i : t) &#123;            if (!stk.empty()) &#123;                for (; rfn[stk.back()] &lt; dfn[i]; stk.pop_back());                to[i] = stk.back(), len[i] = dep[i] - dep[to[i]] - 1;            &#125;            st.insert(i), stk.push_back(i);        &#125;    &#125;    std::vector&lt;int&gt; fa(n + 1), siz(n + 1, 1);    std::iota(fa.begin() + 1, fa.end(), 1);    std::function&lt;int(int)&gt; find = [&amp;](int x) &#123;        return x == fa[x] ? x : fa[x] = find(fa[x]);    &#125;;    std::vector&lt;std::array&lt;int, 2&gt; &gt; f(n + 1);    std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int k) &#123;        if (tag[x])            f[x][0] = inf;        f[x][1] = siz[x] + k;        for (auto i : g[x]) &#123;            DFS(i, k);            if (!tag[x])                f[x][0] += std::min(f[i][0], f[i][1]);            f[x][1] += std::min(&#123; f[i][0], f[i][1], f[i][1] + len[i] - k &#125;);        &#125;        return;    &#125;;    std::function&lt;void(int, int, int)&gt; DFS1 = [&amp;](int x, bool flag, int k) &#123;        for (auto i : g[x])            if (flag) &#123;                if (f[i][0] &lt;= std::min(f[i][1], f[i][1] + len[i] - k))                    DFS1(i, 0, k);                else &#123;                    DFS1(i, 1, k);                    if (f[i][1] + len[i] - k &lt; f[i][1]) &#123;                        tag[x] |= tag[i];                        siz[x] += siz[i] + len[i];                        st.erase(i), fa[i] = x;                    &#125;                &#125;            &#125;            else &#123;                if (f[i][0] &lt;= f[i][1])                    DFS1(i, 0, k);                else                    DFS1(i, 1, k);            &#125;        return;    &#125;;    for (int k = 1; k &lt;= n; ++k) &#123;        std::vector&lt;int&gt; p;        for (auto i : st) &#123;            p.push_back(i);            if (to[i])                g[find(to[i])].push_back(i);        &#125;        DFS(rt, k);        std::cout &lt;&lt; std::min(f[rt][0], f[rt][1]) &lt;&lt; &#39;\n&#39;;        DFS1(rt, f[rt][1] &lt;= f[rt][0], k);        for (auto i : st)            f[i][0] = f[i][1] = 0, std::vector&lt;int&gt;().swap(g[i]);    &#125;    return 0;&#125;</code></pre></details><hr /><h3 id="d---smuggling-marbles">D - Smuggling Marbles</h3><p><a href="https://atcoder.jp/contests/arc086/tasks/arc086_c" class="uri">https://atcoder.jp/contests/arc086/tasks/arc086_c</a></p><p>容易想到从贡献角度思考问题；那么每个点只与同深度的所有点存在竞争关系。</p><p>把每个深度的点拿出来建虚树，在虚树上跑 DP 即可。</p><details><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;const int mod = 1e9 + 7;int main() &#123;#ifdef ONLINE_JUDGE    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr), std::cout.tie(nullptr);#else    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);#endif    int n, m = 0;    std::cin &gt;&gt; n, ++n;    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1), g1(n + 1);    for (int i = 2, x; i &lt;= n; ++i)        std::cin &gt;&gt; x, g1[x + 1].push_back(i);    std::vector&lt;int&gt; top(n + 1), dep(n + 1), dfn(n + 1), rfn(n + 1), fa(n + 1);    &#123;        std::vector&lt;int&gt; siz(n + 1), son(n + 1);        std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;            siz[x] = 1;            m = std::max(m, dep[x]);            for (auto i : g1[x]) &#123;                dep[i] = dep[x] + 1;                fa[i] = x, DFS(i);                siz[x] += siz[i];                if (siz[i] &gt; siz[son[x]])                    son[x] = i;            &#125;            return;        &#125;;        dep[1] = 1, DFS(1);        DFS = [&amp;](int x) &#123;            static int now = 0;            dfn[x] = ++now;            if (son[x])                top[son[x]] = top[x], DFS(son[x]);            for (auto i : g1[x])                if (i != son[x])                    top[i] = i, DFS(i);            rfn[x] = now;            return;        &#125;;        top[1] = 1, DFS(1);    &#125;    auto getLCA = [&amp;](int x, int y) &#123;        for (; top[x] != top[y]; x = fa[top[x]])            if (dep[top[x]] &lt; dep[top[y]])                std::swap(x, y);        return dep[x] &lt; dep[y] ? x : y;    &#125;;    std::vector&lt;std::vector&lt;int&gt; &gt; _p(m + 1);    for (int i = 1; i &lt;= n; ++i)        _p[dep[i]].push_back(i);    std::vector&lt;int&gt; tag(n + 1), flag(n + 1);    std::vector&lt;std::array&lt;long long, 2&gt; &gt; f(n + 1);    std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;        f[x][0] = 1ll + flag[x], f[x][1] = flag[x];        auto s(1ll);        for (auto i : g[x]) &#123;            DFS(i);            f[x][1] = (f[x][1] * f[i][0] + s * f[i][1]) % mod;            (f[x][0] *= f[i][0] + f[i][1]) %= mod;            (s *= f[i][0]) %= mod;        &#125;        (f[x][0] += mod - f[x][1]) %= mod;        // printf(&quot;f[%d][0] = %lld, f[%d][1] = %lld\n&quot;, x, f[x][0], x, f[x][1]);        return;    &#125;;    auto qkp = [&amp;](long long x, int y) &#123;        auto res(1ll);        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)            if (y &amp; 1)                (res *= x) %= mod;        return res;    &#125;;    auto res(0ll);    for (int k = 1; k &lt;= m; ++k) &#123;        auto &amp;p = _p[k], t(p);        for (auto i : p)            flag[i] = 1;        std::sort(p.begin(), p.end(), [&amp;](int x, int y) &#123; return dfn[x] &lt; dfn[y]; &#125;);        for (int i = 1; i &lt; (int)p.size(); ++i) &#123;            int fa = getLCA(p[i - 1], p[i]);            if (!tag[fa])                tag[fa] = 1, t.push_back(fa);        &#125;        std::sort(t.begin(), t.end(), [&amp;](int x, int y) &#123; return dfn[x] &lt; dfn[y]; &#125;);        int rt = t.front();        std::vector&lt;int&gt; st;        for (auto i : t) &#123;            if (!st.empty()) &#123;                for (; rfn[st.back()] &lt; dfn[i]; st.pop_back());                g[st.back()].push_back(i);            &#125;            st.push_back(i);        &#125;        DFS(rt);        (res += f[rt][1] * qkp(2ll, n - (int)p.size())) %= mod;        // std::cout &lt;&lt; f[rt][1] * qkp(2ll, n - (int)p.size()) % mod &lt;&lt; &#39;\n&#39;;        for (auto i : t) &#123;            tag[i] = flag[i] = 0;            std::vector&lt;int&gt;().swap(g[i]);        &#125;    &#125;    std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;    return 0;&#125;</code></pre></details><hr /><h3 id="e---世界树">E - 世界树</h3><p><a href="https://www.luogu.com.cn/problem/P3233" class="uri">https://www.luogu.com.cn/problem/P3233</a></p><p>会想到在虚树上两次 DFS 找到离任意点最近的实点。具体地，第一次找下方，第二次尝试用上方更新。</p><p>接着发现对于虚树上的实点是好做的；对于实点的不在树上的儿子是好做的；接下来是虚点及其不在树上的儿子。</p><p>就要用到刚刚求的信息了。显然二分一下就可以了。说起来很简单，然而实际上写起来很苦恼 <img src="/em/ll.gif" /></p><details><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;int main() &#123;#ifdef ONLINE_JUDGE    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr), std::cout.tie(nullptr);#else    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);#endif    int n, q;    std::cin &gt;&gt; n;    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1), g1(n + 1);    for (int i = 1, x, y; i &lt; n; ++i) &#123;        std::cin &gt;&gt; x &gt;&gt; y;        g1[x].push_back(y), g1[y].push_back(x);    &#125;    std::vector&lt;std::array&lt;int, 21&gt; &gt; fa(n + 1);    std::vector&lt;int&gt; siz(n + 1), top(n + 1), dep(n + 1), dfn(n + 1), rfn(n + 1);    &#123;        std::vector&lt;int&gt; son(n + 1);        std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int faa) &#123;            siz[x] = 1;            for (auto i : g1[x])                if (i != faa) &#123;                    dep[i] = dep[x] + 1;                    fa[i][0] = x;                    for (int j = 1; j &lt;= 20; ++j)                        fa[i][j] = fa[fa[i][j - 1]][j - 1];                    DFS(i, x);                    siz[x] += siz[i];                    if (siz[i] &gt; siz[son[x]])                        son[x] = i;                &#125;            return;        &#125;;        DFS(1, -1);        int now = 0;        DFS = [&amp;](int x, int fa) &#123;            dfn[x] = ++now;            if (son[x])                top[son[x]] = top[x], DFS(son[x], x);            for (auto i : g1[x])                if (i != fa &amp;&amp; i != son[x])                    top[i] = i, DFS(i, x);            rfn[x] = now;            return;        &#125;;        top[1] = 1, DFS(1, -1);    &#125;    auto getLCA = [&amp;](int x, int y) &#123;        for (; top[x] != top[y]; x = fa[top[x]][0])            if (dep[top[x]] &lt; dep[top[y]])                std::swap(x, y);        return dep[x] &lt; dep[y] ? x : y;    &#125;;    auto getfa = [&amp;](int x, int p) &#123;        for (int i = 20; ~i; --i)            if (p &gt;= (1 &lt;&lt; i))                x = fa[x][i], p -= (1 &lt;&lt; i);        return x;    &#125;;    std::vector&lt;int&gt; to(n + 1);    std::vector&lt;int&gt; tag(n + 1), flag(n + 1), res(n + 1);    std::cin &gt;&gt; q;    auto dis = [&amp;](int x, int y) &#123;        return std::make_pair(dep[x] + dep[y] - 2 * dep[getLCA(x, y)], y);    &#125;;    std::function&lt;void(int)&gt; DFS1 = [&amp;](int x) &#123;        to[x] = (flag[x] ? x : -1);        for (auto i : g[x]) &#123;            DFS1(i);            if (~to[i] &amp;&amp; (to[x] == -1 || dis(x, to[i]) &lt; dis(x, to[x])))                to[x] = to[i];        &#125;        // printf(&quot;to[%d] = %d\n&quot;, x, to[x]);        return;    &#125;, DFS2 = [&amp;](int x) &#123;        // printf(&quot;to[%d] = %d\n&quot;, x, to[x]);        for (auto i : g[x]) &#123;            if (to[i] == -1 || dis(i, to[x]) &lt; dis(i, to[i]))                to[i] = to[x];            DFS2(i);        &#125;        return;    &#125;, DFS3 = [&amp;](int x) &#123;        res[to[x]] += siz[x];        for (auto i : g[x]) &#123;            res[to[x]] -= siz[getfa(i, dep[i] - dep[x] - 1)];            DFS3(i);        &#125;        // printf(&quot;res[%d] = %d\n&quot;, x, res[x]);        return;    &#125;, DFS4 = [&amp;](int x) &#123;        for (auto i : g[x]) &#123;            if (to[x] == to[i])                res[to[x]] += siz[getfa(i, dep[i] - dep[x] - 1)] - siz[i];            else &#123;                auto dx(dis(x, to[x])), di(dis(i, to[i]));                int at = -1, len = dep[i] - dep[x] - 1;                for (int l = 0, r = len, mid; l &lt;= r; ) &#123;                    mid = (l + r) &gt;&gt; 1;                    if ([&amp;](auto dx, auto dy) &#123;                        dx.first += mid, dy.first += len - mid + 1;                        return dx &lt; dy;                    &#125; (dx, di))                        at = mid, l = mid + 1;                    else                        r = mid - 1;                &#125;                int fa = getfa(i, len - at);                res[to[x]] += siz[getfa(i, len)] - siz[fa];                res[to[i]] += siz[fa] - siz[i];            &#125;            DFS4(i);        &#125;        return;    &#125;;    for (int k; q--; ) &#123;        std::cin &gt;&gt; k;        std::vector&lt;int&gt; p(k);        for (int i = 0; i &lt; k; ++i)            std::cin &gt;&gt; p[i], tag[p[i]] = flag[p[i]] = 1;        auto org(p);        std::sort(p.begin(), p.end(), [&amp;](int x, int y) &#123; return dfn[x] &lt; dfn[y]; &#125;);        std::vector&lt;int&gt; t(p);        for (int i = 1; i &lt; (int)p.size(); ++i) &#123;            int fa = getLCA(p[i - 1], p[i]);            if (!tag[fa])                tag[fa] = 1, t.push_back(fa);        &#125;        if (!tag[1])            t.push_back(1), tag[1] = 1;        std::sort(t.begin(), t.end(), [&amp;](int x, int y) &#123; return dfn[x] &lt; dfn[y]; &#125;);        std::vector&lt;int&gt; st;        for (auto i : t) &#123;            if (!st.empty()) &#123;                for (; rfn[st.back()] &lt; dfn[i]; st.pop_back());                g[st.back()].push_back(i);            &#125;            st.push_back(i);        &#125;        DFS1(1), DFS2(1), DFS3(1), DFS4(1);        for (auto i : org)            std::cout &lt;&lt; res[i] &lt;&lt; &#39; &#39;;        std::cout &lt;&lt; &#39;\n&#39;;        for (auto i : t) &#123;            res[i] = 0;            tag[i] = flag[i] = 0;            std::vector&lt;int&gt;().swap(g[i]);        &#125;    &#125;    return 0;&#125;</code></pre></details><hr /><h3 id="f---大工程">F - 大工程</h3><p><a href="https://www.luogu.com.cn/problem/P4103" class="uri">https://www.luogu.com.cn/problem/P4103</a></p><p>虚树上 DP 统计相关信息即可。</p><details><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;const long long inf = 0x3f3f3f3f;int main() &#123;#ifdef ONLINE_JUDGE    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr), std::cout.tie(nullptr);#else    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);#endif    int n, q;    std::cin &gt;&gt; n;    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1), g1(n + 1);    for (int i = 1, x, y; i &lt; n; ++i) &#123;        std::cin &gt;&gt; x &gt;&gt; y;        g1[x].push_back(y), g1[y].push_back(x);    &#125;    std::vector&lt;int&gt; top(n + 1), dep(n + 1), dfn(n + 1), rfn(n + 1), fa(n + 1);    &#123;        std::vector&lt;int&gt; siz(n + 1), son(n + 1);        std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int faa) &#123;            siz[x] = 1;            for (auto i : g1[x])                if (i != faa) &#123;                    dep[i] = dep[x] + 1;                    fa[i] = x, DFS(i, x);                    siz[x] += siz[i];                    if (siz[i] &gt; siz[son[x]])                        son[x] = i;                &#125;            return;        &#125;;        DFS(1, -1);        int now = 0;        DFS = [&amp;](int x, int fa) &#123;            dfn[x] = ++now;            if (son[x])                top[son[x]] = top[x], DFS(son[x], x);            for (auto i : g1[x])                if (i != fa &amp;&amp; i != son[x])                    top[i] = i, DFS(i, x);            rfn[x] = now;            return;        &#125;;        top[1] = 1, DFS(1, -1);    &#125;    auto getLCA = [&amp;](int x, int y) &#123;        for (; top[x] != top[y]; x = fa[top[x]])            if (dep[top[x]] &lt; dep[top[y]])                std::swap(x, y);        return dep[x] &lt; dep[y] ? x : y;    &#125;;    std::vector&lt;long long&gt; s(n + 1);    std::vector&lt;int&gt; mx(n + 1), mn(n + 1);    std::vector&lt;int&gt; tag(n + 1), siz(n + 1), flag(n + 1);    int rmx, rmn;    long long rs;    std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;        if (flag[x]) &#123;            siz[x] = 1;            mx[x] = mn[x] = s[x] = 0;        &#125;        else &#123;            siz[x] = s[x] = 0;            mn[x] = inf, mx[x] = -inf;        &#125;        for (auto i : g[x]) &#123;            DFS(i);            int len = dep[i] - dep[x];            rmx = std::max(rmx, mx[x] + mx[i] + len);            mx[x] = std::max(mx[x], mx[i] + len);            rmn = std::min(rmn, mn[x] + mn[i] + len);            mn[x] = std::min(mn[x], mn[i] + len);            rs += siz[x] * (s[i] + (long long)siz[i] * len) + siz[i] * s[x];             s[x] += s[i] + (long long)siz[i] * len;            siz[x] += siz[i];            // printf(&quot;%d -&gt; %d, mx = %d, mn = %d, s = %lld\n&quot;, x, i, rmx, rmn, rs);        &#125;        return;    &#125;;    std::cin &gt;&gt; q;    for (int k; q--; ) &#123;        std::cin &gt;&gt; k;        std::vector&lt;int&gt; p(k);        for (int i = 0; i &lt; k; ++i)            std::cin &gt;&gt; p[i], tag[p[i]] = flag[p[i]] = 1;        std::sort(p.begin(), p.end(), [&amp;](int x, int y) &#123; return dfn[x] &lt; dfn[y]; &#125;);        std::vector&lt;int&gt; t(p);        for (int i = 1; i &lt; (int)p.size(); ++i) &#123;            int fa = getLCA(p[i - 1], p[i]);            if (!tag[fa])                tag[fa] = 1, t.push_back(fa);        &#125;        std::sort(t.begin(), t.end(), [&amp;](int x, int y) &#123; return dfn[x] &lt; dfn[y]; &#125;);        int rt = t.front();        std::vector&lt;int&gt; st;        for (auto i : t) &#123;            if (!st.empty()) &#123;                for (; rfn[st.back()] &lt; dfn[i]; st.pop_back());                g[st.back()].push_back(i);            &#125;            st.push_back(i);        &#125;        rs = 0ll, rmx = -inf, rmn = inf;        DFS(rt);        std::cout &lt;&lt; rs &lt;&lt; &#39; &#39; &lt;&lt; rmn &lt;&lt; &#39; &#39; &lt;&lt; rmx &lt;&lt; &#39;\n&#39;;        for (auto i : t) &#123;            tag[i] = flag[i] = 0;            std::vector&lt;int&gt;().swap(g[i]);        &#125;    &#125;    return 0;&#125;</code></pre></details>]]></content>
      
      
      
        <tags>
            
            <tag> 虚树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>闲，故口嗨点 DS 题</title>
      <link href="/20250529/"/>
      <url>/20250529/</url>
      
        <content type="html"><![CDATA[<p>That’s to say 没写代码。</p><p>DP 还是太消耗我本就不富裕的脑神经元了。还是 DS（此处特指线段树题）更友好 /tyt</p><span id="more"></span><hr /><p>题目来源：在洛谷文章广场里乱薅题解，看看是道 DS 就做。洛谷这招太狠了。</p><hr /><h2 id="p12389-compounds">P12389 COmPoUNdS</h2><p><a href="https://www.luogu.com.cn/problem/P12389" class="uri">https://www.luogu.com.cn/problem/P12389</a></p><blockquote><p>给定常数模数，维护模意义下的区间加、区间哈希。<span class="math inline">\(n\le 10^6\)</span>。</p></blockquote><p>发现线段树哈希没办法维护取模操作，太难受了。</p><p>但<mark>把差分值也取模</mark>容易发现是对的。太好了。<mark>而且小性质：此处取模后的差分数组模意义下前缀和仍然是原数组</mark>。</p><p><em>bb：似乎也有把差分值取 abs 的做法，容易发现也是对的。</em></p><hr /><h2 id="p12598-参数要吉祥">P12598 参数要吉祥</h2><p><a href="https://www.luogu.com.cn/problem/P12598" class="uri">https://www.luogu.com.cn/problem/P12598</a></p><blockquote><p>给定 <span class="math inline">\(\{a\}\)</span> 和 <span class="math inline">\(q\)</span> 个询问，每次问 <span class="math inline">\([l,r]\)</span> 中 <span class="math inline">\(c(x)\times a_x\)</span> 的最大值。其中 <span class="math inline">\(c(x)\)</span> 为『出现次数为 <span class="math inline">\(x\)</span> 的数』的种类。</p></blockquote><p>太好了直接上莫队。每次更新一个数的 <span class="math inline">\(cnt\)</span> 时，如果没出现过就加入队列。最后查询的时候把队列过一遍，丢掉非最新版本的数据。显然队列长度和移动次数是一样的。唉<mark>莫队结合队列</mark>感觉还是有点常用的。</p><p>最后需要过一遍整个队列。对于长度为 <span class="math inline">\(len\)</span> 的区间，你会发现 <span class="math inline">\(\ge \sqrt{len}\)</span> 的 <span class="math inline">\(cnt\)</span> 出现次数不超过 <span class="math inline">\(\sqrt {len}\)</span>；<span class="math inline">\(\le \sqrt{len}\)</span> 的 <span class="math inline">\(cnt\)</span> 出现次数更不超过 <span class="math inline">\(len\)</span>。所以过一遍队列就是 <span class="math inline">\(O(\sqrt {len})\)</span> 的。</p><hr /><h2 id="p3793-由乃救爷爷">P3793 由乃救爷爷</h2><p><a href="https://www.luogu.com.cn/problem/P3793" class="uri">https://www.luogu.com.cn/problem/P3793</a></p><blockquote><p>尽可能快地维护随机序列区间最值。</p></blockquote><p>我们知道随机序列笛卡尔树期望深度是 <span class="math inline">\(\log\)</span>。发现数据太过随机以至于可以过。</p><p>来自 <a href="https://www.luogu.com/article/hj9ci08q">UnyieldingTrilobite 的文章</a>：同样可以用悬线！<a href="/20231117/#随机序列悬线结合分块">悬线 + 分块</a> 就可以做了。</p><hr /><h2 id="p4635-shoi2011-改进代码">P4635 [SHOI2011] 改进代码</h2><p><a href="https://www.luogu.com.cn/problem/P4635" class="uri">https://www.luogu.com.cn/problem/P4635</a></p><blockquote><p>给定序列 <span class="math inline">\(a_{1\sim n}\)</span> 和常数 <span class="math inline">\(p\)</span>，维护:</p><ul><li>修改：模 <span class="math inline">\(p\)</span> 意义下区间加；</li><li>询问：区间中 <span class="math inline">\(\sum\limits_{i=l}^{r-1}[a_i&gt;a_{i+1}]\)</span>。</li></ul><p><span class="math inline">\(n\le 10^5,p\le 10^6\)</span>。</p></blockquote><p>怎么又是模意义区间加？</p><p>发现第二个也和差分有关系；<mark>需要注意到此时差分数组是非负的</mark>（有助于你想正解），假如 <span class="math inline">\(s\)</span> 为当前差分数组前缀和模 <span class="math inline">\(p\)</span> 的值（也就是原数），发现<mark>前一个数 <span class="math inline">\(&gt;\)</span> 后一个数当且仅当 <span class="math inline">\(s\)</span> 加爆了</mark>。那么这就很简单了：顺便维护一下原数组；那么 <span class="math inline">\(p\)</span> 的初值就可以确定。然后维护区间内差分数组之和（显然不用取模），<mark>在这个和里有多少个 <span class="math inline">\(p\)</span> 就会爆多少次</mark>。</p><hr /><h2 id="p12685-国家集训队-排队-加强版">P12685 [国家集训队] 排队 加强版</h2><p><a href="https://www.luogu.com.cn/problem/P12685" class="uri">https://www.luogu.com.cn/problem/P12685</a></p><blockquote><p>给定 <span class="math inline">\(a_{1\sim n}\)</span> 和 <span class="math inline">\(m\)</span> 次交换操作，每次操作后输出逆序对数。</p><p><span class="math inline">\(n,m\le 2\times 10^5\)</span>。</p></blockquote><p>哇是动态逆序对（？）。交换看成两次修改就可以无脑 CDQ 了。</p><p><a href="https://www.luogu.com.cn/article/6rgqdfpb">薅的题解</a> 里给了一个奇怪卡常小寄巧：发现 CDQ 是 <span class="math inline">\(O(len\log n)\)</span> 的，暴力是 <span class="math inline">\(O(len^2)\)</span> 的。所以等到 <span class="math inline">\(len&lt;\log n\)</span> 的时候就可以上暴力了。</p><hr />]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多维 DP</title>
      <link href="/20250526/"/>
      <url>/20250526/</url>
      
        <content type="html"><![CDATA[<p>上楼听到有人在哼 <em>Climbing on the Trees</em>，上来听到隔壁班在放 <em>Burn the House Down</em>，果然春天是 AJR 的季节（）</p><span id="more"></span><hr /><p>主要是多维 DP 特有的优化！</p><h2 id="分步转移">分步转移</h2><p>如果状态的若干维之间只存在很弱的联系，可以分步转移每一维。</p><p>假设有二维状态转移 <span class="math inline">\((a,b)\to (a&#39;,b&#39;)\)</span>，『很弱的联系』举例：</p><ol type="1"><li>DP 值中包含 <span class="math inline">\(w(a&#39;,b&#39;)\)</span>，但不包含诸如 <span class="math inline">\(w(a&#39;,b),w(a,b&#39;)\)</span> 之类。也即该值的求解不依赖于上一个状态、不依赖于转移。</li><li>对于 <span class="math inline">\((a&#39;,b&#39;)\)</span> 的取值有限制，比如 <span class="math inline">\((114,514)\)</span> 不能取到之类。显然这也不依赖于上一个状态、不依赖于转移。</li><li>符号限制（如转移间为 <span class="math inline">\(+\)</span>，状态间为 <span class="math inline">\(\times\)</span> 之类），在计数中常出现。</li><li>一个变动的时候另一个必须也一起动。</li></ol><p>注意！有的时候一个状态也可以拆成两个状态，然后分步转移。</p><hr /><h3 id="例题经典题">例题：经典题</h3><blockquote><p>给定 <span class="math inline">\(w_{N\times M}\)</span>，求 <span class="math inline">\((A,B)_{1\sim K}\)</span>，最大化 <span class="math inline">\(\sum\limits_{i=1}^K w_{A_i,B_i}+w_{A_{i-1},A_i}+w_{B_{i-1},B_i}\)</span> 的值。</p></blockquote><p>发现如果设 <span class="math inline">\(f_{i,a,b}\)</span> 表示 <span class="math inline">\((A,B)_i=(a,b)\)</span> 的话，转移就会达到可观的 <span class="math inline">\(O(N\times M)\)</span>；但发现里面的 <span class="math inline">\(A\)</span> 和 <span class="math inline">\(B\)</span> 其实没什么有机联系；唯一的联系 <span class="math inline">\(w_{A_i,B_i}\)</span>（上面『很弱的联系』中的第一、四种情况）。因此分布转移：</p><p><span class="math display">\[f&#39;_{a&#39;,b}\gets \max\limits_a f_{a,b}+w_{a&#39;,a}\\f_{a&#39;,b&#39;}\gets \max\limits_b f&#39;_{a&#39;, b} + w_{b,b&#39;}+w_{a&#39;,b&#39;}\]</span></p><p>由此便优化转移复杂度到 <span class="math inline">\(O(N+M)\)</span>。</p><hr /><h3 id="例题彩灯晚会">例题：彩灯晚会</h3><p>goto <a href="/20250407/#e---kdoi-11彩灯晚会">link</a>。</p><p>Tips：发现 <span class="math inline">\(l_1,l_2\)</span> 之间也没啥有机联系（上面『很弱的联系』中的第三、四种情况），故分步转移。</p><hr /><h3 id="例题序列妙妙值">例题：序列妙妙值</h3><p><a href="https://uoj.ac/problem/549" class="uri">https://uoj.ac/problem/549</a></p><p>朴素地，设 <span class="math inline">\(f_{i,j}\)</span> 表示在第 <span class="math inline">\(i\)</span> 个处分第 <span class="math inline">\(j\)</span> 段的最大价值，显然有 <span class="math inline">\(O(k\times n^2)\)</span>，且并没有优化的空间。</p><p>考虑利用 <span class="math inline">\(a_i\)</span> 很小这一条件，发现上一条无法优化是因为要获取 <span class="math inline">\(sum_{i}\)</span> 的值；那么把 <span class="math inline">\(sum_i\)</span> 塞到状态里。设 <span class="math inline">\(f_{s&#39;,j}\)</span> 表示 <span class="math inline">\(sum=s&#39;\)</span> 时，分了 <span class="math inline">\(j\)</span> 段的最大价值。同样可以 <span class="math inline">\(O(k\cdot n^2)\)</span>。</p><p>接下来有两个理解这个优化的角度：</p><ol type="1"><li><p>从平衡角度，原问题等价于 <span class="math inline">\(O(1)\)</span> 更新 <span class="math inline">\((s,j)\)</span> 处的最大值，<span class="math inline">\(O(v)\)</span> 查找 <span class="math inline">\(j-1\)</span> 处的最大值；把 <span class="math inline">\(s\)</span> 拆成前 <span class="math inline">\(8\)</span> 位、后 <span class="math inline">\(8\)</span> 位两个 part，当更新</p><p>对于修改：相当于固定前 <span class="math inline">\(8\)</span> 位 <span class="math inline">\(s\)</span>，枚举后 <span class="math inline">\(8\)</span> 位 <span class="math inline">\(x\)</span>，并更新 <span class="math inline">\((s,x)\)</span>。</p>对于查询：相当于固定后 <span class="math inline">\(8\)</span> 位 <span class="math inline">\(x\)</span>，枚举前 <span class="math inline">\(8\)</span> 位 <span class="math inline">\(s\)</span>，并查询 <span class="math inline">\((s,x)\)</span>。</li><li><p>从分步转移角度，由于『现时刻』的贡献是按位的，二进制状态的前 <span class="math inline">\(8\)</span> 位和后 <span class="math inline">\(8\)</span> 位没啥有机联系，故直接拆开，先转移前 <span class="math inline">\(8\)</span> 位，再转移后 <span class="math inline">\(8\)</span> 位。</p></li></ol><p>这样就被优化为 <span class="math inline">\(O(k\cdot n\times \sqrt v)\)</span>。</p><details><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;const int maxv = 1 &lt;&lt; 8;const int inf = 0x3f3f3f3f;int main() &#123;#ifdef ONLINE_JUDGE    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr), std::cout.tie(nullptr);#else    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);#endif    int n, k;    std::cin &gt;&gt; n &gt;&gt; k;    using arr = std::vector&lt;int&gt;;    using brr = std::vector&lt;arr&gt;;    using crr = std::vector&lt;brr&gt;;    arr s(n + 1), tag0(maxv), d0;    crr f(maxv, brr(maxv, arr(k + 1, inf))), g(maxv, brr(maxv, arr(k + 1, inf)));    f[0][0][0] = 0;    for (int j = 0; j &lt; maxv; ++j)        g[0][j][1] = j;    tag0[0] = 1, d0.push_back(0);    for (int i = 1; i &lt;= n; ++i) &#123;        std::cin &gt;&gt; s[i], s[i] ^= s[i - 1];        int p0 = s[i] &gt;&gt; 8, p1 = s[i] &amp; ((1 &lt;&lt; 8) - 1);        for (int j = k; j; --j) &#123;            for (auto a : d0)                f[p0][p1][j] = std::min(f[p0][p1][j], g[a][p1][j] + ((a ^ p0) &lt;&lt; 8));            // printf(&quot;f[%d][%d][%d] = %d\n&quot;, p0, p1, j, f[p0][p1][j]);            if (j != k)                for (int a = 0; a &lt; maxv; ++a)                    g[p0][a][j + 1] = std::min(g[p0][a][j + 1], f[p0][p1][j] + (a ^ p1));        &#125;        if (i &gt;= k)            std::cout &lt;&lt; f[p0][p1][k] &lt;&lt; &#39; &#39;;        if (!tag0[p0])            tag0[p0] = 1, d0.push_back(p0);    &#125;    std::cout &lt;&lt; &#39;\n&#39;;    return 0;&#125;</code></pre></details><hr /><h2 id="割裂">割裂</h2><p>如果状态的若干维之间连无机联系都没了，可以直接把 DP 数组拆开，各自转移各自的。</p><p>最后答案的拼接，可能是枚举、直接拼、用一个转移另一个之类。</p><hr /><h3 id="例题经典题-1">例题：经典题</h3><blockquote><p>给定 <span class="math inline">\(w_{N\times M}\)</span>，求 <span class="math inline">\((A,B)_{1\sim K}\)</span>，最大化 <span class="math inline">\(\sum\limits_{i=1}^K w_{A_{i-1},A_i}+w_{B_{i-1},B_i}\)</span> 的值。</p></blockquote><p>先 DP 出来 <span class="math inline">\(A\)</span>，再 DP 出来 <span class="math inline">\(B\)</span>，直接相加即可。</p><hr /><h3 id="例题mnogomet">例题：MNOGOMET</h3><p><a href="https://www.luogu.com.cn/problem/P7648" class="uri">https://www.luogu.com.cn/problem/P7648</a></p><p>想到设 <span class="math inline">\(f_{t,i,a,b}\)</span> 表示『过去了 <span class="math inline">\(t\)</span> 秒，且球在球员 <span class="math inline">\(i\)</span> 手上，且两个队伍得分分别为 <span class="math inline">\(a,b\)</span>』的概率。那么枚举球上一次在谁手上，有美观的 <span class="math inline">\(O(T\cdot N^2R^2)\)</span>。</p><p>发现比分变动时（上半个时刻完成射门并传球）球一定在某个队的 <span class="math inline">\(1\)</span> 号手上；<span class="math inline">\(i\)</span> 这一维和 <span class="math inline">\(a,b\)</span> 也没有相互的干扰；故可以将 <span class="math inline">\(i\)</span> 提取出来（作为对比，射门和夺球、传球都会影响 <span class="math inline">\(t\)</span>，所以分裂出来的状态中必须包含 <span class="math inline">\(t\)</span>）。具体地：</p><ol type="1"><li><p>令 <span class="math inline">\(g_{t,0/1,i}\)</span> 表示『一开始球在哪个球队的 <span class="math inline">\(1\)</span> 号，花费 <span class="math inline">\(t\)</span> 秒，且没人射门，且球在球员 <span class="math inline">\(i\)</span> 手上』的概率。发现可以 <span class="math inline">\(O(T\times N^2)\)</span> 计算。</p><p>当然这里就是条件概率了。其中『一开始球在哪个球队的 <span class="math inline">\(1\)</span> 号』就是条件。</p>再预处理可以得到 <span class="math inline">\(G_{t,0/1,0/1,0/1}\)</span> 表示『一开始球在哪个球队的 <span class="math inline">\(1\)</span> 号，花费 <span class="math inline">\(t\)</span> 秒，哪个球队射门，（没）射进』的概率。</li><li><p>令 <span class="math inline">\(f_{t,0/1,a,b}\)</span> 表示『过去了 <span class="math inline">\(t\)</span> 秒，球在哪个队的 <span class="math inline">\(1\)</span> 号，且得分为 <span class="math inline">\(a,b\)</span>』的概率。枚举距离上一次射门的时间，可以 <span class="math inline">\(O(T^2\times R^2)\)</span> 完成转移。</p></li></ol><details><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;int main() &#123;#ifdef ONLINE_JUDGE    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr), std::cout.tie(nullptr);#else    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);#endif    int n, r, T;    std::cin &gt;&gt; n &gt;&gt; r &gt;&gt; T;    using arr = std::vector&lt;double&gt;;    using brr = std::vector&lt;arr&gt;;    using crr = std::vector&lt;brr&gt;;    brr p(2 * n + 1, arr(2)), pp(2 * n + 1, arr(2 * n + 1));    for (int i = 1; i &lt;= n; ++i) &#123;        std::cin &gt;&gt; p[i][1], p[i][0] = 1. - p[i][1];        int ss, sd;        std::cin &gt;&gt; ss &gt;&gt; sd;        double P = 1. / (ss + sd + 1);        p[i][0] *= P, p[i][1] *= P;        for (int x; ss--; pp[i][x] = P)            std::cin &gt;&gt; x;        for (int x; sd--; pp[i][x + n] = P)            std::cin &gt;&gt; x;    &#125;    for (int i = n + 1; i &lt;= 2 * n; ++i) &#123;        std::cin &gt;&gt; p[i][1], p[i][0] = 1. - p[i][1];        int ss, sd;        std::cin &gt;&gt; ss &gt;&gt; sd;        double P = 1. / (ss + sd + 1);        p[i][0] *= P, p[i][1] *= P;        for (int x; ss--; pp[i][x + n] = P)            std::cin &gt;&gt; x;        for (int x; sd--; pp[i][x] = P)            std::cin &gt;&gt; x;    &#125;    brr s(T + 1, arr(2));    crr g(T + 1, brr(2, arr(2 * n + 1)));    std::vector&lt;crr&gt; G(T + 1, crr(2, brr(2, arr(2)))), f(T + 1, crr(2, brr(r + 1, arr(r + 1))));    g[0][0][1] = g[0][1][n + 1] = 1.;    for (int t = 1; t &lt;= T; ++t) &#123;        for (int f1 = 0; f1 &lt;= 1; ++f1)            for (int i = 1; i &lt;= 2 * n; ++i) &#123;                G[t][f1][i &gt; n][0] += g[t - 1][f1][i] * p[i][0];                G[t][f1][i &gt; n][1] += g[t - 1][f1][i] * p[i][1];                for (int j = 1; j &lt;= 2 * n; ++j)                    if (j != i)                        g[t][f1][i] += pp[j][i] * g[t - 1][f1][j];                // printf(&quot;spend %ds, start from %d, now at %d: %.10lf\n&quot;, t, 1 + f1 * n, i, g[t][f1][i]);                s[t][f1] += g[t][f1][i];            &#125;    &#125;    // puts(&quot;------------------------------------&quot;);    // for (int t = 1; t &lt;= T; ++t) &#123;    //     for (int f1 = 0; f1 &lt;= 1; ++f1)    //         for (int f2 = 0; f2 &lt;= 1; ++f2)    //             for (int f3 = 0; f3 &lt;= 1; ++f3)    //                 printf(&quot;spend %ds, start from %d, %d shoots, STATUS: %d, P = %.10lf\n&quot;, t, 1 + f1 * n, 1 + f2, f3, G[t][f1][f2][f3]);    // &#125;    // puts(&quot;------------------------------------&quot;);    f[0][0][0][0] = 1.;    for (int t = 0; t &lt; T; ++t)        for (int f1 = 0; f1 &lt;= 1; ++f1)            for (int a = 0; a &lt; r; ++a)                for (int b = 0; b &lt; r; ++b) &#123;                    for (int t1 = 1; t + t1 &lt;= T; ++t1) &#123;                        f[t + t1][0][a][b] += f[t][f1][a][b] * G[t1][f1][1][0];                        f[t + t1][0][a][b + 1] += f[t][f1][a][b] * G[t1][f1][1][1];                        f[t + t1][1][a][b] += f[t][f1][a][b] * G[t1][f1][0][0];                        f[t + t1][1][a + 1][b] += f[t][f1][a][b] * G[t1][f1][0][1];                        if (t + t1 == T)                            f[T][0][a][b] += f[t][f1][a][b] * s[t1][f1];                    &#125;                &#125;    // for (int t = 0; t &lt;= T; ++t)    //     for (int f1 = 0; f1 &lt;= 1; ++f1)    //         for (int a = 0; a &lt;= r; ++a)    //             for (int b = 0; b &lt;= r; ++b)    //                 if (f[t][f1][a][b] &gt; 1e-10)    //                     printf(&quot;%ds later, %d shoots, %d : %d, P = %.10lf\n&quot;, t, 1 + !f1 * n, a, b, f[t][f1][a][b]);    std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(10);    for (int a = 0; a &lt;= r; ++a) &#123;        for (int b = 0; b &lt;= r; ++b) &#123;            if (a == r &amp;&amp; b == r)                continue;            double res(0.);            if (a == r)                for (int t = r; t &lt;= T; ++t)                    res += f[t][1][r][b];            else if (b == r)                for (int t = r; t &lt;= T; ++t)                    res += f[t][0][a][r];            else                res = f[T][0][a][b] + f[T][1][a][b];            std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;        &#125;    &#125;    return 0;&#125;</code></pre></details>]]></content>
      
      
      
        <tags>
            
            <tag> DP </tag>
            
            <tag> DP 优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>周考</title>
      <link href="/20250524/"/>
      <url>/20250524/</url>
      
        <content type="html"><![CDATA[<p>并非周考。</p><span id="more"></span><hr /><h2 id="b---carousel-of-combinations">B - Carousel of Combinations</h2><p><a href="https://codeforces.com/problemset/problem/1957/E" class="uri">https://codeforces.com/problemset/problem/1957/E</a></p><blockquote><p><span class="math inline">\(q\)</span> 次询问，每次给定一个 <span class="math inline">\(n\)</span>，求：</p><p><span class="math display">\[\left(\sum\limits_{i=1}^n\sum\limits_{j=1}^i \dfrac {i!}{(i-j)!\cdot j!}\bmod j\right) \bmod 10^9+7\]</span></p><p><span class="math inline">\(n,q\le 10^6\)</span>。</p></blockquote><p>赛时打表 <span class="math inline">\(\dfrac {i!}{(i-j)!\cdot j!}\bmod j\)</span> 易发现只有 <span class="math inline">\(j=4\)</span> 或 <span class="math inline">\(j\)</span> 为质数的列上有值；且仅当 <span class="math inline">\(\left\lfloor \dfrac ij\right\rfloor\)</span> 发生变化时，<span class="math inline">\((i,j)\)</span> 的值不同。</p><p>于是乎埃筛找每个 <span class="math inline">\(j\)</span> 的倍数，由于每个值会持续一段 <span class="math inline">\(i\)</span> 上的区间，考虑维护差分数组。前缀和得到原数组，再前缀和就能得到答案。</p><details><p><summary>证明</summary></p><p>考虑转化为组合数形式方便证明。当 <span class="math inline">\(j\)</span> 为质数时：</p><p><span class="math display">\[\begin{aligned}\dfrac {i!}{(i-j)!\cdot j!}\bmod j&amp;=C_i^j\cdot (j-1)!\bmod j\\&amp;=C_{i\bmod j}^{j\bmod j}\cdot C_{\lfloor \frac ij\rfloor}^{\frac jj}\cdot (j-1)!\bmod j\\&amp;=\left\lfloor \frac ij\right\rfloor\cdot (j-1)!\bmod j\\&amp;=\left\lfloor \frac ij\right\rfloor\cdot (j-1)\bmod j\end{aligned}\]</span></p><p>当 <span class="math inline">\(j\)</span> 为合数时：</p><p><span class="math display">\[\dfrac {i!}{(i-j)!\cdot j!}\bmod j=\left\lfloor \frac ij\right\rfloor\cdot (j-1)!\bmod j\]</span></p><ul><li><p>当 <span class="math inline">\(j=p^2\)</span>，其中 <span class="math inline">\(p\)</span> 为质数时：</p><ul><li>当 <span class="math inline">\(j\ne 4\)</span> 时，<span class="math inline">\(\dfrac jp \ge 3\)</span>，代表在 <span class="math inline">\(1\sim j-1\)</span> 中至少出现了两个 <span class="math inline">\(p\)</span> 的倍数，即 <span class="math inline">\((j-1)\bmod j = 0\)</span>。</li><li>否则，原式转化为 <span class="math inline">\(2\cdot \left\lfloor \frac i4\right\rfloor\bmod 4\)</span>。</li></ul></li><li><p>否则：可以找到至少一组 <span class="math inline">\(j=i\cdot k\)</span> 满足 <span class="math inline">\(i\ne k\)</span>，则 <span class="math inline">\(i,k\)</span> 出现在 <span class="math inline">\(1\sim j-1\)</span> 中，即 <span class="math inline">\((j-1)\bmod j = 0\)</span>。</p></li></ul><p>得到上述结论。</p><p>Tips：</p><ul><li>卢卡斯定理：懒得写了。</li><li>威尔逊定理：对于质数 <span class="math inline">\(p\)</span>，<span class="math inline">\((p-1)!\equiv -1\pmod p\)</span>。</li></ul></details><hr /><h2 id="c---玻利维亚-bolivija">C - 玻利维亚 / Bolivija</h2><p><a href="https://www.luogu.com.cn/problem/P12401" class="uri">https://www.luogu.com.cn/problem/P12401</a></p><blockquote><p>给定若干次区间的插入与删除操作，对于所有值域内未被覆盖极长段 <span class="math inline">\(i\)</span>，令 <span class="math inline">\(len_i\)</span> 为其长度；每次操作后询问 <span class="math inline">\(\sum \frac {len_i\cdot (len_i-1)}2+len_i\)</span>。</p></blockquote><p>来一点新奇的思路。假如你和我一样，很不幸地不知道维护最小值这个 trick，怎么解决这道题？</p><p>容易想到线段树维护节点内贡献和左侧、右侧极长未覆盖长度。加入区间是简单的：对于线段树上被完全覆盖的节点，更新其贡献为 <span class="math inline">\(0\)</span>。依次 <code>pushup</code> 即可。</p><p>删除区间，对于被这段区间完全覆盖的节点，发现如果整体被覆盖次数减少 <span class="math inline">\(1\)</span>，有可能出现新的、未被覆盖的点，如果暴力 check 左右儿子是否出现了这样的点并更新，复杂度就不太美观了。</p><p>故而对于一个节点，<strong>将『完全覆盖它的区间』和『部分覆盖它的区间』分开考虑</strong>，在维护该节点所有实时信息（记为 <span class="math inline">\(s\)</span>）的同时，<strong>维护另一份只考虑了『部分覆盖它地区间』的信息（记为 <span class="math inline">\(s&#39;\)</span>）</strong>：</p><ul><li><p>如果一个『部分覆盖它的区间』被删除：</p><ul><li>如果存在『完全覆盖它的区间』：<span class="math inline">\(s\)</span> 不变；向下修改儿子的 <span class="math inline">\(s\)</span>，<span class="math inline">\(s&#39;\)</span> 需要从儿子的 <span class="math inline">\(s\)</span> 更新。</li></ul></li><li><p>如果一个『完全覆盖它的区间』被删除：</p><ul><li>如果还存在其他『完全覆盖它的区间』：<span class="math inline">\(s,s&#39;\)</span> 都不变。</li><li>如果不存在其他『完全覆盖它的区间』：用 <span class="math inline">\(s&#39;\)</span> 更新 <span class="math inline">\(s\)</span>。</li></ul></li></ul><p>这样就能 <span class="math inline">\(O(q\log V)\)</span> 解决上述问题。本方法较维护最小值的优势在于——似乎没有。想了许多种情况，它们大抵是等价的——且本方法更难写（哭）。</p><details><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;const int maxn = 654205;struct &#123;    int cnt;    long long u, s;    int l, r, lu, ru, ls, rs;&#125; t[maxn &lt;&lt; 2];#define lt (p &lt;&lt; 1)#define rt (lt | 1)#define len(p) (t[p].r - t[p].l + 1)void pushup(int p) &#123;    t[p].s = t[lt].u + t[rt].u + (long long)t[lt].ru * t[rt].lu;    if (t[lt].lu == len(lt))        t[p].ls = len(lt) + t[rt].lu;    else        t[p].ls = t[lt].lu;    if (t[rt].ru == len(rt))        t[p].rs = t[lt].ru + len(rt);    else        t[p].rs = t[rt].ru;    if (!t[p].cnt)        t[p].u = t[p].s, t[p].lu = t[p].ls, t[p].ru = t[p].rs;    return;&#125;void bld(int p, int l, int r) &#123;    t[p].l = l, t[p].r = r;    if (l == r) &#123;        t[p].u = t[p].s = 1ll;        t[p].lu = t[p].ru = t[p].ls = t[p].rs = 1;        return;    &#125;    int mid = (l + r) &gt;&gt; 1;    bld(lt, l, mid), bld(rt, mid + 1, r);    pushup(p);    return;&#125;void add(int p, int l, int r) &#123;    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r) &#123;        ++t[p].cnt, t[p].u = 0ll, t[p].lu = t[p].ru = 0;        return;    &#125;    int mid = (t[p].l + t[p].r) &gt;&gt; 1;    if (l &lt;= mid)        add(lt, l, r);    if (r &gt; mid)        add(rt, l, r);    pushup(p);    return;&#125;void rem(int p, int l, int r) &#123;    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r) &#123;        if (!--t[p].cnt)            t[p].u = t[p].s, t[p].lu = t[p].ls, t[p].ru = t[p].rs;        return;    &#125;    int mid = (t[p].l + t[p].r) &gt;&gt; 1;    if (l &lt;= mid)        rem(lt, l, r);    if (r &gt; mid)        rem(rt, l, r);    pushup(p);    return;&#125;int main() &#123;    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr), std::cout.tie(nullptr);    int n, q;    std::cin &gt;&gt; n &gt;&gt; q;    std::vector&lt;int&gt; a(n + 1);    for (int i = 1; i &lt;= n; ++i)        std::cin &gt;&gt; a[i];    int u = (n + 1) / 2;    const int N = a[u];    bld(1, 1, N);    for (int i = 1; i &lt; u; ++i)        if (a[i] != a[n - i + 1])            add(1, std::min(a[i], a[n - i + 1]) + 1, std::max(a[i], a[n - i + 1]));    std::cout &lt;&lt; t[1].u &lt;&lt; &#39;\n&#39;;    for (int i, v; q--; ) &#123;        std::cin &gt;&gt; i &gt;&gt; v;        if (a[i] != a[n - i + 1])            rem(1, std::min(a[i], a[n - i + 1]) + 1, std::max(a[i], a[n - i + 1]));        a[i] = v;        if (a[i] != a[n - i + 1])            add(1, std::min(a[i], a[n - i + 1]) + 1, std::max(a[i], a[n - i + 1]));        std::cout &lt;&lt; t[1].u &lt;&lt; &#39;\n&#39;;    &#125;    return 0;&#125;</code></pre></details><hr /><h2 id="d---移动金币">D - 移动金币</h2><p><a href="https://www.luogu.com.cn/problem/P5363" class="uri">https://www.luogu.com.cn/problem/P5363</a></p><p>最后一个棋子的移动等价于丢掉最后一部分空格；中间棋子的移动等价于把左边间隔里的一段空格拿到右边的间隔里。发现原问题转化为『阶梯 Nim 博弈』。</p><details><p><summary>关于阶梯 Nim 博弈…</summary></p><blockquote><p>给定 <span class="math inline">\(n\)</span> 层石头，每次行动可以选择以下操作中的一种：</p><ol type="1"><li>选择 <span class="math inline">\(2\le i\le n\)</span>，从第 <span class="math inline">\(i\)</span> 层石头中拿走若干颗，全部放到第 <span class="math inline">\(i-1\)</span> 层里。</li><li>从第 <span class="math inline">\(1\)</span> 层石头中拿走若干颗，全部丢弃。</li></ol><p>不能行动者输。</p></blockquote><p>本问题可以等效为 Nim 游戏：</p><p>对于第偶数层，若 Alice 选择从第 <span class="math inline">\(2i\)</span> 层中移动 <span class="math inline">\(x\)</span> 个石头到 <span class="math inline">\(2i-1\)</span>，Bob 可以立即从 <span class="math inline">\(2i-1\)</span> 层中将这 <span class="math inline">\(x\)</span> 个石头移动到 <span class="math inline">\(2i-2\)</span>（或丢弃）。</p><p>也就是说，Alice 在偶数层中的操作不会对 Bob 带来任何限制。偶数层的石头可以被视作不存在；从奇数层移动到偶数层的石头可以被视为丢弃；进而，奇数堆中的移动等效为『丢弃』，将原问题中所有奇数堆抽离出来，等效成普通的 Nim 游戏。</p></details><p>问题转化成，将 <span class="math inline">\(n-m\)</span> 个元素放到编号 <span class="math inline">\(0\sim m+1\)</span> 的盒子里，满足奇数号盒子球个数异或和为 <span class="math inline">\(0\)</span> 的方案数。小容斥一下，用总数减去异或和为 <span class="math inline">\(0\)</span> 者。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 线段树 </tag>
            
            <tag> 博弈论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>杂题</title>
      <link href="/20250520/"/>
      <url>/20250520/</url>
      
        <content type="html"><![CDATA[<p>manual 是 anual 的 m 词形式（胡言乱语）</p><p>Everyone is potential. （每个人都是蛋白质。）</p><span id="more"></span><hr /><h2 id="cf2043e-matrix-transformation">CF2043E Matrix Transformation</h2><p><a href="https://codeforces.com/problemset/problem/2043/E" class="uri">https://codeforces.com/problemset/problem/2043/E</a></p><blockquote><p>给定 <span class="math inline">\(n\times m\)</span> 的 <span class="math inline">\(01\)</span> 矩阵 <span class="math inline">\(A,B\)</span>，可任意将 <span class="math inline">\(A\)</span> 的一行置为 <span class="math inline">\(0\)</span> 或一列置为 <span class="math inline">\(1\)</span>，问是否能将 <span class="math inline">\(A\)</span> 变成 <span class="math inline">\(B\)</span>。</p></blockquote><p>发现如果 <span class="math inline">\(B\)</span> 的某一行是 <span class="math inline">\(0\)</span>，那么不管 <span class="math inline">\(A\)</span> 这一行是什么东西都可以通过一次操作让这一行满足条件（当然，要求这步操作最后进行）。列也是相似的。</p><p>那么就有一个撤销的思路，从 <span class="math inline">\(B\)</span> 中不断删除全 <span class="math inline">\(0\)</span> 行或全 <span class="math inline">\(1\)</span> 列，不能删了就对比二者剩下的部分是否全等（因为此时任何操作都是非法的）。</p><details><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;int main() &#123;#ifdef ONLINE_JUDGE    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr), std::cout.tie(nullptr);#else    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);#endif    int T;    for (std::cin &gt;&gt; T; T--; ) &#123;        int n, m;        std::cin &gt;&gt; n &gt;&gt; m;        using arr = std::vector&lt;int&gt;;        using brr = std::vector&lt;arr&gt;;        using crr = std::vector&lt;brr&gt;;        brr cn(31, arr(n + 1)), cm(31, arr(m + 1));        crr a(31, brr(n + 1, arr(m + 1))), b(31, brr(n + 1, arr(m + 1)));        for (int i = 1; i &lt;= n; ++i)            for (int j = 1, x; j &lt;= m; ++j) &#123;                std::cin &gt;&gt; x;                for (int k = 0; k &lt; 31; ++k)                    a[k][i][j] = (x &gt;&gt; k) &amp; 1;            &#125;        for (int i = 1; i &lt;= n; ++i)            for (int j = 1, x; j &lt;= m; ++j) &#123;                std::cin &gt;&gt; x;                for (int k = 0; k &lt; 31; ++k) &#123;                    b[k][i][j] = (x &gt;&gt; k) &amp; 1;                    cn[k][i] += b[k][i][j];                    cm[k][j] += !b[k][i][j];                &#125;            &#125;        for (int k = 0; k &lt; 31; ++k) &#123;            std::queue&lt;int&gt; qn, qm;            std::vector&lt;int&gt; tn(n + 1, 1), tm(m + 1, 1);            for (int i = 1; i &lt;= n; ++i)                if (!cn[k][i])                    tn[i] = 0, qn.push(i);            for (int j = 1; j &lt;= m; ++j)                if (!cm[k][j])                    tm[j] = 0, qm.push(j);            for (; !qn.empty() || !qm.empty(); ) &#123;                if (!qn.empty()) &#123;                    int i = qn.front();                    // printf(&quot;delete line %d\n&quot;, i);                    qn.pop();                    for (int j = 1; j &lt;= m; ++j)                        if (!b[k][i][j] &amp;&amp; !--cm[k][j])                            tm[j] = 0, qm.push(j);                &#125;                else &#123;                    int j = qm.front();                    // printf(&quot;delete column %d\n&quot;, j);                    qm.pop();                    for (int i = 1; i &lt;= n; ++i)                        if (b[k][i][j] &amp;&amp; !--cn[k][i])                            tn[i] = 0, qn.push(i);                &#125;            &#125;            for (int i = 1; i &lt;= n; ++i)                if (tn[i])                    for (int j = 1; j &lt;= m; ++j)                        if (tm[j] &amp;&amp; a[k][i][j] != b[k][i][j]) &#123;                            // printf(&quot;k = %d: (%d, %d)\n&quot;, k, i, j);                            goto nosol;                        &#125;        &#125;        std::cout &lt;&lt; &quot;Yes\n&quot;;        continue;    nosol :        std::cout &lt;&lt; &quot;No\n&quot;;    &#125;    return 0;&#125;</code></pre></details><hr /><h2 id="cf2043f-nim">CF2043F Nim</h2><p><a href="https://codeforces.com/contest/2043/problem/F" class="uri">https://codeforces.com/contest/2043/problem/F</a></p><blockquote><p>给定 <span class="math inline">\(m\)</span> 次询问，每次问从 <span class="math inline">\(a_l\sim a_r\)</span> 选非空子序列使得异或和为 <span class="math inline">\(0\)</span>，问子序列最小长度、该前提下的方案数。</p></blockquote><p>发现子序列问题可以等价为背包；背包可以合并（即把整区间拆成若干段后，两两信息可以合并）；<a href="/20231117/#关于背包">背包可以放在分治上</a>；</p><p>由此，把询问离线下来放在 <span class="math inline">\(a_{1\sim n}\)</span> 的分治上，每次只处理在 <span class="math inline">\([l,r]\)</span> 间且跨越 <span class="math inline">\(mid\)</span> 的询问就可以得到答案。复杂度 <span class="math inline">\(O(n\cdot v^2\log n)\)</span>。</p><details><p>不要用方案数是否为 <span class="math inline">\(0\)</span> 来判断是否无解！因为方案数可能是 <span class="math inline">\(998244353\)</span> 的倍数……</p><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;const int siz = 63;const int mod = 998244353;const int inf = 0x3f3f3f3f;int main() &#123;#ifdef ONLINE_JUDGE    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr), std::cout.tie(nullptr);#else    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);#endif    int n, m;    std::cin &gt;&gt; n &gt;&gt; m;    std::vector&lt;int&gt; a(n + 1);    for (int i = 1; i &lt;= n; ++i)        std::cin &gt;&gt; a[i];    struct _ &#123; int l, r, id; &#125;;    std::vector&lt;_&gt; q(m + 1);    std::vector&lt;std::pair&lt;int, long long&gt; &gt; res(m + 1, &#123; inf, 0ll &#125;);    for (int i = 1; i &lt;= m; ++i) &#123;        std::cin &gt;&gt; q[i].l &gt;&gt; q[i].r;        q[i].id = i;    &#125;    std::function&lt;void(int, int, std::vector&lt;_&gt; &amp;q)&gt; calc = [&amp;](int l, int r, std::vector&lt;_&gt; &amp;q) &#123;        if (l == r) &#123;            for (auto [l, r, id] : q)                if (a[l] == 0)                    res[id] = &#123; 0, 1ll &#125;;            return;        &#125;        int mid = (l + r) &gt;&gt; 1;        std::vector&lt;_&gt; ql, qr, qm;        for (; !q.empty(); q.pop_back()) &#123;            if (q.back().r &lt;= mid)                ql.push_back(std::move(q.back()));            else if (q.back().l &gt; mid)                qr.push_back(std::move(q.back()));            else                qm.push_back(std::move(q.back()));        &#125;        calc(l, mid, ql), calc(mid + 1, r, qr);        std::vector&lt;std::vector&lt;int&gt; &gt; f(r - l + 1, std::vector&lt;int&gt; (siz + 1, inf));        std::vector&lt;std::vector&lt;long long&gt; &gt; g(r - l + 1, std::vector&lt;long long&gt; (siz + 1));        f[mid - l][a[mid]] = 1ll, g[mid - l][a[mid]] = 1ll;        for (int i = mid - l - 1; ~i; --i) &#123;            int k = a[i + l];            f[i] = f[i + 1], g[i] = g[i + 1];            if (f[i][k] == 1)                (++g[i][k]) %= mod;            else                f[i][k] = 1, g[i][k] = 1ll;            for (int j = 0, k = a[i + l]; j &lt;= siz; ++j)                if (f[i + 1][j ^ k] + 1 &lt; f[i][j])                    f[i][j] = f[i + 1][j ^ k] + 1, g[i][j] = g[i + 1][j ^ k];                else if (f[i + 1][j ^ k] + 1 == f[i][j])                    (g[i][j] += g[i + 1][j ^ k]) %= mod;        &#125;        f[mid - l + 1][a[mid + 1]] = 1ll, g[mid - l + 1][a[mid + 1]] = 1ll;        for (int i = mid - l + 2; i &lt;= r - l; ++i) &#123;            int k = a[i + l];            f[i] = f[i - 1], g[i] = g[i - 1];            if (f[i][k] == 1)                (++g[i][k]) %= mod;            else                f[i][k] = 1, g[i][k] = 1ll;            for (int j = 0; j &lt;= siz; ++j)                if (f[i - 1][j ^ k] + 1 &lt; f[i][j])                    f[i][j] = f[i - 1][j ^ k] + 1, g[i][j] = g[i - 1][j ^ k];                else if (f[i - 1][j ^ k] + 1 == f[i][j])                    (g[i][j] += g[i - 1][j ^ k]) %= mod;        &#125;        for (auto [ql, qr, id] : qm) &#123;            // printf(&quot;at [%d, %d], mid = %d: ASK [%d, %d]: \n&quot;, l, r, mid, ql, qr);            ql -= l, qr -= l;            if (f[ql][0] &lt; inf)                res[id].first = f[ql][0], res[id].second = g[ql][0];            if (f[qr][0] &lt; res[id].first)                res[id].first = f[qr][0], res[id].second = g[qr][0];            else if (f[qr][0] == res[id].first)                (res[id].second += g[qr][0]) %= mod;            for (int i = 1; i &lt;= siz; ++i) &#123;                // printf(&quot;  %d[%d]: %d(%lld)  |  %d[%d]: %d(%lld)\n&quot;, ql + l, i, f[ql][i], g[ql][i], qr + l, i, f[qr][i], g[qr][i]);                if (f[ql][i] + f[qr][i] &lt; res[id].first)                    res[id].first = f[ql][i] + f[qr][i], res[id].second = g[ql][i] * g[qr][i] % mod;                else if (f[ql][i] + f[qr][i] == res[id].first)                    (res[id].second += g[ql][i] * g[qr][i]) %= mod;            &#125;            if (res[id].first &lt; inf)                res[id].first = (qr - ql + 1) - res[id].first;        &#125;        return;    &#125;;    calc(1, n, q);    for (int i = 1; i &lt;= m; ++i)        if (res[i].first &lt; inf)            std::cout &lt;&lt; res[i].first &lt;&lt; &#39; &#39; &lt;&lt; res[i].second &lt;&lt; &#39;\n&#39;;        else            std::cout &lt;&lt; -1 &lt;&lt; &#39;\n&#39;;    return 0;&#125;</code></pre></details><hr /><h2 id="peru">Peru</h2><p><a href="https://www.luogu.com.cn/problem/P11405" class="uri">https://www.luogu.com.cn/problem/P11405</a></p><hr /><h2 id="贪玩蓝月">贪玩蓝月</h2><p><a href="https://loj.ac/p/6515" class="uri">https://loj.ac/p/6515</a></p><p><em>差不多的题：<a href="https://atcoder.jp/contests/jag2018summer-day2/tasks/jag2018summer_day2_d" class="uri">https://atcoder.jp/contests/jag2018summer-day2/tasks/jag2018summer_day2_d</a>，注意加入是按体积单增的</em></p><p>发现断点确定时可以背包 <span class="math inline">\(O(p)\)</span> 维护插入删除；使用 <a href="">双栈模拟双端队列</a> 就可以均摊 <span class="math inline">\(O(pm)\)</span> 实现插入删除。</p><p>对于询问，当然可以 <span class="math inline">\(O(p^2)\)</span> 枚举最值再枚举方案（即枚举一端的贡献）；但复杂度不太美观。考虑倒过来，先 <span class="math inline">\(O(v)\)</span> 枚举一端贡献，再枚举『能凑出 <span class="math inline">\([l,r]\)</span> 中的值』的另一端的贡献。这样就发现我们是在求区间最大值；每次询问时构建 ST 表预处理另一端的区间最大值即可。</p><p>复杂度 <span class="math inline">\(O(mq\log q)\)</span>。</p><details><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;const long long inf = 1e18;int main() &#123;#ifdef ONLINE_JUDGE    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr), std::cout.tie(nullptr);#else    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);#endif    int m, mod;    std::cin &gt;&gt; m &gt;&gt; m &gt;&gt; mod;    std::array&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt;, 2&gt; T;    std::array&lt;std::vector&lt;std::vector&lt;long long&gt; &gt;, 2&gt; F;    F[0].emplace_back(mod, -inf), F[1].emplace_back(mod, -inf);    F[0][0][0] = 0ll, F[1][0][0] = 0ll;    for (; m--; ) &#123;        std::string op;        std::cin &gt;&gt; op;        if (op[0] == &#39;I&#39;) &#123;            int v, w;            std::cin &gt;&gt; v &gt;&gt; w, v %= mod;            auto &amp;t = T[op[1] == &#39;G&#39;];            auto &amp;f = F[op[1] == &#39;G&#39;];            t.emplace_back(v, w);            f.emplace_back(f.back());            for (int i = (int)f.size() - 1, j = 0; j &lt; mod; ++j)                if (f[i - 1][(j + mod - v) % mod] + w &gt; f[i][j])                    f[i][j] = f[i - 1][(j + mod - v) % mod] + w;        &#125;        else if (op[0] == &#39;D&#39;) &#123;            auto &amp;t0 = T[op[1] == &#39;G&#39;], &amp;t1 = T[op[1] == &#39;F&#39;];            auto &amp;f0 = F[op[1] == &#39;G&#39;], &amp;f1 = F[op[1] == &#39;F&#39;];            if (t0.empty()) &#123;                t1.erase(t1.begin());                int to = t1.size() / 2;                std::vector&lt;std::pair&lt;int, int&gt; &gt; (t1.begin(), t1.begin() + to).swap(t0);                std::reverse(t0.begin(), t0.end());                std::vector&lt;std::pair&lt;int, int&gt; &gt; (t1.begin() + to, t1.end()).swap(t1);                f0.resize(1), f1.resize(1);                for (auto [v, w] : t0) &#123;                    f0.emplace_back(f0.back());                    for (int i = (int)f0.size() - 1, j = 0; j &lt; mod; ++j)                        if (f0[i - 1][(j + mod - v) % mod] + w &gt; f0[i][j])                            f0[i][j] = f0[i - 1][(j + mod - v) % mod] + w;                &#125;                for (auto [v, w] : t1) &#123;                    f1.emplace_back(f1.back());                    for (int i = (int)f1.size() - 1, j = 0; j &lt; mod; ++j)                        if (f1[i - 1][(j + mod - v) % mod] + w &gt; f1[i][j])                            f1[i][j] = f1[i - 1][(j + mod - v) % mod] + w;                &#125;            &#125;            else                t0.pop_back(), f0.pop_back();        &#125;        else &#123;            int l, r;            std::cin &gt;&gt; l &gt;&gt; r;            auto res(-inf);            std::vector&lt;std::vector&lt;long long&gt; &gt; st(std::__lg(mod) + 1, std::vector&lt;long long&gt; (mod + 1));            st[0] = F[1].back();            for (int j = 1; (1 &lt;&lt; j) &lt;= mod; ++j)                for (int i = 0; i + (1 &lt;&lt; j) - 1 &lt; mod; ++i)                    st[j][i] = std::max(st[j - 1][i], st[j - 1][i + (1 &lt;&lt; (j - 1))]);            auto ask = [&amp;](int l, int r) &#123;                int k = std::__lg(r - l + 1);                return std::max(st[k][l], st[k][r - (1 &lt;&lt; k) + 1]);            &#125;;            for (int j = 0; j &lt; mod; ++j)                if (j &lt;= l)                    res = std::max(res, F[0].back()[j] + ask(l - j, r - j));                else if (l &lt; j &amp;&amp; j &lt;= r)                    res = std::max(&#123; res, F[0].back()[j] + ask(0, r - j), F[0].back()[j] + ask(l + mod - j, mod - 1) &#125;);                else                    res = std::max(res, F[0].back()[j] + ask(l + mod - j, r + mod - j));            std::cout &lt;&lt; std::max(-1ll, res) &lt;&lt; &#39;\n&#39;;        &#125;    &#125;    return 0;&#125;</code></pre></details><hr /><h2 id="apio2025-转杆">APIO2025 转杆</h2><p><a href="https://www.luogu.com.cn/problem/P12543" class="uri">https://www.luogu.com.cn/problem/P12543</a></p><p><del>总有一天我要让全天下的数学题 DP 题字符串题图论题模拟题数据结构题思维题全部消失</del></p><p>不要把它转化成序列问题来考虑！这对观察到结论没有好处！</p><p>考虑 <span class="math inline">\(n=2\)</span> 的情况，当且仅当垂直时最优。<span class="math inline">\(n=3\)</span> 时，随便固定其中一条线，发现剩下两条线如果夹角固定，则代价固定；当夹角取 <span class="math inline">\(90^{\circ}\)</span> 时最优。</p><p>于是猜是不是任意一对都要垂直。考虑数归，当前 <span class="math inline">\(2n\)</span> 对 <del>不知道怎么摆的，反正就是</del> 最优时：</p><ul><li>考虑加入第 <span class="math inline">\(2n+1\)</span> 条；参照 <span class="math inline">\(n=3\)</span> 的情形，把前 <span class="math inline">\(2n\)</span> 条任意两两配对，则第 <span class="math inline">\(2n+1\)</span> 的位置对代价没有任何影响。</li><li>考虑加入第 <span class="math inline">\(2n+2\)</span> 条；相似地，它的位置对前 <span class="math inline">\(2n\)</span> 条没有任何影响；故需要最大化它和第 <span class="math inline">\(2n+1\)</span> 条的贡献。取垂直即可。</li></ul><p>因此得到任意一对都要垂直。具体怎么调整呢？首先下意识排序；配对方式即将 <span class="math inline">\(i\)</span> 与 <span class="math inline">\(\dfrac i+\lfloor \frac n2\rfloor\)</span> 配对；因为能感受到这样影响的线段最少。严谨的证明好像没看到。</p><details><pre class="cpp"><code>#include&lt;bits/stdc++.h&gt;void energy(int, std::vector&lt;int&gt;);void rotate(std::vector&lt;int&gt;, int);void energy(int n, std::vector&lt;int&gt; a) &#123;    std::vector&lt;int&gt; id(n);    std::iota(id.begin(), id.end(), 0);    std::sort(id.begin(), id.end(), [&amp;](int x, int y) &#123; return a[x] &lt; a[y]; &#125;);    for (int i = 0, j = n / 2; i &lt; n / 2; ++i, ++j)        rotate(&#123; id[j] &#125;, (a[id[i]] + 75000 - a[id[j]]) % 50000);    return;&#125;</code></pre></details><hr /><h2 id="abc407e-most-valuable-parentheses">ABC407E Most Valuable Parentheses</h2><p><a href="https://atcoder.jp/contests/abc407/tasks/abc407_e" class="uri">https://atcoder.jp/contests/abc407/tasks/abc407_e</a></p><p>这里有一个很典（可惜我不知道）的 trick：<a href="/20231117/#贪心选取括号序列">贪心构造最优括号序列</a>。</p><p>用优先队列维护，贪心选即可。</p><details><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;int main() &#123;#ifdef ONLINE_JUDGE    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr), std::cout.tie(nullptr);#else    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);#endif    int T;    for (std::cin &gt;&gt; T; T--; ) &#123;        int n;        std::cin &gt;&gt; n;        std::vector&lt;int&gt; a(2 * n + 1);        for (int i = 1; i &lt;= 2 * n; ++i)            std::cin &gt;&gt; a[i];        long long res = a[1];        std::priority_queue&lt;int&gt; q;        for (int i = 2; i &lt; 2 * n; i += 2) &#123;            q.push(a[i]), q.push(a[i + 1]);            res += q.top(), q.pop();        &#125;        std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;    &#125;    return 0;&#125;</code></pre></details><hr /><h2 id="section"></h2>]]></content>
      
      
      
        <tags>
            
            <tag> 分治 </tag>
            
            <tag> 背包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>构造类问题的很少解题方法</title>
      <link href="/20250518/"/>
      <url>/20250518/</url>
      
        <content type="html"><![CDATA[<p>病毒可能具有膜结构，但不存在生物膜系统。核糖体是唯一所有细胞均含有的细胞器，但病毒中无核糖体。</p><span id="more"></span><p>病毒的主要组成是 <span class="math inline">\(10\%\sim 20\%\)</span> 的核酸，<span class="math inline">\(60\%\sim 70\%\)</span> 的蛋白质外壳，<span class="math inline">\(&lt;10\%\)</span> 的结合水，可能具有逆转录酶、RNA 聚合酶。病毒的含水量（<span class="math inline">\(&lt;10\%\)</span>）远远小于细胞（<span class="math inline">\(70\%\)</span>）。</p><hr /><h2 id="type-i调整法---1">Type I：调整法 - 1</h2><p>虽然话是这么说，感觉这就是平常正常的做题路径，『想做法』——『发现有锅』——『打补丁』。</p><p>只是可能这是在提醒你在构造题中发现有锅不要急着换做法（？）</p><hr /><h3 id="例题c---stations">例题：C - Stations</h3><p><a href="https://qoj.ac/problem/1139" class="uri">https://qoj.ac/problem/1139</a></p><p>一个简单的想法是，当可用的编号范围很大时，可以记下每个点 <span class="math inline">\(u\)</span> 的 <span class="math inline">\(DFN_u\)</span> 和出栈序（记为 <span class="math inline">\(RFN_u\)</span>），这样就能解决查询；但标号是 <span class="math inline">\(N^2\)</span> 级别的。</p><p>现在思考，我们为什么需要记录 <span class="math inline">\(RFN_u\)</span> 呢？因为在询问时，需要判断 <span class="math inline">\(t\)</span> 的位置：如果在 <span class="math inline">\(x\)</span> 某一儿子的子树内，答案为该儿子；否则，答案为 <span class="math inline">\(fa\)</span>。当 <span class="math inline">\(DFN_t\)</span> 比 <span class="math inline">\(u\)</span> 最靠后的儿子 <span class="math inline">\(v\)</span> 的 <span class="math inline">\(DFN\)</span> 还要大时，无法判断 <span class="math inline">\(t\)</span> 在 <span class="math inline">\(v\)</span> 内还是在 <span class="math inline">\(u\)</span> 外。</p><p>此处有一个解决方案（原谅我实在无法猜出是怎么想到的），将树按奇数层、偶数层分层，计数层记录 <span class="math inline">\(DFN\)</span>，偶数层记录 <span class="math inline">\(RFN\)</span>（具体地，奇数层在入栈时编号，偶数层在出栈时编号）；接下来进行判断（注意我们并不知道 <span class="math inline">\(u\)</span> 所在层数的奇偶性）：</p><ul><li>若不存在 <span class="math inline">\(id_i&gt;id_u\)</span>，说明 <span class="math inline">\(id_u\)</span> 为 <span class="math inline">\(RFN_u\)</span>；此时 可以判断 <span class="math inline">\(t\)</span> 是否位于 <span class="math inline">\(u\)</span> 内。</li><li>否则，<span class="math inline">\(id_u\)</span> 为 <span class="math inline">\(DFN_u\)</span>。由于知道 <span class="math inline">\(RFN_v\)</span>，可以判断 <span class="math inline">\(t\)</span> 是否位于 <span class="math inline">\(v\)</span> 内。</li></ul><p>容易证明其他一般情况也可以判断 <span class="math inline">\(t\)</span> 的位置。复杂度 <span class="math inline">\(O(n^2)\)</span>。</p><details><pre class="cpp"><code>#include &quot;stations.h&quot;#include &lt;bits/stdc++.h&gt;std::vector&lt;int&gt; label(int n, int k, std::vector&lt;int&gt; u, std::vector&lt;int&gt; v) &#123;    std::vector&lt;std::vector&lt;int&gt; &gt; g(n);    for (int i = 0; i &lt; n - 1; ++i)        g[u[i]].push_back(v[i]), g[v[i]].push_back(u[i]);    std::vector&lt;int&gt; id(n, -1);    int now = 0;    std::function&lt;void(int, int, int)&gt; DFS = [&amp;](int x, int fa, int tag) &#123;        if (tag)            id[x] = now++;        for (auto i : g[x])            if (i != fa)                DFS(i, x, tag ^ 1);        if (!tag)            id[x] = now++;        return;    &#125;;    DFS(0, -1, 1);    return id;&#125;int find_next_station(int s, int t, std::vector&lt;int&gt; c) &#123;    if (c.back() &lt; s) &#123;        int fa = c.front();        if (t &gt; s)            return fa;        for (int i = (int)c.size() - 1; ~i; --i)            if (t &gt;= c[i])                return c[i];        return fa;    &#125;    else &#123;        int fa = c.back();        if (t &lt; s)            return fa;        for (int i = 0; i &lt; (int)c.size() - 1; ++i)            if (t &lt;= c[i])                return c[i];        return fa;    &#125;    // assert(0);    return 114514;&#125;</code></pre></details><hr /><h2 id="type-ii调整法---2">Type II：调整法 - 2</h2><p>题目要求构造『恰好为 <span class="math inline">\(k\)</span>』，可以先不看这个限制，对于局面求出上界和下界，然后再看是不是上下界中全部（或大多数）都能取到，此时有两个路径：</p><ul><li>直接在某个上界 / 下界局面中通过若干步极小改动调整到恰好为 <span class="math inline">\(k\)</span>；</li><li>通过这一点优化 DP 状态（这样就可以大量压缩『可到达局面』这一信息）。见 <a href="/20250510/#b---miriany-and-matchstick">此</a>。</li></ul><hr /><h3 id="例题d---construct-the-binary-tree">例题：D - Construct the Binary Tree</h3><p><a href="https://codeforces.com/problemset/problem/1311/E" class="uri">https://codeforces.com/problemset/problem/1311/E</a></p><p>首先从找上下界的角度出发，发现链为上界，完全二叉树为下界。</p><p>那么只需先 check <span class="math inline">\(d\)</span> 是否在该范围内；固定树最左侧的一条链，每次拿走右下角的一个叶子（这样就能<strong>维持完全二叉树性质</strong>），如果可以插入到链底就 do so；否则由于这是个左边挂着单链的完全二叉树，可以证明你想取的任意深度都可以取到，暴力跳即可，且跳完后就构造完了。</p><p>复杂度 <span class="math inline">\(O(n)\)</span>。</p><p><span class="math inline">\(O(nd)\)</span> 是每次取点时扫一遍完全二叉树找一个能让当前点深度 <span class="math inline">\(+1\)</span> 的父节点。<span class="math inline">\(O(d)\)</span> 的做法是慢慢把树变窄变高，一次还是只 <span class="math inline">\(+1\)</span>，二者的弊端都在于没利用『上界为链』即链和完全二叉树的优美性质。</p><details><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;int main() &#123;#ifdef ONLINE_JUDGE    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr), std::cout.tie(nullptr);#else    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);#endif    int T;    for (std::cin &gt;&gt; T; T--; ) &#123;        int n, d;        std::cin &gt;&gt; n &gt;&gt; d;        std::vector&lt;int&gt; tag(n + 1), dep(n + 1), cnt(n + 1), fa(n + 1);        int L = 0, R = n * (n - 1) / 2;        for (int i = 1; i &lt;= n; ++i) &#123;            L += std::__lg(i), dep[i] = std::__lg(i);            if (i * 2 &lt;= n)                ++cnt[i], fa[i * 2] = i;            if (i * 2 + 1 &lt;= n)                ++cnt[i], fa[i * 2 + 1] = i;        &#125;        if (L &lt;= d &amp;&amp; d &lt;= R) &#123;            std::cout &lt;&lt; &quot;YES\n&quot;;            int t = 1;            for (int i = 1; i &lt;= n; i *= 2)                tag[i] = 1, t = i;            for (int i = n; i &amp;&amp; L != d; --i)                if (!tag[i]) &#123;                    // printf(&quot;i = %d\n&quot;, i);                    if (L + (dep[t] + 1) - dep[i] &lt;= d) &#123;                        // printf(&quot;L += %d - %d\n&quot;, dep[t] + 1, dep[i]);                        L += (dep[t] + 1) - dep[i];                        --cnt[fa[i]], cnt[i] = 0, ++cnt[t];                        dep[i] = dep[t] + 1, fa[i] = t;                        t = i, tag[i] = 1;                    &#125;                    else &#123;                        for (int j = 1; j &lt;= n; ++j)                            if (cnt[j] != 2 &amp;&amp; L + (dep[j] + 1) - dep[i] == d) &#123;                                fa[i] = j, L = d;                                break;                            &#125;                    &#125;                &#125;            for (int i = 2; i &lt;= n; ++i)                std::cout &lt;&lt; fa[i] &lt;&lt; &#39; &#39;;            std::cout &lt;&lt; &#39;\n&#39;;        &#125;        else &#123;            // printf(&quot;[%d, %d]\n&quot;, L, R);            std::cout &lt;&lt; &quot;NO\n&quot;;        &#125;    &#125;    return 0;&#125;</code></pre></details><hr /><h2 id="type-iii增量法-规约法">Type III：增量法 / 规约法</h2><p>增量法：类似数归，发现可以方便地从 <span class="math inline">\(n-k\)</span> 扩展到 <span class="math inline">\(n\)</span>，考虑 <span class="math inline">\(n-k\)</span> 给 <span class="math inline">\(k\)</span> 带来的限制 / 性质，就可以类递推地做了。</p><p>规约法：发现抠掉一个好处理的 <span class="math inline">\(k\)</span> 之后可以转化为规模为 <span class="math inline">\(n-k\)</span> 的子问题，考虑 <span class="math inline">\(k\)</span> 给 <span class="math inline">\(n - k\)</span> 带来的限制，也可以类递推地做。</p><p>其实真差不多哈，并不能说是一正一反之类的，因为思维路径真没太差。</p><hr /><h3 id="例题经典题">例题：经典题</h3><blockquote><p>给定大小为 <span class="math inline">\(n\)</span> 的竞赛图，<span class="math inline">\(O(n^2)\)</span> 内求出一条哈密顿路径。</p><ul><li>竞赛图：给完全图的每条边定向。</li><li>哈密顿路径：经过每个点恰好一次，对边无要求。</li></ul></blockquote><p>假设已经知道规模为 <span class="math inline">\(n-1\)</span> 的子问题的解法，塞一个新点进去，考察 <span class="math inline">\(P(n-1)\)</span> 中的 <span class="math inline">\(\forall\, u\to v\)</span>：</p><ul><li>若只存在 <span class="math inline">\(n\to u,n\to v\)</span>：对于路径起点 <span class="math inline">\(s\)</span> 也有 <span class="math inline">\(n\to s\)</span>，把 <span class="math inline">\(n\)</span> 添加到开头即可。</li><li>若只存在 <span class="math inline">\(u\to n,v\to n\)</span>：对于路径终点 <span class="math inline">\(t\)</span> 也有 <span class="math inline">\(t\to n\)</span>，把 <span class="math inline">\(n\)</span> 添加到末尾即可。</li><li>若只存在 <span class="math inline">\(n\to u,v\to n\)</span>：对于路径起点 <span class="math inline">\(s\)</span> 也有 <span class="math inline">\(n\to s\)</span>，对于路径终点 <span class="math inline">\(t\)</span> 也有 <span class="math inline">\(t\to n\)</span>，爱加哪儿就加哪儿。</li><li>否则：存在 <span class="math inline">\(u\to n,n\to v\)</span>，皆大欢喜，将 <span class="math inline">\(u\to v\)</span> 改为 <span class="math inline">\(u\to n\to v\)</span> 即可。</li></ul><p>由此就可以解决问题。</p><hr /><h3 id="例题e---travelling-salesperson">例题：E - Travelling Salesperson</h3><p><a href="https://www.luogu.com.cn/problem/P6644" class="uri">https://www.luogu.com.cn/problem/P6644</a></p><p>注意本题为无向边！</p><p>相似地，对于 <span class="math inline">\(P(n-1)\)</span>，假如存在 <span class="math inline">\(u\to v\)</span>，欲加入 <span class="math inline">\(u\to n\to v\)</span> 讨论以下几种情况：</p><ul><li>若 <span class="math inline">\(P(n - 1)\)</span> 中只含有一种颜色的边：直接加入首 / 尾即可。</li><li>若存在 <span class="math inline">\(\color{red}{\to} u\color{red}{\to}v\color{red}{\to}\)</span>、<span class="math inline">\(u\color{red}{\to} n\)</span> 和 <span class="math inline">\(n\color{red}{\to} v\)</span>（蓝色同理）：直接加入，皆大欢喜。</li><li><p>其余情况，就是 <span class="math inline">\(\color{red}{\to} u\color{blue}{\to} v\color{blue}{\to}\)</span> 的情况了。容易发现除了 <span class="math inline">\(u\color{blue}{\to} n\land n\color{red}{\to} v\)</span> 之外的情况都可以直接将边加入。故接下来讨论该特例。</p><p>此时在 <span class="math inline">\((u,v)\)</span> 处无法加入；尝试考虑相邻的点。由于在 <span class="math inline">\(u\color{blue}{\to} v\)</span> 处切换颜色，易知 <span class="math inline">\(u\ne s\)</span>，即 <span class="math inline">\(u\)</span> 存在前驱（记为 <span class="math inline">\(p\)</span>）。</p><ul><li>若存在 <span class="math inline">\(p\color{blue}{\to} i\)</span>：连接 <span class="math inline">\(p,i,u\)</span>，最终局面为 <span class="math inline">\(\color{red}{\to} p\color{blue}{\to} i\color{blue}{\to} u\color{blue}{\to} v\color{blue}{\to}\)</span>，即将变换处提前两位。</li><li>否则：存在 <span class="math inline">\(p\color{red}{\to} i\)</span>，仍然连接 <span class="math inline">\(p,i,u\)</span>，最终局面为 <span class="math inline">\(\color{red}{\to} p\color{red}{\to} i\color{blue}{\to} u\color{blue}{\to} v\color{blue}{\to}\)</span>，即将变换处提前一位。</li></ul></li></ul><p>由此可解决问题。可以发现并不存在所谓无解的情况 <img src="/em/ll.gif" /> —— 倒不如说可以对所有点套用最后一种情况（和第一种）——就能够 <span class="math inline">\(O(n^2)\)</span> 解决原问题了。</p><details><p>loj 上过了但洛谷过不了 <img src="/em/kt.gif" /></p><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;int main() &#123;#ifdef ONLINE_JUDGE    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr), std::cout.tie(nullptr);#else    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);#endif    int n;    std::cin &gt;&gt; n;    if (n == 1) &#123;        std::cout &lt;&lt; &quot;1\n1&quot; &lt;&lt; &#39;\n&#39;;        return 0;    &#125;    std::vector&lt;std::vector&lt;char&gt; &gt; g(n + 1, std::vector&lt;char&gt; (n + 1));    for (int i = 2; i &lt;= n; ++i)        for (int j = 1; j &lt; i; ++j)            std::cin &gt;&gt; g[i][j], g[j][i] = g[i][j];    for (int i = 1; i &lt;= n; ++i) &#123;        std::vector&lt;int&gt; tag(n + 1);        std::list&lt;int&gt; p(&#123; i, i == 1 ? 2 : 1 &#125;);        tag[p.front()] = tag[p.back()] = 1;        bool flag = 1;        char R = g[p.front()][p.back()], B = ((R == &#39;R&#39;) ? &#39;B&#39; : &#39;R&#39;);        auto pos = --p.end();        for (int j = 1; j &lt;= n; ++j)            if (!tag[j]) &#123;                if (flag &amp;&amp; g[j][p.back()] == R)                    // printf(&quot;%d: 30  &quot;, j),                    p.push_back(j), ++pos;                else if (g[j][p.back()] == B)                    // printf(&quot;%d: 33  &quot;, j),                    p.push_back(j), flag = 0;                else &#123;                    auto u = pos, v = std::next(pos);                    if (g[*u][j] == R &amp;&amp; g[j][*v] == R) &#123;                        // printf(&quot;%d: 38  &quot;, j),                        p.insert(v, j), ++++pos;                        if (v == --p.end())                            flag = 1;                    &#125;                    else if (g[*u][j] == R &amp;&amp; g[j][*v] == B)                        // printf(&quot;%d: 41  &quot;, j),                        p.insert(v, j), ++pos;                    else if (g[*u][j] == B &amp;&amp; g[j][*v] == B)                        // printf(&quot;%d: 44  &quot;, j),                        p.insert(v, j);                    else &#123;                        auto pr(std::prev(u));                        if (g[*pr][j] == B)                            // printf(&quot;%d: 49  &quot;, j),                            p.insert(u, j), ----pos;                        else                            // printf(&quot;%d: 52  &quot;, j),                            p.insert(u, j), --pos;                    &#125;                &#125;                // for (auto j : p)                //     std::cout &lt;&lt; j &lt;&lt; &#39; &#39;;                // printf(&quot; flag = %d\n&quot;, flag);            &#125;        std::cout &lt;&lt; n &lt;&lt; &#39;\n&#39;;        for (auto j : p)            std::cout &lt;&lt; j &lt;&lt; &#39; &#39;;        std::cout &lt;&lt; &#39;\n&#39;;    &#125;    return 0;&#125;</code></pre></details><hr /><h3 id="f---sergeys-problem">F - Sergey’s problem</h3><p><a href="https://codeforces.com/problemset/problem/1019/C" class="uri">https://codeforces.com/problemset/problem/1019/C</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 构造 </tag>
            
            <tag> 调整法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>杂题</title>
      <link href="/20250510/"/>
      <url>/20250510/</url>
      
        <content type="html"><![CDATA[<p>啊啊。小封条。</p><span id="more"></span><hr /><h2 id="a---pass-to-next">A - Pass to Next</h2><p><a href="https://atcoder.jp/contests/arc124/tasks/arc124_e" class="uri">https://atcoder.jp/contests/arc124/tasks/arc124_e</a></p><p>感觉其他一些题解讲得不是特别清楚，这里参考了 <a href="https://blog.csdn.net/weixin_43960287/article/details/119140590">XJX 的文章</a>。</p><p>要求的答案是 <span class="math inline">\(\prod a&#39;_i\)</span>，<mark>发现运算是乘法，比较怪；由此考虑转化为方案数，也就是假设每个人有 <span class="math inline">\(a&#39;_i\)</span> 个互不相同的球，每个人在其中选出恰好一个的方案数</mark>。</p><p>考虑 DP。发现每个人手上的球分为『自己的』和『左边的人传过来的』两种类型；<mark>显然第二种会有来自上一个人的限制，考虑把第二种在上一个人就完成求解</mark>。具体地，设 <span class="math inline">\(f_{i,0}\)</span> 表示第 <span class="math inline">\(i\)</span> 个人选取自己的球，但只记录 <span class="math inline">\(1\sim i-1\)</span> 的方案；<span class="math inline">\(f_{i,1}\)</span> 表示第 <span class="math inline">\(i\)</span> 个人选取第 <span class="math inline">\(i-1\)</span> 个人的球，并记入答案的方案。<em>你可能需要注意到：最后一个被记入方案的球来自第 <span class="math inline">\(i-1\)</span> 个人</em>。</p><p>但这样会有个小问题。我们让所有人多往右边传一个球，那么在我们的这种分割方法看来是不一样的局面；但实际上它们是等价的。从每个人传出了多少个球（设为 <span class="math inline">\(x_i\)</span>）的角度来看，对于 <span class="math inline">\(\min\{x_n\}\ne 0\)</span>，只需要不断执行 <span class="math inline">\(\forall\, x_i\gets x_i-1\)</span> 就可以在局面不变的情况下使 <span class="math inline">\(\min\{x_n\}\ne 0\)</span>。这是在说，可以让 <span class="math inline">\(\min\{x_n\}\ne 0\)</span> 的方案和终局一一对应。</p><p>发现可以容斥：钦定 <span class="math inline">\(x_i\ge 1\)</span>，也就是每个人必须往右传至少一个，相似地算一遍就能得到非法方案。</p><p>考虑转移，令 <span class="math inline">\(x_i\)</span> 可选最小值为 <span class="math inline">\(l\)</span>，有：</p><ul><li><span class="math inline">\(f_{i+1,0}\gets f_{i,0}\)</span>：将第 <span class="math inline">\(i\)</span> 个人未被记入的自己的球记入，球数可能为 <span class="math inline">\([0,a_i-l]\)</span>。等差数列求和即可。</li><li><span class="math inline">\(f_{i+1,0}\gets f_{i,1}\)</span>：没有球需要被记入，但是这种情况对应多种 <span class="math inline">\(x_i\)</span>。具体地，<span class="math inline">\(x_i\in [l,a_i]\)</span>。共有 <span class="math inline">\(a_i-l+1\)</span> 种方案。</li><li><span class="math inline">\(f_{i+1,1}\gets f_{i,0}\)</span>：将第 <span class="math inline">\(i\)</span> 个人的 <span class="math inline">\(a_i\)</span> 个球分给 <span class="math inline">\(i\)</span> 和 <span class="math inline">\(i+1\)</span>。共有 <span class="math inline">\(x_i\cdot (a_i-x_i)\)</span> 种可能，也就是 <span class="math inline">\(\left(a_i\cdot \sum_{x_i=l}^{a_i} x_i\right)-\left(\sum_{x_i=l}^{a_i}{x_i}^2\right)\)</span> 种方案。</li><li><span class="math inline">\(f_{i+1,1}\gets f_{i,1}\)</span>：将第 <span class="math inline">\(i+1\)</span> 个人得到的第 <span class="math inline">\(i\)</span> 个人的球记入，同第一条。</li></ul><p>破环为链，分别钦定第一个人是用自己的球还是上一个人的球来解决问题（必须对于两种可能性分开计算；否则就不知道答案应该取 <span class="math inline">\(f_{n,0}\)</span> 还是 <span class="math inline">\(f_{n,1}\)</span>）。</p><details><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;const int mod = 998244353, inv2 = (mod + 1) &gt;&gt; 1, inv6 = 166374059;int main() &#123;#ifdef ONLINE_JUDGE    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr), std::cout.tie(nullptr);#else    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);#endif    int n;    std::cin &gt;&gt; n;    std::vector&lt;long long&gt; a(n);    for (int i = 1; i &lt;= n; ++i)        std::cin &gt;&gt; a[i % n];    auto sum = [&amp;](long long r) &#123;        return r * (r + 1) % mod * inv2 % mod;    &#125;;    auto sum2 = [&amp;](long long r) &#123;        return r * (r + 1) % mod * (2 * r % mod + 1) % mod * inv6 % mod;    &#125;;    std::vector&lt;std::vector&lt;long long&gt; &gt; f0(n, std::vector&lt;long long&gt; (2)), f1(n, std::vector&lt;long long&gt; (2));    auto calc = [&amp;](long long l, std::vector&lt;std::vector&lt;long long&gt; &gt; &amp;f) &#123;        f[0][0] = 1ll;        for (int i = 0; i &lt; n; ++i) &#123;            int j = (i + 1) % n;            f[j][0] = f[i][0] * sum(a[i] - l) % mod;            (f[j][0] += f[i][1] * (a[i] - l + 1)) %= mod;            f[j][1] = f[i][0] * (a[i] * sum(a[i]) % mod - sum2(a[i])) % mod;            (f[j][1] += f[i][1] * sum(a[i]) % mod) %= mod;            // printf(&quot;0, l = %lld, f[%d]: %lld / %lld\n&quot;, l, j, f[j][0], f[j][1]);        &#125;        auto res(f[0][0]);        f.assign(n, std::vector&lt;long long&gt; (2));        f[0][1] = 1ll;        for (int i = 0; i &lt; n; ++i) &#123;            int j = (i + 1) % n;            f[j][0] = f[i][0] * sum(a[i] - l) % mod;            (f[j][0] += f[i][1] * (a[i] - l + 1)) %= mod;            f[j][1] = f[i][0] * (a[i] * sum(a[i]) % mod - sum2(a[i])) % mod;            (f[j][1] += f[i][1] * sum(a[i]) % mod) %= mod;            // printf(&quot;1, l = %lld, f[%d]: %lld / %lld\n&quot;, l, j, f[j][0], f[j][1]);        &#125;        return (res + f[0][1]) % mod;    &#125;;    std::cout &lt;&lt; (calc(0, f0) + mod - calc(1, f1)) % mod &lt;&lt; &#39;\n&#39;;    return 0;&#125;</code></pre></details><hr /><h2 id="b---绿宝石之岛">B - 绿宝石之岛</h2><p><a href="https://loj.ac/p/6406" class="uri">https://loj.ac/p/6406</a></p><p>因为只关心最终状态，原题可以转化为：将 <span class="math inline">\(d\)</span> 分成 <span class="math inline">\(n\)</span> 个非负整数，前 <span class="math inline">\(r\)</span> 大数之和的期望（当然你需要加上初始的 <span class="math inline">\(r\)</span> 个）。</p><p>关于非负整数拆分：设 <span class="math inline">\(f_{i,j}\)</span> 表示将 <span class="math inline">\(i\)</span> 分成 <span class="math inline">\(j\)</span> 个 <strong>非负整数</strong> 的方案，钦定其中恰有 <span class="math inline">\(k\)</span> 个 <strong>正整数</strong> 进行转移，给这 <span class="math inline">\(k\)</span> 个数先分一个 <span class="math inline">\(1\)</span>，则 <span class="math inline">\(f_{i,j}=\sum\limits_{k=0}^{\min(i,j)} C_j^k\cdot f_{i-k,k}\)</span>。</p><p>再设 <span class="math inline">\(g_{i,j}\)</span> 表示将 <span class="math inline">\(i\)</span> 分成 <span class="math inline">\(j\)</span> 个非负整数的所有方案中、前 <span class="math inline">\(r\)</span> 大的数之和。类似地，有 <span class="math inline">\(g_{i,j}=\sum\limits_{k=0}^{\min(i,j)} C_j^k\cdot (g_{i-k,k}+\min(k,r)\cdot f_{i-k,k})\)</span>。其中，<span class="math inline">\(\min(k,r)\)</span> 的来源是，只有 <span class="math inline">\(k\)</span> 个数有值，前 <span class="math inline">\(r\)</span> 大的数一定在这 <span class="math inline">\(k\)</span> 个数里面。</p><p>答案为 <span class="math inline">\(\dfrac {g_{d,n}}{f_{d,n}}+r\)</span>，复杂度 <span class="math inline">\(O(n^3)\)</span>。</p><details><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;int main() &#123;#ifdef ONLINE_JUDGE    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr), std::cout.tie(nullptr);#else    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);#endif    int n, d, r;    std::cin &gt;&gt; n &gt;&gt; d &gt;&gt; r;    using arr = std::vector&lt;double&gt;;    std::vector&lt;arr&gt; f(d + 1, arr(n + 1)), g(d + 1, arr(n + 1)), C(n + 1, arr(n + 1));    for (int i = 0; i &lt;= n; ++i) &#123;        C[i][0] = 1.;        for (int j = 1; j &lt;= i; ++j)            C[i][j] = C[i - 1][j - 1] + C[i - 1][j];    &#125;    f[0].assign(n + 1, 1.);    for (int i = 1; i &lt;= d; ++i)        for (int j = 1; j &lt;= n; ++j) &#123;            for (int k = 1; k &lt;= i &amp;&amp; k &lt;= j; ++k) &#123;                f[i][j] += C[j][k] * f[i - k][k];                g[i][j] += C[j][k] * (g[i - k][k] + std::min(k, r) * f[i - k][k]);                // printf(&quot;  k = %d, %.0lf + %.0lf\n&quot;, k, C[j][k] * g[i - k][k], std::min(k, r) * f[i - k][k]);            &#125;            // printf(&quot;f[%d][%d] = %.0lf, g[%d][%d] = %.0lf\n&quot;, i, j, f[i][j], i, j, g[i][j]);        &#125;    std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(8) &lt;&lt; g[d][n] / f[d][n] + r &lt;&lt; &#39;\n&#39;;    return 0;&#125;</code></pre></details><hr /><h2 id="c---uddered-but-not-herd-g">C - Uddered but not Herd G</h2><p><a href="https://www.luogu.com.cn/problem/P7296" class="uri">https://www.luogu.com.cn/problem/P7296</a></p><p>给每个字母分配一个标号 <span class="math inline">\(x\)</span>，那么最小段数就是 <span class="math inline">\(\sum \left[x_i\ge x_{i+1}\right]\)</span>。</p><p>考虑状压完成映射操作，令 <span class="math inline">\(f_{s}\)</span> 表示给标号 <span class="math inline">\(1\sim |s|\)</span> 分配字母后，占用字符集 <span class="math inline">\(s\)</span> 的方案数，那么就能 <span class="math inline">\(O(1)\)</span> 得到贡献——只需预处理出 <span class="math inline">\(f_{c, s}\)</span> 表示分配到字母 <span class="math inline">\(c\)</span> 时，已经先给 <span class="math inline">\(s\)</span> 中字母分配了更小标号时的贡献。</p><p>注意字符集大小只有 <span class="math inline">\(20\)</span>，可以 <span class="math inline">\(O(|S|\cdot 2^{|S|})\)</span> 解决问题，<mark>注意到预处理的内容是类高维前缀最值的形式，可以递推降低复杂度</mark>。</p><details><pre data-line="26-28" class="cpp language-cpp"><code data-line="26-28" class="cpp language-cpp">#include &lt;bits/stdc++.h>const int inf = 0x3f3f3f3f;int main() &#123;#ifdef ONLINE_JUDGE    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr), std::cout.tie(nullptr);#else    std::freopen(".in", "r", stdin);    std::freopen(".out", "w", stdout);#endif    int n;    std::string t;    std::cin >> t, n = (int)t.length(), t = "#" + t;    std::vector&lt;int> a, tag(26, -1), s(n + 1);    for (int i = 1; i &lt;= n; ++i) &#123;        if (tag[t[i] - 'a'] == -1)            tag[t[i] - 'a'] = (int)a.size(), a.push_back(t[i] - 'a');        s[i] = tag[t[i] - 'a'];    &#125;    int m = (int)a.size(), siz = 1 &lt;&lt; m;    std::vector&lt;std::vector&lt;int> > cnt(m, std::vector&lt;int> (m));    for (int i = 1; i &lt; n; ++i)        ++cnt[s[i]][s[i + 1]];    std::vector&lt;std::vector&lt;int> > g(m, std::vector&lt;int> (siz));    for (int i = 0; i &lt; m; ++i)        for (int k = 0; k &lt; m; ++k) // 注意这里相当于是钦定从 k 处转移            for (int j = (1 &lt;&lt; k); j &lt; (2 &lt;&lt; k); ++j) // 枚举的是 k 位为 1 的所有数；这两层循环的复杂度为 O(siz)                g[i][j] = g[i][j ^ (1 &lt;&lt; k)] + cnt[i][k]; // 目的是此处的内存连续访问优化，把 ^ 看作 - 应该就能理解为什么第二维是连续的    std::vector&lt;int> f(siz, inf);    f[0] = 1;    for (int i = 1; i &lt; siz; ++i)        for (int j = 0; j &lt; m; ++j)            if ((i >> j) & 1)                f[i] = std::min(f[i], f[i ^ (1 &lt;&lt; j)] + g[j][i]);    std::cout &lt;&lt; f[siz - 1] &lt;&lt; '\n';    return 0;&#125;</code></pre></details><hr /><h2 id="d---min-max-subarrays-p">D - Min Max Subarrays P</h2><p><a href="https://www.luogu.com.cn/problem/P11845" class="uri">https://www.luogu.com.cn/problem/P11845</a></p><p>先考虑 <span class="math inline">\(01\)</span> 序列的答案：如果序列中存在相邻的 <span class="math inline">\(2\)</span> 个 <span class="math inline">\(1\)</span>，总能保证最后的一个是 <span class="math inline">\(1\)</span>。</p><p>如果序列中存在 <span class="math inline">\(\ge 3\)</span> 个 <span class="math inline">\(1\)</span>，可以牺牲其中的一些使得 <span class="math inline">\(2\)</span> 个 <span class="math inline">\(1\)</span> 相邻。</p><p>当序列中只有 <span class="math inline">\(2\)</span> 个 <span class="math inline">\(1\)</span> 时，只有因为剩下的 <span class="math inline">\(0\)</span> 不太够，导致我们无法随意『上下其手』时不能将 <span class="math inline">\(2\)</span> 个 <span class="math inline">\(1\)</span> 挪到一起。</p><p>令两个 <span class="math inline">\(1\)</span> 为序列最大值与次大值，暴搜处理序列长度较小的情况，剩下的直接用奇偶性判断两个 <span class="math inline">\(1\)</span> 取哪个。</p><hr /><h2 id="a---mst-on-line">A - MST on Line++</h2><p><a href="https://atcoder.jp/contests/arc167/tasks/arc167_c" class="uri">https://atcoder.jp/contests/arc167/tasks/arc167_c</a></p><p>相当于把 <span class="math inline">\(a\)</span> 打乱然后处理原问题。考虑每个 <span class="math inline">\(a_i\)</span> 的贡献次数。模拟 Kruskal 连边，从小到大把点 <span class="math inline">\(a_i\)</span> 加入图，<span class="math inline">\(a_i\)</span> 可以向 <span class="math inline">\(a_{[i-K,i+K]}\)</span> 内所有连通块连边。</p><p>连通块数量当且仅当 <span class="math inline">\([i-K,i)\)</span> 内最靠右的点和 <span class="math inline">\((i, i+K]\)</span> 内最靠左的点距离 <span class="math inline">\(&gt;K\)</span> 时为 <span class="math inline">\(2\)</span>，其余情况为 <span class="math inline">\(1\)</span>。</p><p>但要是从这个角度想这个题就不太好做了。正确的想法应该是<mark>拆分为『若 <span class="math inline">\([i-K,i)\)</span> 中有点，贡献次数 <span class="math inline">\(+1\)</span>』和『若 <span class="math inline">\((i,i+K]\)</span> 中有点 <span class="math inline">\(j\)</span> 满足 <span class="math inline">\([j-K,j)\)</span> 中无点，贡献次数 <span class="math inline">\(+1\)</span>』</mark>。对于第一个问题，贡献次数将前 <span class="math inline">\(i-1\)</span> 大的数分配至少一个到 <span class="math inline">\([i-K,i)\)</span> 中的方案数；对于第二个问题，枚举 <span class="math inline">\(j\)</span>，贡献次数为将前 <span class="math inline">\(i-1\)</span> 大的数分配到 <span class="math inline">\(j\)</span> 和 <span class="math inline">\([1,j-K)\cup (j, n]\)</span> 中的方案数。</p><details><p>实现的时候千万注意循环变量枚举的是位置还是值！不然你会调得很痛苦。</p><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;const int mod = 998244353;int main() &#123;#ifdef ONLINE_JUDGE    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr), std::cout.tie(nullptr);#else    std::freopen(&quot;03-max-01.in&quot;, &quot;r&quot;, stdin);    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);#endif    int n, k;    std::cin &gt;&gt; n &gt;&gt; k;    std::vector&lt;int&gt; a(n + 1);    for (int i = 1; i &lt;= n; ++i)        std::cin &gt;&gt; a[i];    std::sort(a.begin() + 1, a.end());    std::vector&lt;long long&gt; fac(n + 1), inv(n + 1);    fac[0] = inv[0] = 1ll;    for (int i = 1; i &lt;= n; ++i)        fac[i] = fac[i - 1] * i % mod;    auto qkp = [](long long x, int y) &#123;        auto res(1ll);        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)            if (y &amp; 1)                (res *= x) %= mod;        return res;    &#125;;    inv[n] = qkp(fac[n], mod - 2);    for (int i = n - 1; i; --i)        inv[i] = inv[i + 1] * (i + 1) % mod;    auto A = [&amp;](int n, int m) &#123;        if (n &lt; m)            return 0ll;        return fac[n] * inv[n - m] % mod;    &#125;;    auto C = [&amp;](int n, int m) &#123;        return A(n, m) * inv[m] % mod;    &#125;;    long long res = 0ll;    for (int i = 2; i &lt;= n; ++i) &#123;        for (int j = 1; j &lt;= n; ++j)            (res += a[i] * (fac[n - 1] + mod - A(n - 1 - (j - std::max(1, j - k)), i - 1) * fac[n - i] % mod) % mod) %= mod;        for (int j = 2; j &lt;= n; ++j)            (res += a[i] * C(i - 1, i - 2) % mod * C(j - std::max(1, j - k), 1) % mod * A(n - (j - std::max(1, j - k) + 1), i - 2) % mod * fac[n - i] % mod) %= mod;    &#125;    std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;    return 0;&#125;</code></pre></details><hr /><h2 id="b---existence-counting">B - Existence Counting</h2><p><a href="https://atcoder.jp/contests/arc174/tasks/arc174_e" class="uri">https://atcoder.jp/contests/arc174/tasks/arc174_e</a></p><p>发现可以分类讨论。假设 <span class="math inline">\(a&#39;\)</span> 中第一个异于 <span class="math inline">\(a\)</span> 的位置为 <span class="math inline">\(i\)</span>，<span class="math inline">\(x\)</span> 在 <span class="math inline">\(a\)</span> 中位置为 <span class="math inline">\(pos_x\)</span>（不存在则 <span class="math inline">\(pos_x=k+1\)</span>）。令 <span class="math inline">\(f_i\)</span> 为若 <span class="math inline">\(1\sim i-1\)</span> 均相同，<span class="math inline">\(i\)</span> 位置可选的选项数。则 <span class="math inline">\(x\)</span> 出现的次数：</p><table><colgroup><col style="width: 25%" /><col style="width: 25%" /><col style="width: 25%" /><col style="width: 25%" /></colgroup><thead><tr class="header"><th style="text-align: center;"></th><th style="text-align: center;"><span class="math inline">\(pos_x&lt;i\)</span></th><th style="text-align: center;"><span class="math inline">\(pos_x=i\)</span></th><th style="text-align: center;"><span class="math inline">\(pos_x&gt;i,i&lt;k\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><span class="math inline">\(x\le a_i\)</span></td><td style="text-align: center;"><span class="math inline">\(1+f_i\cdot A_{n-i}^{k-i}\)</span></td><td style="text-align: center;"><span class="math inline">\(f_i\cdot C_{k-i}^1\cdot A_{n-i-1}^{k-i-1}\)</span></td><td style="text-align: center;"><span class="math inline">\((f_i-1)\cdot C_{k-i}^1\cdot A_{n-i-1}^{k-i-1}+A_{n-i}^{k-i}\)</span></td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(x&gt;a_i\)</span></td><td style="text-align: center;"><span class="math inline">\(f_i\cdot A_{n-i}^{k-i}\)</span></td><td style="text-align: center;"><span class="math inline">\(0\)</span></td><td style="text-align: center;"><span class="math inline">\(f_i\cdot C_{k-i}^1\cdot A_{n-i-1}^{k-i-1}\)</span></td></tr></tbody></table><p>故，对于任意 <span class="math inline">\(x\)</span>，答案为：</p><p><span class="math display">\[\begin{aligned}&amp;1+\left(\sum_{i=pos_x+1}^k f_i\cdot A_{n-i}^{k-i}\right)+\sum_{i=1}^{pos_x} (f_i-[x&lt; a_i])\cdot C_{k-i}^1\cdot A_{n-i-1}^{k-i-1}+[x&lt; a_i]\cdot A_{n-i}^{k-i}\\=&amp;1+\left(\sum_{i=pos_x+1}^k f_i\cdot A_{n-i}^{k-i}\right)+\left(\sum_{i=1}^{pos_x} f_i\cdot C_{k-i}^1\cdot A_{n-i-1}^{k-i-1}\right)+\sum_{i=1,a_i&gt; x}^{pos_x}A_{n-i}^{k-i}-C_{k-i}^1\cdot A_{n-i-1}^{k-i-1}\\\end{aligned}\]</span></p><p>预处理出 <span class="math inline">\(f_i=\sum\limits_{j=i+1}^k [a_j&lt; a_i]\)</span>（需要数据结构）、<span class="math inline">\(g_i=\sum\limits_{j=1}^i f_j\cdot A_{n-j}^{k-j}\)</span> 和 <span class="math inline">\(h_j=\sum\limits_{j=1}^i f_i\cdot C_{k-i}^1\cdot A_{n-i-1}^{k-i-1}\)</span>，再用数据结构计算 <span class="math inline">\(\sum\limits_{i=1,a_i&gt;x}^{pos_x}C_{k-i}^1\cdot A_{n-i-1}^{k-i-1} - A_{n-i}^{k-i}\)</span> 即可。</p><details><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;const int mod = 998244353;int main() &#123;#ifdef ONLINE_JUDGE    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr), std::cout.tie(nullptr);#else    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);#endif    int n, k;    std::cin &gt;&gt; n &gt;&gt; k;    std::vector&lt;int&gt; a(k + 1), p(n + 1, k + 1);    for (int i = 1; i &lt;= k; ++i)        std::cin &gt;&gt; a[i], p[a[i]] = i;    std::vector&lt;long long&gt; fac(n + 1), inv(n + 1);    &#123;        fac[0] = inv[0] = 1ll;        for (int i = 1; i &lt;= n; ++i)            fac[i] = fac[i - 1] * i % mod;        auto qkp = [](long long x, int y) &#123;            auto res(1ll);            for (; y; (x *= x) %= mod, y &gt;&gt;= 1)                if (y &amp; 1)                    (res *= x) %= mod;            return res;        &#125;;        inv[n] = qkp(fac[n], mod - 2);        for (int i = n - 1; i; --i)            inv[i] = inv[i + 1] * (i + 1) % mod;    &#125;    auto A = [&amp;](int n, int m) &#123;        if (n &lt; m || m &lt; 0)            return 0ll;        return fac[n] * inv[n - m] % mod;    &#125;;    std::vector&lt;long long&gt; f(k + 1), g(k + 1), h(k + 1);    std::vector&lt;long long&gt; bit(n + 1);    auto lowbit = [](int x) &#123;        return x &amp; -x;    &#125;;    auto add = [&amp;](int x, int v) &#123;        for (; x &lt;= n; x += lowbit(x))            (bit[x] += v) %= mod;        return;    &#125;;    auto ask = [&amp;](int x) &#123;        auto res(0ll);        for (; x; x -= lowbit(x))            (res += bit[x]) %= mod;        return res;    &#125;;    for (int i = 1; i &lt;= n; ++i)        if (p[i] == k + 1)            add(i, 1);    for (int i = k; i; --i)        f[i] = ask(a[i]), add(a[i], 1);    for (int i = 1; i &lt;= k; ++i) &#123;        g[i] = (g[i - 1] + f[i] * A(n - i, k - i)) % mod;        h[i] = (h[i - 1] + f[i] * (k - i) % mod * A(n - i - 1, k - i - 1)) % mod;        // printf(&quot;%d: f = %lld, g = %lld, h = %lld\n&quot;, i, f[i], g[i], h[i]);    &#125;    std::vector&lt;long long&gt; res(n + 1);    bit.assign(n + 1, 0ll);    auto s(0ll);    for (int i = 1; i &lt;= k; ++i) &#123;        // printf(&quot;%d: %lld + %lld + %lld\n&quot;, a[i], 1 + g[k] - g[i], h[i], s - ask(a[i]));        res[a[i]] = (1 + g[k] - g[i] + h[i] + (s - ask(a[i]))) % mod;        res[a[i]] = (res[a[i]] + mod) % mod;        (s += A(n - i, k - i) - (k - i) * A(n - i - 1, k - i - 1)) %= mod;        add(a[i], (A(n - i, k - i) - (k - i) * A(n - i - 1, k - i - 1)) % mod);    &#125;    for (int i = 1; i &lt;= n; ++i)        if (p[i] == k + 1) &#123;            res[i] = (h[k] + (s - ask(i))) % mod;            res[i] = (res[i] + mod) % mod;        &#125;    for (int x = 1; x &lt;= n; ++x)        std::cout &lt;&lt; res[x] &lt;&lt; &#39;\n&#39;;    return 0;&#125;</code></pre></details><hr /><h2 id="c---1-loop-bubble-sort">C - 1 Loop Bubble Sort</h2><p><a href="https://atcoder.jp/contests/arc187/tasks/arc187_c" class="uri">https://atcoder.jp/contests/arc187/tasks/arc187_c</a></p><p>首先是被考烂了的：对序列进行一次冒泡排序，等价于将序列在前缀最大值处分段，并将其从段首移到段尾；且满足排序前为前缀最大值的元素，排序后仍为前缀最大值。</p><p>考虑用 DP 解决问题。注意状态要从 <span class="math inline">\(P\)</span> 的角度出发——假如 <span class="math inline">\(Q\)</span> 中不存在 <span class="math inline">\(-1\)</span>，发现也需要 DP。此时再设计有关 <span class="math inline">\(Q\)</span> 的状态就很扯淡了，考虑令 <span class="math inline">\(f_{i,j}\)</span> 表示 <span class="math inline">\(P\)</span> 中直到第 <span class="math inline">\(i\)</span> 位的前缀最大值为 <span class="math inline">\(j\)</span> 的方案数。为什么把前缀最大值作为状态呢？因为它可以表示分段；同时限制段间数的取值。具体地，考虑转移：</p><ol type="1"><li>若令 <span class="math inline">\(P_i=j\)</span>，则在 <span class="math inline">\(i\)</span> 处分段。对应到 <span class="math inline">\(Q\)</span> 中，<span class="math inline">\(i-1\)</span> 位是上一个前缀最大值，那么这要求 <span class="math inline">\(Q_{i-1}&lt;j\)</span>，且 <span class="math inline">\(Q_{i-1}\)</span> 是一个前缀最大值。也即：当 <span class="math inline">\(Q_{i-1}\ne -1\)</span> 时，<span class="math inline">\(f_{i,j}\gets f_{i-1, Q_{i-1}}\)</span>；否则，<span class="math inline">\(f_{i,j}\gets \sum\limits_{k&lt;j} f_{i-1,k}\)</span>。其中，二式都要求转移来源为前缀最大值。</li><li>若令 <span class="math inline">\(P_i&lt;j\)</span>，则 <span class="math inline">\(i\)</span> 在 <span class="math inline">\(Q\)</span> 中恰好前移一位，即 <span class="math inline">\(Q_{i-1}=P_i&lt;j\)</span>。则当 <span class="math inline">\(Q_{i-1}\ne -1\)</span> 时，该位确定，<span class="math inline">\(f_{i,j}\gets f_{i-1,j}\)</span>；否则，<span class="math inline">\(Q_{i-1}\)</span> 可选的值为 <span class="math inline">\(&lt;j\)</span> 的所有未选数（定值，可预处理）。</li></ol><p>关于初值，可以在 <span class="math inline">\(P\)</span> 前加一个 <span class="math inline">\(0\)</span> 作为排列的一部分（那么按照冒泡排序的规则 <span class="math inline">\(Q\)</span> 的第一位也一定是 <span class="math inline">\(0\)</span>）来处理就好了。</p><details><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;const int mod = 998244353;int main() &#123;#ifdef ONLINE_JUDGE    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr), std::cout.tie(nullptr);#else    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);#endif    int n;    std::cin &gt;&gt; n;    std::vector&lt;int&gt; q(n + 1), t(n + 1), c(n + 1), pos(n + 1);    for (int i = 1; i &lt;= n; ++i) &#123;        std::cin &gt;&gt; q[i], c[i] = c[i - 1];        if (q[i] == -1)            ++c[i];        else            pos[q[i]] = i;    &#125;    for (int i = 1; i &lt; n; ++i) &#123;        // printf(&quot;t[%d] = %d\n&quot;, i, t[i]);        if (!pos[i])            for (int j = i + 1; j &lt;= n; ++j)                ++t[j];    &#125;    std::vector&lt;std::vector&lt;long long&gt; &gt; f(n + 1, std::vector&lt;long long&gt; (n + 1)), s(n + 1, std::vector&lt;long long&gt; (n + 1));    f[0][0] = 1ll;    s[0].assign(n + 1, 1ll);    for (int i = 1; i &lt;= n; ++i)        for (int j = 1; j &lt;= n; ++j) &#123;            if (q[i - 1] == -1)                f[i][j] = (s[i - 1][j - 1] + f[i - 1][j] * std::max(0, 1 + t[j] - c[i - 1])) % mod;            else if (q[i - 1] &lt; j)                f[i][j] = (f[i - 1][q[i - 1]] + f[i - 1][j]) % mod;            s[i][j] = s[i][j - 1];            if (q[i] == j || !pos[j]) // 满足前缀最大值                (s[i][j] += f[i][j]) %= mod;            // printf(&quot;f[%d][%d] = %lld\n&quot;, i, j, f[i][j]);        &#125;    std::cout &lt;&lt; f[n][n] &lt;&lt; &#39;\n&#39;;    return 0;&#125;</code></pre></details><hr /><h2 id="f---1.-intro">(F - 1). Intro</h2><blockquote><p>给定一个大小为 <span class="math inline">\(n\)</span> 的树，点有点权。给定 <span class="math inline">\(q\)</span> 次操作，分为两种：</p><ol type="1"><li><code>1 x</code>：查询 <span class="math inline">\(x\)</span> 的点权。</li><li><code>2 x d v</code> 对于所有距 <span class="math inline">\(x\)</span> 不超过 <span class="math inline">\(d\)</span> 的点，将它们的权值加上 <span class="math inline">\(v\)</span>。</li></ol><p><span class="math inline">\(n,q\le 10^5,d\le 20\)</span>。</p></blockquote><p>由于 <span class="math inline">\(d\)</span> 很小，我们可能需要枚举与 <span class="math inline">\(x\)</span> 距离 <span class="math inline">\(0\sim d\)</span> 的点进行修改；那么对距离 <span class="math inline">\(x\)</span> 为 <span class="math inline">\(i\)</span> 的点的更改存储在 <span class="math inline">\(f_{x,i}\)</span>，查询 <span class="math inline">\(v\)</span> 时就可以从 <span class="math inline">\(\sum\limits_i f_{fa(v,i),i}\)</span> 求得答案。</p><p>考虑修改。记 <span class="math inline">\(S_{x,d}\)</span> 为距 <span class="math inline">\(x\)</span> 为 <span class="math inline">\(d\)</span> 的点集。<span class="math inline">\(x\)</span> 子树内是好处理的，但子树外的呢？发现 <span class="math inline">\(S_{fa,d-1}\)</span> 中 <span class="math inline">\(x\)</span> 子树外的点，就是 <span class="math inline">\(fa\)</span> 子树下、<span class="math inline">\(x\)</span> 子树外距离 <span class="math inline">\(x\)</span> 为 <span class="math inline">\(d\)</span> 的所有点。</p><p>由于所有 <span class="math inline">\(S_{fa(x,i),d-i}\)</span> 无交，这可能满足我们每个待操作点被不重不漏加一次的要求。考虑将所有 <span class="math inline">\(S_{fa(x,i),d-i}\)</span> 标记出来：</p><figure><img src="1.png" alt="粉色虚线框是待操作点集" /><figcaption>粉色虚线框是待操作点集</figcaption></figure><p>然后我们可以一眼发现被叉的点和未被叉的待操作点是交错的！这意味着我们只需要再补充上所有 <span class="math inline">\(S_{fa(x,i),d-i-1}\)</span> 即可（显然它们之间、它们和所有 <span class="math inline">\(S_{fa(x,i),d-i}\)</span> 之间都不交）。</p><figure><img src="2.png" alt="虚线叉为 S_{fa(x,i),d-i-1}" /><figcaption>虚线叉为 <span class="math inline">\(S_{fa(x,i),d-i-1}\)</span></figcaption></figure><p>此时就可以不重不漏。当然，也会存在一些细节：比如说 <span class="math inline">\(fa(x,i)\)</span> 不存在之类。只需要在根节点 <span class="math inline">\(1\)</span> 处将剩余的 <span class="math inline">\(S_{1,i\to 0}\)</span> 全部更新即可。</p><p>故每次修改操作只需要修改 <span class="math inline">\(O(d)\)</span> 坨点。时间复杂度 <span class="math inline">\(O(qd)\)</span>。</p><hr /><h2 id="f.-distance-to-the-path">F. Distance to the Path</h2><p><a href="https://codeforces.com/problemset/problem/1749/F" class="uri">https://codeforces.com/problemset/problem/1749/F</a></p><p>本例中将单点修改替换为路径修改；考虑树剖解决问题。</p><p>对于路径上的所有点 <span class="math inline">\(u\)</span>，容易发现只需要修改所有的 <span class="math inline">\(S_{u,d}\)</span> 就可以完成对『<strong>一部分路径内侧的点</strong>』的修改。这『一部分』，是因为不包括距离 LCA <span class="math inline">\(\le d\)</span> 的点。</p><p>而『<strong>另一部分路径内侧的点</strong>（距 LCA <span class="math inline">\(\le d\)</span>：见上一行说明）』及『<strong>路径外侧的点</strong>（距 LCA <span class="math inline">\(\le d\)</span>：因为路径在 LCA 子树内，LCA 能够到最远的外侧点）』，等价于『<strong>距 LCA <span class="math inline">\(\le d\)</span> 的点</strong>』，只需要把 LCA 代入上例中方式修改即可。</p><p>修改路径上所有点 <span class="math inline">\(u\)</span> 的 <span class="math inline">\(S_{u,d}\)</span> 时，可以对所有 <span class="math inline">\(f_{*,i}\)</span> 建立数据结构，由于只需要区间修改、单点查询，使用差分树状数组即可。</p><details><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt; int main() &#123;#ifdef ONLINE_JUDGE    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr), std::cout.tie(nullptr);#else    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);#endif    int n, m;    std::cin &gt;&gt; n;    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);    for (int i = 1, x, y; i &lt; n; ++i) &#123;        std::cin &gt;&gt; x &gt;&gt; y;        g[x].push_back(y), g[y].push_back(x);    &#125;    std::vector&lt;int&gt; siz(n + 1), dep(n + 1), fa(n + 1), son(n + 1);    std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int faa) &#123;        siz[x] = 1;        for (auto i : g[x])            if (i != faa) &#123;                fa[i] = x, dep[i] = dep[x] + 1;                DFS(i, x);                siz[x] += siz[i];                if (siz[i] &gt; siz[son[x]])                    son[x] = i;            &#125;        return;    &#125;;    DFS(1, -1);    std::vector&lt;int&gt; dfn(n + 1), top(n + 1);    DFS = [&amp;](int x, int toop) &#123;        static int now = 0;        dfn[x] = ++now, top[x] = toop;        if (son[x])            DFS(son[x], toop);        for (auto i : g[x])            if (i != fa[x] &amp;&amp; i != son[x])                DFS(i, i);        return;    &#125;;    DFS(1, 1);    std::vector&lt;std::vector&lt;long long&gt; &gt; bit(21, std::vector&lt;long long&gt; (n + 1));    auto lowbit = [&amp;](int x) &#123;        return x &amp; -x;    &#125;;    auto add = [&amp;](auto &amp;bit, int x, int v) &#123;        for (; x &lt;= n; x += lowbit(x))            bit[x] += v;        return;    &#125;;    auto ask = [&amp;](auto &amp;bit, int x) &#123;        auto res(0ll);        for (; x; x -= lowbit(x))            res += bit[x];        return res;    &#125;;    std::cin &gt;&gt; m;    for (int op; m--; ) &#123;        std::cin &gt;&gt; op;        if (op == 1) &#123;            int x;            std::cin &gt;&gt; x;            auto res(0ll);            for (int i = 0; i &lt;= 20 &amp;&amp; x; ++i, x = fa[x])                res += ask(bit[i], dfn[x]);            std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;        &#125;        else &#123;            int x, y, v, d;            std::cin &gt;&gt; x &gt;&gt; y &gt;&gt; v &gt;&gt; d;            for (; top[x] != top[y]; x = fa[top[x]]) &#123;                if (dep[top[x]] &lt; dep[top[y]])                    std::swap(x, y);                add(bit[d], dfn[top[x]], v);                add(bit[d], dfn[x] + 1, -v);            &#125;            if (dep[x] &gt; dep[y])                std::swap(x, y);            add(bit[d], dfn[x] + 1, v), add(bit[d], dfn[y] + 1, -v);            for (x = x, y = d; ~y &amp;&amp; x; x = fa[x], --y) &#123;                add(bit[y], dfn[x], v), add(bit[y], dfn[x] + 1, -v);                if (y &amp;&amp; fa[x])                    add(bit[y - 1], dfn[x], v), add(bit[y - 1], dfn[x] + 1, -v);            &#125;            if (x == 0)                for (; ~y; --y)                    add(bit[y], dfn[1], v), add(bit[y], dfn[1] + 1, -v);        &#125;    &#125;    return 0;&#125;</code></pre></details><hr /><h2 id="a---ina-of-the-mountain">A - Ina of the Mountain</h2><p><a href="https://codeforces.com/problemset/problem/1852/C" class="uri">https://codeforces.com/problemset/problem/1852/C</a></p><p>考虑这么一个简化版的问题：</p><blockquote><p>给定 <span class="math inline">\(\{a_n\}\)</span>，每次可以进行区间 <span class="math inline">\(-1\)</span>，问操作多少次才能将所有元素变为 <span class="math inline">\(0\)</span>。</p></blockquote><p>会想到差分；对原数组进行差分，一次操作相当于令 <span class="math inline">\(d_l\gets d_l-1\)</span> 而 <span class="math inline">\(d_{r+1}\gets d_{r+1}+1\)</span>，最后要让 <span class="math inline">\(\forall \,d_i=0\)</span>。那么答案就是差分数组中正数之和嘛。</p><p>回到原问题。原问题等价于把上述问题变为：</p><blockquote><p>给定 <span class="math inline">\(\{a_n\}\)</span>，每次可以进行区间 <span class="math inline">\(-1\)</span>，每个数的总操作次数对 <span class="math inline">\(k\)</span> 取模，问操作多少次才能将所有元素变为 <span class="math inline">\(0\)</span>。</p></blockquote><p>怎么套回到刚刚的问题上呢？还原被取模掉的操作即可。具体来说，提前在 <span class="math inline">\(d\)</span> 上进行若干次操作（记为操作 1），形如令 <span class="math inline">\(d_i\gets d_i+k\)</span>，同时 <span class="math inline">\(d_{i+1}\gets d_{i+1}-k\)</span>。</p><p>会发现相邻的操作 <span class="math inline">\(1\)</span> 对一个数加加减减影响判断；发现可以合并一段连续的操作 1，表现在 <span class="math inline">\(a\)</span> 上也就是区间 <span class="math inline">\(+k\)</span>。此时可以发现，一个位置上只会剩下若干次 <span class="math inline">\(+k\)</span> 或若干次 <span class="math inline">\(-k\)</span> （否则可以把 <span class="math inline">\(+k\)</span> 和 <span class="math inline">\(-k\)</span> 代表的不同操作合并），就不会有互相影响一说了。这也是有的题解说可以提前在 <span class="math inline">\(a\)</span> 上区间 <span class="math inline">\(+k\)</span> 的原因。</p><p>此时问题变为在 <span class="math inline">\(d\)</span> 进行任意次前加 <span class="math inline">\(k\)</span> 后减 <span class="math inline">\(k\)</span> 的操作，使得 <span class="math inline">\(\sum\limits_{d_i&gt;0}d_i\)</span> 最大化。那么显然如果要使代价更小，只可能在原本 <span class="math inline">\(&lt;0\)</span> 的位置做加法、<span class="math inline">\(&gt;0\)</span> 的位置做减法（其他情况会发现一定不优）。考虑两个数 <span class="math inline">\(d_l,d_r\)</span>，可以感受到对于一个 <span class="math inline">\(r\)</span>，选最小的 <span class="math inline">\(d_l\)</span> 是最优的，但什么时候应该选呢？</p><ul><li><span class="math inline">\(d_l\le -k,d_r\ge k\)</span>：当然可选，<span class="math inline">\(k\)</span> 被完全利用，答案减少 <span class="math inline">\(k\)</span>。</li><li><p><span class="math inline">\(d_l&gt;-k,d_r\ge k\)</span>：此时 <span class="math inline">\(k\)</span> 未被完全利用，但必须选：选择其他更大的数，<span class="math inline">\(k\)</span> 的利用率只会更低；如果不选，答案也无法减少。</p><p>Q：此时是否需要尝试找到一个 <span class="math inline">\(l&#39;&lt;l\)</span> 与 <span class="math inline">\(l\)</span> 做操作，使得 <span class="math inline">\(l\)</span> 重新变为负数呢？</p>A：否。因为你可以将这两次操作合并，发现相当于是直接对 <span class="math inline">\((l&#39;,r)\)</span> 做操作，是更劣的。</li><li><span class="math inline">\(d_l\le -k,d_r&lt;k\)</span>：此时 <span class="math inline">\(k\)</span> 未被完全利用，<span class="math inline">\(d_r\)</span> 成为负数。这意味着 <span class="math inline">\(d_r\)</span> 将会成为某个 <span class="math inline">\(r&#39;\)</span> 的可选项。考察 <span class="math inline">\(d_{r&#39;}\)</span> 可用的最小值。如果 <span class="math inline">\(d_r\)</span> 在当前不应该作为右端点，它就一定会被 <span class="math inline">\(d_{r&#39;}\)</span> 选择。具体的有点抽象，但是你可以理解为 <span class="math inline">\(d_r\)</span> 选了 <span class="math inline">\(d_l\)</span> 的贡献是被整合到 <span class="math inline">\(d_r\)</span> 里的；如果 <span class="math inline">\(d_r\)</span> 被选了就说明 <span class="math inline">\(d_{r&#39;}\)</span> 选 <span class="math inline">\(d_l\)</span> 会拥有更大的优势。</li><li><p><span class="math inline">\(d_l&gt;-k,d_r&lt;k\)</span>：和上面的情况相似；但这种情况下答案可能反而变得更大，因为没有后效性，所以至少要保证单步最优。此时不能选。</p><p>说到单步最优，就会发现这里就是反悔贪心；单步最优一定是全局最优，但更靠前的局部最优可能被否定掉。而『否定』的方法表现为一次操作。</p></li></ul><p>综上，从前往后扫，优先队列实时维护负数最小值，对于每个正数，check 选最小值是否优于当前答案，有就选。如果正数被减为负，加入队列。</p><details><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;int main() &#123;#ifdef ONLINE_JUDGE    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr), std::cout.tie(nullptr);#else    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);#endif    int T;    for (std::cin &gt;&gt; T; T--; ) &#123;        int n, k;        std::cin &gt;&gt; n &gt;&gt; k;        std::vector&lt;int&gt; a(n + 1), d(n + 1);        long long res(0ll);        for (int i = 1; i &lt;= n; ++i) &#123;            std::cin &gt;&gt; a[i], a[i] %= k;            d[i] = a[i] - a[i - 1];            if (d[i] &gt; 0)                (res += d[i]);        &#125;        std::priority_queue&lt;int&gt; q;        for (int i = 1; i &lt;= n; ++i)            if (d[i] &lt; 0)                q.push(-d[i]);            else &#123;                for (; !q.empty() &amp;&amp; d[i] &gt; 0; ) &#123;                    int x = -q.top(), y = d[i];                    auto t(res - y);                    x += k, y -= k;                    if (x &gt; 0)                        t += x;                    if (y &gt; 0)                        t += y;                    if (t &gt;= res)                        break;                    q.pop();                    res = t, d[i] = y;                    if (d[i] &lt; 0)                        q.push(-d[i]);                &#125;            &#125;        std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;    &#125;    return 0;&#125;</code></pre></details><hr /><h2 id="b---miriany-and-matchstick">B - Miriany and Matchstick</h2><p><a href="https://codeforces.com/problemset/problem/1852/D" class="uri">https://codeforces.com/problemset/problem/1852/D</a></p><p>从构造的角度出发，看到『恰好为 <span class="math inline">\(k\)</span>』，会想到找到上界和下界并证明中间每一个数都能取到。</p><p>但似乎很容易证伪：例如对于 <code>AAAA</code>，下界为 <span class="math inline">\(0\)</span>，上界为 <span class="math inline">\(4\)</span>，但有且仅有 <span class="math inline">\(1\)</span> 取不到。但该想法并未破产——可以感受到这样的位置很少。进一步地，你 <a href="https://www.luogu.com.cn/article/2mmg5rjd">可以证明只有一个这样的位置</a>，也可以 <a href="https://www.luogu.com.cn/article/679cwjgl">大胆猜想这样的位置一定出现在 <span class="math inline">\(l+1\)</span>，<span class="math inline">\(r-1\)</span></a>。总之现在我们的状态就减少了（或者说状态变成 DP 值了）。预处理出这个东西之后大力搜索找方案即可。</p><details><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;int main() &#123;#ifdef ONLINE_JUDGE    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr), std::cout.tie(nullptr);#else    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);#endif    int T;    for (std::cin &gt;&gt; T; T--; ) &#123;        int n, k;        std::cin &gt;&gt; n &gt;&gt; k;        std::vector&lt;int&gt; a(n + 1);        for (int i = 1; i &lt;= n; ++i) &#123;            char t;            std::cin &gt;&gt; t, a[i] = (t == &#39;A&#39;);            if (i &gt;= 2)                k -= (a[i] ^ a[i - 1]);        &#125;        std::vector&lt;std::array&lt;std::tuple&lt;int, int, int&gt;, 2&gt; &gt; f(n + 1);        f[n][0] = &#123; a[n], a[n], 0 &#125;, f[n][1] = &#123; !a[n], !a[n], 0 &#125;;        auto merge = [&amp;](int i, int l0, int r0, int p0, int l1, int r1, int p1) &#123;            if (l0 &gt; l1)                std::swap(l0, l1), std::swap(r0, r1), std::swap(p0, p1);            int l = l0, r = std::max(r0, r1), p = 0;            if (!p0 &amp;&amp; !p1) &#123;                if (r0 &lt; l1 - 1)                    assert(r0 == l1 - 2), p = r0 + 1;                else;            &#125;            else if (p0 &amp;&amp; p1) &#123;                if (p0 == p1)                    p = p0;                else &#123;                    int tag0 = (l1 &lt;= p0 &amp;&amp; p0 &lt;= r1), tag1 = (l0 &lt;= p1 &amp;&amp; p1 &lt;= r0);                    if (!tag0 &amp;&amp; !tag1);                    else if (!tag0)                        p = p0;                    else if (!tag1)                        p = p1;                    else;                &#125;            &#125;            else if (p0) &#123;                if (l1 &lt;= p0 &amp;&amp; p0 &lt;= r1);                else                    p = p0;            &#125;            else &#123;                if (l0 &lt;= p1 &amp;&amp; p1 &lt;= r0);                else                    p = p1;            &#125;            assert(p != l &amp;&amp; p != r &amp;&amp; l &lt;= r);            return std::make_tuple(l, r, p);        &#125;;        for (int i = n - 1; i; --i) &#123;            &#123;                auto [l0, r0, p0] = f[i + 1][0];                auto [l1, r1, p1] = f[i + 1][1];                if (a[i]) &#123;                    ++l0, ++r0, ++l1, ++r1;                    if (p0) ++p0;                    if (p1) ++p1;                &#125;                ++l1, ++r1;                if (p1) ++p1;                f[i][0] = merge(i, l0, r0, p0, l1, r1, p1);            &#125;            &#123;                auto [l0, r0, p0] = f[i + 1][0];                auto [l1, r1, p1] = f[i + 1][1];                if (!a[i]) &#123;                    ++l0, ++r0, ++l1, ++r1;                    if (p0) ++p0;                    if (p1) ++p1;                &#125;                ++l0, ++r0;                if (p0) ++p0;                f[i][1] = merge(i, l0, r0, p0, l1, r1, p1);            &#125;        &#125;        std::vector&lt;int&gt; res(n + 1);        std::function&lt;bool(int, int, int)&gt; DFS = [&amp;](int x, int cnt, int la) &#123;            if (x == n + 1)                return cnt == k;            auto [l0, r0, p0] = f[x][0];            auto [l1, r1, p1] = f[x][1];            if (cnt + (la == 1) + l0 &lt;= k &amp;&amp; cnt + (la == 1) + r0 &gt;= k &amp;&amp; (!p0 || cnt + (la == 1) + p0 != k) &amp;&amp; DFS(x + 1, cnt + (la == 1) + a[x], 0))                res[x] = 0;            else if (cnt + !la + l1 &lt;= k &amp;&amp; cnt + !la + r1 &gt;= k &amp;&amp; (!p1 || cnt + !la + p1 != k) &amp;&amp; DFS(x + 1, cnt + !la + !a[x], 1))                res[x] = 1;            else                return false;            return true;        &#125;;        if (DFS(1, 0, -1)) &#123;            std::cout &lt;&lt; &quot;YES\n&quot;;            for (int i = 1; i &lt;= n; ++i)                std::cout &lt;&lt; (res[i] ? &#39;A&#39; : &#39;B&#39;);            std::cout &lt;&lt; &#39;\n&#39;;        &#125;        else            std::cout &lt;&lt; &quot;NO\n&quot;;    &#125;    return 0;&#125;</code></pre></details>]]></content>
      
      
      
        <tags>
            
            <tag> DP </tag>
            
            <tag> 容斥原理 </tag>
            
            <tag> 树链剖分 </tag>
            
            <tag> 反悔贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NOIP 模拟赛</title>
      <link href="/20250505/"/>
      <url>/20250505/</url>
      
        <content type="html"><![CDATA[<p>感觉已经不是第一次碰到并查集没有反应过来了！</p><p>已将并查集应用范围总结（当然肯定会很长）加入 to-do list。</p><span id="more"></span><hr /><h2 id="a.-boss-树">A. Boss 树</h2><p><a href="http://222.180.160.110:61235/contest/6248/problem/1" class="uri">http://222.180.160.110:61235/contest/6248/problem/1</a></p><blockquote><p>以 <span class="math inline">\(1\)</span> 为树根，初始被染色；定义一次操作为：对于父亲已染色的白点，同时选取它们中的至多 <span class="math inline">\(m\)</span> 个，并染色。问最少操作次数。</p></blockquote><p>一种策略是按 size 从大到小排序选取当前可选点。证明可能有点感性：</p><p>如果现在有两个可染色点，一个是大小为 <span class="math inline">\(n\)</span> 的菊花，一个是长度为 <span class="math inline">\(n\)</span> 的链；每次可以染色 <span class="math inline">\(2\)</span> 个点，我们一定会留一个位置给链上的点。</p><p>我们把一次选择分配给一个点，无非是希望：</p><ol type="1"><li>它能够供给这个位置尽可能多轮（也就是说它的高度比较高）。</li><li>它能够带来尽可能多的新点。</li></ol><p>那么选 size 最大的就是一种好的手段。当然也可以得到按高度排序的结论，这其实也是对的。</p><details><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;int main() &#123;    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr), std::cout.tie(nullptr);    std::freopen(&quot;boss.in&quot;, &quot;r&quot;, stdin);    std::freopen(&quot;boss.out&quot;, &quot;w&quot;, stdout);    int n, m;    std::cin &gt;&gt; n &gt;&gt; m;    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);    for (int i = 2, fa; i &lt;= n; ++i) &#123;        std::cin &gt;&gt; fa;        g[fa].push_back(i);    &#125;    std::vector&lt;int&gt; siz(n + 1);    std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;        siz[x] = 1;        for (auto i : g[x])            DFS(i), siz[x] += siz[i];        return;    &#125;;    DFS(1);    std::priority_queue&lt;std::pair&lt;int, int&gt; &gt; q, q1;    q.emplace(siz[1], 1);    std::vector&lt;std::vector&lt;int&gt; &gt; res(1);    for (int k = m; !q.empty(); ) &#123;        int u = q.top().second;        res.back().push_back(u), q.pop();        for (auto i : g[u])            q1.emplace(siz[i], i);        if (!--k || q.empty()) &#123;            res.emplace_back(), k = m;            for (; !q1.empty(); q1.pop())                q.push(q1.top());        &#125;    &#125;    if (res.back().empty())        res.pop_back();    std::cout &lt;&lt; (int)res.size() &lt;&lt; &#39;\n&#39;;    for (auto &amp;i : res) &#123;        std::cout &lt;&lt; (int)i.size();        for (auto j : i)            std::cout &lt;&lt; &#39; &#39; &lt;&lt; j;        std::cout &lt;&lt; &#39;\n&#39;;    &#125;    return 0;&#125;</code></pre></details><hr /><h2 id="b.-喝醉的兔子">B. 喝醉的兔子</h2><p><a href="http://222.180.160.110:61235/contest/6248/problem/2" class="uri">http://222.180.160.110:61235/contest/6248/problem/2</a></p><blockquote><p>给定 <span class="math inline">\(q\)</span> 次询问，每次给定 <span class="math inline">\(f(0)\)</span>，求最小的 <span class="math inline">\(t\)</span>，使得 <span class="math inline">\(n | f(t)\)</span>，其中 <span class="math inline">\(f(t)=d\cdot f(t-1) + \Delta_t\)</span>，<span class="math inline">\(n,d,l,r\)</span> 为常数，<span class="math inline">\(\Delta_t\)</span> 为你自选的 <span class="math inline">\([l,r]\)</span> 间的整数，每次询问独立。</p><p><span class="math inline">\(q, n\le 10^7\)</span>。</p></blockquote><p>如果这是数论题，<span class="math inline">\(n\)</span> 就不会和 <span class="math inline">\(q\)</span> 同阶了，所以这可能是一道偏模拟的题目。</p><p>很容易想到建同余图（这里说的是从 <span class="math inline">\([0-r,0-l]\)</span> 出发；这样每个点第一次被 BFS 到的时候就能确定答案了）。但如果直接把图建出来，大小就是 <span class="math inline">\(O(n^2)\)</span> 级别的了。这个时候就有两条路径：</p><h3 id="优化建图">优化建图</h3><p>每次连的点都是连续的一段，容易想到线段树优化建图。这样就能 <span class="math inline">\(O(n\log n)\)</span> 解决问题了。但是题目要求线性。</p><p>在实现的时候一定会注意到我们会连到一些已经被访问过的点。这样的边是『无效』的——我们不能将访问过的点再次加入队列。能不能规避掉这些点呢？</p><p><mark>每次被访问过的点一定是连续的、长度为 <span class="math inline">\(r - l + 1\)</span> 的一段——有没有<a href="/20250202/#texttt-aa-%E5%BC%8F%E5%AD%90%E4%B8%B2%E5%A4%84%E7%90%86">联想到什么</a>？类似地，给 <span class="math inline">\(0\sim n-1\)</span> 每隔 <span class="math inline">\(r-l+1\)</span> 打一个标记——或者说 <strong>分一段</strong></mark>，那么每次试图访问 <span class="math inline">\([l_0, r_0]\)</span> 时：</p><ol type="1"><li><span class="math inline">\([l_0,r_0]\)</span> 为两个相邻段的前后缀。</li><li><span class="math inline">\([l_0,r_0]\)</span> 恰好为一段。</li></ol><p>这时我们就发现了，每次访问的是完整的前后缀，利用前后缀和优化建图，由于边数是 <span class="math inline">\(O(n)\)</span> 的，且边权只有 <span class="math inline">\(0\)</span> 和 <span class="math inline">\(1\)</span>，就可以做到 <span class="math inline">\(O(n)\)</span> 01BFS 解决问题。</p><details><p>但是似乎常数太大了，神威必可之光都跑不过去……</p><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;int main() &#123;#ifdef ONLINE_JUDGE    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr), std::cout.tie(nullptr);    std::freopen(&quot;calculate.in&quot;, &quot;r&quot;, stdin);    std::freopen(&quot;calculate.out&quot;, &quot;w&quot;, stdout);#else    std::freopen(&quot;ex_calculator3.in&quot;, &quot;r&quot;, stdin);    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);#endif    int T;    for (std::cin &gt;&gt; T; T--; ) &#123;        int n, l, r, m, to;        long long d, len;        std::cin &gt;&gt; n &gt;&gt; d &gt;&gt; l &gt;&gt; r &gt;&gt; m, len = r - l + 1, to = (n - 1) / len + 1;        std::vector&lt;std::vector&lt;int&gt; &gt; t(n), lid(to), rid(to);        for (int i = 0; i &lt; n; ++i)            t[i * d % n].push_back(i);        std::vector&lt;std::vector&lt;int&gt; &gt; g(3 * n);        for (int i = 0, id = n - 1; i &lt; to; ++i) &#123;            int at = ((i != to - 1 || !(n % len)) ? len : (n % len));            lid[i].resize(at), rid[i].resize(at);            for (int j = 0; j &lt; at; ++j) &#123;                lid[i][j] = ++id;                g[id].push_back(i * len + j);                if (j != 0)                    g[id].push_back(id - 1);            &#125;            for (int j = at - 1; ~j; --j) &#123;                rid[i][j] = ++id;                g[id].push_back(i * len + j);                if (j != at - 1)                    g[id].push_back(id - 1);            &#125;        &#125;        auto add = [&amp;](int p, int l0, int r0) &#123;            int p1 = l0 / len, p2 = r0 / len;            if (p1 == p2)                g[p].push_back(lid[p1].back());            else &#123;                g[p].push_back(rid[p1][l0 % len]);                if ((p1 + 1) % to != p2) &#123;                    // fprintf(stderr, &quot;p1 = %d, p2 = %d, to = %d, get %d(%d)\n&quot;, p1, p2, to, (p1 + 1) % to, (int)lid[(p1 + 1) % to].size());                    g[p].push_back(lid[(p1 + 1) % to].back());                &#125;                g[p].push_back(lid[p2][r0 % len]);            &#125;            return;        &#125;;        for (int i = 0; i &lt; n; ++i)            for (auto j : t[i]) &#123;                // printf(&quot;%d -&gt; %d[%d, %d]\n&quot;, i, j, (j + n - r) % n, (j + n - l) % n);                add(i, (j + n - r) % n, (j + n - l) % n);            &#125;        std::deque&lt;std::pair&lt;int, int&gt; &gt; q;        std::vector&lt;int&gt; f(n + 1, -1), tag(3 * n + 1);        for (int i = l, p = (n - r) % n; i &lt;= r; ++i, (++p) %= n)            f[p] = 0, q.emplace_back(p, 0), tag[p] = 2;        for (; !q.empty(); ) &#123;            auto [u, d] = q.front();            q.pop_front();            if (u &lt; n &amp;&amp; f[u] == -1)                f[u] = d;            // printf(&quot;u = %d, d = %d\n&quot;, u, d);            for (auto i : g[u]) &#123;                // printf(&quot;  i = %d\n&quot;, i);                if (i &gt;= n &amp;&amp; tag[i] &lt;= 1)                    q.emplace_front(i, d), tag[i] = 2;                if (i &lt; n &amp;&amp; !tag[i])                    q.emplace_back(i, d + 1), tag[i] = 1;            &#125;        &#125;        for (int x; m--; )            std::cin &gt;&gt; x, std::cout &lt;&lt; f[x] &lt;&lt; &#39;\n&#39;;    &#125;    return 0;&#125;</code></pre></details><p>或者，发现<mark>每次任意标记前后缀，则一段内未访问的一定是中间的一整截</mark>。根据这一点可维护每一段内可访问元素，就能 <span class="math inline">\(O(n)\)</span> BFS；</p><p>如果把图建出来了，还可以解决扩展问题：</p><blockquote><p>假如 <span class="math inline">\(\Delta_i\)</span> 在 <span class="math inline">\([l,r]\)</span> 间的整数中等概率取值，则最优解出现的概率？</p></blockquote><p>为什么 BFS 不能解决该问题呢？因为同层同代价的点对共同能访问到的点的贡献不会被 BFS 记入（注意到一个点只会被一个点访问到），所以只有建图出来才能解决问题。</p><p>这也侧面反映该图在忽略环后所对应的就是最优解，这其实是有点 BFS 扩展出来的意味在的。</p><h3 id="不把图建出来直接-bfs-是否能优化呢">不把图建出来，直接 BFS 是否能优化呢？</h3>]]></content>
      
      
      
        <tags>
            
            <tag> 分治 </tag>
            
            <tag> 树形 DP </tag>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>连通图计数</title>
      <link href="/20250430/"/>
      <url>/20250430/</url>
      
        <content type="html"><![CDATA[<figure><img src="/20250430/neko.png" alt="猫" style="width: 75px"><figcaption>猫</figcaption></figure><span id="more"></span><p>太可怕了！2025 年才过去 4 个月，正经文章的总数已经和 2024 年中正经文章的总数一样多了。</p><hr /><h2 id="有标号无向图计数">有标号无向图计数</h2><p>问题模型大概如下：</p><blockquote><p>给定 <span class="math inline">\(N\)</span> 个点，你可以在它们间任意连边，但存在限制：</p><ul><li>其中一个较好处理（如要求图必须是二分图）；</li><li>另一个较难处理（如去重问题等）；</li><li>最后，可能要求图连通。</li></ul></blockquote><p>首先需要知道怎么处理这样的计数问题。以下皆建立在无重边、自环的基础上。</p><ol type="1"><li><p>先只考虑容易的限制，且不要求连通：</p><p><em>注：如果发现 <strong>不连通</strong> 的时候没办法很方便地计算精确方案数（也就是说会算重），那么可以把 <strong>去重</strong> 作为较难的限制，这一步算重就不重要了</em>。</p><p>该怎么求怎么求。例如，若该限制是二分图且可以算重，枚举左部点数及边，那么方案数就是 <span class="math inline">\(\sum\limits_{i=0}^n C_n^i\cdot C_{i\cdot (n-i)}^m\)</span>。</p>这个时候需要注意到算重部分的意义是什么。比如此处，计算中一个连通块将左右部翻转后被视作不同的子图，但在全局看来对应的总图是同一个二分图。因此，对于拥有 <span class="math inline">\(k\)</span> 个连通块的图，其被计算了 <span class="math inline">\(2^k\)</span> 次。</li><li><p>再加上必须连通的限制，仍只考虑容易的限制：</p><p>如果不存在其他限制，那么就是 <a href="https://oeis.org/A001187">A001187</a>。</p><p>连通的方案就是任意的方案减去不连通的方案。</p><ul><li>任意的求法就是第一点；</li><li>不连通的方案，枚举 <span class="math inline">\(1\)</span> 所在子集，让其补集里面任意连边（第 1 点的子问题）且不和 <span class="math inline">\(1\)</span> 所在子集相连。</li></ul></li><li><p>接着，对连通的情况应用较难处理的限制：</p><p><em>因为连通会带来一些比较好的性质简化运算，所以选择在这一步加上较难的限制</em>。</p>例如，对于上文中二分图去重的例子，连通图中显然只有一个连通块，将连通图的方案 <span class="math inline">\(\div 2\)</span> 就可以得到答案。</li><li><p>最后，如果题目要求任意图的方案，用第三步中的答案再次算出任意图的答案。</p><p>相当于是把第 2 点中的过程反过来，枚举 <span class="math inline">\(1\)</span> 所在子集，在其补集中任意连边（该问的子问题）且可以和 <span class="math inline">\(1\)</span> 所在的子集连边。</p></li></ol><p>这样就可以解决问题。</p><hr /><h3 id="a---many-good-tuple-problems">A - Many Good Tuple Problems</h3><p><a href="https://atcoder.jp/contests/abc327/tasks/abc327_g" class="uri">https://atcoder.jp/contests/abc327/tasks/abc327_g</a></p><p>如果把一组 <span class="math inline">\((S_i,T_i)\)</span> 看作一条边的话，原限制就可以转化为：在 <span class="math inline">\(N\)</span> 个点中连 <span class="math inline">\(M\)</span> 条可重边，形成二分图的方案数。边有序。</p><p><del>你可以发现我偷懒把这道题拿去上面举例了</del>，由于边是可重的，而我们的模型要求无重边，但发现这个限制是独立于模型外的，也就是可以在最后枚举有多少条不同边，再用一点组合手段计算实际贡献。</p><p>首先令 <span class="math inline">\(f_{0,n,m}\)</span> 表示 <span class="math inline">\(n\)</span> 个点、<span class="math inline">\(m\)</span> 条边、<strong>不去重</strong>、<strong>连通性任意</strong> 的方案数，那么 <span class="math inline">\(f_{0,n,m}=\sum_{i=0}^n C_n^i\cdot C_{i\cdot (n-i)}^m\)</span>。</p><p>令 <span class="math inline">\(f_{1,n,m}\)</span> 表示 <strong>不去重</strong>、要求 <strong>连通</strong> 的方案，那么有 <span class="math inline">\(f_{1,n,m}=f_{0,n,m}-\sum\limits_{i,j} C_{n - 1}^{i-1}\cdot f_{1,i,j}\cdot f_{0,n-i,m-j}\)</span>。</p><p>令 <span class="math inline">\(f_{2,n,m}\)</span> 表示 <strong>去重</strong>，要求 <strong>连通</strong> 的方案，那么有 <span class="math inline">\(f_{2,n,m}=\dfrac {f_{1,n,m}}{2}\)</span>。</p><p>令 <span class="math inline">\(f_{3,n,m}\)</span> 表示 <strong>去重</strong>，<strong>连通性任意</strong> 的方案数，那么有 <span class="math inline">\(f_{3,n,m}=\sum\limits_{i,j} C_{n-1}^{i-1} \cdot f_{2,i,j} \cdot f_{3,n-i,m-j}\)</span>。</p><p>最后的方案数为 <span class="math inline">\(\sum\limits_{j} f_{3,n,j}\cdot F(m,j)\)</span>。其中 <span class="math inline">\(F(m,j)\)</span> 表示把 <span class="math inline">\(m\)</span> 个有标号的球放在 <span class="math inline">\(j\)</span> 个有标号的盒子里，不空放的方案数，可以容斥。最后注意边反向算两种，所以乘上 <span class="math inline">\(2^m\)</span>。</p><p>复杂度 <span class="math inline">\(O(n^6)\)</span>。</p><details><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;const int mod = 998244353;const int inv2 = (mod + 1) &gt;&gt; 1;int main() &#123;#ifdef ONLINE_JUDGE    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr), std::cout.tie(nullptr);#else    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);#endif    int n, M, m;    std::cin &gt;&gt; n &gt;&gt; M, m = std::min(n * (n - 1) / 2, M);    std::vector&lt;std::vector&lt;long long&gt; &gt; C(n * n + 1, std::vector&lt;long long&gt; (n * n + 1));    for (int i = 0; i &lt;= n * n; ++i) &#123;        C[i][0] = 1ll;        for (int j = 1; j &lt;= i; ++j)            C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % mod;    &#125;    std::vector&lt;std::vector&lt;std::vector&lt;long long&gt; &gt; &gt; f(4, std::vector&lt;std::vector&lt;long long&gt; &gt; (n + 1, std::vector&lt;long long&gt; (m + 1)));    for (int i = 1; i &lt;= n; ++i)        for (int j = 0; j &lt;= m &amp;&amp; j &lt;= i * (i - 1) / 2; ++j)            for (int k = 0; k &lt;= i; ++k)                (f[0][i][j] += C[i][k] * C[k * (i - k)][j]) %= mod;    for (int i = 1; i &lt;= n; ++i)        for (int j = 0; j &lt;= m; ++j) &#123;            auto t(0ll);            for (int k = 1; k &lt;= i; ++k)                for (int l = 0; l &lt;= j; ++l)                    (t += C[i - 1][k - 1] * f[1][k][l] % mod * f[0][i - k][j - l]) %= mod;            f[1][i][j] = (f[0][i][j] + mod - t) % mod;            f[2][i][j] = f[1][i][j] * inv2 % mod;        &#125;    f[3][0][0] = 1ll;    for (int i = 1; i &lt;= n; ++i)        for (int j = 0; j &lt;= m; ++j)            for (int k = 1; k &lt;= i; ++k)                for (int l = 0; l &lt;= j; ++l)                    (f[3][i][j] += C[i - 1][k - 1] * f[2][k][l] % mod * f[3][i - k][j - l]) %= mod;    auto qkp = [](long long x, int y) &#123;        auto res(1ll);        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)            if (y &amp; 1)                (res *= x) %= mod;        return res;    &#125;;    std::vector&lt;long long&gt; F(m + 1);    for (int i = 1; i &lt;= m; ++i) &#123;        F[i] = qkp(i, M);        for (int j = 1, p = mod - 1; j &lt; m; ++j, p = mod - p)            (F[i] += p * C[i][j] % mod * qkp(i - j, M)) %= mod;    &#125;    auto res(0ll);    for (int j = 1; j &lt;= m; ++j)        (res += f[3][n][j] * F[j]) %= mod;    std::cout &lt;&lt; res * qkp(2, M) % mod &lt;&lt; &#39;\n&#39;;    return 0;&#125;</code></pre></details><hr /><h3 id="b---many-mst">B - Many MST</h3><p><a href="https://atcoder.jp/contests/abc386/tasks/abc386_g" class="uri">https://atcoder.jp/contests/abc386/tasks/abc386_g</a></p><p>这里需要注意到 MST 和连通块的隐含联系。按照 Kruskal 的生成方式可以发现只需要在合并两个连通块时加上它们之间连边中最小的边权就可以得到 MST。</p><p>因此容易想到在 DP 时对最小边权进行限制；枚举 <span class="math inline">\(k\)</span>，让边权 <span class="math inline">\(\le k\)</span> 成为简单限制；让求解 MST 成为某种意义上的较难限制。</p><p>令 <span class="math inline">\(f_{0,n,k}\)</span> 表示 <span class="math inline">\(n\)</span> 个点，边权 <span class="math inline">\(\le k\)</span>、<strong>对连通性没有要求</strong> 的方案数；相应地，<span class="math inline">\(f_{1,n,k}\)</span> 表示 <strong>要求连通</strong> 的方案数，则：</p><ul><li><p><span class="math inline">\(f_{0,n,k}=\sum\limits_i C_{n-1}^{i-1}\cdot f_{1,i,k-1} \cdot f_{0,n-i,k}\cdot (M-k+1)^{i\times(n-i)}\)</span>。</p><p>注解：式子正确性建立在 <strong><span class="math inline">\(1\)</span> 所在 的由权值 <span class="math inline">\(&lt;k\)</span> 的边构成的最大连通块 大小为 <span class="math inline">\(i\)</span></strong> 的基础之上，故两个连通块之间的边权只能 <span class="math inline">\(\ge k\)</span>。这也提醒我们，此处的 <strong>不连通</strong> 含义实际上是给这些边一个 <span class="math inline">\((M-k)\)</span> 的系数。</p>那么这样你会注意到，<span class="math inline">\(f_0\)</span> 的意义就与 <span class="math inline">\(k\)</span> 无关了（那么显然值也与 <span class="math inline">\(k\)</span> 无关），但是仍然保留 <span class="math inline">\(k\)</span> 对思考有帮助，故留之。</li><li><p><span class="math inline">\(f_{1,n,k}=f_{0, n, k} - \sum\limits_i C_{n - 1}^{i-1} \cdot f_{1,i,k}\cdot f_{0,n-i,k}\times (M-k)^{i\times (n - i)}\)</span>。</p></li></ul><p>令 <span class="math inline">\(g_{0, n, k}\)</span> 表示 <span class="math inline">\(n\)</span> 个点、边权 <span class="math inline">\(\le k\)</span>、<strong>对连通性没有要求</strong> 的 MST 之和；相应地，<span class="math inline">\(g_{1,n,k}\)</span> 表示对应条件下 <strong>要求连通</strong> 的 MST 之和。则：</p><ul><li><p><span class="math inline">\(g_{0,n,k}=\sum\limits_{i} C_{n-1}^{i-1}\cdot (f_{1,i,k - 1}\cdot g_{0,n-i,k}+g_{1,i,k - 1} \cdot f_{0,n-i,k}+f_{1,i,k-1}\cdot f_{0,n-i,k}\cdot k)\cdot (M-k+1)^{i\times (n-i)}\)</span>。</p>注解：类比 <span class="math inline">\(f_0\)</span> 的计算方式得到 <span class="math inline">\(g_0\)</span>。在 <span class="math inline">\(i\times (n-i)\)</span> 中任选一条作为 MST 上权值为 <span class="math inline">\(k\)</span> 的边，故有 <span class="math inline">\(f_{1,i,k-1}\cdot f_{0,n-i,k}\cdot k\)</span>。之所以必须要求有这么一条边是为了和 <span class="math inline">\(g_{k-1}\)</span> 和 <span class="math inline">\(g_{k+1}\)</span> 等区分。</li><li><p><span class="math inline">\(g_{1,n,k}=g_{0,n,k}-\sum\limits_i C_{n-1}^{i-1}\cdot (f_{1,i,k}\cdot g_{0,n-i,k}+g_{1,i,k}\cdot f_{0,n-i,k}+f_{1,i,k}\cdot f_{0,n-i,k}\cdot k)\cdot (M-k)^{i\times (n-i)}\)</span>。</p></li></ul><p>复杂度 <span class="math inline">\(O(n^2\cdot M)\)</span>。要求预处理幂，不然会 T。以及可能需要把 <span class="math inline">\(f_0,f_1,g_0,g_1\)</span> 放在同一个内层循环求，不然会卡常；<del>在此基础上使用内存连续访问优化似乎并不明显</del> <img src="/em/kt.gif" /></p><details><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;const int mod = 998244353;int main() &#123;#ifdef ONLINE_JUDGE    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr), std::cout.tie(nullptr);#else    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);#endif    int N, M;    std::cin &gt;&gt; N &gt;&gt; M;    using arr = std::vector&lt;long long&gt;;    using brr = std::vector&lt;arr&gt;;    using crr = std::vector&lt;brr&gt;;    crr f(2, brr(N + 1, arr(M + 1))), g(2, brr(N + 1, arr(M + 1)));    brr C(N + 1, arr(N + 1)), p(M + 1, arr(N * N + 1));    for (int i = 0; i &lt;= M; ++i) &#123;        p[i][0] = 1ll;        for (int j = 1; j &lt;= N * N; ++j)            p[i][j] = p[i][j - 1] * i % mod;    &#125;    for (int i = 0; i &lt;= N; ++i) &#123;        C[i][0] = 1ll;        for (int j = 1; j &lt;= i; ++j)            C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % mod;    &#125;    f[1][0][0] = f[1][1][0] = 1ll;    for (int n = 1; n &lt;= N; ++n)        for (int k = 1; k &lt;= M; ++k) &#123;            f[0][n][k] = f[1][n][k - 1];            for (int i = 1; i &lt; n; ++i) &#123;                (f[0][n][k] += C[n - 1][i - 1] * f[1][i][k - 1] % mod * f[0][n - i][k] % mod * p[M - k + 1][i * (n - i)]) %= mod;                (f[1][n][k] += mod - C[n - 1][i - 1] * f[1][i][k] % mod * f[0][n - i][k] % mod * p[M - k][i * (n - i)] % mod) %= mod;            &#125;            (f[1][n][k] += f[0][n][k]) %= mod;        &#125;    for (int n = 1; n &lt;= N; ++n)        for (int k = 1; k &lt;= M; ++k) &#123;            g[0][n][k] = g[1][n][k - 1];            for (int i = 1; i &lt; n; ++i) &#123;                (g[0][n][k] += (f[1][i][k - 1] * g[0][n - i][k] % mod + g[1][i][k - 1] * f[0][n - i][k] % mod + f[1][i][k - 1] * f[0][n - i][k] % mod * k) % mod * C[n - 1][i - 1] % mod * p[M - k + 1][i * (n - i)]) %= mod;                (g[1][n][k] += mod - (f[1][i][k] * g[0][n - i][k] % mod + g[1][i][k] * f[0][n - i][k] % mod + f[1][i][k] * f[0][n - i][k] % mod * k) % mod * C[n - 1][i - 1] % mod * p[M - k][i * (n - i)] % mod) %= mod;            &#125;            (g[1][n][k] += g[0][n][k]) %= mod;        &#125;    // for (int n = 1; n &lt;= N; ++n)    //     for (int k = 1; k &lt;= M; ++k) &#123;    //         printf(&quot;f[0][%d][%d] = %lld\n&quot;, n, k, f[0][n][k]);    //         printf(&quot;f[1][%d][%d] = %lld\n&quot;, n, k, f[1][n][k]);    //         printf(&quot;g[0][%d][%d] = %lld\n&quot;, n, k, g[0][n][k]);    //         printf(&quot;g[1][%d][%d] = %lld\n&quot;, n, k, g[1][n][k]);    //     &#125;    std::cout &lt;&lt; g[1][N][M] &lt;&lt; &#39;\n&#39;;    return 0;&#125;</code></pre></details><hr /><h2 id="有标号-dag-计数">有标号 DAG 计数</h2><blockquote><p>给定 <span class="math inline">\(N\)</span> 个点，你可以在它们间任意连边，要求最后图为 DAG，可能要求图弱连通。</p></blockquote><p>如果说无向图计数关键在于连通块，那么 DAG 在此基础上关键在于入度为 <span class="math inline">\(0\)</span> 的点集。</p><p>令 <span class="math inline">\(f(i)\)</span> 表示 <span class="math inline">\(i\)</span> 个点的 DAG 的答案；<span class="math inline">\(g_{0, i,j}\)</span> 表示 <span class="math inline">\(i\)</span> 个点的 DAG，其中 <span class="math inline">\(j\)</span> 个入度为 <span class="math inline">\(0\)</span> 的方案，不难想到容斥：令 <span class="math inline">\(g_{1,i,j}\)</span> 表示至少 <span class="math inline">\(j\)</span> 个的方案，那么：</p><p><span class="math display">\[g_{1,i,j}=C_i^j\times f(i-j)\times 2^{j\times (i-j)}\\g_{0,i,j}=\sum_{k=j}^i (-1)^{k-j}\cdot C_k^j\cdot g_{1,i,j}\\f(i)=\sum_{j=1}^i g_{0,i,j}\]</span></p><p>整理有：</p><p><span class="math display">\[\begin{aligned}f(i)&amp;=\sum_{j=1}^i \sum_{k=j}^i (-1)^{k-j}\cdot C_k^j\cdot g_{1,i,k}\\&amp;=\sum_{k=1}^i (-1)^k\cdot g_{1,i,k}\cdot \sum_{j=1}^k (-1)^j\cdot C_k^j\\&amp;=\sum_{k=1}^i (-1)^k\cdot g_{1,i,k}\cdot (0^k-1)\\&amp;=\sum_{k=1}^i (-1)^{k+1}\cdot C_i^k\times f(i-k)\times 2^{(i-k)}\end{aligned}\]</span></p><p>即得递推式。如果要求连通仿照无向图连通的方法，用任意减去不连通即可。</p><hr /><h3 id="c---amusement-park">C - Amusement Park</h3><p><a href="https://codeforces.com/problemset/problem/1193/A" class="uri">https://codeforces.com/problemset/problem/1193/A</a></p><p>先考虑计算方案数。枚举 <span class="math inline">\(1\)</span> 所在子集，那么有 <span class="math inline">\(f(S)=\sum\limits_{T\in S} (-1)^{|T|+1}\cdot f(S - T)\)</span>。相较于一般的 DAG 计数，因为每条边取不取是固定的，所以没有了 <span class="math inline">\(2\)</span> 的次幂的系数；同时因为直接枚举子集，所以没有了组合系数。</p><p>注意此处 <span class="math inline">\(T\)</span> 可构成一轮新的入度为 <span class="math inline">\(0\)</span> 的点集当且仅当 <span class="math inline">\(T\)</span> 之内没有连边，即 <span class="math inline">\(T\)</span> 为独立集。</p><p>算出方案数后如何算答案呢？发现对于一种合法的方案，把里面所有的边反向一定唯一对应另一种合法方案，两种方案取反边数相加为 <span class="math inline">\(m\)</span>；那么给所有方案除以 <span class="math inline">\(2\)</span>，再乘上 <span class="math inline">\(m\)</span> 就能得到答案。</p><p>复杂度 <span class="math inline">\(O(3^n)\)</span>。需要提前把每个点集是否独立预处理下来。</p><details><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;const int mod = 998244353, inv2 = (mod + 1) &gt;&gt; 1;int main() &#123;#ifdef ONLINE_JUDGE    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr), std::cout.tie(nullptr);#else    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);#endif    int n, m;    std::cin &gt;&gt; n &gt;&gt; m;    std::vector&lt;int&gt; g(n + 1);    for (int i = 1, x, y; i &lt;= m; ++i) &#123;        std::cin &gt;&gt; x &gt;&gt; y;        g[x] |= (1 &lt;&lt; (y - 1));        g[y] |= (1 &lt;&lt; (x - 1));    &#125;    auto check = [&amp;](int s) &#123;        for (int i = 1; i &lt;= n; ++i)            if ((s &gt;&gt; (i - 1)) &amp; 1)                if (s &amp; g[i])                    return false;        return true;    &#125;;    int siz = 1 &lt;&lt; n;    std::vector&lt;int&gt; tag(siz);    for (int i = 0; i &lt; siz; ++i)        tag[i] = check(i);    std::vector&lt;long long&gt; f(siz);    f[0] = 1ll;    for (int i = 1; i &lt; siz; ++i)        for (int j = i; j; j = (j - 1) &amp; i)            if (tag[j])                (f[i] += ((__builtin_popcount(j) &amp; 1) ? 1 : mod - 1) * f[i ^ j]) %= mod;    std::cout &lt;&lt; f[siz - 1] * inv2 % mod * m % mod &lt;&lt; &#39;\n&#39;;    return 0;&#125;</code></pre></details><hr /><h3 id="d---balance-scale">D - Balance Scale</h3><p><a href="https://atcoder.jp/contests/abc306/tasks/abc306_h" class="uri">https://atcoder.jp/contests/abc306/tasks/abc306_h</a></p><p>可以发现，如果将被 <code>=</code> 连起来的点缩起来，就可以转化成上一个问题。但枚举被缩的点集显然是不能通过的，这里介绍一种方法。</p><p>不把缩点放在开头。在上一题中的 DP 式子 <span class="math inline">\(f(S)=\sum\limits_{T\in S} (-1)^{|T|+1}\cdot f(S - T)\)</span> 中，考虑和我们最终的答案有什么差异：</p><ol type="1"><li>在现在的问题中，有的边是可以不选的！考虑这会给容斥带来怎样的影响。</li></ol><p>首先应该知道一件事情：你决定把一部分点缩到一起，当且仅当它们全部由 <code>=</code> 连接。要让一些边加入 DP，也就是让它们不是 <code>=</code>，当且仅当它们成为连通块的『割』——把连通块分成多个连通块。这种情况显然已经由另一条路径转移过了。也就是说，就用这个式子可以得到所有答案。 1. 另一个问题，在上一题中，我们可以轻易地判断 <span class="math inline">\(T\)</span> 是否为独立集；但在本问中，不是独立集的点集也可能缩点成为独立集。</p><p>发现有一种唯一方法，就是使 <span class="math inline">\(T\)</span> 中位于同一连通块的点缩到一起；所以应该将 <span class="math inline">\(-1\)</span> 的次数替换为 <span class="math inline">\(T\)</span> 所在连通块个数 <span class="math inline">\(+1\)</span>。</p><p>注意这里说的连通块是 <span class="math inline">\(T\)</span> 的导出子图中的连通块。</p><p>这也启示我们不要把缩点和图的连通性等等关联得太死，需要把点等价的场景都可能用到缩点。</p><details><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;const int mod = 998244353, inv2 = (mod + 1) &gt;&gt; 1;int main() &#123;#ifdef ONLINE_JUDGE    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr), std::cout.tie(nullptr);#else    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);#endif    int n, m;    std::cin &gt;&gt; n &gt;&gt; m;    std::vector&lt;int&gt; fa(n + 1);    std::function&lt;int(int)&gt; find = [&amp;](int x) &#123;        return fa[x] == x ? x : fa[x] = find(fa[x]);    &#125;;    auto merge = [&amp;](int x, int y) &#123;        fa[find(x)] = find(y);        return;    &#125;;    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);    for (int x, y; m--; ) &#123;        std::cin &gt;&gt; x &gt;&gt; y;        g[x].push_back(y), g[y].push_back(x);    &#125;    int siz = 1 &lt;&lt; n;    std::vector&lt;int&gt; cnt(siz);    for (int i = 0; i &lt; siz; ++i) &#123;        std::iota(fa.begin(), fa.end(), 0);        std::vector&lt;int&gt; tag(n + 1);        for (int j = 1; j &lt;= n; ++j)            if ((i &gt;&gt; (j - 1)) &amp; 1)                for (auto k : g[j])                    if ((i &gt;&gt; (k - 1)) &amp; 1)                        merge(k, j);        for (int j = 1; j &lt;= n; ++j)            if ((i &gt;&gt; (j - 1)) &amp; 1)                cnt[i] += (fa[j] == j);    &#125;    std::vector&lt;long long&gt; f(siz);    f[0] = 1ll;    for (int i = 1; i &lt; siz; ++i)        for (int j = i; j; j = (j - 1) &amp; i)            if (cnt[j])                (f[i] += ((cnt[j] &amp; 1) ? 1 : mod - 1) * f[i ^ j]) %= mod;    std::cout &lt;&lt; f[siz - 1] &lt;&lt; &#39;\n&#39;;    return 0;&#125;</code></pre></details><hr /><h3 id="e---主旋律">E - 主旋律</h3><p><a href="https://www.luogu.com.cn/problem/P11714" class="uri">https://www.luogu.com.cn/problem/P11714</a></p><p>即，给定一个有向图，问边集有多少个子集是强连通的。</p><p>再次涉及到了连通性问题，但在这里需要结合 SCC 缩点来考虑。容易发现强连通即缩出来是一个点；故需要关注缩出来的点数。</p><p>令 <span class="math inline">\(f(S)\)</span> 表示 <span class="math inline">\(S\)</span> 的导出子图内合法边子集的数量，<span class="math inline">\(g(S)\)</span> 表示 <span class="math inline">\(S\)</span> 的导出子图中非法边子集的数量；<span class="math inline">\(h(S,k)\)</span> 表示 <span class="math inline">\(S\)</span> 的导出子图中边的子集缩出来有 <span class="math inline">\(k\)</span> 个点的数量， 令 <span class="math inline">\(E(S_1, S_2)\)</span> 表示从 <span class="math inline">\(S_1\)</span> 指向 <span class="math inline">\(S_2\)</span> 的边数，则：</p><p><span class="math display">\[f(S) = 2^{E(S,S)}-g(S)\\g(S)=\sum_{T \subseteq S}2^{E(T, S - T)}\cdot 2^{E(T, T)}\cdot \sum_{k=1+[T=\varnothing]} (-1)^{k+1}\cdot h(S - T, k)\\h(S, k) = \sum_{T\subset S} f(T) \cdot h(S - T, k-1)\]</span></p><p>注意为什么要用一个 <span class="math inline">\(h\)</span> 来转移 <span class="math inline">\(g\)</span> 呢？我们发现 <span class="math inline">\(-1\)</span> 的次数和缩出来的点数是有关的，而光凭 <span class="math inline">\(g\)</span> 无法表示点数信息，所以需要用 <span class="math inline">\(h\)</span> 来搭个桥。</p><p>直接 DP，复杂度 <span class="math inline">\(O(n\cdot 3^n)\)</span>。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 计数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>杂题</title>
      <link href="/20250421/"/>
      <url>/20250421/</url>
      
        <content type="html"><![CDATA[<figure><img src="/20250421/neko.png" alt="猫" style="width: 75px"><figcaption>猫</figcaption></figure><span id="more"></span><hr /><h2 id="a---t-shirt">A - T-shirt</h2><p><a href="https://codeforces.com/problemset/problem/183/D" class="uri">https://codeforces.com/problemset/problem/183/D</a></p><p>如果知道一个衣服序列，怎么算出期望呢？</p><hr /><h2 id="b---two-melodies">B - Two Melodies</h2><p><a href="https://codeforces.com/problemset/problem/813/D" class="uri">https://codeforces.com/problemset/problem/813/D</a></p><p>如果设 <span class="math inline">\(f_{i,j}\)</span> 表示第一个以 <span class="math inline">\(i\)</span> 结尾，第二个以 <span class="math inline">\(j\)</span> 结尾的方案数，就会有一个弊端——假设现在有 <span class="math inline">\(i&gt;j\)</span>，又假设有 <span class="math inline">\(j&lt;j&#39;&lt;i\)</span>，那么就不可以直接把 <span class="math inline">\(f_{i,j}\)</span> 转移到 <span class="math inline">\(f_{i,j&#39;}\)</span>，因为 <span class="math inline">\(j&#39;\)</span> 可能已经被第一个选过了。但如果从 <span class="math inline">\(i\)</span> 转移就没有这样的问题（不管 <span class="math inline">\(i&#39;\)</span> 是比 <span class="math inline">\(j\)</span> 大还是比 <span class="math inline">\(j\)</span> 小）。</p><p>那就可以固定从较大的一维转移，也可以枚举所有情况。但是这样就会有一个问题，这是一个 <span class="math inline">\(n^3\)</span> 的过程，而且对于不单调的内层 <span class="math inline">\(j\)</span>，维护它的数值只能用带 <span class="math inline">\(\log\)</span> 的数据结构优化，似乎不太过得了；但 <span class="math inline">\(i\)</span> 却可以前缀优化。</p><p>其实，两个组是无序的，这意味着可以强制 <span class="math inline">\(i&gt;j\)</span> 再从 <span class="math inline">\(i\)</span> 转移；这个时候转移就和 <span class="math inline">\(j\)</span> 没有太大的关系了，可以把 <span class="math inline">\(j\)</span> 放到外层，对 <span class="math inline">\(i\)</span> 前缀优化。可能需要注意边界的处理。</p><details><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;int main() &#123;#ifdef ONLINE_JUDGE    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr), std::cout.tie(nullptr);#else    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);#endif    int n, res = 0;    std::cin &gt;&gt; n;    std::vector&lt;int&gt; a(n + 1);    for (int i = 1; i &lt;= n; ++i)        std::cin &gt;&gt; a[i];    std::vector&lt;std::vector&lt;int&gt; &gt; f(n + 1, std::vector&lt;int&gt; (n + 1));    for (int j = 0; j &lt; n; ++j) &#123;        std::vector&lt;int&gt; mx(100002), mmx(7);        for (int i = 1; i &lt; j; ++i) &#123;            mx[a[i]] = std::max(mx[a[i]], f[j][i]);            mmx[a[i] % 7] = std::max(mmx[a[i] % 7], f[j][i]);        &#125;        for (int i = j + 1; i &lt;= n; ++i) &#123;            f[i][j] = std::max(&#123; !!i + !!j, mx[a[i] - 1] + 1, mx[a[i] + 1] + 1, mmx[a[i] % 7] + 1, f[j][0] + 1 &#125;);            mx[a[i]] = std::max(mx[a[i]], f[i][j]);            mmx[a[i] % 7] = std::max(mmx[a[i] % 7], f[i][j]);            // printf(&quot;f[%d][%d] = %d\n&quot;, i, j, f[i][j]);            res = std::max(res, f[i][j]);        &#125;    &#125;    std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;    return 0;&#125;</code></pre></details><hr /><h2 id="cf633f-the-chocolate-spree">CF633F The Chocolate Spree</h2><p><a href="https://codeforces.com/problemset/problem/633/F" class="uri">https://codeforces.com/problemset/problem/633/F</a></p><p>数性 DP 求直径的时候，有一种方法是找到每个点下面的最大两条不交链。</p><p>这里也可以有类似的求法。假设答案出现在子树 <span class="math inline">\(u\)</span> 中（下面的 <span class="math inline">\(v_i\)</span> 都是 <span class="math inline">\(u\)</span> 的直接儿子），可以讨论 <span class="math inline">\(u\)</span> 参与构成两条路径的情况：</p><ol type="1"><li>不参与构成任何一条路径，答案是 <span class="math inline">\(v_1,v_2\)</span> 子树中的最长路径之和。</li><li><p>参与构成其中一条：</p><ol type="1"><li>这一条与子树 <span class="math inline">\(v\)</span> 完全相离，答案是 <span class="math inline">\(v\)</span> 中最长路径，和 <span class="math inline">\(u\)</span> 下面不经过 <span class="math inline">\(v\)</span> 的最大两条不交链。</li><li>这一条有一支来自 <span class="math inline">\(v\)</span> 子树，但和 <span class="math inline">\(v\)</span> 中最长路径没有重合的点。答案是 <span class="math inline">\(u\)</span> 的点权、<span class="math inline">\(u\)</span> 下面不经过 <span class="math inline">\(v\)</span> 的最大链、<span class="math inline">\(v\)</span> 中一条路径（不经过 <span class="math inline">\(v\)</span>）和 <span class="math inline">\(v\)</span> 下面一条链之和的最大值；</li><li>这一条两支都来自 <span class="math inline">\(v\)</span> 子树：有重合，不可能发生。</li></ol></li><li><p>参与构成其中两条，答案是 <span class="math inline">\(u\)</span> 下面最长的四条链：路径重复经过 <span class="math inline">\(u\)</span>，不可能发生。</p></li></ol><p><img src="2.png" /></p><p>可以记录 <span class="math inline">\(u\)</span> 下方最大的四条不交链、<span class="math inline">\(u\)</span> 中选取一条不经过 <span class="math inline">\(u\)</span> 的路径和 <span class="math inline">\(u\)</span> 下方一条链之和的最大值、<span class="math inline">\(u\)</span> 中最长路径求解。</p><details><pre class="cpp language-cpp" data-line="42-44"><code class="cpp langauage-cpp">#include &lt;bits/stdc++.h>int main() &#123;#ifdef ONLINE_JUDGE    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr), std::cout.tie(nullptr);#else    std::freopen(".in", "r", stdin);    std::freopen(".out", "w", stdout);#endif    int n;    std::cin >> n;    std::vector&lt;int> a(n + 1);    std::vector&lt;std::vector&lt;int> > g(n + 1);    for (int i = 1; i <= n; ++i)        std::cin >> a[i];    for (int i = 1, x, y; i < n; ++i) &#123;        std::cin >> x >> y;        g[x].push_back(y), g[y].push_back(x);    &#125;    auto res(0ll);    std::vector&lt;long long> s(n + 1), w(n + 1);    std::vector&lt;std::vector&lt;std::pair&lt;long long, int> > > f(n + 1, std::vector&lt;std::pair&lt;long long, int> > (4));    std::function&lt;void(int, int)> DFS = [&](int x, int fa) &#123;        f[x][0] = &#123; 0, x &#125;;        w[x] = s[x] = a[x];        for (auto i : g[x])            if (i != fa) &#123;                DFS(i, x);                &#123;                    if (f[i][0].first + a[i] > f[x][3].first)                        f[x][3].first = f[i][0].first + a[i], f[x][3].second = i;                    std::sort(f[x].begin(), f[x].end(), std::greater&lt;std::pair&lt;long long, int> > ());                &#125;                w[x] = std::max(w[x], w[i] + a[x]);            &#125;        auto mx(0ll);        for (auto i : g[x])            if (i != fa) &#123;                s[x] = std::max(&#123; s[x], s[i], f[x][0].first + f[x][1].first + a[x] &#125;);                w[x] = std::max(w[x], (f[x][0].second != i ? f[x][0] : f[x][1]).first + s[i] + a[x]);                res = std::max(&#123; res,                    mx + s[i], // 情况 1                    (f[x][0].second == i ? f[x][1].first + f[x][2].first : (f[x][1].second == i ? f[x][0].first + f[x][2].first : f[x][0].first + f[x][1].first)) + s[i] + a[x], // 情况 2.1                    (f[x][0].second == i ? f[x][1].first : f[x][0].first) + w[i] + a[x], // 情况 2.2                &#125;);                mx = std::max(mx, s[i]);            &#125;    //     printf("%d: res = %lld\n  f: \n", a[x], res);    //     for (int i = 0; i < 4; ++i)    //         printf("    [%d] %lld\n", f[x][i].second, f[x][i].first);    //     printf("  s: %lld\n  w: %lld\n", s[x], w[x]);    &#125;;    DFS(1, -1);    std::cout << res << '\n';    return 0;&#125;</code></pre></details><hr /><h2 id="c---巡逻">C - 巡逻</h2><p><a href="https://www.luogu.com.cn/problem/P3629" class="uri">https://www.luogu.com.cn/problem/P3629</a></p><p>你可能需要注意：目的是遍历所有边而非所有点。</p><p><span class="math inline">\(K=1\)</span> 的时候，环上除了关键边的所有边经过次数会减 <span class="math inline">\(1\)</span>。所以选树的直径就可以最优。</p><p><span class="math inline">\(K=2\)</span> 的时候，答案是 <span class="math inline">\(2\times (m + 2)\)</span> 减去两个边构成的环的 <em>并集减交集</em> 大小 <span class="math inline">\(L\)</span>。环实际上是不存在的，<span class="math inline">\(L\)</span> 其实是两条路径 <em>并集减交集</em> 再加上两条新边的值。</p><p>两条路径有交的时候，可以等效成无交的情况：</p><p><img src="1.png" /></p><p>就划归成上一个问题了。注意此时情况 3 可能发生；同时情况 2.2 可以选取经过 <span class="math inline">\(v\)</span> 的路径。</p><details><pre class="cpp language-cpp" data-line="55-56,64-67"><code class="cpp langauage-cpp">#include &lt;bits/stdc++.h>int main() &#123;#ifdef ONLINE_JUDGE    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr), std::cout.tie(nullptr);#else    std::freopen(".in", "r", stdin);    std::freopen(".out", "w", stdout);#endif    int n, k;    std::cin >> n >> k;    std::vector&lt;std::vector&lt;int> > g(n + 1);    for (int i = 1, x, y; i < n; ++i) &#123;        std::cin >> x >> y;        g[x].push_back(y), g[y].push_back(x);    &#125;    int res = 0;    if (k == 1) &#123;        std::vector&lt;std::vector&lt;std::pair&lt;int, int> > > f(n + 1, std::vector&lt;std::pair&lt;int, int> > (2));        std::function&lt;void(int, int)> DFS = [&](int x, int fa) &#123;            f[x][0] = &#123; 0, x &#125;;            for (auto i : g[x])                if (i != fa) &#123;                    DFS(i, x);                    &#123;                        if (f[i][0].first + 1 > f[x][1].first)                            f[x][1].first = f[i][0].first + 1, f[x][1].second = i;                        std::sort(f[x].begin(), f[x].end(), std::greater&lt;std::pair&lt;int, int> > ());                    &#125;                &#125;            res = std::max(res, f[x][0].first + f[x][1].first);        &#125;;        DFS(1, -1);        std::cout << 2 * n - res - 1 << '\n';    &#125;    else &#123;        std::vector&lt;int> s(n + 1), w(n + 1);        std::vector&lt;std::vector&lt;std::pair&lt;int, int> > > f(n + 1, std::vector&lt;std::pair&lt;int, int> > (4));        std::function&lt;void(int, int)> DFS = [&](int x, int fa) &#123;            f[x][0] = &#123; 0, x &#125;;            for (auto i : g[x])                if (i != fa) &#123;                    DFS(i, x);                    &#123;                        if (f[i][0].first + 1 > f[x][3].first)                            f[x][3].first = f[i][0].first + 1, f[x][3].second = i;                        std::sort(f[x].begin(), f[x].end(), std::greater&lt;std::pair&lt;int, int> > ());                    &#125;                    w[x] = std::max(w[x], w[i] + 1);                &#125;            &#123;                int t = 0;                for (auto [v, id] : f[x])                    t += v;                res = std::max(res, t); // 情况 3                w[x] = std::max(w[x], t - f[x][3].first); // 路径可经过 u            &#125;            int mx = 0;            for (auto i : g[x])                if (i != fa) &#123;                    s[x] = std::max(&#123; s[x], s[i], f[x][0].first + f[x][1].first &#125;);                    w[x] = std::max(w[x], (f[x][0].second != i ? f[x][0] : f[x][1]).first + std::max(s[i], f[i][0].first + 1));                    res = std::max(&#123; res,                        mx + s[i], // 情况 1                        (f[x][0].second == i ? f[x][1].first + f[x][2].first : (f[x][1].second == i ? f[x][0].first + f[x][2].first : f[x][0].first + f[x][1].first)) + s[i], // 情况 2.1                        (f[x][0].second == i ? f[x][1].first : f[x][0].first) + w[i] + 1, // 情况 2.2                    &#125;);                    mx = std::max(mx, s[i]);                &#125;        &#125;;        DFS(1, -1);        std::cout << 2 * (n + 1) - res - 2 << '\n';    &#125;    return 0;&#125;</code></pre></details><hr /><h2 id="d---瞬间传送-teleport">D - 瞬间传送 / Teleport</h2><p><a href="https://www.luogu.com.cn/problem/P11915" class="uri">https://www.luogu.com.cn/problem/P11915</a></p><p>需要观察到一个很厉害的贪心策略：如果钦定所有点的距离不大于 <span class="math inline">\(r\)</span>，且存在 <span class="math inline">\(d(i,j)&gt;r\)</span>。<strong>假设</strong> 一种满足条件的新边是 <span class="math inline">\((u,v)\)</span>（由于两者无序，不妨钦定 <span class="math inline">\(d(i,u)&lt;d(i,v)\)</span>），可以进行讨论：</p><ol type="1"><li><p><span class="math inline">\(d(j,v)&lt;d(j,u)\)</span>：</p>此时最优路径为 <span class="math inline">\(i\to u\to v\to j\)</span>，判断一下这种方案是否不大于 <span class="math inline">\(r\)</span> 就可以了。</li><li><p><span class="math inline">\(d(j,v)\ge d(j, u)\)</span>：</p><p>此时不管是走 <span class="math inline">\(i\to u\to v\to j\)</span> 还是 <span class="math inline">\(i\to v\to u\to j\)</span> 都不如走已经存在的 <span class="math inline">\(i\to u\to j\)</span> 这条路径，也就是说如果要走新边，代价是一定比原距离大，更是比 <span class="math inline">\(r\)</span> 大的；也就是说，<span class="math inline">\((u,v)\)</span> 不能解决 <span class="math inline">\((i,j)\)</span> 之间的问题，假设就不成立了。</p></li></ol><p>综上，只需要判断 <span class="math inline">\(i\to u\to v\to j\le r\)</span> 是否成立，就可以判断 <span class="math inline">\((u,v)\)</span> 是否合法。从大到小枚举 <span class="math inline">\(r\)</span>，同时维护当前依然合法的 <span class="math inline">\((u,v)\)</span>（显然是有单调性的），对于不合法的 <span class="math inline">\((i,j)\)</span>，枚举每个 <span class="math inline">\(i\)</span>，维护 <span class="math inline">\(\max\{d(v,j)\}\)</span>，精细实现（主要是利用各种均摊）一下就能 <span class="math inline">\(O(n^3)\)</span>。</p><p>这里具体提一下需要摊的几个点：</p><ol type="1"><li>枚举到 <span class="math inline">\(r\)</span> 的时候用所有 <span class="math inline">\(d(i,j)=r+1\)</span> 把 <span class="math inline">\(v\)</span> 在 <span class="math inline">\(i\)</span> 处的最大 <span class="math inline">\(d(v,j)\)</span> 更新，方便后面 <span class="math inline">\(O(n)\)</span> 地 check。摊出来是 <span class="math inline">\(O(n^3)\)</span> 的。</li><li>枚举仍然处在合法队列里的 <span class="math inline">\((u,v)\)</span>，如果 check 合法，就说明对于当前 <span class="math inline">\(r\)</span> 至少存在一个合法解，就可以 <code>break</code> 了；否则，把 <span class="math inline">\((u,v)\)</span> 弹出，继续 check 下一条边。这样每条边只会被弹出一次，而未弹出边的 check 次数最多是 <span class="math inline">\(O(n)\)</span>；加上 <span class="math inline">\(O(n)\)</span> 的 check，摊出来是 <span class="math inline">\(O(n^3)\)</span> 的。</li></ol><details><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;const int inf = 0x3f3f3f3f;int main() &#123;#ifdef ONLINE_JUDGE    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr), std::cout.tie(nullptr);#else    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);#endif    int T;    for (std::cin &gt;&gt; T; T--; ) &#123;        int n;        std::cin &gt;&gt; n;        std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1, std::vector&lt;int&gt; (n + 1, inf));        for (int i = 1; i &lt;= n; ++i)            for (int j = 1; j &lt;= n; ++j) &#123;                char t;                std::cin &gt;&gt; t;                if (t == &#39;1&#39; || i == j)                    g[i][j] = t - &#39;0&#39;;            &#125;        for (int k = 1; k &lt;= n; ++k)            for (int i = 1; i &lt;= n; ++i)                if (i != k)                    for (int j = 1; j &lt;= n; ++j)                        if (j != i &amp;&amp; j != k)                            g[i][j] = std::min(g[i][j], g[i][k] + g[k][j]);        std::queue&lt;std::pair&lt;int, int&gt; &gt; q;        std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; p(n + 1);        std::vector&lt;std::vector&lt;int&gt; &gt; mx(n + 1, std::vector&lt;int&gt; (n + 1));        for (int i = 1; i &lt; n; ++i)            for (int j = i + 1; j &lt;= n; ++j) &#123;                q.emplace(i, j);                p[g[i][j] - 1].emplace_back(i, j);            &#125;        auto check = [&amp;](int u, int v, int r) &#123;            for (int i = 1; i &lt;= n; ++i) &#123;                if (g[u][i] &gt; g[v][i])                    std::swap(u, v);                if (g[u][i] + mx[v][i] &gt; r)                    return false;            &#125;            return true;        &#125;;        for (int r = n; r &gt;= -1; --r) &#123;            for (auto [i, j] : p[r])                for (int v = 1; v &lt;= n; ++v) &#123;                    mx[v][i] = std::max(mx[v][i], g[v][j]);                    mx[v][j] = std::max(mx[v][j], g[v][i]);                &#125;            for (; !q.empty(); ) &#123;                auto [u, v] = q.front();                if (!check(u, v, r))                    q.pop();                else                    break;            &#125;            if (q.empty()) &#123;                std::cout &lt;&lt; r + 1 &lt;&lt; &#39;\n&#39;;                break;            &#125;        &#125;    &#125;    return 0;&#125;</code></pre></details><hr /><h2 id="e.-two-tanks">E. Two Tanks</h2><p><a href="https://codeforces.com/problemset/problem/1809/E" class="uri">https://codeforces.com/problemset/problem/1809/E</a></p><p>果然还是不会简单 DP <img src="/em/ll.gif" /></p><p>可以观察到如果总水量相同，且某个时刻两种初始状态当前是相同状态，那么以后它们也会是相同状态。但光凭这个好像还是不太能做出来的样子 <img src="/em/kt.gif" /></p><p>这里大概算一个定式，对于类似这种两个元素总和不变的问题，可以把两个元素的容量画到数轴上，原点表示分界，当前水为一条定长线段，倒水就相当于左右平移这条线段：</p><p><img src="3.png" /></p><p>需要意识到，<mark></mark></p>]]></content>
      
      
      
        <tags>
            
            <tag> DP </tag>
            
            <tag> 贪心 </tag>
            
            <tag> 均摊 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网格图路径计数</title>
      <link href="/20250419/"/>
      <url>/20250419/</url>
      
        <content type="html"><![CDATA[<figure><img src="/20250419/neko.jpeg" alt="猫" style="width: 75px"><figcaption>猫</figcaption></figure><span id="more"></span><hr /><h2 id="点到点的方案数">点到点的方案数</h2><p>从 <span class="math inline">\((x_1,y_1)\)</span> 只能向右、向下走到 <span class="math inline">\((x_2,y_2)\)</span> 的方案数：<span class="math inline">\(C_{x_2-x_1+y_2-y_1}^{x_2-x_1}\)</span>。就是说，因为必须向下走 <span class="math inline">\(x_2-x_1\)</span> 步，又必须向右走 <span class="math inline">\(y_2-y_1\)</span> 步；但顺序是可以任意打乱的。</p><hr /><h3 id="a---gerald-and-giant-chess">A - Gerald and Giant Chess</h3><p><a href="https://codeforces.com/problemset/problem/560/E" class="uri">https://codeforces.com/problemset/problem/560/E</a></p><p>把不能走的点按 <span class="math inline">\(x\)</span> 为第一关键字，<span class="math inline">\(y\)</span> 为第二关键字排序，就可以得到它们按大致拓扑序排列的结果。</p><p>令 <span class="math inline">\(f_i\)</span> 表示不经过 <span class="math inline">\(1\sim i-1\)</span> 的非法点走到第 <span class="math inline">\(i\)</span> 个非法点的方案数，就可以得到 <span class="math inline">\(f_i=C_{x_i+y_i,x_i}-\sum_{j=1}^{i-1} f_j\times C_{x_i-x_j+y_i-y_j}^{x_i-x_j}\)</span>。可以发现后面减去的方案，因为碰到的第一个非法点不同，所以是两两不同的。</p><p>让 <span class="math inline">\((h,w)\)</span> 成为第 <span class="math inline">\((n+1)\)</span> 个非法点，<span class="math inline">\(f_{n+1}\)</span> 就是答案。</p><details><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;const int mod = 1e9 + 7;int main() &#123;#ifdef ONLINE_JUDGE    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr), std::cout.tie(nullptr);#else    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);#endif    int h, w, n;    std::cin &gt;&gt; h &gt;&gt; w &gt;&gt; n, --h, --w;    std::vector&lt;std::pair&lt;int, int&gt; &gt; a(n + 2);    for (int i = 1; i &lt;= n; ++i) &#123;        std::cin &gt;&gt; a[i].first &gt;&gt; a[i].second;        --a[i].first, --a[i].second;    &#125;    a[n + 1] = &#123; h, w &#125;;    std::sort(a.begin() + 1, a.end());    std::vector&lt;long long&gt; fac(h + w + 1), inv(h + w + 1);    fac[0] = inv[0] = 1ll;    for (int i = 1; i &lt;= h + w; ++i)        fac[i] = fac[i - 1] * i % mod;    auto qkp = [](long long x, int y) &#123;        auto res = 1ll;        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)            if (y &amp; 1)                (res *= x) %= mod;        return res;    &#125;;    inv[h + w] = qkp(fac[h + w], mod - 2);    for (int i = h + w - 1; i; --i)        inv[i] = inv[i + 1] * (i + 1) % mod;    auto C = [&amp;](int n, int m) &#123;        return fac[n] * inv[n - m] % mod * inv[m] % mod;    &#125;;    std::vector&lt;long long&gt; f(n + 2);    for (int i = 1; i &lt;= n + 1; ++i) &#123;        f[i] = C(a[i].first + a[i].second, a[i].first);        for (int j = 1; j &lt; i; ++j)            if (a[j].second &lt;= a[i].second)                (f[i] += mod - f[j] * C(a[i].first - a[j].first + a[i].second - a[j].second, a[i].first - a[j].first) % mod) %= mod;        // printf(&quot;f[(%d, %d)] = %lld\n&quot;, a[i].first, a[i].second, f[i]);    &#125;    std::cout &lt;&lt; f[n + 1] &lt;&lt; &#39;\n&#39;;    return 0;&#125;</code></pre></details><hr /><h3 id="b---bbq-hard">B - BBQ Hard</h3><p><a href="https://atcoder.jp/contests/agc001/tasks/agc001_e" class="uri">https://atcoder.jp/contests/agc001/tasks/agc001_e</a></p><p>不仅仅可以在关键点上 DP，也可以在网格上直接 DP。</p><p><span class="math inline">\(A_i+B_i+A_j+B_j\)</span> 就是 <span class="math inline">\(A_i+B_i-(-A_j)-(-B_j)\)</span>。把棋盘扩大到 <span class="math inline">\(-2000\to 2000\)</span> 就可以了。</p><p>设 <span class="math inline">\(f_{i,j}\)</span> 表示可以到达 <span class="math inline">\((i,j)\)</span> 的所有发出关键点 <span class="math inline">\((-A_j,-B_j)\)</span> 带来的贡献，那么 <span class="math inline">\(f_{i,j}=f_{i-1,j}+f_{i,j-1}\)</span>。枚举所有接收关键点 <span class="math inline">\((A_i,B_i)\)</span>，<span class="math inline">\(\sum f_{A_i,B_i}\)</span> 就是答案的两倍，再减去对角线，也就是 <span class="math inline">\(\sum (-A_i,B_i)\to (A_i,B_i)\)</span> 后的值。</p><details><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;const int N = 2000;const int mod = 1e9 + 7;const int inv2 = 500000004;int main() &#123;#ifdef ONLINE_JUDGE    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr), std::cout.tie(nullptr);#else    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);#endif    int n;    std::cin &gt;&gt; n;    std::vector&lt;long long&gt; fac(4 * N + 1), inv(4 * N + 1);    fac[0] = inv[0] = 1ll;    for (int i = 1; i &lt;= 4 * N; ++i)        fac[i] = fac[i - 1] * i % mod;    auto qkp = [](long long x, int y) &#123;        auto res(1ll);        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)            if (y &amp; 1)                (res *= x) %= mod;        return res;    &#125;;    inv[4 * N] = qkp(fac[4 * N], mod - 2);    for (int i = 4 * N - 1; i; --i)        inv[i] = inv[i + 1] * (i + 1) % mod;    std::vector&lt;std::pair&lt;int, int&gt; &gt; a(n + 1);    std::vector&lt;std::vector&lt;long long&gt; &gt; f(2 * N + 1, std::vector&lt;long long&gt; (2 * N + 1));    for (int i = 1; i &lt;= n; ++i) &#123;        std::cin &gt;&gt; a[i].first &gt;&gt; a[i].second;        ++f[N - a[i].first][N - a[i].second];    &#125;    for (int i = 0; i &lt;= 2 * N; ++i)        for (int j = 0; j &lt;= 2 * N; ++j) &#123;            if (i &gt;= 1)                (f[i][j] += f[i - 1][j]) %= mod;            if (j &gt;= 1)                (f[i][j] += f[i][j - 1]) %= mod;            // printf(&quot;f(%2d, %2d) = %lld\n&quot;, i - N, j - N, f[i][j]);        &#125;    long long res = 0ll;    auto C = [&amp;](int n, int m) &#123;        return fac[n] * inv[n - m] % mod * inv[m] % mod;    &#125;;    for (int i = 1; i &lt;= n; ++i) &#123;        (res += f[a[i].first + N][a[i].second + N]) %= mod;        (res += mod - C(a[i].first * 2 + a[i].second * 2, 2 * a[i].first)) %= mod;    &#125;    std::cout &lt;&lt; res * inv2 % mod &lt;&lt; &#39;\n&#39;;    return 0;&#125;</code></pre></details><hr /><h3 id="c---iroha-and-a-grid">C - Iroha and a Grid</h3><p><a href="https://atcoder.jp/contests/arc058/tasks/arc058_b" class="uri">https://atcoder.jp/contests/arc058/tasks/arc058_b</a></p><p>先把绿色部分的答案计算出来：</p><figure><img src="1.png" alt="网格" /><figcaption>网格</figcaption></figure><p>如果把绿色的每一个格子到终点的方案数求和，就会算重，因为上面的绿色点可以走到下面的绿色点。</p><p>让绿色点第一步只能往右走到黄色点，用这样的方案为黄色点赋初值，再让黄色点自由走就可以得到答案了。</p><details><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;const int mod = 1e9 + 7;int main() &#123;#ifdef ONLINE_JUDGE    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr), std::cout.tie(nullptr);#else    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);#endif    int h, w, a, b;    std::cin &gt;&gt; h &gt;&gt; w &gt;&gt; a &gt;&gt; b;    std::vector&lt;long long&gt; fac(h + w + 1), inv(h + w + 1);    fac[0] = inv[0] = 1ll;    for (int i = 1; i &lt;= h + w; ++i)        fac[i] = fac[i - 1] * i % mod;    auto qkp = [](long long x, int y) &#123;        auto res(1ll);        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)            if (y &amp; 1)                (res *= x) %= mod;        return res;    &#125;;    inv[h + w] = qkp(fac[h + w], mod - 2);    for (int i = h + w - 1; i; --i)        inv[i] = inv[i + 1] * (i + 1) % mod;    auto C = [&amp;](int n, int m) &#123;        return fac[n] * inv[n - m] % mod * inv[m] % mod;    &#125;;    auto res = 0ll;    for (int i = 1; i &lt;= h - a; ++i) &#123;        // (i, B)        auto f(C(i + b - 2, i - 1));        // printf(&quot;(%d, %d): %lld\n&quot;, i, b, f);        // (i, B + 1)        (res += f * C(h - i + w - (b + 1), h - i) % mod) %= mod;    &#125;    std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;    return 0;&#125;</code></pre></details><hr /><h2 id="点到矩形的方案数">点到矩形的方案数</h2><p>从 <span class="math inline">\((x_0,y_0)\)</span> 走到矩形 <span class="math inline">\((x_1,y_1,x_2,y_2)\)</span> 的方案数：</p><p><span class="math display">\[\sum\limits_{i\in [x_1,x_2],j\in [y_1,y_2]} G(x_0,y_0, i, j) = G(x_0,y_0,x_2 + 1,y_2 + 1)-G(x_0,y_0,x_2+1,y_1)-G(x_0,y_0,x_1,y_2+1)+G(x_0,y_0,x_1,y_1)\]</span></p><p>证明：<span class="math inline">\(G(x_0,y_0,x_2+1,y_2+1)=\sum\limits_i G(x_0,y_0,i,y_2)=\sum\limits_{i,j} G(x_0,y_0,i,j)\)</span>，类似的，把后面几项展开，可以得到前缀和的结构。</p><p>现在，矩形就可以被概括成 4 个点了。</p><hr /><h2 id="矩形到矩形的方案数">矩形到矩形的方案数</h2><p>枚举第一个矩形里的所有点，那么就可以得到关于第二个矩形里四个点的表达式。反过来把第一个矩形概括为 4 个点就可以快速求解了。</p><p>具体一点，第一个矩形 <span class="math inline">\((x_1,y_1,x_2,y_2)\)</span> 可以被概括为 <span class="math inline">\((x_1-1,y_1-1)\)</span>，<span class="math inline">\((x_1-1,y_2)\)</span>，<span class="math inline">\((x_2,y_1-1)\)</span>，<span class="math inline">\((x_2,y_2)\)</span>。注意方向颠倒导致符号发生变化。此时对 <span class="math inline">\(4\times 4=16\)</span> 个 <span class="math inline">\(G\)</span> 按对应的 <span class="math inline">\(-1/1\)</span> 系数求和就能得到答案。</p><hr /><h3 id="d---sightseeing-plan">D - Sightseeing Plan</h3><p><a href="https://atcoder.jp/contests/agc018/tasks/agc018_e" class="uri">https://atcoder.jp/contests/agc018/tasks/agc018_e</a></p><ol type="1"><li>恒等式：<span class="math inline">\(\sum\limits_{i\in [x_1,x_2]}G_(x_1,y_1,i,y_2-1)=G(x_1,y_1,x_2,y_2)\)</span>，放在网格图上就是强制走到 <span class="math inline">\((i,y_2-1)\)</span>，再强制向右走一步，然后向上走到 <span class="math inline">\((x_2,y_2)\)</span>。和上一题类似的，可以发现不重不漏。</li><li>三个矩形，<span class="math inline">\(M_1\)</span> 经过 <span class="math inline">\(M_2\)</span> 到达 <span class="math inline">\(M_3\)</span> 的路径数量：经过 <span class="math inline">\(M_2\)</span> 时，根据限制，只可能从下面或左边进入。枚举进入的点 <span class="math inline">\((x_0,y_0)\)</span>（数量为 <span class="math inline">\(O(n)\)</span>），再计算 <span class="math inline">\(G(x_0,y_0,M_3)\)</span> 就能得到不重不漏的答案。</li><li>原问题：要求 <span class="math inline">\(M_2\)</span> 内部路径上点的贡献和，这个其实就是 <span class="math inline">\(M_2\)</span> 内部路径长度。若从 <span class="math inline">\((x_1,y_1)\)</span> 进入，再从 <span class="math inline">\((x_2,y_2)\)</span> 离开，长度就是 <span class="math inline">\(x_2-x_1+y_2-y_1+1\)</span>。拆成 <span class="math inline">\((x_2+y_2+1)\)</span> 和 <span class="math inline">\(-(x_1+y_1)\)</span> 后发现一次进入和一次离开的贡献是独立的。分别枚举进入点和离开点计算贡献就可以了。</li></ol><details><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;const int N = 2e6;const int mod = 1e9 + 7;int main() &#123;#ifdef ONLINE_JUDGE    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr), std::cout.tie(nullptr);#else    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);#endif    int x1, x2, x3, x4, x5, x6, y1, y2, y3, y4, y5, y6;    std::cin &gt;&gt; x1 &gt;&gt; x2 &gt;&gt; x3 &gt;&gt; x4 &gt;&gt; x5 &gt;&gt; x6;    std::cin &gt;&gt; y1 &gt;&gt; y2 &gt;&gt; y3 &gt;&gt; y4 &gt;&gt; y5 &gt;&gt; y6;    std::vector&lt;long long&gt; fac(N + 1), inv(N + 1);    fac[0] = inv[0] = 1ll;    for (int i = 1; i &lt;= N; ++i)        fac[i] = fac[i - 1] * i % mod;    auto qkp = [](long long x, int y) &#123;        auto res(1ll);        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)            if (y &amp; 1)                (res *= x) %= mod;        return res;    &#125;;    inv[N] = qkp(fac[N], mod - 2);    for (int i = N - 1; i; --i)        inv[i] = inv[i + 1] * (i + 1) % mod;    auto C = [&amp;](int n, int m) &#123;        return fac[n] * inv[n - m] % mod * inv[m] % mod;    &#125;;    std::vector&lt;std::tuple&lt;int, int, int&gt; &gt; f(4), g(4);    f[0] = &#123; x1 - 1, y1 - 1, 1 &#125;, f[1] = &#123; x1 - 1, y2, mod - 1 &#125;, f[2] = &#123; x2, y1 - 1, mod - 1 &#125;, f[3] = &#123; x2, y2, 1 &#125;;    g[0] = &#123; x5, y5, 1 &#125;, g[1] = &#123; x5, y6 + 1, mod - 1 &#125;, g[2] = &#123; x6 + 1, y5, mod - 1 &#125;, g[3] = &#123; x6 + 1, y6 + 1, 1 &#125;;     auto G = [&amp;](int x1, int y1, int x2, int y2) &#123;        auto a(std::abs(x1 - x2)), b(std::abs(y1 - y2));        return C(a + b, a);    &#125;;    auto res = 0ll;    for (auto [x1, y1, k1] : f)        for (auto [x2, y2, k2] : g) &#123;            auto t(0ll);            for (int x = x3; x &lt;= x4; ++x) &#123;                (t += G(x1, y1, x, y4) * G(x, y4 + 1, x2, y2) % mod * (x + y4 + 1) % mod) %= mod;                (t += mod - G(x1, y1, x, y3 - 1) * G(x, y3, x2, y2) % mod * (x + y3) % mod) %= mod;            &#125;            for (int y = y3; y &lt;= y4; ++y) &#123;                (t += G(x1, y1, x4, y) * G(x4 + 1, y, x2, y2) % mod * (x4 + y + 1) % mod) %= mod;                (t += mod - G(x1, y1, x3 - 1, y) * G(x3, y, x2, y2) % mod * (x3 + y) % mod) %= mod;            &#125;            // printf(&quot;(%d, %d, %d), (%d, %d, %d): %lld\n&quot;, x1, y1, k1, x2, y2, k2, t * k1 % mod * k2 % mod);            (res += t * k1 % mod * k2 % mod) %= mod;        &#125;    std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;    return 0;&#125;</code></pre></details><hr /><h2 id="不经过-yxc-的方案数">不经过 <span class="math inline">\(y=x+c\)</span> 的方案数</h2><p>Catalan 数的一种推导方式是，在 <span class="math inline">\(n\times n\)</span> 的网格上，要求不能越过 <span class="math inline">\(y=x\)</span> 的方案数。可以用总方案数减去越过的方案数。</p><p>怎么计算非法的方案呢？越过 <span class="math inline">\(y=x\)</span> 的路径必定存在一个点经过 <span class="math inline">\(y=x+1\)</span>，原问题转化为不能碰到 <span class="math inline">\(y=x+1\)</span> 的方案数。</p><p>把终点 <span class="math inline">\((n, n)\)</span> 翻折到 <span class="math inline">\(y=x+1\)</span> 上方，得到 <span class="math inline">\((n-1, n + 1)\)</span>；对于任意到达 <span class="math inline">\((n-1,n+1)\)</span> 的路径，一定会接触 <span class="math inline">\(y=x+1\)</span> 至少一次；将第一次接触以后的路径翻折到 <span class="math inline">\(y=x+1\)</span> 下方，则一定和原图中的非法路径一一对应。</p><p><img src="4.png" /></p><p>就可以得到 <span class="math inline">\(C_{2n}^n-C_{2n}^{n-1}\)</span>。</p><p>如果问题变得更加一般，求解到达 <span class="math inline">\((n, m)\)</span> 不能碰到 <span class="math inline">\(y=x+c\)</span> 的方案数，还是可以把 <span class="math inline">\((n,m)\)</span> 翻折到 <span class="math inline">\((m-c,n+c)\)</span>，答案是 <span class="math inline">\(C_{n+m}^n-C_{n+m}^{m-c}\)</span>。</p><hr /><h2 id="不经过-yx-l-和-yxr-的方案数">不经过 <span class="math inline">\(y=x-l\)</span> 和 <span class="math inline">\(y=x+r\)</span> 的方案数</h2><p>现在有 <span class="math inline">\(y=x-l\)</span> 和 <span class="math inline">\(y=x+r\)</span> 两条线作为限制，现在的翻折意义就会有一点改变。</p><p><img src="5.png" /></p><p>比如图中的 <span class="math inline">\(A&#39;\)</span>，是 <span class="math inline">\(A\)</span> 沿着 <span class="math inline">\(y=x-l\)</span> 翻折一次后的结果。还是按照之前的方式来理解，那么走到 <span class="math inline">\(A&#39;\)</span> 的路径代表至少经过一次 <span class="math inline">\(y=x-l\)</span> 的方案。<span class="math inline">\(A&#39;&#39;\)</span> 是 <span class="math inline">\(A&#39;\)</span> 沿着 <span class="math inline">\(y=x+r\)</span> 翻折一次之后得到的结果，走到 <span class="math inline">\(A&#39;&#39;\)</span> 的路径就代表至少先碰到一次 <span class="math inline">\(y=x-l\)</span>，再碰到一次 <span class="math inline">\(y=x+r\)</span> 的方案数。</p><p>如果把相邻多次碰到 <span class="math inline">\(y=x-l\)</span> 或 <span class="math inline">\(y=x+r\)</span> 合并为一次，最终的非法路径就是 <code>LRLRLR...</code> 或者 <code>RLRLRL...</code> 的形式。因为可以计算的是「至少」的形式，用容斥原理得到，答案是 <span class="math inline">\(f_{\varnothing}-(f_{\texttt L} + f_{\texttt R}) + (f_{\texttt {LR}} + f_{\texttt {RL}}) - \cdots\)</span>。对应计算每个翻折对应终点和答案就可以了。最后的答案是 <span class="math inline">\(C_{n+m}^n-C_{n+m}^{n+l}-C_{n+m}^{n + r}+C_{n+m}^{n+l-r}+C_{n+m}^{n+r-l}-\cdots\)</span>，可以简化成 <span class="math inline">\(\sum\limits_{k\in \mathbb{Z}} C_{n+m}^{n-k\cdot (r-l)}-C_{n+m}^{n-k\cdot (r-l)+r}\)</span>。</p><hr /><h3 id="e---骗我呢">E - 骗我呢</h3><p><a href="https://www.luogu.com.cn/problem/P3266" class="uri">https://www.luogu.com.cn/problem/P3266</a></p><p>每行内部递增，而且选项只有 <span class="math inline">\([0,m]\)</span>，那么每行就会刚好在 <span class="math inline">\([0,m]\)</span> 里面跳过一个数。</p><p>如果第 <span class="math inline">\(i\)</span> 行跳过的数是 <span class="math inline">\(j\)</span>，那么画一画图就可以发现第 <span class="math inline">\(i+1\)</span> 可能跳过的数是 <span class="math inline">\([j-1,m]\)</span>；反过来，第 <span class="math inline">\(i-1\)</span> 行可能跳过的数就是 <span class="math inline">\([0,j+1]\)</span>。</p><p>如果让 <span class="math inline">\(f_{i,j}\)</span> 表示确定了第 <span class="math inline">\(1\to i\)</span> 行，其中第 <span class="math inline">\(i\)</span> 行跳过 <span class="math inline">\(j\)</span> 的方案数，就可以得到 <span class="math inline">\(f_{i,j}=\sum\limits_{k=0}^{j+1} f_{i-1,k}\)</span>。前缀和得到 <span class="math inline">\(f_{i,j}=f_{i,j-1}+f_{i-1,j+1}\)</span>。注意边界：<span class="math inline">\(f_{0,j}=1\)</span>；<span class="math inline">\(f_{i,0}=f_{i-1,0}+f_{i-1,1}\)</span>；<span class="math inline">\(f_{i,m}=f_{i,m-1}\)</span>。</p><p>为了得到答案，让 <span class="math inline">\(g_{i,j}\)</span> 表示 <span class="math inline">\(i\times j\)</span> 矩阵的方案数（这样就有机会通过手段优化了）：</p><p><span class="math display">\[\begin{aligned}g_{i,j}&amp;=\sum_{k=0}^j f_{i,k}\\&amp;= f_{i-1,0}+f_{i-1,1}+\sum_{k=1}^j f_{i,k-1}+f_{i-1,k+1}\\&amp;= g_{i,j-1}+g_{i-1,j+1}\end{aligned}\]</span></p><p>边界情况呢， <span class="math inline">\(g_{i, 0} = f_{i,0} = f_{i-1, 0} + f_{i - 1, 1} = g_{i-1,1}\)</span>；<span class="math inline">\(g_{i,m}=g_{i, m - 1} + f_{i,m}=g_{i-1,m}+g_{i,m-1}\)</span>。 <span class="math inline">\(g_{i,m+1}=g_{i,m}\)</span> 避免边界。</p><p>那么在网格图上转移如下：</p><p><img src="2.png" /></p><p>考虑将这个图形拉正，令 <span class="math inline">\((i+i,j)\gets g_{i,j}\)</span> 得到：</p><p><img src="3.png" /></p><p>问题就转化为，从 <span class="math inline">\((0, 0)\)</span> 走到 <span class="math inline">\((m+n+1,n)\)</span> 且不能触碰 <span class="math inline">\(y=x+1\)</span> 和 <span class="math inline">\(y=x-m-2\)</span> 两条直线的方案数。</p><details></details><hr /><h2 id="不经过一般过原点直线的方案数">不经过一般过原点直线的方案数</h2><ol type="1"><li><p>类型一：<span class="math inline">\((0,0)\to (n,m)\)</span>，不经过 <span class="math inline">\(y=\dfrac mnx\)</span> 的方案，其中要求 <span class="math inline">\((m,n)=1\)</span>。</p><p>方案为 <span class="math inline">\(\dfrac {C_{n+m}^n}{n+m}\)</span>。</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 容斥原理 </tag>
            
            <tag> 数学 </tag>
            
            <tag> 排列组合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>组合计数</title>
      <link href="/20250407/"/>
      <url>/20250407/</url>
      
        <content type="html"><![CDATA[<p>毅毅：统计不是数学（断章取义 ed）。<del>故删掉了数学标签。</del> 其实并没有。</p><span id="more"></span><hr /><h2 id="a.-二分图染色">A. 二分图染色</h2><p><a href="http://222.180.160.110:61235/contest/6181/problem/1" class="uri">http://222.180.160.110:61235/contest/6181/problem/1</a></p><p>首先只看红色。显然一个左部点最多只能用红边连接一个右部点，反之同理。把左部点视为下标，其用红边相连的右部点视为值，则一个合法的方案为 <span class="math inline">\(n\)</span> 的只保留一部分元素的排列。显然为 <span class="math inline">\(f(n)=\sum\limits_{i=0}^nC_n^i\cdot A_n^i\)</span>。</p><p>再加上蓝色，<span class="math inline">\(f^2(n)\)</span> 会给一条边涂两种颜色，故钦定有两种颜色的边数，容斥得到 <span class="math inline">\(\sum\limits_{i=0}^n(-1)^i\cdot C_n^i\cdot A_n^i\cdot f^2(n-i)\)</span>。发现 <span class="math inline">\(f\)</span> 的计算可能需要优化一下。考虑已经知道 <span class="math inline">\(f(n-1)\)</span>，此时对于新增的第 <span class="math inline">\(n\)</span> 对点：</p><ol type="1"><li>任意连边（显然两个当中只能有一个点发出边），共有 <span class="math inline">\(2n-1\)</span> 种方案，因为 <span class="math inline">\((n, n)\)</span> 会被算重。</li><li>不连，共 <span class="math inline">\(1\)</span> 种方案。</li><li>发现 1 中可能连到已经有连边的点上了，新边的目的地有 <span class="math inline">\(n-1\)</span> 个选项，目的地原本连接的点也有 <span class="math inline">\(n-1\)</span> 个选项，去掉两边共 <span class="math inline">\(4\)</span> 个点，非法的即为 <span class="math inline">\((n-1)^2\cdot f(n-2)\)</span>。</li></ol><details><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;const int mod = 1e9 + 7;int main() &#123;#ifdef ONLINE_JUDGE    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr), std::cout.tie(nullptr);#else    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);#endif    int n;    std::cin &gt;&gt; n;    std::vector&lt;long long&gt; f(n + 1), fac(n + 1), inv(n + 1);    f[0] = 1ll, f[1] = 2ll;    fac[0] = 1ll, fac[1] = 1ll, inv[0] = 1ll;    for (int i = 2; i &lt;= n; ++i) &#123;        fac[i] = fac[i - 1] * i % mod;        f[i] = (f[i - 1] * 2 * i % mod + mod - f[i - 2] * (i - 1) % mod * (i - 1) % mod) % mod;    &#125;    auto qkp = [](long long x, int y) &#123;        auto res = 1ll;        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)            if (y &amp; 1)                (res *= x) %= mod;        return res;    &#125;;    inv[n] = qkp(fac[n], mod - 2);    for (int i = n - 1; i; --i)        inv[i] = inv[i + 1] * (i + 1) % mod;    auto C = [&amp;](int n, int m) &#123;        return fac[n] * inv[n - m] % mod * inv[m] % mod;    &#125;;    auto A = [&amp;](int n, int m) &#123;        return fac[n] * inv[n - m] % mod;    &#125;;    long long res = 0ll;    for (int i = 0, k = 1; i &lt;= n; ++i, k = mod - k)        (res += k * C(n, i) % mod * A(n, i) % mod * f[n - i] % mod * f[n - i]) %= mod;    std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;    return 0;&#125;</code></pre></details><hr /><h2 id="b.-七选五">B. 七选五</h2><p><a href="http://222.180.160.110:61235/contest/6181/problem/2" class="uri">http://222.180.160.110:61235/contest/6181/problem/2</a></p><p>首先 <span class="math inline">\(p\)</span> 固定，钦定有 <span class="math inline">\(x\)</span> 个数相等，有 <span class="math inline">\(C_k^x\)</span> 个方案，剩下的就是从 <span class="math inline">\(n-x\)</span> 个元素里选出 <span class="math inline">\(k-x\)</span> 个来错排，考虑钦定相同的个数来容斥：</p><p><span class="math display">\[\sum_{i=0}^{k-x}(-1)^i\cdot C_{k-x}^i\cdot A_{n-x-i}^{k-x-i}\]</span></p><details><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;const int mod = 1e9 + 7;int main() &#123;#ifdef ONLINE_JUDGE    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr), std::cout.tie(nullptr);#else    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);#endif    int n, k, x;    std::cin &gt;&gt; n &gt;&gt; k &gt;&gt; x;    std::vector&lt;long long&gt; fac(n + 1), inv(n + 1);    fac[0] = 1ll, fac[1] = 1ll, inv[0] = 1ll;    for (int i = 2; i &lt;= n; ++i)        fac[i] = fac[i - 1] * i % mod;    auto qkp = [](long long x, int y) &#123;        auto res = 1ll;        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)            if (y &amp; 1)                (res *= x) %= mod;        return res;    &#125;;    inv[n] = qkp(fac[n], mod - 2);    for (int i = n - 1; i; --i)        inv[i] = inv[i + 1] * (i + 1) % mod;    auto C = [&amp;](int n, int m) &#123;        return fac[n] * inv[n - m] % mod * inv[m] % mod;    &#125;;    auto A = [&amp;](int n, int m) &#123;        return fac[n] * inv[n - m] % mod;    &#125;;    long long res = C(k, x), sum = 0ll;    for (int i = 0, p = 1; i &lt;= k - x; ++i, p = mod - p)        (sum += p * C(k - x, i) % mod * A(n - x - i, k - x - i) % mod) %= mod;    std::cout &lt;&lt; res * sum % mod &lt;&lt; &#39;\n&#39;;    return 0;&#125;</code></pre></details><hr /><h2 id="d.-硬币购物">D. 硬币购物</h2><p><a href="http://222.180.160.110:61235/contest/6181/problem/4" class="uri">http://222.180.160.110:61235/contest/6181/problem/4</a></p><p>每次多重背包会超时，考虑用钦定每种硬币是否超额来容斥。令 <span class="math inline">\(f_s\)</span> 表示凑出 <span class="math inline">\(s\)</span> 的方案数（完全背包），那么 <span class="math inline">\(f_{s-c_1\times (d_1 + 1)}\)</span> 就表示钦定第 1 种硬币超额时凑出 <span class="math inline">\(s\)</span> 的方案数，以此类推。</p><details><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;int main() &#123;#ifdef ONLINE_JUDGE    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr), std::cout.tie(nullptr);#else    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);#endif    int c[4], T, m = 1e5;    std::vector&lt;long long&gt; f(m + 1);    f[0] = 1;    for (int i = 0; i &lt; 4; ++i) &#123;        std::cin &gt;&gt; c[i];        for (int j = c[i]; j &lt;= m; ++j)            f[j] += f[j - c[i]];    &#125;    std::cin &gt;&gt; T;    for (int d[4], m; T--; ) &#123;        for (int i = 0; i &lt; 4; ++i)            std::cin &gt;&gt; d[i];        std::cin &gt;&gt; m;        long long res = 0ll;        for (int i = 0; i &lt; (1 &lt;&lt; 4); ++i) &#123;            int s = m;            for (int j = 0; j &lt; 4; ++j)                if ((i &gt;&gt; j) &amp; 1)                    s -= (d[j] + 1) * c[j];            if (s &gt;= 0) &#123;                int k = (__builtin_popcount(i) &amp; 1) ? -1 : 1;                res += k * f[s];            &#125;        &#125;        std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;    &#125;    return 0;&#125;</code></pre></details><hr /><h2 id="e.-distinct-multiples">E. Distinct Multiples</h2><p><a href="http://222.180.160.110:61235/contest/6181/problem/5" class="uri">http://222.180.160.110:61235/contest/6181/problem/5</a></p><p>推式子题。题意转化为，给定 <span class="math inline">\(n\)</span> 个位置可选的值集合，要求任意两个位置值不等，问方案数。</p><p>如果把两个位置取等视作在团上选中边，那么有朴素做法钦定选边的集合 <span class="math inline">\(S\)</span> 然后容斥，考虑它们构成的连通块 <span class="math inline">\(\{s\} \subseteq S\)</span>，有 <span class="math inline">\(res=\sum\limits_{S\subseteq V}(-1)^{|S|}\cdot \prod\limits_{s_i} \left\lfloor \frac m{\operatorname{lcm} s_i} \right\rfloor\)</span>。</p><p>有个很神奇的操作是把 <span class="math inline">\(S\)</span> 丢掉，直接枚举 <span class="math inline">\(\{s\}\)</span> 尝试子集 DP。有：<span class="math inline">\(res=\sum\limits_{\{s\}}\prod\limits_s f(s)\cdot\left\lfloor \frac m{\operatorname{lcm} s} \right\rfloor\)</span>。其中 <span class="math inline">\(f(s)\)</span> 表示选取一个 <span class="math inline">\(s\)</span> 的导出子图的容斥系数之和，其中次数为导出子图中边数。</p><p>怎么把 <span class="math inline">\(f\)</span> 算出来呢？容易发现其值只与 <span class="math inline">\(|s|\)</span> 有关，考虑钦定与 <span class="math inline">\(1\)</span> 连通的点数容斥，则有：</p><p><span class="math display">\[f(n)=\sum\limits_{i=0}^{n - 1} (-1)^i \times C_{n-1}^{i-1} \times f(i) \cdot \sum_{j=0}^{m\gets i\times (i-1)\div 2} (-1)^j\cdot C_m^j\]</span></p><p>我们知道，二项式定理取 <span class="math inline">\(a=1, b = -1\)</span> 有 <span class="math inline">\(0^m=[m=0]=\sum_{j=0}^m(-1)^j\cdot C_m^j\)</span>，代入得：</p><p><span class="math display">\[\begin{aligned}f(n)&amp;=\sum\limits_{i=0}^{n - 1} (-1)^i \times C_{n-1}^{n-i-1} \times f(n-i)\cdot [m=0\iff i=1]\\&amp;=(1 - n)\cdot f(n-1)\end{aligned}\]</span></p><p>然后就能线性求出。再用一个子集 DP，为了保证顺序枚举最小的未被确定的点所在连通块进行转移。</p><details><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;const int mod = 998244353;int main() &#123;#ifdef ONLINE_JUDGE    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr), std::cout.tie(nullptr);#else    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);#endif    int n, l;    long long m;    std::cin &gt;&gt; n &gt;&gt; m, l = 1 &lt;&lt; n;    std::vector&lt;long long&gt; d(n), f(n + 1), dp(l), g(l);    f[1] = 1ll;    for (int i = 1; i &lt;= n; ++i) &#123;        std::cin &gt;&gt; d[i - 1];        if (i &gt;= 2)            f[i] = (1 + mod - i) * f[i - 1] % mod;        // printf(&quot;f[%d] = %lld\n&quot;, i, f[i]);    &#125;    for (int i = 0; i &lt; l; ++i) &#123;        long long now = 1ll;        for (int j = 0; j &lt; n; ++j)            if ((i &gt;&gt; j) &amp; 1) &#123;                if (now / std::__gcd(now, d[j]) &gt; m / d[j])                    goto nosol;                now = now / std::__gcd(now, d[j]) * d[j];            &#125;        g[i] = (m / now) % mod;        // printf(&quot;lcm = %lld, g[%d] = %lld\n&quot;, now, i, g[i]);    nosol: ;    &#125;    dp[0] = 1ll;    auto lowbit = [](int x) &#123;        return x &amp; -x;    &#125;;    for (int i = 1; i &lt; l; ++i) &#123;        int to = std::__lg(lowbit(i));        for (int j = i; j; j = (j - 1) &amp; i)            if ((j &gt;&gt; to) &amp; 1)                (dp[i] += dp[i ^ j] * f[__builtin_popcount(j)] % mod * g[j] % mod) %= mod;    &#125;    std::cout &lt;&lt; dp[l - 1] &lt;&lt; &#39;\n&#39;;    return 0;&#125;</code></pre></details><hr /><h2 id="f.-permutation">F. Permutation</h2><p><a href="http://222.180.160.110:61235/contest/6181/problem/6" class="uri">http://222.180.160.110:61235/contest/6181/problem/6</a></p><p>如果全是 <code>&lt;</code>，方案数为 <span class="math inline">\(1\)</span>。</p><p>现在把其中一些 <code>&lt;</code> 变成 <code>?</code>，比如 <code>&lt;&lt;??&lt;?&lt;&lt;&lt;&lt;</code> 的方案数，<del>太好了是多重集排列，我们没救了</del> 显然被 <code>&lt;</code> 连接起来的一段元素只有一种排列方式，所以可以视为多重集排列，方案数为 <span class="math inline">\(\dfrac {11!}{3!\times 2!\times 5!}\)</span>。</p><p>似乎只需要枚举把 <code>&gt;</code> 变成 <code>&lt;</code> 或 <code>=</code> 的 <span class="math inline">\(2^k\)</span> 种情况再计算就可以了，可惜 <span class="math inline">\(k\)</span> 有点大。但我们发现它在一定程度上是没有后效性的，比如 <code>&lt;&lt;??&lt;</code> 和 <code>&lt;&lt;?&lt;&lt;</code>，前面的 <code>&lt;&lt;</code> 不会对后面的内容带来影响。</p><p>故令 <span class="math inline">\(f_i\)</span> 表示对于前 <span class="math inline">\(i\)</span> 个元素的方案数，枚举最后一个被钦定为 <code>?</code> 的 <code>&gt;</code> <span class="math inline">\(j\)</span>（即 <span class="math inline">\([j + 1, i-1]\)</span> 间的 <code>&gt;</code> 都被替换为 <code>&lt;</code>），带上容斥系数，有 <span class="math inline">\(f_i=\sum\limits_{s_j=\texttt{&#39;&gt;&#39;}}(-1)^{cnt_\texttt{&#39;&gt;&#39;}[j + 1, i - 1]}\times f_j\times\dfrac1{(i-j)!}\)</span>。</p><details><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;const int mod = 1e9 + 7;int main() &#123;#ifdef ONLINE_JUDGE    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr), std::cout.tie(nullptr);#else    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);#endif    int n;    std::cin &gt;&gt; n;    std::vector&lt;long long&gt; fac(n + 1), inv(n + 1);    fac[0] = 1ll, inv[0] = 1ll;    for (int i = 1; i &lt;= n; ++i)        fac[i] = fac[i - 1] * i % mod;    auto qkp = [](long long x, int y) &#123;        auto res = 1ll;        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)            if (y &amp; 1)                (res *= x) %= mod;        return res;    &#125;;    inv[n] = qkp(fac[n], mod - 2);    for (int i = n - 1; i; --i)        inv[i] = inv[i + 1] * (i + 1) % mod;    std::vector&lt;char&gt; s(n + 1);    for (int i = 1; i &lt;= n; ++i)        std::cin &gt;&gt; s[i];    std::vector&lt;long long&gt; f(n + 1);    s[0] = &#39;&gt;&#39;, f[0] = 1ll;    for (int i = 1; i &lt;= n; ++i) &#123;        int cnt = 0;        for (int j = i - 1; ~j; --j)            if (s[j] == &#39;&gt;&#39;) &#123;                long long k = (cnt &amp; 1) ? mod - 1 : 1;                (k *= f[j]) %= mod, (k *= inv[i - j]) %= mod;                (f[i] += k) %= mod;                ++cnt;            &#125;        // printf(&quot;f[%d] = %lld\n&quot;, i, f[i]);    &#125;    std::cout &lt;&lt; f[n] * fac[n] % mod &lt;&lt; &#39;\n&#39;;    return 0;&#125;</code></pre></details><hr /><p><em>忳郁邑余侘傺兮，余独穷困乎此时也。</em></p><hr /><h2 id="h.-k-perm-counting">H. ~K Perm Counting</h2><p><a href="http://222.180.160.110:61235/contest/6181/problem/8" class="uri">http://222.180.160.110:61235/contest/6181/problem/8</a></p><p>考虑钦定令几个元素不满足条件进行容斥，即答案为 <span class="math inline">\(\sum\limits_{i=0}^n (-1)^i\cdot f(i)\)</span>。但我们发现 <span class="math inline">\([n-k,n+k]\)</span> 都有两个不能选的值，直接取 <span class="math inline">\(f(i)=\prod 2\)</span> 肯定会选到相同值，一个自然（？）的想法是再容斥一遍，可惜手玩一下发现似乎容不动。考虑把玩意儿拍在棋盘上：</p><figure><img src="1.png" alt="以 k=2 为例" /><figcaption>以 <span class="math inline">\(k=2\)</span> 为例</figcaption></figure><p>其中 <span class="math inline">\(\times\)</span> 是非法格子，边是非法格子间的不同选关系，同颜色的边隶属同一条链。容易发现如果棋盘继续扩大，这些链还会继续延长。</p><p>会发现这些链互不干扰，就是说我选了这条链上的某个点和链外的点没有任何关系（显然）。把这些链首尾相连拼起来，要做的就是拼接处可以选相邻，其余位置不能选相邻，选出来 <span class="math inline">\(i\)</span> 个的方案数。提前预处理出来整个序列，令 <span class="math inline">\(tag_j\)</span> 表示 <span class="math inline">\(j\)</span> 是否能和 <span class="math inline">\(j-1\)</span> 同选，设 <span class="math inline">\(dp_{j,i,0/1}\)</span> 表示 DP 到了 <span class="math inline">\(j\)</span>，已经选了 <span class="math inline">\(i\)</span> 个数，第 <span class="math inline">\(j\)</span> 个元素（不）选的方案数，那么有：</p><p><span class="math display">\[dp_{j,i,0} = dp_{j - 1, i, 0} + dp_{j-1, i, 1}\\dp_{j,i,1} = \begin{cases}dp_{j-1, i - 1, 1} + dp_{j-1,i - 1,0}&amp;tag_j=1\\dp_{j-1,i,0}&amp;\text{otherwise}\end{cases}\]</span></p><p>大力 DP 即可。<span class="math inline">\(f(i)\)</span> 即为 <span class="math inline">\((n-i)!\times (dp_{m, i, 0} + dp_{m, i, 1})\)</span>，其中 <span class="math inline">\(m\)</span> 为总链长。</p><details><p>注意不滚动可能会 MLE <img src="/em/kt.gif" /></p><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;const int mod = 924844033;int main() &#123;#ifdef ONLINE_JUDGE    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr), std::cout.tie(nullptr);#else    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);#endif    int n, k;    std::cin &gt;&gt; n &gt;&gt; k;    std::vector&lt;int&gt; tag(1);    std::vector&lt;long long&gt; fac(n + 1);    std::vector&lt;std::vector&lt;int&gt; &gt; vis(n + 1, std::vector&lt;int&gt; (n + 1));    auto calc = [&amp;](int i, int j, int s) &#123;        tag.push_back(1);        for (; ; s ^= 1) &#123;            // printf(&quot;(%d, %d) &quot;, i, j);            vis[i][j] = 1;            if (!s) &#123;                i = j + k;                if (i &lt;= n)                    tag.push_back(0);                else                    break;            &#125;            else &#123;                j = i + k;                if (j &lt;= n)                    tag.push_back(0);                else                    break;            &#125;        &#125;        // puts(&quot;&quot;);        return;    &#125;;    fac[0] = 1ll;    for (int i = 1; i &lt;= n; ++i) &#123;        fac[i] = fac[i - 1] * i % mod;        int j = i - k;        if (j &gt;= 1 &amp;&amp; !vis[i][j])            calc(i, j, 1);        j = i + k;        if (j &lt;= n &amp;&amp; !vis[i][j])            calc(i, j, 0);    &#125;    int m = (int)tag.size() - 1;    // printf(&quot;m = %d\n&quot;, m);    std::vector&lt;std::vector&lt;std::vector&lt;long long&gt; &gt; &gt; dp(2, std::vector&lt;std::vector&lt;long long&gt; &gt; (n + 1, std::vector&lt;long long&gt; (2)));    dp[0][0][0] = 1ll;    for (int j = 1, now = 1; j &lt;= m; ++j, now ^= 1) &#123;        for (int i = 0; i &lt;= n &amp;&amp; i &lt;= j; ++i) &#123;            dp[now][i][0] = dp[!now][i][0];            dp[now][i][1] = 0ll;            if (i) &#123;                (dp[now][i][0] += dp[!now][i][1]) %= mod;                dp[now][i][1] = dp[!now][i - 1][0];                if (tag[j]) &#123;                    (dp[now][i][1] += dp[!now][i - 1][1]) %= mod;                    // assert(0);                &#125;            &#125;            // printf(&quot;dp[%d][%d] = %lld / %lld\n&quot;, j, i, dp[j][i][0], dp[j][i][1]);        &#125;    &#125;    long long res = 0ll;    for (int i = 0, p = 1; i &lt;= n; ++i, p = mod - p)        (res += p * fac[n - i] % mod * (dp[m &amp; 1][i][0] + dp[m &amp; 1][i][1]) % mod) %= mod;    std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;    return 0;&#125;</code></pre></details><hr /><h2 id="a---positions-in-permutations">A - Positions in Permutations</h2><p><a href="https://codeforces.com/problemset/problem/285/E" class="uri">https://codeforces.com/problemset/problem/285/E</a></p><p><del>（看向上一题）这照片是你吗？</del></p><p>在上一题的基础上，令 <span class="math inline">\(k=1\)</span>。但是有个小小的问题——所求的「至少」不为 <span class="math inline">\(0\)</span>，无法简单容斥。具体地，如果一个排列一共有 <span class="math inline">\(p\)</span> 个非法排列，那么它会被 <span class="math inline">\(f(i)\)</span> 统计 <span class="math inline">\(C_p^i\)</span> 次。令 <span class="math inline">\(g(p)\)</span> 表示非法格子数恰好为 <span class="math inline">\(p\)</span> 的排列的真实数量，则 <span class="math inline">\(f(i)=\sum\limits_{j=i}^n C_j^i\cdot g(j)\)</span>，二项式反演即可得到真实值 <span class="math inline">\(g(m)=\sum\limits_{j=m}^n (-1)^{j-m}\cdot C_j^m\cdot f(j)\)</span>。</p><details><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;const int mod = 1e9 + 7;int main() &#123;#ifdef ONLINE_JUDGE    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr), std::cout.tie(nullptr);#else    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);#endif    int n, k;    std::cin &gt;&gt; n &gt;&gt; k;    std::vector&lt;int&gt; tag(1);    std::vector&lt;long long&gt; fac(n + 1), inv(n + 1);    std::vector&lt;std::vector&lt;int&gt; &gt; vis(n + 1, std::vector&lt;int&gt; (n + 1));    auto calc = [&amp;](int i, int j, int s) &#123;        tag.push_back(1);        for (; i &lt;= n &amp;&amp; j &lt;= n; s ^= 1) &#123;            vis[i][j] = 1;            if (!s) &#123;                i = j + 1;                if (i &lt;= n)                    tag.push_back(0);            &#125;            else &#123;                j = i + 1;                if (j &lt;= n)                    tag.push_back(0);            &#125;        &#125;        return;    &#125;;    auto qkp = [&amp;](long long x, int y) &#123;        auto res = 1ll;        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)            if (y &amp; 1)                (res *= x) %= mod;        return res;    &#125;;    fac[0] = 1ll, inv[0] = 1ll;    for (int i = 1; i &lt;= n; ++i) &#123;        fac[i] = fac[i - 1] * i % mod;        int j = i - 1;        if (j &gt;= 1 &amp;&amp; !vis[i][j])            calc(i, j, 1);        j = i + 1;        if (j &lt;= n &amp;&amp; !vis[i][j])            calc(i, j, 0);    &#125;    inv[n] = qkp(fac[n], mod - 2);    for (int i = n - 1; i; --i)        inv[i] = inv[i + 1] * (i + 1) % mod;    int m = (int)tag.size() - 1;    std::vector&lt;std::vector&lt;std::vector&lt;long long&gt; &gt; &gt; dp(2, std::vector&lt;std::vector&lt;long long&gt; &gt; (n + 1, std::vector&lt;long long&gt; (2)));    dp[0][0][0] = 1ll;    for (int j = 1, now = 1; j &lt;= m; ++j, now ^= 1) &#123;        for (int i = 0; i &lt;= n &amp;&amp; i &lt;= j; ++i) &#123;            dp[now][i][0] = dp[!now][i][0];            dp[now][i][1] = 0ll;            if (i) &#123;                (dp[now][i][0] += dp[!now][i][1]) %= mod;                dp[now][i][1] = dp[!now][i - 1][0];                if (tag[j])                    (dp[now][i][1] += dp[!now][i - 1][1]) %= mod;            &#125;        &#125;    &#125;    auto C = [&amp;](int n, int m) &#123;        return fac[n] * inv[n - m] % mod * inv[m] % mod;    &#125;;    long long res = 0ll;    for (int i = k, p = 1; i &lt;= n; ++i, p = mod - p) &#123;        // printf(&quot;%d: %lld\n&quot;, i, C(i, k) * fac[n - i] % mod * (dp[m &amp; 1][i][0] + dp[m &amp; 1][i][1]) % mod);        (res += p * C(i, k) % mod * fac[n - i] % mod * (dp[m &amp; 1][i][0] + dp[m &amp; 1][i][1]) % mod) %= mod;    &#125;    std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;    return 0;&#125;</code></pre></details><hr /><h2 id="d---all-pairs-similarity-p">D - All Pairs Similarity P</h2><p><a href="https://www.luogu.com.cn/problem/P11458" class="uri">https://www.luogu.com.cn/problem/P11458</a></p><p>省流：求 <span class="math inline">\(\forall\,i,f_i=\sum\limits_{j=1}^n \dfrac{|a_i\cap a_j|}{|a_i\cup a_j|}\)</span>。</p><p>首先分离常数，有：</p><p><span class="math display">\[\begin{aligned}f_i&amp;=\sum\limits_{j=1}^n \dfrac{|a_i\cap a_j|}{|a_i\cup a_j|}\\&amp;=\sum_{j=1}^n\dfrac {|a_i|+|a_j|-|a_i\cup a_j|}{|a_i\cup a_j|}\\&amp;=\sum_{j=1}^n \dfrac {|a_i|+|a_j|}{|a_i\cup a_j|}-1\end{aligned}\]</span></p><p>尽量把分子变得更简：</p><p><span class="math display">\[\begin{aligned}f_i&amp;=\sum_{j=1}^n \dfrac {|a_i|+|a_j|}{|a_i\cup a_j|}-1\\&amp;=|a_i|\cdot\left(\sum_{j=1}^n\dfrac 1{|a_i\cup a_j|}\right)-n+\sum_{j=1}^n \dfrac {|a_j|}{|a_i\cup a_j|}\end{aligned}\]</span></p><p>问题转化为求解 <span class="math inline">\(\sum\limits_{j=1}^n\dfrac 1{|a_i\cup a_j|}\)</span> 和 <span class="math inline">\(\sum\limits_{j=1}^n\dfrac {|a_j|}{|a_i\cup a_j|}\)</span>，以 <span class="math inline">\(*=\sum\limits_{j=1}^n\dfrac 1{|a_i\cup a_j|}\)</span> 为例。令 <span class="math inline">\(b_i\)</span> 为 <span class="math inline">\(a_i\)</span> 补集，则：</p><p><span class="math display">\[\begin{aligned}*&amp;=\sum\limits_{j=1}^n\dfrac 1{|a_i\cup a_j|}\\&amp;=\sum_{j=1}^n\dfrac 1{k-|b_i\cap b_j|}\end{aligned}\]</span></p><p>为什么要做这个转换呢？相比起并集运算，交集运算有着优秀的性质：<span class="math inline">\(s\subseteq(b_i\cap b_j)\iff s\subseteq b_i\land s\subseteq b_j\)</span>，<del>直接取或当然也有相似的性质，但是太烧脑了</del>。</p><p>基于这个性质，我们有一个想法：对于所有 <span class="math inline">\(j\)</span>，在 <span class="math inline">\(\forall \, s\subseteq b_j\)</span> 处放置 <span class="math inline">\(\dfrac 1{k-|s|}\)</span> 的贡献；对于 <span class="math inline">\(i\)</span>，将 <span class="math inline">\(\forall \, s\subseteq b_i\)</span> 处的贡献求和。但是这样肯定会拿到很多我们不想要的贡献，例如 <span class="math inline">\(\forall \, s\subset (b_i\cap b_j)\)</span>。</p><p>考虑精细布置贡献——构造 <span class="math inline">\(g(|s|)\)</span> 满足 <span class="math inline">\(\sum\limits_{j=1}^n\sum\limits_{s\subseteq b_j}g(|s|)=*\)</span>。</p><p>这里可以二项式反演得到 <span class="math inline">\(g\)</span>，具体地，令 <span class="math inline">\(F(|S|)=\dfrac 1{k-|S|}=\sum\limits_{s\subseteq S}g(|s|)=\sum\limits_{j=0}^{|S|} C_{|S|}^j g(j)\)</span>，则 <span class="math inline">\(g(i)=\sum\limits_{j=0}^iC_i^j\cdot \dfrac {(-1)^{i-j}}{k-j}\)</span>。</p><p>再令 <span class="math inline">\(h(s)=\sum\limits_{b_j\supseteq s}g(|s|)=g(|s|)\cdot \sum\limits_{b_j\supseteq s}1\)</span>，那么 <span class="math inline">\(h\)</span> 就是高维后缀和。我们正在做的事情就是求解 <span class="math inline">\(*=\sum\limits_{s\subseteq b_i}h(s)\)</span>，这就又是一个高维前缀和了。</p><p>对于 <span class="math inline">\(\sum\limits_{j=1}^n\dfrac {|a_j|}{|a_i\cup a_j|}\)</span> 呢，令 <span class="math inline">\(h(s)=\sum\limits_{b_j\supseteq s}g(|s|)\cdot {\color{red}{|a_j|}} = g(|s|) \cdot \sum\limits_{b_j\supseteq s} \color{red}{k - |b_j|}\)</span>，改变高维后缀和求和对象即可。</p><p>复杂度就是 <span class="math inline">\(O(n+k\cdot 2^k)\)</span>，其中 <span class="math inline">\(k\cdot 2^k\)</span> 来自整体高维前 / 后缀和，<span class="math inline">\(n\cdot k\)</span> 来自枚举 <span class="math inline">\(i\)</span>。</p><details><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;const int mod = 1e9 + 7;int main() &#123;#ifdef ONLINE_JUDGE    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr), std::cout.tie(nullptr);#else    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);#endif    int n, k, l;    std::cin &gt;&gt; n &gt;&gt; k, l = 1 &lt;&lt; k;    std::vector&lt;int&gt; a(n + 1), b(n + 1), cnt(l);    for (int i = 1; i &lt;= n; ++i) &#123;        std::cin &gt;&gt; a[i], b[i] = (l - 1) ^ a[i];        ++cnt[b[i]];    &#125;    std::vector&lt;long long&gt; g(k + 1), fac(k + 1);    auto qkp = [&amp;](long long x, int y = mod - 2) &#123;        auto res = 1ll;        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)            if (y &amp; 1)                (res *= x) %= mod;        return res;    &#125;;    auto C = [&amp;](int n, int m) &#123;        return fac[n] * qkp(fac[n - m]) % mod * qkp(fac[m]) % mod;    &#125;;    fac[0] = 1ll;    for (int i = 1; i &lt;= k; ++i)        fac[i] = fac[i - 1] * i % mod;    for (int i = 0; i &lt;= k; ++i) &#123;        for (int j = 0, p = (i &amp; 1) ? mod - 1 : 1; j &lt;= i; ++j, p = mod - p)            (g[i] += C(i, j) * p % mod * qkp(k - j) % mod) %= mod;        // printf(&quot;g[%d] = %lld\n&quot;, i, g[i]);    &#125;    // for (int i = 0; i &lt;= k; ++i) &#123;    //     long long F = 0ll;    //     for (int j = 0; j &lt;= i; ++j)    //         (F += C(i, j) * g[j] % mod) %= mod;    //     printf(&quot;%d: %lld / %lld\n&quot;, i, F, qkp(k - i));    // &#125;    std::vector&lt;long long&gt; h(l);    std::copy(cnt.begin(), cnt.end(), h.begin());    for (int i = 0; i &lt; k; ++i)        for (int j = l - 1; ~j; --j)            if (!((j &gt;&gt; i) &amp; 1))                (h[j] += h[j ^ (1 &lt;&lt; i)]) %= mod;    auto f1(h);    for (int i = 0; i &lt; l; ++i)        (f1[i] *= g[__builtin_popcount(i)]) %= mod;    for (int i = 0; i &lt; k; ++i)        for (int j = 0; j &lt; l; ++j)            if ((j &gt;&gt; i) &amp; 1)                (f1[j] += f1[j ^ (1 &lt;&lt; i)]) %= mod;    for (int i = 0; i &lt; l; ++i)        h[i] = cnt[i] * (k - __builtin_popcount(i));    for (int i = 0; i &lt; k; ++i)        for (int j = l - 1; ~j; --j)            if (!((j &gt;&gt; i) &amp; 1))                (h[j] += h[j ^ (1 &lt;&lt; i)]) %= mod;    auto f2(h);    for (int i = 0; i &lt; l; ++i)        (f2[i] *= g[__builtin_popcount(i)]) %= mod;    for (int i = 0; i &lt; k; ++i)        for (int j = 0; j &lt; l; ++j)            if ((j &gt;&gt; i) &amp; 1)                (f2[j] += f2[j ^ (1 &lt;&lt; i)]) %= mod;    for (int i = 1; i &lt;= n; ++i) &#123;        // fprintf(stderr, &quot;%d: %d * %lld - %d + %lld\n&quot;, i, __builtin_popcount(a[i]), f1[b[i]], n, f2[b[i]]);        std::cout &lt;&lt; (__builtin_popcount(a[i]) * f1[b[i]] % mod + mod - n + f2[b[i]]) % mod &lt;&lt; &#39;\n&#39;;    &#125;    return 0;&#125;</code></pre></details><hr /><h2 id="e---prefix-xors">E - Prefix XORs</h2><p><a href="https://atcoder.jp/contests/arc137/tasks/arc137_d" class="uri">https://atcoder.jp/contests/arc137/tasks/arc137_d</a></p><p>省流：做 <span class="math inline">\(k\)</span> 次前缀和，<span class="math inline">\(k=1,2,\cdots,m\)</span>，分别询问：令 <span class="math inline">\(x_i\gets a_i\)</span> 对 <span class="math inline">\(s_n\)</span> 的贡献次数，则 <span class="math inline">\(\sum a_i\cdot (x_i\bmod 2)\)</span>？</p><p>对于 <span class="math inline">\(a_p\)</span>，容易发现第一轮其对任意 <span class="math inline">\(s_q\)</span> 有 <span class="math inline">\(1\)</span> 次贡献，拉开来就是常数列；第二轮有 <span class="math inline">\((q-p+1)\)</span> 次贡献，是公差为 <span class="math inline">\(1\)</span> 的等差数列；第三轮是类三角形数——至此，肯定和组合数有关了。手玩可以发现第 <span class="math inline">\(k\)</span> 轮 <span class="math inline">\(a_p\)</span> 对 <span class="math inline">\(s_n\)</span> 的贡献为 <span class="math inline">\(C_{n-p+(k-2)}^{n-p}\)</span>，尽量令其中一个不动，得到 <span class="math inline">\(C_{n-p+(k-2)}^{k-1}\)</span>。</p><p>但是我们发现直接枚举每轮每个数会起飞，而且模数为 <span class="math inline">\(2\)</span> 似乎只能 Lucas（再带个 <span class="math inline">\(\log\)</span>），怎么办呢？</p><p>那就 Lucas 呗。由其观察容易发现 <span class="math inline">\(C_{n-p+(k-2)}^{k-2}\bmod2=1\)</span> 当且仅当 <span class="math inline">\((k-2)\subseteq (n-p+k-2)\iff (k-2)\subseteq \complement_U(n-p)\)</span>，故问题转化为高维后缀和，<del>当然你也可以做一次 and-FWT</del>，那么 <span class="math inline">\(res_k=\sum (C_{n-p+(k-2)}^{k-2}\bmod 2)\cdot a_p=S_{k-2}\)</span>，其中 <span class="math inline">\(S\)</span> 为高维后缀和，初值为 <span class="math inline">\(S_{\complement_u(n-i)}\gets a_i\)</span>。</p><details><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;int main() &#123;#ifdef ONLINE_JUDGE    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr), std::cout.tie(nullptr);#else    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);#endif    int n, m, l, k;    std::cin &gt;&gt; n &gt;&gt; m, k = std::__lg(n + m) + 1, l = 1 &lt;&lt; k;    std::vector&lt;int&gt; s(l);    for (int i = 1; i &lt;= n; ++i)        std::cin &gt;&gt; s[l - 1 - (n - i)];    for (int i = 0; i &lt; k; ++i)        for (int j = l - 1; ~j; --j)            if (!((j &gt;&gt; i) &amp; 1))                s[j] ^= s[j ^ (1 &lt;&lt; i)];    for (int i = 1; i &lt;= m; ++i)        std::cout &lt;&lt; s[i - 1] &lt;&lt; &#39; &#39;;    std::cout &lt;&lt; &#39;\n&#39;;    return 0;&#125;</code></pre></details><hr /><h2 id="b---the-top-scorer">B - The Top Scorer</h2><p><a href="https://codeforces.com/problemset/problem/1096/E" class="uri">https://codeforces.com/problemset/problem/1096/E</a></p><p>鉴于每种方案等概率（翻译没说，但原题面有提到），考虑计算小明能够取胜的方案数，再对总方案数做除法。先枚举最高分 <span class="math inline">\(k\ge r\)</span>，再枚举包括小明在内恰有 <span class="math inline">\(c\ge 1\)</span> 个人 拿到 <span class="math inline">\(k\)</span> 分。但剩下的人呢？显然是不能插板随机分配的，因为存在 <span class="math inline">\(&lt;k\)</span> 的限制。</p><p>考虑容斥，钦定剩下的 <span class="math inline">\(p-c\)</span> 个人中拿到 <span class="math inline">\(\ge k\)</span> 分的人数后再可空地插板即可，则总方案数为：</p><p><span class="math display">\[\sum_{k=r}^s\sum_{c=1}^p\dfrac {C_{p - 1}^{c-1}}c\cdot \sum_{i=0}^{p-c}C_{p-c}^i\cdot C_{s-k\cdot (c+i)+(p-c-1)}^{p-c-1}\]</span></p><p>其中分母上的 <span class="math inline">\(c\)</span> 来源于等概率分配给最高分，虽然不是整数，但也代表着「小明获胜可行方案数」。最后将答案除上总方案数 <span class="math inline">\(C_{s-r+p-1}^{p-1}\)</span> 即可。</p><details><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;const int mod = 998244353;int main() &#123;#ifdef ONLINE_JUDGE    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr), std::cout.tie(nullptr);#else    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);#endif    int p, s, r;    std::cin &gt;&gt; p &gt;&gt; s &gt;&gt; r;    std::vector&lt;long long&gt; fac(s + p), inv(s + p);    fac[0] = inv[0] = 1ll;    for (int i = 1; i &lt; s + p; ++i) &#123;        fac[i] = fac[i - 1] * i % mod;    &#125;    auto qkp = [&amp;](long long x, int y) &#123;        auto res = 1ll;        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)            if (y &amp; 1)                (res *= x) %= mod;        return res;    &#125;;    inv.back() = qkp(fac.back(), mod - 2);    for (int i = s + p - 2; i &gt; 0; --i)        inv[i] = inv[i + 1] * (i + 1) % mod;    auto C = [&amp;](int n, int m) &#123;        if (n == -1 &amp;&amp; m == -1)            return 1ll;        return fac[n] * inv[n - m] % mod * inv[m] % mod;    &#125;;    auto res(0ll);    for (int k = r; k &lt;= s; ++k)        for (int c = 1; c &lt;= p; ++c)            if ((p - c) * (k - 1) + c * k &gt;= s) &#123;                auto t(0ll);                for (int i = 0, now = 1; i &lt;= p - c &amp;&amp; k * (c + i) &lt;= s; ++i, now = mod - now)                    (t += now * C(p - c, i) % mod * C(s - k * (c + i) + (p - c - 1), p - c - 1) % mod) %= mod;                (res += C(p - 1, c - 1) * qkp(c, mod - 2) % mod * t % mod) %= mod;            &#125;    std::cout &lt;&lt; res * qkp(C(s - r + p - 1, p - 1), mod - 2) % mod &lt;&lt; &#39;\n&#39;;    return 0;&#125;</code></pre></details><hr /><h2 id="c---sky-full-of-stars">C - Sky Full of Stars</h2><p><a href="https://codeforces.com/problemset/problem/997/C" class="uri">https://codeforces.com/problemset/problem/997/C</a></p><p>发现用 <span class="math inline">\(3^{n\times n}\)</span> 减去任意一行一列不同色的方案就是答案。</p><p>考虑一元容斥，如令 <span class="math inline">\(f_i\)</span> 表示至少 <span class="math inline">\(i\)</span> 行 <span class="math inline">\(i\)</span> 列同色的方案，但会发现 <span class="math inline">\(f_0\)</span> 中包含 <span class="math inline">\(0\)</span> 行 <span class="math inline">\(1\)</span> 列同色等与预期不符的情况。受此启发考虑令 <span class="math inline">\(f_{i,j}\)</span> 表示至少 <span class="math inline">\(i\)</span> 行 <span class="math inline">\(j\)</span> 列同色进行二元容斥。容易发现当 <span class="math inline">\(i\times j\ne 0\)</span> 时，被选中的 <span class="math inline">\(i\)</span> 行 <span class="math inline">\(j\)</span> 列全部连通，应为同一种颜色；将它们挪到角落，可以发现未被选中的格子共有 <span class="math inline">\((n-i)\times (n-j)\)</span> 个。故有：</p><p><span class="math display">\[f_{i,j}=\begin{cases}C_n^j\times 3^j\times 3^{n\times(n - j)}&amp;i=0\\C_n^i\times 3^i\times 3^{n\times(n-i)}&amp;j=0\\C_n^i\times C_n^j\times 3\times 3^{(n-i)\times (n-j)}&amp;\text{otherwise}\end{cases}\]</span></p><p>令 <span class="math inline">\(g_{i,j}\)</span> 表示恰好 <span class="math inline">\(i\)</span> 行 <span class="math inline">\(j\)</span> 列同色的方案数，那么答案为 <span class="math inline">\(3^{n\times n}-g_{0,0}\)</span>。二项式反演 / 容斥原理得 <span class="math inline">\(g_{0,0}=\sum\limits_{i=0}^n\sum\limits_{j=0}^n (-1)^{i+j}\cdot f_{i,j}\)</span>。很惊讶地发现这是 <span class="math inline">\(O(n^2)\)</span> 的！考虑优化。把 <span class="math inline">\(f_{1\to n,1\to n}\)</span> 合并同类项，得到：</p><p><span class="math display">\[\begin{aligned}g_{0, 0}&amp;=\left[\sum_{j=0}^n (-1)^j\cdot f_{0,j}\right]+\sum_{i=1}^n (-1)^i\cdot f_{i,0}+\sum_{j=1}^n (-1)^{i+j}\cdot C_n^i\times C_n^j\times 3^{(n-i)\times (n-j)+1}\\&amp;=\left[\sum_{j=0}^n (-1)^j\cdot f_{0,j}\right]+\sum_{i=1}^n (-1)^i\cdot f_{i,0}+(-1)^i\cdot C_n^i\times 3^{n^2-n\times i+1}\times\sum_{j=1}^n (-1)^j\cdot C_n^j\times 3^{j\times(-n+i)}\\&amp;=\left[\sum_{j=0}^n (-1)^j\cdot f_{0,j}\right]+\sum_{i=1}^n (-1)^i\cdot f_{i,0}+(-1)^i\cdot C_n^i\times 3^{n^2-n\times i+1}\times\left[\left(\sum_{j=0}^n (-1)^j\cdot C_n^j\times (3^{-n+i})^j\right)-1\right]\\&amp;=\left[\sum_{j=0}^n (-1)^j\cdot f_{0,j}\right]+\sum_{i=1}^n (-1)^i\cdot f_{i,0}+(-1)^i\cdot C_n^i\times 3^{n^2-n\times i+1}\times\left[(-3^{-n+i}+1)^n-1\right]\end{aligned}\]</span></p><p>由此便可 <span class="math inline">\(O(n\log n)\)</span> 计算。担心超时可以把所有 <span class="math inline">\(3^{-n+i}\)</span> 和 <span class="math inline">\(3^{n\times i}\)</span> 线性预处理出来，复杂度不会变就是了。</p><p>这里解释一下最后一步的二项式定理，非常遗憾地发现 <span class="math inline">\(-1\)</span> 和 <span class="math inline">\(3^{-n+i}\)</span> 都是 <span class="math inline">\(j\)</span> 次的，没办法把二者相加减做二项式定理；但由于次数相同，这提示我们可以把 <span class="math inline">\(-1\)</span> 乘到 <span class="math inline">\(3^{-n+i}\)</span> 里去，给每一项配上 <span class="math inline">\(1^{n-k}\)</span> 就可以做 <span class="math inline">\(-3^{n-i}\)</span>（注意不是 <span class="math inline">\((-3)^{n-i}\)</span>） 和 <span class="math inline">\(1\)</span> 的二项式定理。</p><details><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;const int mod = 998244353;int main() &#123;#ifdef ONLINE_JUDGE    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr), std::cout.tie(nullptr);#else    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);#endif    long long n;    std::cin &gt;&gt; n;    std::vector&lt;long long&gt; fac(n + 1), inv(n + 1), invn(n + 1), invi(n + 1), powi(n + 1), pown(n + 1);    auto qkp = [&amp;](long long x, long long y) &#123;        auto res(1ll);        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)            if (y &amp; 1)                (res *= x) %= mod;        return res;    &#125;;    const long long pnn = qkp(3ll, n * n), pn = qkp(3ll, n);    fac[0] = inv[0] = invn[0] = invi[0] = powi[0] = pown[0] = 1ll;    for (int i = 1; i &lt;= n; ++i) &#123;        fac[i] = fac[i - 1] * i % mod;        powi[i] = powi[i - 1] * 3 % mod;        pown[i] = pown[i - 1] * pn % mod;    &#125;    inv[n] = qkp(fac[n], mod - 2);    invi[n] = qkp(powi[n], mod - 2);    invn[n] = qkp(pown[n], mod - 2);    for (int i = n - 1; i; --i) &#123;        inv[i] = inv[i + 1] * (i + 1) % mod;        invi[i] = invi[i + 1] * 3 % mod;        invn[i] = invn[i + 1] * pn % mod;    &#125;    auto C = [&amp;](int n, int m) &#123;        return fac[n] * inv[n - m] % mod * inv[m] % mod;    &#125;;    long long g = 0ll;    auto f = [&amp;](int i, int j) &#123; // make sure (!i || !j)        if (i == 0 &amp;&amp; j == 0)            return pnn;        else if (i == 0)            return C(n, j) * powi[j] % mod * pown[n - j] % mod;        return C(n, i) * powi[i] % mod * pown[n - i] % mod;    &#125;;    for (int j = 0, p = 1; j &lt;= n; ++j, p = mod - p)        (g += p * f(0, j)) %= mod;    for (int i = 1, p = mod - 1; i &lt;= n; ++i, p = mod - p)        (g += p * f(i, 0) % mod + p * C(n, i) % mod * pnn % mod * invn[i] % mod * 3 % mod * (qkp(mod - invi[n - i] + 1, n) + mod - 1) % mod) %= mod;    std::cout &lt;&lt; (pnn + mod - g) % mod &lt;&lt; &#39;\n&#39;;    return 0;&#125;</code></pre></details><hr /><h2 id="d---去-m-nom">D - 去 M / NoM</h2><p><a href="https://www.luogu.com.cn/problem/P11316" class="uri">https://www.luogu.com.cn/problem/P11316</a></p><p>假设 <span class="math inline">\(f(i)\)</span> 为至少有 <span class="math inline">\(i\)</span> 对不合法元素的方案数，则容斥得到答案 <span class="math inline">\(\sum\limits_{i=0}^n (-1)^i\cdot f(i)\)</span>。考虑怎么计算 <span class="math inline">\(f(i)\)</span>。</p><p><mark><span class="math inline">\(M\)</span> 整除 <span class="math inline">\(dis(x, y) \iff (pos_x - pos_y)\bmod M=0\iff pos_x\equiv pos_y\pmod M\)</span>。</mark></p><p>考虑把关于 <span class="math inline">\(M\)</span> 同余的位置放在一个组，也就是说需要让一对元素不能选同一组的位置。</p><p>考虑容斥，令 <span class="math inline">\(f(i)\)</span> 表示至少有 <span class="math inline">\(i\)</span> 对点选到一组的方案数，考虑怎么计算。假设我们要在第 <span class="math inline">\(k\)</span> 组（size 为 <span class="math inline">\(s_k\)</span>）中选出 <span class="math inline">\(x\)</span> 对位置，实际上只需要选择 <span class="math inline">\(2x\)</span> 个位置然后任意分配给这 <span class="math inline">\(x\)</span> 对数，即 <span class="math inline">\(A_{s_k}^{2x}\)</span>。设 <span class="math inline">\(dp_{i, j}\)</span> 表示 DP 到第 <span class="math inline">\(i\)</span> 个组，已经选了 <span class="math inline">\(j\)</span> 对，那么有 <span class="math inline">\(dp_{i,j}=\sum\limits_{k=0}^jC_{n-(j - k)}^{j-k}\times dp_{i-1,j-k}\times A_{s_i}^{2k}\)</span>。乍一看好像是 <span class="math inline">\(O(n^3)\)</span> 的，但是别忘了 <span class="math inline">\(\sum s_i=2n\)</span>，所以只有 <span class="math inline">\(O(n^2)\)</span>。<span class="math inline">\(f(i)\)</span> 即为 <span class="math inline">\(dp_{m,i}\times (2n-2i)!\)</span>。</p><details><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;const int mod = 1e9 + 7;int main() &#123;#ifdef ONLINE_JUDGE    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr), std::cout.tie(nullptr);#else    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);#endif    int n, m;    std::cin &gt;&gt; n &gt;&gt; m;    std::vector&lt;int&gt; s(m + 1);    std::vector&lt;long long&gt; fac(2 * n + 1), inv(2 * n + 1);    fac[0] = inv[0] = 1ll;    for (int i = 1; i &lt;= 2 * n; ++i)        ++s[i % m + 1], fac[i] = fac[i - 1] * i % mod;    auto qkp = [](long long x, int y) &#123;        auto res = 1ll;        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)            if (y &amp; 1)                (res *= x) %= mod;        return res;    &#125;;    inv[2 * n] = qkp(fac[2 * n], mod - 2);    for (int i = 2 * n - 1; i; --i)        inv[i] = inv[i + 1] * (i + 1) % mod;    auto A = [&amp;](int n, int m) &#123;        return fac[n] * inv[n - m] % mod;    &#125;;    auto C = [&amp;](int n, int m) &#123;        return fac[n] * inv[n - m] % mod * inv[m] % mod;    &#125;;    std::vector&lt;std::vector&lt;long long&gt; &gt; dp(m + 1, std::vector&lt;long long&gt; (n + 1));    dp[0][0] = 1ll;    for (int i = 1; i &lt;= m; ++i)        for (int j = 0; j &lt;= n; ++j) &#123;            for (int k = 0; k &lt;= j &amp;&amp; 2 * k &lt;= s[i]; ++k)                (dp[i][j] += C(n - (j - k), k) * dp[i - 1][j - k] % mod * A(s[i], 2 * k) % mod) %= mod;            // printf(&quot;s = %d, dp[%d][%d] = %lld\n&quot;, s[i], i, j, dp[i][j]);        &#125;    long long res = 0ll;    for (int i = 0, p = 1; i &lt;= n; ++i, p = mod - p)        (res += p * dp[m][i] % mod * fac[2 * n - 2 * i] % mod) %= mod;    std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;    return 0;&#125;</code></pre></details><hr /><h2 id="e---kdoi-11彩灯晚会">E - 「KDOI-11」彩灯晚会</h2><p><a href="https://www.luogu.com.cn/problem/P11292" class="uri">https://www.luogu.com.cn/problem/P11292</a></p><p>考虑 <span class="math inline">\({cnt_i}^2\)</span> 的含义，即在所有颜色为 <span class="math inline">\(i\)</span>、长度为 <span class="math inline">\(l\)</span> 的链中有放回地选两次的方案数。</p><p>显然复杂度里是不能包含 <span class="math inline">\(k\)</span> 的，所以放弃直接统计 <span class="math inline">\(cnt_i\)</span> 的想法。显然每种颜色是等价的，考虑计算选择两条链可以给答案带来的贡献：答案的形式是个和式；对于两条同色链 <span class="math inline">\(p,q\)</span>，假设颜色为 <span class="math inline">\(i\)</span>，那么会对 <span class="math inline">\({cnt_i}^2\)</span> 带来 <span class="math inline">\(k^{n-2l-|p\cap q|}\)</span> 的贡献，对总答案带来 <span class="math inline">\(k^{n-2l-|p\cap q| + 1}\)</span> 的贡献。</p><p>然而如果要枚举计算 <span class="math inline">\(|p\cap q|\)</span> 就无法避免 <span class="math inline">\(O(n^5)\)</span>，考虑更有潜力的方法：将问题转化为对于每个 <span class="math inline">\(x\)</span>，求交集大小恰好为 <span class="math inline">\(x\)</span> 的链对个数。然而「恰好」是不方便计算的——假如当前两链在 <span class="math inline">\(u\)</span> 次重合，如果假设下一次在 <span class="math inline">\(v\)</span> 次重合，就需要保证在 <span class="math inline">\(u,v\)</span> 之间不能重合——这并不好操作。二项式反演将恰好转化为至少，则限制减弱。</p><p>令 <span class="math inline">\(f_{u,c,l_1,l_2}\)</span> 表示 <span class="math inline">\(p,q\)</span> 当前在 <span class="math inline">\(u\)</span> 处重合，视野内的 <span class="math inline">\(p,q\)</span> 长度为 <span class="math inline">\(l_1,l_2\)</span>，至少已经重合了 <span class="math inline">\(c\)</span> 次的方案数。预处理出走到 <span class="math inline">\(u\)</span> 步数为 <span class="math inline">\(l_1,l_2\)</span> 的方案数为初始值。枚举可能的后续重合点 <span class="math inline">\(v\)</span>（满足 <span class="math inline">\(v\)</span> 的拓扑序 <span class="math inline">\(&gt;u\)</span>）有 <span class="math inline">\(f_{v,c+1,l_1&#39;,l_2&#39;}\gets f_{v,c+1,l_1&#39;,l_2&#39;} + f_{u,c,l_1,l_2}\)</span>。预处理出 <span class="math inline">\(u\to v\)</span> 长度为 <span class="math inline">\(\Delta\)</span> 的方案数（这是 <span class="math inline">\(O(n^3l)\)</span> 的）优化转移，在算出 <span class="math inline">\(nex_{u,l}\)</span> 表示从 <span class="math inline">\(u\)</span> 出发走 <span class="math inline">\(l\)</span> 步的方案数处理答案，则 <span class="math inline">\(F(i)=\sum_{u,l_1,l_2}f_{u,l_1,l_2}\cdot nex_{u,l-l_1}\cdot nex_{u,l-l_2}\)</span>，枚举 <span class="math inline">\(u,c,l_1,l_2,v,l_1&#39;,l_2&#39;\)</span>，就可以达到优秀的 <span class="math inline">\(O(n^2l^5+n^3l)\)</span>！简直是令人震撼 <img src="/em/kt.gif" /></p><p>给出第一个优化：发现 <span class="math inline">\(l_1\)</span> 和 <span class="math inline">\(l_2\)</span> 的转移彼此不干扰，考虑建立一个临时数组 <span class="math inline">\(g\)</span>，先从 <span class="math inline">\(f_u,c\)</span> 转移 <span class="math inline">\(l_1\)</span> 到 <span class="math inline">\(g\)</span>，再从 <span class="math inline">\(g\)</span> 转移 <span class="math inline">\(l_2\)</span> 到 <span class="math inline">\(f_{v,c+1}\)</span>，则复杂度降为 <span class="math inline">\(O(n^2l^4+n^3l)\)</span>，仍不足以通过。</p><p>DP 过程上的优化已经万策尽，考虑从式子本身消元减少 DP 维度入手。令 <span class="math inline">\(h(i)\)</span> 表示交集大小恰好恰好为 <span class="math inline">\(i\)</span> 的方案数，则此时答案式为 <span class="math inline">\(\sum\limits_{i=0}^l k^{n-2l+i+1}\times h(i)\)</span>。又 <span class="math inline">\(F(i)=\sum\limits_{j=i}^lC_j^i\cdot h(j)\)</span>，二项式反演得：</p><p><span class="math display">\[\begin{aligned}res&amp;=\sum\limits_{i=0}^lk^{n-2l+i+1}\cdot \sum_{j=i}^l(-1)^{j-i}\cdot C_j^i\cdot F(j)\\&amp;=k^{n-2l+1}\cdot\sum_{j=0}^l \sum_{i=0}^j k^i\cdot (-1)^{j-i}\cdot C_j^i\cdot F(j)\\&amp;=k^{n-2l+1}\cdot \sum_{j=0}^l (k-1)^j\cdot F(j)\end{aligned}\]</span></p><p><mark>注意这里利用了二项式反演的系数可以和交换求和顺序后的 <span class="math inline">\(i\)</span> 次项（或 <span class="math inline">\(j-i\)</span> 次项，参见 <a href="#c---sky-full-of-stars">Sky Full of Stars 中最后一步的处理</a>）组成二项式定理的特点</mark>，以便基于式子结构尽可能消元。</p><p>那么此时答案式已经和 <span class="math inline">\(c\)</span> 无关，可以丢掉 <span class="math inline">\(c\)</span> 这一维，和 <span class="math inline">\(c\)</span> 有关的计算已经在转移时处理了。则 <span class="math inline">\(f_{v,l_1&#39;,l_2&#39;}=\sum f_{u,l_1,l_2}\times (k-1)\)</span>，复杂度降为 <span class="math inline">\(O(n^2l^3+n^3l)\)</span>。</p><details><p>记得还要算上 <span class="math inline">\(F(0)\)</span>，即任选一条合法链的方案数平方。</p><pre class="cpp"><code>// 兄弟你好香// 兄弟你是依托打分，我踏马吃吃吃吃吃#include &lt;bits/stdc++.h&gt;const int mod = 998244353;int main() &#123;#ifdef ONLINE_JUDGE    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr), std::cout.tie(nullptr);#else    std::freopen(&quot;party3.in&quot;, &quot;r&quot;, stdin);    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);#endif    using arr = std::vector&lt;long long&gt;;    using arrr = std::vector&lt;arr&gt;;    using arrrr = std::vector&lt;arrr&gt;;    int n, k, l, m;    std::cin &gt;&gt; n, std::cin &gt;&gt; n &gt;&gt; k &gt;&gt; l &gt;&gt; m;    std::vector&lt;int&gt; deg(n + 1), id;    std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; g(n + 1);    for (int x, y, c; m--; ) &#123;        std::cin &gt;&gt; x &gt;&gt; y &gt;&gt; c;        ++deg[y], g[x].emplace_back(y, c);    &#125;    arrrr to(n + 1, arrr(n + 1, arr(l + 1)));    arrr pre(n + 1, arr(l + 1)), nex(n + 1, arr(l + 1));    &#123;        std::queue&lt;int&gt; q;        for (int i = 1; i &lt;= n; ++i)            if (!deg[i])                q.push(i);        for (int u; !q.empty(); ) &#123;            u = q.front(), q.pop();            to[u][u][0] = 1ll, id.push_back(u);            for (auto i : id)                for (int j = 0; j &lt;= l; ++j) &#123;                    (pre[u][j] += to[i][u][j]) %= mod;                    // printf(&quot;to[%d][%d][%d] = %lld\n&quot;, i, u, j, to[i][u][j]);                &#125;            // for (int j = 0; j &lt;= l; ++j)            //     printf(&quot;pre[%d][%d] = %lld\n&quot;, u, j, pre[u][j]);            for (auto [v, c] : g[u]) &#123;                for (auto i : id)                    for (int j = 1; j &lt;= l; ++j)                        (to[i][v][j] += to[i][u][j - 1] * c) %= mod;                if (!--deg[v])                    q.push(v);            &#125;        &#125;        for (int u = 1; u &lt;= n; ++u)            for (int v = 1; v &lt;= n; ++v)                for (int i = 0; i &lt;= l; ++i)                    (nex[u][i] += to[u][v][i]) %= mod;    &#125;    arrrr f(n + 1, arrr(l + 1, arr(l + 1)));    &#123;        for (int i = 1; i &lt;= n; ++i)            for (int l1 = 1; l1 &lt;= l; ++l1)                for (int l2 = 1; l2 &lt;= l; ++l2)                    f[i][l1][l2] = pre[i][l1 - 1] * pre[i][l2 - 1] % mod * (k - 1) % mod;        for (auto i = 0; i &lt; n; ++i) &#123;            int u = id[i];            // for (int l1 = 1; l1 &lt;= l; ++l1)            //     for (int l2 = 1; l2 &lt;= l; ++l2)            //         printf(&quot;f[%d][%d][%d] = %lld\n&quot;, u, l1, l2, f[u][l1][l2]);            for (auto j = i + 1; j &lt; n; ++j) &#123;                arrr g(l + 1, arr(l + 1));                int v = id[j];                for (int l1 = 1; l1 &lt; l; ++l1)                    for (int _l1 = l1 + 1; _l1 &lt;= l; ++_l1) &#123;                        auto K = to[u][v][_l1 - l1];                        if (K)                            for (int l2 = 1; l2 &lt; l; ++l2)                                (g[_l1][l2] += f[u][l1][l2] * K) %= mod;                    &#125;                for (int _l1 = 2; _l1 &lt;= l; ++_l1)                    for (int l2 = 1; l2 &lt; l; ++l2)                        if (g[_l1][l2])                            for (int _l2 = l2 + 1; _l2 &lt;= l; ++_l2)                                (f[v][_l1][_l2] += g[_l1][l2] * to[u][v][_l2 - l2] % mod * (k - 1)) %= mod;             &#125;        &#125;    &#125;    auto qkp = [](long long x, int y) &#123;        auto res(1ll);        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)            if (y &amp; 1)                (res *= x) %= mod;        return res;    &#125;;    auto res(0ll);    for (int u = 1; u &lt;= n; ++u)        for (int v = 1; v &lt;= n; ++v)            (res += to[u][v][l - 1]) %= mod;    (res *= res) %= mod;    for (int u = 1; u &lt;= n; ++u)        for (int l1 = 1; l1 &lt;= l; ++l1)            for (int l2 = 1; l2 &lt;= l; ++l2)                (res += f[u][l1][l2] * nex[u][l - l1] % mod * nex[u][l - l2] % mod) %= mod;    res = res % mod * (qkp(k, n + 1) * qkp(qkp(k, 2 * l), mod - 2) % mod) % mod;    std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;    return 0;&#125;</code></pre></details><hr /><h2 id="g---小星星">G - 小星星</h2><p><a href="https://www.luogu.com.cn/problem/P3349" class="uri">https://www.luogu.com.cn/problem/P3349</a></p><p>首先考虑比较暴力的做法，那么有 <span class="math inline">\(f_{i,j,S}\)</span> 表示在 <span class="math inline">\(i\)</span> 这个子树里面选了集合 <span class="math inline">\(S\)</span>，且 <span class="math inline">\(i\)</span> 的颜色为 <span class="math inline">\(j\)</span> 的方案数，维数里之所以有 <span class="math inline">\(j\)</span> 是为了满足连边限制。</p><p>然后树上子集 DP，发现是 <span class="math inline">\(O(n^4\cdot 2^n)\)</span> 的，</p><hr /><h2 id="cf785d-anton-and-school---2">CF785D Anton and School - 2</h2><p><a href="https://codeforces.com/problemset/problem/785/D" class="uri">https://codeforces.com/problemset/problem/785/D</a></p><p>容易想到枚举每个 <code>(</code> 作为分界点的情况，那么钦定当前枚举的 <code>(</code> 是要选的。对于当前 <code>(</code>，若其左边（不含）的 <code>(</code> 有 <span class="math inline">\(n\)</span> 个而右边的 <code>)</code> 有 <span class="math inline">\(m\)</span> 个，枚举除了当前 <code>(</code> 还要选 <span class="math inline">\(i\)</span> 个 <code>(</code>，那么答案为 <span class="math inline">\(\sum_{i=0}C_n^{i-1}\cdot C_m^i\)</span>。</p><p>发现这个形式可以范德蒙德卷积：<span class="math inline">\(\sum_{i=0}C_n^{i-1}\cdot C_m^i=\sum_{i=0}C_n^{n-i+1}\cdot C_m^i=C_{n+m}^{n+1}\)</span>。</p><p>关于怎么记忆范德蒙德卷积，发现上下相加，也可以从组合意义记忆：在 <span class="math inline">\(n\)</span> 个球中选出 <span class="math inline">\(k-i\)</span> 个球，再从 <span class="math inline">\(m\)</span> 个球中选出 <span class="math inline">\(i\)</span> 个球的总方案就是从 <span class="math inline">\(n+m\)</span> 个球中直接选出 <span class="math inline">\(k\)</span> 个球的方案。</p><p>注意判断右侧没有 <code>)</code> 的时候贡献为 <span class="math inline">\(0\)</span>。</p><details><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;const int mod = 1e9 + 7;int main() &#123;#ifdef ONLINE_JUDGE    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr), std::cout.tie(nullptr);#else    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);#endif    std::string s;    std::cin &gt;&gt; s;    int n = s.length();    s = &quot; &quot; + s;    std::vector&lt;int&gt; cnt1(n + 1), cnt2(n + 1);    std::vector&lt;long long&gt; fac(n + 1), inv(n + 1);    fac[0] = inv[0] = 1ll;    for (int i = 1; i &lt;= n; ++i) &#123;        fac[i] = fac[i - 1] * i % mod;        cnt1[i] = cnt1[i - 1] + (s[i] == &#39;(&#39;);    &#125;    auto qkp = [](long long x, int y) &#123;        auto res(1ll);        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)            if (y &amp; 1)                (res *= x) %= mod;        return res;    &#125;;    inv[n] = qkp(fac[n], mod - 2);    cnt2[n] = (s[n] == &#39;)&#39;);    for (int i = n - 1; i; --i) &#123;        cnt2[i] = cnt2[i + 1] + (s[i] == &#39;)&#39;);        inv[i] = inv[i + 1] * (i + 1) % mod;    &#125;    long long res = 0ll;    auto C = [&amp;](int n, int m) &#123;        if (n &lt; m)            return 0ll;        return fac[n] * inv[n - m] % mod * inv[m] % mod;    &#125;;    for (int i = 1; i &lt;= n; ++i)        if (s[i] == &#39;(&#39;)            (res += C(cnt1[i] + cnt2[i] - 1, cnt1[i])) %= mod;    std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;    return 0;&#125;</code></pre></details><hr /><h2 id="cf1332e-height-all-the-same">CF1332E Height All the Same</h2><p><a href="https://codeforces.com/problemset/problem/1332/E" class="uri">https://codeforces.com/problemset/problem/1332/E</a></p><p>容易发现第一个操作是用来改变两个数奇偶性的；而第二个操作能在全图奇偶性相同的任何情况下达成要求。</p><p>注意到如果我们想同时仅改变任意两个数的奇偶性，可以在棋盘上任找一条路径一路使用操作一。只要某种奇偶性的元素个数共有偶数个，就能通过若干次操作一把它们全部变成另一种奇偶性。</p><p>令 <span class="math inline">\(K_1\)</span> 为 <span class="math inline">\(L\sim R\)</span> 中奇数的个数，<span class="math inline">\(K_2\)</span> 为偶数，那么有：</p><p><span class="math display">\[res=\sum_{i=0}^{nm} C_{nm}^i\times {K_1}^i\cdot {K_2}^{nm-i}\cdot [i\bmod 2=0]\]</span></p><p>我们发现这个东西和二项式定理简直像得不能再像了！但多了一个系数导致没办法省略枚举过程。如果进行变形呢？</p><p><span class="math display">\[res=(K_1+K_2)^{nm}-\sum_{i=0}^{nm} C_{nm}^i\times {K_1}^i\cdot {K_2}^{nm-i}\cdot [i\bmod 2=1]\]</span></p><p>似乎依然没有出路！但这里有个神奇的操作：</p><p><span class="math display">\[res=(-K_1+K_2)^{nm}+\sum_{i=0}^{nm} C_{nm}^i\times {K_1}^i\cdot {K_2}^i\cdot [i\bmod 2=1]\]</span></p><p>二式相加就可以<mark>消元</mark>，得到 <span class="math inline">\(2\cdot res=(K_1+K_2)^{nm}+(K_1-K_2)^{nm}\)</span>。<mark>这启示我们二项式定理中的符号和奇偶性的深切联系。</mark></p><details><p>如果你使用费马小定理对次数进行了处理，你可能需要注意次数可能为 <span class="math inline">\(\text{mod} -1\)</span> 的倍数。</p><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;const int mod = 998244353;const int inv2 = 499122177;int main() &#123;#ifdef ONLINE_JUDGE    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr), std::cout.tie(nullptr);#else    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);#endif    long long n, m, l, r, k1, k2;    std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; l &gt;&gt; r, k1 = (r - l + 1) / 2, k2 = (r - l + 1) - k1;    auto qkp = [](long long x, long long y) &#123;        auto res(1ll);        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)            if (y &amp; 1)                (res *= x) %= mod;        return res;    &#125;;    if (n * m % 2)        std::cout &lt;&lt; qkp(r - l + 1, n * m) &lt;&lt; &#39;\n&#39;;    else        std::cout &lt;&lt; (qkp(r - l + 1, n * m) + qkp((k1 + mod - k2) % mod, n * m)) % mod * inv2 % mod &lt;&lt; &#39;\n&#39;;    return 0;&#125;</code></pre></details><hr /><h2 id="a---交错序列">A - 交错序列</h2><p><a href="https://www.luogu.com.cn/problem/P4456" class="uri">https://www.luogu.com.cn/problem/P4456</a></p><figure><img src="2.png" alt="出题人疑似需要加强数学功底（？）" /><figcaption>出题人疑似需要加强数学功底（？）</figcaption></figure><p>容易想到把答案用二项式定理拆开：</p><p><span class="math display">\[\begin{aligned}res&amp;=\sum_y f_y\cdot y^b\cdot (n-y)^a\\&amp;=\sum_y f_y\cdot y^b\cdot \sum_{i=0}^a C_a^i\cdot n^i\cdot(-y)^{a-i}\\&amp;=\sum_y\sum_{i=0}^a f_y\cdot C_a^i\cdot n^i\cdot(-1)^{a-i}\cdot y^{a+b-i}\\&amp;=\sum_{i=0}^a C_a^i\cdot n^i\cdot(-1)^{a-i}\cdot \sum_y f_y\cdot y^{a+b-i}\\\end{aligned}\]</span></p><p>然后发现后面那个 sigma 不太有办法求。一个比较优雅的方法是把 <span class="math inline">\(y^{a+b-i}\)</span> 直接作为系数而非下标塞到 <span class="math inline">\(f\)</span> 里去，即令 <span class="math inline">\(f_{i}\)</span> 表示 <span class="math inline">\(\forall \,y\)</span>，<span class="math inline">\(\sum y^i\)</span> 之和。</p><p>具体地，令 <span class="math inline">\(dp_{n,i,0/1}\)</span> 表示当前 DP 到第 <span class="math inline">\(n\)</span> 位，要求幂次为 <span class="math inline">\(i\)</span>，最后一位为 <span class="math inline">\(0/1\)</span> 的答案。则显然有 <span class="math inline">\(dp_{n,i,0}=dp_{n-1,i,0}+dp_{n-1,i,1}\)</span>。对于 <span class="math inline">\(dp_{n,i,1}\)</span>，因为此时 <span class="math inline">\(\forall\, k,k\gets k+1\)</span>，则 <span class="math inline">\((k+1)^i=\sum\limits_{j=0}^i C_i^j \cdot k^j\)</span> 即 <span class="math inline">\(dp_{n,i,1}=\sum\limits_{j=0}^i C_i^j\cdot dp_{n-1,j,0}\)</span>。发现 <span class="math inline">\(i,j\)</span> 的范围是 <span class="math inline">\(90\)</span>，很恐怖的事情是这是可以矩阵的。</p><details><p>就像我们都知道的那样，矩阵在加完之后再取模就会快很多……</p><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;int mod;int main() &#123;#ifdef ONLINE_JUDGE    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr), std::cout.tie(nullptr);#else    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);#endif    int n, a, b;    std::cin &gt;&gt; n &gt;&gt; a &gt;&gt; b &gt;&gt; mod;    std::vector&lt;std::vector&lt;long long&gt; &gt; C(a + b + 1, std::vector&lt;long long&gt;(a + b + 1));    for (int i = 0; i &lt;= a + b; ++i) &#123;        C[i][0] = 1ll;        for (int j = 1; j &lt;= i; ++j)            C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % mod;    &#125;    struct mat &#123;        int n, m;        std::vector&lt;std::vector&lt;long long&gt; &gt; a;        mat(int n, int m, bool flag = 0): n(n), m(m), a(n, std::vector&lt;long long&gt; (m)) &#123;            if (flag)                for (int i = 0; i &lt; n; ++i)                    a[i][i] = 1ll;            return;        &#125;        mat operator* (const mat &amp;q) const &#123;            mat res(n, q.m);            for (int i = 0; i &lt; n; ++i)                for (int k = 0; k &lt; q.m; ++k) &#123;                    for (int j = 0; j &lt; m; ++j)                        res.a[i][k] += a[i][j] * q.a[j][k];                    res.a[i][k] %= mod;                &#125;            return res;        &#125;        mat operator^ (int q) const &#123;            mat res(n, n, 1), x(*this);            for (; q; x = x * x, q &gt;&gt;= 1)                if (q &amp; 1)                    res = res * x;            return res;        &#125;    &#125; f(1, 2 * (a + b + 1)), op(2 * (a + b + 1), 2 * (a + b + 1));    auto fun = [&amp;](int i, int j) &#123;        return i + j * (a + b + 1);    &#125;;    f.a[0][fun(0, 0)] = 1ll;    for (int i = 0; i &lt;= a + b; ++i)        op.a[fun(i, 0)][fun(i, 0)] = op.a[fun(i, 1)][fun(i, 0)] = 1ll;    for (int i = 0; i &lt;= a + b; ++i)        for (int j = 0; j &lt;= i; ++j)            op.a[fun(j, 0)][fun(i, 1)] = C[i][j];    f = f * (op ^ n);    // for (int i = 0; i &lt;= n; ++i) &#123;    //     if (i)    //         f = f * op;    //     for (int j = 0; j &lt;= a + b; ++j)    //         printf(&quot;f[%d][%d] = %lld / %lld\n&quot;, i, j, f.a[0][fun(j, 0)], f.a[0][fun(j, 1)]);    // &#125;    auto res = 0ll;    for (int i = 0; i &lt;= a; ++i) &#123;        static auto p(1ll), k((a % 2) ? mod - 1ll : 1ll);        (res += C[a][i] * p % mod * k % mod * (f.a[0][fun(a + b - i, 0)] + f.a[0][fun(a + b - i, 1)]) % mod) %= mod;        (p *= n) %= mod, k = mod - k;    &#125;    std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;    return 0;&#125;</code></pre></details><hr /><h2 id="b---different-subsets-for-all-tuples">B - Different Subsets For All Tuples</h2><p><a href="https://www.luogu.com.cn/problem/CF660E" class="uri">https://www.luogu.com.cn/problem/CF660E</a></p><p>首先你可能需要知道，如果已知一个序列，如何得到答案？</p><p>令 <span class="math inline">\(f_i\)</span> 表示在 <span class="math inline">\(i\)</span> 处取一个子序列的末尾，枚举上一个元素 <span class="math inline">\(x\)</span>，找到 <span class="math inline">\(i\)</span> 之前最靠后的一个 <span class="math inline">\(a_j=x\)</span>，那么有 <span class="math inline">\(f_i=\sum f_j\)</span>，换言之需要保证 <span class="math inline">\((j,i)\)</span> 范围内没有 <span class="math inline">\(x\)</span> 出现。</p><p>此时序列未知，令 <span class="math inline">\(f_{i, x}\)</span> 表示在 <span class="math inline">\(i\)</span> 处取一个子序列末尾，且 <span class="math inline">\(i\)</span> 的值为 <span class="math inline">\(x\)</span>；按照贡献的视角来看待，每个可以和 <span class="math inline">\(i\)</span> 组成新子序列的方案可以带来 <span class="math inline">\(m^{i-1}\)</span> 的贡献（因为 <span class="math inline">\(a_i\)</span> 已经固定为 <span class="math inline">\(x\)</span>，其他位置可以任选），那么有 <span class="math inline">\(f_{i,x}=m^i\times \sum_{j&lt;i,y}f_{j,y}\times (m-1)^{i-j-1}\)</span>。</p><p>然后就惊讶地发现式子和 <span class="math inline">\(x\)</span> 这一维没有关系了。所以直接带上系数得到：</p><p><span class="math display">\[\begin{aligned}f_i&amp;=m^i\times \sum_{j&lt;i} f_j\times (m-1)^{i-j-1}\times m\\&amp;=m^i\times (m-1)^{i-1}\times m\cdot \sum_{j&lt;i} f_j\times (m-1)^{-j}\end{aligned}\]</span></p><p>前缀和优化一下就可以快速求了。最终的答案就是 <span class="math inline">\(res=m^n+\sum f_i\times (m-1)^{n-i}\)</span>。</p><details><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;const int mod = 1e9 + 7;int main() &#123;#ifdef ONLINE_JUDGE    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr), std::cout.tie(nullptr);#else    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);#endif    int n, m;    std::cin &gt;&gt; n &gt;&gt; m;    if (m == 1)        std::cout &lt;&lt; (n + 1) &lt;&lt; &#39;\n&#39;;    else &#123;        std::vector&lt;long long&gt; f(n + 1), s(n + 1), pm1(n + 1);        pm1[0] = 1ll;        for (int i = 1; i &lt;= n; ++i)            pm1[i] = pm1[i - 1] * (m - 1) % mod;        auto qkp = [](long long x, int y) &#123;            auto res(1ll);            for (; y; (x *= x) %= mod, y &gt;&gt;= 1)                if (y &amp; 1)                    (res *= x) %= mod;            return res;        &#125;;        auto res(qkp(m, n));        const auto invm = qkp(m - 1, mod - 2);        for (int i = 1; i &lt;= n; ++i) &#123;            static long long p(m), inv(invm);            f[i] = (p + pm1[i - 1] * m % mod * s[i - 1] % mod) % mod;            s[i] = (s[i - 1] + f[i] * inv % mod) % mod;            (res += f[i] * pm1[n - i] % mod) %= mod;            (p *= m) %= mod, (inv *= invm) %= mod;        &#125;        std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;     &#125;    return 0;&#125;</code></pre></details><hr /><h2 id="g---gardens">G - Gardens</h2><p><a href="https://atcoder.jp/contests/abc235/tasks/abc235_g" class="uri">https://atcoder.jp/contests/abc235/tasks/abc235_g</a></p><p>如果没有『每个人必须有一个元素』这个限制，就可以随便做了。现在加上了这个限制，很容易想到用没得到的人来容斥。钦定至少有 <span class="math inline">\(i\)</span> 个人没拿到，得到答案为 <span class="math inline">\(\sum\limits_{i=0}^n (-1)^i\cdot C_n^i\cdot \left(\sum\limits_{j=0}^a C_i^j\right)\cdot \left(\sum\limits_{j=0}^b C_i^j\right)\cdot \left(\sum\limits_{j=0}^c C_i^j\right)\)</span>。</p><p>怎么算 <span class="math inline">\(\sum\limits_{j=0}^a C_i^j\)</span> 呢？当 <span class="math inline">\(a&gt; i\)</span> 时，二项式是好求的；当 <span class="math inline">\(a\le i\)</span> 时呢？看到这个式子很容易带到杨辉三角里去，也就是求一行的前 <span class="math inline">\(a\)</span> 个数。注意到可以用上一行的前 <span class="math inline">\(a\)</span> 个数 <span class="math inline">\(O(1)\)</span> 得到（假设第 <span class="math inline">\(j-1\)</span> 行前 <span class="math inline">\(a\)</span> 个数之和为 <span class="math inline">\(f_a(j-1)\)</span>）：<span class="math inline">\(f_a(j)=f_a(j-1)\times 2-C_{j-1,a}\)</span>。<mark>你需要意识到，由于上一行也是答案中要求的，所以可以使用递推解决问题。<strong>在组合计数中，递推 / DP 无论是在化简式子还是求容斥 / 二项式反演里具体某一限制下的方案数都是很有用的，在需要优化复杂度时，可以从递推 / DP、恒等式、前缀和、预处理等方法入手考虑</strong></mark>。</p><details><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;const int mod = 998244353;int main() &#123;#ifdef ONLINE_JUDGE    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr), std::cout.tie(nullptr);#else    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);#endif    int n, a, b, c;    std::cin &gt;&gt; n &gt;&gt; a &gt;&gt; b &gt;&gt; c;    std::vector&lt;long long&gt; fac(n + 1), inv(n + 1), fa(n + 1), fb(n + 1), fc(n + 1), pow2(n + 1);    fac[0] = inv[0] = pow2[0] = 1ll;    for (int i = 1; i &lt;= n; ++i) &#123;        fac[i] = fac[i - 1] * i % mod;        pow2[i] = pow2[i - 1] * 2 % mod;    &#125;    auto qkp = [&amp;](long long x, int y) &#123;        auto res(1ll);        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)            if (y &amp; 1)                (res *= x) %= mod;        return res;    &#125;;    inv[n] = qkp(fac[n], mod - 2);    for (int i = n - 1; i; --i)        inv[i] = inv[i + 1] * (i + 1) % mod;    auto C = [&amp;](int n, int m) &#123;        return fac[n] * inv[n - m] % mod * inv[m] % mod;    &#125;;    for (int i = 0; i &lt;= a; ++i)        (fa[a] += C(a, i)) %= mod;    for (int i = a + 1; i &lt;= n; ++i)        fa[i] = (2 * fa[i - 1] % mod + mod - C(i - 1, a)) % mod;    for (int i = 0; i &lt;= b; ++i)        (fb[b] += C(b, i)) %= mod;    for (int i = b + 1; i &lt;= n; ++i)        fb[i] = (2 * fb[i - 1] % mod + mod - C(i - 1, b)) % mod;    for (int i = 0; i &lt;= c; ++i)        (fc[c] += C(c, i)) %= mod;    for (int i = c + 1; i &lt;= n; ++i)        fc[i] = (2 * fc[i - 1] % mod + mod - C(i - 1, c)) % mod;    auto res(0ll);    for (int i = n, p = 1; ~i; --i, p = mod - p)        (res += p * C(n, i) % mod * (i &gt;= a ? fa[i] : pow2[i]) % mod * (i &gt;= b ? fb[i] : pow2[i]) % mod * (i &gt;= c ? fc[i] : pow2[i]) % mod) %= mod;    std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;    return 0;&#125;</code></pre></details>]]></content>
      
      
      
        <tags>
            
            <tag> 容斥原理 </tag>
            
            <tag> 数学 </tag>
            
            <tag> 排列组合 </tag>
            
            <tag> 二项式定理 </tag>
            
            <tag> 二项式反演 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>杂题选谈</title>
      <link href="/20250404/"/>
      <url>/20250404/</url>
      
        <content type="html"><![CDATA[<p>NOI Linux 2.0，拼尽全力无法战胜。</p><span id="more"></span><p>比方说我试图对我一片狼藉的屏幕进行一个图的截，但是我并不知道 where the so-called <code>$PICTURE</code> is <img src="/em/kt.gif" /></p><hr /><p>这场有两个题都用到了 <mark>优先队列</mark> + <mark>最优答案扩展</mark> 的思路，可以记录一下。</p><hr /><h2 id="a.-序列加法机">A. 序列加法机</h2><p><a href="http://222.180.160.110:61235/contest/6174/problem/1" class="uri">http://222.180.160.110:61235/contest/6174/problem/1</a></p><p>转化题意可以发现，三个不下降的限制拼起来其实就是没有限制。若令 <span class="math inline">\(c_i=|a_i-b_i|\)</span>，则题意转化如下：</p><blockquote><p>给定 <span class="math inline">\(c_{1\sim n}\)</span>，定义一次操作为：</p><ul><li>选择一个 <span class="math inline">\(x&gt;0\)</span>，再选择 <span class="math inline">\(c_i\ge x\)</span>，令 <span class="math inline">\(c_i\gets c_i-x\)</span>，并花费 <span class="math inline">\(x^2\)</span> 的代价。</li></ul><p>现可进行不超过 <span class="math inline">\(m\)</span> 次操作，问将 <span class="math inline">\(c_i\)</span> 全部置为 <span class="math inline">\(0\)</span> 的最小代价。</p></blockquote><p>有一个比较显然的事情，如果给 <span class="math inline">\(c_i\)</span> 分配 <span class="math inline">\(k\)</span> 次操作机会，那么每次减去 <span class="math inline">\(\dfrac {c_i}k\)</span> 是最优的。具体地，令 <span class="math inline">\(p=\left\lfloor\dfrac {c_i}k\right\rfloor\)</span>，那么给 <span class="math inline">\(k\)</span> 个中的 <span class="math inline">\(c_i\bmod k\)</span> 分配 <span class="math inline">\(p+1\)</span>，给剩余的 <span class="math inline">\(k-c_i\bmod k\)</span> 分配 <span class="math inline">\(p\)</span> 即可。这个随便用反证什么的证一下即可。</p><p>但是我们怎么知道应该给每个 <span class="math inline">\(c_i\)</span> 分配多少次操作次数呢？这里有个 trick：初始先给每个 <span class="math inline">\(c_i\)</span> 分配一次次数，<mark>对于每个 <span class="math inline">\(c_i\)</span>，记录给其多分配一次后能减少的代价，全部丢进优先队列里，将最优的拿出来之后，记录再给其多分配一次后能减少的代价，再丢进去</mark>。能这样做的根本原因在于：</p><ol type="1"><li>每个元素的每一次扩展代价相同。</li><li>对于同一个元素，丢到优先队列里的值是递减的（即无后效性，可以贪心）。</li></ol><details><p>有人对着对的代码调了半个小时，是谁呢 <img src="/em/kt.gif" /></p><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;const int mod = 998244353;int main() &#123;#ifdef ONLINE_JUDGE    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr), std::cout.tie(nullptr);    std::freopen(&quot;seq.in&quot;, &quot;r&quot;, stdin);    std::freopen(&quot;seq.out&quot;, &quot;w&quot;, stdout);#else    std::freopen(&quot;ex_seq2.in&quot;, &quot;r&quot;, stdin);    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);#endif    int n, m;    std::cin &gt;&gt; n &gt;&gt; m;    std::vector&lt;long long&gt; c(n + 1);    for (int i = 1; i &lt;= n; ++i)        std::cin &gt;&gt; c[i];    struct _ &#123;        int k;        long long org, d;        bool operator&lt; (const _ &amp;q) const &#123;            return d &lt; q.d;         &#125;    &#125;;    std::priority_queue&lt;_&gt; q;    long long res = 0ll;    auto calc = [&amp;](long long x, int k) &#123;        auto p = x / k;        return (x % k) * (p + 1) * (p + 1) + (k - x % k) * p * p;    &#125;;    for (int i = 1, x; i &lt;= n; ++i) &#123;        std::cin &gt;&gt; x;        c[i] = std::abs(c[i] - x);        if (c[i]) &#123;            (res += calc(c[i], 1) % mod) %= mod;            q.push(&#123; 2, c[i], calc(c[i], 1) - calc(c[i], 2) &#125;);        &#125;    &#125;    // printf(&quot;res = %lld\n&quot;, res);    if ((int)q.size() &gt; m)        std::cout &lt;&lt; -1 &lt;&lt; &#39;\n&#39;;    else &#123;        m -= (int)q.size();        for (; m--; ) &#123;            auto [k, org, d] = q.top();            q.pop();            // printf(&quot;org = %lld, k = %d, d = %lld\n&quot;, org, k, d);            (res += mod - d % mod) %= mod;            q.push(&#123; k + 1, org, calc(org, k) - calc(org, k + 1) &#125;);        &#125;        std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;    &#125;    return 0;&#125;</code></pre></details><hr /><h2 id="b.-摸鱼军训">B. 摸鱼军训</h2><p><a href="http://222.180.160.110:61235/contest/6174/problem/2" class="uri">http://222.180.160.110:61235/contest/6174/problem/2</a></p><blockquote><p>定义一次冒泡排序为：</p><pre class="cpp"><code>for (int i = 1; i &lt; n; ++i)    if (a[i] &gt; a[i + 1])        std::swap(a[i], a[i + 1]);</code></pre><p>现给定一个排列和 <span class="math inline">\(m\)</span> 次询问，问第 <span class="math inline">\(k\)</span> 轮冒泡排序后元素 <span class="math inline">\(x\)</span> 的位置。</p></blockquote><p>发现一个元素移动的原因有两种：</p><ol type="1"><li>前面有个比它大的元素「冒泡」到它后面去了，本轮该元素向前移动恰好一步。</li><li>前面没有比它更大的元素，轮到它来向后面「冒泡」了。找到具体的位置是不容易的，但我们发现每次 <span class="math inline">\(i\)</span> 向右移动一步，都一定会有一个比 <span class="math inline">\(i\)</span> 更小的元素被它交换到 <span class="math inline">\(i\)</span> 左边。找到有多少个在 <span class="math inline">\(i\)</span> 右边且比 <span class="math inline">\(i\)</span> 小的元素到了 <span class="math inline">\(i\)</span> 左边就可以得到这一种情况下 <span class="math inline">\(i\)</span> 的位置。</li></ol><p>容易发现，只要前面存在比它大的元素，那么第一条始终成立。树状数组统计 <span class="math inline">\(f_i\)</span> 为元素 <span class="math inline">\(i\)</span> 前比它大的元素个数，对于询问 <span class="math inline">\((k,i)\)</span>，若 <span class="math inline">\(k\le f_i\)</span>，那么答案即为 <span class="math inline">\(pos_i-k\)</span>。</p><p>第 <span class="math inline">\(f_i+1\)</span> 轮，<span class="math inline">\(i\)</span> 向后「冒泡」，碰到一个比它更大的元素 <span class="math inline">\(j\)</span> 即停止，此时 <span class="math inline">\(j\)</span> 接替 <span class="math inline">\(i\)</span> 向后「冒泡」，直到碰到一个 <span class="math inline">\(j&#39;&gt;j\)</span> 为止，以此类推。</p><p>如何将 <span class="math inline">\(k\)</span> 轮后 <span class="math inline">\(i\)</span> 停下的位置对应到原数组上呢？我们发现每一轮 <span class="math inline">\(i\)</span> 跨越的元素一定是比 <span class="math inline">\(i\)</span> 小的可空极长段，手玩可以发现段的数量不会因为 <span class="math inline">\(i\)</span> 之后任何元素的移动而改变，故找到 <span class="math inline">\(i\)</span> 后第 <span class="math inline">\(k\)</span> 个比 <span class="math inline">\(i\)</span> 大的元素，中间比 <span class="math inline">\(i\)</span> 小的元素个数就是 <span class="math inline">\(i\)</span> 的右移步数。</p><details><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;int main() &#123;    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr), std::cout.tie(nullptr);    std::freopen(&quot;bubble.in&quot;, &quot;r&quot;, stdin);    std::freopen(&quot;bubble.out&quot;, &quot;w&quot;, stdout);    int n, m;    std::cin &gt;&gt; n;    std::vector&lt;int&gt; a(n + 1), bit(n + 1), p(n + 1), f(n + 1), bit1(n + 1);    auto lowbit = [&amp;](int x) &#123;        return x &amp; -x;    &#125;;    auto add = [&amp;](std::vector&lt;int&gt; &amp;bit, int x, int v) &#123;        for (; x &lt;= n; x += lowbit(x))            bit[x] += v;        return;    &#125;;    auto qry = [&amp;](std::vector&lt;int&gt; &amp;bit, int x) &#123;        int res = 0;        for (; x; x -= lowbit(x))            res += bit[x];        return res;    &#125;;    auto ask = [&amp;](std::vector&lt;int&gt; &amp;bit, int l, int r) &#123;        if (l &gt; n || r &lt; 1)            return 0;        return qry(bit, r) - qry(bit, l - 1);    &#125;;    for (int i = 1; i &lt;= n; ++i) &#123;        std::cin &gt;&gt; a[i], p[a[i]] = i;        f[a[i]] = ask(bit, a[i] + 1, n), add(bit, a[i], 1);    &#125;    struct _ &#123; int k, id; &#125;;    std::vector&lt;std::vector&lt;_&gt; &gt; t(n + 1);    std::cin &gt;&gt; m;    std::vector&lt;int&gt; res(m + 1);    for (int i = 1, x, k; i &lt;= m; ++i) &#123;        std::cin &gt;&gt; k &gt;&gt; x;        t[x].push_back(&#123; k, i &#125;);    &#125;    for (int i = 1; i &lt;= n; ++i) &#123;        add(bit, p[i], -1);        for (auto [k, id] : t[i])            if (k &lt;= f[i])                res[id] = p[i] - k;            else &#123;                int now = n;                for (int l = p[i] + 1, r = n, mid; l &lt;= r; ) &#123;                    mid = (l + r) &gt;&gt; 1;                    if (ask(bit, p[i] + 1, mid) &gt;= k - f[i])                        r = mid - 1, now = mid;                    else                        l = mid + 1;                &#125;                // printf(&quot;%d: now = %d\n&quot;, i, now);                res[id] = p[i] - f[i] + ask(bit1, p[i] + 1, now);            &#125;        add(bit1, p[i], 1);    &#125;    for (int i = 1; i &lt;= m; ++i)        std::cout &lt;&lt; res[i] &lt;&lt; &#39;\n&#39;;    return 0;&#125;</code></pre></details><hr /><h2 id="c0.-超级钢琴">C0. 超级钢琴</h2><p><a href="https://www.luogu.com.cn/problem/P2048" class="uri">https://www.luogu.com.cn/problem/P2048</a></p><p>首先做前缀和，容易想到枚举右端点，那么左端点就是一段连续的区间。显然在这里最优选择是选择左端点中 <span class="math inline">\(s\)</span> 最小的一个。</p><p>怎么求前 <span class="math inline">\(k\)</span> 大呢？这里有一个很固定的 trick：把每个右端点及其对应的左端点区间丢到优先队列里，按照最优解（用 ST 表找一下即可）从优到劣排序。</p><p><mark>每次取出最优解 <span class="math inline">\([l_1, l_2], r\)</span>，假设最优决策为 <span class="math inline">\(x\in [l_1, l_2]\)</span>，那么把 <span class="math inline">\([l_1, x), r\)</span> 和 <span class="math inline">\((x, l_2], r\)</span> 分别丢到优先队列里去</mark>。这个做法成立的根本原因也是：</p><ol type="1"><li>任何一个元素都可以贡献一次答案。</li><li>对于同一个 <span class="math inline">\(r\)</span>，随着拆分次数的增加，最优解逐渐变劣（无后效性，可贪心）。</li></ol><details><pre class="cpp language-cpp" data-line="17"><code class="cpp langauage-cpp">#include &lt;bits/stdc++.h&gt;int main() &#123;#ifdef ONLINE_JUDGE    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr), std::cout.tie(nullptr);#else    std::freopen(".in", "r", stdin);    std::freopen(".out", "w", stdout);#endif    int n, k, l, r;    std::cin >> n >> k >> l >> r;    std::vector&lt;long long> a(n + 1);    std::vector&lt;std::vector&lt;long long> > st(21, std::vector&lt;long long> (n + 1));    for (int i = 1; i <= n; ++i)        std::cin >> a[i], st[0][i] = i;    std::partial_sum(a.begin() + 1, a.end(), a.begin() + 1);    for (int j = 1; (1 << j) <= n + 1; ++j) // 一个优秀的笑话是，你的 ST 表需要从 0 开始。而长度自然也应该为 n + 1。        for (int i = 0; i + (1 << j) - 1 <= n; ++i)            st[j][i] = (a[st[j - 1][i]] <= a[st[j - 1][i + (1 << (j - 1))]] ? st[j - 1][i] : st[j - 1][i + (1 << (j - 1))]);    auto ask = [&](int l, int r) &#123;        int k = std::__lg(r - l + 1);        return a[st[k][l]] <= a[st[k][r - (1 << k) + 1]] ? st[k][l] : st[k][r - (1 << k) + 1];    &#125;;    struct _ &#123;        int l1, l2, r, x;        long long v;        bool operator< (const _ &q) const &#123;            return v < q.v;        &#125;    &#125;;    std::priority_queue<_> q;    for (int i = l; i <= n; ++i) &#123;        _ t;        t.l1 = std::max(i - r, 0), t.l2 = i - l, t.r = i, t.x = ask(t.l1, t.l2), t.v = a[i] - a[t.x];        q.push(t);    &#125;    long long res = 0ll;    for (int to; k--; ) &#123;        auto [l1, l2, r, x, v] = q.top();        q.pop();        res += v;        if (x != l1) &#123;            to = ask(l1, x - 1);            q.push(&#123; l1, x - 1, r, to, a[r] - a[to] &#125;);        &#125;        if (x != l2) &#123;            to = ask(x + 1, l2);            q.push(&#123; x + 1, l2, r, to, a[r] - a[to] &#125;);        &#125;    &#125;    std::cout << res << '\n';    return 0;&#125;</code></pre></details><hr /><h2 id="c1.-皮卡丘">C1. 皮卡丘</h2><p><a href="http://222.180.160.110:61235/contest/6174/problem/3" class="uri">http://222.180.160.110:61235/contest/6174/problem/3</a></p><blockquote><p>给定 <span class="math inline">\(a_{1\sim n}\)</span> 和 <span class="math inline">\(m\)</span> 个询问，每次问 <span class="math inline">\([l, r]\)</span> 中前 <span class="math inline">\(k\)</span> 大 <span class="math inline">\(a_l-a_r\)</span> 的和。<span class="math inline">\(\sum k\le 3\times 10^5\)</span>。</p></blockquote><p>我们发现不能直接按照上一题的方法来做——每次询问都把 <span class="math inline">\(len\)</span> 个元素丢进优先队列是不现实的。但我们似乎忽略了什么——这次的初始最优解是否可以直接在 <span class="math inline">\([l,r]\)</span> 上全局求解？</p><p>区间修改操作就是在明示线段树。显然我们可以差分过后线段树上求解最大子段和——不差分也可以照样维护答案，方法差不多。假设现在求得的最优解为 <span class="math inline">\((x, y)\)</span>。</p><p>但此时我们没有一个端点是固定的！应该怎样拆分呢？这里又要用到另一个经典的 trick——抽象一个矩阵 <span class="math inline">\(b_{i,j}=a_i-a_j\)</span>，那么对于一次询问，可用的 <span class="math inline">\(b\)</span> 构成一个三角形：</p><p><img src="1.png" /></p><p>这里需要注意一个点，我们之所以可以通过最大子段和求得最优解是因为矩阵的行号范围和列号范围是一致的（记为情况 1）。除此之外，除了行号和列号完全相离（即 <span class="math inline">\(l_2&lt;r_1\)</span>，记为情况 2） 时可以直接用 <span class="math inline">\(l_{\max}-r_{\min}\)</span> 求解，其他情况都无法简单得到答案。</p><p>也就是说，我们的拆分方式要尽可能地贴近上面两种可求解的情况。幸运地是，直觉地划分可以比较轻松地在初始状态下得到一种可能的方式：</p><p><img src="2.png" /></p><p>容易注意到初始状态属于情况 1，可以按照图所示，按照行号与 <span class="math inline">\(x\)</span> 的大小关系分类，得到：</p><ol type="1"><li>行 <span class="math inline">\(&lt;x\)</span>，列 <span class="math inline">\(&lt;x\)</span>；</li><li>行 <span class="math inline">\(&lt;x\)</span>，列 <span class="math inline">\(\ge x\)</span>；</li><li>行 <span class="math inline">\(=x\)</span>，列 <span class="math inline">\(=x\)</span>；</li><li>行 <span class="math inline">\(=x\)</span>，列 <span class="math inline">\(\in (x,y)\)</span>；</li><li>行 <span class="math inline">\(=x\)</span>，列 <span class="math inline">\(&gt;y\)</span>；</li><li>行 <span class="math inline">\(&gt;x\)</span>，列 <span class="math inline">\(&gt;x\)</span>。</li></ol><p>几个 part。</p><p>如果我们要对情况 2 进行划分呢？这也是轻松的，假设当前图形满足行： <span class="math inline">\([l_1, l_2]\)</span>，列：<span class="math inline">\([r_1, r_2]\)</span>（显然这是个完整的矩形），且最优解 <span class="math inline">\((x, y)\)</span>。容易发现任意行、列一定相离，故根据 <span class="math inline">\((x, y)\)</span> 划分即可：</p><p><img src="3.png" /></p><p>也即以下几个 part：</p><ol type="1"><li>行 <span class="math inline">\(&lt;x\)</span>；</li><li>行 <span class="math inline">\(=x\)</span>，列 <span class="math inline">\(&lt;y\)</span>；</li><li>行 <span class="math inline">\(=x\)</span>，列 <span class="math inline">\(&gt;y\)</span>；</li><li>行 <span class="math inline">\(&gt;x\)</span>。</li></ol><p>复杂度 <span class="math inline">\(O(\sum k\log)\)</span>。注意到线段树的 <span class="math inline">\(\log\)</span> 和优先队列的 <span class="math inline">\(\log\)</span> 并不会叠起来。</p><details><p>意外的很难写 <img src="/em/qd.gif" /></p><p>主要是线段树写起来有点答辩了 <img src="/em/kt.gif" /></p><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;const int maxn = 1e5 + 5;struct __ &#123;    int l, r;    int i0, i1, s0, s1;    long long u, d, u0, u1;    __ operator+ (const __ &amp;q) const &#123;        __ res;        res.l = l, res.r = q.r, res.d = 0ll;        res.u = std::max(&#123; u, q.u, u1 - q.u0 &#125;);        if (res.u == u)            res.s0 = s0, res.s1 = s1;        else if (res.u == q.u)            res.s0 = q.s0, res.s1 = q.s1;        else            res.s1 = i1, res.s0 = q.i0;        if (u0 &lt; q.u0)            res.u0 = u0, res.i0 = i0;        else            res.u0 = q.u0, res.i0 = q.i0;        if (u1 &gt; q.u1)            res.u1 = u1, res.i1 = i1;        else            res.u1 = q.u1, res.i1 = q.i1;        return res;    &#125;&#125; t[maxn &lt;&lt; 2];long long a[maxn];#define lt (p &lt;&lt; 1)#define rt (lt | 1)void pushdown(int p) &#123;    if (t[p].d) &#123;        t[lt].d += t[p].d, t[rt].d += t[p].d;        t[lt].u0 += t[p].d, t[lt].u1 += t[p].d;        t[rt].u0 += t[p].d, t[rt].u1 += t[p].d;        t[p].d = 0;    &#125;    return;&#125;void pushup(int p) &#123;    t[p] = t[lt] + t[rt];    return;&#125;void bld(int p, int l, int r) &#123;    t[p].l = l, t[p].r = r;    if (l == r) &#123;        t[p].i0 = t[p].i1 = t[p].s0 = t[p].s1 = l;        t[p].u0 = t[p].u1 = a[l];        return;    &#125;    int mid = (l + r) &gt;&gt; 1;    bld(lt, l, mid), bld(rt, mid + 1, r);    pushup(p);    return;&#125;void add(int p, int l, int r, long long v) &#123;    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r) &#123;        t[p].u0 += v, t[p].u1 += v, t[p].d += v;        return;    &#125;    pushdown(p);    int mid = (t[p].l + t[p].r) &gt;&gt; 1;    if (l &lt;= mid)        add(lt, l, r, v);    if (r &gt; mid)        add(rt, l, r, v);    pushup(p);    return;&#125;auto ask(int p, int l, int r) &#123;    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r)        return t[p];    pushdown(p);    int mid = (t[p].l + t[p].r) &gt;&gt; 1;    if (r &lt;= mid)        return ask(lt, l, r);    if (l &gt; mid)        return ask(rt, l, r);    return ask(lt, l, r) + ask(rt, l, r);&#125;int main() &#123;#ifdef ONLINE_JUDGE    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr), std::cout.tie(nullptr);    std::freopen(&quot;pi.in&quot;, &quot;r&quot;, stdin);    std::freopen(&quot;pi.out&quot;, &quot;w&quot;, stdout);#else    std::freopen(&quot;ex_pi2.in&quot;, &quot;r&quot;, stdin);    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);#endif    int n, m;    std::cin &gt;&gt; n &gt;&gt; m;    for (int i = 1; i &lt;= n; ++i)        std::cin &gt;&gt; a[i];    bld(1, 1, n);    for (int op; m--; ) &#123;        std::cin &gt;&gt; op;        if (op == 1) &#123;            int l, r, x;            std::cin &gt;&gt; l &gt;&gt; r &gt;&gt; x;            add(1, l, r, x);        &#125;        else &#123;            int l, r, k;            std::cin &gt;&gt; l &gt;&gt; r &gt;&gt; k;            struct _ &#123;                int ty, l1, l2, r1, r2, x, y;                long long v;                bool operator&lt; (const _ &amp;q) const &#123;                    return v &lt; q.v;                &#125;            &#125;;            long long res = 0ll;            std::priority_queue&lt;_&gt; q;            auto calc = [&amp;](int ty, int l1, int l2, int r1, int r2) &#123;                if (l1 &lt;= l2 &amp;&amp; r1 &lt;= r2) &#123;                    if (ty == 1) &#123;                        auto ts(ask(1, l1, l2));                        q.push(&#123; 1, l1, l2, r1, r2, ts.s1, ts.s0, ts.u &#125;);                    &#125;                    else &#123;                        auto ls(ask(1, l1, l2)), rs(ask(1, r1, r2));                        q.push(&#123; 2, l1, l2, r1, r2, ls.i1, rs.i0, ls.u1 - rs.u0 &#125;);                    &#125;                &#125;                return;            &#125;;            calc(1, l, r, l, r);            for (; k--; ) &#123;                auto [ty, l1, l2, r1, r2, x, y, v] = q.top();                res += v;                q.pop();                if (ty == 1) &#123;                    calc(1, l1, x - 1, r1, x - 1);                    calc(2, l1, x - 1, x, r2);                    if (x != y)                        calc(1, x, x, x, x);                    calc(2, x, x, x + 1, y - 1);                    calc(2, x, x, y + 1, r2);                    calc(1, x + 1, l2, x + 1, r2);                &#125;                else &#123;                    calc(2, l1, x - 1, r1, r2);                    calc(2, x, x, r1, y - 1);                    calc(2, x, x, y + 1, r2);                    calc(2, x + 1, l2, r1, r2);                &#125;            &#125;            std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;        &#125;    &#125;    return 0;&#125;</code></pre></details><hr /><h2 id="d.-银行的崛起">D. 银行的崛起</h2><p><a href="http://222.180.160.110:61235/contest/6174/problem/4" class="uri">http://222.180.160.110:61235/contest/6174/problem/4</a></p><p>原题：<a href="https://www.codechef.com/problems/CTREE?tab=statement">CodeChef CTREE - Chef and Chefcoin</a>。</p><p>假设只需要一个关键点，那么容易想到换根 DP 的做法。但仅凭这个比较 naive 的思路是无法靠近正解的。找题解的时候看到一个惊为天人的式子：<mark><span class="math inline">\(res=\sum\limits_{(u, v): w} f(v)=w\cdot \min(s_v,n-s_v)\)</span>，其中 <span class="math inline">\(s_v\)</span> 表示 <span class="math inline">\(v\)</span> 的 size</mark>。</p><p>乍一看是在讨论关键点要选在 <span class="math inline">\(v\)</span> 外部还是内部，但是 <span class="math inline">\(\min\)</span> 的含义很奇怪——假如有多个点都觉得应该往自己内部走呢？考虑如下普适场景：</p><p><img src="4.png" /></p><p>假如 <span class="math inline">\(a\)</span> 和 <span class="math inline">\(c\)</span> 都觉得应该往自己内部走，就会有 <span class="math inline">\(\begin{cases}a&gt;b+c\\c&gt;a+b\end{cases}\Rightarrow 0&gt;2\times b\)</span>，由此就反证了。</p><p>那么显然 <span class="math inline">\(f(v)=w\cdot s_v\iff s_v\le \dfrac n2\)</span>，转化成带权重心问题，可以 <span class="math inline">\(O(n)\)</span> 一次 DFS 解决。那扩展到两个呢？手玩发现存在一条边作为两个选择倾向的点的分界，不会被任何一方经过（显然），枚举这条分割线切断就可以得到两个子树；在子树上分别作一次一个关键点的做法，加起来就是这条边的答案。</p><p>显然这是 <span class="math inline">\(O(n^2)\)</span> 的，需要优化。能够感受到枚举边的过程不太能被优化，考虑优化求解上面式子的过程。容易想到换根，记 <span class="math inline">\(s&#39;\)</span> 为当前版本时刻变化的 size，<span class="math inline">\(s\)</span> 为初始值，那么有：</p><ul><li><span class="math inline">\(u\)</span> 侧，对于 <span class="math inline">\(u\)</span> 的所有祖先 <span class="math inline">\(\{fa\}\)</span>，<span class="math inline">\(s&#39;_{fa}=s_{fa}-s_v\)</span>，<span class="math inline">\(n&#39;=n-s_v\)</span>。</li><li><span class="math inline">\(v\)</span> 侧，所有点 <span class="math inline">\(\{son\}\)</span> 有 <span class="math inline">\(s&#39;_{son}=s_{son}\)</span>，<span class="math inline">\(n&#39;=s_v\)</span>。</li></ul><p>我们需要维护所有 <span class="math inline">\(s&#39;\)</span> 和 <span class="math inline">\(\dfrac {n&#39;}2\)</span> 的大小关系——发现这是一个类似二维偏序的问题，即求：</p><ol type="1"><li>DFN 在 <span class="math inline">\(v\)</span> 子树范围内，且 <span class="math inline">\(s\le \dfrac {s_v}2\)</span> 的权值。</li><li>DFN 在 <span class="math inline">\(v\)</span> 之前 / 之后，且 <span class="math inline">\(s\le \dfrac {n-s_v}2\)</span> 的权值。</li></ol><p>记录询问的 DFN 区间，离线（？）下来按照 <span class="math inline">\(n&#39;\)</span> 排序，随便用个 DFN 上的 DS 统计一下即可。但 <span class="math inline">\(u\)</span> 侧的 <span class="math inline">\(s&#39;_{fa}\)</span> 会发生变化，没办法离线处理，考虑<mark>费用提前计算消除误差——找到比 <span class="math inline">\(\dfrac {n-s_v}2\)</span> 大，但减去 <span class="math inline">\(s_v\)</span> 后比之小的 <span class="math inline">\(fa\)</span> 提前处理</mark>。</p><p><mark>发现由于 <span class="math inline">\(s\)</span> 随着 <span class="math inline">\(fa\)</span> 往上是单调递增的，满足这个条件的 <span class="math inline">\(fa\)</span> 是连续的。</mark>用树上倍增框出上下端点 <span class="math inline">\((fa_p\to fa_q]\)</span> 进行费用提前计算。那么就可以 <span class="math inline">\(O(n\log)\)</span> 的解决问题了。</p><details><p><summary>具体地，如何提前计算？</summary></p><p>记 <span class="math inline">\(diw_x\)</span> 为从 <span class="math inline">\(1\)</span> 到 <span class="math inline">\(x\)</span> 的路径上所有点 <span class="math inline">\(s\cdot w\)</span> 之和。</p><p>那么有：</p><table><colgroup><col style="width: 25%" /><col style="width: 25%" /><col style="width: 25%" /><col style="width: 25%" /></colgroup><thead><tr class="header"><th style="text-align: center;">项</th><th style="text-align: center;">真实值</th><th style="text-align: center;">计算值</th><th style="text-align: center;"><span class="math inline">\(\sum\Delta\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><span class="math inline">\(x\notin\{fa\}\land x\notin\{son\}\)</span></td><td style="text-align: center;"><span class="math inline">\(w_x\cdot \min(s_x,n&#39;-s_x)\)</span></td><td style="text-align: center;"><span class="math inline">\(w_x\cdot \min(s_x,n&#39;-s_x)\)</span></td><td style="text-align: center;"><span class="math inline">\(0\)</span></td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(x\in[1\to fa_p]\)</span></td><td style="text-align: center;"><span class="math inline">\(w_x\cdot (s_x - s_v)\)</span></td><td style="text-align: center;"><span class="math inline">\(w_x\cdot s_x\)</span></td><td style="text-align: center;"><span class="math inline">\(-dis_p\times s_v\)</span></td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(x\in (fa_p\to fa_q]\)</span></td><td style="text-align: center;"><span class="math inline">\(w_x\cdot (n-s_x)\)</span></td><td style="text-align: center;"><span class="math inline">\(w_x\cdot s_x\)</span></td><td style="text-align: center;"><span class="math inline">\(n\times(dis_q-dis_p)-2\times (diw_q - diw_p)\)</span></td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(x\in(fa_q,v)\)</span></td><td style="text-align: center;"><span class="math inline">\(w_x\cdot (n-s_x)\)</span></td><td style="text-align: center;"><span class="math inline">\(w_x\cdot (n-s_x-s_v)\)</span></td><td style="text-align: center;"><span class="math inline">\(s_v\cdot (dis_u-dis_q)\)</span></td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(x\in \{son\}\)</span></td><td style="text-align: center;"><span class="math inline">\(w_x\cdot \min(s_x,n&#39;-s_x)\)</span></td><td style="text-align: center;"><span class="math inline">\(w_x\cdot \min(s_x,n&#39;-s_x)\)</span></td><td style="text-align: center;"><span class="math inline">\(0\)</span></td></tr></tbody></table><p>即需将答案 <strong>减去</strong> <span class="math inline">\(n\times(dis_q-dis_p)-2\times (diw_q - diw_p)+s_v\cdot (dis_u-dis_q-dis_p)\)</span>。</p></details><details><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;int main() &#123;    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr), std::cout.tie(nullptr);#ifdef ONLINE_JUDGE    std::freopen(&quot;banking.in&quot;, &quot;r&quot;, stdin);    std::freopen(&quot;banking.out&quot;, &quot;w&quot;, stdout);#else    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);#endif    int T;    for (std::cin &gt;&gt; T; T--; ) &#123;        int n;        std::cin &gt;&gt; n;        std::vector&lt;long long&gt; a(n + 1);        long long sw = 0ll;        for (int i = 1; i &lt;= n; ++i)            std::cin &gt;&gt; a[i], sw += a[i];        std::vector&lt;std::vector&lt;std::pair&lt;int, long long&gt; &gt; &gt; g(n + 1);        for (int i = 1, x, y, w; i &lt; n; ++i) &#123;            std::cin &gt;&gt; x &gt;&gt; y &gt;&gt; w;            g[x].emplace_back(y, w), g[y].emplace_back(x, w);        &#125;        struct _ &#123; int l, r, id; long long v; &#125;;        int now = 0;        std::vector&lt;_&gt; q;        std::vector&lt;int&gt; dfn(n + 1), rfn(n + 1);        std::vector&lt;std::vector&lt;int&gt; &gt; f(n + 1, std::vector&lt;int&gt; (21));        std::vector&lt;long long&gt; dis(n + 1), diw(n + 1), w(n + 1), res(n + 1), s(n + 1);        std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int fa) &#123; // 前置工作            dfn[x] = ++now, s[x] = a[x];            for (auto [i, tw] : g[x])                if (i != fa) &#123;                    w[i] = tw;                    f[i][0] = x;                    for (int j = 1; j &lt;= 20; ++j)                        f[i][j] = f[f[i][j - 1]][j - 1];                    DFS(i, x);                    s[x] += s[i];                &#125;            rfn[x] = now;            return;        &#125;;        DFS(1, -1);        DFS = [&amp;](int x, int fa) &#123;            for (auto [i, tw] : g[x])                if (i != fa) &#123;                    dis[i] = dis[x] + tw;                    diw[i] = diw[x] + tw * s[i];                    q.push_back(&#123; dfn[i], rfn[i], i, s[i] &#125;);                    q.push_back(&#123; 1, dfn[i] - 1, i, sw - s[i] &#125;);                    q.push_back(&#123; rfn[i] + 1, n, i, sw - s[i] &#125;);                    int p, q;                    long long t = (sw - s[i]) / 2;                    &#123;   // 找上端点（开的）                        p = i;                        for (int j = 20; ~j; --j)                            if (f[p][j] &amp;&amp; s[f[p][j]] - s[i] &lt;= t)                                p = f[p][j];                        p = f[p][0];                    &#125;                    &#123;   // 找下端点（闭的）                        q = i;                        for (int j = 20; ~j; --j)                            if (f[q][j] &amp;&amp; s[f[q][j]] &lt;= t)                                q = f[q][j];                        q = f[q][0];                    &#125;                    res[i] -= sw * (dis[q] - dis[p]) - 2 * (diw[q] - diw[p]) + (dis[x] - dis[p] - dis[q]) * s[i];                    DFS(i, x);                &#125;            return;        &#125;;        DFS(1, -1);        std::vector&lt;int&gt; id(n + 1);        std::iota(id.begin() + 1, id.end(), 1);        std::sort(id.begin() + 1, id.end(), [&amp;](int x, int y) &#123; return s[x] &lt; s[y]; &#125;);        std::sort(q.begin(), q.end(), [&amp;](_ x, _ y) &#123; return x.v &lt; y.v; &#125;);        std::vector&lt;std::pair&lt;long long, long long&gt; &gt; bit(n + 1);        auto lowbit = [&amp;](int x) &#123; return x &amp; -x; &#125;;        auto add = [&amp;](int x, std::pair&lt;long long, long long&gt; v) &#123;            for (; x &lt;= n; x += lowbit(x))                bit[x].first += v.first, bit[x].second += v.second;            return;        &#125;;        auto ask = [&amp;](int x) &#123;            std::pair&lt;long long, long long&gt; res;            for (; x; x -= lowbit(x))                res.first += bit[x].first, res.second += bit[x].second;            return res;        &#125;;        auto j = ++id.begin();        for (auto &amp;[l, r, x, v] : q) &#123;            for (; j != id.end() &amp;&amp; s[*j] &lt;= v / 2; ++j)                add(dfn[*j], &#123; w[*j], s[*j] * w[*j] &#125;);            auto ls(ask(l - 1)), rs(ask(r));            rs.first -= ls.first, rs.second -= ls.second;            res[x] += rs.second;        &#125;        bit.assign(n + 1, &#123; 0ll, 0ll &#125;);        std::reverse(q.begin(), q.end());        std::reverse(id.begin(), id.end());        j = ++id.begin();        for (auto &amp;[l, r, x, v] : q) &#123;            for (; j != id.end() &amp;&amp; s[*j] &gt; v / 2; ++j)                add(dfn[*j], &#123; w[*j], s[*j] * w[*j] &#125;);            auto ls(ask(l - 1)), rs(ask(r));            rs.first -= ls.first, rs.second -= ls.second;            res[x] += rs.first * v - rs.second;        &#125;        std::cout &lt;&lt; *std::min_element(res.begin() + 2, res.end()) &lt;&lt; &#39;\n&#39;;    &#125;    return 0;&#125;</code></pre></details>]]></content>
      
      
      
        <tags>
            
            <tag> 堆 </tag>
            
            <tag> 树的重心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习笔记：FWT</title>
      <link href="/20250329/"/>
      <url>/20250329/</url>
      
        <content type="html"><![CDATA[<p>活了哥们，复活了。</p><span id="more"></span><hr /><p>考虑以下问题：</p><ul><li>对于 <span class="math inline">\(\forall \,i\in U\)</span>，求 <span class="math inline">\(c_i=\sum\limits_{j\cup k=i}a_j\cdot b_k\)</span>。</li></ul><p>当然这里可以把集合看成二进制状态，那么取并集就是按位或了。</p><p>咕咕咕</p><hr /><h2 id="emiya-家明天的饭">Emiya 家明天的饭</h2><p><a href="https://www.luogu.com.cn/problem/P10242" class="uri">https://www.luogu.com.cn/problem/P10242</a></p><p>冷知识：<em>Emiya 家明天的饭</em> 和 <em>Emiya 家今天的饭</em> 拥有相同的难度评级 <img src="/em/kt.gif" alt="磕头" /></p><p>考虑暴力的做法，如果我们先钦定必须到达的人（这是 <span class="math inline">\(O(2^n)\)</span> 的），再花费 <span class="math inline">\(O(nm)\)</span> 的时间依次判定每道菜是否可以被选择，就可以 解决问题。但发现时间是不能承受的，这里我们选择优化 <span class="math inline">\(O(nm)\)</span> 的判定。</p><p>现在已知人员集合 <span class="math inline">\(s\)</span>，对于一道菜 <span class="math inline">\(i\)</span>，设它适配的人员集合为 <span class="math inline">\(T_i\)</span>，那么有 <span class="math inline">\(s\subseteq T_i\)</span>。所求即为 <span class="math inline">\(\max\limits_s\{\sum\limits_{T_i\supseteq s}\sum\limits_{j\in s}a_{i,j}\}\)</span>。<span class="math inline">\(O(nm)\)</span> 预处理出 <span class="math inline">\(f_j(u)=\sum\limits_{T_i=u}a_{j, i}\)</span>，那么待求即为 <span class="math inline">\(\max\limits_{s}\{\sum\limits_{j\in s}\sum\limits_{u\supseteq s}f_j(u)\}\)</span>，发现这个东西可以用 FWT 求。</p><details><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;int main() &#123;#ifdef ONLINE_JUDGE    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr), std::cout.tie(nullptr);#else    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);#endif    int n, m, k;    std::cin &gt;&gt; k &gt;&gt; m, n = 1 &lt;&lt; k;    using arr = std::vector&lt;long long&gt;;    std::vector&lt;int&gt; t(m + 1);    std::vector&lt;arr&gt; a(k + 1, arr(m + 1)), f(k + 1, arr(n));    for (int i = 1; i &lt;= k; ++i)        for (int j = 1; j &lt;= m; ++j) &#123;            std::cin &gt;&gt; a[i][j];            if (a[i][j] &gt;= 0)                t[j] |= 1 &lt;&lt; (i - 1);        &#125;    for (int i = 1; i &lt;= k; ++i)        for (int j = 1; j &lt;= m; ++j)            if (a[i][j] &gt;= 0)                f[i][t[j]] += a[i][j];    &#123;        std::vector&lt;arr&gt; mT(2, arr(2));        mT[0][0] = 1ll, mT[0][1] = 1ll, mT[1][0] = 0ll, mT[1][1] = 1ll;        auto calc = [&amp;](arr a, arr &amp;f, std::vector&lt;arr&gt; &amp;w) &#123;            f = a;            for (int len = 2; len &lt;= n; len &lt;&lt;= 1) &#123;                for (int i = 0; i &lt; n; i += len)                    for (int p = i, q = i + len / 2; q &lt; i + len; ++p, ++q)                        std::tie(f[p], f[q]) = std::make_tuple(f[p] * w[0][0] + f[q] * w[0][1], f[p] * w[1][0] + f[q] * w[1][1]);            &#125;            return;        &#125;;        for (int i = 1; i &lt;= k; ++i)            calc(f[i], f[i], mT);    &#125;    long long res = 0ll;    for (int s = 0; s &lt; n; ++s) &#123;        long long sum = 0ll;        for (int i = 1; i &lt;= k; ++i)            if ((s &gt;&gt; (i - 1)) &amp; 1)                sum += f[i][s];        res = std::max(res, sum);    &#125;    std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;    return 0;&#125;</code></pre></details><hr /><h2 id="nim-counting">Nim Counting</h2><p><a href="https://atcoder.jp/contests/abc212/tasks/abc212_h" class="uri">https://atcoder.jp/contests/abc212/tasks/abc212_h</a></p><p>即，从 <span class="math inline">\(A_N\)</span> 中有放回地选择 <span class="math inline">\(\le M\)</span> 个数，问它们异或起来不为 <span class="math inline">\(0\)</span> 的方案数。</p><p>如果令 <span class="math inline">\(f_{i, j}\)</span> 表示选了 <span class="math inline">\(i\)</span> 次，异或和为 <span class="math inline">\(j\)</span> 的方案数，显然 <span class="math inline">\(f_{1,i}=\sum [a_j=i]\)</span> 为关于 <span class="math inline">\(a\)</span> 的桶。此时有 <span class="math inline">\(f_{i,j}=\sum\limits_{k=1}^n f_{i-1,j\oplus a_k}=\sum\limits_{k=0}^V f_{i-1,j\oplus k}\cdot f_{1,k}\)</span>，发现把 <span class="math inline">\(f_1\)</span> 这个桶在 <span class="math inline">\(f\)</span> 上做 <span class="math inline">\(N\)</span> 次 xor-FWT 就可以得到 <span class="math inline">\(f_n\)</span>。</p><p>但如果直接卷 <span class="math inline">\(N\)</span> 次是 <span class="math inline">\(O(N\cdot V\log V)\)</span> 的，不太美好，但我们看看我们实际上需要做什么：</p><ol type="1"><li>求 <span class="math inline">\(f_i\)</span> 的 FWT。</li><li>求初始桶 <span class="math inline">\(f_1\)</span> 的 FWT。</li><li>对位相乘得到 <span class="math inline">\(f_{i+1}\)</span> 的 FWT。</li><li>通过 FWT 求得原本的 <span class="math inline">\(f_{i+1}\)</span>。</li></ol><p>当这个操作被放在 <span class="math inline">\(i=1\sim n\)</span> 上依次进行时，我们发现第一步和最后一步会相互抵消，我们只需要求出 <span class="math inline">\(f_1\)</span> 的 FWT，<span class="math inline">\(FWT_{i, j}(f)\)</span> 即为 <span class="math inline">\(FWT_{1, j}(f)^i\)</span>。因为我们要求的是 <span class="math inline">\(\sum\limits_{i, j}f_{i,j}\)</span> 可以通过等比数列求和求出 <span class="math inline">\(FWT_j(s)=\sum f_{i, j}\)</span>。由前文推导可知直接做一次逆变换求得 <span class="math inline">\(s_j\)</span> 即可。</p><details><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;int main() &#123;#ifdef ONLINE_JUDGE    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr), std::cout.tie(nullptr);#else    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);#endif    struct mint &#123;        const int mod = 998244353;        long long x;        mint(): x(0ll) &#123;&#125;        mint(long long x1): x((x1 + mod) % mod) &#123;&#125;        mint&amp; operator= (const mint q) &#123;            x = q.x;            return *this;        &#125;        bool operator== (const mint q) const &#123;            return x == q.x;        &#125;        mint operator* (const mint q) const &#123;            return x * q.x % mod;        &#125;        mint&amp; operator*= (const mint q) &#123;            return *this = *this * q;        &#125;        mint operator+ (const mint q) &#123;            return (x + q.x) % mod;        &#125;        mint&amp; operator+= (const mint q) &#123;            return *this = *this + q;        &#125;        mint operator- (const mint q) &#123;            return (x + mod - q.x) % mod;        &#125;        mint qkp(int y) &#123;            mint res(1ll), x(this-&gt;x);            for (; y; y &gt;&gt;= 1, x *= x)                if (y &amp; 1)                    res *= x;            return res;        &#125;        mint inv(void) &#123;            return qkp(mod - 2);        &#125;    &#125;;    int n, m, k = 16, l = 1 &lt;&lt; k;    std::cin &gt;&gt; m &gt;&gt; n;    using arr = std::vector&lt;mint&gt;;    arr a(n + 1), c(l);    for (int i = 1; i &lt;= n; ++i)        std::cin &gt;&gt; a[i].x, c[a[i].x] += 1;    std::vector&lt;arr&gt; mT(2, arr(2)), mI(2, arr(2));    mT[0][0] = 1ll, mT[0][1] = 1ll, mT[1][0] = 1ll, mT[1][1] = -1ll;    mI[0][0] = mI[0][1] = mI[1][0] = mint(2ll).inv(), mI[1][1] = mint(-2ll).inv();    auto calc = [&amp;](arr a, arr &amp;f, std::vector&lt;arr&gt; &amp;w) &#123;        f = a;        for (int len = 2; len &lt;= l; len &lt;&lt;= 1)            for (int i = 0; i &lt; l; i += len)                for (int p = i, q = i + len / 2; q &lt; i + len; ++p, ++q)                    std::tie(f[p], f[q]) = std::make_tuple(f[p] * w[0][0] + f[q] * w[0][1], f[p] * w[1][0] + f[q] * w[1][1]);        return;    &#125;;    calc(c, c, mT);    arr s(l);    for (int i = 0; i &lt; l; ++i)        if (c[i] == 1ll)            s[i] = m;        else            s[i] = c[i] * (mint(1ll) - c[i].qkp(m)) * (mint(1ll) - c[i]).inv();    calc(s, s, mI);    mint res;    for (int i = 1; i &lt; l; ++i)        res += s[i];    std::cout &lt;&lt; res.x &lt;&lt; &#39;\n&#39;;    return 0;&#125;</code></pre></details><hr /><h2 id="binary-table">Binary Table</h2><p><a href="https://codeforces.com/problemset/problem/662/C" class="uri">https://codeforces.com/problemset/problem/662/C</a></p><p>发现这个题和 <em>Emiya 家今天的饭</em> 很像，都是有一个很小的维和一个相对比较大的维。</p><p>显然，我们所有的操作顺序都可以任意调换；朴素地，我们枚举 <span class="math inline">\(2^n\)</span> 种给这 <span class="math inline">\(n\)</span> 行反转的情况；再对于每一列，<span class="math inline">\(O(n)\)</span> 选择应该反转还是不反转，这样总共是 <span class="math inline">\(O(2^n\cdot nm)\)</span> 的。</p><p>发现把一列初始状态压成一个二进制数 <span class="math inline">\(a\)</span>，假设我们现在枚举的行反转状态为 <span class="math inline">\(s\)</span>，显然用 <span class="math inline">\(s\oplus a\)</span> 可以得到当前状态。怎么利用这个去 FWT 呢？这引导我们依然枚举 <span class="math inline">\(s\)</span>，用一个和 <span class="math inline">\(s\oplus a\)</span> 有关的量跟一个和 <span class="math inline">\(a\)</span> 有关的量相乘得到关于 <span class="math inline">\(s\)</span> 的答案。</p><p>容易发现令 <span class="math inline">\(f_{s\oplus a}\)</span> 表示 <span class="math inline">\(s\oplus a\)</span> 这个状态反转和不反转两个选项中可以获取的最少 1 的个数；再令 <span class="math inline">\(c_s\)</span> 表示状态为 <span class="math inline">\(s\)</span> 的列的个数，那么 <span class="math inline">\(\sum\limits_s c_s\times f_{s\oplus a}\)</span> 就可以得到枚举的反转方案为 <span class="math inline">\(s\)</span> 的答案，求最小即可。</p><details><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;int main() &#123;#ifdef ONLINE_JUDGE    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr), std::cout.tie(nullptr);#else    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);#endif    struct mint &#123;        const int mod = 998244353;        long long x;        mint(): x(0ll) &#123;&#125;        mint(long long x1): x((x1 + mod) % mod) &#123;&#125;        mint&amp; operator= (const mint q) &#123;            x = q.x;            return *this;        &#125;        bool operator== (const mint q) const &#123;            return x == q.x;        &#125;        mint operator* (const mint q) const &#123;            return x * q.x % mod;        &#125;        mint&amp; operator*= (const mint q) &#123;            return *this = *this * q;        &#125;        mint operator+ (const mint q) &#123;            return (x + q.x) % mod;        &#125;        mint&amp; operator+= (const mint q) &#123;            return *this = *this + q;        &#125;        mint operator- (const mint q) &#123;            return (x + mod - q.x) % mod;        &#125;        mint qkp(int y) &#123;            mint res(1ll), x(this-&gt;x);            for (; y; y &gt;&gt;= 1, x *= x)                if (y &amp; 1)                    res *= x;            return res;        &#125;        mint inv(void) &#123;            return qkp(mod - 2);        &#125;    &#125;;    int n, m, l;    std::cin &gt;&gt; n &gt;&gt; m, l = 1 &lt;&lt; n;    using arr = std::vector&lt;mint&gt;;    arr c(l), f(l);    std::vector&lt;std::vector&lt;char&gt; &gt; a(n + 1, std::vector&lt;char&gt; (m + 1));    for (int i = 1; i &lt;= n; ++i)        for (int j = 1; j &lt;= m; ++j)            std::cin &gt;&gt; a[i][j];    for (int j = 1; j &lt;= m; ++j) &#123;        int s = 0;        for (int i = 1; i &lt;= n; ++i)            s = (s &lt;&lt; 1) + a[i][j] - &#39;0&#39;;        c[s] += 1;    &#125;    for (int i = 0, t; i &lt; l; ++i)        t = (__builtin_popcount(i)), f[i] = std::min(t, n - t);    std::vector&lt;arr&gt; mT(2, arr(2)), mI(2, arr(2));    mT[0][0] = 1ll, mT[0][1] = 1ll, mT[1][0] = 1ll, mT[1][1] = -1ll;    mI[0][0] = mI[0][1] = mI[1][0] = mint(2ll).inv(), mI[1][1] = mint(-2ll).inv();    auto calc = [&amp;](arr a, arr &amp;f, std::vector&lt;arr&gt; &amp;w) &#123;        f = a;        for (int len = 2; len &lt;= l; len &lt;&lt;= 1)            for (int i = 0; i &lt; l; i += len)                for (int p = i, q = i + len / 2; q &lt; i + len; ++p, ++q)                    std::tie(f[p], f[q]) = std::make_tuple(f[p] * w[0][0] + f[q] * w[0][1], f[p] * w[1][0] + f[q] * w[1][1]);        return;    &#125;;    calc(c, c, mT), calc(f, f, mT);    arr s(l);    for (int i = 0; i &lt; l; ++i)        s[i] = c[i] * f[i];    calc(s, s, mI);    int res = 0x3f3f3f3f;    for (int i = 0; i &lt; l; ++i)        res = std::min(res, (int)s[i].x);    std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;    return 0;&#125;</code></pre></details><hr /><h2 id="hard-nim">Hard Nim</h2><p><a href="https://hydro.ac/p/bzoj-P4589" class="uri">https://hydro.ac/p/bzoj-P4589</a></p><p><em>Nim Counting</em> 然后缝了个筛子。</p><details><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;const int mod = 1e9 + 7;const int inv2 = 5e8 + 4;int main() &#123;#ifdef ONLINE_JUDGE    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr), std::cout.tie(nullptr);#else    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);#endif    std::vector&lt;int&gt; p, tag(50001);    for (int i = 2; i &lt;= 50000; ++i)        if (!tag[i]) &#123;            p.push_back(i);            for (int j = 2 * i; j &lt;= 50000; j += i)                tag[j] = 1;        &#125;    auto qkp = [&amp;](long long x, int y) &#123;        long long res = 1ll;        for (; y; y &gt;&gt;= 1, (x *= x) %= mod)            if (y &amp; 1)                (res *= x) %= mod;        return res;    &#125;;    for (int n, m; std::cin &gt;&gt; n &gt;&gt; m; ) &#123;        int k = std::__lg(m) + 1, l = 1 &lt;&lt; k;        using arr = std::vector&lt;long long&gt;;        arr c(l);        for (auto i : p)            if (i &lt;= m)                c[i] += 1;            else                break;        std::vector&lt;arr&gt; mT(2, arr(2)), mI(2, arr(2));        mT[0][0] = 1ll, mT[0][1] = 1ll, mT[1][0] = 1ll, mT[1][1] = mod - 1ll;        mI[0][0] = mI[0][1] = mI[1][0] = inv2, mI[1][1] = mod - inv2;        auto calc = [&amp;](arr &amp;f, std::vector&lt;arr&gt; &amp;w) &#123;            for (int len = 2; len &lt;= l; len &lt;&lt;= 1)                for (int i = 0; i &lt; l; i += len)                    for (int p = i, q = i + len / 2; q &lt; i + len; ++p, ++q)                        std::tie(f[p], f[q]) = std::make_tuple((f[p] * w[0][0] + f[q] * w[0][1]) % mod, (f[p] * w[1][0] + f[q] * w[1][1]) % mod);            return;        &#125;;        calc(c, mT);        arr s(l);        for (int i = 0; i &lt; l; ++i)            s[i] = qkp(c[i], n);        calc(s, mI);        std::cout &lt;&lt; s[0] &lt;&lt; &#39;\n&#39;;    &#125;    return 0;&#125;</code></pre></details><hr /><h2 id="子集卷积">子集卷积</h2><p><a href="https://www.luogu.com.cn/problem/P6097" class="uri">https://www.luogu.com.cn/problem/P6097</a></p><p>这个是在许多 DP 中都可能见到过的结构，相信大家都深有体会。</p><p>等价于求 <span class="math inline">\(c_s=\sum\limits_{i\cap j=\varnothing\land i\cup j=s}a_i\cdot b_j\)</span>，首先关注 <span class="math inline">\(i\cup j=s\)</span>，可以用 FWT 解决；对于 <span class="math inline">\(i\cap j = \varnothing\)</span> 呢？</p><p>有一个很聪明的办法，我们发现 <span class="math inline">\(i\cap j=\varnothing\land i\cup j = s\iff \operatorname{ctz}(i)+\operatorname{ctz}(j)=\operatorname{ctz}(s)\)</span>，其中 <span class="math inline">\(\operatorname{ctz}(i)\)</span> 表示 <span class="math inline">\(i\)</span> 中 <span class="math inline">\(1\)</span> 的个数，即 <code>popcount(i)</code>。</p><p>显然后者是个简单的加法运算，这里又有一个很聪明又很基本的办法，我们令 <span class="math inline">\(A_{\operatorname{ctz}(i),i}=a_i,B_{\operatorname{ctz}(j),j}=b_j\)</span>，那么答案就转化为 <span class="math inline">\(\sum\limits_{i}\sum\limits_{j\cup k=s}A_{i,j}\cdot B_{\operatorname{ctz}(s)-i,j}\)</span>，就可以 <span class="math inline">\(O(n\log^2n)\)</span> 地解决问题了。</p><details><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;const int mod = 1e9 + 9;using arr = std::vector&lt;long long&gt;;int main() &#123;#ifdef ONLINE_JUDGE    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr), std::cout.tie(nullptr);#else    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);#endif    int n;    std::cin &gt;&gt; n;    int l = 1 &lt;&lt; n;    std::vector&lt;arr&gt; a(n + 1, arr(l)), b(n + 1, arr(l)), c(n + 1, arr(l));    for (int i = 0, x; i &lt; l; ++i)        std::cin &gt;&gt; x, a[__builtin_popcount(i)][i] = x;    for (int i = 0, x; i &lt; l; ++i)        std::cin &gt;&gt; x, b[__builtin_popcount(i)][i] = x;    std::vector&lt;arr&gt; mT(2, arr(2)), mI(2, arr(2));    mT[0][0] = 1ll, mT[0][1] = 0ll, mT[1][0] = 1ll, mT[1][1] = 1ll;    mI[0][0] = 1ll, mI[0][1] = 0ll, mI[1][0] = mod - 1ll, mI[1][1] = 1ll;    auto calc = [&amp;](arr &amp;f, std::vector&lt;arr&gt; &amp;w) &#123;        for (int len = 2; len &lt;= l; len &lt;&lt;= 1)            for (int i = 0; i &lt; l; i += len)                for (int p = i, q = i + len / 2; q &lt; i + len; ++p, ++q)                    std::tie(f[p], f[q]) = std::make_tuple((f[p] * w[0][0] + f[q] * w[0][1]) % mod, (f[p] * w[1][0] + f[q] * w[1][1]) % mod);        return;    &#125;;    for (int i = 0; i &lt;= n; ++i)        calc(a[i], mT), calc(b[i], mT);    for (int i = 0; i &lt;= n; ++i) &#123;        for (int k = 0; k &lt;= i; ++k)            for (int j = 0; j &lt; l; ++j)                (c[i][j] += a[k][j] * b[i - k][j]) %= mod;        calc(c[i], mI);    &#125;    for (int j = 0; j &lt; l; ++j)        std::cout &lt;&lt; c[__builtin_popcount(j)][j] &lt;&lt; &#39; &#39;;    std::cout &lt;&lt; &#39;\n&#39;;    return 0;&#125;</code></pre></details><hr /><h2 id="州区划分">州区划分</h2><p><a href="https://www.luogu.com.cn/problem/P4221" class="uri">https://www.luogu.com.cn/problem/P4221</a></p><p>人话：把 <span class="math inline">\(n\)</span> 个点划分成若干个点集，保证每个点集的导出子图不是欧拉回路（每个点的度数为偶且图连通）。</p><p>那么枚举每一个点集判定是否合法，再令 <span class="math inline">\(f_{i}={w_i}^{-p}\times\sum\limits_{j\cup k = i\land j\cap k=\varnothing}f_{j}\times {w_k}^p\)</span>。</p><p>发现后面那个 sigma 里面是一个简单的子集卷积；但是我们发现前面有一个和 <span class="math inline">\(i\)</span> 有关的常数，导致没办法直接卷 <span class="math inline">\(n\)</span> 次。</p><p>但我们发现这个 DP 其实是有一定隐含条件的——都是按照 <span class="math inline">\(\text{ctz}\)</span> 从小到大转移。考虑子集卷积的第一维，得到 <span class="math inline">\(FWT_{f_i}\)</span> 后先 IFWT 回来，乘上 <span class="math inline">\({w_i}^{-p}\)</span>，再 FWT 回去即可。考察子集卷积的结构，发现这个是可以想办法套进去的。</p><p>复杂度 <a href="https://atcoder.jp/contests/abc400/tasks/abc400_c"><span class="math inline">\(O(n^2\cdot 2^n)\)</span></a>。</p><details><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;const int mod = 998244353;using arr = std::vector&lt;long long&gt;;int main() &#123;#ifdef ONLINE_JUDGE    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr), std::cout.tie(nullptr);#else    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);#endif    int n, m, p;    std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; p;    int l = 1 &lt;&lt; n;    auto qkp = [&amp;](long long x, int y = mod - 2) &#123;        auto res = 1ll;        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)            if (y &amp; 1)                (res *= x) %= mod;        return res;    &#125;;    arr w(n), inv(l);    std::vector&lt;arr&gt; f(n + 1, arr(l)), s(n + 1, arr(l));    std::vector&lt;std::vector&lt;int&gt; &gt; g(n);    for (int x, y; m--; ) &#123;        std::cin &gt;&gt; x &gt;&gt; y, --x, --y;        g[x].push_back(y);    &#125;    auto check = [&amp;](int s) &#123;        std::vector&lt;int&gt; f(n), deg(n);        std::iota(f.begin(), f.end(), 0);        std::function&lt;int(int)&gt; find = [&amp;](int x) &#123;            return x == f[x] ? x : f[x] = find(f[x]);        &#125;;        auto merge = [&amp;](int x, int y) &#123;            f[find(x)] = find(y);            return;        &#125;;        for (int i = 0; i &lt; n; ++i)            if ((s &gt;&gt; i) &amp; 1)                for (auto j : g[i])                    if ((s &gt;&gt; j) &amp; 1)                        merge(i, j), ++deg[i], ++deg[j];        int fa = -1;        for (int i = 0; i &lt; n; ++i)            if ((s &gt;&gt; i) &amp; 1) &#123;                if (deg[i] &amp; 1)                    return 1;                if (fa == -1 || fa == find(i))                    fa = find(i);                else                    return 1;            &#125;        return 0;    &#125;;    for (int i = 0; i &lt; n; ++i)        std::cin &gt;&gt; w[i];    for (int i = 0; i &lt; l; ++i) &#123;        int ctz = __builtin_popcount(i);        for (int j = 0; j &lt; n; ++j)            if ((i &gt;&gt; j) &amp; 1)                 s[ctz][i] += w[j];        s[ctz][i] = qkp(s[ctz][i], p);        inv[i] = qkp(s[ctz][i]);        if (!check(i))            s[ctz][i] = 0ll;    &#125;    std::vector&lt;arr&gt; mT(2, arr(2)), mI(2, arr(2));    mT[0][0] = 1ll, mT[0][1] = 0ll, mT[1][0] = 1ll, mT[1][1] = 1ll;    mI[0][0] = 1ll, mI[0][1] = 0ll, mI[1][0] = mod - 1ll, mI[1][1] = 1ll;    auto calc = [&amp;](arr &amp;f, std::vector&lt;arr&gt; &amp;w) &#123;        for (int len = 2; len &lt;= l; len &lt;&lt;= 1)            for (int i = 0; i &lt; l; i += len)                for (int p = i, q = i + len / 2; q &lt; i + len; ++p, ++q)                    std::tie(f[p], f[q]) = std::make_tuple((f[p] * w[0][0] + f[q] * w[0][1]) % mod, (f[p] * w[1][0] + f[q] * w[1][1]) % mod);        return;    &#125;;    f[0][0] = 1ll;    for (int i = 0; i &lt;= n; ++i)        calc(s[i], mT);    for (int i = 1; i &lt;= n; ++i) &#123;        calc(f[i - 1], mT);        for (int k = 0; k &lt; i; ++k)            for (int j = 0; j &lt; l; ++j)                (f[i][j] += f[k][j] * s[i - k][j]) %= mod;        calc(f[i], mI);        for (int j = 0; j &lt; l; ++j)            (f[i][j] *= inv[j]) %= mod;    &#125;    std::cout &lt;&lt; f[n][l - 1] &lt;&lt; &#39;\n&#39;;    return 0;&#125;</code></pre></details><hr /><h2 id="b---sum-the-fibonacci">B - Sum the Fibonacci</h2><p><a href="https://codeforces.com/problemset/problem/914/G" class="uri">https://codeforces.com/problemset/problem/914/G</a></p><p>首先，对于每个元素的 <span class="math inline">\(cnt\)</span> 是好做的——做一次子集卷积得到 <span class="math inline">\(cnt_1(a\cup b)\)</span>，做一次 xor-FWT 得到 <span class="math inline">\(cnt_2(d\oplus e)\)</span>，中间的 <span class="math inline">\(cnt(c)\)</span> 就是原样。</p><p>值得注意的是可以在一次 and-FWT 后把 <span class="math inline">\(cnt,cnt_1,cnt_2\)</span> 直接卷起来——由矩阵乘法结合律得（哈哈大笑了）。但怎么把 <span class="math inline">\(f\)</span> 塞进去呢？如果你拥有小学生的数学水平，你可以很容易地想到直接在 <span class="math inline">\(cnt,cnt_1,cnt_2\)</span> IFWT 后的结果分别对位乘上 <span class="math inline">\(f\)</span> 即可，很可惜我并没有这样的数学能力 <img src="/em/kt.gif" /></p><details><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;const int N = 17;const int mod = 1e9 + 7;using arr = std::vector&lt;long long&gt;;int main() &#123;#ifdef ONLINE_JUDGE    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr), std::cout.tie(nullptr);#else    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);#endif    int n, l;    std::cin &gt;&gt; n, l = 1 &lt;&lt; N;    std::vector&lt;int&gt; a(n + 1);    arr f(l), cnt(l), cnt1(l), cnt2(l);    for (int i = 1; i &lt;= n; ++i)        std::cin &gt;&gt; a[i], ++cnt[a[i]];    f[0] = 0ll, f[1] = 1ll;    for (int i = 2; i &lt; l; ++i)        f[i] = (f[i - 1] + f[i - 2]) % mod;    auto qkp = [&amp;](long long x, int y = mod - 2) &#123;        auto res = 1ll;        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)            if (y &amp; 1)                (res *= x) %= mod;        return res;    &#125;;    const int inv2 = qkp(2ll);    std::vector&lt;arr&gt; mT(2, arr(2)), mI(2, arr(2));    auto calc = [&amp;](arr a, arr &amp;f, std::vector&lt;arr&gt; &amp;w) &#123;        f = a;        for (int len = 2; len &lt;= l; len &lt;&lt;= 1)            for (int i = 0; i &lt; l; i += len)                for (int p = i, q = i + len / 2; q &lt; i + len; ++p, ++q)                    std::tie(f[p], f[q]) = std::make_tuple((f[p] * w[0][0] + f[q] * w[0][1]) % mod, (f[p] * w[1][0] + f[q] * w[1][1]) % mod);        return;    &#125;;    &#123; // orFWT        mT[0][0] = 1ll, mT[0][1] = 0ll, mT[1][0] = 1ll, mT[1][1] = 1ll;        mI[0][0] = 1ll, mI[0][1] = 0ll, mI[1][0] = mod - 1ll, mI[1][1] = 1ll;        std::vector&lt;arr&gt; u(N + 1, arr(l)), d(N + 1, arr(l));        for (int i = 0; i &lt; l; ++i)            u[__builtin_popcount(i)][i] = cnt[i];        for (int i = 0; i &lt;= N; ++i)            calc(u[i], u[i], mT);        for (int i = 0; i &lt;= N; ++i) &#123;            for (int j = 0; j &lt; l; ++j)                for (int k = 0; k &lt;= i; ++k)                    (d[i][j] += u[k][j] * u[i - k][j]) %= mod;            calc(d[i], d[i], mI);        &#125;        for (int i = 0; i &lt; l; ++i)            cnt1[i] = d[__builtin_popcount(i)][i] * f[i] % mod;    &#125;    &#123; // xor FWT        mT[0][0] = 1ll, mT[0][1] = 1ll, mT[1][0] = 1ll, mT[1][1] = mod - 1ll;        mI[0][0] = mI[0][1] = mI[1][0] = inv2, mI[1][1] = mod - inv2;        calc(cnt, cnt2, mT);        for (int i = 0; i &lt; l; ++i)            (cnt2[i] *= cnt2[i]) %= mod;        calc(cnt2, cnt2, mI);        for (int i = 0; i &lt; l; ++i)            (cnt2[i] *= f[i]) %= mod;    &#125;    &#123; // andFWT        mT[0][0] = 0ll, mT[0][1] = 1ll, mT[1][0] = 1ll, mT[1][1] = 1ll;        mI[0][0] = mod - 1ll, mI[0][1] = 1ll, mI[1][0] = 1ll, mI[1][1] = 0ll;        for (int i = 0; i &lt; l; ++i) // 这一步要放在 FWT 之前，原因显然 🤗            (cnt[i] *= f[i]) %= mod;        calc(cnt2, cnt2, mT), calc(cnt1, cnt1, mT), calc(cnt, cnt, mT);        for (int i = 0; i &lt; l; ++i)            cnt[i] = cnt[i] * cnt1[i] % mod * cnt2[i] % mod % mod;        calc(cnt, cnt, mI);    &#125;    long long res = 0ll;    for (int i = 0; i &lt; N; ++i)        (res += cnt[1 &lt;&lt; i] % mod) %= mod;    std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;    return 0;&#125;</code></pre></details>]]></content>
      
      
      
        <tags>
            
            <tag> 高维前缀和 </tag>
            
            <tag> FWT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>杂题集</title>
      <link href="/20250219/"/>
      <url>/20250219/</url>
      
        <content type="html"><![CDATA[<p>不在沉默中躺平，就在喧嚣中躺平。</p><span id="more"></span><p>但谁说人一定要躺平？我要 work work work work work work work work 勤劳又勇敢的 XSC062 为了 OI 的关键杂题集 她作出了巨大的贡献 巨大的牺牲 巨大的 carry 无敌了 无敌了 <img src="/em/kt.gif" alt="磕头" /></p><hr /><h2 id="usaco23jan-moo-route-g">[USACO23JAN] Moo Route G</h2><p><a href="https://www.luogu.com.cn/problem/P9018" class="uri">https://www.luogu.com.cn/problem/P9018</a></p><p>关键词：<mark>由小推大</mark> <mark>思维</mark></p><p>希望大家不要和我一样忽略了重要条件：终点也是 <span class="math inline">\(0\)</span>。这意味着每个点都会被左右成对地经过，那么不妨令 <span class="math inline">\(A_i\gets \frac 2{A_i}\)</span>。</p><p>观察到给了 <span class="math inline">\(N=2\)</span> 的一档分，考虑该情况。</p><ol type="1"><li><p>若 <span class="math inline">\(A_1&gt; A_2\)</span>：</p><details><p><summary>此时最优策略为……</summary></p><pre class="plain{data-line=&quot;1,2,5,6,9,10&quot;}"><code>|---------&gt;&lt;---------||---------&gt;&lt;---------||---------&gt;&lt;---------||----&gt;&lt;----||----&gt;&lt;----|===========0    1    2</code></pre></details>只要不拆开一组，箭头排列顺序任意。显然方案数为 <span class="math inline">\({A_1}\choose {A_2}\)</span>。</li><li><p>Otherwise：</p><details><p><summary>此时最优策略为……</summary></p><pre class="plain{data-line=&quot;4,5,7,8&quot;}"><code>|----------&gt;      &lt;----|      |----&gt;      &lt;----|      |----&gt; &lt;---------| |---------&gt; &lt;---------| =========== 0    1    2</code></pre></details><p>相似地，只要不拆开一组，箭头排列顺序任意，可以注意到除了第一个，每个长 <code>|---&gt;</code> 的前面一定是一个长 <code>&lt;---|</code>，那么问题转化为选择 <span class="math inline">\(A_1-1\)</span> 个短 <code>&lt;---|</code> 拉长，方案数为 <span class="math inline">\({A_2-1}\choose{A_1-1}\)</span>。</p></li></ol><p>进一步，考虑 <span class="math inline">\(N=3\)</span> 的情况。若已知子问题 <span class="math inline">\(0\to1\to2\)</span> 的方案和子问题 <span class="math inline">\(1\to2\to3\)</span> 的方案，可以直接乘起来合并。为什么呢？</p><p>二者经过 <span class="math inline">\(2\)</span> 的次数相等；在子问题 <span class="math inline">\(0\to1\to2\)</span> 中，<span class="math inline">\(1\to2\)</span> 的下一步一定是 <span class="math inline">\(2\to 1\)</span>；我们把该过程替换为子问题 <span class="math inline">\(1\to 2\to 3\)</span> 中对应的一段 <span class="math inline">\(1\to2\to\cdots\to2\to1\)</span> 的路径即可。</p><p>那么两两合并起来，可以得到最终答案为 <span class="math inline">\(\prod\limits_{i=1}^{n-1}\begin{cases}{\binom{A_i}{A_{i+1}}}&amp;A_i&gt;A_{i+1}\\{\binom{A_{i+1}-1}{A_i-1}}&amp;\text{otherwise}\end{cases}\)</span>。</p><details><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;const int lim = 5e5;const int mod = 1e9 + 7;int main() &#123;#ifdef ONLINE_JUDGE    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr), std::cout.tie(nullptr);#else    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);#endif    int n;    std::cin &gt;&gt; n;    std::vector&lt;int&gt; a(n + 1);    for (int i = 1; i &lt;= n; ++i)        std::cin &gt;&gt; a[i], a[i] /= 2;    std::vector&lt;long long&gt; inv(lim + 1), fac(lim + 1);    auto qkp = [&amp;](long long x, int y) &#123;        long long res = 1ll;        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)            if (y &amp; 1)                (res *= x) %= mod;        return res;    &#125;;    inv[0] = fac[0] = 1ll;    for (int i = 1; i &lt;= lim; ++i)        fac[i] = fac[i - 1] * i % mod;    inv[lim] = qkp(fac[lim], mod - 2);    for (int i = lim - 1; i; --i)        inv[i] = inv[i + 1] * (i + 1) % mod;    auto C = [&amp;](int n, int m) &#123;        return fac[n] * inv[n - m] % mod * inv[m] % mod;    &#125;;    long long res = 1ll;    for (int i = 1; i &lt; n; ++i)        if (a[i] &gt; a[i + 1])            (res *= C(a[i], a[i + 1])) %= mod;        else            (res *= C(a[i + 1] - 1, a[i] - 1)) %= mod;    std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;    return 0;&#125;</code></pre></details><hr /><h2 id="gdkoi2024-普及组-正方形扩展">[GDKOI2024 普及组] 正方形扩展</h2><p><a href="https://www.luogu.com.cn/problem/P10078" class="uri">https://www.luogu.com.cn/problem/P10078</a></p><p>关键词：<mark>分类讨论</mark> <mark>扫描线</mark></p><p>理论上看懂了就是弱智题，可惜看不懂。</p><p>就是说，一个点如果被染了某种颜色，并且以它为中心的边长为 <span class="math inline">\(2\)</span> 的正方形中没有其他颜色的点，就把这个正方形里的点都染成这个颜色，问每个颜色面积是否能达到无穷大。</p><p>考虑无法达到无穷大的原因，一定是因为向四个方向都无法延伸到无穷远。以右边为例，考虑点 <span class="math inline">\(i\)</span> 什么时候不能在 <span class="math inline">\(x\)</span> 轴正方向上延伸到无穷远：</p><ul><li><p>对于 <span class="math inline">\(\forall \, j,x_j\le x_i\)</span>，<span class="math inline">\(j\)</span> <strong>不会</strong>对 <span class="math inline">\(i\)</span> 向右的延伸带来任何影响——所有点的延伸速度相同。</p></li><li><p>对于 <span class="math inline">\(x_j&gt;x_i\)</span> 且 <span class="math inline">\(y_j=y_i\)</span>，<span class="math inline">\(j\)</span> 可以堵住 <span class="math inline">\(i\)</span>。</p><p>这时候不免产生疑问：<span class="math inline">\(i\)</span> 不能从上下「翻越」过 <span class="math inline">\(j\)</span> 的统治吗？</p><p>显而易见地，由于延伸速度相同，<span class="math inline">\(i\)</span> 在某时刻能够在 <span class="math inline">\(y\)</span> 轴上到达的高度，<span class="math inline">\(j\)</span> 也能达到，所以 <span class="math inline">\(j\)</span> <strong>能够</strong>把 <span class="math inline">\(i\)</span> 堵死，参见题面中给出的例子。</p></li><li><p>对于 <span class="math inline">\(x_j&gt;x_i\)</span> 且 <span class="math inline">\(y_j \ne y_i\)</span>，由上所述，<span class="math inline">\(j\)</span> 在 <span class="math inline">\(y\)</span> 轴下 / 上方向<strong>无法</strong>追上 <span class="math inline">\(i\)</span>，<span class="math inline">\(i\)</span> 可以从该方向越过 <span class="math inline">\(j\)</span>，在 <span class="math inline">\(x\)</span> 轴正方向上延伸到无穷远；但 <span class="math inline">\(j\)</span> 在自己所在的一侧（上 / 下）<strong>可以</strong>堵住 <span class="math inline">\(i\)</span>。</p></li><li><p>对于 <span class="math inline">\(x_j,x_k&gt;x_i\)</span> 且 <span class="math inline">\((y_j-y_i)(y_k-y_i)&lt;0\)</span>（即二者分居 <span class="math inline">\(i\)</span> 点上下），<span class="math inline">\(j\)</span> 和 <span class="math inline">\(k\)</span> <strong>可以</strong>在两个方向分别拦截住 <span class="math inline">\(i\)</span>。</p><p>此时可能有疑问：<span class="math inline">\(i\)</span> 可不可以先越过 <span class="math inline">\(j\)</span> ，再越过 <span class="math inline">\(k\)</span> 呢？答案是否定的。由上，<span class="math inline">\(j\)</span> 和 <span class="math inline">\(k\)</span> 会分别在 <span class="math inline">\(y\)</span> 轴自身对应方向上堵住 <span class="math inline">\(i\)</span>，在越过其中之一后无法从这一侧越过另一个点，所以 <span class="math inline">\(i\)</span> 会被两个点合作堵死。</p></li></ul><p>由此我们总结出，<span class="math inline">\(i\)</span> 能在 <span class="math inline">\(x\)</span> 轴正方向被拦截，当且仅当：</p><ul><li>存在 <span class="math inline">\(x_j&gt;x_i\)</span> 且 <span class="math inline">\(y_j=y_i\)</span>；</li><li>抑或，存在 <span class="math inline">\(x_j,x_k&gt;x_i\)</span> 且 <span class="math inline">\(y_j&lt;y_i,y_k&gt;y_i\)</span>。</li></ul><p>那么可以从四个方向分别用扫描线求解。鉴于和实际坐标数值没有什么直接关系，可以离散化后树状数组以避免被卡常。</p><hr /><h2 id="金鱼草">金鱼草</h2><p><a href="http://222.180.160.110:61235/contest/6051/problem/4" class="uri">http://222.180.160.110:61235/contest/6051/problem/4</a></p><blockquote><p>给定 <span class="math inline">\(n\)</span> 个区间 <span class="math inline">\([l,r]\)</span> 满足 <span class="math inline">\(r\le m\)</span>，给出 <span class="math inline">\(q\)</span> 个询问，每次询问 <span class="math inline">\([L,R]\)</span> 是否能被表示为若干 <span class="math inline">\([l,r]\)</span> 的 OR（并）。</p><p><span class="math inline">\(n,m,q\le 5\times 10^5\)</span>。</p></blockquote><p>关键词：<mark>扫描线</mark> <mark>线段树维护特殊数据</mark></p><p>小清新数据结构题。题目所求等价于 check 满足 <span class="math inline">\(l\ge L\land r\le R\)</span> 的所有区间是否能够覆盖 <span class="math inline">\([L,R]\)</span>。</p><p>在考虑是不是能够用数据结构直接完成任务时，发现线段树可以维护「一段连续左端点中是否能够完整覆盖一段数」，具体地，维护每一段区间能够最远到达的右端点 <span class="math inline">\(rv\)</span>（那么显然从区间左端点到 <span class="math inline">\(rv\)</span> 都能被连续覆盖），区间内最靠右的没有被覆盖到的点 <span class="math inline">\(p\)</span>，和表示区间是否能被完整覆盖的标记 <span class="math inline">\(flag\)</span>。<span class="math inline">\(rv\)</span> 是易维护的；而 <span class="math inline">\(flag=0\)</span> 当且仅当：</p><ul><li><p>左儿子的 <span class="math inline">\(flag=0\)</span>。</p><p>此时若右儿子 <span class="math inline">\(flag=0\)</span>，那么当前结点 <span class="math inline">\(p\)</span> 可赋为右儿子的 <span class="math inline">\(p\)</span>；否则，<span class="math inline">\(p\)</span> 赋为左儿子的 <span class="math inline">\(p\)</span>。</p></li><li><p>左儿子的 <span class="math inline">\(flag=1\)</span>，但右儿子 <span class="math inline">\(flag = 0\)</span>，且左儿子的 <span class="math inline">\(rv\)</span>够不到右儿子的 <span class="math inline">\(p\)</span>。</p><p>此时当前结点的 <span class="math inline">\(p\)</span> 仍为右儿子的 <span class="math inline">\(p\)</span>，因为我们只在意最远的没有被覆盖到的点。</p></li></ul><p>容易发现如果我们在树上询问 <span class="math inline">\([L,R]\)</span> 中所有左端点的 <span class="math inline">\(flag\)</span>（询问方法和 pushup 是类似的），无法保证参与覆盖的 <span class="math inline">\(r\le R\)</span>。故离线下来扫描线，从左到右枚举每个 <span class="math inline">\(i\)</span> 作为 <span class="math inline">\(R\)</span> 的情况，把所有 <span class="math inline">\([l,i]\)</span> 插入线段树，对于每个询问 <span class="math inline">\([L,i]\)</span> 即可在树上直接查询答案。</p><p><em>bb：据说是 d1t2 水平，但我居然 1min 不到把解法大概胡出来了？希望 CQOI2025 也这么胡（双关</em></p><p><em>bb：似乎是一个全新的不需要区间修改的做法 <img src="/em/kt.gif" alt="磕头" /></em></p><details><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;const int maxn = 5e5 + 5;struct _ &#123;    bool flag;    int l, r, rv, p;&#125; t[maxn &lt;&lt; 2];#define lt (p &lt;&lt; 1)#define rt (lt | 1)void pushup(int p) &#123;    t[p].rv = std::max(t[lt].rv, t[rt].rv);    if (!t[lt].flag) &#123;        t[p].flag = 0;        if (!t[rt].flag &amp;&amp; t[lt].rv &lt; t[rt].p)            t[p].p = t[rt].p;        else            t[p].p = t[lt].p;    &#125;    else if (!t[rt].flag &amp;&amp; t[lt].rv &lt; t[rt].p)        t[p].flag = 0, t[p].p = t[rt].p;    else        t[p].flag = 1, t[p].p = 0;    return;&#125;void bld(int p, int l, int r) &#123;    t[p].l = l, t[p].r = t[p].p = r;    if (l == r)        return;    int mid = (l + r) &gt;&gt; 1;    bld(lt, l, mid), bld(rt, mid + 1, r);    return;&#125;void add(int p, int x, int v) &#123;    if(t[p].l == t[p].r) &#123;        t[p].flag = 1, t[p].p = 0;        t[p].rv = std::max(t[p].rv, v);        return;    &#125;    int mid = (t[p].l + t[p].r) &gt;&gt; 1;    if (x &lt;= mid)        add(lt, x, v);    else        add(rt, x, v);    pushup(p);    return;&#125;_ ask(int p, int l, int r) &#123;    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r)        return t[p];    int mid = (t[p].l + t[p].r) &gt;&gt; 1;    if (r &lt;= mid)        return ask(lt, l, r);    if (l &gt; mid)        return ask(rt, l, r);    auto ls(ask(lt, l, r)), rs(ask(rt, l, r));    if (!ls.flag) &#123;        if (!rs.flag &amp;&amp; ls.rv &lt; rs.p)            ls.p = rs.p;    &#125;    else if (!rs.flag &amp;&amp; ls.rv &lt; rs.p)        ls.flag = 0, ls.p = rs.p;    ls.rv = std::max(ls.rv, rs.rv);    return ls;&#125;int main() &#123;#ifdef ONLINE_JUDGE    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr), std::cout.tie(nullptr);    std::freopen(&quot;snapdragon.in&quot;, &quot;r&quot;, stdin);    std::freopen(&quot;snapdragon.out&quot;, &quot;w&quot;, stdout);#else    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);#endif    int n, m, q;    std::cin &gt;&gt; m &gt;&gt; n &gt;&gt; q;    bld(1, 1, m);    std::vector&lt;std::vector&lt;int&gt; &gt; t(m + 1);    for (int i = 1, l, r; i &lt;= n; ++i) &#123;        std::cin &gt;&gt; l &gt;&gt; r;        t[r].push_back(l);    &#125;    std::vector&lt;int&gt; res(q + 1);    std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; tq(m + 1);    for (int i = 1, l, r; i &lt;= q; ++i) &#123;        std::cin &gt;&gt; l &gt;&gt; r;        tq[r].emplace_back(l, i);    &#125;    for (int i = 1; i &lt;= m; ++i) &#123;        for (auto l : t[i])            add(1, l, i);        for (auto [l, id] : tq[i])            res[id] = ask(1, l, i).flag;    &#125;    for (int i = 1; i &lt;= q; ++i)        std::cout &lt;&lt; (res[i] ? &quot;YES&quot; : &quot;NO&quot;) &lt;&lt; &#39;\n&#39;;    return 0;&#125;</code></pre></details>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>线段树维护前缀最值序列信息</title>
      <link href="/20250217/"/>
      <url>/20250217/</url>
      
        <content type="html"><![CDATA[<p>人类不应该使用 <code>std::vector</code> 实现线段树的 2 个原因：</p><span id="more"></span><ol type="1"><li>当你的参数包含引用时，扩容操作，包括显式的 <code>resize()</code> 和隐式的 <code>push_back()</code> 均会导致引用失效。</li><li>当你的左值为引用时，由于 <code>=</code> 左右计算顺序是不确定的（C++14），由于 1 中所述原因，引用可能失效。</li><li><code>terminate called after throwing an instance of 'std::bad_alloc' what():  std::bad_alloc</code></li></ol><p>笑点解析：首先通过「……的 2 个原因」暗示声明一个长度为 2 的 <code>vector</code>，接着在试图访问第 3 个元素时抛出错误。</p><p>什么？你说我的下标是从 1 开始的？恭喜你发现了 <code>vector</code> 的第 0 个笑点。</p><hr /><h2 id="楼房重建">楼房重建</h2><p><a href="https://www.luogu.com.cn/problem/P4198" class="uri">https://www.luogu.com.cn/problem/P4198</a></p><p>考虑用线段树解决问题。难点在于如何合并两个区间的信息——直觉地，大区间的信息一定与两个子区间有关。</p><p>考虑理想的情况：我们现在知道左右两边区间的答案序列。显然我们需要保留左边整段区间，对于左区间序列末的元素 <span class="math inline">\(rv_l\)</span>，我们在右区间内找到第一个大于之的元素 <span class="math inline">\(x\)</span>，从它开始的序列就是答案。</p><p>反证法易得 <span class="math inline">\(x\)</span> 一定在右区间答案序列内：若 <span class="math inline">\(x\)</span> 不在答案序列内，则右区间内存在一个 <span class="math inline">\(&gt;x\)</span> 且位于 <span class="math inline">\(x\)</span> 之前的元素，那么 <span class="math inline">\(x\)</span> 就不是第一个 <span class="math inline">\(&gt;rv_l\)</span> 的元素，矛盾。</p><p>那么现在对于左右序列未知的情况，我们取左区间的答案，再在右区间中单 <span class="math inline">\(\log\)</span> 查找能够接上去的区间长度，加起来即可。</p><p>题目只要求总区间答案，故不需要查询。动态开点可能需要小心处理一下。</p><details><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;const int maxn = 1e5 + 5;struct &#123;    int l, r, u;    double lv, rv, mv;&#125; t[maxn &lt;&lt; 2];int tot;#define lt t[p].l#define rt t[p].rint askt(int p, int l, int r, double v) &#123;    if (l == r)        return t[p].u;    int mid = (l + r) &gt;&gt; 1;    if (lt &amp;&amp; t[p].mv &gt; v)        return t[p].u - t[lt].u + askt(lt, l, mid, v);    return askt(rt, mid + 1, r, v);&#125;void pushup(int p, int l, int r) &#123;    t[p].mv = t[lt].rv;    if (lt &amp;&amp; rt) &#123;        t[p].lv = t[lt].lv;        t[p].rv = std::max(t[lt].rv, t[rt].rv);        if (t[lt].rv &lt; t[rt].lv)            t[p].u = t[lt].u + t[rt].u;        else if (t[lt].rv &gt;= t[rt].rv)            t[p].u = t[lt].u;        else &#123;            int mid = (l + r) &gt;&gt; 1;            t[p].u = t[lt].u + askt(rt, mid + 1, r, t[lt].rv);        &#125;    &#125;    else &#123;        t[p].u = t[lt + rt].u;        t[p].lv = t[lt + rt].lv, t[p].rv = t[lt + rt].rv;    &#125;    return;&#125;void upd(int &amp;p, int l, int r, int x, double v) &#123;    if (!p)        p = ++tot;    if (l == r) &#123;        t[p].lv = t[p].rv = v, t[p].u = 1;        return;    &#125;    int mid = (l + r) &gt;&gt; 1;    if (x &lt;= mid)        upd(lt, l, mid, x, v);    else        upd(rt, mid + 1, r, x, v);    pushup(p, l, r);    return;&#125;#undef lt#undef rtint main() &#123;#ifdef ONLINE_JUDGE    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr), std::cout.tie(nullptr);#else    std::freopen(&quot;P4198_2.in&quot;, &quot;r&quot;, stdin);    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);#endif    int n, m, rt = 0;    std::cin &gt;&gt; n &gt;&gt; m;    std::vector&lt;double&gt; a(n + 1);    for (int x; m--; ) &#123;        double y;        std::cin &gt;&gt; x &gt;&gt; y;        a[x] = y / x;        upd(rt, 1, n, x, y / x);        std::cout &lt;&lt; t[1].u &lt;&lt; &#39;\n&#39;;    &#125;    return 0;&#125;</code></pre></details>]]></content>
      
      
      
        <tags>
            
            <tag> 线段树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Public Round 15 前两题</title>
      <link href="/20250216/"/>
      <url>/20250216/</url>
      
        <content type="html"><![CDATA[<p><a href="https://pjudge.ac/contest/1914">PR #15</a> 前两题题解。</p><span id="more"></span><hr /><h2 id="最小表示法">最小表示法</h2><p><a href="https://pjudge.ac/contest/1914/problem/21888" class="uri">https://pjudge.ac/contest/1914/problem/21888</a></p><p>首先不妨假设每个 <span class="math inline">\(f\)</span> 在值域内等概率取值以简化问题。那么手玩一下可以轻松地得到规律：不妨将 <span class="math inline">\(\{s\}\)</span> 循环右移一位的结果记为 <span class="math inline">\(\{t\}\)</span>，那么 <span class="math inline">\(res=\sum\frac 1{\max(|s_i|,|t_i|)}\)</span>。</p><p>这看起来令人疑惑：对于不同的 <span class="math inline">\(i\)</span>，<span class="math inline">\([f(s_i)=f(t_i)]\)</span> 的期望似乎是彼此独立的，十分奇怪。这其实与表达式的来源有关，记 <span class="math inline">\(g(s_i, j)\)</span> 表示 <span class="math inline">\(f(s_i)=j\)</span> 的概率，那么上述等式可以转写为 <span class="math inline">\(res=\sum\limits_i\sum\limits_jg({s_i},j)\times g(t_i,j)\)</span>。</p><p>那么将最小表示法带来的偏差纳入考虑范围，我们发现 <span class="math inline">\(g(s,j)\)</span> 对于不同的 <span class="math inline">\(j\)</span> 并不永远相等。具体地，当 <span class="math inline">\(s\)</span> 具有循环节时，最小循环节的第一处结尾会享有更大的取得概率。</p><p>枚举 <span class="math inline">\(s_i\)</span> 的因数作为最小循环节长度的情况，显然，对于最小循环节为 <span class="math inline">\(j\)</span> 的情况（该情况出现的概率，容斥得到 <span class="math inline">\(p_j=26^j-\sum_{k\mid j}p_k\)</span>），<span class="math inline">\(f(s_i)\)</span> 的取值在 <span class="math inline">\(1\sim j\)</span> 上等概率分布，差分即可统计每个值在不同循环节长度下被取到的概率和。</p><p>用埃筛解决每个数的因数和 <span class="math inline">\(p\)</span> 值，那么此时复杂度瓶颈在于 <span class="math inline">\(g(s_i, j)\)</span> 和 <span class="math inline">\(\sum\limits_i\sum\limits_jg({s_i},j)\times g(t_i,j)\)</span> 的求解。容易发现只有每个 <span class="math inline">\(g(s_i,j),j\mid |s_i|\)</span> 的值是有效的（其他的和它们值都相同），考虑只求解和利用这些值，类 <code>std::merge</code>（即归并排序）地求解答案。</p><p>注意特判 <span class="math inline">\(n=1\)</span>。会得到错误答案的原因是此时存在 <span class="math inline">\(s_i=t_i\)</span>，不满足基本要求。</p><details><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;const int lim = 1e5;const int mod = 998244353;int main() &#123;#ifdef ONLINE_JUDGE    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr), std::cout.tie(nullptr);#else    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);#endif    int n;    std::cin &gt;&gt; n;    if (n == 1) &#123;        std::cout &lt;&lt; 1 &lt;&lt; &#39;\n&#39;;        return 0;    &#125;    auto qkp = [](long long x, int y) &#123;        long long res = 1ll;        for (; y; y &gt;&gt;= 1, (x *= x) %= mod)            if (y &amp; 1)                (res *= x) %= mod;        return res;    &#125;;    auto inv = [&amp;](int x) &#123;        return qkp(x, mod - 2);    &#125;;    std::vector&lt;long long&gt; f(lim + 1);    std::vector&lt;std::vector&lt;int&gt; &gt; fac(lim + 1);    for (int i = 1; i &lt;= lim; ++i) &#123;        static long long now = 26;        (f[i] += now) %= mod;        fac[i].push_back(i);        for (int j = 2 * i; j &lt;= lim; j += i)            (f[j] += mod - f[i]) %= mod, fac[j].push_back(i);        (now *= 26) %= mod;    &#125;    for (int i = 1; i &lt;= lim; ++i)        (f[i] *= inv(i)) %= mod;    std::vector&lt;int&gt; a(n + 1);    struct _ &#123; int l, r; long long f; &#125;;    std::vector&lt;std::vector&lt;_&gt; &gt; g(lim + 1);    for (int i = 1; i &lt;= n; ++i) &#123;        std::cin &gt;&gt; a[i];        if (g[a[i]].empty()) &#123;            g[a[i]].resize(fac[a[i]].size());            for (int j = 0; j &lt; (int)fac[a[i]].size(); ++j) &#123;                g[a[i]][j].l = (j ? g[a[i]][j - 1].r + 1 : 1);                g[a[i]][j].r = fac[a[i]][j];                (g[a[i]][0].f += f[fac[a[i]][j]]) %= mod;                if (j != (int)fac[a[i]].size() - 1)                    (g[a[i]][j + 1].f += mod - f[fac[a[i]][j]]) %= mod;            &#125;            for (int j = 1; j &lt; (int)fac[a[i]].size(); ++j)                (g[a[i]][j].f += g[a[i]][j - 1].f) %= mod;            int getinv = inv(qkp(26, a[i]));            for (int j = 0; j &lt; (int)fac[a[i]].size(); ++j)                (g[a[i]][j].f *= getinv) %= mod;        &#125;    &#125;    std::vector&lt;int&gt; b(n + 1);    std::rotate_copy(a.begin() + 1, --a.end(), a.end(), b.begin() + 1);    long long res = 0ll;    for (int i = 1; i &lt;= n; ++i) &#123;        for (int j = 0, k = 0, now = 0;            j &lt; (int)fac[a[i]].size() &amp;&amp; k &lt; (int)fac[b[i]].size(); )            if (g[a[i]][j].r &lt; g[b[i]][k].r) &#123;                (res += g[a[i]][j].f * g[b[i]][k].f % mod                    * (g[a[i]][j].r - now) % mod) %= mod;                now = g[a[i]][j].r, ++j;            &#125;            else if (g[a[i]][j].r == g[b[i]][k].r) &#123;                (res += g[a[i]][j].f * g[b[i]][k].f % mod                    * (g[a[i]][j].r - now) % mod) %= mod;                now = g[a[i]][j].r, ++j, ++k;            &#125;            else &#123;                (res += g[a[i]][j].f * g[b[i]][k].f % mod                    * (g[b[i]][k].r - now) % mod) %= mod;                now = g[b[i]][k].r, ++k;            &#125;    &#125;    std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;    return 0;&#125;</code></pre></details><hr /><h2 id="二叉搜索树">二叉搜索树</h2><p><a href="https://pjudge.ac/contest/1914/problem/21889" class="uri">https://pjudge.ac/contest/1914/problem/21889</a></p><p>当我们处理链的部分分时，很容易想到用差分解决问题。把更新 <span class="math inline">\([l, r]\)</span> 看作在差分数组 <span class="math inline">\(l\)</span> 处插入，在 <span class="math inline">\(r+1\)</span> 处删除，离线下来再从左到右扫一遍操作，考虑如何解决查询问题。</p><p>考虑如何获取 <span class="math inline">\(i\)</span> 树上 <span class="math inline">\(t_0\)</span> 时刻点 <span class="math inline">\(x\)</span> 的所有祖先。根据前面的操作，我们可以获取 <span class="math inline">\(i\)</span> 树上存在过的所有元素。</p><p>对于比 <span class="math inline">\(x\)</span> 大的元素，考虑祖先 <span class="math inline">\(p_a\)</span> 和非祖先 <span class="math inline">\(p\)</span> 有什么区别。根据 BST 的性质易得，对于最低的右侧祖先 <span class="math inline">\({p_a}_0\)</span>，其是 <span class="math inline">\(\ge x\)</span> 的最小的元素（当然其加入时刻 <span class="math inline">\(t_a&lt;t_0\)</span>）；那么同理可以找到 <span class="math inline">\({p_a}_0\)</span> 右侧最低的祖先（其左侧的祖先显然也 <span class="math inline">\(x\)</span> 左侧），该祖先满足 <span class="math inline">\(t&lt;t_a\)</span>。那么我们就从左右两边分别得到 <span class="math inline">\(x\)</span> 的所有祖先。容易证明该过程对于不在树上的 <span class="math inline">\(x\)</span> 也是正确的。</p><p>具体地，我们需要一个数据结构，能够求出 <span class="math inline">\(\ge x\)</span> 的元素中，以 <span class="math inline">\(t_0\)</span> 为起点的前缀最小值序列的区间和。</p><p>欸 ☝🤓 这是什么？<a href="/20250217">楼房重建</a>！秒一下！</p><p>进一步地，本题需要完成对于 <span class="math inline">\(t_0\)</span> 为序列头的查询。再次利用性质，每次 <span class="math inline">\(O(\log V)\)</span> 地合并答案。</p><p>好的那么怎么把链搞到树上呢？把差分放到树上，写个线段树合并即可。</p><p><strong>注意由于这题细节太多了，所以你可能需要舍弃不必要的时空优化换取代码简洁度以方便调试。</strong></p><details><pre data-line="12" class="cpp language-cpp"><code data-line="12" class="cpp language-cpp">#include &lt;bits/stdc++.h&gt;const int lim = 2e5;const int maxn = 2e7 + 5;const int inf = 0x3f3f3f3f;struct &#123;    int l, r, rv;    long long u;&#125; t[maxn];std::vector&lt;int> tr;#define lt t[p].l#define rt t[p].rint newnode(void) &#123;         // 我知道你要说什么，但这属于「必要的」空间优化 😥    static int tot = 0;    if (tr.empty())        return ++tot;    auto p(tr.back());    t[p].l = t[p].r = 0;    tr.pop_back();    return p;&#125;long long askv(int p, int l, int r, int v) &#123;    if (l == r)        return t[p].rv < v ? t[p].u : 0;    int mid = (l + r) >> 1;    if (v > t[lt].rv)        return t[p].u - t[lt].u + askv(lt, l, mid, v);    return askv(rt, mid + 1, r, v);&#125;void pushup(int p, int l, int r) &#123;    t[p].rv = std::min(t[lt].rv, t[rt].rv);    int mid = (l + r) >> 1;    t[p].u = t[lt].u + askv(rt, mid + 1, r, t[lt].rv);    return;&#125;void upd(int &p, int l, int r, int x, int v, int u) &#123;    if (!p)        p = newnode();    if (l == r) &#123;        t[p].rv = v, t[p].u = u;        return;    &#125;    int mid = (l + r) >> 1;    if (x <= mid)        upd(lt, l, mid, x, v, u);    else        upd(rt, mid + 1, r, x, v, u);    pushup(p, l, r);    return;&#125;void merge(int &p, int q, int l, int r) &#123;    if (!p || !q) &#123;        p += q;        return;    &#125;    if (l == r) &#123;        t[p].rv = std::min(t[p].rv, t[q].rv);        t[p].u = std::max(t[p].u, t[q].u);        return;    &#125;    int mid = (l + r) >> 1;    merge(t[p].l, t[q].l, l, mid), merge(t[p].r, t[q].r, mid + 1, r);    pushup(p, l, r), tr.push_back(q);    return;&#125;int qv = inf;long long ask(int p, int l, int r, int ql, int qr) &#123;    if (ql <= l && r <= qr) &#123;        auto s(askv(p, l, r, qv));        qv = std::min(qv, t[p].rv);        return s;    &#125;    int mid = (l + r) >> 1;    long long res = 0ll;    if (ql <= mid)        res = ask(lt, l, mid, ql, qr);    if (qr > mid)        res += ask(rt, mid + 1, r, ql, qr);    return res;&#125;#undef lt#undef rtint main() &#123;#ifdef ONLINE_JUDGE    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr), std::cout.tie(nullptr);#else    std::freopen("ex_problem4.in", "r", stdin);    std::freopen(".out", "w", stdout);#endif    int n, m;    std::cin >> n >> m;    std::vector&lt;std::vector&lt;int> > g(n + 1);    for (int i = 1, x, y; i < n; ++i) &#123;        std::cin >> x >> y;        g[x].push_back(y), g[y].push_back(x);    &#125;    std::vector&lt;int> top(n + 1), fa(n + 1), siz(n + 1), son(n + 1), dep(n + 1);    std::function&lt;void(int, int)> DFS = [&](int x, int faa) &#123;        siz[x] = 1;        for (auto i : g[x])            if (i != faa) &#123;                fa[i] = x, dep[i] = dep[x] + 1;                DFS(i, x), siz[x] += siz[i];                if (siz[i] > siz[son[x]])                    son[x] = i;            &#125;        return;    &#125;;    DFS(1, -1);    DFS = [&](int x, int topp) &#123;        top[x] = topp;        if (son[x])            DFS(son[x], topp);        for (auto i : g[x])            if (i != fa[x] && i != son[x])                DFS(i, i);        return;    &#125;;    DFS(1, 1);    auto getLCA = [&](int x, int y) &#123;        for (; top[x] != top[y]; x = fa[top[x]])            if (dep[top[y]] > dep[top[x]])                std::swap(x, y);        return (dep[x] < dep[y] ? x : y);    &#125;;    std::vector&lt;std::vector&lt;int> > d(n + 1);    std::vector&lt;std::vector&lt;std::pair&lt;int, int> > > u(n + 1);    std::vector&lt;std::vector&lt;std::tuple&lt;int, int, int> > > q(n + 1);    int cnt = 0;    for (int i = 1; i <= m; ++i) &#123;        int op;        std::cin >> op;        if (op == 0) &#123;            int x, v;            std::cin >> x >> v;            q[x].emplace_back(++cnt, i, v);        &#125; else &#123;            int x, y, v;            std::cin >> x >> y >> v;            int faa = getLCA(x, y);            u[x].emplace_back(i, v), u[y].emplace_back(i, v);            if (fa[faa])                d[fa[faa]].emplace_back(v);        &#125;    &#125;    std::vector&lt;long long> res(cnt + 1);    std::vector&lt;std::vector&lt;int> > rt(2, std::vector&lt;int> (n + 1));    t[0].rv = inf;    DFS = [&](int x, int fa) &#123;        for (auto i : g[x])            if (i != fa) &#123;                DFS(i, x);                merge(rt[0][x], rt[0][i], 1, lim);                merge(rt[1][x], rt[1][i], 1, lim);            &#125;        for (auto [t, v] : u[x]) &#123;            upd(rt[0][x], 1, lim, v, t, v);            upd(rt[1][x], 1, lim, lim - v + 1, t, v);        &#125;        for (auto v : d[x]) &#123;            upd(rt[0][x], 1, lim, v, inf, 0);            upd(rt[1][x], 1, lim, lim - v + 1, inf, 0);        &#125;        for (auto [id, t, v] : q[x]) &#123;            qv = t, res[id] = ask(rt[0][x], 1, lim, v, lim);            qv = t, res[id] += ask(rt[1][x], 1, lim, lim - v + 1, lim);            qv = t, res[id] -= ask(rt[0][x], 1, lim, v, v);        &#125;    &#125;;    DFS(1, -1);    for (int i = 1; i <= cnt; ++i)        std::cout << res[i] << '\n';    return 0;&#125;</code></pre></details>]]></content>
      
      
      
        <tags>
            
            <tag> 线段树 </tag>
            
            <tag> 数学 </tag>
            
            <tag> 树上差分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构杂烩</title>
      <link href="/20250210/"/>
      <url>/20250210/</url>
      
        <content type="html"><![CDATA[<p>ds is fun ——<span class="citation" data-cites="crashed">@crashed</span></p><span id="more"></span><hr /><h2 id="warm-up-i">Warm up! I</h2><h3 id="多重集-彩虹蛋糕">多重集 / 彩虹蛋糕</h3><p><a href="http://222.180.160.110:61235/contest/6010/problem/7" class="uri">http://222.180.160.110:61235/contest/6010/problem/7</a></p><p>好像并不是第一次见了？<mark>像是把几个二元组的同一维拿来整活，可以考虑恒等变形转化为偏序问题</mark>。</p><p>若 <span class="math inline">\(a_{i,0}+b_{j,0}\ge a_{i,1}+b_{j,1}\)</span>，则 <span class="math inline">\(a_{i,0}-a_{i,1}\ge b_{j,1}-b_{j,0}\)</span>。如果我们把 <span class="math inline">\(a\)</span> 按照 <span class="math inline">\(a_{i,0}-a_{i,1}\)</span> 排序并把 <span class="math inline">\(b\)</span> 按照 <span class="math inline">\(b_{j,1}-b_{j,0}\)</span> 排序，那么若需要求某个时刻的答案，需要对于每一个 <span class="math inline">\(i\)</span>，找到最小的 <span class="math inline">\(b_{j,0}\)</span>，使得 <span class="math inline">\(b_{j,1}-b_{j,0}\)</span> 在 <span class="math inline">\([-\infty, a_{i,0}-a_{i,1}]\)</span> 中，同时找到最小的 <span class="math inline">\(b_{j,1}\)</span>，使得 <span class="math inline">\(b_{j,1}-b_{j,0}\)</span> 在 <span class="math inline">\([a_{i, 0}-a_{i,1},+\infty]\)</span> 中。</p><p>那么有一个很神的方法（似乎也不是第一次遇到了但总结不出来 <img src="/em/yun.gif" alt="晕" />），我们在线段树 pushup 的时候，尝试用左边的 <span class="math inline">\(b_{j,0}\)</span> 更新右边的答案。</p><p><em>牢游说之所以觉得很熟悉是因为我之前 % 你赛做到过这道题还 A 了？？？离谱的。</em></p><p>为啥 llsw 一定说是离线啊 <img src="/em/yun.gif" alt="晕" /> 想不到什么好的离线解决时间限制的方案 <img src="/em/yun.gif" alt="晕" /> 所以还是在线。</p><details><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;const int inf = 2e9 + 1;struct _ &#123; long long aa, ab, ba, bb, u; int l, r, id; &#125;;std::vector&lt;_&gt; t(1);std::vector&lt;std::multiset&lt;long long&gt; &gt; aa(1), ab(1), ba(1), bb(1);int tot, cnt;#define lt t[p].l#define rt t[p].rvoid pushup(int p) &#123;    t[p].aa = t[p].ab = t[p].ba = t[p].bb = t[p].u = inf;    if (lt) &#123;        t[p].u = t[lt].u;        t[p].aa = t[lt].aa, t[p].ab = t[lt].ab, t[p].ba = t[lt].ba, t[p].bb = t[lt].bb;    &#125;    if (rt) &#123;        t[p].u = std::min(t[p].u, t[rt].u);        t[p].aa = std::min(t[p].aa, t[rt].aa), t[p].ab = std::min(t[p].ab, t[rt].ab), t[p].ba = std::min(t[p].ba, t[rt].ba), t[p].bb = std::min(t[p].bb, t[rt].bb);    &#125;    if (lt &amp;&amp; rt)        t[p].u = std::min(&#123; t[p].u, t[lt].ba + t[rt].aa, t[lt].ab + t[rt].bb &#125;);    return;&#125;int adda(int p, long long l, long long r, int x, int a, int b) &#123;    if (!p)        p = ++tot, t.emplace_back(), t[p].aa = t[p].ab = t[p].ba = t[p].bb = t[p].u = inf;    if (l == r) &#123;        if (!t[p].id)            t[p].id = ++cnt, aa.emplace_back(), ab.emplace_back(), ba.emplace_back(), bb.emplace_back();        int id = t[p].id;        aa[id].insert(a), ab[id].insert(b);        t[p].aa = *aa[id].begin(), t[p].ab = *ab[id].begin();        if (!aa[id].empty() &amp;&amp; !ba[id].empty())            t[p].u = std::min(*aa[id].begin() + *ba[id].begin(), *ab[id].begin() + *bb[id].begin());        else            t[p].u = inf;        return p;    &#125;    long long mid = (l + r) &gt;&gt; 1;    if (x &lt;= mid) &#123;        auto s(adda(lt, l, mid, x, a, b));        lt = s;    &#125;    else &#123;        auto s(adda(rt, mid + 1, r, x, a, b));        rt = s;    &#125;    pushup(p);    return p;&#125;int addb(int p, long long l, long long r, int x, int a, int b) &#123;    if (!p)        p = ++tot, t.emplace_back(), t[p].aa = t[p].ab = t[p].ba = t[p].bb = t[p].u = inf;    if (l == r) &#123;        if (!t[p].id)            t[p].id = ++cnt, aa.emplace_back(), ab.emplace_back(), ba.emplace_back(), bb.emplace_back();        int id = t[p].id;        ba[id].insert(a), bb[id].insert(b);        t[p].ba = *ba[id].begin(), t[p].bb = *bb[id].begin();        if (!aa[id].empty() &amp;&amp; !ba[id].empty())            t[p].u = std::min(*aa[id].begin() + *ba[id].begin(), *ab[id].begin() + *bb[id].begin());        else            t[p].u = inf;        return p;    &#125;    long long mid = (l + r) &gt;&gt; 1;    if (x &lt;= mid) &#123;        auto s(addb(lt, l, mid, x, a, b));        lt = s;    &#125;    else &#123;        auto s(addb(rt, mid + 1, r, x, a, b));        rt = s;    &#125;    pushup(p);    return p;&#125;void dela(int p, long long l, long long r, int x, int a, int b) &#123;    if (l == r) &#123;        int id = t[p].id;        aa[id].erase(aa[id].find(a)), ab[id].erase(ab[id].find(b));        t[p].aa = (aa[id].empty() ? inf : *aa[id].begin());        t[p].ab = (ab[id].empty() ? inf : *ab[id].begin());        if (!aa[id].empty() &amp;&amp; !ba[id].empty())            t[p].u = std::min(*aa[id].begin() + *ba[id].begin(), *ab[id].begin() + *bb[id].begin());        else            t[p].u = inf;        return;    &#125;    long long mid = (l + r) &gt;&gt; 1;    if (x &lt;= mid)        dela(lt, l, mid, x, a, b);    else        dela(rt, mid + 1, r, x, a, b);    pushup(p);    return;&#125;void delb(int p, long long l, long long r, int x, int a, int b) &#123;    if (l == r) &#123;        int id = t[p].id;        ba[id].erase(ba[id].find(a)), bb[id].erase(bb[id].find(b));        t[p].ba = (ba[id].empty() ? inf : *ba[id].begin());        t[p].bb = (bb[id].empty() ? inf : *bb[id].begin());        if (!aa[id].empty() &amp;&amp; !ba[id].empty())            t[p].u = std::min(*aa[id].begin() + *ba[id].begin(), *ab[id].begin() + *bb[id].begin());        else            t[p].u = inf;        return;    &#125;    long long mid = (l + r) &gt;&gt; 1;    if (x &lt;= mid)        delb(lt, l, mid, x, a, b);    else        delb(rt, mid + 1, r, x, a, b);    pushup(p);    return;&#125;#undef lt#undef rtint main() &#123;#ifdef ONLINE_JUDGE    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr), std::cout.tie(nullptr);    std::freopen(&quot;set.in&quot;, &quot;r&quot;, stdin);    std::freopen(&quot;set.out&quot;, &quot;w&quot;, stdout);#else    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);#endif    int q, rt = 0;    std::cin &gt;&gt; q;    for (int i = 1; i &lt;= q; ++i) &#123;        int op, d, a, b;        std::cin &gt;&gt; op &gt;&gt; d &gt;&gt; a &gt;&gt; b;        if (op == 0 &amp;&amp; d == 0)            dela(rt, -inf, inf, a - b, a, b);        else if (op == 0)            delb(rt, -inf, inf, b - a, a, b);        else if (d == 0)            rt = adda(rt, -inf, inf, a - b, a, b);        else            rt = addb(rt, -inf, inf, b - a, a, b);        std::cout &lt;&lt; (t[1].u == inf ? -1 : t[1].u) &lt;&lt; &#39;\n&#39;;    &#125;    return 0;&#125;</code></pre></details><h3 id="青蛙题">青蛙题</h3><p><a href="http://222.180.160.110:61235/contest/6010/problem/1" class="uri">http://222.180.160.110:61235/contest/6010/problem/1</a></p><p><em>全程都是被牵着鼻子走捏。自己的大脑完全没有运转捏。开摆！</em></p><p>llsw：哎其实 <mark>碰到这种区间里面找区间的问题的话 <strong>扫描线</strong> 算是常见思路了</mark>。</p><p>我们会发现想到区间种类数我们会有几种思路：集合哈希、前驱后继 + 人类智慧、莫队之类的。这道题感觉是可以用集合哈希做的，但是看了一眼原题出自 Ynoi，哈哈，这道题感觉是不能用集合哈希做的 <img src="/em/ll.gif" alt="流泪" />。</p><p>大致思路是，对于 <span class="math inline">\(i=1\sim n\)</span>，依次考虑 <span class="math inline">\(i\)</span> 作为右端点的情况。线段树维护每个 <span class="math inline">\(j\)</span> 作为左端点时的 <span class="math inline">\(i-r_j\)</span>，其中 <span class="math inline">\([j, r_j]\)</span> 是与 <span class="math inline">\([j,i]\)</span> 种类相同的最小区间。</p><p>那么询问的时候，只需要找到最大的 <span class="math inline">\(j&#39;\)</span>，满足 <span class="math inline">\([j, r]\)</span> 与 <span class="math inline">\([l, r]\)</span> 种类相同，求解 <span class="math inline">\([l, j&#39;]\)</span> 的区间和即可。怎么找到 <span class="math inline">\(j&#39;\)</span> 呢？这里就用到了前驱后继 + 人类智慧法。初始每个 <span class="math inline">\(l\)</span> 对应的 <span class="math inline">\(j&#39;\)</span> 就是自己，若加入了一个与 <span class="math inline">\(l\)</span> 相同的新元素，那么 <span class="math inline">\(l\)</span> 就不再有贡献，此时 <span class="math inline">\(l\)</span> 的 <span class="math inline">\(j&#39;\)</span> 就会继承 <span class="math inline">\(l+1\)</span> 的 <span class="math inline">\(j&#39;\)</span>，这个过程用并查集即可简单维护。</p><details><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;const int lim = 2e6;const int maxn = 2e6 + 5;const int maxm = 5e7 + 5;const int inf = 0x3f3f3f3f;struct &#123; int l, r, u, d; &#125; t[maxn &lt;&lt; 2];int tot;#define lt (p &lt;&lt; 1)#define rt (lt | 1)void pushdown(int p) &#123;    if (~t[p].d) &#123;        t[lt].d = t[rt].d = t[p].d;        t[lt].u = t[p].d - t[lt].r + 1;        t[rt].u = t[p].d - t[rt].r + 1;        t[p].d = -1;    &#125;    return;&#125;void bld(int p, int l, int r) &#123;    t[p].l = l, t[p].r = r, t[p].d = -1;    if (l == r)        return;    int mid = (l + r) &gt;&gt; 1;    bld(lt, l, mid), bld(rt, mid + 1, r);    return;&#125;void upd(int p, int l, int r, int v) &#123;    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r) &#123;        t[p].d = v, t[p].u = v - t[p].r + 1;        return;    &#125;    pushdown(p);    int mid = (t[p].l + t[p].r) &gt;&gt; 1;    if (l &lt;= mid)        upd(lt, l, r, v);    if (r &gt; mid)        upd(rt, l, r, v);    t[p].u = std::min(t[lt].u, t[rt].u);    return;&#125;int ask(int p, int l, int r) &#123;    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r)        return t[p].u;    pushdown(p);    int mid = (t[p].l + t[p].r) &gt;&gt; 1, res = inf;    if (l &lt;= mid)        res = ask(lt, l, r);    if (r &gt; mid)        res = std::min(res, ask(rt, l, r));    return res;&#125;#undef lt#undef rtint main() &#123;#ifdef ONLINE_JUDGE    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr), std::cout.tie(nullptr);#else    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);#endif    int n, q;    std::cin &gt;&gt; n;    std::vector&lt;int&gt; a(n + 1), la(lim + 1), pre(n + 1), f(n + 1);    for (int i = 1; i &lt;= n; ++i) &#123;        std::cin &gt;&gt; a[i];        pre[i] = la[a[i]], la[a[i]] = i, f[i] = i;    &#125;    std::cin &gt;&gt; q;    std::vector&lt;int&gt; res(q + 1);    std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; t(n + 1);    for (int i = 1, l, r; i &lt;= q; ++i) &#123;        std::cin &gt;&gt; l &gt;&gt; r;        t[r].emplace_back(l, i);    &#125;    bld(1, 1, n);    std::function&lt;int(int)&gt; find = [&amp;](int x) &#123;        return x == f[x] ? x : f[x] = find(f[x]);    &#125;;    auto merge = [&amp;](int x, int y) &#123;        x = find(x), y = find(y);        f[std::min(x, y)] = std::max(x, y);        return;    &#125;;    for (int r = 1; r &lt;= n; ++r) &#123;        if (pre[r])            merge(pre[r], pre[r] + 1);        upd(1, pre[r] + 1, r, r);        for (auto [l, i] : t[r])            res[i] = ask(1, l, find(l));    &#125;    for (int i = 1; i &lt;= q; ++i)        std::cout &lt;&lt; res[i] &lt;&lt; &#39;\n&#39;;    return 0;&#125;</code></pre></details>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习笔记：后缀数组</title>
      <link href="/20250202/"/>
      <url>/20250202/</url>
      
        <content type="html"><![CDATA[<p>非常后知后觉地意识到 SA(Suffix Array) 和 SAM(Suffix Automaton) 的 A 不是同一个 A <img src="/em/fad.gif" /></p><span id="more"></span><hr /><h2 id="定义">定义</h2><p>显而易见一个长度为 <span class="math inline">\(n\)</span> 的字符串中有 <span class="math inline">\(n\)</span> 个长度分别为 <span class="math inline">\(1\sim n\)</span> 的后缀，如果我们对其按字典序排序，分别存储下排名 <span class="math inline">\(i\)</span> 的后缀 <span class="math inline">\(sa_i\)</span> 和每个后缀 <span class="math inline">\(i\)</span> 的排名 <span class="math inline">\(rk_i\)</span>。虽然看着挺没头没尾的，但是很有用。</p><h2 id="求解">求解</h2><h3 id="哈希-排序">哈希 + 排序</h3><p>直接把所有后缀拿来排序的话，字符串比较是 <span class="math inline">\(O(n)\)</span> 的。如果我们用哈希 + 二分优化比较过程，就可以把整个排序优化到 <span class="math inline">\(O(n\log^2 n)\)</span>。</p><h3 id="倍增">倍增</h3><p>先对所有后缀按 <strong>第一个字符</strong> 排序，记排序后排名序列为 <span class="math inline">\(a\)</span>。</p><p>那么怎么按 <strong>前两个字符</strong> 排序呢？对于第 <span class="math inline">\(i\)</span> 组字符，我们用 <span class="math inline">\((a_i,a_{i+1})\)</span> 双关键字排序即可。记此时排名序列为 <span class="math inline">\(b\)</span>，那么如果需要按照前四个字符排序，用 <span class="math inline">\((b_i,b_{i+2})\)</span> 进行双关键字排序即可。总共需要进行 <span class="math inline">\(\log n\)</span> 次排序。复杂度为 <span class="math inline">\(O(n\log^2n)\)</span>。</p><p>此时我们注意到排名数组的值域为 <span class="math inline">\(n\)</span>，那么我们用桶排就能少一个 <span class="math inline">\(\log\)</span>。</p><h2 id="实现">实现</h2><p>哈希很好实现，这里就按下不表，主要讲解倍增法的实现。</p><p>描述起来很简单，实现起来很要命。OI wiki 上的实现算是相对好理解的：</p><p>首先了解双关键字桶排的方法，首先用单关键字桶排完成对 <strong>第二关键字</strong> 的排序；对于第一关键字，令桶 <span class="math inline">\(i\)</span> 记录前 <span class="math inline">\(i\)</span> 个元素的数量；遍历排序后的第二关键字数组，将元素放到桶中记录数值对应的下标中，并将桶中数值 <span class="math inline">\(-1\)</span>。实际上桶 <span class="math inline">\(c\)</span> 充当计算下标范围的作用，<span class="math inline">\((c_{i-1},c_i]\)</span> 即为 <span class="math inline">\(i\)</span> 分布的范围。</p><p>显然，当且仅当排名种类为 <span class="math inline">\(n\)</span>，即没有并列排名时，排序完成。设本轮区间长度为 <span class="math inline">\(w\)</span>，对于一轮操作：</p><ol type="1"><li>计算每个区间按后半段 <span class="math inline">\(\frac w2\)</span> 长度字符排序的结果：<span class="math inline">\((n-w,n]\)</span> 开头的区间后半段均为空，直接放在序列首端；接着按照上一轮 <span class="math inline">\(sa\)</span> 结果，把能够作为后半段的元素依次放入。</li><li>依照上一轮的 <span class="math inline">\(rk\)</span> 作为前半段排名，进行双关键字桶排。</li><li>依照 <span class="math inline">\(sa\)</span> 和第二关键字（处理并列），求出 <span class="math inline">\(rk\)</span>。</li></ol><details><pre class="cpp"><code>std::vector&lt;int&gt; la(n + 2);std::copy(s.begin(), s.end(), rk.begin());int m = 128;&#123;    std::vector&lt;int&gt; c(m + 1);    for (int i = 1; i &lt;= n; ++i)        ++c[rk[i]];    std::partial_sum(c.begin(), c.end(), c.begin());    for (int i = n; i; --i)        sa[c[rk[i]]--] = i;&#125; for (int w = 1, p; ; w &lt;&lt;= 1, m = p) &#123;    std::vector&lt;int&gt; id(1);    for (int i = n - w + 1; i &lt;= n; ++i)        id.push_back(i);    for (int i = 1; i &lt;= n; ++i)        if (sa[i] &gt; w)            id.push_back(sa[i] - w);    std::vector&lt;int&gt; c(m + 1);    for (int i = 1; i &lt;= n; ++i)        ++c[rk[i]];    std::partial_sum(c.begin(), c.end(), c.begin());    for (int i = n; i; --i)        sa[c[rk[id[i]]]--] = id[i];    p = 0;    std::copy(rk.begin(), rk.end(), la.begin());    for (int i = 1; i &lt;= n; ++i)        if (la[sa[i]] == la[sa[i - 1]] &amp;&amp; la[sa[i] + w] == la[sa[i - 1] + w])            rk[sa[i]] = p;        else            rk[sa[i]] = ++p;    if (p == n)        break;&#125;</code></pre></details><hr /><h2 id="纯-sa-的应用">纯 SA 的应用</h2><h3 id="最小表示法">最小表示法</h3><p>模板：<a href="https://www.luogu.com.cn/problem/P1368" class="uri">https://www.luogu.com.cn/problem/P1368</a>。</p><p>对于循环位移相关要求，首先考虑将字符串重复一遍。</p><p>在 <span class="math inline">\(ss\)</span> 中找到排名第一个 <span class="math inline">\(sa_i\le n\)</span> 即为答案。</p><details><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;int main() &#123;#ifdef ONLINE_JUDGE    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr), std::cout.tie(nullptr);#else    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);#endif    int n;    std::cin &gt;&gt; n;    std::vector&lt;int&gt; s(2 * n + 1);    for (int i = 1; i &lt;= n; ++i)        std::cin &gt;&gt; s[i], s[n + i] = s[i];    std::vector&lt;int&gt; sa(2 * n + 1), rk(s);    &#123;        int m = 29;        &#123;            std::vector&lt;int&gt; c(m + 1);            for (int i = 1; i &lt;= 2 * n; ++i)                ++c[rk[i]];            std::partial_sum(c.begin(), c.end(), c.begin());            for (int i = 2 * n; i; --i)                sa[c[rk[i]]--] = i;        &#125;        for (int w = 1, p; ; w &lt;&lt;= 1, m = p) &#123;            std::vector&lt;int&gt; id(1);            for (int i = 2 * n - w + 1; i &lt;= 2 * n; ++i)                id.push_back(i);            for (int i = 1; i &lt;= 2 * n; ++i)                if (sa[i] &gt; w)                    id.push_back(sa[i] - w);            std::vector&lt;int&gt; c(m + 1);            for (int i = 1; i &lt;= 2 * n; ++i)                ++c[rk[i]];            std::partial_sum(c.begin(), c.end(), c.begin());            for (int i = 2 * n; i; --i)                sa[c[rk[id[i]]]--] = id[i];            auto la(rk);            p = 0;            for (int i = 1; i &lt;= 2 * n; ++i)                if (i != 1 &amp;&amp; la[sa[i]] == la[sa[i - 1]] &amp;&amp; la[sa[i] + w] == la[sa[i - 1] + w])                    rk[sa[i]] = p;                else                    rk[sa[i]] = ++p;            if (p == 2 * n)                break;        &#125;    &#125;    for (int i = 1; i &lt;= 2 * n; ++i)        if (sa[i] &lt;= n) &#123;            for (int j = sa[i]; j &lt; n + sa[i]; ++j)                std::cout &lt;&lt; s[j] &lt;&lt; &#39; &#39;;            std::cout &lt;&lt; &#39;\n&#39;;            break;        &#125;    return 0;&#125;</code></pre></details><hr /><h3 id="字符串匹配">字符串匹配</h3><p>二分，复杂度 <span class="math inline">\(O(|S|\log |T|)\)</span>。求出现次数则二分左右边界。</p><p>太麻烦了且没有实际应用价值，代码略。</p><hr /><h2 id="height-数组">height 数组</h2><p>定义 <span class="math inline">\(h_i=\text {lcp}(sa_i, sa_i-1)\)</span>，特别地，<span class="math inline">\(h_1=0\)</span>。</p><blockquote><p>有引理：<span class="math inline">\(h_{rk_i}\ge h_{rk_{i-1}}-1\)</span>。</p></blockquote><p>假设已经求出 <span class="math inline">\(h_{rk_{i-1}}\)</span>，那么可以从 <span class="math inline">\(h_{rk_{i-1}}-1\)</span> 出发暴力看下一个字符是否相等得到答案。那么我们会发现从前往后 <span class="math inline">\(h\)</span> 值每次最多 <span class="math inline">\(-1\)</span>，所以复杂度摊下来是 <span class="math inline">\(O(n)\)</span> 的。</p><p><mark>记住记住一定是 <span class="math inline">\(rk_{i-1}\)</span> 而不是下意识的 <span class="math inline">\(rk_i-1\)</span>！！！</mark>所以为了保证求解顺序循环枚举的一定是下标而非排名。但是注意定义却是和 <span class="math inline">\(rk_i-1\)</span> 的 lcp！！！所以求 height 的写法是相对固定的，不能觉得好像是对的就随便乱改。</p><hr /><h2 id="height-数组的应用">height 数组的应用</h2><p>相当于背板子，因为应用太多且形式大多固定。</p><h3 id="求任意两个后缀的-lcp">求任意两个后缀的 lcp</h3><p>易得 <span class="math inline">\(\text{lcp}(sa_i, sa_j)=\min\{h_{i+1}, \cdots, h_j\}\)</span>。<strong>故应将一些复杂 lcp 问题的解决方式和 RMQ 联系起来</strong>。</p><hr /><h3 id="子串大小关系">子串大小关系</h3><p>即比较 <span class="math inline">\(S_{l_1, r_1}\)</span> 和 <span class="math inline">\(S_{l_2, r_2}\)</span> 的大小关系。比较导致 lcp 不能继续延伸的元素大小即可。</p><hr /><h3 id="本质不同子串数量">本质不同子串数量</h3><p><strong>子串等价于「后缀的前缀」</strong>。按顺序枚举每个后缀，减去和已枚举的所有后缀的 lcp 即可。鉴于 <span class="math inline">\(\min\{h_{j+1},\cdots,h_i\}\)</span> 单调不减，直接减去 <span class="math inline">\(h_i\)</span> 即可。</p><p>最后答案即为 <span class="math inline">\(\frac {n(n-1)}2 - \sum\limits_{i=2}^nh_i\)</span>。</p><hr /><h3 id="至少出现-k-次子串的最大长度">至少出现 <span class="math inline">\(k\)</span> 次子串的最大长度</h3><p>模板：<a href="https://www.luogu.com.cn/problem/P2852" class="uri">https://www.luogu.com.cn/problem/P2852</a>。</p><p>出现 <span class="math inline">\(k\)</span> 次 <span class="math inline">\(\iff\)</span> 在后缀数组中连续出现 <span class="math inline">\(k\)</span> 次 <span class="math inline">\(\iff\)</span> 是任意连续 <span class="math inline">\(k-1\)</span> 个 <span class="math inline">\(h\)</span> 的最小值，需要最大化该最小值，考虑滑动窗口。</p><details><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;int main() &#123;#ifdef ONLINE_JUDGE    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr), std::cout.tie(nullptr);#else    std::freopen(&quot;P2852_7.in&quot;, &quot;r&quot;, stdin);    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);#endif    int n, k;    std::cin &gt;&gt; n &gt;&gt; k, --k;    std::vector&lt;int&gt; s(n + 1);    for (int i = 1; i &lt;= n; ++i)        std::cin &gt;&gt; s[i];    std::vector&lt;int&gt; sa(n + 1), rk(s), h(n + 1);    &#123;        int m = 1000001;        &#123;            std::vector&lt;int&gt; c(m + 1);            for (int i = 1; i &lt;= n; ++i)                ++c[rk[i]];            std::partial_sum(c.begin(), c.end(), c.begin());            for (int i = n; i; --i)                sa[c[rk[i]]--] = i;        &#125;        for (int w = 1, p; ; w &lt;&lt;= 1, m = p) &#123;            std::vector&lt;int&gt; id(1);            for (int i = n - w + 1; i &lt;= n; ++i)                id.push_back(i);            for (int i = 1; i &lt;= n; ++i)                if (sa[i] &gt; w)                    id.push_back(sa[i] - w);            std::vector&lt;int&gt; c(m + 1);            for (int i = 1; i &lt;= n; ++i)                ++c[rk[i]];            std::partial_sum(c.begin(), c.end(), c.begin());            for (int i = n; i; --i)                sa[c[rk[id[i]]]--] = id[i];            auto la(rk);            p = 0;            for (int i = 1; i &lt;= n; ++i)                if (i != 1 &amp;&amp; la[sa[i]] == la[sa[i - 1]] &amp;&amp; la[sa[i] + w] == la[sa[i - 1] + w])                    rk[sa[i]] = p;                else                    rk[sa[i]] = ++p;            if (p == n)                break;        &#125;        for (int i = 1, to = 0; i &lt;= n; ++i)            if (rk[i]) &#123;                for (to = std::max(to - 1, 0); s[i + to] == s[sa[rk[i] - 1] + to]; ++to);                h[rk[i]] = to;            &#125;    &#125;    std::vector&lt;int&gt; q(n + 1);    int res = 0;    for (int i = 1, l = 1, r = 0; i &lt;= n; ++i) &#123;        // printf(&quot;%d\n&quot;, h[i]);        for (; l &lt;= r &amp;&amp; i - q[l] &gt;= k; ++l);        for (; l &lt;= r &amp;&amp; h[i] &lt;= h[q[r]]; --r);        q[++r] = i;        if (i &gt;= k)            res = std::max(res, h[q[l]]);    &#125;    std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;    return 0;&#125;</code></pre></details><hr /><h3 id="最长不重叠多次出现子串">最长不重叠多次出现子串</h3><p><del>bb：定式太多太杂以至于让人怀疑某些定式是否存在应用场景</del> <img src="/em/kt.gif" /></p><p>发现满足单调性，二分子串长度 <span class="math inline">\(len\)</span>，那么显然 <span class="math inline">\(\text {lcp}\ge len\)</span>；将 <span class="math inline">\(h\)</span> 划分为连续 <span class="math inline">\(\ge len\)</span> 的段，在每段内找到下标极差与 <span class="math inline">\(len\)</span> 比较即可。</p><p>也可以用于判定是否存在不重叠多次出现子串。</p><p>甚至可以考虑限制至少出现次数为 <span class="math inline">\(k\)</span>，那大概多个 <span class="math inline">\(\log\)</span>，看看一段里有没有 <span class="math inline">\(\ge k\)</span> 个相互相差 <span class="math inline">\(\ge len\)</span> 的。排序贪心求解。</p><p>那么上面的至少出现 <span class="math inline">\(k\)</span> 次子串也可以用这个方法来解，但是多个 <span class="math inline">\(\log\)</span> 没必要。</p><p>也可以限制多次出现但长度至少为 <span class="math inline">\(len\)</span>，那甚至少了二分的 <span class="math inline">\(\log\)</span>，直接跑一遍 check 即可。</p><p><del>？？？到底为什么会有这么多奇怪的定式，是因为真的有题这么出吗？？？</del> <img src="/em/oh.gif" /></p><hr /><h3 id="最长公共子串问题">最长公共子串问题</h3><p>求 <span class="math inline">\(S\)</span> 和 <span class="math inline">\(T\)</span> 的最长公共子串（注意不是 LCS）。设 <span class="math inline">\(S\)</span> 长为 <span class="math inline">\(n\)</span>，<span class="math inline">\(T\)</span> 长为 <span class="math inline">\(m\)</span>，那么将 <span class="math inline">\(S\)</span> 与 <span class="math inline">\(T\)</span> 拼接，答案就是 <span class="math inline">\(\max \{\text{lcp}(i,j)\},i\le n&lt;j\)</span>。</p><p>但这里不直接枚举 <span class="math inline">\(i\)</span> 和 <span class="math inline">\(j\)</span>，还是照例先从 <span class="math inline">\(h\)</span> 下手再卡条件，若 <span class="math inline">\(sa_{i-1}\le n&lt;sa_{i}\)</span>（或者反过来），就可以用 <span class="math inline">\(h_i\)</span> 更新答案。容易证明这样总可以找到最大值。</p><h4 id="eg1.-找相同字符">eg1. 找相同字符</h4><p><a href="https://www.luogu.com.cn/problem/P3181" class="uri">https://www.luogu.com.cn/problem/P3181</a></p><p>要求方案数，那么答案为 <span class="math inline">\(\text{lcp}(i,j),i\le n&lt;j\)</span>。（我已经帮你们试过了容斥比直接做更麻烦），考虑用单调栈维护左 / 右侧区间 lcp 求解右 / 左侧答案。关于单调栈的描述可见 <a href="#结合单调栈">本页后部内容</a>。</p><details><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;int main() &#123;#ifdef ONLINE_JUDGE    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr), std::cout.tie(nullptr);#else    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);#endif    int n, n1;    std::string s, t;    std::cin &gt;&gt; s &gt;&gt; t;    n = (int)s.length(), n1 = n + (int)t.length() + 1;    s = &quot;#&quot; + s + &quot;$&quot; + t;    std::vector&lt;int&gt; sa(n1 + 1), rk(n1 + 1), h(n1 + 1);    &#123;        std::copy(s.begin() + 1, s.end(), rk.begin() + 1);        int m = 128;        &#123;            std::vector&lt;int&gt; c(m + 1);            for (int i = 1; i &lt;= n1; ++i)                ++c[rk[i]];            std::partial_sum(c.begin(), c.end(), c.begin());            for (int i = n1; i; --i)                sa[c[rk[i]]--] = i;        &#125;        for (int w = 1, p; ; w &lt;&lt;= 1, m = p) &#123;            std::vector&lt;int&gt; id(w + 1);            std::iota(id.begin() + 1, id.end(), n1 - w + 1);            for (int i = 1; i &lt;= n1; ++i)                if (sa[i] &gt; w)                    id.push_back(sa[i] - w);            std::vector&lt;int&gt; c(m + 1);            for (int i = 1; i &lt;= n1; ++i)                ++c[rk[i]];            std::partial_sum(c.begin(), c.end(), c.begin());            for (int i = n1; i; --i)                sa[c[rk[id[i]]]--] = id[i];            p = 0;            auto la(rk);            for (int i = 1; i &lt;= n1; ++i)                if (i != 1 &amp;&amp; la[sa[i]] == la[sa[i - 1]] &amp;&amp; la[sa[i] + w] == la[sa[i - 1] + w])                    rk[sa[i]] = p;                else                    rk[sa[i]] = ++p;            if (p == n1)                break;        &#125;        for (int i = 1, to = 0; i &lt;= n1; ++i) &#123;            for (to = std::max(to - 1, 0); s[i + to] == s[sa[rk[i] - 1] + to]; ++to);            h[rk[i]] = to;        &#125;    &#125;    std::vector&lt;std::pair&lt;int, long long&gt; &gt; q1, q2;    std::vector&lt;int&gt; tot1(n1 + 1), tot2(n1 + 1);    for (int i = 1; i &lt;= n1; ++i) &#123;        tot1[i] = tot1[i - 1] + (sa[i] &lt;= n);        tot2[i] = tot2[i - 1] + (sa[i] &gt; n + 1);    &#125;    long long res = 0ll;    q1.emplace_back(1, 0ll), q2.emplace_back(1, 0ll);    for (int i = 1; i &lt;= n1; ++i) &#123;        for (; !q1.empty() &amp;&amp; h[i] &lt; h[q1.back().first]; q1.pop_back());        q1.emplace_back(i, (tot1[i - 1] - tot1[q1.back().first - 1]) * h[i] + q1.back().second);        if (sa[i] &gt; n + 1)            res += q1.back().second;        for (; !q2.empty() &amp;&amp; h[i] &lt; h[q2.back().first]; q2.pop_back());        q2.emplace_back(i, (tot2[i - 1] - tot2[q2.back().first - 1]) * h[i] + q2.back().second);        if (sa[i] &lt;= n)            res += q2.back().second;    &#125;    std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;    return 0;&#125;</code></pre></details><h4 id="eg2.-公共串">eg2. 公共串</h4><p><a href="https://www.luogu.com.cn/problem/P5546" class="uri">https://www.luogu.com.cn/problem/P5546</a></p><p>要求多串最长公共子串，仍然考虑将多个串拼在一起。仿照前面二分的方式处理，问题转化为找到最长的 <span class="math inline">\(len\)</span>，使得存在一段最小值 <span class="math inline">\(\ge len\)</span> 的区间，其覆盖了 <span class="math inline">\(n\)</span> 段串。</p><details><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;int main() &#123;#ifdef ONLINE_JUDGE    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr), std::cout.tie(nullptr);#else    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);#endif    int n, l = 0, r = 0;    std::cin &gt;&gt; n;    std::string s;    std::vector&lt;std::pair&lt;int, int&gt; &gt; lim(n + 1);    for (int i = 1; i &lt;= n; ++i) &#123;        std::string t;        std::cin &gt;&gt; t;        lim[i] = &#123; (int)s.length() + 1, s.length() + t.length() &#125;;        s += &quot;#&quot; + t;        r = std::max(r, (int)t.length());        // printf(&quot;[%d, %d]\n&quot;, lim[i].first, lim[i].second);    &#125;    int n1 = lim.back().second;    std::vector&lt;int&gt; sa(n1 + 1), rk(n1 + 1), h(n1 + 1);    &#123;        std::copy(s.begin() + 1, s.end(), rk.begin() + 1);        int m = 128;        &#123;            std::vector&lt;int&gt; c(m + 1);            for (int i = 1; i &lt;= n1; ++i)                ++c[rk[i]];            std::partial_sum(c.begin(), c.end(), c.begin());            for (int i = n1; i; --i)                sa[c[rk[i]]--] = i;        &#125;        for (int w = 1, p; ; w &lt;&lt;= 1, m = p) &#123;            std::vector&lt;int&gt; id(w + 1);            std::iota(id.begin() + 1, id.end(), n1 - w + 1);            for (int i = 1; i &lt;= n1; ++i)                if (sa[i] &gt; w)                    id.push_back(sa[i] - w);            std::vector&lt;int&gt; c(m + 1);            for (int i = 1; i &lt;= n1; ++i)                ++c[rk[i]];            std::partial_sum(c.begin(), c.end(), c.begin());            for (int i = n1; i; --i)                sa[c[rk[id[i]]]--] = id[i];            p = 0;            auto la(rk);            for (int i = 1; i &lt;= n1; ++i)                if (i != 1 &amp;&amp; la[sa[i]] == la[sa[i - 1]] &amp;&amp; la[sa[i] + w] == la[sa[i - 1] + w])                    rk[sa[i]] = p;                else                    rk[sa[i]] = ++p;            if (p == n1)                break;        &#125;        for (int i = 1, to = 0; i &lt;= n1; ++i) &#123;            for (to = std::max(to - 1, 0); s[i + to] == s[sa[rk[i] - 1] + to]; ++to);            h[rk[i]] = to;        &#125;    &#125;    // for (int i = 1; i &lt;= n1; ++i)    //     printf(&quot;h[%d] = %d\n&quot;, sa[i], h[i]);    int res = 0;    auto check = [&amp;](int len) &#123;        // printf(&quot;check %d: \n&quot;, len);        std::vector&lt;int&gt; cnt(n + 1);        for (int i = 1; i &lt;= n1; ++i) &#123;            if (h[i] &lt; len) &#123;                if (*std::min_element(cnt.begin() + 1, cnt.end()))                    return 1;                cnt.assign(n + 1, 0);            &#125;            else                for (int j = 1; j &lt;= n; ++j) &#123;                    if (lim[j].first &lt;= sa[i - 1] &amp;&amp; sa[i - 1] &lt;= lim[j].second)                        cnt[j] = 1;                    if (lim[j].first &lt;= sa[i] &amp;&amp; sa[i] &lt;= lim[j].second)                        cnt[j] = 1;                &#125;        &#125;        // printf(&quot;\n%d\n&quot;, *std::min_element(cnt.begin() + 1, cnt.end()));        return *std::min_element(cnt.begin() + 1, cnt.end());    &#125;;    for (int mid; l &lt;= r; ) &#123;        mid = (l + r) &gt;&gt; 1;        if (check(mid))            l = mid + 1, res = mid;        else            r = mid - 1;    &#125;    std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;    return 0;&#125;</code></pre></details><p>但是看了题解发现居然还有线性做法（当然不看建 SA 的 <span class="math inline">\(\log\)</span>），对于覆盖全部 <span class="math inline">\(n\)</span> 段串找区间最小值，发现需要最小化区间，考虑双指针。</p><p>区间最小值用单调队列求解，细想可能会觉得不太对劲，但是容易证明答案不大于队首且不小于最大队首，所以最大队首就是答案。</p><details><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;int main() &#123;#ifdef ONLINE_JUDGE    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr), std::cout.tie(nullptr);#else    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);#endif    int n, l = 0, r = 0;    std::cin &gt;&gt; n;    std::string s;    std::vector&lt;std::pair&lt;int, int&gt; &gt; lim(n + 1);    for (int i = 1; i &lt;= n; ++i) &#123;        std::string t;        std::cin &gt;&gt; t;        lim[i] = &#123; (int)s.length() + 1, s.length() + t.length() &#125;;        s += (char)(&#39;A&#39; + i - 1) + t;        r = std::max(r, (int)t.length());    &#125;    int n1 = lim.back().second;    std::vector&lt;int&gt; sa(n1 + 1), rk(n1 + 1), h(n1 + 1);    &#123;        std::copy(s.begin() + 1, s.end(), rk.begin() + 1);        int m = 128;        &#123;            std::vector&lt;int&gt; c(m + 1);            for (int i = 1; i &lt;= n1; ++i)                ++c[rk[i]];            std::partial_sum(c.begin(), c.end(), c.begin());            for (int i = n1; i; --i)                sa[c[rk[i]]--] = i;        &#125;        for (int w = 1, p; ; w &lt;&lt;= 1, m = p) &#123;            std::vector&lt;int&gt; id(w + 1);            std::iota(id.begin() + 1, id.end(), n1 - w + 1);            for (int i = 1; i &lt;= n1; ++i)                if (sa[i] &gt; w)                    id.push_back(sa[i] - w);            std::vector&lt;int&gt; c(m + 1);            for (int i = 1; i &lt;= n1; ++i)                ++c[rk[i]];            std::partial_sum(c.begin(), c.end(), c.begin());            for (int i = n1; i; --i)                sa[c[rk[id[i]]]--] = id[i];            p = 0;            auto la(rk);            for (int i = 1; i &lt;= n1; ++i)                if (i != 1 &amp;&amp; la[sa[i]] == la[sa[i - 1]] &amp;&amp; la[sa[i] + w] == la[sa[i - 1] + w])                    rk[sa[i]] = p;                else                    rk[sa[i]] = ++p;            if (p == n1)                break;        &#125;        for (int i = 1, to = 0; i &lt;= n1; ++i) &#123;            for (to = std::max(to - 1, 0); s[i + to] == s[sa[rk[i] - 1] + to]; ++to);            h[rk[i]] = to;        &#125;    &#125;    int res = 0;    std::vector&lt;int&gt; q(n1 + 1), cnt(n + 1);    // for (int i = 1; i &lt;= n1; ++i)    //     printf(&quot;%d: %d\n&quot;, sa[i], h[i]);    for (int l = 1, r = 0, ql = 1, qr = 0; l &lt;= n1; ++l) &#123;        for (; r &lt; n1 &amp;&amp; !*std::min_element(cnt.begin() + 1, cnt.end()); ) &#123;            ++r;            for (int i = 1; i &lt;= n; ++i)                if (lim[i].first &lt;= sa[r] &amp;&amp; sa[r] &lt;= lim[i].second) &#123;                    ++cnt[i];                    break;                &#125;            for (; ql &lt;= qr &amp;&amp; h[r] &lt;= h[q[qr]]; --qr);            q[++qr] = r;        &#125;        if (*std::min_element(cnt.begin() + 1, cnt.end())) &#123;            // printf(&quot;[%d, %d]: %d\n&quot;, l, r, h[q[ql]]);            res = std::max(res, h[q[ql]]);        &#125;        for (; ql &lt;= qr &amp;&amp; q[ql] &lt;= l; ++ql);        if (l != 1) &#123;            for (int i = 1; i &lt;= n; ++i)                if (lim[i].first &lt;= sa[l - 1] &amp;&amp; sa[l - 1] &lt;= lim[i].second) &#123;                    --cnt[i];                    break;                &#125;        &#125;    &#125;    std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;    return 0;&#125;</code></pre></details><hr /><h3 id="texttt-aa-式子串处理"><span class="math inline">\(\texttt {AA}\)</span> 式子串处理</h3><p>即对于连续相同子串问题的处理，有一个定的思路，由例题分析。</p><h4 id="eg1.-优秀的拆分">eg1. 优秀的拆分</h4><p><a href="https://www.luogu.com.cn/problem/P1117" class="uri">https://www.luogu.com.cn/problem/P1117</a></p><p>还是从中间分开，按前后分别处理。这里有个 trick，我们枚举 <span class="math inline">\(\texttt B\)</span> 的长度 <span class="math inline">\(len\)</span>，在 <span class="math inline">\(S\)</span> 中每隔 <span class="math inline">\(len\)</span> 打一个标记。那么显然，任意一个长度为 <span class="math inline">\(2\times len\)</span> 的子串都会经过恰好两个标记（充分的），这样就可以筛选出所有可能的串。</p><p>我们枚举所有连续两个标记（总复杂度为调和级数），求它们对应后缀的 lcp 和对应前缀的 lcs（翻转求 SA 即可），如果二者加起来 <span class="math inline">\(\ge len\)</span> 就说明存在这样的 <span class="math inline">\(\texttt {AA}\)</span>。在 <span class="math inline">\(\text {lcs}+\text {lcp}\)</span> 中任取 <span class="math inline">\(len\)</span> 长度即为一对 <span class="math inline">\(\texttt {AA}\)</span>。用差分给可能的起点和终点区间加即可。</p><p>小细节：lcp 和 lcs 均需要对 <span class="math inline">\(len\)</span> 取 <span class="math inline">\(\min\)</span>，否则取到的串可能不会经过当前选中的两个标记。</p><details><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;class SA &#123;public:    std::vector&lt;int&gt; sa, rk, h;    std::vector&lt;std::vector&lt;int&gt;  &gt; st;    SA(int n, std::string s): sa(n + 1), rk(n + 2), h(n + 1), st(20, std::vector&lt;int&gt; (n + 1)) &#123;        std::vector&lt;int&gt; la(n + 2);        std::copy(s.begin(), s.end(), rk.begin());        int m = 128;        &#123;            std::vector&lt;int&gt; c(m + 1);            for (int i = 1; i &lt;= n; ++i)                ++c[rk[i]];            std::partial_sum(c.begin(), c.end(), c.begin());            for (int i = n; i; --i)                sa[c[rk[i]]--] = i;        &#125;        for (int w = 1, p; ; w &lt;&lt;= 1, m = p) &#123;            std::vector&lt;int&gt; id(1);            for (int i = n - w + 1; i &lt;= n; ++i)                id.push_back(i);            for (int i = 1; i &lt;= n; ++i)                if (sa[i] &gt; w)                    id.push_back(sa[i] - w);            std::vector&lt;int&gt; c(m + 1);            for (int i = 1; i &lt;= n; ++i)                ++c[rk[i]];            std::partial_sum(c.begin(), c.end(), c.begin());            for (int i = n; i; --i)                sa[c[rk[id[i]]]--] = id[i];            p = 0;            std::copy(rk.begin(), rk.end(), la.begin());            for (int i = 1; i &lt;= n; ++i)                if (la[sa[i]] == la[sa[i - 1]] &amp;&amp; la[sa[i] + w] == la[sa[i - 1] + w])                    rk[sa[i]] = p;                else                    rk[sa[i]] = ++p;            if (p == n)                break;        &#125;        for (int i = 1, to = 0; i &lt;= n; ++i)            if (rk[i]) &#123;                for (to = std::max(to - 1, 0); s[i + to] == s[sa[rk[i] - 1] + to]; ++to);                h[rk[i]] = to;            &#125;        for (int i = 1; i &lt;= n; ++i)            st[0][i] = h[i];        for (int j = 1; (1 &lt;&lt; j) &lt;= n; ++j)            for (int i = 1; i + (1 &lt;&lt; j) - 1 &lt;= n; ++i)                st[j][i] = std::min(st[j - 1][i], st[j - 1][i + (1 &lt;&lt; (j - 1))]);        rk.emplace_back();        return;    &#125;private:    int ask(int l, int r) &#123;        // fprintf(stderr, &quot;l = %d, r = %d\n&quot;, l, r);        int k = std::__lg(r - l + 1);        return std::min(st[k][l], st[k][r - (1 &lt;&lt; k) + 1]);    &#125;public:    int lcp(int l, int r) &#123;        return ask(std::min(rk[l], rk[r]) + 1, std::max(rk[l], rk[r]));    &#125;&#125;;int main() &#123;#ifdef ONLINE_JUDGE    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr), std::cout.tie(nullptr);#else    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);#endif    int T;    for (std::cin &gt;&gt; T; T--; ) &#123;        std::string s;        std::cin &gt;&gt; s;        int n = (int)s.length();        s = &quot;#&quot; + s;        SA p(n, s);        std::reverse(s.begin() + 1, s.end());        SA q(n, s);        std::vector&lt;int&gt; f(n + 2), g(n + 2);        for (int len = 1; len &lt;= n / 2; ++len)            for (int i = len; i + len &lt;= n; i += len) &#123;                int l = i, r = i + len, lcp = std::min(len, p.lcp(l, r)), lcs = std::min(len - 1, q.lcp(n - l + 2, n - r + 2));                if (lcp + lcs &gt;= len) &#123;                    int t = lcp + lcs - len + 1;                    // fprintf(stderr, &quot;(%d, %d), %d, %d\n&quot;, l, r, lcp, lcs);                    ++g[l - lcs], --g[l - lcs + t], ++f[r + lcp - t], --f[r + lcp];                &#125;            &#125;        std::partial_sum(f.begin(), f.end(), f.begin());        std::partial_sum(g.begin(), g.end(), g.begin());        long long res = 0ll;        for (int i = 1; i &lt; n; ++i)            res += (long long)f[i] * g[i + 1];        std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;    &#125;    return 0;&#125;</code></pre></details><hr /><h4 id="eg2.-tandem">eg2. tandem</h4><p><a href="https://www.codechef.com/problems/TANDEM" class="uri">https://www.codechef.com/problems/TANDEM</a></p><p>注意到多了一个限制，前一个好处理，找到经过 <span class="math inline">\(3\)</span> 个标记的串即可。对于后一个限制，画图可以发现对于 interesting ones，每次只会出现最多一个；当且仅当 <span class="math inline">\(\text {lcp}&gt;len\)</span> 时不存在。</p><p>对于 uninteresting ones，用每次能提供的总数减去 interesting ones 的数量即可。</p><details><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;class SA &#123;public:    std::vector&lt;int&gt; sa, rk, h;    std::vector&lt;std::vector&lt;int&gt;  &gt; st;    SA(int n, std::string s): sa(n + 1), rk(n + 2), h(n + 1), st(20, std::vector&lt;int&gt; (n + 1)) &#123;        std::vector&lt;int&gt; la(n + 2);        std::copy(s.begin(), s.end(), rk.begin());        int m = 128;        &#123;            std::vector&lt;int&gt; c(m + 1);            for (int i = 1; i &lt;= n; ++i)                ++c[rk[i]];            std::partial_sum(c.begin(), c.end(), c.begin());            for (int i = n; i; --i)                sa[c[rk[i]]--] = i;        &#125;        for (int w = 1, p; ; w &lt;&lt;= 1, m = p) &#123;            std::vector&lt;int&gt; id(1);            for (int i = n - w + 1; i &lt;= n; ++i)                id.push_back(i);            for (int i = 1; i &lt;= n; ++i)                if (sa[i] &gt; w)                    id.push_back(sa[i] - w);            std::vector&lt;int&gt; c(m + 1);            for (int i = 1; i &lt;= n; ++i)                ++c[rk[i]];            std::partial_sum(c.begin(), c.end(), c.begin());            for (int i = n; i; --i)                sa[c[rk[id[i]]]--] = id[i];            p = 0;            std::copy(rk.begin(), rk.end(), la.begin());            for (int i = 1; i &lt;= n; ++i)                if (la[sa[i]] == la[sa[i - 1]] &amp;&amp; la[sa[i] + w] == la[sa[i - 1] + w])                    rk[sa[i]] = p;                else                    rk[sa[i]] = ++p;            if (p == n)                break;        &#125;        for (int i = 1, to = 0; i &lt;= n; ++i)            if (rk[i]) &#123;                for (to = std::max(to - 1, 0); s[i + to] == s[sa[rk[i] - 1] + to]; ++to);                h[rk[i]] = to;            &#125;        for (int i = 1; i &lt;= n; ++i)            st[0][i] = h[i];        for (int j = 1; (1 &lt;&lt; j) &lt;= n; ++j)            for (int i = 1; i + (1 &lt;&lt; j) - 1 &lt;= n; ++i)                st[j][i] = std::min(st[j - 1][i], st[j - 1][i + (1 &lt;&lt; (j - 1))]);        rk.emplace_back();        return;    &#125;private:    int ask(int l, int r) &#123;        // fprintf(stderr, &quot;l = %d, r = %d\n&quot;, l, r);        int k = std::__lg(r - l + 1);        return std::min(st[k][l], st[k][r - (1 &lt;&lt; k) + 1]);    &#125;public:    int lcp(int l, int r) &#123;        return ask(std::min(rk[l], rk[r]) + 1, std::max(rk[l], rk[r]));    &#125;&#125;;int main() &#123;#ifdef ONLINE_JUDGE    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr), std::cout.tie(nullptr);#else    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);#endif    std::string s;    std::cin &gt;&gt; s;    int n = (int)s.length();    s = &quot;#&quot; + s;    SA p(n, s);    std::reverse(s.begin() + 1, s.end());    SA q(n, s);    std::reverse(s.begin() + 1, s.end());    long long res1 = 0ll, res2 = 0ll;    for (int len = 1; len &lt;= n; ++len)        for (int i = len, j = 2 * len, k = 3 * len; k &lt;= n; i += len, j += len, k += len) &#123;            int lcp = std::min(p.lcp(i, j), p.lcp(j, k)), lcs = std::min(&#123; len - 1, q.lcp(n - i + 2, n - j + 2), q.lcp(n - j + 2, n - k + 2) &#125;);            if (std::min(len, lcp) + lcs &gt;= len) &#123;                // printf(&quot;(%d, %d, %d), %d, %d, %d\n&quot;, i, j, k, lcs, lcp, len);                int t = (lcp &lt;= len);                res1 += t, res2 += std::min(len, lcp) + lcs - len + 1 - t;            &#125;            // else            //     printf(&quot;# (%d, %d, %d), %d, %d, %d\n&quot;, i, j, k, lcs, lcp, len);        &#125;    std::cout &lt;&lt; res1 &lt;&lt; &#39; &#39; &lt;&lt; res2 &lt;&lt; &#39;\n&#39;;    return 0;&#125;</code></pre></details><hr /><h4 id="eg3.-repeats">eg3. repeats</h4><p><a href="https://www.spoj.com/problems/REPEATS/" class="uri">https://www.spoj.com/problems/REPEATS/</a></p><p>重复次数最多，只需经过标记点最多。显然经过标记点的数量就是该字符串长除以 <span class="math inline">\(len\)</span> 向下取整就可以得到重复次数减 <span class="math inline">\(1\)</span> 的值。</p><p>选择两个连续标记点，对于 lcp 和 lcs（显然此时不需要对 <span class="math inline">\(len\)</span> 取 <span class="math inline">\(\min\)</span>），计算 <span class="math inline">\(\dfrac {\text{lcp}+\text{lcs}}{len}+1\)</span> 取最大即可。</p><details><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;class SA &#123;public:    std::vector&lt;int&gt; sa, rk, h;    std::vector&lt;std::vector&lt;int&gt;  &gt; st;    SA(int n, std::string s): sa(n + 1), rk(n + 2), h(n + 1), st(20, std::vector&lt;int&gt; (n + 1)) &#123;        std::vector&lt;int&gt; la(n + 2);        std::copy(s.begin(), s.end(), rk.begin());        int m = 128;        &#123;            std::vector&lt;int&gt; c(m + 1);            for (int i = 1; i &lt;= n; ++i)                ++c[rk[i]];            std::partial_sum(c.begin(), c.end(), c.begin());            for (int i = n; i; --i)                sa[c[rk[i]]--] = i;        &#125;        for (int w = 1, p; ; w &lt;&lt;= 1, m = p) &#123;            std::vector&lt;int&gt; id(1);            for (int i = n - w + 1; i &lt;= n; ++i)                id.push_back(i);            for (int i = 1; i &lt;= n; ++i)                if (sa[i] &gt; w)                    id.push_back(sa[i] - w);            std::vector&lt;int&gt; c(m + 1);            for (int i = 1; i &lt;= n; ++i)                ++c[rk[i]];            std::partial_sum(c.begin(), c.end(), c.begin());            for (int i = n; i; --i)                sa[c[rk[id[i]]]--] = id[i];            p = 0;            std::copy(rk.begin(), rk.end(), la.begin());            for (int i = 1; i &lt;= n; ++i)                if (la[sa[i]] == la[sa[i - 1]] &amp;&amp; la[sa[i] + w] == la[sa[i - 1] + w])                    rk[sa[i]] = p;                else                    rk[sa[i]] = ++p;            if (p == n)                break;        &#125;        for (int i = 1, to = 0; i &lt;= n; ++i)            if (rk[i]) &#123;                for (to = std::max(to - 1, 0); s[i + to] == s[sa[rk[i] - 1] + to]; ++to);                h[rk[i]] = to;            &#125;        for (int i = 1; i &lt;= n; ++i)            st[0][i] = h[i];        for (int j = 1; (1 &lt;&lt; j) &lt;= n; ++j)            for (int i = 1; i + (1 &lt;&lt; j) - 1 &lt;= n; ++i)                st[j][i] = std::min(st[j - 1][i], st[j - 1][i + (1 &lt;&lt; (j - 1))]);        rk.emplace_back();        return;    &#125;private:    int ask(int l, int r) &#123;        // fprintf(stderr, &quot;l = %d, r = %d\n&quot;, l, r);        int k = std::__lg(r - l + 1);        return std::min(st[k][l], st[k][r - (1 &lt;&lt; k) + 1]);    &#125;public:    int lcp(int l, int r) &#123;        return ask(std::min(rk[l], rk[r]) + 1, std::max(rk[l], rk[r]));    &#125;&#125;;int main() &#123;#ifdef ONLINE_JUDGE    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr), std::cout.tie(nullptr);#else    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);#endif    int T;    for (std::cin &gt;&gt; T; T--; ) &#123;        int n;        std::cin &gt;&gt; n;        std::string s = &quot;#&quot;;        for (int i = 1; i &lt;= n; ++i) &#123;            char t;            std::cin &gt;&gt; t;            s.push_back(t);        &#125;        SA p(n, s);        std::reverse(s.begin() + 1, s.end());        SA q(n, s);        int res = 0;        for (int len = 1; len &lt;= n; ++len)            for (int i = len, j = 2 * len; j &lt;= n; i += len, j += len) &#123;                int lcp = p.lcp(i, j), lcs = q.lcp(n - i + 2, n - j + 2);                if (lcp + lcs &gt;= len)                    res = std::max(res, (lcp + lcs) / len + 1);            &#125;        std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;    &#125;    return 0;&#125;</code></pre></details><hr /><h3 id="结合并查集">结合并查集</h3><hr /><h3 id="结合单调栈">结合单调栈</h3>]]></content>
      
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
            <tag> SA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络流</title>
      <link href="/20250124/"/>
      <url>/20250124/</url>
      
        <content type="html"><![CDATA[<p>想当年叱诧风云左牵字符串右擎网络流，而今飘零憔悴沦落到需要学而时习之的地步 <img src="/em/kx.gif" /></p><span id="more"></span><hr /><h2 id="定义">定义</h2><p>对于有一个源点 <span class="math inline">\(s\)</span> 和汇点 <span class="math inline">\(t\)</span> 的有向图，每条边都有一个权值 <span class="math inline">\(c\)</span> 作为容量，称这个有向图 <span class="math inline">\(G\)</span> 是一个网络。</p><p>假设现在有 <span class="math inline">\(f\)</span> 升水从 <span class="math inline">\(s\)</span> 流入，而我们可以自由分配每个点的水可以朝哪个方向流出，那么显然地：</p><ul><li>流出 <span class="math inline">\(t\)</span> 的水为 <span class="math inline">\(f\)</span> 升。</li><li>对于除 <span class="math inline">\(s\)</span> 和 <span class="math inline">\(t\)</span> 以外的所有点，流入的水量等于流出的水量。</li><li>对于任意一条边，流经的水量不超过容量。</li></ul><p>对于这个网络，任选出一部分点与 <span class="math inline">\(s\)</span> 分为一组，剩下与 <span class="math inline">\(t\)</span> 分为一组，该操作称为「割」。一个割的「容量」定义为 <span class="math inline">\(s\)</span> 组与 <span class="math inline">\(t\)</span> 组间连边的容量和。</p><p>那么接下来就会由这个模型衍生出许多问题：</p><ul><li>最大流问题：找到一种分配方式最大化 <span class="math inline">\(f\)</span>。</li><li>最小割问题：找到一种割的方案最小化割的容量。</li><li>最小费用最大流问题：给每条边除容量 <span class="math inline">\(c\)</span> 外外加一个费用权值 <span class="math inline">\(w\)</span>，需要在保证最大化 <span class="math inline">\(f\)</span> 的前提下最小化 <span class="math inline">\(\sum f(u, v)\times w(u, v)\)</span>。</li></ul><p>接下来会分别介绍解决这几种不同问题的方法。</p><hr /><h2 id="最大流问题">最大流问题</h2><p>一个主要的思想是 <strong>贪心寻找增广路更新当前答案</strong>。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 网络流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>技巧：字符串拆分</title>
      <link href="/20250121/"/>
      <url>/20250121/</url>
      
        <content type="html"><![CDATA[<p>神刘家在走前体育课上问我听没听过 <em>Die For You - The Weekend</em>。我让他哼一段，刘家便展示了自己的天籁之音，我理所当然地连旋律都没辨认出来。</p><span id="more"></span><hr /><p>有的时候，对于一个完整的匹配串，我们需要「枚举断点」，分为前半段和后半段分别和模式串匹配解决问题。当然这样的技巧不止局限于字符串，我们在之前的学习中在诸如动态规划等题目中遇到了相似的情景。</p><p>在字符串题目中，一个典型的标志是「模式串的拼接」，将两截模式串拼接到一起，形成的新模式串并不利好我们的处理，我们需要尽量利用已知的模式串。当然我们不会将新模式串重新拆成两半，而是考虑转换，枚举匹配串的断点，将前半段的后缀和后半段的前缀分别匹配。</p><hr /><h2 id="一个模板cf1202e-you-are-given-some-strings">一个模板：CF1202E You Are Given Some Strings…</h2><p><a href="https://codeforces.com/problemset/problem/1202/E" class="uri">https://codeforces.com/problemset/problem/1202/E</a></p><p>虽然对于每种不同拼接需要求解分别的出现次数，但是注意到最后只需要输出 <span class="math inline">\(f\)</span> 的总和，所以就可以不再顾及不同拼接方式间的区别。</p><p>枚举匹配串的断点。一个自然的想法是将前后缀与 AC 自动机匹配，但如果逐个放进去显然复杂度起飞。这里就又有一个实现小技巧，我们在原串的 AC 自动机上把原串过一遍，每个位置所在的状态就是这个位置对应后缀可能处在的后缀。</p><p>记录每个状态可能处在的模式串末尾个数，这一点直接在 fail 树上从上到下转移即可。反串同理。</p><p>二者相乘即为答案。</p><details><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;const int maxn = 2e5 + 5;struct &#123;    int T[maxn][26], tot, cnt[maxn], fail[maxn], deg[maxn];    void ins(std::string &amp;t) &#123;        int p = 0;        for (auto i : t) &#123;            if (!T[p][i - &#39;a&#39;])                T[p][i - &#39;a&#39;] = ++tot;            p = T[p][i - &#39;a&#39;];        &#125;        ++cnt[p];        return;    &#125;    void bld(void) &#123;        std::queue&lt;int&gt; q;        for (int i = 0; i &lt; 26; ++i)            if (T[0][i])                q.push(T[0][i]);        for (; !q.empty(); ) &#123;            int u = q.front();            q.pop();            for (int i = 0; i &lt; 26; ++i)                if (T[u][i]) &#123;                    int v = T[u][i];                    fail[v] = T[fail[u]][i], cnt[v] += cnt[fail[v]];                    q.push(v);                &#125;                else                    T[u][i] = T[fail[u]][i];        &#125;        return;    &#125;&#125; p, q;int main() &#123;#ifdef ONLINE_JUDGE    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr), std::cout.tie(nullptr);#else    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);#endif    std::string s;    std::cin &gt;&gt; s;    int n;    std::cin &gt;&gt; n;    for (int i = 1; i &lt;= n; ++i) &#123;        std::string t;        std::cin &gt;&gt; t;        p.ins(t);        std::reverse(t.begin(), t.end());        q.ins(t);    &#125;    p.bld(), q.bld();    int len = s.length();    std::vector&lt;std::array&lt;int, 2&gt; &gt; f(len + 1);    &#123;        int u = 0;        for (int i = 1; i &lt;= len; ++i) &#123;            u = p.T[u][s[i - 1] - &#39;a&#39;];            f[i][0] = p.cnt[u];        &#125;    &#125;    &#123;        int u = 0;        for (int i = len; i; --i) &#123;            u = q.T[u][s[i - 1] - &#39;a&#39;];            f[i][1] = q.cnt[u];        &#125;    &#125;    long long res = 0ll;    for (int i = 1; i &lt; len; ++i)        res += (long long)f[i][0] * f[i + 1][1];    std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;    return 0;&#125;</code></pre></details><hr /><h2 id="变式优秀的拆分">变式：优秀的拆分</h2><p><a href="https://www.luogu.com.cn/problem/P1117" class="uri">https://www.luogu.com.cn/problem/P1117</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习笔记：AC 自动机</title>
      <link href="/20250120/"/>
      <url>/20250120/</url>
      
        <content type="html"><![CDATA[<p>耳机声音疑似有点小了，用心旷神怡的话来说大致会是「比果蝇↑嗡嗡声还小」。</p><span id="more"></span><p>？卧槽耳机上居然可以调音量 <img src="/em/oh.gif" /></p><hr /><h2 id="前置知识">前置知识</h2><p>首先可能需要知道专有名词「自动机」的含义。</p><p>大致可以简单理解为，一个 DAG，其中点表示状态，边表示转移。给进去一个字符串之类，就可以在 DAG 上游走，根据最后所处结点，可以得到字符串相关特征。</p><p>这个定义让我们想到了 Trie。事实上，Trie 就是一种相当基础的自动机。</p><hr /><p>接下来，让我们复习 KMP 相关概念。</p><p>假想一个场景：你需要求得 <span class="math inline">\(T\)</span> 在 <span class="math inline">\(S\)</span> 中的出现次数。</p><p>拥有一定题目经验的你，会使用 KMP 求出 <span class="math inline">\(T\)</span> 的 <code>next</code> 数组，令 <span class="math inline">\(T\)</span> 在 <span class="math inline">\(S\)</span> 上进行匹配，失配或完全匹配时回到 <span class="math inline">\(T\)</span> 在该处的 <code>next</code>，<span class="math inline">\(S\)</span> 上的指针始终向右，<span class="math inline">\(T\)</span> 上的指针如果向右，每次只能移动一位；如果向左，最左移到开头，均摊下来复杂度即为 <span class="math inline">\(O(|S| + |T|)\)</span>。</p><p>假如场景变得更复杂：给定 <span class="math inline">\(\{T_m\}\)</span>，你需要求出每个 <span class="math inline">\(T_j\)</span> 在 <span class="math inline">\(S\)</span> 中的出现次数。</p><p>那么如果我们对每个 <span class="math inline">\(T_j\)</span> 进行一次 KMP，复杂度将会上升到 <span class="math inline">\(O(m|S|)\)</span>，难以承受。有没有优化的方法呢？</p><hr /><h2 id="ac-自动机的建立">AC 自动机的建立</h2><p>结合上面的知识，我们下意识想到，能不能将 <span class="math inline">\(\{T_m\}\)</span> 建成一个树状结构，令 <span class="math inline">\(S\)</span> 在其上进行 KMP 呢？</p><p>将 <span class="math inline">\(\{T_m\}\)</span> 全部加入 Trie，由于 <code>next</code> 只会由更深的点指向更浅的点，似乎从直觉上是有规则的。但随之而来的是一个问题：点 <span class="math inline">\(u\)</span> 的 <code>next</code> 不一定在 <span class="math inline">\(\text{root}\to u\)</span> 的链上（由于 Trie 的性质，可知指向的点是唯一的）。鉴于这一点不同，我们结合其「失配指针」的定义，将 <code>next</code> 在 Trie 上的同分异构体唤为 <code>fail</code>。</p><p>考察 Trie 上该 <code>fail</code> 边的性质，假设其为 <span class="math inline">\(u\to v\)</span>，结合 KMP 中 <code>next</code> 的性质，假设 <span class="math inline">\(u\)</span> 的父节点为 <span class="math inline">\(u&#39;\)</span>，其 <code>fail</code> 为 <span class="math inline">\(u&#39;\to v&#39;\)</span>，那么有：</p><ul><li><span class="math inline">\(v&#39;\)</span> 上有边权为 <span class="math inline">\(u\)</span> 的边，<span class="math inline">\(v\)</span> 为该边右端结点。</li><li>否则，前往 <span class="math inline">\(v&#39;\)</span> 的 <code>fail</code>，重复以上判定。</li></ul><p>那么我们就完成了失配的处理。那么相应地，完全匹配时的跳转应如何处理呢？我们直接暴力地将 <code>fail</code> 的儿子全部接到 <span class="math inline">\(u\)</span> 下面就行了。如果 <span class="math inline">\(u\)</span> 和 <code>fail</code> 具有同一条边呢？我们选择保留 <span class="math inline">\(u\)</span> 的这条边 <span class="math inline">\(u\to v\)</span>，因为 <span class="math inline">\(v\)</span> 的 <code>fail</code> 必定指向 <span class="math inline">\(u\)</span> 的 <code>fail</code> 的对应儿子。</p><p>两点结合，我们发现从实现上，可以直接令 <span class="math inline">\(v\)</span> 的 <code>fail</code> 指向 <span class="math inline">\(u\)</span> 的 <code>fail</code> 的对应儿子（那么时间复杂度显而易见是 <span class="math inline">\(O(26\sum |T|)\)</span> 的）。</p><p>匹配时，对于每个点和其返回到根的 <code>fail</code> 链，全部标记。则一个模式串匹配的次数即为被打标记的次数。</p><hr /><p>那么根据上述要求，我们需要按照深度顺序求得 <code>fail</code>，考虑 BFS。</p><details><p>哦哦好神奇复活之后记得啥是 KMP 但忘了啥是 C++ 了。甚至花了一点时间学习怎么创建一个函数？？？</p><p>大家写 AC 自动机 Trie 根节点下标一定要设成 0 啊 <img src="/em/ll.gif" /> 设成 1 被各种细节坑惨了 <img src="/em/ll.gif" /></p><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;const int maxn = 2e5 + 5;int T[maxn][26], tot, cnt[maxn], fail[maxn];int ins(std::string &amp;t) &#123;    int p = 0;    for (auto i : t) &#123;        if (!T[p][i - &#39;a&#39;])            T[p][i - &#39;a&#39;] = ++tot;        p = T[p][i - &#39;a&#39;];    &#125;    return p;&#125;int main() &#123;#ifdef ONLINE_JUDGE    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr), std::cout.tie(nullptr);#else    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);#endif    int n;    std::cin &gt;&gt; n;    std::vector&lt;int&gt; tail(n + 1);    std::vector&lt;std::string&gt; t(n + 1);    for (int i = 1; i &lt;= n; ++i)        std::cin &gt;&gt; t[i], tail[i] = ins(t[i]);    &#123;        std::queue&lt;int&gt; q;        for (int i = 0; i &lt; 26; ++i)            if (T[0][i])                q.push(T[0][i]);        for (; !q.empty(); ) &#123;            int u = q.front();            q.pop();            for (int i = 0; i &lt; 26; ++i)                if (T[u][i]) &#123;                    int v = T[u][i];                    fail[v] = T[fail[u]][i];                    q.push(v);                &#125;                else                    T[u][i] = T[fail[u]][i];        &#125;    &#125;    std::string s;    std::cin &gt;&gt; s;    &#123;        int p = 0;        for (auto i : s) &#123;            p = T[p][i - &#39;a&#39;];            for (int fa = p; fa; fa = fail[fa])                ++cnt[fa];        &#125;    &#125;    for (int i = 1; i &lt;= n; ++i)        std::cout &lt;&lt; cnt[tail[i]] &lt;&lt; &#39;\n&#39;;    return 0;&#125;</code></pre></details><hr /><p>肉眼可见该查询方式是极其低效的，故考虑优化跳 <code>fail</code> 打标记的过程。</p><p>既然自动机结构不变，不如将跳 <code>fail</code> 的步骤放在最后统一进行。容易在发现 <code>fail</code> 树上进行拓扑排序转移即可。</p><details><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;const int maxn = 2e5 + 5;int T[maxn][26], tot, cnt[maxn], fail[maxn], deg[maxn];int ins(std::string &amp;t) &#123;    int p = 0;    for (auto i : t) &#123;        if (!T[p][i - &#39;a&#39;])            T[p][i - &#39;a&#39;] = ++tot;        p = T[p][i - &#39;a&#39;];    &#125;    return p;&#125;int main() &#123;#ifdef ONLINE_JUDGE    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr), std::cout.tie(nullptr);#else    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);#endif    int n;    std::cin &gt;&gt; n;    std::vector&lt;int&gt; tail(n + 1);    std::vector&lt;std::string&gt; t(n + 1);    for (int i = 1; i &lt;= n; ++i)        std::cin &gt;&gt; t[i], tail[i] = ins(t[i]);    &#123;        std::queue&lt;int&gt; q;        for (int i = 0; i &lt; 26; ++i)            if (T[0][i])                q.push(T[0][i]);        for (; !q.empty(); ) &#123;            int u = q.front();            q.pop();            for (int i = 0; i &lt; 26; ++i)                if (T[u][i]) &#123;                    int v = T[u][i];                    fail[v] = T[fail[u]][i], ++deg[T[fail[u]][i]];                    q.push(v);                &#125;                else                    T[u][i] = T[fail[u]][i];        &#125;    &#125;    std::string s;    std::cin &gt;&gt; s;    &#123;        int p = 0;        for (auto i : s)            p = T[p][i - &#39;a&#39;], ++cnt[p];    &#125;    &#123;        std::queue&lt;int&gt; q;        for (int i = 1; i &lt;= tot; ++i)            if (!deg[i])                q.push(i);        for (; !q.empty(); ) &#123;            int u = q.front();            q.pop();            cnt[fail[u]] += cnt[u];            if (!--deg[fail[u]])                q.push(fail[u]);        &#125;    &#125;    for (int i = 1; i &lt;= n; ++i)        std::cout &lt;&lt; cnt[tail[i]] &lt;&lt; &#39;\n&#39;;    return 0;&#125;</code></pre></details><hr /><h2 id="ac-自动机的应用与识别">AC 自动机的应用与识别</h2><p>我们知道其最典型的特征是 <strong>多模式串</strong>、<strong>静态 / 离线</strong>。当碰到类似特点时，大概率就是 AC 自动机。</p><p>其中，可以设置的难点有：</p><ol type="1"><li>字符串难点，和其他字符串题可设置的难点相同。</li><li>fail 树维护，可能结合数据结构、拓扑排序、树形 DP 等考察。</li><li>DP 的设计。</li></ol><hr /><h2 id="字符串难点设计">字符串难点设计</h2><h3 id="eg.-indie-album">eg. Indie Album</h3><p><a href="https://codeforces.com/problemset/problem/1207/G" class="uri">https://codeforces.com/problemset/problem/1207/G</a></p><p>题目的「可持久化」试图误导我们用操作串建立自动机，但这样就会有一个比较严重的问题，我们没办法求 <span class="math inline">\(t\)</span> 的出现次数。</p><p>为了保证答案可求我们仍然在 <span class="math inline">\(t\)</span> 上建立 ACAM。容易发现操作串以 Trie 形式给出，我们可以在遍历 Trie 时同时完成游走，通过回溯完成询问。</p><p>假设当前 DFS 中，遍历到 Trie 树中的 <span class="math inline">\(x\)</span> 点和自动机中的 <span class="math inline">\(u\)</span> 状态，那么对于 <span class="math inline">\(x\)</span> 点所对应的一个询问串 <span class="math inline">\(t\)</span>，相当于询问经过的所有状态有多少个在 <span class="math inline">\(t\)</span> 引导的 fail 树子树中。我们求出 fail 树的 dfn，用树状数组简单统计即可。</p><details><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;const int maxn = 4e5 + 5;std::vector&lt;int&gt; g[maxn], q[maxn];int fail[maxn], T[maxn][26], tot, bit[maxn], to[maxn][26], cnt[maxn];int ins(std::string s) &#123;    int p = 0;    for (auto i : s) &#123;        if (!T[p][i - &#39;a&#39;])            T[p][i - &#39;a&#39;] = ++tot;        p = T[p][i - &#39;a&#39;];    &#125;    return p;&#125;int lowbit(int x) &#123;    return x &amp; -x;&#125;void add(int x, int v) &#123;    for (; x &lt;= tot + 1; x += lowbit(x))        bit[x] += v;    return;&#125;int ask(int x) &#123;    int res = 0;    for (; x; x -= lowbit(x))        res += bit[x];    return res;&#125;int main() &#123;#ifdef ONLINE_JUDGE    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr), std::cout.tie(nullptr);#else    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);#endif    int n, now = 0;    std::cin &gt;&gt; n;    std::vector&lt;int&gt; id(n + 1);    for (int i = 1, op; i &lt;= n; ++i) &#123;        char t;        std::cin &gt;&gt; op;        if (op == 1) &#123;            std::cin &gt;&gt; t;            if (!to[0][t - &#39;a&#39;])                to[0][t - &#39;a&#39;] = ++now;            ++cnt[to[0][t - &#39;a&#39;]], id[i] = to[0][t - &#39;a&#39;];        &#125;        else &#123;            int j;             std::cin &gt;&gt; j &gt;&gt; t;            if (!to[id[j]][t - &#39;a&#39;])                to[id[j]][t - &#39;a&#39;] = ++now;            ++cnt[to[id[j]][t - &#39;a&#39;]], id[i] = to[id[j]][t - &#39;a&#39;];        &#125;    &#125;    int m;    std::cin &gt;&gt; m;    std::vector&lt;int&gt; tail(m + 1), res(m + 1);    for (int i = 1, x; i &lt;= m; ++i) &#123;        std::string t;        std::cin &gt;&gt; x &gt;&gt; t, tail[i] = ins(t);        q[id[x]].push_back(i);    &#125;    &#123;        std::queue&lt;int&gt; q;        for (int i = 0; i &lt; 26; ++i)            if (T[0][i])                q.push(T[0][i]), g[0].push_back(T[0][i]);        for (; !q.empty(); ) &#123;            int u = q.front();            q.pop();            for (int i = 0; i &lt; 26; ++i)                if (T[u][i]) &#123;                    int v = T[u][i];                    fail[v] = T[fail[u]][i];                    q.push(v), g[fail[v]].push_back(v);                &#125;                else                    T[u][i] = T[fail[u]][i];        &#125;    &#125;    std::vector&lt;int&gt; dfn(tot + 1), rfn(tot + 1);    std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;        static int now = 0;        dfn[x] = ++now;        // printf(&quot;%d &quot;, x);        for (auto i : g[x])            DFS(i);        rfn[x] = now;        return;    &#125;;    DFS(0);    std::function&lt;void(int, int)&gt; DFS1 = [&amp;](int x, int u) &#123;        add(dfn[u], 1);        for (auto i : q[x])            res[i] += ask(rfn[tail[i]]) - ask(dfn[tail[i]] - 1);        for (int i = 0; i &lt; 26; ++i)            if (to[x][i])                DFS1(to[x][i], T[u][i]);        add(dfn[u], -1);        return;    &#125;;    DFS1(0, 0);    for (int i = 1; i &lt;= m; ++i)        std::cout &lt;&lt; res[i] &lt;&lt; &#39;\n&#39;;    return 0;&#125;</code></pre></details><hr /><h2 id="fail-树的维护">fail 树的维护</h2><h3 id="eg1.-divljak">eg1. Divljak</h3><p><a href="https://www.luogu.com.cn/problem/P5840" class="uri">https://www.luogu.com.cn/problem/P5840</a></p><h4 id="法一把动态问题离线">法一：把动态问题离线</h4><p>问题相当于将模式串 <span class="math inline">\(T:\{P\}\)</span> 动态化，但我们仍可以无脑离线下来解决问题。</p><p>考虑原本的答案计算过程，即在经过的所有状态及其 fail 链上打标记。现在我们需要离线并区分标记的来源（并且标记类型为布尔值），下意识想到使用线段树维护。</p><p>我们对每个状态建立动态开点线段树，最后拓扑排序时使用线段树合并处理信息。容易证明时间复杂度相较原来多了一个 <span class="math inline">\(\log\)</span>。</p><p><del>理论可行，开始实践</del> 出题人似乎不是很喜欢线段树选手所以决定剥夺你的 Memory Limit。想要用这种做法通过本题可见 <a href="https://www.luogu.com.cn/article/jaxk3sno" class="uri">https://www.luogu.com.cn/article/jaxk3sno</a>。</p><h4 id="法二转而处理静态问题">法二：转而处理静态问题</h4><p>注意到题目中的静态的 <span class="math inline">\(S_x\)</span> 比起 <span class="math inline">\(T:\{P\}\)</span> 更适合用来做模式串，我们在 <span class="math inline">\(S_x\)</span> 上构建 AC 自动机，考虑在线解决问题。</p><p>在每次 <code>1</code> 操作时，更新模式串信息。对于途径的所有状态 <span class="math inline">\(\{u\}\)</span>，考虑更新其所在 fail 链上的信息。</p><p>注意到我们需要修改整条 fail 链上的信息，询问则是询问单点。这个时候可以考虑使用树上差分。</p><p>但是 here comes a problem，我们对于这一整个串只能在整个树上每个点上更新一次。怎么消去相同的影响呢？</p><p>这里实现上我们将经过的点按 fail 树上 dfn 排序，并且对于序列中相邻的两点在其 LCA 上减去一次标记。为什么这是正确的呢？参考虚树，我们只需要让序列中相邻的两个点尽量近就可以保证重复的被删除完毕。</p><details><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;const int maxn = 2e6 + 5;int tot, bit[maxn], T[maxn][26], fail[maxn];int ins(std::string &amp;t) &#123;    int p = 0;    for (auto i : t) &#123;        if (!T[p][i - &#39;a&#39;])            T[p][i - &#39;a&#39;] = ++tot;        p = T[p][i - &#39;a&#39;];    &#125;    return p;&#125;int lowbit(int x) &#123;    return x &amp; -x;&#125;void add(int x, int v) &#123;    // printf(&quot;add (%d, %d)\n&quot;, x, v);    for (; x &lt;= tot + 1; x += lowbit(x))        bit[x] += v;    return;&#125;int ask(int x) &#123;    int res = 0, to = x;    for (; x; x -= lowbit(x))        res += bit[x];    // printf(&quot;ask(%d) = %d\n&quot;, to, res);    return res;&#125;int main() &#123;#ifdef ONLINE_JUDGE    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr), std::cout.tie(nullptr);#else    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);#endif    int n, q;    std::cin &gt;&gt; n;    std::vector&lt;int&gt; tail(n + 1);    for (int i = 1; i &lt;= n; ++i) &#123;        std::string t;        std::cin &gt;&gt; t, tail[i] = ins(t);    &#125;    std::vector&lt;std::vector&lt;int&gt; &gt; g(tot + 2);    &#123;        std::queue&lt;int&gt; q;        for (int i = 0; i &lt; 26; ++i)            if (T[0][i])                q.push(T[0][i]);        for (; !q.empty(); ) &#123;            int u = q.front();            q.pop();            for (int i = 0; i &lt; 26; ++i)                if (T[u][i]) &#123;                    int v = T[u][i];                    fail[v] = T[fail[u]][i];                    q.push(v);                &#125;                else                    T[u][i] = T[fail[u]][i];        &#125;        for (int i = 1; i &lt;= tot; ++i)            g[fail[i] + 1].push_back(i + 1);    &#125;    std::vector&lt;std::array&lt;int, 22&gt; &gt; f(tot + 2);    std::vector&lt;int&gt; dep(tot + 2), dfn(tot + 2), siz(tot + 2);    std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;        static int now = 0;        siz[x] = 1, dfn[x] = ++now;        // printf(&quot;%d\n&quot;, x);        for (auto i : g[x]) &#123;            dep[i] = dep[x] + 1;            f[i][0] = x;            for (int j = 1; j &lt;= 21; ++j)                f[i][j] = f[f[i][j - 1]][j - 1];            DFS(i), siz[x] += siz[i];        &#125;        return;    &#125;;    dep[1] = 1, DFS(1);    auto askLCA = [&amp;](int x, int y) &#123;        if (x == y)            return x;        if (dep[x] &lt; dep[y])            std::swap(x, y);        for (int i = 21; ~i; --i)            if (dep[f[x][i]] &gt;= dep[y])                x = f[x][i];        if (x == y)            return x;        for (int i = 21; ~i; --i)            if (f[x][i] != f[y][i])                x = f[x][i], y = f[y][i];        return f[x][0];    &#125;;    std::cin &gt;&gt; q;    for (; q--; ) &#123;        int op;        std::cin &gt;&gt; op;        if (op == 1) &#123;            std::string s;            std::cin &gt;&gt; s;            int p = 0, len = (int)s.length();            std::vector&lt;int&gt; id(len + 1);            for (int i = 1; i &lt;= len; ++i)                p = T[p][s[i - 1] - &#39;a&#39;], id[i] = p + 1;            std::sort(id.begin() + 1, id.end(), [&amp;](int x, int y) &#123; return dfn[x] &lt; dfn[y]; &#125;);            // for (int i = 1; i &lt;= len; ++i)            //     printf(&quot;%d &quot;, id[i]);            // puts(&quot;&quot;);            for (int i = 1; i &lt;= len; ++i) &#123;                // printf(&quot;%d %d %d\n&quot;, i, id[i], dfn[id[i]]);                // assert(0);                add(dfn[id[i]], 1);                if (i != 1)                    add(dfn[askLCA(id[i], id[i - 1])], -1);            &#125;        &#125;        else &#123;            int x;            std::cin &gt;&gt; x;            x = tail[x] + 1;            std::cout &lt;&lt; ask(dfn[x] + siz[x] - 1) - ask(dfn[x] - 1) &lt;&lt; &#39;\n&#39;;        &#125;    &#125;    return 0;&#125;</code></pre></details><hr /><h3 id="eg2.">eg2.</h3><hr /><h2 id="ac-自动机上的-dp">AC 自动机上的 DP</h2><p>鉴于 AC 自动机的优秀结构与性质，并不经常作为字符串匹配工具出现，其一个应用是作为 DP 的载体。</p><h3 id="eg1.-l-语言">eg1. L 语言</h3><p><a href="https://www.luogu.com.cn/problem/P2292" class="uri">https://www.luogu.com.cn/problem/P2292</a></p><p>我们想到要在自动机上匹配，但此时 <code>fail</code> 作为「断句」的唯一手段（断句的位置在链上当前点深度 - <code>fail</code> 深度处），不再仅当失配时才能经过。我们考虑朴素的 DP：在经过的每个状态考虑断句，那么这要求断句处是一个单词的结尾，那么此时 <code>fail</code> 最长匹配长度即可被更新。最后遍历所有单词的末结点，取最大答案。这里的 <code>fail</code> 其实是 <code>fail</code> 链上任意一点。</p><p>考虑复杂度。容易发现对于每一个点我们跳了其整条 fail 链，那么复杂度就是最劣 <span class="math inline">\(n^2\)</span> 的。考虑优化这个过程至 <span class="math inline">\(O(1)\)</span>。</p><p>题目里有一个很重要的条件还没有用到：单个单词长度 <span class="math inline">\(\le 20\)</span>，这让我们想到状态压缩。对于每一个状态，记录其断出来单词的可能长度。</p><p>我们在 DAG 上游走的时候记录目前可以断的所有位置，如果其和当前可断出来的长度之交不为空，就可以将此处加入「可以断的所有位置」并更新答案。</p><details><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;const int maxn = 2e5 + 5;int T[maxn][26], tot, fail[maxn], len[maxn], dep[maxn], tag[maxn];int ins(std::string &amp;t) &#123;    int p = 0;    for (auto i : t) &#123;        if (!T[p][i - &#39;a&#39;])            T[p][i - &#39;a&#39;] = ++tot, dep[tot] = dep[p] + 1;        p = T[p][i - &#39;a&#39;];    &#125;    ++tag[p];    return p;&#125;int main() &#123;#ifdef ONLINE_JUDGE    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr), std::cout.tie(nullptr);#else    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);#endif    int n, m;    std::cin &gt;&gt; n &gt;&gt; m;    std::vector&lt;int&gt; tail(n + 1);    std::vector&lt;std::string&gt; t(n + 1);    for (int i = 1; i &lt;= n; ++i)        std::cin &gt;&gt; t[i], tail[i] = ins(t[i]);    &#123;        std::queue&lt;int&gt; q;        for (int i = 0; i &lt; 26; ++i)            if (T[0][i])                q.push(T[0][i]);        for (; !q.empty(); ) &#123;            int u = q.front();            q.pop();            len[u] = len[fail[u]];            if (tag[u])                len[u] |= (1 &lt;&lt; dep[u]);            for (int i = 0; i &lt; 26; ++i)                if (T[u][i]) &#123;                    int v = T[u][i];                    fail[v] = T[fail[u]][i];                    q.push(v);                &#125;                else                    T[u][i] = T[fail[u]][i];        &#125;    &#125;    for (; m--; ) &#123;        std::string s;        std::cin &gt;&gt; s;        int p = 0, q = 1, res = 0;        for (int i = 0; i &lt; (int)s.length(); ++i) &#123;            p = T[p][s[i] - &#39;a&#39;], q &lt;&lt;= 1;            if (len[p] &amp; q)                q |= 1, res = i + 1;        &#125;        std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;    &#125;    return 0;&#125;</code></pre></details><hr /><h3 id="eg2.-popcount-words">eg2. Popcount Words</h3><p><a href="https://codeforces.com/gym/103409/problem/H" class="uri">https://codeforces.com/gym/103409/problem/H</a></p><p><del>咋上强度了啊。</del></p><p>先把整个序列写出来，即 <span class="math inline">\(w=\texttt{01101001100101}\cdots\)</span>，尝试进一步探究形式化的规律，可以得到：</p><ol type="1"><li><span class="math inline">\(w_{[0, 2^n), 0}=w_{[0, 2^{n-1}),0}+w_{[0, 2^n), 1}\)</span>，其中 <span class="math inline">\(w_{[l, r], 0/1}\)</span> 表示 <span class="math inline">\([l, r]\)</span> 内，原串 / 取反的值。</li><li>对于不以 <span class="math inline">\(0\)</span> 开头的整段，可以从上述规则转化为 <span class="math inline">\(0\)</span> 开头的整段。</li></ol><p>接着不难想到一种类似线段树的方式，将待求的 <span class="math inline">\(w_{[l, r], 0}\)</span> 分到 <span class="math inline">\(O(\log V)\)</span> 个整段上，那么 <span class="math inline">\(S\)</span> 就可以被 <span class="math inline">\(O(n\log V)\)</span> 个整段（也是 <span class="math inline">\(\log V\)</span> 个本质不同整段）描述。</p><p>我们对 <span class="math inline">\({p_m}\)</span> 建立 AC 自动机，需要知道这 <span class="math inline">\(\log V\)</span> 个整段在每个点上的出现次数。对于自动机上任意状态 <span class="math inline">\(u\)</span>，设 <span class="math inline">\(to_{u, n, 0/1}\)</span> 表示 <span class="math inline">\(u\)</span> 经过 <span class="math inline">\(w_{[0, 2^n), 0/1}\)</span> 后到达的点，则可倍增（嘶，这里是不是应该反过来叫分治啊）简单解决。</p><p>那么接下来我们就可以用 <span class="math inline">\(to\)</span> 来进行快速游走了。顺便打个 <span class="math inline">\(cnt\)</span> 记录一下每个 <span class="math inline">\(u\)</span> 作为不同整段的开头被经过的次数。然后做一个 DP，类似于线段树上 <code>pushdown</code> 的操作把所有整段下放到单点上的单个字符。</p><p>有一说一用 DP 来处理这个东西还挺难想的。可能也是基于前面的倍增吧。最后拓扑排序就行了。</p><details><p>大家数组一定要用 C-style array 啊，<code>std::vector&lt;&gt;</code> 计算的是申请空间包 MLE 的 <img src="/em/ll.gif" /></p><p>大家大数组一定要内存连续访问优化啊，TLE <span class="math inline">\(\to\)</span> 100ms 泪目了 <img src="/em/ll.gif" /></p><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;const int maxn = 5e5 + 5;long long sum[maxn], f[2][30][maxn];int cnt[2][30][maxn], to[2][30][maxn];int T[maxn][2], tot, fail[maxn], deg[maxn];int ins(std::string &amp;t) &#123;    int p = 0;    for (auto i : t) &#123;        if (!T[p][i - &#39;0&#39;])            T[p][i - &#39;0&#39;] = ++tot;        p = T[p][i - &#39;0&#39;];    &#125;    return p;&#125;void ask(std::vector&lt;std::pair&lt;int, int&gt; &gt; &amp;s, int ql, int qr, int l = 0, int r = (1 &lt;&lt; 30) - 1, int len = 30, int v = 0) &#123;    if (ql &lt;= l &amp;&amp; r &lt;= qr) &#123;        s.emplace_back(len, v);        return;    &#125;    int mid = l + (r - l) / 2;    if (ql &lt;= mid)        ask(s, ql, qr, l, mid, len - 1, v);    if (qr &gt; mid)        ask(s, ql, qr, mid + 1, r, len - 1, v ^ 1);    return;&#125;int main() &#123;#ifdef ONLINE_JUDGE    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr), std::cout.tie(nullptr);#else    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);#endif    int n, m;    std::cin &gt;&gt; n &gt;&gt; m;    std::vector&lt;std::pair&lt;int, int&gt; &gt; s;    for (int i = 1; i &lt;= n; ++i) &#123;        int l, r;        std::cin &gt;&gt; l &gt;&gt; r;        ask(s, l, r);    &#125;    std::vector&lt;int&gt; tail(m + 1);    for (int i = 1; i &lt;= m; ++i) &#123;        std::string t;        std::cin &gt;&gt; t;        tail[i] = ins(t);    &#125;    &#123;        std::queue&lt;int&gt; q;        for (int i = 0; i &lt; 2; ++i)            if (T[0][i])                q.push(T[0][i]);        for (; !q.empty(); ) &#123;            int u = q.front();            q.pop();            for (int i = 0; i &lt; 2; ++i)                if (T[u][i]) &#123;                    int v = T[u][i];                    fail[v] = T[fail[u]][i], ++deg[T[fail[u]][i]];                    q.push(v);                &#125;                else                    T[u][i] = T[fail[u]][i];        &#125;    &#125;    for (int i = 0; i &lt;= tot; ++i)        to[0][0][i] = T[i][0], to[1][0][i] = T[i][1];    for (int j = 1; j &lt; 30; ++j)        for (int i = 0; i &lt;= tot; ++i) &#123;            to[0][j][i] = to[1][j - 1][to[0][j - 1][i]];            to[1][j][i] = to[0][j - 1][to[1][j - 1][i]];        &#125;    &#123;        int p = 0;        for (auto [n, i] : s) &#123;            // printf(&quot;# %d %d\n&quot;, n, i);            ++cnt[i][n][p], p = to[i][n][p];        &#125;    &#125;    for (int j = 29; ~j; --j)        for (int i = 0; i &lt;= tot; ++i) &#123;            if (j != 29) &#123;                f[0][j][i] += f[0][j + 1][i];                f[1][j][i] += f[1][j + 1][i];                f[0][j][to[1][j][i]] += f[1][j + 1][i];                f[1][j][to[0][j][i]] += f[0][j + 1][i];            &#125;            f[1][j][i] += cnt[1][j][i];            f[0][j][i] += cnt[0][j][i];        &#125;    for (int i = 0; i &lt;= tot; ++i) &#123;        sum[T[i][0]] += f[0][0][i], sum[T[i][1]] += f[1][0][i];        // printf(&quot;%d %d\n&quot;, f[i][0][0], f[i][0][1]);    &#125;    &#123;        std::queue&lt;int&gt; q;        for (int i = 0; i &lt;= tot; ++i)            if (!deg[i])                q.push(i);        for (; !q.empty(); ) &#123;            int u = q.front();            q.pop();            sum[fail[u]] += sum[u];            if (!--deg[fail[u]])                q.push(fail[u]);        &#125;    &#125;    for (int i = 1; i &lt;= m; ++i)        std::cout &lt;&lt; sum[tail[i]] &lt;&lt; &#39;\n&#39;;    return 0;&#125;</code></pre></details><hr /><h3 id="eg3.-legen">eg3. Legen…</h3><p><a href="https://codeforces.com/problemset/problem/696/D" class="uri">https://codeforces.com/problemset/problem/696/D</a></p><p>先在 fail 树上把每个状态的实际价值计算出来。我们发现匹配串是未知的，也就是我们需要主动决定游走路径。注意到 <span class="math inline">\(l=10^{14}\)</span>，考虑矩阵。</p><p>令 <span class="math inline">\(f_{u, i}\)</span> 表示在 <span class="math inline">\(u\)</span> 状态时已经走了 <span class="math inline">\(i\)</span> 步，可以得到的最大价值。那么显然有：</p><p><span class="math display">\[f_{v,i+1}=f_{u,i}+s_v.\]</span></p><p>其中 <span class="math inline">\(v\)</span> 是自动机上 <span class="math inline">\(u\)</span> 的任意出边。图的大小为 <span class="math inline">\(200\)</span>，可以放到 <span class="math inline">\(+\max\)</span> 矩阵里加速转移。</p><details><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;const int maxn = 2e5 + 5;const long long inf = 1e18;int fail[maxn], T[maxn][26], tot;int ins(std::string s) &#123;    int p = 0;    for (auto i : s) &#123;        if (!T[p][i - &#39;a&#39;])            T[p][i - &#39;a&#39;] = ++tot;        p = T[p][i - &#39;a&#39;];    &#125;    return p;&#125;struct matrix &#123;    int n, m;    std::vector&lt;std::vector&lt;long long&gt; &gt; a;    matrix(int n1, int m1, long long v = -inf, bool op = 0): n(n1), m(m1), a(n + 1, std::vector&lt;long long&gt; (m + 1, v)) &#123;        if (op)            for (int i = 0; i &lt;= n; ++i)                a[i][i] = 0;        return;    &#125;    std::vector&lt;long long&gt; &amp;operator[] (int i) &#123;        return a[i];    &#125;    matrix operator* (matrix &amp;q) const &#123;        matrix res(n, q.m);        for (int k = 0; k &lt;= m; ++k)            for (int i = 0; i &lt;= n; ++i)                for (int j = 0; j &lt;= q.m; ++j)                    res[i][j] = std::max(res[i][j], a[i][k] + q[k][j]);        return res;    &#125;    matrix&amp; operator*= (matrix q) &#123;        return *this = *this * q;    &#125;    matrix operator^ (long long q) &#123;        matrix res(n, n, -inf, 1), x(*this);        for (; q; q &gt;&gt;= 1, x *= x)            if (q &amp; 1)                res *= x;        return res;    &#125;&#125;;int main() &#123;#ifdef ONLINE_JUDGE    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr), std::cout.tie(nullptr);#else    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);#endif    int n;    long long m;    std::cin &gt;&gt; n &gt;&gt; m;    std::vector&lt;long long&gt; a(n + 1);    for (int i = 1; i &lt;= n; ++i)        std::cin &gt;&gt; a[i];    std::vector&lt;int&gt; tail(n + 1);    std::vector&lt;std::string&gt; t(n + 1);    for (int i = 1; i &lt;= n; ++i) &#123;        std::cin &gt;&gt; t[i];        tail[i] = ins(t[i]);    &#125;    std::vector&lt;long long&gt; s(tot + 1);    for (int i = 1; i &lt;= n; ++i)        s[tail[i]] += a[i];    &#123;        std::queue&lt;int&gt; q;        for (int i = 0; i &lt; 26; ++i)            if (T[0][i])                q.push(T[0][i]);         for (; !q.empty(); ) &#123;            int u = q.front();            q.pop();            for (int i = 0; i &lt; 26; ++i)                if (T[u][i]) &#123;                    int v = T[u][i];                    fail[v] = T[fail[u]][i], s[v] += s[fail[v]];                    q.push(v);                &#125;                else                    T[u][i] = T[fail[u]][i];        &#125;    &#125;    matrix f(0, tot), op(tot, tot);    f[0][0] = 0;    for (int i = 0; i &lt;= tot; ++i)        for (int j = 0; j &lt; 26; ++j)            op[i][T[i][j]] = s[T[i][j]];    f *= (op * m);    std::cout &lt;&lt; *std::max_element(f[0].begin(), f[0].end()) &lt;&lt; &#39;\n&#39;;    return 0;&#125;</code></pre></details><hr /><h3 id="eg4.-you-are-given-some-strings">eg4. You Are Given Some Strings…</h3><p>goto <a href="/20250121/#%E4%B8%80%E4%B8%AA%E6%A8%A1%E6%9D%BFcf1202e-you-are-given-some-strings...">link</a>.</p>]]></content>
      
      
      
        <tags>
            
            <tag> DP </tag>
            
            <tag> 字符串 </tag>
            
            <tag> AC 自动机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>杂题</title>
      <link href="/20241104/"/>
      <url>/20241104/</url>
      
        <content type="html"><![CDATA[<p>哭いた閃光が目に刺さる / お別かれの鐘が鳴る / 神が成した歴史の / 結ぶ答えは砂の味がする</p><span id="more"></span><hr /><h2 id="a.-美味しい美味しいハンバーグ">A. 美味しい美味しいハンバーグ</h2><p><a href="https://vjudge.net/contest/669299#problem/A" class="uri">https://vjudge.net/contest/669299#problem/A</a></p><p>有一个很神奇的随机化做法：我们从前往后串签子，最开始签子数为 <span class="math inline">\(0\)</span>，如果当前任何一个签子都没办法再串这一个就新增签子。如果没有签子可以用了，就说明这块肉不合法，挪到前 <span class="math inline">\(k\)</span> 块中的随机位置使其优先被选择。</p><p>你会发现这个做法跑得很快，spdarkle 说因为 <span class="math inline">\(K\)</span> 很小还保证有解，所以期望次数是非常对的。我太菜了他也没细说所以开摆。</p><p>由于神秘原因，我的 <code>std::mt19937::operator()</code> 如果外边不套一层 abs 就会起飞 <img src="/em/yun.gif" alt="晕" /></p><details><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;int main() &#123;#ifdef ONLINE_JUDGE    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr), std::cout.tie(nullptr);#else    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);#endif    int n, k;    std::cin &gt;&gt; n &gt;&gt; k;    struct _ &#123; int l, r, u, d; &#125;;    std::vector&lt;_&gt; a(n + 1), b(k + 1);    std::mt19937 rand(time(nullptr));    auto random = [&amp;](int l, int r) &#123;        return l + std::abs((int)rand()) % (r - l + 1);    &#125;;    for (int i = 1; i &lt;= n; ++i)        std::cin &gt;&gt; a[i].l &gt;&gt; a[i].u &gt;&gt; a[i].r &gt;&gt; a[i].d;    for (;;) &#123;        std::copy(a.begin() + 1, a.begin() + k + 1, b.begin() + 1);        for (int i = k + 1; i &lt;= n; ++i) &#123;            for (int j = 1; j &lt;= k; ++j) &#123;                if (std::min(b[j].r, a[i].r) &gt;= std::max(b[j].l, a[i].l) &amp;&amp; std::min(b[j].d, a[i].d) &gt;= std::max(b[j].u, a[i].u)) &#123;                    b[j].l = std::max(b[j].l, a[i].l);                    b[j].r = std::min(b[j].r, a[i].r);                    b[j].u = std::max(b[j].u, a[i].u);                    b[j].d = std::min(b[j].d, a[i].d);                    goto issol;                &#125;            &#125;            std::swap(a[i], a[random(1, i)]);            goto nosol;        issol: ;        &#125;        for (int i = 1; i &lt;= k; ++i)            std::cout &lt;&lt; b[i].l &lt;&lt; &#39; &#39; &lt;&lt; b[i].u &lt;&lt; &#39;\n&#39;;        break;    nosol: ;    &#125;    return 0;&#125;</code></pre></details><hr /><h2 id="b.-shik-and-travel">B. Shik and Travel</h2><p><a href="https://vjudge.net/contest/669299#problem/B" class="uri">https://vjudge.net/contest/669299#problem/B</a></p><p>最小化最大，显然需要二分答案，check 打个 DP。具体怎么 DP 呢？首先考虑暴力，设 <span class="math inline">\(f_{u, a, b}\)</span> 表示在当前 <span class="math inline">\(mid\)</span> 的限制下，从 <span class="math inline">\(u\)</span> 出发到第一个叶子距离为 <span class="math inline">\(a\)</span>，最后一个距离为 <span class="math inline">\(b\)</span> 的可行性。那么有 <span class="math inline">\(f_{u,a,b} = (f_{l,a,i}\land f_{r,j,b})\lor (f_{r,a,i}\land f_{l,j,b})\)</span>。</p><p>先不说转移，状态数已经难以接受。所以我们从状态数入手，显然如果存在一个 <span class="math inline">\(a&#39;\le a\)</span> 和 <span class="math inline">\(b&#39;\le b\)</span>，那么 <span class="math inline">\((a&#39;,b&#39;)\)</span> 就是无用状态。也就是说，我们把所有有用的 <span class="math inline">\((a, b)\)</span> 按 <span class="math inline">\(a\)</span> 从小到大排序，<span class="math inline">\(b\)</span> 应该是单调递减的；考虑这个抽象的过程，相当于从头到尾遍历一串状态，在路上碰到的所有较大的 <span class="math inline">\(b\)</span> 都会被当场丢弃。</p><p>感性思考可以发现<mark>当我们试图让 <span class="math inline">\(b\)</span> 最小的时候，这个状态最有用（即最不可能被丢弃）</mark>。对于一个 <span class="math inline">\(f_{l,a,i}\)</span>，我们找到能够转移的 <span class="math inline">\(f_{r,j,b_{\min}}\)</span> 来转移。正确性很好证明，我们的 check 只要求在根节点上存在任意合法状态，那只需要让最不可能被丢弃的不被丢弃即可，更可能被丢弃的状态是否被丢弃就不会产生影响了。</p><p>优化后的状态数在 <span class="math inline">\(u\)</span> 上只会增加 <span class="math inline">\(\min(|a_l|,|b_r|)+\min(|a_r|,|b_l|)\)</span>，即两个儿子上的状态数较小者，参考 DSU on tree，是 <span class="math inline">\(O(n\log)\)</span> 的。加上对状态排序的数据结构，复杂度 <span class="math inline">\(O(n\log^2 n\log V)\)</span>。</p><details><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;const long long inf = 1e18;int main() &#123;#ifdef ONLINE_JUDGE    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr), std::cout.tie(nullptr);#else    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);#endif    int n;    std::cin &gt;&gt; n;    std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; g(n + 1);    for (int i = 2, x, w; i &lt;= n; ++i) &#123;        std::cin &gt;&gt; x &gt;&gt; w;        g[x].emplace_back(i, w);    &#125;    long long res = -1;    for (long long l = 0, r = inf, mid; l &lt;= r; ) &#123;        mid = (l + r) &gt;&gt; 1;        if ([&amp;](void) -&gt; bool &#123;            std::vector&lt;std::vector&lt;std::pair&lt;long long, long&gt; &gt; &gt; f(n + 1);            std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;                if (g[x].empty()) &#123;                    f[x].emplace_back(0, 0);                    return;                &#125;                long long lim = mid;                for (auto [i, w] : g[x])                    DFS(i), lim -= w;                std::vector&lt;std::pair&lt;long long, long long&gt; &gt; t;                for (int i = 0; i &lt; 2; ++i) &#123;                    int j = 0;                    auto l = g[x][0], r = g[x][1];                    for (auto [a, b] : f[l.first]) &#123;                        for (; j + 1 &lt; (int)f[r.first].size() &amp;&amp; f[r.first][j + 1].first + b &lt;= lim; ++j);                        if (j &lt; (int)f[r.first].size() &amp;&amp; f[r.first][j].first + b &lt;= lim)                            t.emplace_back(a + l.second, f[r.first][j].second + r.second);                    &#125;                    std::swap(g[x][0], g[x][1]);                &#125;                std::sort(t.begin(), t.end());                for (auto [a, b] : t)                    if (f[x].empty() || f[x].back().second &gt; b)                        f[x].emplace_back(a, b);                return;            &#125;;            DFS(1);            return !f[1].empty();        &#125; ())            res = mid, r = mid - 1;        else             l = mid + 1;    &#125;    std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;    return 0;&#125;</code></pre></details><hr /><h2 id="d.-candy-piles">D. Candy Piles</h2><p><a href="https://vjudge.net/contest/669299#problem/D" class="uri">https://vjudge.net/contest/669299#problem/D</a></p><p>不难发现我们可以把题意转化为，把所有列从大到小排列，每次可以选择删掉最左边一列或最下边一行，删空者胜。</p><p>把该柱状图转化为网格图，定义边界为胜利点，对于非边界上的点，其一定可以往右走、往上走。若一个点上方、右侧点均为胜利点，此点为失败点；否则，此点为胜利点。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CSP-S</title>
      <link href="/20241027/"/>
      <url>/20241027/</url>
      
        <content type="html"><![CDATA[<p>弟娃年方十一。方出考场之时，余问弟娃曰：「T1 用时几何？」。弟娃对曰：「及过大样例，已半炷香矣。」余大恸，为余 T1 大样例既过，已两柱香有余。古谚有云：「若有一人年少于吾亦强于吾，吾为之单调队列也。」吾弟娃年少于吾，殊难易之；今吾弟娃已四倍而强于吾，吾盍为单调队列哉！</p><span id="more"></span><hr /><p>忆往昔昔（初二），1=。忆往昔昔昔（初一），1=。忆往昔（初三），135pts 喜提 2=。</p><p>看今朝，300pts 应该有 1=。哇恭喜恭喜，2= 到 1=，一年来你有很大进步呢！</p><hr /><h2 id="a.-duel">A. duel</h2><p>非常遗憾地，被橙题<mark>硬控 1h+</mark>。问就是上场之后先花了 59min 下载 <em>大脑.tar.gz</em>，然后 1s 知道做法，59s 实现。</p><p>其实我们是注意到了众数的那个奇妙结论的，但是因为太奇怪并且担心是因为大样例太水所以没敢写，不服来战。</p><hr /><h2 id="b.-detect">B. detect</h2><p>我们在求解出区间后被精度问题<mark>硬控 1h+</mark>。在按照右端点排序后超厉害地使用 <strong>线段树优化 DP</strong> 解决了初一简单线性贪心问题。哈哈哈。</p><p>笑话：被精度问题控的 1h 里有 40min 扑在因为调精度而打出来的 <em>死循环</em> 上 <img src="/em/kx.gif" /></p><hr /><h2 id="c.-color">C. color</h2><p>在 5min 解决费用提前计算式子后删除了 node_modules &gt; 大脑，稍加思考得出了「大抵是不存在不带 <span class="math inline">\(\log\)</span> 的全局修改、单点修改、单点查询的数据结构的」的结论，超厉害地使用 <strong>线段树优化 DP</strong>，并且被全局修改懒标记没传给树根<mark>硬控 1h+</mark>。</p><p>不过因为知道 1e6 的数据给线段树确实挺奇怪的，所以大力卡常，赛时代码跑民间数据跑得挺快。也就是线性所有点加起来 500ms，我一个点就要跑 500ms 的水平 <img src="/em/kx.gif" /> 虽然肯定 T 是不可能 T 的。</p><hr /><h2 id="d.-arena">D. arena</h2><p>坏消息：前三题均被硬控 1h+，T4 连暴力都打不完了，甚而至于，输入都打不完喜提零蛋。</p><p>好消息：看开点，至少 T4 不会被<mark>硬控 1h+</mark> <img src="/em/kx.gif" /></p><p>这道题有个好写的做法，先胡一胡，等会儿开一篇具体写一写。</p><p>还原到每场比赛胜出者能力值（线性），还需要注意到一个单调性：若在加入一个人后某场比赛的胜者就不可能成为全局胜者（相当于知道其祖先中某个元素的具体胜者，且该胜者不是自己），那么加入更多的人也不行。故记录这个人（假设对于比赛 <span class="math inline">\(x\)</span> 为 <span class="math inline">\(id_x\)</span>），那么知道了所有叶子的 <span class="math inline">\(id\)</span> 就可以随便乱搞了。至于求 <span class="math inline">\(id\)</span> 的过程，直接把 <span class="math inline">\(1\sim n\)</span> 的人加入二叉树，如果某个点被确定了胜者，就往败者子树打一个标记，完了过后遍历整个树下传标记即可。</p><hr /><p>小知识：在 2024 CSP-S2 中，99% 的人打了 0 个 <strong>线段树优化 DP</strong>，而你打了 2 个 <strong>线段树优化 DP</strong> <img src="/em/kx.gif" /></p><hr /><p>可怜捏。100 + 100 + 100 + 0 = 300。由于 T4 输入没写完是没机会浮动了。拜拜 WC。</p><p>草草草，wc 都拜拜了我今年是不是直接原地 afo 了啊。不要啊不要啊。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 下饭 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>长链剖分 学习笔记</title>
      <link href="/20241021-1/"/>
      <url>/20241021-1/</url>
      
        <content type="html"><![CDATA[<p><em>半端な生命の関数を / 少々ここらでオーバーライド</em></p><span id="more"></span><hr /><h2 id="内容-性质">内容 &amp; 性质</h2><p>把重链剖分选的 siz 最大的儿子换成高度最大的儿子就是长剖了。同样具有一些美妙的性质。</p><ul><li><p>任意点到根节点经过的链数最劣为 <span class="math inline">\(\sqrt n\)</span>。</p><p>考虑构造一条经过了 <span class="math inline">\(\sqrt n+1\)</span> 条链的路径，发现构造不出来。得证。（？）</p>这点也决定了长剖和重剖走的不是一条赛道，更多的是处理一些和深度有关的场景下的问题。用法有点像 dsu on tree。</li><li><p>任意点 <span class="math inline">\(x\)</span> 的 <span class="math inline">\(k\)</span> 级祖先 <span class="math inline">\(fa\)</span> 所在链长 <span class="math inline">\(\ge k\)</span>。</p><p>考虑反证。若 <span class="math inline">\(fa\)</span> 所在链长度 <span class="math inline">\(&lt;k\)</span>，则 <span class="math inline">\(fa\to x\)</span> 更优，矛盾。故原命题成立。</p></li></ul><hr /><h2 id="求-k-级祖先">求 k 级祖先</h2><p>长剖的一个典型应用是 <span class="math inline">\(O(n\log n)-O(1)\)</span> 求 <span class="math inline">\(k\)</span> 级祖先。先考虑相对暴力的做法，可以 <span class="math inline">\(O(n\sqrt n)\)</span> 预处理每个点的 <span class="math inline">\(1\sim \sqrt n\)</span> 级祖先然后块间块内随便跳一跳就是 <span class="math inline">\(O(\sqrt n)\)</span> 的单次查询了。</p><p>把这个暴力结合「任意点 <span class="math inline">\(k\)</span> 级祖先所在链长 <span class="math inline">\(\ge k\)</span>」的性质，令 <span class="math inline">\(r=\dfrac k2\)</span>，那么 <span class="math inline">\(x\)</span> 的 <span class="math inline">\(r\)</span> 级祖先所在链长 <span class="math inline">\(\ge r\)</span>。假设我们现在已经知道 <span class="math inline">\(r\)</span> 级祖先 <span class="math inline">\(fa_r\)</span>，预处理出链内点序列、链顶向上的链长个祖先（均摊 <span class="math inline">\(O(n)\)</span>），就可以 <span class="math inline">\(O(1)\)</span> 访问 <span class="math inline">\(fa_k\)</span>。</p><p>怎么找到 <span class="math inline">\(fa_r\)</span> 呢？这看似是递归的问题，实际上发现 <span class="math inline">\(r\)</span> 的取值只需 <span class="math inline">\(\ge \dfrac k2\)</span>，对于 <span class="math inline">\(1\sim n\)</span> 的每一个 <span class="math inline">\(k\)</span>，找到其最高二进制位 <span class="math inline">\(r\)</span>（显然 <span class="math inline">\(r\)</span> 的可能取值有 <span class="math inline">\(\log n\)</span> 种），对于每个点，预处理出其 <span class="math inline">\(\log n\)</span> 个不同的 <span class="math inline">\(r\)</span> 级祖先。这个就是倍增了。</p><details><pre class="cpp"><code>for (int i = 1, mx = 0; i &lt;= n; ++i) &#123;    if (i &gt;= (1 &lt;&lt; mx) * 2)        ++mx;    to[i] = mx;&#125;std::vector&lt;std::array&lt;int, 21&gt; &gt; fa(n + 1);std::vector&lt;int&gt; h(n + 1, 1), son(n + 1), dep(n + 1);h[0] = 0;std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;    for (auto i : g[x])        if (i != fa[x][0]) &#123;            fa[i][0] = x;            for (int j = 1; j &lt;= 20; ++j)                fa[i][j] = fa[fa[i][j - 1]][j - 1];            dep[i] = dep[x] + 1;            DFS(i);            if (h[i] &gt;= h[son[x]])                son[x] = i, h[x] = h[i] + 1;        &#125;    return;&#125;;dep[1] = 1, DFS(1);std::vector&lt;int&gt; top(n + 1), id(n + 1);std::vector&lt;std::vector&lt;int&gt; &gt; anc(n + 1), des(n + 1, std::vector&lt;int&gt; (1));std::function&lt;void(int, int)&gt; DFS1 = [&amp;](int x, int toq) &#123;    top[x] = toq;    if (son[x])        DFS1(son[x], toq);    for (auto i : g[x])        if (i != fa[x][0] &amp;&amp; i != son[x])            DFS1(i, i);    des[toq].push_back(x);    id[x] = (int)des[toq].size() - 1;    if (x == toq) &#123;        anc[x].push_back(x);        for (int j = 1, now = x; j &lt;= id[x]; ++j, now = fa[now][0])            anc[x].push_back(fa[now][0]);    &#125;    return;&#125;;DFS1(1, 1);auto ask = [&amp;](int x, int k) &#123;    int x1 = x;    if (!k)        return x;    x = fa[x][to[k]];    if (dep[x] - dep[top[x]] &gt;= k - (1 &lt;&lt; to[k]))        return des[top[x]][id[x] + k - (1 &lt;&lt; to[k])];    return anc[top[x]][k - (1 &lt;&lt; to[k]) - (dep[x] - dep[top[x]])];&#125;;</code></pre></details><hr /><h2 id="优化-dp">优化 DP</h2><blockquote><p>yly：管它这那的，只要是有关深度直接上长剖就是了。</p></blockquote><p>我还想上呢，怎么上啊？？？</p><hr /><h3 id="p5904-poi-2014-hot-hotels-加强版">P5904 [POI 2014] HOT-Hotels 加强版</h3><p><a href="https://www.luogu.com.cn/problem/P5904" class="uri">https://www.luogu.com.cn/problem/P5904</a></p><p>首先 <del>不难</del> 得到 <span class="math inline">\(O(n^2)\)</span> 做法：显然存在一个点到三个点距离相等。这个点既可能是它们的 LCA，也可能是其中一个点的子孙，另外两个点的 LCA。总之在 LCA 处统计答案是可行的。</p><p>令 <span class="math inline">\(f_{i,j}\)</span> 表示 <span class="math inline">\(i\)</span> 子树中距离 <span class="math inline">\(i\)</span> 为 <span class="math inline">\(j\)</span> 的点数；<span class="math inline">\(g_{i,j}\)</span> 表示 <span class="math inline">\(i\)</span> 子树中距离 <span class="math inline">\(i\)</span> 为 <span class="math inline">\(j\)</span>、或者距 LCA 为 <span class="math inline">\(d\)</span> 且 LCA 距离 <span class="math inline">\(i\)</span> 为 <span class="math inline">\(d-j\)</span> 的点对数；随便做就可以了。</p><details><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;int main() &#123;#ifdef ONLINE_JUDGE    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr), std::cout.tie(nullptr);#else    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);#endif    int n;    std::cin &gt;&gt; n;    std::vector&lt;std::vector&lt;int&gt; &gt; g1(n + 1);    for (int i = 1, x, y; i &lt; n; ++i) &#123;        std::cin &gt;&gt; x &gt;&gt; y;        g1[x].push_back(y), g1[y].push_back(x);    &#125;    auto res(0ll);    std::vector&lt;int&gt; h(n + 1);    std::vector&lt;std::vector&lt;long long&gt; &gt; f(n + 1), g(n + 1);    std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int fa) &#123;        h[x] = 1;        for (auto i : g1[x])            if (i != fa) &#123;                DFS(i, x);                h[x] = std::max(h[x], h[i] + 1);            &#125;        f[x].resize(h[x] + 1), g[x].resize(h[x] + 1);        f[x][0] = 1ll;        for (auto i : g1[x])            if (i != fa) &#123;                for (int j = 0; j &lt;= h[i]; ++j) &#123;                    if (j &gt;= 1)                        res += g[x][j] * f[i][j - 1];                    if (j &gt;= 1 &amp;&amp; j + 1 &lt;= h[i])                        res += f[x][j] * g[i][j + 1];                    if (j &gt;= 1) &#123;                        g[x][j] += f[x][j] * f[i][j - 1];                        f[x][j] += f[i][j - 1];                    &#125;                    if (j + 1 &lt;= h[i])                        g[x][j] += g[i][j + 1];                &#125;                std::vector&lt;long long&gt;().swap(f[i]);                std::vector&lt;long long&gt;().swap(g[i]);            &#125;        res += g[x][0];        return;    &#125;;    DFS(1, -1);    std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;    return 0;&#125;</code></pre></details><p>然后对于每个 <span class="math inline">\(u\)</span>，类似 DSU on tree，继承其长儿子的数据（整体前移 / 后移一位，使用指针实现），再把短儿子暴力合并上来。</p><p>每次合并短儿子，数组长为短儿子链长；<span class="math inline">\(u\)</span> 向上合并时，数组长为长儿子链长。故所有链被合并恰好一次，复杂度 <span class="math inline">\(O(n)\)</span>。</p><details><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;int main() &#123;#ifdef ONLINE_JUDGE    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr), std::cout.tie(nullptr);#else    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);#endif    int n;    std::cin &gt;&gt; n;    std::vector&lt;std::vector&lt;int&gt; &gt; g1(n + 1);    for (int i = 1, x, y; i &lt; n; ++i) &#123;        std::cin &gt;&gt; x &gt;&gt; y;        g1[x].push_back(y), g1[y].push_back(x);    &#125;    std::vector&lt;int&gt; h(n + 1), son(n + 1);    std::vector&lt;long long&gt; df(5 * n + 1), dg(5 * n + 1);    std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int fa) &#123;        h[x] = 1;        for (auto i : g1[x])            if (i != fa) &#123;                DFS(i, x);                h[x] = std::max(h[x], h[i] + 1);                if (h[i] &gt; h[son[x]])                    son[x] = i;            &#125;        return;    &#125;;    DFS(1, -1);    auto pos(dg.begin() + 3 * n);    std::vector&lt;decltype(df.begin())&gt; f(n + 1), g(n + 1);    auto res(0ll);    DFS = [&amp;](int x, int fa) &#123;        f[x][0] = 1ll;        if (son[x]) &#123;            f[son[x]] = std::next(f[x]), g[son[x]] = std::prev(g[x]);            DFS(son[x], x);        &#125;        for (auto i : g1[x])            if (i != fa &amp;&amp; i != son[x]) &#123;                f[i] = std::next(f[x], h[x] + 1);                std::fill(f[i], f[i] + h[i] + 2, 0ll);                g[i] = std::next(pos, h[i]), pos = std::next(g[i], h[i]);                std::fill(std::prev(g[i]), g[i] + h[i] + 2, 0ll);                DFS(i, x);                for (int j = 0; j &lt;= h[i]; ++j) &#123;                    if (j &gt;= 1)                        res += g[x][j] * f[i][j - 1];                    if (j &gt;= 1 &amp;&amp; j + 1 &lt;= h[i])                        res += f[x][j] * g[i][j + 1];                    if (j &gt;= 1) &#123;                        g[x][j] += f[x][j] * f[i][j - 1];                        f[x][j] += f[i][j - 1];                    &#125;                    if (j + 1 &lt;= h[i])                        g[x][j] += g[i][j + 1];                &#125;            &#125;        res += g[x][0];        return;    &#125;;    f[1] = df.begin(), g[1] = dg.begin() + 2 * n;    DFS(1, -1);    std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;    return 0;&#125;</code></pre></details><hr /><h3 id="cf1585g-poachers">CF1585G Poachers</h3><p><a href="https://www.luogu.com.cn/problem/CF1585G" class="uri">https://www.luogu.com.cn/problem/CF1585G</a></p><p>公平博弈。我们现在要算每个根的 SG 值。设 <span class="math inline">\(f_{u,j}\)</span> 表示在点 <span class="math inline">\(u\)</span>，删了距离它为 <span class="math inline">\(j\)</span> 这一层的 SG 值，那么有：</p><p><span class="math display">\[f_{u,j}=\begin{cases}\text{mex}\{f_{v,0}\}&amp;j=0\\\bigoplus f_{v,j-1}&amp;\text{otherwise}\end{cases}\]</span></p><p>然后发现有深度维。大力长剖。</p><hr />]]></content>
      
      
      
        <tags>
            
            <tag> 树链剖分 </tag>
            
            <tag> 长链剖分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符串</title>
      <link href="/20241021/"/>
      <url>/20241021/</url>
      
        <content type="html"><![CDATA[<p>标题本来叫「哈希」，后来发现第二天的很多题虽然打了哈希的 tag 但是只有 KMP 做法，故忍痛改成「字符串」。</p><span id="more"></span><hr /><h2 id="a.-two-permutations">A. Two Permutations</h2><p><a href="http://222.180.160.110:61235/contest/5653/problem/1" class="uri">http://222.180.160.110:61235/contest/5653/problem/1</a></p><p>有个很重要的性质是 <span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span> 都是排列。然后我们就知道了 <span class="math inline">\(x\in [0,m-n]\)</span>，且每个 <span class="math inline">\(a_i+x\)</span> 在 <span class="math inline">\(b\)</span> 中有元素与之唯一对应。<mark>于是问题可以转化成，<span class="math inline">\(b\)</span> 中在 <span class="math inline">\([1+x,n+x]\)</span> 范围中的元素按顺序哈希起来和 <span class="math inline">\(a\)</span> 序列是否完全一致</mark>。</p><p>我们就有了一个想法：枚举这个 <span class="math inline">\(x\)</span>，通过某种方法快速查询这个长度固定的值域区间按顺序哈希起来的值。<mark>然后就是典中典之线段树维护哈希，只需在枚举 <span class="math inline">\(x\)</span> 时滑动窗口，剔除头部元素，新增尾部元素，查询全局哈希值即可</mark>。</p><p>还有一个小细节是关于实时维护全局加 <span class="math inline">\(x\)</span> 后的 <span class="math inline">\(a\)</span>。由于哈希用乘的肯定拆不开，只能用加哈希了。每次 <span class="math inline">\(x\)</span> 加一的时候全局哈希值加上 <span class="math inline">\(\sum p_i\)</span> 即可。</p><details><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;const int p = 998244353;const int mod = 1e9 + 7;const int maxn = 2e5 + 5;struct &#123;    int l, r, s;    long long u;&#125; t[maxn &lt;&lt; 2];long long base[maxn];#define lt (p &lt;&lt; 1)#define rt (lt | 1)void pushup(int p) &#123;    t[p].u = (t[lt].u * base[t[rt].s] % mod + t[rt].u) % mod;    return;&#125;void bld(int p, int l, int r) &#123;    t[p].l = l, t[p].r = r;    if (l == r)        return;    int mid = (l + r) &gt;&gt; 1;    bld(lt, l, mid), bld(rt, mid + 1, r);    return;&#125;void add(int p, int x, int v) &#123;    t[p].s += (v &gt;= 0 ? 1 : -1);    if (t[p].l == t[p].r) &#123;        t[p].u += v;        return;    &#125;    int mid = (t[p].l + t[p].r) &gt;&gt; 1;    if (x &lt;= mid)        add(lt, x, v);    else        add(rt, x, v);    pushup(p);    return;&#125;int main() &#123;#ifdef ONLINE_JUDGE    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr), std::cout.tie(nullptr);#else    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);#endif    int n, m;    std::cin &gt;&gt; n &gt;&gt; m;    std::vector&lt;int&gt; a(n + 1), b(m + 1), pos(m + 1);    base[0] = 1;    long long s = 1;    for (int i = 1; i &lt;= m; ++i) &#123;        base[i] = base[i - 1] * p % mod;        if (i &lt; n)            (s += base[i]) %= mod;    &#125;    long long now = 0;    for (int i = 1; i &lt;= n; ++i) &#123;        std::cin &gt;&gt; a[i];        now = (now * p % mod + a[i]) % mod;    &#125;    for (int i = 1; i &lt;= m; ++i)        std::cin &gt;&gt; b[i], pos[b[i]] = i;    int res = 0;    bld(1, 1, m);    for (int x = 0; x &lt;= m - n; ++x) &#123;        for (static int l = 1; l &lt; 1 + x; add(1, pos[l], -l), ++l);            // printf(&quot;add %d: %d\n&quot;, pos[l], -l);        for (static int r = 1; r &lt;= n + x; add(1, pos[r], r), ++r);            // printf(&quot;add %d: %d\n&quot;, pos[r], r);        (res += (now == t[1].u));        // printf(&quot;x = %d, now = %lld, t[1].u = %lld\n&quot;, x, now, t[1].u);        (now += s) %= mod;    &#125;    std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;    return 0;&#125;</code></pre></details><hr /><h2 id="b.-k-substrings">B. k-substrings</h2><p><a href="http://222.180.160.110:61235/contest/5653/problem/2" class="uri">http://222.180.160.110:61235/contest/5653/problem/2</a></p><p>我们可以发现这 <span class="math inline">\(\left\lceil\dfrac n2\right\rceil\)</span> 个串都有共同中点，而<mark>不管其位于元素还是元素间的空隙，两边的 border 都应关于其对称</mark>。啥叫奇 border 呢，就是每个 border 都能取到元素上的中点，<mark>也就是说这俩中点是关于全串中点对称的</mark>。</p><p>我们枚举这 <span class="math inline">\(\left\lfloor\dfrac n2\right\rfloor\)</span> 对可能的 border 中点，分别二分 border 长度。假设最后该对中点最长合法 border 为 <span class="math inline">\([l_1,r_1]\)</span> 与 <span class="math inline">\([l_2,r_2]\)</span>，用 <span class="math inline">\(r_1-l_1+1-2\times k\)</span> 更新 <span class="math inline">\(l_1+k\)</span> 处的答案即可。</p><details><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;const int p = 131;const int mod = 1e9 + 7;int main() &#123;#ifdef ONLINE_JUDGE    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr), std::cout.tie(nullptr);#else    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);#endif    int n;    std::cin &gt;&gt; n;    std::vector&lt;char&gt; a(n + 1);    std::vector&lt;int&gt; res(n + 1, -1);    std::vector&lt;long long&gt; h(n + 1), base(n + 1);    base[0] = 1;    for (int i = 1; i &lt;= n; ++i) &#123;        std::cin &gt;&gt; a[i];        h[i] = (h[i - 1] * p + a[i]) % mod;        base[i] = base[i - 1] * p % mod;    &#125;    auto geth = [&amp;](int l, int r) &#123;        return (h[r] + mod - h[l - 1] * base[r - l + 1] % mod) % mod;    &#125;;    for (int l = n / 2, r = (n + 1) / 2 + 1; r &lt;= n; --l, ++r)        if (a[l] == a[r]) &#123;            int t = 0;            for (int ll = 1, rr = l, mid; ll &lt;= rr; ) &#123;                mid = (ll + rr) &gt;&gt; 1;                if (geth(l - mid + 1, l + mid - 1) == geth(r - mid + 1, r + mid - 1))                    t = mid, ll = mid + 1;                else                    rr = mid - 1;            &#125;            res[l - t + 1] = std::max(res[l - t + 1], 2 * t - 1);        &#125;    for (int i = 1; i &lt;= (n + 1) / 2; ++i) &#123;        res[i] = std::max(res[i - 1] - 2, res[i]);        std::cout &lt;&lt; res[i] &lt;&lt; &#39; &#39;;    &#125;    std::cout &lt;&lt; &#39;\n&#39;;    return 0;&#125;</code></pre></details><hr /><h2 id="c.-kefa-and-watch">C. Kefa and Watch</h2><p><a href="http://222.180.160.110:61235/contest/5653/problem/3" class="uri">http://222.180.160.110:61235/contest/5653/problem/3</a></p><p>一个挺常用的 trick 是，<mark><span class="math inline">\(S_{l\sim r}\)</span> 存在长度为 <span class="math inline">\(d\)</span> 的循环节 <span class="math inline">\(\iff S_{l\sim (r-d)}=S_{(l+d+)\sim r}\)</span></mark>。而题目要求为混循环节，刚好也可以用这个方法判定。线段树随便维护一下哈希就行。assign 操作就是将长度为 <span class="math inline">\(len\)</span> 的区间哈希值更改为 <span class="math inline">\(t\times \sum_{i=0}^{len-1}p^i\)</span>。</p><details><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;const int p = 131;const int mod = 1e9 + 7;const int maxn = 1e5 + 5;struct &#123;    int l, r, d;    long long u;&#125; t[maxn &lt;&lt; 2];int a[maxn];long long base[maxn], s[maxn];#define lt (p &lt;&lt; 1)#define rt (lt | 1)void pushup(int p) &#123;    t[p].u = (t[lt].u * base[t[rt].r - t[rt].l + 1] % mod + t[rt].u) % mod;    return;&#125;void pushdown(int p) &#123;    if (~t[p].d) &#123;        t[lt].d = t[rt].d = t[p].d;        t[lt].u = t[p].d * s[t[lt].r - t[lt].l] % mod;        t[rt].u = t[p].d * s[t[rt].r - t[rt].l] % mod;        t[p].d = -1;    &#125;    return;&#125;void bld(int p, int l, int r) &#123;    t[p].l = l, t[p].r = r, t[p].d = -1;    if (l == r) &#123;        t[p].u = a[l];        return;    &#125;    int mid = (l + r) &gt;&gt; 1;    bld(lt, l, mid), bld(rt, mid + 1, r);    pushup(p);    return;&#125;void ass(int p, int l, int r, int v) &#123;    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r) &#123;        t[p].d = v;        t[p].u = v * s[t[p].r - t[p].l] % mod;        return;    &#125;    pushdown(p);    int mid = (t[p].l + t[p].r) &gt;&gt; 1;    if (l &lt;= mid)        ass(lt, l, r, v);    if (r &gt; mid)        ass(rt, l, r, v);    pushup(p);    return;&#125;long long ask(int p, int l, int r) &#123;    // printf(&quot;p = %d, u = %lld, [%d, %d] of [%d, %d]\n&quot;, p, t[p].u, t[p].l, t[p].r, l, r);    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r)        return t[p].u;    pushdown(p);    int mid = (t[p].l + t[p].r) &gt;&gt; 1;    if (r &lt;= mid)        return ask(lt, l, r);    if (l &gt; mid)        return ask(rt, l, r);    return (ask(lt, l, r) * base[std::min(r, t[p].r) - mid] % mod + ask(rt, l, r)) % mod;&#125;int main() &#123;#ifdef ONLINE_JUDGE    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr), std::cout.tie(nullptr);#else    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);#endif    int n, m, k;    std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;    base[0] = s[0] = 1;    for (int i = 1; i &lt;= n; ++i) &#123;        char t;        std::cin &gt;&gt; t;        a[i] = t - &#39;0&#39;;        base[i] = base[i - 1] * p % mod;        s[i] = (s[i - 1] + base[i]) % mod;    &#125;    bld(1, 1, n);    for (int q = m + k; q--; ) &#123;        int op;        std::cin &gt;&gt; op;        if (op == 1) &#123;            int l, r, t;            std::cin &gt;&gt; l &gt;&gt; r &gt;&gt; t;            ass(1, l, r, t);        &#125;        else &#123;            int l, r, d;            std::cin &gt;&gt; l &gt;&gt; r &gt;&gt; d;            // if (d != r - l + 1)            //     printf(&quot;%lld / %lld\n&quot;, ask(1, l, r - d), ask(1, l + d, r));            std::cout &lt;&lt; ((d == r - l + 1 || ask(1, l, r - d) == ask(1, l + d, r)) ? &quot;YES&quot; : &quot;NO&quot;) &lt;&lt; &#39;\n&#39;;        &#125;    &#125;    return 0;&#125;</code></pre></details><hr /><h2 id="d.-misha-and-lcp-on-tree">D. Misha and LCP on Tree</h2><p><a href="http://222.180.160.110:61235/contest/5653/problem/4" class="uri">http://222.180.160.110:61235/contest/5653/problem/4</a></p><p>一个很显然的做法是，我们二分一个长度，然后在 <span class="math inline">\(a\to fa\)</span> 上正哈希，<span class="math inline">\(b\to fa\)</span> 上反哈希，<span class="math inline">\(O(1)\)</span> check。</p><p>笑话：本来想用倍增求 <span class="math inline">\(a\to fa\)</span> 和 <span class="math inline">\(b\to fa\)</span> 的哈希（当然双 <span class="math inline">\(\log\)</span> 肯定是会被卡飞的），后来发现<mark>哈希具有可减性，我们又只需求一条链上的哈希值，直接减掉就行</mark>。</p><p>还有一个点就是 <span class="math inline">\(O(1)\)</span> 求 <span class="math inline">\(k\)</span> 级祖先，有长剖预处理的做法。<a href="/20241021-1">具体做法</a>。</p><details><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;const int p = 131;const int mod = 1e9 + 7;int main() &#123;#ifdef ONLINE_JUDGE    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr), std::cout.tie(nullptr);#else    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);#endif    int n;    std::cin &gt;&gt; n;    std::vector&lt;int&gt; to(n + 1);    std::vector&lt;char&gt; a(n + 1);    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);    std::vector&lt;long long&gt; base(n + 1), inv(n + 1);    auto qkp = [](long long x, int y) &#123;        long long res = 1;        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)            if (y &amp; 1)                (res *= x) %= mod;        return res;    &#125;;    base[0] = inv[0] = 1;    for (int i = 1, mx = 0; i &lt;= n; ++i) &#123;        std::cin &gt;&gt; a[i];        base[i] = base[i - 1] * p % mod;        inv[i] = qkp(base[i], mod - 2);        if (i &gt;= (1 &lt;&lt; mx) * 2)            ++mx;        to[i] = mx;    &#125;    for (int i = 1, x, y; i &lt; n; ++i) &#123;        std::cin &gt;&gt; x &gt;&gt; y;        g[x].push_back(y), g[y].push_back(x);    &#125;    std::vector&lt;long long&gt; h1(n + 1), h2(n + 1);    std::vector&lt;std::array&lt;int, 21&gt; &gt; fa(n + 1);    std::vector&lt;int&gt; h(n + 1, 1), son(n + 1), dep(n + 1);    h[0] = 0;    std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;        h1[x] = (h1[fa[x][0]] * p % mod + a[x]) % mod;        h2[x] = (h2[fa[x][0]] + a[x] * base[dep[x] - 1]) % mod;        for (auto i : g[x])            if (i != fa[x][0]) &#123;                fa[i][0] = x;                for (int j = 1; j &lt;= 20; ++j)                    fa[i][j] = fa[fa[i][j - 1]][j - 1];                dep[i] = dep[x] + 1;                DFS(i);                if (h[i] &gt;= h[son[x]])                    son[x] = i, h[x] = h[i] + 1;            &#125;        return;    &#125;;    dep[1] = 1, DFS(1);    std::vector&lt;int&gt; top(n + 1), id(n + 1);    std::vector&lt;std::vector&lt;int&gt; &gt; anc(n + 1), des(n + 1, std::vector&lt;int&gt; (1));    std::function&lt;void(int, int)&gt; DFS1 = [&amp;](int x, int toq) &#123;        top[x] = toq;        if (son[x])            DFS1(son[x], toq);        for (auto i : g[x])            if (i != fa[x][0] &amp;&amp; i != son[x])                DFS1(i, i);        des[toq].push_back(x);        id[x] = (int)des[toq].size() - 1;        if (x == toq) &#123;            anc[x].push_back(x);            for (int j = 1, now = x; j &lt;= id[x]; ++j, now = fa[now][0])                anc[x].push_back(fa[now][0]);        &#125;        return;    &#125;;    DFS1(1, 1);    auto getLCA = [&amp;](int x, int y) &#123;        if (dep[x] &lt; dep[y])            std::swap(x, y);        for (int i = 20; ~i; --i)            if (dep[fa[x][i]] &gt;= dep[y])                x = fa[x][i];        if (x == y)            return x;        for (int i = 20; ~i; --i)            if (fa[x][i] != fa[y][i])                x = fa[x][i], y = fa[y][i];        return fa[x][0];    &#125;;    auto ask = [&amp;](int x, int k) &#123;        assert(dep[x] - 1 &gt;= k);        int x1 = x;        if (!k)            return x;        x = fa[x][to[k]];        if (dep[x] - dep[top[x]] &gt;= k - (1 &lt;&lt; to[k]))            return des[top[x]][id[x] + k - (1 &lt;&lt; to[k])];        return anc[top[x]][k - (1 &lt;&lt; to[k]) - (dep[x] - dep[top[x]])];    &#125;;    auto dis = [&amp;](int x, int y, int fa) &#123;        return dep[x] + dep[y] - 2 * dep[fa];    &#125;;    auto gethash = [&amp;](int x, int y, int f, int k) &#123;        if (!k)            return 0ll;        if (k &lt;= dep[x] - dep[f] + 1) &#123;            f = ask(x, k - 1);            return (h2[x] + mod - h2[fa[f][0]]) % mod * inv[dep[f] - 1] % mod;        &#125;        long long h = (h2[x] + mod - h2[fa[f][0]]) % mod * inv[dep[f] - 1] % mod;        k -= (dep[x] - dep[f] + 1);        y = ask(y, (dep[y] - dep[f]) - k);        h = (h * base[dep[y] - dep[f]] % mod + (h1[y] + mod - h1[f] * base[dep[y] - dep[f]] % mod) % mod) % mod;        return h;    &#125;;    int m;    std::cin &gt;&gt; m;    for (int x, y, a, b; m--; ) &#123;        std::cin &gt;&gt; x &gt;&gt; y &gt;&gt; a &gt;&gt; b;        int fa1 = getLCA(x, y), fa2 = getLCA(a, b), res = 0;        for (int l = 0, r = std::min(dis(x, y, fa1), dis(a, b, fa2)) + 1, mid; l &lt;= r; ) &#123;            mid = (l + r) &gt;&gt; 1;            if (gethash(x, y, fa1, mid) == gethash(a, b, fa2, mid))                res = mid, l = mid + 1;            else                r = mid - 1;        &#125;        std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;    &#125;    return 0;&#125;</code></pre></details><hr /><h2 id="a.-song-of-the-sirens">A. Song of the Sirens</h2><p><a href="http://222.180.160.110:61235/contest/5658/problem/1" class="uri">http://222.180.160.110:61235/contest/5658/problem/1</a></p><p>笑话：是 <span class="math inline">\(s_it_is_i\)</span> 而不是 <span class="math inline">\(s_its_i\)</span>。</p><p>我们发现 <span class="math inline">\(s_0\)</span> 很短，所以直接枚举起始位置把 <span class="math inline">\(s_0\)</span> 和匹配串大力匹配，把空位挖出来组成新的匹配串再考虑 <span class="math inline">\(t\)</span> 的问题（因为所有 <span class="math inline">\(s_i\)</span> 最开头都有一个完整的 <span class="math inline">\(s_0\)</span>，所以可以随便选断点）。</p><p>我们知道 <span class="math inline">\(t\)</span> 的下标是一个自底向上从 <span class="math inline">\(1\)</span> 到 <span class="math inline">\(n\)</span> 的满二叉树的中序遍历，其中 <mark><span class="math inline">\(t_1\)</span> 间隔一位出现；于是我们仿照对 <span class="math inline">\(s\)</span> 的处理方式，再把 <span class="math inline">\(t_1\)</span> 挖掉。注意到此时 <span class="math inline">\(t_2\)</span> 又成为二叉树最底层，间隔一位出现，这就变成了一个 <span class="math inline">\(\mathcal O(n\log n)\)</span> 递归的问题</mark>。</p><p>至于答案，当 <span class="math inline">\(t\)</span> 被删空时，假设删掉的最后一个元素为 <span class="math inline">\(t_p\)</span>，<span class="math inline">\(t\)</span> 的出现次数即为二叉树中 <span class="math inline">\(p\)</span> 层点数，为 <span class="math inline">\(2^{k-p}\)</span>。</p><p>有一个细节，就是如果当前删到 <span class="math inline">\(i\)</span> 了，<span class="math inline">\(t\)</span> 的长度只剩 <span class="math inline">\(1\)</span>，就会有一个很尴尬的问题——这个元素不一定就是 <span class="math inline">\(t_i\)</span>，而应该是 <span class="math inline">\(\{j \mid j\ge i\land t_j=t_i\}\)</span>。统计 <span class="math inline">\(t_{i\sim k}\)</span> 中值为 <span class="math inline">\(t_i\)</span> 的元素个数（前缀和），乘上对应的层数即可。这个可以用一点小技巧搞定，前缀和时忽略 <span class="math inline">\(k\)</span> 乘上 <span class="math inline">\(k=n\)</span> 时的系数，统计答案时乘上 <span class="math inline">\(2^{n-k}\)</span> 即可。</p><p>不是，那我缺的哈希这块谁来补啊？？？</p><details><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;const int mod = 1e9 + 7;int main() &#123;#ifdef ONLINE_JUDGE    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr), std::cout.tie(nullptr);#else    std::freopen(&quot;sirens1.in&quot;, &quot;r&quot;, stdin);    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);#endif    int n, q, m;    std::string s;    std::cin &gt;&gt; n &gt;&gt; q &gt;&gt; s;    s = &#39;\0&#39; + s, m = (int)s.length() - 1;    std::vector&lt;char&gt; t(n + 1);    std::vector&lt;long long&gt; base(n + 1), inv(n + 1);    std::vector&lt;std::array&lt;long long, 26&gt; &gt; a(n + 1);    auto qkp = [](long long x, int y) &#123;        long long res = 1ll;        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)            if (y &amp; 1)                (res *= x) %= mod;        return res;    &#125;;    base[0] = 1ll, inv[0] = 1ll, inv[1] = qkp(2, mod - 2);    for (int i = 1; i &lt;= n; ++i) &#123;        std::cin &gt;&gt; t[i];        base[i] = base[i - 1] * 2 % mod;        if (i != 1)            inv[i] = inv[i - 1] * inv[1] % mod;    &#125;    for (int i = 1; i &lt;= n; ++i)        a[i] = a[i - 1], (a[i][t[i] - &#39;a&#39;] += base[n - i]) %= mod;    for (int k; q--; ) &#123;        std::string p;        std::cin &gt;&gt; k &gt;&gt; p;        p = &#39;\0&#39; + p;        long long res = 0;        int l = (int)p.length() - 1;        std::vector&lt;char&gt; u;        std::function&lt;void(int, std::vector&lt;char&gt; &amp;)&gt; calc = [&amp;](int x, std::vector&lt;char&gt; &amp;p) &#123;            int m = (int)p.size() - 1;            if (m == 0) &#123;                // puts(&quot;# 45&quot;);                // printf(&quot;0, += %lld\n&quot;, base[k - x + 1]);                (res += base[k - x + 1]) %= mod;                return;            &#125;            if (x &gt; k)                return;            if (m == 1) &#123;                // puts(&quot;# 50&quot;);                // printf(&quot;1, += %lld(%lld)\n&quot;, (a[k][p[1] - &#39;a&#39;] + mod - a[x - 1][p[1] - &#39;a&#39;]) % mod * inv[n - k] % mod, inv[n - k] % mod);                (res += (a[k][p[1] - &#39;a&#39;] + mod - a[x - 1][p[1] - &#39;a&#39;]) % mod * inv[n - k] % mod) %= mod;                return;            &#125;            bool flag0 = 1, flag1 = 1;            std::vector&lt;char&gt; t0(1), t1(1);            for (int i = 1; i &lt;= m; ++i)                if (!(i &amp; 1)) &#123;                    if (flag0)                        t0.push_back(p[i]);                    flag1 &amp;= (p[i] == t[x]);                &#125;                else &#123;                    if (flag1)                        t1.push_back(p[i]);                    flag0 &amp;= (p[i] == t[x]);                &#125;            if (flag0)                calc(x + 1, t0);            if (flag1)                calc(x + 1, t1);            return;        &#125;;        for (int i = 1; i &lt;= m + 1; ++i) &#123;            std::vector&lt;char&gt;(1).swap(u);            for (int j = i, now = 1; now &lt;= l; ++now) &#123;                if (j == m + 1)                    j = 1, u.push_back(p[now]);                else if (p[now] != s[j])                    goto nosol;                else                    ++j;            &#125;            // printf(&quot;u: &quot;);            // for (int i = 1; i &lt; (int)u.size(); ++i)            //     std::cout &lt;&lt; u[i];            // puts(&quot;&quot;);            calc(1, u);        nosol: ;        &#125;        std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;    &#125;    return 0;&#125;</code></pre></details><hr /><h2 id="b.-prefix-of-suffixes">B. Prefix of Suffixes</h2><p><a href="http://222.180.160.110:61235/contest/5658/problem/2" class="uri">http://222.180.160.110:61235/contest/5658/problem/2</a></p><p>还是太科幻了。哦哦 border 我的 border。</p><h3 id="法一">法一</h3><p>考虑每次增量，若加入 <span class="math inline">\(S_i\)</span> 后有 <span class="math inline">\(z_j\)</span> 的值增加 <span class="math inline">\(1\)</span>，那么这对 <span class="math inline">\((i, j)\)</span> 就会贡献 <span class="math inline">\(A_j\cdot B_i\)</span> 的增量；<mark>反之，<span class="math inline">\(z_j\)</span> 在以后也不会增加</mark>。</p><p>我们维护当前没有确定下来的所有 <span class="math inline">\(z_j\)</span>，对于每个 <span class="math inline">\(i\)</span> 暴力 check <span class="math inline">\(z_j\)</span> 是否确定并更新答案，<strong>因为数据比较弱</strong>，在 CF 神机上跑得飞快 <img src="/em/dy.gif" /> 但是 QOJ 上死活过不了 <img src="/em/ll.gif" /></p><details><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;int main() &#123;#ifdef ONLINE_JUDGE    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr), std::cout.tie(nullptr);#else    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);#endif    int n;    long long res = 0, s = 0;    std::cin &gt;&gt; n;    std::vector&lt;int&gt; now;    std::vector&lt;int&gt; a(n + 1), b(n + 1), t(n + 1);    for (int i = 1; i &lt;= n; ++i) &#123;        std::cin &gt;&gt; t[i] &gt;&gt; a[i] &gt;&gt; b[i];        t[i] = (res + t[i]) % n;        if (t[i] == t[1])            s += b[i], now.push_back(i);        std::vector&lt;int&gt; g(std::move(now));        for (auto j : g)            if (t[i] == t[i - j + 1])                now.push_back(j);            else                s -= b[j];        res += a[i] * s;        std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;    &#125;    return 0;&#125;</code></pre></details><h3 id="法二">法二</h3><p>依然考虑增量。<mark><span class="math inline">\(z_j\)</span> 增加 <span class="math inline">\(\iff S_{j\to i}\)</span> 为 <span class="math inline">\(S_{1\sim i}\)</span> 的一个 border</mark>。考虑对于每一个 <span class="math inline">\(S_i\)</span>，border 的组成。</p><ol type="1"><li>若 <span class="math inline">\(S_1=S_i\)</span>，那么将会新增一个长度为 <span class="math inline">\(1\)</span> 的 border。</li><li>对于在 <span class="math inline">\(i-1\)</span> 处合法的 border <span class="math inline">\(S_{j\sim i-1}\)</span>，若 <span class="math inline">\(S_i=S_{i-j+1}\)</span>，则该 border 仍合法；否则非法。</li></ol><p>我们的法一其实相当于是暴力 check 了所有合法 border 是否仍然合法，但这显然最坏是 <span class="math inline">\(O(n^2)\)</span> 的。我们考虑从 border 角度优化一下。</p><p>我们发现，比如说 <span class="math inline">\(\texttt{abababa + b}\)</span>，我们会进行很多次不必要的 check，当然这个时候我们会本能大力跳 fail，但是这里有一个 <a href="https://www.luogu.com/article/e08ebmz6">border 的等差数列性质</a>，若 <span class="math inline">\(x+1\)</span> 与 <span class="math inline">\(i\)</span> 能够匹配，那么与 <span class="math inline">\(x\)</span> 同属一个等差数列的所有 <span class="math inline">\(x&#39;+1\)</span> 都应和 <span class="math inline">\(i\)</span> 匹配。</p><p>对于正在 check 的 <span class="math inline">\(x\)</span>，如果 check 成功则跳到上一条链的链尾；否则跳到链头。总的复杂度是 <span class="math inline">\(O(n\log n)\)</span> 的。找一下和每个 <span class="math inline">\(i\)</span> 匹配不了的第一个链头，甚至可以因为某些我太菜了所以不知道的不明原因整到线性。</p><details><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;int main() &#123;#ifdef ONLINE_JUDGE    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr), std::cout.tie(nullptr);#else    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);#endif    int n;    long long res = 0, s = 0;    std::cin &gt;&gt; n;    std::vector&lt;int&gt; a(n + 1), b(n + 1), t(n + 1), ne(n + 1), to(n + 1);    for (int i = 1; i &lt;= n; ++i) &#123;        std::cin &gt;&gt; t[i] &gt;&gt; a[i] &gt;&gt; b[i];        t[i] = (res + t[i]) % n;        if (i == 1)            s += b[i], res = (long long)a[i] * b[i];        else &#123;            int j = ne[i - 1];            for (; j &amp;&amp; t[j + 1] != t[i]; j = ne[j]);            if (t[j + 1] == t[i])                ++j;            ne[i] = j;            if (t[i] == t[1])                s += b[i];            to[i - 1] = (t[ne[i - 1] + 1] == t[i] ? to[ne[i - 1]] : ne[i - 1]);            for (int j = i - 1; j; )                if (t[j + 1] == t[i])                    j = to[j];                else                    for (int at = to[j]; j != at; s -= b[i - j], j = ne[j]);            res += a[i] * s;        &#125;        std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;    &#125;    return 0;&#125;</code></pre></details><hr /><h2 id="c.-matching">C. Matching</h2><p><a href="http://222.180.160.110:61235/contest/5658/problem/3" class="uri">http://222.180.160.110:61235/contest/5658/problem/3</a></p><p>我们发现，如果我们直接要 check 一段 <span class="math inline">\(a\)</span> 和 <span class="math inline">\(p\)</span>，感觉不太好整。</p><p>然后考虑这么一个问题，假如我们通过神秘方法让我们每次 check 的 <span class="math inline">\(a\)</span></p>]]></content>
      
      
      
        <tags>
            
            <tag> 线段树 </tag>
            
            <tag> 哈希 </tag>
            
            <tag> KMP </tag>
            
            <tag> border </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模拟赛</title>
      <link href="/20241017/"/>
      <url>/20241017/</url>
      
        <content type="html"><![CDATA[<p>好消息：会简单数学题 <img src="/em/dy.gif" /></p><p>更好的消息：忘取模了 <img src="/em/dy.gif" /></p><span id="more"></span><hr /><h3 id="a.-distorted">A. distorted</h3><p><a href="http://222.180.160.110:61235/contest/5611/problem/1" class="uri">http://222.180.160.110:61235/contest/5611/problem/1</a></p><p>考虑最多需要多少个元素。最坏情况是选取四个角的元素，已经可以覆盖整个矩阵。进一步考虑感性反证发现无论如何都选不出来五个，故最多选择四个。</p><p>我们发现，选取中间一个就可以覆盖整个矩阵。扩展一下，选择中间列就可以覆盖上 / 下半个矩阵，选择中间行就可以覆盖左 / 右半个矩阵。剩下的选择过后只能保证照顾到对应的 1/4 矩阵且一定不会完全覆盖其他的 1/4 矩阵。</p><p>我们发现，中心元素地位高于中间行 / 列元素高于左上、左下、右上、右下元素。由此出发讨论选择元素的个数。</p><ul><li>1 个：选择中心元素。</li><li>2 个：在中间行的左右两边各选一个 / 在中间列的上下两边各选一个。</li><li>3 个：选一个中间行 / 列 + 两个其他元素，或两个中间行 / 列 + 一个其他元素。</li><li>4 个：左上、左下、右上、右下各选一个。</li></ul><p>统计各个方向的最小值，选最小组合即可。</p><details><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;#define putcharconst long long inf = 0x3f3f3f3f;int main() &#123;    freopen(&quot;distorted.in&quot;, &quot;r&quot;, stdin);    freopen(&quot;distorted.out&quot;, &quot;w&quot;, stdout);    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr), std::cout.tie(nullptr);    int T;    for (std::cin &gt;&gt; T; T--; ) &#123;        int n;        std::cin &gt;&gt; n;        long long to = inf, u = inf, d = inf, l = inf, r = inf, q = inf, z = inf, p = inf, m = inf;        for (int i = 1; i &lt;= n; ++i)            for (int j = 1; j &lt;= n; ++j) &#123;                long long x;                std::cin &gt;&gt; x;                if (i * 2 - 1 == n &amp;&amp; j * 2 - 1 == n)                    to = x;                else if (i * 2 - 1 == n &amp;&amp; j * 2 - 1 &lt; n)                    l = std::min(l, x);                else if (i * 2 - 1 == n)                    r = std::min(r, x);                else if (i * 2 - 1 &lt; n &amp;&amp; j * 2 - 1 == n)                    u = std::min(u, x);                else if (j * 2 - 1 == n)                    d = std::min(d, x);                else if (i * 2 - 1 &lt; n &amp;&amp; j * 2 - 1 &lt; n)                    q = std::min(q, x);                else if (i * 2 - 1 &lt; n)                    p = std::min(p, x);                else if (j * 2 - 1 &lt; n)                    z = std::min(z, x);                else                    m = std::min(m, x);            &#125;        std::cout &lt;&lt; std::min(&#123; to, l + r, u + d, l + u + m, l + d + p, r + u + z, r + d + q, u + z + m, d + q + p, l + p + m, r + q + z, q + p + z + m &#125;) &lt;&lt; &#39;\n&#39;;    &#125;    return 0;&#125;</code></pre></details><hr /><h3 id="b.-fate">B. fate</h3><p><a href="http://222.180.160.110:61235/contest/5611/problem/2" class="uri">http://222.180.160.110:61235/contest/5611/problem/2</a></p><p>诈骗题。对于前半段，考虑取差分数组 <span class="math inline">\(d\)</span>，容易发现如果直接在差分数组上做减法，一定满足后面减得不比前面少。故只要满足差分数组每一项至少为 <span class="math inline">\(0\)</span> 即可，答案为 <span class="math inline">\(\prod {i\le p} a_i - a_{i-1} + 1\)</span>。</p><p>对于后半段，我们考虑转化成和前半段相似的问题，将后半段翻转，同样取差分数组，则此时在该差分数组上满足后面减得不比前面少，同时需要满足差分数组每一项至多为 <span class="math inline">\(0\)</span>，前面的所有项初始为负，操作为减，自然满足；但第 <span class="math inline">\(p\)</span> 项在把前面减去的全部加上后不一定满足。故前面最多减去 <span class="math inline">\(d_p\)</span>，随便在哪里减都无所谓，组合意义一下，就是无标号球放有标号盒子可空放可不放，插板得答案为 <span class="math inline">\(\displaystyle {-d_p + n - p\choose n - p}\)</span>。</p><p>前后乘起来即为答案。注意不要在最后一步乘起来的时候忘记取模，否则你会获得 76pts 的高分 <img src="/em/xk.gif" /></p><details><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;const int mod = 998244353;int main() &#123;    freopen(&quot;fate.in&quot;, &quot;r&quot;, stdin);    freopen(&quot;fate.out&quot;, &quot;w&quot;, stdout);    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr), std::cout.tie(nullptr);    int n, m;    std::cin &gt;&gt; n;    std::vector&lt;long long&gt; a(n + 1);    for (int i = 1; i &lt;= n; ++i)        std::cin &gt;&gt; a[i];    std::cin &gt;&gt; m;    long long res = 1;    for (int i = 1; i &lt; m; ++i) &#123;        auto x = a[i] - a[i - 1];        (res *= x + 1) %= mod;    &#125;    auto qkp = [](long long x, int y) &#123;        long long res = 1;        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)            if (y &amp; 1)                (res *= x) %= mod;        return res;    &#125;;    auto C = [&amp;](int n, int m) &#123;        long long res = 1ll;        for (int i = n; i &gt; n - m; --i)            (res *= i) %= mod;        for (int i = m; i; --i)            (res *= qkp(i, mod - 2)) %= mod;            return res;    &#125;;    if (m != n)        (res *= C(a[m + 1] - a[m] + n - m, n - m)) %= mod;    std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;    return 0;&#125;</code></pre></details><hr /><h3 id="c.-abstruse">C. abstruse</h3><p><a href="https://www.luogu.com.cn/problem/P9731" class="uri">https://www.luogu.com.cn/problem/P9731</a></p><p>注意到有挺高的一档 <span class="math inline">\(S=2\)</span> 的分，考虑其启示意义。</p><p>我们对于一对 <span class="math inline">\((a_i, b_i)\)</span>，在 <span class="math inline">\(a_i\)</span> 和 <span class="math inline">\(b_i\)</span> 间连边，则原问题转化为给无向图的每条边选择方向，使对于每个 <span class="math inline">\(x\)</span>，<span class="math inline">\(|in_x-out_x|\le 1\)</span>。</p><p>我们知道对于一条欧拉回路，有对于任意 <span class="math inline">\(x\)</span>，<span class="math inline">\(in_x=out_x\)</span>。然后这个时候为了把问题转化成欧拉回路问题我们建一个虚点朝度数为奇的点连条边然后跑欧拉回路即可。</p><p>至于 <span class="math inline">\(S=2^k\)</span>，就是在明示分治。即对于任意 <span class="math inline">\(x\)</span>，要求其在前后 <span class="math inline">\(2^{k-1}\)</span> 次出现次数相差不超过 <span class="math inline">\(1\)</span>。注意到非常幸福的有前后两个部分大小相等，又有一个天才的建图，<mark>即在每个点和自己所属的行连边，然后跑欧拉回路，出边表示选前半部分，入边表示选后半部分，这样就保证了一行中各有 <span class="math inline">\(2^{k-1}\)</span> 个选前后半部分，也保证了每个点在前后半边出现的次数相差不超过 <span class="math inline">\(1\)</span>。对于后面一个性质，分治最终可得到点在每一列出现次数相差不超过 <span class="math inline">\(1\)</span></mark>。</p><p>打个当前弧优化然后注意计算细节复杂度然后多卡几（十）遍就过了 <img src="/em/dy.gif" /></p><details><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;namespace fastIO &#123;const int LEN = (1 &lt;&lt; 20);#ifdef ONLINE_JUDGEint nec(void) &#123;    static char buf[LEN], *p = buf, *e = buf;    if (p == e) &#123;        e = buf + fread(buf, 1, LEN, stdin);        if (e == buf) return EOF;        p = buf;    &#125;    return *p++;&#125;#else#define nec getchar#endifbool read(int &amp;x) &#123;    x = 0;    bool f = 0;    char ch = nec();    while (ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123;        if (ch == EOF) return 0;        if (ch == &#39;-&#39;) f = 1;        ch = nec();    &#125;    while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) &#123;        x = x * 10 + ch - &#39;0&#39;;        ch = nec();    &#125;    if (f) x = -x;    return 1;&#125;void print(int x) &#123;    if (x &lt; 0)        putchar(&#39;-&#39;), x = -x;    if (x &gt;= 10) print(x / 10);    putchar(x % 10 + &#39;0&#39;);    return;&#125;void print(int x, char ch) &#123;    print(x), putchar(ch);    return;&#125;&#125; using namespace fastIO;int main() &#123;#ifdef ONLINE_JUDGE    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr);    std::cout.tie(nullptr);    freopen(&quot;abstruse.in&quot;, &quot;r&quot;, stdin);    freopen(&quot;abstruse.out&quot;, &quot;w&quot;, stdout);#else    freopen(&quot;.in&quot;, &quot;r&quot;, stdin);    freopen(&quot;.out&quot;, &quot;w&quot;, stdout);#endif    int n, m, k;    read(n), read(m), read(k);    std::vector&lt;std::vector&lt;int&gt; &gt; a(n + 1, std::vector&lt;int&gt; (m + 1));    for (int i = 1; i &lt;= n; ++i)        for (int j = 1; j &lt;= m; ++j)            read(a[i][j]);    std::vector&lt;int&gt; to(k + n + 1), tag(n * m + n + k + 1);    std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; g(k + n + 1);     std::function&lt;void(int, int)&gt; calc = [&amp;](int l, int r) &#123;        if (l + 1 == r) &#123;            for (int i = 1; i &lt;= n; ++i) &#123;                g[a[i][l]].emplace_back(a[i][r], i);                g[a[i][r]].emplace_back(a[i][l], i);            &#125;            int cnt = n;            for (int i = 1; i &lt;= n; ++i) &#123;                if ((int)g[a[i][l]].size() &amp; 1)                    g[0].emplace_back(a[i][l], ++cnt), g[a[i][l]].emplace_back(0, cnt);                if ((int)g[a[i][r]].size() &amp; 1)                    g[0].emplace_back(a[i][r], ++cnt), g[a[i][r]].emplace_back(0, cnt);            &#125;            std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;                for (int i = to[x]; i &lt; (int)g[x].size(); i = to[x]) &#123;                    to[x] = i + 1;                    auto [v, id] = g[x][i];                    if (!tag[id]) &#123;                        tag[id] = 1;                        if (x &amp;&amp; v)                            a[id][l] = x, a[id][r] = v;                        DFS(v);                    &#125;                &#125;                return;            &#125;;            DFS(0);            for (int i = 1; i &lt;= n; ++i)                DFS(a[i][l]), DFS(a[i][r]);            to[0] = 0, g[0].clear();            for (int i = 1; i &lt;= n; ++i) &#123;                to[a[i][l]] = 0, g[a[i][l]].clear();                to[a[i][r]] = 0, g[a[i][r]].clear();            &#125;            std::fill(tag.begin() + 1, tag.begin() + cnt + 1, 0);            return;        &#125;        int mid = (l + r) &gt;&gt; 1, cnt = 0;        std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; g(k + n + 1);        for (int i = 1; i &lt;= n; ++i)            for (int j = l; j &lt;= r; ++j) &#123;                g[a[i][j]].emplace_back(i + k, ++cnt);                g[i + k].emplace_back(a[i][j], cnt);            &#125;        for (int i = 1; i &lt;= n; ++i)            for (int j = l; j &lt;= r; ++j)                if ((int)g[a[i][j]].size() &amp; 1)                    g[0].emplace_back(a[i][j], ++cnt), g[a[i][j]].emplace_back(0, cnt);        std::vector&lt;int&gt; L(n + 1, l - 1), R(n + 1, r + 1);        std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;            for (int i = to[x]; i &lt; (int)g[x].size(); i = to[x]) &#123;                to[x] = i + 1;                auto [v, id] = g[x][i];                if (!tag[id]) &#123;                    tag[id] = 1;                    if (x &amp;&amp; v) &#123;                        if (v &lt;= k)                            a[x - k][++L[x - k]] = v;                        else                            a[v - k][--R[v - k]] = x;                    &#125;                    DFS(v);                &#125;            &#125;            return;        &#125;;        DFS(0);        for (int i = 1; i &lt;= n; ++i)            DFS(i + k);        for (int i = 1; i &lt;= n; ++i)            for (int j = l; j &lt;= r; ++j)                DFS(a[i][j]);        to[0] = 0, g[0].clear();        for (int i = 1; i &lt;= n; ++i)            to[i + k] = 0, g[i + k].clear();        for (int i = 1; i &lt;= n; ++i)            for (int j = l; j &lt;= r; ++j)                to[a[i][j]] = 0, g[a[i][j]].clear();        std::fill(tag.begin() + 1, tag.begin() + cnt + 1, 0);        calc(l, mid), calc(mid + 1, r);        return;    &#125;;    calc(1, m);    for (int i = 1; i &lt;= n; ++i, putchar(&#39;\n&#39;))        for (int j = 1; j &lt;= m; ++j)            print(a[i][j], &#39; &#39;);    return 0;&#125;</code></pre></details>]]></content>
      
      
      
        <tags>
            
            <tag> 分治 </tag>
            
            <tag> 欧拉回路 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划 10 题 - I</title>
      <link href="/20240906/"/>
      <url>/20240906/</url>
      
        <content type="html"><![CDATA[<p>现在是 10 题。虽然看着很掉价，但是写够了 10 就改成 20 题。以此类推，免得我摆烂（）</p><p>自用向，不写太详细，把破题点写出来就差不多了。哦哦这里的破题是动词不是名词。</p><span id="more"></span><hr /><h2 id="字符合并">1. 字符合并</h2><p><a href="https://www.luogu.com.cn/problem/P3736" class="uri">https://www.luogu.com.cn/problem/P3736</a></p><blockquote><p>给定长度为 <span class="math inline">\(n\)</span> 的 <span class="math inline">\(01\)</span> 串和 <span class="math inline">\(2^k\)</span> 条规则，第 <span class="math inline">\(i\)</span> 条规则形如：</p><ul><li>对于序列中的 <span class="math inline">\(k\)</span> 位二进制数 <span class="math inline">\(i\)</span>，可以将它合并为 <span class="math inline">\(c(c\in\{0,1\})\)</span>，并产生 <span class="math inline">\(v\)</span> 的价值。</li></ul><p>进行任意次合并，求出能取得的最大总价值。<span class="math inline">\(n\le 300,k\le 8\)</span>。</p></blockquote><p><strong>状压</strong>，<strong>区间 DP</strong>。</p><p>注意到 <span class="math inline">\(k\)</span> 只有 <span class="math inline">\(8\)</span>，独特的输入方式也引导我们注意到状态数为 <span class="math inline">\(10^2\)</span> 级别。合并的背景又让我们本能想到区间 DP，所以刚好盲猜这题是个 <span class="math inline">\(O(2^k\times n^2)\)</span> 的区间状压 DP。</p><ul><li><p>然后我觉得最神的一个地方是什么呢？最后的答案一定是一个长度小于 <span class="math inline">\(k\)</span> 的串，<mark>每位展开还原，可以知道，每个合并操作选取的区间可能包含但不相交。</mark></p><p>看起来很蠢很显然，但这是我们 <span class="math inline">\(n^2\)</span> 区间 DP 的基础啊（（（</p></li></ul><p>然后我们区间 DP 套路，枚举对于 <span class="math inline">\([l,r]\)</span> 最左边一位，然后就可以开始大力转移了。</p><p>但是这里我们会发现，这一位原本的样子有点多，可以是任何一个长度为 <span class="math inline">\(1 + d\times (k-1)\)</span> 的数，所以只能再来一层 <span class="math inline">\(\dfrac nk\)</span> 的枚举，极限情况是个有点难绷的 3e9，作为正解只能说这个数据范围的提示性有点令人难评了。</p><p>实现着实现着把自己整懵了：<code>00000</code> 和 <code>0</code> 压出来都是 <code>0</code>，但二者代表的含义显然不同，又无法简单区别。但其实<mark>长度为 <span class="math inline">\(1+d\times (k-1)\)</span> 的区间和长度为 <span class="math inline">\(d\)</span> 的最终结果是一一对应的，所以在我们设计的包含了区间作右端点的状态中，压出来的就是我们想要的那个。</mark></p><details><p>这里的实现比<strong>所有</strong>我找到的题解都更像人打出来的。导致我想对比疗法都找不到合适的代码 <img src="/em/lh.gif" /></p><p>换言之，这最像是一份通常的区间 DP 代码，不存在其他题解中乱七八糟的填表啊相互影响啊之类的恶心 feature。</p><p>sto rybp orz</p><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;const int maxn = 305;const int maxm = (1 &lt;&lt; 8) + 5;char a[maxn];int c[maxm], w[maxm];long long f[maxn][maxn][maxm];int main() &#123;#ifdef ONLINE_JUDGE    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr);    std::cout.tie(nullptr);#else    freopen(&quot;in.in&quot;, &quot;r&quot;, stdin);    freopen(&quot;out.out&quot;, &quot;w&quot;, stdout);#endif    int n, k;    std::cin &gt;&gt; n &gt;&gt; k;    int siz = (1 &lt;&lt; k), si = (1 &lt;&lt; (k - 1));    for (int i = 1; i &lt;= n; ++i)        std::cin &gt;&gt; a[i];    for (int i = 0; i &lt; siz; ++i)        std::cin &gt;&gt; c[i] &gt;&gt; w[i];    memset(f, -0x3f, sizeof(f));    for (int l = 1; l &lt; k; ++l)        for (int i = 1; i &lt;= n - l + 1; ++i) &#123;            int j = i + l - 1, now = 0;            for (int p = i; p &lt;= j; ++p)                now = now * 2 + a[p] - &#39;0&#39;;            f[i][j][now] = 0;        &#125;    for (int i = 1; i &lt;= n - k + 1; ++i) &#123;        int now = 0;        for (int j = i; j &lt;= i + k - 1; ++j)            now = now * 2 + a[j] - &#39;0&#39;;        f[i][i + k - 1][c[now]] = w[now];    &#125;    for (int l = k + 1; l &lt;= n; ++l)        for (int i = 1; i &lt;= n - l + 1; ++i) &#123;            int j = i + l - 1;            for (int p = i; p &lt; j; p += k - 1) &#123;                for (int q = 0; q &lt; si; ++q)                    if (!(q &gt;&gt; ((l - 1) % (k - 1) + 1)))                        f[i][j][q] = std::max(f[i][j][q], f[i][p][q &gt;&gt; ((l - 1) % (k - 1))] + f[p + 1][j][q &amp; ((1 &lt;&lt; ((l - 1) % (k - 1))) - 1)]);                if (l % (k - 1) == 1 || k == 2)                    for (int q = 0; q &lt; siz; ++q)                        f[i][j][c[q]] = std::max(f[i][j][c[q]], f[i][p][q &gt;&gt; (k - 1)] + f[p + 1][j][q &amp; ((1 &lt;&lt; (k - 1)) - 1)] + w[q]);            &#125;        &#125;    std::cout &lt;&lt; *std::max_element(f[1][n], f[1][n] + si) &lt;&lt; &#39;\n&#39;;    return 0;&#125;</code></pre></details><hr /><p>其实一开始挺担心会不会因为写博客影响做题时间之类的。</p><p>直到发现我可以看知乎看一个上午然后代码动都不动一下 <img src="/em/lh.gif" /></p><hr /><h2 id="mod-mod-mod">2. Mod Mod Mod</h2><p><a href="https://codeforces.com/contest/889/problem/E" class="uri">https://codeforces.com/contest/889/problem/E</a></p><blockquote><p>给定 <span class="math inline">\(a_{1\sim n}\)</span>，对于所有非负整数 <span class="math inline">\(x\)</span> 定义 <span class="math inline">\(f(x,n)=x\bmod a_n\)</span>，<span class="math inline">\(f(x,i)=x\bmod a_i+f(x\bmod a_i,i+1)\)</span>。</p><p>求 <span class="math inline">\(f(x,1)\)</span> 最大值。<span class="math inline">\(n\le 2\times 10^5\)</span>。</p></blockquote><p><strong>技巧 / 特殊性质类 DP</strong>。</p><p>小神题。注意到题意可以转化为，找到一个 <span class="math inline">\(x\)</span>，最大化：</p><p><span class="math display">\[x\bmod a_1 + x\bmod a_1\bmod a_2 + \cdots + x\bmod a_1\bmod a_2\bmod\cdots\bmod a_n.\]</span></p><p>简称 <span class="math inline">\(x\bmod a_1\bmod a_2\bmod \cdots\bmod a_i\)</span> 的值为 <span class="math inline">\(f_i\)</span>。</p><p>这个时候我们不难注意到，<span class="math inline">\(f_i\)</span> 肯定是<mark>单调不升</mark>的。形象化地，整个 <span class="math inline">\(f\)</span> 序列肯定是由若干个单调下降的段组成的。并且，<mark>必定存在至少一个 <span class="math inline">\(i\)</span>，使得 <span class="math inline">\(f_i = a_i-1\)</span>，否则可以将所有 <span class="math inline">\(f_i\gets f_i+1\)</span>，同时 <span class="math inline">\(\sum f\gets (\sum f) + n\)</span></mark>。</p><p>这启示我们关注 <span class="math inline">\(f_i\)</span> 的值域。假设已经确定了 <span class="math inline">\(f\)</span> 序列的一个前缀 <span class="math inline">\(f_1\sim i\)</span>，对于任意 <span class="math inline">\(0\le k\le f_{\min}\)</span>（注意由于单调不降，<span class="math inline">\(f_{\min} = f_i\)</span>），我们可以将所有 <span class="math inline">\(f_j\gets f_j-k\)</span>，得到一个新的合法的 <span class="math inline">\(f&#39;_{1\sim i}\)</span>。</p><p>形象化地，将 <span class="math inline">\(f_{1\sim i}\)</span> 想象为一个逐渐降低的柱状图，任意切去了一个高度的底部，并且这个高度不高于最矮的元素（即第 <span class="math inline">\(i\)</span> 个元素）。</p><p>这时候有一个很美妙的性质，就是我们<mark>对于切之前和切之后的柱状图，其 <strong>最矮元素以上的部分</strong> 长得完全相同</mark>。然后就是神中神之 DP 状态设计。很难想象是在什么样的精神状态下凑出来这种神奇状态的，可能是某种我不了解的 trick？</p><p>令 <span class="math inline">\(dp_{i, j}\)</span> 表示对于前缀 <span class="math inline">\(f_{1, i}\)</span>，当切去的高度为 <span class="math inline">\(0\sim j\)</span> 时，<strong>最矮元素以上的部分</strong> 的和都为 <span class="math inline">\(dp_{i, j}\)</span>。那么易得 <span class="math inline">\(\sum f_{1\sim i}=j\times i + dp_{i, j}\)</span>。</p><p>考虑转移。假设已知所有 <span class="math inline">\(dp_{i - 1, j}\)</span>，需转移到 <span class="math inline">\(i\)</span>，我们有三种转移路径：</p><ol type="1"><li><p><span class="math inline">\(j &lt; a_i\)</span>：</p>对 <span class="math inline">\(a_i\)</span> 取模取不动，不会产生任何影响。<span class="math inline">\(dp_{i, j}\gets dp_{i - 1, j}\)</span>。</li><li><p><span class="math inline">\(j\ge a_i\)</span>：</p><ul><li><p>让 <span class="math inline">\(i\)</span> 承担 <span class="math inline">\(f_i=a_i-1\)</span> 的责任。我们从 <span class="math inline">\(0\sim j\)</span> 中找到一个满足 <span class="math inline">\(j&#39;\bmod a_i=a_i-1\)</span> 的 <span class="math inline">\(j&#39;\)</span>，<span class="math inline">\(j&#39;\)</span> 肯定是越大越好，故 <span class="math inline">\(j&#39;=(\left\lfloor \dfrac {j}{a_i}\right\rfloor-1)\times a_i+(a_i-1)\)</span>。</p>此时便有 <span class="math inline">\(dp_{i, a_i-1}\gets dp_{i - 1, j&#39;} + [j&#39; - (a_i-1)]\times (i-1)\)</span>。</li><li><p>盲猜 <span class="math inline">\(0\sim i - 1\)</span> 或 <span class="math inline">\(i+1\sim n\)</span> 中会出现承担 <span class="math inline">\(f_{i&#39;}=a_{i&#39;-1}\)</span> 的 <span class="math inline">\(i&#39;\)</span>，故按照 <span class="math inline">\(j\)</span> 取最大来转移。</p><p>此时有 <span class="math inline">\(dp_{i, j\bmod a_i}=dp_{i-1,j}+(j-j\bmod a_i)\times (i-1)\)</span>。</p></li></ul></li></ol><p>答案即为 <span class="math inline">\(\max\{j\times n+dp_{n, j}\}\)</span>。由于不存在 <span class="math inline">\(f_i=a_i-1\)</span> 的 <span class="math inline">\(f\)</span> 肯定比存在的要劣，所以我们肯定选到的是正确的答案。</p><p>注意到每个 <span class="math inline">\(i\)</span> 只会新增 <span class="math inline">\(a_i-1\)</span> 一个状态，故状态总数为 <span class="math inline">\(O(n)\)</span>。把 <span class="math inline">\(dp\)</span> 开成 map 就可以 <span class="math inline">\(O(n\log n)\)</span> 地解决问题。</p><details><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;int main() &#123;#ifdef ONLINE_JUDGE    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr);    std::cout.tie(nullptr);#else    freopen(&quot;.in&quot;, &quot;r&quot;, stdin);    freopen(&quot;.out&quot;, &quot;w&quot;, stdout);#endif    int n;    std::cin &gt;&gt; n;    std::vector&lt;long long&gt; a(n + 1);    std::map&lt;long long, long long&gt; t;    std::cin &gt;&gt; a[1];    t[a[1] - 1] = 0;    for (int i = 2; i &lt;= n; ++i) &#123;        std::cin &gt;&gt; a[i];        for (;;) &#123;            auto p = t.lower_bound(a[i]);            if (p == t.end())                break;            long long j = p-&gt;first, f = p-&gt;second;            t[j % a[i]] = std::max(t[j % a[i]], f + (j - j % a[i]) * (i - 1));            if (j &gt;= a[i]) &#123;                j = (j / a[i] - 1) * a[i] + a[i] - 1;                t[a[i] - 1] = std::max(t[a[i] - 1], f + (j - (a[i] - 1)) * (i - 1));            &#125;            t.erase(p);        &#125;    &#125;    long long res = 0;    for (auto i : t)        res = std::max(res, i.first * n + i.second);    std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;    return 0;&#125;</code></pre></details><hr /><h2 id="stalinsort-algorithm">3. StalinSort Algorithm</h2><p><a href="https://qoj.ac/problem/1456" class="uri">https://qoj.ac/problem/1456</a></p><blockquote><p>给定排列 <span class="math inline">\(A_{1\sim n}\)</span>。从 <span class="math inline">\(i=2\)</span> 开始往右扫，每一步执行以下操作：</p><ul><li>若 <span class="math inline">\(A_i&gt; A_{i-1}\)</span>，什么也不做。</li><li>否则，你可以删除 <span class="math inline">\(A_{i-1}\)</span> 或 <span class="math inline">\(A_i\)</span>，但要求删除后，该前缀必须单调递增。</li></ul><p>问最少可以删除多少个数。<span class="math inline">\(n\le 10^5\)</span>。</p></blockquote><p>你会发现<mark>删最少 = 留最多</mark>。</p><p>考虑 <span class="math inline">\(i\)</span> 能够转移到的 <span class="math inline">\(j(j&gt;i)\)</span> 需满足的条件。若令 <span class="math inline">\(nex_p\)</span> 表示 <span class="math inline">\(p\)</span> 之后第一个值比 <span class="math inline">\(a_p\)</span> 大的元素，则 <span class="math inline">\(j\in [nex_i, nex_{nex_i})\)</span> 且 <span class="math inline">\(a_j&gt;a_i\)</span>。</p><p><mark>赛时误认为右端点为 <span class="math inline">\(i\)</span> 之后第二个值比 <span class="math inline">\(a_i\)</span> 大的元素，导致完全寄掉。</mark></p><p>时间复杂度 <span class="math inline">\(O(n^2)\)</span>，考虑优化。<mark>注意到如果只有 <span class="math inline">\(j\in [nex_i, nex_{nex_i})\)</span> 这个条件很容易用线段树维护，考虑消去 <span class="math inline">\(a_j&gt;a_i\)</span> 的影响。故考虑按 <span class="math inline">\(a\)</span> <strong>从小到大</strong> 的顺序选取 <span class="math inline">\(i\)</span>，因为当前最小的 <span class="math inline">\(i\)</span> 一定已经被刷完表了</mark>。</p><p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p><details><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;const int maxn = 5e5 + 5;const int inf = 0x3f3f3f3f;struct _ &#123; int u, d; &#125; t1[maxn &lt;&lt; 2];int n, t[maxn &lt;&lt; 2];#define lt (p &lt;&lt; 1)#define rt (lt | 1)void upd(int p, int l, int r, int x, int v) &#123;    t[p] = std::min(t[p], v);    if (l == r)        return;    int mid = (l + r) &gt;&gt; 1;    if (x &lt;= mid)        upd(lt, l, mid, x, v);    else        upd(rt, mid + 1, r, x, v);    return;&#125;int ask(int p, int l, int r, int ql, int qr) &#123;    if (ql &lt;= l &amp;&amp; r &lt;= qr)        return t[p];    int mid = (l + r) &gt;&gt; 1, res = n + 1;    if (ql &lt;= mid)        res = ask(lt, l, mid, ql, qr);    if (qr &gt; mid)        res = std::min(res, ask(rt, mid + 1, r, ql, qr));    return res;&#125;void pushdown(int p) &#123;    if (t1[p].d) &#123;        t1[lt].u = std::max(t1[lt].u, t1[p].d);        t1[lt].d = std::max(t1[lt].d, t1[p].d);               t1[rt].u = std::max(t1[rt].u, t1[p].d);        t1[rt].d = std::max(t1[rt].d, t1[p].d);               t1[p].d = 0;    &#125;    return;&#125;void upd(int p, int l, int r, int ql, int qr, int v) &#123;    t1[p].u = std::max(t1[p].u, v);    if (ql &lt;= l &amp;&amp; r &lt;= qr) &#123;        t1[p].d = std::max(t1[p].d, v);        return;    &#125;    pushdown(p);    int mid = (l + r) &gt;&gt; 1;    if (ql &lt;= mid)        upd(lt, l, mid, ql, qr, v);    if (qr &gt; mid)        upd(rt, mid + 1, r, ql, qr, v);    return;&#125;int ask(int p, int l, int r, int x) &#123;    if (l == r)        return t1[p].u;    pushdown(p);    int mid = (l + r) &gt;&gt; 1;    if (x &lt;= mid)        return ask(lt, l, mid, x);    return ask(rt, mid + 1, r, x);&#125;int main() &#123;#ifdef ONLINE_JUDGE    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr);    std::cout.tie(nullptr);#else    freopen(&quot;sort3.in&quot;, &quot;r&quot;, stdin);    // freopen(&quot;.out&quot;, &quot;w&quot;, stdout);#endif    int res = 0;    std::cin &gt;&gt; n;    std::vector&lt;int&gt; a(n + 1), ne(n + 1), f(n + 1);    std::fill(t + 1, t + 4 * n + 1, n + 1);    std::fill(t1 + 1, t1 + 4 * n + 1, (_)&#123; -inf, 0 &#125;);    for (int i = 1; i &lt;= n; ++i)        std::cin &gt;&gt; a[i];    for (int i = n; ~i; --i) &#123;        ne[i] = ask(1, 0, n, a[i] + 1, n);        upd(1, 0, n, a[i], i);       &#125;    std::vector&lt;int&gt; id(n + 1);    std::iota(id.begin(), id.end(), 0);    std::sort(id.begin(), id.end(), [&amp;](int x, int y) &#123; return a[x] &lt; a[y]; &#125;);    f[0] = 0;    for (int i = 0; i &lt;= n; ++i) &#123;        if (i) &#123;            f[id[i]] = ask(1, 0, n, id[i]);            res = std::max(res, f[id[i]]);        &#125;        if (ne[id[i]] &lt;= n)            upd(1, 0, n, ne[id[i]], ne[ne[id[i]]] - 1, f[id[i]] + 1);    &#125;    std::cout &lt;&lt; n - res &lt;&lt; &#39;\n&#39;;    return 0;&#125;</code></pre></details><hr /><h2 id="merge-triplets">4. Merge Triplets</h2><p><a href="https://atcoder.jp/contests/agc043/tasks/agc043_d" class="uri">https://atcoder.jp/contests/agc043/tasks/agc043_d</a></p><blockquote><p>给定 <span class="math inline">\(A_{1\sim 3N}=\{1, 2, \dots, 3N\}\)</span>，从 <span class="math inline">\(1\)</span> 开始每 <span class="math inline">\(3\)</span> 个数分为一组，每一组初始有一个指针指向第一个元素。执行若干次以下操作：</p><ul><li>在所有指针指向的数中选择一个最小的，把它放到序列末（不会加入末端的组）；将原本指向它的指针后移一位，如果移出原本的组就删除这个指针。</li></ul><p>问任意次操作后，可能得到多少种序列。<span class="math inline">\(n\le 2\times 10^3\)</span>。</p></blockquote><p>由于要对合法的最终序列进行计数，考虑最终序列的性质。</p><p>若序列中 <span class="math inline">\(a_{i+1}&lt;a_i\)</span>，则说明在某一组中，值为 <span class="math inline">\(a_i\)</span> 的元素下一个就是 <span class="math inline">\(a_{i+1}\)</span>。否则，因 <span class="math inline">\(a_{i+1}\)</span> 可选且比 <span class="math inline">\(a_i\)</span> 小，<span class="math inline">\(a_{i+1}\)</span> 应排在 <span class="math inline">\(a_i\)</span> 前面。</p><p>否则，<span class="math inline">\(a_{i+1}\)</span> 既可以与 <span class="math inline">\(a_i\)</span> 不在同一组，也可以是 <span class="math inline">\(a_i\)</span> 的下一个元素。</p><p>一组最多三个元素，也就是说，不能出现 <span class="math inline">\(a_i&gt;a_{i+1},a_{i+2},a_{i+3}\)</span> 的情况。而 <span class="math inline">\(N=1\)</span> 时序列长度只有 <span class="math inline">\(3\)</span>，这就是为什么样例一的答案为 <span class="math inline">\(3!\)</span>。</p><p>但这个限制并不能排除所有非法情况。<span class="math inline">\(N=2\)</span> 时暴搜我们目前限制下的解，共有 276 个，比答案中的 261 个要多，说明包含了其他非法解。</p><p>暴搜输出并观察，易得这 15 个非法序列即为满足目前限制且存在 <span class="math inline">\(3\)</span> 个 <span class="math inline">\(i\)</span>，满足 <span class="math inline">\(a_i&gt;a_{i+1}\)</span> 且 <span class="math inline">\(a_i&lt;a_{i+2}\)</span> 的所有序列，<mark>由前面的推导，必须分为三个长度为 2 的组，而我们要求的是长度为 3 的组。显然无法用前者组合得到后者</mark>。</p><p>在我们第一个条件的限制下，必须被分到同一组的数的连续长度，只有 <span class="math inline">\(1,2,3\)</span> 三种。而：</p><ul><li>长度为 3 的对答案合法性无影响；</li><li>而长度为 1 的既可以和 2 组为一组，也可以和其他两个 1 组为一组；</li><li>长度为 2 的只能和 1 组成一组。</li></ul><p><mark>这时，我们发现所有限制都指向长度为 2 的段，其总个数不能比长度为 1 的段多。</mark></p><p>于是乎，上述限制可总结为两点：</p><ol type="1"><li>若令所有满足 <span class="math inline">\(a_l&gt;\max\{a_{l\sim r}\}\)</span> 的极大区间为一段（易证每段互不重合且覆盖全序列），那么其长度不能超过 3。</li><li>其中，长度为 2 的个数不能比长度为 1 的个数多。</li></ol><p><mark>令 <span class="math inline">\(f_{i, j}\)</span> 表示若当前枚举的最后一段右端点为 <span class="math inline">\(i\)</span>，长度为 1 的段比长度为 2 的段多 <span class="math inline">\(j\)</span> 的方案数。</mark></p><p>最后答案即为 <span class="math inline">\(\sum\limits_{j=0}^n f_{i, j}\)</span>。</p><details><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;int main() &#123;#ifdef ONLINE_JUDGE    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr);    std::cout.tie(nullptr);#else    freopen(&quot;.in&quot;, &quot;r&quot;, stdin);    freopen(&quot;.out&quot;, &quot;w&quot;, stdout);#endif    int n, mod;    std::cin &gt;&gt; n &gt;&gt; mod;    n *= 3;    std::vector&lt;std::unordered_map&lt;int, long long&gt; &gt; f(n + 1);    f[0][0] = 1;    for (int i = 0; i &lt; n; ++i)        for (auto [j, k] : f[i]) &#123;            (f[i + 1][j + 1] += k) %= mod;            if (i + 2 &lt;= n)                (f[i + 2][j - 1] += k * (i + 1) % mod) %= mod;            if (i + 3 &lt;= n)                (f[i + 3][j] += k * (i + 1) % mod * (i + 2) % mod) %= mod;        &#125;    long long res = 0;    for (int i = 0; i &lt;= n; ++i)        (res += f[n][i]) %= mod;    std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;    return 0;&#125;</code></pre></details><hr /><h2 id="runaway-quail">5. Runaway Quail</h2><p><a href="https://qoj.ac/problem/5978" class="uri">https://qoj.ac/problem/5978</a></p><blockquote><p>数轴上有 <span class="math inline">\(n\)</span> 只鸡，初始位置为非 <span class="math inline">\(0\)</span> 整数 <span class="math inline">\(p_i\)</span>，奔跑速度为 <span class="math inline">\(s_i\)</span>。你初始在 <span class="math inline">\(0\)</span> 位置，奔跑速度为 <span class="math inline">\(Y(Y&gt;s_i)\)</span>。你要抓到所有鸡。</p><p>你可以在任意时刻调转方向；鸡总会朝着远离你的方向奔跑；当你的坐标和鸡重合时，你抓到鸡。</p><p>问抓到所有鸡的最短时间（显然是个实数）。<span class="math inline">\(n\le 500\)</span>。</p></blockquote><p>容易发现鸡的奔跑方向从始至终不会变，如果我们要从往左追变成往右追，显而易见地我们会<mark>在追上右边第一只鸡前经过原点</mark>，反之同理。</p><p>那么有一个很神奇的状态设计，设 <span class="math inline">\(f_{i,j}\)</span> 为追上了左边速度第 <span class="math inline">\(1\sim i - 1\)</span> 大的所有鸡和右边速度第 <span class="math inline">\(1\sim j - 1\)</span> 大的所有鸡，然后跑回原点的最小时间，这样我们就不用记录这个非常难记录的当前位置信息，对于速度排名 <span class="math inline">\(\ge i,j\)</span> 的所有鸡，当前是否追上我们并不关心——<mark>如果其位置比较远，那么我们会在后续转移中再考虑；如果其位置比较近，在解决速度排名 <span class="math inline">\(&lt;i,j\)</span> 的鸡时就已经抓住</mark>。</p><p><mark>我们 <span class="math inline">\(\mathcal O(n)\)</span> 枚举上一次反向是在抓住哪一只鸡时，然后让中间全部同向跑即可</mark>。</p><p>也就是说，假设我们要用 <span class="math inline">\(f_{i,j}\)</span> 更新 <span class="math inline">\(f_{k,j}\)</span>（<span class="math inline">\(k&lt;i\)</span>），那么只需要更新抓住速度排名 <span class="math inline">\(i\sim k+1\)</span> 中跑得最远的一只鸡所需额外时间。按速度排序后可以线性算代价。</p><details><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;const long double eps = 1e-12;int main() &#123;#ifdef ONLINE_JUDGE    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr), std::cout.tie(nullptr);#else    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);#endif    int T;    for (std::cin &gt;&gt; T; T--; ) &#123;        int v, n;        std::cin &gt;&gt; v &gt;&gt; n;        std::vector&lt;std::pair&lt;int, int&gt; &gt; a(n + 1);        for (int i = 1; i &lt;= n; ++i)            std::cin &gt;&gt; a[i].first;        for (int i = 1; i &lt;= n; ++i)            std::cin &gt;&gt; a[i].second;        a.emplace_back(0, 0), ++n;        std::sort(a.begin() + 1, a.end());        int p = std::lower_bound(a.begin() + 1, a.end(), std::make_pair(0, 0)) - a.begin();        std::sort(a.begin() + 1, a.begin() + p, [](std::pair&lt;int, int&gt; x, std::pair&lt;int, int&gt; y) &#123; return x.second == y.second ? x.first &lt; y.first : x.second &gt; y.second; &#125;);        std::sort(a.begin() + p + 1, a.end(), [](std::pair&lt;int, int&gt; x, std::pair&lt;int, int&gt; y) &#123; return x.second == y.second ? x.first &lt; y.first : x.second &lt; y.second; &#125;);        std::vector&lt;std::vector&lt;long double&gt; &gt; f(n + 1, std::vector&lt;long double&gt; (n + 1, 1e18));        f[1][n] = 0.;        auto at = [&amp;](int i, long double t) &#123;            return std::fabs(a[i].first + t * a[i].second * (i &lt; p ? -1 : 1));        &#125;;        auto calc = [&amp;](int i, long double t) &#123;            return at(i, t) / (v - a[i].second);        &#125;;        // for (int i = 1; i &lt;= n; ++i)        //     printf(&quot;%d: (%d, %d)\n&quot;, i, a[i].first, a[i].second);        for (int i = 1; i &lt;= p; ++i)            for (int j = n; j &gt;= p; --j) &#123;                if (i == p &amp;&amp; j == p)                    break;                long double d = 0.;                // printf(&quot;[%d, %d]: %lf\n&quot;, i, j, f[i][j]);                for (int k = i; k &lt; p; ++k) &#123;                    if (at(k, f[i][j]) &gt;= at(i, f[i][j]) - eps)                        d = std::max(d, calc(k, f[i][j]));                    // printf(&quot;  k1 = %d, d = %lf\n&quot;, k, d);                    f[k + 1][j] = std::min(f[k + 1][j], f[i][j] + d + (k != j - 1) * d);                &#125;                d = 0.;                for (int k = j; k &gt; p; --k) &#123;                    if (at(k, f[i][j]) &gt;= at(j, f[i][j]) - eps)                        d = std::max(d, calc(k, f[i][j]));                    // printf(&quot;  k2 = %d, d = %lf\n&quot;, k, d);                    f[i][k - 1] = std::min(f[i][k - 1], f[i][j] + d + (k != i + 1) * d);                &#125;            &#125;        &#123;            static int casetot = 0;            std::cout &lt;&lt; &quot;Case #&quot; &lt;&lt; ++casetot &lt;&lt; &quot;: &quot;;        &#125;        std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(9) &lt;&lt; f[p][p] &lt;&lt; &#39;\n&#39;;    &#125;    return 0;&#125;</code></pre></details><hr /><h2 id="the-great-marathon">6. The Great Marathon</h2><p><a href="https://codeforces.com/problemset/problem/38/H" class="uri">https://codeforces.com/problemset/problem/38/H</a></p><blockquote><p>给定一个 <span class="math inline">\(n\)</span> 个点 <span class="math inline">\(m\)</span> 条边的无向连通图，点 <span class="math inline">\(i\)</span> 上初始有选手 <span class="math inline">\(i\)</span>。为每个选手任意指定终点（可重复），那么最后的排名按照最短路为第一关键字、编号为第二关键字排序。</p><p>现按照排名序列分成前中后三段，记为金银铜牌；满足金牌数在 <span class="math inline">\([g_1,g_2]\)</span> 之间，银牌数在 <span class="math inline">\([s_1,s_2]\)</span> 之间。任意指定发牌数量和每个人的终点，问最后有多少种方案数；两个方案不同当且仅当有至少一个人拿的牌不一样。</p><p><span class="math inline">\(n\le 50,m\le 1000\)</span>。</p></blockquote><p><mark><span class="math inline">\(n=50\)</span>：可能需要考虑 <span class="math inline">\(n^5\)</span> 做法。</mark></p><p>发现是 <mark>需要确定顺序的 DP</mark>。关键位置自然在于『金银、银铜界处』。考虑钦定金牌最后一名、铜牌第一名的人选（不考虑中间的银牌是因为会出现这样那样的问题），还需要枚举他们的路程吗？并不。甚而至于，这样做会算重。</p><p>考虑<mark>『最小化』左右两侧的金牌、铜牌可选集合</mark>。强行让金牌最后一名 <span class="math inline">\(u\)</span> 的路程为 <span class="math inline">\(\min\{dis_{u,i}\}\)</span>，最小路程小于这个值的所有元素都可以成为金牌；同时让铜牌第一名 <span class="math inline">\(v\)</span> 的路程为 <span class="math inline">\(\max\{dis_{v,i}\}\)</span>，最大路程大于这个值的所有数都可以成为铜牌。</p><p>Q1: 如果存在一个 <span class="math inline">\(i\)</span>，它最小的距离也比 <span class="math inline">\(u\)</span> 的最小距离大，但实际上当 <span class="math inline">\(u\)</span> 更大一点儿的时候，<span class="math inline">\(i\)</span> 可以成为金牌呢？</p><p>A1：这种情况在钦定 <span class="math inline">\(i\)</span> 为最后一名的时候讨论过了。</p><p>Q2：是否会算重？</p><p>A2：如上所述，假如在钦定 <span class="math inline">\(i\)</span> 的时候统计了 <span class="math inline">\(u\)</span>，那么在钦定 <span class="math inline">\(u\)</span> 的时候就不会统计 <span class="math inline">\(i\)</span>。</p><p>考虑转移。令 <span class="math inline">\(f_{i,u,v,j,k}\)</span> 为考虑到 <span class="math inline">\(i\)</span>，金牌倒一为 <span class="math inline">\(u\)</span>，铜牌第一为 <span class="math inline">\(v\)</span>，选了 <span class="math inline">\(j\)</span> 个金、<span class="math inline">\(k\)</span> 个铜的方案数。转移是 <span class="math inline">\(O(1)\)</span> 的。</p><details><p>注意 <code>vector</code> 要开在循环外面，不然申请空间很耗时间 /ll</p><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;const int inf = 0x3f3f3f3f;int main() &#123;#ifdef ONLINE_JUDGE    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr), std::cout.tie(nullptr);#else    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);#endif    int n, m;    std::cin &gt;&gt; n &gt;&gt; m;    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1, std::vector&lt;int&gt; (n + 1, inf));    for (int x, y; m--; ) &#123;        std::cin &gt;&gt; x &gt;&gt; y;        std::cin &gt;&gt; g[x][y], g[y][x] = g[x][y];    &#125;    for (int i = 1; i &lt;= n; ++i)        g[i][i] = 0;    for (int k = 1; k &lt;= n; ++k)        for (int i = 1; i &lt;= n; ++i)            if (k != i)                for (int j = 1; j &lt;= n; ++j)                    if (i != k &amp;&amp; j != k)                        g[i][j] = std::min(g[i][j], g[i][k] + g[k][j]);    int g1, g2, s1, s2;    std::cin &gt;&gt; g1 &gt;&gt; g2 &gt;&gt; s1 &gt;&gt; s2;    for (int i = 1; i &lt;= n; ++i)        for (int j = 1; j &lt;= n; ++j)            if (g[i][j] != inf)                g[i][j] = g[i][j] * n + i;    std::vector&lt;int&gt; mx(n + 1), mn(n + 1, inf);    for (int i = 1; i &lt;= n; ++i) &#123;        for (int j = 1; j &lt;= n; ++j)            if (j != i)                mn[i] = std::min(mn[i], g[i][j]);        mx[i] = *std::max_element(g[i].begin() + 1, g[i].end());    &#125;    auto res(0ll);    std::vector&lt;std::vector&lt;std::vector&lt;long long&gt; &gt; &gt; f(n + 1, std::vector&lt;std::vector&lt;long long&gt; &gt; (n + 1, std::vector&lt;long long&gt; (n + 1)));    for (int u = 1; u &lt;= n; ++u)        for (int v = 1; v &lt;= n; ++v)            if (v != u) &#123;                f[0][1][1] = 1ll;                for (int i = 1; i &lt;= n; ++i)                    if (i == u || i == v)                        f[i] = f[i - 1];                    else &#123;                        bool flag = 0;                        for (int j = 1; j &lt;= n; ++j)                            if (mn[u] &lt; g[i][j] &amp;&amp; g[i][j] &lt; mx[v]) &#123;                                flag = 1;                                break;                            &#125;                        for (int j = 1; j &lt;= g2; ++j)                            for (int k = 1; k &lt;= n - g1 - s1; ++k) &#123;                                f[i][j][k] = 0ll;                                if (mx[i] &lt; mn[u])                                    f[i][j][k] = f[i - 1][j - 1][k];                                else if (mn[i] &gt; mx[v])                                    f[i][j][k] = f[i - 1][j][k - 1];                                else &#123;                                    if (flag)                                        f[i][j][k] = f[i - 1][j][k];                                    if (mn[i] &lt; mn[u])                                        f[i][j][k] += f[i - 1][j - 1][k];                                    if (mx[i] &gt; mx[v])                                        f[i][j][k] += f[i - 1][j][k - 1];                                &#125;                            &#125;                    &#125;                for (int g = g1; g &lt;= g2; ++g)                    for (int s = s1; s &lt;= s2; ++s)                        res += f[n][g][n - g - s];            &#125;    std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;    return 0;&#125;</code></pre></details><hr /><h2 id="sorting-pancakes">7. Sorting Pancakes</h2><p><a href="https://codeforces.com/contest/1675/problem/G" class="uri">https://codeforces.com/contest/1675/problem/G</a></p><blockquote><p>给定盒子 <span class="math inline">\(1\sim n\)</span> 和每个盒子 <span class="math inline">\(i\)</span> 里的初始球数 <span class="math inline">\(a_i\)</span>，每次可以选择一个球移动到相邻盒子，最后欲使盒子内球数单调不升,求最小移球次数。</p><p><span class="math inline">\(n,\sum a_i\le 250\)</span>。</p></blockquote><p>简单题！这种『移动元素的题』，会考虑<mark>钦定每个元素最终的值，把前面的元素富余的 / 欠下来的存储起来</mark>。<em>当然也有例外，比如添加了『时间』这一维的限制，goto <a href="http://localhost:4000/20250510/#a---pass-to-next">solu to Pass to Next</a></em></p><p>在如果在 <span class="math inline">\(i\)</span> 处富余了 <span class="math inline">\(x\)</span>，那么在移动到 <span class="math inline">\(i+1\)</span> 的过程中就会产生 <span class="math inline">\(|x|\)</span> 的代价。</p><p>令 <span class="math inline">\(f_{i,k,j}\)</span> 表示第 <span class="math inline">\(i\)</span> 个元素处，钦定它最终为 <span class="math inline">\(j\)</span>，富余 <span class="math inline">\(k\)</span>，则 <span class="math inline">\(f_{i,k,j}\gets \min\limits_{j&#39;\ge j}\{f_{i-1, k-(j-a_i),j&#39;}\}\)</span>。显而易见后缀 min 优化就能 <span class="math inline">\(O(n\cdot m^2)\)</span> 地做了。</p><details><p>DP 数组和后缀 min 数组要合起来，不然会 MLE /ll</p><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;const int inf = 0x3f3f3f3f;int main() &#123;#ifdef ONLINE_JUDGE    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr), std::cout.tie(nullptr);#else    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);#endif    int n, m;    std::cin &gt;&gt; n &gt;&gt; m;    std::vector&lt;int&gt; a(n + 1);    for (int i = 1; i &lt;= n; ++i)        std::cin &gt;&gt; a[i];    using arr = std::vector&lt;int&gt;;    using brr = std::vector&lt;arr&gt;;    using crr = std::vector&lt;brr&gt;;    crr f(n + 1, brr(2 * m + 1, arr(m + 1, inf)));    std::fill(f[0][m].begin(), f[0][m].begin() + m + 1, 0);    for (int i = 1; i &lt;= n; ++i)        for (int k = 0; k &lt;= 2 * m; ++k)            for (int j = std::min(m, k + a[i]); j &gt;= std::max(0, k + a[i] - 2 * m); --j) &#123;                f[i][k][j] = f[i - 1][k - (j - a[i])][j] + std::abs(k - m);                if (j != m)                    f[i][k][j] = std::min(f[i][k][j], f[i][k][j + 1]);            &#125;    std::cout &lt;&lt; f[n][m][0] &lt;&lt; &#39;\n&#39;;    return 0;&#125;</code></pre></details><hr /><h2 id="complexity">8. Complexity</h2><p><a href="https://atcoder.jp/contests/agc033/tasks/agc033_d" class="uri">https://atcoder.jp/contests/agc033/tasks/agc033_d</a></p><blockquote><p>给定 <span class="math inline">\(n\times m\)</span> 的 <span class="math inline">\(01\)</span> 矩阵。定义其子矩阵的凌乱度：</p><ul><li>若该矩阵中只有一种值，凌乱度为 <span class="math inline">\(0\)</span>。</li><li>否则，任意竖直 / 水平切一刀，得到两个小矩阵；若它们的凌乱度分别为 <span class="math inline">\(a,b\)</span>，则大矩阵的凌乱度为 <span class="math inline">\(\max(a,b)+1\)</span> 的最小值。</li></ul><p>求给定矩阵的凌乱度。<span class="math inline">\(n,m\le 185\)</span>。</p></blockquote><p>如果暴力枚举 DP，很不幸是 <span class="math inline">\(n^5\)</span> 的。考虑优化。发现矩阵的凌乱度大致在 <span class="math inline">\(O(\log n)\)</span> 级别，考虑用<mark>状态交换答案</mark>减小复杂度。具体地，设 <span class="math inline">\(f_{k,u,d,l}\)</span> 表示凌乱度 <span class="math inline">\(\le k\)</span> 时，<span class="math inline">\(r\)</span> 可取到的最大值，那么有转移：</p><ul><li>竖着切一刀，枚举切点 <span class="math inline">\(i\le f_{k-1,u,d,l}\)</span>，有 <span class="math inline">\(f_{k,u,d,l}\gets f_{k-1,u,d,i+1}\)</span>。发现显然 <span class="math inline">\(i\)</span> 取 <span class="math inline">\(f_{k-1,u,d,l}\)</span> 的时候最优，这个是 <span class="math inline">\(O(1)\)</span> 的。</li><li>横着切一刀，枚举切点 <span class="math inline">\(i\in[u,d)\)</span>，有 <span class="math inline">\(f_{k,u,d,l}\gets \min(f_{k-1,u,i,l},f_{k-1,i+1,d,l})\)</span>。发现随 <span class="math inline">\(i\)</span> 增大左边单调不增，右边单调不降。随着 <span class="math inline">\(d\)</span> 的增大，左边不变，右边下移，交出来的交点一直右移。然后就可以优化到均摊 <span class="math inline">\(O(1)\)</span>。</li></ul><details><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;const int inf = 0x3f3f3f3f;int main() &#123;#ifdef ONLINE_JUDGE    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr), std::cout.tie(nullptr);#else    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);#endif    int n, m;    std::cin &gt;&gt; n &gt;&gt; m;    std::vector&lt;std::vector&lt;char&gt; &gt; a(n + 1, std::vector&lt;char&gt; (m + 1));    for (int i = 1; i &lt;= n; ++i)        for (int j = 1; j &lt;= m; ++j)            std::cin &gt;&gt; a[i][j];    using arr = std::vector&lt;int&gt;;    using brr = std::vector&lt;arr&gt;;    using crr = std::vector&lt;brr&gt;;    std::vector&lt;std::string&gt; res;    std::vector&lt;crr&gt; _f(2, crr(n + 1, brr(m + 1, arr(n + 1))));    for (int k = 0; ; ++k) &#123;        auto &amp;f = _f[k &amp; 1], &amp;f1 = _f[(k &amp; 1) ^ 1];        if (k == 0) &#123;            crr tag(m + 1, brr(n + 1, arr(n + 1, -1)));            for (int l = 1; l &lt;= m; ++l)                for (int u = 1; u &lt;= n; ++u)                    for (int d = u; d &lt;= n &amp;&amp; a[d][l] == a[u][l]; ++d)                        tag[l][u][d] = a[u][l];            for (int u = 1; u &lt;= n; ++u)                for (int d = u; d &lt;= n; ++d)                    for (int l = m; l; --l) &#123;                        f[u][l][d] = l - 1;                        if (~tag[l][u][d]) &#123;                            if (l != m &amp;&amp; tag[l][u][d] == tag[l + 1][u][d])                                f[u][l][d] = f[u][l + 1][d];                            else                                f[u][l][d] = l;                        &#125;                    &#125;        &#125;        else            for (int u = 1; u &lt;= n; ++u)                for (int l = 1; l &lt;= m; ++l)                    for (int d = u, pos = 1; d &lt;= n; ++d) &#123;                        f[u][l][d] = f1[u][l][d];                        if (f[u][l][d] != m) &#123;                            f[u][l][d] = std::max(f[u][l][d], f1[u][f1[u][l][d] + 1][d]);                            int mx = 0;                            for (int i = pos; i &lt; d; ++i) &#123;                                if (std::min(f1[u][l][i], f1[i + 1][l][d]) &gt;= mx)                                    mx = std::min(f1[u][l][i], f1[i + 1][l][d]), pos = i;                                else                                    break;                            &#125;                            f[u][l][d] = std::max(f[u][l][d], mx);                        &#125;                    &#125;        if (f[1][1][n] == m) &#123;            std::cout &lt;&lt; k &lt;&lt; &#39;\n&#39;;            return 0;        &#125;    &#125;    return 0;&#125;</code></pre></details><hr /><h2 id="boxes-and-balls">9. Boxes and Balls</h2><p><a href="https://www.luogu.com.cn/problem/CF1845E" class="uri">https://www.luogu.com.cn/problem/CF1845E</a></p><blockquote><p>给定一个长度为 <span class="math inline">\(n\)</span> 的 <span class="math inline">\(01\)</span> 序列 <span class="math inline">\(a_{1\sim n}\)</span>。你可以进行恰好 <span class="math inline">\(k\)</span> 次如下操作：</p><ul><li>选择序列中一对相邻且值不同的元素，将它们交换。</li></ul><p>问有多少种最终序列。<span class="math inline">\(n,k\le 1500\)</span>。</p></blockquote><p>沿用 <a href="#sorting-pancakes">7. Sorting Pancakes</a> 的思路，考虑令 <span class="math inline">\(f_{i,j,l}\)</span> 表示最终序列的前 <span class="math inline">\(i\)</span> 个里有 <span class="math inline">\(j\)</span> 个 <span class="math inline">\(1\)</span>，代价已经有 <span class="math inline">\(l\)</span> 的方案数；那么令 <span class="math inline">\(s_i\)</span> 为 <span class="math inline">\(a\)</span> 的前缀和，显然有：</p><p><span class="math display">\[f_{i+1,j+1,k+|j-s_i|}\gets f_{i,j,k}\\f_{i+1,j,k+|j-s_i|}\gets f_{i,j,k}\]</span></p><p>最后在比 <span class="math inline">\(k\)</span> 小且奇偶性和 <span class="math inline">\(k\)</span> 相同的 <span class="math inline">\(l\)</span> 里找答案。然后想怎么优化。</p><p>答案是不用优化。考虑<mark>有效状态数</mark>，<del>打个表发现每个 <span class="math inline">\(i\)</span> 在 <span class="math inline">\(O(n\sqrt n)\)</span> 左右</del>，但有另一种方法是发现有效的 <span class="math inline">\(|j-s_i|\)</span> 不会超过 <span class="math inline">\(O(\sqrt n)\)</span>（原因：为了消除 <span class="math inline">\(|j-s_i|\)</span> 的欠账，需要 <span class="math inline">\(|j-s_i|\)</span> 个位置；每个位置都会有差不多 <span class="math inline">\(|j-s_i|\)</span> 的代价），所以枚举时只用枚举 <span class="math inline">\(O(\sqrt n)\)</span> 个 <span class="math inline">\(j\)</span>。</p><p>总之只用存有效状态会发现跑不满 <img src="/em/bb.gif" /></p><details><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;const int mod = 1e9 + 7;int main() &#123;#ifdef ONLINE_JUDGE    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr), std::cout.tie(nullptr);#else    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);#endif    int n, k;    std::cin &gt;&gt; n &gt;&gt; k;    std::vector&lt;int&gt; a(n + 1), s(n + 1);    for (int i = 1; i &lt;= n; ++i)        std::cin &gt;&gt; a[i];    std::partial_sum(a.begin() + 1, a.end(), s.begin() + 1);    using arr = std::vector&lt;long long&gt;;    using brr = std::vector&lt;arr&gt;;    using crr = std::vector&lt;brr&gt;;    brr tag(n + 1, arr(n + 1));    std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; stt(2);    stt[0].emplace_back(0, 0);    crr _f(2, brr(n + 1, arr(k + 1)));    _f[0][0][0] = 1;    for (int i = 0; i &lt; n; ++i) &#123;        auto &amp;f = _f[i &amp; 1], &amp;f1 = _f[(i &amp; 1) ^ 1];        std::vector&lt;std::pair&lt;int, int&gt; &gt;().swap(stt[(i &amp; 1) ^ 1]);        for (auto [j, l] : stt[i &amp; 1]) &#123;                if (j + 1 &lt;= s[n] &amp;&amp; l + std::abs(j - s[i]) &lt;= k) &#123;                    if (tag[j + 1][l + std::abs(j - s[i])] != i + 1)                        tag[j + 1][l + std::abs(j - s[i])] = i + 1, stt[(i &amp; 1) ^ 1].emplace_back(j + 1, l + std::abs(j - s[i])), f1[j + 1][l + std::abs(j - s[i])] = 0ll;                    (f1[j + 1][l + std::abs(j - s[i])] += f[j][l]) %= mod;                &#125;                if (l + std::abs(j - s[i]) &lt;= k) &#123;                    if (tag[j][l + std::abs(j - s[i])] != i + 1)                        tag[j][l + std::abs(j - s[i])] = i + 1, stt[(i &amp; 1) ^ 1].emplace_back(j, l + std::abs(j - s[i])), f1[j][l + std::abs(j - s[i])] = 0ll;                    (f1[j][l + std::abs(j - s[i])] += f[j][l]) %= mod;                &#125;            &#125;        std::cout &lt;&lt; (int)stt[i &amp; 1].size() &lt;&lt; &#39;\n&#39;;    &#125;    auto res(0ll);    for (int i = k &amp; 1; i &lt;= k; i += 2)        if (tag[s[n]][i] == n)            (res += _f[n &amp; 1][s[n]][i]) %= mod;    std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;    return 0;&#125;</code></pre></details><hr /><h2 id="legondary-grandmaster">10. LEGOndary Grandmaster</h2><p><a href="https://codeforces.com/problemset/problem/1615/F" class="uri">https://codeforces.com/problemset/problem/1615/F</a></p><blockquote><p>给定两个长度为 <span class="math inline">\(n\)</span> 的 <span class="math inline">\(0/1/?\)</span> 串 <span class="math inline">\(s,t\)</span>，你可以对 <span class="math inline">\(s\)</span> 进行若干次如下操作：</p><ul><li>选择序列中一对相邻且值相同的元素，将它们取反。</li></ul><p>现任意将 <span class="math inline">\(s\)</span> 和 <span class="math inline">\(t\)</span> 中的 <code>?</code> 填为 <span class="math inline">\(0/1\)</span>，问所有情况中 <span class="math inline">\(s\)</span> 转化为 <span class="math inline">\(t\)</span> 所需最小操作次数和（规定无解的操作次数为 <span class="math inline">\(0\)</span>）。<span class="math inline">\(n\le 2000\)</span>。</p></blockquote><p>如果我们之前做过某些令人心（咬）旷（牙）神（切）怡（齿）的题目，会发现这个操作等价于交换任意两个相邻数，再让他们取反。</p><p>进一步地，可以交换运算顺序，先取反某个位置，再交换，再取反这个位置——把这个操作平均分配到 <span class="math inline">\(s\)</span> 和 <span class="math inline">\(t\)</span> 上，<mark>结合『相邻两数位置必一奇一偶』这个美妙的性质，想到把 <span class="math inline">\(s\)</span> 和 <span class="math inline">\(t\)</span> 的奇数位都提前取反，这样就可以转化成直接交换了</mark>，</p><p>接下来就和上一题有点不一样了。这里我们直接算一个位置的贡献——这意味着不需要统计一个序列的代价（此时失去了 <span class="math inline">\(k\)</span> 的限制，代价来到 <span class="math inline">\(n^2\)</span> 级别）。令 <span class="math inline">\(f_{i,j}\)</span> 表示从前往后到了第 <span class="math inline">\(i\)</span> 个位置，欠债为 <span class="math inline">\(j\)</span> 的方案数；同样地，令 <span class="math inline">\(g_{i,j}\)</span> 表示从后到前到了第 <span class="math inline">\(i\)</span> 个位置，欠债为 <span class="math inline">\(j\)</span> 的方案数。则贡献为 <span class="math inline">\(\sum_i \sum_j f_{i, j}\times g_{i + 1, -j}\times j\)</span>。</p><details><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;const int mod = 1e9 + 7;int main() &#123;#ifdef ONLINE_JUDGE    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr), std::cout.tie(nullptr);#else    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);#endif    int T;    for (std::cin &gt;&gt; T; T--; ) &#123;        int n;        std::string s, t;        std::cin &gt;&gt; n &gt;&gt; s &gt;&gt; t, s = &#39;#&#39; + s, t = &#39;#&#39; + t;        for (int i = 1; i &lt;= n; ++i)            if (i &amp; 1) &#123;                if (s[i] != &#39;?&#39;)                    s[i] = &#39;0&#39; + &#39;1&#39; - s[i];                if (t[i] != &#39;?&#39;)                    t[i] = &#39;0&#39; + &#39;1&#39; - t[i];            &#125;        using arr = std::vector&lt;long long&gt;;        using brr = std::vector&lt;arr&gt;;        brr f(n + 1, arr(2 * n + 1)), g(n + 2, arr(2 * n + 1));        f[0][n] = 1ll;        for (int i = 1; i &lt;= n; ++i) &#123;            for (int S = 0; S &lt;= 1; ++S)                if ((S == 0 &amp;&amp; s[i] == &#39;1&#39;) || (S == 1 &amp;&amp; s[i] == &#39;0&#39;));                else                    for (int T = 0; T &lt;= 1; ++T) &#123;                        if ((T == 0 &amp;&amp; t[i] == &#39;1&#39;) || (T == 1 &amp;&amp; t[i] == &#39;0&#39;));                        else                            for (int j = 0; j &lt;= 2 * n; ++j)                                if (j - (T - S) &gt;= 0 &amp;&amp; j - (T - S) &lt;= 2 * n)                                    (f[i][j] += f[i - 1][j - (T - S)]) %= mod;                    &#125;        &#125;        g[n + 1][n] = 1ll;        for (int i = n; i; --i) &#123;            for (int S = 0; S &lt;= 1; ++S)                if ((S == 0 &amp;&amp; s[i] == &#39;1&#39;) || (S == 1 &amp;&amp; s[i] == &#39;0&#39;));                else                    for (int T = 0; T &lt;= 1; ++T) &#123;                        if ((T == 0 &amp;&amp; t[i] == &#39;1&#39;) || (T == 1 &amp;&amp; t[i] == &#39;0&#39;));                        else                            for (int j = 0; j &lt;= 2 * n; ++j)                                if (j - (T - S) &gt;= 0 &amp;&amp; j - (T - S) &lt;= 2 * n)                                    (g[i][j] += g[i + 1][j - (T - S)]) %= mod;                    &#125;        &#125;        auto res(0ll);        for (int i = 1; i &lt; n; ++i)            for (int j = 1; j &lt;= n; ++j) &#123;                (res += j * f[i][n + j] % mod * g[i + 1][n - j] % mod) %= mod;                (res += j * f[i][n - j] % mod * g[i + 1][n + j] % mod) %= mod;            &#125;        std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;    &#125;    return 0;&#125;</code></pre></details>]]></content>
      
      
      
        <tags>
            
            <tag> DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>媒介素养</title>
      <link href="/20240625/"/>
      <url>/20240625/</url>
      
        <content type="html"><![CDATA[<p>Adapted from 之前的一片发电文。现在更癫了。</p><span id="more"></span><hr /><p><img src="pre.jpeg" /></p><hr /><p>媒介素养一般是指人们正确地、建设性地使用媒介资源的能力。它包括人们面对各种信息时的选择、理解、质疑、评估等能力。</p><ul><li>关于选择：太遗憾了！你没有任何其他的项目是可选择的，因为<em>歌愛ユキ</em>很可爱！</li><li>关于理解：接下来，你将会度过一定量的时间理解<em>歌愛ユキ</em>的可爱性。</li><li>关于质疑：是的，正在质疑！通常情况下这代表着一种好的状态，但在这里您可能会遇到障碍——你不会想要质疑<em>歌愛ユキ</em>。事实上，<em>歌愛ユキ</em>又有什么是可质疑的呢？</li><li><p>关于评估：当然，在这里，评估有着不可忽视的重要性——海内存知己，天涯若比邻。对我们的<em>歌愛ユキ</em>进行打分！</p><p>可选的评估项：</p><ul><li>100 分</li><li><p>其他，请补锟斤拷锟斤拷锟斤拷烫烫烫烫烫烫烫烫烫</p><pre><code>程序 Assessing.exe 引用了名为 0x00000000ff 的内存，该地址不能为 &#39;read&#39;。</code></pre><p>很遗憾！看起来你的 Windows 出现了问题。请勿关闭电脑，我们将会收集你电脑上的错误信息，我们将会将它上传到 Microsoft 官网并尝试在脱机状态下解决它。</p><p>错误代码：0x00009E2EAF60</p><p>我们正在为你解析。</p></li></ul></li></ul><hr /><p>嘿，抬起头！这篇帖子可能并没有您正在考虑的那样陌生！</p><p>Hey, heads up! The post may not so strange as you are considering!</p><p>让我们分析这些笑话！</p><p>Let’s analyse the jokes!</p><ul><li><p>努力理解「花」意味着什么。</p>Try to understand what “spend” means.</li><li><p>正在错误地翻译「查询」。</p>Wrong translating “querying”.</li><li><p>海内存知己，天涯若比邻。</p>Sea inside exist know self, sky Ya like than neighbor.</li><li><p>主语并未变化，但主语却在相邻的两个短句中出现了。相同的相邻主语没有得到省略，而这将导致这些相同的主语看起来很累赘！</p>The subject didn’t changed, but it appears in two adjacent short sentences. The same adjacent subjects havn’t been omitted, which will make these identical subjects appear cumbersome!</li><li><p>正在错过时间状语！这使「上传」和「脱机处理」两个动作看上去像是同时发生的。</p>Missing time adverb! This makes the actions of “uploading” and “offline processing” appear to occur simultaneously.</li><li><p>你您你您你您你您你您</p><p>You you you you you you you you you you</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 闲话 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>状压枚举子集 + 高维前缀和</title>
      <link href="/20240517/"/>
      <url>/20240517/</url>
      
        <content type="html"><![CDATA[<p>出现了，但发现没写过，故记之。</p><span id="more"></span><hr /><h3 id="状压枚举子集">状压枚举子集</h3><p>需求：对于 <strong>每一个</strong> 长度为 <span class="math inline">\(n\)</span> 的二进制状态 <span class="math inline">\(s\)</span>，枚举其子状态 <span class="math inline">\(\{ t \mid t \operatorname{bitand} s = t \}\)</span>。</p><p>直接枚举所有长度为 <span class="math inline">\(n\)</span> 的状态 <span class="math inline">\(t&#39;\)</span>，然后判定是否满足 <span class="math inline">\(t&#39; \operatorname{bitand} s = t\)</span>，总时间复杂度是 <span class="math inline">\(O(2^{2n})\)</span> 的。考虑优化。</p><p>考虑对于所有 <span class="math inline">\(2^n\)</span> 种状态 <span class="math inline">\(s\)</span>，假如有一种方式能够不重不漏地枚举出它们中每一个的所有子状态，那么总时间复杂度是多少呢？</p><p>把所有数对 <span class="math inline">\((s, t)\)</span> 排列在一起。那么对于 <span class="math inline">\(n\)</span> 位中的每一位 <span class="math inline">\(i\)</span>，枚举每一个 <span class="math inline">\((s&#39;, t&#39;)\)</span>。</p><p>那么存在以下几种可能性：</p><ol type="1"><li><span class="math inline">\({s&#39;}_i=1,{t&#39;}_i=1\)</span>；</li><li><span class="math inline">\({s&#39;}_i=1, {t&#39;}_i=0\)</span>；</li><li><span class="math inline">\({s&#39;}_i=0, {t&#39;}_i = 0\)</span>。</li></ol><p>假如我们用 <span class="math inline">\(o_i=0,1,2\)</span> 分别代表第一、二、三种情况，完全可以用长度为 <span class="math inline">\(n\)</span> 的三进制状态 <span class="math inline">\(o\)</span> 还原数对 <span class="math inline">\((s, t)\)</span>。</p><p>由于这个 <span class="math inline">\((s, t)\)</span> 序列中肯定没有完全相同的元素，也就是说，对于每一个 <span class="math inline">\((s, t)\)</span>，其 <span class="math inline">\(o\)</span> 都各不相同。</p><p>因此，<span class="math inline">\((s, t)\)</span> 的数目不超过 <span class="math inline">\(3^n\)</span>（更准确地，二者值相等）。</p><p>又因为对于 <span class="math inline">\(3^n\)</span> 个 <span class="math inline">\(o\)</span>，每个都可以还原出合法状态，所以总的 <span class="math inline">\((s, t)\)</span> 数目应恰好为 <span class="math inline">\(3^n\)</span>。</p><p>也就是说，假如有一种方式能够不重不漏地枚举出每一个 <span class="math inline">\(s\)</span> 的所有子状态 <span class="math inline">\(t\)</span>，可以做到均摊 <span class="math inline">\(O(3^n)\)</span>。</p><p>接下来探讨这种枚举方式。直接给出结论：</p><pre class="cpp"><code>for (int t = s; t; t = (t - 1) &amp; s);</code></pre><p>其实不难理解。从 <span class="math inline">\(t\)</span> 的定义出发即 <span class="math inline">\(t \operatorname{bitand} s = t\)</span>，重点理解 <span class="math inline">\(t\gets (t - 1)\operatorname{bitand} s\)</span> 这一步。</p><p>分两种情况讨论：</p><ol type="1"><li><p><span class="math inline">\(t-1\)</span> 较 <span class="math inline">\(t\)</span> 发生退位：</p><p>因为只减 <span class="math inline">\(1\)</span>，所以末位一定发生退位。</p><p>如果发生连续退位，一定是因为末端有连续的 <span class="math inline">\(0\)</span>。对于第一个 <span class="math inline">\(1\)</span>（记为第 <span class="math inline">\(j\)</span> 位），已经枚举完了在 <span class="math inline">\(j\)</span> 及更高位固定在当前状态下的所有状态。</p><p>则应有：</p><ul><li>比 <span class="math inline">\(j\)</span> 更高的数位，未受到退位带来的连续影响的位不变；</li><li>第 <span class="math inline">\(j\)</span> 位 <span class="math inline">\(1\to 0\)</span>；</li><li>从第 <span class="math inline">\(j\)</span> 位一直到末位都有 <span class="math inline">\(0\to 1\)</span>。</li></ul><p>此时与 <span class="math inline">\(s\)</span> 进行 <span class="math inline">\(\operatorname{bitand}\)</span>，得到比 <span class="math inline">\(j\)</span> 更高的数位不变、<span class="math inline">\(j\)</span> 位 <span class="math inline">\(1\to 0\)</span>、比 <span class="math inline">\(j\)</span> 更低的数位变为抵着 <span class="math inline">\(s\)</span> 对应数位的最大状态。</p>综上，这是比 <span class="math inline">\(t\)</span> 小的第一个合法状态。</li><li><p><span class="math inline">\(t-1\)</span> 较 <span class="math inline">\(t\)</span> 不发生退位：</p><p>根据上面的讨论，其实就是末位不退位，即末位 <span class="math inline">\(1\to 0\)</span>。显然是比 <span class="math inline">\(t\)</span> 更小的第一个合法状态。</p></li></ol><p>综上，实现了从大到小依次枚举合法状态，因此不重不漏。</p><hr /><h3 id="枚举补集">枚举补集</h3><p>看了几个比较抽象的博客，但是我觉得不如直接把 <span class="math inline">\(s\)</span> 异或一下 <span class="math inline">\(2^n-1\)</span> 然后枚举子集。</p><hr /><h3 id="子集和-高维前缀和">子集和 / 高维前缀和</h3><p>首先理解一下什么是高维前缀和。实际上全称应为边长为 <span class="math inline">\(2\)</span> 的高维空间前缀和。其实就是求所有状态的子集和，运用了前缀和的思想故唤高位前缀和 / 逐维前缀和。</p><p>即在 <span class="math inline">\(n=2\)</span> 的情况下，我们发现我们可以将 <span class="math inline">\(k\)</span> 维前缀和看作在 <span class="math inline">\(k\)</span> 位二进制数上做子集元素求和。显然根据枚举子集有 <span class="math inline">\(3^k\)</span> 的做法，但还能更快。</p><pre class="cpp"><code>std::copy(a.begin(), a.end(), s.begin());for (int i = 0; i &lt; k; ++i)    for (int j = 0; j &lt; l; ++j)        if ((j &gt;&gt; i) &amp; 1)            s[j] += s[j ^ (1 &lt;&lt; i)];</code></pre><p>先枚举 <span class="math inline">\(i\)</span> 是因为使用高维前缀和的题目一般时限卡得比较死，需要使用内存连续访问尽量减小常数。</p><p>对于状态 <span class="math inline">\(j\)</span>，考虑枚举其每一维上的值，则 <span class="math inline">\(s_j=a_j+\sum s_{j\bigoplus 2^i}\)</span>。易发现这可以不重不漏地覆盖所有子集。</p><p>这种思想在一些状态压缩的题目中也有应用，具体见 <a href="/20231117#1">此</a>。</p><h3 id="高维后缀和">高维后缀和</h3><p>从大往小枚举 <span class="math inline">\(j\)</span>，对于 <span class="math inline">\(j\)</span> 中值为 <code>false</code> 的维 <span class="math inline">\(i\)</span>，令 <span class="math inline">\(s_j=a_j+\sum s_{j+2^i}\)</span> 即可。</p><pre class="cpp"><code>std::copy(a.begin(), a.end(), s.begin());for (int i = 0; i &lt; k; ++i)    for (int j = l - 1; ~j; --j)        if (!((j &gt;&gt; i) &amp; 1))            s[j] += s[j ^ (1 &lt;&lt; i)];</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 状压 </tag>
            
            <tag> 高维前缀和 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>五一杂题</title>
      <link href="/20240501/"/>
      <url>/20240501/</url>
      
        <content type="html"><![CDATA[<p><a href="http://222.180.160.110:61235/contest/5169">SAM 杂题</a> + <a href="http://222.180.160.110:61235/contest/5170">NOIPS8</a> + <a href="http://222.180.160.110:61235/contest/5175">周考</a> 选讲。</p><p>看看这个标签列表长度就知道这三天做的题有多杂。</p><span id="more"></span><hr /><h3 id="d.-字符串">D. 字符串</h3><p><a href="http://222.180.160.110:61235/contest/5169/problem/4" class="uri">http://222.180.160.110:61235/contest/5169/problem/4</a></p><p>和 SA 的做法一样，先二分 <span class="math inline">\(s_{c\sim d}\)</span> 的前缀长度 <span class="math inline">\(mid\)</span>，只需 check <span class="math inline">\(s_{c \sim c + mid - 1}\)</span> 是否在 <span class="math inline">\(s_{a\sim b}\)</span> 中出现过。</p><p>考虑怎么快速 check。从 <span class="math inline">\(c\)</span> 一步一步跳到 <span class="math inline">\(c+mid-1\)</span> 显然会起飞，考虑到查询是静态的，我们事先预处理一下然后倍增地跳即可。</p><p>此时只需看当前状态的 <span class="math inline">\(\text {endpos}\)</span> 是否在 <span class="math inline">\([a + mid - 1, b]\)</span> 出现过。</p><p>因为这个不能用最大最小简单代替，所以就到了我们喜闻乐见的线段树合并环节。将插入后的每个单点 <span class="math inline">\(\text {endpos}\)</span> 在权值线段树上更新，在 parent tree 上暴力线段树合并即可。</p><p>之前一直有一个误区，就是觉得线段树合并是一次性的，比如用 A 树和 B 树并出来了 C 树之后，A 树和 B 树的数据就无效了。</p><p>但这显然是很荒谬的，同样因为我们的查询是静态的，所以完全可以用一种类似于可持久化的方式，建立一些新的点表示合并后的信息状态点，一些可以保留的点就保留作儿子。</p><p>在对应的状态上查询即可。</p><details><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;const int maxm = 35;const int maxn = 6e5 + 5;const int maxk = 8e7 + 5;struct _ &#123;    int l, f;    int ne[maxm];     _() &#123;&#125;    _(int l1, int f1): l(l1), f(f1) &#123;&#125;&#125;;_ t[maxn &lt;&lt; 1];int vis[maxn &lt;&lt; 1];int fa[maxn][maxm];int n, la, tot, siz;struct &#123; int l, r, u; &#125; t1[maxk];int tab[maxn &lt;&lt; 1], cnt[maxn &lt;&lt; 1];void Init(void) &#123;    la = tot = 1;    t[1] = _(0, 0);    return;&#125;void ext(int c) &#123;    int p = la, np = ++tot;    la = tot;    t[np] = _(t[p].l + 1, 0);    while (p &amp;&amp; !t[p].ne[c])        t[p].ne[c] = np, p = t[p].f;    if (!p)        t[np].f = 1;    else &#123;        int q = t[p].ne[c];        if (t[q].l == t[p].l + 1)            t[np].f = q;        else &#123;            int nq = ++tot;            t[nq] = _(t[p].l + 1, t[q].f);            std::copy(t[q].ne, t[q].ne + 26, t[nq].ne);            while (p &amp;&amp; t[p].ne[c] == q)                t[p].ne[c] = nq, p = t[p].f;            t[q].f = nq;            t[np].f = nq;        &#125;    &#125;    return;&#125;int now = 0;void ins(int &amp;p, int l, int r, int v) &#123;    if (!p)        p = ++now;    ++t1[p].u;    if (l == r)        return;    int mid = (l + r) &gt;&gt; 1;    if (v &lt;= mid)        ins(t1[p].l, l, mid, v);    else        ins(t1[p].r, mid + 1, r, v);    return;&#125;int ask(int p, int l, int r, int ql, int qr) &#123;    if (ql &lt;= l &amp;&amp; r &lt;= qr)        return t1[p].u;    int mid = (l + r) &gt;&gt; 1, res = 0;    if (ql &lt;= mid)        res = ask(t1[p].l, l, mid, ql, qr);    if (qr &gt; mid)        res += ask(t1[p].r, mid + 1, r, ql, qr);    return res;&#125;int merge(int p, int q, int l, int r) &#123;    if (!p || !q)        return p + q;    int np = ++now, mid = (l + r) &gt;&gt; 1;    t1[np].u = t1[p].u + t1[q].u;    if (l == r) return np;    t1[np].l = merge(t1[p].l, t1[q].l, l, mid);    t1[np].r = merge(t1[p].r, t1[q].r, mid + 1, r);    return np;&#125;int pos[maxn], rt[maxn &lt;&lt; 1];bool check(int x, int a, int b, int c, int d) &#123;    assert(c + x - 1 &gt;= 0);    int p = pos[c + x - 1];    for (int i = siz; ~i; --i)        if (fa[p][i] &amp;&amp; t[fa[p][i]].l &gt;= x)            p = fa[p][i];    return ask(rt[p], 0, n - 1, a + x - 1, b) &gt; 0;&#125;int solve(int a, int b, int c, int d) &#123;    int l = 1, r = std::min(d - c + 1, b - a + 1), res = 0;    while (l &lt;= r) &#123;        int mid = (l + r) &gt;&gt; 1;        if (check(mid, a, b, c, d))            l = mid + 1, res = mid;        else            r = mid - 1;    &#125;    return res;&#125;int main() &#123;#ifdef ONLINE_JUDGE    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr);    std::cout.tie(nullptr);#endif    int m;    std::string s;    std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; s;    Init();    for (int i = 0; i &lt; n; ++i) &#123;        ext(s[i] - &#39;a&#39;);        pos[i] = la;        ins(rt[la], 0, n - 1, i);    &#125;    siz = log(tot) / log(2.0);    for (int i = 1; i &lt;= tot; ++i)        ++cnt[t[i].l];    std::partial_sum(cnt + 1, cnt + tot + 1, cnt + 1);    for (int i = 1; i &lt;= tot; ++i)        tab[cnt[t[i].l]--] = i;    for (int i = 1; i &lt;= tot; ++i) &#123;        int u = tab[i];        fa[u][0] = t[u].f;        for (int j = 1; j &lt;= siz; ++j)            fa[u][j] = fa[fa[u][j - 1]][j - 1];    &#125;    for (int i = tot; i; --i) &#123;        int u = tab[i];        if (t[u].f)            rt[t[u].f] = merge(rt[t[u].f], rt[u], 0, n - 1);    &#125;    while (m--) &#123;        int a, b, c, d;        std::cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;        std::cout &lt;&lt; solve(a - 1, b - 1, c - 1, d - 1) &lt;&lt; &#39;\n&#39;;    &#125;    return 0;&#125;</code></pre></details><hr /><h3 id="f.-security">F. Security</h3><p><a href="http://222.180.160.110:61235/contest/5169/problem/6" class="uri">http://222.180.160.110:61235/contest/5169/problem/6</a></p><p>对我们来说应该是会 D 就会 F 的。所以只打了 10min。</p><p>首先考虑一个大家喜闻乐见的 DFS 求最小字典序。显然地，如果存在和当前位相等的字符，那么优先跳相等字符，进入下一层深搜；否则找到最小的更大字符，然后直接 out。</p><p>此时 SAM 就是我们用来判断 <span class="math inline">\(S_{l, r}\)</span> 中是否存在某状态的工具了。甚至比上一题简单，因为不用写二分和倍增。</p><p>值得注意的是如果 <span class="math inline">\(S_{l, r}\)</span> 包含 <span class="math inline">\(T\)</span> 那么还要在后面随便加一个字符以字典序保证严格大于 <span class="math inline">\(T\)</span>。</p><details><p>值得注意的是因为我写的太丑了以至于在 CF 上会光荣 MLE #46。然后分屏左半边看我代码右半边写的 zwb 却没有。啧。为什么呢。</p><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;const int maxm = 35;const int maxn = 6e5 + 5;const int maxk = 8e7 + 5;struct _ &#123;    int l, f;    int ne[maxm];     _() &#123;&#125;    _(int l1, int f1): l(l1), f(f1) &#123;&#125;&#125;;_ t[maxn &lt;&lt; 1];int vis[maxn &lt;&lt; 1];int fa[maxn][maxm];int n, la, tot, siz;struct &#123; int l, r, u; &#125; t1[maxk];int tab[maxn &lt;&lt; 1], cnt[maxn &lt;&lt; 1];void Init(void) &#123;    la = tot = 1;    t[1] = _(0, 0);    return;&#125;void ext(int c) &#123;    int p = la, np = ++tot;    la = tot;    t[np] = _(t[p].l + 1, 0);    while (p &amp;&amp; !t[p].ne[c])        t[p].ne[c] = np, p = t[p].f;    if (!p)        t[np].f = 1;    else &#123;        int q = t[p].ne[c];        if (t[q].l == t[p].l + 1)            t[np].f = q;        else &#123;            int nq = ++tot;            t[nq] = _(t[p].l + 1, t[q].f);            std::copy(t[q].ne, t[q].ne + 26, t[nq].ne);            while (p &amp;&amp; t[p].ne[c] == q)                t[p].ne[c] = nq, p = t[p].f;            t[q].f = nq;            t[np].f = nq;        &#125;    &#125;    return;&#125;int now = 0;void ins(int &amp;p, int l, int r, int v) &#123;    if (!p)        p = ++now;    ++t1[p].u;    if (l == r)        return;    int mid = (l + r) &gt;&gt; 1;    if (v &lt;= mid)        ins(t1[p].l, l, mid, v);    else        ins(t1[p].r, mid + 1, r, v);    return;&#125;int ask(int p, int l, int r, int ql, int qr) &#123;    if (ql &lt;= l &amp;&amp; r &lt;= qr)        return t1[p].u;    int mid = (l + r) &gt;&gt; 1, res = 0;    if (ql &lt;= mid)        res = ask(t1[p].l, l, mid, ql, qr);    if (qr &gt; mid)        res += ask(t1[p].r, mid + 1, r, ql, qr);    return res;&#125;int merge(int p, int q, int l, int r) &#123;    if (!p || !q)        return p + q;    int np = ++now, mid = (l + r) &gt;&gt; 1;    t1[np].u = t1[p].u + t1[q].u;    if (l == r) return np;    t1[np].l = merge(t1[p].l, t1[q].l, l, mid);    t1[np].r = merge(t1[p].r, t1[q].r, mid + 1, r);    return np;&#125;int pos[maxn], rt[maxn &lt;&lt; 1];bool check(int p, int ch, int l, int r) &#123;    return ask(rt[t[p].ne[ch]], 0, n - 1, l, r) &gt; 0;&#125;bool fun(std::string &amp;res, std::string now, std::string &amp;t, int x, int p, int l, int r) &#123;    // std::cout &lt;&lt; &quot;x = &quot; &lt;&lt; x &lt;&lt; &quot;, now = \&quot;&quot; &lt;&lt; now &lt;&lt; &quot;\&quot;;\n&quot;;    if (x != (int)t.length() &amp;&amp; check(p, t[x] - &#39;a&#39;, l + x, r) &amp;&amp; fun(res, now + t[x], t, x + 1, ::t[p].ne[t[x] - &#39;a&#39;], l, r))        return 1;    for (int i = (x == (int)t.length()) ? 0 : t[x] - &#39;a&#39; + 1; i &lt; 26; ++i) &#123;        if (check(p, i, l + x, r)) &#123;            now += i + &#39;a&#39;;            res = now;            return 1;        &#125;    &#125;    return 0;&#125;std::string solve(std::string &amp;t, int l, int r) &#123;    std::string res;    return fun(res, &quot;&quot;, t, 0, 1, l, r) ? res : &quot;-1&quot;;&#125;int main() &#123;#ifdef ONLINE_JUDGE    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr);    std::cout.tie(nullptr);#endif    int q;    std::string s;    std::cin &gt;&gt; s &gt;&gt; q;    n = (int)s.length();    Init();    for (int i = 0; i &lt; n; ++i) &#123;        ext(s[i] - &#39;a&#39;);        pos[i] = la;        ins(rt[la], 0, n - 1, i);    &#125;    siz = log(tot) / log(2.0);    for (int i = 1; i &lt;= tot; ++i)        ++cnt[t[i].l];    std::partial_sum(cnt + 1, cnt + tot + 1, cnt + 1);    for (int i = 1; i &lt;= tot; ++i)        tab[cnt[t[i].l]--] = i;    for (int i = 1; i &lt;= tot; ++i) &#123;        int u = tab[i];        fa[u][0] = t[u].f;        for (int j = 1; j &lt;= siz; ++j)            fa[u][j] = fa[fa[u][j - 1]][j - 1];    &#125;    for (int i = tot; i; --i) &#123;        int u = tab[i];        if (t[u].f)            rt[t[u].f] = merge(rt[t[u].f], rt[u], 0, n - 1);    &#125;    while (q--) &#123;        int l, r;        std::string t;        std::cin &gt;&gt; l &gt;&gt; r &gt;&gt; t;        std::cout &lt;&lt; solve(t, l - 1, r - 1) &lt;&lt; &#39;\n&#39;;    &#125;    return 0;&#125;</code></pre></details><hr /><h3 id="a.-六出祁山">A. 六出祁山</h3><p><a href="http://222.180.160.110:61235/contest/5170/problem/1" class="uri">http://222.180.160.110:61235/contest/5170/problem/1</a></p><p>是能用贪心拿 60pts 的 DP 题 /tuu</p><p>需要先把暴力的式子写出来。设 <span class="math inline">\(f_{i, j}\)</span> 为将 <span class="math inline">\(i\)</span> 山修改高度为 <span class="math inline">\(j\)</span> 的代价，则：</p><p><span class="math display">\[f_{i, j} = \min\limits_{k\in [j-d, j+d]}\left\{f_{i-1, k}\right\} + |h_i - j|\]</span></p><p>注意到可以单调队列优化。但是这样做复杂度还是 <span class="math inline">\(O(nV)\)</span> 的，根本原因在于第二维这个 <span class="math inline">\(V\)</span> 的状态数太多了。</p><p>根据直觉，最后 <span class="math inline">\(j\)</span> 的值应为 <span class="math inline">\(k+d\)</span> 或 <span class="math inline">\(k-d\)</span> 或 <span class="math inline">\(a_i\)</span>。也就是说，我们可以认为，合法的状态数为所有的 <span class="math inline">\(a_i+x\times d, x\in[-n, n]\)</span>。</p><details><p><summary>正确性证明……</summary></p><p>考虑全部更改完后的结束状态，即最后的最优状态。</p><p>考虑所有山中最矮的山 <span class="math inline">\(i\)</span>，此山的高度要么为 <span class="math inline">\(h_i\)</span>，要么为前一座山的高度 <span class="math inline">\(-d\)</span>，要么为后一座山的高度 <span class="math inline">\(-d\)</span>。</p><p>考虑第二矮的山，以此类推即可。</p></details><p>将第二维的状态集大小减少为 <span class="math inline">\(O(n^2)\)</span>，总时间复杂度为 <span class="math inline">\(O(n^3)\)</span>。</p><details><p>需注意到因为 <span class="math inline">\(a_i+x\times d\)</span> 中的 <span class="math inline">\(x\)</span> 范围为 <span class="math inline">\([-n, n]\)</span> 共 <span class="math inline">\(2\times n\)</span>，所以 DP 数组第二维大小一定要开 <span class="math inline">\(2\times n^2\)</span> 呀！！！</p><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;using ll = long long;const int maxn = 305;const int maxm = 18e4 + 5;const ll inf = 0x3f3f3f3f3f3f3f3f;ll d;int n;ll h[maxn];ll f[maxn][maxm];int main() &#123;    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr);    std::cout.tie(nullptr);    memset(f, 0x3f, sizeof (f));    std::cin &gt;&gt; n &gt;&gt; d;    std::vector&lt;ll&gt; st;    for (int i = 1; i &lt;= n; ++i) &#123;        std::cin &gt;&gt; h[i];        for (ll j = -n; j &lt;= n; ++j)            st.push_back(h[i] + j * d);    &#125;    std::sort(st.begin(), st.end());    st.erase(std::unique(st.begin(), st.end()), st.end());    auto abs = [&amp;](ll x) -&gt; ll &#123; return x &gt;= 0 ? x : -x; &#125;;    f[1][lower_bound(st.begin(), st.end(), h[1]) - st.begin()] = 0;    for (int i = 2; i &lt;= n; ++i) &#123;        int h(1), t(0), p(-1);        static int q[maxm];        for (int j = 0; j &lt; (int)st.size(); ++j) &#123;            while (p &lt; (int)st.size() &amp;&amp; st[p + 1] &lt;= st[j] + d) &#123;                ++p;                while (h &lt;= t &amp;&amp; f[i - 1][p] &lt;= f[i - 1][q[t]])                    --t;                q[++t] = p;            &#125;            while (h &lt;= t &amp;&amp; st[q[h]] &lt; st[j] - d)                ++h;            if (h &lt;= t)                f[i][j] = std::min(inf, f[i - 1][q[h]] + abs(st[j] - ::h[i]));        &#125;    &#125;    ll res = f[n][std::lower_bound(st.begin(), st.end(), h[n]) - st.begin()];    std::cout &lt;&lt; (res == inf ? -1 : res) &lt;&lt; &#39;\n&#39;;    return 0;&#125;</code></pre></details><hr /><h3 id="b.-水淹七军">B. 水淹七军</h3><p><a href="http://222.180.160.110:61235/contest/5170/problem/2" class="uri">http://222.180.160.110:61235/contest/5170/problem/2</a></p><p>容易发现最后连出来一定是没有环的。所以一定是一个 DAG。</p><p>我们知道状态压缩是会遍历到每一种情况的，所以我们可以假设当前的 DAG 就是该状态下的最优。</p><p>至于这个「最优」如何定义就要交给我们了。我们不妨强制认为这个 DAG 是按层序遍历得到的，也就是说连续遍历到的点属于同一层（这里的层是指某点到任意源点的最长路长度）。</p><p>显然只有一组相互之间没有任何连边的点才能组成同一层。不妨枚举点集然后暴力转移，转移时记录路径即可。</p><details><p>注意到在写这玩意儿的时候我还不会 <a href="/2024/05/17/20240517/">状压枚举子集</a>，所以枚举子集的部分可能打得比较抽象。</p><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;const int maxn = 25;const int inf = 0x3f3f3f3f;const int maxm = (1 &lt;&lt; 16) + 5;int n, res;int tag[maxn][maxn];int f[maxn], g[maxn];int solve(std::vector&lt;int&gt;&amp; a) &#123;    static int g[maxn];    static int f[maxm], p[maxm];    int n(a.size()), siz(1 &lt;&lt; n);    std::fill(g, g + n, 0);    std::fill(p, p + siz + 1, 0);    std::fill(f, f + siz + 1, inf);    std::vector&lt;int&gt; st;    for (int i = 0; i &lt; n; ++i) &#123;        for (int j = 0; j &lt; n; ++j) &#123;            if (::g[a[i]] &amp; (1 &lt;&lt; a[j]))                g[i] |= 1 &lt;&lt; j;        &#125;    &#125;    for (int i = 1; i &lt; siz; ++i) &#123;        int now = 0;        for (int j = 0; j &lt; n; ++j) &#123;            if (i &amp; (1 &lt;&lt; j))                now |= g[j];        &#125;        if (!(now &amp; i))            st.push_back(i), f[i] = 0, p[i] = i;        for (auto j : st) &#123;            if (!(i &amp; j)) &#123;                if (f[i | j] &gt; f[i] + 1)                    f[i | j] = f[i] + 1, p[i | j] = j;            &#125;        &#125;    &#125;    int now = siz - 1;    while (now) &#123;        int fa = now ^ p[now];        for (int i = 0; i &lt; n; ++i)            if (p[now] &amp; (1 &lt;&lt; i))                for (int j = 0; j &lt; n; ++j)                    if ((fa &amp; (1 &lt;&lt; j)) &amp;&amp; tag[a[j]][a[i]] == 2)                        tag[a[j]][a[i]] = 1, tag[a[i]][a[j]] = -1;        now = fa;    &#125;    return f[siz - 1];&#125;int find(int x) &#123;    return x == f[x] ? x : f[x] = find(f[x]);&#125;int main() &#123;    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr);    std::cout.tie(nullptr);    int m;    std::cin &gt;&gt; n &gt;&gt; m;    std::vector&lt;std::pair&lt;int, int&gt; &gt; edge;    for (int i = 0; i &lt; n; ++i)        f[i] = i;    while (m--) &#123;        int x, y;        std::cin &gt;&gt; x &gt;&gt; y;        edge.emplace_back(--x, --y);        f[find(x)] = find(y);        g[x] |= 1 &lt;&lt; y;        g[y] |= 1 &lt;&lt; x;        tag[x][y] = tag[y][x] = 2;    &#125;    std::vector&lt;int&gt; ver[maxn];    for (int i = 0; i &lt; n; ++i) &#123;        ver[find(i)].push_back(i);    &#125;    for (int i = 0; i &lt; n; ++i) &#123;        if (f[i] == i)            res = std::max(res, solve(ver[i]));    &#125;    std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;    for (auto i : edge) &#123;        if (tag[i.first][i.second] == 1)            std::cout &lt;&lt; i.first + 1 &lt;&lt; &#39; &#39; &lt;&lt; i.second + 1 &lt;&lt; &#39;\n&#39;;        else std::cout &lt;&lt; i.second + 1 &lt;&lt; &#39; &#39; &lt;&lt; i.first + 1 &lt;&lt; &#39;\n&#39;;    &#125;    return 0;&#125;</code></pre></details><hr /><h3 id="c.-煮酒论英雄">C. 煮酒论英雄</h3><p><a href="http://222.180.160.110:61235/contest/5170/problem/3" class="uri">http://222.180.160.110:61235/contest/5170/problem/3</a></p><p>注意到如果存在串被其他串包含那么直接将其毙掉就可以了。</p><p>对于相互不完全包含的串，我们令 <span class="math inline">\(mx_{i, j, 0/1, 0/1}\)</span> 表示将正序 / 逆序的 <span class="math inline">\(i\)</span> 串拼到正序 / 逆序的 <span class="math inline">\(j\)</span> 串之前，两者共用相接公共部分的串长。这个可以用字符串哈希暴力求。</p><p>用状压枚举拼接顺序，求得最小总串长即可。</p><p>注意如果去掉被包含串后 <span class="math inline">\(n=1\)</span> 时需直接输出串的 border；以及答案需和 <span class="math inline">\(2\)</span> 取 <span class="math inline">\(\max\)</span>。</p><p>实现起来又臭又长，但实际上思路确实非常简单。</p><details><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;using ll = long long;const int p = 131;const int maxn = 25;const int lim = 2e4;const int maxl = 2e4 + 5;const int mod = 998244353;const int inf = 0x3f3f3f3f;const int maxm = (1 &lt;&lt; 16) + 5;int n;std::vector&lt;std::string&gt; s;std::vector&lt;std::vector&lt;ll&gt; &gt; h[2];int main() &#123;#ifdef ONLINE_JUDGE    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr);    std::cout.tie(nullptr);#endif    std::cin &gt;&gt; n;    s.resize(n);    h[0].resize(n);    h[1].resize(n);    static ll base[maxl];    static bool del[maxn];    base[0] = 1;    for (int i = 1; i &lt;= lim; ++i)        base[i] = base[i - 1] * p % mod;    for (int i = 0; i &lt; n; ++i) &#123;        std::cin &gt;&gt; s[i];        h[0][i].resize((int)s[i].length());        h[1][i].resize((int)s[i].length());        ll x = 0;        for (int j = 0; j &lt; (int)s[i].length(); ++j, (x *= p) %= mod)            h[0][i][j] = ((x += s[i][j]) %= mod);        std::reverse(s[i].begin(), s[i].end());        x = 0;        for (int j = 0; j &lt; (int)s[i].length(); ++j, (x *= p) %= mod)            h[1][i][j] = ((x += s[i][j]) %= mod);        std::reverse(s[i].begin(), s[i].end());    &#125;    std::vector&lt;int&gt; tab;    auto gethash = [&amp;](int i, int l, int r, bool t) -&gt; ll &#123;        if (l &gt; r) return 0;        ll res = (h[t][i][r] - (l ? h[t][i][l - 1] : 0) * base[r - l + 1] % mod);        return (res % mod + mod) % mod;    &#125;;    // ll now = 0;    // for (int i = 0; i &lt;= 4; ++i)    //     now = (now * p + s[1][i]) % mod;    // printf(&quot;now = %lld\n&quot;, now);    // now = 0;    // for (int i = 3; i &lt;= 7; ++i)    //     now = (now * p + s[0][i]) % mod;    // printf(&quot;now = %lld\n&quot;, now);    // printf(&quot;# %lld\n&quot;, h[0][0].back());    for (int i = 0; i &lt; n; ++i) &#123;        tab.push_back(i);        for (int j = 0; j &lt; n; ++j)            if (!del[j] &amp;&amp; i != j)                for (int k = 0; k &lt;= ((int)s[j].length()) - ((int)s[i].length()); ++k) &#123;                    // printf(&quot;i = %d, j = %d, k = %d, %lld / %lld\n&quot;, i, j, k,                    //         gethash(i, 0, ((int)s[i].length()) - 1, 0), gethash(j, k, k + ((int)s[i].length()) - 1, 0));                    if (h[0][i].back() == gethash(j, k, k + ((int)s[i].length()) - 1, 0)) &#123;                        tab.pop_back();                        del[i] = 1;                        goto outo;                    &#125;                &#125;        outo: ;    &#125;    n = (int)tab.size();    if (n == 1) &#123;        int border;        for (border = ((int)s[tab[0]].length()) - 1; ~border; --border) &#123;            if (gethash(tab[0], 0, border - 1, 0) == gethash(tab[0], ((int)s[tab[0]].length()) - border, ((int)s[tab[0]].length()) - 1, 0))                break;        &#125;        std::cout &lt;&lt; std::max(2, ((int)s[tab[0]].length()) - border) &lt;&lt; &#39;\n&#39;;    &#125;    else &#123;        static int mx[maxn][maxn][2][2];        for (int i = 0; i &lt; n; ++i)            for (int j = 0; j &lt; n; ++j)                for (int a = 0; a &lt; 2; ++a)                    for (int b = 0; b &lt; 2; ++b)                        for (int k = std::min((int)s[tab[i]].length(), (int)s[tab[j]].length()); ~k; --k) &#123;                            if (gethash(tab[i], ((int)s[tab[i]].length()) - k, ((int)s[tab[i]].length()) - 1, a) ==                                                                                            gethash(tab[j], 0, k - 1, b)) &#123;                                mx[i][j][a][b] = (int)s[tab[j]].length() - k;                                // printf(&quot;%d(%d) + %d(%d) = %d, k = %d\n&quot;, i, a, j, b, mx[i][j][a][b], k);                                break;                            &#125;                        &#125;        static int f[maxm][maxn][2];        memset(f, 0x3f, sizeof (f));        int siz = 1 &lt;&lt; n, res = inf;        f[1][0][0] = (int)s[tab[0]].length();        for (int i = 1; i &lt; siz; ++i)            for (int j = 0; j &lt; n; ++j)                if (i &amp; (1 &lt;&lt; j))                    for (int a = 0; a &lt; 2; ++a) &#123;                        // printf(&quot;f[%d][%d][%d] = %d\n&quot;, i, j, a, f[i][j][a]);                        for (int k = 0; k &lt; n; ++k)                            if (!(i &amp; (1 &lt;&lt; k)))                                for (int b = 0; b &lt; 2; ++b)                                    f[i | (1 &lt;&lt; k)][k][b] = std::min(f[i | (1 &lt;&lt; k)][k][b], f[i][j][a] + mx[j][k][a][b]);                        if (i == siz - 1)                            res = std::min(res, f[i][j][a] - (int)s[tab[0]].length() + mx[j][0][a][0]);                    &#125;                std::cout &lt;&lt; std::max(2, res) &lt;&lt; &#39;\n&#39;;    &#125;    return 0;&#125;</code></pre></details><hr /><h3 id="a.-捏斑马">A. 捏斑马</h3><p><a href="http://222.180.160.110:61235/contest/5175/problem/1" class="uri">http://222.180.160.110:61235/contest/5175/problem/1</a></p><p>我甚至不会（）</p><p>翻转 + 拼接本质上就是首尾相接。我们把字符串整个拼到自己后边儿，然后任取一段长度为 <span class="math inline">\(n\)</span> 的串就可以得到一个倒过来的操作后的字符串。</p><p>注意到可以操作很多次。但是既然我们操作后的串也可以在这个拼接后的串中找到了，那么其实多次操作后的也行。</p><p>所以呢我们在拼接后的串种枚举每一个长度为 <span class="math inline">\(n\)</span> 的串计算答案即可。</p><p>具体怎么算呢？注意到只看开头，也就是在新串中只看离我们当前枚举的右端点最近的那一段，所以我们打一个双指针，看这一段是否在右移后仍然合法，如果非法就把答案区间左端点更新为右端点自己。以及注意到左右端点的距离不能超过 <span class="math inline">\(n\)</span>。</p><details><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;int res;std::string s;int main() &#123;#ifdef ONLINE_JUDGE    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr);    std::cout.tie(nullptr);#endif    std::cin &gt;&gt; s;    int l = 0, r = -1, n = (int)s.length();    char la = 0;    s += s;    while (++r &lt; (int)s.length()) &#123;        if (s[r] == la)            l = r;        while (r - l + 1 &gt; n) ++l;        la = s[r];        res = std::max(res, r - l + 1);    &#125;    std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;    return 0;&#125;</code></pre></details><hr /><h3 id="d.-链状闪电">D. 链状闪电</h3><p><a href="http://222.180.160.110:61235/contest/5175/problem/4" class="uri">http://222.180.160.110:61235/contest/5175/problem/4</a></p><p>莫名其妙且又臭又长的根号做法。</p><p>容易发现一个怪被杀掉了序列就会裂开成两段连续子序列，以及最先被杀掉的怪物一定血量最少。在裂开来的两段连续子序列中也满足此规律，以此类推。</p><p>考虑对序列建立笛卡尔树。令树根为 <span class="math inline">\(rt\)</span>，当前攻击力为 <span class="math inline">\(k\)</span>，记 <span class="math inline">\(t_{x, k}=\left\lceil \dfrac {h_x}k \right\rceil\)</span>，即不考虑其他条件时击倒 <span class="math inline">\(x\)</span> 所需次数。</p><p>那么对于 <span class="math inline">\(rt\)</span> 的左、右儿子 <span class="math inline">\(l,r\)</span>，单考虑这三个怪物所需的总击倒次数，容易发现为 <span class="math inline">\(t_{rt,k}+(t_{l,k}-t_{rt,k})+(t_{r,k}-t_{rt,k})\)</span>。</p><p>对于 <span class="math inline">\(l\)</span> 引导的子树，此时的实际已攻击次数为 <span class="math inline">\(t_{l,k}\)</span>；所以对于 <span class="math inline">\(l\)</span> 的左右儿子 <span class="math inline">\(l&#39;,r&#39;\)</span>，击倒这两个怪物的所需次数为 <span class="math inline">\((t_{l&#39;,k} - t_{l,k})+(t_{r&#39;,k}-t_{l,k})\)</span>。<span class="math inline">\(r\)</span> 引导的子树同理。</p><p>所以我们就可以知道，如果存在树边 <span class="math inline">\(u\to v\)</span>，那么击倒 <span class="math inline">\(v\)</span> 的所需次数为 <span class="math inline">\(t_{v,k}-t_{u,k}\)</span>；特别地，击倒 <span class="math inline">\(rt\)</span> 的所需次数为 <span class="math inline">\(t_{rt,k}\)</span>。</p><p>那么我们就可以通过一次 <span class="math inline">\(O(n)\)</span> 的树上 DFS 对于一个 <span class="math inline">\(k\)</span> 找到答案了。</p><p>那么对于 <span class="math inline">\(2\times 10^4\)</span> 范围内的所有 <span class="math inline">\(k\)</span>，应该怎么办呢？这个时候就要利用 <span class="math inline">\(t\)</span> 的性质进行根号分治了。</p><ul><li><p>对于 <span class="math inline">\(k\le \sqrt {2\times 10^4}\)</span>，我们大可以直接做这么多次 DFS 得到答案；</p></li><li><p>对于 <span class="math inline">\(k&gt;\sqrt {2\times 10^4}\)</span>：</p><p>我们容易发现最终的结果是若干个 <span class="math inline">\(t\)</span> 的值相加减得到的，而每个 <span class="math inline">\(t\)</span> 的权值 <span class="math inline">\(cnt\)</span> 取决于其在笛卡尔树上的儿子个数，有多少就在 <span class="math inline">\(1\)</span> 的基础上减去多少。</p><p>由于 <span class="math inline">\(t\)</span> 实在过于特殊，考虑整除分块 / 数论分块。对于每个 <span class="math inline">\(x\)</span>，对于任意 <span class="math inline">\(k&#39;\in (\sqrt {2\times 10^4}, 2\times 10^4]\)</span>，可能的 <span class="math inline">\(t\)</span> 值只有 <span class="math inline">\(\sqrt {2\times 10^4 }\)</span> 种。计算出对于每个 <span class="math inline">\(t&#39;\)</span>，满足 <span class="math inline">\(\left\lceil \dfrac {h_x}{k&#39;} \right\rceil=t&#39;\)</span> 的 <span class="math inline">\(k&#39;\)</span> 范围，对该范围 <span class="math inline">\(k&#39;\)</span> 的答案区间加上 <span class="math inline">\(t&#39;\times cnt\)</span> 即可，可以使用差分。</p><p>至此，就可以在一次 DFS 内解决这种情况下的问题。</p></li></ul><p>总时间复杂度为 <span class="math inline">\(O(n\sqrt {2\times 10^4})\)</span>。</p><details><p>值得注意的是，我在做这道题的时候并没有意识到自己用到了笛卡尔树，</p><p>所以代码中笛卡尔树的建树部分可能长得特别抽象（</p><p>这里是使用了下标上的 ST 表带 log 地求解了左右儿子。</p><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;const int maxm = 35;const int maxn = 1e5 + 5;using ll = long long;ll res;int n, k, l;int g[maxn][2];int f[maxn][maxm];int a[maxn], t[maxn];ll dif[maxn], cnt[maxn];int ask(int l, int r) &#123;    if (l &gt; r) return 0;    int k = log(r - l + 1) / log(2.0);    return (a[f[l][k]] &lt; a[f[r - (1 &lt;&lt; k) + 1][k]]) ? f[l][k] : f[r - (1 &lt;&lt; k) + 1][k];&#125;void bld(int rt, int l, int r) &#123;    if (rt != l) &#123;        g[rt][0] = ask(l, rt - 1);        bld(g[rt][0], l, rt - 1);    &#125;    if (rt != r) &#123;        g[rt][1] = ask(rt + 1, r);        bld(g[rt][1], rt + 1, r);    &#125;    return;&#125;// k &lt;= sqrt(lim)void DFS(int x, int k, int fa) &#123;    t[x] = (a[x] + k - 1) / k;    res += t[x] - t[fa];    for (int i = 0; i &lt; 2; ++i) &#123;        if (g[x][i])            DFS(g[x][i], k, x);    &#125;    return;&#125;// k &gt; sqrt(lim)void DFS(int x, int fa) &#123;    ++cnt[x];    --cnt[fa];    for (int i = 0; i &lt; 2; ++i) &#123;        if (g[x][i])            DFS(g[x][i], x);    &#125;    int l = k + 1, r;    // 注意这里 i 的范围判定，如果直接写成 i * i &lt;= k 会少计算一些情况    for (int i = 1; (i - 1) * (i - 1) &lt; k; ++i) &#123;        r = l - 1;        l = (a[x] + i - 1) / i;        // fprintf(stderr, &quot;%d: [%d, %d] += %d * %d\n&quot;, a[x], l, r, cnt[x], i);        dif[l] += i * cnt[x], dif[r + 1] -= i * cnt[x];    &#125;    return;&#125;int main() &#123;#ifdef ONLINE_JUDGE    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr);    std::cout.tie(nullptr);#endif    std::cin &gt;&gt; n;    for (int i = 1; i &lt;= n; ++i) &#123;        std::cin &gt;&gt; a[i];        f[i][0] = i;        k = std::max(k, a[i]);    &#125;    for (int j = 1; (1 &lt;&lt; j) &lt;= n; ++j)        for (int i = 1; i + (1 &lt;&lt; j) - 1 &lt;= n; ++i)            f[i][j] = (a[f[i][j - 1]] &lt; a[f[i + (1 &lt;&lt; (j - 1))][j - 1]]) ? f[i][j - 1] : f[i + (1 &lt;&lt; (j - 1))][j - 1];    int rt = ask(1, n);    bld(rt, 1, n);    for (int i = 1; i * i &lt;= k; ++i) &#123;        res = 0;        DFS(rt, i, 0);        std::cout &lt;&lt; res &lt;&lt; &#39; &#39;;        l = i + 1;    &#125;    // fputs(&quot;\n&quot;, stderr);    DFS(rt, 0);    std::partial_sum(dif + 1, dif + k + 1, dif + 1);    for (int i = l; i &lt;= k; ++i)        std::cout &lt;&lt; dif[i] &lt;&lt; &#39; &#39;;    std::cout &lt;&lt; &#39;\n&#39;;    return 0;&#125;</code></pre></details><hr /><h3 id="f.-弹飞绵羊">F. 弹飞绵羊</h3><p><a href="http://222.180.160.110:61235/contest/5175/problem/6" class="uri">http://222.180.160.110:61235/contest/5175/problem/6</a></p><p>很棒可持久化分块，使我 lxl 旋转。</p><p>笑话：赛后 5s 才交上去。然后 A 了。</p><p>我们猜大家都会普通的弹飞绵羊这道题。就是块间暴力跳嘛。</p><p>这里给一个我自己整的简单实现方法。</p><p>我们把分出来的块视作若干个无关联的散块并纳入块集合；对于每一个版本，用一个大小为 <span class="math inline">\(\sqrt n\)</span> 的 <span class="math inline">\(id\)</span> 数组记录每一位置的块在块集合中对应的位置。</p><p>然后该怎么搞怎么搞即可。</p><p>P.S. zwb 坚定不移信仰 lxl 神教于是决定用可持久化平衡树实现可持久化分块，结果当然是因为多了个 <span class="math inline">\(\log\)</span> 被卡飞了，最后气急败坏慌不择路恼羞成怒抄起了我的代码。</p><details><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;const int maxk = 320;const int maxn = 2e5 + 5;class devicer &#123;public:    int l, r;    std::vector&lt;int&gt; ne, u, a;    int &amp;nex(int x);    int &amp;val(int x);&#125;;int id[maxn][maxk];std::vector&lt;devicer&gt; b;int n, q, ty, siz, k, la;int a[maxn], tab[maxn], blk[maxn];void upd(int x, int a, devicer &amp;p) &#123;    if (x + a &gt; n)        p.nex(x) = -1, p.val(x) = 1;    else if (x + a &gt; p.r)        p.nex(x) = x + a, p.val(x) = 1;    else        p.nex(x) = p.nex(x + a), p.val(x) = p.val(x + a) + 1;    // printf(&quot;x = %d, a = %d, r = %d, upd ne[%d] to %d\n&quot;, x, a, p.r, x, p.nex(x));    return;&#125;int main() &#123;#ifdef ONLINE_JUDGE    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr);    std::cout.tie(nullptr);#endif    std::cin &gt;&gt; n &gt;&gt; q &gt;&gt; ty;    siz = sqrt(n);    k = (n + siz - 1) / siz;    b.resize(k);    int la = 0, now = k - 1;    for (auto &amp;i : b)        i.l = la + 1, la = i.r = i.l + siz - 1;    b.back().r = n;    for (int i = 0; i &lt; k; ++i) &#123;        id[0][i] = i;        b[i].a.resize(b[i].r - b[i].l + 1);        b[i].u.resize(b[i].r - b[i].l + 1);        b[i].ne.resize(b[i].r - b[i].l + 1);        for (int j = b[i].l; j &lt;= b[i].r; ++j)            tab[j] = j - b[i].l, blk[j] = i;    &#125;    for (int i = 1; i &lt;= n; ++i)        std::cin &gt;&gt; b[blk[i]].a[tab[i]];    for (int i = n; i; --i)        upd(i, b[blk[i]].a[tab[i]], b[blk[i]]);    int ver = 0;    while (q--) &#123;        int op, pr, x;        static int res = 0;        std::cin &gt;&gt; op &gt;&gt; pr &gt;&gt; x;        if (!ty)            res = 0;        x ^= res;        if (op == 1) &#123;            std::copy(id[pr], id[pr] + k, id[++ver]);            b.push_back(b[id[ver][blk[x]]]);            id[ver][blk[x]] = ++now;            std::cin &gt;&gt; b.back().a[tab[x]];            b.back().a[tab[x]] ^= res;            for (int i = x; i &gt;= b.back().l; --i)                upd(i, b.back().a[tab[i]], b.back());        &#125;        else &#123;            int p = x;            res = 0;            while (~p) &#123;                // printf(&quot;p = %d\n&quot;, p);                res += b[id[pr][blk[p]]].u[tab[p]];                p = b[id[pr][blk[p]]].ne[tab[p]];            &#125;            std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;        &#125;    &#125;    return 0;&#125;int&amp; devicer::nex(int x) &#123;    return ne[tab[x]];&#125;int&amp; devicer::val(int x) &#123;    return u[tab[x]];&#125;</code></pre></details>]]></content>
      
      
      
        <tags>
            
            <tag> DP </tag>
            
            <tag> SAM </tag>
            
            <tag> 状压 </tag>
            
            <tag> 分块 </tag>
            
            <tag> 可持久化 </tag>
            
            <tag> 笛卡尔树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>曼哈顿最小距离生成树</title>
      <link href="/20240206/"/>
      <url>/20240206/</url>
      
        <content type="html"><![CDATA[<p>如题。</p><span id="more"></span><hr /><h3 id="e.-another-minimum-spanning-tree">E. Another Minimum Spanning Tree</h3><p>http://222.180.160.110:61235/contest/4940/problem/5</p><p>曼哈顿最小距离生成树。给定 <span class="math inline">\(n\)</span> 个已知坐标的点，两两之间可连权值为曼哈顿距离的边，需求最小生成树。</p><p>有一引理：以任意一点为顶点的大小为 <span class="math inline">\(\dfrac \pi8\)</span> 、且一条边与坐标轴重合的角覆盖的范围中，与该点曼哈顿距离最小的点才有可能与此点连边。</p><p>概括说来便是以该点为原点建系，沿坐标轴米字划分。</p><details><p><summary>浅证</summary></p><p>首先需认识到，若 <span class="math inline">\(w(x,y)&lt;w(x,z)\)</span> 且 <span class="math inline">\(w(y,z)&lt;w(x,z)\)</span>，则边 <span class="math inline">\(E(x,z)\)</span> 不在最小生成树中。</p><figure><img src="1.png" alt="示意图" /><figcaption>示意图</figcaption></figure><p>考虑有如上 <span class="math inline">\(A,B,C\)</span> 三点。不妨设 <span class="math inline">\(d(A,B)\le d(A,C)\)</span>。其中 <span class="math inline">\(d\)</span> 为曼哈顿距离。</p><p>由图易知 <span class="math inline">\(x_B,y_B,x_C,y_C&gt;0\)</span> 且 <span class="math inline">\(y_B-x_B,y_C-x_C&gt;0\)</span>。讨论 <span class="math inline">\(B\)</span> 与 <span class="math inline">\(C\)</span> 位置关系。下文的 <span class="math inline">\(x,y\)</span> 均相对 <span class="math inline">\(A\)</span> 而言。</p><ul><li><p><span class="math inline">\(x_B&gt;x_C\)</span> 且 <span class="math inline">\(y_B&gt;y_c\)</span>：</p>此时 <span class="math inline">\(d(A,B)&gt;d(B,C)\)</span>，与题设不符，舍去。</li><li><p><span class="math inline">\(x_B&gt;x_C\)</span> 且 <span class="math inline">\(y_B&lt;y_C\)</span>：</p><p>此时 <span class="math inline">\(d(A,B)=x_B+y_B,d(B,C)=x_B-x_C+y_C-y_B,d(A,C)=x_C+y_C\)</span>。由作差法得 <span class="math inline">\(d(B,C)-d(A,C)=x_B-y_B-2\times x_C\)</span>，由 <span class="math inline">\(x_B-y_B&lt;0,x_C&gt;0\)</span>，<span class="math inline">\(d(B,C)&lt;d(A,C)\)</span>。</p>由于 <span class="math inline">\(d(A,B),d(B,C)&lt;d(A,C)\)</span>，故 <span class="math inline">\(A\)</span> 一定不与 <span class="math inline">\(C\)</span> 连边。</li><li><p><span class="math inline">\(x_B&lt;x_C\)</span> 且 <span class="math inline">\(y_B&gt;y_C\)</span>：</p>与上一种情况同理。</li><li><p><span class="math inline">\(x_B&lt;x_C\)</span> 且 <span class="math inline">\(y_B&lt;y_C\)</span>：</p>此时有 <span class="math inline">\(d(A,C)=d(A,B)+d(B,C)\)</span>，则 <span class="math inline">\(A\)</span> 一定不与 <span class="math inline">\(C\)</span> 连边。</li></ul></details><p>如此一来，边数便降低到了 <span class="math inline">\(O(n)\)</span> 水平。</p><p>此外，如何识别每个点周围每 <span class="math inline">\(\dfrac \pi8\)</span> 的最近点便是问题所在。</p><p>由于坐标可以变换，此处仅考虑顶点为 <span class="math inline">\(A\)</span>，始边沿 <span class="math inline">\(y\)</span> 轴正方向，终边沿 <span class="math inline">\(k=1\)</span> 的区域。则对于区域内的点 <span class="math inline">\(B\)</span>，易知 <span class="math inline">\(x_B\geqslant x_A,y_B-y_A\geqslant x_B-x_A\)</span>。</p><p>后一条规则分离变量则有 <span class="math inline">\(y_B-x_B\geqslant y_A-x_A\)</span>，那么问题转化为二维偏序，其中待求为最小 <span class="math inline">\(x_B+y_B\)</span>，可以用树状数组离散解决。</p><p><del>由于边是双向的，将问题在平面任意连续 <span class="math inline">\(\dfrac \pi 2\)</span> 范围内进行四次坐标转化即可。</del></p><p><del>其实并不一定要连续，只要该区域与其旋转一百八十度后的图形的并可以覆盖整个平面即可。这么看来是不是只能连续。</del></p><p>我们会发现旋转 <span class="math inline">\(\dfrac \pi 8\)</span> 这个我们在整数域上做不到啊。所以我们考虑旋转 + 翻折，最后整出来差不多这个图形：</p><figure><img src="2.png" alt="示意图" /><figcaption>示意图</figcaption></figure><p>然后由于我们发现这些点关于 <span class="math inline">\(A\)</span> 的关系（是通过 <span class="math inline">\(A\)</span> 翻折还是旋转得来的）并不中心对称啊，所以呢就要委屈一下写满八个方向了。</p><details><pre class="cpp"><code>namespace XSC062 &#123;using namespace fastIO;const int maxn = 1e5 + 5;struct _ &#123;    int x, y, id;    bool operator&lt; (const _ &amp;q) const &#123;        return y - x &gt; q.y - q.x;    &#125;&#125;;struct __ &#123;    int x, y, w;    __() &#123;&#125;    __(int x1, int y1, int w1) &#123;        if (y1 &lt; x1) x1 ^= y1 ^= x1 ^= y1;        x = x1, y = y1, w = w1;    &#125;    bool operator&lt; (const __ &amp;q) const &#123;        return w == q.w ? x &lt; q.x : w &lt; q.w;    &#125;&#125;;int n;int Bit[maxn]; std::vector&lt;__&gt; e;_ a[maxn], b[maxn];int ls[maxn], f[maxn];int lowbit(int x) &#123; return x &amp; -x; &#125;void upd(int &amp;i, int j) &#123;    if (!i || (j &amp;&amp; b[j].x + b[j].y &lt;= b[i].x + b[i].y)) i = j;    return;&#125;void add(int x, int i) &#123;    for (; x &lt;= n; x += lowbit(x)) upd(Bit[x], i);    return;&#125;int ask(int x) &#123;    int res = 0;    for (; x; x -= lowbit(x)) upd(res, Bit[x]);    return res;&#125; int find(int x) &#123; return x == f[x] ? x : f[x] = find(f[x]); &#125;void merge(int x, int y) &#123; f[find(x)] = find(y); return; &#125;int abs(int x) &#123; return x &gt;= 0 ? x : -x; &#125;void adde(int x, int y) &#123;    if (!x || !y) return;    e.emplace_back(x, y, abs(a[x].x - a[y].x) + abs(a[x].y - a[y].y));    return;&#125;int main() &#123;    read(n);    while (n) &#123;        e.clear();        for (int i = 1; i &lt;= n; ++i) &#123;            read(a[i].x), read(a[i].y), a[i].id = i;            ls[i] = a[i].x, b[i] = a[i], f[i] = i;        &#125;        memset(Bit, 0, sizeof (Bit));        std::sort(b + 1, b + n + 1);        std::sort(ls + 1, ls + n + 1);        for (int i = 1; i &lt;= n; ++i) &#123;            int x = std::lower_bound(ls + 1, ls + n + 1, b[i].x) - ls;            x = n + 1 - x, adde(b[i].id, b[ask(x)].id), add(x, i);        &#125;        memset(Bit, 0, sizeof (Bit));        for (int i = 1; i &lt;= n; ++i) &#123;            b[i].x = a[i].y, b[i].y = a[i].x;            ls[i] = b[i].x, b[i].id = i;        &#125;        std::sort(b + 1, b + n + 1);        std::sort(ls + 1, ls + n + 1);        for (int i = 1; i &lt;= n; ++i) &#123;            int x = std::lower_bound(ls + 1, ls + n + 1, b[i].x) - ls;            assert(x &gt;= 1 &amp;&amp; x &lt;= n);            x = n + 1 - x, adde(b[i].id, b[ask(x)].id), add(x, i);        &#125;        memset(Bit, 0, sizeof (Bit));        for (int i = 1; i &lt;= n; ++i) &#123;            b[i].x = -a[i].x, b[i].y = a[i].y;            ls[i] = b[i].x, b[i].id = i;        &#125;        std::sort(b + 1, b + n + 1);        std::sort(ls + 1, ls + n + 1);        for (int i = 1; i &lt;= n; ++i) &#123;            int x = std::lower_bound(ls + 1, ls + n + 1, b[i].x) - ls;            assert(x &gt;= 1 &amp;&amp; x &lt;= n);            x = n + 1 - x, adde(b[i].id, b[ask(x)].id), add(x, i);        &#125;        memset(Bit, 0, sizeof (Bit));        for (int i = 1; i &lt;= n; ++i) &#123;            b[i].x = -a[i].y, b[i].y = a[i].x;            ls[i] = b[i].x, b[i].id = i;        &#125;        std::sort(b + 1, b + n + 1);        std::sort(ls + 1, ls + n + 1);        for (int i = 1; i &lt;= n; ++i) &#123;            int x = std::lower_bound(ls + 1, ls + n + 1, b[i].x) - ls;            assert(x &gt;= 1 &amp;&amp; x &lt;= n);            x = n + 1 - x, adde(b[i].id, b[ask(x)].id), add(x, i);        &#125;        memset(Bit, 0, sizeof (Bit));        for (int i = 1; i &lt;= n; ++i) &#123;            b[i].x = -a[i].y, b[i].y = -a[i].x;            ls[i] = b[i].x, b[i].id = i;        &#125;        std::sort(b + 1, b + n + 1);        std::sort(ls + 1, ls + n + 1);        for (int i = 1; i &lt;= n; ++i) &#123;            int x = std::lower_bound(ls + 1, ls + n + 1, b[i].x) - ls;            assert(x &gt;= 1 &amp;&amp; x &lt;= n);            x = n + 1 - x, adde(b[i].id, b[ask(x)].id), add(x, i);        &#125;        memset(Bit, 0, sizeof (Bit));        for (int i = 1; i &lt;= n; ++i) &#123;            b[i].x = -a[i].x, b[i].y = -a[i].y;            ls[i] = b[i].x, b[i].id = i;        &#125;        std::sort(b + 1, b + n + 1);        std::sort(ls + 1, ls + n + 1);        for (int i = 1; i &lt;= n; ++i) &#123;            int x = std::lower_bound(ls + 1, ls + n + 1, b[i].x) - ls;            assert(x &gt;= 1 &amp;&amp; x &lt;= n);            x = n + 1 - x, adde(b[i].id, b[ask(x)].id), add(x, i);        &#125;        memset(Bit, 0, sizeof (Bit));        for (int i = 1; i &lt;= n; ++i) &#123;            b[i].x = a[i].x, b[i].y = -a[i].y;            ls[i] = b[i].x, b[i].id = i;        &#125;        std::sort(b + 1, b + n + 1);        std::sort(ls + 1, ls + n + 1);        for (int i = 1; i &lt;= n; ++i) &#123;            int x = std::lower_bound(ls + 1, ls + n + 1, b[i].x) - ls;            assert(x &gt;= 1 &amp;&amp; x &lt;= n);            x = n + 1 - x, adde(b[i].id, b[ask(x)].id), add(x, i);        &#125;        memset(Bit, 0, sizeof (Bit));        for (int i = 1; i &lt;= n; ++i) &#123;            b[i].x = a[i].y, b[i].y = -a[i].x;            ls[i] = b[i].x, b[i].id = i;        &#125;        std::sort(b + 1, b + n + 1);        std::sort(ls + 1, ls + n + 1);        for (int i = 1; i &lt;= n; ++i) &#123;            int x = std::lower_bound(ls + 1, ls + n + 1, b[i].x) - ls;            assert(x &gt;= 1 &amp;&amp; x &lt;= n);            x = n + 1 - x, adde(b[i].id, b[ask(x)].id), add(x, i);        &#125;        std::sort(e.begin(), e.end());        int res = 0;        for (auto i : e) &#123;            if (find(i.x) != find(i.y))                res += i.w, merge(i.x, i.y);        &#125;        static int TimeKeeper = 0;        printf(&quot;Case %d: Total Weight = %d\n&quot;, ++TimeKeeper, res);        read(n);    &#125;    return 0;&#125;&#125; // namespace XSC062</code></pre></details>]]></content>
      
      
      
        <tags>
            
            <tag> 最小生成树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>USACO2024JAN 三组连打</title>
      <link href="/20240131/"/>
      <url>/20240131/</url>
      
        <content type="html"><![CDATA[<p>假的，只连打了两组。Ag 没时间了。日后再补吧。</p><span id="more"></span><p><img src="https://pic.imgdb.cn/item/65b7b152871b83018ac5e7b7.gif" /></p><p>无意中存了题面，但代码大部分因为系统还原消失了，只有文字题解，将就着看吧。</p><hr /><h3 id="cu-a.-majority-opinion">Cu A. Majority Opinion</h3><p><a href="https://www.luogu.com.cn/problem/P10131" class="uri">https://www.luogu.com.cn/problem/P10131</a></p><p><em>省流：任意区间内，若某元素出现个数严格大于区间长度一半，则可将整个区间推平为该值。问最终可以使整个序列被推平为哪些值。</em></p><p>注意到当任意长度 <span class="math inline">\(\ge 2\)</span> 的区间可以被推平为某种元素时，整个数列都可以被推平为该元素。故目标转化为对于某种元素判定是否存在一个可被其推平的区间。</p><p>统计元素个数采用前缀和。令 <span class="math inline">\(s_i\)</span> 表示 <span class="math inline">\(h_i\)</span> 在前 <span class="math inline">\(i\)</span> 项中出现的次数，假设有 <span class="math inline">\([j,i]\)</span> 满足条件，贪心可知 <span class="math inline">\(h_i=h_j\)</span>。</p><p>那么由定义有 <span class="math inline">\(i-j+1&lt;2\times (s_i-s_j+1)\)</span>。典中典，直接移项分离变量。则有 <span class="math inline">\(i-2\times s_i-1&lt;j-2\times s_j\)</span>。令 <span class="math inline">\(t_p\gets p-2\times s_p\)</span>，对于每个 <span class="math inline">\(h\)</span> 记录 <span class="math inline">\(t_j\)</span> 最大值查看是否有 <span class="math inline">\(i,j\)</span> 满足条件即可。</p><h3 id="cu-b.-cannonball">Cu B. Cannonball</h3><p><a href="https://www.luogu.com.cn/problem/P10132" class="uri">https://www.luogu.com.cn/problem/P10132</a></p><p><em>省流：有 <span class="math inline">\(N\)</span> 个格子，从 <span class="math inline">\(s\)</span> 格子开始以 <span class="math inline">\(1\)</span> 为初始能量向右跳，跳一步的距离为能量大小。格子分两种，一种经过加一定能量并反向，另一种若当前能量大于一定值则可永久摧毁，问跳出范围或无限长时间后可摧毁格子个数。</em></p><p>不难发现若忽略增加能量为 <span class="math inline">\(0\)</span> 的跳板则每经过一个跳板可跳距离增加 <span class="math inline">\(1\)</span>，最多增加到 <span class="math inline">\(n\)</span>，否则会跳出去。</p><p>注意到调和级数，故直接模拟跳的过程。唯一导致时间无限的情况是存在相邻的增加能量为 <span class="math inline">\(0\)</span> 的跳板，但其实它具体是什么并不重要，反正我们跳的次数严格大于调和级数后就可以认为进入死循环，直接结束模拟即可。我这里嫌麻烦直接拿了 <span class="math inline">\(2\times 10^8\)</span> 作阈值。</p><h3 id="cu-c.-balancing-bacteria">Cu C. Balancing Bacteria</h3><p><a href="https://www.luogu.com.cn/problem/P10133" class="uri">https://www.luogu.com.cn/problem/P10133</a></p><p><em>省流：定义一次操作为选取一个整数 <span class="math inline">\(\Delta\le N\)</span>，并从 <span class="math inline">\(N\)</span> 到 <span class="math inline">\(1\)</span>，令 <span class="math inline">\(a_i\gets a_i+\Delta\)</span> 并令 <span class="math inline">\(\Delta\)</span> 向 <span class="math inline">\(0\)</span> 靠近 <span class="math inline">\(1\)</span>，<span class="math inline">\(\Delta=0\)</span> 时停止。问令所有 <span class="math inline">\(a_i=0\)</span> 所需最少操作次数。</em></p><p>挺有意思的思维题，首先需要进行一个思维转化。<span class="math inline">\(\Delta\le N\)</span> 是一个利于解题的限制，这意味着我们想让任何一个 <span class="math inline">\(a_i\)</span> 改变 <span class="math inline">\(1\)</span> 而不影响到之前的值，从让 <span class="math inline">\(a_1\gets 0\)</span> 入手，进行一次操作后每个 <span class="math inline">\(a_i\)</span> 分到的 <span class="math inline">\(\Delta\)</span> 应依次加 1 或依次减 1。则差分数组为 <span class="math inline">\(0\)</span> 后跟着一截 <span class="math inline">\(1\)</span> 是理想状态。中间每有一项不满足规律都会带来额外的操作次数。</p><p>归纳为差分数组的差分数组绝对值之和即为答案。</p><hr /><h3 id="ag-a.-cowmpetency">Ag A. Cowmpetency</h3><p><a href="https://www.luogu.com.cn/problem/P10134" class="uri">https://www.luogu.com.cn/problem/P10134</a></p><p><em>省流：有若干条限制，每条形如 <span class="math inline">\(\max\limits_{i=1}^{a_h-1}\{A_i\}=\max\limits_{i=1}^{a_j}\{A_i\}\)</span> 且 <span class="math inline">\(A_{a_h}&gt;\max\limits_{i=1}^{a_h-1}\{A_i\}\)</span>，部分数已知，构造出符合条件且字典序最小的序列。</em></p><p>是本场最难题吧，但也没啥卡的。画个线段图容易发现，若将 <span class="math inline">\([a,h)\)</span> 视作一条线段，那么除非 <span class="math inline">\(h\)</span> 相同，否则两条线段不能有交集。不然的话就无解。以及如果存在不满足条件的定值也显然无解。</p><p>从前往后看每个 <span class="math inline">\(h\)</span> 并尝试赋值，对于每个 <span class="math inline">\(1\sim a\)</span> 记录一个需要满足的最大值数值，按照此数值从后往前填空格。</p><p>填完过后扫一遍看看是不是全部合法，可以证明若此时不合法则无解。</p><h3 id="ag-b.-potion-farming">Ag B. Potion Farming</h3><p><a href="https://www.luogu.com.cn/problem/P10135" class="uri">https://www.luogu.com.cn/problem/P10135</a></p><p><em>省流：一棵树，每个点上有若干个物品，对于每条从根到叶子的简单路径，可以选择路径上的一个物品，每个物品只能被选一次，问最多可选物品数。</em></p><p>如果一个点引导的子树下所有叶子有没有分配到的，就可以把这个点的物品分配给该叶子。</p><p>跑一个树形 DP 即可。</p><details><pre class="cpp"><code>namespace XSC062 &#123;using namespace fastIO;const int maxn = 1e5 + 5;int n, x, y;int cnt[maxn];std::vector&lt;int&gt; g[maxn];int a[maxn], f[maxn], p[maxn];int min(int x, int y) &#123;    return x &lt; y ? x : y;&#125;void DFS(int x, int fa) &#123;    if ((int)g[x].size() == 1)        cnt[x] = 1;    for (auto i : g[x]) &#123;        if (i == fa) continue;        DFS(i, x);        f[x] += f[i];        cnt[x] += cnt[i];    &#125;    if (f[x] &lt; cnt[x])        f[x] = min(f[x] + a[x], cnt[x]);    return;&#125;void add(int x, int y) &#123;    g[x].push_back(y);    return;&#125;int main() &#123;    read(n);    for (int i = 1; i &lt;= n; ++i) read(p[i]);    for (int i = 1; i &lt; n; ++i) &#123;        read(x), read(y);        add(x, y), add(y, x);    &#125;    int tot = 0;    for (int i = 2; i &lt;= n; ++i)        tot += ((int)g[i].size() == 1);    for (int i = 1; i &lt;= tot; ++i) ++a[p[i]];    DFS(1, -1);    print(f[1], &#39;\n&#39;);    return 0;&#125;&#125; // namespace XSC062</code></pre></details><h3 id="ag-c.-cowlendar">Ag C. Cowlendar</h3><p><a href="https://www.luogu.com.cn/problem/P10136" class="uri">https://www.luogu.com.cn/problem/P10136</a></p><p><em>省流：对于给定的序列 <span class="math inline">\(a\)</span>，找出所有满足 <span class="math inline">\(a_i\bmod L\)</span> 的值的种类最多为 3 的 <span class="math inline">\(L\)</span>。</em></p><p>也是挺有意思的数学题了。若将 <span class="math inline">\(a_i\)</span> 按照模 <span class="math inline">\(L\)</span> 的情况分组，则对于任意一个 <span class="math inline">\(a_i\)</span>，在 <span class="math inline">\((a_i,a_i+L)\)</span> 中最多包含两个分别来自其余两组的数。</p><p>对于去重后 <span class="math inline">\(n&gt;3\)</span> 的情况，由鸽巢得必定有两个数可分为一组。故我们枚举可能的组间间隔，而可能的 <span class="math inline">\(L\)</span> 就是这些间隔的因数。</p><p>由上面我们推出一个合法组间间隔中最多间隔三个数，我们将所有 <span class="math inline">\(a_{i+3}-a_i\)</span>、<span class="math inline">\(a_{i+2}-a_i\)</span> 和 <span class="math inline">\(a_{i+1}-a_i\)</span> 纳入考虑范围即可。对于所有可能的 <span class="math inline">\(L\)</span>，直接 <span class="math inline">\(O(n)\)</span> 跑一个 <code>check</code> 检查是否合法。</p><p>因子个数照理来说是 <span class="math inline">\(\sqrt{V}\times n\)</span> 级别的，但是实测 <span class="math inline">\(n\)</span> 最多只有一百多。估计是因为 <span class="math inline">\(n\)</span> 太大就很难构造出更多的合法解吧。</p><details><pre class="cpp"><code>#define int long longnamespace XSC062 &#123;using namespace fastIO;const int maxn = 1e4 + 5;const int maxm = 3e4 + 5;std::set&lt;int&gt; u;int n, res, mn, tot;int a[maxn], b[maxm];bool check(int x) &#123;    int l1 = 0, l2 = 0, l3 = 0;    for (int i = 1; i &lt;= n; ++i) &#123;        if (l1 == 0) l1 = a[i];        else if (x &amp;&amp; (a[i] - l1) % x == 0) l1 = a[i];        else if (l2 == 0) l2 = a[i];        else if (x &amp;&amp; (a[i] - l2) % x == 0) l2 = a[i];        else if (l3 == 0) l3 = a[i];        else if (x &amp;&amp; (a[i] - l3) % x == 0) l3 = a[i];        else return 0;    &#125;    return 1;&#125;int main() &#123;    read(n);    for (int i = 1; i &lt;= n; ++i) &#123;        read(a[i]);        if (!mn || a[i] / 4 &lt; mn) mn = a[i] / 4;    &#125;    std::sort(a + 1, a + n + 1);    n = std::unique(a + 1, a + n + 1) - a - 1;    if (check(0)) &#123;        print(mn * (mn + 1) / 2, &#39;\n&#39;);        return 0;    &#125;    for (int i = 2; i &lt;= n; ++i) &#123;        b[++tot] = a[i] - a[i - 1];        if (i &gt;= 3) b[++tot] = a[i] - a[i - 2];        if (i &gt;= 4) b[++tot] = a[i] - a[i - 3];    &#125;    std::sort(b + 1, b + tot + 1);    tot = std::unique(b + 1, b + tot + 1) - b - 1;    for (int i = 1; i &lt;= tot; ++i) &#123;        if (check(b[i])) &#123;            for (int j = 1; j * j &lt;= b[i]; ++j) &#123;                if (b[i] % j == 0)                    u.insert(j), u.insert(b[i] / j);            &#125;        &#125;    &#125;    for (auto i : u) &#123;        if (i &gt; mn) break;        res += i;    &#125;    print(res, &#39;\n&#39;);    return 0;&#125;&#125; // namespace XSC062#undef int</code></pre><p></deteails></p>]]></content>
      
      
      
        <tags>
            
            <tag> 鸽巢原理 </tag>
            
            <tag> 调和级数 </tag>
            
            <tag> 差分 </tag>
            
            <tag> 思维 </tag>
            
            <tag> 树形 DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我超！雀！</title>
      <link href="/20240125/"/>
      <url>/20240125/</url>
      
        <content type="html"><![CDATA[<p>Solution to <a href="http://222.180.160.110:61235/contest/4813/problem/1">PKUSC2022 Mahjong</a>。</p><span id="more"></span><hr /><p><a href="https://www.bilibili.com/video/BV1JB4y1R7AP/" class="uri">https://www.bilibili.com/video/BV1JB4y1R7AP/</a></p><p>这里是 PKUSC 当时的讲解视频。听说可以证明本题一定有 <span class="math inline">\(\le 5\)</span> 的解。好神奇。</p><hr /><p>就比如说我们爆搜，<span class="math inline">\(9^4\times 13^4\)</span> 这个显然干不动对吧，所以我们考虑反过来 DP。</p><p>我们先把字符串转化成计数数组，就是每种牌有多少片。不妨将 <code>1m ~ 9s</code> 编号为 <span class="math inline">\(1\sim 27\)</span>，记 <span class="math inline">\(g_i\)</span> 为编号为 <span class="math inline">\(i\)</span> 的牌的数量。</p><p>为什么我们觉得 DP 不好打呢？因为换牌操作可以将两个毫不相干的牌的数量更改，不好记录状态。我们不妨直接将换牌拆成 <em>丢弃一张牌</em> 和 <em>借取令一张牌</em> 两个操作。很显然这两个操作数量是一样的，因为我们的牌数量自始至终不变。</p><p>对于比较简单的对子作为终局的情况，我们只关心对数是否为 <span class="math inline">\(7\)</span>，所以设计状态：<span class="math inline">\(dp_{i,j}\)</span> 表示前 <span class="math inline">\(i\)</span> 张牌中凑出 <span class="math inline">\(j\)</span> 个对子的最小代价。</p><p>那么就分 <em>把当前牌丢一些 / 借一些拿去组对子</em> 和 <em>直接丢弃当前牌</em> 两种方案。因为丢 / 借的数量是不确定的，直接 <code>abs</code> 一下就好。刷表，有：</p><p><span class="math display">\[dp_{i+1,j}=dp_{i,j}+g_{i+1}\\dp_{i+1,j+1}=dp_{i,j}+|g_{i+1}-2|\]</span></p><p>最后我们的答案就来自 <span class="math inline">\(dp_{27,7}\)</span>。然后注意这里我们的终局是 14 张牌 <del>你能秒我</del>，但起手只有 13 张牌，所以其实会有一个额外的借牌操作，假设答案为 <span class="math inline">\(x\)</span>，那么其实 <span class="math inline">\(dp_{27,7}=2\times x+1\)</span>。</p><hr /><p>有了对子的铺垫，面子手其实也还好。我们需要考虑的是对子和面子的个数。</p><p>但是有个问题，对子只用借 / 丢当前花色，但面子可能是会借 / 丢下一个 / 下下一个花色的。</p><p>所以干脆全部记录到状态里，令 <span class="math inline">\(f_{i,j,k,a,b}\)</span> 表示当前在第 <span class="math inline">\(i\)</span> 个花色，凑成了 <span class="math inline">\(j\)</span> 个面子，<span class="math inline">\(k\)</span> 个对子，需要 <span class="math inline">\(a\)</span> 个 <span class="math inline">\(i+1\)</span>，<span class="math inline">\(b\)</span> 个 <span class="math inline">\(i+2\)</span>。注意因为表示丢借有负数不太容易，不如就直接设成需要的数量了。</p><p>因为这个需要数量只是前面的花色对当前花色的需要 <span class="math inline">\(a\)</span>，我们还要满足当前花色 <strong>自身</strong> 的需要 <span class="math inline">\(now\)</span>（也就是说当前花色一共需要 <span class="math inline">\(a+now\)</span> 张）。注意这里 <span class="math inline">\(a\)</span> 张全部都是拿去借给前面的花色用的，自己不能用。</p><ul><li><p>对于 <span class="math inline">\(k=0\)</span> 且 <span class="math inline">\(now\ge 2\)</span>，此时可以从 <span class="math inline">\(now\)</span> 里拿两张出来凑对子，剩下的 <span class="math inline">\(now - 2\)</span> 因为肯定 <span class="math inline">\(\le 2\)</span>，所以只能全部拿去凑顺子。所以有：</p><span class="math display">\[f_{i+1,j+now-2,1,b+now-2, now-2}=f_{i,j,0,a,b}+|g_{i+1}-(a+now)|\]</span></li><li><p>对于 <span class="math inline">\(now\ge 3\)</span>，拿三张凑一面。有：</p><span class="math display">\[f_{i+1,j+now-2,k,b+now-3,now-3}=f_{i,j,0,a,b}+|g_{i+1}-(a+now)|\]</span></li><li><p>对于 <span class="math inline">\(now\ne 0\)</span>，可以凑顺子，有：</p><p><span class="math display">\[f_{i+1,j+now,k,b+now,now}=f_{i,j,0,a,b}+|g_{i+1}-(a+now)|\]</span></p><p>注意不能跨花色借牌，也就是不能让 <span class="math inline">\(i=8/9/17/18/26/27\)</span>。</p></li></ul><p>答案就是 <span class="math inline">\(f_{27,4,1,0,0}\)</span>。</p><hr /><p>然后这两个情况取一个 <span class="math inline">\(\min\)</span> 就是答案。</p><details><pre class="cpp"><code>namespace XSC062 &#123;using namespace fastIO;using std::cin;using std::getline;using str = std::string;int g[30];int dp[30][15];str sm, sp, ss;int f[30][7][2][7][7];int abs(int x) &#123; return x &gt;= 0 ? x : -x; &#125;int min(int x, int y) &#123; return x &lt; y ? x : y; &#125;void upd(int &amp;x, int y) &#123; x = min(x, y); return; &#125;int main() &#123;    getline(cin, sm, &#39;m&#39;);    getline(cin, sp, &#39;p&#39;);    getline(cin, ss, &#39;s&#39;);    for (auto i : sm) ++g[i - &#39;0&#39;];    for (auto i : sp) ++g[i - &#39;0&#39; + 9];    for (auto i : ss) ++g[i - &#39;0&#39; + 18];    // 打对子    memset(dp, 0x3f, sizeof (dp));    dp[0][0] = 0;    for (int i = 0; i &lt; 27; ++i) &#123;        for (int j = 0; j &lt;= 7; ++j) &#123;            if (dp[i][j] == 0x3f3f3f3f) continue;            upd(dp[i + 1][j], dp[i][j] + g[i + 1]);            upd(dp[i + 1][j + 1], dp[i][j] + abs(g[i + 1] - 2));        &#125;    &#125;    // 打飞机    memset(f, 0x3f, sizeof (f));    f[0][0][0][0][0] = 0;    for (int i = 0; i &lt; 27; ++i)    for (int j = 0; j &lt;= 4; ++j)    for (int k = 0; k &lt;= 1; ++k)    for (int a = 0; a &lt;= 4; ++a)    for (int b = 0; b &lt;= 4; ++b) &#123;        if (i % 9 == 8 &amp;&amp; b) continue;        if (i % 9 == 0 &amp;&amp; a + b) continue;        for (int now = 0; now &lt;= 4; ++now) &#123; // 对当前的额外需求             if (a + now &gt; 4) continue;            int v = f[i][j][k][a][b] + abs(g[i + 1] - (a + now));            if (j + now &lt;= 4 &amp;&amp; b + now &lt;= 4) // 直接硬配顺子                 upd(f[i + 1][j + now][k][b + now][now], v);            if (now &gt;= 2 &amp;&amp; !k &amp;&amp; j + now - 2 &lt;= 4 &amp;&amp; b + now - 2 &lt;= 4) // 借两个去凑对子                 upd(f[i + 1][j + now - 2][1][b + now - 2][now - 2], v);            if (now &gt;= 3 &amp;&amp; j + now - 2 &lt;= 4 &amp;&amp; b + now - 3 &lt;= 4) // 借两个去凑三不带                 upd(f[i + 1][j + now - 2][k][b + now - 3][now - 3], v);        &#125;    &#125;    // 拿来借走会算两次     print(min(dp[27][7], f[27][4][1][0][0]) / 2, &#39;\n&#39;);    return 0;&#125;&#125; // namespace XSC062</code></pre></details>]]></content>
      
      
      
        <tags>
            
            <tag> DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>杂题别选谈了</title>
      <link href="/20240111/"/>
      <url>/20240111/</url>
      
        <content type="html"><![CDATA[<p>Solution to <a href="http://222.180.160.110:61235/contest/4665/problem/2">SP4060 Game with Probability Problem</a>。</p><span id="more"></span><hr /><p>设 <span class="math inline">\(f_i,g_i\)</span> 分别表示还剩 <span class="math inline">\(i\)</span> 个的时候轮到 Alice 和 Bob 时 <strong>Alice</strong> 分别的胜率。</p><p>概率经典倒推。那么显然有 <span class="math inline">\(f_0=0,g_0=1\)</span>。</p><p>然后就是一个分讨，讨论这个人想要正面还是反面。很显然，对于同样的剩余棋子数，两个人先手的情况对于这颗棋子的喜爱程度是一样的。也就是说，要么都想要，要么都不想要。</p><p>什么时候想要呢？拿掉过后自己胜率更大，也就是 <span class="math inline">\(g_{i-1}&gt;f_{i-1}\)</span>。此时有：</p><p><span class="math display">\[f_i=(1-p)\times g_i+p\times g_{i-1}\\g_i=(1-q)\times f_i+q\times f_{i-1}\]</span></p><p>发现是互相影响的，这个时候先不要着急怀疑自己推错了，因为我们这里有两个未知数，又刚好有两个方程，暴解一下就有：</p><p><span class="math display">\[f_i=\dfrac {(1-p)\times q\times f_{i-1}+p\times g_{i-1}}{1-(1-p)(1-q)}\\g_i=\dfrac {(1-q)\times p\times g_{i-1}+q\times f_{i-1}}{1-(1-p)(1-q)}\]</span></p><p>然后 <span class="math inline">\(g_{i-1}&lt;f_{i-1}\)</span> 的情况也差不多，把拿的概率和不拿的概率换一下：</p><p><span class="math display">\[f_i=p\times g_i+(1-p)\times g_{i-1}\\g_i=q\times f_i+(1-q)\times f_{i-1}\]</span></p><p>解方程组有：</p><p><span class="math display">\[f_i=\dfrac {(1-q)\times p\times f_{i-1}+(1-p)\times g_{i-1}}{1-p\times q}\\g_i=\dfrac {(1-p)\times q\times g_{i-1}+(1-q)\times f_{i-1}}{1-p\times q}\]</span></p><p>然后就可以开始 DP 了。最后的答案就是 <span class="math inline">\(f_{\min(n,1000)}\)</span>。</p><p>还有个问题就是 <span class="math inline">\(n\)</span> 特别大然后这个看起来也不太能矩乘，但是这个 DP 式有个好处是它的增长趋势是指数级的，所以我们 DP 到 <span class="math inline">\(1000\)</span> 就可以了。</p><details><pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;namespace XSC062 &#123;const int maxn = 1e3 + 5;using db = double;db p, q;int T, n;db f[maxn], g[maxn];int min(int x, int y) &#123;    return x &lt; y ? x : y;&#125;int main() &#123;    scanf(&quot;%d&quot;, &amp;T);    while (T--) &#123;        scanf(&quot;%d %lf %lf&quot;, &amp;n, &amp;p, &amp;q);        f[0] = .0, g[0] = 1.0;        for (int i = 1; i &lt;= n &amp;&amp; i &lt;= 1000; ++i) &#123;            if (g[i - 1] &gt; f[i - 1]) &#123;                f[i] = ((1 - p) * q * f[i - 1] + p * g[i - 1]) / (1 - (1 - p) * (1 - q));                g[i] = ((1 - q) * p * g[i - 1] + q * f[i - 1]) / (1 - (1 - p) * (1 - q));            &#125;            else &#123;                f[i] = ((1 - q) * p * f[i - 1] + (1 - p) * g[i - 1]) / (1 - p * q);                g[i] = ((1 - p) * q * g[i - 1] + (1 - q) * f[i - 1]) / (1 - p * q);            &#125;        &#125;        printf(&quot;%.6lf\n&quot;, f[min(n, 1000)]);    &#125;    return 0;&#125;&#125; // namespace XSC062int main() &#123;    XSC062::main();    return 0;&#125;</code></pre></details>]]></content>
      
      
      
        <tags>
            
            <tag> DP </tag>
            
            <tag> 概率期望 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>杂题全谈</title>
      <link href="/20240106/"/>
      <url>/20240106/</url>
      
        <content type="html"><![CDATA[<p>想不到好标题了。</p><span id="more"></span><p>有句话怎么说来着，罗马不是一天建成的，是一天天建成的。</p><p>还有什么，Do in Rome as the Romans’ do，还有一句，All roads leads to Rome。</p><hr /><h3 id="a.-连续的零-zero">A. 连续的零 zero</h3><p><a href="http://222.180.160.110:61235/contest/4647/problem/1" class="uri">http://222.180.160.110:61235/contest/4647/problem/1</a></p><p>做个前缀和，看看任意一个长度为 <span class="math inline">\(k\)</span> 的区间中有几个 <span class="math inline">\(1\)</span>。复杂度 <span class="math inline">\(O(n)\)</span>。</p><details><pre class="cpp"><code>namespace XSC062 &#123;using namespace fastIO;const int maxn = 5e5 + 5;const int inf = 0x3f3f3f3f;int n, m, res = inf;int a[maxn], s[maxn];int min(int x, int y) &#123;    return x &lt; y ? x : y;&#125;int main() &#123;    scanf(&quot;%d %d&quot;, &amp;n, &amp;m);    for (int i = 1; i &lt;= n; ++i) &#123;        scanf(&quot;%1d&quot;, &amp;a[i]);        s[i] = s[i - 1] + a[i];        if (i &gt;= m)            res = min(res, s[i] - s[i - m]);    &#125;    print(res, &#39;\n&#39;);    return 0;&#125;&#125; // namespace XSC062</code></pre></details><hr /><h3 id="b.-反回文串-anti">B. 反回文串 anti</h3><p><a href="http://222.180.160.110:61235/contest/4647/problem/2" class="uri">http://222.180.160.110:61235/contest/4647/problem/2</a></p><p>当 <span class="math inline">\(n\)</span> 为奇时，中间的元素一定和自己相等，故无解。</p><p>当数量最多的一个字符个数超过 <span class="math inline">\(\dfrac n2\)</span> 时，由鸽巢得无解。</p><p>剩下的情况一定有解。</p><details><p><summary>证明</summary></p><p>可以找到一种合法的构造方式。我们列出一个列数为 <span class="math inline">\(2\)</span>，行数为 <span class="math inline">\(\dfrac n2\)</span> 的表格，将所有相同字母排列在一起，按照从左到右，从上到下的方式将字母填入表格，最后将第 <span class="math inline">\(i\)</span> 行第一列的字母填入 <span class="math inline">\(a_i\)</span>，第 <span class="math inline">\(i\)</span> 行第二列的字母填入 <span class="math inline">\(a_{n-i+1}\)</span>，即可完成构造。</p><p>一种字母只在第一列或第二列出现当然合法，如果从第一列持续到第二列，因为任意字母出现次数不超过 <span class="math inline">\(\dfrac n2\)</span> 次，所以同一行的两列不会出现同一种字母。</p><p>这叫什么，有字证明。</p><p><del>感觉可以拿去出一道类似于「找到字符串字典序最小的反回文串」之类的小水题</del></p></details><p>然后现在我们知道有解了，怎么找到最优解呢。</p><p>比如有一组 <span class="math inline">\((a_i,a_{n-i+1})=(\texttt a, \texttt a)\)</span>，还有一组 <span class="math inline">\((a_j, a_{n-j+1})=(\texttt b, \texttt b)\)</span>，那我们直接把 <span class="math inline">\(a_i\)</span> 和 <span class="math inline">\(a_j\)</span> 交换，皆大欢喜。</p><p>这就说明我们需要把值不相等的非法 <span class="math inline">\(a_i\)</span> 与 <span class="math inline">\(a_j\)</span> 配对。</p><p>然后我们就可以沿用证明中的构造方式，分组配对，一定最优，每组代价为 <span class="math inline">\(1\)</span>。</p><p>同一行两个值 <span class="math inline">\(v\)</span> 相等，因为已经最优了，所以不能再在非法串中寻找答案。应该找合法对中某个值交换，每组代价为 <span class="math inline">\(2\)</span>。具体和谁交换我们不用担心，只要找到一组 <span class="math inline">\((a_i,a_{n-i+1})\)</span> 满足 <span class="math inline">\(a_i\ne v\)</span> 且 <span class="math inline">\(a_{n-i+1}\ne v\)</span> 就可以了，然后我们又知道 <span class="math inline">\(v\)</span> 的个数 <span class="math inline">\(\ne \dfrac n2\)</span>，假设 <span class="math inline">\(\dfrac n2\)</span> 对中每队都有至少一个 <span class="math inline">\(v\)</span>，由于当前这一对有两个相同的 <span class="math inline">\(v\)</span>，那么 <span class="math inline">\(v\)</span> 的个数就会大于 <span class="math inline">\(\dfrac n2\)</span>，矛盾了，所以一定能找到。</p><p>对于非法总对数是奇数的情况，我们要钦定一个非法对强制让其和合法对交换，贪心一下取非法对数量最多的 <span class="math inline">\(v\)</span> 的某一对最优。</p><details><pre class="cpp"><code>namespace XSC062 &#123;using namespace fastIO;const int maxm = 35;const int maxn = 2e5 + 5;char s[maxn];int cnt[maxm], p[maxn];int T, n, tot, res, now;int main() &#123;    scanf(&quot;%d&quot;, &amp;T);    while (T--) &#123;        tot = 0;        scanf(&quot;%d %s&quot;, &amp;n, s + 1);        if (n &amp; 1) &#123;            puts(&quot;-1&quot;);            continue;        &#125;        memset(cnt, 0, sizeof (cnt));        for (int i = 1; i &lt;= n; ++i)            ++cnt[s[i] - &#39;a&#39; + 1];        for (int i = 1; i &lt;= 26; ++i) &#123;            if (cnt[i] * 2 &gt; n) &#123;                puts(&quot;-1&quot;);                goto noSol;            &#125;        &#125;        memset(cnt, 0, sizeof (cnt));        for (int i = 1; i * 2 &lt;= n; ++i) &#123;            if (s[i] == s[n - i + 1])                ++cnt[s[i] - &#39;a&#39; + 1], ++tot;        &#125;        std::sort(cnt + 1, cnt + 27,                    std::greater&lt;int&gt;());        res = now = 0;        if (tot &amp; 1) &#123;            res = 1, --cnt[1];            std::sort(cnt + 1, cnt + 27,                        std::greater&lt;int&gt;());        &#125;        for (int i = 1; i &lt;= 26; ++i) &#123;            while (cnt[i]--) &#123;                if (++now &gt; tot / 2) &#123;                    if (i == p[now - tot / 2])                        res += 2;                    else ++res;                &#125;                else p[now] = i;            &#125;        &#125;        print(res, &#39;\n&#39;);        noSol: ;    &#125;    return 0;&#125;&#125; // namespace XSC062</code></pre></details><hr /><h3 id="c.-除与减-divsub">C. 除与减 divsub</h3><p><a href="http://222.180.160.110:61235/contest/4647/problem/3" class="uri">http://222.180.160.110:61235/contest/4647/problem/3</a></p><p>小数学，还好。</p><p>假设 <span class="math inline">\(n=d\times k^p\)</span>，其中 <span class="math inline">\(k\nmid d\)</span>，那么我们分两种情况讨论。</p><ol type="1"><li><p><span class="math inline">\(p=0\)</span>，即 <span class="math inline">\(k\nmid n\)</span>，那么 <span class="math inline">\(n\bmod k=1\)</span>，即 <span class="math inline">\(k\mid (n-1)\)</span>。</p>这个时候问 <span class="math inline">\(k\)</span> 的个数就相当于是在问 <span class="math inline">\(n-1\)</span> 除 <span class="math inline">\(1\)</span> 以外的因子个数。假设 <span class="math inline">\(n-1={x_1}^{p_1}{x_2}^{p_2}\cdots {x_m}^{p_m}\)</span>，那么答案为 <span class="math inline">\((\prod p_i+1)-1\)</span>，减去的是 <span class="math inline">\(1\)</span>。</li><li><p><span class="math inline">\(p\ne 0\)</span>，<span class="math inline">\(k\mid n\)</span>。</p><p>这个时候好像并没有什么好的转化。好消息是 <span class="math inline">\(n\)</span> 的范围是 <span class="math inline">\(10^{12}\)</span>，根号枚举因数复杂度跑得过。所以我们就可以暴力判定 <span class="math inline">\(n\)</span> 的所有因数是否满足条件。</p></li></ol><p>时间复杂度，<span class="math inline">\(O(\sqrt n\times \log n)\)</span>，枚举因数是根号，算次数（也就是算 <span class="math inline">\(d\)</span>）是 <span class="math inline">\(\log\)</span>。</p><details><pre class="cpp"><code>#define int long longnamespace XSC062 &#123;using namespace fastIO;int n, m, res, cnt;int main() &#123;    read(n), m = n;    for (int i = 2; i * i &lt;= n; ++i) &#123;        if (n % i == 0) &#123;            m = n;            while (m % i == 0) m /= i;            if (m % i == 1) ++res;            if (i * i != n) &#123;                m = n;                while (m % (n / i) == 0)                    m /= (n / i);                if (m % (n / i) == 1) ++res;            &#125;        &#125;    &#125;    m = n - 1, cnt = 1;    for (int i = 2; i * i &lt;= m; ++i) &#123;        if (m % i == 0) &#123;            int now = 0;            while (m % i == 0)                ++now, m /= i;            cnt *= now + 1;        &#125;    &#125;    if (m != 1) cnt *= 2;    print(res + cnt, &#39;\n&#39;);    return 0;&#125;&#125; // namespace XSC062#undef int</code></pre></details><hr /><h3 id="d.-图书管理员-librarian">D. 图书管理员 librarian</h3><p><a href="http://222.180.160.110:61235/contest/4647/problem/4" class="uri">http://222.180.160.110:61235/contest/4647/problem/4</a></p><p>[SDOI2008] 郁闷的小 J。</p><p>关于这个，我们发现自己不会考场现冲主席树。哎，打 CDQ 又怕写挂。</p><p>我们发现这道题的修改都是单点的，询问也只关于某一种颜色，不同的颜色之间没有影响。</p><p>于是我们可以把操作离线下来，初始视作将某颜色在某位置增加，修改视作将某颜色在某位置删除，将另一颜色在该位置增加，将所有操作按颜色离散化分类然后 <code>vector</code> 下来，对于所有颜色从前到后树状数组做一遍操作就能 <span class="math inline">\(O(n\log n+q\log n)\)</span> 解决。</p><p>树状数组清空是肯定不能 <code>memset</code> 的，复杂度不对。那么怎么办呢？把所有操作撤回去就可以了。</p><p>顺带一提我是洛谷上最优解。</p><details><pre class="cpp"><code>namespace XSC062 &#123;using namespace fastIO;const int maxn = 2e5 + 5;struct __ &#123;    int ty, l, r, v;    __() &#123;&#125;    __(int t1, int l1, int r1, int v1 = 0) &#123;        if (t1 == 0)            ty = 0, l = l1, v = r1;        else ty = 1, l = l1, r = r1, v = v1;    &#125;&#125;;char ty;std::map&lt;int, int&gt; tab;std::vector&lt;__&gt; q[maxn];int n, m, tot, x, y, v, id;int Bit[maxn], a[maxn], res[maxn];int lowbit(int x) &#123; return x &amp; -x; &#125;void add(int x, int v) &#123;    for (; x &lt;= n; x += lowbit(x))        Bit[x] += v;    return;&#125;int ask(int x) &#123;    int res = 0;    for (; x; x -= lowbit(x)) res += Bit[x];    return res;&#125;int main() &#123;    read(n), read(m);    for (int i = 1; i &lt;= n; ++i) &#123;        read(a[i]);        if (!tab.count(a[i]))            tab[a[i]] = ++tot;        a[i] = tab[a[i]];        q[a[i]].emplace_back(0, i, 1);    &#125;    while (m--) &#123;        scanf(&quot;%1s&quot;, &amp;ty);        if (ty == &#39;C&#39;) &#123;            read(x), read(y);            if (!tab.count(y))                tab[y] = ++tot;            y = tab[y];            q[a[x]].emplace_back(0, x, -1);            q[a[x] = y].emplace_back(0, x, 1);        &#125;        else &#123;            ++id;            read(x), read(y), read(v);            if (!tab.count(v)) continue;            v = tab[v];            q[v].emplace_back(1, x, y, id);        &#125;    &#125;    for (int i = 1; i &lt;= tot; ++i) &#123;        for (auto &amp;j : q[i]) &#123;            if (j.ty == 0) add(j.l, j.v);            else &#123;                res[j.v] =                    ask(j.r) - ask(j.l - 1);            &#125;        &#125;        for (auto &amp;j : q[i])            if (j.ty == 0) add(j.l, -j.v);    &#125;    for (int i = 1; i &lt;= id; ++i)        print(res[i], &#39;\n&#39;);    return 0;&#125;&#125; // namespace XSC062</code></pre></details><hr /><p>E 会单独开一篇。</p><hr /><h3 id="f.-树-tree">F. 树 tree</h3><p><a href="http://222.180.160.110:61235/contest/4647/problem/6" class="uri">http://222.180.160.110:61235/contest/4647/problem/6</a></p><p>CF916E。</p><p>大分讨给我整不会了，更给我整不会的是下来过后发现这只是个小分讨。</p><p>更新子树和子树查询我们都会。换根 DP 我们也都写过，都知道换根并不会对子树结构产生大的影响。所以应当是能根据已知信息推测出子树在原树上对应的点集的。</p><p>记 <span class="math inline">\(r\)</span> 为当前树根，<span class="math inline">\(\text {LCA}(x,y)\)</span> 为 <span class="math inline">\(x,y\)</span> 在 <span class="math inline">\(1\)</span> 为根时的 LCA，<span class="math inline">\(\text {LCA}&#39;(x,y)\)</span> 表示 <span class="math inline">\(x,y\)</span> 在 <span class="math inline">\(r\)</span> 为根时的 LCA。</p><p>那么对于 <span class="math inline">\(\text {LCA}&#39;(x,y)\)</span>，肯定是要讨论 <span class="math inline">\(x,y\)</span> 和 <span class="math inline">\(r\)</span> 的位置关系的。</p><ol type="1"><li><span class="math inline">\(\text {LCA}(x,y)\)</span> 是 <span class="math inline">\(r\)</span> 的子孙。此时 <span class="math inline">\(\text {LCA}&#39;(x,y) = \text {LCA}(x,y)\)</span>。</li><li><span class="math inline">\(\text {LCA}(x,y)\)</span> 是 <span class="math inline">\(r\)</span> 的祖先。那么说明至少有一个点不是 <span class="math inline">\(r\)</span> 的子孙。此时 <span class="math inline">\(\text {LCA}(x,y)&#39;\)</span> 的值为 <span class="math inline">\(r\)</span> 为另一个点的 LCA。</li></ol><p>整理可得 <span class="math inline">\(\text {LCA}&#39;(x,y)\)</span> 是 <span class="math inline">\(\text {LCA}(x,y)\)</span>、<span class="math inline">\(\text {LCA}(x,r)\)</span> 和 <span class="math inline">\(\text {LCA}(y,r)\)</span> 中的深度最大者。</p><p>对于以 <span class="math inline">\(r\)</span> 为根时的子树 <span class="math inline">\(x\)</span>：</p><ol type="1"><li><span class="math inline">\(x=r\)</span>，此时子树为整棵树。</li><li><span class="math inline">\(\text {LCA}(x,r)\ne x\)</span>，即 <span class="math inline">\(r\)</span> 不为 <span class="math inline">\(x\)</span> 的子孙，此时子树就是以 <span class="math inline">\(1\)</span> 为根是的子树 <span class="math inline">\(x\)</span>。</li><li><span class="math inline">\(\text {LCA}(x,y)=x\)</span>，即 <span class="math inline">\(r\)</span> 为 <span class="math inline">\(x\)</span> 的子孙，此时子树是整棵树除开 <span class="math inline">\(x\)</span> 包含 <span class="math inline">\(r\)</span> 的儿子及其子孙。修改和查询的时候容斥一下就好。这个时候的子树倍增跳一下就能找到。</li></ol><p>然后就是常规线段树维护了。时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p><details><pre class="cpp"><code>namespace XSC062 &#123;using namespace fastIO;const int maxm = 35;const int maxn = 1e5 + 5;#define lt (p &lt;&lt; 1)#define rt (lt | 1)struct _ &#123; int l, r, u, d; &#125;;_ t[maxn &lt;&lt; 2];int f[maxn][maxm];std::vector&lt;int&gt; g[maxn];int a[maxn], dfn[maxn], rfn[maxn];int n, q, r, ty, x, y, v, si, now;int top[maxn], dep[maxn], tab[maxn];void swap(int &amp;x, int &amp;y) &#123;    x ^= y ^= x ^= y;    return;&#125;void DFS(int x) &#123;    dep[x] = dep[f[x][0]] + 1;    dfn[x] = ++now, tab[now] = x;    for (auto i : g[x]) &#123;        if (i == f[x][0]) continue;        f[i][0] = x;        for (int j = 1; j &lt;= si; ++j)            f[i][j] = f[f[i][j - 1]][j - 1];        DFS(i);    &#125;    rfn[x] = now;    return;&#125;void pushup(int p) &#123;    t[p].u = t[lt].u + t[rt].u;    return;&#125;void pushdown(int p) &#123;    if (t[p].d) &#123;        t[lt].d += t[p].d;        t[rt].d += t[p].d;        t[lt].u += t[p].d *                (t[lt].r - t[lt].l + 1);        t[rt].u += t[p].d *                (t[rt].r - t[rt].l + 1);        t[p].d = 0;    &#125;    return;&#125;void bld(int p, int l, int r) &#123;    t[p].l = l, t[p].r = r;    if (l == r) &#123;        t[p].u = a[tab[l]];        return;    &#125;    int mid = (l + r) &gt;&gt; 1;    bld(lt, l, mid), bld(rt, mid + 1, r);    pushup(p);    return;&#125;void add(int p, int x, int v) &#123;    t[p].u += v;    if (t[p].l == t[p].r) return;    pushdown(p);    int mid = (t[p].l + t[p].r) &gt;&gt; 1;    if (x &lt;= mid) add(lt, x, v);    else add(rt, x, v);    return;&#125;void add(int p, int l, int r, int v) &#123;    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r) &#123;        t[p].d += v;        t[p].u += (t[p].r - t[p].l + 1) * v;        return;    &#125;    pushdown(p);    int mid = (t[p].l + t[p].r) &gt;&gt; 1;    if (l &lt;= mid) add(lt, l, r, v);    if (r &gt; mid) add(rt, l, r, v);    pushup(p);    return;&#125;int ask(int p, int l, int r) &#123;    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r)        return t[p].u;    pushdown(p);    int res = 0,        mid = (t[p].l + t[p].r) &gt;&gt; 1;    if (l &lt;= mid) res = ask(lt, l, r);    if (r &gt; mid) res += ask(rt, l, r);    return res;&#125;int LCA(int x, int y) &#123;    if (dep[x] &lt; dep[y]) swap(x, y);    for (int i = si; ~i; --i) &#123;        if (dep[f[x][i]] &gt;= dep[y])            x = f[x][i];    &#125;    if (x == y) return x;    for (int i = si; ~i; --i) &#123;        if (f[x][i] != f[y][i])            x = f[x][i], y = f[y][i];    &#125;    return f[x][0];&#125;void Add(int x, int v) &#123;    int rlca = LCA(r, x);    if (x == r) add(1, 1, n, v);    else if (rlca != x)        add(1, dfn[x], rfn[x], v);    else &#123;        add(1, 1, n, v);        int p = r;        for (int i = si; ~i; --i) &#123;            if (dep[f[p][i]] &gt;= dep[x] + 1)                p = f[p][i];        &#125;        add(1, dfn[p], rfn[p], -v);    &#125;    return;&#125;void tAdd(int x, int y, int v) &#123;    int llca = LCA(r, x), rlca = LCA(r, y),        ulca = LCA(x, y);    if (dep[llca] &gt;= dep[rlca] &amp;&amp;        dep[llca] &gt;= dep[ulca]) Add(llca, v);    else if (dep[rlca] &gt;= dep[llca] &amp;&amp;        dep[rlca] &gt;= dep[ulca]) Add(rlca, v);    else Add(ulca, v);    return;&#125;int tAsk(int x) &#123;    int rlca = LCA(r, x);    if (x == r) return t[1].u;    if (rlca != x)        return ask(1, dfn[x], rfn[x]);    int p = r;    for (int i = si; ~i; --i) &#123;        if (dep[f[p][i]] &gt;= dep[x] + 1)            p = f[p][i];    &#125;    return t[1].u - ask(1, dfn[p], rfn[p]);&#125;void add(int x, int y) &#123;    g[x].push_back(y);    return;&#125;int main() &#123;    read(n), read(q), r = 1;    si = log(n) / log(2.0);    for (int i = 1; i &lt;= n; ++i) read(a[i]);    for (int i = 1; i &lt; n; ++i) &#123;        read(x), read(y);        add(x, y), add(y, x);    &#125;    dep[0] = 1, DFS(1), dep[0] = 0;    bld(1, 1, n);    while (q--) &#123;        read(ty);        if (ty == 1) read(r);        else if (ty == 2) &#123;            read(x), read(y), read(v);            tAdd(x, y, v);        &#125;        else &#123;            read(x);            print(tAsk(x), &#39;\n&#39;);        &#125;    &#125;    return 0;&#125;&#125; // namespace XSC062#undef int</code></pre></details>]]></content>
      
      
      
        <tags>
            
            <tag> 线段树 </tag>
            
            <tag> 树状数组 </tag>
            
            <tag> LCA </tag>
            
            <tag> 倍增 </tag>
            
            <tag> 鸽巢原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TRICKS</title>
      <link href="/20231117/"/>
      <url>/20231117/</url>
      
        <content type="html"><![CDATA[<p>想着写点什么东西，就是说，不会被归入知识点，却又感觉很常用的东西。</p><p>哦我懂了，通常来说我们管这个叫 trick。</p><span id="more"></span><p>先记一记自己遇到过的。</p><hr /><h2 id="ds">DS</h2><ul><li><p><strong>不强制在线</strong> <strong>复杂度不依赖均摊</strong> 的可持久化数据结构 <span class="math inline">\(\to\)</span> DAG 上直接模拟。</p>并查集，线段树合并 <img src="/em/lh.gif" /></li><li>只要求『在最新版本上修改』和『查询所有版本』的可持久化数组可以在 <code>vector</code> 上二分，又唤部分可持久化。</li><li>在可以使用『线段树合并』或『主席树』解决的问题中，选前者。原因：跑不满。</li><li><p>插入删除区间，维护值域内未被覆盖的点的信息：线段树维护节点内被覆盖次数最小值和最小值信息；当最小值为 <span class="math inline">\(0\)</span> 时，将信息纳入统计。</p><p>扩：插入删除区间，维护值域内恰好被区间覆盖 <span class="math inline">\(k\)</span> 次的点的信息：线段树维护节点内前 <span class="math inline">\(k+1\)</span> 小值的信息，则 <span class="math inline">\(k\)</span> 一定出现在前 <span class="math inline">\(k+1\)</span> 小值中。</p></li></ul><hr /><h2 id="数学">数学</h2><ul><li><p>先整点若智的视力问题。虽然我在数学方面跟若智也没差太多了。</p><ul><li><p><span class="math inline">\(\{1,1,2,3,5,8,\cdots\}\)</span> 是斐波那契；矩阵可以优化；生成函数可以找通项；<span class="math inline">\(f_i=\sum\limits_{i=0}^nC_n-i^i\)</span>。</p></li><li><p><span class="math inline">\(\{1, 1, 2, 5, 14, 42, 132, 429, 1430,\cdots\}\)</span> 是 Catalan，走网格不能穿过对角线 / 构造二叉树方案数 / 一群人买电影票。<a href="/20250419/#不经过-yxc-的方案数">有组合求法 <span class="math inline">\({2n\choose n} - {2n \choose n - 1}\)</span></a>；生成函数还是可以找通项；</p></li><li><span class="math inline">\(\{3, 7, 6, 15, 25, 10, 31, 90, 65, 15, 63, 301, 350, 140, 21, 127, 966,\cdots\}\)</span>，中间插着 一堆 <span class="math inline">\(1\)</span> 我写不下了所以删了，是展开了的第二类斯特林数三角形，把 <span class="math inline">\(n\)</span> 个不同球，不空放，放到 <span class="math inline">\(k\)</span> 个相同盒子的方案数，有递推式 <span class="math inline">\(S(n,k)=S(n-1,k-1)+k\cdot S(n-1,k)\)</span> 和二项式反演出来的通项 <span class="math inline">\(S(n,m)=\sum\limits_{i=0}^m\dfrac {(-1)^{m-i}\cdot i^n}{i!\cdot (m-i)!}\)</span>。多项式可以 <span class="math inline">\(n\log\)</span> 算同一行 / 列，方法不太一样。</li></ul></li><li><p><span class="math inline">\(O(n)\)</span> 求任意 <span class="math inline">\(n\)</span> 个数的逆元：</p><pre class="cpp"><code>inv[0] = 1;for (int i = 1; i &lt;= n; ++i)    inv[i] = inv[i - 1] * a[i];inv[n] = qkp(inv[n], mod - 2);for (int i = n; i; --i) &#123;    int t = inv[i - 1];    inv[i - 1] = inv[i] * a[i] % mod;    inv[i] = inv[i] * t % mod;&#125;</code></pre></li><li><p>求线段 <span class="math inline">\((x_1,y_1,x_2,y_2)\)</span> 穿过直线系 <span class="math inline">\(x+y=k\cdots m(k\in \mathbb{N}^*)\)</span> 的次数。</p><p>算出线段中 <span class="math inline">\(x+y\)</span> 的取值范围也即 <span class="math inline">\([x_1+y_1,x_2+y_2]\)</span>（斜率为负就不同了，但可以证明都是单调的），求出 <span class="math inline">\(k\cdot m\)</span> 在里面的出现次数就可以了。<del>有的人高中数学欠的债要到竞赛来还</del></p><p>goto <a href="https://codeforces.com/contest/2098/problem/E">CF2098E</a>。</p></li></ul><hr /><h2 id="图论">图论</h2><ul><li><p>一系列元素，每个元素有不超过两种可选值，要求最终每个元素值不同，求方案数。</p><p>对所有可选值建图 / 并查集。如果只有一个可选值，看作两种可选值相同，连自环；否则把两个可选值连边。此时一个元素对应一条边，即对于每条边选一个端点，满足每个端点被选最多一次。</p><p>对于所有连通块：</p><ul><li>若 <span class="math inline">\(n&gt;m+1\)</span>： 没有这种可能性，不连通的。</li><li>若 <span class="math inline">\(n=m+1\)</span>，即该连通块为树，任选一个点不选都能唯一构成一组解，方案数为 <span class="math inline">\(n\)</span>。</li><li><p>若 <span class="math inline">\(n=m\)</span>，即形成基环树：</p><p>由于环上点只能且必须被环上边选，树上边的选法唯一。主要讨论环边选法。</p><ul><li>若环为自环，答案为 <span class="math inline">\(1\)</span>；</li><li>否则枚举环上所有边是统一选顺 / 逆时针方向的端点，答案为 <span class="math inline">\(2\)</span>。</li></ul></li><li><p>若 <span class="math inline">\(n&lt;m\)</span>：</p><p>点不够用，答案为 <span class="math inline">\(0\)</span>。</p></li></ul><p>最后把所有连通块的答案相乘就可以得到总答案。</p>goto <a href="https://vjudge.net/problem/OpenJ_POJ-C19A">Ball</a>, <a href="https://codeforces.com/contest/2097/problem/B">Baggage Claim</a>, <a href="https://atcoder.jp/contests/tkppc6-2/tasks/tkppc6_2_g">Must be Distinct!</a>。</li><li><p>比如有对图中边权的更新。像是让你求某某的最小，然后更新操作是减小某个边权。</p><p>这个时候我们就会发现改边不太现实，可以直接加边，因为保留原来那条更大的边不会影响答案。</p>题不知道。</li><li><p>有环图上的 DP，通常来说可以根据状态转移方程的形式找到环上的「根源」，即不由任何环上节点转移得到。</p><p>无视根源在环上的前驱边就可以用类拓扑的方式转移。</p>Goto <a href="/20231113/#b.-商人">solu to 商人</a>。</li><li><p>关于树的直径：</p><ul><li><p>树的半径（即 <span class="math inline">\(\min\limits_x\{\max\limits_y dis(x, y)\}\)</span>）的一端一定在直径上，且在直径中间。</p>如果不带权的话就是直径长度的一半 <del>不然为啥叫半径</del>。</li><li><p>如果知道一坨连通块内的直径是 <span class="math inline">\(x\to y\)</span>，另一坨是 <span class="math inline">\(a\to b\)</span>，那么两个合并起来的直径一定是 <span class="math inline">\(\{x,y,a,b\}\)</span> 里的 <span class="math inline">\(C_4^2\)</span>。</p>以及树上的连通块是树 <img src="/em/lh.gif" /></li><li><p>动态维护树的直径（比如修改叶子的边权，这里是为了保证单点修改）：</p>用上面提到的方法，线段树维护一段连续欧拉序内（不用 DFS 序是为了保证联通）的直径和两个端点，然后求 dis 再合并。为了快点儿我们在顺势欧拉序上 st 表来查 LCA 即可 <span class="math inline">\(n\log\)</span> 地解决问题。</li></ul></li><li><p>奇奇怪怪的优化建图：</p><p>通用的是 <span class="math inline">\(n\log\)</span> 线段树，目前还见到过前缀和优化建图（前提是每条边都指向某个前缀区间，与线段树优化建图相比的优势是虚点数为 <span class="math inline">\(O(n)\)</span>，<a href="http://222.180.160.110:61235/contest/5476/problem/3">eg</a>）。</p></li></ul><hr /><h2 id="dp">DP</h2><ul><li>计数 DP 和容斥的选择。</li><li><p>（容斥）碰到了「起点状态到终点状态，中间不能经过一些非法状态的方案数」，可以用 <span class="math inline">\(f_i\)</span> 表示从起点，不经过 <span class="math inline">\(1\sim i-1\)</span> 的非法状态，到达非法状态 <span class="math inline">\(i\)</span> 的方案数，最后将终点状态也视为一个非法状态并 DP 即可。</p>Goto <a href="/20231113/#a---gerald-and-giant-chess">solu to CF559C Gerald and Giant Chess</a>，<a href="https://www.cnblogs.com/XSC062/p/17330225.html">solu to 两双手</a>。</li><li><p>要求字典序大于 / 小于给定值的方案数，考虑使用 <span class="math inline">\(f_i\)</span> 表示 <span class="math inline">\(1\sim i\)</span> 全部和给定值相同，<span class="math inline">\(i+1\)</span> 大于 / 小于给定值，后面乱搞的情况总数。</p>Goto <a href="http://222.180.160.110:61235/contest/5423/problem/2">冒泡排序</a>。</li><li><p>求方案数，如果用通常的「考虑满足条件的情况并转移」，就必须能够简单地对条件进行判定。</p><p>如果这一点做不到，可以考虑从最简单或最极限情况出发 <strong>构造</strong> 出一般情况，并计算相应的方案数。</p><details><p><summary>goto <em>solu to 染色</em>…</summary></p><p><a href="http://222.180.160.110:61235/contest/3887/problem/3" class="uri">http://222.180.160.110:61235/contest/3887/problem/3</a></p><blockquote><p>有 <span class="math inline">\(N\)</span> 个格子排成一排，你需要用至多 <span class="math inline">\(M\)</span> 种颜色给这些格子染色，每个格子恰好染成某一种颜色，不需要每种颜色都用上。求有多少种染色方案满足相邻的同色格子不超过 <span class="math inline">\(K\)</span> 对。</p></blockquote><p>不妨将一对相邻同色格子称为同色对，将一串连续的相同颜色称作一段，那么最极端的情况下会有 <span class="math inline">\(N\)</span> 段（即不存在同色对）。</p><p>构造一段长度为 <span class="math inline">\(L\)</span> 的 <span class="math inline">\(L\)</span> 段序列（即不存在同色对）。此时将任意一段长度增加 1，则出现一对同色对。接下来，不论是选取长度为 2 的那一段，还是选取剩下的长度为 1 的段，将其长度增加 1，都会且仅会增加 1 对同色对。</p><p>以此类推，进行 <span class="math inline">\(K\)</span> 次「选取一段并将其长度增加 1」的操作，可得到刚好 <span class="math inline">\(K\)</span> 个同色对，此时序列长度为 <span class="math inline">\(L + K\)</span>，而 <strong>段数没有变化</strong>，仍是一开始的 <span class="math inline">\(L\)</span>。 所以反过来，如果在长度为 <span class="math inline">\(N\)</span> 的序列中存在 <span class="math inline">\(K\)</span> 个同色对，那么段数为 <span class="math inline">\(N-K\)</span>。<del>很难想象题解用「所以」两个字直接略过了上述推导过程</del></p><p>由此，我们只要考虑分别将序列任意分为非空的 <span class="math inline">\(N-K\sim N\)</span> 段，就可以解决问题，隔板法可得将 <span class="math inline">\(N\)</span> 分为 <span class="math inline">\(T\)</span> 段的方案数为 <span class="math inline">\(C_{N-1}^{T-1}\)</span>。在此基础上考虑染色，由乘法原理，将 <span class="math inline">\(T\)</span> 段染色的方案为 <span class="math inline">\((m - 1)^{T - 1}\times M\)</span>。</p><p>取 <span class="math inline">\(T=N-K\sim N\)</span> 并求和问题即解决。</p></details></li><li><p>如果有转移会有后效性不妨考虑是否有前效性然后逆序 DP。</p><p>比如题目让我们求最小字典序。你只知道最后一个字符肯定不能推断出谁的字典序最小，但如果你知道最开头一个字符，并保证从后往前填表的每一步都走的最小就可以。</p><details><p><summary>goto <em>solu to 匹配数</em>…</summary></p><p><a href="http://222.180.160.110:61235/contest/3887/problem/2" class="uri">http://222.180.160.110:61235/contest/3887/problem/2</a></p><blockquote><p>求出最小的、不含前导零的 <span class="math inline">\(n\)</span> 位数 <span class="math inline">\(x\)</span>，满足 <span class="math inline">\(n-1\)</span> 条限制，第 <span class="math inline">\(i\)</span> 条限制规定 <span class="math inline">\(x\)</span> 的第 <span class="math inline">\(i\)</span> 位和 <span class="math inline">\(i + 1\)</span> 位的关系（小于、大于、等于、不等于）。</p></blockquote><p>如果正着 DP，也就是说先确定前面的数位再向后 DP，后面的数位就没办法决定选择哪个已有状态进行转移，因为我们没有办法仅凭上一位就得到哪个状态拥有最小的字典序。</p><p>但是题解很风轻云淡地给出了一个我一辈子想不出来的 fix：倒着 DP。我们只要保证每次选取最小的可行的下一位即可，这恰好符合字典序的定义。</p><p>记录前驱（or 后继？）后输出即可。</p></details></li><li><p id="1">状态拆分技巧。比如状态 ABC 不一定要从状态 A、状态 B、状态 C 分别 <span class="math inline">\(O(m)\)</span> 的转移，而可以从 A 和 BC 以 <span class="math inline">\(O(1)\)</span> 完成转移。</p>Goto <a href="/20231003/#f.-单词">solu to 单词</a>。</li><li><p>有结论：一个长度为 <span class="math inline">\(n\)</span> 的 <span class="math inline">\(1/-1\)</span> 随机序列的前缀和离 <span class="math inline">\(0\)</span> 的距离期望不超过 <span class="math inline">\(\sqrt n\)</span>。</p><p>故胡乱拓展一下，在保证值域内分布均匀的整数域内背包，在 <code>random_shuffle</code> 后实际最大状态不太会超过 <span class="math inline">\(\sqrt V\)</span>。</p><p>因为这个是由一个科什么什么定理推来的中间很松的结论，所以运气比较好的时候甚至不会超过 <span class="math inline">\(\log v\)</span>。</p></li></ul><h3 id="关于背包">关于背包</h3><ul><li><p>子序列问题（不仅是 + &amp; min，也可以是 xor、加 &amp; 模等）可以转化为背包问题；对一个区间做背包，可以把区间划分成若干段，每段做背包，再依次 <span class="math inline">\(O(v^2)\)</span> 地合并。</p><p>『划分』的一个典型场景是找『分割线』，然后向左向右分别做背包——这么做的优点是，对于任意穿这条分割线的区间，你都能 <span class="math inline">\(O(v^2)\)</span> 得到所有的背包信息。甚至，如果你只需要求某个特定体积下的答案，只需要 <span class="math inline">\(O(v)\)</span> 枚举。</p>goto <a href="https://loj.ac/p/6515">贪玩蓝月</a>。</li><li><p>背包可以看作一种 +/min 卷积：在体积维上做加法、在代价维上做 min。当然其他操作如体积维上的 xor、加模；代价维上的方案数都差不多。</p><p>因此，多次区间询问（离线）的背包可以结合分治——原因是从每个 <span class="math inline">\(l\)</span> 开始做一次背包是不现实的，而我们发现分割线是可以共用的——分割线代表的背包信息也是可以共用的。</p><p>所以需要找到一种『找分割线』和『一条分割线求解的范围』的方法，使得规定复杂度内能够最大化利用『公共信息』。分治的（类线段树的）结构就是一种极好的方式，在一层分治内解决所有在 <span class="math inline">\([l,r]\)</span> 范围内，且跨越 <span class="math inline">\(mid\)</span> 的询问，这样就能从 <span class="math inline">\(mid\)</span> 出发，向左到 <span class="math inline">\(l\)</span>，向右到 <span class="math inline">\(r\)</span> 求解背包。</p><p>goto <a href="/20250520/#cf2043f-nim">solu to CF2043F</a>。</p></li></ul><hr /><h2 id="哈希">哈希</h2><ul><li><p>用哈希解决，呃，怎么概括呢，比如区间计数，其中合法区间的左右端点对应着一种转化后的「全等」关系……？</p><p>Goto <a href="https://www.luogu.com.cn/article/5reynyzi">Three Occurrence</a>。</p></li></ul><h3 id="xor-hash">xor hash</h3><p>使用于异或判断次数奇偶性 / 元素存在性的哈希。</p><p>我们知道，区间里每个值出现次数都是偶数的必要不充分条件是区间异或起来为 <span class="math inline">\(0\)</span>。之所以不充分是因为存在类似 <span class="math inline">\(1\oplus 2\oplus 3=0\)</span> 的情况。</p><p>然后怎么让他变成充要的呢，哎，我们把每个数都给他哈希成一个随机大数（比如 ull），这样冲突的概率就会变成 <span class="math inline">\(2^{-64}\)</span>。</p><p>goto <a href="https://www.luogu.com.cn/article/ugg047a7">NOI2024 D1T1</a>。</p><details><p><summary>goto <em>solu to 牛客题</em>…</summary></p><blockquote><p>给定一棵带权树，将 <span class="math inline">\((u,v)\)</span> 间简单路径上的边权生成数组，两个人在数组中轮流选数，每次选走的数必须 <span class="math inline">\(\le\)</span> 上一个人选走的数，不能选的人输，问有多少个 <span class="math inline">\((u,v)\)</span> 满足先手必胜。</p></blockquote><p>如果在 <span class="math inline">\((u, v)\)</span> 的路径上有任何一种边权的数量是奇数，那么就要统计 <span class="math inline">\((u,v)\)</span>。</p><p>对于最小的、出现次数为奇数的边权 <span class="math inline">\(w\)</span>，先手选择 <span class="math inline">\(w\)</span>，此时剩下偶数个可选项。后手选择 <span class="math inline">\(w&#39;\)</span>，这会删除 <span class="math inline">\(&gt;w&#39;\)</span> 且 <span class="math inline">\(\le w\)</span> 的所有可选项。发现被删掉偶数个选项；剩下奇数个选项。易知先手必胜。</p><p>若不存在出现次数为奇数的边权，从刚刚后手的处境可以看出先手必败。所以，问题就转化为了：统计点对 <span class="math inline">\((u, v)\)</span> 的数量，满足 <span class="math inline">\(u\)</span> 到 <span class="math inline">\(v\)</span> 的简单路径中存在出现次数为奇数的边权。</p><p>给每个边权映射一个值，为 <code>base</code> 的 <code>rand()</code> 次方，自然溢出即可。然后直接按照之前的操作处理就好了。</p><p>如果一个你想找到类似于 <code>1 ^ 2 ^ 3 = 0</code> 的情况，其出现概率与数字的二进制位数有关。因为 <code>xor</code> 只针对于同一位，结果不会被上一位或下一位干扰，所以每一位出现异或起来为 <span class="math inline">\(0\)</span> 的概率是 <span class="math inline">\(\dfrac 12\)</span>。只要我们整点比较强力的 <span class="math inline">\(k\)</span> 位二进制数，那么出现以上情况的概率就是 <span class="math inline">\(2^{-k}\)</span>。</p><p>那么这个比较强力的 <span class="math inline">\(k\)</span> 位二进制数，用比较强力的类字符串哈希生成方式，再使用一个很大很大的随机数替代字符串哈希中表示下标的 <span class="math inline">\(i\)</span>，用自然溢出让它显得更加稳妥就好。所以现在我们程序寄掉的概率就是 <span class="math inline">\(\dfrac 1{2^{64}}\)</span>，好事情啊好事情。</p><p>时间复杂度 <span class="math inline">\(\mathcal O(n\log n)\)</span>，<span class="math inline">\(\log n\)</span> 来源于映射。</p></details><hr /><h2 id="关于最值">关于最值</h2><h3 id="关于冒泡排序">关于冒泡排序</h3><p><em>『冒泡排序有一种被出烂但是每次碰到我都不会的美感。』——wosile</em></p><p><em>这个人我不认识，但是我觉得这句话说得太好了！</em></p><ul><li><p>一轮冒泡排序做的事情：将序列按前缀最大值为段首划分为若干段，并把其移到段末。</p>goto <a href="/20250510/#c---1-loop-bubble-sort">1 Loop Bubble Sort</a>。</li><li><p>前缀最大值在一轮冒泡排序后仍是前缀最大值。</p></li></ul><h3 id="关于-lis">关于 LIS</h3><ul><li><p>要求一个下标在序列 LIS 中（显然一个序列存在多个 LIS）的出现次数。</p><p>这个时候分别统计以其结尾和开头的 LIS 长度与次数，如果加起来是序列 LIS 的长度，那么次数相乘就是答案。</p></li></ul><h2 id="杂项">杂项</h2><ul><li><span class="math inline">\(k\)</span> 个「二者至少选其一」形式的限制，要求选的尽可能少，使用 <span class="math inline">\(2^k\)</span> 枚举后取并集代替你那脑子被电灯泡撞了才能想出来的 <span class="math inline">\(3^k\)</span> 枚举。</li></ul><h3 id="悬线法">悬线法</h3><p>具体可维护的东西和倍增差不多吧，还是比单调栈泛用性大很多的。是单调栈 / 单调栈上二分的 <span class="math inline">\(O(n)\)</span> 平替。可以用笛卡尔树完美替代 <img src="/em/lh.gif" /></p><p>不过肯定悬线是好写很多的。一行代码还不用在意任何特殊情况的单调栈谁不爱呢。</p><p>Goto <a href="https://www.cnblogs.com/XSC062/p/17833822.html">solu to 情景剧</a>。</p><h4 id="随机序列悬线结合分块">随机序列悬线结合分块</h4><p>随机序列的笛卡尔树深度为 <span class="math inline">\(\log\)</span>；令块长为 <span class="math inline">\(B=\sqrt {\log n}\)</span>，维护每个点跳 <span class="math inline">\(B\)</span> 步的答案；那么就能 <span class="math inline">\(O(\sqrt {\log n})\)</span> 跳悬线。</p><h3 id="撤销思想">撤销思想</h3><p>当题目给出『按一定的操作序列，将整块逐步分解为小段，问至晚哪一步后满足条件（需要单调性）』，可以考虑从最后的局面开始考虑，逐步『合并』，并 check 最早合并到哪一步时满足条件。</p><details><p><summary>Goto <em>solu to CF567D</em></summary></p><p><a href="https://www.luogu.com.cn/problem/CF567D" class="uri">https://www.luogu.com.cn/problem/CF567D</a></p><p>因为「某一时刻是否一定被击中过」具有单调性，考虑先提前发射所有炮弹，倒序枚举炮弹，不断「撤销」当前最后一发炮弹的发射，如果在「撤销」这发炮弹后，存在任意一种放下 <span class="math inline">\(k\)</span> 艘完整的战舰的方案，说明在发射这一发炮弹之后绝对能够击中。</p><p>如果发射所有炮弹后，依然存在一种放下 <span class="math inline">\(k\)</span> 艘完整的战舰的方案，则无解。</p><p>具体实现可以使用并查集维护连通块大小，每「撤销」一发炮弹的发射相当于合并三个连通块：炮弹的落点、落点的前一个元素（若不存在或已被炮弹摧毁则忽略）、落点的后一个元素（若不存在或已被炮弹摧毁则忽略）。</p><p>设某连通块大小为 <span class="math inline">\(x\)</span>，可容纳战舰数为 <span class="math inline">\(res\)</span>，显然有 <span class="math inline">\(res = \lfloor (x + 1) \div (p + 1) \rfloor\)</span>。</p><p>记统计当前可容纳战舰的数量为 <span class="math inline">\(ans\)</span>，在并查集合并时，<span class="math inline">\(ans\)</span> 分别减去两个待合并连通块的可容纳战舰的数量，再加上新连通块可容纳战舰的数量。最靠后的 <span class="math inline">\(ans\ge k\)</span> 的时刻即为所求。</p><p>同时使用路径压缩和按秩合并，时空复杂度均为 <span class="math inline">\(\mathcal O(n)\)</span>。优于 multiset 解法。</p></details><h3 id="双栈模拟双端队列">双栈模拟双端队列</h3><blockquote><p>用两个栈模拟队列或双端队列。支持两头删除、插入。</p></blockquote><p>一个维护前面的插入、删除；一个维护后面的插入、删除。插入是简单的；删除在大部分情况下是简单的；如果某个栈删空了，将另一个栈的一半挪过来暴力重构即可。均摊复杂度线性。</p><details><p><summary>复杂度证明</summary></p><p>设两栈长度分别为 <span class="math inline">\(L_1,L_2\)</span>，定义势能 <span class="math inline">\(E=|L_1-L_2|\)</span>。每次插入 / 简单删除带来 <span class="math inline">\(\pm 1\)</span> 的势能变化；</p><p>一次重构消耗 <span class="math inline">\(E\)</span> 的势能，将势能重置为 <span class="math inline">\(E\le 1\)</span>。显然就有均摊线性复杂度了。</p></details><p>适用场景：类队列 / 双端队列场景，但若固定一个端点就可以向左向右分别简单维护的；如背包等。</p><p>goto <a href="https://ac.nowcoder.com/acm/contest/39759/F">黑鸟</a>，<a href="/20250520/#贪玩蓝月">solu to 贪玩蓝月</a>，<a href="/20250520/#贪玩蓝月">solu to Peru</a>。</p><h3 id="括号序列">括号序列</h3><h4 id="线段树维护括号序列">线段树维护括号序列</h4><p>每个节点维护左边</p><h4 id="贪心选取括号序列">贪心选取括号序列</h4><blockquote><p>给定 <span class="math inline">\(a_1\sim a_{2N}\)</span>，选取一个合法的长度为 <span class="math inline">\(2N\)</span> 的括号序列，记权值为所有 <span class="math inline">\((\)</span> 所在位置的 <span class="math inline">\(a\)</span> 值之和，最大化权值。</p></blockquote><p><span class="math inline">\(a_1\)</span> 显然为 <code>(</code>，<span class="math inline">\(a_{2N}\)</span> 显然为 <code>)</code>；</p><p>对于 <span class="math inline">\(a_2\sim a_{2N-1}\)</span>，从前往后扫，每次把两个连续元素放在一起考虑，进行如下操作：</p><ul><li>把这两个连续元素放到『可用来作 <code>(</code>』的队列里。</li><li>贪心地从队列里挑选 <span class="math inline">\(a\)</span> 最大的元素，令其为 <code>(</code>。</li></ul><details><p><summary>正确性证明</summary></p><p>即证：可构造出来的序列 <span class="math inline">\(\iff\)</span> 合法的序列；构造出来的序列最优。</p><ul><li><p>必要性：</p><p>我们知道，括号序列合法 <span class="math inline">\(\iff\)</span> 对于任意 <span class="math inline">\(i\)</span>，<span class="math inline">\(1\sim i\)</span> 中的 <code>)</code> 的数量不超过 <code>(</code>。</p>对于任意 <span class="math inline">\(i=2k+1\)</span>，前 <span class="math inline">\(i\)</span> 个元素中存在至少 <span class="math inline">\(k+1\)</span> 个 <code>(</code>。<strong>且如果任意一步少选，序列不合法</strong>。</li><li><p>充分性：</p><p>也即在我们可以任意选择从队列中挑选哪个元素的情况下，证明任意目标序列都可以被这么构造。</p>每次选择目标序列最靠前的未被选的 <code>(</code> 并将其选中。如果有一步不存在这样的位置怎么办？由『必要性』中粗体字得不合法。</li><li><p>最优性：</p><p>首先需要知道每个元素是否被选择是相对独立的。如果两个数都可被选，那么它们的选中状态是互不影响的（除非这是最后一个位置了，但显然这不是我们关注的重点）。</p><p>假设一个 <span class="math inline">\(a_i\)</span> 位于最优解序列，但我们没有选择它：说明选中了一个比 <span class="math inline">\(a_i\)</span> 更大的元素，可以构造出更优的序列。由此反证。</p></li></ul></details><p>goto <a href="/20250520/#abc407e-most-valuable-parentheses">abc407E</a>。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 下饭 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>杂题</title>
      <link href="/20231113/"/>
      <url>/20231113/</url>
      
        <content type="html"><![CDATA[<p><a href="http://222.180.160.110:61235/contest/4434">NOIP S</a> &amp; <a href="https://vjudge.net/contest/594162">计数杂题</a>。</p><span id="more"></span><hr /><h3 id="a.-卡门">A. 卡门</h3><p><a href="https://www.luogu.com.cn/problem/P6370" class="uri">https://www.luogu.com.cn/problem/P6370</a></p><p><a href="http://222.180.160.110:61235/contest/4434/problem/1" class="uri">http://222.180.160.110:61235/contest/4434/problem/1</a></p><p>我们惊讶地发现全场没多少人会做绿题。</p><hr /><p>就是说呢，我们把它「滚动到相邻行然后落下」的过程直接变成「往左下 / 右下滚」。那么球掉下去的过程呢，就可以理解为它是一直一次往下掉一格的，然后每一次掉落呢，会根据实际情况往左 / 往右 / 直着掉。</p><p>所以我们可以直接用 <span class="math inline">\(m\)</span> 个长度为 <span class="math inline">\(n\)</span> 的序列，记录从每 <span class="math inline">\(1\sim m\)</span> 列扔下去的情况。然后我们很容易可以知道，如果任意两个序列发生了交汇，那么从交汇点开始至序列结束呢，这两个序列的内容都是完全一样的。因为之前序列长什么样子，完全不会对之后产生影响。所以一旦有任意一个状态是一样的，后面都会是一样的。</p><p>所以呢，一旦我们跟着计划好的路线走，却发现走不动了，那就说明从走不动的位置开始，到原定路线结束，这些位置都会被封掉。所以这个时候我们直接重新计算路线就好了。</p><p>对于这 <span class="math inline">\(m\)</span> 列，就算每一列预定路线上的每个位置都被占了一次，也只会被更改 <span class="math inline">\(n\times m\)</span> 次；总体时间复杂度只有 <span class="math inline">\(O(nm^2)\)</span>。然后又由于不可能跑满，其实是完全没有问题，甚至跑得出溜快的。</p><details><pre class="cpp"><code>namespace XSC062 &#123;using namespace fastIO;const int maxm = 35;const int maxn = 3e4 + 5;char a[maxn][maxm];int n, m, q, u, x, y;std::vector&lt;int&gt; p[maxm]; int main() &#123;#ifdef ONLINE_JUDGE    freopen(&quot;kamen.in&quot;, &quot;r&quot;, stdin);    freopen(&quot;kamen.out&quot;, &quot;w&quot;, stdout);#endif    scanf(&quot;%d %d&quot;, &amp;n, &amp;m);    for (int i = 1; i &lt;= n; ++i)        scanf(&quot;%s&quot;, a[i] + 1);    for (int i = 1; i &lt;= m; ++i) &#123;        x = 1, y = i;        for (;;) &#123;            p[i].push_back(y);             if (a[x + 1][y] == &#39;.&#39;) ++x;            else &#123;                if (a[x + 1][y] == &#39;X&#39;) break;                if (a[x][y - 1] == &#39;.&#39; &amp;&amp; a[x + 1][y - 1] == &#39;.&#39;)                    ++x, --y;                else if (a[x][y + 1] == &#39;.&#39; &amp;&amp; a[x + 1][y + 1] == &#39;.&#39;)                    ++x, ++y;                else break;            &#125;        &#125;    &#125;    scanf(&quot;%d&quot;, &amp;q);    while (q--) &#123;        scanf(&quot;%d&quot;, &amp;u);        while (a[p[u].size()][p[u].back()] != &#39;.&#39;)            p[u].pop_back();        x = p[u].size(), y = p[u].back();        for (;;) &#123;            p[u].push_back(y);             if (a[x + 1][y] == &#39;.&#39;) ++x;            else &#123;                if (a[x + 1][y] == &#39;X&#39;) break;                if (a[x][y - 1] == &#39;.&#39; &amp;&amp; a[x + 1][y - 1] == &#39;.&#39;)                    ++x, --y;                else if (a[x][y + 1] == &#39;.&#39; &amp;&amp; a[x + 1][y + 1] == &#39;.&#39;)                    ++x, ++y;                else break;            &#125;        &#125;        a[x][y] = &#39;O&#39;;    &#125;    for (int i = 1; i &lt;= n; ++i) puts(a[i] + 1);    return 0;&#125;&#125; // namespace XSC062</code></pre></details><hr /><h3 id="b.-商人">B. 商人</h3><p><a href="http://222.180.160.110:61235/contest/4434/problem/2" class="uri">http://222.180.160.110:61235/contest/4434/problem/2</a></p><p>首先忽略图中的环带来的问题，假设 <span class="math inline">\(f_u\)</span> 表示从 <span class="math inline">\(u\)</span> 点出发的答案，不难想到 DP 式 <span class="math inline">\(f_u = \min\{\max(f_v-p_{(u,v)}, r_{(u,v)})\}\)</span>。</p><p>那么问题来了，图中是会有环的，不能简单地去更新 DP 值。我们首先考虑「根源」，每一个 <span class="math inline">\(f_u\)</span> 一定都是由另一个 <span class="math inline">\(f_v\)</span> 转移得到的，那么一定会存在一个已知的 <span class="math inline">\(f_u\)</span>，不由其他任何 <span class="math inline">\(f_v\)</span> 得到。</p><p>考虑一个环中 <span class="math inline">\(r\)</span> 最大的一条边 <span class="math inline">\((u,v)\)</span>。假设图中只有这一个环，那么 <span class="math inline">\(f_u\)</span> 的值一定为 <span class="math inline">\(r\)</span>，因为 <span class="math inline">\(p\)</span> 只能为非负。这样「根源」就被我们找到了。接下来进一步考虑转移方法。</p><p>一个点 <span class="math inline">\(u\)</span> 只能被其相连的点 <span class="math inline">\(v\)</span> 更新，那么当且仅当所有 <span class="math inline">\(f_v\)</span> 都是确定的，<span class="math inline">\(f_u\)</span> 才能被确定，进而去更新 <span class="math inline">\(u\)</span> 的前驱。这让我们想到了拓扑排序。如果我们将所有边反向，那么上面的过程几乎就是拓扑排序。</p><p>为了保证任意一个环上的「根源」都能最先被确定，我们按照按 <span class="math inline">\(r\)</span> 从大到小遍历每一条边的方式处理问题。对于每一条边 <span class="math inline">\((u,v)\)</span>，我们都假设它是「根源」并用 <span class="math inline">\(r_{(u,v)}\)</span> 更新 <span class="math inline">\(f_u\)</span>。我们其实并不关心 <span class="math inline">\(u\)</span> 是否是我们刚刚定义的形式上的「根源」，毕竟，只要 <span class="math inline">\(f_u\)</span> 能被 <span class="math inline">\(r_{(u,v)}\)</span> 更新，它就能算作广义上的，<strong>当前时刻的</strong>「根源」。</p><p>我们在一开始将出度为 <span class="math inline">\(0\)</span>（反图上就是入度为 <span class="math inline">\(0\)</span>）的点全部加入队列，在每次加边的时候进行拓扑排序。每次一条边以任意形式被「使用」后，都要打标记删除并不能再访问，以保证转移的正确性和高效。如果一条边被「使用」，分两种情况：</p><ol type="1"><li><p>更新「根源」：</p>这个时候这条边已经发挥了它的所有作用了，作为 <strong>当前时刻的</strong>「根源」，这条边的源点在未来至少不会再经由这一条边被更新。故可以删除。</li><li><p>拓扑排序中转移：</p><p>一个点被加入队列，说明它的 DP 值是确定的，那么就不用拿一个已经确定的值多次更新另一个 DP 值。故可以删除。</p></li></ol><p>所以正确性是可以保证的。类拓扑排序的结构也保证了算法复杂度 <span class="math inline">\(O(n+m)\)</span>。</p><details><pre class="cpp"><code>#define int long longnamespace XSC062 &#123;using namespace fastIO;const int inf = 1e18;const int maxn = 2e5 + 5;const int maxm = 2e5 + 5;struct _ &#123;    int v, r, p, i;    _() &#123;&#125;    _(int v1, int r1, int p1, int i1) &#123;        v = v1, r = r1, p = p1, i = i1;    &#125;&#125;;struct __ &#123;    int x, y, r, p;    bool operator&lt; (const __ &amp;q) const &#123;        return r &gt; q.r;    &#125;&#125;;__ a[maxm];bool del[maxn];std::queue&lt;int&gt; q;int n, m, x, y, r, p;std::vector&lt;_&gt; g[maxn];int f[maxn], deg[maxn];int max(int x, int y) &#123; return x &gt; y ? x : y; &#125;int min(int x, int y) &#123; return x &lt; y ? x : y; &#125;void add(int x, int y, int r, int p, int i) &#123;    g[x].emplace_back(y, r, p, i);    return;&#125;int main() &#123;#ifdef ONLINE_JUDGE    freopen(&quot;merchant.in&quot;, &quot;r&quot;, stdin);    freopen(&quot;merchant.out&quot;, &quot;w&quot;, stdout);#endif    read(n), read(m);    std::fill(f + 1, f + n + 1, inf);    for (int i = 1; i &lt;= m; ++i) &#123;        read(a[i].x), read(a[i].y);        read(a[i].r), read(a[i].p);        ++deg[a[i].x];    &#125;    std::sort(a + 1, a + m + 1);    for (int i = 1; i &lt;= n; ++i)        if (!deg[i]) q.push(i);    for (int i = 1; i &lt;= m; ++i)        add(a[i].y, a[i].x, a[i].r, a[i].p, i);    for (int i = 1; i &lt;= m; ++i) &#123;        while (!q.empty()) &#123;            int t = q.front(); q.pop();            for (auto j : g[t]) &#123;                if (del[j.i]) continue;                del[j.i] = 1;                if (f[t] != inf)                    f[j.v] = min(f[j.v], max(f[t] - j.p, j.r));                if (!--deg[j.v]) q.push(j.v);            &#125;        &#125;        if (!del[i]) &#123;            del[i] = 1, f[a[i].x] = min(f[a[i].x], a[i].r);            if (!--deg[a[i].x]) q.push(a[i].x);        &#125;    &#125;    for (int i = 1; i &lt;= n; ++i)        print(f[i] == inf ? -1 : f[i], &#39; &#39;);    putchar(&#39;\n&#39;);    return 0;&#125;&#125; // namespace XSC062#undef int</code></pre></details><hr /><h3 id="a---gerald-and-giant-chess">A - Gerald and Giant Chess</h3><p><a href="https://vjudge.net/contest/594162#problem/A" class="uri">https://vjudge.net/contest/594162#problem/A</a></p><p>这个呢，一道简单的数数题，但是因为我忘了 DP 容斥怎么打了所以自行思考了很久很久很久，还差最后一点点想出来的时候放弃了去抄题解 /cf</p><p>就是，这种「限制通行」的 DP 容斥（名字是我现场起的）类型的数数题有一种通法，就是首先我们只计算非法方案然后减掉。</p><p>那么非法方案怎么算呢？令 <span class="math inline">\(f_i\)</span> 表示一个非法点都不经过，到达 <span class="math inline">\(i\)</span> 这个非法点的方案数，那么有 <span class="math inline">\(f_i=calc(s,i)-\sum f_j\times calc(j,i)\)</span>，其中 <span class="math inline">\(s\)</span> 是起点，<span class="math inline">\(calc(j,i)\)</span> 是从 <span class="math inline">\(j\to i\)</span> 的方案数。这样就能不重不漏地枚举完所有情况了。</p><p>我们把 <span class="math inline">\((n,m)\)</span> 也视作一个非法点然后代入 DP 即可得到答案。</p><details><pre class="cpp"><code>#define int long longnamespace XSC062 &#123;using namespace fastIO;const int lim = 3e5;const int mod = 1e9 + 7;const int maxk = 2e3 + 5;const int maxn = 3e5 + 5;struct _ &#123;    int x, y;    bool operator&lt; (const _ &amp;q) const &#123;        return x == q.x ? y &lt; q.y : x &lt; q.x;    &#125;&#125;;_ a[maxk];int n, m, k, res; int f[maxk], fac[maxn];int qkp(int x, int y) &#123;    int res = 1;    while (y) &#123;        if (y &amp; 1) (res *= x) %= mod;        (x *= x) %= mod, y &gt;&gt;= 1;    &#125;    return res;&#125;int inv(int x) &#123; return qkp(x, mod - 2); &#125;int A(int n, int m) &#123;    return fac[n] * inv(fac[n - m]) % mod;&#125;int C(int n, int m) &#123;    return A(n, m) * inv(fac[m]) % mod;&#125;int calc(int i, int j) &#123;    int x = a[j].x - a[i].x + 1,        y = a[j].y - a[i].y + 1;    return C(x + y - 2, y - 1);&#125;int main() &#123;    fac[0] = 1;    for (int i = 1; i &lt;= lim; ++i)        fac[i] = fac[i - 1] * i % mod;    bool flag = 0;    read(n), read(m), read(k);    for (int i = 1; i &lt;= k; ++i) &#123;        read(a[i].x), read(a[i].y);        flag |= (a[i].x == 1 &amp;&amp; a[i].y == 1);        flag |= (a[i].x == n &amp;&amp; a[i].y == m);    &#125;    a[0].x = a[0].y = 1;    if (flag) &#123; print(0, &#39;\n&#39;); return 0; &#125;    ++k, a[k].x = n, a[k].y = m;    std::sort(a + 1, a + k + 1);    for (int i = 1; i &lt;= k; ++i) &#123;        f[i] = calc(0, i);        for (int j = 1; j &lt; i; ++j) &#123;            if (a[j].x &gt; a[i].x || a[j].y &gt; a[i].y) continue;            (f[i] -= f[j] * calc(j, i) % mod) %= mod;        &#125;    &#125;    f[k] = (f[k] % mod + mod) % mod;    print(f[k], &#39;\n&#39;);    return 0;&#125;&#125; // namespace XSC062#undef int</code></pre></details>]]></content>
      
      
      
        <tags>
            
            <tag> Tarjan </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>杂题</title>
      <link href="/20231112/"/>
      <url>/20231112/</url>
      
        <content type="html"><![CDATA[<p><a href="http://222.180.160.110:61235/contest/4424">NOIP S</a> &amp; <a href="http://222.180.160.110:61235/contest/4423">周考 16</a> &amp; 杂题。</p><span id="more"></span><hr /><h3 id="a.-数字游戏">A. 数字游戏</h3><p><a href="http://222.180.160.110:61235/contest/4424/problem/1" class="uri">http://222.180.160.110:61235/contest/4424/problem/1</a></p><details><p><summary>闲话</summary></p><p>一开始忘了怎么做的然后从 Cindy 的做法开始回忆，一边回忆一边写下文，结果发现写着写着变成 wjf 的做法了 /cf</p><p>upd：变成菌的做法了 /cf /cf /cf</p><p>upd：变成 zmq 的做法了，我已经懒得 /cf 了。</p></details><p>题意转化一下，大致就是一个每次往右拓展一位的询问区间，每次查询该询问区间内最大值并拿走之。</p><p>我们先感性地想，对于一个 <strong>很大的值</strong>，它一进入询问范围就会被当场拿走。</p><p>那如果没有被拿走是因为什么呢？因为在前面积存下来的元素中还有比它大的。</p><p>那为什么前面的比它大的元素没有被当场拿走呢？因为在更前面积存下来的有比这个元素大的…… 那么最开始的积存是怎么来的呢？是最初询问区间为 <span class="math inline">\([1,p_i]\)</span> 而非 <span class="math inline">\([1,1]\)</span> 导致的。</p><p>被积存下的数被拿出来用掉的时刻，就是往后碰到了一个比它小的值，然后顶替掉这个值被用掉。被顶替的就进入积存区。</p><p>所以这个时候我们直接 <strong>模拟</strong> 积存数被用掉的过程。</p><p>对于全序列中的最大值，当场用掉。次大值呢，若它比最大值先进入询问区间，皆大欢喜，当场用掉；又因为最大值不可能被积存，就算它在最大值之后，也可以当场用掉。</p><p>第三大的，就可能进积存区。假设它要出来，首先要满足出来的时间（在进入积存区之后，有点废话），然后如果它一出来就碰到了比它更大的，很不幸，出不来了。但是因为除了最大和次大之外没有元素比它大了，它就可以在剩下的位置里面随便挑——当然是挑最靠前的。后面的和第三大道理就差不多了。</p><p>所以这个时候我们就可以得到一个大致的做法了，我们把元素从大到小排序，顺便记录一下它进入询问范围的时间 <span class="math inline">\(t\)</span>。然后我们优先让这个值在 <span class="math inline">\(t\)</span> 时刻直接被拿走。那假如 <span class="math inline">\(t\)</span> 这个位置已经被更大的元素占领了，就找这之后第一个空位。</p><p>那么这个「第一个空位」怎么找呢？我们用一个初值为 <span class="math inline">\(1\)</span> 的 <span class="math inline">\(pos\)</span>，对于当场拿走的情况，肯定是不会有冲突的，所以冲突都发生在积存区。积存区又都是从 <span class="math inline">\(1\)</span> 开始的，所以我们只需要对于不是当场拿走的情况，把 <span class="math inline">\(pos\)</span> 移到距离 <strong>当前值</strong> 最近的空位然后放进去就可以了。因为 <span class="math inline">\(pos\)</span> 全程只会右移，摊出来是 <span class="math inline">\(O(n)\)</span> 的。</p><p>因为我们只要在最开始排个序，总时间复杂度 <span class="math inline">\(O(n\log n + nq)\)</span>。</p><details><pre class="cpp"><code>#define int long longnamespace XSC062 &#123;using namespace fastIO;const int maxn = 1e5 + 5;struct _ &#123;    int x, i;    bool operator&lt; (const _ &amp;q) const &#123;        return x &gt; q.x;    &#125;&#125;;_ a[maxn];int flag[maxn];int n, m, p, res, pos;int main() &#123;#ifdef ONLINE_JUDGE    freopen(&quot;game.in&quot;, &quot;r&quot;, stdin);    freopen(&quot;game.out&quot;, &quot;w&quot;, stdout);#endif    read(n), read(m);    for (int i = 1; i &lt;= n; ++i)        read(a[i].x), a[i].i = i;    std::sort(a + 1, a + n + 1);    while (m--) &#123;        read(p), res = 0, pos = 1;        for (int i = 1; i &lt;= n; ++i)            flag[i] = 0;        for (int i = 1; i &lt;= n; ++i) &#123;            int id =            (a[i].i &lt; p ? 1 : a[i].i - p + 1);            if (flag[id]) &#123;                while (flag[pos]) ++pos;                flag[pos] = i;            &#125;            else flag[id] = i;        &#125;        for (int i = 1, j = 1; i &lt;= n; ++i, j = -j)             res += j * a[flag[i]].x;        print(res, &#39;\n&#39;);    &#125;    return 0;&#125;&#125; // namespace XSC062#undef int</code></pre></details><hr /><h3 id="b.-过河卒ii">B. 过河卒II</h3><p><a href="http://222.180.160.110:61235/contest/4424/problem/2" class="uri">http://222.180.160.110:61235/contest/4424/problem/2</a></p><p>以及 <a href="https://www.luogu.com.cn/problem/P6234">这</a> 是原题。</p><p>读错题了整整 3.5h /youl</p><p>我们接下来把「特殊格子」记为 <code>-</code>，「特殊格子」四个方向相邻的点记作 <code>O</code>，除此之外的点因为没有可能被选到，我们不做讨论。</p><pre class="plain"><code>  -- O -  -</code></pre><p>对于一个关键点，我们发现找 T 字本身不太方便，所以我们可以把这个转化成在十字里面抠掉一个最小值。</p><p>接下来，我们假设有另一个关键点的十字和这一个的十字有重合并不相邻，那么大抵是形如这个样子的：</p><pre class="plain"><code>  -   -- O - O -  -   -</code></pre><p>这个时候，我们发现一共有 7 个 <code>-</code>，一共需要 6 个 <code>-</code>，所以我们试着随便抠掉一个。</p><pre class="plain"><code>  X   | -- O - | O -  -   | -</code></pre><p>我们发现这个时候一定是能找到一个 <strong>确定的</strong> 方案去划分 T 字的。</p><p>所以对于两个 <code>O</code> 的情况，我们抠掉七个 <code>-</code> 当中的最小值即可。</p><p>接下来假设有三个 <code>O</code>，那么会有 10 个 <code>-</code>，但我们需要 9 个，于是抠掉最小值，依然存在一种 <strong>确定的</strong> 方案去划分 T 字。</p><p>不难发现，<span class="math inline">\(n\)</span> 彼此影响还不相邻的 <code>O</code> 会带来 <span class="math inline">\(3\times n-1\)</span> 个 <code>-</code>（小学数学计算即可），我们将最小者删除即可得到最大答案。</p><p>推广一下结论，其实是我们对于 <span class="math inline">\(x\)</span> 个相互影响的 <code>O</code>（注意这里 <strong>没有强调</strong> 不相邻），删掉一些使得 <code>-</code> 的数量为 <span class="math inline">\(3x\)</span>。</p><p>那么我们又知道对于最理想的情况，也就是上面讲到的相互影响又不相邻，<code>-</code> 的个数是 <span class="math inline">\(3\times x+1\)</span>，我们又只能进行抠掉 <code>-</code> 这一个操作。</p><p>所以对于一个 <code>O/-</code> 连通块，要求其 <code>-</code> 的个数要么是 <span class="math inline">\(3x\)</span>（不然 <code>-</code> 就不够用了，以及 <code>-</code> 的缺失是相邻的 <code>O</code> 和边界导致的；边界外的 <code>-</code> 肯定是不能算的），要么为 <span class="math inline">\(3x+1\)</span>（只用删一个也保证了正确性）。</p><p>所以我们跑一个类 Flood-fill，一边搜一边找最小的 <code>-</code>，还要统计 <code>-</code> 和 <code>O</code> 的总个数，还要计算 <span class="math inline">\(sum\)</span>。然后就完了。</p><p>虽然说这个 Flood-fill 没什么技术含量，但是我们要注意只能从 <code>-</code> 出发只能通往 <code>O</code> 而非另一个 <code>-</code>，因为相邻的两个 <code>-</code> 其实是不会互相交叉的相互影响的。</p><p>Flood-fill 带来的总时间复杂度为 <span class="math inline">\(O(nm)\)</span>。</p><details><pre class="cpp"><code>namespace XSC062 &#123;using namespace fastIO;const int maxk = 1e6 + 5;const int inf = 0x3f3f3f3f;const int fx[] = &#123; 0, 0, 1, -1 &#125;;const int fy[] = &#123; 1, -1, 0, 0 &#125;;int n, m, k, x, y, res;int mn, sum, cnt1, cnt2;std::vector&lt;std::vector&lt;int&gt; &gt; a, b, c;int min(int x, int y) &#123; return x &lt; y ? x : y; &#125;int max(int x, int y) &#123; return x &gt; y ? x : y; &#125;void DFS(int x, int y) &#123;    sum += a[x][y];    if (b[x][y] == 1) ++cnt1;    else ++cnt2, mn = min(mn, a[x][y]);    c[x][y] = 1;    for (int i = 0; i &lt; 4; ++i) &#123;        int nx = x + fx[i],            ny = y + fy[i];        if (!nx || !ny || nx &gt; n || ny &gt; m)            continue;        if (c[nx][ny]) continue;        if ((b[x][y] == 1 &amp;&amp; b[nx][ny] == 1)         || (b[x][y] == 1 &amp;&amp; b[nx][ny] == 2)          || (b[x][y] == 2 &amp;&amp; b[nx][ny] == 1))            DFS(nx, ny);    &#125;    return;&#125;int main() &#123;#ifdef ONLINE_JUDGE    freopen(&quot;pawn.in&quot;, &quot;r&quot;, stdin);    freopen(&quot;pawn.out&quot;, &quot;w&quot;, stdout);#endif    read(n), read(m);    a.push_back(std::vector&lt;int&gt;(m + 1));    b.push_back(std::vector&lt;int&gt;(m + 1));    for (int i = 1; i &lt;= n; ++i) &#123;        a.push_back(std::vector&lt;int&gt;(m + 1));        b.push_back(std::vector&lt;int&gt;(m + 1));        for (int j = 1; j &lt;= m; ++j)            read(a[i][j]);    &#125;    c = b, read(k);    for (int i = 1; i &lt;= k; ++i) &#123;        read(x), read(y), ++x, ++y;        b[x][y] = 1;        if (x + 1 &lt;= n &amp;&amp; !b[x + 1][y]) b[x + 1][y] = 2;        if (y + 1 &lt;= m &amp;&amp; !b[x][y + 1]) b[x][y + 1] = 2;        if (x - 1 &gt;= 1 &amp;&amp; !b[x - 1][y]) b[x - 1][y] = 2;        if (y - 1 &gt;= 1 &amp;&amp; !b[x][y - 1]) b[x][y - 1] = 2;    &#125;    for (int i = 1; i &lt;= n; ++i) &#123;        for (int j = 1; j &lt;= m; ++j) &#123;            if (b[i][j] &amp;&amp; !c[i][j]) &#123;                mn = inf;                cnt1 = cnt2 = sum = 0;                DFS(i, j);                if (cnt2 == cnt1 * 3) res += sum;                else if (cnt2 == cnt1 * 3 + 1) res += sum - mn;                else &#123; puts(&quot;No&quot;); return 0; &#125;            &#125;        &#125;    &#125;    print(res, &#39;\n&#39;);    return 0;&#125;&#125; // namespace XSC062</code></pre></details><hr /><h3 id="c.-树图">C. 树图</h3><p><a href="http://222.180.160.110:61235/contest/4424/problem/3" class="uri">http://222.180.160.110:61235/contest/4424/problem/3</a></p><blockquote><p>DJ：你们去打一下动态树 DP 的板子就可以了。</p></blockquote><p>此时无声胜有声。</p><p>这里仅仅介绍一下 40pts 的做法。我们理所当然地想到 DP 一个点染成某种颜色所需的最小代价。</p><p>这里说的染成某种颜色其实不太准确，应该是「代表着」哪种颜色。像 0 可以代表 1 也可以代表 2，1 就只能代表 1，2 也只能代表 2。</p><p>令 <span class="math inline">\(f_{u,1}\)</span> 表示以 <span class="math inline">\(u\)</span> 为根的子树中不保留颜色 2 的最小代价（代表 1），<span class="math inline">\(f_{u, 2}\)</span> 表示以 <span class="math inline">\(u\)</span> 为根的子树中不保留颜色 1 的最小代价（代表 2）。</p><p>那么对于颜色已经确定为 <span class="math inline">\(1\)</span> 的点 <span class="math inline">\(u_1\)</span>，<span class="math inline">\(f_{u_1,2}=\inf\)</span>；对于颜色已经确定为 <span class="math inline">\(2\)</span> 的点 <span class="math inline">\(u_2\)</span>，<span class="math inline">\(f_{u_2,1}=\inf\)</span>；颜色为 0 的 <span class="math inline">\(u_0\)</span> 就不用管。</p><p>然后如果 <span class="math inline">\(u_1\)</span> 有一个 2 颜色的儿子 <span class="math inline">\(v_2\)</span>，就要切断这条边；反之，如果这个儿子的颜色为 1，就不用切断。</p><p>所以有：</p><p><span class="math display">\[f_{u,c}=\sum_{v\in son_u} \min(f_{v,c},f_{v,3-c}+1)\]</span></p><p>那么就完了。每次询问的时候跑一个完整的树 DP，或者我们也可以发现只用更新 <span class="math inline">\(u\)</span> 到目标点这一条链上的 DP 值，然后就可以根据这个做一个并不会实际改进复杂度的优化。</p><p>总体时间复杂度 <span class="math inline">\(O(nq)\)</span>。</p><details><pre class="cpp"><code>namespace XSC062 &#123;using namespace fastIO;const int maxn = 1e5 + 5;const int inf = 0x3f3f3f3f;int col[maxn];int f[maxn][3];int n, x, y, q;std::vector&lt;int&gt; g[maxn];int min(int x, int y) &#123;    return x &lt; y ? x : y;&#125;void DFS(int x, int fa, int to) &#123;    f[x][1] = f[x][2] = 0;    if (col[x] == 1) f[x][2] = inf;    else if (col[x] == 2) f[x][1] = inf;    for (auto i : g[x]) &#123;        if (i == fa) continue;        if (x != to) DFS(i, x, to);        f[x][1] += min(f[i][1], f[i][2] + 1);        f[x][2] += min(f[i][2], f[i][1] + 1);    &#125;    return;&#125;void add(int x, int y) &#123;    g[x].push_back(y);    return;&#125;int main() &#123;#ifdef ONLINE_JUDGE     freopen(&quot;diagrams.in&quot;, &quot;r&quot;, stdin);    freopen(&quot;diagrams.out&quot;, &quot;w&quot;, stdout);#endif    read(n);    for (int i = 1; i &lt; n; ++i) &#123;        read(x), read(y);        add(x, y), add(y, x);    &#125;    read(q);    while (q--) &#123;        read(x), read(y);        col[y] = (x &lt;= 2) ? x : 0;        DFS(1, -1, y);        print(min(f[1][1], f[1][2]), &#39;\n&#39;);    &#125;    return 0;&#125;&#125; // namespace XSC062</code></pre></details><hr /><h3 id="e.-字符串-string">E. 字符串 string</h3><p><a href="http://222.180.160.110:61235/contest/4423/problem/5" class="uri">http://222.180.160.110:61235/contest/4423/problem/5</a></p><p>原题：<a href="https://codeforces.com/problemset/problem/756/D">CF756D - Bacterial Melee</a>。</p><details><p><summary>怪话</summary></p><p>兔子：我谴责你。</p><p>我：？</p><p>兔子：为什么你的 last 要缩写成 <code>la</code>。我没看你题解直接看的代码看了半天没看懂。</p><p>我：不缩写成 <code>la</code> 难道要写成 <code>lst</code> 吗？</p><p>兔子：不然呢？</p><p>好吧，大家都是异教徒。</p></details><p>可以很简单的想到，最终字符串一定由原串中的部分字符，按照其在原串中的顺序，经过若干次重复得到。那么我们把一段连续的相同字符视为一个字符，得到的这个串就是原串的一个子序列。</p><p>所以我们只需要求出原串的不同子序列个数，再经过一定的排列组合就可以求出方案数。</p><p>比如，我们知道一个长度为 <span class="math inline">\(n\)</span> 的串中有 <span class="math inline">\(k\)</span> 个长度为 <span class="math inline">\(m\)</span> 的子序列，那么由插板法可得这 <span class="math inline">\(k\)</span> 个子序列会贡献 <span class="math inline">\(C_{n-1}^{m-1}\times k\)</span> 的方案数。</p><p>那么不同子序列个数怎么求呢？显而易见需要 DP，规定 <span class="math inline">\(f_{i,j}\)</span> 表示一个长度为 <span class="math inline">\(i\)</span> 的子序列最后一位为 <span class="math inline">\(s_j\)</span> 的方案数，就可以直接 <span class="math inline">\(f_{i,j}=\sum f_{i-1,k}\)</span>。</p><p>但这样做有一个问题，就是会重复计算。假如原串中在 <span class="math inline">\(i\)</span> 位置有一个 <code>'o'</code>，<span class="math inline">\(i+1\)</span> 位置又有一个 <code>'o'</code>，两个都可以从前面某个位置（假设为 <span class="math inline">\(j\)</span>；假设 <span class="math inline">\(j\)</span> 上其中一个被计入方案数的合法子序列为 <code>"hyac"</code>），那么转移到 <span class="math inline">\(i\)</span> 时，计算了 <code>"hyaco"</code>，到了 <span class="math inline">\(i+1\)</span>，依然可以从 <span class="math inline">\(j\)</span> 处得到 <code>"hyaco"</code>，就会重复计算。</p><p>那么怎么避免这一点呢？对于一个位置 <span class="math inline">\(i\)</span>，假设其上一个相同字母的位置为 <span class="math inline">\(last_i\)</span>，我们规定其仅可从 <span class="math inline">\((last_i,i)\)</span> 进行转移即可（注意两边都是开区间）。</p><p>初始化是对于每一个没有前驱的 <span class="math inline">\(i\)</span>，<span class="math inline">\(f_{1,i}=1\)</span>。</p><p>实现上，因为 <span class="math inline">\(n\)</span> 的大小是 <span class="math inline">\(5\times 10^3\)</span>，转移区间又是连续的，我们用一个前缀和进行优化即可。</p><p>时间复杂度 <span class="math inline">\(O(n^2)\)</span>，应该比官方题解讲的方法具象一些。</p><details><pre class="cpp"><code>#define int long longnamespace XSC062 &#123;using namespace fastIO;const int mod = 1e9 + 7;const int maxn = 5e3 + 5;int n, res;char s[maxn];int fac[maxn];int la[maxn], p[maxn];int f[maxn][maxn], u[maxn][maxn];int max(int x, int y) &#123; return x &gt; y ? x : y; &#125;int qkp(int x, int y) &#123;    int res = 1;    while (y) &#123;        if (y &amp; 1) (res *= x) %= mod;        (x *= x) %= mod, y &gt;&gt;= 1;    &#125;    return res;&#125;int inv(int x) &#123; return qkp(x, mod - 2); &#125;int A(int n, int m) &#123;    return fac[n] * inv(fac[n - m]) % mod;&#125;int C(int n, int m) &#123;    return A(n, m) * inv(fac[m]) % mod;&#125;int main() &#123;    scanf(&quot;%lld %s&quot;, &amp;n, s + 1);    fac[0] = 1;    for (int i = 1; i &lt;= n; ++i) &#123;        la[i] = p[s[i] - &#39;a&#39; + 1];        if (!la[i]) f[1][i] = 1, ++res;        u[1][i] = u[1][i - 1] + f[1][i];        p[s[i] - &#39;a&#39; + 1] = i;        fac[i] = (fac[i - 1] * i) % mod;    &#125;    for (int i = 2; i &lt;= n; ++i) &#123;        int sum = 0;        for (int j = i; j &lt;= n; ++j) &#123;            int k = max(i - 1, la[j] + 1);            if (k &lt;= j - 1)                f[i][j] = (u[i - 1][j - 1] - u[i - 1][k - 1]) % mod;            u[i][j] = (u[i][j - 1] + f[i][j]) % mod;            (sum += f[i][j]) %= mod;        &#125;        res += C(n - 1, i - 1) * sum % mod;        res %= mod;    &#125;    res = (res + mod) % mod;    print(res, &#39;\n&#39;);    return 0;&#125;&#125; // namespace XSC062#undef int</code></pre></details><hr /><h3 id="abc328f---good-set-query">ABC328F - Good Set Query</h3><p><a href="https://atcoder.jp/contests/abc328/tasks/abc328_f" class="uri">https://atcoder.jp/contests/abc328/tasks/abc328_f</a></p><p>一个加权并查集。</p><p>我们用并查集维护关系，在合并两个集合的时候给被合并者的原本根打一个懒标记，意为该并查集需要整体更新的 delta。</p><p>在每次 <code>find</code> 时，路径上的点均从 <strong>直系父亲</strong> 处继承懒标记。然后因为有了路径压缩，所以每个点在查询时均能得到不重复的懒标记（因为自己的祖先已经被直系父亲继承过了）。</p><p>同样也是因为弱势一方才被打标记，保证了根节点上不会有标记，路径压缩后就将父亲更新为根，保证不会因为多次 <code>find</code> 导致标记重复计算。</p><p>每次尝试合并的时候，因为首先需要进行 <code>find</code>，保证 <span class="math inline">\(x\)</span> 和 <span class="math inline">\(y\)</span> 均是最新状态。若 <span class="math inline">\(x\)</span> 和 <span class="math inline">\(y\)</span> 已经在同一个集合了，直接判断两个差值是否为 <span class="math inline">\(d\)</span>；否则，合并两个集合并给弱势方打上标记。</p><details><pre class="cpp"><code>#define int long longnamespace XSC062 &#123;using namespace fastIO;const int maxn = 2e5 + 5;int n, q, x, y, d;int f[maxn], u[maxn];int find(int x) &#123;    if (f[x] == x) return x;    int fa = find(f[x]);    u[x] += u[f[x]];    return f[x] = fa;&#125;bool merge(int x, int y, int d) &#123;    int fx = find(x), fy = find(y);    if (fx == fy) return u[x] - u[y] == d;    f[fx] = fy, u[fx] = d - (u[x] - u[y]);    return 1;&#125;int main() &#123;    read(n), read(q);    for (int i = 1; i &lt;= n; ++i)        f[i] = i;    for (int i = 1; i &lt;= q; ++i) &#123;        read(x), read(y), read(d);        if (merge(x, y, d)) print(i, &#39; &#39;);    &#125;    putchar(&#39;\n&#39;);    return 0;&#125;&#125; // namespace XSC062#undef int</code></pre></details><hr /><h3 id="cf1701f---points">CF1701F - Points</h3><p><a href="http://codeforces.com/problemset/problem/1701/F" class="uri">http://codeforces.com/problemset/problem/1701/F</a></p><p>我们先考虑对于一个单点 <span class="math inline">\(p\)</span>，假设 <span class="math inline">\([p-d, p)\)</span> 中共有 <span class="math inline">\(k\)</span> 个点，那么答案就是 <span class="math inline">\(C_k^2=\dfrac {k(k-1)}2\)</span>。</p><p>假如范围内新加入了一个点，<span class="math inline">\(k\gets k+1\)</span>，那么答案就是 <span class="math inline">\(C_{k+1}^2=\dfrac {k(k+1)}{2}\)</span>，较原来增加了 <span class="math inline">\(k\)</span>。相应地，若范围内减少了一个点，<span class="math inline">\(k\gets k-1\)</span>，答案较原来就会减少 <span class="math inline">\(k-1\)</span>。</p><p>当我们加入一个点 <span class="math inline">\(p\)</span>，区间 <span class="math inline">\((p,p+d]\)</span> 都会收到影响。假设该区间内原本的每个点之 <span class="math inline">\(k\)</span> 的和是 <span class="math inline">\(s_k\)</span>，那么总体的答案就会减少 <span class="math inline">\(s_k\)</span>。</p><p>那么 <span class="math inline">\(s_k\)</span> 怎么去维护呢？插入点 <span class="math inline">\(p\)</span> 时，答案先加上当前 <span class="math inline">\(s_k\)</span> 和新点的 <span class="math inline">\(k\)</span>，再将 <span class="math inline">\((p, p+d]\)</span> 内的 <span class="math inline">\(s_k\)</span> 全部 +1；删除点 <span class="math inline">\(p\)</span> 时，答案减去 <span class="math inline">\(s_k-c\)</span> 和待删点的答案（其中 <span class="math inline">\(c\)</span> 是 <span class="math inline">\((p,p+d]\)</span> 中的点数），再将 <span class="math inline">\((p, p+d]\)</span> 内的 <span class="math inline">\(s_k\)</span> 全部 -1。</p><details><pre class="cpp"><code>#define int long longnamespace XSC062 &#123;using namespace fastIO;const int lim = 2e5;const int maxn = 2e5 + 5;#define lt (p &lt;&lt; 1)#define rt (lt | 1)struct _ &#123; int u, p, d, l, r; &#125;;_ t[maxn &lt;&lt; 2];int q, d, x, res;int min(int x, int y) &#123; return x &lt; y ? x : y; &#125;int max(int x, int y) &#123; return x &gt; y ? x : y; &#125;void pushdown(int p) &#123;    if (t[p].d) &#123;        t[lt].u += t[lt].p * t[p].d;        t[rt].u += t[rt].p * t[p].d;        t[lt].d += t[p].d;        t[rt].d += t[p].d;        t[p].d = 0;    &#125;    return;&#125;void bld(int p, int l, int r) &#123;    t[p].l = l, t[p].r = r;    if (l == r) return;    int mid = (l + r) &gt;&gt; 1;    bld(lt, l, mid), bld(rt, mid + 1, r);    return;&#125;int ask(int p, int l, int r) &#123;    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r)        return t[p].p;    int res = 0, mid = (t[p].l + t[p].r) &gt;&gt; 1;    if (l &lt;= mid) res = ask(lt, l, r);    if (r &gt; mid) res += ask(rt, l, r);    return res;&#125;int qry(int p, int l, int r) &#123;    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r)        return t[p].u;    int res = 0, mid = (t[p].l + t[p].r) &gt;&gt; 1;    pushdown(p);    if (l &lt;= mid) res = qry(lt, l, r);    if (r &gt; mid) res += qry(rt, l, r);    return res;&#125;void upd(int p, int l, int r, int x) &#123;    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r) &#123;        t[p].d += x;        t[p].u += t[p].p * x;        return;    &#125;    int mid = (t[p].l + t[p].r) &gt;&gt; 1;    pushdown(p);    if (l &lt;= mid) upd(lt, l, r, x);    if (r &gt; mid) upd(rt, l, r, x);    t[p].u = t[lt].u + t[rt].u;    return;&#125;void clr(int p, int x) &#123;    --t[p].p;    if (t[p].l == t[p].r) &#123;        res -= t[p].u * (t[p].u - 1) / 2;        t[p].u = t[p].d = t[p].p = 0;        return;    &#125;    int mid = (t[p].l + t[p].r) &gt;&gt; 1;    pushdown(p);    if (x &lt;= mid) clr(lt, x);    else clr(rt, x);    t[p].u = t[lt].u + t[rt].u;    return;&#125;void add(int p, int x, int v) &#123;    ++t[p].p;    if (t[p].l == t[p].r) &#123;        res += v * (v - 1) / 2;        t[p].u = v, t[p].p = 1;        return;    &#125;    int mid = (t[p].l + t[p].r) &gt;&gt; 1;    pushdown(p);    if (x &lt;= mid) add(lt, x, v);    else add(rt, x, v);    t[p].u = t[lt].u + t[rt].u;    return;&#125;void upd(int l, int r, int x) &#123;    upd(1, min(l, lim), min(r, lim), x);    return;&#125;int qry(int l, int r) &#123;    return qry(1, min(l, lim), min(r, lim));&#125;int ask(int l, int r) &#123;    return ask(1, max(1, min(l, lim)), max(1, min(r, lim)));&#125;int main() &#123;    read(q), read(d);    bld(1, 1, lim);    while (q--) &#123;        read(x);        if (ask(x, x)) &#123;            int u = qry(x + 1, x + d) - ask(x + 1, x + d);            res -= u, upd(x + 1, x + d, -1), clr(1, x);        &#125;        else &#123;            int u = qry(x + 1, x + d);            res += u, upd(x + 1, x + d, 1);            add(1, x, ask(x - d, x - 1));        &#125;        print(res, &#39;\n&#39;);    &#125;    return 0;&#125;&#125; // namespace XSC062#undef int</code></pre></details>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>构造</title>
      <link href="/20231005/"/>
      <url>/20231005/</url>
      
        <content type="html"><![CDATA[<p><a href="https://vjudge.net/contest/585791">构造杂题</a>。</p><span id="more"></span><hr /><h3 id="a---errich-tac-toe-hard-version">A - Errich-Tac-Toe (Hard Version)</h3><p><a href="https://vjudge.net/contest/585791#problem/A" class="uri">https://vjudge.net/contest/585791#problem/A</a></p><p>如果我们将地图按国际象棋式斜向黑白染色分组，规定黑组要么黑色要么无色，白组要么白色要么无色，那么这样是一定不会三连击的。</p><p><img src="https://pic.imgdb.cn/item/651e6652c458853aef280846.jpg" /></p><p>容易发现无色格子永远不会被更改，而在方式 A 中被更改的格子在方式 B 中一定不会被更改；相应地，在方式 A 中不被更改的格子在方式 B 中一定会被更改，故两种染色方式更改的格子数总和就是一开始非无色的格子数。所以根据抽屉原理，一定能找到一种染色方式，代价 <span class="math inline">\(\le \dfrac k2\)</span>。</p><p>但是我们要找到的，是代价 <span class="math inline">\(\le \dfrac k3\)</span> 的方案呀？我们观察到我们上面的分组方式，直接让相邻两个不一样了，连二连击都做不到；所以我们要使我们的染色方式更廉价。</p><p>我们仍然斜向染色，但是分为三组：</p><p><img src="https://pic.imgdb.cn/item/651e691fc458853aef28c528.jpg" /></p><p>这样，因为刚才叙述过的原因，一定能找到一种染色方法，代价 <span class="math inline">\(\le \dfrac k3\)</span>。</p><p>枚举三种方式，取代价最小的一种即可。</p><details><pre class="cpp"><code>namespace XSC062 &#123;using namespace fastIO;const int maxn = 305;char a[maxn][maxn];int col[maxn][maxn];int T, n, res, id, typ;int min(int x, int y) &#123; return x &lt; y ? x : y; &#125;int func(int x, int y) &#123;    int res = 0;    for (int i = 1; i &lt;= n; ++i) &#123;        for (int j = 1; j &lt;= n; ++j) &#123;            if (col[i][j] == y)                res += (a[i][j] == &#39;X&#39;);            else if (col[i][j] != x)                res += (a[i][j] == &#39;O&#39;);        &#125;    &#125;    return res;&#125;int main() &#123;    scanf(&quot;%d&quot;, &amp;T);    while (T--) &#123;        scanf(&quot;%d&quot;, &amp;n);        int cnt = 0;        for (int i = 1; i &lt;= n; ++i)            scanf(&quot;%s&quot;, a[i] + 1);        for (int i = 1; i &lt;= n; ++i) &#123;            for (int j = 1; j &lt;= n; ++j)                cnt += (a[i][j] != &#39;.&#39;);            for (int j = 1; j &lt;= i; ++j)                col[j][i - j + 1] = (i - 1) % 3 + 1;        &#125;        for (int i = 2; i &lt;= n; ++i) &#123;            for (int j = 1; j &lt;= n - i + 1; ++j)                col[j + i - 1][n - j + 1] = (n + i - 2) % 3 + 1;        &#125;        res = func(1, 2), id = 1, typ = 2;        if (func(1, 3) &lt; res)            res = func(1, 3), id = 1, typ = 3;        if (func(2, 1) &lt; res)            res = func(2, 1), id = 2, typ = 1;        if (func(2, 3) &lt; res)            res = func(2, 3), id = 2, typ = 3;        if (func(3, 1) &lt; res)            res = func(3, 1), id = 3, typ = 1;        if (func(3, 2) &lt; res)            res = func(3, 2), id = 3, typ = 2;        for (int i = 1; i &lt;= n; ++i) &#123;            for (int j = 1; j &lt;= n; ++j) &#123;                if (col[i][j] == typ) &#123;                    if (a[i][j] == &#39;X&#39;)                        a[i][j] = &#39;O&#39;;                &#125;                else if (col[i][j] != id) &#123;                    if (a[i][j] == &#39;O&#39;)                        a[i][j] = &#39;X&#39;;                &#125;            &#125;        &#125;        for (int i = 1; i &lt;= n; ++i) &#123;            for (int j = 1; j &lt;= n; ++j)                putchar(a[i][j]);            putchar(&#39;\n&#39;);        &#125;    &#125;    return 0;&#125;&#125; // namespace XSC062</code></pre></details><p>抽屉原理是构造中经常用到的手段，后面我们也会遇到运用了抽屉原理的更多题目。</p><hr /><h3 id="b---mine-sweeper-ii">B - Mine Sweeper II</h3><p><a href="https://vjudge.net/contest/585791#problem/B" class="uri">https://vjudge.net/contest/585791#problem/B</a></p><p>观察到答案必须 <span class="math inline">\(\le \dfrac {n\times m}2\)</span>，根据在上一道题目得到的经验，考虑找到两种地位相等、并完全相反的方案。</p><p>我们知道，把 B 变成 A 一定可以满足条件；从「完全相反」出发，考虑把所有雷变成空地、所有空地变成雷。</p><p>将空地上的数字视为由空地向周围八格的雷连边，可以连到的边的数量。将地图完全翻转后，边除了起点和终点翻转之外，<strong>没有任何变化</strong>。所以，数字之和不变。</p><p>由此我们就得到了分两组的方案，由抽屉原理，必有一组方案的代价 <span class="math inline">\(\le \dfrac {n\times m}2\)</span>，取较小者即可。</p><details><pre class="cpp"><code>namespace XSC062 &#123;using namespace fastIO;const int maxn = 1e3 + 5;int n, m, res1, res2;char a[maxn][maxn], b[maxn][maxn];int main() &#123;    scanf(&quot;%d %d&quot;, &amp;n, &amp;m);    for (int i = 1; i &lt;= n; ++i)        scanf(&quot;%s&quot;, a[i] + 1);    for (int i = 1; i &lt;= n; ++i) &#123;        scanf(&quot;%s&quot;, b[i] + 1);        for (int j = 1; j &lt;= m; ++j) &#123;            res1 += (a[i][j] != b[i][j]);            res2 += (a[i][j] == b[i][j]);        &#125;    &#125;    if (res1 &lt; res2) &#123;        for (int i = 1; i &lt;= n; ++i)            puts(a[i] + 1);    &#125;    else &#123;        for (int i = 1; i &lt;= n; ++i) &#123;            for (int j = 1; j &lt;= m; ++j) &#123;                if (a[i][j] == &#39;.&#39;)                    putchar(&#39;X&#39;);                else putchar(&#39;.&#39;);            &#125;            putchar(&#39;\n&#39;);        &#125;    &#125;    return 0;&#125;&#125; // namespace XSC062</code></pre></details><hr /><h3 id="c---ehabs-last-corollary">C - Ehab’s Last Corollary</h3><p><a href="https://vjudge.net/contest/585791#problem/C" class="uri">https://vjudge.net/contest/585791#problem/C</a></p><p>我们尝试证明出题人的猜想……</p><ul><li><p>如果整个图上没有环，就整个一棵树</p>树呢，是一个二分图对不对，然后抽屉原理，我们看两部节点中比较大的那一坨，它的大小一定是 <span class="math inline">\(\ge \dfrac n2\)</span> 又 <span class="math inline">\(\ge \dfrac k2\)</span> 的，直接输出就好了。</li><li>否则，对于一个环，如果它的点数小于等于 <span class="math inline">\(k\)</span>，那我们直接将它作为第二个问题的答案输出。</li><li><p>否则，我们在图的最小环上隔一个点选一个点，一定能选出 <span class="math inline">\(\left\lfloor\dfrac k2\right\rfloor\)</span> 个相互独立的点。你说为什么它们之间没有直接连边呢？因为我们是在一个比 <span class="math inline">\(k\)</span> 大的最小环上选的，要是它们之间有直接连边，那就会又构成一个更小的环了。</p><p>所以我们只需要找到一个最小的环然后按上述操作得到答案…… 然而找最小环这一点本身不太现实……</p><p>这个时候我们怎么办呢？</p><p>我们用一点神奇科技。考虑图的 DFS 树。</p><ul><li>如果有返祖边 <span class="math inline">\((v, u)\)</span>，且深度 <span class="math inline">\(d_v-d_u&lt; k\)</span>，那么 <span class="math inline">\(u\to v\)</span> 在树上的简单路径和返祖边 <span class="math inline">\((v, u)\)</span> 共同构成一个长度不超过 <span class="math inline">\(k\)</span> 的环，直接输出。</li><li><p>否则，因为 <span class="math inline">\(d_v-d_u\ge k\)</span>，有 <span class="math inline">\(d_v\ge k\)</span>，且对于任意 <span class="math inline">\(d_y-d_x&lt;k\)</span>，返祖边 <span class="math inline">\((y,x)\)</span> 不存在。</p><p>我们仍然考虑上面提到的隔一个取一个的方法。从任意 <span class="math inline">\(d_v\ge k\)</span> 开始取点，分别取 <span class="math inline">\(v\)</span> 的 <span class="math inline">\(0\)</span> 代父辈（即自身），<span class="math inline">\(2\)</span> 代父辈（即爷爷），<span class="math inline">\(4\)</span> 代父辈……</p><p>为什么这么取就不会出 bug 呢？因为我们上面提到的「对于任意 <span class="math inline">\(d_y-d_x&lt;k\)</span>，返祖边 <span class="math inline">\((y,x)\)</span> 不存在」，所以不会有杂边干扰。</p></li></ul></li></ul><p>时间复杂度 <span class="math inline">\(O(n + m)\)</span>。只能说真是妙啊。jly 赛高！</p><details><pre class="cpp"><code>namespace XSC062 &#123;using namespace fastIO;const int maxn = 1e5 + 5;bool vis[maxn];int n, m, k, x, y;int f[maxn], dep[maxn];std::vector&lt;int&gt; g[maxn];int col[maxn], cnt[5];void color(int x, int fa, int now) &#123;    col[x] = now, ++cnt[now];    for (auto i : g[x]) &#123;        if (i == fa) continue;        color(i, x, 3 - now);    &#125;    return;&#125;void DFS(int x, int fa) &#123;    vis[x] = 1;    for (auto i : g[x]) &#123;        if (i == fa) continue;        if (vis[i]) &#123;            if (dep[i] &lt; dep[x] &amp;&amp;                dep[x] - dep[i] &lt; k) &#123;                print(2, &#39;\n&#39;);                int p = x, cnt = 1;                while (p != i) ++cnt, p = f[p];                print(cnt, &#39;\n&#39;), p = x;                while (p != i) print(p, &#39; &#39;), p = f[p];                print(i, &#39;\n&#39;), exit(0);            &#125;            continue;        &#125;        f[i] = x;        dep[i] = dep[x] + 1;        DFS(i, x);    &#125;    return;&#125;void add(int x, int y) &#123;    g[x].push_back(y);    return;&#125;int main() &#123;    read(n), read(m), read(k);    for (int i = 1; i &lt;= m; ++i) &#123;        read(x), read(y);        add(x, y), add(y, x);    &#125;    if (m == n - 1) &#123;        print(1, &#39;\n&#39;);        color(1, -1, 1);        k = (k + 1) / 2;        x = cnt[1] &gt; cnt[2] ? 1 : 2;        for (int i = 1; i &lt;= n &amp;&amp; k; ++i) &#123;            if (col[i] == x)                print(i, &#39; &#39;), --k;        &#125;        putchar(&#39;\n&#39;);        return 0;    &#125;    dep[1] = 1, DFS(1, -1);    for (int i = 1; i &lt;= n; ++i) &#123;        if (dep[i] &gt;= k) &#123;            print(1, &#39;\n&#39;);            x = i, k = (k + 1) / 2;            while (k--)                print(x, &#39; &#39;), x = f[f[x]];            putchar(&#39;\n&#39;);            break;        &#125;    &#125;    return 0;&#125;&#125; // namespace XSC062</code></pre></details><hr /><h3 id="d---景点划分">D - 景点划分</h3><p><a href="https://vjudge.net/contest/585791#problem/D" class="uri">https://vjudge.net/contest/585791#problem/D</a></p><details><p><summary>🤡 前言</summary></p><p>你打开了题目。你想，不就是从图里抠两个连通块出来吗，这也能进 IOI？</p><p>你开始打代码。你突然发现不对劲。你抠掉了一个大小为 <span class="math inline">\(a\)</span> 的连通块，然后发现剩下的部分裂成了很多个块，其中根本找不到一个大小 <span class="math inline">\(\ge b\)</span> 的块。</p><p>你发现，事情没有这么简单。</p><p>这是你吗？不，这不是你，这是我，小丑 lym 🤡</p></details><p>不妨设 <span class="math inline">\(a\le b\le c\)</span>，则由抽屉原理，<span class="math inline">\(a\le \dfrac n3\)</span>。</p><p>我们从最特殊的情况开始思考。假如图是树，那么答案怎么求呢？</p><p>对于任意一条边，在其左右两边的连通块中，根据抽屉原理，较大者的大小必定 <span class="math inline">\(\ge \dfrac{n}{2}\)</span>，根据重心的定义，重心必然属于较大连通块。</p><p>后面鸽了。总之先放个代码在这里。</p><details><pre class="cpp"><code>namespace XSC062 &#123;using namespace fastIO;const int maxn = 1e5 + 5;int org[5];bool book[maxn];int solFlag, sumFa, faP;int siz[maxn], col[maxn];int n, m, a, b, c, x, y, P;bool vis[maxn], legSon[maxn];std::vector&lt;int&gt; w[maxn], g[maxn];void DFS(int x, int fa) &#123;    bool flag = 1;    vis[x] = 1, siz[x] = 1;    for (auto i : w[x]) &#123;        if (vis[i]) continue;        DFS(i, x);        if (siz[i] &gt; n / 2) flag = 0;        siz[x] += siz[i];        g[x].push_back(i);    &#125;    if (n - siz[x] &gt; n / 2) flag = 0;    if (flag &amp;&amp; !P) &#123;        P = x, faP = fa;        if (n - siz[x] &gt;= a)            solFlag = fa;        else &#123;            for (auto i : g[x]) &#123;                if (siz[i] &gt;= a) &#123;                    solFlag = i;                    break;                &#125;            &#125;        &#125;    &#125;    return;&#125;void fillA(int x) &#123;    if (a == 0) return;    col[x] = 1, --a;    for (auto i : g[x]) fillA(i);    return;&#125;void fillB(int x) &#123;    if (b == 0) return;    col[x] = 2, --b;    for (auto i : g[x]) &#123;        if (x == P &amp;&amp; i == solFlag)            continue;        fillB(i);    &#125;    return;&#125;void fillC(void) &#123;    for (int i = 1; i &lt;= n; ++i)        if (!col[i]) col[i] = 3;    return;&#125;void DFS1(int x) &#123;    if (!a || x == P) return;    col[x] = 1, --a;    for (auto i : g[x]) DFS1(i);    return;&#125;void DFS2(int x) &#123;    if (b == 0) return;    if (!col[x]) col[x] = 2, --b;    for (auto i : g[x]) DFS2(i);    return;&#125;void func(void) &#123;    int pos[5] = &#123;&#125;;    if (a &gt;= b &amp;&amp; b &gt;= c) // cba        org[1] = 3, org[2] = 2, org[3] = 1;    else if (a &gt;= b &amp;&amp; a &gt;= c) // bca        org[1] = 2, org[2] = 3, org[3] = 1;    else if (a &gt;= b) // bac        org[1] = 2, org[2] = 1, org[3] = 3;    else if (c &gt;= b) // abc        org[1] = 1, org[2] = 2, org[3] = 3;    else if (c &gt;= a) // acb        org[1] = 1, org[2] = 3, org[3] = 2;    else // cab        org[1] = 3, org[2] = 1, org[3] = 2;    pos[1] = a, pos[2] = b, pos[3] = c;    std::sort(pos + 1, pos + 4);    a = pos[1], b = pos[2], c = pos[3];    return;&#125;void ADD(int x) &#123; // 判断儿子是否合法     if (x == P)        return;    book[x] = 1;    for (auto i : w[x]) &#123;        if (i == P &amp;&amp; x != faP) legSon[x] = 1;        if (!book[i]) ADD(i);    &#125;    return;&#125;void DFS3(int x) &#123; // Sub2 染头上     if (!a || x == P) return;    col[x] = 1, --a;    for (auto i : g[x]) DFS3(i);    return;&#125;void DFS4(int x) &#123; // Sub2 染儿子    if (a == 0) return;    col[x] = 1, --a;    for (auto i : g[x]) DFS4(i);    return;&#125;void DFS5(int x) &#123; // Sub2 染 B 色    if (b == 0) return;    col[x] = 2, --b;    for (auto i : g[x]) &#123;        // 如果子树加入了 A        // 那么起码子树的根是会被染的。         if (col[i]) continue;        DFS5(i);    &#125;    return;&#125;int main() &#123;    read(n), read(m);    read(a), read(b), read(c), func();    while (m--) &#123;        read(x), read(y), ++x, ++y;        w[x].push_back(y), w[y].push_back(x);    &#125;    DFS(1, -1);    if (solFlag) &#123;        if (solFlag == faP) DFS1(1), DFS2(P);        else fillA(solFlag), fillB(1);        fillC();    &#125;    else &#123;        ADD(1), sumFa = n - siz[P];        auto now = g[P].begin(), ex = now;        while (sumFa &lt; a) &#123;            while (now != g[P].end() &amp;&amp; !legSon[*now]) ++now;            if (now == g[P].end()) goto noSol;            sumFa += siz[*(ex = now++)];        &#125;        auto pos = g[P].begin();        DFS3(1);        for (;; ++pos) &#123;            if (!legSon[*pos]) continue;            DFS4(*pos);            if (pos == ex) break;        &#125;        DFS5(P), fillC();    &#125;    noSol: ;    for (int i = 1; i &lt;= n; ++i) &#123;    #ifdef ONLINE_JUDGE        print(org[col[i]], &#39; &#39;);    #else        print(col[i], &#39; &#39;);    #endif    &#125;    putchar(&#39;\n&#39;);    return 0;&#125;&#125; // namespace XSC062int main() &#123;    XSC062::main();    return 0;&#125;</code></pre></details><hr /><h3 id="f---strange-housing">F - Strange Housing</h3><p><a href="https://vjudge.net/contest/585791#problem/F" class="uri">https://vjudge.net/contest/585791#problem/F</a></p><p>是难得一见的小清新题目（经历过前两题的洗礼之后）。</p><p>我们从原图中抽一个生成树出来，比如 DFS 树。</p><p>然后我们又知道树是连通二分图，所以我们按照二分图来染色就可以了。</p><p>但这么做有个 bug，就是树里有返祖边，这就可能会导致二分图的一个部分里出现在原图中相连的点。</p><p>所以我们可以换一种思考方式，把二分图的染色方法带到原图里。</p><p>一个点当且仅当周围有染色点或自身为染色点时是可达的。</p><p>对于一个点，我们先检查其周围一圈有没有染色点；如果有就不能染色。在 DFS 遍历的时候直接染色即可。</p><details><pre class="cpp"><code>namespace XSC062 &#123;using namespace fastIO;const int maxn = 3e5 + 5;int col[maxn];bool vis[maxn];int T, n, m, x, y, cnt;std::vector&lt;int&gt; g[maxn];void DFS(int x) &#123;    vis[x] = 1;    for (auto i : g[x]) &#123;        if (col[i] == 1) &#123;            col[x] = 0;            break;        &#125;    &#125;    if (col[x] == -1)        ++cnt, col[x] = 1;    for (auto i : g[x]) &#123;        if (vis[i]) continue;        if (col[x] == 1) col[i] = 0;        DFS(i);    &#125;    return;&#125;void add(int x, int y) &#123;    g[x].push_back(y);    return;&#125;int main() &#123;    read(T);    while (T--) &#123;        read(n), read(m);        for (int i = 1; i &lt;= n; ++i) &#123;            g[i].clear();            g[i].shrink_to_fit();            vis[i] = 0, col[i] = -1;        &#125;        while (m--) &#123;            read(x), read(y);            add(x, y), add(y, x);        &#125;        cnt = 0, DFS(1);        for (int i = 2; i &lt;= n; ++i) &#123;            if (!vis[i]) &#123;                puts(&quot;NO&quot;);                goto noSol;            &#125;        &#125;        puts(&quot;YES&quot;), print(cnt, &#39;\n&#39;);        for (int i = 1; i &lt;= n; ++i) &#123;            if (col[i] == 1)                print(i, &#39; &#39;);        &#125;        putchar(&#39;\n&#39;);        noSol: ;    &#125;    return 0;&#125;&#125; // namespace XSC062</code></pre></details>]]></content>
      
      
      
        <tags>
            
            <tag> 构造 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>情景剧</title>
      <link href="/20231004/"/>
      <url>/20231004/</url>
      
        <content type="html"><![CDATA[<p>Solution to <a href="http://222.180.160.110:61235/contest/4273/problem/1">情景剧</a>。</p><span id="more"></span><hr /><h3 id="a.-情景剧">A. 情景剧</h3><p><a href="http://222.180.160.110:61235/contest/4273/problem/1" class="uri">http://222.180.160.110:61235/contest/4273/problem/1</a></p><blockquote><p>给定序列，求任取一段区间，区间最大值、区间最小值、区间长度之积的最大值。</p><p><span class="math inline">\(N\le 2\times 10^6\)</span>，值域为 <span class="math inline">\(10^9\)</span>。</p></blockquote><p>对于 <span class="math inline">\(a_i\)</span>，假设它是 <span class="math inline">\([X_i, Y_i]\)</span> 内的最大值，且 <span class="math inline">\([X_i, Y_i]\)</span> 是该条件下的极大区间；</p><p>相似地，对于 <span class="math inline">\(a_j\)</span>，假设它是 <span class="math inline">\([P_j, Q_j]\)</span> 内的最小值，且 <span class="math inline">\([P_j, Q_j]\)</span> 是该条件下的极大区间；</p><p>则对于 <span class="math inline">\(a_i\)</span> 作为区间内最大值，<span class="math inline">\(a_j\)</span> 作为区间内最小值的情况，满足该条件的区间为 <span class="math inline">\([\max(X_i, P_j), \min(Y_i, Q_j)]\)</span>，答案为 <span class="math inline">\(k=a_i \times a_j \times [\min(Y_i, Q_j) - \max(X_i, P_j) + 1]\)</span>。我们的目标就是最大化 <span class="math inline">\(k\)</span>。</p><p>两个不固定的值，并且不能拆给斜优做，所以考虑将其中一个变得「固定」。</p><p>观察数组，我们发现，对于数组中的最大值 <span class="math inline">\(a_m\)</span>，有 <span class="math inline">\(X_m = 1,Y_m=n\)</span>。那么此时选取 <span class="math inline">\(a_m\)</span> 作为区间最大值，选取任意数 <span class="math inline">\(a_j\)</span> 作为最小值。这样做可以保证由 <span class="math inline">\(i\)</span> 带来的影响都是最优的，只用枚举 <span class="math inline">\(j\)</span> 并求解即可。此时的答案就是 <span class="math inline">\(a_m\times a_j\times (Q_j-P_j + 1)\)</span>。</p><p>我们上述条件成立的前提是 <span class="math inline">\(i\)</span> 在 <span class="math inline">\([P_j, Q_j]\)</span> 内且 <span class="math inline">\(j\)</span> 在 <span class="math inline">\([X_i, Y_i]\)</span> 内。当 <span class="math inline">\(i\)</span> 取 <span class="math inline">\(m\)</span> 时后者显然成立，但很容易构造出来情况让前者不成立。比如说 <code>15 1 5</code>，当 <span class="math inline">\(j=3\)</span> 时就会得到错误的答案。</p><p>受刚才的思考启发，取 <span class="math inline">\([P_j, Q_j]\)</span> 内的最大值作为 <span class="math inline">\(i\)</span>。此时有 <span class="math inline">\(X_i\le P_j\le Q_j \le Y_j\)</span>，答案为区间内最优。</p><p>接下来需要求解 <span class="math inline">\(P_j\)</span> 和 <span class="math inline">\(Q_j\)</span>。观察数据范围，应该是 <span class="math inline">\(O(n)\)</span> 做法。不难想到单调栈，可惜我不会，所以采用同样是 <span class="math inline">\(O(n)\)</span> 的悬线法（<a href="/20220927">我的博客：有关悬线法的介绍</a>）。</p><p>那么怎么求 <span class="math inline">\([P_j,Q_j]\)</span> 内的最大值呢？当遇到这种求解区间与左右端点一致，并且待求满足可加性的情况时，我们可以在悬线的时候一起求解。当悬线跨越一个区间时，我们直接用这个已求解区间的最大值更新当前求的最大值。</p><p>左右分别求最大值（注意要用两个数组分别记录，防止错误更新），最后取两者较大作为最终区间内最大值即可。</p><p>最终时间复杂度 <span class="math inline">\(O(n)\)</span>。</p><details><p><summary>🌼 鲜花</summary></p><p>不知道为什么听别人说很卡，不卡啊，我一个点 250ms。</p><p>啊什么你们打的 <span class="math inline">\(O(n\log n)\)</span>？因为单调栈信息断层不能维护区间内最大值？菜。那我必须把这篇发出来嘲讽你们了。兔子说要是不打 <code>fread</code> Lemon 上就会起飞，我说我打了，我还疑惑 <span class="math inline">\(O(n)\)</span> 跑 <code>2e6</code> 普通快读怎么会寄呢。一问，啊，带 <span class="math inline">\(\log\)</span>，菜。</p><p>啊什么谭委员带 <span class="math inline">\(\log\)</span> 一个点只要 500ms？那也比我慢，菜。</p></details><p>说起来这是我头一次用悬线解决不在矩阵上，还要维护信息的题，之前并没有细想过单调栈和悬线可维护的信息差异，这次算是误打误撞做对了。</p><p>注意到数据范围，应该要开 <code>__int128</code> 吧。</p><details><pre class="cpp"><code>#define int __int128namespace XSC062 &#123;using namespace fastIO;const int maxn = 2e6 + 5;int a[maxn];int n, mx, res;int l[maxn], r[maxn];int mxl[maxn], mxr[maxn];int max(int x, int y) &#123; return x &gt; y ? x : y; &#125;int main() &#123;    read(n), l[0] = 1;    for (int i = 1; i &lt;= n; ++i) &#123;        read(a[i]), l[i] = i;        mxl[i] = mxr[i] = a[i];        while (l[i] &gt; 1 &amp;&amp; a[l[i] - 1] &gt;= a[i]) &#123;            mxl[i] = max(mxl[i], mxl[l[i] - 1]);            l[i] = l[l[i] - 1];        &#125;    &#125;    r[n + 1] = n;    for (int i = n; i; --i) &#123;        r[i] = i;        while (r[i] &lt; n &amp;&amp; a[r[i] + 1] &gt;= a[i]) &#123;            mxr[i] = max(mxr[i], mxr[r[i] + 1]);            r[i] = r[r[i] + 1];        &#125;        res = max(res, max(mxl[i], mxr[i]) * a[i] * (r[i] - l[i] + 1));    &#125;    print(res, &#39;\n&#39;);    return 0;&#125;&#125; // namespace XSC062#undef int</code></pre></details><hr /><p><em>upd on 240704</em></p><p>我们在 <a href="/20220927">这篇博客</a> 中提到了悬线的本质是笛卡尔树，而本题就是其链上爬山维护数据的一个优秀体现，也是因为这一点，应该更加深切地认识到悬线包含式的访问顺序使之维护的数据类型应和倍增 / 树状数组等类似。</p><p>所以说到可维护数据的复杂程度，笛卡尔树严格大于悬线严格大于单调栈好吧 <img src="/em/dy.gif" /></p><p>虽然现在全世界都知道我是悬线魔怔人了 <img src="/em/dy.gif" /></p>]]></content>
      
      
      
        <tags>
            
            <tag> 悬线法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>杂题</title>
      <link href="/20231004-1/"/>
      <url>/20231004-1/</url>
      
        <content type="html"><![CDATA[<p><a href="http://222.180.160.110:61235/contest/4272">牛客普及</a>。</p><span id="more"></span><hr /><h3 id="a.-学习求余">A. 学习求余</h3><p><a href="http://222.180.160.110:61235/contest/4272/problem/1" class="uri">http://222.180.160.110:61235/contest/4272/problem/1</a></p><p>今天我们来学习求余！这种题放普及 T1 不合适吧！</p><p>令 <span class="math inline">\(k=\left\lfloor \dfrac n2 \right\rfloor + 1\)</span>，直接输出 <span class="math inline">\(k\times (n - k)\)</span> 即可。</p><details><p><summary>我是不是证复杂了…</summary></p><p>我们可以简单地发现一个道理，对于任意 <span class="math inline">\(\dfrac n2&lt;x\le n\)</span>，<span class="math inline">\(n\bmod x\)</span> 的值是 <span class="math inline">\(n - x\)</span>；</p><p>根据基本不等式（<del>wjs 直接感动得哭出声来</del>）或小学知识「和不变，差小积大」，我们可以知道当 <span class="math inline">\(x=\left\lfloor \dfrac n2 \right\rfloor + 1\)</span> 时，<span class="math inline">\(x\times (n-x)\)</span> 取最大值。</p><p>故有：当 <span class="math inline">\(x=\left\lfloor \dfrac n2 \right\rfloor + 1\)</span> 时，<span class="math inline">\(x\times (n\bmod x)\)</span> 取最大值。</p><p>而对于 <span class="math inline">\(y\le \dfrac n2\)</span>，由余数小于除数得，<span class="math inline">\(n\bmod y&lt;y\le \dfrac n2\)</span>。由于 <span class="math inline">\(0&lt;y&lt;x=\left\lfloor \dfrac n2 \right\rfloor + 1\)</span> 且 <span class="math inline">\(0\le n\bmod y\le \left\lfloor \dfrac n2 \right\rfloor - 1\le n - \left\lfloor \dfrac n2 \right\rfloor - 1=n\bmod x\)</span>，由不等式的基本性质得 <span class="math inline">\(x\times(n\bmod x)&gt;y\times (n\bmod y)\)</span>。</p><p>综上，对于 <span class="math inline">\(1\le x\le n\)</span>，当 <span class="math inline">\(x=\left\lfloor \dfrac n2 \right\rfloor + 1\)</span> 时，<span class="math inline">\(x\times (n\bmod x)\)</span> 有最大值。</p></details><p>然后如果你要问我怎么发现这一点的呢，我当时没有思路，然后随手输出了 <span class="math inline">\(n=100\)</span> 时 <span class="math inline">\(n\bmod i\)</span> 的所有值。然后发现 <span class="math inline">\(k=51\)</span> 时余数是 <span class="math inline">\(49\)</span>…… 然后就会了。</p><details><pre class="cpp"><code>#define int long longnamespace XSC062 &#123;using namespace fastIO;int n, k;int main() &#123;    read(n), k = n / 2 + 1;    print(k * (n % k));    return 0;&#125;&#125; // namespace XSC062#undef int</code></pre><p><del>头一次在题解里贴这么短的代码</del></p></details><hr /><h3 id="b.-提取数字">B. 提取数字</h3><p><a href="http://222.180.160.110:61235/contest/4272/problem/2" class="uri">http://222.180.160.110:61235/contest/4272/problem/2</a></p><p>我被这道题（疑似 T1）坑到了！交了三遍才过！这合理吗？</p><p>首先要开 <code>long long</code>！然后注意，你的判定条件应为「当前是否已存储数」而非「当前存数变量是否为 0」！因为数据中会有单个 0 的情况出现！</p><p>然后就没有了。</p><details><pre class="cpp"><code>#define int long longnamespace XSC062 &#123;using namespace fastIO;const int maxn = 1e5 + 5;bool flag;char s[maxn]; int n, ans, cnt;int main() &#123;    scanf(&quot;%*s %s&quot;, s + 1);    n = strlen(s + 1);    for (int i = 1; i &lt;= n; ++i) &#123;        if (s[i] &gt;= &#39;0&#39; &amp;&amp; s[i] &lt;= &#39;9&#39;)            cnt = cnt * 10 + s[i] - &#39;0&#39;, flag = 1;        else if (flag)            ans += (cnt + 5), cnt = 0, flag = 0;    &#125;    if (flag) ans += (cnt + 5);    print(ans, &#39;\n&#39;);    return 0;&#125;&#125; // namespace XSC062#undef int</code></pre></details><hr /><h3 id="c.-武器选择">C. 武器选择</h3><p><a href="http://222.180.160.110:61235/contest/4272/problem/3" class="uri">http://222.180.160.110:61235/contest/4272/problem/3</a></p><details><p><summary>首先是我想了半个小时的狂拽酷炫吊炸天的法一：离线</summary></p><p>我当时一边打一边怀疑现在的普及组是什么神仙，T3 考这么神奇的离线，难道是我落后于时代了？</p><p>（之所以认为这是 T3 是因为括号那道题确实是正常 T4 风格）</p><p>我们预处理出对于每一个可能获得武器 <span class="math inline">\(i\)</span> 的位置，应该从哪个位置第一次捡到武器 <span class="math inline">\(i\)</span>，由于这一段内的所有武器 <span class="math inline">\(i\)</span> 都需要被拾取，我们将其作为区间 <span class="math inline">\([L_i, R_i]\)</span> 来记录。</p><p>那么询问可以转化为，在 <span class="math inline">\([l, r]\)</span> 内 <strong>不同颜色</strong> <span class="math inline">\([L_i, R_i]\)</span> 的数量。</p><p>考虑将询问离线。将询问按左端点从大到小排序，信息区间 <span class="math inline">\([L_i, R_i]\)</span> 也按左端点从大到小排序。</p><p>对于每次询问 <span class="math inline">\(l, r\)</span>，在树状数组中将被 <span class="math inline">\([l, n]\)</span> 完全包含的所有 <span class="math inline">\([L_i, R_i]\)</span>（其实就是 <span class="math inline">\(l\le L_i\)</span> 的所有 <span class="math inline">\(L_i\)</span>）在右端点 <span class="math inline">\(R_i\)</span> 处加一，我们就统计到了可以捡到武器的所有位置。</p><p>怎么区分颜色呢？很简单，我们让每个颜色只被算一次。算哪一次呢？就算当前已加入的 <span class="math inline">\([L_i, R_i]\)</span> 内，比选中概率最大的一次。</p><p>我们树状数组统计的是 <span class="math inline">\([1, r]\)</span> 内的值，所以我们要让概率最大的话，就要让 <span class="math inline">\(R_i\)</span> 尽量的小。</p><p>我们记录每个颜色当前合法 <span class="math inline">\([L_i, R_i]\)</span> 的最小右端点 <span class="math inline">\(\min_R\)</span>。加入一个新的 <span class="math inline">\([L_i, R_i]\)</span> 时，如果 <span class="math inline">\(R_i\ge \min_R\)</span>，那么不会产生影响，跳过；否则，当 <span class="math inline">\(R_i&lt;\min_R\)</span> 时，我们就要先消除当前 <span class="math inline">\(\min_R\)</span> 的影响（即在树状数组中将该位置加上的 1 减去），再加上 <span class="math inline">\(R_i\)</span> 的影响（即在树状数组中加上该位置的 1）。</p><p>此时我们对 <span class="math inline">\([1, r]\)</span> 的询问就是答案。</p><p>复杂度 <span class="math inline">\(O(n\log n + m\log m + m\log n)\)</span>，其中 <span class="math inline">\(n\log n\)</span> 来自于对 <span class="math inline">\([L_i, R_i]\)</span> 的排序，<span class="math inline">\(m\log m\)</span> 来自于对询问的排序，<span class="math inline">\(m\log n\)</span> 来自于离线树状数组。</p></details><p>接下来讲题解给的正解…… 这个是真的妙。</p><p>考虑所有种类数，在 <span class="math inline">\(n\)</span> 个数内满足条件的种类 <span class="math inline">\(x\)</span> 最优条件下也不过 <span class="math inline">\(\dfrac {x\times (x+1)}2=n\)</span>，所以满足条件武器的数量最多只有 <span class="math inline">\(\sqrt n\)</span> 级别。</p><p>所以我们对所有合法种类做前缀和，每次询问检查所有合法种类是否在该区间内出现对应次数，然后统计答案。复杂度 <span class="math inline">\(O(m\sqrt n + n\sqrt n)\)</span>。<span class="math inline">\(n\sqrt n\)</span> 是前面前缀和来的，<span class="math inline">\(m\sqrt n\)</span> 是暴力统计来的。</p><p>但是根号可耻，所以我的法一更 NB！！！🤡🤡🤡</p><details><p><summary>狂拽酷炫吊炸天的法一代码</summary></p><pre class="cpp"><code>#define int long longnamespace XSC062 &#123;using namespace fastIO;const int maxn = 1e5 + 5;struct _ &#123;    int l, r, k, i;    bool operator&lt; (const _ &amp;q) const &#123;        return l &lt; q.l;    &#125;&#125;;struct __ &#123;    int l, r, nxt, x;    bool operator&lt; (const __ &amp;q) const &#123;        return l &lt; q.l;    &#125;&#125;;_ q[maxn];__ a[maxn];std::map&lt;int, int&gt; t;std::vector&lt;int&gt; u[maxn];int ans[maxn], now[maxn];int mnr[maxn], Bit[maxn];int n, m, tot, x, cnt, pos;int lowbit(int x) &#123; return x &amp; -x; &#125;void add(int x, int v) &#123;    for (int i = x; i &lt;= n; i += lowbit(i))        Bit[i] += v;    return;&#125;int ask(int x) &#123;    int res = 0;    for (int i = x; i; i -= lowbit(i))        res += Bit[i];    return res;&#125;int calc(int x, int k) &#123;    int res = 1;    for (int i = 1; i &lt;= k; ++i)        res *= x--;    for (int i = 1; i &lt;= k; ++i)        res /= i;    return res;&#125;int main() &#123;    read(n);    for (int i = 1; i &lt;= n; ++i) &#123;        read(x);        if (!t.count(x)) t[x] = ++tot;        int id = t[x];        u[id].push_back(i);        if ((int)u[id].size() &gt;= x) &#123;            a[++cnt].l = u[id][(int)u[id].size() - x];            a[cnt].r = i, a[now[id]].nxt = cnt;            a[cnt].x = x, mnr[x] = n + 1;            now[id] = cnt;        &#125;    &#125;    read(m);    for (int i = 1; i &lt;= m; ++i) &#123;        read(q[i].l), read(q[i].r);        read(q[i].k), q[i].i = i;    &#125;    std::sort(q + 1, q + m + 1);    std::sort(a + 1, a + cnt + 1);    pos = cnt;    for (int i = m; i; --i) &#123;        while (a[pos].l &gt;= q[i].l) &#123;            if (a[pos].r &lt; mnr[a[pos].x]) &#123;                if (mnr[a[pos].x] &lt;= n)                    add(mnr[a[pos].x], -1);                add(a[pos].r, 1);                mnr[a[pos].x] = a[pos].r;            &#125;            --pos;        &#125;        ans[q[i].i] = calc(ask(q[i].r), q[i].k);    &#125;    for (int i = 1; i &lt;= m; ++i)        print(ans[i], &#39;\n&#39;);    return 0;&#125;&#125; // namespace XSC062#undef int</code></pre><p>我甚至打完了就过了样例然后直接就 A 了，好久没有这么爽地过过这种大码量 <del>正确性还未知</del> 的题了。</p></details><p>而且我相信全场只有我一个 <del>小丑</del> 帅哥打离线，所以我是最强的！！！🤡🤡🤡</p><details><p><summary>绝对不如法一的法二代码</summary></p><pre class="cpp"><code>#define int long longnamespace XSC062 &#123;using namespace fastIO;const int maxm = 505;const int maxn = 1e5 + 5;int a[maxn];int cnt[maxn];int sum[maxm][maxn];int n, tot, m, l, r, k, res;int calc(int x, int k) &#123;    int res = 1;    for (int i = 1; i &lt;= k; ++i)        res *= x--;    for (int i = 1; i &lt;= k; ++i)        res /= i;    return res;&#125;int main() &#123;    read(n);    for (int i = 1; i &lt;= n; ++i) &#123;        read(a[i]);        if (a[i] &lt;= n) ++cnt[a[i]];    &#125;    for (int i = 1; i &lt;= n; ++i) &#123;        if (cnt[i] &gt;= i) &#123;            sum[++tot][n + 1] = i;            for (int j = 1; j &lt;= n; ++j)                sum[tot][j] = sum[tot][j - 1] + (a[j] == i);        &#125;    &#125;    read(m);    while (m--) &#123;        read(l), read(r), read(k);        res = 0;        for (int i = 1; i &lt;= tot; ++i)            res += (sum[i][r] - sum[i][l - 1] &gt;= sum[i][n + 1]);        print(calc(res, k), &#39;\n&#39;);    &#125;    return 0;&#125;&#125; // namespace XSC062#undef int</code></pre></details><hr /><h3 id="d.-括号序列">D. 括号序列</h3><p>http://222.180.160.110:61235/contest/4272/problem/4</p><p>呃呃呃，这，有什么好讲的吗？做过原题的应该都会吧……</p><p>反正就是个比较裸的区间 DP，转移的时候注意一下究竟哪些是同一对括号，哪些是相邻括号就好。</p><p>复杂度 <span class="math inline">\(O(n^2)\)</span>。</p><details><pre class="cpp"><code>namespace XSC062 &#123;using namespace fastIO;const int maxn = 1e3 + 5;int n, res;char s[maxn];std::stack&lt;int&gt; t;int mat[maxn], c[5];int f[maxn][maxn][3][3];int max(int x, int y) &#123; return x &gt; y ? x : y; &#125;void upd(int &amp;x, int y) &#123; x = max(x, y); return; &#125;int main() &#123;    memset(f, -0x3f, sizeof (f));    scanf(&quot;%d %d %d&quot;, &amp;n, &amp;c[1], &amp;c[2]);    scanf(&quot;%s&quot;, s + 1);    for (int i = 1; i &lt;= n; ++i) &#123;        if (s[i] == &#39;(&#39;) t.push(i);        else mat[t.top()] = i, t.pop();    &#125;    for (int i = 1; i &lt;= n; ++i) &#123;        if (mat[i] == i + 1) &#123;            for (int k = 0; k &lt;= 2; ++k)                f[i][i + 1][k][k] = c[k];        &#125;    &#125;    for (int l = 4; l &lt;= n; l += 2) &#123;        for (int i = 1; i &lt;= n - l + 1; ++i) &#123;            int j = i + l - 1;            if (mat[i] == j) &#123;                // ((...))                // xy...zx                for (int x = 0; x &lt;= 2; ++x) &#123;                    for (int y = 0; y &lt;= 2; ++y) &#123;                        if (y == x) continue;                        for (int z = 0; z &lt;= 2; ++z) &#123;                            if (z == x) continue;                            upd(f[i][j][x][x], f[i + 1][j - 1][y][z] + c[x]);                        &#125;                    &#125;                &#125;            &#125;            else &#123;                // ()(...)                // xxy...z                for (int x = 0; x &lt;= 2; ++x) &#123;                    for (int y = 0; y &lt;= 2; ++y) &#123;                        if (y == x) continue;                        for (int z = 0; z &lt;= 2; ++z)                            upd(f[i][j][x][z], f[i][mat[i]][x][x] + f[mat[i] + 1][j][y][z]);                    &#125;                &#125;            &#125;        &#125;    &#125;    for (int i = 0; i &lt;= 2; ++i) &#123;        for (int j = 0; j &lt;= 2; ++j)            res = max(res, f[1][n][i][j]);    &#125;    print(res, &#39;\n&#39;);    return 0;&#125;&#125; // namespace XSC062</code></pre></details>]]></content>
      
      
      
        <tags>
            
            <tag> 树状数组 </tag>
            
            <tag> 区间 DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>杂题</title>
      <link href="/20231003/"/>
      <url>/20231003/</url>
      
        <content type="html"><![CDATA[<p><a href="http://222.180.160.110:61235/contest/4268">周考 14</a>。</p><span id="more"></span><hr /><p>医生问我对药有什么要求吗，我说我宁死不喝冲剂。</p><p>然后医生给我开了五盒胶囊，告诉我说一天三次，一次六个。</p><p>哈哈哈，我自找的。以此为证，A 一道题磕一片！！！</p><hr /><h3 id="a.-修改序列">A. 修改序列</h3><p><a href="http://222.180.160.110:61235/contest/4268/problem/1" class="uri">http://222.180.160.110:61235/contest/4268/problem/1</a></p><p>注意到一增一减，全数列的和 <span class="math inline">\(s\)</span> 不变，考虑这一点带来的提示。</p><p>假设最后要求一部分数为 <span class="math inline">\(p\)</span>，另一部分为 <span class="math inline">\(p+1\)</span>，那么有 <span class="math inline">\(p = \lfloor \dfrac sn \rfloor\)</span>，<span class="math inline">\(p+1\)</span> 的数量 <span class="math inline">\(c_r=s\bmod n\)</span>，<span class="math inline">\(p\)</span> 的数量 <span class="math inline">\(c_l=n-c_r\)</span>。</p><p>那么我们让 <span class="math inline">\(\le p\)</span> 的变成 <span class="math inline">\(p\)</span>，<span class="math inline">\(\ge p + 1\)</span> 的变成 <span class="math inline">\(p + 1\)</span>。直接求两数距离，最后将总和除以二即为答案、</p><details><p><summary>正确性证明…</summary></p><p>这样做的最优性毫无疑问，问题无非就在于这么做的正确性，换言之，为什么一定能找到合法的操作序列还原我们的求解过程。</p><p>将原数列分为两部分，数值 <span class="math inline">\(\le p\)</span> 的（记为 <span class="math inline">\(X\)</span>）和数值 <span class="math inline">\(\ge p + 1\)</span> 的（记为 <span class="math inline">\(Y\)</span>）。</p><p>再把我们的目标状态分为两部分，数值 <span class="math inline">\(= p\)</span> 的（记为 <span class="math inline">\(A\)</span>）和 数值 <span class="math inline">\(=p + 1\)</span> 的（记为 <span class="math inline">\(B\)</span>）。</p><p>那么有 <span class="math inline">\(\begin{cases}X+Y=s\\A+B=s\end{cases}\)</span>，由等式的基本性质得 <span class="math inline">\(X-A+Y-B = 0\)</span>，移项得 <span class="math inline">\(Y-B=A-X\)</span>。也就是说，<span class="math inline">\(Y\)</span> 部分与 <span class="math inline">\(p+1\)</span> 的差的总和正好等于 <span class="math inline">\(X\)</span> 部分与 <span class="math inline">\(p\)</span> 的差的总和。</p><p>这个时候我们的正确性就有了保证。</p><p>这个时候你可能就有疑问了，<span class="math inline">\(X,Y\)</span> 中的元素个数和 <span class="math inline">\(A,B\)</span> 中的元素个数并不对应，怎么办呢？</p><p>我们发现上面的原理式并不会随元素个数的变化而变化，所以依然可以用它来解答这个问题。没有人规定 <span class="math inline">\(Y-B\)</span> 和 <span class="math inline">\(A-X\)</span> 不能为负，为负时我们把 <span class="math inline">\(A\)</span> 中塞不下的 <span class="math inline">\(X\)</span> 拿到 <span class="math inline">\(B\)</span> 里面去即可，反之同理。</p></details><p>那么代码还是很好写的。时间复杂度 <span class="math inline">\(O(n)\)</span>。</p><details><pre class="cpp"><code>namespace XSC062 &#123;using namespace fastIO;const int maxn = 2e5 + 5;int a[maxn];int n, s, p, cl, cg, res;int main() &#123;    read(n);    for (int i = 1; i &lt;= n; ++i)        read(a[i]), s += a[i];    p = s / n, cg = s - p * n, cl = n - cg;    for (int i = 1; i &lt;= n; ++i) &#123;        if (a[i] &lt;= p) &#123;            if (cl) res += p - a[i], --cl;            else res += p - a[i] + 1, --cg;        &#125;        else &#123;            if (cg) res += a[i] - p - 1, --cg;            else res += a[i] - p, --cl;        &#125;    &#125;    print(res / 2, &#39;\n&#39;);    return 0;&#125;&#125; // namespace XSC062</code></pre></details><hr /><h3 id="b.-knuth-表示法">B. Knuth 表示法</h3><p><a href="http://222.180.160.110:61235/contest/4268/problem/2" class="uri">http://222.180.160.110:61235/contest/4268/problem/2</a></p><p>模拟。输入的数用 <code>map</code> 转化为 <span class="math inline">\(10\)</span> 的次幂形式，然后幂次直接相加即表示指数相乘。</p><p>最后按位数从大到小将次幂形式转化为字符串、再按位数从小到大输出。</p><p>注意到开头的字符串不是 <code>one</code> 就是 <code>ten</code>，需要在没有抽出来 <code>ten</code> 的时候补 <code>one</code>。</p><details><pre class="cpp"><code>namespace XSC062 &#123;using namespace fastIO;using str = std::string;const str u[] = &#123; &quot;one&quot;, &quot;ten&quot;, &quot;hundred&quot;, &quot;myriad&quot;, &quot;myllion&quot;, &quot;byllion&quot;, &quot;tryllion&quot;,                  &quot;quadryllion&quot;, &quot;quintyllion&quot;, &quot;sextyllion&quot;, &quot;septyllion&quot;, &quot;octyllion&quot;,                  &quot;nonyllion&quot;, &quot;decyllion&quot; &#125;;str x;int res = 0;std::stack&lt;str&gt; s;std::map&lt;str, int&gt; t;void get(str &amp;x) &#123;    str y;    std::stringstream p(x);    while (p &gt;&gt; y) &#123;        if (y == &quot;one&quot;) continue;        res += 1 &lt;&lt; (t[y] - 1);    &#125;    return;&#125;int main() &#123;    for (int i = 0; i &lt;= 13; ++i) t[u[i]] = i;    std::getline(std::cin, x), get(x);    std::getline(std::cin, x), get(x);    for (int i = 13; i; --i) &#123;        if (res &amp; (1 &lt;&lt; (i - 1)))            s.push(u[i]), res ^= (1 &lt;&lt; (i - 1));    &#125;    if (s.top() != &quot;ten&quot;) s.push(&quot;one&quot;);    while (!s.empty())        std::cout &lt;&lt; s.top() &lt;&lt; &#39; &#39;, s.pop();    return 0;&#125;&#125; // namespace XSC062</code></pre></details><hr /><h3 id="c.-魔力塔">C. 魔力塔</h3><p><a href="http://222.180.160.110:61235/contest/4268/problem/3" class="uri">http://222.180.160.110:61235/contest/4268/problem/3</a></p><p>神奇的线段树优化建图。这拿来放 T3？不合适吧。</p><p>很好想到对于 <span class="math inline">\(a_i\ne -1\)</span>，连边 <span class="math inline">\(i\to a_i\)</span>；否则，连边 <span class="math inline">\(i\to x(x\in [i+1,\min(i + k,n+1)])\)</span>。BFS 遍历，复杂度 <span class="math inline">\(O(n\times k)\)</span>。</p><p>问题在于无用边太多，例如 <span class="math inline">\(i\)</span> 和 <span class="math inline">\(i+1\)</span> 共同可达的点有整整 <span class="math inline">\(k-1\)</span> 个，造成大量浪费。</p><p>考虑到实际进入 BFS 的点只有 <span class="math inline">\(n\)</span> 个，及由传送门构成的连通块均呈棒棒糖状（即链套环），我们直接优化掉 <span class="math inline">\(a_i=-1\)</span> 时的连边。使用线段树查询 <span class="math inline">\([i+1,\min(i + k,n+1)]\)</span> 内的所有剩余点，连边入队并从线段树中删除。</p><p>这样，每个点只会入队一次（忽视无用环），时间复杂度控制在 <span class="math inline">\(O(n\log n)\)</span>，<span class="math inline">\(\log\)</span> 来源于线段树，写得不好就是 <span class="math inline">\(\log^2\)</span>，写得好一点就只有一个。</p><details><p><summary>然而…</summary></p><p>会 T，因为常数太大了。</p><p>所以我们需要另一种 <span class="math inline">\(\log\)</span> 的做法，并且短小精悍。</p><p>用 <code>set</code> 存储所有未入队的点，每次 <code>lower_bound</code> 并依次弹出、入队。</p></details><p>用迭代器的话代码很短，美汁汁。</p><p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>，但等我先磕片药先。</p><details><pre class="cpp"><code>namespace XSC062 &#123;using namespace fastIO;const int maxn = 5e5 + 5;int a[maxn];int n, k, res;bool vis[maxn];std::set&lt;int&gt; t;std::vector&lt;int&gt; g[maxn]; int max(int x, int y) &#123; return x &gt; y ? x : y; &#125;void DFS(int x) &#123;    res = max(res, x);    if (a[x] == -1) &#123;        auto p = t.lower_bound(x + 1);        while (p != t.end() &amp;&amp; *p &lt;= x + k) &#123;            g[x].push_back(*p);            t.erase(*p++);        &#125;    &#125;    for (auto i : g[x]) &#123;        if (vis[i]) continue;        vis[i] = 1, DFS(i);    &#125;    return;&#125;int main() &#123;    read(n), read(k);    for (int i = 1; i &lt;= n; ++i) &#123;        read(a[i]), t.insert(i + 1);        if (~a[i]) g[i].push_back(a[i]);    &#125;    DFS(1), print(res, &#39;\n&#39;);    return 0;&#125;&#125; // namespace XSC062</code></pre></details><hr /><h3 id="d.-卡牌游戏">D. 卡牌游戏</h3><p><a href="http://222.180.160.110:61235/contest/4268/problem/4" class="uri">http://222.180.160.110:61235/contest/4268/problem/4</a></p><p>怎么说呢，爆搜可以拿 80pts！！！然而正解是区间 DP，哭唧唧。他这个数据范围给得很神奇，让人只会往搜索上面想。</p><p>摧毁操作是一换一，不会更改串长，而入栈操作会增加初始串的长度。</p><p>所以我们考虑 <strong>逆序 DP</strong>，从最终状态入手，用 <span class="math inline">\(f_{x, i, j}\)</span> 表示是否可以使用一个字符 <span class="math inline">\(x\)</span> 经过一系列操作消掉 <span class="math inline">\(w_{i\sim j}\)</span>。</p><p>那么明显若一条摧毁操作为可用字符 <span class="math inline">\(a\)</span> 摧毁 <span class="math inline">\(w_i\)</span>，有 <span class="math inline">\(f_{a, i, i} = 1\)</span>。</p><p>若一条入栈操作为用字符 <span class="math inline">\(a\)</span> 换字符 <span class="math inline">\(b,c\)</span>，枚举区间断点 <span class="math inline">\(k\)</span>，有 <span class="math inline">\(f_{a, i, j} = f_{b, i, k} \times f_{c, k + 1, j}\)</span>。</p><p>最后答案为 <span class="math inline">\(f_{\texttt S,i,|w_i|}\)</span>。</p><p>注意循环顺序，区间的枚举应在字符的枚举之外。最终时间复杂度 <span class="math inline">\(O(T\times |w_i|^3\times N_2)\)</span>，注意到字母的枚举属于常数。胶囊好吃滴捏。</p><details><pre class="cpp"><code>namespace XSC062 &#123;using namespace fastIO;const int maxn = 25;const int maxm = 1e3 + 5;int n, m, l;char w[maxn];bool r1[maxm][maxm];bool f[maxm][maxn][maxn];struct &#123; int u, a, b; &#125; r2[maxn];int main() &#123;    scanf(&quot;%d %d&quot;, &amp;n, &amp;m);    for (int i = 1; i &lt;= n; ++i) &#123;        scanf(&quot;%s&quot;, w + 1);        r1[(int)w[1]][(int)w[4]] = 1;    &#125;    for (int i = 1; i &lt;= m; ++i) &#123;        scanf(&quot;%s&quot;, w + 1);        r2[i].u = w[1];        r2[i].a = w[4], r2[i].b = w[5];    &#125;    while (~scanf(&quot;%s&quot;, w + 1)) &#123;        memset(f, 0, sizeof (f));        l = strlen(w + 1);        for (int i = &#39;A&#39;; i &lt;= &#39;Z&#39;; ++i) &#123;            for (int j = 1; j &lt;= l; ++j) &#123;                if (r1[i][(int)w[j]])                    f[i][j][j] = 1;            &#125;        &#125;        for (int len = 1; len &lt;= l; ++len) &#123;            for (int i = 1; i &lt;= l - len + 1; ++i) &#123;                int j = i + len - 1;                for (int t = &#39;A&#39;; t &lt;= &#39;Z&#39;; ++t) &#123;                    for (int k = i; k &lt; j; ++k) &#123;                        for (int p = 1; p &lt;= m; ++p) &#123;                            if (r2[p].u != t) continue;                            f[t][i][j] |= f[r2[p].a][i][k] &amp;&amp; f[r2[p].b][k + 1][j];                        &#125;                    &#125;                &#125;            &#125;        &#125;        puts(f[&#39;S&#39;][1][l] ? &quot;YES&quot; : &quot;NO&quot;);    &#125;    return 0;&#125;&#125; // namespace XSC062</code></pre></details><hr /><h3 id="e.-生长树">E. 生长树</h3><p><a href="http://222.180.160.110:61235/contest/4268/problem/5" class="uri">http://222.180.160.110:61235/contest/4268/problem/5</a></p><p>一道很菜的题。我们发现有子树操作，第一时间想到树剖，那么接下来要考虑的内容就是线段树如何维护。</p><p>题意换句话说就是往下数 0 代是加，数 1 代是减，数 2 代是加，以此类推。那么不难想到奇偶性。</p><p>如果起点的深度是奇数，那么子树中所有奇数深度权值增加，偶数深度权值减少，反之同理。</p><p>但是我们操作线段树的时候怎么知道点在树中的深度奇偶性呢？我们只能在线段树外才知道呀。</p><p>所以观察询问，询问是单点的，所以我们知道了，可以只在线段树外对奇偶性进行处理。简单来说，假设更改起点深度为奇数，那么增加整个子树的「奇加偶减计数器」；反之，增加整个子树的「奇减偶加计数器」。</p><p>最后查询的时候，如果该点深度为奇，那么答案为对应的「奇加偶减计数器」减去「奇减偶加计数器」的值，反之同理。</p><p>做到最后发现根本不用树剖，就是一个 DFN 上线段树。时间复杂度 <span class="math inline">\(O(m\log n)\)</span>。</p><p>胶囊真好吃！！！</p><details><pre class="cpp"><code>namespace XSC062 &#123;using namespace fastIO;#define lt (p &lt;&lt; 1)#define rt (lt | 1)const int maxn = 2e5 + 5;struct _ &#123;    int l, r;    int u1, u2, d1, d2;&#125;; _ t[maxn &lt;&lt; 2];int a[maxn], dep[maxn];std::vector&lt;int&gt; g[maxn];int n, m, x, y, tot, typ;int end[maxn], dfn[maxn], tab[maxn];// u 只用维护最底层信息// 所以不用打 pushup // 但维护起来好看一些 所以还是打了void pushup(int p) &#123;    t[p].u1 = t[lt].u1 + t[rt].u1;    t[p].u2 = t[lt].u2 + t[rt].u2;    return;&#125;void pushdown(int p) &#123;    if (t[p].d1) &#123;        t[lt].d1 += t[p].d1;        t[rt].d1 += t[p].d1;        t[lt].u1 += t[p].d1 * (t[lt].r - t[lt].l + 1);        t[rt].u1 += t[p].d1 * (t[rt].r - t[rt].l + 1);        t[p].d1 = 0;    &#125;    if (t[p].d2) &#123;        t[lt].d2 += t[p].d2;        t[rt].d2 += t[p].d2;        t[lt].u2 += t[p].d2 * (t[lt].r - t[lt].l + 1);        t[rt].u2 += t[p].d2 * (t[rt].r - t[rt].l + 1);        t[p].d2 = 0;    &#125;    return;&#125;void bld(int p, int l, int r) &#123;    t[p].l = l, t[p].r = r;    if (l == r) &#123;        if (dep[tab[l]] &amp; 1)            t[p].u1 = a[tab[l]];        else t[p].u2 = a[tab[l]];        return;    &#125;    int mid = (l + r) &gt;&gt; 1;    bld(lt, l, mid), bld(rt, mid + 1, r);    pushup(p);    return;&#125;void add1(int p, int l, int r, int x) &#123;    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r) &#123;        t[p].d1 += x;        t[p].u1 += (t[p].r - t[p].l + 1) * x;        return;    &#125;    int mid = (t[p].l + t[p].r) &gt;&gt; 1;    pushdown(p);    if (l &lt;= mid) add1(lt, l, r, x);    if (r &gt; mid) add1(rt, l, r, x);    pushup(p);    return;&#125;void add2(int p, int l, int r, int x) &#123;    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r) &#123;        t[p].d2 += x;        t[p].u2 += (t[p].r - t[p].l + 1) * x;        return;    &#125;    int mid = (t[p].l + t[p].r) &gt;&gt; 1;    pushdown(p);    if (l &lt;= mid) add2(lt, l, r, x);    if (r &gt; mid) add2(rt, l, r, x);    pushup(p);    return;&#125;int ask(int p, int x) &#123;    if (t[p].l == t[p].r)        return t[p].u1 - t[p].u2;    int mid = (t[p].l + t[p].r) &gt;&gt; 1;    pushdown(p);    if (x &lt;= mid) return ask(lt, x);    return ask(rt, x);&#125;void DFS(int x, int fa) &#123;    dfn[x] = ++tot, tab[tot] = x;    for (auto i : g[x]) &#123;        if (i == fa) continue;        dep[i] = dep[x] + 1;        DFS(i, x);    &#125;    end[x] = tot;    return;&#125;void add(int x, int y) &#123;    g[x].push_back(y);    return;&#125;int main() &#123;    read(n), read(m);    for (int i = 1; i &lt;= n; ++i)        read(a[i]);    for (int i = 1; i &lt; n; ++i) &#123;        read(x), read(y);        add(x, y), add(y, x);    &#125;    dep[1] = 1, DFS(1, -1);    bld(1, 1, n);    while (m--) &#123;        read(typ), read(x);        if (typ == 1) &#123;            read(y);            if (dep[x] &amp; 1)                add1(1, dfn[x], end[x], y);            else add2(1, dfn[x], end[x], y);        &#125;        else &#123;            int res = ask(1, dfn[x]);            if (dep[x] &amp; 1)                print(res, &#39;\n&#39;);            else print(-res, &#39;\n&#39;);        &#125;    &#125;    return 0;&#125;&#125; // namespace XSC062</code></pre></details><hr /><h3 id="f.-单词">F. 单词</h3><p><a href="http://222.180.160.110:61235/contest/4268/problem/6" class="uri">http://222.180.160.110:61235/contest/4268/problem/6</a></p><p><span class="math inline">\(n \le 20\)</span>，考虑状压。用 <span class="math inline">\(f_x\)</span> 表示状态为 <span class="math inline">\(x\)</span> 时的最小代价，其中 <span class="math inline">\(x\)</span> 是字符串合法情况的状态压缩。</p><p>对于每一个待满足的串，枚举去满足它的哪一位，那么满足方式分两种情况：</p><ul><li>把它变成一个新的值</li><li><p>把和它重合的变成新的值</p><p>我们注意到 <span class="math inline">\(n \le 20 \le 26\)</span>，所以一定能找到一种方法让每个串的这一位都不一样。</p><p>接着，反正我们都要改这一位了，那就贪心地把要改的全部改成完全不一样的。那么这些要改的串也在这一位上满足了条件。</p></li></ul><p>所以，假设对于状态 <span class="math inline">\(i\)</span>，有串 <span class="math inline">\(j\)</span> 未满足，枚举位置 <span class="math inline">\(k\)</span>，有：</p><pre class="cpp"><code>f[i | (1 &lt;&lt; (j - 1))] = min(f[i | (1 &lt;&lt; (j - 1))], f[i] + a[j][k]); f[i | lac[j][k]] = min(f[i | lac[j][k]], f[i] + mx[j][k]);</code></pre><p>其中 <code>lac[j][k]</code> 和 <code>mx[j][k]</code> 都是预处理出来的值。<code>lac[j][k]</code> 表示与第 <span class="math inline">\(j\)</span> 个串的第 <span class="math inline">\(k\)</span> 位相同串的状态压缩；<code>mx[j][k]</code> 表示通过第二种方式将 <span class="math inline">\(j\)</span> 串的第 <span class="math inline">\(k\)</span> 位变得合法的最小费用。</p><p><code>lac[j][k]</code> 的求法没有任何疑问，主要是在 <code>mx[j][k]</code> 上。注意到假设这一位上有 <span class="math inline">\(x\)</span> 个串与 <span class="math inline">\(j\)</span> 串的第 <span class="math inline">\(k\)</span> 位相同（包括其本身），而我们只需要将这当中的 <span class="math inline">\(x-1\)</span> 个变成两两不同的全新字符就可以同时满足这 <span class="math inline">\(x\)</span> 串的条件，那我们为什么不把不动的这一个串设置为 <span class="math inline">\(x\)</span> 个串中改这一位代价最大的那个呢？</p><p>那么问题来了。我们枚举状态、枚举状态中的每一个 <code>0</code>，枚举每一个串的每一位，实际上是 <span class="math inline">\(O(n\times m\times 2^n)\)</span> 的。虽然跑不满，但这个时间复杂度仍然是有问题的。我们需要优化。</p><p>我们枚举的是状态中的每一个 <code>0</code>，假设我们的状态是 <code>000</code>，我们的解决方案是将三个 <code>0</code> 位置的方案共同处理，表示为 <code>'0--'</code> + <code>'-0-'</code> + <code>'--0'</code>。但实际上，我们只用实际求解一个 <code>0</code> 位置的答案，表示为 <code>'0--'</code> + <code>'-00'</code> 。</p><p>也就是说，我们原本需要枚举每一个状态为 <code>0</code> 的 <span class="math inline">\(j\)</span> 并用 <span class="math inline">\(O(m)\)</span> 的时间进行计算，现在我们碰到一个状态为 <code>0</code> 的 <span class="math inline">\(j\)</span> 就开始计算，得到完全相同的答案。</p><p>很 NB 并且很实用的优化，已加入 <a href="/20231117/">下饭操作合集</a>。</p><details><pre class="cpp"><code>namespace XSC062 &#123;using namespace fastIO;const int maxn = 205;const int maxm = (1 &lt;&lt; 25) + 5;int f[maxm];int n, m, siz;char s[maxn][maxn];int lac[maxn][maxn];int a[maxn][maxn], mx[maxn][maxn];int min(int x, int y) &#123; return x &lt; y ? x : y; &#125;int max(int x, int y) &#123; return x &gt; y ? x : y; &#125;int main() &#123;    while(~scanf(&quot;%d %d&quot;, &amp;n, &amp;m)) &#123;        memset(f, 0x3f, sizeof (f));        f[0] = 0, siz = 1 &lt;&lt; n;        for (int i = 1; i &lt;= n; ++i)            scanf(&quot;%s&quot;, s[i] + 1);        for (int i = 1; i &lt;= n; ++i) &#123;            for (int j = 1; j &lt;= m; ++j)                scanf(&quot;%d&quot;, &amp;a[i][j]);        &#125;        for (int i = 1; i &lt;= n; ++i) &#123;            for (int j = 1; j &lt;= m; ++j) &#123;                int sum = 0;                lac[i][j] = mx[i][j] = 0;                for (int k = 1; k &lt;= n; ++k) &#123;                    if (s[k][j] == s[i][j]) &#123;                        lac[i][j] |= 1 &lt;&lt; (k - 1);                        sum += a[k][j];                        mx[i][j] = max(mx[i][j], a[k][j]);                    &#125;                &#125;                mx[i][j] = sum - mx[i][j];            &#125;        &#125;        for (int i = 0, j; i &lt; siz - 1; ++i) &#123;            for (j = 1; j &lt;= n; ++j) &#123;                if (!(i &amp; (1 &lt;&lt; (j - 1))))                    break;            &#125;            for (int k = 1; k &lt;= m; ++k) &#123;                f[i | (1 &lt;&lt; (j - 1))] =                    min(f[i | (1 &lt;&lt; (j - 1))], f[i] + a[j][k]);                 f[i | lac[j][k]] =                    min(f[i | lac[j][k]], f[i] + mx[j][k]);            &#125;        &#125;        print(f[siz - 1], &#39;\n&#39;);    &#125;    return 0;&#125;&#125; // namespace XSC062</code></pre></details><hr /><p>这次暴露出的问题：</p><ul><li>深度乱求，打代码的时候考虑过要放在递归之前，但是由于精力不集中最后还是放在了递归后面。</li></ul><p>没了。这次主要问题出在 T5。T3 估计真的想不到，先不强求自己。</p><p>这次学到的新知识：</p><ul><li>对于子集合并最优性的问题，可以用单点 + 集合代替集合 + 集合枚举。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> DP </tag>
            
            <tag> 线段树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>颜色</title>
      <link href="/20230928/"/>
      <url>/20230928/</url>
      
        <content type="html"><![CDATA[<p>Solution to <a href="https://vjudge.net/contest/583230#problem/B">颜色</a>。</p><span id="more"></span><hr /><h3 id="b---颜色">B - 颜色</h3><p><a href="https://vjudge.net/contest/583230#problem/B" class="uri">https://vjudge.net/contest/583230#problem/B</a></p><p>颜色删完过后剩下的肯定是一段区间。</p><p>那么区间外的所有颜色都会被删掉，如果要满足题目条件的话，删掉的颜色不能出现在区间内。</p><p>那么就可以有这么一个题意的转化：寻找区间的个数，满足区间内的颜色只出现在区间内。</p><p>然后你可能就要问了，不是还要满足区间外的所有颜色都不出现在区间内吗。但是你想想，要是它出现在区间内了，它作为区间内的颜色，不就不满足我们上面说的那条规则了吗。</p><p>这个转化是非常厉害的。那么这个时候有一个显而易见暴力做法，我们记录一个颜色在整个序列中出现的第一个位置（记为 <span class="math inline">\(L_x\)</span>）和最后一个位置（记作 <span class="math inline">\(R_x\)</span>），然后枚举每一个区间 <span class="math inline">\([i, j]\)</span>，再枚举其中的每一个颜色，看看有没有超出去就好，复杂度 <span class="math inline">\(O(n^3)\)</span>。</p><details><summary>对纯暴力的一点小优化</summary> 上述区间内枚举过程转化为判定区间是否满足 <span class="math inline">\({L_x}_{\min} \ge i\)</span> 且 <span class="math inline">\({R_x}_{\max} \le j\)</span>，采用数据结构维护，就可以优化到 <span class="math inline">\(O(n^2\log)\)</span>。为什么要专门提一嘴这个呢，因为这个模型我没想到。我真 NB。</details><p>接下来又是一个我想不到的模型。我们发现复杂度瓶颈出在枚举区间上，所以考虑通过固定区间右端点，用较小的复杂度直接求解满足条件的左端点数量来解决问题。为什么不是固定左端点呢？</p><p>「因为题解都是写的固定右端点。」 0# 如是说。</p><p>对于正在枚举的右端点 <span class="math inline">\(j\)</span> 右边的颜色 <span class="math inline">\(x\)</span>，我们记录它们上一次出现的位置 <span class="math inline">\(p_x\)</span>，并用线段树找到范围内最右值 <span class="math inline">\((p_x)_{\max}\)</span>，那么左端点 <span class="math inline">\(i&gt;(p_x)_{\max}\)</span>。取 <span class="math inline">\(i&#39;=(p_x)_{\max}+1\)</span>，这样我们就初步得到了一个 <span class="math inline">\([i&#39;, j]\)</span>。相对于纯暴力的做法，<span class="math inline">\(R_x\le j\)</span> 的等价条件已经满足，但还有一个条件，就是 <span class="math inline">\(L_x\)</span> 不能小于 <span class="math inline">\(i\)</span>。</p><p>为了方便数据结构维护 <span class="math inline">\(p_x\)</span>，我们逆序枚举 <span class="math inline">\(j\)</span>，这样又可以得到一个性质：<span class="math inline">\(i&#39;\)</span> 单调不降。这个时候我们逆向思维，处理出对于每个 <span class="math inline">\(i\ge i&#39;\)</span>，其能够到的最远的 <span class="math inline">\(j\)</span>，记为 <span class="math inline">\(f_i\)</span>，那么我们对于 <span class="math inline">\(f_i\)</span> 建一个权值线段树，然后在枚举过程中查询权值在 <span class="math inline">\([j, +\infty)\)</span> 的 <span class="math inline">\(i\)</span> 的个数就是答案。由于求的是个数，所以可以对超出范围的 <span class="math inline">\(i\)</span> 对应的 <span class="math inline">\(f_i\)</span> 进行删除操作。</p><p>那么 <span class="math inline">\(f_i\)</span> 又该怎么求呢？暴力地再建一个权值线段树维护 <span class="math inline">\(L_x\)</span>，在 <span class="math inline">\((-\infty, i)\)</span> 权值范围内查询下标 <span class="math inline">\(k\)</span> 的最小值，此时的 <span class="math inline">\(k\)</span> 就是 <span class="math inline">\(f_i\)</span>。</p><p>因为 0# 讲课的时候我在开飞机，所以我也不知道 0# 是不是这么讲的，总之我这么做应该能做出来，就是要维护的东西实在有亿点点多。</p><p>但是注意到一个线段树和两个权值线段树维护的大区间其实是一样的，所以我们只用一个线段树同时维护三个信息就好。最后时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p><details><pre class="cpp"><code>namespace XSC062 &#123;using namespace fastIO;#define lt (p &lt;&lt; 1)#define rt (lt | 1)#define mid (t[p].l + t[p].r) / 2const int maxn = 3e5 + 5;// shaber monotonicity// destroy my youth struct _ &#123; int l, r, u, d; &#125;;struct __ &#123;    int u, i;    __() &#123;&#125;    __(int u1, int i1) &#123;        u = u1, i = i1;    &#125;&#125;;int T, n, res;_ t[maxn &lt;&lt; 2];int a[maxn], L[maxn], R[maxn];int max(int x, int y) &#123; return x &gt; y ? x : y; &#125;int min(int x, int y) &#123; return x &lt; y ? x : y; &#125;void pushup(int p) &#123;    t[p].u = t[lt].u + t[rt].u;    return;&#125;void pushdown(int p) &#123;    if (t[p].d) &#123;        t[lt].d = t[rt].d = 1;        t[lt].u = t[lt].r - t[lt].l + 1;        t[rt].u = t[rt].r - t[rt].l + 1;        t[p].d = 0;    &#125;    return;&#125;void bld(int p, int l, int r) &#123;    t[p].u = t[p].d = 0;    t[p].l = l, t[p].r = r;    if (l == r) return;    bld(lt, l, mid), bld(rt, mid + 1, r);    return;&#125;void add(int p, int l, int r) &#123;    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r) &#123;        t[p].u = t[p].r - t[p].l + 1;        t[p].d = 1;        return;    &#125;    pushdown(p);    if (l &lt;= mid) add(lt, l, r);    if (r &gt; mid) add(rt, l, r);    pushup(p);    return;&#125;int ask(int p, int l, int r) &#123;    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r)        return t[p].u;    int res = 0; pushdown(p);    if (l &lt;= mid) res = ask(lt, l, r);    if (r &gt; mid) res += ask(rt, l, r);    return res;&#125;int main() &#123;    read(T);    while (T--) &#123;        read(n), res = 0;        std::stack&lt;__&gt; p;        std::fill(L + 1, L + n + 1, n + 5);        std::fill(R + 1, R + n + 1, 0);        for (int i = 1; i &lt;= n; ++i) &#123;            read(a[i]), R[a[i]] = i;            if (L[a[i]] == n + 5) L[a[i]] = i;        &#125;        bld(1, 1, n);        for (int i = 1, j; i &lt;= n; ++i) &#123;            if (i == R[a[i]] &amp;&amp; i != L[a[i]])                add(1, L[a[i]] + 1, R[a[i]]);            else p.push(__(a[i], i));            while (!p.empty() &amp;&amp; R[p.top().u] &lt;= i) p.pop();            j = p.size() ? p.top().i : 0;            if (i != j) res += i - j - ask(1, j + 1, i);        &#125;        print(res, &#39;\n&#39;);    &#125;    return 0;&#125;&#125; // namespace XSC062</code></pre></details>]]></content>
      
      
      
        <tags>
            
            <tag> 线段树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pn、pm 和 plmm</title>
      <link href="/20230813/"/>
      <url>/20230813/</url>
      
        <content type="html"><![CDATA[<p>Sotution to <a href="https://codeforces.com/problemset/problem/258/C">CF258C Little Elephant and LCM</a>。</p><span id="more"></span><hr /><p>0#：那么这个 pn 可以等于什么？它只能等于 pm。（露出看到 plmm 一般的猥琐坏笑）</p><hr /><p>方便起见，下面 <span class="math inline">\(b_{\text{lcm}}\)</span> 的意思就是 <span class="math inline">\(\text{lcm}\{b_1,b_2,\cdots,b_n\}\)</span>，<span class="math inline">\(\max\)</span> 什么的也同理。</p><p>首先我们都能反应过来，如果 <span class="math inline">\(b_{\text{lcm}}=b_{\max}\)</span>，那么 <span class="math inline">\(b\)</span> 中的最大值就得是 <span class="math inline">\(b_{\text {lcm}}\)</span>，而其他元素都得是 <span class="math inline">\(b_{\max}\)</span> 的因数。</p><p>既然涉及到求 <span class="math inline">\(b_{\max}\)</span> 的因数，那我们势必避免不了枚举 <span class="math inline">\(b_{\max}\)</span>。我一开始陷入了一个 trick：我并不知道 <span class="math inline">\(b_{\max}\)</span> 应该处于哪一个位置。但其实这不重要，它对我们最后的方案没有影响，有影响的是「有多少个位置可以取到当前枚举的 <span class="math inline">\(b_{\max}\)</span>」。</p><p>对于当前枚举的 <span class="math inline">\(b_{\max}\)</span>（假设为 <span class="math inline">\(k\)</span>），我们找到它的所有因数 <span class="math inline">\(p_1\sim p_m\)</span>，按从小到大的顺序排列。对于一个 <span class="math inline">\(a_i\)</span>，当且仅当 <span class="math inline">\(a_i\ge p_j\)</span> 时，<span class="math inline">\(a_i\)</span> 可以选择 <span class="math inline">\(p_j\)</span>。那么我们找到 <span class="math inline">\(a_i\)</span> 可以选到的最大的 <span class="math inline">\(p_j\)</span>，此时 <span class="math inline">\(a_i\)</span> 的选择就是 <span class="math inline">\(p_1\sim p_j\)</span>，共 <span class="math inline">\(j\)</span> 种。</p><p>那么我们在外面已经有一层枚举 <span class="math inline">\(k\)</span> 的循环的前提下，再遍历 <span class="math inline">\(a\)</span> 数组无疑是会起飞的，我们考虑倒过来，遍历 <span class="math inline">\(p\)</span>，对于每个 <span class="math inline">\(p_j\)</span>，找到它是多少个 <span class="math inline">\(a_i\)</span> 的最大选择（假设为 <span class="math inline">\(x_j\)</span>），那么对于 <span class="math inline">\(p_j\)</span>，它贡献的答案就是 <span class="math inline">\(j^{x_j}\)</span>。</p><p><span class="math inline">\(x_j\)</span> 的计算也不难，我们用两个二分找到满足 <span class="math inline">\(p_j\le a_i &lt; p_j + 1\)</span> 的 <span class="math inline">\(a_i\)</span> 数量就可以了。那么总方案数就是 <span class="math inline">\(\prod j^{x_j}\)</span>。</p><p>但是别忘了还有 <span class="math inline">\(k\)</span> 为 <span class="math inline">\(b_{\max}\)</span> 的限制。找到 <span class="math inline">\(x_m\)</span>，怎么去满足至少有一个 <span class="math inline">\(a_i=k\)</span> 呢？一个微型容斥，用总方案数减去一个 <span class="math inline">\(k\)</span> 都没有的方案数。那么就规定了每个可以取到 <span class="math inline">\(k\)</span> 的数都必须不取 <span class="math inline">\(k\)</span>，本来有 <span class="math inline">\(m\)</span> 种选择，现在只剩下 <span class="math inline">\(m−1\)</span> 种，所以答案就是 <span class="math inline">\((m−1)^{x_m}\)</span>，容斥后为 <span class="math inline">\(m^{x_m}−(m−1)^{x_m}\)</span>。</p><p>对于 <span class="math inline">\(b_{\max}=k\)</span>，最终结果为 <span class="math inline">\((\prod\limits_{j=1}^{m−1}j^{x_j})\times (m^{x_m}−(m−1)^{x_m})\)</span>。加法原理把所有 <span class="math inline">\(k\)</span> 的情况加起来即可。</p><p>对于时间复杂度，枚举 <span class="math inline">\(k\)</span> 是 <span class="math inline">\(O(V)\)</span> 的，找因数是 <span class="math inline">\(O(\sqrt V)\)</span> 的，枚举 <span class="math inline">\(p_j\)</span> 是 <span class="math inline">\(\log V\)</span> 的，二分是 <span class="math inline">\(\log n\)</span> 的。所以最终时间复杂度为 <span class="math inline">\(O(V\times \max\{\sqrt V,\log V\times \log n\})\)</span>。</p><details><pre class="cpp"><code>#define int long longnamespace XSC062 &#123;using namespace fastIO;const int mod = 1e9 + 7;const int maxn = 1e5 + 5;int a[maxn];int n, mx, ans, res;int qkp(int x, int y) &#123;    int res = 1;    while (y) &#123;        if (y &amp; 1) (res *= x) %= mod;        (x *= x) %= mod, y &gt;&gt;= 1;    &#125;    return res;&#125;int max(int x, int y) &#123; return x &gt; y ? x : y; &#125;int main() &#123;    read(n);    for (int i = 1; i &lt;= n; ++i)         read(a[i]), mx = max(mx, a[i]);    std::sort(a + 1, a + n + 1);    for (int k = 1; k &lt;= mx; ++k) &#123;        res = 1;        std::vector&lt;int&gt; p;        p.push_back(-1); // 占位符，方便下标对齐         for (int i = 1; i * i &lt;= k; ++i) &#123;            if (k % i == 0) &#123;                p.push_back(i);                if (i * i != k) p.push_back(k / i);            &#125;        &#125;        std::sort(p.begin() + 1, p.end());        // 先算前 m - 1 个         int m = p.size() - 1;        for (int j = 1; j &lt;= m - 1; ++j) &#123;            int l, r, x;            l = std::lower_bound(a + 1, a + n + 1, p[j]) - a;            r = std::lower_bound(a + 1, a + n + 1, p[j + 1]) - a - 1;            x = r - l + 1, (res *= qkp(j, x)) %= mod;        &#125;        int l, r, x;        l = std::lower_bound(a + 1, a + n + 1, p[m]) - a;        r = n, x = r - l + 1;        (res *= (qkp(m, x) - qkp(m - 1, x))) %= mod;        (ans += res) %= mod;    &#125;    print((ans + mod) % mod, &#39;\n&#39;);    return 0;&#125;&#125; // namespace XSC062#undef int</code></pre></details>]]></content>
      
      
      
        <tags>
            
            <tag> 二分 </tag>
            
            <tag> 容斥原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>矩阵</title>
      <link href="/20230729/"/>
      <url>/20230729/</url>
      
        <content type="html"><![CDATA[<p>Solution to <a href="http://222.180.160.110:61235/contest/3825/problem/7">BZOJ2406 矩阵</a>。</p><span id="more"></span><hr /><blockquote><p>赛时公告</p><p>现在呢？：现在有弹窗了吗 「2023-07-19 16:45:07」</p></blockquote><p>此时无声胜有声。</p><hr /><h3 id="f.bzoj2406矩阵">F.「BZOJ2406」矩阵</h3><p><a href="http://222.180.160.110:61235/contest/3825/problem/7" class="uri">http://222.180.160.110:61235/contest/3825/problem/7</a></p><p>这是头一次见识到把矩阵和网络流结合在一起的题目。不过这种处理方式也是我们在学习二分图时的常客了：把行和列连边表示某一元素。</p><p>我们发现 <span class="math inline">\(B_{i, j}\)</span> 有给定的上下界，故我们考虑 <strong>上下界网络流</strong>。那怎么去表示 <span class="math inline">\(B_{i, j}\)</span> 呢？这就要联系到我们刚刚说过的连边方式：用边 <span class="math inline">\(i\to j\)</span> 的流量来表示 <span class="math inline">\(B_{i, j}\)</span>，有 <span class="math inline">\([L, R]\)</span> 的上下界。</p><p>可是我们除了 <span class="math inline">\([L,R]\)</span> 的限制，还有最大值这个条件呀，怎么办呢？</p><p>注意到题目要求最大的最小，自然想到二分答案。设答案为 <span class="math inline">\(x\)</span>，则我们需要保证每行每列的答案都 <span class="math inline">\(\le x\)</span>。每行每列，这刚好是我们的建点方式。这对点本身作出了要求，这套路我们熟，让大源点向行连边、列向大汇点连边就好。</p><p>那么这些边的上下界怎么办呢？我们已知 <span class="math inline">\(|S_A-S_B|\le x\)</span>，那么变形得：</p><p><span class="math display">\[\begin{cases}S_B\ge S_A-x &amp;(S_B \le S_A) \\S_B\le S_A+x &amp;(S_B \ge S_A)\end{cases}\]</span></p><p>照理来说，两行的符号相反，我们现在已经得到了一个具有对称美的上下界：<span class="math inline">\(S_A-x\le S_B\le S_A+x\)</span>，就应该速速连边了，可是我怎么看都觉得不舒坦：这个不等式可是带条件的，就这么直接拿来做上下界真的没问题吗？</p><p><del>答案是没问题，因为我看的题解是这么写的</del> 本着探索求真精神，我们考虑尊重原不等式（因为原不等式的每一行刚好也有两个相反的符号），将这些边拆成两条，一条的上下界是 <span class="math inline">\([S_A-x, S_A]\)</span>，另一条是 <span class="math inline">\([S_A,S_A+x]\)</span>。6。我明白题解为什么这么写了，一个的下界就是另一个的上界，那直接合并不就行了，这个 naive trick 题解都不屑于写出来。</p><p>然后跑个可行流就可以了。注意要保证边的下界为非负。</p><details><pre class="cpp"><code>#define int long longnamespace XSC062 &#123;using namespace fastIO;const int lim = 2e5;const int maxn = 405;const int inf = 1e18;const int maxm = 3e5 + 5;struct _ &#123;    int v, w, n;    _() &#123;&#125;    _(int v1, int w1, int n1) &#123;        v = v1, w = w1, n = n1;    &#125;&#125;;_ u[maxm];int gs, gt, tot;int a[maxn][maxn];int l, mid, r, res;int h[maxn], dif[maxn];int n, m, cnt, s, t, L, R;int vis[maxn], now[maxn], dep[maxn];int max(int x, int y) &#123; return x &gt; y ? x : y; &#125;int min(int x, int y) &#123; return x &lt; y ? x : y; &#125;bool BFS(int n) &#123;    std::fill(vis + 1, vis + n + 1, 0);    std::fill(dep + 1, dep + n + 1, 0);     std::queue&lt;int&gt; q;    dep[gs] = 1, vis[gs] = 1;    q.push(gs), now[gs] = h[gs];    while (!q.empty()) &#123;        int f = q.front(); q.pop();        for (int i = h[f]; i; i = u[i].n) &#123;            int v = u[i].v, w = u[i].w;            if (vis[v] == 1 || w == 0) continue;            vis[v] = 1, now[v] = h[v];            dep[v] = dep[f] + 1, q.push(v);            if (v == gt) return 1;        &#125;    &#125;    return 0;&#125;int findP(int x, int flow = inf) &#123;    if (x == gt) return flow;    int rest = flow, i;    for (i = now[x]; rest &amp;&amp; i; i = u[i].n) &#123;        now[x] = i;        int v = u[i].v, w = u[i].w;        if (dep[v] != dep[x] + 1 || w == 0) continue;        int t = findP(v, min(rest, w));        if (t == 0) dep[v] = 0;        rest -= t, u[i].w -= t, u[i ^ 1].w += t;    &#125;    return flow - rest;&#125;int Dinic(int n) &#123;    int res = 0;    while (BFS(n)) &#123;        int t = findP(gs);        while (t) res += t, t = findP(gs);    &#125;    return res;&#125;void add(int x, int y, int w) &#123;    u[++tot] = _(y, w, h[x]), h[x] = tot;    return;&#125;void add(int x, int y, int d, int u) &#123;    add(x, y, u - d), add(y, x, 0);    dif[x] -= d, dif[y] += d;    return;&#125;void Init(void) &#123;    tot = 1, cnt = 0;    memset(h, 0, sizeof (h));    memset(dif, 0, sizeof (dif));    return;&#125;bool check(int x) &#123;    Init();    s = n + m + 1, t = s + 1;    add(t, s, inf), add(s, t, 0);    gs = t + 1, gt = t + 2;    for (int i = 1; i &lt;= n; ++i) &#123;        for (int j = 1; j &lt;= m; ++j)            add(i, j + n, L, R);    &#125;    for (int i = 1; i &lt;= n; ++i) &#123;        int sum = 0;        for (int j = 1; j &lt;= m; ++j)            sum += a[i][j];        add(s, i, max(0, sum - x), sum + x);    &#125;    for (int j = 1; j &lt;= m; ++j) &#123;        int sum = 0;        for (int i = 1; i &lt;= n; ++i)            sum += a[i][j];        add(j + n, t, max(sum - x, 0), sum + x);    &#125;    for (int i = 1; i &lt;= t; ++i) &#123;        if (dif[i] &lt; 0)            add(i, gt, -dif[i]), add(gt, i, 0);        else if (dif[i] &gt; 0) &#123;            add(gs, i, dif[i]);            add(i, gs, 0), cnt += dif[i];        &#125;    &#125;    return (Dinic(gt) == cnt);&#125;int main() &#123;    read(n), read(m);    for (int i = 1; i &lt;= n; ++i) &#123;        for (int j = 1; j &lt;= m; ++j)            read(a[i][j]);    &#125;    read(L), read(R);    l = 0, r = lim, res = -1;    while (l &lt;= r) &#123;        mid = (l + r) &gt;&gt; 1;        if (check(mid))            res = mid, r = mid - 1;        else l = mid + 1;    &#125;    print(res);    return 0;&#125;&#125; // namespace XSC062#undef int</code></pre></details><hr /><p>你最好有要事相求.jpg</p>]]></content>
      
      
      
        <tags>
            
            <tag> 网络流 </tag>
            
            <tag> 二分 </tag>
            
            <tag> 上下界网络流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络流 24 题</title>
      <link href="/20230722/"/>
      <url>/20230722/</url>
      
        <content type="html"><![CDATA[<p>Solution to <a href="http://222.180.160.110:61235/contest/3952/problem/1">网络流 24 题</a>。</p><span id="more"></span><hr /><h2 id="day-11st---6th">Day 1：1st - 6th</h2><h3 id="a.-星际转移问题">A. 星际转移问题</h3><p><a href="http://222.180.160.110:61235/contest/3952/problem/1" class="uri">http://222.180.160.110:61235/contest/3952/problem/1</a></p><p>如果就按照题目给的路线图，我们显然无法考虑到飞船到达的时刻。同时 <span class="math inline">\(n\)</span> 和 <span class="math inline">\(m\)</span> 又很小，我们就知道了，「人不能两次踏进同一条河流」，<span class="math inline">\(1\)</span> 时刻的站 <span class="math inline">\(p\)</span> 和 <span class="math inline">\(2\)</span> 时刻的站 <span class="math inline">\(p\)</span> 也不能是同一个站 <span class="math inline">\(p\)</span>。</p><p>考虑用 <span class="math inline">\((p, t)\)</span> 表示 <span class="math inline">\(t\)</span> 时刻的站 <span class="math inline">\(p\)</span>，然后对于每条路线跑个暴力连边，容量全部为 <span class="math inline">\(H_i\)</span>。</p><p>怎么控制时间最小呢？二分一下就可以了…… 然后最大流判定是不是满流的即可。</p><p>以及注意到对于同一站点，前面的时刻可以留下来等后面的时刻，我们将同一站的前一时刻和后一时刻全部连边，容量为 <span class="math inline">\(k\)</span>。以及保留节目对源点拆点以控制流量为 <span class="math inline">\(k\)</span>。</p><p><del>经实验答案最大为 29，所以把二分上界设为 30 即可</del> 理论上来说答案可能很大，比如你谷最后一组数据的答案就是 <span class="math inline">\(900\)</span> 多，所以我掐指一算用天才般的算术技巧开了 <span class="math inline">\(10^4\)</span>。真的，数数位天才就是我。</p><details><p>woc，这题居然没人做，果然我还是太强了。</p><p>为什么都跑去做 T4 了，这个不是按难度顺序排列的吗？</p><p>哦哦，好像不是，那（Na）没（Mei）事（Shi）了（Le）。</p><p><img src="https://pic.imgdb.cn/item/64be2f6e1ddac507cc0e0955.png" /></p><pre class="cpp"><code>#define int long longnamespace XSC062 &#123;using namespace fastIO;const int lim = 1e4;const int inf = 1e18;const int maxm = 4e5 + 5;const int maxn = 5e4 + 15;struct _ &#123;    int v, w, n;    _() &#123;&#125;    _(int v1, int w1, int n1) &#123;        v = v1, w = w1, n = n1;    &#125;&#125;;struct __ &#123;    int c;    std::vector&lt;int&gt; p;&#125;;_ u[maxm];__ w[maxn];int h[maxn];int l, mid, r;int gs, gt, tot = 1;int n, m, k, s, mt, x, res, y;int vis[maxn], now[maxn], dep[maxn];int min(int x, int y) &#123; return x &lt; y ? x : y; &#125;int fun(int p, int t) &#123; return (p - 1) * mt + t; &#125;bool BFS(int n) &#123;    std::fill(vis + 1, vis + n + 1, 0);    std::fill(dep + 1, dep + n + 1, 0);     std::queue&lt;int&gt; q;    dep[gs] = 1, vis[gs] = 1;    q.push(gs), now[gs] = h[gs];    while (!q.empty()) &#123;        int f = q.front(); q.pop();        for (int i = h[f]; i; i = u[i].n) &#123;            int v = u[i].v, w = u[i].w;            if (vis[v] == 1 || w == 0) continue;            vis[v] = 1, now[v] = h[v];            dep[v] = dep[f] + 1, q.push(v);            if (v == gt) return 1;        &#125;    &#125;    return 0;&#125;int findP(int x, int flow = inf) &#123;    if (x == gt) return flow;    int rest = flow, i;    for (i = now[x]; rest &amp;&amp; i; i = u[i].n) &#123;        int v = u[i].v, w = u[i].w;        now[x] = i;        if (dep[v] != dep[x] + 1 || w == 0)            continue;        int t = findP(v, min(rest, w));        if (t == 0) dep[v] = 0;        rest -= t, u[i].w -= t, u[i ^ 1].w += t;    &#125;    return flow - rest;&#125;int Dinic(int n) &#123;    int res = 0;    while (BFS(n)) &#123;        int t = findP(gs);        while (t) res += t, t = findP(gs);    &#125;    return res;&#125;void add(int x, int y, int w) &#123;    u[++tot] = _(y, w, h[x]);    h[x] = tot;    return;&#125;void addf(int x, int y, int w) &#123;    add(x, y, w), add(y, x, 0);    return;&#125;void Init(void) &#123;    tot = 1;    memset(h, 0, sizeof (h));    return;&#125;bool check(int x) &#123;    Init();    mt = x, s = fun(n, mt) + 1;    gs = s + 1, gt = s + 2;    addf(gs, s, k);    for (int i = 1; i &lt;= mt; ++i) &#123;        addf(s, fun(n - 1, i), k);        addf(fun(n, i), gt, k);    &#125;    for (int i = 1; i &lt;= n; ++i) &#123;        for (int j = 1; j &lt; mt; ++j)            addf(fun(i, j), fun(i, j + 1), k);    &#125;    for (int i = 1; i &lt;= m; ++i) &#123;        int p = 0, x = 0, la = 0;        while (++p &lt;= mt) &#123;            if (la != 0)                addf(fun(la, p - 1), fun(w[i].p[x], p), w[i].c);            la = w[i].p[x];            if (++x &gt;= w[i].p.size()) x = 0;        &#125;    &#125;    return (Dinic(gt) == k);&#125;int main() &#123;    read(n), read(m), read(k);    for (int i = 1; i &lt;= m; ++i) &#123;        read(w[i].c), read(y);        while (y--) &#123;            read(x);            if (x == 0) x = n + 1;            else if (x == -1) x = n + 2;            w[i].p.push_back(x);        &#125;    &#125;    n += 2;    l = 1, r = lim;    while (l &lt;= r) &#123;        mid = (l + r) &gt;&gt; 1;        if (check(mid))            res = mid, r = mid - 1;        else l = mid + 1;    &#125;    print(res ? res - 1 : 0, &#39;\n&#39;);    return 0;&#125;&#125; // namespace XSC062#undef int</code></pre></details><hr /><h3 id="b.-最长递增子序列">B. 最长递增子序列</h3><p><a href="http://222.180.160.110:61235/contest/3952/problem/2" class="uri">http://222.180.160.110:61235/contest/3952/problem/2</a></p><p>就算知道不是按难度顺序排列我也要顺序开题。欸嘿，就是玩。</p><p>第一问很水，跑个 DP 就行。</p><p>第二问有点意思，取出就代表只能选一次，总之典中典，把每个数拆成入点和出点，容量为 <span class="math inline">\(1\)</span>，这样就可以只选一次了。</p><p>那怎么保证每次找到的流一定是 LIS 呢？其实这和我们 Dinic 的深度分层数组有异曲同工之妙，我们把 <span class="math inline">\(f_i = f_j + 1(i&gt;j,A_i\ge A_j)\)</span> 的 <span class="math inline">\((j, i)\)</span> 连边，容量为 <span class="math inline">\(1\)</span> 即可。</p><p>然后源点只和满足 <span class="math inline">\(f_x = 1\)</span> 的 <span class="math inline">\(x\)</span> 连边，相应地，汇点之和满足 <span class="math inline">\(f_x = \text{LIS}\)</span> 的 <span class="math inline">\(x\)</span> 连边。</p><p>第三问很好想啊，我们把 <span class="math inline">\(1\)</span> 到源点和 <span class="math inline">\(n\)</span> 到汇点的容量设成无穷大就好。</p><p>然后踩了半天的坑，这道题的拆点部分不知道为什么必须要连双向边。</p><details><pre class="cpp"><code>#define int long longnamespace XSC062 &#123;using namespace fastIO;const int inf = 1e18;const int maxm = 4e5 + 5;const int maxn = 5e5 + 15;struct _ &#123;    int v, w, n;    _() &#123;&#125;    _(int v1, int w1, int n1) &#123;        v = v1, w = w1, n = n1;    &#125;&#125;;_ u[maxm];int n, res;int gs, gt, tot = 1;int a[maxn], h[maxn], f[maxn];int vis[maxn], now[maxn], dep[maxn];int min(int x, int y) &#123; return x &lt; y ? x : y; &#125;int max(int x, int y) &#123; return x &gt; y ? x : y; &#125;bool BFS(int n) &#123;    std::fill(vis + 1, vis + n + 1, 0);    std::fill(dep + 1, dep + n + 1, 0);     std::queue&lt;int&gt; q;    dep[gs] = 1, vis[gs] = 1;    q.push(gs), now[gs] = h[gs];    while (!q.empty()) &#123;        int f = q.front(); q.pop();        for (int i = h[f]; i; i = u[i].n) &#123;            int v = u[i].v, w = u[i].w;            if (vis[v] == 1 || w == 0) continue;            vis[v] = 1, now[v] = h[v];            dep[v] = dep[f] + 1, q.push(v);            if (v == gt) return 1;        &#125;    &#125;    return 0;&#125;int findP(int x, int flow = inf) &#123;    if (x == gt) return flow;    int rest = flow, i;    for (i = now[x]; rest &amp;&amp; i; i = u[i].n) &#123;        int v = u[i].v, w = u[i].w;        now[x] = i;        if (dep[v] != dep[x] + 1 || w == 0) continue;        int t = findP(v, min(rest, w));        if (t == 0) dep[v] = 0;        rest -= t, u[i].w -= t, u[i ^ 1].w += t;    &#125;    return flow - rest;&#125;int Dinic(int n) &#123;    int res = 0;    while (BFS(n)) &#123;        int t = findP(gs);        while (t) res += t, t = findP(gs);    &#125;    return res;&#125;void add(int x, int y, int w) &#123;    u[++tot] = _(y, w, h[x]);    h[x] = tot;    return;&#125;void addf(int x, int y, int w) &#123;    add(x, y, w), add(y, x, 0);    return;&#125;int main() &#123;    read(n);    gs = 2 * n + 1, gt = gs + 1;    for (int i = 1; i &lt;= n; ++i) &#123;        read(a[i]), f[i] = 1;        addf(i, i + n, 1);        addf(i + n, i, 1);        for (int j = 1; j &lt; i; ++j) &#123;            if (a[j] &lt;= a[i])                f[i] = max(f[i], f[j] + 1);        &#125;        res = max(res, f[i]);        for (int j = 1; j &lt; i; ++j) &#123;            if (a[j] &lt;= a[i] &amp;&amp; f[i] == f[j] + 1)                addf(j, i + n, 1);        &#125;    &#125;    for (int i = 1; i &lt;= n; ++i) &#123;        if (f[i] == 1) addf(gs, i, 1);        if (f[i] == res) addf(i + n, gt, 1);    &#125;    print(res, &#39;\n&#39;);    print(Dinic(gt), &#39;\n&#39;);    tot = 1;    memset(h, 0, sizeof (h));    for (int i = 1; i &lt;= n; ++i) &#123;        addf(i, i + n, 1);        addf(i + n, i, 1);        for (int j = 1; j &lt; i; ++j) &#123;            if (a[j] &lt;= a[i] &amp;&amp; f[i] == f[j] + 1)                addf(j, i + n, 1);        &#125;    &#125;    for (int i = 1; i &lt;= n; ++i) &#123;        if (f[i] == 1) &#123;            if (i == 1) addf(gs, i, inf);            else addf(gs, i, 1);        &#125;        if (f[i] == res) &#123;            if (i == n) addf(i + n, gt, inf);            else addf(i + n, gt, 1);        &#125;    &#125;    print(Dinic(gt), &#39;\n&#39;);    return 0;&#125;&#125; // namespace XSC062#undef int</code></pre></details><hr /><h3 id="c.-餐巾计划问题">C. 餐巾计划问题</h3><p><a href="http://222.180.160.110:61235/contest/3952/problem/3" class="uri">http://222.180.160.110:61235/contest/3952/problem/3</a></p><p>这个有点简单啊。就差把费用流三个大字拍你脸上了。</p><p>用过和没用过的餐巾是不能混合处理的，故考虑拆点，把每一天拆出来一个点表示当天所有用过的餐巾量（注意不止是当天用过的，还可以是前几天传下来的）。</p><p>首先不难想到大源点和每天的没用过连边，容量为无穷大，费用为购买费用，表示购买餐巾；用过的和下一天用过的连边，容量为无穷大，费用为 <span class="math inline">\(0\)</span>，表示用过的餐巾的继承；用过的和快洗 / 慢洗所需时间后的没用过的连边，容量为无穷大，费用为快洗 / 慢洗费用，表示把用过的洗成没用过的（奇奇怪怪）。</p><p>那么问题来了，怎么表示使用餐巾呢？这里有一个很妙的处理方式，把没用过的朝大汇点连边，容量为当天使用量，费用为 <span class="math inline">\(0\)</span>，表示把这么多没用过的餐巾销毁；再把大源点朝用过的连边，容量也为当天使用量，费用为 <span class="math inline">\(0\)</span>，表示凭空变出来这么多条用过的餐巾。</p><p>然后跑个费用流就可以了。</p><details><pre class="cpp"><code>#define int long longnamespace XSC062 &#123;using namespace fastIO;const int inf = 1e18;const int maxn = 4e3 + 5;const int maxm = 6e5 + 5;struct _ &#123;    int v, c, w, n;    _() &#123;&#125;    _(int v1, int c1, int w1, int n1) &#123;        v = v1, c = c1, w = w1, n = n1;    &#125;&#125;;_ u[maxm];bool inq[maxn];int gs, gt, tot = 1;int h[maxn], dis[maxn];int fl[maxn], pre[maxn];int n, m, t1, c1, t2, c2, res, x;int min(int x, int y) &#123; return x &lt; y ? x : y; &#125;bool SPFA(int s, int n) &#123;    std::queue&lt;int&gt; q;    std::fill(dis + 1, dis + n + 1, inf);    q.push(s), dis[s] = 0, inq[s] = 1;    pre[s] = inf, pre[gt] = 0, fl[s] = inf;    while (!q.empty()) &#123;        int f = q.front();        q.pop(), inq[f] = 0;        for (int i = h[f]; i; i = u[i].n) &#123;            if (u[i].c == 0) continue;            int v = u[i].v, w = u[i].w;            if (dis[v] &gt; dis[f] + w) &#123;                pre[v] = i ^ 1;                dis[v] = dis[f] + w;                fl[v] = min(fl[f], u[i].c);                if (!inq[v]) inq[v] = 1, q.push(v);            &#125;        &#125;    &#125;    return pre[gt];&#125;void SSP(int s, int n) &#123;    int p, mn, d;    while (SPFA(s, n)) &#123;        mn = fl[gt], d = 0;        for (p = gt; p != s; p = u[pre[p]].v) &#123;            u[pre[p]].c += mn;            u[pre[p] ^ 1].c -= mn;            d += u[pre[p] ^ 1].w;        &#125;        res += mn * d;    &#125;    return;&#125;void add(int x, int y, int c, int w) &#123;    u[++tot] = _(y, c, w, h[x]);    h[x] = tot;    return;&#125;void addf(int x, int y, int c, int w) &#123;    add(x, y, c, w), add(y, x, 0, -w);    return;&#125;int main() &#123;    read(n);    gs = 2 * n + 1, gt = gs + 1;    for (int i = 1; i &lt;= n; ++i) &#123;        read(x);        addf(i, gt, x, 0);        addf(gs, i + n, x, 0);        if (i != n)            addf(i + n, i + 1 + n, inf, 0);    &#125;    read(m), read(t1);    read(c1), read(t2), read(c2);    for (int i = 1; i &lt;= n; ++i) &#123;        addf(gs, i, inf, m);        if (i + t1 &lt;= n)            addf(i + n, i + t1, inf, c1);        if (i + t2 &lt;= n)            addf(i + n, i + t2, inf, c2);    &#125;    SSP(gs, gt);    print(res, &#39;\n&#39;);    return 0;&#125;&#125; // namespace XSC062#undef int</code></pre></details><hr /><h3 id="d.-运输问题">D. 运输问题</h3><p><a href="http://222.180.160.110:61235/contest/3952/problem/4" class="uri">http://222.180.160.110:61235/contest/3952/problem/4</a></p><p>不是很理解啊，这题就一个普普通通的二分图建模，有什么难点吗，，，</p><p>哦，蓝的，那没事了。</p><details><pre class="cpp"><code>#define int long longnamespace XSC062 &#123;using namespace fastIO;const int inf = 1e18;const int maxn = 4e3 + 5;const int maxm = 6e5 + 5;struct _ &#123;    int v, c, w, n;    _() &#123;&#125;    _(int v1, int c1, int w1, int n1) &#123;        v = v1, c = c1, w = w1, n = n1;    &#125;&#125;;bool inq[maxn];int gs, gt, tot = 1;_ u[maxm], u1[maxm];int fl[maxn], pre[maxn];int h[maxn], dis[maxn], h1[maxn];int n, m, t1, c1, t2, c2, res, x;int min(int x, int y) &#123;    return x &lt; y ? x : y;&#125;bool SPFA(int s, int n) &#123;    std::queue&lt;int&gt; q;    std::fill(dis + 1, dis + n + 1, inf);    q.push(s), dis[s] = 0, inq[s] = 1;    pre[s] = inf, pre[gt] = 0, fl[s] = inf;    while (!q.empty()) &#123;        int f = q.front();        q.pop(), inq[f] = 0;        for (int i = h[f]; i; i = u[i].n) &#123;            if (u[i].c == 0)                continue;            int v = u[i].v, w = u[i].w;            if (dis[v] &gt; dis[f] + w) &#123;                pre[v] = i ^ 1;                dis[v] = dis[f] + w;                fl[v] = min(fl[f], u[i].c);                if (!inq[v]) inq[v] = 1, q.push(v);            &#125;        &#125;    &#125;    return pre[gt];&#125;bool SPFA1(int s, int n) &#123;    std::queue&lt;int&gt; q;    std::fill(pre + 1, pre + n + 1, 0);    std::fill(dis + 1, dis + n + 1, -inf);    q.push(s), dis[s] = 0, inq[s] = 1;    pre[s] = inf, pre[gt] = 0, fl[s] = inf;    while (!q.empty()) &#123;        int f = q.front();        q.pop(), inq[f] = 0;        for (int i = h[f]; i; i = u[i].n) &#123;            if (u[i].c == 0) continue;            int v = u[i].v, w = u[i].w;            if (dis[v] &lt; dis[f] + w) &#123;                pre[v] = i ^ 1;                dis[v] = dis[f] + w;                fl[v] = min(fl[f], u[i].c);                if (!inq[v])                    inq[v] = 1, q.push(v);            &#125;        &#125;    &#125;    return pre[gt];&#125;void SSP(int s, int n) &#123;    int p, mn, d;    while (SPFA(s, n)) &#123;        mn = fl[gt], d = 0;        for (p = gt; p != s; p = u[pre[p]].v) &#123;            u[pre[p]].c += mn;            u[pre[p] ^ 1].c -= mn;            d += u[pre[p] ^ 1].w;        &#125;        res += mn * d;    &#125;    return;&#125;void SSP1(int s, int n) &#123;    int p, mn, d;    while (SPFA1(s, n)) &#123;        mn = fl[gt], d = 0;        for (p = gt; p != s; p = u[pre[p]].v) &#123;            u[pre[p]].c += mn;            u[pre[p] ^ 1].c -= mn;            d += u[pre[p] ^ 1].w;        &#125;        res += mn * d;    &#125;    return;&#125;void add(int x, int y, int c, int w) &#123;    u[++tot] = _(y, c, w, h[x]);    h[x] = tot;    return;&#125;void addf(int x, int y, int c, int w) &#123;    add(x, y, c, w), add(y, x, 0, -w);    return;&#125;int main() &#123;    read(n), read(m);    gs = n + m + 1, gt = gs + 1;    for (int i = 1; i &lt;= n; ++i)        read(x), addf(gs, i, x, 0);    for (int i = 1; i &lt;= m; ++i)        read(x), addf(i + n, gt, x, 0);    for (int i = 1; i &lt;= n; ++i) &#123;        for (int j = 1; j &lt;= m; ++j)            read(x), addf(i, j + n, inf, x);    &#125;    memcpy(h1, h, sizeof (h1));    memcpy(u1, u, sizeof (u1));    SSP(gs, gt);    print(res, &#39;\n&#39;), res = 0;    memcpy(h, h1, sizeof (h));    memcpy(u, u1, sizeof (u));    SSP1(gs, gt);    print(res, &#39;\n&#39;);    return 0;&#125;&#125; // namespace XSC062#undef int</code></pre></details><hr /><h3 id="e.-最小路径覆盖">E. 最小路径覆盖</h3><p><a href="http://222.180.160.110:61235/contest/3952/problem/5" class="uri">http://222.180.160.110:61235/contest/3952/problem/5</a></p><p>当我们把所有点视作长度为 <span class="math inline">\(0\)</span> 的路径时，答案为 <span class="math inline">\(n\)</span>。怎么让这个答案减小呢？我们需要 <strong>合并路径</strong>。</p><p>假设有路径 <span class="math inline">\(u \to x\)</span> 和 <span class="math inline">\(x \to v\)</span>，那么将它们合并为 <span class="math inline">\(u\to v\)</span> 显然可以得到更优的答案。</p><p>那么这个时候就有同学要问了，我选择合并路径的方式会不会对答案产生影响呢？这个不急，我们讲完了再证明。</p><p>首先开一个新图，把所有点整一个保留节目，<span class="math inline">\(S\to x\)</span> 建一条容量为 <span class="math inline">\(1\)</span> 的边；<span class="math inline">\(x&#39; \to T\)</span> 建一条容量为 <span class="math inline">\(1\)</span> 的边；对于边 <span class="math inline">\(u\to v\)</span>，在 <span class="math inline">\(u\to v&#39;\)</span> 建一条容量为 <span class="math inline">\(1\)</span> 的边。</p><p>这个时候我们就有了一个类二分图的模型。想想看，我们在里面跑出来的最大流是什么？</p><p>在这种容量均为 <span class="math inline">\(1\)</span> 的类二分图模型中，网络流中找到的路径其实就是二分图中的增广路，因为反向的容量为 <span class="math inline">\(0\)</span> 的边就相当于已匹配边，会限制搜索进一步搜下去。</p><p>在二分图中，每找到一条增广路，最大匹配的大小便扩大 <span class="math inline">\(1\)</span>；在这里的网络流中也一样，每找到一条路径，最大流的大小便扩大 <span class="math inline">\(1\)</span>。</p><p>那么，这里的「路径」究竟有什么含义？</p><p>一条从 <span class="math inline">\(S\)</span> 到 <span class="math inline">\(T\)</span> 的边，若其流量为 <span class="math inline">\(1\)</span>，我们将它视作原图中被选中、加入路径集合的边，你会发现，找最大流（不断延长路径）的过程就相当于在合并路径，而且最后这个新图满足：点和边都不会被重复选中，且因为我们找的是最大流，所有点都会被选中。</p><p>好好好，正确性就很显而易见了，来自于二分图增广路找最大匹配的正确性（被打）。</p><p>那么求出最大流 <span class="math inline">\(f\)</span>，因为每合并一次路径，路径的条数就会减少 <span class="math inline">\(1\)</span>，所以最后的答案就是 <span class="math inline">\(N - f\)</span>。方案呢？</p><p>因为网络流特性，你会发现路径的起点一定是 <span class="math inline">\(S\to x\)</span>（废话），所以找出所有 <span class="math inline">\(S\to x\)</span> 流量为 <span class="math inline">\(1\)</span> 的 <span class="math inline">\(x\)</span>，它们就是每条路径的起点。</p><p>因为路径没有交叉且肯定联通，所以你沿着这个起点一直找流量为 <span class="math inline">\(1\)</span> 的边就能找到头。</p><details><pre class="cpp"><code>namespace XSC062 &#123;using namespace fastIO;const int inf = 1e18;const int maxn = 4e3 + 5;const int maxm = 6e5 + 5;struct _ &#123;    int v, w, n;    _() &#123;&#125;    _(int v1, int w1, int n1) &#123;        v = v1, w = w1, n = n1;    &#125;&#125;;_ u[maxm];bool vis1[maxn];int n, m, x, y, res;int gs, gt, tot = 1;int a[maxn], h[maxn], f[maxn];int vis[maxn], now[maxn], dep[maxn];int min(int x, int y) &#123; return x &lt; y ? x : y; &#125;int max(int x, int y) &#123; return x &gt; y ? x : y; &#125;bool BFS(int n) &#123;    std::fill(vis + 1, vis + n + 1, 0);    std::fill(dep + 1, dep + n + 1, 0);     std::queue&lt;int&gt; q;    dep[gs] = 1, vis[gs] = 1;    q.push(gs), now[gs] = h[gs];    while (!q.empty()) &#123;        int f = q.front(); q.pop();        for (int i = h[f]; i; i = u[i].n) &#123;            int v = u[i].v, w = u[i].w;            if (vis[v] == 1 || w == 0) continue;            vis[v] = 1, now[v] = h[v];            dep[v] = dep[f] + 1, q.push(v);            if (v == gt) return 1;        &#125;    &#125;    return 0;&#125;int findP(int x, int flow = inf) &#123;    if (x == gt) return flow;    int rest = flow, i;    for (i = now[x]; rest &amp;&amp; i; i = u[i].n) &#123;        int v = u[i].v, w = u[i].w;        now[x] = i;        if (dep[v] != dep[x] + 1 || w == 0) continue;        int t = findP(v, min(rest, w));        if (t == 0) dep[v] = 0;        rest -= t, u[i].w -= t, u[i ^ 1].w += t;    &#125;    return flow - rest;&#125;int Dinic(int n) &#123;    int res = 0;    while (BFS(n)) &#123;        int t = findP(gs);        while (t) res += t, t = findP(gs);    &#125;    return res;&#125;void add(int x, int y, int w) &#123;    u[++tot] = _(y, w, h[x]);    h[x] = tot;    return;&#125;void addf(int x, int y, int w) &#123;    add(x, y, w), add(y, x, 0);    return;&#125;void output(int x) &#123;    if (x == gs) return;    print(x, &#39; &#39;), vis1[x] = 1;    for (int i = h[x]; i; i = u[i].n) &#123;        int v = u[i].v;        if (v &lt;= n || v &gt; 2 * n || vis1[v - n])            continue;        if (u[i].w == 0) &#123;            output(u[i].v - n);            return;        &#125;    &#125;    return;&#125;int main() &#123;    read(n), read(m);    gs = 2 * n + 1, gt = gs + 1;    for (int i = 1; i &lt;= n; ++i) &#123;        addf(gs, i, 1);        addf(i + n, gt, 1);    &#125;    while (m--) &#123;        read(x), read(y);        addf(x, y + n, 1);    &#125;    res = n - Dinic(gt);    for (int i = h[gt]; i; i = u[i].n) &#123;        if (u[i ^ 1].w == 1) &#123;            output(u[i].v - n);            putchar(&#39;\n&#39;);        &#125;    &#125;    print(res, &#39;\n&#39;);    return 0;&#125;&#125; // namespace XSC062#undef int</code></pre></details><hr /><h3 id="f.-数字梯形">F. 数字梯形</h3><p><a href="http://222.180.160.110:61235/contest/3952/problem/6" class="uri">http://222.180.160.110:61235/contest/3952/problem/6</a></p><p>在 GM 的强制要求下只能跳了，呜呜呜</p><hr /><h2 id="day-27th---14th">Day 2：7th - 14th</h2><h3 id="a.-太空飞行计划">A. 太空飞行计划</h3><p><a href="http://222.180.160.110:61235/contest/3976/problem/1" class="uri">http://222.180.160.110:61235/contest/3976/problem/1</a></p><p>不难想到把大源点和实验连容量为报酬的边；把仪器和大汇点连容量为消费的边；实验和仪器之间连容量为无穷大的边。</p><p>这个时候我们要选择一些实验不去做，选择一些仪器不要，并且要求要和不要的实验和仪器之间不能有边关联，还要求留下的利润最大。</p><p>假如我们把删去一条仪器边视作保留仪器，删去一条实验边视作跳过实验，这是什么？最小割！因为必须保证没有关联，这和最小割要求被分为两个部分是符合的。因为中间的边容量无穷大，故绝对不会选中间的边。同时，它删除了最不赚钱的实验，保留了最便宜的仪器。</p><p>据说这也是个经典最小割模型，建议掌握。</p><p>然后答案呢？先暂时将器材视为负权值，则：</p><ol type="1"><li>总收入 为 被选中的实验权值 加上 被选中的器材权值</li><li>被选中的实验权值 为 所有实验权值和 减去 未被选择的实验权值和</li><li>总收入 为 所有实验权值和 减去 未被选择的实验权值和 加上 被选中的器材权值</li><li>总收入 为 所有实验权值和 减去 未被选择的实验权值和 减去 被选中的器材权值的相反数</li><li>最小割 为 未被选择的实验权值和 加上 被选中的器材权值的相反数</li><li>总收入 为 被选中的实验权值 减去 最小割</li></ol><p>那么怎么输出方案呢？</p><p><a href="https://www.luogu.com.cn/blog/35891/solution-p2762" class="uri">https://www.luogu.com.cn/blog/35891/solution-p2762</a></p><p>woc 这篇讲得太好了。最后一次 Dinic 失败了，这是为什么呢？因为 BFS 找不到汇点了，说明若干条残量为 0 的边已经堵死了从源点到汇点的路。这个时候这些残量为 0 的边其实就是最小割。</p><p>那选取的实验和仪器，就是从源点出发可以到达的（已在 BFS 中为其分层作为记号），所以只需统计有层数的点即可。太妙了。</p><details><pre class="cpp"><code>#define int long longnamespace XSC062 &#123;using namespace fastIO;const int inf = 1e18;const int maxn = 4e3 + 5;const int maxm = 6e5 + 5;struct _ &#123;    int v, w, n;    _() &#123;&#125;    _(int v1, int w1, int n1) &#123;        v = v1, w = w1, n = n1;    &#125;&#125;;_ u[maxm];bool vis1[maxn];int n, m, x, y, res;int gs, gt, tot = 1;int a[maxn], h[maxn], f[maxn];int vis[maxn], now[maxn], dep[maxn];int min(int x, int y) &#123; return x &lt; y ? x : y; &#125;int max(int x, int y) &#123; return x &gt; y ? x : y; &#125;bool BFS(int n) &#123;    std::fill(vis + 1, vis + n + 1, 0);    std::fill(dep + 1, dep + n + 1, 0);     std::queue&lt;int&gt; q;    dep[gs] = 1, vis[gs] = 1;    q.push(gs), now[gs] = h[gs];    while (!q.empty()) &#123;        int f = q.front(); q.pop();        for (int i = h[f]; i; i = u[i].n) &#123;            int v = u[i].v, w = u[i].w;            if (vis[v] == 1 || w == 0) continue;            vis[v] = 1, now[v] = h[v];            dep[v] = dep[f] + 1, q.push(v);            if (v == gt) return 1;        &#125;    &#125;    return 0;&#125;int findP(int x, int flow = inf) &#123;    if (x == gt) return flow;    int rest = flow, i;    for (i = now[x]; rest &amp;&amp; i; i = u[i].n) &#123;        int v = u[i].v, w = u[i].w;        now[x] = i;        if (dep[v] != dep[x] + 1 || w == 0) continue;        int t = findP(v, min(rest, w));        if (t == 0) dep[v] = 0;        rest -= t, u[i].w -= t, u[i ^ 1].w += t;    &#125;    return flow - rest;&#125;int Dinic(int n) &#123;    int res = 0;    while (BFS(n)) &#123;        int t = findP(gs);        while (t) res += t, t = findP(gs);    &#125;    return res;&#125;void add(int x, int y, int w) &#123;    u[++tot] = _(y, w, h[x]);    h[x] = tot;    return;&#125;void addf(int x, int y, int w) &#123;    add(x, y, w), add(y, x, 0);    return;&#125;int main() &#123;    scanf(&quot;%lld %lld&quot;, &amp;n, &amp;m);    gs = n + m + 1, gt = gs + 1;    for (int i = 1; i &lt;= n; ++i) &#123;        scanf(&quot;%lld&quot;, &amp;x);        addf(gs, i, x);        res += x;        std::string tmp;        std::getline(std::cin, tmp);        std::stringstream t(tmp);        while (t &gt;&gt; y)            addf(i, y + n, inf);    &#125;    for (int i = 1; i &lt;= m; ++i)        read(x), addf(n + i, gt, x);    res -= Dinic(gt);    for (int i = 1; i &lt;= n; ++i)        if (dep[i] != 0) print(i, &#39; &#39;);    putchar(&#39;\n&#39;);    for (int i = n + 1; i &lt;= n + m; ++i)        if (dep[i] != 0) print(i - n, &#39; &#39;);    putchar(&#39;\n&#39;), print(res, &#39;\n&#39;);    return 0;&#125;&#125; // namespace XSC062#undef int</code></pre></details>]]></content>
      
      
      
        <tags>
            
            <tag> 网络流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>费用流练习</title>
      <link href="/20230720/"/>
      <url>/20230720/</url>
      
        <content type="html"><![CDATA[<p><a href="http://222.180.160.110:61235/contest/3820">费用流入门练习</a>。</p><span id="more"></span><hr /><h3 id="a.-订货">A. 订货</h3><p><a href="http://222.180.160.110:61235/contest/3820/problem/1" class="uri">http://222.180.160.110:61235/contest/3820/problem/1</a></p><p>这个带继承关系的模型很熟悉，想到了 <a href="https://www.cnblogs.com/XSC062/p/17548925.html">猪</a> 那一题。所以我们试着仿照这个方式来建图。</p><p>题目提到了单位费用，这简直就是直接把边的费用拍你脸上嘲讽。</p><p>我们拉一个大源点，朝每个月连一条容量为无穷大、费用为当月购买单位费用的边，表示每个月的购买。</p><p>拉一个大汇点，每个月朝它连一条容量为当月需求量、费用为 <span class="math inline">\(0\)</span> 的边，表示每个月的需求。</p><p>再让每个月朝下一个月连一条容量为仓库容量、费用为贮存费用的边，表示继承。跑一个最小费用最大流即可。</p><details><pre class="cpp"><code>#define int long longnamespace XSC062 &#123;using namespace fastIO;const int maxn = 405;const int inf = 1e18;const int maxm = 5e5 + 5;struct _ &#123;    int v, c, w, n;    _() &#123;&#125;    _(int v1, int c1, int w1, int n1) &#123;        v = v1, c = c1, w = w1, n = n1;    &#125;&#125;;_ u[maxm];bool inq[maxn];int n, m, S, x, res;int gs, gt, tot = 1;int h[maxn], dis[maxn];int fl[maxn], pre[maxn];int min(int x, int y) &#123;    return x &lt; y ? x : y;&#125;bool SPFA(int s, int n) &#123;    std::queue&lt;int&gt; q;    std::fill(dis + 1, dis + n + 1, inf);    q.push(s), dis[s] = 0, inq[s] = 1;    pre[s] = inf, pre[gt] = 0, fl[s] = inf;    while (!q.empty()) &#123;        int f = q.front();        q.pop(), inq[f] = 0;        for (int i = h[f]; i; i = u[i].n) &#123;            if (u[i].c == 0)                continue;            int v = u[i].v, w = u[i].w;            if (dis[v] &gt; dis[f] + w) &#123;                pre[v] = i ^ 1;                dis[v] = dis[f] + w;                fl[v] = min(fl[f], u[i].c);                if (!inq[v])                    inq[v] = 1, q.push(v);            &#125;        &#125;    &#125;    return pre[gt];&#125;void SSP(int s, int n) &#123;    int p, mn, d;    while (SPFA(s, n)) &#123;        mn = fl[gt], d = 0;        for (p = gt; p != s; p = u[pre[p]].v) &#123;            u[pre[p]].c += mn;            u[pre[p] ^ 1].c -= mn;            d += u[pre[p] ^ 1].w;        &#125;        res += mn * d;    &#125;    return;&#125;void add(int x, int y, int c, int w) &#123;    u[++tot] = _(y, c, w, h[x]);    h[x] = tot;    return;&#125;void addf(int x, int y, int c, int w) &#123;    add(x, y, c, w), add(y, x, 0, -w);    return;&#125;int main() &#123;    read(n), read(m), read(S);    gs = n + 1, gt = gs + 1;    for (int i = 1; i &lt;= n; ++i) &#123;        read(x);        addf(i, gt, x, 0);        if (i != n)            addf(i, i + 1, S, m);    &#125;    for (int i = 1; i &lt;= n; ++i) &#123;        read(x);        addf(gs, i, inf, x);    &#125;        SSP(gs, gt);    print(res, &#39;\n&#39;);    return 0;&#125;&#125; // namespace XSC062#undef int  </code></pre></details><hr /><h3 id="b.-网络扩容">B. 网络扩容</h3><p><a href="http://222.180.160.110:61235/contest/3820/problem/2" class="uri">http://222.180.160.110:61235/contest/3820/problem/2</a></p><p>鉴于一道费用流不会无缘无故先让你求一遍最大流，我们先持观望态度，暂且认为最大流对题目有提示作用 <del>而不是说这道题就是个缝合怪</del></p><p>其实看完题我们就悟了，这怎么这么像上下界网络流那个差量网络呀，要不我们试试这么干？</p><p>我们先求得普通网络中的最大流，然后每条边减去流量，就成为了一个「差量网络 Pro」。那么我们现在就要通过扩容让该网络中的最大流变为 <span class="math inline">\(K\)</span>。对于扩容的操作，不难想到把每条边的边权设为正无穷，然后费用设为扩容费用。</p><p>现在有了一个问题：原图中未留满的边，在现在的新网络中的残余容量应该如何处理呢？很简单，我们就把它当作已经扩过了这么多容，通过拆边操作拆出来一条容量为原图中残余容量、费用为 <span class="math inline">\(0\)</span>「会员通道」，那么算法就会优先选择这条边。</p><p>怎么去控制流量为 <span class="math inline">\(K\)</span>？联想到之前的拆边操作，我们考虑拆点。在 <span class="math inline">\(1\)</span> 和 <span class="math inline">\(N\)</span> 中任选一个拆开作为新的源点 / 汇点，新点和旧点之间的容量为 <span class="math inline">\(K\)</span>、费用为 <span class="math inline">\(0\)</span> 即可。</p><p>然后跑一个最小费用最大流就行。<del>该说不说题目的正解思路引导做得还挺好的</del></p><p>其实注意到在跑完最大流之后，所有正向边的残余容量已经求得，只要在跑最大流时令所有边的费用为 <span class="math inline">\(0\)</span>（毕竟最大流不关心费用），就可以沿用原图，只加新边再跑费用流。</p><details><pre class="cpp"><code>#define int long longnamespace XSC062 &#123;using namespace fastIO;const int inf = 1e18;const int maxn = 1e3 + 5;const int maxm = 5e5 + 5;struct _ &#123;    int v, c, w, n;    _() &#123;&#125;    _(int v1, int c1, int w1, int n1) &#123;        v = v1, c = c1, w = w1, n = n1;    &#125;&#125;;struct __ &#123; int x, y, c, w; &#125;;_ u[maxm];__ w[maxm];bool inq[maxn];int n, m, k, res;int gs, gt, tot = 1;int h[maxn], dis[maxn];int fl[maxn], pre[maxn];int vis[maxn], now[maxn], dep[maxn];int min(int x, int y) &#123;    return x &lt; y ? x : y;&#125;bool BFS(int n) &#123;    std::fill(vis + 1, vis + n + 1, 0);    std::fill(dep + 1, dep + n + 1, 0);     std::queue&lt;int&gt; q;    dep[gs] = 1, vis[gs] = 1;    q.push(gs), now[gs] = h[gs];    while (!q.empty()) &#123;        int f = q.front();        q.pop();        for (int i = h[f]; i; i = u[i].n) &#123;            int v = u[i].v, w = u[i].c;            if (vis[v] == 1 || w == 0)                continue;            vis[v] = 1, now[v] = h[v];            dep[v] = dep[f] + 1, q.push(v);            if (v == gt)                return 1;        &#125;    &#125;    return 0;&#125;int findP(int x, int flow = inf) &#123;    if (x == gt)        return flow;    int rest = flow, i;    for (i = now[x]; rest &amp;&amp; i; i = u[i].n) &#123;        int v = u[i].v, w = u[i].c;        now[x] = i;        if (dep[v] != dep[x] + 1 || w == 0)            continue;        int t = findP(v, min(rest, w));        if (t == 0)            dep[v] = 0;        rest -= t;        u[i].c -= t, u[i ^ 1].c += t;    &#125;    return flow - rest;&#125;int Dinic(int n) &#123;    int res = 0;    while (BFS(n)) &#123;        int t = findP(gs);        while (t) &#123;            res += t;            t = findP(gs);        &#125;    &#125;    return res;&#125;bool SPFA(int s, int n) &#123;    std::queue&lt;int&gt; q;    std::fill(dis + 1, dis + n + 1, inf);    q.push(s), dis[s] = 0, inq[s] = 1;    pre[s] = inf, pre[gt] = 0, fl[s] = inf;    while (!q.empty()) &#123;        int f = q.front();        q.pop(), inq[f] = 0;        for (int i = h[f]; i; i = u[i].n) &#123;            if (u[i].c == 0)                continue;            int v = u[i].v, w = u[i].w;            if (dis[v] &gt; dis[f] + w) &#123;                pre[v] = i ^ 1;                dis[v] = dis[f] + w;                fl[v] = min(fl[f], u[i].c);                if (!inq[v])                    inq[v] = 1, q.push(v);            &#125;        &#125;    &#125;    return pre[gt];&#125;void SSP(int s, int n) &#123;    int p, mn, d;    while (SPFA(s, n)) &#123;        mn = fl[gt], d = 0;        for (p = gt; p != s; p = u[pre[p]].v) &#123;            u[pre[p]].c += mn;            u[pre[p] ^ 1].c -= mn;            d += u[pre[p] ^ 1].w;        &#125;        res += mn * d;    &#125;    return;&#125;void add(int x, int y, int c, int w) &#123;    u[++tot] = _(y, c, w, h[x]);    h[x] = tot;    return;&#125;void addf(int x, int y, int c, int w = 0) &#123;    add(x, y, c, w), add(y, x, 0, -w);    return;&#125;int main() &#123;    read(n), read(m), read(k);    gs = 1, gt = n;    for (int i = 1; i &lt;= m; ++i) &#123;        read(w[i].x), read(w[i].y);        read(w[i].c), read(w[i].w);        addf(w[i].x, w[i].y, w[i].c);    &#125;    print(Dinic(n), &#39; &#39;);    gs = n + 1, addf(gs, 1, k, 0);    for (int i = 1; i &lt;= m; ++i)        addf(w[i].x, w[i].y, inf, w[i].w);    SSP(gs, gt);    print(res, &#39;\n&#39;);    return 0;&#125;&#125; // namespace XSC062#undef int</code></pre></details><hr /><h3 id="c.-航班安排">C. 航班安排</h3><p><a href="http://222.180.160.110:61235/contest/3820/problem/3" class="uri">http://222.180.160.110:61235/contest/3820/problem/3</a></p><p>很简单一个道理，时间的具体值对我们来说并不重要。能到就是能到，不能到就是不能到。</p><p>边权矩阵也并不是全部有用，这条边和任务有关系吗？没有，那就当它是空气。</p><p>那什么会对我们产生限制？飞机数量。故容量由飞机数量决定。什么是我们要最大化的值？收益，故我们的费用是支出。</p><p>如果飞机能在一个任务结束之后，在另一个任务开始之前飞过去，那就将两个任务连边，容量为 <span class="math inline">\(1\)</span>，费用为两点间花费。特别地，应将机场拆为大源点和大汇点，并在二者中任选其一拆点（和 T2 类似），好作出 <span class="math inline">\(K\)</span> 的流量限制。</p><p>还有一个小细节，对于一个任务的流量我们也要加以约束，不然碰到流入 <span class="math inline">\(2\)</span> 流出 <span class="math inline">\(2\)</span> 这种平衡但不合法的情况就不行了，所以对于任务我们也要按老套路拆点。</p><details><pre class="cpp"><code>#define int long longnamespace XSC062 &#123;using namespace fastIO;const int inf = 1e18;const int maxn = 405;const int maxm = 4e5 + 5;struct _ &#123;    int v, c, w, n;    _() &#123;&#125;    _(int v1, int c1, int w1, int n1) &#123;        v = v1, c = c1, w = w1, n = n1;    &#125;&#125;;struct __ &#123;    int x, y, l, r, c;    bool operator&lt; (const __ &amp;q) const &#123;        return l &lt; q.l;    &#125;&#125;;_ u[maxm];__ w[maxn];bool inq[maxn];int gs, gt, tot = 1;int h[maxn], dis[maxn];int fl[maxn], pre[maxn];int n, m, k, T, res, fs, ft;int t[maxn][maxn], f[maxn][maxn];int min(int x, int y) &#123;    return x &lt; y ? x : y;&#125;bool SPFA(int s, int n) &#123;    std::queue&lt;int&gt; q;    std::fill(dis + 1, dis + n + 1, inf);    q.push(s), dis[s] = 0, inq[s] = 1;    pre[s] = inf, pre[gt] = 0, fl[s] = inf;    while (!q.empty()) &#123;        int f = q.front();        q.pop(), inq[f] = 0;        for (int i = h[f]; i; i = u[i].n) &#123;            if (u[i].c == 0)                continue;            int v = u[i].v, w = u[i].w;            if (dis[v] &gt; dis[f] + w) &#123;                pre[v] = i ^ 1;                dis[v] = dis[f] + w;                fl[v] = min(fl[f], u[i].c);                if (!inq[v])                    inq[v] = 1, q.push(v);            &#125;        &#125;    &#125;    return pre[gt];&#125;void SSP(int s, int n) &#123;    int p, mn, d;    while (SPFA(s, n)) &#123;        mn = fl[gt], d = 0;        for (p = gt; p != s; p = u[pre[p]].v) &#123;            u[pre[p]].c += mn;            u[pre[p] ^ 1].c -= mn;            d += u[pre[p] ^ 1].w;        &#125;        res += mn * d;    &#125;    return;&#125;void add(int x, int y, int c, int w) &#123;    u[++tot] = _(y, c, w, h[x]);    h[x] = tot;    return;&#125;void addf(int x, int y, int c, int w) &#123;    add(x, y, c, w), add(y, x, 0, -w);    return;&#125;int main() &#123;    read(n), read(m), read(k), read(T);    fs = 2 * m + 1, ft = 2 * m + 2;    gs = 2 * m + 3, gt = 2 * m + 4;    addf(gs, fs, k, 0), addf(ft, gt, k, 0);    for (int i = 1; i &lt;= n; ++i) &#123;        for (int j = 1; j &lt;= n; ++j)            read(t[i][j]);    &#125;    for (int i = 1; i &lt;= n; ++i) &#123;        for (int j = 1; j &lt;= n; ++j)            read(f[i][j]);    &#125;    for (int i = 1; i &lt;= m; ++i) &#123;        read(w[i].x), read(w[i].y);        read(w[i].l), read(w[i].r);        read(w[i].c), ++w[i].x, ++w[i].y;    &#125;    for (int i = 1; i &lt;= m; ++i) &#123;        addf(i + m, i, 1, 0);        if (t[1][w[i].x] &lt;= w[i].l) &#123;            addf(fs, i + m, 1,                f[1][w[i].x] - w[i].c);        &#125;        if (w[i].r + t[w[i].y][1] &lt;= T)            addf(i, ft, 1, f[w[i].y][1]);        for (int j = 1; j &lt;= m; ++j) &#123;            if (i != j &amp;&amp; w[i].r +                t[w[i].y][w[j].x] &lt;= w[j].l) &#123;                addf(i, j + m, 1,                    f[w[i].y][w[j].x] - w[j].c);            &#125;        &#125;    &#125;    SSP(gs, gt);    print(-res, &#39;\n&#39;);    return 0;&#125;&#125; // namespace XSC062#undef int</code></pre></details><hr /><h3 id="d.-修车">D. 修车</h3><p><a href="http://222.180.160.110:61235/contest/3820/problem/4" class="uri">http://222.180.160.110:61235/contest/3820/problem/4</a></p><p>顾客数一定，所谓平均等待时间不过是个幌子，只需要求得最小等待总时间。</p><p>技术人员不能同时修两辆车，<span class="math inline">\(M\)</span> 的范围又这么小，不往拆点想都难。可问题来了，怎么拆呢？</p><p>我一开始的想法是，用点 <span class="math inline">\((i, j)\)</span> 表示人 <span class="math inline">\(i\)</span> 修车 <span class="math inline">\(j\)</span>，但是这样建图怎样也无法达到目的。</p><p>于是我添加了一个维度 <span class="math inline">\(k\)</span>，用点 <span class="math inline">\((i, j, k)\)</span> 表示人 <span class="math inline">\(i\)</span> 修车 <span class="math inline">\(j\)</span>，并且这是他修的倒数第 <span class="math inline">\(k\)</span> 辆车，这样建图就轻而易举了。但接下来就面临了一个问题：这数据范围跑不过。于是乎审视我们的点，其实 <span class="math inline">\(j\)</span> 这个维度是可以被合并的，只保留 <span class="math inline">\((i, k)\)</span>，因为不可能存在两辆车同时为人 <span class="math inline">\(i\)</span> 的倒数第 <span class="math inline">\(k\)</span> 辆车。</p><p>故将大源点和每辆车连边，容量为 <span class="math inline">\(1\)</span>，费用为 <span class="math inline">\(0\)</span>；将每辆车 <span class="math inline">\(j\)</span> 和每个 <span class="math inline">\((i, k)\)</span> 连边，容量为 <span class="math inline">\(1\)</span>，费用为 <span class="math inline">\(T_{i, j}\times k\)</span>。</p><p>这里有一点点费用提前计算的意思，所以就直接将每个 <span class="math inline">\((i, j)\)</span> 和大汇点连边，容量为 <span class="math inline">\(1\)</span>，费用为 <span class="math inline">\(0\)</span>。</p><details><pre class="cpp"><code>#define int long longnamespace XSC062 &#123;using namespace fastIO;const int inf = 1e18;const int maxn = 1e4 + 5;const int maxm = 1e6 + 5;struct _ &#123;    int v, c, w, n;    _() &#123;&#125;    _(int v1, int c1, int w1, int n1) &#123;        v = v1, c = c1, w = w1, n = n1;    &#125;&#125;;_ u[maxm];bool inq[maxn];int n, m, x, res;int gs, gt, tot = 1;int h[maxn], dis[maxn];int fl[maxn], pre[maxn];int fun(int i, int j) &#123;    return n + (i - 1) * n + j;&#125;int min(int x, int y) &#123;    return x &lt; y ? x : y;&#125;bool SPFA(int s, int n) &#123;    std::queue&lt;int&gt; q;    std::fill(dis + 1, dis + n + 1, inf);    q.push(s), dis[s] = 0, inq[s] = 1;    pre[s] = inf, pre[gt] = 0, fl[s] = inf;    while (!q.empty()) &#123;        int f = q.front();        q.pop(), inq[f] = 0;        for (int i = h[f]; i; i = u[i].n) &#123;            if (u[i].c == 0)                continue;            int v = u[i].v, w = u[i].w;            if (dis[v] &gt; dis[f] + w) &#123;                pre[v] = i ^ 1;                dis[v] = dis[f] + w;                fl[v] = min(fl[f], u[i].c);                if (!inq[v])                    inq[v] = 1, q.push(v);            &#125;        &#125;    &#125;    return pre[gt];&#125;void SSP(int s, int n) &#123;    int p, mn, d;    while (SPFA(s, n)) &#123;        mn = fl[gt], d = 0;        for (p = gt; p != s; p = u[pre[p]].v) &#123;            u[pre[p]].c += mn;            u[pre[p] ^ 1].c -= mn;            d += u[pre[p] ^ 1].w;        &#125;        res += mn * d;    &#125;    return;&#125;void add(int x, int y, int c, int w) &#123;    u[++tot] = _(y, c, w, h[x]);    h[x] = tot;    return;&#125;void addf(int x, int y, int c, int w) &#123;    add(x, y, c, w), add(y, x, 0, -w);    return;&#125;int main() &#123;    read(m), read(n);    gs = n * m + n + 1, gt = gs + 1;    for (int i = 1; i &lt;= n; ++i)        addf(gs, i, 1, 0);    for (int i = 1; i &lt;= n * m; ++i)        addf(i + n, gt, 1, 0);    for (int i = 1; i &lt;= n; ++i) &#123;        for (int j = 1; j &lt;= m; ++j) &#123;            read(x);            for (int k = 1; k &lt;= n; ++k) &#123;                addf(i, fun(j, k),                            1, x * k);            &#125;        &#125;    &#125;    SSP(gs, gt);    printf(&quot;%.2lf&quot;, res * 1.0 / n);    return 0;&#125;&#125; // namespace XSC062#undef int</code></pre></details><hr /><h3 id="e.-连连看">E. 连连看</h3><p><a href="http://222.180.160.110:61235/contest/3820/problem/5" class="uri">http://222.180.160.110:61235/contest/3820/problem/5</a></p><p>样例已经告诉了我们事实：小心删数，因为会有数同时出现在多组勾股数中。</p><p>还是熟悉的单点 <span class="math inline">\(1\)</span> 流量限制，故拆点为入点和出点，入点连大源点容量为 <span class="math inline">\(1\)</span> 费用为 <span class="math inline">\(0\)</span>，出点连大汇点容量为 <span class="math inline">\(1\)</span> 费用为 <span class="math inline">\(0\)</span>，满足条件的 <span class="math inline">\(x\)</span> 和 <span class="math inline">\(y\)</span> 我们为了不整细节就暴力地连双向边然后跑最大费用最大流。</p><p>由于双向边这个神必操作，最后的最大流和最大费用都会翻倍，输出的时候要减半。</p><details><pre class="cpp"><code>#define int long longnamespace XSC062 &#123;using namespace fastIO;const int inf = 1e18;const int maxn = 2e3 + 5;const int maxm = 4e5 + 5;struct _ &#123;    int v, c, w, n;    _() &#123;&#125;    _(int v1, int c1, int w1, int n1) &#123;        v = v1, c = c1, w = w1, n = n1;    &#125;&#125;;_ u[maxm];bool inq[maxn];int l, r, res, cnt;bool f[maxn][maxn];int gs, gt, tot = 1;int h[maxn], dis[maxn];int fl[maxn], pre[maxn];int gcd(int x, int y) &#123;    return y ? gcd(y, x % y) : x;&#125;int min(int x, int y) &#123;    return x &lt; y ? x : y;&#125;bool SPFA(int s, int n) &#123;    std::queue&lt;int&gt; q;    std::fill(dis + 1, dis + n + 1, -inf);    q.push(s), dis[s] = 0, inq[s] = 1;    pre[s] = inf, pre[gt] = 0, fl[s] = inf;    while (!q.empty()) &#123;        int f = q.front();        q.pop(), inq[f] = 0;        for (int i = h[f]; i; i = u[i].n) &#123;            if (u[i].c == 0)                continue;            int v = u[i].v, w = u[i].w;            if (dis[v] &lt; dis[f] + w) &#123;                pre[v] = i ^ 1;                dis[v] = dis[f] + w;                fl[v] = min(fl[f], u[i].c);                if (!inq[v])                    inq[v] = 1, q.push(v);            &#125;        &#125;    &#125;    return pre[gt];&#125;void SSP(int s, int n) &#123;    int p, mn, d;    while (SPFA(s, n)) &#123;        mn = fl[gt], d = 0;        for (p = gt; p != s; p = u[pre[p]].v) &#123;            u[pre[p]].c += mn;            u[pre[p] ^ 1].c -= mn;            d += u[pre[p] ^ 1].w;        &#125;        res += mn * d, cnt += mn;    &#125;    return;&#125;void add(int x, int y, int c, int w) &#123;    u[++tot] = _(y, c, w, h[x]);    h[x] = tot;    return;&#125;void addf(int x, int y, int c, int w) &#123;    if (f[x][y])        return;    f[x][y] = f[y][x] = 1;    add(x, y, c, w), add(y, x, 0, -w);    return;&#125;bool check(int x, int y) &#123;    int z = sqrt(x * x - y * y);    if (z * z + y * y == x * x)        return (gcd(z, y) == 1);    return 0;&#125;int main() &#123;    read(l), read(r);    gs = 2 * r + 1, gt = 2 * r + 2;    for (int i = l; i &lt;= r; ++i) &#123;        addf(gs, i, 1, 0);        addf(i + r, gt, 1, 0);        for (int j = l; j &lt; i; ++j) &#123;            if (check(i, j)) &#123;                addf(j, i + r, 1, i + j);                addf(i, j + r, 1, i + j);            &#125;        &#125;    &#125;    SSP(gs, gt);    print(cnt / 2, &#39; &#39;), print(res / 2, &#39;\n&#39;);    return 0;&#125;&#125; // namespace XSC062#undef int</code></pre></details><hr /><p>依我看，队名就叫「曾总说的都队」吧 🐵</p>]]></content>
      
      
      
        <tags>
            
            <tag> 网络流 </tag>
            
            <tag> 费用流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习小组</title>
      <link href="/20230717/"/>
      <url>/20230717/</url>
      
        <content type="html"><![CDATA[<p>Solution to <a href="https://codeforces.com/problemset/problem/756/D">CF756D Bacterial Melee</a>。</p><span id="more"></span><hr /><p>给我整不会了。怎么处理平方？怎么控制参与总学生最多？其中一定又有什么我不知道的奇技淫巧。</p><p>一切尽在连边。</p><ul><li><p>处理学生与社团间的选择关系</p><p>把学生向社团连边。学生只能选取某社团一次，故容量为 <span class="math inline">\(1\)</span>。</p><p>一个学生选取某个社团并不会立即对最终花费带来可计算的影响，因为最终花费由该社团参与的 <strong>所有学生平方数</strong> 决定。</p>故这一步我们先不慌计算社团的代价，只算参与社团本身需要的手续费 <span class="math inline">\(F_i\)</span>。但是需要注意到手续费是财务部的收入而非支出，故实际边权为 <span class="math inline">\(-F_i\)</span>，计算答案时视作负支出（明显不会因此而产生负环，因此可以放心加边）。</li><li><p>处理学生的选择数量上限</p><p>学生最多只能选择 <span class="math inline">\(K\)</span> 个社团，为保证这一点，我们将源点向学生连边，容量为 <span class="math inline">\(K\)</span>。</p>很明显，代价也不在此处计算，故令费用为 <span class="math inline">\(0\)</span>。</li><li><p>保证代价最小</p><p>一开始，我认为最小费用最大流一定会找到最小费用，这个处理是无意义的，后来被打脸了。</p><p>我们若欲在此图中寻得最小费用最大流，则 <strong>流一定最大</strong>。</p><p>而学生的流入容量为 <span class="math inline">\(K\)</span>，为了满流，学生一定会尽可能多地选择社团，那么费用就会噌噌上涨。回到目标，即保证学生都选取至少一个社团时，支出最小。</p><p>那我们只要给机会让学生可以只选取一个社团就好了（当然也可以是两个、三个……）。</p><p>故让学生向终点连边，容量为 <span class="math inline">\(K-1\)</span>，那么学生可以在选取了所有比较赚的社团后就不再选了，选这条边达到满流。同样因为该边流量只有 <span class="math inline">\(K-1\)</span>，学生为了满流就只能再选至少一个社团，满足题意。</p>不选社团明显是没有手续费和社团支出的，故费用为 <span class="math inline">\(0\)</span>。</li><li><p>处理社团本身支出</p><p>问题在于如何处理 <span class="math inline">\(a\)</span> 这个平方项。</p><p>对于平方，我们可以联想到许多数学知识，譬如完全平方、平方差等，这里用到了平方差。</p><p>假如原来的代价是 <span class="math inline">\(C_i\times x^2\)</span>，又加入了一个人，那么费用会变成 <span class="math inline">\(C_i\times (x + 1)^2\)</span>。由平方差得两者之差为 <span class="math inline">\(C_i\times (2\times x + 1)\)</span>。当 <span class="math inline">\(x - 1\)</span> 取为任意正整数时，<span class="math inline">\(2\times x + 1\)</span> 即为所有奇数。</p><p>所以我们将社团向汇点连边，连很多条边，每条边表示 <strong>新增一个团员的代价</strong>，容量为 <span class="math inline">\(1\)</span> 表示一个新增团员，费用为从 <span class="math inline">\(1\)</span> 开始，一直到 <span class="math inline">\(2\times (N - 1) + 1\)</span> 的所有奇数。</p></li></ul><p>那么问题到这里就算处理完了。直接上费用流即可。</p><p>不知道我的代码遭遇了哪家宇宙射线的侵蚀，Dinic 死活过不去，换成 EK 就过了。同学们如果发现自己的 Dinic 过不了也可以试试换 EK。</p><details><pre class="cpp"><code>#define int long longnamespace XSC062 &#123;using namespace fastIO;const int maxn = 405;const int inf = 1e18;const int maxm = 5e5 + 5;struct _ &#123;    int v, c, w, n;    _() &#123;&#125;    _(int v1, int c1, int w1, int n1) &#123;        v = v1, c = c1, w = w1, n = n1;    &#125;&#125;;_ u[maxm];bool inq[maxn];int n, m, k, x, res;int gs, gt, tot = 1;int c[maxn], f[maxn];int h[maxn], dis[maxn];int fl[maxn], pre[maxn];int min(int x, int y) &#123;    return x &lt; y ? x : y;&#125;bool SPFA(int s, int n) &#123;    std::queue&lt;int&gt; q;    std::fill(dis + 1, dis + n + 1, inf);    q.push(s), dis[s] = 0, inq[s] = 1;    pre[s] = inf, pre[gt] = 0, fl[s] = inf;    while (!q.empty()) &#123;        int f = q.front();        q.pop(), inq[f] = 0;        for (int i = h[f]; i; i = u[i].n) &#123;            if (u[i].c == 0)                continue;            int v = u[i].v, w = u[i].w;            if (dis[v] &gt; dis[f] + w) &#123;                pre[v] = i ^ 1;                dis[v] = dis[f] + w;                fl[v] = min(fl[f], u[i].c);                if (!inq[v])                    inq[v] = 1, q.push(v);            &#125;        &#125;    &#125;    return pre[gt];&#125;void SSP(int s, int n) &#123;    int p, mn, d;    while (SPFA(s, n)) &#123;        mn = fl[gt], d = 0;        for (p = gt; p != s; p = u[pre[p]].v) &#123;            u[pre[p]].c += mn;            u[pre[p] ^ 1].c -= mn;            d += u[pre[p] ^ 1].w;        &#125;        res += mn * d;    &#125;    return;&#125;void add(int x, int y, int c, int w) &#123;    u[++tot] = _(y, c, w, h[x]);    h[x] = tot;    return;&#125;void readx(int &amp;x) &#123;    char ch = nec();    while (ch != &#39;0&#39; &amp;&amp; ch != &#39;1&#39;)        ch = nec();    x = ch - &#39;0&#39;;    return;&#125;int main() &#123;    read(n), read(m), read(k);    gs = n + m + 1, gt = gs + 1;    for (int i = 1; i &lt;= m; ++i) &#123;        read(c[i]);        for (int j = 0; j &lt; n; ++j) &#123;            add(i + n, gt, 1,                    (2 * j + 1) * c[i]);            add(gt, i + n, 0,                    -(2 * j + 1) * c[i]);        &#125;    &#125;    for (int i = 1; i &lt;= m; ++i)        read(f[i]);    for (int i = 1; i &lt;= n; ++i) &#123;        add(gs, i, k, 0);        add(i, gs, 0, 0);        add(i, gt, k - 1, 0);        add(gt, i, 0, 0);        for (int j = 1; j &lt;= m; ++j) &#123;            readx(x);            if (x == 1) &#123;                add(i, j + n, 1, -f[j]); // 负代价                add(j + n, i, 0, f[j]);            &#125;        &#125;    &#125;    SSP(gs, gt);    print(res, &#39;\n&#39;);    return 0;&#125;&#125; // namespace XSC062#undef int</code></pre></details>]]></content>
      
      
      
        <tags>
            
            <tag> 网络流 </tag>
            
            <tag> 费用流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>中国剩余定理</title>
      <link href="/20230527/"/>
      <url>/20230527/</url>
      
        <content type="html"><![CDATA[<p>upd on 04/27/25：发现该文没写完 <img src="/em/qd.gif" /></p><span id="more"></span><hr /><h2 id="中国剩余定理">中国剩余定理</h2><p>给定下列关于 <span class="math inline">\(x\)</span> 的一元同余方程组：</p><p><span class="math display">\[\begin {cases}x \equiv a_1 \pmod {m_1}  \\x \equiv a_2 \pmod {m_2}  \\\quad \quad \vdots \\x \equiv a_k \pmod {m_k}\end {cases}\]</span> 其中对于 <span class="math inline">\(\forall \, 1\le i, j\le k\, (i\ne j)\)</span>，满足 <span class="math inline">\(m_i \, \bot\, m_j\)</span>。下面是求解该方程组的具体方法：</p><p>令 <span class="math inline">\(M = \prod \limits _{i = 1} ^ k m_i, \, M_i=\dfrac M {m_i}\)</span>，则 <span class="math inline">\(x = \sum \limits _{i = 1} ^k a_i\times M_i\times M_i ^{-1} \pmod M\)</span>。</p><p>其中，<span class="math inline">\(M_i^{-1}\)</span> 是 <span class="math inline">\(M_i\)</span> 在模 <span class="math inline">\(m_i\)</span> 意义下的逆元（所以 <span class="math inline">\(M_i\times M_i^{-1}\)</span> 的值并不是视觉上的 <span class="math inline">\(1\)</span>）。</p><p>正确性证明：对于 <span class="math inline">\(\forall \, i\in \{1, 2, \cdots, k\}\)</span>，有 <span class="math inline">\(M_i\mid M\)</span>；对于 <span class="math inline">\(\forall \, j\in \{1, 2, \cdots, k\}\)</span> 且 <span class="math inline">\(j\ne i\)</span>，有 <span class="math inline">\(m_i\mid \dfrac M{m_j}\)</span> 即 <span class="math inline">\(m_i\mid M_j\)</span>，即 <span class="math inline">\(M_j\equiv 0\pmod {m_i}\)</span>。</p><p>又 <span class="math inline">\(m_i\mid M\)</span> 那么就有 <span class="math inline">\(x\equiv a_i\cdot M_i\cdot {M_i}^{-1}\equiv a_i\pmod {n_i}\)</span>。</p><p>时间复杂度 <span class="math inline">\(\mathcal O(n\log n)\)</span>。注意求解逆元时要用到 exgcd。</p><details><pre class="cpp"><code>int CRT(int k, int *a, int *m) &#123;    int M = 1, x = 0;    static int M1[maxn], Mi[maxn];     for (int i = 1; i &lt;= k; ++i)        M *= m[i];    for (int i = 1; i &lt;= k; ++i) &#123;        M1[i] = M / m[i];        Mi[i] = getinv(M1[i], m[i]);        (x += a[i] * M1[i] * Mi[i]) %= M;    &#125;    return x;&#125;</code></pre></details><hr /><h2 id="扩展中国剩余定理">扩展中国剩余定理</h2><p>设有如下同余方程组：</p><p><span class="math display">\[\begin {cases}x \equiv a_1 \pmod {m_1} \\x \equiv a_2 \pmod {m_2}\end {cases}\]</span></p><p>不保证 <span class="math inline">\(m_1 \, \bot \, m_2\)</span>。</p><p>设 <span class="math inline">\(x = m_1 \times p_1 + a_1 = m_2 \times p_2 + a_2\)</span>，其中 <span class="math inline">\(p_i \in \mathbb Z\)</span>，则有 <span class="math inline">\(p_1 \times m_1 - p_2 \times m_2 = a_2 - a_1\)</span>。</p><p><span class="math inline">\(p_1\)</span> 的值可以用 exgcd 求解，则原方程的解满足 <span class="math inline">\(x \equiv m_1\times p_1 + a_1 \pmod {M}\)</span>，其中 <span class="math inline">\(M=\operatorname{lcm}(m_1, m_2)\)</span>。</p><p>这样我们就得到了一个新的同余方程。对于 <span class="math inline">\(k&gt;2\)</span> 的情况，我们不断合并两个同余方程即可得到最终同余方程。</p><p>此时根据题目要求（一般求最小值即 <span class="math inline">\(m_k\times p_k + a_k\)</span>）求解答案即可。</p><p>时间复杂度 <span class="math inline">\(\mathcal O(n\log n)\)</span>，其中 <span class="math inline">\(\log\)</span> 来自 exgcd。</p><details><pre class="cpp"><code>int calc(int m1, int a1, int m2, int a2) &#123;    int p1, p2;    if (a2 - a1 &lt; 0)        swap(a1, a2), swap(m1, m2);    int g = exgcd(m1, p1, m2, p2);    if ((a2 - a1) % g)        return -1;    p1 *= (a2 - a1) / g, m2 /= g;    p1 = (p1 % m2 + m2) % m2;    return p1 * m1 + a1;&#125;int exCRT(int k, int *a, int *m) &#123;    for (int i = 2; i &lt;= k; ++i) &#123;        a[i] = calc(m[i - 1],                a[i - 1], m[i], a[i]);        if (a[i] == -1)            return -1;        m[i] = lcm(m[i - 1], m[i]);    &#125;    return a[k] % m[k];&#125;</code></pre></details><hr /><h3 id="d.-strange-way-to-express-integers">D. Strange Way to Express Integers</h3><p><a href="http://222.180.160.110:1024/contest/3642/problem/4" class="uri">http://222.180.160.110:1024/contest/3642/problem/4</a></p><p>板。但是要开 <code>__int128</code>。不知道为什么智力只用开 <code>long long</code> 就能跑过，我和揭哥就不行。</p><details><pre class="cpp"><code>#define int __int128namespace XSC062 &#123;using namespace fastIO;const int maxn = 1e5 + 5;int n;int a[maxn], m[maxn];int gcd(int x, int y) &#123;    return y ? gcd(y, x % y) : x;&#125;inline int lcm(int x, int y) &#123;    return x / gcd(x, y) * y;&#125;inline void swap(int &amp;x, int &amp;y) &#123;    x ^= y ^= x ^= y;    return;&#125;int exgcd(int a, int &amp;x, int b, int &amp;y) &#123;    if (b == 0) &#123;        x = 1, y = 0;        return a;    &#125;    int u = exgcd(b, x, a % b, y);    int t = x;    x = y, y = t - (a / b) * y;    return u;&#125;inline int calc(int m1, int a1,                    int m2, int a2) &#123;    int p1, p2;    if (a2 - a1 &lt; 0)        swap(a1, a2), swap(m1, m2);    int g = exgcd(m1, p1, m2, p2);    if ((a2 - a1) % g)        return -1;    p1 *= (a2 - a1) / g, m2 /= g;    p1 = (p1 % m2 + m2) % m2;    return p1 * m1 + a1;&#125;inline int exCRT(int k, int *a, int *m) &#123;    for (int i = 2; i &lt;= k; ++i) &#123;        a[i] = calc(m[i - 1],                a[i - 1], m[i], a[i]);        if (a[i] == -1)            return -1;        m[i] = lcm(m[i - 1], m[i]);    &#125;    return a[k] % m[k];&#125;int main() &#123;    while (read(n)) &#123;        for (int i = 1; i &lt;= n; ++i)            read(m[i]), read(a[i]);        print(exCRT(n, a, m), &#39;\n&#39;);    &#125;    return 0;&#125;&#125; // namespace XSC062#undef int</code></pre></details>]]></content>
      
      
      
        <tags>
            
            <tag> CRT / exCRT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分图</title>
      <link href="/20230509/"/>
      <url>/20230509/</url>
      
        <content type="html"><![CDATA[<p>你说得对，所以我打网络流。</p><span id="more"></span><hr /><h2 id="二分图">二分图</h2><p><del>二分图总体概念不难</del>。主要是其应用广泛，需要注意什么样的题目可以联系到二分图上来。</p><h3 id="概念">概念</h3><p>若图 <span class="math inline">\(G\)</span> 可将点集 <span class="math inline">\(V\)</span> 分成两个互不相交的子集 <span class="math inline">\(X\)</span> 和 <span class="math inline">\(Y\)</span>，且每条边连接的两个点都满足一个在 <span class="math inline">\(X\)</span> 中，一个在 <span class="math inline">\(Y\)</span> 中，则称 <span class="math inline">\(G\)</span> 为二分图。</p><p>也就是说，如果一个图有任何一种分组方式满足：把图中的点分成两组，每一组的点两两之间没有连边，那么这个图就是二分图。</p><p>举个例子：</p><figure><img src="https://pic.imgdb.cn/item/62c8cd2cf54cd3f9371c4818.jpg" alt="每一组中的点两两之间没有连边，所以该图是二分图。" /><figcaption>每一组中的点两两之间没有连边，所以该图是二分图。</figcaption></figure><h3 id="性质">性质</h3><ul><li><p>二分图的每条边连接的点属于不同的集合。</p><p>显然。</p></li><li><p>二分图中可能存在环，且长度一定为偶数。</p><p>我们指定环中任意一个点，从该点出发，易得，经过奇数条边时到达另一个集合，反之回到该集合。因为路径是一个环，所以我们最后一定会回到起点所在集合，即经过偶数条边。</p></li></ul><h3 id="判定">判定</h3><p>通常，我们使用图的深度优先遍历每一个点 <span class="math inline">\(u\)</span>。</p><p>显然，若已知点 <span class="math inline">\(u\)</span> 在 <span class="math inline">\(X\)</span> 集，那么所有与 <span class="math inline">\(u\)</span> 有连边的点 <span class="math inline">\(v\)</span> 一定在 <span class="math inline">\(Y\)</span> 集（反之同理）。</p><p>当然，很多图是有环的，不免会产生 <span class="math inline">\(v\)</span> 已经被分组的情况。若此时 <span class="math inline">\(v\)</span> 恰好在 <span class="math inline">\(Y\)</span> 集，皆大欢喜；若 <span class="math inline">\(v\)</span> 也在 <span class="math inline">\(X\)</span> 集，那么该图一定不为二分图。</p><p>由于每个点最多搜索一次，时间复杂度 <span class="math inline">\(O(n)\)</span>。</p><pre class="cpp"><code>int col[maxn];bool DFS(int x, int c) &#123;    col[x] = c;    for (auto i : g[x]) &#123;        if (col[i]) &#123;            if (col[i] == c)                return 0;        &#125;        else if (!DFS(i, 3 - c))            return 0;    &#125;    return 1;&#125;int main() &#123; DFS(1, 1); &#125;</code></pre><p>厚颜无耻地推销一下 <a href="https://www.luogu.com.cn/problem/U283873">题目</a>（（（</p><h3 id="匹配">匹配</h3><p>定义：对于一个二分图中的若干条边，若这些边没有任何公共点，则称这些边组成的集合 <span class="math inline">\(M\)</span> 是数量为 <span class="math inline">\(|M|\)</span> 的 <strong>匹配</strong>。</p><figure><img src="https://pic.imgdb.cn/item/62c8cd75f54cd3f9371c866f.jpg" alt="图中红色边展示了一个数量为 4 的匹配" /><figcaption>图中红色边展示了一个数量为 4 的匹配</figcaption></figure><p>容易看出，对于点 <span class="math inline">\(u\)</span>，只会存在 「有一条 <span class="math inline">\(M\)</span> 集合内的边与 <span class="math inline">\(u\)</span> 相连接」 和 「<span class="math inline">\(u\)</span> 连接的边均不在 <span class="math inline">\(M\)</span> 集合内」 两种情况。也就是说，从 <span class="math inline">\(u\)</span> 出发的 <span class="math inline">\(M\)</span> 集合内的边，最多有 <span class="math inline">\(1\)</span> 条。</p><p>接下来，我们称 「有任何一条与之相连的边在匹配集合内」 的点为匹配点，「在匹配集合内的边」 为匹配边。</p><h3 id="完备匹配">完备匹配</h3><p>如果 <span class="math inline">\(|M|=\dfrac n2\)</span>，即 <span class="math inline">\(M\)</span> 恰好连接了 <span class="math inline">\(1\sim n\)</span> 所有点，我们就称匹配 <span class="math inline">\(M\)</span> 为 <strong>完备匹配</strong>。</p><figure><img src="https://pic.imgdb.cn/item/62c902d9f54cd3f93755faf9.jpg" alt="一个完备匹配的例子" /><figcaption>一个完备匹配的例子</figcaption></figure><p>比方说，现在我们知道一些男孩和女孩，他们之间有若干条互相喜欢的关系，我们把此关系抽象成一个二分图，如果每个人都能与自己喜欢的异性配对，那么我们认为这个关系网存在完备匹配。</p><p>显然，完备匹配存在，仅当两集合大小相等。</p><hr /><h2 id="匈牙利算法">匈牙利算法</h2><p>匈牙利算法一般用于求解 <span class="math inline">\(\max\{|M|\}\)</span>。</p><p>我们将图上满足下列条件的路径 <span class="math inline">\(P\)</span> 称为<strong>增广路</strong>：</p><ul><li><span class="math inline">\(P\)</span> 的起点和终点均是非匹配点</li><li><span class="math inline">\(P\)</span> 的起点和终点不在二分图的同一组内</li><li>路径 <span class="math inline">\(P\)</span> 经过的边按 <strong>非</strong> 匹配边，匹配边，<span class="math inline">\(\cdots\)</span>，<strong>非</strong> 匹配边的规律交替。</li></ul><p>最终，<span class="math inline">\(P\)</span> 会呈类 「<span class="math inline">\(\text Z\)</span>」 形（值得一提的是，增广路不能经过一整个环，否则其长度将会因为二分图中只存在偶环而变为无穷大）。</p><p>显然，非匹配边比匹配边的数量始终多 <span class="math inline">\(1\)</span>。</p><p>此时，我们对 <span class="math inline">\(P\)</span> 上匹配的状态取反。也就是说，原来的非匹配边变成匹配边，匹配边变成非匹配边。这样做相当于是在匹配边集仍然合法的情况下将匹配边集的大小扩大了 <span class="math inline">\(1\)</span>。</p><p>那么增广路经过的边按非匹配边，匹配边，<span class="math inline">\(\cdots\)</span>，非匹配边顺序交替的原因就很显而易见了。取反前，匹配边不可能连续出现；取反后，匹配边（即取反前的非匹配边）也不可能连续出现。</p><p>而匈牙利算法的主要思路，就是反复寻找增广路，直到无法找到为止。</p><p>这里就必须再提到一个性质：<span class="math inline">\(M\)</span> 为图 <span class="math inline">\(G\)</span> 的最大匹配，当且仅当无法在 <span class="math inline">\(M\)</span> 的基础上找到增广路。</p><p>证明如下：</p><ul><li><p>有引理：对于图 <span class="math inline">\(G\)</span> 的任意两个匹配 <span class="math inline">\(M\)</span> 和 <span class="math inline">\(M&#39;\)</span>，它们的 <a href="https://baike.baidu.com/item/%E5%AF%B9%E7%A7%B0%E5%B7%AE">对称差</a> <span class="math inline">\(M\Delta M&#39;\)</span> 中的每一个连通块都是一条链或一个包含边数为偶数的环。</p><p>证明：</p><p>根据对称差的定义，对于任意边 <span class="math inline">\(e\in M\Delta M&#39;\)</span>，<span class="math inline">\(e\)</span> 要么是 <span class="math inline">\(M\)</span> 中的一条匹配边，要么是 <span class="math inline">\(M&#39;\)</span> 中的一条匹配边，但不同时被 <span class="math inline">\(M\)</span> 和 <span class="math inline">\(M&#39;\)</span> 包含。</p><p>因为在同一个匹配中，任意两条匹配边不存在公共顶点，所以对于任意与 <span class="math inline">\(e\)</span> 有公共顶点的匹配边 <span class="math inline">\(e&#39;\)</span>，<span class="math inline">\(e\)</span> 和 <span class="math inline">\(e&#39;\)</span> 必然来自两个不同的匹配。</p><p>由此可得，对于任意匹配点 <span class="math inline">\(u\)</span>，<span class="math inline">\(u\)</span> 的度数为 <span class="math inline">\(1\)</span> 或 <span class="math inline">\(2\)</span>。</p><p>所以，对称差中的每一个连通块都是链或环。</p><p>对于其中的环，所有相邻的边必定来自不同的匹配，所以环包含的边数为偶数。</p></li><li><p>必要性：当 <span class="math inline">\(M\)</span> 为最大匹配时，无法找到 <span class="math inline">\(M\)</span> 的增广路。</p><p>我们已经知道了，找到某匹配的增广路 <span class="math inline">\(P\)</span> 并将其匹配状态取反，可以使匹配大小加一。</p><p>如果 <span class="math inline">\(M\)</span> 存在增广路，则我们可以将其取反，得到一个比 <span class="math inline">\(M\)</span> 大小更大的匹配。与 <span class="math inline">\(M\)</span> 是最大匹配矛盾。</p><p>所以一定不存在 <span class="math inline">\(M\)</span> 的增广路。</p></li><li><p>充分性：如果不存在 <span class="math inline">\(M\)</span> 的增广路，<span class="math inline">\(M\)</span> 为 <span class="math inline">\(G\)</span> 的最大匹配。</p><p>设 <span class="math inline">\(M&#39;\)</span> 是一个比 <span class="math inline">\(M\)</span> 更大的匹配。</p><p>由引理得：</p><p>在它们的对称差 <span class="math inline">\(M\Delta M&#39;\)</span> 中，连通块为链或环。</p><p>其中，环包含边的数量为偶数，所以必然有同样多的边来自 <span class="math inline">\(M\)</span> 和 <span class="math inline">\(M&#39;\)</span>。所以我们可以忽视这些环。</p><p>由于 <span class="math inline">\(|M|&lt;|M&#39;|\)</span>，存在至少一条链 <span class="math inline">\(L\)</span>，且 <span class="math inline">\(|L|=k-1\)</span>，包含 <span class="math inline">\(k\)</span> 条 <span class="math inline">\(M\)</span> 中的边，<span class="math inline">\(k+1\)</span> 条来自于 <span class="math inline">\(M&#39;\)</span> 的边。</p><p>显然，<span class="math inline">\(L\)</span> 就是一条 <span class="math inline">\(M\)</span> 的增广路，所以我们必然可以找到一条 <span class="math inline">\(M\)</span> 的增广路，命题成立。</p></li></ul><p>对于 「寻找增广路」 这个过程，我们使用 DFS 算法实现。</p><p>对于点 <span class="math inline">\(x\)</span>，若与 <span class="math inline">\(x\)</span> 有连边的点 <span class="math inline">\(y\)</span> 可匹配上 <span class="math inline">\(x\)</span>，需要满足下列两个条件之一：</p><ul><li><span class="math inline">\(y\)</span> 是非匹配点，此时 <span class="math inline">\(x\to y\)</span> 构成一条增广路，非匹配边的数量已经比匹配边数量多 <span class="math inline">\(1\)</span>。</li><li><span class="math inline">\((u,y)\)</span> 是已匹配边，且 <span class="math inline">\((u,v)\)</span> 是未匹配但合法的边，此时 <span class="math inline">\(x\to y\to u\to v\)</span> 构成一条增广路。</li></ul><p>在实现中，我们依次令 <span class="math inline">\(1\sim n\)</span> 内 <strong>所有的非匹配点</strong> 作为起始点 <span class="math inline">\(x\)</span> 尝试找到任何一条增广路。当碰到任意非匹配点时结束（增广路判定：起点与终点均为非匹配点），否则向 <strong>该匹配点匹配的点</strong> 继续搜索。</p><p>也就是说，一层 DFS 会寻找一条非匹配边并作为起点，产生以下两种行为：</p><ol type="1"><li>该非匹配边终点为非匹配点，以该匹配边结束增广路。</li><li>经过该非匹配边后还能再找到一条匹配边（若情况 1 不满足，显然一定能找到这样一条边），则在终点进行下一层 DFS，寻找下一条非匹配边。</li></ol><p>时间复杂度为 <span class="math inline">\(O(n^2+nm)\)</span>，但一般二分图题目的 <span class="math inline">\(X\)</span> 与 <span class="math inline">\(Y\)</span> 部间的连边偏稠密，所以简化为 <span class="math inline">\(O(nm)\)</span>。</p><pre class="cpp"><code>bool Find(int x) &#123;    vis[x] = now; // 时间戳标记    for (auto i : g[x]) &#123;        if (vis[i] == now) // 不经过访问过的 i            continue;        if (!mat[i] /* 非匹配点，即终点 */ ||            (vis[mat[i]] != now /* mat[i] 未访问过，可以经过 */            &amp;&amp; Find(mat[i]) /* 可找到增广路 */)) &#123;            mat[i] = x; // 匹配            return 1;        &#125;    &#125;    return 0;&#125;int Hungary(int n) &#123;    int res = 0;    for (int i = 1; i &lt;= n; ++i) &#123;        ++now;        res += Find(i);    &#125;    return res;&#125;</code></pre><p>一般来说，二分图题目对点、边、分组方法和匹配范围的识别较为模糊。但一般的二分图题目都会有一些特点：</p><ul><li>结点能分为两组，且各组内结点间没有连边</li><li>每个结点只能与一条边匹配</li></ul><p>有时候，题目要求判定是否存在 「完备匹配」，也就是说，<span class="math inline">\(ans=n\)</span>。即任意一次 <code>find(i)</code> 返回 <code>false</code> 时，完备匹配不存在。</p><p>最后给出与匈牙利算法有关的两个问题：</p><ol type="1"><li><p>最小点覆盖：给定一个二分图，求出一个最小的点集，使得这个点集发出的所有边可以覆盖整个二分图。</p><p>定理：该点集的大小是二分图的最大匹配包含的边数。</p></li><li><p>最大独立集：给定一个无向图，求出一个最大的点集，使得该点集中的所有点两两之间没有边相连。</p><p>定理：当该无向图是二分图时，最大独立集的大小等于 <span class="math inline">\(n\)</span> 减去最大匹配数。</p><p>证明：由于最小点覆盖可以覆盖所有边，故不存在两个点，使得它们不属于最小点覆盖且有连边。</p><p>所以，当去掉最小点覆盖后，剩余点两两之间没有连边。因为最小点覆盖大小就是最大匹配大小，故原命题成立。</p></li></ol><hr /><p>注意二分图的点和边是可以互相转化的，即，若发现信息集中在点上，也可以用二分图解决。匹配边的数量即最终参与匹配的点数较多的一方的匹配点数量。</p><p>对于二分图建图的一个判断方式是，找冲突。找到彼此之间有冲突的两方，连边。这样就能建出二分图。当然要保证两方之间没有交集。</p><p>所谓冲突，就是我们通常理解中的选了一个就不能选另一个。因此也可以通过冲突存在的形式思考建图方式。</p><hr /><h3 id="a.-棋盘上的骑士">A. 棋盘上的骑士</h3><p><a href="http://222.180.160.110:61235/contest/3699/problem/1" class="uri">http://222.180.160.110:61235/contest/3699/problem/1</a></p><p>这道题就是我们提到的边转化为点的情况。</p><p>为棋盘上的每个格子编号。骑士走的是日字，所以我们要把周围每个格子日字方向八个格子都连上边。</p><p>那要怎么将所有 <span class="math inline">\(n\times n\)</span> 个格子分为有冲突的两方呢？注意到日字连接的两个格子一定奇偶性相异，故我们以奇偶性分类。</p><p>被挖掉的格子无视即可，不能连任何边，否则该边都有可能被选。然后跑一个最大匹配就行。</p><details><pre class="cpp"><code>namespace XSC062 &#123;using namespace fastIO;const int maxn = 205;const int maxm = 1e5 + 5;const int fx[] = &#123; 1, 1, -1, -1, 2, 2, -2, -2 &#125;;const int fy[] = &#123; 2, -2, 2, -2, 1, -1, 1, -1 &#125;;int a[maxn][maxn];int mat[maxm], vis[maxm];std::vector&lt;int&gt; g[maxm];int n, m, x, y, now, cnt, tot;bool Find(int x) &#123;    vis[x] = now;    for (auto i : g[x]) &#123;        if (vis[i] == now)            continue;        if (!mat[i] || (vis[mat[i]] != now                            &amp;&amp; Find(mat[i]))) &#123;            mat[i] = x;            return 1;        &#125;    &#125;    return 0;&#125;int Hungary(int n) &#123;    int res = 0;    for (int i = 1; i &lt;= n; ++i)        ++now, res += Find(i);    return res;&#125;void add(int x, int y) &#123;    g[x].push_back(y);    return;&#125;int main() &#123;    read(n), read(m);    while (m--) &#123;        read(x), read(y);        a[x][y] = -1;    &#125;    for (int i = 1; i &lt;= n; ++i) &#123;        for (int j = 1; j &lt;= n; ++j) &#123;            if (a[i][j] != -1 &amp;&amp; !((i + j) &amp; 1))                a[i][j] = ++cnt;        &#125;    &#125;    for (int i = 1; i &lt;= n; ++i) &#123;        for (int j = 1; j &lt;= n; ++j) &#123;            if (a[i][j] == -1 || !((i + j) &amp; 1))                continue;            a[i][j] = ++tot;            for (int k = 0; k &lt; 8; ++k) &#123;                int nx = i + fx[k];                int ny = j + fy[k];                if (nx &lt; 1 || ny &lt; 1 || nx &gt; n ||                    ny &gt; n || a[nx][ny] == -1)                    continue;                add(a[i][j], a[nx][ny] + n * n);            &#125;        &#125;    &#125;    print(cnt + tot - Hungary(tot), &#39;\n&#39;);    return 0;&#125;&#125; // namespace XSC062</code></pre></details><hr /><h3 id="b.-火力网">B. 火力网</h3><p><a href="http://222.180.160.110:61235/contest/3699/problem/2" class="uri">http://222.180.160.110:61235/contest/3699/problem/2</a></p><p>这里用到了二分图在地图上一个较为常用的分组方法。</p><p>找到每行每列的「连通块」，满足在行上的连通块任意放一个炮台，炮台覆盖连通块内所有点，所有点均被连通块覆盖，列范围内同理。为连通块分别编号，则样例的情况可转化如下：</p><pre class="plain"><code>/* 对于行 */        /* 对于列 */  1 - 2 2            1 - 5 6  3 3 3 3            1 3 5 6  - - 4 4            - - 5 6  5 5 5 5            2 4 5 6</code></pre><p>若一个格子为空地，则将其在行 / 列范围内所属的连通块连边。这样，我们在选取该格后，就相当于选取了这条边，由于匹配边不共点，所以合法。</p><details><pre class="cpp"><code>namespace XSC062 &#123;using namespace fastIO;const int maxn = 25;const int maxm = 1e5 + 5;char a[maxn][maxn];int mat[maxm], vis[maxm];std::vector&lt;int&gt; g[maxm];int n, x, y, now, cnt1, cnt2;int t[maxn][maxn], p[maxn][maxn];bool Find(int x) &#123;    vis[x] = now;    for (auto i : g[x]) &#123;        if (vis[i] == now)            continue;        if (!mat[i] || (vis[mat[i]] != now                            &amp;&amp; Find(mat[i]))) &#123;            mat[i] = x;            return 1;        &#125;    &#125;    return 0;&#125;int Hungary(int n) &#123;    int res = 0;    for (int i = 1; i &lt;= n; ++i)        ++now, res += Find(i);    return res;&#125;void add(int x, int y) &#123;    g[x].push_back(y);    return;&#125;int main() &#123;    scanf(&quot;%d&quot;, &amp;n);    for (int i = 1; i &lt;= n; ++i)        scanf(&quot;%s&quot;, a[i] + 1);    for (int i = 1; i &lt;= n; ++i) &#123;        for (int j = 1; j &lt;= n; ++j) &#123;            if (a[i][j] == &#39;X&#39;)                continue;            if (a[i][j - 1] != &#39;.&#39;)                t[i][j] = ++cnt1;            else t[i][j] = t[i][j - 1];        &#125;    &#125;    for (int j = 1; j &lt;= n; ++j) &#123;        for (int i = 1; i &lt;= n; ++i) &#123;            if (a[i][j] == &#39;X&#39;)                continue;            if (a[i - 1][j] != &#39;.&#39;)                p[i][j] = ++cnt2;            else p[i][j] = p[i - 1][j];        &#125;    &#125;    for (int i = 1; i &lt;= n; ++i) &#123;        for (int j = 1; j &lt;= n; ++j) &#123;            if (a[i][j] == &#39;.&#39;)                add(t[i][j], p[i][j] + cnt1);        &#125;    &#125;    print(Hungary(cnt1), &#39;\n&#39;);    return 0;&#125;&#125; // namespace XSC062</code></pre></details><hr /><h3 id="c.-超级英雄-hero">C. 超级英雄 Hero</h3><p><a href="http://222.180.160.110:61235/contest/3699/problem/3" class="uri">http://222.180.160.110:61235/contest/3699/problem/3</a></p><p>分析冲突。每个锦囊只能被一道题使用，一道题只能使用一个锦囊，故考虑将锦囊和题连边。题目要求连续解题最多，故以题目进行匈牙利。</p><p>最后输出匹配数组即可。</p><details><pre class="cpp"><code>namespace XSC062 &#123;using namespace fastIO;const int maxn = 2e4 + 5;int n, m, x, y, now, t;int mat[maxn], vis[maxn];std::vector&lt;int&gt; g[maxn];bool Find(int x) &#123;    vis[x] = now;    for (auto i : g[x]) &#123;        if (vis[i] == now)            continue;        if (!mat[i] || (vis[mat[i]] != now                            &amp;&amp; Find(mat[i]))) &#123;            mat[i] = x, mat[x] = i;            return 1;        &#125;    &#125;    return 0;&#125;int Hungary(int n) &#123;    int res = 0;    for (int i = 1; i &lt;= n; ++i) &#123;        ++now;        if (Find(i))            ++res;        else break;    &#125;    return res;&#125;void add(int x, int y) &#123;    g[x].push_back(y);    return;&#125;int main() &#123;    read(n), read(m);    for (int i = 1; i &lt;= m; ++i) &#123;        read(x), read(y);        add(i, x + m + 1);        add(i, y + m + 1);    &#125;    print(t = Hungary(m), &#39;\n&#39;);    for (int i = 1; i &lt;= t; ++i)        print(mat[i] - m - 1, &#39;\n&#39;);    return 0;&#125;&#125; // namespace XSC062</code></pre></details><hr /><h2 id="km-算法">KM 算法</h2><p>还没写…… 咕咕咕</p><hr /><h3 id="a.-ants">A. Ants</h3><p><a href="https://vjudge.net/contest/554888#problem/A" class="uri">https://vjudge.net/contest/554888#problem/A</a></p><p>板板题。把黑蚂蚁和白蚂蚁按欧几里得距离连边后 KM 即可。</p><details><pre class="cpp"><code>namespace XSC062 &#123;using namespace fastIO;typedef double db;const db inf = 1e18;const db eps = 1e-5;const int maxn = 205;int n, now;db g[maxn][maxn];db u[maxn], up[maxn];int vis[maxn], mat[maxn];int a[maxn][2], b[maxn][2];db max(db x, db y) &#123;    return x &gt; y ? x : y;&#125;db min(db x, db y) &#123;    return x &lt; y ? x : y;&#125;bool eq(db x, db y) &#123;    return fabs(x - y) &lt;= eps;&#125;bool Find(int x) &#123;    vis[x] = now;    for (int i = n + 1; i &lt;= 2 * n; ++i) &#123;        if (vis[i] == now)            continue;        if (eq(u[x] + u[i], g[x][i])) &#123;            vis[i] = now;            if (!mat[i] || (vis[mat[i]] != now                            &amp;&amp; Find(mat[i]))) &#123;                mat[i] = x;                return 1;            &#125;        &#125;        else &#123;            up[i] = min(up[i],                u[x] + u[i] - g[x][i]);        &#125;    &#125;    return 0;&#125;void Solve(void) &#123;    for (int i = 1; i &lt;= n; ++i) &#123;        u[i] = -inf;        for (int j = n + 1; j &lt;= 2 * n; ++j)            u[i] = max(u[i], g[i][j]);    &#125;    for (int i = 1; i &lt;= n; ++i) &#123;        for (;;) &#123;            ++now;            for (int j = n + 1; j &lt;= 2 * n; ++j)                up[j] = inf;            if (Find(i))                break;            db Delta = inf;            for (int j = n + 1;                            j &lt;= 2 * n; ++j) &#123;                if (vis[j] != now)                    Delta = min(Delta, up[j]);            &#125;            for (int j = 1; j &lt;= n; ++j) &#123;                if (vis[j] == now)                    u[j] -= Delta;            &#125;            for (int j = n + 1;                            j &lt;= 2 * n; ++j) &#123;                if (vis[j] == now)                    u[j] += Delta;            &#125;        &#125;    &#125;    return;&#125;db dist(int x1, int y1, int x2, int y2) &#123;    return sqrt((db)(x1 - x2) * (x1 - x2) +                    (y1 - y2) * (y1 - y2));&#125;int main() &#123;    read(n);    for (int i = 1; i &lt;= n; ++i)        read(a[i][0]), read(a[i][1]);    for (int i = 1; i &lt;= n; ++i)        read(b[i][0]), read(b[i][1]);    for (int i = 1; i &lt;= n; ++i) &#123;        for (int j = 1; j &lt;= n; ++j) &#123;            g[j][i + n] = -dist(a[i][0], a[i][1],                            b[j][0], b[j][1]);        &#125;    &#125;    Solve();    for (int i = n + 1; i &lt;= 2 * n; ++i)        print(mat[i], &#39;\n&#39;);    return 0;&#125;&#125; // namespace XSC062</code></pre></details><h3 id="b.-奔小康赚大钱">B. 奔小康赚大钱</h3><p><a href="https://vjudge.net/contest/554888#problem/B" class="uri">https://vjudge.net/contest/554888#problem/B</a></p><p>板板题。把居民和房子连边即可。</p><details><pre class="cpp"><code>namespace XSC062 &#123;using namespace fastIO;const int maxn = 605;const int inf = 0x3f3f3f3f;int n, now, res;int g[maxn][maxn];int u[maxn], up[maxn];int vis[maxn], mat[maxn];int max(int x, int y) &#123;    return x &gt; y ? x : y;&#125;int min(int x, int y) &#123;    return x &lt; y ? x : y;&#125;bool Find(int x) &#123;    vis[x] = now;    for (int i = n + 1; i &lt;= 2 * n; ++i) &#123;        if (vis[i] == now)            continue;        if (u[x] + u[i] == g[x][i]) &#123;            vis[i] = now;            if (!mat[i] || (vis[mat[i]] != now                            &amp;&amp; Find(mat[i]))) &#123;                mat[i] = x;                return 1;            &#125;        &#125;        else &#123;            up[i] = min(up[i],                u[x] + u[i] - g[x][i]);        &#125;    &#125;    return 0;&#125;void Solve(void) &#123;    for (int i = 1; i &lt;= 2 * n; ++i)        mat[i] = u[i] = 0;    for (int i = 1; i &lt;= n; ++i) &#123;        u[i] = -inf;        for (int j = n + 1; j &lt;= 2 * n; ++j)            u[i] = max(u[i], g[i][j]);    &#125;    for (int i = 1; i &lt;= n; ++i) &#123;        for (;;) &#123;            ++now;            for (int j = n + 1; j &lt;= 2 * n; ++j)                up[j] = inf;            if (Find(i))                break;            int Delta = inf;            for (int j = n + 1;                            j &lt;= 2 * n; ++j) &#123;                if (vis[j] != now)                    Delta = min(Delta, up[j]);            &#125;            for (int j = 1; j &lt;= n; ++j) &#123;                if (vis[j] == now)                    u[j] -= Delta;            &#125;            for (int j = n + 1;                            j &lt;= 2 * n; ++j) &#123;                if (vis[j] == now)                    u[j] += Delta;            &#125;        &#125;    &#125;    return;&#125;int main() &#123;    while(read(n)) &#123;        res = 0;        for (int i = 1; i &lt;= n; ++i) &#123;            for (int j = 1; j &lt;= n; ++j)                read(g[i][j + n]);        &#125;        Solve();        for (int i = n + 1; i &lt;= 2 * n; ++i)            res += g[mat[i]][i];        print(res, &#39;\n&#39;);    &#125;    return 0;&#125;&#125; // namespace XSC062</code></pre></details><hr /><h3 id="c.-going-home">C. Going Home</h3><p><a href="https://vjudge.net/contest/554888#problem/C" class="uri">https://vjudge.net/contest/554888#problem/C</a></p><p>板板题。把人和房子按曼哈顿距离连边即可。</p><details><pre class="cpp"><code>namespace XSC062 &#123;using namespace fastIO;const int maxn = 205;const int inf = 0x3f3f3f3f;int g[maxn][maxn];char s[maxn][maxn];int u[maxn], up[maxn];int h, w, n, m, now, res;int vis[maxn], mat[maxn];int a[maxn][2], b[maxn][2];int max(int x, int y) &#123;    return x &gt; y ? x : y;&#125;int min(int x, int y) &#123;    return x &lt; y ? x : y;&#125;bool Find(int x) &#123;    vis[x] = now;    for (int i = n + 1; i &lt;= 2 * n; ++i) &#123;        if (vis[i] == now)            continue;        if (u[x] + u[i] == g[x][i]) &#123;            vis[i] = now;            if (!mat[i] || (vis[mat[i]] != now                            &amp;&amp; Find(mat[i]))) &#123;                mat[i] = x;                return 1;            &#125;        &#125;        else &#123;            up[i] = min(up[i],                u[x] + u[i] - g[x][i]);        &#125;    &#125;    return 0;&#125;void Solve(void) &#123;    for (int i = 1; i &lt;= 2 * n; ++i)        mat[i] = u[i] = 0;    for (int i = 1; i &lt;= n; ++i) &#123;        u[i] = -inf;        for (int j = n + 1; j &lt;= 2 * n; ++j)            u[i] = max(u[i], g[i][j]);    &#125;    for (int i = 1; i &lt;= n; ++i) &#123;        for (;;) &#123;            ++now;            for (int j = n + 1; j &lt;= 2 * n; ++j)                up[j] = inf;            if (Find(i))                break;            int Delta = inf;            for (int j = n + 1;                            j &lt;= 2 * n; ++j) &#123;                if (vis[j] != now)                    Delta = min(Delta, up[j]);            &#125;            for (int j = 1; j &lt;= n; ++j) &#123;                if (vis[j] == now)                    u[j] -= Delta;            &#125;            for (int j = n + 1;                            j &lt;= 2 * n; ++j) &#123;                if (vis[j] == now)                    u[j] += Delta;            &#125;        &#125;    &#125;    return;&#125;int abs(int x) &#123;    return x &gt;= 0 ? x : -x;&#125;int dist(int x1, int y1, int x2, int y2) &#123;    return abs(x1 - x2) + abs(y1- y2);&#125;void Init(void) &#123;    res = n = m = 0;    memset(g, 0, sizeof (g));    return;&#125;int main() &#123;    scanf(&quot;%d %d&quot;, &amp;h, &amp;w);    while (h || w) &#123;        Init();        for (int i = 1; i &lt;= h; ++i) &#123;            scanf(&quot;%s&quot;, s[i] + 1);            for (int j = 1; j &lt;= w; ++j) &#123;                if (s[i][j] == &#39;H&#39;)                    a[++n][0] = i, a[n][1] = j;                else if (s[i][j] == &#39;m&#39;)                    b[++m][0] = i, b[m][1] = j;            &#125;        &#125;        for (int i = 1; i &lt;= n; ++i) &#123;            for (int j = 1; j &lt;= n; ++j) &#123;                g[i][j + n] = -dist(a[i][0],                    a[i][1], b[j][0], b[j][1]);            &#125;        &#125;        Solve();        for (int i = n + 1; i &lt;= 2 * n; ++i)            res += g[mat[i]][i];        print(-res, &#39;\n&#39;);        scanf(&quot;%d %d&quot;, &amp;h, &amp;w);    &#125;    return 0;&#125;&#125; // namespace XSC062</code></pre></details><hr /><h3 id="d.-cyclic-tour">D. Cyclic Tour</h3><p><a href="https://vjudge.net/contest/554888#problem/D" class="uri">https://vjudge.net/contest/554888#problem/D</a></p><p>题意在讲什么啊，看了半天看不懂。</p><p>给定一个有向图，找到若干个互不相交的环覆盖整个图，使得所有环上边权和最小，若找不到方案输出 -1。</p><p>我们知道与这道题相类似的最小路径覆盖问题可以用二分图 + 拆点来解决。那么这里我们也可以小小地拆一拆点。把一个点拆成两个，一个作为起点，一个作为终点，两个点之间连双向边，这样该图就和原图等价。</p><p>拆出来起点之间没有边，拆出来的终点之间也没有边，所以原图是二分图。</p><p>不难发现，假设原图中的环上共有 <span class="math inline">\(x\)</span> 个点、<span class="math inline">\(x\)</span> 条边，那么拆点后就会有 <span class="math inline">\(2\times x\)</span> 个点和 <span class="math inline">\(2\times x\)</span> 条边，其中 <span class="math inline">\(x\)</span> 条边是点 <span class="math inline">\(i\)</span> 连向点 <span class="math inline">\(i&#39;\)</span>（或反之）的边。</p><p>需要匹配到剩余的实边（而非自己连向自己的虚边）共有 <span class="math inline">\(x\)</span> 条，左右部节点都有 <span class="math inline">\(x\)</span> 个，考虑设虚边边权为正无穷，进行最小权完美匹配（点和自己连边的操作保证了一定能找到解，不会进入死循环）。</p><p>那么什么时候无解呢？当算法不得不选中虚边时，就说明找不到环了。所以我们判一下匹配有没有包含正无穷边即可。</p><p>记得判重边！</p><details><pre class="cpp"><code>namespace XSC062 &#123;using namespace fastIO;const int maxn = 205;const int inf = 0x3f3f3f3f;int g[maxn][maxn];int u[maxn], up[maxn];int vis[maxn], mat[maxn];int n, m, x, y, now, res, w;int max(int x, int y) &#123;    return x &gt; y ? x : y;&#125;int min(int x, int y) &#123;    return x &lt; y ? x : y;&#125;bool Find(int x) &#123;    vis[x] = now;    for (int i = n + 1; i &lt;= 2 * n; ++i) &#123;        if (vis[i] == now)            continue;        if (u[x] + u[i] == g[x][i]) &#123;            vis[i] = now;            if (!mat[i] || (vis[mat[i]] != now                            &amp;&amp; Find(mat[i]))) &#123;                mat[i] = x;                return 1;            &#125;        &#125;        else &#123;            up[i] = min(up[i],                u[x] + u[i] - g[x][i]);        &#125;    &#125;    return 0;&#125;void Solve(void) &#123;    for (int i = 1; i &lt;= 2 * n; ++i)        mat[i] = u[i] = 0;    for (int i = 1; i &lt;= n; ++i) &#123;        u[i] = -inf;        for (int j = n + 1; j &lt;= 2 * n; ++j)            u[i] = max(u[i], g[i][j]);    &#125;    for (int i = 1; i &lt;= n; ++i) &#123;        for (;;) &#123;            ++now;            for (int j = n + 1; j &lt;= 2 * n; ++j)                up[j] = inf;            if (Find(i))                break;            int Delta = inf;            for (int j = n + 1;                            j &lt;= 2 * n; ++j) &#123;                if (vis[j] != now)                    Delta = min(Delta, up[j]);            &#125;            for (int j = 1; j &lt;= n; ++j) &#123;                if (vis[j] == now)                    u[j] -= Delta;            &#125;            for (int j = n + 1;                            j &lt;= 2 * n; ++j) &#123;                if (vis[j] == now)                    u[j] += Delta;            &#125;        &#125;    &#125;    return;&#125;int main() &#123;    while (read(n)) &#123;        read(m);        res = 0;        for (int i = 1; i &lt;= 2 * n; ++i) &#123;            for (int j = 1; j &lt;= 2 * n; ++j)                 g[i][j] = -inf;        &#125;        while (m--) &#123;            read(x), read(y), read(w);            g[x][y + n] = max(g[x][y + n], -w);        &#125;        Solve();        for (int i = n + 1; i &lt;= 2 * n; ++i) &#123;            if (g[mat[i]][i] &lt;= -inf) &#123;                puts(&quot;-1&quot;);                goto NoSol;            &#125;            res += -g[mat[i]][i];        &#125;        print(res, &#39;\n&#39;);        NoSol: ;    &#125;    return 0;&#125;&#125; // namespace XSC062</code></pre></details><hr /><h3 id="e.-tour">E. Tour</h3><p><a href="https://vjudge.net/contest/554888#problem/E" class="uri">https://vjudge.net/contest/554888#problem/E</a></p><p>把上一题输入方式和数据范围改一改就好了。</p><details><pre class="cpp"><code>namespace XSC062 &#123;using namespace fastIO;const int maxn = 405;const int inf = 0x3f3f3f3f;int g[maxn][maxn];int u[maxn], up[maxn];int vis[maxn], mat[maxn];int T, n, m, x, y, now, res, w;int max(int x, int y) &#123;    return x &gt; y ? x : y;&#125;int min(int x, int y) &#123;    return x &lt; y ? x : y;&#125;bool Find(int x) &#123;    vis[x] = now;    for (int i = n + 1; i &lt;= 2 * n; ++i) &#123;        if (vis[i] == now)            continue;        if (u[x] + u[i] == g[x][i]) &#123;            vis[i] = now;            if (!mat[i] || (vis[mat[i]] != now                            &amp;&amp; Find(mat[i]))) &#123;                mat[i] = x;                return 1;            &#125;        &#125;        else &#123;            up[i] = min(up[i],                u[x] + u[i] - g[x][i]);        &#125;    &#125;    return 0;&#125;void Solve(void) &#123;    for (int i = 1; i &lt;= 2 * n; ++i)        mat[i] = u[i] = 0;    for (int i = 1; i &lt;= n; ++i) &#123;        u[i] = -inf;        for (int j = n + 1; j &lt;= 2 * n; ++j)            u[i] = max(u[i], g[i][j]);    &#125;    for (int i = 1; i &lt;= n; ++i) &#123;        for (;;) &#123;            ++now;            for (int j = n + 1; j &lt;= 2 * n; ++j)                up[j] = inf;            if (Find(i))                break;            int Delta = inf;            for (int j = n + 1;                            j &lt;= 2 * n; ++j) &#123;                if (vis[j] != now)                    Delta = min(Delta, up[j]);            &#125;            for (int j = 1; j &lt;= n; ++j) &#123;                if (vis[j] == now)                    u[j] -= Delta;            &#125;            for (int j = n + 1;                            j &lt;= 2 * n; ++j) &#123;                if (vis[j] == now)                    u[j] += Delta;            &#125;        &#125;    &#125;    return;&#125;int main() &#123;    read(T);    while(T--) &#123;        read(n), read(m);        res = 0;        for (int i = 1; i &lt;= 2 * n; ++i) &#123;            for (int j = 1; j &lt;= 2 * n; ++j)                 g[i][j] = -inf;        &#125;        while (m--) &#123;            read(x), read(y), read(w);            g[x][y + n] = max(g[x][y + n], -w);        &#125;        Solve();        for (int i = n + 1; i &lt;= 2 * n; ++i) &#123;            if (g[mat[i]][i] &lt;= -inf) &#123;                puts(&quot;-1&quot;);                goto NoSol;            &#125;            res += -g[mat[i]][i];        &#125;        print(res, &#39;\n&#39;);        NoSol: ;    &#125;    return 0;&#125;&#125; // namespace XSC062</code></pre></details><hr /><h3 id="d.-导弹防御塔">D. 导弹防御塔</h3><p><a href="http://222.180.160.110:61235/contest/3699/problem/4" class="uri">http://222.180.160.110:61235/contest/3699/problem/4</a></p><p>GM 说的好哇（指 <em>毛病多，一会儿分钟一会儿秒</em>）。</p><p>寻找冲突。一个敌人只能被一炮打死，故考虑</p><p>但一个塔可以打很多炮，考虑拆点。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 二分图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分治</title>
      <link href="/20230314/"/>
      <url>/20230314/</url>
      
        <content type="html"><![CDATA[<p>听说是 <a href="http://222.180.160.110:61235/contest/3416">分治场</a>，想起了自己根本没学过分治（甚至从来不知道归并排序的原理 orz）就去听 CDQ 然后一头雾水的惨痛经历，不禁 PTSD 了。</p><span id="more"></span><hr /><h3 id="a.-老板的又一道题">A. 老板的又一道题</h3><p><a href="http://222.180.160.110:61235/contest/3416/problem/1" class="uri">http://222.180.160.110:61235/contest/3416/problem/1</a></p><p>这是什么，有序表的最小和，切一下（所以和分治有什么关系啊）。</p><p>首先对数组进行排序（我忘了 orz），然后在优先队列中填入 <span class="math inline">\(A_{1\sim n} + B_1\)</span>。假设当前最小值为 <span class="math inline">\(A_i + B_j\)</span>，则输出，弹出并填入 <span class="math inline">\(A_i + B_{j + 1}\)</span>。因为 <span class="math inline">\(B\)</span> 是单调的，所以我们填入的数（起码在输出时）是单调的。</p><details><pre class="cpp"><code>namespace XSC062 &#123;using namespace fastIO;const int maxn = 1e5 + 5;struct _ &#123;    int u, i;    _() &#123;&#125;    _(int u1, int i1) &#123;        u = u1, i = i1;    &#125;    bool operator&lt; (const _ q) const &#123;        return u &gt; q.u;    &#125;&#125;;int n, cnt;int a[maxn], b[maxn];std::priority_queue&lt;_&gt; q;int main() &#123;    read(n);    for (int i = 1; i &lt;= n; ++i)        read(a[i]);    for (int i = 1; i &lt;= n; ++i)        read(b[i]);    std::sort(a + 1, a + n + 1);    std::sort(b + 1, b + n + 1);    for (int i = 1; i &lt;= n; ++i)        q.push(_(a[i] + b[1], 1));    while (!q.empty()) &#123;        _ f = q.top();        q.pop();        print(f.u, &#39; &#39;);        if (++cnt == n)            break;        _ t = f;        t.u -= b[f.i];        t.u += b[++t.i];        q.push(t);    &#125;    return 0;&#125;&#125; // namespace XSC062</code></pre></details><hr /><h3 id="b.-魔法石的诱惑">B. 魔法石的诱惑</h3><p><a href="http://222.180.160.110:61235/contest/3416/problem/2" class="uri">http://222.180.160.110:61235/contest/3416/problem/2</a></p><p>这，这不是二分答案？到底和分治有什么关系啊。</p><p>嘶，<span class="math inline">\(Q\)</span> 是 <span class="math inline">\(10^8\)</span>，算一算 <span class="math inline">\(n\)</span> 的范围。不难发现 <span class="math inline">\(Q=\sum\limits_{i&gt;1} \lfloor \dfrac n{5^i} \rfloor\)</span>，当 <span class="math inline">\(n=5\times 10^8\)</span> 时，<span class="math inline">\(\dfrac n5\)</span> 就已经是 <span class="math inline">\(10^8\)</span> 了，所以我们二分的左右边界应为 <span class="math inline">\([0,5\times 10^8]\)</span>。</p><p>然后 <code>check</code> 的话我们就暴力除 <span class="math inline">\(5\)</span> 计算答案（就像小奥一样），一次 <code>check</code> 的时间复杂度是 <span class="math inline">\(\log_5\)</span> 的，不会有问题。</p><details><pre class="cpp"><code>namespace XSC062 &#123;using namespace fastIO;int q, l, mid, r = 5e18, res;int check(int x) &#123;    int res = 0;    while (x / 5)        res += (x /= 5);    return res;&#125;int main() &#123;    read(q);    while (l &lt;= r) &#123;        int mid = (l + r) &gt;&gt; 1;        if (check(mid) &gt;= q) &#123;            res = mid;            r = mid - 1;        &#125;        else l = mid + 1;    &#125;    if (check(res) == q)        print(res);    else puts(&quot;No solution&quot;);    return 0;&#125;&#125; // namespace XSC062</code></pre></details><hr /><h3 id="c.-神族文字">C. 神族文字</h3><p><a href="http://222.180.160.110:61235/contest/3416/problem/3" class="uri">http://222.180.160.110:61235/contest/3416/problem/3</a></p><p>我不理解？这到底和分治有什么关系？GM 不会是纯看标签拉题吧？标签又是哪个聪明打的？</p><p>总而言之，言而总之，我们打一个 <code>map</code>。</p><details><pre class="cpp"><code>namespace XSC062 &#123;using namespace fastIO;using str = std::string;str s1, s2, sl;std::map&lt;str, str&gt; t;int main() &#123;    for (;;) &#123;        std::getline(std::cin, sl);        std::stringstream s(sl);        if (s &gt;&gt; s1) &#123;            s &gt;&gt; s2;            t[s2] = s1;        &#125;        else break;    &#125;    while (std::cin &gt;&gt; s1) &#123;        if (t.count(s1))            std::cout &lt;&lt; t[s1] &lt;&lt; &#39;\n&#39;;        else puts(&quot;eh&quot;);    &#125;    return 0;&#125;&#125; // namespace XSC062</code></pre></details><hr /><h3 id="d.-逃亡">D. 逃亡</h3><p><a href="http://222.180.160.110:61235/contest/3416/problem/4" class="uri">http://222.180.160.110:61235/contest/3416/problem/4</a></p><p>首先注意到车车是自动驾驶的，就是说一个人下车过后车会自动往另一个人的方向跑。</p><p>明显反复交接的话车会多跑很多路程，所以我们只交接一次。</p><p>所以难点只是用未知数把最终速度表示出来（想起了物理实验题）。</p><p>假设距离为 <span class="math inline">\(S\)</span>，车速为 <span class="math inline">\(v_1\)</span>，人速为 <span class="math inline">\(v_2\)</span>，第一个人一直坐车坐到 <span class="math inline">\(x\)</span> 路程，则最终时间为 <span class="math inline">\(\max\left\{ \dfrac x{v_1} + \dfrac {S - x}{v_2}, \dfrac x{v_1}+\dfrac {x - \dfrac x{v_1}\times v_2}{v_1 + v_2} + \dfrac {S-\dfrac x{v_1}\times v_2 - \dfrac {x - \dfrac x{v_1}\times v_2}{v_1 + v_2} \times v_2}{v_1}\right\}\)</span>。</p><p>有一个很明显的点，就是 <span class="math inline">\(x\)</span> 越大，第一个人用时就越短，第二个人用时就越多。这个时候我们就可以二分 <span class="math inline">\(x\)</span>，尽量使第一个人和第二个人用时接近（用时是一个关于 <span class="math inline">\(x\)</span> 的分段函数，我们寻找其拐点），最终相同用时即为答案。</p><details><p>因为从来不是很喜欢浮点数二分，采用了先整数二分再框范围取精确答案的方法。</p><p>所以怎么又是二分？说好的分治场呢？</p><pre class="cpp"><code>namespace XSC062 &#123;using namespace fastIO;using db = double;const db eps = 1e-2;db res, ans = 1e18;int s, v1, v2, l, mid, r;db min(db x, db y) &#123;    return x &lt; y ? x : y; &#125;db max(db x, db y) &#123;    return x &gt; y ? x : y;&#125;bool check(int x) &#123;    db t1 = x * 1.0 / v1;    db r1 = t1 + (s - x) * 1.0 / v2;    db t2 = (x - t1 * v2) / (v1 + v2);    db r2 = t1 + t2 + (s - t1 * v2 - t2 * v2) / v1;    return r1 &lt;= r2;&#125;int main() &#123;    read(s), read(v2), read(v1);    l = 0, r = s;    while (l &lt;= r) &#123;        mid = (l + r) &gt;&gt; 1;        if (check(mid)) &#123;            res = (db)mid;            r = mid - 1;        &#125;        else l = mid + 1;    &#125;    for (db i = res - 2; i &lt;= res + 2; i += eps) &#123;        db t1 = i * 1.0 / v1;        db r1 = t1 + (s - i) * 1.0 / v2;        db t2 = (i - t1 * v2) / (v1 + v2);        db r2 = t1 + t2 +                (s - t1 * v2 - t2 * v2) / v1;        ans = min(ans, max(r1, r2));    &#125;    printf(&quot;%.2lf&quot;, ans);    return 0;&#125;&#125; // namespace XSC062</code></pre></details><hr /><h3 id="e.-剔除多余括号">E. 剔除多余括号</h3><p><a href="http://222.180.160.110:61235/contest/3416/problem/5" class="uri">http://222.180.160.110:61235/contest/3416/problem/5</a></p><p><em>为了套取数据理解题意，我用 python 交了一个 <code>print(input())</code>，结果总司令在上，得到了 33pts 的高分…</em></p><p>什么叫多余括号呢？括号前后的符号优先级小于等于括号中的符号，并且若括号内存在括号与括号前同级，则括号前不为 <code>-</code> 或 <code>/</code>。</p><p>这样就可以了。我们将问题划分为若干个子问题，对每个括号内的内容进行相同方式的处理：对比括号内优先级最高的符号和括号前后符号的优先级，处理括号内的内容时若遇到括号，则递归地进行相似的处理。</p><details><p>其实这个充其量只能算是模拟…… 跟分治并不是很有关系，和 CSP-J 2022 T3 有点像。</p><pre class="cpp"><code>namespace XSC062 &#123;using namespace fastIO;const int maxn = 260;int n;char s[maxn];bool vis[maxn];int max(int x, int y) &#123;    return x &gt; y ? x : y;&#125;int Deal(int l, int r) &#123;    int res = 1;    for (int i = l; i &lt;= r; ++i) &#123;        if (s[i] == &#39;+&#39; || s[i] == &#39;-&#39;)            res = max(res, 1);        else if (s[i] == &#39;*&#39; || s[i] == &#39;/&#39;)            res = 2;        else if (s[i] == &#39;(&#39;) &#123;            int cnt = 1, j;            for (j = i + 1; j &lt;= r; ++j) &#123;                if (s[j] == &#39;(&#39;)                    ++cnt;                else if (s[j] == &#39;)&#39;)                    --cnt;                if (cnt == 0)                    break;            &#125;            cnt = Deal(i + 1, j - 1);            int t = 1;            int p1 = i - 1, p2 = j + 1;            while (s[p1] == &#39;(&#39; || s[p1] == &#39;)&#39;)                --p1;            while (s[p2] == &#39;(&#39; || s[p2] == &#39;)&#39;)                ++p2;            if (s[p1] == &#39;+&#39; || s[p1] == &#39;-&#39;)                t = max(t, 1);            else t = max(t, 2);            if (s[p2] == &#39;+&#39; || s[p2] == &#39;-&#39;)                t = max(t, 1);            else t = max(t, 2);            if (t &lt; cnt)                vis[i] = vis[j] = 1;            else if (t == cnt) &#123;                if (s[p1] != &#39;-&#39; &amp;&amp; s[p1] != &#39;/&#39;)                    vis[i] = vis[j] = 1;            &#125;            i = j;        &#125;    &#125;    return res;&#125;int main() &#123;    s[1] = &#39;+&#39;;    scanf(&quot;%s&quot;, s + 2);    n = strlen(s + 1) + 1;    s[n] = &#39;+&#39;;    Deal(1, n);    for (int i = 2; i &lt; n; ++i) &#123;        if (!vis[i])            putchar(s[i]);    &#125;    return 0;&#125;&#125; // namespace XSC062</code></pre></details><hr /><h3 id="f.-最接近点对问题">F. 最接近点对问题</h3><p><a href="http://222.180.160.110:61235/contest/3416/problem/6" class="uri">http://222.180.160.110:61235/contest/3416/problem/6</a></p><p>分治典中典。</p><p>我们将点按照横坐标排序，对点 <span class="math inline">\(1\sim n\)</span> 进行分治。</p><p>将求解区间包含的点分为两部分，假设左边部分和右边部分已经分别求解出了最近点对（出口即为求解区间仅包含两点，直接求出距离），考虑合并状态。则情况无非有三种：</p><ol type="1"><li>答案为左边部分的答案</li><li>答案为右边部分的答案</li><li>答案为左、右各选取一点</li></ol><p>前两者是已知量，则我们求解出第三种情况，选择最小值即可。</p><p>第三种情况有个很妙的处理方式：我们设前两种情况的答案较小者为 <span class="math inline">\(d\)</span>，设求解区间最靠中间的点为 <span class="math inline">\(m\)</span>。</p><ul><li><p>若 <span class="math inline">\(m\)</span> 为左边部分的点</p><p>则由于我们对半二分，<span class="math inline">\(m\)</span> 一定是左边部分最靠右的点。</p><ul><li><p>对于其余左边部分的节点：</p>若它们与 <span class="math inline">\(m\)</span> 的横向距离已经大于等于 <span class="math inline">\(d\)</span>，则它们与右边部分的点的横向距离会更大。连横向距离都已经大于等于当前最优解了，无需考虑纵向距离，筛除这部分点。</li><li><p>对于右边部分的节点：</p><p>若它们与 <span class="math inline">\(m\)</span> 的横向距离已经大于等于 <span class="math inline">\(d\)</span>，则它们与更左边的其他左边部分节点的横向距离会更大，故筛除这部分点。</p></li></ul></li><li><p>若 <span class="math inline">\(m\)</span> 为右边部分的点</p><p>同理。</p></li></ul><p>综上，我们只用考虑求解区间内与 <span class="math inline">\(m\)</span> 的横向距离小于 <span class="math inline">\(d\)</span> 的点。</p><p>在筛选出这些点后，我们如何进行进一步的处理呢？答案是，<strong>枚举</strong>。</p><p>我们枚举每一对点，计算它们间的距离。若比答案小，则更新答案。</p><p>那这复杂度也太神奇了。所以我们给出一个同样神奇的优化：按纵坐标递增对筛选出的点排序。当二重循环筛选时，若当前第一层循环 <span class="math inline">\(i\)</span> 与第二层循环 <span class="math inline">\(j\)</span> 的纵向距离大于等于了当前最小答案，就可以将第二层循环 <code>break</code> 了。因为纵坐标单调，继续枚举距离会继续增加，离答案更远。</p><p>那看起来复杂度还是很神奇，理论上来说应该是 <span class="math inline">\(O(n^2\log n)\)</span> 的呀？</p><p>考虑第一层循环 <span class="math inline">\(i\)</span>。对于点 <span class="math inline">\(i\)</span>，有哪些 <span class="math inline">\(j\)</span> 可以满足它的要求，从而被枚举到呢？</p><ul><li>由于点对无序，所以 <span class="math inline">\(j\)</span> 从 <span class="math inline">\(i+1\)</span> 开始枚举，所以 <span class="math inline">\(y_j&gt;y_i\)</span>。</li><li>由于筛选条件，<span class="math inline">\(|x_i-x_m|&lt; d\)</span> 且 <span class="math inline">\(|x_j-x_m|&lt; d\)</span>。</li><li>由于 <code>break</code> 条件，<span class="math inline">\(y_j-y_i&lt; d\)</span>。</li></ul><p>合并一下就是，<span class="math inline">\(|x_i-x_j|\le 2\times d\)</span>，且 <span class="math inline">\(0\le y_j - y_i \le d\)</span>。那么我们可以画出一个底为 <span class="math inline">\(2\times d\)</span>，高为 <span class="math inline">\(d\)</span> 的矩形，且它的中轴线为 <span class="math inline">\(x=x_m\)</span>，中轴线左右两边均为 <span class="math inline">\(d\times d\)</span> 的正方形。</p><p>若任意两个点同在左边部分或同在右边部分，那么这一对点的贡献已经在分治时计算完成了，所以一定不会比 <span class="math inline">\(d\)</span> 小。</p><p>有一个很妙的结论：满足条件的 <span class="math inline">\(j\)</span> 在矩形的左半边和右半边最多只有三个。</p><p>为什么？同一部分中，任意两个 <span class="math inline">\(j\)</span> 的距离至少为 <span class="math inline">\(d\)</span>。那么四个 <span class="math inline">\(j\)</span>，距离都为 <span class="math inline">\(d\)</span>，那么正好就是整个左半边的正方形。别忘了一点，<span class="math inline">\(j\)</span> 需满足的三个条件都是严格小于，所以不能碰到整个矩形的边界，所以一个部分中最多只能存在三个 <span class="math inline">\(j\)</span>。</p><p>那么实际上看似 <span class="math inline">\(n^2\)</span> 的枚举，在多个优化下就变成了 <span class="math inline">\(O(n)\)</span>。再加上对筛选出的点纵坐标排序的时间，总体时间复杂度为 <span class="math inline">\(O(n\log^2 n)\)</span>。</p><details><pre class="cpp"><code>namespace XSC062 &#123;using db = double;const db inf = 1e18;const int maxn = 6e4 + 5;struct _ &#123; db x, y; &#125;;int n;_ a[maxn];db dis(db x1, db y1, db x2, db y2) &#123;    return sqrt((x1 - x2) * (x1 - x2) +                (y1 - y2) * (y1 - y2));&#125;db min(db x, db y) &#123;    return x &lt; y ? x : y;&#125;db abs(db x) &#123;    return x &gt;= 0 ? x : -x;&#125;db Solu(int l, int r) &#123;    if (l == r)        return inf;    if (l + 1 == r)        return dis(a[l].x, a[l].y, a[r].x, a[r].y);    int mid = (l + r) &gt;&gt; 1;    db d = min(Solu(l, mid), Solu(mid + 1, r));    std::vector&lt;_&gt; t;    for (int i = l; i &lt;= r; ++i) &#123;        if (abs(a[i].x - a[mid].x) &lt; d)            t.push_back(a[i]);    &#125;    std::sort(t.begin(), t.end(),        [&amp;](_ x, _ y) &#123; return x.y &lt; y.y; &#125;);    for (int i = 0; i &lt; (int)t.size(); ++i) &#123;        for (int j = i + 1; j &lt; (int)t.size(); ++j) &#123;            if (t[j].y - t[i].y &gt;= d)                break;            d = min(d, dis(t[i].x, t[i].y,                                t[j].x, t[j].y));        &#125;    &#125;    return d;&#125;int main() &#123;    scanf(&quot;%d&quot;, &amp;n);    for (int i = 1; i &lt;= n; ++i)        scanf(&quot;%lf %lf&quot;, &amp;a[i].x, &amp;a[i].y);    std::sort(a + 1, a + n + 1,        [&amp;](_ x, _ y) &#123; return x.x &lt; y.x; &#125;);    printf(&quot;%.2lf\n&quot;, Solu(1, n) / 2);    return 0;&#125;&#125; // namespace XSC062</code></pre></details><p>考虑一个问题。代码的时间复杂度有两个 <span class="math inline">\(\log\)</span>，这是极不好的（will be fixed）。</p><hr /><h3 id="g.-残缺棋盘问题">G. 残缺棋盘问题</h3><p><a href="http://222.180.160.110:61235/contest/3416/problem/7" class="uri">http://222.180.160.110:61235/contest/3416/problem/7</a></p><p>首先考虑一个有趣的问题：<span class="math inline">\(4^n-1\)</span> 一定被 <span class="math inline">\(3\)</span> 整除吗？</p><p>一个简单的方法是使用数学归纳法进行证明，其思想也会在这道题中体现。</p><p>不过还有另一个方法：<span class="math inline">\(4^n-1=(3+1)^n-1\)</span>，使用二项式定理则有：</p><p><span class="math display">\[(3+1)^n-1=\sum_{i=0}^n {n\choose i} \times 3^{n-i}\times 1^i - 1\]</span></p><p>不难发现除 <span class="math inline">\(i=n\)</span> 时，前面每一项都有因子 <span class="math inline">\(3\)</span>，而当 <span class="math inline">\(i=n\)</span> 时，<span class="math inline">\({n\choose n}\times 3^0\times 1^n=1\)</span>，与后面的 <span class="math inline">\(-1\)</span> 抵消，故得证。</p><hr /><p>考虑将棋盘划分为若干个 <span class="math inline">\(2\times 2\)</span> 的 1 级区域。对于缺口所在的 1 级区域，我们使用一个刚好贴合的三格板将其补齐成为一个完整的 1 级区域。</p><p>我们称包含四个完整的 <span class="math inline">\(2\times 2\)</span> 的 1 级区域的 <span class="math inline">\(4\times 4\)</span> 的区域为 2 级区域，对于包含了我们刚刚补齐的 1 级区域的 2 级区域，我们将最中间的四个格子视为一个 1 级区域并填充，接下来剩余的 3 个完整 1 级区域为各自失去一个能填充的格子，我们选取对应的三格板填充即可。</p><p>对于一个 <span class="math inline">\(8\times 8\)</span> 的 3 级区域，若其包含我们填充完毕的 2 级区域，我们将最中间 <span class="math inline">\(2\times 2\)</span> 的格子视为一个 1 级区域并填充。接下来，剩余的 3 个完整的 2 级区域成为缺失 1 个格子的 2 级区域，按之前的方法填充即可。</p><p>以此类推即可递归地填充完成整个棋盘。但现在又来了一个问题：这道题没有 SPJ。根据样例可知，填充规则是由外到内，中、左上、左下、右上、右下，我们按照此顺序进行分治递归即可。</p><details><pre class="cpp"><code>namespace XSC062 &#123;using namespace fastIO;const int maxn = 105;int n, x, y, cnt;int t[maxn][maxn];void getColor(int c, int r, int l, int x, int y) &#123;    if (l == 2) &#123;        ++cnt;        for (int i = c; i &lt;= c + 1; ++i) &#123;            for (int j = r; j &lt;= r + 1; ++j) &#123;                if (i != x || j != y)                    t[i][j] = cnt;            &#125;        &#125;        return;    &#125;    l /= 2;    if (x - c &lt; l) &#123;        if (y - r &lt; l) &#123;            getColor(c + l - 1, r + l - 1,                        2, c + l - 1, r + l - 1);            getColor(c, r, l, x, y);            getColor(c + l, r, l, c + l, r + l - 1);            getColor(c, r + l, l, c + l - 1, r + l);            getColor(c + l, r + l, l, c + l, r + l);        &#125;        else &#123;            getColor(c + l - 1, r + l - 1,                        2, c + l - 1, r + l);            getColor(c, r, l, c + l - 1, r + l - 1);            getColor(c + l, r, l, c + l, r + l - 1);            getColor(c, r + l, l, x, y);            getColor(c + l, r + l, l, c + l, r + l);        &#125;    &#125;    else &#123;        if (y - r &lt; l) &#123;            getColor(c + l - 1, r + l - 1,                            2, c + l, r + l - 1);            getColor(c, r, l, c + l - 1, r + l - 1);            getColor(c + l, r, l, x, y);            getColor(c, r + l, l, c + l - 1, r + l);            getColor(c + l, r + l, l, c + l, r + l);        &#125;        else &#123;            getColor(c + l - 1, r + l - 1,                            2, c + l, r + l);            getColor(c, r, l, c + l - 1, r + l - 1);            getColor(c + l, r, l, c + l, r + l - 1);            getColor(c, r + l, l, c + l - 1, r + l);            getColor(c + l, r + l, l, x, y);        &#125;    &#125;    return;&#125;int main() &#123;    read(n), read(x), read(y);    getColor(1, 1, n, x, y);    for (int i = 1; i &lt;= n; ++i) &#123;        for (int j = 1; j &lt;= n; ++j)            print(t[i][j], &#39; &#39;);        putchar(&#39;\n&#39;);    &#125;    return 0;&#125;&#125; // namespace XSC062</code></pre></details><hr /><h3 id="h.-tricky-function">H. Tricky Function</h3><p><a href="http://222.180.160.110:61235/contest/3416/problem/8" class="uri">http://222.180.160.110:61235/contest/3416/problem/8</a></p><p>GM 提示了这道题就是平面最近点对。豁然开朗。</p><p>不妨将 <span class="math inline">\(i\)</span> 视作 <span class="math inline">\(x_i\)</span>，将 <span class="math inline">\(\sum_{k=1}^i a_k\)</span> 视作 <span class="math inline">\(y_i\)</span>，则直接求解平面最近点对即可。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 分治 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>美丽的柠檬花！</title>
      <link href="/20230203/"/>
      <url>/20230203/</url>
      
        <content type="html"><![CDATA[<p>Solution to <a href="https://codeforces.com/problemset/problem/1733/D2">CF1733D2 Zero-One (Hard Version)</a>。</p><span id="more"></span><hr /><p>没做过简单版本，模拟赛上遇到，乍一看是个贪心，但贪心思维太弱想不到怎么贪。所以思考其他方法。</p><p>下文称同时取反 <span class="math inline">\(a_i\)</span> 和 <span class="math inline">\(a_j\)</span> 的一次操作为「取反 <span class="math inline">\((a_i, a_j)\)</span>」，称 <span class="math inline">\(a_i=b_i\)</span> 的状态为「匹配」。</p><hr /><h3 id="思维关键点">思维关键点</h3><p>若我们想要将 <span class="math inline">\((a_i,a_j)\)</span> 取反，我们可以怎么做？</p><p>不难发现，分 <span class="math inline">\(a_i\)</span> 与 <span class="math inline">\(a_j\)</span> 相邻和不相邻两种情况：</p><ol type="1"><li><p><span class="math inline">\(a_i\)</span> 与 <span class="math inline">\(a_j\)</span> 相邻：</p><ol type="1"><li>直接取反，代价为 <span class="math inline">\(x\)</span>。</li><li>寻找到一个与 <span class="math inline">\(a_i\)</span> 和 <span class="math inline">\(a_j\)</span> 都不相邻的 <span class="math inline">\(a_k\)</span>，先将 <span class="math inline">\((a_i,a_k)\)</span> 取反，再将 <span class="math inline">\((a_j,a_k)\)</span> 取反，代价为 <span class="math inline">\(2\times y\)</span>。</li></ol></li><li><p><span class="math inline">\(a_i\)</span> 与 <span class="math inline">\(a_j\)</span> 不相邻：</p><ol type="1"><li>直接取反，代价为 <span class="math inline">\(y\)</span>。</li><li>将 <span class="math inline">\((a_i,a_{i + 1}),(a_{i + 1}, a_{i + 2}),\cdots,(a_{j - 1}, a_{j})\)</span> 取反，代价为 <span class="math inline">\((j - i)\times x\)</span>。</li></ol></li></ol><p>接下来考虑另一个问题：我们要取反哪些 <span class="math inline">\((a_i,a_j)\)</span> 呢？</p><p>假设现在有 <span class="math inline">\(a_p\)</span> 与 <span class="math inline">\(b_p\)</span> 不匹配，<span class="math inline">\(a_q\)</span> 与 <span class="math inline">\(b_q\)</span> 不匹配，那么我们肯定选择将 <span class="math inline">\((a_p,a_q)\)</span> 取反。</p><p>原因很简单，假设有 <span class="math inline">\(a_k=b_k\)</span>，如果我们将 <span class="math inline">\((a_p,a_k)\)</span> 取反，那么 <span class="math inline">\(a_k\ne b_k\)</span>，我们需要额外的一次与 <span class="math inline">\(a_k\)</span> 有关的操作将其复原。如果我们挑选一个 <span class="math inline">\(a_l=b_l\)</span>，并将 <span class="math inline">\((a_k,a_l)\)</span> 取反，那么 <span class="math inline">\(a_l\)</span> 与 <span class="math inline">\(b_l\)</span> 又会不匹配，又需要一次操作；如果挑选一个 <span class="math inline">\(a_l\ne b_l\)</span>，并将 <span class="math inline">\((a_k,a_l)\)</span> 取反，那么为什么不能在一开始就将 <span class="math inline">\((a_p,a_l)\)</span> 取反呢？此时的 <span class="math inline">\(a_k\)</span> 相当于一个中继，而这种情况我们已经在取反 <span class="math inline">\((a_p,a_l)\)</span> 时考虑到了。</p><p>也就是说，我们每次取反 <strong>只</strong> 选择两个无法与 <span class="math inline">\(b\)</span> 匹配的 <span class="math inline">\(a\)</span>。</p><p>那么，有没有一种情况，让我们无法选择两个无法匹配的值呢？</p><p>那就是不匹配的值的数量有奇数个，才会让我们两个两个选的时候有元素落单。</p><p>不妨思考一次取反操作所有可能的情况（假设不受上面的结论限制）：</p><ol type="1"><li><p>取反一个匹配值和一个不匹配值</p>此时匹配值变为非匹配，不匹配值变为匹配，不匹配的元素总数不变。</li><li><p>取反两个不匹配值</p>两个不匹配值都变为匹配，不匹配元素的总数量增加 <span class="math inline">\(-2\)</span>。</li><li><p>取反两个匹配值</p><p>两个匹配值都变为非匹配，不匹配元素的总数量增加 <span class="math inline">\(2\)</span>。</p></li></ol><p>综上，一次操作对不匹配元素总数带来的更改只可能为 <span class="math inline">\(0,2,-2\)</span>，均为偶数。当不匹配元素为奇数时，必定无法将其更改至刚好为 <span class="math inline">\(0\)</span>。此时输出 <span class="math inline">\(-1\)</span>。</p><p>我们上面结论的可实现性也得到了保障：只取反两个不匹配的 <span class="math inline">\(a\)</span>，不会有元素落单。</p><p>下文记从前往后第 <span class="math inline">\(i\)</span> 个与 <span class="math inline">\(b\)</span> 不匹配的 <span class="math inline">\(a\)</span> 的下标为 <span class="math inline">\(d_i\)</span>。</p><hr /><h3 id="确定实现方法">确定实现方法</h3><p>发现 <span class="math inline">\(\sum n\le 5\times 10^3\)</span>，确定算法复杂度为 <span class="math inline">\(O(n^2)\)</span>。</p><p>首先不难想到暴力搜索，每次枚举将哪一对 <span class="math inline">\((d_i, d_j)\)</span> 取反。</p><p>亦或是使用 <code>bitset</code> 记录哪些非匹配值已被取反（被取反为 <span class="math inline">\(1\)</span>，否则为 <span class="math inline">\(0\)</span>），枚举数对暴力 DP 更新最小值。</p><p>但以上两种方法铁定超时。</p><p>受到上面两种方法的启发，扩展思维，我们发现：</p><ul><li><p>取反操作的顺序不会影响最终答案。</p>因为每个数被取反的次数一定，最终结果也就一定。</li><li><p>我们可以通过 DP 的方式寻找最小值。</p></li></ul><p>设计状态。</p><p>不妨考虑让问题麻烦起来的是什么，对于 <span class="math inline">\(d_i\)</span> 与 <span class="math inline">\(d_j\)</span> 不相邻时的取反，我们无法得知 <span class="math inline">\(d_i\)</span> 需要哪一个 <span class="math inline">\(d_j\)</span>（而对于 <span class="math inline">\(d_i\)</span> 与 <span class="math inline">\(d_j\)</span> 相邻的情况，<span class="math inline">\(d_j\)</span> 就是 <span class="math inline">\(d_{i + 1}\)</span>，位置是确定的）。</p><p>但我们同时也发现，与相邻时的代价不同，不相邻时的操作代价与 <span class="math inline">\(i\)</span>，<span class="math inline">\(j\)</span> 的具体值无关。</p><p>所以不妨用 <span class="math inline">\(f_{i,j}\)</span> 表示，已枚举到 <span class="math inline">\(d_i\)</span>，前面有 <span class="math inline">\(j\)</span> 个数需要后面 <strong>与它们不相邻的数</strong> 用以和它们配对取反。</p><p>假设已枚举到 <span class="math inline">\(d_i\)</span>，当前面有 <span class="math inline">\(s\)</span> 个数需要配对时，有以下的情况：</p><ul><li><p>当 <span class="math inline">\(s = 1\)</span>，即只有一个数需要配对时：</p><ul><li><p>如果这个数是 <span class="math inline">\(d_{i - 1}\)</span>，那么代价为 <span class="math inline">\(2\times y\)</span>。</p>注意，这里只枚举了需要不相邻的数来配对的情况，相邻的情况将会另外计算，所以代价不能为 <span class="math inline">\(x\)</span>。</li><li>否则，代价为 <span class="math inline">\(y\)</span>。</li></ul></li><li><p>当 <span class="math inline">\(s&gt;1\)</span> 时，即有多个数需要配对时：</p><p>不管 <span class="math inline">\(d_{i-1}\)</span> 是否需要配对，我们都不选它。因为选它的代价是 <span class="math inline">\(2\times y\)</span>，而随便选另一个待配对数的代价都只有 <span class="math inline">\(y\)</span>。</p></li></ul><p>那么问题来了，我咋知道它们相不相邻？</p><p>再多开一维 <span class="math inline">\(0/1\)</span> 状态，记录最后一个需要与其他后面的元素配对值是否是 <span class="math inline">\(a_{i-1}\)</span> 即可。</p><p>假设现在已经枚举到 <span class="math inline">\(f_{i,j,0/1}\)</span>，即已枚举完 <span class="math inline">\(d_i\)</span>，有 <span class="math inline">\(j\)</span> 个元素需要配对。</p><p>则更新 <span class="math inline">\(d_{i+1}\)</span> 的状态：</p><ul><li><p>若我们想要让 <span class="math inline">\(d_{i+1}\)</span> 与后面的元素配对，则代价至少为 <span class="math inline">\(y\)</span>。至于是否会因为待配对元素相邻而额外增加 <span class="math inline">\(y\)</span> 的代价，我们在待配对元素处计算。</p><span class="math display">\[ f_{i+1,j+1,1}\gets\min(f_{i,j,0},f_{i,j,1}) + y \]</span></li><li><p>若我们想要让 <span class="math inline">\(d_{i+1}\)</span> 与其相邻的 <span class="math inline">\(a_{i+2}\)</span> 匹配，那么 <span class="math inline">\(d_{i+2}\)</span> 就不需要再与后面的元素配对了，故最后一维为 <span class="math inline">\(0\)</span>。</p><span class="math display">\[ f_{i+2,j,0}\gets\min(f_{i,j,0},f_{i,j,1})+(d_{i+2}-d_{i+1})\times x \]</span></li><li><p>如果我们想让 <span class="math inline">\(d_{i+1}\)</span> 与前面的待配对元素配对：</p><p>在此种大前提下，<span class="math inline">\(d_{i+1}\)</span> 一定不需要与后面的元素配对，故最后一维为 <span class="math inline">\(0\)</span>。</p><ul><li><p>当 <span class="math inline">\(j=1\)</span> 且 <span class="math inline">\(d_i+1=d_{i+1}\)</span> 时，即存在其相邻元素，且只有一个配对可选项时：</p><ul><li>如果这个数是 <span class="math inline">\(d_{i}\)</span>，则 <span class="math inline">\(d_{i+1}\)</span> 必须与相邻元素配对。</li></ul><p><span class="math display">\[ f_{i+1,j-1,0}\gets f_{i,j,1}+y \]</span></p>因为在计算 <span class="math inline">\(f_{i,j,1}\)</span> 时已计算了一个 <span class="math inline">\(y\)</span>，所以此处只用加一个 <span class="math inline">\(y\)</span>。<ul><li><p>否则，该元素完成配对，不产生任何代价。</p><span class="math display">\[ f_{i+1,j-1,0}\gets f_{i,j,0} \]</span></li></ul></li><li><p>否则，随意选择前面的一个数。</p><p>因为此时，要么前面有除了相邻元素的其他数可选，要么根本没有相邻元素，所以该数完成配对不会产生任何代价（因为 <span class="math inline">\(y\)</span> 已经加过了）。</p><p><span class="math display">\[ f_{i+1,j-1,0}\gets \min(f_{i,j,0},f_{i,j,1}) \]</span></p></li></ul></li></ul><p>至此，全部情况讨论完毕。因为不能让最后一个元素再去与后面的元素配对，最终答案为 <span class="math inline">\(f_{tot,0,0}\)</span>，其中 <span class="math inline">\(tot\)</span> 为 <span class="math inline">\(d\)</span> 数组长度。</p><p>时间复杂度 <span class="math inline">\(O(n^2)\)</span>，空间复杂度 <span class="math inline">\(O(n^2)\)</span>。</p><p>因为 <span class="math inline">\(x,y\le 10^9\)</span>，最坏情况下需要加 <span class="math inline">\(\dfrac n2\)</span> 次，故需要为 DP 数组开 <code>long long</code>。尽管热心人士 @<a href="/user/428358">cqbztzl</a> 帮助我计算得出使用空间约为 300 兆，但仍然会 MLE。</p><p>不难发现，第一维枚举到 <span class="math inline">\(i\)</span> 时，只需要更新第一维为 <span class="math inline">\(i+1\)</span> 和 <span class="math inline">\(i+2\)</span> 状态的值，而不需要其他任何 DP 值，故将第一维模 <span class="math inline">\(3\)</span>，滚动为 <span class="math inline">\(0\sim 2\)</span>。</p><hr /><pre class="cpp"><code>// 代码里可能有一些赛时的神秘注释 hhhnamespace XSC062 &#123;using namespace fastIO;const ll inf = 1e18;const int maxn = 5e3 + 5;ll x, y;int T, n, tot;ll f[3][maxn][2];int diff[maxn], a[maxn], b[maxn];ll min(ll x, ll y) &#123;    return x &lt; y ? x : y;&#125;void upd(int i, int j, int k, ll y) &#123;    f[i % 3][j][k] = min(f[i % 3][j][k], y);    return;&#125;int main() &#123;    read(T);    while (T--) &#123;        read(n), read(x), read(y);        tot = 0;        for (int i = 1; i &lt;= n; ++i)            getnum(a[i]);        for (int i = 1; i &lt;= n; ++i) &#123;            getnum(b[i]);            if (a[i] != b[i])                diff[++tot] = i;        &#125;        if (tot &amp; 1) &#123;            puts(&quot;-1&quot;);            continue;        &#125;        memset(f, 0x3f, sizeof (f));        f[0][0][0] = 0;        for (int i = 0; i &lt;= tot; ++i) &#123;            for (int j = 0; j &lt;= i; ++j) &#123;                // 新增起点                if (i + 1 &lt;= tot) &#123;                    upd(i + 1, j + 1, 1,                        min(f[i % 3][j][0],                            f[i % 3][j][1]) + y);                &#125;                // 碾过去                 if (i + 2 &lt;= tot) &#123;                    upd(i + 2, j, 0,                        min(f[i % 3][j][0],                            f[i % 3][j][1]) +                            (diff[i + 2] -                            diff[i + 1]) * x);                &#125;                // 使用起点                if (j &gt; 0 &amp;&amp; i + 1 &lt;= tot) &#123;                    if (j == 1 &amp;&amp; diff[i] + 1 ==                                        diff[i + 1]) &#123;                        upd(i + 1, j - 1, 0,                                f[i % 3][j][1] + y);                        upd(i + 1, j - 1, 0,                                f[i % 3][j][0]);                    &#125;                    else &#123;                        upd(i + 1, j - 1, 0,                            min(f[i % 3][j][0],                                f[i % 3][j][1]));                    &#125;                &#125;                if (i != tot) &#123;                    f[i % 3][j][0] =                        f[i % 3][j][1] = inf;                &#125;            &#125;        &#125;        print(f[tot % 3][0][0], &#39;\n&#39;);    &#125;    return 0;&#125;&#125; // namespace XSC062</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>瑰丽华尔兹</title>
      <link href="/20230111/"/>
      <url>/20230111/</url>
      
        <content type="html"><![CDATA[<p>Solution to<a href="http://222.180.160.110:61235/problem/8965">「NOI2005」瑰丽华尔兹</a>。</p><span id="more"></span><hr /><p>单调队列优化 DP。</p><p>不难发现，题意可转化为：</p><p>从 <span class="math inline">\((x,y)\)</span> 出发，按顺序向 <span class="math inline">\(d_i\)</span> 方向移动 <span class="math inline">\([0,t_i−s_i+1]\)</span> 距离，问最大移动距离。</p><p>为了方便描述，我们把一次「向 <span class="math inline">\(d_i\)</span> 方向移动 <span class="math inline">\([0,t_i−s_i+1]\)</span> 距离」的操作称为「一步」。</p><p>设计状态。不难发现位置信息必须出现在 DP 的维度中（因为当前位置会影响下一步滑动的距离），而其他信息均不会对下一步滑动产生影响。</p><p>故可令 <span class="math inline">\(f_{i,j}\)</span> 表示完成当前次滑动后，从起点滑动到 <span class="math inline">\((i,j)\)</span> 可得到的最大滑动距离。</p><p>以方向上为例，可列 DP 式：</p><p><span class="math display">\[f_{i,j}=\max_{i&lt;k≤i+(ti−si+1)}\{f_{k,j}+k−i\}\]</span></p><p>此时可枚举每一列的所有状态，使用单调队列优化。</p><p>但实际操作中会出现问题。因为单调队列从下向上更新状态时，<span class="math inline">\(f_{k,j}\)</span> 会比 <span class="math inline">\(f_{i,j}\)</span> 先更新（参考 01 背包倒序枚举容量），导致每一「步」会重复被走很多次。但单调队列的特性限制了我们只能从下向上枚举，此时可新开一个数组记录 <span class="math inline">\(f\)</span> 当次被更新之前的值。</p><p>障碍物如何处理呢？我们知道，如果 <span class="math inline">\((i,j)\)</span> 下面某一位置有障碍物，那么障碍物下面所有的 <span class="math inline">\((k,j)\)</span> 都不能用于更新 <span class="math inline">\(f_{i,j}\)</span>（因为被挡住了滑不上来）。所以我们在从下往上枚举时，遇到障碍物就清空单调队列即可。</p><p>下、左、右方向的处理方式类似。</p><p>只需顺序执行操作，根据当前操作方向对应处理即可。</p><details><pre class="cpp"><code>namespace XSC062 &#123;using namespace fastIO;const int maxn = 205;const int inf = 1e18;int q[maxn];char a[maxn][maxn];int f[maxn][maxn], d[maxn][maxn];int n, m, x, y, k, u, h, t, res;int max(int x, int y) &#123;    return x &gt; y ? x : y;&#125;int main() &#123;    memset(f, -0x3f, sizeof (f));    read(n), read(m);    read(x), read(y), read(k);    f[x][y] = 0;    for (int i = 1; i &lt;= n; ++i)        scanf(&quot;%s&quot;, a[i] + 1);    while (k--) &#123;        read(x), read(y), read(u);        y = y - x + 1;        if (u == 1) &#123;            for (int j = 1; j &lt;= m; ++j) &#123;                h = 1, t = 0;                for (int i = n; i; --i) &#123;                    if (a[i][j] == &#39;x&#39;) &#123;                        h = 1, t = 0;                        continue;                    &#125;                    while (h &lt;= t &amp;&amp; q[h] - i &gt; y)                        ++h;                    d[i][j] = f[i][j];                    if (h &lt;= t) &#123;                        f[i][j] = max(f[i][j],                                    d[q[h]][j] + q[h] - i);                    &#125;                    while (h &lt;= t &amp;&amp; d[i][j] + i                                    &gt;= d[q[t]][j] + q[t])                        --t;                    q[++t] = i;                &#125;            &#125;        &#125;        else if (u == 2) &#123;            for (int j = 1; j &lt;= m; ++j) &#123;                h = 1, t = 0;                for (int i = 1; i &lt;= n; ++i) &#123;                    if (a[i][j] == &#39;x&#39;) &#123;                        h = 1, t = 0;                        continue;                    &#125;                    while (h &lt;= t &amp;&amp; i - q[h] &gt; y)                        ++h;                    d[i][j] = f[i][j];                    if (h &lt;= t) &#123;                        f[i][j] = max(f[i][j],                                    d[q[h]][j] + i - q[h]);                    &#125;                    while (h &lt;= t &amp;&amp; d[i][j] - i                                &gt;= d[q[t]][j] - q[t])                        --t;                    q[++t] = i;                &#125;            &#125;        &#125;        else if (u == 3) &#123;            for (int i = 1; i &lt;= n; ++i) &#123;                h = 1, t = 0;                for (int j = m; j; --j) &#123;                    if (a[i][j] == &#39;x&#39;) &#123;                        h = 1, t = 0;                        continue;                    &#125;                    while (h &lt;= t &amp;&amp; q[h] - j &gt; y)                        ++h;                    d[i][j] = f[i][j];                    if (h &lt;= t) &#123;                        f[i][j] = max(f[i][j],                                    d[i][q[h]] + q[h] - j);                    &#125;                    while (h &lt;= t &amp;&amp; d[i][j] + j                                &gt;= d[i][q[t]] + q[t])                        --t;                    q[++t] = j;                &#125;            &#125;        &#125;        else &#123;            for (int i = 1; i &lt;= n; ++i) &#123;                h = 1, t = 0;                for (int j = 1; j &lt;= m; ++j) &#123;                    if (a[i][j] == &#39;x&#39;) &#123;                        h = 1, t = 0;                        continue;                    &#125;                    while (h &lt;= t &amp;&amp; j - q[h] &gt; y)                        ++h;                    d[i][j] = f[i][j];                    if (h &lt;= t) &#123;                        f[i][j] = max(f[i][j],                                    d[i][q[h]] + j - q[h]);                    &#125;                    while (h &lt;= t &amp;&amp; d[i][j] - j                                &gt;= d[i][q[t]] - q[t])                        --t;                    q[++t] = j;                &#125;            &#125;        &#125;        for (int i = 1; i &lt;= n; ++i) &#123;            for (int j = 1; j &lt;= m; ++j)                res = max(res, f[i][j]);        &#125;    &#125;    print(res);    return 0;&#125;&#125; // namespace XSC062</code></pre></details>]]></content>
      
      
      
        <tags>
            
            <tag> DP </tag>
            
            <tag> 单调队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>背单词</title>
      <link href="/20230110/"/>
      <url>/20230110/</url>
      
        <content type="html"><![CDATA[<p>Solution to<a href="http://222.180.160.110:61235/problem/59">「SCOI2016」背单词</a>。</p><span id="more"></span><hr /><p>题解 P3294。</p><p>我们看到字典树这个标签，下意识想到了前缀。</p><p>但是题目让我们求后缀，所以我们把所有字符串先 <code>reverse</code> 一下，将问题转化为前缀，方便描述。</p><hr /><p>我们发现，因为 <span class="math inline">\(y &lt; x \le n\)</span>，所以三种情况的花费排序为 <span class="math inline">\(x-y&lt;x&lt;n\times n\)</span>。</p><p>不难发现，我们可以很简单地通过「把某单词的所有前缀单词放到它之前」消除开销为 <span class="math inline">\(n\times n\)</span> 的情况。此时开销最劣情况下为 <span class="math inline">\(\sum\limits_{i=1}^ni &lt; n\times n\)</span>。</p><p>接下来，问题在于怎样在满足「把某单词的所有前缀单词放到它之前」的条件下，最小化开销。不难发现，当我们去除第一种情况后，剩下的 <span class="math inline">\(x\)</span> 和 <span class="math inline">\(x-y\)</span> 都包含 <span class="math inline">\(x\)</span> 项，也就是说，我们只需要最小化 <span class="math inline">\(\sum -y\)</span> 的值，也就是最大化 <span class="math inline">\(\sum y\)</span> 的值。而 <span class="math inline">\(\sum x\)</span> 为定值 <span class="math inline">\(\sum\limits_{i=1}^ni\)</span>。</p><p><strong>关于处理方式：不难发现一个单词的最长前缀单词最多只有一个，但以该单词为最长前缀单词的单词可能有多个，联想到树。</strong></p><p><strong>我们将每个单词的最长前缀和该单词连边，会得到一个森林。</strong></p><p>不妨先考虑问题的简化，假设有两条链（即，不会同时存在多个单词，使得它们的最长前缀单词相同），应该如何安排其顺序。</p><p>如图所示，考虑「同一条链均匀分散到序列中」和「同一条链集中在一起」两种有规律的安排方式，得到：</p><p><img src="1.jpg" /></p><p>可以发现，第二种情况明显更优。</p><p>所以我们扩展猜想：对于某一单词，以它为前缀的所有单词必须紧随其后。该结论是可递归的。</p><p>继续处理细节部分。考虑两条链长度不同，应如何排列它们的位置？</p><p>下图展示了「前短后长」和「前长后短」两种方案：</p><p><img src="2.jpg" /></p><p>可以发现，前短后长的方案更优。</p><p>扩展得到猜想，同一单词的所有子树中，大小更小的应在更前面。该结论是可递归的。</p><hr /><p>接下来对猜想进行证明。</p><p>假设现在已有一条链。我们只有把整条链连在一起，短单词放到长单词前面这一种方法。</p><p>然后新来了一个不属于这条链的节点，明显，因为节点不管放到哪里，其 <span class="math inline">\(y\)</span> 值不变，但会改变已有链的 <span class="math inline">\(y\)</span> 值，所以放到最前面最优。</p><p>又来了一个节点，和刚才新增的节点属于同一条链，一样，不管这个节点何去何从，其 <span class="math inline">\(y\)</span> 不变，但放在越前面，后面的节点的 <span class="math inline">\(y\)</span> 值增加得越多。</p><p>以此类推可得到结论，同一条链放到一起。短链放到长链前面也是比较好想的。假设有两条链，短链长度为 <span class="math inline">\(a\)</span>，长链长度为 <span class="math inline">\(b\)</span>，放置起点为 <span class="math inline">\(l\)</span>，则前短后长和钱长后短的 y 之和分别为 <span class="math inline">\(\dfrac{(l + l + a - 2) \times (a - 1) + (l + a + l + a + b - 2) \times (b - 1)} 2\)</span> 和 <span class="math inline">\(\dfrac{(l + l + b - 2) \times (b - 1) + (l + b + l + b + a - 2) \times (b - 1)} 2\)</span>（运用等差数列求和公式），解不等式可得前短后长一定更优。</p><p>接下来是从链扩展到树。那么我们想到了什么？树链剖分。</p><p>我们化用树剖思想，以最轻边为剖分条件，将树划分为有顺序的链，按照上述方式排列其顺序即可。</p><p>此时我们记录下每个单词的直系父亲（即其最长前缀单词），在唯一序列中模拟计分操作，即可得到答案。</p><hr /><p>为了方便，可将所有入度为 <span class="math inline">\(0\)</span> 的点与一个虚点相连，将森林转化为树。</p><p>注意 <code>long long</code>。</p><details><pre class="cpp"><code>namespace XSC062 &#123;using namespace fastIO;using str = std::string;const int maxn = 1e6 + 5;const int maxm = 1e6 + 5;str s[maxn];int T[maxm][26];int kaz[maxn], siz[maxn]; // kaz 表示单词在最终序列中所处的位置std::vector&lt;int&gt; g[maxn];int n, l, res, cnt = 1, ti;int tot[maxm], fa[maxn], deg[maxn];void Insert(int k) &#123;     int f = 1, len = s[k].length();    for(int i = 0; i &lt; len; ++i) &#123;        if (!T[f][s[k][i] - &#39;a&#39;])             T[f][s[k][i] - &#39;a&#39;] = ++cnt;        f = T[f][s[k][i]-&#39;a&#39;];    &#125;    tot[f] = k;    return;&#125;void Search(int k) &#123;    int f = 1;    int len = s[k].length();    for (int i = 0; i &lt; len; ++i) &#123;        f = T[f][s[k][i] - &#39;a&#39;];        if (tot[f]) &#123;            if (tot[f] != k)                fa[k] = tot[f]; // 记录当前最长前缀        &#125;    &#125;    return;&#125;void add(int x, int y) &#123;    ++deg[y];    g[x].push_back(y);    return;&#125;void DFS1(int x) &#123; // 提前计算每个子树的 size    siz[x] = 1;    for (auto i : g[x]) &#123;        DFS1(i);        siz[x] += siz[i];    &#125;    return;&#125;void DFS2(int x) &#123;    kaz[x] = ti++;  // 时间戳即为单词位置    std::sort(g[x].begin(), g[x].end(),        [&amp;](int x, int y) &#123; return siz[x] &lt; siz[y]; &#125;); // 按子树 size 排序    for (auto i : g[x])        DFS2(i);    return;&#125;int main() &#123;    scanf(&quot;%lld&quot;, &amp;n);    for (int i = 1; i &lt;= n; ++i) &#123;        std::cin &gt;&gt; s[i];        std::reverse(s[i].begin(), s[i].end());  // 后缀转前缀        Insert(i);        res += i;    &#125;    for (int i = 1; i &lt;= n; ++i) &#123;        Search(i);        if (fa[i])            add(fa[i], i); // 建图    &#125;    for (int i = 1; i &lt;= n; ++i) &#123;        if (!deg[i]) // 建虚点方便操作            add(n + 1, i), fa[i] = n + 1;    &#125;    DFS1(n + 1), DFS2(n + 1);    for (int i = 1; i &lt;= n; ++i)        res -= kaz[fa[i]]; // 处理 y 值    print(res);    return 0;&#125;&#125; // namespace XSC062</code></pre></details>]]></content>
      
      
      
        <tags>
            
            <tag> 字典树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>悬线法</title>
      <link href="/20220927/"/>
      <url>/20220927/</url>
      
        <content type="html"><![CDATA[<p>有一段时间看见单调栈就抑郁，所以做题的时候就东贺贺，西贺贺，最终了解到了世界上还有一种很神奇的方法叫悬线法。</p><span id="more"></span><p>本文中的「单调栈」均指依赖于顺序维护信息的工具，单纯利用单调性质作为数据结构独立存在的单调栈不在本篇文章 <strong>批判</strong> 范围之内。</p><hr /><h2 id="引入土豪聪要请客">引入：土豪聪要请客</h2><p><a href="http://222.180.160.110:61235/contest/2870/problem/4" class="uri">http://222.180.160.110:61235/contest/2870/problem/4</a></p><p>题意简述：给定一个 <span class="math inline">\(n\times m\)</span> 的矩阵，其中有一部分地方有障碍。在整个地图上找到周长最大的、不包含障碍的矩形。</p><p>输入一个由 <code>.</code>（空地）和 <code>X</code>（障碍）组成的矩阵，输出最大矩形周长减 <span class="math inline">\(1\)</span>。</p><details><p><summary>一些鲜花</summary></p><p>看到题后即可想到悬线法，但是中午太困了处于游离状态一直掉线，所以干瞪着电脑屏幕打瞌睡。</p><p><del>于是这篇文章从 220927 被拖到了 230916，哈哈真神奇</del> 现在是 231004 了，我才动笔。</p></details><hr /><p>首先预处理出 <span class="math inline">\(s_{i, j}\)</span>，表示从 <span class="math inline">\((i,\,j)\)</span> 向上，共有多少个连续的 <code>.</code>。</p><pre class="cpp"><code>for (int i = 1; i &lt;= n; ++i) &#123;    for (int j = 1; j &lt;= m; ++j)        s[i][j] = (a[i][j] == &#39;.&#39; ? s[i - 1][j] + 1 : 0);&#125;</code></pre><p>悬线法的名字很形象，拎着一根细线的头，让它自然下垂。</p><p>为了方便思考和实现，我们这样想象：一个地图，我们手里拿着一根硬棒朝上举，然后固定我们手只能在一行上运动，用它左右「刷」沿途的矩形。</p><p>具象地说，选定一行 <span class="math inline">\(i\)</span>，枚举每一个 <span class="math inline">\(j\)</span>，寻找以第 <span class="math inline">\(i\)</span> 行为底，包含 <span class="math inline">\((i,\,j)\)</span>，高为 <span class="math inline">\(s_{i,\,j}\)</span> 的最宽矩形。</p><p>也就是从 <span class="math inline">\((i, j)\)</span> 出发，往左右分别找到最远的一个位置 <span class="math inline">\(L_j, R_j\)</span>，满足 <span class="math inline">\(s_{i, L_j \sim R_j} \ge s_{i, j}\)</span>。那么悬线法最抽象的部分就讲完了，接下来是最神奇的部分。</p><p>在第 <span class="math inline">\(i\)</span> 行内，从每个 <span class="math inline">\((i, j)\)</span> 开始找到 <span class="math inline">\(L_j, R_j\)</span>，如果暴力那么明显是个 <span class="math inline">\(O(m^2)\)</span> 的时间。</p><p>但是我们考虑这么一件事情。假设 <span class="math inline">\(L_{i-1}\)</span> 已经求出。</p><p>令 <span class="math inline">\(k = j-1\)</span>，<span class="math inline">\(L_j\)</span> 初值赋为 <span class="math inline">\(j\)</span>（左端点至少是自己）。</p><ol type="1"><li>当 <span class="math inline">\(L_j=1\)</span> 时 即刻停止算法，因为 <span class="math inline">\(1\)</span> 是可达的最左位置，不能再往左了。</li><li>当 <span class="math inline">\(a_k &gt; a_j\)</span> 时 <span class="math inline">\(a_k\)</span> 就像一堵墙，堵住了我们要继续往左刷的硬棒，故不改变 <span class="math inline">\(L_j\)</span> 并停止算法。</li><li>否则，由于 <span class="math inline">\(a_{L_k\sim k}\ge a_k\ge a_j\)</span>，从 <span class="math inline">\(j\)</span> 开始往左刷至少都能够到 <span class="math inline">\(L_k\)</span>。此时我们令 <span class="math inline">\(k=L_k-1\)</span>，回到第一步。</li></ol><p>我们就可以求解到正确的 <span class="math inline">\(L_j\)</span> 的。求解 <span class="math inline">\(R_j\)</span> 的流程和上述大致相同，不再赘述。</p><hr /><p>那么是一个非常神奇的事情。悬线法的时间复杂度怎么证明呢？</p><p>我们思考。假设 <span class="math inline">\(a_{j-1}&gt;a_j\)</span>，算法会即刻停止；否则，当前定位直接跳到 <span class="math inline">\(L_{j-1}\)</span> 之前，也就是说，为了求解 <span class="math inline">\(L_{j-1}\)</span> 而遍历过的位置，求解 <span class="math inline">\(L_j\)</span> 时都不会再遍历第二遍。</p><p>没有值会被遍历第二遍，所以是 <span class="math inline">\(O(m)\)</span> 的。</p><hr /><p>按照上述流程，算法总体时间复杂度 <span class="math inline">\(O(n\times m)\)</span>，和单调栈完全一致。</p><details><pre class="cpp"><code>namespace XSC062 &#123;using namespace fastIO;const int maxn = 2e3 + 5;int n, m, ans;char a[maxn][maxn];int s[maxn][maxn], l[maxn][maxn], r[maxn][maxn];int max(int x, int y) &#123;    return x &gt; y ? x : y;&#125;int main() &#123;    read(n);    read(m);    for (int i = 1; i &lt;= n; ++i)        scanf(&quot;%s&quot;, a[i] + 1);    for (int i = 1; i &lt;= n; ++i) &#123;        for (int j = 1; j &lt;= m; ++j)            s[i][j] = (a[i][j] == &#39;.&#39; ? s[i - 1][j] + 1 : 0);    &#125;    for (int i = 1; i &lt;= n; ++i) &#123;        for (int j = 1; j &lt;= m; ++j) &#123;            l[i][j] = j;            while (l[i][j] &gt; 1 &amp;&amp; s[i][j] &lt;= s[i][l[i][j] - 1])                l[i][j] = l[i][l[i][j] - 1];        &#125;    &#125;    for (int i = 1; i &lt;= n; ++i) &#123;        for (int j = m; j; --j) &#123;            r[i][j] = j;            while (r[i][j] &lt; m &amp;&amp; s[i][j] &lt;= s[i][r[i][j] + 1])                r[i][j] = r[i][r[i][j] + 1];        &#125;    &#125;    for (int i = 1; i &lt;= n; ++i) &#123;        for (int j = 1; j &lt;= m; ++j) &#123;            if (!s[i][j])                continue;            ans = max(ans, (s[i][j] +                      (r[i][j] - l[i][j] + 1)) * 2);        &#125;    &#125;    printf(&quot;%d&quot;, ans - 1);    return 0;&#125;&#125; // namespace XSC062</code></pre></details><hr /><p>上述处理 <span class="math inline">\(s\)</span> 数组的「竖向压缩」技巧是处理矩阵类悬线法题目的常用技巧，这里使用另一道题来举例子。</p><h3 id="例玉蟾宫-city-game-城市游戏">例：玉蟾宫 / City Game / 城市游戏</h3><p><a href="http://222.180.160.110:61235/contest/1655/problem/2" class="uri">http://222.180.160.110:61235/contest/1655/problem/2</a></p><p>这道题和上一道非常相似，只需改变求答案的式子即可。</p><details><pre class="cpp"><code>namespace XSC062 &#123;using namespace fastIO;const int maxn = 1e3 + 5; char t;int n, m, ans;int s[maxn][maxn];int l[maxn][maxn], r[maxn][maxn];int max(int x, int y) &#123;    return x &gt; y ? x : y;&#125;int main() &#123;    scanf(&quot;%d %d&quot;, &amp;n, &amp;m);    for (int i = 1; i &lt;= n; ++i) &#123;        for (int j = 1; j &lt;= m; ++j) &#123;            scanf(&quot;%1s&quot;, &amp;t);            if (t == &#39;F&#39;)                s[i][j] = s[i - 1][j] + 1;            l[i][j] = j;            while (l[i][j] &gt; 1 &amp;&amp; s[i][j]                        &lt;= s[i][l[i][j] - 1])                l[i][j] = l[i][l[i][j] - 1];        &#125;    &#125;    for (int i = 1; i &lt;= n; ++i) &#123;        r[i][m + 1] = m + 1;        for (int j = m; j; --j) &#123;            r[i][j] = j;            while (r[i][j] &lt; m &amp;&amp; s[i][j]                         &lt;= s[i][r[i][j] + 1])                r[i][j] = r[i][r[i][j] + 1];            ans = max(ans, s[i][j] *                        (r[i][j] - l[i][j] + 1));        &#125;    &#125;    print(ans * 3, &#39;\n&#39;);    return 0;&#125;&#125; // namespace XSC062</code></pre></details><hr /><h2 id="悬线法能维护的数据特点">悬线法能维护的数据特点</h2><p>值得注意的是，悬线法仅指求解最远左右端点的技巧。</p><p>同时可以维护过程中的其它信息，例如 <a href="/20231004">情景剧</a> 一题。链接中有详细叙述，此处略。</p><p>根据本题带来的启发，我们认识到悬线可在求解过程中维护的内容更多。</p><p><del>不像你单调栈随随便便删这删那信息全部断层什么都维护不了</del></p><hr /><h2 id="进一步地悬线法与单调栈">进一步地，悬线法与单调栈？</h2><p>和 <span class="citation" data-cites="Rosmist">@Rosmist</span> 辩经的时候，Rosmist 激情爆典：「悬线不就是可持久化单调栈吗？」</p><p>很有道理。容易发现单调栈在每一个 <span class="math inline">\(i\)</span> 时刻的栈内元素就是从 <span class="math inline">\(i\)</span> 开始往起始方向跳，经过的所有元素。由于悬线存储的数据是不会更改的，倒推回去我们可以知道，悬线存储了每个时刻的单调栈信息并有多个点共享前驱 / 后继，其实就是一种另类的可持久化单调栈，并且复杂度与单调栈本体相同。</p><hr /><h2 id="与笛卡尔树的关联">与笛卡尔树的关联</h2><p><em>upd on 240704</em>，学习了笛卡尔树。现在介绍悬线与笛卡尔树的关系。</p><p>容易发现元素 <span class="math inline">\(i\)</span> 的 <span class="math inline">\(l_i,r_i\)</span> 二值就是其在笛卡尔树上对应的区间。</p><p>更抽象的一点是悬线法中跳一跳的操作在笛卡尔树中的对应内涵。以小根堆为背景、在 <span class="math inline">\(l\)</span> 上向左跳为例，注意到该操作相当于从左到右向笛卡尔树中新增节点。</p><p>这也进一步验证了悬线法复杂度的正确性：我们都知道，在新加入节点时，若从树中提取出由根节点和其一直向右走直到节点不存在右儿子构成的链，则该点被添加到链中某一点的右儿子，该点原本的右子树（完整包含了链的剩余部分）成为新建节点的左子树。</p><p>而悬线实现的就是从链的最低点暴力爬山，直到找到合法点；而根据上面的结论，被枚举过的链上较低点不会作为新节点的右边的子孙，自然也不会再次被枚举到。</p><p>故而每个点最多被枚举到一次，得证。</p><p>进一步的，可以开发出悬线法 <span class="math inline">\(O(n)\)</span> 建笛卡尔树的方法：</p><p>每次求解完 <span class="math inline">\(l_i\)</span> 后，令 <span class="math inline">\(rc_{l_i-1}=i\)</span> 即可（当然 <span class="math inline">\(rc_{l_i-1}\)</span> 是会被多次更新的，这也是不直接用邻接表 / 前向星连边的原因），<span class="math inline">\(r_i\)</span> 与 <span class="math inline">\(lc\)</span> 同理。</p><pre class="cpp"><code>for (int i = 1; i &lt;= n; ++i) &#123;    l[i] = i;    while (l[i] != 1 &amp;&amp; a[l[i] - 1] &gt; a[i])        l[i] = l[l[i] - 1];    rc[l[i] - 1] = i;&#125;for (int i = n; i; --i) &#123;    r[i] = i;    while (r[i] != n &amp;&amp; a[r[i] + 1] &gt; a[i])        r[i] = r[r[i] + 1];    lc[r[i] + 1] = i;&#125;</code></pre><p>其中，根节点即为 <code>rc[0]</code> 或 <code>lc[n + 1]</code>。</p><hr /><p>进一步从笛卡尔树出发，探究悬线法能够循环内维护的数据特点。</p><p>为何是循环内维护？因为循环外维护就只能从左右的直接儿子进行更新，那和笛卡尔树就没有区别了。</p><p>但其实结果是没什么可探究的，因为其经过的节点——自己左子树下最右端链——实在不具有什么特殊性，它们所对应的区间——从 <span class="math inline">\([l_i, i - 1]\)</span> 到 <span class="math inline">\([i - 1, i - 1]\)</span> 也看不出什么值得研究的，更何况可以被笛卡尔树更具象地代替；如果你要从前缀最值的角度出发，那就没意思了，完全等价于单调栈。</p><p>所以我们认为这次悬线法的开发最终以失败告终，<del>不然它早被别人开发了</del>，我在此能给出的意见是，可以用悬线法完成矩形题目等不需要笛卡尔树树形结构的问题，至于其他，甚至包括上面提到的 <a href="/20231004">情景剧</a> 一题，都可以直接上笛卡尔树。</p><p>但笛卡尔树的建树我还是肯定会用悬线的！毕竟照应开头，我不会单调栈 <img src="/em/dy.gif" alt="得意" /></p>]]></content>
      
      
      
        <tags>
            
            <tag> 悬线法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【总结】斜率优化 DP</title>
      <link href="/20210214/"/>
      <url>/20210214/</url>
      
        <content type="html"><![CDATA[<p>于是，XSC062 开始写总结。</p><h2 id="斜率优化-dp">斜率优化 DP</h2><p><strong>前置芝士</strong></p><p><a href="https://www.cnblogs.com/XSC062/p/14383610.html">单调队列优化 DP</a></p><p><strong>正文</strong></p><p>我们以一道题为例。</p><h3 id="打印文章"><a href="http://acm.hdu.edu.cn/showproblem.php?pid=3507">打印文章</a></h3><p><a href="https://loj.ac/p/10191">双倍经验</a> | <a href="https://www.acwing.com/problem/content/1096/">三倍经验</a></p><h4 id="solution">Solution</h4><p>明显 DP。</p><p>那么 DP 式就是： <span class="math display">\[\begin{aligned}f_i&amp;=\min\{f_j+(s_i-s_j)^2+M\}\\&amp;=\min\{f_j+{s_i}^2-2\times s_i\times s_j+{s_j}^2+M\}\\&amp;=\min\{f_j-2\times s_i\times s_j+{s_j}^2\}+{s_i}^2+M\end{aligned}\]</span> 其中 <span class="math inline">\(s\)</span> 为 <span class="math inline">\(c\)</span> 的前缀和。</p><p>时间复杂度 <span class="math inline">\(\mathcal O(n^2)\)</span>，明显爆炸，所以我们需要优化。</p><p>在上一篇的 <a href="https://www.cnblogs.com/XSC062/p/14383610.html">单调队列优化DP</a> 中，我们提到过，只有 DP 式中的与 <span class="math inline">\(i\)</span> 有关的项能直接提出来时，我们才能使用单调队列优化，而这里的 <span class="math inline">\(s_i\)</span> 与 <span class="math inline">\(s_j\)</span> 相乘，无法使用单调队列优化。</p><p>我们思考，对于 <span class="math inline">\(f_i\)</span> 来说，无非就是选出最优的 <span class="math inline">\(j\)</span> 来构造它。</p><p>假设有 <span class="math inline">\(j\)</span> 与 <span class="math inline">\(k\)</span>，如何判断 <span class="math inline">\(j\)</span> 与 <span class="math inline">\(k\)</span> 谁更优呢？</p><p>我们先钦定 <span class="math inline">\(j\)</span> 优于 <span class="math inline">\(k\)</span>，且 <span class="math inline">\(j&lt;k\)</span>。</p><p>那么可以得到： <span class="math display">\[f_j-2\times s_i\times s_j+{s_j}^2+{s_i}^2+M&lt;f_k-2\times s_i\times s_k+{s_k}^2+{s_i}^2+M\]</span> 化简得： <span class="math display">\[f_j-2\times s_i\times s_j+{s_j}^2&lt;f_k-2\times s_i\times s_k+{s_k}^2\]</span> 再将<strong>只</strong>与 <span class="math inline">\(j,k\)</span> 有关的项放到左边，与 <span class="math inline">\(i\)</span> 有关的项放到右边： <span class="math display">\[f_j-f_k+{s_j}^2-{s_k}^2&lt;2\times s_i\times s_j-2\times s_i\times s_k\\f_j-f_k+{s_j}^2-{s_k}^2&lt;2\times s_i\times(s_j-s_k)\]</span> 左右两边同时 <span class="math inline">\(\div\)</span> 与 <span class="math inline">\(i\)</span> 无关的项 <span class="math inline">\(2\times(s_j-s_k)\)</span> ： <span class="math display">\[\dfrac{(f_j+{s_j}^2)-(f_k+{s_k}^2)}{(2\times s_j)-(2\times s_k)}&lt;s_i\]</span> 如果满足上式 ，则 <span class="math inline">\(j&lt;k\)</span> 且 <span class="math inline">\(j\)</span> 优于 <span class="math inline">\(k\)</span>。</p><p>接下来是斜率优化的重点部分。</p><blockquote><p>在义务教育阶段，学生学习了 <a href="https://baike.baidu.com/item/一次函数">一次函数</a>，它的几何意义表示为一条直线，一次项的系数就是直线的斜率，只不过当直线与 <span class="math inline">\(x\)</span> 轴垂直的时候无法表示。虽然没有明确给出斜率这个名词，但实际上思想已经渗透到其中。</p><p>直线对 <span class="math inline">\(x\)</span> 轴的倾斜角 <span class="math inline">\(\alpha\)</span> 的正切值 <span class="math inline">\(\tan\alpha\)</span> 称为该直线的“斜率”，并记作 <span class="math inline">\(k\)</span> ，公式为 <span class="math inline">\(k=\tan\alpha\)</span>。</p><p>即 <span class="math inline">\(k=\tan\alpha=\dfrac{\Delta y}{\Delta x}=\dfrac{y_2-y_1}{x_2-x_1}\)</span> 或 <span class="math inline">\(\dfrac{y_1-y_2}{x_1-x_2}\)</span> 。</p><p align="right">——选自 <a href="https://baike.baidu.com/item/%E6%96%9C%E7%8E%87/4914111?fr=aladdin">斜率_百度百科</a></p></blockquote><p>XSC062 看完了百度百科表示 <del>你 TM 在说些啥是不是欺负我六年义务教育的小学生</del> 恍然大悟</p><p>上面推出来的那个关于 <span class="math inline">\(j\)</span> 和 <span class="math inline">\(k\)</span> 的DP式，不就是求两个点 <span class="math inline">\((2\times s_j,f_j+{s_j}^2)\)</span> 和 <span class="math inline">\((2\times s_k,f_j+{s_k}^2)\)</span> 连成一条线之后的坡度吗？</p><p>本文后面的部分，<span class="math inline">\(x\)</span> 的含义会在「点<span class="math inline">\((2\times s_x,f_x+{s_x}^2)\)</span> 」和「下标 <span class="math inline">\(x\)</span> 」之间漂浮，请根据语境识别。</p><p>随后 XSC062 边打瞌睡边听 GM 讲课（特异功能），勉强算是明白了中心意思：</p><p>如图，假设有三个点 <span class="math inline">\(A,B,C\)</span>，以及 <span class="math inline">\(l_{AB}\)</span> 的斜率 <span class="math inline">\(k_1\)</span>，<span class="math inline">\(l_{BC}\)</span> 的斜率 <span class="math inline">\(k_2\)</span>。</p><figure><img src="https://img-blog.csdnimg.cn/img_convert/3bc5fea553ad6b06229ef9e9fa4c9664.png" alt="上凸" /><figcaption>上凸</figcaption></figure><p>我们暂且把这个向外凸起的奇怪玩意儿称为一个「上凸」。</p><p>回到前面的我们得到的那个结论：</p><blockquote><p><span class="math display">\[\dfrac{(f_j+{s_j}^2)-(f_k+{s_k}^2)}{(2\times s_j)-(2\times s_k)}&lt;s_i\]</span></p><p>如果满足上式 ，则 <span class="math inline">\(j&lt;k\)</span> 且 <span class="math inline">\(j\)</span> 优于 <span class="math inline">\(k\)</span>。</p></blockquote><p>简单记忆为：</p><ul><li>若 <span class="math inline">\(l_{NM}\)</span> 的斜率比 <span class="math inline">\(s_i\)</span> 小，则 <span class="math inline">\(N&lt;M\)</span> 且 <span class="math inline">\(N\)</span> 优于 <span class="math inline">\(M\)</span> 。</li><li>反之，若点 <span class="math inline">\(l_{NM}\)</span> 的斜率比 <span class="math inline">\(s_i\)</span> 大，则 <span class="math inline">\(M&lt;N\)</span> 且 <span class="math inline">\(M\)</span> 优于 <span class="math inline">\(N\)</span>。</li></ul><p>将 <span class="math inline">\(A,B\)</span> 代入，我们得知：</p><ol type="1"><li>若 <span class="math inline">\(k_1\leqslant s_i\)</span>，则 <span class="math inline">\(B\)</span> 优于 <span class="math inline">\(A\)</span>。</li><li>若 <span class="math inline">\(k_1&gt;s_i\)</span>，则 <span class="math inline">\(A\)</span> 优于 <span class="math inline">\(B\)</span>。</li><li>若 <span class="math inline">\(k_2\leqslant s_i\)</span>，则 <span class="math inline">\(C\)</span> 优于 <span class="math inline">\(B\)</span>。</li><li>若 <span class="math inline">\(k_2&gt;s_i\)</span>，则 <span class="math inline">\(B\)</span> 优于 <span class="math inline">\(C\)</span>。</li></ol><p>因为斜率 = 倾斜度 = 竖得有多高，明显 <span class="math inline">\(k_1&gt;k_2\)</span>。所以针对一个大小关系，<span class="math inline">\(k_1\)</span> 和 <span class="math inline">\(k_2\)</span> 之间只有可能有：</p><ol type="1"><li><span class="math inline">\(s_i&lt;k_2&lt;k_1\)</span>，此时 <span class="math inline">\(B\)</span> 优于 <span class="math inline">\(C\)</span>，<span class="math inline">\(A\)</span> 优于 <span class="math inline">\(B\)</span>，<span class="math inline">\(A\)</span> 为最优解。</li><li><span class="math inline">\(k_2&lt;s_i&lt;k_1\)</span>，此时 <span class="math inline">\(C\)</span> 优于 <span class="math inline">\(B\)</span>，<span class="math inline">\(A\)</span> 优于 <span class="math inline">\(B\)</span>，<span class="math inline">\(A,C\)</span> 为最优解。</li><li><span class="math inline">\(k_2&lt;k_1&lt;s_i\)</span>，此时 <span class="math inline">\(C\)</span> 优于 <span class="math inline">\(B\)</span>，<span class="math inline">\(B\)</span> 优于 <span class="math inline">\(A\)</span>，<span class="math inline">\(C\)</span> 为最优解。</li></ol><p>发现了吗？<span class="math inline">\(B\)</span> 永远都不可能是最优解。</p><p>所以如果我们要维护一个最优解的序列，就可以不要 <span class="math inline">\(B\)</span> 了。</p><figure><img src="0.png" alt="上凸" /><figcaption>上凸</figcaption></figure><p>那么，因为我们已经删掉了所有「上凸」的突起部分，所以这个最优解序列里肯定不会再存在「上凸」了。</p><p>如果是这样的「下凸」呢？</p><figure><img src="1.png" alt="下凸" /><figcaption>下凸</figcaption></figure><p><span class="math inline">\(k_1\)</span> 为 <span class="math inline">\(l_{AB}\)</span> 的斜率，<span class="math inline">\(k_2\)</span> 为 <span class="math inline">\(l_{BC}\)</span> 的斜率。</p><p>将 <span class="math inline">\(A,B\)</span> 代入，我们得知：</p><ol type="1"><li>若 <span class="math inline">\(k_1\leqslant s_i\)</span>，则 <span class="math inline">\(B\)</span> 优于 <span class="math inline">\(A\)</span>。</li><li>若 <span class="math inline">\(k_1&gt;s_i\)</span>，则 <span class="math inline">\(A\)</span> 优于 <span class="math inline">\(B\)</span>。</li><li>若 <span class="math inline">\(k_2\leqslant s_i\)</span>，则 <span class="math inline">\(C\)</span> 优于 <span class="math inline">\(B\)</span>。</li><li>若 <span class="math inline">\(k_2&gt;s_i\)</span>，则 <span class="math inline">\(B\)</span> 优于 <span class="math inline">\(C\)</span>。</li></ol><p>明显 <span class="math inline">\(k_1&lt;k_2\)</span>。所以 <span class="math inline">\(k_1\)</span> 和 <span class="math inline">\(k_2\)</span> 之间只有可能有：</p><ol type="1"><li><span class="math inline">\(s_i&lt;k_1&lt;k_2\)</span>，此时 <span class="math inline">\(B\)</span> 优于 <span class="math inline">\(C\)</span>，<span class="math inline">\(A\)</span> 优于 <span class="math inline">\(B\)</span>，<span class="math inline">\(A\)</span> 为最优解。</li><li><span class="math inline">\(k_1&lt;s_i&lt;k_2\)</span>，此时 <span class="math inline">\(B\)</span> 优于 <span class="math inline">\(C\)</span>，<span class="math inline">\(B\)</span> 优于 <span class="math inline">\(A\)</span>，<span class="math inline">\(B\)</span> 为最优解。</li><li><span class="math inline">\(k_1&lt;k_2&lt;s_i\)</span>，此时 <span class="math inline">\(C\)</span> 优于 <span class="math inline">\(B\)</span>，<span class="math inline">\(B\)</span> 优于 <span class="math inline">\(A\)</span>，<span class="math inline">\(C\)</span> 为最优解。</li></ol><p>所以，在下凸的情况中，三个点都有可能是最优解，都需要保留。</p><p>现在呢，所有上凸都被去掉了，只剩下凸，所以大概最后的最优解序列就长这个样子：</p><figure><img src="2.png" alt="下凸包" /><figcaption>下凸包</figcaption></figure><p><del>下 秃 包</del></p><p><del>反过来看就是 lifan 的脑袋了</del></p><p>观察发现，斜率是从左往右递增的。</p><p>所以，我们考虑用单调队列来当这个「最优解序列」。</p><h5 id="维护队头">维护队头</h5><p>即保证队头元素为最优解。</p><p>设队头为 <span class="math inline">\(q_l\)</span>。</p><p>如果 <span class="math inline">\(q_{l+1}\)</span> 与 <span class="math inline">\(q_l\)</span> 形成的斜率 <span class="math inline">\(\leqslant s_i\)</span>，根据上面推出来的玩意儿，得到 <span class="math inline">\(q_{l+1}\)</span> 优于 <span class="math inline">\(q_l\)</span>。</p><p>那还要 <span class="math inline">\(q_l\)</span> 干啥，直接 <code>l++</code>。</p><h5 id="更新-dp-值">更新 DP 值</h5><p><span class="math inline">\(f_i=f_{q_l}-2\times s_i\times s_{q_l}+{s_{q_l}}^2+{s_i}^2+M\)</span></p><h5 id="维护队尾">维护队尾</h5><p>即保证里面塞的点相邻两个的斜率递增。</p><p>设队尾为 <span class="math inline">\(q_r\)</span>，我们要往最优解队列里 <code>push</code> 一个 <span class="math inline">\(i\)</span> 。</p><p>若队尾两个点 <span class="math inline">\(q_r,q_{r-1}\)</span> 形成的斜率比 <span class="math inline">\(i,q_r\)</span> 形成的斜率大，那么<code>push(i)</code>后，整个队列的斜率就不再单调递增，所以此时要将<code>r--</code>。（因为 <a href="https://www.cnblogs.com/XSC062/p/14383610.html">上一篇关于单调队列的博客</a> 中讲到的 <span class="math inline">\(i\)</span> 必须入队，只能委屈一下 <span class="math inline">\(q_r\)</span> 了）</p><p><strong>注意事项</strong></p><p>众所周知，斜率是个浮点数。为了避免损失精度造成的一些惨案，我们交叉相乘，将分子、分母分开处理。</p><p>以及时刻都要保证队列中至少有两个点，因为要访问 <span class="math inline">\(q_l,q_{l+1}\)</span> 和 <span class="math inline">\(q_r,q_{r-1}\)</span>。</p><h4 id="code">Code</h4><pre class="cpp"><code>#include &lt;cstdio&gt;const int maxn = 5e5 + 5;int n, m, l, r;int f[maxn], c[maxn], q[maxn];inline int getDP(int i, int j) &#123;    return f[j] + m + (c[i] - c[j]) * (c[i] - c[j]);&#125;inline int getup(int j, int k)&#123;    return f[j] + c[j] * c[j] - f[k] - c[k] * c[k]; // 计算分子的值&#125;inline int getdown(int j, int k) &#123;    return (c[j] - c[k]) * 2; // 计算分母的值&#125;int main()&#123;    while (~scanf(&quot;%d %d&quot;, &amp;n, &amp;m)) &#123;        l = r = 1; // 凡是涉及到前缀和的单调队列，队列中必须存在初始 0        for (int i = 1; i &lt;= n; ++i) &#123;            scanf(&quot;%d&quot;, &amp;c[i]); // c 自给自足            c[i] += c[i - 1];            // # 维护队头            // 注意此处的条件为 l &lt; r，因为队列中至少需要存在两个点            while (l &lt; r &amp;&amp; getup(q[l+1], q[l]) &lt;= c[i] * getdown(q[l + 1],q[l]))                l++;            // # 转移状态            f[i] = getDP(i, q[l]);            // # 维护队尾            while(l &lt; r&amp;&amp; getup(i, q[r]) * getdown(q[r], q[r-1]) &lt;= getup(q[r] ,q[r - 1]) * getdown(i, q[r]))                r--;            q[++r] = i;        &#125;        printf(&quot;%d\n&quot;,f[n]);    &#125;    return 0;&#125;</code></pre><p>在对 DP 式变形时，我们最好将其化为 <span class="math inline">\(\dfrac{(j)-(k)}{(j)-(k)}&lt;x\)</span> 或 <span class="math inline">\(\dfrac{(j)-(k)}{(j)-(k)}&gt;x\)</span> 的形式。</p><p>这个板子只适用于维护下凸包的情况。当中间的符号为 <span class="math inline">\(&gt;\)</span> 时，我们会在这份代码上稍作改动，维护一个上凸包，后文会提到有关内容。</p><hr /><h3 id="玩具装箱"><a href="https://www.luogu.com.cn/problem/P3195">玩具装箱</a></h3><p><a href="https://loj.ac/p/10188">双倍经验</a> | <a href="https://www.acwing.com/problem/content/1094/">三倍经验</a></p><p>从今往后我们就只讲怎么推式子，不再证明下凸等性质了。</p><p>设 <span class="math inline">\(f_i\)</span> 表示第 <span class="math inline">\(i\)</span> 个玩具放完后的最小费用。 <span class="math display">\[f_i=\min\{f_j+(i-j-1+\sum\limits_{k=i}^jC_k-L)^2\}\]</span> 为了让这个式子好拆，我们在一开始让 <code>l++</code>，并且 <span class="math inline">\(C\)</span> 再次自给自足，为输入的 <span class="math inline">\(C\)</span> 的前缀和数组。</p><p>于是式子就变成： <span class="math display">\[f_i=\min\{f_j+(i-j-L+C_i-C_j)^2\}\]</span> 明显硬拆会死人。（反正我试过，比较适合用来发泄</p><p>所以我们把式子变成这样： <span class="math display">\[f_i=\min\{f_j+((C_i+i)-(C_j+j)-L)^2\}\]</span> 既然 <span class="math inline">\(C_i\)</span> 与 <span class="math inline">\(i\)</span>，<span class="math inline">\(C_j\)</span> 与 <span class="math inline">\(j\)</span> 是对应的，那么直接预处理，给 <span class="math inline">\(C_i\)</span> 加上 <span class="math inline">\(i\)</span> 不就行了？</p><p>现在这个 <span class="math inline">\(C_i\)</span> 的含义和实现就变得有点曲折难懂了。</p><p>具体实现如下：</p><pre class="cpp"><code>for (int i = 1; i &lt;= n; ++i) &#123;    scanf(&quot;%lld&quot;, &amp;c[i]);    c[i] += c[i - 1];&#125;for (int i = 1; i &lt;= n; ++i)    c[i] += i;</code></pre><p>也就是说，<span class="math inline">\(C_i\)</span> 是在前缀和的基础上加了一个 <span class="math inline">\(i\)</span>，注意不能把 <span class="math inline">\(i\)</span> 也一起前缀和了。</p><p>然后式子就变成了这样： <span class="math display">\[\begin{aligned}f_i&amp;=\min\{f_j+(C_i-C_j-L)^2\}\\&amp;=\min\{f_j+{C_i}^2+{C_j}^2+L^2-2\times C_i\times C_j-2\times C_i\times L+2\times C_j\times L\}\\&amp;=\min\{f_j+{C_j}^2-2\times C_i\times C_j+2\times C_j\times L\}+{C_i}^2+L^2-2\times C_i\times L\end{aligned}\]</span></p><p>令 <span class="math inline">\(j\)</span> 优于 <span class="math inline">\(k\)</span> 且 <span class="math inline">\(j&lt;k\)</span>。</p><p>得： <span class="math display">\[f_j+{C_j}^2-2\times C_i\times C_j+2\times C_j\times L&lt;f_k+{C_k}^2-2\times C_i\times C_k+2\times C_k\times L\\f_j-f_k+{C_j}^2-{C_k}^2+2\times C_j\times L-2\times C_k\times L&lt;2\times C_i\times C_j-2\times C_i\times C_k\\f_j-f_k+{C_j}^2-{C_k}^2+2\times C_j\times L-2\times C_k\times L&lt;2\times(C_j-C_k)\times C_i\\\dfrac{f_j-f_k+{C_j}^2-{C_k}^2}{2\times(C_j-C_k)}&lt;C_i\\\dfrac{(f_j+{C_j}^2)-(f_k+{C_k}^2)}{(2\times C_j)-(2\times C_k)}&lt;C_i\]</span></p><pre class="cpp"><code>#include &lt;cstdio&gt;#define int long longconst int maxn = 5e5 + 5;const int LEN = (1 &lt;&lt; 20);int n, m, h, t;int c[maxn], q[maxn], f[maxn];#define nec getcharinline bool read(int &amp;x) &#123;    char ch = nec();    bool f = 0; x = 0;    while (ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123;        if (ch == EOF) return 0;        if (ch == &#39;-&#39;) f = 1; ch = nec();    &#125;    while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) &#123;        x = x * 10 + ch - &#39;0&#39;;        ch = nec();    &#125;    if (f) x = -x;    return 1;&#125;inline int getup(int j, int k) &#123;    return (f[j] + c[j] * c[j] + 2 * c[j] * m)           - (f[k] + c[k] * c[k] + 2 * c[k] * m);&#125;inline int getdown(int j, int k) &#123;    return (2 * c[j]) - (2 * c[k]);&#125;inline int getDP(int i, int j) &#123;    return f[j] + (c[i] - c[j] - m) * (c[i] - c[j] - m);&#125;signed main() &#123;    read(n); read(m); h = t = 1; ++m;    for (int i = 1; i &lt;= n; ++i)        read(c[i]), c[i] += c[i - 1];    for (int i = 1; i &lt;= n; ++i) &#123;        c[i] += i;        while (h &lt; t &amp;&amp; getup(q[h + 1], q[h]) &lt;               c[i] * getdown(q[h + 1], q[h])) ++h;        f[i] = getDP(i, q[h]);        while (h &lt; t               &amp;&amp; getup(i, q[t]) * getdown(q[t], q[t - 1]) &lt;=               getdown(i, q[t]) * getup(q[t], q[t - 1])) --t;        q[++t] = i;    &#125;    printf(&quot;%lld&quot;, f[n]);    return 0;&#125;</code></pre><hr /><h3 id="任务安排-1"><a href="https://loj.ac/p/10184">任务安排 1</a></h3><p><a href="https://www.acwing.com/problem/content/302/">双倍经验</a> | <a href="https://www.luogu.com.cn/problem/P2365">三倍经验</a></p><p>感谢蓝书。这里按着蓝书上的思维走。</p><h4 id="解法一">解法一</h4><p>暴力。</p><p>此处的 <span class="math inline">\(t,c\)</span> 为输入的 <span class="math inline">\(t,c\)</span> 的前缀和数组。</p><p>设 <span class="math inline">\(f_{i,j}\)</span> 为前 <span class="math inline">\(i\)</span> 个任务分成 <span class="math inline">\(j\)</span> 批的最小费用。</p><p>故 <span class="math inline">\(S\times j+t_i\)</span> 为第 <span class="math inline">\(i\)</span> 个任务的完成时间。</p><p>得出状态转移方程（<span class="math inline">\(k\)</span> 枚举上一批任务结束位置）： <span class="math display">\[f_{i,j}=\min\limits_{0\leqslant k&lt;i}\{f_{k,j-1}+(S\times j+t_i)\times(c_i-c_k)\}\]</span> 时间复杂度 <span class="math inline">\(\mathcal O(n^3)\)</span>。</p><pre class="cpp"><code>#include &lt;cstdio&gt;#include &lt;cstring&gt;#define int long longconst int inf = 1e18;const int maxn = 5005;const int LEN = (1 &lt;&lt; 20);int f[maxn][maxn];int n, s, ans = inf;int t[maxn], c[maxn];inline int min(int x, int y) &#123; return x &lt; y ? x : y; &#125;#ifdef ONLINE_JUDGEinline int nec(void) &#123;    static char buf[LEN], *p = buf, *e = buf;    if (p == e) &#123;        e = buf + fread(buf, 1, LEN, stdin);        if (e == buf) return EOF; p = buf;    &#125;    return *p++;&#125;#else#define nec getchar#endifinline bool read(int &amp;x) &#123;    char ch = nec();    bool f = 0; x = 0;    while (ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123;        if (ch == EOF) return 0;        if (ch == &#39;-&#39;) f = 1;        ch = nec();    &#125;    while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) &#123;        x = x * 10 + ch - &#39;0&#39;;        ch = nec();    &#125;    if (f) x = -x;    return 1;&#125;signed main() &#123;    read(n); read(s);    memset(f, 0x3f, sizeof (f));    for (int i = 1; i &lt;= n; ++i) &#123;        read(t[i]); read(c[i]);        t[i] += t[i - 1];        c[i] += c[i - 1];        f[i][1] = (s + t[i]) * c[i]; // 初始化    &#125;    for (int i = 2; i &lt;= n; ++i) &#123;        for (int j = 2; j &lt;= i; ++j) &#123;            for (int k = 1; k &lt; i; ++k)                f[i][j] = min(f[i][j], f[k][j - 1] + (t[i] + s * j) * (c[i] - c[k]));        &#125;    &#125;    for (int i = 1; i &lt;= n; ++i)        ans = min(ans, f[n][i]);    printf(&quot;%lld&quot;, ans);    return 0;&#125;</code></pre><p><del>亲测 TLE 70</del></p><h4 id="解法二">解法二</h4><p>脑子炸了，想了好久才想明白这个优化的正确性。</p><p>思考，以上代码需要 <span class="math inline">\(j\)</span> 这一维的根本原因是什么？</p><p>因为我们无法确定之前已经划分了多少批，也就是无法确定 <span class="math inline">\(S\)</span> 的个数。</p><p>换个角度思考，我们无法确定之前，却可以确定之后。</p><p>什么意思呢？如果我们在任务 <span class="math inline">\(i\)</span> 处划分，那么任务 <span class="math inline">\(i\)</span> 以及任务 <span class="math inline">\(i\)</span> 以后的所有任务的执行时间都会延后 <span class="math inline">\(S\)</span>。</p><p>因为 <span class="math inline">\(i\)</span> 以后的状态也会使用 <span class="math inline">\(f_i\)</span> 的值，我们在计算 <span class="math inline">\(f_i\)</span> 时就将 <span class="math inline">\(S\)</span> 提出来，提前把后面的 <span class="math inline">\(c\)</span> 乘上不就行了？</p><p>中间的结果不对劲也无所谓，只要最后的答案是对的就行了。</p><blockquote><p>也就是说，我们没有直接求出每批任务的完成时刻，而是在一批任务<strong>「开始」</strong>对后续任务产生影响时，就先把费用累加到答案中。这是一种名为<strong>「费用提前计算」</strong>的经典思想。</p><p align="right">——李煜东《算法竞赛进阶指南》</p></blockquote><p>状态转移方程： <span class="math display">\[f_i=\min\limits_{0\leqslant j&lt;i}\{f_j+(c_i-c_j)\times t_i+s\times(c_n-c_j)\}\]</span> 此处，<span class="math inline">\(f_i\)</span> 没有具体含义。</p><pre class="cpp"><code>#include &lt;cstdio&gt;#include &lt;cstring&gt;#define int long longconst int maxn = 1e4 + 5;const int LEN = (1 &lt;&lt; 20);int n, s;int f[maxn], t[maxn], c[maxn];inline int min(int x, int y) &#123; return x &lt; y ? x : y; &#125;#ifdef ONLINE_JUDGEinline int nec(void) &#123;    static char buf[LEN], *p = buf, *e = buf;    if (p == e) &#123;        e = buf + fread(buf, 1, LEN, stdin);        if (e == buf) return EOF; p = buf;    &#125;    return *p++;&#125;#else#define nec getchar#endifinline bool read(int &amp;x) &#123;    char ch = nec();    bool f = 0; x = 0;    while (ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123;        if (ch == EOF) return 0;        if (ch == &#39;-&#39;) f = 1;        ch = nec();    &#125;    while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) &#123;        x = x * 10 + ch - &#39;0&#39;;        ch = nec();    &#125;    if (f) x = -x;    return 1;&#125;signed main() &#123;    read(n); read(s);    memset(f, 0x3f, sizeof (f));    for (int i = 1; i &lt;= n; ++i) &#123;        read(t[i]); read(c[i]);        t[i] += t[i - 1];        c[i] += c[i - 1];    &#125;    f[0] = 0;    for (int i = 1; i &lt;= n; ++i) &#123;        for (int j = 0; j &lt; i; ++j)            f[i] = min(f[i], f[j] + t[i]* (c[i] - c[j]) + s * (c[n] - c[j]));    &#125;    printf(&quot;%lld&quot;, f[n]);    return 0;&#125;</code></pre><hr /><h3 id="任务安排-2"><a href="https://loj.ac/p/10185">任务安排 2</a></h3><p><a href="https://www.acwing.com/problem/content/303/">双倍经验</a></p><p><span class="math inline">\(n\)</span> 的范围变大了，<span class="math inline">\(n^2\)</span> 过不了。</p><p>这不随手加个斜率优化的事儿吗。</p><p>我们继续瞎搞这个式子。 <span class="math display">\[\begin{aligned}f_i&amp;=\min\{f_j+(c_i-c_j)\times t_i+s\times(c_n-c_j)\}\\&amp;=\min\{f_j+c_i\times t_i-c_j\times t_i+s\times c_n-s\times c_j\}\\&amp;=\min\{f_j-c_j\times t_i-s\times c_j\}+c_i\times t_i+s\times c_n\end{aligned}\]</span> 令 <span class="math inline">\(j\)</span> 优于 <span class="math inline">\(k\)</span> 且 <span class="math inline">\(j&lt;k\)</span> 。</p><p>则有： <span class="math display">\[f_j-c_j\times t_i-s\times c_j&lt;f_k-c_k\times t_i-s\times c_k\\f_j-f_k-s\times c_j+s\times c_k&lt;c_j\times t_i-c_k\times t_i\\f_j-f_k-s\times c_j+s\times c_k&lt;t_i\times(c_j-c_k)\\\dfrac{(f_j-s\times c_j)-(f_k-s\times c_k)}{(c_j)-(c_k)}&lt;t_i\]</span> 然后就是老套路。</p><p>时间复杂度 <span class="math inline">\(\mathcal O(n)\)</span>。</p><pre class="cpp"><code>#include &lt;cstdio&gt;#define int long longconst int maxn = 5e5 + 5;const int LEN = (1 &lt;&lt; 20);int n, s, L, R;int f[maxn], t[maxn], c[maxn], q[maxn];#define nec getcharinline bool read(int &amp;x) &#123;    char ch = nec();    bool f = 0; x = 0;    while (ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123;        if (ch == EOF) return 0;        if (ch == &#39;-&#39;) f = 1; ch = nec();    &#125;    while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) &#123;        x = x * 10 + ch - &#39;0&#39;;        ch = nec();    &#125;    if (f) x = -x;    return 1;&#125;inline int getup(int j, int k) &#123; return (f[j] - s * c[j]) - (f[k] - s * c[k]); &#125;inline int getdown(int j, int k) &#123; return (c[j]) - (c[k]); &#125;inline int getDP(int i, int j) &#123; return f[j] + (c[i] - c[j]) * t[i] + s * (c[n] - c[j]); &#125;signed main() &#123;    read(n); read(s);    L = R = 1;    for (int i = 1; i &lt;= n; ++i) &#123;        read(t[i]); read(c[i]);        t[i] += t[i - 1];        c[i] += c[i - 1];    &#125;    for (int i = 1; i &lt;= n; ++i) &#123;        while (L &lt; R &amp;&amp; getup(q[L + 1], q[L]) &lt;= t[i] * getdown(q[L + 1], q[L]))            ++L;        f[i] = getDP(i, q[L]);        while (L &lt; R &amp;&amp; getup(i, q[R]) * getdown(q[R], q[R - 1]) &lt;= getdown(i, q[R]) * getup(q[R], q[R - 1]))            --R;        q[++R] = i;    &#125;    printf(&quot;%lld&quot;, f[n]);    return 0;&#125;</code></pre><hr /><h3 id="任务安排-3"><a href="https://www.luogu.com.cn/problem/P5785">任务安排 3</a></h3><p><a href="https://loj.ac/p/10186">双倍经验</a> | <a href="https://www.acwing.com/problem/content/304/">三倍经验</a></p><p>注意 <span class="math inline">\(t\)</span> 有可能是负数。</p><p><span class="math inline">\(t\)</span> （输入）有可能为负，代表着 <span class="math inline">\(t\)</span>（前缀和）不再单调递增，用不单调的对象作为单调队列的条件一看就十分不讲武德，这样维护出来的队头显然不是正确答案。</p><p>后面的 <span class="math inline">\(t,c\)</span> 默认为前缀和。</p><p>我们感性证明一下。</p><p>一个最普通的例子，假设输入了一个负数，导致 <span class="math inline">\(t_i&lt;t_{i-1}\)</span>，且有一斜率 <span class="math inline">\(&gt;t_i\)</span> 且 <span class="math inline">\(&lt;t_{i-1}\)</span>。</p><p>那么在 <span class="math inline">\(i-1\)</span> 时，它就被维护队头的操作剔掉了，但也许它凑巧就是 <span class="math inline">\(i\)</span> 的最优解，呜呼哀哉。</p><p>于是我们不能删队头元素了。那怎么查询最优解呢？</p><p>单调队列里装的始终还是个具有单调性的下凸包，于是我们可以在队列中二分一个 <span class="math inline">\(pos\)</span>，<span class="math inline">\(pos\)</span> 与 <span class="math inline">\(pos-1\)</span> 形成的斜率比 <span class="math inline">\(t_i\)</span> 小，<span class="math inline">\(pos+1\)</span> 与 <span class="math inline">\(pos\)</span> 形成的斜率比 <span class="math inline">\(t_i\)</span> 大。</p><p>然后把 <span class="math inline">\(pos\)</span> 当成 <span class="math inline">\(q_l\)</span> 来处理就好了。</p><p>队尾还是维护一个下凸。</p><p>时间复杂度 <span class="math inline">\(\mathcal O(n\log_2n)\)</span>。</p><p><em>强烈建议不要去动 AcWing 版本的那道。</em></p><p><em>最后两组数据堪称毒瘤。</em></p><p><em>卡 <code>long long</code> 乘法，卡 <code>__int128</code> 时限，卡 <code>double</code>精度，非 T 即 WA。</em></p><p><em>反正我搞了半个小时硬是没有搞出来。</em></p><pre class="cpp"><code>#include &lt;cstdio&gt;#define int long longconst int maxn = 3e5 + 5;const int LEN = (1 &lt;&lt; 20);int n, s, L, R;int f[maxn], t[maxn], c[maxn], q[maxn];#define nec getcharinline bool read(int &amp;x) &#123;    char ch = nec();    bool f = 0; x = 0;    while (ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123;        if (ch == EOF) return 0;        if (ch == &#39;-&#39;) f = 1; ch = nec();    &#125;    while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) &#123;        x = x * 10 + ch - &#39;0&#39;;        ch = nec();    &#125;    if (f) x = -x;    return 1;&#125;inline int getup(int j, int k) &#123; return (f[j] - s * c[j]) - (f[k] - s * c[k]); &#125;inline int getdown(int j, int k) &#123; return (c[j]) - (c[k]); &#125;inline int getDP(int i, int j) &#123; return f[j] + t[i] * (c[i] - c[j]) + s * (c[n] - c[j]); &#125;inline int Func(int u) &#123;    if (L == R) return q[L];    int l = L, r = R;    while (l &lt; r) &#123;        int mid = l + r &gt;&gt; 1;        if (getup(q[mid + 1], q[mid]) &lt;= u * getdown(q[mid + 1], q[mid]))            l = mid + 1;        else r = mid;    &#125;    return l;&#125;signed main() &#123;    read(n); read(s);    L = R = 1;    for (int i = 1; i &lt;= n; ++i) &#123;        read(t[i]); read(c[i]);        t[i] += t[i - 1];        c[i] += c[i - 1];    &#125;    for (int i = 1; i &lt;= n; ++i) &#123;        int Best = Func(t[i]);        f[i] = getDP(i, q[Best]);        while (L &lt; R &amp;&amp; getup(i, q[R]) * getdown(q[R], q[R - 1]) &lt;= getdown(i, q[R]) * getup(q[R], q[R - 1]))            --R;        q[++R] = i;    &#125;    printf(&quot;%lld&quot;, f[n]);    return 0;&#125;</code></pre><hr /><h3 id="土地购买"><a href="https://www.luogu.com.cn/problem/P2900">土地购买</a></h3><p>首先我们想明白一件事情：如果一块土地，有另一块土地的长和宽都比它大，那就不用再理它了，直接从总序列里剔除。</p><pre class="cpp"><code>struct _ &#123;    int w, l;    bool operator&lt; (const _ q) const &#123;        return w == q.w ? l &gt; q.l : w &gt; q.w;    &#125;&#125; a[maxn];...std::sort(a + 1, a + n + 1);for (int i = 1; i &lt;= n; ++i) &#123;    if (a[i].l &gt; a[cnt].l)        a[++cnt] = a[i];&#125;</code></pre><p>然后就推式子。</p><p>贪心地想，在前面的操作后，<span class="math inline">\(a\)</span> 是一个 <span class="math inline">\(w\)</span> 递减，<span class="math inline">\(l\)</span> 递增的土地序列。</p><p>所以我们选择将连续的一段区间分为一组，这样的话，一个组里的一段连续的土地 <span class="math inline">\([x,y]\)</span> 就只有 <span class="math inline">\(w_x\)</span> 和 <span class="math inline">\(l_y\)</span> 起了作用，又没有中间那一段的事了。</p><p>设 <span class="math inline">\(f_i\)</span> 表示分配完第 <span class="math inline">\(i\)</span> 块土地后的最小花费。</p><p>则有： <span class="math display">\[f_i=\min\{f_j+w_{j+1}\times l_i\}\]</span> 令 <span class="math inline">\(j\)</span> 优于 <span class="math inline">\(k\)</span>。</p><p>则有： <span class="math display">\[f_j+w_{j+1}\times l_i&lt;f_k+w_{k+1}\times l_i\\f_j-f_k&lt;(-w_{j+1}+w_{k+1})\times l_i\\\dfrac{(f_j)-(f_k)}{(-w_{j+1})+(w_{k+1})}&lt;l_i\]</span></p><pre class="cpp"><code>#include &lt;cstdio&gt;#include &lt;algorithm&gt;#define int long longconst int maxn = 5e4 + 5;struct _ &#123;    int w, l;    bool operator&lt; (const _ q) const&#123;        return w == q.w ? l &gt; q.l : w &gt; q.w;    &#125;&#125;;_ a[maxn];int n, cnt, l, r;int q[maxn], f[maxn];int getup(int j, int k) &#123; return f[j] - f[k]; &#125;int getdown(int j,int k) &#123; return a[k + 1].w - a[j + 1].w; &#125;int getDP(int i,int j) &#123; return f[j] + a[j + 1].w * a[i].l; &#125;signed main() &#123;    scanf(&quot;%lld&quot;, &amp;n);    for(int i = 1; i &lt;= n; ++i)        scanf(&quot;%lld %lld&quot;, &amp;a[i].w, &amp;a[i].l);    std::sort(a + 1, a + n + 1);    for (int i = 1; i &lt;= n; ++i) &#123;        if (a[i].l &gt; a[cnt].l)            a[++cnt] = a[i];    &#125;    n = cnt; l = r = 1;    for (int i = 1; i &lt;= n; ++i) &#123;        while (l &lt; r &amp;&amp; getup(q[l + 1], q[l]) &lt;= a[i].l * getdown(q[l + 1], q[l]))            l++;        f[i] = getDP(i, q[l]);        while (l &lt; r &amp;&amp; getup(i, q[r]) * getdown(q[r], q[r - 1]) &lt;= getup(q[r],q[r - 1]) * getdown(i, q[r]))            r--;        q[++r] = i;    &#125;    printf(&quot;%lld&quot;, f[n]);    return 0;&#125;</code></pre><hr /><h3 id="仓库建设"><a href="https://www.luogu.com.cn/problem/P2120">仓库建设</a></h3><p><a href="https://loj.ac/p/10189">双倍经验</a> | <a href="https://www.acwing.com/problem/content/description/1095/">三倍经验</a></p><p>设 <span class="math inline">\(f_i\)</span> 表示在 <span class="math inline">\(i\)</span> 工厂建立仓库的最小花费。</p><p>则有： <span class="math display">\[\begin{aligned}f_i&amp;=\min\{f_j+\sum\limits_{k=j+1}^{i-1}[(x_i-x_k)\times p_k]+c_i\}\\&amp;=\min\{f_j+\sum\limits_{k=j+1}^{i-1}(x_i\times p_k)-\sum\limits_{k=j+1}^{i-1}(x_k\times p_k)\}+c_i\\&amp;=\min\{f_j+x_i\times\sum\limits_{k=j+1}^{i-1}p_k-\sum\limits_{k=j+1}^{i-1}(x_k\times p_k)\}+c_i\end{aligned}\]</span> 利用前缀和优化：设 <span class="math inline">\(a\)</span> 为 <span class="math inline">\(p\)</span> 的前缀和数组，<span class="math inline">\(b\)</span> 为 <span class="math inline">\(x_i\times p_i\)</span> 的前缀和数组。</p><p>则原式可化为： <span class="math display">\[\begin{aligned}f_i&amp;=\min\{f_j+x_i\times(a_{i-1}-a_j)-(b_{i-1}-b_j)\}+c_i\\&amp;=\min\{f_j+x_i\times a_{i-1}-x_i\times a_j-b_{i-1}+b_j\}+c_i\\&amp;=\min\{f_j-x_i\times a_j+b_j\}+x_i\times a_{i-1}-b_{i-1}+c_i\end{aligned}\]</span> 令 <span class="math inline">\(j\)</span> 优于 <span class="math inline">\(k\)</span> 。</p><p>则有： <span class="math display">\[f_j-x_i\times a_j+b_j&lt;f_k-x_i\times a_k+b_k\\f_j-f_k+b_j-b_k&lt;x_i\times a_j-x_i\times a_k\\\dfrac{(f_j+b_j)-(f_k+b_k)}{a_j-a_k}&lt;x_i\]</span></p><p><em>想感受人生的同学们可以尝试做一下 AcWing 那个版本，非 MLE 即 WA，爽到炸。</em></p><pre class="cpp"><code>#include &lt;cstdio&gt;#define int long longconst int maxn = 1e6 + 5;const int LEN = (1 &lt;&lt; 20);int n, L, R;int f[maxn], x[maxn], p[maxn];int a[maxn], b[maxn], c[maxn], q[maxn];#ifdef ONLINE_JUDGEinline int nec(void) &#123;    static char buf[LEN], *p = buf, *e = buf;    if (p == e) &#123;        e = buf + fread(buf, 1, LEN, stdin);        if (e == buf) return EOF; p = buf;    &#125;    return *p++;&#125;#else#define nec getchar#endifinline bool read(int &amp;x) &#123;    char ch = nec();    bool f = 0; x = 0;    while (ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123;        if (ch == EOF) return 0;        if (ch == &#39;-&#39;) f = 1;        ch = nec();    &#125;    while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) &#123;        x = x * 10 + ch - &#39;0&#39;;        ch = nec();    &#125;    if (f) x = -x;    return 1;&#125;inline int getup(int j, int k) &#123; return (f[j] + b[j]) - (f[k] + b[k]); &#125;inline int getdown(int j, int k) &#123; return (a[j]) - (a[k]); &#125;inline int getDP(int i, int j) &#123; return f[j] - x[i] * a[j] + b[j] + x[i] * a[i - 1] - b[i - 1] + c[i]; &#125;signed main() &#123;    read(n); L = R = 1;    for (int i = 1; i &lt;= n; ++i) &#123;        read(x[i]); read(p[i]); read(c[i]);        a[i] = a[i - 1] + p[i];        b[i] = b[i - 1] + x[i] * p[i];    &#125;    for (int i = 1; i &lt;= n; ++i) &#123;        while (L &lt; R &amp;&amp; getup(q[L + 1], q[L]) &lt;= x[i] * getdown(q[L + 1], q[L]))            ++L;        f[i] = getDP(i, q[L]);        while (L &lt; R &amp;&amp; getup(i, q[R]) * getdown(q[R], q[R - 1]) &lt;= getdown(i, q[R]) * getup(q[R], q[R - 1]))            --R;        q[++R] = i;    &#125;    printf(&quot;%lld&quot;, f[n]);    return 0;&#125;</code></pre><hr /><h3 id="锯木厂选址"><a href="https://www.luogu.com.cn/problem/P4360">锯木厂选址</a></h3><p><a href="https://loj.ac/p/10192">双倍经验</a> | <a href="https://www.acwing.com/problem/content/1097/">三倍经验</a></p><p>和仓库建设很像。</p><p>设 <span class="math inline">\(A_i=\sum\limits_{j=i}^nd_j\)</span>，表示第 <span class="math inline">\(i\)</span> 棵树与山脚的距离；<span class="math inline">\(B_i=\sum\limits_{j=1}^iw_j\)</span>，表示 <span class="math inline">\(w\)</span> 的前缀和；<span class="math inline">\(S=\sum\limits_{i=1}^nA_i\times w_i\)</span>，表示将所有树全部运到山脚的花费总和。</p><p>假设在 <span class="math inline">\(j\)</span> 处建立第 <span class="math inline">\(1\)</span> 座锯木厂，在 <span class="math inline">\(i\)</span> 处建立第 <span class="math inline">\(2\)</span> 座锯木厂，此时：</p><ul><li>对于第 <span class="math inline">\(1\sim j\)</span> 棵树来说，<span class="math inline">\(S\)</span> 比实际情况多运了 <span class="math inline">\(A_j\)</span> 的路程；</li><li>对于第 <span class="math inline">\(j+1\sim i\)</span> 棵树来说，<span class="math inline">\(S\)</span> 比实际情况多运了 <span class="math inline">\(A_i\)</span> 的路程。</li></ul><p>将对应的多运的距离与花费相乘的结果，让 <span class="math inline">\(S\)</span> 将其减去即可。 <span class="math display">\[\begin{aligned}ans&amp;=\min\{S-A_j\times B_j-(B_i-B_j)\times A_i\}\\   &amp;=\min\{A_i\times B_j-A_j\times B_j\}+S-A_i\times B_i\end{aligned}\]</span> 令 <span class="math inline">\(j&lt;k\)</span> 且 <span class="math inline">\(j\)</span> 优于 <span class="math inline">\(k\)</span>，则有： <span class="math display">\[\begin{aligned}A_i\times B_j-A_j\times B_j&amp;&lt;A_i\times B_k-A_k\times B_k\\-A_j\times B_j+A_k\times B_k&amp;&lt;-A_i\times B_j+A_i\times B_k\\\dfrac{-A_j\times B_j+A_k\times B_k}{-B_j+B_k}&amp;&lt;A_i\\\dfrac{A_j\times B_j-A_k\times B_k}{B_j-B_k}&amp;&lt;A_i\\\end{aligned}\]</span> 其中，<span class="math inline">\(A_i\)</span> 具有单调性，可以直接套板子。</p><pre class="cpp"><code>#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#define int long longconst int inf = 1e18;const int maxn = 1e6 + 5;const int LEN = (1 &lt;&lt; 20);int w[maxn], d[maxn];int n, L, R, s, ans = inf;int q[maxn], a[maxn], b[maxn];inline int min(int x, int y) &#123; return x &lt; y ? x : y; &#125;inline int getDP(int i, int j) &#123;    return s - a[j] * b[j] - (b[i] - b[j]) * a[i];&#125;inline int getup(int j, int k) &#123;    return a[j] * b[j] - a[k] * b[k];&#125;inline int getdown(int j, int k) &#123;    return b[j] - b[k];&#125;#ifdef ONLINE_JUDGEinline int nec(void) &#123;    static char buf[LEN], *p = buf, *e = buf;    if (p == e) &#123;        e = buf + fread(buf, 1, LEN, stdin);        if (e == buf) return EOF; p = buf;    &#125;    return *p++;&#125;#else#define nec getchar#endifinline bool read(int &amp;x) &#123;    char ch = nec();    bool f = 0; x = 0;    while (ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123;        if (ch == EOF) return 0;        if (ch == &#39;-&#39;) f = 1;        ch = nec();    &#125;    while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) &#123;        x = x * 10 + ch - &#39;0&#39;;        ch = nec();    &#125;    if (f) x = -x;    return 1;&#125;signed main() &#123;    read(n);    L = R = 1;    for (int i = 1; i &lt;= n; ++i) &#123;        read(w[i]), read(d[i]);        b[i] = b[i - 1] + w[i];    &#125;    for (int i = n; i; --i) &#123;        a[i] = a[i + 1] + d[i];        s += a[i] * w[i];    &#125;    for (int i = 1; i &lt;= n; ++i) &#123;        while (L &lt; R &amp;&amp; getup(q[L + 1], q[L]) &gt;= a[i] * getdown(q[L + 1], q[L]))            ++L;        ans = min(ans, getDP(i, q[L]));        while (L &lt; R &amp;&amp; getup(i, q[R]) * getdown(q[R], q[R - 1]) &gt;= getup(q[R], q[R - 1]) * getdown(i, q[R]))            --R;        q[++R] = i;    &#125;    printf(&quot;%lld&quot;, ans);    return 0;&#125;</code></pre><hr /><h3 id="cats-transport"><a href="https://www.luogu.com.cn/problem/CF311B">Cats Transport</a></h3><p><a href="https://www.acwing.com/problem/content/305/">双倍经验</a> | <a href="http://codeforces.com/problemset/problem/311/B">三倍经验</a></p><p>经验：洛谷的题面比蓝书和 AcWing 上的标准多了，蓝书的题意不清。</p><p>研究表明，边猛灌养乐多边看蓝书有助于理解。</p><p>这道题难在推式子。<del>不然还能难在哪里</del></p><p>设 <span class="math inline">\(A_i\)</span> 表示要接到第 <span class="math inline">\(i\)</span> 只猫的最早出发时间，也就是说，在此时出发，猫 <span class="math inline">\(i\)</span> 的等待时间为 <span class="math inline">\(0\)</span>。</p><p>即 <span class="math inline">\(A_i=T_i-\sum\limits_{j=1}^{H_i}D_j\)</span>，也就是出发时间=到达时间-经过时间。</p><p>此时我们可以把其他所有因素去掉，题意转换为：</p><blockquote><p>已知在 <span class="math inline">\(\geqslant A_i\)</span> 的时刻出发可以接到猫 <span class="math inline">\(i\)</span> ，在 <span class="math inline">\(P\)</span> 次出发次数的限制内接到所有猫，猫的等待时间之和最小是多少？</p></blockquote><p>假设饲养员在 <span class="math inline">\(t\)</span> 时刻出发，猫 <span class="math inline">\(i\)</span> 的等待时间就是 <span class="math inline">\(t-A_i\)</span>。</p><p>对 <span class="math inline">\(A_i\)</span> 从小到大排序。</p><p>显然，一次接一段连续的猫，花费自然是最小的。</p><p>若我们要接 <span class="math inline">\([k+1,j]\)</span> 范围内的猫，它们的等待时间之和就是： <span class="math display">\[\begin{aligned}\sum\limits_{p=k+1}^{j}(A_j-A_p)&amp;=[j-(k+1)+1]A_j-\sum\limits_{p=k+1}^{j}A_p\\&amp;=(j-k)\times A_j-(S_j-S_k)\\&amp;=j\times A_j-k\times A_j-S_j+S_k\end{aligned}\]</span> 其中 <span class="math inline">\(S\)</span> 为 <span class="math inline">\(A\)</span> 的前缀和。</p><p>设 <span class="math inline">\(f_{i,j}\)</span> 表示前 <span class="math inline">\(i\)</span> 个饲养员带走前 <span class="math inline">\(j\)</span> 只猫的最小花费。</p><p>则有： <span class="math display">\[\begin{aligned}f_{i,j}&amp;=\min\{f_{i-1,k}+j\times A_j-k\times A_j-S_j+S_k\}\\&amp;=\min\{f_{i-1,k}-A_j\times k+S_k\}+A_j\times j-S_j\end{aligned}\]</span></p><p>我们将循环地枚举每个饲养员的循环变量 <span class="math inline">\(i\)</span> 看做常量。</p><p>令 <span class="math inline">\(x\)</span> 优于 <span class="math inline">\(y\)</span>，则有： <span class="math display">\[f_{i-1,x}-A_j\times x+S_x&lt;f_{i-1,y}-A_j\times y+S_y\\\dfrac{(f_{i-1,x}+S_x)-(f_{i-1,y+S_y})}{x-y}&lt;A_j\]</span> <strong>注意事项</strong></p><p><span class="math inline">\(f\)</span> 初始化为极大值。</p><pre class="cpp"><code>#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#define int long longconst int maxp = 105;const int maxn = 1e5 + 5;const int LEN = (1 &lt;&lt; 20);int f[maxp][maxn];int n, m, p, L, R, t, h;int q[maxn], a[maxn], d[maxn], s[maxn];inline int getDP(int i, int j, int k) &#123;    return f[i - 1][k] + (j - k) * a[j] - (s[j] - s[k]);&#125;inline int getup(int i, int j, int k) &#123;    return (f[i - 1][j] + s[j]) - (f[i - 1][k] + s[k]);&#125;inline int getdown(int j, int k) &#123;    return (j) - (k);&#125;#ifdef ONLINE_JUDGEinline int nec(void) &#123;    static char buf[LEN], *p = buf, *e = buf;    if (p == e) &#123;        e = buf + fread(buf, 1, LEN, stdin);        if (e == buf) return EOF; p = buf;    &#125;    return *p++;&#125;#else#define nec getchar#endifinline bool read(int &amp;x) &#123;    char ch = nec();    bool f = 0; x = 0;    while (ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123;        if (ch == EOF) return 0;        if (ch == &#39;-&#39;) f = 1;        ch = nec();    &#125;    while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) &#123;        x = x * 10 + ch - &#39;0&#39;;        ch = nec();    &#125;    if (f) x = -x;    return 1;&#125;signed main() &#123;    read(n); read(m); read(p);    memset(f, 0x3f, sizeof (f));    for (int i = 2; i &lt;= n; ++i)        read(d[i]), d[i] += d[i - 1];    for (int i = 1; i &lt;= m; ++i) &#123;        read(h); read(t);        a[i] = t - d[h];    &#125;    std::sort(a + 1, a + m + 1);    for (int i = 1; i &lt;= m; ++i)        s[i] = s[i - 1] + a[i];    f[0][0] = 0;    for (int i = 1; i &lt;= p; ++i) &#123;        L = R = 1;        for (int j = 1; j &lt;= m; ++j) &#123;            while (L &lt; R &amp;&amp; getup(i, q[L + 1], q[L]) &lt;= a[j] * getdown(q[L + 1], q[L]))                ++L;            f[i][j] = getDP(i, j, q[L]);            while (L &lt; R &amp;&amp; getup(i, j, q[R]) * getdown(q[R], q[R - 1]) &lt;= getup(i, q[R], q[R - 1]) * getdown(j, q[R]))                --R;            q[++R] = j;        &#125;    &#125;    printf(&quot;%lld&quot;, f[p][m]);    return 0;&#125;</code></pre><hr /><h3 id="特别行动队"><a href="https://www.luogu.com.cn/problem/P3628">特别行动队</a></h3><p><a href="https://www.acwing.com/problem/content/337/">双倍经验</a> | <a href="https://loj.ac/p/10190">三倍经验</a></p><p>直接推式子。 <span class="math display">\[\begin{aligned}f_i&amp;=\max\{f_j+a\times(s_i-s_j)^2+b\times(s_i-s_j)+c\ \}\\&amp;=\max\{f_j+a\times({s_i}^2-2\times s_i\times s_j+{s_j}^2)+b\times s_i-b\times s_j\ \}+c\\&amp;=\max\{f_j+a\times{s_i}^2-2\times a\times s_i\times s_j+a\times{s_j}^2-b\times s_j\ \}+b\times s_i+c\\&amp;=\max\{f_j-2\times a\times s_i\times s_j+a\times{s_j}^2-b\times s_j\ \}+a\times{s_i}^2+b\times s_i+c\\\end{aligned}\]</span> 令 <span class="math inline">\(j\)</span> 优于 <span class="math inline">\(k\)</span>，则有： <span class="math display">\[\begin{aligned}f_j-2\times a\times s_i\times s_j+a\times{s_j}^2-b\times s_j&amp;&gt;f_k-2\times a\times s_i\times s_k+a\times{s_k}^2-b\times s_k\\(f_j+a\times{s_j}^2-b\times s_j)-(f_k+a\times{s_k}^2-b\times s_k)&amp;&gt;(2\times a\times s_i\times s_j)-(2\times a\times s_i\times s_k)\\\dfrac{(f_j+a\times{s_j}^2-b\times s_j)-(f_k+a\times{s_k}^2-b\times s_k)}{(2\times a\times s_j) - (2\times a\times s_k)}&amp;&gt;s_i\\\end{aligned}\]</span> 我们发现中间的符号是 <span class="math inline">\(&gt;\)</span>。</p><p>所以我们在弹队头的时候，要把判断条件中的符号反过来。</p><pre class="cpp"><code>#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#define int long longconst int maxn = 1e6 + 5;const int LEN = (1 &lt;&lt; 20);int n, L, R, a, b ,c;int q[maxn], s[maxn], f[maxn];inline int getDP(int i, int j) &#123;    return f[j] + a * (s[i] - s[j]) * (s[i] - s[j]) + b * (s[i] - s[j]) + c;&#125;inline int getup(int j, int k) &#123;    return (f[j] + a * s[j] * s[j] - b * s[j]) - (f[k] + a * s[k] * s[k] - b * s[k]);&#125;inline int getdown(int j, int k) &#123;    return (2 * a * s[j]) - (2 * a * s[k]);&#125;#ifdef ONLINE_JUDGEinline int nec(void) &#123;    static char buf[LEN], *p = buf, *e = buf;    if (p == e) &#123;        e = buf + fread(buf, 1, LEN, stdin);        if (e == buf) return EOF; p = buf;    &#125;    return *p++;&#125;#else#define nec getchar#endifinline bool read(int &amp;x) &#123;    char ch = nec();    bool f = 0; x = 0;    while (ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123;        if (ch == EOF) return 0;        if (ch == &#39;-&#39;) f = 1;        ch = nec();    &#125;    while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) &#123;        x = x * 10 + ch - &#39;0&#39;;        ch = nec();    &#125;    if (f) x = -x;    return 1;&#125;signed main() &#123;    read(n); read(a); read(b); read(c);    L = R = 1;    for (int i = 1; i &lt;= n; ++i) &#123;        read(s[i]), s[i] += s[i - 1];        while (L &lt; R &amp;&amp; getup(q[L + 1], q[L]) &gt;= s[i] * getdown(q[L + 1], q[L]))            ++L;        f[i] = getDP(i, q[L]);        while (L &lt; R &amp;&amp; getup(i, q[R]) * getdown(q[R], q[R - 1]) &lt;= getup(q[R], q[R - 1]) * getdown(i, q[R]))            --R;        q[++R] = i;    &#125;    printf(&quot;%lld&quot;, f[n]);    return 0;&#125;</code></pre><hr /><h3 id="征途"><a href="https://www.luogu.com.cn/problem/P4072">征途</a></h3><p><a href="https://loj.ac/p/2035">双倍经验</a> | <a href="https://www.acwing.com/problem/content/2575/">三倍经验</a></p><p>明显，不化掉 <span class="math inline">\(v\times m^2\)</span> 就无法进行优化。</p><p>设 <span class="math inline">\(x\)</span> 为当前休息站点与上一休息站点的距离， <span class="math inline">\(x_0\)</span> 为 <span class="math inline">\(x_1\sim x_n\)</span> 的平均数，<span class="math inline">\(S\)</span> 为 <span class="math inline">\(x\)</span> 的前缀和。 <span class="math display">\[\begin{aligned}V\times m^2&amp;=[(x_1-x_0)^2+(x_2-x_0)^2+\cdots+(x_m-x_0)^2]\times m\\&amp;=m\times \sum\limits_{i=1}^{m}{x_i}^2+(m\times {x_0})^2-2\times (x_0\times m)\times \sum\limits_{i=1}^{m}x_i\\&amp;=m\times \sum\limits_{i=1}^{m}{x_i}^2+{S_m}^2-2\times{S_m}^2\\&amp;=m\times \sum\limits_{i=1}^{m}{x_i}^2-{S_m}^2\end{aligned}\]</span></p><p>其中 <span class="math inline">\(S_m\)</span> 是一个定值（即输入所有路的长度和）。</p><p>唯一需要计算的，就是 <span class="math inline">\(\sum\limits_{i=1}^{m}{x_i}^{2}\)</span>，所以我们就来 DP 它。</p><p>设 <span class="math inline">\(a\)</span> 为输入道路长度的前缀和数组，<span class="math inline">\(f_{i,j}\)</span> 表示第 <span class="math inline">\(i\)</span> 次休息在 <span class="math inline">\(j\)</span> 处时 <span class="math inline">\(\min\{\sum\limits_{k=1}^{i}{x_k}^2\}\)</span> 的值，则有： <span class="math display">\[\begin{aligned}f_{i,j}&amp;=\min\{f_{i-1,j}+(a_i-a_j)^2\}\\&amp;=\min\{f_{i-1,j}+{a_i}^2-2\times a_i\times a_j+{a_j}^2\}\end{aligned}\]</span> 令 <span class="math inline">\(j\)</span> 优于 <span class="math inline">\(k\)</span>，则有： <span class="math display">\[f_{i-1,j}-2\times a_i\times a_j+{a_j}^2&lt;f_{i-1,k}-2\times a_i\times a_k+{a_k}^2\\f_{i-1,j}-f_{i-1,k}+{a_j}^2-{a_k}^2&lt;2\times a_i\times(a_j-a_k)\\\dfrac{f_{i-1,j}-f_{i-1,k}+{a_j}^2-{a_k}^2}{2\times(a_j-a_k)}&lt;a_i\]</span></p><p>初始化。</p><p>将 <span class="math inline">\(f\)</span> 初始化为极大值。</p><p>在 AcWing 上将 <code>memset</code> 改为初始化 <code>f[0][i] = a[i] * a[i]</code> 就可以过了，不然会 MLE，也许是因为没开滚动。（本来也用不着滚</p><pre class="cpp"><code>#include &lt;cstdio&gt;#define int long longconst int inf = 1e18;const int maxn = 3005;const int LEN = (1 &lt;&lt; 20);int f[maxn][maxn];int a[maxn], q[maxn];int n, m, L, R, ans = inf;#ifdef ONLINE_JUDGEinline int nec(void) &#123;    static char buf[LEN], *p = buf, *e = buf;    if (p == e) &#123;        e = buf + fread(buf, 1, LEN, stdin);        if (e == buf) return EOF; p = buf;    &#125;    return *p++;&#125;#else#define nec getchar#endifinline bool read(int &amp;x) &#123;    char ch = nec();    bool f = 0; x = 0;    while (ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123;        if (ch == EOF) return 0;        if (ch == &#39;-&#39;) f = 1;        ch = nec();    &#125;    while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) &#123;        x = x * 10 + ch - &#39;0&#39;;        ch = nec();    &#125;    if (f) x = -x;    return 1;&#125;inline int min(int x, int y) &#123; return x &lt; y ? x : y; &#125;int getDP(int i, int j, int k) &#123;    return f[k - 1][j] + (a[i] - a[j]) * (a[i] - a[j]);&#125;int getup(int j, int k, int i) &#123;    return f[i - 1][j] - f[i - 1][k] + a[j] * a[j] - a[k] * a[k];&#125;int getdown(int j, int k) &#123;    return (a[j] - a[k]) &lt;&lt; 1;&#125;signed main()&#123;    read(n); read(m);    for (int i = 1; i &lt;= n; ++i) &#123;        read(a[i]);        a[i] += a[i - 1];        f[0][i] = a[i] * a[i];    &#125;    for (int i = 1; i &lt; m; ++i) &#123;        L = R = 1; q[L] = i;        for (int j = i; j &lt;= n; ++j) &#123;            while (L &lt; R &amp;&amp; getup(q[L + 1], q[L], i) &lt;= a[j] * getdown(q[L + 1], q[L]))                ++L;            f[i][j] = getDP(j, q[L], i);            while (L &lt; R &amp;&amp; getup(i, q[R], i) * getdown(q[R], q[R - 1]) &lt;= getup(q[R], q[R - 1], i) * getdown(i, q[R]))                --R;            q[++R] = j;        &#125;    &#125;    printf(&quot;%lld&quot;,m * f[m - 1][n] - a[n] * a[n]);    return 0;&#125;</code></pre><hr /><h3 id="柠檬"><a href="https://www.luogu.com.cn/problem/P5504">柠檬</a></h3><p><a href="https://www.acwing.com/problem/content/2396/">双倍经验</a></p><p>是边写这篇题解边做的（</p><p>题意：</p><p>有一个含有 <span class="math inline">\(n\)</span> 个元素的序列 <span class="math inline">\(s\)</span>。将这个序列分成连续的若干段，定义每一段的价值为「在这一段当中任选某个元素的个数的平方再乘上这个元素」的最大值。求将 <span class="math inline">\(s\)</span> 划分后的最大价值。</p><p>不难想到分成的每一段首尾元素必须相等。</p><p>比如有这样一个序列 <span class="math inline">\(x,a_1,a_2,a_3,\cdots,a_k,x,y\)</span> 。假设我们求的是这一段包含 <span class="math inline">\(x\)</span> 的个数的平方，那么完全可以将 <span class="math inline">\(y\)</span> 从这一段中分离，单独为一段，明显更优。</p><p>而其他所有情况都是这种情况的拓展。</p><p>于是得到式子： <span class="math display">\[f_i=\max\{f_{j-1}+s_i\times(cnt_i-cnt_j+1)^2\}\]</span> 其中 <span class="math inline">\(cnt_i\)</span> 为 <span class="math inline">\(s_i\)</span> 已经出现了多少次。</p><p>然后就是套路。 <span class="math display">\[\begin{aligned}f_i&amp;=\max\{f_{j-1}+s_i\times({cnt_i}^2+{cnt_j}^2-2\times cnt_i\times cnt_j+2\times cnt_i-2\times cnt_j+1)\}\\&amp;=\max\{f_{j-1}+s_i\times{cnt_i}^2+s_i\times{cnt_j}^2-2\times s_i\times cnt_i\times cnt_j+2\times s_i\times cnt_i-2\times s_i\times cnt_j+s_i\}\\&amp;=\max\{f_{j-1}+s_i\times {cnt_j}^2-2\times s_i\times cnt_i\times cnt_j-2\times s_i\times cnt_j\}+s_i\times {cnt_i}^2+2\times s_i\times cnt_i+s_i\end{aligned}\]</span> 这次不是 <span class="math inline">\(\min\)</span>，而是 <span class="math inline">\(\max\)</span>，我们还能像以前那样推吗？</p><p>不急，我们先按以前的方法试试，见机行事。</p><p>令 <span class="math inline">\(j\)</span> 优于 <span class="math inline">\(k\)</span>，则有： <span class="math display">\[f_{j-1}+s_i\times {cnt_j}^2-2\times s_i\times cnt_i\times cnt_j-2\times s_i\times cnt_j&gt;f_{k-1}+s_i\times {cnt_k}^2-2\times s_i\times cnt_i\times cnt_k-2\times s_i\times cnt_k\]</span> 暴力搞不出来，因为那个 <span class="math inline">\(s_i\)</span> 乘上的平方项。</p><p>那我们想一个办法，把 <span class="math inline">\(s_i\)</span> 给灭掉就行了。</p><p>既然我们已知一段的首尾元素必须相等，那不就说明 <span class="math inline">\(s_i,s_j,s_k\)</span> 可以相互替换吗？</p><p>继续搞。 <span class="math display">\[f_{j-1}+s_j\times {cnt_j}^2-2\times s_i\times cnt_i\times cnt_j-2\times s_j\times cnt_j&gt;f_{k-1}+s_k\times {cnt_k}^2-2\times s_i\times cnt_i\times cnt_k-2\times s_k\times cnt_k\\f_{j-1}-f_{k-1}+s_j\times {cnt_j}^2-s_k\times {cnt_k}^2-2\times s_j\times cnt_j+2\times s_k\times cnt_k&gt;2\times s_i\times cnt_i\times cnt_j-2\times s_i\times cnt_i\times cnt_k\\\dfrac{f_{j-1}-f_{k-1}+s_j\times {cnt_j}^2-s_k\times {cnt_k}^2-2\times s_j\times cnt_j+2\times s_k\times cnt_k}{cnt_j-cnt_k}&gt;2\times s_i\times cnt_i\]</span></p><p>这里的符号变成 <span class="math inline">\(&gt;\)</span> 了。</p><p>易得，这里要维护的是一个斜率单调递减的上凸包最优解序列。</p><p>因为 <span class="math inline">\(s_i\)</span> 必须与 <span class="math inline">\(s_j,s_k\)</span> 相同，明显要针对每个 <span class="math inline">\(s_i\)</span> 维护不同的最优解序列，在每次对应的序列中计算。</p><p>维护的斜率单调递减，而对于每一个相等的 <span class="math inline">\(s_i\)</span>， <span class="math inline">\(2\times s_i\times cnt_i\)</span> 一定是单调递增的，导致了这个序列大概长这个样子：斜率单调递减，但末尾的最小的斜率仍大于 <span class="math inline">\(2\times s_i\times cnt_i\)</span>。</p><p>单调栈可以自行研究，因为作者瞄了一眼时间发现已经是明天了。（什</p><pre class="cpp"><code>#include&lt;cstdio&gt;#include&lt;vector&gt;using namespace std;#define int long long#define top q[x].size() - 1const int maxn = 1e5 + 5;const int maxm = 1e4 + 5;int n;vector&lt;int&gt; q[maxm]; // 不用 vector 会 MLEint f[maxn], s[maxn];int cnt[maxn], tot[maxm];int getDP(int i,int j)&#123;    return f[j-1]+(cnt[i]-cnt[j]+1)*(cnt[i]-cnt[j]+1)*s[i];&#125;int getup(int j,int k)&#123;    return f[j-1]-f[k-1]+s[j]*cnt[j]*cnt[j]-s[k]*cnt[k]*cnt[k]-2*s[j]*cnt[j]+2*s[k]*cnt[k];&#125;int getdown(int j,int k)&#123;    return cnt[j]-cnt[k];&#125;signed main()&#123;    scanf(&quot;%lld&quot;,&amp;n);    for(int i=1;i&lt;=n;++i)&#123;        scanf(&quot;%lld&quot;,&amp;s[i]);        cnt[i]=++tot[s[i]];    &#125;    for(int i=1;i&lt;=n;++i)&#123;        int x=s[i];        while(q[x].size()&gt;=2&amp;&amp;getup(q[x][top-1],i)*getdown(q[x][top-1],q[x][top])&gt;=getup(q[x][top-1],q[x][top])*getdown(q[x][top-1],i))            q[x].pop_back();        q[x].push_back(i);        while(q[x].size()&gt;=2&amp;&amp;getDP(i,q[x][top])&lt;=getDP(i,q[x][top-1]))            q[x].pop_back();        f[i]=getDP(i,q[x][top]);    &#125;    printf(&quot;%lld&quot;,f[n]);    return 0;&#125;</code></pre><hr /><h3 id="总结">总结</h3><p>总结斜优的步骤：</p><ol type="1"><li>推 DP 式子</li><li>对式子进行巧妙的优化，使其易于化简</li><li>假设 <span class="math inline">\(j\)</span> 优于 <span class="math inline">\(k\)</span>，将式子化成 <span class="math inline">\(\dfrac{(j)-(k)}{(j)-(k)}&gt; \text{or} &lt;x\)</span> 的形式</li><li>单调队列或单调栈优化</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 斜率优化 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
