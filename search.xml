<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>学习笔记：悬线法</title>
    <url>/20220927/</url>
    <content><![CDATA[有一段时间看见单调栈就抑郁，所以做题的时候就东贺贺，西贺贺，最终了解到了世界上还有一种很神奇的方法叫悬线法。

本文中的「单调栈」均指依赖于顺序维护信息的工具，单纯利用单调性质作为数据结构独立存在的单调栈不在本篇文章 批判 范围之内。

引入：土豪聪要请客
https://www.becoder.com.cn/problem/6926

给定一个 \(n\times m\) 的矩阵，其中有一部分地方有障碍。在整个地图上找到周长最大的、不包含障碍的矩形。
输入一个由 .（空地）和 X（障碍）组成的矩阵，输出最大矩形周长减 \(1\)。
\(n,m\le 2000\)。


一些鲜花
看到题后即可想到悬线法，但是中午太困了处于游离状态一直掉线，所以干瞪着电脑屏幕打瞌睡。
于是这篇文章从 220927 被拖到了 230916，哈哈真神奇 现在是 231004 了，我才动笔。


首先预处理出 \(s_{i, j}\)，表示从 \((i,\,j)\) 向上，共有多少个连续的 .。
for (int i = 1; i &lt;= n; ++i) &#123;
    for (int j = 1; j &lt;= m; ++j)
        s[i][j] = (a[i][j] == &#39;.&#39; ? s[i - 1][j] + 1 : 0);
&#125;
悬线法的名字很形象，拎着一根细线的头，让它自然下垂。
为了方便思考和实现，我们这样想象：一个地图，我们手里拿着一根硬棒朝上举，然后固定我们手只能在一行上运动，用它左右「刷」沿途的矩形。
具象地说，选定一行 \(i\)，枚举每一个 \(j\)，寻找以第 \(i\) 行为底，包含 \((i,\,j)\)，高为 \(s_{i,\,j}\) 的最宽矩形。
也就是从 \((i, j)\) 出发，往左右分别找到最远的一个位置 \(L_j, R_j\)，满足 \(s_{i, L_j \sim R_j} \ge s_{i, j}\)。那么悬线法最抽象的部分就讲完了，接下来是最神奇的部分。
在第 \(i\) 行内，从每个 \((i, j)\) 开始找到 \(L_j, R_j\)，如果暴力那么明显是个 \(O(m^2)\) 的时间。
但是我们考虑这么一件事情。假设 \(L_{i-1}\) 已经求出。
令 \(k = j-1\)，\(L_j\) 初值赋为 \(j\)（左端点至少是自己）。

当 \(L_j=1\) 时 即刻停止算法，因为 \(1\) 是可达的最左位置，不能再往左了。
当 \(a_k &gt; a_j\) 时 \(a_k\) 就像一堵墙，堵住了我们要继续往左刷的硬棒，故不改变 \(L_j\) 并停止算法。
否则，由于 \(a_{L_k\sim k}\ge a_k\ge a_j\)，从 \(j\) 开始往左刷至少都能够到 \(L_k\)。此时我们令 \(k=L_k-1\)，回到第一步。

我们就可以求解到正确的 \(L_j\) 的。求解 \(R_j\) 的流程和上述大致相同，不再赘述。

悬线法的时间复杂度怎么证明呢？
假设 \(a_{j-1}&gt;a_j\)，算法会即刻停止；否则，当前定位直接跳到 \(L_{j-1}\) 之前，也就是说，为了求解 \(L_{j-1}\) 而遍历过的位置，求解 \(L_j\) 时都不会再遍历第二遍。
没有值会被遍历第二遍，所以是均摊 \(O(m)\) 的。

按照上述流程，算法总体时间复杂度 \(O(n\times m)\)，和单调栈完全一致。

namespace XSC062 &#123;
using namespace fastIO;
const int maxn = 2e3 + 5;
int n, m, ans;
char a[maxn][maxn];
int s[maxn][maxn], l[maxn][maxn], r[maxn][maxn];
int max(int x, int y) &#123;
    return x &gt; y ? x : y;
&#125;
int main() &#123;
    read(n);
    read(m);
    for (int i = 1; i &lt;= n; ++i)
        scanf(&quot;%s&quot;, a[i] + 1);
    for (int i = 1; i &lt;= n; ++i) &#123;
        for (int j = 1; j &lt;= m; ++j)
            s[i][j] = (a[i][j] == &#39;.&#39; ? s[i - 1][j] + 1 : 0);
    &#125;
    for (int i = 1; i &lt;= n; ++i) &#123;
        for (int j = 1; j &lt;= m; ++j) &#123;
            l[i][j] = j;
            while (l[i][j] &gt; 1 &amp;&amp; s[i][j] &lt;= s[i][l[i][j] - 1])
                l[i][j] = l[i][l[i][j] - 1];
        &#125;
    &#125;
    for (int i = 1; i &lt;= n; ++i) &#123;
        for (int j = m; j; --j) &#123;
            r[i][j] = j;
            while (r[i][j] &lt; m &amp;&amp; s[i][j] &lt;= s[i][r[i][j] + 1])
                r[i][j] = r[i][r[i][j] + 1];
        &#125;
    &#125;
    for (int i = 1; i &lt;= n; ++i) &#123;
        for (int j = 1; j &lt;= m; ++j) &#123;
            if (!s[i][j])
                continue;
            ans = max(ans, (s[i][j] +
                      (r[i][j] - l[i][j] + 1)) * 2);
        &#125;
    &#125;
    printf(&quot;%d&quot;, ans - 1);
    return 0;
&#125;
&#125; // namespace XSC062


上述处理 \(s\) 数组的「竖向压缩」技巧是处理矩阵类悬线法题目的常用技巧，这里使用另一道题来举例子。
例：玉蟾宫 / City Game / 城市游戏
https://www.becoder.com.cn/problem/17039
这道题和上一道非常相似，只需改变求答案的式子即可。

namespace XSC062 &#123;
using namespace fastIO;
const int maxn = 1e3 + 5; 
char t;
int n, m, ans;
int s[maxn][maxn];
int l[maxn][maxn], r[maxn][maxn];
int max(int x, int y) &#123;
    return x &gt; y ? x : y;
&#125;
int main() &#123;
    scanf(&quot;%d %d&quot;, &amp;n, &amp;m);
    for (int i = 1; i &lt;= n; ++i) &#123;
        for (int j = 1; j &lt;= m; ++j) &#123;
            scanf(&quot;%1s&quot;, &amp;t);
            if (t == &#39;F&#39;)
                s[i][j] = s[i - 1][j] + 1;
            l[i][j] = j;
            while (l[i][j] &gt; 1 &amp;&amp; s[i][j]
                        &lt;= s[i][l[i][j] - 1])
                l[i][j] = l[i][l[i][j] - 1];
        &#125;
    &#125;
    for (int i = 1; i &lt;= n; ++i) &#123;
        r[i][m + 1] = m + 1;
        for (int j = m; j; --j) &#123;
            r[i][j] = j;
            while (r[i][j] &lt; m &amp;&amp; s[i][j]
                         &lt;= s[i][r[i][j] + 1])
                r[i][j] = r[i][r[i][j] + 1];
            ans = max(ans, s[i][j] *
                        (r[i][j] - l[i][j] + 1));
        &#125;
    &#125;
    print(ans * 3, &#39;\n&#39;);
    return 0;
&#125;
&#125; // namespace XSC062


悬线法能维护的数据特点
值得注意的是，悬线法仅指求解最远左右端点的技巧。
同时可以维护过程中的其它信息，例如 情景剧 一题。链接中有详细叙述，此处略。
根据本题带来的启发，我们认识到悬线可在求解过程中维护的内容更多。
不像你单调栈随随便便删这删那信息全部断层什么都维护不了

进一步地，悬线法与单调栈？
和 @Rosmist 辩经的时候，Rosmist 激情爆典：「悬线不就是可持久化单调栈吗？」
很有道理。容易发现单调栈在每一个 \(i\) 时刻的栈内元素就是从 \(i\) 开始往起始方向跳，经过的所有元素。由于悬线存储的数据是不会更改的，倒推回去我们可以知道，悬线存储了每个时刻的单调栈信息并有多个点共享前驱 / 后继，其实就是一种另类的可持久化单调栈，并且复杂度与单调栈本体相同。

简单来说，悬线数组保存了序列的笛卡尔树，自然维护了每个版本的单调栈。
单条悬线链和单调栈在笛卡尔树上是一致的，这里的信息重复利用也很持久化。


与笛卡尔树的关联
upd on 240704，学习了笛卡尔树。现在介绍悬线与笛卡尔树的关系。
容易发现元素 \(i\) 的 \(l_i,r_i\) 二值就是其在笛卡尔树上对应的区间。
更抽象的一点是悬线法中跳一跳的操作在笛卡尔树中的对应内涵。以小根堆为背景、在 \(l\) 上向左跳为例，注意到该操作相当于从左到右向笛卡尔树中新增节点。
这也进一步验证了悬线法复杂度的正确性：我们都知道，在新加入节点时，若从树中提取出由根节点和其一直向右走直到节点不存在右儿子构成的链，则该点被添加到链中某一点的右儿子，该点原本的右子树（完整包含了链的剩余部分）成为新建节点的左子树。
而悬线实现的就是从链的最低点暴力爬山，直到找到合法点；而根据上面的结论，被枚举过的链上较低点不会作为新节点的右边的子孙，自然也不会再次被枚举到。
故而每个点最多被枚举到一次，得证。
进一步的，可以开发出悬线法 \(O(n)\) 建笛卡尔树的方法：
每次求解完 \(l_i\) 后，令 \(rc_{l_i-1}=i\) 即可（当然 \(rc_{l_i-1}\) 是会被多次更新的，这也是不直接用邻接表 / 前向星连边的原因），\(r_i\) 与 \(lc\) 同理。
for (int i = 1; i &lt;= n; ++i) &#123;
    l[i] = i;
    while (l[i] != 1 &amp;&amp; a[l[i] - 1] &gt; a[i])
        l[i] = l[l[i] - 1];
    rc[l[i] - 1] = i;
&#125;
for (int i = n; i; --i) &#123;
    r[i] = i;
    while (r[i] != n &amp;&amp; a[r[i] + 1] &gt; a[i])
        r[i] = r[r[i] + 1];
    lc[r[i] + 1] = i;
&#125;
其中，根节点即为 rc[0] 或 lc[n + 1]。

进一步从笛卡尔树出发，探究悬线法能够循环内维护的数据特点。
为何是循环内维护？因为循环外维护就只能从左右的直接儿子进行更新，那和笛卡尔树就没有区别了。
但其实结果是没什么可探究的，因为其经过的节点——自己左子树下最右端链——实在不具有什么特殊性，它们所对应的区间——从 \([l_i, i - 1]\) 到 \([i - 1, i - 1]\) 也看不出什么值得研究的，更何况可以被笛卡尔树更具象地代替；如果你要从前缀最值的角度出发，那就没意思了，完全等价于单调栈。

考虑代表的区间呢？发现一条悬线链代表笛卡尔树上，包含点 \(i\) 的若干个极长不交区间，使得 \(1\sim i\) 被完整覆盖。
Grisses 问是否存在笛卡尔树上树剖，我说未必不存在开发空间（。）

所以我们认为这次悬线法的开发最终以失败告终，不然它早被别人开发了，我在此能给出的意见是，可以用悬线法完成矩形题目等不需要笛卡尔树树形结构的问题，至于其他，甚至包括上面提到的 情景剧 一题，都可以直接上笛卡尔树。
但笛卡尔树的建树我还是肯定会用悬线的！毕竟照应开头，我不会单调栈 
]]></content>
      <tags>
        <tag>悬线法</tag>
      </tags>
  </entry>
  <entry>
    <title>【总结】斜率优化 DP</title>
    <url>/20210214/</url>
    <content><![CDATA[于是，XSC062 开始写总结。
斜率优化 DP
前置芝士
单调队列优化 DP
正文
我们以一道题为例。
打印文章
双倍经验 | 三倍经验
Solution
明显 DP。
那么 DP 式就是： \[
\begin{aligned}
f_i&amp;=\min\{f_j+(s_i-s_j)^2+M\}
\\
&amp;=\min\{f_j+{s_i}^2-2\times s_i\times s_j+{s_j}^2+M\}
\\
&amp;=\min\{f_j-2\times s_i\times s_j+{s_j}^2\}+{s_i}^2+M
\end{aligned}
\] 其中 \(s\) 为 \(c\) 的前缀和。
时间复杂度 \(O(n^2)\)，明显爆炸，所以我们需要优化。
在上一篇的 单调队列优化DP 中，我们提到过，只有 DP 式中的与 \(i\) 有关的项能直接提出来时，我们才能使用单调队列优化，而这里的 \(s_i\) 与 \(s_j\) 相乘，无法使用单调队列优化。
我们思考，对于 \(f_i\) 来说，无非就是选出最优的 \(j\) 来构造它。
假设有 \(j\) 与 \(k\)，如何判断 \(j\) 与 \(k\) 谁更优呢？
我们先钦定 \(j\) 优于 \(k\)，且 \(j&lt;k\)。
那么可以得到： \[
f_j-2\times s_i\times s_j+{s_j}^2+{s_i}^2+M&lt;f_k-2\times s_i\times s_k+{s_k}^2+{s_i}^2+M
\] 化简得： \[
f_j-2\times s_i\times s_j+{s_j}^2&lt;f_k-2\times s_i\times s_k+{s_k}^2
\] 再将只与 \(j,k\) 有关的项放到左边，与 \(i\) 有关的项放到右边： \[
f_j-f_k+{s_j}^2-{s_k}^2&lt;2\times s_i\times s_j-2\times s_i\times s_k
\\
f_j-f_k+{s_j}^2-{s_k}^2&lt;2\times s_i\times(s_j-s_k)
\] 左右两边同时 \(\div\) 与 \(i\) 无关的项 \(2\times(s_j-s_k)\) ： \[
\dfrac{(f_j+{s_j}^2)-(f_k+{s_k}^2)}{(2\times s_j)-(2\times s_k)}&lt;s_i
\] 如果满足上式 ，则 \(j&lt;k\) 且 \(j\) 优于 \(k\)。
接下来是斜率优化的重点部分。

在义务教育阶段，学生学习了 一次函数，它的几何意义表示为一条直线，一次项的系数就是直线的斜率，只不过当直线与 \(x\) 轴垂直的时候无法表示。虽然没有明确给出斜率这个名词，但实际上思想已经渗透到其中。
直线对 \(x\) 轴的倾斜角 \(\alpha\) 的正切值 \(\tan\alpha\) 称为该直线的“斜率”，并记作 \(k\) ，公式为 \(k=\tan\alpha\)。
即 \(k=\tan\alpha=\dfrac{\Delta y}{\Delta x}=\dfrac{y_2-y_1}{x_2-x_1}\) 或 \(\dfrac{y_1-y_2}{x_1-x_2}\) 。

——选自 斜率_百度百科


XSC062 看完了百度百科表示 你 TM 在说些啥是不是欺负我六年义务教育的小学生 恍然大悟
上面推出来的那个关于 \(j\) 和 \(k\) 的DP式，不就是求两个点 \((2\times s_j,f_j+{s_j}^2)\) 和 \((2\times s_k,f_j+{s_k}^2)\) 连成一条线之后的坡度吗？
本文后面的部分，\(x\) 的含义会在「点\((2\times s_x,f_x+{s_x}^2)\) 」和「下标 \(x\) 」之间漂浮，请根据语境识别。
随后 XSC062 边打瞌睡边听 GM 讲课（特异功能），勉强算是明白了中心意思：
如图，假设有三个点 \(A,B,C\)，以及 \(l_{AB}\) 的斜率 \(k_1\)，\(l_{BC}\) 的斜率 \(k_2\)。

上凸

我们暂且把这个向外凸起的奇怪玩意儿称为一个「上凸」。
回到前面的我们得到的那个结论：

\[
\dfrac{(f_j+{s_j}^2)-(f_k+{s_k}^2)}{(2\times s_j)-(2\times s_k)}&lt;s_i
\]
如果满足上式 ，则 \(j&lt;k\) 且 \(j\) 优于 \(k\)。

简单记忆为：

若 \(l_{NM}\) 的斜率比 \(s_i\) 小，则 \(N&lt;M\) 且 \(N\) 优于 \(M\) 。
反之，若点 \(l_{NM}\) 的斜率比 \(s_i\) 大，则 \(M&lt;N\) 且 \(M\) 优于 \(N\)。

将 \(A,B\) 代入，我们得知：

若 \(k_1\leqslant s_i\)，则 \(B\) 优于 \(A\)。
若 \(k_1&gt;s_i\)，则 \(A\) 优于 \(B\)。
若 \(k_2\leqslant s_i\)，则 \(C\) 优于 \(B\)。
若 \(k_2&gt;s_i\)，则 \(B\) 优于 \(C\)。

因为斜率 = 倾斜度 = 竖得有多高，明显 \(k_1&gt;k_2\)。所以针对一个大小关系，\(k_1\) 和 \(k_2\) 之间只有可能有：

\(s_i&lt;k_2&lt;k_1\)，此时 \(B\) 优于 \(C\)，\(A\) 优于 \(B\)，\(A\) 为最优解。
\(k_2&lt;s_i&lt;k_1\)，此时 \(C\) 优于 \(B\)，\(A\) 优于 \(B\)，\(A,C\) 为最优解。
\(k_2&lt;k_1&lt;s_i\)，此时 \(C\) 优于 \(B\)，\(B\) 优于 \(A\)，\(C\) 为最优解。

发现了吗？\(B\) 永远都不可能是最优解。
所以如果我们要维护一个最优解的序列，就可以不要 \(B\) 了。

上凸

那么，因为我们已经删掉了所有「上凸」的突起部分，所以这个最优解序列里肯定不会再存在「上凸」了。
如果是这样的「下凸」呢？

下凸

\(k_1\) 为 \(l_{AB}\) 的斜率，\(k_2\) 为 \(l_{BC}\) 的斜率。
将 \(A,B\) 代入，我们得知：

若 \(k_1\leqslant s_i\)，则 \(B\) 优于 \(A\)。
若 \(k_1&gt;s_i\)，则 \(A\) 优于 \(B\)。
若 \(k_2\leqslant s_i\)，则 \(C\) 优于 \(B\)。
若 \(k_2&gt;s_i\)，则 \(B\) 优于 \(C\)。

明显 \(k_1&lt;k_2\)。所以 \(k_1\) 和 \(k_2\) 之间只有可能有：

\(s_i&lt;k_1&lt;k_2\)，此时 \(B\) 优于 \(C\)，\(A\) 优于 \(B\)，\(A\) 为最优解。
\(k_1&lt;s_i&lt;k_2\)，此时 \(B\) 优于 \(C\)，\(B\) 优于 \(A\)，\(B\) 为最优解。
\(k_1&lt;k_2&lt;s_i\)，此时 \(C\) 优于 \(B\)，\(B\) 优于 \(A\)，\(C\) 为最优解。

所以，在下凸的情况中，三个点都有可能是最优解，都需要保留。
现在呢，所有上凸都被去掉了，只剩下凸，所以大概最后的最优解序列就长这个样子：

下凸包

下 秃 包
反过来看就是 lifan 的脑袋了
观察发现，斜率是从左往右递增的。
所以，我们考虑用单调队列来当这个「最优解序列」。
维护队头
即保证队头元素为最优解。
设队头为 \(q_l\)。
如果 \(q_{l+1}\) 与 \(q_l\) 形成的斜率 \(\leqslant s_i\)，根据上面推出来的玩意儿，得到 \(q_{l+1}\) 优于 \(q_l\)。
那还要 \(q_l\) 干啥，直接 l++。
更新 DP 值
\(f_i=f_{q_l}-2\times s_i\times s_{q_l}+{s_{q_l}}^2+{s_i}^2+M\)
维护队尾
即保证里面塞的点相邻两个的斜率递增。
设队尾为 \(q_r\)，我们要往最优解队列里 push 一个 \(i\) 。
若队尾两个点 \(q_r,q_{r-1}\) 形成的斜率比 \(i,q_r\) 形成的斜率大，那么push(i)后，整个队列的斜率就不再单调递增，所以此时要将r--。（因为 上一篇关于单调队列的博客 中讲到的 \(i\) 必须入队，只能委屈一下 \(q_r\) 了）
注意事项
众所周知，斜率是个浮点数。为了避免损失精度造成的一些惨案，我们交叉相乘，将分子、分母分开处理。
以及时刻都要保证队列中至少有两个点，因为要访问 \(q_l,q_{l+1}\) 和 \(q_r,q_{r-1}\)。
Code
#include &lt;cstdio&gt;
const int maxn = 5e5 + 5;
int n, m, l, r;
int f[maxn], c[maxn], q[maxn];
inline int getDP(int i, int j) &#123;
    return f[j] + m + (c[i] - c[j]) * (c[i] - c[j]);
&#125;
inline int getup(int j, int k)&#123;
    return f[j] + c[j] * c[j] - f[k] - c[k] * c[k]; // 计算分子的值
&#125;
inline int getdown(int j, int k) &#123;
    return (c[j] - c[k]) * 2; // 计算分母的值
&#125;
int main()&#123;
    while (~scanf(&quot;%d %d&quot;, &amp;n, &amp;m)) &#123;
        l = r = 1; // 凡是涉及到前缀和的单调队列，队列中必须存在初始 0
        for (int i = 1; i &lt;= n; ++i) &#123;
            scanf(&quot;%d&quot;, &amp;c[i]); // c 自给自足
            c[i] += c[i - 1];
            // # 维护队头
            // 注意此处的条件为 l &lt; r，因为队列中至少需要存在两个点
            while (l &lt; r &amp;&amp; getup(q[l+1], q[l]) &lt;= c[i] * getdown(q[l + 1],q[l]))
                l++;
            // # 转移状态
            f[i] = getDP(i, q[l]);
            // # 维护队尾
            while(l &lt; r&amp;&amp; getup(i, q[r]) * getdown(q[r], q[r-1]) &lt;= getup(q[r] ,q[r - 1]) * getdown(i, q[r]))
                r--;
            q[++r] = i;
        &#125;
        printf(&quot;%d\n&quot;,f[n]);
    &#125;
    return 0;
&#125;
在对 DP 式变形时，我们最好将其化为 \(\dfrac{(j)-(k)}{(j)-(k)}&lt;x\) 或 \(\dfrac{(j)-(k)}{(j)-(k)}&gt;x\) 的形式。
这个板子只适用于维护下凸包的情况。当中间的符号为 \(&gt;\) 时，我们会在这份代码上稍作改动，维护一个上凸包，后文会提到有关内容。

玩具装箱
双倍经验 | 三倍经验
从今往后我们就只讲怎么推式子，不再证明下凸等性质了。
设 \(f_i\) 表示第 \(i\) 个玩具放完后的最小费用。 \[
f_i=\min\{f_j+(i-j-1+\sum\limits_{k=i}^jC_k-L)^2\}
\] 为了让这个式子好拆，我们在一开始让 l++，并且 \(C\) 再次自给自足，为输入的 \(C\) 的前缀和数组。
于是式子就变成： \[
f_i=\min\{f_j+(i-j-L+C_i-C_j)^2\}
\] 明显硬拆会死人。（反正我试过，比较适合用来发泄
所以我们把式子变成这样： \[
f_i=\min\{f_j+((C_i+i)-(C_j+j)-L)^2\}
\] 既然 \(C_i\) 与 \(i\)，\(C_j\) 与 \(j\) 是对应的，那么直接预处理，给 \(C_i\) 加上 \(i\) 不就行了？
现在这个 \(C_i\) 的含义和实现就变得有点曲折难懂了。
具体实现如下：
for (int i = 1; i &lt;= n; ++i) &#123;
    scanf(&quot;%lld&quot;, &amp;c[i]);
    c[i] += c[i - 1];
&#125;
for (int i = 1; i &lt;= n; ++i)
    c[i] += i;
也就是说，\(C_i\) 是在前缀和的基础上加了一个 \(i\)，注意不能把 \(i\) 也一起前缀和了。
然后式子就变成了这样： \[
\begin{aligned}
f_i&amp;=\min\{f_j+(C_i-C_j-L)^2\}
\\
&amp;=\min\{f_j+{C_i}^2+{C_j}^2+L^2-2\times C_i\times C_j-2\times C_i\times L+2\times C_j\times L\}
\\
&amp;=\min\{f_j+{C_j}^2-2\times C_i\times C_j+2\times C_j\times L\}+{C_i}^2+L^2-2\times C_i\times L
\end{aligned}
\]
令 \(j\) 优于 \(k\) 且 \(j&lt;k\)。
得： \[
f_j+{C_j}^2-2\times C_i\times C_j+2\times C_j\times L&lt;f_k+{C_k}^2-2\times C_i\times C_k+2\times C_k\times L
\\
f_j-f_k+{C_j}^2-{C_k}^2+2\times C_j\times L-2\times C_k\times L&lt;2\times C_i\times C_j-2\times C_i\times C_k
\\
f_j-f_k+{C_j}^2-{C_k}^2+2\times C_j\times L-2\times C_k\times L&lt;2\times(C_j-C_k)\times C_i
\\
\dfrac{f_j-f_k+{C_j}^2-{C_k}^2}{2\times(C_j-C_k)}&lt;C_i
\\
\dfrac{(f_j+{C_j}^2)-(f_k+{C_k}^2)}{(2\times C_j)-(2\times C_k)}&lt;C_i
\]
#include &lt;cstdio&gt;
#define int long long
const int maxn = 5e5 + 5;
const int LEN = (1 &lt;&lt; 20);
int n, m, h, t;
int c[maxn], q[maxn], f[maxn];
#define nec getchar
inline bool read(int &amp;x) &#123;
    char ch = nec();
    bool f = 0; x = 0;
    while (ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123;
        if (ch == EOF) return 0;
        if (ch == &#39;-&#39;) f = 1; ch = nec();
    &#125;
    while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) &#123;
        x = x * 10 + ch - &#39;0&#39;;
        ch = nec();
    &#125;
    if (f) x = -x;
    return 1;
&#125;
inline int getup(int j, int k) &#123;
    return (f[j] + c[j] * c[j] + 2 * c[j] * m)
           - (f[k] + c[k] * c[k] + 2 * c[k] * m);
&#125;
inline int getdown(int j, int k) &#123;
    return (2 * c[j]) - (2 * c[k]);
&#125;
inline int getDP(int i, int j) &#123;
    return f[j] + (c[i] - c[j] - m) * (c[i] - c[j] - m);
&#125;
signed main() &#123;
    read(n); read(m); h = t = 1; ++m;
    for (int i = 1; i &lt;= n; ++i)
        read(c[i]), c[i] += c[i - 1];
    for (int i = 1; i &lt;= n; ++i) &#123;
        c[i] += i;
        while (h &lt; t &amp;&amp; getup(q[h + 1], q[h]) &lt;
               c[i] * getdown(q[h + 1], q[h])) ++h;
        f[i] = getDP(i, q[h]);
        while (h &lt; t
               &amp;&amp; getup(i, q[t]) * getdown(q[t], q[t - 1]) &lt;=
               getdown(i, q[t]) * getup(q[t], q[t - 1])) --t;
        q[++t] = i;
    &#125;
    printf(&quot;%lld&quot;, f[n]);
    return 0;
&#125;

任务安排 1
双倍经验 | 三倍经验
感谢蓝书。这里按着蓝书上的思维走。
解法一
暴力。
此处的 \(t,c\) 为输入的 \(t,c\) 的前缀和数组。
设 \(f_{i,j}\) 为前 \(i\) 个任务分成 \(j\) 批的最小费用。
故 \(S\times j+t_i\) 为第 \(i\) 个任务的完成时间。
得出状态转移方程（\(k\) 枚举上一批任务结束位置）： \[
f_{i,j}=\min\limits_{0\leqslant k&lt;i}\{f_{k,j-1}+(S\times j+t_i)\times(c_i-c_k)\}
\] 时间复杂度 \(O(n^3)\)。
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#define int long long
const int inf = 1e18;
const int maxn = 5005;
const int LEN = (1 &lt;&lt; 20);
int f[maxn][maxn];
int n, s, ans = inf;
int t[maxn], c[maxn];
inline int min(int x, int y) &#123; return x &lt; y ? x : y; &#125;
#ifdef ONLINE_JUDGE
inline int nec(void) &#123;
    static char buf[LEN], *p = buf, *e = buf;
    if (p == e) &#123;
        e = buf + fread(buf, 1, LEN, stdin);
        if (e == buf) return EOF; p = buf;
    &#125;
    return *p++;
&#125;
#else
#define nec getchar
#endif
inline bool read(int &amp;x) &#123;
    char ch = nec();
    bool f = 0; x = 0;
    while (ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123;
        if (ch == EOF) return 0;
        if (ch == &#39;-&#39;) f = 1;
        ch = nec();
    &#125;
    while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) &#123;
        x = x * 10 + ch - &#39;0&#39;;
        ch = nec();
    &#125;
    if (f) x = -x;
    return 1;
&#125;
signed main() &#123;
    read(n); read(s);
    memset(f, 0x3f, sizeof (f));
    for (int i = 1; i &lt;= n; ++i) &#123;
        read(t[i]); read(c[i]);
        t[i] += t[i - 1];
        c[i] += c[i - 1];
        f[i][1] = (s + t[i]) * c[i]; // 初始化
    &#125;
    for (int i = 2; i &lt;= n; ++i) &#123;
        for (int j = 2; j &lt;= i; ++j) &#123;
            for (int k = 1; k &lt; i; ++k)
                f[i][j] = min(f[i][j], f[k][j - 1] + (t[i] + s * j) * (c[i] - c[k]));
        &#125;
    &#125;
    for (int i = 1; i &lt;= n; ++i)
        ans = min(ans, f[n][i]);
    printf(&quot;%lld&quot;, ans);
    return 0;
&#125;
亲测 TLE 70
解法二
脑子炸了，想了好久才想明白这个优化的正确性。
思考，以上代码需要 \(j\) 这一维的根本原因是什么？
因为我们无法确定之前已经划分了多少批，也就是无法确定 \(S\) 的个数。
换个角度思考，我们无法确定之前，却可以确定之后。
什么意思呢？如果我们在任务 \(i\) 处划分，那么任务 \(i\) 以及任务 \(i\) 以后的所有任务的执行时间都会延后 \(S\)。
因为 \(i\) 以后的状态也会使用 \(f_i\) 的值，我们在计算 \(f_i\) 时就将 \(S\) 提出来，提前把后面的 \(c\) 乘上不就行了？
中间的结果不对劲也无所谓，只要最后的答案是对的就行了。

也就是说，我们没有直接求出每批任务的完成时刻，而是在一批任务「开始」对后续任务产生影响时，就先把费用累加到答案中。这是一种名为「费用提前计算」的经典思想。

——李煜东《算法竞赛进阶指南》


状态转移方程： \[
f_i=\min\limits_{0\leqslant j&lt;i}\{f_j+(c_i-c_j)\times t_i+s\times(c_n-c_j)\}
\] 此处，\(f_i\) 没有具体含义。
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#define int long long
const int maxn = 1e4 + 5;
const int LEN = (1 &lt;&lt; 20);
int n, s;
int f[maxn], t[maxn], c[maxn];
inline int min(int x, int y) &#123; return x &lt; y ? x : y; &#125;
#ifdef ONLINE_JUDGE
inline int nec(void) &#123;
    static char buf[LEN], *p = buf, *e = buf;
    if (p == e) &#123;
        e = buf + fread(buf, 1, LEN, stdin);
        if (e == buf) return EOF; p = buf;
    &#125;
    return *p++;
&#125;
#else
#define nec getchar
#endif
inline bool read(int &amp;x) &#123;
    char ch = nec();
    bool f = 0; x = 0;
    while (ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123;
        if (ch == EOF) return 0;
        if (ch == &#39;-&#39;) f = 1;
        ch = nec();
    &#125;
    while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) &#123;
        x = x * 10 + ch - &#39;0&#39;;
        ch = nec();
    &#125;
    if (f) x = -x;
    return 1;
&#125;
signed main() &#123;
    read(n); read(s);
    memset(f, 0x3f, sizeof (f));
    for (int i = 1; i &lt;= n; ++i) &#123;
        read(t[i]); read(c[i]);
        t[i] += t[i - 1];
        c[i] += c[i - 1];
    &#125;
    f[0] = 0;
    for (int i = 1; i &lt;= n; ++i) &#123;
        for (int j = 0; j &lt; i; ++j)
            f[i] = min(f[i], f[j] + t[i]* (c[i] - c[j]) + s * (c[n] - c[j]));
    &#125;
    printf(&quot;%lld&quot;, f[n]);
    return 0;
&#125;

任务安排 2
双倍经验
\(n\) 的范围变大了，\(n^2\) 过不了。
这不随手加个斜率优化的事儿吗。
我们继续瞎搞这个式子。 \[
\begin{aligned}
f_i&amp;=\min\{f_j+(c_i-c_j)\times t_i+s\times(c_n-c_j)\}
\\
&amp;=\min\{f_j+c_i\times t_i-c_j\times t_i+s\times c_n-s\times c_j\}
\\
&amp;=\min\{f_j-c_j\times t_i-s\times c_j\}+c_i\times t_i+s\times c_n
\end{aligned}
\] 令 \(j\) 优于 \(k\) 且 \(j&lt;k\) 。
则有： \[
f_j-c_j\times t_i-s\times c_j&lt;f_k-c_k\times t_i-s\times c_k
\\
f_j-f_k-s\times c_j+s\times c_k&lt;c_j\times t_i-c_k\times t_i
\\
f_j-f_k-s\times c_j+s\times c_k&lt;t_i\times(c_j-c_k)
\\
\dfrac{(f_j-s\times c_j)-(f_k-s\times c_k)}{(c_j)-(c_k)}&lt;t_i
\] 然后就是老套路。
时间复杂度 \(O(n)\)。
#include &lt;cstdio&gt;
#define int long long
const int maxn = 5e5 + 5;
const int LEN = (1 &lt;&lt; 20);
int n, s, L, R;
int f[maxn], t[maxn], c[maxn], q[maxn];
#define nec getchar
inline bool read(int &amp;x) &#123;
    char ch = nec();
    bool f = 0; x = 0;
    while (ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123;
        if (ch == EOF) return 0;
        if (ch == &#39;-&#39;) f = 1; ch = nec();
    &#125;
    while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) &#123;
        x = x * 10 + ch - &#39;0&#39;;
        ch = nec();
    &#125;
    if (f) x = -x;
    return 1;
&#125;
inline int getup(int j, int k) &#123; return (f[j] - s * c[j]) - (f[k] - s * c[k]); &#125;
inline int getdown(int j, int k) &#123; return (c[j]) - (c[k]); &#125;
inline int getDP(int i, int j) &#123; return f[j] + (c[i] - c[j]) * t[i] + s * (c[n] - c[j]); &#125;
signed main() &#123;
    read(n); read(s);
    L = R = 1;
    for (int i = 1; i &lt;= n; ++i) &#123;
        read(t[i]); read(c[i]);
        t[i] += t[i - 1];
        c[i] += c[i - 1];
    &#125;
    for (int i = 1; i &lt;= n; ++i) &#123;
        while (L &lt; R &amp;&amp; getup(q[L + 1], q[L]) &lt;= t[i] * getdown(q[L + 1], q[L]))
            ++L;
        f[i] = getDP(i, q[L]);
        while (L &lt; R &amp;&amp; getup(i, q[R]) * getdown(q[R], q[R - 1]) &lt;= getdown(i, q[R]) * getup(q[R], q[R - 1]))
            --R;
        q[++R] = i;
    &#125;
    printf(&quot;%lld&quot;, f[n]);
    return 0;
&#125;

任务安排 3
双倍经验 | 三倍经验
注意 \(t\) 有可能是负数。
\(t\) （输入）有可能为负，代表着 \(t\)（前缀和）不再单调递增，用不单调的对象作为单调队列的条件一看就十分不讲武德，这样维护出来的队头显然不是正确答案。
后面的 \(t,c\) 默认为前缀和。
我们感性证明一下。
一个最普通的例子，假设输入了一个负数，导致 \(t_i&lt;t_{i-1}\)，且有一斜率 \(&gt;t_i\) 且 \(&lt;t_{i-1}\)。
那么在 \(i-1\) 时，它就被维护队头的操作剔掉了，但也许它凑巧就是 \(i\) 的最优解，呜呼哀哉。
于是我们不能删队头元素了。那怎么查询最优解呢？
单调队列里装的始终还是个具有单调性的下凸包，于是我们可以在队列中二分一个 \(pos\)，\(pos\) 与 \(pos-1\) 形成的斜率比 \(t_i\) 小，\(pos+1\) 与 \(pos\) 形成的斜率比 \(t_i\) 大。
然后把 \(pos\) 当成 \(q_l\) 来处理就好了。
队尾还是维护一个下凸。
时间复杂度 \(O(n\log n)\)。
强烈建议不要去动 AcWing 版本的那道。
最后两组数据堪称毒瘤。
卡 long long 乘法，卡 __int128 时限，卡 double精度，非 T 即 WA。
反正我搞了半个小时硬是没有搞出来。
#include &lt;cstdio&gt;
#define int long long
const int maxn = 3e5 + 5;
const int LEN = (1 &lt;&lt; 20);
int n, s, L, R;
int f[maxn], t[maxn], c[maxn], q[maxn];
#define nec getchar
inline bool read(int &amp;x) &#123;
    char ch = nec();
    bool f = 0; x = 0;
    while (ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123;
        if (ch == EOF) return 0;
        if (ch == &#39;-&#39;) f = 1; ch = nec();
    &#125;
    while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) &#123;
        x = x * 10 + ch - &#39;0&#39;;
        ch = nec();
    &#125;
    if (f) x = -x;
    return 1;
&#125;
inline int getup(int j, int k) &#123; return (f[j] - s * c[j]) - (f[k] - s * c[k]); &#125;
inline int getdown(int j, int k) &#123; return (c[j]) - (c[k]); &#125;
inline int getDP(int i, int j) &#123; return f[j] + t[i] * (c[i] - c[j]) + s * (c[n] - c[j]); &#125;
inline int Func(int u) &#123;
    if (L == R) return q[L];
    int l = L, r = R;
    while (l &lt; r) &#123;
        int mid = l + r &gt;&gt; 1;
        if (getup(q[mid + 1], q[mid]) &lt;= u * getdown(q[mid + 1], q[mid]))
            l = mid + 1;
        else r = mid;
    &#125;
    return l;
&#125;
signed main() &#123;
    read(n); read(s);
    L = R = 1;
    for (int i = 1; i &lt;= n; ++i) &#123;
        read(t[i]); read(c[i]);
        t[i] += t[i - 1];
        c[i] += c[i - 1];
    &#125;
    for (int i = 1; i &lt;= n; ++i) &#123;
        int Best = Func(t[i]);
        f[i] = getDP(i, q[Best]);
        while (L &lt; R &amp;&amp; getup(i, q[R]) * getdown(q[R], q[R - 1]) &lt;= getdown(i, q[R]) * getup(q[R], q[R - 1]))
            --R;
        q[++R] = i;
    &#125;
    printf(&quot;%lld&quot;, f[n]);
    return 0;
&#125;

土地购买
首先我们想明白一件事情：如果一块土地，有另一块土地的长和宽都比它大，那就不用再理它了，直接从总序列里剔除。
struct _ &#123;
    int w, l;
    bool operator&lt; (const _ q) const &#123;
        return w == q.w ? l &gt; q.l : w &gt; q.w;
    &#125;
&#125; a[maxn];
...

std::sort(a + 1, a + n + 1);
for (int i = 1; i &lt;= n; ++i) &#123;
    if (a[i].l &gt; a[cnt].l)
        a[++cnt] = a[i];
&#125;
然后就推式子。
贪心地想，在前面的操作后，\(a\) 是一个 \(w\) 递减，\(l\) 递增的土地序列。
所以我们选择将连续的一段区间分为一组，这样的话，一个组里的一段连续的土地 \([x,y]\) 就只有 \(w_x\) 和 \(l_y\) 起了作用，又没有中间那一段的事了。
设 \(f_i\) 表示分配完第 \(i\) 块土地后的最小花费。
则有： \[
f_i=\min\{f_j+w_{j+1}\times l_i\}
\] 令 \(j\) 优于 \(k\)。
则有： \[
f_j+w_{j+1}\times l_i&lt;f_k+w_{k+1}\times l_i
\\
f_j-f_k&lt;(-w_{j+1}+w_{k+1})\times l_i
\\
\dfrac{(f_j)-(f_k)}{(-w_{j+1})+(w_{k+1})}&lt;l_i
\]
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#define int long long
const int maxn = 5e4 + 5;
struct _ &#123;
    int w, l;
    bool operator&lt; (const _ q) const&#123;
        return w == q.w ? l &gt; q.l : w &gt; q.w;
    &#125;
&#125;;
_ a[maxn];
int n, cnt, l, r;
int q[maxn], f[maxn];
int getup(int j, int k) &#123; return f[j] - f[k]; &#125;
int getdown(int j,int k) &#123; return a[k + 1].w - a[j + 1].w; &#125;
int getDP(int i,int j) &#123; return f[j] + a[j + 1].w * a[i].l; &#125;
signed main() &#123;
    scanf(&quot;%lld&quot;, &amp;n);
    for(int i = 1; i &lt;= n; ++i)
        scanf(&quot;%lld %lld&quot;, &amp;a[i].w, &amp;a[i].l);
    std::sort(a + 1, a + n + 1);
    for (int i = 1; i &lt;= n; ++i) &#123;
        if (a[i].l &gt; a[cnt].l)
            a[++cnt] = a[i];
    &#125;
    n = cnt; l = r = 1;
    for (int i = 1; i &lt;= n; ++i) &#123;
        while (l &lt; r &amp;&amp; getup(q[l + 1], q[l]) &lt;= a[i].l * getdown(q[l + 1], q[l]))
            l++;
        f[i] = getDP(i, q[l]);
        while (l &lt; r &amp;&amp; getup(i, q[r]) * getdown(q[r], q[r - 1]) &lt;= getup(q[r],q[r - 1]) * getdown(i, q[r]))
            r--;
        q[++r] = i;
    &#125;
    printf(&quot;%lld&quot;, f[n]);
    return 0;
&#125;

仓库建设
双倍经验 | 三倍经验
设 \(f_i\) 表示在 \(i\) 工厂建立仓库的最小花费。
则有： \[
\begin{aligned}
f_i&amp;=\min\{f_j+\sum\limits_{k=j+1}^{i-1}[(x_i-x_k)\times p_k]+c_i\}
\\
&amp;=\min\{f_j+\sum\limits_{k=j+1}^{i-1}(x_i\times p_k)-\sum\limits_{k=j+1}^{i-1}(x_k\times p_k)\}+c_i
\\
&amp;=\min\{f_j+x_i\times\sum\limits_{k=j+1}^{i-1}p_k-\sum\limits_{k=j+1}^{i-1}(x_k\times p_k)\}+c_i
\end{aligned}
\] 利用前缀和优化：设 \(a\) 为 \(p\) 的前缀和数组，\(b\) 为 \(x_i\times p_i\) 的前缀和数组。
则原式可化为： \[
\begin{aligned}
f_i&amp;=\min\{f_j+x_i\times(a_{i-1}-a_j)-(b_{i-1}-b_j)\}+c_i
\\
&amp;=\min\{f_j+x_i\times a_{i-1}-x_i\times a_j-b_{i-1}+b_j\}+c_i
\\
&amp;=\min\{f_j-x_i\times a_j+b_j\}+x_i\times a_{i-1}-b_{i-1}+c_i
\end{aligned}
\] 令 \(j\) 优于 \(k\) 。
则有： \[
f_j-x_i\times a_j+b_j&lt;f_k-x_i\times a_k+b_k
\\
f_j-f_k+b_j-b_k&lt;x_i\times a_j-x_i\times a_k
\\
\dfrac{(f_j+b_j)-(f_k+b_k)}{a_j-a_k}&lt;x_i
\]
想感受人生的同学们可以尝试做一下 AcWing 那个版本，非 MLE 即 WA，爽到炸。
#include &lt;cstdio&gt;
#define int long long
const int maxn = 1e6 + 5;
const int LEN = (1 &lt;&lt; 20);
int n, L, R;
int f[maxn], x[maxn], p[maxn];
int a[maxn], b[maxn], c[maxn], q[maxn];
#ifdef ONLINE_JUDGE
inline int nec(void) &#123;
    static char buf[LEN], *p = buf, *e = buf;
    if (p == e) &#123;
        e = buf + fread(buf, 1, LEN, stdin);
        if (e == buf) return EOF; p = buf;
    &#125;
    return *p++;
&#125;
#else
#define nec getchar
#endif
inline bool read(int &amp;x) &#123;
    char ch = nec();
    bool f = 0; x = 0;
    while (ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123;
        if (ch == EOF) return 0;
        if (ch == &#39;-&#39;) f = 1;
        ch = nec();
    &#125;
    while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) &#123;
        x = x * 10 + ch - &#39;0&#39;;
        ch = nec();
    &#125;
    if (f) x = -x;
    return 1;
&#125;
inline int getup(int j, int k) &#123; return (f[j] + b[j]) - (f[k] + b[k]); &#125;
inline int getdown(int j, int k) &#123; return (a[j]) - (a[k]); &#125;
inline int getDP(int i, int j) &#123; return f[j] - x[i] * a[j] + b[j] + x[i] * a[i - 1] - b[i - 1] + c[i]; &#125;
signed main() &#123;
    read(n); L = R = 1;
    for (int i = 1; i &lt;= n; ++i) &#123;
        read(x[i]); read(p[i]); read(c[i]);
        a[i] = a[i - 1] + p[i];
        b[i] = b[i - 1] + x[i] * p[i];
    &#125;
    for (int i = 1; i &lt;= n; ++i) &#123;
        while (L &lt; R &amp;&amp; getup(q[L + 1], q[L]) &lt;= x[i] * getdown(q[L + 1], q[L]))
            ++L;
        f[i] = getDP(i, q[L]);
        while (L &lt; R &amp;&amp; getup(i, q[R]) * getdown(q[R], q[R - 1]) &lt;= getdown(i, q[R]) * getup(q[R], q[R - 1]))
            --R;
        q[++R] = i;
    &#125;
    printf(&quot;%lld&quot;, f[n]);
    return 0;
&#125;

锯木厂选址
双倍经验 | 三倍经验
和仓库建设很像。
设 \(A_i=\sum\limits_{j=i}^nd_j\)，表示第 \(i\) 棵树与山脚的距离；\(B_i=\sum\limits_{j=1}^iw_j\)，表示 \(w\) 的前缀和；\(S=\sum\limits_{i=1}^nA_i\times w_i\)，表示将所有树全部运到山脚的花费总和。
假设在 \(j\) 处建立第 \(1\) 座锯木厂，在 \(i\) 处建立第 \(2\) 座锯木厂，此时：

对于第 \(1\sim j\) 棵树来说，\(S\) 比实际情况多运了 \(A_j\) 的路程；
对于第 \(j+1\sim i\) 棵树来说，\(S\) 比实际情况多运了 \(A_i\) 的路程。

将对应的多运的距离与花费相乘的结果，让 \(S\) 将其减去即可。 \[
\begin{aligned}
ans&amp;=\min\{S-A_j\times B_j-(B_i-B_j)\times A_i\}\\
   &amp;=\min\{A_i\times B_j-A_j\times B_j\}+S-A_i\times B_i
\end{aligned}
\] 令 \(j&lt;k\) 且 \(j\) 优于 \(k\)，则有： \[
\begin{aligned}
A_i\times B_j-A_j\times B_j&amp;&lt;A_i\times B_k-A_k\times B_k\\
-A_j\times B_j+A_k\times B_k&amp;&lt;-A_i\times B_j+A_i\times B_k\\
\dfrac{-A_j\times B_j+A_k\times B_k}{-B_j+B_k}&amp;&lt;A_i\\
\dfrac{A_j\times B_j-A_k\times B_k}{B_j-B_k}&amp;&lt;A_i\\
\end{aligned}
\] 其中，\(A_i\) 具有单调性，可以直接套板子。
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#define int long long
const int inf = 1e18;
const int maxn = 1e6 + 5;
const int LEN = (1 &lt;&lt; 20);
int w[maxn], d[maxn];
int n, L, R, s, ans = inf;
int q[maxn], a[maxn], b[maxn];
inline int min(int x, int y) &#123; return x &lt; y ? x : y; &#125;
inline int getDP(int i, int j) &#123;
    return s - a[j] * b[j] - (b[i] - b[j]) * a[i];
&#125;
inline int getup(int j, int k) &#123;
    return a[j] * b[j] - a[k] * b[k];
&#125;
inline int getdown(int j, int k) &#123;
    return b[j] - b[k];
&#125;
#ifdef ONLINE_JUDGE
inline int nec(void) &#123;
    static char buf[LEN], *p = buf, *e = buf;
    if (p == e) &#123;
        e = buf + fread(buf, 1, LEN, stdin);
        if (e == buf) return EOF; p = buf;
    &#125;
    return *p++;
&#125;
#else
#define nec getchar
#endif
inline bool read(int &amp;x) &#123;
    char ch = nec();
    bool f = 0; x = 0;
    while (ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123;
        if (ch == EOF) return 0;
        if (ch == &#39;-&#39;) f = 1;
        ch = nec();
    &#125;
    while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) &#123;
        x = x * 10 + ch - &#39;0&#39;;
        ch = nec();
    &#125;
    if (f) x = -x;
    return 1;
&#125;
signed main() &#123;
    read(n);
    L = R = 1;
    for (int i = 1; i &lt;= n; ++i) &#123;
        read(w[i]), read(d[i]);
        b[i] = b[i - 1] + w[i];
    &#125;
    for (int i = n; i; --i) &#123;
        a[i] = a[i + 1] + d[i];
        s += a[i] * w[i];
    &#125;
    for (int i = 1; i &lt;= n; ++i) &#123;
        while (L &lt; R &amp;&amp; getup(q[L + 1], q[L]) &gt;= a[i] * getdown(q[L + 1], q[L]))
            ++L;
        ans = min(ans, getDP(i, q[L]));
        while (L &lt; R &amp;&amp; getup(i, q[R]) * getdown(q[R], q[R - 1]) &gt;= getup(q[R], q[R - 1]) * getdown(i, q[R]))
            --R;
        q[++R] = i;
    &#125;
    printf(&quot;%lld&quot;, ans);
    return 0;
&#125;

Cats Transport
双倍经验 | 三倍经验
经验：洛谷的题面比蓝书和 AcWing 上的标准多了，蓝书的题意不清。
研究表明，边猛灌养乐多边看蓝书有助于理解。
这道题难在推式子。不然还能难在哪里
设 \(A_i\) 表示要接到第 \(i\) 只猫的最早出发时间，也就是说，在此时出发，猫 \(i\) 的等待时间为 \(0\)。
即 \(A_i=T_i-\sum\limits_{j=1}^{H_i}D_j\)，也就是出发时间=到达时间-经过时间。
此时我们可以把其他所有因素去掉，题意转换为：

已知在 \(\geqslant A_i\) 的时刻出发可以接到猫 \(i\) ，在 \(P\) 次出发次数的限制内接到所有猫，猫的等待时间之和最小是多少？

假设饲养员在 \(t\) 时刻出发，猫 \(i\) 的等待时间就是 \(t-A_i\)。
对 \(A_i\) 从小到大排序。
显然，一次接一段连续的猫，花费自然是最小的。
若我们要接 \([k+1,j]\) 范围内的猫，它们的等待时间之和就是： \[
\begin{aligned}
\sum\limits_{p=k+1}^{j}(A_j-A_p)&amp;=[j-(k+1)+1]A_j-\sum\limits_{p=k+1}^{j}A_p
\\
&amp;=(j-k)\times A_j-(S_j-S_k)
\\
&amp;=j\times A_j-k\times A_j-S_j+S_k
\end{aligned}
\] 其中 \(S\) 为 \(A\) 的前缀和。
设 \(f_{i,j}\) 表示前 \(i\) 个饲养员带走前 \(j\) 只猫的最小花费。
则有： \[
\begin{aligned}
f_{i,j}&amp;=\min\{f_{i-1,k}+j\times A_j-k\times A_j-S_j+S_k\}
\\
&amp;=\min\{f_{i-1,k}-A_j\times k+S_k\}+A_j\times j-S_j
\end{aligned}
\]
我们将循环地枚举每个饲养员的循环变量 \(i\) 看做常量。
令 \(x\) 优于 \(y\)，则有： \[
f_{i-1,x}-A_j\times x+S_x&lt;f_{i-1,y}-A_j\times y+S_y
\\
\dfrac{(f_{i-1,x}+S_x)-(f_{i-1,y+S_y})}{x-y}&lt;A_j
\] 注意事项
\(f\) 初始化为极大值。
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#define int long long
const int maxp = 105;
const int maxn = 1e5 + 5;
const int LEN = (1 &lt;&lt; 20);
int f[maxp][maxn];
int n, m, p, L, R, t, h;
int q[maxn], a[maxn], d[maxn], s[maxn];
inline int getDP(int i, int j, int k) &#123;
    return f[i - 1][k] + (j - k) * a[j] - (s[j] - s[k]);
&#125;
inline int getup(int i, int j, int k) &#123;
    return (f[i - 1][j] + s[j]) - (f[i - 1][k] + s[k]);
&#125;
inline int getdown(int j, int k) &#123;
    return (j) - (k);
&#125;
#ifdef ONLINE_JUDGE
inline int nec(void) &#123;
    static char buf[LEN], *p = buf, *e = buf;
    if (p == e) &#123;
        e = buf + fread(buf, 1, LEN, stdin);
        if (e == buf) return EOF; p = buf;
    &#125;
    return *p++;
&#125;
#else
#define nec getchar
#endif
inline bool read(int &amp;x) &#123;
    char ch = nec();
    bool f = 0; x = 0;
    while (ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123;
        if (ch == EOF) return 0;
        if (ch == &#39;-&#39;) f = 1;
        ch = nec();
    &#125;
    while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) &#123;
        x = x * 10 + ch - &#39;0&#39;;
        ch = nec();
    &#125;
    if (f) x = -x;
    return 1;
&#125;
signed main() &#123;
    read(n); read(m); read(p);
    memset(f, 0x3f, sizeof (f));
    for (int i = 2; i &lt;= n; ++i)
        read(d[i]), d[i] += d[i - 1];
    for (int i = 1; i &lt;= m; ++i) &#123;
        read(h); read(t);
        a[i] = t - d[h];
    &#125;
    std::sort(a + 1, a + m + 1);
    for (int i = 1; i &lt;= m; ++i)
        s[i] = s[i - 1] + a[i];
    f[0][0] = 0;
    for (int i = 1; i &lt;= p; ++i) &#123;
        L = R = 1;
        for (int j = 1; j &lt;= m; ++j) &#123;
            while (L &lt; R &amp;&amp; getup(i, q[L + 1], q[L]) &lt;= a[j] * getdown(q[L + 1], q[L]))
                ++L;
            f[i][j] = getDP(i, j, q[L]);
            while (L &lt; R &amp;&amp; getup(i, j, q[R]) * getdown(q[R], q[R - 1]) &lt;= getup(i, q[R], q[R - 1]) * getdown(j, q[R]))
                --R;
            q[++R] = j;
        &#125;
    &#125;
    printf(&quot;%lld&quot;, f[p][m]);
    return 0;
&#125;

特别行动队
双倍经验 | 三倍经验
直接推式子。 \[
\begin{aligned}
f_i&amp;=\max\{f_j+a\times(s_i-s_j)^2+b\times(s_i-s_j)+c\ \}\\
&amp;=\max\{f_j+a\times({s_i}^2-2\times s_i\times s_j+{s_j}^2)+b\times s_i-b\times s_j\ \}+c\\
&amp;=\max\{f_j+a\times{s_i}^2-2\times a\times s_i\times s_j+a\times{s_j}^2-b\times s_j\ \}+b\times s_i+c\\
&amp;=\max\{f_j-2\times a\times s_i\times s_j+a\times{s_j}^2-b\times s_j\ \}+a\times{s_i}^2+b\times s_i+c\\
\end{aligned}
\] 令 \(j\) 优于 \(k\)，则有： \[
\begin{aligned}
f_j-2\times a\times s_i\times s_j+a\times{s_j}^2-b\times s_j&amp;&gt;f_k-2\times a\times s_i\times s_k+a\times{s_k}^2-b\times s_k\\
(f_j+a\times{s_j}^2-b\times s_j)-(f_k+a\times{s_k}^2-b\times s_k)&amp;&gt;(2\times a\times s_i\times s_j)-(2\times a\times s_i\times s_k)\\
\dfrac{(f_j+a\times{s_j}^2-b\times s_j)-(f_k+a\times{s_k}^2-b\times s_k)}{(2\times a\times s_j) - (2\times a\times s_k)}&amp;&gt;s_i\\
\end{aligned}
\] 我们发现中间的符号是 \(&gt;\)。
所以我们在弹队头的时候，要把判断条件中的符号反过来。
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#define int long long
const int maxn = 1e6 + 5;
const int LEN = (1 &lt;&lt; 20);
int n, L, R, a, b ,c;
int q[maxn], s[maxn], f[maxn];
inline int getDP(int i, int j) &#123;
    return f[j] + a * (s[i] - s[j]) * (s[i] - s[j]) + b * (s[i] - s[j]) + c;
&#125;
inline int getup(int j, int k) &#123;
    return (f[j] + a * s[j] * s[j] - b * s[j]) - (f[k] + a * s[k] * s[k] - b * s[k]);
&#125;
inline int getdown(int j, int k) &#123;
    return (2 * a * s[j]) - (2 * a * s[k]);
&#125;
#ifdef ONLINE_JUDGE
inline int nec(void) &#123;
    static char buf[LEN], *p = buf, *e = buf;
    if (p == e) &#123;
        e = buf + fread(buf, 1, LEN, stdin);
        if (e == buf) return EOF; p = buf;
    &#125;
    return *p++;
&#125;
#else
#define nec getchar
#endif
inline bool read(int &amp;x) &#123;
    char ch = nec();
    bool f = 0; x = 0;
    while (ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123;
        if (ch == EOF) return 0;
        if (ch == &#39;-&#39;) f = 1;
        ch = nec();
    &#125;
    while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) &#123;
        x = x * 10 + ch - &#39;0&#39;;
        ch = nec();
    &#125;
    if (f) x = -x;
    return 1;
&#125;
signed main() &#123;
    read(n); read(a); read(b); read(c);
    L = R = 1;
    for (int i = 1; i &lt;= n; ++i) &#123;
        read(s[i]), s[i] += s[i - 1];
        while (L &lt; R &amp;&amp; getup(q[L + 1], q[L]) &gt;= s[i] * getdown(q[L + 1], q[L]))
            ++L;
        f[i] = getDP(i, q[L]);
        while (L &lt; R &amp;&amp; getup(i, q[R]) * getdown(q[R], q[R - 1]) &lt;= getup(q[R], q[R - 1]) * getdown(i, q[R]))
            --R;
        q[++R] = i;
    &#125;
    printf(&quot;%lld&quot;, f[n]);
    return 0;
&#125;

征途
双倍经验 | 三倍经验
明显，不化掉 \(v\times m^2\) 就无法进行优化。
设 \(x\) 为当前休息站点与上一休息站点的距离， \(x_0\) 为 \(x_1\sim x_n\) 的平均数，\(S\) 为 \(x\) 的前缀和。 \[
\begin{aligned}
V\times m^2&amp;=[(x_1-x_0)^2+(x_2-x_0)^2+\cdots+(x_m-x_0)^2]\times m
\\
&amp;=m\times \sum\limits_{i=1}^{m}{x_i}^2+(m\times {x_0})^2-2\times (x_0\times m)\times \sum\limits_{i=1}^{m}x_i
\\
&amp;=m\times \sum\limits_{i=1}^{m}{x_i}^2+{S_m}^2-2\times{S_m}^2
\\
&amp;=m\times \sum\limits_{i=1}^{m}{x_i}^2-{S_m}^2
\end{aligned}
\]
其中 \(S_m\) 是一个定值（即输入所有路的长度和）。
唯一需要计算的，就是 \(\sum\limits_{i=1}^{m}{x_i}^{2}\)，所以我们就来 DP 它。
设 \(a\) 为输入道路长度的前缀和数组，\(f_{i,j}\) 表示第 \(i\) 次休息在 \(j\) 处时 \(\min\{\sum\limits_{k=1}^{i}{x_k}^2\}\) 的值，则有： \[
\begin{aligned}
f_{i,j}&amp;=\min\{f_{i-1,j}+(a_i-a_j)^2\}
\\
&amp;=\min\{f_{i-1,j}+{a_i}^2-2\times a_i\times a_j+{a_j}^2\}
\end{aligned}
\] 令 \(j\) 优于 \(k\)，则有： \[
f_{i-1,j}-2\times a_i\times a_j+{a_j}^2&lt;f_{i-1,k}-2\times a_i\times a_k+{a_k}^2
\\
f_{i-1,j}-f_{i-1,k}+{a_j}^2-{a_k}^2&lt;2\times a_i\times(a_j-a_k)
\\
\dfrac{f_{i-1,j}-f_{i-1,k}+{a_j}^2-{a_k}^2}{2\times(a_j-a_k)}&lt;a_i
\]
初始化。
将 \(f\) 初始化为极大值。
在 AcWing 上将 memset 改为初始化 f[0][i] = a[i] * a[i] 就可以过了，不然会 MLE，也许是因为没开滚动。（本来也用不着滚
#include &lt;cstdio&gt;
#define int long long
const int inf = 1e18;
const int maxn = 3005;
const int LEN = (1 &lt;&lt; 20);
int f[maxn][maxn];
int a[maxn], q[maxn];
int n, m, L, R, ans = inf;
#ifdef ONLINE_JUDGE
inline int nec(void) &#123;
    static char buf[LEN], *p = buf, *e = buf;
    if (p == e) &#123;
        e = buf + fread(buf, 1, LEN, stdin);
        if (e == buf) return EOF; p = buf;
    &#125;
    return *p++;
&#125;
#else
#define nec getchar
#endif
inline bool read(int &amp;x) &#123;
    char ch = nec();
    bool f = 0; x = 0;
    while (ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123;
        if (ch == EOF) return 0;
        if (ch == &#39;-&#39;) f = 1;
        ch = nec();
    &#125;
    while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) &#123;
        x = x * 10 + ch - &#39;0&#39;;
        ch = nec();
    &#125;
    if (f) x = -x;
    return 1;
&#125;
inline int min(int x, int y) &#123; return x &lt; y ? x : y; &#125;
int getDP(int i, int j, int k) &#123;
    return f[k - 1][j] + (a[i] - a[j]) * (a[i] - a[j]);
&#125;
int getup(int j, int k, int i) &#123;
    return f[i - 1][j] - f[i - 1][k] + a[j] * a[j] - a[k] * a[k];
&#125;
int getdown(int j, int k) &#123;
    return (a[j] - a[k]) &lt;&lt; 1;
&#125;
signed main()&#123;
    read(n); read(m);
    for (int i = 1; i &lt;= n; ++i) &#123;
        read(a[i]);
        a[i] += a[i - 1];
        f[0][i] = a[i] * a[i];
    &#125;
    for (int i = 1; i &lt; m; ++i) &#123;
        L = R = 1; q[L] = i;
        for (int j = i; j &lt;= n; ++j) &#123;
            while (L &lt; R &amp;&amp; getup(q[L + 1], q[L], i) &lt;= a[j] * getdown(q[L + 1], q[L]))
                ++L;
            f[i][j] = getDP(j, q[L], i);
            while (L &lt; R &amp;&amp; getup(i, q[R], i) * getdown(q[R], q[R - 1]) &lt;= getup(q[R], q[R - 1], i) * getdown(i, q[R]))
                --R;
            q[++R] = j;
        &#125;
    &#125;
    printf(&quot;%lld&quot;,m * f[m - 1][n] - a[n] * a[n]);
    return 0;
&#125;

柠檬
双倍经验
是边写这篇题解边做的（
题意：
有一个含有 \(n\) 个元素的序列 \(s\)。将这个序列分成连续的若干段，定义每一段的价值为「在这一段当中任选某个元素的个数的平方再乘上这个元素」的最大值。求将 \(s\) 划分后的最大价值。
不难想到分成的每一段首尾元素必须相等。
比如有这样一个序列 \(x,a_1,a_2,a_3,\cdots,a_k,x,y\) 。假设我们求的是这一段包含 \(x\) 的个数的平方，那么完全可以将 \(y\) 从这一段中分离，单独为一段，明显更优。
而其他所有情况都是这种情况的拓展。
于是得到式子： \[
f_i=\max\{f_{j-1}+s_i\times(cnt_i-cnt_j+1)^2\}
\] 其中 \(cnt_i\) 为 \(s_i\) 已经出现了多少次。
然后就是套路。 \[
\begin{aligned}
f_i&amp;=\max\{f_{j-1}+s_i\times({cnt_i}^2+{cnt_j}^2-2\times cnt_i\times cnt_j+2\times cnt_i-2\times cnt_j+1)\}
\\
&amp;=\max\{f_{j-1}+s_i\times{cnt_i}^2+s_i\times{cnt_j}^2-2\times s_i\times cnt_i\times cnt_j+2\times s_i\times cnt_i-2\times s_i\times cnt_j+s_i\}
\\
&amp;=\max\{f_{j-1}+s_i\times {cnt_j}^2-2\times s_i\times cnt_i\times cnt_j-2\times s_i\times cnt_j\}+s_i\times {cnt_i}^2+2\times s_i\times cnt_i+s_i
\end{aligned}
\] 这次不是 \(\min\)，而是 \(\max\)，我们还能像以前那样推吗？
不急，我们先按以前的方法试试，见机行事。
令 \(j\) 优于 \(k\)，则有： \[
f_{j-1}+s_i\times {cnt_j}^2-2\times s_i\times cnt_i\times cnt_j-2\times s_i\times cnt_j&gt;f_{k-1}+s_i\times {cnt_k}^2-2\times s_i\times cnt_i\times cnt_k-2\times s_i\times cnt_k
\] 暴力搞不出来，因为那个 \(s_i\) 乘上的平方项。
那我们想一个办法，把 \(s_i\) 给灭掉就行了。
既然我们已知一段的首尾元素必须相等，那不就说明 \(s_i,s_j,s_k\) 可以相互替换吗？
继续搞。 \[
f_{j-1}+s_j\times {cnt_j}^2-2\times s_i\times cnt_i\times cnt_j-2\times s_j\times cnt_j&gt;f_{k-1}+s_k\times {cnt_k}^2-2\times s_i\times cnt_i\times cnt_k-2\times s_k\times cnt_k
\\
f_{j-1}-f_{k-1}+s_j\times {cnt_j}^2-s_k\times {cnt_k}^2-2\times s_j\times cnt_j+2\times s_k\times cnt_k&gt;2\times s_i\times cnt_i\times cnt_j-2\times s_i\times cnt_i\times cnt_k
\\
\dfrac{f_{j-1}-f_{k-1}+s_j\times {cnt_j}^2-s_k\times {cnt_k}^2-2\times s_j\times cnt_j+2\times s_k\times cnt_k}{cnt_j-cnt_k}&gt;2\times s_i\times cnt_i
\]
这里的符号变成 \(&gt;\) 了。
易得，这里要维护的是一个斜率单调递减的上凸包最优解序列。
因为 \(s_i\) 必须与 \(s_j,s_k\) 相同，明显要针对每个 \(s_i\) 维护不同的最优解序列，在每次对应的序列中计算。
维护的斜率单调递减，而对于每一个相等的 \(s_i\)， \(2\times s_i\times cnt_i\) 一定是单调递增的，导致了这个序列大概长这个样子：斜率单调递减，但末尾的最小的斜率仍大于 \(2\times s_i\times cnt_i\)。
单调栈可以自行研究，因为作者瞄了一眼时间发现已经是明天了。（什
#include&lt;cstdio&gt;
#include&lt;vector&gt;
using namespace std;
#define int long long
#define top q[x].size() - 1
const int maxn = 1e5 + 5;
const int maxm = 1e4 + 5;
int n;
vector&lt;int&gt; q[maxm]; // 不用 vector 会 MLE
int f[maxn], s[maxn];
int cnt[maxn], tot[maxm];
int getDP(int i,int j)&#123;
    return f[j-1]+(cnt[i]-cnt[j]+1)*(cnt[i]-cnt[j]+1)*s[i];
&#125;
int getup(int j,int k)&#123;
    return f[j-1]-f[k-1]+s[j]*cnt[j]*cnt[j]-s[k]*cnt[k]*cnt[k]-2*s[j]*cnt[j]+2*s[k]*cnt[k];
&#125;
int getdown(int j,int k)&#123;
    return cnt[j]-cnt[k];
&#125;
signed main()&#123;
    scanf(&quot;%lld&quot;,&amp;n);
    for(int i=1;i&lt;=n;++i)&#123;
        scanf(&quot;%lld&quot;,&amp;s[i]);
        cnt[i]=++tot[s[i]];
    &#125;
    for(int i=1;i&lt;=n;++i)&#123;
        int x=s[i];
        while(q[x].size()&gt;=2&amp;&amp;getup(q[x][top-1],i)*getdown(q[x][top-1],q[x][top])&gt;=getup(q[x][top-1],q[x][top])*getdown(q[x][top-1],i))
            q[x].pop_back();
        q[x].push_back(i);
        while(q[x].size()&gt;=2&amp;&amp;getDP(i,q[x][top])&lt;=getDP(i,q[x][top-1]))
            q[x].pop_back();
        f[i]=getDP(i,q[x][top]);
    &#125;
    printf(&quot;%lld&quot;,f[n]);
    return 0;
&#125;

总结
总结斜优的步骤：

推 DP 式子
对式子进行巧妙的优化，使其易于化简
假设 \(j\) 优于 \(k\)，将式子化成 \(\dfrac{(j)-(k)}{(j)-(k)}&gt; \text{or} &lt;x\) 的形式
单调队列或单调栈优化

]]></content>
      <tags>
        <tag>斜率优化</tag>
      </tags>
  </entry>
  <entry>
    <title>解题报告：One-Dimensional Battle Ships</title>
    <url>/20220808/</url>
    <content><![CDATA[老题解批量补档。


图论题中的时光倒流

主要体现在只存在删边操作，且可离线的题目。
核心思想在于删边是及其不方便维护的，而加边可以用并查集等手段快速维护。
如果信息与连通块有关且方便合并就可以用并查集做。


One-Dimensional Battle Ships
https://www.luogu.com.cn/problem/CF567D

「某一时刻是否一定被击中过」具有单调性，考虑时光倒流：
先提前发射所有炮弹，倒序枚举炮弹，不断「撤销」当前最后一发炮弹的发射，如果在「撤销」这发炮弹后，存在任意一种放下 \(k\) 艘完整的战舰的方案，说明在发射这一发炮弹之后绝对能够击中。
如果发射所有炮弹后，依然存在一种放下 \(k\) 艘完整的战舰的方案，则无解。
具体实现可以使用并查集维护连通块大小：
每「撤销」一发炮弹的发射相当于合并三个连通块：炮弹的落点、落点的前一个元素（若不存在或已被炮弹摧毁则忽略）、落点的后一个元素（若不存在或已被炮弹摧毁则忽略）。
设某连通块大小为 \(x\)，可容纳战舰数为 \(res\)，显然有 \(res = \lfloor (x + 1) \div (p + 1) \rfloor\)。
记统计当前可容纳战舰的数量为 \(ans\)，在并查集合并时，\(ans\) 分别减去两个待合并连通块的可容纳战舰的数量，再加上新连通块可容纳战舰的数量。最靠后的 \(ans\ge k\) 的时刻即为所求。
同时使用路径压缩和按秩合并，时空复杂度均为 \(O(n)\)。优于 multiset 解法。


namespace XSC062 &#123;
using namespace fastIO;
const int maxn = 2e5 + 15;
bool vis[maxn];
int n, k, p, m, x, ans;
int a[maxn], f[maxn], siz[maxn];
inline void swap(int &amp;x, int &amp;y)&#123;
    x ^= y ^= x ^= y;
    return 0;
&#125;
inline int calc(int x) &#123;
    return (x + 1) / (p + 1);
&#125;
inline void Init(int n) &#123;
    for (int i = 1; i &lt;= n; ++i) &#123;
        f[i] = i;
        siz[i] = 1;
    &#125;
    return;
&#125;
int find(int x) &#123;
    return x == f[x] ? x : f[x] = find(f[x]);
&#125;
inline void merge(int x, int y) &#123;
    int fx = find(x);
    int fy = find(y);
    if (fx == fy)
        return;
    ans -= calc(siz[fx]);
    ans -= calc(siz[fy]);
    if (siz[fy] &gt; siz[fx])
        swap(fx, fy);
    ans += calc(siz[fy]);
    f[fx] = fy;
    return;
&#125;
int main() &#123;
    read(n);
    read(k);
    read(p);
    read(m);
    Init(n + 5);
    ans = (n - m) * (2 / (p + 1));
    for (int i = 1; i &lt;= m; ++i) &#123;
        read(a[i]);
        vis[a[i]] = 1;
    &#125;
    for (int i = 1; i &lt;= n; ++i) &#123;
        if (vis[i] || vis[i - 1])
            continue;
        merge(i, i - 1);
    &#125; 
    if (ans &gt;= k) &#123;
        puts(&quot;-1&quot;);
        return 0;
    &#125;
    for (int i = m; i; --i) &#123;
        vis[a[i]] = 0;
        ans += 2 / (p + 1);
        if (a[i] - 1 &amp;&amp; !vis[a[i] - 1])
            merge(a[i], a[i] - 1);
        if (a[i] + 1 &lt;= n &amp;&amp; !vis[a[i] + 1])
            merge(a[i], a[i] + 1);
        if (ans &gt;= k) &#123;
            printf(&quot;%d&quot;, i);
            return 0;
        &#125;
    &#125;
    puts(&quot;-1&quot;);
    return 0;
&#125;
&#125; // namespace XSC062
int main() &#123;
    XSC062::main();
    return 0;
&#125;

]]></content>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>解题报告：博弈</title>
    <url>/20221010/</url>
    <content><![CDATA[老题解批量补档。


博弈

给定一棵带权树，将 \((u,v)\) 间简单路径上的边权生成数组，两个人在数组中轮流选数，每次选走的数必须 \(\le\) 上一个人选走的数，不能选的人输，问有多少个 \((u,v)\) 满足先手必胜。

如果在 \((u, v)\) 的路径上有任何一种边权的数量是奇数，那么就要统计 \((u,v)\)。
对于最小的、出现次数为奇数的边权 \(w\)，先手选择 \(w\)，此时剩下偶数个可选项。后手选择 \(w&#39;\)，这会删除 \(&gt;w&#39;\) 且 \(\le w\) 的所有可选项。发现被删掉偶数个选项；剩下奇数个选项。易知先手必胜。
若不存在出现次数为奇数的边权，从刚刚后手的处境可以看出先手必败。所以，问题就转化为了：统计点对 \((u, v)\) 的数量，满足 \(u\) 到 \(v\) 的简单路径中存在出现次数为奇数的边权。
给每个边权映射一个值，为 base 的 rand() 次方，自然溢出即可。然后直接按照之前的操作处理就好了。
如果一个你想找到类似于 1 ^ 2 ^ 3 = 0 的情况，其出现概率与数字的二进制位数有关。因为 xor 只针对于同一位，结果不会被上一位或下一位干扰，所以每一位出现异或起来为 \(0\) 的概率是 \(\dfrac 12\)。只要我们整点比较强力的 \(k\) 位二进制数，那么出现以上情况的概率就是 \(2^{-k}\)。
那么这个比较强力的 \(k\) 位二进制数，用比较强力的类字符串哈希生成方式，再使用一个很大很大的随机数替代字符串哈希中表示下标的 \(i\)，用自然溢出让它显得更加稳妥就好。所以现在我们程序寄掉的概率就是 \(\dfrac 1{2^{64}}\)，好事情啊好事情。
时间复杂度 \(O(n\log n)\)，\(\log n\) 来源于映射。

namespace XSC062 &#123;
using namespace fastIO;
const int _p = 13331;
const int maxn = 5e5 + 5;
struct _ &#123;
    int v;
    ull w;
    _ () &#123;&#125;
    _ (int v1, ull w1) &#123;
        v = v1, w = w1;
    &#125;
&#125;;
ull w;
ull f[maxn];
int T, n, x, y, ans;
std::map&lt;ull, int&gt; t;
std::map&lt;ull, ull&gt; q;
std::vector&lt;_&gt; g[maxn];
inline void Init(int n) &#123;
    t.clear();
    q.clear();
    for (int i = 1; i &lt;= n; ++i) &#123;
        f[i] = 0;
        g[i].clear();
        g[i].shrink_to_fit();
    &#125;
    return;
&#125;
void DFS(int x, int fa) &#123;
    ++t[f[x]];
    for (auto i : g[x]) &#123;
        if (i.v == fa)
            continue;
        f[i.v] = f[x] ^ i.w;
        DFS(i.v, x);
    &#125;
    return;
&#125;
inline void add(int x, int y, ull w) &#123;
    g[x].push_back(_(y, w));
    return;
&#125;
inline ull randint(void) &#123;
    ull res = rand();
    res *= rand();
    res *= rand();
    return res;
&#125;
inline ull qkp(ull x, ull y) &#123;
    ull res = 1;
    while (y) &#123;
        if (y &amp; 1)
            res *= x;
        x *= x;
        y &gt;&gt;= 1;
    &#125; 
    return res;
&#125;
int main() &#123;
    read(T);
    srand(time(NULL));
    while (T--) &#123;
        read(n);
        Init(n);
        ans = n * (n - 1) / 2;
        for (int i = 1; i &lt; n; ++i) &#123;
            read(x), read(y), read(w);
            if (!q.count(w))
                q[w] = qkp(_p, randint());
            w = q[w];
            add(x, y, w), add(y, x, w);
        &#125;
        DFS(1, -1);
        for (auto i : t)
            ans -= i.second * (i.second - 1) / 2;
        print(ans, &#39;\n&#39;);
    &#125;
    return 0;
&#125;
&#125; // namespace XSC062

]]></content>
      <tags>
        <tag>哈希</tag>
      </tags>
  </entry>
  <entry>
    <title>解题报告：瑰丽华尔兹</title>
    <url>/20230111/</url>
    <content><![CDATA[「NOI2005」瑰丽华尔兹。


单调队列优化 DP。
不难发现，题意可转化为：
从 \((x,y)\) 出发，按顺序向 \(d_i\) 方向移动 \([0,t_i−s_i+1]\) 距离，问最大移动距离。
为了方便描述，我们把一次「向 \(d_i\) 方向移动 \([0,t_i−s_i+1]\) 距离」的操作称为「一步」。
设计状态。不难发现位置信息必须出现在 DP 的维度中（因为当前位置会影响下一步滑动的距离），而其他信息均不会对下一步滑动产生影响。
故可令 \(f_{i,j}\) 表示完成当前次滑动后，从起点滑动到 \((i,j)\) 可得到的最大滑动距离。
以方向上为例，可列 DP 式：
\[
f_{i,j}=\max_{i&lt;k≤i+(ti−si+1)}\{f_{k,j}+k−i\}
\]
此时可枚举每一列的所有状态，使用单调队列优化。
但实际操作中会出现问题。因为单调队列从下向上更新状态时，\(f_{k,j}\) 会比 \(f_{i,j}\) 先更新（参考 01 背包倒序枚举容量），导致每一「步」会重复被走很多次。但单调队列的特性限制了我们只能从下向上枚举，此时可新开一个数组记录 \(f\) 当次被更新之前的值。
障碍物如何处理呢？我们知道，如果 \((i,j)\) 下面某一位置有障碍物，那么障碍物下面所有的 \((k,j)\) 都不能用于更新 \(f_{i,j}\)（因为被挡住了滑不上来）。所以我们在从下往上枚举时，遇到障碍物就清空单调队列即可。
下、左、右方向的处理方式类似。
只需顺序执行操作，根据当前操作方向对应处理即可。

namespace XSC062 &#123;
using namespace fastIO;
const int maxn = 205;
const int inf = 1e18;
int q[maxn];
char a[maxn][maxn];
int f[maxn][maxn], d[maxn][maxn];
int n, m, x, y, k, u, h, t, res;
int max(int x, int y) &#123;
    return x &gt; y ? x : y;
&#125;
int main() &#123;
    memset(f, -0x3f, sizeof (f));
    read(n), read(m);
    read(x), read(y), read(k);
    f[x][y] = 0;
    for (int i = 1; i &lt;= n; ++i)
        scanf(&quot;%s&quot;, a[i] + 1);
    while (k--) &#123;
        read(x), read(y), read(u);
        y = y - x + 1;
        if (u == 1) &#123;
            for (int j = 1; j &lt;= m; ++j) &#123;
                h = 1, t = 0;
                for (int i = n; i; --i) &#123;
                    if (a[i][j] == &#39;x&#39;) &#123;
                        h = 1, t = 0;
                        continue;
                    &#125;
                    while (h &lt;= t &amp;&amp; q[h] - i &gt; y)
                        ++h;
                    d[i][j] = f[i][j];
                    if (h &lt;= t) &#123;
                        f[i][j] = max(f[i][j],
                                    d[q[h]][j] + q[h] - i);
                    &#125;
                    while (h &lt;= t &amp;&amp; d[i][j] + i
                                    &gt;= d[q[t]][j] + q[t])
                        --t;
                    q[++t] = i;
                &#125;
            &#125;
        &#125;
        else if (u == 2) &#123;
            for (int j = 1; j &lt;= m; ++j) &#123;
                h = 1, t = 0;
                for (int i = 1; i &lt;= n; ++i) &#123;
                    if (a[i][j] == &#39;x&#39;) &#123;
                        h = 1, t = 0;
                        continue;
                    &#125;
                    while (h &lt;= t &amp;&amp; i - q[h] &gt; y)
                        ++h;
                    d[i][j] = f[i][j];
                    if (h &lt;= t) &#123;
                        f[i][j] = max(f[i][j],
                                    d[q[h]][j] + i - q[h]);
                    &#125;
                    while (h &lt;= t &amp;&amp; d[i][j] - i
                                &gt;= d[q[t]][j] - q[t])
                        --t;
                    q[++t] = i;
                &#125;
            &#125;
        &#125;
        else if (u == 3) &#123;
            for (int i = 1; i &lt;= n; ++i) &#123;
                h = 1, t = 0;
                for (int j = m; j; --j) &#123;
                    if (a[i][j] == &#39;x&#39;) &#123;
                        h = 1, t = 0;
                        continue;
                    &#125;
                    while (h &lt;= t &amp;&amp; q[h] - j &gt; y)
                        ++h;
                    d[i][j] = f[i][j];
                    if (h &lt;= t) &#123;
                        f[i][j] = max(f[i][j],
                                    d[i][q[h]] + q[h] - j);
                    &#125;
                    while (h &lt;= t &amp;&amp; d[i][j] + j
                                &gt;= d[i][q[t]] + q[t])
                        --t;
                    q[++t] = j;
                &#125;
            &#125;
        &#125;
        else &#123;
            for (int i = 1; i &lt;= n; ++i) &#123;
                h = 1, t = 0;
                for (int j = 1; j &lt;= m; ++j) &#123;
                    if (a[i][j] == &#39;x&#39;) &#123;
                        h = 1, t = 0;
                        continue;
                    &#125;
                    while (h &lt;= t &amp;&amp; j - q[h] &gt; y)
                        ++h;
                    d[i][j] = f[i][j];
                    if (h &lt;= t) &#123;
                        f[i][j] = max(f[i][j],
                                    d[i][q[h]] + j - q[h]);
                    &#125;
                    while (h &lt;= t &amp;&amp; d[i][j] - j
                                &gt;= d[i][q[t]] - q[t])
                        --t;
                    q[++t] = j;
                &#125;
            &#125;
        &#125;
        for (int i = 1; i &lt;= n; ++i) &#123;
            for (int j = 1; j &lt;= m; ++j)
                res = max(res, f[i][j]);
        &#125;
    &#125;
    print(res);
    return 0;
&#125;
&#125; // namespace XSC062

]]></content>
      <tags>
        <tag>DP</tag>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title>解题报告：背单词</title>
    <url>/20230110/</url>
    <content><![CDATA[「SCOI2016」背单词。


题解 P3294。
我们看到字典树这个标签，下意识想到了前缀。
但是题目让我们求后缀，所以我们把所有字符串先 reverse 一下，将问题转化为前缀，方便描述。

我们发现，因为 \(y &lt; x \le n\)，所以三种情况的花费排序为 \(x-y&lt;x&lt;n\times n\)。
不难发现，我们可以很简单地通过「把某单词的所有前缀单词放到它之前」消除开销为 \(n\times n\) 的情况。此时开销最劣情况下为 \(\sum\limits_{i=1}^ni &lt; n\times n\)。
接下来，问题在于怎样在满足「把某单词的所有前缀单词放到它之前」的条件下，最小化开销。不难发现，当我们去除第一种情况后，剩下的 \(x\) 和 \(x-y\) 都包含 \(x\) 项，也就是说，我们只需要最小化 \(\sum -y\) 的值，也就是最大化 \(\sum y\) 的值。而 \(\sum x\) 为定值 \(\sum\limits_{i=1}^ni\)。
关于处理方式：不难发现一个单词的最长前缀单词最多只有一个，但以该单词为最长前缀单词的单词可能有多个，联想到树。
我们将每个单词的最长前缀和该单词连边，会得到一个森林。
不妨先考虑问题的简化，假设有两条链（即，不会同时存在多个单词，使得它们的最长前缀单词相同），应该如何安排其顺序。
如图所示，考虑「同一条链均匀分散到序列中」和「同一条链集中在一起」两种有规律的安排方式，得到：

可以发现，第二种情况明显更优。
所以我们扩展猜想：对于某一单词，以它为前缀的所有单词必须紧随其后。该结论是可递归的。
继续处理细节部分。考虑两条链长度不同，应如何排列它们的位置？
下图展示了「前短后长」和「前长后短」两种方案：

可以发现，前短后长的方案更优。
扩展得到猜想，同一单词的所有子树中，大小更小的应在更前面。该结论是可递归的。

接下来对猜想进行证明。
假设现在已有一条链。我们只有把整条链连在一起，短单词放到长单词前面这一种方法。
然后新来了一个不属于这条链的节点，明显，因为节点不管放到哪里，其 \(y\) 值不变，但会改变已有链的 \(y\) 值，所以放到最前面最优。
又来了一个节点，和刚才新增的节点属于同一条链，一样，不管这个节点何去何从，其 \(y\) 不变，但放在越前面，后面的节点的 \(y\) 值增加得越多。
以此类推可得到结论，同一条链放到一起。短链放到长链前面也是比较好想的。假设有两条链，短链长度为 \(a\)，长链长度为 \(b\)，放置起点为 \(l\)，则前短后长和钱长后短的 y 之和分别为 \(\dfrac{(l + l + a - 2) \times (a - 1) + (l + a + l + a + b - 2) \times (b - 1)} 2\) 和 \(\dfrac{(l + l + b - 2) \times (b - 1) + (l + b + l + b + a - 2) \times (b - 1)} 2\)（运用等差数列求和公式），解不等式可得前短后长一定更优。
接下来是从链扩展到树。那么我们想到了什么？树链剖分。
我们化用树剖思想，以最轻边为剖分条件，将树划分为有顺序的链，按照上述方式排列其顺序即可。
此时我们记录下每个单词的直系父亲（即其最长前缀单词），在唯一序列中模拟计分操作，即可得到答案。

为了方便，可将所有入度为 \(0\) 的点与一个虚点相连，将森林转化为树。
注意 long long。

namespace XSC062 &#123;
using namespace fastIO;
using str = std::string;
const int maxn = 1e6 + 5;
const int maxm = 1e6 + 5;
str s[maxn];
int T[maxm][26];
int kaz[maxn], siz[maxn]; // kaz 表示单词在最终序列中所处的位置
std::vector&lt;int&gt; g[maxn];
int n, l, res, cnt = 1, ti;
int tot[maxm], fa[maxn], deg[maxn];
void Insert(int k) &#123; 
    int f = 1, len = s[k].length();
    for(int i = 0; i &lt; len; ++i) &#123;
        if (!T[f][s[k][i] - &#39;a&#39;]) 
            T[f][s[k][i] - &#39;a&#39;] = ++cnt;
        f = T[f][s[k][i]-&#39;a&#39;];
    &#125;
    tot[f] = k;
    return;
&#125;
void Search(int k) &#123;
    int f = 1;
    int len = s[k].length();
    for (int i = 0; i &lt; len; ++i) &#123;
        f = T[f][s[k][i] - &#39;a&#39;];
        if (tot[f]) &#123;
            if (tot[f] != k)
                fa[k] = tot[f]; // 记录当前最长前缀
        &#125;
    &#125;
    return;
&#125;
void add(int x, int y) &#123;
    ++deg[y];
    g[x].push_back(y);
    return;
&#125;
void DFS1(int x) &#123; // 提前计算每个子树的 size
    siz[x] = 1;
    for (auto i : g[x]) &#123;
        DFS1(i);
        siz[x] += siz[i];
    &#125;
    return;
&#125;
void DFS2(int x) &#123;
    kaz[x] = ti++;  // 时间戳即为单词位置
    std::sort(g[x].begin(), g[x].end(),
        [&amp;](int x, int y) &#123; return siz[x] &lt; siz[y]; &#125;); // 按子树 size 排序
    for (auto i : g[x])
        DFS2(i);
    return;
&#125;
int main() &#123;
    scanf(&quot;%lld&quot;, &amp;n);
    for (int i = 1; i &lt;= n; ++i) &#123;
        std::cin &gt;&gt; s[i];
        std::reverse(s[i].begin(), s[i].end());  // 后缀转前缀
        Insert(i);
        res += i;
    &#125;
    for (int i = 1; i &lt;= n; ++i) &#123;
        Search(i);
        if (fa[i])
            add(fa[i], i); // 建图
    &#125;
    for (int i = 1; i &lt;= n; ++i) &#123;
        if (!deg[i]) // 建虚点方便操作
            add(n + 1, i), fa[i] = n + 1;
    &#125;
    DFS1(n + 1), DFS2(n + 1);
    for (int i = 1; i &lt;= n; ++i)
        res -= kaz[fa[i]]; // 处理 y 值
    print(res);
    return 0;
&#125;
&#125; // namespace XSC062

]]></content>
      <tags>
        <tag>字典树</tag>
      </tags>
  </entry>
  <entry>
    <title>解题报告：Zero-One (Hard Version)</title>
    <url>/20230203/</url>
    <content><![CDATA[CF1733D2 Zero-One (Hard Version)。


没做过简单版本，模拟赛上遇到，乍一看是个贪心，但贪心思维太弱想不到怎么贪。所以思考其他方法。
下文称同时取反 \(a_i\) 和 \(a_j\) 的一次操作为「取反 \((a_i, a_j)\)」，称 \(a_i=b_i\) 的状态为「匹配」。

思维关键点
若我们想要将 \((a_i,a_j)\) 取反，我们可以怎么做？
不难发现，分 \(a_i\) 与 \(a_j\) 相邻和不相邻两种情况：

\(a_i\) 与 \(a_j\) 相邻：

直接取反，代价为 \(x\)。
寻找到一个与 \(a_i\) 和 \(a_j\) 都不相邻的 \(a_k\)，先将 \((a_i,a_k)\) 取反，再将 \((a_j,a_k)\) 取反，代价为 \(2\times y\)。

\(a_i\) 与 \(a_j\) 不相邻：

直接取反，代价为 \(y\)。
将 \((a_i,a_{i + 1}),(a_{i + 1}, a_{i + 2}),\cdots,(a_{j - 1}, a_{j})\) 取反，代价为 \((j - i)\times x\)。


接下来考虑另一个问题：我们要取反哪些 \((a_i,a_j)\) 呢？
假设现在有 \(a_p\) 与 \(b_p\) 不匹配，\(a_q\) 与 \(b_q\) 不匹配，那么我们肯定选择将 \((a_p,a_q)\) 取反。
原因很简单，假设有 \(a_k=b_k\)，如果我们将 \((a_p,a_k)\) 取反，那么 \(a_k\ne b_k\)，我们需要额外的一次与 \(a_k\) 有关的操作将其复原。如果我们挑选一个 \(a_l=b_l\)，并将 \((a_k,a_l)\) 取反，那么 \(a_l\) 与 \(b_l\) 又会不匹配，又需要一次操作；如果挑选一个 \(a_l\ne b_l\)，并将 \((a_k,a_l)\) 取反，那么为什么不能在一开始就将 \((a_p,a_l)\) 取反呢？此时的 \(a_k\) 相当于一个中继，而这种情况我们已经在取反 \((a_p,a_l)\) 时考虑到了。
也就是说，我们每次取反 只 选择两个无法与 \(b\) 匹配的 \(a\)。
那么，有没有一种情况，让我们无法选择两个无法匹配的值呢？
那就是不匹配的值的数量有奇数个，才会让我们两个两个选的时候有元素落单。
不妨思考一次取反操作所有可能的情况（假设不受上面的结论限制）：

取反一个匹配值和一个不匹配值
此时匹配值变为非匹配，不匹配值变为匹配，不匹配的元素总数不变。
取反两个不匹配值
两个不匹配值都变为匹配，不匹配元素的总数量增加 \(-2\)。
取反两个匹配值
两个匹配值都变为非匹配，不匹配元素的总数量增加 \(2\)。

综上，一次操作对不匹配元素总数带来的更改只可能为 \(0,2,-2\)，均为偶数。当不匹配元素为奇数时，必定无法将其更改至刚好为 \(0\)。此时输出 \(-1\)。
我们上面结论的可实现性也得到了保障：只取反两个不匹配的 \(a\)，不会有元素落单。
下文记从前往后第 \(i\) 个与 \(b\) 不匹配的 \(a\) 的下标为 \(d_i\)。

确定实现方法
发现 \(\sum n\le 5\times 10^3\)，确定算法复杂度为 \(O(n^2)\)。
首先不难想到暴力搜索，每次枚举将哪一对 \((d_i, d_j)\) 取反。
亦或是使用 bitset 记录哪些非匹配值已被取反（被取反为 \(1\)，否则为 \(0\)），枚举数对暴力 DP 更新最小值。
但以上两种方法铁定超时。
受到上面两种方法的启发，扩展思维，我们发现：

取反操作的顺序不会影响最终答案。
因为每个数被取反的次数一定，最终结果也就一定。
我们可以通过 DP 的方式寻找最小值。

设计状态。
不妨考虑让问题麻烦起来的是什么，对于 \(d_i\) 与 \(d_j\) 不相邻时的取反，我们无法得知 \(d_i\) 需要哪一个 \(d_j\)（而对于 \(d_i\) 与 \(d_j\) 相邻的情况，\(d_j\) 就是 \(d_{i + 1}\)，位置是确定的）。
但我们同时也发现，与相邻时的代价不同，不相邻时的操作代价与 \(i\)，\(j\) 的具体值无关。
所以不妨用 \(f_{i,j}\) 表示，已枚举到 \(d_i\)，前面有 \(j\) 个数需要后面 与它们不相邻的数 用以和它们配对取反。
假设已枚举到 \(d_i\)，当前面有 \(s\) 个数需要配对时，有以下的情况：

当 \(s = 1\)，即只有一个数需要配对时：

如果这个数是 \(d_{i - 1}\)，那么代价为 \(2\times y\)。
注意，这里只枚举了需要不相邻的数来配对的情况，相邻的情况将会另外计算，所以代价不能为 \(x\)。
否则，代价为 \(y\)。

当 \(s&gt;1\) 时，即有多个数需要配对时：
不管 \(d_{i-1}\) 是否需要配对，我们都不选它。因为选它的代价是 \(2\times y\)，而随便选另一个待配对数的代价都只有 \(y\)。

那么问题来了，我咋知道它们相不相邻？
再多开一维 \(0/1\) 状态，记录最后一个需要与其他后面的元素配对值是否是 \(a_{i-1}\) 即可。
假设现在已经枚举到 \(f_{i,j,0/1}\)，即已枚举完 \(d_i\)，有 \(j\) 个元素需要配对。
则更新 \(d_{i+1}\) 的状态：

若我们想要让 \(d_{i+1}\) 与后面的元素配对，则代价至少为 \(y\)。至于是否会因为待配对元素相邻而额外增加 \(y\) 的代价，我们在待配对元素处计算。
\[
 f_{i+1,j+1,1}\gets\min(f_{i,j,0},f_{i,j,1}) + y
 \]
若我们想要让 \(d_{i+1}\) 与其相邻的 \(a_{i+2}\) 匹配，那么 \(d_{i+2}\) 就不需要再与后面的元素配对了，故最后一维为 \(0\)。
\[
 f_{i+2,j,0}\gets\min(f_{i,j,0},f_{i,j,1})+(d_{i+2}-d_{i+1})\times x
 \]
如果我们想让 \(d_{i+1}\) 与前面的待配对元素配对：
在此种大前提下，\(d_{i+1}\) 一定不需要与后面的元素配对，故最后一维为 \(0\)。

当 \(j=1\) 且 \(d_i+1=d_{i+1}\) 时，即存在其相邻元素，且只有一个配对可选项时：

如果这个数是 \(d_{i}\)，则 \(d_{i+1}\) 必须与相邻元素配对。

\[
 f_{i+1,j-1,0}\gets f_{i,j,1}+y
 \]
因为在计算 \(f_{i,j,1}\) 时已计算了一个 \(y\)，所以此处只用加一个 \(y\)。

否则，该元素完成配对，不产生任何代价。
\[
 f_{i+1,j-1,0}\gets f_{i,j,0}
 \]

否则，随意选择前面的一个数。
因为此时，要么前面有除了相邻元素的其他数可选，要么根本没有相邻元素，所以该数完成配对不会产生任何代价（因为 \(y\) 已经加过了）。
\[
 f_{i+1,j-1,0}\gets \min(f_{i,j,0},f_{i,j,1})
 \]


至此，全部情况讨论完毕。因为不能让最后一个元素再去与后面的元素配对，最终答案为 \(f_{tot,0,0}\)，其中 \(tot\) 为 \(d\) 数组长度。
时间复杂度 \(O(n^2)\)，空间复杂度 \(O(n^2)\)。
因为 \(x,y\le 10^9\)，最坏情况下需要加 \(\dfrac n2\) 次，故需要为 DP 数组开 long long。尽管热心人士 @cqbztzl 帮助我计算得出使用空间约为 300 兆，但仍然会 MLE。
不难发现，第一维枚举到 \(i\) 时，只需要更新第一维为 \(i+1\) 和 \(i+2\) 状态的值，而不需要其他任何 DP 值，故将第一维模 \(3\)，滚动为 \(0\sim 2\)。

// 代码里可能有一些赛时的神秘注释 hhh
namespace XSC062 &#123;
using namespace fastIO;
const ll inf = 1e18;
const int maxn = 5e3 + 5;
ll x, y;
int T, n, tot;
ll f[3][maxn][2];
int diff[maxn], a[maxn], b[maxn];
ll min(ll x, ll y) &#123;
    return x &lt; y ? x : y;
&#125;
void upd(int i, int j, int k, ll y) &#123;
    f[i % 3][j][k] = min(f[i % 3][j][k], y);
    return;
&#125;
int main() &#123;
    read(T);
    while (T--) &#123;
        read(n), read(x), read(y);
        tot = 0;
        for (int i = 1; i &lt;= n; ++i)
            getnum(a[i]);
        for (int i = 1; i &lt;= n; ++i) &#123;
            getnum(b[i]);
            if (a[i] != b[i])
                diff[++tot] = i;
        &#125;
        if (tot &amp; 1) &#123;
            puts(&quot;-1&quot;);
            continue;
        &#125;
        memset(f, 0x3f, sizeof (f));
        f[0][0][0] = 0;
        for (int i = 0; i &lt;= tot; ++i) &#123;
            for (int j = 0; j &lt;= i; ++j) &#123;
                // 新增起点
                if (i + 1 &lt;= tot) &#123;
                    upd(i + 1, j + 1, 1,
                        min(f[i % 3][j][0],
                            f[i % 3][j][1]) + y);
                &#125;
                // 碾过去 
                if (i + 2 &lt;= tot) &#123;
                    upd(i + 2, j, 0,
                        min(f[i % 3][j][0],
                            f[i % 3][j][1]) +
                            (diff[i + 2] -
                            diff[i + 1]) * x);
                &#125;
                // 使用起点
                if (j &gt; 0 &amp;&amp; i + 1 &lt;= tot) &#123;
                    if (j == 1 &amp;&amp; diff[i] + 1 ==
                                        diff[i + 1]) &#123;
                        upd(i + 1, j - 1, 0,
                                f[i % 3][j][1] + y);
                        upd(i + 1, j - 1, 0,
                                f[i % 3][j][0]);
                    &#125;
                    else &#123;
                        upd(i + 1, j - 1, 0,
                            min(f[i % 3][j][0],
                                f[i % 3][j][1]));
                    &#125;
                &#125;
                if (i != tot) &#123;
                    f[i % 3][j][0] =
                        f[i % 3][j][1] = inf;
                &#125;
            &#125;
        &#125;
        print(f[tot % 3][0][0], &#39;\n&#39;);
    &#125;
    return 0;
&#125;
&#125; // namespace XSC062
]]></content>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>学习笔记：二分图</title>
    <url>/20230509/</url>
    <content><![CDATA[你说得对，所以我打网络流。


二分图
二分图总体概念不难。主要是其应用广泛，需要注意什么样的题目可以联系到二分图上来。
概念
若图 \(G\) 可将点集 \(V\) 分成两个互不相交的子集 \(X\) 和 \(Y\)，且每条边连接的两个点都满足一个在 \(X\) 中，一个在 \(Y\) 中，则称 \(G\) 为二分图。
也就是说，如果一个图有任何一种分组方式满足：把图中的点分成两组，每一组的点两两之间没有连边，那么这个图就是二分图。
举个例子：

每一组中的点两两之间没有连边，所以该图是二分图。

性质

二分图的每条边连接的点属于不同的集合。
显然。
二分图中可能存在环，且长度一定为偶数。
我们指定环中任意一个点，从该点出发，易得，经过奇数条边时到达另一个集合，反之回到该集合。因为路径是一个环，所以我们最后一定会回到起点所在集合，即经过偶数条边。

判定
通常，我们使用图的深度优先遍历每一个点 \(u\)。
显然，若已知点 \(u\) 在 \(X\) 集，那么所有与 \(u\) 有连边的点 \(v\) 一定在 \(Y\) 集（反之同理）。
当然，很多图是有环的，不免会产生 \(v\) 已经被分组的情况。若此时 \(v\) 恰好在 \(Y\) 集，皆大欢喜；若 \(v\) 也在 \(X\) 集，那么该图一定不为二分图。
由于每个点最多搜索一次，时间复杂度 \(O(n)\)。
int col[maxn];
bool DFS(int x, int c) &#123;
    col[x] = c;
    for (auto i : g[x]) &#123;
        if (col[i]) &#123;
            if (col[i] == c)
                return 0;
        &#125;
        else if (!DFS(i, 3 - c))
            return 0;
    &#125;
    return 1;
&#125;
int main() &#123; DFS(1, 1); &#125;
厚颜无耻地推销一下 题目（（（
匹配
定义：对于一个二分图中的若干条边，若这些边没有任何公共点，则称这些边组成的集合 \(M\) 是数量为 \(|M|\) 的 匹配。

图中红色边展示了一个数量为 4 的匹配

容易看出，对于点 \(u\)，只会存在 「有一条 \(M\) 集合内的边与 \(u\) 相连接」 和 「\(u\) 连接的边均不在 \(M\) 集合内」 两种情况。也就是说，从 \(u\) 出发的 \(M\) 集合内的边，最多有 \(1\) 条。
接下来，我们称 「有任何一条与之相连的边在匹配集合内」 的点为匹配点，「在匹配集合内的边」 为匹配边。
完备匹配
如果 \(|M|=\dfrac n2\)，即 \(M\) 恰好连接了 \(1\sim n\) 所有点，我们就称匹配 \(M\) 为 完备匹配。

一个完备匹配的例子

比方说，现在我们知道一些男孩和女孩，他们之间有若干条互相喜欢的关系，我们把此关系抽象成一个二分图，如果每个人都能与自己喜欢的异性配对，那么我们认为这个关系网存在完备匹配。
显然，完备匹配存在，仅当两集合大小相等。

匈牙利算法
匈牙利算法一般用于求解 \(\max\{|M|\}\)。
我们将图上满足下列条件的路径 \(P\) 称为增广路：

\(P\) 的起点和终点均是非匹配点
\(P\) 的起点和终点不在二分图的同一组内
路径 \(P\) 经过的边按 非 匹配边，匹配边，\(\cdots\)，非 匹配边的规律交替。

最终，\(P\) 会呈类 「\(\text Z\)」 形（值得一提的是，增广路不能经过一整个环，否则其长度将会因为二分图中只存在偶环而变为无穷大）。
显然，非匹配边比匹配边的数量始终多 \(1\)。
此时，我们对 \(P\) 上匹配的状态取反。也就是说，原来的非匹配边变成匹配边，匹配边变成非匹配边。这样做相当于是在匹配边集仍然合法的情况下将匹配边集的大小扩大了 \(1\)。
那么增广路经过的边按非匹配边，匹配边，\(\cdots\)，非匹配边顺序交替的原因就很显而易见了。取反前，匹配边不可能连续出现；取反后，匹配边（即取反前的非匹配边）也不可能连续出现。
而匈牙利算法的主要思路，就是反复寻找增广路，直到无法找到为止。
这里就必须再提到一个性质：\(M\) 为图 \(G\) 的最大匹配，当且仅当无法在 \(M\) 的基础上找到增广路。
证明如下：

有引理：对于图 \(G\) 的任意两个匹配 \(M\) 和 \(M&#39;\)，它们的 对称差 \(M\Delta M&#39;\) 中的每一个连通块都是一条链或一个包含边数为偶数的环。
证明：
根据对称差的定义，对于任意边 \(e\in M\Delta M&#39;\)，\(e\) 要么是 \(M\) 中的一条匹配边，要么是 \(M&#39;\) 中的一条匹配边，但不同时被 \(M\) 和 \(M&#39;\) 包含。
因为在同一个匹配中，任意两条匹配边不存在公共顶点，所以对于任意与 \(e\) 有公共顶点的匹配边 \(e&#39;\)，\(e\) 和 \(e&#39;\) 必然来自两个不同的匹配。
由此可得，对于任意匹配点 \(u\)，\(u\) 的度数为 \(1\) 或 \(2\)。
所以，对称差中的每一个连通块都是链或环。
对于其中的环，所有相邻的边必定来自不同的匹配，所以环包含的边数为偶数。
必要性：当 \(M\) 为最大匹配时，无法找到 \(M\) 的增广路。
我们已经知道了，找到某匹配的增广路 \(P\) 并将其匹配状态取反，可以使匹配大小加一。
如果 \(M\) 存在增广路，则我们可以将其取反，得到一个比 \(M\) 大小更大的匹配。与 \(M\) 是最大匹配矛盾。
所以一定不存在 \(M\) 的增广路。
充分性：如果不存在 \(M\) 的增广路，\(M\) 为 \(G\) 的最大匹配。
设 \(M&#39;\) 是一个比 \(M\) 更大的匹配。
由引理得：
在它们的对称差 \(M\Delta M&#39;\) 中，连通块为链或环。
其中，环包含边的数量为偶数，所以必然有同样多的边来自 \(M\) 和 \(M&#39;\)。所以我们可以忽视这些环。
由于 \(|M|&lt;|M&#39;|\)，存在至少一条链 \(L\)，且 \(|L|=k-1\)，包含 \(k\) 条 \(M\) 中的边，\(k+1\) 条来自于 \(M&#39;\) 的边。
显然，\(L\) 就是一条 \(M\) 的增广路，所以我们必然可以找到一条 \(M\) 的增广路，命题成立。

对于 「寻找增广路」 这个过程，我们使用 DFS 算法实现。
对于点 \(x\)，若与 \(x\) 有连边的点 \(y\) 可匹配上 \(x\)，需要满足下列两个条件之一：

\(y\) 是非匹配点，此时 \(x\to y\) 构成一条增广路，非匹配边的数量已经比匹配边数量多 \(1\)。
\((u,y)\) 是已匹配边，且 \((u,v)\) 是未匹配但合法的边，此时 \(x\to y\to u\to v\) 构成一条增广路。

在实现中，我们依次令 \(1\sim n\) 内 所有的非匹配点 作为起始点 \(x\) 尝试找到任何一条增广路。当碰到任意非匹配点时结束（增广路判定：起点与终点均为非匹配点），否则向 该匹配点匹配的点 继续搜索。
也就是说，一层 DFS 会寻找一条非匹配边并作为起点，产生以下两种行为：

该非匹配边终点为非匹配点，以该匹配边结束增广路。
经过该非匹配边后还能再找到一条匹配边（若情况 1 不满足，显然一定能找到这样一条边），则在终点进行下一层 DFS，寻找下一条非匹配边。

时间复杂度为 \(O(n^2+nm)\)，但一般二分图题目的 \(X\) 与 \(Y\) 部间的连边偏稠密，所以简化为 \(O(nm)\)。
bool Find(int x) &#123;
    vis[x] = now; // 时间戳标记
    for (auto i : g[x]) &#123;
        if (vis[i] == now) // 不经过访问过的 i
            continue;
        if (!mat[i] /* 非匹配点，即终点 */ ||
            (vis[mat[i]] != now /* mat[i] 未访问过，可以经过 */
            &amp;&amp; Find(mat[i]) /* 可找到增广路 */)) &#123;
            mat[i] = x; // 匹配
            return 1;
        &#125;
    &#125;
    return 0;
&#125;
int Hungary(int n) &#123;
    int res = 0;
    for (int i = 1; i &lt;= n; ++i) &#123;
        ++now;
        res += Find(i);
    &#125;
    return res;
&#125;
一般来说，二分图题目对点、边、分组方法和匹配范围的识别较为模糊。但一般的二分图题目都会有一些特点：

结点能分为两组，且各组内结点间没有连边
每个结点只能与一条边匹配

有时候，题目要求判定是否存在 「完备匹配」，也就是说，\(ans=n\)。即任意一次 find(i) 返回 false 时，完备匹配不存在。
最后给出与匈牙利算法有关的两个问题：

最小点覆盖：给定一个二分图，求出一个最小的点集，使得这个点集发出的所有边可以覆盖整个二分图。
定理：该点集的大小是二分图的最大匹配包含的边数。
最大独立集：给定一个无向图，求出一个最大的点集，使得该点集中的所有点两两之间没有边相连。
定理：当该无向图是二分图时，最大独立集的大小等于 \(n\) 减去最大匹配数。
证明：由于最小点覆盖可以覆盖所有边，故不存在两个点，使得它们不属于最小点覆盖且有连边。
所以，当去掉最小点覆盖后，剩余点两两之间没有连边。因为最小点覆盖大小就是最大匹配大小，故原命题成立。


注意二分图的点和边是可以互相转化的，即，若发现信息集中在点上，也可以用二分图解决。匹配边的数量即最终参与匹配的点数较多的一方的匹配点数量。
对于二分图建图的一个判断方式是，找冲突。找到彼此之间有冲突的两方，连边。这样就能建出二分图。当然要保证两方之间没有交集。
所谓冲突，就是我们通常理解中的选了一个就不能选另一个。因此也可以通过冲突存在的形式思考建图方式。

A. 棋盘上的骑士
https://www.becoder.com.cn/contest/3699/problem/1
这道题就是我们提到的边转化为点的情况。
为棋盘上的每个格子编号。骑士走的是日字，所以我们要把周围每个格子日字方向八个格子都连上边。
那要怎么将所有 \(n\times n\) 个格子分为有冲突的两方呢？注意到日字连接的两个格子一定奇偶性相异，故我们以奇偶性分类。
被挖掉的格子无视即可，不能连任何边，否则该边都有可能被选。然后跑一个最大匹配就行。

namespace XSC062 &#123;
using namespace fastIO;
const int maxn = 205;
const int maxm = 1e5 + 5;
const int fx[] = &#123; 1, 1, -1, -1, 2, 2, -2, -2 &#125;;
const int fy[] = &#123; 2, -2, 2, -2, 1, -1, 1, -1 &#125;;
int a[maxn][maxn];
int mat[maxm], vis[maxm];
std::vector&lt;int&gt; g[maxm];
int n, m, x, y, now, cnt, tot;
bool Find(int x) &#123;
    vis[x] = now;
    for (auto i : g[x]) &#123;
        if (vis[i] == now)
            continue;
        if (!mat[i] || (vis[mat[i]] != now
                            &amp;&amp; Find(mat[i]))) &#123;
            mat[i] = x;
            return 1;
        &#125;
    &#125;
    return 0;
&#125;
int Hungary(int n) &#123;
    int res = 0;
    for (int i = 1; i &lt;= n; ++i)
        ++now, res += Find(i);
    return res;
&#125;
void add(int x, int y) &#123;
    g[x].push_back(y);
    return;
&#125;
int main() &#123;
    read(n), read(m);
    while (m--) &#123;
        read(x), read(y);
        a[x][y] = -1;
    &#125;
    for (int i = 1; i &lt;= n; ++i) &#123;
        for (int j = 1; j &lt;= n; ++j) &#123;
            if (a[i][j] != -1 &amp;&amp; !((i + j) &amp; 1))
                a[i][j] = ++cnt;
        &#125;
    &#125;
    for (int i = 1; i &lt;= n; ++i) &#123;
        for (int j = 1; j &lt;= n; ++j) &#123;
            if (a[i][j] == -1 || !((i + j) &amp; 1))
                continue;
            a[i][j] = ++tot;
            for (int k = 0; k &lt; 8; ++k) &#123;
                int nx = i + fx[k];
                int ny = j + fy[k];
                if (nx &lt; 1 || ny &lt; 1 || nx &gt; n ||
                    ny &gt; n || a[nx][ny] == -1)
                    continue;
                add(a[i][j], a[nx][ny] + n * n);
            &#125;
        &#125;
    &#125;
    print(cnt + tot - Hungary(tot), &#39;\n&#39;);
    return 0;
&#125;
&#125; // namespace XSC062


B. 火力网
https://www.becoder.com.cn/contest/3699/problem/2
这里用到了二分图在地图上一个较为常用的分组方法。
找到每行每列的「连通块」，满足在行上的连通块任意放一个炮台，炮台覆盖连通块内所有点，所有点均被连通块覆盖，列范围内同理。为连通块分别编号，则样例的情况可转化如下：
/* 对于行 */        /* 对于列 */
  1 - 2 2            1 - 5 6
  3 3 3 3            1 3 5 6
  - - 4 4            - - 5 6
  5 5 5 5            2 4 5 6
若一个格子为空地，则将其在行 / 列范围内所属的连通块连边。这样，我们在选取该格后，就相当于选取了这条边，由于匹配边不共点，所以合法。

namespace XSC062 &#123;
using namespace fastIO;
const int maxn = 25;
const int maxm = 1e5 + 5;
char a[maxn][maxn];
int mat[maxm], vis[maxm];
std::vector&lt;int&gt; g[maxm];
int n, x, y, now, cnt1, cnt2;
int t[maxn][maxn], p[maxn][maxn];
bool Find(int x) &#123;
    vis[x] = now;
    for (auto i : g[x]) &#123;
        if (vis[i] == now)
            continue;
        if (!mat[i] || (vis[mat[i]] != now
                            &amp;&amp; Find(mat[i]))) &#123;
            mat[i] = x;
            return 1;
        &#125;
    &#125;
    return 0;
&#125;
int Hungary(int n) &#123;
    int res = 0;
    for (int i = 1; i &lt;= n; ++i)
        ++now, res += Find(i);
    return res;
&#125;
void add(int x, int y) &#123;
    g[x].push_back(y);
    return;
&#125;
int main() &#123;
    scanf(&quot;%d&quot;, &amp;n);
    for (int i = 1; i &lt;= n; ++i)
        scanf(&quot;%s&quot;, a[i] + 1);
    for (int i = 1; i &lt;= n; ++i) &#123;
        for (int j = 1; j &lt;= n; ++j) &#123;
            if (a[i][j] == &#39;X&#39;)
                continue;
            if (a[i][j - 1] != &#39;.&#39;)
                t[i][j] = ++cnt1;
            else t[i][j] = t[i][j - 1];
        &#125;
    &#125;
    for (int j = 1; j &lt;= n; ++j) &#123;
        for (int i = 1; i &lt;= n; ++i) &#123;
            if (a[i][j] == &#39;X&#39;)
                continue;
            if (a[i - 1][j] != &#39;.&#39;)
                p[i][j] = ++cnt2;
            else p[i][j] = p[i - 1][j];
        &#125;
    &#125;
    for (int i = 1; i &lt;= n; ++i) &#123;
        for (int j = 1; j &lt;= n; ++j) &#123;
            if (a[i][j] == &#39;.&#39;)
                add(t[i][j], p[i][j] + cnt1);
        &#125;
    &#125;
    print(Hungary(cnt1), &#39;\n&#39;);
    return 0;
&#125;
&#125; // namespace XSC062


C. 超级英雄 Hero
https://www.becoder.com.cn/contest/3699/problem/3
分析冲突。每个锦囊只能被一道题使用，一道题只能使用一个锦囊，故考虑将锦囊和题连边。题目要求连续解题最多，故以题目进行匈牙利。
最后输出匹配数组即可。

namespace XSC062 &#123;
using namespace fastIO;
const int maxn = 2e4 + 5;
int n, m, x, y, now, t;
int mat[maxn], vis[maxn];
std::vector&lt;int&gt; g[maxn];
bool Find(int x) &#123;
    vis[x] = now;
    for (auto i : g[x]) &#123;
        if (vis[i] == now)
            continue;
        if (!mat[i] || (vis[mat[i]] != now
                            &amp;&amp; Find(mat[i]))) &#123;
            mat[i] = x, mat[x] = i;
            return 1;
        &#125;
    &#125;
    return 0;
&#125;
int Hungary(int n) &#123;
    int res = 0;
    for (int i = 1; i &lt;= n; ++i) &#123;
        ++now;
        if (Find(i))
            ++res;
        else break;
    &#125;
    return res;
&#125;
void add(int x, int y) &#123;
    g[x].push_back(y);
    return;
&#125;
int main() &#123;
    read(n), read(m);
    for (int i = 1; i &lt;= m; ++i) &#123;
        read(x), read(y);
        add(i, x + m + 1);
        add(i, y + m + 1);
    &#125;
    print(t = Hungary(m), &#39;\n&#39;);
    for (int i = 1; i &lt;= t; ++i)
        print(mat[i] - m - 1, &#39;\n&#39;);
    return 0;
&#125;
&#125; // namespace XSC062


KM 算法
还没写…… 咕咕咕

A. Ants
https://vjudge.net/contest/554888#problem/A
板板题。把黑蚂蚁和白蚂蚁按欧几里得距离连边后 KM 即可。

namespace XSC062 &#123;
using namespace fastIO;
typedef double db;
const db inf = 1e18;
const db eps = 1e-5;
const int maxn = 205;
int n, now;
db g[maxn][maxn];
db u[maxn], up[maxn];
int vis[maxn], mat[maxn];
int a[maxn][2], b[maxn][2];
db max(db x, db y) &#123;
    return x &gt; y ? x : y;
&#125;
db min(db x, db y) &#123;
    return x &lt; y ? x : y;
&#125;
bool eq(db x, db y) &#123;
    return fabs(x - y) &lt;= eps;
&#125;
bool Find(int x) &#123;
    vis[x] = now;
    for (int i = n + 1; i &lt;= 2 * n; ++i) &#123;
        if (vis[i] == now)
            continue;
        if (eq(u[x] + u[i], g[x][i])) &#123;
            vis[i] = now;
            if (!mat[i] || (vis[mat[i]] != now
                            &amp;&amp; Find(mat[i]))) &#123;
                mat[i] = x;
                return 1;
            &#125;
        &#125;
        else &#123;
            up[i] = min(up[i],
                u[x] + u[i] - g[x][i]);
        &#125;
    &#125;
    return 0;
&#125;
void Solve(void) &#123;
    for (int i = 1; i &lt;= n; ++i) &#123;
        u[i] = -inf;
        for (int j = n + 1; j &lt;= 2 * n; ++j)
            u[i] = max(u[i], g[i][j]);
    &#125;
    for (int i = 1; i &lt;= n; ++i) &#123;
        for (;;) &#123;
            ++now;
            for (int j = n + 1; j &lt;= 2 * n; ++j)
                up[j] = inf;
            if (Find(i))
                break;
            db Delta = inf;
            for (int j = n + 1;
                            j &lt;= 2 * n; ++j) &#123;
                if (vis[j] != now)
                    Delta = min(Delta, up[j]);
            &#125;            for (int j = 1; j &lt;= n; ++j) &#123;
                if (vis[j] == now)
                    u[j] -= Delta;
            &#125;
            for (int j = n + 1;
                            j &lt;= 2 * n; ++j) &#123;
                if (vis[j] == now)
                    u[j] += Delta;
            &#125;
        &#125;
    &#125;
    return;
&#125;
db dist(int x1, int y1, int x2, int y2) &#123;
    return sqrt((db)(x1 - x2) * (x1 - x2) +
                    (y1 - y2) * (y1 - y2));
&#125;
int main() &#123;
    read(n);
    for (int i = 1; i &lt;= n; ++i)
        read(a[i][0]), read(a[i][1]);
    for (int i = 1; i &lt;= n; ++i)
        read(b[i][0]), read(b[i][1]);
    for (int i = 1; i &lt;= n; ++i) &#123;
        for (int j = 1; j &lt;= n; ++j) &#123;
            g[j][i + n] = -dist(a[i][0], a[i][1],
                            b[j][0], b[j][1]);
        &#125;
    &#125;
    Solve();
    for (int i = n + 1; i &lt;= 2 * n; ++i)
        print(mat[i], &#39;\n&#39;);
    return 0;
&#125;
&#125; // namespace XSC062

B. 奔小康赚大钱
https://vjudge.net/contest/554888#problem/B
板板题。把居民和房子连边即可。

namespace XSC062 &#123;
using namespace fastIO;
const int maxn = 605;
const int inf = 0x3f3f3f3f;
int n, now, res;
int g[maxn][maxn];
int u[maxn], up[maxn];
int vis[maxn], mat[maxn];
int max(int x, int y) &#123;
    return x &gt; y ? x : y;
&#125;
int min(int x, int y) &#123;
    return x &lt; y ? x : y;
&#125;
bool Find(int x) &#123;
    vis[x] = now;
    for (int i = n + 1; i &lt;= 2 * n; ++i) &#123;
        if (vis[i] == now)
            continue;
        if (u[x] + u[i] == g[x][i]) &#123;
            vis[i] = now;
            if (!mat[i] || (vis[mat[i]] != now
                            &amp;&amp; Find(mat[i]))) &#123;
                mat[i] = x;
                return 1;
            &#125;
        &#125;
        else &#123;
            up[i] = min(up[i],
                u[x] + u[i] - g[x][i]);
        &#125;
    &#125;
    return 0;
&#125;
void Solve(void) &#123;
    for (int i = 1; i &lt;= 2 * n; ++i)
        mat[i] = u[i] = 0;
    for (int i = 1; i &lt;= n; ++i) &#123;
        u[i] = -inf;
        for (int j = n + 1; j &lt;= 2 * n; ++j)
            u[i] = max(u[i], g[i][j]);
    &#125;
    for (int i = 1; i &lt;= n; ++i) &#123;
        for (;;) &#123;
            ++now;
            for (int j = n + 1; j &lt;= 2 * n; ++j)
                up[j] = inf;
            if (Find(i))
                break;
            int Delta = inf;
            for (int j = n + 1;
                            j &lt;= 2 * n; ++j) &#123;
                if (vis[j] != now)
                    Delta = min(Delta, up[j]);
            &#125;
            for (int j = 1; j &lt;= n; ++j) &#123;
                if (vis[j] == now)
                    u[j] -= Delta;
            &#125;
            for (int j = n + 1;
                            j &lt;= 2 * n; ++j) &#123;
                if (vis[j] == now)
                    u[j] += Delta;
            &#125;
        &#125;
    &#125;
    return;
&#125;
int main() &#123;
    while(read(n)) &#123;
        res = 0;
        for (int i = 1; i &lt;= n; ++i) &#123;
            for (int j = 1; j &lt;= n; ++j)
                read(g[i][j + n]);
        &#125;
        Solve();
        for (int i = n + 1; i &lt;= 2 * n; ++i)
            res += g[mat[i]][i];
        print(res, &#39;\n&#39;);
    &#125;
    return 0;
&#125;
&#125; // namespace XSC062


C. Going Home
https://vjudge.net/contest/554888#problem/C
板板题。把人和房子按曼哈顿距离连边即可。

namespace XSC062 &#123;
using namespace fastIO;
const int maxn = 205;
const int inf = 0x3f3f3f3f;
int g[maxn][maxn];
char s[maxn][maxn];
int u[maxn], up[maxn];
int h, w, n, m, now, res;
int vis[maxn], mat[maxn];
int a[maxn][2], b[maxn][2];
int max(int x, int y) &#123;
    return x &gt; y ? x : y;
&#125;
int min(int x, int y) &#123;
    return x &lt; y ? x : y;
&#125;
bool Find(int x) &#123;
    vis[x] = now;
    for (int i = n + 1; i &lt;= 2 * n; ++i) &#123;
        if (vis[i] == now)
            continue;
        if (u[x] + u[i] == g[x][i]) &#123;
            vis[i] = now;
            if (!mat[i] || (vis[mat[i]] != now
                            &amp;&amp; Find(mat[i]))) &#123;
                mat[i] = x;
                return 1;
            &#125;
        &#125;
        else &#123;
            up[i] = min(up[i],
                u[x] + u[i] - g[x][i]);
        &#125;
    &#125;
    return 0;
&#125;
void Solve(void) &#123;
    for (int i = 1; i &lt;= 2 * n; ++i)
        mat[i] = u[i] = 0;
    for (int i = 1; i &lt;= n; ++i) &#123;
        u[i] = -inf;
        for (int j = n + 1; j &lt;= 2 * n; ++j)
            u[i] = max(u[i], g[i][j]);
    &#125;
    for (int i = 1; i &lt;= n; ++i) &#123;
        for (;;) &#123;
            ++now;
            for (int j = n + 1; j &lt;= 2 * n; ++j)
                up[j] = inf;
            if (Find(i))
                break;
            int Delta = inf;
            for (int j = n + 1;
                            j &lt;= 2 * n; ++j) &#123;
                if (vis[j] != now)
                    Delta = min(Delta, up[j]);
            &#125;
            for (int j = 1; j &lt;= n; ++j) &#123;
                if (vis[j] == now)
                    u[j] -= Delta;
            &#125;
            for (int j = n + 1;
                            j &lt;= 2 * n; ++j) &#123;
                if (vis[j] == now)
                    u[j] += Delta;
            &#125;
        &#125;
    &#125;
    return;
&#125;
int abs(int x) &#123;
    return x &gt;= 0 ? x : -x;
&#125;
int dist(int x1, int y1, int x2, int y2) &#123;
    return abs(x1 - x2) + abs(y1- y2);
&#125;
void Init(void) &#123;
    res = n = m = 0;
    memset(g, 0, sizeof (g));
    return;
&#125;
int main() &#123;
    scanf(&quot;%d %d&quot;, &amp;h, &amp;w);
    while (h || w) &#123;
        Init();
        for (int i = 1; i &lt;= h; ++i) &#123;
            scanf(&quot;%s&quot;, s[i] + 1);
            for (int j = 1; j &lt;= w; ++j) &#123;
                if (s[i][j] == &#39;H&#39;)
                    a[++n][0] = i, a[n][1] = j;
                else if (s[i][j] == &#39;m&#39;)
                    b[++m][0] = i, b[m][1] = j;
            &#125;
        &#125;
        for (int i = 1; i &lt;= n; ++i) &#123;
            for (int j = 1; j &lt;= n; ++j) &#123;
                g[i][j + n] = -dist(a[i][0],
                    a[i][1], b[j][0], b[j][1]);
            &#125;
        &#125;
        Solve();
        for (int i = n + 1; i &lt;= 2 * n; ++i)
            res += g[mat[i]][i];
        print(-res, &#39;\n&#39;);
        scanf(&quot;%d %d&quot;, &amp;h, &amp;w);
    &#125;
    return 0;
&#125;
&#125; // namespace XSC062


D. Cyclic Tour
https://vjudge.net/contest/554888#problem/D
题意在讲什么啊，看了半天看不懂。
给定一个有向图，找到若干个互不相交的环覆盖整个图，使得所有环上边权和最小，若找不到方案输出 -1。
我们知道与这道题相类似的最小路径覆盖问题可以用二分图 + 拆点来解决。那么这里我们也可以小小地拆一拆点。把一个点拆成两个，一个作为起点，一个作为终点，两个点之间连双向边，这样该图就和原图等价。
拆出来起点之间没有边，拆出来的终点之间也没有边，所以原图是二分图。
不难发现，假设原图中的环上共有 \(x\) 个点、\(x\) 条边，那么拆点后就会有 \(2\times x\) 个点和 \(2\times x\) 条边，其中 \(x\) 条边是点 \(i\) 连向点 \(i&#39;\)（或反之）的边。
需要匹配到剩余的实边（而非自己连向自己的虚边）共有 \(x\) 条，左右部节点都有 \(x\) 个，考虑设虚边边权为正无穷，进行最小权完美匹配（点和自己连边的操作保证了一定能找到解，不会进入死循环）。
那么什么时候无解呢？当算法不得不选中虚边时，就说明找不到环了。所以我们判一下匹配有没有包含正无穷边即可。
记得判重边！

namespace XSC062 &#123;
using namespace fastIO;
const int maxn = 205;
const int inf = 0x3f3f3f3f;
int g[maxn][maxn];
int u[maxn], up[maxn];
int vis[maxn], mat[maxn];
int n, m, x, y, now, res, w;
int max(int x, int y) &#123;
    return x &gt; y ? x : y;
&#125;
int min(int x, int y) &#123;
    return x &lt; y ? x : y;
&#125;
bool Find(int x) &#123;
    vis[x] = now;
    for (int i = n + 1; i &lt;= 2 * n; ++i) &#123;
        if (vis[i] == now)
            continue;
        if (u[x] + u[i] == g[x][i]) &#123;
            vis[i] = now;
            if (!mat[i] || (vis[mat[i]] != now
                            &amp;&amp; Find(mat[i]))) &#123;
                mat[i] = x;
                return 1;
            &#125;
        &#125;
        else &#123;
            up[i] = min(up[i],
                u[x] + u[i] - g[x][i]);
        &#125;
    &#125;
    return 0;
&#125;
void Solve(void) &#123;
    for (int i = 1; i &lt;= 2 * n; ++i)
        mat[i] = u[i] = 0;
    for (int i = 1; i &lt;= n; ++i) &#123;
        u[i] = -inf;
        for (int j = n + 1; j &lt;= 2 * n; ++j)
            u[i] = max(u[i], g[i][j]);
    &#125;
    for (int i = 1; i &lt;= n; ++i) &#123;
        for (;;) &#123;
            ++now;
            for (int j = n + 1; j &lt;= 2 * n; ++j)
                up[j] = inf;
            if (Find(i))
                break;
            int Delta = inf;
            for (int j = n + 1;
                            j &lt;= 2 * n; ++j) &#123;
                if (vis[j] != now)
                    Delta = min(Delta, up[j]);
            &#125;
            for (int j = 1; j &lt;= n; ++j) &#123;
                if (vis[j] == now)
                    u[j] -= Delta;
            &#125;
            for (int j = n + 1;
                            j &lt;= 2 * n; ++j) &#123;
                if (vis[j] == now)
                    u[j] += Delta;
            &#125;
        &#125;
    &#125;
    return;
&#125;
int main() &#123;
    while (read(n)) &#123;
        read(m);
        res = 0;
        for (int i = 1; i &lt;= 2 * n; ++i) &#123;
            for (int j = 1; j &lt;= 2 * n; ++j) 
                g[i][j] = -inf;
        &#125;
        while (m--) &#123;
            read(x), read(y), read(w);
            g[x][y + n] = max(g[x][y + n], -w);
        &#125;
        Solve();
        for (int i = n + 1; i &lt;= 2 * n; ++i) &#123;
            if (g[mat[i]][i] &lt;= -inf) &#123;
                puts(&quot;-1&quot;);
                goto NoSol;
            &#125;
            res += -g[mat[i]][i];
        &#125;
        print(res, &#39;\n&#39;);
        NoSol: ;
    &#125;
    return 0;
&#125;
&#125; // namespace XSC062


E. Tour
https://vjudge.net/contest/554888#problem/E
把上一题输入方式和数据范围改一改就好了。

namespace XSC062 &#123;
using namespace fastIO;
const int maxn = 405;
const int inf = 0x3f3f3f3f;
int g[maxn][maxn];
int u[maxn], up[maxn];
int vis[maxn], mat[maxn];
int T, n, m, x, y, now, res, w;
int max(int x, int y) &#123;
    return x &gt; y ? x : y;
&#125;
int min(int x, int y) &#123;
    return x &lt; y ? x : y;
&#125;
bool Find(int x) &#123;
    vis[x] = now;
    for (int i = n + 1; i &lt;= 2 * n; ++i) &#123;
        if (vis[i] == now)
            continue;
        if (u[x] + u[i] == g[x][i]) &#123;
            vis[i] = now;
            if (!mat[i] || (vis[mat[i]] != now
                            &amp;&amp; Find(mat[i]))) &#123;
                mat[i] = x;
                return 1;
            &#125;
        &#125;
        else &#123;
            up[i] = min(up[i],
                u[x] + u[i] - g[x][i]);
        &#125;
    &#125;
    return 0;
&#125;
void Solve(void) &#123;
    for (int i = 1; i &lt;= 2 * n; ++i)
        mat[i] = u[i] = 0;
    for (int i = 1; i &lt;= n; ++i) &#123;
        u[i] = -inf;
        for (int j = n + 1; j &lt;= 2 * n; ++j)
            u[i] = max(u[i], g[i][j]);
    &#125;
    for (int i = 1; i &lt;= n; ++i) &#123;
        for (;;) &#123;
            ++now;
            for (int j = n + 1; j &lt;= 2 * n; ++j)
                up[j] = inf;
            if (Find(i))
                break;
            int Delta = inf;
            for (int j = n + 1;
                            j &lt;= 2 * n; ++j) &#123;
                if (vis[j] != now)
                    Delta = min(Delta, up[j]);
            &#125;
            for (int j = 1; j &lt;= n; ++j) &#123;
                if (vis[j] == now)
                    u[j] -= Delta;
            &#125;
            for (int j = n + 1;
                            j &lt;= 2 * n; ++j) &#123;
                if (vis[j] == now)
                    u[j] += Delta;
            &#125;
        &#125;
    &#125;
    return;
&#125;
int main() &#123;
    read(T);
    while(T--) &#123;
        read(n), read(m);
        res = 0;
        for (int i = 1; i &lt;= 2 * n; ++i) &#123;
            for (int j = 1; j &lt;= 2 * n; ++j) 
                g[i][j] = -inf;
        &#125;
        while (m--) &#123;
            read(x), read(y), read(w);
            g[x][y + n] = max(g[x][y + n], -w);
        &#125;
        Solve();
        for (int i = n + 1; i &lt;= 2 * n; ++i) &#123;
            if (g[mat[i]][i] &lt;= -inf) &#123;
                puts(&quot;-1&quot;);
                goto NoSol;
            &#125;
            res += -g[mat[i]][i];
        &#125;
        print(res, &#39;\n&#39;);
        NoSol: ;
    &#125;
    return 0;
&#125;
&#125; // namespace XSC062


D. 导弹防御塔
https://www.becoder.com.cn/contest/3699/problem/4
GM 说的好哇（指 毛病多，一会儿分钟一会儿秒）。
寻找冲突。一个敌人只能被一炮打死，故考虑
但一个塔可以打很多炮，考虑拆点。
]]></content>
      <tags>
        <tag>二分图</tag>
      </tags>
  </entry>
  <entry>
    <title>杂题选谈：分治</title>
    <url>/20230314/</url>
    <content><![CDATA[听说是 分治场，想起了自己根本没学过分治（甚至从来不知道归并排序的原理 orz）就去听 CDQ 然后一头雾水的惨痛经历，不禁 PTSD 了。


A. 老板的又一道题
https://www.becoder.com.cn/contest/3416/problem/1
这是什么，有序表的最小和，切一下（所以和分治有什么关系啊）。
首先对数组进行排序（我忘了 orz），然后在优先队列中填入 \(A_{1\sim n} + B_1\)。假设当前最小值为 \(A_i + B_j\)，则输出，弹出并填入 \(A_i + B_{j + 1}\)。因为 \(B\) 是单调的，所以我们填入的数（起码在输出时）是单调的。

namespace XSC062 &#123;
using namespace fastIO;
const int maxn = 1e5 + 5;
struct _ &#123;
    int u, i;
    _() &#123;&#125;
    _(int u1, int i1) &#123;
        u = u1, i = i1;
    &#125;
    bool operator&lt; (const _ q) const &#123;
        return u &gt; q.u;
    &#125;
&#125;;
int n, cnt;
int a[maxn], b[maxn];
std::priority_queue&lt;_&gt; q;
int main() &#123;
    read(n);
    for (int i = 1; i &lt;= n; ++i)
        read(a[i]);
    for (int i = 1; i &lt;= n; ++i)
        read(b[i]);
    std::sort(a + 1, a + n + 1);
    std::sort(b + 1, b + n + 1);
    for (int i = 1; i &lt;= n; ++i)
        q.push(_(a[i] + b[1], 1));
    while (!q.empty()) &#123;
        _ f = q.top();
        q.pop();
        print(f.u, &#39; &#39;);
        if (++cnt == n)
            break;
        _ t = f;
        t.u -= b[f.i];
        t.u += b[++t.i];
        q.push(t);
    &#125;
    return 0;
&#125;
&#125; // namespace XSC062


B. 魔法石的诱惑
https://www.becoder.com.cn/contest/3416/problem/2
这，这不是二分答案？到底和分治有什么关系啊。
嘶，\(Q\) 是 \(10^8\)，算一算 \(n\) 的范围。不难发现 \(Q=\sum\limits_{i&gt;1} \lfloor \dfrac n{5^i} \rfloor\)，当 \(n=5\times 10^8\) 时，\(\dfrac n5\) 就已经是 \(10^8\) 了，所以我们二分的左右边界应为 \([0,5\times 10^8]\)。
然后 check 的话我们就暴力除 \(5\) 计算答案（就像小奥一样），一次 check 的时间复杂度是 \(\log\) 的，不会有问题。

namespace XSC062 &#123;
using namespace fastIO;
int q, l, mid, r = 5e18, res;
int check(int x) &#123;
    int res = 0;
    while (x / 5)
        res += (x /= 5);
    return res;
&#125;
int main() &#123;
    read(q);
    while (l &lt;= r) &#123;
        int mid = (l + r) &gt;&gt; 1;
        if (check(mid) &gt;= q) &#123;
            res = mid;
            r = mid - 1;
        &#125;
        else l = mid + 1;
    &#125;
    if (check(res) == q)
        print(res);
    else puts(&quot;No solution&quot;);
    return 0;
&#125;
&#125; // namespace XSC062


C. 神族文字
https://www.becoder.com.cn/contest/3416/problem/3
我不理解？这到底和分治有什么关系？GM 不会是纯看标签拉题吧？标签又是哪个聪明打的？
总而言之，言而总之，我们打一个 map。

namespace XSC062 &#123;
using namespace fastIO;
using str = std::string;
str s1, s2, sl;
std::map&lt;str, str&gt; t;
int main() &#123;
    for (;;) &#123;
        std::getline(std::cin, sl);
        std::stringstream s(sl);
        if (s &gt;&gt; s1) &#123;
            s &gt;&gt; s2;
            t[s2] = s1;
        &#125;
        else break;
    &#125;
    while (std::cin &gt;&gt; s1) &#123;
        if (t.count(s1))
            std::cout &lt;&lt; t[s1] &lt;&lt; &#39;\n&#39;;
        else puts(&quot;eh&quot;);
    &#125;
    return 0;
&#125;
&#125; // namespace XSC062


D. 逃亡
https://www.becoder.com.cn/contest/3416/problem/4
首先注意到车车是自动驾驶的，就是说一个人下车过后车会自动往另一个人的方向跑。
明显反复交接的话车会多跑很多路程，所以我们只交接一次。
所以难点只是用未知数把最终速度表示出来（想起了物理实验题）。
假设距离为 \(S\)，车速为 \(v_1\)，人速为 \(v_2\)，第一个人一直坐车坐到 \(x\) 路程，则最终时间为 \(\max\left\{ \dfrac x{v_1} + \dfrac {S - x}{v_2}, \dfrac x{v_1}+\dfrac {x - \dfrac x{v_1}\times v_2}{v_1 + v_2} + \dfrac {S-\dfrac x{v_1}\times v_2 - \dfrac {x - \dfrac x{v_1}\times v_2}{v_1 + v_2} \times v_2}{v_1}\right\}\)。
有一个很明显的点，就是 \(x\) 越大，第一个人用时就越短，第二个人用时就越多。这个时候我们就可以二分 \(x\)，尽量使第一个人和第二个人用时接近（用时是一个关于 \(x\) 的分段函数，我们寻找其拐点），最终相同用时即为答案。

因为从来不是很喜欢浮点数二分，采用了先整数二分再框范围取精确答案的方法。
所以怎么又是二分？说好的分治场呢？
namespace XSC062 &#123;
using namespace fastIO;
using db = double;
const db eps = 1e-2;
db res, ans = 1e18;
int s, v1, v2, l, mid, r;
db min(db x, db y) &#123;
    return x &lt; y ? x : y; 
&#125;
db max(db x, db y) &#123;
    return x &gt; y ? x : y;
&#125;
bool check(int x) &#123;
    db t1 = x * 1.0 / v1;
    db r1 = t1 + (s - x) * 1.0 / v2;
    db t2 = (x - t1 * v2) / (v1 + v2);
    db r2 = t1 + t2 + (s - t1 * v2 - t2 * v2) / v1;
    return r1 &lt;= r2;
&#125;
int main() &#123;
    read(s), read(v2), read(v1);
    l = 0, r = s;
    while (l &lt;= r) &#123;
        mid = (l + r) &gt;&gt; 1;
        if (check(mid)) &#123;
            res = (db)mid;
            r = mid - 1;
        &#125;
        else l = mid + 1;
    &#125;
    for (db i = res - 2; i &lt;= res + 2; i += eps) &#123;
        db t1 = i * 1.0 / v1;
        db r1 = t1 + (s - i) * 1.0 / v2;
        db t2 = (i - t1 * v2) / (v1 + v2);
        db r2 = t1 + t2 +
                (s - t1 * v2 - t2 * v2) / v1;
        ans = min(ans, max(r1, r2));
    &#125;
    printf(&quot;%.2lf&quot;, ans);
    return 0;
&#125;
&#125; // namespace XSC062


E. 剔除多余括号
https://www.becoder.com.cn/contest/3416/problem/5
为了套取数据理解题意，我用 python 交了一个 print(input())，结果总司令在上，得到了 33pts 的高分…
什么叫多余括号呢？括号前后的符号优先级小于等于括号中的符号，并且若括号内存在括号与括号前同级，则括号前不为 - 或 /。
这样就可以了。我们将问题划分为若干个子问题，对每个括号内的内容进行相同方式的处理：对比括号内优先级最高的符号和括号前后符号的优先级，处理括号内的内容时若遇到括号，则递归地进行相似的处理。

其实这个充其量只能算是模拟…… 跟分治并不是很有关系，和 CSP-J 2022 T3 有点像。
namespace XSC062 &#123;
using namespace fastIO;
const int maxn = 260;
int n;
char s[maxn];
bool vis[maxn];
int max(int x, int y) &#123;
    return x &gt; y ? x : y;
&#125;
int Deal(int l, int r) &#123;
    int res = 1;
    for (int i = l; i &lt;= r; ++i) &#123;
        if (s[i] == &#39;+&#39; || s[i] == &#39;-&#39;)
            res = max(res, 1);
        else if (s[i] == &#39;*&#39; || s[i] == &#39;/&#39;)
            res = 2;
        else if (s[i] == &#39;(&#39;) &#123;
            int cnt = 1, j;
            for (j = i + 1; j &lt;= r; ++j) &#123;
                if (s[j] == &#39;(&#39;)
                    ++cnt;
                else if (s[j] == &#39;)&#39;)
                    --cnt;
                if (cnt == 0)
                    break;
            &#125;
            cnt = Deal(i + 1, j - 1);
            int t = 1;
            int p1 = i - 1, p2 = j + 1;
            while (s[p1] == &#39;(&#39; || s[p1] == &#39;)&#39;)
                --p1;
            while (s[p2] == &#39;(&#39; || s[p2] == &#39;)&#39;)
                ++p2;
            if (s[p1] == &#39;+&#39; || s[p1] == &#39;-&#39;)
                t = max(t, 1);
            else t = max(t, 2);
            if (s[p2] == &#39;+&#39; || s[p2] == &#39;-&#39;)
                t = max(t, 1);
            else t = max(t, 2);
            if (t &lt; cnt)
                vis[i] = vis[j] = 1;
            else if (t == cnt) &#123;
                if (s[p1] != &#39;-&#39; &amp;&amp; s[p1] != &#39;/&#39;)
                    vis[i] = vis[j] = 1;
            &#125;
            i = j;
        &#125;
    &#125;
    return res;
&#125;
int main() &#123;
    s[1] = &#39;+&#39;;
    scanf(&quot;%s&quot;, s + 2);
    n = strlen(s + 1) + 1;
    s[n] = &#39;+&#39;;
    Deal(1, n);
    for (int i = 2; i &lt; n; ++i) &#123;
        if (!vis[i])
            putchar(s[i]);
    &#125;
    return 0;
&#125;
&#125; // namespace XSC062


F. 最接近点对问题
https://www.becoder.com.cn/contest/3416/problem/6
分治典中典。
我们将点按照横坐标排序，对点 \(1\sim n\) 进行分治。
将求解区间包含的点分为两部分，假设左边部分和右边部分已经分别求解出了最近点对（出口即为求解区间仅包含两点，直接求出距离），考虑合并状态。则情况无非有三种：

答案为左边部分的答案
答案为右边部分的答案
答案为左、右各选取一点

前两者是已知量，则我们求解出第三种情况，选择最小值即可。
第三种情况有个很妙的处理方式：我们设前两种情况的答案较小者为 \(d\)，设求解区间最靠中间的点为 \(m\)。

若 \(m\) 为左边部分的点
则由于我们对半二分，\(m\) 一定是左边部分最靠右的点。

对于其余左边部分的节点：
若它们与 \(m\) 的横向距离已经大于等于 \(d\)，则它们与右边部分的点的横向距离会更大。连横向距离都已经大于等于当前最优解了，无需考虑纵向距离，筛除这部分点。
对于右边部分的节点：
若它们与 \(m\) 的横向距离已经大于等于 \(d\)，则它们与更左边的其他左边部分节点的横向距离会更大，故筛除这部分点。

若 \(m\) 为右边部分的点
同理。

综上，我们只用考虑求解区间内与 \(m\) 的横向距离小于 \(d\) 的点。
在筛选出这些点后，我们如何进行进一步的处理呢？答案是，枚举。
我们枚举每一对点，计算它们间的距离。若比答案小，则更新答案。
那这复杂度也太神奇了。所以我们给出一个同样神奇的优化：按纵坐标递增对筛选出的点排序。当二重循环筛选时，若当前第一层循环 \(i\) 与第二层循环 \(j\) 的纵向距离大于等于了当前最小答案，就可以将第二层循环 break 了。因为纵坐标单调，继续枚举距离会继续增加，离答案更远。
那看起来复杂度还是很神奇，理论上来说应该是 \(O(n^2\log n)\) 的呀？
考虑第一层循环 \(i\)。对于点 \(i\)，有哪些 \(j\) 可以满足它的要求，从而被枚举到呢？

由于点对无序，所以 \(j\) 从 \(i+1\) 开始枚举，所以 \(y_j&gt;y_i\)。
由于筛选条件，\(|x_i-x_m|&lt; d\) 且 \(|x_j-x_m|&lt; d\)。
由于 break 条件，\(y_j-y_i&lt; d\)。

合并一下就是，\(|x_i-x_j|\le 2\times d\)，且 \(0\le y_j - y_i \le d\)。那么我们可以画出一个底为 \(2\times d\)，高为 \(d\) 的矩形，且它的中轴线为 \(x=x_m\)，中轴线左右两边均为 \(d\times d\) 的正方形。
若任意两个点同在左边部分或同在右边部分，那么这一对点的贡献已经在分治时计算完成了，所以一定不会比 \(d\) 小。
有一个很妙的结论：满足条件的 \(j\) 在矩形的左半边和右半边最多只有三个。
为什么？同一部分中，任意两个 \(j\) 的距离至少为 \(d\)。那么四个 \(j\)，距离都为 \(d\)，那么正好就是整个左半边的正方形。别忘了一点，\(j\) 需满足的三个条件都是严格小于，所以不能碰到整个矩形的边界，所以一个部分中最多只能存在三个 \(j\)。
那么实际上看似 \(n^2\) 的枚举，在多个优化下就变成了 \(O(n)\)。再加上对筛选出的点纵坐标排序的时间，总体时间复杂度为 \(O(n\log^2 n)\)。

namespace XSC062 &#123;
using db = double;
const db inf = 1e18;
const int maxn = 6e4 + 5;
struct _ &#123; db x, y; &#125;;
int n;
_ a[maxn];
db dis(db x1, db y1, db x2, db y2) &#123;
    return sqrt((x1 - x2) * (x1 - x2) +
                (y1 - y2) * (y1 - y2));
&#125;
db min(db x, db y) &#123;
    return x &lt; y ? x : y;
&#125;
db abs(db x) &#123;
    return x &gt;= 0 ? x : -x;
&#125;
db Solu(int l, int r) &#123;
    if (l == r)
        return inf;
    if (l + 1 == r)
        return dis(a[l].x, a[l].y, a[r].x, a[r].y);
    int mid = (l + r) &gt;&gt; 1;
    db d = min(Solu(l, mid), Solu(mid + 1, r));
    std::vector&lt;_&gt; t;
    for (int i = l; i &lt;= r; ++i) &#123;
        if (abs(a[i].x - a[mid].x) &lt; d)
            t.push_back(a[i]);
    &#125;
    std::sort(t.begin(), t.end(),
        [&amp;](_ x, _ y) &#123; return x.y &lt; y.y; &#125;);
    for (int i = 0; i &lt; (int)t.size(); ++i) &#123;
        for (int j = i + 1; j &lt; (int)t.size(); ++j) &#123;
            if (t[j].y - t[i].y &gt;= d)
                break;
            d = min(d, dis(t[i].x, t[i].y,
                                t[j].x, t[j].y));
        &#125;
    &#125;
    return d;
&#125;
int main() &#123;
    scanf(&quot;%d&quot;, &amp;n);
    for (int i = 1; i &lt;= n; ++i)
        scanf(&quot;%lf %lf&quot;, &amp;a[i].x, &amp;a[i].y);
    std::sort(a + 1, a + n + 1,
        [&amp;](_ x, _ y) &#123; return x.x &lt; y.x; &#125;);
    printf(&quot;%.2lf\n&quot;, Solu(1, n) / 2);
    return 0;
&#125;
&#125; // namespace XSC062

考虑一个问题。代码的时间复杂度有两个 \(\log\)，这是极不好的（will be fixed）。

G. 残缺棋盘问题
https://www.becoder.com.cn/contest/3416/problem/7
首先考虑一个有趣的问题：\(4^n-1\) 一定被 \(3\) 整除吗？
一个简单的方法是使用数学归纳法进行证明，其思想也会在这道题中体现。
不过还有另一个方法：\(4^n-1=(3+1)^n-1\)，使用二项式定理则有：
\[
(3+1)^n-1=\sum_{i=0}^n {n\choose i} \times 3^{n-i}\times 1^i - 1
\]
不难发现除 \(i=n\) 时，前面每一项都有因子 \(3\)，而当 \(i=n\) 时，\({n\choose n}\times 3^0\times 1^n=1\)，与后面的 \(-1\) 抵消，故得证。

考虑将棋盘划分为若干个 \(2\times 2\) 的 1 级区域。对于缺口所在的 1 级区域，我们使用一个刚好贴合的三格板将其补齐成为一个完整的 1 级区域。
我们称包含四个完整的 \(2\times 2\) 的 1 级区域的 \(4\times 4\) 的区域为 2 级区域，对于包含了我们刚刚补齐的 1 级区域的 2 级区域，我们将最中间的四个格子视为一个 1 级区域并填充，接下来剩余的 3 个完整 1 级区域为各自失去一个能填充的格子，我们选取对应的三格板填充即可。
对于一个 \(8\times 8\) 的 3 级区域，若其包含我们填充完毕的 2 级区域，我们将最中间 \(2\times 2\) 的格子视为一个 1 级区域并填充。接下来，剩余的 3 个完整的 2 级区域成为缺失 1 个格子的 2 级区域，按之前的方法填充即可。
以此类推即可递归地填充完成整个棋盘。但现在又来了一个问题：这道题没有 SPJ。根据样例可知，填充规则是由外到内，中、左上、左下、右上、右下，我们按照此顺序进行分治递归即可。

namespace XSC062 &#123;
using namespace fastIO;
const int maxn = 105;
int n, x, y, cnt;
int t[maxn][maxn];
void getColor(int c, int r, int l, int x, int y) &#123;
    if (l == 2) &#123;
        ++cnt;
        for (int i = c; i &lt;= c + 1; ++i) &#123;
            for (int j = r; j &lt;= r + 1; ++j) &#123;
                if (i != x || j != y)
                    t[i][j] = cnt;
            &#125;
        &#125;
        return;
    &#125;
    l /= 2;
    if (x - c &lt; l) &#123;
        if (y - r &lt; l) &#123;
            getColor(c + l - 1, r + l - 1,
                        2, c + l - 1, r + l - 1);
            getColor(c, r, l, x, y);
            getColor(c + l, r, l, c + l, r + l - 1);
            getColor(c, r + l, l, c + l - 1, r + l);
            getColor(c + l, r + l, l, c + l, r + l);
        &#125;
        else &#123;
            getColor(c + l - 1, r + l - 1,
                        2, c + l - 1, r + l);
            getColor(c, r, l, c + l - 1, r + l - 1);
            getColor(c + l, r, l, c + l, r + l - 1);
            getColor(c, r + l, l, x, y);
            getColor(c + l, r + l, l, c + l, r + l);
        &#125;
    &#125;
    else &#123;
        if (y - r &lt; l) &#123;
            getColor(c + l - 1, r + l - 1,
                            2, c + l, r + l - 1);
            getColor(c, r, l, c + l - 1, r + l - 1);
            getColor(c + l, r, l, x, y);
            getColor(c, r + l, l, c + l - 1, r + l);
            getColor(c + l, r + l, l, c + l, r + l);
        &#125;
        else &#123;
            getColor(c + l - 1, r + l - 1,
                            2, c + l, r + l);
            getColor(c, r, l, c + l - 1, r + l - 1);
            getColor(c + l, r, l, c + l, r + l - 1);
            getColor(c, r + l, l, c + l - 1, r + l);
            getColor(c + l, r + l, l, x, y);
        &#125;
    &#125;
    return;
&#125;
int main() &#123;
    read(n), read(x), read(y);
    getColor(1, 1, n, x, y);
    for (int i = 1; i &lt;= n; ++i) &#123;
        for (int j = 1; j &lt;= n; ++j)
            print(t[i][j], &#39; &#39;);
        putchar(&#39;\n&#39;);
    &#125;
    return 0;
&#125;
&#125; // namespace XSC062


H. Tricky Function
https://www.becoder.com.cn/contest/3416/problem/8
GM 提示了这道题就是平面最近点对。豁然开朗。
不妨将 \(i\) 视作 \(x_i\)，将 \(\sum_{k=1}^i a_k\) 视作 \(y_i\)，则直接求解平面最近点对即可。
]]></content>
      <tags>
        <tag>分治</tag>
      </tags>
  </entry>
  <entry>
    <title>解题报告：两双手</title>
    <url>/20230418/</url>
    <content><![CDATA[凳子充分地让我切身实地地体会到了平行四边形的不稳定性。做题的时候可以 360° 无死角地把下半身转来转去，有点意思。也有点容易摔（×


A. 两双手
http://222.180.160.110:1024/contest/3506/problem/1
不难发现可以通过解二元一次方程组得到用几个 A 操作和 B 操作才能让横纵坐标分别改变一些特定的值。可惜我没能想到一个经典的容斥 DP 思想：
定义起点为点 \(0\)。定义 \(C(x,y)\) 表示从 \(x\) 点走到 \(y\) 点的方案数（可经过特殊点）。对于特殊点 \(1\sim n\)，顺序枚举，对于点 \(i\)，定义 \(f_i\) 表示从 \(0\sim i\) 不经过任何除 \(i\) 以外的特殊点的方案数，则 \(f_i=C(0,i)-\sum\limits_{j=1}^{i-1}f_j\times C(j,i)\)。其中 \(\sum\limits_{j=1}^{i-1}f_j\times C(j,i)\) 就是从 \(0\) 到 \(i\)，除 \(i\) 以外经过至少 1 个特殊点的方案数。用总方案数减去不合法方案数，则得到合法方案数。
一个细节。我们枚举时，可能会遇到只能从 \(i\) 到达 \(j\)，而不能从 \(j\) 到达 \(i\) 的情况。若恰好 \(j\) 在 \(i\) 前面，那么从 \(i\) 到 \(j\) 的路径就会被统计漏。这个时候怎么办呢？对于任意点 \(i\)，我们求得从 \(0\to i\) 所需的步数，并以此为关键字从小到大排序，那么我们就能保证，任意一条合法路径都会被我们统计到。
还是没那么难，有点套路。时间复杂度 \(O(n^2)\)。

namespace XSC062 &#123;
using namespace fastIO;
#define mkp std::make_pair
using pii = std::pair&lt;int, int&gt;;
const int lim = 1e6;
const int maxn = 505;
const int mod = 1e9 + 7;
const int maxm = 1e6 + 5;
struct _ &#123; int x, y, w; &#125;;
std::set&lt;pii&gt; t;
_ s[maxn], s1[maxn];
int fac[maxm], f[maxn];
int ex, ey, n1, n, ax, ay, bx, by;
inline int gcd(int x, int y) &#123;
    return y ? gcd(y, x % y) : x;
&#125;
inline int lcm(int x, int y) &#123;
    return x / gcd(x, y) * y;
&#125;
pii Solve(int a, int b, int c,
                int d, int e, int f) &#123;
    int N = 0, M = 0;
    if (!a) &#123;
        if (c % b)
            return mkp(-1, -1);
        M = c / b, f -= M * e;
        if (f % d)
            return mkp(-1, -1);
        N = f / d;
    &#125;
    else if (!b) &#123;
        if (c % a)
            return mkp(-1, -1);
        N = c / a, f -= N * d;
        if (f % e)
            return mkp(-1, -1);
        M = f / e;
    &#125;
    else if (!d) &#123;
        if (f % e)
            return mkp(-1, -1);
        M = f / e, f -= M * b;
        if (c % a)
            return mkp(-1, -1);
        N = c / a;
    &#125;
    else if (!e) &#123;
        if (f % d)
            return mkp(-1, -1);
        N = f / d, c -= N * a;
        if (c % b)
            return mkp(-1, -1);
        M = c / b;
    &#125;
    else &#123;
        int g = lcm(b, e);
        a *= g / b, c *= g / b, b = g;
        d *= g / e, f *= g / e, e = g;
        if ((c - f) % (a - d))
            return mkp(-1, -1);
        N = (c - f) / (a - d), c -= N * a;
        if (c % b)
            return mkp(-1, -1);
        M = c / b;
    &#125;
    return mkp(N, M);
&#125;
inline int qkp(int x, int y) &#123;
    int res = 1;
    while (y) &#123;
        if (y &amp; 1)
            (res *= x) %= mod;
        (x *= x) %= mod;
        y &gt;&gt;= 1;
    &#125;
    return res;
&#125;
inline int inv(int x) &#123;
    return qkp(x, mod - 2);
&#125;
inline int A(int n, int m) &#123;
    return (fac[n] * inv(fac[n - m])) % mod;
&#125;
inline int C(int n, int m) &#123;
    return (A(n, m) * inv(A(m, m))) % mod;
&#125;
inline void Init(void) &#123;
    fac[0] = 1;
    for (int i = 1; i &lt;= lim; ++i)
        fac[i] = (fac[i - 1] * i) % mod;
    return;
&#125;
int main() &#123;
    read(ex), read(ey), read(n1);
    read(ax), read(ay), read(bx), read(by);
    for (int i = 1; i &lt;= n1; ++i) &#123;
        read(s1[i].x), read(s1[i].y);
        pii t = Solve(ax, bx, s1[i].x,
                        ay, by, s1[i].y);
        s1[i].w = t.first + t.second;
    &#125;
    std::sort(s1 + 1, s1 + n1 + 1,
        [&amp;](_ x, _ y) &#123; return x.w &lt; y.w; &#125;);
    Init(), f[0] = 1, ++n1;
    s1[n1].x = ex, s1[n1].y = ey;
    for (int i = 1; i &lt;= n1; ++i) &#123;
        pii t = Solve(ax, bx, s1[i].x,
                        ay, by, s1[i].y);
        if (t.first &lt; 0 || t.second &lt; 0) &#123;
            if (i == n1) &#123;
                puts(&quot;0&quot;);
                return 0;
            &#125;
            continue;
        &#125;
        s[++n] = s1[i];
    &#125;
    for (int i = 1; i &lt;= n; ++i) &#123;
        for (int j = 1; j &lt; i; ++j) &#123;
            pii t = Solve(ax, bx, s[i].x
                - s[j].x, ay, by, s[i].y
                - s[j].y);
            if (t.first &lt; 0 || t.second &lt; 0)
                continue;
            (f[i] += (f[j] * C(t.first +
                    t.second, t.first)) %
                    mod) %= mod;
        &#125;
        pii t = Solve(ax, bx, s[i].x,
                    ay, by, s[i].y);
        f[i] = (C(t.first + t.second,
                t.first) + mod - f[i]) % mod;
    &#125;
    print(f[n]);
    return 0;
&#125;
&#125; // namespace XSC062

]]></content>
      <tags>
        <tag>DP</tag>
        <tag>计数</tag>
        <tag>容斥</tag>
      </tags>
  </entry>
  <entry>
    <title>学习笔记：中国剩余定理</title>
    <url>/20230527/</url>
    <content><![CDATA[upd on 04/27/25：发现该文没写完 


中国剩余定理
给定下列关于 \(x\) 的一元同余方程组：
\[
\begin {cases}
x \equiv a_1 \pmod {m_1}  \\
x \equiv a_2 \pmod {m_2}  \\
\quad \quad \vdots \\
x \equiv a_k \pmod {m_k}
\end {cases}
\] 其中对于 \(\forall \, 1\le i, j\le k\, (i\ne j)\)，满足 \(m_i \, \bot\, m_j\)。下面是求解该方程组的具体方法：
令 \(M = \prod \limits _{i = 1} ^ k m_i, \, M_i=\dfrac M {m_i}\)，则 \(x = \sum \limits _{i = 1} ^k a_i\times M_i\times M_i ^{-1} \pmod M\)。
其中，\(M_i^{-1}\) 是 \(M_i\) 在模 \(m_i\) 意义下的逆元（所以 \(M_i\times M_i^{-1}\) 的值并不是视觉上的 \(1\)）。
正确性证明：对于 \(\forall \, i\in \{1, 2, \cdots, k\}\)，有 \(M_i\mid M\)；对于 \(\forall \, j\in \{1, 2, \cdots, k\}\) 且 \(j\ne i\)，有 \(m_i\mid \dfrac M{m_j}\) 即 \(m_i\mid M_j\)，即 \(M_j\equiv 0\pmod {m_i}\)。
又 \(m_i\mid M\) 那么就有 \(x\equiv a_i\cdot M_i\cdot {M_i}^{-1}\equiv a_i\pmod {n_i}\)。
时间复杂度 \(O(n\log n)\)。注意求解逆元时要用到 exgcd。

int CRT(int k, int *a, int *m) &#123;
    int M = 1, x = 0;
    static int M1[maxn], Mi[maxn]; 
    for (int i = 1; i &lt;= k; ++i)
        M *= m[i];
    for (int i = 1; i &lt;= k; ++i) &#123;
        M1[i] = M / m[i];
        Mi[i] = getinv(M1[i], m[i]);
        (x += a[i] * M1[i] * Mi[i]) %= M;
    &#125;
    return x;
&#125;


扩展中国剩余定理
设有如下同余方程组：
\[
\begin {cases}
x \equiv a_1 \pmod {m_1} \\
x \equiv a_2 \pmod {m_2}
\end {cases}
\]
不保证 \(m_1 \, \bot \, m_2\)。
设 \(x = m_1 \times p_1 + a_1 = m_2 \times p_2 + a_2\)，其中 \(p_i \in \mathbb Z\)，则有 \(p_1 \times m_1 - p_2 \times m_2 = a_2 - a_1\)。
\(p_1\) 的值可以用 exgcd 求解，则原方程的解满足 \(x \equiv m_1\times p_1 + a_1 \pmod {M}\)，其中 \(M=\operatorname{lcm}(m_1, m_2)\)。
这样我们就得到了一个新的同余方程。对于 \(k&gt;2\) 的情况，我们不断合并两个同余方程即可得到最终同余方程。
此时根据题目要求（一般求最小值即 \(m_k\times p_k + a_k\)）求解答案即可。
时间复杂度 \(O(n\log n)\)，其中 \(\log\) 来自 exgcd。

int calc(int m1, int a1, int m2, int a2) &#123;
    int p1, p2;
    if (a2 - a1 &lt; 0)
        swap(a1, a2), swap(m1, m2);
    int g = exgcd(m1, p1, m2, p2);
    if ((a2 - a1) % g)
        return -1;
    p1 *= (a2 - a1) / g, m2 /= g;
    p1 = (p1 % m2 + m2) % m2;
    return p1 * m1 + a1;
&#125;
int exCRT(int k, int *a, int *m) &#123;
    for (int i = 2; i &lt;= k; ++i) &#123;
        a[i] = calc(m[i - 1],
                a[i - 1], m[i], a[i]);
        if (a[i] == -1)
            return -1;
        m[i] = lcm(m[i - 1], m[i]);
    &#125;
    return a[k] % m[k];
&#125;


D. Strange Way to Express Integers
http://222.180.160.110:1024/contest/3642/problem/4
板。但是要开 __int128。不知道为什么智力只用开 long long 就能跑过，我和揭哥就不行。

#define int __int128
namespace XSC062 &#123;
using namespace fastIO;
const int maxn = 1e5 + 5;
int n;
int a[maxn], m[maxn];
int gcd(int x, int y) &#123;
    return y ? gcd(y, x % y) : x;
&#125;
inline int lcm(int x, int y) &#123;
    return x / gcd(x, y) * y;
&#125;
inline void swap(int &amp;x, int &amp;y) &#123;
    x ^= y ^= x ^= y;
    return;
&#125;
int exgcd(int a, int &amp;x, int b, int &amp;y) &#123;
    if (b == 0) &#123;
        x = 1, y = 0;
        return a;
    &#125;
    int u = exgcd(b, x, a % b, y);
    int t = x;
    x = y, y = t - (a / b) * y;
    return u;
&#125;
inline int calc(int m1, int a1,
                    int m2, int a2) &#123;
    int p1, p2;
    if (a2 - a1 &lt; 0)
        swap(a1, a2), swap(m1, m2);
    int g = exgcd(m1, p1, m2, p2);
    if ((a2 - a1) % g)
        return -1;
    p1 *= (a2 - a1) / g, m2 /= g;
    p1 = (p1 % m2 + m2) % m2;
    return p1 * m1 + a1;
&#125;
inline int exCRT(int k, int *a, int *m) &#123;
    for (int i = 2; i &lt;= k; ++i) &#123;
        a[i] = calc(m[i - 1],
                a[i - 1], m[i], a[i]);
        if (a[i] == -1)
            return -1;
        m[i] = lcm(m[i - 1], m[i]);
    &#125;
    return a[k] % m[k];
&#125;
int main() &#123;
    while (read(n)) &#123;
        for (int i = 1; i &lt;= n; ++i)
            read(m[i]), read(a[i]);
        print(exCRT(n, a, m), &#39;\n&#39;);
    &#125;
    return 0;
&#125;
&#125; // namespace XSC062
#undef int

]]></content>
      <tags>
        <tag>CRT / exCRT</tag>
      </tags>
  </entry>
  <entry>
    <title>解题报告：匹配数</title>
    <url>/20230716-1/</url>
    <content><![CDATA[老题解批量补档。


https://www.becoder.com.cn/contest/3887/problem/2

求出最小的、不含前导零的 \(n\) 位数 \(x\)，满足 \(n-1\) 条限制，第 \(i\) 条限制规定 \(x\) 的第 \(i\) 位和 \(i + 1\) 位的关系（小于、大于、等于、不等于）。

如果正着 DP，也就是说先确定前面的数位再向后 DP，后面的数位就没办法决定选择哪个已有状态进行转移，因为我们没有办法仅凭上一位就得到哪个状态拥有最小的字典序。
但是题解很风轻云淡地给出了一个我一辈子想不出来的 fix：倒着 DP。我们只要保证每次选取最小的可行的下一位即可，这恰好符合字典序的定义。
记录前驱（or 后继？）后输出即可。

namespace XSC062 &#123;
using namespace fastIO;
const int maxm = 15;
const int maxn = 2e3 + 5;
int n;
char s[maxn];
int f[maxn][maxm];
void output(int i, int j) &#123;
    print(j);
    if (i != n)
        output(i + 1, f[i][j]);
    return;
&#125;
int main() &#123;
    scanf(&quot;%s&quot;, s + 1);
    n = strlen(s + 1) + 1;
    memset(f, -1, sizeof (f));
    for (int i = 0; i &lt;= 9; ++i)
        f[n][i] = 0x3f3f3f3f;
    for (int i = n - 1; i; --i) &#123;
        for (int j = 0; j &lt;= 9; ++j) &#123;
            if (s[i] == &#39;&gt;&#39;) &#123;
                for (int k = j - 1; k &gt;= 0; --k) &#123;
                    if (~f[i + 1][k])
                        f[i][j] = k;
                &#125;
            &#125;
            else if (s[i] == &#39;&lt;&#39;) &#123;
                for (int k = 9; k &gt; j; --k) &#123;
                    if (~f[i + 1][k])
                        f[i][j] = k;
                &#125;
            &#125;
            else if (s[i] == &#39;=&#39;) &#123;
                if (~f[i + 1][j])
                    f[i][j] = j;
            &#125;
            else &#123;
                for (int k = 9; ~k; --k) &#123;
                    if (k == j)
                        continue;
                    if (~f[i + 1][k])
                        f[i][j] = k;
                &#125;
            &#125;
        &#125;
    &#125;
    for (int i = 1; i &lt;= 9; ++i)
        if (~f[1][i]) &#123;
            output(1, i);
            break;
        &#125;
    return 0;
&#125;
&#125; // namespace XSC062

]]></content>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>解题报告：染色</title>
    <url>/20230716/</url>
    <content><![CDATA[老题解批量补档。


https://www.becoder.com.cn/contest/3887/problem/3

有 \(N\) 个格子排成一排，你需要用至多 \(M\) 种颜色给这些格子染色，每个格子恰好染成某一种颜色，不需要每种颜色都用上。求有多少种染色方案满足相邻的同色格子不超过 \(K\) 对。

不妨将一对相邻同色格子称为同色对，将一串连续的相同颜色称作一段，那么最极端的情况下会有 \(N\) 段（即不存在同色对）。
构造一段长度为 \(L\) 的 \(L\) 段序列（即不存在同色对）。此时将任意一段长度增加 1，则出现一对同色对。接下来，不论是选取长度为 2 的那一段，还是选取剩下的长度为 1 的段，将其长度增加 1，都会且仅会增加 1 对同色对。
以此类推，进行 \(K\) 次「选取一段并将其长度增加 1」的操作，可得到刚好 \(K\) 个同色对，此时序列长度为 \(L + K\)，而 段数没有变化，仍是一开始的 \(L\)。 所以反过来，如果在长度为 \(N\) 的序列中存在 \(K\) 个同色对，那么段数为 \(N-K\)。很难想象题解用「所以」两个字直接略过了上述推导过程
由此，我们只要考虑分别将序列任意分为非空的 \(N-K\sim N\) 段，就可以解决问题，隔板法可得将 \(N\) 分为 \(T\) 段的方案数为 \(C_{N-1}^{T-1}\)。在此基础上考虑染色，由乘法原理，将 \(T\) 段染色的方案为 \((m - 1)^{T - 1}\times M\)。
取 \(T=N-K\sim N\) 并求和问题即解决。

namespace XSC062 &#123;
using namespace fastIO;
const int maxn = 2e5 + 15;
const int mod = 998244353;
int fac[maxn];
int n, m, k, res;
inline int qkp(int x, int y) &#123;
    int res = 1;
    while (y) &#123;
        if (y &amp; 1)
            (res *= x) %= mod;
        (x *= x) %= mod;
        y &gt;&gt;= 1;
    &#125;
    return res;
&#125;
inline int inv(int x) &#123;
    return qkp(x, mod - 2);
&#125;
inline int A(int n, int m) &#123;
    return (fac[n] * inv(fac[n - m])) % mod;
&#125;
inline int C(int n, int m) &#123;
    return (A(n, m) * inv(A(m, m))) % mod;
&#125;
int main() &#123;
    read(n), read(m), read(k);
    fac[0] = 1;
    for (int i = 1; i &lt;= n + 5; ++i)
        fac[i] = (fac[i - 1] * i) % mod;
    for (int i = n - k; i &lt;= n; ++i) &#123;
        (res += ((C(n - 1, i - 1) *
                qkp(m - 1, i - 1)) % mod
                * m) % mod) %= mod;
    &#125;
    print(res, &#39;\n&#39;);
    return 0;
&#125;
&#125; // namespace XSC062
#undef int

]]></content>
      <tags>
        <tag>排列组合</tag>
      </tags>
  </entry>
  <entry>
    <title>解题报告：学习小组 / Bacterial Melee</title>
    <url>/20230717/</url>
    <content><![CDATA[CF756D Bacterial Melee。


给我整不会了。怎么处理平方？怎么控制参与总学生最多？其中一定又有什么我不知道的奇技淫巧。
一切尽在连边。

处理学生与社团间的选择关系
把学生向社团连边。学生只能选取某社团一次，故容量为 \(1\)。
一个学生选取某个社团并不会立即对最终花费带来可计算的影响，因为最终花费由该社团参与的 所有学生平方数 决定。
故这一步我们先不慌计算社团的代价，只算参与社团本身需要的手续费 \(F_i\)。但是需要注意到手续费是财务部的收入而非支出，故实际边权为 \(-F_i\)，计算答案时视作负支出（明显不会因此而产生负环，因此可以放心加边）。
处理学生的选择数量上限
学生最多只能选择 \(K\) 个社团，为保证这一点，我们将源点向学生连边，容量为 \(K\)。
很明显，代价也不在此处计算，故令费用为 \(0\)。
保证代价最小
一开始，我认为最小费用最大流一定会找到最小费用，这个处理是无意义的，后来被打脸了。
我们若欲在此图中寻得最小费用最大流，则 流一定最大。
而学生的流入容量为 \(K\)，为了满流，学生一定会尽可能多地选择社团，那么费用就会噌噌上涨。回到目标，即保证学生都选取至少一个社团时，支出最小。
那我们只要给机会让学生可以只选取一个社团就好了（当然也可以是两个、三个……）。
故让学生向终点连边，容量为 \(K-1\)，那么学生可以在选取了所有比较赚的社团后就不再选了，选这条边达到满流。同样因为该边流量只有 \(K-1\)，学生为了满流就只能再选至少一个社团，满足题意。
不选社团明显是没有手续费和社团支出的，故费用为 \(0\)。
处理社团本身支出
问题在于如何处理 \(a\) 这个平方项。
对于平方，我们可以联想到许多数学知识，譬如完全平方、平方差等，这里用到了平方差。
假如原来的代价是 \(C_i\times x^2\)，又加入了一个人，那么费用会变成 \(C_i\times (x + 1)^2\)。由平方差得两者之差为 \(C_i\times (2\times x + 1)\)。当 \(x - 1\) 取为任意正整数时，\(2\times x + 1\) 即为所有奇数。
所以我们将社团向汇点连边，连很多条边，每条边表示 新增一个团员的代价，容量为 \(1\) 表示一个新增团员，费用为从 \(1\) 开始，一直到 \(2\times (N - 1) + 1\) 的所有奇数。

那么问题到这里就算处理完了。直接上费用流即可。
不知道我的代码遭遇了哪家宇宙射线的侵蚀，Dinic 死活过不去，换成 EK 就过了。同学们如果发现自己的 Dinic 过不了也可以试试换 EK。

#define int long long
namespace XSC062 &#123;
using namespace fastIO;
const int maxn = 405;
const int inf = 1e18;
const int maxm = 5e5 + 5;
struct _ &#123;
    int v, c, w, n;
    _() &#123;&#125;
    _(int v1, int c1, int w1, int n1) &#123;
        v = v1, c = c1, w = w1, n = n1;
    &#125;
&#125;;
_ u[maxm];
bool inq[maxn];
int n, m, k, x, res;
int gs, gt, tot = 1;
int c[maxn], f[maxn];
int h[maxn], dis[maxn];
int fl[maxn], pre[maxn];
int min(int x, int y) &#123;
    return x &lt; y ? x : y;
&#125;
bool SPFA(int s, int n) &#123;
    std::queue&lt;int&gt; q;
    std::fill(dis + 1, dis + n + 1, inf);
    q.push(s), dis[s] = 0, inq[s] = 1;
    pre[s] = inf, pre[gt] = 0, fl[s] = inf;
    while (!q.empty()) &#123;
        int f = q.front();
        q.pop(), inq[f] = 0;
        for (int i = h[f]; i; i = u[i].n) &#123;
            if (u[i].c == 0)
                continue;
            int v = u[i].v, w = u[i].w;
            if (dis[v] &gt; dis[f] + w) &#123;
                pre[v] = i ^ 1;
                dis[v] = dis[f] + w;
                fl[v] = min(fl[f], u[i].c);
                if (!inq[v])
                    inq[v] = 1, q.push(v);
            &#125;
        &#125;
    &#125;
    return pre[gt];
&#125;
void SSP(int s, int n) &#123;
    int p, mn, d;
    while (SPFA(s, n)) &#123;
        mn = fl[gt], d = 0;
        for (p = gt; p != s; p = u[pre[p]].v) &#123;
            u[pre[p]].c += mn;
            u[pre[p] ^ 1].c -= mn;
            d += u[pre[p] ^ 1].w;
        &#125;
        res += mn * d;
    &#125;
    return;
&#125;
void add(int x, int y, int c, int w) &#123;
    u[++tot] = _(y, c, w, h[x]);
    h[x] = tot;
    return;
&#125;
void readx(int &amp;x) &#123;
    char ch = nec();
    while (ch != &#39;0&#39; &amp;&amp; ch != &#39;1&#39;)
        ch = nec();
    x = ch - &#39;0&#39;;
    return;
&#125;
int main() &#123;
    read(n), read(m), read(k);
    gs = n + m + 1, gt = gs + 1;
    for (int i = 1; i &lt;= m; ++i) &#123;
        read(c[i]);
        for (int j = 0; j &lt; n; ++j) &#123;
            add(i + n, gt, 1,
                    (2 * j + 1) * c[i]);
            add(gt, i + n, 0,
                    -(2 * j + 1) * c[i]);
        &#125;
    &#125;
    for (int i = 1; i &lt;= m; ++i)
        read(f[i]);
    for (int i = 1; i &lt;= n; ++i) &#123;
        add(gs, i, k, 0);
        add(i, gs, 0, 0);
        add(i, gt, k - 1, 0);
        add(gt, i, 0, 0);
        for (int j = 1; j &lt;= m; ++j) &#123;
            readx(x);
            if (x == 1) &#123;
                add(i, j + n, 1, -f[j]); // 负代价
                add(j + n, i, 0, f[j]);
            &#125;
        &#125;
    &#125;
    SSP(gs, gt);
    print(res, &#39;\n&#39;);
    return 0;
&#125;
&#125; // namespace XSC062
#undef int

]]></content>
      <tags>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title>杂题选谈：费用流</title>
    <url>/20230720/</url>
    <content><![CDATA[费用流入门练习。


A. 订货
https://www.becoder.com.cn/contest/3820/problem/1
这个带继承关系的模型很熟悉，想到了 猪 那一题。所以我们试着仿照这个方式来建图。
题目提到了单位费用，这简直就是直接把边的费用拍你脸上嘲讽。
我们拉一个大源点，朝每个月连一条容量为无穷大、费用为当月购买单位费用的边，表示每个月的购买。
拉一个大汇点，每个月朝它连一条容量为当月需求量、费用为 \(0\) 的边，表示每个月的需求。
再让每个月朝下一个月连一条容量为仓库容量、费用为贮存费用的边，表示继承。跑一个最小费用最大流即可。

#define int long long
namespace XSC062 &#123;
using namespace fastIO;
const int maxn = 405;
const int inf = 1e18;
const int maxm = 5e5 + 5;
struct _ &#123;
    int v, c, w, n;
    _() &#123;&#125;
    _(int v1, int c1, int w1, int n1) &#123;
        v = v1, c = c1, w = w1, n = n1;
    &#125;
&#125;;
_ u[maxm];
bool inq[maxn];
int n, m, S, x, res;
int gs, gt, tot = 1;
int h[maxn], dis[maxn];
int fl[maxn], pre[maxn];
int min(int x, int y) &#123;
    return x &lt; y ? x : y;
&#125;
bool SPFA(int s, int n) &#123;
    std::queue&lt;int&gt; q;
    std::fill(dis + 1, dis + n + 1, inf);
    q.push(s), dis[s] = 0, inq[s] = 1;
    pre[s] = inf, pre[gt] = 0, fl[s] = inf;
    while (!q.empty()) &#123;
        int f = q.front();
        q.pop(), inq[f] = 0;
        for (int i = h[f]; i; i = u[i].n) &#123;
            if (u[i].c == 0)
                continue;
            int v = u[i].v, w = u[i].w;
            if (dis[v] &gt; dis[f] + w) &#123;
                pre[v] = i ^ 1;
                dis[v] = dis[f] + w;
                fl[v] = min(fl[f], u[i].c);
                if (!inq[v])
                    inq[v] = 1, q.push(v);
            &#125;
        &#125;
    &#125;
    return pre[gt];
&#125;
void SSP(int s, int n) &#123;
    int p, mn, d;
    while (SPFA(s, n)) &#123;
        mn = fl[gt], d = 0;
        for (p = gt; p != s; p = u[pre[p]].v) &#123;
            u[pre[p]].c += mn;
            u[pre[p] ^ 1].c -= mn;
            d += u[pre[p] ^ 1].w;
        &#125;
        res += mn * d;
    &#125;
    return;
&#125;
void add(int x, int y, int c, int w) &#123;
    u[++tot] = _(y, c, w, h[x]);
    h[x] = tot;
    return;
&#125;
void addf(int x, int y, int c, int w) &#123;
    add(x, y, c, w), add(y, x, 0, -w);
    return;
&#125;
int main() &#123;
    read(n), read(m), read(S);
    gs = n + 1, gt = gs + 1;
    for (int i = 1; i &lt;= n; ++i) &#123;
        read(x);
        addf(i, gt, x, 0);
        if (i != n)
            addf(i, i + 1, S, m);
    &#125;
    for (int i = 1; i &lt;= n; ++i) &#123;
        read(x);
        addf(gs, i, inf, x);
    &#125;    
    SSP(gs, gt);
    print(res, &#39;\n&#39;);
    return 0;
&#125;
&#125; // namespace XSC062
#undef int  


B. 网络扩容
https://www.becoder.com.cn/contest/3820/problem/2
鉴于一道费用流不会无缘无故先让你求一遍最大流，我们先持观望态度，暂且认为最大流对题目有提示作用 而不是说这道题就是个缝合怪
其实看完题我们就悟了，这怎么这么像上下界网络流那个差量网络呀，要不我们试试这么干？
我们先求得普通网络中的最大流，然后每条边减去流量，就成为了一个「差量网络 Pro」。那么我们现在就要通过扩容让该网络中的最大流变为 \(K\)。对于扩容的操作，不难想到把每条边的边权设为正无穷，然后费用设为扩容费用。
现在有了一个问题：原图中未留满的边，在现在的新网络中的残余容量应该如何处理呢？很简单，我们就把它当作已经扩过了这么多容，通过拆边操作拆出来一条容量为原图中残余容量、费用为 \(0\)「会员通道」，那么算法就会优先选择这条边。
怎么去控制流量为 \(K\)？联想到之前的拆边操作，我们考虑拆点。在 \(1\) 和 \(N\) 中任选一个拆开作为新的源点 / 汇点，新点和旧点之间的容量为 \(K\)、费用为 \(0\) 即可。
然后跑一个最小费用最大流就行。该说不说题目的正解思路引导做得还挺好的
其实注意到在跑完最大流之后，所有正向边的残余容量已经求得，只要在跑最大流时令所有边的费用为 \(0\)（毕竟最大流不关心费用），就可以沿用原图，只加新边再跑费用流。

#define int long long
namespace XSC062 &#123;
using namespace fastIO;
const int inf = 1e18;
const int maxn = 1e3 + 5;
const int maxm = 5e5 + 5;
struct _ &#123;
    int v, c, w, n;
    _() &#123;&#125;
    _(int v1, int c1, int w1, int n1) &#123;
        v = v1, c = c1, w = w1, n = n1;
    &#125;
&#125;;
struct __ &#123; int x, y, c, w; &#125;;
_ u[maxm];
__ w[maxm];
bool inq[maxn];
int n, m, k, res;
int gs, gt, tot = 1;
int h[maxn], dis[maxn];
int fl[maxn], pre[maxn];
int vis[maxn], now[maxn], dep[maxn];
int min(int x, int y) &#123;
    return x &lt; y ? x : y;
&#125;
bool BFS(int n) &#123;
    std::fill(vis + 1, vis + n + 1, 0);
    std::fill(dep + 1, dep + n + 1, 0); 
    std::queue&lt;int&gt; q;
    dep[gs] = 1, vis[gs] = 1;
    q.push(gs), now[gs] = h[gs];
    while (!q.empty()) &#123;
        int f = q.front();
        q.pop();
        for (int i = h[f]; i; i = u[i].n) &#123;
            int v = u[i].v, w = u[i].c;
            if (vis[v] == 1 || w == 0)
                continue;
            vis[v] = 1, now[v] = h[v];
            dep[v] = dep[f] + 1, q.push(v);
            if (v == gt)
                return 1;
        &#125;
    &#125;
    return 0;
&#125;
int findP(int x, int flow = inf) &#123;
    if (x == gt)
        return flow;
    int rest = flow, i;
    for (i = now[x]; rest &amp;&amp; i; i = u[i].n) &#123;
        int v = u[i].v, w = u[i].c;
        now[x] = i;
        if (dep[v] != dep[x] + 1 || w == 0)
            continue;
        int t = findP(v, min(rest, w));
        if (t == 0)
            dep[v] = 0;
        rest -= t;
        u[i].c -= t, u[i ^ 1].c += t;
    &#125;
    return flow - rest;
&#125;
int Dinic(int n) &#123;
    int res = 0;
    while (BFS(n)) &#123;
        int t = findP(gs);
        while (t) &#123;
            res += t;
            t = findP(gs);
        &#125;
    &#125;
    return res;
&#125;
bool SPFA(int s, int n) &#123;
    std::queue&lt;int&gt; q;
    std::fill(dis + 1, dis + n + 1, inf);
    q.push(s), dis[s] = 0, inq[s] = 1;
    pre[s] = inf, pre[gt] = 0, fl[s] = inf;
    while (!q.empty()) &#123;
        int f = q.front();
        q.pop(), inq[f] = 0;
        for (int i = h[f]; i; i = u[i].n) &#123;
            if (u[i].c == 0)
                continue;
            int v = u[i].v, w = u[i].w;
            if (dis[v] &gt; dis[f] + w) &#123;
                pre[v] = i ^ 1;
                dis[v] = dis[f] + w;
                fl[v] = min(fl[f], u[i].c);
                if (!inq[v])
                    inq[v] = 1, q.push(v);
            &#125;
        &#125;
    &#125;
    return pre[gt];
&#125;
void SSP(int s, int n) &#123;
    int p, mn, d;
    while (SPFA(s, n)) &#123;
        mn = fl[gt], d = 0;
        for (p = gt; p != s; p = u[pre[p]].v) &#123;
            u[pre[p]].c += mn;
            u[pre[p] ^ 1].c -= mn;
            d += u[pre[p] ^ 1].w;
        &#125;
        res += mn * d;
    &#125;
    return;
&#125;
void add(int x, int y, int c, int w) &#123;
    u[++tot] = _(y, c, w, h[x]);
    h[x] = tot;
    return;
&#125;
void addf(int x, int y, int c, int w = 0) &#123;
    add(x, y, c, w), add(y, x, 0, -w);
    return;
&#125;
int main() &#123;
    read(n), read(m), read(k);
    gs = 1, gt = n;
    for (int i = 1; i &lt;= m; ++i) &#123;
        read(w[i].x), read(w[i].y);
        read(w[i].c), read(w[i].w);
        addf(w[i].x, w[i].y, w[i].c);
    &#125;
    print(Dinic(n), &#39; &#39;);
    gs = n + 1, addf(gs, 1, k, 0);
    for (int i = 1; i &lt;= m; ++i)
        addf(w[i].x, w[i].y, inf, w[i].w);
    SSP(gs, gt);
    print(res, &#39;\n&#39;);
    return 0;
&#125;
&#125; // namespace XSC062
#undef int


C. 航班安排
https://www.becoder.com.cn/contest/3820/problem/3
很简单一个道理，时间的具体值对我们来说并不重要。能到就是能到，不能到就是不能到。
边权矩阵也并不是全部有用，这条边和任务有关系吗？没有，那就当它是空气。
那什么会对我们产生限制？飞机数量。故容量由飞机数量决定。什么是我们要最大化的值？收益，故我们的费用是支出。
如果飞机能在一个任务结束之后，在另一个任务开始之前飞过去，那就将两个任务连边，容量为 \(1\)，费用为两点间花费。特别地，应将机场拆为大源点和大汇点，并在二者中任选其一拆点（和 T2 类似），好作出 \(K\) 的流量限制。
还有一个小细节，对于一个任务的流量我们也要加以约束，不然碰到流入 \(2\) 流出 \(2\) 这种平衡但不合法的情况就不行了，所以对于任务我们也要按老套路拆点。

#define int long long
namespace XSC062 &#123;
using namespace fastIO;
const int inf = 1e18;
const int maxn = 405;
const int maxm = 4e5 + 5;
struct _ &#123;
    int v, c, w, n;
    _() &#123;&#125;
    _(int v1, int c1, int w1, int n1) &#123;
        v = v1, c = c1, w = w1, n = n1;
    &#125;
&#125;;
struct __ &#123;
    int x, y, l, r, c;
    bool operator&lt; (const __ &amp;q) const &#123;
        return l &lt; q.l;
    &#125;
&#125;;
_ u[maxm];
__ w[maxn];
bool inq[maxn];
int gs, gt, tot = 1;
int h[maxn], dis[maxn];
int fl[maxn], pre[maxn];
int n, m, k, T, res, fs, ft;
int t[maxn][maxn], f[maxn][maxn];
int min(int x, int y) &#123;
    return x &lt; y ? x : y;
&#125;
bool SPFA(int s, int n) &#123;
    std::queue&lt;int&gt; q;
    std::fill(dis + 1, dis + n + 1, inf);
    q.push(s), dis[s] = 0, inq[s] = 1;
    pre[s] = inf, pre[gt] = 0, fl[s] = inf;
    while (!q.empty()) &#123;
        int f = q.front();
        q.pop(), inq[f] = 0;
        for (int i = h[f]; i; i = u[i].n) &#123;
            if (u[i].c == 0)
                continue;
            int v = u[i].v, w = u[i].w;
            if (dis[v] &gt; dis[f] + w) &#123;
                pre[v] = i ^ 1;
                dis[v] = dis[f] + w;
                fl[v] = min(fl[f], u[i].c);
                if (!inq[v])
                    inq[v] = 1, q.push(v);
            &#125;
        &#125;
    &#125;
    return pre[gt];
&#125;
void SSP(int s, int n) &#123;
    int p, mn, d;
    while (SPFA(s, n)) &#123;
        mn = fl[gt], d = 0;
        for (p = gt; p != s; p = u[pre[p]].v) &#123;
            u[pre[p]].c += mn;
            u[pre[p] ^ 1].c -= mn;
            d += u[pre[p] ^ 1].w;
        &#125;
        res += mn * d;
    &#125;
    return;
&#125;
void add(int x, int y, int c, int w) &#123;
    u[++tot] = _(y, c, w, h[x]);
    h[x] = tot;
    return;
&#125;
void addf(int x, int y, int c, int w) &#123;
    add(x, y, c, w), add(y, x, 0, -w);
    return;
&#125;
int main() &#123;
    read(n), read(m), read(k), read(T);
    fs = 2 * m + 1, ft = 2 * m + 2;
    gs = 2 * m + 3, gt = 2 * m + 4;
    addf(gs, fs, k, 0), addf(ft, gt, k, 0);
    for (int i = 1; i &lt;= n; ++i) &#123;
        for (int j = 1; j &lt;= n; ++j)
            read(t[i][j]);
    &#125;
    for (int i = 1; i &lt;= n; ++i) &#123;
        for (int j = 1; j &lt;= n; ++j)
            read(f[i][j]);
    &#125;
    for (int i = 1; i &lt;= m; ++i) &#123;
        read(w[i].x), read(w[i].y);
        read(w[i].l), read(w[i].r);
        read(w[i].c), ++w[i].x, ++w[i].y;
    &#125;
    for (int i = 1; i &lt;= m; ++i) &#123;
        addf(i + m, i, 1, 0);
        if (t[1][w[i].x] &lt;= w[i].l) &#123;
            addf(fs, i + m, 1,
                f[1][w[i].x] - w[i].c);
        &#125;
        if (w[i].r + t[w[i].y][1] &lt;= T)
            addf(i, ft, 1, f[w[i].y][1]);
        for (int j = 1; j &lt;= m; ++j) &#123;
            if (i != j &amp;&amp; w[i].r +
                t[w[i].y][w[j].x] &lt;= w[j].l) &#123;
                addf(i, j + m, 1,
                    f[w[i].y][w[j].x] - w[j].c);
            &#125;
        &#125;
    &#125;
    SSP(gs, gt);
    print(-res, &#39;\n&#39;);
    return 0;
&#125;
&#125; // namespace XSC062
#undef int


D. 修车
https://www.becoder.com.cn/contest/3820/problem/4
顾客数一定，所谓平均等待时间不过是个幌子，只需要求得最小等待总时间。
技术人员不能同时修两辆车，\(M\) 的范围又这么小，不往拆点想都难。可问题来了，怎么拆呢？
我一开始的想法是，用点 \((i, j)\) 表示人 \(i\) 修车 \(j\)，但是这样建图怎样也无法达到目的。
于是我添加了一个维度 \(k\)，用点 \((i, j, k)\) 表示人 \(i\) 修车 \(j\)，并且这是他修的倒数第 \(k\) 辆车，这样建图就轻而易举了。但接下来就面临了一个问题：这数据范围跑不过。于是乎审视我们的点，其实 \(j\) 这个维度是可以被合并的，只保留 \((i, k)\)，因为不可能存在两辆车同时为人 \(i\) 的倒数第 \(k\) 辆车。
故将大源点和每辆车连边，容量为 \(1\)，费用为 \(0\)；将每辆车 \(j\) 和每个 \((i, k)\) 连边，容量为 \(1\)，费用为 \(T_{i, j}\times k\)。
这里有一点点费用提前计算的意思，所以就直接将每个 \((i, j)\) 和大汇点连边，容量为 \(1\)，费用为 \(0\)。

#define int long long
namespace XSC062 &#123;
using namespace fastIO;
const int inf = 1e18;
const int maxn = 1e4 + 5;
const int maxm = 1e6 + 5;
struct _ &#123;
    int v, c, w, n;
    _() &#123;&#125;
    _(int v1, int c1, int w1, int n1) &#123;
        v = v1, c = c1, w = w1, n = n1;
    &#125;
&#125;;
_ u[maxm];
bool inq[maxn];
int n, m, x, res;
int gs, gt, tot = 1;
int h[maxn], dis[maxn];
int fl[maxn], pre[maxn];
int fun(int i, int j) &#123;
    return n + (i - 1) * n + j;
&#125;
int min(int x, int y) &#123;
    return x &lt; y ? x : y;
&#125;
bool SPFA(int s, int n) &#123;
    std::queue&lt;int&gt; q;
    std::fill(dis + 1, dis + n + 1, inf);
    q.push(s), dis[s] = 0, inq[s] = 1;
    pre[s] = inf, pre[gt] = 0, fl[s] = inf;
    while (!q.empty()) &#123;
        int f = q.front();
        q.pop(), inq[f] = 0;
        for (int i = h[f]; i; i = u[i].n) &#123;
            if (u[i].c == 0)
                continue;
            int v = u[i].v, w = u[i].w;
            if (dis[v] &gt; dis[f] + w) &#123;
                pre[v] = i ^ 1;
                dis[v] = dis[f] + w;
                fl[v] = min(fl[f], u[i].c);
                if (!inq[v])
                    inq[v] = 1, q.push(v);
            &#125;
        &#125;
    &#125;
    return pre[gt];
&#125;
void SSP(int s, int n) &#123;
    int p, mn, d;
    while (SPFA(s, n)) &#123;
        mn = fl[gt], d = 0;
        for (p = gt; p != s; p = u[pre[p]].v) &#123;
            u[pre[p]].c += mn;
            u[pre[p] ^ 1].c -= mn;
            d += u[pre[p] ^ 1].w;
        &#125;
        res += mn * d;
    &#125;
    return;
&#125;
void add(int x, int y, int c, int w) &#123;
    u[++tot] = _(y, c, w, h[x]);
    h[x] = tot;
    return;
&#125;
void addf(int x, int y, int c, int w) &#123;
    add(x, y, c, w), add(y, x, 0, -w);
    return;
&#125;
int main() &#123;
    read(m), read(n);
    gs = n * m + n + 1, gt = gs + 1;
    for (int i = 1; i &lt;= n; ++i)
        addf(gs, i, 1, 0);
    for (int i = 1; i &lt;= n * m; ++i)
        addf(i + n, gt, 1, 0);
    for (int i = 1; i &lt;= n; ++i) &#123;
        for (int j = 1; j &lt;= m; ++j) &#123;
            read(x);
            for (int k = 1; k &lt;= n; ++k) &#123;
                addf(i, fun(j, k),
                            1, x * k);
            &#125;
        &#125;
    &#125;
    SSP(gs, gt);
    printf(&quot;%.2lf&quot;, res * 1.0 / n);
    return 0;
&#125;
&#125; // namespace XSC062
#undef int


E. 连连看
https://www.becoder.com.cn/contest/3820/problem/5
样例已经告诉了我们事实：小心删数，因为会有数同时出现在多组勾股数中。
还是熟悉的单点 \(1\) 流量限制，故拆点为入点和出点，入点连大源点容量为 \(1\) 费用为 \(0\)，出点连大汇点容量为 \(1\) 费用为 \(0\)，满足条件的 \(x\) 和 \(y\) 我们为了不整细节就暴力地连双向边然后跑最大费用最大流。
由于双向边这个神必操作，最后的最大流和最大费用都会翻倍，输出的时候要减半。

#define int long long
namespace XSC062 &#123;
using namespace fastIO;
const int inf = 1e18;
const int maxn = 2e3 + 5;
const int maxm = 4e5 + 5;
struct _ &#123;
    int v, c, w, n;
    _() &#123;&#125;
    _(int v1, int c1, int w1, int n1) &#123;
        v = v1, c = c1, w = w1, n = n1;
    &#125;
&#125;;
_ u[maxm];
bool inq[maxn];
int l, r, res, cnt;
bool f[maxn][maxn];
int gs, gt, tot = 1;
int h[maxn], dis[maxn];
int fl[maxn], pre[maxn];
int gcd(int x, int y) &#123;
    return y ? gcd(y, x % y) : x;
&#125;
int min(int x, int y) &#123;
    return x &lt; y ? x : y;
&#125;
bool SPFA(int s, int n) &#123;
    std::queue&lt;int&gt; q;
    std::fill(dis + 1, dis + n + 1, -inf);
    q.push(s), dis[s] = 0, inq[s] = 1;
    pre[s] = inf, pre[gt] = 0, fl[s] = inf;
    while (!q.empty()) &#123;
        int f = q.front();
        q.pop(), inq[f] = 0;
        for (int i = h[f]; i; i = u[i].n) &#123;
            if (u[i].c == 0)
                continue;
            int v = u[i].v, w = u[i].w;
            if (dis[v] &lt; dis[f] + w) &#123;
                pre[v] = i ^ 1;
                dis[v] = dis[f] + w;
                fl[v] = min(fl[f], u[i].c);
                if (!inq[v])
                    inq[v] = 1, q.push(v);
            &#125;
        &#125;
    &#125;
    return pre[gt];
&#125;
void SSP(int s, int n) &#123;
    int p, mn, d;
    while (SPFA(s, n)) &#123;
        mn = fl[gt], d = 0;
        for (p = gt; p != s; p = u[pre[p]].v) &#123;
            u[pre[p]].c += mn;
            u[pre[p] ^ 1].c -= mn;
            d += u[pre[p] ^ 1].w;
        &#125;
        res += mn * d, cnt += mn;
    &#125;
    return;
&#125;
void add(int x, int y, int c, int w) &#123;
    u[++tot] = _(y, c, w, h[x]);
    h[x] = tot;
    return;
&#125;
void addf(int x, int y, int c, int w) &#123;
    if (f[x][y])
        return;
    f[x][y] = f[y][x] = 1;
    add(x, y, c, w), add(y, x, 0, -w);
    return;
&#125;
bool check(int x, int y) &#123;
    int z = sqrt(x * x - y * y);
    if (z * z + y * y == x * x)
        return (gcd(z, y) == 1);
    return 0;
&#125;
int main() &#123;
    read(l), read(r);
    gs = 2 * r + 1, gt = 2 * r + 2;
    for (int i = l; i &lt;= r; ++i) &#123;
        addf(gs, i, 1, 0);
        addf(i + r, gt, 1, 0);
        for (int j = l; j &lt; i; ++j) &#123;
            if (check(i, j)) &#123;
                addf(j, i + r, 1, i + j);
                addf(i, j + r, 1, i + j);
            &#125;
        &#125;
    &#125;
    SSP(gs, gt);
    print(cnt / 2, &#39; &#39;), print(res / 2, &#39;\n&#39;);
    return 0;
&#125;
&#125; // namespace XSC062
#undef int


依我看，队名就叫「曾总说的都队」吧 🐵
]]></content>
      <tags>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title>杂题选谈：网络流 24 题</title>
    <url>/20230722/</url>
    <content><![CDATA[Solution to 网络流 24 题。


Day 1：1st - 6th
A. 星际转移问题
https://www.becoder.com.cn/contest/3952/problem/1
如果就按照题目给的路线图，我们显然无法考虑到飞船到达的时刻。同时 \(n\) 和 \(m\) 又很小，我们就知道了，「人不能两次踏进同一条河流」，\(1\) 时刻的站 \(p\) 和 \(2\) 时刻的站 \(p\) 也不能是同一个站 \(p\)。
考虑用 \((p, t)\) 表示 \(t\) 时刻的站 \(p\)，然后对于每条路线跑个暴力连边，容量全部为 \(H_i\)。
怎么控制时间最小呢？二分一下就可以了…… 然后最大流判定是不是满流的即可。
以及注意到对于同一站点，前面的时刻可以留下来等后面的时刻，我们将同一站的前一时刻和后一时刻全部连边，容量为 \(k\)。以及保留节目对源点拆点以控制流量为 \(k\)。
经实验答案最大为 29，所以把二分上界设为 30 即可 理论上来说答案可能很大，比如你谷最后一组数据的答案就是 \(900\) 多，所以我掐指一算用天才般的算术技巧开了 \(10^4\)。真的，数数位天才就是我。

woc，这题居然没人做，果然我还是太强了。
为什么都跑去做 T4 了，这个不是按难度顺序排列的吗？
哦哦，好像不是，那（Na）没（Mei）事（Shi）了（Le）。

#define int long long
namespace XSC062 &#123;
using namespace fastIO;
const int lim = 1e4;
const int inf = 1e18;
const int maxm = 4e5 + 5;
const int maxn = 5e4 + 15;
struct _ &#123;
    int v, w, n;
    _() &#123;&#125;
    _(int v1, int w1, int n1) &#123;
        v = v1, w = w1, n = n1;
    &#125;
&#125;;
struct __ &#123;
    int c;
    std::vector&lt;int&gt; p;
&#125;;
_ u[maxm];
__ w[maxn];
int h[maxn];
int l, mid, r;
int gs, gt, tot = 1;
int n, m, k, s, mt, x, res, y;
int vis[maxn], now[maxn], dep[maxn];
int min(int x, int y) &#123; return x &lt; y ? x : y; &#125;
int fun(int p, int t) &#123; return (p - 1) * mt + t; &#125;
bool BFS(int n) &#123;
    std::fill(vis + 1, vis + n + 1, 0);
    std::fill(dep + 1, dep + n + 1, 0); 
    std::queue&lt;int&gt; q;
    dep[gs] = 1, vis[gs] = 1;
    q.push(gs), now[gs] = h[gs];
    while (!q.empty()) &#123;
        int f = q.front(); q.pop();
        for (int i = h[f]; i; i = u[i].n) &#123;
            int v = u[i].v, w = u[i].w;
            if (vis[v] == 1 || w == 0) continue;
            vis[v] = 1, now[v] = h[v];
            dep[v] = dep[f] + 1, q.push(v);
            if (v == gt) return 1;
        &#125;
    &#125;
    return 0;
&#125;
int findP(int x, int flow = inf) &#123;
    if (x == gt) return flow;
    int rest = flow, i;
    for (i = now[x]; rest &amp;&amp; i; i = u[i].n) &#123;
        int v = u[i].v, w = u[i].w;
        now[x] = i;
        if (dep[v] != dep[x] + 1 || w == 0)
            continue;
        int t = findP(v, min(rest, w));
        if (t == 0) dep[v] = 0;
        rest -= t, u[i].w -= t, u[i ^ 1].w += t;
    &#125;
    return flow - rest;
&#125;
int Dinic(int n) &#123;
    int res = 0;
    while (BFS(n)) &#123;
        int t = findP(gs);
        while (t) res += t, t = findP(gs);
    &#125;
    return res;
&#125;
void add(int x, int y, int w) &#123;
    u[++tot] = _(y, w, h[x]);
    h[x] = tot;
    return;
&#125;
void addf(int x, int y, int w) &#123;
    add(x, y, w), add(y, x, 0);
    return;
&#125;
void Init(void) &#123;
    tot = 1;
    memset(h, 0, sizeof (h));
    return;
&#125;
bool check(int x) &#123;
    Init();
    mt = x, s = fun(n, mt) + 1;
    gs = s + 1, gt = s + 2;
    addf(gs, s, k);
    for (int i = 1; i &lt;= mt; ++i) &#123;
        addf(s, fun(n - 1, i), k);
        addf(fun(n, i), gt, k);
    &#125;
    for (int i = 1; i &lt;= n; ++i) &#123;
        for (int j = 1; j &lt; mt; ++j)
            addf(fun(i, j), fun(i, j + 1), k);
    &#125;
    for (int i = 1; i &lt;= m; ++i) &#123;
        int p = 0, x = 0, la = 0;
        while (++p &lt;= mt) &#123;
            if (la != 0)
                addf(fun(la, p - 1), fun(w[i].p[x], p), w[i].c);
            la = w[i].p[x];
            if (++x &gt;= w[i].p.size()) x = 0;
        &#125;
    &#125;
    return (Dinic(gt) == k);
&#125;
int main() &#123;
    read(n), read(m), read(k);
    for (int i = 1; i &lt;= m; ++i) &#123;
        read(w[i].c), read(y);
        while (y--) &#123;
            read(x);
            if (x == 0) x = n + 1;
            else if (x == -1) x = n + 2;
            w[i].p.push_back(x);
        &#125;
    &#125;
    n += 2;
    l = 1, r = lim;
    while (l &lt;= r) &#123;
        mid = (l + r) &gt;&gt; 1;
        if (check(mid))
            res = mid, r = mid - 1;
        else l = mid + 1;
    &#125;
    print(res ? res - 1 : 0, &#39;\n&#39;);
    return 0;
&#125;
&#125; // namespace XSC062
#undef int


B. 最长递增子序列
https://www.becoder.com.cn/contest/3952/problem/2
就算知道不是按难度顺序排列我也要顺序开题。欸嘿，就是玩。
第一问很水，跑个 DP 就行。
第二问有点意思，取出就代表只能选一次，总之典中典，把每个数拆成入点和出点，容量为 \(1\)，这样就可以只选一次了。
那怎么保证每次找到的流一定是 LIS 呢？其实这和我们 Dinic 的深度分层数组有异曲同工之妙，我们把 \(f_i = f_j + 1(i&gt;j,A_i\ge A_j)\) 的 \((j, i)\) 连边，容量为 \(1\) 即可。
然后源点只和满足 \(f_x = 1\) 的 \(x\) 连边，相应地，汇点之和满足 \(f_x = \text{LIS}\) 的 \(x\) 连边。
第三问很好想啊，我们把 \(1\) 到源点和 \(n\) 到汇点的容量设成无穷大就好。
然后踩了半天的坑，这道题的拆点部分不知道为什么必须要连双向边。

#define int long long
namespace XSC062 &#123;
using namespace fastIO;
const int inf = 1e18;
const int maxm = 4e5 + 5;
const int maxn = 5e5 + 15;
struct _ &#123;
    int v, w, n;
    _() &#123;&#125;
    _(int v1, int w1, int n1) &#123;
        v = v1, w = w1, n = n1;
    &#125;
&#125;;
_ u[maxm];
int n, res;
int gs, gt, tot = 1;
int a[maxn], h[maxn], f[maxn];
int vis[maxn], now[maxn], dep[maxn];
int min(int x, int y) &#123; return x &lt; y ? x : y; &#125;
int max(int x, int y) &#123; return x &gt; y ? x : y; &#125;
bool BFS(int n) &#123;
    std::fill(vis + 1, vis + n + 1, 0);
    std::fill(dep + 1, dep + n + 1, 0); 
    std::queue&lt;int&gt; q;
    dep[gs] = 1, vis[gs] = 1;
    q.push(gs), now[gs] = h[gs];
    while (!q.empty()) &#123;
        int f = q.front(); q.pop();
        for (int i = h[f]; i; i = u[i].n) &#123;
            int v = u[i].v, w = u[i].w;
            if (vis[v] == 1 || w == 0) continue;
            vis[v] = 1, now[v] = h[v];
            dep[v] = dep[f] + 1, q.push(v);
            if (v == gt) return 1;
        &#125;
    &#125;
    return 0;
&#125;
int findP(int x, int flow = inf) &#123;
    if (x == gt) return flow;
    int rest = flow, i;
    for (i = now[x]; rest &amp;&amp; i; i = u[i].n) &#123;
        int v = u[i].v, w = u[i].w;
        now[x] = i;
        if (dep[v] != dep[x] + 1 || w == 0) continue;
        int t = findP(v, min(rest, w));
        if (t == 0) dep[v] = 0;
        rest -= t, u[i].w -= t, u[i ^ 1].w += t;
    &#125;
    return flow - rest;
&#125;
int Dinic(int n) &#123;
    int res = 0;
    while (BFS(n)) &#123;
        int t = findP(gs);
        while (t) res += t, t = findP(gs);
    &#125;
    return res;
&#125;
void add(int x, int y, int w) &#123;
    u[++tot] = _(y, w, h[x]);
    h[x] = tot;
    return;
&#125;
void addf(int x, int y, int w) &#123;
    add(x, y, w), add(y, x, 0);
    return;
&#125;
int main() &#123;
    read(n);
    gs = 2 * n + 1, gt = gs + 1;
    for (int i = 1; i &lt;= n; ++i) &#123;
        read(a[i]), f[i] = 1;
        addf(i, i + n, 1);
        addf(i + n, i, 1);
        for (int j = 1; j &lt; i; ++j) &#123;
            if (a[j] &lt;= a[i])
                f[i] = max(f[i], f[j] + 1);
        &#125;
        res = max(res, f[i]);
        for (int j = 1; j &lt; i; ++j) &#123;
            if (a[j] &lt;= a[i] &amp;&amp; f[i] == f[j] + 1)
                addf(j, i + n, 1);
        &#125;
    &#125;
    for (int i = 1; i &lt;= n; ++i) &#123;
        if (f[i] == 1) addf(gs, i, 1);
        if (f[i] == res) addf(i + n, gt, 1);
    &#125;
    print(res, &#39;\n&#39;);
    print(Dinic(gt), &#39;\n&#39;);
    tot = 1;
    memset(h, 0, sizeof (h));
    for (int i = 1; i &lt;= n; ++i) &#123;
        addf(i, i + n, 1);
        addf(i + n, i, 1);
        for (int j = 1; j &lt; i; ++j) &#123;
            if (a[j] &lt;= a[i] &amp;&amp; f[i] == f[j] + 1)
                addf(j, i + n, 1);
        &#125;
    &#125;
    for (int i = 1; i &lt;= n; ++i) &#123;
        if (f[i] == 1) &#123;
            if (i == 1) addf(gs, i, inf);
            else addf(gs, i, 1);
        &#125;
        if (f[i] == res) &#123;
            if (i == n) addf(i + n, gt, inf);
            else addf(i + n, gt, 1);
        &#125;
    &#125;
    print(Dinic(gt), &#39;\n&#39;);
    return 0;
&#125;
&#125; // namespace XSC062
#undef int


C. 餐巾计划问题
https://www.becoder.com.cn/contest/3952/problem/3
这个有点简单啊。就差把费用流三个大字拍你脸上了。
用过和没用过的餐巾是不能混合处理的，故考虑拆点，把每一天拆出来一个点表示当天所有用过的餐巾量（注意不止是当天用过的，还可以是前几天传下来的）。
首先不难想到大源点和每天的没用过连边，容量为无穷大，费用为购买费用，表示购买餐巾；用过的和下一天用过的连边，容量为无穷大，费用为 \(0\)，表示用过的餐巾的继承；用过的和快洗 / 慢洗所需时间后的没用过的连边，容量为无穷大，费用为快洗 / 慢洗费用，表示把用过的洗成没用过的（奇奇怪怪）。
那么问题来了，怎么表示使用餐巾呢？这里有一个很妙的处理方式，把没用过的朝大汇点连边，容量为当天使用量，费用为 \(0\)，表示把这么多没用过的餐巾销毁；再把大源点朝用过的连边，容量也为当天使用量，费用为 \(0\)，表示凭空变出来这么多条用过的餐巾。
然后跑个费用流就可以了。

#define int long long
namespace XSC062 &#123;
using namespace fastIO;
const int inf = 1e18;
const int maxn = 4e3 + 5;
const int maxm = 6e5 + 5;
struct _ &#123;
    int v, c, w, n;
    _() &#123;&#125;
    _(int v1, int c1, int w1, int n1) &#123;
        v = v1, c = c1, w = w1, n = n1;
    &#125;
&#125;;
_ u[maxm];
bool inq[maxn];
int gs, gt, tot = 1;
int h[maxn], dis[maxn];
int fl[maxn], pre[maxn];
int n, m, t1, c1, t2, c2, res, x;
int min(int x, int y) &#123; return x &lt; y ? x : y; &#125;
bool SPFA(int s, int n) &#123;
    std::queue&lt;int&gt; q;
    std::fill(dis + 1, dis + n + 1, inf);
    q.push(s), dis[s] = 0, inq[s] = 1;
    pre[s] = inf, pre[gt] = 0, fl[s] = inf;
    while (!q.empty()) &#123;
        int f = q.front();
        q.pop(), inq[f] = 0;
        for (int i = h[f]; i; i = u[i].n) &#123;
            if (u[i].c == 0) continue;
            int v = u[i].v, w = u[i].w;
            if (dis[v] &gt; dis[f] + w) &#123;
                pre[v] = i ^ 1;
                dis[v] = dis[f] + w;
                fl[v] = min(fl[f], u[i].c);
                if (!inq[v]) inq[v] = 1, q.push(v);
            &#125;
        &#125;
    &#125;
    return pre[gt];
&#125;
void SSP(int s, int n) &#123;
    int p, mn, d;
    while (SPFA(s, n)) &#123;
        mn = fl[gt], d = 0;
        for (p = gt; p != s; p = u[pre[p]].v) &#123;
            u[pre[p]].c += mn;
            u[pre[p] ^ 1].c -= mn;
            d += u[pre[p] ^ 1].w;
        &#125;
        res += mn * d;
    &#125;
    return;
&#125;
void add(int x, int y, int c, int w) &#123;
    u[++tot] = _(y, c, w, h[x]);
    h[x] = tot;
    return;
&#125;
void addf(int x, int y, int c, int w) &#123;
    add(x, y, c, w), add(y, x, 0, -w);
    return;
&#125;
int main() &#123;
    read(n);
    gs = 2 * n + 1, gt = gs + 1;
    for (int i = 1; i &lt;= n; ++i) &#123;
        read(x);
        addf(i, gt, x, 0);
        addf(gs, i + n, x, 0);
        if (i != n)
            addf(i + n, i + 1 + n, inf, 0);
    &#125;
    read(m), read(t1);
    read(c1), read(t2), read(c2);
    for (int i = 1; i &lt;= n; ++i) &#123;
        addf(gs, i, inf, m);
        if (i + t1 &lt;= n)
            addf(i + n, i + t1, inf, c1);
        if (i + t2 &lt;= n)
            addf(i + n, i + t2, inf, c2);
    &#125;
    SSP(gs, gt);
    print(res, &#39;\n&#39;);
    return 0;
&#125;
&#125; // namespace XSC062
#undef int


D. 运输问题
https://www.becoder.com.cn/contest/3952/problem/4
不是很理解啊，这题就一个普普通通的二分图建模，有什么难点吗，，，
哦，蓝的，那没事了。

#define int long long
namespace XSC062 &#123;
using namespace fastIO;
const int inf = 1e18;
const int maxn = 4e3 + 5;
const int maxm = 6e5 + 5;
struct _ &#123;
    int v, c, w, n;
    _() &#123;&#125;
    _(int v1, int c1, int w1, int n1) &#123;
        v = v1, c = c1, w = w1, n = n1;
    &#125;
&#125;;
bool inq[maxn];
int gs, gt, tot = 1;
_ u[maxm], u1[maxm];
int fl[maxn], pre[maxn];
int h[maxn], dis[maxn], h1[maxn];
int n, m, t1, c1, t2, c2, res, x;
int min(int x, int y) &#123;
    return x &lt; y ? x : y;
&#125;
bool SPFA(int s, int n) &#123;
    std::queue&lt;int&gt; q;
    std::fill(dis + 1, dis + n + 1, inf);
    q.push(s), dis[s] = 0, inq[s] = 1;
    pre[s] = inf, pre[gt] = 0, fl[s] = inf;
    while (!q.empty()) &#123;
        int f = q.front();
        q.pop(), inq[f] = 0;
        for (int i = h[f]; i; i = u[i].n) &#123;
            if (u[i].c == 0)
                continue;
            int v = u[i].v, w = u[i].w;
            if (dis[v] &gt; dis[f] + w) &#123;
                pre[v] = i ^ 1;
                dis[v] = dis[f] + w;
                fl[v] = min(fl[f], u[i].c);
                if (!inq[v]) inq[v] = 1, q.push(v);
            &#125;
        &#125;
    &#125;
    return pre[gt];
&#125;
bool SPFA1(int s, int n) &#123;
    std::queue&lt;int&gt; q;
    std::fill(pre + 1, pre + n + 1, 0);
    std::fill(dis + 1, dis + n + 1, -inf);
    q.push(s), dis[s] = 0, inq[s] = 1;
    pre[s] = inf, pre[gt] = 0, fl[s] = inf;
    while (!q.empty()) &#123;
        int f = q.front();
        q.pop(), inq[f] = 0;
        for (int i = h[f]; i; i = u[i].n) &#123;
            if (u[i].c == 0) continue;
            int v = u[i].v, w = u[i].w;
            if (dis[v] &lt; dis[f] + w) &#123;
                pre[v] = i ^ 1;
                dis[v] = dis[f] + w;
                fl[v] = min(fl[f], u[i].c);
                if (!inq[v])
                    inq[v] = 1, q.push(v);
            &#125;
        &#125;
    &#125;
    return pre[gt];
&#125;
void SSP(int s, int n) &#123;
    int p, mn, d;
    while (SPFA(s, n)) &#123;
        mn = fl[gt], d = 0;
        for (p = gt; p != s; p = u[pre[p]].v) &#123;
            u[pre[p]].c += mn;
            u[pre[p] ^ 1].c -= mn;
            d += u[pre[p] ^ 1].w;
        &#125;
        res += mn * d;
    &#125;
    return;
&#125;
void SSP1(int s, int n) &#123;
    int p, mn, d;
    while (SPFA1(s, n)) &#123;
        mn = fl[gt], d = 0;
        for (p = gt; p != s; p = u[pre[p]].v) &#123;
            u[pre[p]].c += mn;
            u[pre[p] ^ 1].c -= mn;
            d += u[pre[p] ^ 1].w;
        &#125;
        res += mn * d;
    &#125;
    return;
&#125;
void add(int x, int y, int c, int w) &#123;
    u[++tot] = _(y, c, w, h[x]);
    h[x] = tot;
    return;
&#125;
void addf(int x, int y, int c, int w) &#123;
    add(x, y, c, w), add(y, x, 0, -w);
    return;
&#125;
int main() &#123;
    read(n), read(m);
    gs = n + m + 1, gt = gs + 1;
    for (int i = 1; i &lt;= n; ++i)
        read(x), addf(gs, i, x, 0);
    for (int i = 1; i &lt;= m; ++i)
        read(x), addf(i + n, gt, x, 0);
    for (int i = 1; i &lt;= n; ++i) &#123;
        for (int j = 1; j &lt;= m; ++j)
            read(x), addf(i, j + n, inf, x);
    &#125;
    memcpy(h1, h, sizeof (h1));
    memcpy(u1, u, sizeof (u1));
    SSP(gs, gt);
    print(res, &#39;\n&#39;), res = 0;
    memcpy(h, h1, sizeof (h));
    memcpy(u, u1, sizeof (u));
    SSP1(gs, gt);
    print(res, &#39;\n&#39;);
    return 0;
&#125;
&#125; // namespace XSC062
#undef int


E. 最小路径覆盖
https://www.becoder.com.cn/contest/3952/problem/5
当我们把所有点视作长度为 \(0\) 的路径时，答案为 \(n\)。怎么让这个答案减小呢？我们需要 合并路径。
假设有路径 \(u \to x\) 和 \(x \to v\)，那么将它们合并为 \(u\to v\) 显然可以得到更优的答案。
那么这个时候就有同学要问了，我选择合并路径的方式会不会对答案产生影响呢？这个不急，我们讲完了再证明。
首先开一个新图，把所有点整一个保留节目，\(S\to x\) 建一条容量为 \(1\) 的边；\(x&#39; \to T\) 建一条容量为 \(1\) 的边；对于边 \(u\to v\)，在 \(u\to v&#39;\) 建一条容量为 \(1\) 的边。
这个时候我们就有了一个类二分图的模型。想想看，我们在里面跑出来的最大流是什么？
在这种容量均为 \(1\) 的类二分图模型中，网络流中找到的路径其实就是二分图中的增广路，因为反向的容量为 \(0\) 的边就相当于已匹配边，会限制搜索进一步搜下去。
在二分图中，每找到一条增广路，最大匹配的大小便扩大 \(1\)；在这里的网络流中也一样，每找到一条路径，最大流的大小便扩大 \(1\)。
那么，这里的「路径」究竟有什么含义？
一条从 \(S\) 到 \(T\) 的边，若其流量为 \(1\)，我们将它视作原图中被选中、加入路径集合的边，你会发现，找最大流（不断延长路径）的过程就相当于在合并路径，而且最后这个新图满足：点和边都不会被重复选中，且因为我们找的是最大流，所有点都会被选中。
好好好，正确性就很显而易见了，来自于二分图增广路找最大匹配的正确性（被打）。
那么求出最大流 \(f\)，因为每合并一次路径，路径的条数就会减少 \(1\)，所以最后的答案就是 \(N - f\)。方案呢？
因为网络流特性，你会发现路径的起点一定是 \(S\to x\)（废话），所以找出所有 \(S\to x\) 流量为 \(1\) 的 \(x\)，它们就是每条路径的起点。
因为路径没有交叉且肯定联通，所以你沿着这个起点一直找流量为 \(1\) 的边就能找到头。

namespace XSC062 &#123;
using namespace fastIO;
const int inf = 1e18;
const int maxn = 4e3 + 5;
const int maxm = 6e5 + 5;
struct _ &#123;
    int v, w, n;
    _() &#123;&#125;
    _(int v1, int w1, int n1) &#123;
        v = v1, w = w1, n = n1;
    &#125;
&#125;;
_ u[maxm];
bool vis1[maxn];
int n, m, x, y, res;
int gs, gt, tot = 1;
int a[maxn], h[maxn], f[maxn];
int vis[maxn], now[maxn], dep[maxn];
int min(int x, int y) &#123; return x &lt; y ? x : y; &#125;
int max(int x, int y) &#123; return x &gt; y ? x : y; &#125;
bool BFS(int n) &#123;
    std::fill(vis + 1, vis + n + 1, 0);
    std::fill(dep + 1, dep + n + 1, 0); 
    std::queue&lt;int&gt; q;
    dep[gs] = 1, vis[gs] = 1;
    q.push(gs), now[gs] = h[gs];
    while (!q.empty()) &#123;
        int f = q.front(); q.pop();
        for (int i = h[f]; i; i = u[i].n) &#123;
            int v = u[i].v, w = u[i].w;
            if (vis[v] == 1 || w == 0) continue;
            vis[v] = 1, now[v] = h[v];
            dep[v] = dep[f] + 1, q.push(v);
            if (v == gt) return 1;
        &#125;
    &#125;
    return 0;
&#125;
int findP(int x, int flow = inf) &#123;
    if (x == gt) return flow;
    int rest = flow, i;
    for (i = now[x]; rest &amp;&amp; i; i = u[i].n) &#123;
        int v = u[i].v, w = u[i].w;
        now[x] = i;
        if (dep[v] != dep[x] + 1 || w == 0) continue;
        int t = findP(v, min(rest, w));
        if (t == 0) dep[v] = 0;
        rest -= t, u[i].w -= t, u[i ^ 1].w += t;
    &#125;
    return flow - rest;
&#125;
int Dinic(int n) &#123;
    int res = 0;
    while (BFS(n)) &#123;
        int t = findP(gs);
        while (t) res += t, t = findP(gs);
    &#125;
    return res;
&#125;
void add(int x, int y, int w) &#123;
    u[++tot] = _(y, w, h[x]);
    h[x] = tot;
    return;
&#125;
void addf(int x, int y, int w) &#123;
    add(x, y, w), add(y, x, 0);
    return;
&#125;
void output(int x) &#123;
    if (x == gs) return;
    print(x, &#39; &#39;), vis1[x] = 1;
    for (int i = h[x]; i; i = u[i].n) &#123;
        int v = u[i].v;
        if (v &lt;= n || v &gt; 2 * n || vis1[v - n])
            continue;
        if (u[i].w == 0) &#123;
            output(u[i].v - n);
            return;
        &#125;
    &#125;
    return;
&#125;
int main() &#123;
    read(n), read(m);
    gs = 2 * n + 1, gt = gs + 1;
    for (int i = 1; i &lt;= n; ++i) &#123;
        addf(gs, i, 1);
        addf(i + n, gt, 1);
    &#125;
    while (m--) &#123;
        read(x), read(y);
        addf(x, y + n, 1);
    &#125;
    res = n - Dinic(gt);
    for (int i = h[gt]; i; i = u[i].n) &#123;
        if (u[i ^ 1].w == 1) &#123;
            output(u[i].v - n);
            putchar(&#39;\n&#39;);
        &#125;
    &#125;
    print(res, &#39;\n&#39;);
    return 0;
&#125;
&#125; // namespace XSC062
#undef int


F. 数字梯形
https://www.becoder.com.cn/contest/3952/problem/6
在 GM 的强制要求下只能跳了，呜呜呜

Day 2：7th - 14th
A. 太空飞行计划
https://www.becoder.com.cn/contest/3976/problem/1
不难想到把大源点和实验连容量为报酬的边；把仪器和大汇点连容量为消费的边；实验和仪器之间连容量为无穷大的边。
这个时候我们要选择一些实验不去做，选择一些仪器不要，并且要求要和不要的实验和仪器之间不能有边关联，还要求留下的利润最大。
假如我们把删去一条仪器边视作保留仪器，删去一条实验边视作跳过实验，这是什么？最小割！因为必须保证没有关联，这和最小割要求被分为两个部分是符合的。因为中间的边容量无穷大，故绝对不会选中间的边。同时，它删除了最不赚钱的实验，保留了最便宜的仪器。
据说这也是个经典最小割模型，建议掌握。
然后答案呢？先暂时将器材视为负权值，则：

总收入 为 被选中的实验权值 加上 被选中的器材权值
被选中的实验权值 为 所有实验权值和 减去 未被选择的实验权值和
总收入 为 所有实验权值和 减去 未被选择的实验权值和 加上 被选中的器材权值
总收入 为 所有实验权值和 减去 未被选择的实验权值和 减去 被选中的器材权值的相反数
最小割 为 未被选择的实验权值和 加上 被选中的器材权值的相反数
总收入 为 被选中的实验权值 减去 最小割

那么怎么输出方案呢？
https://www.luogu.com.cn/blog/35891/solution-p2762
woc 这篇讲得太好了。最后一次 Dinic 失败了，这是为什么呢？因为 BFS 找不到汇点了，说明若干条残量为 0 的边已经堵死了从源点到汇点的路。这个时候这些残量为 0 的边其实就是最小割。
那选取的实验和仪器，就是从源点出发可以到达的（已在 BFS 中为其分层作为记号），所以只需统计有层数的点即可。太妙了。

#define int long long
namespace XSC062 &#123;
using namespace fastIO;
const int inf = 1e18;
const int maxn = 4e3 + 5;
const int maxm = 6e5 + 5;
struct _ &#123;
    int v, w, n;
    _() &#123;&#125;
    _(int v1, int w1, int n1) &#123;
        v = v1, w = w1, n = n1;
    &#125;
&#125;;
_ u[maxm];
bool vis1[maxn];
int n, m, x, y, res;
int gs, gt, tot = 1;
int a[maxn], h[maxn], f[maxn];
int vis[maxn], now[maxn], dep[maxn];
int min(int x, int y) &#123; return x &lt; y ? x : y; &#125;
int max(int x, int y) &#123; return x &gt; y ? x : y; &#125;
bool BFS(int n) &#123;
    std::fill(vis + 1, vis + n + 1, 0);
    std::fill(dep + 1, dep + n + 1, 0); 
    std::queue&lt;int&gt; q;
    dep[gs] = 1, vis[gs] = 1;
    q.push(gs), now[gs] = h[gs];
    while (!q.empty()) &#123;
        int f = q.front(); q.pop();
        for (int i = h[f]; i; i = u[i].n) &#123;
            int v = u[i].v, w = u[i].w;
            if (vis[v] == 1 || w == 0) continue;
            vis[v] = 1, now[v] = h[v];
            dep[v] = dep[f] + 1, q.push(v);
            if (v == gt) return 1;
        &#125;
    &#125;
    return 0;
&#125;
int findP(int x, int flow = inf) &#123;
    if (x == gt) return flow;
    int rest = flow, i;
    for (i = now[x]; rest &amp;&amp; i; i = u[i].n) &#123;
        int v = u[i].v, w = u[i].w;
        now[x] = i;
        if (dep[v] != dep[x] + 1 || w == 0) continue;
        int t = findP(v, min(rest, w));
        if (t == 0) dep[v] = 0;
        rest -= t, u[i].w -= t, u[i ^ 1].w += t;
    &#125;
    return flow - rest;
&#125;
int Dinic(int n) &#123;
    int res = 0;
    while (BFS(n)) &#123;
        int t = findP(gs);
        while (t) res += t, t = findP(gs);
    &#125;
    return res;
&#125;
void add(int x, int y, int w) &#123;
    u[++tot] = _(y, w, h[x]);
    h[x] = tot;
    return;
&#125;
void addf(int x, int y, int w) &#123;
    add(x, y, w), add(y, x, 0);
    return;
&#125;
int main() &#123;
    scanf(&quot;%lld %lld&quot;, &amp;n, &amp;m);
    gs = n + m + 1, gt = gs + 1;
    for (int i = 1; i &lt;= n; ++i) &#123;
        scanf(&quot;%lld&quot;, &amp;x);
        addf(gs, i, x);
        res += x;
        std::string tmp;
        std::getline(std::cin, tmp);
        std::stringstream t(tmp);
        while (t &gt;&gt; y)
            addf(i, y + n, inf);
    &#125;
    for (int i = 1; i &lt;= m; ++i)
        read(x), addf(n + i, gt, x);
    res -= Dinic(gt);
    for (int i = 1; i &lt;= n; ++i)
        if (dep[i] != 0) print(i, &#39; &#39;);
    putchar(&#39;\n&#39;);
    for (int i = n + 1; i &lt;= n + m; ++i)
        if (dep[i] != 0) print(i - n, &#39; &#39;);
    putchar(&#39;\n&#39;), print(res, &#39;\n&#39;);
    return 0;
&#125;
&#125; // namespace XSC062
#undef int

]]></content>
      <tags>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title>解题报告：矩阵</title>
    <url>/20230729/</url>
    <content><![CDATA[BZOJ2406 矩阵。



赛时公告
现在呢？：现在有弹窗了吗 「2023-07-19 16:45:07」

此时无声胜有声。

F.「BZOJ2406」矩阵
https://www.becoder.com.cn/contest/3825/problem/7
这是头一次见识到把矩阵和网络流结合在一起的题目。不过这种处理方式也是我们在学习二分图时的常客了：把行和列连边表示某一元素。
我们发现 \(B_{i, j}\) 有给定的上下界，故我们考虑 上下界网络流。那怎么去表示 \(B_{i, j}\) 呢？这就要联系到我们刚刚说过的连边方式：用边 \(i\to j\) 的流量来表示 \(B_{i, j}\)，有 \([L, R]\) 的上下界。
可是我们除了 \([L,R]\) 的限制，还有最大值这个条件呀，怎么办呢？
注意到题目要求最大的最小，自然想到二分答案。设答案为 \(x\)，则我们需要保证每行每列的答案都 \(\le x\)。每行每列，这刚好是我们的建点方式。这对点本身作出了要求，这套路我们熟，让大源点向行连边、列向大汇点连边就好。
那么这些边的上下界怎么办呢？我们已知 \(|S_A-S_B|\le x\)，那么变形得：
\[
\begin{cases}
S_B\ge S_A-x &amp;(S_B \le S_A) \\
S_B\le S_A+x &amp;(S_B \ge S_A)
\end{cases}
\]
照理来说，两行的符号相反，我们现在已经得到了一个具有对称美的上下界：\(S_A-x\le S_B\le S_A+x\)，就应该速速连边了，可是我怎么看都觉得不舒坦：这个不等式可是带条件的，就这么直接拿来做上下界真的没问题吗？
答案是没问题，因为我看的题解是这么写的 本着探索求真精神，我们考虑尊重原不等式（因为原不等式的每一行刚好也有两个相反的符号），将这些边拆成两条，一条的上下界是 \([S_A-x, S_A]\)，另一条是 \([S_A,S_A+x]\)。6。我明白题解为什么这么写了，一个的下界就是另一个的上界，那直接合并不就行了，这个 naive trick 题解都不屑于写出来。
然后跑个可行流就可以了。注意要保证边的下界为非负。

#define int long long
namespace XSC062 &#123;
using namespace fastIO;
const int lim = 2e5;
const int maxn = 405;
const int inf = 1e18;
const int maxm = 3e5 + 5;
struct _ &#123;
    int v, w, n;
    _() &#123;&#125;
    _(int v1, int w1, int n1) &#123;
        v = v1, w = w1, n = n1;
    &#125;
&#125;;
_ u[maxm];
int gs, gt, tot;
int a[maxn][maxn];
int l, mid, r, res;
int h[maxn], dif[maxn];
int n, m, cnt, s, t, L, R;
int vis[maxn], now[maxn], dep[maxn];
int max(int x, int y) &#123; return x &gt; y ? x : y; &#125;
int min(int x, int y) &#123; return x &lt; y ? x : y; &#125;
bool BFS(int n) &#123;
    std::fill(vis + 1, vis + n + 1, 0);
    std::fill(dep + 1, dep + n + 1, 0); 
    std::queue&lt;int&gt; q;
    dep[gs] = 1, vis[gs] = 1;
    q.push(gs), now[gs] = h[gs];
    while (!q.empty()) &#123;
        int f = q.front(); q.pop();
        for (int i = h[f]; i; i = u[i].n) &#123;
            int v = u[i].v, w = u[i].w;
            if (vis[v] == 1 || w == 0) continue;
            vis[v] = 1, now[v] = h[v];
            dep[v] = dep[f] + 1, q.push(v);
            if (v == gt) return 1;
        &#125;
    &#125;
    return 0;
&#125;
int findP(int x, int flow = inf) &#123;
    if (x == gt) return flow;
    int rest = flow, i;
    for (i = now[x]; rest &amp;&amp; i; i = u[i].n) &#123;
        now[x] = i;
        int v = u[i].v, w = u[i].w;
        if (dep[v] != dep[x] + 1 || w == 0) continue;
        int t = findP(v, min(rest, w));
        if (t == 0) dep[v] = 0;
        rest -= t, u[i].w -= t, u[i ^ 1].w += t;
    &#125;
    return flow - rest;
&#125;
int Dinic(int n) &#123;
    int res = 0;
    while (BFS(n)) &#123;
        int t = findP(gs);
        while (t) res += t, t = findP(gs);
    &#125;
    return res;
&#125;
void add(int x, int y, int w) &#123;
    u[++tot] = _(y, w, h[x]), h[x] = tot;
    return;
&#125;
void add(int x, int y, int d, int u) &#123;
    add(x, y, u - d), add(y, x, 0);
    dif[x] -= d, dif[y] += d;
    return;
&#125;
void Init(void) &#123;
    tot = 1, cnt = 0;
    memset(h, 0, sizeof (h));
    memset(dif, 0, sizeof (dif));
    return;
&#125;
bool check(int x) &#123;
    Init();
    s = n + m + 1, t = s + 1;
    add(t, s, inf), add(s, t, 0);
    gs = t + 1, gt = t + 2;
    for (int i = 1; i &lt;= n; ++i) &#123;
        for (int j = 1; j &lt;= m; ++j)
            add(i, j + n, L, R);
    &#125;
    for (int i = 1; i &lt;= n; ++i) &#123;
        int sum = 0;
        for (int j = 1; j &lt;= m; ++j)
            sum += a[i][j];
        add(s, i, max(0, sum - x), sum + x);
    &#125;
    for (int j = 1; j &lt;= m; ++j) &#123;
        int sum = 0;
        for (int i = 1; i &lt;= n; ++i)
            sum += a[i][j];
        add(j + n, t, max(sum - x, 0), sum + x);
    &#125;
    for (int i = 1; i &lt;= t; ++i) &#123;
        if (dif[i] &lt; 0)
            add(i, gt, -dif[i]), add(gt, i, 0);
        else if (dif[i] &gt; 0) &#123;
            add(gs, i, dif[i]);
            add(i, gs, 0), cnt += dif[i];
        &#125;
    &#125;
    return (Dinic(gt) == cnt);
&#125;
int main() &#123;
    read(n), read(m);
    for (int i = 1; i &lt;= n; ++i) &#123;
        for (int j = 1; j &lt;= m; ++j)
            read(a[i][j]);
    &#125;
    read(L), read(R);
    l = 0, r = lim, res = -1;
    while (l &lt;= r) &#123;
        mid = (l + r) &gt;&gt; 1;
        if (check(mid))
            res = mid, r = mid - 1;
        else l = mid + 1;
    &#125;
    print(res);
    return 0;
&#125;
&#125; // namespace XSC062
#undef int


你最好有要事相求.jpg
]]></content>
      <tags>
        <tag>网络流</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>解题报告：Little Elephant and LCM</title>
    <url>/20230813/</url>
    <content><![CDATA[CF258C Little Elephant and LCM。


方便起见，下面 \(b_{\text{lcm}}\) 的意思就是 \(\text{lcm}\{b_1,b_2,\cdots,b_n\}\)，\(\max\) 什么的也同理。
首先我们都能反应过来，如果 \(b_{\text{lcm}}=b_{\max}\)，那么 \(b\) 中的最大值就得是 \(b_{\text {lcm}}\)，而其他元素都得是 \(b_{\max}\) 的因数。
既然涉及到求 \(b_{\max}\) 的因数，那我们势必避免不了枚举 \(b_{\max}\)。我一开始陷入了一个 trick：我并不知道 \(b_{\max}\) 应该处于哪一个位置。但其实这不重要，它对我们最后的方案没有影响，有影响的是「有多少个位置可以取到当前枚举的 \(b_{\max}\)」。
对于当前枚举的 \(b_{\max}\)（假设为 \(k\)），我们找到它的所有因数 \(p_1\sim p_m\)，按从小到大的顺序排列。对于一个 \(a_i\)，当且仅当 \(a_i\ge p_j\) 时，\(a_i\) 可以选择 \(p_j\)。那么我们找到 \(a_i\) 可以选到的最大的 \(p_j\)，此时 \(a_i\) 的选择就是 \(p_1\sim p_j\)，共 \(j\) 种。
那么我们在外面已经有一层枚举 \(k\) 的循环的前提下，再遍历 \(a\) 数组无疑是会起飞的，我们考虑倒过来，遍历 \(p\)，对于每个 \(p_j\)，找到它是多少个 \(a_i\) 的最大选择（假设为 \(x_j\)），那么对于 \(p_j\)，它贡献的答案就是 \(j^{x_j}\)。
\(x_j\) 的计算也不难，我们用两个二分找到满足 \(p_j\le a_i &lt; p_j + 1\) 的 \(a_i\) 数量就可以了。那么总方案数就是 \(\prod j^{x_j}\)。
但是别忘了还有 \(k\) 为 \(b_{\max}\) 的限制。找到 \(x_m\)，怎么去满足至少有一个 \(a_i=k\) 呢？一个微型容斥，用总方案数减去一个 \(k\) 都没有的方案数。那么就规定了每个可以取到 \(k\) 的数都必须不取 \(k\)，本来有 \(m\) 种选择，现在只剩下 \(m−1\) 种，所以答案就是 \((m−1)^{x_m}\)，容斥后为 \(m^{x_m}−(m−1)^{x_m}\)。
对于 \(b_{\max}=k\)，最终结果为 \((\prod\limits_{j=1}^{m−1}j^{x_j})\times (m^{x_m}−(m−1)^{x_m})\)。加法原理把所有 \(k\) 的情况加起来即可。
对于时间复杂度，枚举 \(k\) 是 \(O(V)\) 的，找因数是 \(O(\sqrt V)\) 的，枚举 \(p_j\) 是 \(\log V\) 的，二分是 \(\log n\) 的。所以最终时间复杂度为 \(O(V\times \max\{\sqrt V,\log V\times \log n\})\)。

#define int long long
namespace XSC062 &#123;
using namespace fastIO;
const int mod = 1e9 + 7;
const int maxn = 1e5 + 5;
int a[maxn];
int n, mx, ans, res;
int qkp(int x, int y) &#123;
    int res = 1;
    while (y) &#123;
        if (y &amp; 1) (res *= x) %= mod;
        (x *= x) %= mod, y &gt;&gt;= 1;
    &#125;
    return res;
&#125;
int max(int x, int y) &#123; return x &gt; y ? x : y; &#125;
int main() &#123;
    read(n);
    for (int i = 1; i &lt;= n; ++i) 
        read(a[i]), mx = max(mx, a[i]);
    std::sort(a + 1, a + n + 1);
    for (int k = 1; k &lt;= mx; ++k) &#123;
        res = 1;
        std::vector&lt;int&gt; p;
        p.push_back(-1); // 占位符，方便下标对齐 
        for (int i = 1; i * i &lt;= k; ++i) &#123;
            if (k % i == 0) &#123;
                p.push_back(i);
                if (i * i != k) p.push_back(k / i);
            &#125;
        &#125;
        std::sort(p.begin() + 1, p.end());
        // 先算前 m - 1 个 
        int m = p.size() - 1;
        for (int j = 1; j &lt;= m - 1; ++j) &#123;
            int l, r, x;
            l = std::lower_bound(a + 1, a + n + 1, p[j]) - a;
            r = std::lower_bound(a + 1, a + n + 1, p[j + 1]) - a - 1;
            x = r - l + 1, (res *= qkp(j, x)) %= mod;
        &#125;
        int l, r, x;
        l = std::lower_bound(a + 1, a + n + 1, p[m]) - a;
        r = n, x = r - l + 1;
        (res *= (qkp(m, x) - qkp(m - 1, x))) %= mod;
        (ans += res) %= mod;
    &#125;
    print((ans + mod) % mod, &#39;\n&#39;);
    return 0;
&#125;
&#125; // namespace XSC062
#undef int

]]></content>
      <tags>
        <tag>二分</tag>
        <tag>容斥原理</tag>
      </tags>
  </entry>
  <entry>
    <title>解题报告：颜色</title>
    <url>/20230928/</url>
    <content><![CDATA[[JXOI2017] 颜色。


颜色删完过后剩下的肯定是一段区间。
那么区间外的所有颜色都会被删掉，如果要满足题目条件的话，删掉的颜色不能出现在区间内。
那么就可以有这么一个题意的转化：寻找区间的个数，满足区间内的颜色只出现在区间内。
然后你可能就要问了，不是还要满足区间外的所有颜色都不出现在区间内吗。但是你想想，要是它出现在区间内了，它作为区间内的颜色，不就不满足我们上面说的那条规则了吗。
这个转化是非常厉害的。那么这个时候有一个显而易见暴力做法，我们记录一个颜色在整个序列中出现的第一个位置（记为 \(L_x\)）和最后一个位置（记作 \(R_x\)），然后枚举每一个区间 \([i, j]\)，再枚举其中的每一个颜色，看看有没有超出去就好，复杂度 \(O(n^3)\)。

对纯暴力的一点小优化 上述区间内枚举过程转化为判定区间是否满足 \({L_x}_{\min} \ge i\) 且 \({R_x}_{\max} \le j\)，采用数据结构维护，就可以优化到 \(O(n^2\log)\)。为什么要专门提一嘴这个呢，因为这个模型我没想到。我真 NB。

接下来又是一个我想不到的模型。我们发现复杂度瓶颈出在枚举区间上，所以考虑通过固定区间右端点，用较小的复杂度直接求解满足条件的左端点数量来解决问题。为什么不是固定左端点呢？
「因为题解都是写的固定右端点。」 0# 如是说。
对于正在枚举的右端点 \(j\) 右边的颜色 \(x\)，我们记录它们上一次出现的位置 \(p_x\)，并用线段树找到范围内最右值 \((p_x)_{\max}\)，那么左端点 \(i&gt;(p_x)_{\max}\)。取 \(i&#39;=(p_x)_{\max}+1\)，这样我们就初步得到了一个 \([i&#39;, j]\)。相对于纯暴力的做法，\(R_x\le j\) 的等价条件已经满足，但还有一个条件，就是 \(L_x\) 不能小于 \(i\)。
为了方便数据结构维护 \(p_x\)，我们逆序枚举 \(j\)，这样又可以得到一个性质：\(i&#39;\) 单调不降。这个时候我们逆向思维，处理出对于每个 \(i\ge i&#39;\)，其能够到的最远的 \(j\)，记为 \(f_i\)，那么我们对于 \(f_i\) 建一个权值线段树，然后在枚举过程中查询权值在 \([j, +\infty)\) 的 \(i\) 的个数就是答案。由于求的是个数，所以可以对超出范围的 \(i\) 对应的 \(f_i\) 进行删除操作。
那么 \(f_i\) 又该怎么求呢？暴力地再建一个权值线段树维护 \(L_x\)，在 \((-\infty, i)\) 权值范围内查询下标 \(k\) 的最小值，此时的 \(k\) 就是 \(f_i\)。
因为 0# 讲课的时候我在开飞机，所以我也不知道 0# 是不是这么讲的，总之我这么做应该能做出来，就是要维护的东西实在有亿点点多。
但是注意到一个线段树和两个权值线段树维护的大区间其实是一样的，所以我们只用一个线段树同时维护三个信息就好。最后时间复杂度 \(O(n\log n)\)。

namespace XSC062 &#123;
using namespace fastIO;
#define lt (p &lt;&lt; 1)
#define rt (lt | 1)
#define mid (t[p].l + t[p].r) / 2
const int maxn = 3e5 + 5;
// shaber monotonicity
// destroy my youth 
struct _ &#123; int l, r, u, d; &#125;;
struct __ &#123;
    int u, i;
    __() &#123;&#125;
    __(int u1, int i1) &#123;
        u = u1, i = i1;
    &#125;
&#125;;
int T, n, res;
_ t[maxn &lt;&lt; 2];
int a[maxn], L[maxn], R[maxn];
int max(int x, int y) &#123; return x &gt; y ? x : y; &#125;
int min(int x, int y) &#123; return x &lt; y ? x : y; &#125;
void pushup(int p) &#123;
    t[p].u = t[lt].u + t[rt].u;
    return;
&#125;
void pushdown(int p) &#123;
    if (t[p].d) &#123;
        t[lt].d = t[rt].d = 1;
        t[lt].u = t[lt].r - t[lt].l + 1;
        t[rt].u = t[rt].r - t[rt].l + 1;
        t[p].d = 0;
    &#125;
    return;
&#125;
void bld(int p, int l, int r) &#123;
    t[p].u = t[p].d = 0;
    t[p].l = l, t[p].r = r;
    if (l == r) return;
    bld(lt, l, mid), bld(rt, mid + 1, r);
    return;
&#125;
void add(int p, int l, int r) &#123;
    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r) &#123;
        t[p].u = t[p].r - t[p].l + 1;
        t[p].d = 1;
        return;
    &#125;
    pushdown(p);
    if (l &lt;= mid) add(lt, l, r);
    if (r &gt; mid) add(rt, l, r);
    pushup(p);
    return;
&#125;
int ask(int p, int l, int r) &#123;
    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r)
        return t[p].u;
    int res = 0; pushdown(p);
    if (l &lt;= mid) res = ask(lt, l, r);
    if (r &gt; mid) res += ask(rt, l, r);
    return res;
&#125;
int main() &#123;
    read(T);
    while (T--) &#123;
        read(n), res = 0;
        std::stack&lt;__&gt; p;
        std::fill(L + 1, L + n + 1, n + 5);
        std::fill(R + 1, R + n + 1, 0);
        for (int i = 1; i &lt;= n; ++i) &#123;
            read(a[i]), R[a[i]] = i;
            if (L[a[i]] == n + 5) L[a[i]] = i;
        &#125;
        bld(1, 1, n);
        for (int i = 1, j; i &lt;= n; ++i) &#123;
            if (i == R[a[i]] &amp;&amp; i != L[a[i]])
                add(1, L[a[i]] + 1, R[a[i]]);
            else p.push(__(a[i], i));
            while (!p.empty() &amp;&amp; R[p.top().u] &lt;= i) p.pop();
            j = p.size() ? p.top().i : 0;
            if (i != j) res += i - j - ask(1, j + 1, i);
        &#125;
        print(res, &#39;\n&#39;);
    &#125;
    return 0;
&#125;
&#125; // namespace XSC062

]]></content>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>杂题选谈</title>
    <url>/20231003/</url>
    <content><![CDATA[周考 14。


医生问我对药有什么要求吗，我说我宁死不喝冲剂。
然后医生给我开了五盒胶囊，告诉我说一天三次，一次六个。
哈哈哈，我自找的。以此为证，A 一道题磕一片！！！

A. 修改序列
https://www.becoder.com.cn/contest/4268/problem/1
注意到一增一减，全数列的和 \(s\) 不变，考虑这一点带来的提示。
假设最后要求一部分数为 \(p\)，另一部分为 \(p+1\)，那么有 \(p = \lfloor \dfrac sn \rfloor\)，\(p+1\) 的数量 \(c_r=s\bmod n\)，\(p\) 的数量 \(c_l=n-c_r\)。
那么我们让 \(\le p\) 的变成 \(p\)，\(\ge p + 1\) 的变成 \(p + 1\)。直接求两数距离，最后将总和除以二即为答案、

正确性证明…
这样做的最优性毫无疑问，问题无非就在于这么做的正确性，换言之，为什么一定能找到合法的操作序列还原我们的求解过程。
将原数列分为两部分，数值 \(\le p\) 的（记为 \(X\)）和数值 \(\ge p + 1\) 的（记为 \(Y\)）。
再把我们的目标状态分为两部分，数值 \(= p\) 的（记为 \(A\)）和 数值 \(=p + 1\) 的（记为 \(B\)）。
那么有 \(\begin{cases}X+Y=s\\A+B=s\end{cases}\)，由等式的基本性质得 \(X-A+Y-B = 0\)，移项得 \(Y-B=A-X\)。也就是说，\(Y\) 部分与 \(p+1\) 的差的总和正好等于 \(X\) 部分与 \(p\) 的差的总和。
这个时候我们的正确性就有了保证。
这个时候你可能就有疑问了，\(X,Y\) 中的元素个数和 \(A,B\) 中的元素个数并不对应，怎么办呢？
我们发现上面的原理式并不会随元素个数的变化而变化，所以依然可以用它来解答这个问题。没有人规定 \(Y-B\) 和 \(A-X\) 不能为负，为负时我们把 \(A\) 中塞不下的 \(X\) 拿到 \(B\) 里面去即可，反之同理。

那么代码还是很好写的。时间复杂度 \(O(n)\)。

namespace XSC062 &#123;
using namespace fastIO;
const int maxn = 2e5 + 5;
int a[maxn];
int n, s, p, cl, cg, res;
int main() &#123;
    read(n);
    for (int i = 1; i &lt;= n; ++i)
        read(a[i]), s += a[i];
    p = s / n, cg = s - p * n, cl = n - cg;
    for (int i = 1; i &lt;= n; ++i) &#123;
        if (a[i] &lt;= p) &#123;
            if (cl) res += p - a[i], --cl;
            else res += p - a[i] + 1, --cg;
        &#125;
        else &#123;
            if (cg) res += a[i] - p - 1, --cg;
            else res += a[i] - p, --cl;
        &#125;
    &#125;
    print(res / 2, &#39;\n&#39;);
    return 0;
&#125;
&#125; // namespace XSC062


B. Knuth 表示法
https://www.becoder.com.cn/contest/4268/problem/2
模拟。输入的数用 map 转化为 \(10\) 的次幂形式，然后幂次直接相加即表示指数相乘。
最后按位数从大到小将次幂形式转化为字符串、再按位数从小到大输出。
注意到开头的字符串不是 one 就是 ten，需要在没有抽出来 ten 的时候补 one。

namespace XSC062 &#123;
using namespace fastIO;
using str = std::string;
const str u[] = &#123; &quot;one&quot;, &quot;ten&quot;, &quot;hundred&quot;, &quot;myriad&quot;, &quot;myllion&quot;, &quot;byllion&quot;, &quot;tryllion&quot;,
                  &quot;quadryllion&quot;, &quot;quintyllion&quot;, &quot;sextyllion&quot;, &quot;septyllion&quot;, &quot;octyllion&quot;,
                  &quot;nonyllion&quot;, &quot;decyllion&quot; &#125;;
str x;
int res = 0;
std::stack&lt;str&gt; s;
std::map&lt;str, int&gt; t;
void get(str &amp;x) &#123;
    str y;
    std::stringstream p(x);
    while (p &gt;&gt; y) &#123;
        if (y == &quot;one&quot;) continue;
        res += 1 &lt;&lt; (t[y] - 1);
    &#125;
    return;
&#125;
int main() &#123;
    for (int i = 0; i &lt;= 13; ++i) t[u[i]] = i;
    std::getline(std::cin, x), get(x);
    std::getline(std::cin, x), get(x);
    for (int i = 13; i; --i) &#123;
        if (res &amp; (1 &lt;&lt; (i - 1)))
            s.push(u[i]), res ^= (1 &lt;&lt; (i - 1));
    &#125;
    if (s.top() != &quot;ten&quot;) s.push(&quot;one&quot;);
    while (!s.empty())
        std::cout &lt;&lt; s.top() &lt;&lt; &#39; &#39;, s.pop();
    return 0;
&#125;
&#125; // namespace XSC062


C. 魔力塔
https://www.becoder.com.cn/contest/4268/problem/3
神奇的线段树优化建图。这拿来放 T3？不合适吧。
很好想到对于 \(a_i\ne -1\)，连边 \(i\to a_i\)；否则，连边 \(i\to x(x\in [i+1,\min(i + k,n+1)])\)。BFS 遍历，复杂度 \(O(n\times k)\)。
问题在于无用边太多，例如 \(i\) 和 \(i+1\) 共同可达的点有整整 \(k-1\) 个，造成大量浪费。
考虑到实际进入 BFS 的点只有 \(n\) 个，及由传送门构成的连通块均呈棒棒糖状（即链套环），我们直接优化掉 \(a_i=-1\) 时的连边。使用线段树查询 \([i+1,\min(i + k,n+1)]\) 内的所有剩余点，连边入队并从线段树中删除。
这样，每个点只会入队一次（忽视无用环），时间复杂度控制在 \(O(n\log n)\)，\(\log\) 来源于线段树，写得不好就是 \(\log^2\)，写得好一点就只有一个。

然而…
会 T，因为常数太大了。
所以我们需要另一种 \(\log\) 的做法，并且短小精悍。
用 set 存储所有未入队的点，每次 lower_bound 并依次弹出、入队。

用迭代器的话代码很短，美汁汁。
时间复杂度 \(O(n\log n)\)，但等我先磕片药先。

namespace XSC062 &#123;
using namespace fastIO;
const int maxn = 5e5 + 5;
int a[maxn];
int n, k, res;
bool vis[maxn];
std::set&lt;int&gt; t;
std::vector&lt;int&gt; g[maxn]; 
int max(int x, int y) &#123; return x &gt; y ? x : y; &#125;
void DFS(int x) &#123;
    res = max(res, x);
    if (a[x] == -1) &#123;
        auto p = t.lower_bound(x + 1);
        while (p != t.end() &amp;&amp; *p &lt;= x + k) &#123;
            g[x].push_back(*p);
            t.erase(*p++);
        &#125;
    &#125;
    for (auto i : g[x]) &#123;
        if (vis[i]) continue;
        vis[i] = 1, DFS(i);
    &#125;
    return;
&#125;
int main() &#123;
    read(n), read(k);
    for (int i = 1; i &lt;= n; ++i) &#123;
        read(a[i]), t.insert(i + 1);
        if (~a[i]) g[i].push_back(a[i]);
    &#125;
    DFS(1), print(res, &#39;\n&#39;);
    return 0;
&#125;
&#125; // namespace XSC062


D. 卡牌游戏
https://www.becoder.com.cn/contest/4268/problem/4
怎么说呢，爆搜可以拿 80pts！！！然而正解是区间 DP，哭唧唧。他这个数据范围给得很神奇，让人只会往搜索上面想。
摧毁操作是一换一，不会更改串长，而入栈操作会增加初始串的长度。
所以我们考虑 逆序 DP，从最终状态入手，用 \(f_{x, i, j}\) 表示是否可以使用一个字符 \(x\) 经过一系列操作消掉 \(w_{i\sim j}\)。
那么明显若一条摧毁操作为可用字符 \(a\) 摧毁 \(w_i\)，有 \(f_{a, i, i} = 1\)。
若一条入栈操作为用字符 \(a\) 换字符 \(b,c\)，枚举区间断点 \(k\)，有 \(f_{a, i, j} = f_{b, i, k} \times f_{c, k + 1, j}\)。
最后答案为 \(f_{\texttt S,i,|w_i|}\)。
注意循环顺序，区间的枚举应在字符的枚举之外。最终时间复杂度 \(O(T\times |w_i|^3\times N_2)\)，注意到字母的枚举属于常数。胶囊好吃滴捏。

namespace XSC062 &#123;
using namespace fastIO;
const int maxn = 25;
const int maxm = 1e3 + 5;
int n, m, l;
char w[maxn];
bool r1[maxm][maxm];
bool f[maxm][maxn][maxn];
struct &#123; int u, a, b; &#125; r2[maxn];
int main() &#123;
    scanf(&quot;%d %d&quot;, &amp;n, &amp;m);
    for (int i = 1; i &lt;= n; ++i) &#123;
        scanf(&quot;%s&quot;, w + 1);
        r1[(int)w[1]][(int)w[4]] = 1;
    &#125;
    for (int i = 1; i &lt;= m; ++i) &#123;
        scanf(&quot;%s&quot;, w + 1);
        r2[i].u = w[1];
        r2[i].a = w[4], r2[i].b = w[5];
    &#125;
    while (~scanf(&quot;%s&quot;, w + 1)) &#123;
        memset(f, 0, sizeof (f));
        l = strlen(w + 1);
        for (int i = &#39;A&#39;; i &lt;= &#39;Z&#39;; ++i) &#123;
            for (int j = 1; j &lt;= l; ++j) &#123;
                if (r1[i][(int)w[j]])
                    f[i][j][j] = 1;
            &#125;
        &#125;
        for (int len = 1; len &lt;= l; ++len) &#123;
            for (int i = 1; i &lt;= l - len + 1; ++i) &#123;
                int j = i + len - 1;
                for (int t = &#39;A&#39;; t &lt;= &#39;Z&#39;; ++t) &#123;
                    for (int k = i; k &lt; j; ++k) &#123;
                        for (int p = 1; p &lt;= m; ++p) &#123;
                            if (r2[p].u != t) continue;
                            f[t][i][j] |= f[r2[p].a][i][k] &amp;&amp; f[r2[p].b][k + 1][j];
                        &#125;
                    &#125;
                &#125;
            &#125;
        &#125;
        puts(f[&#39;S&#39;][1][l] ? &quot;YES&quot; : &quot;NO&quot;);
    &#125;
    return 0;
&#125;
&#125; // namespace XSC062


E. 生长树
https://www.becoder.com.cn/contest/4268/problem/5
一道很菜的题。我们发现有子树操作，第一时间想到树剖，那么接下来要考虑的内容就是线段树如何维护。
题意换句话说就是往下数 0 代是加，数 1 代是减，数 2 代是加，以此类推。那么不难想到奇偶性。
如果起点的深度是奇数，那么子树中所有奇数深度权值增加，偶数深度权值减少，反之同理。
但是我们操作线段树的时候怎么知道点在树中的深度奇偶性呢？我们只能在线段树外才知道呀。
所以观察询问，询问是单点的，所以我们知道了，可以只在线段树外对奇偶性进行处理。简单来说，假设更改起点深度为奇数，那么增加整个子树的「奇加偶减计数器」；反之，增加整个子树的「奇减偶加计数器」。
最后查询的时候，如果该点深度为奇，那么答案为对应的「奇加偶减计数器」减去「奇减偶加计数器」的值，反之同理。
做到最后发现根本不用树剖，就是一个 DFN 上线段树。时间复杂度 \(O(m\log n)\)。
胶囊真好吃！！！

namespace XSC062 &#123;
using namespace fastIO;
#define lt (p &lt;&lt; 1)
#define rt (lt | 1)
const int maxn = 2e5 + 5;
struct _ &#123;
    int l, r;
    int u1, u2, d1, d2;
&#125;; 
_ t[maxn &lt;&lt; 2];
int a[maxn], dep[maxn];
std::vector&lt;int&gt; g[maxn];
int n, m, x, y, tot, typ;
int end[maxn], dfn[maxn], tab[maxn];
// u 只用维护最底层信息
// 所以不用打 pushup 
// 但维护起来好看一些 所以还是打了
void pushup(int p) &#123;
    t[p].u1 = t[lt].u1 + t[rt].u1;
    t[p].u2 = t[lt].u2 + t[rt].u2;
    return;
&#125;
void pushdown(int p) &#123;
    if (t[p].d1) &#123;
        t[lt].d1 += t[p].d1;
        t[rt].d1 += t[p].d1;
        t[lt].u1 += t[p].d1 * (t[lt].r - t[lt].l + 1);
        t[rt].u1 += t[p].d1 * (t[rt].r - t[rt].l + 1);
        t[p].d1 = 0;
    &#125;
    if (t[p].d2) &#123;
        t[lt].d2 += t[p].d2;
        t[rt].d2 += t[p].d2;
        t[lt].u2 += t[p].d2 * (t[lt].r - t[lt].l + 1);
        t[rt].u2 += t[p].d2 * (t[rt].r - t[rt].l + 1);
        t[p].d2 = 0;
    &#125;
    return;
&#125;
void bld(int p, int l, int r) &#123;
    t[p].l = l, t[p].r = r;
    if (l == r) &#123;
        if (dep[tab[l]] &amp; 1)
            t[p].u1 = a[tab[l]];
        else t[p].u2 = a[tab[l]];
        return;
    &#125;
    int mid = (l + r) &gt;&gt; 1;
    bld(lt, l, mid), bld(rt, mid + 1, r);
    pushup(p);
    return;
&#125;
void add1(int p, int l, int r, int x) &#123;
    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r) &#123;
        t[p].d1 += x;
        t[p].u1 += (t[p].r - t[p].l + 1) * x;
        return;
    &#125;
    int mid = (t[p].l + t[p].r) &gt;&gt; 1;
    pushdown(p);
    if (l &lt;= mid) add1(lt, l, r, x);
    if (r &gt; mid) add1(rt, l, r, x);
    pushup(p);
    return;
&#125;
void add2(int p, int l, int r, int x) &#123;
    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r) &#123;
        t[p].d2 += x;
        t[p].u2 += (t[p].r - t[p].l + 1) * x;
        return;
    &#125;
    int mid = (t[p].l + t[p].r) &gt;&gt; 1;
    pushdown(p);
    if (l &lt;= mid) add2(lt, l, r, x);
    if (r &gt; mid) add2(rt, l, r, x);
    pushup(p);
    return;
&#125;
int ask(int p, int x) &#123;
    if (t[p].l == t[p].r)
        return t[p].u1 - t[p].u2;
    int mid = (t[p].l + t[p].r) &gt;&gt; 1;
    pushdown(p);
    if (x &lt;= mid) return ask(lt, x);
    return ask(rt, x);
&#125;
void DFS(int x, int fa) &#123;
    dfn[x] = ++tot, tab[tot] = x;
    for (auto i : g[x]) &#123;
        if (i == fa) continue;
        dep[i] = dep[x] + 1;
        DFS(i, x);
    &#125;
    end[x] = tot;
    return;
&#125;
void add(int x, int y) &#123;
    g[x].push_back(y);
    return;
&#125;
int main() &#123;
    read(n), read(m);
    for (int i = 1; i &lt;= n; ++i)
        read(a[i]);
    for (int i = 1; i &lt; n; ++i) &#123;
        read(x), read(y);
        add(x, y), add(y, x);
    &#125;
    dep[1] = 1, DFS(1, -1);
    bld(1, 1, n);
    while (m--) &#123;
        read(typ), read(x);
        if (typ == 1) &#123;
            read(y);
            if (dep[x] &amp; 1)
                add1(1, dfn[x], end[x], y);
            else add2(1, dfn[x], end[x], y);
        &#125;
        else &#123;
            int res = ask(1, dfn[x]);
            if (dep[x] &amp; 1)
                print(res, &#39;\n&#39;);
            else print(-res, &#39;\n&#39;);
        &#125;
    &#125;
    return 0;
&#125;
&#125; // namespace XSC062


F. 单词
https://www.becoder.com.cn/contest/4268/problem/6
\(n \le 20\)，考虑状压。用 \(f_x\) 表示状态为 \(x\) 时的最小代价，其中 \(x\) 是字符串合法情况的状态压缩。
对于每一个待满足的串，枚举去满足它的哪一位，那么满足方式分两种情况：

把它变成一个新的值
把和它重合的变成新的值
我们注意到 \(n \le 20 \le 26\)，所以一定能找到一种方法让每个串的这一位都不一样。
接着，反正我们都要改这一位了，那就贪心地把要改的全部改成完全不一样的。那么这些要改的串也在这一位上满足了条件。

所以，假设对于状态 \(i\)，有串 \(j\) 未满足，枚举位置 \(k\)，有：
f[i | (1 &lt;&lt; (j - 1))] = min(f[i | (1 &lt;&lt; (j - 1))], f[i] + a[j][k]); 
f[i | lac[j][k]] = min(f[i | lac[j][k]], f[i] + mx[j][k]);
其中 lac[j][k] 和 mx[j][k] 都是预处理出来的值。lac[j][k] 表示与第 \(j\) 个串的第 \(k\) 位相同串的状态压缩；mx[j][k] 表示通过第二种方式将 \(j\) 串的第 \(k\) 位变得合法的最小费用。
lac[j][k] 的求法没有任何疑问，主要是在 mx[j][k] 上。注意到假设这一位上有 \(x\) 个串与 \(j\) 串的第 \(k\) 位相同（包括其本身），而我们只需要将这当中的 \(x-1\) 个变成两两不同的全新字符就可以同时满足这 \(x\) 串的条件，那我们为什么不把不动的这一个串设置为 \(x\) 个串中改这一位代价最大的那个呢？
那么问题来了。我们枚举状态、枚举状态中的每一个 0，枚举每一个串的每一位，实际上是 \(O(n\times m\times 2^n)\) 的。虽然跑不满，但这个时间复杂度仍然是有问题的。我们需要优化。
我们枚举的是状态中的每一个 0，假设我们的状态是 000，我们的解决方案是将三个 0 位置的方案共同处理，表示为 '0--' + '-0-' + '--0'。但实际上，我们只用实际求解一个 0 位置的答案，表示为 '0--' + '-00' 。
也就是说，我们原本需要枚举每一个状态为 0 的 \(j\) 并用 \(O(m)\) 的时间进行计算，现在我们碰到一个状态为 0 的 \(j\) 就开始计算，得到完全相同的答案。
很 NB 并且很实用的优化，已加入 下饭操作合集。

namespace XSC062 &#123;
using namespace fastIO;
const int maxn = 205;
const int maxm = (1 &lt;&lt; 25) + 5;
int f[maxm];
int n, m, siz;
char s[maxn][maxn];
int lac[maxn][maxn];
int a[maxn][maxn], mx[maxn][maxn];
int min(int x, int y) &#123; return x &lt; y ? x : y; &#125;
int max(int x, int y) &#123; return x &gt; y ? x : y; &#125;
int main() &#123;
    while(~scanf(&quot;%d %d&quot;, &amp;n, &amp;m)) &#123;
        memset(f, 0x3f, sizeof (f));
        f[0] = 0, siz = 1 &lt;&lt; n;
        for (int i = 1; i &lt;= n; ++i)
            scanf(&quot;%s&quot;, s[i] + 1);
        for (int i = 1; i &lt;= n; ++i) &#123;
            for (int j = 1; j &lt;= m; ++j)
                scanf(&quot;%d&quot;, &amp;a[i][j]);
        &#125;
        for (int i = 1; i &lt;= n; ++i) &#123;
            for (int j = 1; j &lt;= m; ++j) &#123;
                int sum = 0;
                lac[i][j] = mx[i][j] = 0;
                for (int k = 1; k &lt;= n; ++k) &#123;
                    if (s[k][j] == s[i][j]) &#123;
                        lac[i][j] |= 1 &lt;&lt; (k - 1);
                        sum += a[k][j];
                        mx[i][j] = max(mx[i][j], a[k][j]);
                    &#125;
                &#125;
                mx[i][j] = sum - mx[i][j];
            &#125;
        &#125;
        for (int i = 0, j; i &lt; siz - 1; ++i) &#123;
            for (j = 1; j &lt;= n; ++j) &#123;
                if (!(i &amp; (1 &lt;&lt; (j - 1))))
                    break;
            &#125;
            for (int k = 1; k &lt;= m; ++k) &#123;
                f[i | (1 &lt;&lt; (j - 1))] =
                    min(f[i | (1 &lt;&lt; (j - 1))], f[i] + a[j][k]); 
                f[i | lac[j][k]] =
                    min(f[i | lac[j][k]], f[i] + mx[j][k]);
            &#125;
        &#125;
        print(f[siz - 1], &#39;\n&#39;);
    &#125;
    return 0;
&#125;
&#125; // namespace XSC062


这次暴露出的问题：

深度乱求，打代码的时候考虑过要放在递归之前，但是由于精力不集中最后还是放在了递归后面。

没了。这次主要问题出在 T5。T3 估计真的想不到，先不强求自己。
这次学到的新知识：

对于子集合并最优性的问题，可以用单点 + 集合代替集合 + 集合枚举。

]]></content>
      <tags>
        <tag>DP</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>杂题选谈</title>
    <url>/20231004-1/</url>
    <content><![CDATA[牛客普及。


A. 学习求余
https://www.becoder.com.cn/contest/4272/problem/1
今天我们来学习求余！这种题放普及 T1 不合适吧！
令 \(k=\left\lfloor \dfrac n2 \right\rfloor + 1\)，直接输出 \(k\times (n - k)\) 即可。

我是不是证复杂了…
我们可以简单地发现一个道理，对于任意 \(\dfrac n2&lt;x\le n\)，\(n\bmod x\) 的值是 \(n - x\)；
根据基本不等式（wjs 直接感动得哭出声来）或小学知识「和不变，差小积大」，我们可以知道当 \(x=\left\lfloor \dfrac n2 \right\rfloor + 1\) 时，\(x\times (n-x)\) 取最大值。
故有：当 \(x=\left\lfloor \dfrac n2 \right\rfloor + 1\) 时，\(x\times (n\bmod x)\) 取最大值。
而对于 \(y\le \dfrac n2\)，由余数小于除数得，\(n\bmod y&lt;y\le \dfrac n2\)。由于 \(0&lt;y&lt;x=\left\lfloor \dfrac n2 \right\rfloor + 1\) 且 \(0\le n\bmod y\le \left\lfloor \dfrac n2 \right\rfloor - 1\le n - \left\lfloor \dfrac n2 \right\rfloor - 1=n\bmod x\)，由不等式的基本性质得 \(x\times(n\bmod x)&gt;y\times (n\bmod y)\)。
综上，对于 \(1\le x\le n\)，当 \(x=\left\lfloor \dfrac n2 \right\rfloor + 1\) 时，\(x\times (n\bmod x)\) 有最大值。

然后如果你要问我怎么发现这一点的呢，我当时没有思路，然后随手输出了 \(n=100\) 时 \(n\bmod i\) 的所有值。然后发现 \(k=51\) 时余数是 \(49\)…… 然后就会了。

#define int long long
namespace XSC062 &#123;
using namespace fastIO;
int n, k;
int main() &#123;
    read(n), k = n / 2 + 1;
    print(k * (n % k));
    return 0;
&#125;
&#125; // namespace XSC062
#undef int
头一次在题解里贴这么短的代码


B. 提取数字
https://www.becoder.com.cn/contest/4272/problem/2
我被这道题（疑似 T1）坑到了！交了三遍才过！这合理吗？
首先要开 long long！然后注意，你的判定条件应为「当前是否已存储数」而非「当前存数变量是否为 0」！因为数据中会有单个 0 的情况出现！
然后就没有了。

#define int long long
namespace XSC062 &#123;
using namespace fastIO;
const int maxn = 1e5 + 5;
bool flag;
char s[maxn]; 
int n, ans, cnt;
int main() &#123;
    scanf(&quot;%*s %s&quot;, s + 1);
    n = strlen(s + 1);
    for (int i = 1; i &lt;= n; ++i) &#123;
        if (s[i] &gt;= &#39;0&#39; &amp;&amp; s[i] &lt;= &#39;9&#39;)
            cnt = cnt * 10 + s[i] - &#39;0&#39;, flag = 1;
        else if (flag)
            ans += (cnt + 5), cnt = 0, flag = 0;
    &#125;
    if (flag) ans += (cnt + 5);
    print(ans, &#39;\n&#39;);
    return 0;
&#125;
&#125; // namespace XSC062
#undef int


C. 武器选择
https://www.becoder.com.cn/contest/4272/problem/3

首先是我想了半个小时的狂拽酷炫吊炸天的法一：离线
我当时一边打一边怀疑现在的普及组是什么神仙，T3 考这么神奇的离线，难道是我落后于时代了？
（之所以认为这是 T3 是因为括号那道题确实是正常 T4 风格）
我们预处理出对于每一个可能获得武器 \(i\) 的位置，应该从哪个位置第一次捡到武器 \(i\)，由于这一段内的所有武器 \(i\) 都需要被拾取，我们将其作为区间 \([L_i, R_i]\) 来记录。
那么询问可以转化为，在 \([l, r]\) 内 不同颜色 \([L_i, R_i]\) 的数量。
考虑将询问离线。将询问按左端点从大到小排序，信息区间 \([L_i, R_i]\) 也按左端点从大到小排序。
对于每次询问 \(l, r\)，在树状数组中将被 \([l, n]\) 完全包含的所有 \([L_i, R_i]\)（其实就是 \(l\le L_i\) 的所有 \(L_i\)）在右端点 \(R_i\) 处加一，我们就统计到了可以捡到武器的所有位置。
怎么区分颜色呢？很简单，我们让每个颜色只被算一次。算哪一次呢？就算当前已加入的 \([L_i, R_i]\) 内，比选中概率最大的一次。
我们树状数组统计的是 \([1, r]\) 内的值，所以我们要让概率最大的话，就要让 \(R_i\) 尽量的小。
我们记录每个颜色当前合法 \([L_i, R_i]\) 的最小右端点 \(\min_R\)。加入一个新的 \([L_i, R_i]\) 时，如果 \(R_i\ge \min_R\)，那么不会产生影响，跳过；否则，当 \(R_i&lt;\min_R\) 时，我们就要先消除当前 \(\min_R\) 的影响（即在树状数组中将该位置加上的 1 减去），再加上 \(R_i\) 的影响（即在树状数组中加上该位置的 1）。
此时我们对 \([1, r]\) 的询问就是答案。
复杂度 \(O(n\log n + m\log m + m\log n)\)，其中 \(n\log n\) 来自于对 \([L_i, R_i]\) 的排序，\(m\log m\) 来自于对询问的排序，\(m\log n\) 来自于离线树状数组。

接下来讲题解给的正解…… 这个是真的妙。
考虑所有种类数，在 \(n\) 个数内满足条件的种类 \(x\) 最优条件下也不过 \(\dfrac {x\times (x+1)}2=n\)，所以满足条件武器的数量最多只有 \(\sqrt n\) 级别。
所以我们对所有合法种类做前缀和，每次询问检查所有合法种类是否在该区间内出现对应次数，然后统计答案。复杂度 \(O(m\sqrt n + n\sqrt n)\)。\(n\sqrt n\) 是前面前缀和来的，\(m\sqrt n\) 是暴力统计来的。
但是根号可耻，所以我的法一更 NB！！！🤡🤡🤡

狂拽酷炫吊炸天的法一代码
#define int long long
namespace XSC062 &#123;
using namespace fastIO;
const int maxn = 1e5 + 5;
struct _ &#123;
    int l, r, k, i;
    bool operator&lt; (const _ &amp;q) const &#123;
        return l &lt; q.l;
    &#125;
&#125;;
struct __ &#123;
    int l, r, nxt, x;
    bool operator&lt; (const __ &amp;q) const &#123;
        return l &lt; q.l;
    &#125;
&#125;;
_ q[maxn];
__ a[maxn];
std::map&lt;int, int&gt; t;
std::vector&lt;int&gt; u[maxn];
int ans[maxn], now[maxn];
int mnr[maxn], Bit[maxn];
int n, m, tot, x, cnt, pos;
int lowbit(int x) &#123; return x &amp; -x; &#125;
void add(int x, int v) &#123;
    for (int i = x; i &lt;= n; i += lowbit(i))
        Bit[i] += v;
    return;
&#125;
int ask(int x) &#123;
    int res = 0;
    for (int i = x; i; i -= lowbit(i))
        res += Bit[i];
    return res;
&#125;
int calc(int x, int k) &#123;
    int res = 1;
    for (int i = 1; i &lt;= k; ++i)
        res *= x--;
    for (int i = 1; i &lt;= k; ++i)
        res /= i;
    return res;
&#125;
int main() &#123;
    read(n);
    for (int i = 1; i &lt;= n; ++i) &#123;
        read(x);
        if (!t.count(x)) t[x] = ++tot;
        int id = t[x];
        u[id].push_back(i);
        if ((int)u[id].size() &gt;= x) &#123;
            a[++cnt].l = u[id][(int)u[id].size() - x];
            a[cnt].r = i, a[now[id]].nxt = cnt;
            a[cnt].x = x, mnr[x] = n + 1;
            now[id] = cnt;
        &#125;
    &#125;
    read(m);
    for (int i = 1; i &lt;= m; ++i) &#123;
        read(q[i].l), read(q[i].r);
        read(q[i].k), q[i].i = i;
    &#125;
    std::sort(q + 1, q + m + 1);
    std::sort(a + 1, a + cnt + 1);
    pos = cnt;
    for (int i = m; i; --i) &#123;
        while (a[pos].l &gt;= q[i].l) &#123;
            if (a[pos].r &lt; mnr[a[pos].x]) &#123;
                if (mnr[a[pos].x] &lt;= n)
                    add(mnr[a[pos].x], -1);
                add(a[pos].r, 1);
                mnr[a[pos].x] = a[pos].r;
            &#125;
            --pos;
        &#125;
        ans[q[i].i] = calc(ask(q[i].r), q[i].k);
    &#125;
    for (int i = 1; i &lt;= m; ++i)
        print(ans[i], &#39;\n&#39;);
    return 0;
&#125;
&#125; // namespace XSC062
#undef int
我甚至打完了就过了样例然后直接就 A 了，好久没有这么爽地过过这种大码量 正确性还未知 的题了。

而且我相信全场只有我一个 小丑 帅哥打离线，所以我是最强的！！！🤡🤡🤡

绝对不如法一的法二代码
#define int long long
namespace XSC062 &#123;
using namespace fastIO;
const int maxm = 505;
const int maxn = 1e5 + 5;
int a[maxn];
int cnt[maxn];
int sum[maxm][maxn];
int n, tot, m, l, r, k, res;
int calc(int x, int k) &#123;
    int res = 1;
    for (int i = 1; i &lt;= k; ++i)
        res *= x--;
    for (int i = 1; i &lt;= k; ++i)
        res /= i;
    return res;
&#125;
int main() &#123;
    read(n);
    for (int i = 1; i &lt;= n; ++i) &#123;
        read(a[i]);
        if (a[i] &lt;= n) ++cnt[a[i]];
    &#125;
    for (int i = 1; i &lt;= n; ++i) &#123;
        if (cnt[i] &gt;= i) &#123;
            sum[++tot][n + 1] = i;
            for (int j = 1; j &lt;= n; ++j)
                sum[tot][j] = sum[tot][j - 1] + (a[j] == i);
        &#125;
    &#125;
    read(m);
    while (m--) &#123;
        read(l), read(r), read(k);
        res = 0;
        for (int i = 1; i &lt;= tot; ++i)
            res += (sum[i][r] - sum[i][l - 1] &gt;= sum[i][n + 1]);
        print(calc(res, k), &#39;\n&#39;);
    &#125;
    return 0;
&#125;
&#125; // namespace XSC062
#undef int


D. 括号序列
https://www.becoder.com.cn/contest/4272/problem/4
呃呃呃，这，有什么好讲的吗？做过原题的应该都会吧……
反正就是个比较裸的区间 DP，转移的时候注意一下究竟哪些是同一对括号，哪些是相邻括号就好。
复杂度 \(O(n^2)\)。

namespace XSC062 &#123;
using namespace fastIO;
const int maxn = 1e3 + 5;
int n, res;
char s[maxn];
std::stack&lt;int&gt; t;
int mat[maxn], c[5];
int f[maxn][maxn][3][3];
int max(int x, int y) &#123; return x &gt; y ? x : y; &#125;
void upd(int &amp;x, int y) &#123; x = max(x, y); return; &#125;
int main() &#123;
    memset(f, -0x3f, sizeof (f));
    scanf(&quot;%d %d %d&quot;, &amp;n, &amp;c[1], &amp;c[2]);
    scanf(&quot;%s&quot;, s + 1);
    for (int i = 1; i &lt;= n; ++i) &#123;
        if (s[i] == &#39;(&#39;) t.push(i);
        else mat[t.top()] = i, t.pop();
    &#125;
    for (int i = 1; i &lt;= n; ++i) &#123;
        if (mat[i] == i + 1) &#123;
            for (int k = 0; k &lt;= 2; ++k)
                f[i][i + 1][k][k] = c[k];
        &#125;
    &#125;
    for (int l = 4; l &lt;= n; l += 2) &#123;
        for (int i = 1; i &lt;= n - l + 1; ++i) &#123;
            int j = i + l - 1;
            if (mat[i] == j) &#123;
                // ((...))
                // xy...zx
                for (int x = 0; x &lt;= 2; ++x) &#123;
                    for (int y = 0; y &lt;= 2; ++y) &#123;
                        if (y == x) continue;
                        for (int z = 0; z &lt;= 2; ++z) &#123;
                            if (z == x) continue;
                            upd(f[i][j][x][x], f[i + 1][j - 1][y][z] + c[x]);
                        &#125;
                    &#125;
                &#125;
            &#125;
            else &#123;
                // ()(...)
                // xxy...z
                for (int x = 0; x &lt;= 2; ++x) &#123;
                    for (int y = 0; y &lt;= 2; ++y) &#123;
                        if (y == x) continue;
                        for (int z = 0; z &lt;= 2; ++z)
                            upd(f[i][j][x][z], f[i][mat[i]][x][x] + f[mat[i] + 1][j][y][z]);
                    &#125;
                &#125;
            &#125;
        &#125;
    &#125;
    for (int i = 0; i &lt;= 2; ++i) &#123;
        for (int j = 0; j &lt;= 2; ++j)
            res = max(res, f[1][n][i][j]);
    &#125;
    print(res, &#39;\n&#39;);
    return 0;
&#125;
&#125; // namespace XSC062

]]></content>
      <tags>
        <tag>树状数组</tag>
        <tag>区间 DP</tag>
      </tags>
  </entry>
  <entry>
    <title>解题报告：情景剧</title>
    <url>/20231004/</url>
    <content><![CDATA[2023 牛客 OI 赛前集训营-提高组（第一场）- A. 情景剧。


A. 情景剧
https://www.becoder.com.cn/contest/4273/problem/1

给定序列，求任取一段区间，区间最大值、区间最小值、区间长度之积的最大值。
\(N\le 2\times 10^6\)，值域为 \(10^9\)。

对于 \(a_i\)，假设它是 \([X_i, Y_i]\) 内的最大值，且 \([X_i, Y_i]\) 是该条件下的极大区间；
相似地，对于 \(a_j\)，假设它是 \([P_j, Q_j]\) 内的最小值，且 \([P_j, Q_j]\) 是该条件下的极大区间；
则对于 \(a_i\) 作为区间内最大值，\(a_j\) 作为区间内最小值的情况，满足该条件的区间为 \([\max(X_i, P_j), \min(Y_i, Q_j)]\)，答案为 \(k=a_i \times a_j \times [\min(Y_i, Q_j) - \max(X_i, P_j) + 1]\)。我们的目标就是最大化 \(k\)。
两个不固定的值，并且不能拆给斜优做，所以考虑将其中一个变得「固定」。
观察数组，我们发现，对于数组中的最大值 \(a_m\)，有 \(X_m = 1,Y_m=n\)。那么此时选取 \(a_m\) 作为区间最大值，选取任意数 \(a_j\) 作为最小值。这样做可以保证由 \(i\) 带来的影响都是最优的，只用枚举 \(j\) 并求解即可。此时的答案就是 \(a_m\times a_j\times (Q_j-P_j + 1)\)。
我们上述条件成立的前提是 \(i\) 在 \([P_j, Q_j]\) 内且 \(j\) 在 \([X_i, Y_i]\) 内。当 \(i\) 取 \(m\) 时后者显然成立，但很容易构造出来情况让前者不成立。比如说 15 1 5，当 \(j=3\) 时就会得到错误的答案。
受刚才的思考启发，取 \([P_j, Q_j]\) 内的最大值作为 \(i\)。此时有 \(X_i\le P_j\le Q_j \le Y_j\)，答案为区间内最优。
接下来需要求解 \(P_j\) 和 \(Q_j\)。观察数据范围，应该是 \(O(n)\) 做法。不难想到单调栈，可惜我不会，所以采用同样是 \(O(n)\) 的悬线法（我的博客：有关悬线法的介绍）。
那么怎么求 \([P_j,Q_j]\) 内的最大值呢？当遇到这种求解区间与左右端点一致，并且待求满足可加性的情况时，我们可以在悬线的时候一起求解。当悬线跨越一个区间时，我们直接用这个已求解区间的最大值更新当前求的最大值。
左右分别求最大值（注意要用两个数组分别记录，防止错误更新），最后取两者较大作为最终区间内最大值即可。
最终时间复杂度 \(O(n)\)。

🌼 鲜花
不知道为什么听别人说很卡，不卡啊，我一个点 250ms。
啊什么你们打的 \(O(n\log n)\)？因为单调栈信息断层不能维护区间内最大值？菜。那我必须把这篇发出来嘲讽你们了。兔子说要是不打 fread Lemon 上就会起飞，我说我打了，我还疑惑 \(O(n)\) 跑 2e6 普通快读怎么会寄呢。一问，啊，带 \(\log\)，菜。
啊什么谭委员带 \(\log\) 一个点只要 500ms？那也比我慢，菜。

说起来这是我头一次用悬线解决不在矩阵上，还要维护信息的题，之前并没有细想过单调栈和悬线可维护的信息差异，这次算是误打误撞做对了。
注意到数据范围，应该要开 __int128 吧。

#define int __int128
namespace XSC062 &#123;
using namespace fastIO;
const int maxn = 2e6 + 5;
int a[maxn];
int n, mx, res;
int l[maxn], r[maxn];
int mxl[maxn], mxr[maxn];
int max(int x, int y) &#123; return x &gt; y ? x : y; &#125;
int main() &#123;
    read(n), l[0] = 1;
    for (int i = 1; i &lt;= n; ++i) &#123;
        read(a[i]), l[i] = i;
        mxl[i] = mxr[i] = a[i];
        while (l[i] &gt; 1 &amp;&amp; a[l[i] - 1] &gt;= a[i]) &#123;
            mxl[i] = max(mxl[i], mxl[l[i] - 1]);
            l[i] = l[l[i] - 1];
        &#125;
    &#125;
    r[n + 1] = n;
    for (int i = n; i; --i) &#123;
        r[i] = i;
        while (r[i] &lt; n &amp;&amp; a[r[i] + 1] &gt;= a[i]) &#123;
            mxr[i] = max(mxr[i], mxr[r[i] + 1]);
            r[i] = r[r[i] + 1];
        &#125;
        res = max(res, max(mxl[i], mxr[i]) * a[i] * (r[i] - l[i] + 1));
    &#125;
    print(res, &#39;\n&#39;);
    return 0;
&#125;
&#125; // namespace XSC062
#undef int


upd on 240704
我们在 这篇博客 中提到了悬线的本质是笛卡尔树，而本题就是其链上爬山维护数据的一个优秀体现，也是因为这一点，应该更加深切地认识到悬线包含式的访问顺序使之维护的数据类型应和倍增 / 树状数组等类似。
所以说到可维护数据的复杂程度，笛卡尔树严格大于悬线严格大于单调栈好吧 
虽然现在全世界都知道我是悬线魔怔人了 
]]></content>
      <tags>
        <tag>悬线法</tag>
      </tags>
  </entry>
  <entry>
    <title>杂题选谈</title>
    <url>/20231112/</url>
    <content><![CDATA[NOIP S &amp; 周考 16 &amp; 杂题。


A. 数字游戏
https://www.becoder.com.cn/contest/4424/problem/1

闲话
一开始忘了怎么做的然后从 Cindy 的做法开始回忆，一边回忆一边写下文，结果发现写着写着变成 wjf 的做法了 /cf
upd：变成菌的做法了 /cf /cf /cf
upd：变成 zmq 的做法了，我已经懒得 /cf 了。

题意转化一下，大致就是一个每次往右拓展一位的询问区间，每次查询该询问区间内最大值并拿走之。
我们先感性地想，对于一个 很大的值，它一进入询问范围就会被当场拿走。
那如果没有被拿走是因为什么呢？因为在前面积存下来的元素中还有比它大的。
那为什么前面的比它大的元素没有被当场拿走呢？因为在更前面积存下来的有比这个元素大的…… 那么最开始的积存是怎么来的呢？是最初询问区间为 \([1,p_i]\) 而非 \([1,1]\) 导致的。
被积存下的数被拿出来用掉的时刻，就是往后碰到了一个比它小的值，然后顶替掉这个值被用掉。被顶替的就进入积存区。
所以这个时候我们直接 模拟 积存数被用掉的过程。
对于全序列中的最大值，当场用掉。次大值呢，若它比最大值先进入询问区间，皆大欢喜，当场用掉；又因为最大值不可能被积存，就算它在最大值之后，也可以当场用掉。
第三大的，就可能进积存区。假设它要出来，首先要满足出来的时间（在进入积存区之后，有点废话），然后如果它一出来就碰到了比它更大的，很不幸，出不来了。但是因为除了最大和次大之外没有元素比它大了，它就可以在剩下的位置里面随便挑——当然是挑最靠前的。后面的和第三大道理就差不多了。
所以这个时候我们就可以得到一个大致的做法了，我们把元素从大到小排序，顺便记录一下它进入询问范围的时间 \(t\)。然后我们优先让这个值在 \(t\) 时刻直接被拿走。那假如 \(t\) 这个位置已经被更大的元素占领了，就找这之后第一个空位。
那么这个「第一个空位」怎么找呢？我们用一个初值为 \(1\) 的 \(pos\)，对于当场拿走的情况，肯定是不会有冲突的，所以冲突都发生在积存区。积存区又都是从 \(1\) 开始的，所以我们只需要对于不是当场拿走的情况，把 \(pos\) 移到距离 当前值 最近的空位然后放进去就可以了。因为 \(pos\) 全程只会右移，摊出来是 \(O(n)\) 的。
因为我们只要在最开始排个序，总时间复杂度 \(O(n\log n + nq)\)。

#define int long long
namespace XSC062 &#123;
using namespace fastIO;
const int maxn = 1e5 + 5;
struct _ &#123;
    int x, i;
    bool operator&lt; (const _ &amp;q) const &#123;
        return x &gt; q.x;
    &#125;
&#125;;
_ a[maxn];
int flag[maxn];
int n, m, p, res, pos;
int main() &#123;
#ifdef ONLINE_JUDGE
    freopen(&quot;game.in&quot;, &quot;r&quot;, stdin);
    freopen(&quot;game.out&quot;, &quot;w&quot;, stdout);
#endif
    read(n), read(m);
    for (int i = 1; i &lt;= n; ++i)
        read(a[i].x), a[i].i = i;
    std::sort(a + 1, a + n + 1);
    while (m--) &#123;
        read(p), res = 0, pos = 1;
        for (int i = 1; i &lt;= n; ++i)
            flag[i] = 0;
        for (int i = 1; i &lt;= n; ++i) &#123;
            int id =
            (a[i].i &lt; p ? 1 : a[i].i - p + 1);
            if (flag[id]) &#123;
                while (flag[pos]) ++pos;
                flag[pos] = i;
            &#125;
            else flag[id] = i;
        &#125;
        for (int i = 1, j = 1; i &lt;= n; ++i, j = -j) 
            res += j * a[flag[i]].x;
        print(res, &#39;\n&#39;);
    &#125;
    return 0;
&#125;
&#125; // namespace XSC062
#undef int


B. 过河卒II
https://www.becoder.com.cn/contest/4424/problem/2
以及 这 是原题。
读错题了整整 3.5h /youl
我们接下来把「特殊格子」记为 -，「特殊格子」四个方向相邻的点记作 O，除此之外的点因为没有可能被选到，我们不做讨论。
  -
- O -
  -
对于一个关键点，我们发现找 T 字本身不太方便，所以我们可以把这个转化成在十字里面抠掉一个最小值。
接下来，我们假设有另一个关键点的十字和这一个的十字有重合并不相邻，那么大抵是形如这个样子的：
  -   -
- O - O -
  -   -
这个时候，我们发现一共有 7 个 -，一共需要 6 个 -，所以我们试着随便抠掉一个。
  X   | -
- O - | O -
  -   | -
我们发现这个时候一定是能找到一个 确定的 方案去划分 T 字的。
所以对于两个 O 的情况，我们抠掉七个 - 当中的最小值即可。
接下来假设有三个 O，那么会有 10 个 -，但我们需要 9 个，于是抠掉最小值，依然存在一种 确定的 方案去划分 T 字。
不难发现，\(n\) 彼此影响还不相邻的 O 会带来 \(3\times n-1\) 个 -（小学数学计算即可），我们将最小者删除即可得到最大答案。
推广一下结论，其实是我们对于 \(x\) 个相互影响的 O（注意这里 没有强调 不相邻），删掉一些使得 - 的数量为 \(3x\)。
那么我们又知道对于最理想的情况，也就是上面讲到的相互影响又不相邻，- 的个数是 \(3\times x+1\)，我们又只能进行抠掉 - 这一个操作。
所以对于一个 O/- 连通块，要求其 - 的个数要么是 \(3x\)（不然 - 就不够用了，以及 - 的缺失是相邻的 O 和边界导致的；边界外的 - 肯定是不能算的），要么为 \(3x+1\)（只用删一个也保证了正确性）。
所以我们跑一个类 Flood-fill，一边搜一边找最小的 -，还要统计 - 和 O 的总个数，还要计算 \(sum\)。然后就完了。
虽然说这个 Flood-fill 没什么技术含量，但是我们要注意只能从 - 出发只能通往 O 而非另一个 -，因为相邻的两个 - 其实是不会互相交叉的相互影响的。
Flood-fill 带来的总时间复杂度为 \(O(nm)\)。

namespace XSC062 &#123;
using namespace fastIO;
const int maxk = 1e6 + 5;
const int inf = 0x3f3f3f3f;
const int fx[] = &#123; 0, 0, 1, -1 &#125;;
const int fy[] = &#123; 1, -1, 0, 0 &#125;;
int n, m, k, x, y, res;
int mn, sum, cnt1, cnt2;
std::vector&lt;std::vector&lt;int&gt; &gt; a, b, c;
int min(int x, int y) &#123; return x &lt; y ? x : y; &#125;
int max(int x, int y) &#123; return x &gt; y ? x : y; &#125;
void DFS(int x, int y) &#123;
    sum += a[x][y];
    if (b[x][y] == 1) ++cnt1;
    else ++cnt2, mn = min(mn, a[x][y]);
    c[x][y] = 1;
    for (int i = 0; i &lt; 4; ++i) &#123;
        int nx = x + fx[i],
            ny = y + fy[i];
        if (!nx || !ny || nx &gt; n || ny &gt; m)
            continue;
        if (c[nx][ny]) continue;
        if ((b[x][y] == 1 &amp;&amp; b[nx][ny] == 1)
         || (b[x][y] == 1 &amp;&amp; b[nx][ny] == 2)
          || (b[x][y] == 2 &amp;&amp; b[nx][ny] == 1))
            DFS(nx, ny);
    &#125;
    return;
&#125;
int main() &#123;
#ifdef ONLINE_JUDGE
    freopen(&quot;pawn.in&quot;, &quot;r&quot;, stdin);
    freopen(&quot;pawn.out&quot;, &quot;w&quot;, stdout);
#endif
    read(n), read(m);
    a.push_back(std::vector&lt;int&gt;(m + 1));
    b.push_back(std::vector&lt;int&gt;(m + 1));
    for (int i = 1; i &lt;= n; ++i) &#123;
        a.push_back(std::vector&lt;int&gt;(m + 1));
        b.push_back(std::vector&lt;int&gt;(m + 1));
        for (int j = 1; j &lt;= m; ++j)
            read(a[i][j]);
    &#125;
    c = b, read(k);
    for (int i = 1; i &lt;= k; ++i) &#123;
        read(x), read(y), ++x, ++y;
        b[x][y] = 1;
        if (x + 1 &lt;= n &amp;&amp; !b[x + 1][y]) b[x + 1][y] = 2;
        if (y + 1 &lt;= m &amp;&amp; !b[x][y + 1]) b[x][y + 1] = 2;
        if (x - 1 &gt;= 1 &amp;&amp; !b[x - 1][y]) b[x - 1][y] = 2;
        if (y - 1 &gt;= 1 &amp;&amp; !b[x][y - 1]) b[x][y - 1] = 2;
    &#125;
    for (int i = 1; i &lt;= n; ++i) &#123;
        for (int j = 1; j &lt;= m; ++j) &#123;
            if (b[i][j] &amp;&amp; !c[i][j]) &#123;
                mn = inf;
                cnt1 = cnt2 = sum = 0;
                DFS(i, j);
                if (cnt2 == cnt1 * 3) res += sum;
                else if (cnt2 == cnt1 * 3 + 1) res += sum - mn;
                else &#123; puts(&quot;No&quot;); return 0; &#125;
            &#125;
        &#125;
    &#125;
    print(res, &#39;\n&#39;);
    return 0;
&#125;
&#125; // namespace XSC062


C. 树图
https://www.becoder.com.cn/contest/4424/problem/3

DJ：你们去打一下动态树 DP 的板子就可以了。

此时无声胜有声。
这里仅仅介绍一下 40pts 的做法。我们理所当然地想到 DP 一个点染成某种颜色所需的最小代价。
这里说的染成某种颜色其实不太准确，应该是「代表着」哪种颜色。像 0 可以代表 1 也可以代表 2，1 就只能代表 1，2 也只能代表 2。
令 \(f_{u,1}\) 表示以 \(u\) 为根的子树中不保留颜色 2 的最小代价（代表 1），\(f_{u, 2}\) 表示以 \(u\) 为根的子树中不保留颜色 1 的最小代价（代表 2）。
那么对于颜色已经确定为 \(1\) 的点 \(u_1\)，\(f_{u_1,2}=\inf\)；对于颜色已经确定为 \(2\) 的点 \(u_2\)，\(f_{u_2,1}=\inf\)；颜色为 0 的 \(u_0\) 就不用管。
然后如果 \(u_1\) 有一个 2 颜色的儿子 \(v_2\)，就要切断这条边；反之，如果这个儿子的颜色为 1，就不用切断。
所以有：
\[
f_{u,c}=\sum_{v\in son_u} \min(f_{v,c},f_{v,3-c}+1)
\]
那么就完了。每次询问的时候跑一个完整的树 DP，或者我们也可以发现只用更新 \(u\) 到目标点这一条链上的 DP 值，然后就可以根据这个做一个并不会实际改进复杂度的优化。
总体时间复杂度 \(O(nq)\)。

namespace XSC062 &#123;
using namespace fastIO;
const int maxn = 1e5 + 5;
const int inf = 0x3f3f3f3f;
int col[maxn];
int f[maxn][3];
int n, x, y, q;
std::vector&lt;int&gt; g[maxn];
int min(int x, int y) &#123;
    return x &lt; y ? x : y;
&#125;
void DFS(int x, int fa, int to) &#123;
    f[x][1] = f[x][2] = 0;
    if (col[x] == 1) f[x][2] = inf;
    else if (col[x] == 2) f[x][1] = inf;
    for (auto i : g[x]) &#123;
        if (i == fa) continue;
        if (x != to) DFS(i, x, to);
        f[x][1] += min(f[i][1], f[i][2] + 1);
        f[x][2] += min(f[i][2], f[i][1] + 1);
    &#125;
    return;
&#125;
void add(int x, int y) &#123;
    g[x].push_back(y);
    return;
&#125;
int main() &#123;
#ifdef ONLINE_JUDGE 
    freopen(&quot;diagrams.in&quot;, &quot;r&quot;, stdin);
    freopen(&quot;diagrams.out&quot;, &quot;w&quot;, stdout);
#endif
    read(n);
    for (int i = 1; i &lt; n; ++i) &#123;
        read(x), read(y);
        add(x, y), add(y, x);
    &#125;
    read(q);
    while (q--) &#123;
        read(x), read(y);
        col[y] = (x &lt;= 2) ? x : 0;
        DFS(1, -1, y);
        print(min(f[1][1], f[1][2]), &#39;\n&#39;);
    &#125;
    return 0;
&#125;
&#125; // namespace XSC062


E. 字符串 string
https://www.becoder.com.cn/contest/4423/problem/5
原题：CF756D - Bacterial Melee。

怪话
兔子：我谴责你。
我：？
兔子：为什么你的 last 要缩写成 la。我没看你题解直接看的代码看了半天没看懂。
我：不缩写成 la 难道要写成 lst 吗？
兔子：不然呢？
好吧，大家都是异教徒。

可以很简单的想到，最终字符串一定由原串中的部分字符，按照其在原串中的顺序，经过若干次重复得到。那么我们把一段连续的相同字符视为一个字符，得到的这个串就是原串的一个子序列。
所以我们只需要求出原串的不同子序列个数，再经过一定的排列组合就可以求出方案数。
比如，我们知道一个长度为 \(n\) 的串中有 \(k\) 个长度为 \(m\) 的子序列，那么由插板法可得这 \(k\) 个子序列会贡献 \(C_{n-1}^{m-1}\times k\) 的方案数。
那么不同子序列个数怎么求呢？显而易见需要 DP，规定 \(f_{i,j}\) 表示一个长度为 \(i\) 的子序列最后一位为 \(s_j\) 的方案数，就可以直接 \(f_{i,j}=\sum f_{i-1,k}\)。
但这样做有一个问题，就是会重复计算。假如原串中在 \(i\) 位置有一个 'o'，\(i+1\) 位置又有一个 'o'，两个都可以从前面某个位置（假设为 \(j\)；假设 \(j\) 上其中一个被计入方案数的合法子序列为 "hyac"），那么转移到 \(i\) 时，计算了 "hyaco"，到了 \(i+1\)，依然可以从 \(j\) 处得到 "hyaco"，就会重复计算。
那么怎么避免这一点呢？对于一个位置 \(i\)，假设其上一个相同字母的位置为 \(last_i\)，我们规定其仅可从 \((last_i,i)\) 进行转移即可（注意两边都是开区间）。
初始化是对于每一个没有前驱的 \(i\)，\(f_{1,i}=1\)。
实现上，因为 \(n\) 的大小是 \(5\times 10^3\)，转移区间又是连续的，我们用一个前缀和进行优化即可。
时间复杂度 \(O(n^2)\)，应该比官方题解讲的方法具象一些。

#define int long long
namespace XSC062 &#123;
using namespace fastIO;
const int mod = 1e9 + 7;
const int maxn = 5e3 + 5;
int n, res;
char s[maxn];
int fac[maxn];
int la[maxn], p[maxn];
int f[maxn][maxn], u[maxn][maxn];
int max(int x, int y) &#123; return x &gt; y ? x : y; &#125;
int qkp(int x, int y) &#123;
    int res = 1;
    while (y) &#123;
        if (y &amp; 1) (res *= x) %= mod;
        (x *= x) %= mod, y &gt;&gt;= 1;
    &#125;
    return res;
&#125;
int inv(int x) &#123; return qkp(x, mod - 2); &#125;
int A(int n, int m) &#123;
    return fac[n] * inv(fac[n - m]) % mod;
&#125;
int C(int n, int m) &#123;
    return A(n, m) * inv(fac[m]) % mod;
&#125;
int main() &#123;
    scanf(&quot;%lld %s&quot;, &amp;n, s + 1);
    fac[0] = 1;
    for (int i = 1; i &lt;= n; ++i) &#123;
        la[i] = p[s[i] - &#39;a&#39; + 1];
        if (!la[i]) f[1][i] = 1, ++res;
        u[1][i] = u[1][i - 1] + f[1][i];
        p[s[i] - &#39;a&#39; + 1] = i;
        fac[i] = (fac[i - 1] * i) % mod;
    &#125;
    for (int i = 2; i &lt;= n; ++i) &#123;
        int sum = 0;
        for (int j = i; j &lt;= n; ++j) &#123;
            int k = max(i - 1, la[j] + 1);
            if (k &lt;= j - 1)
                f[i][j] = (u[i - 1][j - 1] - u[i - 1][k - 1]) % mod;
            u[i][j] = (u[i][j - 1] + f[i][j]) % mod;
            (sum += f[i][j]) %= mod;
        &#125;
        res += C(n - 1, i - 1) * sum % mod;
        res %= mod;
    &#125;
    res = (res + mod) % mod;
    print(res, &#39;\n&#39;);
    return 0;
&#125;
&#125; // namespace XSC062
#undef int


ABC328F - Good Set Query
https://atcoder.jp/contests/abc328/tasks/abc328_f
一个加权并查集。
我们用并查集维护关系，在合并两个集合的时候给被合并者的原本根打一个懒标记，意为该并查集需要整体更新的 delta。
在每次 find 时，路径上的点均从 直系父亲 处继承懒标记。然后因为有了路径压缩，所以每个点在查询时均能得到不重复的懒标记（因为自己的祖先已经被直系父亲继承过了）。
同样也是因为弱势一方才被打标记，保证了根节点上不会有标记，路径压缩后就将父亲更新为根，保证不会因为多次 find 导致标记重复计算。
每次尝试合并的时候，因为首先需要进行 find，保证 \(x\) 和 \(y\) 均是最新状态。若 \(x\) 和 \(y\) 已经在同一个集合了，直接判断两个差值是否为 \(d\)；否则，合并两个集合并给弱势方打上标记。

#define int long long
namespace XSC062 &#123;
using namespace fastIO;
const int maxn = 2e5 + 5;
int n, q, x, y, d;
int f[maxn], u[maxn];
int find(int x) &#123;
    if (f[x] == x) return x;
    int fa = find(f[x]);
    u[x] += u[f[x]];
    return f[x] = fa;
&#125;
bool merge(int x, int y, int d) &#123;
    int fx = find(x), fy = find(y);
    if (fx == fy) return u[x] - u[y] == d;
    f[fx] = fy, u[fx] = d - (u[x] - u[y]);
    return 1;
&#125;
int main() &#123;
    read(n), read(q);
    for (int i = 1; i &lt;= n; ++i)
        f[i] = i;
    for (int i = 1; i &lt;= q; ++i) &#123;
        read(x), read(y), read(d);
        if (merge(x, y, d)) print(i, &#39; &#39;);
    &#125;
    putchar(&#39;\n&#39;);
    return 0;
&#125;
&#125; // namespace XSC062
#undef int


CF1701F - Points
http://codeforces.com/problemset/problem/1701/F
我们先考虑对于一个单点 \(p\)，假设 \([p-d, p)\) 中共有 \(k\) 个点，那么答案就是 \(C_k^2=\dfrac {k(k-1)}2\)。
假如范围内新加入了一个点，\(k\gets k+1\)，那么答案就是 \(C_{k+1}^2=\dfrac {k(k+1)}{2}\)，较原来增加了 \(k\)。相应地，若范围内减少了一个点，\(k\gets k-1\)，答案较原来就会减少 \(k-1\)。
当我们加入一个点 \(p\)，区间 \((p,p+d]\) 都会收到影响。假设该区间内原本的每个点之 \(k\) 的和是 \(s_k\)，那么总体的答案就会减少 \(s_k\)。
那么 \(s_k\) 怎么去维护呢？插入点 \(p\) 时，答案先加上当前 \(s_k\) 和新点的 \(k\)，再将 \((p, p+d]\) 内的 \(s_k\) 全部 +1；删除点 \(p\) 时，答案减去 \(s_k-c\) 和待删点的答案（其中 \(c\) 是 \((p,p+d]\) 中的点数），再将 \((p, p+d]\) 内的 \(s_k\) 全部 -1。

#define int long long
namespace XSC062 &#123;
using namespace fastIO;
const int lim = 2e5;
const int maxn = 2e5 + 5;
#define lt (p &lt;&lt; 1)
#define rt (lt | 1)
struct _ &#123; int u, p, d, l, r; &#125;;
_ t[maxn &lt;&lt; 2];
int q, d, x, res;
int min(int x, int y) &#123; return x &lt; y ? x : y; &#125;
int max(int x, int y) &#123; return x &gt; y ? x : y; &#125;
void pushdown(int p) &#123;
    if (t[p].d) &#123;
        t[lt].u += t[lt].p * t[p].d;
        t[rt].u += t[rt].p * t[p].d;
        t[lt].d += t[p].d;
        t[rt].d += t[p].d;
        t[p].d = 0;
    &#125;
    return;
&#125;
void bld(int p, int l, int r) &#123;
    t[p].l = l, t[p].r = r;
    if (l == r) return;
    int mid = (l + r) &gt;&gt; 1;
    bld(lt, l, mid), bld(rt, mid + 1, r);
    return;
&#125;
int ask(int p, int l, int r) &#123;
    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r)
        return t[p].p;
    int res = 0, mid = (t[p].l + t[p].r) &gt;&gt; 1;
    if (l &lt;= mid) res = ask(lt, l, r);
    if (r &gt; mid) res += ask(rt, l, r);
    return res;
&#125;
int qry(int p, int l, int r) &#123;
    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r)
        return t[p].u;
    int res = 0, mid = (t[p].l + t[p].r) &gt;&gt; 1;
    pushdown(p);
    if (l &lt;= mid) res = qry(lt, l, r);
    if (r &gt; mid) res += qry(rt, l, r);
    return res;
&#125;
void upd(int p, int l, int r, int x) &#123;
    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r) &#123;
        t[p].d += x;
        t[p].u += t[p].p * x;
        return;
    &#125;
    int mid = (t[p].l + t[p].r) &gt;&gt; 1;
    pushdown(p);
    if (l &lt;= mid) upd(lt, l, r, x);
    if (r &gt; mid) upd(rt, l, r, x);
    t[p].u = t[lt].u + t[rt].u;
    return;
&#125;
void clr(int p, int x) &#123;
    --t[p].p;
    if (t[p].l == t[p].r) &#123;
        res -= t[p].u * (t[p].u - 1) / 2;
        t[p].u = t[p].d = t[p].p = 0;
        return;
    &#125;
    int mid = (t[p].l + t[p].r) &gt;&gt; 1;
    pushdown(p);
    if (x &lt;= mid) clr(lt, x);
    else clr(rt, x);
    t[p].u = t[lt].u + t[rt].u;
    return;
&#125;
void add(int p, int x, int v) &#123;
    ++t[p].p;
    if (t[p].l == t[p].r) &#123;
        res += v * (v - 1) / 2;
        t[p].u = v, t[p].p = 1;
        return;
    &#125;
    int mid = (t[p].l + t[p].r) &gt;&gt; 1;
    pushdown(p);
    if (x &lt;= mid) add(lt, x, v);
    else add(rt, x, v);
    t[p].u = t[lt].u + t[rt].u;
    return;
&#125;
void upd(int l, int r, int x) &#123;
    upd(1, min(l, lim), min(r, lim), x);
    return;
&#125;
int qry(int l, int r) &#123;
    return qry(1, min(l, lim), min(r, lim));
&#125;
int ask(int l, int r) &#123;
    return ask(1, max(1, min(l, lim)), max(1, min(r, lim)));
&#125;
int main() &#123;
    read(q), read(d);
    bld(1, 1, lim);
    while (q--) &#123;
        read(x);
        if (ask(x, x)) &#123;
            int u = qry(x + 1, x + d) - ask(x + 1, x + d);
            res -= u, upd(x + 1, x + d, -1), clr(1, x);
        &#125;
        else &#123;
            int u = qry(x + 1, x + d);
            res += u, upd(x + 1, x + d, 1);
            add(1, x, ask(x - d, x - 1));
        &#125;
        print(res, &#39;\n&#39;);
    &#125;
    return 0;
&#125;
&#125; // namespace XSC062
#undef int

]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>杂题选谈：构造</title>
    <url>/20231005/</url>
    <content><![CDATA[构造杂题。


A - Errich-Tac-Toe (Hard Version)
https://vjudge.net/contest/585791#problem/A
如果我们将地图按国际象棋式斜向黑白染色分组，规定黑组要么黑色要么无色，白组要么白色要么无色，那么这样是一定不会三连击的。

容易发现无色格子永远不会被更改，而在方式 A 中被更改的格子在方式 B 中一定不会被更改；相应地，在方式 A 中不被更改的格子在方式 B 中一定会被更改，故两种染色方式更改的格子数总和就是一开始非无色的格子数。所以根据抽屉原理，一定能找到一种染色方式，代价 \(\le \dfrac k2\)。
但是我们要找到的，是代价 \(\le \dfrac k3\) 的方案呀？我们观察到我们上面的分组方式，直接让相邻两个不一样了，连二连击都做不到；所以我们要使我们的染色方式更廉价。
我们仍然斜向染色，但是分为三组：

这样，因为刚才叙述过的原因，一定能找到一种染色方法，代价 \(\le \dfrac k3\)。
枚举三种方式，取代价最小的一种即可。

namespace XSC062 &#123;
using namespace fastIO;
const int maxn = 305;
char a[maxn][maxn];
int col[maxn][maxn];
int T, n, res, id, typ;
int min(int x, int y) &#123; return x &lt; y ? x : y; &#125;
int func(int x, int y) &#123;
    int res = 0;
    for (int i = 1; i &lt;= n; ++i) &#123;
        for (int j = 1; j &lt;= n; ++j) &#123;
            if (col[i][j] == y)
                res += (a[i][j] == &#39;X&#39;);
            else if (col[i][j] != x)
                res += (a[i][j] == &#39;O&#39;);
        &#125;
    &#125;
    return res;
&#125;
int main() &#123;
    scanf(&quot;%d&quot;, &amp;T);
    while (T--) &#123;
        scanf(&quot;%d&quot;, &amp;n);
        int cnt = 0;
        for (int i = 1; i &lt;= n; ++i)
            scanf(&quot;%s&quot;, a[i] + 1);
        for (int i = 1; i &lt;= n; ++i) &#123;
            for (int j = 1; j &lt;= n; ++j)
                cnt += (a[i][j] != &#39;.&#39;);
            for (int j = 1; j &lt;= i; ++j)
                col[j][i - j + 1] = (i - 1) % 3 + 1;
        &#125;
        for (int i = 2; i &lt;= n; ++i) &#123;
            for (int j = 1; j &lt;= n - i + 1; ++j)
                col[j + i - 1][n - j + 1] = (n + i - 2) % 3 + 1;
        &#125;
        res = func(1, 2), id = 1, typ = 2;
        if (func(1, 3) &lt; res)
            res = func(1, 3), id = 1, typ = 3;
        if (func(2, 1) &lt; res)
            res = func(2, 1), id = 2, typ = 1;
        if (func(2, 3) &lt; res)
            res = func(2, 3), id = 2, typ = 3;
        if (func(3, 1) &lt; res)
            res = func(3, 1), id = 3, typ = 1;
        if (func(3, 2) &lt; res)
            res = func(3, 2), id = 3, typ = 2;
        for (int i = 1; i &lt;= n; ++i) &#123;
            for (int j = 1; j &lt;= n; ++j) &#123;
                if (col[i][j] == typ) &#123;
                    if (a[i][j] == &#39;X&#39;)
                        a[i][j] = &#39;O&#39;;
                &#125;
                else if (col[i][j] != id) &#123;
                    if (a[i][j] == &#39;O&#39;)
                        a[i][j] = &#39;X&#39;;
                &#125;
            &#125;
        &#125;
        for (int i = 1; i &lt;= n; ++i) &#123;
            for (int j = 1; j &lt;= n; ++j)
                putchar(a[i][j]);
            putchar(&#39;\n&#39;);
        &#125;
    &#125;
    return 0;
&#125;
&#125; // namespace XSC062

抽屉原理是构造中经常用到的手段，后面我们也会遇到运用了抽屉原理的更多题目。

B - Mine Sweeper II
https://vjudge.net/contest/585791#problem/B
观察到答案必须 \(\le \dfrac {n\times m}2\)，根据在上一道题目得到的经验，考虑找到两种地位相等、并完全相反的方案。
我们知道，把 B 变成 A 一定可以满足条件；从「完全相反」出发，考虑把所有雷变成空地、所有空地变成雷。
将空地上的数字视为由空地向周围八格的雷连边，可以连到的边的数量。将地图完全翻转后，边除了起点和终点翻转之外，没有任何变化。所以，数字之和不变。
由此我们就得到了分两组的方案，由抽屉原理，必有一组方案的代价 \(\le \dfrac {n\times m}2\)，取较小者即可。

namespace XSC062 &#123;
using namespace fastIO;
const int maxn = 1e3 + 5;
int n, m, res1, res2;
char a[maxn][maxn], b[maxn][maxn];
int main() &#123;
    scanf(&quot;%d %d&quot;, &amp;n, &amp;m);
    for (int i = 1; i &lt;= n; ++i)
        scanf(&quot;%s&quot;, a[i] + 1);
    for (int i = 1; i &lt;= n; ++i) &#123;
        scanf(&quot;%s&quot;, b[i] + 1);
        for (int j = 1; j &lt;= m; ++j) &#123;
            res1 += (a[i][j] != b[i][j]);
            res2 += (a[i][j] == b[i][j]);
        &#125;
    &#125;
    if (res1 &lt; res2) &#123;
        for (int i = 1; i &lt;= n; ++i)
            puts(a[i] + 1);
    &#125;
    else &#123;
        for (int i = 1; i &lt;= n; ++i) &#123;
            for (int j = 1; j &lt;= m; ++j) &#123;
                if (a[i][j] == &#39;.&#39;)
                    putchar(&#39;X&#39;);
                else putchar(&#39;.&#39;);
            &#125;
            putchar(&#39;\n&#39;);
        &#125;
    &#125;
    return 0;
&#125;
&#125; // namespace XSC062


C - Ehab’s Last Corollary
https://vjudge.net/contest/585791#problem/C
我们尝试证明出题人的猜想……

如果整个图上没有环，就整个一棵树
树呢，是一个二分图对不对，然后抽屉原理，我们看两部节点中比较大的那一坨，它的大小一定是 \(\ge \dfrac n2\) 又 \(\ge \dfrac k2\) 的，直接输出就好了。
否则，对于一个环，如果它的点数小于等于 \(k\)，那我们直接将它作为第二个问题的答案输出。
否则，我们在图的最小环上隔一个点选一个点，一定能选出 \(\left\lfloor\dfrac k2\right\rfloor\) 个相互独立的点。你说为什么它们之间没有直接连边呢？因为我们是在一个比 \(k\) 大的最小环上选的，要是它们之间有直接连边，那就会又构成一个更小的环了。
所以我们只需要找到一个最小的环然后按上述操作得到答案…… 然而找最小环这一点本身不太现实……
这个时候我们怎么办呢？
我们用一点神奇科技。考虑图的 DFS 树。

如果有返祖边 \((v, u)\)，且深度 \(d_v-d_u&lt; k\)，那么 \(u\to v\) 在树上的简单路径和返祖边 \((v, u)\) 共同构成一个长度不超过 \(k\) 的环，直接输出。
否则，因为 \(d_v-d_u\ge k\)，有 \(d_v\ge k\)，且对于任意 \(d_y-d_x&lt;k\)，返祖边 \((y,x)\) 不存在。
我们仍然考虑上面提到的隔一个取一个的方法。从任意 \(d_v\ge k\) 开始取点，分别取 \(v\) 的 \(0\) 代父辈（即自身），\(2\) 代父辈（即爷爷），\(4\) 代父辈……
为什么这么取就不会出 bug 呢？因为我们上面提到的「对于任意 \(d_y-d_x&lt;k\)，返祖边 \((y,x)\) 不存在」，所以不会有杂边干扰。


时间复杂度 \(O(n + m)\)。只能说真是妙啊。jly 赛高！

namespace XSC062 &#123;
using namespace fastIO;
const int maxn = 1e5 + 5;
bool vis[maxn];
int n, m, k, x, y;
int f[maxn], dep[maxn];
std::vector&lt;int&gt; g[maxn];
int col[maxn], cnt[5];
void color(int x, int fa, int now) &#123;
    col[x] = now, ++cnt[now];
    for (auto i : g[x]) &#123;
        if (i == fa) continue;
        color(i, x, 3 - now);
    &#125;
    return;
&#125;
void DFS(int x, int fa) &#123;
    vis[x] = 1;
    for (auto i : g[x]) &#123;
        if (i == fa) continue;
        if (vis[i]) &#123;
            if (dep[i] &lt; dep[x] &amp;&amp;
                dep[x] - dep[i] &lt; k) &#123;
                print(2, &#39;\n&#39;);
                int p = x, cnt = 1;
                while (p != i) ++cnt, p = f[p];
                print(cnt, &#39;\n&#39;), p = x;
                while (p != i) print(p, &#39; &#39;), p = f[p];
                print(i, &#39;\n&#39;), exit(0);
            &#125;
            continue;
        &#125;
        f[i] = x;
        dep[i] = dep[x] + 1;
        DFS(i, x);
    &#125;
    return;
&#125;
void add(int x, int y) &#123;
    g[x].push_back(y);
    return;
&#125;
int main() &#123;
    read(n), read(m), read(k);
    for (int i = 1; i &lt;= m; ++i) &#123;
        read(x), read(y);
        add(x, y), add(y, x);
    &#125;
    if (m == n - 1) &#123;
        print(1, &#39;\n&#39;);
        color(1, -1, 1);
        k = (k + 1) / 2;
        x = cnt[1] &gt; cnt[2] ? 1 : 2;
        for (int i = 1; i &lt;= n &amp;&amp; k; ++i) &#123;
            if (col[i] == x)
                print(i, &#39; &#39;), --k;
        &#125;
        putchar(&#39;\n&#39;);
        return 0;
    &#125;
    dep[1] = 1, DFS(1, -1);
    for (int i = 1; i &lt;= n; ++i) &#123;
        if (dep[i] &gt;= k) &#123;
            print(1, &#39;\n&#39;);
            x = i, k = (k + 1) / 2;
            while (k--)
                print(x, &#39; &#39;), x = f[f[x]];
            putchar(&#39;\n&#39;);
            break;
        &#125;
    &#125;
    return 0;
&#125;
&#125; // namespace XSC062


D - 景点划分
https://vjudge.net/contest/585791#problem/D

🤡 前言
你打开了题目。你想，不就是从图里抠两个连通块出来吗，这也能进 IOI？
你开始打代码。你突然发现不对劲。你抠掉了一个大小为 \(a\) 的连通块，然后发现剩下的部分裂成了很多个块，其中根本找不到一个大小 \(\ge b\) 的块。
你发现，事情没有这么简单。
这是你吗？不，这不是你，这是我，小丑 lym 🤡

不妨设 \(a\le b\le c\)，则由抽屉原理，\(a\le \dfrac n3\)。
我们从最特殊的情况开始思考。假如图是树，那么答案怎么求呢？
对于任意一条边，在其左右两边的连通块中，根据抽屉原理，较大者的大小必定 \(\ge \dfrac{n}{2}\)，根据重心的定义，重心必然属于较大连通块。
后面鸽了。总之先放个代码在这里。

namespace XSC062 &#123;
using namespace fastIO;
const int maxn = 1e5 + 5;
int org[5];
bool book[maxn];
int solFlag, sumFa, faP;
int siz[maxn], col[maxn];
int n, m, a, b, c, x, y, P;
bool vis[maxn], legSon[maxn];
std::vector&lt;int&gt; w[maxn], g[maxn];
void DFS(int x, int fa) &#123;
    bool flag = 1;
    vis[x] = 1, siz[x] = 1;
    for (auto i : w[x]) &#123;
        if (vis[i]) continue;
        DFS(i, x);
        if (siz[i] &gt; n / 2) flag = 0;
        siz[x] += siz[i];
        g[x].push_back(i);
    &#125;
    if (n - siz[x] &gt; n / 2) flag = 0;
    if (flag &amp;&amp; !P) &#123;
        P = x, faP = fa;
        if (n - siz[x] &gt;= a)
            solFlag = fa;
        else &#123;
            for (auto i : g[x]) &#123;
                if (siz[i] &gt;= a) &#123;
                    solFlag = i;
                    break;
                &#125;
            &#125;
        &#125;
    &#125;
    return;
&#125;
void fillA(int x) &#123;
    if (a == 0) return;
    col[x] = 1, --a;
    for (auto i : g[x]) fillA(i);
    return;
&#125;
void fillB(int x) &#123;
    if (b == 0) return;
    col[x] = 2, --b;
    for (auto i : g[x]) &#123;
        if (x == P &amp;&amp; i == solFlag)
            continue;
        fillB(i);
    &#125;
    return;
&#125;
void fillC(void) &#123;
    for (int i = 1; i &lt;= n; ++i)
        if (!col[i]) col[i] = 3;
    return;
&#125;
void DFS1(int x) &#123;
    if (!a || x == P) return;
    col[x] = 1, --a;
    for (auto i : g[x]) DFS1(i);
    return;
&#125;
void DFS2(int x) &#123;
    if (b == 0) return;
    if (!col[x]) col[x] = 2, --b;
    for (auto i : g[x]) DFS2(i);
    return;
&#125;
void func(void) &#123;
    int pos[5] = &#123;&#125;;
    if (a &gt;= b &amp;&amp; b &gt;= c) // cba
        org[1] = 3, org[2] = 2, org[3] = 1;
    else if (a &gt;= b &amp;&amp; a &gt;= c) // bca
        org[1] = 2, org[2] = 3, org[3] = 1;
    else if (a &gt;= b) // bac
        org[1] = 2, org[2] = 1, org[3] = 3;
    else if (c &gt;= b) // abc
        org[1] = 1, org[2] = 2, org[3] = 3;
    else if (c &gt;= a) // acb
        org[1] = 1, org[2] = 3, org[3] = 2;
    else // cab
        org[1] = 3, org[2] = 1, org[3] = 2;
    pos[1] = a, pos[2] = b, pos[3] = c;
    std::sort(pos + 1, pos + 4);
    a = pos[1], b = pos[2], c = pos[3];
    return;
&#125;
void ADD(int x) &#123; // 判断儿子是否合法 
    if (x == P)
        return;
    book[x] = 1;
    for (auto i : w[x]) &#123;
        if (i == P &amp;&amp; x != faP) legSon[x] = 1;
        if (!book[i]) ADD(i);
    &#125;
    return;
&#125;
void DFS3(int x) &#123; // Sub2 染头上 
    if (!a || x == P) return;
    col[x] = 1, --a;
    for (auto i : g[x]) DFS3(i);
    return;
&#125;
void DFS4(int x) &#123; // Sub2 染儿子
    if (a == 0) return;
    col[x] = 1, --a;
    for (auto i : g[x]) DFS4(i);
    return;
&#125;
void DFS5(int x) &#123; // Sub2 染 B 色
    if (b == 0) return;
    col[x] = 2, --b;
    for (auto i : g[x]) &#123;
        // 如果子树加入了 A
        // 那么起码子树的根是会被染的。 
        if (col[i]) continue;
        DFS5(i);
    &#125;
    return;
&#125;
int main() &#123;
    read(n), read(m);
    read(a), read(b), read(c), func();
    while (m--) &#123;
        read(x), read(y), ++x, ++y;
        w[x].push_back(y), w[y].push_back(x);
    &#125;
    DFS(1, -1);
    if (solFlag) &#123;
        if (solFlag == faP) DFS1(1), DFS2(P);
        else fillA(solFlag), fillB(1);
        fillC();
    &#125;
    else &#123;
        ADD(1), sumFa = n - siz[P];
        auto now = g[P].begin(), ex = now;
        while (sumFa &lt; a) &#123;
            while (now != g[P].end() &amp;&amp; !legSon[*now]) ++now;
            if (now == g[P].end()) goto noSol;
            sumFa += siz[*(ex = now++)];
        &#125;
        auto pos = g[P].begin();
        DFS3(1);
        for (;; ++pos) &#123;
            if (!legSon[*pos]) continue;
            DFS4(*pos);
            if (pos == ex) break;
        &#125;
        DFS5(P), fillC();
    &#125;
    noSol: ;
    for (int i = 1; i &lt;= n; ++i) &#123;
    #ifdef ONLINE_JUDGE
        print(org[col[i]], &#39; &#39;);
    #else
        print(col[i], &#39; &#39;);
    #endif
    &#125;
    putchar(&#39;\n&#39;);
    return 0;
&#125;
&#125; // namespace XSC062
int main() &#123;
    XSC062::main();
    return 0;
&#125;


F - Strange Housing
https://vjudge.net/contest/585791#problem/F
是难得一见的小清新题目（经历过前两题的洗礼之后）。
我们从原图中抽一个生成树出来，比如 DFS 树。
然后我们又知道树是连通二分图，所以我们按照二分图来染色就可以了。
但这么做有个 bug，就是树里有返祖边，这就可能会导致二分图的一个部分里出现在原图中相连的点。
所以我们可以换一种思考方式，把二分图的染色方法带到原图里。
一个点当且仅当周围有染色点或自身为染色点时是可达的。
对于一个点，我们先检查其周围一圈有没有染色点；如果有就不能染色。在 DFS 遍历的时候直接染色即可。

namespace XSC062 &#123;
using namespace fastIO;
const int maxn = 3e5 + 5;
int col[maxn];
bool vis[maxn];
int T, n, m, x, y, cnt;
std::vector&lt;int&gt; g[maxn];
void DFS(int x) &#123;
    vis[x] = 1;
    for (auto i : g[x]) &#123;
        if (col[i] == 1) &#123;
            col[x] = 0;
            break;
        &#125;
    &#125;
    if (col[x] == -1)
        ++cnt, col[x] = 1;
    for (auto i : g[x]) &#123;
        if (vis[i]) continue;
        if (col[x] == 1) col[i] = 0;
        DFS(i);
    &#125;
    return;
&#125;
void add(int x, int y) &#123;
    g[x].push_back(y);
    return;
&#125;
int main() &#123;
    read(T);
    while (T--) &#123;
        read(n), read(m);
        for (int i = 1; i &lt;= n; ++i) &#123;
            g[i].clear();
            g[i].shrink_to_fit();
            vis[i] = 0, col[i] = -1;
        &#125;
        while (m--) &#123;
            read(x), read(y);
            add(x, y), add(y, x);
        &#125;
        cnt = 0, DFS(1);
        for (int i = 2; i &lt;= n; ++i) &#123;
            if (!vis[i]) &#123;
                puts(&quot;NO&quot;);
                goto noSol;
            &#125;
        &#125;
        puts(&quot;YES&quot;), print(cnt, &#39;\n&#39;);
        for (int i = 1; i &lt;= n; ++i) &#123;
            if (col[i] == 1)
                print(i, &#39; &#39;);
        &#125;
        putchar(&#39;\n&#39;);
        noSol: ;
    &#125;
    return 0;
&#125;
&#125; // namespace XSC062

]]></content>
      <tags>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title>杂题选谈</title>
    <url>/20231113/</url>
    <content><![CDATA[NOIP S &amp; 计数杂题。


A. 卡门
https://www.luogu.com.cn/problem/P6370
https://www.becoder.com.cn/contest/4434/problem/1
我们惊讶地发现全场没多少人会做绿题。

就是说呢，我们把它「滚动到相邻行然后落下」的过程直接变成「往左下 / 右下滚」。那么球掉下去的过程呢，就可以理解为它是一直一次往下掉一格的，然后每一次掉落呢，会根据实际情况往左 / 往右 / 直着掉。
所以我们可以直接用 \(m\) 个长度为 \(n\) 的序列，记录从每 \(1\sim m\) 列扔下去的情况。然后我们很容易可以知道，如果任意两个序列发生了交汇，那么从交汇点开始至序列结束呢，这两个序列的内容都是完全一样的。因为之前序列长什么样子，完全不会对之后产生影响。所以一旦有任意一个状态是一样的，后面都会是一样的。
所以呢，一旦我们跟着计划好的路线走，却发现走不动了，那就说明从走不动的位置开始，到原定路线结束，这些位置都会被封掉。所以这个时候我们直接重新计算路线就好了。
对于这 \(m\) 列，就算每一列预定路线上的每个位置都被占了一次，也只会被更改 \(n\times m\) 次；总体时间复杂度只有 \(O(nm^2)\)。然后又由于不可能跑满，其实是完全没有问题，甚至跑得出溜快的。

namespace XSC062 &#123;
using namespace fastIO;
const int maxm = 35;
const int maxn = 3e4 + 5;
char a[maxn][maxm];
int n, m, q, u, x, y;
std::vector&lt;int&gt; p[maxm]; 
int main() &#123;
#ifdef ONLINE_JUDGE
    freopen(&quot;kamen.in&quot;, &quot;r&quot;, stdin);
    freopen(&quot;kamen.out&quot;, &quot;w&quot;, stdout);
#endif
    scanf(&quot;%d %d&quot;, &amp;n, &amp;m);
    for (int i = 1; i &lt;= n; ++i)
        scanf(&quot;%s&quot;, a[i] + 1);
    for (int i = 1; i &lt;= m; ++i) &#123;
        x = 1, y = i;
        for (;;) &#123;
            p[i].push_back(y); 
            if (a[x + 1][y] == &#39;.&#39;) ++x;
            else &#123;
                if (a[x + 1][y] == &#39;X&#39;) break;
                if (a[x][y - 1] == &#39;.&#39; &amp;&amp; a[x + 1][y - 1] == &#39;.&#39;)
                    ++x, --y;
                else if (a[x][y + 1] == &#39;.&#39; &amp;&amp; a[x + 1][y + 1] == &#39;.&#39;)
                    ++x, ++y;
                else break;
            &#125;
        &#125;
    &#125;
    scanf(&quot;%d&quot;, &amp;q);
    while (q--) &#123;
        scanf(&quot;%d&quot;, &amp;u);
        while (a[p[u].size()][p[u].back()] != &#39;.&#39;)
            p[u].pop_back();
        x = p[u].size(), y = p[u].back();
        for (;;) &#123;
            p[u].push_back(y); 
            if (a[x + 1][y] == &#39;.&#39;) ++x;
            else &#123;
                if (a[x + 1][y] == &#39;X&#39;) break;
                if (a[x][y - 1] == &#39;.&#39; &amp;&amp; a[x + 1][y - 1] == &#39;.&#39;)
                    ++x, --y;
                else if (a[x][y + 1] == &#39;.&#39; &amp;&amp; a[x + 1][y + 1] == &#39;.&#39;)
                    ++x, ++y;
                else break;
            &#125;
        &#125;
        a[x][y] = &#39;O&#39;;
    &#125;
    for (int i = 1; i &lt;= n; ++i) puts(a[i] + 1);
    return 0;
&#125;
&#125; // namespace XSC062


B. 商人
https://www.becoder.com.cn/contest/4434/problem/2
首先忽略图中的环带来的问题，假设 \(f_u\) 表示从 \(u\) 点出发的答案，不难想到 DP 式 \(f_u = \min\{\max(f_v-p_{(u,v)}, r_{(u,v)})\}\)。
那么问题来了，图中是会有环的，不能简单地去更新 DP 值。我们首先考虑「根源」，每一个 \(f_u\) 一定都是由另一个 \(f_v\) 转移得到的，那么一定会存在一个已知的 \(f_u\)，不由其他任何 \(f_v\) 得到。
考虑一个环中 \(r\) 最大的一条边 \((u,v)\)。假设图中只有这一个环，那么 \(f_u\) 的值一定为 \(r\)，因为 \(p\) 只能为非负。这样「根源」就被我们找到了。接下来进一步考虑转移方法。
一个点 \(u\) 只能被其相连的点 \(v\) 更新，那么当且仅当所有 \(f_v\) 都是确定的，\(f_u\) 才能被确定，进而去更新 \(u\) 的前驱。这让我们想到了拓扑排序。如果我们将所有边反向，那么上面的过程几乎就是拓扑排序。
为了保证任意一个环上的「根源」都能最先被确定，我们按照按 \(r\) 从大到小遍历每一条边的方式处理问题。对于每一条边 \((u,v)\)，我们都假设它是「根源」并用 \(r_{(u,v)}\) 更新 \(f_u\)。我们其实并不关心 \(u\) 是否是我们刚刚定义的形式上的「根源」，毕竟，只要 \(f_u\) 能被 \(r_{(u,v)}\) 更新，它就能算作广义上的，当前时刻的「根源」。
我们在一开始将出度为 \(0\)（反图上就是入度为 \(0\)）的点全部加入队列，在每次加边的时候进行拓扑排序。每次一条边以任意形式被「使用」后，都要打标记删除并不能再访问，以保证转移的正确性和高效。如果一条边被「使用」，分两种情况：

更新「根源」：
这个时候这条边已经发挥了它的所有作用了，作为 当前时刻的「根源」，这条边的源点在未来至少不会再经由这一条边被更新。故可以删除。
拓扑排序中转移：
一个点被加入队列，说明它的 DP 值是确定的，那么就不用拿一个已经确定的值多次更新另一个 DP 值。故可以删除。

所以正确性是可以保证的。类拓扑排序的结构也保证了算法复杂度 \(O(n+m)\)。

#define int long long
namespace XSC062 &#123;
using namespace fastIO;
const int inf = 1e18;
const int maxn = 2e5 + 5;
const int maxm = 2e5 + 5;
struct _ &#123;
    int v, r, p, i;
    _() &#123;&#125;
    _(int v1, int r1, int p1, int i1) &#123;
        v = v1, r = r1, p = p1, i = i1;
    &#125;
&#125;;
struct __ &#123;
    int x, y, r, p;
    bool operator&lt; (const __ &amp;q) const &#123;
        return r &gt; q.r;
    &#125;
&#125;;
__ a[maxm];
bool del[maxn];
std::queue&lt;int&gt; q;
int n, m, x, y, r, p;
std::vector&lt;_&gt; g[maxn];
int f[maxn], deg[maxn];
int max(int x, int y) &#123; return x &gt; y ? x : y; &#125;
int min(int x, int y) &#123; return x &lt; y ? x : y; &#125;
void add(int x, int y, int r, int p, int i) &#123;
    g[x].emplace_back(y, r, p, i);
    return;
&#125;
int main() &#123;
#ifdef ONLINE_JUDGE
    freopen(&quot;merchant.in&quot;, &quot;r&quot;, stdin);
    freopen(&quot;merchant.out&quot;, &quot;w&quot;, stdout);
#endif
    read(n), read(m);
    std::fill(f + 1, f + n + 1, inf);
    for (int i = 1; i &lt;= m; ++i) &#123;
        read(a[i].x), read(a[i].y);
        read(a[i].r), read(a[i].p);
        ++deg[a[i].x];
    &#125;
    std::sort(a + 1, a + m + 1);
    for (int i = 1; i &lt;= n; ++i)
        if (!deg[i]) q.push(i);
    for (int i = 1; i &lt;= m; ++i)
        add(a[i].y, a[i].x, a[i].r, a[i].p, i);
    for (int i = 1; i &lt;= m; ++i) &#123;
        while (!q.empty()) &#123;
            int t = q.front(); q.pop();
            for (auto j : g[t]) &#123;
                if (del[j.i]) continue;
                del[j.i] = 1;
                if (f[t] != inf)
                    f[j.v] = min(f[j.v], max(f[t] - j.p, j.r));
                if (!--deg[j.v]) q.push(j.v);
            &#125;
        &#125;
        if (!del[i]) &#123;
            del[i] = 1, f[a[i].x] = min(f[a[i].x], a[i].r);
            if (!--deg[a[i].x]) q.push(a[i].x);
        &#125;
    &#125;
    for (int i = 1; i &lt;= n; ++i)
        print(f[i] == inf ? -1 : f[i], &#39; &#39;);
    putchar(&#39;\n&#39;);
    return 0;
&#125;
&#125; // namespace XSC062
#undef int


A - Gerald and Giant Chess
https://vjudge.net/contest/594162#problem/A
这个呢，一道简单的数数题，但是因为我忘了 DP 容斥怎么打了所以自行思考了很久很久很久，还差最后一点点想出来的时候放弃了去抄题解 /cf
就是，这种「限制通行」的 DP 容斥（名字是我现场起的）类型的数数题有一种通法，就是首先我们只计算非法方案然后减掉。
那么非法方案怎么算呢？令 \(f_i\) 表示一个非法点都不经过，到达 \(i\) 这个非法点的方案数，那么有 \(f_i=calc(s,i)-\sum f_j\times calc(j,i)\)，其中 \(s\) 是起点，\(calc(j,i)\) 是从 \(j\to i\) 的方案数。这样就能不重不漏地枚举完所有情况了。
我们把 \((n,m)\) 也视作一个非法点然后代入 DP 即可得到答案。

#define int long long
namespace XSC062 &#123;
using namespace fastIO;
const int lim = 3e5;
const int mod = 1e9 + 7;
const int maxk = 2e3 + 5;
const int maxn = 3e5 + 5;
struct _ &#123;
    int x, y;
    bool operator&lt; (const _ &amp;q) const &#123;
        return x == q.x ? y &lt; q.y : x &lt; q.x;
    &#125;
&#125;;
_ a[maxk];
int n, m, k, res; 
int f[maxk], fac[maxn];
int qkp(int x, int y) &#123;
    int res = 1;
    while (y) &#123;
        if (y &amp; 1) (res *= x) %= mod;
        (x *= x) %= mod, y &gt;&gt;= 1;
    &#125;
    return res;
&#125;
int inv(int x) &#123; return qkp(x, mod - 2); &#125;
int A(int n, int m) &#123;
    return fac[n] * inv(fac[n - m]) % mod;
&#125;
int C(int n, int m) &#123;
    return A(n, m) * inv(fac[m]) % mod;
&#125;
int calc(int i, int j) &#123;
    int x = a[j].x - a[i].x + 1,
        y = a[j].y - a[i].y + 1;
    return C(x + y - 2, y - 1);
&#125;
int main() &#123;
    fac[0] = 1;
    for (int i = 1; i &lt;= lim; ++i)
        fac[i] = fac[i - 1] * i % mod;
    bool flag = 0;
    read(n), read(m), read(k);
    for (int i = 1; i &lt;= k; ++i) &#123;
        read(a[i].x), read(a[i].y);
        flag |= (a[i].x == 1 &amp;&amp; a[i].y == 1);
        flag |= (a[i].x == n &amp;&amp; a[i].y == m);
    &#125;
    a[0].x = a[0].y = 1;
    if (flag) &#123; print(0, &#39;\n&#39;); return 0; &#125;
    ++k, a[k].x = n, a[k].y = m;
    std::sort(a + 1, a + k + 1);
    for (int i = 1; i &lt;= k; ++i) &#123;
        f[i] = calc(0, i);
        for (int j = 1; j &lt; i; ++j) &#123;
            if (a[j].x &gt; a[i].x || a[j].y &gt; a[i].y) continue;
            (f[i] -= f[j] * calc(j, i) % mod) %= mod;
        &#125;
    &#125;
    f[k] = (f[k] % mod + mod) % mod;
    print(f[k], &#39;\n&#39;);
    return 0;
&#125;
&#125; // namespace XSC062
#undef int

]]></content>
      <tags>
        <tag>Tarjan</tag>
      </tags>
  </entry>
  <entry>
    <title>TRICKS</title>
    <url>/20231117/</url>
    <content><![CDATA[想着写点什么东西，就是说，不会被归入知识点（upd：并非不会），却又感觉很常用（upd：并非常用）的东西。
哦我懂了，通常来说我们管这个叫 trick。


DS

容易记错的操作复杂度：

线段树建树：\(O(n)\)。
线段树合并：单次线段树合并复杂度为新建的点数。均摊单次 \(O(\log n)\)。
两颗满的线段树合并复杂度为 \(O(n)\)，故 DSU on tree + 线段树合并的复杂度为 \(O(n\log n)\)，且显然跑不满。
FHQ Treap 建树：视作笛卡尔树，\(O(n)\)。
动态开店线段树单次访问至多增加 \(4\log\) 个点，e.g. \([2,n-1]\)。



随机序列的笛卡尔树：
是 Treap。


有『合并』功能的 DS：
并查集，线段树，字典树，笛卡尔树，BST。


复杂度依赖『均摊』的 DS：
并查集，线段树 / 字典树合并。
不强制在线 复杂度不依赖均摊 的可持久化数据结构 \(\to\) DAG 上直接模拟。


部分可持久化：
只要求『在最新版本上修改』和『查询所有版本』的可持久化数组可以在 vector 上二分，又唤部分可持久化。


字典树维护二进制操作：
字典树的节点 id 可视作对信息的引用，也即，如果在初次插入时记录了某个元素对应的 id，相当于获取了元素的引用。

单点修改：拿出来，修改，塞进去，单次修改 \(O(\log V)\)。
全局 xor：打懒标记，单次修改 \(O(1)\)。
全局 +1 / -1：字典树上信息必须从低位到高位存储。现场处理，（发现只会递归一条链），单次修改 \(O(\log V)\)。



线段树可维护的经典信息：

操作：插入 / 删除区间，询问：值域内未被覆盖的点的信息：
线段树维护节点内被覆盖次数最小值和最小值信息；当最小值为 \(0\) 时，将信息纳入统计。
扩：维护值域内恰好被区间覆盖 \(k\) 次的点的信息：线段树维护节点内前 \(k+1\) 小值的信息，则 \(k\) 一定出现在前 \(k+1\) 小值中。
线段树维护函数：如果对于任意区间，都能定义一个定义域为该区间的函数，可以线段树维护该函数。维护的总点数是 \(n\log n\) 的。



维护 \(\sum\limits_{i\in[L,R]}\sum\limits_{j\in[i,R]}\min\{a_{i\sim j}\}\)：
考虑单调栈，则只需做 \(O(n)\) 次区间修改。
goto CF2009G3。


数学


常见数据对应的数列：

\(\{1,1,2,3,5,8,\cdots\}\) 是斐波那契；矩阵可以优化；生成函数可以找通项；\(f_i=\sum\limits_{i=0}^nC_n-i^i\)。
\(\{1, 1, 2, 5, 14\cdots\}\) 是 Catalan，走网格不能穿过对角线 / 构造二叉树方案数 / 一群人买电影票。有组合求法 \({2n\choose n} - {2n \choose n - 1}\)；生成函数还是可以找通项；
\(\{3, 7, 6, 15, 25, 10, 31, 90, 65, 15, 63, 301, 350, 140, 21, 127, 966,\cdots\}\)，中间插着一堆 \(1\)，是展开了的第二类斯特林数三角形，把 \(n\) 个不同球，不空放，放到 \(k\) 个相同盒子的方案数，有递推式 \(S(n,k)=S(n-1,k-1)+k\cdot S(n-1,k)\) 和二项式反演出来的通项 \(S(n,m)=\sum\limits_{i=0}^m\dfrac {(-1)^{m-i}\cdot i^n}{i!\cdot (m-i)!}\)。多项式可以 \(n\log\) 算同一行 / 列，方法不太一样。



\(n\) 被取模后的组合数：
将原式展开，\(\binom nm=\frac 1{m!} \prod\limits_{i=0}^{m-1} (n-i)\)，容易发现 \(n\) 取模是没有影响的，如果模数很小则可以预处理模数范围内的阶乘，如果 \(m\) 很小则可以每次 \(O(m)\) 现算。
同理可以发现 \(m\) 是不能直接取模的，如果需要给 \(m\) 取模就只能用 Lucas。


\(O(V\log V)\) 求数的因数：
假设 \(n=V=5\times 10^6\)，那么对于每个数暴力分解就是 \(O(n\sqrt V)\) 的，无法通过。
埃筛预处理，存储每个数的所有因数就可以 \(O(V\log V)\) 求了。


求线段穿过直线系的次数：
求线段 \((x_1,y_1,x_2,y_2)\) 穿过直线系 \(x+y=k\cdots m(k\in \mathbb{N}^*)\) 的次数算出线段中 \(x+y\) 的取值范围也即 \([x_1+y_1,x_2+y_2]\)（斜率为负就不同了，但可以证明都是单调的），求出 \(k\cdot m\) 在里面的出现次数就可以了。有的人高中数学欠的债要到竞赛来还
goto CF2098E。


模数非质数时求多重集组合：
杨辉三角求组合数，答案为：
\[
\prod_{i=1}^m \binom{\sum_{j=i}^m s_j}{s_i}
\]
goto ABC425E。


图论

\(m-n\) 很小带来的隐含条件
DFS 树的反祖边很少，可以基于这一点想一些比较暴力的做法。
goto solu to Count Simple Paths 2。

经典建模

左部点度数为 \(2\) 的二分图匹配：
一系列元素，每个元素有不超过两种可选值，要求最终每个元素值不同，求方案数。
对所有可选值建图。如果只有一个可选值，看作两种可选值相同，连自环；否则把两个可选值连边。此时一个元素对应一条边，即对于每条边选一个端点，满足每个端点被选最多一次。
对于所有连通块：

若 \(n&gt;m+1\)： 没有这种可能性（不连通）。
若 \(n=m+1\)，即该连通块为树，任选一个点不选都能唯一构成一组解，方案数为 \(n\)。
若 \(n=m\)，即形成基环树：
由于环上点只能且必须被环上边选，树上边的选法唯一。主要讨论环边选法。

若环为自环，答案为 \(1\)；
否则枚举环上所有边是统一选顺 / 逆时针方向的端点，答案为 \(2\)。

若 \(n&lt;m\)：
点不够用，答案为 \(0\)。

最后把所有连通块的答案相乘就可以得到总答案。
goto Ball, Baggage Claim, Must be Distinct!。


凸多边形三角剖分转化为树上问题：
结论：若把三角形视作 \(n-2\) 个点，在有公共边的三角形之间连边可以得到树。
证明：有 \(n-3\) 条边，显然每条边都被两个三角形共用；至于为什么是 \(n-2\) 个三角形请移步计几。
生成方法：易发现肯定存在 \(\ge 2\) 个顶点不被任何对角线经过（其属于一个叶子三角形），其度数为 \(2\)；用类似拓扑排序的方式，不断切下叶子三角形并寻找新的叶子三角形，就可以找到所有点。注意到对角线就是树边，记录每条对角线两侧的三角形，连边即可。
goto solu to Distance on Triangulation。

优化建图

前缀和优化建图：
要求每条边都指向某个前缀区间；与线段树优化建图相比的优势是虚点、边数均为 \(O(n)\)。
Goto solu to 喝醉的兔子。

图上 DP

有环图的 DP 顺序：
有环图上的 DP，通常来说可以根据状态转移方程的形式找到环上的「根源」，即不由任何环上节点转移得到。
无视根源在环上的前驱边就可以用类拓扑的方式转移。
Goto solu to 商人。

树的直径，图的直径

半径与中点的定义：

半径：图 / 树的半径（数值上为 \(\min\limits_x\{\max\limits_y dis(x, y)\}\)）的一端一定在直径上，且在直径中间。如果不带权的话就是直径长度的一半 不然为啥叫半径。
中点：半径在直径上的端点，有一个（直径为奇）或两个（直径为偶），均满足到所有点的距离不超过半径。



直径的性质：

图的直径的性质：

不能用两次 BFS 求，原因：图不满足『距离任意点最远的点都是直径的一个端点』这条贪心性质。
设图的直径为 \(d\)，对于任意点 \(x\)，其和其他点最短路的最大值 \(s\) 满足：
\[
\left\lceil \dfrac d2\right\rceil \le s\le d
\]
等价形式：\(d\in[s, 2s]\)。
证明：上界显然；对于下界，取图中心 \(m\)，对任意 \(x\) 找到距其最远的点 \(y\)。由松弛，显然有 \(d(x,y)\le d(x,m)+d(y,m)\)。又 \(d(x,m),d(y,m)\le r\)，故 \(d(x,y)\le 2r\)，也即 \(d\ge d(x,y)\)。

树的直径的性质：

树的所有直径交于树的所有中点（参考半径，如果长度为偶数就是两个点）；
向树中加一个叶子，最多改变直径的一个端点。
距离任意点最远的点都是直径的一个端点。




半径的性质 / 离树上某点最远的点：
将中心边（若有两条任选一条）提出来，让两侧的点作为根；

对于一个点 \(u\)，离它最远的点一定在另一棵树中最深的位置。


动态维护树的直径：
如果知道一个连通块内的直径是 \(x\to y\)，另一个是 \(a\to b\)，那么两个合并起来的直径一定是 \(\{x,y,a,b\}\) 里的 \(C_4^2\)。
线段树维护一段连续欧拉序内（不用 DFS 序是为了保证联通）的直径和两个端点，就能解决动态加点一类问题。

树上问题

树上路径问题的解决思路：

静态问题：

不要求方向且能预处理：树上差分。
要求方向且能预处理：倍增、树剖（多一个 log 但跑不满；综合来看慢一些）。
注意这里的倍增如果要维护信息，一定是一个左闭右开的形式，可以少很多麻烦。
离线、要求方向且不能预处理：
把询问挂在 \(u\) 和 LCA 上，第一遍 DFS 把 \(u\to\) LCA 的答案计算出来（需要可合并信息），第二遍 DFS 利用回溯把 LCA \(\to v\) 的答案计算出来。
goto solu to 记忆。

动态问题：树剖。



DP

轮廓线 DP / 逐格状压 DP：
对于棋盘上的状压 DP，如果某格内容的限制只来自相邻的格子（这是大部分棋盘问题能够满足的），可以考虑轮廓线 DP。
具体来说，按照通常的从上到下、从左到右 DP 的思路，对于某一格，发现影响到它的只有左侧和上方的状态；这时我们通常会保存上一行所有状态，但发现左上侧格子及以前的状态是无用的，反而左边的状态是有用的。故记录每一列最靠下的已确定状态，就可以完成 DP。
goto solu to Count Grid 3-coloring，solu to 123 Set。
对于 \(2\times 1\) 骨牌放置问题，可以设『上半片』为 1，其余为 0，对于横向骨牌逐二格确定。这样就能发现，轮廓线 DP 并不一定只有在左侧有限制的时候才能用，因为记录左侧状态也是在完成状态的转移。


『贡献』的思想：
用乘法分配率将式子拆开，即『分类』，这时可能会发现『分步』这一步比原来更好做。
更具象地，对于『分步』中的某一步，将『类别』的全集划分为若干个子集，发现除此之外的部分可能可以更方便地计算。如果能找到这样一种简单的均裂或异裂的方式，使得每一『类』的『单步』价值能够确定，就能考虑用『贡献』计算。
特别地，对于一个子集，如果其他步骤对它的价值没有影响，其贡献往往会表现为幂次形式。
Goto solu to One to One，solu to 彩灯晚会


想要筛选出特定一『类』的状态 / 不同『分类』对应不同『分步』时的处理方法：
如果类别比较少，将类别放到维度里（例：如果存在二进制运算则可以拆位，则类别为 0/1 两类），分别处理。
看起来很显然，但确实是很多状态设计的难点。


多重集的组合数
主要要求能够认识到正在应用该模型。
当 \(n,m\) 很小而 \(c_i\) 很大时：

朴素地，设 \(f_{i,j}\) 表示在 \(i\) 处填了 \(\le j\) 的数（可以意识到需要前缀和），如果只关注当前位是不能做的，考虑枚举填了多少个 \(j\)，可以得到 \(f_{i,j}=\sum_k f_{i-k,j-1}\)。注意 \(k\) 可以取到 \(0\)，从数值上来看恰好是对的。
如果认为一个多重集中的元素是有差异的，还可以乘上 \(\binom {c_j}k\)。
如果保证 \(n\le c_i\)，且题目没有其他限制时，发现原问题等价于 \(x_1+x_2+\cdots +x_m=n\) 的非负整数解数目，插板法解决。
在上一种方式的基础上，如果没有了 \(n\le c_i\) 的限制，易发现容斥也是可行的。



与字典序有关的状态设计：
要求字典序大于 / 小于给定值的方案数，考虑使用 \(f_i\) 表示 \(1\sim i\) 全部和给定值相同，\(i+1\) 大于 / 小于给定值，后面无限制的情况总数。
Goto 冒泡排序。


计数 DP 和容斥的选择。
（容斥）碰到了「起点状态到终点状态，中间不能经过一些非法状态的方案数」，可以用 \(f_i\) 表示从起点，不经过 \(1\sim i-1\) 的非法状态，到达非法状态 \(i\) 的方案数，最后将终点状态也视为一个非法状态并 DP 即可。
Goto solu to Gerald and Giant Chess，solu to 两双手。
求方案数，如果用通常的「考虑满足条件的情况并转移」，就必须能够简单地对条件进行判定。
如果这一点做不到，可以考虑从最简单或最极限情况出发充要且不重地 构造 出一般情况，并计算相应的方案数。
goto solu to 染色。
如果有转移会有后效性不妨考虑是否有前效性然后逆序 DP。
例如求字典序最小的答案：只知道最后一个字符不能推断出谁的字典序最小。但如果知道最开头一个字符，并保证从后往前填表的每一步都走的最小就能够确定。
goto solu to 匹配数

状态拆分技巧。比如状态 ABC 不一定要从状态 A、状态 B、状态 C 分别 \(O(m)\) 的转移，而可以从 A 和 BC 以 \(O(1)\) 完成转移。

Goto solu to 单词。

关于背包

子序列问题转化为背包问题：
子序列问题（不仅是 + &amp; min，也可以是 xor、加 &amp; 模等）可以转化为背包问题；对一个区间做背包，可以把区间划分成若干段，每段做背包，再依次 \(O(v^2)\) 地合并。
『划分』的一个典型场景是找『分割线』，然后向左向右分别做背包——这么做的优点是，对于任意穿这条分割线的区间，你都能 \(O(v^2)\) 得到所有的背包信息。甚至，如果你只需要求某个特定体积下的答案，只需要 \(O(v)\) 枚举。
upd：可以猫树
goto 贪玩蓝月。


离线背包结合分治：
背包可以看作一种 +/min 卷积：在体积维上做加法、在代价维上做 min。当然其他操作如体积维上的 xor、加模；代价维上的方案数都差不多。
因此，多次区间询问（离线）的背包可以结合分治——原因是从每个 \(l\) 开始做一次背包是不现实的，而我们发现分割线是可以共用的——分割线代表的背包信息也是可以共用的。
所以需要找到一种『找分割线』和『一条分割线求解的范围』的方法，使得规定复杂度内能够最大化利用『公共信息』。分治的（类线段树的）结构就是一种极好的方式，在一层分治内解决所有在 \([l,r]\) 范围内，且跨越 \(mid\) 的询问，这样就能从 \(mid\) 出发，向左到 \(l\)，向右到 \(r\) 求解背包。
goto solu to CF2043F。


树上背包序列化：
注意到对于任何类型的背包，树结构复杂度不优于序列结构。仅有物品体积为 \(1\) 的 01 背包可以用技巧优化到相同复杂度。
利用 DFS 序进行填表，若不选某个点，相当于不选其引导的一整个子树 DFS 序区间。其余和序列背包一致。
Goto solu to Shopping。


随机序列的背包：
有结论：一个长度为 \(n\) 的 \(1/-1\) 随机序列的前缀和离 \(0\) 的距离期望不超过 \(\sqrt n\)。
拓展一下，在保证值域内分布均匀的整数域内背包，在 random_shuffle 后实际最大状态不太会超过 \(\sqrt V\)。
因为结论很松，所以运气比较好的时候甚至不会超过 \(\log V\)。


哈希

哈希中全等条件的应用 / 哈希与前缀信息的关联：
有的区间问题的判定条件可以转化为部分前缀信息的全等。
例：要求区间内每个数出现次数为 \(3\) 的倍数，转化为：令 \(cnt_{i,j}\) 表示前 \(i\) 个数中 \(j\) 出现次数 \(\bmod3\) 的值，则要求左右端点该值全等。
Goto Three Occurrences。


xor hash：
使用于异或判断次数奇偶性 / 元素存在性的哈希。
区间里每个值出现次数都是偶数的必要条件是区间异或起来为 \(0\)。该结论不充分：\(1\oplus 2\oplus 3=0\)。
把每个数都哈希成一个随机大数（比如 ull），冲突的概率就会变成 \(2^{-64}\)。
Goto NOI2024 D1T1，solu to 博弈。


字符串

对于相邻 00 或 01 的操作，考虑奇数位 flip
这样可以让操作呈现出一些更好处理的性质，往往表现为：可以忽略 \(a_i=a_{i+1}\) 的前提，得到一个适用于所有情况的新操作。
goto solu to LEGOndary Grandmaster，solu to 字符串转换，QOJ#9565. Birthday Gift。


关于最值

求某下标在序列所有的 LIS 中出现次数：
分别统计以其结尾和开头的 LIS 长度与次数，如果加起来是序列 LIS 的长度，那么次数相乘就是答案。


关于冒泡排序：

反序表：
令 \(f_i\) 表示以 \(i\) 结尾的逆序对数，那么对一个序列排序，需要的最少冒泡轮数为 \(\max\{f_i\}\)。
goto solu to 排序。
一轮冒泡排序做的事情：将序列按前缀最大值为段首划分为若干段，并把其移到段末。
goto 1 Loop Bubble Sort。
前缀最大值在一轮冒泡排序后仍是前缀最大值。


杂项

常用低复杂度库函数 / 比手写复杂度更低的库函数：

__builtin_clz / __builtin_ctz：统计二进制开头 / 末尾 \(0\) 的个数，通常是硬件指令，硬件不支持则会采用掩码 \(O(1)\) 得到结果。
__builtin_popcount：同上。
sqrt：争议很大，但事实是对于所有数据最多迭代 \(6\) 次，实际表现接近单次浮点乘法操作，故为 \(O(1)\)。
此处值得说明的是，&lt;cmath&gt; 中的对数函数同样为常数复杂度，但被观测到实际表现时常数较大，跑 1e6 次就已经很危险了。
如果需要对 \(2\) 取对数，使用 std::__lg 代替（其实现为 31 - __builtin_clz(x)）。
std::nth_element：可以 \(O(n)\) 找到第 \(k\) 大元素（放在第 \(k\) 位），并将原数组部分重排，使得前 \(k-1\) 为均比第 \(k\) 位小，后 \(n-k\) 位均比第 \(k\) 位大。
所以实际功能其实是 \(O(n)\) 找到前 \(k\) 大元素。因为平常提到 rank 都喜欢用 \(k\) 来叙述，所以函数名经常被误记为 kth。



随机序列跳悬线 / 悬线结合分块：
随机序列的笛卡尔树深度为 \(\log\)；令块长为 \(B=\sqrt {\log n}\)，维护每个点跳 \(B\) 步的答案；那么就能 \(O(\sqrt {\log n})\) 跳悬线。


摩尔投票：
设元素总数为 \(k\cdot n\)，则『将元素划分为 \(n\) 个 \(k\) 元组，满足每个 \(k\) 元组中不存在相同元素』等价于『出现次数最多的元素出现次数不超过 \(k\)』。
思路是让出现次数最多的元素（动态的）和其他元素抵消。
应用：

\(k=2\)，则这样的元素最多只有一个。
goto ARC205D，ABC362F。
求众数。



撤销思想：
当题目给出『按一定的操作序列，将整块逐步分解为小段，问至晚哪一步后满足条件（需要单调性）』，可以考虑从最后的局面开始考虑，逐步『合并』，并 check 最早合并到哪一步时满足条件。
Goto solu to CF567D


『连续数子段』的转化：
对于 \(i\in (l,r],\)a_i=a_{i-1}+1$ 式的『连续数子段』，令 \(a_i\gets a_i-i\)，则全部变为同一个数。
goto CF2009G3。


双栈模拟双端队列：

用两个栈模拟队列或双端队列。支持两头删除、插入。

一个维护前面的插入、删除；一个维护后面的插入、删除。插入是简单的；删除在大部分情况下是简单的；如果某个栈删空了，将另一个栈的一半挪过来暴力重构即可。均摊复杂度线性。
复杂度证明：设两栈长度分别为 \(L_1,L_2\)，定义势能 \(E=|L_1-L_2|\)。每次插入 / 简单删除带来 \(\pm 1\) 的势能变化；一次重构消耗 \(E\) 的势能，将势能重置为 \(E\le 1\)。显然就有均摊线性复杂度了。
适用场景：类队列 / 双端队列场景，但若固定一个端点就可以向左向右分别简单维护的；如背包等。
goto solu to 贪玩蓝月。


线段树维护括号序列：
每个节点维护左边


贪心选取括号序列：

给定 \(a_1\sim a_{2N}\)，选取一个合法的长度为 \(2N\) 的括号序列，记权值为所有 \((\) 所在位置的 \(a\) 值之和，最大化权值。

\(a_1\) 显然为 (，\(a_{2N}\) 显然为 )；
对于 \(a_2\sim a_{2N-1}\)，从前往后扫，每次把两个连续元素放在一起考虑，进行如下操作：

把这两个连续元素放到『可用来作 (』的队列里。
贪心地从队列里挑选 \(a\) 最大的元素，令其为 (。


正确性证明
即证：可构造出来的序列 \(\iff\) 合法的序列；构造出来的序列最优。

必要性：
我们知道，括号序列合法 \(\iff\) 对于任意 \(i\)，\(1\sim i\) 中的 ) 的数量不超过 (。
对于任意 \(i=2k+1\)，前 \(i\) 个元素中存在至少 \(k+1\) 个 (。且如果任意一步少选，序列不合法。
充分性：
也即在我们可以任意选择从队列中挑选哪个元素的情况下，证明任意目标序列都可以被这么构造。
每次选择目标序列最靠前的未被选的 ( 并将其选中。如果有一步不存在这样的位置怎么办？由『必要性』中粗体字得不合法。
最优性：
首先需要知道每个元素是否被选择是相对独立的。如果两个数都可被选，那么它们的选中状态是互不影响的（除非这是最后一个位置了，但显然这不是我们关注的重点）。
假设一个 \(a_i\) 位于最优解序列，但我们没有选择它：说明选中了一个比 \(a_i\) 更大的元素，可以构造出更优的序列。由此反证。


goto solu to abc407E。


切比雪夫距离：
\[
|PQ|=\max(|x_P-x_Q|,|y_P-y_Q|)
\]
将平面直角坐标系旋转 \(45^\circ\) 的坐标系中，两个点的切比雪夫距离是原坐标系中的曼哈顿距离。
做仿射变换（\((x+y,y-x)\) 之类，都行）即可得到新的坐标系。
可以用于棋盘题，用于把『距某点曼哈顿距离为 \(d\) 的点集』组成的斜向正方形变为正向的
或者一些数据结构题中，把式子中的 max 转写成 +，方便算贡献。

]]></content>
      <tags>
        <tag>下饭</tag>
      </tags>
  </entry>
  <entry>
    <title>解题报告：[SDOI2016] 游戏</title>
    <url>/20231230/</url>
    <content><![CDATA[可以看出来出题人很想出一道把李超和别的什么东西凑起来的题目，于是给了这么一个缝合怪。


https://www.luogu.com.cn/problem/P4069
符号有点混乱。比如箭头又可以表示路径又可以表示赋值，代入语境应该还是好理解的。

看到 \(a\times dis + b\) 就应激反应出来是李超了，看到 \(s\to t\) 又瞬间反应过来是树剖，但是树剖的 DFN 和 \(dis\) 没有直接关联，赛时想不到怎么做就跑路了。
实际上这个转化很板。因为这是条路径，我们还在树链上跳，每次跳过的一个链上的 DFN 是连续的，对应的 \(dis\) 也是连续的。
估计是打 T4 的子树问题打傻了，没想到这个。
所以我们就相当于是给一条重链上的某个连续区间加了一个斜率为 \(a\)，截距为 \(b\) 加上 一坨东西 的线段。用李超维护即可。

感觉讲的不清不楚的，那就再讲讲。
我们要让李超上任意一个点 \(u\) 代表的 \(x\) 是个定值。一坨东西 维护了这条线段相对于 \(s\) 的偏移量。令 \(r\gets \text{LCA of } s \text { and } t\)，\(R\) 表示整棵树的根，\(d(u,v)\gets \text {distance between } u \text { and } v\)。

对于 \(s\to r\) 上的每个点 \(u\)：
\[
\begin{aligned}
val_u&amp;=a\times d(s, u)+b\\
&amp;=a\times[d(s,R)-d(u,R)]+b\\
&amp;=-a\times d(u,R)+[a\times d(s,R)+b]
\end{aligned}
\] \(a\times d(s,R)+b\) 是和 \(u\) 无关的定值（这意味着可以在同一个询问的树剖时直接线段树），\(d(u,R)\) 是只和 \(u\) 相关的值（这意味着对于任意询问都成立）。令斜率为 \(-a\)，截距为 \(a\times d(s,R)+b\)，李超上任意点 \(u\) 代表 \(x\) 为 \(d(x,R)\)，维护如此一条线段即可。
对于 \(r\to t\) 上的每个点 \(v\)： \[
\begin{aligned}
val_v&amp;=a\times d(s,v)+b\\
&amp;= a\times [d(r,v)+d(s,r)]+b\\
&amp;=a\times [d(v,R)-d(r,R)+d(s,r)]+b\\
&amp;=a\times d(v,R)+[-a\times d(r,R)+a\times d(s,r)+b]
\end{aligned}
\] \(-a\times d(r,R)+a\times d(s,r)+b\) 是和 \(v\) 无关，只和询问中固定的 \(s,r,a,b\) 有关的定值；\(d(v,R)\) 是只和 \(v\) 相关的值且和上一个 case 里的 \(d(u,R)\) 同构，也用李超这么维护即可。

用李超维护把原问题转化为每次向若干重链上连续区间插入线段，求最低交点的问题。
注意到区间查询，李超需要加一个 pushup。具体怎么去操作呢？在加线段的时候除编号外新增一个变量维护当前区间内最低交点；我们就 pushup 这个东西。然后查询的时候就是在散区间的时候和原来一样查，整区间就在散区间答案的基础上再和当前区间的整体最低交点比一个 min。

#define int long long
namespace XSC062 &#123;
using namespace fastIO;
const int maxk = 25;
const int maxn = 1e6 + 5;
const int maxm = 1e6 + 5;
const int inf = 123456789123456789;
//#define DEBUG

#ifdef DEBUG
#define Z(x) x
#else
#define Z(x)
#endif
#define lt (p &lt;&lt; 1)
#define rt (lt | 1)
struct __ &#123; int k, b; &#125;;
struct _ &#123; int l, r, u, d; &#125;;
struct ____ &#123;
    int v, w;
    ____() &#123;&#125;
    ____(int v1, int w1) &#123;
        v = v1, w = w1; 
    &#125;
&#125;;
__ a[maxm];
_ t[maxn &lt;&lt; 2];
int tot, si, now;
int f[maxn][maxk];
int dis[maxn], dep[maxn];
int dfn[maxn], tab[maxn];
std::vector&lt;____&gt; g[maxn];
int n, m, ty, x, y, w, k, b;
int siz[maxn], top[maxn], son[maxn];
int max(int x, int y) &#123;
    return x &gt; y ? x : y;
&#125;
int min(int x, int y) &#123;
    return x &lt; y ? x : y;
&#125;
void swap(int &amp;x, int &amp;y) &#123;
    x ^= y ^= x ^= y;
    return;
&#125;
void DFS1(int x) &#123;
    siz[x] = 1;
    for (auto i : g[x]) &#123;
        if (i.v == f[x][0]) continue;
        f[i.v][0] = x;
        for (int j = 1; j &lt;= si; ++j)
            f[i.v][j] = f[f[i.v][j - 1]][j - 1];
        dep[i.v] = dep[x] + 1;
        dis[i.v] = dis[x] + i.w;
        DFS1(i.v);
        if (siz[i.v] &gt; siz[son[x]])
            son[x] = i.v;
        siz[x] += siz[i.v];
    &#125;
    return;
&#125;
void DFS2(int x, int t) &#123;
    top[x] = t;
    dfn[x] = ++now, tab[now] = x;
    if (son[x]) DFS2(son[x], t);
    for (auto i : g[x]) &#123;
        if (i.v == f[x][0] || i.v == son[x])
            continue;
        DFS2(i.v, i.v);
    &#125;
    return;
&#125;
void bld(int p, int l, int r) &#123;
    t[p].l = l, t[p].r = r, t[p].d = inf;
    if (l == r) return;
    int mid = (l + r) &gt;&gt; 1;
    bld(lt, l, mid), bld(rt, mid + 1, r);
    return;
&#125;
int getv(int id, int x) &#123;
    if (!id) return inf;
    Z(printf(&quot;get (%lld, %lld) = %lld\n&quot;,
        id, x, dis[tab[x]] * a[id].k + a[id].b));
    return dis[tab[x]] * a[id].k + a[id].b;
&#125;
void pushup(int p) &#123;
    if (t[p].l == t[p].r) return;
    t[p].d = min(t[p].d, min(t[lt].d, t[rt].d));
    Z(printf(&quot;[%lld, %lld]: pushup to %lld\n&quot;,
        t[p].l, t[p].r, t[p].d));
    return;
&#125;
void chg(int p, int id) &#123;
    t[p].u = id;
    Z(int tmp = t[p].d);
    t[p].d = min(getv(id, t[p].l),
                 getv(id, t[p].r));
    Z(printf(&quot;[%lld, %lld]: %lld -&gt; %lld\n&quot;,
                t[p].l, t[p].r, tmp, t[p].d)); 
    return;
&#125;
void upd(int p, int id) &#123;
    if (!t[p].u) &#123;
        chg(p, id), pushup(p);
        return;
    &#125;
    int mid = (t[p].l + t[p].r) &gt;&gt; 1;
    int v1 = getv(t[p].u, mid),
        v2 = getv(id, mid);
    if (v2 &lt; v1) swap(t[p].u, id);
    v1 = getv(t[p].u, t[p].l);
    v2 = getv(id, t[p].l);
    if (v2 &lt; v1) upd(lt, id);
    v1 = getv(t[p].u, t[p].r);
    v2 = getv(id, t[p].r);
    if (v2 &lt; v1) upd(rt, id);
    chg(p, t[p].u);
    pushup(p);
    return;
&#125;
void add(int p, int l, int r, int id) &#123;
    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r) &#123;
        upd(p, id);
        return;
    &#125;
    int mid = (t[p].l + t[p].r) &gt;&gt; 1;
    if (l &lt;= mid) add(lt, l, r, id);
    if (r &gt; mid) add(rt, l, r, id);
    pushup(p);
    return;
&#125;
int ask(int p, int l, int r) &#123;
    l = max(l, t[p].l);
    r = min(r, t[p].r);
    int res = min(getv(t[p].u, l),
                  getv(t[p].u, r));
    Z(printf(&quot;[%lld, %lld]: res = %lld\n&quot;,
        t[p].l, t[p].r, res));
    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r)
        return min(res, t[p].d);
    int mid = (t[p].l + t[p].r) &gt;&gt; 1;
    if (l &lt;= mid) res = min(res, ask(lt, l, r));
    if (r &gt; mid) res = min(res, ask(rt, l, r));
    Z(printf(&quot;[%lld, %lld]: res = %lld\n&quot;,
        t[p].l, t[p].r, res));
    return res;
&#125;
void add(int x, int y, int w) &#123;
    g[x].push_back(____(y, w));
    return;
&#125;
void ins(int l, int r, int k, int b) &#123;
    a[++tot].k = k, a[tot].b = b;
    add(1, l, r, tot);
    return;
&#125;
int getLCA(int x, int y) &#123;
    if (dep[x] &lt; dep[y]) swap(x, y);
    for (int i = si; ~i; --i) &#123;
        if (dep[f[x][i]] &gt;= dep[y])
            x = f[x][i];
    &#125;
    if (x == y) return x;
    for (int i = si; ~i; --i) &#123;
        if (f[x][i] != f[y][i])
            x = f[x][i], y = f[y][i];
    &#125;
    return f[x][0];
&#125;
void inst(int s, int t, int k, int b) &#123;
    int r = getLCA(s, t), u = s;
    while (top[u] != top[r]) &#123;
        ins(dfn[top[u]], dfn[u],
                    -k, k * dis[s] + b);
        u = f[top[u]][0];
    &#125;
    ins(dfn[r], dfn[u], -k, k * dis[s] + b);
    u = t;
    int d = dis[s] - dis[r];
    while (top[u] != top[r]) &#123;
        ins(dfn[top[u]], dfn[u],
                k, -k * dis[r] + k * d + b);
        u = f[top[u]][0];
    &#125;
    ins(dfn[r], dfn[u],
            k, -k * dis[r] + k * d + b);
    return;
&#125;
int qry(int x, int y) &#123;
    int res = inf;
    while (top[x] != top[y]) &#123;
        if (dep[top[x]] &lt; dep[top[y]])
            swap(x, y);
        Z(printf(&quot;ask %lld -&gt; %lld: %lld\n&quot;,
            x, top[x],
            ask(1, dfn[top[x]], dfn[x])));
        res = min(res,
            ask(1, dfn[top[x]], dfn[x]));
        x = f[top[x]][0];
    &#125;
    if (dep[x] &lt; dep[y]) swap(x, y);
    Z(printf(&quot;ask %lld -&gt; %lld: %lld\n&quot;,
        x, y, ask(1, dfn[y], dfn[x])));
    res = min(res, ask(1, dfn[y], dfn[x]));
    return res;
&#125;
int main() &#123;
//  freopen(&quot;game1.in&quot;, &quot;r&quot;, stdin);
    read(n), read(m);
    si = log(n) / log(2.0);
    for (int i = 1; i &lt; n; ++i) &#123;
        read(x), read(y), read(w);
        add(x, y, w), add(y, x, w);
    &#125;
    bld(1, 1, n);
    dep[1] = 1, DFS1(1), DFS2(1, -1);
    Z(for (int i = 1; i &lt;= n; ++i)
        printf(&quot;dfn[%lld] = %lld\n&quot;, i, dfn[i]));
    while (m--) &#123;
        read(ty), read(x), read(y);
        if (ty == 1) &#123;
            read(k), read(b);
            inst(x, y, k, b);
        &#125;
        else print(qry(x, y), &#39;\n&#39;);
    &#125;
    return 0;
&#125;
&#125; // namespace XSC062
#undef int

]]></content>
      <tags>
        <tag>李超线段树</tag>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title>杂题选谈</title>
    <url>/20240106/</url>
    <content><![CDATA[想不到好标题了。

有句话怎么说来着，罗马不是一天建成的，是一天天建成的。
还有什么，Do in Rome as the Romans’ do，还有一句，All roads leads to Rome。

A. 连续的零 zero
https://www.becoder.com.cn/contest/4647/problem/1
做个前缀和，看看任意一个长度为 \(k\) 的区间中有几个 \(1\)。复杂度 \(O(n)\)。

namespace XSC062 &#123;
using namespace fastIO;
const int maxn = 5e5 + 5;
const int inf = 0x3f3f3f3f;
int n, m, res = inf;
int a[maxn], s[maxn];
int min(int x, int y) &#123;
    return x &lt; y ? x : y;
&#125;
int main() &#123;
    scanf(&quot;%d %d&quot;, &amp;n, &amp;m);
    for (int i = 1; i &lt;= n; ++i) &#123;
        scanf(&quot;%1d&quot;, &amp;a[i]);
        s[i] = s[i - 1] + a[i];
        if (i &gt;= m)
            res = min(res, s[i] - s[i - m]);
    &#125;
    print(res, &#39;\n&#39;);
    return 0;
&#125;
&#125; // namespace XSC062


B. 反回文串 anti
https://www.becoder.com.cn/contest/4647/problem/2
当 \(n\) 为奇时，中间的元素一定和自己相等，故无解。
当数量最多的一个字符个数超过 \(\dfrac n2\) 时，由鸽巢得无解。
剩下的情况一定有解。

证明
可以找到一种合法的构造方式。我们列出一个列数为 \(2\)，行数为 \(\dfrac n2\) 的表格，将所有相同字母排列在一起，按照从左到右，从上到下的方式将字母填入表格，最后将第 \(i\) 行第一列的字母填入 \(a_i\)，第 \(i\) 行第二列的字母填入 \(a_{n-i+1}\)，即可完成构造。
一种字母只在第一列或第二列出现当然合法，如果从第一列持续到第二列，因为任意字母出现次数不超过 \(\dfrac n2\) 次，所以同一行的两列不会出现同一种字母。
这叫什么，有字证明。
感觉可以拿去出一道类似于「找到字符串字典序最小的反回文串」之类的小水题

然后现在我们知道有解了，怎么找到最优解呢。
比如有一组 \((a_i,a_{n-i+1})=(\texttt a, \texttt a)\)，还有一组 \((a_j, a_{n-j+1})=(\texttt b, \texttt b)\)，那我们直接把 \(a_i\) 和 \(a_j\) 交换，皆大欢喜。
这就说明我们需要把值不相等的非法 \(a_i\) 与 \(a_j\) 配对。
然后我们就可以沿用证明中的构造方式，分组配对，一定最优，每组代价为 \(1\)。
同一行两个值 \(v\) 相等，因为已经最优了，所以不能再在非法串中寻找答案。应该找合法对中某个值交换，每组代价为 \(2\)。具体和谁交换我们不用担心，只要找到一组 \((a_i,a_{n-i+1})\) 满足 \(a_i\ne v\) 且 \(a_{n-i+1}\ne v\) 就可以了，然后我们又知道 \(v\) 的个数 \(\ne \dfrac n2\)，假设 \(\dfrac n2\) 对中每队都有至少一个 \(v\)，由于当前这一对有两个相同的 \(v\)，那么 \(v\) 的个数就会大于 \(\dfrac n2\)，矛盾了，所以一定能找到。
对于非法总对数是奇数的情况，我们要钦定一个非法对强制让其和合法对交换，贪心一下取非法对数量最多的 \(v\) 的某一对最优。

namespace XSC062 &#123;
using namespace fastIO;
const int maxm = 35;
const int maxn = 2e5 + 5;
char s[maxn];
int cnt[maxm], p[maxn];
int T, n, tot, res, now;
int main() &#123;
    scanf(&quot;%d&quot;, &amp;T);
    while (T--) &#123;
        tot = 0;
        scanf(&quot;%d %s&quot;, &amp;n, s + 1);
        if (n &amp; 1) &#123;
            puts(&quot;-1&quot;);
            continue;
        &#125;
        memset(cnt, 0, sizeof (cnt));
        for (int i = 1; i &lt;= n; ++i)
            ++cnt[s[i] - &#39;a&#39; + 1];
        for (int i = 1; i &lt;= 26; ++i) &#123;
            if (cnt[i] * 2 &gt; n) &#123;
                puts(&quot;-1&quot;);
                goto noSol;
            &#125;
        &#125;
        memset(cnt, 0, sizeof (cnt));
        for (int i = 1; i * 2 &lt;= n; ++i) &#123;
            if (s[i] == s[n - i + 1])
                ++cnt[s[i] - &#39;a&#39; + 1], ++tot;
        &#125;
        std::sort(cnt + 1, cnt + 27,
                    std::greater&lt;int&gt;());
        res = now = 0;
        if (tot &amp; 1) &#123;
            res = 1, --cnt[1];
            std::sort(cnt + 1, cnt + 27,
                        std::greater&lt;int&gt;());
        &#125;
        for (int i = 1; i &lt;= 26; ++i) &#123;
            while (cnt[i]--) &#123;
                if (++now &gt; tot / 2) &#123;
                    if (i == p[now - tot / 2])
                        res += 2;
                    else ++res;
                &#125;
                else p[now] = i;
            &#125;
        &#125;
        print(res, &#39;\n&#39;);
        noSol: ;
    &#125;
    return 0;
&#125;
&#125; // namespace XSC062


C. 除与减 divsub
https://www.becoder.com.cn/contest/4647/problem/3
小数学，还好。
假设 \(n=d\times k^p\)，其中 \(k\nmid d\)，那么我们分两种情况讨论。

\(p=0\)，即 \(k\nmid n\)，那么 \(n\bmod k=1\)，即 \(k\mid (n-1)\)。
这个时候问 \(k\) 的个数就相当于是在问 \(n-1\) 除 \(1\) 以外的因子个数。假设 \(n-1={x_1}^{p_1}{x_2}^{p_2}\cdots {x_m}^{p_m}\)，那么答案为 \((\prod p_i+1)-1\)，减去的是 \(1\)。
\(p\ne 0\)，\(k\mid n\)。
这个时候好像并没有什么好的转化。好消息是 \(n\) 的范围是 \(10^{12}\)，根号枚举因数复杂度跑得过。所以我们就可以暴力判定 \(n\) 的所有因数是否满足条件。

时间复杂度，\(O(\sqrt n\times \log n)\)，枚举因数是根号，算次数（也就是算 \(d\)）是 \(\log\)。

#define int long long
namespace XSC062 &#123;
using namespace fastIO;
int n, m, res, cnt;
int main() &#123;
    read(n), m = n;
    for (int i = 2; i * i &lt;= n; ++i) &#123;
        if (n % i == 0) &#123;
            m = n;
            while (m % i == 0) m /= i;
            if (m % i == 1) ++res;
            if (i * i != n) &#123;
                m = n;
                while (m % (n / i) == 0)
                    m /= (n / i);
                if (m % (n / i) == 1) ++res;
            &#125;
        &#125;
    &#125;
    m = n - 1, cnt = 1;
    for (int i = 2; i * i &lt;= m; ++i) &#123;
        if (m % i == 0) &#123;
            int now = 0;
            while (m % i == 0)
                ++now, m /= i;
            cnt *= now + 1;
        &#125;
    &#125;
    if (m != 1) cnt *= 2;
    print(res + cnt, &#39;\n&#39;);
    return 0;
&#125;
&#125; // namespace XSC062
#undef int


D. 图书管理员 librarian
https://www.becoder.com.cn/contest/4647/problem/4
[SDOI2008] 郁闷的小 J。
关于这个，我们发现自己不会考场现冲主席树。哎，打 CDQ 又怕写挂。
我们发现这道题的修改都是单点的，询问也只关于某一种颜色，不同的颜色之间没有影响。
于是我们可以把操作离线下来，初始视作将某颜色在某位置增加，修改视作将某颜色在某位置删除，将另一颜色在该位置增加，将所有操作按颜色离散化分类然后 vector 下来，对于所有颜色从前到后树状数组做一遍操作就能 \(O(n\log n+q\log n)\) 解决。
树状数组清空是肯定不能 memset 的，复杂度不对。那么怎么办呢？把所有操作撤回去就可以了。
顺带一提我是洛谷上最优解。

namespace XSC062 &#123;
using namespace fastIO;
const int maxn = 2e5 + 5;
struct __ &#123;
    int ty, l, r, v;
    __() &#123;&#125;
    __(int t1, int l1, int r1, int v1 = 0) &#123;
        if (t1 == 0)
            ty = 0, l = l1, v = r1;
        else ty = 1, l = l1, r = r1, v = v1;
    &#125;
&#125;;
char ty;
std::map&lt;int, int&gt; tab;
std::vector&lt;__&gt; q[maxn];
int n, m, tot, x, y, v, id;
int Bit[maxn], a[maxn], res[maxn];
int lowbit(int x) &#123; return x &amp; -x; &#125;
void add(int x, int v) &#123;
    for (; x &lt;= n; x += lowbit(x))
        Bit[x] += v;
    return;
&#125;
int ask(int x) &#123;
    int res = 0;
    for (; x; x -= lowbit(x)) res += Bit[x];
    return res;
&#125;
int main() &#123;
    read(n), read(m);
    for (int i = 1; i &lt;= n; ++i) &#123;
        read(a[i]);
        if (!tab.count(a[i]))
            tab[a[i]] = ++tot;
        a[i] = tab[a[i]];
        q[a[i]].emplace_back(0, i, 1);
    &#125;
    while (m--) &#123;
        scanf(&quot;%1s&quot;, &amp;ty);
        if (ty == &#39;C&#39;) &#123;
            read(x), read(y);
            if (!tab.count(y))
                tab[y] = ++tot;
            y = tab[y];
            q[a[x]].emplace_back(0, x, -1);
            q[a[x] = y].emplace_back(0, x, 1);
        &#125;
        else &#123;
            ++id;
            read(x), read(y), read(v);
            if (!tab.count(v)) continue;
            v = tab[v];
            q[v].emplace_back(1, x, y, id);
        &#125;
    &#125;
    for (int i = 1; i &lt;= tot; ++i) &#123;
        for (auto &amp;j : q[i]) &#123;
            if (j.ty == 0) add(j.l, j.v);
            else &#123;
                res[j.v] =
                    ask(j.r) - ask(j.l - 1);
            &#125;
        &#125;
        for (auto &amp;j : q[i])
            if (j.ty == 0) add(j.l, -j.v);
    &#125;
    for (int i = 1; i &lt;= id; ++i)
        print(res[i], &#39;\n&#39;);
    return 0;
&#125;
&#125; // namespace XSC062


E 会单独开一篇。

F. 树 tree
https://www.becoder.com.cn/contest/4647/problem/6
CF916E。
大分讨给我整不会了，更给我整不会的是下来过后发现这只是个小分讨。
更新子树和子树查询我们都会。换根 DP 我们也都写过，都知道换根并不会对子树结构产生大的影响。所以应当是能根据已知信息推测出子树在原树上对应的点集的。
记 \(r\) 为当前树根，\(\text {LCA}(x,y)\) 为 \(x,y\) 在 \(1\) 为根时的 LCA，\(\text {LCA}&#39;(x,y)\) 表示 \(x,y\) 在 \(r\) 为根时的 LCA。
那么对于 \(\text {LCA}&#39;(x,y)\)，肯定是要讨论 \(x,y\) 和 \(r\) 的位置关系的。

\(\text {LCA}(x,y)\) 是 \(r\) 的子孙。此时 \(\text {LCA}&#39;(x,y) = \text {LCA}(x,y)\)。
\(\text {LCA}(x,y)\) 是 \(r\) 的祖先。那么说明至少有一个点不是 \(r\) 的子孙。此时 \(\text {LCA}(x,y)&#39;\) 的值为 \(r\) 为另一个点的 LCA。

整理可得 \(\text {LCA}&#39;(x,y)\) 是 \(\text {LCA}(x,y)\)、\(\text {LCA}(x,r)\) 和 \(\text {LCA}(y,r)\) 中的深度最大者。
对于以 \(r\) 为根时的子树 \(x\)：

\(x=r\)，此时子树为整棵树。
\(\text {LCA}(x,r)\ne x\)，即 \(r\) 不为 \(x\) 的子孙，此时子树就是以 \(1\) 为根是的子树 \(x\)。
\(\text {LCA}(x,y)=x\)，即 \(r\) 为 \(x\) 的子孙，此时子树是整棵树除开 \(x\) 包含 \(r\) 的儿子及其子孙。修改和查询的时候容斥一下就好。这个时候的子树倍增跳一下就能找到。

然后就是常规线段树维护了。时间复杂度 \(O(n\log n)\)。

namespace XSC062 &#123;
using namespace fastIO;
const int maxm = 35;
const int maxn = 1e5 + 5;
#define lt (p &lt;&lt; 1)
#define rt (lt | 1)
struct _ &#123; int l, r, u, d; &#125;;
_ t[maxn &lt;&lt; 2];
int f[maxn][maxm];
std::vector&lt;int&gt; g[maxn];
int a[maxn], dfn[maxn], rfn[maxn];
int n, q, r, ty, x, y, v, si, now;
int top[maxn], dep[maxn], tab[maxn];
void swap(int &amp;x, int &amp;y) &#123;
    x ^= y ^= x ^= y;
    return;
&#125;
void DFS(int x) &#123;
    dep[x] = dep[f[x][0]] + 1;
    dfn[x] = ++now, tab[now] = x;
    for (auto i : g[x]) &#123;
        if (i == f[x][0]) continue;
        f[i][0] = x;
        for (int j = 1; j &lt;= si; ++j)
            f[i][j] = f[f[i][j - 1]][j - 1];
        DFS(i);
    &#125;
    rfn[x] = now;
    return;
&#125;
void pushup(int p) &#123;
    t[p].u = t[lt].u + t[rt].u;
    return;
&#125;
void pushdown(int p) &#123;
    if (t[p].d) &#123;
        t[lt].d += t[p].d;
        t[rt].d += t[p].d;
        t[lt].u += t[p].d *
                (t[lt].r - t[lt].l + 1);
        t[rt].u += t[p].d *
                (t[rt].r - t[rt].l + 1);
        t[p].d = 0;
    &#125;
    return;
&#125;
void bld(int p, int l, int r) &#123;
    t[p].l = l, t[p].r = r;
    if (l == r) &#123;
        t[p].u = a[tab[l]];
        return;
    &#125;
    int mid = (l + r) &gt;&gt; 1;
    bld(lt, l, mid), bld(rt, mid + 1, r);
    pushup(p);
    return;
&#125;
void add(int p, int x, int v) &#123;
    t[p].u += v;
    if (t[p].l == t[p].r) return;
    pushdown(p);
    int mid = (t[p].l + t[p].r) &gt;&gt; 1;
    if (x &lt;= mid) add(lt, x, v);
    else add(rt, x, v);
    return;
&#125;
void add(int p, int l, int r, int v) &#123;
    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r) &#123;
        t[p].d += v;
        t[p].u += (t[p].r - t[p].l + 1) * v;
        return;
    &#125;
    pushdown(p);
    int mid = (t[p].l + t[p].r) &gt;&gt; 1;
    if (l &lt;= mid) add(lt, l, r, v);
    if (r &gt; mid) add(rt, l, r, v);
    pushup(p);
    return;
&#125;
int ask(int p, int l, int r) &#123;
    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r)
        return t[p].u;
    pushdown(p);
    int res = 0,
        mid = (t[p].l + t[p].r) &gt;&gt; 1;
    if (l &lt;= mid) res = ask(lt, l, r);
    if (r &gt; mid) res += ask(rt, l, r);
    return res;
&#125;
int LCA(int x, int y) &#123;
    if (dep[x] &lt; dep[y]) swap(x, y);
    for (int i = si; ~i; --i) &#123;
        if (dep[f[x][i]] &gt;= dep[y])
            x = f[x][i];
    &#125;
    if (x == y) return x;
    for (int i = si; ~i; --i) &#123;
        if (f[x][i] != f[y][i])
            x = f[x][i], y = f[y][i];
    &#125;
    return f[x][0];
&#125;
void Add(int x, int v) &#123;
    int rlca = LCA(r, x);
    if (x == r) add(1, 1, n, v);
    else if (rlca != x)
        add(1, dfn[x], rfn[x], v);
    else &#123;
        add(1, 1, n, v);
        int p = r;
        for (int i = si; ~i; --i) &#123;
            if (dep[f[p][i]] &gt;= dep[x] + 1)
                p = f[p][i];
        &#125;
        add(1, dfn[p], rfn[p], -v);
    &#125;
    return;
&#125;
void tAdd(int x, int y, int v) &#123;
    int llca = LCA(r, x), rlca = LCA(r, y),
        ulca = LCA(x, y);
    if (dep[llca] &gt;= dep[rlca] &amp;&amp;
        dep[llca] &gt;= dep[ulca]) Add(llca, v);
    else if (dep[rlca] &gt;= dep[llca] &amp;&amp;
        dep[rlca] &gt;= dep[ulca]) Add(rlca, v);
    else Add(ulca, v);
    return;
&#125;
int tAsk(int x) &#123;
    int rlca = LCA(r, x);
    if (x == r) return t[1].u;
    if (rlca != x)
        return ask(1, dfn[x], rfn[x]);
    int p = r;
    for (int i = si; ~i; --i) &#123;
        if (dep[f[p][i]] &gt;= dep[x] + 1)
            p = f[p][i];
    &#125;
    return t[1].u - ask(1, dfn[p], rfn[p]);
&#125;
void add(int x, int y) &#123;
    g[x].push_back(y);
    return;
&#125;
int main() &#123;
    read(n), read(q), r = 1;
    si = log(n) / log(2.0);
    for (int i = 1; i &lt;= n; ++i) read(a[i]);
    for (int i = 1; i &lt; n; ++i) &#123;
        read(x), read(y);
        add(x, y), add(y, x);
    &#125;
    dep[0] = 1, DFS(1), dep[0] = 0;
    bld(1, 1, n);
    while (q--) &#123;
        read(ty);
        if (ty == 1) read(r);
        else if (ty == 2) &#123;
            read(x), read(y), read(v);
            tAdd(x, y, v);
        &#125;
        else &#123;
            read(x);
            print(tAsk(x), &#39;\n&#39;);
        &#125;
    &#125;
    return 0;
&#125;
&#125; // namespace XSC062
#undef int

]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>树状数组</tag>
        <tag>LCA</tag>
        <tag>倍增</tag>
        <tag>鸽巢原理</tag>
      </tags>
  </entry>
  <entry>
    <title>解题报告：Game with Probability Problem</title>
    <url>/20240111/</url>
    <content><![CDATA[SP4060 Game with Probability Problem。


设 \(f_i,g_i\) 分别表示还剩 \(i\) 个的时候轮到 Alice 和 Bob 时 Alice 分别的胜率。
概率经典倒推。那么显然有 \(f_0=0,g_0=1\)。
然后就是一个分讨，讨论这个人想要正面还是反面。很显然，对于同样的剩余棋子数，两个人先手的情况对于这颗棋子的喜爱程度是一样的。也就是说，要么都想要，要么都不想要。
什么时候想要呢？拿掉过后自己胜率更大，也就是 \(g_{i-1}&gt;f_{i-1}\)。此时有：
\[
f_i=(1-p)\times g_i+p\times g_{i-1}\\
g_i=(1-q)\times f_i+q\times f_{i-1}
\]
发现是互相影响的，这个时候先不要着急怀疑自己推错了，因为我们这里有两个未知数，又刚好有两个方程，暴解一下就有：
\[
f_i=\dfrac {(1-p)\times q\times f_{i-1}+p\times g_{i-1}}{1-(1-p)(1-q)}\\
g_i=\dfrac {(1-q)\times p\times g_{i-1}+q\times f_{i-1}}{1-(1-p)(1-q)}
\]
然后 \(g_{i-1}&lt;f_{i-1}\) 的情况也差不多，把拿的概率和不拿的概率换一下：
\[
f_i=p\times g_i+(1-p)\times g_{i-1}\\
g_i=q\times f_i+(1-q)\times f_{i-1}
\]
解方程组有：
\[
f_i=\dfrac {(1-q)\times p\times f_{i-1}+(1-p)\times g_{i-1}}{1-p\times q}\\
g_i=\dfrac {(1-p)\times q\times g_{i-1}+(1-q)\times f_{i-1}}{1-p\times q}
\]
然后就可以开始 DP 了。最后的答案就是 \(f_{\min(n,1000)}\)。
还有个问题就是 \(n\) 特别大然后这个看起来也不太能矩乘，但是这个 DP 式有个好处是它的增长趋势是指数级的，所以我们 DP 到 \(1000\) 就可以了。

#include &lt;bits/stdc++.h&gt;
namespace XSC062 &#123;
const int maxn = 1e3 + 5;
using db = double;
db p, q;
int T, n;
db f[maxn], g[maxn];
int min(int x, int y) &#123;
    return x &lt; y ? x : y;
&#125;
int main() &#123;
    scanf(&quot;%d&quot;, &amp;T);
    while (T--) &#123;
        scanf(&quot;%d %lf %lf&quot;, &amp;n, &amp;p, &amp;q);
        f[0] = .0, g[0] = 1.0;
        for (int i = 1; i &lt;= n &amp;&amp; i &lt;= 1000; ++i) &#123;
            if (g[i - 1] &gt; f[i - 1]) &#123;
                f[i] = ((1 - p) * q * f[i - 1] + p * g[i - 1]) / (1 - (1 - p) * (1 - q));
                g[i] = ((1 - q) * p * g[i - 1] + q * f[i - 1]) / (1 - (1 - p) * (1 - q));
            &#125;
            else &#123;
                f[i] = ((1 - q) * p * f[i - 1] + (1 - p) * g[i - 1]) / (1 - p * q);
                g[i] = ((1 - p) * q * g[i - 1] + (1 - q) * f[i - 1]) / (1 - p * q);
            &#125;
        &#125;
        printf(&quot;%.6lf\n&quot;, f[min(n, 1000)]);
    &#125;
    return 0;
&#125;
&#125; // namespace XSC062
int main() &#123;
    XSC062::main();
    return 0;
&#125;


]]></content>
      <tags>
        <tag>DP</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>解题报告：Mahjong</title>
    <url>/20240125/</url>
    <content><![CDATA[PKUSC2022 Mahjong。


https://www.bilibili.com/video/BV1JB4y1R7AP/
这里是 PKUSC 当时的讲解视频。听说可以证明本题一定有 \(\le 5\) 的解。好神奇。

就比如说我们爆搜，\(9^4\times 13^4\) 这个显然干不动对吧，所以我们考虑反过来 DP。
我们先把字符串转化成计数数组，就是每种牌有多少片。不妨将 1m ~ 9s 编号为 \(1\sim 27\)，记 \(g_i\) 为编号为 \(i\) 的牌的数量。
为什么我们觉得 DP 不好打呢？因为换牌操作可以将两个毫不相干的牌的数量更改，不好记录状态。我们不妨直接将换牌拆成 丢弃一张牌 和 借取令一张牌 两个操作。很显然这两个操作数量是一样的，因为我们的牌数量自始至终不变。
对于比较简单的对子作为终局的情况，我们只关心对数是否为 \(7\)，所以设计状态：\(dp_{i,j}\) 表示前 \(i\) 张牌中凑出 \(j\) 个对子的最小代价。
那么就分 把当前牌丢一些 / 借一些拿去组对子 和 直接丢弃当前牌 两种方案。因为丢 / 借的数量是不确定的，直接 abs 一下就好。刷表，有：
\[
dp_{i+1,j}=dp_{i,j}+g_{i+1}\\
dp_{i+1,j+1}=dp_{i,j}+|g_{i+1}-2|
\]
最后我们的答案就来自 \(dp_{27,7}\)。然后注意这里我们的终局是 14 张牌 你能秒我，但起手只有 13 张牌，所以其实会有一个额外的借牌操作，假设答案为 \(x\)，那么其实 \(dp_{27,7}=2\times x+1\)。

有了对子的铺垫，面子手其实也还好。我们需要考虑的是对子和面子的个数。
但是有个问题，对子只用借 / 丢当前花色，但面子可能是会借 / 丢下一个 / 下下一个花色的。
所以干脆全部记录到状态里，令 \(f_{i,j,k,a,b}\) 表示当前在第 \(i\) 个花色，凑成了 \(j\) 个面子，\(k\) 个对子，需要 \(a\) 个 \(i+1\)，\(b\) 个 \(i+2\)。注意因为表示丢借有负数不太容易，不如就直接设成需要的数量了。
因为这个需要数量只是前面的花色对当前花色的需要 \(a\)，我们还要满足当前花色 自身 的需要 \(now\)（也就是说当前花色一共需要 \(a+now\) 张）。注意这里 \(a\) 张全部都是拿去借给前面的花色用的，自己不能用。

对于 \(k=0\) 且 \(now\ge 2\)，此时可以从 \(now\) 里拿两张出来凑对子，剩下的 \(now - 2\) 因为肯定 \(\le 2\)，所以只能全部拿去凑顺子。所以有：
\[
f_{i+1,j+now-2,1,b+now-2, now-2}=f_{i,j,0,a,b}+|g_{i+1}-(a+now)|
\]
对于 \(now\ge 3\)，拿三张凑一面。有：
\[
f_{i+1,j+now-2,k,b+now-3,now-3}=f_{i,j,0,a,b}+|g_{i+1}-(a+now)|
\]
对于 \(now\ne 0\)，可以凑顺子，有：
\[
f_{i+1,j+now,k,b+now,now}=f_{i,j,0,a,b}+|g_{i+1}-(a+now)|
\]
注意不能跨花色借牌，也就是不能让 \(i=8/9/17/18/26/27\)。

答案就是 \(f_{27,4,1,0,0}\)。

然后这两个情况取一个 \(\min\) 就是答案。

namespace XSC062 &#123;
using namespace fastIO;
using std::cin;
using std::getline;
using str = std::string;
int g[30];
int dp[30][15];
str sm, sp, ss;
int f[30][7][2][7][7];
int abs(int x) &#123; return x &gt;= 0 ? x : -x; &#125;
int min(int x, int y) &#123; return x &lt; y ? x : y; &#125;
void upd(int &amp;x, int y) &#123; x = min(x, y); return; &#125;
int main() &#123;
    getline(cin, sm, &#39;m&#39;);
    getline(cin, sp, &#39;p&#39;);
    getline(cin, ss, &#39;s&#39;);
    for (auto i : sm) ++g[i - &#39;0&#39;];
    for (auto i : sp) ++g[i - &#39;0&#39; + 9];
    for (auto i : ss) ++g[i - &#39;0&#39; + 18];
    // 打对子
    memset(dp, 0x3f, sizeof (dp));
    dp[0][0] = 0;
    for (int i = 0; i &lt; 27; ++i) &#123;
        for (int j = 0; j &lt;= 7; ++j) &#123;
            if (dp[i][j] == 0x3f3f3f3f) continue;
            upd(dp[i + 1][j], dp[i][j] + g[i + 1]);
            upd(dp[i + 1][j + 1], dp[i][j] + abs(g[i + 1] - 2));
        &#125;
    &#125;
    // 打飞机
    memset(f, 0x3f, sizeof (f));
    f[0][0][0][0][0] = 0;
    for (int i = 0; i &lt; 27; ++i)
    for (int j = 0; j &lt;= 4; ++j)
    for (int k = 0; k &lt;= 1; ++k)
    for (int a = 0; a &lt;= 4; ++a)
    for (int b = 0; b &lt;= 4; ++b) &#123;
        if (i % 9 == 8 &amp;&amp; b) continue;
        if (i % 9 == 0 &amp;&amp; a + b) continue;
        for (int now = 0; now &lt;= 4; ++now) &#123; // 对当前的额外需求 
            if (a + now &gt; 4) continue;
            int v = f[i][j][k][a][b] + abs(g[i + 1] - (a + now));
            if (j + now &lt;= 4 &amp;&amp; b + now &lt;= 4) // 直接硬配顺子 
                upd(f[i + 1][j + now][k][b + now][now], v);
            if (now &gt;= 2 &amp;&amp; !k &amp;&amp; j + now - 2 &lt;= 4 &amp;&amp; b + now - 2 &lt;= 4) // 借两个去凑对子 
                upd(f[i + 1][j + now - 2][1][b + now - 2][now - 2], v);
            if (now &gt;= 3 &amp;&amp; j + now - 2 &lt;= 4 &amp;&amp; b + now - 3 &lt;= 4) // 借两个去凑三不带 
                upd(f[i + 1][j + now - 2][k][b + now - 3][now - 3], v);
        &#125;
    &#125;
    // 拿来借走会算两次 
    print(min(dp[27][7], f[27][4][1][0][0]) / 2, &#39;\n&#39;);
    return 0;
&#125;
&#125; // namespace XSC062

]]></content>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>解题报告：USACO2024JAN</title>
    <url>/20240131/</url>
    <content><![CDATA[假的，只连打了两组。Ag 没时间了。日后再补吧。


无意中存了题面，但代码大部分因为系统还原消失了，只有文字题解，将就着看吧。

Cu A. Majority Opinion
https://www.luogu.com.cn/problem/P10131
省流：任意区间内，若某元素出现个数严格大于区间长度一半，则可将整个区间推平为该值。问最终可以使整个序列被推平为哪些值。
注意到当任意长度 \(\ge 2\) 的区间可以被推平为某种元素时，整个数列都可以被推平为该元素。故目标转化为对于某种元素判定是否存在一个可被其推平的区间。
统计元素个数采用前缀和。令 \(s_i\) 表示 \(h_i\) 在前 \(i\) 项中出现的次数，假设有 \([j,i]\) 满足条件，贪心可知 \(h_i=h_j\)。
那么由定义有 \(i-j+1&lt;2\times (s_i-s_j+1)\)。典中典，直接移项分离变量。则有 \(i-2\times s_i-1&lt;j-2\times s_j\)。令 \(t_p\gets p-2\times s_p\)，对于每个 \(h\) 记录 \(t_j\) 最大值查看是否有 \(i,j\) 满足条件即可。
Cu B. Cannonball
https://www.luogu.com.cn/problem/P10132
省流：有 \(N\) 个格子，从 \(s\) 格子开始以 \(1\) 为初始能量向右跳，跳一步的距离为能量大小。格子分两种，一种经过加一定能量并反向，另一种若当前能量大于一定值则可永久摧毁，问跳出范围或无限长时间后可摧毁格子个数。
不难发现若忽略增加能量为 \(0\) 的跳板则每经过一个跳板可跳距离增加 \(1\)，最多增加到 \(n\)，否则会跳出去。
注意到调和级数，故直接模拟跳的过程。唯一导致时间无限的情况是存在相邻的增加能量为 \(0\) 的跳板，但其实它具体是什么并不重要，反正我们跳的次数严格大于调和级数后就可以认为进入死循环，直接结束模拟即可。我这里嫌麻烦直接拿了 \(2\times 10^8\) 作阈值。
Cu C. Balancing Bacteria
https://www.luogu.com.cn/problem/P10133
省流：定义一次操作为选取一个整数 \(\Delta\le N\)，并从 \(N\) 到 \(1\)，令 \(a_i\gets a_i+\Delta\) 并令 \(\Delta\) 向 \(0\) 靠近 \(1\)，\(\Delta=0\) 时停止。问令所有 \(a_i=0\) 所需最少操作次数。
挺有意思的思维题，首先需要进行一个思维转化。\(\Delta\le N\) 是一个利于解题的限制，这意味着我们想让任何一个 \(a_i\) 改变 \(1\) 而不影响到之前的值，从让 \(a_1\gets 0\) 入手，进行一次操作后每个 \(a_i\) 分到的 \(\Delta\) 应依次加 1 或依次减 1。则差分数组为 \(0\) 后跟着一截 \(1\) 是理想状态。中间每有一项不满足规律都会带来额外的操作次数。
归纳为差分数组的差分数组绝对值之和即为答案。

Ag A. Cowmpetency
https://www.luogu.com.cn/problem/P10134
省流：有若干条限制，每条形如 \(\max\limits_{i=1}^{a_h-1}\{A_i\}=\max\limits_{i=1}^{a_j}\{A_i\}\) 且 \(A_{a_h}&gt;\max\limits_{i=1}^{a_h-1}\{A_i\}\)，部分数已知，构造出符合条件且字典序最小的序列。
是本场最难题吧，但也没啥卡的。画个线段图容易发现，若将 \([a,h)\) 视作一条线段，那么除非 \(h\) 相同，否则两条线段不能有交集。不然的话就无解。以及如果存在不满足条件的定值也显然无解。
从前往后看每个 \(h\) 并尝试赋值，对于每个 \(1\sim a\) 记录一个需要满足的最大值数值，按照此数值从后往前填空格。
填完过后扫一遍看看是不是全部合法，可以证明若此时不合法则无解。
Ag B. Potion Farming
https://www.luogu.com.cn/problem/P10135
省流：一棵树，每个点上有若干个物品，对于每条从根到叶子的简单路径，可以选择路径上的一个物品，每个物品只能被选一次，问最多可选物品数。
如果一个点引导的子树下所有叶子有没有分配到的，就可以把这个点的物品分配给该叶子。
跑一个树形 DP 即可。

namespace XSC062 &#123;
using namespace fastIO;
const int maxn = 1e5 + 5;
int n, x, y;
int cnt[maxn];
std::vector&lt;int&gt; g[maxn];
int a[maxn], f[maxn], p[maxn];
int min(int x, int y) &#123;
    return x &lt; y ? x : y;
&#125;
void DFS(int x, int fa) &#123;
    if ((int)g[x].size() == 1)
        cnt[x] = 1;
    for (auto i : g[x]) &#123;
        if (i == fa) continue;
        DFS(i, x);
        f[x] += f[i];
        cnt[x] += cnt[i];
    &#125;
    if (f[x] &lt; cnt[x])
        f[x] = min(f[x] + a[x], cnt[x]);
    return;
&#125;
void add(int x, int y) &#123;
    g[x].push_back(y);
    return;
&#125;
int main() &#123;
    read(n);
    for (int i = 1; i &lt;= n; ++i) read(p[i]);
    for (int i = 1; i &lt; n; ++i) &#123;
        read(x), read(y);
        add(x, y), add(y, x);
    &#125;
    int tot = 0;
    for (int i = 2; i &lt;= n; ++i)
        tot += ((int)g[i].size() == 1);
    for (int i = 1; i &lt;= tot; ++i) ++a[p[i]];
    DFS(1, -1);
    print(f[1], &#39;\n&#39;);
    return 0;
&#125;
&#125; // namespace XSC062

Ag C. Cowlendar
https://www.luogu.com.cn/problem/P10136
省流：对于给定的序列 \(a\)，找出所有满足 \(a_i\bmod L\) 的值的种类最多为 3 的 \(L\)。
也是挺有意思的数学题了。若将 \(a_i\) 按照模 \(L\) 的情况分组，则对于任意一个 \(a_i\)，在 \((a_i,a_i+L)\) 中最多包含两个分别来自其余两组的数。
对于去重后 \(n&gt;3\) 的情况，由鸽巢得必定有两个数可分为一组。故我们枚举可能的组间间隔，而可能的 \(L\) 就是这些间隔的因数。
由上面我们推出一个合法组间间隔中最多间隔三个数，我们将所有 \(a_{i+3}-a_i\)、\(a_{i+2}-a_i\) 和 \(a_{i+1}-a_i\) 纳入考虑范围即可。对于所有可能的 \(L\)，直接 \(O(n)\) 跑一个 check 检查是否合法。
因子个数照理来说是 \(\sqrt{V}\times n\) 级别的，但是实测 \(n\) 最多只有一百多。估计是因为 \(n\) 太大就很难构造出更多的合法解吧。

#define int long long
namespace XSC062 &#123;
using namespace fastIO;
const int maxn = 1e4 + 5;
const int maxm = 3e4 + 5;
std::set&lt;int&gt; u;
int n, res, mn, tot;
int a[maxn], b[maxm];
bool check(int x) &#123;
    int l1 = 0, l2 = 0, l3 = 0;
    for (int i = 1; i &lt;= n; ++i) &#123;
        if (l1 == 0) l1 = a[i];
        else if (x &amp;&amp; (a[i] - l1) % x == 0) l1 = a[i];
        else if (l2 == 0) l2 = a[i];
        else if (x &amp;&amp; (a[i] - l2) % x == 0) l2 = a[i];
        else if (l3 == 0) l3 = a[i];
        else if (x &amp;&amp; (a[i] - l3) % x == 0) l3 = a[i];
        else return 0;
    &#125;
    return 1;
&#125;
int main() &#123;
    read(n);
    for (int i = 1; i &lt;= n; ++i) &#123;
        read(a[i]);
        if (!mn || a[i] / 4 &lt; mn) mn = a[i] / 4;
    &#125;
    std::sort(a + 1, a + n + 1);
    n = std::unique(a + 1, a + n + 1) - a - 1;
    if (check(0)) &#123;
        print(mn * (mn + 1) / 2, &#39;\n&#39;);
        return 0;
    &#125;
    for (int i = 2; i &lt;= n; ++i) &#123;
        b[++tot] = a[i] - a[i - 1];
        if (i &gt;= 3) b[++tot] = a[i] - a[i - 2];
        if (i &gt;= 4) b[++tot] = a[i] - a[i - 3];
    &#125;
    std::sort(b + 1, b + tot + 1);
    tot = std::unique(b + 1, b + tot + 1) - b - 1;
    for (int i = 1; i &lt;= tot; ++i) &#123;
        if (check(b[i])) &#123;
            for (int j = 1; j * j &lt;= b[i]; ++j) &#123;
                if (b[i] % j == 0)
                    u.insert(j), u.insert(b[i] / j);
            &#125;
        &#125;
    &#125;
    for (auto i : u) &#123;
        if (i &gt; mn) break;
        res += i;
    &#125;
    print(res, &#39;\n&#39;);
    return 0;
&#125;
&#125; // namespace XSC062
#undef int

]]></content>
      <tags>
        <tag>鸽巢原理</tag>
        <tag>调和级数</tag>
        <tag>差分</tag>
        <tag>思维</tag>
        <tag>树形 DP</tag>
      </tags>
  </entry>
  <entry>
    <title>解题报告：曼哈顿最小距离生成树</title>
    <url>/20240206/</url>
    <content><![CDATA[如题。


E. Another Minimum Spanning Tree
https://www.becoder.com.cn/contest/4940/problem/5
曼哈顿最小距离生成树。给定 \(n\) 个已知坐标的点，两两之间可连权值为曼哈顿距离的边，需求最小生成树。
有一引理：以任意一点为顶点的大小为 \(\dfrac \pi8\) 、且一条边与坐标轴重合的角覆盖的范围中，与该点曼哈顿距离最小的点才有可能与此点连边。
概括说来便是以该点为原点建系，沿坐标轴米字划分。

浅证
首先需认识到，若 \(w(x,y)&lt;w(x,z)\) 且 \(w(y,z)&lt;w(x,z)\)，则边 \(E(x,z)\) 不在最小生成树中。

示意图

考虑有如上 \(A,B,C\) 三点。不妨设 \(d(A,B)\le d(A,C)\)。其中 \(d\) 为曼哈顿距离。
由图易知 \(x_B,y_B,x_C,y_C&gt;0\) 且 \(y_B-x_B,y_C-x_C&gt;0\)。讨论 \(B\) 与 \(C\) 位置关系。下文的 \(x,y\) 均相对 \(A\) 而言。

\(x_B&gt;x_C\) 且 \(y_B&gt;y_c\)：
此时 \(d(A,B)&gt;d(B,C)\)，与题设不符，舍去。
\(x_B&gt;x_C\) 且 \(y_B&lt;y_C\)：
此时 \(d(A,B)=x_B+y_B,d(B,C)=x_B-x_C+y_C-y_B,d(A,C)=x_C+y_C\)。由作差法得 \(d(B,C)-d(A,C)=x_B-y_B-2\times x_C\)，由 \(x_B-y_B&lt;0,x_C&gt;0\)，\(d(B,C)&lt;d(A,C)\)。
由于 \(d(A,B),d(B,C)&lt;d(A,C)\)，故 \(A\) 一定不与 \(C\) 连边。
\(x_B&lt;x_C\) 且 \(y_B&gt;y_C\)：
与上一种情况同理。
\(x_B&lt;x_C\) 且 \(y_B&lt;y_C\)：
此时有 \(d(A,C)=d(A,B)+d(B,C)\)，则 \(A\) 一定不与 \(C\) 连边。


如此一来，边数便降低到了 \(O(n)\) 水平。
此外，如何识别每个点周围每 \(\dfrac \pi8\) 的最近点便是问题所在。
由于坐标可以变换，此处仅考虑顶点为 \(A\)，始边沿 \(y\) 轴正方向，终边沿 \(k=1\) 的区域。则对于区域内的点 \(B\)，易知 \(x_B\geqslant x_A,y_B-y_A\geqslant x_B-x_A\)。
后一条规则分离变量则有 \(y_B-x_B\geqslant y_A-x_A\)，那么问题转化为二维偏序，其中待求为最小 \(x_B+y_B\)，可以用树状数组离散解决。
由于边是双向的，将问题在平面任意连续 \(\dfrac \pi 2\) 范围内进行四次坐标转化即可。
其实并不一定要连续，只要该区域与其旋转一百八十度后的图形的并可以覆盖整个平面即可。这么看来是不是只能连续。
我们会发现旋转 \(\dfrac \pi 8\) 这个我们在整数域上做不到啊。所以我们考虑旋转 + 翻折，最后整出来差不多这个图形：

示意图

然后由于我们发现这些点关于 \(A\) 的关系（是通过 \(A\) 翻折还是旋转得来的）并不中心对称啊，所以呢就要委屈一下写满八个方向了。

namespace XSC062 &#123;
using namespace fastIO;
const int maxn = 1e5 + 5;
struct _ &#123;
    int x, y, id;
    bool operator&lt; (const _ &amp;q) const &#123;
        return y - x &gt; q.y - q.x;
    &#125;
&#125;;
struct __ &#123;
    int x, y, w;
    __() &#123;&#125;
    __(int x1, int y1, int w1) &#123;
        if (y1 &lt; x1) x1 ^= y1 ^= x1 ^= y1;
        x = x1, y = y1, w = w1;
    &#125;
    bool operator&lt; (const __ &amp;q) const &#123;
        return w == q.w ? x &lt; q.x : w &lt; q.w;
    &#125;
&#125;;
int n;
int Bit[maxn]; 
std::vector&lt;__&gt; e;
_ a[maxn], b[maxn];
int ls[maxn], f[maxn];
int lowbit(int x) &#123; return x &amp; -x; &#125;
void upd(int &amp;i, int j) &#123;
    if (!i || (j &amp;&amp; b[j].x + b[j].y &lt;= b[i].x + b[i].y)) i = j;
    return;
&#125;
void add(int x, int i) &#123;
    for (; x &lt;= n; x += lowbit(x)) upd(Bit[x], i);
    return;
&#125;
int ask(int x) &#123;
    int res = 0;
    for (; x; x -= lowbit(x)) upd(res, Bit[x]);
    return res;
&#125; 
int find(int x) &#123; return x == f[x] ? x : f[x] = find(f[x]); &#125;
void merge(int x, int y) &#123; f[find(x)] = find(y); return; &#125;
int abs(int x) &#123; return x &gt;= 0 ? x : -x; &#125;
void adde(int x, int y) &#123;
    if (!x || !y) return;
    e.emplace_back(x, y, abs(a[x].x - a[y].x) + abs(a[x].y - a[y].y));
    return;
&#125;
int main() &#123;
    read(n);
    while (n) &#123;
        e.clear();
        for (int i = 1; i &lt;= n; ++i) &#123;
            read(a[i].x), read(a[i].y), a[i].id = i;
            ls[i] = a[i].x, b[i] = a[i], f[i] = i;
        &#125;
        memset(Bit, 0, sizeof (Bit));
        std::sort(b + 1, b + n + 1);
        std::sort(ls + 1, ls + n + 1);
        for (int i = 1; i &lt;= n; ++i) &#123;
            int x = std::lower_bound(ls + 1, ls + n + 1, b[i].x) - ls;
            x = n + 1 - x, adde(b[i].id, b[ask(x)].id), add(x, i);
        &#125;
        memset(Bit, 0, sizeof (Bit));
        for (int i = 1; i &lt;= n; ++i) &#123;
            b[i].x = a[i].y, b[i].y = a[i].x;
            ls[i] = b[i].x, b[i].id = i;
        &#125;
        std::sort(b + 1, b + n + 1);
        std::sort(ls + 1, ls + n + 1);
        for (int i = 1; i &lt;= n; ++i) &#123;
            int x = std::lower_bound(ls + 1, ls + n + 1, b[i].x) - ls;
            assert(x &gt;= 1 &amp;&amp; x &lt;= n);
            x = n + 1 - x, adde(b[i].id, b[ask(x)].id), add(x, i);
        &#125;
        memset(Bit, 0, sizeof (Bit));
        for (int i = 1; i &lt;= n; ++i) &#123;
            b[i].x = -a[i].x, b[i].y = a[i].y;
            ls[i] = b[i].x, b[i].id = i;
        &#125;
        std::sort(b + 1, b + n + 1);
        std::sort(ls + 1, ls + n + 1);
        for (int i = 1; i &lt;= n; ++i) &#123;
            int x = std::lower_bound(ls + 1, ls + n + 1, b[i].x) - ls;
            assert(x &gt;= 1 &amp;&amp; x &lt;= n);
            x = n + 1 - x, adde(b[i].id, b[ask(x)].id), add(x, i);
        &#125;
        memset(Bit, 0, sizeof (Bit));
        for (int i = 1; i &lt;= n; ++i) &#123;
            b[i].x = -a[i].y, b[i].y = a[i].x;
            ls[i] = b[i].x, b[i].id = i;
        &#125;
        std::sort(b + 1, b + n + 1);
        std::sort(ls + 1, ls + n + 1);
        for (int i = 1; i &lt;= n; ++i) &#123;
            int x = std::lower_bound(ls + 1, ls + n + 1, b[i].x) - ls;
            assert(x &gt;= 1 &amp;&amp; x &lt;= n);
            x = n + 1 - x, adde(b[i].id, b[ask(x)].id), add(x, i);
        &#125;
        memset(Bit, 0, sizeof (Bit));
        for (int i = 1; i &lt;= n; ++i) &#123;
            b[i].x = -a[i].y, b[i].y = -a[i].x;
            ls[i] = b[i].x, b[i].id = i;
        &#125;
        std::sort(b + 1, b + n + 1);
        std::sort(ls + 1, ls + n + 1);
        for (int i = 1; i &lt;= n; ++i) &#123;
            int x = std::lower_bound(ls + 1, ls + n + 1, b[i].x) - ls;
            assert(x &gt;= 1 &amp;&amp; x &lt;= n);
            x = n + 1 - x, adde(b[i].id, b[ask(x)].id), add(x, i);
        &#125;
        memset(Bit, 0, sizeof (Bit));
        for (int i = 1; i &lt;= n; ++i) &#123;
            b[i].x = -a[i].x, b[i].y = -a[i].y;
            ls[i] = b[i].x, b[i].id = i;
        &#125;
        std::sort(b + 1, b + n + 1);
        std::sort(ls + 1, ls + n + 1);
        for (int i = 1; i &lt;= n; ++i) &#123;
            int x = std::lower_bound(ls + 1, ls + n + 1, b[i].x) - ls;
            assert(x &gt;= 1 &amp;&amp; x &lt;= n);
            x = n + 1 - x, adde(b[i].id, b[ask(x)].id), add(x, i);
        &#125;
        memset(Bit, 0, sizeof (Bit));
        for (int i = 1; i &lt;= n; ++i) &#123;
            b[i].x = a[i].x, b[i].y = -a[i].y;
            ls[i] = b[i].x, b[i].id = i;
        &#125;
        std::sort(b + 1, b + n + 1);
        std::sort(ls + 1, ls + n + 1);
        for (int i = 1; i &lt;= n; ++i) &#123;
            int x = std::lower_bound(ls + 1, ls + n + 1, b[i].x) - ls;
            assert(x &gt;= 1 &amp;&amp; x &lt;= n);
            x = n + 1 - x, adde(b[i].id, b[ask(x)].id), add(x, i);
        &#125;
        memset(Bit, 0, sizeof (Bit));
        for (int i = 1; i &lt;= n; ++i) &#123;
            b[i].x = a[i].y, b[i].y = -a[i].x;
            ls[i] = b[i].x, b[i].id = i;
        &#125;
        std::sort(b + 1, b + n + 1);
        std::sort(ls + 1, ls + n + 1);
        for (int i = 1; i &lt;= n; ++i) &#123;
            int x = std::lower_bound(ls + 1, ls + n + 1, b[i].x) - ls;
            assert(x &gt;= 1 &amp;&amp; x &lt;= n);
            x = n + 1 - x, adde(b[i].id, b[ask(x)].id), add(x, i);
        &#125;
        std::sort(e.begin(), e.end());
        int res = 0;
        for (auto i : e) &#123;
            if (find(i.x) != find(i.y))
                res += i.w, merge(i.x, i.y);
        &#125;
        static int TimeKeeper = 0;
        printf(&quot;Case %d: Total Weight = %d\n&quot;, ++TimeKeeper, res);
        read(n);
    &#125;
    return 0;
&#125;
&#125; // namespace XSC062

]]></content>
      <tags>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title>杂题选谈</title>
    <url>/20240501/</url>
    <content><![CDATA[SAM 杂题 + NOIPS8 + 周考 选讲。
看看这个标签列表长度就知道这三天做的题有多杂。


D. 字符串
https://www.becoder.com.cn/contest/5169/problem/4
和 SA 的做法一样，先二分 \(s_{c\sim d}\) 的前缀长度 \(mid\)，只需 check \(s_{c \sim c + mid - 1}\) 是否在 \(s_{a\sim b}\) 中出现过。
考虑怎么快速 check。从 \(c\) 一步一步跳到 \(c+mid-1\) 显然会起飞，考虑到查询是静态的，我们事先预处理一下然后倍增地跳即可。
此时只需看当前状态的 \(\text {endpos}\) 是否在 \([a + mid - 1, b]\) 出现过。
因为这个不能用最大最小简单代替，所以就到了我们喜闻乐见的线段树合并环节。将插入后的每个单点 \(\text {endpos}\) 在权值线段树上更新，在 parent tree 上暴力线段树合并即可。
之前一直有一个误区，就是觉得线段树合并是一次性的，比如用 A 树和 B 树并出来了 C 树之后，A 树和 B 树的数据就无效了。
但这显然是很荒谬的，同样因为我们的查询是静态的，所以完全可以用一种类似于可持久化的方式，建立一些新的点表示合并后的信息状态点，一些可以保留的点就保留作儿子。
在对应的状态上查询即可。

#include &lt;bits/stdc++.h&gt;
const int maxm = 35;
const int maxn = 6e5 + 5;
const int maxk = 8e7 + 5;
struct _ &#123;
    int l, f;
    int ne[maxm]; 
    _() &#123;&#125;
    _(int l1, int f1): l(l1), f(f1) &#123;&#125;
&#125;;
_ t[maxn &lt;&lt; 1];
int vis[maxn &lt;&lt; 1];
int fa[maxn][maxm];
int n, la, tot, siz;
struct &#123; int l, r, u; &#125; t1[maxk];
int tab[maxn &lt;&lt; 1], cnt[maxn &lt;&lt; 1];
void Init(void) &#123;
    la = tot = 1;
    t[1] = _(0, 0);
    return;
&#125;
void ext(int c) &#123;
    int p = la, np = ++tot;
    la = tot;
    t[np] = _(t[p].l + 1, 0);
    while (p &amp;&amp; !t[p].ne[c])
        t[p].ne[c] = np, p = t[p].f;
    if (!p)
        t[np].f = 1;
    else &#123;
        int q = t[p].ne[c];
        if (t[q].l == t[p].l + 1)
            t[np].f = q;
        else &#123;
            int nq = ++tot;
            t[nq] = _(t[p].l + 1, t[q].f);
            std::copy(t[q].ne, t[q].ne + 26, t[nq].ne);
            while (p &amp;&amp; t[p].ne[c] == q)
                t[p].ne[c] = nq, p = t[p].f;
            t[q].f = nq;
            t[np].f = nq;
        &#125;
    &#125;
    return;
&#125;
int now = 0;
void ins(int &amp;p, int l, int r, int v) &#123;
    if (!p)
        p = ++now;
    ++t1[p].u;
    if (l == r)
        return;
    int mid = (l + r) &gt;&gt; 1;
    if (v &lt;= mid)
        ins(t1[p].l, l, mid, v);
    else
        ins(t1[p].r, mid + 1, r, v);
    return;
&#125;
int ask(int p, int l, int r, int ql, int qr) &#123;
    if (ql &lt;= l &amp;&amp; r &lt;= qr)
        return t1[p].u;
    int mid = (l + r) &gt;&gt; 1, res = 0;
    if (ql &lt;= mid)
        res = ask(t1[p].l, l, mid, ql, qr);
    if (qr &gt; mid)
        res += ask(t1[p].r, mid + 1, r, ql, qr);
    return res;
&#125;
int merge(int p, int q, int l, int r) &#123;
    if (!p || !q)
        return p + q;
    int np = ++now, mid = (l + r) &gt;&gt; 1;
    t1[np].u = t1[p].u + t1[q].u;
    if (l == r) return np;
    t1[np].l = merge(t1[p].l, t1[q].l, l, mid);
    t1[np].r = merge(t1[p].r, t1[q].r, mid + 1, r);
    return np;
&#125;
int pos[maxn], rt[maxn &lt;&lt; 1];
bool check(int x, int a, int b, int c, int d) &#123;
    assert(c + x - 1 &gt;= 0);
    int p = pos[c + x - 1];
    for (int i = siz; ~i; --i)
        if (fa[p][i] &amp;&amp; t[fa[p][i]].l &gt;= x)
            p = fa[p][i];
    return ask(rt[p], 0, n - 1, a + x - 1, b) &gt; 0;
&#125;
int solve(int a, int b, int c, int d) &#123;
    int l = 1, r = std::min(d - c + 1, b - a + 1), res = 0;
    while (l &lt;= r) &#123;
        int mid = (l + r) &gt;&gt; 1;
        if (check(mid, a, b, c, d))
            l = mid + 1, res = mid;
        else
            r = mid - 1;
    &#125;
    return res;
&#125;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    std::cout.tie(nullptr);
#endif
    int m;
    std::string s;
    std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; s;
    Init();
    for (int i = 0; i &lt; n; ++i) &#123;
        ext(s[i] - &#39;a&#39;);
        pos[i] = la;
        ins(rt[la], 0, n - 1, i);
    &#125;
    siz = log(tot) / log(2.0);
    for (int i = 1; i &lt;= tot; ++i)
        ++cnt[t[i].l];
    std::partial_sum(cnt + 1, cnt + tot + 1, cnt + 1);
    for (int i = 1; i &lt;= tot; ++i)
        tab[cnt[t[i].l]--] = i;
    for (int i = 1; i &lt;= tot; ++i) &#123;
        int u = tab[i];
        fa[u][0] = t[u].f;
        for (int j = 1; j &lt;= siz; ++j)
            fa[u][j] = fa[fa[u][j - 1]][j - 1];
    &#125;
    for (int i = tot; i; --i) &#123;
        int u = tab[i];
        if (t[u].f)
            rt[t[u].f] = merge(rt[t[u].f], rt[u], 0, n - 1);
    &#125;
    while (m--) &#123;
        int a, b, c, d;
        std::cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;
        std::cout &lt;&lt; solve(a - 1, b - 1, c - 1, d - 1) &lt;&lt; &#39;\n&#39;;
    &#125;
    return 0;
&#125;


F. Security
https://www.becoder.com.cn/contest/5169/problem/6
对我们来说应该是会 D 就会 F 的。所以只打了 10min。
首先考虑一个大家喜闻乐见的 DFS 求最小字典序。显然地，如果存在和当前位相等的字符，那么优先跳相等字符，进入下一层深搜；否则找到最小的更大字符，然后直接 out。
此时 SAM 就是我们用来判断 \(S_{l, r}\) 中是否存在某状态的工具了。甚至比上一题简单，因为不用写二分和倍增。
值得注意的是如果 \(S_{l, r}\) 包含 \(T\) 那么还要在后面随便加一个字符以字典序保证严格大于 \(T\)。

值得注意的是因为我写的太丑了以至于在 CF 上会光荣 MLE #46。然后分屏左半边看我代码右半边写的 zwb 却没有。啧。为什么呢。
#include &lt;bits/stdc++.h&gt;
const int maxm = 35;
const int maxn = 6e5 + 5;
const int maxk = 8e7 + 5;
struct _ &#123;
    int l, f;
    int ne[maxm]; 
    _() &#123;&#125;
    _(int l1, int f1): l(l1), f(f1) &#123;&#125;
&#125;;
_ t[maxn &lt;&lt; 1];
int vis[maxn &lt;&lt; 1];
int fa[maxn][maxm];
int n, la, tot, siz;
struct &#123; int l, r, u; &#125; t1[maxk];
int tab[maxn &lt;&lt; 1], cnt[maxn &lt;&lt; 1];
void Init(void) &#123;
    la = tot = 1;
    t[1] = _(0, 0);
    return;
&#125;
void ext(int c) &#123;
    int p = la, np = ++tot;
    la = tot;
    t[np] = _(t[p].l + 1, 0);
    while (p &amp;&amp; !t[p].ne[c])
        t[p].ne[c] = np, p = t[p].f;
    if (!p)
        t[np].f = 1;
    else &#123;
        int q = t[p].ne[c];
        if (t[q].l == t[p].l + 1)
            t[np].f = q;
        else &#123;
            int nq = ++tot;
            t[nq] = _(t[p].l + 1, t[q].f);
            std::copy(t[q].ne, t[q].ne + 26, t[nq].ne);
            while (p &amp;&amp; t[p].ne[c] == q)
                t[p].ne[c] = nq, p = t[p].f;
            t[q].f = nq;
            t[np].f = nq;
        &#125;
    &#125;
    return;
&#125;
int now = 0;
void ins(int &amp;p, int l, int r, int v) &#123;
    if (!p)
        p = ++now;
    ++t1[p].u;
    if (l == r)
        return;
    int mid = (l + r) &gt;&gt; 1;
    if (v &lt;= mid)
        ins(t1[p].l, l, mid, v);
    else
        ins(t1[p].r, mid + 1, r, v);
    return;
&#125;
int ask(int p, int l, int r, int ql, int qr) &#123;
    if (ql &lt;= l &amp;&amp; r &lt;= qr)
        return t1[p].u;
    int mid = (l + r) &gt;&gt; 1, res = 0;
    if (ql &lt;= mid)
        res = ask(t1[p].l, l, mid, ql, qr);
    if (qr &gt; mid)
        res += ask(t1[p].r, mid + 1, r, ql, qr);
    return res;
&#125;
int merge(int p, int q, int l, int r) &#123;
    if (!p || !q)
        return p + q;
    int np = ++now, mid = (l + r) &gt;&gt; 1;
    t1[np].u = t1[p].u + t1[q].u;
    if (l == r) return np;
    t1[np].l = merge(t1[p].l, t1[q].l, l, mid);
    t1[np].r = merge(t1[p].r, t1[q].r, mid + 1, r);
    return np;
&#125;
int pos[maxn], rt[maxn &lt;&lt; 1];
bool check(int p, int ch, int l, int r) &#123;
    return ask(rt[t[p].ne[ch]], 0, n - 1, l, r) &gt; 0;
&#125;
bool fun(std::string &amp;res, std::string now, std::string &amp;t, int x, int p, int l, int r) &#123;
    // std::cout &lt;&lt; &quot;x = &quot; &lt;&lt; x &lt;&lt; &quot;, now = \&quot;&quot; &lt;&lt; now &lt;&lt; &quot;\&quot;;\n&quot;;
    if (x != (int)t.length() &amp;&amp; check(p, t[x] - &#39;a&#39;, l + x, r) &amp;&amp; fun(res, now + t[x], t, x + 1, ::t[p].ne[t[x] - &#39;a&#39;], l, r))
        return 1;
    for (int i = (x == (int)t.length()) ? 0 : t[x] - &#39;a&#39; + 1; i &lt; 26; ++i) &#123;
        if (check(p, i, l + x, r)) &#123;
            now += i + &#39;a&#39;;
            res = now;
            return 1;
        &#125;
    &#125;
    return 0;
&#125;
std::string solve(std::string &amp;t, int l, int r) &#123;
    std::string res;
    return fun(res, &quot;&quot;, t, 0, 1, l, r) ? res : &quot;-1&quot;;
&#125;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    std::cout.tie(nullptr);
#endif
    int q;
    std::string s;
    std::cin &gt;&gt; s &gt;&gt; q;
    n = (int)s.length();
    Init();
    for (int i = 0; i &lt; n; ++i) &#123;
        ext(s[i] - &#39;a&#39;);
        pos[i] = la;
        ins(rt[la], 0, n - 1, i);
    &#125;
    siz = log(tot) / log(2.0);
    for (int i = 1; i &lt;= tot; ++i)
        ++cnt[t[i].l];
    std::partial_sum(cnt + 1, cnt + tot + 1, cnt + 1);
    for (int i = 1; i &lt;= tot; ++i)
        tab[cnt[t[i].l]--] = i;
    for (int i = 1; i &lt;= tot; ++i) &#123;
        int u = tab[i];
        fa[u][0] = t[u].f;
        for (int j = 1; j &lt;= siz; ++j)
            fa[u][j] = fa[fa[u][j - 1]][j - 1];
    &#125;
    for (int i = tot; i; --i) &#123;
        int u = tab[i];
        if (t[u].f)
            rt[t[u].f] = merge(rt[t[u].f], rt[u], 0, n - 1);
    &#125;
    while (q--) &#123;
        int l, r;
        std::string t;
        std::cin &gt;&gt; l &gt;&gt; r &gt;&gt; t;
        std::cout &lt;&lt; solve(t, l - 1, r - 1) &lt;&lt; &#39;\n&#39;;
    &#125;
    return 0;
&#125;


A. 六出祁山
https://www.becoder.com.cn/contest/5170/problem/1
是能用贪心拿 60pts 的 DP 题 /tuu
需要先把暴力的式子写出来。设 \(f_{i, j}\) 为将 \(i\) 山修改高度为 \(j\) 的代价，则：
\[
f_{i, j} = \min\limits_{k\in [j-d, j+d]}\left\{f_{i-1, k}\right\} + |h_i - j|
\]
注意到可以单调队列优化。但是这样做复杂度还是 \(O(nV)\) 的，根本原因在于第二维这个 \(V\) 的状态数太多了。
根据直觉，最后 \(j\) 的值应为 \(k+d\) 或 \(k-d\) 或 \(a_i\)。也就是说，我们可以认为，合法的状态数为所有的 \(a_i+x\times d, x\in[-n, n]\)。

正确性证明……
考虑全部更改完后的结束状态，即最后的最优状态。
考虑所有山中最矮的山 \(i\)，此山的高度要么为 \(h_i\)，要么为前一座山的高度 \(-d\)，要么为后一座山的高度 \(-d\)。
考虑第二矮的山，以此类推即可。

将第二维的状态集大小减少为 \(O(n^2)\)，总时间复杂度为 \(O(n^3)\)。

需注意到因为 \(a_i+x\times d\) 中的 \(x\) 范围为 \([-n, n]\) 共 \(2\times n\)，所以 DP 数组第二维大小一定要开 \(2\times n^2\) 呀！！！
#include &lt;bits/stdc++.h&gt;
using ll = long long;
const int maxn = 305;
const int maxm = 18e4 + 5;
const ll inf = 0x3f3f3f3f3f3f3f3f;
ll d;
int n;
ll h[maxn];
ll f[maxn][maxm];
int main() &#123;
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    std::cout.tie(nullptr);
    memset(f, 0x3f, sizeof (f));
    std::cin &gt;&gt; n &gt;&gt; d;
    std::vector&lt;ll&gt; st;
    for (int i = 1; i &lt;= n; ++i) &#123;
        std::cin &gt;&gt; h[i];
        for (ll j = -n; j &lt;= n; ++j)
            st.push_back(h[i] + j * d);
    &#125;
    std::sort(st.begin(), st.end());
    st.erase(std::unique(st.begin(), st.end()), st.end());
    auto abs = [&amp;](ll x) -&gt; ll &#123; return x &gt;= 0 ? x : -x; &#125;;
    f[1][lower_bound(st.begin(), st.end(), h[1]) - st.begin()] = 0;
    for (int i = 2; i &lt;= n; ++i) &#123;
        int h(1), t(0), p(-1);
        static int q[maxm];
        for (int j = 0; j &lt; (int)st.size(); ++j) &#123;
            while (p &lt; (int)st.size() &amp;&amp; st[p + 1] &lt;= st[j] + d) &#123;
                ++p;
                while (h &lt;= t &amp;&amp; f[i - 1][p] &lt;= f[i - 1][q[t]])
                    --t;
                q[++t] = p;
            &#125;
            while (h &lt;= t &amp;&amp; st[q[h]] &lt; st[j] - d)
                ++h;
            if (h &lt;= t)
                f[i][j] = std::min(inf, f[i - 1][q[h]] + abs(st[j] - ::h[i]));
        &#125;
    &#125;
    ll res = f[n][std::lower_bound(st.begin(), st.end(), h[n]) - st.begin()];
    std::cout &lt;&lt; (res == inf ? -1 : res) &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;


B. 水淹七军
https://www.becoder.com.cn/contest/5170/problem/2
容易发现最后连出来一定是没有环的。所以一定是一个 DAG。
我们知道状态压缩是会遍历到每一种情况的，所以我们可以假设当前的 DAG 就是该状态下的最优。
至于这个「最优」如何定义就要交给我们了。我们不妨强制认为这个 DAG 是按层序遍历得到的，也就是说连续遍历到的点属于同一层（这里的层是指某点到任意源点的最长路长度）。
显然只有一组相互之间没有任何连边的点才能组成同一层。不妨枚举点集然后暴力转移，转移时记录路径即可。

注意到在写这玩意儿的时候我还不会 状压枚举子集，所以枚举子集的部分可能打得比较抽象。
#include &lt;bits/stdc++.h&gt;
const int maxn = 25;
const int inf = 0x3f3f3f3f;
const int maxm = (1 &lt;&lt; 16) + 5;
int n, res;
int tag[maxn][maxn];
int f[maxn], g[maxn];
int solve(std::vector&lt;int&gt;&amp; a) &#123;
    static int g[maxn];
    static int f[maxm], p[maxm];
    int n(a.size()), siz(1 &lt;&lt; n);
    std::fill(g, g + n, 0);
    std::fill(p, p + siz + 1, 0);
    std::fill(f, f + siz + 1, inf);
    std::vector&lt;int&gt; st;
    for (int i = 0; i &lt; n; ++i) &#123;
        for (int j = 0; j &lt; n; ++j) &#123;
            if (::g[a[i]] &amp; (1 &lt;&lt; a[j]))
                g[i] |= 1 &lt;&lt; j;
        &#125;
    &#125;
    for (int i = 1; i &lt; siz; ++i) &#123;
        int now = 0;
        for (int j = 0; j &lt; n; ++j) &#123;
            if (i &amp; (1 &lt;&lt; j))
                now |= g[j];
        &#125;
        if (!(now &amp; i))
            st.push_back(i), f[i] = 0, p[i] = i;
        for (auto j : st) &#123;
            if (!(i &amp; j)) &#123;
                if (f[i | j] &gt; f[i] + 1)
                    f[i | j] = f[i] + 1, p[i | j] = j;
            &#125;
        &#125;
    &#125;
    int now = siz - 1;
    while (now) &#123;
        int fa = now ^ p[now];
        for (int i = 0; i &lt; n; ++i)
            if (p[now] &amp; (1 &lt;&lt; i))
                for (int j = 0; j &lt; n; ++j)
                    if ((fa &amp; (1 &lt;&lt; j)) &amp;&amp; tag[a[j]][a[i]] == 2)
                        tag[a[j]][a[i]] = 1, tag[a[i]][a[j]] = -1;
        now = fa;
    &#125;
    return f[siz - 1];
&#125;
int find(int x) &#123;
    return x == f[x] ? x : f[x] = find(f[x]);
&#125;
int main() &#123;
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    std::cout.tie(nullptr);
    int m;
    std::cin &gt;&gt; n &gt;&gt; m;
    std::vector&lt;std::pair&lt;int, int&gt; &gt; edge;
    for (int i = 0; i &lt; n; ++i)
        f[i] = i;
    while (m--) &#123;
        int x, y;
        std::cin &gt;&gt; x &gt;&gt; y;
        edge.emplace_back(--x, --y);
        f[find(x)] = find(y);
        g[x] |= 1 &lt;&lt; y;
        g[y] |= 1 &lt;&lt; x;
        tag[x][y] = tag[y][x] = 2;
    &#125;
    std::vector&lt;int&gt; ver[maxn];
    for (int i = 0; i &lt; n; ++i) &#123;
        ver[find(i)].push_back(i);
    &#125;
    for (int i = 0; i &lt; n; ++i) &#123;
        if (f[i] == i)
            res = std::max(res, solve(ver[i]));
    &#125;
    std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
    for (auto i : edge) &#123;
        if (tag[i.first][i.second] == 1)
            std::cout &lt;&lt; i.first + 1 &lt;&lt; &#39; &#39; &lt;&lt; i.second + 1 &lt;&lt; &#39;\n&#39;;
        else std::cout &lt;&lt; i.second + 1 &lt;&lt; &#39; &#39; &lt;&lt; i.first + 1 &lt;&lt; &#39;\n&#39;;
    &#125;
    return 0;
&#125;


C. 煮酒论英雄
https://www.becoder.com.cn/contest/5170/problem/3
注意到如果存在串被其他串包含那么直接将其毙掉就可以了。
对于相互不完全包含的串，我们令 \(mx_{i, j, 0/1, 0/1}\) 表示将正序 / 逆序的 \(i\) 串拼到正序 / 逆序的 \(j\) 串之前，两者共用相接公共部分的串长。这个可以用字符串哈希暴力求。
用状压枚举拼接顺序，求得最小总串长即可。
注意如果去掉被包含串后 \(n=1\) 时需直接输出串的 border；以及答案需和 \(2\) 取 \(\max\)。
实现起来又臭又长，但实际上思路确实非常简单。

#include &lt;bits/stdc++.h&gt;
using ll = long long;
const int p = 131;
const int maxn = 25;
const int lim = 2e4;
const int maxl = 2e4 + 5;
const int mod = 998244353;
const int inf = 0x3f3f3f3f;
const int maxm = (1 &lt;&lt; 16) + 5;
int n;
std::vector&lt;std::string&gt; s;
std::vector&lt;std::vector&lt;ll&gt; &gt; h[2];
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    std::cout.tie(nullptr);
#endif
    std::cin &gt;&gt; n;
    s.resize(n);
    h[0].resize(n);
    h[1].resize(n);
    static ll base[maxl];
    static bool del[maxn];
    base[0] = 1;
    for (int i = 1; i &lt;= lim; ++i)
        base[i] = base[i - 1] * p % mod;

    for (int i = 0; i &lt; n; ++i) &#123;
        std::cin &gt;&gt; s[i];
        h[0][i].resize((int)s[i].length());
        h[1][i].resize((int)s[i].length());
        ll x = 0;
        for (int j = 0; j &lt; (int)s[i].length(); ++j, (x *= p) %= mod)
            h[0][i][j] = ((x += s[i][j]) %= mod);
        std::reverse(s[i].begin(), s[i].end());
        x = 0;
        for (int j = 0; j &lt; (int)s[i].length(); ++j, (x *= p) %= mod)
            h[1][i][j] = ((x += s[i][j]) %= mod);
        std::reverse(s[i].begin(), s[i].end());
    &#125;

    std::vector&lt;int&gt; tab;
    auto gethash = [&amp;](int i, int l, int r, bool t) -&gt; ll &#123;
        if (l &gt; r) return 0;
        ll res = (h[t][i][r] - (l ? h[t][i][l - 1] : 0) * base[r - l + 1] % mod);
        return (res % mod + mod) % mod;
    &#125;;
    // ll now = 0;
    // for (int i = 0; i &lt;= 4; ++i)
    //     now = (now * p + s[1][i]) % mod;
    // printf(&quot;now = %lld\n&quot;, now);
    // now = 0;
    // for (int i = 3; i &lt;= 7; ++i)
    //     now = (now * p + s[0][i]) % mod;
    // printf(&quot;now = %lld\n&quot;, now);
    // printf(&quot;# %lld\n&quot;, h[0][0].back());
    for (int i = 0; i &lt; n; ++i) &#123;
        tab.push_back(i);
        for (int j = 0; j &lt; n; ++j)
            if (!del[j] &amp;&amp; i != j)
                for (int k = 0; k &lt;= ((int)s[j].length()) - ((int)s[i].length()); ++k) &#123;
                    // printf(&quot;i = %d, j = %d, k = %d, %lld / %lld\n&quot;, i, j, k,
                    //         gethash(i, 0, ((int)s[i].length()) - 1, 0), gethash(j, k, k + ((int)s[i].length()) - 1, 0));
                    if (h[0][i].back() == gethash(j, k, k + ((int)s[i].length()) - 1, 0)) &#123;
                        tab.pop_back();
                        del[i] = 1;
                        goto outo;
                    &#125;
                &#125;
        outo: ;
    &#125;
    n = (int)tab.size();
    if (n == 1) &#123;
        int border;
        for (border = ((int)s[tab[0]].length()) - 1; ~border; --border) &#123;
            if (gethash(tab[0], 0, border - 1, 0) == gethash(tab[0], ((int)s[tab[0]].length()) - border, ((int)s[tab[0]].length()) - 1, 0))
                break;
        &#125;
        std::cout &lt;&lt; std::max(2, ((int)s[tab[0]].length()) - border) &lt;&lt; &#39;\n&#39;;
    &#125;
    else &#123;
        static int mx[maxn][maxn][2][2];
        for (int i = 0; i &lt; n; ++i)
            for (int j = 0; j &lt; n; ++j)
                for (int a = 0; a &lt; 2; ++a)
                    for (int b = 0; b &lt; 2; ++b)
                        for (int k = std::min((int)s[tab[i]].length(), (int)s[tab[j]].length()); ~k; --k) &#123;
                            if (gethash(tab[i], ((int)s[tab[i]].length()) - k, ((int)s[tab[i]].length()) - 1, a) ==
                                                                                            gethash(tab[j], 0, k - 1, b)) &#123;
                                mx[i][j][a][b] = (int)s[tab[j]].length() - k;
                                // printf(&quot;%d(%d) + %d(%d) = %d, k = %d\n&quot;, i, a, j, b, mx[i][j][a][b], k);
                                break;
                            &#125;
                        &#125;
        static int f[maxm][maxn][2];
        memset(f, 0x3f, sizeof (f));

        int siz = 1 &lt;&lt; n, res = inf;
        f[1][0][0] = (int)s[tab[0]].length();
        for (int i = 1; i &lt; siz; ++i)
            for (int j = 0; j &lt; n; ++j)
                if (i &amp; (1 &lt;&lt; j))
                    for (int a = 0; a &lt; 2; ++a) &#123;
                        // printf(&quot;f[%d][%d][%d] = %d\n&quot;, i, j, a, f[i][j][a]);
                        for (int k = 0; k &lt; n; ++k)
                            if (!(i &amp; (1 &lt;&lt; k)))
                                for (int b = 0; b &lt; 2; ++b)
                                    f[i | (1 &lt;&lt; k)][k][b] = std::min(f[i | (1 &lt;&lt; k)][k][b], f[i][j][a] + mx[j][k][a][b]);
                        if (i == siz - 1)
                            res = std::min(res, f[i][j][a] - (int)s[tab[0]].length() + mx[j][0][a][0]);
                    &#125;
        
        std::cout &lt;&lt; std::max(2, res) &lt;&lt; &#39;\n&#39;;
    &#125;
    return 0;
&#125;


A. 捏斑马
https://www.becoder.com.cn/contest/5175/problem/1
我甚至不会（）
翻转 + 拼接本质上就是首尾相接。我们把字符串整个拼到自己后边儿，然后任取一段长度为 \(n\) 的串就可以得到一个倒过来的操作后的字符串。
注意到可以操作很多次。但是既然我们操作后的串也可以在这个拼接后的串中找到了，那么其实多次操作后的也行。
所以呢我们在拼接后的串种枚举每一个长度为 \(n\) 的串计算答案即可。
具体怎么算呢？注意到只看开头，也就是在新串中只看离我们当前枚举的右端点最近的那一段，所以我们打一个双指针，看这一段是否在右移后仍然合法，如果非法就把答案区间左端点更新为右端点自己。以及注意到左右端点的距离不能超过 \(n\)。

#include &lt;bits/stdc++.h&gt;
int res;
std::string s;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    std::cout.tie(nullptr);
#endif
    std::cin &gt;&gt; s;
    int l = 0, r = -1, n = (int)s.length();
    char la = 0;
    s += s;
    while (++r &lt; (int)s.length()) &#123;
        if (s[r] == la)
            l = r;
        while (r - l + 1 &gt; n) ++l;
        la = s[r];
        res = std::max(res, r - l + 1);
    &#125;
    std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;


D. 链状闪电
https://www.becoder.com.cn/contest/5175/problem/4
莫名其妙且又臭又长的根号做法。
容易发现一个怪被杀掉了序列就会裂开成两段连续子序列，以及最先被杀掉的怪物一定血量最少。在裂开来的两段连续子序列中也满足此规律，以此类推。
考虑对序列建立笛卡尔树。令树根为 \(rt\)，当前攻击力为 \(k\)，记 \(t_{x, k}=\left\lceil \dfrac {h_x}k \right\rceil\)，即不考虑其他条件时击倒 \(x\) 所需次数。
那么对于 \(rt\) 的左、右儿子 \(l,r\)，单考虑这三个怪物所需的总击倒次数，容易发现为 \(t_{rt,k}+(t_{l,k}-t_{rt,k})+(t_{r,k}-t_{rt,k})\)。
对于 \(l\) 引导的子树，此时的实际已攻击次数为 \(t_{l,k}\)；所以对于 \(l\) 的左右儿子 \(l&#39;,r&#39;\)，击倒这两个怪物的所需次数为 \((t_{l&#39;,k} - t_{l,k})+(t_{r&#39;,k}-t_{l,k})\)。\(r\) 引导的子树同理。
所以我们就可以知道，如果存在树边 \(u\to v\)，那么击倒 \(v\) 的所需次数为 \(t_{v,k}-t_{u,k}\)；特别地，击倒 \(rt\) 的所需次数为 \(t_{rt,k}\)。
那么我们就可以通过一次 \(O(n)\) 的树上 DFS 对于一个 \(k\) 找到答案了。
那么对于 \(2\times 10^4\) 范围内的所有 \(k\)，应该怎么办呢？这个时候就要利用 \(t\) 的性质进行根号分治了。

对于 \(k\le \sqrt {2\times 10^4}\)，我们大可以直接做这么多次 DFS 得到答案；
对于 \(k&gt;\sqrt {2\times 10^4}\)：
我们容易发现最终的结果是若干个 \(t\) 的值相加减得到的，而每个 \(t\) 的权值 \(cnt\) 取决于其在笛卡尔树上的儿子个数，有多少就在 \(1\) 的基础上减去多少。
由于 \(t\) 实在过于特殊，考虑整除分块 / 数论分块。对于每个 \(x\)，对于任意 \(k&#39;\in (\sqrt {2\times 10^4}, 2\times 10^4]\)，可能的 \(t\) 值只有 \(\sqrt {2\times 10^4 }\) 种。计算出对于每个 \(t&#39;\)，满足 \(\left\lceil \dfrac {h_x}{k&#39;} \right\rceil=t&#39;\) 的 \(k&#39;\) 范围，对该范围 \(k&#39;\) 的答案区间加上 \(t&#39;\times cnt\) 即可，可以使用差分。
至此，就可以在一次 DFS 内解决这种情况下的问题。

总时间复杂度为 \(O(n\sqrt {2\times 10^4})\)。

值得注意的是，我在做这道题的时候并没有意识到自己用到了笛卡尔树，
所以代码中笛卡尔树的建树部分可能长得特别抽象（
这里是使用了下标上的 ST 表带 log 地求解了左右儿子。
#include &lt;bits/stdc++.h&gt;
const int maxm = 35;
const int maxn = 1e5 + 5;
using ll = long long;
ll res;
int n, k, l;
int g[maxn][2];
int f[maxn][maxm];
int a[maxn], t[maxn];
ll dif[maxn], cnt[maxn];
int ask(int l, int r) &#123;
    if (l &gt; r) return 0;
    int k = log(r - l + 1) / log(2.0);
    return (a[f[l][k]] &lt; a[f[r - (1 &lt;&lt; k) + 1][k]]) ? f[l][k] : f[r - (1 &lt;&lt; k) + 1][k];
&#125;
void bld(int rt, int l, int r) &#123;
    if (rt != l) &#123;
        g[rt][0] = ask(l, rt - 1);
        bld(g[rt][0], l, rt - 1);
    &#125;
    if (rt != r) &#123;
        g[rt][1] = ask(rt + 1, r);
        bld(g[rt][1], rt + 1, r);
    &#125;
    return;
&#125;
// k &lt;= sqrt(lim)
void DFS(int x, int k, int fa) &#123;
    t[x] = (a[x] + k - 1) / k;
    res += t[x] - t[fa];
    for (int i = 0; i &lt; 2; ++i) &#123;
        if (g[x][i])
            DFS(g[x][i], k, x);
    &#125;
    return;
&#125;
// k &gt; sqrt(lim)
void DFS(int x, int fa) &#123;
    ++cnt[x];
    --cnt[fa];
    for (int i = 0; i &lt; 2; ++i) &#123;
        if (g[x][i])
            DFS(g[x][i], x);
    &#125;
    int l = k + 1, r;
    // 注意这里 i 的范围判定，如果直接写成 i * i &lt;= k 会少计算一些情况
    for (int i = 1; (i - 1) * (i - 1) &lt; k; ++i) &#123;
        r = l - 1;
        l = (a[x] + i - 1) / i;
        // fprintf(stderr, &quot;%d: [%d, %d] += %d * %d\n&quot;, a[x], l, r, cnt[x], i);
        dif[l] += i * cnt[x], dif[r + 1] -= i * cnt[x];
    &#125;
    return;
&#125;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    std::cout.tie(nullptr);
#endif
    std::cin &gt;&gt; n;
    for (int i = 1; i &lt;= n; ++i) &#123;
        std::cin &gt;&gt; a[i];
        f[i][0] = i;
        k = std::max(k, a[i]);
    &#125;
    for (int j = 1; (1 &lt;&lt; j) &lt;= n; ++j)
        for (int i = 1; i + (1 &lt;&lt; j) - 1 &lt;= n; ++i)
            f[i][j] = (a[f[i][j - 1]] &lt; a[f[i + (1 &lt;&lt; (j - 1))][j - 1]]) ? f[i][j - 1] : f[i + (1 &lt;&lt; (j - 1))][j - 1];
    int rt = ask(1, n);
    bld(rt, 1, n);
    for (int i = 1; i * i &lt;= k; ++i) &#123;
        res = 0;
        DFS(rt, i, 0);
        std::cout &lt;&lt; res &lt;&lt; &#39; &#39;;
        l = i + 1;
    &#125;
    // fputs(&quot;\n&quot;, stderr);
    DFS(rt, 0);
    std::partial_sum(dif + 1, dif + k + 1, dif + 1);
    for (int i = l; i &lt;= k; ++i)
        std::cout &lt;&lt; dif[i] &lt;&lt; &#39; &#39;;
    std::cout &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;


F. 弹飞绵羊
https://www.becoder.com.cn/contest/5175/problem/6
很棒可持久化分块，使我 lxl 旋转。
笑话：赛后 5s 才交上去。然后 A 了。
我们猜大家都会普通的弹飞绵羊这道题。就是块间暴力跳嘛。
这里给一个我自己整的简单实现方法。
我们把分出来的块视作若干个无关联的散块并纳入块集合；对于每一个版本，用一个大小为 \(\sqrt n\) 的 \(id\) 数组记录每一位置的块在块集合中对应的位置。
然后该怎么搞怎么搞即可。
P.S. zwb 坚定不移信仰 lxl 神教于是决定用可持久化平衡树实现可持久化分块，结果当然是因为多了个 \(\log\) 被卡飞了，最后气急败坏慌不择路恼羞成怒抄起了我的代码。

#include &lt;bits/stdc++.h&gt;
const int maxk = 320;
const int maxn = 2e5 + 5;
class devicer &#123;
public:
    int l, r;
    std::vector&lt;int&gt; ne, u, a;
    int &amp;nex(int x);
    int &amp;val(int x);
&#125;;
int id[maxn][maxk];
std::vector&lt;devicer&gt; b;
int n, q, ty, siz, k, la;
int a[maxn], tab[maxn], blk[maxn];
void upd(int x, int a, devicer &amp;p) &#123;
    if (x + a &gt; n)
        p.nex(x) = -1, p.val(x) = 1;
    else if (x + a &gt; p.r)
        p.nex(x) = x + a, p.val(x) = 1;
    else
        p.nex(x) = p.nex(x + a), p.val(x) = p.val(x + a) + 1;
    // printf(&quot;x = %d, a = %d, r = %d, upd ne[%d] to %d\n&quot;, x, a, p.r, x, p.nex(x));
    return;
&#125;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    std::cout.tie(nullptr);
#endif
    std::cin &gt;&gt; n &gt;&gt; q &gt;&gt; ty;
    siz = sqrt(n);
    k = (n + siz - 1) / siz;
    b.resize(k);
    int la = 0, now = k - 1;
    for (auto &amp;i : b)
        i.l = la + 1, la = i.r = i.l + siz - 1;
    b.back().r = n;
    for (int i = 0; i &lt; k; ++i) &#123;
        id[0][i] = i;
        b[i].a.resize(b[i].r - b[i].l + 1);
        b[i].u.resize(b[i].r - b[i].l + 1);
        b[i].ne.resize(b[i].r - b[i].l + 1);
        for (int j = b[i].l; j &lt;= b[i].r; ++j)
            tab[j] = j - b[i].l, blk[j] = i;
    &#125;
    for (int i = 1; i &lt;= n; ++i)
        std::cin &gt;&gt; b[blk[i]].a[tab[i]];
    for (int i = n; i; --i)
        upd(i, b[blk[i]].a[tab[i]], b[blk[i]]);
    int ver = 0;
    while (q--) &#123;
        int op, pr, x;
        static int res = 0;
        std::cin &gt;&gt; op &gt;&gt; pr &gt;&gt; x;
        if (!ty)
            res = 0;
        x ^= res;
        if (op == 1) &#123;
            std::copy(id[pr], id[pr] + k, id[++ver]);
            b.push_back(b[id[ver][blk[x]]]);
            id[ver][blk[x]] = ++now;
            std::cin &gt;&gt; b.back().a[tab[x]];
            b.back().a[tab[x]] ^= res;
            for (int i = x; i &gt;= b.back().l; --i)
                upd(i, b.back().a[tab[i]], b.back());
        &#125;
        else &#123;
            int p = x;
            res = 0;
            while (~p) &#123;
                // printf(&quot;p = %d\n&quot;, p);
                res += b[id[pr][blk[p]]].u[tab[p]];
                p = b[id[pr][blk[p]]].ne[tab[p]];
            &#125;
            std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
        &#125;
    &#125;
    return 0;
&#125;
int&amp; devicer::nex(int x) &#123;
    return ne[tab[x]];
&#125;
int&amp; devicer::val(int x) &#123;
    return u[tab[x]];
&#125;

]]></content>
      <tags>
        <tag>DP</tag>
        <tag>SAM</tag>
        <tag>状压</tag>
        <tag>分块</tag>
        <tag>可持久化</tag>
        <tag>笛卡尔树</tag>
      </tags>
  </entry>
  <entry>
    <title>学习笔记：状压枚举子集 + 高维前缀和</title>
    <url>/20240517/</url>
    <content><![CDATA[出现了，但发现没写过，故记之。


状压枚举子集
需求：对于 每一个 长度为 \(n\) 的二进制状态 \(s\)，枚举其子状态 \(\{ t \mid t \operatorname{bitand} s = t \}\)。
直接枚举所有长度为 \(n\) 的状态 \(t&#39;\)，然后判定是否满足 \(t&#39; \operatorname{bitand} s = t\)，总时间复杂度是 \(O(2^{2n})\) 的。考虑优化。
考虑对于所有 \(2^n\) 种状态 \(s\)，假如有一种方式能够不重不漏地枚举出它们中每一个的所有子状态，那么总时间复杂度是多少呢？
把所有数对 \((s, t)\) 排列在一起。那么对于 \(n\) 位中的每一位 \(i\)，枚举每一个 \((s&#39;, t&#39;)\)。
那么存在以下几种可能性：

\({s&#39;}_i=1,{t&#39;}_i=1\)；
\({s&#39;}_i=1, {t&#39;}_i=0\)；
\({s&#39;}_i=0, {t&#39;}_i = 0\)。

假如我们用 \(o_i=0,1,2\) 分别代表第一、二、三种情况，完全可以用长度为 \(n\) 的三进制状态 \(o\) 还原数对 \((s, t)\)。
由于这个 \((s, t)\) 序列中肯定没有完全相同的元素，也就是说，对于每一个 \((s, t)\)，其 \(o\) 都各不相同。
因此，\((s, t)\) 的数目不超过 \(3^n\)（更准确地，二者值相等）。
又因为对于 \(3^n\) 个 \(o\)，每个都可以还原出合法状态，所以总的 \((s, t)\) 数目应恰好为 \(3^n\)。
也就是说，假如有一种方式能够不重不漏地枚举出每一个 \(s\) 的所有子状态 \(t\)，可以做到均摊 \(O(3^n)\)。
接下来探讨这种枚举方式。直接给出结论：
for (int t = s; t; t = (t - 1) &amp; s);
其实不难理解。从 \(t\) 的定义出发即 \(t \operatorname{bitand} s = t\)，重点理解 \(t\gets (t - 1)\operatorname{bitand} s\) 这一步。
分两种情况讨论：

\(t-1\) 较 \(t\) 发生退位：
因为只减 \(1\)，所以末位一定发生退位。
如果发生连续退位，一定是因为末端有连续的 \(0\)。对于第一个 \(1\)（记为第 \(j\) 位），已经枚举完了在 \(j\) 及更高位固定在当前状态下的所有状态。
则应有：

比 \(j\) 更高的数位，未受到退位带来的连续影响的位不变；
第 \(j\) 位 \(1\to 0\)；
从第 \(j\) 位一直到末位都有 \(0\to 1\)。

此时与 \(s\) 进行 \(\operatorname{bitand}\)，得到比 \(j\) 更高的数位不变、\(j\) 位 \(1\to 0\)、比 \(j\) 更低的数位变为抵着 \(s\) 对应数位的最大状态。
综上，这是比 \(t\) 小的第一个合法状态。
\(t-1\) 较 \(t\) 不发生退位：
根据上面的讨论，其实就是末位不退位，即末位 \(1\to 0\)。显然是比 \(t\) 更小的第一个合法状态。

综上，实现了从大到小依次枚举合法状态，因此不重不漏。

枚举补集
看了几个比较抽象的博客，但是我觉得不如直接把 \(s\) 异或一下 \(2^n-1\) 然后枚举子集。

子集和 / 高维前缀和
首先理解一下什么是高维前缀和。实际上全称应为边长为 \(2\) 的高维空间前缀和。其实就是求所有状态的子集和，运用了前缀和的思想故唤高位前缀和 / 逐维前缀和。
即在 \(n=2\) 的情况下，我们发现我们可以将 \(k\) 维前缀和看作在 \(k\) 位二进制数上做子集元素求和。显然根据枚举子集有 \(3^k\) 的做法，但还能更快。
std::copy(a.begin(), a.end(), s.begin());
for (int i = 0; i &lt; k; ++i)
    for (int j = 0; j &lt; l; ++j)
        if ((j &gt;&gt; i) &amp; 1)
            s[j] += s[j ^ (1 &lt;&lt; i)];
先枚举 \(i\) 是因为使用高维前缀和的题目一般时限卡得比较死，需要使用内存连续访问尽量减小常数。
对于状态 \(j\)，考虑枚举其每一维上的值，则 \(s_j=a_j+\sum s_{j\bigoplus 2^i}\)。易发现这可以不重不漏地覆盖所有子集。
这种思想在一些状态压缩的题目中也有应用，具体见 此。
高维后缀和
从大往小枚举 \(j\)，对于 \(j\) 中值为 false 的维 \(i\)，令 \(s_j=a_j+\sum s_{j+2^i}\) 即可。
std::copy(a.begin(), a.end(), s.begin());
for (int i = 0; i &lt; k; ++i)
    for (int j = l - 1; ~j; --j)
        if (!((j &gt;&gt; i) &amp; 1))
            s[j] += s[j ^ (1 &lt;&lt; i)];
]]></content>
      <tags>
        <tag>状压</tag>
        <tag>高维前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title>媒介素养</title>
    <url>/20240625/</url>
    <content><![CDATA[Adapted from 之前的一片发电文。现在更癫了。




媒介素养一般是指人们正确地、建设性地使用媒介资源的能力。它包括人们面对各种信息时的选择、理解、质疑、评估等能力。

关于选择：太遗憾了！你没有任何其他的项目是可选择的，因为歌愛ユキ很可爱！
关于理解：接下来，你将会度过一定量的时间理解歌愛ユキ的可爱性。
关于质疑：是的，正在质疑！通常情况下这代表着一种好的状态，但在这里您可能会遇到障碍——你不会想要质疑歌愛ユキ。事实上，歌愛ユキ又有什么是可质疑的呢？
关于评估：当然，在这里，评估有着不可忽视的重要性——海内存知己，天涯若比邻。对我们的歌愛ユキ进行打分！
可选的评估项：

100 分
其他，请补锟斤拷锟斤拷锟斤拷烫烫烫烫烫烫烫烫烫
程序 Assessing.exe 引用了名为 0x00000000ff 的内存，该地址不能为 &#39;read&#39;。
很遗憾！看起来你的 Windows 出现了问题。请勿关闭电脑，我们将会收集你电脑上的错误信息，我们将会将它上传到 Microsoft 官网并尝试在脱机状态下解决它。
错误代码：0x00009E2EAF60
我们正在为你解析。



嘿，抬起头！这篇帖子可能并没有您正在考虑的那样陌生！
Hey, heads up! The post may not so strange as you are considering!
让我们分析这些笑话！
Let’s analyse the jokes!

努力理解「花」意味着什么。
Try to understand what “spend” means.
正在错误地翻译「查询」。
Wrong translating “querying”.
海内存知己，天涯若比邻。
Sea inside exist know self, sky Ya like than neighbor.
主语并未变化，但主语却在相邻的两个短句中出现了。相同的相邻主语没有得到省略，而这将导致这些相同的主语看起来很累赘！
The subject didn’t changed, but it appears in two adjacent short sentences. The same adjacent subjects havn’t been omitted, which will make these identical subjects appear cumbersome!
正在错过时间状语！这使「上传」和「脱机处理」两个动作看上去像是同时发生的。
Missing time adverb! This makes the actions of “uploading” and “offline processing” appear to occur simultaneously.
你您你您你您你您你您
You you you you you you you you you you


如果你听 Lost Umbrella / ロストアンブレラ，我们就是一辈子的好兄弟


如果你听 Ipace / アイペース，我们就是一辈子的好兄弟


如果你听 绣球花 / Hydrangea / ハイドレンジア，我们就是一辈子的好兄弟


如果你听 斯德哥尔摩华尔兹 / ストックホルムワルツ，我们就是一辈子的好兄弟


如果你听 延误列车 / ラグトレイン，我们就是一辈子的好兄弟


如果你听 無，我们就是一辈子的好兄弟


]]></content>
      <tags>
        <tag>闲话</tag>
      </tags>
  </entry>
  <entry>
    <title>杂题选谈：DP 杂题</title>
    <url>/20240906/</url>
    <content><![CDATA[现在是 10 题。虽然看着很掉价，但是写够了 10 就改成 20 题。以此类推，免得我摆烂（）
自用向，不写太详细，把破题点写出来就差不多了。哦哦这里的破题是动词不是名词。


1. 字符合并
https://www.luogu.com.cn/problem/P3736

给定长度为 \(n\) 的 \(01\) 串和 \(2^k\) 条规则，第 \(i\) 条规则形如：

对于序列中的 \(k\) 位二进制数 \(i\)，可以将它合并为 \(c(c\in\{0,1\})\)，并产生 \(v\) 的价值。

进行任意次合并，求出能取得的最大总价值。\(n\le 300,k\le 8\)。

状压，区间 DP。
注意到 \(k\) 只有 \(8\)，独特的输入方式也引导我们注意到状态数为 \(10^2\) 级别。合并的背景又让我们本能想到区间 DP，所以刚好盲猜这题是个 \(O(2^k\times n^2)\) 的区间状压 DP。

然后我觉得最神的一个地方是什么呢？最后的答案一定是一个长度小于 \(k\) 的串，每位展开还原，可以知道，每个合并操作选取的区间可能包含但不相交。
看起来很蠢很显然，但这是我们 \(n^2\) 区间 DP 的基础啊（（（

然后我们区间 DP 套路，枚举对于 \([l,r]\) 最左边一位，然后就可以开始大力转移了。
但是这里我们会发现，这一位原本的样子有点多，可以是任何一个长度为 \(1 + d\times (k-1)\) 的数，所以只能再来一层 \(\dfrac nk\) 的枚举，极限情况是个有点难绷的 3e9，作为正解只能说这个数据范围的提示性有点令人难评了。
实现着实现着把自己整懵了：00000 和 0 压出来都是 0，但二者代表的含义显然不同，又无法简单区别。但其实长度为 \(1+d\times (k-1)\) 的区间和长度为 \(d\) 的最终结果是一一对应的，所以在我们设计的包含了区间作右端点的状态中，压出来的就是我们想要的那个。

这里的实现比所有我找到的题解都更像人打出来的。导致我想对比疗法都找不到合适的代码 
换言之，这最像是一份通常的区间 DP 代码，不存在其他题解中乱七八糟的填表啊相互影响啊之类的恶心 feature。
sto rybp orz
#include &lt;bits/stdc++.h&gt;
const int maxn = 305;
const int maxm = (1 &lt;&lt; 8) + 5;
char a[maxn];
int c[maxm], w[maxm];
long long f[maxn][maxn][maxm];
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    std::cout.tie(nullptr);
#else
    freopen(&quot;in.in&quot;, &quot;r&quot;, stdin);
    freopen(&quot;out.out&quot;, &quot;w&quot;, stdout);
#endif
    int n, k;
    std::cin &gt;&gt; n &gt;&gt; k;
    int siz = (1 &lt;&lt; k), si = (1 &lt;&lt; (k - 1));
    for (int i = 1; i &lt;= n; ++i)
        std::cin &gt;&gt; a[i];
    for (int i = 0; i &lt; siz; ++i)
        std::cin &gt;&gt; c[i] &gt;&gt; w[i];
    memset(f, -0x3f, sizeof(f));
    for (int l = 1; l &lt; k; ++l)
        for (int i = 1; i &lt;= n - l + 1; ++i) &#123;
            int j = i + l - 1, now = 0;
            for (int p = i; p &lt;= j; ++p)
                now = now * 2 + a[p] - &#39;0&#39;;
            f[i][j][now] = 0;
        &#125;
    for (int i = 1; i &lt;= n - k + 1; ++i) &#123;
        int now = 0;
        for (int j = i; j &lt;= i + k - 1; ++j)
            now = now * 2 + a[j] - &#39;0&#39;;
        f[i][i + k - 1][c[now]] = w[now];
    &#125;
    for (int l = k + 1; l &lt;= n; ++l)
        for (int i = 1; i &lt;= n - l + 1; ++i) &#123;
            int j = i + l - 1;
            for (int p = i; p &lt; j; p += k - 1) &#123;
                for (int q = 0; q &lt; si; ++q)
                    if (!(q &gt;&gt; ((l - 1) % (k - 1) + 1)))
                        f[i][j][q] = std::max(f[i][j][q], f[i][p][q &gt;&gt; ((l - 1) % (k - 1))] + f[p + 1][j][q &amp; ((1 &lt;&lt; ((l - 1) % (k - 1))) - 1)]);
                if (l % (k - 1) == 1 || k == 2)
                    for (int q = 0; q &lt; siz; ++q)
                        f[i][j][c[q]] = std::max(f[i][j][c[q]], f[i][p][q &gt;&gt; (k - 1)] + f[p + 1][j][q &amp; ((1 &lt;&lt; (k - 1)) - 1)] + w[q]);
            &#125;
        &#125;
    std::cout &lt;&lt; *std::max_element(f[1][n], f[1][n] + si) &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;


其实一开始挺担心会不会因为写博客影响做题时间之类的。
直到发现我可以看知乎看一个上午然后代码动都不动一下 

2. Mod Mod Mod
https://codeforces.com/contest/889/problem/E

给定 \(a_{1\sim n}\)，对于所有非负整数 \(x\) 定义 \(f(x,n)=x\bmod a_n\)，\(f(x,i)=x\bmod a_i+f(x\bmod a_i,i+1)\)。
求 \(f(x,1)\) 最大值。\(n\le 2\times 10^5\)。

技巧 / 特殊性质类 DP。
小神题。注意到题意可以转化为，找到一个 \(x\)，最大化：
\[
x\bmod a_1 + x\bmod a_1\bmod a_2 + \cdots + x\bmod a_1\bmod a_2\bmod\cdots\bmod a_n.
\]
简称 \(x\bmod a_1\bmod a_2\bmod \cdots\bmod a_i\) 的值为 \(f_i\)。
这个时候我们不难注意到，\(f_i\) 肯定是单调不升的。形象化地，整个 \(f\) 序列肯定是由若干个单调下降的段组成的。并且，必定存在至少一个 \(i\)，使得 \(f_i = a_i-1\)，否则可以将所有 \(f_i\gets f_i+1\)，同时 \(\sum f\gets (\sum f) + n\)。
这启示我们关注 \(f_i\) 的值域。假设已经确定了 \(f\) 序列的一个前缀 \(f_1\sim i\)，对于任意 \(0\le k\le f_{\min}\)（注意由于单调不降，\(f_{\min} = f_i\)），我们可以将所有 \(f_j\gets f_j-k\)，得到一个新的合法的 \(f&#39;_{1\sim i}\)。
形象化地，将 \(f_{1\sim i}\) 想象为一个逐渐降低的柱状图，任意切去了一个高度的底部，并且这个高度不高于最矮的元素（即第 \(i\) 个元素）。
这时候有一个很美妙的性质，就是我们对于切之前和切之后的柱状图，其 最矮元素以上的部分 长得完全相同。然后就是神中神之 DP 状态设计。很难想象是在什么样的精神状态下凑出来这种神奇状态的，可能是某种我不了解的 trick？
令 \(dp_{i, j}\) 表示对于前缀 \(f_{1, i}\)，当切去的高度为 \(0\sim j\) 时，最矮元素以上的部分 的和都为 \(dp_{i, j}\)。那么易得 \(\sum f_{1\sim i}=j\times i + dp_{i, j}\)。
考虑转移。假设已知所有 \(dp_{i - 1, j}\)，需转移到 \(i\)，我们有三种转移路径：

\(j &lt; a_i\)：
对 \(a_i\) 取模取不动，不会产生任何影响。\(dp_{i, j}\gets dp_{i - 1, j}\)。
\(j\ge a_i\)：

让 \(i\) 承担 \(f_i=a_i-1\) 的责任。我们从 \(0\sim j\) 中找到一个满足 \(j&#39;\bmod a_i=a_i-1\) 的 \(j&#39;\)，\(j&#39;\) 肯定是越大越好，故 \(j&#39;=(\left\lfloor \dfrac {j}{a_i}\right\rfloor-1)\times a_i+(a_i-1)\)。
此时便有 \(dp_{i, a_i-1}\gets dp_{i - 1, j&#39;} + [j&#39; - (a_i-1)]\times (i-1)\)。
盲猜 \(0\sim i - 1\) 或 \(i+1\sim n\) 中会出现承担 \(f_{i&#39;}=a_{i&#39;-1}\) 的 \(i&#39;\)，故按照 \(j\) 取最大来转移。
此时有 \(dp_{i, j\bmod a_i}=dp_{i-1,j}+(j-j\bmod a_i)\times (i-1)\)。


答案即为 \(\max\{j\times n+dp_{n, j}\}\)。由于不存在 \(f_i=a_i-1\) 的 \(f\) 肯定比存在的要劣，所以我们肯定选到的是正确的答案。
注意到每个 \(i\) 只会新增 \(a_i-1\) 一个状态，故状态总数为 \(O(n)\)。把 \(dp\) 开成 map 就可以 \(O(n\log n)\) 地解决问题。

#include &lt;bits/stdc++.h&gt;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    std::cout.tie(nullptr);
#else
    freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n;
    std::cin &gt;&gt; n;
    std::vector&lt;long long&gt; a(n + 1);
    std::map&lt;long long, long long&gt; t;
    std::cin &gt;&gt; a[1];
    t[a[1] - 1] = 0;
    for (int i = 2; i &lt;= n; ++i) &#123;
        std::cin &gt;&gt; a[i];
        for (;;) &#123;
            auto p = t.lower_bound(a[i]);
            if (p == t.end())
                break;
            long long j = p-&gt;first, f = p-&gt;second;
            t[j % a[i]] = std::max(t[j % a[i]], f + (j - j % a[i]) * (i - 1));
            if (j &gt;= a[i]) &#123;
                j = (j / a[i] - 1) * a[i] + a[i] - 1;
                t[a[i] - 1] = std::max(t[a[i] - 1], f + (j - (a[i] - 1)) * (i - 1));
            &#125;
            t.erase(p);
        &#125;
    &#125;
    long long res = 0;
    for (auto i : t)
        res = std::max(res, i.first * n + i.second);
    std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;


3. StalinSort Algorithm
https://qoj.ac/problem/1456

给定排列 \(A_{1\sim n}\)。从 \(i=2\) 开始往右扫，每一步执行以下操作：

若 \(A_i&gt; A_{i-1}\)，什么也不做。
否则，你可以删除 \(A_{i-1}\) 或 \(A_i\)，但要求删除后，该前缀必须单调递增。

问最少可以删除多少个数。\(n\le 10^5\)。

你会发现删最少 = 留最多。
考虑 \(i\) 能够转移到的 \(j(j&gt;i)\) 需满足的条件。若令 \(nex_p\) 表示 \(p\) 之后第一个值比 \(a_p\) 大的元素，则 \(j\in [nex_i, nex_{nex_i})\) 且 \(a_j&gt;a_i\)。
赛时误认为右端点为 \(i\) 之后第二个值比 \(a_i\) 大的元素，导致完全寄掉。
时间复杂度 \(O(n^2)\)，考虑优化。注意到如果只有 \(j\in [nex_i, nex_{nex_i})\) 这个条件很容易用线段树维护，考虑消去 \(a_j&gt;a_i\) 的影响。故考虑按 \(a\) 从小到大 的顺序选取 \(i\)，因为当前最小的 \(i\) 一定已经被刷完表了。
时间复杂度 \(O(n\log n)\)。

#include &lt;bits/stdc++.h&gt;
const int maxn = 5e5 + 5;
const int inf = 0x3f3f3f3f;
struct _ &#123; int u, d; &#125; t1[maxn &lt;&lt; 2];
int n, t[maxn &lt;&lt; 2];
#define lt (p &lt;&lt; 1)
#define rt (lt | 1)
void upd(int p, int l, int r, int x, int v) &#123;
    t[p] = std::min(t[p], v);
    if (l == r)
        return;
    int mid = (l + r) &gt;&gt; 1;
    if (x &lt;= mid)
        upd(lt, l, mid, x, v);
    else
        upd(rt, mid + 1, r, x, v);
    return;
&#125;
int ask(int p, int l, int r, int ql, int qr) &#123;
    if (ql &lt;= l &amp;&amp; r &lt;= qr)
        return t[p];
    int mid = (l + r) &gt;&gt; 1, res = n + 1;
    if (ql &lt;= mid)
        res = ask(lt, l, mid, ql, qr);
    if (qr &gt; mid)
        res = std::min(res, ask(rt, mid + 1, r, ql, qr));
    return res;
&#125;
void pushdown(int p) &#123;
    if (t1[p].d) &#123;
        t1[lt].u = std::max(t1[lt].u, t1[p].d);
        t1[lt].d = std::max(t1[lt].d, t1[p].d);       
        t1[rt].u = std::max(t1[rt].u, t1[p].d);
        t1[rt].d = std::max(t1[rt].d, t1[p].d);       
        t1[p].d = 0;
    &#125;
    return;
&#125;
void upd(int p, int l, int r, int ql, int qr, int v) &#123;
    t1[p].u = std::max(t1[p].u, v);
    if (ql &lt;= l &amp;&amp; r &lt;= qr) &#123;
        t1[p].d = std::max(t1[p].d, v);
        return;
    &#125;
    pushdown(p);
    int mid = (l + r) &gt;&gt; 1;
    if (ql &lt;= mid)
        upd(lt, l, mid, ql, qr, v);
    if (qr &gt; mid)
        upd(rt, mid + 1, r, ql, qr, v);
    return;
&#125;
int ask(int p, int l, int r, int x) &#123;
    if (l == r)
        return t1[p].u;
    pushdown(p);
    int mid = (l + r) &gt;&gt; 1;
    if (x &lt;= mid)
        return ask(lt, l, mid, x);
    return ask(rt, mid + 1, r, x);
&#125;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    std::cout.tie(nullptr);
#else
    freopen(&quot;sort3.in&quot;, &quot;r&quot;, stdin);
    // freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int res = 0;
    std::cin &gt;&gt; n;
    std::vector&lt;int&gt; a(n + 1), ne(n + 1), f(n + 1);
    std::fill(t + 1, t + 4 * n + 1, n + 1);
    std::fill(t1 + 1, t1 + 4 * n + 1, (_)&#123; -inf, 0 &#125;);
    for (int i = 1; i &lt;= n; ++i)
        std::cin &gt;&gt; a[i];
    for (int i = n; ~i; --i) &#123;
        ne[i] = ask(1, 0, n, a[i] + 1, n);
        upd(1, 0, n, a[i], i);   
    &#125;
    std::vector&lt;int&gt; id(n + 1);
    std::iota(id.begin(), id.end(), 0);
    std::sort(id.begin(), id.end(), [&amp;](int x, int y) &#123; return a[x] &lt; a[y]; &#125;);
    f[0] = 0;
    for (int i = 0; i &lt;= n; ++i) &#123;
        if (i) &#123;
            f[id[i]] = ask(1, 0, n, id[i]);
            res = std::max(res, f[id[i]]);
        &#125;
        if (ne[id[i]] &lt;= n)
            upd(1, 0, n, ne[id[i]], ne[ne[id[i]]] - 1, f[id[i]] + 1);
    &#125;
    std::cout &lt;&lt; n - res &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;


4. Merge Triplets
https://atcoder.jp/contests/agc043/tasks/agc043_d

给定 \(A_{1\sim 3N}=\{1, 2, \dots, 3N\}\)，从 \(1\) 开始每 \(3\) 个数分为一组，每一组初始有一个指针指向第一个元素。执行若干次以下操作：

在所有指针指向的数中选择一个最小的，把它放到序列末（不会加入末端的组）；将原本指向它的指针后移一位，如果移出原本的组就删除这个指针。

问任意次操作后，可能得到多少种序列。\(n\le 2\times 10^3\)。

由于要对合法的最终序列进行计数，考虑最终序列的性质。
若序列中 \(a_{i+1}&lt;a_i\)，则说明在某一组中，值为 \(a_i\) 的元素下一个就是 \(a_{i+1}\)。否则，因 \(a_{i+1}\) 可选且比 \(a_i\) 小，\(a_{i+1}\) 应排在 \(a_i\) 前面。
否则，\(a_{i+1}\) 既可以与 \(a_i\) 不在同一组，也可以是 \(a_i\) 的下一个元素。
一组最多三个元素，也就是说，不能出现 \(a_i&gt;a_{i+1},a_{i+2},a_{i+3}\) 的情况。而 \(N=1\) 时序列长度只有 \(3\)，这就是为什么样例一的答案为 \(3!\)。
但这个限制并不能排除所有非法情况。\(N=2\) 时暴搜我们目前限制下的解，共有 276 个，比答案中的 261 个要多，说明包含了其他非法解。
暴搜输出并观察，易得这 15 个非法序列即为满足目前限制且存在 \(3\) 个 \(i\)，满足 \(a_i&gt;a_{i+1}\) 且 \(a_i&lt;a_{i+2}\) 的所有序列，由前面的推导，必须分为三个长度为 2 的组，而我们要求的是长度为 3 的组。显然无法用前者组合得到后者。
在我们第一个条件的限制下，必须被分到同一组的数的连续长度，只有 \(1,2,3\) 三种。而：

长度为 3 的对答案合法性无影响；
而长度为 1 的既可以和 2 组为一组，也可以和其他两个 1 组为一组；
长度为 2 的只能和 1 组成一组。

这时，我们发现所有限制都指向长度为 2 的段，其总个数不能比长度为 1 的段多。
于是乎，上述限制可总结为两点：

若令所有满足 \(a_l&gt;\max\{a_{l\sim r}\}\) 的极大区间为一段（易证每段互不重合且覆盖全序列），那么其长度不能超过 3。
其中，长度为 2 的个数不能比长度为 1 的个数多。

令 \(f_{i, j}\) 表示若当前枚举的最后一段右端点为 \(i\)，长度为 1 的段比长度为 2 的段多 \(j\) 的方案数。
最后答案即为 \(\sum\limits_{j=0}^n f_{i, j}\)。

#include &lt;bits/stdc++.h&gt;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    std::cout.tie(nullptr);
#else
    freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n, mod;
    std::cin &gt;&gt; n &gt;&gt; mod;
    n *= 3;
    std::vector&lt;std::unordered_map&lt;int, long long&gt; &gt; f(n + 1);
    f[0][0] = 1;
    for (int i = 0; i &lt; n; ++i)
        for (auto [j, k] : f[i]) &#123;
            (f[i + 1][j + 1] += k) %= mod;
            if (i + 2 &lt;= n)
                (f[i + 2][j - 1] += k * (i + 1) % mod) %= mod;
            if (i + 3 &lt;= n)
                (f[i + 3][j] += k * (i + 1) % mod * (i + 2) % mod) %= mod;
        &#125;
    long long res = 0;
    for (int i = 0; i &lt;= n; ++i)
        (res += f[n][i]) %= mod;
    std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;


5. Runaway Quail
https://qoj.ac/problem/5978

数轴上有 \(n\) 只鸡，初始位置为非 \(0\) 整数 \(p_i\)，奔跑速度为 \(s_i\)。你初始在 \(0\) 位置，奔跑速度为 \(Y(Y&gt;s_i)\)。你要抓到所有鸡。
你可以在任意时刻调转方向；鸡总会朝着远离你的方向奔跑；当你的坐标和鸡重合时，你抓到鸡。
问抓到所有鸡的最短时间（显然是个实数）。\(n\le 500\)。

容易发现鸡的奔跑方向从始至终不会变，如果我们要从往左追变成往右追，显而易见地我们会在追上右边第一只鸡前经过原点，反之同理。
那么有一个很神奇的状态设计，设 \(f_{i,j}\) 为追上了左边速度第 \(1\sim i - 1\) 大的所有鸡和右边速度第 \(1\sim j - 1\) 大的所有鸡，然后跑回原点的最小时间，这样我们就不用记录这个非常难记录的当前位置信息，对于速度排名 \(\ge i,j\) 的所有鸡，当前是否追上我们并不关心——如果其位置比较远，那么我们会在后续转移中再考虑；如果其位置比较近，在解决速度排名 \(&lt;i,j\) 的鸡时就已经抓住。
我们 \(O(n)\) 枚举上一次反向是在抓住哪一只鸡时，然后让中间全部同向跑即可。
也就是说，假设我们要用 \(f_{i,j}\) 更新 \(f_{k,j}\)（\(k&lt;i\)），那么只需要更新抓住速度排名 \(i\sim k+1\) 中跑得最远的一只鸡所需额外时间。按速度排序后可以线性算代价。

#include &lt;bits/stdc++.h&gt;
const long double eps = 1e-12;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int T;
    for (std::cin &gt;&gt; T; T--; ) &#123;
        int v, n;
        std::cin &gt;&gt; v &gt;&gt; n;
        std::vector&lt;std::pair&lt;int, int&gt; &gt; a(n + 1);
        for (int i = 1; i &lt;= n; ++i)
            std::cin &gt;&gt; a[i].first;
        for (int i = 1; i &lt;= n; ++i)
            std::cin &gt;&gt; a[i].second;
        a.emplace_back(0, 0), ++n;
        std::sort(a.begin() + 1, a.end());
        int p = std::lower_bound(a.begin() + 1, a.end(), std::make_pair(0, 0)) - a.begin();
        std::sort(a.begin() + 1, a.begin() + p, [](std::pair&lt;int, int&gt; x, std::pair&lt;int, int&gt; y) &#123; return x.second == y.second ? x.first &lt; y.first : x.second &gt; y.second; &#125;);
        std::sort(a.begin() + p + 1, a.end(), [](std::pair&lt;int, int&gt; x, std::pair&lt;int, int&gt; y) &#123; return x.second == y.second ? x.first &lt; y.first : x.second &lt; y.second; &#125;);
        std::vector&lt;std::vector&lt;long double&gt; &gt; f(n + 1, std::vector&lt;long double&gt; (n + 1, 1e18));
        f[1][n] = 0.;
        auto at = [&amp;](int i, long double t) &#123;
            return std::fabs(a[i].first + t * a[i].second * (i &lt; p ? -1 : 1));
        &#125;;
        auto calc = [&amp;](int i, long double t) &#123;
            return at(i, t) / (v - a[i].second);
        &#125;;
        // for (int i = 1; i &lt;= n; ++i)
        //     printf(&quot;%d: (%d, %d)\n&quot;, i, a[i].first, a[i].second);
        for (int i = 1; i &lt;= p; ++i)
            for (int j = n; j &gt;= p; --j) &#123;
                if (i == p &amp;&amp; j == p)
                    break;
                long double d = 0.;
                // printf(&quot;[%d, %d]: %lf\n&quot;, i, j, f[i][j]);
                for (int k = i; k &lt; p; ++k) &#123;
                    if (at(k, f[i][j]) &gt;= at(i, f[i][j]) - eps)
                        d = std::max(d, calc(k, f[i][j]));
                    // printf(&quot;  k1 = %d, d = %lf\n&quot;, k, d);
                    f[k + 1][j] = std::min(f[k + 1][j], f[i][j] + d + (k != j - 1) * d);
                &#125;
                d = 0.;
                for (int k = j; k &gt; p; --k) &#123;
                    if (at(k, f[i][j]) &gt;= at(j, f[i][j]) - eps)
                        d = std::max(d, calc(k, f[i][j]));
                    // printf(&quot;  k2 = %d, d = %lf\n&quot;, k, d);
                    f[i][k - 1] = std::min(f[i][k - 1], f[i][j] + d + (k != i + 1) * d);
                &#125;
            &#125;
        &#123;
            static int casetot = 0;
            std::cout &lt;&lt; &quot;Case #&quot; &lt;&lt; ++casetot &lt;&lt; &quot;: &quot;;
        &#125;
        std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(9) &lt;&lt; f[p][p] &lt;&lt; &#39;\n&#39;;
    &#125;
    return 0;
&#125;


6. The Great Marathon
https://codeforces.com/problemset/problem/38/H

给定一个 \(n\) 个点 \(m\) 条边的无向连通图，点 \(i\) 上初始有选手 \(i\)。为每个选手任意指定终点（可重复），那么最后的排名按照最短路为第一关键字、编号为第二关键字排序。
现按照排名序列分成前中后三段，记为金银铜牌；满足金牌数在 \([g_1,g_2]\) 之间，银牌数在 \([s_1,s_2]\) 之间。任意指定发牌数量和每个人的终点，问最后有多少种方案数；两个方案不同当且仅当有至少一个人拿的牌不一样。
\(n\le 50,m\le 1000\)。

\(n=50\)：可能需要考虑 \(n^5\) 做法。
发现是 需要确定顺序的 DP。关键位置自然在于『金银、银铜界处』。考虑钦定金牌最后一名、铜牌第一名的人选（不考虑中间的银牌是因为会出现这样那样的问题），还需要枚举他们的路程吗？并不。甚而至于，这样做会算重。
考虑『最小化』左右两侧的金牌、铜牌可选集合。强行让金牌最后一名 \(u\) 的路程为 \(\min\{dis_{u,i}\}\)，最小路程小于这个值的所有元素都可以成为金牌；同时让铜牌第一名 \(v\) 的路程为 \(\max\{dis_{v,i}\}\)，最大路程大于这个值的所有数都可以成为铜牌。
Q1: 如果存在一个 \(i\)，它最小的距离也比 \(u\) 的最小距离大，但实际上当 \(u\) 更大一点儿的时候，\(i\) 可以成为金牌呢？
A1：这种情况在钦定 \(i\) 为最后一名的时候讨论过了。
Q2：是否会算重？
A2：如上所述，假如在钦定 \(i\) 的时候统计了 \(u\)，那么在钦定 \(u\) 的时候就不会统计 \(i\)。
考虑转移。令 \(f_{i,u,v,j,k}\) 为考虑到 \(i\)，金牌倒一为 \(u\)，铜牌第一为 \(v\)，选了 \(j\) 个金、\(k\) 个铜的方案数。转移是 \(O(1)\) 的。

注意 vector 要开在循环外面，不然申请空间很耗时间 /ll
#include &lt;bits/stdc++.h&gt;
const int inf = 0x3f3f3f3f;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n, m;
    std::cin &gt;&gt; n &gt;&gt; m;
    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1, std::vector&lt;int&gt; (n + 1, inf));
    for (int x, y; m--; ) &#123;
        std::cin &gt;&gt; x &gt;&gt; y;
        std::cin &gt;&gt; g[x][y], g[y][x] = g[x][y];
    &#125;
    for (int i = 1; i &lt;= n; ++i)
        g[i][i] = 0;
    for (int k = 1; k &lt;= n; ++k)
        for (int i = 1; i &lt;= n; ++i)
            if (k != i)
                for (int j = 1; j &lt;= n; ++j)
                    if (i != k &amp;&amp; j != k)
                        g[i][j] = std::min(g[i][j], g[i][k] + g[k][j]);
    int g1, g2, s1, s2;
    std::cin &gt;&gt; g1 &gt;&gt; g2 &gt;&gt; s1 &gt;&gt; s2;
    for (int i = 1; i &lt;= n; ++i)
        for (int j = 1; j &lt;= n; ++j)
            if (g[i][j] != inf)
                g[i][j] = g[i][j] * n + i;
    std::vector&lt;int&gt; mx(n + 1), mn(n + 1, inf);
    for (int i = 1; i &lt;= n; ++i) &#123;
        for (int j = 1; j &lt;= n; ++j)
            if (j != i)
                mn[i] = std::min(mn[i], g[i][j]);
        mx[i] = *std::max_element(g[i].begin() + 1, g[i].end());
    &#125;
    auto res(0ll);
    std::vector&lt;std::vector&lt;std::vector&lt;long long&gt; &gt; &gt; f(n + 1, std::vector&lt;std::vector&lt;long long&gt; &gt; (n + 1, std::vector&lt;long long&gt; (n + 1)));
    for (int u = 1; u &lt;= n; ++u)
        for (int v = 1; v &lt;= n; ++v)
            if (v != u) &#123;
                f[0][1][1] = 1ll;
                for (int i = 1; i &lt;= n; ++i)
                    if (i == u || i == v)
                        f[i] = f[i - 1];
                    else &#123;
                        bool flag = 0;
                        for (int j = 1; j &lt;= n; ++j)
                            if (mn[u] &lt; g[i][j] &amp;&amp; g[i][j] &lt; mx[v]) &#123;
                                flag = 1;
                                break;
                            &#125;
                        for (int j = 1; j &lt;= g2; ++j)
                            for (int k = 1; k &lt;= n - g1 - s1; ++k) &#123;
                                f[i][j][k] = 0ll;
                                if (mx[i] &lt; mn[u])
                                    f[i][j][k] = f[i - 1][j - 1][k];
                                else if (mn[i] &gt; mx[v])
                                    f[i][j][k] = f[i - 1][j][k - 1];
                                else &#123;
                                    if (flag)
                                        f[i][j][k] = f[i - 1][j][k];
                                    if (mn[i] &lt; mn[u])
                                        f[i][j][k] += f[i - 1][j - 1][k];
                                    if (mx[i] &gt; mx[v])
                                        f[i][j][k] += f[i - 1][j][k - 1];
                                &#125;
                            &#125;
                    &#125;
                for (int g = g1; g &lt;= g2; ++g)
                    for (int s = s1; s &lt;= s2; ++s)
                        res += f[n][g][n - g - s];
            &#125;
    std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;


7. Sorting Pancakes
https://codeforces.com/contest/1675/problem/G

给定盒子 \(1\sim n\) 和每个盒子 \(i\) 里的初始球数 \(a_i\)，每次可以选择一个球移动到相邻盒子，最后欲使盒子内球数单调不升,求最小移球次数。
\(n,\sum a_i\le 250\)。

简单题！这种『移动元素的题』，会考虑钦定每个元素最终的值，把前面的元素富余的 / 欠下来的存储起来。当然也有例外，比如添加了『时间』这一维的限制，goto solu to Pass to Next
在如果在 \(i\) 处富余了 \(x\)，那么在移动到 \(i+1\) 的过程中就会产生 \(|x|\) 的代价。
令 \(f_{i,k,j}\) 表示第 \(i\) 个元素处，钦定它最终为 \(j\)，富余 \(k\)，则 \(f_{i,k,j}\gets \min\limits_{j&#39;\ge j}\{f_{i-1, k-(j-a_i),j&#39;}\}\)。显而易见后缀 min 优化就能 \(O(n\cdot m^2)\) 地做了。

DP 数组和后缀 min 数组要合起来，不然会 MLE /ll
#include &lt;bits/stdc++.h&gt;
const int inf = 0x3f3f3f3f;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n, m;
    std::cin &gt;&gt; n &gt;&gt; m;
    std::vector&lt;int&gt; a(n + 1);
    for (int i = 1; i &lt;= n; ++i)
        std::cin &gt;&gt; a[i];
    using arr = std::vector&lt;int&gt;;
    using brr = std::vector&lt;arr&gt;;
    using crr = std::vector&lt;brr&gt;;
    crr f(n + 1, brr(2 * m + 1, arr(m + 1, inf)));
    std::fill(f[0][m].begin(), f[0][m].begin() + m + 1, 0);
    for (int i = 1; i &lt;= n; ++i)
        for (int k = 0; k &lt;= 2 * m; ++k)
            for (int j = std::min(m, k + a[i]); j &gt;= std::max(0, k + a[i] - 2 * m); --j) &#123;
                f[i][k][j] = f[i - 1][k - (j - a[i])][j] + std::abs(k - m);
                if (j != m)
                    f[i][k][j] = std::min(f[i][k][j], f[i][k][j + 1]);
            &#125;
    std::cout &lt;&lt; f[n][m][0] &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;


8. Complexity
https://atcoder.jp/contests/agc033/tasks/agc033_d

给定 \(n\times m\) 的 \(01\) 矩阵。定义其子矩阵的凌乱度：

若该矩阵中只有一种值，凌乱度为 \(0\)。
否则，任意竖直 / 水平切一刀，得到两个小矩阵；若它们的凌乱度分别为 \(a,b\)，则大矩阵的凌乱度为 \(\max(a,b)+1\) 的最小值。

求给定矩阵的凌乱度。\(n,m\le 185\)。

如果暴力枚举 DP，很不幸是 \(n^5\) 的。考虑优化。发现矩阵的凌乱度大致在 \(O(\log n)\) 级别，考虑用状态交换答案减小复杂度。具体地，设 \(f_{k,u,d,l}\) 表示凌乱度 \(\le k\) 时，\(r\) 可取到的最大值，那么有转移：

竖着切一刀，枚举切点 \(i\le f_{k-1,u,d,l}\)，有 \(f_{k,u,d,l}\gets f_{k-1,u,d,i+1}\)。发现显然 \(i\) 取 \(f_{k-1,u,d,l}\) 的时候最优，这个是 \(O(1)\) 的。
横着切一刀，枚举切点 \(i\in[u,d)\)，有 \(f_{k,u,d,l}\gets \min(f_{k-1,u,i,l},f_{k-1,i+1,d,l})\)。发现随 \(i\) 增大左边单调不增，右边单调不降。随着 \(d\) 的增大，左边不变，右边下移，交出来的交点一直右移。然后就可以优化到均摊 \(O(1)\)。


#include &lt;bits/stdc++.h&gt;
const int inf = 0x3f3f3f3f;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n, m;
    std::cin &gt;&gt; n &gt;&gt; m;
    std::vector&lt;std::vector&lt;char&gt; &gt; a(n + 1, std::vector&lt;char&gt; (m + 1));
    for (int i = 1; i &lt;= n; ++i)
        for (int j = 1; j &lt;= m; ++j)
            std::cin &gt;&gt; a[i][j];
    using arr = std::vector&lt;int&gt;;
    using brr = std::vector&lt;arr&gt;;
    using crr = std::vector&lt;brr&gt;;
    std::vector&lt;std::string&gt; res;
    std::vector&lt;crr&gt; _f(2, crr(n + 1, brr(m + 1, arr(n + 1))));
    for (int k = 0; ; ++k) &#123;
        auto &amp;f = _f[k &amp; 1], &amp;f1 = _f[(k &amp; 1) ^ 1];
        if (k == 0) &#123;
            crr tag(m + 1, brr(n + 1, arr(n + 1, -1)));
            for (int l = 1; l &lt;= m; ++l)
                for (int u = 1; u &lt;= n; ++u)
                    for (int d = u; d &lt;= n &amp;&amp; a[d][l] == a[u][l]; ++d)
                        tag[l][u][d] = a[u][l];
            for (int u = 1; u &lt;= n; ++u)
                for (int d = u; d &lt;= n; ++d)
                    for (int l = m; l; --l) &#123;
                        f[u][l][d] = l - 1;
                        if (~tag[l][u][d]) &#123;
                            if (l != m &amp;&amp; tag[l][u][d] == tag[l + 1][u][d])
                                f[u][l][d] = f[u][l + 1][d];
                            else
                                f[u][l][d] = l;
                        &#125;
                    &#125;
        &#125;
        else
            for (int u = 1; u &lt;= n; ++u)
                for (int l = 1; l &lt;= m; ++l)
                    for (int d = u, pos = 1; d &lt;= n; ++d) &#123;
                        f[u][l][d] = f1[u][l][d];
                        if (f[u][l][d] != m) &#123;
                            f[u][l][d] = std::max(f[u][l][d], f1[u][f1[u][l][d] + 1][d]);
                            int mx = 0;
                            for (int i = pos; i &lt; d; ++i) &#123;
                                if (std::min(f1[u][l][i], f1[i + 1][l][d]) &gt;= mx)
                                    mx = std::min(f1[u][l][i], f1[i + 1][l][d]), pos = i;
                                else
                                    break;
                            &#125;
                            f[u][l][d] = std::max(f[u][l][d], mx);
                        &#125;
                    &#125;
        if (f[1][1][n] == m) &#123;
            std::cout &lt;&lt; k &lt;&lt; &#39;\n&#39;;
            return 0;
        &#125;
    &#125;
    return 0;
&#125;


9. Boxes and Balls
https://www.luogu.com.cn/problem/CF1845E

给定一个长度为 \(n\) 的 \(01\) 序列 \(a_{1\sim n}\)。你可以进行恰好 \(k\) 次如下操作：

选择序列中一对相邻且值不同的元素，将它们交换。

问有多少种最终序列。\(n,k\le 1500\)。

沿用 7. Sorting Pancakes 的思路，考虑令 \(f_{i,j,l}\) 表示最终序列的前 \(i\) 个里有 \(j\) 个 \(1\)，代价已经有 \(l\) 的方案数；那么令 \(s_i\) 为 \(a\) 的前缀和，显然有：
\[
f_{i+1,j+1,k+|j-s_i|}\gets f_{i,j,k}\\
f_{i+1,j,k+|j-s_i|}\gets f_{i,j,k}
\]
最后在比 \(k\) 小且奇偶性和 \(k\) 相同的 \(l\) 里找答案。然后想怎么优化。
答案是不用优化。考虑有效状态数，打个表发现每个 \(i\) 在 \(O(n\sqrt n)\) 左右，但有另一种方法是发现有效的 \(|j-s_i|\) 不会超过 \(O(\sqrt n)\)（原因：为了消除 \(|j-s_i|\) 的欠账，需要 \(|j-s_i|\) 个位置；每个位置都会有差不多 \(|j-s_i|\) 的代价），所以枚举时只用枚举 \(O(\sqrt n)\) 个 \(j\)。
总之只用存有效状态会发现跑不满 

#include &lt;bits/stdc++.h&gt;
const int mod = 1e9 + 7;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n, k;
    std::cin &gt;&gt; n &gt;&gt; k;
    std::vector&lt;int&gt; a(n + 1), s(n + 1);
    for (int i = 1; i &lt;= n; ++i)
        std::cin &gt;&gt; a[i];
    std::partial_sum(a.begin() + 1, a.end(), s.begin() + 1);
    using arr = std::vector&lt;long long&gt;;
    using brr = std::vector&lt;arr&gt;;
    using crr = std::vector&lt;brr&gt;;
    brr tag(n + 1, arr(n + 1));
    std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; stt(2);
    stt[0].emplace_back(0, 0);
    crr _f(2, brr(n + 1, arr(k + 1)));
    _f[0][0][0] = 1;
    for (int i = 0; i &lt; n; ++i) &#123;
        auto &amp;f = _f[i &amp; 1], &amp;f1 = _f[(i &amp; 1) ^ 1];
        std::vector&lt;std::pair&lt;int, int&gt; &gt;().swap(stt[(i &amp; 1) ^ 1]);
        for (auto [j, l] : stt[i &amp; 1]) &#123;
                if (j + 1 &lt;= s[n] &amp;&amp; l + std::abs(j - s[i]) &lt;= k) &#123;
                    if (tag[j + 1][l + std::abs(j - s[i])] != i + 1)
                        tag[j + 1][l + std::abs(j - s[i])] = i + 1, stt[(i &amp; 1) ^ 1].emplace_back(j + 1, l + std::abs(j - s[i])), f1[j + 1][l + std::abs(j - s[i])] = 0ll;
                    (f1[j + 1][l + std::abs(j - s[i])] += f[j][l]) %= mod;
                &#125;
                if (l + std::abs(j - s[i]) &lt;= k) &#123;
                    if (tag[j][l + std::abs(j - s[i])] != i + 1)
                        tag[j][l + std::abs(j - s[i])] = i + 1, stt[(i &amp; 1) ^ 1].emplace_back(j, l + std::abs(j - s[i])), f1[j][l + std::abs(j - s[i])] = 0ll;
                    (f1[j][l + std::abs(j - s[i])] += f[j][l]) %= mod;
                &#125;
            &#125;
        std::cout &lt;&lt; (int)stt[i &amp; 1].size() &lt;&lt; &#39;\n&#39;;
    &#125;
    auto res(0ll);
    for (int i = k &amp; 1; i &lt;= k; i += 2)
        if (tag[s[n]][i] == n)
            (res += _f[n &amp; 1][s[n]][i]) %= mod;
    std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;


10. LEGOndary Grandmaster
https://codeforces.com/problemset/problem/1615/F

给定两个长度为 \(n\) 的 \(0/1/?\) 串 \(s,t\)，你可以对 \(s\) 进行若干次如下操作：

选择序列中一对相邻且值相同的元素，将它们取反。

现任意将 \(s\) 和 \(t\) 中的 ? 填为 \(0/1\)，问所有情况中 \(s\) 转化为 \(t\) 所需最小操作次数和（规定无解的操作次数为 \(0\)）。\(n\le 2000\)。

如果我们之前做过某些令人心（咬）旷（牙）神（切）怡（齿）的题目，会发现这个操作等价于交换任意两个相邻数，再让他们取反。
进一步地，可以交换运算顺序，先取反某个位置，再交换，再取反这个位置——把这个操作平均分配到 \(s\) 和 \(t\) 上，结合『相邻两数位置必一奇一偶』这个美妙的性质，想到把 \(s\) 和 \(t\) 的奇数位都提前取反，这样就可以转化成直接交换了，
接下来就和上一题有点不一样了。这里我们直接算一个位置的贡献——这意味着不需要统计一个序列的代价（此时失去了 \(k\) 的限制，代价来到 \(n^2\) 级别）。令 \(f_{i,j}\) 表示从前往后到了第 \(i\) 个位置，欠债为 \(j\) 的方案数；同样地，令 \(g_{i,j}\) 表示从后到前到了第 \(i\) 个位置，欠债为 \(j\) 的方案数。则贡献为 \(\sum_i \sum_j f_{i, j}\times g_{i + 1, -j}\times j\)。

#include &lt;bits/stdc++.h&gt;
const int mod = 1e9 + 7;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int T;
    for (std::cin &gt;&gt; T; T--; ) &#123;
        int n;
        std::string s, t;
        std::cin &gt;&gt; n &gt;&gt; s &gt;&gt; t, s = &#39;#&#39; + s, t = &#39;#&#39; + t;
        for (int i = 1; i &lt;= n; ++i)
            if (i &amp; 1) &#123;
                if (s[i] != &#39;?&#39;)
                    s[i] = &#39;0&#39; + &#39;1&#39; - s[i];
                if (t[i] != &#39;?&#39;)
                    t[i] = &#39;0&#39; + &#39;1&#39; - t[i];
            &#125;
        using arr = std::vector&lt;long long&gt;;
        using brr = std::vector&lt;arr&gt;;
        brr f(n + 1, arr(2 * n + 1)), g(n + 2, arr(2 * n + 1));
        f[0][n] = 1ll;
        for (int i = 1; i &lt;= n; ++i) &#123;
            for (int S = 0; S &lt;= 1; ++S)
                if ((S == 0 &amp;&amp; s[i] == &#39;1&#39;) || (S == 1 &amp;&amp; s[i] == &#39;0&#39;));
                else
                    for (int T = 0; T &lt;= 1; ++T) &#123;
                        if ((T == 0 &amp;&amp; t[i] == &#39;1&#39;) || (T == 1 &amp;&amp; t[i] == &#39;0&#39;));
                        else
                            for (int j = 0; j &lt;= 2 * n; ++j)
                                if (j - (T - S) &gt;= 0 &amp;&amp; j - (T - S) &lt;= 2 * n)
                                    (f[i][j] += f[i - 1][j - (T - S)]) %= mod;
                    &#125;
        &#125;
        g[n + 1][n] = 1ll;
        for (int i = n; i; --i) &#123;
            for (int S = 0; S &lt;= 1; ++S)
                if ((S == 0 &amp;&amp; s[i] == &#39;1&#39;) || (S == 1 &amp;&amp; s[i] == &#39;0&#39;));
                else
                    for (int T = 0; T &lt;= 1; ++T) &#123;
                        if ((T == 0 &amp;&amp; t[i] == &#39;1&#39;) || (T == 1 &amp;&amp; t[i] == &#39;0&#39;));
                        else
                            for (int j = 0; j &lt;= 2 * n; ++j)
                                if (j - (T - S) &gt;= 0 &amp;&amp; j - (T - S) &lt;= 2 * n)
                                    (g[i][j] += g[i + 1][j - (T - S)]) %= mod;
                    &#125;
        &#125;
        auto res(0ll);
        for (int i = 1; i &lt; n; ++i)
            for (int j = 1; j &lt;= n; ++j) &#123;
                (res += j * f[i][n + j] % mod * g[i + 1][n - j] % mod) %= mod;
                (res += j * f[i][n - j] % mod * g[i + 1][n + j] % mod) %= mod;
            &#125;
        std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
    &#125;
    return 0;
&#125;

]]></content>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>杂题选谈</title>
    <url>/20241017/</url>
    <content><![CDATA[好消息：会简单数学题 
更好的消息：忘取模了 


A. distorted
https://www.becoder.com.cn/contest/5611/problem/1
考虑最多需要多少个元素。最坏情况是选取四个角的元素，已经可以覆盖整个矩阵。进一步考虑感性反证发现无论如何都选不出来五个，故最多选择四个。
我们发现，选取中间一个就可以覆盖整个矩阵。扩展一下，选择中间列就可以覆盖上 / 下半个矩阵，选择中间行就可以覆盖左 / 右半个矩阵。剩下的选择过后只能保证照顾到对应的 1/4 矩阵且一定不会完全覆盖其他的 1/4 矩阵。
我们发现，中心元素地位高于中间行 / 列元素高于左上、左下、右上、右下元素。由此出发讨论选择元素的个数。

1 个：选择中心元素。
2 个：在中间行的左右两边各选一个 / 在中间列的上下两边各选一个。
3 个：选一个中间行 / 列 + 两个其他元素，或两个中间行 / 列 + 一个其他元素。
4 个：左上、左下、右上、右下各选一个。

统计各个方向的最小值，选最小组合即可。

#include &lt;bits/stdc++.h&gt;
#define putchar
const long long inf = 0x3f3f3f3f;
int main() &#123;
    freopen(&quot;distorted.in&quot;, &quot;r&quot;, stdin);
    freopen(&quot;distorted.out&quot;, &quot;w&quot;, stdout);
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
    int T;
    for (std::cin &gt;&gt; T; T--; ) &#123;
        int n;
        std::cin &gt;&gt; n;
        long long to = inf, u = inf, d = inf, l = inf, r = inf, q = inf, z = inf, p = inf, m = inf;
        for (int i = 1; i &lt;= n; ++i)
            for (int j = 1; j &lt;= n; ++j) &#123;
                long long x;
                std::cin &gt;&gt; x;
                if (i * 2 - 1 == n &amp;&amp; j * 2 - 1 == n)
                    to = x;
                else if (i * 2 - 1 == n &amp;&amp; j * 2 - 1 &lt; n)
                    l = std::min(l, x);
                else if (i * 2 - 1 == n)
                    r = std::min(r, x);
                else if (i * 2 - 1 &lt; n &amp;&amp; j * 2 - 1 == n)
                    u = std::min(u, x);
                else if (j * 2 - 1 == n)
                    d = std::min(d, x);
                else if (i * 2 - 1 &lt; n &amp;&amp; j * 2 - 1 &lt; n)
                    q = std::min(q, x);
                else if (i * 2 - 1 &lt; n)
                    p = std::min(p, x);
                else if (j * 2 - 1 &lt; n)
                    z = std::min(z, x);
                else
                    m = std::min(m, x);
            &#125;
        std::cout &lt;&lt; std::min(&#123; to, l + r, u + d, l + u + m, l + d + p, r + u + z, r + d + q, u + z + m, d + q + p, l + p + m, r + q + z, q + p + z + m &#125;) &lt;&lt; &#39;\n&#39;;
    &#125;
    return 0;
&#125;


B. fate
https://www.becoder.com.cn/contest/5611/problem/2
诈骗题。对于前半段，考虑取差分数组 \(d\)，容易发现如果直接在差分数组上做减法，一定满足后面减得不比前面少。故只要满足差分数组每一项至少为 \(0\) 即可，答案为 \(\prod {i\le p} a_i - a_{i-1} + 1\)。
对于后半段，我们考虑转化成和前半段相似的问题，将后半段翻转，同样取差分数组，则此时在该差分数组上满足后面减得不比前面少，同时需要满足差分数组每一项至多为 \(0\)，前面的所有项初始为负，操作为减，自然满足；但第 \(p\) 项在把前面减去的全部加上后不一定满足。故前面最多减去 \(d_p\)，随便在哪里减都无所谓，组合意义一下，就是无标号球放有标号盒子可空放可不放，插板得答案为 \(\displaystyle {-d_p + n - p\choose n - p}\)。
前后乘起来即为答案。注意不要在最后一步乘起来的时候忘记取模，否则你会获得 76pts 的高分 

#include &lt;bits/stdc++.h&gt;
const int mod = 998244353;
int main() &#123;
    freopen(&quot;fate.in&quot;, &quot;r&quot;, stdin);
    freopen(&quot;fate.out&quot;, &quot;w&quot;, stdout);
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
    int n, m;
    std::cin &gt;&gt; n;
    std::vector&lt;long long&gt; a(n + 1);
    for (int i = 1; i &lt;= n; ++i)
        std::cin &gt;&gt; a[i];
    std::cin &gt;&gt; m;
    long long res = 1;
    for (int i = 1; i &lt; m; ++i) &#123;
        auto x = a[i] - a[i - 1];
        (res *= x + 1) %= mod;
    &#125;
    auto qkp = [](long long x, int y) &#123;
        long long res = 1;
        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)
            if (y &amp; 1)
                (res *= x) %= mod;
        return res;
    &#125;;
    auto C = [&amp;](int n, int m) &#123;
        long long res = 1ll;
        for (int i = n; i &gt; n - m; --i)
            (res *= i) %= mod;
        for (int i = m; i; --i)
            (res *= qkp(i, mod - 2)) %= mod;    
        return res;
    &#125;;
    if (m != n)
        (res *= C(a[m + 1] - a[m] + n - m, n - m)) %= mod;
    std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;


C. abstruse
https://www.luogu.com.cn/problem/P9731
注意到有挺高的一档 \(S=2\) 的分，考虑其启示意义。
我们对于一对 \((a_i, b_i)\)，在 \(a_i\) 和 \(b_i\) 间连边，则原问题转化为给无向图的每条边选择方向，使对于每个 \(x\)，\(|in_x-out_x|\le 1\)。
我们知道对于一条欧拉回路，有对于任意 \(x\)，\(in_x=out_x\)。然后这个时候为了把问题转化成欧拉回路问题我们建一个虚点朝度数为奇的点连条边然后跑欧拉回路即可。
至于 \(S=2^k\)，就是在明示分治。即对于任意 \(x\)，要求其在前后 \(2^{k-1}\) 次出现次数相差不超过 \(1\)。注意到非常幸福的有前后两个部分大小相等，又有一个天才的建图，即在每个点和自己所属的行连边，然后跑欧拉回路，出边表示选前半部分，入边表示选后半部分，这样就保证了一行中各有 \(2^{k-1}\) 个选前后半部分，也保证了每个点在前后半边出现的次数相差不超过 \(1\)。对于后面一个性质，分治最终可得到点在每一列出现次数相差不超过 \(1\)。
打个当前弧优化然后注意计算细节复杂度然后多卡几（十）遍就过了 

#include &lt;bits/stdc++.h&gt;
namespace fastIO &#123;
const int LEN = (1 &lt;&lt; 20);
#ifdef ONLINE_JUDGE
int nec(void) &#123;
    static char buf[LEN], *p = buf, *e = buf;
    if (p == e) &#123;
        e = buf + fread(buf, 1, LEN, stdin);
        if (e == buf) return EOF;
        p = buf;
    &#125;
    return *p++;
&#125;
#else
#define nec getchar
#endif
bool read(int &amp;x) &#123;
    x = 0;
    bool f = 0;
    char ch = nec();
    while (ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123;
        if (ch == EOF) return 0;
        if (ch == &#39;-&#39;) f = 1;
        ch = nec();
    &#125;
    while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) &#123;
        x = x * 10 + ch - &#39;0&#39;;
        ch = nec();
    &#125;
    if (f) x = -x;
    return 1;
&#125;
void print(int x) &#123;
    if (x &lt; 0)
        putchar(&#39;-&#39;), x = -x;
    if (x &gt;= 10) print(x / 10);
    putchar(x % 10 + &#39;0&#39;);
    return;
&#125;
void print(int x, char ch) &#123;
    print(x), putchar(ch);
    return;
&#125;
&#125; using namespace fastIO;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    std::cout.tie(nullptr);
    freopen(&quot;abstruse.in&quot;, &quot;r&quot;, stdin);
    freopen(&quot;abstruse.out&quot;, &quot;w&quot;, stdout);
#else
    freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n, m, k;
    read(n), read(m), read(k);
    std::vector&lt;std::vector&lt;int&gt; &gt; a(n + 1, std::vector&lt;int&gt; (m + 1));
    for (int i = 1; i &lt;= n; ++i)
        for (int j = 1; j &lt;= m; ++j)
            read(a[i][j]);
    std::vector&lt;int&gt; to(k + n + 1), tag(n * m + n + k + 1);
    std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; g(k + n + 1); 
    std::function&lt;void(int, int)&gt; calc = [&amp;](int l, int r) &#123;
        if (l + 1 == r) &#123;
            for (int i = 1; i &lt;= n; ++i) &#123;
                g[a[i][l]].emplace_back(a[i][r], i);
                g[a[i][r]].emplace_back(a[i][l], i);
            &#125;
            int cnt = n;
            for (int i = 1; i &lt;= n; ++i) &#123;
                if ((int)g[a[i][l]].size() &amp; 1)
                    g[0].emplace_back(a[i][l], ++cnt), g[a[i][l]].emplace_back(0, cnt);
                if ((int)g[a[i][r]].size() &amp; 1)
                    g[0].emplace_back(a[i][r], ++cnt), g[a[i][r]].emplace_back(0, cnt);
            &#125;
            std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;
                for (int i = to[x]; i &lt; (int)g[x].size(); i = to[x]) &#123;
                    to[x] = i + 1;
                    auto [v, id] = g[x][i];
                    if (!tag[id]) &#123;
                        tag[id] = 1;
                        if (x &amp;&amp; v)
                            a[id][l] = x, a[id][r] = v;
                        DFS(v);
                    &#125;
                &#125;
                return;
            &#125;;
            DFS(0);
            for (int i = 1; i &lt;= n; ++i)
                DFS(a[i][l]), DFS(a[i][r]);
            to[0] = 0, g[0].clear();
            for (int i = 1; i &lt;= n; ++i) &#123;
                to[a[i][l]] = 0, g[a[i][l]].clear();
                to[a[i][r]] = 0, g[a[i][r]].clear();
            &#125;
            std::fill(tag.begin() + 1, tag.begin() + cnt + 1, 0);
            return;
        &#125;
        int mid = (l + r) &gt;&gt; 1, cnt = 0;
        std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; g(k + n + 1);
        for (int i = 1; i &lt;= n; ++i)
            for (int j = l; j &lt;= r; ++j) &#123;
                g[a[i][j]].emplace_back(i + k, ++cnt);
                g[i + k].emplace_back(a[i][j], cnt);
            &#125;
        for (int i = 1; i &lt;= n; ++i)
            for (int j = l; j &lt;= r; ++j)
                if ((int)g[a[i][j]].size() &amp; 1)
                    g[0].emplace_back(a[i][j], ++cnt), g[a[i][j]].emplace_back(0, cnt);
        std::vector&lt;int&gt; L(n + 1, l - 1), R(n + 1, r + 1);
        std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;
            for (int i = to[x]; i &lt; (int)g[x].size(); i = to[x]) &#123;
                to[x] = i + 1;
                auto [v, id] = g[x][i];
                if (!tag[id]) &#123;
                    tag[id] = 1;
                    if (x &amp;&amp; v) &#123;
                        if (v &lt;= k)
                            a[x - k][++L[x - k]] = v;
                        else
                            a[v - k][--R[v - k]] = x;
                    &#125;
                    DFS(v);
                &#125;
            &#125;
            return;
        &#125;;
        DFS(0);
        for (int i = 1; i &lt;= n; ++i)
            DFS(i + k);
        for (int i = 1; i &lt;= n; ++i)
            for (int j = l; j &lt;= r; ++j)
                DFS(a[i][j]);
        to[0] = 0, g[0].clear();
        for (int i = 1; i &lt;= n; ++i)
            to[i + k] = 0, g[i + k].clear();
        for (int i = 1; i &lt;= n; ++i)
            for (int j = l; j &lt;= r; ++j)
                to[a[i][j]] = 0, g[a[i][j]].clear();
        std::fill(tag.begin() + 1, tag.begin() + cnt + 1, 0);
        calc(l, mid), calc(mid + 1, r);
        return;
    &#125;;
    calc(1, m);
    for (int i = 1; i &lt;= n; ++i, putchar(&#39;\n&#39;))
        for (int j = 1; j &lt;= m; ++j)
            print(a[i][j], &#39; &#39;);
    return 0;
&#125;

]]></content>
      <tags>
        <tag>分治</tag>
        <tag>欧拉回路</tag>
      </tags>
  </entry>
  <entry>
    <title>学习笔记：长链剖分</title>
    <url>/20241021-1/</url>
    <content><![CDATA[半端な生命の関数を / 少々ここらでオーバーライド


内容 &amp; 性质
把重链剖分选的 siz 最大的儿子换成高度最大的儿子就是长剖了。同样具有一些美妙的性质。

任意点到根节点经过的链数最劣为 \(\sqrt n\)。
考虑构造一条经过了 \(\sqrt n+1\) 条链的路径，发现构造不出来。得证。（？）
这点也决定了长剖和重剖走的不是一条赛道，更多的是处理一些和深度有关的场景下的问题。用法有点像 dsu on tree。
任意点 \(x\) 的 \(k\) 级祖先 \(fa\) 所在链长 \(\ge k\)。
考虑反证。若 \(fa\) 所在链长度 \(&lt;k\)，则 \(fa\to x\) 更优，矛盾。故原命题成立。


求 k 级祖先
长剖的一个典型应用是 \(O(n\log n)-O(1)\) 求 \(k\) 级祖先。先考虑相对暴力的做法，可以 \(O(n\sqrt n)\) 预处理每个点的 \(1\sim \sqrt n\) 级祖先然后块间块内随便跳一跳就是 \(O(\sqrt n)\) 的单次查询了。
把这个暴力结合「任意点 \(k\) 级祖先所在链长 \(\ge k\)」的性质，令 \(r=\dfrac k2\)，那么 \(x\) 的 \(r\) 级祖先所在链长 \(\ge r\)。假设我们现在已经知道 \(r\) 级祖先 \(fa_r\)，预处理出链内点序列、链顶向上的链长个祖先（均摊 \(O(n)\)），就可以 \(O(1)\) 访问 \(fa_k\)。
怎么找到 \(fa_r\) 呢？这看似是递归的问题，实际上发现 \(r\) 的取值只需 \(\ge \dfrac k2\)，对于 \(1\sim n\) 的每一个 \(k\)，找到其最高二进制位 \(r\)（显然 \(r\) 的可能取值有 \(\log n\) 种），对于每个点，预处理出其 \(\log n\) 个不同的 \(r\) 级祖先。这个就是倍增了。

for (int i = 1, mx = 0; i &lt;= n; ++i) &#123;
    if (i &gt;= (1 &lt;&lt; mx) * 2)
        ++mx;
    to[i] = mx;
&#125;
std::vector&lt;std::array&lt;int, 21&gt; &gt; fa(n + 1);
std::vector&lt;int&gt; h(n + 1, 1), son(n + 1), dep(n + 1);
h[0] = 0;
std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;
    for (auto i : g[x])
        if (i != fa[x][0]) &#123;
            fa[i][0] = x;
            for (int j = 1; j &lt;= 20; ++j)
                fa[i][j] = fa[fa[i][j - 1]][j - 1];
            dep[i] = dep[x] + 1;
            DFS(i);
            if (h[i] &gt;= h[son[x]])
                son[x] = i, h[x] = h[i] + 1;
        &#125;
    return;
&#125;;
dep[1] = 1, DFS(1);
std::vector&lt;int&gt; top(n + 1), id(n + 1);
std::vector&lt;std::vector&lt;int&gt; &gt; anc(n + 1), des(n + 1, std::vector&lt;int&gt; (1));
std::function&lt;void(int, int)&gt; DFS1 = [&amp;](int x, int toq) &#123;
    top[x] = toq;
    if (son[x])
        DFS1(son[x], toq);
    for (auto i : g[x])
        if (i != fa[x][0] &amp;&amp; i != son[x])
            DFS1(i, i);
    des[toq].push_back(x);
    id[x] = (int)des[toq].size() - 1;
    if (x == toq) &#123;
        anc[x].push_back(x);
        for (int j = 1, now = x; j &lt;= id[x]; ++j, now = fa[now][0])
            anc[x].push_back(fa[now][0]);
    &#125;
    return;
&#125;;
DFS1(1, 1);
auto ask = [&amp;](int x, int k) &#123;
    int x1 = x;
    if (!k)
        return x;
    x = fa[x][to[k]];
    if (dep[x] - dep[top[x]] &gt;= k - (1 &lt;&lt; to[k]))
        return des[top[x]][id[x] + k - (1 &lt;&lt; to[k])];
    return anc[top[x]][k - (1 &lt;&lt; to[k]) - (dep[x] - dep[top[x]])];
&#125;;


优化 DP

yly：管它这那的，只要是有关深度直接上长剖就是了。

和 DSU on tree 类似，主要利用每条链只会被算一次实现 \(O(n)\) DP。具体地，尽可能地『继承』长链的信息，『短链』则暴力合并。
值得注意的是，一般『深度』这一维信息会以『与 \(u\) 的距离』的形式，结合指针来维护（因为直接记录深度会更史）。
具体地，用一个全局大数组容纳所有信息，为每个点分配相应的数组头指针。正常情况下需要用到的元素最多为 \(2n\)，但如果存在一些诡异的前移后移操作就另当别论了。

P5904 [POI 2014] HOT-Hotels 加强版
https://www.luogu.com.cn/problem/P5904
首先 不难 得到 \(O(n^2)\) 做法：显然存在一个点到三个点距离相等。这个点既可能是它们的 LCA，也可能是其中一个点的子孙，另外两个点的 LCA。综上，在 LCA 处统计答案是可行的。
令 \(f_{i,j}\) 表示 \(i\) 子树中距离 \(i\) 为 \(j\) 的点数；\(g_{i,j}\) 表示 \(i\) 子树中距离 \(i\) 为 \(j\)、或者距 LCA 为 \(d\) 且 LCA 距离 \(i\) 为 \(d-j\) 的点对数；随便做就可以了。

#include &lt;bits/stdc++.h&gt;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n;
    std::cin &gt;&gt; n;
    std::vector&lt;std::vector&lt;int&gt; &gt; g1(n + 1);
    for (int i = 1, x, y; i &lt; n; ++i) &#123;
        std::cin &gt;&gt; x &gt;&gt; y;
        g1[x].push_back(y), g1[y].push_back(x);
    &#125;
    auto res(0ll);
    std::vector&lt;int&gt; h(n + 1);
    std::vector&lt;std::vector&lt;long long&gt; &gt; f(n + 1), g(n + 1);
    std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int fa) &#123;
        h[x] = 1;
        for (auto i : g1[x])
            if (i != fa) &#123;
                DFS(i, x);
                h[x] = std::max(h[x], h[i] + 1);
            &#125;
        f[x].resize(h[x] + 1), g[x].resize(h[x] + 1);
        f[x][0] = 1ll;
        for (auto i : g1[x])
            if (i != fa) &#123;
                for (int j = 0; j &lt;= h[i]; ++j) &#123;
                    if (j &gt;= 1)
                        res += g[x][j] * f[i][j - 1];
                    if (j &gt;= 1 &amp;&amp; j + 1 &lt;= h[i])
                        res += f[x][j] * g[i][j + 1];
                    if (j &gt;= 1) &#123;
                        g[x][j] += f[x][j] * f[i][j - 1];
                        f[x][j] += f[i][j - 1];
                    &#125;
                    if (j + 1 &lt;= h[i])
                        g[x][j] += g[i][j + 1];
                &#125;
                std::vector&lt;long long&gt;().swap(f[i]);
                std::vector&lt;long long&gt;().swap(g[i]);
            &#125;
        res += g[x][0];
        return;
    &#125;;
    DFS(1, -1);
    std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;

然后对于每个 \(u\)，类似 DSU on tree，继承其长儿子的数据（整体前移 / 后移一位，使用指针实现），再把短儿子暴力合并上来。
每次合并短儿子，数组长为短儿子链长；\(u\) 向上合并时，数组长为长儿子链长。故所有链被合并恰好一次，复杂度 \(O(n)\)。

#include &lt;bits/stdc++.h&gt;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n;
    std::cin &gt;&gt; n;
    std::vector&lt;std::vector&lt;int&gt; &gt; g1(n + 1);
    for (int i = 1, x, y; i &lt; n; ++i) &#123;
        std::cin &gt;&gt; x &gt;&gt; y;
        g1[x].push_back(y), g1[y].push_back(x);
    &#125;
    std::vector&lt;int&gt; h(n + 1), son(n + 1);
    std::vector&lt;long long&gt; df(5 * n + 1), dg(5 * n + 1);
    std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int fa) &#123;
        h[x] = 1;
        for (auto i : g1[x])
            if (i != fa) &#123;
                DFS(i, x);
                h[x] = std::max(h[x], h[i] + 1);
                if (h[i] &gt; h[son[x]])
                    son[x] = i;
            &#125;
        return;
    &#125;;
    DFS(1, -1);
    auto pos(dg.begin() + 3 * n);
    std::vector&lt;decltype(df.begin())&gt; f(n + 1), g(n + 1);
    auto res(0ll);
    DFS = [&amp;](int x, int fa) &#123;
        f[x][0] = 1ll;
        if (son[x]) &#123;
            f[son[x]] = std::next(f[x]), g[son[x]] = std::prev(g[x]);
            DFS(son[x], x);
        &#125;
        for (auto i : g1[x])
            if (i != fa &amp;&amp; i != son[x]) &#123;
                f[i] = std::next(f[x], h[x] + 1);
                std::fill(f[i], f[i] + h[i] + 2, 0ll);
                g[i] = std::next(pos, h[i]), pos = std::next(g[i], h[i]);
                std::fill(std::prev(g[i]), g[i] + h[i] + 2, 0ll);
                DFS(i, x);
                for (int j = 0; j &lt;= h[i]; ++j) &#123;
                    if (j &gt;= 1)
                        res += g[x][j] * f[i][j - 1];
                    if (j &gt;= 1 &amp;&amp; j + 1 &lt;= h[i])
                        res += f[x][j] * g[i][j + 1];
                    if (j &gt;= 1) &#123;
                        g[x][j] += f[x][j] * f[i][j - 1];
                        f[x][j] += f[i][j - 1];
                    &#125;
                    if (j + 1 &lt;= h[i])
                        g[x][j] += g[i][j + 1];
                &#125;
            &#125;
        res += g[x][0];
        return;
    &#125;;
    f[1] = df.begin(), g[1] = dg.begin() + 2 * n;
    DFS(1, -1);
    std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;


CF1585G Poachers
https://codeforces.com/problemset/problem/1585/G
公平博弈。我们现在要算每个根的 SG 值。设 \(f_{u,j}\) 表示在点 \(u\)，删了距离它为 \(j\) 这一层的 SG 值，那么有：
\[
f_{u,j}=
\begin{cases}
\text{mex}\{f_{v,0}\}&amp;j=0\\
\bigoplus f_{v,j-1}&amp;\text{otherwise}
\end{cases}
\]
然后发现有深度维。大力长剖。

#include &lt;bits/stdc++.h&gt;
const int inf = 0x3f3f3f3f;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int T;
    for (std::cin &gt;&gt; T; T--; ) &#123;
        int n;
        std::cin &gt;&gt; n;
        std::vector&lt;int&gt; rt;
        std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);
        for (int i = 1, x; i &lt;= n; ++i) &#123;
            std::cin &gt;&gt; x;
            if (x)
                g[x].push_back(i);
            else
                rt.push_back(i);
        &#125;
        std::vector&lt;int&gt; h(n + 1), son(n + 1), to(n + 1, inf);
        std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;
            h[x] = 1;
            for (auto i : g[x]) &#123;
                DFS(i);
                h[x] = std::max(h[x], h[i] + 1);
                to[x] = std::min(to[x], to[i] + 1);
                if (h[i] &gt; h[son[x]])
                    son[x] = i;
            &#125;
            to[x] = std::min(to[x], h[x]);
            return;
        &#125;;
        for (auto i : rt)
            DFS(i);
        std::vector&lt;int&gt; _f(5 * n + 1), top(n + 1);
        std::vector&lt;decltype(_f.begin())&gt; f(n + 1);
        std::vector&lt;std::unordered_set&lt;int&gt; &gt; s(n + 1);
        auto p(_f.begin());
        DFS = [&amp;](int x) &#123;
            if (son[x]) &#123;
                f[son[x]] = std::next(f[x]);
                top[son[x]] = top[x], DFS(son[x]);
            &#125;
            if ((int)g[x].size() == 1) &#123;
                s[top[x]].insert(f[son[x]][0]);
                for (int now = f[son[x]][0] + 1; ; ++now)
                    if (!s[top[x]].count(now)) &#123;
                        f[x][0] = now;
                        break;
                    &#125;
                return;
            &#125;
            for (auto i : g[x])
                if (i != son[x]) &#123;
                    f[i] = p, p = std::next(p, h[i] + 1);
                    top[i] = i, DFS(i);
                    for (int j = 1; j &lt;= to[i] + 1; ++j)
                        f[x][j] ^= f[i][j - 1];
                &#125;
            std::unordered_set&lt;int&gt;().swap(s[top[x]]);
            for (int j = 1; j &lt;= to[x]; ++j)
                s[top[x]].insert(f[x][j]);
            for (int now = 0; ; ++now)
                if (!s[top[x]].count(now)) &#123;
                    f[x][0] = now;
                    break;
                &#125;
            return;
        &#125;;
        int res = 0;
        for (auto i : rt) &#123;
            f[i] = p, p = std::next(p, h[i] + 1);
            DFS(i), res ^= f[i][0];
        &#125;
        std::cout &lt;&lt; (res ? &quot;YES&quot; : &quot;NO&quot;) &lt;&lt; &#39;\n&#39;;
    &#125;
    return 0;
&#125;


]]></content>
      <tags>
        <tag>树链剖分</tag>
        <tag>长链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title>杂题选谈：字符串</title>
    <url>/20241021/</url>
    <content><![CDATA[标题本来叫「哈希」，后来发现第二天的很多题虽然打了哈希的 tag 但是只有 KMP 做法，故忍痛改成「字符串」。


A. Two Permutations
https://www.becoder.com.cn/contest/5653/problem/1
有个很重要的性质是 \(a\) 和 \(b\) 都是排列。然后我们就知道了 \(x\in [0,m-n]\)，且每个 \(a_i+x\) 在 \(b\) 中有元素与之唯一对应。于是问题可以转化成，\(b\) 中在 \([1+x,n+x]\) 范围中的元素按顺序哈希起来和 \(a\) 序列是否完全一致。
我们就有了一个想法：枚举这个 \(x\)，通过某种方法快速查询这个长度固定的值域区间按顺序哈希起来的值。然后就是典中典之线段树维护哈希，只需在枚举 \(x\) 时滑动窗口，剔除头部元素，新增尾部元素，查询全局哈希值即可。
还有一个小细节是关于实时维护全局加 \(x\) 后的 \(a\)。由于哈希用乘的肯定拆不开，只能用加哈希了。每次 \(x\) 加一的时候全局哈希值加上 \(\sum p_i\) 即可。

#include &lt;bits/stdc++.h&gt;
const int p = 998244353;
const int mod = 1e9 + 7;
const int maxn = 2e5 + 5;
struct &#123;
    int l, r, s;
    long long u;
&#125; t[maxn &lt;&lt; 2];
long long base[maxn];
#define lt (p &lt;&lt; 1)
#define rt (lt | 1)
void pushup(int p) &#123;
    t[p].u = (t[lt].u * base[t[rt].s] % mod + t[rt].u) % mod;
    return;
&#125;
void bld(int p, int l, int r) &#123;
    t[p].l = l, t[p].r = r;
    if (l == r)
        return;
    int mid = (l + r) &gt;&gt; 1;
    bld(lt, l, mid), bld(rt, mid + 1, r);
    return;
&#125;
void add(int p, int x, int v) &#123;
    t[p].s += (v &gt;= 0 ? 1 : -1);
    if (t[p].l == t[p].r) &#123;
        t[p].u += v;
        return;
    &#125;
    int mid = (t[p].l + t[p].r) &gt;&gt; 1;
    if (x &lt;= mid)
        add(lt, x, v);
    else
        add(rt, x, v);
    pushup(p);
    return;
&#125;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n, m;
    std::cin &gt;&gt; n &gt;&gt; m;
    std::vector&lt;int&gt; a(n + 1), b(m + 1), pos(m + 1);
    base[0] = 1;
    long long s = 1;
    for (int i = 1; i &lt;= m; ++i) &#123;
        base[i] = base[i - 1] * p % mod;
        if (i &lt; n)
            (s += base[i]) %= mod;
    &#125;
    long long now = 0;
    for (int i = 1; i &lt;= n; ++i) &#123;
        std::cin &gt;&gt; a[i];
        now = (now * p % mod + a[i]) % mod;
    &#125;
    for (int i = 1; i &lt;= m; ++i)
        std::cin &gt;&gt; b[i], pos[b[i]] = i;
    int res = 0;
    bld(1, 1, m);
    for (int x = 0; x &lt;= m - n; ++x) &#123;
        for (static int l = 1; l &lt; 1 + x; add(1, pos[l], -l), ++l);
            // printf(&quot;add %d: %d\n&quot;, pos[l], -l);
        for (static int r = 1; r &lt;= n + x; add(1, pos[r], r), ++r);
            // printf(&quot;add %d: %d\n&quot;, pos[r], r);
        (res += (now == t[1].u));
        // printf(&quot;x = %d, now = %lld, t[1].u = %lld\n&quot;, x, now, t[1].u);
        (now += s) %= mod;
    &#125;
    std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;


B. k-substrings
https://www.becoder.com.cn/contest/5653/problem/2
我们可以发现这 \(\left\lceil\dfrac n2\right\rceil\) 个串都有共同中点，而不管其位于元素还是元素间的空隙，两边的 border 都应关于其对称。啥叫奇 border 呢，就是每个 border 都能取到元素上的中点，也就是说这俩中点是关于全串中点对称的。
我们枚举这 \(\left\lfloor\dfrac n2\right\rfloor\) 对可能的 border 中点，分别二分 border 长度。假设最后该对中点最长合法 border 为 \([l_1,r_1]\) 与 \([l_2,r_2]\)，用 \(r_1-l_1+1-2\times k\) 更新 \(l_1+k\) 处的答案即可。

#include &lt;bits/stdc++.h&gt;
const int p = 131;
const int mod = 1e9 + 7;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n;
    std::cin &gt;&gt; n;
    std::vector&lt;char&gt; a(n + 1);
    std::vector&lt;int&gt; res(n + 1, -1);
    std::vector&lt;long long&gt; h(n + 1), base(n + 1);
    base[0] = 1;
    for (int i = 1; i &lt;= n; ++i) &#123;
        std::cin &gt;&gt; a[i];
        h[i] = (h[i - 1] * p + a[i]) % mod;
        base[i] = base[i - 1] * p % mod;
    &#125;
    auto geth = [&amp;](int l, int r) &#123;
        return (h[r] + mod - h[l - 1] * base[r - l + 1] % mod) % mod;
    &#125;;
    for (int l = n / 2, r = (n + 1) / 2 + 1; r &lt;= n; --l, ++r)
        if (a[l] == a[r]) &#123;
            int t = 0;
            for (int ll = 1, rr = l, mid; ll &lt;= rr; ) &#123;
                mid = (ll + rr) &gt;&gt; 1;
                if (geth(l - mid + 1, l + mid - 1) == geth(r - mid + 1, r + mid - 1))
                    t = mid, ll = mid + 1;
                else
                    rr = mid - 1;
            &#125;
            res[l - t + 1] = std::max(res[l - t + 1], 2 * t - 1);
        &#125;
    for (int i = 1; i &lt;= (n + 1) / 2; ++i) &#123;
        res[i] = std::max(res[i - 1] - 2, res[i]);
        std::cout &lt;&lt; res[i] &lt;&lt; &#39; &#39;;
    &#125;
    std::cout &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;


C. Kefa and Watch
https://www.becoder.com.cn/contest/5653/problem/3
一个挺常用的 trick 是，\(S_{l\sim r}\) 存在长度为 \(d\) 的循环节 \(\iff S_{l\sim (r-d)}=S_{(l+d+)\sim r}\)。而题目要求为混循环节，刚好也可以用这个方法判定。线段树随便维护一下哈希就行。assign 操作就是将长度为 \(len\) 的区间哈希值更改为 \(t\times \sum_{i=0}^{len-1}p^i\)。

#include &lt;bits/stdc++.h&gt;
const int p = 131;
const int mod = 1e9 + 7;
const int maxn = 1e5 + 5;
struct &#123;
    int l, r, d;
    long long u;
&#125; t[maxn &lt;&lt; 2];
int a[maxn];
long long base[maxn], s[maxn];
#define lt (p &lt;&lt; 1)
#define rt (lt | 1)
void pushup(int p) &#123;
    t[p].u = (t[lt].u * base[t[rt].r - t[rt].l + 1] % mod + t[rt].u) % mod;
    return;
&#125;
void pushdown(int p) &#123;
    if (~t[p].d) &#123;
        t[lt].d = t[rt].d = t[p].d;
        t[lt].u = t[p].d * s[t[lt].r - t[lt].l] % mod;
        t[rt].u = t[p].d * s[t[rt].r - t[rt].l] % mod;
        t[p].d = -1;
    &#125;
    return;
&#125;
void bld(int p, int l, int r) &#123;
    t[p].l = l, t[p].r = r, t[p].d = -1;
    if (l == r) &#123;
        t[p].u = a[l];
        return;
    &#125;
    int mid = (l + r) &gt;&gt; 1;
    bld(lt, l, mid), bld(rt, mid + 1, r);
    pushup(p);
    return;
&#125;
void ass(int p, int l, int r, int v) &#123;
    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r) &#123;
        t[p].d = v;
        t[p].u = v * s[t[p].r - t[p].l] % mod;
        return;
    &#125;
    pushdown(p);
    int mid = (t[p].l + t[p].r) &gt;&gt; 1;
    if (l &lt;= mid)
        ass(lt, l, r, v);
    if (r &gt; mid)
        ass(rt, l, r, v);
    pushup(p);
    return;
&#125;
long long ask(int p, int l, int r) &#123;
    // printf(&quot;p = %d, u = %lld, [%d, %d] of [%d, %d]\n&quot;, p, t[p].u, t[p].l, t[p].r, l, r);
    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r)
        return t[p].u;
    pushdown(p);
    int mid = (t[p].l + t[p].r) &gt;&gt; 1;
    if (r &lt;= mid)
        return ask(lt, l, r);
    if (l &gt; mid)
        return ask(rt, l, r);
    return (ask(lt, l, r) * base[std::min(r, t[p].r) - mid] % mod + ask(rt, l, r)) % mod;
&#125;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n, m, k;
    std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;
    base[0] = s[0] = 1;
    for (int i = 1; i &lt;= n; ++i) &#123;
        char t;
        std::cin &gt;&gt; t;
        a[i] = t - &#39;0&#39;;
        base[i] = base[i - 1] * p % mod;
        s[i] = (s[i - 1] + base[i]) % mod;
    &#125;
    bld(1, 1, n);
    for (int q = m + k; q--; ) &#123;
        int op;
        std::cin &gt;&gt; op;
        if (op == 1) &#123;
            int l, r, t;
            std::cin &gt;&gt; l &gt;&gt; r &gt;&gt; t;
            ass(1, l, r, t);
        &#125;
        else &#123;
            int l, r, d;
            std::cin &gt;&gt; l &gt;&gt; r &gt;&gt; d;
            // if (d != r - l + 1)
            //     printf(&quot;%lld / %lld\n&quot;, ask(1, l, r - d), ask(1, l + d, r));
            std::cout &lt;&lt; ((d == r - l + 1 || ask(1, l, r - d) == ask(1, l + d, r)) ? &quot;YES&quot; : &quot;NO&quot;) &lt;&lt; &#39;\n&#39;;
        &#125;
    &#125;
    return 0;
&#125;


D. Misha and LCP on Tree
https://www.becoder.com.cn/contest/5653/problem/4
一个很显然的做法是，我们二分一个长度，然后在 \(a\to fa\) 上正哈希，\(b\to fa\) 上反哈希，\(O(1)\) check。
笑话：本来想用倍增求 \(a\to fa\) 和 \(b\to fa\) 的哈希（当然双 \(\log\) 肯定是会被卡飞的），后来发现哈希具有可减性，我们又只需求一条链上的哈希值，直接减掉就行。
还有一个点就是 \(O(1)\) 求 \(k\) 级祖先，有长剖预处理的做法。具体做法。

#include &lt;bits/stdc++.h&gt;
const int p = 131;
const int mod = 1e9 + 7;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n;
    std::cin &gt;&gt; n;
    std::vector&lt;int&gt; to(n + 1);
    std::vector&lt;char&gt; a(n + 1);
    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);
    std::vector&lt;long long&gt; base(n + 1), inv(n + 1);
    auto qkp = [](long long x, int y) &#123;
        long long res = 1;
        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)
            if (y &amp; 1)
                (res *= x) %= mod;
        return res;
    &#125;;
    base[0] = inv[0] = 1;
    for (int i = 1, mx = 0; i &lt;= n; ++i) &#123;
        std::cin &gt;&gt; a[i];
        base[i] = base[i - 1] * p % mod;
        inv[i] = qkp(base[i], mod - 2);
        if (i &gt;= (1 &lt;&lt; mx) * 2)
            ++mx;
        to[i] = mx;
    &#125;
    for (int i = 1, x, y; i &lt; n; ++i) &#123;
        std::cin &gt;&gt; x &gt;&gt; y;
        g[x].push_back(y), g[y].push_back(x);
    &#125;
    std::vector&lt;long long&gt; h1(n + 1), h2(n + 1);
    std::vector&lt;std::array&lt;int, 21&gt; &gt; fa(n + 1);
    std::vector&lt;int&gt; h(n + 1, 1), son(n + 1), dep(n + 1);
    h[0] = 0;
    std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;
        h1[x] = (h1[fa[x][0]] * p % mod + a[x]) % mod;
        h2[x] = (h2[fa[x][0]] + a[x] * base[dep[x] - 1]) % mod;
        for (auto i : g[x])
            if (i != fa[x][0]) &#123;
                fa[i][0] = x;
                for (int j = 1; j &lt;= 20; ++j)
                    fa[i][j] = fa[fa[i][j - 1]][j - 1];
                dep[i] = dep[x] + 1;
                DFS(i);
                if (h[i] &gt;= h[son[x]])
                    son[x] = i, h[x] = h[i] + 1;
            &#125;
        return;
    &#125;;
    dep[1] = 1, DFS(1);
    std::vector&lt;int&gt; top(n + 1), id(n + 1);
    std::vector&lt;std::vector&lt;int&gt; &gt; anc(n + 1), des(n + 1, std::vector&lt;int&gt; (1));
    std::function&lt;void(int, int)&gt; DFS1 = [&amp;](int x, int toq) &#123;
        top[x] = toq;
        if (son[x])
            DFS1(son[x], toq);
        for (auto i : g[x])
            if (i != fa[x][0] &amp;&amp; i != son[x])
                DFS1(i, i);
        des[toq].push_back(x);
        id[x] = (int)des[toq].size() - 1;
        if (x == toq) &#123;
            anc[x].push_back(x);
            for (int j = 1, now = x; j &lt;= id[x]; ++j, now = fa[now][0])
                anc[x].push_back(fa[now][0]);
        &#125;
        return;
    &#125;;
    DFS1(1, 1);
    auto getLCA = [&amp;](int x, int y) &#123;
        if (dep[x] &lt; dep[y])
            std::swap(x, y);
        for (int i = 20; ~i; --i)
            if (dep[fa[x][i]] &gt;= dep[y])
                x = fa[x][i];
        if (x == y)
            return x;
        for (int i = 20; ~i; --i)
            if (fa[x][i] != fa[y][i])
                x = fa[x][i], y = fa[y][i];
        return fa[x][0];
    &#125;;
    auto ask = [&amp;](int x, int k) &#123;
        assert(dep[x] - 1 &gt;= k);
        int x1 = x;
        if (!k)
            return x;
        x = fa[x][to[k]];
        if (dep[x] - dep[top[x]] &gt;= k - (1 &lt;&lt; to[k]))
            return des[top[x]][id[x] + k - (1 &lt;&lt; to[k])];
        return anc[top[x]][k - (1 &lt;&lt; to[k]) - (dep[x] - dep[top[x]])];
    &#125;;
    auto dis = [&amp;](int x, int y, int fa) &#123;
        return dep[x] + dep[y] - 2 * dep[fa];
    &#125;;
    auto gethash = [&amp;](int x, int y, int f, int k) &#123;
        if (!k)
            return 0ll;
        if (k &lt;= dep[x] - dep[f] + 1) &#123;
            f = ask(x, k - 1);
            return (h2[x] + mod - h2[fa[f][0]]) % mod * inv[dep[f] - 1] % mod;
        &#125;
        long long h = (h2[x] + mod - h2[fa[f][0]]) % mod * inv[dep[f] - 1] % mod;
        k -= (dep[x] - dep[f] + 1);
        y = ask(y, (dep[y] - dep[f]) - k);
        h = (h * base[dep[y] - dep[f]] % mod + (h1[y] + mod - h1[f] * base[dep[y] - dep[f]] % mod) % mod) % mod;
        return h;
    &#125;;
    int m;
    std::cin &gt;&gt; m;
    for (int x, y, a, b; m--; ) &#123;
        std::cin &gt;&gt; x &gt;&gt; y &gt;&gt; a &gt;&gt; b;
        int fa1 = getLCA(x, y), fa2 = getLCA(a, b), res = 0;
        for (int l = 0, r = std::min(dis(x, y, fa1), dis(a, b, fa2)) + 1, mid; l &lt;= r; ) &#123;
            mid = (l + r) &gt;&gt; 1;
            if (gethash(x, y, fa1, mid) == gethash(a, b, fa2, mid))
                res = mid, l = mid + 1;
            else
                r = mid - 1;
        &#125;
        std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
    &#125;
    return 0;
&#125;


A. Song of the Sirens
https://www.becoder.com.cn/contest/5658/problem/1
笑话：是 \(s_it_is_i\) 而不是 \(s_its_i\)。
我们发现 \(s_0\) 很短，所以直接枚举起始位置把 \(s_0\) 和匹配串大力匹配，把空位挖出来组成新的匹配串再考虑 \(t\) 的问题（因为所有 \(s_i\) 最开头都有一个完整的 \(s_0\)，所以可以随便选断点）。
我们知道 \(t\) 的下标是一个自底向上从 \(1\) 到 \(n\) 的满二叉树的中序遍历，其中 \(t_1\) 间隔一位出现；于是我们仿照对 \(s\) 的处理方式，再把 \(t_1\) 挖掉。注意到此时 \(t_2\) 又成为二叉树最底层，间隔一位出现，这就变成了一个 \(O(n\log n)\) 递归的问题。
至于答案，当 \(t\) 被删空时，假设删掉的最后一个元素为 \(t_p\)，\(t\) 的出现次数即为二叉树中 \(p\) 层点数，为 \(2^{k-p}\)。
有一个细节，就是如果当前删到 \(i\) 了，\(t\) 的长度只剩 \(1\)，就会有一个很尴尬的问题——这个元素不一定就是 \(t_i\)，而应该是 \(\{j \mid j\ge i\land t_j=t_i\}\)。统计 \(t_{i\sim k}\) 中值为 \(t_i\) 的元素个数（前缀和），乘上对应的层数即可。这个可以用一点小技巧搞定，前缀和时忽略 \(k\) 乘上 \(k=n\) 时的系数，统计答案时乘上 \(2^{n-k}\) 即可。
不是，那我缺的哈希这块谁来补啊？？？

#include &lt;bits/stdc++.h&gt;
const int mod = 1e9 + 7;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;sirens1.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n, q, m;
    std::string s;
    std::cin &gt;&gt; n &gt;&gt; q &gt;&gt; s;
    s = &#39;\0&#39; + s, m = (int)s.length() - 1;
    std::vector&lt;char&gt; t(n + 1);
    std::vector&lt;long long&gt; base(n + 1), inv(n + 1);
    std::vector&lt;std::array&lt;long long, 26&gt; &gt; a(n + 1);
    auto qkp = [](long long x, int y) &#123;
        long long res = 1ll;
        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)
            if (y &amp; 1)
                (res *= x) %= mod;
        return res;
    &#125;;
    base[0] = 1ll, inv[0] = 1ll, inv[1] = qkp(2, mod - 2);
    for (int i = 1; i &lt;= n; ++i) &#123;
        std::cin &gt;&gt; t[i];
        base[i] = base[i - 1] * 2 % mod;
        if (i != 1)
            inv[i] = inv[i - 1] * inv[1] % mod;
    &#125;
    for (int i = 1; i &lt;= n; ++i)
        a[i] = a[i - 1], (a[i][t[i] - &#39;a&#39;] += base[n - i]) %= mod;
    for (int k; q--; ) &#123;
        std::string p;
        std::cin &gt;&gt; k &gt;&gt; p;
        p = &#39;\0&#39; + p;
        long long res = 0;
        int l = (int)p.length() - 1;
        std::vector&lt;char&gt; u;
        std::function&lt;void(int, std::vector&lt;char&gt; &amp;)&gt; calc = [&amp;](int x, std::vector&lt;char&gt; &amp;p) &#123;
            int m = (int)p.size() - 1;
            if (m == 0) &#123;
                // puts(&quot;# 45&quot;);
                // printf(&quot;0, += %lld\n&quot;, base[k - x + 1]);
                (res += base[k - x + 1]) %= mod;
                return;
            &#125;
            if (x &gt; k)
                return;
            if (m == 1) &#123;
                // puts(&quot;# 50&quot;);
                // printf(&quot;1, += %lld(%lld)\n&quot;, (a[k][p[1] - &#39;a&#39;] + mod - a[x - 1][p[1] - &#39;a&#39;]) % mod * inv[n - k] % mod, inv[n - k] % mod);
                (res += (a[k][p[1] - &#39;a&#39;] + mod - a[x - 1][p[1] - &#39;a&#39;]) % mod * inv[n - k] % mod) %= mod;
                return;
            &#125;
            bool flag0 = 1, flag1 = 1;
            std::vector&lt;char&gt; t0(1), t1(1);
            for (int i = 1; i &lt;= m; ++i)
                if (!(i &amp; 1)) &#123;
                    if (flag0)
                        t0.push_back(p[i]);
                    flag1 &amp;= (p[i] == t[x]);
                &#125;
                else &#123;
                    if (flag1)
                        t1.push_back(p[i]);
                    flag0 &amp;= (p[i] == t[x]);
                &#125;
            if (flag0)
                calc(x + 1, t0);
            if (flag1)
                calc(x + 1, t1);
            return;
        &#125;;
        for (int i = 1; i &lt;= m + 1; ++i) &#123;
            std::vector&lt;char&gt;(1).swap(u);
            for (int j = i, now = 1; now &lt;= l; ++now) &#123;
                if (j == m + 1)
                    j = 1, u.push_back(p[now]);
                else if (p[now] != s[j])
                    goto nosol;
                else
                    ++j;
            &#125;
            // printf(&quot;u: &quot;);
            // for (int i = 1; i &lt; (int)u.size(); ++i)
            //     std::cout &lt;&lt; u[i];
            // puts(&quot;&quot;);
            calc(1, u);
        nosol: ;
        &#125;
        std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
    &#125;
    return 0;
&#125;


B. Prefix of Suffixes
https://www.becoder.com.cn/contest/5658/problem/2
还是太科幻了。哦哦 border 我的 border。
法一
考虑每次增量，若加入 \(S_i\) 后有 \(z_j\) 的值增加 \(1\)，那么这对 \((i, j)\) 就会贡献 \(A_j\cdot B_i\) 的增量；反之，\(z_j\) 在以后也不会增加。
我们维护当前没有确定下来的所有 \(z_j\)，对于每个 \(i\) 暴力 check \(z_j\) 是否确定并更新答案，因为数据比较弱，在 CF 神机上跑得飞快  但是 QOJ 上死活过不了 

#include &lt;bits/stdc++.h&gt;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n;
    long long res = 0, s = 0;
    std::cin &gt;&gt; n;
    std::vector&lt;int&gt; now;
    std::vector&lt;int&gt; a(n + 1), b(n + 1), t(n + 1);
    for (int i = 1; i &lt;= n; ++i) &#123;
        std::cin &gt;&gt; t[i] &gt;&gt; a[i] &gt;&gt; b[i];
        t[i] = (res + t[i]) % n;
        if (t[i] == t[1])
            s += b[i], now.push_back(i);
        std::vector&lt;int&gt; g(std::move(now));
        for (auto j : g)
            if (t[i] == t[i - j + 1])
                now.push_back(j);
            else
                s -= b[j];
        res += a[i] * s;
        std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
    &#125;
    return 0;
&#125;

法二
依然考虑增量。\(z_j\) 增加 \(\iff S_{j\to i}\) 为 \(S_{1\sim i}\) 的一个 border。考虑对于每一个 \(S_i\)，border 的组成。

若 \(S_1=S_i\)，那么将会新增一个长度为 \(1\) 的 border。
对于在 \(i-1\) 处合法的 border \(S_{j\sim i-1}\)，若 \(S_i=S_{i-j+1}\)，则该 border 仍合法；否则非法。

我们的法一其实相当于是暴力 check 了所有合法 border 是否仍然合法，但这显然最坏是 \(O(n^2)\) 的。我们考虑从 border 角度优化一下。
我们发现，比如说 \(\texttt{abababa + b}\)，我们会进行很多次不必要的 check，当然这个时候我们会本能大力跳 fail，但是这里有一个 border 的等差数列性质，若 \(x+1\) 与 \(i\) 能够匹配，那么与 \(x\) 同属一个等差数列的所有 \(x&#39;+1\) 都应和 \(i\) 匹配。
对于正在 check 的 \(x\)，如果 check 成功则跳到上一条链的链尾；否则跳到链头。总的复杂度是 \(O(n\log n)\) 的。找一下和每个 \(i\) 匹配不了的第一个链头，甚至可以因为某些我太菜了所以不知道的不明原因整到线性。

#include &lt;bits/stdc++.h&gt;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n;
    long long res = 0, s = 0;
    std::cin &gt;&gt; n;
    std::vector&lt;int&gt; a(n + 1), b(n + 1), t(n + 1), ne(n + 1), to(n + 1);
    for (int i = 1; i &lt;= n; ++i) &#123;
        std::cin &gt;&gt; t[i] &gt;&gt; a[i] &gt;&gt; b[i];
        t[i] = (res + t[i]) % n;
        if (i == 1)
            s += b[i], res = (long long)a[i] * b[i];
        else &#123;
            int j = ne[i - 1];
            for (; j &amp;&amp; t[j + 1] != t[i]; j = ne[j]);
            if (t[j + 1] == t[i])
                ++j;
            ne[i] = j;
            if (t[i] == t[1])
                s += b[i];
            to[i - 1] = (t[ne[i - 1] + 1] == t[i] ? to[ne[i - 1]] : ne[i - 1]);
            for (int j = i - 1; j; )
                if (t[j + 1] == t[i])
                    j = to[j];
                else
                    for (int at = to[j]; j != at; s -= b[i - j], j = ne[j]);
            res += a[i] * s;
        &#125;
        std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
    &#125;
    return 0;
&#125;


C. Matching
https://www.becoder.com.cn/contest/5658/problem/3
我们发现，如果我们直接要 check 一段 \(a\) 和 \(p\)，感觉不太好整。
然后考虑这么一个问题，假如我们通过神秘方法让我们每次 check 的 \(a\)
]]></content>
      <tags>
        <tag>哈希</tag>
        <tag>线段树</tag>
        <tag>KMP</tag>
        <tag>border</tag>
      </tags>
  </entry>
  <entry>
    <title>CSP-S</title>
    <url>/20241027/</url>
    <content><![CDATA[弟娃年方十一。方出考场之时，余问弟娃曰：「T1 用时几何？」。弟娃对曰：「及过大样例，已半炷香矣。」余大恸，为余 T1 大样例既过，已两柱香有余。古谚有云：「若有一人年少于吾亦强于吾，吾为之单调队列也。」吾弟娃年少于吾，殊难易之；今吾弟娃已四倍而强于吾，吾盍为单调队列哉！


忆往昔昔（初二），1=。忆往昔昔昔（初一），1=。忆往昔（初三），135pts 喜提 2=。
看今朝，300pts 应该有 1=。哇恭喜恭喜，2= 到 1=，一年来你有很大进步呢！

A. duel
非常遗憾地，被橙题硬控 1h+。问就是上场之后先花了 59min 下载 大脑.tar.gz，然后 1s 知道做法，59s 实现。
其实我们是注意到了众数的那个奇妙结论的，但是因为太奇怪并且担心是因为大样例太水所以没敢写，不服来战。

B. detect
我们在求解出区间后被精度问题硬控 1h+。在按照右端点排序后超厉害地使用 线段树优化 DP 解决了初一简单线性贪心问题。哈哈哈。
笑话：被精度问题控的 1h 里有 40min 扑在因为调精度而打出来的 死循环 上 

C. color
在 5min 解决费用提前计算式子后删除了 node_modules &gt; 大脑，稍加思考得出了「大抵是不存在不带 \(\log\) 的全局修改、单点修改、单点查询的数据结构的」的结论，超厉害地使用 线段树优化 DP，并且被全局修改懒标记没传给树根硬控 1h+。
不过因为知道 1e6 的数据给线段树确实挺奇怪的，所以大力卡常，赛时代码跑民间数据跑得挺快。也就是线性所有点加起来 500ms，我一个点就要跑 500ms 的水平  虽然肯定 T 是不可能 T 的。

D. arena
坏消息：前三题均被硬控 1h+，T4 连暴力都打不完了，甚而至于，输入都打不完喜提零蛋。
好消息：看开点，至少 T4 不会被硬控 1h+ 
这道题有个好写的做法，先胡一胡，等会儿开一篇具体写一写。
还原到每场比赛胜出者能力值（线性），还需要注意到一个单调性：若在加入一个人后某场比赛的胜者就不可能成为全局胜者（相当于知道其祖先中某个元素的具体胜者，且该胜者不是自己），那么加入更多的人也不行。故记录这个人（假设对于比赛 \(x\) 为 \(id_x\)），那么知道了所有叶子的 \(id\) 就可以随便乱搞了。至于求 \(id\) 的过程，直接把 \(1\sim n\) 的人加入二叉树，如果某个点被确定了胜者，就往败者子树打一个标记，完了过后遍历整个树下传标记即可。

小知识：在 2024 CSP-S2 中，99% 的人打了 0 个 线段树优化 DP，而你打了 2 个 线段树优化 DP 

可怜捏。100 + 100 + 100 + 0 = 300。由于 T4 输入没写完是没机会浮动了。拜拜 WC。
草草草，wc 都拜拜了我今年是不是直接原地 afo 了啊。不要啊不要啊。
]]></content>
      <tags>
        <tag>下饭</tag>
      </tags>
  </entry>
  <entry>
    <title>杂题选谈</title>
    <url>/20241104/</url>
    <content><![CDATA[哭いた閃光が目に刺さる / お別かれの鐘が鳴る / 神が成した歴史の / 結ぶ答えは砂の味がする


A. 美味しい美味しいハンバーグ
https://vjudge.net/contest/669299#problem/A
有一个很神奇的随机化做法：我们从前往后串签子，最开始签子数为 \(0\)，如果当前任何一个签子都没办法再串这一个就新增签子。如果没有签子可以用了，就说明这块肉不合法，挪到前 \(k\) 块中的随机位置使其优先被选择。
你会发现这个做法跑得很快，spdarkle 说因为 \(K\) 很小还保证有解，所以期望次数是非常对的。我太菜了他也没细说所以开摆。
由于神秘原因，我的 std::mt19937::operator() 如果外边不套一层 abs 就会起飞 

#include &lt;bits/stdc++.h&gt;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n, k;
    std::cin &gt;&gt; n &gt;&gt; k;
    struct _ &#123; int l, r, u, d; &#125;;
    std::vector&lt;_&gt; a(n + 1), b(k + 1);
    std::mt19937 rand(time(nullptr));
    auto random = [&amp;](int l, int r) &#123;
        return l + std::abs((int)rand()) % (r - l + 1);
    &#125;;
    for (int i = 1; i &lt;= n; ++i)
        std::cin &gt;&gt; a[i].l &gt;&gt; a[i].u &gt;&gt; a[i].r &gt;&gt; a[i].d;
    for (;;) &#123;
        std::copy(a.begin() + 1, a.begin() + k + 1, b.begin() + 1);
        for (int i = k + 1; i &lt;= n; ++i) &#123;
            for (int j = 1; j &lt;= k; ++j) &#123;
                if (std::min(b[j].r, a[i].r) &gt;= std::max(b[j].l, a[i].l) &amp;&amp; std::min(b[j].d, a[i].d) &gt;= std::max(b[j].u, a[i].u)) &#123;
                    b[j].l = std::max(b[j].l, a[i].l);
                    b[j].r = std::min(b[j].r, a[i].r);
                    b[j].u = std::max(b[j].u, a[i].u);
                    b[j].d = std::min(b[j].d, a[i].d);
                    goto issol;
                &#125;
            &#125;
            std::swap(a[i], a[random(1, i)]);
            goto nosol;
        issol: ;
        &#125;
        for (int i = 1; i &lt;= k; ++i)
            std::cout &lt;&lt; b[i].l &lt;&lt; &#39; &#39; &lt;&lt; b[i].u &lt;&lt; &#39;\n&#39;;
        break;
    nosol: ;
    &#125;
    return 0;
&#125;


B. Shik and Travel
https://vjudge.net/contest/669299#problem/B
最小化最大，显然需要二分答案，check 打个 DP。具体怎么 DP 呢？首先考虑暴力，设 \(f_{u, a, b}\) 表示在当前 \(mid\) 的限制下，从 \(u\) 出发到第一个叶子距离为 \(a\)，最后一个距离为 \(b\) 的可行性。那么有 \(f_{u,a,b} = (f_{l,a,i}\land f_{r,j,b})\lor (f_{r,a,i}\land f_{l,j,b})\)。
先不说转移，状态数已经难以接受。所以我们从状态数入手，显然如果存在一个 \(a&#39;\le a\) 和 \(b&#39;\le b\)，那么 \((a&#39;,b&#39;)\) 就是无用状态。也就是说，我们把所有有用的 \((a, b)\) 按 \(a\) 从小到大排序，\(b\) 应该是单调递减的；考虑这个抽象的过程，相当于从头到尾遍历一串状态，在路上碰到的所有较大的 \(b\) 都会被当场丢弃。
感性思考可以发现当我们试图让 \(b\) 最小的时候，这个状态最有用（即最不可能被丢弃）。对于一个 \(f_{l,a,i}\)，我们找到能够转移的 \(f_{r,j,b_{\min}}\) 来转移。正确性很好证明，我们的 check 只要求在根节点上存在任意合法状态，那只需要让最不可能被丢弃的不被丢弃即可，更可能被丢弃的状态是否被丢弃就不会产生影响了。
优化后的状态数在 \(u\) 上只会增加 \(\min(|a_l|,|b_r|)+\min(|a_r|,|b_l|)\)，即两个儿子上的状态数较小者，参考 DSU on tree，是 \(O(n\log)\) 的。加上对状态排序的数据结构，复杂度 \(O(n\log^2 n\log V)\)。

#include &lt;bits/stdc++.h&gt;
const long long inf = 1e18;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n;
    std::cin &gt;&gt; n;
    std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; g(n + 1);
    for (int i = 2, x, w; i &lt;= n; ++i) &#123;
        std::cin &gt;&gt; x &gt;&gt; w;
        g[x].emplace_back(i, w);
    &#125;
    long long res = -1;
    for (long long l = 0, r = inf, mid; l &lt;= r; ) &#123;
        mid = (l + r) &gt;&gt; 1;
        if ([&amp;](void) -&gt; bool &#123;
            std::vector&lt;std::vector&lt;std::pair&lt;long long, long&gt; &gt; &gt; f(n + 1);
            std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;
                if (g[x].empty()) &#123;
                    f[x].emplace_back(0, 0);
                    return;
                &#125;
                long long lim = mid;
                for (auto [i, w] : g[x])
                    DFS(i), lim -= w;
                std::vector&lt;std::pair&lt;long long, long long&gt; &gt; t;
                for (int i = 0; i &lt; 2; ++i) &#123;
                    int j = 0;
                    auto l = g[x][0], r = g[x][1];
                    for (auto [a, b] : f[l.first]) &#123;
                        for (; j + 1 &lt; (int)f[r.first].size() &amp;&amp; f[r.first][j + 1].first + b &lt;= lim; ++j);
                        if (j &lt; (int)f[r.first].size() &amp;&amp; f[r.first][j].first + b &lt;= lim)
                            t.emplace_back(a + l.second, f[r.first][j].second + r.second);
                    &#125;
                    std::swap(g[x][0], g[x][1]);
                &#125;
                std::sort(t.begin(), t.end());
                for (auto [a, b] : t)
                    if (f[x].empty() || f[x].back().second &gt; b)
                        f[x].emplace_back(a, b);
                return;
            &#125;;
            DFS(1);
            return !f[1].empty();
        &#125; ())
            res = mid, r = mid - 1;
        else 
            l = mid + 1;
    &#125;
    std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;


D. Candy Piles
https://vjudge.net/contest/669299#problem/D
不难发现我们可以把题意转化为，把所有列从大到小排列，每次可以选择删掉最左边一列或最下边一行，删空者胜。
把该柱状图转化为网格图，定义边界为胜利点，对于非边界上的点，其一定可以往右走、往上走。若一个点上方、右侧点均为胜利点，此点为失败点；否则，此点为胜利点。
]]></content>
      <tags>
        <tag>DP</tag>
        <tag>随机化</tag>
      </tags>
  </entry>
  <entry>
    <title>学习笔记：AC 自动机</title>
    <url>/20250120/</url>
    <content><![CDATA[耳机声音疑似有点小了，用心旷神怡的话来说大致会是「比果蝇↑嗡嗡声还小」。

？卧槽耳机上居然可以调音量 

前置知识
首先可能需要知道专有名词「自动机」的含义。
大致可以简单理解为，一个 DAG，其中点表示状态，边表示转移。给进去一个字符串之类，就可以在 DAG 上游走，根据最后所处结点，可以得到字符串相关特征。
这个定义让我们想到了 Trie。事实上，Trie 就是一种相当基础的自动机。

接下来，让我们复习 KMP 相关概念。
假想一个场景：你需要求得 \(T\) 在 \(S\) 中的出现次数。
拥有一定题目经验的你，会使用 KMP 求出 \(T\) 的 next 数组，令 \(T\) 在 \(S\) 上进行匹配，失配或完全匹配时回到 \(T\) 在该处的 next，\(S\) 上的指针始终向右，\(T\) 上的指针如果向右，每次只能移动一位；如果向左，最左移到开头，均摊下来复杂度即为 \(O(|S| + |T|)\)。
假如场景变得更复杂：给定 \(\{T_m\}\)，你需要求出每个 \(T_j\) 在 \(S\) 中的出现次数。
那么如果我们对每个 \(T_j\) 进行一次 KMP，复杂度将会上升到 \(O(m|S|)\)，难以承受。有没有优化的方法呢？

AC 自动机的建立
结合上面的知识，我们下意识想到，能不能将 \(\{T_m\}\) 建成一个树状结构，令 \(S\) 在其上进行 KMP 呢？
将 \(\{T_m\}\) 全部加入 Trie，由于 next 只会由更深的点指向更浅的点，似乎从直觉上是有规则的。但随之而来的是一个问题：点 \(u\) 的 next 不一定在 \(\text{root}\to u\) 的链上（由于 Trie 的性质，可知指向的点是唯一的）。鉴于这一点不同，我们结合其「失配指针」的定义，将 next 在 Trie 上的同分异构体唤为 fail。
考察 Trie 上该 fail 边的性质。现欲求解 \(u\) 的 fail 指向的 \(c\)，结合 KMP 中 next 的性质，假设 \(u\) 的父节点的 fail 边指向 \(v&#39;\)，那么 \(v\) 的值为：

\(v&#39;\) 上有边权相同的边，那么 \(v\) 就是该边指向的点。
否则，前往 \(v&#39;\) 的 fail，重复以上判定。

那么就完成了失配的处理。相应地，完全匹配时的跳转应如何处理？直接将 fail 的儿子全部接到 \(u\) 下面即可。如果 \(u\) 和 fail 具有同一个边权的边时，保留 \(u\) 的这条边 \(u\to v\)，因为 \(v\) 的 fail 必定指向 \(u\) 的 fail 的对应儿子。
两点结合，我们发现从实现上，可以直接令 \(v\) 的 fail 指向 \(u\) 的 fail 的对应儿子（那么时间复杂度显而易见是 \(O(26\sum |T|)\) 的）。
匹配时，对于每个点和其返回到根的 fail 链，全部标记。则一个模式串匹配的次数即为被打标记的次数。
那么可以发现 AC 自动机的本质就是添加了 fail 边的 Trie。

那么根据上述要求，我们需要按照深度顺序求得 fail，考虑 BFS。

哦哦好神奇复活之后记得啥是 KMP 但忘了啥是 C++ 了。甚至花了一点时间学习怎么创建一个函数？？？
大家写 AC 自动机 Trie 根节点下标一定要设成 0 啊  设成 1 被各种细节坑惨了 
#include &lt;bits/stdc++.h&gt;
const int maxn = 2e5 + 5;
int T[maxn][26], tot, cnt[maxn], fail[maxn];
int ins(std::string &amp;t) &#123;
    int p = 0;
    for (auto i : t) &#123;
        if (!T[p][i - &#39;a&#39;])
            T[p][i - &#39;a&#39;] = ++tot;
        p = T[p][i - &#39;a&#39;];
    &#125;
    return p;
&#125;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n;
    std::cin &gt;&gt; n;
    std::vector&lt;int&gt; tail(n + 1);
    std::vector&lt;std::string&gt; t(n + 1);
    for (int i = 1; i &lt;= n; ++i)
        std::cin &gt;&gt; t[i], tail[i] = ins(t[i]);
    &#123;
        std::queue&lt;int&gt; q;
        for (int i = 0; i &lt; 26; ++i)
            if (T[0][i])
                q.push(T[0][i]);
        for (; !q.empty(); ) &#123;
            int u = q.front();
            q.pop();
            for (int i = 0; i &lt; 26; ++i)
                if (T[u][i]) &#123;
                    int v = T[u][i];
                    fail[v] = T[fail[u]][i];
                    q.push(v);
                &#125;
                else
                    T[u][i] = T[fail[u]][i];
        &#125;
    &#125;
    std::string s;
    std::cin &gt;&gt; s;
    &#123;
        int p = 0;
        for (auto i : s) &#123;
            p = T[p][i - &#39;a&#39;];
            for (int fa = p; fa; fa = fail[fa])
                ++cnt[fa];
        &#125;
    &#125;
    for (int i = 1; i &lt;= n; ++i)
        std::cout &lt;&lt; cnt[tail[i]] &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;


肉眼可见该查询方式是极其低效的，故考虑优化跳 fail 打标记的过程。
既然自动机结构不变，不如将跳 fail 的步骤放在最后统一进行。容易在发现 fail 树上进行拓扑排序转移即可。

#include &lt;bits/stdc++.h&gt;
const int maxn = 2e5 + 5;
int T[maxn][26], tot, cnt[maxn], fail[maxn], deg[maxn];
int ins(std::string &amp;t) &#123;
    int p = 0;
    for (auto i : t) &#123;
        if (!T[p][i - &#39;a&#39;])
            T[p][i - &#39;a&#39;] = ++tot;
        p = T[p][i - &#39;a&#39;];
    &#125;
    return p;
&#125;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n;
    std::cin &gt;&gt; n;
    std::vector&lt;int&gt; tail(n + 1);
    std::vector&lt;std::string&gt; t(n + 1);
    for (int i = 1; i &lt;= n; ++i)
        std::cin &gt;&gt; t[i], tail[i] = ins(t[i]);
    &#123;
        std::queue&lt;int&gt; q;
        for (int i = 0; i &lt; 26; ++i)
            if (T[0][i])
                q.push(T[0][i]);
        for (; !q.empty(); ) &#123;
            int u = q.front();
            q.pop();
            for (int i = 0; i &lt; 26; ++i)
                if (T[u][i]) &#123;
                    int v = T[u][i];
                    fail[v] = T[fail[u]][i], ++deg[T[fail[u]][i]];
                    q.push(v);
                &#125;
                else
                    T[u][i] = T[fail[u]][i];
        &#125;
    &#125;
    std::string s;
    std::cin &gt;&gt; s;
    &#123;
        int p = 0;
        for (auto i : s)
            p = T[p][i - &#39;a&#39;], ++cnt[p];
    &#125;
    &#123;
        std::queue&lt;int&gt; q;
        for (int i = 1; i &lt;= tot; ++i)
            if (!deg[i])
                q.push(i);
        for (; !q.empty(); ) &#123;
            int u = q.front();
            q.pop();
            cnt[fail[u]] += cnt[u];
            if (!--deg[fail[u]])
                q.push(fail[u]);
        &#125;
    &#125;
    for (int i = 1; i &lt;= n; ++i)
        std::cout &lt;&lt; cnt[tail[i]] &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;


AC 自动机的应用与识别
我们知道其最典型的特征是 多模式串、静态 / 离线。当碰到类似特点时，大概率就是 AC 自动机。
其中，可以设置的难点有：

字符串难点，和其他字符串题可设置的难点相同。
fail 树维护，可能结合数据结构、拓扑排序、树形 DP 等考察。
DP 的设计。


字符串难点设计
eg. Indie Album
https://codeforces.com/problemset/problem/1207/G
题目的「可持久化」试图误导我们用操作串建立自动机，但这样就会有一个比较严重的问题，我们没办法求 \(t\) 的出现次数。
为了保证答案可求我们仍然在 \(t\) 上建立 ACAM。容易发现操作串以 Trie 形式给出，我们可以在遍历 Trie 时同时完成游走，通过回溯完成询问。
假设当前 DFS 中，遍历到 Trie 树中的 \(x\) 点和自动机中的 \(u\) 状态，那么对于 \(x\) 点所对应的一个询问串 \(t\)，相当于询问经过的所有状态有多少个在 \(t\) 引导的 fail 树子树中。我们求出 fail 树的 dfn，用树状数组简单统计即可。

#include &lt;bits/stdc++.h&gt;
const int maxn = 4e5 + 5;
std::vector&lt;int&gt; g[maxn], q[maxn];
int fail[maxn], T[maxn][26], tot, bit[maxn], to[maxn][26], cnt[maxn];
int ins(std::string s) &#123;
    int p = 0;
    for (auto i : s) &#123;
        if (!T[p][i - &#39;a&#39;])
            T[p][i - &#39;a&#39;] = ++tot;
        p = T[p][i - &#39;a&#39;];
    &#125;
    return p;
&#125;
int lowbit(int x) &#123;
    return x &amp; -x;
&#125;
void add(int x, int v) &#123;
    for (; x &lt;= tot + 1; x += lowbit(x))
        bit[x] += v;
    return;
&#125;
int ask(int x) &#123;
    int res = 0;
    for (; x; x -= lowbit(x))
        res += bit[x];
    return res;
&#125;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n, now = 0;
    std::cin &gt;&gt; n;
    std::vector&lt;int&gt; id(n + 1);
    for (int i = 1, op; i &lt;= n; ++i) &#123;
        char t;
        std::cin &gt;&gt; op;
        if (op == 1) &#123;
            std::cin &gt;&gt; t;
            if (!to[0][t - &#39;a&#39;])
                to[0][t - &#39;a&#39;] = ++now;
            ++cnt[to[0][t - &#39;a&#39;]], id[i] = to[0][t - &#39;a&#39;];
        &#125;
        else &#123;
            int j; 
            std::cin &gt;&gt; j &gt;&gt; t;
            if (!to[id[j]][t - &#39;a&#39;])
                to[id[j]][t - &#39;a&#39;] = ++now;
            ++cnt[to[id[j]][t - &#39;a&#39;]], id[i] = to[id[j]][t - &#39;a&#39;];
        &#125;
    &#125;
    int m;
    std::cin &gt;&gt; m;
    std::vector&lt;int&gt; tail(m + 1), res(m + 1);
    for (int i = 1, x; i &lt;= m; ++i) &#123;
        std::string t;
        std::cin &gt;&gt; x &gt;&gt; t, tail[i] = ins(t);
        q[id[x]].push_back(i);
    &#125;
    &#123;
        std::queue&lt;int&gt; q;
        for (int i = 0; i &lt; 26; ++i)
            if (T[0][i])
                q.push(T[0][i]), g[0].push_back(T[0][i]);
        for (; !q.empty(); ) &#123;
            int u = q.front();
            q.pop();
            for (int i = 0; i &lt; 26; ++i)
                if (T[u][i]) &#123;
                    int v = T[u][i];
                    fail[v] = T[fail[u]][i];
                    q.push(v), g[fail[v]].push_back(v);
                &#125;
                else
                    T[u][i] = T[fail[u]][i];
        &#125;
    &#125;
    std::vector&lt;int&gt; dfn(tot + 1), rfn(tot + 1);
    std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;
        static int now = 0;
        dfn[x] = ++now;
        // printf(&quot;%d &quot;, x);
        for (auto i : g[x])
            DFS(i);
        rfn[x] = now;
        return;
    &#125;;
    DFS(0);
    std::function&lt;void(int, int)&gt; DFS1 = [&amp;](int x, int u) &#123;
        add(dfn[u], 1);
        for (auto i : q[x])
            res[i] += ask(rfn[tail[i]]) - ask(dfn[tail[i]] - 1);
        for (int i = 0; i &lt; 26; ++i)
            if (to[x][i])
                DFS1(to[x][i], T[u][i]);
        add(dfn[u], -1);
        return;
    &#125;;
    DFS1(0, 0);
    for (int i = 1; i &lt;= m; ++i)
        std::cout &lt;&lt; res[i] &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;


fail 树的维护
eg. Divljak
https://www.luogu.com.cn/problem/P5840
法一：把动态问题离线
问题相当于将模式串 \(T:\{P\}\) 动态化，但我们仍可以无脑离线下来解决问题。
考虑原本的答案计算过程，即在经过的所有状态及其 fail 链上打标记。现在我们需要离线并区分标记的来源（并且标记类型为布尔值），下意识想到使用线段树维护。
我们对每个状态建立动态开点线段树，最后拓扑排序时使用线段树合并处理信息。容易证明时间复杂度相较原来多了一个 \(\log\)。
理论可行，开始实践 出题人似乎不是很喜欢线段树选手所以决定剥夺你的 Memory Limit。想要用这种做法通过本题可见 https://www.luogu.com.cn/article/jaxk3sno。
法二：转而处理静态问题
注意到题目中的静态的 \(S_x\) 比起 \(T:\{P\}\) 更适合用来做模式串，我们在 \(S_x\) 上构建 AC 自动机，考虑在线解决问题。
在每次 1 操作时，更新模式串信息。对于途径的所有状态 \(\{u\}\)，考虑更新其所在 fail 链上的信息。
注意到我们需要修改整条 fail 链上的信息，询问则是询问单点。这个时候可以考虑使用树上差分。
但是 here comes a problem，我们对于这一整个串只能在整个树上每个点上更新一次。怎么消去相同的影响呢？
这里实现上我们将经过的点按 fail 树上 dfn 排序，并且对于序列中相邻的两点在其 LCA 上减去一次标记。为什么这是正确的呢？参考虚树，我们只需要让序列中相邻的两个点尽量近就可以保证重复的被删除完毕。

#include &lt;bits/stdc++.h&gt;
const int maxn = 2e6 + 5;
int tot, bit[maxn], T[maxn][26], fail[maxn];
int ins(std::string &amp;t) &#123;
    int p = 0;
    for (auto i : t) &#123;
        if (!T[p][i - &#39;a&#39;])
            T[p][i - &#39;a&#39;] = ++tot;
        p = T[p][i - &#39;a&#39;];
    &#125;
    return p;
&#125;
int lowbit(int x) &#123;
    return x &amp; -x;
&#125;
void add(int x, int v) &#123;
    // printf(&quot;add (%d, %d)\n&quot;, x, v);
    for (; x &lt;= tot + 1; x += lowbit(x))
        bit[x] += v;
    return;
&#125;
int ask(int x) &#123;
    int res = 0, to = x;
    for (; x; x -= lowbit(x))
        res += bit[x];
    // printf(&quot;ask(%d) = %d\n&quot;, to, res);
    return res;
&#125;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n, q;
    std::cin &gt;&gt; n;
    std::vector&lt;int&gt; tail(n + 1);
    for (int i = 1; i &lt;= n; ++i) &#123;
        std::string t;
        std::cin &gt;&gt; t, tail[i] = ins(t);
    &#125;
    std::vector&lt;std::vector&lt;int&gt; &gt; g(tot + 2);
    &#123;
        std::queue&lt;int&gt; q;
        for (int i = 0; i &lt; 26; ++i)
            if (T[0][i])
                q.push(T[0][i]);
        for (; !q.empty(); ) &#123;
            int u = q.front();
            q.pop();
            for (int i = 0; i &lt; 26; ++i)
                if (T[u][i]) &#123;
                    int v = T[u][i];
                    fail[v] = T[fail[u]][i];
                    q.push(v);
                &#125;
                else
                    T[u][i] = T[fail[u]][i];
        &#125;
        for (int i = 1; i &lt;= tot; ++i)
            g[fail[i] + 1].push_back(i + 1);
    &#125;
    std::vector&lt;std::array&lt;int, 22&gt; &gt; f(tot + 2);
    std::vector&lt;int&gt; dep(tot + 2), dfn(tot + 2), siz(tot + 2);
    std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;
        static int now = 0;
        siz[x] = 1, dfn[x] = ++now;
        // printf(&quot;%d\n&quot;, x);
        for (auto i : g[x]) &#123;
            dep[i] = dep[x] + 1;
            f[i][0] = x;
            for (int j = 1; j &lt;= 21; ++j)
                f[i][j] = f[f[i][j - 1]][j - 1];
            DFS(i), siz[x] += siz[i];
        &#125;
        return;
    &#125;;
    dep[1] = 1, DFS(1);
    auto askLCA = [&amp;](int x, int y) &#123;
        if (x == y)
            return x;
        if (dep[x] &lt; dep[y])
            std::swap(x, y);
        for (int i = 21; ~i; --i)
            if (dep[f[x][i]] &gt;= dep[y])
                x = f[x][i];
        if (x == y)
            return x;
        for (int i = 21; ~i; --i)
            if (f[x][i] != f[y][i])
                x = f[x][i], y = f[y][i];
        return f[x][0];
    &#125;;
    std::cin &gt;&gt; q;
    for (; q--; ) &#123;
        int op;
        std::cin &gt;&gt; op;
        if (op == 1) &#123;
            std::string s;
            std::cin &gt;&gt; s;
            int p = 0, len = (int)s.length();
            std::vector&lt;int&gt; id(len + 1);
            for (int i = 1; i &lt;= len; ++i)
                p = T[p][s[i - 1] - &#39;a&#39;], id[i] = p + 1;
            std::sort(id.begin() + 1, id.end(), [&amp;](int x, int y) &#123; return dfn[x] &lt; dfn[y]; &#125;);
            // for (int i = 1; i &lt;= len; ++i)
            //     printf(&quot;%d &quot;, id[i]);
            // puts(&quot;&quot;);
            for (int i = 1; i &lt;= len; ++i) &#123;
                // printf(&quot;%d %d %d\n&quot;, i, id[i], dfn[id[i]]);
                // assert(0);
                add(dfn[id[i]], 1);
                if (i != 1)
                    add(dfn[askLCA(id[i], id[i - 1])], -1);
            &#125;
        &#125;
        else &#123;
            int x;
            std::cin &gt;&gt; x;
            x = tail[x] + 1;
            std::cout &lt;&lt; ask(dfn[x] + siz[x] - 1) - ask(dfn[x] - 1) &lt;&lt; &#39;\n&#39;;
        &#125;
    &#125;
    return 0;
&#125;


AC 自动机上的 DP
鉴于 AC 自动机的优秀结构与性质，并不经常作为字符串匹配工具出现，其一个应用是作为 DP 的载体。
eg1. L 语言
https://www.luogu.com.cn/problem/P2292
我们想到要在自动机上匹配，但此时 fail 作为「断句」的唯一手段（断句的位置在链上当前点深度 - fail 深度处），不再仅当失配时才能经过。我们考虑朴素的 DP：在经过的每个状态考虑断句，那么这要求断句处是一个单词的结尾，那么此时 fail 最长匹配长度即可被更新。最后遍历所有单词的末结点，取最大答案。这里的 fail 其实是 fail 链上任意一点。
考虑复杂度。容易发现对于每一个点我们跳了其整条 fail 链，那么复杂度就是最劣 \(n^2\) 的。考虑优化这个过程至 \(O(1)\)。
题目里有一个很重要的条件还没有用到：单个单词长度 \(\le 20\)，这让我们想到状态压缩。对于每一个状态，记录其断出来单词的可能长度。
我们在 DAG 上游走的时候记录目前可以断的所有位置，如果其和当前可断出来的长度之交不为空，就可以将此处加入「可以断的所有位置」并更新答案。

#include &lt;bits/stdc++.h&gt;
const int maxn = 2e5 + 5;
int T[maxn][26], tot, fail[maxn], len[maxn], dep[maxn], tag[maxn];
int ins(std::string &amp;t) &#123;
    int p = 0;
    for (auto i : t) &#123;
        if (!T[p][i - &#39;a&#39;])
            T[p][i - &#39;a&#39;] = ++tot, dep[tot] = dep[p] + 1;
        p = T[p][i - &#39;a&#39;];
    &#125;
    ++tag[p];
    return p;
&#125;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n, m;
    std::cin &gt;&gt; n &gt;&gt; m;
    std::vector&lt;int&gt; tail(n + 1);
    std::vector&lt;std::string&gt; t(n + 1);
    for (int i = 1; i &lt;= n; ++i)
        std::cin &gt;&gt; t[i], tail[i] = ins(t[i]);
    &#123;
        std::queue&lt;int&gt; q;
        for (int i = 0; i &lt; 26; ++i)
            if (T[0][i])
                q.push(T[0][i]);
        for (; !q.empty(); ) &#123;
            int u = q.front();
            q.pop();
            len[u] = len[fail[u]];
            if (tag[u])
                len[u] |= (1 &lt;&lt; dep[u]);
            for (int i = 0; i &lt; 26; ++i)
                if (T[u][i]) &#123;
                    int v = T[u][i];
                    fail[v] = T[fail[u]][i];
                    q.push(v);
                &#125;
                else
                    T[u][i] = T[fail[u]][i];
        &#125;
    &#125;
    for (; m--; ) &#123;
        std::string s;
        std::cin &gt;&gt; s;
        int p = 0, q = 1, res = 0;
        for (int i = 0; i &lt; (int)s.length(); ++i) &#123;
            p = T[p][s[i] - &#39;a&#39;], q &lt;&lt;= 1;
            if (len[p] &amp; q)
                q |= 1, res = i + 1;
        &#125;
        std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
    &#125;
    return 0;
&#125;


eg2. Popcount Words
https://codeforces.com/gym/103409/problem/H
咋上强度了啊。
先把整个序列写出来，即 \(w=\texttt{01101001100101}\cdots\)，尝试进一步探究形式化的规律，可以得到：

\(w_{[0, 2^n), 0}=w_{[0, 2^{n-1}),0}+w_{[0, 2^n), 1}\)，其中 \(w_{[l, r], 0/1}\) 表示 \([l, r]\) 内，原串 / 取反的值。
对于不以 \(0\) 开头的整段，可以从上述规则转化为 \(0\) 开头的整段。

接着不难想到一种类似线段树的方式，将待求的 \(w_{[l, r], 0}\) 分到 \(O(\log V)\) 个整段上，那么 \(S\) 就可以被 \(O(n\log V)\) 个整段（也是 \(\log V\) 个本质不同整段）描述。
我们对 \({p_m}\) 建立 AC 自动机，需要知道这 \(\log V\) 个整段在每个点上的出现次数。对于自动机上任意状态 \(u\)，设 \(to_{u, n, 0/1}\) 表示 \(u\) 经过 \(w_{[0, 2^n), 0/1}\) 后到达的点，则可倍增（嘶，这里是不是应该反过来叫分治啊）简单解决。
那么接下来我们就可以用 \(to\) 来进行快速游走了。顺便打个 \(cnt\) 记录一下每个 \(u\) 作为不同整段的开头被经过的次数。然后做一个 DP，类似于线段树上 pushdown 的操作把所有整段下放到单点上的单个字符。
有一说一用 DP 来处理这个东西还挺难想的。可能也是基于前面的倍增吧。最后拓扑排序就行了。

大家数组一定要用 C-style array 啊，std::vector&lt;&gt; 计算的是申请空间包 MLE 的 
大家大数组一定要内存连续访问优化啊，TLE \(\to\) 100ms 泪目了 
#include &lt;bits/stdc++.h&gt;
const int maxn = 5e5 + 5;
long long sum[maxn], f[2][30][maxn];
int cnt[2][30][maxn], to[2][30][maxn];
int T[maxn][2], tot, fail[maxn], deg[maxn];
int ins(std::string &amp;t) &#123;
    int p = 0;
    for (auto i : t) &#123;
        if (!T[p][i - &#39;0&#39;])
            T[p][i - &#39;0&#39;] = ++tot;
        p = T[p][i - &#39;0&#39;];
    &#125;
    return p;
&#125;
void ask(std::vector&lt;std::pair&lt;int, int&gt; &gt; &amp;s, int ql, int qr, int l = 0, int r = (1 &lt;&lt; 30) - 1, int len = 30, int v = 0) &#123;
    if (ql &lt;= l &amp;&amp; r &lt;= qr) &#123;
        s.emplace_back(len, v);
        return;
    &#125;
    int mid = l + (r - l) / 2;
    if (ql &lt;= mid)
        ask(s, ql, qr, l, mid, len - 1, v);
    if (qr &gt; mid)
        ask(s, ql, qr, mid + 1, r, len - 1, v ^ 1);
    return;
&#125;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n, m;
    std::cin &gt;&gt; n &gt;&gt; m;
    std::vector&lt;std::pair&lt;int, int&gt; &gt; s;
    for (int i = 1; i &lt;= n; ++i) &#123;
        int l, r;
        std::cin &gt;&gt; l &gt;&gt; r;
        ask(s, l, r);
    &#125;
    std::vector&lt;int&gt; tail(m + 1);
    for (int i = 1; i &lt;= m; ++i) &#123;
        std::string t;
        std::cin &gt;&gt; t;
        tail[i] = ins(t);
    &#125;
    &#123;
        std::queue&lt;int&gt; q;
        for (int i = 0; i &lt; 2; ++i)
            if (T[0][i])
                q.push(T[0][i]);
        for (; !q.empty(); ) &#123;
            int u = q.front();
            q.pop();
            for (int i = 0; i &lt; 2; ++i)
                if (T[u][i]) &#123;
                    int v = T[u][i];
                    fail[v] = T[fail[u]][i], ++deg[T[fail[u]][i]];
                    q.push(v);
                &#125;
                else
                    T[u][i] = T[fail[u]][i];
        &#125;
    &#125;
    for (int i = 0; i &lt;= tot; ++i)
        to[0][0][i] = T[i][0], to[1][0][i] = T[i][1];
    for (int j = 1; j &lt; 30; ++j)
        for (int i = 0; i &lt;= tot; ++i) &#123;
            to[0][j][i] = to[1][j - 1][to[0][j - 1][i]];
            to[1][j][i] = to[0][j - 1][to[1][j - 1][i]];
        &#125;
    &#123;
        int p = 0;
        for (auto [n, i] : s) &#123;
            // printf(&quot;# %d %d\n&quot;, n, i);
            ++cnt[i][n][p], p = to[i][n][p];
        &#125;
    &#125;
    for (int j = 29; ~j; --j)
        for (int i = 0; i &lt;= tot; ++i) &#123;
            if (j != 29) &#123;
                f[0][j][i] += f[0][j + 1][i];
                f[1][j][i] += f[1][j + 1][i];
                f[0][j][to[1][j][i]] += f[1][j + 1][i];
                f[1][j][to[0][j][i]] += f[0][j + 1][i];
            &#125;
            f[1][j][i] += cnt[1][j][i];
            f[0][j][i] += cnt[0][j][i];
        &#125;
    for (int i = 0; i &lt;= tot; ++i) &#123;
        sum[T[i][0]] += f[0][0][i], sum[T[i][1]] += f[1][0][i];
        // printf(&quot;%d %d\n&quot;, f[i][0][0], f[i][0][1]);
    &#125;
    &#123;
        std::queue&lt;int&gt; q;
        for (int i = 0; i &lt;= tot; ++i)
            if (!deg[i])
                q.push(i);
        for (; !q.empty(); ) &#123;
            int u = q.front();
            q.pop();
            sum[fail[u]] += sum[u];
            if (!--deg[fail[u]])
                q.push(fail[u]);
        &#125;
    &#125;
    for (int i = 1; i &lt;= m; ++i)
        std::cout &lt;&lt; sum[tail[i]] &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;


eg3. Legen…
https://codeforces.com/problemset/problem/696/D
先在 fail 树上把每个状态的实际价值计算出来。我们发现匹配串是未知的，也就是我们需要主动决定游走路径。注意到 \(l=10^{14}\)，考虑矩阵。
令 \(f_{u, i}\) 表示在 \(u\) 状态时已经走了 \(i\) 步，可以得到的最大价值。那么显然有：
\[
f_{v,i+1}=f_{u,i}+s_v.
\]
其中 \(v\) 是自动机上 \(u\) 的任意出边。图的大小为 \(200\)，可以放到 \(+\max\) 矩阵里加速转移。

#include &lt;bits/stdc++.h&gt;
const int maxn = 2e5 + 5;
const long long inf = 1e18;
int fail[maxn], T[maxn][26], tot;
int ins(std::string s) &#123;
    int p = 0;
    for (auto i : s) &#123;
        if (!T[p][i - &#39;a&#39;])
            T[p][i - &#39;a&#39;] = ++tot;
        p = T[p][i - &#39;a&#39;];
    &#125;
    return p;
&#125;
struct matrix &#123;
    int n, m;
    std::vector&lt;std::vector&lt;long long&gt; &gt; a;
    matrix(int n1, int m1, long long v = -inf, bool op = 0): n(n1), m(m1), a(n + 1, std::vector&lt;long long&gt; (m + 1, v)) &#123;
        if (op)
            for (int i = 0; i &lt;= n; ++i)
                a[i][i] = 0;
        return;
    &#125;
    std::vector&lt;long long&gt; &amp;operator[] (int i) &#123;
        return a[i];
    &#125;
    matrix operator* (matrix &amp;q) const &#123;
        matrix res(n, q.m);
        for (int k = 0; k &lt;= m; ++k)
            for (int i = 0; i &lt;= n; ++i)
                for (int j = 0; j &lt;= q.m; ++j)
                    res[i][j] = std::max(res[i][j], a[i][k] + q[k][j]);
        return res;
    &#125;
    matrix&amp; operator*= (matrix q) &#123;
        return *this = *this * q;
    &#125;
    matrix operator^ (long long q) &#123;
        matrix res(n, n, -inf, 1), x(*this);
        for (; q; q &gt;&gt;= 1, x *= x)
            if (q &amp; 1)
                res *= x;
        return res;
    &#125;
&#125;;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n;
    long long m;
    std::cin &gt;&gt; n &gt;&gt; m;
    std::vector&lt;long long&gt; a(n + 1);
    for (int i = 1; i &lt;= n; ++i)
        std::cin &gt;&gt; a[i];
    std::vector&lt;int&gt; tail(n + 1);
    std::vector&lt;std::string&gt; t(n + 1);
    for (int i = 1; i &lt;= n; ++i) &#123;
        std::cin &gt;&gt; t[i];
        tail[i] = ins(t[i]);
    &#125;
    std::vector&lt;long long&gt; s(tot + 1);
    for (int i = 1; i &lt;= n; ++i)
        s[tail[i]] += a[i];
    &#123;
        std::queue&lt;int&gt; q;
        for (int i = 0; i &lt; 26; ++i)
            if (T[0][i])
                q.push(T[0][i]); 
        for (; !q.empty(); ) &#123;
            int u = q.front();
            q.pop();
            for (int i = 0; i &lt; 26; ++i)
                if (T[u][i]) &#123;
                    int v = T[u][i];
                    fail[v] = T[fail[u]][i], s[v] += s[fail[v]];
                    q.push(v);
                &#125;
                else
                    T[u][i] = T[fail[u]][i];
        &#125;
    &#125;
    matrix f(0, tot), op(tot, tot);
    f[0][0] = 0;
    for (int i = 0; i &lt;= tot; ++i)
        for (int j = 0; j &lt; 26; ++j)
            op[i][T[i][j]] = s[T[i][j]];
    f *= (op * m);
    std::cout &lt;&lt; *std::max_element(f[0].begin(), f[0].end()) &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;



eg4. You Are Given Some Strings…
goto link.
]]></content>
      <tags>
        <tag>DP</tag>
        <tag>字符串</tag>
        <tag>AC 自动机</tag>
      </tags>
  </entry>
  <entry>
    <title>学习笔记：字符串拆分</title>
    <url>/20250121/</url>
    <content><![CDATA[神刘家在走前体育课上问我听没听过 Die For You - The Weekend。我让他哼一段，刘家便展示了自己的天籁之音，我理所当然地连旋律都没辨认出来。


有的时候，对于一个完整的匹配串，我们需要「枚举断点」，分为前半段和后半段分别和模式串匹配解决问题。当然这样的技巧不止局限于字符串，我们在之前的学习中在诸如动态规划等题目中遇到了相似的情景。
在字符串题目中，一个典型的标志是「模式串的拼接」，将两截模式串拼接到一起，形成的新模式串并不利好我们的处理，我们需要尽量利用已知的模式串。当然我们不会将新模式串重新拆成两半，而是考虑转换，枚举匹配串的断点，将前半段的后缀和后半段的前缀分别匹配。

一个模板：CF1202E You Are Given Some Strings…
https://codeforces.com/problemset/problem/1202/E
虽然对于每种不同拼接需要求解分别的出现次数，但是注意到最后只需要输出 \(f\) 的总和，所以就可以不再顾及不同拼接方式间的区别。
枚举匹配串的断点。一个自然的想法是将前后缀与 AC 自动机匹配，但如果逐个放进去显然复杂度起飞。这里就又有一个实现小技巧，我们在原串的 AC 自动机上把原串过一遍，每个位置所在的状态就是这个位置对应后缀可能处在的后缀。
记录每个状态可能处在的模式串末尾个数，这一点直接在 fail 树上从上到下转移即可。反串同理。
二者相乘即为答案。

#include &lt;bits/stdc++.h&gt;
const int maxn = 2e5 + 5;
struct &#123;
    int T[maxn][26], tot, cnt[maxn], fail[maxn], deg[maxn];
    void ins(std::string &amp;t) &#123;
        int p = 0;
        for (auto i : t) &#123;
            if (!T[p][i - &#39;a&#39;])
                T[p][i - &#39;a&#39;] = ++tot;
            p = T[p][i - &#39;a&#39;];
        &#125;
        ++cnt[p];
        return;
    &#125;
    void bld(void) &#123;
        std::queue&lt;int&gt; q;
        for (int i = 0; i &lt; 26; ++i)
            if (T[0][i])
                q.push(T[0][i]);
        for (; !q.empty(); ) &#123;
            int u = q.front();
            q.pop();
            for (int i = 0; i &lt; 26; ++i)
                if (T[u][i]) &#123;
                    int v = T[u][i];
                    fail[v] = T[fail[u]][i], cnt[v] += cnt[fail[v]];
                    q.push(v);
                &#125;
                else
                    T[u][i] = T[fail[u]][i];
        &#125;
        return;
    &#125;
&#125; p, q;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    std::string s;
    std::cin &gt;&gt; s;
    int n;
    std::cin &gt;&gt; n;
    for (int i = 1; i &lt;= n; ++i) &#123;
        std::string t;
        std::cin &gt;&gt; t;
        p.ins(t);
        std::reverse(t.begin(), t.end());
        q.ins(t);
    &#125;
    p.bld(), q.bld();
    int len = s.length();
    std::vector&lt;std::array&lt;int, 2&gt; &gt; f(len + 1);
    &#123;
        int u = 0;
        for (int i = 1; i &lt;= len; ++i) &#123;
            u = p.T[u][s[i - 1] - &#39;a&#39;];
            f[i][0] = p.cnt[u];
        &#125;
    &#125;
    &#123;
        int u = 0;
        for (int i = len; i; --i) &#123;
            u = q.T[u][s[i - 1] - &#39;a&#39;];
            f[i][1] = q.cnt[u];
        &#125;
    &#125;
    long long res = 0ll;
    for (int i = 1; i &lt; len; ++i)
        res += (long long)f[i][0] * f[i + 1][1];
    std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;


变式：优秀的拆分
https://www.luogu.com.cn/problem/P1117
]]></content>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>学习笔记：后缀数组</title>
    <url>/20250202/</url>
    <content><![CDATA[非常后知后觉地意识到 SA(Suffix Array) 和 SAM(Suffix Automaton) 的 A 不是同一个 A 


定义

一个长度为 \(n\) 的字符串中有 \(n\) 个长度分别为 \(1\sim n\) 的后缀
对其按字典序排序，分别存储下排名为 \(i\) 的后缀编号 \(sa_i\) 和每个后缀 \(i\) 的排名 \(rk_i\)。
这样相当于构造了有序的『前缀的后缀』，所以会有很多字符串功能。

求解
哈希 + 排序

直接把所有后缀拿来排序的话，字符串比较是 \(O(n)\) 的。
用哈希 + 二分优化比较过程，就可以把整个排序优化到 \(O(n\log^2 n)\)。

倍增

首先，把后缀按照 \(s_i\)，即第一个字符排序；记排序后排名序列为 \(a\)。
相似地，对于第 \(i\) 个后缀，我们用 \((a_i,a_{i+1})\) 双关键字排序，即可按照后缀的前两个字符排序；记此时排名序列为 \(b\)。
进一步地，用 \((b_i,b_{i+2})\) 进行双关键字排序，即可实现按后缀的前四个字符排序。
进行 \(\log n\) 次双关键字排序后，就能完成对整个后缀的正确排序。
由于把字符串排序压缩成了值域很小的整数排序，用桶排就可以减一个 \(\log\)，实现 \(O(n\log n)\) 求 SA。

实现

哈希很好实现，这里按下不表。主要讲解倍增法的实现。
首先了解双关键字桶排的方法：
计算出第一关键字的桶序列，令桶 \(c_i\) 记录前 \(i\) 个元素的数量。这样做的目的是让桶 \(c\) 充当计算下标范围的作用，\((c_{i-1},c_i]\) 即为 \(i\) 分布的范围。
遍历排序后的第二关键字数组（在 SA 中，排序在上一轮完成），将元素放到第一关键字在 \(c\) 中记录的下标中，并将 \(c\) 中数值 \(-1\)。
显然当排名种类为 \(n\)，即没有并列排名时，排序完成。
设本轮区间长度为 \(2w\)，对于一轮操作：

计算每个区间按后 \(w\) 长度字符排序的结果：\((n-w,n]\) 开头的区间后半段均为空，直接放在序列首端；接着按照上一轮 \(sa\) 结果，把能够作为后半段的元素依次放入。
依照上一轮的 \(rk\) 作为第二关键字排名，进行双关键字桶排。
依照得到的 \(sa\) 和第二关键字的排名，处理并列，求出这一轮的 \(rk\)。



倒着写是为了保证所谓稳定性。然而并没有什么所谓。
std::vector&lt;int&gt; sa(n + 1), rk(2 * n + 1);
&#123;
    int m = 128;
    std::vector&lt;int&gt; c(std::max(n, m) + 1), id, la(2 * n + 1);
    std::copy(s.begin() + 1, s.end(), rk.begin() + 1);
    for (int i = 1; i &lt;= n; ++i)
        ++c[rk[i]];
    std::partial_sum(c.begin() + 1, c.begin() + m + 1, c.begin() + 1);
    for (int i = n; i; --i)
        sa[c[rk[i]]--] = i;
    for (int w = 1, p; ; w &lt;&lt;= 1, m = p) &#123;
        id.clear(), id.push_back(-1);
        for (int i = n - w + 1; i &lt;= n; ++i)
            id.push_back(i);
        for (int i = 1; i &lt;= n; ++i)
            if (sa[i] &gt; w)
                id.push_back(sa[i] - w);
        std::fill(c.begin() + 1, c.begin() + m + 1, 0);
        for (int i = 1; i &lt;= n; ++i)
            ++c[rk[i]];
        std::partial_sum(c.begin() + 1, c.begin() + m + 1, c.begin() + 1);
        for (int i = n; i; --i)
            sa[c[rk[id[i]]]--] = id[i];
        p = 0;
        std::copy(rk.begin() + 1, rk.end(), la.begin() + 1);
        for (int i = 1; i &lt;= n; ++i)
            if (i != 1 &amp;&amp; la[sa[i]] == la[sa[i - 1]] &amp;&amp; la[sa[i] + w] == la[sa[i - 1] + w])
                rk[sa[i]] = p;
            else
                rk[sa[i]] = ++p;
        if (p == n)
            break;
    &#125;
&#125;


纯 SA 的应用
最小表示法
https://www.luogu.com.cn/problem/P1368。

对于循环位移相关要求，首先考虑将 \(\texttt s\) 重复一遍。
在 \(\texttt {ss}\) 中找到第一个 \(sa_i\le n\) 即为答案。


#include &lt;bits/stdc++.h&gt;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n;
    std::cin &gt;&gt; n;
    std::vector&lt;int&gt; s(2 * n + 1);
    for (int i = 1; i &lt;= n; ++i)
        std::cin &gt;&gt; s[i], s[n + i] = s[i];
    std::vector&lt;int&gt; sa(2 * n + 1), rk(s);
    &#123;
        int m = 29;
        &#123;
            std::vector&lt;int&gt; c(m + 1);
            for (int i = 1; i &lt;= 2 * n; ++i)
                ++c[rk[i]];
            std::partial_sum(c.begin(), c.end(), c.begin());
            for (int i = 2 * n; i; --i)
                sa[c[rk[i]]--] = i;
        &#125;
        for (int w = 1, p; ; w &lt;&lt;= 1, m = p) &#123;
            std::vector&lt;int&gt; id(1);
            for (int i = 2 * n - w + 1; i &lt;= 2 * n; ++i)
                id.push_back(i);
            for (int i = 1; i &lt;= 2 * n; ++i)
                if (sa[i] &gt; w)
                    id.push_back(sa[i] - w);
            std::vector&lt;int&gt; c(m + 1);
            for (int i = 1; i &lt;= 2 * n; ++i)
                ++c[rk[i]];
            std::partial_sum(c.begin(), c.end(), c.begin());
            for (int i = 2 * n; i; --i)
                sa[c[rk[id[i]]]--] = id[i];
            auto la(rk);
            p = 0;
            for (int i = 1; i &lt;= 2 * n; ++i)
                if (i != 1 &amp;&amp; la[sa[i]] == la[sa[i - 1]] &amp;&amp; la[sa[i] + w] == la[sa[i - 1] + w])
                    rk[sa[i]] = p;
                else
                    rk[sa[i]] = ++p;
            if (p == 2 * n)
                break;
        &#125;
    &#125;
    for (int i = 1; i &lt;= 2 * n; ++i)
        if (sa[i] &lt;= n) &#123;
            for (int j = sa[i]; j &lt; n + sa[i]; ++j)
                std::cout &lt;&lt; s[j] &lt;&lt; &#39; &#39;;
            std::cout &lt;&lt; &#39;\n&#39;;
            break;
        &#125;
    return 0;
&#125;


字符串匹配

二分，复杂度 \(O(|S|\log |T|)\)。求出现次数则二分左右边界。
太麻烦了且没有实际应用价值，代码略。


height 数组
定义 \(h_i=\text {lcp}(sa_i, sa_i-1)\)，特别地，\(h_1=0\)。

有引理：\(h_{rk_i}\ge h_{rk_{i-1}}-1\)。

假设已经求出 \(h_{rk_{i-1}}\)，那么可以从 \(h_{rk_{i-1}}-1\) 出发暴力看下一个字符是否相等得到答案。那么我们会发现从前往后 \(h\) 值每次最多 \(-1\)，所以复杂度摊下来是 \(O(n)\) 的。
记住记住一定是 \(rk_{i-1}\) 而不是下意识的 \(rk_i-1\)！！！所以为了保证求解顺序循环枚举的一定是下标而非排名。但是注意定义却是和 \(rk_i-1\) 的 lcp！！！所以求 height 的写法是相对固定的，不能觉得好像是对的就随便乱改。

height 数组的应用
相当于背板子，因为应用太多且形式大多固定。
求任意两个后缀的 lcp
易得 \(\text{lcp}(sa_i, sa_j)=\min\{h_{i+1}, \cdots, h_j\}\)。故应将一些复杂 lcp 问题的解决方式和 RMQ 联系起来。

子串大小关系
即比较 \(S_{l_1, r_1}\) 和 \(S_{l_2, r_2}\) 的大小关系。比较导致 lcp 不能继续延伸的元素大小即可。

本质不同子串数量
子串等价于「后缀的前缀」。按顺序枚举每个后缀，减去和已枚举的所有后缀的 lcp 即可。鉴于 \(\min\{h_{j+1},\cdots,h_i\}\) 单调不减，直接减去 \(h_i\) 即可。
最后答案即为 \(\frac {n(n-1)}2 - \sum\limits_{i=2}^nh_i\)。

至少出现 \(k\) 次子串的最大长度
模板：https://www.luogu.com.cn/problem/P2852。
出现 \(k\) 次 \(\iff\) 在后缀数组中连续出现 \(k\) 次 \(\iff\) 是任意连续 \(k-1\) 个 \(h\) 的最小值，需要最大化该最小值，考虑滑动窗口。

#include &lt;bits/stdc++.h&gt;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;P2852_7.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n, k;
    std::cin &gt;&gt; n &gt;&gt; k, --k;
    std::vector&lt;int&gt; s(n + 1);
    for (int i = 1; i &lt;= n; ++i)
        std::cin &gt;&gt; s[i];
    std::vector&lt;int&gt; sa(n + 1), rk(s), h(n + 1);
    &#123;
        int m = 1000001;
        &#123;
            std::vector&lt;int&gt; c(m + 1);
            for (int i = 1; i &lt;= n; ++i)
                ++c[rk[i]];
            std::partial_sum(c.begin(), c.end(), c.begin());
            for (int i = n; i; --i)
                sa[c[rk[i]]--] = i;
        &#125;
        for (int w = 1, p; ; w &lt;&lt;= 1, m = p) &#123;
            std::vector&lt;int&gt; id(1);
            for (int i = n - w + 1; i &lt;= n; ++i)
                id.push_back(i);
            for (int i = 1; i &lt;= n; ++i)
                if (sa[i] &gt; w)
                    id.push_back(sa[i] - w);
            std::vector&lt;int&gt; c(m + 1);
            for (int i = 1; i &lt;= n; ++i)
                ++c[rk[i]];
            std::partial_sum(c.begin(), c.end(), c.begin());
            for (int i = n; i; --i)
                sa[c[rk[id[i]]]--] = id[i];
            auto la(rk);
            p = 0;
            for (int i = 1; i &lt;= n; ++i)
                if (i != 1 &amp;&amp; la[sa[i]] == la[sa[i - 1]] &amp;&amp; la[sa[i] + w] == la[sa[i - 1] + w])
                    rk[sa[i]] = p;
                else
                    rk[sa[i]] = ++p;
            if (p == n)
                break;
        &#125;
        for (int i = 1, to = 0; i &lt;= n; ++i)
            if (rk[i]) &#123;
                for (to = std::max(to - 1, 0); s[i + to] == s[sa[rk[i] - 1] + to]; ++to);
                h[rk[i]] = to;
            &#125;
    &#125;
    std::vector&lt;int&gt; q(n + 1);
    int res = 0;
    for (int i = 1, l = 1, r = 0; i &lt;= n; ++i) &#123;
        // printf(&quot;%d\n&quot;, h[i]);
        for (; l &lt;= r &amp;&amp; i - q[l] &gt;= k; ++l);
        for (; l &lt;= r &amp;&amp; h[i] &lt;= h[q[r]]; --r);
        q[++r] = i;
        if (i &gt;= k)
            res = std::max(res, h[q[l]]);
    &#125;
    std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;


最长不重叠多次出现子串
bb：定式太多太杂以至于让人怀疑某些定式是否存在应用场景 
发现满足单调性，二分子串长度 \(len\)，那么显然 \(\text {lcp}\ge len\)；将 \(h\) 划分为连续 \(\ge len\) 的段，在每段内找到下标极差与 \(len\) 比较即可。
也可以用于判定是否存在不重叠多次出现子串。
甚至可以考虑限制至少出现次数为 \(k\)，那大概多个 \(\log\)，看看一段里有没有 \(\ge k\) 个相互相差 \(\ge len\) 的。排序贪心求解。
那么上面的至少出现 \(k\) 次子串也可以用这个方法来解，但是多个 \(\log\) 没必要。
也可以限制多次出现但长度至少为 \(len\)，那甚至少了二分的 \(\log\)，直接跑一遍 check 即可。
？？？到底为什么会有这么多奇怪的定式，是因为真的有题这么出吗？？？ 

最长公共子串问题
求 \(S\) 和 \(T\) 的最长公共子串（注意不是 LCS）。设 \(S\) 长为 \(n\)，\(T\) 长为 \(m\)，那么将 \(S\) 与 \(T\) 拼接，答案就是 \(\max \{\text{lcp}(i,j)\},i\le n&lt;j\)。
但这里不直接枚举 \(i\) 和 \(j\)，还是照例先从 \(h\) 下手再卡条件，若 \(sa_{i-1}\le n&lt;sa_{i}\)（或者反过来），就可以用 \(h_i\) 更新答案。容易证明这样总可以找到最大值。
eg1. 找相同字符
https://www.luogu.com.cn/problem/P3181
要求方案数，那么答案为 \(\text{lcp}(i,j),i\le n&lt;j\)。（我已经帮你们试过了容斥比直接做更麻烦），考虑用单调栈维护左 / 右侧区间 lcp 求解右 / 左侧答案。关于单调栈的描述可见 本页后部内容。

#include &lt;bits/stdc++.h&gt;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n, n1;
    std::string s, t;
    std::cin &gt;&gt; s &gt;&gt; t;
    n = (int)s.length(), n1 = n + (int)t.length() + 1;
    s = &quot;#&quot; + s + &quot;$&quot; + t;
    std::vector&lt;int&gt; sa(n1 + 1), rk(n1 + 1), h(n1 + 1);
    &#123;
        std::copy(s.begin() + 1, s.end(), rk.begin() + 1);
        int m = 128;
        &#123;
            std::vector&lt;int&gt; c(m + 1);
            for (int i = 1; i &lt;= n1; ++i)
                ++c[rk[i]];
            std::partial_sum(c.begin(), c.end(), c.begin());
            for (int i = n1; i; --i)
                sa[c[rk[i]]--] = i;
        &#125;
        for (int w = 1, p; ; w &lt;&lt;= 1, m = p) &#123;
            std::vector&lt;int&gt; id(w + 1);
            std::iota(id.begin() + 1, id.end(), n1 - w + 1);
            for (int i = 1; i &lt;= n1; ++i)
                if (sa[i] &gt; w)
                    id.push_back(sa[i] - w);
            std::vector&lt;int&gt; c(m + 1);
            for (int i = 1; i &lt;= n1; ++i)
                ++c[rk[i]];
            std::partial_sum(c.begin(), c.end(), c.begin());
            for (int i = n1; i; --i)
                sa[c[rk[id[i]]]--] = id[i];
            p = 0;
            auto la(rk);
            for (int i = 1; i &lt;= n1; ++i)
                if (i != 1 &amp;&amp; la[sa[i]] == la[sa[i - 1]] &amp;&amp; la[sa[i] + w] == la[sa[i - 1] + w])
                    rk[sa[i]] = p;
                else
                    rk[sa[i]] = ++p;
            if (p == n1)
                break;
        &#125;
        for (int i = 1, to = 0; i &lt;= n1; ++i) &#123;
            for (to = std::max(to - 1, 0); s[i + to] == s[sa[rk[i] - 1] + to]; ++to);
            h[rk[i]] = to;
        &#125;
    &#125;
    std::vector&lt;std::pair&lt;int, long long&gt; &gt; q1, q2;
    std::vector&lt;int&gt; tot1(n1 + 1), tot2(n1 + 1);
    for (int i = 1; i &lt;= n1; ++i) &#123;
        tot1[i] = tot1[i - 1] + (sa[i] &lt;= n);
        tot2[i] = tot2[i - 1] + (sa[i] &gt; n + 1);
    &#125;
    long long res = 0ll;
    q1.emplace_back(1, 0ll), q2.emplace_back(1, 0ll);
    for (int i = 1; i &lt;= n1; ++i) &#123;
        for (; !q1.empty() &amp;&amp; h[i] &lt; h[q1.back().first]; q1.pop_back());
        q1.emplace_back(i, (tot1[i - 1] - tot1[q1.back().first - 1]) * h[i] + q1.back().second);
        if (sa[i] &gt; n + 1)
            res += q1.back().second;
        for (; !q2.empty() &amp;&amp; h[i] &lt; h[q2.back().first]; q2.pop_back());
        q2.emplace_back(i, (tot2[i - 1] - tot2[q2.back().first - 1]) * h[i] + q2.back().second);
        if (sa[i] &lt;= n)
            res += q2.back().second;
    &#125;
    std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;

eg2. 公共串
https://www.luogu.com.cn/problem/P5546
要求多串最长公共子串，仍然考虑将多个串拼在一起。仿照前面二分的方式处理，问题转化为找到最长的 \(len\)，使得存在一段最小值 \(\ge len\) 的区间，其覆盖了 \(n\) 段串。

#include &lt;bits/stdc++.h&gt;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n, l = 0, r = 0;
    std::cin &gt;&gt; n;
    std::string s;
    std::vector&lt;std::pair&lt;int, int&gt; &gt; lim(n + 1);
    for (int i = 1; i &lt;= n; ++i) &#123;
        std::string t;
        std::cin &gt;&gt; t;
        lim[i] = &#123; (int)s.length() + 1, s.length() + t.length() &#125;;
        s += &quot;#&quot; + t;
        r = std::max(r, (int)t.length());
        // printf(&quot;[%d, %d]\n&quot;, lim[i].first, lim[i].second);
    &#125;
    int n1 = lim.back().second;
    std::vector&lt;int&gt; sa(n1 + 1), rk(n1 + 1), h(n1 + 1);
    &#123;
        std::copy(s.begin() + 1, s.end(), rk.begin() + 1);
        int m = 128;
        &#123;
            std::vector&lt;int&gt; c(m + 1);
            for (int i = 1; i &lt;= n1; ++i)
                ++c[rk[i]];
            std::partial_sum(c.begin(), c.end(), c.begin());
            for (int i = n1; i; --i)
                sa[c[rk[i]]--] = i;
        &#125;
        for (int w = 1, p; ; w &lt;&lt;= 1, m = p) &#123;
            std::vector&lt;int&gt; id(w + 1);
            std::iota(id.begin() + 1, id.end(), n1 - w + 1);
            for (int i = 1; i &lt;= n1; ++i)
                if (sa[i] &gt; w)
                    id.push_back(sa[i] - w);
            std::vector&lt;int&gt; c(m + 1);
            for (int i = 1; i &lt;= n1; ++i)
                ++c[rk[i]];
            std::partial_sum(c.begin(), c.end(), c.begin());
            for (int i = n1; i; --i)
                sa[c[rk[id[i]]]--] = id[i];
            p = 0;
            auto la(rk);
            for (int i = 1; i &lt;= n1; ++i)
                if (i != 1 &amp;&amp; la[sa[i]] == la[sa[i - 1]] &amp;&amp; la[sa[i] + w] == la[sa[i - 1] + w])
                    rk[sa[i]] = p;
                else
                    rk[sa[i]] = ++p;
            if (p == n1)
                break;
        &#125;
        for (int i = 1, to = 0; i &lt;= n1; ++i) &#123;
            for (to = std::max(to - 1, 0); s[i + to] == s[sa[rk[i] - 1] + to]; ++to);
            h[rk[i]] = to;
        &#125;
    &#125;
    // for (int i = 1; i &lt;= n1; ++i)
    //     printf(&quot;h[%d] = %d\n&quot;, sa[i], h[i]);
    int res = 0;
    auto check = [&amp;](int len) &#123;
        // printf(&quot;check %d: \n&quot;, len);
        std::vector&lt;int&gt; cnt(n + 1);
        for (int i = 1; i &lt;= n1; ++i) &#123;
            if (h[i] &lt; len) &#123;
                if (*std::min_element(cnt.begin() + 1, cnt.end()))
                    return 1;
                cnt.assign(n + 1, 0);
            &#125;
            else
                for (int j = 1; j &lt;= n; ++j) &#123;
                    if (lim[j].first &lt;= sa[i - 1] &amp;&amp; sa[i - 1] &lt;= lim[j].second)
                        cnt[j] = 1;
                    if (lim[j].first &lt;= sa[i] &amp;&amp; sa[i] &lt;= lim[j].second)
                        cnt[j] = 1;
                &#125;
        &#125;
        // printf(&quot;\n%d\n&quot;, *std::min_element(cnt.begin() + 1, cnt.end()));
        return *std::min_element(cnt.begin() + 1, cnt.end());
    &#125;;
    for (int mid; l &lt;= r; ) &#123;
        mid = (l + r) &gt;&gt; 1;
        if (check(mid))
            l = mid + 1, res = mid;
        else
            r = mid - 1;
    &#125;
    std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;

但是看了题解发现居然还有线性做法（当然不看建 SA 的 \(\log\)），对于覆盖全部 \(n\) 段串找区间最小值，发现需要最小化区间，考虑双指针。
区间最小值用单调队列求解，细想可能会觉得不太对劲，但是容易证明答案不大于队首且不小于最大队首，所以最大队首就是答案。

#include &lt;bits/stdc++.h&gt;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n, l = 0, r = 0;
    std::cin &gt;&gt; n;
    std::string s;
    std::vector&lt;std::pair&lt;int, int&gt; &gt; lim(n + 1);
    for (int i = 1; i &lt;= n; ++i) &#123;
        std::string t;
        std::cin &gt;&gt; t;
        lim[i] = &#123; (int)s.length() + 1, s.length() + t.length() &#125;;
        s += (char)(&#39;A&#39; + i - 1) + t;
        r = std::max(r, (int)t.length());
    &#125;
    int n1 = lim.back().second;
    std::vector&lt;int&gt; sa(n1 + 1), rk(n1 + 1), h(n1 + 1);
    &#123;
        std::copy(s.begin() + 1, s.end(), rk.begin() + 1);
        int m = 128;
        &#123;
            std::vector&lt;int&gt; c(m + 1);
            for (int i = 1; i &lt;= n1; ++i)
                ++c[rk[i]];
            std::partial_sum(c.begin(), c.end(), c.begin());
            for (int i = n1; i; --i)
                sa[c[rk[i]]--] = i;
        &#125;
        for (int w = 1, p; ; w &lt;&lt;= 1, m = p) &#123;
            std::vector&lt;int&gt; id(w + 1);
            std::iota(id.begin() + 1, id.end(), n1 - w + 1);
            for (int i = 1; i &lt;= n1; ++i)
                if (sa[i] &gt; w)
                    id.push_back(sa[i] - w);
            std::vector&lt;int&gt; c(m + 1);
            for (int i = 1; i &lt;= n1; ++i)
                ++c[rk[i]];
            std::partial_sum(c.begin(), c.end(), c.begin());
            for (int i = n1; i; --i)
                sa[c[rk[id[i]]]--] = id[i];
            p = 0;
            auto la(rk);
            for (int i = 1; i &lt;= n1; ++i)
                if (i != 1 &amp;&amp; la[sa[i]] == la[sa[i - 1]] &amp;&amp; la[sa[i] + w] == la[sa[i - 1] + w])
                    rk[sa[i]] = p;
                else
                    rk[sa[i]] = ++p;
            if (p == n1)
                break;
        &#125;
        for (int i = 1, to = 0; i &lt;= n1; ++i) &#123;
            for (to = std::max(to - 1, 0); s[i + to] == s[sa[rk[i] - 1] + to]; ++to);
            h[rk[i]] = to;
        &#125;
    &#125;
    int res = 0;
    std::vector&lt;int&gt; q(n1 + 1), cnt(n + 1);
    // for (int i = 1; i &lt;= n1; ++i)
    //     printf(&quot;%d: %d\n&quot;, sa[i], h[i]);
    for (int l = 1, r = 0, ql = 1, qr = 0; l &lt;= n1; ++l) &#123;
        for (; r &lt; n1 &amp;&amp; !*std::min_element(cnt.begin() + 1, cnt.end()); ) &#123;
            ++r;
            for (int i = 1; i &lt;= n; ++i)
                if (lim[i].first &lt;= sa[r] &amp;&amp; sa[r] &lt;= lim[i].second) &#123;
                    ++cnt[i];
                    break;
                &#125;
            for (; ql &lt;= qr &amp;&amp; h[r] &lt;= h[q[qr]]; --qr);
            q[++qr] = r;
        &#125;
        if (*std::min_element(cnt.begin() + 1, cnt.end())) &#123;
            // printf(&quot;[%d, %d]: %d\n&quot;, l, r, h[q[ql]]);
            res = std::max(res, h[q[ql]]);
        &#125;
        for (; ql &lt;= qr &amp;&amp; q[ql] &lt;= l; ++ql);
        if (l != 1) &#123;
            for (int i = 1; i &lt;= n; ++i)
                if (lim[i].first &lt;= sa[l - 1] &amp;&amp; sa[l - 1] &lt;= lim[i].second) &#123;
                    --cnt[i];
                    break;
                &#125;
        &#125;
    &#125;
    std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;


\(\texttt {AA}\) 式子串处理
即对于连续相同子串问题的处理，有一个定的思路，由例题分析。
eg1. 优秀的拆分
https://www.luogu.com.cn/problem/P1117
还是从中间分开，按前后分别处理。这里有个 trick，我们枚举 \(\texttt B\) 的长度 \(len\)，在 \(S\) 中每隔 \(len\) 打一个标记。那么显然，任意一个长度为 \(2\times len\) 的子串都会经过恰好两个标记（充分的），这样就可以筛选出所有可能的串。
我们枚举所有连续两个标记（总复杂度为调和级数），求它们对应后缀的 lcp 和对应前缀的 lcs（翻转求 SA 即可），如果二者加起来 \(\ge len\) 就说明存在这样的 \(\texttt {AA}\)。在 \(\text {lcs}+\text {lcp}\) 中任取 \(len\) 长度即为一对 \(\texttt {AA}\)。用差分给可能的起点和终点区间加即可。
小细节：lcp 和 lcs 均需要对 \(len\) 取 \(\min\)，否则取到的串可能不会经过当前选中的两个标记。

#include &lt;bits/stdc++.h&gt;
class SA &#123;
public:
    std::vector&lt;int&gt; sa, rk, h;
    std::vector&lt;std::vector&lt;int&gt;  &gt; st;
    SA(int n, std::string s): sa(n + 1), rk(n + 2), h(n + 1), st(20, std::vector&lt;int&gt; (n + 1)) &#123;
        std::vector&lt;int&gt; la(n + 2);
        std::copy(s.begin(), s.end(), rk.begin());
        int m = 128;
        &#123;
            std::vector&lt;int&gt; c(m + 1);
            for (int i = 1; i &lt;= n; ++i)
                ++c[rk[i]];
            std::partial_sum(c.begin(), c.end(), c.begin());
            for (int i = n; i; --i)
                sa[c[rk[i]]--] = i;
        &#125;
        for (int w = 1, p; ; w &lt;&lt;= 1, m = p) &#123;
            std::vector&lt;int&gt; id(1);
            for (int i = n - w + 1; i &lt;= n; ++i)
                id.push_back(i);
            for (int i = 1; i &lt;= n; ++i)
                if (sa[i] &gt; w)
                    id.push_back(sa[i] - w);
            std::vector&lt;int&gt; c(m + 1);
            for (int i = 1; i &lt;= n; ++i)
                ++c[rk[i]];
            std::partial_sum(c.begin(), c.end(), c.begin());
            for (int i = n; i; --i)
                sa[c[rk[id[i]]]--] = id[i];
            p = 0;
            std::copy(rk.begin(), rk.end(), la.begin());
            for (int i = 1; i &lt;= n; ++i)
                if (la[sa[i]] == la[sa[i - 1]] &amp;&amp; la[sa[i] + w] == la[sa[i - 1] + w])
                    rk[sa[i]] = p;
                else
                    rk[sa[i]] = ++p;
            if (p == n)
                break;
        &#125;
        for (int i = 1, to = 0; i &lt;= n; ++i)
            if (rk[i]) &#123;
                for (to = std::max(to - 1, 0); s[i + to] == s[sa[rk[i] - 1] + to]; ++to);
                h[rk[i]] = to;
            &#125;
        for (int i = 1; i &lt;= n; ++i)
            st[0][i] = h[i];
        for (int j = 1; (1 &lt;&lt; j) &lt;= n; ++j)
            for (int i = 1; i + (1 &lt;&lt; j) - 1 &lt;= n; ++i)
                st[j][i] = std::min(st[j - 1][i], st[j - 1][i + (1 &lt;&lt; (j - 1))]);
        rk.emplace_back();
        return;
    &#125;
private:
    int ask(int l, int r) &#123;
        // fprintf(stderr, &quot;l = %d, r = %d\n&quot;, l, r);
        int k = std::__lg(r - l + 1);
        return std::min(st[k][l], st[k][r - (1 &lt;&lt; k) + 1]);
    &#125;
public:
    int lcp(int l, int r) &#123;
        return ask(std::min(rk[l], rk[r]) + 1, std::max(rk[l], rk[r]));
    &#125;
&#125;;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int T;
    for (std::cin &gt;&gt; T; T--; ) &#123;
        std::string s;
        std::cin &gt;&gt; s;
        int n = (int)s.length();
        s = &quot;#&quot; + s;
        SA p(n, s);
        std::reverse(s.begin() + 1, s.end());
        SA q(n, s);
        std::vector&lt;int&gt; f(n + 2), g(n + 2);
        for (int len = 1; len &lt;= n / 2; ++len)
            for (int i = len; i + len &lt;= n; i += len) &#123;
                int l = i, r = i + len, lcp = std::min(len, p.lcp(l, r)), lcs = std::min(len - 1, q.lcp(n - l + 2, n - r + 2));
                if (lcp + lcs &gt;= len) &#123;
                    int t = lcp + lcs - len + 1;
                    // fprintf(stderr, &quot;(%d, %d), %d, %d\n&quot;, l, r, lcp, lcs);
                    ++g[l - lcs], --g[l - lcs + t], ++f[r + lcp - t], --f[r + lcp];
                &#125;
            &#125;
        std::partial_sum(f.begin(), f.end(), f.begin());
        std::partial_sum(g.begin(), g.end(), g.begin());
        long long res = 0ll;
        for (int i = 1; i &lt; n; ++i)
            res += (long long)f[i] * g[i + 1];
        std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
    &#125;
    return 0;
&#125;


eg2. tandem
https://www.codechef.com/problems/TANDEM
注意到多了一个限制，前一个好处理，找到经过 \(3\) 个标记的串即可。对于后一个限制，画图可以发现对于 interesting ones，每次只会出现最多一个；当且仅当 \(\text {lcp}&gt;len\) 时不存在。
对于 uninteresting ones，用每次能提供的总数减去 interesting ones 的数量即可。

#include &lt;bits/stdc++.h&gt;
class SA &#123;
public:
    std::vector&lt;int&gt; sa, rk, h;
    std::vector&lt;std::vector&lt;int&gt;  &gt; st;
    SA(int n, std::string s): sa(n + 1), rk(n + 2), h(n + 1), st(20, std::vector&lt;int&gt; (n + 1)) &#123;
        std::vector&lt;int&gt; la(n + 2);
        std::copy(s.begin(), s.end(), rk.begin());
        int m = 128;
        &#123;
            std::vector&lt;int&gt; c(m + 1);
            for (int i = 1; i &lt;= n; ++i)
                ++c[rk[i]];
            std::partial_sum(c.begin(), c.end(), c.begin());
            for (int i = n; i; --i)
                sa[c[rk[i]]--] = i;
        &#125;
        for (int w = 1, p; ; w &lt;&lt;= 1, m = p) &#123;
            std::vector&lt;int&gt; id(1);
            for (int i = n - w + 1; i &lt;= n; ++i)
                id.push_back(i);
            for (int i = 1; i &lt;= n; ++i)
                if (sa[i] &gt; w)
                    id.push_back(sa[i] - w);
            std::vector&lt;int&gt; c(m + 1);
            for (int i = 1; i &lt;= n; ++i)
                ++c[rk[i]];
            std::partial_sum(c.begin(), c.end(), c.begin());
            for (int i = n; i; --i)
                sa[c[rk[id[i]]]--] = id[i];
            p = 0;
            std::copy(rk.begin(), rk.end(), la.begin());
            for (int i = 1; i &lt;= n; ++i)
                if (la[sa[i]] == la[sa[i - 1]] &amp;&amp; la[sa[i] + w] == la[sa[i - 1] + w])
                    rk[sa[i]] = p;
                else
                    rk[sa[i]] = ++p;
            if (p == n)
                break;
        &#125;
        for (int i = 1, to = 0; i &lt;= n; ++i)
            if (rk[i]) &#123;
                for (to = std::max(to - 1, 0); s[i + to] == s[sa[rk[i] - 1] + to]; ++to);
                h[rk[i]] = to;
            &#125;
        for (int i = 1; i &lt;= n; ++i)
            st[0][i] = h[i];
        for (int j = 1; (1 &lt;&lt; j) &lt;= n; ++j)
            for (int i = 1; i + (1 &lt;&lt; j) - 1 &lt;= n; ++i)
                st[j][i] = std::min(st[j - 1][i], st[j - 1][i + (1 &lt;&lt; (j - 1))]);
        rk.emplace_back();
        return;
    &#125;
private:
    int ask(int l, int r) &#123;
        // fprintf(stderr, &quot;l = %d, r = %d\n&quot;, l, r);
        int k = std::__lg(r - l + 1);
        return std::min(st[k][l], st[k][r - (1 &lt;&lt; k) + 1]);
    &#125;
public:
    int lcp(int l, int r) &#123;
        return ask(std::min(rk[l], rk[r]) + 1, std::max(rk[l], rk[r]));
    &#125;
&#125;;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    std::string s;
    std::cin &gt;&gt; s;
    int n = (int)s.length();
    s = &quot;#&quot; + s;
    SA p(n, s);
    std::reverse(s.begin() + 1, s.end());
    SA q(n, s);
    std::reverse(s.begin() + 1, s.end());
    long long res1 = 0ll, res2 = 0ll;
    for (int len = 1; len &lt;= n; ++len)
        for (int i = len, j = 2 * len, k = 3 * len; k &lt;= n; i += len, j += len, k += len) &#123;
            int lcp = std::min(p.lcp(i, j), p.lcp(j, k)), lcs = std::min(&#123; len - 1, q.lcp(n - i + 2, n - j + 2), q.lcp(n - j + 2, n - k + 2) &#125;);
            if (std::min(len, lcp) + lcs &gt;= len) &#123;
                // printf(&quot;(%d, %d, %d), %d, %d, %d\n&quot;, i, j, k, lcs, lcp, len);
                int t = (lcp &lt;= len);
                res1 += t, res2 += std::min(len, lcp) + lcs - len + 1 - t;
            &#125;
            // else
            //     printf(&quot;# (%d, %d, %d), %d, %d, %d\n&quot;, i, j, k, lcs, lcp, len);
        &#125;
    std::cout &lt;&lt; res1 &lt;&lt; &#39; &#39; &lt;&lt; res2 &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;


eg3. repeats
https://www.spoj.com/problems/REPEATS/
重复次数最多，只需经过标记点最多。显然经过标记点的数量就是该字符串长除以 \(len\) 向下取整就可以得到重复次数减 \(1\) 的值。
选择两个连续标记点，对于 lcp 和 lcs（显然此时不需要对 \(len\) 取 \(\min\)），计算 \(\dfrac {\text{lcp}+\text{lcs}}{len}+1\) 取最大即可。

#include &lt;bits/stdc++.h&gt;
class SA &#123;
public:
    std::vector&lt;int&gt; sa, rk, h;
    std::vector&lt;std::vector&lt;int&gt;  &gt; st;
    SA(int n, std::string s): sa(n + 1), rk(n + 2), h(n + 1), st(20, std::vector&lt;int&gt; (n + 1)) &#123;
        std::vector&lt;int&gt; la(n + 2);
        std::copy(s.begin(), s.end(), rk.begin());
        int m = 128;
        &#123;
            std::vector&lt;int&gt; c(m + 1);
            for (int i = 1; i &lt;= n; ++i)
                ++c[rk[i]];
            std::partial_sum(c.begin(), c.end(), c.begin());
            for (int i = n; i; --i)
                sa[c[rk[i]]--] = i;
        &#125;
        for (int w = 1, p; ; w &lt;&lt;= 1, m = p) &#123;
            std::vector&lt;int&gt; id(1);
            for (int i = n - w + 1; i &lt;= n; ++i)
                id.push_back(i);
            for (int i = 1; i &lt;= n; ++i)
                if (sa[i] &gt; w)
                    id.push_back(sa[i] - w);
            std::vector&lt;int&gt; c(m + 1);
            for (int i = 1; i &lt;= n; ++i)
                ++c[rk[i]];
            std::partial_sum(c.begin(), c.end(), c.begin());
            for (int i = n; i; --i)
                sa[c[rk[id[i]]]--] = id[i];
            p = 0;
            std::copy(rk.begin(), rk.end(), la.begin());
            for (int i = 1; i &lt;= n; ++i)
                if (la[sa[i]] == la[sa[i - 1]] &amp;&amp; la[sa[i] + w] == la[sa[i - 1] + w])
                    rk[sa[i]] = p;
                else
                    rk[sa[i]] = ++p;
            if (p == n)
                break;
        &#125;
        for (int i = 1, to = 0; i &lt;= n; ++i)
            if (rk[i]) &#123;
                for (to = std::max(to - 1, 0); s[i + to] == s[sa[rk[i] - 1] + to]; ++to);
                h[rk[i]] = to;
            &#125;
        for (int i = 1; i &lt;= n; ++i)
            st[0][i] = h[i];
        for (int j = 1; (1 &lt;&lt; j) &lt;= n; ++j)
            for (int i = 1; i + (1 &lt;&lt; j) - 1 &lt;= n; ++i)
                st[j][i] = std::min(st[j - 1][i], st[j - 1][i + (1 &lt;&lt; (j - 1))]);
        rk.emplace_back();
        return;
    &#125;
private:
    int ask(int l, int r) &#123;
        // fprintf(stderr, &quot;l = %d, r = %d\n&quot;, l, r);
        int k = std::__lg(r - l + 1);
        return std::min(st[k][l], st[k][r - (1 &lt;&lt; k) + 1]);
    &#125;
public:
    int lcp(int l, int r) &#123;
        return ask(std::min(rk[l], rk[r]) + 1, std::max(rk[l], rk[r]));
    &#125;
&#125;;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int T;
    for (std::cin &gt;&gt; T; T--; ) &#123;
        int n;
        std::cin &gt;&gt; n;
        std::string s = &quot;#&quot;;
        for (int i = 1; i &lt;= n; ++i) &#123;
            char t;
            std::cin &gt;&gt; t;
            s.push_back(t);
        &#125;
        SA p(n, s);
        std::reverse(s.begin() + 1, s.end());
        SA q(n, s);
        int res = 0;
        for (int len = 1; len &lt;= n; ++len)
            for (int i = len, j = 2 * len; j &lt;= n; i += len, j += len) &#123;
                int lcp = p.lcp(i, j), lcs = q.lcp(n - i + 2, n - j + 2);
                if (lcp + lcs &gt;= len)
                    res = std::max(res, (lcp + lcs) / len + 1);
            &#125;
        std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
    &#125;
    return 0;
&#125;


结合并查集

结合单调栈
]]></content>
      <tags>
        <tag>字符串</tag>
        <tag>SA</tag>
      </tags>
  </entry>
  <entry>
    <title>杂题选谈：Public Round 15</title>
    <url>/20250216/</url>
    <content><![CDATA[PR #15 前两题题解。


最小表示法
https://pjudge.ac/contest/1914/problem/21888
首先不妨假设每个 \(f\) 在值域内等概率取值以简化问题。那么手玩一下可以轻松地得到规律：不妨将 \(\{s\}\) 循环右移一位的结果记为 \(\{t\}\)，那么 \(res=\sum\frac 1{\max(|s_i|,|t_i|)}\)。
这看起来令人疑惑：对于不同的 \(i\)，\([f(s_i)=f(t_i)]\) 的期望似乎是彼此独立的，十分奇怪。这其实与表达式的来源有关，记 \(g(s_i, j)\) 表示 \(f(s_i)=j\) 的概率，那么上述等式可以转写为 \(res=\sum\limits_i\sum\limits_jg({s_i},j)\times g(t_i,j)\)。
那么将最小表示法带来的偏差纳入考虑范围，我们发现 \(g(s,j)\) 对于不同的 \(j\) 并不永远相等。具体地，当 \(s\) 具有循环节时，最小循环节的第一处结尾会享有更大的取得概率。
枚举 \(s_i\) 的因数作为最小循环节长度的情况，显然，对于最小循环节为 \(j\) 的情况（该情况出现的概率，容斥得到 \(p_j=26^j-\sum_{k\mid j}p_k\)），\(f(s_i)\) 的取值在 \(1\sim j\) 上等概率分布，差分即可统计每个值在不同循环节长度下被取到的概率和。
用埃筛解决每个数的因数和 \(p\) 值，那么此时复杂度瓶颈在于 \(g(s_i, j)\) 和 \(\sum\limits_i\sum\limits_jg({s_i},j)\times g(t_i,j)\) 的求解。容易发现只有每个 \(g(s_i,j),j\mid |s_i|\) 的值是有效的（其他的和它们值都相同），考虑只求解和利用这些值，类 std::merge（即归并排序）地求解答案。
注意特判 \(n=1\)。会得到错误答案的原因是此时存在 \(s_i=t_i\)，不满足基本要求。

#include &lt;bits/stdc++.h&gt;
const int lim = 1e5;
const int mod = 998244353;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n;
    std::cin &gt;&gt; n;
    if (n == 1) &#123;
        std::cout &lt;&lt; 1 &lt;&lt; &#39;\n&#39;;
        return 0;
    &#125;
    auto qkp = [](long long x, int y) &#123;
        long long res = 1ll;
        for (; y; y &gt;&gt;= 1, (x *= x) %= mod)
            if (y &amp; 1)
                (res *= x) %= mod;
        return res;
    &#125;;
    auto inv = [&amp;](int x) &#123;
        return qkp(x, mod - 2);
    &#125;;
    std::vector&lt;long long&gt; f(lim + 1);
    std::vector&lt;std::vector&lt;int&gt; &gt; fac(lim + 1);
    for (int i = 1; i &lt;= lim; ++i) &#123;
        static long long now = 26;
        (f[i] += now) %= mod;
        fac[i].push_back(i);
        for (int j = 2 * i; j &lt;= lim; j += i)
            (f[j] += mod - f[i]) %= mod, fac[j].push_back(i);
        (now *= 26) %= mod;
    &#125;
    for (int i = 1; i &lt;= lim; ++i)
        (f[i] *= inv(i)) %= mod;
    std::vector&lt;int&gt; a(n + 1);
    struct _ &#123; int l, r; long long f; &#125;;
    std::vector&lt;std::vector&lt;_&gt; &gt; g(lim + 1);
    for (int i = 1; i &lt;= n; ++i) &#123;
        std::cin &gt;&gt; a[i];
        if (g[a[i]].empty()) &#123;
            g[a[i]].resize(fac[a[i]].size());
            for (int j = 0; j &lt; (int)fac[a[i]].size(); ++j) &#123;
                g[a[i]][j].l = (j ? g[a[i]][j - 1].r + 1 : 1);
                g[a[i]][j].r = fac[a[i]][j];
                (g[a[i]][0].f += f[fac[a[i]][j]]) %= mod;
                if (j != (int)fac[a[i]].size() - 1)
                    (g[a[i]][j + 1].f += mod - f[fac[a[i]][j]]) %= mod;
            &#125;
            for (int j = 1; j &lt; (int)fac[a[i]].size(); ++j)
                (g[a[i]][j].f += g[a[i]][j - 1].f) %= mod;
            int getinv = inv(qkp(26, a[i]));
            for (int j = 0; j &lt; (int)fac[a[i]].size(); ++j)
                (g[a[i]][j].f *= getinv) %= mod;
        &#125;
    &#125;
    std::vector&lt;int&gt; b(n + 1);
    std::rotate_copy(a.begin() + 1, --a.end(), a.end(), b.begin() + 1);
    long long res = 0ll;
    for (int i = 1; i &lt;= n; ++i) &#123;
        for (int j = 0, k = 0, now = 0;
            j &lt; (int)fac[a[i]].size() &amp;&amp; k &lt; (int)fac[b[i]].size(); )
            if (g[a[i]][j].r &lt; g[b[i]][k].r) &#123;
                (res += g[a[i]][j].f * g[b[i]][k].f % mod
                    * (g[a[i]][j].r - now) % mod) %= mod;
                now = g[a[i]][j].r, ++j;
            &#125;
            else if (g[a[i]][j].r == g[b[i]][k].r) &#123;
                (res += g[a[i]][j].f * g[b[i]][k].f % mod
                    * (g[a[i]][j].r - now) % mod) %= mod;
                now = g[a[i]][j].r, ++j, ++k;
            &#125;
            else &#123;
                (res += g[a[i]][j].f * g[b[i]][k].f % mod
                    * (g[b[i]][k].r - now) % mod) %= mod;
                now = g[b[i]][k].r, ++k;
            &#125;
    &#125;
    std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;


二叉搜索树
https://pjudge.ac/contest/1914/problem/21889
当我们处理链的部分分时，很容易想到用差分解决问题。把更新 \([l, r]\) 看作在差分数组 \(l\) 处插入，在 \(r+1\) 处删除，离线下来再从左到右扫一遍操作，考虑如何解决查询问题。
考虑如何获取 \(i\) 树上 \(t_0\) 时刻点 \(x\) 的所有祖先。根据前面的操作，我们可以获取 \(i\) 树上存在过的所有元素。
对于比 \(x\) 大的元素，考虑祖先 \(p_a\) 和非祖先 \(p\) 有什么区别。根据 BST 的性质易得，对于最低的右侧祖先 \({p_a}_0\)，其是 \(\ge x\) 的最小的元素（当然其加入时刻 \(t_a&lt;t_0\)）；那么同理可以找到 \({p_a}_0\) 右侧最低的祖先（其左侧的祖先显然也 \(x\) 左侧），该祖先满足 \(t&lt;t_a\)。那么我们就从左右两边分别得到 \(x\) 的所有祖先。容易证明该过程对于不在树上的 \(x\) 也是正确的。
具体地，我们需要一个数据结构，能够求出 \(\ge x\) 的元素中，以 \(t_0\) 为起点的前缀最小值序列的区间和。
欸 ☝🤓 这是什么？楼房重建！秒一下！
进一步地，本题需要完成对于 \(t_0\) 为序列头的查询。再次利用性质，每次 \(O(\log V)\) 地合并答案。
好的那么怎么把链搞到树上呢？把差分放到树上，写个线段树合并即可。
注意由于这题细节太多了，所以你可能需要舍弃不必要的时空优化换取代码简洁度以方便调试。

#include &lt;bits/stdc++.h&gt;
const int lim = 2e5;
const int maxn = 2e7 + 5;
const int inf = 0x3f3f3f3f;
struct &#123;
    int l, r, rv;
    long long u;
&#125; t[maxn];
std::vector&lt;int> tr;
#define lt t[p].l
#define rt t[p].r
int newnode(void) &#123;         // 我知道你要说什么，但这属于「必要的」空间优化 😥
    static int tot = 0;
    if (tr.empty())
        return ++tot;
    auto p(tr.back());
    t[p].l = t[p].r = 0;
    tr.pop_back();
    return p;
&#125;
long long askv(int p, int l, int r, int v) &#123;
    if (l == r)
        return t[p].rv < v ? t[p].u : 0;
    int mid = (l + r) >> 1;
    if (v > t[lt].rv)
        return t[p].u - t[lt].u + askv(lt, l, mid, v);
    return askv(rt, mid + 1, r, v);
&#125;
void pushup(int p, int l, int r) &#123;
    t[p].rv = std::min(t[lt].rv, t[rt].rv);
    int mid = (l + r) >> 1;
    t[p].u = t[lt].u + askv(rt, mid + 1, r, t[lt].rv);
    return;
&#125;
void upd(int &p, int l, int r, int x, int v, int u) &#123;
    if (!p)
        p = newnode();
    if (l == r) &#123;
        t[p].rv = v, t[p].u = u;
        return;
    &#125;
    int mid = (l + r) >> 1;
    if (x > 1;
    merge(t[p].l, t[q].l, l, mid), merge(t[p].r, t[q].r, mid + 1, r);
    pushup(p, l, r), tr.push_back(q);
    return;
&#125;
int qv = inf;
long long ask(int p, int l, int r, int ql, int qr) &#123;
    if (ql  1;
    long long res = 0ll;
    if (ql  mid)
        res += ask(rt, mid + 1, r, ql, qr);
    return res;
&#125;
#undef lt
#undef rt
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen("ex_problem4.in", "r", stdin);
    std::freopen(".out", "w", stdout);
#endif
    int n, m;
    std::cin >> n >> m;
    std::vector&lt;std::vector&lt;int> > g(n + 1);
    for (int i = 1, x, y; i < n; ++i) &#123;
        std::cin >> x >> y;
        g[x].push_back(y), g[y].push_back(x);
    &#125;
    std::vector&lt;int> top(n + 1), fa(n + 1), siz(n + 1), son(n + 1), dep(n + 1);
    std::function&lt;void(int, int)> DFS = [&](int x, int faa) &#123;
        siz[x] = 1;
        for (auto i : g[x])
            if (i != faa) &#123;
                fa[i] = x, dep[i] = dep[x] + 1;
                DFS(i, x), siz[x] += siz[i];
                if (siz[i] > siz[son[x]])
                    son[x] = i;
            &#125;
        return;
    &#125;;
    DFS(1, -1);
    DFS = [&](int x, int topp) &#123;
        top[x] = topp;
        if (son[x])
            DFS(son[x], topp);
        for (auto i : g[x])
            if (i != fa[x] && i != son[x])
                DFS(i, i);
        return;
    &#125;;
    DFS(1, 1);
    auto getLCA = [&](int x, int y) &#123;
        for (; top[x] != top[y]; x = fa[top[x]])
            if (dep[top[y]] > dep[top[x]])
                std::swap(x, y);
        return (dep[x] < dep[y] ? x : y);
    &#125;;
    std::vector&lt;std::vector&lt;int> > d(n + 1);
    std::vector&lt;std::vector&lt;std::pair&lt;int, int> > > u(n + 1);
    std::vector&lt;std::vector&lt;std::tuple&lt;int, int, int> > > q(n + 1);
    int cnt = 0;
    for (int i = 1; i > op;
        if (op == 0) &#123;
            int x, v;
            std::cin >> x >> v;
            q[x].emplace_back(++cnt, i, v);
        &#125; else &#123;
            int x, y, v;
            std::cin >> x >> y >> v;
            int faa = getLCA(x, y);
            u[x].emplace_back(i, v), u[y].emplace_back(i, v);
            if (fa[faa])
                d[fa[faa]].emplace_back(v);
        &#125;
    &#125;
    std::vector&lt;long long> res(cnt + 1);
    std::vector&lt;std::vector&lt;int> > rt(2, std::vector&lt;int> (n + 1));
    t[0].rv = inf;
    DFS = [&](int x, int fa) &#123;
        for (auto i : g[x])
            if (i != fa) &#123;
                DFS(i, x);
                merge(rt[0][x], rt[0][i], 1, lim);
                merge(rt[1][x], rt[1][i], 1, lim);
            &#125;
        for (auto [t, v] : u[x]) &#123;
            upd(rt[0][x], 1, lim, v, t, v);
            upd(rt[1][x], 1, lim, lim - v + 1, t, v);
        &#125;
        for (auto v : d[x]) &#123;
            upd(rt[0][x], 1, lim, v, inf, 0);
            upd(rt[1][x], 1, lim, lim - v + 1, inf, 0);
        &#125;
        for (auto [id, t, v] : q[x]) &#123;
            qv = t, res[id] = ask(rt[0][x], 1, lim, v, lim);
            qv = t, res[id] += ask(rt[1][x], 1, lim, lim - v + 1, lim);
            qv = t, res[id] -= ask(rt[0][x], 1, lim, v, v);
        &#125;
    &#125;;
    DFS(1, -1);
    for (int i = 1; i ]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>数学</tag>
        <tag>树上差分</tag>
      </tags>
  </entry>
  <entry>
    <title>学习笔记：单侧递归线段树</title>
    <url>/20250217/</url>
    <content><![CDATA[人类不应该使用 std::vector 实现线段树的 2 个原因：


当你的参数包含引用时，扩容操作，包括显式的 resize() 和隐式的 push_back() 均会导致引用失效。
当你的左值为引用时，由于 = 左右计算顺序是不确定的（C++14），由于 1 中所述原因，引用可能失效。
terminate called after throwing an instance of 'std::bad_alloc' what():  std::bad_alloc

笑点解析：首先通过「……的 2 个原因」暗示声明一个长度为 2 的 vector，接着在试图访问第 3 个元素时抛出错误。
什么？你说我的下标是从 1 开始的？恭喜你发现了 vector 的第 0 个笑点。

楼房重建
https://www.luogu.com.cn/problem/P4198
考虑用线段树解决问题。难点在于如何合并两个区间的信息——直觉地，大区间的信息一定与两个子区间有关。
考虑理想的情况：我们现在知道左右两边区间的答案序列。显然我们需要保留左边整段区间，对于左区间序列末的元素 \(rv_l\)，我们在右区间内找到第一个大于之的元素 \(x\)，从它开始的序列就是答案。
反证法易得 \(x\) 一定在右区间答案序列内：若 \(x\) 不在答案序列内，则右区间内存在一个 \(&gt;x\) 且位于 \(x\) 之前的元素，那么 \(x\) 就不是第一个 \(&gt;rv_l\) 的元素，矛盾。
那么现在对于左右序列未知的情况，我们取左区间的答案，再在右区间中单 \(\log\) 查找能够接上去的区间长度，加起来即可。
题目只要求总区间答案，故不需要查询。动态开点可能需要小心处理一下。

#include &lt;bits/stdc++.h&gt;
const int maxn = 1e5 + 5;
struct &#123;
    int l, r, u;
    double lv, rv, mv;
&#125; t[maxn &lt;&lt; 2];
int tot;
#define lt t[p].l
#define rt t[p].r
int askt(int p, int l, int r, double v) &#123;
    if (l == r)
        return t[p].u;
    int mid = (l + r) &gt;&gt; 1;
    if (lt &amp;&amp; t[p].mv &gt; v)
        return t[p].u - t[lt].u + askt(lt, l, mid, v);
    return askt(rt, mid + 1, r, v);
&#125;
void pushup(int p, int l, int r) &#123;
    t[p].mv = t[lt].rv;
    if (lt &amp;&amp; rt) &#123;
        t[p].lv = t[lt].lv;
        t[p].rv = std::max(t[lt].rv, t[rt].rv);
        if (t[lt].rv &lt; t[rt].lv)
            t[p].u = t[lt].u + t[rt].u;
        else if (t[lt].rv &gt;= t[rt].rv)
            t[p].u = t[lt].u;
        else &#123;
            int mid = (l + r) &gt;&gt; 1;
            t[p].u = t[lt].u + askt(rt, mid + 1, r, t[lt].rv);
        &#125;
    &#125;
    else &#123;
        t[p].u = t[lt + rt].u;
        t[p].lv = t[lt + rt].lv, t[p].rv = t[lt + rt].rv;
    &#125;
    return;
&#125;
void upd(int &amp;p, int l, int r, int x, double v) &#123;
    if (!p)
        p = ++tot;
    if (l == r) &#123;
        t[p].lv = t[p].rv = v, t[p].u = 1;
        return;
    &#125;
    int mid = (l + r) &gt;&gt; 1;
    if (x &lt;= mid)
        upd(lt, l, mid, x, v);
    else
        upd(rt, mid + 1, r, x, v);
    pushup(p, l, r);
    return;
&#125;
#undef lt
#undef rt
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;P4198_2.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n, m, rt = 0;
    std::cin &gt;&gt; n &gt;&gt; m;
    std::vector&lt;double&gt; a(n + 1);
    for (int x; m--; ) &#123;
        double y;
        std::cin &gt;&gt; x &gt;&gt; y;
        a[x] = y / x;
        upd(rt, 1, n, x, y / x);
        std::cout &lt;&lt; t[1].u &lt;&lt; &#39;\n&#39;;
    &#125;
    return 0;
&#125;

]]></content>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>杂题选谈</title>
    <url>/20250219/</url>
    <content><![CDATA[不在沉默中躺平，就在喧嚣中躺平。

但谁说人一定要躺平？我要 work work work work work work work work 勤劳又勇敢的 XSC062 为了 OI 的关键杂题集 她作出了巨大的贡献 巨大的牺牲 巨大的 carry 无敌了 无敌了 

[USACO23JAN] Moo Route G
https://www.luogu.com.cn/problem/P9018
关键词：由小推大 思维
希望大家不要和我一样忽略了重要条件：终点也是 \(0\)。这意味着每个点都会被左右成对地经过，那么不妨令 \(A_i\gets \frac 2{A_i}\)。
观察到给了 \(N=2\) 的一档分，考虑该情况。

若 \(A_1&gt; A_2\)：

此时最优策略为……
|---------&gt;
&lt;---------|
|---------&gt;
&lt;---------|
|---------&gt;
&lt;---------|
|----&gt;
&lt;----|
|----&gt;
&lt;----|
===========
0    1    2

只要不拆开一组，箭头排列顺序任意。显然方案数为 \({A_1}\choose {A_2}\)。
Otherwise：

此时最优策略为……
|----------&gt;
      &lt;----|
      |----&gt;
      &lt;----|
      |----&gt;
 &lt;---------|
 |---------&gt;
 &lt;---------|
 ===========
 0    1    2

相似地，只要不拆开一组，箭头排列顺序任意，可以注意到除了第一个，每个长 |---&gt; 的前面一定是一个长 &lt;---|，那么问题转化为选择 \(A_1-1\) 个短 &lt;---| 拉长，方案数为 \({A_2-1}\choose{A_1-1}\)。

进一步，考虑 \(N=3\) 的情况。若已知子问题 \(0\to1\to2\) 的方案和子问题 \(1\to2\to3\) 的方案，可以直接乘起来合并。为什么呢？
二者经过 \(2\) 的次数相等；在子问题 \(0\to1\to2\) 中，\(1\to2\) 的下一步一定是 \(2\to 1\)；我们把该过程替换为子问题 \(1\to 2\to 3\) 中对应的一段 \(1\to2\to\cdots\to2\to1\) 的路径即可。
那么两两合并起来，可以得到最终答案为 \(\prod\limits_{i=1}^{n-1}\begin{cases}{\binom{A_i}{A_{i+1}}}&amp;A_i&gt;A_{i+1}\\{\binom{A_{i+1}-1}{A_i-1}}&amp;\text{otherwise}\end{cases}\)。

#include &lt;bits/stdc++.h&gt;
const int lim = 5e5;
const int mod = 1e9 + 7;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n;
    std::cin &gt;&gt; n;
    std::vector&lt;int&gt; a(n + 1);
    for (int i = 1; i &lt;= n; ++i)
        std::cin &gt;&gt; a[i], a[i] /= 2;
    std::vector&lt;long long&gt; inv(lim + 1), fac(lim + 1);
    auto qkp = [&amp;](long long x, int y) &#123;
        long long res = 1ll;
        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)
            if (y &amp; 1)
                (res *= x) %= mod;
        return res;
    &#125;;
    inv[0] = fac[0] = 1ll;
    for (int i = 1; i &lt;= lim; ++i)
        fac[i] = fac[i - 1] * i % mod;
    inv[lim] = qkp(fac[lim], mod - 2);
    for (int i = lim - 1; i; --i)
        inv[i] = inv[i + 1] * (i + 1) % mod;
    auto C = [&amp;](int n, int m) &#123;
        return fac[n] * inv[n - m] % mod * inv[m] % mod;
    &#125;;
    long long res = 1ll;
    for (int i = 1; i &lt; n; ++i)
        if (a[i] &gt; a[i + 1])
            (res *= C(a[i], a[i + 1])) %= mod;
        else
            (res *= C(a[i + 1] - 1, a[i] - 1)) %= mod;
    std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;


[GDKOI2024 普及组] 正方形扩展
https://www.luogu.com.cn/problem/P10078
关键词：分类讨论 扫描线
理论上看懂了就是弱智题，可惜看不懂。
就是说，一个点如果被染了某种颜色，并且以它为中心的边长为 \(2\) 的正方形中没有其他颜色的点，就把这个正方形里的点都染成这个颜色，问每个颜色面积是否能达到无穷大。
考虑无法达到无穷大的原因，一定是因为向四个方向都无法延伸到无穷远。以右边为例，考虑点 \(i\) 什么时候不能在 \(x\) 轴正方向上延伸到无穷远：

对于 \(\forall \, j,x_j\le x_i\)，\(j\) 不会对 \(i\) 向右的延伸带来任何影响——所有点的延伸速度相同。
对于 \(x_j&gt;x_i\) 且 \(y_j=y_i\)，\(j\) 可以堵住 \(i\)。
这时候不免产生疑问：\(i\) 不能从上下「翻越」过 \(j\) 的统治吗？
显而易见地，由于延伸速度相同，\(i\) 在某时刻能够在 \(y\) 轴上到达的高度，\(j\) 也能达到，所以 \(j\) 能够把 \(i\) 堵死，参见题面中给出的例子。
对于 \(x_j&gt;x_i\) 且 \(y_j \ne y_i\)，由上所述，\(j\) 在 \(y\) 轴下 / 上方向无法追上 \(i\)，\(i\) 可以从该方向越过 \(j\)，在 \(x\) 轴正方向上延伸到无穷远；但 \(j\) 在自己所在的一侧（上 / 下）可以堵住 \(i\)。
对于 \(x_j,x_k&gt;x_i\) 且 \((y_j-y_i)(y_k-y_i)&lt;0\)（即二者分居 \(i\) 点上下），\(j\) 和 \(k\) 可以在两个方向分别拦截住 \(i\)。
此时可能有疑问：\(i\) 可不可以先越过 \(j\) ，再越过 \(k\) 呢？答案是否定的。由上，\(j\) 和 \(k\) 会分别在 \(y\) 轴自身对应方向上堵住 \(i\)，在越过其中之一后无法从这一侧越过另一个点，所以 \(i\) 会被两个点合作堵死。

由此我们总结出，\(i\) 能在 \(x\) 轴正方向被拦截，当且仅当：

存在 \(x_j&gt;x_i\) 且 \(y_j=y_i\)；
抑或，存在 \(x_j,x_k&gt;x_i\) 且 \(y_j&lt;y_i,y_k&gt;y_i\)。

那么可以从四个方向分别用扫描线求解。鉴于和实际坐标数值没有什么直接关系，可以离散化后树状数组以避免被卡常。

金鱼草
link
]]></content>
  </entry>
  <entry>
    <title>中等题目 Practice</title>
    <url>/20250222/</url>
    <content><![CDATA[
]]></content>
  </entry>
  <entry>
    <title>学习笔记：FWT</title>
    <url>/20250329/</url>
    <content><![CDATA[活了哥们，复活了。


考虑以下问题：

对于 \(\forall \,i\in U\)，求 \(c_i=\sum\limits_{j\cup k=i}a_j\cdot b_k\)。

当然这里可以把集合看成二进制状态，那么取并集就是按位或了。
咕咕咕

Emiya 家明天的饭
https://www.luogu.com.cn/problem/P10242
冷知识：Emiya 家明天的饭 和 Emiya 家今天的饭 拥有相同的难度评级 
考虑暴力的做法，如果我们先钦定必须到达的人（这是 \(O(2^n)\) 的），再花费 \(O(nm)\) 的时间依次判定每道菜是否可以被选择，就可以 解决问题。但发现时间是不能承受的，这里我们选择优化 \(O(nm)\) 的判定。
现在已知人员集合 \(s\)，对于一道菜 \(i\)，设它适配的人员集合为 \(T_i\)，那么有 \(s\subseteq T_i\)。所求即为 \(\max\limits_s\{\sum\limits_{T_i\supseteq s}\sum\limits_{j\in s}a_{i,j}\}\)。\(O(nm)\) 预处理出 \(f_j(u)=\sum\limits_{T_i=u}a_{j, i}\)，那么待求即为 \(\max\limits_{s}\{\sum\limits_{j\in s}\sum\limits_{u\supseteq s}f_j(u)\}\)，发现这个东西可以用 FWT 求。

#include &lt;bits/stdc++.h&gt;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n, m, k;
    std::cin &gt;&gt; k &gt;&gt; m, n = 1 &lt;&lt; k;
    using arr = std::vector&lt;long long&gt;;
    std::vector&lt;int&gt; t(m + 1);
    std::vector&lt;arr&gt; a(k + 1, arr(m + 1)), f(k + 1, arr(n));
    for (int i = 1; i &lt;= k; ++i)
        for (int j = 1; j &lt;= m; ++j) &#123;
            std::cin &gt;&gt; a[i][j];
            if (a[i][j] &gt;= 0)
                t[j] |= 1 &lt;&lt; (i - 1);
        &#125;
    for (int i = 1; i &lt;= k; ++i)
        for (int j = 1; j &lt;= m; ++j)
            if (a[i][j] &gt;= 0)
                f[i][t[j]] += a[i][j];
    &#123;
        std::vector&lt;arr&gt; mT(2, arr(2));
        mT[0][0] = 1ll, mT[0][1] = 1ll, mT[1][0] = 0ll, mT[1][1] = 1ll;
        auto calc = [&amp;](arr a, arr &amp;f, std::vector&lt;arr&gt; &amp;w) &#123;
            f = a;
            for (int len = 2; len &lt;= n; len &lt;&lt;= 1) &#123;
                for (int i = 0; i &lt; n; i += len)
                    for (int p = i, q = i + len / 2; q &lt; i + len; ++p, ++q)
                        std::tie(f[p], f[q]) = std::make_tuple(f[p] * w[0][0] + f[q] * w[0][1], f[p] * w[1][0] + f[q] * w[1][1]);
            &#125;
            return;
        &#125;;
        for (int i = 1; i &lt;= k; ++i)
            calc(f[i], f[i], mT);
    &#125;
    long long res = 0ll;
    for (int s = 0; s &lt; n; ++s) &#123;
        long long sum = 0ll;
        for (int i = 1; i &lt;= k; ++i)
            if ((s &gt;&gt; (i - 1)) &amp; 1)
                sum += f[i][s];
        res = std::max(res, sum);
    &#125;
    std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;


Nim Counting
https://atcoder.jp/contests/abc212/tasks/abc212_h
即，从 \(A_N\) 中有放回地选择 \(\le M\) 个数，问它们异或起来不为 \(0\) 的方案数。
如果令 \(f_{i, j}\) 表示选了 \(i\) 次，异或和为 \(j\) 的方案数，显然 \(f_{1,i}=\sum [a_j=i]\) 为关于 \(a\) 的桶。此时有 \(f_{i,j}=\sum\limits_{k=1}^n f_{i-1,j\oplus a_k}=\sum\limits_{k=0}^V f_{i-1,j\oplus k}\cdot f_{1,k}\)，发现把 \(f_1\) 这个桶在 \(f\) 上做 \(N\) 次 xor-FWT 就可以得到 \(f_n\)。
但如果直接卷 \(N\) 次是 \(O(N\cdot V\log V)\) 的，不太美好，但我们看看我们实际上需要做什么：

求 \(f_i\) 的 FWT。
求初始桶 \(f_1\) 的 FWT。
对位相乘得到 \(f_{i+1}\) 的 FWT。
通过 FWT 求得原本的 \(f_{i+1}\)。

当这个操作被放在 \(i=1\sim n\) 上依次进行时，我们发现第一步和最后一步会相互抵消，我们只需要求出 \(f_1\) 的 FWT，\(FWT_{i, j}(f)\) 即为 \(FWT_{1, j}(f)^i\)。因为我们要求的是 \(\sum\limits_{i, j}f_{i,j}\) 可以通过等比数列求和求出 \(FWT_j(s)=\sum f_{i, j}\)。由前文推导可知直接做一次逆变换求得 \(s_j\) 即可。

#include &lt;bits/stdc++.h&gt;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    struct mint &#123;
        const int mod = 998244353;
        long long x;
        mint(): x(0ll) &#123;&#125;
        mint(long long x1): x((x1 + mod) % mod) &#123;&#125;
        mint&amp; operator= (const mint q) &#123;
            x = q.x;
            return *this;
        &#125;
        bool operator== (const mint q) const &#123;
            return x == q.x;
        &#125;
        mint operator* (const mint q) const &#123;
            return x * q.x % mod;
        &#125;
        mint&amp; operator*= (const mint q) &#123;
            return *this = *this * q;
        &#125;
        mint operator+ (const mint q) &#123;
            return (x + q.x) % mod;
        &#125;
        mint&amp; operator+= (const mint q) &#123;
            return *this = *this + q;
        &#125;
        mint operator- (const mint q) &#123;
            return (x + mod - q.x) % mod;
        &#125;
        mint qkp(int y) &#123;
            mint res(1ll), x(this-&gt;x);
            for (; y; y &gt;&gt;= 1, x *= x)
                if (y &amp; 1)
                    res *= x;
            return res;
        &#125;
        mint inv(void) &#123;
            return qkp(mod - 2);
        &#125;
    &#125;;
    int n, m, k = 16, l = 1 &lt;&lt; k;
    std::cin &gt;&gt; m &gt;&gt; n;
    using arr = std::vector&lt;mint&gt;;
    arr a(n + 1), c(l);
    for (int i = 1; i &lt;= n; ++i)
        std::cin &gt;&gt; a[i].x, c[a[i].x] += 1;
    std::vector&lt;arr&gt; mT(2, arr(2)), mI(2, arr(2));
    mT[0][0] = 1ll, mT[0][1] = 1ll, mT[1][0] = 1ll, mT[1][1] = -1ll;
    mI[0][0] = mI[0][1] = mI[1][0] = mint(2ll).inv(), mI[1][1] = mint(-2ll).inv();
    auto calc = [&amp;](arr a, arr &amp;f, std::vector&lt;arr&gt; &amp;w) &#123;
        f = a;
        for (int len = 2; len &lt;= l; len &lt;&lt;= 1)
            for (int i = 0; i &lt; l; i += len)
                for (int p = i, q = i + len / 2; q &lt; i + len; ++p, ++q)
                    std::tie(f[p], f[q]) = std::make_tuple(f[p] * w[0][0] + f[q] * w[0][1], f[p] * w[1][0] + f[q] * w[1][1]);
        return;
    &#125;;
    calc(c, c, mT);
    arr s(l);
    for (int i = 0; i &lt; l; ++i)
        if (c[i] == 1ll)
            s[i] = m;
        else
            s[i] = c[i] * (mint(1ll) - c[i].qkp(m)) * (mint(1ll) - c[i]).inv();
    calc(s, s, mI);
    mint res;
    for (int i = 1; i &lt; l; ++i)
        res += s[i];
    std::cout &lt;&lt; res.x &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;


Binary Table
https://codeforces.com/problemset/problem/662/C
发现这个题和 Emiya 家今天的饭 很像，都是有一个很小的维和一个相对比较大的维。
显然，我们所有的操作顺序都可以任意调换；朴素地，我们枚举 \(2^n\) 种给这 \(n\) 行反转的情况；再对于每一列，\(O(n)\) 选择应该反转还是不反转，这样总共是 \(O(2^n\cdot nm)\) 的。
发现把一列初始状态压成一个二进制数 \(a\)，假设我们现在枚举的行反转状态为 \(s\)，显然用 \(s\oplus a\) 可以得到当前状态。怎么利用这个去 FWT 呢？这引导我们依然枚举 \(s\)，用一个和 \(s\oplus a\) 有关的量跟一个和 \(a\) 有关的量相乘得到关于 \(s\) 的答案。
容易发现令 \(f_{s\oplus a}\) 表示 \(s\oplus a\) 这个状态反转和不反转两个选项中可以获取的最少 1 的个数；再令 \(c_s\) 表示状态为 \(s\) 的列的个数，那么 \(\sum\limits_s c_s\times f_{s\oplus a}\) 就可以得到枚举的反转方案为 \(s\) 的答案，求最小即可。

#include &lt;bits/stdc++.h&gt;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    struct mint &#123;
        const int mod = 998244353;
        long long x;
        mint(): x(0ll) &#123;&#125;
        mint(long long x1): x((x1 + mod) % mod) &#123;&#125;
        mint&amp; operator= (const mint q) &#123;
            x = q.x;
            return *this;
        &#125;
        bool operator== (const mint q) const &#123;
            return x == q.x;
        &#125;
        mint operator* (const mint q) const &#123;
            return x * q.x % mod;
        &#125;
        mint&amp; operator*= (const mint q) &#123;
            return *this = *this * q;
        &#125;
        mint operator+ (const mint q) &#123;
            return (x + q.x) % mod;
        &#125;
        mint&amp; operator+= (const mint q) &#123;
            return *this = *this + q;
        &#125;
        mint operator- (const mint q) &#123;
            return (x + mod - q.x) % mod;
        &#125;
        mint qkp(int y) &#123;
            mint res(1ll), x(this-&gt;x);
            for (; y; y &gt;&gt;= 1, x *= x)
                if (y &amp; 1)
                    res *= x;
            return res;
        &#125;
        mint inv(void) &#123;
            return qkp(mod - 2);
        &#125;
    &#125;;
    int n, m, l;
    std::cin &gt;&gt; n &gt;&gt; m, l = 1 &lt;&lt; n;
    using arr = std::vector&lt;mint&gt;;
    arr c(l), f(l);
    std::vector&lt;std::vector&lt;char&gt; &gt; a(n + 1, std::vector&lt;char&gt; (m + 1));
    for (int i = 1; i &lt;= n; ++i)
        for (int j = 1; j &lt;= m; ++j)
            std::cin &gt;&gt; a[i][j];
    for (int j = 1; j &lt;= m; ++j) &#123;
        int s = 0;
        for (int i = 1; i &lt;= n; ++i)
            s = (s &lt;&lt; 1) + a[i][j] - &#39;0&#39;;
        c[s] += 1;
    &#125;
    for (int i = 0, t; i &lt; l; ++i)
        t = (__builtin_popcount(i)), f[i] = std::min(t, n - t);
    std::vector&lt;arr&gt; mT(2, arr(2)), mI(2, arr(2));
    mT[0][0] = 1ll, mT[0][1] = 1ll, mT[1][0] = 1ll, mT[1][1] = -1ll;
    mI[0][0] = mI[0][1] = mI[1][0] = mint(2ll).inv(), mI[1][1] = mint(-2ll).inv();
    auto calc = [&amp;](arr a, arr &amp;f, std::vector&lt;arr&gt; &amp;w) &#123;
        f = a;
        for (int len = 2; len &lt;= l; len &lt;&lt;= 1)
            for (int i = 0; i &lt; l; i += len)
                for (int p = i, q = i + len / 2; q &lt; i + len; ++p, ++q)
                    std::tie(f[p], f[q]) = std::make_tuple(f[p] * w[0][0] + f[q] * w[0][1], f[p] * w[1][0] + f[q] * w[1][1]);
        return;
    &#125;;
    calc(c, c, mT), calc(f, f, mT);
    arr s(l);
    for (int i = 0; i &lt; l; ++i)
        s[i] = c[i] * f[i];
    calc(s, s, mI);
    int res = 0x3f3f3f3f;
    for (int i = 0; i &lt; l; ++i)
        res = std::min(res, (int)s[i].x);
    std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;


Hard Nim
https://hydro.ac/p/bzoj-P4589
Nim Counting 然后缝了个筛子。

#include &lt;bits/stdc++.h&gt;
const int mod = 1e9 + 7;
const int inv2 = 5e8 + 4;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    std::vector&lt;int&gt; p, tag(50001);
    for (int i = 2; i &lt;= 50000; ++i)
        if (!tag[i]) &#123;
            p.push_back(i);
            for (int j = 2 * i; j &lt;= 50000; j += i)
                tag[j] = 1;
        &#125;
    auto qkp = [&amp;](long long x, int y) &#123;
        long long res = 1ll;
        for (; y; y &gt;&gt;= 1, (x *= x) %= mod)
            if (y &amp; 1)
                (res *= x) %= mod;
        return res;
    &#125;;
    for (int n, m; std::cin &gt;&gt; n &gt;&gt; m; ) &#123;
        int k = std::__lg(m) + 1, l = 1 &lt;&lt; k;
        using arr = std::vector&lt;long long&gt;;
        arr c(l);
        for (auto i : p)
            if (i &lt;= m)
                c[i] += 1;
            else
                break;
        std::vector&lt;arr&gt; mT(2, arr(2)), mI(2, arr(2));
        mT[0][0] = 1ll, mT[0][1] = 1ll, mT[1][0] = 1ll, mT[1][1] = mod - 1ll;
        mI[0][0] = mI[0][1] = mI[1][0] = inv2, mI[1][1] = mod - inv2;
        auto calc = [&amp;](arr &amp;f, std::vector&lt;arr&gt; &amp;w) &#123;
            for (int len = 2; len &lt;= l; len &lt;&lt;= 1)
                for (int i = 0; i &lt; l; i += len)
                    for (int p = i, q = i + len / 2; q &lt; i + len; ++p, ++q)
                        std::tie(f[p], f[q]) = std::make_tuple((f[p] * w[0][0] + f[q] * w[0][1]) % mod, (f[p] * w[1][0] + f[q] * w[1][1]) % mod);
            return;
        &#125;;
        calc(c, mT);
        arr s(l);
        for (int i = 0; i &lt; l; ++i)
            s[i] = qkp(c[i], n);
        calc(s, mI);
        std::cout &lt;&lt; s[0] &lt;&lt; &#39;\n&#39;;
    &#125;
    return 0;
&#125;


子集卷积
https://www.luogu.com.cn/problem/P6097
这个是在许多 DP 中都可能见到过的结构，相信大家都深有体会。
等价于求 \(c_s=\sum\limits_{i\cap j=\varnothing\land i\cup j=s}a_i\cdot b_j\)，首先关注 \(i\cup j=s\)，可以用 FWT 解决；对于 \(i\cap j = \varnothing\) 呢？
有一个很聪明的办法，我们发现 \(i\cap j=\varnothing\land i\cup j = s\iff \operatorname{ctz}(i)+\operatorname{ctz}(j)=\operatorname{ctz}(s)\)，其中 \(\operatorname{ctz}(i)\) 表示 \(i\) 中 \(1\) 的个数，即 popcount(i)。
显然后者是个简单的加法运算，这里又有一个很聪明又很基本的办法，我们令 \(A_{\operatorname{ctz}(i),i}=a_i,B_{\operatorname{ctz}(j),j}=b_j\)，那么答案就转化为 \(\sum\limits_{i}\sum\limits_{j\cup k=s}A_{i,j}\cdot B_{\operatorname{ctz}(s)-i,j}\)，就可以 \(O(n\log^2n)\) 地解决问题了。

#include &lt;bits/stdc++.h&gt;
const int mod = 1e9 + 9;
using arr = std::vector&lt;long long&gt;;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n;
    std::cin &gt;&gt; n;
    int l = 1 &lt;&lt; n;
    std::vector&lt;arr&gt; a(n + 1, arr(l)), b(n + 1, arr(l)), c(n + 1, arr(l));
    for (int i = 0, x; i &lt; l; ++i)
        std::cin &gt;&gt; x, a[__builtin_popcount(i)][i] = x;
    for (int i = 0, x; i &lt; l; ++i)
        std::cin &gt;&gt; x, b[__builtin_popcount(i)][i] = x;
    std::vector&lt;arr&gt; mT(2, arr(2)), mI(2, arr(2));
    mT[0][0] = 1ll, mT[0][1] = 0ll, mT[1][0] = 1ll, mT[1][1] = 1ll;
    mI[0][0] = 1ll, mI[0][1] = 0ll, mI[1][0] = mod - 1ll, mI[1][1] = 1ll;
    auto calc = [&amp;](arr &amp;f, std::vector&lt;arr&gt; &amp;w) &#123;
        for (int len = 2; len &lt;= l; len &lt;&lt;= 1)
            for (int i = 0; i &lt; l; i += len)
                for (int p = i, q = i + len / 2; q &lt; i + len; ++p, ++q)
                    std::tie(f[p], f[q]) = std::make_tuple((f[p] * w[0][0] + f[q] * w[0][1]) % mod, (f[p] * w[1][0] + f[q] * w[1][1]) % mod);
        return;
    &#125;;
    for (int i = 0; i &lt;= n; ++i)
        calc(a[i], mT), calc(b[i], mT);
    for (int i = 0; i &lt;= n; ++i) &#123;
        for (int k = 0; k &lt;= i; ++k)
            for (int j = 0; j &lt; l; ++j)
                (c[i][j] += a[k][j] * b[i - k][j]) %= mod;
        calc(c[i], mI);
    &#125;
    for (int j = 0; j &lt; l; ++j)
        std::cout &lt;&lt; c[__builtin_popcount(j)][j] &lt;&lt; &#39; &#39;;
    std::cout &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;


州区划分
https://www.luogu.com.cn/problem/P4221
人话：把 \(n\) 个点划分成若干个点集，保证每个点集的导出子图不是欧拉回路（每个点的度数为偶且图连通）。
那么枚举每一个点集判定是否合法，再令 \(f_{i}={w_i}^{-p}\times\sum\limits_{j\cup k = i\land j\cap k=\varnothing}f_{j}\times {w_k}^p\)。
发现后面那个 sigma 里面是一个简单的子集卷积；但是我们发现前面有一个和 \(i\) 有关的常数，导致没办法直接卷 \(n\) 次。
但我们发现这个 DP 其实是有一定隐含条件的——都是按照 \(\text{ctz}\) 从小到大转移。考虑子集卷积的第一维，得到 \(FWT_{f_i}\) 后先 IFWT 回来，乘上 \({w_i}^{-p}\)，再 FWT 回去即可。考察子集卷积的结构，发现这个是可以想办法套进去的。
复杂度 \(O(n^2\cdot 2^n)\)。

#include &lt;bits/stdc++.h&gt;
const int mod = 998244353;
using arr = std::vector&lt;long long&gt;;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n, m, p;
    std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; p;
    int l = 1 &lt;&lt; n;
    auto qkp = [&amp;](long long x, int y = mod - 2) &#123;
        auto res = 1ll;
        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)
            if (y &amp; 1)
                (res *= x) %= mod;
        return res;
    &#125;;
    arr w(n), inv(l);
    std::vector&lt;arr&gt; f(n + 1, arr(l)), s(n + 1, arr(l));
    std::vector&lt;std::vector&lt;int&gt; &gt; g(n);
    for (int x, y; m--; ) &#123;
        std::cin &gt;&gt; x &gt;&gt; y, --x, --y;
        g[x].push_back(y);
    &#125;
    auto check = [&amp;](int s) &#123;
        std::vector&lt;int&gt; f(n), deg(n);
        std::iota(f.begin(), f.end(), 0);
        std::function&lt;int(int)&gt; find = [&amp;](int x) &#123;
            return x == f[x] ? x : f[x] = find(f[x]);
        &#125;;
        auto merge = [&amp;](int x, int y) &#123;
            f[find(x)] = find(y);
            return;
        &#125;;
        for (int i = 0; i &lt; n; ++i)
            if ((s &gt;&gt; i) &amp; 1)
                for (auto j : g[i])
                    if ((s &gt;&gt; j) &amp; 1)
                        merge(i, j), ++deg[i], ++deg[j];
        int fa = -1;
        for (int i = 0; i &lt; n; ++i)
            if ((s &gt;&gt; i) &amp; 1) &#123;
                if (deg[i] &amp; 1)
                    return 1;
                if (fa == -1 || fa == find(i))
                    fa = find(i);
                else
                    return 1;
            &#125;
        return 0;
    &#125;;
    for (int i = 0; i &lt; n; ++i)
        std::cin &gt;&gt; w[i];
    for (int i = 0; i &lt; l; ++i) &#123;
        int ctz = __builtin_popcount(i);
        for (int j = 0; j &lt; n; ++j)
            if ((i &gt;&gt; j) &amp; 1) 
                s[ctz][i] += w[j];
        s[ctz][i] = qkp(s[ctz][i], p);
        inv[i] = qkp(s[ctz][i]);
        if (!check(i))
            s[ctz][i] = 0ll;
    &#125;
    std::vector&lt;arr&gt; mT(2, arr(2)), mI(2, arr(2));
    mT[0][0] = 1ll, mT[0][1] = 0ll, mT[1][0] = 1ll, mT[1][1] = 1ll;
    mI[0][0] = 1ll, mI[0][1] = 0ll, mI[1][0] = mod - 1ll, mI[1][1] = 1ll;
    auto calc = [&amp;](arr &amp;f, std::vector&lt;arr&gt; &amp;w) &#123;
        for (int len = 2; len &lt;= l; len &lt;&lt;= 1)
            for (int i = 0; i &lt; l; i += len)
                for (int p = i, q = i + len / 2; q &lt; i + len; ++p, ++q)
                    std::tie(f[p], f[q]) = std::make_tuple((f[p] * w[0][0] + f[q] * w[0][1]) % mod, (f[p] * w[1][0] + f[q] * w[1][1]) % mod);
        return;
    &#125;;
    f[0][0] = 1ll;
    for (int i = 0; i &lt;= n; ++i)
        calc(s[i], mT);
    for (int i = 1; i &lt;= n; ++i) &#123;
        calc(f[i - 1], mT);
        for (int k = 0; k &lt; i; ++k)
            for (int j = 0; j &lt; l; ++j)
                (f[i][j] += f[k][j] * s[i - k][j]) %= mod;
        calc(f[i], mI);
        for (int j = 0; j &lt; l; ++j)
            (f[i][j] *= inv[j]) %= mod;
    &#125;
    std::cout &lt;&lt; f[n][l - 1] &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;


B - Sum the Fibonacci
https://codeforces.com/problemset/problem/914/G
首先，对于每个元素的 \(cnt\) 是好做的——做一次子集卷积得到 \(cnt_1(a\cup b)\)，做一次 xor-FWT 得到 \(cnt_2(d\oplus e)\)，中间的 \(cnt(c)\) 就是原样。
值得注意的是可以在一次 and-FWT 后把 \(cnt,cnt_1,cnt_2\) 直接卷起来——由矩阵乘法结合律得（哈哈大笑了）。但怎么把 \(f\) 塞进去呢？如果你拥有小学生的数学水平，你可以很容易地想到直接在 \(cnt,cnt_1,cnt_2\) IFWT 后的结果分别对位乘上 \(f\) 即可，很可惜我并没有这样的数学能力 

#include &lt;bits/stdc++.h&gt;
const int N = 17;
const int mod = 1e9 + 7;
using arr = std::vector&lt;long long&gt;;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n, l;
    std::cin &gt;&gt; n, l = 1 &lt;&lt; N;
    std::vector&lt;int&gt; a(n + 1);
    arr f(l), cnt(l), cnt1(l), cnt2(l);
    for (int i = 1; i &lt;= n; ++i)
        std::cin &gt;&gt; a[i], ++cnt[a[i]];
    f[0] = 0ll, f[1] = 1ll;
    for (int i = 2; i &lt; l; ++i)
        f[i] = (f[i - 1] + f[i - 2]) % mod;
    auto qkp = [&amp;](long long x, int y = mod - 2) &#123;
        auto res = 1ll;
        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)
            if (y &amp; 1)
                (res *= x) %= mod;
        return res;
    &#125;;
    const int inv2 = qkp(2ll);
    std::vector&lt;arr&gt; mT(2, arr(2)), mI(2, arr(2));
    auto calc = [&amp;](arr a, arr &amp;f, std::vector&lt;arr&gt; &amp;w) &#123;
        f = a;
        for (int len = 2; len &lt;= l; len &lt;&lt;= 1)
            for (int i = 0; i &lt; l; i += len)
                for (int p = i, q = i + len / 2; q &lt; i + len; ++p, ++q)
                    std::tie(f[p], f[q]) = std::make_tuple((f[p] * w[0][0] + f[q] * w[0][1]) % mod, (f[p] * w[1][0] + f[q] * w[1][1]) % mod);
        return;
    &#125;;
    &#123; // orFWT
        mT[0][0] = 1ll, mT[0][1] = 0ll, mT[1][0] = 1ll, mT[1][1] = 1ll;
        mI[0][0] = 1ll, mI[0][1] = 0ll, mI[1][0] = mod - 1ll, mI[1][1] = 1ll;
        std::vector&lt;arr&gt; u(N + 1, arr(l)), d(N + 1, arr(l));
        for (int i = 0; i &lt; l; ++i)
            u[__builtin_popcount(i)][i] = cnt[i];
        for (int i = 0; i &lt;= N; ++i)
            calc(u[i], u[i], mT);
        for (int i = 0; i &lt;= N; ++i) &#123;
            for (int j = 0; j &lt; l; ++j)
                for (int k = 0; k &lt;= i; ++k)
                    (d[i][j] += u[k][j] * u[i - k][j]) %= mod;
            calc(d[i], d[i], mI);
        &#125;
        for (int i = 0; i &lt; l; ++i)
            cnt1[i] = d[__builtin_popcount(i)][i] * f[i] % mod;
    &#125;
    &#123; // xor FWT
        mT[0][0] = 1ll, mT[0][1] = 1ll, mT[1][0] = 1ll, mT[1][1] = mod - 1ll;
        mI[0][0] = mI[0][1] = mI[1][0] = inv2, mI[1][1] = mod - inv2;
        calc(cnt, cnt2, mT);
        for (int i = 0; i &lt; l; ++i)
            (cnt2[i] *= cnt2[i]) %= mod;
        calc(cnt2, cnt2, mI);
        for (int i = 0; i &lt; l; ++i)
            (cnt2[i] *= f[i]) %= mod;
    &#125;
    &#123; // andFWT
        mT[0][0] = 0ll, mT[0][1] = 1ll, mT[1][0] = 1ll, mT[1][1] = 1ll;
        mI[0][0] = mod - 1ll, mI[0][1] = 1ll, mI[1][0] = 1ll, mI[1][1] = 0ll;
        for (int i = 0; i &lt; l; ++i) // 这一步要放在 FWT 之前，原因显然 🤗
            (cnt[i] *= f[i]) %= mod;
        calc(cnt2, cnt2, mT), calc(cnt1, cnt1, mT), calc(cnt, cnt, mT);
        for (int i = 0; i &lt; l; ++i)
            cnt[i] = cnt[i] * cnt1[i] % mod * cnt2[i] % mod % mod;
        calc(cnt, cnt, mI);
    &#125;
    long long res = 0ll;
    for (int i = 0; i &lt; N; ++i)
        (res += cnt[1 &lt;&lt; i] % mod) %= mod;
    std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;

]]></content>
      <tags>
        <tag>高维前缀和</tag>
        <tag>FWT</tag>
      </tags>
  </entry>
  <entry>
    <title>杂题选谈</title>
    <url>/20250404/</url>
    <content><![CDATA[NOI Linux 2.0，拼尽全力无法战胜。

比方说我试图对我一片狼藉的屏幕进行一个图的截，但是我并不知道 where the so-called $PICTURE is 

这场有两个题都用到了 优先队列 + 最优答案扩展 的思路，可以记录一下。

A. 序列加法机
https://www.becoder.com.cn/contest/6174/problem/1
转化题意可以发现，三个不下降的限制拼起来其实就是没有限制。若令 \(c_i=|a_i-b_i|\)，则题意转化如下：

给定 \(c_{1\sim n}\)，定义一次操作为：

选择一个 \(x&gt;0\)，再选择 \(c_i\ge x\)，令 \(c_i\gets c_i-x\)，并花费 \(x^2\) 的代价。

现可进行不超过 \(m\) 次操作，问将 \(c_i\) 全部置为 \(0\) 的最小代价。

有一个比较显然的事情，如果给 \(c_i\) 分配 \(k\) 次操作机会，那么每次减去 \(\dfrac {c_i}k\) 是最优的。具体地，令 \(p=\left\lfloor\dfrac {c_i}k\right\rfloor\)，那么给 \(k\) 个中的 \(c_i\bmod k\) 分配 \(p+1\)，给剩余的 \(k-c_i\bmod k\) 分配 \(p\) 即可。这个随便用反证什么的证一下即可。
但是我们怎么知道应该给每个 \(c_i\) 分配多少次操作次数呢？这里有个 trick：初始先给每个 \(c_i\) 分配一次次数，对于每个 \(c_i\)，记录给其多分配一次后能减少的代价，全部丢进优先队列里，将最优的拿出来之后，记录再给其多分配一次后能减少的代价，再丢进去。能这样做的根本原因在于：

每个元素的每一次扩展代价相同。
对于同一个元素，丢到优先队列里的值是递减的（即无后效性，可以贪心）。


有人对着对的代码调了半个小时，是谁呢 
#include &lt;bits/stdc++.h&gt;
const int mod = 998244353;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
    std::freopen(&quot;seq.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;seq.out&quot;, &quot;w&quot;, stdout);
#else
    std::freopen(&quot;ex_seq2.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n, m;
    std::cin &gt;&gt; n &gt;&gt; m;
    std::vector&lt;long long&gt; c(n + 1);
    for (int i = 1; i &lt;= n; ++i)
        std::cin &gt;&gt; c[i];
    struct _ &#123;
        int k;
        long long org, d;
        bool operator&lt; (const _ &amp;q) const &#123;
            return d &lt; q.d; 
        &#125;
    &#125;;
    std::priority_queue&lt;_&gt; q;
    long long res = 0ll;
    auto calc = [&amp;](long long x, int k) &#123;
        auto p = x / k;
        return (x % k) * (p + 1) * (p + 1) + (k - x % k) * p * p;
    &#125;;
    for (int i = 1, x; i &lt;= n; ++i) &#123;
        std::cin &gt;&gt; x;
        c[i] = std::abs(c[i] - x);
        if (c[i]) &#123;
            (res += calc(c[i], 1) % mod) %= mod;
            q.push(&#123; 2, c[i], calc(c[i], 1) - calc(c[i], 2) &#125;);
        &#125;
    &#125;
    // printf(&quot;res = %lld\n&quot;, res);
    if ((int)q.size() &gt; m)
        std::cout &lt;&lt; -1 &lt;&lt; &#39;\n&#39;;
    else &#123;
        m -= (int)q.size();
        for (; m--; ) &#123;
            auto [k, org, d] = q.top();
            q.pop();
            // printf(&quot;org = %lld, k = %d, d = %lld\n&quot;, org, k, d);
            (res += mod - d % mod) %= mod;
            q.push(&#123; k + 1, org, calc(org, k) - calc(org, k + 1) &#125;);
        &#125;
        std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
    &#125;
    return 0;
&#125;


B. 摸鱼军训
https://www.becoder.com.cn/contest/6174/problem/2

定义一次冒泡排序为：
for (int i = 1; i &lt; n; ++i)
    if (a[i] &gt; a[i + 1])
        std::swap(a[i], a[i + 1]);
现给定一个排列和 \(m\) 次询问，问第 \(k\) 轮冒泡排序后元素 \(x\) 的位置。

发现一个元素移动的原因有两种：

前面有个比它大的元素「冒泡」到它后面去了，本轮该元素向前移动恰好一步。
前面没有比它更大的元素，轮到它来向后面「冒泡」了。找到具体的位置是不容易的，但我们发现每次 \(i\) 向右移动一步，都一定会有一个比 \(i\) 更小的元素被它交换到 \(i\) 左边。找到有多少个在 \(i\) 右边且比 \(i\) 小的元素到了 \(i\) 左边就可以得到这一种情况下 \(i\) 的位置。

容易发现，只要前面存在比它大的元素，那么第一条始终成立。树状数组统计 \(f_i\) 为元素 \(i\) 前比它大的元素个数，对于询问 \((k,i)\)，若 \(k\le f_i\)，那么答案即为 \(pos_i-k\)。
第 \(f_i+1\) 轮，\(i\) 向后「冒泡」，碰到一个比它更大的元素 \(j\) 即停止，此时 \(j\) 接替 \(i\) 向后「冒泡」，直到碰到一个 \(j&#39;&gt;j\) 为止，以此类推。
如何将 \(k\) 轮后 \(i\) 停下的位置对应到原数组上呢？我们发现每一轮 \(i\) 跨越的元素一定是比 \(i\) 小的可空极长段，手玩可以发现段的数量不会因为 \(i\) 之后任何元素的移动而改变，故找到 \(i\) 后第 \(k\) 个比 \(i\) 大的元素，中间比 \(i\) 小的元素个数就是 \(i\) 的右移步数。

#include &lt;bits/stdc++.h&gt;
int main() &#123;
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
    std::freopen(&quot;bubble.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;bubble.out&quot;, &quot;w&quot;, stdout);
    int n, m;
    std::cin &gt;&gt; n;
    std::vector&lt;int&gt; a(n + 1), bit(n + 1), p(n + 1), f(n + 1), bit1(n + 1);
    auto lowbit = [&amp;](int x) &#123;
        return x &amp; -x;
    &#125;;
    auto add = [&amp;](std::vector&lt;int&gt; &amp;bit, int x, int v) &#123;
        for (; x &lt;= n; x += lowbit(x))
            bit[x] += v;
        return;
    &#125;;
    auto qry = [&amp;](std::vector&lt;int&gt; &amp;bit, int x) &#123;
        int res = 0;
        for (; x; x -= lowbit(x))
            res += bit[x];
        return res;
    &#125;;
    auto ask = [&amp;](std::vector&lt;int&gt; &amp;bit, int l, int r) &#123;
        if (l &gt; n || r &lt; 1)
            return 0;
        return qry(bit, r) - qry(bit, l - 1);
    &#125;;
    for (int i = 1; i &lt;= n; ++i) &#123;
        std::cin &gt;&gt; a[i], p[a[i]] = i;
        f[a[i]] = ask(bit, a[i] + 1, n), add(bit, a[i], 1);
    &#125;
    struct _ &#123; int k, id; &#125;;
    std::vector&lt;std::vector&lt;_&gt; &gt; t(n + 1);
    std::cin &gt;&gt; m;
    std::vector&lt;int&gt; res(m + 1);
    for (int i = 1, x, k; i &lt;= m; ++i) &#123;
        std::cin &gt;&gt; k &gt;&gt; x;
        t[x].push_back(&#123; k, i &#125;);
    &#125;
    for (int i = 1; i &lt;= n; ++i) &#123;
        add(bit, p[i], -1);
        for (auto [k, id] : t[i])
            if (k &lt;= f[i])
                res[id] = p[i] - k;
            else &#123;
                int now = n;
                for (int l = p[i] + 1, r = n, mid; l &lt;= r; ) &#123;
                    mid = (l + r) &gt;&gt; 1;
                    if (ask(bit, p[i] + 1, mid) &gt;= k - f[i])
                        r = mid - 1, now = mid;
                    else
                        l = mid + 1;
                &#125;
                // printf(&quot;%d: now = %d\n&quot;, i, now);
                res[id] = p[i] - f[i] + ask(bit1, p[i] + 1, now);
            &#125;
        add(bit1, p[i], 1);
    &#125;
    for (int i = 1; i &lt;= m; ++i)
        std::cout &lt;&lt; res[i] &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;


C0. 超级钢琴
https://www.luogu.com.cn/problem/P2048
首先做前缀和，容易想到枚举右端点，那么左端点就是一段连续的区间。显然在这里最优选择是选择左端点中 \(s\) 最小的一个。
怎么求前 \(k\) 大呢？这里有一个很固定的 trick：把每个右端点及其对应的左端点区间丢到优先队列里，按照最优解（用 ST 表找一下即可）从优到劣排序。
每次取出最优解 \([l_1, l_2], r\)，假设最优决策为 \(x\in [l_1, l_2]\)，那么把 \([l_1, x), r\) 和 \((x, l_2], r\) 分别丢到优先队列里去。这个做法成立的根本原因也是：

任何一个元素都可以贡献一次答案。
对于同一个 \(r\)，随着拆分次数的增加，最优解逐渐变劣（无后效性，可贪心）。


#include &lt;bits/stdc++.h&gt;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(".in", "r", stdin);
    std::freopen(".out", "w", stdout);
#endif
    int n, k, l, r;
    std::cin >> n >> k >> l >> r;
    std::vector&lt;long long> a(n + 1);
    std::vector&lt;std::vector&lt;long long> > st(21, std::vector&lt;long long> (n + 1));
    for (int i = 1; i > a[i], st[0][i] = i;
    std::partial_sum(a.begin() + 1, a.end(), a.begin() + 1);
    for (int j = 1; (1 < j) ]]></content>
      <tags>
        <tag>堆</tag>
        <tag>树的重心</tag>
      </tags>
  </entry>
  <entry>
    <title>NOI 大纲 Upload</title>
    <url>/20250418/</url>
    <content><![CDATA[link




]]></content>
  </entry>
  <entry>
    <title>杂题选谈：组合计数</title>
    <url>/20250407/</url>
    <content><![CDATA[毅毅：统计不是数学（断章取义 ed）。故删掉了数学标签。 其实并没有。


A. 二分图染色
https://www.becoder.com.cn/contest/6181/problem/1
首先只看红色。显然一个左部点最多只能用红边连接一个右部点，反之同理。把左部点视为下标，其用红边相连的右部点视为值，则一个合法的方案为 \(n\) 的只保留一部分元素的排列。显然为 \(f(n)=\sum\limits_{i=0}^nC_n^i\cdot A_n^i\)。
再加上蓝色，\(f^2(n)\) 会给一条边涂两种颜色，故钦定有两种颜色的边数，容斥得到 \(\sum\limits_{i=0}^n(-1)^i\cdot C_n^i\cdot A_n^i\cdot f^2(n-i)\)。发现 \(f\) 的计算可能需要优化一下。考虑已经知道 \(f(n-1)\)，此时对于新增的第 \(n\) 对点：

任意连边（显然两个当中只能有一个点发出边），共有 \(2n-1\) 种方案，因为 \((n, n)\) 会被算重。
不连，共 \(1\) 种方案。
发现 1 中可能连到已经有连边的点上了，新边的目的地有 \(n-1\) 个选项，目的地原本连接的点也有 \(n-1\) 个选项，去掉两边共 \(4\) 个点，非法的即为 \((n-1)^2\cdot f(n-2)\)。


#include &lt;bits/stdc++.h&gt;
const int mod = 1e9 + 7;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n;
    std::cin &gt;&gt; n;
    std::vector&lt;long long&gt; f(n + 1), fac(n + 1), inv(n + 1);
    f[0] = 1ll, f[1] = 2ll;
    fac[0] = 1ll, fac[1] = 1ll, inv[0] = 1ll;
    for (int i = 2; i &lt;= n; ++i) &#123;
        fac[i] = fac[i - 1] * i % mod;
        f[i] = (f[i - 1] * 2 * i % mod + mod - f[i - 2] * (i - 1) % mod * (i - 1) % mod) % mod;
    &#125;
    auto qkp = [](long long x, int y) &#123;
        auto res = 1ll;
        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)
            if (y &amp; 1)
                (res *= x) %= mod;
        return res;
    &#125;;
    inv[n] = qkp(fac[n], mod - 2);
    for (int i = n - 1; i; --i)
        inv[i] = inv[i + 1] * (i + 1) % mod;
    auto C = [&amp;](int n, int m) &#123;
        return fac[n] * inv[n - m] % mod * inv[m] % mod;
    &#125;;
    auto A = [&amp;](int n, int m) &#123;
        return fac[n] * inv[n - m] % mod;
    &#125;;
    long long res = 0ll;
    for (int i = 0, k = 1; i &lt;= n; ++i, k = mod - k)
        (res += k * C(n, i) % mod * A(n, i) % mod * f[n - i] % mod * f[n - i]) %= mod;
    std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;


B. 七选五
https://www.becoder.com.cn/contest/6181/problem/2
首先 \(p\) 固定，钦定有 \(x\) 个数相等，有 \(C_k^x\) 个方案，剩下的就是从 \(n-x\) 个元素里选出 \(k-x\) 个来错排，考虑钦定相同的个数来容斥：
\[
\sum_{i=0}^{k-x}(-1)^i\cdot C_{k-x}^i\cdot A_{n-x-i}^{k-x-i}
\]

#include &lt;bits/stdc++.h&gt;
const int mod = 1e9 + 7;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n, k, x;
    std::cin &gt;&gt; n &gt;&gt; k &gt;&gt; x;
    std::vector&lt;long long&gt; fac(n + 1), inv(n + 1);
    fac[0] = 1ll, fac[1] = 1ll, inv[0] = 1ll;
    for (int i = 2; i &lt;= n; ++i)
        fac[i] = fac[i - 1] * i % mod;
    auto qkp = [](long long x, int y) &#123;
        auto res = 1ll;
        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)
            if (y &amp; 1)
                (res *= x) %= mod;
        return res;
    &#125;;
    inv[n] = qkp(fac[n], mod - 2);
    for (int i = n - 1; i; --i)
        inv[i] = inv[i + 1] * (i + 1) % mod;
    auto C = [&amp;](int n, int m) &#123;
        return fac[n] * inv[n - m] % mod * inv[m] % mod;
    &#125;;
    auto A = [&amp;](int n, int m) &#123;
        return fac[n] * inv[n - m] % mod;
    &#125;;
    long long res = C(k, x), sum = 0ll;
    for (int i = 0, p = 1; i &lt;= k - x; ++i, p = mod - p)
        (sum += p * C(k - x, i) % mod * A(n - x - i, k - x - i) % mod) %= mod;
    std::cout &lt;&lt; res * sum % mod &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;


D. 硬币购物
https://www.becoder.com.cn/contest/6181/problem/4
每次多重背包会超时，考虑用钦定每种硬币是否超额来容斥。令 \(f_s\) 表示凑出 \(s\) 的方案数（完全背包），那么 \(f_{s-c_1\times (d_1 + 1)}\) 就表示钦定第 1 种硬币超额时凑出 \(s\) 的方案数，以此类推。

#include &lt;bits/stdc++.h&gt;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int c[4], T, m = 1e5;
    std::vector&lt;long long&gt; f(m + 1);
    f[0] = 1;
    for (int i = 0; i &lt; 4; ++i) &#123;
        std::cin &gt;&gt; c[i];
        for (int j = c[i]; j &lt;= m; ++j)
            f[j] += f[j - c[i]];
    &#125;
    std::cin &gt;&gt; T;
    for (int d[4], m; T--; ) &#123;
        for (int i = 0; i &lt; 4; ++i)
            std::cin &gt;&gt; d[i];
        std::cin &gt;&gt; m;
        long long res = 0ll;
        for (int i = 0; i &lt; (1 &lt;&lt; 4); ++i) &#123;
            int s = m;
            for (int j = 0; j &lt; 4; ++j)
                if ((i &gt;&gt; j) &amp; 1)
                    s -= (d[j] + 1) * c[j];
            if (s &gt;= 0) &#123;
                int k = (__builtin_popcount(i) &amp; 1) ? -1 : 1;
                res += k * f[s];
            &#125;
        &#125;
        std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
    &#125;
    return 0;
&#125;


E. Distinct Multiples
https://www.becoder.com.cn/contest/6181/problem/5
推式子题。题意转化为，给定 \(n\) 个位置可选的值集合，要求任意两个位置值不等，问方案数。
如果把两个位置取等视作在团上选中边，那么有朴素做法钦定选边的集合 \(S\) 然后容斥，考虑它们构成的连通块 \(\{s\} \subseteq S\)，有 \(res=\sum\limits_{S\subseteq V}(-1)^{|S|}\cdot \prod\limits_{s_i} \left\lfloor \frac m{\operatorname{lcm} s_i} \right\rfloor\)。
有个很神奇的操作是把 \(S\) 丢掉，直接枚举 \(\{s\}\) 尝试子集 DP。有：\(res=\sum\limits_{\{s\}}\prod\limits_s f(s)\cdot\left\lfloor \frac m{\operatorname{lcm} s} \right\rfloor\)。其中 \(f(s)\) 表示选取一个 \(s\) 的导出子图的容斥系数之和，其中次数为导出子图中边数。
怎么把 \(f\) 算出来呢？容易发现其值只与 \(|s|\) 有关，考虑钦定与 \(1\) 连通的点数容斥，则有：
\[
f(n)=\sum\limits_{i=0}^{n - 1} (-1)^i \times C_{n-1}^{i-1} \times f(i) \cdot \sum_{j=0}^{m\gets i\times (i-1)\div 2} (-1)^j\cdot C_m^j
\]
我们知道，二项式定理取 \(a=1, b = -1\) 有 \(0^m=[m=0]=\sum_{j=0}^m(-1)^j\cdot C_m^j\)，代入得：
\[
\begin{aligned}
f(n)&amp;=\sum\limits_{i=0}^{n - 1} (-1)^i \times C_{n-1}^{n-i-1} \times f(n-i)\cdot [m=0\iff i=1]\\
&amp;=(1 - n)\cdot f(n-1)
\end{aligned}
\]
然后就能线性求出。再用一个子集 DP，为了保证顺序枚举最小的未被确定的点所在连通块进行转移。

#include &lt;bits/stdc++.h&gt;
const int mod = 998244353;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n, l;
    long long m;
    std::cin &gt;&gt; n &gt;&gt; m, l = 1 &lt;&lt; n;
    std::vector&lt;long long&gt; d(n), f(n + 1), dp(l), g(l);
    f[1] = 1ll;
    for (int i = 1; i &lt;= n; ++i) &#123;
        std::cin &gt;&gt; d[i - 1];
        if (i &gt;= 2)
            f[i] = (1 + mod - i) * f[i - 1] % mod;
        // printf(&quot;f[%d] = %lld\n&quot;, i, f[i]);
    &#125;
    for (int i = 0; i &lt; l; ++i) &#123;
        long long now = 1ll;
        for (int j = 0; j &lt; n; ++j)
            if ((i &gt;&gt; j) &amp; 1) &#123;
                if (now / std::__gcd(now, d[j]) &gt; m / d[j])
                    goto nosol;
                now = now / std::__gcd(now, d[j]) * d[j];
            &#125;
        g[i] = (m / now) % mod;
        // printf(&quot;lcm = %lld, g[%d] = %lld\n&quot;, now, i, g[i]);
    nosol: ;
    &#125;
    dp[0] = 1ll;
    auto lowbit = [](int x) &#123;
        return x &amp; -x;
    &#125;;
    for (int i = 1; i &lt; l; ++i) &#123;
        int to = std::__lg(lowbit(i));
        for (int j = i; j; j = (j - 1) &amp; i)
            if ((j &gt;&gt; to) &amp; 1)
                (dp[i] += dp[i ^ j] * f[__builtin_popcount(j)] % mod * g[j] % mod) %= mod;
    &#125;
    std::cout &lt;&lt; dp[l - 1] &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;


F. Permutation
https://www.becoder.com.cn/contest/6181/problem/6
如果全是 &lt;，方案数为 \(1\)。
现在把其中一些 &lt; 变成 ?，比如 &lt;&lt;??&lt;?&lt;&lt;&lt;&lt; 的方案数，太好了是多重集排列，我们没救了 显然被 &lt; 连接起来的一段元素只有一种排列方式，所以可以视为多重集排列，方案数为 \(\dfrac {11!}{3!\times 2!\times 5!}\)。
似乎只需要枚举把 &gt; 变成 &lt; 或 = 的 \(2^k\) 种情况再计算就可以了，可惜 \(k\) 有点大。但我们发现它在一定程度上是没有后效性的，比如 &lt;&lt;??&lt; 和 &lt;&lt;?&lt;&lt;，前面的 &lt;&lt; 不会对后面的内容带来影响。
故令 \(f_i\) 表示对于前 \(i\) 个元素的方案数，枚举最后一个被钦定为 ? 的 &gt; \(j\)（即 \([j + 1, i-1]\) 间的 &gt; 都被替换为 &lt;），带上容斥系数，有 \(f_i=\sum\limits_{s_j=\texttt{&#39;&gt;&#39;}}(-1)^{cnt_\texttt{&#39;&gt;&#39;}[j + 1, i - 1]}\times f_j\times\dfrac1{(i-j)!}\)。

#include &lt;bits/stdc++.h&gt;
const int mod = 1e9 + 7;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n;
    std::cin &gt;&gt; n;
    std::vector&lt;long long&gt; fac(n + 1), inv(n + 1);
    fac[0] = 1ll, inv[0] = 1ll;
    for (int i = 1; i &lt;= n; ++i)
        fac[i] = fac[i - 1] * i % mod;
    auto qkp = [](long long x, int y) &#123;
        auto res = 1ll;
        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)
            if (y &amp; 1)
                (res *= x) %= mod;
        return res;
    &#125;;
    inv[n] = qkp(fac[n], mod - 2);
    for (int i = n - 1; i; --i)
        inv[i] = inv[i + 1] * (i + 1) % mod;
    std::vector&lt;char&gt; s(n + 1);
    for (int i = 1; i &lt;= n; ++i)
        std::cin &gt;&gt; s[i];
    std::vector&lt;long long&gt; f(n + 1);
    s[0] = &#39;&gt;&#39;, f[0] = 1ll;
    for (int i = 1; i &lt;= n; ++i) &#123;
        int cnt = 0;
        for (int j = i - 1; ~j; --j)
            if (s[j] == &#39;&gt;&#39;) &#123;
                long long k = (cnt &amp; 1) ? mod - 1 : 1;
                (k *= f[j]) %= mod, (k *= inv[i - j]) %= mod;
                (f[i] += k) %= mod;
                ++cnt;
            &#125;
        // printf(&quot;f[%d] = %lld\n&quot;, i, f[i]);
    &#125;
    std::cout &lt;&lt; f[n] * fac[n] % mod &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;


忳郁邑余侘傺兮，余独穷困乎此时也。

H. ~K Perm Counting
https://www.becoder.com.cn/contest/6181/problem/8
考虑钦定令几个元素不满足条件进行容斥，即答案为 \(\sum\limits_{i=0}^n (-1)^i\cdot f(i)\)。但我们发现 \([n-k,n+k]\) 都有两个不能选的值，直接取 \(f(i)=\prod 2\) 肯定会选到相同值，一个自然（？）的想法是再容斥一遍，可惜手玩一下发现似乎容不动。考虑把玩意儿拍在棋盘上：

以 \(k=2\) 为例

其中 \(\times\) 是非法格子，边是非法格子间的不同选关系，同颜色的边隶属同一条链。容易发现如果棋盘继续扩大，这些链还会继续延长。
会发现这些链互不干扰，就是说我选了这条链上的某个点和链外的点没有任何关系（显然）。把这些链首尾相连拼起来，要做的就是拼接处可以选相邻，其余位置不能选相邻，选出来 \(i\) 个的方案数。提前预处理出来整个序列，令 \(tag_j\) 表示 \(j\) 是否能和 \(j-1\) 同选，设 \(dp_{j,i,0/1}\) 表示 DP 到了 \(j\)，已经选了 \(i\) 个数，第 \(j\) 个元素（不）选的方案数，那么有：
\[
dp_{j,i,0} = dp_{j - 1, i, 0} + dp_{j-1, i, 1}\\
dp_{j,i,1} = \begin{cases}
dp_{j-1, i - 1, 1} + dp_{j-1,i - 1,0}&amp;tag_j=1
\\
dp_{j-1,i,0}&amp;\text{otherwise}
\end{cases}
\]
大力 DP 即可。\(f(i)\) 即为 \((n-i)!\times (dp_{m, i, 0} + dp_{m, i, 1})\)，其中 \(m\) 为总链长。

注意不滚动可能会 MLE 
#include &lt;bits/stdc++.h&gt;
const int mod = 924844033;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n, k;
    std::cin &gt;&gt; n &gt;&gt; k;
    std::vector&lt;int&gt; tag(1);
    std::vector&lt;long long&gt; fac(n + 1);
    std::vector&lt;std::vector&lt;int&gt; &gt; vis(n + 1, std::vector&lt;int&gt; (n + 1));
    auto calc = [&amp;](int i, int j, int s) &#123;
        tag.push_back(1);
        for (; ; s ^= 1) &#123;
            // printf(&quot;(%d, %d) &quot;, i, j);
            vis[i][j] = 1;
            if (!s) &#123;
                i = j + k;
                if (i &lt;= n)
                    tag.push_back(0);
                else
                    break;
            &#125;
            else &#123;
                j = i + k;
                if (j &lt;= n)
                    tag.push_back(0);
                else
                    break;
            &#125;
        &#125;
        // puts(&quot;&quot;);
        return;
    &#125;;
    fac[0] = 1ll;
    for (int i = 1; i &lt;= n; ++i) &#123;
        fac[i] = fac[i - 1] * i % mod;
        int j = i - k;
        if (j &gt;= 1 &amp;&amp; !vis[i][j])
            calc(i, j, 1);
        j = i + k;
        if (j &lt;= n &amp;&amp; !vis[i][j])
            calc(i, j, 0);
    &#125;
    int m = (int)tag.size() - 1;
    // printf(&quot;m = %d\n&quot;, m);
    std::vector&lt;std::vector&lt;std::vector&lt;long long&gt; &gt; &gt; dp(2, std::vector&lt;std::vector&lt;long long&gt; &gt; (n + 1, std::vector&lt;long long&gt; (2)));
    dp[0][0][0] = 1ll;
    for (int j = 1, now = 1; j &lt;= m; ++j, now ^= 1) &#123;
        for (int i = 0; i &lt;= n &amp;&amp; i &lt;= j; ++i) &#123;
            dp[now][i][0] = dp[!now][i][0];
            dp[now][i][1] = 0ll;
            if (i) &#123;
                (dp[now][i][0] += dp[!now][i][1]) %= mod;
                dp[now][i][1] = dp[!now][i - 1][0];
                if (tag[j]) &#123;
                    (dp[now][i][1] += dp[!now][i - 1][1]) %= mod;
                    // assert(0);
                &#125;
            &#125;
            // printf(&quot;dp[%d][%d] = %lld / %lld\n&quot;, j, i, dp[j][i][0], dp[j][i][1]);
        &#125;
    &#125;
    long long res = 0ll;
    for (int i = 0, p = 1; i &lt;= n; ++i, p = mod - p)
        (res += p * fac[n - i] % mod * (dp[m &amp; 1][i][0] + dp[m &amp; 1][i][1]) % mod) %= mod;
    std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;


A - Positions in Permutations
https://codeforces.com/problemset/problem/285/E
（看向上一题）这照片是你吗？
在上一题的基础上，令 \(k=1\)。但是有个小小的问题——所求的「至少」不为 \(0\)，无法简单容斥。具体地，如果一个排列一共有 \(p\) 个非法排列，那么它会被 \(f(i)\) 统计 \(C_p^i\) 次。令 \(g(p)\) 表示非法格子数恰好为 \(p\) 的排列的真实数量，则 \(f(i)=\sum\limits_{j=i}^n C_j^i\cdot g(j)\)，二项式反演即可得到真实值 \(g(m)=\sum\limits_{j=m}^n (-1)^{j-m}\cdot C_j^m\cdot f(j)\)。

#include &lt;bits/stdc++.h&gt;
const int mod = 1e9 + 7;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n, k;
    std::cin &gt;&gt; n &gt;&gt; k;
    std::vector&lt;int&gt; tag(1);
    std::vector&lt;long long&gt; fac(n + 1), inv(n + 1);
    std::vector&lt;std::vector&lt;int&gt; &gt; vis(n + 1, std::vector&lt;int&gt; (n + 1));
    auto calc = [&amp;](int i, int j, int s) &#123;
        tag.push_back(1);
        for (; i &lt;= n &amp;&amp; j &lt;= n; s ^= 1) &#123;
            vis[i][j] = 1;
            if (!s) &#123;
                i = j + 1;
                if (i &lt;= n)
                    tag.push_back(0);
            &#125;
            else &#123;
                j = i + 1;
                if (j &lt;= n)
                    tag.push_back(0);
            &#125;
        &#125;
        return;
    &#125;;
    auto qkp = [&amp;](long long x, int y) &#123;
        auto res = 1ll;
        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)
            if (y &amp; 1)
                (res *= x) %= mod;
        return res;
    &#125;;
    fac[0] = 1ll, inv[0] = 1ll;
    for (int i = 1; i &lt;= n; ++i) &#123;
        fac[i] = fac[i - 1] * i % mod;
        int j = i - 1;
        if (j &gt;= 1 &amp;&amp; !vis[i][j])
            calc(i, j, 1);
        j = i + 1;
        if (j &lt;= n &amp;&amp; !vis[i][j])
            calc(i, j, 0);
    &#125;
    inv[n] = qkp(fac[n], mod - 2);
    for (int i = n - 1; i; --i)
        inv[i] = inv[i + 1] * (i + 1) % mod;
    int m = (int)tag.size() - 1;
    std::vector&lt;std::vector&lt;std::vector&lt;long long&gt; &gt; &gt; dp(2, std::vector&lt;std::vector&lt;long long&gt; &gt; (n + 1, std::vector&lt;long long&gt; (2)));
    dp[0][0][0] = 1ll;
    for (int j = 1, now = 1; j &lt;= m; ++j, now ^= 1) &#123;
        for (int i = 0; i &lt;= n &amp;&amp; i &lt;= j; ++i) &#123;
            dp[now][i][0] = dp[!now][i][0];
            dp[now][i][1] = 0ll;
            if (i) &#123;
                (dp[now][i][0] += dp[!now][i][1]) %= mod;
                dp[now][i][1] = dp[!now][i - 1][0];
                if (tag[j])
                    (dp[now][i][1] += dp[!now][i - 1][1]) %= mod;
            &#125;
        &#125;
    &#125;
    auto C = [&amp;](int n, int m) &#123;
        return fac[n] * inv[n - m] % mod * inv[m] % mod;
    &#125;;
    long long res = 0ll;
    for (int i = k, p = 1; i &lt;= n; ++i, p = mod - p) &#123;
        // printf(&quot;%d: %lld\n&quot;, i, C(i, k) * fac[n - i] % mod * (dp[m &amp; 1][i][0] + dp[m &amp; 1][i][1]) % mod);
        (res += p * C(i, k) % mod * fac[n - i] % mod * (dp[m &amp; 1][i][0] + dp[m &amp; 1][i][1]) % mod) %= mod;
    &#125;
    std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;


D - All Pairs Similarity P
https://www.luogu.com.cn/problem/P11458
省流：求 \(\forall\,i,f_i=\sum\limits_{j=1}^n \dfrac{|a_i\cap a_j|}{|a_i\cup a_j|}\)。
首先分离常数，有：
\[
\begin{aligned}
f_i&amp;=\sum\limits_{j=1}^n \dfrac{|a_i\cap a_j|}{|a_i\cup a_j|}\\
&amp;=\sum_{j=1}^n\dfrac {|a_i|+|a_j|-|a_i\cup a_j|}{|a_i\cup a_j|}\\
&amp;=\sum_{j=1}^n \dfrac {|a_i|+|a_j|}{|a_i\cup a_j|}-1
\end{aligned}
\]
尽量把分子变得更简：
\[
\begin{aligned}
f_i&amp;=\sum_{j=1}^n \dfrac {|a_i|+|a_j|}{|a_i\cup a_j|}-1\\
&amp;=|a_i|\cdot\left(\sum_{j=1}^n\dfrac 1{|a_i\cup a_j|}\right)-n+\sum_{j=1}^n \dfrac {|a_j|}{|a_i\cup a_j|}
\end{aligned}
\]
问题转化为求解 \(\sum\limits_{j=1}^n\dfrac 1{|a_i\cup a_j|}\) 和 \(\sum\limits_{j=1}^n\dfrac {|a_j|}{|a_i\cup a_j|}\)，以 \(*=\sum\limits_{j=1}^n\dfrac 1{|a_i\cup a_j|}\) 为例。令 \(b_i\) 为 \(a_i\) 补集，则：
\[
\begin{aligned}
*&amp;=\sum\limits_{j=1}^n\dfrac 1{|a_i\cup a_j|}\\
&amp;=\sum_{j=1}^n\dfrac 1{k-|b_i\cap b_j|}
\end{aligned}
\]
为什么要做这个转换呢？相比起并集运算，交集运算有着优秀的性质：\(s\subseteq(b_i\cap b_j)\iff s\subseteq b_i\land s\subseteq b_j\)，直接取或当然也有相似的性质，但是太烧脑了。
基于这个性质，我们有一个想法：对于所有 \(j\)，在 \(\forall \, s\subseteq b_j\) 处放置 \(\dfrac 1{k-|s|}\) 的贡献；对于 \(i\)，将 \(\forall \, s\subseteq b_i\) 处的贡献求和。但是这样肯定会拿到很多我们不想要的贡献，例如 \(\forall \, s\subset (b_i\cap b_j)\)。
考虑精细布置贡献——构造 \(g(|s|)\) 满足 \(\sum\limits_{j=1}^n\sum\limits_{s\subseteq b_j}g(|s|)=*\)。
这里可以二项式反演得到 \(g\)，具体地，令 \(F(|S|)=\dfrac 1{k-|S|}=\sum\limits_{s\subseteq S}g(|s|)=\sum\limits_{j=0}^{|S|} C_{|S|}^j g(j)\)，则 \(g(i)=\sum\limits_{j=0}^iC_i^j\cdot \dfrac {(-1)^{i-j}}{k-j}\)。
再令 \(h(s)=\sum\limits_{b_j\supseteq s}g(|s|)=g(|s|)\cdot \sum\limits_{b_j\supseteq s}1\)，那么 \(h\) 就是高维后缀和。我们正在做的事情就是求解 \(*=\sum\limits_{s\subseteq b_i}h(s)\)，这就又是一个高维前缀和了。
对于 \(\sum\limits_{j=1}^n\dfrac {|a_j|}{|a_i\cup a_j|}\) 呢，令 \(h(s)=\sum\limits_{b_j\supseteq s}g(|s|)\cdot {\color{red}{|a_j|}} = g(|s|) \cdot \sum\limits_{b_j\supseteq s} \color{red}{k - |b_j|}\)，改变高维后缀和求和对象即可。
复杂度就是 \(O(n+k\cdot 2^k)\)，其中 \(k\cdot 2^k\) 来自整体高维前 / 后缀和，\(n\cdot k\) 来自枚举 \(i\)。

#include &lt;bits/stdc++.h&gt;
const int mod = 1e9 + 7;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n, k, l;
    std::cin &gt;&gt; n &gt;&gt; k, l = 1 &lt;&lt; k;
    std::vector&lt;int&gt; a(n + 1), b(n + 1), cnt(l);
    for (int i = 1; i &lt;= n; ++i) &#123;
        std::cin &gt;&gt; a[i], b[i] = (l - 1) ^ a[i];
        ++cnt[b[i]];
    &#125;
    std::vector&lt;long long&gt; g(k + 1), fac(k + 1);
    auto qkp = [&amp;](long long x, int y = mod - 2) &#123;
        auto res = 1ll;
        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)
            if (y &amp; 1)
                (res *= x) %= mod;
        return res;
    &#125;;
    auto C = [&amp;](int n, int m) &#123;
        return fac[n] * qkp(fac[n - m]) % mod * qkp(fac[m]) % mod;
    &#125;;
    fac[0] = 1ll;
    for (int i = 1; i &lt;= k; ++i)
        fac[i] = fac[i - 1] * i % mod;
    for (int i = 0; i &lt;= k; ++i) &#123;
        for (int j = 0, p = (i &amp; 1) ? mod - 1 : 1; j &lt;= i; ++j, p = mod - p)
            (g[i] += C(i, j) * p % mod * qkp(k - j) % mod) %= mod;
        // printf(&quot;g[%d] = %lld\n&quot;, i, g[i]);
    &#125;
    // for (int i = 0; i &lt;= k; ++i) &#123;
    //     long long F = 0ll;
    //     for (int j = 0; j &lt;= i; ++j)
    //         (F += C(i, j) * g[j] % mod) %= mod;
    //     printf(&quot;%d: %lld / %lld\n&quot;, i, F, qkp(k - i));
    // &#125;
    std::vector&lt;long long&gt; h(l);
    std::copy(cnt.begin(), cnt.end(), h.begin());
    for (int i = 0; i &lt; k; ++i)
        for (int j = l - 1; ~j; --j)
            if (!((j &gt;&gt; i) &amp; 1))
                (h[j] += h[j ^ (1 &lt;&lt; i)]) %= mod;
    auto f1(h);
    for (int i = 0; i &lt; l; ++i)
        (f1[i] *= g[__builtin_popcount(i)]) %= mod;
    for (int i = 0; i &lt; k; ++i)
        for (int j = 0; j &lt; l; ++j)
            if ((j &gt;&gt; i) &amp; 1)
                (f1[j] += f1[j ^ (1 &lt;&lt; i)]) %= mod;
    for (int i = 0; i &lt; l; ++i)
        h[i] = cnt[i] * (k - __builtin_popcount(i));
    for (int i = 0; i &lt; k; ++i)
        for (int j = l - 1; ~j; --j)
            if (!((j &gt;&gt; i) &amp; 1))
                (h[j] += h[j ^ (1 &lt;&lt; i)]) %= mod;
    auto f2(h);
    for (int i = 0; i &lt; l; ++i)
        (f2[i] *= g[__builtin_popcount(i)]) %= mod;
    for (int i = 0; i &lt; k; ++i)
        for (int j = 0; j &lt; l; ++j)
            if ((j &gt;&gt; i) &amp; 1)
                (f2[j] += f2[j ^ (1 &lt;&lt; i)]) %= mod;
    for (int i = 1; i &lt;= n; ++i) &#123;
        // fprintf(stderr, &quot;%d: %d * %lld - %d + %lld\n&quot;, i, __builtin_popcount(a[i]), f1[b[i]], n, f2[b[i]]);
        std::cout &lt;&lt; (__builtin_popcount(a[i]) * f1[b[i]] % mod + mod - n + f2[b[i]]) % mod &lt;&lt; &#39;\n&#39;;
    &#125;
    return 0;
&#125;


E - Prefix XORs
https://atcoder.jp/contests/arc137/tasks/arc137_d
省流：做 \(k\) 次前缀和，\(k=1,2,\cdots,m\)，分别询问：令 \(x_i\gets a_i\) 对 \(s_n\) 的贡献次数，则 \(\sum a_i\cdot (x_i\bmod 2)\)？
对于 \(a_p\)，容易发现第一轮其对任意 \(s_q\) 有 \(1\) 次贡献，拉开来就是常数列；第二轮有 \((q-p+1)\) 次贡献，是公差为 \(1\) 的等差数列；第三轮是类三角形数——至此，肯定和组合数有关了。手玩可以发现第 \(k\) 轮 \(a_p\) 对 \(s_n\) 的贡献为 \(C_{n-p+(k-2)}^{n-p}\)，尽量令其中一个不动，得到 \(C_{n-p+(k-2)}^{k-1}\)。
但是我们发现直接枚举每轮每个数会起飞，而且模数为 \(2\) 似乎只能 Lucas（再带个 \(\log\)），怎么办呢？
那就 Lucas 呗。由其观察容易发现 \(C_{n-p+(k-2)}^{k-2}\bmod2=1\) 当且仅当 \((k-2)\subseteq (n-p+k-2)\iff (k-2)\subseteq \complement_U(n-p)\)，故问题转化为高维后缀和，当然你也可以做一次 and-FWT，那么 \(res_k=\sum (C_{n-p+(k-2)}^{k-2}\bmod 2)\cdot a_p=S_{k-2}\)，其中 \(S\) 为高维后缀和，初值为 \(S_{\complement_u(n-i)}\gets a_i\)。

#include &lt;bits/stdc++.h&gt;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n, m, l, k;
    std::cin &gt;&gt; n &gt;&gt; m, k = std::__lg(n + m) + 1, l = 1 &lt;&lt; k;
    std::vector&lt;int&gt; s(l);
    for (int i = 1; i &lt;= n; ++i)
        std::cin &gt;&gt; s[l - 1 - (n - i)];
    for (int i = 0; i &lt; k; ++i)
        for (int j = l - 1; ~j; --j)
            if (!((j &gt;&gt; i) &amp; 1))
                s[j] ^= s[j ^ (1 &lt;&lt; i)];
    for (int i = 1; i &lt;= m; ++i)
        std::cout &lt;&lt; s[i - 1] &lt;&lt; &#39; &#39;;
    std::cout &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;


B - The Top Scorer
https://codeforces.com/problemset/problem/1096/E
鉴于每种方案等概率（翻译没说，但原题面有提到），考虑计算小明能够取胜的方案数，再对总方案数做除法。先枚举最高分 \(k\ge r\)，再枚举包括小明在内恰有 \(c\ge 1\) 个人 拿到 \(k\) 分。但剩下的人呢？显然是不能插板随机分配的，因为存在 \(&lt;k\) 的限制。
考虑容斥，钦定剩下的 \(p-c\) 个人中拿到 \(\ge k\) 分的人数后再可空地插板即可，则总方案数为：
\[
\sum_{k=r}^s\sum_{c=1}^p\dfrac {C_{p - 1}^{c-1}}c\cdot \sum_{i=0}^{p-c}C_{p-c}^i\cdot C_{s-k\cdot (c+i)+(p-c-1)}^{p-c-1}
\]
其中分母上的 \(c\) 来源于等概率分配给最高分，虽然不是整数，但也代表着「小明获胜可行方案数」。最后将答案除上总方案数 \(C_{s-r+p-1}^{p-1}\) 即可。

#include &lt;bits/stdc++.h&gt;
const int mod = 998244353;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int p, s, r;
    std::cin &gt;&gt; p &gt;&gt; s &gt;&gt; r;
    std::vector&lt;long long&gt; fac(s + p), inv(s + p);
    fac[0] = inv[0] = 1ll;
    for (int i = 1; i &lt; s + p; ++i) &#123;
        fac[i] = fac[i - 1] * i % mod;
    &#125;
    auto qkp = [&amp;](long long x, int y) &#123;
        auto res = 1ll;
        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)
            if (y &amp; 1)
                (res *= x) %= mod;
        return res;
    &#125;;
    inv.back() = qkp(fac.back(), mod - 2);
    for (int i = s + p - 2; i &gt; 0; --i)
        inv[i] = inv[i + 1] * (i + 1) % mod;
    auto C = [&amp;](int n, int m) &#123;
        if (n == -1 &amp;&amp; m == -1)
            return 1ll;
        return fac[n] * inv[n - m] % mod * inv[m] % mod;
    &#125;;
    auto res(0ll);
    for (int k = r; k &lt;= s; ++k)
        for (int c = 1; c &lt;= p; ++c)
            if ((p - c) * (k - 1) + c * k &gt;= s) &#123;
                auto t(0ll);
                for (int i = 0, now = 1; i &lt;= p - c &amp;&amp; k * (c + i) &lt;= s; ++i, now = mod - now)
                    (t += now * C(p - c, i) % mod * C(s - k * (c + i) + (p - c - 1), p - c - 1) % mod) %= mod;
                (res += C(p - 1, c - 1) * qkp(c, mod - 2) % mod * t % mod) %= mod;
            &#125;
    std::cout &lt;&lt; res * qkp(C(s - r + p - 1, p - 1), mod - 2) % mod &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;


C - Sky Full of Stars
https://codeforces.com/problemset/problem/997/C
发现用 \(3^{n\times n}\) 减去任意一行一列不同色的方案就是答案。
考虑一元容斥，如令 \(f_i\) 表示至少 \(i\) 行 \(i\) 列同色的方案，但会发现 \(f_0\) 中包含 \(0\) 行 \(1\) 列同色等与预期不符的情况。受此启发考虑令 \(f_{i,j}\) 表示至少 \(i\) 行 \(j\) 列同色进行二元容斥。容易发现当 \(i\times j\ne 0\) 时，被选中的 \(i\) 行 \(j\) 列全部连通，应为同一种颜色；将它们挪到角落，可以发现未被选中的格子共有 \((n-i)\times (n-j)\) 个。故有：
\[
f_{i,j}=\begin{cases}
C_n^j\times 3^j\times 3^{n\times(n - j)}&amp;i=0\\
C_n^i\times 3^i\times 3^{n\times(n-i)}&amp;j=0\\
C_n^i\times C_n^j\times 3\times 3^{(n-i)\times (n-j)}&amp;\text{otherwise}
\end{cases}
\]
令 \(g_{i,j}\) 表示恰好 \(i\) 行 \(j\) 列同色的方案数，那么答案为 \(3^{n\times n}-g_{0,0}\)。二项式反演 / 容斥原理得 \(g_{0,0}=\sum\limits_{i=0}^n\sum\limits_{j=0}^n (-1)^{i+j}\cdot f_{i,j}\)。很惊讶地发现这是 \(O(n^2)\) 的！考虑优化。把 \(f_{1\to n,1\to n}\) 合并同类项，得到：
\[
\begin{aligned}
g_{0, 0}
&amp;=\left[\sum_{j=0}^n (-1)^j\cdot f_{0,j}\right]+\sum_{i=1}^n (-1)^i\cdot f_{i,0}+\sum_{j=1}^n (-1)^{i+j}\cdot C_n^i\times C_n^j\times 3^{(n-i)\times (n-j)+1}\\
&amp;=\left[\sum_{j=0}^n (-1)^j\cdot f_{0,j}\right]+\sum_{i=1}^n (-1)^i\cdot f_{i,0}+(-1)^i\cdot C_n^i\times 3^{n^2-n\times i+1}\times\sum_{j=1}^n (-1)^j\cdot C_n^j\times 3^{j\times(-n+i)}\\
&amp;=\left[\sum_{j=0}^n (-1)^j\cdot f_{0,j}\right]+\sum_{i=1}^n (-1)^i\cdot f_{i,0}+(-1)^i\cdot C_n^i\times 3^{n^2-n\times i+1}\times\left[\left(\sum_{j=0}^n (-1)^j\cdot C_n^j\times (3^{-n+i})^j\right)-1\right]\\
&amp;=\left[\sum_{j=0}^n (-1)^j\cdot f_{0,j}\right]+\sum_{i=1}^n (-1)^i\cdot f_{i,0}+(-1)^i\cdot C_n^i\times 3^{n^2-n\times i+1}\times\left[(-3^{-n+i}+1)^n-1\right]
\end{aligned}
\]
由此便可 \(O(n\log n)\) 计算。担心超时可以把所有 \(3^{-n+i}\) 和 \(3^{n\times i}\) 线性预处理出来，复杂度不会变就是了。
这里解释一下最后一步的二项式定理，非常遗憾地发现 \(-1\) 和 \(3^{-n+i}\) 都是 \(j\) 次的，没办法把二者相加减做二项式定理；但由于次数相同，这提示我们可以把 \(-1\) 乘到 \(3^{-n+i}\) 里去，给每一项配上 \(1^{n-k}\) 就可以做 \(-3^{n-i}\)（注意不是 \((-3)^{n-i}\)） 和 \(1\) 的二项式定理。

#include &lt;bits/stdc++.h&gt;
const int mod = 998244353;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    long long n;
    std::cin &gt;&gt; n;
    std::vector&lt;long long&gt; fac(n + 1), inv(n + 1), invn(n + 1), invi(n + 1), powi(n + 1), pown(n + 1);
    auto qkp = [&amp;](long long x, long long y) &#123;
        auto res(1ll);
        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)
            if (y &amp; 1)
                (res *= x) %= mod;
        return res;
    &#125;;
    const long long pnn = qkp(3ll, n * n), pn = qkp(3ll, n);
    fac[0] = inv[0] = invn[0] = invi[0] = powi[0] = pown[0] = 1ll;
    for (int i = 1; i &lt;= n; ++i) &#123;
        fac[i] = fac[i - 1] * i % mod;
        powi[i] = powi[i - 1] * 3 % mod;
        pown[i] = pown[i - 1] * pn % mod;
    &#125;
    inv[n] = qkp(fac[n], mod - 2);
    invi[n] = qkp(powi[n], mod - 2);
    invn[n] = qkp(pown[n], mod - 2);
    for (int i = n - 1; i; --i) &#123;
        inv[i] = inv[i + 1] * (i + 1) % mod;
        invi[i] = invi[i + 1] * 3 % mod;
        invn[i] = invn[i + 1] * pn % mod;
    &#125;
    auto C = [&amp;](int n, int m) &#123;
        return fac[n] * inv[n - m] % mod * inv[m] % mod;
    &#125;;
    long long g = 0ll;
    auto f = [&amp;](int i, int j) &#123; // make sure (!i || !j)
        if (i == 0 &amp;&amp; j == 0)
            return pnn;
        else if (i == 0)
            return C(n, j) * powi[j] % mod * pown[n - j] % mod;
        return C(n, i) * powi[i] % mod * pown[n - i] % mod;
    &#125;;
    for (int j = 0, p = 1; j &lt;= n; ++j, p = mod - p)
        (g += p * f(0, j)) %= mod;
    for (int i = 1, p = mod - 1; i &lt;= n; ++i, p = mod - p)
        (g += p * f(i, 0) % mod + p * C(n, i) % mod * pnn % mod * invn[i] % mod * 3 % mod * (qkp(mod - invi[n - i] + 1, n) + mod - 1) % mod) %= mod;
    std::cout &lt;&lt; (pnn + mod - g) % mod &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;


D - 去 M / NoM
https://www.luogu.com.cn/problem/P11316
假设 \(f(i)\) 为至少有 \(i\) 对不合法元素的方案数，则容斥得到答案 \(\sum\limits_{i=0}^n (-1)^i\cdot f(i)\)。考虑怎么计算 \(f(i)\)。
\(M\) 整除 \(dis(x, y) \iff (pos_x - pos_y)\bmod M=0\iff pos_x\equiv pos_y\pmod M\)。
考虑把关于 \(M\) 同余的位置放在一个组，也就是说需要让一对元素不能选同一组的位置。
考虑容斥，令 \(f(i)\) 表示至少有 \(i\) 对点选到一组的方案数，考虑怎么计算。假设我们要在第 \(k\) 组（size 为 \(s_k\)）中选出 \(x\) 对位置，实际上只需要选择 \(2x\) 个位置然后任意分配给这 \(x\) 对数，即 \(A_{s_k}^{2x}\)。设 \(dp_{i, j}\) 表示 DP 到第 \(i\) 个组，已经选了 \(j\) 对，那么有 \(dp_{i,j}=\sum\limits_{k=0}^jC_{n-(j - k)}^{j-k}\times dp_{i-1,j-k}\times A_{s_i}^{2k}\)。乍一看好像是 \(O(n^3)\) 的，但是别忘了 \(\sum s_i=2n\)，所以只有 \(O(n^2)\)。\(f(i)\) 即为 \(dp_{m,i}\times (2n-2i)!\)。

#include &lt;bits/stdc++.h&gt;
const int mod = 1e9 + 7;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n, m;
    std::cin &gt;&gt; n &gt;&gt; m;
    std::vector&lt;int&gt; s(m + 1);
    std::vector&lt;long long&gt; fac(2 * n + 1), inv(2 * n + 1);
    fac[0] = inv[0] = 1ll;
    for (int i = 1; i &lt;= 2 * n; ++i)
        ++s[i % m + 1], fac[i] = fac[i - 1] * i % mod;
    auto qkp = [](long long x, int y) &#123;
        auto res = 1ll;
        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)
            if (y &amp; 1)
                (res *= x) %= mod;
        return res;
    &#125;;
    inv[2 * n] = qkp(fac[2 * n], mod - 2);
    for (int i = 2 * n - 1; i; --i)
        inv[i] = inv[i + 1] * (i + 1) % mod;
    auto A = [&amp;](int n, int m) &#123;
        return fac[n] * inv[n - m] % mod;
    &#125;;
    auto C = [&amp;](int n, int m) &#123;
        return fac[n] * inv[n - m] % mod * inv[m] % mod;
    &#125;;
    std::vector&lt;std::vector&lt;long long&gt; &gt; dp(m + 1, std::vector&lt;long long&gt; (n + 1));
    dp[0][0] = 1ll;
    for (int i = 1; i &lt;= m; ++i)
        for (int j = 0; j &lt;= n; ++j) &#123;
            for (int k = 0; k &lt;= j &amp;&amp; 2 * k &lt;= s[i]; ++k)
                (dp[i][j] += C(n - (j - k), k) * dp[i - 1][j - k] % mod * A(s[i], 2 * k) % mod) %= mod;
            // printf(&quot;s = %d, dp[%d][%d] = %lld\n&quot;, s[i], i, j, dp[i][j]);
        &#125;
    long long res = 0ll;
    for (int i = 0, p = 1; i &lt;= n; ++i, p = mod - p)
        (res += p * dp[m][i] % mod * fac[2 * n - 2 * i] % mod) %= mod;
    std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;


E - 「KDOI-11」彩灯晚会
https://www.luogu.com.cn/problem/P11292
考虑 \({cnt_i}^2\) 的含义，即在所有颜色为 \(i\)、长度为 \(l\) 的链中有放回地选两次的方案数。
显然复杂度里是不能包含 \(k\) 的，所以放弃直接统计 \(cnt_i\) 的想法。显然每种颜色是等价的，考虑计算选择两条链可以给答案带来的贡献：答案的形式是个和式；对于两条同色链 \(p,q\)，假设颜色为 \(i\)，那么会对 \({cnt_i}^2\) 带来 \(k^{n-2l-|p\cap q|}\) 的贡献，对总答案带来 \(k^{n-2l-|p\cap q| + 1}\) 的贡献。
然而如果要枚举计算 \(|p\cap q|\) 就无法避免 \(O(n^5)\)，考虑更有潜力的方法：将问题转化为对于每个 \(x\)，求交集大小恰好为 \(x\) 的链对个数。然而「恰好」是不方便计算的——假如当前两链在 \(u\) 次重合，如果假设下一次在 \(v\) 次重合，就需要保证在 \(u,v\) 之间不能重合——这并不好操作。二项式反演将恰好转化为至少，则限制减弱。
令 \(f_{u,c,l_1,l_2}\) 表示 \(p,q\) 当前在 \(u\) 处重合，视野内的 \(p,q\) 长度为 \(l_1,l_2\)，至少已经重合了 \(c\) 次的方案数。预处理出走到 \(u\) 步数为 \(l_1,l_2\) 的方案数为初始值。枚举可能的后续重合点 \(v\)（满足 \(v\) 的拓扑序 \(&gt;u\)）有 \(f_{v,c+1,l_1&#39;,l_2&#39;}\gets f_{v,c+1,l_1&#39;,l_2&#39;} + f_{u,c,l_1,l_2}\)。预处理出 \(u\to v\) 长度为 \(\Delta\) 的方案数（这是 \(O(n^3l)\) 的）优化转移，在算出 \(nex_{u,l}\) 表示从 \(u\) 出发走 \(l\) 步的方案数处理答案，则 \(F(i)=\sum_{u,l_1,l_2}f_{u,l_1,l_2}\cdot nex_{u,l-l_1}\cdot nex_{u,l-l_2}\)，枚举 \(u,c,l_1,l_2,v,l_1&#39;,l_2&#39;\)，就可以达到优秀的 \(O(n^2l^5+n^3l)\)！简直是令人震撼 
给出第一个优化：发现 \(l_1\) 和 \(l_2\) 的转移彼此不干扰，考虑建立一个临时数组 \(g\)，先从 \(f_u,c\) 转移 \(l_1\) 到 \(g\)，再从 \(g\) 转移 \(l_2\) 到 \(f_{v,c+1}\)，则复杂度降为 \(O(n^2l^4+n^3l)\)，仍不足以通过。
DP 过程上的优化已经万策尽，考虑从式子本身消元减少 DP 维度入手。令 \(h(i)\) 表示交集大小恰好恰好为 \(i\) 的方案数，则此时答案式为 \(\sum\limits_{i=0}^l k^{n-2l+i+1}\times h(i)\)。又 \(F(i)=\sum\limits_{j=i}^lC_j^i\cdot h(j)\)，二项式反演得：
\[
\begin{aligned}
res&amp;=\sum\limits_{i=0}^lk^{n-2l+i+1}\cdot \sum_{j=i}^l(-1)^{j-i}\cdot C_j^i\cdot F(j)\\
&amp;=k^{n-2l+1}\cdot\sum_{j=0}^l \sum_{i=0}^j k^i\cdot (-1)^{j-i}\cdot C_j^i\cdot F(j)\\
&amp;=k^{n-2l+1}\cdot \sum_{j=0}^l (k-1)^j\cdot F(j)
\end{aligned}
\]
注意这里利用了二项式反演的系数可以和交换求和顺序后的 \(i\) 次项（或 \(j-i\) 次项，参见 Sky Full of Stars 中最后一步的处理）组成二项式定理的特点，以便基于式子结构尽可能消元。
那么此时答案式已经和 \(c\) 无关，可以丢掉 \(c\) 这一维，和 \(c\) 有关的计算已经在转移时处理了。则 \(f_{v,l_1&#39;,l_2&#39;}=\sum f_{u,l_1,l_2}\times (k-1)\)，复杂度降为 \(O(n^2l^3+n^3l)\)。

记得还要算上 \(F(0)\)，即任选一条合法链的方案数平方。
// 兄弟你好香
// 兄弟你是依托打分，我踏马吃吃吃吃吃
#include &lt;bits/stdc++.h&gt;
const int mod = 998244353;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;party3.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    using arr = std::vector&lt;long long&gt;;
    using arrr = std::vector&lt;arr&gt;;
    using arrrr = std::vector&lt;arrr&gt;;
    int n, k, l, m;
    std::cin &gt;&gt; n, std::cin &gt;&gt; n &gt;&gt; k &gt;&gt; l &gt;&gt; m;
    std::vector&lt;int&gt; deg(n + 1), id;
    std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; g(n + 1);
    for (int x, y, c; m--; ) &#123;
        std::cin &gt;&gt; x &gt;&gt; y &gt;&gt; c;
        ++deg[y], g[x].emplace_back(y, c);
    &#125;
    arrrr to(n + 1, arrr(n + 1, arr(l + 1)));
    arrr pre(n + 1, arr(l + 1)), nex(n + 1, arr(l + 1));
    &#123;
        std::queue&lt;int&gt; q;
        for (int i = 1; i &lt;= n; ++i)
            if (!deg[i])
                q.push(i);
        for (int u; !q.empty(); ) &#123;
            u = q.front(), q.pop();
            to[u][u][0] = 1ll, id.push_back(u);
            for (auto i : id)
                for (int j = 0; j &lt;= l; ++j) &#123;
                    (pre[u][j] += to[i][u][j]) %= mod;
                    // printf(&quot;to[%d][%d][%d] = %lld\n&quot;, i, u, j, to[i][u][j]);
                &#125;
            // for (int j = 0; j &lt;= l; ++j)
            //     printf(&quot;pre[%d][%d] = %lld\n&quot;, u, j, pre[u][j]);
            for (auto [v, c] : g[u]) &#123;
                for (auto i : id)
                    for (int j = 1; j &lt;= l; ++j)
                        (to[i][v][j] += to[i][u][j - 1] * c) %= mod;
                if (!--deg[v])
                    q.push(v);
            &#125;
        &#125;
        for (int u = 1; u &lt;= n; ++u)
            for (int v = 1; v &lt;= n; ++v)
                for (int i = 0; i &lt;= l; ++i)
                    (nex[u][i] += to[u][v][i]) %= mod;
    &#125;
    arrrr f(n + 1, arrr(l + 1, arr(l + 1)));
    &#123;
        for (int i = 1; i &lt;= n; ++i)
            for (int l1 = 1; l1 &lt;= l; ++l1)
                for (int l2 = 1; l2 &lt;= l; ++l2)
                    f[i][l1][l2] = pre[i][l1 - 1] * pre[i][l2 - 1] % mod * (k - 1) % mod;
        for (auto i = 0; i &lt; n; ++i) &#123;
            int u = id[i];
            // for (int l1 = 1; l1 &lt;= l; ++l1)
            //     for (int l2 = 1; l2 &lt;= l; ++l2)
            //         printf(&quot;f[%d][%d][%d] = %lld\n&quot;, u, l1, l2, f[u][l1][l2]);
            for (auto j = i + 1; j &lt; n; ++j) &#123;
                arrr g(l + 1, arr(l + 1));
                int v = id[j];
                for (int l1 = 1; l1 &lt; l; ++l1)
                    for (int _l1 = l1 + 1; _l1 &lt;= l; ++_l1) &#123;
                        auto K = to[u][v][_l1 - l1];
                        if (K)
                            for (int l2 = 1; l2 &lt; l; ++l2)
                                (g[_l1][l2] += f[u][l1][l2] * K) %= mod;
                    &#125;
                for (int _l1 = 2; _l1 &lt;= l; ++_l1)
                    for (int l2 = 1; l2 &lt; l; ++l2)
                        if (g[_l1][l2])
                            for (int _l2 = l2 + 1; _l2 &lt;= l; ++_l2)
                                (f[v][_l1][_l2] += g[_l1][l2] * to[u][v][_l2 - l2] % mod * (k - 1)) %= mod; 
            &#125;
        &#125;
    &#125;
    auto qkp = [](long long x, int y) &#123;
        auto res(1ll);
        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)
            if (y &amp; 1)
                (res *= x) %= mod;
        return res;
    &#125;;
    auto res(0ll);
    for (int u = 1; u &lt;= n; ++u)
        for (int v = 1; v &lt;= n; ++v)
            (res += to[u][v][l - 1]) %= mod;
    (res *= res) %= mod;
    for (int u = 1; u &lt;= n; ++u)
        for (int l1 = 1; l1 &lt;= l; ++l1)
            for (int l2 = 1; l2 &lt;= l; ++l2)
                (res += f[u][l1][l2] * nex[u][l - l1] % mod * nex[u][l - l2] % mod) %= mod;
    res = res % mod * (qkp(k, n + 1) * qkp(qkp(k, 2 * l), mod - 2) % mod) % mod;
    std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;


G - 小星星
https://www.luogu.com.cn/problem/P3349
首先考虑比较暴力的做法，那么有 \(f_{i,j,S}\) 表示在 \(i\) 这个子树里面选了集合 \(S\)，且 \(i\) 的颜色为 \(j\) 的方案数，维数里之所以有 \(j\) 是为了满足连边限制。
然后树上子集 DP，发现是 \(O(n^4\cdot 2^n)\) 的，

CF785D Anton and School - 2
https://codeforces.com/problemset/problem/785/D
容易想到枚举每个 ( 作为分界点的情况，那么钦定当前枚举的 ( 是要选的。对于当前 (，若其左边（不含）的 ( 有 \(n\) 个而右边的 ) 有 \(m\) 个，枚举除了当前 ( 还要选 \(i\) 个 (，那么答案为 \(\sum_{i=0}C_n^{i-1}\cdot C_m^i\)。
发现这个形式可以范德蒙德卷积：\(\sum_{i=0}C_n^{i-1}\cdot C_m^i=\sum_{i=0}C_n^{n-i+1}\cdot C_m^i=C_{n+m}^{n+1}\)。
关于怎么记忆范德蒙德卷积，发现上下相加，也可以从组合意义记忆：在 \(n\) 个球中选出 \(k-i\) 个球，再从 \(m\) 个球中选出 \(i\) 个球的总方案就是从 \(n+m\) 个球中直接选出 \(k\) 个球的方案。
注意判断右侧没有 ) 的时候贡献为 \(0\)。

#include &lt;bits/stdc++.h&gt;
const int mod = 1e9 + 7;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    std::string s;
    std::cin &gt;&gt; s;
    int n = s.length();
    s = &quot; &quot; + s;
    std::vector&lt;int&gt; cnt1(n + 1), cnt2(n + 1);
    std::vector&lt;long long&gt; fac(n + 1), inv(n + 1);
    fac[0] = inv[0] = 1ll;
    for (int i = 1; i &lt;= n; ++i) &#123;
        fac[i] = fac[i - 1] * i % mod;
        cnt1[i] = cnt1[i - 1] + (s[i] == &#39;(&#39;);
    &#125;
    auto qkp = [](long long x, int y) &#123;
        auto res(1ll);
        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)
            if (y &amp; 1)
                (res *= x) %= mod;
        return res;
    &#125;;
    inv[n] = qkp(fac[n], mod - 2);
    cnt2[n] = (s[n] == &#39;)&#39;);
    for (int i = n - 1; i; --i) &#123;
        cnt2[i] = cnt2[i + 1] + (s[i] == &#39;)&#39;);
        inv[i] = inv[i + 1] * (i + 1) % mod;
    &#125;
    long long res = 0ll;
    auto C = [&amp;](int n, int m) &#123;
        if (n &lt; m)
            return 0ll;
        return fac[n] * inv[n - m] % mod * inv[m] % mod;
    &#125;;
    for (int i = 1; i &lt;= n; ++i)
        if (s[i] == &#39;(&#39;)
            (res += C(cnt1[i] + cnt2[i] - 1, cnt1[i])) %= mod;
    std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;


CF1332E Height All the Same
https://codeforces.com/problemset/problem/1332/E
容易发现第一个操作是用来改变两个数奇偶性的；而第二个操作能在全图奇偶性相同的任何情况下达成要求。
注意到如果我们想同时仅改变任意两个数的奇偶性，可以在棋盘上任找一条路径一路使用操作一。只要某种奇偶性的元素个数共有偶数个，就能通过若干次操作一把它们全部变成另一种奇偶性。
令 \(K_1\) 为 \(L\sim R\) 中奇数的个数，\(K_2\) 为偶数，那么有：
\[
res=\sum_{i=0}^{nm} C_{nm}^i\times {K_1}^i\cdot {K_2}^{nm-i}\cdot [i\bmod 2=0]
\]
我们发现这个东西和二项式定理简直像得不能再像了！但多了一个系数导致没办法省略枚举过程。如果进行变形呢？
\[
res=(K_1+K_2)^{nm}-\sum_{i=0}^{nm} C_{nm}^i\times {K_1}^i\cdot {K_2}^{nm-i}\cdot [i\bmod 2=1]
\]
似乎依然没有出路！但这里有个神奇的操作：
\[
res=(-K_1+K_2)^{nm}+\sum_{i=0}^{nm} C_{nm}^i\times {K_1}^i\cdot {K_2}^i\cdot [i\bmod 2=1]
\]
二式相加就可以消元，得到 \(2\cdot res=(K_1+K_2)^{nm}+(K_1-K_2)^{nm}\)。这启示我们二项式定理中的符号和奇偶性的深切联系。

如果你使用费马小定理对次数进行了处理，你可能需要注意次数可能为 \(\text{mod} -1\) 的倍数。
#include &lt;bits/stdc++.h&gt;
const int mod = 998244353;
const int inv2 = 499122177;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    long long n, m, l, r, k1, k2;
    std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; l &gt;&gt; r, k1 = (r - l + 1) / 2, k2 = (r - l + 1) - k1;
    auto qkp = [](long long x, long long y) &#123;
        auto res(1ll);
        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)
            if (y &amp; 1)
                (res *= x) %= mod;
        return res;
    &#125;;
    if (n * m % 2)
        std::cout &lt;&lt; qkp(r - l + 1, n * m) &lt;&lt; &#39;\n&#39;;
    else
        std::cout &lt;&lt; (qkp(r - l + 1, n * m) + qkp((k1 + mod - k2) % mod, n * m)) % mod * inv2 % mod &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;


A - 交错序列
https://www.luogu.com.cn/problem/P4456

出题人疑似需要加强数学功底（？）

容易想到把答案用二项式定理拆开：
\[
\begin{aligned}
res&amp;=\sum_y f_y\cdot y^b\cdot (n-y)^a\\
&amp;=\sum_y f_y\cdot y^b\cdot \sum_{i=0}^a C_a^i\cdot n^i\cdot(-y)^{a-i}\\
&amp;=\sum_y\sum_{i=0}^a f_y\cdot C_a^i\cdot n^i\cdot(-1)^{a-i}\cdot y^{a+b-i}\\
&amp;=\sum_{i=0}^a C_a^i\cdot n^i\cdot(-1)^{a-i}\cdot \sum_y f_y\cdot y^{a+b-i}\\
\end{aligned}
\]
然后发现后面那个 sigma 不太有办法求。一个比较优雅的方法是把 \(y^{a+b-i}\) 直接作为系数而非下标塞到 \(f\) 里去，即令 \(f_{i}\) 表示 \(\forall \,y\)，\(\sum y^i\) 之和。
具体地，令 \(dp_{n,i,0/1}\) 表示当前 DP 到第 \(n\) 位，要求幂次为 \(i\)，最后一位为 \(0/1\) 的答案。则显然有 \(dp_{n,i,0}=dp_{n-1,i,0}+dp_{n-1,i,1}\)。对于 \(dp_{n,i,1}\)，因为此时 \(\forall\, k,k\gets k+1\)，则 \((k+1)^i=\sum\limits_{j=0}^i C_i^j \cdot k^j\) 即 \(dp_{n,i,1}=\sum\limits_{j=0}^i C_i^j\cdot dp_{n-1,j,0}\)。发现 \(i,j\) 的范围是 \(90\)，很恐怖的事情是这是可以矩阵的。

就像我们都知道的那样，矩阵在加完之后再取模就会快很多……
#include &lt;bits/stdc++.h&gt;
int mod;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n, a, b;
    std::cin &gt;&gt; n &gt;&gt; a &gt;&gt; b &gt;&gt; mod;
    std::vector&lt;std::vector&lt;long long&gt; &gt; C(a + b + 1, std::vector&lt;long long&gt;(a + b + 1));
    for (int i = 0; i &lt;= a + b; ++i) &#123;
        C[i][0] = 1ll;
        for (int j = 1; j &lt;= i; ++j)
            C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % mod;
    &#125;
    struct mat &#123;
        int n, m;
        std::vector&lt;std::vector&lt;long long&gt; &gt; a;
        mat(int n, int m, bool flag = 0): n(n), m(m), a(n, std::vector&lt;long long&gt; (m)) &#123;
            if (flag)
                for (int i = 0; i &lt; n; ++i)
                    a[i][i] = 1ll;
            return;
        &#125;
        mat operator* (const mat &amp;q) const &#123;
            mat res(n, q.m);
            for (int i = 0; i &lt; n; ++i)
                for (int k = 0; k &lt; q.m; ++k) &#123;
                    for (int j = 0; j &lt; m; ++j)
                        res.a[i][k] += a[i][j] * q.a[j][k];
                    res.a[i][k] %= mod;
                &#125;
            return res;
        &#125;
        mat operator^ (int q) const &#123;
            mat res(n, n, 1), x(*this);
            for (; q; x = x * x, q &gt;&gt;= 1)
                if (q &amp; 1)
                    res = res * x;
            return res;
        &#125;
    &#125; f(1, 2 * (a + b + 1)), op(2 * (a + b + 1), 2 * (a + b + 1));
    auto fun = [&amp;](int i, int j) &#123;
        return i + j * (a + b + 1);
    &#125;;
    f.a[0][fun(0, 0)] = 1ll;
    for (int i = 0; i &lt;= a + b; ++i)
        op.a[fun(i, 0)][fun(i, 0)] = op.a[fun(i, 1)][fun(i, 0)] = 1ll;
    for (int i = 0; i &lt;= a + b; ++i)
        for (int j = 0; j &lt;= i; ++j)
            op.a[fun(j, 0)][fun(i, 1)] = C[i][j];
    f = f * (op ^ n);
    // for (int i = 0; i &lt;= n; ++i) &#123;
    //     if (i)
    //         f = f * op;
    //     for (int j = 0; j &lt;= a + b; ++j)
    //         printf(&quot;f[%d][%d] = %lld / %lld\n&quot;, i, j, f.a[0][fun(j, 0)], f.a[0][fun(j, 1)]);
    // &#125;
    auto res = 0ll;
    for (int i = 0; i &lt;= a; ++i) &#123;
        static auto p(1ll), k((a % 2) ? mod - 1ll : 1ll);
        (res += C[a][i] * p % mod * k % mod * (f.a[0][fun(a + b - i, 0)] + f.a[0][fun(a + b - i, 1)]) % mod) %= mod;
        (p *= n) %= mod, k = mod - k;
    &#125;
    std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;


B - Different Subsets For All Tuples
https://www.luogu.com.cn/problem/CF660E
首先你可能需要知道，如果已知一个序列，如何得到答案？
令 \(f_i\) 表示在 \(i\) 处取一个子序列的末尾，枚举上一个元素 \(x\)，找到 \(i\) 之前最靠后的一个 \(a_j=x\)，那么有 \(f_i=\sum f_j\)，换言之需要保证 \((j,i)\) 范围内没有 \(x\) 出现。
此时序列未知，令 \(f_{i, x}\) 表示在 \(i\) 处取一个子序列末尾，且 \(i\) 的值为 \(x\)；按照贡献的视角来看待，每个可以和 \(i\) 组成新子序列的方案可以带来 \(m^{i-1}\) 的贡献（因为 \(a_i\) 已经固定为 \(x\)，其他位置可以任选），那么有 \(f_{i,x}=m^i\times \sum_{j&lt;i,y}f_{j,y}\times (m-1)^{i-j-1}\)。
然后就惊讶地发现式子和 \(x\) 这一维没有关系了。所以直接带上系数得到：
\[
\begin{aligned}
f_i&amp;=m^i\times \sum_{j&lt;i} f_j\times (m-1)^{i-j-1}\times m\\
&amp;=m^i\times (m-1)^{i-1}\times m\cdot \sum_{j&lt;i} f_j\times (m-1)^{-j}
\end{aligned}
\]
前缀和优化一下就可以快速求了。最终的答案就是 \(res=m^n+\sum f_i\times (m-1)^{n-i}\)。

#include &lt;bits/stdc++.h&gt;
const int mod = 1e9 + 7;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n, m;
    std::cin &gt;&gt; n &gt;&gt; m;
    if (m == 1)
        std::cout &lt;&lt; (n + 1) &lt;&lt; &#39;\n&#39;;
    else &#123;
        std::vector&lt;long long&gt; f(n + 1), s(n + 1), pm1(n + 1);
        pm1[0] = 1ll;
        for (int i = 1; i &lt;= n; ++i)
            pm1[i] = pm1[i - 1] * (m - 1) % mod;
        auto qkp = [](long long x, int y) &#123;
            auto res(1ll);
            for (; y; (x *= x) %= mod, y &gt;&gt;= 1)
                if (y &amp; 1)
                    (res *= x) %= mod;
            return res;
        &#125;;
        auto res(qkp(m, n));
        const auto invm = qkp(m - 1, mod - 2);
        for (int i = 1; i &lt;= n; ++i) &#123;
            static long long p(m), inv(invm);
            f[i] = (p + pm1[i - 1] * m % mod * s[i - 1] % mod) % mod;
            s[i] = (s[i - 1] + f[i] * inv % mod) % mod;
            (res += f[i] * pm1[n - i] % mod) %= mod;
            (p *= m) %= mod, (inv *= invm) %= mod;
        &#125;
        std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;; 
    &#125;
    return 0;
&#125;


G - Gardens
https://atcoder.jp/contests/abc235/tasks/abc235_g
如果没有『每个人必须有一个元素』这个限制，就可以随便做了。现在加上了这个限制，很容易想到用没得到的人来容斥。钦定至少有 \(i\) 个人没拿到，得到答案为 \(\sum\limits_{i=0}^n (-1)^i\cdot C_n^i\cdot \left(\sum\limits_{j=0}^a C_i^j\right)\cdot \left(\sum\limits_{j=0}^b C_i^j\right)\cdot \left(\sum\limits_{j=0}^c C_i^j\right)\)。
怎么算 \(\sum\limits_{j=0}^a C_i^j\) 呢？当 \(a&gt; i\) 时，二项式是好求的；当 \(a\le i\) 时呢？看到这个式子很容易带到杨辉三角里去，也就是求一行的前 \(a\) 个数。注意到可以用上一行的前 \(a\) 个数 \(O(1)\) 得到（假设第 \(j-1\) 行前 \(a\) 个数之和为 \(f_a(j-1)\)）：\(f_a(j)=f_a(j-1)\times 2-C_{j-1,a}\)。你需要意识到，由于上一行也是答案中要求的，所以可以使用递推解决问题。在组合计数中，递推 / DP 无论是在化简式子还是求容斥 / 二项式反演里具体某一限制下的方案数都是很有用的，在需要优化复杂度时，可以从递推 / DP、恒等式、前缀和、预处理等方法入手考虑。

#include &lt;bits/stdc++.h&gt;
const int mod = 998244353;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n, a, b, c;
    std::cin &gt;&gt; n &gt;&gt; a &gt;&gt; b &gt;&gt; c;
    std::vector&lt;long long&gt; fac(n + 1), inv(n + 1), fa(n + 1), fb(n + 1), fc(n + 1), pow2(n + 1);
    fac[0] = inv[0] = pow2[0] = 1ll;
    for (int i = 1; i &lt;= n; ++i) &#123;
        fac[i] = fac[i - 1] * i % mod;
        pow2[i] = pow2[i - 1] * 2 % mod;
    &#125;
    auto qkp = [&amp;](long long x, int y) &#123;
        auto res(1ll);
        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)
            if (y &amp; 1)
                (res *= x) %= mod;
        return res;
    &#125;;
    inv[n] = qkp(fac[n], mod - 2);
    for (int i = n - 1; i; --i)
        inv[i] = inv[i + 1] * (i + 1) % mod;
    auto C = [&amp;](int n, int m) &#123;
        return fac[n] * inv[n - m] % mod * inv[m] % mod;
    &#125;;
    for (int i = 0; i &lt;= a; ++i)
        (fa[a] += C(a, i)) %= mod;
    for (int i = a + 1; i &lt;= n; ++i)
        fa[i] = (2 * fa[i - 1] % mod + mod - C(i - 1, a)) % mod;
    for (int i = 0; i &lt;= b; ++i)
        (fb[b] += C(b, i)) %= mod;
    for (int i = b + 1; i &lt;= n; ++i)
        fb[i] = (2 * fb[i - 1] % mod + mod - C(i - 1, b)) % mod;
    for (int i = 0; i &lt;= c; ++i)
        (fc[c] += C(c, i)) %= mod;
    for (int i = c + 1; i &lt;= n; ++i)
        fc[i] = (2 * fc[i - 1] % mod + mod - C(i - 1, c)) % mod;
    auto res(0ll);
    for (int i = n, p = 1; ~i; --i, p = mod - p)
        (res += p * C(n, i) % mod * (i &gt;= a ? fa[i] : pow2[i]) % mod * (i &gt;= b ? fb[i] : pow2[i]) % mod * (i &gt;= c ? fc[i] : pow2[i]) % mod) %= mod;
    std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;

]]></content>
      <tags>
        <tag>DP</tag>
        <tag>计数</tag>
      </tags>
  </entry>
  <entry>
    <title>杂题选谈：网格图路径计数</title>
    <url>/20250419/</url>
    <content><![CDATA[


猫




点到点的方案数
从 \((x_1,y_1)\) 只能向右、向下走到 \((x_2,y_2)\) 的方案数：\(C_{x_2-x_1+y_2-y_1}^{x_2-x_1}\)。就是说，因为必须向下走 \(x_2-x_1\) 步，又必须向右走 \(y_2-y_1\) 步；但顺序是可以任意打乱的。

A - Gerald and Giant Chess
https://codeforces.com/problemset/problem/560/E
把不能走的点按 \(x\) 为第一关键字，\(y\) 为第二关键字排序，就可以得到它们按大致拓扑序排列的结果。
令 \(f_i\) 表示不经过 \(1\sim i-1\) 的非法点走到第 \(i\) 个非法点的方案数，就可以得到 \(f_i=C_{x_i+y_i,x_i}-\sum_{j=1}^{i-1} f_j\times C_{x_i-x_j+y_i-y_j}^{x_i-x_j}\)。可以发现后面减去的方案，因为碰到的第一个非法点不同，所以是两两不同的。
让 \((h,w)\) 成为第 \((n+1)\) 个非法点，\(f_{n+1}\) 就是答案。

#include &lt;bits/stdc++.h&gt;
const int mod = 1e9 + 7;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int h, w, n;
    std::cin &gt;&gt; h &gt;&gt; w &gt;&gt; n, --h, --w;
    std::vector&lt;std::pair&lt;int, int&gt; &gt; a(n + 2);
    for (int i = 1; i &lt;= n; ++i) &#123;
        std::cin &gt;&gt; a[i].first &gt;&gt; a[i].second;
        --a[i].first, --a[i].second;
    &#125;
    a[n + 1] = &#123; h, w &#125;;
    std::sort(a.begin() + 1, a.end());
    std::vector&lt;long long&gt; fac(h + w + 1), inv(h + w + 1);
    fac[0] = inv[0] = 1ll;
    for (int i = 1; i &lt;= h + w; ++i)
        fac[i] = fac[i - 1] * i % mod;
    auto qkp = [](long long x, int y) &#123;
        auto res = 1ll;
        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)
            if (y &amp; 1)
                (res *= x) %= mod;
        return res;
    &#125;;
    inv[h + w] = qkp(fac[h + w], mod - 2);
    for (int i = h + w - 1; i; --i)
        inv[i] = inv[i + 1] * (i + 1) % mod;
    auto C = [&amp;](int n, int m) &#123;
        return fac[n] * inv[n - m] % mod * inv[m] % mod;
    &#125;;
    std::vector&lt;long long&gt; f(n + 2);
    for (int i = 1; i &lt;= n + 1; ++i) &#123;
        f[i] = C(a[i].first + a[i].second, a[i].first);
        for (int j = 1; j &lt; i; ++j)
            if (a[j].second &lt;= a[i].second)
                (f[i] += mod - f[j] * C(a[i].first - a[j].first + a[i].second - a[j].second, a[i].first - a[j].first) % mod) %= mod;
        // printf(&quot;f[(%d, %d)] = %lld\n&quot;, a[i].first, a[i].second, f[i]);
    &#125;
    std::cout &lt;&lt; f[n + 1] &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;


B - BBQ Hard
https://atcoder.jp/contests/agc001/tasks/agc001_e
不仅仅可以在关键点上 DP，也可以在网格上直接 DP。
\(A_i+B_i+A_j+B_j\) 就是 \(A_i+B_i-(-A_j)-(-B_j)\)。把棋盘扩大到 \(-2000\to 2000\) 就可以了。
设 \(f_{i,j}\) 表示可以到达 \((i,j)\) 的所有发出关键点 \((-A_j,-B_j)\) 带来的贡献，那么 \(f_{i,j}=f_{i-1,j}+f_{i,j-1}\)。枚举所有接收关键点 \((A_i,B_i)\)，\(\sum f_{A_i,B_i}\) 就是答案的两倍，再减去对角线，也就是 \(\sum (-A_i,B_i)\to (A_i,B_i)\) 后的值。

#include &lt;bits/stdc++.h&gt;
const int N = 2000;
const int mod = 1e9 + 7;
const int inv2 = 500000004;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n;
    std::cin &gt;&gt; n;
    std::vector&lt;long long&gt; fac(4 * N + 1), inv(4 * N + 1);
    fac[0] = inv[0] = 1ll;
    for (int i = 1; i &lt;= 4 * N; ++i)
        fac[i] = fac[i - 1] * i % mod;
    auto qkp = [](long long x, int y) &#123;
        auto res(1ll);
        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)
            if (y &amp; 1)
                (res *= x) %= mod;
        return res;
    &#125;;
    inv[4 * N] = qkp(fac[4 * N], mod - 2);
    for (int i = 4 * N - 1; i; --i)
        inv[i] = inv[i + 1] * (i + 1) % mod;
    std::vector&lt;std::pair&lt;int, int&gt; &gt; a(n + 1);
    std::vector&lt;std::vector&lt;long long&gt; &gt; f(2 * N + 1, std::vector&lt;long long&gt; (2 * N + 1));
    for (int i = 1; i &lt;= n; ++i) &#123;
        std::cin &gt;&gt; a[i].first &gt;&gt; a[i].second;
        ++f[N - a[i].first][N - a[i].second];
    &#125;
    for (int i = 0; i &lt;= 2 * N; ++i)
        for (int j = 0; j &lt;= 2 * N; ++j) &#123;
            if (i &gt;= 1)
                (f[i][j] += f[i - 1][j]) %= mod;
            if (j &gt;= 1)
                (f[i][j] += f[i][j - 1]) %= mod;
            // printf(&quot;f(%2d, %2d) = %lld\n&quot;, i - N, j - N, f[i][j]);
        &#125;
    long long res = 0ll;
    auto C = [&amp;](int n, int m) &#123;
        return fac[n] * inv[n - m] % mod * inv[m] % mod;
    &#125;;
    for (int i = 1; i &lt;= n; ++i) &#123;
        (res += f[a[i].first + N][a[i].second + N]) %= mod;
        (res += mod - C(a[i].first * 2 + a[i].second * 2, 2 * a[i].first)) %= mod;
    &#125;
    std::cout &lt;&lt; res * inv2 % mod &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;


C - Iroha and a Grid
https://atcoder.jp/contests/arc058/tasks/arc058_b
先把绿色部分的答案计算出来：

网格

如果把绿色的每一个格子到终点的方案数求和，就会算重，因为上面的绿色点可以走到下面的绿色点。
让绿色点第一步只能往右走到黄色点，用这样的方案为黄色点赋初值，再让黄色点自由走就可以得到答案了。

#include &lt;bits/stdc++.h&gt;
const int mod = 1e9 + 7;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int h, w, a, b;
    std::cin &gt;&gt; h &gt;&gt; w &gt;&gt; a &gt;&gt; b;
    std::vector&lt;long long&gt; fac(h + w + 1), inv(h + w + 1);
    fac[0] = inv[0] = 1ll;
    for (int i = 1; i &lt;= h + w; ++i)
        fac[i] = fac[i - 1] * i % mod;
    auto qkp = [](long long x, int y) &#123;
        auto res(1ll);
        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)
            if (y &amp; 1)
                (res *= x) %= mod;
        return res;
    &#125;;
    inv[h + w] = qkp(fac[h + w], mod - 2);
    for (int i = h + w - 1; i; --i)
        inv[i] = inv[i + 1] * (i + 1) % mod;
    auto C = [&amp;](int n, int m) &#123;
        return fac[n] * inv[n - m] % mod * inv[m] % mod;
    &#125;;
    auto res = 0ll;
    for (int i = 1; i &lt;= h - a; ++i) &#123;
        // (i, B)
        auto f(C(i + b - 2, i - 1));
        // printf(&quot;(%d, %d): %lld\n&quot;, i, b, f);
        // (i, B + 1)
        (res += f * C(h - i + w - (b + 1), h - i) % mod) %= mod;
    &#125;
    std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;


点到矩形的方案数
从 \((x_0,y_0)\) 走到矩形 \((x_1,y_1,x_2,y_2)\) 的方案数：
\[
\sum\limits_{i\in [x_1,x_2],j\in [y_1,y_2]} G(x_0,y_0, i, j) = G(x_0,y_0,x_2 + 1,y_2 + 1)-G(x_0,y_0,x_2+1,y_1)-G(x_0,y_0,x_1,y_2+1)+G(x_0,y_0,x_1,y_1)
\]
证明：\(G(x_0,y_0,x_2+1,y_2+1)=\sum\limits_i G(x_0,y_0,i,y_2)=\sum\limits_{i,j} G(x_0,y_0,i,j)\)，类似的，把后面几项展开，可以得到前缀和的结构。
现在，矩形就可以被概括成 4 个点了。

矩形到矩形的方案数
枚举第一个矩形里的所有点，那么就可以得到关于第二个矩形里四个点的表达式。反过来把第一个矩形概括为 4 个点就可以快速求解了。
具体一点，第一个矩形 \((x_1,y_1,x_2,y_2)\) 可以被概括为 \((x_1-1,y_1-1)\)，\((x_1-1,y_2)\)，\((x_2,y_1-1)\)，\((x_2,y_2)\)。注意方向颠倒导致符号发生变化。此时对 \(4\times 4=16\) 个 \(G\) 按对应的 \(-1/1\) 系数求和就能得到答案。

D - Sightseeing Plan
https://atcoder.jp/contests/agc018/tasks/agc018_e

恒等式：\(\sum\limits_{i\in [x_1,x_2]}G_(x_1,y_1,i,y_2-1)=G(x_1,y_1,x_2,y_2)\)，放在网格图上就是强制走到 \((i,y_2-1)\)，再强制向右走一步，然后向上走到 \((x_2,y_2)\)。和上一题类似的，可以发现不重不漏。
三个矩形，\(M_1\) 经过 \(M_2\) 到达 \(M_3\) 的路径数量：经过 \(M_2\) 时，根据限制，只可能从下面或左边进入。枚举进入的点 \((x_0,y_0)\)（数量为 \(O(n)\)），再计算 \(G(x_0,y_0,M_3)\) 就能得到不重不漏的答案。
原问题：要求 \(M_2\) 内部路径上点的贡献和，这个其实就是 \(M_2\) 内部路径长度。若从 \((x_1,y_1)\) 进入，再从 \((x_2,y_2)\) 离开，长度就是 \(x_2-x_1+y_2-y_1+1\)。拆成 \((x_2+y_2+1)\) 和 \(-(x_1+y_1)\) 后发现一次进入和一次离开的贡献是独立的。分别枚举进入点和离开点计算贡献就可以了。


#include &lt;bits/stdc++.h&gt;
const int N = 2e6;
const int mod = 1e9 + 7;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int x1, x2, x3, x4, x5, x6, y1, y2, y3, y4, y5, y6;
    std::cin &gt;&gt; x1 &gt;&gt; x2 &gt;&gt; x3 &gt;&gt; x4 &gt;&gt; x5 &gt;&gt; x6;
    std::cin &gt;&gt; y1 &gt;&gt; y2 &gt;&gt; y3 &gt;&gt; y4 &gt;&gt; y5 &gt;&gt; y6;
    std::vector&lt;long long&gt; fac(N + 1), inv(N + 1);
    fac[0] = inv[0] = 1ll;
    for (int i = 1; i &lt;= N; ++i)
        fac[i] = fac[i - 1] * i % mod;
    auto qkp = [](long long x, int y) &#123;
        auto res(1ll);
        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)
            if (y &amp; 1)
                (res *= x) %= mod;
        return res;
    &#125;;
    inv[N] = qkp(fac[N], mod - 2);
    for (int i = N - 1; i; --i)
        inv[i] = inv[i + 1] * (i + 1) % mod;
    auto C = [&amp;](int n, int m) &#123;
        return fac[n] * inv[n - m] % mod * inv[m] % mod;
    &#125;;
    std::vector&lt;std::tuple&lt;int, int, int&gt; &gt; f(4), g(4);
    f[0] = &#123; x1 - 1, y1 - 1, 1 &#125;, f[1] = &#123; x1 - 1, y2, mod - 1 &#125;, f[2] = &#123; x2, y1 - 1, mod - 1 &#125;, f[3] = &#123; x2, y2, 1 &#125;;
    g[0] = &#123; x5, y5, 1 &#125;, g[1] = &#123; x5, y6 + 1, mod - 1 &#125;, g[2] = &#123; x6 + 1, y5, mod - 1 &#125;, g[3] = &#123; x6 + 1, y6 + 1, 1 &#125;; 
    auto G = [&amp;](int x1, int y1, int x2, int y2) &#123;
        auto a(std::abs(x1 - x2)), b(std::abs(y1 - y2));
        return C(a + b, a);
    &#125;;
    auto res = 0ll;
    for (auto [x1, y1, k1] : f)
        for (auto [x2, y2, k2] : g) &#123;
            auto t(0ll);
            for (int x = x3; x &lt;= x4; ++x) &#123;
                (t += G(x1, y1, x, y4) * G(x, y4 + 1, x2, y2) % mod * (x + y4 + 1) % mod) %= mod;
                (t += mod - G(x1, y1, x, y3 - 1) * G(x, y3, x2, y2) % mod * (x + y3) % mod) %= mod;
            &#125;
            for (int y = y3; y &lt;= y4; ++y) &#123;
                (t += G(x1, y1, x4, y) * G(x4 + 1, y, x2, y2) % mod * (x4 + y + 1) % mod) %= mod;
                (t += mod - G(x1, y1, x3 - 1, y) * G(x3, y, x2, y2) % mod * (x3 + y) % mod) %= mod;
            &#125;
            // printf(&quot;(%d, %d, %d), (%d, %d, %d): %lld\n&quot;, x1, y1, k1, x2, y2, k2, t * k1 % mod * k2 % mod);
            (res += t * k1 % mod * k2 % mod) %= mod;
        &#125;
    std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;


不经过 \(y=x+c\) 的方案数
Catalan 数的一种推导方式是，在 \(n\times n\) 的网格上，要求不能越过 \(y=x\) 的方案数。可以用总方案数减去越过的方案数。
怎么计算非法的方案呢？越过 \(y=x\) 的路径必定存在一个点经过 \(y=x+1\)，原问题转化为不能碰到 \(y=x+1\) 的方案数。
把终点 \((n, n)\) 翻折到 \(y=x+1\) 上方，得到 \((n-1, n + 1)\)；对于任意到达 \((n-1,n+1)\) 的路径，一定会接触 \(y=x+1\) 至少一次；将第一次接触以后的路径翻折到 \(y=x+1\) 下方，则一定和原图中的非法路径一一对应。

就可以得到 \(C_{2n}^n-C_{2n}^{n-1}\)。
如果问题变得更加一般，求解到达 \((n, m)\) 不能碰到 \(y=x+c\) 的方案数，还是可以把 \((n,m)\) 翻折到 \((m-c,n+c)\)，答案是 \(C_{n+m}^n-C_{n+m}^{m-c}\)。

不经过 \(y=x-l\) 和 \(y=x+r\) 的方案数
现在有 \(y=x-l\) 和 \(y=x+r\) 两条线作为限制，现在的翻折意义就会有一点改变。

比如图中的 \(A&#39;\)，是 \(A\) 沿着 \(y=x-l\) 翻折一次后的结果。还是按照之前的方式来理解，那么走到 \(A&#39;\) 的路径代表至少经过一次 \(y=x-l\) 的方案。\(A&#39;&#39;\) 是 \(A&#39;\) 沿着 \(y=x+r\) 翻折一次之后得到的结果，走到 \(A&#39;&#39;\) 的路径就代表至少先碰到一次 \(y=x-l\)，再碰到一次 \(y=x+r\) 的方案数。
如果把相邻多次碰到 \(y=x-l\) 或 \(y=x+r\) 合并为一次，最终的非法路径就是 LRLRLR... 或者 RLRLRL... 的形式。因为可以计算的是「至少」的形式，用容斥原理得到，答案是 \(f_{\varnothing}-(f_{\texttt L} + f_{\texttt R}) + (f_{\texttt {LR}} + f_{\texttt {RL}}) - \cdots\)。对应计算每个翻折对应终点和答案就可以了。最后的答案是 \(C_{n+m}^n-C_{n+m}^{n+l}-C_{n+m}^{n + r}+C_{n+m}^{n+l-r}+C_{n+m}^{n+r-l}-\cdots\)，可以简化成 \(\sum\limits_{k\in \mathbb{Z}} C_{n+m}^{n-k\cdot (r-l)}-C_{n+m}^{n-k\cdot (r-l)+r}\)。

E - 骗我呢
https://www.luogu.com.cn/problem/P3266
每行内部递增，而且选项只有 \([0,m]\)，那么每行就会刚好在 \([0,m]\) 里面跳过一个数。
如果第 \(i\) 行跳过的数是 \(j\)，那么画一画图就可以发现第 \(i+1\) 可能跳过的数是 \([j-1,m]\)；反过来，第 \(i-1\) 行可能跳过的数就是 \([0,j+1]\)。
如果让 \(f_{i,j}\) 表示确定了第 \(1\to i\) 行，其中第 \(i\) 行跳过 \(j\) 的方案数，就可以得到 \(f_{i,j}=\sum\limits_{k=0}^{j+1} f_{i-1,k}\)。前缀和得到 \(f_{i,j}=f_{i,j-1}+f_{i-1,j+1}\)。注意边界：\(f_{0,j}=1\)；\(f_{i,0}=f_{i-1,0}+f_{i-1,1}\)；\(f_{i,m}=f_{i,m-1}\)。
为了得到答案，让 \(g_{i,j}\) 表示 \(i\times j\) 矩阵的方案数（这样就有机会通过手段优化了）：
\[
\begin{aligned}
g_{i,j}&amp;=\sum_{k=0}^j f_{i,k}\\
&amp;= f_{i-1,0}+f_{i-1,1}+\sum_{k=1}^j f_{i,k-1}+f_{i-1,k+1}\\
&amp;= g_{i,j-1}+g_{i-1,j+1}
\end{aligned}
\]
边界情况呢， \(g_{i, 0} = f_{i,0} = f_{i-1, 0} + f_{i - 1, 1} = g_{i-1,1}\)；\(g_{i,m}=g_{i, m - 1} + f_{i,m}=g_{i-1,m}+g_{i,m-1}\)。 \(g_{i,m+1}=g_{i,m}\) 避免边界。
那么在网格图上转移如下：

考虑将这个图形拉正，令 \((i+i,j)\gets g_{i,j}\) 得到：

问题就转化为，从 \((0, 0)\) 走到 \((m+n+1,n)\) 且不能触碰 \(y=x+1\) 和 \(y=x-m-2\) 两条直线的方案数。



不经过一般过原点直线的方案数

类型一：\((0,0)\to (n,m)\)，不经过 \(y=\dfrac mnx\) 的方案，其中要求 \((m,n)=1\)。
方案为 \(\dfrac {C_{n+m}^n}{n+m}\)。

]]></content>
      <tags>
        <tag>排列组合</tag>
        <tag>容斥原理</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>杂题选谈</title>
    <url>/20250421/</url>
    <content><![CDATA[


猫




A - T-shirt
https://codeforces.com/problemset/problem/183/D
如果知道一个衣服序列，怎么算出期望呢？

B - Two Melodies
https://codeforces.com/problemset/problem/813/D
如果设 \(f_{i,j}\) 表示第一个以 \(i\) 结尾，第二个以 \(j\) 结尾的方案数，就会有一个弊端——假设现在有 \(i&gt;j\)，又假设有 \(j&lt;j&#39;&lt;i\)，那么就不可以直接把 \(f_{i,j}\) 转移到 \(f_{i,j&#39;}\)，因为 \(j&#39;\) 可能已经被第一个选过了。但如果从 \(i\) 转移就没有这样的问题（不管 \(i&#39;\) 是比 \(j\) 大还是比 \(j\) 小）。
那就可以固定从较大的一维转移，也可以枚举所有情况。但是这样就会有一个问题，这是一个 \(n^3\) 的过程，而且对于不单调的内层 \(j\)，维护它的数值只能用带 \(\log\) 的数据结构优化，似乎不太过得了；但 \(i\) 却可以前缀优化。
其实，两个组是无序的，这意味着可以强制 \(i&gt;j\) 再从 \(i\) 转移；这个时候转移就和 \(j\) 没有太大的关系了，可以把 \(j\) 放到外层，对 \(i\) 前缀优化。可能需要注意边界的处理。

#include &lt;bits/stdc++.h&gt;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n, res = 0;
    std::cin &gt;&gt; n;
    std::vector&lt;int&gt; a(n + 1);
    for (int i = 1; i &lt;= n; ++i)
        std::cin &gt;&gt; a[i];
    std::vector&lt;std::vector&lt;int&gt; &gt; f(n + 1, std::vector&lt;int&gt; (n + 1));
    for (int j = 0; j &lt; n; ++j) &#123;
        std::vector&lt;int&gt; mx(100002), mmx(7);
        for (int i = 1; i &lt; j; ++i) &#123;
            mx[a[i]] = std::max(mx[a[i]], f[j][i]);
            mmx[a[i] % 7] = std::max(mmx[a[i] % 7], f[j][i]);
        &#125;
        for (int i = j + 1; i &lt;= n; ++i) &#123;
            f[i][j] = std::max(&#123; !!i + !!j, mx[a[i] - 1] + 1, mx[a[i] + 1] + 1, mmx[a[i] % 7] + 1, f[j][0] + 1 &#125;);
            mx[a[i]] = std::max(mx[a[i]], f[i][j]);
            mmx[a[i] % 7] = std::max(mmx[a[i] % 7], f[i][j]);
            // printf(&quot;f[%d][%d] = %d\n&quot;, i, j, f[i][j]);
            res = std::max(res, f[i][j]);
        &#125;
    &#125;
    std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;


CF633F The Chocolate Spree
https://codeforces.com/problemset/problem/633/F
树形 DP 求直径的时候，有一种方法是找到每个点下面的最大两条不交链。
这里也可以有类似的求法。假设答案出现在子树 \(u\) 中（下面的 \(v_i\) 都是 \(u\) 的直接儿子），可以讨论 \(u\) 参与构成两条路径的情况：

不参与构成任何一条路径，答案是 \(v_1,v_2\) 子树中的最长路径之和。
参与构成其中一条：

这一条与子树 \(v\) 完全相离，答案是 \(v\) 中最长路径，和 \(u\) 下面不经过 \(v\) 的最大两条不交链。
这一条有一支来自 \(v\) 子树，但和 \(v\) 中最长路径没有重合的点。答案是 \(u\) 的点权、\(u\) 下面不经过 \(v\) 的最大链、\(v\) 中一条路径（不经过 \(v\)）和 \(v\) 下面一条链之和的最大值；
这一条两支都来自 \(v\) 子树：有重合，不可能发生。

参与构成其中两条，答案是 \(u\) 下面最长的四条链：路径重复经过 \(u\)，不可能发生。


可以记录 \(u\) 下方最大的四条不交链、\(u\) 中选取一条不经过 \(u\) 的路径和 \(u\) 下方一条链之和的最大值、\(u\) 中最长路径求解。

#include &lt;bits/stdc++.h>
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(".in", "r", stdin);
    std::freopen(".out", "w", stdout);
#endif
    int n;
    std::cin >> n;
    std::vector&lt;int> a(n + 1);
    std::vector&lt;std::vector&lt;int> > g(n + 1);
    for (int i = 1; i > a[i];
    for (int i = 1, x, y; i < n; ++i) &#123;
        std::cin >> x >> y;
        g[x].push_back(y), g[y].push_back(x);
    &#125;
    auto res(0ll);
    std::vector&lt;long long> s(n + 1), w(n + 1);
    std::vector&lt;std::vector&lt;std::pair&lt;long long, int> > > f(n + 1, std::vector&lt;std::pair&lt;long long, int> > (4));
    std::function&lt;void(int, int)> DFS = [&](int x, int fa) &#123;
        f[x][0] = &#123; 0, x &#125;;
        w[x] = s[x] = a[x];
        for (auto i : g[x])
            if (i != fa) &#123;
                DFS(i, x);
                &#123;
                    if (f[i][0].first + a[i] > f[x][3].first)
                        f[x][3].first = f[i][0].first + a[i], f[x][3].second = i;
                    std::sort(f[x].begin(), f[x].end(), std::greater&lt;std::pair&lt;long long, int> > ());
                &#125;
                w[x] = std::max(w[x], w[i] + a[x]);
            &#125;
        auto mx(0ll);
        for (auto i : g[x])
            if (i != fa) &#123;
                s[x] = std::max(&#123; s[x], s[i], f[x][0].first + f[x][1].first + a[x] &#125;);
                w[x] = std::max(w[x], (f[x][0].second != i ? f[x][0] : f[x][1]).first + s[i] + a[x]);
                res = std::max(&#123; res,
                    mx + s[i], // 情况 1
                    (f[x][0].second == i ? f[x][1].first + f[x][2].first : (f[x][1].second == i ? f[x][0].first + f[x][2].first : f[x][0].first + f[x][1].first)) + s[i] + a[x], // 情况 2.1
                    (f[x][0].second == i ? f[x][1].first : f[x][0].first) + w[i] + a[x], // 情况 2.2
                &#125;);
                mx = std::max(mx, s[i]);
            &#125;
    //     printf("%d: res = %lld\n  f: \n", a[x], res);
    //     for (int i = 0; i < 4; ++i)
    //         printf("    [%d] %lld\n", f[x][i].second, f[x][i].first);
    //     printf("  s: %lld\n  w: %lld\n", s[x], w[x]);
    &#125;;
    DFS(1, -1);
    std::cout < res < '\n';
    return 0;
&#125;> n >> k;
    std::vector&lt;std::vector&lt;int> > g(n + 1);
    for (int i = 1, x, y; i < n; ++i) &#123;
        std::cin >> x >> y;
        g[x].push_back(y), g[y].push_back(x);
    &#125;
    int res = 0;
    if (k == 1) &#123;
        std::vector&lt;std::vector&lt;std::pair&lt;int, int> > > f(n + 1, std::vector&lt;std::pair&lt;int, int> > (2));
        std::function&lt;void(int, int)> DFS = [&](int x, int fa) &#123;
            f[x][0] = &#123; 0, x &#125;;
            for (auto i : g[x])
                if (i != fa) &#123;
                    DFS(i, x);
                    &#123;
                        if (f[i][0].first + 1 > f[x][1].first)
                            f[x][1].first = f[i][0].first + 1, f[x][1].second = i;
                        std::sort(f[x].begin(), f[x].end(), std::greater&lt;std::pair&lt;int, int> > ());
                    &#125;
                &#125;
            res = std::max(res, f[x][0].first + f[x][1].first);
        &#125;;
        DFS(1, -1);
        std::cout < 2 * n - res - 1 < '\n';
    &#125;
    else &#123;
        std::vector&lt;int> s(n + 1), w(n + 1);
        std::vector&lt;std::vector&lt;std::pair&lt;int, int> > > f(n + 1, std::vector&lt;std::pair&lt;int, int> > (4));
        std::function&lt;void(int, int)> DFS = [&](int x, int fa) &#123;
            f[x][0] = &#123; 0, x &#125;;
            for (auto i : g[x])
                if (i != fa) &#123;
                    DFS(i, x);
                    &#123;
                        if (f[i][0].first + 1 > f[x][3].first)
                            f[x][3].first = f[i][0].first + 1, f[x][3].second = i;
                        std::sort(f[x].begin(), f[x].end(), std::greater&lt;std::pair&lt;int, int> > ());
                    &#125;
                    w[x] = std::max(w[x], w[i] + 1);
                &#125;
            &#123;
                int t = 0;
                for (auto [v, id] : f[x])
                    t += v;
                res = std::max(res, t); // 情况 3
                w[x] = std::max(w[x], t - f[x][3].first); // 路径可经过 u
            &#125;
            int mx = 0;
            for (auto i : g[x])
                if (i != fa) &#123;
                    s[x] = std::max(&#123; s[x], s[i], f[x][0].first + f[x][1].first &#125;);
                    w[x] = std::max(w[x], (f[x][0].second != i ? f[x][0] : f[x][1]).first + std::max(s[i], f[i][0].first + 1));
                    res = std::max(&#123; res,
                        mx + s[i], // 情况 1
                        (f[x][0].second == i ? f[x][1].first + f[x][2].first : (f[x][1].second == i ? f[x][0].first + f[x][2].first : f[x][0].first + f[x][1].first)) + s[i], // 情况 2.1
                        (f[x][0].second == i ? f[x][1].first : f[x][0].first) + w[i] + 1, // 情况 2.2
                    &#125;);
                    mx = std::max(mx, s[i]);
                &#125;
        &#125;;
        DFS(1, -1);
        std::cout < 2 * (n + 1) - res - 2 < '\n';
    &#125;
    return 0;
&#125;]]></content>
      <tags>
        <tag>DP</tag>
        <tag>贪心</tag>
        <tag>均摊</tag>
      </tags>
  </entry>
  <entry>
    <title>杂题选谈：连通图计数</title>
    <url>/20250430/</url>
    <content><![CDATA[


猫



太可怕了！2025 年才过去 4 个月，正经文章的总数已经和 2024 年中正经文章的总数一样多了。

有标号无向图计数
问题模型大概如下：

给定 \(N\) 个点，你可以在它们间任意连边，但存在限制：

其中一个较好处理（如要求图必须是二分图）；
另一个较难处理（如去重问题等）；
最后，可能要求图连通。


首先需要知道怎么处理这样的计数问题。以下皆建立在无重边、自环的基础上。

先只考虑容易的限制，且不要求连通：
注：如果发现 不连通 的时候没办法很方便地计算精确方案数（也就是说会算重），那么可以把 去重 作为较难的限制，这一步算重就不重要了。
该怎么求怎么求。例如，若该限制是二分图且可以算重，枚举左部点数及边，那么方案数就是 \(\sum\limits_{i=0}^n C_n^i\cdot C_{i\cdot (n-i)}^m\)。
这个时候需要注意到算重部分的意义是什么。比如此处，计算中一个连通块将左右部翻转后被视作不同的子图，但在全局看来对应的总图是同一个二分图。因此，对于拥有 \(k\) 个连通块的图，其被计算了 \(2^k\) 次。
再加上必须连通的限制，仍只考虑容易的限制：
如果不存在其他限制，那么就是 A001187。
连通的方案就是任意的方案减去不连通的方案。

任意的求法就是第一点；
不连通的方案，枚举 \(1\) 所在子集，让其补集里面任意连边（第 1 点的子问题）且不和 \(1\) 所在子集相连。

接着，对连通的情况应用较难处理的限制：
因为连通会带来一些比较好的性质简化运算，所以选择在这一步加上较难的限制。
例如，对于上文中二分图去重的例子，连通图中显然只有一个连通块，将连通图的方案 \(\div 2\) 就可以得到答案。
最后，如果题目要求任意图的方案，用第三步中的答案再次算出任意图的答案。
相当于是把第 2 点中的过程反过来，枚举 \(1\) 所在子集，在其补集中任意连边（该问的子问题）且可以和 \(1\) 所在的子集连边。

这样就可以解决问题。

A - Many Good Tuple Problems
https://atcoder.jp/contests/abc327/tasks/abc327_g
如果把一组 \((S_i,T_i)\) 看作一条边的话，原限制就可以转化为：在 \(N\) 个点中连 \(M\) 条可重边，形成二分图的方案数。边有序。
你可以发现我偷懒把这道题拿去上面举例了，由于边是可重的，而我们的模型要求无重边，但发现这个限制是独立于模型外的，也就是可以在最后枚举有多少条不同边，再用一点组合手段计算实际贡献。
首先令 \(f_{0,n,m}\) 表示 \(n\) 个点、\(m\) 条边、不去重、连通性任意 的方案数，那么 \(f_{0,n,m}=\sum_{i=0}^n C_n^i\cdot C_{i\cdot (n-i)}^m\)。
令 \(f_{1,n,m}\) 表示 不去重、要求 连通 的方案，那么有 \(f_{1,n,m}=f_{0,n,m}-\sum\limits_{i,j} C_{n - 1}^{i-1}\cdot f_{1,i,j}\cdot f_{0,n-i,m-j}\)。
令 \(f_{2,n,m}\) 表示 去重，要求 连通 的方案，那么有 \(f_{2,n,m}=\dfrac {f_{1,n,m}}{2}\)。
令 \(f_{3,n,m}\) 表示 去重，连通性任意 的方案数，那么有 \(f_{3,n,m}=\sum\limits_{i,j} C_{n-1}^{i-1} \cdot f_{2,i,j} \cdot f_{3,n-i,m-j}\)。
最后的方案数为 \(\sum\limits_{j} f_{3,n,j}\cdot F(m,j)\)。其中 \(F(m,j)\) 表示把 \(m\) 个有标号的球放在 \(j\) 个有标号的盒子里，不空放的方案数，可以容斥。最后注意边反向算两种，所以乘上 \(2^m\)。
复杂度 \(O(n^6)\)。

#include &lt;bits/stdc++.h&gt;
const int mod = 998244353;
const int inv2 = (mod + 1) &gt;&gt; 1;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n, M, m;
    std::cin &gt;&gt; n &gt;&gt; M, m = std::min(n * (n - 1) / 2, M);
    std::vector&lt;std::vector&lt;long long&gt; &gt; C(n * n + 1, std::vector&lt;long long&gt; (n * n + 1));
    for (int i = 0; i &lt;= n * n; ++i) &#123;
        C[i][0] = 1ll;
        for (int j = 1; j &lt;= i; ++j)
            C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % mod;
    &#125;
    std::vector&lt;std::vector&lt;std::vector&lt;long long&gt; &gt; &gt; f(4, std::vector&lt;std::vector&lt;long long&gt; &gt; (n + 1, std::vector&lt;long long&gt; (m + 1)));
    for (int i = 1; i &lt;= n; ++i)
        for (int j = 0; j &lt;= m &amp;&amp; j &lt;= i * (i - 1) / 2; ++j)
            for (int k = 0; k &lt;= i; ++k)
                (f[0][i][j] += C[i][k] * C[k * (i - k)][j]) %= mod;
    for (int i = 1; i &lt;= n; ++i)
        for (int j = 0; j &lt;= m; ++j) &#123;
            auto t(0ll);
            for (int k = 1; k &lt;= i; ++k)
                for (int l = 0; l &lt;= j; ++l)
                    (t += C[i - 1][k - 1] * f[1][k][l] % mod * f[0][i - k][j - l]) %= mod;
            f[1][i][j] = (f[0][i][j] + mod - t) % mod;
            f[2][i][j] = f[1][i][j] * inv2 % mod;
        &#125;
    f[3][0][0] = 1ll;
    for (int i = 1; i &lt;= n; ++i)
        for (int j = 0; j &lt;= m; ++j)
            for (int k = 1; k &lt;= i; ++k)
                for (int l = 0; l &lt;= j; ++l)
                    (f[3][i][j] += C[i - 1][k - 1] * f[2][k][l] % mod * f[3][i - k][j - l]) %= mod;
    auto qkp = [](long long x, int y) &#123;
        auto res(1ll);
        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)
            if (y &amp; 1)
                (res *= x) %= mod;
        return res;
    &#125;;
    std::vector&lt;long long&gt; F(m + 1);
    for (int i = 1; i &lt;= m; ++i) &#123;
        F[i] = qkp(i, M);
        for (int j = 1, p = mod - 1; j &lt; m; ++j, p = mod - p)
            (F[i] += p * C[i][j] % mod * qkp(i - j, M)) %= mod;
    &#125;
    auto res(0ll);
    for (int j = 1; j &lt;= m; ++j)
        (res += f[3][n][j] * F[j]) %= mod;
    std::cout &lt;&lt; res * qkp(2, M) % mod &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;


B - Many MST
https://atcoder.jp/contests/abc386/tasks/abc386_g
这里需要注意到 MST 和连通块的隐含联系。按照 Kruskal 的生成方式可以发现只需要在合并两个连通块时加上它们之间连边中最小的边权就可以得到 MST。
因此容易想到在 DP 时对最小边权进行限制；枚举 \(k\)，让边权 \(\le k\) 成为简单限制；让求解 MST 成为某种意义上的较难限制。
令 \(f_{0,n,k}\) 表示 \(n\) 个点，边权 \(\le k\)、对连通性没有要求 的方案数；相应地，\(f_{1,n,k}\) 表示 要求连通 的方案数，则：

\(f_{0,n,k}=\sum\limits_i C_{n-1}^{i-1}\cdot f_{1,i,k-1} \cdot f_{0,n-i,k}\cdot (M-k+1)^{i\times(n-i)}\)。
注解：式子正确性建立在 \(1\) 所在 的由权值 \(&lt;k\) 的边构成的最大连通块 大小为 \(i\) 的基础之上，故两个连通块之间的边权只能 \(\ge k\)。这也提醒我们，此处的 不连通 含义实际上是给这些边一个 \((M-k)\) 的系数。
那么这样你会注意到，\(f_0\) 的意义就与 \(k\) 无关了（那么显然值也与 \(k\) 无关），但是仍然保留 \(k\) 对思考有帮助，故留之。
\(f_{1,n,k}=f_{0, n, k} - \sum\limits_i C_{n - 1}^{i-1} \cdot f_{1,i,k}\cdot f_{0,n-i,k}\times (M-k)^{i\times (n - i)}\)。

令 \(g_{0, n, k}\) 表示 \(n\) 个点、边权 \(\le k\)、对连通性没有要求 的 MST 之和；相应地，\(g_{1,n,k}\) 表示对应条件下 要求连通 的 MST 之和。则：

\(g_{0,n,k}=\sum\limits_{i} C_{n-1}^{i-1}\cdot (f_{1,i,k - 1}\cdot g_{0,n-i,k}+g_{1,i,k - 1} \cdot f_{0,n-i,k}+f_{1,i,k-1}\cdot f_{0,n-i,k}\cdot k)\cdot (M-k+1)^{i\times (n-i)}\)。
注解：类比 \(f_0\) 的计算方式得到 \(g_0\)。在 \(i\times (n-i)\) 中任选一条作为 MST 上权值为 \(k\) 的边，故有 \(f_{1,i,k-1}\cdot f_{0,n-i,k}\cdot k\)。之所以必须要求有这么一条边是为了和 \(g_{k-1}\) 和 \(g_{k+1}\) 等区分。
\(g_{1,n,k}=g_{0,n,k}-\sum\limits_i C_{n-1}^{i-1}\cdot (f_{1,i,k}\cdot g_{0,n-i,k}+g_{1,i,k}\cdot f_{0,n-i,k}+f_{1,i,k}\cdot f_{0,n-i,k}\cdot k)\cdot (M-k)^{i\times (n-i)}\)。

复杂度 \(O(n^2\cdot M)\)。要求预处理幂，不然会 T。以及可能需要把 \(f_0,f_1,g_0,g_1\) 放在同一个内层循环求，不然会卡常；在此基础上使用内存连续访问优化似乎并不明显 

#include &lt;bits/stdc++.h&gt;
const int mod = 998244353;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int N, M;
    std::cin &gt;&gt; N &gt;&gt; M;
    using arr = std::vector&lt;long long&gt;;
    using brr = std::vector&lt;arr&gt;;
    using crr = std::vector&lt;brr&gt;;
    crr f(2, brr(N + 1, arr(M + 1))), g(2, brr(N + 1, arr(M + 1)));
    brr C(N + 1, arr(N + 1)), p(M + 1, arr(N * N + 1));
    for (int i = 0; i &lt;= M; ++i) &#123;
        p[i][0] = 1ll;
        for (int j = 1; j &lt;= N * N; ++j)
            p[i][j] = p[i][j - 1] * i % mod;
    &#125;
    for (int i = 0; i &lt;= N; ++i) &#123;
        C[i][0] = 1ll;
        for (int j = 1; j &lt;= i; ++j)
            C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % mod;
    &#125;
    f[1][0][0] = f[1][1][0] = 1ll;
    for (int n = 1; n &lt;= N; ++n)
        for (int k = 1; k &lt;= M; ++k) &#123;
            f[0][n][k] = f[1][n][k - 1];
            for (int i = 1; i &lt; n; ++i) &#123;
                (f[0][n][k] += C[n - 1][i - 1] * f[1][i][k - 1] % mod * f[0][n - i][k] % mod * p[M - k + 1][i * (n - i)]) %= mod;
                (f[1][n][k] += mod - C[n - 1][i - 1] * f[1][i][k] % mod * f[0][n - i][k] % mod * p[M - k][i * (n - i)] % mod) %= mod;
            &#125;
            (f[1][n][k] += f[0][n][k]) %= mod;
        &#125;
    for (int n = 1; n &lt;= N; ++n)
        for (int k = 1; k &lt;= M; ++k) &#123;
            g[0][n][k] = g[1][n][k - 1];
            for (int i = 1; i &lt; n; ++i) &#123;
                (g[0][n][k] += (f[1][i][k - 1] * g[0][n - i][k] % mod + g[1][i][k - 1] * f[0][n - i][k] % mod + f[1][i][k - 1] * f[0][n - i][k] % mod * k) % mod * C[n - 1][i - 1] % mod * p[M - k + 1][i * (n - i)]) %= mod;
                (g[1][n][k] += mod - (f[1][i][k] * g[0][n - i][k] % mod + g[1][i][k] * f[0][n - i][k] % mod + f[1][i][k] * f[0][n - i][k] % mod * k) % mod * C[n - 1][i - 1] % mod * p[M - k][i * (n - i)] % mod) %= mod;
            &#125;
            (g[1][n][k] += g[0][n][k]) %= mod;
        &#125;
    // for (int n = 1; n &lt;= N; ++n)
    //     for (int k = 1; k &lt;= M; ++k) &#123;
    //         printf(&quot;f[0][%d][%d] = %lld\n&quot;, n, k, f[0][n][k]);
    //         printf(&quot;f[1][%d][%d] = %lld\n&quot;, n, k, f[1][n][k]);
    //         printf(&quot;g[0][%d][%d] = %lld\n&quot;, n, k, g[0][n][k]);
    //         printf(&quot;g[1][%d][%d] = %lld\n&quot;, n, k, g[1][n][k]);
    //     &#125;
    std::cout &lt;&lt; g[1][N][M] &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;


有标号 DAG 计数

给定 \(N\) 个点，你可以在它们间任意连边，要求最后图为 DAG，可能要求图弱连通。

如果说无向图计数关键在于连通块，那么 DAG 在此基础上关键在于入度为 \(0\) 的点集。
令 \(f(i)\) 表示 \(i\) 个点的 DAG 的答案；\(g_{0, i,j}\) 表示 \(i\) 个点的 DAG，其中 \(j\) 个入度为 \(0\) 的方案，不难想到容斥：令 \(g_{1,i,j}\) 表示至少 \(j\) 个的方案，那么：
\[
g_{1,i,j}=C_i^j\times f(i-j)\times 2^{j\times (i-j)}\\
g_{0,i,j}=\sum_{k=j}^i (-1)^{k-j}\cdot C_k^j\cdot g_{1,i,j}\\
f(i)=\sum_{j=1}^i g_{0,i,j}
\]
整理有：
\[
\begin{aligned}
f(i)
&amp;=\sum_{j=1}^i \sum_{k=j}^i (-1)^{k-j}\cdot C_k^j\cdot g_{1,i,k}\\
&amp;=\sum_{k=1}^i (-1)^k\cdot g_{1,i,k}\cdot \sum_{j=1}^k (-1)^j\cdot C_k^j\\
&amp;=\sum_{k=1}^i (-1)^k\cdot g_{1,i,k}\cdot (0^k-1)\\
&amp;=\sum_{k=1}^i (-1)^{k+1}\cdot C_i^k\times f(i-k)\times 2^{(i-k)}
\end{aligned}
\]
即得递推式。如果要求连通仿照无向图连通的方法，用任意减去不连通即可。

C - Amusement Park
https://codeforces.com/problemset/problem/1193/A
先考虑计算方案数。枚举 \(1\) 所在子集，那么有 \(f(S)=\sum\limits_{T\in S} (-1)^{|T|+1}\cdot f(S - T)\)。相较于一般的 DAG 计数，因为每条边取不取是固定的，所以没有了 \(2\) 的次幂的系数；同时因为直接枚举子集，所以没有了组合系数。
注意此处 \(T\) 可构成一轮新的入度为 \(0\) 的点集当且仅当 \(T\) 之内没有连边，即 \(T\) 为独立集。
算出方案数后如何算答案呢？发现对于一种合法的方案，把里面所有的边反向一定唯一对应另一种合法方案，两种方案取反边数相加为 \(m\)；那么给所有方案除以 \(2\)，再乘上 \(m\) 就能得到答案。
复杂度 \(O(3^n)\)。需要提前把每个点集是否独立预处理下来。

#include &lt;bits/stdc++.h&gt;
const int mod = 998244353, inv2 = (mod + 1) &gt;&gt; 1;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n, m;
    std::cin &gt;&gt; n &gt;&gt; m;
    std::vector&lt;int&gt; g(n + 1);
    for (int i = 1, x, y; i &lt;= m; ++i) &#123;
        std::cin &gt;&gt; x &gt;&gt; y;
        g[x] |= (1 &lt;&lt; (y - 1));
        g[y] |= (1 &lt;&lt; (x - 1));
    &#125;
    auto check = [&amp;](int s) &#123;
        for (int i = 1; i &lt;= n; ++i)
            if ((s &gt;&gt; (i - 1)) &amp; 1)
                if (s &amp; g[i])
                    return false;
        return true;
    &#125;;
    int siz = 1 &lt;&lt; n;
    std::vector&lt;int&gt; tag(siz);
    for (int i = 0; i &lt; siz; ++i)
        tag[i] = check(i);
    std::vector&lt;long long&gt; f(siz);
    f[0] = 1ll;
    for (int i = 1; i &lt; siz; ++i)
        for (int j = i; j; j = (j - 1) &amp; i)
            if (tag[j])
                (f[i] += ((__builtin_popcount(j) &amp; 1) ? 1 : mod - 1) * f[i ^ j]) %= mod;
    std::cout &lt;&lt; f[siz - 1] * inv2 % mod * m % mod &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;


D - Balance Scale
https://atcoder.jp/contests/abc306/tasks/abc306_h
可以发现，如果将被 = 连起来的点缩起来，就可以转化成上一个问题。但枚举被缩的点集显然是不能通过的，这里介绍一种方法。
不把缩点放在开头。在上一题中的 DP 式子 \(f(S)=\sum\limits_{T\in S} (-1)^{|T|+1}\cdot f(S - T)\) 中，考虑和我们最终的答案有什么差异：

在现在的问题中，有的边是可以不选的！考虑这会给容斥带来怎样的影响。

首先应该知道一件事情：你决定把一部分点缩到一起，当且仅当它们全部由 = 连接。要让一些边加入 DP，也就是让它们不是 =，当且仅当它们成为连通块的『割』——把连通块分成多个连通块。这种情况显然已经由另一条路径转移过了。也就是说，就用这个式子可以得到所有答案。 1. 另一个问题，在上一题中，我们可以轻易地判断 \(T\) 是否为独立集；但在本问中，不是独立集的点集也可能缩点成为独立集。
发现有一种唯一方法，就是使 \(T\) 中位于同一连通块的点缩到一起；所以应该将 \(-1\) 的次数替换为 \(T\) 所在连通块个数 \(+1\)。
注意这里说的连通块是 \(T\) 的导出子图中的连通块。
这也启示我们不要把缩点和图的连通性等等关联得太死，需要把点等价的场景都可能用到缩点。

#include &lt;bits/stdc++.h&gt;
const int mod = 998244353, inv2 = (mod + 1) &gt;&gt; 1;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n, m;
    std::cin &gt;&gt; n &gt;&gt; m;
    std::vector&lt;int&gt; fa(n + 1);
    std::function&lt;int(int)&gt; find = [&amp;](int x) &#123;
        return fa[x] == x ? x : fa[x] = find(fa[x]);
    &#125;;
    auto merge = [&amp;](int x, int y) &#123;
        fa[find(x)] = find(y);
        return;
    &#125;;
    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);
    for (int x, y; m--; ) &#123;
        std::cin &gt;&gt; x &gt;&gt; y;
        g[x].push_back(y), g[y].push_back(x);
    &#125;
    int siz = 1 &lt;&lt; n;
    std::vector&lt;int&gt; cnt(siz);
    for (int i = 0; i &lt; siz; ++i) &#123;
        std::iota(fa.begin(), fa.end(), 0);
        std::vector&lt;int&gt; tag(n + 1);
        for (int j = 1; j &lt;= n; ++j)
            if ((i &gt;&gt; (j - 1)) &amp; 1)
                for (auto k : g[j])
                    if ((i &gt;&gt; (k - 1)) &amp; 1)
                        merge(k, j);
        for (int j = 1; j &lt;= n; ++j)
            if ((i &gt;&gt; (j - 1)) &amp; 1)
                cnt[i] += (fa[j] == j);
    &#125;
    std::vector&lt;long long&gt; f(siz);
    f[0] = 1ll;
    for (int i = 1; i &lt; siz; ++i)
        for (int j = i; j; j = (j - 1) &amp; i)
            if (cnt[j])
                (f[i] += ((cnt[j] &amp; 1) ? 1 : mod - 1) * f[i ^ j]) %= mod;
    std::cout &lt;&lt; f[siz - 1] &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;


E - 主旋律
https://www.luogu.com.cn/problem/P11714
即，给定一个有向图，问边集有多少个子集是强连通的。
再次涉及到了连通性问题，但在这里需要结合 SCC 缩点来考虑。容易发现强连通即缩出来是一个点；故需要关注缩出来的点数。
令 \(f(S)\) 表示 \(S\) 的导出子图内合法边子集的数量，\(g(S)\) 表示 \(S\) 的导出子图中非法边子集的数量；\(h(S,k)\) 表示 \(S\) 的导出子图中边的子集缩出来有 \(k\) 个点的数量， 令 \(E(S_1, S_2)\) 表示从 \(S_1\) 指向 \(S_2\) 的边数，则：
\[
f(S) = 2^{E(S,S)}-g(S)\\
g(S)=\sum_{T \subseteq S}2^{E(T, S - T)}\cdot 2^{E(T, T)}\cdot \sum_{k=1+[T=\varnothing]} (-1)^{k+1}\cdot h(S - T, k)\\
h(S, k) = \sum_{T\subset S} f(T) \cdot h(S - T, k-1)
\]
注意为什么要用一个 \(h\) 来转移 \(g\) 呢？我们发现 \(-1\) 的次数和缩出来的点数是有关的，而光凭 \(g\) 无法表示点数信息，所以需要用 \(h\) 来搭个桥。
直接 DP，复杂度 \(O(n\cdot 3^n)\)。
]]></content>
      <tags>
        <tag>计数</tag>
      </tags>
  </entry>
  <entry>
    <title>杂题选谈</title>
    <url>/20250510/</url>
    <content><![CDATA[啊啊。小封条。


A - Pass to Next
https://atcoder.jp/contests/arc124/tasks/arc124_e
感觉其他一些题解讲得不是特别清楚，这里参考了 XJX 的文章。
要求的答案是 \(\prod a&#39;_i\)，发现运算是乘法，比较怪；由此考虑转化为方案数，也就是假设每个人有 \(a&#39;_i\) 个互不相同的球，每个人在其中选出恰好一个的方案数。
考虑 DP。发现每个人手上的球分为『自己的』和『左边的人传过来的』两种类型；显然第二种会有来自上一个人的限制，考虑把第二种在上一个人就完成求解。具体地，设 \(f_{i,0}\) 表示第 \(i\) 个人选取自己的球，但只记录 \(1\sim i-1\) 的方案；\(f_{i,1}\) 表示第 \(i\) 个人选取第 \(i-1\) 个人的球，并记入答案的方案。你可能需要注意到：最后一个被记入方案的球来自第 \(i-1\) 个人。
但这样会有个小问题。我们让所有人多往右边传一个球，那么在我们的这种分割方法看来是不一样的局面；但实际上它们是等价的。从每个人传出了多少个球（设为 \(x_i\)）的角度来看，对于 \(\min\{x_n\}\ne 0\)，只需要不断执行 \(\forall\, x_i\gets x_i-1\) 就可以在局面不变的情况下使 \(\min\{x_n\}\ne 0\)。这是在说，可以让 \(\min\{x_n\}\ne 0\) 的方案和终局一一对应。
发现可以容斥：钦定 \(x_i\ge 1\)，也就是每个人必须往右传至少一个，相似地算一遍就能得到非法方案。
考虑转移，令 \(x_i\) 可选最小值为 \(l\)，有：

\(f_{i+1,0}\gets f_{i,0}\)：将第 \(i\) 个人未被记入的自己的球记入，球数可能为 \([0,a_i-l]\)。等差数列求和即可。
\(f_{i+1,0}\gets f_{i,1}\)：没有球需要被记入，但是这种情况对应多种 \(x_i\)。具体地，\(x_i\in [l,a_i]\)。共有 \(a_i-l+1\) 种方案。
\(f_{i+1,1}\gets f_{i,0}\)：将第 \(i\) 个人的 \(a_i\) 个球分给 \(i\) 和 \(i+1\)。共有 \(x_i\cdot (a_i-x_i)\) 种可能，也就是 \(\left(a_i\cdot \sum_{x_i=l}^{a_i} x_i\right)-\left(\sum_{x_i=l}^{a_i}{x_i}^2\right)\) 种方案。
\(f_{i+1,1}\gets f_{i,1}\)：将第 \(i+1\) 个人得到的第 \(i\) 个人的球记入，同第一条。

破环为链，分别钦定第一个人是用自己的球还是上一个人的球来解决问题（必须对于两种可能性分开计算；否则就不知道答案应该取 \(f_{n,0}\) 还是 \(f_{n,1}\)）。

#include &lt;bits/stdc++.h&gt;
const int mod = 998244353, inv2 = (mod + 1) &gt;&gt; 1, inv6 = 166374059;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n;
    std::cin &gt;&gt; n;
    std::vector&lt;long long&gt; a(n);
    for (int i = 1; i &lt;= n; ++i)
        std::cin &gt;&gt; a[i % n];
    auto sum = [&amp;](long long r) &#123;
        return r * (r + 1) % mod * inv2 % mod;
    &#125;;
    auto sum2 = [&amp;](long long r) &#123;
        return r * (r + 1) % mod * (2 * r % mod + 1) % mod * inv6 % mod;
    &#125;;
    std::vector&lt;std::vector&lt;long long&gt; &gt; f0(n, std::vector&lt;long long&gt; (2)), f1(n, std::vector&lt;long long&gt; (2));
    auto calc = [&amp;](long long l, std::vector&lt;std::vector&lt;long long&gt; &gt; &amp;f) &#123;
        f[0][0] = 1ll;
        for (int i = 0; i &lt; n; ++i) &#123;
            int j = (i + 1) % n;
            f[j][0] = f[i][0] * sum(a[i] - l) % mod;
            (f[j][0] += f[i][1] * (a[i] - l + 1)) %= mod;
            f[j][1] = f[i][0] * (a[i] * sum(a[i]) % mod - sum2(a[i])) % mod;
            (f[j][1] += f[i][1] * sum(a[i]) % mod) %= mod;
            // printf(&quot;0, l = %lld, f[%d]: %lld / %lld\n&quot;, l, j, f[j][0], f[j][1]);
        &#125;
        auto res(f[0][0]);
        f.assign(n, std::vector&lt;long long&gt; (2));
        f[0][1] = 1ll;
        for (int i = 0; i &lt; n; ++i) &#123;
            int j = (i + 1) % n;
            f[j][0] = f[i][0] * sum(a[i] - l) % mod;
            (f[j][0] += f[i][1] * (a[i] - l + 1)) %= mod;
            f[j][1] = f[i][0] * (a[i] * sum(a[i]) % mod - sum2(a[i])) % mod;
            (f[j][1] += f[i][1] * sum(a[i]) % mod) %= mod;
            // printf(&quot;1, l = %lld, f[%d]: %lld / %lld\n&quot;, l, j, f[j][0], f[j][1]);
        &#125;
        return (res + f[0][1]) % mod;
    &#125;;
    std::cout &lt;&lt; (calc(0, f0) + mod - calc(1, f1)) % mod &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;


B - 绿宝石之岛
https://loj.ac/p/6406
因为只关心最终状态，原题可以转化为：将 \(d\) 分成 \(n\) 个非负整数，前 \(r\) 大数之和的期望（当然你需要加上初始的 \(r\) 个）。
关于非负整数拆分：设 \(f_{i,j}\) 表示将 \(i\) 分成 \(j\) 个 非负整数 的方案，钦定其中恰有 \(k\) 个 正整数 进行转移，给这 \(k\) 个数先分一个 \(1\)，则 \(f_{i,j}=\sum\limits_{k=0}^{\min(i,j)} C_j^k\cdot f_{i-k,k}\)。
再设 \(g_{i,j}\) 表示将 \(i\) 分成 \(j\) 个非负整数的所有方案中、前 \(r\) 大的数之和。类似地，有 \(g_{i,j}=\sum\limits_{k=0}^{\min(i,j)} C_j^k\cdot (g_{i-k,k}+\min(k,r)\cdot f_{i-k,k})\)。其中，\(\min(k,r)\) 的来源是，只有 \(k\) 个数有值，前 \(r\) 大的数一定在这 \(k\) 个数里面。
答案为 \(\dfrac {g_{d,n}}{f_{d,n}}+r\)，复杂度 \(O(n^3)\)。

#include &lt;bits/stdc++.h&gt;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n, d, r;
    std::cin &gt;&gt; n &gt;&gt; d &gt;&gt; r;
    using arr = std::vector&lt;double&gt;;
    std::vector&lt;arr&gt; f(d + 1, arr(n + 1)), g(d + 1, arr(n + 1)), C(n + 1, arr(n + 1));
    for (int i = 0; i &lt;= n; ++i) &#123;
        C[i][0] = 1.;
        for (int j = 1; j &lt;= i; ++j)
            C[i][j] = C[i - 1][j - 1] + C[i - 1][j];
    &#125;
    f[0].assign(n + 1, 1.);
    for (int i = 1; i &lt;= d; ++i)
        for (int j = 1; j &lt;= n; ++j) &#123;
            for (int k = 1; k &lt;= i &amp;&amp; k &lt;= j; ++k) &#123;
                f[i][j] += C[j][k] * f[i - k][k];
                g[i][j] += C[j][k] * (g[i - k][k] + std::min(k, r) * f[i - k][k]);
                // printf(&quot;  k = %d, %.0lf + %.0lf\n&quot;, k, C[j][k] * g[i - k][k], std::min(k, r) * f[i - k][k]);
            &#125;
            // printf(&quot;f[%d][%d] = %.0lf, g[%d][%d] = %.0lf\n&quot;, i, j, f[i][j], i, j, g[i][j]);
        &#125;
    std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(8) &lt;&lt; g[d][n] / f[d][n] + r &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;


C - Uddered but not Herd G
https://www.luogu.com.cn/problem/P7296
给每个字母分配一个标号 \(x\)，那么最小段数就是 \(\sum \left[x_i\ge x_{i+1}\right]\)。
考虑状压完成映射操作，令 \(f_{s}\) 表示给标号 \(1\sim |s|\) 分配字母后，占用字符集 \(s\) 的方案数，那么就能 \(O(1)\) 得到贡献——只需预处理出 \(f_{c, s}\) 表示分配到字母 \(c\) 时，已经先给 \(s\) 中字母分配了更小标号时的贡献。
注意字符集大小只有 \(20\)，可以 \(O(|S|\cdot 2^{|S|})\) 解决问题，注意到预处理的内容是类高维前缀最值的形式，可以递推降低复杂度。

#include &lt;bits/stdc++.h>
const int inf = 0x3f3f3f3f;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(".in", "r", stdin);
    std::freopen(".out", "w", stdout);
#endif
    int n;
    std::string t;
    std::cin >> t, n = (int)t.length(), t = "#" + t;
    std::vector&lt;int> a, tag(26, -1), s(n + 1);
    for (int i = 1; i &lt;= n; ++i) &#123;
        if (tag[t[i] - 'a'] == -1)
            tag[t[i] - 'a'] = (int)a.size(), a.push_back(t[i] - 'a');
        s[i] = tag[t[i] - 'a'];
    &#125;
    int m = (int)a.size(), siz = 1 &lt;&lt; m;
    std::vector&lt;std::vector&lt;int> > cnt(m, std::vector&lt;int> (m));
    for (int i = 1; i &lt; n; ++i)
        ++cnt[s[i]][s[i + 1]];
    std::vector&lt;std::vector&lt;int> > g(m, std::vector&lt;int> (siz));
    for (int i = 0; i &lt; m; ++i)
        for (int k = 0; k &lt; m; ++k) // 注意这里相当于是钦定从 k 处转移
            for (int j = (1 &lt;&lt; k); j &lt; (2 &lt;&lt; k); ++j) // 枚举的是 k 位为 1 的所有数；这两层循环的复杂度为 O(siz)
                g[i][j] = g[i][j ^ (1 &lt;&lt; k)] + cnt[i][k]; // 目的是此处的内存连续访问优化，把 ^ 看作 - 应该就能理解为什么第二维是连续的
    std::vector&lt;int> f(siz, inf);
    f[0] = 1;
    for (int i = 1; i &lt; siz; ++i)
        for (int j = 0; j &lt; m; ++j)
            if ((i >> j) & 1)
                f[i] = std::min(f[i], f[i ^ (1 &lt;&lt; j)] + g[j][i]);
    std::cout &lt;&lt; f[siz - 1] &lt;&lt; '\n';
    return 0;
&#125;


D - Min Max Subarrays P
https://www.luogu.com.cn/problem/P11845
先考虑 \(01\) 序列的答案：如果序列中存在相邻的 \(2\) 个 \(1\)，总能保证最后的一个是 \(1\)。
如果序列中存在 \(\ge 3\) 个 \(1\)，可以牺牲其中的一些使得 \(2\) 个 \(1\) 相邻。
当序列中只有 \(2\) 个 \(1\) 时，只有因为剩下的 \(0\) 不太够，导致我们无法随意『上下其手』时不能将 \(2\) 个 \(1\) 挪到一起。
令两个 \(1\) 为序列最大值与次大值，暴搜处理序列长度较小的情况，剩下的直接用奇偶性判断两个 \(1\) 取哪个。

A - MST on Line++
https://atcoder.jp/contests/arc167/tasks/arc167_c
相当于把 \(a\) 打乱然后处理原问题。考虑每个 \(a_i\) 的贡献次数。模拟 Kruskal 连边，从小到大把点 \(a_i\) 加入图，\(a_i\) 可以向 \(a_{[i-K,i+K]}\) 内所有连通块连边。
连通块数量当且仅当 \([i-K,i)\) 内最靠右的点和 \((i, i+K]\) 内最靠左的点距离 \(&gt;K\) 时为 \(2\)，其余情况为 \(1\)。
但要是从这个角度想这个题就不太好做了。正确的想法应该是拆分为『若 \([i-K,i)\) 中有点，贡献次数 \(+1\)』和『若 \((i,i+K]\) 中有点 \(j\) 满足 \([j-K,j)\) 中无点，贡献次数 \(+1\)』。对于第一个问题，贡献次数将前 \(i-1\) 大的数分配至少一个到 \([i-K,i)\) 中的方案数；对于第二个问题，枚举 \(j\)，贡献次数为将前 \(i-1\) 大的数分配到 \(j\) 和 \([1,j-K)\cup (j, n]\) 中的方案数。

实现的时候千万注意循环变量枚举的是位置还是值！不然你会调得很痛苦。
#include &lt;bits/stdc++.h&gt;
const int mod = 998244353;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;03-max-01.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n, k;
    std::cin &gt;&gt; n &gt;&gt; k;
    std::vector&lt;int&gt; a(n + 1);
    for (int i = 1; i &lt;= n; ++i)
        std::cin &gt;&gt; a[i];
    std::sort(a.begin() + 1, a.end());
    std::vector&lt;long long&gt; fac(n + 1), inv(n + 1);
    fac[0] = inv[0] = 1ll;
    for (int i = 1; i &lt;= n; ++i)
        fac[i] = fac[i - 1] * i % mod;
    auto qkp = [](long long x, int y) &#123;
        auto res(1ll);
        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)
            if (y &amp; 1)
                (res *= x) %= mod;
        return res;
    &#125;;
    inv[n] = qkp(fac[n], mod - 2);
    for (int i = n - 1; i; --i)
        inv[i] = inv[i + 1] * (i + 1) % mod;
    auto A = [&amp;](int n, int m) &#123;
        if (n &lt; m)
            return 0ll;
        return fac[n] * inv[n - m] % mod;
    &#125;;
    auto C = [&amp;](int n, int m) &#123;
        return A(n, m) * inv[m] % mod;
    &#125;;
    long long res = 0ll;
    for (int i = 2; i &lt;= n; ++i) &#123;
        for (int j = 1; j &lt;= n; ++j)
            (res += a[i] * (fac[n - 1] + mod - A(n - 1 - (j - std::max(1, j - k)), i - 1) * fac[n - i] % mod) % mod) %= mod;
        for (int j = 2; j &lt;= n; ++j)
            (res += a[i] * C(i - 1, i - 2) % mod * C(j - std::max(1, j - k), 1) % mod * A(n - (j - std::max(1, j - k) + 1), i - 2) % mod * fac[n - i] % mod) %= mod;
    &#125;
    std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;


B - Existence Counting
https://atcoder.jp/contests/arc174/tasks/arc174_e
发现可以分类讨论。假设 \(a&#39;\) 中第一个异于 \(a\) 的位置为 \(i\)，\(x\) 在 \(a\) 中位置为 \(pos_x\)（不存在则 \(pos_x=k+1\)）。令 \(f_i\) 为若 \(1\sim i-1\) 均相同，\(i\) 位置可选的选项数。则 \(x\) 出现的次数：










\(pos_x&lt;i\)
\(pos_x=i\)
\(pos_x&gt;i,i&lt;k\)




\(x\le a_i\)
\(1+f_i\cdot A_{n-i}^{k-i}\)
\(f_i\cdot C_{k-i}^1\cdot A_{n-i-1}^{k-i-1}\)
\((f_i-1)\cdot C_{k-i}^1\cdot A_{n-i-1}^{k-i-1}+A_{n-i}^{k-i}\)


\(x&gt;a_i\)
\(f_i\cdot A_{n-i}^{k-i}\)
\(0\)
\(f_i\cdot C_{k-i}^1\cdot A_{n-i-1}^{k-i-1}\)



故，对于任意 \(x\)，答案为：
\[
\begin{aligned}
&amp;1+\left(\sum_{i=pos_x+1}^k f_i\cdot A_{n-i}^{k-i}\right)
+\sum_{i=1}^{pos_x} (f_i-[x&lt; a_i])\cdot C_{k-i}^1\cdot A_{n-i-1}^{k-i-1}+[x&lt; a_i]\cdot A_{n-i}^{k-i}\\
=&amp;1+\left(\sum_{i=pos_x+1}^k f_i\cdot A_{n-i}^{k-i}\right)
+\left(\sum_{i=1}^{pos_x} f_i\cdot C_{k-i}^1\cdot A_{n-i-1}^{k-i-1}\right)+\sum_{i=1,a_i&gt; x}^{pos_x}A_{n-i}^{k-i}-C_{k-i}^1\cdot A_{n-i-1}^{k-i-1}\\
\end{aligned}
\]
预处理出 \(f_i=\sum\limits_{j=i+1}^k [a_j&lt; a_i]\)（需要数据结构）、\(g_i=\sum\limits_{j=1}^i f_j\cdot A_{n-j}^{k-j}\) 和 \(h_j=\sum\limits_{j=1}^i f_i\cdot C_{k-i}^1\cdot A_{n-i-1}^{k-i-1}\)，再用数据结构计算 \(\sum\limits_{i=1,a_i&gt;x}^{pos_x}C_{k-i}^1\cdot A_{n-i-1}^{k-i-1} - A_{n-i}^{k-i}\) 即可。

#include &lt;bits/stdc++.h&gt;
const int mod = 998244353;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n, k;
    std::cin &gt;&gt; n &gt;&gt; k;
    std::vector&lt;int&gt; a(k + 1), p(n + 1, k + 1);
    for (int i = 1; i &lt;= k; ++i)
        std::cin &gt;&gt; a[i], p[a[i]] = i;
    std::vector&lt;long long&gt; fac(n + 1), inv(n + 1);
    &#123;
        fac[0] = inv[0] = 1ll;
        for (int i = 1; i &lt;= n; ++i)
            fac[i] = fac[i - 1] * i % mod;
        auto qkp = [](long long x, int y) &#123;
            auto res(1ll);
            for (; y; (x *= x) %= mod, y &gt;&gt;= 1)
                if (y &amp; 1)
                    (res *= x) %= mod;
            return res;
        &#125;;
        inv[n] = qkp(fac[n], mod - 2);
        for (int i = n - 1; i; --i)
            inv[i] = inv[i + 1] * (i + 1) % mod;
    &#125;
    auto A = [&amp;](int n, int m) &#123;
        if (n &lt; m || m &lt; 0)
            return 0ll;
        return fac[n] * inv[n - m] % mod;
    &#125;;
    std::vector&lt;long long&gt; f(k + 1), g(k + 1), h(k + 1);
    std::vector&lt;long long&gt; bit(n + 1);
    auto lowbit = [](int x) &#123;
        return x &amp; -x;
    &#125;;
    auto add = [&amp;](int x, int v) &#123;
        for (; x &lt;= n; x += lowbit(x))
            (bit[x] += v) %= mod;
        return;
    &#125;;
    auto ask = [&amp;](int x) &#123;
        auto res(0ll);
        for (; x; x -= lowbit(x))
            (res += bit[x]) %= mod;
        return res;
    &#125;;
    for (int i = 1; i &lt;= n; ++i)
        if (p[i] == k + 1)
            add(i, 1);
    for (int i = k; i; --i)
        f[i] = ask(a[i]), add(a[i], 1);
    for (int i = 1; i &lt;= k; ++i) &#123;
        g[i] = (g[i - 1] + f[i] * A(n - i, k - i)) % mod;
        h[i] = (h[i - 1] + f[i] * (k - i) % mod * A(n - i - 1, k - i - 1)) % mod;
        // printf(&quot;%d: f = %lld, g = %lld, h = %lld\n&quot;, i, f[i], g[i], h[i]);
    &#125;
    std::vector&lt;long long&gt; res(n + 1);
    bit.assign(n + 1, 0ll);
    auto s(0ll);
    for (int i = 1; i &lt;= k; ++i) &#123;
        // printf(&quot;%d: %lld + %lld + %lld\n&quot;, a[i], 1 + g[k] - g[i], h[i], s - ask(a[i]));
        res[a[i]] = (1 + g[k] - g[i] + h[i] + (s - ask(a[i]))) % mod;
        res[a[i]] = (res[a[i]] + mod) % mod;
        (s += A(n - i, k - i) - (k - i) * A(n - i - 1, k - i - 1)) %= mod;
        add(a[i], (A(n - i, k - i) - (k - i) * A(n - i - 1, k - i - 1)) % mod);
    &#125;
    for (int i = 1; i &lt;= n; ++i)
        if (p[i] == k + 1) &#123;
            res[i] = (h[k] + (s - ask(i))) % mod;
            res[i] = (res[i] + mod) % mod;
        &#125;
    for (int x = 1; x &lt;= n; ++x)
        std::cout &lt;&lt; res[x] &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;


C - 1 Loop Bubble Sort
https://atcoder.jp/contests/arc187/tasks/arc187_c
首先是被考烂了的：对序列进行一次冒泡排序，等价于将序列在前缀最大值处分段，并将其从段首移到段尾；且满足排序前为前缀最大值的元素，排序后仍为前缀最大值。
考虑用 DP 解决问题。注意状态要从 \(P\) 的角度出发——假如 \(Q\) 中不存在 \(-1\)，发现也需要 DP。此时再设计有关 \(Q\) 的状态就很扯淡了，考虑令 \(f_{i,j}\) 表示 \(P\) 中直到第 \(i\) 位的前缀最大值为 \(j\) 的方案数。为什么把前缀最大值作为状态呢？因为它可以表示分段；同时限制段间数的取值。具体地，考虑转移：

若令 \(P_i=j\)，则在 \(i\) 处分段。对应到 \(Q\) 中，\(i-1\) 位是上一个前缀最大值，那么这要求 \(Q_{i-1}&lt;j\)，且 \(Q_{i-1}\) 是一个前缀最大值。也即：当 \(Q_{i-1}\ne -1\) 时，\(f_{i,j}\gets f_{i-1, Q_{i-1}}\)；否则，\(f_{i,j}\gets \sum\limits_{k&lt;j} f_{i-1,k}\)。其中，二式都要求转移来源为前缀最大值。
若令 \(P_i&lt;j\)，则 \(i\) 在 \(Q\) 中恰好前移一位，即 \(Q_{i-1}=P_i&lt;j\)。则当 \(Q_{i-1}\ne -1\) 时，该位确定，\(f_{i,j}\gets f_{i-1,j}\)；否则，\(Q_{i-1}\) 可选的值为 \(&lt;j\) 的所有未选数（定值，可预处理）。

关于初值，可以在 \(P\) 前加一个 \(0\) 作为排列的一部分（那么按照冒泡排序的规则 \(Q\) 的第一位也一定是 \(0\)）来处理就好了。

#include &lt;bits/stdc++.h&gt;
const int mod = 998244353;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n;
    std::cin &gt;&gt; n;
    std::vector&lt;int&gt; q(n + 1), t(n + 1), c(n + 1), pos(n + 1);
    for (int i = 1; i &lt;= n; ++i) &#123;
        std::cin &gt;&gt; q[i], c[i] = c[i - 1];
        if (q[i] == -1)
            ++c[i];
        else
            pos[q[i]] = i;
    &#125;
    for (int i = 1; i &lt; n; ++i) &#123;
        // printf(&quot;t[%d] = %d\n&quot;, i, t[i]);
        if (!pos[i])
            for (int j = i + 1; j &lt;= n; ++j)
                ++t[j];
    &#125;
    std::vector&lt;std::vector&lt;long long&gt; &gt; f(n + 1, std::vector&lt;long long&gt; (n + 1)), s(n + 1, std::vector&lt;long long&gt; (n + 1));
    f[0][0] = 1ll;
    s[0].assign(n + 1, 1ll);
    for (int i = 1; i &lt;= n; ++i)
        for (int j = 1; j &lt;= n; ++j) &#123;
            if (q[i - 1] == -1)
                f[i][j] = (s[i - 1][j - 1] + f[i - 1][j] * std::max(0, 1 + t[j] - c[i - 1])) % mod;
            else if (q[i - 1] &lt; j)
                f[i][j] = (f[i - 1][q[i - 1]] + f[i - 1][j]) % mod;
            s[i][j] = s[i][j - 1];
            if (q[i] == j || !pos[j]) // 满足前缀最大值
                (s[i][j] += f[i][j]) %= mod;
            // printf(&quot;f[%d][%d] = %lld\n&quot;, i, j, f[i][j]);
        &#125;
    std::cout &lt;&lt; f[n][n] &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;


(F - 1). Intro

给定一个大小为 \(n\) 的树，点有点权。给定 \(q\) 次操作，分为两种：

1 x：查询 \(x\) 的点权。
2 x d v 对于所有距 \(x\) 不超过 \(d\) 的点，将它们的权值加上 \(v\)。

\(n,q\le 10^5,d\le 20\)。

由于 \(d\) 很小，我们可能需要枚举与 \(x\) 距离 \(0\sim d\) 的点进行修改；那么对距离 \(x\) 为 \(i\) 的点的更改存储在 \(f_{x,i}\)，查询 \(v\) 时就可以从 \(\sum\limits_i f_{fa(v,i),i}\) 求得答案。
考虑修改。记 \(S_{x,d}\) 为距 \(x\) 为 \(d\) 的点集。\(x\) 子树内是好处理的，但子树外的呢？发现 \(S_{fa,d-1}\) 中 \(x\) 子树外的点，就是 \(fa\) 子树下、\(x\) 子树外距离 \(x\) 为 \(d\) 的所有点。
由于所有 \(S_{fa(x,i),d-i}\) 无交，这可能满足我们每个待操作点被不重不漏加一次的要求。考虑将所有 \(S_{fa(x,i),d-i}\) 标记出来：

粉色虚线框是待操作点集

然后我们可以一眼发现被叉的点和未被叉的待操作点是交错的！这意味着我们只需要再补充上所有 \(S_{fa(x,i),d-i-1}\) 即可（显然它们之间、它们和所有 \(S_{fa(x,i),d-i}\) 之间都不交）。

虚线叉为 \(S_{fa(x,i),d-i-1}\)

此时就可以不重不漏。当然，也会存在一些细节：比如说 \(fa(x,i)\) 不存在之类。只需要在根节点 \(1\) 处将剩余的 \(S_{1,i\to 0}\) 全部更新即可。
故每次修改操作只需要修改 \(O(d)\) 坨点。时间复杂度 \(O(qd)\)。

F. Distance to the Path
https://codeforces.com/problemset/problem/1749/F
本例中将单点修改替换为路径修改；考虑树剖解决问题。
对于路径上的所有点 \(u\)，容易发现只需要修改所有的 \(S_{u,d}\) 就可以完成对『一部分路径内侧的点』的修改。这『一部分』，是因为不包括距离 LCA \(\le d\) 的点。
而『另一部分路径内侧的点（距 LCA \(\le d\)：见上一行说明）』及『路径外侧的点（距 LCA \(\le d\)：因为路径在 LCA 子树内，LCA 能够到最远的外侧点）』，等价于『距 LCA \(\le d\) 的点』，只需要把 LCA 代入上例中方式修改即可。
修改路径上所有点 \(u\) 的 \(S_{u,d}\) 时，可以对所有 \(f_{*,i}\) 建立数据结构，由于只需要区间修改、单点查询，使用差分树状数组即可。

#include &lt;bits/stdc++.h&gt; 
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n, m;
    std::cin &gt;&gt; n;
    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);
    for (int i = 1, x, y; i &lt; n; ++i) &#123;
        std::cin &gt;&gt; x &gt;&gt; y;
        g[x].push_back(y), g[y].push_back(x);
    &#125;
    std::vector&lt;int&gt; siz(n + 1), dep(n + 1), fa(n + 1), son(n + 1);
    std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int faa) &#123;
        siz[x] = 1;
        for (auto i : g[x])
            if (i != faa) &#123;
                fa[i] = x, dep[i] = dep[x] + 1;
                DFS(i, x);
                siz[x] += siz[i];
                if (siz[i] &gt; siz[son[x]])
                    son[x] = i;
            &#125;
        return;
    &#125;;
    DFS(1, -1);
    std::vector&lt;int&gt; dfn(n + 1), top(n + 1);
    DFS = [&amp;](int x, int toop) &#123;
        static int now = 0;
        dfn[x] = ++now, top[x] = toop;
        if (son[x])
            DFS(son[x], toop);
        for (auto i : g[x])
            if (i != fa[x] &amp;&amp; i != son[x])
                DFS(i, i);
        return;
    &#125;;
    DFS(1, 1);
    std::vector&lt;std::vector&lt;long long&gt; &gt; bit(21, std::vector&lt;long long&gt; (n + 1));
    auto lowbit = [&amp;](int x) &#123;
        return x &amp; -x;
    &#125;;
    auto add = [&amp;](auto &amp;bit, int x, int v) &#123;
        for (; x &lt;= n; x += lowbit(x))
            bit[x] += v;
        return;
    &#125;;
    auto ask = [&amp;](auto &amp;bit, int x) &#123;
        auto res(0ll);
        for (; x; x -= lowbit(x))
            res += bit[x];
        return res;
    &#125;;
    std::cin &gt;&gt; m;
    for (int op; m--; ) &#123;
        std::cin &gt;&gt; op;
        if (op == 1) &#123;
            int x;
            std::cin &gt;&gt; x;
            auto res(0ll);
            for (int i = 0; i &lt;= 20 &amp;&amp; x; ++i, x = fa[x])
                res += ask(bit[i], dfn[x]);
            std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
        &#125;
        else &#123;
            int x, y, v, d;
            std::cin &gt;&gt; x &gt;&gt; y &gt;&gt; v &gt;&gt; d;
            for (; top[x] != top[y]; x = fa[top[x]]) &#123;
                if (dep[top[x]] &lt; dep[top[y]])
                    std::swap(x, y);
                add(bit[d], dfn[top[x]], v);
                add(bit[d], dfn[x] + 1, -v);
            &#125;
            if (dep[x] &gt; dep[y])
                std::swap(x, y);
            add(bit[d], dfn[x] + 1, v), add(bit[d], dfn[y] + 1, -v);
            for (x = x, y = d; ~y &amp;&amp; x; x = fa[x], --y) &#123;
                add(bit[y], dfn[x], v), add(bit[y], dfn[x] + 1, -v);
                if (y &amp;&amp; fa[x])
                    add(bit[y - 1], dfn[x], v), add(bit[y - 1], dfn[x] + 1, -v);
            &#125;
            if (x == 0)
                for (; ~y; --y)
                    add(bit[y], dfn[1], v), add(bit[y], dfn[1] + 1, -v);
        &#125;
    &#125;
    return 0;
&#125;


A - Ina of the Mountain
https://codeforces.com/problemset/problem/1852/C
考虑这么一个简化版的问题：

给定 \(\{a_n\}\)，每次可以进行区间 \(-1\)，问操作多少次才能将所有元素变为 \(0\)。

会想到差分；对原数组进行差分，一次操作相当于令 \(d_l\gets d_l-1\) 而 \(d_{r+1}\gets d_{r+1}+1\)，最后要让 \(\forall \,d_i=0\)。那么答案就是差分数组中正数之和嘛。
回到原问题。原问题等价于把上述问题变为：

给定 \(\{a_n\}\)，每次可以进行区间 \(-1\)，每个数的总操作次数对 \(k\) 取模，问操作多少次才能将所有元素变为 \(0\)。

怎么套回到刚刚的问题上呢？还原被取模掉的操作即可。具体来说，提前在 \(d\) 上进行若干次操作（记为操作 1），形如令 \(d_i\gets d_i+k\)，同时 \(d_{i+1}\gets d_{i+1}-k\)。
会发现相邻的操作 \(1\) 对一个数加加减减影响判断；发现可以合并一段连续的操作 1，表现在 \(a\) 上也就是区间 \(+k\)。此时可以发现，一个位置上只会剩下若干次 \(+k\) 或若干次 \(-k\) （否则可以把 \(+k\) 和 \(-k\) 代表的不同操作合并），就不会有互相影响一说了。这也是有的题解说可以提前在 \(a\) 上区间 \(+k\) 的原因。
此时问题变为在 \(d\) 进行任意次前加 \(k\) 后减 \(k\) 的操作，使得 \(\sum\limits_{d_i&gt;0}d_i\) 最大化。那么显然如果要使代价更小，只可能在原本 \(&lt;0\) 的位置做加法、\(&gt;0\) 的位置做减法（其他情况会发现一定不优）。考虑两个数 \(d_l,d_r\)，可以感受到对于一个 \(r\)，选最小的 \(d_l\) 是最优的，但什么时候应该选呢？

\(d_l\le -k,d_r\ge k\)：当然可选，\(k\) 被完全利用，答案减少 \(k\)。
\(d_l&gt;-k,d_r\ge k\)：此时 \(k\) 未被完全利用，但必须选：选择其他更大的数，\(k\) 的利用率只会更低；如果不选，答案也无法减少。
Q：此时是否需要尝试找到一个 \(l&#39;&lt;l\) 与 \(l\) 做操作，使得 \(l\) 重新变为负数呢？
A：否。因为你可以将这两次操作合并，发现相当于是直接对 \((l&#39;,r)\) 做操作，是更劣的。
\(d_l\le -k,d_r&lt;k\)：此时 \(k\) 未被完全利用，\(d_r\) 成为负数。这意味着 \(d_r\) 将会成为某个 \(r&#39;\) 的可选项。考察 \(d_{r&#39;}\) 可用的最小值。如果 \(d_r\) 在当前不应该作为右端点，它就一定会被 \(d_{r&#39;}\) 选择。具体的有点抽象，但是你可以理解为 \(d_r\) 选了 \(d_l\) 的贡献是被整合到 \(d_r\) 里的；如果 \(d_r\) 被选了就说明 \(d_{r&#39;}\) 选 \(d_l\) 会拥有更大的优势。
\(d_l&gt;-k,d_r&lt;k\)：和上面的情况相似；但这种情况下答案可能反而变得更大，因为没有后效性，所以至少要保证单步最优。此时不能选。
说到单步最优，就会发现这里就是反悔贪心；单步最优一定是全局最优，但更靠前的局部最优可能被否定掉。而『否定』的方法表现为一次操作。

综上，从前往后扫，优先队列实时维护负数最小值，对于每个正数，check 选最小值是否优于当前答案，有就选。如果正数被减为负，加入队列。

#include &lt;bits/stdc++.h&gt;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int T;
    for (std::cin &gt;&gt; T; T--; ) &#123;
        int n, k;
        std::cin &gt;&gt; n &gt;&gt; k;
        std::vector&lt;int&gt; a(n + 1), d(n + 1);
        long long res(0ll);
        for (int i = 1; i &lt;= n; ++i) &#123;
            std::cin &gt;&gt; a[i], a[i] %= k;
            d[i] = a[i] - a[i - 1];
            if (d[i] &gt; 0)
                (res += d[i]);
        &#125;
        std::priority_queue&lt;int&gt; q;
        for (int i = 1; i &lt;= n; ++i)
            if (d[i] &lt; 0)
                q.push(-d[i]);
            else &#123;
                for (; !q.empty() &amp;&amp; d[i] &gt; 0; ) &#123;
                    int x = -q.top(), y = d[i];
                    auto t(res - y);
                    x += k, y -= k;
                    if (x &gt; 0)
                        t += x;
                    if (y &gt; 0)
                        t += y;
                    if (t &gt;= res)
                        break;
                    q.pop();
                    res = t, d[i] = y;
                    if (d[i] &lt; 0)
                        q.push(-d[i]);
                &#125;
            &#125;
        std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
    &#125;
    return 0;
&#125;


B - Miriany and Matchstick
https://codeforces.com/problemset/problem/1852/D
从构造的角度出发，看到『恰好为 \(k\)』，会想到找到上界和下界并证明中间每一个数都能取到。
但似乎很容易证伪：例如对于 AAAA，下界为 \(0\)，上界为 \(4\)，但有且仅有 \(1\) 取不到。但该想法并未破产——可以感受到这样的位置很少。进一步地，你 可以证明只有一个这样的位置，也可以 大胆猜想这样的位置一定出现在 \(l+1\)，\(r-1\)。总之现在我们的状态就减少了（或者说状态变成 DP 值了）。预处理出这个东西之后大力搜索找方案即可。

#include &lt;bits/stdc++.h&gt;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int T;
    for (std::cin &gt;&gt; T; T--; ) &#123;
        int n, k;
        std::cin &gt;&gt; n &gt;&gt; k;
        std::vector&lt;int&gt; a(n + 1);
        for (int i = 1; i &lt;= n; ++i) &#123;
            char t;
            std::cin &gt;&gt; t, a[i] = (t == &#39;A&#39;);
            if (i &gt;= 2)
                k -= (a[i] ^ a[i - 1]);
        &#125;
        std::vector&lt;std::array&lt;std::tuple&lt;int, int, int&gt;, 2&gt; &gt; f(n + 1);
        f[n][0] = &#123; a[n], a[n], 0 &#125;, f[n][1] = &#123; !a[n], !a[n], 0 &#125;;
        auto merge = [&amp;](int i, int l0, int r0, int p0, int l1, int r1, int p1) &#123;
            if (l0 &gt; l1)
                std::swap(l0, l1), std::swap(r0, r1), std::swap(p0, p1);
            int l = l0, r = std::max(r0, r1), p = 0;
            if (!p0 &amp;&amp; !p1) &#123;
                if (r0 &lt; l1 - 1)
                    assert(r0 == l1 - 2), p = r0 + 1;
                else;
            &#125;
            else if (p0 &amp;&amp; p1) &#123;
                if (p0 == p1)
                    p = p0;
                else &#123;
                    int tag0 = (l1 &lt;= p0 &amp;&amp; p0 &lt;= r1), tag1 = (l0 &lt;= p1 &amp;&amp; p1 &lt;= r0);
                    if (!tag0 &amp;&amp; !tag1);
                    else if (!tag0)
                        p = p0;
                    else if (!tag1)
                        p = p1;
                    else;
                &#125;
            &#125;
            else if (p0) &#123;
                if (l1 &lt;= p0 &amp;&amp; p0 &lt;= r1);
                else
                    p = p0;
            &#125;
            else &#123;
                if (l0 &lt;= p1 &amp;&amp; p1 &lt;= r0);
                else
                    p = p1;
            &#125;
            assert(p != l &amp;&amp; p != r &amp;&amp; l &lt;= r);
            return std::make_tuple(l, r, p);
        &#125;;
        for (int i = n - 1; i; --i) &#123;
            &#123;
                auto [l0, r0, p0] = f[i + 1][0];
                auto [l1, r1, p1] = f[i + 1][1];
                if (a[i]) &#123;
                    ++l0, ++r0, ++l1, ++r1;
                    if (p0) ++p0;
                    if (p1) ++p1;
                &#125;
                ++l1, ++r1;
                if (p1) ++p1;
                f[i][0] = merge(i, l0, r0, p0, l1, r1, p1);
            &#125;
            &#123;
                auto [l0, r0, p0] = f[i + 1][0];
                auto [l1, r1, p1] = f[i + 1][1];
                if (!a[i]) &#123;
                    ++l0, ++r0, ++l1, ++r1;
                    if (p0) ++p0;
                    if (p1) ++p1;
                &#125;
                ++l0, ++r0;
                if (p0) ++p0;
                f[i][1] = merge(i, l0, r0, p0, l1, r1, p1);
            &#125;
        &#125;
        std::vector&lt;int&gt; res(n + 1);
        std::function&lt;bool(int, int, int)&gt; DFS = [&amp;](int x, int cnt, int la) &#123;
            if (x == n + 1)
                return cnt == k;
            auto [l0, r0, p0] = f[x][0];
            auto [l1, r1, p1] = f[x][1];
            if (cnt + (la == 1) + l0 &lt;= k &amp;&amp; cnt + (la == 1) + r0 &gt;= k &amp;&amp; (!p0 || cnt + (la == 1) + p0 != k) &amp;&amp; DFS(x + 1, cnt + (la == 1) + a[x], 0))
                res[x] = 0;
            else if (cnt + !la + l1 &lt;= k &amp;&amp; cnt + !la + r1 &gt;= k &amp;&amp; (!p1 || cnt + !la + p1 != k) &amp;&amp; DFS(x + 1, cnt + !la + !a[x], 1))
                res[x] = 1;
            else
                return false;
            return true;
        &#125;;
        if (DFS(1, 0, -1)) &#123;
            std::cout &lt;&lt; &quot;YES\n&quot;;
            for (int i = 1; i &lt;= n; ++i)
                std::cout &lt;&lt; (res[i] ? &#39;A&#39; : &#39;B&#39;);
            std::cout &lt;&lt; &#39;\n&#39;;
        &#125;
        else
            std::cout &lt;&lt; &quot;NO\n&quot;;
    &#125;
    return 0;
&#125;

]]></content>
      <tags>
        <tag>DP</tag>
        <tag>容斥原理</tag>
        <tag>树链剖分</tag>
        <tag>反悔贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>解题报告：喝醉的兔子</title>
    <url>/20250505/</url>
    <content><![CDATA[老题解批量补档。


https://www.becoder.com.cn/contest/6248/problem/2

给定 \(q\) 次询问，每次给定 \(f(0)\)，求最小的 \(t\)，使得 \(n | f(t)\)，其中 \(f(t)=d\cdot f(t-1) + \Delta_t\)，\(n,d,l,r\) 为常数，\(\Delta_t\) 为你自选的 \([l,r]\) 间的整数，每次询问独立。
\(q, n\le 10^7\)。

如果这是数论题，\(n\) 就不会和 \(q\) 同阶了，所以这可能是一道偏模拟的题目。
很容易想到建同余图（这里说的是从 \([0-r,0-l]\) 出发；这样每个点第一次被 BFS 到的时候就能确定答案了）。但如果直接把图建出来，大小就是 \(O(n^2)\) 级别的了。每次连的点都是连续的一段，容易想到线段树优化建图。这样就能 \(O(n\log n)\) 解决问题了。但是题目要求线性。
在实现的时候一定会注意到我们会连到一些已经被访问过的点。这样的边是『无效』的——我们不能将访问过的点再次加入队列。能不能规避掉这些点呢？
每次被访问过的点一定是连续的、长度为 \(r - l + 1\) 的一段——有没有联想到什么？类似地，给 \(0\sim n-1\) 每隔 \(r-l+1\) 打一个标记——或者说 分一段，那么每次试图访问 \([l_0, r_0]\) 时：

\([l_0,r_0]\) 为两个相邻段的前后缀。
\([l_0,r_0]\) 恰好为一段。

这时我们就发现了，每次访问的是完整的前后缀，利用前后缀和优化建图，由于边数是 \(O(n)\) 的，且边权只有 \(0\) 和 \(1\)，就可以做到 \(O(n)\) 01BFS 解决问题。

注：常数大到必可神机跑不过
#include &lt;bits/stdc++.h&gt;
struct IO &#123;
    static const int N = 1 &lt;&lt; 22;
    char buf[N], pbuf[N], *p1 = buf, *p2 = buf, *pp = pbuf;
#define gc() (p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, N, stdin), p1 == p2) ? EOF : *p1++)
    template &lt;typename T&gt;
    void read(T&amp; x) &#123;
        x = 0;
        char ch;
        int f = 0;
        while ((ch = gc()) &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) f |= (ch == &#39;-&#39;);
        while (x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ 48), (ch = gc()) &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;)
            ;
        if (f)
            x = ~x + 1;
    &#125;
    void putc(char c) &#123;
        if (pp - pbuf == N)
            fwrite(pbuf, 1, N, stdout), pp = pbuf;
        *pp++ = c;
    &#125;
    void puts(const char* s) &#123;
        while (*s) putc(*s), ++s;
        putc(&#39;\n&#39;);
    &#125;
    template &lt;typename T&gt;
    void print(T x) &#123;
        static int st[20];
        int tp = 0;
        if (x &lt; 0)
            putc(&#39;-&#39;), x = ~x + 1;
        do
            st[++tp] = x % 10, x /= 10;
        while (x);
        while (tp) putc(st[tp--] + &#39;0&#39;);
    &#125;
    ~IO() &#123; fwrite(pbuf, pp - pbuf, 1, stdout); &#125;
&#125; io;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::freopen(&quot;calculate.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;calculate.out&quot;, &quot;w&quot;, stdout);
#else
    std::freopen(&quot;ex_calculator3.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int T;
    for (io.read(T); T--; ) &#123;
        int n, l, r, m, to;
        long long d, len;
        io.read(n), io.read(d), io.read(l), io.read(r), io.read(m);
        len = r - l + 1, to = (n - 1) / len + 1;
        std::vector&lt;std::vector&lt;int&gt; &gt; t(n), lid(to), rid(to);
        for (int i = 0; i &lt; n; ++i)
            t[i * d % n].push_back(i);
        std::vector&lt;std::vector&lt;int&gt; &gt; g(3 * n);
        for (int i = 0, id = n - 1; i &lt; to; ++i) &#123;
            int at = ((i != to - 1 || !(n % len)) ? len : (n % len));
            lid[i].resize(at), rid[i].resize(at);
            for (int j = 0; j &lt; at; ++j) &#123;
                lid[i][j] = ++id;
                g[id].push_back(i * len + j);
                if (j != 0)
                    g[id].push_back(id - 1);
            &#125;
            for (int j = at - 1; ~j; --j) &#123;
                rid[i][j] = ++id;
                g[id].push_back(i * len + j);
                if (j != at - 1)
                    g[id].push_back(id - 1);
            &#125;
        &#125;
        auto add = [&amp;](int p, int l0, int r0) &#123;
            int p1 = l0 / len, p2 = r0 / len;
            if (p1 == p2)
                g[p].push_back(lid[p1].back());
            else &#123;
                g[p].push_back(rid[p1][l0 % len]);
                if ((p1 + 1) % to != p2) &#123;
                    // fprintf(stderr, &quot;p1 = %d, p2 = %d, to = %d, get %d(%d)\n&quot;, p1, p2, to, (p1 + 1) % to, (int)lid[(p1 + 1) % to].size());
                    g[p].push_back(lid[(p1 + 1) % to].back());
                &#125;
                g[p].push_back(lid[p2][r0 % len]);
            &#125;
            return;
        &#125;;
        for (int i = 0; i &lt; n; ++i)
            for (auto j : t[i]) &#123;
                // printf(&quot;%d -&gt; %d[%d, %d]\n&quot;, i, j, (j + n - r) % n, (j + n - l) % n);
                add(i, (j + n - r) % n, (j + n - l) % n);
            &#125;
        std::list&lt;std::pair&lt;int, int&gt; &gt; q;
        std::vector&lt;int&gt; f(n + 1, -1), tag(3 * n + 1);
        for (int i = l, p = (n - r) % n; i &lt;= r; ++i, (++p) %= n)
            f[p] = 0, q.emplace_back(p, 0), tag[p] = 1;
        for (; !q.empty(); ) &#123;
            auto [u, d] = q.front();
            q.pop_front();
            if (u &lt; n)
                f[u] = d;
            // printf(&quot;u = %d, d = %d\n&quot;, u, d);
            for (auto i : g[u]) &#123;
                // printf(&quot;  i = %d\n&quot;, i);
                if (!tag[i]) &#123;
                    if (i &gt;= n)
                        q.emplace_front(i, d), tag[i] = 1;
                    else
                        q.emplace_back(i, d + 1), tag[i] = 1;
                &#125;
            &#125;
        &#125;
        for (int x; m--; )
            io.read(x), io.print(f[x]), io.putc(&#39;\n&#39;);
    &#125;
    return 0;
&#125;

或者，发现每次任意标记前后缀，则一段内未访问的一定是中间的一整截。根据这一点可维护每一段内可访问元素，就能 \(O(n)\) BFS；
如果把图建出来了，还可以解决扩展问题：

假如 \(\Delta_i\) 在 \([l,r]\) 间的整数中等概率取值，则最优解出现的概率？

为什么 BFS 不能解决该问题呢？因为同层同代价的点对共同能访问到的点的贡献不会被 BFS 记入（注意到一个点只会被一个点访问到），所以只有建图出来才能解决问题。
这也侧面反映该图在忽略环后所对应的就是最优解，这其实是有点 BFS 扩展出来的意味在的。
]]></content>
      <tags>
        <tag>优化建图</tag>
      </tags>
  </entry>
  <entry>
    <title>杂题选谈：构造</title>
    <url>/20250518/</url>
    <content><![CDATA[病毒可能具有膜结构，但不存在生物膜系统。核糖体是唯一所有细胞均含有的细胞器，但病毒中无核糖体。

病毒的主要组成是 \(10\%\sim 20\%\) 的核酸，\(60\%\sim 70\%\) 的蛋白质外壳，\(&lt;10\%\) 的结合水，可能具有逆转录酶、RNA 聚合酶。病毒的含水量（\(&lt;10\%\)）远远小于细胞（\(70\%\)）。

Type I：调整法 - 1
虽然话是这么说，感觉这就是平常正常的做题路径，『想做法』——『发现有锅』——『打补丁』。
只是可能这是在提醒你在构造题中发现有锅不要急着换做法（？）

例题：C - Stations
https://qoj.ac/problem/1139
一个简单的想法是，当可用的编号范围很大时，可以记下每个点 \(u\) 的 \(DFN_u\) 和出栈序（记为 \(RFN_u\)），这样就能解决查询；但标号是 \(N^2\) 级别的。
现在思考，我们为什么需要记录 \(RFN_u\) 呢？因为在询问时，需要判断 \(t\) 的位置：如果在 \(x\) 某一儿子的子树内，答案为该儿子；否则，答案为 \(fa\)。当 \(DFN_t\) 比 \(u\) 最靠后的儿子 \(v\) 的 \(DFN\) 还要大时，无法判断 \(t\) 在 \(v\) 内还是在 \(u\) 外。
此处有一个解决方案（原谅我实在无法猜出是怎么想到的），将树按奇数层、偶数层分层，计数层记录 \(DFN\)，偶数层记录 \(RFN\)（具体地，奇数层在入栈时编号，偶数层在出栈时编号）；接下来进行判断（注意我们并不知道 \(u\) 所在层数的奇偶性）：

若不存在 \(id_i&gt;id_u\)，说明 \(id_u\) 为 \(RFN_u\)；此时 可以判断 \(t\) 是否位于 \(u\) 内。
否则，\(id_u\) 为 \(DFN_u\)。由于知道 \(RFN_v\)，可以判断 \(t\) 是否位于 \(v\) 内。

容易证明其他一般情况也可以判断 \(t\) 的位置。复杂度 \(O(n^2)\)。

#include &quot;stations.h&quot;
#include &lt;bits/stdc++.h&gt;
std::vector&lt;int&gt; label(int n, int k, std::vector&lt;int&gt; u, std::vector&lt;int&gt; v) &#123;
    std::vector&lt;std::vector&lt;int&gt; &gt; g(n);
    for (int i = 0; i &lt; n - 1; ++i)
        g[u[i]].push_back(v[i]), g[v[i]].push_back(u[i]);
    std::vector&lt;int&gt; id(n, -1);
    int now = 0;
    std::function&lt;void(int, int, int)&gt; DFS = [&amp;](int x, int fa, int tag) &#123;
        if (tag)
            id[x] = now++;
        for (auto i : g[x])
            if (i != fa)
                DFS(i, x, tag ^ 1);
        if (!tag)
            id[x] = now++;
        return;
    &#125;;
    DFS(0, -1, 1);
    return id;
&#125;
int find_next_station(int s, int t, std::vector&lt;int&gt; c) &#123;
    if (c.back() &lt; s) &#123;
        int fa = c.front();
        if (t &gt; s)
            return fa;
        for (int i = (int)c.size() - 1; ~i; --i)
            if (t &gt;= c[i])
                return c[i];
        return fa;
    &#125;
    else &#123;
        int fa = c.back();
        if (t &lt; s)
            return fa;
        for (int i = 0; i &lt; (int)c.size() - 1; ++i)
            if (t &lt;= c[i])
                return c[i];
        return fa;
    &#125;
    // assert(0);
    return 114514;
&#125;


Type II：调整法 - 2
题目要求构造『恰好为 \(k\)』，可以先不看这个限制，对于局面求出上界和下界，然后再看是不是上下界中全部（或大多数）都能取到，此时有两个路径：

直接在某个上界 / 下界局面中通过若干步极小改动调整到恰好为 \(k\)；
通过这一点优化 DP 状态（这样就可以大量压缩『可到达局面』这一信息）。见 此。


例题：D - Construct the Binary Tree
https://codeforces.com/problemset/problem/1311/E
首先从找上下界的角度出发，发现链为上界，完全二叉树为下界。
那么只需先 check \(d\) 是否在该范围内；固定树最左侧的一条链，每次拿走右下角的一个叶子（这样就能维持完全二叉树性质），如果可以插入到链底就 do so；否则由于这是个左边挂着单链的完全二叉树，可以证明你想取的任意深度都可以取到，暴力跳即可，且跳完后就构造完了。
复杂度 \(O(n)\)。
\(O(nd)\) 是每次取点时扫一遍完全二叉树找一个能让当前点深度 \(+1\) 的父节点。\(O(d)\) 的做法是慢慢把树变窄变高，一次还是只 \(+1\)，二者的弊端都在于没利用『上界为链』即链和完全二叉树的优美性质。

#include &lt;bits/stdc++.h&gt;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int T;
    for (std::cin &gt;&gt; T; T--; ) &#123;
        int n, d;
        std::cin &gt;&gt; n &gt;&gt; d;
        std::vector&lt;int&gt; tag(n + 1), dep(n + 1), cnt(n + 1), fa(n + 1);
        int L = 0, R = n * (n - 1) / 2;
        for (int i = 1; i &lt;= n; ++i) &#123;
            L += std::__lg(i), dep[i] = std::__lg(i);
            if (i * 2 &lt;= n)
                ++cnt[i], fa[i * 2] = i;
            if (i * 2 + 1 &lt;= n)
                ++cnt[i], fa[i * 2 + 1] = i;
        &#125;
        if (L &lt;= d &amp;&amp; d &lt;= R) &#123;
            std::cout &lt;&lt; &quot;YES\n&quot;;
            int t = 1;
            for (int i = 1; i &lt;= n; i *= 2)
                tag[i] = 1, t = i;
            for (int i = n; i &amp;&amp; L != d; --i)
                if (!tag[i]) &#123;
                    // printf(&quot;i = %d\n&quot;, i);
                    if (L + (dep[t] + 1) - dep[i] &lt;= d) &#123;
                        // printf(&quot;L += %d - %d\n&quot;, dep[t] + 1, dep[i]);
                        L += (dep[t] + 1) - dep[i];
                        --cnt[fa[i]], cnt[i] = 0, ++cnt[t];
                        dep[i] = dep[t] + 1, fa[i] = t;
                        t = i, tag[i] = 1;
                    &#125;
                    else &#123;
                        for (int j = 1; j &lt;= n; ++j)
                            if (cnt[j] != 2 &amp;&amp; L + (dep[j] + 1) - dep[i] == d) &#123;
                                fa[i] = j, L = d;
                                break;
                            &#125;
                    &#125;
                &#125;
            for (int i = 2; i &lt;= n; ++i)
                std::cout &lt;&lt; fa[i] &lt;&lt; &#39; &#39;;
            std::cout &lt;&lt; &#39;\n&#39;;
        &#125;
        else &#123;
            // printf(&quot;[%d, %d]\n&quot;, L, R);
            std::cout &lt;&lt; &quot;NO\n&quot;;
        &#125;
    &#125;
    return 0;
&#125;


Type III：增量法 / 规约法
增量法：类似数归，发现可以方便地从 \(n-k\) 扩展到 \(n\)，考虑 \(n-k\) 给 \(k\) 带来的限制 / 性质，就可以类递推地做了。
规约法：发现抠掉一个好处理的 \(k\) 之后可以转化为规模为 \(n-k\) 的子问题，考虑 \(k\) 给 \(n - k\) 带来的限制，也可以类递推地做。
其实真差不多哈，并不能说是一正一反之类的，因为思维路径真没太差。

例题：经典题

给定大小为 \(n\) 的竞赛图，\(O(n^2)\) 内求出一条哈密顿路径。

竞赛图：给完全图的每条边定向。
哈密顿路径：经过每个点恰好一次，对边无要求。


假设已经知道规模为 \(n-1\) 的子问题的解法，塞一个新点进去，考察 \(P(n-1)\) 中的 \(\forall\, u\to v\)：

若只存在 \(n\to u,n\to v\)：对于路径起点 \(s\) 也有 \(n\to s\)，把 \(n\) 添加到开头即可。
若只存在 \(u\to n,v\to n\)：对于路径终点 \(t\) 也有 \(t\to n\)，把 \(n\) 添加到末尾即可。
若只存在 \(n\to u,v\to n\)：对于路径起点 \(s\) 也有 \(n\to s\)，对于路径终点 \(t\) 也有 \(t\to n\)，爱加哪儿就加哪儿。
否则：存在 \(u\to n,n\to v\)，皆大欢喜，将 \(u\to v\) 改为 \(u\to n\to v\) 即可。

由此就可以解决问题。

例题：E - Travelling Salesperson
https://www.luogu.com.cn/problem/P6644
注意本题为无向边！
相似地，对于 \(P(n-1)\)，假如存在 \(u\to v\)，欲加入 \(u\to n\to v\) 讨论以下几种情况：

若 \(P(n - 1)\) 中只含有一种颜色的边：直接加入首 / 尾即可。
若存在 \(\color{red}{\to} u\color{red}{\to}v\color{red}{\to}\)、\(u\color{red}{\to} n\) 和 \(n\color{red}{\to} v\)（蓝色同理）：直接加入，皆大欢喜。
其余情况，就是 \(\color{red}{\to} u\color{blue}{\to} v\color{blue}{\to}\) 的情况了。容易发现除了 \(u\color{blue}{\to} n\land n\color{red}{\to} v\) 之外的情况都可以直接将边加入。故接下来讨论该特例。
此时在 \((u,v)\) 处无法加入；尝试考虑相邻的点。由于在 \(u\color{blue}{\to} v\) 处切换颜色，易知 \(u\ne s\)，即 \(u\) 存在前驱（记为 \(p\)）。

若存在 \(p\color{blue}{\to} i\)：连接 \(p,i,u\)，最终局面为 \(\color{red}{\to} p\color{blue}{\to} i\color{blue}{\to} u\color{blue}{\to} v\color{blue}{\to}\)，即将变换处提前两位。
否则：存在 \(p\color{red}{\to} i\)，仍然连接 \(p,i,u\)，最终局面为 \(\color{red}{\to} p\color{red}{\to} i\color{blue}{\to} u\color{blue}{\to} v\color{blue}{\to}\)，即将变换处提前一位。


由此可解决问题。可以发现并不存在所谓无解的情况  —— 倒不如说可以对所有点套用最后一种情况（和第一种）——就能够 \(O(n^2)\) 解决原问题了。

loj 上过了但洛谷过不了 
#include &lt;bits/stdc++.h&gt;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n;
    std::cin &gt;&gt; n;
    if (n == 1) &#123;
        std::cout &lt;&lt; &quot;1\n1&quot; &lt;&lt; &#39;\n&#39;;
        return 0;
    &#125;
    std::vector&lt;std::vector&lt;char&gt; &gt; g(n + 1, std::vector&lt;char&gt; (n + 1));
    for (int i = 2; i &lt;= n; ++i)
        for (int j = 1; j &lt; i; ++j)
            std::cin &gt;&gt; g[i][j], g[j][i] = g[i][j];
    for (int i = 1; i &lt;= n; ++i) &#123;
        std::vector&lt;int&gt; tag(n + 1);
        std::list&lt;int&gt; p(&#123; i, i == 1 ? 2 : 1 &#125;);
        tag[p.front()] = tag[p.back()] = 1;
        bool flag = 1;
        char R = g[p.front()][p.back()], B = ((R == &#39;R&#39;) ? &#39;B&#39; : &#39;R&#39;);
        auto pos = --p.end();
        for (int j = 1; j &lt;= n; ++j)
            if (!tag[j]) &#123;
                if (flag &amp;&amp; g[j][p.back()] == R)
                    // printf(&quot;%d: 30  &quot;, j),
                    p.push_back(j), ++pos;
                else if (g[j][p.back()] == B)
                    // printf(&quot;%d: 33  &quot;, j),
                    p.push_back(j), flag = 0;
                else &#123;
                    auto u = pos, v = std::next(pos);
                    if (g[*u][j] == R &amp;&amp; g[j][*v] == R) &#123;
                        // printf(&quot;%d: 38  &quot;, j),
                        p.insert(v, j), ++++pos;
                        if (v == --p.end())
                            flag = 1;
                    &#125;
                    else if (g[*u][j] == R &amp;&amp; g[j][*v] == B)
                        // printf(&quot;%d: 41  &quot;, j),
                        p.insert(v, j), ++pos;
                    else if (g[*u][j] == B &amp;&amp; g[j][*v] == B)
                        // printf(&quot;%d: 44  &quot;, j),
                        p.insert(v, j);
                    else &#123;
                        auto pr(std::prev(u));
                        if (g[*pr][j] == B)
                            // printf(&quot;%d: 49  &quot;, j),
                            p.insert(u, j), ----pos;
                        else
                            // printf(&quot;%d: 52  &quot;, j),
                            p.insert(u, j), --pos;
                    &#125;
                &#125;
                // for (auto j : p)
                //     std::cout &lt;&lt; j &lt;&lt; &#39; &#39;;
                // printf(&quot; flag = %d\n&quot;, flag);
            &#125;
        std::cout &lt;&lt; n &lt;&lt; &#39;\n&#39;;
        for (auto j : p)
            std::cout &lt;&lt; j &lt;&lt; &#39; &#39;;
        std::cout &lt;&lt; &#39;\n&#39;;
    &#125;
    return 0;
&#125;


F - Sergey’s problem
https://codeforces.com/problemset/problem/1019/C
]]></content>
      <tags>
        <tag>构造</tag>
        <tag>调整法</tag>
      </tags>
  </entry>
  <entry>
    <title>杂题选谈：周考</title>
    <url>/20250524/</url>
    <content><![CDATA[并非周考。


B - Carousel of Combinations
https://codeforces.com/problemset/problem/1957/E

\(q\) 次询问，每次给定一个 \(n\)，求：
\[
\left(\sum\limits_{i=1}^n\sum\limits_{j=1}^i \dfrac {i!}{(i-j)!\cdot j!}\bmod j\right) \bmod 10^9+7
\]
\(n,q\le 10^6\)。

赛时打表 \(\dfrac {i!}{(i-j)!\cdot j!}\bmod j\) 易发现只有 \(j=4\) 或 \(j\) 为质数的列上有值；且仅当 \(\left\lfloor \dfrac ij\right\rfloor\) 发生变化时，\((i,j)\) 的值不同。
于是乎埃筛找每个 \(j\) 的倍数，由于每个值会持续一段 \(i\) 上的区间，考虑维护差分数组。前缀和得到原数组，再前缀和就能得到答案。

证明
考虑转化为组合数形式方便证明。当 \(j\) 为质数时：
\[
\begin{aligned}
\dfrac {i!}{(i-j)!\cdot j!}\bmod j
&amp;=C_i^j\cdot (j-1)!\bmod j\\
&amp;=C_{i\bmod j}^{j\bmod j}\cdot C_{\lfloor \frac ij\rfloor}^{\frac jj}\cdot (j-1)!\bmod j\\
&amp;=\left\lfloor \frac ij\right\rfloor\cdot (j-1)!\bmod j\\
&amp;=\left\lfloor \frac ij\right\rfloor\cdot (j-1)\bmod j
\end{aligned}
\]
当 \(j\) 为合数时：
\[
\dfrac {i!}{(i-j)!\cdot j!}\bmod j=\left\lfloor \frac ij\right\rfloor\cdot (j-1)!\bmod j
\]

当 \(j=p^2\)，其中 \(p\) 为质数时：

当 \(j\ne 4\) 时，\(\dfrac jp \ge 3\)，代表在 \(1\sim j-1\) 中至少出现了两个 \(p\) 的倍数，即 \((j-1)\bmod j = 0\)。
否则，原式转化为 \(2\cdot \left\lfloor \frac i4\right\rfloor\bmod 4\)。

否则：可以找到至少一组 \(j=i\cdot k\) 满足 \(i\ne k\)，则 \(i,k\) 出现在 \(1\sim j-1\) 中，即 \((j-1)\bmod j = 0\)。

得到上述结论。
Tips：

卢卡斯定理：懒得写了。
威尔逊定理：对于质数 \(p\)，\((p-1)!\equiv -1\pmod p\)。



C - 玻利维亚 / Bolivija
https://www.luogu.com.cn/problem/P12401

给定若干次区间的插入与删除操作，对于所有值域内未被覆盖极长段 \(i\)，令 \(len_i\) 为其长度；每次操作后询问 \(\sum \frac {len_i\cdot (len_i-1)}2+len_i\)。

来一点新奇的思路。假如你和我一样，很不幸地不知道维护最小值这个 trick，怎么解决这道题？
容易想到线段树维护节点内贡献和左侧、右侧极长未覆盖长度。加入区间是简单的：对于线段树上被完全覆盖的节点，更新其贡献为 \(0\)。依次 pushup 即可。
删除区间，对于被这段区间完全覆盖的节点，发现如果整体被覆盖次数减少 \(1\)，有可能出现新的、未被覆盖的点，如果暴力 check 左右儿子是否出现了这样的点并更新，复杂度就不太美观了。
故而对于一个节点，将『完全覆盖它的区间』和『部分覆盖它的区间』分开考虑，在维护该节点所有实时信息（记为 \(s\)）的同时，维护另一份只考虑了『部分覆盖它地区间』的信息（记为 \(s&#39;\)）：

如果一个『部分覆盖它的区间』被删除：

如果存在『完全覆盖它的区间』：\(s\) 不变；向下修改儿子的 \(s\)，\(s&#39;\) 需要从儿子的 \(s\) 更新。

如果一个『完全覆盖它的区间』被删除：

如果还存在其他『完全覆盖它的区间』：\(s,s&#39;\) 都不变。
如果不存在其他『完全覆盖它的区间』：用 \(s&#39;\) 更新 \(s\)。


这样就能 \(O(q\log V)\) 解决上述问题。本方法较维护最小值的优势在于——似乎没有。想了许多种情况，它们大抵是等价的——且本方法更难写（哭）。

#include &lt;bits/stdc++.h&gt;
const int maxn = 654205;
struct &#123;
    int cnt;
    long long u, s;
    int l, r, lu, ru, ls, rs;
&#125; t[maxn &lt;&lt; 2];
#define lt (p &lt;&lt; 1)
#define rt (lt | 1)
#define len(p) (t[p].r - t[p].l + 1)
void pushup(int p) &#123;
    t[p].s = t[lt].u + t[rt].u + (long long)t[lt].ru * t[rt].lu;
    if (t[lt].lu == len(lt))
        t[p].ls = len(lt) + t[rt].lu;
    else
        t[p].ls = t[lt].lu;
    if (t[rt].ru == len(rt))
        t[p].rs = t[lt].ru + len(rt);
    else
        t[p].rs = t[rt].ru;
    if (!t[p].cnt)
        t[p].u = t[p].s, t[p].lu = t[p].ls, t[p].ru = t[p].rs;
    return;
&#125;
void bld(int p, int l, int r) &#123;
    t[p].l = l, t[p].r = r;
    if (l == r) &#123;
        t[p].u = t[p].s = 1ll;
        t[p].lu = t[p].ru = t[p].ls = t[p].rs = 1;
        return;
    &#125;
    int mid = (l + r) &gt;&gt; 1;
    bld(lt, l, mid), bld(rt, mid + 1, r);
    pushup(p);
    return;
&#125;
void add(int p, int l, int r) &#123;
    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r) &#123;
        ++t[p].cnt, t[p].u = 0ll, t[p].lu = t[p].ru = 0;
        return;
    &#125;
    int mid = (t[p].l + t[p].r) &gt;&gt; 1;
    if (l &lt;= mid)
        add(lt, l, r);
    if (r &gt; mid)
        add(rt, l, r);
    pushup(p);
    return;
&#125;
void rem(int p, int l, int r) &#123;
    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r) &#123;
        if (!--t[p].cnt)
            t[p].u = t[p].s, t[p].lu = t[p].ls, t[p].ru = t[p].rs;
        return;
    &#125;
    int mid = (t[p].l + t[p].r) &gt;&gt; 1;
    if (l &lt;= mid)
        rem(lt, l, r);
    if (r &gt; mid)
        rem(rt, l, r);
    pushup(p);
    return;
&#125;
int main() &#123;
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
    int n, q;
    std::cin &gt;&gt; n &gt;&gt; q;
    std::vector&lt;int&gt; a(n + 1);
    for (int i = 1; i &lt;= n; ++i)
        std::cin &gt;&gt; a[i];
    int u = (n + 1) / 2;
    const int N = a[u];
    bld(1, 1, N);
    for (int i = 1; i &lt; u; ++i)
        if (a[i] != a[n - i + 1])
            add(1, std::min(a[i], a[n - i + 1]) + 1, std::max(a[i], a[n - i + 1]));
    std::cout &lt;&lt; t[1].u &lt;&lt; &#39;\n&#39;;
    for (int i, v; q--; ) &#123;
        std::cin &gt;&gt; i &gt;&gt; v;
        if (a[i] != a[n - i + 1])
            rem(1, std::min(a[i], a[n - i + 1]) + 1, std::max(a[i], a[n - i + 1]));
        a[i] = v;
        if (a[i] != a[n - i + 1])
            add(1, std::min(a[i], a[n - i + 1]) + 1, std::max(a[i], a[n - i + 1]));
        std::cout &lt;&lt; t[1].u &lt;&lt; &#39;\n&#39;;
    &#125;
    return 0;
&#125;


D - 移动金币
https://www.luogu.com.cn/problem/P5363
最后一个棋子的移动等价于丢掉最后一部分空格；中间棋子的移动等价于把左边间隔里的一段空格拿到右边的间隔里。发现原问题转化为『阶梯 Nim 博弈』。

关于阶梯 Nim 博弈…

给定 \(n\) 层石头，每次行动可以选择以下操作中的一种：

选择 \(2\le i\le n\)，从第 \(i\) 层石头中拿走若干颗，全部放到第 \(i-1\) 层里。
从第 \(1\) 层石头中拿走若干颗，全部丢弃。

不能行动者输。

本问题可以等效为 Nim 游戏：
对于第偶数层，若 Alice 选择从第 \(2i\) 层中移动 \(x\) 个石头到 \(2i-1\)，Bob 可以立即从 \(2i-1\) 层中将这 \(x\) 个石头移动到 \(2i-2\)（或丢弃）。
也就是说，Alice 在偶数层中的操作不会对 Bob 带来任何限制。偶数层的石头可以被视作不存在；从奇数层移动到偶数层的石头可以被视为丢弃；进而，奇数堆中的移动等效为『丢弃』，将原问题中所有奇数堆抽离出来，等效成普通的 Nim 游戏。

问题转化成，将 \(n-m\) 个元素放到编号 \(0\sim m+1\) 的盒子里，满足奇数号盒子球个数异或和为 \(0\) 的方案数。小容斥一下，用总数减去异或和为 \(0\) 者。
]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title>杂题选谈：多维 DP</title>
    <url>/20250526/</url>
    <content><![CDATA[上楼听到有人在哼 Climbing on the Trees，上来听到隔壁班在放 Burn the House Down，果然春天是 AJR 的季节（）


主要是多维 DP 特有的优化！
分步转移
如果状态的若干维之间只存在很弱的联系，可以分步转移每一维。
假设有二维状态转移 \((a,b)\to (a&#39;,b&#39;)\)，『很弱的联系』举例：

DP 值中包含 \(w(a&#39;,b&#39;)\)，但不包含诸如 \(w(a&#39;,b),w(a,b&#39;)\) 之类。也即该值的求解不依赖于上一个状态、不依赖于转移。
对于 \((a&#39;,b&#39;)\) 的取值有限制，比如 \((114,514)\) 不能取到之类。显然这也不依赖于上一个状态、不依赖于转移。
符号限制（如转移间为 \(+\)，状态间为 \(\times\) 之类），在计数中常出现。
一个变动的时候另一个必须也一起动。

注意！有的时候一个状态也可以拆成两个状态，然后分步转移。

例题：经典题

给定 \(w_{N\times M}\)，求 \((A,B)_{1\sim K}\)，最大化 \(\sum\limits_{i=1}^K w_{A_i,B_i}+w_{A_{i-1},A_i}+w_{B_{i-1},B_i}\) 的值。

发现如果设 \(f_{i,a,b}\) 表示 \((A,B)_i=(a,b)\) 的话，转移就会达到可观的 \(O(N\times M)\)；但发现里面的 \(A\) 和 \(B\) 其实没什么有机联系；唯一的联系 \(w_{A_i,B_i}\)（上面『很弱的联系』中的第一、四种情况）。因此分布转移：
\[
f&#39;_{a&#39;,b}\gets \max\limits_a f_{a,b}+w_{a&#39;,a}\\
f_{a&#39;,b&#39;}\gets \max\limits_b f&#39;_{a&#39;, b} + w_{b,b&#39;}+w_{a&#39;,b&#39;}
\]
由此便优化转移复杂度到 \(O(N+M)\)。

例题：彩灯晚会
goto link。
Tips：发现 \(l_1,l_2\) 之间也没啥有机联系（上面『很弱的联系』中的第三、四种情况），故分步转移。

例题：序列妙妙值
https://uoj.ac/problem/549
朴素地，设 \(f_{i,j}\) 表示在第 \(i\) 个处分第 \(j\) 段的最大价值，显然有 \(O(k\times n^2)\)，且并没有优化的空间。
考虑利用 \(a_i\) 很小这一条件，发现上一条无法优化是因为要获取 \(sum_{i}\) 的值；那么把 \(sum_i\) 塞到状态里。设 \(f_{s&#39;,j}\) 表示 \(sum=s&#39;\) 时，分了 \(j\) 段的最大价值。同样可以 \(O(k\cdot n^2)\)。
接下来有两个理解这个优化的角度：

从平衡角度，原问题等价于 \(O(1)\) 更新 \((s,j)\) 处的最大值，\(O(v)\) 查找 \(j-1\) 处的最大值；把 \(s\) 拆成前 \(8\) 位、后 \(8\) 位两个 part，当更新
对于修改：相当于固定前 \(8\) 位 \(s\)，枚举后 \(8\) 位 \(x\)，并更新 \((s,x)\)。
对于查询：相当于固定后 \(8\) 位 \(x\)，枚举前 \(8\) 位 \(s\)，并查询 \((s,x)\)。
从分步转移角度，由于『现时刻』的贡献是按位的，二进制状态的前 \(8\) 位和后 \(8\) 位没啥有机联系，故直接拆开，先转移前 \(8\) 位，再转移后 \(8\) 位。

这样就被优化为 \(O(k\cdot n\times \sqrt v)\)。

#include &lt;bits/stdc++.h&gt;
const int maxv = 1 &lt;&lt; 8;
const int inf = 0x3f3f3f3f;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n, k;
    std::cin &gt;&gt; n &gt;&gt; k;
    using arr = std::vector&lt;int&gt;;
    using brr = std::vector&lt;arr&gt;;
    using crr = std::vector&lt;brr&gt;;
    arr s(n + 1), tag0(maxv), d0;
    crr f(maxv, brr(maxv, arr(k + 1, inf))), g(maxv, brr(maxv, arr(k + 1, inf)));
    f[0][0][0] = 0;
    for (int j = 0; j &lt; maxv; ++j)
        g[0][j][1] = j;
    tag0[0] = 1, d0.push_back(0);
    for (int i = 1; i &lt;= n; ++i) &#123;
        std::cin &gt;&gt; s[i], s[i] ^= s[i - 1];
        int p0 = s[i] &gt;&gt; 8, p1 = s[i] &amp; ((1 &lt;&lt; 8) - 1);
        for (int j = k; j; --j) &#123;
            for (auto a : d0)
                f[p0][p1][j] = std::min(f[p0][p1][j], g[a][p1][j] + ((a ^ p0) &lt;&lt; 8));
            // printf(&quot;f[%d][%d][%d] = %d\n&quot;, p0, p1, j, f[p0][p1][j]);
            if (j != k)
                for (int a = 0; a &lt; maxv; ++a)
                    g[p0][a][j + 1] = std::min(g[p0][a][j + 1], f[p0][p1][j] + (a ^ p1));
        &#125;
        if (i &gt;= k)
            std::cout &lt;&lt; f[p0][p1][k] &lt;&lt; &#39; &#39;;
        if (!tag0[p0])
            tag0[p0] = 1, d0.push_back(p0);
    &#125;
    std::cout &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;


割裂
如果状态的若干维之间连无机联系都没了，可以直接把 DP 数组拆开，各自转移各自的。
最后答案的拼接，可能是枚举、直接拼、用一个转移另一个之类。

例题：经典题

给定 \(w_{N\times M}\)，求 \((A,B)_{1\sim K}\)，最大化 \(\sum\limits_{i=1}^K w_{A_{i-1},A_i}+w_{B_{i-1},B_i}\) 的值。

先 DP 出来 \(A\)，再 DP 出来 \(B\)，直接相加即可。

例题：MNOGOMET
https://www.luogu.com.cn/problem/P7648
想到设 \(f_{t,i,a,b}\) 表示『过去了 \(t\) 秒，且球在球员 \(i\) 手上，且两个队伍得分分别为 \(a,b\)』的概率。那么枚举球上一次在谁手上，有美观的 \(O(T\cdot N^2R^2)\)。
发现比分变动时（上半个时刻完成射门并传球）球一定在某个队的 \(1\) 号手上；\(i\) 这一维和 \(a,b\) 也没有相互的干扰；故可以将 \(i\) 提取出来（作为对比，射门和夺球、传球都会影响 \(t\)，所以分裂出来的状态中必须包含 \(t\)）。具体地：

令 \(g_{t,0/1,i}\) 表示『一开始球在哪个球队的 \(1\) 号，花费 \(t\) 秒，且没人射门，且球在球员 \(i\) 手上』的概率。发现可以 \(O(T\times N^2)\) 计算。
当然这里就是条件概率了。其中『一开始球在哪个球队的 \(1\) 号』就是条件。
再预处理可以得到 \(G_{t,0/1,0/1,0/1}\) 表示『一开始球在哪个球队的 \(1\) 号，花费 \(t\) 秒，哪个球队射门，（没）射进』的概率。
令 \(f_{t,0/1,a,b}\) 表示『过去了 \(t\) 秒，球在哪个队的 \(1\) 号，且得分为 \(a,b\)』的概率。枚举距离上一次射门的时间，可以 \(O(T^2\times R^2)\) 完成转移。


#include &lt;bits/stdc++.h&gt;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n, r, T;
    std::cin &gt;&gt; n &gt;&gt; r &gt;&gt; T;
    using arr = std::vector&lt;double&gt;;
    using brr = std::vector&lt;arr&gt;;
    using crr = std::vector&lt;brr&gt;;
    brr p(2 * n + 1, arr(2)), pp(2 * n + 1, arr(2 * n + 1));
    for (int i = 1; i &lt;= n; ++i) &#123;
        std::cin &gt;&gt; p[i][1], p[i][0] = 1. - p[i][1];
        int ss, sd;
        std::cin &gt;&gt; ss &gt;&gt; sd;
        double P = 1. / (ss + sd + 1);
        p[i][0] *= P, p[i][1] *= P;
        for (int x; ss--; pp[i][x] = P)
            std::cin &gt;&gt; x;
        for (int x; sd--; pp[i][x + n] = P)
            std::cin &gt;&gt; x;
    &#125;
    for (int i = n + 1; i &lt;= 2 * n; ++i) &#123;
        std::cin &gt;&gt; p[i][1], p[i][0] = 1. - p[i][1];
        int ss, sd;
        std::cin &gt;&gt; ss &gt;&gt; sd;
        double P = 1. / (ss + sd + 1);
        p[i][0] *= P, p[i][1] *= P;
        for (int x; ss--; pp[i][x + n] = P)
            std::cin &gt;&gt; x;
        for (int x; sd--; pp[i][x] = P)
            std::cin &gt;&gt; x;
    &#125;
    brr s(T + 1, arr(2));
    crr g(T + 1, brr(2, arr(2 * n + 1)));
    std::vector&lt;crr&gt; G(T + 1, crr(2, brr(2, arr(2)))), f(T + 1, crr(2, brr(r + 1, arr(r + 1))));
    g[0][0][1] = g[0][1][n + 1] = 1.;
    for (int t = 1; t &lt;= T; ++t) &#123;
        for (int f1 = 0; f1 &lt;= 1; ++f1)
            for (int i = 1; i &lt;= 2 * n; ++i) &#123;
                G[t][f1][i &gt; n][0] += g[t - 1][f1][i] * p[i][0];
                G[t][f1][i &gt; n][1] += g[t - 1][f1][i] * p[i][1];
                for (int j = 1; j &lt;= 2 * n; ++j)
                    if (j != i)
                        g[t][f1][i] += pp[j][i] * g[t - 1][f1][j];
                // printf(&quot;spend %ds, start from %d, now at %d: %.10lf\n&quot;, t, 1 + f1 * n, i, g[t][f1][i]);
                s[t][f1] += g[t][f1][i];
            &#125;
    &#125;
    // puts(&quot;------------------------------------&quot;);
    // for (int t = 1; t &lt;= T; ++t) &#123;
    //     for (int f1 = 0; f1 &lt;= 1; ++f1)
    //         for (int f2 = 0; f2 &lt;= 1; ++f2)
    //             for (int f3 = 0; f3 &lt;= 1; ++f3)
    //                 printf(&quot;spend %ds, start from %d, %d shoots, STATUS: %d, P = %.10lf\n&quot;, t, 1 + f1 * n, 1 + f2, f3, G[t][f1][f2][f3]);
    // &#125;
    // puts(&quot;------------------------------------&quot;);
    f[0][0][0][0] = 1.;
    for (int t = 0; t &lt; T; ++t)
        for (int f1 = 0; f1 &lt;= 1; ++f1)
            for (int a = 0; a &lt; r; ++a)
                for (int b = 0; b &lt; r; ++b) &#123;
                    for (int t1 = 1; t + t1 &lt;= T; ++t1) &#123;
                        f[t + t1][0][a][b] += f[t][f1][a][b] * G[t1][f1][1][0];
                        f[t + t1][0][a][b + 1] += f[t][f1][a][b] * G[t1][f1][1][1];
                        f[t + t1][1][a][b] += f[t][f1][a][b] * G[t1][f1][0][0];
                        f[t + t1][1][a + 1][b] += f[t][f1][a][b] * G[t1][f1][0][1];
                        if (t + t1 == T)
                            f[T][0][a][b] += f[t][f1][a][b] * s[t1][f1];
                    &#125;
                &#125;
    // for (int t = 0; t &lt;= T; ++t)
    //     for (int f1 = 0; f1 &lt;= 1; ++f1)
    //         for (int a = 0; a &lt;= r; ++a)
    //             for (int b = 0; b &lt;= r; ++b)
    //                 if (f[t][f1][a][b] &gt; 1e-10)
    //                     printf(&quot;%ds later, %d shoots, %d : %d, P = %.10lf\n&quot;, t, 1 + !f1 * n, a, b, f[t][f1][a][b]);
    std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(10);
    for (int a = 0; a &lt;= r; ++a) &#123;
        for (int b = 0; b &lt;= r; ++b) &#123;
            if (a == r &amp;&amp; b == r)
                continue;
            double res(0.);
            if (a == r)
                for (int t = r; t &lt;= T; ++t)
                    res += f[t][1][r][b];
            else if (b == r)
                for (int t = r; t &lt;= T; ++t)
                    res += f[t][0][a][r];
            else
                res = f[T][0][a][b] + f[T][1][a][b];
            std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
        &#125;
    &#125;
    return 0;
&#125;

]]></content>
      <tags>
        <tag>DP</tag>
        <tag>DP 优化</tag>
      </tags>
  </entry>
  <entry>
    <title>学习笔记：虚树</title>
    <url>/20250603/</url>
    <content><![CDATA[凡所有相，皆是虚妄①。
注释：①虚妄：犹言虚树是狂妄的算法。


定义
给定一个大小为 \(n\) 的树和树上 \(k\) 个关键点。取出这 \(k\) 个关键点和它们任意两个间的 LCA 作为虚树的点集，按照原树上的祖孙关系连边得到虚树。


求虚树
按照 DFN 排序，获取任意相邻两点 LCA，即可生成虚树点集。将点集按 DFN 排序后连边，复杂度为 \(O(k\log k)\)。
至少两个实点对应一个虚点，故而虚树大小为 \(O(k)\)。

用途
注意到无论是构建还是遍历虚树复杂度都与 \(n\) 无关。因而适用于对 \(\sum k\) 有限制的题目。

B - Leaf Color
https://atcoder.jp/contests/abc340/tasks/abc340_g
枚举所有颜色，每次对该颜色对应的所有点建立虚树，发现不能选虚树外的其他点，虚树上 DP 即可。
注意根有可能是叶子。需要特判一下。

#include &lt;bits/stdc++.h&gt;
const int mod = 998244353;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n;
    std::cin &gt;&gt; n;
    std::vector&lt;int&gt; a(n + 1);
    std::vector&lt;std::vector&lt;int&gt; &gt; g1(n + 1), t(n + 1), g(n + 1);
    for (int i = 1; i &lt;= n; ++i)
        std::cin &gt;&gt; a[i], t[a[i]].push_back(i);
    for (int i = 1, x, y; i &lt; n; ++i) &#123;
        std::cin &gt;&gt; x &gt;&gt; y;
        g1[x].push_back(y), g1[y].push_back(x);
    &#125;
    std::vector&lt;int&gt; siz(n + 1), son(n + 1), dep(n + 1), fa(n + 1);
    std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int faa) &#123;
        siz[x] = 1;
        for (auto i : g1[x])
            if (i != faa) &#123;
                dep[i] = dep[x] + 1;
                fa[i] = x;
                DFS(i, x);
                if (siz[i] &gt; siz[son[x]])
                    son[x] = i;
            &#125;
        return;
    &#125;;
    DFS(1, -1);
    std::vector&lt;int&gt; dfn(n + 1), rfn(n + 1), top(n + 1);
    DFS = [&amp;](int x, int fa) &#123;
        static int now = 0;
        dfn[x] = ++now;
        if (son[x])
            top[son[x]] = top[x], DFS(son[x], x);
        for (auto i : g1[x])
            if (i != fa &amp;&amp; i != son[x])
                top[i] = i, DFS(i, x);
        rfn[x] = now;
        return;
    &#125;;
    top[1] = 1, DFS(1, -1);
    auto getLCA = [&amp;](int x, int y) &#123;
        for (; top[x] != top[y]; x = fa[top[x]])
            if (dep[top[x]] &lt; dep[top[y]])
                std::swap(x, y);
        return dep[x] &lt; dep[y] ? x : y;
    &#125;;
    std::vector&lt;int&gt; tag(n + 1);
    std::vector&lt;long long&gt; f(n + 1);
    auto res(0ll);
    for (int k = 1; k &lt;= n; ++k)
        if (!t[k].empty()) &#123;
            std::sort(t[k].begin(), t[k].end(), [&amp;](int x, int y) &#123; return dfn[x] &lt; dfn[y]; &#125;);
            std::vector&lt;int&gt; p;
            for (auto i : t[k])
                tag[i] = 1, p.push_back(i);
            for (int i = 1; i &lt; (int)t[k].size(); ++i) &#123;
                int fa = getLCA(t[k][i - 1], t[k][i]);
                if (!tag[fa])
                    tag[fa] = 1, p.push_back(fa);
            &#125;
            std::sort(p.begin(), p.end(), [&amp;](int x, int y) &#123; return dfn[x] &lt; dfn[y]; &#125;);
            std::vector&lt;int&gt; tmp;
            for (auto i : p) &#123;
                if (!tmp.empty()) &#123;
                    for (; rfn[tmp.back()] &lt; dfn[i]; tmp.pop_back());
                    g[tmp.back()].push_back(i);
                &#125;
                tmp.push_back(i);
            &#125;
            std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;
                f[x] = 1ll;
                auto s(1ll);
                for (auto i : g[x]) &#123;
                    DFS(i), (s += f[i]) %= mod;
                    (f[x] *= f[i] + 1) %= mod;
                &#125;
                if (a[x] != k)
                    (f[x] += mod - s) %= mod;
                // printf(&quot;color = %d, res += f[%d](%lld)\n&quot;, k, x, f[x]);
                (res += f[x]) %= mod;
                if (a[x] != k)
                    --s, (f[x] += s) %= mod;
                return;
            &#125;;
            DFS(p.front());
            for (auto i : p) &#123;
                tag[i] = 0, f[i] = 0ll;
                std::vector&lt;int&gt;().swap(g[i]);
            &#125;
        &#125;
    std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;


C - Watching Cowflix P
https://www.luogu.com.cn/problem/P9132
会想到钦定 \(k\) 再来做。发现任意情况下都有：假如两个连通块距离 \(\le k\)，那么合并起来不劣。所以把距离 \(\le k\) 的所有点都合并起来发现只剩下 \(O(\frac nk)\) 个点了，想到用虚树。
然后虚树上枚举点选不选，DP 一下就完了。
但是实现起来好史啊。合并需要用并查集维护父亲（而非本身），特别打脑壳。

我的天哪滔天巨史。
#include &lt;bits/stdc++.h&gt;
const int inf = 0x3f3f3f3f;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n, rt;
    std::cin &gt;&gt; n;
    std::vector&lt;int&gt; p, tag(n + 1);
    for (int i = 1; i &lt;= n; ++i) &#123;
        char t;
        std::cin &gt;&gt; t;
        if (t == &#39;1&#39;)
            p.push_back(i), tag[i] = 1;
    &#125;
    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1), g1(n + 1);
    for (int i = 1, x, y; i &lt; n; ++i) &#123;
        std::cin &gt;&gt; x &gt;&gt; y;
        g1[x].push_back(y), g1[y].push_back(x);
    &#125;
    std::set&lt;int&gt; st;
    std::vector&lt;int&gt; to(n + 1), len(n + 1), cnt(n + 1), dfn(n + 1);
    &#123;
        std::vector&lt;int&gt; siz(n + 1), son(n + 1), fa(n + 1), dep(n + 1);
        std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int faa) &#123;
            siz[x] = 1;
            for (auto i : g1[x])
                if (i != faa) &#123;
                    dep[i] = dep[x] + 1;
                    fa[i] = x, DFS(i, x);
                    siz[x] += siz[i];
                    if (siz[i] &gt; siz[son[x]])
                        son[x] = i;
                &#125;
            return;
        &#125;;
        DFS(1, -1);
        std::vector&lt;int&gt; rfn(n + 1), top(n + 1);
        DFS = [&amp;](int x, int fa) &#123;
            static int now = 0;
            dfn[x] = ++now;
            if (son[x])
                top[son[x]] = top[x], DFS(son[x], x);
            for (auto i : g1[x])
                if (i != son[x] &amp;&amp; i != fa)
                    top[i] = i, DFS(i, x);
            rfn[x] = now;
            return;
        &#125;;
        DFS(1, -1);
        auto getLCA = [&amp;](int x, int y) &#123;
            for (; top[x] != top[y]; x = fa[top[x]])
                if (dep[top[x]] &lt; dep[top[y]])
                    std::swap(x, y);
            return dep[x] &lt; dep[y] ? x : y;
        &#125;;
        std::sort(p.begin(), p.end(), [&amp;](int x, int y) &#123; return dfn[x] &lt; dfn[y]; &#125;);
        std::vector&lt;int&gt; vis(tag), t(p);
        for (int i = 1; i &lt; (int)p.size(); ++i) &#123;
            int fa = getLCA(p[i - 1], p[i]);
            if (!vis[fa])
                vis[fa] = 1, t.push_back(fa);
        &#125;
        std::sort(t.begin(), t.end(), [&amp;](int x, int y) &#123; return dfn[x] &lt; dfn[y]; &#125;);
        rt = t.front();
        std::vector&lt;int&gt; stk;
        for (auto i : t) &#123;
            if (!stk.empty()) &#123;
                for (; rfn[stk.back()] &lt; dfn[i]; stk.pop_back());
                to[i] = stk.back(), len[i] = dep[i] - dep[to[i]] - 1;
            &#125;
            st.insert(i), stk.push_back(i);
        &#125;
    &#125;
    std::vector&lt;int&gt; fa(n + 1), siz(n + 1, 1);
    std::iota(fa.begin() + 1, fa.end(), 1);
    std::function&lt;int(int)&gt; find = [&amp;](int x) &#123;
        return x == fa[x] ? x : fa[x] = find(fa[x]);
    &#125;;
    std::vector&lt;std::array&lt;int, 2&gt; &gt; f(n + 1);
    std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int k) &#123;
        if (tag[x])
            f[x][0] = inf;
        f[x][1] = siz[x] + k;
        for (auto i : g[x]) &#123;
            DFS(i, k);
            if (!tag[x])
                f[x][0] += std::min(f[i][0], f[i][1]);
            f[x][1] += std::min(&#123; f[i][0], f[i][1], f[i][1] + len[i] - k &#125;);
        &#125;
        return;
    &#125;;
    std::function&lt;void(int, int, int)&gt; DFS1 = [&amp;](int x, bool flag, int k) &#123;
        for (auto i : g[x])
            if (flag) &#123;
                if (f[i][0] &lt;= std::min(f[i][1], f[i][1] + len[i] - k))
                    DFS1(i, 0, k);
                else &#123;
                    DFS1(i, 1, k);
                    if (f[i][1] + len[i] - k &lt; f[i][1]) &#123;
                        tag[x] |= tag[i];
                        siz[x] += siz[i] + len[i];
                        st.erase(i), fa[i] = x;
                    &#125;
                &#125;
            &#125;
            else &#123;
                if (f[i][0] &lt;= f[i][1])
                    DFS1(i, 0, k);
                else
                    DFS1(i, 1, k);
            &#125;
        return;
    &#125;;
    for (int k = 1; k &lt;= n; ++k) &#123;
        std::vector&lt;int&gt; p;
        for (auto i : st) &#123;
            p.push_back(i);
            if (to[i])
                g[find(to[i])].push_back(i);
        &#125;
        DFS(rt, k);
        std::cout &lt;&lt; std::min(f[rt][0], f[rt][1]) &lt;&lt; &#39;\n&#39;;
        DFS1(rt, f[rt][1] &lt;= f[rt][0], k);
        for (auto i : st)
            f[i][0] = f[i][1] = 0, std::vector&lt;int&gt;().swap(g[i]);
    &#125;
    return 0;
&#125;


D - Smuggling Marbles
https://atcoder.jp/contests/arc086/tasks/arc086_c
容易想到从贡献角度思考问题；那么每个点只与同深度的所有点存在竞争关系。
把每个深度的点拿出来建虚树，在虚树上跑 DP 即可。

#include &lt;bits/stdc++.h&gt;
const int mod = 1e9 + 7;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n, m = 0;
    std::cin &gt;&gt; n, ++n;
    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1), g1(n + 1);
    for (int i = 2, x; i &lt;= n; ++i)
        std::cin &gt;&gt; x, g1[x + 1].push_back(i);
    std::vector&lt;int&gt; top(n + 1), dep(n + 1), dfn(n + 1), rfn(n + 1), fa(n + 1);
    &#123;
        std::vector&lt;int&gt; siz(n + 1), son(n + 1);
        std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;
            siz[x] = 1;
            m = std::max(m, dep[x]);
            for (auto i : g1[x]) &#123;
                dep[i] = dep[x] + 1;
                fa[i] = x, DFS(i);
                siz[x] += siz[i];
                if (siz[i] &gt; siz[son[x]])
                    son[x] = i;
            &#125;
            return;
        &#125;;
        dep[1] = 1, DFS(1);
        DFS = [&amp;](int x) &#123;
            static int now = 0;
            dfn[x] = ++now;
            if (son[x])
                top[son[x]] = top[x], DFS(son[x]);
            for (auto i : g1[x])
                if (i != son[x])
                    top[i] = i, DFS(i);
            rfn[x] = now;
            return;
        &#125;;
        top[1] = 1, DFS(1);
    &#125;
    auto getLCA = [&amp;](int x, int y) &#123;
        for (; top[x] != top[y]; x = fa[top[x]])
            if (dep[top[x]] &lt; dep[top[y]])
                std::swap(x, y);
        return dep[x] &lt; dep[y] ? x : y;
    &#125;;
    std::vector&lt;std::vector&lt;int&gt; &gt; _p(m + 1);
    for (int i = 1; i &lt;= n; ++i)
        _p[dep[i]].push_back(i);
    std::vector&lt;int&gt; tag(n + 1), flag(n + 1);
    std::vector&lt;std::array&lt;long long, 2&gt; &gt; f(n + 1);
    std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;
        f[x][0] = 1ll + flag[x], f[x][1] = flag[x];
        auto s(1ll);
        for (auto i : g[x]) &#123;
            DFS(i);
            f[x][1] = (f[x][1] * f[i][0] + s * f[i][1]) % mod;
            (f[x][0] *= f[i][0] + f[i][1]) %= mod;
            (s *= f[i][0]) %= mod;
        &#125;
        (f[x][0] += mod - f[x][1]) %= mod;
        // printf(&quot;f[%d][0] = %lld, f[%d][1] = %lld\n&quot;, x, f[x][0], x, f[x][1]);
        return;
    &#125;;
    auto qkp = [&amp;](long long x, int y) &#123;
        auto res(1ll);
        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)
            if (y &amp; 1)
                (res *= x) %= mod;
        return res;
    &#125;;
    auto res(0ll);
    for (int k = 1; k &lt;= m; ++k) &#123;
        auto &amp;p = _p[k], t(p);
        for (auto i : p)
            flag[i] = 1;
        std::sort(p.begin(), p.end(), [&amp;](int x, int y) &#123; return dfn[x] &lt; dfn[y]; &#125;);
        for (int i = 1; i &lt; (int)p.size(); ++i) &#123;
            int fa = getLCA(p[i - 1], p[i]);
            if (!tag[fa])
                tag[fa] = 1, t.push_back(fa);
        &#125;
        std::sort(t.begin(), t.end(), [&amp;](int x, int y) &#123; return dfn[x] &lt; dfn[y]; &#125;);
        int rt = t.front();
        std::vector&lt;int&gt; st;
        for (auto i : t) &#123;
            if (!st.empty()) &#123;
                for (; rfn[st.back()] &lt; dfn[i]; st.pop_back());
                g[st.back()].push_back(i);
            &#125;
            st.push_back(i);
        &#125;
        DFS(rt);
        (res += f[rt][1] * qkp(2ll, n - (int)p.size())) %= mod;
        // std::cout &lt;&lt; f[rt][1] * qkp(2ll, n - (int)p.size()) % mod &lt;&lt; &#39;\n&#39;;
        for (auto i : t) &#123;
            tag[i] = flag[i] = 0;
            std::vector&lt;int&gt;().swap(g[i]);
        &#125;
    &#125;
    std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;


E - 世界树
https://www.luogu.com.cn/problem/P3233
会想到在虚树上两次 DFS 找到离任意点最近的实点。具体地，第一次找下方，第二次尝试用上方更新。
接着发现对于虚树上的实点是好做的；对于实点的不在树上的儿子是好做的；接下来是虚点及其不在树上的儿子。
就要用到刚刚求的信息了。显然二分一下就可以了。说起来很简单，然而实际上写起来很苦恼 

#include &lt;bits/stdc++.h&gt;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n, q;
    std::cin &gt;&gt; n;
    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1), g1(n + 1);
    for (int i = 1, x, y; i &lt; n; ++i) &#123;
        std::cin &gt;&gt; x &gt;&gt; y;
        g1[x].push_back(y), g1[y].push_back(x);
    &#125;
    std::vector&lt;std::array&lt;int, 21&gt; &gt; fa(n + 1);
    std::vector&lt;int&gt; siz(n + 1), top(n + 1), dep(n + 1), dfn(n + 1), rfn(n + 1);
    &#123;
        std::vector&lt;int&gt; son(n + 1);
        std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int faa) &#123;
            siz[x] = 1;
            for (auto i : g1[x])
                if (i != faa) &#123;
                    dep[i] = dep[x] + 1;
                    fa[i][0] = x;
                    for (int j = 1; j &lt;= 20; ++j)
                        fa[i][j] = fa[fa[i][j - 1]][j - 1];
                    DFS(i, x);
                    siz[x] += siz[i];
                    if (siz[i] &gt; siz[son[x]])
                        son[x] = i;
                &#125;
            return;
        &#125;;
        DFS(1, -1);
        int now = 0;
        DFS = [&amp;](int x, int fa) &#123;
            dfn[x] = ++now;
            if (son[x])
                top[son[x]] = top[x], DFS(son[x], x);
            for (auto i : g1[x])
                if (i != fa &amp;&amp; i != son[x])
                    top[i] = i, DFS(i, x);
            rfn[x] = now;
            return;
        &#125;;
        top[1] = 1, DFS(1, -1);
    &#125;
    auto getLCA = [&amp;](int x, int y) &#123;
        for (; top[x] != top[y]; x = fa[top[x]][0])
            if (dep[top[x]] &lt; dep[top[y]])
                std::swap(x, y);
        return dep[x] &lt; dep[y] ? x : y;
    &#125;;
    auto getfa = [&amp;](int x, int p) &#123;
        for (int i = 20; ~i; --i)
            if (p &gt;= (1 &lt;&lt; i))
                x = fa[x][i], p -= (1 &lt;&lt; i);
        return x;
    &#125;;
    std::vector&lt;int&gt; to(n + 1);
    std::vector&lt;int&gt; tag(n + 1), flag(n + 1), res(n + 1);
    std::cin &gt;&gt; q;
    auto dis = [&amp;](int x, int y) &#123;
        return std::make_pair(dep[x] + dep[y] - 2 * dep[getLCA(x, y)], y);
    &#125;;
    std::function&lt;void(int)&gt; DFS1 = [&amp;](int x) &#123;
        to[x] = (flag[x] ? x : -1);
        for (auto i : g[x]) &#123;
            DFS1(i);
            if (~to[i] &amp;&amp; (to[x] == -1 || dis(x, to[i]) &lt; dis(x, to[x])))
                to[x] = to[i];
        &#125;
        // printf(&quot;to[%d] = %d\n&quot;, x, to[x]);
        return;
    &#125;, DFS2 = [&amp;](int x) &#123;
        // printf(&quot;to[%d] = %d\n&quot;, x, to[x]);
        for (auto i : g[x]) &#123;
            if (to[i] == -1 || dis(i, to[x]) &lt; dis(i, to[i]))
                to[i] = to[x];
            DFS2(i);
        &#125;
        return;
    &#125;, DFS3 = [&amp;](int x) &#123;
        res[to[x]] += siz[x];
        for (auto i : g[x]) &#123;
            res[to[x]] -= siz[getfa(i, dep[i] - dep[x] - 1)];
            DFS3(i);
        &#125;
        // printf(&quot;res[%d] = %d\n&quot;, x, res[x]);
        return;
    &#125;, DFS4 = [&amp;](int x) &#123;
        for (auto i : g[x]) &#123;
            if (to[x] == to[i])
                res[to[x]] += siz[getfa(i, dep[i] - dep[x] - 1)] - siz[i];
            else &#123;
                auto dx(dis(x, to[x])), di(dis(i, to[i]));
                int at = -1, len = dep[i] - dep[x] - 1;
                for (int l = 0, r = len, mid; l &lt;= r; ) &#123;
                    mid = (l + r) &gt;&gt; 1;
                    if ([&amp;](auto dx, auto dy) &#123;
                        dx.first += mid, dy.first += len - mid + 1;
                        return dx &lt; dy;
                    &#125; (dx, di))
                        at = mid, l = mid + 1;
                    else
                        r = mid - 1;
                &#125;
                int fa = getfa(i, len - at);
                res[to[x]] += siz[getfa(i, len)] - siz[fa];
                res[to[i]] += siz[fa] - siz[i];
            &#125;
            DFS4(i);
        &#125;
        return;
    &#125;;
    for (int k; q--; ) &#123;
        std::cin &gt;&gt; k;
        std::vector&lt;int&gt; p(k);
        for (int i = 0; i &lt; k; ++i)
            std::cin &gt;&gt; p[i], tag[p[i]] = flag[p[i]] = 1;
        auto org(p);
        std::sort(p.begin(), p.end(), [&amp;](int x, int y) &#123; return dfn[x] &lt; dfn[y]; &#125;);
        std::vector&lt;int&gt; t(p);
        for (int i = 1; i &lt; (int)p.size(); ++i) &#123;
            int fa = getLCA(p[i - 1], p[i]);
            if (!tag[fa])
                tag[fa] = 1, t.push_back(fa);
        &#125;
        if (!tag[1])
            t.push_back(1), tag[1] = 1;
        std::sort(t.begin(), t.end(), [&amp;](int x, int y) &#123; return dfn[x] &lt; dfn[y]; &#125;);
        std::vector&lt;int&gt; st;
        for (auto i : t) &#123;
            if (!st.empty()) &#123;
                for (; rfn[st.back()] &lt; dfn[i]; st.pop_back());
                g[st.back()].push_back(i);
            &#125;
            st.push_back(i);
        &#125;
        DFS1(1), DFS2(1), DFS3(1), DFS4(1);
        for (auto i : org)
            std::cout &lt;&lt; res[i] &lt;&lt; &#39; &#39;;
        std::cout &lt;&lt; &#39;\n&#39;;
        for (auto i : t) &#123;
            res[i] = 0;
            tag[i] = flag[i] = 0;
            std::vector&lt;int&gt;().swap(g[i]);
        &#125;
    &#125;
    return 0;
&#125;


F - 大工程
https://www.luogu.com.cn/problem/P4103
虚树上 DP 统计相关信息即可。

#include &lt;bits/stdc++.h&gt;
const long long inf = 0x3f3f3f3f;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n, q;
    std::cin &gt;&gt; n;
    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1), g1(n + 1);
    for (int i = 1, x, y; i &lt; n; ++i) &#123;
        std::cin &gt;&gt; x &gt;&gt; y;
        g1[x].push_back(y), g1[y].push_back(x);
    &#125;
    std::vector&lt;int&gt; top(n + 1), dep(n + 1), dfn(n + 1), rfn(n + 1), fa(n + 1);
    &#123;
        std::vector&lt;int&gt; siz(n + 1), son(n + 1);
        std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int faa) &#123;
            siz[x] = 1;
            for (auto i : g1[x])
                if (i != faa) &#123;
                    dep[i] = dep[x] + 1;
                    fa[i] = x, DFS(i, x);
                    siz[x] += siz[i];
                    if (siz[i] &gt; siz[son[x]])
                        son[x] = i;
                &#125;
            return;
        &#125;;
        DFS(1, -1);
        int now = 0;
        DFS = [&amp;](int x, int fa) &#123;
            dfn[x] = ++now;
            if (son[x])
                top[son[x]] = top[x], DFS(son[x], x);
            for (auto i : g1[x])
                if (i != fa &amp;&amp; i != son[x])
                    top[i] = i, DFS(i, x);
            rfn[x] = now;
            return;
        &#125;;
        top[1] = 1, DFS(1, -1);
    &#125;
    auto getLCA = [&amp;](int x, int y) &#123;
        for (; top[x] != top[y]; x = fa[top[x]])
            if (dep[top[x]] &lt; dep[top[y]])
                std::swap(x, y);
        return dep[x] &lt; dep[y] ? x : y;
    &#125;;
    std::vector&lt;long long&gt; s(n + 1);
    std::vector&lt;int&gt; mx(n + 1), mn(n + 1);
    std::vector&lt;int&gt; tag(n + 1), siz(n + 1), flag(n + 1);
    int rmx, rmn;
    long long rs;
    std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;
        if (flag[x]) &#123;
            siz[x] = 1;
            mx[x] = mn[x] = s[x] = 0;
        &#125;
        else &#123;
            siz[x] = s[x] = 0;
            mn[x] = inf, mx[x] = -inf;
        &#125;
        for (auto i : g[x]) &#123;
            DFS(i);
            int len = dep[i] - dep[x];
            rmx = std::max(rmx, mx[x] + mx[i] + len);
            mx[x] = std::max(mx[x], mx[i] + len);
            rmn = std::min(rmn, mn[x] + mn[i] + len);
            mn[x] = std::min(mn[x], mn[i] + len);
            rs += siz[x] * (s[i] + (long long)siz[i] * len) + siz[i] * s[x]; 
            s[x] += s[i] + (long long)siz[i] * len;
            siz[x] += siz[i];
            // printf(&quot;%d -&gt; %d, mx = %d, mn = %d, s = %lld\n&quot;, x, i, rmx, rmn, rs);
        &#125;
        return;
    &#125;;
    std::cin &gt;&gt; q;
    for (int k; q--; ) &#123;
        std::cin &gt;&gt; k;
        std::vector&lt;int&gt; p(k);
        for (int i = 0; i &lt; k; ++i)
            std::cin &gt;&gt; p[i], tag[p[i]] = flag[p[i]] = 1;
        std::sort(p.begin(), p.end(), [&amp;](int x, int y) &#123; return dfn[x] &lt; dfn[y]; &#125;);
        std::vector&lt;int&gt; t(p);
        for (int i = 1; i &lt; (int)p.size(); ++i) &#123;
            int fa = getLCA(p[i - 1], p[i]);
            if (!tag[fa])
                tag[fa] = 1, t.push_back(fa);
        &#125;
        std::sort(t.begin(), t.end(), [&amp;](int x, int y) &#123; return dfn[x] &lt; dfn[y]; &#125;);
        int rt = t.front();
        std::vector&lt;int&gt; st;
        for (auto i : t) &#123;
            if (!st.empty()) &#123;
                for (; rfn[st.back()] &lt; dfn[i]; st.pop_back());
                g[st.back()].push_back(i);
            &#125;
            st.push_back(i);
        &#125;
        rs = 0ll, rmx = -inf, rmn = inf;
        DFS(rt);
        std::cout &lt;&lt; rs &lt;&lt; &#39; &#39; &lt;&lt; rmn &lt;&lt; &#39; &#39; &lt;&lt; rmx &lt;&lt; &#39;\n&#39;;
        for (auto i : t) &#123;
            tag[i] = flag[i] = 0;
            std::vector&lt;int&gt;().swap(g[i]);
        &#125;
    &#125;
    return 0;
&#125;

]]></content>
      <tags>
        <tag>虚树</tag>
      </tags>
  </entry>
  <entry>
    <title>学习笔记：点分治</title>
    <url>/20250612/</url>
    <content><![CDATA[一时兴起在博客里搜索『点分治』，发现没有匹配项。


定义
适用于解决和点对、路径相关的问题。
对于任意点 \(x\)，树上任意简单路径 \((u,v)\) 被分为几类：

不经过 \(x\)。
经过 \(x\)：

一个端点为 \(x\)。
两个端点都不为 \(x\)：可以由上一种情况拼接得到。


如果我们把每个点作为 \(x\) 的情况都枚举一遍，再统计不重复的 \((u,v)\)，在一种特定的枚举顺序下可以做到 \(O(n\log n)\) 完成所有点对的枚举。
证明略，每次取子树重心，只遍历没遍历过的点即可。
关于子树重心，一则阅读材料：一种基于错误的寻找重心方法的点分治的复杂度分析。

CF1575E Eye-Pleasing City Park Tour
https://codeforces.com/problemset/problem/1575/E
随便用线段树维护一下就行了。复杂度 \(O(n\log^2 n)\)。

随便维护一下 
#include &lt;bits/stdc++.h&gt;
const int mod = 1e9 + 7;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n, k;
    std::cin &gt;&gt; n &gt;&gt; k;
    std::vector&lt;int&gt; a(n + 1);
    for (int i = 1; i &lt;= n; ++i)
        std::cin &gt;&gt; a[i];
    std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; g(n + 1);
    for (int i = 1, x, y, c; i &lt; n; ++i) &#123;
        std::cin &gt;&gt; x &gt;&gt; y &gt;&gt; c;
        g[x].emplace_back(y, c), g[y].emplace_back(x, c);
    &#125;
    std::vector&lt;std::vector&lt;std::pair&lt;int, long long&gt; &gt; &gt; bit(2, std::vector&lt;std::pair&lt;int, long long&gt; &gt; (n + 1));
    auto lowbit = [&amp;](int x) &#123;
        return x &amp; -x;
    &#125;;
    auto add = [&amp;](int id, int x, long long v, int type) &#123;
        for (++x; x &lt;= n; x += lowbit(x))
            bit[id][x].first += type, (bit[id][x].second += v * type) %= mod;
        return;
    &#125;;
    auto ask = [&amp;](int id, int x) &#123;
        std::pair&lt;int, long long&gt; res;
        for (++x; x; x -= lowbit(x))
            res.first += bit[id][x].first, (res.second += bit[id][x].second) %= mod;
        return res;
    &#125;;
    std::vector&lt;int&gt; p, siz(n + 1), mx(n + 1), tag(n + 1);
    std::function&lt;void(int, int)&gt; findp = [&amp;](int x, int fa) &#123;
        p.push_back(x);
        siz[x] = 1, mx[x] = 0;
        for (auto [i, c] : g[x])
            if (i != fa &amp;&amp; !tag[i]) &#123;
                findp(i, x);
                siz[x] += siz[i];
                mx[x] = std::max(mx[x], siz[i]);
            &#125;
        return;
    &#125;;
    auto findrt = [&amp;](int x) &#123;
        std::vector&lt;int&gt;().swap(p), findp(x, -1);
        int n = (int)p.size();
        for (auto i : p)
            if (mx[i] &lt;= n / 2 &amp;&amp; n - siz[i] &lt;= n / 2)
                return i;
        return -1;
    &#125;;
    auto res(0ll);
    std::function&lt;void(int, int, int, int, int, long long, int, int)&gt; calc = [&amp;](int x, int fa, int oc, int la, int cnt, long long s, int os, int type) &#123;
        if (cnt &gt; k)
            return;
        if (type == 0) &#123;
            auto t0(ask(oc, k - cnt)), t1(ask(!oc, k - cnt - 1));
            // auto lr(res);
            (res += t0.first * (s - os) + t0.second) %= mod;
            (res += t1.first * (s - os) + t1.second) %= mod;
            // printf(&quot;  %d(%d, %lld): ask[0](%d) = (%d, %lld), ask[1](%d) = (%d, %lld), res += %lld\n&quot;, x, cnt, s - os, k - cnt, t0.first, t0.second, k - cnt - 1, t1.first, t1.second, res - lr);
        &#125;
        else if (type != 0) &#123;
            // printf(&quot;  %d(%d, %lld): add(%d, %lld)\n&quot;, x, cnt, s - os, oc, s * type);
            add(oc, cnt, s, type);
        &#125;
        for (auto [i, c] : g[x])
            if (i != fa &amp;&amp; !tag[i])
                calc(i, x, oc, c, cnt + (la != c), (s + a[i]) % mod, os, type);
        return;
    &#125;;
    std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;
        x = findrt(x);
        // printf(&quot;DFS %d\n&quot;, x);
        for (auto [i, c] : g[x])
            if (!tag[i]) &#123;
                calc(i, x, c, c, 0, (a[x] + a[i]) % mod, a[x], 0);
                calc(i, x, c, c, 0, (a[x] + a[i]) % mod, a[x], 1);
            &#125;
        (res += ask(0, k).second + ask(1, k).second) %= mod;
        (res += a[x]) %= mod;
        // printf(&quot;res += %lld + %lld\n&quot;, ask(0, k).second, ask(1, k).second);
        for (auto [i, c] : g[x])
            if (!tag[i])
                calc(i, x, c, c, 0, (a[x] + a[i]) % mod, a[x], -1);
        // assert(!ask(0, k).second);
        tag[x] = 1;
        for (auto [i, c] : g[x])
            if (!tag[i])
                DFS(i);
        return;
    &#125;;
    DFS(1);
    std::cout &lt;&lt; (res + mod) % mod &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;


A - 三元图 Graf
https://www.luogu.com.cn/problem/P10829
发现很圆方树；观察题图，肯定想要把中间的方点作为树根。
发现它就是重心；进一步地，整个圆方树其实是一个点分治的结构。显然除了最后一层，每次找到的重心都应该是方点；并且其应该有三个等大的儿子。check 上述两点即可。
唉还是挺常规的，限制我做出来这道题的应该是我已经 &gt; 1y 没写过连通性问题了 😅

怎么还有人不会判重边的 😅
#include &lt;bits/stdc++.h&gt;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n, m;
    std::cin &gt;&gt; n &gt;&gt; m;
    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1), _g(n + 1);
    auto nosol = [](void) &#123;
        std::cout &lt;&lt; &quot;ne&quot; &lt;&lt; &#39;\n&#39;;
        exit(0);
        return;
    &#125;;
    std::set&lt;std::pair&lt;int, int&gt; &gt; t;
    for (int x, y; m--; ) &#123;
        std::cin &gt;&gt; x &gt;&gt; y;
        if (x == y || t.count(&#123; x, y &#125;))
            nosol();
        t.insert(&#123; x, y &#125;), t.insert(&#123; y, x &#125;);
        _g[x].push_back(y), _g[y].push_back(x);
    &#125;
    std::vector&lt;int&gt; st, dfn(n + 1), low(n + 1);
    std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int fa) &#123;
        static int now = 0;
        st.push_back(x);
        dfn[x] = low[x] = ++now;
        for (auto i : _g[x])
            if (!dfn[i]) &#123;
                DFS(i, x);
                low[x] = std::min(low[x], low[i]);
                if (low[i] &gt;= dfn[x]) &#123;
                    ++n, g.emplace_back();
                    for (int p = st.back(); ; p = st.back()) &#123;
                        g[n].push_back(p), g[p].push_back(n);
                        st.pop_back();
                        if (p == i)
                            break;
                    &#125;
                    g[n].push_back(x), g[x].push_back(n);
                &#125;
            &#125;
            else if (i != fa)
                low[x] = std::min(low[x], dfn[i]);
        return;
    &#125;;
    int n1 = n;
    DFS(1, -1);
    std::vector&lt;int&gt; siz(n + 1), p, mx(n + 1), tag(n + 1);
    DFS = [&amp;](int x, int fa) &#123;
        siz[x] = 1, mx[x] = 0;
        p.push_back(x);
        for (auto i : g[x])
            if (i != fa &amp;&amp; !tag[i]) &#123;
                DFS(i, x);
                siz[x] += siz[i];
                mx[x] = std::max(mx[x], siz[i]);
            &#125;
        return;
    &#125;;
    auto findrt = [&amp;](int x) &#123;
        p.clear(), DFS(x, -1);
        int n = (int)p.size();
        for (auto i : p)
            if (mx[i] &lt;= n / 2 &amp;&amp; n - siz[i] &lt;= n / 2)
                return i;
        return -1;
    &#125;;
    std::function&lt;void(int)&gt; DFS1 = [&amp;](int x) &#123;
        x = findrt(x), DFS(x, -1);
        int si = -1, cnt = 0;
        if (siz[x] == 1) &#123;
            if (x &gt; n1)
                nosol();
            return;
        &#125;
        if (x &lt;= n1)
            nosol();
        for (auto i : g[x])
            if (!tag[i]) &#123;
                ++cnt;
                if (~si &amp;&amp; si != siz[i])
                    nosol();
                if (si == -1)
                    si = siz[i];
            &#125;
        if (cnt != 3)
            nosol();
        tag[x] = 1;
        for (auto i : g[x])
            if (!tag[i])
                DFS1(i);
        return;
    &#125;; 
    DFS1(1);
    std::cout &lt;&lt; &quot;da&quot; &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;


B - Distance on Triangulation
https://www.luogu.com.cn/problem/P6976
众（除了我）所周知 凸多边形的三角剖分可以转化为树上问题，故把树建出来；一个重要的点是要认识到这个树的意义。树上的点其实是没什么物理含义的；经过了某一个树上的点和经过了三角形上的任一点是等价的；也就是说，想要从某个点走到另一个点，肯定要经过对应的树上路径，但这不能反应实际距离什么的，只是能获取路径可能包含的点和必须包含的点（的超集），具体还是要最短路。
接着转化为点分治。但其实这里的点分治有点像序列分治：先跑一遍根节点（三个）在当前分治范围内的最短路，然后处理经过了这个点的询问，然后递归。容易发现三个点里有一些之前被算过了，且一定包含了这个分治范围，直接跳过就行了。
注意询问要写成整体二分那种动态下传的形式，只把被某个子树完全包含的询问传下去；不然复杂度是错的。以及这样就可以剪枝：发现询问数组空了就可以停了。直接 TLE to 200ms 了 😅

#include &lt;bits/stdc++.h&gt;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n;
    std::cin &gt;&gt; n;
    std::vector&lt;int&gt; deg(n + 1);
    std::vector&lt;std::vector&lt;int&gt; &gt; _g(n + 1), g(n + 1);
    for (int i = 1; i &lt; n; ++i) &#123;
        _g[i].push_back(i + 1), _g[i + 1].push_back(i);
        ++deg[i], ++deg[i + 1];
    &#125;
    _g[1].push_back(n), _g[n].push_back(1);
    ++deg[1], ++deg[n];
    for (int i = 1, x, y; i &lt;= n - 3; ++i) &#123;
        std::cin &gt;&gt; x &gt;&gt; y;
        _g[x].push_back(y), _g[y].push_back(x);
        ++deg[x], ++deg[y];
    &#125;
    int cnt = 0;
    std::vector&lt;std::vector&lt;int&gt; &gt; t(1);
    &#123;
        std::queue&lt;int&gt; q;
        std::vector&lt;int&gt; inq(n + 1);
        for (int i = 1; i &lt;= n; ++i)
            if (deg[i] == 2)
                q.push(i);
        std::map&lt;std::pair&lt;int, int&gt;, int&gt; st;
        for (; !q.empty(); ) &#123;
            int x = q.front();
            q.pop(), inq[x] = 1;
            if (deg[x] == 2) &#123;
                ++cnt, t.push_back(&#123; x &#125;);
                for (auto i : _g[x])
                    if (!inq[i]) &#123;
                        t[cnt].push_back(i);
                    &#125;
                std::sort(t[cnt].begin(), t[cnt].end());
                for (int a = 0; a &lt; 2; ++a)
                    for (int b = a + 1; b &lt; 3; ++b) &#123;
                        std::pair&lt;int, int&gt; now(t[cnt][a], t[cnt][b]);
                        if (st.count(now)) &#123;
                            int to = st[now];
                            // printf(&quot;add %d &lt;-&gt; %d\n&quot;, to, cnt);
                            g[cnt].push_back(to), g[to].push_back(cnt);
                        &#125;
                        else
                            st[now] = cnt;
                    &#125;
            &#125;
            for (auto i : _g[x])
                if (--deg[i] == 2)
                    q.push(i);
        &#125;
    &#125;
    int q;
    std::cin &gt;&gt; q;
    std::vector&lt;int&gt; res(q + 1, 0x3f3f3f3f);
    std::vector&lt;std::tuple&lt;int, int, int&gt; &gt; u(q);
    for (int i = 1, x, y; i &lt;= q; ++i)
        std::cin &gt;&gt; x &gt;&gt; y, u[i - 1] = &#123; x, y, i &#125;;
    int tik = 0;
    std::vector&lt;int&gt; siz(cnt + 1), mx(cnt + 1), p, now(n + 1), p1;
    std::vector&lt;int&gt; dis(n + 1), tag(n + 1), vis(n + 1), faa(n + 1);
    std::function&lt;void(int, int)&gt; DFS1 = [&amp;](int x, int fa) &#123;
        siz[x] = 1, mx[x] = 0;
        p.push_back(x);
        for (auto i : t[x])
            now[i] = tik, p1.push_back(i);
        for (auto i : g[x])
            if (i != fa &amp;&amp; !tag[i]) &#123;
                DFS1(i, x);
                siz[x] += siz[i];
                mx[x] = std::max(mx[x], siz[i]);
            &#125;
        return;
    &#125;;
    auto findrt = [&amp;](int x) &#123;
        p.clear(), p1.clear(), DFS1(x, -1);
        int n = (int)p.size();
        for (auto i : p)
            if (mx[i] &lt;= n / 2 &amp;&amp; n - siz[i] &lt;= n / 2)
                return i;
        return -1;
    &#125;;
    auto BFS = [&amp;](int x) &#123;
        std::queue&lt;int&gt; q;
        for (auto i : p1)
            dis[i] = 0x3f3f3f3f;
        q.push(x), dis[x] = 0;
        for (; !q.empty(); ) &#123;
            int x = q.front();
            q.pop();
            for (auto i : _g[x])
                if (dis[i] == 0x3f3f3f3f &amp;&amp; now[i] == tik)
                    dis[i] = dis[x] + 1, q.push(i);
        &#125;
        return;
    &#125;;
    std::function&lt;void(int, int, int)&gt; calc = [&amp;](int x, int fa, int rt) &#123;
        for (auto i : t[x])
            faa[i] = rt;
        for (auto i : g[x])
            if (i != fa &amp;&amp; !tag[i])
                calc(i, x, rt);
        return;
    &#125;;
    std::vector&lt;std::vector&lt;std::tuple&lt;int, int, int&gt; &gt; &gt; tmp(n + 1);
    std::function&lt;void(int, std::vector&lt;std::tuple&lt;int, int, int&gt; &gt;)&gt; DFS = [&amp;](int x, std::vector&lt;std::tuple&lt;int, int, int&gt; &gt; q) &#123;
        if (q.empty())
            return;
        ++tik, x = findrt(x);
        for (auto i : g[x])
            calc(i, x, i);
        for (auto k : t[x])
            if (!vis[k]) &#123;
                vis[k] = 1, BFS(k);
                for (auto [u, v, id] : q)
                    res[id] = std::min(res[id], dis[u] + dis[v]);
            &#125;
        for (auto [u, v, id] : q)
            if (faa[u] == faa[v])
                tmp[faa[u]].emplace_back(u, v, id);
        std::vector&lt;std::tuple&lt;int, int, int&gt; &gt;().swap(q);
        tag[x] = 1;
        for (auto i : g[x])
            if (!tag[i])
                DFS(i, std::move(tmp[i]));
        return;
    &#125;;
    DFS(1, std::move(u));
    for (int i = 1; i &lt;= q; ++i)
        std::cout &lt;&lt; res[i] &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;


C - Shopping
https://www.luogu.com.cn/problem/P6326
意识到连通块 DP 也是可以放在点分上做的，令 \(f_{u,i}\) 表示在（点分时的）子树 \(u\) 中，\(u\) 选了至少一个，共用了 \(i\) 体积的最大价值。剩下就是一个树上的多重 + 01 背包；发现这个 01 背包不满足可以优化的形式，所以考虑树上背包序列化，转换成序列上多重背包问题；不知道真实数据强度，但我认为应该用 单调队列优化多重背包。
注意树背包序列化的细节其实是有点多的。可能需要一些邪思。

#include &lt;bits/stdc++.h&gt;
const int inf = 0x3f3f3f3f;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int T;
    for (std::cin &gt;&gt; T; T--; ) &#123;
        int n, m;
        std::cin &gt;&gt; n &gt;&gt; m;
        std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);
        std::vector&lt;int&gt; v(n + 1), w(n + 1), c(n + 1);
        for (int i = 1; i &lt;= n; ++i)
            std::cin &gt;&gt; w[i];
        for (int i = 1; i &lt;= n; ++i)
            std::cin &gt;&gt; v[i];
        for (int i = 1; i &lt;= n; ++i)
            std::cin &gt;&gt; c[i];
        for (int i = 1, x, y; i &lt; n; ++i) &#123;
            std::cin &gt;&gt; x &gt;&gt; y;
            g[x].push_back(y), g[y].push_back(x);
        &#125;
        std::vector&lt;int&gt; siz(n + 1), mx(n + 1), tag(n + 1), p;
        std::function&lt;void(int, int)&gt; DFS1 = [&amp;](int x, int fa) &#123;
            p.push_back(x);
            siz[x] = 1, mx[x] = 0;
            for (auto i : g[x])
                if (i != fa &amp;&amp; !tag[i]) &#123;
                    DFS1(i, x);
                    siz[x] += siz[i];
                    mx[x] = std::max(mx[x], siz[i]);
                &#125;
            return;
        &#125;;
        int now = 0;
        std::vector&lt;int&gt; nex(n + 1), tab(n + 1);
        auto findrt = [&amp;](int x) &#123;
            p.clear(), DFS1(x, -1);
            int n = (int)p.size();
            for (auto i : p)
                if (mx[i] &lt;= n / 2 &amp;&amp; n - siz[i] &lt;= n / 2)
                    return i;
            assert(0);
            return -1;
        &#125;;
        std::function&lt;void(int, int)&gt; DFS2 = [&amp;](int x, int fa) &#123;
            tab[++now] = x;
            for (auto i : g[x])
                if (i != fa &amp;&amp; !tag[i])
                    DFS2(i, x);
            nex[x] = now;
            return;
        &#125;;
        int res = -inf;
        std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;
            x = findrt(x), now = 0, DFS2(x, -1);
            std::vector&lt;std::vector&lt;int&gt; &gt; f(now + 1, std::vector&lt;int&gt; (m + 1, -inf));
            for (int i = 1; i &lt;= c[x] &amp;&amp; i * v[x] &lt;= m; ++i)
                f[1][i * v[x]] = i * w[x];
            for (int i = 1; i &lt; now; ++i) &#123;
                int V = v[tab[i + 1]], W = w[tab[i + 1]], C = c[tab[i + 1]];
                for (int b = 0; b &lt; V; ++b) &#123;
                    std::vector&lt;int&gt; q;
                    int h = 0, t = -1;
                    for (int a = 0; a * V + b &lt;= m; ++a) &#123;
                        for (; h &lt;= t &amp;&amp; a - q[h] &gt; C; ++h);
                        if (h &lt;= t &amp;&amp; f[i][q[h] * V + b] != -inf)
                            f[i + 1][a * V + b] = std::max(f[i + 1][a * V + b], f[i][q[h] * V + b] + (a - q[h]) * W);
                        for (; h &lt;= t &amp;&amp; f[i][a * V + b] - a * W &gt;= f[i][q[t] * V + b] - q[t] * W; --t);
                        q.resize(++t + 1), q[t] = a;
                    &#125;
                &#125;
                int to = nex[tab[i + 1]];
                for (int j = 0; j &lt;= m; ++j)
                    f[to][j] = std::max(f[to][j], f[i][j]);
            &#125;
            res = std::max(res, *std::max_element(f[now].begin(), f[now].end()));
            std::vector&lt;std::vector&lt;int&gt; &gt;().swap(f);
            tag[x] = 1;
            for (auto i : g[x])
                if (!tag[i])
                    DFS(i);
            return;
        &#125;;
        DFS(1);
        std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
    &#125;
    return 0;
&#125;


D - 加油站
https://www.luogu.com.cn/problem/P10805
点分治后分为 \(u\to rt\) 和 \(rt\to v\) 两个部分考虑。前者只需要倍增找到第一次加油的点即可；后者需要对于每个点作为加油站的情况，统计起点个数。
具体地，需要分类讨论：若 \(d(rt,v)&lt;k\)，说明上次加油一定不在当前子树内；在根节点上登记的加油站中统计走得到 \(fa_v\) 但走不到 \(v\) 的，就可以找到 \(fa_v\) 作为加油站对应的起点个数。对 \(d(rt,v)\ge k\)，只需要倍增找到上一次加油的点即可找到 \(fa_v\) 的答案。
说着很轻巧，实现着很恶心。摆了。

E - 首都
https://www.luogu.com.cn/problem/P7215
启示我们点分治处理的问题不一定是与『树结构』强相关者；也可以仅利用点分治划分出来的块，例如『若超出当前块，则一定不优』之类的。
本题的该性质通过分讨是好证的；所以直接每个块内暴力即可。复杂度 \(O(n\log n)\)。

#include &lt;bits/stdc++.h&gt;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n, k;
    std::cin &gt;&gt; n &gt;&gt; k;
    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1), t(k + 1);
    for (int i = 1, x, y; i &lt; n; ++i) &#123;
        std::cin &gt;&gt; x &gt;&gt; y;
        g[x].push_back(y), g[y].push_back(x);
    &#125;
    std::vector&lt;int&gt; col(n + 1), mx(n + 1), siz(n + 1);
    for (int i = 1; i &lt;= n; ++i) &#123;
        std::cin &gt;&gt; col[i];
        t[col[i]].push_back(i);
    &#125;
    std::vector&lt;int&gt; tag(n + 1), p, tik(n + 1), faa(n + 1), vis(n + 1), book(k + 1);
    std::function&lt;void(int, int)&gt; DFS1 = [&amp;](int x, int fa) &#123;
        siz[x] = 1, mx[x] = 0;
        p.push_back(x), tik[x] = 1;
        for (auto i : g[x])
            if (!tag[i] &amp;&amp; i != fa) &#123;
                DFS1(i, x);
                siz[x] += siz[i];
                mx[x] = std::max(mx[x], siz[i]);
            &#125;
        return;
    &#125;;
    auto findrt = [&amp;](int x) &#123;
        p.clear(), DFS1(x, -1);
        int n = (int)p.size();
        for (auto i : p)
            if (mx[i] &lt;= n / 2 &amp;&amp; n - siz[i] &lt;= n / 2)
                return i;
        assert(0);
        return -1;
    &#125;;
    std::function&lt;void(int)&gt; DFS2 = [&amp;](int x) &#123;
        for (auto i : g[x])
            if (!tag[i] &amp;&amp; i != faa[x])
                faa[i] = x, DFS2(i);
        return;
    &#125;;
    int res = 0x3f3f3f3f;
    std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;
        x = findrt(x);
        faa[x] = -1, DFS2(x);
        std::queue&lt;int&gt; q;
        q.push(col[x]), book[col[x]] = 1;
        int cnt = 0;
        for (; !q.empty(); ) &#123;
            int f = q.front();
            q.pop();
            for (auto i : t[f])
                if (tik[i]) 
                    for (int p = i; ~p &amp;&amp; !vis[p]; p = faa[p]) &#123;
                        vis[p] = 1;
                        if (!book[col[p]]) &#123;
                            if (++cnt &gt;= res)
                                goto outo;
                            q.push(col[p]), book[col[p]] = 1;
                        &#125;
                    &#125;
                else
                    goto outo;
        &#125;
        res = cnt;
        // printf(&quot;x = %d: cnt = %d\n&quot;, x, cnt);
    outo:
        for (auto i : p)
            vis[i] = tik[i] = book[col[i]] = 0;
        tag[x] = 1;
        for (auto i : g[x])
            if (!tag[i])
                DFS(i);
        return;
    &#125;;
    DFS(1);
    std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;    
    return 0;
&#125;


F - 开店
https://www.luogu.com.cn/problem/P3241
转化问题，原问题即求解权值在 \([L,R]\) 间的元素到 \(u\) 的距离和。
一般求解距离的方法是找到 LCA 后计算，考虑如果不利用树上 LCA，而是利用点分树上 LCA 如何计算。分讨易证得点分树上 LCA 一定在两点路径上。
储存点分树上每个点到其每个祖先的距离，就可以方便地计算任意两点间距离。接下来处理原问题的弱化：对于每个 \(u\) 求解其到树上所有点距离和。显然这是一个类似换根的问题，随便做即可。
现在需要在线地解决原问题。可以用 vector 存储这一层所有点的权值与深度信息，按权值排序后二分查询。复杂度 \(O(n\log^2 n)\)。实现的时候应该可以注意到原题限制点度数对复杂度的保证。

打起来的时候感觉很史，但实际上调得比大多数题快。
大概懂得为什么经常看大佬写游记做到史题的实现预期都是『一遍过』了。
#include &lt;bits/stdc++.h&gt;
const long long inf = 1e18;
const int maxn = 1.5e5 + 5;
std::vector&lt;std::pair&lt;int, int&gt; &gt; g[maxn];
int top[maxn], siz[maxn], fa[maxn], son[maxn], dep[maxn], dis[maxn];
void DFS1(int x) &#123;
    siz[x] = 1;
    for (auto [i, w] : g[x])
        if (i != fa[x]) &#123;
            fa[i] = x;
            dep[i] = dep[x] + 1, dis[i] = dis[x] + w;
            DFS1(i);
            siz[x] += siz[i];
            if (siz[i] &gt; siz[son[x]])
                son[x] = i;
        &#125;
    return;
&#125;
void DFS2(int x) &#123;
    if (son[x])
        top[son[x]] = top[x], DFS2(son[x]);
    for (auto [i, w] : g[x])
        if (i != fa[x] &amp;&amp; i != son[x])
            top[i] = i, DFS2(i);
    return;
&#125;
int ask(int x, int y) &#123;
    int sx = x, sy = y;
    for (; top[x] != top[y]; x = fa[top[x]])
        if (dep[top[x]] &lt; dep[top[y]])
            std::swap(x, y);
    x = dep[x] &lt; dep[y] ? x : y;
    return dis[sx] + dis[sy] - 2 * dis[x];
&#125;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n, q, A;
    std::cin &gt;&gt; n &gt;&gt; q &gt;&gt; A;
    std::vector&lt;int&gt; c(n + 1);
    for (int i = 1; i &lt;= n; ++i)
        std::cin &gt;&gt; c[i];
    for (int i = 1, x, y, w; i &lt; n; ++i) &#123;
        std::cin &gt;&gt; x &gt;&gt; y &gt;&gt; w;
        g[x].emplace_back(y, w), g[y].emplace_back(x, w);
    &#125;
    DFS1(1), DFS2(1);
    std::vector&lt;int&gt; mx(n + 1), siz(n + 1), p, tag(n + 1);
    std::function&lt;void(int, int)&gt; DFS1 = [&amp;](int x, int fa) &#123;
        siz[x] = 1, mx[x] = 0;
        p.push_back(x);
        for (auto [i, w] : g[x])
            if (!tag[i] &amp;&amp; i != fa) &#123;
                DFS1(i, x);
                siz[x] += siz[i];
                mx[x] = std::max(mx[x], siz[i]);
            &#125;
        return;
    &#125;;
    auto findrt = [&amp;](int x) &#123;
        p.clear(), DFS1(x, -1);
        int n = (int)p.size();
        for (auto i : p)
            if (mx[i] &lt;= n / 2 &amp;&amp; n - siz[i] &lt;= n / 2)
                return i;
        assert(0);
        return -1;
    &#125;;
    std::vector&lt;int&gt; dis(n + 1);
    std::vector&lt;std::array&lt;std::vector&lt;std::pair&lt;int, long long&gt; &gt;, 3&gt; &gt; t(n + 1);
    std::function&lt;void(int, int, std::vector&lt;std::pair&lt;int, long long&gt; &gt;&amp;)&gt; DFS2 = [&amp;](int x, int fa, std::vector&lt;std::pair&lt;int, long long&gt; &gt; &amp;t) &#123;
        t.emplace_back(c[x], dis[x]);
        for (auto [i, w] : g[x])
            if (!tag[i] &amp;&amp; i != fa) &#123;
                dis[i] = dis[x] + w;
                DFS2(i, x, t);
            &#125;
        return;
    &#125;;
    std::vector&lt;std::pair&lt;int, int&gt; &gt; to(n + 1);
    std::function&lt;std::pair&lt;int, int&gt; (int)&gt; DFS = [&amp;](int x) &#123;
        x = findrt(x);
        int ret = dis[x];
        for (int j = 0; j &lt; (int)g[x].size(); ++j) &#123;
            auto [i, w] = g[x][j];
            if (!tag[i]) &#123;
                dis[i] = w;
                DFS2(i, x, t[x][j]);
                std::sort(t[x][j].begin(), t[x][j].end());
                // printf(&quot;[%d, %d]: %d(%lld)&quot;, x, j, t[x][j][0].first, t[x][j][0].second);
                for (int k = 1; k &lt; (int)t[x][j].size(); ++k) &#123;
                    t[x][j][k].second += t[x][j][k - 1].second;
                    // printf(&quot; %d(%lld)&quot;, t[x][j][k].first, t[x][j][k].second);
                &#125;
                // puts(&quot;&quot;);
            &#125;
        &#125;
        tag[x] = 1;
        for (int j = 0; j &lt; (int)g[x].size(); ++j) &#123;
            auto [i, w] = g[x][j];
            if (!tag[i]) &#123;
                auto [rt, d] = DFS(i);
                to[rt] = &#123; x, j &#125;;
            &#125;
        &#125;
        return std::make_pair(x, ret);
    &#125;;
    int rt = DFS(1).first;
    std::vector&lt;std::vector&lt;int&gt; &gt; fd(n + 1);
    for (int i = 1; i &lt;= n; ++i) &#123;
        int now = i;
        for (;; now = to[now].first) &#123;
            fd[i].push_back(ask(now, i));
            if (now == rt)
                break;
        &#125;
    &#125;
    for (int u, a, b; q--; ) &#123;
        static long long la = 0ll;
        std::cin &gt;&gt; u &gt;&gt; a &gt;&gt; b;
        int l = std::min((a + la) % A, (b + la) % A), r = std::max((a + la) % A, (b + la) % A);
        // printf(&quot;ask %d, [%d, %d]\n&quot;, u, l, r);
        auto ask = [&amp;](int x, int j) &#123;
            auto res(0ll);
            int cnt = 0, p = 0;
            p = std::lower_bound(t[x][j].begin(), t[x][j].end(), std::make_pair(l, -1ll)) - t[x][j].begin();
            cnt -= p;
            if (p != 0)
                res -= t[x][j][p - 1].second;
            p = std::upper_bound(t[x][j].begin(), t[x][j].end(), std::make_pair(r, inf)) - t[x][j].begin();
            cnt += p;
            if (p != 0)
                res += t[x][j][p - 1].second;
            return std::make_pair(res, cnt);
        &#125;;
        la = ask(u, 0).first + ask(u, 1).first + ask(u, 2).first;
        // int U = u;
        for (auto d = ++fd[u].begin(); u != rt; ++d) &#123;
            auto [fa, k] = to[u];
            // fprintf(stderr, &quot;u = %d, fa = %d, d = %d\n&quot;, U, fa, *d);
            for (int j = 0; j &lt; 3; ++j)
                if (j != k) &#123;
                    auto [len, cnt] = ask(fa, j);
                    la += len + (long long)cnt * *d;
                &#125;
            if (c[fa] &gt;= l &amp;&amp; c[fa] &lt;= r)
                la += *d;
            u = fa;
        &#125;
        std::cout &lt;&lt; la &lt;&lt; &#39;\n&#39;;
    &#125;
    return 0;
&#125;

]]></content>
      <tags>
        <tag>点分治</tag>
      </tags>
  </entry>
  <entry>
    <title>学习笔记：决策单调性</title>
    <url>/20250707-1/</url>
    <content><![CDATA[等和线：在线段 \(AB\) 上取一点 \(M\)，使得 \(\vec{AB}=\lambda \vec{AM}\)。在 \(AB\) 上方任取一点 \(P\)，则有 \(\vec{PM}=(1-\lambda) \vec{PA}+\lambda \vec{PB}\)。


什么是 xD/yD DP
即 DP 数组共有 \(x\) 维，一次转移复杂度为 \(O(n^y)\)。
为什么要给一句话单开一个标题
下面设通式 \(f_i=\max\left\{f_j+w(i,j)\right\}\)。

单调队列优化 DP
\(w(i,j)\) 仅包含 \(i,j\) 的最高一次项。

如果要求 \(j\in [1,i]\)，前缀最小值即可。
若 \(j\) 的取值范围在到处乱动，可以写 DS =_=
若 \(j\) 的取值范围 \([l,r]\) 随着 \(i\) 增大而 \(l,r\) 都不减小，那么可以使用单调队列。
顺带一提，和这种的单调队列用法相似的『单调栈』主要在斜优里出现。

具体过程被 grizzly bear 吃掉了 
例：单调队列优化多重背包
朴素的多重背包式子是 \(f_{i,j}=\max\left\{f_{i-1,j-k\times v_i}+k\times w_i\right\}\)，因为 \(i\) 和整个式子无关，所以是关于 \(j\) 的 1D/1D。
为了套用单调队列，需要把查询的项变成连续的。发现 \(j-k\times v_i\) 和 \(j\) 关于 \(v_i\) 同余；且随着 \(k\) 的增大，查询的位置不断移动 \(v_i\)。那么不妨把所有 \(j\) 按照模 \(v_i\) 的余数分开做。具体地，不妨设 \(j=a\times v_i+b\)，将 \(j-k\times v_i\) 替换为余数写法，那么有：
\[
\begin{aligned}
f_{i,j}&amp;=\max\{f_{i-1,x\times v_i+b}+(a-x)\times v_i\}\\
&amp;=\max\{f_{i-1,x\times v_i+b}-x\times v_i\}+a\times v_i
\end{aligned}
\]
限制 \((a-x)\) 的取值不超过物品数，在不同模数下按 \(x\) 从小到大将 \(j\) 这一维进行单调队列优化即可。容易发现会不重不漏枚举所有体积；复杂度 \(O(nV)\)。

斜率优化 DP
若 \(w(i,j)\) 种含有 \(i,j\) 的交叉项，可以考虑斜优。
具体过程，（如果你愿意），可以看这篇 四年半前的博客。
关于符号等问题，分享一下我的做法：

单调队列维护：适用于符号和右侧斜率要求单调性相反的情况。

首先，讨论队头维护。不妨假设 \(a\) 为队头第二个元素，\(b\) 为队头第一个元素。
如果队头 \(b\) 需要被弹出，说明 \(a\) 优于 \(b\)；假设式子要求 max，则用 \(a\) 转移得到的答案 &gt; 用 \(b\) 转移得到的答案。
化式子，注意 \(a&gt;b\)；且负数乘除要变号。
最后得到的式子中间的不等号就决定了需要维护的斜率单调情况。以此决定队尾维护方式即可。
注意这个式子的不等号体现的是弹出条件；保留条件和其相反 

单调栈维护：适用于符号和右侧斜率要求单调性相同的情况；需要清楚，维护合法性、维护单调和取答案都在栈顶进行。

首先，都知道要用单调栈了，说明斜优形式已经被化出来了；以此维护合法性即可。
维护一个从底到顶，『优』得越来越小的斜率序列。找到从更优到更劣的临界点，更新答案。


啊，果然高中文化学科是非常有用的。算是明白为什么我小学 / 初中基本没弄懂过斜优，而旁边的大佬已经在乱杀了 

现在假设正在维护一个上凸包，可以进行一些思考：

如果查询区间不单增？
搞不了啊这个。废了。
查询的斜率不单增？
写个二分 + 单调栈。参见 任务安排、TRAKA。
加入斜率的位置不单增？
李超 / CDQ / 平衡树。


四边形不等式优化 DP
关于四边形不等式
对于代价矩阵 \(w\) 和定义域内 \(\forall\,a\le b\le c\le d\)，若 \(w(a,d)+w(b,c)\ge w(a,c)+w(b,d)\)，认为 \(w\) 满足四边形不等式。简记为重叠大于交叉。
命名来源是四边形对角线之和大于对边之和；将恒大于改为恒小于也能得到相似的性质。
就会发现单调队列优化和斜优其实是四边形不等式的特化，导致它们可以少一个 log。

性质
用于证明：

对于任意 \(c\le l\le r\)，若 \(w(l-c,r+c) + w(l,r)\le w(l-c,r)+ w(l,r+c)\)，则 \(w\) 满足四边形不等式。

用于题目：

性质一：若 \(f_i\) 满足四边形不等式（或其反式），那么最优决策点 \(p_i\) 与 \(i\) 有单调关系。
性质二：当 \(i\) 变化时，每个 \(j\) 带来贡献的相对大小 rank 不变。亦作：若 \(j_1\) 相对于 \(j_2\) 对 \(i\) 更优，对于任意 \(i&#39;\)，\(j_1\) 相对于 \(j_2\) 对 \(i&#39;\) 更优。


在优化 DP 之前

首先我必须要提一嘴。由于我第一次接触『四边形不等式』是在四年前，看到『石子合并的 \(n^2\) 做法』时。然而，这一题的 DP 本身有一个特殊性质，即贡献是一个以决策点为极值的凸函数；这直接导致我误以为这是四边形不等式本身带来的性质，导致我在理解上浪费了很多时间。四边形不等式带来的性质，只有上述两条！
当然这也告诉我们，如果你发现『贡献是一个以决策点为极值的凸函数』，你就可以用类似石子合并中的线性转移完成问题。
『满足四边形不等式』并不能等价于『决策单调性』。决策单调性并不具备性质二。
也就是说，如果只满足决策单调性，只有最优决策点是单调的，但贡献函数随着 \(i\) 的变化，其形状会有很大的变动。


优化 DP：分治
主要适用于 \(f_{i}=g_j+w(j,i)\) 的场景，其中 \(g\) 是与 \(f\) 无关的函数。
对于分治范围 \([l,r]\) 和其决策点范围 \([L_p,R_p]\)，首先把暴力 \(mid\) 的决策点 \(p_{mid}\) 找出来。
接着对于 \([l,mid)\) 和 \((mid,R]\)，分别在 \([L_p,p_{mid}]\) 和 \([p_{mid},R_p]\) 里找决策点（注意两边都是闭的）。递归地做。
这时候你肯定就会怀疑了，主播主播，虽然你的区间每次在减半，但决策点范围并不是均分的，还会被共用，复杂度真的对吗？
对的兄弟，对的。观察搜索树，你会发现虽然 \(p_{mid}\) 会被给两个儿子共用，但是在任何一层中，被重复经过的点只会出现在两个区间的交界处。也就是说每整层大概遍历 \(2n\) 次。是不是很对了。

例：Yet Another Minimization Problem
https://codeforces.com/problemset/problem/868/F

我的天哪！是罕见的四级标题！
笑点解析：这个人因为懒得写 CSS 所以只写了经常用的 h2 和 h3 的样式，现在迫不得已用 h4 被倒逼去写了 h4 的 CSS。

发现 \(k\le 20\)，所以可以不用写 WQS 二分。令 \(f_{i,j}\) 表示第 \(i\) 段分在 \(j\) 处的代价，那么有 \(f_{i,j}=\min\{f_{i-1,l}+w(l+1,j)\}\)，分治解决。
接着发现问题：\(w(l+1,j)\) 并不能很快地求出来；然后注意到这个代价的形式很莫队（其实在看到这个题的时候就会有莫队的想法），考虑使用莫队移动端点的方式解决问题。由于分治中查询的区间两端单增，每层的总移动次数是 \(O(n)\) 的，总复杂度就是 \(O(nk\log n)\) 的。

#include &lt;bits/stdc++.h&gt;
const long long inf = 1e12;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n, k;
    std::cin &gt;&gt; n &gt;&gt; k;
    std::vector&lt;int&gt; a(n + 1);
    for (int i = 1; i &lt;= n; ++i)
        std::cin &gt;&gt; a[i];
    std::vector&lt;long long&gt; cnt(n + 1);
    std::vector&lt;std::vector&lt;int&gt; &gt; p(k + 1, std::vector&lt;int&gt; (n + 1));
    std::vector&lt;std::vector&lt;long long&gt; &gt; f(k + 1, std::vector&lt;long long&gt; (n + 1, inf));
    auto w = [&amp;](int l, int r) &#123;
        static int L = 1, R = 0;
        static long long res = 0ll;
        for (; L &gt; l; --L, res -= cnt[a[L]] * (cnt[a[L]] - 1) / 2, ++cnt[a[L]], res += cnt[a[L]] * (cnt[a[L]] - 1) / 2);
        for (; R &gt; r; res -= cnt[a[R]] * (cnt[a[R]] - 1) / 2, --cnt[a[R]], res += cnt[a[R]] * (cnt[a[R]] - 1) / 2, --R);
        for (; R &lt; r; ++R, res -= cnt[a[R]] * (cnt[a[R]] - 1) / 2, ++cnt[a[R]], res += cnt[a[R]] * (cnt[a[R]] - 1) / 2);
        for (; L &lt; l; res -= cnt[a[L]] * (cnt[a[L]] - 1) / 2, --cnt[a[L]], res += cnt[a[L]] * (cnt[a[L]] - 1) / 2, ++L);
        return res;
    &#125;;
    f[0][0] = 0ll;
    for (int t = 1; t &lt;= k; ++t) &#123;
        std::function&lt;void(int, int, int, int)&gt; calc = [&amp;](int l, int r, int lp, int rp) &#123;
            if (l &gt; r)
                return;
            if (l == r) &#123;
                for (int i = lp; i &lt;= rp &amp;&amp; i &lt; l; ++i)
                    if (f[t - 1][i] + w(i + 1, l) &lt; f[t][l])
                        f[t][l] = f[t - 1][i] + w(i + 1, l), p[t][l] = i;
                return;
            &#125;
            int mid = (l + r) &gt;&gt; 1;
            for (int i = lp; i &lt;= rp &amp;&amp; i &lt; mid; ++i)
                if (f[t - 1][i] + w(i + 1, mid) &lt; f[t][mid])
                    f[t][mid] = f[t - 1][i] + w(i + 1, mid), p[t][mid] = i;
            calc(l, mid - 1, lp, p[t][mid]), calc(mid + 1, r, p[t][mid], rp);
            return;
        &#125;;
        calc(1, n, 0, n - 1);
    &#125;
    std::cout &lt;&lt; f[k][n] &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;


优化 DP：单调数据结构
有的时候会出现 \(f_{i}=f_{j}+w(j,i)\) 的结构，也就是 \(f\) 的取值与自己有关。
这种情况我们通常选择填表法，求出 \(f_i\) 后找到 \(i\) 是哪些点的最优决策（那么显然这些点是一段连续区间）。用 \((i,l_i,r_i)\) 这个三元组表示当前算出来的 \(i\) 管辖的范围。
这是什么意思呢？结合性质二，每当我们手上拿到一个新的 \(i\)，那么推出来其管辖范围右端点就会是 \(n\)。接着想办法找到左端点，同样利用性质二，二分出最靠左的一个 \(j\)，满足之前算出来的决策点没有 \(i\) 优，那么 \([j,n]\) 就是当前条件下 \(i\) 的管辖范围。
在队列里加入当前版本的整个三元组序列就可以方便地完成这个过程。为寻找当前元素的答案，需要将队头上，管辖范围完全早于当前元素的弹出去。由于维护的过程和单调队列很像，所以也有人直接把这里的队列叫单调队列。
视题目不同，也可能用到单调栈，也有可能不用二分（例如满足前两种特化的情况）。goto Yakiniku Restaurants。

例：诗人小G
https://www.luogu.com.cn/problem/P1912
我觉得给出字符串内容的唯一价值是让出题人欣赏白日依山尽
令 \(f_{j}\) 为某一行分在第 \(j\) 句处的代价，那么有 \(f_{j}=\min\limits_{k&lt;j}\left\{f_{k}+|(s_j-s_k+j-k-1)-L|^P\right\}\)。
那么就可以考虑单调队列 + 二分了。需要注意无穷大之间的大小比较，我写这个写红温了，直接用指数项相对大小来代替了，似乎可以过。

#include &lt;bits/stdc++.h&gt;
const long long inf = 1000000000000000001ll;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;P1912_2.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int T;
    for (std::cin &gt;&gt; T; T--; ) &#123;
        int n, l, p;
        std::cin &gt;&gt; n &gt;&gt; l &gt;&gt; p;
        long long to;
        switch (p) &#123; // 会有精度问题
        case 1:
            to = 1e18;
            break;
        case 2:
            to = 1e9;
            break;
        case 3:
            to = 1e6;
            break;
        case 4:
            to = 31622;
            break;
        case 5:
            to = 3981;
            break;
        case 6:
            to = 1e3;
            break;
        case 7:
            to = 372;
            break;
        case 8:
            to = 177;
            break;
        case 9:
            to = 100;
            break;
        default:
            to = 63;
            break;
        &#125;
        std::vector&lt;int&gt; s(n + 1);
        std::vector&lt;std::string&gt; a(n + 1);
        for (int i = 1; i &lt;= n; ++i)
            std::cin &gt;&gt; a[i], s[i] = (int)a[i].length();
        std::partial_sum(s.begin() + 1, s.end(), s.begin() + 1);
        struct node &#123; int i, l, r; &#125;;
        std::vector&lt;node&gt; q(n + 1);
        int h = 0, t = -1;
        q[++t] = &#123; 0, 1, n &#125;;
        auto qkp = [&amp;](long long x, int y) &#123;
            if (x &gt; to)
                return inf;
            auto res(1ll);
            for (; y--; res *= x);
            return res;
        &#125;;
        std::vector&lt;int&gt; pre(n + 1);
        std::vector&lt;long long&gt; f(n + 1);
        auto calc = [&amp;](int k, int j) &#123;
            return std::min(inf, f[k] + qkp(std::abs(s[j] - s[k] + j - k - 1 - l), p));
        &#125;;
        auto less = [&amp;](int k1, int j1, int k2, int j2) &#123;
            auto t1(calc(k1, j1)), t2(calc(k2, j2));
            if (t1 == inf &amp;&amp; t2 == inf)
                return std::abs(s[j1] - s[k1] + j1 - k1 - 1 - l) &lt; std::abs(s[j2] - s[k2] + j2 - k2 - 1 - l);
            return t1 &lt; t2;
        &#125;;
        for (int i = 1; i &lt;= n; ++i) &#123;
            for (; h &lt;= t &amp;&amp; q[h].r &lt; i; ++h);
            f[i] = calc(q[h].i, i), pre[i] = q[h].i;
            for (; h &lt;= t &amp;&amp; q[t].l &gt; i &amp;&amp; less(i, q[t].l, q[t].i, q[t].l); --t)
                q[t - 1].r = q[t].r;
            for (int l = std::max(q[t].l, i + 1), r = q[t].r, mid; l &lt;= r; ) &#123;
                mid = (l + r) &gt;&gt; 1;
                if (less(i, mid, q[t].i, mid))
                    r = q[t].r = mid - 1, q[t + 1] = &#123; i, mid, n &#125;;
                else
                    l = mid + 1;
            &#125;
            if (q[t + 1].i == i)
                ++t;
        &#125;
        if (f[n] &gt;= inf)
            std::cout &lt;&lt; &quot;Too hard to arrange&quot; &lt;&lt; &#39;\n&#39;;
        else &#123;
            std::cout &lt;&lt; f[n] &lt;&lt; &#39;\n&#39;;
            std::function&lt;void(int)&gt; print = [&amp;](int x) &#123;
                if (x == 0)
                    return;
                print(pre[x]);
                for (int i = pre[x] + 1; i &lt;= x; ++i) &#123;
                    std::cout &lt;&lt; a[i];
                    if (i != x)
                        std::cout &lt;&lt; &#39; &#39;;
                &#125;
                std::cout &lt;&lt; &#39;\n&#39;;
                return;
            &#125;;
            print(n);
        &#125;
        std::cout &lt;&lt; &quot;--------------------&quot;;
        if (T)
            std::cout &lt;&lt; &#39;\n&#39;;
    &#125;
    return 0;
&#125;

需要注意，本题也可以再加一个『恰好分 \(k\) 段』的限制，直接在外层套一个 WQS 二分就好了，参见 邮局 加强版 加强版。
2D/1D DP 优化
若存在 \(f(i,j)=\min\limits_{k&lt;j} f(i-1,k)+w(k+1,j)\)，且 \(w\) 满足四边形不等式：

设 \(p(i,j)\) 为最优决策点，那么有 \(p(i,j)\le p(i,j+1)\le p(i+1,j+1)\)，亦作 \(p(i,j-1)\le p(i,j)\le p(i+1,j)\)。
此时可以 \(O(nm)\) 解决问题：

若 \(i\) 固定，\(f_i(j)\) 为凸函数。（例：邮局 加强版 加强版）
goto DP 凸优化。

]]></content>
      <tags>
        <tag>DP</tag>
        <tag>DP 优化</tag>
      </tags>
  </entry>
  <entry>
    <title>学习笔记：DP 凸优化</title>
    <url>/20250707/</url>
    <content><![CDATA[袜，这篇文章一下子创建了三个新 tag。


什么是凸函数
定义
在信息学中研究的凸函数大抵是只在正整数域上有定义的，所以只能直接摒弃导函数的概念了。
若斜率递增，换言之，差分数组递增，认为函数是凸的（好反直觉）。
或者看看符号化的定义：若对于任意 \(\lambda\in[0,1]\)，函数 \(f(x)\) 均满足：
\[
f(\lambda x+(1-\lambda) y)\le \lambda f(x)+(1-\lambda) f(y).
\]
或等价地：
\[
f(x)-f(x - 1)\le f(x + 1) - f(x)
\]
那么认为 \(f\) 是凸函数。
因为凹凸在性质上没区别，所以 下文施行暴政，将凹函数和凸函数统称为凸函数。

判定
对于具体情境下的问题，怎么判断 DP 数组是否关于其某一维为凸函数？

相信相信的力量（最常用）。
对于分段问题，证明分出来的每一段满足四边形不等式。
值得一提的是，数学上不认为满足四边形不等式能够推出函数为凸。但这是信息学.jpg
其由两个凸函数线性相加得到：
对于 \(\forall\, \lambda,\mu\ge 0\) 和凸函数 \(f,g\)，若 \(h=\lambda f+\mu g\)，则 \(h\) 为凸函数。
此外，此时 \(h\) 的差分数组和 \(f,g\) 差分数组也满足上述关系。
其是两个凸函数的 闵可夫斯基和。
其由两个凸函数线性 max 得到。
对于两个凸函数的线性 min，一般不是凸函数，甚至可能是凹的。


性质

最值为唯一极值。
斜率 / 差分数组具有单调性。

在解题中主要用到的大概就是上面两条。

WQS 二分
主要任务

例：把 \(a_{1\sim n}\) 分为恰好 \(k\) 段，每段的代价为 \(sum^2+c\)（\(c\) 为给定的常数），问最小代价。\(n\le 2\times 10^5,a_i\le 10^9\)。

如果对段数没有要求，可以用斜优 \(O(n)\) 做。
加上了 \(k\) 的限制，DP 变成二维的，令 \(f_{i,j}\) 表示在 \(i\) 处分第 \(j\) 段，可以在第一维斜率优化，做到 \(O(nk)\)；亦或发现 \((i,j)\) 有决策单调性，然后四边形不等式优化到 \(O(n^2)\)。
我们发现 \(f\) 关于 \(j\) 这一维是凸的（而非上文的 \((i,j)\)），故将 \(f(n,j)\) 关于 \(j\) 的函数提取出来（记为 \(f_n(j)\)）。发现只有最高点是可以一次斜优快速求出来的，故可以认为在当前复杂度限制下，整个函数除了最高点以外都是未知的（注意可以在 DP 时记录极值点的横坐标，即分了几段）。
我们给每个 \(f_n(j)\) 加上 \(\alpha\cdot j\)（在本题中即将 \(c\gets c+k\)），勉强可以认为 \(\alpha\cdot j\) 是凸的，所以新函数 \(f&#39;_n(j)\) 也是凸的。若 \(k&gt;0\)，可以感受到极值点向左偏移，且随着 \(k\) 的增大，极值点不会右移；\(k&lt;0\) 时同理。
结合几何观点，在 \(f_n\) 上的极值点可以用斜率为 \(0\) 的直线切到；而加上 \(\alpha\cdot j\) 的过程，其实就是切线斜率减去 \(\alpha\) 的过程。相当于令切线斜率为 \(-\alpha\)，看看能切到哪里。
故可以二分一个合适的 \(k\)，使得极值点的横坐标为 \(k\)。此时 \(f&#39;_n(k)-\alpha\cdot k\) 即为待求。

WQS 二分参与的问题一般以如下形式呈现：

给定序列，将其恰好分为 \(k\) 段 / 恰好选 \(k\) 个，求最大 / 最小代价。

题目要求最大 / 最小值一般能够反映函数的凹凸性，可以根据这一点来猜。

细节处理
考虑如下凸函数：


显然对于『凸出来』的点（即图中除了 \(E,H\) 以外的点），能切到的直线斜率为一个范围；而位于直线上的点（途中 \(E,H\)），能切到的直线斜率更是定死了。所以这要求你的二分精度需要略高一点。
对于 \(E\)（或 \(H\)），不能找到只过它一点的切线。根据 DP 的写法，记录的横坐标可能是最小的 \(D\)，也可能是最大的 \(F\)，此时你可以：

同时记录最小和最大的横坐标，看看 \(k\) 在不在中间。
题目要求最大代价时，记录最大横坐标，二分到一个极值点 \(k&#39;\ge k\) 时，显然 \(\alpha&#39;\ge \alpha\)，用 \(f&#39;_n(k&#39;)-\alpha&#39;\cdot k\) 更新答案（是赋值而不是取最值）；求最小代价时同理。
主要是需要记住斜率是 \(\alpha\) 的相反数，实在搞不清对应关系可以都试一试



例：种树
https://www.luogu.com.cn/problem/P1484
首先，函数是凸的——感性理解即可。
接着，要求的是 \(\le k\) 时的最值。分为两种情况：\(k\) 是否右于原函数极值点。

若 \(k\) 右于原函数极值点，则原函数极值点为答案。
否则，\(k\) 为答案。

好消息是整数域上一定有解（最后答案为整、倒推即可），所以不用打浮点数二分了。

#include &lt;bits/stdc++.h&gt;
const int lim = 1e6;
const long long inf = 1e18;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n, k;
    std::cin &gt;&gt; n &gt;&gt; k;
    std::vector&lt;long long&gt; a(n + 1);
    for (int i = 1; i &lt;= n; ++i)
        std::cin &gt;&gt; a[i];
    auto calc = [&amp;](int c) &#123;
        std::vector&lt;std::pair&lt;long long, int&gt; &gt; f(n + 1);
        auto mx = f.front();
        auto upd = [&amp;](auto &amp;x, auto y) &#123;
            if (y.first &gt; x.first || (y.first == x.first &amp;&amp; y.second &lt; x.second))
                x = y;
            return;
        &#125;;
        for (int i = 1; i &lt;= n; ++i) &#123;
            f[i].first = mx.first + a[i] + c;
            f[i].second = mx.second + 1;
            upd(mx, f[i - 1]);
        &#125;
        upd(mx, f[n]);
        return mx;
    &#125;;
    auto t(calc(0));
    if (t.second &lt;= k) &#123;
        std::cout &lt;&lt; t.first &lt;&lt; &#39;\n&#39;;
        return 0;
    &#125;
    auto res(-inf);
    for (int l = -lim, r = lim, mid; l &lt;= r; ) &#123;
        mid = (l + r) &gt;&gt; 1;
        auto t = calc(mid);
        if (t.second &lt;= k)
            res = t.first - (long long)mid * k, l = mid + 1;
        else
            r = mid - 1;
    &#125;
    std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;


例：Raper
https://www.luogu.com.cn/problem/P4694
给所有光盘附一个奖励 \(mid\)，进行 WQS 二分。
然后内层就和 sequence 差得不是特别多，所以考虑反悔贪心。（？）
把路过的 \(-a_j\) 丢到大根堆里，尝试和 \(b_i\) 配对。如果 \(mid-a_i-b_i\ge 0\) 那么暂时配对，顺便把 \(b_i-mid\) 丢进去用于反悔，若 \(b_{i&#39;}\) 选中了 \(b_i-mid\) 说明反悔，将 \(a_j\) 与 \(b_{i&#39;}\) 配对。
贪心的时候需要记录已经配的对数，优先队列中需要对 \(-a_j\) 和 \(b_i-mid\) 打标记进行区分，匹配到前者时才增加成功对数。
发现整数域上仍然必有解（答案为整，倒推），不用打浮点数二分 neiher.

#include &lt;bits/stdc++.h&gt;
const long long inf = 2e9 + 5;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n, k;
    std::cin &gt;&gt; n &gt;&gt; k;
    std::vector&lt;int&gt; a(n + 1), b(n + 1);
    for (int i = 1; i &lt;= n; ++i)
        std::cin &gt;&gt; a[i];
    for (int i = 1; i &lt;= n; ++i)
        std::cin &gt;&gt; b[i];
    auto calc = [&amp;](long long mid) &#123;
        std::priority_queue&lt;std::pair&lt;long long, int&gt; &gt; q;
        int cnt = 0;
        auto res(0ll);
        for (int i = 1; i &lt;= n; ++i) &#123;
            q.emplace(-a[i], 1);
            auto [v, ty] = q.top();
            if (mid + v - b[i] &gt;= 0) &#123;
                q.pop(), cnt += ty;
                res += mid + v - b[i], q.emplace(b[i] - mid, 0);
            &#125;
        &#125;
        return std::make_pair(cnt, res);
    &#125;;
    auto res(inf);
    for (long long l = 1ll, r = inf, mid; l &lt;= r; ) &#123;
        mid = (l + r) &gt;&gt; 1;
        auto t(calc(mid));
        if (t.first &gt;= k)
            r = mid - 1, res = -(t.second - k * mid);
        else
            l = mid + 1;
    &#125;
    std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;


区间分拆问题
目标：尝试将 \(a_{1\sim n}\) 分割成恰好 \(k\) 段，定义 \(w(i,j)\) 为将 \([i,j]\) 作为一段的代价，求代价最值。其中 \(w(i,j)\) 满足四边形不等式。
不妨设求最小代价。定义 \(f(i,j)\) 在 \(i\) 处分第 \(j\) 段，那么有：
\[
f(i,j)=\min(f(i-1,p-1)+w(p,j)).
\]

有定理：若 \(w(i,j)\) 满足四边形不等式，那么有 \(f(i-1,j)\le f(i,j)\le f(i,j+1)\)，从 \(f\) 定义出发很好感性理解。

那么可以从这一点出发，\(p\) 这一维就可以被摊掉，做到 \(O(n(n+m))\)。

有定理：若 \(w(i,j)\) 满足四边形不等式，那么 \(f_i(j)\) 是凸函数。

那很好了。直接冲刺 WQS 即可。

闵可夫斯基和
给定两个凸函数（当然是指 OI 中那种长得很直的函数），将它们的『边』拆下来过后，以某种方式拼在一起，使得最后得到一个新的凸函数。
按每条『边』的斜率归并一下就可以得到，显然答案存在且唯一，这个过程被称为闵可夫斯基和。可以发现这是一种最值 - 加卷积。
假设我们要求的 DP 数组是两个已知的子数组以类似的方法卷起来的，最后要求完整的 DP 数组（而非 WQS 中的单点值），就可以考虑闵可夫斯基和。
发现这个结构是很适合归并的，使用归并要求状态中含有版本维、因变量维。

例：It's Mooin' Time P
https://www.luogu.com.cn/problem/P11459
定义 \(w_i\) 为将 \([i,i+L)\) 改为 MOO 的代价，问题转化为选取 \(1\sim \frac nL\) 个不重区间的最小代价和。
尝试归并，每次将 \([l,mid]\) 和 \((mid, r]\) 卷起来。但是会有一点问题：如果恰好有区间卡在中间呢？
可以令 \(f_{l,r,0/1/2,0/1/2}(i)\) 表示在 \([l,r]\) 内选了 \(i\) 个 MOO，且两侧最远的被选点距离端点为 \(0/1/\ge 2\) 的 DP 值。然后可以进行相应的讨论、平移、闵可夫斯基和，最后将所有情况线性取 max 得到这一层的答案，容易发现得到的答案也是凸的。

#include &lt;bits/stdc++.h&gt;
const long long inf = 1e18;
int L;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n;
    std::cin &gt;&gt; L &gt;&gt; n;
    std::vector&lt;int&gt; a(n + 1);
    std::vector&lt;char&gt; t(n + 1);
    std::vector&lt;long long&gt; w(n + 1);
    for (int i = 1; i &lt;= n; ++i)
        std::cin &gt;&gt; t[i];
    for (int i = 1; i &lt;= n; ++i)
        std::cin &gt;&gt; a[i];
    for (int i = 1; i &lt;= n - L + 1; ++i) &#123;
        w[i] = a[i] * (t[i] != &#39;M&#39;);
        for (int j = i + 1; j &lt; i + L; ++j)
            w[i] += a[j] * (t[j] != &#39;O&#39;);
        // printf(&quot;[%d, %d]: %lld\n&quot;, i, i + L - 1, w[i]);
    &#125;
    if (L == 1) &#123;
        std::sort(w.begin() + 1, w.end());
        auto s(0ll);
        for (int i = 1; i &lt;= n; ++i) &#123;
            s += w[i];
            std::cout &lt;&lt; s &lt;&lt; &#39;\n&#39;;
        &#125;
        return 0;
    &#125;
    using arr = std::vector&lt;long long&gt;;
    using brr = std::vector&lt;arr&gt;;
    using crr = std::vector&lt;brr&gt;;
    struct node &#123;
        crr f;
        node(int len): f(L, brr(L, arr(len, inf))) &#123;
            for (int i = 0; i &lt; L; ++i)
                for (int j = 0; j &lt; L; ++j)
                    f[i][j][0] = 0ll;
            return;
        &#125;
        brr&amp; operator[] (int q) &#123; return f[q]; &#125;
    &#125;;
    auto upd = [&amp;](arr &amp;x, arr y) &#123;
        if (x.size() &lt; y.size())
            x.resize(y.size(), inf);
        for (int i = 0; i &lt; (int)y.size(); ++i)
            x[i] = std::min(x[i], y[i]);
        return;
    &#125;;
    auto merge = [&amp;](arr l, arr r) &#123;
        arr out((int)(l.size() + r.size()) - 1), dl(l.size()), dr(r.size());
        for (int i = 1; i &lt; (int)l.size(); ++i)
            dl[i] = l[i] - l[i - 1];
        for (int i = 1; i &lt; (int)r.size(); ++i)
            dr[i] = r[i] - r[i - 1];
        std::merge(dl.begin() + 1, dl.end(), dr.begin() + 1, dr.end(), out.begin() + 1);
        out[0] = l[0] + r[0];
        std::partial_sum(out.begin(), out.end(), out.begin());
        return out;
    &#125;;
    std::function&lt;node(int, int)&gt; calc = [&amp;](int l, int r) &#123;
        if (r - l + 1 &lt; 2 * L) &#123;
            node res(1);
            for (int ll = 0; ll &lt; L; ++ll)
                for (int rr = 0; rr &lt; L; ++rr)
                    if (l + ll &lt;= r - rr - L + 1) &#123;
                        res[ll][rr].resize(2, inf);
                        for (int i = l + ll; i &lt;= r - rr - L + 1; ++i)
                            res[ll][rr][1] = std::min(res[ll][rr][1], w[i]);
                        // printf(&quot;[%d, %d]: (%d, %d) = %lld\n&quot;, l, r, ll, rr, res[ll][rr][1]);
                    &#125;
            // for (int i = 0; i &lt; L; ++i)
            //     if (l + i + L - 1 &lt;= r) &#123;
            //         printf(&quot;[%d, %d]: (%d, %d) = %lld\n&quot;, l, r, i, r - (l + i + L - 1), w[l + i]);
            //         res[i][r - (l + i + L - 1)].emplace_back(w[l + i]);
            //     &#125;
            return res;
        &#125;   
        int mid = (l + r) &gt;&gt; 1;
        node tl(calc(l, mid)), tr(calc(mid + 1, r)), res((r - l + 1) / L + 1);
        for (int ll = 0; ll &lt; L; ++ll)
            for (int rr = 0; rr &lt; L; ++rr)
                res[ll][rr] = merge(tl[ll][0], tr[0][rr]);
        for (int ll = 0; ll &lt; L; ++ll)
            for (int rr = 0; rr &lt; L; ++rr)
                for (int i = 1; i &lt; L &amp;&amp; i &lt; mid; ++i)
                    upd(res[ll][rr], merge(merge(tl[ll][i], tr[L - i][rr]), &#123; 0, w[mid - i + 1] &#125;));
        for (int ll = 0; ll &lt; L; ++ll)
            for (int rr = L - 1; rr; --rr)
                upd(res[ll][rr - 1], res[ll][rr]);
        for (int rr = 0; rr &lt; L; ++rr)
            for (int ll = L - 1; ll; --ll)
                upd(res[ll - 1][rr], res[ll][rr]);
        // for (int i = 0; i &lt; L; ++i)
        //     for (int j = 0; j &lt; L; ++j) &#123;
        //         printf(&quot;  (%d, %d): &quot;, i, j);
        //         for (auto p : res[i][j])
        //             printf(&quot;%lld &quot;, p);
        //         puts(&quot;&quot;);
        //     &#125;
        return res;
    &#125;;
    auto res(calc(1, n));
    for (int i = 1; i &lt;= n / L; ++i)
        std::cout &lt;&lt; res[0][0][i] &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;


例：假人
https://www.becoder.com.cn/problem/47728
令 \(f_{i,j}\) 表示前 \(i\) 组选完占了 \(j\) 体积的最大价值。那么有 \(f_{i,j}=\max\{f_{i-1,k}+a_{i,j-k}\}\)。
袜，这个东西好凸的样子！啊？居然不是凸的？
事实上，有结论：若干个体积为 \(0\sim 4\) 的物品做背包，可以凑出值域内任意 \(24\) 的倍数。所以先把体积全部 \(-1\)，然后就可以得到体积为 \(0\sim 4\) 的物品。然后会发现他们按照模 \(12\) 的余数分别是凸的。
能感受到恶意了。然后就可以枚举体积，再闵可夫斯基和了。同样需要在状态中引入作为版本号的 \([l,r]\) 维，显然因变量是体积、版本号是组数。

#include &lt;bits/stdc++.h&gt;
const long long inf = 1e18;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;fake2.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n, m = 0;
    std::cin &gt;&gt; n;
    std::vector&lt;int&gt; siz(n + 1);
    std::vector&lt;std::vector&lt;int&gt; &gt; a(n + 1);
    for (int i = 1; i &lt;= n; ++i) &#123;
        std::cin &gt;&gt; siz[i], m += siz[i];
        a[i].resize(siz[i] + 1);
        for (int j = 1; j &lt;= siz[i]; ++j)
            std::cin &gt;&gt; a[i][j];
    &#125;
    using arr = std::vector&lt;long long&gt;;
    struct node &#123;
        std::vector&lt;arr&gt; f;
        node(): f(12) &#123;&#125;
        arr &amp;operator[] (int q) &#123;
            return f[q];
        &#125;
    &#125;;
    auto merge = [&amp;](arr &amp;p, arr &amp;q) &#123;
        arr res((int)(p.size() + q.size()) - 1), dp(p.size()), dq(q.size());
        std::adjacent_difference(p.begin(), p.end(), dp.begin());
        std::adjacent_difference(q.begin(), q.end(), dq.begin());
        std::merge(dp.begin() + 1, dp.end(), dq.begin() + 1, dq.end(), res.begin() + 1, std::greater&lt;long long&gt; ());
        res[0] = p[0] + q[0];
        std::partial_sum(res.begin(), res.end(), res.begin());
        return res;
    &#125;;
    auto upd = [&amp;](arr y, arr &amp;x, int tag) &#123;
        if (tag)
            y.insert(y.begin(), -inf);
        if (y.size() &gt; x.size())
            x.resize(y.size(), -inf);
        for (int i = 0; i &lt; (int)y.size(); ++i)
            x[i] = std::max(x[i], y[i]);
        return;
    &#125;;
    std::function&lt;node(int, int)&gt; calc = [&amp;](int l, int r) &#123;
        if (l == r) &#123;
            node res;
            for (int i = 1; i &lt;= siz[l]; ++i)
                res[i - 1].push_back(a[l][i]);
            return res;
        &#125;
        int mid = (l + r) &gt;&gt; 1;
        node tl(calc(l, mid)), tr(calc(mid + 1, r)), res;
        for (int p = 0; p &lt; 12; ++p)
            for (int q = 0; q &lt; 12; ++q)
                if (!tl[p].empty() &amp;&amp; !tr[q].empty())
                    upd(merge(tl[p], tr[q]), res[(p + q) % 12], p + q &gt;= 12);
        return res;
    &#125;;
    auto res(calc(1, n));
    for (int i = 0; i &lt;= m - n; ++i)
        std::cout &lt;&lt; res[i % 12][i / 12] &lt;&lt; &#39; &#39;;
    std::cout &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;


slope trick
对于一个 OI 中的凸函数，它是由一些斜率单调的线段拼接成的图形。
在这个前提下，发现可以用整个函数的左 / 右端点值（截距）和 \((n-1)\) 个斜率 / 差分信息描述函数。而这有时比直接维护 \(n\) 个点值有着更优美的性质，唤其为 slope trick。
例如，关于斜率序列，如果定义域不大，可以直接维护；如果它的变化次数不多，可以利用它的单调性质，用单调数据结构维护；如果它的值域很小，可以直接维护拐点。
注意前两种方法一般关注横坐标对应的函数值，所以自变量一般是和操作次数一类有关的；而这里关注函数最值而弱化了具体横坐标，操作次数一般会作为待最优化的因变量，例如：

我想要将数列通过若干次单点修改使序列单调，但不关心序列最终形态，问最小操作次数。
我想要让树上所有叶子到根的路径边权和相等，但不关心这个值是多少，问最小操作次数。

下面依次解决上述问题。

例：序列 sequence
https://www.luogu.com.cn/problem/P4597
暴力地，令 \(f_{i,j}\) 表示 \(a_i\) 最终被修改为 \(j\)，容易写出 DP 式子 \(f_{i,j}=\min\limits_{k\le j}\{f_{i-1,k}\}+|a_i-j|\)。
然后就会发现它的定义域实在是太大了！那如果关注斜率的变化情况呢？
令 \(f_{i-1}(k)\) 的极值点为 \(k_m\)，分类讨论拆绝对值和 min：

当 \(j\le a_i\) 时，\(f_i(j)=\min\limits_{k\le j}\{f_{i-1}(k)\}+a_i - j\)。

当 \(j &lt; k_m\) 时，\(f_i(j)=f_{i-1}(j)+a_i-j\)，斜率相对于 \(f_{i-1}(j)\) 整体减 \(1\)。我就说导数没白学吧
当 \(j \ge k_m\) 时，\(f_i(j)=f_{i-1}(k_m)+a_i-j\)，斜率为 \(-1\)。

当 \(j &gt; a_i\) 时，\(f_i(j)=\min\limits_{k\le j}\{f_{i-1}(k)\}+j-a_i\)。

当 \(j &lt; k_m\) 时，\(f_i(j)=f_{i-1}(j)+j-a_i\)，斜率相对于 \(f_{i-1}(j)\) 整体加 \(1\)。
当 \(j\ge k_m\) 时，\(f_i(j) = f_{i-1}(k_m)+j-a_i\)，斜率为 \(1\)。


如果现在我们掏一个支持区间加斜率、区间推平斜率且维护区间函数最值点的数据结构，那就太逆天了。一个经典的解决方案是用堆维护线段斜率的差分（也就是差分的差分）。
发现整体修改次数是 \(O(n)\) 的，且如果只看比 \(k_m\) 更左的 \(j\)（更靠右的已经与极值无关所以不用维护），那么就只需要维护区间减法。
如果将一次区间前缀减法看作一次前缀右端点入队，显然左侧某点 \(a\) 的实际被减次数为 \(a\) 入队的次数 + 所有右于 \(a\) 点的元素的入队次数。用大根堆维护这些元素，就可以快速维护整个斜率序列。例如 3 2 2 1，代表 \(3\) 处斜率为 \(-1\)，\(2\) 处斜率为 \(-3\)，\(1\) 处斜率为 \(-4\)。

当 \(a_i\ge k_m\) 时（容易发现它会成为新的 \(k_m\)），直接把 \(a_i\) 加入大根堆，就可以把 \(\le a_i\) 的所有位置斜率减去 \(1\)。
什么你问在 \(k_m\) 和 \(a_i\) 之间的推平怎么办？由于唯一右于它们的拐点 \(a_i\) 入了一次队，所以中间的元素斜率自然是 \(-1\) 啊。
当 \(a_i&lt;k_m\) 时，我们需要：

将 \(a_i\) 以左的位置斜率减去 \(1\)，直接将 \(a_i\) 入队即可。
将 \(a_i\) 和 \(k_m\) 之间的位置斜率加上 \(1\)，把 \(k_m\) 弹出（太好了就在队首）再把 \(a_i\) 加入即可。由于 \(k_m\) 显然是一个拐点，所以删除 \(k_m\) 并非虚空索敌，但注意 \(k_m\) 可能会变化成其后继。


其实就会发现还有一些有趣的小性质，比如 \(k_m\) 与队首等价（用于实现）；\(k_m\) 右侧斜率全部为 \(1\)，也是唯一可以取到的正斜率。

袜写起来好简单。
#include &lt;bits/stdc++.h&gt;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n;
    std::cin &gt;&gt; n;
    std::vector&lt;int&gt; a(n + 1);
    long long res = 0ll;
    std::priority_queue&lt;int&gt; q;
    for (int i = 1; i &lt;= n; ++i) &#123;
        std::cin &gt;&gt; a[i];
        if (i == 1 || a[i] &gt;= q.top())
            q.push(a[i]);
        else &#123;
            res += q.top() - a[i];
            q.pop(), q.push(a[i]), q.push(a[i]);
        &#125;
    &#125;
    std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;


例：烟花表演
https://www.luogu.com.cn/problem/P3642
设 \(f_{u,d}\) 表示在 \(u\) 子树中所有叶子距根均为 \(d\) 的最小代价。那么有：
\[
f_{u,d}=\sum\limits_{(v, w)\in u}\min\limits_{0\le w&#39;\le d}\{f_{v,d-w&#39;}+|w-w&#39;|\}.
\]
可以归纳证明 \(f_{u,d}\) 为凸；和上一题相似地，考虑用 \(f_v\) 的堆得到 \(f_u\) 的堆。
首先最外层是一个线性加，这其实就是把差分数组 / 斜率加起来，放到我们这个堆里面就是合并两个堆。虽然你可能和我一样不认识可并堆，但是你可以和我一样不会 pd_ds。
再看内层，发现和上一题长得像但其实不一样，呜呜呜。发现 \(|w-w&#39;|\) 是一个左右斜率分别为 \(-1,1\) 的分段函数，而左边类比可得斜率最大为 \(1\)。
由闵可夫斯基和，内层函数斜率 \(&lt;-1\) 的部分来自 \(f_{v,d-w&#39;}\)；\(=-1\) 的部分来自 \(f_{v,d-w&#39;}\) 和 \(|w-w&#39;|\) 的左半边（感谢 \(w&#39;\) 是有下确界的）；\(=0\) 的部分来自 \(f_{v,d-w&#39;}\)；\(&gt;0\) 的部分我们不关心。
最终函数图像的变化：水平部分的左端点右移了 \(w\)。找到 \(f_{v,d}\) 中的水平线段和斜率为 \(1\) 的线段，令其在堆中的值 \(+w\) 就能达到平移的目的。
但需要注意，此时仍然需要 保留内层函数中斜率为 \(1\) 的部分，但斜率 \(&gt;1\) 的部分被删除。原因如下：

绝对值函数与内层函数定义域相同，作闵可夫斯基和后，斜率为 \(1\) 的右侧线段会将 \(f_{v,d-w&#39;}\) 中原有的 \(&gt;1\) 的部分『挤』出定义域，故可以将其直接删除。
斜率为 \(1\) 的部分，虽然对内层函数中极值点无贡献，但在外层函数中极值点可能向右偏移，此时会对其产生影响，需要维护。

容易发现由于 \(w&#39;\) 的取值上限是 \(d\)，但 \(d\) 没有上界，所以每个内层函数的右侧都一定是一条斜率为 \(1\) 的射线；也就是说，每个外层函数一定有（儿子个数）个拐点（堆中元素），弹出这么多个就可以删除外层函数中斜率 \(&gt;1\) 的线段，顺便找到斜率为 \(0\) 和 \(1\) 的线段。

#include &lt;bits/stdc++.h&gt;
#include &lt;ext/pb_ds/priority_queue.hpp&gt;
const int inf= 0x3f3f3f3f;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n, m;
    std::cin &gt;&gt; n &gt;&gt; m, n += m;
    std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; g(n + 1);
    auto res(0ll);
    for (int i = 2, fa, w; i &lt;= n; ++i) &#123;
        std::cin &gt;&gt; fa &gt;&gt; w, res += w;
        g[fa].emplace_back(i, w);
    &#125;
    std::vector&lt;__gnu_pbds::priority_queue&lt;long long&gt; &gt; q(n + 1);
    std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;
        if (g[x].empty())
            q[x].push(0), q[x].push(0);
        else
            for (auto [i, w] : g[x]) &#123;
                DFS(i);
                for (int j = 1; j &lt; (int)g[i].size(); ++j)
                    q[i].pop();
                long long t1 = q[i].top(), t0;
                q[i].pop(), t0 = q[i].top(), q[i].pop();
                q[i].push(t1 + w), q[i].push(t0 + w);
                q[x].join(q[i]);
            &#125;
        // fprintf(stderr, &quot;size(%d) = %d\n&quot;, x, (int)q[x].size());
        return;
    &#125;;
    DFS(1);
    for (int i = 1; i &lt;= (int)g[1].size(); ++i)
        q[1].pop();
    for (; !q[1].empty(); q[1].pop())
        res -= q[1].top();
    std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;


例：Buy Low Sell High
https://codeforces.com/problemset/problem/865/D
令 \(f_{i,j}\) 表示在第 \(i\) 天结束后持有 \(j\) 支股票的最大收益。则 \(f_{i,j}=\max\{f_{i-1,j},f_{i-1,j-1}-a_i,f_{i-1,j+1}+a_i\}\)。
（由于这里和 max 有关所以需要精细描述凹凸了）发现就是把三个（可能）经过平移的（可能）凹的函数做线性 max。虽然实际上的结论『函数在整点上是凹的』不算太显然，但是可以猜是凹的。
线性 max 在 slope trick 中是不太能体现的，但我们发现这里是同一个凹函数向左上、右下平移同一个向量，希望得到新的凹函数不管是从差分角度还是图象，都能得到新函数由左上部分斜率 \(&gt;-a_i\) 的线段、两段斜率 \(=-a_i\) 的线段、右下部分斜率 \(&lt;-a_i\) 的线段组成。此外，由于向左上平移的函数有一处离开了定义域，还需将其剔除。
值得注意的是，当 \(-a_i\) 比最小斜率还要小时会有变化，可以画图看一下。

发现定义域是相对小的（\(0\le j\le n\)），故用优先队列维护整个斜率序列就可以快速插入两个 \(k=-a_i\) 的线段。容易发现顶点在 \(j=0\) 处取得（从图象和定义都易知），最右侧是只买不卖的最劣方案，可以倒推。

#include &lt;bits/stdc++.h&gt;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n;
    std::cin &gt;&gt; n;
    std::vector&lt;int&gt; a(n + 1);
    auto res = 0ll;
    for (int i = 1; i &lt;= n; ++i)
        std::cin &gt;&gt; a[i], res -= a[i];
    std::priority_queue&lt;int&gt; q;
    q.push(-a[1]);
    for (int i = 2; i &lt;= n; ++i)
        if (a[i] &lt; -q.top())
            q.push(-a[i]);
        else
            q.pop(), q.push(-a[i]), q.push(-a[i]);
    for (; !q.empty(); res -= q.top(), q.pop());
    std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;

]]></content>
      <tags>
        <tag>DP</tag>
        <tag>反悔贪心</tag>
        <tag>DP 优化</tag>
      </tags>
  </entry>
  <entry>
    <title>杂题选谈：DP 凸优化</title>
    <url>/20250709/</url>
    <content><![CDATA[Stewart’s theorem：在线段 \(AB\) 上取一点 \(M\)，使得 \(\vec{AB}=\lambda \vec{AM}\)。在 \(AB\) 上方任取一点 \(P\)，则有 \(PM^2=(1-\lambda) PA^2+\lambda PB^2-\lambda(1-\lambda) AB^2\)。


D. Akvizna
https://www.becoder.com.cn/contest/6393/problem/4
其实到这里应该发现了，WQS 的奖励都以一次项系数出现，原因也很显然，奖励的对象是一次项系数嘛。此外，WQS 内层 DP 数组的维度都应和操作次数无关，而 DP 值应为最大收益。这个也很显然。
令一轮比赛的惩罚是 \(mid\) 然后二分。令 \(f_{j}\) 表示剩余人数为 \(j\) 时的最大收益，那么有 \(f_{j}=\max\limits_{k\ge j}\left\{f_k+\frac {k-j}k\right\}-mid\)。最后在 \(f_0\) 处找答案即可。
然后就发现一个很可怕的问题，内层 DP 咋写。发现把 \(\frac {k-j}k\) 改写成 \(1-\frac jk\) 后出现交叉项，考虑斜优。令 \(a&lt;b\)，那么 \(a\) 优于 \(b\) 当且仅当 \(\dfrac {f_a-f_b}{\frac 1a - \frac 1b} &gt; j\)。维护单减的斜率即可。

笑话：二分 50 次不够，需要 60 次。
#include &lt;bits/stdc++.h&gt;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n, k;
    std::cin &gt;&gt; n &gt;&gt; k;
    double l = 0., r = 1e5, mid;
    auto calc = [&amp;](double mid) &#123;
        std::vector&lt;double&gt; f(n + 1, -1e18);
        f[n] = 0.;
        int h = 1, t = 0;
        std::vector&lt;int&gt; q(n + 1), p(n + 1);
        q[++t] = n;
        // printf(&quot;mid = %.3lf: \n&quot;, mid);
        for (int i = n - 1; ~i; --i) &#123;
            for (; h &lt; t &amp;&amp; (f[q[h + 1]] - f[q[h]]) / (1. / q[h + 1] - 1. / q[h]) &gt;= i; ++h);
            f[i] = f[q[h]] + 1. - i * 1.0 / q[h] - mid, p[i] = p[q[h]] + 1;
            // printf(&quot;  %d: f = %.3lf, p = %d, q[h] = %d(%.3lf / %d)\n&quot;, i, f[i], p[i], q[h], f[q[h]], p[q[h]]);
            if (i) &#123;
                for (; h &lt; t &amp;&amp; (f[i] - f[q[t]]) / (1. / i - 1. / q[t]) &gt;= (f[q[t]] - f[q[t - 1]]) / (1. / q[t] - 1. / q[t - 1]); --t);
                q[++t] = i;
            &#125;
        &#125;
        // printf(&quot;res = %.3lf\n&quot;, f[0] + p[0] * mid);
        return std::make_pair(f[0], p[0]);
    &#125;;
    // calc(0.);
    // return 0;
    double res(0.);
    for (int i = 1; i &lt;= 60; ++i) &#123;
        mid = (l + r) / 2.;
        auto t(calc(mid));
        if (t.second &gt;= k)
            l = mid, res = t.first + k * mid;
        else
            r = mid;
    &#125;
    std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(8) &lt;&lt; res &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;


E. Poborcy podatkowi
https://www.becoder.com.cn/contest/6393/problem/5
首先令 \(f_{u,l}(i),l=0,1,2,3\) 表示在 \(u\) 上挂了长度为 \(l\) 的半条链，共有 \(i\) 条整链的最大收益。
可以观察到是凸的。那么不难发现需要闵可夫斯基和，考虑 \(u\) 位置上的合并。首先需要注意到儿子上长度为 \(l\) 的链到父亲上会变成 \(l+1\)。显然每条可以不选；如果选了 \(cnt_a\) 条长度为 \(a\) 的半链，那么合并出来的结果是 \(cnt_1-cnt_3\) 条长度为 \(1\) 或 \(3\) 的链、\(cnt_2\bmod 2\) 条长度为 \(2\) 的链，并且要求两者不同时出现。发现这个东西基本上处理不了。
接着注意到这个形式有点像背包。但怎么处理 \(cnt_1\) 和 \(cnt_3\) 配对的这个要求呢？有个非常精妙的在物品体积上做文章的方法：
首先注意到我们最后的查询的答案肯定要求把所有儿子用完。那么不妨设体积之和为儿子总数 \(tot\)。接着，对 \(cnt_0\)（同时也是 \(cnt_4\)）没有限制，直接令其体积为 \(1\)。\(cnt_2\) 单独处理（等会儿会说），为了不对现在的问题产生影响也令其体积为 \(1\)。对于 \(cnt_1\) 和 \(cnt_3\)，显然两者平均体积需要为 \(1\)；你可以令 \(cnt_3\) 体积为 \(2\)，令 \(cnt_1\) 体积为 \(0\)。
接下来就有个很好的性质：\(cnt_1\) 必须和 \(cnt_3\) 配对才能让平均体积为 \(1\)。在 \(tot\) 处查找的答案，由 \(x\) 个体积不为 \(0\) 的物品和 \(tot-x\) 个体积为 \(0\) 的物品（\(cnt_1\)）组成，原因是背包会贪心地在所有『剩余』的分组中选择体积为 \(0\) 的一项。再计算一下 \(cnt_3\)，发现显然为 \(tot-x\)。符合目的。
在 \(dp_{tot}\) 处查找可以找到 \(cnt_1=cnt_3\) 时的答案；同理，在 \(dp_{tot-1},dp_{tot1+1}\) 处可以查找到 \(cnt_1=cnt_3\pm 1\) 的答案。
接下来再考虑 \(cnt_2\)，解决『\(cnt\bmod2=1\) 和 \(cnt_1\ne cnt_3\) 不能同时成立』的限制。那太好了，直接多开一维记录 \(cnt_2\bmod 2\) 即可。
啊啊太妙了。像利用体积为 \(-1,1\) 的随机数据背包期望最大体积不超过 \(\sqrt V\) 的那个方法，显然就没有办法利用凸性了。所以这或许是闵可夫斯基和做法的唯一解？
需要知道，如果设 \(cnt_1\) 为 \(2\) 而 \(cnt_3\) 为 \(0\)，始终会出一些问题。这个我和 yly 讨论了一下没啥结果。

#include &lt;bits/stdc++.h&gt;
const long long inf = 1e12;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;1.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n;
    std::cin &gt;&gt; n;
    std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; g(n + 1);
    for (int i = 1, x, y, w; i &lt; n; ++i) &#123;
        std::cin &gt;&gt; x &gt;&gt; y &gt;&gt; w;
        g[x].emplace_back(y, w), g[y].emplace_back(x, w);
    &#125;
    using arr = std::vector&lt;long long&gt;;
    std::vector&lt;arr&gt; f(n + 1, arr(4));
    struct node &#123;
        std::vector&lt;arr&gt; f;
        node(): f(2) &#123;&#125;
        node(std::vector&lt;arr&gt; f1): f(f1) &#123;&#125;
        arr&amp; operator[](int q) &#123;
            return f[q];
        &#125;
    &#125;;
    auto getmax = [&amp;](arr p, arr q) &#123;
        arr res(p);
        if (q.size() &gt; p.size())
            res.resize(q.size());
        for (int i = 0; i &lt; (int)q.size(); ++i)
            res[i] = std::max(res[i], q[i]);
        return res;
    &#125;;
    auto merge = [&amp;](arr &amp;p, arr &amp;q) &#123;
        arr res(p.size() + q.size() - 1), dp(p.size()), dq(q.size());
        std::adjacent_difference(p.begin(), p.end(), dp.begin());
        std::adjacent_difference(q.begin(), q.end(), dq.begin());
        std::merge(dp.begin() + 1, dp.end(), dq.begin() + 1, dq.end(), res.begin() + 1, std::greater&lt;long long&gt; ());
        res[0] = p[0] + q[0];
        std::partial_sum(res.begin(), res.end(), res.begin());
        return res;
    &#125;; 
    std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int fa) &#123;
        if ((int)g[x].size() == 1 &amp;&amp; x != 1) &#123;
            f[x][1] = f[x][2] = f[x][3] = -inf;
            return;
        &#125;
        int tot = (int)g[x].size() - (x != 1);
        std::vector&lt;arr&gt; w1(1), w2(1);
        for (auto [i, w] : g[x])
            if (i != fa) &#123;
                DFS(i, x);
                w1.push_back(&#123; f[i][0] + w, std::max(f[i][0], f[i][3] + w), f[i][2] + w &#125;);
                w2.push_back(&#123; -inf, f[i][1] + w &#125;);
            &#125;
        auto fun = [&amp;](arr &amp;p, arr &amp;q) &#123;
            arr res(p.size() + q.size() - 1, -inf);
            for (int ip = 0; ip &lt; 2; ++ip)
                for (int iq = 0; iq &lt; 2; ++iq) &#123;
                    arr tp, tq;
                    for (int i = ip; i &lt; (int)p.size(); i += 2)
                        tp.push_back(p[i]);
                    for (int i = iq; i &lt; (int)q.size(); i += 2)
                        tq.push_back(q[i]);
                    auto t = merge(tp, tq);
                    for (int i = 0; i &lt; (int)t.size(); ++i)
                        if (i * 2 + ip + iq &lt; (int)res.size())
                            res[i * 2 + ip + iq] = std::max(res[i * 2 + ip + iq], t[i]);
                &#125;
            return res;
        &#125;; 
        std::function&lt;node(int, int)&gt; calc = [&amp;](int l, int r) &#123;
            if (l == r)
                return node(&#123; w1[l], w2[l] &#125;);
            int mid = (l + r) &gt;&gt; 1;
            node t1(calc(l, mid)), t2(calc(mid + 1, r));
            return node(&#123; getmax(fun(t1[0], t2[0]), fun(t1[1], t2[1])),
                          getmax(fun(t1[0], t2[1]), fun(t1[1], t2[0])) &#125;);
        &#125;;
        auto t(calc(1, tot));
        f[x][0] = t[0][tot], f[x][1] = t[0][tot - 1], f[x][2] = t[1][tot], f[x][3] = t[0][tot + 1];
        return;
    &#125;;
    DFS(1, -1);
    std::cout &lt;&lt; f[1][0] &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;

]]></content>
      <tags>
        <tag>DP</tag>
        <tag>DP 优化</tag>
      </tags>
  </entry>
  <entry>
    <title>杂题选谈</title>
    <url>/20250712/</url>
    <content><![CDATA[我生待明日，万事成蹉跎。


town
https://www.becoder.com.cn/contest/6407/problem/1

给定一棵大小为 \(n\) 的树，点有点权，欲将树划分为若干个连通块，使得每个块内的点权异或和都为 \(x\)，求方案数，模 \(998244353\)。
\(n\le 10^6,0\le x\le 10^9\)。

记 \(u\) 引导的子树异或和为 \(s_u\)。把连通块转化为对断边的讨论。考察一条最末端的边，其下方子树的异或和一定为 \(x\)。
简单数归可得断掉的每一条边，其下方子树异或和为 \(x\) 或 \(0\)（那么显然有解的充要条件是 \(s_1=0\lor s_1=x\)）。考虑树形 DP，令 \(f_{u,0/1}\) 表示当前 DP 到 \(u\) 子树头上那条边，它连接了一个异或和为 \(s_u\) （或 \(s_u\oplus x\)）的连通块的合法方案数，分别代表已经『断』掉了偶数 / 奇数个合法连通块。
首先自然可以一条边都不断，\(f_{u,0}=1\)。那么更新就应为：
\[
f&#39;_{u,0}=f_{u,0}\cdot f_{v,0}+f_{u,1}\cdot f_{v,1}\\
f&#39;_{u,1}=f_{u,0}\cdot f_{v,1}+f_{u,1}\cdot f_{v,0}
\]
接着，如果 \(s_u\) 恰好为 \(0\) 或 \(x\)，这条边连接的连通块的异或和就可以是 \(x\)，那么就可以在这条边处断开，提供一个空连通块（加入异或和为 \(0\) 的方案）。
最后注意 \(x\) 可能为 \(0\)，需要特殊处理——每个 \(s_u=0\) 处都可以断开。
这个 DP 状态实在非常新奇；同时 DP 和删边又是分开的，显得非常割裂。看 sol、听 grisses 讲解的时候都完全一头雾水。quack 说这是因为我没做过连通块 DP /ll

#include &lt;bits/stdc++.h&gt;
const int mod = 998244353;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;ex_town1.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n, m;
    std::cin &gt;&gt; n &gt;&gt; m;
    std::vector&lt;int&gt; a(n + 1), s(n + 1);
    for (int i = 1; i &lt;= n; ++i)
        std::cin &gt;&gt; a[i];
    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);
    for (int i = 1, x, y; i &lt; n; ++i) &#123;
        std::cin &gt;&gt; x &gt;&gt; y;
        g[x].push_back(y), g[y].push_back(x);
    &#125;
    std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int fa) &#123;
        s[x] = a[x];
        for (auto i : g[x])
            if (i != fa) &#123;
                DFS(i, x);
                s[x] ^= s[i];
            &#125;
        return;
    &#125;;
    DFS(1, -1);
    if (s[1] != 0 &amp;&amp; s[1] != m) &#123;
        std::cout &lt;&lt; 0 &lt;&lt; &#39;\n&#39;;
        return 0;
    &#125;
    if (m == 0) &#123;
        auto res(1ll);
        for (int i = 2; i &lt;= n; ++i)
            if (s[i] == 0)
                (res *= 2) %= mod;
        std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
    &#125;
    else &#123;
        std::vector&lt;std::array&lt;long long, 2&gt; &gt; f(n + 1);
        DFS = [&amp;](int x, int fa) &#123;
            f[x][0] = 1ll;
            for (auto i : g[x])
                if (i != fa) &#123;
                    DFS(i, x);
                    std::tie(f[x][0], f[x][1]) = std::make_tuple((f[x][0] * f[i][0] + f[x][1] * f[i][1]) % mod, (f[x][0] * f[i][1] + f[x][1] * f[i][0]) % mod);
                &#125;
            if (x != 1) &#123;
                if (s[x] == m)
                    (f[x][1] += f[x][0]) %= mod;
                if (s[x] == 0)
                    (f[x][0] += f[x][1]) %= mod;
            &#125;
            // printf(&quot;f[%d][0] = %lld, f[%d][1] = %lld\n&quot;, x, f[x][0], x, f[x][1]);
            return;
        &#125;;
        DFS(1, -1);
        std::cout &lt;&lt; (s[1] == m ? f[1][0] : f[1][1]) &lt;&lt; &#39;\n&#39;;
    &#125;
    return 0;
&#125;


perm
https://www.becoder.com.cn/contest/6407/problem/3

给定一个长度为 \(n\)、元素两两不同的序列，你可以交换任意两个元素。试使用最少交换次数使得序列有序，问方案数。
\(n\le 10^6\)。

对于一个下标，将它和它上面元素的 rank 连有向边，那么每个下标的出、入度都为 \(1\)，则图由若干个简单环组成。
接着，考虑一次任意一次交换 \((x,y)\) 的操作会带来什么：

若 \(x,y\) 不在同一环上：
该操作使得 \(x,y\) 所在的环合为一个大环。
若 \(x,y\) 在同一环上：
该操作使得环以 \(x,y\) 为分界线裂成两个小环。

以得到 \(n\) 个自环为目标，数归得到，对于最优方案，当且仅当每次交换的目标都在同一环上。
考虑方案数。把一个大小为 \(k\) 的环，欲将其拆成 \(k\) 个自环，共需 \(k-1\) 次 有序 的拆解。
考虑 DP，令 \(f_k\) 为方案数，那么 \(f_k=\dfrac {k\sum\limits_{j=1}^{k-1} f_j\cdot f_{k-j}\cdot C_{k-2}^j}2\)。尝试打表，（惊讶地）发现 \(f_k=k^{k-2}\)。
不同的环之间的操作可以交错，看作多重集排列即可。

#include &lt;bits/stdc++.h&gt;
const int mod = 998244353;
int main() &#123;
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
    int n;
    std::cin &gt;&gt; n;
    std::vector&lt;int&gt; a(n + 1), p(n + 1);
    for (int i = 1; i &lt;= n; ++i)
        std::cin &gt;&gt; a[i], p[i] = i;
    std::sort(p.begin() + 1, p.end(), [&amp;](int i, int j) &#123; return a[i] &lt; a[j]; &#125;);
    std::vector&lt;int&gt; f(n + 1), siz(n + 1, 1);
    std::iota(f.begin() + 1, f.end(), 1);
    std::function&lt;int(int)&gt; find = [&amp;](int x) &#123;
        return x == f[x] ? x : f[x] = find(f[x]);
    &#125;;
    auto merge = [&amp;](int x, int y) &#123;
        x = find(x), y = find(y);
        if (x != y)
            siz[y] += siz[x], f[x] = y;
        return;
    &#125;;
    for (int i = 1; i &lt;= n; ++i)
        merge(i, p[i]);
    std::vector&lt;long long&gt; g(n + 1), fac(n + 1), inv(n + 1);
    g[1] = g[2] = 1ll, fac[0] = inv[0] = 1ll;
    for (int i = 1; i &lt;= n; ++i)
        fac[i] = fac[i - 1] * i % mod;
    auto qkp = [&amp;](long long x, int y) &#123;
        auto res(1ll);
        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)
            if (y &amp; 1)
                (res *= x) %= mod;
        return res;
    &#125;;
    inv[n] = qkp(fac[n], mod - 2);
    for (int i = n - 1; i; --i)
        inv[i] = inv[i + 1] * (i + 1) % mod;
    for (int i = 3; i &lt;= n; ++i)
        g[i] = qkp(i, i - 2);
    int cnt(0);
    auto res(1ll);
    for (int i = 1; i &lt;= n; ++i)
        if (f[i] == i) &#123;
            cnt += siz[i] - 1;
            (res *= g[siz[i]]) %= mod;
            (res *= inv[siz[i] - 1]) %= mod;
        &#125;
    (res *= fac[cnt]) %= mod;
    std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;


CF2122D Traffic Lights
https://codeforces.com/contest/2122/problem/D

给你一个由 \(n\) 个顶点和 \(m\) 条边组成的简单无向连通图。在顶点 \(1\) 有一个标记。认为初始时间为 \(t=0\)，在 \(t\) 秒后，如果标记位于点 \(u\) ，则必须执行以下操作之一：

等待一秒。
将标记沿 \(u\) 的第 \((t \bmod \mathrm{deg}(u) + 1)\) 条边移动，花费一秒。

计算将标记从顶点 \(1\) 移到顶点 \(n\) 所需的最短时间，以及在使总时间最小化的同时所能达到的最短等待时间。\(m\le 5\times 10^5\)。

能够发现这是一个边权和 dis 有关的最短路，本着分层图一类的想法，考察答案的最值。发现一个很松的上界是 \(O(m)\)；发现实际情况会比这个乐观得多，这个时候就会考虑用一些暴力做法草过去了。
实际上有一个上界是 \(3n\)：取一条最短路，则不存在路径外的点，与路径上至少四个点有连边，否则可以更新最短路。设最短路长 \(k\)，让每次等待时间取满，考察答案发现为 \(2k\)（路径上点之间）、\(3(n-k)\)（路径上与路径外），共为 \(\le 3n\)。还有一个上确界是 \(2n-3\)，可以欣赏一下 https://codeforces.com/blog/entry/144876?#comment-1295568，我没看懂 😰
总之可以猜到暴力 dij 上 DP 得到…… 啊题解怎么说是 \(O(n^2+m)\) 的。原因是求得答案上界之后就能暴力模拟这个过程了 😅

#include &lt;bits/stdc++.h&gt;
const int inf = 0x3f3f3f3f;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int T;
    for (std::cin &gt;&gt; T; T--; ) &#123;
        int n, m;
        std::cin &gt;&gt; n &gt;&gt; m;
        std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);
        for (int x, y; m--; ) &#123;
            std::cin &gt;&gt; x &gt;&gt; y;
            g[x].push_back(y), g[y].push_back(x);
        &#125;
        std::vector&lt;std::vector&lt;int&gt; &gt; dis(2, std::vector&lt;int&gt; (n + 1, inf));
        dis[1][1] = 0;
        for (int t = 0; ; ++t) &#123;
            auto &amp;d = dis[t &amp; 1], &amp;la = dis[(t &amp; 1) ^ 1];
            std::vector&lt;int&gt; (n + 1, inf).swap(d);
            for (int i = 1; i &lt;= n; ++i) &#123;
                int to = t % ((int)g[i].size());
                d[g[i][to]] = std::min(d[g[i][to]], la[i]);
                d[i] = std::min(d[i], la[i] + 1);
            &#125;
            if (d[n] != inf) &#123;
                std::cout &lt;&lt; t + 1 &lt;&lt; &#39; &#39; &lt;&lt; d[n] &lt;&lt; &#39;\n&#39;;
                break;
            &#125;
        &#125;
    &#125;
    return 0;
&#125;


ARC202A Merge and Increment
https://atcoder.jp/contests/arc202/tasks/arc202_a
假设相邻元素全部不同，至少在当前这一步有一个很显然的策略（记为 策略一）是选全局最小值，把它和它左边、右边更小的一个 merge 起来。
注意到如果当前全局最小值有相邻的偶数个，可以把相邻项合并一次，得到长度减半的区间，一定不劣（记为 策略二）；假如当前全局最小值存在相邻的奇数个，很容易注意到有两种处理方式：

选取偶数个应用策略二，剩余一个应用策略一。
花一步，补一个全局最小值，转化为策略二。

很容易发现第二种方式一定不劣 😅。模拟即可。

#include &lt;bits/stdc++.h&gt;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int T;
    for (std::cin &gt;&gt; T; T--; ) &#123;
        int n;
        std::cin &gt;&gt; n;
        std::vector&lt;std::pair&lt;int, int&gt; &gt; a(1);
        &#123;
            for (int i = 1, x; i &lt;= n; ++i) &#123;
                std::cin &gt;&gt; x;
                if (x != a.back().first)
                    a.emplace_back(x, 1);
                else
                    ++a.back().second;
            &#125;
            n = (int)a.size() - 1;
        &#125;
        std::vector&lt;int&gt; pre(n + 2), nex(n + 1), tag(n + 1);
        std::priority_queue&lt;std::pair&lt;int, int&gt;, std::vector&lt;std::pair&lt;int, int&gt; &gt;, std::greater&lt;std::pair&lt;int, int&gt; &gt; &gt; q;
        for (int i = 1; i &lt;= n; ++i) &#123;
            q.emplace(a[i].first, i);
            pre[i] = i - 1, nex[i] = i + 1;
        &#125;
        nex[0] = 1, pre[n + 1] = n;
        auto del = [&amp;](int i) &#123;
            tag[i] = 1;
            pre[nex[i]] = pre[i], nex[pre[i]] = nex[i];
            return;
        &#125;;
        auto res(0ll);
        for (; (int)q.size() &gt; 1;) &#123;
            auto [x, id] = q.top();
            q.pop();
            if (tag[id] || a[id].first != x)
                continue;
            if (a[id].second == 1) &#123;
                if (!pre[id] || (nex[id] != n + 1 &amp;&amp; a[nex[id]].first &lt;= a[pre[id]].first))
                    res += a[nex[id]].first - x, a[id].first = a[nex[id]].first;
                else
                    res += a[pre[id]].first - x, a[id].first = a[pre[id]].first;
            &#125;
            else &#123;
                if (a[id].second &amp; 1)
                    ++res, ++a[id].second;
                ++a[id].first, a[id].second /= 2;
            &#125;
            if (pre[id] &amp;&amp; a[id].first == a[pre[id]].first)
                a[id].second += a[pre[id]].second, del(pre[id]);
            if (nex[id] != n + 1 &amp;&amp; a[id].first == a[nex[id]].first)
                a[id].second += a[nex[id]].second, del(nex[id]);
            q.emplace(a[id].first, id);
        &#125;
        &#123;
            auto [x, id] = q.top();
            for ( ; a[id].second != 1; ) &#123;
                if (a[id].second &amp; 1)
                    ++res, ++a[id].second;
                ++a[id].first, a[id].second /= 2;
            &#125;
        &#125;
        std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
    &#125;
    return 0;
&#125;

]]></content>
      <tags>
        <tag>DP</tag>
        <tag>树形 DP</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>杂题选谈：决策单调性</title>
    <url>/20250715/</url>
    <content><![CDATA[『心静自然凉』大抵是因为情绪平和时副交感神经兴奋，体温略有降低导致的。吗？

其实是因为心脏停跳后血液循环终止、代谢中断，导致产热低于散热（？）

A - 征途
https://www.luogu.com.cn/problem/P4072
用完全平方公式展开得到 \(m^2\sigma^2=m\left(\sum {x_i}^2\right)-S^2\)，其中 \(S\) 为求和。
所以目标是最小化 \(\sum {x_i}^2\) 这个东西。令 \(f_{i,j}\) 表示第 \(i\) 天走到 \(j\)，得到：
\[
\begin{aligned}
f_{i,j}&amp;=\min\{f_{i-1,k}+(s_j-s_k)^2\}\\
&amp;=\min\{f_{i-1,k}-2\times s_j\times s_k+{s_k}^2\}+{s_j}^2
\end{aligned}
\]
最后得到的斜率式子是 \(\dfrac {f_{i - 1, a}-f_{i - 1, b}+{s_a}^2-{s_b}^2}{2(s_a-s_b)}&lt;s_j\)，由于 \(s_j\) 单增，单调队列维护递减斜率即可 更正：是递增斜率。原因是 \(&lt;\) 是弹出条件，而非保留条件……

#include &lt;bits/stdc++.h&gt;
const long long inf = 1e9;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n, m;
    std::cin &gt;&gt; n &gt;&gt; m;
    std::vector&lt;int&gt; a(n + 1);
    std::vector&lt;long long&gt; s(n + 1);
    auto sum(0ll);
    for (int i = 1; i &lt;= n; ++i) &#123;
        std::cin &gt;&gt; a[i];
        s[i] = s[i - 1] + a[i];
        sum += a[i];
    &#125;
    std::vector&lt;std::vector&lt;long long&gt; &gt; f(m + 1, std::vector&lt;long long&gt; (n + 1, inf));
    f[0][0] = 0ll;
    for (int i = 1; i &lt;= m; ++i) &#123;
        auto f1 = [&amp;](int a, int b) &#123;
            return f[i - 1][a] - f[i - 1][b] + s[a] * s[a] - s[b] * s[b];
        &#125;;
        auto f2 = [&amp;](int a, int b) &#123;
            return 2 * (s[a] - s[b]);
        &#125;;
        std::vector&lt;int&gt; q(n + 1);
        int h = 0, t = -1;
        q[++t] = i - 1;
        for (int j = i; j &lt;= n; ++j) &#123;
            for (; h &lt; t &amp;&amp; f1(q[h + 1], q[h]) &lt; s[j] * f2(q[h + 1], q[h]); ++h);
            f[i][j] = f[i - 1][q[h]] + (s[j] - s[q[h]]) * (s[j] - s[q[h]]);
            for (; h &lt; t &amp;&amp; f1(j, q[t]) * f2(q[t], q[t - 1]) &lt; f1(q[t], q[t - 1]) * f2(j, q[t]); --t);
            q[++t] = j;
        &#125;
    &#125;
    std::cout &lt;&lt; m * f[m][n] - sum * sum &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;


B - 刷野 III
https://www.luogu.com.cn/problem/P10074
发现最坏情况就是每次『试探』都不中的情况，再试探中最坏的那一个。为啥呢，相当于我们每次攻击的一定是未知元素中血最多的一个。既然已经试探出了比阈值大的所有元素，那么下一个攻击的就一定是阈值本身，如果这次跳过它，它就会成为下一次试探失败的元素。这显然不如一开始就直接用新阈值试探。
从大到小排序。令 \(f_{j, i}\) 表示只确定了前 \(i\) 大的数，已经杀了 \(j\) 个人的最坏情况最小代价。那么显然这一次的阈值是 \(a_i\)。随便选出上一次的阈值 \(a_k\)，那么中间这一段待确定的元素数量为 \(i-k\)。那么有：
\[
\begin{aligned}
f_{j, i}&amp;=\min\limits_{k&lt;i}\{f_{j-1,k}+(i-k)\times a_i\}\\
&amp;=\min\limits_{k&lt;i}\{f_{j-1,k}-k\times a_i\}+i\times a_i
\end{aligned}
\]
经过验证，虽然这个式子和题解长得不一样，但是是对的 因为我 n^3 暴力 A 了
推出斜优形式 \(\dfrac {f_{j-1,A}-f_{j-1,B}}{A-B}&lt;a_i\)，但我的朋友，\(a_i\) 是递减的。所以用单调栈维护递增斜率即可。或者你也可以学习 grisses 打一个单调队列上二分

#include &lt;bits/stdc++.h&gt;
const long long inf = 1e12;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;P10074_4.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n, m;
    std::cin &gt;&gt; n &gt;&gt; m;
    std::vector&lt;long long&gt; a(n + 1);
    for (int i = 1; i &lt;= n; ++i)
        std::cin &gt;&gt; a[i];
    std::sort(a.begin() + 1, a.end(), std::greater&lt;long long&gt; ());
    std::vector&lt;std::vector&lt;long long&gt; &gt; f(m + 1, std::vector&lt;long long&gt; (n + 1, inf));
    f[0][0] = 0ll;
    for (int j = 1; j &lt;= m; ++j) &#123;
        std::vector&lt;int&gt; q(n + 1);
        int t = -1;
        q[++t] = j - 1;
        auto f1 = [&amp;](int A, int B) &#123;
            return f[j - 1][A] - f[j - 1][B];
        &#125;;
        auto f2 =[&amp;](int A, int B) &#123;
            return A - B;
        &#125;;
        for (int i = j; i &lt;= n; ++i) &#123;
            for (; t &gt;= 1 &amp;&amp; f1(q[t], q[t - 1]) &gt; a[i] * f2(q[t], q[t - 1]); --t);
            f[j][i] = f[j - 1][q[t]] + (i - q[t]) * a[i];
            for (; t &gt;= 1 &amp;&amp; f1(i, q[t]) * f2(q[t], q[t - 1]) &lt; f1(q[t], q[t - 1]) * f2(i, q[t]); --t);
            q[++t] = i;
        &#125;
    &#125;
    auto res(inf);
    for (int i = m; i &lt;= n; ++i)
        res = std::min(res, f[m][i]);
    std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;


C - TRAKA
https://www.luogu.com.cn/problem/P7747
稍微手玩一下就可以发现，假如第 \(j\) 个人在第 \(i\) 次的工作时间为 \([L_{j,i},R_{j,i}]\)，第 \(i-1\) 次为 \([L_{j,i-1},R_{j,i-1}]\)，那么要求 \(L_{j,i}\ge R_{j,i-1}\)。
令 \(s_j\) 为 \(t\) 的前缀和。假设第 \(i-1\) 次加工于 \(x_{i-1}\) 开始，那么我们可以把上式转写为 \(x_{i}+s_{j-1}\times f_{i}\ge x_{i-1}+s_j\times f_{i-1}\)。也即 \(x_i-x_{i-1}\ge s_j\times f_{i-1}-s_{j-1}\times f_i\)。
显然需要找到一个 \(j\) 使得 RSH 取得最大值；现在就可以考虑斜率优化了。由于所有项都和 \(i\) 有关，想到两边同除 \(f_{i}\) 消掉一个 \(i\) 有关的系数，最后化出来的斜优形式是 \(\dfrac {s_A-s_B}{s_{A-1}-s_{B-1}}&gt;\dfrac {f_{i-1}}{f_i}\)。由于 RSH 不单调，把所有 \(j\) 塞到队列里维护递减斜率，打二分即可。

#include &lt;bits/stdc++.h&gt;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n, m;
    std::cin &gt;&gt; n &gt;&gt; m;
    std::vector&lt;long long&gt; a(n + 1), w(m + 1), s(n + 1);
    for (int i = 1; i &lt;= n; ++i)
        std::cin &gt;&gt; a[i], s[i] = s[i - 1] + a[i];
    for (int i = 1; i &lt;= m; ++i)
        std::cin &gt;&gt; w[i];
    std::vector&lt;long long&gt; f(m + 1);
    std::vector&lt;int&gt; q(n + 1);
    int h = 0, t = -1;
    q[++t] = 1;
    for (int i = 2; i &lt;= n; ++i) &#123;
        for (; h &lt; t &amp;&amp; (s[i] - s[q[t]]) * (s[q[t] - 1] - s[q[t - 1] - 1]) &gt; (s[q[t]] - s[q[t - 1]]) * (s[i - 1] - s[q[t] - 1]); --t);
        q[++t] = i;
    &#125;
    for (int i = 2; i &lt;= m; ++i) &#123;
        int to = q[h];
        for (int l = h + 1, r = t, mid; l &lt;= r; ) &#123;
            mid = (l + r) &gt;&gt; 1;
            if ((s[q[mid]] - s[q[mid - 1]]) * w[i - 1] &gt; w[i] * (s[q[mid] - 1] - s[q[mid - 1] - 1]))
                to = q[mid], l = mid + 1;
            else
                r = mid - 1;
        &#125;
        f[i] = f[i - 1] + s[to] * w[i - 1] - s[to - 1] * w[i];
    &#125;
    std::cout &lt;&lt; f[m] + w[m] * s[n] &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;


D - 柠檬
https://www.luogu.com.cn/problem/P5504

观察零：原问题『从两端取』可以转化为分段问题，故从其中一端考虑即可。
观察一：若有一段连续的 \(x\)，完整的比拆开的更优。
观察二：如果一段 \(x\) 中夹杂了一些其他元素，那么在哪里分段是说不准的。
观察三：如果选取的区间是 \([1,r]\)，那么贪心地想，\(a_r\) 一定是关键值，不然取 \(a_r\) 就浪费了。
观察四：如果选取的区间是 \([l,r]\)，那么由观察四，\(a_l=a_r\)，且该值为关键值。

结合这几个观察，令 \(c_i\) 表示 \(a_i\) 在 \([1,i]\) 中出现次数，\(f_i\) 表示这一段以 \(i\) 结尾的最大价值：
\[
\begin{aligned}
f_i&amp;=\max\limits_{j&lt;i,a_{j+1}=a_i}\{f_j+a_i\times (c_i-c_{j + 1} + 1)^2\}\\
&amp;=\max\limits_{j&lt;i,a_{j+1}=a_i}\{f_j+a_{j+1}\times {c_{j+1}}^2-2\times c_i\times a_{j+1}\times c_{j+1}-2\times c_{j+1}\times a_{j+1}\}+a_i\times(c_i-1)^2
\end{aligned}
\]
（怎么这么大一堆。）最后可以化出 \(\dfrac {f_A-f_B+a_{A+1}\cdot c_{A+1}\cdot (c_{A+1}-2)-a_{B+1}\cdot c_{B+1}\cdot (c_{B+1}-2)}{2(c_{A+1} - c_{B+1})}&gt;c_i\times a_i\)。发现对于每一种 \(a_i\)，\(c_i\times a_i\) 是单增的。单调栈维护即可。
这其实提醒我们关于代换的问题——显然，当与 \(i\) 的项、与 \(j\) 有关的项之间存在代换关系时，应该尽量往 \(j\) 的方向靠。

#include &lt;bits/stdc++.h&gt;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;7.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n;
    std::cin &gt;&gt; n;
    std::vector&lt;long long&gt; a(n + 1), c(n + 1), la(10001);
    for (int i = 1; i &lt;= n; ++i) &#123;
        std::cin &gt;&gt; a[i];
        c[i] = c[la[a[i]]] + 1, la[a[i]] = i;
    &#125;
    std::vector&lt;long long&gt; f(n + 1);
    std::vector&lt;int&gt; _t(10001, -1);
    std::vector&lt;std::vector&lt;int&gt; &gt; _q(10001);
    auto f1 = [&amp;](int A, int B) &#123;
        return f[A] - f[B] + a[A + 1] * c[A + 1] * (c[A + 1] - 2) - a[B + 1] * c[B + 1] * (c[B + 1] - 2);
    &#125;;
    auto f2 = [&amp;](int A, int B) &#123;
        return 2 * (c[A + 1] - c[B + 1]);
    &#125;;
    ++_t[a[1]], _q[a[1]].push_back(0);
    for (int i = 1; i &lt;= n; ++i) &#123;
        &#123;
            auto &amp;t = _t[a[i]];
            auto &amp;q = _q[a[i]];
            for (; t &gt;= 1 &amp;&amp; f1(q[t], q[t - 1]) &lt; c[i] * a[i] * f2(q[t], q[t - 1]); --t);
            f[i] = f[q[t]] + a[i] * (c[i] - c[q[t] + 1] + 1) * (c[i] - c[q[t] + 1] + 1);
        &#125;
        if (i &lt; n) &#123;
            auto &amp;t = _t[a[i + 1]];
            auto &amp;q = _q[a[i + 1]];
            for (; t &gt;= 1 &amp;&amp; f1(i, q[t]) * f2(q[t], q[t - 1]) &gt; f1(q[t], q[t - 1]) * f2(i, q[t]); --t);
            q.resize(++t + 1), q[t] = i;
        &#125;
    &#125;
    std::cout &lt;&lt; f[n] &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;


E - Knapsack with Diminishing Values
https://atcoder.jp/contests/abc373/tasks/abc373_f
发现和 单调队列优化多重背包 有异曲同工之妙。
不妨令 \(v_i\) 表示体积，\(w_i\) 表示价值。对于每一个 \(i\)，把所有体积按模 \(v_i\) 的余数分类，设为 \(j\cdot v_i+x\)。对于 \(k\cdot v_i+x\)，有：
\[
\begin{aligned}
f_{i,j\cdot v_i+x}&amp;=\max\limits_{k&lt;j}\{f_{i-1,k\cdot v_i+x}+(j-k)\cdot w_i-(j-k)^2\}\\
&amp;=\max\limits_{k&lt;j}\{f_{i-1,k\cdot v_i+x}-k\cdot w_i-k^2+2\times j\times k\}-j^2+j\cdot w_i
\end{aligned}
\]
则得到 \(\dfrac {f_{i-1,A\cdot v_i+x}-f_{i-1,B\cdot v_i+x}+(B-A)\cdot w_i - A^2+B^2}{2(B-A)}&lt;j\)。注意分母为负。总之单调队列维护递增斜率即可。

#include &lt;bits/stdc++.h&gt;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n, m;
    std::cin &gt;&gt; n &gt;&gt; m;
    std::vector&lt;long long&gt; v(n + 1), w(n + 1);
    std::vector&lt;std::vector&lt;long long&gt; &gt; f(n + 1, std::vector&lt;long long&gt; (m + 1));
    for (int i = 1; i &lt;= n; ++i) &#123;
        std::cin &gt;&gt; v[i] &gt;&gt; w[i];
        for (int x = 0; x &lt; v[i]; ++x) &#123;
            int h = 0, t = -1;
            std::vector&lt;int&gt; q;
            auto f1 = [&amp;](int A, int B) &#123;
                return f[i - 1][A * v[i] + x] - f[i - 1][B * v[i] + x] + (B - A) * w[i] - A * A + B * B;
            &#125;;
            auto f2 = [&amp;](int A, int B) &#123;
                return 2 * (B - A);
            &#125;;
            for (int j = 0, J = x; J &lt;= m; ++j, J += v[i]) &#123;
                for (; h &lt; t &amp;&amp; f1(q[h + 1], q[h]) &gt; j * f2(q[h + 1], q[h]); ++h);
                f[i][J] = f[i - 1][J];
                if (h &lt;= t)
                    f[i][J] = std::max(f[i][J], f[i - 1][q[h] * v[i] + x] + (j - q[h]) * w[i] - (j - q[h]) * (j - q[h]));
                for (; h &lt; t &amp;&amp; f1(j, q[t]) * f2(q[t], q[t - 1]) &lt; f1(q[t], q[t - 1]) * f2(j, q[t]); --t);
                q.resize(++t + 1), q[t] = j;
            &#125;
        &#125;
    &#125;
    std::cout &lt;&lt; f[n][m] &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;


F - Managing Telephone Poles
https://codeforces.com/problemset/problem/1575/M
？观察到性质然后被自己忽略了。非常值得批评。
不难写出类似斜率优化的式子 \(S(i,j)=\min\{ {x_k}^2-2\times i\times x_k+{y_k}^2-2\times j \times y_k\}+i^2+j^2\)。
会下意识尝试固定 \(i\)，就可以 \(O(n^2m)\) 完成任务，似乎不太行。顺着这个想法会观察到，固定 \(i\) 之后，每一列的 poles 中只有和第 \(i\) 行最近的才会有贡献。
这个是好做的，且这样的相邻点数量是 \(O(m)\) 的；于是将 \(i\) 视为常数进行变形，若将所有 poles 按 \(y\) 从小到大排序就能得到斜率形式 \(\dfrac { {x_A}^2-{x_B}^2+{y_A}^2-{y_B}^2-2\times i\times(x_A-x_B)}{2(y_A-y_B)}&lt;j\)。维护递增斜率就能 \(O(n^2)\) 完成问题。
那么找相邻点这一步大可以摆烂写二分。所以总共是 \(O(nm\log m)\) 的。
不要像我一样把两边最近的都加进队列，不然你会有分母为 \(0\) 的斜率 

#include &lt;bits/stdc++.h&gt;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n, m;
    std::cin &gt;&gt; n &gt;&gt; m, ++n, ++m;
    std::vector&lt;std::vector&lt;int&gt; &gt; tag(n + 1, std::vector&lt;int&gt; (m + 1));
    std::vector&lt;std::vector&lt;int&gt; &gt; g(m + 1);
    for (int i = 1; i &lt;= n; ++i)
        for (int j = 1; j &lt;= m; ++j) &#123;
            char t;
            std::cin &gt;&gt; t;
            if (t == &#39;1&#39;)
                g[j].push_back(i), tag[i][j] = 1;
        &#125;
    struct node &#123; long long x, y; &#125;;
    auto res(0ll);
    for (int i = 1; i &lt;= n; ++i) &#123;
        std::vector&lt;node&gt; p;
        for (int j = 1; j &lt;= m; ++j) &#123;
            int to = std::lower_bound(g[j].begin(), g[j].end(), i) - g[j].begin();
            if (to &lt; (int)g[j].size()) &#123;
                p.push_back(&#123; g[j][to], j &#125;);
                if (g[j][to] != i &amp;&amp; to != 0 &amp;&amp; g[j][to] - i &gt; i - g[j][to - 1])
                    p.back() = &#123; g[j][to - 1], j &#125;;
            &#125;
            else if (to != 0)
                p.push_back(&#123; g[j][to - 1], j &#125;);
        &#125;
        std::vector&lt;int&gt; q(m + 1);
        int h = 0, t = -1;
        auto f1 = [&amp;](node A, node B) &#123;
            return A.x * A.x - B.x * B.x + A.y * A.y - B.y * B.y - 2 * i * (A.x - B.x);
        &#125;;
        auto f2 = [&amp;](node A, node B) &#123;
            return 2 * (A.y - B.y);
        &#125;;
        for (int j = 0; j &lt; (int)p.size(); ++j) &#123;
            for (; h &lt; t &amp;&amp; f1(p[j], p[q[t]]) * f2(p[q[t]], p[q[t - 1]]) &lt; f1(p[q[t]], p[q[t - 1]]) * f2(p[j], p[q[t]]); --t);
            q[++t] = j;
        &#125;
        for (int j = 1; j &lt;= m; ++j) &#123;  
            for (; h &lt; t &amp;&amp; f1(p[q[h + 1]], p[q[h]]) &lt; j * f2(p[q[h + 1]], p[q[h]]); ++h);
            res += (p[q[h]].x - i) * (p[q[h]].x - i) + (p[q[h]].y - j) * (p[q[h]].y - j);
        &#125;
    &#125;
    std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;


G - Partition Game
https://codeforces.com/problemset/problem/1527/E
发现不太斜优，终于给我浸泡了两天斜优内容的大脑加了勺新的底物。
令 \(f_{i,j}\) 表示第 \(i\) 段以 \(j\) 结尾的最小代价；对 \(w\) 套用四边形不等式变式 \(w(l-1,r+1)+w(l,r)\ge w(l-1,r)+w(l,r+1)\) 发现成立（其中大多数时候能取等；部分特殊情况取到大于号）。
那么发现可以用分治优化。发现 \(w\) 不那么能快速求；还是套用 Yet Another Minimization Problem 中的方法，用类似莫队的方式求解。
发现这个莫队套路也很熟悉了，直接用双端队列维护即可。复杂度 \(O(nk\log n)\)，看着不太安全。但注意到我们在 20 个月前的提交中使用了 \(O(nk\log n)\) 的线段树，所以能过的兄弟。

鉴于 deque 的时空常数都大得吓人，所以我用静态 vector 模拟 deque 了。
跑得比我之前线段树的一半还快，兄弟。
#include &lt;bits/stdc++.h&gt;
const int inf = 1e18;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n, m;
    std::cin &gt;&gt; n &gt;&gt; m;
    std::vector&lt;std::vector&lt;int&gt; &gt; pos(n + 1);
    std::vector&lt;int&gt; a(n + 1), _h(n + 1), _t(n + 1, -1);
    for (int i = 1; i &lt;= n; ++i)
        std::cin &gt;&gt; a[i], pos[a[i]].push_back(i);
    std::vector&lt;std::vector&lt;long long&gt; &gt; f(m + 1, std::vector&lt;long long&gt; (n + 1, inf));
    f[0][0] = 0ll;
    auto w = [&amp;](int ql, int qr) &#123;
        static int l = 1, r = 0;
        static auto res(0ll);
        for (; l &gt; ql; ) &#123;
            --l;
            auto &amp;h = _h[a[l]], &amp;t = _t[a[l]];
            auto &amp;q = pos[a[l]];
            if (h &lt;= t)
                res -= q[t] - q[h];
            res += q[t] - q[--h];
        &#125;
        for (; r &gt; qr; ) &#123;
            auto &amp;h = _h[a[r]], &amp;t = _t[a[r]];
            auto &amp;q = pos[a[r]];
            res -= q[t--] - q[h];
            if (h &lt;= t)
                res += q[t] - q[h];
            --r;
        &#125;
        for (; r &lt; qr; ) &#123;
            ++r;
            auto &amp;h = _h[a[r]], &amp;t = _t[a[r]];
            auto &amp;q = pos[a[r]];
            if (h &lt;= t)
                res -= q[t] - q[h];
            res += q[++t] - q[h];
        &#125;
        for (; l &lt; ql; ) &#123;
            auto &amp;h = _h[a[l]], &amp;t = _t[a[l]];
            auto &amp;q = pos[a[l]];
            res -= q[t] - q[h++];
            if (h &lt;= t)
                res += q[t] - q[h];
            ++l;
        &#125;
        return res;
    &#125;;
    for (int t = 1; t &lt;= m; ++t) &#123;
        std::function&lt;void(int, int, int, int)&gt; calc = [&amp;](int l, int r, int lp, int rp) &#123;
            if (l &gt; r)
                return;
            if (l == r) &#123;
                for (int i = lp; i &lt;= rp &amp;&amp; i &lt; l; ++i)
                    f[t][l] = std::min(f[t][l], f[t - 1][i] + w(i + 1, l));
                return;
            &#125;
            int mid = (l + r) &gt;&gt; 1, p = -1;
            for (int i = lp; i &lt;= rp &amp;&amp; i &lt; mid; ++i)
                if (f[t - 1][i] + w(i + 1, mid) &lt; f[t][mid])
                    f[t][mid] = f[t - 1][i] + w(i + 1, mid), p = i;
            calc(l, mid - 1, lp, p), calc(mid + 1, r, p, rp);
            return;
        &#125;;
        calc(t, n, t - 1, n - 1);
    &#125;
    std::cout &lt;&lt; f[m][n] &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;


H - Battle Lemmings
https://codeforces.com/problemset/problem/1420/E
容易发现 \(0\) 的数目不变，答案就是 \(0\) 的对数 - 连续 \(0\) 的对数。
然后有一个我们很熟悉的 trick，随便找一个目标序列，那么花费的操作次数就是每个对应的 \(1\) 的位置差。令 \(f_{i,j,k}\) 表示用了 \(i\) 次操作、\(j\) 个 \(1\)、最后一个 \(1\) 在 \(k\) 的最小连续 \(0\) 对数。那么有：
\[
\begin{aligned}
f_{i,j,k}&amp;=\min\limits_{p&lt;k}\left\{f_{i-|k-pos_j|,j-1,p}+\dfrac {(k-p-1)(k-p-2)}2\right\}\\
&amp;=\min\left\{f_{i-|k-pos_j|,j-1,p}-k\cdot p+\dfrac {p(p + 2)}2\right\}+\dfrac {k^2-3k+2}2
\end{aligned}
\]
发现这个式子是 \(O(n^5)\) 的，而且看起来很斜优，化为斜率形式 \(\dfrac{2\times f_A-2\times f_B+A(A+2)-B(B+2)}{2(A-B)}&lt;k\)。维护递增斜率就可以 \(O(n^4)\) 做了。
Tip：当时写着写着愣住了，比如这个 \(i-|k-pos_j|\) 不是一直在动吗。解决方案？同时维护很多个队列即可。

注意还要把最后一个 \(1\) 之后连续 \(0\) 的代价算上。
#include &lt;bits/stdc++.h&gt;
const long long inf = 1e9;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n;
    std::cin &gt;&gt; n;
    std::vector&lt;int&gt; a(n + 1);
    std::vector&lt;long long&gt; pos(1);
    for (int i = 1; i &lt;= n; ++i) &#123;
        std::cin &gt;&gt; a[i];
        if (a[i] == 1)
            pos.push_back(i);
    &#125;
    int m = n * (n - 1) / 2;
    std::vector&lt;std::vector&lt;std::vector&lt;long long&gt; &gt; &gt; f(pos.size(), std::vector&lt;std::vector&lt;long long&gt; &gt; (m + 1, std::vector&lt;long long&gt; (n + 1, inf)));
    f[0][0][0] = 0ll;
    for (int j = 1; j &lt; (int)pos.size(); ++j) &#123;
        std::vector&lt;std::vector&lt;int&gt; &gt; _q(m + 1, std::vector&lt;int&gt; (n + 1));
        std::vector&lt;int&gt; _h(m + 1), _t(m + 1, -1);
        for (int k = 0; k &lt;= n; ++k)
            for (int i = m; i &gt;= 0; --i) &#123;
                if (i &gt;= std::abs(k - pos[j])) &#123;
                    auto f1 = [&amp;](long long A, long long B) &#123;
                        return 2 * f[j - 1][i - std::abs(k - pos[j])][A] - 2 * f[j - 1][i - std::abs(k - pos[j])][B] + A * (A + 2) - B * (B + 2);
                    &#125;;
                    auto f2 = [&amp;](long long A, long long B) &#123;
                        return 2 * (A - B);
                    &#125;;
                    auto &amp;h = _h[i - std::abs(k - pos[j])], &amp;t = _t[i - std::abs(k - pos[j])];
                    auto &amp;q = _q[i - std::abs(k - pos[j])];
                    for (; h &lt; t &amp;&amp; f1(q[h + 1], q[h]) &lt; k * f2(q[h + 1], q[h]); ++h) &#123;&#125;
                    if (h &lt;= t)
                        f[j][i][k] = std::min(inf, f[j - 1][i - std::abs(k - pos[j])][q[h]] + (k - q[h] - 1) * (k - q[h] - 2) / 2);
                &#125;
                auto f1 = [&amp;](long long A, long long B) &#123;
                    return 2 * f[j - 1][i][A] - 2 * f[j - 1][i][B] + A * (A + 2) - B * (B + 2);
                &#125;;
                auto f2 = [&amp;](long long A, long long B) &#123;
                    return 2 * (A - B);
                &#125;;
                auto &amp;h = _h[i], &amp;t = _t[i];
                auto &amp;q = _q[i];
                for (; h &lt; t &amp;&amp; f1(k, q[t]) * f2(q[t], q[t - 1]) &lt; f1(q[t], q[t - 1]) * f2(k, q[t]); --t);
                q[++t] = k;
            &#125;
    &#125;
    auto res(-inf);
    int cnt = n - (int)pos.size() + 1;
    cnt = cnt * (cnt - 1) / 2;
    for (int i = 0; i &lt;= m; ++i) &#123;
        for (int k = 0; k &lt;= n; ++k)
            res = std::max(res, cnt - f.back()[i][k] - (n - k) * (n - k - 1) / 2);
        std::cout &lt;&lt; res &lt;&lt; &#39; &#39;;
    &#125;
    std::cout &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;


A - Yakiniku Restaurants
https://atcoder.jp/contests/arc067/tasks/arc067_d
发现固定左右端点后，收益是可以贪心算的；下意识想到只固定左端点，那么右端点应该就可以用单调队列之类的搞一搞。
先提前把所有东西塞到队列里。左端点一开始在最右边；往左边动一下之后，就可以更新每种菜的队列；发现在所有元素中作决策点的不总是队头；这个地方用 单调递减的单调栈 是极好的。这里的单调栈其实就类似 四边形不等式中的单调数据结构 了。
维护单调栈中每个决策点的影响区间；显然每个右端点的答案变化量相同；用个类似于差分的东西记录一下就好了。
复杂度 \(O(n^2)\)。

#include &lt;bits/stdc++.h&gt;
const long long inf = 1e18;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n, m;
    std::cin &gt;&gt; n &gt;&gt; m;
    std::vector&lt;long long&gt; s(n + 1), f(n + 1);
    for (int i = 2; i &lt;= n; ++i) &#123;
        std::cin &gt;&gt; s[i], s[i] += s[i - 1];
        f[i] = -s[i];
    &#125;
    std::vector&lt;std::vector&lt;int&gt; &gt; a(n + 1, std::vector&lt;int&gt; (m + 1));
    for (int i = 1; i &lt;= n; ++i)
        for (int j = 1; j &lt;= m; ++j)
            std::cin &gt;&gt; a[i][j];
    struct node &#123; int j, l, r; &#125;;
    std::vector&lt;std::stack&lt;node&gt; &gt; _q(m + 1);
    auto res(-inf);
    for (int l = n; l; --l) &#123;
        std::vector&lt;long long&gt; d(n + 1);
        auto add = [&amp;](int l, int r, long long v) &#123;
            d[l] += v;
            if (r != n)
                d[r + 1] -= v;
            return;
        &#125;;
        for (int j = 1; j &lt;= m; ++j) &#123;
            auto &amp;q = _q[j];
            node now = &#123; j, l, l &#125;;
            add(l, l, a[l][j]);
            for (; !q.empty() &amp;&amp; a[l][j] &gt;= a[q.top().l][q.top().j]; q.pop()) &#123;
                now.r = q.top().r;
                add(q.top().l, q.top().r, a[l][j] - a[q.top().l][q.top().j]);
            &#125;
            q.push(now);
        &#125;
        std::partial_sum(d.begin() + 1, d.end(), d.begin() + 1);
        for (int r = l; r &lt;= n; ++r) &#123;
            f[r] += d[r];
            res = std::max(res, f[r] + s[l]);
        &#125;
    &#125;
    std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;


B - Jellyfish and Miku
https://codeforces.com/problemset/problem/1874/D
唉数列。唉概统。在数学讲义上折磨了我一遍之后还要到这儿来折磨我。
假设已经知道了 \(a\)，考虑求期望步数。设 \(E_i\) 为从 \(i\) 出发走到 \(n\) 的期望步数。那么有：
\[
E_i=\begin{cases}
E_1+1&amp;i=0\\
0&amp;i=n\\
E_i=(E_{i-1}+1)\cdot \dfrac {a_i}{a_{i+1}+a_i}+(E_{i+1}+1)\cdot \dfrac {a_{i+1}}{a_{i+1}+a_{i}}&amp;\text{otherwise}
\end{cases}
\]
（提示：从『\(i\) 下一步会走哪个方向』考虑。）
接下来就可以利用你的高中数学知识进行一个 \(f_0\) 的求，（一堆过程），得到 \(E_0=n+2\times \sum\limits_{i=1}^n\dfrac {\sum_{j\le i}a_j}{a_i}\)，然后想要最小化这个东西。
不妨令 \(f_{i,j}\) 表示到 \(i\) 时已经分配走了 \(j\) 体积，\(\sum_{k=1}^i \dfrac {\sum_{l\le k}a_l}{a_k}\) 的最小值，有 \(f_{i,j}=\min\limits_{k&lt;j}\left\{f_{i-1,k}+\dfrac {k}{j - k}\right\}\)。发现它大抵是满足四边形不等式的，按照 2D/1D DP 优化的结论，代入 \(p_{i,j-1}&lt;p_{i,j}&lt;p_{i+1,j}\) 可以 \(O(nm)\) 解决问题。

#include &lt;bits/stdc++.h&gt;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n, m;
    std::cin &gt;&gt; n &gt;&gt; m;
    std::vector&lt;std::vector&lt;int&gt; &gt; p(n + 1, std::vector&lt;int&gt; (m + 1));
    std::vector&lt;std::vector&lt;long double&gt; &gt; f(n + 1, std::vector&lt;long double&gt; (m + 1, 1e18));
    f[0][0] = 0ll;
    for (int j = 1; j &lt;= m; ++j)
        for (int i = std::min(j, n); i; --i) &#123;
            int to = ((i == std::min(j, n)) ? j : std::min(p[i + 1][j], j));
            for (int k = p[i][j - 1]; k &lt;= to; ++k)
                if (f[i - 1][k] + k * 1. / (j - k) &lt; f[i][j])
                    f[i][j] = f[i - 1][k] + k * 1. / (j - k), p[i][j] = k;
            // printf(&quot;f[%d][%d] = %Lf, p = %d\n&quot;, i, j, f[i][j], p[i][j]);
        &#125;
    std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(10) &lt;&lt; n + 2 * f[n][m] &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;


Cut the Sequence
https://www.luogu.com.cn/problem/P10977
通知：区间最值 不满足 四边形不等式。
其实在猜的时候是举了反例的，但是大脑萎缩了推着推着忘记符号了 😅
看到 \(f_i=\min\limits_{g(i)\le j&lt;i}\{f_j+\max\{a_{j+1\sim i}\}\}\) 这个 \(j\) 的范围其实是有点单调队列优化的感觉的，但这个最大值传统的单调队列不是很可做。可以注意到最大值这一项有点 单调队列 后缀最大值的感觉（实际上就是）；一个很自然的想法是利用这个最大值影响的区间，维护 \(f\) 的线段树来暴力做。
另一个比较牛的做法是发现同一个下标的 \(f\) 和 \(a\) 的关系。首先需要注意到 \(f\) 单调不降；对于同一个 \(a\)，能取到的 \(f\) 就是最靠前的；维护一个 \(a\) 的单减队列，那么共用同一个 \(a\) 的就是相邻两个下标之间的部分，其最优决策在能取到的最前端取得；需要注意到队列里的贡献并不单调，需要用一个 multiset 来存储所有贡献并查找、更新。
需要注意单调队列里某个元素 \(f_{q_i}\) 结合的其实是 \(a_{q_{i+1}}\)。还需要注意队头的维护，可能需要一些小巧思。

#include &lt;bits/stdc++.h&gt;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;1.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n, m;
    std::cin &gt;&gt; n &gt;&gt; m;
    std::vector&lt;int&gt; a(n + 1);
    std::vector&lt;long long&gt; s(n + 1);
    for (int i = 1; i &lt;= n; ++i)
        std::cin &gt;&gt; a[i], s[i] = s[i - 1] + a[i];
    int h = 0, t = -1;
    std::multiset&lt;long long&gt; st;
    std::vector&lt;long long&gt; f(n + 1);
    std::vector&lt;std::pair&lt;int, int&gt; &gt; q(n + 1);
    q[++t] = &#123; 0, 0 &#125;, a[0] = 0x3f3f3f3f;
    for (int i = 1; i &lt;= n; ++i) &#123;
        for (; s[i] - s[q[h].second] &gt; m; ) &#123;
            st.erase(st.find(f[q[h].second] + a[q[h + 1].first]));
            if (++q[h].second &gt;= q[h + 1].first)
                a[q[++h].first] = 0x3f3f3f3f;
            else
                st.insert(f[q[h].second] + a[q[h + 1].first]);
        &#125;
        for (; h &lt; t &amp;&amp; a[q[t].first] &lt;= a[i]; --t)
            st.erase(st.find(f[q[t - 1].second] + a[q[t].first]));
        st.insert(f[q[t].second] + a[i]), q[++t] = &#123; i, i &#125;;
        f[i] = *st.begin();
    &#125;
    std::cout &lt;&lt; f[n] &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;

]]></content>
      <tags>
        <tag>斜率优化</tag>
        <tag>DP</tag>
        <tag>四边形不等式</tag>
      </tags>
  </entry>
  <entry>
    <title>杂题选谈：树的各种性质 I</title>
    <url>/20250716/</url>
    <content><![CDATA[这不比斜优做着爽。


A - Tr/ee
https://atcoder.jp/contests/arc103/tasks/arc103_c
可以发现，类似删边的问题，删出来的连通块当中，靠下的是一个完整的子树；就可以转化为子树问题了。
容易想到枚举 \(i-1\) 时树的状态，尝试转化为 \(i\) 时的状态；进一步可以胡出来一堆方案（大概），这里我胡的是，初始设置一个单点，\(0\to 1\) 啥也不干，\(0\to 0\) 在当前根上再加一个叶子，\(1\to 0\) 新建一个带叶子的根并令其成为当前根的父亲，\(1\to 1\) 加一个父亲。
然后特判一下 \(s_1=0\) 和 \(s_n=1\) 和 \(s_i\ne s_{n-i}\) 的情况，发现其他时候都有解。

#include &lt;bits/stdc++.h&gt;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n;
    std::string s;
    std::cin &gt;&gt; s, n = (int)s.length();
    s = &quot;#&quot; + s;
    if (s[1] == &#39;0&#39; || s[n] == &#39;1&#39;) &#123;
        std::cout &lt;&lt; -1 &lt;&lt; &#39;\n&#39;;
        return 0;
    &#125;
    for (int i = 1; i &lt; n; ++i)
        if (s[i] != s[n - i]) &#123;
            std::cout &lt;&lt; -1 &lt;&lt; &#39;\n&#39;;
            return 0;
        &#125;
    int tot = 1, rt = 1;
    for (int i = 2; i &lt; n; ++i) &#123;
        if (tot == i - 1) &#123;
            if (s[i] == &#39;0&#39;) &#123;
                std::cout &lt;&lt; rt &lt;&lt; &#39; &#39; &lt;&lt; ++tot &lt;&lt; &#39;\n&#39;;
                rt = tot;
                std::cout &lt;&lt; rt &lt;&lt; &#39; &#39; &lt;&lt; ++tot &lt;&lt; &#39;\n&#39;;
            &#125;
            else &#123;
                std::cout &lt;&lt; rt &lt;&lt; &#39; &#39; &lt;&lt; ++tot &lt;&lt; &#39;\n&#39;;
                rt = tot;
            &#125;
        &#125;
        else if (s[i] == &#39;0&#39;)
            std::cout &lt;&lt; rt &lt;&lt; &#39; &#39; &lt;&lt; ++tot &lt;&lt; &#39;\n&#39;;
    &#125;
    if (tot != n)
        std::cout &lt;&lt; rt &lt;&lt; &#39; &#39; &lt;&lt; n &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;


B - Keep Perfectly Matched
https://atcoder.jp/contests/arc183/tasks/arc183_d
发现这个『完美匹配』就是在树上给每个点找相邻点配对，看看能不能配上；继而发现由于点的总数为偶，一个点有且仅能有一个 siz 为奇的子树（不然非法），再发现对于任意一个点，删掉的点对要么来自其同一个子树；要么一个来自其奇子树，另一个来自其偶子树。
发现要求最大化距离，又只能删叶子，所以需要最小化 LCA 深度；有没有办法让每次的 LCA 都是根呢？让重心成为根，并保证每次操作的两个点都不来自同一个儿子即可（显然这样是完全可能的）。
接着写了一发发现过不了样例，原因是发现在偶子树中会出现『一个中途的节点本来有一个奇儿子，删去偶子树中的一个叶子后非法』的情况。显然这样的节点是一个偶儿子。确保每个偶儿子的奇儿子先被删掉就可以解决问题。
对重心的每个儿子，提前规划其节点被删除的顺序即可。

#include &lt;bits/stdc++.h&gt;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n;
    std::cin &gt;&gt; n;
    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);
    for (int i = 1, x, y; i &lt; n; ++i) &#123;
        std::cin &gt;&gt; x &gt;&gt; y;
        g[x].push_back(y), g[y].push_back(x);
    &#125;
    std::vector&lt;int&gt; siz(n + 1);
    int rt = 0;
    std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int fa) &#123;
        siz[x] = 1;
        bool flag = 1;
        for (auto i : g[x])
            if (i != fa) &#123;
                DFS(i, x);
                siz[x] += siz[i];
                if (siz[i] &gt; n / 2)
                    flag = 0;
            &#125;
        if (flag &amp;&amp; n - siz[x] &lt;= n / 2)
            rt = x;
        return;
    &#125;;
    DFS(1, -1);
    std::vector&lt;std::vector&lt;int&gt; &gt; lf(n + 1);
    int f1 = -1;
    auto comp = [&amp;](int i, int j) &#123; return siz[i] &lt; siz[j]; &#125;;
    std::priority_queue&lt;int, std::vector&lt;int&gt;, decltype(comp)&gt; f0(comp);
    siz.assign(n + 1, 0);
    for (auto t : g[rt]) &#123;
        DFS = [&amp;](int x, int fa) &#123;
            siz[x] = 1;
            for (auto i : g[x])
                if (i != fa) &#123;
                    DFS(i, x);
                    siz[x] += siz[i];
                &#125;
            return;
        &#125;;
        DFS(t, rt);
        DFS = [&amp;](int x, int fa) &#123;
            if (siz[x] % 2 == 0) &#123;
                for (auto i : g[x])
                    if (i != fa &amp;&amp; siz[x] % 2 == 1)
                        DFS(i, x);
                for (auto i : g[x])
                    if (i != fa &amp;&amp; siz[x] % 2 == 0)
                        DFS(i, x);
            &#125;
            else
                for (auto i : g[x])
                    if (i != fa)
                        DFS(i, x);
            lf[t].push_back(x);
            return;
        &#125;;
        DFS(t, rt);
        if (siz[t] &amp; 1)
            assert(f1 == -1), f1 = t;
        else
            f0.push(t);
        std::reverse(lf[t].begin(), lf[t].end());
    &#125;
    fprintf(stderr, &quot;rt = %d\n&quot;, rt);
    assert(~f1);
    for (int _ = n / 2; _--; ) &#123;
        assert(~f1);
        if (!_ &amp;&amp; f0.empty()) &#123;
            std::cout &lt;&lt; f1 &lt;&lt; &#39; &#39; &lt;&lt; rt &lt;&lt; &#39;\n&#39;;
            break;
        &#125;
        assert(!f0.empty());
        int t = f0.top();
        f0.pop();
        assert(!lf[f1].empty());
        assert(!lf[t].empty());
        std::cout &lt;&lt; lf[f1].back() &lt;&lt; &#39; &#39; &lt;&lt; lf[t].back() &lt;&lt; &#39;\n&#39;;
        lf[f1].pop_back(), --siz[f1];
        lf[t].pop_back(), --siz[t];
        if (siz[f1])
            f0.push(f1);
        f1 = t;
    &#125;
    return 0;
&#125;


C - Fiolki
https://www.luogu.com.cn/problem/P5578
难点在于判断每一步有哪些反应发生；显然一个反应只会在某一步发生。
发现将倒水的操作视为连边 \(b_i\to a_i\)，那么形成了森林，把每个反应丢到 LCA 处等待 check。
发现在 LCA 之外，两种试剂不可能相遇；故最后遍历一遍反应序列，维护每种药水当前数量，在每个点处 check 即可。
再发现如果每次加边都在父亲处 check 所有可能发生的反应，复杂度肯定是错的；故用倍增求出两个点在 LCA 下方的点作为『检查点』，当『检查点』被合并到其父亲时，就可以 check 一下检查点上面挂的所有询问。显然每个点上的询问只会被检查一次；复杂度线性。
加上倍增 LCA 的复杂度，就可以 \(O(n\log n)\) 地完成。

#include &lt;bits/stdc++.h&gt;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n, m, k;
    std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;
    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);
    std::vector&lt;int&gt; f(n + 1), deg(n + 1), now(n + 1);
    for (int i = 1; i &lt;= n; ++i)
        std::cin &gt;&gt; now[i];
    std::iota(f.begin() + 1, f.end(), 1);
    std::function&lt;int(int)&gt; find = [&amp;](int x) &#123;
        return x == f[x] ? x : f[x] = find(f[x]);
    &#125;;
    auto merge = [&amp;](int x, int y) &#123;
        f[find(x)] = find(y);
        return;
    &#125;;
    std::vector&lt;std::pair&lt;int, int&gt; &gt; a(m + 1);
    for (int i = 1; i &lt;= m; ++i) &#123;
        auto &amp;[x, y] = a[i];
        std::cin &gt;&gt; x &gt;&gt; y, ++deg[x];
        g[y].push_back(x), merge(x, y);
    &#125;
    std::vector&lt;int&gt; dep(n + 1);
    std::vector&lt;std::vector&lt;int&gt; &gt; fa(n + 1, std::vector&lt;int&gt; (21));
    for (int i = 1; i &lt;= n; ++i)
        if (!deg[i]) &#123;
            std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;
                for (auto i : g[x]) &#123;
                    fa[i][0] = x;
                    for (int j = 1; j &lt;= 20; ++j)
                        fa[i][j] = fa[fa[i][j - 1]][j - 1];
                    dep[i] = dep[x] + 1, DFS(i);
                &#125;
                return;
            &#125;;
            dep[i] = 1, DFS(i);
        &#125;
    std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; t(n + 1);
    for (int x, y; k--; ) &#123;
        std::cin &gt;&gt; x &gt;&gt; y;
        if (find(x) == find(y)) &#123;
            std::pair&lt;int, int&gt; p(x, y);
            if (dep[x] != dep[y]) &#123;
                if (dep[x] &lt; dep[y])
                    std::swap(x, y);
                for (int i = 20; ~i; --i)
                    if (dep[fa[x][i]] &gt; dep[y])
                        x = fa[x][i];
                if (fa[x][0] == y) &#123;
                    t[x].push_back(p);
                    // printf(&quot;add (%d, %d) to %d\n&quot;, p.first, p.second, x);
                    continue;
                &#125;
                x = fa[x][0];
            &#125;
            for (int i = 20; ~i; --i)
                if (fa[x][i] != fa[y][i])
                    x = fa[x][i], y = fa[y][i];
            t[x].push_back(p), t[y].push_back(p);
        &#125;
    &#125;
    std::iota(f.begin() + 1, f.end(), 1);
    auto res(0ll);
    for (int i = 1; i &lt;= m; ++i) &#123;
        auto [x, y] = a[i];
        merge(x, y);
        for (auto [p, q] : t[x])
            if (find(p) == find(x) &amp;&amp; find(q) == find(x)) &#123;
                int u = std::min(now[p], now[q]);
                res += 2 * u, now[p] -= u, now[q] -= u;
            &#125;
    &#125;
    std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
    return 0;
&#125; 


D - Permutation Tree
https://atcoder.jp/contests/arc095/tasks/arc095_d
随便画图，会发现，如果按层数从小到大标号，一个点的儿子只有最多一个不是叶子。一言以蔽之：毛毛虫。
然后就可以判断可行性了（直径就是虫身）。接下来需要考虑最小化答案字典序的问题，发现对于一个点的儿子，必须是虫足在其左、虫身在其右且必须严格按照层数标号。
字典序是个偏贪心的东西，所以可以开始瞎搞：发现虫足越多，标号更小的父亲就会越靠后，所以依次比较用两端开头的情况，如果到了虫身的某一段，哪种的儿子更少就选谁，然后直接按最小来标号即可。
实际上由于只有两种方案，你也可以两边都试试（）

#include &lt;bits/stdc++.h&gt;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n;
    std::cin &gt;&gt; n;
    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);
    for (int i = 1, x, y; i &lt; n; ++i) &#123;
        std::cin &gt;&gt; x &gt;&gt; y;
        g[x].push_back(y), g[y].push_back(x);
    &#125;
    std::vector&lt;int&gt; dep(n + 1);
    std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int fa) &#123;
        for (auto i : g[x])
            if (i != fa) &#123;
                dep[i] = dep[x] + 1;
                DFS(i, x);
            &#125;
        return;
    &#125;;
    dep[1] = 1, DFS(1, -1);
    int p = std::max_element(dep.begin() + 1, dep.end()) - dep.begin();
    bool flag = 0;
    std::vector&lt;int&gt; node, cnt(n + 1), siz(n + 1);
    DFS = [&amp;](int x, int fa) &#123;
        siz[x] = 1;
        for (auto i : g[x])
            if (i != fa) &#123;
                DFS(i, x);
                siz[x] += siz[i], ++cnt[x];
            &#125;
        if (siz[x] &gt; 1) &#123;
            node.push_back(0), --cnt[x];
            for (auto i : g[x]) &#123;
                if (i != fa &amp;&amp; siz[node.back()] &gt; 1 &amp;&amp; siz[i] &gt; 1)
                    flag = 1;
                if (i != fa &amp;&amp; siz[i] &gt; siz[node.back()])
                    node.back() = i;
            &#125;
        &#125;
        return;
    &#125;;
    DFS(p, -1), node.push_back(p);
    if (flag) &#123;
        std::cout &lt;&lt; -1 &lt;&lt; &#39;\n&#39;;
        return 0;
    &#125;
    for (int i = 0, j = (int)node.size() - 1; i &lt;= j; ++i, --j)
        if (cnt[node[i]] &gt; cnt[node[j]]) &#123;
            std::reverse(node.begin(), node.end());
            break;
        &#125;
        else if (cnt[node[i]] &lt; cnt[node[j]])
            break;
    int now = 0;
    for (auto i : node) &#123;
        int rt = ++now;
        for (; cnt[i]--; std::cout &lt;&lt; ++now &lt;&lt; &#39; &#39;);
        std::cout &lt;&lt; rt &lt;&lt; &#39; &#39;;
    &#125;
    std::cout &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;


E - Isomorphism Freak
https://atcoder.jp/contests/agc024/tasks/agc024_d
像在数有多少种化学环境的 H 是可以说的吗
鉴于这个，高中化学选择性必修三，给我们打下的坚实基础，我们可以非常迅速地注意到答案就是半径长。
然后最少叶子，发现一眼瞪不出来，糟糕！没关系，观察样例输出，发现这些答案的因数都挺多，故猜测是若干个数乘起来的；然后再发现是每层最大儿子数的乘积。
枚举中间的边（仅当直径长度为偶时）、点（奇偶都行）作为对称轴 / 对称中心的情况取 min 即可（原因是要尽量取靠近中心的 点），注意边两端算两个儿子数。
所以为啥 \(n\) 这么小

#include &lt;bits/stdc++.h&gt;
const long long inf = 1e18;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n;
    std::cin &gt;&gt; n;
    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);
    for (int i = 1, x, y; i &lt; n; ++i) &#123;
        std::cin &gt;&gt; x &gt;&gt; y;
        g[x].push_back(y), g[y].push_back(x);
    &#125;
    std::vector&lt;int&gt; dep(n + 1);
    std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int fa) &#123;
        for (auto i : g[x])
        if (i != fa) &#123;
            dep[i] = dep[x] + 1;
            DFS(i, x);
        &#125;
        return;
    &#125;;
    dep[1] = 1, DFS(1, -1);
    int p = std::max_element(dep.begin() + 1, dep.end()) - dep.begin();
    dep[p] = 1, DFS(p, -1);
    int q = std::max_element(dep.begin() + 1, dep.end()) - dep.begin();
    std::cout &lt;&lt; (dep[q] + 1) / 2 &lt;&lt; &#39; &#39;;
    std::vector&lt;int&gt; node;
    std::vector&lt;std::pair&lt;int, int&gt; &gt; edge;
    if (dep[q] &amp; 1) &#123;
        DFS = [&amp;](int x, int fa) &#123;
            for (auto i : g[x])
                if (i != fa)
                    DFS(i, x);
            if (dep[x] == (dep[q] + 1) / 2)
                node.push_back(x), edge.emplace_back(x, fa);
            if (dep[x] == (dep[q] + 1) / 2 + 1)
                edge.emplace_back(x, fa);
            return;
        &#125;;
        DFS(p, -1);
    &#125;
    else &#123;
        std::function&lt;bool(int, int)&gt; DFS = [&amp;](int x, int fa) &#123;
            if (x == q)
                return true;
            bool ret = false;
            for (auto i : g[x])
                if (i != fa)
                    ret |= DFS(i, x);
            if (ret &amp;&amp; dep[x] == dep[q] / 2 + 1)
                edge.emplace_back(x, fa);
            return ret;
        &#125;;
        DFS(p, -1);
    &#125;
    long long res = inf;
    for (auto [x, y] : edge) &#123;
        std::vector&lt;int&gt; cnt(n + 1);
        std::function&lt;void(int, int, int)&gt; DFS = [&amp;](int x, int fa, int dep) &#123;
            int son = 0;
            for (auto i : g[x])
                if (i != fa)
                    ++son, DFS(i, x, dep + 1);
            cnt[dep] = std::max(cnt[dep], son);
            return;
        &#125;;
        DFS(x, y, 1), DFS(y, x, 1);
        auto now(2ll);
        for (int i = 1; i &lt;= n &amp;&amp; cnt[i]; ++i)
            now *= cnt[i];
        res = std::min(res, now);
    &#125;
    for (auto rt : node) &#123;
        std::vector&lt;int&gt; cnt(n + 1);
        std::function&lt;void(int, int, int)&gt; DFS = [&amp;](int x, int fa, int dep) &#123;
            int son = 0;
            for (auto i : g[x])
                if (i != fa)
                    ++son, DFS(i, x, dep + 1);
            cnt[dep] = std::max(cnt[dep], son);
            return;
        &#125;;
        DFS(rt, -1, 1);
        auto now(1ll);
        for (int i = 1; i &lt;= n &amp;&amp; cnt[i]; ++i)
            now *= cnt[i];
        res = std::min(res, now);
    &#125;
    std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;

]]></content>
      <tags>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title>杂题选谈</title>
    <url>/20250520/</url>
    <content><![CDATA[manual 是 anual 的 m 词形式（胡言乱语）
Everyone is potential. （每个人都是蛋白质。）


CF2043E Matrix Transformation
https://codeforces.com/problemset/problem/2043/E

给定 \(n\times m\) 的 \(01\) 矩阵 \(A,B\)，可任意将 \(A\) 的一行置为 \(0\) 或一列置为 \(1\)，问是否能将 \(A\) 变成 \(B\)。

发现如果 \(B\) 的某一行是 \(0\)，那么不管 \(A\) 这一行是什么东西都可以通过一次操作让这一行满足条件（当然，要求这步操作最后进行）。列也是相似的。
那么就有一个撤销的思路，从 \(B\) 中不断删除全 \(0\) 行或全 \(1\) 列，不能删了就对比二者剩下的部分是否全等（因为此时任何操作都是非法的）。

#include &lt;bits/stdc++.h&gt;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int T;
    for (std::cin &gt;&gt; T; T--; ) &#123;
        int n, m;
        std::cin &gt;&gt; n &gt;&gt; m;
        using arr = std::vector&lt;int&gt;;
        using brr = std::vector&lt;arr&gt;;
        using crr = std::vector&lt;brr&gt;;
        brr cn(31, arr(n + 1)), cm(31, arr(m + 1));
        crr a(31, brr(n + 1, arr(m + 1))), b(31, brr(n + 1, arr(m + 1)));
        for (int i = 1; i &lt;= n; ++i)
            for (int j = 1, x; j &lt;= m; ++j) &#123;
                std::cin &gt;&gt; x;
                for (int k = 0; k &lt; 31; ++k)
                    a[k][i][j] = (x &gt;&gt; k) &amp; 1;
            &#125;
        for (int i = 1; i &lt;= n; ++i)
            for (int j = 1, x; j &lt;= m; ++j) &#123;
                std::cin &gt;&gt; x;
                for (int k = 0; k &lt; 31; ++k) &#123;
                    b[k][i][j] = (x &gt;&gt; k) &amp; 1;
                    cn[k][i] += b[k][i][j];
                    cm[k][j] += !b[k][i][j];
                &#125;
            &#125;
        for (int k = 0; k &lt; 31; ++k) &#123;
            std::queue&lt;int&gt; qn, qm;
            std::vector&lt;int&gt; tn(n + 1, 1), tm(m + 1, 1);
            for (int i = 1; i &lt;= n; ++i)
                if (!cn[k][i])
                    tn[i] = 0, qn.push(i);
            for (int j = 1; j &lt;= m; ++j)
                if (!cm[k][j])
                    tm[j] = 0, qm.push(j);
            for (; !qn.empty() || !qm.empty(); ) &#123;
                if (!qn.empty()) &#123;
                    int i = qn.front();
                    // printf(&quot;delete line %d\n&quot;, i);
                    qn.pop();
                    for (int j = 1; j &lt;= m; ++j)
                        if (!b[k][i][j] &amp;&amp; !--cm[k][j])
                            tm[j] = 0, qm.push(j);
                &#125;
                else &#123;
                    int j = qm.front();
                    // printf(&quot;delete column %d\n&quot;, j);
                    qm.pop();
                    for (int i = 1; i &lt;= n; ++i)
                        if (b[k][i][j] &amp;&amp; !--cn[k][i])
                            tn[i] = 0, qn.push(i);
                &#125;
            &#125;
            for (int i = 1; i &lt;= n; ++i)
                if (tn[i])
                    for (int j = 1; j &lt;= m; ++j)
                        if (tm[j] &amp;&amp; a[k][i][j] != b[k][i][j]) &#123;
                            // printf(&quot;k = %d: (%d, %d)\n&quot;, k, i, j);
                            goto nosol;
                        &#125;
        &#125;
        std::cout &lt;&lt; &quot;Yes\n&quot;;
        continue;
    nosol :
        std::cout &lt;&lt; &quot;No\n&quot;;
    &#125;
    return 0;
&#125;


CF2043F Nim
https://codeforces.com/contest/2043/problem/F

给定 \(m\) 次询问，每次问从 \(a_l\sim a_r\) 选非空子序列使得异或和为 \(0\)，问子序列最小长度、该前提下的方案数。

发现子序列问题可以等价为背包；背包可以合并（即把整区间拆成若干段后，两两信息可以合并）；背包可以放在分治上；
由此，把询问离线下来放在 \(a_{1\sim n}\) 的分治上，每次只处理在 \([l,r]\) 间且跨越 \(mid\) 的询问就可以得到答案。复杂度 \(O(n\cdot v^2\log n)\)。

不要用方案数是否为 \(0\) 来判断是否无解！因为方案数可能是 \(998244353\) 的倍数……
#include &lt;bits/stdc++.h&gt;
const int siz = 63;
const int mod = 998244353;
const int inf = 0x3f3f3f3f;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n, m;
    std::cin &gt;&gt; n &gt;&gt; m;
    std::vector&lt;int&gt; a(n + 1);
    for (int i = 1; i &lt;= n; ++i)
        std::cin &gt;&gt; a[i];
    struct _ &#123; int l, r, id; &#125;;
    std::vector&lt;_&gt; q(m + 1);
    std::vector&lt;std::pair&lt;int, long long&gt; &gt; res(m + 1, &#123; inf, 0ll &#125;);
    for (int i = 1; i &lt;= m; ++i) &#123;
        std::cin &gt;&gt; q[i].l &gt;&gt; q[i].r;
        q[i].id = i;
    &#125;
    std::function&lt;void(int, int, std::vector&lt;_&gt; &amp;q)&gt; calc = [&amp;](int l, int r, std::vector&lt;_&gt; &amp;q) &#123;
        if (l == r) &#123;
            for (auto [l, r, id] : q)
                if (a[l] == 0)
                    res[id] = &#123; 0, 1ll &#125;;
            return;
        &#125;
        int mid = (l + r) &gt;&gt; 1;
        std::vector&lt;_&gt; ql, qr, qm;
        for (; !q.empty(); q.pop_back()) &#123;
            if (q.back().r &lt;= mid)
                ql.push_back(std::move(q.back()));
            else if (q.back().l &gt; mid)
                qr.push_back(std::move(q.back()));
            else
                qm.push_back(std::move(q.back()));
        &#125;
        calc(l, mid, ql), calc(mid + 1, r, qr);
        std::vector&lt;std::vector&lt;int&gt; &gt; f(r - l + 1, std::vector&lt;int&gt; (siz + 1, inf));
        std::vector&lt;std::vector&lt;long long&gt; &gt; g(r - l + 1, std::vector&lt;long long&gt; (siz + 1));
        f[mid - l][a[mid]] = 1ll, g[mid - l][a[mid]] = 1ll;
        for (int i = mid - l - 1; ~i; --i) &#123;
            int k = a[i + l];
            f[i] = f[i + 1], g[i] = g[i + 1];
            if (f[i][k] == 1)
                (++g[i][k]) %= mod;
            else
                f[i][k] = 1, g[i][k] = 1ll;
            for (int j = 0, k = a[i + l]; j &lt;= siz; ++j)
                if (f[i + 1][j ^ k] + 1 &lt; f[i][j])
                    f[i][j] = f[i + 1][j ^ k] + 1, g[i][j] = g[i + 1][j ^ k];
                else if (f[i + 1][j ^ k] + 1 == f[i][j])
                    (g[i][j] += g[i + 1][j ^ k]) %= mod;
        &#125;
        f[mid - l + 1][a[mid + 1]] = 1ll, g[mid - l + 1][a[mid + 1]] = 1ll;
        for (int i = mid - l + 2; i &lt;= r - l; ++i) &#123;
            int k = a[i + l];
            f[i] = f[i - 1], g[i] = g[i - 1];
            if (f[i][k] == 1)
                (++g[i][k]) %= mod;
            else
                f[i][k] = 1, g[i][k] = 1ll;
            for (int j = 0; j &lt;= siz; ++j)
                if (f[i - 1][j ^ k] + 1 &lt; f[i][j])
                    f[i][j] = f[i - 1][j ^ k] + 1, g[i][j] = g[i - 1][j ^ k];
                else if (f[i - 1][j ^ k] + 1 == f[i][j])
                    (g[i][j] += g[i - 1][j ^ k]) %= mod;
        &#125;
        for (auto [ql, qr, id] : qm) &#123;
            // printf(&quot;at [%d, %d], mid = %d: ASK [%d, %d]: \n&quot;, l, r, mid, ql, qr);
            ql -= l, qr -= l;
            if (f[ql][0] &lt; inf)
                res[id].first = f[ql][0], res[id].second = g[ql][0];
            if (f[qr][0] &lt; res[id].first)
                res[id].first = f[qr][0], res[id].second = g[qr][0];
            else if (f[qr][0] == res[id].first)
                (res[id].second += g[qr][0]) %= mod;
            for (int i = 1; i &lt;= siz; ++i) &#123;
                // printf(&quot;  %d[%d]: %d(%lld)  |  %d[%d]: %d(%lld)\n&quot;, ql + l, i, f[ql][i], g[ql][i], qr + l, i, f[qr][i], g[qr][i]);
                if (f[ql][i] + f[qr][i] &lt; res[id].first)
                    res[id].first = f[ql][i] + f[qr][i], res[id].second = g[ql][i] * g[qr][i] % mod;
                else if (f[ql][i] + f[qr][i] == res[id].first)
                    (res[id].second += g[ql][i] * g[qr][i]) %= mod;
            &#125;
            if (res[id].first &lt; inf)
                res[id].first = (qr - ql + 1) - res[id].first;
        &#125;
        return;
    &#125;;
    calc(1, n, q);
    for (int i = 1; i &lt;= m; ++i)
        if (res[i].first &lt; inf)
            std::cout &lt;&lt; res[i].first &lt;&lt; &#39; &#39; &lt;&lt; res[i].second &lt;&lt; &#39;\n&#39;;
        else
            std::cout &lt;&lt; -1 &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;


贪玩蓝月
https://loj.ac/p/6515
差不多的题：https://atcoder.jp/contests/jag2018summer-day2/tasks/jag2018summer_day2_d，注意加入是按体积单增的
发现断点确定时可以背包 \(O(p)\) 维护插入删除；使用 双栈模拟双端队列 就可以均摊 \(O(pm)\) 实现插入删除。
对于询问，当然可以 \(O(p^2)\) 枚举最值再枚举方案（即枚举一端的贡献）；但复杂度不太美观。考虑倒过来，先 \(O(v)\) 枚举一端贡献，再枚举『能凑出 \([l,r]\) 中的值』的另一端的贡献。这样就发现我们是在求区间最大值；每次询问时构建 ST 表预处理另一端的区间最大值即可。
复杂度 \(O(mq\log q)\)。

#include &lt;bits/stdc++.h&gt;
const long long inf = 1e18;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int m, mod;
    std::cin &gt;&gt; m &gt;&gt; m &gt;&gt; mod;
    std::array&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt;, 2&gt; T;
    std::array&lt;std::vector&lt;std::vector&lt;long long&gt; &gt;, 2&gt; F;
    F[0].emplace_back(mod, -inf), F[1].emplace_back(mod, -inf);
    F[0][0][0] = 0ll, F[1][0][0] = 0ll;
    for (; m--; ) &#123;
        std::string op;
        std::cin &gt;&gt; op;
        if (op[0] == &#39;I&#39;) &#123;
            int v, w;
            std::cin &gt;&gt; v &gt;&gt; w, v %= mod;
            auto &amp;t = T[op[1] == &#39;G&#39;];
            auto &amp;f = F[op[1] == &#39;G&#39;];
            t.emplace_back(v, w);
            f.emplace_back(f.back());
            for (int i = (int)f.size() - 1, j = 0; j &lt; mod; ++j)
                if (f[i - 1][(j + mod - v) % mod] + w &gt; f[i][j])
                    f[i][j] = f[i - 1][(j + mod - v) % mod] + w;
        &#125;
        else if (op[0] == &#39;D&#39;) &#123;
            auto &amp;t0 = T[op[1] == &#39;G&#39;], &amp;t1 = T[op[1] == &#39;F&#39;];
            auto &amp;f0 = F[op[1] == &#39;G&#39;], &amp;f1 = F[op[1] == &#39;F&#39;];
            if (t0.empty()) &#123;
                t1.erase(t1.begin());
                int to = t1.size() / 2;
                std::vector&lt;std::pair&lt;int, int&gt; &gt; (t1.begin(), t1.begin() + to).swap(t0);
                std::reverse(t0.begin(), t0.end());
                std::vector&lt;std::pair&lt;int, int&gt; &gt; (t1.begin() + to, t1.end()).swap(t1);
                f0.resize(1), f1.resize(1);
                for (auto [v, w] : t0) &#123;
                    f0.emplace_back(f0.back());
                    for (int i = (int)f0.size() - 1, j = 0; j &lt; mod; ++j)
                        if (f0[i - 1][(j + mod - v) % mod] + w &gt; f0[i][j])
                            f0[i][j] = f0[i - 1][(j + mod - v) % mod] + w;
                &#125;
                for (auto [v, w] : t1) &#123;
                    f1.emplace_back(f1.back());
                    for (int i = (int)f1.size() - 1, j = 0; j &lt; mod; ++j)
                        if (f1[i - 1][(j + mod - v) % mod] + w &gt; f1[i][j])
                            f1[i][j] = f1[i - 1][(j + mod - v) % mod] + w;
                &#125;
            &#125;
            else
                t0.pop_back(), f0.pop_back();
        &#125;
        else &#123;
            int l, r;
            std::cin &gt;&gt; l &gt;&gt; r;
            auto res(-inf);
            std::vector&lt;std::vector&lt;long long&gt; &gt; st(std::__lg(mod) + 1, std::vector&lt;long long&gt; (mod + 1));
            st[0] = F[1].back();
            for (int j = 1; (1 &lt;&lt; j) &lt;= mod; ++j)
                for (int i = 0; i + (1 &lt;&lt; j) - 1 &lt; mod; ++i)
                    st[j][i] = std::max(st[j - 1][i], st[j - 1][i + (1 &lt;&lt; (j - 1))]);
            auto ask = [&amp;](int l, int r) &#123;
                int k = std::__lg(r - l + 1);
                return std::max(st[k][l], st[k][r - (1 &lt;&lt; k) + 1]);
            &#125;;
            for (int j = 0; j &lt; mod; ++j)
                if (j &lt;= l)
                    res = std::max(res, F[0].back()[j] + ask(l - j, r - j));
                else if (l &lt; j &amp;&amp; j &lt;= r)
                    res = std::max(&#123; res, F[0].back()[j] + ask(0, r - j), F[0].back()[j] + ask(l + mod - j, mod - 1) &#125;);
                else
                    res = std::max(res, F[0].back()[j] + ask(l + mod - j, r + mod - j));
            std::cout &lt;&lt; std::max(-1ll, res) &lt;&lt; &#39;\n&#39;;
        &#125;
    &#125;
    return 0;
&#125;


APIO2025 转杆
https://www.luogu.com.cn/problem/P12543
总有一天我要让全天下的数学题 DP 题字符串题图论题模拟题数据结构题思维题全部消失
不要把它转化成序列问题来考虑！这对观察到结论没有好处！
考虑 \(n=2\) 的情况，当且仅当垂直时最优。\(n=3\) 时，随便固定其中一条线，发现剩下两条线如果夹角固定，则代价固定；当夹角取 \(90^{\circ}\) 时最优。
于是猜是不是任意一对都要垂直。考虑数归，当前 \(2n\) 对 不知道怎么摆的，反正就是 最优时：

考虑加入第 \(2n+1\) 条；参照 \(n=3\) 的情形，把前 \(2n\) 条任意两两配对，则第 \(2n+1\) 的位置对代价没有任何影响。
考虑加入第 \(2n+2\) 条；相似地，它的位置对前 \(2n\) 条没有任何影响；故需要最大化它和第 \(2n+1\) 条的贡献。取垂直即可。

因此得到任意一对都要垂直。具体怎么调整呢？首先下意识排序；配对方式即将 \(i\) 与 \(\dfrac i+\lfloor \frac n2\rfloor\) 配对；因为能感受到这样影响的线段最少。严谨的证明好像没看到。

#include&lt;bits/stdc++.h&gt;
void energy(int, std::vector&lt;int&gt;);
void rotate(std::vector&lt;int&gt;, int);
void energy(int n, std::vector&lt;int&gt; a) &#123;
    std::vector&lt;int&gt; id(n);
    std::iota(id.begin(), id.end(), 0);
    std::sort(id.begin(), id.end(), [&amp;](int x, int y) &#123; return a[x] &lt; a[y]; &#125;);
    for (int i = 0, j = n / 2; i &lt; n / 2; ++i, ++j)
        rotate(&#123; id[j] &#125;, (a[id[i]] + 75000 - a[id[j]]) % 50000);
    return;
&#125;


ABC407E Most Valuable Parentheses
https://atcoder.jp/contests/abc407/tasks/abc407_e
这里有一个很典（可惜我不知道）的 trick：贪心构造最优括号序列。
用优先队列维护，贪心选即可。

#include &lt;bits/stdc++.h&gt;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int T;
    for (std::cin &gt;&gt; T; T--; ) &#123;
        int n;
        std::cin &gt;&gt; n;
        std::vector&lt;int&gt; a(2 * n + 1);
        for (int i = 1; i &lt;= 2 * n; ++i)
            std::cin &gt;&gt; a[i];
        long long res = a[1];
        std::priority_queue&lt;int&gt; q;
        for (int i = 2; i &lt; 2 * n; i += 2) &#123;
            q.push(a[i]), q.push(a[i + 1]);
            res += q.top(), q.pop();
        &#125;
        std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
    &#125;
    return 0;
&#125;

]]></content>
      <tags>
        <tag>分治</tag>
        <tag>背包</tag>
      </tags>
  </entry>
  <entry>
    <title>杂题选谈：树的各种性质 II</title>
    <url>/20250717/</url>
    <content><![CDATA[好像确实比斜优做着舒服。


A - Perfect Matching on a Tree
https://atcoder.jp/contests/abc362/tasks/abc362_f
肯定直接猜以重心为根。
至于咋求答案，（显然值是所有点的深度之和），这个我去年在场上被卡住了，还是太菜了。其实是摩尔投票板子。

#include &lt;bits/stdc++.h&gt;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n;
    std::cin &gt;&gt; n;
    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);
    for (int i = 1, x, y; i &lt; n; ++i) &#123;
        std::cin &gt;&gt; x &gt;&gt; y;
        g[x].push_back(y), g[y].push_back(x);
    &#125;
    std::vector&lt;int&gt; siz(n + 1);
    int rt = 0;
    std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int fa) &#123;
        siz[x] = 1;
        bool flag = 1;
        for (auto i : g[x])
            if (i != fa) &#123;
                DFS(i, x);
                siz[x] += siz[i];
                if (siz[i] &gt; n / 2)
                    flag = 0;
            &#125;
        if (flag &amp;&amp; n - siz[x] &lt;= n / 2)
            rt = x;
        return;
    &#125;;
    DFS(1, -1);
    std::vector&lt;std::vector&lt;int&gt; &gt; t(n + 1);
    for (auto i : g[rt]) &#123;
        DFS = [&amp;](int x, int fa) &#123;
            t[i].push_back(x);
            for (auto i : g[x])
                if (i != fa)
                    DFS(i, x);
            return;
        &#125;;
        DFS(i, rt);
    &#125;
    std::deque&lt;int&gt; p1, p2;
    int to = n / 2;
    for (auto i : g[rt]) &#123;
        auto &amp;q1 = (p1.size() &gt; p2.size() ? p2 : p1), &amp;q2 = (p1.size() &gt; p2.size() ? p1 : p2);
        for (; !t[i].empty() &amp;&amp; (int)q1.size() &lt; to; q1.push_back(t[i].back()), t[i].pop_back());
        for (; !t[i].empty() &amp;&amp; (int)q2.size() &lt; to; q2.push_front(t[i].back()), t[i].pop_back());
    &#125;
    if (n % 2 == 0)
        (p1.size() &lt; p2.size() ? p1 : p2).push_back(rt);
    for (; to--; ) &#123;
        std::cout &lt;&lt; p1.back() &lt;&lt; &#39; &#39; &lt;&lt; p2.back() &lt;&lt; &#39;\n&#39;;
        p1.pop_back(), p2.pop_back();
    &#125;
    return 0;
&#125;


B - Miracle Tree
https://atcoder.jp/contests/arc117/tasks/arc117_d
容易发现任取 \(a,b,c\) 三点，由于它们之间只有一条简单路径，可以视为一条线段，即退化的三角形。那么由三角形三边关系，任取两边之和都大于等于第三边。
不妨令 \(E(a)&gt;E(b)&gt;E(c)\)，以 \(d(b,a)+d(b,c)\ge d(a,c)\) 举例，有 \(E(a)-E(b)+E(b)-E(c)\ge d(a,c)\) 成立；即，若 \((b,a)\) 和 \((b,c)\) 分别已经找到可行解，则 \((a,c)\) 合法。
从而推断出，按点权将所有点从小到大排序后，只需让任意相邻两点合法，则全树合法。易发现答案是所有相邻两点 \(dis\) 之和；也即，从任意一点出发，经过全树所有点的路径和。这种问题我们很熟悉，由欧拉序可知是从 \(2(n-1)\) 个 \(w\) 中抠走一段路径长（终点到起点）。想要最小化答案就要最大化这段路径长，取直径即可。
最后的答案序列按照欧拉序直接求即可（注意直径的端点要在序列两端），实现上应该可以有一些 \(O(n)\) 小巧思。

#include &lt;bits/stdc++.h&gt;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n;
    std::cin &gt;&gt; n;
    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);
    for (int i = 1, x, y; i &lt; n; ++i) &#123;
        std::cin &gt;&gt; x &gt;&gt; y;
        g[x].push_back(y), g[y].push_back(x);
    &#125;
    std::vector&lt;int&gt; dep(n + 1);
    std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int fa) &#123;
        for (auto i : g[x])
            if (i != fa) &#123;
                dep[i] = dep[x] + 1;
                DFS(i, x);
            &#125;
        return;
    &#125;;
    dep[1] = 1, DFS(1, -1);
    int p = std::max_element(dep.begin() + 1, dep.end()) - dep.begin();
    dep[p] = 1, DFS(p, -1);
    int q = std::max_element(dep.begin() + 1, dep.end()) - dep.begin();
    std::vector&lt;int&gt; tag(n + 1);
    std::function&lt;bool(int, int)&gt; DFS1 = [&amp;](int x, int fa) &#123;
        if (x == q) &#123;
            tag[x] = 1;
            return true;
        &#125;
        for (auto i : g[x])
            if (i != fa &amp;&amp; DFS1(i, x)) &#123;
                tag[x] = 1;
                return true;
            &#125;
        return false;
    &#125;;
    DFS1(p, -1);
    std::vector&lt;int&gt; res(n + 1);
    DFS = [&amp;](int x, int fa) &#123;
        static int now = 1;
        int son = 0;
        if (x != p)
            res[x] = now;
        for (auto i : g[x])
            if (i != fa) &#123;
                if (tag[i])
                    son = i;
                else
                    ++now, DFS(i, x), ++now;
            &#125;
        if (son)
            ++now, DFS(son, x); // 回不来了，故可以不加 ;-)
        return;
    &#125;;
    res[p] = 1, DFS(p, -1);
    for (int i = 1; i &lt;= n; ++i)
        std::cout &lt;&lt; res[i] &lt;&lt; &#39; &#39;;
    std::cout &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;


C - 树的计数
https://www.luogu.com.cn/problem/P1232
需要意识到 DFS 和 BFS 地位是不等价的：二者都有自己相应的性质，但 BFS 的深度性质更易于上手。
不妨进行重标号，令 BFS 序为 \(1\sim n\)。可以在 BFS 中不断进行『分层』得到点的深度信息。发现 \(1\) 后必须分割一次，除此之外没有 BFS 序本身带来的限制。考虑 DFS 序对深度带来的额外限制：

对于 \(D_i\) 和 \(D_{i+1}\)，则 \(D_{i+1}\) 的插入位点位于 \(1\sim D_i\) 的链上，则 \(dep_{D_{i+1}}\le dep_{D_i}+1\)，即 BFS 序中，\([D_i,D_{i+1})\) 间有至多一个分段点。
虽然题面没说，但是这里 BFS 和 DFS 遍历儿子的顺序是相同的；由于在 BFS 序中 \(i\) 先于 \(i+1\) 被遍历，（由于 \(dep_i\le dep_{i+1}\le dep_i+1\)），故而若 \(dep_i= dep_{i+1}\)，则 DFS 先遍历 \(i\)；反之，若 DFS 序中 \(i+1\) 早于 \(i\) 出现，BFS 序中 \(i\) 处必须分层。

则得到若干条限制，形如某处必须断、某区间必须恰好断一次之类。发现比较难处理的是区间内没有要求『某个点必须断』的情况；可以差分约束 惊讶地发现，这种情况下有 \(D_{i+1}=D_i+1\)（可以考察第一个满足 \(D_i\ne i\) 的点来思考）。这点其实是比较难论证的，所以我也没有想得很清楚；好在信息也不是很要求证明这一块就是了。
用差分处理『恰好一次』的限制，标记某些点不能断。初始高度为 \(1\)；每次『必须分段』会带来 \(1\) 的高度；每次『可能分段』会带来 \(0.5\) 的高度。加起来就可以了。

#include &lt;bits/stdc++.h&gt;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;P1232_2.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n;
    std::cin &gt;&gt; n;
    std::vector&lt;int&gt; d(n + 1), b(n + 1), p(n + 1);
    for (int i = 1; i &lt;= n; ++i)
        std::cin &gt;&gt; d[i];
    for (int i = 1; i &lt;= n; ++i)
        std::cin &gt;&gt; b[i], p[b[i]] = i;
    for (int i = 1; i &lt;= n; ++i)
        d[i] = p[d[i]];
    for (int i = 1; i &lt;= n; ++i)
        p[d[i]] = i;
    int res = 4;
    std::vector&lt;int&gt; tag(n + 1), forbid(n + 1);
    for (int i = 2; i &lt; n; ++i)
        if (p[i + 1] &lt; p[i])
            tag[i] = 1;
    std::partial_sum(tag.begin() + 1, tag.end(), tag.begin() + 1);
    for (int i = 2; i &lt; n; ++i)
        if (d[i + 1] &gt; d[i] &amp;&amp; tag[d[i + 1] - 1] - tag[d[i] - 1]) &#123;
            // fprintf(stderr, &quot;forbid [%d, %d)\n&quot;, d[i], d[i + 1]);
            forbid[d[i]] += 1, forbid[d[i + 1]] -= 1;
        &#125;
    std::partial_sum(forbid.begin() + 1, forbid.end(), forbid.begin() + 1);
    for (int i = 2; i &lt; n; ++i)
        if (p[i] &gt; p[i + 1])
            res += 2;
        else if (!forbid[i] &amp;&amp; p[i + 1] == p[i] + 1)
            res += 1;
    std::cout &lt;&lt; res / 2;
    if (res &amp; 1)
        std::cout &lt;&lt; &quot;.500&quot;;
    else
        std::cout &lt;&lt; &quot;.000&quot;;
    std::cout &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;


D - Alice and Bob
https://www.luogu.com.cn/problem/P3971
一个很显然的想法是 BST；但是这个东西只能求可行解，求不了最优解。
题解说观察到 \(i\) 的决策点一定是左侧最靠右的一个 \(a_j=a_i-1\)（可以假设 \(a_j&gt;a_i\) 然后反证）。如果把 \(j\) 向 \(i\) 连边可以建树；注意到共用一个父亲的点值是递减的。
要往树上填值。容易想到一层一层填；可惜不最优（反例如下图）。

考察从 1 开始的最长下降子序列，发现按层倒序填不优。

考虑『以 \(i\) 开头的最长下降子序列长度』在树上的内涵，发现：

只能取 \(i\) 所在子树往右的部分；
取了祖先就不能取儿子；儿子标号比祖先大；标号越大越能取；最优肯定取叶子。

想要尽量取满所有 \(i\) 子树右侧的所有比 \(i\) 标号大的叶子，就要让它们比 \(i\) 都小。这个问题是简单的；一种方法是按儿子标号从大到小，一边 DFS 一边赋值。暂时没想到不用还原序列、log 求答案的统计方法。

附：两种方式对比


#include &lt;bits/stdc++.h&gt;
const int maxn = 1e5 + 5;
struct &#123; int l, r, u; &#125; t[maxn &lt;&lt; 2];
#define lt (p &lt;&lt; 1)
#define rt (lt | 1)
void bld(int p, int l, int r) &#123;
    t[p].l = l, t[p].r = r;
    if (l == r)
        return;
    int mid = (l + r) &gt;&gt; 1;
    bld(lt, l, mid), bld(rt, mid + 1, r);
    return;
&#125;
void add(int p, int x, int v) &#123;
    t[p].u = std::max(t[p].u, v);
    if (t[p].l == t[p].r)
        return;
    int mid = (t[p].l + t[p].r) &gt;&gt; 1;
    if (x &lt;= mid)
        add(lt, x, v);
    else
        add(rt, x, v);
    return;
&#125;
int ask(int p, int l, int r) &#123;
    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r)
        return t[p].u;
    int mid = (t[p].l + t[p].r) &gt;&gt; 1, res = 0;
    if (l &lt;= mid)
        res = ask(lt, l, r);
    if (r &gt; mid)
        res = std::max(res, ask(rt, l, r));
    return res;
&#125;
#undef lt
#undef rt
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n;
    std::cin &gt;&gt; n;
    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);
    std::vector&lt;int&gt; a(n + 1), la(n + 1), deg(n + 1);
    for (int i = 1; i &lt;= n; ++i) &#123;
        std::cin &gt;&gt; a[i];
        g[la[a[i] - 1]].push_back(i), ++deg[la[a[i] - 1]];
        la[a[i]] = i;
    &#125;
    std::vector&lt;int&gt; u(n + 1), b(n + 1);
    std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;
        static int now = 0;
        u[x] = now++;
        std::reverse(g[x].begin(), g[x].end());
        for (auto i : g[x])
            DFS(i);
        return;
    &#125;;
    DFS(0);
    bld(1, 1, n);
    for (int i = n; i; --i) &#123;
        b[i] = ask(1, 1, u[i] - 1) + 1;
        add(1, u[i], b[i]);
    &#125;
    // for (int i = 1; i &lt;= n; ++i)
    //     std::cout &lt;&lt; b[i] &lt;&lt; &#39; &#39;;
    // std::cout &lt;&lt; &#39;\n&#39;;
    std::cout &lt;&lt; std::accumulate(b.begin() + 1, b.end(), 0ll) &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;


E - Tree Factory
https://codeforces.com/problemset/problem/1225/F
首先把题意转化为『每次可以把一个子树下移，要求把一个树转化为一条链』。可以进行一些观察：

一次移动能产生贡献当且仅当其让树高增加 \(1\)。
如果每次移动都产生贡献，易发现答案下界为 \(n-\sum mxd_i\)，可以取到。

看到深度相关就要想到长剖 😅 bro 还没 ptsd
取以根为 top 的长链，从底到顶依次完成『并到短链所在树上，把树拆成链』的操作。具体过程大概是一个 dfn 的感觉。

#include &lt;bits/stdc++.h&gt;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n;
    std::cin &gt;&gt; n;
    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);
    for (int i = 2, x; i &lt;= n; ++i)
        std::cin &gt;&gt; x, g[x + 1].push_back(i);
    std::vector&lt;int&gt; mxd(n + 1), son(n + 1), res, nex(n + 1);
    std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;
        mxd[x] = 1;
        for (auto i : g[x]) &#123;
            DFS(i);
            if (mxd[i] + 1 &gt; mxd[x])
                son[x] = i, mxd[x] = mxd[i] + 1;
        &#125;
        return;
    &#125;;
    DFS(1);
    std::vector&lt;int&gt; p;
    for (int i = 1; son[i]; i = son[i])
        p.push_back(i);
    std::function&lt;void(int, int)&gt; merge = [&amp;](int son, int x) &#123;
        int la = son;
        res.push_back(son);
        for (auto i : g[x])
            merge(la, i), la = i;
        nex[x] = la;
        return;
    &#125;;
    for (int i = (int)p.size() - 1; ~i; --i) &#123;
        int la = son[p[i]];
        for (auto j : g[p[i]])
            if (j != son[p[i]])
                merge(la, j), la = j;
        nex[p[i]] = la;
    &#125;
    for (int i = 1; i; i = nex[i])
        std::cout &lt;&lt; i - 1 &lt;&lt; &#39; &#39;;
    std::cout &lt;&lt; &#39;\n&#39; &lt;&lt; res.size() &lt;&lt; &#39;\n&#39;;
    std::reverse(res.begin(), res.end());
    for (auto i : res)
        std::cout &lt;&lt; i - 1 &lt;&lt; &#39; &#39;;
    std::cout &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;

]]></content>
      <tags>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title>解题报告：Approximate Diameter</title>
    <url>/20250721/</url>
    <content><![CDATA[唉确实没见过这种二分形式。


https://codeforces.com/problemset/problem/1804/F
注意到这个范围基本上就是 图直径的这个性质，但是我不认识 😅
每次修改做一次 BFS 过于抽象，发现这个上界多了个 \(2\) 的系数，把主元换成 \(d\) 可以得到 \(d\in[0.5s,2s]\)。有一个很牛的操作，假设在当前图上求出来了一个 \(s&#39;\)，显然一直加边，\(2s\) 这个上界是在变小的，但只要 \(s&#39;\le 2s\) 成立，\(s&#39;\) 就一直可以作为区间里的一个估值。如果不成立，发现除以二就成立了。
转化成二分 \(s&#39;\) 最远可以达到的距离即可。每次 \(s&#39;\) 除以二，共除了 \(\log n\) 次；复杂度 \(O(n\log^2 n)\)。
然后注意不要每次 check 都复制一遍原数组然后加边；应该预先在原图上加好所有边，记录版本。原因是申请空间特别费时间。

#include &lt;bits/stdc++.h&gt;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n, m, q;
    std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;
    std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; g(n + 1);
    for (int x, y; m--; ) &#123;
        std::cin &gt;&gt; x &gt;&gt; y;
        g[x].emplace_back(y, 0), g[y].emplace_back(x, 0);
    &#125;
    for (int i = 1, x, y; i &lt;= q; ++i) &#123;
        std::cin &gt;&gt; x &gt;&gt; y;
        g[x].emplace_back(y, i), g[y].emplace_back(x, i);
    &#125;
    std::vector&lt;int&gt; mem(q + 1, -1);
    auto calc = [&amp;](int id) &#123;
        if (~mem[id])
            return mem[id];
        std::queue&lt;std::pair&lt;int, int&gt; &gt; q;
        std::vector&lt;int&gt; tag(n + 1);
        q.emplace(1, 0), tag[1] = 1;
        int mx = 0;
        for (; !q.empty(); ) &#123;
            auto [x, w] = q.front();
            q.pop(), mx = w;
            for (auto [i, ver] : g[x])
                if (ver &lt;= id &amp;&amp; !tag[i]) &#123;
                    tag[i] = 1;
                    q.emplace(i, w + 1);
                &#125;
        &#125;
        return mem[id] = mx;
    &#125;;
    int s = calc(0);
    for (int i = 0; i &lt;= q; ) &#123;
        int j = i;
        for (int l = i + 1, r = q, mid; l &lt;= r; ) &#123;
            mid = (l + r) &gt;&gt; 1;
            if (s &lt;= 2 * calc(mid))
                j = mid, l = mid + 1;
            else
                r = mid - 1;
        &#125;
        for (; i &lt;= j; ++i)
            std::cout &lt;&lt; s &lt;&lt; &#39; &#39;;
        s /= 2;
    &#125;
    std::cout &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;

]]></content>
      <tags>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>vp 记录 edu 181</title>
    <url>/20250723/</url>
    <content><![CDATA[tzl 太强了！真挚的膜拜

lhy 太强了！真挚的膜拜

E. Sets of Complementary Sums
https://codeforces.com/contest/2125/problem/E
分拆数、其实是个不牛的东西，但是写假了 😅
令集合元素升序排列为 \(b_{1\sim n}\)。显然有结论 \(\sum b\geqslant (n-1)(b_n+1)\)，化一下就有 \(b_n\geqslant \left(\sum\limits_{i=1}^{n-1} b_n-b_i\right)+(n-1)\)。发现 RSH 取值对 LSH 无影响（从取等开始，RSH 不变，若 \(b_n\gets b_n+1\)，只需将每个 \(b_i\gets b_i+1\) 即可构造出一组解），故只用考虑 RSH 的每种取值下的方案。
然后就可以做 分拆数 了。发现会 MLE，滚动即可。每次暴力 assign 会很慢，可以用一点巧思清空滚动数组。

#include &lt;bits/stdc++.h&gt;
const int mod = 998244353;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int T;
    for (std::cin &gt;&gt; T; T--; ) &#123;
        long long n, m;
        std::cin &gt;&gt; n &gt;&gt; m;
        if (n * (n - 1) / 2 &gt; m) &#123;
            std::cout &lt;&lt; 0 &lt;&lt; &#39;\n&#39;;
            continue;
        &#125;
        if (n == 1) &#123;
            std::cout &lt;&lt; m &lt;&lt; &#39;\n&#39;;
            continue;
        &#125;
        --n;
        std::vector&lt;std::vector&lt;long long&gt; &gt; f(2, std::vector &lt;long long&gt; (m + 1));
        f[0][0] = 1ll;
        for (int j = 1, at = 1; j &lt;= n; ++j, at ^= 1)
            for (int i = 0; i &lt;= m; ++i) &#123;
                if (i &lt; j)
                    f[at][i] = 0;
                else
                    f[at][i] = (f[at ^ 1][i - j] + f[at][i - j]) % mod;
            &#125;
        auto res(0ll);
        for (int i = 1; i &lt;= m - n; ++i)
            (res += f[n &amp; 1][i] * (m - (i + n) + 1)) %= mod;
        std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
    &#125;
    return 0;
&#125;


vp 记录
A
1:43 切。打 std:: 还是太费时间了。
B
5:46 切，看完题没想到 gcd，输出的时候想到了。莼菜。
C
11:23 切，原因是容斥符号乱写。
D
24:21 切，中间重构了一次并且前缀和的部分考虑得有点问题。绅士（38:35）问我为啥做这么快。
E.0
看了一眼感觉不太可做。quack 说 F 板板，故跳。
F
01:13:41 草完。奇怪的 WQS 二分板板。吃了一发罚时，原因是没人合法的时候要输出 \(0\)。但和 maimai 的 30 发比起来还是相形见绌。绅士考虑了这个，但是没判目标 \(&lt;\) 当前的情况遗憾 4 题离场。
场下看了 Diagnostics，发现其实第二发有个地方是 RE 了的（长度不足 \(6\) 我的 *std::max_element 会飞起来），但是不知道为啥就是 A 了。
E.1
猜到结论之后止步于此。试着打了分拆数然后（实际上是）写挂了，怀疑自己结论出错直到 5 题招笑离场 😅
B.1
哈哈 B 的 gcd 没开 long long 被 hack 了，rk55 to 6000+
]]></content>
      <tags>
        <tag>差分</tag>
        <tag>背包</tag>
      </tags>
  </entry>
  <entry>
    <title>杂题选谈：树 DP</title>
    <url>/20250803/</url>
    <content><![CDATA[树上的 DP 以及 和树有关的 DP


A - Svjetlo
https://www.luogu.com.cn/problem/P7163
很容易想到一种状态设计，即令 \(f_{x,0/1/2}\) 分别表示有 \(0/1/2\) 个端点在子树内部的情况；然后就开始思考，如何满足对于开关状态的要求？
还是想少了。如果再加一维，从『状态为开或关』思考就会轻松很多，令 \(f_{x,0/1/2,0/1}\) 表示有 \(0/1/2\) 个端点再子树外部，且子树内操作完后 \(x\) 为关 / 开的最少步数。然后分类讨论转移方式即可。
一个比较方便的讨论方式是，先确定某种情况下，访问 \(u\) 与 \(v\) 的次数，然后就可以得到它们原本的状态。

#include &lt;bits/stdc++.h&gt;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n, rt = -1;
    std::cin &gt;&gt; n;
    std::vector&lt;int&gt; a(n + 1);
    for (int i = 1; i &lt;= n; ++i) &#123;
        char t;
        std::cin &gt;&gt; t;
        a[i] = t - &#39;0&#39;;
        if (!a[i])
            rt = i;
    &#125;
    if (rt == -1) &#123;
        std::cout &lt;&lt; 0 &lt;&lt; &#39;\n&#39;;
        return 0;
    &#125;
    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);
    for (int i = 1, x, y; i &lt; n; ++i) &#123;
        std::cin &gt;&gt; x &gt;&gt; y;
        g[x].push_back(y), g[y].push_back(x);
    &#125;
    std::vector&lt;int&gt; tag(n + 1);
    std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int fa) &#123;
        tag[x] = a[x];
        for (auto i : g[x])
            if (i != fa)
                DFS(i, x), tag[x] &amp;= tag[i];
        return;
    &#125;;
    DFS(rt, -1);
    std::vector&lt;std::vector&lt;std::vector&lt;int&gt; &gt; &gt; f(n + 1, std::vector&lt;std::vector&lt;int&gt; &gt; (3, std::vector&lt;int&gt; (2, 0x3f3f3f3f)));
    DFS = [&amp;](int x, int fa) &#123;
        f[x][0][a[x]] = 0;
        for (auto i : g[x])
            if (i != fa &amp;&amp; !tag[i]) &#123;
                DFS(i, x);
                auto g = f[x];
                f[x][0][0] = std::min(g[0][0] + f[i][0][1] + 4, g[0][1] + f[i][0][0] + 2);
                f[x][0][1] = std::min(g[0][1] + f[i][0][1] + 4, g[0][0] + f[i][0][0] + 2);
                f[x][1][0] = std::min(&#123; g[1][0] + f[i][0][1] + 4, g[1][1] + f[i][0][0] + 2, g[0][0] + f[i][1][0] + 3, g[0][1] + f[i][1][1] + 1 &#125;);
                f[x][1][1] = std::min(&#123; g[1][1] + f[i][0][1] + 4, g[1][0] + f[i][0][0] + 2, g[0][1] + f[i][1][0] + 3, g[0][0] + f[i][1][1] + 1 &#125;);
                f[x][2][0] = std::min(&#123; g[2][0] + f[i][0][1] + 4, g[2][1] + f[i][0][0] + 2, g[1][0] + f[i][1][1], g[1][1] + f[i][1][0] + 2, g[0][0] + f[i][2][1] + 4, g[0][1] + f[i][2][0] + 2 &#125;);
                f[x][2][1] = std::min(&#123; g[2][1] + f[i][0][1] + 4, g[2][0] + f[i][0][0] + 2, g[1][1] + f[i][1][1], g[1][0] + f[i][1][0] + 2, g[0][1] + f[i][2][1] + 4, g[0][0] + f[i][2][0] + 2 &#125;);
            &#125;
        f[x][1][0] = std::min(f[x][1][0], f[x][0][1] + 1);
        f[x][1][1] = std::min(f[x][1][1], f[x][0][0] + 1);
        f[x][2][0] = std::min(f[x][2][0], f[x][1][0]);
        f[x][2][1] = std::min(f[x][2][1], f[x][1][1]);
        // for (int i = 0; i &lt; 3; ++i)
        //     for (int j = 0; j &lt; 2; ++j)
        //         printf(&quot;f[%d][%d][%d] = %d\n&quot;, x, i, j, f[x][i][j]);
        return;
    &#125;;
    DFS(rt, -1);
    std::cout &lt;&lt; f[rt][2][1] &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;


B - One to One
https://atcoder.jp/contests/arc140/tasks/arc140_d
观察原图上连通块，发现要么是没有未确定边的基环树，要么是有恰好一条未确定边的树。缩点，任意为未确定边赋值，考察最后得到的连通块，发现要么是以『基环树点』为根的树，要么是不包含『基环树点』的（内向）基环树。
这里要用到贡献的思想。考虑将全局划分为若干个部分，保证每部分的单步价值是可确定的。将第一步，即对树和基环树的讨论拆开，对于树，其数量确定；对于基环树，发现环的数量即为基环树的数量，进一步将所有步中的『环』这一类分开，统计成环的方案数就可以得到基环树的贡献。具体地，令 \(f_{i,j}\) 为在前 \(i\) 个点中选择 \(j\) 个成一个环的方案数，则有：
\[
f_{i,j}=f_{i-1,j}+f_{i-1,j-1}\times siz_i
\]
最后计算每个环的贡献即可。注意还要算上环内部的排列（注意循环位移）。

#include &lt;bits/stdc++.h&gt;
const int mod = 998244353;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n;
    std::cin &gt;&gt; n;
    std::vector&lt;int&gt; a(n + 1), tag(n + 1), s(n + 1, 1), fa(n + 1), siz(n + 1);
    std::iota(fa.begin() + 1, fa.end(), 1);
    std::function&lt;int(int)&gt; find = [&amp;](int x) &#123;
        return x == fa[x] ? x : fa[x] = find(fa[x]);
    &#125;;
    auto merge = [&amp;](int x, int y) &#123;
        x = find(x), y = find(y);
        if (x != y) &#123;
            tag[y] += tag[x];
            s[y] += s[x];
            fa[x] = y;
        &#125;
        return;
    &#125;;
    for (int i = 1; i &lt;= n; ++i)  &#123;
        std::cin &gt;&gt; a[i], fa[i] = i;
        if (a[i] == -1)
            tag[i] = 1;
        else
            merge(i, a[i]);
    &#125;
    int cnt1 = 0, cnt2 = 0;
    for (int i = 1; i &lt;= n; ++i) &#123;
        cnt1 += (fa[i] == i &amp;&amp; !tag[i]);
        if (fa[i] == i &amp;&amp; tag[i])
            siz[++cnt2] = s[i];
    &#125;
    auto qkp = [&amp;](long long x, int y) &#123;
        auto res(1ll);
        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)
            if (y &amp; 1)
                (res *= x) %= mod;
        return res;
    &#125;;
    auto res(cnt1 * qkp(n, cnt2) % mod);
    std::vector&lt;std::vector&lt;long long&gt; &gt; f(cnt2 + 1, std::vector&lt;long long&gt; (cnt2 + 1));
    f[0][0] = 1ll;
    for (int i = 1; i &lt;= cnt2; ++i) &#123;
        // printf(&quot;i = %d, siz = %d: \n&quot;, i, siz[i]);
        for (int j = 0; j &lt;= i; ++j) &#123;
            f[i][j] = f[i - 1][j];
            if (j != 0)
                (f[i][j] += f[i - 1][j - 1] * siz[i]) %= mod;
            // printf(&quot;  f[%d][%d] = %lld\n&quot;, i, j, f[i][j]);
        &#125;
    &#125;
    for (int i = 1; i &lt;= cnt2; ++i) &#123;
        static auto fac(1ll);
        (res += f[cnt2][i] * fac % mod * qkp(n, cnt2 - i) % mod) %= mod;
        (fac *= i) %= mod;
    &#125;
    std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;


C - Diameter Cuts
https://codeforces.com/problemset/problem/1499/F
令 \(f_{x,i}\) 表示 \(x\) 上的最长链长为 \(i\) 的方案数，就可以用一个类似背包的过程求答案了。发现这个背包满足可以被优化的形式，故能在 \(O(nk)\) 内解决问题。

#include &lt;bits/stdc++.h&gt;
const int mod = 998244353;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n, k;
    std::cin &gt;&gt; n &gt;&gt; k, ++k;
    if (k == 0) &#123;
        std::cout &lt;&lt; 1 &lt;&lt; &#39;\n&#39;;
        return 0;
    &#125;
    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);
    for (int i = 1, x, y; i &lt; n; ++i) &#123;
        std::cin &gt;&gt; x &gt;&gt; y;
        g[x].push_back(y), g[y].push_back(x);
    &#125;
    std::vector&lt;int&gt; h(n + 1);
    std::vector&lt;std::vector&lt;long long&gt; &gt; f(n + 1, std::vector&lt;long long&gt; (k + 1));
    std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int fa) &#123;
        f[x][1] = 1ll, h[x] = 1;
        for (auto i : g[x])
            if (i != fa) &#123;
                DFS(i, x);
                std::vector&lt;long long&gt; g(k + 1);
                g.swap(f[x]);
                for (int j = std::min(h[x], k); j; --j)
                    for (int l = std::min(h[i], k - j); ~l; --l)
                        (f[x][std::max(j, l + 1)] += g[j] * f[i][l] % mod) %= mod;
                h[x] = std::max(h[x], h[i] + 1);
            &#125;
        for (int i = 1; i &lt;= h[x] &amp;&amp; i &lt;= k; ++i)
            (f[x][0] += f[x][i]) %= mod;
        // for (int i = 0; i &lt;= h[x] &amp;&amp; i &lt;= k; ++i)
        //     printf(&quot;f[%d][%d] = %lld\n&quot;, x, i, f[x][i]);
        return;
    &#125;;
    DFS(1, -1);
    auto res(0ll);
    for (int i = 1; i &lt;= k; ++i)
        (res += f[1][i]) %= mod;
    std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;


D - Leaf Partition
https://codeforces.com/problemset/problem/1146/F
假设已经完成分组，欲判定这种方式是否合法，容易想到对每一组叶子建立虚树，则该分组方式合法，当且仅当没有一个点被多个虚树占用。也即，我们需要在总的虚树上选出一些点，让它们可以覆盖所有叶子。
虚树上 DP，容易发现当且仅当存在 \(\ge 2\) 个儿子想要分进同一个虚树时，\(i\) 会被选到。故令 \(f_{i, 0/1/2}\) 表示当前有 \(0/1/\ge 2\) 个儿子想要选择 \(i\) 时的方案数，DP 即可。
在实现的过程中就会发现根本不需要求虚树，原树上 DP 就可以了。

#include &lt;bits/stdc++.h&gt;
const int mod = 998244353;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n;
    std::cin &gt;&gt; n;
    std::vector&lt;int&gt; fa(n + 1);
    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);
    for (int i = 2; i &lt;= n; ++i)
        std::cin &gt;&gt; fa[i], g[fa[i]].push_back(i);
    std::vector&lt;std::array&lt;long long, 3&gt; &gt; f(n + 1);
    std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;
        if (g[x].empty())
            f[x][2] = 1ll;
        else
            f[x][0] = 1ll;
        for (auto i : g[x]) &#123;
            DFS(i);
            auto F0 = (f[i][0] + f[i][2]) % mod, F1 = (f[i][1] + f[i][2]) % mod;
            f[x][2] = (f[x][2] * F0 % mod + f[x][2] * F1 % mod + f[x][1] * F1 % mod) % mod;
            f[x][1] = (f[x][1] * F0 % mod + f[x][0] * F1 % mod) % mod;
            (f[x][0] *= F0) %= mod;
        &#125;
        // printf(&quot;%d: %lld / %lld / %lld\n&quot;, x, f[x][0], f[x][1], f[x][2]);
        return;
    &#125;;
    DFS(1);
    std::cout &lt;&lt; (f[1][0] + f[1][2]) % mod &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;


E - Uniformly Branched Trees
https://codeforces.com/problemset/problem/724/F
感觉是很常见的套路，但是我不会 😱
在手玩样例的时候可以感性认知到，每个树会被每种点作为根的情况统计一次。且如果固定以某种（化学环境）的点为根，可以通过按 siz 从小到大排列唯一求解出该树。
发现以重心为根（即钦定根为重心）可以带来很多优美的性质。因为 siz 是好确定的，且是儿子的排序依据，所以选重心便于统计，同时满足每种树最多被统计两次（当且仅当有两个重心）。
发现这就变成了多重集的组合数，设 \(f_{i,j,k}\) 表示已经花费 \(i\) 个点组成一个子树，子树的根节点当前已经确认了 \(j\) 个儿子，最靠右的一个 siz \(\le k\) 的方案数。得到 \(f_{i,j,k}=\sum_{x=0} f_{i-x\cdot k,j-x,k-1}\cdot \binom{f_{k,d-1,k}+x-1}{x}\)（相当于将 \(x\) 个无标号的位置 / 球分配给 \(f_{k,d-1,k}\) 个有标号的选项 / 盒子，插板即可）。
若 \(n\) 为奇数，则可直接输出 \(f_{n,d,\lfloor\frac n2\rfloor}\)；若 \(n\) 为偶数，则可能存在两个重心，即需要统计拥有两个重心，且以两个重心分别为根时长相不同的树种类。这种情况下显然存在一条边，左右两边 siz 相同且长相不同。故数量为 \(\binom{f_{\lfloor \frac n2\rfloor, d-1,\lfloor \frac n2\rfloor}}{2}\)，容斥掉即可。
需要特判 \(n\le2\) 的情况。

#include &lt;bits/stdc++.h&gt;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n, d, mod;
    std::cin &gt;&gt; n &gt;&gt; d &gt;&gt; mod;
    if (n &lt;= 2) &#123;
        std::cout &lt;&lt; 1 &lt;&lt; &#39;\n&#39;;
        return 0;
    &#125;
    using arr = std::vector&lt;long long&gt;;
    using brr = std::vector&lt;arr&gt;;
    using crr = std::vector&lt;brr&gt;;
    auto qkp = [&amp;](long long x, int y) &#123;
        auto res(1ll);
        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)
            if (y &amp; 1)
                (res *= x) %= mod;
        return res;
    &#125;;
    arr inv(d + 1);
    inv[0] = inv[1] = 1ll;
    auto fac = 1ll;
    for (int i = 2; i &lt;= d; ++i) &#123;
        (fac *= i) %= mod;
        inv[i] = qkp(fac, mod - 2);
    &#125;
    auto C = [&amp;](long long n, int m) &#123;
        if (m == 0)
            return 1ll;
        if (m &gt; n)
            return 0ll;
        auto res(1ll);
        for (auto i = 0; i &lt; m; ++i)
            (res *= n - i) %= mod;
        return res * inv[m] % mod;
    &#125;;
    crr f(n + 1, brr(d + 1, arr(n / 2 + 1)));
    f[1][0][0] = 1ll;
    for (int i = 1; i &lt;= n; ++i)
        for (int j = 0; j &lt;= d &amp;&amp; 1 + j &lt;= i; ++j) &#123;
            for (int x = 0; x &lt;= j &amp;&amp; x &lt;= i; ++x)
                f[i][j][1] += f[i - x][j - x][0];
            f[i][j][1] %= mod;
            for (int k = 2; k &lt;= n / 2; ++k) &#123;
                // bool flag = (i == 10 &amp;&amp; j == 3 &amp;&amp; k == 3);
                for (int x = 0; x &lt;= j &amp;&amp; x * k &lt;= i; ++x) &#123;
                    f[i][j][k] += f[i - x * k][j - x][k - 1] * C(f[k][d - 1][k - 1] + x - 1, x);
                    // if (flag)
                    //     printf(&quot;x = %d, f[%d][%d][%d](%lld) * C(%lld, %d)(%lld)\n&quot;, x, i - x * k, j - x, k - 1, f[i - x * k][j - x][k - 1], f[k][d - 1][k - 1] + x - 1, x, C(f[k][d - 1][k - 1] + x - 1, x));
                &#125;
                f[i][j][k] %= mod;
            &#125;
        &#125;
    // for (int i = 1; i &lt;= n; ++i)
    //     for (int j = 0; j &lt;= d &amp;&amp; j &lt;= i - 1; ++j, puts(&quot;&quot;))
    //         for (int k = 0; k &lt;= n / 2; ++k) &#123;
    //             printf(&quot;f[%d][%d][%d] = %lld\n&quot;, i, j, k, f[i][j][k]);
    //         &#125;
    if (n &amp; 1)
        std::cout &lt;&lt; f[n][d][n / 2] &lt;&lt; &#39;\n&#39;;
    else &#123;
        auto res(f[n][d][n / 2]);
        res = (res + mod - C(f[n / 2][d - 1][n / 2 - 1], 2)) % mod;
        std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
    &#125;
    return 0;
&#125;


A - Dominant Indices
https://codeforces.com/problemset/problem/1009/F
长剖板子；难点在于可能要复习一下长剖怎么写。

#include &lt;bits/stdc++.h&gt;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n;
    std::cin &gt;&gt; n;
    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);
    for (int i = 1, x, y; i &lt; n; ++i) &#123;
        std::cin &gt;&gt; x &gt;&gt; y;
        g[x].push_back(y), g[y].push_back(x);
    &#125;
    std::vector&lt;int&gt; h(n + 1), son(n + 1);
    std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int fa) &#123;
        h[x] = 1;
        for (auto i : g[x])
            if (i != fa) &#123;
                DFS(i, x);
                h[x] = std::max(h[x], h[i] + 1);
                if (h[i] &gt; h[son[x]])
                    son[x] = i;
            &#125;
        return;
    &#125;;
    DFS(1, -1);
    std::vector&lt;int&gt; _f(2 * n + 1), res(n + 1);
    auto pos(_f.begin());
    std::vector&lt;decltype(pos)&gt; f(n + 1);
    DFS = [&amp;](int x, int fa) &#123;
        ++f[x][0];
        if (!son[x]) &#123;
            res[x] = 0;
            return;
        &#125;
        f[son[x]] = std::next(f[x]);
        DFS(son[x], x);
        int mx = -std::max(std::make_pair(f[x][res[son[x]] + 1], -(res[son[x]] + 1)), std::make_pair(1, 0)).second;
        for (auto i : g[x])
            if (i != fa &amp;&amp; i != son[x]) &#123;
                f[i] = pos, pos = std::next(pos, h[i] + 1);
                DFS(i, x);
                for (int j = 0; j &lt;= h[i]; ++j) &#123;
                    f[x][j + 1] += f[i][j];
                    if (j + 1 != mx &amp;&amp; std::make_pair(f[x][j + 1], -(j + 1)) &gt; std::make_pair(f[x][mx], -mx))
                        mx = j + 1;
                &#125;
            &#125;
        // printf(&quot;%d: &quot;, x);
        // for (int i = 0; i &lt;= h[x]; ++i)
        //     printf(&quot;%d &quot;, f[x][i]);
        // puts(&quot;&quot;);
        res[x] = mx;
        return;
    &#125;;
    f[1] = pos, pos = std::next(pos, h[1]);
    DFS(1, -1);
    for (int i = 1; i &lt;= n; ++i)
        std::cout &lt;&lt; res[i] &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;


B - 树上异或
https://www.luogu.com.cn/problem/P9745
和 Svjetlo 很像，把连通块的异或和放到状态里，拆位后令 \(f_{i,j,0/1}\) 表示点 \(i\) 所在的连通块在第 \(j\) 位异或和为 \(0/1\) 的权值（不计 \(i\) 所在连通块），转移即可。

#include &lt;bits/stdc++.h&gt;
const int mod = 998244353;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n;
    std::cin &gt;&gt; n;
    std::vector&lt;long long&gt; a(n + 1);
    for (int i = 1; i &lt;= n; ++i)
        std::cin &gt;&gt; a[i];
    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);
    for (int i = 2, x; i &lt;= n; ++i) &#123;
        std::cin &gt;&gt; x;
        g[x].push_back(i), g[i].push_back(x);
    &#125;
    std::vector&lt;long long&gt; dp(n + 1);
    std::vector&lt;std::array&lt;std::array&lt;long long, 2&gt;, 60&gt; &gt; f(n + 1);
    std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int fa) &#123;
        for (int i = 0; i &lt; 60; ++i)
            f[x][i][(a[x] &gt;&gt; i) &amp; 1] = 1ll;
        for (auto i : g[x])
            if (i != fa) &#123;
                DFS(i, x);
                for (int j = 0; j &lt; 60; ++j) &#123;
                    auto f1 = f[x][j];
                    f[x][j][0] = (f1[0] * dp[i] % mod + f1[0] * f[i][j][0] % mod + f1[1] * f[i][j][1] % mod) % mod;
                    f[x][j][1] = (f1[1] * dp[i] % mod + f1[0] * f[i][j][1] % mod + f1[1] * f[i][j][0] % mod) % mod;
                &#125;
            &#125;
        for (int i = 0; i &lt; 60; ++i)
            dp[x] += (1ll &lt;&lt; i) % mod * f[x][i][1] % mod;
        dp[x] %= mod;
        return;
    &#125;;
    DFS(1, -1);
    std::cout &lt;&lt; dp[1] &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;


C - 一个网的路
https://www.luogu.com.cn/problem/P8595
首先需要意识到，树和链的边数是一样的，炸掉了多少条边，在之后就会花多少代价补回来。故炸一个点的代价为度数 +1。对于一个点 \(u\)，分为四种可能性：

被炸了，单独作为一个连通块。
没被炸，儿子全部被炸了。
没被炸，有 1 个儿子没被炸。
没被炸，有 2 个儿子没被炸。

分别用 \(f_{u,0/1/2/3}\) 代表上面四种可能性，转移即可。
贺了个 fread，擦边跑过了。这个不是 \(O(n)\) 的吗？

#include &lt;bits/stdc++.h&gt;
const int LEN = (1 &lt;&lt; 20);
#ifdef ONLINE_JUDGE
int nec(void) &#123;
    static char buf[LEN], *p = buf, *e = buf;
    if (p == e) &#123;
        e = buf + fread(buf, 1, LEN, stdin);
        if (e == buf) return EOF;
        p = buf;
    &#125;
    return *p++;
&#125;
#else
#define nec getchar

#endif
bool read(int &amp;x) &#123;
    x = 0;
    bool f = 0;
    char ch = nec();
    while (ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123;
        if (ch == EOF) return 0;
        if (ch == &#39;-&#39;) f = 1;
        ch = nec();
    &#125;
    while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) &#123;
        x = x * 10 + ch - &#39;0&#39;;
        ch = nec();
    &#125;
    if (f) x = -x;
    return 1;
&#125;
void print(int x) &#123;
    if (x &lt; 0)
        putchar(&#39;-&#39;), x = -x;
    if (x &gt;= 10) print(x / 10);
    putchar(x % 10 + &#39;0&#39;);
    return;
&#125;
void print(int x, char ch) &#123;
    print(x), putchar(ch);
    return;
&#125;
int main() &#123;
    int n, m;
    read(n), read(m);
    int res = (n - 1) - m;
    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);
    for (int x, y; m--; ) &#123;
        read(x), read(y);
        g[x].push_back(y), g[y].push_back(x);
    &#125;
    std::vector&lt;int&gt; tag(n + 1);
    std::vector&lt;std::array&lt;int, 4&gt; &gt; f(n + 1);
    std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int fa) &#123;
        tag[x] = 1;
        f[x][0] = (fa != -1) + 1;
        f[x][2] = f[x][3] = 0x3f3f3f3f;
        for (auto i : g[x])
            if (i != fa) &#123;
                DFS(i, x);
                f[x][3] = std::min(f[x][3] + f[i][0], f[x][2] + std::min(f[i][1], f[i][2]));
                f[x][2] = std::min(f[x][2] + f[i][0], f[x][1] + std::min(f[i][1], f[i][2]));
                f[x][1] += f[i][0];
                f[x][0] += std::min(&#123; f[i][0] - 1, f[i][1], f[i][2], f[i][3] &#125;) + 1;
            &#125;
        return;
    &#125;;
    for (int i = 1; i &lt;= n; ++i)
        if (!tag[i]) &#123;
            DFS(i, -1);
            res += *std::min_element(f[i].begin(), f[i].end());
        &#125;
    print(res, &#39;\n&#39;);
    return 0;
&#125;


D - 随机树
https://www.luogu.com.cn/problem/P3830
对于第一问，令 \(f_x\) 表示共有 \(x\) 个叶子时的期望深度，两个新叶子的期望深度为 \(f_{x-1}+1\)，delta 为 \(f_{x-1}+2\)，故有 \(f_x=\dfrac {(x-1)f_{x-1}+f_{x-1}+2}x\)，递推即可。
对于第二问，令 \(f_{x,k}\) 表示有 \(x\) 个叶子，深度 \(\ge k\) 的概率（一种理解是从整数概率公式的角度出发）。则考虑枚举左、右叶子数，对于左侧叶子数为 \(i\) 的情况，为了去重，只选择深度为 \(k-1\) 的叶子展开。只考虑某种组合的出现概率，为 \(f_{i,k-1}+f_{x-i,k-1}-f_{i,k-1}\cdot f_{x-i,k-1}\)。数归可以证明，对于任意 \(i\)，深度为 \(k-1\) 的叶子被选中的概率均为 \(\dfrac 1{x-1}\)。

#include &lt;bits/stdc++.h&gt;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int q, n;
    std::cin &gt;&gt; q &gt;&gt; n;
    std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(6);
    if (q == 1) &#123;
        std::vector&lt;double&gt; f(n + 1);
        for (int i = 2; i &lt;= n; ++i)
            f[i] = (f[i - 1] * (i - 1) + f[i - 1] + 2.) / i;
        std::cout &lt;&lt; f[n] &lt;&lt; &#39;\n&#39;;
    &#125;
    else &#123;
        std::vector&lt;std::vector&lt;double&gt; &gt; f(n + 1, std::vector&lt;double&gt; (n + 1));
        for (int i = 1; i &lt;= n; ++i) &#123;
            f[i][0] = 1.;
            for (int j = 1; j &lt; i; ++j) &#123;
                auto s(0.);
                for (int k = 1; k &lt; i; ++k)
                    s += f[k][j - 1] + f[i - k][j - 1] - f[k][j - 1] * f[i - k][j - 1];
                f[i][j] = s / (i - 1);
            &#125;
        &#125;
        auto res(0.);
        for (int i = 1; i &lt; n; ++i)
            res += f[n][i];
        std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
    &#125;
    return 0;
&#125;


E - Complete Compress
https://atcoder.jp/contests/agc034/tasks/agc034_e
对于链，发现可以枚举最后聚集的点，答案与配对方式无关，check 是否能配对即可。
如果不是链，则相比链，还可以选择同一子树中不存在祖孙关系的两个点，将它们都向 LCA 移一步。
故而，可以在链的做法上打一个补丁，观察到先『内部消化』，再在子树间配对一定不劣，且答案仍然和配对方式无关。故令 \(f_x\) 表示点 \(x\) 内最多消掉多少对，就可以 check 了。

#include &lt;bits/stdc++.h&gt;
const long long inf = 1e18;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;line_02.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n;
    std::cin &gt;&gt; n;
    std::vector&lt;int&gt; a(n + 1);
    for (int i = 1; i &lt;= n; ++i) &#123;
        char t;
        std::cin &gt;&gt; t;
        a[i] = t - &#39;0&#39;;
    &#125;
    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);
    for (int i = 1, x, y; i &lt; n; ++i) &#123;
        std::cin &gt;&gt; x &gt;&gt; y;
        g[x].push_back(y), g[y].push_back(x);
    &#125;
    auto res(inf);
    for (int i = 1; i &lt;= n; ++i) &#123;
        std::vector&lt;int&gt; s(n + 1);
        std::vector&lt;long long&gt; f(n + 1), cnt(n + 1);
        std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int fa) &#123;
            s[x] = a[x];
            int son = 0;
            auto sum(0ll);
            for (auto i : g[x])
                if (i != fa) &#123;
                    DFS(i, x), s[x] += s[i];
                    sum += cnt[i];
                    if (cnt[i] &gt; cnt[son])
                        son = i;
                &#125;
            if (son) &#123;
                if (cnt[son] * 2 &lt;= sum)
                    f[x] = sum / 2;
                else
                    f[x] = sum - cnt[son] + std::min(f[son], (cnt[son] - (sum - cnt[son])) / 2);
            &#125;
            cnt[x] = sum;
            if (x != i)
                cnt[x] += s[x];
            return;
        &#125;;
        DFS(i, -1);
        if (cnt[i] % 2 == 0 &amp;&amp; f[i] == cnt[i] / 2)
            res = std::min(res, cnt[i] / 2);
    &#125;
    if (res == inf)
        std::cout &lt;&lt; -1 &lt;&lt; &#39;\n&#39;;
    else
        std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;

]]></content>
      <tags>
        <tag>DP</tag>
        <tag>树形 DP</tag>
        <tag>长链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title>杂题选谈：状压 DP</title>
    <url>/20250805/</url>
    <content><![CDATA[没补完（1/3），动作还是太慢了


A - 只不过是长的领带 2 / Just Long Neckties 2
https://www.luogu.com.cn/problem/P11665
需要观察到，任意时刻 \(B\) 中不存在重复元素。把 \(B\) 压出来，令 \(f_{i,S}\) 表示选了 \(i\)，当前 \(B\) 为 \(S\) 是否可行，能够 \(O(n\cdot 2^V)\)。对于某个 \(S\)，只关心它最远能到达哪个 \(i\)，故令 \(f_S\) 记录之。对于每一个 \(S\)，都可以找到 \(f_S\) 后第一对 \(a_i,a_{i+1}\notin S\)，用其刷表。
发现『找 \(f_S\) 后第一对非法元素』是很慢的，考虑优化；对于每个 \(i\) 维护 \(p\) 在其后第一次出现的位置 \(x\)，对于每个 \(a_x=p\) 维护 \(x\) 后方 \(a_y=p,a_{y+1}=q\) 第一次出现的位置，相当于先找 \(p\) 再找 \((p,q)\)，就可以做到 \(O(V^2\cdot 2^V+n\cdot V)\)。

#include &lt;bits/stdc++.h&gt;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n;
    std::cin &gt;&gt; n;
    std::vector&lt;int&gt; a(n + 1);
    int V = 0;
    for (int i = 1; i &lt;= n; ++i) &#123;
        std::cin &gt;&gt; a[i];
        V = std::max(V, a[i]--);
    &#125;
    std::vector&lt;std::vector&lt;int&gt; &gt; tx(n + 1, std::vector&lt;int&gt; (V)), ty(n + 1, std::vector&lt;int&gt; (V));
    std::vector&lt;int&gt; lp(V);
    std::vector&lt;std::vector&lt;int&gt; &gt; lpq(V, std::vector&lt;int&gt; (V));
    for (int i = n; ~i; --i) &#123;
        if (i &amp;&amp; i != n)
            lpq[a[i]][a[i + 1]] = i;
        for (int j = 0; j &lt; V; ++j) &#123;
            tx[i][j] = lp[j];
            if (i != n)
                ty[i][j] = lpq[a[i]][j];
        &#125;
        if (i != 0)
            lp[a[i]] = i;
    &#125;
    int siz = 1 &lt;&lt; V, res = 21;
    std::vector&lt;int&gt; f(siz);
    for (int i = 0; i &lt; siz; ++i) &#123;
        std::vector&lt;int&gt; p0, p1;
        for (int j = 0; j &lt; V; ++j)
            if ((i &gt;&gt; j) &amp; 1)
                p1.push_back(j);
            else
                p0.push_back(j);
        int j = n;
        for (auto p : p0)
            if (tx[f[i]][p])
                for (auto q : p0)
                    if (ty[tx[f[i]][p]][q])
                        j = std::min(j, ty[tx[f[i]][p]][q]);
        if (j != n) &#123;
            f[i ^ (1 &lt;&lt; a[j])] = std::max(f[i ^ (1 &lt;&lt; a[j])], j);
            f[i ^ (1 &lt;&lt; a[j + 1])] = std::max(f[i ^ (1 &lt;&lt; a[j + 1])], j + 1);
            for (auto k : p1) &#123;
                f[i ^ (1 &lt;&lt; k) ^ (1 &lt;&lt; a[j])] = std::max(f[i ^ (1 &lt;&lt; k) ^ (1 &lt;&lt; a[j])], j);
                f[i ^ (1 &lt;&lt; k) ^ (1 &lt;&lt; a[j + 1])] = std::max(f[i ^ (1 &lt;&lt; k) ^ (1 &lt;&lt; a[j + 1])], j + 1);
            &#125;
        &#125;
        else
            res = std::min(res, __builtin_popcount(i));
    &#125;
    std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;


B - Cut and Reorder
https://atcoder.jp/contests/abc328/tasks/abc328_g
不妨先重排再修改，令 \(f_{i,S}\) 表示已经重排好新序列的前 \(i\) 个元素，对应原序列状态 \(S\) 的最小代价。枚举新区间容易转移。可以发现枚举 \(i,S\) 的实际复杂度为 \(O(2^n)\)（空间也可以这么优化），预处理之后总时间复杂度 \(O(n^2\cdot 2^n)\)，跑不满，可以通过。

#include &lt;bits/stdc++.h&gt;
const long long inf = 1e18;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n;
    long long c;
    std::cin &gt;&gt; n &gt;&gt; c;
    std::vector&lt;long long&gt; a(n), b(n);
    for (int i = 0; i &lt; n; ++i)
        std::cin &gt;&gt; a[i];
    for (int i = 0; i &lt; n; ++i)
        std::cin &gt;&gt; b[i];
    using arr = std::vector&lt;long long&gt;;
    using brr = std::vector&lt;arr&gt;;
    using crr = std::vector&lt;brr&gt;;
    brr p(n, arr(n));
    crr g(n, brr(n, arr(n)));
    for (int l = 0; l &lt; n; ++l)
        for (int r = l; r &lt; n; ++r) &#123;
            for (int k = l; k &lt;= r; ++k)
                p[l][r] ^= (1 &lt;&lt; k);
            for (int R = r - l; R &lt; n; ++R)
                for (int L = R, j = r; j &gt;= l; --L, --j)
                    g[l][r][R] += std::abs(b[L] - a[j]);
        &#125;
    int siz = 1 &lt;&lt; n;
    std::vector&lt;long long&gt; f(siz, inf);
    f[0] = 0ll;
    for (int j = 1; j &lt; siz; ++j) &#123;
        int i = __builtin_popcount(j) - 1;
        for (int r = 0; r &lt; n; ++r)
            for (int l = r; ~l &amp;&amp; ((j &gt;&gt; l) &amp; 1); --l)
                f[j] = std::min(f[j], f[j ^ p[l][r]] + g[l][r][i] + c);
    &#125;
    std::cout &lt;&lt; f[siz - 1] - c &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;


C - Electric Circuit
https://atcoder.jp/contests/abc321/tasks/abc321_g
很像无向图容斥？令 \(f_S\) 表示让 \(S\) 内部完成配对，可以不连通的方案数，那么当且仅当 \(S\) 内部点出、入度之和相等（记为 \(cnt\)）时，\(f_S\) 有值 \(cnt!\)。相似地，设 \(g_S\) 表示让 \(S\) 完成配对，成为一个连通块的方案数，得到 \(g_S=f_S-\sum\limits_{v\in S} f_{S\oplus v}\cdot g_v\)。让 \(v\) 必须包含 \(S\) 中编号最小的点就可以去重。
从贡献的角度出发，\(S\) 带来的贡献就是 \(g_S\cdot f_{U\oplus S}\)，其中 \(U\) 是全集。最后除以 \(M!\) 求出期望。
复杂度 \(O(3^n)\)。

#include &lt;bits/stdc++.h&gt;
const int mod = 998244353;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n, m;
    std::cin &gt;&gt; n &gt;&gt; m;
    std::vector&lt;int&gt; ci(n), co(n);
    for (int i = 1, x; i &lt;= m; ++i)
        std::cin &gt;&gt; x, ++ci[x - 1];
    for (int i = 1, x; i &lt;= m; ++i)
        std::cin &gt;&gt; x, ++co[x - 1];
    std::vector&lt;long long&gt; fac(m + 1);
    fac[0] = 1ll;
    for (int i = 1; i &lt;= m; ++i)
        fac[i] = fac[i - 1] * i % mod;
    auto qkp = [&amp;](long long x, int y) &#123;
        auto res(1ll);
        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)
            if (y &amp; 1)
                (res *= x) %= mod;
        return res;
    &#125;;
    int siz = 1 &lt;&lt; n;
    std::vector&lt;long long&gt; f(siz), g(siz);
    for (int i = 1; i &lt; siz; ++i) &#123;
        int si = 0, so = 0;
        for (int j = 0; j &lt; n; ++j)
            if ((i &gt;&gt; j) &amp; 1)
                si += ci[j], so += co[j];
        if (si == so)
            f[i] = fac[si];
    &#125;
    auto res(0ll);
    for (int i = 1; i &lt; siz; ++i) &#123;
        g[i] = f[i];
        int mn = 0;
        for (int j = 0; j &lt; n; ++j)
            if ((i &gt;&gt; j) &amp; 1) &#123;
                mn = j;
                break;
            &#125;
        int s = i ^ (1 &lt;&lt; mn);
        (g[i] += mod - g[1 &lt;&lt; mn] * f[s] % mod) %= mod;
        for (int j = (s - 1) &amp; s; j; j = (j - 1) &amp; s)
            (g[i] += mod - g[j ^ (1 &lt;&lt; mn)] * f[s ^ j] % mod) %= mod;
        if (i != siz - 1)
            (res += g[i] * f[(siz - 1) ^ i]) %= mod;
        else
            (res += g[i]) %= mod;
    &#125;
    std::cout &lt;&lt; res * qkp(fac[m], mod - 2) % mod &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;


D - Count Grid 3-coloring
https://atcoder.jp/contests/abc379/tasks/abc379_g
轮廓线 DP。把每一列已经确定的最靠下的元素压起来，每行逐个确定即可。
发现有效状态中只能容许最多一对相邻相同元素，这样复杂度就能降下来了。注意特判 \(1\times 1\) 的情况。

#include &lt;bits/stdc++.h&gt;
const int mod = 998244353;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n, m;
    std::cin &gt;&gt; n &gt;&gt; m;
    std::array&lt;int, 15&gt; p;
    p[0] = 1;
    for (int i = 1; i &lt; 15; ++i)
        p[i] = p[i - 1] * 3;
    std::vector&lt;std::vector&lt;int&gt; &gt; a;
    if (n &gt;= m) &#123;
        a.assign(n + 1, std::vector&lt;int&gt; (m + 1));
        for (int i = 1; i &lt;= n; ++i) 
            for (int j = 1; j &lt;= m; ++j) &#123;
                char t;
                std::cin &gt;&gt; t, a[i][j] = (t == &#39;?&#39; ? -1 : t - &#39;1&#39;);
            &#125;
    &#125;
    else &#123;
        std::swap(n, m);
        a.assign(n + 1, std::vector&lt;int&gt; (m + 1));
        for (int i = 1; i &lt;= m; ++i)
            for (int j = 1; j &lt;= n; ++j) &#123;
                char t;
                std::cin &gt;&gt; t, a[j][i] = (t == &#39;?&#39; ? -1 : t - &#39;1&#39;);
            &#125;
    &#125;
    int siz = p[m];
    using arr = std::vector&lt;long long&gt;;
    using brr = std::vector&lt;arr&gt;;
    using crr = std::vector&lt;brr&gt;;
    std::vector&lt;int&gt; s, tab(siz, -1);
    auto getv_1 = [&amp;](int j, int i) &#123;
        return (j / p[i - 1]) % 3;
    &#125;;
    auto getv = [&amp;](int j, int i) &#123;
        return (s[j] / p[i - 1]) % 3;
    &#125;;
    auto chg = [&amp;](int j, int i, int v) &#123;
        return tab[s[j] - p[i - 1] * getv(j, i) + p[i - 1] * v];
    &#125;;
    auto out = [&amp;](int i) &#123;
        std::string s;
        for (int j = 1; j &lt;= m; ++j)
            s += &#39;1&#39; + getv_1(i, j);
        return s.c_str();
    &#125;;
    for (int i = 0; i &lt; siz; ++i) &#123;
        s.push_back(i);
        int cnt = 0;
        for (int j = 2; j &lt;= m; ++j)
            if (getv_1(i, j - 1) == getv_1(i, j) &amp;&amp; ++cnt &gt;= 2) &#123;
                s.pop_back();
                break;
            &#125;
    &#125;
    for (int i = 0; i &lt; (int)s.size(); ++i)
        tab[s[i]] = i;
    siz = (int)s.size();
    if (n == 1) &#123;
        std::cout &lt;&lt; (a[1][1] == -1 ? 3 : 1) &lt;&lt; &#39;\n&#39;;
        return 0;
    &#125;
    crr f(n + 1, brr(m + 1, arr(siz)));
    for (int i = 0; i &lt; siz; ++i)
        if ([&amp;](int i, int s) &#123;
            for (int j = 1; j &lt;= m; ++j) &#123;
                if (a[i][j] != -1 &amp;&amp; a[i][j] != getv(s, j))
                    return false;
                if (j != 1 &amp;&amp; getv(s, j) == getv(s, j - 1))
                    return false;
            &#125;
            return true;
        &#125; (1, i)) &#123;
            for (int p = 0; p &lt; 3; ++p)
                if ((a[2][1] == -1 || a[2][1] == p) &amp;&amp; getv(i, 1) != p &amp;&amp; ~chg(i, 1, p))
                    (++f[2][1][chg(i, 1, p)]) %= mod;
        &#125;
    for (int i = 2; i &lt;= n; ++i) &#123;
        for (int k = 1; k &lt; m; ++k)
            for (int j = 0; j &lt; siz; ++j)
                if (f[i][k][j]) &#123;
                    // printf(&quot;f[%d][%d][%s] = %lld\n&quot;, i, k, out(s[j]), f[i][k][j]);
                    for (int p = 0; p &lt; 3; ++p)
                        if ((a[i][k + 1] == -1 || a[i][k + 1] == p) &amp;&amp; getv(j, k) != p &amp;&amp; getv(j, k + 1) != p &amp;&amp; ~chg(j, k + 1, p))
                            (f[i][k + 1][chg(j, k + 1, p)] += f[i][k][j]) %= mod;
                &#125;
        for (int j = 0; j &lt; siz; ++j)
            if (i != n &amp;&amp; f[i][m][j])
                for (int p = 0; p &lt; 3; ++p)
                    if ((a[i + 1][1] == -1 || a[i + 1][1] == p) &amp;&amp; getv(j, 1) != p &amp;&amp; ~chg(j, 1, p))
                        (f[i + 1][1][chg(j, 1, p)] += f[i][m][j]) %= mod;
    &#125;
    auto res = 0ll;
    for (int i = 0; i &lt; siz; ++i)
        (res += f[n][m][i]) %= mod;
    std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;


E - Pure Straight
https://atcoder.jp/contests/arc126/tasks/arc126_d
手玩发现只要最终序列确定，那么移动的顺序不影响答案。故考虑确定目标位置和移动序列。考虑绝对值的几何意义，不妨令目标子序列中元素集中到被选中位置的中间元素，此时的代价可以计算。用点二进制技巧和库函数可以 \(O(1)\) 算代价。

#include &lt;bits/stdc++.h&gt;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n, k;
    std::cin &gt;&gt; n &gt;&gt; k;
    int siz = 1 &lt;&lt; k;
    std::vector&lt;int&gt; a(n + 1), f(siz, 0x3f3f3f3f);
    auto out = [&amp;](int j) &#123;
        std::string s;
        for (int i = 0; i &lt; k; ++i)
            s += (&#39;0&#39; + ((j &gt;&gt; i) &amp; 1));
        return s.c_str();
    &#125;;
    f[0] = 0;
    for (int i = 1; i &lt;= n; ++i) &#123;
        std::cin &gt;&gt; a[i], --a[i];
        for (int j = siz - 1; j &gt;= 0; --j) &#123;
            if (!((j &gt;&gt; a[i]) &amp; 1))
                f[j | (1 &lt;&lt; a[i])] = std::min(f[j | (1 &lt;&lt; a[i])], f[j] + __builtin_popcount(j &amp; (~((1 &lt;&lt; a[i]) - 1))));
            f[j] += std::min(__builtin_popcount(j), k - __builtin_popcount(j));
        &#125;
    &#125;
    std::cout &lt;&lt; f[siz - 1] &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;


F - 123 Set
https://atcoder.jp/contests/arc184/tasks/arc184_b
做过 集合选数（这个 trick 见过很多次了，应该不只这一道，但我想不起来了）很容易想到画一个表格或者 DAG 出来，其实都能做
对于表格左上角和 DAG 的源点，肯定是一个 \(x\)，其不是 \(2\) 或 \(3\) 的倍数。如果画表，横乘 3 竖乘 2，观察一下是包含了 \(1\sim n\) 恰好一次的很多个杨表（没什么用，提一嘴而已），考虑转化目标，发现是用一个不可旋转的倒 L 形骨牌可叠放地铺满异形表格，可以考虑轮廓线 DP
具体地，用 1 来表示拐角处，0 表示其他，叠放的时候 1 的优先级比 0 高，然后就可以做了。以 3 为行，悲观估计单个表格大概有 \(31\times 2^{19}\) 个状态，运算次数差不多 \(31\times 19\times 2^{19}\)；再发现长得一模一样的表格肯定方案数是一样的，如果把任意一个表格全部除以 \(x\)，就会得到 \(n=10^9\div x\) 时 \(1\) 为左上角的杨表，就是说长相只和 \(10^9\div x\) 的值有关，可以整除分块 😱 可预计的跑得非常不满，实践下来是可以过的（但是很慢）

#include &lt;bits/stdc++.h&gt;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n;
    std::cin &gt;&gt; n;
    auto calc = [&amp;](int r) &#123;
        return r - r / 2 - r / 3 + r / 6;
    &#125;;
    auto dp = [&amp;](int lim) &#123;
        if (lim == 1) &#123;
            // printf(&quot;lim = 1, ret 1&quot;);
            return 1;
        &#125;
        int n = 1, m = 1;
        for (int k = 1; k * 2 &lt;= lim; ++n, k *= 2);
        for (int k = 1; k * 3 &lt;= lim; ++m, k *= 3);
        int siz = 1 &lt;&lt; m;
        std::vector&lt;std::vector&lt;std::vector&lt;int&gt; &gt; &gt; f(2, std::vector&lt;std::vector&lt;int&gt; &gt; (2, std::vector&lt;int&gt; (siz))), p(n + 1, std::vector&lt;std::vector&lt;int&gt; &gt; (m));
        std::vector&lt;std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; &gt; t(2, std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; (2, std::vector&lt;std::pair&lt;int, int&gt; &gt; (siz))); // sb
        auto upd = [&amp;](int i, int k, int j, int v) &#123;
            if (t[i &amp; 1][k &amp; 1][j] != std::make_pair(i, k)) &#123;
                p[i][k].push_back(j);
                t[i &amp; 1][k &amp; 1][j] = &#123; i, k &#125;, f[i &amp; 1][k &amp; 1][j] = v;
            &#125;
            else
                f[i &amp; 1][k &amp; 1][j] = std::min(f[i &amp; 1][k &amp; 1][j], v);
            return;
        &#125;;
        auto chg = [&amp;](int i, int j, int v) &#123;
            return i ^ (((i &gt;&gt; j) &amp; 1) &lt;&lt; j) ^ (v &lt;&lt; j);
        &#125;;
        for (int i = 0; i &lt; siz; ++i) &#123;
            bool flag = 0;
            for (int j = 0; j &lt; m; ++j)
                if (((i &gt;&gt; j) &amp; 1) || (j &amp;&amp; ((i &gt;&gt; (j - 1)) &amp; 1)));
                else &#123;
                    flag = 1;
                    break;
                &#125;
            if (!flag)
                upd(1, m - 1, i, __builtin_popcount(i));
        &#125;
        for (int i = 2; i &lt;= n; i++) &#123;
            int m1 = 1;
            for (int x = (1 &lt;&lt; (i - 1)); x * 3ll &lt;= lim; ++m1, x *= 3);
            int siz1 = 1 &lt;&lt; m1;
            for (auto j : p[i - 1][m - 1]) &#123;
                if (j &amp; 1)
                    upd(i, 0, chg(j &amp; (siz1 - 1), 0, 0), f[(i - 1) &amp; 1][(m - 1) &amp; 1][j]);
                upd(i, 0, chg(j &amp; (siz1 - 1), 0, 1), f[(i - 1) &amp; 1][(m - 1) &amp; 1][j] + 1);
            &#125;
            m = m1, siz = siz1;
            for (int k = 0; k &lt; m - 1; ++k)
                for (auto j : p[i][k]) &#123;
                    if (((j &gt;&gt; k) &amp; 1) || ((j &gt;&gt; (k + 1)) &amp; 1))
                        upd(i, k + 1, chg(j, k + 1, 0), f[i &amp; 1][k &amp; 1][j]);
                    upd(i, k + 1, chg(j, k + 1, 1), f[i &amp; 1][k &amp; 1][j] + 1);
                &#125;
        &#125;
        int res = 0x3f3f3f3f;
        for (auto i : p[n][m - 1])
            res = std::min(res, f[n &amp; 1][(m - 1) &amp; 1][i]);
        return res;
    &#125;;
    int res = 0;
    for (int l = 1, r; l &lt;= n; l = r + 1) &#123;
        r = n / (n / l);
        if (calc(r) - calc(l - 1))
            res += (calc(r) - calc(l - 1)) * dp(n / l);
    &#125;
    std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;

]]></content>
      <tags>
        <tag>DP</tag>
        <tag>状压</tag>
      </tags>
  </entry>
  <entry>
    <title>学习笔记：分拆数与 Ferrers 图</title>
    <url>/20250807/</url>
    <content><![CDATA[需要知道概念和求法，有一定的用处


分拆数与互异分拆数
要求：给定一个正整数 \(n\)，要求将其划分为 \(m\) 个可重 / 不可重的正整数，问本质不同的方案数。（显然 \(m\) 与 \(\sqrt n\) 同阶。）
不妨令划分结果单调不降，则有两种 DP 路径：

法一：令 \(f_{i,j}\) 表示把 \(i\) 分成 \(j\) 个正整数的方案数。

不可重：考虑将这 \(j\) 个数减去 \(1\)。最多一个元素由 \(1\) 变为 \(0\)，组数减少 \(1\)；其他时候还是 \(j\) 组。故云 \(f_{i,j}=f_{i-j,j-1}+f_{i-j,j}\)。
可重：如果存在 \(1\)，可以删除之然后转移；否则仍整体减 \(1\) 转移。故曰 \(f_{i,j}=f_{i-1,j-1}+f_{i-j,j}\)。

该转移方法唯一性很显然。注意到第二维只和 \(j,j-1\) 有关；可以交换前后两维顺序然后滚动。
法二：令 \(n=\sum a_i\)，建立 \(a\) 的差分数组 \(d\)，则有 \(n=\sum\limits_{i=1}^m \sum\limits_{j=1}^i c_j=\sum\limits_{i=1}^m (n-i+1)\times a_i\)。发现 \(a_i\) 每增大 \(1\)，答案会增大 \(n-i+1\)。故转化为『第 \(i\) 个物品重量为 \(n-i+1\)』的完全背包。

不可重：要求每个物品至少选一次。
可重：无限制。

该方法唯一性更显然。

复杂度均为 \(O(nm)\)，即 \(O(V\sqrt V)\)。
例：Sets of Complementary Sums
link
Ferrers 图
将 \(k\) 个分拆出来的数用横向柱状图表示并单调不增排列，得到 Ferrers 图。

例：\(12=5+4+2+1\) 的 Ferrers 图（图源 OI Wiki）

将图像斜向翻折得到一组共轭解，原图中的 \(k\) 即为共轭解中的元素最值。故亦可限定分拆结果的最值为 \(k\)，则结果仍为 \(f_{n,k}\)。同时适用于分拆数与互异分拆数。
顺带提一嘴杨表：把点替换成 \(1\sim n\)，并使得一个点同时大于左侧和上方的值。
似乎就不是很有用了。计数题可能会考。
]]></content>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>杂题选谈</title>
    <url>/20250809/</url>
    <content><![CDATA[这段时间比赛的一些题 和 nKessi、duanyu 讲的题目。太偏计数、数学的基本上没办法做了。


A. 出关
https://www.becoder.com.cn/contest/6462/problem/1

给定 \(s\)，对于一个空串，任意利用下列三种操作，使其变为 \(s\)，求最小代价：

在末尾添加字符 \(c\)，代价为 \(t_{0,c}\)；
复制整个字符串并粘贴在末尾，代价为 \(t_1\)；
删除末尾字符，代价为 \(t_2\)。

\(|s|\le 10^6\)。

可以预处理出对于每个 \(i\) 结尾，最多可以复制到哪个地方，发现要求 \(z_i=lcp(s_{1\dots n},s_{i+1\dots n})\)。那么一个 \(i\) 的最远转移点 \(r_i=i+z_{i+1}\)，用单调队列就能维护，会 exkmp 就能线性；
否则可以二分 + 哈希多个 log，后面也有理由偷懒用优先队列了。

#include &lt;bits/stdc++.h&gt;
const int p = 31;
const int mod = 998244353;
int main() &#123;
    std::freopen(&quot;laozi.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;laozi.out&quot;, &quot;w&quot;, stdout);
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
    std::string s;
    std::cin &gt;&gt; s;
    int n = (int)s.length(), t1, t2;
    std::vector&lt;long long&gt; h(n + 1), base(n + 1);
    std::vector&lt;int&gt; a(n + 1), t0(27), z(n + 1), r(n + 1);
    base[0] = 1ll;
    for (int i = 1; i &lt;= n; ++i) &#123;
        a[i] = s[i - 1] - &#39;a&#39; + 1;
        h[i] = (h[i - 1] * p + a[i]) % mod;
        base[i] = base[i - 1] * p % mod;
    &#125;
    auto gethash = [&amp;](int l, int r) &#123;
        return (h[r] - h[l - 1] * base[r - l + 1] % mod + mod) % mod;
    &#125;;
    for (int i = 1; i &lt;= n; ++i)
        for (int l = 1, r = std::min(i - 1, n - i + 1), mid; l &lt;= r; ) &#123;
            mid = (l + r) &gt;&gt; 1;
            if (gethash(1, mid) == gethash(i, i + mid - 1))
                z[i] = mid, l = mid + 1;
            else
                r = mid - 1;
        &#125;
    for (int i = 1; i &lt; n; ++i)
        r[i] = i + std::min(i, z[i + 1]);
    for (int i = 1; i &lt;= 26; ++i)
        std::cin &gt;&gt; t0[i];
    std::cin &gt;&gt; t1 &gt;&gt; t2;
    std::vector&lt;long long&gt; f(n + 1);
    std::priority_queue&lt;std::pair&lt;long long, int&gt; &gt; q;
    for (int i = 1; i &lt;= n; ++i) &#123;
        f[i] = f[i - 1] + t0[a[i]];
        for (; !q.empty() &amp;&amp; r[q.top().second] &lt; i; q.pop());
        if (!q.empty())
            f[i] = std::min(f[i], t1 - q.top().first - (long long)t2 * i);
        if (i != n)
            q.emplace(-(f[i] + 2ll * t2 * i), i);
    &#125;
    std::cout &lt;&lt; f[n] &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;


D. 非攻
https://www.becoder.com.cn/contest/6462/problem/4

给定 \(n\)，对于一个 \(1\sim n\) 的排列，使用最小的交换次数使得其单增。在该前提下，定义代价为每次交换的两个数之积。对于所有 \(n!\) 个排列，计算最小代价之和。
\(n\le 10^7\)。

转化成，把 \(1\sim n\) 分成无标号的若干组，每组的代价是 最小值 \(\times\) 其他元素的和，还有一个项链问题的系数，发现组间的符号是求和，考虑计算贡献。
枚举 \(i,j\) 并钦定两个同属一个环，且 \(i\) 为最小值，枚举环大小 \(s+2\)，那么有：
\[
\begin{aligned}
res&amp;=\sum_{i=1}^{n-1}\sum_{j=i+1}^n i\cdot j \cdot \sum_{s=0}^{n-i-1}\binom{n-i-1}s \cdot (s+1)!\cdot (n-s-2)!\\
&amp;=\sum_{i=1}^{n-1}i\cdot \dfrac {(i+n+1)(n-i)}2 \cdot \sum_{s=0}^{n-i-1}\binom{n-i-1}s\cdot (s+1)!\cdot (n-s-2)!\\
&amp;=\frac 12\times\sum_{i=1}^{n-1}i\cdot (i+n+1)\cdot (n-i)!\cdot\sum_{s=0}^{n-i-1}\dfrac {(s + 1)\cdot (n-s-2)!}{(n-i-1-s)!}\\
\end{aligned}
\]
令 \(T=n-i-1\)，发现我们需要快速计算 \(f_T=\sum\limits_{i=0}^T \dfrac{(i+1)\cdot (n-i-2)!}{(T-i)!}\)。记 \(m=n-2\)，变形得 \(f_T=(m-T)!\cdot \sum\limits_{i=0}^{T} (i+1) \binom{m-i}{m-T}\)，发现似乎可以简化，令 \(k=m-T,t=T+1\)，则 \(f_T=\sum\limits_{i=1}^T i\cdot \binom {k+t-i}k\)。
然后是经典的组合意义保平安环节，即从 \(k+t\) 个有标号小球中选择一条分界线，分界线左边选一个球、右边选 \(k\) 个球的方案数。发现分界线的存在很诡异，故用分界线后方的第一个球代替，在 \(t+1\) 处新建一个虚球，规定在前 \(t+1\) 个球中选两个球，并令后一个为分界线，且令前 \(t+1\) 个中的其他球为实球，就能建立双射。在分界线后再选 \(k\) 个球，容易发现直接在范围内选 \(k+2\) 个球就能满足条件，故 \(f_T=(n-T-2)!\cdot \binom{t+k+1}{k+2}\)。

#include &lt;bits/stdc++.h&gt;
const int mod = 1e9 + 7;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
    std::freopen(&quot;mozi.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;mozi.out&quot;, &quot;w&quot;, stdout);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n;
    std::cin &gt;&gt; n;
    std::vector&lt;long long&gt; fac(n + 1), inv(n + 1), f(n + 1);
    fac[0] = inv[0] = 1ll;
    for (int i = 1; i &lt;= n; ++i)
        fac[i] = fac[i - 1] * i % mod;
    auto qkp = [&amp;](long long x, int y) &#123;
        auto res(1ll);
        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)
            if (y &amp; 1)
                (res *= x) %= mod;
        return res;
    &#125;;
    inv[n] = qkp(fac[n], mod - 2);
    for (int i = n - 1; i; --i)
        inv[i] = inv[i + 1] * (i + 1) % mod;
    auto C = [&amp;](int n, int m) &#123;
        return fac[n] * inv[n - m] % mod * inv[m] % mod;
    &#125;;
    int m = n - 2;
    for (int T = 0; T &lt;= n - 2; ++T) &#123;
        int k = m - T, t = T + 1;
        f[T] = C(t + k + 1, k + 2) * fac[m - T] % mod;
    &#125;
    auto res = 0ll;
    for (int i = 1; i &lt;= n - 1; ++i)
        (res += (long long)i * (i + n + 1) % mod * fac[n - i] % mod * f[n - i - 1] % mod) %= mod;
    std::cout &lt;&lt; res * inv[2] % mod &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;


C - Destruction of Walls
https://atcoder.jp/contests/arc203/tasks/arc203_c

D - Insert XOR
https://atcoder.jp/contests/arc203/tasks/arc203_d

A - 记忆
https://ac.nowcoder.com/acm/problem/274793
需要意识到问题是静态的，并且不能用线段树之类维护；故考虑离线下来，想办法在 LCA 处统计答案。
这个时候发现需要合并子树状态、整体异或、整体 +1，很容易想到 Trie。把 \(u\to\) LCA 的答案保存在 LCA 处，然后再用 DFS + 回溯统计 LCA \(\to v\) 的答案。想了半天没想到把上下拆开来做也是神了 😅
可能比较考验对字典树的理解？做个比喻，字典树的 id 就相当于对这个点上信息的『引用』。

字典树合并的时候可以考虑回收废弃点，不然可能有点卡。
#include &lt;bits/stdc++.h&gt;
const int X = 50;
const int maxn = 2e7 + 5;
long long d[maxn];
int tot, T[maxn][2], f[maxn], fa[maxn];
#define lc(p) T[p][0]
#define rc(p) T[p][1]
int find(int x) &#123; return x == f[x] ? x : f[x] = find(f[x]); &#125;
int newnode(void) &#123;
    int p = ++tot;
    assert(p &lt; maxn);
    d[p] = lc(p) = rc(p) = 0, f[p] = p;
    return p;
&#125;
void pushdown(int p) &#123;
    if (d[p]) &#123;
        if (d[p] &amp; 1)
            std::swap(lc(p), rc(p));
        d[p] &gt;&gt;= 1;
        if (lc(p))
            d[lc(p)] ^= d[p];
        if (rc(p))
            d[rc(p)] ^= d[p];
        d[p] = 0;
    &#125;
    return;
&#125;
int ins(int p, long long x) &#123;
    for (int i = 0; i &lt; X; ++i) &#123;
        pushdown(p);
        if (!T[p][(x &gt;&gt; i) &amp; 1]) &#123;
            T[p][(x &gt;&gt; i) &amp; 1] = newnode();
            fa[T[p][(x &gt;&gt; i) &amp; 1]] = p;
        &#125;
        p = T[p][(x &gt;&gt; i) &amp; 1];
    &#125;
    return p;
&#125;
void merge(int &amp;p, int q) &#123;
    if (!q)
        return;
    if (!p) &#123;
        p = q;
        return;
    &#125;
    pushdown(p), pushdown(q);
    fa[lc(q)] = p, fa[rc(q)] = p;
    merge(lc(p), lc(q)), merge(rc(p), rc(q));
    assert(f[p] == p), assert(f[q] == q), f[q] = p;
    return;
&#125;
long long ask(int p) &#123;
    std::vector&lt;int&gt; st;
    for (int i = 0, j = p; i &lt; X; ++i)
        st.push_back(fa[j]), j = fa[j];
    for (int i = 0; i &lt; X; ++i)
        pushdown(st.back()), st.pop_back();
    long long x = 0;
    for (int i = 0; i &lt; X; ++i) &#123;
        x = x * 2 + (p == rc(fa[p]));
        p = fa[p];
    &#125;
    return x;
&#125;
void add(int p) &#123;
    for (int i = 0; p &amp;&amp; i &lt; X; ++i) &#123;
        pushdown(p);
        std::swap(lc(p), rc(p));
        p = lc(p);
    &#125;
    return;
&#125;
void del(int p) &#123;
    for (int i = 0; p &amp;&amp; i &lt; X; ++i) &#123;
        pushdown(p);
        std::swap(lc(p), rc(p));
        p = rc(p);
    &#125;
    return;
&#125;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n, m;
    std::cin &gt;&gt; n &gt;&gt; m;
    std::vector&lt;int&gt; a(n + 1);
    for (int i = 1; i &lt;= n; ++i)
        std::cin &gt;&gt; a[i];
    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);
    for (int i = 1, x, y; i &lt; n; ++i) &#123;
        std::cin &gt;&gt; x &gt;&gt; y;
        g[x].push_back(y), g[y].push_back(x);
    &#125;
    std::vector&lt;int&gt; siz(n + 1), son(n + 1), top(n + 1), fa(n + 1), dep(n + 1);
    std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;
        siz[x] = 1;
        for (auto i : g[x])
            if (i != fa[x]) &#123;
                dep[i] = dep[x] + 1;
                fa[i] = x, DFS(i);
                siz[x] += siz[i];
                if (siz[i] &gt; siz[son[x]])
                    son[x] = i;
            &#125;
        return;
    &#125;;
    DFS(1);
    DFS = [&amp;](int x) &#123;
        if (son[x])
            top[son[x]] = top[x], DFS(son[x]);
        for (auto i : g[x])
            if (i != son[x] &amp;&amp; i != fa[x])
                top[i] = i, DFS(i);
        return;
    &#125;;
    top[1] = 1, DFS(1);
    auto askLCA = [&amp;](int x, int y) &#123;
        for (; top[x] != top[y]; x = fa[top[x]])
            if (dep[top[x]] &lt; dep[top[y]])
                std::swap(x, y);
        return dep[x] &lt; dep[y] ? x : y;
    &#125;;
    struct node &#123; long long x; int u, v; &#125;;
    std::vector&lt;node&gt; q(m + 1);
    std::vector&lt;int&gt; id(m + 1);
    std::vector&lt;long long&gt; res(m + 1), ans(m + 1);
    std::vector&lt;std::vector&lt;int&gt; &gt; up(n + 1), dn(n + 1), ed(n + 1);
    for (int i = 1, x, u, v; i &lt;= m; ++i) &#123;
        std::cin &gt;&gt; x &gt;&gt; u &gt;&gt; v;
        q[i] = &#123; x, u, v &#125;;
        up[u].push_back(i), dn[askLCA(u, v)].push_back(i), ed[v].push_back(i);
    &#125;
    std::vector&lt;int&gt; rt(n + 1);
    DFS = [&amp;](int x) &#123;
        rt[x] = newnode();
        for (auto i : g[x])
            if (i != fa[x]) &#123;
                DFS(i);
                merge(rt[x], rt[i]);
            &#125;
        add(rt[x]);
        for (auto i : up[x])
            id[i] = ins(rt[x], q[i].x);
        d[rt[x]] ^= a[x];
        for (auto i : dn[x])
            res[i] = ask(find(id[i]));
        return;
    &#125;;
    DFS(1);
    tot = 0, rt[0] = newnode();
    std::fill(id.begin() + 1, id.end(), 0);
    DFS = [&amp;](int x) &#123;
        d[rt[0]] ^= a[x];
        for (auto i : dn[x])
            id[i] = ins(rt[0], res[i]);
        for (auto i : ed[x])
            ans[i] = ask(id[i]);
        add(rt[0]);
        for (auto i : g[x])
            if (i != fa[x])
                DFS(i);
        del(rt[0]);
        d[rt[0]] ^= a[x];
        return;
    &#125;;
    DFS(1);
    for (int i = 1; i &lt;= m; ++i)
        std::cout &lt;&lt; ans[i] &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;


B - ビーバーの会合 2 (Meetings 2)
https://www.luogu.com.cn/problem/AT_joisc2021_j
定义所求点为『局部重心』；类似树的重心，容易发现当关键点数量为奇时，只存在一个局部重心；否则，局部重心组成一条链。
即对于每一个 \(i\)，需要找到一条最长链，使得其两端存在大小为 \(i\) 的子树（容易发现取后缀 max 即可得到真实答案）。使用点分治，精细实现容易做到 \(O(n\log n)\)。

#include &lt;bits/stdc++.h&gt;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n;
    std::cin &gt;&gt; n;
    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);
    for (int i = 1, x, y; i &lt; n; ++i) &#123;
        std::cin &gt;&gt; x &gt;&gt; y;
        g[x].push_back(y), g[y].push_back(x);
    &#125;
    std::vector&lt;int&gt; mx(n + 1), siz(n + 1), p, tag(n + 1), res(n + 1, 1);
    std::function&lt;void(int, int)&gt; DFS1 = [&amp;](int x, int fa) &#123;
        p.push_back(x);
        siz[x] = 1, mx[x] = 0;
        for (auto i : g[x])
            if (!tag[i] &amp;&amp; i != fa) &#123;
                DFS1(i, x);
                siz[x] += siz[i];
                mx[x] = std::max(mx[x], siz[i]);
            &#125;
        return;
    &#125;;
    auto findrt = [&amp;](int x) &#123;
        p.clear(), DFS1(x, -1);
        int n = (int)p.size();
        for (auto i : p)
            if (mx[i] &lt;= n / 2 &amp;&amp; n - siz[i] &lt;= n / 2)
                return i;
        assert(0);
        return -1;
    &#125;;
    struct node &#123;
        int u1, u2, id1, id2;
        node(): u1(0), u2(0), id1(0), id2(0) &#123;&#125;
        void upd(int u, int id) &#123;
            if (id1 == id)
                u1 = std::max(u1, u);
            else if (u &gt;= u1)
                u2 = u1, id2 = id1, u1 = u, id1 = id;
            else if (u &gt;= u2)
                u2 = u, id2 = id;
            return;
        &#125;
    &#125;;
    std::vector&lt;node&gt; s(n + 1);
    std::function&lt;void(int, int, int, int)&gt; DFS2 = [&amp;](int x, int fa, int dep, int anc) &#123;
        s[siz[x]].upd(dep, anc);
        for (auto i : g[x])
            if (!tag[i] &amp;&amp; i != fa)
                DFS2(i, x, dep + 1, anc);
        return;
    &#125;;
    std::function&lt;void(int, int, int, int)&gt; DFS3 = [&amp;](int x, int fa, int dep, int anc) &#123;
        int v = ((s[siz[x]].id1 == anc) ? s[siz[x]].u2 : s[siz[x]].u1);
        res[2 * siz[x]] = std::max(res[2 * siz[x]], dep + 1 + v);
        for (auto i : g[x])
            if (!tag[i] &amp;&amp; i != fa)
                DFS3(i, x, dep + 1, anc);
        return;
    &#125;;
    std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;
        x = findrt(x), p.clear(), DFS1(x, -1);
        // printf(&quot;rt = %d\n&quot;, x);
        for (auto i : g[x])
            if (!tag[i])
                DFS2(i, x, 1, i);
        for (int i = siz[x] - 1; i; --i) &#123;
            s[i].upd(s[i + 1].u1, s[i + 1].id1);
            s[i].upd(s[i + 1].u2, s[i + 1].id2);
        &#125;
        for (auto i : g[x])
            if (!tag[i])
                DFS3(i, x, 1, i);
        tag[x] = 1;
        for (int i = 1; i &lt; siz[x]; ++i)
            s[i] = node();
        for (auto i : g[x])
            if (!tag[i])
                DFS(i);
        return;
    &#125;;
    DFS(1);
    for (int i = (n &gt;&gt; 1) * 2; i; --i)
        if (i + 2 &lt;= n)
            res[i] = std::max(res[i], res[i + 2]);
    for (int i = 1; i &lt;= n; ++i)
        std::cout &lt;&lt; res[i] &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;


C - The Closest Pair
https://ac.nowcoder.com/acm/problem/262593
常规方法：考虑支配对，对于每个 \(a_i\)，找到所有合法的 \(a_j\)。容易想到枚举 \(a_i\div a_j\) 来做；假设存在 \(a_k\div a_i=a_j\div a_i\) 且 \(k&gt;j\)。
不妨设 \(a_j=K\cdot a_i+p,a_k=K\cdot a_i+q\)，\((a_i,a_j),(a_i,a_k)\) 均合法当且仅当下列条件全部成立：

\(a_j\bmod a_i&gt;a_k\bmod a_i\)； 则 \(a_j&gt;a_k\)。
\(a_j\bmod a_k&gt;a_k\bmod a_i\)；又 \(p-q\ge a_j\bmod a_k\)（太牛了这一步），即 \(p-q&gt;q\iff p&gt;2q\)。

证得只关心同一个 \(a_j\div a_i\) 时的支配对数量为 \(\log n\) 级别；总对数 \(O(n\log n\ln n)\)。离线下来扫描线就行了。

对着 单点修改 区间最值 想了 1h 的单 log 做法 😰 果然小脑掉线太可怕了，第二天早上重置大脑 1s 发现自己是斯波 😓
#include &lt;bits/stdc++.h&gt;
const int LEN = (1 &lt;&lt; 20);
int nec(void) &#123;
    static char buf[LEN], *p = buf, *e = buf;
    if (p == e) &#123;
        e = buf + fread(buf, 1, LEN, stdin);
        if (e == buf) return EOF;
        p = buf;
    &#125;
    return *p++;
&#125;
bool read(int &amp;x) &#123;
    x = 0;
    bool f = 0;
    char ch = nec();
    while (ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123;
        if (ch == EOF) return 0;
        if (ch == &#39;-&#39;) f = 1;
        ch = nec();
    &#125;
    while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) &#123;
        x = x * 10 + ch - &#39;0&#39;;
        ch = nec();
    &#125;
    if (f) x = -x;
    return 1;
&#125;
void print(int x) &#123;
    if (x &lt; 0)
        putchar(&#39;-&#39;), x = -x;
    if (x &gt;= 10) print(x / 10);
    putchar(x % 10 + &#39;0&#39;);
    return;
&#125;
void print(int x, char ch) &#123;
    print(x), putchar(ch);
    return;
&#125;
const int maxn = 4e6 + 5;
struct &#123; int l, r, u[2]; &#125; t[maxn];
#define lt (t[p].l)
#define rt (t[p].r)
int tot[2];
void add(int &amp;p, int l, int r, int x, int v, int i) &#123;
    if (!p)
        p = ++tot[i], t[p].u[0] = -1, t[p].u[1] = 0x3f3f3f3f;
    if (i == 0)
        t[p].u[0] = std::max(t[p].u[0], v);
    else
        t[p].u[1] = std::min(t[p].u[1], v);
    if (l == r)
        return;
    int mid = (l + r) &gt;&gt; 1;
    if (x &lt;= mid)
        add(lt, l, mid, x, v, i);
    else
        add(rt, mid + 1, r, x, v, i);
    return;
&#125;
int ask(int p, int l, int r, int ql, int qr, int i) &#123;
    if (!p || (ql &lt;= l &amp;&amp; r &lt;= qr))
        return t[p].u[i];
    int mid = (l + r) &gt;&gt; 1;
    if (qr &lt;= mid)
        return ask(lt, l, mid, ql, qr, i);
    if (ql &gt; mid)
        return ask(rt, mid + 1, r, ql, qr, i);
    if (i == 0)
        return std::max(ask(lt, l, mid, ql, qr, 0), ask(rt, mid + 1, r, ql, qr, 0));
    return std::min(ask(lt, l, mid, ql, qr, 1), ask(rt, mid + 1, r, ql, qr, 1));
&#125;
#undef lt
#undef rt
int main() &#123;
#ifndef ONLINE_JUDGE
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    const int m = 1e6;
    int rt[2] = &#123; 0 &#125;, n;
    t[0].u[0] = -1, t[0].u[1] = 0x3f3f3f3f;
    read(n);
    std::vector&lt;int&gt; a(n + 1);
    for (int i = 1; i &lt;= n; ++i)
        read(a[i]);
    std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; t(n + 1);
    for (int i = 1; i &lt;= n; ++i) &#123;
        if (i != 1) &#123;
            for (int K = a[i]; K &lt;= m; K += a[i]) &#123;
                for (int mx = std::min(a[i] - 1, m - K); ; ) &#123;
                    int k = ask(rt[0], 1, m, K, K + mx, 0);
                    if (k == -1)
                        break;
                    t[i].emplace_back(k, a[k] - K);
                    if (k == 1 || !(a[k] - K))
                        break;
                    mx = (a[k] - K - 1) / 2;
                &#125;
            &#125;
        &#125;
        add(rt[0], 1, m, a[i], i, 0);
    &#125;
    for (int i = n; i; --i) &#123;
        if (i != n)
            for (int K = a[i]; K &lt;= m; K += a[i])
                for (int mx = std::min(a[i] - 1, m - K); ; ) &#123;
                    int k = ask(rt[1], 1, m, K, K + mx, 1);
                    if (k == 0x3f3f3f3f)
                        break;
                    t[k].emplace_back(i, a[k] - K);
                    if (k == n || !(a[k] - K))
                        break;
                    mx = (a[k] - K - 1) / 2;
                &#125;
        add(rt[1], 1, m, a[i], i, 1);
    &#125;
    int q;
    read(q);
    std::vector&lt;int&gt; res(q + 1);
    std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; u(n + 1);
    for (int i = 1, l, r; i &lt;= q; ++i) &#123;
        read(l), read(r);
        if (l &gt; r)
            std::swap(l, r);
        u[r].emplace_back(l, i);
    &#125;
    std::vector&lt;int&gt; bit(n + 1, 0x3f3f3f3f);
    auto lowbit = [&amp;](int x) &#123; return x &amp; -x; &#125;;
    auto add = [&amp;](int x, int v) &#123;
        for (; x &lt;= n; x += lowbit(x))
            bit[x] = std::min(bit[x], v);
        return;
    &#125;;
    auto ask = [&amp;](int x) &#123;
        auto res = 0x3f3f3f3f;
        for (; x; x -= lowbit(x))
            res = std::min(res, bit[x]);
        return res;
    &#125;;
    for (int r = 1; r &lt;= n; ++r) &#123;
        for (auto [l, v] : t[r])
            add(n - l + 1, v);
        for (auto [l, i] : u[r])
            res[i] = ask(n - l + 1);
    &#125;
    for (int i = 1; i &lt;= q; ++i)
        print(res[i], &#39;\n&#39;);
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;

求支配对的过程也要带 log（线段树），再加上扫描线的 3log，总共是常数比较大的 3log（卡了一个上午的常也是有了）。所以接下来讲解另一种奇技淫巧。
暴力分治：注意到对于比较长（\(len&gt; B\)）的区间，答案比较小；故考虑分治。

对于长询问（\(len&gt;B\)），从小到大枚举答案并 check；预处理某个范围（\(V\)）内的 \(res\) 出现的所有位置，平衡的时候还要算上调和级数和 bit。
对于短询问（\(len\le B\)），发现每次区间内暴力是 \(O(B^2q)\) 的；把询问离线下来，精细实现，利用询问的公共部分使得每一对数只被枚举一次就能达到 \(O(B^2 + Bq)\)。

最优解取 \(B=333,V=483\)，不自己实现一遍了。

D - 仙人掌
https://www.luogu.com.cn/problem/P3687
把边双从图中删除、问题转化为树上边不交的链覆盖，使得所有链长 \(\ge 2\) 的方案数。发现由于边可以不被覆盖，常规 DP 会使得在父节点处合并时需要额外的数量维，参考树上背包，复杂度 \(O(n^2)\)。
思考时会注意到两个限制可以抵消——如果认为长为 \(1\) 的链就是不被覆盖的边，覆盖所有树边，显然可以建立和合法解的双射。此时合并是非常方便的，注意到每个儿子的系数一定都参与『分步』，只需要求出『分类』的系数。这个可以预处理（和 二分图染色 这个题有点像），令 \(f_i\) 表示一个点度数为 \(i\) 时的答案，参考错排的思路，则 \(i\) 可以不参与配对，也可以乱选一个点配对，如果选中了已配对的点就令其和 \(i-1\) 交换，可以建立和合法解的双射。则 \(f_i=f_{i-1}+(n-1)f_{i-2}\)。
首先需要 check 原图是否为仙人掌，顺带回忆一下连通性的知识——在 DFS 树上差分，检查是否有边被覆盖两次即可。

#include &lt;bits/stdc++.h&gt;
const int mod = 998244353;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int T;
    for (std::cin &gt;&gt; T; T--; ) &#123;
        int n, m;
        std::cin &gt;&gt; n &gt;&gt; m;
        std::vector&lt;std::vector&lt;int&gt; &gt; g1(n + 1);
        for (int x, y; m--; ) &#123;
            std::cin &gt;&gt; x &gt;&gt; y;
            g1[x].push_back(y), g1[y].push_back(x);
        &#125;
        bool flag = 1;
        int now = 0, cnt = 0;
        std::vector&lt;int&gt; st, dfn(n + 1), low(n + 1), col(n + 1), diff(n + 1);
        std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int fa) &#123;
            st.push_back(x);
            dfn[x] = low[x] = ++now;
            for (auto i : g1[x])
                if (!dfn[i]) &#123;
                    // printf(&quot;x = %d, %d -&gt; %d\n&quot;, x, x, i);
                    DFS(i, x);
                    diff[x] += diff[i];
                    // printf(&quot;x = %d, diff[%d] += diff[%d]\n&quot;, x, x, i);
                    low[x] = std::min(low[x], low[i]);
                &#125;
                else if (i != fa &amp;&amp; dfn[i] &lt; dfn[x]) &#123;
                    low[x] = std::min(low[x], dfn[i]);
                    ++diff[x], --diff[i];
                    // printf(&quot;x = %d, ++diff[%d], --diff[%d]\n&quot;, x, x, i);
                &#125;
            if (diff[x] &gt;= 2)
                flag = 0;
            // printf(&quot;x = %d, diff[%d] = %d\n&quot;, x, x, diff[x]);
            if (low[x] == dfn[x]) &#123;
                ++cnt;
                for (int p = -1; p != x; ) &#123;
                    p = st.back(), st.pop_back();
                    col[p] = cnt;
                &#125;
            &#125;
            return;
        &#125;;
        DFS(1, -1);
        if (!flag) &#123;
            std::cout &lt;&lt; 0 &lt;&lt; &#39;\n&#39;;
            continue;
        &#125;
        std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);
        for (int i = 1; i &lt;= n; ++i)
            for (auto j : g1[i])
                if (col[i] != col[j])
                    g[i].push_back(j);
        std::vector&lt;long long&gt; f(n + 1), dp(n + 1);
        dp[0] = 1ll, dp[1] = 1ll;
        for (int i = 2; i &lt;= n; ++i)
            dp[i] = (dp[i - 1] + (i - 1) * dp[i - 2]) % mod;
        std::vector&lt;int&gt; tag(n + 1);
        DFS = [&amp;](int x, int fa) &#123;
            f[x] = 1ll, tag[x] = 1;
            for (auto i : g[x])
                if (i != fa) &#123;
                    DFS(i, x);
                    (f[x] *= f[i]) %= mod;
                &#125;
            (f[x] *= dp[(int)g[x].size()]) %= mod;
            return;
        &#125;;
        auto res(1ll);
        for (int i = 1; i &lt;= n; ++i)
            if (!tag[i])
                DFS(i, -1), (res *= f[i]) %= mod;
        std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
    &#125;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;


E. Many Minimizations 是数学题，跳了。


无名题

背景：给定 \(n,k\)，对于 \(\forall\, 1\le i\le n\)，令 \(a_i=i\bmod k\)，问一共有多少个本质不同的子序列？对于 \(k=1,2,\cdots,n\) 分别求出答案。


maimai
https://ac.nowcoder.com/acm/contest/66112/F
]]></content>
      <tags>
        <tag>字典树</tag>
        <tag>计数</tag>
        <tag>字符串</tag>
        <tag>支配对</tag>
      </tags>
  </entry>
  <entry>
    <title>杂题选谈：DDP 与 GBT</title>
    <url>/20250814/</url>
    <content><![CDATA[线段树是对的（存疑）


A - 数据传输
https://www.luogu.com.cn/problem/P8820
我在上一篇文章中提到了 DDP &amp; 路径查询问题，在这个题中就有体现。
设 \(f_{u,0/1/2}\) 表示数据保存在 \(u\) 往下数 \(0/1/2\) 个点处的最小代价，手玩容易发现 \(k=3\) 时最优路径可能会往某个 \(x\) 或 \(fa\) 处的最小代价儿子处绕一圈来避免这个 \(x\) 或 \(fa\) 的代价。但该值是定值，问题还是纯路径问题，就可以 DDP 了。

共两种可能性（任意一个箭头长度不为 \(3\) 时绕一圈一定不比直接走更优）


#include &lt;bits/stdc++.h&gt;
struct mat &#123;
    long long a[3][3];
    long long* operator[] (const int q) &#123;
        return a[q];
    &#125;
    mat() &#123;
        memset(a, 0x3f, sizeof (a));
        return;
    &#125;
    mat(int flag) &#123;
        memset(a, 0x3f, sizeof (a));
        a[0][0] = a[1][1] = a[2][2] = 0ll;
        return;
    &#125;
    mat operator* (mat &amp;q) const &#123;
        mat res;
        for (int i = 0; i &lt; 3; ++i)
            for (int k = 0; k &lt; 3; ++k)
                for (int j = 0; j &lt; 3; ++j)
                    res[i][k] = std::min(res[i][k], a[i][j] + q[j][k]);
        return res;
    &#125;
    mat&amp; operator*= (mat &amp;q) &#123;
        return *this = *this * q;
    &#125;
&#125;;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, q, k;
    std::cin &gt;&gt; n &gt;&gt; q &gt;&gt; k;
    std::vector&lt;int&gt; a(n + 1);
    for (int i = 1; i &lt;= n; ++i)
        std::cin &gt;&gt; a[i];
    std::vector&lt;int&gt; mx(n + 1, 0x3f3f3f3f);
    std::vector&lt;std::vector&lt;int&gt; &gt; g1(n + 1);
    for (int i = 1, x, y; i &lt; n; ++i) &#123;
        std::cin &gt;&gt; x &gt;&gt; y;
        mx[x] = std::min(mx[x], a[y]);
        mx[y] = std::min(mx[y], a[x]);
        g1[x].push_back(y), g1[y].push_back(x);
    &#125;
    std::vector&lt;int&gt; dep(n + 1);
    std::vector&lt;std::array&lt;int, 18&gt; &gt; f(n + 1);
    std::vector&lt;std::array&lt;mat, 18&gt; &gt; u(n + 1), d(n + 1);
    u[0][0] = d[0][0] = mat(1);
    std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;
        for (auto i : g1[x])
            if (i != f[x][0]) &#123;
                f[i][0] = x;
                &#123;
                    mat s;
                    s[0][0] = a[x];
                    if (k &gt;= 2) &#123;
                        s[0][1] = 0;
                        s[1][0] = a[x];
                    &#125;
                    if (k &gt;= 3) &#123;
                        s[1][2] = 0;
                        s[2][0] = a[x];
                        s[1][1] = mx[x];
                        s[2][2] = mx[i];
                    &#125;
                    u[i][0] = s; 
                    s[0][0] = a[i];
                    if (k &gt;= 2)
                        s[1][0] = a[i];
                    if (k &gt;= 3) &#123;
                        s[2][0] = a[i];
                        s[1][1] = mx[i];
                        s[2][2] = mx[x];
                    &#125;
                    d[i][0] = s; 
                &#125;
                for (int j = 1; j &lt; 18; ++j) &#123;
                    f[i][j] = f[f[i][j - 1]][j - 1];
                    u[i][j] = u[i][j - 1] * u[f[i][j - 1]][j - 1];
                    d[i][j] = d[f[i][j - 1]][j - 1] * d[i][j - 1];
                &#125;
                dep[i] = dep[x] + 1;
                DFS(i);
            &#125;
        return;
    &#125;;
    dep[1] = 1, DFS(1);
    for (int x, y; q--; ) &#123;
        std::cin &gt;&gt; x &gt;&gt; y;
        long long res = a[x];
        mat r1(1), r2(1);
        if (dep[x] &gt; dep[y]) &#123;
            for (int i = 17; ~i; --i)
                if (dep[f[x][i]] &gt;= dep[y]) &#123;
                    r1 = r1 * u[x][i];
                    x = f[x][i];
                &#125;
        &#125;
        else if (dep[y] &gt; dep[x]) &#123;
            for (int i = 17; ~i; --i)
                if (dep[f[y][i]] &gt;= dep[x]) &#123;
                    r2 = d[y][i] * r2;
                    y = f[y][i];
                &#125;
        &#125;
        if (x != y) &#123;
            for (int i = 17; ~i; --i)
                if (f[x][i] != f[y][i]) &#123;
                    r1 = r1 * u[x][i];
                    r2 = d[y][i] * r2;
                    x = f[x][i], y = f[y][i];
                &#125;
            r1 = r1 * u[x][0], r2 = d[y][0] * r2;
        &#125;
        std::cout &lt;&lt; res + (r1 * r2)[0][0] &lt;&lt; &#39;\n&#39;;
    &#125;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;


B - The Silk Road … with Robots!
https://qoj.ac/problem/10410

题意：初始有一个长为 \(10^8\) 的空数轴，给定 \(n\) 次操作，每次操作在数轴上的一个空位放一个 A 类点或 B 类点。每个 A 类点有其价值。
任意在数轴上移动这些 B 类点，总价值为所有被经过的 A 类点的价值 - B 类点移动总路程。每次操作后输出最大总价值，重复经过的 A 类点只计一次。
\(n\le 2\times 10^5\)。

这个题确实可以带来很多启发，我一开始直接设 \(f_j\) 为状态，这样对于暴力是可做的，但是会出现一些需要被区间修改的系数，比如前缀和。最好设计状态，让转移的时候只需要用到常数、差分值等修改次数很少的系数。
设 \(f_{i,0/1/2/3}\) 分别表示：

那么可以写出转移式：
\[
f_{i,0}=\max(mx+a_i+x_i,f_{i-1,0}+a_i)\\
f_{i,1}=\max(mx+a_i+2x_i,f_{i-1,1}+a_i)\\
f_{i,2}=f_{i-1,2}-(x_i-x_{i-1}) + a_i\\
f_{i,3}=f_{i-1,3}-2(x_i-x_{i-1})+a_i
\]
其中 \(mx\) 为 \(f_{i,2/3}\) 的前缀最大值。在 B 类点处可以让 \(f_{2/3}\) 继承对应的 \(f_{0/1}\)，新开一维记录 \(mx\) 就可以维护矩乘了。

#include &lt;bits/stdc++.h&gt;
const int lim = 1e8;
const int maxn = 5e6 + 5;
const long long inf = 1e12;
struct mat &#123;
    long long a[5][5];
    mat() &#123;&#125;
    long long* operator[] (const int q) &#123;
        return a[q];
    &#125;
    mat operator* (mat &amp;q) const &#123;
        mat res;
        for (int i = 0; i &lt; 5; ++i)
            for (int k = 0; k &lt; 5; ++k) &#123;
                auto u(-inf);
                for (int j = 0; j &lt; 5; ++j)
                    u = std::max(u, a[i][j] + q[j][k]);
                res[i][k] = u;
            &#125;
        return res;
    &#125;
    mat&amp; operator*= (mat &amp;q) &#123;
        return *this = *this * q;
    &#125;
&#125;;
struct &#123; int l, r; mat u; &#125; t[maxn];
#define lt t[p].l
#define rt t[p].r
void add(int &amp;p, int l, int r, int x, mat &amp;v) &#123;
    static int tot = 0;
    if (!p)
        p = ++tot;
    if (l == r) &#123;
        t[p].u = v;
        return;
    &#125;
    int mid = (l + r) &gt;&gt; 1;
    if (x &lt;= mid)
        add(lt, l, mid, x, v);
    else
        add(rt, mid + 1, r, x, v);
    t[p].u = t[lt].u * t[rt].u;
    return;
&#125;
#undef lt
#undef rt
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    &#123;
        mat &amp;u = t[0].u;
        for (int i = 0; i &lt; 5; ++i)
            for (int j = 0; j &lt; 5; ++j)
                u[i][j] = -inf;
        u[0][0] = u[1][1] = u[2][2] = u[3][3] = u[4][4] = 0ll;
    &#125;
    int m, rt = 0;
    std::cin &gt;&gt; m;
    std::vector&lt;mat&gt; a(m + 1);
    std::vector&lt;int&gt; ty(m + 1);
    std::set&lt;std::pair&lt;long long, int&gt; &gt; s;
    s.emplace(-inf, 0);
    for (int op, x, i = 1; i &lt;= m; ++i) &#123;
        std::cin &gt;&gt; op &gt;&gt; x;
        auto &amp;u = a[i];
        for (int i = 0; i &lt; 5; ++i)
            for (int j = 0; j &lt; 5; ++j)
                u[i][j] = -inf;
        auto p = --s.lower_bound(std::make_pair(x, 0)), q = s.upper_bound(std::make_pair(x, 0));
        int v = 0;
        if (op == 2)
            std::cin &gt;&gt; v;
        u[0][0] = v, u[1][1] = v, u[4][0] = v + x, u[4][1] = v + 2 * x;
        if (op == 1) &#123;
            ty[i] = 0;
            u[4][2] = u[4][1] - 2 * x;
            u[1][2] = u[1][1] - 2 * x;
            u[4][3] = u[4][0] - x;
            u[0][3] = u[0][0] - x;
        &#125;
        else &#123;
            ty[i] = 1;
            u[2][2] = v - (x - p-&gt;first);
            u[3][3] = v - 2 * (x - p-&gt;first);
        &#125;
        u[4][4] = std::max(&#123; 0ll, u[4][2], u[4][3] &#125;);
        u[1][4] = u[1][2], u[0][4] = u[0][3], u[2][4] = u[2][2], u[3][4] = u[3][3];
        add(rt, 0, lim, x, u);
        if (q != s.end() &amp;&amp; ty[q-&gt;second] == 1) &#123;
            auto &amp;u = a[q-&gt;second];
            u[2][2] -= p-&gt;first, u[2][2] += x;
            u[3][3] -= 2 * p-&gt;first, u[3][3] += 2 * x;
            u[2][4] = u[2][2], u[3][4] = u[3][3];
            add(rt, 0, lim, q-&gt;first, a[q-&gt;second]);
        &#125;
        s.emplace(x, i);
        std::cout &lt;&lt; t[1].u[4][4] &lt;&lt; &#39;\n&#39;;
        // for (int i = 0; i &lt; 5; ++i, puts(&quot;&quot;))
        //     for (int j = 0; j &lt; 5; ++j)
        //         if (t[1].u[i][j] &lt; -200)
        //             printf(&quot;  x &quot;);
        //         else
        //             printf(&quot;%3lld &quot;, t[1].u[i][j]);
        // puts(&quot;=============&quot;);
    &#125;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;


C - 密码箱
link;
]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>DDP</tag>
      </tags>
  </entry>
  <entry>
    <title>学习笔记：DDP 与全局平衡二叉树</title>
    <url>/20250812/</url>
    <content><![CDATA[其实动态 DP 不是动态树 DP 的同义词


动态 DP
对于转移只依赖前几项的 DP，可以放进矩阵。
默认转移范围是 \([1,n]\)；如果我们需要改变求解范围，发现如果能获取转移矩阵的乘积就很快了。考虑存下来。
如果需要单点修改，等价于修改其所在矩阵，则想要尽可能少地修改存储的答案，考虑使用线段树优化该过程。
例：海报
https://www.luogu.com.cn/problem/P9790
容易列出暴力 DP 式：令 \(f_{i,j}\) 表示枚举到 \(i\) 时，包含 \(i\) 在内已经有 \(j\) 个连续的人举起海报，易得：
\[
f_{i,0}=\max(f_{i-1,0},f_{i-1,1},f_{i-1,2},f_{i-1,3})\\
f_{i,j}=f_{i-1,j-1}+a_i \forall 1\le j\le 3
\]
发现满足 + / max 矩阵乘法 的形式；想到用线段树保存每段区间对应矩阵（对应性质：结合律），每次修改 / 查询就能在 \(O(\log n)\) 之内完成。
原问题是环形的，可以再加一维 \(k\) 表示钦定选了前 \(k\) 个且不选第 \(k+1\) 个时的答案。

#include &lt;bits/stdc++.h&gt;
const int maxn = 4e4 + 5;
const long long inf = 1e18;
struct mat &#123;
    int n, m;
    long long a[4][4];
    mat() &#123;&#125;
    mat(int n1, int m1): n(n1), m(m1) &#123;
        for (int i = 0; i &lt; n; ++i)
            for (int j = 0; j &lt; m; ++j)
                a[i][j] = -inf;
        return;
    &#125;
    long long* operator[] (const int q) &#123;
        return a[q];
    &#125;
    mat operator* (mat &amp;q) const &#123;
        mat res(n, q.m);
        for (int i = 0; i &lt; n; ++i)
            for (int k = 0; k &lt; q.m; ++k)
                for (int j = 0; j &lt; m; ++j)
                    res[i][k] = std::max(res[i][k], a[i][j] + q[j][k]);
        return res;
    &#125;
    mat&amp; operator*= (mat &amp;q) &#123;
        return *this = *this * q;
    &#125;
&#125;;
struct &#123; int l, r; mat u[4]; &#125; t[maxn &lt;&lt; 2];
int a[maxn];
#define lt (p &lt;&lt; 1)
#define rt (lt | 1)
#define c t[p].u[i]
void bld(int p, int l, int r) &#123;
    t[p].l = l, t[p].r = r;
    if (l == r) &#123;
        for (int i = 0; i &lt;= 3; ++i) &#123;
            c = mat(4, 4);
            if (l &gt; i + 1) &#123;
                c[0][0] = c[1][0] = c[2][0] = c[3][0] = 0;
                c[0][1] = c[1][2] = c[2][3] = a[l];
            &#125;
            else if (l == i + 1)
                c[0][0] = c[1][0] = c[2][0] = c[3][0] = 0;
            else
                c[0][1] = c[1][2] = c[2][3] = a[l];
        &#125;
        return;
    &#125;
    int mid = (l + r) &gt;&gt; 1;
    bld(lt, l, mid), bld(rt, mid + 1, r);
    for (int i = 0; i &lt;= 3; ++i)
        t[p].u[i] = t[lt].u[i] * t[rt].u[i];
    return;
&#125;
void add(int p, int x, int v) &#123;
    if (t[p].l == t[p].r) &#123;
        for (int i = 0; i &lt;= 3; ++i)
            if (t[p].l != i + 1) 
                c[0][1] = c[1][2] = c[2][3] = v;
        return;
    &#125;
    int mid = (t[p].l + t[p].r) &gt;&gt; 1;
    if (x &lt;= mid)
        add(lt, x, v);
    else
        add(rt, x, v);
    for (int i = 0; i &lt;= 3; ++i)
        t[p].u[i] = t[lt].u[i] * t[rt].u[i];
    return;
&#125;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n;
    std::cin &gt;&gt; n;
    for (int i = 1; i &lt;= n; ++i)
        std::cin &gt;&gt; a[i];
    bld(1, 1, n);
    auto calc = [&amp;](void) &#123;
        mat f(1, 4);
        f[0][0] = 0;
        auto res = -inf;
        for (int i = 0; i &lt;= 3; ++i) &#123;
            auto r = (f * t[1].u[i]);
            for (int j = 0; j &lt;= 3; ++j)
                if (i + j &lt;= 3) &#123;
                    res = std::max(res, r[0][j]);
                    // printf(&quot;f[%d][%d] = %lld\n&quot;, i, j, f[i][j]);
                &#125;
        &#125;
        return res;
    &#125;;
    std::cout &lt;&lt; calc() &lt;&lt; &#39;\n&#39;;
    int q;
    std::cin &gt;&gt; q;
    for (int x, v; q--; ) &#123;
        std::cin &gt;&gt; x &gt;&gt; v;
        add(1, x, v);
        std::cout &lt;&lt; calc() &lt;&lt; &#39;\n&#39;;
    &#125;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;

发现矩阵本身和 \(k\) 无关，还可以可以共用一个线段树上的信息，就可以只开一个线段树了。

我写这一版本的原因是 maxn 开大了导致 MLE，实际上四个线段树是没有任何空间压力的 😅
#include &lt;bits/stdc++.h&gt;
const int maxn = 4e5 + 5;
const long long inf = 1e18;
struct mat &#123;
    int n, m;
    long long a[4][4];
    mat() &#123;&#125;
    mat(int n1, int m1): n(n1), m(m1) &#123;
        for (int i = 0; i &lt; n; ++i)
            for (int j = 0; j &lt; m; ++j)
                a[i][j] = -inf;
        return;
    &#125;
    long long* operator[] (const int q) &#123;
        return a[q];
    &#125;
    mat operator* (mat q) const &#123;
        mat res(n, q.m);
        for (int i = 0; i &lt; n; ++i)
            for (int k = 0; k &lt; q.m; ++k)
                for (int j = 0; j &lt; m; ++j)
                    res[i][k] = std::max(res[i][k], a[i][j] + q[j][k]);
        return res;
    &#125;
    mat&amp; operator*= (mat &amp;q) &#123;
        return *this = *this * q;
    &#125;
&#125;;
struct &#123; int l, r; mat u; &#125; t[maxn &lt;&lt; 2];
int a[maxn];
#define lt (p &lt;&lt; 1)
#define rt (lt | 1)
void bld(int p, int l, int r) &#123;
    t[p].l = l, t[p].r = r;
    if (l == r) &#123;
        t[p].u = mat(4, 4);
        t[p].u[0][0] = t[p].u[1][0] = t[p].u[2][0] = t[p].u[3][0] = 0;
        t[p].u[0][1] = t[p].u[1][2] = t[p].u[2][3] = a[l];
        return;
    &#125;
    int mid = (l + r) &gt;&gt; 1;
    bld(lt, l, mid), bld(rt, mid + 1, r);
    t[p].u = t[lt].u * t[rt].u;
    return;
&#125;
void add(int p, int x, int v) &#123;
    if (t[p].l == t[p].r) &#123;
        t[p].u[0][1] = t[p].u[1][2] = t[p].u[2][3] = v;
        return;
    &#125;
    int mid = (t[p].l + t[p].r) &gt;&gt; 1;
    if (x &lt;= mid)
        add(lt, x, v);
    else
        add(rt, x, v);
    t[p].u = t[lt].u * t[rt].u;
    return;
&#125;
mat ask(int p, int l, int r) &#123;
    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r)
        return t[p].u;
    int mid = (t[p].l + t[p].r) &gt;&gt; 1;
    if (r &lt;= mid)
        return ask(lt, l, r);
    if (l &gt; mid)
        return ask(rt, l, r);
    return ask(lt, l, r) * ask(rt, l, r);
&#125;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n;
    std::cin &gt;&gt; n;
    for (int i = 1; i &lt;= n; ++i)
        std::cin &gt;&gt; a[i];
    bld(1, 1, n);
    auto calc = [&amp;](void) &#123;
        mat f(1, 4);
        f[0][0] = 0, f[0][1] = f[0][2] = f[0][3] = -inf;
        auto r(f * ask(1, 2, n));
        auto res(*std::max_element(r[0], r[0] + 4));
        mat z(4, 4);
        z[0][0] = z[1][0] = z[2][0] = z[3][0] = 0ll;
        for (int i = 1; i &lt;= 3; ++i) &#123;
            mat op(4, 4);
            op[0][1] = op[1][2] = op[2][3] = a[i];
            f *= op;
            if (i + 2 &lt;= n)
                r = f * z * ask(1, i + 2, n);
            else
                r = f * z;
            res = std::max(res, *std::max_element(r[0], r[0] + 4 - i));
        &#125;
        return res;
    &#125;;
    std::cout &lt;&lt; calc() &lt;&lt; &#39;\n&#39;;
    int q;
    std::cin &gt;&gt; q;
    for (int x, v; q--; ) &#123;
        std::cin &gt;&gt; x &gt;&gt; v, a[x] = v;
        add(1, x, v);
        std::cout &lt;&lt; calc() &lt;&lt; &#39;\n&#39;;
    &#125;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;


经典题：GSS3
https://www.luogu.com.cn/problem/SP1716
怎么是子段和 😓
同样列出能够矩阵乘法的 DP 式，发现限制在于至少要选一个数。设 \(f_{i}\) 表示选了 \(i\) 的最大值，\(g_i\) 表示历史最大值，则：
\[
f_i=\max(f_{i-1}+a_i,0+a_i)\\
g_i=\max(g_{i-1}+0,f_{i-1}+a_i,0+a_i)
\]
容易发现是一个 + / max 矩乘，线段树维护即可。

#include &lt;bits/stdc++.h&gt;
const int maxn = 4e5 + 5;
const long long inf = 1e18;
struct mat &#123;
    int n, m;
    long long a[3][3];
    mat() &#123;&#125;
    mat(int n1, int m1): n(n1), m(m1) &#123;
        for (int i = 0; i &lt; n; ++i)
            for (int j = 0; j &lt; m; ++j)
                a[i][j] = -inf;
        return;
    &#125;
    long long* operator[] (const int q) &#123;
        return a[q];
    &#125;
    mat operator* (mat q) const &#123;
        mat res(n, q.m);
        for (int i = 0; i &lt; n; ++i)
            for (int k = 0; k &lt; q.m; ++k)
                for (int j = 0; j &lt; m; ++j)
                    res[i][k] = std::max(res[i][k], a[i][j] + q[j][k]);
        return res;
    &#125;
    mat&amp; operator*= (mat &amp;q) &#123;
        return *this = *this * q;
    &#125;
&#125;;
struct &#123; int l, r; mat u; &#125; t[maxn &lt;&lt; 2]; 
int a[maxn];
#define lt (p &lt;&lt; 1)
#define rt (lt | 1)
void bld(int p, int l, int r) &#123;
    t[p].l = l, t[p].r = r;
    if (l == r) &#123;
        t[p].u = mat(3, 3);
        t[p].u[0][0] = t[p].u[2][0] = a[l];
        t[p].u[0][1] = a[l], t[p].u[1][1] = 0ll, t[p].u[2][1] = a[l];
        t[p].u[2][2] = 0ll;
        return;
    &#125;
    int mid = (l + r) &gt;&gt; 1;
    bld(lt, l, mid), bld(rt, mid + 1, r);
    t[p].u = t[lt].u * t[rt].u;
    return;
&#125;
void add(int p, int x, int v) &#123;
    if (t[p].l == t[p].r) &#123;
        t[p].u[0][0] = t[p].u[2][0] = t[p].u[0][1] = t[p].u[2][1] = v;
        return;
    &#125;
    int mid = (t[p].l + t[p].r) &gt;&gt; 1;
    if (x &lt;= mid)
        add(lt, x, v);
    else
        add(rt, x, v);
    t[p].u = t[lt].u * t[rt].u;
    return;
&#125;
mat ask(int p, int l, int r) &#123;
    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r)
        return t[p].u;
    int mid = (t[p].l + t[p].r) &gt;&gt; 1;
    if (r &lt;= mid)
        return ask(lt, l, r);
    if (l &gt; mid)
        return ask(rt, l, r);
    return ask(lt, l, r) * ask(rt, l, r);
&#125;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n;
    std::cin &gt;&gt; n;
    for (int i = 1; i &lt;= n; ++i)
        std::cin &gt;&gt; a[i];
    bld(1, 1, n);
    auto calc = [&amp;](int l, int r) &#123;
        mat f(1, 3);
        f[0][2] = 0ll;
        auto res(f * ask(1, l, r));
        return res[0][1];
    &#125;;
    int q;
    std::cin &gt;&gt; q;
    for (int op; q--; ) &#123;
        std::cin &gt;&gt; op;
        if (op == 1) &#123;
            int l, r;
            std::cin &gt;&gt; l &gt;&gt; r;
            std::cout &lt;&lt; calc(l, r) &lt;&lt; &#39;\n&#39;;
        &#125;
        else &#123;
            int x, v;
            std::cin &gt;&gt; x &gt;&gt; v;
            a[x] = v, add(1, x, v);
        &#125;
    &#125;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;


动态树 DP
把上述过程放到树上，很容易想到树剖 + 线段树。
由于认为线段树上的矩乘只能进行从重儿子到父亲的转移，轻儿子的转移会被合并为一个新函数（同时是矩阵的系数），在跳重链的时候被单独更新。
由于两个函数相互依赖，需要思考清楚更新的先后顺序。
【模板】动态 DP
https://www.luogu.com.cn/problem/P4719
令 \(f_{u,0/1}\) 表示在 \(u\) 上，选 / 不选 \(u\) 的最大价值。容易得出转移：
\[
f_{u,0}=\sum\max(f_{v,0},f_{v,1})\\
f_{u,1}=a_i+\sum f_{v,0}
\]
把转移矩阵放到树剖上后，考虑更新，发现求和这一步很困难。解决方案是直接将求和用另一个函数代替。定义 \(g_{u,0}\) 表示取 \(u\)、不取 \(u\) 的所有轻儿子的答案，\(g_{u,1}\) 不取 \(u\)，轻儿子可选可不选的答案。
\(g\) 是可求的，且只需要在跳重链的时候更新 \(g\)。具体更新起来非常绞，因为 \(g\) 和 \(f\) 是相互依赖的，需要分清楚先后关系。
首先 \(g_u\) 和 \(f_u\) 都会被更新；接着，重链上其它的 \(g\) 不会被影响，而链顶的 \(f\) 需要被新的 \(g_u\) 更新；由此链顶父亲的 \(g\) 被更新；依次类推。注意到对于一个链顶，其 \(f\) 值是整条重链的乘积，故需要记录链底。
复杂度 \(O(q\log ^2n)\)。注意很重要的一点是线段树内乘法应从右往左。

#include &lt;bits/stdc++.h&gt;
const int maxn = 1e5 + 5;
const int inf = 0x3f3f3f3f;
struct mat &#123;
    int n, m, a[2][2];
    mat() &#123;&#125;
    mat(int n1, int m1): n(n1), m(m1) &#123;
        for (int i = 0; i &lt; n; ++i)
            for (int j = 0; j &lt; m; ++j)
                a[i][j] = -inf;
        return;
    &#125;
    int* operator[] (const int q) &#123;
        return a[q];
    &#125;
    mat operator* (mat q) const &#123;
        mat res(n, q.m);
        for (int i = 0; i &lt; n; ++i)
            for (int k = 0; k &lt; q.m; ++k)
                for (int j = 0; j &lt; m; ++j)
                    res[i][k] = std::max(res[i][k], a[i][j] + q[j][k]);
        return res;
    &#125;
    mat&amp; operator*= (mat &amp;q) &#123;
        return *this = *this * q;
    &#125;
&#125;;
struct &#123; int l, r; mat u; &#125; t[maxn &lt;&lt; 2]; 
int g[maxn][2], tab[maxn];
#define lt (p &lt;&lt; 1)
#define rt (lt | 1)
void bld(int p, int l, int r) &#123;
    t[p].l = l, t[p].r = r;
    if (l == r) &#123;
        int u = tab[l];
        t[p].u = mat(2, 2);
        t[p].u[0][0] = t[p].u[1][0] = g[u][1];
        t[p].u[0][1] = g[u][0];
        return;
    &#125;
    int mid = (l + r) &gt;&gt; 1;
    bld(lt, l, mid), bld(rt, mid + 1, r);
    t[p].u = t[rt].u * t[lt].u;
    return;
&#125;
void add(int p, int x) &#123;
    if (t[p].l == t[p].r) &#123;
        int u = tab[x];
        t[p].u[0][0] = t[p].u[1][0] = g[u][1];
        t[p].u[0][1] = g[u][0];
        return;
    &#125;
    int mid = (t[p].l + t[p].r) &gt;&gt; 1;
    if (x &lt;= mid)
        add(lt, x);
    else
        add(rt, x);
    t[p].u = t[rt].u * t[lt].u;
    return;
&#125;
mat ask(int p, int l, int r) &#123;
    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r)
        return t[p].u;
    int mid = (t[p].l + t[p].r) &gt;&gt; 1;
    if (r &lt;= mid)
        return ask(lt, l, r);
    if (l &gt; mid)
        return ask(rt, l, r);
    return ask(rt, l, r) * ask(lt, l, r);
&#125;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, q;
    std::cin &gt;&gt; n &gt;&gt; q;
    std::vector&lt;int&gt; a(n + 1);
    for (int i = 1; i &lt;= n; ++i)
        std::cin &gt;&gt; a[i];
    std::vector&lt;std::vector&lt;int&gt; &gt; g1(n + 1);
    for (int i = 1, x, y; i &lt; n; ++i) &#123;
        std::cin &gt;&gt; x &gt;&gt; y;
        g1[x].push_back(y), g1[y].push_back(x);
    &#125;
    std::vector&lt;int&gt; siz(n + 1), son(n + 1), fa(n + 1);
    std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;
        siz[x] = 1;
        for (auto i : g1[x])
            if (i != fa[x]) &#123;
                fa[i] = x, DFS(i);
                siz[x] += siz[i];
                if (siz[i] &gt; siz[son[x]])
                    son[x] = i;
            &#125;
        return;
    &#125;;
    DFS(1);
    std::vector&lt;std::array&lt;int, 2&gt; &gt; f(n + 1);
    std::vector&lt;int&gt; top(n + 1), bot(n + 1), dfn(n + 1);
    DFS = [&amp;](int x) &#123;
        static int now = 0;
        dfn[x] = ++now, tab[now] = x;
        if (son[x]) &#123;
            top[son[x]] = top[x], DFS(son[x]);
            bot[x] = bot[son[x]];
            g[x][0] = a[x];
            for (auto i : g1[x])
                if (i != son[x] &amp;&amp; i != fa[x]) &#123;
                    top[i] = i, DFS(i);
                    g[x][0] += f[i][0];
                    g[x][1] += std::max(f[i][1], f[i][0]);
                &#125;
            f[x][0] = g[x][1] + std::max(f[son[x]][0], f[son[x]][1]);
            f[x][1] = g[x][0] + f[son[x]][0];
        &#125;
        else
            f[x][1] = g[x][0] = a[x], bot[x] = x;
        return;
    &#125;;
    top[1] = 1, DFS(1);
    bld(1, 1, n);
    for (int x, v; q--; ) &#123;
        std::cin &gt;&gt; x &gt;&gt; v;
        g[x][0] -= a[x], g[x][0] += v, a[x] = v;
        for (; top[x] != 1; ) &#123;
            auto r = ask(1, dfn[top[x]], dfn[bot[x]]);
            f[top[x]][0] = r[0][0], f[top[x]][1] = r[0][1];
            g[fa[top[x]]][0] -= f[top[x]][0];
            g[fa[top[x]]][1] -= std::max(f[top[x]][0], f[top[x]][1]);
            add(1, dfn[x]);
            r = ask(1, dfn[top[x]], dfn[bot[x]]);
            f[top[x]][0] = r[0][0], f[top[x]][1] = r[0][1];
            g[fa[top[x]]][0] += f[top[x]][0];
            g[fa[top[x]]][1] += std::max(f[top[x]][0], f[top[x]][1]);
            x = fa[top[x]];
        &#125;
        add(1, dfn[x]);
        auto r = ask(1, dfn[1], dfn[bot[1]]);
        f[1][0] = r[0][0], f[1][1] = r[0][1];
        std::cout &lt;&lt; std::max(f[1][0], f[1][1]) &lt;&lt; &#39;\n&#39;;
    &#125;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;


全局平衡二叉树
回顾树剖（重剖），功能在于解决路径问题，单次操作能够在 \(O(\log^2 n)\) 的时间内完成。这个功能可以被全局平衡二叉树（GBT）上位替代。GBT 能够在单次 \(O(\log n)\) 的复杂度内完成链操作、子树操作。Yang Zhe - SPOJ375 QTREE 解法的一些研究 中更为详细严谨地对 GBT 进行了说明，我传了份文件上来。
考虑树剖能被卡的原因：每次线段树询问都会卡满 \(O(\log n)\)，找一条卡得满 \(O(\log n)\) 次跳重链次数的路径一直薅，就可以卡到 \(O(\log^2 n)\)。
在实现线段树时发现，对于路径操作和单点操作，树剖只需要维护同一条重链的信息，建一个大线段树会产生许多重链间的无效维护。故一种经典的树剖卡常技巧是对于每一条重链建出线段树。
在本文中定义全局二叉树：将单个线段树按照在原树上重链顶的相对祖孙关系连边得到的模型。这里为了和全局平衡二叉树形成照应而命名，实际上模型并不是二叉树。容易发现修改某个点花费的操作次数和其在全局二叉树中的深度相同。
考虑本方法理论上仍可卡到 \(O(\log^2 n)\) 单次操作的原因，虽然单个线段树平衡，但全局二叉树并不平衡；能够构造数据使得树高达到 \(\log^2 n\)。考虑使得全局二叉树平衡，即调整线段树结构使得任何一个点在全局二叉树上的左右儿子大小最接近。发现是易做的，只需在建线段树时移动左右儿子分割点使得两边子树大小均为全树的一半即可。
法一：求出每个点的轻子树大小 \(ls_u=1+\sum siz_v\)，作为加权在线段树上找 mid 就能满足全局平衡；证明可以见上面的论文。这里用线段树代替了 BST，常数很大。
法二：用一个 BST 实现上述功能，需要满足：任意子树的根为子树的带权 mid；BST 的中序遍历为原重链。显然有：树高为 log 级别。这就决定了所有问题都可以通过暴力爬山解决。
GBT 能够快速维护普通树剖操作和 DDP 信息。

维护 DDP：【模板】动态 DP（加强版）
https://www.luogu.com.cn/problem/P4751
和未加强版类似，把所有线段树操作替换为 BST 即可。如果写得丑可能需要一些额外的卡常技巧。

#include &lt;bits/stdc++.h&gt;
const int maxn = 1e6 + 5;
const int inf = 0x3f3f3f3f;
const int LEN = (1 &lt;&lt; 20);
int nec(void) &#123;
    static char buf[LEN], *p = buf, *e = buf;
    if (p == e) &#123;
        e = buf + fread(buf, 1, LEN, stdin);
        if (e == buf) return EOF;
        p = buf;
    &#125;
    return *p++;
&#125;
bool read(int &amp;x) &#123;
    x = 0;
    bool f = 0;
    char ch = nec();
    while (ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123;
        if (ch == EOF) return 0;
        if (ch == &#39;-&#39;) f = 1;
        ch = nec();
    &#125;
    while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) &#123;
        x = x * 10 + ch - &#39;0&#39;;
        ch = nec();
    &#125;
    if (f) x = -x;
    return 1;
&#125;
void print(int x) &#123;
    if (x &lt; 0)
        putchar(&#39;-&#39;), x = -x;
    if (x &gt;= 10) print(x / 10);
    putchar(x % 10 + &#39;0&#39;);
    return;
&#125;
void print(int x, char ch) &#123;
    print(x), putchar(ch);
    return;
&#125;
struct mat &#123;
    int a[2][2];
    int* operator[] (const int q) &#123; 
        return a[q];
    &#125;
    mat operator* (mat &amp;q) const &#123;
        mat res;
        res[0][0] = res[0][1] = res[1][0] = res[1][1] = -inf;
        for (int i = 0; i &lt; 2; ++i)
            for (int k = 0; k &lt; 2; ++k)
                for (int j = 0; j &lt; 2; ++j)
                    res[i][k] = std::max(res[i][k], a[i][j] + q[j][k]);
        return res;
    &#125;
    mat&amp; operator*= (mat &amp;q) &#123;
        return *this = *this * q;
    &#125;
&#125;;
struct &#123; int lc, rc, fa; mat u; &#125; t[maxn]; 
int g[maxn][2], tab[maxn], ls[maxn];
mat p[maxn];
void pushup(int x) &#123;
    t[x].u = t[t[x].rc].u * p[x] * t[t[x].lc].u;
    return;
&#125;
void bld(int &amp;x, int l, int r) &#123;
    if (l &gt; r)
        return;
    int s = 0, k = 0;
    for (int i = l; i &lt;= r; ++i)
        s += ls[tab[i]];
    for (int i = l; i &lt;= r; ++i, k += ls[tab[i]])
        if ((k + ls[tab[i]]) * 2 &gt; s) &#123;
            x = tab[i];
            bld(t[x].lc, l, i - 1), t[t[x].lc].fa = x;
            bld(t[x].rc, i + 1, r), t[t[x].rc].fa = x;
            pushup(x);
            break;
        &#125;
    return;
&#125;
#undef lt
#undef rt
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    t[0].u[0][0] = t[0].u[1][1] = 0, t[0].u[0][1] = t[0].u[1][0] = -inf;
    int n, q;
    read(n), read(q);
    std::vector&lt;int&gt; a(n + 1), rt(n + 1);
    for (int i = 1; i &lt;= n; ++i)
        read(a[i]);
    std::vector&lt;std::vector&lt;int&gt; &gt; g1(n + 1);
    for (int i = 1, x, y; i &lt; n; ++i) &#123;
        read(x), read(y);
        g1[x].push_back(y), g1[y].push_back(x);
    &#125;
    std::vector&lt;int&gt; son(n + 1), fa(n + 1), siz(n + 1);
    std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;
        siz[x] = 1;
        for (auto i : g1[x])
            if (i != fa[x]) &#123;
                fa[i] = x, DFS(i);
                siz[x] += siz[i];
                if (siz[i] &gt; siz[son[x]])
                    son[x] = i;
            &#125;
        return;
    &#125;;
    DFS(1);
    std::vector&lt;std::array&lt;int, 2&gt; &gt; f(n + 1);
    std::vector&lt;int&gt; top(n + 1), bot(n + 1), dfn(n + 1);
    DFS = [&amp;](int x) &#123;
        static int now = 0;
        dfn[x] = ++now, tab[now] = x, ls[x] = 1;
        if (son[x]) &#123;
            top[son[x]] = top[x], DFS(son[x]);
            bot[x] = bot[son[x]];
            g[x][0] = a[x];
            for (auto i : g1[x])
                if (i != son[x] &amp;&amp; i != fa[x]) &#123;
                    top[i] = i, DFS(i), t[rt[i]].fa = x;
                    ls[x] += siz[i];
                    g[x][0] += f[i][0];
                    g[x][1] += std::max(f[i][1], f[i][0]);
                &#125;
            f[x][0] = g[x][1] + std::max(f[son[x]][0], f[son[x]][1]);
            f[x][1] = g[x][0] + f[son[x]][0];
        &#125;
        else
            f[x][1] = g[x][0] = a[x], bot[x] = x;
        p[x][0][0] = p[x][1][0] = g[x][1];
        p[x][0][1] = g[x][0], p[x][1][1] = -inf;
        if (x == top[x])
            bld(rt[x], dfn[x], dfn[bot[x]]);
        return;
    &#125;;
    top[1] = 1, DFS(1);
    for (int x, v, la = 0; q--; ) &#123;
        read(x), read(v), x ^= la;
        p[x][0][1] += v - a[x], a[x] = v;
        for (; x; ) &#123;
            int fa = t[x].fa;
            if (fa &amp;&amp; x != t[fa].lc &amp;&amp; x != t[fa].rc) &#123;
                int f0 = t[x].u[0][0], f1 = std::max(f0, t[x].u[0][1]);
                pushup(x);
                int F0 = t[x].u[0][0], F1 = std::max(F0, t[x].u[0][1]);
                p[fa][0][0] += F1 - f1, p[fa][1][0] += F1 - f1;
                p[fa][0][1] += F0 - f0;
            &#125;
            else
                pushup(x);
            x = fa;
        &#125;
        print(la = std::max(t[rt[1]].u[0][0], t[rt[1]].u[0][1]), &#39;\n&#39;);
    &#125;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;

也给出一个线段树版本的

#include &lt;bits/stdc++.h&gt;
const int maxn = 1e6 + 5;
const int inf = 0x3f3f3f3f;
const int LEN = (1 &lt;&lt; 20);
int nec(void) &#123;
    static char buf[LEN], *p = buf, *e = buf;
    if (p == e) &#123;
        e = buf + fread(buf, 1, LEN, stdin);
        if (e == buf) return EOF;
        p = buf;
    &#125;
    return *p++;
&#125;
bool read(int &amp;x) &#123;
    x = 0;
    bool f = 0;
    char ch = nec();
    while (ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123;
        if (ch == EOF) return 0;
        if (ch == &#39;-&#39;) f = 1;
        ch = nec();
    &#125;
    while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) &#123;
        x = x * 10 + ch - &#39;0&#39;;
        ch = nec();
    &#125;
    if (f) x = -x;
    return 1;
&#125;
void print(int x) &#123;
    if (x &lt; 0)
        putchar(&#39;-&#39;), x = -x;
    if (x &gt;= 10) print(x / 10);
    putchar(x % 10 + &#39;0&#39;);
    return;
&#125;
void print(int x, char ch) &#123;
    print(x), putchar(ch);
    return;
&#125;
struct mat &#123;
    int a[2][2];
    int* operator[] (const int q) &#123;
        return a[q];
    &#125;
    mat operator* (mat q) const &#123;
        mat res;
        res[0][0] = res[0][1] = res[1][0] = res[1][1] = -inf;
        for (int i = 0; i &lt; 2; ++i)
            for (int k = 0; k &lt; 2; ++k)
                for (int j = 0; j &lt; 2; ++j)
                    res[i][k] = std::max(res[i][k], a[i][j] + q[j][k]);
        return res;
    &#125;
    mat&amp; operator*= (mat &amp;q) &#123;
        return *this = *this * q;
    &#125;
&#125;;
struct &#123; int lc, rc, l, r, mid; mat u; &#125; t[maxn &lt;&lt; 2]; 
int g[maxn][2], tab[maxn], ls[maxn];
#define lt t[p].lc
#define rt t[p].rc
void bld(int &amp;p, int l, int r) &#123;
    static int tot = 0;
    p = ++tot, t[p].l = l, t[p].r = r;
    if (l == r) &#123;
        int u = tab[l];
        t[p].u[0][0] = t[p].u[1][0] = g[u][1];
        t[p].u[0][1] = g[u][0], t[p].u[1][1] = -inf;
        return;
    &#125;
    int s = 0, u = ls[tab[l]];
    for (int i = l; i &lt;= r; ++i)
        s += ls[tab[i]];
    s &gt;&gt;= 1;
    t[p].mid = r - 1;
    for (int i = l + 1; i &lt; r; ++i) &#123;
        u += ls[tab[i]];
        if (u + ls[tab[i + 1]] &gt; s) &#123;
            t[p].mid = i;
            break;
        &#125;
    &#125;
    bld(lt, l, t[p].mid), bld(rt, t[p].mid + 1, r);
    t[p].u = t[rt].u * t[lt].u;
    return;
&#125;
void add(int p, int x) &#123;
    if (t[p].l == t[p].r) &#123;
        int u = tab[x];
        t[p].u[0][0] = t[p].u[1][0] = g[u][1];
        t[p].u[0][1] = g[u][0];
        return;
    &#125;
    if (x &lt;= t[p].mid)
        add(lt, x);
    else
        add(rt, x);
    t[p].u = t[rt].u * t[lt].u;
    return;
&#125;
mat ask(int p, int l, int r) &#123;
    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r)
        return t[p].u;
    if (r &lt;= t[p].mid)
        return ask(lt, l, r);
    if (l &gt; t[p].mid)
        return ask(rt, l, r);
    return ask(rt, l, r) * ask(lt, l, r);
&#125;
#undef lt
#undef rt
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, q;
    read(n), read(q);
    std::vector&lt;int&gt; a(n + 1), rt(n + 1);
    for (int i = 1; i &lt;= n; ++i)
        read(a[i]);
    std::vector&lt;std::vector&lt;int&gt; &gt; g1(n + 1);
    for (int i = 1, x, y; i &lt; n; ++i) &#123;
        read(x), read(y);
        g1[x].push_back(y), g1[y].push_back(x);
    &#125;
    std::vector&lt;int&gt; siz(n + 1), son(n + 1), fa(n + 1);
    std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;
        siz[x] = 1;
        for (auto i : g1[x])
            if (i != fa[x]) &#123;
                fa[i] = x, DFS(i);
                siz[x] += siz[i];
                if (siz[i] &gt; siz[son[x]])
                    son[x] = i;
            &#125;
        return;
    &#125;;
    DFS(1);
    std::vector&lt;std::array&lt;int, 2&gt; &gt; f(n + 1);
    std::vector&lt;int&gt; top(n + 1), bot(n + 1), dfn(n + 1);
    DFS = [&amp;](int x) &#123;
        static int now = 0;
        dfn[x] = ++now, tab[now] = x;
        ls[x] = 1;
        if (son[x]) &#123;
            top[son[x]] = top[x], DFS(son[x]);
            bot[x] = bot[son[x]];
            g[x][0] = a[x];
            for (auto i : g1[x])
                if (i != son[x] &amp;&amp; i != fa[x]) &#123;
                    top[i] = i, DFS(i);
                    ls[x] += siz[i];
                    g[x][0] += f[i][0];
                    g[x][1] += std::max(f[i][1], f[i][0]);
                &#125;
            f[x][0] = g[x][1] + std::max(f[son[x]][0], f[son[x]][1]);
            f[x][1] = g[x][0] + f[son[x]][0];
        &#125;
        else
            f[x][1] = g[x][0] = a[x], bot[x] = x;
        if (x == top[x])
            bld(rt[x], dfn[x], dfn[bot[x]]);
        return;
    &#125;;
    top[1] = 1, DFS(1);
    for (int x, v, la = 0; q--; ) &#123;
        read(x), read(v), x ^= la;
        g[x][0] -= a[x], g[x][0] += v, a[x] = v;
        for (; top[x] != 1; ) &#123;
            auto r = t[rt[top[x]]].u;
            f[top[x]][0] = r[0][0], f[top[x]][1] = r[0][1];
            g[fa[top[x]]][0] -= f[top[x]][0];
            g[fa[top[x]]][1] -= std::max(f[top[x]][0], f[top[x]][1]);
            add(rt[top[x]], dfn[x]);
            r = t[rt[top[x]]].u;
            f[top[x]][0] = r[0][0], f[top[x]][1] = r[0][1];
            g[fa[top[x]]][0] += f[top[x]][0];
            g[fa[top[x]]][1] += std::max(f[top[x]][0], f[top[x]][1]);
            x = fa[top[x]];
        &#125;
        add(rt[1], dfn[x]);
        auto r =  t[rt[1]].u;
        f[1][0] = r[0][0], f[1][1] = r[0][1];
        std::cout &lt;&lt; (la = std::max(f[1][0], f[1][1])) &lt;&lt; &#39;\n&#39;;
    &#125;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;


树上路径问题：染色
https://www.luogu.com.cn/problem/P2486
GBT 上的路径问题。
BST：首先暴力爬山到 LCA，统计一路上的答案；然后跳到当前 BST 的根。由于本题有标记，所以需要在跳的同时想办法把标记问题解决一下。
线段树：把树剖的线段树略改一下就过了。从上一行模棱两可的描述就可以看出来 BST 实现起来不太轻松；还是线段树更轮椅啊！

跑得没纯树剖快，因为数据没有刻意构造导致树高很低，再加上常数的影响吧。
#include &lt;bits/stdc++.h&gt;
const int maxn = 1e5 + 5;
const int LEN = (1 &lt;&lt; 20);
int nec(void) &#123;
    static char buf[LEN], *p = buf, *e = buf;
    if (p == e) &#123;
        e = buf + fread(buf, 1, LEN, stdin);
        if (e == buf) return EOF;
        p = buf;
    &#125;
    return *p++;
&#125;
bool read(int &amp;x) &#123;
    x = 0;
    bool f = 0;
    char ch = nec();
    while (ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123;
        if (ch == EOF) return 0;
        if (ch == &#39;-&#39;) f = 1;
        ch = nec();
    &#125;
    while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) &#123;
        x = x * 10 + ch - &#39;0&#39;;
        ch = nec();
    &#125;
    if (f) x = -x;
    return 1;
&#125;
void read(char &amp;x) &#123;
    for (x = nec(); x != &#39;C&#39; &amp;&amp; x != &#39;Q&#39;; x = nec());
    return;
&#125;
void print(int x) &#123;
    if (x &lt; 0)
        putchar(&#39;-&#39;), x = -x;
    if (x &gt;= 10) print(x / 10);
    putchar(x % 10 + &#39;0&#39;);
    return;
&#125;
void print(int x, char ch) &#123;
    print(x), putchar(ch);
    return;
&#125;
class node &#123;
private:
    int lt, rt;
public:
    int l, r, mid, lc, rc, u, d;
    node(): u(-1) &#123;&#125;
    inline int&amp; ls(void) &#123; return lt; &#125;
    inline int&amp; rs(void) &#123; return rt; &#125;
    node&amp; operator= (const node &amp;q) &#123;
        lc = q.lc, rc = q.rc, u = q.u;
        return *this;
    &#125;
    node operator+ (const node &amp;q) const &#123;
        if (u == -1)
            return q;
        if (q.u == -1)
            return *this;
        node res;
        res.lc = lc, res.rc = q.rc, res.u = u + q.u - (rc == q.lc);
        return res;
    &#125;
    inline void swap(void) &#123;
        if (~u)
            lc ^= rc ^= lc ^= rc;
        return;
    &#125;
&#125; t[maxn &lt;&lt; 2]; 
int tab[maxn], ls[maxn], a[maxn];
#define lt t[p].ls()
#define rt t[p].rs()
void bld(int &amp;p, int l, int r) &#123;
    static int tot = 0;
    p = ++tot, t[p].l = l, t[p].r = r;
    if (l == r) &#123;
        t[p].u = 1;
        t[p].lc = t[p].rc = a[tab[l]];
        return;
    &#125;
    int s = 0, u = ls[tab[l]];
    for (int i = l; i &lt;= r; ++i)
        s += ls[tab[i]];
    s &gt;&gt;= 1;
    t[p].mid = r - 1;
    for (int i = l + 1; i &lt; r; ++i) &#123;
        u += ls[tab[i]];
        if (u + ls[tab[i + 1]] &gt; s) &#123;
            t[p].mid = i;
            break;
        &#125;
    &#125;
    bld(lt, l, t[p].mid), bld(rt, t[p].mid + 1, r);
    t[p] = t[lt] + t[rt];
    return;
&#125;
void pushdown(int p) &#123;
    if (t[p].d) &#123;
        t[lt].d = t[lt].lc = t[lt].rc = t[rt].d = t[rt].lc = t[rt].rc = t[p].d;
        t[lt].u = t[rt].u = 1;
        t[p].d = 0;
    &#125;
    return;
&#125;
void add(int p, int l, int r, int v) &#123;
    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r) &#123;
        t[p].u = 1;
        t[p].lc = t[p].rc = t[p].d = v;
        return;
    &#125;
    pushdown(p);
    if (l &lt;= t[p].mid)
        add(lt, l, r, v);
    if (r &gt; t[p].mid)
        add(rt, l, r, v);
    t[p] = t[lt] + t[rt];
    return;
&#125;
node ask(int p, int l, int r) &#123;
    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r)
        return t[p];
    pushdown(p);
    if (r &lt;= t[p].mid)
        return ask(lt, l, r);
    if (l &gt; t[p].mid)
        return ask(rt, l, r);
    return ask(lt, l, r) + ask(rt, l, r);
&#125;
#undef lt
#undef rt
int main() &#123;
#ifdef ONLINE_JUDGE
#else
    std::freopen(&quot;paint17.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, q;
    read(n), read(q);
    std::vector&lt;int&gt; rt(n + 1);
    for (int i = 1; i &lt;= n; ++i)
        read(a[i]);
    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);
    for (int i = 1, x, y; i &lt; n; ++i) &#123;
        read(x), read(y);
        g[x].push_back(y), g[y].push_back(x);
    &#125;
    std::vector&lt;int&gt; siz(n + 1), son(n + 1), fa(n + 1), dep(n + 1);
    std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;
        siz[x] = 1;
        for (auto i : g[x])
            if (i != fa[x]) &#123;
                dep[i] = dep[x] + 1;
                fa[i] = x, DFS(i);
                siz[x] += siz[i];
                if (siz[i] &gt; siz[son[x]])
                    son[x] = i;
            &#125;
        return;
    &#125;;
    DFS(1);
    std::vector&lt;std::array&lt;int, 2&gt; &gt; f(n + 1);
    std::vector&lt;int&gt; top(n + 1), bot(n + 1), dfn(n + 1);
    DFS = [&amp;](int x) &#123;
        static int now = 0;
        dfn[x] = ++now, tab[now] = x, ls[x] = 1;
        if (son[x]) &#123;
            top[son[x]] = top[x], DFS(son[x]);
            bot[x] = bot[son[x]];
        &#125;
        else
            bot[x] = x;
        for (auto i : g[x])
            if (i != son[x] &amp;&amp; i != fa[x]) &#123;
                top[i] = i;
                DFS(i);
                ls[x] += siz[i];
            &#125;
        if (x == top[x])
            bld(rt[x], dfn[x], dfn[bot[x]]);
        return;
    &#125;;
    top[1] = 1, DFS(1);
    for (char op; q--; ) &#123;
        read(op);
        if (op == &#39;C&#39;) &#123;
            int x, y, c;
            read(x), read(y), read(c);
            for (; top[x] != top[y]; x = fa[top[x]]) &#123;
                if (dep[top[x]] &lt; dep[top[y]])
                    std::swap(x, y);
                add(rt[top[x]], dfn[top[x]], dfn[x], c);
            &#125;
            if (dep[x] &gt; dep[y])
                std::swap(x, y);
            add(rt[top[x]], dfn[x], dfn[y], c);
        &#125;
        else &#123;
            int x, y;
            read(x), read(y);
            node res1, res2;
            for (; top[x] != top[y]; )
                if (dep[top[x]] &lt; dep[top[y]]) &#123;
                    res2 = ask(rt[top[y]], dfn[top[y]], dfn[y]) + res2;
                    y = fa[top[y]];
                &#125;
                else &#123;
                    res1 = ask(rt[top[x]], dfn[top[x]], dfn[x]) + res1;
                    x = fa[top[x]];
                &#125;
            if (dep[x] &gt; dep[y])
                res1 = ask(rt[top[y]], dfn[y], dfn[x]) + res1;
            else
                res2 = ask(rt[top[x]], dfn[x], dfn[y]) + res2;
            res1.swap();
            print((res1 + res2).u, &#39;\n&#39;);
        &#125;
    &#125;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;


树上路径查询？
做题的时候可以感受到，路径询问的存在很诡异，因为只需要一条链的操作，更偏向链上 DDP 而非树上的；轻儿子的信息是不用维护的，形式上更像树剖（DS）；当成链上的 DDP 就可以解决了。
可以用倍增维护 DDP（不用考虑轻重儿子，只用维护父子关系，进一步向序列 DDP 靠近），就不用打 GBT 了，常数也会小一些。

习题
GBT 就统一用线段树了。DDP 也就可以顺带用 GBT 优化了。

E - 猫或狗 / Cats or Dogs
https://www.luogu.com.cn/problem/P9597
设 \(f_{u,0/1}\) 表示从根上颜色为 \(0/1\) 时的最小断边数，显然无色可以视作任选一个颜色。那么有：
\[
f_{u,a}=\sum\limits_v\min\limits_{b\in\{0,1\}}\{f_{v,b}+[a\ne b]\}
\]
直接把轻儿子的项提出来，记 \(g_{u,0/1}\) 表示 \(f_{u,0/1}\) 对应的轻儿子贡献即可。

#include &lt;bits/stdc++.h&gt;
const int maxn = 1e5 + 5;
const int inf = 0x3f3f3f3f;
struct mat &#123;
    int a[2][2];
    int* operator[] (const int q) &#123; 
        return a[q];
    &#125;
    mat operator* (mat &amp;q) const &#123;
        mat res;
        res[0][0] = res[0][1] = res[1][0] = res[1][1] = inf;
        for (int i = 0; i &lt; 2; ++i)
            for (int k = 0; k &lt; 2; ++k)
                for (int j = 0; j &lt; 2; ++j)
                    res[i][k] = std::min(res[i][k], a[i][j] + q[j][k]);
        return res;
    &#125;
    mat&amp; operator*= (mat &amp;q) &#123;
        return *this = *this * q;
    &#125;
&#125; p[maxn];
struct &#123; int lc, rc, l, r, mid; mat u; &#125; t[maxn &lt;&lt; 2]; 
int ls[maxn], tab[maxn], g[maxn][2], rt[maxn], top[maxn], dfn[maxn], fa[maxn];
std::vector&lt;int&gt; a;
#define lt t[p].lc
#define rt t[p].rc
void bld(int &amp;p, int l, int r) &#123;
    static int tot = 0;
    p = ++tot, t[p].l = l, t[p].r = r;
    if (l == r) &#123;
        t[p].u[0][1] = t[p].u[1][0] = 1;
        return;
    &#125;
    int s = 0, u = ls[tab[l]];
    for (int i = l; i &lt;= r; ++i)
        s += ls[tab[i]];
    s &gt;&gt;= 1;
    t[p].mid = r - 1;
    for (int i = l + 1; i &lt; r; ++i) &#123;
        u += ls[tab[i]];
        if (u + ls[tab[i + 1]] &gt; s) &#123;
            t[p].mid = i;
            break;
        &#125;
    &#125;
    bld(lt, l, t[p].mid), bld(rt, t[p].mid + 1, r);
    t[p].u = t[rt].u * t[lt].u;
    return;
&#125;
void add(int p, int x) &#123;
    if (t[p].l == t[p].r) &#123;
        int u = tab[x], g0 = (a[u] == 1 ? inf : g[u][0]), g1 = (a[u] == 0 ? inf : g[u][1]);
        t[p].u[0][0] = g0, t[p].u[0][1] = g1 + 1;
        t[p].u[1][0] = g0 + 1, t[p].u[1][1] = g1;
        return;
    &#125;
    if (x &lt;= t[p].mid)
        add(lt, x);
    else
        add(rt, x);
    t[p].u = t[rt].u * t[lt].u;
    return;
&#125;
#undef lt
#undef rt
void initialize(int n, std::vector&lt;int&gt; A, std::vector&lt;int&gt; B) &#123;
    a.assign(n + 1, -1);
    std::vector&lt;std::vector&lt;int&gt; &gt; g1(n + 1);
    for (int i = 0; i &lt; n - 1; ++i)
        g1[A[i]].push_back(B[i]), g1[B[i]].push_back(A[i]);
    std::vector&lt;int&gt; siz(n + 1), son(n + 1);
    std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;
        siz[x] = 1;
        for (auto i : g1[x])
            if (i != fa[x]) &#123;
                fa[i] = x, DFS(i);
                siz[x] += siz[i];
                if (siz[i] &gt; siz[son[x]])
                    son[x] = i;
            &#125;
        return;
    &#125;;
    DFS(1);
    std::vector&lt;int&gt; bot(n + 1);
    DFS = [&amp;](int x) &#123;
        static int now = 0;
        dfn[x] = ++now, tab[now] = x, ls[x] = 1;
        if (son[x]) &#123;
            top[son[x]] = top[x], DFS(son[x]);
            bot[x] = bot[son[x]];
            for (auto i : g1[x])
                if (i != son[x] &amp;&amp; i != fa[x]) &#123;
                    top[i] = i, DFS(i);
                    ls[x] += siz[i];
                &#125;
        &#125;
        else
            bot[x] = x;
        if (x == top[x])
            bld(rt[x], dfn[x], dfn[bot[x]]);
        return;
    &#125;;
    top[1] = 1, DFS(1);
    return;
&#125;
int upd(int x) &#123;
    for (; top[x] != 1; ) &#123;
        int faa = fa[top[x]];
        auto &amp;id = t[rt[top[x]]].u;
        int f0 = std::min(id[0][0], id[1][0]), f1 = std::min(id[0][1], id[1][1]);
        g[faa][0] -= std::min(f0, f1 + 1);
        g[faa][1] -= std::min(f0 + 1, f1);
        add(rt[top[x]], dfn[x]);
        f0 = std::min(id[0][0], id[1][0]), f1 = std::min(id[0][1], id[1][1]);
        // printf(&quot;%d: f0 = %d, f1 = %d\n&quot;, top[x], f0, f1);
        g[faa][0] += std::min(f0, f1 + 1);
        g[faa][1] += std::min(f0 + 1, f1);
        x = faa;
    &#125;
    add(rt[1], dfn[x]);
    auto &amp;id = t[rt[1]].u;
    int f0 = std::min(id[0][0], id[1][0]), f1 = std::min(id[0][1], id[1][1]);
    // printf(&quot;%d: f0 = %d, f1 = %d\n&quot;, 1, f0, f1);
    return std::min(f0, f1);
&#125;
int cat(int x) &#123;
    a[x] = 0;
    return upd(x);
&#125;
int dog(int x) &#123;
    a[x] = 1;
    return upd(x);
&#125;
int neighbor(int x) &#123;
    a[x] = -1;
    return upd(x);
&#125;
#ifndef ONLINE_JUDGE
int main() &#123;
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
    int n;
    std::cin &gt;&gt; n;
    std::vector&lt;int&gt; A(n - 1), B(n - 1);
    for (int i = 0; i &lt; n - 1; ++i)
        std::cin &gt;&gt; A[i] &gt;&gt; B[i];
    initialize(n, A, B);
    int q;
    std::cin &gt;&gt; q;
    for (int op, x; q--; ) &#123;
        std::cin &gt;&gt; op &gt;&gt; x;
        std::cout &lt;&lt; (op == 1 ? cat(x) : (op == 2 ? dog(x) : neighbor(x))) &lt;&lt; &#39;\n&#39;;
    &#125;
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
    return 0;
&#125;
#endif


F - Hash on Tree
https://www.luogu.com.cn/problem/AT_abc351_g
记 \(g_x\) 为轻儿子的哈希值之积，则 \(f_u=A_u+f_{son}\cdot g_u\)。
然后开一个常数维即可。快速幂的 log 省不掉，所以是双 log 的。
初值和修改都有可能为 \(0\)，需要维护实际哈希值和去掉 \(0\) 的哈希值。

#include &lt;bits/stdc++.h&gt;
const int maxn = 1e6 + 5;
const int LEN = (1 &lt;&lt; 20);
const int mod = 998244353;
int nec(void) &#123;
    static char buf[LEN], *p = buf, *e = buf;
    if (p == e) &#123;
        e = buf + fread(buf, 1, LEN, stdin);
        if (e == buf) return EOF;
        p = buf;
    &#125;
    return *p++;
&#125;
bool read(int &amp;x) &#123;
    x = 0;
    bool f = 0;
    char ch = nec();
    while (ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123;
        if (ch == EOF) return 0;
        if (ch == &#39;-&#39;) f = 1;
        ch = nec();
    &#125;
    while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) &#123;
        x = x * 10 + ch - &#39;0&#39;;
        ch = nec();
    &#125;
    if (f) x = -x;
    return 1;
&#125;
void print(int x) &#123;
    if (x &lt; 0)
        putchar(&#39;-&#39;), x = -x;
    if (x &gt;= 10) print(x / 10);
    putchar(x % 10 + &#39;0&#39;);
    return;
&#125;
void print(int x, char ch) &#123;
    print(x), putchar(ch);
    return;
&#125;
struct mat &#123;
    int n, m;
    long long a[2][2];
    long long* operator[] (const int q) &#123;
        return a[q];
    &#125;
    mat operator* (mat &amp;q) const &#123;
        mat res;
        res.n = n, res.m = q.m;
        res[0][0] = res[0][1] = res[1][0] = res[1][1] = 0ll;
        for (int i = 0; i &lt; n; ++i)
            for (int k = 0; k &lt; q.m; ++k) &#123;
                for (int j = 0; j &lt; m; ++j)
                    res[i][k] += a[i][j] * q[j][k];
                res[i][k] %= mod;
            &#125;
        return res;
    &#125;
    mat&amp; operator*= (mat &amp;q) &#123;
        return *this = *this * q;
    &#125;
&#125;;
struct &#123; int lc, rc, l, r, mid; mat u; &#125; t[maxn &lt;&lt; 2]; 
long long g[maxn];
int tab[maxn], ls[maxn], a[maxn];
#define lt t[p].lc
#define rt t[p].rc
void bld(int &amp;p, int l, int r) &#123;
    static int tot = 0;
    p = ++tot, t[p].l = l, t[p].r = r;
    if (l == r) &#123;
        int u = tab[l];
        t[p].u.n = t[p].u.m = 2;
        t[p].u[0][0] = g[u];
        t[p].u[0][1] = 0ll;
        t[p].u[1][0] = a[u];
        t[p].u[1][1] = 1ll;
        return;
    &#125;
    int s = 0, u = ls[tab[l]];
    for (int i = l; i &lt;= r; ++i)
        s += ls[tab[i]];
    s &gt;&gt;= 1;
    t[p].mid = r - 1;
    for (int i = l + 1; i &lt; r; ++i) &#123;
        u += ls[tab[i]];
        if (u + ls[tab[i + 1]] &gt; s) &#123;
            t[p].mid = i;
            break;
        &#125;
    &#125;
    bld(lt, l, t[p].mid), bld(rt, t[p].mid + 1, r);
    t[p].u = t[rt].u * t[lt].u;
    return;
&#125;
void add(int p, int x) &#123;
    if (t[p].l == t[p].r) &#123;
        int u = tab[x];
        t[p].u[0][0] = g[u];
        t[p].u[1][0] = a[u];
        return;
    &#125;
    if (x &lt;= t[p].mid)
        add(lt, x);
    else
        add(rt, x);
    t[p].u = t[rt].u * t[lt].u;
    return;
&#125;
#undef lt
#undef rt
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, q;
    read(n), read(q);
    std::vector&lt;int&gt; rt(n + 1);
    std::vector&lt;std::vector&lt;int&gt; &gt; g1(n + 1);
    for (int i = 2, x; i &lt;= n; ++i) &#123;
        read(x);
        g1[i].push_back(x), g1[x].push_back(i);
    &#125;
    for (int i = 1; i &lt;= n; ++i)
        read(a[i]);
    std::vector&lt;int&gt; siz(n + 1), son(n + 1), fa(n + 1);
    std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;
        siz[x] = 1;
        for (auto i : g1[x])
            if (i != fa[x]) &#123;
                fa[i] = x, DFS(i);
                siz[x] += siz[i];
                if (siz[i] &gt; siz[son[x]])
                    son[x] = i;
            &#125;
        return;
    &#125;;
    DFS(1);
    std::vector&lt;long long&gt; f(n + 1);
    std::vector&lt;int&gt; top(n + 1), bot(n + 1), dfn(n + 1), la(n + 1), cnt(n + 1);
    DFS = [&amp;](int x) &#123;
        static int now = 0;
        dfn[x] = ++now, tab[now] = x, ls[x] = 1;
        if (son[x]) &#123;
            top[son[x]] = top[x], DFS(son[x]);
            bot[x] = bot[son[x]];
            g[x] = 1ll;
            for (auto i : g1[x])
                if (i != son[x] &amp;&amp; i != fa[x]) &#123;
                    top[i] = i, DFS(i);
                    ls[x] += siz[i];
                    if (f[i] == 0ll)
                        ++cnt[x];
                    else
                        (la[x] *= f[i]) %= mod;
                    (g[x] *= f[i]) %= mod;
                &#125;
            f[x] = (a[x] + g[x] * f[son[x]]) % mod;
        &#125;
        else
            f[x] = a[x], bot[x] = x;
        // printf(&quot;f[%d] = %lld\n&quot;, x, f[x]);
        if (x == top[x])
            bld(rt[x], dfn[x], dfn[bot[x]]);
        return;
    &#125;;
    top[1] = 1, DFS(1);
    mat init;
    init.n = 1, init.m = 2;
    init[0][0] = 0ll, init[0][1] = 1ll;
    auto qkp = [&amp;](long long x, int y) &#123;
        auto res(1ll);
        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)
            if (y &amp; 1)
                (res *= x) %= mod;
        return res;
    &#125;;
    auto inv = [&amp;](int x) &#123;
        return qkp(x, mod - 2);
    &#125;;
    for (int x, v; q--; ) &#123;
        read(x), read(v);
        a[x] = v;
        for (; top[x] != 1; ) &#123;
            int faa = fa[top[x]];
            auto &amp;id = t[rt[top[x]]].u;
            int f = (init * id)[0][0];
            if (f == 0) &#123;
                if (--cnt[faa] == 0)
                    g[faa] = la[faa];
            &#125;
            else &#123;
                f = inv(f);
                (g[faa] *= f) %= mod;
                (la[faa] *= f) %= mod;
            &#125;
            add(rt[top[x]], dfn[x]);
            f = (init * id)[0][0];
            if (f == 0) &#123;
                if (cnt[faa]++ == 0)
                    la[faa] = g[faa];
                g[faa] = 0ll;
            &#125;
            else &#123;
                (g[faa] *= f) %= mod;
                (la[faa] *= f) %= mod;
            &#125;
            x = faa;
        &#125;
        add(rt[1], dfn[x]);
        auto &amp;id = t[rt[1]].u;
        int f = (init * id)[0][0];
        std::cout &lt;&lt; f &lt;&lt; &#39;\n&#39;;
    &#125;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;


G - 考试 2
https://www.luogu.com.cn/problem/P10626
运算均是线性的，容易想到『按位』维护，即只维护某个特定点值。如果将询问离线下来排序，每个函数的点值只会变化 \(O(1)\) 次。
建出符号二叉树，进行 DDP 即可。具体地，令 \(f_u\) 表示在运算 \(u\) 处的答案，计算 \(g_u\) 为轻儿子的答案，按照 \(u\) 处的符号写矩阵即可。叶子不是一次运算，应该直接填入点值（注意线段树上的叶子不一定是原树上的叶子）。
建树和矩阵更新有点史，适当封装一下感觉会好一点

#include &lt;bits/stdc++.h&gt;
const int maxn = 1e6 + 5;
const char mp[] = &quot;x!&amp;|^&quot;;
const int LEN = (1 &lt;&lt; 20);
#define nec getchar
inline bool read(int &amp;x) &#123;
    x = 0;
    bool f = 0;
    char ch = nec();
    while (ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123;
        if (ch == EOF) return 0;
        if (ch == &#39;-&#39;) f = 1;
        ch = nec();
    &#125;
    while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) &#123;
        x = x * 10 + ch - &#39;0&#39;;
        ch = nec();
    &#125;
    if (f) x = -x;
    return 1;
&#125;
void print(int x) &#123;
    if (x &lt; 0)
        putchar(&#39;-&#39;), x = -x;
    if (x &gt;= 10) print(x / 10);
    putchar(x % 10 + &#39;0&#39;);
    return;
&#125;
void print(int x, char ch) &#123;
    print(x), putchar(ch);
    return;
&#125;
struct mat &#123;
    int n, m;
    int a[2][2];
    int* operator[] (const int q) &#123;
        return a[q];
    &#125;
    inline mat operator* (mat &amp;q) const &#123;
        mat res;
        res.n = n, res.m = q.m;
        res[0][0] = res[0][1] = res[1][0] = res[1][1] = 0ll;
        for (int i = 0; i &lt; n; ++i)
            for (int k = 0; k &lt; q.m; ++k)
                for (int j = 0; j &lt; m; ++j)
                    res[i][k] += a[i][j] * q[j][k];
        return res;
    &#125;
    mat&amp; operator*= (mat &amp;q) &#123;
        return *this = *this * q;
    &#125;
&#125;;
struct &#123; int lc, rc, l, r, mid; mat u; &#125; t[maxn &lt;&lt; 2]; 
int g1[maxn][2];
int g[maxn], ty[maxn];
int tab[maxn], ls[maxn], lim[maxn];
#define lt t[p].lc
#define rt t[p].rc
void fillmat(mat &amp;a, int op, int g) &#123;
    if (op == 0) &#123;
        a.n = 1, a.m = 2;
        a[0][!g] = 0, a[0][g] = 1;
        return;
    &#125;
    a.n = 2, a.m = 2;
    switch (op) &#123;
    case 1: // !
        a[0][0] = 0, a[0][1] = 1;
        a[1][0] = 1, a[1][1] = 0;
        break;
    case 2: // &amp;
        a[0][0] = 1, a[0][1] = 0;
        a[1][0] = !g, a[1][1] = g;
        break;
    case 3: // |
        a[0][0] = !g, a[0][1] = g;
        a[1][0] = 0, a[1][1] = 1;
        break;
    case 4: // ^
        a[0][0] = !g, a[0][1] = g;
        a[1][0] = g, a[1][1] = !g;
        break;
    default:
        assert(0);
    &#125;
    return;
&#125;
void bld(int &amp;p, int l, int r) &#123;
    static int tot = 0;
    p = ++tot, t[p].l = l, t[p].r = r;
    if (l == r) &#123;
        fillmat(t[p].u, ty[tab[l]], g[tab[l]]);
        return;
    &#125;
    int s = 0, u = ls[tab[l]];
    for (int i = l; i &lt;= r; ++i)
        s += ls[tab[i]];
    s &gt;&gt;= 1;
    t[p].mid = r - 1;
    for (int i = l + 1; i &lt; r; ++i) &#123;
        u += ls[tab[i]];
        if (u + ls[tab[i + 1]] &gt; s) &#123;
            t[p].mid = i;
            break;
        &#125;
    &#125;
    bld(lt, l, t[p].mid), bld(rt, t[p].mid + 1, r);
    t[p].u = t[rt].u * t[lt].u;
    return;
&#125;
void add(int p, int x) &#123;
    if (t[p].l == t[p].r) &#123;
        fillmat(t[p].u, ty[tab[t[p].l]], g[tab[t[p].l]]);
        return;
    &#125;
    if (x &lt;= t[p].mid)
        add(lt, x);
    else
        add(rt, x);
    t[p].u = t[rt].u * t[lt].u;
    return;
&#125;
#undef lt
#undef rt
int main() &#123;
#ifndef ONLINE_JUDGE
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n = 0, q, p;
    read(q), read(q);
    &#123;
        std::string s;
        std::cin &gt;&gt; s;
        std::stringstream in(s);
        std::stack&lt;char&gt; op;
        std::stack&lt;int&gt; id;
        auto trans = [&amp;](char t) &#123;
            switch (t) &#123;
            case &#39;!&#39;:
                return 1;
            case &#39;&amp;&#39;:
                return 2;
            case &#39;|&#39;:
                return 3;
            case &#39;^&#39;:
                return 4;
            &#125;
            assert(0);
            return -1;
        &#125;;
        auto calcNot = [&amp;](void) &#123;
            for (; !op.empty() &amp;&amp; op.top() == &#39;!&#39;; ) &#123;
                ty[++n] = trans(op.top());
                g1[n][0] = id.top(), id.pop(), id.push(n);
                op.pop();
            &#125;
            return;
        &#125;;
        auto opt = [&amp;](void) &#123;
            ty[++n] = trans(op.top());
            g1[n][0] = id.top(), id.pop();
            g1[n][1] = id.top(), id.pop();
            id.push(n), op.pop();
            return;
        &#125;;
        for (char t; in &gt;&gt; t; )
            if (t == &#39;[&#39;) &#123;
                int x;
                in &gt;&gt; x, in &gt;&gt; t;
                lim[++n] = x - 1;
                id.push(n), calcNot();
            &#125;
            else if (t == &#39;(&#39;)
                op.push(t);
            else if (t == &#39;)&#39;) &#123;
                for (; op.top() != &#39;(&#39;; opt());
                op.pop(), calcNot();
            &#125;
            else if (t == &#39;&amp;&#39;)
                op.push(t);
            else if (t == &#39;^&#39;) &#123;
                for (; !op.empty() &amp;&amp; op.top() == &#39;&amp;&#39;; opt());
                op.push(t);
            &#125;
            else if (t == &#39;|&#39;) &#123;
                for (; !op.empty() &amp;&amp; (op.top() == &#39;&amp;&#39; || op.top() == &#39;^&#39;); opt());
                op.push(t);
            &#125;
            else &#123;
                assert(t == &#39;!&#39;);
                op.push(t);
            &#125;
        for (; !op.empty(); opt());
        p = id.top();
    &#125;
    std::vector&lt;int&gt; rt(n + 1);
    std::vector&lt;int&gt; siz(n + 1), son(n + 1), fa(n + 1);
    std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;
        siz[x] = 1;
        for (auto i : g1[x])
            if (i != 0) &#123;
                fa[i] = x, DFS(i);
                siz[x] += siz[i];
                if (siz[i] &gt; siz[son[x]])
                    son[x] = i;
            &#125;
        return;
    &#125;;
    DFS(p);
    std::vector&lt;long long&gt; f(n + 1);
    std::vector&lt;int&gt; top(n + 1), bot(n + 1), dfn(n + 1);
    DFS = [&amp;](int x) &#123;
        static int now = 0;
        dfn[x] = ++now, tab[now] = x, ls[x] = 1;
        if (son[x]) &#123;
            top[son[x]] = top[x], DFS(son[x]);
            bot[x] = bot[son[x]];
            for (auto i : g1[x])
                if (i != son[x] &amp;&amp; i != 0) &#123;
                    top[i] = i, DFS(i);
                    ls[x] += siz[i], g[x] = f[i];
                &#125;
            switch (ty[x]) &#123;
            case 1:
                f[x] = !f[son[x]];
                break;
            case 2:
                f[x] = g[x] &amp; f[son[x]];
                break;
            case 3:
                f[x] = g[x] | f[son[x]];
                break;
            case 4:
                f[x] = g[x] ^ f[son[x]];
                break;
            default:
                assert(0);
                break;
            &#125;
        &#125;
        else
            assert(!ty[x]), f[x] = g[x] = 0, bot[x] = x;
        if (x == top[x])
            bld(rt[x], dfn[x], dfn[bot[x]]);
        return;
    &#125;;
    top[p] = p, DFS(p);
    std::vector&lt;int&gt; a(q + 1), res(q + 1);
    for (int i = 1; i &lt;= q; ++i)
        read(a[i]);
    std::vector&lt;int&gt; qid(q), nid;
    for (int i = 1; i &lt;= n; ++i)
        if (ty[i] == 0)
            nid.push_back(i);
    std::iota(qid.begin(), qid.end(), 1);
    std::sort(qid.begin(), qid.end(), [&amp;](int x, int y) &#123; return a[x] &lt; a[y]; &#125;);
    std::sort(nid.begin(), nid.end(), [&amp;](int x, int y) &#123; return lim[x] &gt; lim[y]; &#125;);
    for (auto i : qid) &#123;
        for (; !nid.empty() &amp;&amp; lim[nid.back()] &lt; a[i]; ) &#123;
            int x = nid.back();
            nid.pop_back();
            g[x] = 1;
            for (; top[x] != p; ) &#123;
                add(rt[top[x]], dfn[x]);
                g[fa[top[x]]] = t[rt[top[x]]].u[0][1];
                x = fa[top[x]];
            &#125;
            add(rt[p], dfn[x]);
        &#125;
        res[i] = t[rt[p]].u[0][1];
    &#125;
    for (int i = 1; i &lt;= q; ++i)
        if (res[i])
            std::cout &lt;&lt; &quot;True\n&quot;;
        else
            std::cout &lt;&lt; &quot;False\n&quot;;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;

]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>树链剖分</tag>
        <tag>DDP</tag>
      </tags>
  </entry>
  <entry>
    <title>杂题选谈</title>
    <url>/20250816/</url>
    <content><![CDATA[和 Aug 9th 的杂题不太能合并，所以分开了


B. GAS-Fire Extinguishers
https://www.luogu.com.cn/problem/P3479
显然可以贪心，不妨从下到上，记录当前遍历过的、空余出来的灭火器（其实算的是可以供给的房间数）和还未分配灭火器的房间，按距离为 \(0\sim k\) 分组。
不难发现如果在某个点 \(u\) 处存在距离为 \(k\) 的空闲灭火器，可以贪心地分配给 \(u\)；如果存在距离为 \(k\) 的未分配房间，也可以在 \(u\) 处放置灭火器并分配给这些房间。类似地，进行两两配对一定是不劣的。
发现同子树内距离为 \(k-1\) 的点对留到 \(fa\) 再匹配是不行的，因为这时距离会变成 \(k+1\)，不能匹配上；可以感受到这样是更劣的。
然后就可以做了，根节点特殊乱贪心一下就行了。记得开 long long。

#include &lt;bits/stdc++.h&gt;
#define int long long
signed main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, s, k, res = 0;
    std::cin &gt;&gt; n &gt;&gt; s &gt;&gt; k;
    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1), p(n + 1, std::vector&lt;int&gt; (k + 1)), q(n + 1, std::vector&lt;int&gt; (k + 1));
    for (int i = 1, x, y; i &lt; n; ++i) &#123;
        std::cin &gt;&gt; x &gt;&gt; y;
        g[x].push_back(y), g[y].push_back(x);
    &#125;
    std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int fa) &#123;
        for (auto i : g[x])
            if (i != fa)  &#123;
                DFS(i, x);
                for (int j = 0; j &lt; k; ++j)
                    p[x][j + 1] += p[i][j], q[x][j + 1] += q[i][j];
            &#125;
        ++q[x][0];
        if (x != 1) &#123;
            int v = (q[x][k] + s - 1) / s;
            p[x][0] = v * s, res += v;
            for (int i = 0; i &lt;= k; ++i) &#123;
                int v = std::min(p[x][i], q[x][k - i]);
                p[x][i] -= v, q[x][k - i] -= v;
            &#125;
            for (int i = 0; i &lt; k; ++i) &#123;
                int v = std::min(p[x][i], q[x][k - 1 - i]);
                p[x][i] -= v, q[x][k - 1 - i] -= v;
            &#125;
        &#125;
        else &#123;
            // std::cerr &lt;&lt; res &lt;&lt; &#39;\n&#39;;
            int sum = 0ll, r = 0;
            for (int i = k; ~i; --i) &#123;
                sum += p[x][k - i];
                // std::cerr &lt;&lt; sum &lt;&lt; &#39;\n&#39;;
                int v = std::min(sum, q[x][i]);
                sum -= v, q[x][i] -= v;
                r += q[x][i];
            &#125;
            res += (r + s - 1) / s;
        &#125;
        return;
    &#125;;
    DFS(1, -1);
    std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;


C. 扫地机器人
https://www.becoder.com.cn/contest/6502/problem/3

题意：给定 \(n\) 堆货物，每堆货物有重量 \(v_i\) 和一个参数 \(a_i\)。有一个初始负载为 \(0\)、负载上限为 \(c\) 的机器人，从 \(1\) 到 \(n\) 遍历这些货物，对每一处货物执行以下操作，直到清空这堆货物：

当前负载未满：可以选择进行装载直到达到负载上限，或货物清空。花费 \(a_i\) 的代价。
不管当前负载满没满：可以选择清空当前负载，花费 \(b\) 的代价。

每一处可以任意操作，要求遍历完之后机器人负载为 \(0\)，问最小代价。\(n\le 2\times 10^5,c\le 10^9\)。

题面是重构过的，原来的题面太有歧义了。绝大多数人没做出来就是因为没看懂题吧！
考虑暴力，可以想到令 \(f_{i,j}\) 表示处理完 \(i\) 过后负载为 \(j\) 的最小代价（显然 \(f_{i,c}\) 和 \(f_{i,0}\) 是等效的，故舍弃前者）。记 \(k=\left\lceil\dfrac {v_i}c\right\rceil,w=(v_i\bmod c - 1)\bmod c+1\)，那么有：
\[
f_{i,(j+v_i)\bmod c}\gets f_{i-1,j}+k\cdot a_i+(k-1)\cdot b +
\begin{cases}
b&amp;j+w=c\\
a_i+b&amp;j+w&gt; c\\
0&amp;\text{otherwise}
\end{cases}\\
f_{i,0}\gets f_{i,j}+b
\]
发现 \(f_{i-1}\) 和 \(f_i\) 之间是存在对应关系的，所以考虑直接继承（真实的 \(0\) 应该位于 \(-s_i\) 的位置），再做全局加、区间加，\(f_{i,0}\) 的转移是全局 min，线段树维护即可；每次只会新增一个状态，动态开点即可。

#include &lt;bits/stdc++.h&gt;
const int maxn = 5e6 + 5;
const __int128 inf = 1e18;
struct &#123;
    int l, r;
    __int128 u, d;
&#125; t[maxn];
#define lt t[p].l
#define rt t[p].r
int tot;
void pushdown(int p) &#123;
    if (t[p].d) &#123;
        t[lt].d += t[p].d, t[lt].u += t[p].d;
        t[rt].d += t[p].d, t[rt].u += t[p].d;
        t[p].d = 0ll;
    &#125;
    return;
&#125;
void upd(int &amp;p, int l, int r, int x, __int128 v) &#123;
    if (!p)
        p = ++tot, t[p].u = v;
    else
        t[p].u = std::min(t[p].u, v);
    if (l == r)
        return;
    pushdown(p);
    int mid = (l + r) &gt;&gt; 1;
    if (x &lt;= mid)
        upd(lt, l, mid, x, v);
    else
        upd(rt, mid + 1, r, x, v);
    return;
&#125;
void add(int p, int l, int r, int ql, int qr, __int128 v) &#123;
    if (!p)
        return;
    if (ql &lt;= l &amp;&amp; r &lt;= qr) &#123;
        t[p].d += v, t[p].u += v;
        return;
    &#125;
    int mid = (l + r) &gt;&gt; 1;
    pushdown(p);
    if (ql &lt;= mid)
        add(lt, l, mid, ql, qr, v);
    if (qr &gt; mid)
        add(rt, mid + 1, r, ql, qr, v);
    t[p].u = std::min(t[lt].u, t[rt].u);
    return;
&#125;
__int128 ask(int p, int l, int r, int x) &#123;
    if (l == r)
        return t[p].u;
    int mid = (l + r) &gt;&gt; 1;
    pushdown(p);
    if (x &lt;= mid)
        return ask(lt, l, mid, x);
    return ask(rt, mid + 1, r, x);
&#125;
#undef lt
#undef rt
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
    std::freopen(&quot;robot.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;robot.out&quot;, &quot;w&quot;, stdout);
#else
    std::freopen(&quot;ex_robot4.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    t[0].u = inf;
    int n, b, c, p0 = 0, rt = 0;
    std::cin &gt;&gt; n &gt;&gt; c &gt;&gt; b;
    std::vector&lt;int&gt; a(n + 1), v(n + 1);
    for (int i = 1; i &lt;= n; ++i)
        std::cin &gt;&gt; a[i];
    for (int i = 1; i &lt;= n; ++i)
        std::cin &gt;&gt; v[i];
    upd(rt, 0, c - 1, 0, 0ll);
    for (int i = 1; i &lt;= n; ++i) &#123;
        __int128 k = (v[i] + c - 1) / c, w = (v[i] % c == 0 ? c : v[i] % c);
        t[rt].d += k * a[i] + (k - 1) * b;
        t[rt].u += k * a[i] + (k - 1) * b;
        if (w &lt;= c)
            add(rt, 0, c - 1, (c - w + p0) % c, (c - w + p0) % c, b);
        if (w != 1) &#123;
            int l = (c - w + p0 + 1) % c, r = (p0 + c - 1) % c;
            if (l &lt;= r)
                add(rt, 0, c - 1, l, r, a[i] + b);
            else &#123;
                add(rt, 0, c - 1, 0, r, a[i] + b);
                add(rt, 0, c - 1, l, c - 1, a[i] + b);
            &#125;
        &#125;
        p0 = (p0 + c - v[i] % c) % c;
        upd(rt, 0, c - 1, p0, t[rt].u + b);
    &#125;
    std::cout &lt;&lt; (long long)ask(rt, 0, c - 1, p0) &lt;&lt; &#39;\n&#39;;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;


D. 套娃
https://www.becoder.com.cn/contest/6502/problem/4

题意：给定初始为全 \(0\) 的数组 \(a_{1\sim n + 1}\) 和 \(n\) 次单点 +1 操作，每次操作后，求解：
令 \(a\) 的前缀和数组为 \(s\)，找到一个最小的 \(k\)，使得对于每个 \(i\)，均有 \(k\cdot i\ge s_i\) 成立。
\(n\le 10^6\)，时限 0.5s。


趣事一则
考场上最后 10min 拿到题，憋了一个能拿到 96pts 的假做法：注意到前缀和是单增的，需要维护最大的 \(\dfrac {s_i}i\)，由于后缀 +1 带来的影响很小，所以可以猜测在大多数情况下最大的 \(i\) 只会在原来的和修改的点之间变化。只用 10 行的核心代码就能拿到很多分。但是居然有这么多，可能出题人都没有想到真有人敢交这种做法吧。
#include &lt;bits/stdc++.h&gt;
int main() &#123;
    std::freopen(&quot;doll.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;doll.out&quot;, &quot;w&quot;, stdout);
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
    auto stime = std::chrono::steady_clock::now();
    int n, res = 0;
    std::cin &gt;&gt; n;
    std::vector&lt;int&gt; bit(n + 2);
    auto lowbit = [](int x) &#123;
        return x &amp; -x;
    &#125;;
    auto add = [&amp;](int x) &#123;
        for (; x &lt;= n + 1; x += lowbit(x))
            ++bit[x];
        return;
    &#125;;
    auto ask = [&amp;](int x) &#123;
        int res = 0;
        for (; x; x -= lowbit(x))
            res += bit[x];
        return res;
    &#125;;
    int p = 1;
    for (int i = 1, x; i &lt;= n; ++i) &#123;
        std::cin &gt;&gt; x, add(++x);
        long long s = ask(x), t = ask(p);
        if (s * p == t * x ? x &gt; p : s * p &gt; t * x)
            p = x;
        else
            s = t;
        if (s &gt; p * res)
            ++res;
        std::cout &lt;&lt; res &lt;&lt; &#39; &#39;;
    &#125;
    std::cout &lt;&lt; &#39;\n&#39;;
    std::cerr &lt;&lt; std::chrono::duration&lt;double&gt;(std::chrono::steady_clock::now() - stime).count() &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;

很容易写出暴力，观察样例就能发现每次修改后答案最多增加 \(1\)。记当前答案为 \(res\)，线段树维护 \(s_i-res\cdot i\) 的最小值，若其为负则 res++，然后重构线段树（等差数列和 min 不兼容）。
怎么又有不等式 😱
目的是在本来合法的范围里找到新的不合法值。考虑合法范围：\(s_i-res\cdot i\ge 0\)，解一下得到 \(i\le \dfrac {s_i}{res}\)，放缩得到 \(i\le\dfrac {n}{res}\)，每次 \(res\) 变化时只重构 \(\dfrac {n}{res}\) 以前的位置，重构的总长是 \(O(n\ln n)\) 的。（线段树建树是线性的）

#include &lt;bits/stdc++.h&gt;
const int maxn = 1e6 + 5;
const int inf = 0x3f3f3f3f;
struct &#123;
    int l, r, u, d;
&#125; t[maxn &lt;&lt; 2];
#define lt (p &lt;&lt; 1)
#define rt (lt | 1)
void bld(int p, int l, int r) &#123;
    t[p].u = t[p].l = l, t[p].r = r;
    if (l == r)
        return;
    int mid = (l + r) &gt;&gt; 1;
    bld(lt, l, mid), bld(rt, mid + 1, r);
    return;
&#125;
void pushdown(int p) &#123;
    if (t[p].d) &#123;
        t[lt].d += t[p].d, t[rt].d += t[p].d;
        t[lt].u -= t[p].d, t[rt].u -= t[p].d;
        t[p].d = 0;
    &#125;
    return;
&#125;
void add(int p, int x) &#123;
    if (x &lt;= t[p].l) &#123;
        ++t[p].d, --t[p].u;
        return;
    &#125;
    pushdown(p);
    int mid = (t[p].l + t[p].r) &gt;&gt; 1;
    if (x &lt;= mid)
        add(lt, x);
    add(rt, x);
    t[p].u = std::min(t[lt].u, t[rt].u);
    // printf(&quot;[%d, %d]: %d, [%d, %d]: %d\n&quot;, t[p].l, mid, t[lt].u, mid + 1, t[p].r, t[rt].u);
    return;
&#125;
void rem(int p, int r) &#123;
    if (t[p].l == t[p].r) &#123;
        t[p].u += t[p].l;
        return;
    &#125;
    pushdown(p);
    int mid = (t[p].l + t[p].r) &gt;&gt; 1;
    if (r &lt;= mid)
        rem(lt, r), t[rt].u = inf;
    else
        rem(lt, r), rem(rt, r);
    t[p].u = std::min(t[lt].u, t[rt].u);
    return;
&#125;
#undef lt
#undef rt
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
    std::freopen(&quot;doll.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;doll.out&quot;, &quot;w&quot;, stdout);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n;
    std::cin &gt;&gt; n;
    bld(1, 1, n + 1);
    for (int i = 1, x, res = 1, now = n; i &lt;= n; ++i) &#123;
        std::cin &gt;&gt; x;
        if (x &lt;= now)
            add(1, ++x);
        if (t[1].u &lt; 0) &#123;
            std::cout &lt;&lt; ++res &lt;&lt; &#39; &#39;;
            rem(1, now = n / res);
        &#125;
        else
            std::cout &lt;&lt; res &lt;&lt; &#39; &#39;;
        // puts(&quot;&quot;);
    &#125;
    std::cout &lt;&lt; &#39;\n&#39;;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;


E - Subarray Sum Divisibility
https://atcoder.jp/contests/abc419/tasks/abc419_e
模意义下的数列全等，可以对应原数组全等、差分全等、前缀和全等（都是模意义下的，还有其他的一些线性和非线性的变换也可以）
本着修改的点尽量少的想法，如果题目给定单点修改就可以在原数组上做文章，给定区间修改可以考虑差分数组，前缀和对于一些区间查询有优势
其他两种用得也很多，像这题只需要用原数组全等就可以做了

#include &lt;bits/stdc++.h&gt;
const int inf = 0x3f3f3f3f;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, m, l;
    std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; l;
    std::vector&lt;int&gt; a(n + 1);
    for (int i = 1; i &lt;= n; ++i)
        std::cin &gt;&gt; a[i];
    std::vector&lt;std::vector&lt;int&gt; &gt; u(l + 1, std::vector&lt;int&gt; (m));
    for (int i = 1; i &lt;= l; ++i)
        for (int j = 0; j &lt; m; ++j)
            for (int k = i; k &lt;= n; k += l)
                u[i][j] += (j + m - a[k]) % m;
    std::vector&lt;std::vector&lt;int&gt; &gt; f(l + 1, std::vector&lt;int&gt; (m, inf));
    f[0][0] = 0;
    for (int i = 1; i &lt;= l; ++i)
        for (int j = 0; j &lt; m; ++j)
            for (int k = 0; k &lt; m; ++k)
                f[i][(j + k) % m] = std::min(f[i][(j + k) % m], f[i - 1][j] + u[i][k]);
    std::cout &lt;&lt; f[l][0] &lt;&lt; &#39;\n&#39;;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;



F - All Included
https://atcoder.jp/contests/abc419/tasks/abc419_f
原题意转化为在 AC 自动机上走 \(L\) 步，要求经过 \(n\) 个叶子的方案数。不太可做，转化成容斥（令字符串终点不可达）。在外层枚举步数暴力游走。
要求恰好走 \(L\) 步，也可以用矩阵；但原图很稀疏，所以矩阵并没有优势。

#include &lt;bits/stdc++.h&gt;
const int mod = 998244353;
int tot = 1, T[805][26], fail[805];
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, l;
    std::cin &gt;&gt; n &gt;&gt; l;
    std::vector&lt;std::string&gt; a;
    &#123;
        std::vector&lt;std::string&gt; s(n + 1);
        for (int i = 1; i &lt;= n; ++i)
            std::cin &gt;&gt; s[i];
        for (int i = 1; i &lt;= n; ++i) &#123;
            bool flag = 1;
            for (int j = 1; j &lt;= n; ++j)
                if (j != i)
                    if (s[j].find(s[i]) != std::string::npos) &#123;
                        flag = 0;
                        break;
                    &#125;
            if (flag)
                a.push_back(s[i]);
        &#125;
        n = (int)a.size();
    &#125;
    std::vector&lt;int&gt; pos(n);
    for (int i = 0; i &lt; n; ++i) &#123;
        int &amp;p = pos[i];
        for (auto j : a[i]) &#123;
            if (!T[p][j - &#39;a&#39;])
                T[p][j - &#39;a&#39;] = tot++;
            p = T[p][j - &#39;a&#39;];
        &#125;
    &#125;
    &#123;
        std::queue&lt;int&gt; q;
        for (int i = 0; i &lt; 26; ++i)
            if (T[0][i])
                q.push(T[0][i]);
        for (; !q.empty(); ) &#123;
            int u = q.front();
            q.pop();
            for (int i = 0; i &lt; 26; ++i)
                if (T[u][i]) &#123;
                    int v = T[u][i];
                    fail[v] = T[fail[u]][i];
                    q.push(v);
                &#125;
                else
                    T[u][i] = T[fail[u]][i];
        &#125;
    &#125;
    auto res = 0ll;
    int siz = 1 &lt;&lt; n;
    for (int i = 0; i &lt; siz; ++i) &#123;
        std::vector&lt;int&gt; tag(tot);
        for (int j = 0; j &lt; n; ++j)
            if ((i &gt;&gt; j) &amp; 1)
                tag[pos[j]] = 1;
        std::vector&lt;std::vector&lt;long long&gt; &gt; f(l + 1, std::vector&lt;long long&gt; (tot));
        f[0][0] = 1ll;
        for (int j = 0; j &lt; l; ++j)
            for (int k = 0; k &lt; tot; ++k)
                for (int a = 0; a &lt; 26; ++a) &#123;
                    if (!tag[T[k][a]])
                        (f[j + 1][T[k][a]] += f[j][k]) %= mod;
                &#125;
        int k = (__builtin_popcount(i) &amp; 1 ? mod - 1 : 1);
        auto s = 0ll;
        for (int j = 0; j &lt; tot; ++j)
            if (!tag[j])
                (s += f[l][j]) %= mod;
        (res += k * s) %= mod;
    &#125;
    std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;


G - Count Simple Paths 2
https://atcoder.jp/contests/abc419/tasks/abc419_g
很新的性质。考虑『以 \(1\) 为起点的简单路径数』和反祖边数量的关系：选定一条反祖边必须被经过时（显然只有一种可能的经过方向），树的形态发生变化：

也就是说，一种反祖边的选取方案对应一种树，遍历其从 \(1\) 开始的简单路径复杂度为 \(O(n)\)。设反祖边数量为 \(k\)，那么合法的方案数不超过 \(2^k\)，暴力 DFS 的整个图复杂度为 \(O(2^k\cdot n)\)。
发现很多跟反祖边无关的遍历是不必要的（只有一种走法，可以设成边权），考虑对所有连接反祖边的点建立虚树，并把原树上的反祖边也移到虚树上，就能 \(O(2^k\cdot k)\) 解决问题。

#include &lt;bits/stdc++.h&gt;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, m;
    std::cin &gt;&gt; n &gt;&gt; m;
    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1), g1(n + 1);
    std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; g2(n + 1);
    for (int x, y; m--; ) &#123;
        std::cin &gt;&gt; x &gt;&gt; y;
        g[x].push_back(y), g[y].push_back(x);
    &#125;
    std::vector&lt;int&gt; tag(n + 1), vis(n + 1);
    std::vector&lt;std::pair&lt;int, int&gt; &gt; be;
    std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int fa) &#123;
        static int now = 0;
        tag[x] = 1, vis[x] = ++now;
        for (auto i : g[x])
            if (!tag[i]) &#123;
                // fprintf(stderr, &quot;%d -&gt; %d\n&quot;, x, i);
                g1[x].push_back(i), DFS(i, x);
            &#125;
            else if (i != fa &amp;&amp; vis[i] &lt; vis[x])
                be.emplace_back(i, x);
        return;
    &#125;;
    DFS(1, -1);
    &#123; // 求虚树
        std::vector&lt;int&gt; dep(n + 1), fa(n + 1), top(n + 1), siz(n + 1), son(n + 1), dfn(n + 1), rfn(n + 1);
        std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;
            siz[x] = 1;
            for (auto i : g1[x]) &#123;
                dep[i] = dep[x] + 1;
                fa[i] = x, DFS(i);
                siz[x] += siz[i];
                if (siz[i] &gt; siz[son[x]])
                    son[x] = i;
            &#125;
            return;
        &#125;;
        DFS(1);
        DFS = [&amp;](int x) &#123;
            static int now = 0;
            dfn[x] = ++now;
            if (son[x])
                top[son[x]] = top[x], DFS(son[x]);
            for (auto i : g1[x])
                if (i != son[x])
                    top[i] = i, DFS(i);
            rfn[x] = now;
            // printf(&quot;%d: [%d, %d]\n&quot;, x, dfn[x], rfn[x]);
            return;
        &#125;;
        top[1] = 1, DFS(1);
        auto getLCA = [&amp;](int x, int y) &#123;
            for (; top[x] != top[y]; x = fa[top[x]])
                if (dep[top[x]] &lt; dep[top[y]])
                    std::swap(x, y);
            return dep[x] &lt; dep[y] ? x : y;
        &#125;;
        tag.assign(n + 1, 0);
        tag[1] = tag[n] = 1;
        for (auto [u, v] : be)
            tag[u] = 1, tag[v] = 1;
        std::vector&lt;int&gt; p;
        for (int i = 1; i &lt;= n; ++i)
            if (tag[i])
                p.push_back(i);
        std::sort(p.begin(), p.end(), [&amp;](int i, int j) &#123; return dfn[i] &lt; dfn[j]; &#125;);
        for (int i = 1; i &lt; (int)p.size(); ++i) &#123;
            int fa = getLCA(p[i], p[i - 1]);
            if (!tag[fa])
                tag[fa] = 1;
        &#125;
        p.clear();
        for (int i = 1; i &lt;= n; ++i)
            if (tag[i])
                p.push_back(i);
        std::sort(p.begin(), p.end(), [&amp;](int i, int j) &#123; return dfn[i] &lt; dfn[j]; &#125;);
        std::vector&lt;int&gt; st;
        for (auto i : p) &#123;
            if (st.empty())
                st.push_back(i);
            else &#123;
                for (; rfn[st.back()] &lt; dfn[i]; st.pop_back());
                g2[st.back()].emplace_back(i, dep[i] - dep[st.back()]);
                g2[i].emplace_back(st.back(), dep[i] - dep[st.back()]);
                // printf(&quot;add (%d, %d): %d\n&quot;, st.back(), i, dep[i] - dep[st.back()]);
                st.push_back(i);
            &#125;
        &#125;
        for (auto [u, v] : be) &#123;
            g2[u].emplace_back(v, 1), g2[v].emplace_back(u, 1);
            // printf(&quot;# add(%d, %d): 1\n&quot;, u, v);
        &#125;
    &#125;
    tag.assign(n + 1, 0);
    std::vector&lt;int&gt; res(n + 1);
    DFS = [&amp;](int x, int s) &#123;
        if (x == n)
            ++res[s];
        tag[x] = 1;
        for (auto [i, w] : g2[x])
            if (!tag[i])
                DFS(i, s + w);
        tag[x] = 0;
        return;
    &#125;;
    DFS(1, 0);
    for (int i = 1; i &lt; n; ++i)
        std::cout &lt;&lt; res[i] &lt;&lt; &#39; &#39;;
    std::cout &lt;&lt; &#39;\n&#39;;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;

]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>AC 自动机</tag>
        <tag>贪心</tag>
        <tag>DP 优化</tag>
        <tag>虚树</tag>
      </tags>
  </entry>
  <entry>
    <title>杂题选谈</title>
    <url>/20250820/</url>
    <content><![CDATA[困难


B. beauty（拆贡献）
https://www.becoder.com.cn/contest/6513/problem/2

给定 \(n,V\)，求出对于所有长度为 \(n\)，值域为 \([1,V]\) 的序列 \(a_{1\sim n}\)，\(\sum_{i=1}^n |a_i-a_{n-i+1}|\) 的和。
\(n,V\le 5000\)。


容易想到算贡献，会有一个 \(O(n^2V)\) 的做法。但是想 \(O(nV)\) 做是很抽象的，和 \(O(n^2V)\) 的思路已经很不一样了
经典 trick，\(a_{i+n/2}-a_i=\sum\limits_{x=0}^{+\infty} [a_i\le x&lt;a_{i+n/2}]\) 拆贡献 。故要算 \(a_{i}-a_{i+n/2}\)，只需要对于每个 \(x\in[a_i,a_{i+n/2})\) 计算贡献。
枚举 \(x\in [1,V)\)，再枚举最大的 \(t\)，满足 \(a_t\ge x\)。那么有 \(t\) 个 \(a_i\le x\)，同时有 \(n-t\) 个 \(a_i&gt;x\)；满足 \(i\le n/2\) 的 \(a_{i},a_{i+n/2}\) 对数应该是 \(\min(t,n-t)\)。故对于一个确定的序列，\(x\) 共有 \(\min(t,n-t)\) 的贡献。
考虑计数满足 \(a_t\le x\) 的 \(a\)，这要求第 \(t\) 大的数 \(\le x\) 而第 \(t+1\) 大的数 \(&gt;x\)，也即在 \([1,x]\) 里找 \(t\) 个数再在 \((x,V]\) 里找 \(n-t\) 个数，注意还要再乘上这两种数拼起来的方案数。


#include &lt;bits/stdc++.h&gt;
const int mod = 998244353;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
    std::freopen(&quot;beauty.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;beauty.out&quot;, &quot;w&quot;, stdout);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int T;
    std::vector&lt;long long&gt; fac(5001), inv(5001);
    std::vector&lt;std::vector&lt;long long&gt; &gt; pw(5001, std::vector&lt;long long&gt; (5001));
    fac[0] = inv[0] = 1ll;
    for (int i = 1; i &lt;= 5000; ++i) &#123;
        fac[i] = fac[i - 1] * i % mod;
        pw[i][0] = 1ll;
        for (int j = 1; j &lt;= 5000; ++j)
            pw[i][j] = pw[i][j - 1] * i % mod;
    &#125;
    auto qkp = [](long long x, int y) &#123;
        auto res(1ll);
        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)
            if (y &amp; 1)
                (res *= x) %= mod;
        return res;
    &#125;;
    inv[5000] = qkp(fac[5000], mod - 2);
    for (int i = 4999; i; --i)
        inv[i] = inv[i + 1] * (i + 1) % mod;
    auto C = [&amp;](int n, int m) &#123;
        return fac[n] * inv[m] % mod * inv[n - m] % mod;
    &#125;;
    for (std::cin &gt;&gt; T; T--; ) &#123;
        int n, V;
        std::cin &gt;&gt; n &gt;&gt; V;
        auto res(0ll);
        for (int x = 1; x &lt; V; ++x)
            for (int t = 1; t &lt; n; ++t) &#123;
                int k = std::min(t, n - t);
                (res += k * pw[x][t] % mod * pw[V - x][n - t] % mod * C(n, t) % mod) %= mod;
            &#125;
        std::cout &lt;&lt; res * 2 % mod &lt;&lt; &#39;\n&#39;;
    &#125;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;


C. Drink Bar（容斥 + 偏序）
https://www.luogu.com.cn/problem/AT_snuke21_j

三个属性都是排列，可以推理出只要两个三元组中，作出贡献的元素不完全相同，两个三元组就不同。讨论作出贡献的元素数量。
只有一个元素作出贡献，答案为 \(n\)。
有两个元素作出贡献，任选的话答案为 \(C_n^2\)，要减去一个元素严格优于另一个元素的情况，三维偏序即可。
有三个元素作出贡献，是个有点复杂的容斥，不妨设三元组为 \((i,j,k)\)，其中贡献次数最多的为 \(i\)

\(i\) 贡献了 \(\ge 1\) 次，方案数为 \(C_n^3\)
\(i\) 贡献了 \(\ge 2\) 次，枚举作出两次贡献的属性，以 \(a,b\) 为例，那么有 \(a_j,a_k&lt;a_i\)，以及 \(b_j,b_k&lt;b_i\)，二维偏序即可
\(i\) 贡献了 \(\ge 3\) 次，依然是三维偏序，可以用『两个元素做出贡献』中 cdq 得到的值算出答案。记得乘 2，因为被多减了 2 次。



#include &lt;bits/stdc++.h&gt;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n;
    std::cin &gt;&gt; n;
    struct node &#123; int a, b, c, res; &#125;;
    std::vector&lt;node&gt; a(n + 1);
    for (int i = 1; i &lt;= n; ++i) &#123;
        std::cin &gt;&gt; a[i].a &gt;&gt; a[i].b &gt;&gt; a[i].c;
        a[i].res = 0;
    &#125;
    long long res = n;
    res += (long long)n * (n - 1) / 2;
    std::vector&lt;int&gt; bit(n + 1);
    auto lowbit = [](int x) &#123;
        return x &amp; -x;
    &#125;;
    auto add = [&amp;](int x, int v) &#123;
        for (; x &lt;= n; x += lowbit(x))
            bit[x] += v;
        return;
    &#125;;
    auto ask = [&amp;](int x) &#123;
        int res = 0;
        for (; x; x -= lowbit(x))
            res += bit[x];
        return res;
    &#125;;
    std::function&lt;void(int, int)&gt; calc = [&amp;](int l, int r) &#123;
        if (l == r)
            return;
        int mid = (l + r) &gt;&gt; 1;
        calc(l, mid), calc(mid + 1, r);
        int j = l;
        for (int i = mid + 1; i &lt;= r; ++i) &#123;
            for (; j &lt;= mid &amp;&amp; a[j].b &lt; a[i].b; ++j)
                add(a[j].c, 1);
            a[i].res += ask(a[i].c);
        &#125;
        for (int i = l; i &lt; j; ++i)
            add(a[i].c, -1);
        std::inplace_merge(a.begin() + l, a.begin() + mid + 1, a.begin() + r + 1, [&amp;](node x, node y) &#123; return x.b &lt; y.b; &#125;);
        return;
    &#125;;
    std::sort(a.begin() + 1, a.end(), [&amp;](node x, node y) &#123; return x.a &lt; y.a; &#125;);
    calc(1, n);
    for (int i = 1; i &lt;= n; ++i)
        res -= a[i].res;
    res += (long long)n * (n - 1) * (n - 2) / 6;
    for (int k = 0; k &lt; 3; ++k) &#123;
        std::sort(a.begin() + 1, a.end(), [&amp;](node x, node y) &#123; return x.a &lt; y.a; &#125;);
        std::fill(bit.begin() + 1, bit.end(), 0);
        for (int i = 1; i &lt;= n; ++i) &#123;
            int t = ask(a[i].b);
            res -= (long long)t * (t - 1) / 2;
            add(a[i].b, 1);
            std::tie(a[i].a, a[i].b, a[i].c) = std::make_tuple(a[i].b, a[i].c, a[i].a);
        &#125;
    &#125;
    for (int i = 1; i &lt;= n; ++i)
        res += (long long)a[i].res * (a[i].res - 1);
    std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;


C. 星白 by TTpandaS（笛卡尔树 + dsu on tree）
link

C. isn
https://hydro.ac/p/bzoj-P4361

最后一个删去的一定是连接 &gt; 的数，可以 DP 还剩一个数没删时可能的序列。
令 \(f_{i,j,0/1}\) 表示最后一个元素为 \(i\)，序列长为 \(j\)，最后一个被删去的数（未）被确定的方案数。注意确定最后一个被删去的数要在转移过程中进行，而不是作为一个 DP 节点，很容易发现后者是错的。
优化的思路就不一样了。因为要乘上 \((n-j)!\)，所以 \(j\) 的这一维是省不掉的
考虑不管最后一个被删掉的数，直接令 \(f_{i,j}\) 表示最后一个元素为 \(i\)，序列长为 \(j\) 的方案数。有 \(f_{i,j}=\sum\limits_{a_k\le a_i}f_{k,j - 1}\)，可以 DS 优化。但这样会产生不合法的情况。
考察什么样的序列合法，发现删去的最后一个数一定是非法的，也就是包含之的序列都是非法的；反之易得被合法序列包含的序列都非法
明白了这一点过后就会知道长度为 \(j\) 的合法序列系数都为 \((n-j)!\)
故容斥，令 \(g_i\) 表示序列长为 \(i\) 的方案数，\(h_i\) 表示序列长为 \(i\) 的合法方案数。从异或角度考虑，易得 \(h_i=g_i-\sum\limits_{j=i+1}h_j\times (j-i)!\times C_j^i\)。


#include &lt;bits/stdc++.h&gt;
const int mod = 1e9 + 7;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
    std::freopen(&quot;isn.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;isn.out&quot;, &quot;w&quot;, stdout);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n;
    std::cin &gt;&gt; n;
    std::vector&lt;int&gt; a(n + 1), l(1);
    std::vector&lt;long long&gt; fac(n + 1), inv(n + 1);
    fac[0] = inv[0] = 1ll;
    for (int i = 1; i &lt;= n; ++i) &#123;
        std::cin &gt;&gt; a[i], l.push_back(a[i]);
        fac[i] = fac[i - 1] * i % mod;
    &#125;
    auto qkp = [](long long x, int y) &#123;
        auto res(1ll);
        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)
            if (y &amp; 1)
                (res *= x) %= mod;
        return res;
    &#125;;
    inv[n] = qkp(fac[n], mod - 2);
    for (int i = n - 1; i; --i)
        inv[i] = inv[i + 1] * (i + 1) % mod;
    auto C = [&amp;](int n, int m) &#123;
        return fac[n] * inv[m] % mod * inv[n - m] % mod;
    &#125;;
    std::sort(l.begin(), l.end());
    l.erase(std::unique(l.begin(), l.end()), l.end());
    for (int i = 0; i &lt;= n; ++i)
        a[i] = std::lower_bound(l.begin(), l.end(), a[i]) - l.begin() + 1;
    int m = (int)l.size();
    std::vector&lt;std::vector&lt;long long&gt; &gt; bit(n + 1, std::vector&lt;long long&gt; (m + 1));
    auto lowbit = [](int x) &#123;
        return x &amp; -x;
    &#125;;
    auto add = [&amp;](int id, int x, long long v) &#123;
        for (; x &lt;= m; x += lowbit(x))
            (bit[id][x] += v) %= mod;
        return;
    &#125;;
    auto ask = [&amp;](int id, int x) &#123;
        auto res(0ll);
        for (; x; x -= lowbit(x))
            (res += bit[id][x]) %= mod;
        return res;
    &#125;;
    std::vector&lt;long long&gt; g(n + 1), h(n + 1);
    std::vector&lt;std::vector&lt;long long&gt; &gt; f(n + 1, std::vector&lt;long long&gt; (n + 1));
    add(0, a[0], 1ll), f[0][0] = 1ll;
    for (int i = 1; i &lt;= n; ++i)
        for (int j = n; j; --j) &#123;
            f[i][j] = ask(j - 1, a[i]);
            add(j, a[i], f[i][j]);
            (g[j] += f[i][j] * fac[n - j]) %= mod;
        &#125;
    auto res(0ll);
    for (int i = n; i; --i) &#123;
        h[i] = g[i];
        for (int j = i + 1; j &lt;= n; ++j)
            (h[i] += mod - h[j] * fac[j - i] % mod * C(j, i) % mod) %= mod;
        (res += h[i]) %= mod;
    &#125;
    std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;


D. ThePowers
TopCoder - 12185，原题交不了故不放链接了
https://www.becoder.com.cn/contest/6522/problem/4

给定 \(A,B\)，对于所有 \(X\le A,Y\le B\)，求 \(X^Y\) 的可能取值数量。\(A,B\le10^9\)。


考虑什么时候算重。发现当且仅当 \(x^a=y^b\)，此时记 \(a&#39;=a\div\gcd(a,b),b&#39;=b\div \gcd(a,b)\)，那么 \(t=\sqrt[a&#39;]x=\sqrt[b&#39;]y\) 为整（写成质因数乘积是易证的），则 \(x=t^b,y=t^a\)，是同一个数的不同次幂
故把 \(A\) 内所有数分组，记 \(S_x\) 表示所有 \(x\) 的次幂，其中 \(x\) 不是其他数的次幂
发现一个对于 \(&gt;\sqrt A\) 的数 \(y\)，只有可能属于 \(S_y\)，或一个 \(x\le \sqrt A\) 的 \(S_x\)。每组最多有 \(30\) 个，故扫一遍 \(\le\sqrt A\) 的数即可完成分组。
这样就只用考虑同组内的计数。即对于 \(x\) 和 \(p\le |S_x|,y\le B\)，\(x^{py}\) 有多少种取值，也即 \(py\) 有多少种取值
发现因为值域是连续的，对于一个 \(p\)，只要 \(pB\) 范围内某个数是 \(p\) 的倍数就可以取到，枚举 \([(p-1)B+1,pB]\)，对于每个 \(p\) 容斥，就需要计算 \(p\sim |S_x|\) 的每个子集，复杂度会爆炸。
对于 \(x,y\in[p,|S_x|]\)，如果 \(y\) 是 \(x\) 的倍数，就可以 skip，只在剩下的元素里枚举子集，可以代码验证一下 \(30\) 以内最多剩下 \(15\) 个数，可以接受，注意子集信息类似高维前缀和地 \(O(1)\) 求就行了


#include &lt;bits/stdc++.h&gt;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
    std::freopen(&quot;power.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;power.out&quot;, &quot;w&quot;, stdout);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    long long A, B, mx = 1ll;
    std::cin &gt;&gt; A &gt;&gt; B;
    if (A == 1) &#123;
        std::cout &lt;&lt; 1 &lt;&lt; &#39;\n&#39;;
        return 0;
    &#125;
    int cnt = 1;
    long long res = 1ll;
    for (; (mx + 1) * (mx + 1) &lt;= A; ++mx);
    std::vector&lt;int&gt; tag(mx + 1);
    for (int i = 2; i &lt;= mx; ++i)
        if (!tag[i]) &#123;
            int siz = 1;
            for (long long j = i; j &lt;= A; j *= i, ++siz)
                if (j &lt;= mx)
                    tag[j] = 1;
            cnt += --siz;
            for (int j = 1; j &lt;= siz; ++j) &#123;
                std::vector&lt;int&gt; p(&#123; j &#125;);
                for (int k = j + 1; k &lt;= siz; ++k) &#123;
                    bool flag = 1;
                    for (auto l : p)
                        if (k % l == 0) &#123;
                            flag = 0;
                            break;
                        &#125;
                    if (flag)
                        p.push_back(k);
                &#125;
                int m = (int)p.size(), s = 1 &lt;&lt; m;
                std::vector&lt;long long&gt; mul(s);
                mul[0] = 1ll;
                auto lcm = [&amp;](long long x, long long y) &#123;
                    return x / std::__gcd(x, y) * y;
                &#125;;
                for (int k = 1; k &lt; s; ++k) &#123;
                    mul[k] = lcm(p[std::__lg(k ^ ((k - 1) &amp; k))], mul[(k - 1) &amp; k]);
                    if (__builtin_popcount(k) &amp; 1)
                        res += j * B / mul[k] - (j - 1) * B / mul[k];
                    else
                        res -= j * B / mul[k] - (j - 1) * B / mul[k];
                &#125;
            &#125;
        &#125;
    res += (A - cnt) * B;
    std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;

搜索做法本质上是一样的，就不赘述了
]]></content>
      <tags>
        <tag>DP</tag>
        <tag>计数</tag>
        <tag>CDQ 分治</tag>
      </tags>
  </entry>
  <entry>
    <title>杂题选谈：log 数据结构</title>
    <url>/20250819/</url>
    <content><![CDATA[线段树、树状数组、倍增、分治（朴素分治 / CDQ / 整体二分）、平衡树、字典树、笛卡尔树
多乎哉？不多也。


题目来源：

llsw’s pdf
caijianhong /bx /bx
【笔记】数据结构选讲-李雷思问 2025.2.10
洛谷文章广场题解区搜索对应算法
自己以前的一些零散题解

找了一些有数据结构方面思维难点的题，实现难度通常不会很大，也有少许粑粑夹杂其中

# 是缺题解，* 是缺代码

线段树
维护特殊信息
金鱼草 / Curtains（区间覆盖信息）
https://www.luogu.com.cn/problem/P11536

给定 \(n\) 个区间 \([l,r]\)，给出 \(q\) 个询问，每次询问 \([L,R]\) 是否能被表示为若干 \([l,r]\) 的并集。注意不能覆盖到 \([L,R]\) 之外的点。
\(n,q\le 5\times 10^5,|V|\le 10^9\)。


题目所求等价于 check 满足 \(l\ge L\land r\le R\) 的所有区间是否能够覆盖 \([L,R]\)
这个很简单，需要区间修改的做法就不提了。可以想一下有没有只需要单点修改的做法
发现权值线段树可以维护「一段连续左端点对应区间的并」是否是连续的：
维护位于区间内的左端点最后一个覆盖到的点 \(rv\)（可以在区间外；发现从区间左端点到 \(rv\) 会被连续覆盖），区间内最后一个没有被覆盖到的点 \(p\)，和表示区间是否能被完整覆盖的标记 flag。pushup 是容易的。
容易发现如果我们在树上询问 \([L,R]\) 中所有左端点的 flag，无法保证参与覆盖的 \(r\le R\)。故离线下来扫描线即可。
实际上由于未知原因跑得很可能不如区间修改的方法快 TAT


#include &lt;bits/stdc++.h&gt;
const int maxn = 5e5 + 5;
struct _ &#123;
    bool flag;
    int l, r, rv, p;
&#125; t[maxn &lt;&lt; 2];
#define lt (p &lt;&lt; 1)
#define rt (lt | 1)
void pushup(int p) &#123;
    t[p].rv = std::max(t[lt].rv, t[rt].rv);
    if (!t[lt].flag) &#123;
        t[p].flag = 0;
        if (!t[rt].flag &amp;&amp; t[lt].rv &lt; t[rt].p)
            t[p].p = t[rt].p;
        else
            t[p].p = t[lt].p;
    &#125;
    else if (!t[rt].flag &amp;&amp; t[lt].rv &lt; t[rt].p)
        t[p].flag = 0, t[p].p = t[rt].p;
    else
        t[p].flag = 1, t[p].p = 0;
    return;
&#125;
void bld(int p, int l, int r) &#123;
    t[p].l = l, t[p].r = t[p].p = r;
    if (l == r)
        return;
    int mid = (l + r) &gt;&gt; 1;
    bld(lt, l, mid), bld(rt, mid + 1, r);
    return;
&#125;
void add(int p, int x, int v) &#123;
    if(t[p].l == t[p].r) &#123;
        t[p].flag = 1, t[p].p = 0;
        t[p].rv = std::max(t[p].rv, v);
        return;
    &#125;
    int mid = (t[p].l + t[p].r) &gt;&gt; 1;
    if (x &lt;= mid)
        add(lt, x, v);
    else
        add(rt, x, v);
    pushup(p);
    return;
&#125;
_ ask(int p, int l, int r) &#123;
    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r)
        return t[p];
    int mid = (t[p].l + t[p].r) &gt;&gt; 1;
    if (r &lt;= mid)
        return ask(lt, l, r);
    if (l &gt; mid)
        return ask(rt, l, r);
    auto ls(ask(lt, l, r)), rs(ask(rt, l, r));
    if (!ls.flag) &#123;
        if (!rs.flag &amp;&amp; ls.rv &lt; rs.p)
            ls.p = rs.p;
    &#125;
    else if (!rs.flag &amp;&amp; ls.rv &lt; rs.p)
        ls.flag = 0, ls.p = rs.p;
    ls.rv = std::max(ls.rv, rs.rv);
    return ls;
&#125;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n, m, q;
    std::cin &gt;&gt; m &gt;&gt; n &gt;&gt; q;
    bld(1, 1, m);
    std::vector&lt;std::vector&lt;int&gt; &gt; t(m + 1);
    for (int i = 1, l, r; i &lt;= n; ++i) &#123;
        std::cin &gt;&gt; l &gt;&gt; r;
        t[r].push_back(l);
    &#125;
    std::vector&lt;int&gt; res(q + 1);
    std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; tq(m + 1);
    for (int i = 1, l, r; i &lt;= q; ++i) &#123;
        std::cin &gt;&gt; l &gt;&gt; r;
        tq[r].emplace_back(l, i);
    &#125;
    for (int i = 1; i &lt;= m; ++i) &#123;
        for (auto l : t[i])
            add(1, l, i);
        for (auto [l, id] : tq[i])
            res[id] = ask(1, l, i).flag;
    &#125;
    for (int i = 1; i &lt;= q; ++i)
        std::cout &lt;&lt; (res[i] ? &quot;YES&quot; : &quot;NO&quot;) &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;

题日 Zapatak（哈希）
https://www.luogu.com.cn/problem/P11262

给定 \(A_{1\cdots n}\) 和 \(B_{1\cdots n}\)，给定 \(m\) 次询问，行如：

给定 \(l_1,r_1,l_2,r_2\)，问 \(A_{l_1\cdots r_1}\) 是否能通过重排，与 \(B_{l_2\cdots r_2}\) 有恰好一个元素不同。

\(n,m\le 10^5\)。


『重排』体现：不重视下标，但重视值本身的性质。
要么用主席树（这样 pushup 信息时会利用值本身的性质），要么用普通线段树 + 哈希（理论上一种哈希和就对应一种数的组合方式）。
『全等』的处理一般是哈希。
考虑主席树解决『重排』。
可以发现性质：如果区间合法，不同的位置是可以主席树上二分出来的。
换句话说，如果可以二分，那么区间合法。哈希判定全等即可。
另一个不用权值数据结构的随机化做法：给每个数随机赋权 \(0\) 或 \(1\)，每次 check 时统计区间内所有哈希和。
随机赋 100 次，要求这 100 次中，每次两个区间的差绝对值都为 0 或 1，且存在至少一个 1。本质上利用了第二种『重排』的解决方式。


#include &lt;bits/stdc++.h&gt;
const int inf = 1e9;
const int p = 1e9 + 7;
const int mod = 2e9 + 11;
const int maxn = 1e5 + 5;
const int maxm = 2e7 + 5;
struct &#123; int l, r; long long h, u; &#125; t[maxm];
int sum, tot;
#define plt t[p].l
#define prt t[p].r
#define qlt t[q].l
#define qrt t[q].r
long long qkp(long long x, int y) &#123;
    long long res = 1ll;
    for (; y; (x *= x) %= mod, y &gt;&gt;= 1)
        if (y &amp; 1)
            (res *= x) %= mod;
    return res;
&#125;
void pushup(int p) &#123;
    t[p].h = 0ll;
    if (plt)
        t[p].h = t[plt].h;
    if (prt)
        (t[p].h += t[prt].h) %= mod;
    return;
&#125;
void add(int &amp;p, int q, int l, int r, int x, long long base) &#123;
    p = ++tot, t[p] = t[q];
    if (l == r) &#123;
        (t[p].h += base) %= mod, ++t[p].u;
        return;
    &#125;
    int mid = (l + r) &gt;&gt; 1;
    if (x &lt;= mid)
        add(plt, qlt, l, mid, x, base);
    else
        add(prt, qrt, mid + 1, r, x, base);
    pushup(p);
    return;
&#125;
void ask(int p1, int q1, int p2, int q2, int l, int r) &#123;
    if (l == r) &#123;
        sum += std::abs((t[p1].u - t[q1].u) - (t[p2].u - t[q2].u));
        return;
    &#125;
    int mid = (l + r) &gt;&gt; 1;
    if ((t[t[p1].l].h + mod - t[t[q1].l].h) % mod != (t[t[p2].l].h + mod - t[t[q2].l].h) % mod) &#123;
        if (sum &lt; 2)
            ask(t[p1].l, t[q1].l, t[p2].l, t[q2].l, l, mid);
        else
            sum = inf;
    &#125;
    if ((t[t[p1].r].h + mod - t[t[q1].r].h) % mod != (t[t[p2].r].h + mod - t[t[q2].r].h) % mod) &#123;
        if (sum &lt; 2)
            ask(t[p1].r, t[q1].r, t[p2].r, t[q2].r, mid + 1, r);
        else
            sum = inf;
    &#125;
    return;
&#125;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n, m;
    std::cin &gt;&gt; n &gt;&gt; m;
    std::map&lt;int, int&gt; t;
    std::mt19937 rnd(time(nullptr));
    std::vector&lt;int&gt; a(n + 1), rt(n + 1);
    for (int i = 1; i &lt;= n; ++i) &#123;
        std::cin &gt;&gt; a[i];
        if (!t.count(a[i]))
            t[a[i]] = qkp(p, std::abs((int)(rnd())));
        add(rt[i], rt[i - 1], 0, inf, a[i], t[a[i]]);
    &#125;
    auto ask = [&amp;](int l1, int r1, int l2, int r2) &#123;
        sum = 0;
        ::ask(rt[r1], rt[l1 - 1], rt[r2], rt[l2 - 1], 0, inf);
        return (sum == 2);
    &#125;;
    for (int l1, r1, l2, r2; m--; ) &#123;
        std::cin &gt;&gt; l1 &gt;&gt; r1 &gt;&gt; l2 &gt;&gt; r2;
        std::cout &lt;&lt; (ask(l1, r1, l2, r2) ? &quot;DA&quot; : &quot;NE&quot;) &lt;&lt; &#39;\n&#39;;
        // assert(0);
    &#125;
    return 0;
&#125;

简单数据结构（带一点递推性质）
https://pjudge.ac/problem/21636

给定初始为空的多重集 \(p\), \(q\)，这两个多重集中的元素都有 \(a,b\) 两种属性。需要需要维护 \(p\) 和 \(q\) 的加点和删点操作，询问 \(\forall \,i\in p,j\in q\)，\(\max(i_x + j_x, i_y + j_y)\) 的最小值。
\(m\le 10^6,V\le 10^9\)。


考虑对不等式恒等变形，转化为偏序问题。若 \(a_{i,0}+b_{j,0}\ge a_{i,1}+b_{j,1}\)，则 \(a_{i,0}-a_{i,1}\ge b_{j,1}-b_{j,0}\)。
把 \(a\) 按照 \(a_{i,0}-a_{i,1}\) 排序、把 \(b\) 按照 \(b_{j,1}-b_{j,0}\) 排序。
要求某个时刻的答案，需要对于每一个 \(i\) 找到最小的 \(b_{j,0}\)，使得 \(b_{j,1}-b_{j,0}\) 在 \([-\infty, a_{i,0}-a_{i,1}]\) 中，同时找到最小的 \(b_{j,1}\)，使得 \(b_{j,1}-b_{j,0}\) 在 \([a_{i, 0}-a_{i,1},+\infty]\) 中。
这个带有一点递推的性质，在线段树 pushup 的时候，用左边的 \(b_{j,0}\) 结合右边的答案得到父亲的答案。

听说我之前赛时切了这题？怎么没印象。llsw 讲题的时候说要离线，但是没想到离线做法 orz

#include &lt;bits/stdc++.h&gt;
const int inf = 2e9 + 1;
struct _ &#123; long long aa, ab, ba, bb, u; int l, r, id; &#125;;
std::vector&lt;_&gt; t(1);
std::vector&lt;std::multiset&lt;long long&gt; &gt; aa(1), ab(1), ba(1), bb(1);
int tot, cnt;
#define lt t[p].l
#define rt t[p].r
void pushup(int p) &#123;
    t[p].aa = t[p].ab = t[p].ba = t[p].bb = t[p].u = inf;
    if (lt) &#123;
        t[p].u = t[lt].u;
        t[p].aa = t[lt].aa, t[p].ab = t[lt].ab, t[p].ba = t[lt].ba, t[p].bb = t[lt].bb;
    &#125;
    if (rt) &#123;
        t[p].u = std::min(t[p].u, t[rt].u);
        t[p].aa = std::min(t[p].aa, t[rt].aa);
        t[p].ab = std::min(t[p].ab, t[rt].ab);
        t[p].ba = std::min(t[p].ba, t[rt].ba);
        t[p].bb = std::min(t[p].bb, t[rt].bb);
    &#125;
    if (lt &amp;&amp; rt)
        t[p].u = std::min(&#123; t[p].u, t[lt].ba + t[rt].aa, t[lt].ab + t[rt].bb &#125;);
    return;
&#125;
int adda(int p, long long l, long long r, int x, int a, int b) &#123;
    if (!p)
        p = ++tot, t.emplace_back(), t[p].aa = t[p].ab = t[p].ba = t[p].bb = t[p].u = inf;
    if (l == r) &#123;
        if (!t[p].id)
            t[p].id = ++cnt, aa.emplace_back(), ab.emplace_back(), ba.emplace_back(), bb.emplace_back();
        int id = t[p].id;
        aa[id].insert(a), ab[id].insert(b);
        t[p].aa = *aa[id].begin(), t[p].ab = *ab[id].begin();
        if (!aa[id].empty() &amp;&amp; !ba[id].empty())
            t[p].u = std::min(*aa[id].begin() + *ba[id].begin(), *ab[id].begin() + *bb[id].begin());
        else
            t[p].u = inf;
        return p;
    &#125;
    long long mid = (l + r) &gt;&gt; 1;
    if (x &lt;= mid) &#123;
        auto s(adda(lt, l, mid, x, a, b));
        lt = s;
    &#125;
    else &#123;
        auto s(adda(rt, mid + 1, r, x, a, b));
        rt = s;
    &#125;
    pushup(p);
    return p;
&#125;
int addb(int p, long long l, long long r, int x, int a, int b) &#123;
    if (!p)
        p = ++tot, t.emplace_back(), t[p].aa = t[p].ab = t[p].ba = t[p].bb = t[p].u = inf;
    if (l == r) &#123;
        if (!t[p].id)
            t[p].id = ++cnt, aa.emplace_back(), ab.emplace_back(), ba.emplace_back(), bb.emplace_back();
        int id = t[p].id;
        ba[id].insert(a), bb[id].insert(b);
        t[p].ba = *ba[id].begin(), t[p].bb = *bb[id].begin();
        if (!aa[id].empty() &amp;&amp; !ba[id].empty())
            t[p].u = std::min(*aa[id].begin() + *ba[id].begin(), *ab[id].begin() + *bb[id].begin());
        else
            t[p].u = inf;
        return p;
    &#125;
    long long mid = (l + r) &gt;&gt; 1;
    if (x &lt;= mid) &#123;
        auto s(addb(lt, l, mid, x, a, b));
        lt = s;
    &#125;
    else &#123;
        auto s(addb(rt, mid + 1, r, x, a, b));
        rt = s;
    &#125;
    pushup(p);
    return p;
&#125;
void dela(int p, long long l, long long r, int x, int a, int b) &#123;
    if (l == r) &#123;
        int id = t[p].id;
        aa[id].erase(aa[id].find(a)), ab[id].erase(ab[id].find(b));
        t[p].aa = (aa[id].empty() ? inf : *aa[id].begin());
        t[p].ab = (ab[id].empty() ? inf : *ab[id].begin());
        if (!aa[id].empty() &amp;&amp; !ba[id].empty())
            t[p].u = std::min(*aa[id].begin() + *ba[id].begin(), *ab[id].begin() + *bb[id].begin());
        else
            t[p].u = inf;
        return;
    &#125;
    long long mid = (l + r) &gt;&gt; 1;
    if (x &lt;= mid)
        dela(lt, l, mid, x, a, b);
    else
        dela(rt, mid + 1, r, x, a, b);
    pushup(p);
    return;
&#125;
void delb(int p, long long l, long long r, int x, int a, int b) &#123;
    if (l == r) &#123;
        int id = t[p].id;
        ba[id].erase(ba[id].find(a)), bb[id].erase(bb[id].find(b));
        t[p].ba = (ba[id].empty() ? inf : *ba[id].begin());
        t[p].bb = (bb[id].empty() ? inf : *bb[id].begin());
        if (!aa[id].empty() &amp;&amp; !ba[id].empty())
            t[p].u = std::min(*aa[id].begin() + *ba[id].begin(), *ab[id].begin() + *bb[id].begin());
        else
            t[p].u = inf;
        return;
    &#125;
    long long mid = (l + r) &gt;&gt; 1;
    if (x &lt;= mid)
        delb(lt, l, mid, x, a, b);
    else
        delb(rt, mid + 1, r, x, a, b);
    pushup(p);
    return;
&#125;
#undef lt
#undef rt
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
    std::freopen(&quot;set.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;set.out&quot;, &quot;w&quot;, stdout);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int q, rt = 0;
    std::cin &gt;&gt; q;
    for (int i = 1; i &lt;= q; ++i) &#123;
        int op, d, a, b;
        std::cin &gt;&gt; op &gt;&gt; d &gt;&gt; a &gt;&gt; b;
        if (op == 0 &amp;&amp; d == 0)
            dela(rt, -inf, inf, a - b, a, b);
        else if (op == 0)
            delb(rt, -inf, inf, b - a, a, b);
        else if (d == 0)
            rt = adda(rt, -inf, inf, a - b, a, b);
        else
            rt = addb(rt, -inf, inf, b - a, a, b);
        std::cout &lt;&lt; (t[1].u == inf ? -1 : t[1].u) &lt;&lt; &#39;\n&#39;;
    &#125;
    return 0;
&#125;


# 命运（利用线段树的分治结构递推）
https://www.luogu.com.cn/problem/P6773

* 对数据结构的爱（维护函数）
https://www.luogu.com.cn/problem/P5609

给定长度为 \(n\) 的数组 \(a\) 和模数 \(p\)（\(a_i\) 初始可能比 \(p\) 大很多，还有可能为负），给定 \(m\) 次询问，每次问区间 \([l,r]\)，进行这样的操作：
初始 \(sum=0\)，从 \(l\) 到 \(r\)，依次令 \(sum\gets sum+a_i\)，当且仅当 \(sum\ge p\) 时令 \(sum\gets sum-p\)（注意这不是取模，减完之后还是可能 \(\ge p\)）。
问最终 \(sum\) 的值。\(n\le 10^6,m\le 2\times 10^5\)。

考虑线段树维护函数。定义 \(f(x)\) 表示区间上想要减去 \(x\) 次 \(p\) 需要的最小初始值（这样才能让定义域和区间长有关），查询时直接二分即可；考虑初始化时如何合并。
首先思考较为暴力的做法，对于左侧点 \(a\) 和右侧点 \(b\)，若 \(f(a+1)-1+s_l-a\cdot p\ge f(b)\)，也即可以减去 \(a+b\) 次，就可以用 \(\max(f(a),f(b)-s_l+a\cdot p)\) 来更新 \(f(a+b)\)。
发现 \((a,b)\) 的贡献一定小于 \((a+1,b-1)\) 的贡献；具体地，发现 \(f(x+1)-f(x)\ge p\) 后就很显然了。采用双指针，优先移动 \(b\)，就能把最短区间扫一遍。

关于线段树维护函数
维护一个函数，形如 \(f_{[l,r]}(x)\) 表示在 \([l,r]\) 区间上，\(x\) 的一个映射
如果相邻区间的函数可以用某种方式合并，就可以用线段树来维护
把树建在值域上，就可以在节点内把这段区间每个点对应的函数值存下来。一般来说是静态的，因为这是一个类前缀和的形式，没办法修改
每个点的点值数组会在当前层被扫一遍，上一层被扫一遍，如果合并能够做到线性，总复杂度就是单 \(\log\) 的。
实际情形下函数本身可能很隐秘、很抽象，怎么优化到线性合并也不太好想


* COmPoUNdS（模意义下问题）
https://www.luogu.com.cn/problem/P12389

给定常数模数，维护模意义下的区间加、区间哈希（即判断两段区间是否全等）。\(n\le 10^6\)。


线段树哈希是可以维护区间加的，但是没办法维护区间取模
类似 ABC419E 里面用到的，模意义下序列全等可以转化成差分全等，区间修改就可以简化成单点修改了
额外判一下开头的元素（维护原数组或者是差分数组之和）是否相等就可以了


* 改进代码（模意义下问题）
https://www.luogu.com.cn/problem/P4635

给定序列 \(a_{1\sim n}\) 和常数 \(p\)，维护:

修改：模 \(p\) 意义下区间加；
询问：区间中 \(\sum\limits_{i=l}^{r-1}[a_i&gt;a_{i+1}]\)。

\(n\le 10^5,p\le 10^6\)。

询问也和模意义差分有关系，假如 \(s\) 为当前差分数组前缀和模 \(p\) 的值（也就是原数），发现前一个数 \(&gt;\) 后一个数当且仅当 \(s\) 加爆了。维护原数组用来确定 \(s\) 的初值。再维护区间内差分数组之和（不取模），在这个和里有多少个 \(p\) 就会爆多少次。
黑白树（很新的东西）
https://www.becoder.com.cn/problem/46907

以楼房重建为代表的 \(\log^2\) 一类前缀信息维护
特点：pushup 时需要先获得一边的信息，在另一边进行线段树上二分，单次操作是 \(O(\log^2)\) 的
本质是一类具有单调性的前 / 后缀信息，区间对全局的贡献和区间外的信息有关，故不能直接维护对全局的贡献，只能维护区间内的答案。但由于两个子区间答案可以合并出大区间答案（通过线段树上二分得到需要的信息），所以只需要逐层向上合并就可以得到全局答案
一个名字是『线段树维护前缀信息』，感觉不很精确。log 方线段树又是什么鬼名字？兔队线段树又是谁起的（upd：疑似皎月半洒花）？更多还是叫的楼房重建线段树吧

楼房重建
https://www.luogu.com.cn/problem/P4198

给定 \(a_{1\sim n}\)，维护 \(q\) 次操作：

单点修改；
查询 \(\dfrac{a_i}i\) 的前缀最大值序列长度。

\(n,q\le 10^5\)。

Fractures 说当年（初一）是他力荐 gm 给我们拉这个题的。dashena！

线段树维护单调栈，或者说前缀最值，维护方式过于经典，使得『楼房重建』成为该 trick 称呼之一
考虑 pushup。保留左边整段区间，对于左区间序列末的元素 l.rv，我们在右区间内找到第一个大于之的元素 \(x\)，从它开始的序列就是答案。
反证法易得 \(x\) 一定在右区间答案序列内：若 \(x\) 不在答案序列内，则右区间内存在一个 \(&gt;x\) 且位于 \(x\) 之前的元素，那么 \(x\) 就不是第一个 &gt; l.rv 的元素，矛盾。
故在右区间中二分能够接上去的区间长度，加起来即可。
题目只要求总区间答案，故不需要查询。动态开点可能需要小心处理一下。


#include &lt;bits/stdc++.h&gt;
const int maxn = 1e5 + 5;
struct &#123;
    int l, r, u;
    double lv, rv, mv;
&#125; t[maxn &lt;&lt; 2];
int tot;
#define lt t[p].l
#define rt t[p].r
int askt(int p, int l, int r, double v) &#123;
    if (l == r)
        return t[p].u;
    int mid = (l + r) &gt;&gt; 1;
    if (lt &amp;&amp; t[p].mv &gt; v)
        return t[p].u - t[lt].u + askt(lt, l, mid, v);
    return askt(rt, mid + 1, r, v);
&#125;
void pushup(int p, int l, int r) &#123;
    t[p].mv = t[lt].rv;
    if (lt &amp;&amp; rt) &#123;
        t[p].lv = t[lt].lv;
        t[p].rv = std::max(t[lt].rv, t[rt].rv);
        if (t[lt].rv &lt; t[rt].lv)
            t[p].u = t[lt].u + t[rt].u;
        else if (t[lt].rv &gt;= t[rt].rv)
            t[p].u = t[lt].u;
        else &#123;
            int mid = (l + r) &gt;&gt; 1;
            t[p].u = t[lt].u + askt(rt, mid + 1, r, t[lt].rv);
        &#125;
    &#125;
    else &#123;
        t[p].u = t[lt + rt].u;
        t[p].lv = t[lt + rt].lv, t[p].rv = t[lt + rt].rv;
    &#125;
    return;
&#125;
void upd(int &amp;p, int l, int r, int x, double v) &#123;
    if (!p)
        p = ++tot;
    if (l == r) &#123;
        t[p].lv = t[p].rv = v, t[p].u = 1;
        return;
    &#125;
    int mid = (l + r) &gt;&gt; 1;
    if (x &lt;= mid)
        upd(lt, l, mid, x, v);
    else
        upd(rt, mid + 1, r, x, v);
    pushup(p, l, r);
    return;
&#125;
#undef lt
#undef rt
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;P4198_2.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n, m, rt = 0;
    std::cin &gt;&gt; n &gt;&gt; m;
    std::vector&lt;double&gt; a(n + 1);
    for (int x; m--; ) &#123;
        double y;
        std::cin &gt;&gt; x &gt;&gt; y;
        a[x] = y / x;
        upd(rt, 1, n, x, y / x);
        std::cout &lt;&lt; t[1].u &lt;&lt; &#39;\n&#39;;
    &#125;
    return 0;
&#125;


二叉搜索树
https://pjudge.ac/problem/21889

给定一个大小为 \(n\) 的树，树上每个元素是一个 BST，你需要维护 \(q\) 次操作：

对于树上的一条路径 \((u,v)\)，在经过的所有节点上的 BST 插入 \(x\)，保证任意时刻 BST 中无相同值
在点 \(u\) 查找 \(x\)，如果 \(x\) 存在则返回其到 BST 根的元素和，否则返回查找时最远走到的那个点，到 BST 根的元素和。

\(n,q\le 2\times 10^5\)。


考虑链上问题。差分，把更新 \([l, r]\) 看作在差分数组 \(l\) 处插入，在 \(r+1\) 处删除，离线下来再从左到右扫一遍操作就能更新。
考虑查询。\(i\) 树上存在过的所有元素是已知的，考虑如何基于此获取 \(i\) 树上 \(t_0\) 时刻，\(x\) 的所有祖先。
对于比 \(x\) 大的元素，考虑祖先 \(p_a\) 和非祖先 \(p\) 的区别：
根据 BST 的性质易得，对于最低的右侧祖先 \({p_a}_0\)，其是 \(\ge x\) 的最小的元素（加入时刻 \(t_a&lt;t_0\)）；
同理可以找到 \({p_a}_0\) 右侧最低的祖先（其左侧的祖先显然也在 \(x\) 左侧），该祖先满足 \(t&lt;t_a\)。从左右两边分别得到 \(x\) 的所有祖先。容易证明该过程对于不在树上的 \(x\) 也是正确的。
具体地，需要能够求出 \(\ge x\) 的元素中，以 \(t_0\) 为起点的前缀最小值序列的区间和。线段树维护单调栈容易解决不带 \(t_0\) 限制的答案；再次利用性质就能满足限制。
对于树的情况，把差分放到树上，线段树合并即可。


#include &lt;bits/stdc++.h&gt;
const int lim = 2e5;
const int maxn = 2e7 + 5;
const int inf = 0x3f3f3f3f;
struct &#123;
    int l, r, rv;
    long long u;
&#125; t[maxn];
std::vector&lt;int&gt; tr;
#define lt t[p].l
#define rt t[p].r
int newnode(void) &#123;
    static int tot = 0;
    if (tr.empty())
        return ++tot;
    auto p(tr.back());
    t[p].l = t[p].r = 0;
    tr.pop_back();
    return p;
&#125;
long long askv(int p, int l, int r, int v) &#123;
    if (l == r)
        return t[p].rv &lt; v ? t[p].u : 0;
    int mid = (l + r) &gt;&gt; 1;
    if (v &gt; t[lt].rv)
        return t[p].u - t[lt].u + askv(lt, l, mid, v);
    return askv(rt, mid + 1, r, v);
&#125;
void pushup(int p, int l, int r) &#123;
    t[p].rv = std::min(t[lt].rv, t[rt].rv);
    int mid = (l + r) &gt;&gt; 1;
    t[p].u = t[lt].u + askv(rt, mid + 1, r, t[lt].rv);
    return;
&#125;
void upd(int &amp;p, int l, int r, int x, int v, int u) &#123;
    if (!p)
        p = newnode();
    if (l == r) &#123;
        t[p].rv = v, t[p].u = u;
        return;
    &#125;
    int mid = (l + r) &gt;&gt; 1;
    if (x &lt;= mid)
        upd(lt, l, mid, x, v, u);
    else
        upd(rt, mid + 1, r, x, v, u);
    pushup(p, l, r);
    return;
&#125;
void merge(int &amp;p, int q, int l, int r) &#123;
    if (!p || !q) &#123;
        p += q;
        return;
    &#125;
    if (l == r) &#123;
        t[p].rv = std::min(t[p].rv, t[q].rv);
        t[p].u = std::max(t[p].u, t[q].u);
        return;
    &#125;
    int mid = (l + r) &gt;&gt; 1;
    merge(t[p].l, t[q].l, l, mid), merge(t[p].r, t[q].r, mid + 1, r);
    pushup(p, l, r), tr.push_back(q);
    return;
&#125;
int qv = inf;
long long ask(int p, int l, int r, int ql, int qr) &#123;
    if (ql &lt;= l &amp;&amp; r &lt;= qr) &#123;
        auto s(askv(p, l, r, qv));
        qv = std::min(qv, t[p].rv);
        return s;
    &#125;
    int mid = (l + r) &gt;&gt; 1;
    long long res = 0ll;
    if (ql &lt;= mid)
        res = ask(lt, l, mid, ql, qr);
    if (qr &gt; mid)
        res += ask(rt, mid + 1, r, ql, qr);
    return res;
&#125;
#undef lt
#undef rt
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;ex_problem4.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n, m;
    std::cin &gt;&gt; n &gt;&gt; m;
    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);
    for (int i = 1, x, y; i &lt; n; ++i) &#123;
        std::cin &gt;&gt; x &gt;&gt; y;
        g[x].push_back(y), g[y].push_back(x);
    &#125;
    std::vector&lt;int&gt; top(n + 1), fa(n + 1), siz(n + 1), son(n + 1), dep(n + 1);
    std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int faa) &#123;
        siz[x] = 1;
        for (auto i : g[x])
            if (i != faa) &#123;
                fa[i] = x, dep[i] = dep[x] + 1;
                DFS(i, x), siz[x] += siz[i];
                if (siz[i] &gt; siz[son[x]])
                    son[x] = i;
            &#125;
        return;
    &#125;;
    DFS(1, -1);
    DFS = [&amp;](int x, int topp) &#123;
        top[x] = topp;
        if (son[x])
            DFS(son[x], topp);
        for (auto i : g[x])
            if (i != fa[x] &amp;&amp; i != son[x])
                DFS(i, i);
        return;
    &#125;;
    DFS(1, 1);
    auto getLCA = [&amp;](int x, int y) &#123;
        for (; top[x] != top[y]; x = fa[top[x]])
            if (dep[top[y]] &gt; dep[top[x]])
                std::swap(x, y);
        return (dep[x] &lt; dep[y] ? x : y);
    &#125;;
    std::vector&lt;std::vector&lt;int&gt; &gt; d(n + 1);
    std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; u(n + 1);
    std::vector&lt;std::vector&lt;std::tuple&lt;int, int, int&gt; &gt; &gt; q(n + 1);
    int cnt = 0;
    for (int i = 1; i &lt;= m; ++i) &#123;
        int op;
        std::cin &gt;&gt; op;
        if (op == 0) &#123;
            int x, v;
            std::cin &gt;&gt; x &gt;&gt; v;
            q[x].emplace_back(++cnt, i, v);
        &#125; else &#123;
            int x, y, v;
            std::cin &gt;&gt; x &gt;&gt; y &gt;&gt; v;
            int faa = getLCA(x, y);
            u[x].emplace_back(i, v), u[y].emplace_back(i, v);
            if (fa[faa])
                d[fa[faa]].emplace_back(v);
        &#125;
    &#125;
    std::vector&lt;long long&gt; res(cnt + 1);
    std::vector&lt;std::vector&lt;int&gt; &gt; rt(2, std::vector&lt;int&gt; (n + 1));
    t[0].rv = inf;
    DFS = [&amp;](int x, int fa) &#123;
        for (auto i : g[x])
            if (i != fa) &#123;
                DFS(i, x);
                merge(rt[0][x], rt[0][i], 1, lim);
                merge(rt[1][x], rt[1][i], 1, lim);
            &#125;
        for (auto [t, v] : u[x]) &#123;
            upd(rt[0][x], 1, lim, v, t, v);
            upd(rt[1][x], 1, lim, lim - v + 1, t, v);
        &#125;
        for (auto v : d[x]) &#123;
            upd(rt[0][x], 1, lim, v, inf, 0);
            upd(rt[1][x], 1, lim, lim - v + 1, inf, 0);
        &#125;
        for (auto [id, t, v] : q[x]) &#123;
            qv = t, res[id] = ask(rt[0][x], 1, lim, v, lim);
            qv = t, res[id] += ask(rt[1][x], 1, lim, lim - v + 1, lim);
            qv = t, res[id] -= ask(rt[0][x], 1, lim, v, v);
        &#125;
    &#125;;
    DFS(1, -1);
    for (int i = 1; i &lt;= cnt; ++i)
        std::cout &lt;&lt; res[i] &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;


Nastya and CBS
https://www.luogu.com.cn/problem/CF1340F

给定长度为 \(n\) 的括号序列，由 \(k\) 种括号对（\(-i,i\) 表示第 \(i\) 种左、右括号）组成，你需要维护单点修改元素、区间查询是否为合法括号序列。
\(1\le k\le n\le 10^5,q\le 10^5\)。


考虑不带修且允许 \(O(n)\) 询问的情景，经典题，扫一遍，用栈维护即可；
\(k=1\) 时是线段树经典题，可以类比这个经典题，从刻画合法的条件入手。
如果存在相邻且可以匹配的可以直接消掉，一直重复这样的操作，此时要么包含不能匹配的子串，如 &#123;[)&#125;，要么是 )]&#125; (&#123;[&#123;&#123; 的形式。
考虑怎么 pushup，发现中间生成的一段 ([()]) 必须完全匹配，消掉它们之后，大区间又变成 )]&#125; (&#123;[&#123;&#123; 的形式。
每次 pushup 要合并的区间很长，考虑怎么快速地做『消除相邻匹配括号』这一步。容易想到记录一段括号（例：([&#123;）及其对应反括号（例：&#125;])）的哈希值，check 是否相等，然后就可以不管它们了，并不是真的要删去。
线段树不能维护每个前后缀的哈希值，但需要的只是在删除连续匹配括号后长度为 \(len\) 的哈希值，可以线段树上二分。
这个过程有点困难，需要在询问的同时匹配、消除；但发现所谓消除就是对位相减，注意一下什么时候移位，还是好写的。
询问看似不太可做，因为中途的答案不是线段树的节点；如果把询问看成一次修改，就可以用类似可持久化的方式实现。
由于并不是真的要可持久化，询问新建的点可以重复利用。如果不重复利用，每次询问最多新建 \(O(\log n)\) 个点，空间复杂度 \(O(q\log n)\)，在 CF 上有点卡，也是能过的。


Hint：有卡 998244353 的 Hack，故可以用 1e9 + 7 当模数；WA on 7 是正确性有巨大问题，WA on 8 可能是 long long 没开完 / 数组开小了 / 哈希方向有问题 / 线段树上二分写挂了（通常是消括号消错了）。前人踩坑后人嘲笑。
#include &lt;bits/stdc++.h&gt;
const int mod = 1e9 + 7;
const int base = 1e5 + 3;
const int maxn = 7e5 + 5;
struct Node &#123;
    bool flag;
    long long hr0, hl1;
    int l, r, lc, rc, ll, rl;
    Node&amp; operator= (const Node &amp;q) &#123;
        flag = q.flag, hr0 = q.hr0, hl1 = q.hl1;
        l = q.l, r = q.r, ll = q.ll, rl = q.rl;
        return *this;
    &#125;
    Node operator+ (const Node &amp;q) const;
&#125; t[maxn &lt;&lt; 2];
int tot;
int a[maxn];
long long bpow[maxn], inv[maxn];
long long askhl1(const Node &amp;p, int k) &#123;
    if (k == 0)
        return 0ll;
    if (k &gt; p.ll)
        return -1ll;
    if (p.ll == k)
        return p.hl1;
    int ll = t[p.lc].ll, rl = t[p.lc].rl;
    if (ll &gt;= k)
        return askhl1(t[p.lc], k);
    k -= ll, k += rl;
    auto hl1 = askhl1(t[p.rc], k);
    hl1 = ((hl1 + mod - t[p.lc].hr0) * inv[rl] % mod * bpow[ll] % mod + t[p.lc].hl1) % mod;
    return hl1;
&#125;
long long askhr0(const Node &amp;p, int k) &#123;
    if (k == 0)
        return 0ll;
    if (k &gt; p.rl)
        return -1ll;
    if (p.rl == k)
        return p.hr0;
    int rl = t[p.rc].rl, ll = t[p.rc].ll;
    if (rl &gt;= k)
        return askhr0(t[p.rc], k);
    k -= rl, k += ll;
    auto hr0 = askhr0(t[p.lc], k);
    hr0 = ((hr0 + mod - t[p.rc].hl1) * inv[ll] % mod * bpow[rl] % mod + t[p.rc].hr0) % mod;
    return hr0;
&#125;
Node Node::operator+ (const Node &amp;q) const  &#123;
    Node res;
    res.l = l, res.r = q.r;
    if (flag || q.flag)
        res.flag = 1;
    else &#123;
        if (rl == q.ll) &#123;
            if (hr0 == q.hl1) &#123;
                res.flag = 0;
                res.ll = ll, res.rl = q.rl;
                res.hl1 = hl1, res.hr0 = q.hr0;
            &#125;
            else
                res.flag = 1;
        &#125;
        else if (rl &lt; q.ll) &#123;
            auto qhl1 = askhl1(q, rl);
            if (hr0 == qhl1) &#123;
                res.flag = 0;
                res.ll = ll + q.ll - rl, res.rl = q.rl;
                res.hl1 = ((q.hl1 + mod - qhl1) % mod * inv[rl] % mod * bpow[ll] % mod + hl1) % mod;
                res.hr0 = q.hr0;
            &#125;
            else
                res.flag = 1;
        &#125;
        else &#123;
            auto phr0 = askhr0(*this, q.ll);
            if (phr0 == q.hl1) &#123;
                res.flag = 0;
                res.ll = ll, res.rl = rl - q.ll + q.rl;
                res.hl1 = hl1;
                res.hr0 = ((hr0 + mod - phr0) % mod * inv[q.ll] % mod * bpow[q.rl] % mod + q.hr0) % mod;
            &#125;
            else
                res.flag = 1;
        &#125;
    &#125;
    return res;
&#125;
void bld(int &amp;p, int l, int r) &#123;
    p = ++tot;
    if (l == r) &#123;
        t[p].l = t[p].r = l;
        if (a[l] &lt; 0)
            t[p].ll = 1, t[p].hl1 = -a[l];
        else
            t[p].rl = 1, t[p].hr0 = a[l];
        return;
    &#125;
    int mid = (l + r) &gt;&gt; 1;
    bld(t[p].lc, l, mid), bld(t[p].rc, mid + 1, r);
    t[p] = t[t[p].lc] + t[t[p].rc];
    return;
&#125;
void add(int p, int x, int v) &#123;
    if (t[p].l == t[p].r) &#123;
        if (v &lt; 0) &#123;
            t[p].rl = 0, t[p].hr0 = 0ll;
            t[p].ll = 1, t[p].hl1 = -v;
        &#125;
        else &#123;
            t[p].ll = 0, t[p].hl1 = 0ll;
            t[p].rl = 1, t[p].hr0 = v;
        &#125;
        return;
    &#125;
    int mid = (t[p].l + t[p].r) &gt;&gt; 1;
    if (x &lt;= mid)
        add(t[p].lc, x, v);
    else
        add(t[p].rc, x, v);
    t[p] = t[t[p].lc] + t[t[p].rc];
    return;
&#125;
int ask(int p, int l, int r) &#123;
    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r)
        return p;
    int mid = (t[p].l + t[p].r) &gt;&gt; 1;
    if (r &lt;= mid)
        return ask(t[p].lc, l, r);
    if (l &gt; mid)
        return ask(t[p].rc, l, r);
    int q = ++tot;
    t[q].lc = ask(t[p].lc, l, r);
    t[q].rc = ask(t[p].rc, l, r);
    t[q] = t[t[q].lc] + t[t[q].rc];
    return q;
&#125;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, k, rt = 0;
    std::cin &gt;&gt; n &gt;&gt; k;
    bpow[0] = inv[0] = 1ll;
    auto qkp = [&amp;](long long x, int y) &#123;
        auto res(1ll);
        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)
            if (y &amp; 1)
                (res *= x) %= mod;
        return res;
    &#125;;
    inv[1] = qkp(base, mod - 2);
    for (int i = 1; i &lt;= n; ++i) &#123;
        std::cin &gt;&gt; a[i];
        bpow[i] = bpow[i - 1] * base % mod;
        if (i &gt;= 2)
            inv[i] = inv[i - 1] * inv[1] % mod;
    &#125;
    bld(rt, 1, n);
    int q;
    std::cin &gt;&gt; q;
    for (int op; q--; ) &#123;
        std::cin &gt;&gt; op;
        if (op == 1) &#123;
            int x, v;
            std::cin &gt;&gt; x &gt;&gt; v;
            add(1, x, v);
        &#125;
        else &#123;
            int l, r;
            std::cin &gt;&gt; l &gt;&gt; r;
            if ((r - l + 1) &amp; 1)
                std::cout &lt;&lt; &quot;No&quot; &lt;&lt; &#39;\n&#39;;
            else &#123;
                auto s(ask(1, l, r));
                std::cout &lt;&lt; ((!t[s].flag &amp;&amp; !t[s].ll &amp;&amp; !t[s].rl) ? &quot;Yes&quot; : &quot;No&quot;) &lt;&lt; &#39;\n&#39;;
            &#125;
        &#125;
    &#125;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;


# Hungry Cow P
https://www.luogu.com.cn/problem/P9130

# 2020牛客NOIP赛前集训营-提高组（第六场）牛半仙的妹子序列
https://www.becoder.com.cn/problem/29550 / https://ac.nowcoder.com/acm/contest/7615/D
要用自己的号登录牛客才能看到 /qd

# Organizing a Race
https://www.luogu.com.cn/problem/CF671E
这个题不太应该放在这里的，因为存在只用一只 log 的纯线段树上二分做法，用楼房重建显得有点唐了

# 转盘
https://www.luogu.com.cn/problem/P4425

# 前进四（楼房重建 ver）
https://uoj.ac/problem/515
另见 segment tree beats ver
可持久化线段树
# Card Game
https://qoj.ac/problem/8240

历史信息

一类形如『询问 \([l,r]\) 内合法子区间数量』的题目是可以考虑历史信息的
具体地，扫描线，对于每个 \(r\)，把合法的 \(l\) 答案加一
在每个 \(r\) 处查询 \([l,r]\) 的区间和就可以得出答案

铃原露露
https://www.luogu.com.cn/problem/P8528

题目形式满足树上支配对，考虑寻找支配关系
固定一个 LCA \(z\)，讨论 \(a_z\) 与 \(a_x,a_y\) 的大小关系给 \([1,a_x]\) 间的 \(l\) 带来的限制：

\(a_z\in[a_x,a_y]\)，\((x,y)\) 总是合法，无限制。
\(a_z&lt;a_x\)，对于 \(r\ge a_y\)，当 \(l\in(a_z,a_x]\) 时，\((x,y)\) 非法。
\(a_z&gt;a_y\)，当 \(r\in[a_y,a_z)\) 时，\((x,y)\) 总是非法。此时所有 \(l\in[1,a_x]\) 不可选。

发现固定 \(a_z,a_x\)，那么当 \(a_y\) 越靠近 \(a_x\) 时给出的限制越紧，反之亦然，就可以得到这样的支配关系
容易发现当 \(a_z\notin [a_x,a_y]\) 时，\((x,y)\) 不合法；故只需要在 dsu on tree 上找到 \(a_x\) 的前驱、后继并统计支配对即可
考虑询问，发现需要维护区间加、区间历史 0 个数，是好做的（这里的区间加并不对应 summary 中提到的区间加；对 0 的更新才是）。

历史标记的下传需要格外注意一下，应该只保证标记期间存在 0 的区间拥有懒标记；具体地，只应将其下传到和当前区间最小值相同的子区间（具体可以看代码），容易证明是对的。

#include &lt;bits/stdc++.h&gt;
const int maxn = 2e5 + 5;
struct node &#123;
    long long s;
    int l, r, u, c, d, d1;
    node operator+ (const node q) const &#123;
        node res;
        res.s = s + q.s;
        res.l = l, res.r = q.r;
        res.u = std::min(u, q.u);
        res.d = res.d1 = res.c = 0;
        if (u == res.u)
            res.c = c;
        if (q.u == res.u)
            res.c += q.c;
        return res;
    &#125;
&#125; t[maxn &lt;&lt; 2];
#define lt (p &lt;&lt; 1)
#define rt (lt | 1)
void bld(int p, int l, int r) &#123;
    t[p].c = r - l + 1;
    t[p].l = l, t[p].r = r;
    if (l == r)
        return;
    int mid = (l + r) &gt;&gt; 1;
    bld(lt, l, mid), bld(rt, mid + 1, r);
    return;
&#125;
void pushdown(int p) &#123;
    if (t[p].d) &#123;
        t[lt].d += t[p].d, t[lt].u += t[p].d;
        t[rt].d += t[p].d, t[rt].u += t[p].d;
        t[p].d = 0;
    &#125;
    if (t[p].d1) &#123;
        if (t[lt].u == t[p].u) &#123;
            t[lt].s += (long long)t[lt].c * t[p].d1;
            t[lt].d1 += t[p].d1;
        &#125;
        if (t[rt].u == t[p].u) &#123;
            t[rt].s += (long long)t[rt].c * t[p].d1;
            t[rt].d1 += t[p].d1;
        &#125;
        t[p].d1 = 0;
    &#125;
    return;
&#125;
void add(int p, int l, int r, int v) &#123;
    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r) &#123;
        t[p].d += v, t[p].u += v;
        return;
    &#125;
    pushdown(p);
    int mid = (t[p].l + t[p].r) &gt;&gt; 1;
    if (l &lt;= mid)
        add(lt, l, r, v);
    if (r &gt; mid)
        add(rt, l, r, v);
    t[p] = t[lt] + t[rt];
    return;
&#125;
void upd(int p, int l, int r) &#123;
    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r) &#123;
        if (!t[p].u)
            t[p].s += t[p].c, ++t[p].d1;
        return;
    &#125;
    pushdown(p);
    int mid = (t[p].l + t[p].r) &gt;&gt; 1;
    if (l &lt;= mid)
        upd(lt, l, r);
    if (r &gt; mid)
        upd(rt, l, r);
    t[p] = t[lt] + t[rt];
    return;
&#125;
long long ask(int p, int l, int r) &#123;
    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r)
        return t[p].s;
    pushdown(p);
    auto res(0ll);
    int mid = (t[p].l + t[p].r) &gt;&gt; 1;
    if (l &lt;= mid)
        res = ask(lt, l, r);
    if (r &gt; mid)
        res += ask(rt, l, r);
    return res;
&#125;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, m;
    std::cin &gt;&gt; n &gt;&gt; m;
    std::vector&lt;int&gt; a(n + 1);
    for (int i = 1; i &lt;= n; ++i)
        std::cin &gt;&gt; a[i];
    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1); 
    for (int i = 2, x; i &lt;= n; ++i)
        std::cin &gt;&gt; x, g[x].push_back(i);
    std::vector&lt;int&gt; siz(n + 1), son(n + 1);
    std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;
        siz[x] = 1;
        for (auto i : g[x]) &#123;
            DFS(i);
            siz[x] += siz[i];
            if (siz[i] &gt; siz[son[x]])
                son[x] = i;
        &#125;
        return;
    &#125;;
    DFS(1);
    std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; u1(n + 1), u2(n + 1);
    std::function&lt;void(int, int, std::set&lt;int&gt; &amp;)&gt; DFS2 = [&amp;](int col, int x, std::set&lt;int&gt; &amp;t) &#123;
        auto p = t.lower_bound(a[x]);
        if (col == -1)
            t.insert(a[x]);
        else &#123;
            if (p != t.begin()) &#123;
                int y = *std::prev(p);
                if (col &lt; y)
                    u1[a[x]].emplace_back(col + 1, y);
                else if (col &gt; a[x]) &#123;
                    u1[a[x]].emplace_back(1, y);
                    u2[col].emplace_back(1, y);
                &#125;
            &#125;
            if (p != t.end()) &#123;
                int y = *p;
                if (col &lt; a[x])
                    u1[y].emplace_back(col + 1, a[x]);
                else if (col &gt; y) &#123;
                    u1[y].emplace_back(1, a[x]);
                    u2[col].emplace_back(1, a[x]);
                &#125;
            &#125;
        &#125;
        for (auto i : g[x])
            DFS2(col, i, t);
        return;
    &#125;;
    std::function&lt;void(int, std::set&lt;int&gt; &amp;)&gt; DFS1 = [&amp;](int x, std::set&lt;int&gt; &amp;t) &#123;
        if (son[x])
            DFS1(son[x], t);
        for (auto i : g[x])
            if (i != son[x]) &#123;
                std::set&lt;int&gt; nt;
                DFS1(i, nt);
            &#125;
        t.insert(a[x]);
        for (auto i : g[x])
            if (i != son[x])
                DFS2(a[x], i, t), DFS2(-1, i, t);
        return;
    &#125;;
    &#123;
        std::set&lt;int&gt; t;
        DFS1(1, t);
    &#125;
    std::vector&lt;long long&gt; res(m + 1);
    std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; t(n + 1);
    for (int i = 1, l, r; i &lt;= m; ++i) &#123;
        std::cin &gt;&gt; l &gt;&gt; r;
        t[r].emplace_back(l, i);
    &#125;
    bld(1, 1, n);
    for (int i = 1; i &lt;= n; ++i) &#123;
        for (auto [l, r] : u1[i])
            add(1, l, r, 1);
        for (auto [l, r] : u2[i])
            add(1, l, r, -1);
        upd(1, 1, i);
        for (auto [l, id] : t[i])
            res[id] = ask(1, l, i);
    &#125;
    for (int i = 1; i &lt;= m; ++i)
        std::cout &lt;&lt; res[i] &lt;&lt; &#39;\n&#39;;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;


Prof. Pang’s sequence / TEST_90
https://www.luogu.com.cn/problem/P10822 / https://www.luogu.com.cn/problem/P9990

离线扫描线，对于当前右端点 \(r\)，记录每种数最后一次出现的位置 \(pos\)。令 \(r\) 的颜色为 1，从右到左，每碰到一个新的 \(pos\) 就切换颜色。
显然对于当前 \(r\)，应该被加一的 \(l\) 就是颜色为 1 的这些位置。
考虑更快地维护这个过程，也就是在 \(r\) 的颜色和 \(r-1\) 不同时就可以对 \([1,r)\) 做一次 flip，是可行的
在每个 \(r\) 处查询 \([l,r]\) 的区间和即可。


#include &lt;bits/stdc++.h&gt;
const int maxn = 5e5 + 5;
struct &#123;
    long long s;
    int l, r, d0, d1, df, ds, u0, u1;
&#125; t[maxn &lt;&lt; 2];
#define lt (p &lt;&lt; 1)
#define rt (lt | 1)
void pushup(int p) &#123;
    t[p].u0 = t[lt].u0 + t[rt].u0;
    t[p].u1 = t[lt].u1 + t[rt].u1;
    return;
&#125;
void pushval(int p, long long v0, long long v1, bool f) &#123;
    if (f) &#123;
        t[p].df ^= 1;
        std::swap(t[p].u0, t[p].u1);
        std::swap(t[p].d0, t[p].d1);
    &#125;
    t[p].d0 += v0, t[p].d1 += v1;
    t[p].s += t[p].u0 * v0 + t[p].u1 * v1;
    return;
&#125;
void pushdown(int p) &#123;
    pushval(lt, t[p].d0, t[p].d1, t[p].df);
    pushval(rt, t[p].d0, t[p].d1, t[p].df);
    t[p].d0 = t[p].d1 = t[p].df = 0;
    return;
&#125;
void bld(int p, int l, int r) &#123;
    t[p].l = l, t[p].r = r;
    t[p].u0 = r - l + 1;
    if (l == r)
        return;
    int mid = (l + r) &gt;&gt; 1;
    bld(lt, l, mid), bld(rt, mid + 1, r);
    return;
&#125;
void flip(int p, int l, int r) &#123;
    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r) &#123;
        pushval(p, 0, 0, 1);
        return;
    &#125;
    pushdown(p);
    int mid = (t[p].l + t[p].r) &gt;&gt; 1;
    if (l &lt;= mid)
        flip(lt, l, r);
    if (r &gt; mid)
        flip(rt, l, r);
    pushup(p);
    return;
&#125;
long long ask(int p, int l, int r) &#123;
    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r)
        return t[p].s;
    pushdown(p);
    auto res(0ll);
    int mid = (t[p].l + t[p].r) &gt;&gt; 1;
    if (l &lt;= mid)
        res = ask(lt, l, r);
    if (r &gt; mid)
        res += ask(rt, l, r);
    return res;
&#125;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n;
    std::cin &gt;&gt; n;
    std::vector&lt;int&gt; a(n + 1), la(n + 1);
    for (int i = 1; i &lt;= n; ++i)
        std::cin &gt;&gt; a[i];
    int m;
    std::cin &gt;&gt; m;
    std::vector&lt;long long&gt; res(m + 1);
    std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; u(n + 1);
    for (int i = 1, l, r; i &lt;= m; ++i) &#123;
        std::cin &gt;&gt; l &gt;&gt; r;
        u[r].emplace_back(l, i);
    &#125;
    bld(1, 1, n);
    for (int r = 1; r &lt;= n; ++r) &#123;
        flip(1, la[a[r]] + 1, r);
        pushval(1, 0, 1, 0);
        for (auto [l, id] : u[r])
            res[id] = ask(1, l, r);
        la[a[r]] = r;
    &#125;
    for (int i = 1; i &lt;= m; ++i)
        std::cout &lt;&lt; res[i] &lt;&lt; &#39;\n&#39;;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;


# 比赛
https://www.luogu.com.cn/problem/P8868

# V
https://uoj.ac/problem/164

# Cartesian Tree
https://www.luogu.com.cn/problem/CF1290E

# rprmq1
https://www.luogu.com.cn/problem/P6109

# rpfrdtzls
https://www.luogu.com.cn/problem/P9057

线段树合并
树上的线段树合并都很熟悉了，利用了线段树合并是线性的，以及 dsu on tree
不如说绝大多数线段树合并都有树上背景，因为自带合并顺序和复杂度保证
Tip：树上合并的背景下，线段树合并的表现会比主席树优秀很多，因为前者跑不满
不在树上的问题，题目可能会通过各种方式保证复杂度，比如保证每个点只会被合并一次之类

# 迁移计划 / Migration Plan
https://www.luogu.com.cn/problem/P11993

# 永无乡
https://www.luogu.com.cn/problem/P3224

# 语言
https://www.luogu.com.cn/problem/P5327

# 梦幻布丁
https://www.luogu.com.cn/problem/P3201

还有两个比较屎的 P7563 和 P7963
扫描线
离线，按照下标排序，扫一遍处理询问，就可以利用『所有更靠前的下标都以被计算过』来处理问题
不只局限于区间询问，单点的可能反而更难一点，需要发现和下标大小有关的性质
等差子序列
https://www.luogu.com.cn/problem/P2757

给定一个 \(n\) 的排列，问是否能找到 \(len\ge 3\) 的子序列，使得其是等差的。
\(n\le 5\times 10^5\)。

根据单调性，可以简化为 \(len=3\) 时的答案
也就是对于中项 \(j\)，能不能找到 \(i&lt;j&lt;k\)，使得 \(a_j-a_i=a_k-a_j\)。从下标出发，差值是不好维护的；注意到是排列，可以从值出发，转化成是否存在一个 \(d\)，使得 \(a_j-d\) 在之前出现，\(a_j+d\) 在之后出现。
利用下标『之前』和『之后』的限制，做扫描线，查看是否存在 \(d\) 使 \(a_j-d\) 出现过但是 \(a_j+d\) 没有出现过；还是因为是排列，数量只会为 \(0\) 或 \(1\)，如果非法说明 \(a_j-d\) 和 \(a_j+d\) 都是 \(0\) 或者都是 \(1\)，发现是关于 \(a_j\) 的回文，故权值线段树维护哈希，如果 \(a_j\) 两侧全部回文，说明 \(j\) 不是合法中项。

#include &lt;bits/stdc++.h&gt;
namespace fastIO &#123;
const int LEN = (1 &lt;&lt; 20);
#ifdef ONLINE_JUDGE
inline int nec(void) &#123;
    static char buf[LEN], *p = buf, *e = buf;
    if (p == e) &#123;
        e = buf + fread(buf, 1, LEN, stdin);
        if (e == buf)
            return EOF;
        p = buf;
    &#125;
    return *p++;
&#125;
#else
#define nec getchar
#endif
inline bool read(int &amp;x) &#123;
    x = 0;
    bool f = 0;
    char ch = nec();
    while (ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123;
        if (ch == EOF)
            return 0;
        if (ch == &#39;-&#39;)
            f = 1;
        ch = nec();
    &#125;
    while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) &#123;
        x = x * 10 + ch - &#39;0&#39;;
        ch = nec();
    &#125;
    if (f)
        x = -x;
    return 1;
&#125;
void print(int x) &#123;
    if (x &lt; 0) &#123;
        putchar(&#39;-&#39;);
        x = -x;
    &#125;
    if (x &gt;= 10)
        print(x / 10);
    putchar(x % 10 + &#39;0&#39;);
    return;
&#125;
void print(int x, char ch) &#123;
    print(x);
    putchar(ch);
    return;
&#125;
&#125; // namespace fastIO
namespace XSC062 &#123;
using namespace fastIO;
#define lt (p &lt;&lt; 1)
#define rt (lt | 1)
using sc = unsigned long long;
const int p = 13331; // 0103 ¿É°®µÎÄó 
const int lim = 5e5;
const int maxn = 5e5 + 5;
struct _ &#123;
    int l, r;
    sc lh, rh;
&#125;;
int T, n;
int a[maxn];
sc base[maxn];
_ t[maxn &lt;&lt; 2];
int min(int x, int y) &#123;
    return x &lt; y ? x : y;
&#125;
int max(int x, int y) &#123;
    return x &gt; y ? x : y;
&#125;
void pushup(int p) &#123;
    int ll = t[lt].r - t[lt].l + 1;
    int rl = t[rt].r - t[rt].l + 1;
    t[p].lh = t[lt].lh * base[rl] + t[rt].lh;
    t[p].rh = t[rt].rh * base[ll] + t[lt].rh;
    return;
&#125;
void bld(int p, int l, int r) &#123;
    t[p].lh = t[p].rh = 0;
    t[p].l = l, t[p].r = r;
    if (l == r)
        return;
    int mid = (l + r) &gt;&gt; 1;
    bld(lt, l, mid);
    bld(rt, mid + 1, r);
    return;
&#125;
void upd(int p, int x, int v) &#123;
    if (t[p].l == t[p].r) &#123;
        t[p].lh = t[p].rh = v;
        return;
    &#125;
    int mid = (t[p].l + t[p].r) &gt;&gt; 1;
    if (x &lt;= mid)
        upd(lt, x, v);
    else upd(rt, x, v);
    pushup(p);
    return;
&#125;
sc qryl(int p, int l, int r) &#123;
    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r)
        return t[p].lh;
    sc ans = 0;
    int mid = (t[p].l + t[p].r) &gt;&gt; 1;
    if (l &lt;= mid)
        ans = qryl(lt, l, r);
    if (r &gt; mid) &#123;
        ans *= base[min(r, t[p].r) - mid];
        ans += qryl(rt, l, r);
    &#125;
    return ans;
&#125;
sc qryr(int p, int l, int r) &#123;
    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r)
        return t[p].rh;
    sc ans = 0;
    int mid = (t[p].l + t[p].r) &gt;&gt; 1;
    if (r &gt; mid)
        ans = qryr(rt, l, r);
    if (l &lt;= mid) &#123;
        ans *= base[mid - max(l, t[p].l) + 1];
        ans += qryr(lt, l, r);
    &#125;
    return ans;
&#125;
int main() &#123;
    read(T);
    base[0] = 1;
    for (int i = 1; i &lt;= lim; ++i)
        base[i] = base[i - 1] * p;
    while (T--) &#123;
        read(n);
        bld(1, 1, n);
        for (int i = 1; i &lt;= n; ++i)
            read(a[i]);
        for (int i = 1; i &lt;= n; ++i) &#123;
            int len = min(n - a[i], a[i] - 1);
            if (i &gt; 1) &#123;
                upd(1, a[i - 1], 1);
            &#125;
            if (len == 0)
                continue;
            int l = a[i] - len;
            int r = a[i] + len;
            if (qryl(1, l, a[i] - 1) !=
                qryr(1, a[i] + 1, r)) &#123;
                puts(&quot;Y&quot;);
                goto isSol;
            &#125;
        &#125;
        puts(&quot;N&quot;);
        isSol: ;
    &#125;
    return 0;
&#125;
&#125; // namespace XSC062
int main() &#123;
    XSC062::main();
    return 0;
&#125;

小奇的糖果
https://hydro.ac/p/bzoj-P4548

有 \(N\) 个有颜色（\(M\) 种）的点在平面上，在平面上取一条水平的线段，可以选择线段上方的所有点，也可以选择下方的所有点。找出一条线段和选取的方向，使得在选取的点不包含所有颜色的前提下，最大化选到点的数量。
\(N,M\le 10^6,|x|,|y|\le 10^9\)。

先离散化 + 按 \(y\) 排序降一维，贪心地枚举某种颜色 \(c\) 不选。考虑线段在平面最底部时的答案，取出所有颜色为 \(c\) 的点的 \(x\) 坐标，只能选择相邻的 \(x\) 之间的所有点。枚举每一对相邻的点计算答案。把线段上移，如果碰到了一个颜色为 \(c\) 的点，就说明这个点不再参与限制，删去即可，该点原前驱和后继围出来的区间就能够更新答案。用链表 / 单调栈就能很快地维护。
先枚举颜色再跑扫描线是 \(O(n^2\log n)\) 的，考虑优化。注意到数据结构里存在当前颜色没有影响，因为一定不在询问区间内。整体做扫描线，复杂度 \(O(n\log n)\)。

namespace XSC062 &#123;
using namespace fastIO;
const int maxn = 2e5 + 5;
struct _ &#123;
    int x, y, c;
    bool operator&lt; (const _ &amp;q) const &#123;
        return y &lt; q.y;
    &#125;
&#125;;
_ a[maxn];
int s[maxn], t[maxn];
int ls[maxn], rs[maxn];
int cp[maxn], cn[maxn];
int pre[maxn], nex[maxn];
std::vector&lt;int&gt; g[maxn];
int div[maxn], Bit[maxn];
int T, n, k, tot, cnt, now, res;
int max(int x, int y) &#123; return x &gt; y ? x : y; &#125;
int lowbit(int x) &#123; return x &amp; -x; &#125;
void add(int x, int v) &#123;
    for (; x &lt;= n; x += lowbit(x)) Bit[x] += v;
    return;
&#125;
int ask(int x) &#123;
    int res = 0;
    for (; x; x -= lowbit(x)) res += Bit[x];
    return res;
&#125;
int ask(int l, int r) &#123;
    if (l &gt; r) return 0;
    return ask(r) - ask(l - 1);
&#125;
int main() &#123;
//  freopen(&quot;1.in&quot;, &quot;r&quot;, stdin); 
    read(T);
    while (T--) &#123;
        read(n), read(k), now = res = 0;
        for (int i = 1; i &lt;= k; ++i) &#123;
            s[i] = ++now, t[i] = ++now;
            div[s[i]] = 0, div[t[i]] = n + 1;
            nex[s[i]] = t[i], pre[t[i]] = s[i];
            pre[s[i]] = nex[t[i]] = 0;
        &#125;
        for (int i = 1; i &lt;= n; ++i) &#123;
            read(a[i].x), read(a[i].y), read(a[i].c);
            ls[i] = a[i].x, rs[i] = a[i].y;
        &#125;
        std::sort(a + 1, a + n + 1, [&amp;](_ x, _ y) &#123; return x.x &lt; y.x; &#125;);
        std::sort(ls + 1, ls + n + 1);
        std::sort(rs + 1, rs + n + 1);
        tot = std::unique(ls + 1, ls + n + 1) - ls - 1;
        cnt = std::unique(rs + 1, rs + n + 1) - rs - 1;
        for (int i = 1; i &lt;= n; ++i) &#123;
            a[i].x = std::lower_bound(ls + 1, ls + tot + 1, a[i].x) - ls;
            a[i].y = std::lower_bound(rs + 1, rs + cnt + 1, a[i].y) - rs;
        &#125;
        for (int i = 1; i &lt;= n; ++i) &#123;
            div[++now] = a[i].x;
            add(a[i].x, 1), g[a[i].y].push_back(now);
            pre[now] = pre[t[a[i].c]], nex[pre[t[a[i].c]]] = now;
            pre[t[a[i].c]] = now, nex[now] = t[a[i].c];
        &#125;
        memcpy(cp, pre, sizeof (cp));
        memcpy(cn, nex, sizeof (cn));
        for (int i = 1; i &lt;= k; ++i) &#123;
            for (int j = s[i]; j != t[i]; j = nex[j])
                res = max(res, ask(div[j] + 1, div[nex[j]] - 1));
        &#125;
        for (int i = 1; i &lt;= n; ++i) &#123;
            for (auto j : g[i]) add(div[j], -1);
            for (auto j : g[i]) &#123;
                res = max(res, ask(div[pre[j]] + 1, div[nex[j]] - 1));
                nex[pre[j]] = nex[j], pre[nex[j]] = pre[j];
            &#125;
        &#125;
        for (int i = 1; i &lt;= n; ++i) add(a[i].x, 1);
        for (int i = n; i; --i) &#123;
            for (auto j : g[i]) add(div[j], -1);
            for (auto j : g[i]) &#123;
                res = max(res, ask(div[cp[j]] + 1, div[cn[j]] - 1));
                cn[cp[j]] = cn[j], cp[cn[j]] = cp[j];
            &#125;
        &#125;
        print(res, &#39;\n&#39;);
        for (int i = 1; i &lt;= n; ++i)
            g[i].clear(), g[i].shrink_to_fit();
    &#125;
    return 0;
&#125;
&#125; // namespace XSC062


rmscne
https://www.luogu.com.cn/problem/P7907

给定长为 \(n\) 的序列，\(q\) 次询问 \([l,r]\) 中的最短子区间 \([l&#39;,r&#39;]\)，使得其包含 \([l,r]\) 中出现的全部值。输出长度即可。
\(n,q,V\le 2\times 10^6\)。

区间里面找子区间也是扫描线经典问题。
区间种类数会有几种思路：集合哈希、前驱后继、莫队之类。PS：这个题用 ODT 可以拿到最优解
对于 \(i=1\sim n\)，依次考虑 \(i\) 作为右端点的情况。线段树维护每个 \(j\) 作为左端点时的 \(i-r_j\)，其中 \([j, r_j]\) 是与 \([j,i]\) 种类相同的最小区间。
询问的时候，只需要找到最大的 \(j&#39;\)，满足 \([j, r]\) 与 \([l, r]\) 种类相同，求 \([l, j&#39;]\) 的区间和即可。找 \(j&#39;\) 可以记录前驱后继，初始每个 \(l\) 对应的 \(j&#39;\) 就是自己。若加入了一个与 \(l\) 相同的新元素，那么 \(l\) 就不再有贡献，此时 \(l\) 的 \(j&#39;\) 就会继承 \(l+1\) 的 \(j&#39;\)，这个过程用并查集即可简单维护。

#include &lt;bits/stdc++.h&gt;
const int lim = 2e6;
const int maxn = 2e6 + 5;
const int maxm = 5e7 + 5;
const int inf = 0x3f3f3f3f;
struct &#123; int l, r, u, d; &#125; t[maxn &lt;&lt; 2];
int tot;
#define lt (p &lt;&lt; 1)
#define rt (lt | 1)
void pushdown(int p) &#123;
    if (~t[p].d) &#123;
        t[lt].d = t[rt].d = t[p].d;
        t[lt].u = t[p].d - t[lt].r + 1;
        t[rt].u = t[p].d - t[rt].r + 1;
        t[p].d = -1;
    &#125;
    return;
&#125;
void bld(int p, int l, int r) &#123;
    t[p].l = l, t[p].r = r, t[p].d = -1;
    if (l == r)
        return;
    int mid = (l + r) &gt;&gt; 1;
    bld(lt, l, mid), bld(rt, mid + 1, r);
    return;
&#125;
void upd(int p, int l, int r, int v) &#123;
    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r) &#123;
        t[p].d = v, t[p].u = v - t[p].r + 1;
        return;
    &#125;
    pushdown(p);
    int mid = (t[p].l + t[p].r) &gt;&gt; 1;
    if (l &lt;= mid)
        upd(lt, l, r, v);
    if (r &gt; mid)
        upd(rt, l, r, v);
    t[p].u = std::min(t[lt].u, t[rt].u);
    return;
&#125;
int ask(int p, int l, int r) &#123;
    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r)
        return t[p].u;
    pushdown(p);
    int mid = (t[p].l + t[p].r) &gt;&gt; 1, res = inf;
    if (l &lt;= mid)
        res = ask(lt, l, r);
    if (r &gt; mid)
        res = std::min(res, ask(rt, l, r));
    return res;
&#125;
#undef lt
#undef rt
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n, q;
    std::cin &gt;&gt; n;
    std::vector&lt;int&gt; a(n + 1), la(lim + 1), pre(n + 1), f(n + 1);
    for (int i = 1; i &lt;= n; ++i) &#123;
        std::cin &gt;&gt; a[i];
        pre[i] = la[a[i]], la[a[i]] = i, f[i] = i;
    &#125;
    std::cin &gt;&gt; q;
    std::vector&lt;int&gt; res(q + 1);
    std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; t(n + 1);
    for (int i = 1, l, r; i &lt;= q; ++i) &#123;
        std::cin &gt;&gt; l &gt;&gt; r;
        t[r].emplace_back(l, i);
    &#125;
    bld(1, 1, n);
    std::function&lt;int(int)&gt; find = [&amp;](int x) &#123;
        return x == f[x] ? x : f[x] = find(f[x]);
    &#125;;
    auto merge = [&amp;](int x, int y) &#123;
        x = find(x), y = find(y);
        f[std::min(x, y)] = std::max(x, y);
        return;
    &#125;;
    for (int r = 1; r &lt;= n; ++r) &#123;
        if (pre[r])
            merge(pre[r], pre[r] + 1);
        upd(1, pre[r] + 1, r, r);
        for (auto [l, i] : t[r])
            res[i] = ask(1, l, find(l));
    &#125;
    for (int i = 1; i &lt;= q; ++i)
        std::cout &lt;&lt; res[i] &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;


# 颜色
https://www.luogu.com.cn/problem/P4065

给定 \(n\) 个元素，每个元素有一个颜色。选择若干颜色（不能全选或全不选），问有多少种选取方案使得拥有这些颜色的点是一段连续的区间。
\(n\le 3\times 10^5\)。


线段树 + 势能
# 市场
https://loj.ac/p/6029

# Segment Tree Beats!

维护区间取 min，区间求和。

pdf P57

# Segment Tree Beats! Plus

维护区间加，区间取 min，区间求和。

pdf P60

# 最假女选手
https://loj.ac/p/6565

# Mzl loves segment tree
https://www.becoder.com.cn/problem/10203
pdf P66

# CTSN loves segment tree
https://www.luogu.com.cn/problem/U180387

# 前进四（segment tree beats ver）
https://uoj.ac/problem/515
另见 楼房重建 ver

# 基础数据结构练习题
https://uoj.ac/problem/228

# 线段树 3
https://www.luogu.com.cn/problem/P6242

# 赛格蒙特彼茨
pdf P70

# 堕天作战 TEST_98
https://www.luogu.com.cn/problem/P9069

线段树分治
# meetings 会议
https://www.luogu.com.cn/problem/P5044
# 八纵八横
https://www.luogu.com.cn/problem/P3733
笛卡尔树
一些思考方式和 trick 吧
* 由乃救爷爷
https://www.luogu.com.cn/problem/P3793

尽可能快地维护随机序列区间最值。

随机序列笛卡尔树期望深度是 \(\log\)。就可以做了。
来自 UnyieldingTrilobite 的文章：同样可以用悬线！悬线 + 分块 就可以做了。

* 情景剧（最值的性质，维护方式的取舍）
https://www.becoder.com.cn/contest/4273/problem/1

给定长度为 \(n\) 的序列 \(a_{1\sim n}\)，找到一个区间，使得 区间长度 \(\times\) 区间最大值 \(\times\) 区间最小值 最大。输出最大值。
\(n\le 10^6,V\le 10^9\)。


容易想到建笛卡尔树。这里的 最大值 和 最小值 地位相等吗？为什么？
如果我们是钦定最大值，再去最大化『最小值 \(\times\) 区间长』，好像没办法做，因为这个最大贡献没什么性质
但如果钦定最小值，能取到的最长区间就是在小根笛卡尔树上的管辖区间，显然区间越长取到的最大值也越大，直接取这里的最大值即可
所以最大值和最小值地位不等是因为，区间长和最大值大小是正相关的，所以只需要最大化区间长，最大值也就最大化了
所以在小根笛卡尔树上维护区间最大值即可


# 小蓝的好友
https://www.luogu.com.cn/problem/P2611

星白 by TTpandaS（笛卡尔树 + dsu on tree）
https://www.becoder.com.cn/contest/6517/problem/3

给定 \(n\) 的排列 \(a_{1\sim n}\)，回答 \(q\) 个询问：

给定 \([l,r]\)，是否存在 \(l\le x&lt;y\le r\)，使得：

\(a_x&lt;a_y\)，且 \(a_x\) 不为 \([x,y]\) 中最小值；
令 \(a_i\) 为 \([x, y]\) 中最小值，则 \(a_i\mid (a_x\cdot a_y)\)。


\(n\le 3\times 10^5,q\le10^6\)。


容易想到对于 \(i\) 反过来找 \([x,y]\)。如果建立小根笛卡尔树，在 \(i\) 的左边找 \(x\)、右边找 \(y\)。
一个自然的想法是对于左侧的每个 \(x\)，维护最近的合法 \(y\)；或是对于右侧的每个 \(y\)，维护最近的合法 \(x\)。
做一个 DSU on Tree，哪边区间短就维护哪边，是单 \(\log\) 的。
需要解决点内预处理，以 \(x\) 为例，对于每个 \(x\) 和当前点 \((p,l,r)\)，需要查询 \((p, r]\) 中最小的 \(y\)，使得 \(a_y\) 是 \(\dfrac {a_p}{\gcd(a_x,a_p)}\) 的倍数。离线下来扫描线，开 \(n\) 棵线段树，跑 \(n\) 次树状数组，用 \(y\) 更新所有 \(a_y\) 因数在 \(a_y\) 处的 min / max，可以在两个 log 内获得支配对类似物。
不是很理解为什么题目要再加一个偏序限制，除了增加代码量和用时外似乎并没有什么作用？
查询时直接 rmq（这里唐了写了 st 表，实际上只需要前后缀）即可。整体复杂度 \(O(n\log^2 n)\)。


#include &lt;bits/stdc++.h&gt;
const int LEN = (1 &lt;&lt; 20);
#ifdef ONLINE_JUDGE
int nec(void) &#123;
    static char buf[LEN], *p = buf, *e = buf;
    if (p == e) &#123;
        e = buf + fread(buf, 1, LEN, stdin);
        if (e == buf) return EOF;
        p = buf;
    &#125;
    return *p++;
&#125;
#else
#define nec getchar
#endif
bool read(int &amp;x) &#123;
    x = 0;
    bool f = 0;
    char ch = nec();
    while (ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123;
        if (ch == EOF) return 0;
        if (ch == &#39;-&#39;) f = 1;
        ch = nec();
    &#125;
    while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) &#123;
        x = x * 10 + ch - &#39;0&#39;;
        ch = nec();
    &#125;
    if (f) x = -x;
    return 1;
&#125;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n;
    read(n);
    std::vector&lt;std::vector&lt;int&gt; &gt; mul(n + 1);
    std::vector&lt;int&gt; a(n + 1), l(n + 1), r(n + 1), pos(n + 1);
    for (int i = 1; i &lt;= n; ++i) &#123;
        read(a[i]), pos[a[i]] = i;
        for (l[i] = i; l[i] != 1 &amp;&amp; a[i] &lt; a[l[i] - 1]; l[i] = l[l[i] - 1]);
    &#125;
    for (int i = 1; i &lt;= n; ++i) &#123;
        for (int j = i; j &lt;= n; j += i)
            mul[i].push_back(pos[j]);
        std::sort(mul[i].begin(), mul[i].end());
    &#125;
    for (int i = n; i; --i)
        for (r[i] = i; r[i] != n &amp;&amp; a[i] &lt; a[r[i] + 1]; r[i] = r[r[i] + 1]);
    struct query &#123; int id, l, r; &#125;;
    std::vector&lt;std::vector&lt;query&gt; &gt; ql(n + 1), qr(n + 1);
    for (int i = 1; i &lt;= n; ++i)
        if (i - l[i] &lt; r[i] - i)
            for (int j = l[i]; j &lt; i; ++j)
                qr[a[i] / std::__gcd(a[i], a[j])].push_back(&#123; j, i + 1, r[i] &#125;);
        else
            for (int j = i + 1; j &lt;= r[i]; ++j)
                ql[a[i] / std::__gcd(a[i], a[j])].push_back(&#123; j, l[i], i - 1 &#125;);
    std::vector&lt;int&gt; u(n + 1), rt(n + 1), bit(n + 1);
    auto lowbit = [](int x) &#123;
        return x &amp; -x;
    &#125;;
    auto add = [&amp;](int x, int v) &#123;
        for (; x &lt;= n; x += lowbit(x))
            bit[x] = v;
        return;
    &#125;;
    std::function&lt;int(int)&gt; ask = [&amp;](int x) &#123;
        int res = 0;
        for (; x; x -= lowbit(x))
            res = std::max(res, bit[x]);
        return res;
    &#125;;
    for (int fac = 1; fac &lt;= n; ++fac) &#123;
        std::sort(ql[fac].begin(), ql[fac].end(), [&amp;](query x, query y) &#123; return x.r &lt; y.r; &#125;);
        auto i = mul[fac].begin();
        for (auto [id, l, r] : ql[fac]) &#123;
            for (; i != mul[fac].end() &amp;&amp; *i &lt;= r; ++i)
                add(a[*i], *i);
            auto mx(ask(a[id]));
            if (mx &gt;= l)
                u[id] = std::max(u[id], mx);
        &#125;
        for (auto i : mul[fac])
            add(a[i], 0);
    &#125;
    bit.assign(n + 1, 0x3f3f3f3f);
    ask = [&amp;](int x) &#123;
        int res = 0x3f3f3f3f;
        for (; x; x -= lowbit(x))
            res = std::min(res, bit[x]);
        return res;
    &#125;;
    for (int fac = 1; fac &lt;= n; ++fac) &#123;
        std::sort(qr[fac].begin(), qr[fac].end(), [&amp;](query x, query y) &#123; return x.l &gt; y.l; &#125;);
        std::reverse(mul[fac].begin(), mul[fac].end());
        auto i = mul[fac].begin();
        for (auto [id, l, r] : qr[fac]) &#123;
            for (; i != mul[fac].end() &amp;&amp; *i &gt;= l; ++i)
                add(n - a[*i] + 1, *i);
            auto mn(ask(n - a[id] + 1));
            if (mn &lt;= r)
                u[mn] = std::max(u[mn], id);
        &#125;
        for (auto i : mul[fac])
            add(n - a[i] + 1, 0x3f3f3f3f);
    &#125;
    std::vector&lt;std::vector&lt;int&gt; &gt; st(20, std::vector&lt;int&gt; (n + 1));
    for (int i = 1; i &lt;= n; ++i) &#123;
        // if (u[i] != 0)
        //     printf(&quot;%d %d\n&quot;, u[i], i);
        st[0][i] = u[i];
    &#125;
    for (int j = 1; (1 &lt;&lt; j) &lt;= n; ++j)
        for (int i = 1; i + (1 &lt;&lt; j) - 1 &lt;= n; ++i)
            st[j][i] = std::max(st[j - 1][i], st[j - 1][i + (1 &lt;&lt; (j - 1))]);
    auto askmx = [&amp;](int l, int r) &#123;
        int k = std::__lg(r - l + 1);
        return std::max(st[k][l], st[k][r - (1 &lt;&lt; k) + 1]);
    &#125;;
    int q;
    read(q);
    for (int l, r; q--; ) &#123;
        read(l), read(r);
        std::cout &lt;&lt; (askmx(l, r) &gt;= l ? &quot;Yes&quot; : &quot;No&quot;) &lt;&lt; &#39;\n&#39;;
    &#125;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;


# PERIODNI
https://www.luogu.com.cn/problem/P6453

CDQ 分治
# Coloring Nodes（偏序很隐秘）
https://www.luogu.com.cn/problem/P12423

字典树
字典树作为 log 数据结构的时候，等价权值线段树，而且支持合并、分裂（权值线段树 also OK，强调一下而已）
有些情景 Trie 写起来会比权值线段树舒服一些，比如值域操作、二进制操作之类
# 异或粽子
https://www.luogu.com.cn/problem/P5283

# Friends
https://www.luogu.com.cn/problem/CF241B
]]></content>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>学习笔记：猫树</title>
    <url>/20250822/</url>
    <content><![CDATA[分治树


概念

线段树不能维护背包的原因是 pushup 复杂度太高（单次 \(O(V^2)\)）。如果确定了要询问的体积（单点 / 区间），能否降低单次合并的复杂度？
想到 贪玩蓝月 这个题，如果存在一个 \(mid\) 在询问区间内，从 \(mid\) 往两侧预处理对应的单侧前后缀答案，最后询问的时候复杂度就比较低
考虑分治，这样就可以使得对于任意一个询问，总存在一段分治区间将其包含，且分治区间的 \(mid\) 在询问内。
这样就可以单 log 预处理之后，比较快地查询。
基于这样的预处理形式，所以只能支持静态问题。
空间复杂度为 \(O(n\log n)\)，有一些降空间的实现技巧，这里不赘述
实现起来会发现很像链上的点分，也会联想到 星白，只是这个题更像是 dsu on tree。


对于树上问题，在 uoj 上翻到一个 \(O(n\log n)\) 预处理，\(O(1)\) 单次查询的做法 link
实际上并不用猫树，只需要点分树预处理，欧拉序求 LCA 即可。

A - 好吃的题目
https://www.luogu.com.cn/problem/P6240
背包合并的 单点询问 和 前缀询问 都是 \(O(V)\) 的，任意区间 是 \(O(V\log V)\) 的，也支持取模，像贪玩蓝月那样的
然后就比较板了
发现空间不太对，需要把询问离线下来，其实就是经典分治

#include &lt;bits/stdc++.h&gt;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, q;
    std::cin &gt;&gt; n &gt;&gt; q;
    std::vector&lt;int&gt; v(n + 1), w(n + 1);
    for (int i = 1; i &lt;= n; ++i)
        std::cin &gt;&gt; v[i];
    for (int i = 1; i &lt;= n; ++i)
        std::cin &gt;&gt; w[i];
    n = 1 &lt;&lt; (std::__lg(n) + 1);
    v.resize(n), w.resize(n);
    struct node &#123; int i, l, m; &#125;;
    std::vector&lt;int&gt; res(q + 1);
    std::vector&lt;std::vector&lt;std::vector&lt;node&gt; &gt; &gt; t(17, std::vector&lt;std::vector&lt;node&gt; &gt; (n + 1));
    for (int i = 1, l, r, m; i &lt;= q; ++i) &#123;
        std::cin &gt;&gt; l &gt;&gt; r &gt;&gt; m;
        if (l == r)
            res[i] = (m &gt;= v[l] ? w[l] : 0);
        else &#123;
            int d = std::__lg(l ^ r);
            t[d][r].push_back(&#123; i, l, m &#125;);
        &#125;
    &#125;
    std::vector&lt;std::array&lt;int, 201&gt; &gt; f(n + 1);
    std::function&lt;void(int, int)&gt; calc = [&amp;](int l, int r) &#123;
        int d = std::__lg(r - l + 1) - 1;
        if (l == r)
            return;
        int mid = (l + r) &gt;&gt; 1;
        calc(l, mid), calc(mid + 1, r);
        for (int i = 0; i &lt;= 200; ++i)
            f[mid][i] = (i &gt;= v[mid] ? w[mid] : 0);
        for (int i = mid - 1; i &gt;= l; --i)
            for (int j = 0; j &lt;= 200; ++j) &#123;
                f[i][j] = f[i + 1][j];
                if (v[i] &lt;= j)
                    f[i][j] = std::max(f[i][j], f[i + 1][j - v[i]] + w[i]);
            &#125;
        for (int i = 0; i &lt;= 200; ++i) &#123;
            f[mid + 1][i] = (i &gt;= v[mid + 1] ? w[mid + 1] : 0);
            for (auto [id, l, m] : t[d][mid + 1])
                if (i &lt;= m)
                    res[id] = std::max(res[id], f[mid + 1][i] + f[l][m - i]);
        &#125;
        for (int i = mid + 2; i &lt;= r; ++i)
            for (int j = 0; j &lt;= 200; ++j) &#123;
                f[i][j] = f[i - 1][j];
                if (v[i] &lt;= j)
                    f[i][j] = std::max(f[i][j], f[i - 1][j - v[i]] + w[i]);
                for (auto [id, l, m] : t[d][i])
                    if (j &lt;= m)
                        res[id] = std::max(res[id], f[i][j] + f[l][m - j]);
            &#125;
        return;
    &#125;;
    calc(0, n - 1);
    for (int i = 1; i &lt;= q; ++i)
        std::cout &lt;&lt; res[i] &lt;&lt; &#39;\n&#39;;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;


B - 子序列
https://www.luogu.com.cn/problem/P8885
规范称呼：好子序列、好子串、好整串。
考虑不含 ? 的好子串判定，朴素 DP，令 \(f_{i,0/1}\) 表示 DP 到 \(i\)，子序列末尾为 \(0/1\) 时的子序列数量奇偶性。有：
\[
f_{i,0}=\begin{cases}
f_{i-1,0}+f_{i-1,1}+1&amp;a_i=0\\
f_{i-1,0}&amp;a_i=1
\end{cases},\\f_{i,1}=\begin{cases}
f_{i-1,1}&amp;a_i=0\\
f_{i-1,0}+f_{i-1,1}+1&amp;a_i=1
\end{cases}
\]
观察发现 \(f_{0},f_{1}\) 中只有至多一个为 \(1\)。令 \(f_2\) 为一当且仅当 \(f_0,f_1\) 均不为 \(1\)。考虑 \(1\) 所在位置，建立 DFA：

如需加入 ?，转化为 NFA。注意到只关心每个点上指针数量的奇偶性，故压缩为 \({c_0,c_1,c_2}\) 记录。考虑对好子串计数。每次在 \(2\) 处加入一个新的 \(1\) 表示空串，再令所有指针移动一步，并对当前点结尾的子串数量计数，也即 \(f_{a_i}\)。即完成对好子串的计数。
考虑进一步 DP of DP，将计数变量 \(tot\) 的奇偶性放入状态。初始为 \(0,0,0,0\)，转移 \(dp_{f0,f1,f2,tot}\to dp_{f2\oplus1,f1,f0,tot\oplus f0}\)，最后在 \(*,*,*,1\) 查答案。状态数共为 \(2^4=16\)，使用 DDP 维护动态询问即可。由于矩阵略大，需要用猫树替换线段树。然后就可以得到一个会 TLE 80 的做法（注意 ? 的转移矩阵系数可能为 2）。

#include &lt;bits/stdc++.h&gt;
const int mod = 998244353;
struct mat &#123;
    long long a[16][16];
    long long* operator[] (const int q) &#123;
        return a[q];
    &#125;
    mat() &#123;
        return;
    &#125;
    mat operator* (mat &amp;q) const &#123;
        mat res;
        for (int i = 0; i &lt; 16; ++i)
            for (int k = 0; k &lt; 16; ++k) &#123;
                auto s = 0ll;
                for (int j = 0; j &lt; 16; ++j)
                    s += a[i][j] * q[j][k];
                res[i][k] = s % mod;
            &#125;
        return res;
    &#125;
    mat&amp; operator*= (mat &amp;q) &#123;
        return *this = *this * q;
    &#125;
&#125; m0, m1, ma;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    for (int f0 = 0; f0 &lt;= 1; ++f0)
        for (int f1 = 0; f1 &lt;= 1; ++f1)
            for (int f2 = 0; f2 &lt;= 1; ++f2)
                for (int tot = 0; tot &lt;= 1; ++tot) &#123;
                    m0[(f0 &lt;&lt; 3) + (f1 &lt;&lt; 2) + (f2 &lt;&lt; 1) + tot][((f2 ^ 1) &lt;&lt; 3) + (f1 &lt;&lt; 2) + (f0 &lt;&lt; 1) + (tot ^ f0)] = 1ll;
                    ma[(f0 &lt;&lt; 3) + (f1 &lt;&lt; 2) + (f2 &lt;&lt; 1) + tot][((f2 ^ 1) &lt;&lt; 3) + (f1 &lt;&lt; 2) + (f0 &lt;&lt; 1) + (tot ^ f0)] = 1LL;
                    m1[(f0 &lt;&lt; 3) + (f1 &lt;&lt; 2) + (f2 &lt;&lt; 1) + tot][(f0 &lt;&lt; 3) + ((f2 ^ 1) &lt;&lt; 2) + (f1 &lt;&lt; 1) + (tot ^ f1)] = 1ll;
                    ++ma[(f0 &lt;&lt; 3) + (f1 &lt;&lt; 2) + (f2 &lt;&lt; 1) + tot][(f0 &lt;&lt; 3) + ((f2 ^ 1) &lt;&lt; 2) + (f1 &lt;&lt; 1) + (tot ^ f1)];
                &#125;
    int n, n1;
    std::cin &gt;&gt; n;
    n1 = 1 &lt;&lt; (std::__lg(n + 1) + 1);
    std::vector&lt;char&gt; a(n + 1);
    for (int i = 1; i &lt;= n; ++i)
        std::cin &gt;&gt; a[i];
    std::vector&lt;mat&gt; f(std::vector&lt;mat&gt; (n + 1));
    auto askmat = [&amp;](char t) -&gt; mat&amp; &#123;
        if (t == &#39;0&#39;)
            return m0;
        if (t == &#39;1&#39;)
            return m1;
        return ma;
    &#125;;
    int m;
    std::cin &gt;&gt; m;
    std::vector&lt;long long&gt; res(m + 1);
    std::vector&lt;std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; &gt; u(std::__lg(n1), std::vector&lt;std::vector&lt; std::pair&lt;int, int&gt; &gt; &gt; (n + 1));
    for (int i = 1, l, r; i &lt;= m; ++i) &#123;
        std::cin &gt;&gt; l &gt;&gt; r;
        mat k;
        if (l == r) &#123;
            k = askmat(a[l]);
            auto sum(0ll);
            for (int s = 0; s &lt; 8; ++s)
                sum += k[0][(s &lt;&lt; 1) + 1];
            res[i] = sum % mod;
        &#125;
        else &#123;
            int d = std::__lg(l ^ r);
            u[d][r].emplace_back(l, i);
        &#125;
    &#125;
    std::function&lt;void(int, int)&gt; calc = [&amp;](int l, int r) &#123;
        if (l == r)
            return;
        int d = std::__lg(r - l + 1) - 1, mid = (l + r) &gt;&gt; 1;
        calc(l, mid), calc(mid + 1, r);
        if (mid &lt;= n &amp;&amp; mid) &#123;
            f[mid] = askmat(a[mid]);
            for (int i = mid - 1; i &gt;= l &amp;&amp; i; --i)
                f[i] = askmat(a[i]) * f[i + 1];
        &#125;
        if (mid + 1 &lt;= n) &#123;
            f[mid + 1] = askmat(a[mid + 1]);
            for (auto [l, id] : u[d][mid + 1]) &#123;
                auto sum(0ll);
                auto k(f[l] * f[mid + 1]);
                for (int s = 0; s &lt; 8; ++s)
                    sum += k[0][(s &lt;&lt; 1) + 1];
                res[id] = sum % mod;
            &#125;
            for (int i = mid + 2; i &lt;= r &amp;&amp; i &lt;= n; ++i) &#123;
                f[i] = f[i - 1] * askmat(a[i]);
                for (auto [l, id] : u[d][i]) &#123;
                    auto sum(0ll);
                    auto k(f[l] * f[i]);
                    for (int s = 0; s &lt; 8; ++s)
                        sum += k[0][(s &lt;&lt; 1) + 1];
                    res[id] = sum % mod;
                &#125;
            &#125;
        &#125;
        return;
    &#125;;
    calc(0, n1 - 1);
    for (int i = 1; i &lt;= m; ++i)
        std::cout &lt;&lt; res[i] &lt;&lt; &#39;\n&#39;;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;

观察 ? 的转移矩阵，发现其实很稀疏，有效边只有 28 条

那么完全可以抛弃矩阵这个概念，返璞归真用线性 DP 解决；枚举中间相接的位就可以合并。
实际上另一种更数学的理解方式是在左侧乘一个 \([1,0,0,\cdots,0]\) 就可以把左边的矩阵转化成向量；通过枚举中间相接的位，相当于在 \(mid\) 处乘一个 \([0,0,\cdots,0,1,0,\cdots,0]\) 的向量，右边的矩阵就也转化成了向量。接着，由于矩阵很稀疏，只有 28 个位置有值，故可以手动转移。
这样就可以少一个 \(O(s)\)，可以通过。

贺了 @spdarkle 的代码，但跑得没他快
@Rosmist 又在表演卡常技能了，勇夺最优解
#include &lt;bits/stdc++.h&gt;
const int mod = 998244353;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    std::vector&lt;int&gt; m0(16), m1(16);
    for (int f0 = 0; f0 &lt;= 1; ++f0)
        for (int f1 = 0; f1 &lt;= 1; ++f1)
            for (int f2 = 0; f2 &lt;= 1; ++f2)
                for (int tot = 0; tot &lt;= 1; ++tot) &#123;
                    m0[(f0 &lt;&lt; 3) + (f1 &lt;&lt; 2) + (f2 &lt;&lt; 1) + tot] = ((f2 ^ 1) &lt;&lt; 3) + (f1 &lt;&lt; 2) + (f0 &lt;&lt; 1) + (tot ^ f0);
                    m1[(f0 &lt;&lt; 3) + (f1 &lt;&lt; 2) + (f2 &lt;&lt; 1) + tot] = (f0 &lt;&lt; 3) + ((f2 ^ 1) &lt;&lt; 2) + (f1 &lt;&lt; 1) + (tot ^ f1);
                &#125;
    int n, n1;
    std::cin &gt;&gt; n;
    n1 = 1 &lt;&lt; (std::__lg(n + 1) + 1);
    std::vector&lt;char&gt; a(n + 1);
    for (int i = 1; i &lt;= n; ++i)
        std::cin &gt;&gt; a[i];
    std::vector&lt;int&gt; dp(n + 1);
    std::vector&lt;std::array&lt;int, 16&gt; &gt; f(n + 1);
    int m;
    std::cin &gt;&gt; m;
    std::vector&lt;long long&gt; res(m + 1);
    std::vector&lt;std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; &gt; u(std::__lg(n1), std::vector&lt;std::vector&lt; std::pair&lt;int, int&gt; &gt; &gt; (n + 1));
    for (int i = 1, l, r; i &lt;= m; ++i) &#123;
        std::cin &gt;&gt; l &gt;&gt; r;
        if (l != r) &#123;
            int d = std::__lg(l ^ r);
            u[d][r].emplace_back(l, i);
        &#125;
    &#125;
    std::function&lt;void(int, int)&gt; calc = [&amp;](int l, int r) &#123;
        if (l == r)
            return;
        int d = std::__lg(r - l + 1) - 1, mid = (l + r) &gt;&gt; 1;
        calc(l, mid), calc(mid + 1, r);
        for (int t = 0; t &lt; 16; ++t) &#123;
            std::array&lt;int, 16&gt; la;
            if (mid &lt;= n &amp;&amp; mid) &#123;
                std::fill(la.begin(), la.end(), 0);
                la[t] = 1ll;
                for (int i = mid; i &gt;= l &amp;&amp; i; --i) &#123;
                    std::fill(f[i].begin(), f[i].end(), 0);
                    if (a[i] != &#39;1&#39;)
                        for (int j = 0; j &lt; 16; ++j)
                            f[i][j] = la[m0[j]];
                    if (a[i] != &#39;0&#39;)
                        for (int j = 0; j &lt; 16; ++j) &#123;
                            f[i][j] += la[m1[j]];
                            if (f[i][j] &gt;= mod)
                                f[i][j] -= mod;
                        &#125;
                    dp[i] = f[i][0];
                    la = f[i];
                &#125;
            &#125;
            if (mid + 1 &lt;= n) &#123;
                std::fill(la.begin(), la.end(), 0);
                la[t] = 1ll;
                for (int i = mid + 1; i &lt;= r &amp;&amp; i &lt;= n; ++i) &#123;
                    std::fill(f[i].begin(), f[i].end(), 0);
                    if (a[i] != &#39;1&#39;)
                        for (int j = 0; j &lt; 16; ++j)
                            f[i][m0[j]] = la[j];
                    if (a[i] != &#39;0&#39;)
                        for (int j = 0; j &lt; 16; ++j) &#123;
                            f[i][m1[j]] += la[j];
                            if (f[i][m1[j]] &gt;= mod)
                                f[i][m1[j]] -= mod;
                        &#125;
                    dp[i] = 0ll;
                    for (int s = 0; s &lt; 8; ++s) &#123;
                        dp[i] += f[i][(s &lt;&lt; 1) + 1];
                        if (dp[i] &gt;= mod)
                            dp[i] -= mod;
                    &#125;
                    for (auto [l, id] : u[d][i])
                        (res[id] += (long long)dp[l] * dp[i]) %= mod;
                    la = f[i];
                &#125;
            &#125;
        &#125;
        return;
    &#125;;
    calc(0, n1 - 1);
    for (int i = 1; i &lt;= m; ++i)
        std::cout &lt;&lt; res[i] &lt;&lt; &#39;\n&#39;;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;

]]></content>
      <tags>
        <tag>猫树</tag>
        <tag>DP 套 DP</tag>
      </tags>
  </entry>
  <entry>
    <title>杂题选谈</title>
    <url>/20250824/</url>
    <content><![CDATA[不会的东西越来越多了


B. K-Set Tree
https://www.luogu.com.cn/problem/CF1691F
令 \(F_i\) 表示以 \(1\) 为根时，\(S\) 在 \(i\) 子树内的答案。则：
\[
F_u=\left(C_{siz_u}^k-\sum C_{siz_v}^k\right)\cdot siz_u+\sum F_v\\
\]
直接换根是很复杂的；把 \(\sum C_{siz_v}^k\) 记作 \(dp_u\)，把 \(\sum F_v\) 记作 \(f_u\)，那么：
\[
res=\sum(C_n^k-dp_u)\cdot n+f_u\\
\]
这样做是为了把两个和 \(v\) 有关的乘项拆开来换根，实际换根的时候就只用分别换 \(f,dp\) 两个值，不用考虑二次项等问题，计算量会少很多

#include &lt;bits/stdc++.h&gt;
const int mod = 1e9 + 7;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, k;
    std::cin &gt;&gt; n &gt;&gt; k;
    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);
    for (int i = 1, x, y; i &lt; n; ++i) &#123;
        std::cin &gt;&gt; x &gt;&gt; y;
        g[x].push_back(y), g[y].push_back(x);
    &#125;
    std::vector&lt;long long&gt; fac(n + 1), inv(n + 1);
    fac[0] = inv[0] = 1ll;
    for (int i = 1; i &lt;= n; ++i)
        fac[i] = fac[i - 1] * i % mod;
    auto qkp = [](long long x, int y) &#123;
        auto res(1ll);
        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)
            if (y &amp; 1)
                (res *= x) %= mod;
        return res;
    &#125;;
    inv[n] = qkp(fac[n], mod - 2);
    for (int i = n - 1; i; --i)
        inv[i] = inv[i + 1] * (i + 1) % mod;
    auto C = [&amp;](int n, int m) &#123;
        if (m &gt; n)
            return 0ll;
        return fac[n] * inv[m] % mod * inv[n - m] % mod;
    &#125;;
    auto res(0ll);
    std::vector&lt;int&gt; siz(n + 1), ss(n + 1);
    std::vector&lt;long long&gt; f(n + 1), dp(n + 1);
    std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int fa) &#123;
        siz[x] = 1;
        for (auto i : g[x])
            if (i != fa) &#123;
                DFS(i, x);
                (f[x] += (C(siz[i], k) - dp[i]) * siz[i] + f[i]) %= mod;
                (dp[x] += C(siz[i], k)) %= mod;
                siz[x] += siz[i];
            &#125;
        return;
    &#125;;
    DFS(1, -1);
    DFS = [&amp;](int x, int fa) &#123;
        (res += (C(n, k) - dp[x]) * n + f[x]) %= mod;
        for (auto i : g[x])
            if (i != fa) &#123;
                (f[i] += (C(n - siz[i], k) - (dp[x] - C(siz[i], k))) * (n - siz[i]) + f[x] - f[i] - (C(siz[i], k) - dp[i]) * siz[i]) %= mod;
                (dp[i] += C(n - siz[i], k)) %= mod;
                DFS(i, x);
            &#125;
        return;
    &#125;;
    DFS(1, -1);
    std::cout &lt;&lt; (res + mod) % mod &lt;&lt; &#39;\n&#39;;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;


C. Li Hua and Path
https://www.luogu.com.cn/problem/CF1797F
考虑容斥，分别求解满足 1、满足 2、满足 12（注意要减两倍）就能计算答案
发现题目所求点对形式很符合 Kruskal 重构树的要求，考虑以对应点权为边权，分别建立 min，max Kruskal 点权多叉重构树。

点权多叉重构树？
在点权上做 Kruskal 重构树时，发现边的虚点是不必要的，可以直接将更优点作为父亲。
写的时候有点难想清楚…… 可以画画图，仔细确定一下 Kruskal 重构树的具体性质
这样做的优势是没有虚点，一些问题会方便一些；但同时放弃了二叉树的结构，一些题可能没那么好做。
这道题只用经典 Kruskal 重构树也可以解决。

发现 1 2 均可以转化成两棵树在两棵树上的祖孙关系要求，可以轻松地分别统计满足 1、满足 2 的点对数量
考虑怎么处理同时满足 12 的，发现要求在两棵树上二者应该都具有祖孙关系，且是相反的。可以考虑在一棵树上 DFS 的同时用主席树存储祖先，在另一颗树上 ask
考虑从更容易用 dfn 表示的子树问题思考，在 min 树上分配 dfn 后，在 max 树上用 DFS + 回溯得到每个点实时祖先序列，存在树状数组里；ask 该点被分配的 dfn 子树区间就能得到答案。
考虑询问，由于每次加入的都是编号最大的点，对于满足 1、满足 2 的贡献是显然的，而同时满足 12 的点就是在 min 树上的祖先，都是好做的。
实现的时候一定要把 min / max 树对应的性质思考清楚，不然会很麻烦

#include &lt;bits/stdc++.h&gt;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n;
    std::cin &gt;&gt; n;
    std::vector&lt;int&gt; f1(n + 1), f2(n + 1);
    std::iota(f1.begin() + 1, f1.end(), 1);
    std::iota(f2.begin() + 1, f2.end(), 1);
    std::function&lt;int(int)&gt; find1 = [&amp;](int x) &#123;
        return x == f1[x] ? x : f1[x] = find1(f1[x]);
    &#125;;
    std::function&lt;int(int)&gt; find2 = [&amp;](int x) &#123;
        return x == f2[x] ? x : f2[x] = find2(f2[x]);
    &#125;;
    std::vector&lt;std::vector&lt;int&gt; &gt; g1(n + 1), g2(n + 1), adj1(n + 1), adj2(n + 1);
    for (int i = 1, x, y; i &lt; n; ++i) &#123;
        std::cin &gt;&gt; x &gt;&gt; y;
        if (x &gt; y)
            std::swap(x, y);
        adj1[y].push_back(x);
        adj2[x].push_back(y);
    &#125;
    for (int i = 1; i &lt;= n; ++i)
        for (auto j : adj1[i]) &#123;
            int fi = find1(i), fj = find1(j);
            g1[fi].push_back(fj), f1[fj] = fi;
        &#125;
    for (int i = n; i; --i)
        for (auto j : adj2[i]) &#123;
            int fi = find2(i), fj = find2(j);
            g2[fi].push_back(fj), f2[fj] = fi;
        &#125;
    std::vector&lt;int&gt; bit(n + 1), dfn(n + 1), rfn(n + 1);
    auto lowbit = [](int x) &#123;
        return x &amp; -x;
    &#125;;
    auto add = [&amp;](int x, int v) &#123;
        for (; x &lt;= n; x += lowbit(x))
            bit[x] += v;
        return;
    &#125;;
    auto ask = [&amp;](int x) &#123;
        int res = 0;
        for (; x; x -= lowbit(x))
            res += bit[x];
        return res;
    &#125;;
    int rt1 = 0, rt2 = 0;
    for (int i = 1; i &lt;= n; ++i) &#123;
        if (f1[i] == i)
            rt1 = i;
        if (f2[i] == i)
            rt2 = i;
    &#125;
    int q;
    std::cin &gt;&gt; q;
    std::vector&lt;int&gt; dep1(n + 1), dep2(n + q + 1);
    long long res = 0ll;
    std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;
        static int now = 0;
        dfn[x] = ++now;
        res += dep1[x];
        for (auto i : g1[x]) &#123;
            dep1[i] = dep1[x] + 1;
            DFS(i);
        &#125;
        rfn[x] = now;
        return;
    &#125;;
    DFS(rt1);
    DFS = [&amp;](int x) &#123;
        res += dep2[x];
        res -= 2 * (ask(rfn[x]) - ask(dfn[x] - 1));
        add(dfn[x], 1);
        for (auto i : g2[x]) &#123;
            dep2[i] = dep2[x] + 1;
            DFS(i);
        &#125;
        add(dfn[x], -1);
        return;
    &#125;;
    DFS(rt2);
    std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
    for (int fa; q--; ) &#123;
        std::cin &gt;&gt; fa;
        dep2[++n] = dep2[fa] + 1;
        res += (n - 1) - dep2[n];
        std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
    &#125;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;


D. 团队选拔
https://www.becoder.com.cn/contest/6534/problem/4

给定 \(a_{1\sim n}\)，从中任选一些互不相交的区间，满足每个区间内元素的 gcd 相同。
\(n\le 10^5,V\le 10^7\)。

注意到固定一个左端点后，移动右端点，gcd 每次至多减小到原来的一半；也就是说，其种类有 \(\log V\) 种。故全序列的 gcd 总数是 \(O(n\log V)\) 的。
很容易想到与此原理类似的全局答案求法：对于每个 \(i\)，向左处理出每一段 \([l,r]\)，满足 \(\gcd(a_{l\cdots i})=\gcd(a_r\cdots i)\)，并记录该 \(\gcd\)。这样求出来的 \((i,l,r)\) 共有 \(O(n\log V)\) 段。
对于每个 gcd 有 \(f_{i}=f_{i-1}+\sum\limits_{j=l_i}^{r_i} f_{j - 1}\)，可以做一个扫描线，得到全局答案；向前向后分别做到 \(i-1,i+1\)，相乘就能得到 \(i\) 未被选取时的答案
考虑怎么完成『相乘』这个动作：最后的 \(f\) 在每个右端点处发生变化，可以转化成若干段 \(f\)；反过来的 \(f&#39;\) 亦可以这样转化。将 \(f\) 整体后移一位、\(f&#39;\) 整体前移一位，就可以对齐。二者的端点总数是均摊单 log 的，区间总数也就是均摊单 log 的（归并就能快速寻找到区间），用差分做一个区间加即可。
用二分勉强单 log 解决了转移；还看到 @spdarkle 疑似在 \(1\sim n\) 上直接做的做法，和 @Rosmist 疑似直接在每个 \(i\) 上做的做法。官解是个看不懂的做法
呃，好像一不小心拿了最优解。而且优势很明显（怎么总用时比别人一个点还少？），这是为什么？
可能因为大家都看不懂官解，做法比较多样？除了我之外比较快的 lwz 和 @GoldSpade 都用归并完成最后一步；我较他们的额外优势大概是用二分换掉了树状数组？迷惑

#include &lt;bits/stdc++.h&gt;
const int mod = 998244353;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
    std::freopen(&quot;selection.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;selection.out&quot;, &quot;w&quot;, stdout);
#else
    std::freopen(&quot;ex_selection2.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n;
    std::cin &gt;&gt; n;
    std::vector&lt;int&gt; a(n + 1);
    std::vector&lt;std::vector&lt;int&gt; &gt; st(20, std::vector&lt;int&gt; (n + 1));
    for (int i = 1; i &lt;= n; ++i)
        std::cin &gt;&gt; a[i], st[0][i] = a[i];
    for (int j = 1; (1 &lt;&lt; j) &lt;= n; ++j)
        for (int i = 1; i + (1 &lt;&lt; j) - 1 &lt;= n; ++i)
            st[j][i] = std::__gcd(st[j - 1][i], st[j - 1][i + (1 &lt;&lt; (j - 1))]);
    auto askgcd = [&amp;](int l, int r) &#123;
        int k = std::__lg(r - l + 1);
        return std::__gcd(st[k][l], st[k][r - (1 &lt;&lt; k) + 1]);
    &#125;;
    std::unordered_map&lt;int, int&gt; tab;
    struct node &#123;
        int i, l, r;
        bool operator&lt; (const int q) const &#123;
            return i &lt; q;
        &#125;
        bool operator&lt;= (const int q) const &#123;
            return i &lt;= q;
        &#125;
    &#125;;
    std::vector&lt;std::vector&lt;node&gt; &gt; p1, p2;
    for (int i = 1; i &lt;= n; ++i) &#123;
        for (int to = i; to &gt;= 1; ) &#123;
            int at = i, g = askgcd(to, i);
            for (int l = 1, r = to, mid; l &lt;= r; ) &#123;
                mid = (l + r) &gt;&gt; 1;
                if (askgcd(mid, i) == g)
                    at = mid, r = mid - 1;
                else
                    l = mid + 1;
            &#125;
            if (!tab.count(g)) &#123;
                tab[g] = (int)p1.size();
                p1.emplace_back(), p2.emplace_back();
            &#125;
            p1[tab[g]].push_back(&#123; i, at, to &#125;);
            to = at - 1;
        &#125;
        for (int to = i; to &lt;= n; ) &#123;
            int at = i, g = askgcd(i, to);
            for (int l = to, r = n, mid; l &lt;= r; ) &#123;
                mid = (l + r) &gt;&gt; 1;
                if (askgcd(i, mid) == g)
                    at = mid, l = mid + 1;
                else
                    r = mid - 1;
            &#125;
            if (!tab.count(g)) &#123;
                tab[g] = (int)p2.size();
                p1.emplace_back(), p2.emplace_back();
            &#125;
            p2[tab[g]].push_back(&#123; i, to, at &#125;);
            to = at + 1;
        &#125;
    &#125;
    auto s(0ll);
    std::vector&lt;int&gt; x1(n + 1), x2(n + 2), pos(2 * n + 3);
    std::vector&lt;long long&gt; f1(n + 1), f2(n + 2), s1(n + 1), s2(n + 2), diff(n + 1);
    for (auto [g, id] : tab) &#123;
        // printf(&quot;g = %d: \n&quot;, g);
        int n1 = (int)p1[id].size();
        x1[0] = 0, f1[0] = s1[0] = 1ll;
        for (int i = 1; i &lt;= n1; ++i) &#123;
            auto [x, L, R] = p1[id][i - 1];
            --L, --R;
            x1[i] = x, f1[i] = f1[i - 1];
            int l = std::upper_bound(x1.begin() + 1, x1.begin() + i + 1, L) - x1.begin() - 1,
                r = std::upper_bound(x1.begin() + 1, x1.begin() + i + 1, R) - x1.begin() - 1;
            if (l == r)
                (f1[i] += f1[l] * (R - L + 1)) %= mod;
            else &#123;
                f1[i] += s1[r - 1] + mod - s1[l];
                f1[i] += f1[r] * (R - x1[r] + 1);
                f1[i] += f1[l] * (x1[l + 1] - L);
                f1[i] %= mod;
            &#125;
            // printf(&quot;  r = %d, l = [%d, %d]: %lld\n&quot;, x, L, R, f1[i]);
            if (i != n1)
                s1[i] = (s1[i - 1] + f1[i] * (p1[id][i].i - x)) % mod;
        &#125;
        (s += f1[n1] - 1) %= mod;
        int n2 = (int)p2[id].size();
        x2[n2 + 1] = n + 1, f2[n2 + 1] = s2[n2 + 1] = 1ll;
        for (int i = n2; i; --i) &#123;
            auto [x, L, R] = p2[id][i - 1];
            ++L, ++R;
            x2[i] = x, f2[i] = f2[i + 1];
            int l = std::lower_bound(x2.begin() + i, x2.begin() + n2 + 1, L) - x2.begin(),
                r = std::lower_bound(x2.begin() + i, x2.begin() + n2 + 1, R) - x2.begin();
            if (l == r)
                (f2[i] += f2[l] * (R - L + 1)) %= mod;
            else&#123;
                f2[i] += s2[l + 1] + mod - s2[r];
                f2[i] += f2[r] * (R - x2[r - 1]);
                f2[i] += f2[l] * (x2[l] - L + 1);
                f2[i] %= mod;
            &#125;
            // printf(&quot;  l = %d, r = [%d, %d]: %lld\n&quot;, x, L, R, f2[i]);
            if (i != 1)
                s2[i] = (s2[i + 1] + f2[i] * (x - p2[id][i - 2].i)) % mod;
        &#125;
        for (int i = 0; i &lt; n1; ++i)
            x1[i] = x1[i + 1];
        x1[n1] = n;
        int t = (x2[1] == 1) + 1;
        for (int i = 1; i &lt;= n2 + 1; ++i)
            --x2[i];
        std::merge(x1.begin(), x1.begin() + n1 + 1, x2.begin() + t, x2.begin() + n2 + 2, pos.begin() + 1);
        int m = std::unique(pos.begin() + 1, pos.begin() + n1 + n2 + 4 - t) - pos.begin() - 1;
        for (int i = 1, p1 = 0, p2 = t, la = 0; i &lt;= m; ++i) &#123;
            for (; p1 + 1 &lt;= n1 &amp;&amp; x1[p1] &lt; pos[i]; ++p1);
            for (; p2 + 1 &lt;= n2 + 1 &amp;&amp; x2[p2] &lt; pos[i]; ++p2);
            (diff[la + 1] += f1[p1] * f2[p2] + mod - 1) %= mod;
            // printf(&quot;  [%d, %d]: %lld, %lld\n&quot;, la + 1, pos[i], f1[p1], f2[p2]);
            if (pos[i] + 1 &lt;= n)
                (diff[pos[i] + 1] += mod - f1[p1] * f2[p2] + 1) %= mod;
            la = pos[i];
        &#125;
    &#125;
    // std::cout &lt;&lt; s &lt;&lt; &#39;\n&#39;;
    for (int i = 1; i &lt;= n; ++i) &#123;
        (diff[i] += diff[i - 1]) %= mod;
        std::cout &lt;&lt; (s + mod - diff[i]) % mod &lt;&lt; &#39; &#39;;
    &#125;
    std::cout &lt;&lt; &#39;\n&#39;;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;

我一开始将 \(f\) 定义为单点答案而非前缀和，会导致需要线段树维护等差序列，还丢失了答案段数不多这个性质，非常麻烦。将 \(f\) 的意义替换为前缀和后，就可以很轻松地做了。

A. 宇宙
https://www.becoder.com.cn/contest/6535/problem/1

给定 \(a_{1\sim n}\)，对于 \(k=1,2,\cdots,n-1\)，回答：

令 \(i\) 从 \(1\) 开始自增，对于每个 \(i\)，都可以选取 \(k\) 个互不相同的下标，并使它们对应的元素增加 1。此时，若存在元素不大于 \(i\)，停止。输出停止时 \(i\) 可能的最大值。

\(n\le 10^6,V\le 10^9\)。

发现不大于这个 condition 有些反人类，先将 \(a\) 全部减 1，转化成小于来考虑
考虑能坚持到 \(i\) 的一个必要条件，即 \(\sum\limits_{a_j&lt;i} i-a_j\le k\cdot i\)
容易发现该条件同时是充分的，可以朝摩尔投票思考
对 \(a\) 排序，停止时参与运算的 \(a_j\) 是越来越多的，故记录最后一个参与运算的下标，逐步挪动（当发现解出来的 \(i\) 比下一个更大时就需要挪动），同时解不等式即可。
@Quack 云我在场上能想出官解对我来说是非常了不起的（其实场上写正解的人少得出奇），我也不得不承认我能做出来确实有一定运气成分，也能从中一窥我令人眼前一黑的数学素养！

#include &lt;bits/stdc++.h&gt;
int main() &#123;
    std::freopen(&quot;universe.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;universe.out&quot;, &quot;w&quot;, stdout);
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
    int n;
    std::cin &gt;&gt; n, std::cin &gt;&gt; n;
    std::vector&lt;int&gt; a(n + 1);
    for (int i = 1; i &lt;= n; ++i)
        std::cin &gt;&gt; a[i], --a[i];
    std::sort(a.begin() + 1, a.end());
    int id = 1;
    long long s = a[1];
    for (int i = 1; i &lt; n; ++i) &#123;
        if (id &lt; i + 1)
            s += a[++id];
        long long x = s / (id - i);
        for (; id != n &amp;&amp; x &gt; a[id + 1]; s += a[++id], x = s / (id - i));
        std::cout &lt;&lt; x &lt;&lt; &#39; &#39;;
    &#125;
    std::cout &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;


B. 跳跃
https://www.becoder.com.cn/contest/6535/problem/2

给定长度为 \(n\) 的 01 序列和跳跃上限 \(k\)。给定 \(q\) 个询问，回答：

从 \(a\) 跳到 \(b\)，保证 \(a,b\) 的颜色均为 1，每次不能跳超过 \(k\) 格或跳出去，在最小化踩到 0 数量的前提下，最小化跳跃次数，输出这两个值。

\(n,q\le5\times10^5\)。

容易发现只能往一个方向跳，那么不妨令 \(a&lt;b\)。有一个贪心的想法是能往右就往右，手玩发现是对的（我场上手玩过后坚定地认为是错的；可能和没时间了兵荒马乱有关）。这样就很好想到第二问需要倍增；但把两个问结合起来考虑是有点困难的，赛时就意识到这两问的联系没有看起来那么大，甚至很可能是割裂的。
单独考虑第一问，发现对于一段长度为 \(len\) 的 0，需要踩到恰好 \(\left\lfloor\dfrac {len}k\right\rfloor\) 个 0。答案容易计算。
单独考虑第二问，考虑一个第一问答案固定为 0 的情况，也即每个 len 都比 \(k\) 小。则问题转化成在不踩 0 的情况下最小的步数。容易用倍增解决。
本题最令人印象深刻的点在于二者的结合，发现这 \(\left\lfloor\dfrac {len}k\right\rfloor\cdot k\) 个 0 是无论如何都会被经过的，所以可以在原始数组里删掉它们，转化成只考虑第二问的情况

？？？
我对于自己莫名其妙跑得比别人快一大截这件事情已经快要见怪不怪了，这次又是什么原理，我预处理写得比较漂亮吗？？
#include &lt;bits/stdc++.h&gt;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
    std::freopen(&quot;jump.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;jump.out&quot;, &quot;w&quot;, stdout);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, k, q, op;
    std::cin &gt;&gt; n, std::cin &gt;&gt; n &gt;&gt; q &gt;&gt; k &gt;&gt; op;
    std::vector&lt;int&gt; tmp(n + 1), a(1), s(1), to(n + 2);
    for (int i = 1; i &lt;= n; ++i) &#123;
        char t;
        std::cin &gt;&gt; t;
        tmp[i] = t - &#39;0&#39;;
    &#125;
    tmp.push_back(1), ++n;
    int cnt = 0;
    for (int i = 1; i &lt;= n; ++i) &#123;
        if (tmp[i] == 1) &#123;
            a.push_back(1), to[i] = (int)a.size() - 1;
            s.push_back(s.back() + cnt), cnt = 0;
        &#125;
        else &#123;
            ++cnt;
            if (i == n || tmp[i + 1] == 1) &#123;
                for (int j = 1; j &lt;= cnt % k; ++j)
                    a.push_back(0), s.push_back(s.back());
                cnt /= k;
            &#125;
        &#125;
    &#125;
    n = (int)a.size() - 1;
    std::vector&lt;std::vector&lt;int&gt; &gt; f(20, std::vector&lt;int&gt; (n + 1));
    for (int i = 0; i &lt; 20; ++i)
        f[i][n] = n;
    for (int i = n - 1; i; --i) &#123;
        f[0][i] = std::min(&#123; n, i + k, f[0][i + 1] &#125;);
        for (; !a[f[0][i]]; --f[0][i]);
        if (a[i] == 1) &#123;
            for (int j = 1; j &lt; 20; ++j)
                f[j][i] = f[j - 1][f[j - 1][i]];
        &#125;
    &#125;
    for (int a, b; q--; ) &#123;
        std::cin &gt;&gt; a &gt;&gt; b;
        if (a &gt; b)
            std::swap(a, b);
        a = to[a], b = to[b];
        std::cout &lt;&lt; s[b] - s[a];
        if (op == 1) &#123;
            int res = s[b] - s[a];
            for (int i = 19; ~i; --i)
                if (f[i][a] &lt; b)
                    a = f[i][a], res += (1 &lt;&lt; i);
            std::cout &lt;&lt; &#39; &#39; &lt;&lt; res + 1;
        &#125;
        std::cout &lt;&lt; &#39;\n&#39;;
    &#125;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;


D. Jongmah
https://codeforces.com/contest/1110/problem/D
容易发现当连续出现三次 \((i-1,i,i+1)\) 时，可以被三次相同代替；
容易发现需要使用 \(f_{i,a,b}\) 来代表 DP 到 \(i\) 时，用了 \(a\) 组 \((i-1,i,i+1)\) 和 \(b\) 组 \((i,i+1,i+2)\) 时的最大组数；
但是并没有想到要将二者结合起来！感觉应该是能比较快做出来的水平。能察觉到不太认真。悔过！

#include &lt;bits/stdc++.h&gt;
const int inf = 0x3f3f3f3f;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, m;
    std::cin &gt;&gt; n &gt;&gt; m;
    std::vector&lt;int&gt; cnt(m + 1);
    for (int i = 1, x; i &lt;= n; ++i)
        std::cin &gt;&gt; x, ++cnt[x];
    std::vector&lt;std::vector&lt;std::vector&lt;int&gt; &gt; &gt; f(m + 1, std::vector&lt;std::vector&lt;int&gt; &gt; (3, std::vector&lt;int&gt; (3, -inf)));
    f[0][0][0] = 0ll;
    for (int i = 1; i &lt;= m; ++i)
        for (int a = 0; a &lt;= 2; ++a) // i - 1, i, i + 1
            for (int b = 0; b &lt;= 2; ++b) // i, i + 1, i + 2
                for (int c = 0; c &lt;= 2; ++c) &#123; // i - 2, i - 1, i
                    if (a + b + c &gt; cnt[i]) continue;
                    f[i][a][b] = std::max(f[i][a][b], f[i - 1][c][a] + b + (cnt[i] - a - b - c) / 3);
                &#125;
    std::cout &lt;&lt; f[m][0][0] &lt;&lt; &#39;\n&#39;;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;


E. Magic Stones
https://codeforces.com/contest/1110/problem/F
容易想到考察差分数组，发现这个操作就是交换了差分数组的相邻两个元素。故对于 \(c\) 和 \(t\) 的差分数组分别排序，然后 check 是否相等即可。

#include &lt;bits/stdc++.h&gt;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n;
    std::cin &gt;&gt; n;
    std::vector&lt;int&gt; a(n + 1), b(n + 1);
    for (int i = 1; i &lt;= n; ++i)
        std::cin &gt;&gt; a[i];
    for (int i = 1; i &lt;= n; ++i)
        std::cin &gt;&gt; b[i];
    if (a[1] != b[1] || a[n] != b[n]) &#123;
        std::cout &lt;&lt; &quot;No&quot; &lt;&lt; &#39;\n&#39;;
        return 0;
    &#125;
    std::vector&lt;int&gt; da(n), db(n);
    std::adjacent_difference(a.begin() + 1, a.end(), da.begin());
    std::adjacent_difference(b.begin() + 1, b.end(), db.begin());
    std::sort(da.begin(), da.end());
    std::sort(db.begin(), db.end());
    std::cout &lt;&lt; (da == db ? &quot;Yes&quot; : &quot;No&quot;) &lt;&lt; &#39;\n&#39;;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;

]]></content>
      <tags>
        <tag>倍增</tag>
        <tag>树形 DP</tag>
        <tag>Kruskal 重构树</tag>
      </tags>
  </entry>
  <entry>
    <title>学习笔记：压位高精</title>
    <url>/20250906/</url>
    <content><![CDATA[把 ddxrS 吓到了，发出惊世疑问：『为什么高二机房正在激烈地讨论怎么写高精度？』


考虑 10-base 高精度，单次运算复杂度为 \(O(\log V)\)。使用 10-base 的主要原因是 std::to_string 很方便、输出也很简单。
但效率太低。实际上，一般打高精度都是 1e4-base，或更激进地，1e9-base。
注意高精乘低精是 \(O(len)\) 而非 \(O(len^2)\)。
需要考虑输出。由于用的是 10-power 作为 base，所以只需要把每四位直接输出即可。注意除首位外需要补前导 0 直到四位。

struct BI &#123;
    std::vector&lt;int&gt; s;
    BI() &#123;&#125;
    BI(int x) &#123;
        for (; x; s.push_back(x % 10000), x /= 10000);
        return;
    &#125;
    BI&amp; operator= (int q) &#123;
        return *this = (BI)q;
    &#125;
    bool operator&gt; (const BI &amp;q) &#123;
        if (s.size() != q.s.size())
            return s.size() &gt; q.s.size();
        for (int i = (int)s.size() - 1; ~i; --i)
            if (s[i] != q.s[i])
                return s[i] &gt; q.s[i];
        return 0;
    &#125;
    BI operator* (int q) const &#123;
        int lx = s.size();
        std::vector&lt;long long&gt; res(lx + 3);
        for (int i = 0; i &lt; lx; ++i)
            res[i] = (long long)s[i] * q;
        BI p;
        for (int j = 0; j &lt; lx + 2; ++j)
            res[j + 1] += res[j] / 10000, res[j] %= 10000;
        int len = lx + 2;
        for (; ~len &amp;&amp; !res[len]; --len);
        for (int j = 0; j &lt;= len; ++j)
            p.s.push_back(res[j]);
        return p;
    &#125;
    void out(void) &#123;
        for (int i = (int)s.size() - 1; ~i; --i) &#123;
            auto p = std::to_string(s[i]);
            if (i != (int)s.size() - 1)
                for (; (int)p.size() &lt; 4; p = &quot;0&quot; + p);
            std::cout &lt;&lt; p;
        &#125;
        std::cout &lt;&lt; &#39;\n&#39;;
        return;
    &#125;
&#125;;

]]></content>
      <tags>
        <tag>高精度</tag>
      </tags>
  </entry>
  <entry>
    <title>杂题选谈</title>
    <url>/20250907/</url>
    <content><![CDATA[突围


E - Colinear
https://atcoder.jp/contests/abc422/tasks/abc422_e
看到题目会有一个乱搞的想法：随机取一对点，那么是有 \(\dfrac 14\) 的概率都在直线上的。带进去暴力 check 一下，多来几次正确率就比较高。
什么，这是正解？abc 的风格真是越来越奇怪了。

F - Eat and Ride
https://atcoder.jp/contests/abc422/tasks/abc422_f
考虑一个费用提前计算的分层图，就可以跑 Dij 了。
官解给出了一个优化：搜索实际上是在给边定向；这样图就转化为 DAG（实际上反向边并不会产生有效更新，故直接朴素转移即可）。

B - Triangle Toggle
https://atcoder.jp/contests/arc205/tasks/arc205_b
现场是打表找规律做出来的 😅
发现这样一次操作之后每个点上黑边的奇偶性是不会变的，所以会有一个上界，难点在于是否可以达到这个上界。
发现只要存在一个点上连有两条白边，就可以把 001 反转为 110，一次操作至少可以新增一条黑边。故是可以达到的。

D - Non-Ancestor Matching
https://atcoder.jp/contests/arc205/tasks/arc205_d
没啥好说的摩尔投票，有一个非常简单的优先队列做法
但 Rosmist 打了另一个看起来有点玄学的东西：可以感受到每次只向最大的子树递归是合理的，尝试证明一下发现确实比较显然

E - Subset Product Problem
https://www.luogu.com.cn/problem/AT_arc205_e
奇怪题目
高维前缀和 + 分块其实不算特别罕见的 trick
用 \(f_{i,j}\) 表示前 \(10\) 位为 \(i\)，后 \(10\) 位的高维前缀和
每次查询 / 更新都是 \(O(2^{10})\) 的，可以接受（吗）
然后还有一个科研性的做法 见 https://www.luogu.com.cn/article/1uyz0hn2

C. By the Assignment
https://codeforces.com/contest/2135/problem/C
]]></content>
      <tags>
        <tag>分块</tag>
        <tag>随机化</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title>学习笔记：吉司机线段树</title>
    <url>/20250909/</url>
    <content><![CDATA[势能，但仅限于势能吗？

数据结构选讲(一) by crashed.pdf

需要知道线段树并非万能，很多看起来兼容的操作其实是不兼容的。举例：

区间取 min, max、区间查询 min, max
发现在涉及最值操作的时候，把区间元素值看作分段函数和取最值的性质是比较贴的。
那么相当于把所有大于 / 小于 \(v\) 的部分推平。查询是好做的。
区间加、区间查询 min, max
相当于竖直方向平移。
区间加等差数列、区间查询 min, max
发现是和另一个固定的一次函数做线性加；发现是不可做的。
区间取 min、区间求和
也即把所有大于 / 小于 \(v\) 的部分推平，还要求点值之和。
看起来不可做，因为求和没办法用这样的语言体系简单阐释，只能考虑脱离这个语言体系，真的去找到这样的凸起。这样看起来是特别慢的。

但实际上最后一条是可做的，吉如一发明了一种特定的方法，并证明了在仅有区间取 min / max + 区间求和操作时，复杂度是 \(O(q\log n)\) 的；如果再增加其他任何区间操作，复杂度是 \(O(q\log^2 n)\) 的。

区间取 min / 区间求和
例：Gorgeous Sequence
记录最大值 \(mx\)、次大值 \(se\)、最大值出现次数 \(cnt\)。当 \(v\in(se,mx)\) 时，发现只有 \(mx\) 需要被更新。此时 \(s\gets s-(mx-v)\cdot cnt\)。
否则，\(se\) 也需要被更新，暴力递归直到满足上一条后停止。复杂度 \(O(q\log n)\)。

#include &lt;bits/stdc++.h&gt;
const int maxn = 1e6 + 5;
const int inf = 0x3f3f3f3f;
struct &#123;
    long long s;
    int l, r, mx, se, d, cnt;
&#125; t[maxn &lt;&lt; 2];
#define lt (p &lt;&lt; 1)
#define rt (lt | 1)
int a[maxn];
void pushup(int p) &#123;
    if (t[lt].mx == t[rt].mx) &#123;
        t[p].mx = t[lt].mx, t[p].cnt = t[lt].cnt + t[rt].cnt;
        t[p].se = std::max(t[lt].se, t[rt].se);
    &#125;
    else if (t[lt].mx &gt; t[rt].mx) &#123;
        t[p].mx = t[lt].mx, t[p].cnt = t[lt].cnt;
        t[p].se = std::max(t[lt].se, t[rt].mx);
    &#125;
    else &#123;
        t[p].mx = t[rt].mx, t[p].cnt = t[rt].cnt;
        t[p].se = std::max(t[lt].mx, t[rt].se);
    &#125;
    t[p].s = t[lt].s + t[rt].s;
    return;
&#125;
void bld(int p, int l, int r) &#123;
    t[p].d = inf;
    t[p].l = l, t[p].r = r;
    if (l == r) &#123;
        t[p].s = t[p].mx = a[l], t[p].cnt = 1, t[p].se = 0;
        return;
    &#125;
    int mid = (l + r) &gt;&gt; 1;
    bld(lt, l, mid), bld(rt, mid + 1, r);
    pushup(p);
    return;
&#125;
void pushval(int p, int v) &#123;
    if (v &lt;= t[p].mx) &#123;
        t[p].s -= (long long)(t[p].mx - v) * t[p].cnt;
        t[p].mx = t[p].d = v;
    &#125;
    return;
&#125;
void pushdown(int p) &#123;
    if (t[p].d != inf) &#123;
        pushval(lt, t[p].d), pushval(rt, t[p].d);
        t[p].d = inf;
    &#125;
    return;
&#125;
void add(int p, int l, int r, int v) &#123;
    if (t[p].mx &lt;= v)
        return;
    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r &amp;&amp; v &gt; t[p].se) &#123;
        pushval(p, v);
        return;
    &#125;
    pushdown(p);
    int mid = (t[p].l + t[p].r) &gt;&gt; 1;
    if (l &lt;= mid)
        add(lt, l, r, v);
    if (r &gt; mid)
        add(rt, l, r, v);
    pushup(p);
    return;
&#125;
int askmx(int p, int l, int r) &#123;
    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r)
        return t[p].mx;
    pushdown(p);
    int mid = (t[p].l + t[p].r) &gt;&gt; 1, res = 0;
    if (l &lt;= mid)
        res = askmx(lt, l, r);
    if (r &gt; mid)
        res = std::max(res, askmx(rt, l, r));
    return res;
&#125;
long long asks(int p, int l, int r) &#123;
    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r)
        return t[p].s;
    pushdown(p);
    int mid = (t[p].l + t[p].r) &gt;&gt; 1;
    auto res = 0ll;
    if (l &lt;= mid)
        res = asks(lt, l, r);
    if (r &gt; mid)
        res += asks(rt, l, r);
    return res;
&#125;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int T;
    for (std::cin &gt;&gt; T; T--; ) &#123;
        int n, m;
        std::cin &gt;&gt; n &gt;&gt; m;
        for (int i = 1; i &lt;= n; ++i)
            std::cin &gt;&gt; a[i];
        bld(1, 1, n);
        for (int op, l, r; m--; ) &#123;
            std::cin &gt;&gt; op &gt;&gt; l &gt;&gt; r;
            if (op == 0) &#123;
                int v;
                std::cin &gt;&gt; v;
                add(1, l, r, v);
            &#125;
            else if (op == 1)
                std::cout &lt;&lt; askmx(1, l, r) &lt;&lt; &#39;\n&#39;;
            else
                std::cout &lt;&lt; asks(1, l, r) &lt;&lt; &#39;\n&#39;;
        &#125;
    &#125;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;


区间取 min、区间操作、区间求和
例：最假女选手
可以用相似的方法来维护；
]]></content>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>杂题选谈：吉司机 + 历史和</title>
    <url>/20250911/</url>
    <content><![CDATA[并非所有历史和都是吉司机


A - Just Another Game of Stones
https://www.luogu.com.cn/problem/P9631

发现如果选定了这一步取的位置 \(i\)，那么要拿的石子是定值 \(a_i-a_i\oplus s\)，当 \(a_i\le a_i\oplus s\) 时不合法。
可以用吉司机维护修改和区间异或和，那么询问需要转化。
答案为 \(a_i&gt;a_i\oplus s\) 的次数，结合异或是不带进位的区间加的观点，考察『加数』\(s\) 的最高位，当且仅当 \(a_i\) 在这一位为 \(1\) 时有贡献。
故再维护一下每一位为 \(1\) 的个数即可。复杂度 \(O(q\log n\log V)\)。


#include &lt;bits/stdc++.h&gt;
const int inf = 1 &lt;&lt; 30;
const int maxn = 2e5 + 5;
struct &#123;
    std::array&lt;int, 30&gt; u;
    int l, r, cnt, mn, se, d, s;
&#125; t[maxn &lt;&lt; 2];
#define lt (p &lt;&lt; 1)
#define rt (lt | 1)
int a[maxn];
void pushup(int p) &#123;
    if (t[lt].mn == t[rt].mn) &#123;
        t[p].mn = t[lt].mn, t[p].cnt = t[lt].cnt + t[rt].cnt;
        t[p].se = std::min(t[lt].se, t[rt].se);
    &#125;
    else if (t[lt].mn &lt; t[rt].mn) &#123;
        t[p].mn = t[lt].mn, t[p].cnt = t[lt].cnt;
        t[p].se = std::min(t[lt].se, t[rt].mn);
    &#125;
    else &#123;
        t[p].mn = t[rt].mn, t[p].cnt = t[rt].cnt;
        t[p].se = std::min(t[lt].mn, t[rt].se);
    &#125;
    t[p].s = t[lt].s ^ t[rt].s;
    for (int i = 0; i &lt; 30; ++i)
        t[p].u[i] = t[lt].u[i] + t[rt].u[i];
    return;
&#125;
void bld(int p, int l, int r) &#123;
    t[p].d = -inf;
    t[p].l = l, t[p].r = r;
    if (l == r) &#123;
        for (int i = 0; i &lt; 30; ++i)
            t[p].u[i] = (a[l] &gt;&gt; i) &amp; 1;
        t[p].s = t[p].mn = a[l], t[p].cnt = 1, t[p].se = inf;
        return;
    &#125;
    int mid = (l + r) &gt;&gt; 1;
    bld(lt, l, mid), bld(rt, mid + 1, r);
    pushup(p);
    return;
&#125;
void pushval(int p, int v) &#123;
    if (v &gt; t[p].mn) &#123;
        for (int i = 0; i &lt; 30; ++i) &#123;
            if ((t[p].mn &gt;&gt; i) &amp; 1)
                t[p].u[i] -= t[p].cnt;
            if ((v &gt;&gt; i) &amp; 1)
                t[p].u[i] += t[p].cnt;
        &#125;
        if (t[p].cnt &amp; 1)
            t[p].s ^= t[p].mn ^ v;
        t[p].mn = t[p].d = v;
    &#125;
    return;
&#125;
void pushdown(int p) &#123;
    if (t[p].d != -inf) &#123;
        pushval(lt, t[p].d), pushval(rt, t[p].d);
        t[p].d = -inf;
    &#125;
    return;
&#125;
void add(int p, int l, int r, int v) &#123;
    if (t[p].mn &gt;= v)
        return;
    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r &amp;&amp; v &lt; t[p].se) &#123;
        pushval(p, v);
        return;
    &#125;
    pushdown(p);
    int mid = (t[p].l + t[p].r) &gt;&gt; 1;
    if (l &lt;= mid)
        add(lt, l, r, v);
    if (r &gt; mid)
        add(rt, l, r, v);
    pushup(p);
    return;
&#125;
int askt(int p, int l, int r, int i) &#123;
    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r)
        return t[p].u[i];
    pushdown(p);
    int mid = (t[p].l + t[p].r) &gt;&gt; 1, res = 0;
    if (l &lt;= mid)
        res = askt(lt, l, r, i);
    if (r &gt; mid)
        res += askt(rt, l, r, i);
    return res;
&#125;
int asks(int p, int l, int r) &#123;
    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r)
        return t[p].s;
    pushdown(p);
    int mid = (t[p].l + t[p].r) &gt;&gt; 1, res = 0;
    if (l &lt;= mid)
        res = asks(lt, l, r);
    if (r &gt; mid)
        res ^= asks(rt, l, r);
    return res;
&#125;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, m;
    std::cin &gt;&gt; n &gt;&gt; m;
    for (int i = 1; i &lt;= n; ++i)
        std::cin &gt;&gt; a[i];
    bld(1, 1, n);
    for (int op, l, r, v; m--; ) &#123;
        std::cin &gt;&gt; op &gt;&gt; l &gt;&gt; r &gt;&gt; v;
        if (op == 1)
            add(1, l, r, v);
        else &#123;
            int s = asks(1, l, r) ^ v;
            if (s == 0) &#123;
                std::cout &lt;&lt; 0 &lt;&lt; &#39;\n&#39;;
                continue;
            &#125;
            int t = std::__lg(s);
            std::cout &lt;&lt; askt(1, l, r, t) + ((v &gt;&gt; t) &amp; 1) &lt;&lt; &#39;\n&#39;;
        &#125;
    &#125;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;


B - Prof. Pang’s sequence / C - TEST_90
https://www.luogu.com.cn/problem/P10822 / https://www.luogu.com.cn/problem/P9990

历史和维护子区间问题是一个固定的 trick，只需要对于每一个 \(r\)，给合法的 \(l\) 加一。
离线扫描线，对于当前右端点 \(r\)，记录每种数最后一次出现的位置 \(pos\)。令 \(r\) 的颜色为 1，从右到左，每碰到一个新的 \(pos\) 就切换颜色
显然对于当前 \(r\)，应该被加一的 \(l\) 就是颜色为 1 的这些位置。
考虑更快地维护这个过程，也就是在 \(r\) 的颜色和 \(r-1\) 不同时就可以对 \([1,r)\) 做一次 flip，是可行的
在每个 \(r\) 处查询 \([l,r]\) 的区间和即可。
吐槽：并非所有历史和都是吉司机


#include &lt;bits/stdc++.h&gt;
const int maxn = 5e5 + 5;
struct &#123;
    long long s;
    int l, r, d0, d1, df, ds, u0, u1;
&#125; t[maxn &lt;&lt; 2];
#define lt (p &lt;&lt; 1)
#define rt (lt | 1)
void pushup(int p) &#123;
    t[p].u0 = t[lt].u0 + t[rt].u0;
    t[p].u1 = t[lt].u1 + t[rt].u1;
    return;
&#125;
void pushval(int p, long long v0, long long v1, bool f) &#123;
    if (f) &#123;
        t[p].df ^= 1;
        std::swap(t[p].u0, t[p].u1);
        std::swap(t[p].d0, t[p].d1);
    &#125;
    t[p].d0 += v0, t[p].d1 += v1;
    t[p].s += t[p].u0 * v0 + t[p].u1 * v1;
    return;
&#125;
void pushdown(int p) &#123;
    pushval(lt, t[p].d0, t[p].d1, t[p].df);
    pushval(rt, t[p].d0, t[p].d1, t[p].df);
    t[p].d0 = t[p].d1 = t[p].df = 0;
    return;
&#125;
void bld(int p, int l, int r) &#123;
    t[p].l = l, t[p].r = r;
    t[p].u0 = r - l + 1;
    if (l == r)
        return;
    int mid = (l + r) &gt;&gt; 1;
    bld(lt, l, mid), bld(rt, mid + 1, r);
    return;
&#125;
void flip(int p, int l, int r) &#123;
    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r) &#123;
        pushval(p, 0, 0, 1);
        return;
    &#125;
    pushdown(p);
    int mid = (t[p].l + t[p].r) &gt;&gt; 1;
    if (l &lt;= mid)
        flip(lt, l, r);
    if (r &gt; mid)
        flip(rt, l, r);
    pushup(p);
    return;
&#125;
long long ask(int p, int l, int r) &#123;
    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r)
        return t[p].s;
    pushdown(p);
    auto res(0ll);
    int mid = (t[p].l + t[p].r) &gt;&gt; 1;
    if (l &lt;= mid)
        res = ask(lt, l, r);
    if (r &gt; mid)
        res += ask(rt, l, r);
    return res;
&#125;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n;
    std::cin &gt;&gt; n;
    std::vector&lt;int&gt; a(n + 1), la(n + 1);
    for (int i = 1; i &lt;= n; ++i)
        std::cin &gt;&gt; a[i];
    int m;
    std::cin &gt;&gt; m;
    std::vector&lt;long long&gt; res(m + 1);
    std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; u(n + 1);
    for (int i = 1, l, r; i &lt;= m; ++i) &#123;
        std::cin &gt;&gt; l &gt;&gt; r;
        u[r].emplace_back(l, i);
    &#125;
    bld(1, 1, n);
    for (int r = 1; r &lt;= n; ++r) &#123;
        flip(1, la[a[r]] + 1, r);
        pushval(1, 0, 1, 0);
        for (auto [l, id] : u[r])
            res[id] = ask(1, l, r);
        la[a[r]] = r;
    &#125;
    for (int i = 1; i &lt;= m; ++i)
        std::cout &lt;&lt; res[i] &lt;&lt; &#39;\n&#39;;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;


D - Stations
https://www.luogu.com.cn/problem/CF1572F

不太能直接维护 \(b\)，但发现如果维护每个 \(i\) 最远能到达的点，发现每次更新 \(j\) 会把 \(j\) 左边的所有点值和 \(j-1\) 取 min。
发现吉司机能够在取 min 的同时在另一个树状树组里维护差分
需要注意更新的时机，应该是每次线段树更新函数访问到完整节点时。
复杂度 \(O(q\log^2n)\)。但真的吗？单点修改似乎对势能有影响？然而并不会相关分析。

看起来有点激进了，没想到确实是正解。

可以发现树状数组在时间上确实是有优势的
#include &lt;bits/stdc++.h&gt;
const int maxn = 2e5 + 5;
const int inf = 0x3f3f3f3f;
struct &#123;
    int l, r, mx, se, d, cnt;
&#125; t[maxn &lt;&lt; 2];
#define lt (p &lt;&lt; 1)
#define rt (lt | 1)
int n;
long long bit[maxn][2];
int lowbit(int x) &#123; return x &amp; -x; &#125;
void add(int x, long long v) &#123;
    for (int i = x; i &lt;= n; i += lowbit(i))
        bit[i][0] += v, bit[i][1] += v * (x - 1);
    return;
&#125;
long long ask(int x) &#123;
    auto res = 0ll;
    for (int i = x; i; i -= lowbit(i))
        res += bit[i][0] * x - bit[i][1];
    return res;
&#125;
void pushup(int p) &#123;
    if (t[lt].mx == t[rt].mx) &#123;
        t[p].mx = t[lt].mx, t[p].cnt = t[lt].cnt + t[rt].cnt;
        t[p].se = std::max(t[lt].se, t[rt].se);
    &#125;
    else if (t[lt].mx &gt; t[rt].mx) &#123;
        t[p].mx = t[lt].mx, t[p].cnt = t[lt].cnt;
        t[p].se = std::max(t[lt].se, t[rt].mx);
    &#125;
    else &#123;
        t[p].mx = t[rt].mx, t[p].cnt = t[rt].cnt;
        t[p].se = std::max(t[lt].mx, t[rt].se);
    &#125;
    return;
&#125;
void bld(int p, int l, int r) &#123;
    t[p].d = inf;
    t[p].l = l, t[p].r = r;
    if (l == r) &#123;
        add(l, 1), add(l + 1, -1);
        t[p].mx = l, t[p].se = -1, t[p].cnt = 1;
        return;
    &#125;
    int mid = (l + r) &gt;&gt; 1;
    bld(lt, l, mid), bld(rt, mid + 1, r);
    pushup(p);
    return;
&#125;
void pushval(int p, int v) &#123;
    if (v &lt;= t[p].mx)
        t[p].mx = t[p].d = v;
    return;
&#125;
void pushdown(int p) &#123;
    if (t[p].d != inf) &#123;
        pushval(lt, t[p].d), pushval(rt, t[p].d);
        t[p].d = inf;
    &#125;
    return;
&#125;
void add(int p, int l, int r, int v) &#123;
    if (t[p].mx &lt;= v)
        return;
    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r &amp;&amp; v &gt; t[p].se) &#123;
        add(t[p].mx + 1, t[p].cnt);
        add(v + 1, -t[p].cnt);
        pushval(p, v);
        return;
    &#125;
    pushdown(p);
    int mid = (t[p].l + t[p].r) &gt;&gt; 1;
    if (l &lt;= mid)
        add(lt, l, r, v);
    if (r &gt; mid)
        add(rt, l, r, v);
    pushup(p);
    return;
&#125;
void upd(int p, int x, int v) &#123;
    if (t[p].l == t[p].r) &#123;
        add(t[p].mx + 1, 1), add(v + 1, -1);
        t[p].mx = v;
        return;
    &#125;
    pushdown(p);
    int mid = (t[p].l + t[p].r) &gt;&gt; 1;
    if (x &lt;= mid)
        upd(lt, x, v);
    else
        upd(rt, x, v);
    pushup(p);
    return;
&#125;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int m;
    std::cin &gt;&gt; n &gt;&gt; m;
    bld(1, 1, n);
    for (int op; m--; ) &#123;
        std::cin &gt;&gt; op;
        if (op == 1) &#123;
            int x, v;
            std::cin &gt;&gt; x &gt;&gt; v;
            if (x != 1)
                add(1, 1, x - 1, x - 1);
            upd(1, x, v);
            // for (int i = 1; i &lt;= n; ++i)
            //     std::cout &lt;&lt; ask(i) - ask(i - 1) &lt;&lt; &#39; &#39;;
            // std::cout &lt;&lt; &#39;\n&#39;;
        &#125;
        else &#123;
            int l, r;
            std::cin &gt;&gt; l &gt;&gt; r;
            std::cout &lt;&lt; ask(r) - ask(l - 1) &lt;&lt; &#39;\n&#39;;
        &#125;
    &#125;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;


E - LuoTianyi and the Function
https://codeforces.com/problemset/problem/1824/D

由于 \(j\) 和函数关联更强，考虑把 \(j\) 这一维扫描线 + 差分掉
经典套路，维护每个 \(x\) 从右向左第一次出现的位置 \(pos_x\)
每次 \(j\) 移动一下，会更新一段区间（可能不存在）的 \(g\) 值，它们原本为 \(pos_{a_j}\)，需要被更新为下一个 \(pos\)。
记录值为 \(pos_x\) 的区间，做区间赋值历史和即可。


#include &lt;bits/stdc++.h&gt;
const int maxn = 1e6 + 5;
struct &#123;
    int l, r;
    long long d1, d2, d3, u, s;
&#125; t[maxn &lt;&lt; 2];
#define lt (p &lt;&lt; 1)
#define rt (lt | 1)
void pushup(int p) &#123;
    t[p].u = t[lt].u + t[rt].u;
    t[p].s = t[lt].s + t[rt].s;
    return;
&#125;
void pushval(int p, long long d1, long long d2, long long d3) &#123;
    t[p].s += t[p].u * d2 + d3 * (t[p].r - t[p].l + 1);
    t[p].d3 += d3;
    if (t[p].d1)
        t[p].d3 += t[p].d1 * d2;
    else
        t[p].d2 += d2;
    if (d1) &#123;
        t[p].u = d1 * (t[p].r - t[p].l + 1);
        t[p].d1 = d1;
    &#125;
    return;
&#125;
void pushdown(int p) &#123;
    pushval(lt, t[p].d1, t[p].d2, t[p].d3);
    pushval(rt, t[p].d1, t[p].d2, t[p].d3);
    t[p].d1 = t[p].d2 = t[p].d3 = 0ll;
    return;
&#125;
void bld(int p, int l, int r) &#123;
    t[p].l = l, t[p].r = r;
    if (l == r)
        return;
    int mid = (t[p].l + t[p].r) &gt;&gt; 1;
    bld(lt, l, mid), bld(rt, mid + 1, r);
    return;
&#125;
void upd(int p, int l, int r, long long v) &#123;
    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r) &#123;
        pushval(p, v, 0ll, 0ll);
        return;
    &#125;
    pushdown(p);
    int mid = (t[p].l + t[p].r) &gt;&gt; 1;
    if (l &lt;= mid)
        upd(lt, l, r, v);
    if (r &gt; mid)
        upd(rt, l, r, v);
    pushup(p);
    return;
&#125;
long long ask(int p, int l, int r) &#123;
    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r)
        return t[p].s;
    pushdown(p);
    int mid = (t[p].l + t[p].r) &gt;&gt; 1;
    auto res = 0ll;
    if (l &lt;= mid)
        res = ask(lt, l, r);
    if (r &gt; mid)
        res += ask(rt, l, r);
    return res;
&#125;
signed main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, q;
    std::cin &gt;&gt; n &gt;&gt; q;
    std::vector&lt;int&gt; a(n + 1), la(n + 1);
    for (int i = 1; i &lt;= n; ++i)
        std::cin &gt;&gt; a[i];
    struct query &#123; int l, r, id, k; &#125;;
    std::vector&lt;long long&gt; res(q + 1);
    std::vector&lt;std::vector&lt;query&gt; &gt; u(n + 1);
    for (int i = 1, l, r, x, y; i &lt;= q; ++i) &#123;
        std::cin &gt;&gt; l &gt;&gt; r &gt;&gt; x &gt;&gt; y;
        if (x != 1)
            u[x - 1].push_back(&#123; l, r, i, -1 &#125;);
        u[y].push_back(&#123; l, r, i, 1 &#125;);
    &#125;
    bld(1, 1, n);
    std::vector&lt;int&gt; pre(n + 2), nex(n + 2), l(n + 2);
    pre[n + 1] = 0, nex[0] = n + 1;
    for (int i = 1; i &lt;= n; ++i) &#123;
        int p = la[a[i]];
        nex[pre[n + 1]] = i, pre[i] = pre[n + 1], pre[n + 1] = i, nex[i] = n + 1;
        l[i] = i;
        if (p != 0) &#123;
            upd(1, l[p], p, nex[p]);
            l[nex[p]] = l[p];
            pre[nex[p]] = pre[p], nex[pre[p]] = nex[p];
        &#125;
        upd(1, i, i, i);
        pushval(1, 0, 1, 0);
        for (auto [l, r, id, k] : u[i])
            res[id] += k * ask(1, l, r);
        la[a[i]] = i;
    &#125;
    for (int i = 1; i &lt;= q; ++i)
        std::cout &lt;&lt; res[i] &lt;&lt; &#39;\n&#39;;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;


F - Yunli’s Subarray Queries (extreme version)
https://codeforces.com/problemset/problem/2009/G3

考虑对 \(\forall i\)，令 \(a_i\gets a_i-i\)，那么能够参与同一个连续子段的元素值应相同
显然对于任意一个长度为 \(k\) 的子段，其答案为 \(k\) 减去众数出现次数（\([l, r]\) 处答案记为 \(g_r\)）
这一点可以用类似莫队的方法来做
那么对于更长的子段 \([l, r]\)，其 \(f\) 就是 \(\min\limits_{l+k-1\le i\le r}\{g_i\}\)
原问题中的一次 \([l, r]\) 的询问就可以转化为 \(\sum\limits_{i=l+k-1}^r\sum\limits_{j=i}^r\min\{ g_{i\sim j}\}\)
这里有一个 trick：扫描线时可以用单调栈的想法来维护最小值操作，那么就把最值操作转化为一般的区间加历史和了。


#include &lt;bits/stdc++.h&gt;
const int maxn = 1e6 + 5;
struct &#123;
    int l, r;
    long long d1, d2, d3, u, s;
&#125; t[maxn &lt;&lt; 2];
#define lt (p &lt;&lt; 1)
#define rt (lt | 1)
void pushup(int p) &#123;
    t[p].u = t[lt].u + t[rt].u;
    t[p].s = t[lt].s + t[rt].s;
    return;
&#125;
void pushval(int p, long long d1, long long d2, long long d3) &#123;
    t[p].s += t[p].u * d2 + d3 * (t[p].r - t[p].l + 1);
    t[p].d3 += d3 + t[p].d1 * d2;
    t[p].d2 += d2;
    t[p].u += d1 * (t[p].r - t[p].l + 1);
    t[p].d1 += d1;
    return;
&#125;
void pushdown(int p) &#123;
    pushval(lt, t[p].d1, t[p].d2, t[p].d3);
    pushval(rt, t[p].d1, t[p].d2, t[p].d3);
    t[p].d1 = t[p].d2 = t[p].d3 = 0ll;
    return;
&#125;
void bld(int p, int l, int r) &#123;
    t[p].l = l, t[p].r = r;
    t[p].u = t[p].s = 0ll;
    t[p].d1 = t[p].d2 = t[p].d3 = 0;
    if (l == r)
        return;
    int mid = (t[p].l + t[p].r) &gt;&gt; 1;
    bld(lt, l, mid), bld(rt, mid + 1, r);
    return;
&#125;
void add(int p, int l, int r, long long v) &#123;
    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r) &#123;
        pushval(p, v, 0ll, 0ll);
        return;
    &#125;
    pushdown(p);
    int mid = (t[p].l + t[p].r) &gt;&gt; 1;
    if (l &lt;= mid)
        add(lt, l, r, v);
    if (r &gt; mid)
        add(rt, l, r, v);
    pushup(p);
    return;
&#125;
long long ask(int p, int l, int r) &#123;
    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r)
        return t[p].s;
    pushdown(p);
    int mid = (t[p].l + t[p].r) &gt;&gt; 1;
    auto res = 0ll;
    if (l &lt;= mid)
        res = ask(lt, l, r);
    if (r &gt; mid)
        res += ask(rt, l, r);
    return res;
&#125;
signed main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int T;
    for (std::cin &gt;&gt; T; T--; ) &#123;
        int n, k, q;
        std::cin &gt;&gt; n &gt;&gt; k &gt;&gt; q;
        std::vector&lt;int&gt; a(n + 1);
        for (int i = 1; i &lt;= n; ++i)
            std::cin &gt;&gt; a[i], a[i] -= i;
        bld(1, 1, n);
        std::vector&lt;int&gt; g(n + 1);
        std::unordered_map&lt;int, int&gt; cnt;
        std::multiset&lt;int&gt; t;
        for (int i = 1; i &lt;= n; ++i) &#123;
            if (i &gt; k) &#123;
                t.erase(t.find(cnt[a[i - k]]));
                if (--cnt[a[i - k]])
                    t.insert(cnt[a[i - k]]);
            &#125;
            if (cnt[a[i]])
                t.erase(t.find(cnt[a[i]]));
            t.insert(++cnt[a[i]]);
            if (i &gt;= k)
                g[i] = k - *--t.end();
        &#125;
        std::vector&lt;long long&gt; res(q + 1);
        std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; u(n + 1);
        for (int i = 1, l, r; i &lt;= q; ++i) &#123;
            std::cin &gt;&gt; l &gt;&gt; r;
            u[r].emplace_back(l + k - 1, i);
        &#125;
        std::stack&lt;std::pair&lt;int, int&gt; &gt; st;
        for (int i = 1; i &lt;= n; ++i) &#123;
            std::pair&lt;int, int&gt; now(g[i], i);
            add(1, i, i, g[i]);
            for (; !st.empty() &amp;&amp; st.top() &gt; now; st.pop()) &#123;
                auto [v, p] = st.top();
                add(1, p, now.second - 1, g[i] - v);
                now.second = p;
            &#125;
            st.push(now);
            pushval(1, 0ll, 1ll, 0ll);
            for (auto [l, id] : u[i])
                res[id] = ask(1, l, i);
        &#125;
        for (int i = 1; i &lt;= q; ++i)
            std::cout &lt;&lt; res[i] &lt;&lt; &#39;\n&#39;;
    &#125;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;

]]></content>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>杂题选谈：线段树</title>
    <url>/20250921/</url>
    <content><![CDATA[信息转化为主


B - Into Blocks (hard version)
https://www.luogu.com.cn/problem/CF1209G2

trick：考察每个颜色出现的区间 \([s_{col},t_{col}]\)，对每个 \([s_{col},t_{col})\) 打标记，则没有被打过标记的点后能够进行一次分段。
对于每一段，其代价为段长度 - 众数出现次数。
这个众数乍一看有点吓人，实际上发现由于每个元素出现的所有位置都在这个段里，所以可以记录每个元素的个数，对于每个元素只钦定其中一个位置来记录即可快速维护。
发现线段树能够比较容易地维护全局查询：维护 \(0\) 位置是经典 trick；且容易发现『段长』之和为 \(n\)，故只需维护众数。
实现技巧：单点本身就是自己的最小值，从这一点出发可以规避很多边界情况。


#include &lt;bits/stdc++.h&gt;
const int lim = 2e5;
const int maxn = 2e5 + 5;
struct node &#123;
    int l, r, u, d;
    int lu, ru, mn, mx;
    node operator+ (const node &amp;q) const &#123;
        node res;
        res.d = 0;
        res.l = l, res.r = q.r;
        res.mx = std::max(mx, q.mx);
        res.mn = std::min(mn, q.mn);
        if (mn &lt; q.mn) &#123;
            res.mn = mn, res.u = u;
            res.lu = lu, res.ru = std::max(q.mx, ru);
        &#125;
        else if (q.mn &lt; mn) &#123;
            res.mn = q.mn, res.u = q.u;
            res.lu = std::max(mx, q.lu), res.ru = q.ru;
        &#125;
        else &#123;
            res.lu = lu, res.ru = q.ru;
            res.u = u + q.u + std::max(ru, q.lu);
        &#125;
        return res;
    &#125;
&#125; t[maxn &lt;&lt; 2];
#define lt (p &lt;&lt; 1)
#define rt (lt | 1)
void bld(int p, int l, int r) &#123;
    t[p].l = l, t[p].r = r;
    if (l == r)
        return;
    int mid = (l + r) &gt;&gt; 1;
    bld(lt, l, mid), bld(rt, mid + 1, r);
    return;
&#125;
void pushval(int p, int d) &#123;
    t[p].mn += d, t[p].d += d;
    return;
&#125;
void pushdown(int p) &#123;
    pushval(lt, t[p].d), pushval(rt, t[p].d);
    t[p].d = 0;
    return;
&#125;
void upd(int p, int x, int v) &#123;
    if (t[p].l == t[p].r) &#123;
        t[p].u = t[p].mx = v;
        return;
    &#125;
    pushdown(p);
    int mid = (t[p].l + t[p].r) &gt;&gt; 1;
    if (x &lt;= mid)
        upd(lt, x, v);
    else
        upd(rt, x, v);
    t[p] = t[lt] + t[rt];
    return;
&#125;
void add(int p, int l, int r, int v) &#123;
    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r) &#123;
        pushval(p, v);
        return;
    &#125;
    pushdown(p);
    int mid = (t[p].l + t[p].r) &gt;&gt; 1;
    if (l &lt;= mid)
        add(lt, l, r, v);
    if (r &gt; mid)
        add(rt, l, r, v);
    t[p] = t[lt] + t[rt];
    return;
&#125;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, q;
    std::cin &gt;&gt; n &gt;&gt; q;
    std::vector&lt;int&gt; a(n + 1);
    std::vector&lt;std::set&lt;int&gt; &gt; st(lim + 1);
    for (int i = 1; i &lt;= n; ++i) &#123;
        std::cin &gt;&gt; a[i];
        st[a[i]].emplace(i);
    &#125;
    bld(1, 1, n);
    for (int i = 1; i &lt;= lim; ++i)
        if (!st[i].empty()) &#123;
            int s = *st[i].begin(), t = *--st[i].end();
            if (s &lt;= t - 1)
                add(1, s, t - 1, 1);
            upd(1, s, (int)st[i].size());
        &#125;
    std::cout &lt;&lt; n - ::t[1].u - ::t[1].lu - ::t[1].ru  &lt;&lt; &#39;\n&#39;;
    auto work = [&amp;](int v, int k) &#123;
        if (st[v].empty())
            return;
        int s = *st[v].begin(), t = *--st[v].end();
        if (s &lt;= t - 1)
            add(1, s, t - 1, k);
        upd(1, s, k == 1 ? (int)st[v].size() : 0);
        return;
    &#125;;
    for (int i, x; q--; ) &#123;
        std::cin &gt;&gt; i &gt;&gt; x;
        work(a[i], -1), st[a[i]].erase(i), work(a[i], 1);
        a[i] = x;
        work(a[i], -1), st[a[i]].insert(i), work(a[i], 1);
        std::cout &lt;&lt; n - ::t[1].u - ::t[1].lu - ::t[1].ru  &lt;&lt; &#39;\n&#39;;
    &#125;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;


C - seats 排座位
https://www.luogu.com.cn/problem/P4898
很有价值的一个题

对于一个固定的 \(k\)，考虑怎么刻画合法矩形
发现『前 \(k\) 个元素构成矩形』比『大小为 \(k\) 的矩形包含前 \(k\) 个元素』更合理
考虑前 \(k\) 个元素在满足什么条件时构成矩形
我最开始的想法是『记录这 \(k\) 个元素占据的最大、最小、最左、最右，如果乘起来为 \(k\)，那么合法』
但会发现这个转化是不好做的，或者说就又往上面那个错误的判定转化（大小为 \(k\) 的矩形包含前 \(k\) 个元素）靠了。两个都有一个共同的问题，就是过于依赖这个 \(k\)，限制太具体了，导致不能很好地应用到每个 \(k\)
现在这个判定的转化比较合理的地方就在于，对矩形本身不存在约束，只是要求构成矩形。这样就允许直接从图形出发，更多地考虑怎样用单点信息合并出矩形与否
把 \([0,k)\) 染成黑色，其他为白色，那么有一个粗暴但简单的方法来刻画『矩形』这个要求：

图形存在四个『角』。

再刻画一下『角』：黑点左上 / 左下 / 右上 / 右下两个点都为白。
当然这样是很荒谬的，因为下图显然不只有四个角。

所以我们不得不把一个凹角也算作角，不难发现把上方凸角的定义中的主体换成白点即可定义凹角。
优化：算贡献
维护当前时刻，所有 \(4nm\) 个角在 \(k\) 处是否存在
此时要用一个类似维护 \(0\) 个数的方法来维护有 \(4\) 个角个数的 \(k\) 个数。
考虑这么一个可能的角：

其存在当且仅当 \(A\) 为黑，\(B,C\) 为白（凸角），或 \(A\) 为白，\(B,C\) 为黑（凹角）。
考察 \(A,B,C\) 第一次变黑的时间 \(k_A,k_B,k_C\)，那么 \(A\) 能够对所有 \(k\in[k_A,\min\{k_B,k_C\})\) 和 \(k\in[\max\{k_B,k_C\},k_A)\) 造成贡献。
每次修改只会做 \(O(1)\) 次区间加，是可维护的。注意两个被交换的点可能会有公共的相邻点，需要特别处理一下。
这个东西本质上可以看作一个 2⨉2 的Soble 算子，所以可以抠出来一般定义上的角


non-interactive version:
#include &lt;bits/stdc++.h&gt;
const int dir[][2] = &#123; &#123; 0, -1 &#125;, &#123; 0, 1 &#125;, &#123; -1, 0 &#125;, &#123; 1, 0 &#125; &#125;;
const int maxn = 1e6 + 5;
struct node &#123;
    int l, r, u, d, mn;
    node operator+ (const node &amp;q) const &#123;
        node res;
        res.l = l, res.r = q.r, res.d = 0;
        res.mn = std::min(mn, q.mn), res.u = 0;
        if (mn == res.mn)
            res.u = u;
        if (q.mn == res.mn)
            res.u += q.u;
        return res;
    &#125;
&#125; t[maxn &lt;&lt; 2];
#define lt (p &lt;&lt; 1)
#define rt (lt | 1)
void bld(int p, int l, int r) &#123;
    t[p].l = l, t[p].r = r, t[p].u = r - l + 1;
    if (l == r)
        return;
    int mid = (l + r) &gt;&gt; 1;
    bld(lt, l, mid), bld(rt, mid + 1, r);
    return;
&#125;
void pushval(int p, int v) &#123;
    t[p].mn += v, t[p].d += v;
    return;
&#125;
void pushdown(int p) &#123;
    pushval(lt, t[p].d), pushval(rt, t[p].d);
    t[p].d = 0;
    return;
&#125;
void add(int p, int l, int r, int v) &#123;
    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r) &#123;
        pushval(p, v);
        return;
    &#125;
    pushdown(p);
    int mid = (t[p].l + t[p].r) &gt;&gt; 1;
    if (l &lt;= mid)
        add(lt, l, r, v);
    if (r &gt; mid)
        add(rt, l, r, v);
    t[p] = t[lt] + t[rt];
    return;
&#125;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, m, q;
    std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;
    const int N = n * m;
    std::vector&lt;std::pair&lt;int, int&gt; &gt; pos(N + 1);
    std::vector&lt;std::vector&lt;int&gt; &gt; id(n + 2, std::vector&lt;int&gt; (m + 2, N + 1));
    for (int i = 1, x, y; i &lt;= N; ++i) &#123;
        std::cin &gt;&gt; x &gt;&gt; y, ++x, ++y;
        id[x][y] = i, pos[i] = &#123; x, y &#125;;
    &#125;
    bld(1, 1, N);
    auto work = [&amp;](int x, int y, int k) &#123;
        for (int i = 0; i &lt; 2; ++i)
            for (int j = 2; j &lt; 4; ++j) &#123;
                int x1 = x + dir[j][0], y1 = y + dir[i][1];
                if (id[x][y] &lt; std::min(id[x1][y], id[x][y1]))
                    add(1, id[x][y], std::min(id[x1][y], id[x][y1]) - 1, k);
                if (std::max(id[x1][y], id[x][y1]) &lt; id[x][y])
                    add(1, std::max(id[x1][y], id[x][y1]), id[x][y] - 1, k);
            &#125;
        return;
    &#125;;
    for (int i = 1; i &lt;= n; ++i)
        for (int j = 1; j &lt;= m; ++j)
            work(i, j, 1);
    for (int i1, i2; q--; ) &#123;
        std::cin &gt;&gt; i1 &gt;&gt; i2, ++i1, ++i2;
        auto [x1, y1] = pos[i1];
        auto [x2, y2] = pos[i2];
        std::set&lt;std::pair&lt;int, int&gt; &gt; st;
        st.emplace(x1, y1);
        for (auto [fx, fy] : dir) &#123;
            int x = x1 + fx, y = y1 + fy;
            if (x &gt;= 1 &amp;&amp; x &lt;= n &amp;&amp; y &gt;= 1 &amp;&amp; y &lt;= m)
                st.emplace(x, y);
        &#125;
        st.emplace(x2, y2);
        for (auto [fx, fy] : dir) &#123;
            int x = x2 + fx, y = y2 + fy;
            if (x &gt;= 1 &amp;&amp; x &lt;= n &amp;&amp; y &gt;= 1 &amp;&amp; y &lt;= m)
                st.emplace(x, y);
        &#125;
        for (auto [x, y] : st)
            work(x, y, -1);
        std::swap(id[x1][y1], id[x2][y2]), std::swap(pos[i1], pos[i2]);
        for (auto [x, y] : st)
            work(x, y, 1);
        std::cout &lt;&lt; t[1].u &lt;&lt; &#39;\n&#39;;
    &#125;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;
interactive version:
#include &lt;bits/stdc++.h&gt;
#ifdef ONLINE_JUDGE
#include &quot;seats.h&quot;
#endif
const int dir[][2] = &#123; &#123; 0, -1 &#125;, &#123; 0, 1 &#125;, &#123; -1, 0 &#125;, &#123; 1, 0 &#125; &#125;;
const int maxn = 1e6 + 5;
struct node &#123;
    int l, r, u, d, mn;
    node operator+ (const node &amp;q) const &#123;
        node res;
        res.l = l, res.r = q.r, res.d = 0;
        res.mn = std::min(mn, q.mn), res.u = 0;
        if (mn == res.mn)
            res.u = u;
        if (q.mn == res.mn)
            res.u += q.u;
        return res;
    &#125;
&#125; t[maxn &lt;&lt; 2];
#define lt (p &lt;&lt; 1)
#define rt (lt | 1)
void bld(int p, int l, int r) &#123;
    t[p].l = l, t[p].r = r, t[p].u = r - l + 1;
    if (l == r)
        return;
    int mid = (l + r) &gt;&gt; 1;
    bld(lt, l, mid), bld(rt, mid + 1, r);
    return;
&#125;
void pushval(int p, int v) &#123;
    t[p].mn += v, t[p].d += v;
    return;
&#125;
void pushdown(int p) &#123;
    pushval(lt, t[p].d), pushval(rt, t[p].d);
    t[p].d = 0;
    return;
&#125;
void add(int p, int l, int r, int v) &#123;
    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r) &#123;
        pushval(p, v);
        return;
    &#125;
    pushdown(p);
    int mid = (t[p].l + t[p].r) &gt;&gt; 1;
    if (l &lt;= mid)
        add(lt, l, r, v);
    if (r &gt; mid)
        add(rt, l, r, v);
    t[p] = t[lt] + t[rt];
    return;
&#125;
int n, m, N;
std::vector&lt;std::pair&lt;int, int&gt; &gt; pos;
std::vector&lt;std::vector&lt;int&gt; &gt; id(n + 2, std::vector&lt;int&gt; (m + 2, N + 1));
void work(int x, int y, int k) &#123;
    for (int i = 0; i &lt; 2; ++i)
        for (int j = 2; j &lt; 4; ++j) &#123;
            int x1 = x + dir[j][0], y1 = y + dir[i][1];
            if (id[x][y] &lt; std::min(id[x1][y], id[x][y1]))
                add(1, id[x][y], std::min(id[x1][y], id[x][y1]) - 1, k);
            if (std::max(id[x1][y], id[x][y1]) &lt; id[x][y])
                add(1, std::max(id[x1][y], id[x][y1]), id[x][y] - 1, k);
        &#125;
    return;
&#125;;
void give_initial_chart(int n, int m, std::vector&lt;int&gt; R, std::vector&lt;int&gt; C) &#123;
    ::n = n, ::m = m, N = n * m;
    pos.resize(N + 1);
    id.assign(n + 2, std::vector&lt;int&gt; (m + 2, N + 1));
    for (int i = 0; i &lt; N; ++i) &#123;
        int x = R[i] + 1, y = C[i] + 1;
        id[x][y] = i + 1, pos[i + 1] = &#123; x, y &#125;;
    &#125;
    bld(1, 1, N);
    for (int i = 1; i &lt;= n; ++i)
        for (int j = 1; j &lt;= m; ++j)
            work(i, j, 1);
    return;
&#125;
int swap_seats(int i1, int i2) &#123;
    ++i1, ++i2;
    auto [x1, y1] = pos[i1];
    auto [x2, y2] = pos[i2];
    std::set&lt;std::pair&lt;int, int&gt; &gt; st;
    st.emplace(x1, y1);
    for (auto [fx, fy] : dir) &#123;
        int x = x1 + fx, y = y1 + fy;
        if (x &gt;= 1 &amp;&amp; x &lt;= n &amp;&amp; y &gt;= 1 &amp;&amp; y &lt;= m)
            st.emplace(x, y);
    &#125;
    st.emplace(x2, y2);
    for (auto [fx, fy] : dir) &#123;
        int x = x2 + fx, y = y2 + fy;
        if (x &gt;= 1 &amp;&amp; x &lt;= n &amp;&amp; y &gt;= 1 &amp;&amp; y &lt;= m)
            st.emplace(x, y);
    &#125;
    for (auto [x, y] : st)
        work(x, y, -1);
    std::swap(id[x1][y1], id[x2][y2]), std::swap(pos[i1], pos[i2]);
    for (auto [x, y] : st)
        work(x, y, 1);
    return t[1].u;
&#125;


D - 单旋
https://www.luogu.com.cn/problem/P3721

发现任意时刻参与旋转的都是最值，简单分析可以发现做的这件事情是把最值移到根，其他点相对关系不变，转化为维护深度
考虑新加入点，可以利用 BST 的性质，直接查询 \(x\) 的前驱、后继，则二者存在祖孙关系，把 \(x\) 接在矮的下面即可
考虑做一个先删再加的过程，删会影响儿子的深度（显然只有一侧儿子），加会影响全树深度


E - NEKAMELEONI
https://www.luogu.com.cn/problem/P7230
]]></content>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>杂题选谈</title>
    <url>/20250922/</url>
    <content><![CDATA[最近的几场 abc, arc, cf, 模拟赛题


G - Set list
https://atcoder.jp/contests/abc424/tasks/abc424_g

B - Slime Swap
https://atcoder.jp/contests/arc206/tasks/arc206_b

D - LIS ∩ LDS
https://atcoder.jp/contests/arc206/tasks/arc206_d

#3761. Bubble Sort
http://poj.org/problem?id=3761

F. Bubble Sort
https://codeforces.com/contest/2146/problem/F

E. Limited Edition Shop
https://codeforces.com/contest/2151/problem/E

构造几个 \(n=2,3\) 的例子手玩一下，会发现对于 \(a,b\) 两个元素，如果在 A 里的相对顺序是 ab，在 B 里的相对顺序是 ba，那么要选 b 就必须选 a。
那么会想到把 A 变成 \(1\sim n\)，那么对于 B 中的一个元素，如果其后方有更小的元素，那么必须选了它才能选这个数。
考虑在 B 中 DP 最后选出来的集合，那么对于当前的 \(x\)，若不选，则不允许『已选集合』中存在 \(&gt;x\) 的数。
故令 \(f_{i,j}\) 表示 DP 到 \(i\)，当前已选集合最大值为 \(j\) 的最大集合大小，那么有：
\[
f_{i,B_i}\gets f_{i-1,j}+v, j&lt;B_i\\
f_{i,j}\gets f_{i-1, j}+v, j &gt; B_i\\
f_{i,j}\gets f_{i-1,j}, j &lt; B_i
\]
显然可以线段树优化转移


#include &lt;bits/stdc++.h&gt;
const int maxn = 2e5 + 5;
const long long inf = 1e18;
struct &#123;
    int l, r;
    long long u, d;
&#125; t[maxn &lt;&lt; 2];
#define lt (p &lt;&lt; 1)
#define rt (lt | 1)
void pushval(int p, long long v) &#123;
    t[p].d += v, t[p].u += v;
    return;
&#125;
void pushdown(int p) &#123;
    pushval(lt, t[p].d), pushval(rt, t[p].d);
    t[p].d = 0ll;
    return;
&#125;
void pushup(int p) &#123;
    t[p].u = std::max(t[lt].u, t[rt].u);
    return;
&#125;
void bld(int p, int l, int r) &#123;
    t[p].l = l, t[p].r = r;
    t[p].u = -inf, t[p].d = 0ll;
    if (l == r)
        return;
    int mid = (t[p].l + t[p].r) &gt;&gt; 1;
    bld(lt, l, mid), bld(rt, mid + 1, r);
    return;
&#125;
void upd(int p, int x, long long v) &#123;
    t[p].u = std::max(t[p].u, v);
    if (t[p].l == t[p].r)
        return;
    pushdown(p);
    int mid = (t[p].l + t[p].r) &gt;&gt; 1;
    if (x &lt;= mid)
        upd(lt, x, v);
    else
        upd(rt, x, v);
    return;
&#125;
void add(int p, int l, int r, long long v) &#123;
    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r) &#123;
        pushval(p, v);
        return;
    &#125;
    pushdown(p);
    int mid = (t[p].l + t[p].r) &gt;&gt; 1;
    if (l &lt;= mid)
        add(lt, l, r, v);
    if (r &gt; mid)
        add(rt, l, r, v);
    pushup(p);
    return;
&#125;
long long ask(int p, int l, int r) &#123;
    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r)
        return t[p].u;
    pushdown(p);
    long long res = -inf;
    int mid = (t[p].l + t[p].r) &gt;&gt; 1;
    if (l &lt;= mid)
        res = ask(lt, l, r);
    if (r &gt; mid)
        res = std::max(res, ask(rt, l, r));
    return res;
&#125;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int T;
    for (std::cin &gt;&gt; T; T--; ) &#123;
        int n;
        std::cin &gt;&gt; n;
        std::vector&lt;int&gt; w(n + 1), k(n + 1), a(n + 1), b(n + 1), tab(n + 1);
        for (int i = 1; i &lt;= n; ++i)
            std::cin &gt;&gt; w[i];
        for (int i = 1; i &lt;= n; ++i)
            std::cin &gt;&gt; a[i], tab[a[i]] = i;
        for (int i = 1; i &lt;= n; ++i)
            k[i] = w[a[i]];
        for (int i = 1; i &lt;= n; ++i)
            std::cin &gt;&gt; b[i], b[i] = tab[b[i]];
        bld(1, 0, n), upd(1, 0, 0);
        for (int i = 1; i &lt;= n; ++i) &#123;
            if (b[i] != n)
                add(1, b[i] + 1, n, k[b[i]]);
            upd(1, b[i], ask(1, 0, b[i] - 1) + k[b[i]]);
        &#125;
        std::cout &lt;&lt; t[1].u &lt;&lt; &#39;\n&#39;;
    &#125;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;


A. 小猪盖房子
https://www.becoder.com.cn/problem/51898

给定一个 \(n\times m\) 的 01 矩阵，每一行有 2 个 1 或没有 1。现需选择两个相邻的行区间，并为范围内的空行选择两个位置改为 1，使得这两个区间是全等的。
求可能的方案。当空行的涂色方式不同或选择范围不同看作不同的方案。对 \(998244353\) 取模。
\(n,m\le 5000\)。


第一反应是枚举分界线 + 上端点，发现没有办法做：当上端点移动的时候，下部矩形会整体平移。
进一步考虑导致这个问题的原因，感受到一个因素是长度在变。
故固定长度枚举，前缀和统计 \(\dfrac {m(m-1)}2\) 的幂次即可。


#include &lt;bits/stdc++.h&gt;
const int mod = 998244353;
int main() &#123;
    std::freopen(&quot;piggy.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;piggy.out&quot;, &quot;w&quot;, stdout);
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
    const auto stime = std::chrono::steady_clock::now();
    int n, m;
    std::cin &gt;&gt; n &gt;&gt; m;
    std::vector&lt;std::array&lt;int, 2&gt; &gt; a(n + 1);
    std::vector&lt;long long&gt; ps(n + 1);
    const int s = m * (m - 1) / 2;
    ps[0] = 1ll;
    for (int i = 1; i &lt;= n; ++i) &#123;
        std::cin &gt;&gt; a[i][0] &gt;&gt; a[i][1];
        ps[i] = ps[i - 1] * s % mod;
    &#125;
    auto res = 0ll;
    for (int i = 1; i &lt;= n / 2; ++i) &#123;
        std::vector&lt;int&gt; cnt0(n + 1), cnts(n + 1);
        for (int u = 1; u &lt;= n - i; ++u) &#123;
            int d = u + i;
            if (!a[u][0] &amp;&amp; !a[d][0])
                cnts[u] = 1;
            else if (a[u][0] &amp;&amp; a[d][0] &amp;&amp; (a[u][0] != a[d][0] || a[u][1] != a[d][1]))
                cnt0[u] = 1;
            cnts[u] += cnts[u - 1], cnt0[u] += cnt0[u - 1];
        &#125;
        for (int u = 1; u &lt;= n - 2 * i + 1; ++u) &#123;
            int ss = cnts[u + i - 1] - cnts[u - 1], s0 = cnt0[u + i - 1] - cnt0[u - 1];
            if (!s0)
                (res += ps[ss] % mod) %= mod;
        &#125;
    &#125;
    std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
    return 0;
&#125;


B. 换乘旅行
https://www.becoder.com.cn/problem/51900

手玩可以发现『环』在题目中是一个很重要的东西
重要性质：考虑一个环第一次被访问的点，一定会从这个点出发把这个环访问一遍，反证法易证。
故可以把每个环给『删除』。可以用下图概括所有情况。

假设当前以 \(s\) 为起点，终点为 \(t\)，且之前已经在以 \(s&#39;\) 为起点时访问过了一部分路径上的点。
那么此时 \(m\to t\) 是有答案的，而 \(s\to m\) 都可以继承 \(m\) 的答案。


#include &lt;bits/stdc++.h&gt;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::freopen(&quot;travel.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;travel.out&quot;, &quot;w&quot;, stdout);
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n;
    std::cin &gt;&gt; n;
    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);
    std::vector&lt;std::vector&lt;int&gt;::iterator&gt; it(n + 1);
    for (int i = 1, k; i &lt;= n; ++i) &#123;
        std::cin &gt;&gt; k;
        for (int x; k--; )
            std::cin &gt;&gt; x, g[i].push_back(x);
        it[i] = g[i].begin();
    &#125;
    std::vector&lt;int&gt; res(n + 1), inq(n + 1);
    for (int i = 1; i &lt;= n; ++i)
        if (!res[i]) &#123;
            std::stack&lt;int&gt; st;
            for (int x = i; ; ) &#123;
                if (it[x] == g[x].end() || res[x]) &#123;
                    if (!res[x])
                        res[x] = x;
                    res[i] = res[x];
                    for (; !st.empty(); st.pop())
                        res[st.top()] = res[x], inq[st.top()] = 0;
                    break;
                &#125;
                st.push(x), inq[x] = 1, x = *it[x];
                if (inq[x])
                    for (int p = -1; p != x; ) &#123;
                        p = st.top(), st.pop();
                        inq[p] = 0, ++it[p];
                    &#125;
            &#125;
        &#125;
    for (int i = 1; i &lt;= n; ++i)
        std::cout &lt;&lt; res[i] &lt;&lt; &#39;\n&#39;;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;


C. 优美的街景
no link

给定 \(n\) 的排列 \(a_{1\cdots n}\)，现定义『优美子段』\([l,r]\)：存在 \(l\le t&lt;r\)，使得 \(\max\{a_{l\sim t}\}&lt;\min\{a_{t+1\sim r}\}\)。
求出该排列『优美子段』的个数，\(n\le 3\times 10^5\)。


由经典 trick 出发，一个想法是从小到大枚举分解值 \(v\)，并把 \(\le v\) 的值涂成白色，剩下的涂成黑色。
那么此时一个前白后黑的子段是优美的。
令值为 \(v\) 的元素必须参与子段组成。枚举 \(v\) 时，序列每个点颜色已知，即 \(v\) 所在的优美子段被包含于 \(v\) 所在的白黑子段中。
求出该子段，则包含 \(v\) 的优美子段，左右端点各有范围，且不会相互影响。
此时不可直接计数：一个优美子段会被其中所有合法分割点统计。故做一个 亚特兰蒂斯 即可。
如果像我一样没有甚区间问题经验，可以用 0 覆盖次数这个 trick 来反向求。因而被群嘲了


#include &lt;bits/stdc++.h&gt;
const int maxn = 3e5 + 5;
struct &#123;
    int l, r, mn, u, d;
&#125; t[maxn &lt;&lt; 2];
#define lt (p &lt;&lt; 1)
#define rt (lt | 1)
void bld(int p, int l, int r) &#123;
    t[p].l = l, t[p].r = r;
    t[p].u = r - l + 1;
    if (l == r)
        return;
    int mid = (l + r) &gt;&gt; 1;
    bld(lt, l, mid), bld(rt, mid + 1, r);
    return;
&#125;
void pushval(int p, int v) &#123;
    t[p].d += v, t[p].mn += v;
    return;
&#125;
void pushdown(int p) &#123;
    pushval(lt, t[p].d), pushval(rt, t[p].d);
    t[p].d = 0;
    return;
&#125;
void pushup(int p) &#123;
    t[p].u = 0;
    t[p].mn = std::min(t[lt].mn, t[rt].mn);
    if (t[lt].mn == t[p].mn)
        t[p].u = t[lt].u;
    if (t[rt].mn == t[p].mn)
        t[p].u += t[rt].u;
    return;
&#125;
void add(int p, int l, int r, int v) &#123;
    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r) &#123;
        pushval(p, v);
        return;
    &#125;
    pushdown(p);
    int mid = (t[p].l + t[p].r) &gt;&gt; 1;
    if (l &lt;= mid)
        add(lt, l, r, v);
    if (r &gt; mid)
        add(rt, l, r, v);
    pushup(p);
    return;
&#125;
#undef lt
#undef rt
int main() &#123;
    std::freopen(&quot;street.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;street.out&quot;, &quot;w&quot;, stdout);
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
    const auto stime = std::chrono::steady_clock::now();
    int n;
    std::cin &gt;&gt; n;
    std::vector&lt;int&gt; a(n + 1), tab(n + 1);
    std::vector&lt;std::vector&lt;int&gt; &gt; mn(20, std::vector&lt;int&gt; (n + 1)), mx(20, std::vector&lt;int&gt; (n + 1));
    for (int i = 1; i &lt;= n; ++i) &#123;
        std::cin &gt;&gt; a[i];
        tab[a[i]] = i, mn[0][i] = mx[0][i] = a[i];
    &#125;
    for (int j = 1; (1 &lt;&lt; j) &lt;= n; ++j)
        for (int i = 1; i + (1 &lt;&lt; j) - 1 &lt;= n; ++i) &#123;
            mn[j][i] = std::min(mn[j - 1][i], mn[j - 1][i + (1 &lt;&lt; (j - 1))]);
            mx[j][i] = std::max(mx[j - 1][i], mx[j - 1][i + (1 &lt;&lt; (j - 1))]);
        &#125;
    auto askmn = [&amp;](int l, int r) &#123;
        int k = std::__lg(r - l + 1);
        return std::min(mn[k][l], mn[k][r - (1 &lt;&lt; k) + 1]);
    &#125;;
    auto askmx = [&amp;](int l, int r) &#123;
        int k = std::__lg(r - l + 1);
        return std::max(mx[k][l], mx[k][r - (1 &lt;&lt; k) + 1]);
    &#125;;
    auto res = 0ll;
    std::vector&lt;std::vector&lt;std::tuple&lt;int, int, int&gt; &gt; &gt; t(n + 1);
    auto ask1 = [&amp;](int x, int v) &#123; // 找到 x 左侧最后一个 &lt;= v 的
        int res = x;
        for (int l = 1, r = x, mid; l &lt;= r; ) &#123;
            mid = (l + r) &gt;&gt; 1;
            if (askmx(mid, x) &lt;= v)
                r = mid - 1, res = mid;
            else
                l = mid + 1;
        &#125;
        return res;
    &#125;;
    auto ask2 = [&amp;](int x, int v) &#123; // 找到 x 右侧第一个 &gt; v 的
        int res = -1;
        for (int l = x + 1, r = n, mid; l &lt;= r; ) &#123;
            mid = (l + r) &gt;&gt; 1;
            if (askmx(x, mid) &gt; v)
                r = mid - 1, res = mid;
            else
                l = mid + 1;
        &#125;
        return res;
    &#125;;
    auto ask3 = [&amp;](int x, int v) &#123; // 找到 x 右侧最后一个 &gt; v 的
        int res = x;
        for (int l = x, r = n, mid; l &lt;= r; ) &#123;
            mid = (l + r) &gt;&gt; 1;
            if (askmn(x, mid) &gt; v)
                l = mid + 1, res = mid;
            else
                r = mid - 1;
        &#125;
        return res;
    &#125;;
    for (int i = 1; i &lt;= n; ++i) &#123;
        int cr = ask1(tab[i], i), tl = ask2(tab[i], i);
        if (tl != -1) &#123;
            int tr = ask3(tl, i);
            t[cr].emplace_back(1, tl, tr);
            if (tab[i] != n)
                t[tab[i] + 1].emplace_back(-1, tl, tr);
        &#125;
    &#125;
    bld(1, 0, n);
    std::vector&lt;int&gt; cnt(n + 1);
    for (int i = 1; i &lt;= n; ++i) &#123;
        std::sort(t[i].begin(), t[i].end(), std::greater&lt;std::tuple&lt;int, int, int&gt; &gt; ());
        for (auto [k, l, r] : t[i])
            add(1, l, r, k);
        res += n + 1 - ::t[1].u;
    &#125;
    std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
    return 0;
&#125;

]]></content>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>杂题选谈：最短路</title>
    <url>/20250924/</url>
    <content><![CDATA[最短路为背景的题 + 做法是最短路的题


A - Minimum Path
https://www.luogu.com.cn/problem/CF1473E

经典套路，发现可以把 max 和 min 换成任意路径中的边，然后 max 和 min 就会最小化这个式子
故写一个 Dijkstra + DP，求这个式子的最小值即可


#include &lt;bits/stdc++.h&gt;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, m;
    std::cin &gt;&gt; n &gt;&gt; m;
    using arr = std::vector&lt;long long&gt;;
    using brr = std::vector&lt;arr&gt;;
    std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; g(n + 1);
    std::vector&lt;brr&gt; dis(2, brr(2, arr(n + 1, 1e18))), vis(2, brr(2, arr(n + 1)));
    for (int x, y, w; m--; ) &#123;
        std::cin &gt;&gt; x &gt;&gt; y &gt;&gt; w;
        g[x].emplace_back(y, w);
        g[y].emplace_back(x, w);
    &#125;
    dis[0][0][1] = 0;
    std::array&lt;std::array&lt;std::priority_queue&lt;std::pair&lt;long long, int&gt; &gt;, 2&gt;, 2&gt; q;
    q[0][0].emplace(0, 1);
    for (int i = 0; i &lt; 2; ++i) &#123;
        for (int j = 0; j &lt; 2; ++j) &#123;
            for (; !q[i][j].empty(); ) &#123;
                int f = q[i][j].top().second;
                q[i][j].pop();
                if (vis[i][j][f])
                    continue;
                vis[i][j][f] = 1;
                for (auto k : g[f]) &#123;
                    if (dis[i][j][k.first] &gt; dis[i][j][f] + k.second) &#123;
                        dis[i][j][k.first] = dis[i][j][f] + k.second;
                        q[i][j].emplace(-dis[i][j][k.first], k.first);
                    &#125;
                    if (!i &amp;&amp; dis[1][j][k.first] &gt; dis[i][j][f]) &#123;
                        dis[1][j][k.first] = dis[i][j][f];
                        q[1][j].emplace(-dis[1][j][k.first], k.first);
                    &#125;
                    if (!j &amp;&amp; dis[i][1][k.first] &gt; dis[i][j][f] + 2 * k.second) &#123;
                        dis[i][1][k.first] = dis[i][j][f] + 2 * k.second;
                        q[i][1].emplace(-dis[i][1][k.first], k.first);
                    &#125;
                &#125;
            &#125;
        &#125;
    &#125;
    for (int i = 2; i &lt;= n; ++i)
        std::cout &lt;&lt; std::min(&#123; dis[0][0][i], dis[1][1][i] &#125;) &lt;&lt; &#39; &#39;;
    std::cout &lt;&lt; &#39;\n&#39;;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;


B - Train Delay
https://vjudge.net/contest/750645#problem/B

简化题目很重要的一个转化是由于 \(S\le T\) 带来的 \(S\) 和 \(T\) 地位平等，考虑把出发和到达分别看作一次事件处理。
按照所有事件的发生时刻排序，有：

对于一次出发事件，可以得到在其之前该站点所有到达事件的 \(\max\{T&#39;\}\)，用之更新 \(X\) 即可。
对于一次到达事件，由于对应的 \(X\) 已经确定，更新该站点当前最大值即可。



#include &lt;bits/stdc++.h&gt;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, m;
    std::cin &gt;&gt; n &gt;&gt; m;
    std::vector&lt;int&gt; d(m + 1);
    std::cin &gt;&gt; d[1];
    struct event &#123;
        int t, op, id, x;
    &#125;;
    std::vector&lt;event&gt; a;
    std::vector&lt;int&gt; mx(n + 1);
    for (int i = 1, x, y, s, t; i &lt;= m; ++i) &#123;
        std::cin &gt;&gt; x &gt;&gt; y &gt;&gt; s &gt;&gt; t;
        a.push_back(&#123; s, 0, i, x &#125;);
        a.push_back(&#123; t, 1, i, y &#125;);
    &#125;
    std::sort(a.begin(), a.end(), [&amp;](event &amp;x, event &amp;y) &#123; return x.t == y.t ? x.op &gt; y.op : x.t &lt; y.t; &#125;);
    for (auto [t, op, id, x] : a)
        if (op == 1)
            mx[x] = std::max(mx[x], t + d[id]);
        else if (id != 1)
            d[id] = std::max(mx[x] - t, 0);
    for (int i = 2; i &lt;= m; ++i)
        std::cout &lt;&lt; d[i] &lt;&lt; &#39; &#39;;
    std::cout &lt;&lt; &#39;\n&#39;;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;


C - Complete The Graph
https://www.luogu.com.cn/problem/CF715B
神仙二分

如果初始把所有白边置为 \(1\)，那么会想到调整法构造
但是不知道应该在哪些边上调整，确定调整多少似乎也没有什么简单的做法
故平均用力，构造一个 边1 += 1，边2 += 1，边3 += 1, …, 边cnt0 += 1, 边1 += 1, 边2 += 1, … 的操作序列
容易发现每次操作最多让当前最短路长度增加 1，而且有单调性
故二分答案即可


#include &lt;bits/stdc++.h&gt;
const __int128 inf = 1e18;
const __int128 inff = 1e23;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, m, s, t, l, cnt = 0;
    std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; l &gt;&gt; s &gt;&gt; t, ++s, ++t;
    std::vector&lt;std::tuple&lt;int, int, long long&gt; &gt; u(m + 1);
    std::vector&lt;std::vector&lt;std::pair&lt;int, long long&gt; &gt; &gt; g(n + 1);
    for (int i = 1, x, y; i &lt;= m; ++i) &#123;
        long long w;
        std::cin &gt;&gt; x &gt;&gt; y &gt;&gt; w, ++x, ++y;
        if (w == 0)
            w = -(++cnt);
        g[x].emplace_back(y, w), g[y].emplace_back(x, w);
        u[i] = &#123; x, y, w &#125;;
    &#125;
    std::vector&lt;int&gt; vis(n + 1);
    std::vector&lt;__int128&gt; dis(n + 1);
    std::vector&lt;long long&gt; k(cnt + 1);
    __int128 res = -1;
    auto check = [&amp;](__int128 x) &#123;
        for (int i = 1; i &lt;= cnt; ++i)
            k[i] = x / cnt + (i &lt;= x % cnt);
        std::fill(vis.begin() + 1, vis.end(), 0);
        std::fill(dis.begin() + 1, dis.end(), inf);
        std::priority_queue&lt;std::pair&lt;__int128, int&gt; &gt; q;
        dis[s] = 0, q.emplace(0, s);
        for (; !q.empty(); ) &#123;
            int f = q.top().second;
            q.pop();
            if (vis[f])
                continue;
            vis[f] = 1;
            for (auto [v, w] : g[f]) &#123;
                if (w &lt; 0)
                    w = k[-w];
                if (dis[v] &gt; dis[f] + w) &#123;
                    dis[v] = dis[f] + w;
                    q.emplace(-dis[v], v);
                &#125;
            &#125;
        &#125;
        return dis[t] &lt;= l;
    &#125;;
    for (__int128 l = cnt, r = cnt * inf, mid; l &lt;= r; ) &#123;
        mid = (l + r) &gt;&gt; 1;
        if (check(mid))
            res = mid, l = mid + 1;
        else
            r = mid - 1;
    &#125;
    if (res == -1)
        std::cout &lt;&lt; &quot;NO\n&quot;;
    else &#123;
        check(res);
        if (dis[t] != l)
            std::cout &lt;&lt; &quot;NO\n&quot;;
        else &#123;
            std::cout &lt;&lt; &quot;YES\n&quot;;
            for (int i = 1; i &lt;= m; ++i) &#123;
                auto [x, y, w] = u[i];
                if (w &lt; 0)
                    w = k[-w];
                std::cout &lt;&lt; x - 1 &lt;&lt; &#39; &#39; &lt;&lt; y - 1 &lt;&lt; &#39; &#39; &lt;&lt; w &lt;&lt; &#39;\n&#39;;
            &#125;
        &#125;
    &#125;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;


A - 重力球
https://www.luogu.com.cn/problem/P7473

\(m\) 相对很小，看看有没有什么基于 \(m\) 的做法
每次球停下的位置一定是某个障碍物（或边界）上 / 下 / 左 / 右的格子，故可以在这 \(O(n + m)\) 个点上建图
怎么同时维护两个球的信息呢，发现 \(m\) 还是很小，所以可以把两个球塞一起作为一个状态
\(m^2\) 次 Dij 还是太激进了 进一步思考发现可能的终点共 \(m\) 个 并且彼此不区分
故以这 \(m\) 个终点跑多源最短路即可
但 5e6 跑 Dij 还是太勉强了。发现边权为 1，为什么不 BFS 呢 😅
发现起点可能不在我们限定的点上，但可以人为选择一次重力方向，然后就回到刚刚的问题了
或者离线也是一种方法

疑似常数太大，拼尽全力勉强卡过

#include &lt;bits/stdc++.h&gt;
const int LEN = (1 &lt;&lt; 20);
#ifdef ONLINE_JUDGE
inline int nec(void) &#123;
    static char buf[LEN], *p = buf, *e = buf;
    if (p == e) &#123;
        e = buf + fread(buf, 1, LEN, stdin);
        if (e == buf)
            return EOF;
        p = buf;
    &#125;
    return *p++;
&#125;
#else
#define nec getchar
#endif
inline bool read(int &amp;x) &#123;
    x = 0;
    bool f = 0;
    char ch = nec();
    while (ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123;
        if (ch == EOF)
            return 0;
        if (ch == &#39;-&#39;)
            f = 1;
        ch = nec();
    &#125;
    while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) &#123;
        x = x * 10 + ch - &#39;0&#39;;
        ch = nec();
    &#125;
    if (f)
        x = -x;
    return 1;
&#125;
void print(int x) &#123;
    if (x &lt; 0) &#123;
        putchar(&#39;-&#39;);
        x = -x;
    &#125;
    if (x &gt;= 10)
        print(x / 10);
    putchar(x % 10 + &#39;0&#39;);
    return;
&#125;
void print(int x, char ch) &#123;
    print(x);
    putchar(ch);
    return;
&#125;
const int inf = 0x3f3f3f3f;
const int dir[][2] = &#123;&#123; -1, 0 &#125;, &#123; 1, 0 &#125;, &#123; 0, -1 &#125;, &#123; 0, 1 &#125;&#125;;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, m, q;
    read(n), read(m), read(q);
    std::vector&lt;std::pair&lt;int, int&gt; &gt; pos(m + 1);
    std::vector&lt;std::vector&lt;int&gt; &gt; a(n + 1, std::vector&lt;int&gt; (n + 1));
    for (int i = 1, x, y; i &lt;= m; ++i) &#123;
        read(x), read(y);
        pos[i] = &#123; x, y &#125;, a[x][y] = -1;
    &#125;
    for (int i = 1; i &lt;= n; ++i)
        pos.emplace_back(0, i), ++m;
    for (int i = 1; i &lt;= n; ++i)
        pos.emplace_back(i, n + 1), ++m;
    for (int i = 1; i &lt;= n; ++i)
        pos.emplace_back(n + 1, i), ++m;
    for (int i = 1; i &lt;= n; ++i)
        pos.emplace_back(i, 0), ++m;
    int cnt = 0;
    std::vector&lt;std::pair&lt;int, int&gt; &gt; u(1);
    for (int i = 1; i &lt;= m; ++i)
        for (auto [fx, fy] : dir) &#123;
            int nx = pos[i].first + fx, ny = pos[i].second + fy;
            if (nx &gt;= 1 &amp;&amp; nx &lt;= n &amp;&amp; ny &gt;= 1 &amp;&amp; ny &lt;= n &amp;&amp; !a[nx][ny])
                a[nx][ny] = ++cnt, u.emplace_back(nx, ny);
        &#125;
    std::vector&lt;std::vector&lt;std::array&lt;int, 4&gt; &gt; &gt; top(n + 1, std::vector&lt;std::array&lt;int, 4&gt; &gt; (n + 1));
    for (int j = 1; j &lt;= n; ++j) &#123;
        for (int i = 1; i &lt;= n; ++i)
            if (a[i][j] != -1) &#123;
                if (i == 1 || a[i - 1][j] == -1)
                    top[i][j][0] = a[i][j];
                else
                    top[i][j][0] = top[i - 1][j][0];
            &#125;
        for (int i = n; i; --i)
            if (a[i][j] != -1) &#123;
                if (i == n || a[i + 1][j] == -1)
                    top[i][j][1] = a[i][j];
                else
                    top[i][j][1] = top[i + 1][j][1];
            &#125;
    &#125;
    for (int i = 1; i &lt;= n; ++i) &#123;
        for (int j = 1; j &lt;= n; ++j)
            if (a[i][j] != -1) &#123;
                if (j == 1 || a[i][j - 1] == -1)
                    top[i][j][2] = a[i][j];
                else
                    top[i][j][2] = top[i][j - 1][2];
            &#125;
        for (int j = n; j; --j)
            if (a[i][j] != -1) &#123;
                if (j == n || a[i][j + 1] == -1)
                    top[i][j][3] = a[i][j];
                else
                    top[i][j][3] = top[i][j + 1][3];
            &#125;
    &#125;
    const int N = cnt * cnt;
    std::vector&lt;std::vector&lt;int&gt; &gt; g(N + 1);
    auto encode = [&amp;](int x, int y) &#123;
        return (x - 1) * cnt + y;
    &#125;;
    auto decode = [&amp;](int id) &#123;
        return std::make_pair((id - 1) / cnt + 1, (id - 1) % cnt + 1);
    &#125;;
    for (int i = 1; i &lt;= N; ++i)
        for (int j = 0; j &lt; 4; ++j) &#123;
            auto [a, b] = decode(i);
            g[encode(top[u[a].first][u[a].second][j], top[u[b].first][u[b].second][j])].emplace_back(i);
        &#125;
    std::vector&lt;int&gt; dis(N + 1, inf), vis(N + 1);
    &#123;
        std::queue&lt;int&gt; q;
        for (int i = 1; i &lt;= cnt; ++i)
            dis[encode(i, i)] = 0, q.push(encode(i, i)), vis[encode(i, i)] = 1;
        for (; !q.empty(); ) &#123;
            int x = q.front();
            q.pop();
            for (auto i : g[x])
                if (!vis[i])
                    dis[i] = dis[x] + 1, vis[i] = 1, q.push(i);
        &#125;
    &#125;
    for (int a, b, c, d; q--; ) &#123;
        read(a), read(b), read(c), read(d);
        if (a == c &amp;&amp; b == d)
            print(0, &#39;\n&#39;);
        else &#123;
            int res = inf;
            for (int j = 0; j &lt; 4; ++j)
                res = std::min(res, dis[encode(top[a][b][j], top[c][d][j])] + 1);
            if (res == inf)
                print(-1, &#39;\n&#39;);
            else
                print(res, &#39;\n&#39;);
        &#125;
    &#125;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;


B - 矩阵游戏
https://www.luogu.com.cn/problem/P7515

把问题形式化一下，现在有 \(n\times m\) 个未知数和 \((n-1)\times (m-1)\) 个方程
那么可以对边上一圈任意赋值，限制是左上角这 \((n-1)\times (m-1)\) 个未知数必须落在 \([0,10^6]\) 上
有一个很容易观察到的性质，对于一个 \(a\)，选取一个 \(v\)，并把棋盘黑白染色，那么把所有黑格 \(+=v\)，白格 \(-=v\)，对应的 \(b\) 是不会变的。
这个操作是涉及全局的，太苛刻了，有没有什么更 mild 的构造？
发现只对一行 / 列黑白染色并操作也可以得到相同的结果。能感受到操作无法再简化了。考虑用这个版本的操作调整。
故大力令周围一圈的临时解 \(a&#39;\) 为 \(0\)，令每行、列的调整 delta 为 \(r_i,c_i\)，可以得到若干个关于 \(0\) 和 \(10^6\) 的约束。最后建出来一个完全二分图状物，跑差分约束即可，容易发现复杂度正确。
实现技巧：规划一下 \(r\) 和 \(c\) 的染色方式，使得它们错开，可以把所有位置都写作 \(a&#39;_{i,j}+c-r\) 或 \(a&#39;_{i,j}+r-c\) 的形式，便于差分约束





C - Tax
https://www.luogu.com.cn/problem/P6822

容易想到分类讨论，如果钦定是入边贡献边权，那么出边边权不能大于入边边权；否则，出边贡献边权。
考虑把每个点上的出边按边权从小到大排序，显然需要入边贡献的是一段前缀，需要出边贡献的是一段后缀，就可以做一个前后缀优化建图。


#include &lt;bits/stdc++.h&gt;
const long long inf = 1e18;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, m;
    std::cin &gt;&gt; n &gt;&gt; m;
    struct edge &#123; int v, w, id, pi, si; &#125;;
    std::vector&lt;std::vector&lt;edge&gt; &gt; g1(n + 2);
    std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; g(1);
    int cnt = 0;
    for (int x, y, w; m--; ) &#123;
        std::cin &gt;&gt; x &gt;&gt; y &gt;&gt; w;
        g1[x].push_back(&#123; y, w, ++cnt, 0, 0 &#125;);
        g1[y].push_back(&#123; x, w, ++cnt, 0, 0 &#125;);
        g.emplace_back(), g.emplace_back();
    &#125;
    int s = ++cnt, t = ++cnt;
    g1[0].push_back(&#123; 1, 0, s, 0, 0 &#125;), g1[n].push_back(&#123; n + 1, 0, t, 0, 0 &#125;);
    g.emplace_back(), g.emplace_back();
    for (int i = 0; i &lt;= n + 1; ++i)
        if (!g1[i].empty()) &#123;
            std::sort(g1[i].begin(), g1[i].end(), [&amp;](edge &amp;x, edge &amp;y) &#123; return x.w &lt; y.w; &#125;);
            for (int j = 0; j &lt; (int)g1[i].size(); ++j) &#123;
                g1[i][j].pi = ++cnt, g.emplace_back();
                if (j != 0)
                    g[cnt].emplace_back(cnt - 1, 0);
                g[cnt].emplace_back(g1[i][j].id, 0);
            &#125;
            for (int j = (int)g1[i].size() - 1; ~j; --j) &#123;
                g1[i][j].si = ++cnt, g.emplace_back();
                if (j != (int)g1[i].size() - 1)
                    g[cnt].emplace_back(cnt - 1, 0);
                g[cnt].emplace_back(g1[i][j].id, g1[i][j].w);
            &#125;
        &#125;
    for (int i = 0; i &lt;= n + 1; ++i)
        for (auto &amp;[v, w, id, pi, si] : g1[i]) &#123;
            auto to = std::upper_bound(g1[v].begin(), g1[v].end(), w, [&amp;](int x, edge &amp;y) &#123; return x &lt; y.w; &#125;);
            if (to != g1[v].end())
                g[id].emplace_back(to-&gt;si, 0);
            if (to != g1[v].begin())
                g[id].emplace_back((--to)-&gt;pi, w);
        &#125;
    std::vector&lt;int&gt; vis(cnt + 1, 0);
    std::vector&lt;long long&gt; dis(cnt + 1, inf);
    std::priority_queue&lt;std::pair&lt;long long, int&gt; &gt; q;
    dis[s] = 0, q.emplace(0, s);
    for (; !q.empty(); ) &#123;
        int f = q.top().second;
        q.pop();
        if (vis[f])
            continue;
        vis[f] = 1;
        for (auto [v, w] : g[f])
            if (dis[v] &gt; dis[f] + w) &#123;
                dis[v] = dis[f] + w;
                q.emplace(-dis[v], v);
            &#125;
    &#125;
    std::cout &lt;&lt; dis[t] &lt;&lt; &#39;\n&#39;;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;


D - Travelling Through the Snow Queen’s Kingdom
https://www.luogu.com.cn/problem/CF685E
目前见过的数据范围提示性极弱（误导性极强）的循环结构题：

[BZOJ3620] 似乎在梦中见过的样子
字符合并
[ARC205E] Subset Product Problem

正赛因为有部分分，应该不会出现不敢写的问题

考虑离线询问，逆序加边；原文无边权；边的通行时刻只决定到达点的时刻。
借鉴 merchant 中的思路，只需要更新当前边两侧点为起点的 DP 数组。
需要注意边从某种意义上说是『有向』的。


#include &lt;bits/stdc++.h&gt;
const int inf = 0x3f3f3f3f;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, m, q;
    std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;
    struct query &#123; int r, s, t, id; &#125;;
    std::vector&lt;int&gt; res(q + 1);
    std::vector&lt;std::vector&lt;query&gt; &gt; u(m + 1);
    std::vector&lt;std::pair&lt;int, int&gt; &gt; e(m + 1);
    for (int i = 1; i &lt;= m; ++i)
        std::cin &gt;&gt; e[i].first &gt;&gt; e[i].second;
    for (int i = 1, l, r, s, t; i &lt;= q; ++i) &#123;
        std::cin &gt;&gt; l &gt;&gt; r &gt;&gt; s &gt;&gt; t;
        u[l].push_back(&#123; r, s, t, i &#125;);
    &#125;
    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1, std::vector&lt;int&gt; (n + 1, inf));
    for (int i = m; i; --i) &#123;
        auto [x, y] = e[i];
        g[x][y] = g[y][x] = i;
        for (int j = 1; j &lt;= n; ++j)
            g[x][j] = g[y][j] = std::min(g[x][j], g[y][j]);
        for (auto [r, s, t, id] : u[i])
            if (g[s][t] &lt;= r)
                res[id] = 1;
    &#125;
    for (int i = 1; i &lt;= q; ++i)
        std::cout &lt;&lt; (res[i] ? &quot;Yes&quot; : &quot;No&quot;) &lt;&lt; &#39;\n&#39;;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;


E - Culture Code
https://www.luogu.com.cn/problem/CF1197E

先按 \(out\) 排序，做一个前缀优化建图。
容易发现除了最外层，每一个套娃都会提供 \(in_i-out_i\) 的代价，而最外层会提供 \(in_x\) 的代价。
好在要求的是最长路，这样就可以 Dij 了，并不需要真正把图建出来，发现这个形式更序列，直接在序列上二分前缀 + DP 即可。
求方案是容易的。最后统计 DP 值最大，且不能被其他套娃包含的元素即可。
Tip：在求解过程中并不用考虑当前元素和前缀 min 元素间能否加入其他套娃，因为保证 \(out&gt;in\)，如果存在这样的套娃，其 DP 值会比前缀 min 更小，矛盾。


#include &lt;bits/stdc++.h&gt;
const int mod = 1e9 + 7;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n;
    std::cin &gt;&gt; n;
    std::vector&lt;std::pair&lt;int, int&gt; &gt; a(n + 1);
    int mxi = 0;
    for (int i = 1; i &lt;= n; ++i) &#123;
        std::cin &gt;&gt; a[i].first &gt;&gt; a[i].second;
        mxi = std::max(mxi, a[i].second);
    &#125;
    std::sort(a.begin() + 1, a.end());
    std::vector&lt;long long&gt; g(n + 1), mxg(n + 1), f(n + 1), mx(n + 1);
    for (int i = 1; i &lt;= n; ++i) &#123;
        int j = std::upper_bound(a.begin() + 1, a.begin() + i, std::make_pair(a[i].second, 0x3f3f3f3f)) - a.begin() - 1;
        if (j == 0)
            f[i] = a[i].second, g[i] = 1ll;
        else
            f[i] = mx[j] + a[i].second, g[i] = mxg[j];
        long long now = f[i] - a[i].first;
        if (now &lt; mx[i - 1])
            mx[i] = now, mxg[i] = g[i];
        else if (now == mx[i - 1])
            mx[i] = now, mxg[i] = (mxg[i - 1] + g[i]) % mod;
        else
            mx[i] = mx[i - 1], mxg[i] = mxg[i - 1];
    &#125;
    auto now = 0x3f3f3f3fll, res = 0ll;
    for (int i = 1; i &lt;= n; ++i) &#123;
        if (a[i].first &lt;= mxi)
            continue;
        if (f[i] &lt; now)
            now = f[i], res = g[i];
        else if (f[i] == now)
            (res += g[i]) %= mod;
    &#125;
    std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;


A - Awesome Arrowland Adventure
https://www.luogu.com.cn/problem/P6233

没什么好说的建图，注意只能顺时针转
代码略


B - 地铁线路
https://www.luogu.com.cn/problem/P6096

考虑做一个神秘拆点，把每个点附上线路和运行方向的信息（所以是单向的）
认为路径代价是二元组，那么同条线路中的点通行代价为 \((0,-1)\)
换乘需要优化建图，每个点可以花 \((0,0)\) 的代价走到这个点的『换乘点』，再花 \((1,0)\) 的代价走到另一个分点
但 15 年的时候 SPFA 已经死了，所以需要好好考虑怎么实现最短路。
分两问是有提示性在的，可以想到 01 BFS 解决第一个关键字，比较对的想法是把所有最短路拿出来形成 DAG，在 DAG 上对第二关键字 DP。


#include &lt;bits/stdc++.h&gt;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, m;
    std::cin &gt;&gt; m &gt;&gt; n;
    std::unordered_map&lt;std::string, int&gt; tab;
    std::vector&lt;std::vector&lt;int&gt; &gt; l(n + 1);
    std::vector&lt;std::vector&lt;std::tuple&lt;int, int, int&gt; &gt; &gt; g0(n + 1), g1(n + 1);
    for (int i = 1; i &lt;= n; ++i) &#123;
        std::string s;
        std::cin &gt;&gt; s, tab[s] = i;
    &#125;
    int tot = n;
    for (int i = 1, k; i &lt;= m; ++i) &#123;
        std::cin &gt;&gt; k;
        int lp = 0, lq = 0;
        for (std::string s; k--; ) &#123;
            std::cin &gt;&gt; s;
            int p = ++tot, q = ++tot, id = tab[s];
            g0.emplace_back(), g0.emplace_back();
            g1.emplace_back(), g1.emplace_back();
            if (lp) &#123;
                g0[p].emplace_back(lp, 0, 1), g0[lq].emplace_back(q, 0, 1);
                g1[lp].emplace_back(p, 0, 1), g1[q].emplace_back(lq, 0, 1);
            &#125;
            g0[p].emplace_back(id, 0, 0), g0[id].emplace_back(p, 1, 0);
            g1[id].emplace_back(p, 0, 0), g1[p].emplace_back(id, 1, 0);
            g0[q].emplace_back(id, 0, 0), g0[id].emplace_back(q, 1, 0);
            g1[id].emplace_back(q, 0, 0), g1[q].emplace_back(id, 1, 0);
            l[id].push_back(p), l[id].push_back(q);
            lp = p, lq = q;
        &#125;
    &#125;
    int s, t;
    &#123;
        std::string s1, s2;
        std::cin &gt;&gt; s1 &gt;&gt; s2;
        s = ++tot, t = tab[s2];
        g0.emplace_back(), g1.emplace_back();
        int p = tab[s1];
        for (auto i : l[p])
            g0[s].emplace_back(i, 1, 0), g1[i].emplace_back(s, 1, 0);
    &#125;
    std::vector&lt;int&gt; dis0(tot + 1, 0x3f3f3f3f), dis1(tot + 1, 0x3f3f3f3f);
    auto BFS = [&amp;](decltype(g0) &amp;g, decltype(dis0) &amp;dis, int s) &#123;
        std::deque&lt;int&gt; q;
        std::vector&lt;int&gt; vis(tot + 1);
        q.push_back(s), dis[s] = 0;
        for (; !q.empty(); ) &#123;
            int x = q.front();
            q.pop_front();
            if (vis[x])
                continue;
            vis[x] = 1;
            for (auto [v, w1, w2] : g[x])
                if (dis[x] + w1 &lt; dis[v]) &#123;
                    dis[v] = dis[x] + w1;
                    if (w1 == 0)
                        q.push_front(v);
                    else
                        q.push_back(v);
                &#125;
        &#125;
        return;
    &#125;;
    BFS(g0, dis0, s), BFS(g1, dis1, t);
    std::cout &lt;&lt; dis0[t] &lt;&lt; &#39;\n&#39;;
    std::vector&lt;int&gt; deg(tot + 1);
    std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; g(tot + 1);
    for (int i = 1; i &lt;= tot; ++i)
        for (auto [j, w1, w2] : g0[i])
            if (dis0[i] + dis1[j] + w1 == dis0[t])
                g[i].emplace_back(j, w2), ++deg[j];
    std::queue&lt;int&gt; q;
    for (int i = 1; i &lt;= tot; ++i)
        if (!deg[i])
            q.push(i);
    std::vector&lt;int&gt; f(tot + 1);
    for (; !q.empty(); ) &#123;
        int x = q.front();
        q.pop();
        for (auto [v, w] : g[x]) &#123;
            f[v] = std::max(f[v], f[x] + w);
            if (!--deg[v])
                q.push(v);
        &#125;
    &#125;
    std::cout &lt;&lt; f[t] &lt;&lt; &#39;\n&#39;;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;


C - Droga do domu
https://www.luogu.com.cn/problem/P9402

还是做一个和上一题类似的优化建图
此外就是一个普通的 Dij 上 DP 了。图没有环，直接拓扑即可。
可以滚动优化空间，但似乎并无必要。代码略。


D - Tickets P
https://www.luogu.com.cn/problem/P7984

没什么好说的线段树优化建图，难点在于如何同时获取 \(1\) 和 \(N\) 的信息
发现从某个点走到 \(1\) 和 \(N\)，有一种不劣的走法：

维护一下每个点单独走到 \(1\)，\(N\) 的最小代价和同时走到 \(1,N\) 的最小代价
看到一种更加对的写法是令 \(f_u\) 表示 \(v\) 的答案，那么可以用 \(f_v+w(u,v)\) 更新 \(f_u\)。
那么可以从 \(1,N\) 出发做一个 Dij。代码略。


E - 监狱
https://www.luogu.com.cn/problem/P9520

注意要走简单路径，也就是说不存在绕路让道的可能性。容易推出：若输入合法，总能找到一种方式使得每个人受到的指令是连续给出的。
P.S. 这个结论挪到图上就不成立了，很容易举出反例。

若一个人的起点 / 终点在另一个人的路径上，那么这两个人之间存在先后关系。建图后检查是否为 DAG 即可。
但建图显然是比较困难的，容易构造出数据使得边数来到 \(n^2\) 级别。考虑优化建图。
发现可以用一个树剖 / 倍增的结构来建图。
Tips：这一点同样是一个树上路径问题。参见 树上问题，倍增和树剖的选择？
这里的路径要求两端都是开的，这就导致倍增写着很困难（虽然树剖可能也是），不排除我写丑了


#include &lt;bits/stdc++.h&gt;
const int K = 19;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;01-02.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int T;
    for (std::cin &gt;&gt; T; T--; ) &#123;
        int n, m;
        std::cin &gt;&gt; n;
        std::vector&lt;std::vector&lt;int&gt; &gt; g1(n + 1);
        std::vector&lt;int&gt; s(n + 1), t(n + 1);
        for (int i = 1, x, y; i &lt; n; ++i) &#123;
            std::cin &gt;&gt; x &gt;&gt; y;
            g1[x].push_back(y), g1[y].push_back(x);
        &#125;
        std::cin &gt;&gt; m;
        std::vector&lt;std::vector&lt;int&gt; &gt; g(m + 1);
        std::vector&lt;std::pair&lt;int, int&gt; &gt; a(m + 1);
        for (int i = 1; i &lt;= m; ++i) &#123;
            std::cin &gt;&gt; a[i].first &gt;&gt; a[i].second;
            s[a[i].first] = i;
            t[a[i].second] = i;
        &#125;
        int cnt = m;
        struct node &#123; int fa, i0, i1; &#125;;
        std::vector&lt;std::array&lt;node, K + 1&gt; &gt; p(n + 1);
        std::vector&lt;int&gt; i0(n + 1), i1(n + 1), dep(n + 1), deg(m + 1);
        auto init = [&amp;](void) &#123;
            g.emplace_back(), deg.emplace_back();
            return ++cnt;
        &#125;;
        auto add = [&amp;](int x, int y) &#123;
            g[x].push_back(y), ++deg[y];
            return;
        &#125;;
        for (int i = 1; i &lt;= n; ++i)
            i0[i] = init(), i1[i] = init();
        std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int fa) &#123;
            if (s[x])
                add(s[x], i1[x]);
            if (t[x])
                add(i0[x], t[x]);
            for (auto i : g1[x])
                if (i != fa) &#123;
                    dep[i] = dep[x] + 1;
                    p[i][0].fa = x;
                    p[i][0].i0 = init(), p[i][0].i1 = init();
                    add(p[i][0].i0, i0[i]), add(i1[i], p[i][0].i1);
                    for (int j = 1; j &lt;= K; ++j) &#123;
                        p[i][j].fa = p[p[i][j - 1].fa][j - 1].fa;
                        if (!p[i][j].fa)
                            break;
                        p[i][j].i0 = init(), p[i][j].i1 = init();
                        add(p[i][j].i0, p[i][j - 1].i0);
                        add(p[i][j].i0, p[p[i][j - 1].fa][j - 1].i0);
                        add(p[i][j - 1].i1, p[i][j].i1);
                        add(p[p[i][j - 1].fa][j - 1].i1, p[i][j].i1);
                    &#125;
                    DFS(i, x);
                &#125;
            return;
        &#125;;
        dep[1] = 1, DFS(1, -1);
        for (int i = 1; i &lt;= m; ++i) &#123;
            auto [x, y] = a[i];
            if (x == y)
                continue;
            if (t[x])
                add(i, t[x]);
            if (s[y])
                add(s[y], i);
            if (dep[x] &lt; dep[y])
                std::swap(x, y);
            x = p[x][0].fa;
            if (dep[x] &gt;= dep[y]) &#123;
                for (int j = K; ~j; --j)
                    if (dep[p[x][j].fa] &gt;= dep[y]) &#123;
                        add(i, p[x][j].i0), add(p[x][j].i1, i);
                        x = p[x][j].fa;
                    &#125;
                if (x == y)
                    continue;
                add(i, p[x][0].i0), add(p[x][0].i1, i);
                x = p[x][0].fa;
            &#125;
            y = p[y][0].fa;
            if (x != y) &#123;
                for (int j = K; ~j; --j)
                    if (p[x][j].fa != p[y][j].fa) &#123;
                        add(i, p[x][j].i0), add(i, p[y][j].i0);
                        add(p[x][j].i1, i), add(p[y][j].i1, i);
                        x = p[x][j].fa, y = p[y][j].fa;
                    &#125;
                add(i, p[x][0].i0), add(i, p[y][0].i0);
                add(p[x][0].i1, i), add(p[y][0].i1, i);
                x = p[x][0].fa;
            &#125;
            add(i, i0[x]), add(i1[x], i);
        &#125;
        std::queue&lt;int&gt; q;
        for (int i = 1; i &lt;= cnt; ++i)
            if (!deg[i])
                q.push(i);
        int tot = 0;
        for (; !q.empty(); ) &#123;
            int x = q.front();
            q.pop(), ++tot;
            for (auto i : g[x])
                if (!--deg[i])
                    q.push(i);
        &#125;
        std::cout &lt;&lt; (tot == cnt ? &quot;Yes&quot; : &quot;No&quot;) &lt;&lt; &#39;\n&#39;;
    &#125;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;

]]></content>
      <tags>
        <tag>DP</tag>
        <tag>二分</tag>
        <tag>倍增</tag>
        <tag>调整法</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title>杂题选谈：生成树</title>
    <url>/20250929/</url>
    <content><![CDATA[zyz /bx /bx /bx


图论杂谈 by Para.pdf
link




最小公倍树
https://www.luogu.com.cn/problem/P8207

会想到从数论角度优化。需要想到最小化 lcm \(\to\) 最大化 gcd。
枚举 gcd \(u\)，那么 \(u\) 的倍数在 \([L,R]\) 中呈现为 \(k\cdot u,(k+1)\cdot u,(k+2)\cdot u,\cdots\)。虽然这些数两两之间的 gcd 并不一定为 \(u\)，但我们在枚举时『钦定』\(u\) 就是 gcd，故贪心地将所有 \(k+i\) 和 \(k\) 连边。
这种钦定的思想是很重要但我不太容易想到的。许多关于『最优化』的转化都会用到这种钦定的想法。
优化建图后跑 Kruskal 即可。


古老代码
#include &lt;bits/stdc++.h&gt;
#define int long long
namespace fastIO &#123;
const int LEN = (1 &lt;&lt; 20);
#ifdef ONLINE_JUDGE
inline int nec(void) &#123;
    static char buf[LEN], *p = buf, *e = buf;
    if (p == e) &#123;
        e = buf + fread(buf, 1, LEN, stdin);
        if (e == buf) return EOF;
        p = buf;
    &#125;
    return *p++;
&#125;
#else
#define nec getchar
#endif
inline bool read(int &amp;x) &#123;
    x = 0;
    bool f = 0;
    char ch = nec();
    while (ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123;
        if (ch == EOF) return 0;
        if (ch == &#39;-&#39;) f = 1;
        ch = nec();
    &#125;
    while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) &#123;
        x = x * 10 + ch - &#39;0&#39;;
        ch = nec();
    &#125;
    if (f) x = -x;
    return 1;
&#125;
void print(int x) &#123;
    if (x &lt; 0)
        putchar(&#39;-&#39;), x = -x;
    if (x &gt;= 10) print(x / 10);
    putchar(x % 10 + &#39;0&#39;);
    return;
&#125;
void print(int x, char ch) &#123;
    print(x), putchar(ch);
    return;
&#125;
&#125; // namespace fastIO
namespace XSC062 &#123;
using namespace fastIO;
const int maxn = 1e6 + 5;
struct _ &#123;
    int x, y, w;
    _() &#123;&#125;
    _(int x1, int y1, int w1) &#123;
        x = x1, y = y1, w = w1;
    &#125;
    bool operator&lt; (const _ &amp;q) const &#123;
        return w &lt; q.w;
    &#125;
&#125;;
int f[maxn];
std::vector&lt;_&gt; e;
int n, res, l, r;
int find(int x) &#123; return x == f[x] ? x : f[x] = find(f[x]); &#125;
void merge(int x, int y) &#123; f[find(x)] = find(y); &#125;
int gcd(int x, int y) &#123; return y ? gcd(y, x % y) : x; &#125;
int lcm(int x, int y) &#123; return x / gcd(x, y) * y; &#125;
int main() &#123;
    read(l), read(r);
    for (int i = 1; i &lt;= r; ++i) &#123;
        f[i] = i;
        int x = ((l + i - 1) / i) * i;
        for(int y = x + i; y &lt;= r; y += i)
            e.emplace_back(x, y, lcm(x, y));
    &#125;
    std::sort(e.begin(), e.end());
    for (auto i : e) &#123;
        if (find(i.x) != find(i.y))
            merge(i.x, i.y), res += i.w;
    &#125;
    print(res, &#39;\n&#39;);
    return 0;
&#125;
&#125; // namespace XSC062
#undef int
int main() &#123;
    XSC062::main();
    return 0;
&#125;


色
https://www.becoder.com.cn/problem/46791

容易发现相当于在问最短的边，满足两端颜色不同
进一步地，『最短边』问题应该思考边是否一定在 mst 上，就可以借助树的结构。考虑证明：
若 Kruskal 时，边两端的连通块内部都是同色的，且二者不同色，则这条边是最短的异色边。
问题转化为问树上最短异色边。乍一看好像和图没什么区别，困境还是『一次修改影响边数太多』，或『无法简单判定边的类型转化』。
树上问题经验不足。可以分为儿子和父亲维护，儿子整体维护每个颜色的个数，对父亲暴力修改即可。
另一种做法是，忽略 mst 性质，对图上的边序列排序后分块。
询问时枚举所有块，如果该块中存在异色边，则暴力枚举块中边然后 break。
修改则是祖传哈希，给每条边、每个颜色赋一个随机系数并强行有向化，起点为加终点为减
记录每个块中的系数和，最后总和为 0 则块不可选。


古老代码
#include &lt;bits/stdc++.h&gt;
using ull = unsigned long long;
const int maxk = 555;
const int maxn = 2e5 + 5;
const int maxm = 3e5 + 5;
struct _ &#123; int u, v, w; &#125;;
_ g[maxm];
int l[maxk], r[maxk], a[maxn];
ull hash[maxm], w[maxk], to[maxn], val[maxk][maxn];
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    std::cout.tie(nullptr);
#else
    freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n, m, q;
    std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; q &gt;&gt; q;
    std::mt19937_64 rnd(0xabcdef);
    for (int i = 1; i &lt;= m; ++i) &#123;
        std::cin &gt;&gt; g[i].u &gt;&gt; g[i].v &gt;&gt; g[i].w;
        hash[i] = rnd();
    &#125;
    for (int i = 1; i &lt;= n; ++i) &#123;
        std::cin &gt;&gt; a[i];
        for (; !to[a[i]]; to[a[i]] = rnd());
    &#125;
    std::sort(g + 1, g + m + 1, [](_ x, _ y) &#123; return x.w &lt; y.w; &#125;);
    int siz = sqrt(m), k = (m + siz - 1) / siz;
    for (int i = 1; i &lt;= k; ++i) &#123;
        l[i] = r[i - 1] + 1, r[i] = std::min(l[i] + siz - 1, m);
        for (int j = l[i]; j &lt;= r[i]; ++j) &#123;
            val[i][g[j].u] += hash[j];
            val[i][g[j].v] -= hash[j];
            w[i] += hash[j] * (to[a[g[j].u]] - to[a[g[j].v]]);
        &#125;
    &#125;
    for (int x, y; q--; ) &#123;
        std::cin &gt;&gt; x &gt;&gt; y;
        for (; !to[y]; to[y] = rnd());
        for (int i = 1; i &lt;= k; ++i)
            w[i] += val[i][x] * (to[y] - to[a[x]]);
        a[x] = y;
        for (int i = 1; i &lt;= k; ++i) &#123;
            if (w[i]) &#123;
                for (int j = l[i]; j &lt;= r[i]; ++j)
                    if (a[g[j].u] != a[g[j].v]) &#123;
                        std::cout &lt;&lt; g[j].w &lt;&lt; &#39;\n&#39;;
                        break;
                    &#125;
                break;
            &#125;
        &#125;
    &#125;
    return 0;
&#125;


DFS Trees
https://www.luogu.com.cn/problem/CF1707C

一个结论：若图中边权两两不同，则图的最小生成树唯一。

借鉴次小生成树的思路证明…
对于两个 mst \(T_1,T_2\)，假设二者边集不同但权值相同，对于其对称差 \(S\)，设 \(e\) 是其中最小的边，且 \(e\in T_1,e\notin T_2\)。
将 \(e\) 加入 \(T_2\)，则形成的环上存在 \(e&#39;\) 使得 \(e&#39;\in T_2,e&#39;\notin T_1\)，那么 \(e&#39;\in S\)。删掉 \(e&#39;\) 并加入 \(e\)，得到 \(T_2&#39;\)。
由于 \(e\) 是 \(S\) 中最小边，那么 \(e&lt;e&#39;\)。也即 \(T_2&#39;&lt;T_1\)，与前提矛盾。

知道了这一点，就很好从 DFS 树的方向下手了。考虑如何什么时候 DFS 树就是 mst。
对于一条非 mst 树边 \((u,v,w)\)：

由 DFS 树的性质，若其为横叉边，必被经过。
由 mst 的性质，\(w\) 一定比 \(u,v\) 简单路径上的所有边边权更大，也即，当可以走这条路径时，一定不走 \(w\)。

结合起来，\(w\) 不被经过，当且仅当 \(u,v\) 间存在祖孙关系。对应子树即为合法根。实现时还是需要倍增来找到差分范围，较为难受。


#include &lt;bits/stdc++.h&gt;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, m;
    std::cin &gt;&gt; n &gt;&gt; m;
    std::vector&lt;std::pair&lt;int, int&gt; &gt; e(m + 1);
    for (int i = 1; i &lt;= m; ++i)
        std::cin &gt;&gt; e[i].first &gt;&gt; e[i].second;
    std::vector&lt;int&gt; f(n + 1);
    std::iota(f.begin() + 1, f.end(), 1);
    std::function&lt;int(int)&gt; find = [&amp;](int x) &#123;
        return x == f[x] ? x : f[x] = find(f[x]);
    &#125;;
    auto merge = [&amp;](int x, int y) &#123;
        f[find(x)] = find(y);
        return;
    &#125;;
    std::vector&lt;std::pair&lt;int, int&gt; &gt; u;
    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);
    for (int i = 1; i &lt;= m; ++i) &#123;
        auto &amp;[x, y] = e[i];
        if (find(x) != find(y)) &#123;
            g[x].push_back(y), g[y].push_back(x);
            merge(x, y);
        &#125;
        else
            u.push_back(e[i]);
    &#125;
    std::vector&lt;int&gt; dep(n + 1);
    std::vector&lt;std::array&lt;int, 19&gt; &gt; fa(n + 1);
    std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;
        for (auto i : g[x])
            if (i != fa[x][0]) &#123;
                dep[i] = dep[x] + 1;
                fa[i][0] = x;
                for (int j = 1; j &lt; 19; ++j)
                    fa[i][j] = fa[fa[i][j - 1]][j - 1];
                DFS(i);
            &#125;
        return;
    &#125;;
    dep[1] = 1, DFS(1);
    auto ask = [&amp;](int x, int y) &#123;
        if (dep[x] &lt; dep[y])
            std::swap(x, y);
        for (int i = 18; ~i; --i)
            if (dep[fa[x][i]] &gt;= dep[y])
                x = fa[x][i];
        if (x == y)
            return x;
        for (int i = 18; ~i; --i)
            if (fa[x][i] != fa[y][i])
                x = fa[x][i], y = fa[y][i];
        return fa[x][0];
    &#125;;
    std::vector&lt;int&gt; diff(n + 1);
    for (auto [x, y] : u) &#123;
        ++diff[x], ++diff[y];
        if (dep[x] &lt; dep[y])
            std::swap(x, y);
        if (ask(x, y) == y) &#123;
            for (int i = 18; ~i; --i)
                if (dep[fa[x][i]] &gt; dep[y])
                    x = fa[x][i];
            --diff[x];
        &#125;
    &#125;
    std::vector&lt;int&gt; res(n + 1);
    std::function&lt;void(int, int)&gt; DFS1 = [&amp;](int x, int s) &#123;
        s += diff[x];
        res[x] = (s == (int)u.size());
        for (auto i : g[x])
            if (i != fa[x][0])
                DFS1(i, s);
        return;
    &#125;;
    DFS1(1, 0);
    for (int i = 1; i &lt;= n; ++i)
        std::cout &lt;&lt; res[i];
    std::cout &lt;&lt; &#39;\n&#39;;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;


Minimum spanning tree for each edge
https://www.luogu.com.cn/problem/CF609E
挺没意思的题…… 略了。
考虑这个题的孪生版本：
Minimum Spanning Tree
https://www.luogu.com.cn/problem/AT_icpc2013spring_e
用非树边更新环上每条树边的最小取代边即可。类似树上差分。代码略。

Power Tree
https://www.luogu.com.cn/problem/CF1120D

容易想到把原问题转化为叶子序列上的差分。那么对于任意一个初始差分序列，我们都需要把它通过这样的差分操作变为 \(1\sim n\) 全 0，第 \(n+1\) 位为 \(-s\)。
联想到差分和连有向边的转化，那么要求连一个 \(n+1\) 为唯一汇点的树出来。显然就是原图的 mst。
考虑怎么求出可能被 mst 包含的边。对于每一条非树边，若环上存在边权相同的边，那么这条非树边也能成为树边。
考虑一个孪生问题：怎么求出一定被 mst 包含的边？
https://www.luogu.com.cn/problem/CF160D
树上差分 + 线段树合并即可，注意单次线段树合并只有线性，直接做 DSU on tree 的复杂度是单 log 的。
关于具体实现，可以参考 最小生成树的唯一性 - OI Wiki。


#include &lt;bits/stdc++.h&gt;
#define int long long
namespace fastIO &#123;
const int LEN = (1 &lt;&lt; 20);
#ifdef ONLINE_JUDGE
inline int nec(void) &#123;
    static char buf[LEN], *p = buf, *e = buf;
    if (p == e) &#123;
        e = buf + fread(buf, 1, LEN, stdin);
        if (e == buf) return EOF;
        p = buf;
    &#125;
    return *p++;
&#125;
#else
#define nec getchar
#endif
inline bool read(int &amp;x) &#123;
    x = 0;
    bool f = 0;
    char ch = nec();
    while (ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123;
        if (ch == EOF) return 0;
        if (ch == &#39;-&#39;) f = 1;
        ch = nec();
    &#125;
    while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) &#123;
        x = x * 10 + ch - &#39;0&#39;;
        ch = nec();
    &#125;
    if (f) x = -x;
    return 1;
&#125;
void print(int x) &#123;
    if (x &lt; 0)
        putchar(&#39;-&#39;), x = -x;
    if (x &gt;= 10) print(x / 10);
    putchar(x % 10 + &#39;0&#39;);
    return;
&#125;
void print(int x, char ch) &#123;
    print(x), putchar(ch);
    return;
&#125;
&#125; // namespace fastIO
namespace XSC062 &#123;
using namespace fastIO;
const int maxn = 2e5 + 5;
struct _ &#123;
    int x, y, i;
    _() &#123;&#125;
    _(int x1, int y1, int i1) &#123;
        x = x1, y = y1, i = i1;
    &#125;
    bool operator&lt; (const _ &amp;q) const;
&#125;;
_ t[maxn];
int a[maxn], f[maxn];
std::vector&lt;int&gt; res;
int n, now, x, y, sum; 
int beg[maxn], to[maxn];
std::vector&lt;int&gt; g[maxn];
bool _::operator&lt; (const _ &amp;q) const &#123;
    return a[i] &lt; a[q.i];
&#125;
int find(int x) &#123; return x == f[x] ? x : f[x] = find(f[x]); &#125;
void merge(int x, int y) &#123;
    f[find(x)] = find(y);
    return;
&#125;
void DFS(int x, int fa) &#123;
    if (~fa &amp;&amp; (int)g[x].size() == 1)
        beg[x] = to[x] = ++now;
    for (auto i : g[x]) &#123;
        if (i == fa) continue;
        DFS(i, x);
        if (!beg[x]) beg[x] = beg[i];
        to[x] = to[i];
    &#125;
    t[x] = _(beg[x], to[x] + 1, x);
    return;
&#125;
void add(int x, int y) &#123;
    g[x].push_back(y);
    return;
&#125;
int main() &#123;
    read(n);
    for (int i = 1; i &lt;= n; ++i) read(a[i]);
    for (int i = 1; i &lt;= n + 1; ++i) f[i] = i;
    for (int i = 1; i &lt; n; ++i) &#123;
        read(x), read(y);
        add(x, y), add(y, x);
    &#125;
    DFS(1, -1);
    std::sort(t + 1, t + n + 1);
    for (int l = 1, r = 0; l &lt;= n; l = r + 1) &#123;
        while (r &lt; n &amp;&amp; a[t[r + 1].i] == a[t[l].i]) ++r;
        for (int i = l; i &lt;= r; ++i) &#123;
            if (find(t[i].x) != find(t[i].y))
                res.push_back(t[i].i);
        &#125;
        for (int i = l; i &lt;= r; ++i) &#123;
            if (find(t[i].x) != find(t[i].y))
                sum += a[t[i].i], merge(t[i].x, t[i].y);
        &#125;
    &#125;
    std::sort(res.begin(), res.end());
    print(sum, &#39; &#39;), print(res.size(), &#39;\n&#39;);
    for (auto i : res) print(i, &#39; &#39;);
    putchar(&#39;\n&#39;);
    return 0;
&#125;
&#125; // namespace XSC062
#undef int
int main() &#123;
    XSC062::main();
    return 0;
&#125;


Another Minimum Spanning Tree
https://www.becoder.com.cn/problem/29212
goto 曼哈顿最小距离生成树。

A - Design Tutorial: Inverse the Problem
https://www.luogu.com.cn/problem/CF472D

发现给出的完全图的最小生成树就是原树。check 一下是否合法即可。
图较稠密，需要用 Prim。


#include &lt;bits/stdc++.h&gt;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n;
    std::cin &gt;&gt; n;
    std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; g(n + 1);
    std::vector&lt;std::vector&lt;int&gt; &gt; g0(n + 1, std::vector&lt;int&gt; (n + 1));
    for (int i = 1; i &lt;= n; ++i)
        for (int j = 1; j &lt;= n; ++j)
            std::cin &gt;&gt; g0[i][j];
    for (int i = 1; i &lt;= n; ++i) &#123;
        if (g0[i][i] != 0) &#123;
            std::cout &lt;&lt; &quot;NO\n&quot;;
            return 0;
        &#125;
        for (int j = 1; j &lt; i; ++j)
            if (g0[i][j] != g0[j][i] || !g0[i][j]) &#123;
                std::cout &lt;&lt; &quot;NO\n&quot;;
                return 0;
            &#125;
    &#125;
    std::vector&lt;int&gt; pos(n + 1), tag(n + 1);
    tag[1] = 1;
    for (int _ = 1, s = 1; _ &lt; n; ++_) &#123;
        for (int i = 1; i &lt;= n; ++i)
            if (!tag[i] &amp;&amp; (!pos[i] || g0[s][i] &lt; g0[pos[i]][i]))
                pos[i] = s;
        s = 0;
        int t = 0;
        for (int i = 1; i &lt;= n; ++i)
            if (!tag[i] &amp;&amp; pos[i] &amp;&amp; (!s || g0[pos[i]][i] &lt; g0[pos[s]][s]))
                s = i, t = pos[i];
        tag[s] = 1;
        g[s].emplace_back(t, g0[s][t]), g[t].emplace_back(s, g0[s][t]);
    &#125;
    std::vector&lt;int&gt; tab(n + 1), dis(n + 1);
    std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int fa) &#123;
        static int now = 0;
        tab[++now] = x;
        int L = now, R = now;
        for (auto [i, w] : g[x])
            if (i != fa) &#123;
                dis[i] = dis[x] + w;
                DFS(i, x);
                for (int p = L; p &lt;= R; ++p)
                    for (int q = R + 1; q &lt;= now; ++q) &#123;
                        if (g0[tab[p]][tab[q]] != dis[tab[p]] + dis[tab[q]] - 2 * dis[x]) &#123;
                            std::cout &lt;&lt; &quot;NO\n&quot;;
                            exit(0); // extremely ugly
                        &#125;
                    &#125;
                R = now;
            &#125;
        return;
    &#125;;
    DFS(1, -1);
    std::cout &lt;&lt; &quot;YES\n&quot;;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;


B - Phoenix and Earthquake
https://www.luogu.com.cn/problem/CF1515F

会想到，有解的充要条件是的点权之和 \(\ge (n-1)\cdot x\)。证明方法很广泛，但规约的思想对破题是决定性的。

对于 \(u\ge x\)，将 \(u\) 和任意相邻点合并后缩点，规约为更小规模的问题。
对于 \(u&lt;x\)，一次合并使点权和减少 \(u\)，点权需求减少 \(x\)，故子问题合法则该问题合法。

条件是充要的，则可以任意合并，但这样不太好做，考虑借助规约的结构，若 \(u\ge x\) 则直接合并，否则等到其他部分合并完后再合并这一条边。这是一个栈的结构。


#include &lt;bits/stdc++.h&gt;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, m, k;
    std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;
    std::vector&lt;long long&gt; a(n + 1);
    for (int i = 1; i &lt;= n; ++i)
        std::cin &gt;&gt; a[i];
    if (std::accumulate(a.begin() + 1, a.end(), 0ll) &lt; (long long)k * (n - 1)) &#123;
        std::cout &lt;&lt; &quot;NO\n&quot;;
        return 0;
    &#125;
    std::cout &lt;&lt; &quot;YES\n&quot;;
    std::vector&lt;int&gt; f(n + 1);
    std::iota(f.begin() + 1, f.end(), 1);
    std::function&lt;int(int)&gt; find = [&amp;](int x) &#123;
        return x == f[x] ? x : f[x] = find(f[x]);
    &#125;;
    auto merge = [&amp;](int x, int y) &#123;
        f[find(x)] = find(y);
        return;
    &#125;;
    std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; g(n + 1);
    for (int i = 1, x, y; m--; ++i) &#123;
        std::cin &gt;&gt; x &gt;&gt; y;
        if (find(x) != find(y)) &#123;
            g[x].emplace_back(y, i);
            g[y].emplace_back(x, i);
            merge(x, y);
        &#125;
    &#125;
    std::vector&lt;int&gt; t;
    std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int fa) &#123;
        for (auto [i, id] : g[x])
            if (i != fa) &#123;
                DFS(i, x);
                if (a[i] &gt;= k) &#123;
                    a[x] += a[i] - k;
                    std::cout &lt;&lt; id &lt;&lt; &#39;\n&#39;;
                &#125;
                else
                    t.push_back(id);
            &#125;
        return;
    &#125;;
    DFS(1, -1);
    for (; !t.empty(); t.pop_back())
        std::cout &lt;&lt; t.back() &lt;&lt; &#39;\n&#39;;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;


最小度限制生成树 (Easy Version)
https://www.luogu.com.cn/problem/P5633

要求：两只 log。

wqs 二分即可。

最小度限制生成树 (Hard Version)

要求：一只 log。

注意到涉及的边是固定的，且偏移量相同，故对于『与 \(s\) 有关的边』和『与 \(s\) 无关的边』先分别排序作为预处理，二分内部仅需归并即可。

最小度限制生成树 (Extreme Version)

要求：

一只 log；
对于 \(k=1,2,\cdots,n\)，分别输出答案。


观看 https://www.luogu.com.cn/article/ym8ixzr8。
]]></content>
      <tags>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title>杂题选谈：生成树 II</title>
    <url>/20251004/</url>
    <content><![CDATA[为什么要定义最小瓶颈路？似乎并不是很有意义


A - 水筒
https://www.luogu.com.cn/problem/AT_joisc2014_e

即求重构树，考虑 BFS 建图
代码略


B - Difference of Distance
https://www.luogu.com.cn/problem/AT_abc301_h

有一个很奇怪的想法，就是当存在多种 Kruskal 重构树时，最大边权最小值是不会变的
也就是说如果拿掉了这条边，但仍然存在另一条边权相同的边可以『代替』自己时，最大边权最小值不变
否则，从另一个角度想，就可以仍然选自己，那么答案就会增加 1。
因此，只需要对于不在生成树上的每一条边，标记环上和自己相同的边即可。
树上差分 + dsu on tree 即可，注意线段树合并是线性的，如果忘了这一点就会和我一样想出虚树 + 树剖的诡异双 log 做法

]]></content>
      <tags>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title>杂题选谈：贪心</title>
    <url>/20251005/</url>
    <content><![CDATA[不会做的简单题



贪心的『策略』是一种很模糊的东西

如果能找到一种清晰的操作流程，自然是很好的，但如果要从数学角度进行推导，可能有些困难
否则，如果没办法找到一种确定的操作方式，需要确定答案的上 / 下界是可以取到的



饥饿的狐狸
https://www.luogu.com.cn/problem/P4801

第一问，发现不喝水一定不劣，故大小顺序吃饼干即可。
具体地，若 \(W&lt;a_1\)，把 \(W\) 视作 \(a_0\) 即可；若 \(W&gt;a_n\)，把 \(W\) 视作 \(a_{n+1}\) 即可；
若 \(a_1&lt;W&lt;a_n\)，那么由于喝水是没有代价的，可以从 \(W\) 一直吃到 \(a_1\)，再喝水，再从 \(W\) 一直吃到 \(a_n\)。
第二问，我们希望 \(a_i-a_j\) 这个代价中的 \(a_i\) 尽可能大，\(a_j\) 尽可能小。故尝试让前一半当 \(a_j\)，后一半当 \(a_i\) 即可，那么顺序其实无所谓，只是需要讨论一下和第一次 \(W\) 接壤的是 \(a_1\) 还是 \(a_n\)。


#include &lt;bits/stdc++.h&gt;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n;
    long long w;
    std::cin &gt;&gt; n &gt;&gt; w;
    std::vector&lt;long long&gt; a(n + 1);
    for (int i = 1; i &lt;= n; ++i)
        std::cin &gt;&gt; a[i];
    std::sort(a.begin() + 1, a.end());
    std::cout &lt;&lt; std::max(w - a[1], 0ll) + std::max(a[n] - w, 0ll) &lt;&lt; &#39; &#39;;
    auto calc = [&amp;](int op) &#123;
        long long res = 0ll, now = w;
        for (int i = 1, l = 1, r = n; i &lt;= n; ++i)
            if (i % 2 == op)
                res += std::max(std::abs(a[l] - now), std::abs(a[l] - w)), now = a[l++];
            else
                res += std::max(std::abs(a[r] - now), std::abs(a[r] - w)), now = a[r--];
        return res;
    &#125;;
    std::cout &lt;&lt; std::max(calc(0), calc(1)) &lt;&lt; &#39;\n&#39;;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;


SAM-Toy Cars
https://www.luogu.com.cn/problem/P3419

有一个大概的感受是每次丢弃『下次出现时间』最晚的一个。
tip：玩具在地上的时候不会更新队列中的 nex。需要特别处理。


#include &lt;bits/stdc++.h&gt;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, k, p;
    std::cin &gt;&gt; n &gt;&gt; k &gt;&gt; p;
    std::vector&lt;int&gt; a(p + 1);
    for (int i = 1; i &lt;= p; ++i)
        std::cin &gt;&gt; a[i];
    std::vector&lt;int&gt; nex(p + 1), la(n + 1, p + 1);
    for (int i = p; i; --i)
        nex[i] = la[a[i]], la[a[i]] = i;
    std::priority_queue&lt;std::pair&lt;int, int&gt; &gt; q;
    std::vector&lt;int&gt; inq(n + 1);
    int cnt = 0;
    for (int i = 1; i &lt;= p; ++i)
        if (!inq[a[i]]) &#123;
            if ((int)q.size() == k) &#123;
                auto [nex, v] = q.top();
                q.pop();
                inq[v] = 0;
            &#125;
            ++cnt, q.emplace(nex[i], a[i]);
            inq[a[i]] = 1;
        &#125;
        else
            q.emplace(nex[i], a[i]), ++k;
    std::cout &lt;&lt; cnt &lt;&lt; &#39;\n&#39;;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;


Sports Festival
https://www.luogu.com.cn/problem/AT_agc018_b

会有一个显然的二分做法
其实可以不用二分，每次删最大的，每次更新答案
用带一点反证的思路是好证的


#include &lt;bits/stdc++.h&gt;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, m;
    std::cin &gt;&gt; n &gt;&gt; m;
    std::vector&lt;std::queue&lt;int&gt; &gt; a(n + 1);
    std::vector&lt;int&gt; del(m + 1), cnt(m + 1);
    for (int i = 1; i &lt;= n; ++i) &#123;
        for (int j = 1, x; j &lt;= m; ++j)
            std::cin &gt;&gt; x, a[i].push(x);
        ++cnt[a[i].front()];
    &#125;
    int res = n + 1;
    for (int i = 1; i &lt;= m; ++i) &#123;
        int mx = 0, id = 0;
        for (int i = 1; i &lt;= m; ++i)
            if (cnt[i] &gt; mx)
                mx = cnt[i], id = i;
        res = std::min(res, mx);
        if (i == m)
            break;
        del[id] = 1;
        for (int j = 1; j &lt;= n; ++j) &#123;
            --cnt[a[j].front()];
            for (; del[a[j].front()]; a[j].pop());
            ++cnt[a[j].front()];
        &#125;
    &#125;
    std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;


Linguistics
https://www.luogu.com.cn/problem/CF1685B

找到每一段极长交错段，把 AB 和 BA ；处理掉
发现 ABABA 和 BABAB 对于 AB 和 BA 是等价的，考虑 ABABAB 和 BABABA。发现后二者要么匹配 AB / BA，要么删去首尾后转化为另一者。但这样就会浪费掉一个消去 AB 或 BA 的机会。
故优先对后二者匹配 AB / BA，实在有多余再删头尾。


#include &lt;bits/stdc++.h&gt;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int T;
    for (std::cin &gt;&gt; T; T--; ) &#123;
        int A, B, AB, BA;
        std::string a;
        std::cin &gt;&gt; A &gt;&gt; B &gt;&gt; AB &gt;&gt; BA &gt;&gt; a;
        int n = (int)a.length();
        a = &quot;#&quot; + a;
        char l = a[1];
        int len = 0;
        std::vector&lt;int&gt; ab, ba, c;
        for (int i = 1; i &lt;= n; ++i) &#123;
            if (i == 1 || a[i] != a[i - 1])
                ++len;
            if (i == n || a[i] == a[i - 1]) &#123;
                if (len != 1) &#123;
                    // fprintf(stderr, &quot;#1 len = %d, l = %c \n&quot;, len, l);
                    if (l == &#39;A&#39; &amp;&amp; a[i] == &#39;B&#39;)
                        ab.push_back(len);
                    else if (l == &#39;A&#39;) &#123;
                        if (!A)
                            goto nosol;
                        else
                            --A, c.push_back(len - 1);
                    &#125;
                    else if (a[i] == &#39;A&#39;)
                        ba.push_back(len);
                    else if (!B)
                        goto nosol;
                    else
                        --B, c.push_back(len - 1);
                &#125;
                else &#123;
                    // fprintf(stderr, &quot;#2 len = %d, l = %c \n&quot;, 1, l);
                    if (l == &#39;A&#39;) &#123;
                        if (!A)
                            goto nosol;
                        --A;
                    &#125;
                    else &#123;
                        if (!B)
                            goto nosol;
                        --B;
                    &#125;
                &#125;
                if (i == n &amp;&amp; a[i] == a[i - 1]) &#123;
                    // fprintf(stderr, &quot;#3 len = %d, l = %c \n&quot;, 1, a[i]);
                    if (a[i] == &#39;A&#39;) &#123;
                        if (!A)
                            goto nosol;
                        --A;
                    &#125;
                    else &#123;
                        if (!B)
                            goto nosol;
                        --B;
                    &#125;
                &#125;
                len = 1, l = a[i];
            &#125;
        &#125;
        std::sort(ab.begin(), ab.end(), std::greater&lt;int&gt; ());
        std::sort(ba.begin(), ba.end(), std::greater&lt;int&gt; ());
        for (; !ab.empty() &amp;&amp; AB; ) &#123;
            int x = std::min(AB, ab.back() / 2);
            AB -= x, ab.back() -= x * 2;
            if (!ab.back())
                ab.pop_back();
        &#125;
        for (; !ba.empty() &amp;&amp; BA; ) &#123;
            int x = std::min(BA, ba.back() / 2);
            BA -= x, ba.back() -= x * 2;
            if (!ba.back())
                ba.pop_back();
        &#125;
        // fprintf(stderr, &quot;AB = %d, BA = %d, A = %d, B = %d \n&quot;, AB, BA, A, B);
        for (; !ab.empty() &amp;&amp; BA; ) &#123;
            if (!A || !B)
                goto nosol;
            ab.back() -= 2, --A, --B;
            int x = std::min(BA, ab.back() / 2);
            BA -= x, ab.back() -= x * 2;
            if (!ab.back())
                ab.pop_back();
        &#125;
        for (; !ab.empty(); ) &#123;
            A -= ab.back() / 2, B -= ab.back() / 2;
            ab.pop_back();
        &#125;
        if (A &lt; 0 || B &lt; 0)
            goto nosol;
        for (; !ba.empty() &amp;&amp; AB; ) &#123;
            if (!A || !B)
                goto nosol;
            ba.back() -= 2, --A, --B;
            int x = std::min(AB, ba.back() / 2);
            AB -= x, ba.back() -= x * 2;
            if (!ba.back())
                ba.pop_back();
        &#125;
        for (; !ba.empty(); ) &#123;
            A -= ba.back() / 2, B -= ba.back() / 2;
            ba.pop_back();
        &#125;
        if (A &lt; 0 || B &lt; 0)
            goto nosol;
        for (; !c.empty() &amp;&amp; AB; ) &#123;
            int x = std::min(AB, c.back() / 2);
            AB -= x, c.back() -= x * 2;
            if (!c.back())
                c.pop_back();
        &#125;
        for (; !c.empty() &amp;&amp; BA; ) &#123;
            int x = std::min(BA, c.back() / 2);
            BA -= x, c.back() -= x * 2;
            if (!c.back())
                c.pop_back();
        &#125;
        if (AB || BA)
            goto nosol;
        for (; !c.empty(); ) &#123;
            A -= c.back() / 2, B -= c.back() / 2;
            c.pop_back();
        &#125;
        if (A || B)
            goto nosol;
        std::cout &lt;&lt; &quot;YES\n&quot;;
        continue;
    nosol: ;
        std::cout &lt;&lt; &quot;NO\n&quot;;
    &#125;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;


Sunny’s Crystals
https://www.luogu.com.cn/problem/P5584

如果某一时刻同时存在多个可以被删除的数，显然应该删最后一个
否则，发现删每一个位置对于后方关键点的贡献完全相同，故删第一个即可。
发现线段树没办法很好地维护『有哪些点是二的次方』，但是我们知道一个很相似的结构『有哪些点是 \(0\)』，结合起来可以马上反映出来实时维护每个点到最近一个二的此方位置的距离。
把非关键点 / 被删去的点赋为 inf 即可方便维护。


#include &lt;bits/stdc++.h&gt;
const int maxn = 3e6 + 5;
const int inf = 0x3f3f3f3f;
struct &#123;
    int l, r, u, x, d;
&#125; t[maxn &lt;&lt; 2];
int tot = 0;
#define lt t[p].l
#define rt t[p].r
void pushval(int p, int v) &#123;
    if (p)
        t[p].d += v, t[p].u += v;
    return;
&#125;
void pushdown(int p) &#123;
    pushval(lt, t[p].d), pushval(rt, t[p].d);
    t[p].d = 0;
    return;
&#125;
void pushup(int p) &#123;
    t[p].u = std::min(t[lt].u, t[rt].u);
    if (t[rt].u == t[p].u)
        t[p].x = t[rt].x;
    else
        t[p].x = t[lt].x;
    return;
&#125;
void upd(int &amp;p, int l, int r, int x, int v) &#123;
    if (!p)
        p = ++tot;
    if (l == r) &#123;
        t[p].u = v, t[p].x = l;
        return;
    &#125;
    pushdown(p);
    int mid = (l + r) &gt;&gt; 1;
    if (x &lt;= mid)
        upd(lt, l, mid, x, v);
    else
        upd(rt, mid + 1, r, x, v);
    pushup(p);
    return;
&#125;
void add(int p, int l, int r, int ql, int qr, int v) &#123;
    if (!p)
        return;
    if (ql &lt;= l &amp;&amp; r &lt;= qr) &#123;
        pushval(p, v);
        return;
    &#125;
    pushdown(p);
    int mid = (l + r) &gt;&gt; 1;
    if (ql &lt;= mid)
        add(lt, l, mid, ql, qr, v);
    if (qr &gt; mid)
        add(rt, mid + 1, r, ql, qr, v);
    pushup(p);
    return;
&#125;
#undef lt
#undef rt
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, w, m = 0, rt = 0;
    std::cin &gt;&gt; n &gt;&gt; w, t[0].u = inf;
    auto to = [&amp;](int x) &#123;
        return 1 &lt;&lt; std::__lg(x);
    &#125;;
    for (int i = 1, x; i &lt;= n; ++i) &#123;
        std::cin &gt;&gt; x;
        if (x == w)
            ++m, upd(rt, 1, n, i, i - to(i));
    &#125;
    std::vector&lt;int&gt; res, del(n + 1);
    for (int i = 1, now = 1; i &lt;= m; ++i) &#123;
        for (int j = 1; j &lt;= t[1].u; ++j) &#123;
            for (; del[now]; ++now);
            del[now] = 1, res.push_back(now++);
        &#125;
        pushval(rt, -t[1].u);
        int pos = t[1].x;
        del[pos] = 1, res.push_back(pos);
        upd(rt, 1, n, pos, inf);
        if (pos + 1 &lt;= n)
            add(rt, 1, n, pos + 1, n, -1);
    &#125;
    std::cout &lt;&lt; (int)res.size() &lt;&lt; &#39;\n&#39;;
    for (auto i : res)
        std::cout &lt;&lt; i &lt;&lt; &#39; &#39;;
    std::cout &lt;&lt; &#39;\n&#39;;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;



]]></content>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>学习笔记：树套树</title>
    <url>/20251007-1/</url>
    <content><![CDATA[第一次学树套树时，并没有什么特别的感觉，因为属于我的离线分治，我早已遇见

并非第一次学

线段树

考虑线段树的本质，即给定序列，能够返回关键字在 \([l,r]\) 内的可加信息之和
仅需要保证信息是可加的（如众数，mex 等显然不在此列）


树状数组

给定序列，能够返回任意关键字处的前缀和 / 后缀和，需要保证信息是可加的
如果要求任意区间内关键字的信息之和，会用到差分，此时还需额外保证信息是可减的（如 min / max 显然不在此列）


主席树 / 可持久化线段树
之前有人在争论『主席树』是否等价于『可持久化线段树』，其实从当前 OI 环境的语境下我觉得是等价的

给定序列，存在关键字 A 和关键字 B，能够求出 \(([0, A&#39;], [B_1, B_2])\) 这个矩形的信息和（这里的矩形可能是 DAG 状的）
也就是说主席树本身存的是关于 A 的信息前缀和
要求 A 只能来源于先前的 A（即 A 具有单调性），且底层信息的 delta 为 1
需要发现这个条件是相当苛刻的，所以这里的 A 通常以时间 / 版本 / DAG 的形式出现
如果信息具有可减性，对于 \(A_2\) 和其某个祖先 \(A_1\)，能够求出 \(([A_1,A_2],[B_1,B_2])\) 这个矩形的信息和。



考虑为什么主席树不能解决三维偏序
现在已经对关键字 C 排完序了，我们需要求出 \(([0, A], [0, B])\) 这个矩形的信息和
发现 A 是不具备单调性的，有没有什么 DS 能够不要求 A 的单调性呢？


树状数组套线段树

用 \(n\) 棵线段树维护 B 的偏序关系，用类主席树的方式来排列这些树
发现一次修改需要改一段后缀
这一点我们前面说过了，主席树本身存储的是 A 维的前缀和。
所以直接解决这个问题：维护信息的差分。这样就可以通过询问前缀得到原始信息
这个结构和树状数组是很吻合的，考虑在树状数组的每个点上维护动态开点线段树
这样就可以只用修改 log 个线段树
考虑怎么询问
我最初的想法是，做一个线段树合并，利用 DS 本身的树形结构可以有一个 dsu on tree 的复杂度（即 \(O(nq\log^2 n)\)），但显然这个太糖了
正常的做法是，注意到每个点的权值线段树结构相同，所以在 log 个线段树上同时维护，当作包含长度 log 的数组的结构体即可
同树状数组，要求信息有可减性
但由于外层的 DS 本质上舍弃了主席树 DAG 的结构
导致不能直接简单用于树上问题，而是需要在 DFS 序上作文章
实际上常数很大，超过 \(10^5\) 就不太能跑得动了


Dynamic Rankings / K大数查询
https://www.luogu.com.cn/problem/P2617 / https://www.luogu.com.cn/problem/P3332

全局第 \(k\) 大就是普通的权值线段树上二分，抑或平衡树，抑或 01-Trie（三者等价）
这里的权值线段树上二分，其实是矩形第二维限制的变体
发现这里只需要简单地维护元素个数，是具有可减性的。


三维偏序（陌上花开）
https://www.luogu.com.cn/problem/P3810

树状数组套权值线段树即可


二逼平衡树
https://loj.ac/p/106

和 k 大数差不多，都是权值线段树那些东西


网络管理
https://www.luogu.com.cn/problem/P4175

维护带修树上简单路径第 \(k\) 大。


做树上差分即可转化为序列第 \(k\) 大。


买宝石
https://www.becoder.com.cn/contest/6620/problem/4

给定根为 \(1\) 的树，每个点 \(u\) 上有 \(k_u\) 个价钱为 \(w_u\) 的物品，可以在时间 \(t_u\) 及之后获得
给定 \(Q\) 次询问，从问 \(x\) 出发到根的路径上所有在时刻 \(T\) 可以获得的物品全部拿出来排成一列，拥有 \(K\) 金钱时，按照价值从小到大购买，买到的最后一个物品价值。
\(n\le 10^5\)，价钱：\(10^{15}\)，时间：\(10^5\)，个数：\(10^5\)。


信息自带一个有序的时间偏序维 \(T\) 且原生有序，所以不能整体二分，必须处理 \(k\) 偏序维和 \(w\) 二分维。




总的来说，就是维护了两个关键字，或者说一个矩形
根据在 A，B 维需要做的操作选择，以及需要维护的信息类型，选择相应的数据结构


关于整体二分

考虑动态区间第 K 大这一类的问题，特征是 A 维『求和』，B 维二分
此时可以把对 B 维的二分提到外层一起进行，反过来对 A 维应用数据结构
考虑到树套树常数过大，所以在能用整体二分的时候不推荐用树套树

]]></content>
      <tags>
        <tag>树套树</tag>
      </tags>
  </entry>
  <entry>
    <title>杂题选谈</title>
    <url>/20251007/</url>
    <content><![CDATA[近期模拟赛


A. 考试
https://www.becoder.com.cn/contest/6624/problem/1

\(m\) 道题，分数是一个 \(m\) 的排列（初始未知），做对得满分，做错得 0 分
给定 \(n\) 个人对于这 \(m\) 个题的过题情况矩阵，且第 \(i\) 个人有一个预期分数 \(x_i\)。
求每到题的分数，使得每个人实际得分与期望的分差的绝对值之和最大。输出该排列。
\(n\le 10,m\le 10^4\)。


绝对值是贪心一个很大的阻碍
一个典型的『钦定』型贪心，枚举每个人的绝对值是否取反，就可以得到每个题对应的系数。
因为『就算错了也不会影响最优解』，所以是对的。


#include &lt;bits/stdc++.h&gt;
int main() &#123;
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
    std::freopen(&quot;test.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;test.out&quot;, &quot;w&quot;, stdout);
    int T;
    for (std::cin &gt;&gt; T; T--; ) &#123;
        int n, m;
        std::cin &gt;&gt; n &gt;&gt; m;
        std::vector&lt;int&gt; s(n + 1);
        for (int i = 1; i &lt;= n; ++i)
            std::cin &gt;&gt; s[i];
        std::vector&lt;std::vector&lt;int&gt; &gt; pos(n + 1);
        for (int i = 1; i &lt;= n; ++i)
            for (int j = 1; j &lt;= m; ++j) &#123;
                char t;
                std::cin &gt;&gt; t;
                if (t == &#39;1&#39;)
                    pos[i].push_back(j);
            &#125;
        auto res = 0ll;
        int siz = 1 &lt;&lt; n;
        std::vector&lt;std::vector&lt;int&gt; &gt; id(2 * n + 1);
        std::vector&lt;int&gt; cnt(m + 1), ans(m + 1), p(m + 1);
        for (int i = 0; i &lt; siz; ++i) &#123;
            std::fill(cnt.begin() + 1, cnt.end(), 0);
            for (int j = 0; j &lt;= 2 * n; ++j)
                id[j].clear();
            for (int j = 1; j &lt;= n; ++j)
                if ((i &gt;&gt; (j - 1)) &amp; 1)
                    for (auto k : pos[j])
                        ++cnt[k];
                else
                    for (auto k : pos[j])
                        --cnt[k];
            for (int j = 1; j &lt;= m; ++j)
                id[cnt[j] + n].push_back(j);
            for (int i = 2 * n, k = m; ~i; --i)
                for (auto j : id[i])
                    p[j] = k--;
            auto now = 0ll;
            for (int i = 1; i &lt;= n; ++i) &#123;
                int sum = 0;
                for (auto j : pos[i])
                    sum += p[j];
                now += std::abs(sum - s[i]);
            &#125;
            if (now &gt;= res)
                res = now, ans = p;
        &#125;
        // std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
        for (int i = 1; i &lt;= m; ++i)
            std::cout &lt;&lt; ans[i] &lt;&lt; &#39; &#39;;
        std::cout &lt;&lt; &#39;\n&#39;;
    &#125;
    return 0;
&#125;


B. 围棋
https://www.becoder.com.cn/contest/6624/problem/2

给定 \(n \times n\) 的棋盘，上面有黑棋、白棋和空地，定义白棋的『气』为四个方向空地的数量，若一个白棋四连通块中所有白棋的『气』都为 0，则认为这个白棋四连通块中的所有白棋是『死的』。
现枚举每个棋子，并将其反转颜色，问『死的』白棋数量。操作是独立的。
3s，\(n\le 10^3\)。


分讨题，需要想清楚。首先需要一次 floodfill 完成染色，记录哪些连通块死了。
若反转黑棋：

若黑棋自己有气，或和黑棋相连的白棋四连通块有气，那么黑棋自己，以及所有和黑棋相连的白棋四连通块都是活的。
此时需要找到所有和黑棋相连的，且死了的白棋四连通块的大小，答案需要减去之。

否则，黑棋自身贡献 \(1\) 的答案。
若反转白棋：

若白棋本身是死的：答案 \(-1\)。
否则，需要考虑有多少个原本是活的白棋此时与有气的白棋不连通，这种情况发生当且仅当有气的白棋是被反转的白棋自身，或者被反转的白棋是割点。
很奇妙的一个想法是建立超级源点，向所有空地连边，再建圆方树，这样这个点的所有儿子就是待求。圆方树并不需要显式地建出来。


代码：不会

C. 相互抵消
https://www.becoder.com.cn/contest/6624/problem/3

给定 \(a_{1\sim n}\)，维护 \(m\) 次操作：

区间加。
给定 \(l,r\)，查询 \(\left(\sum\limits_{i=l}^r\sum\limits_{j=i}^r ((\sum_{k=i}^j a_k)^2 + (r-l+2)\times(j-i)\times a_i\times a_j)\right) \bmod 998244353\)。

\(n,m\le 5\times 10^5\)，强制在线。


题目名字是真在降低难度吧，强制在线就排除离线历史和了；猜测询问所求可以化成一个比较简单的东西。
推一下：
（省略）
\[
=-\left(\sum_{i=l}^r i\cdot a_i\right)^2 + (1-l)(r+1)\left(\sum_{i=l}^r a_i\right)^2+(l+r)\left(\sum_{i=l}^r i\cdot a_i\right)\left(\sum_{i=l}^r a_i\right)
\]
故线段树维护 \(\sum a_i\) 和 \(\sum i\cdot a_i\) 即可。
实际上可以用树状数组维护。


喜提最优解，不得不说 bit 的速度优势还是很明显的。
#include &lt;bits/stdc++.h&gt;
const int mod = 998244353; 
const int inv2 = (mod + 1) &gt;&gt; 1;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
    std::freopen(&quot;offset.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;offset.out&quot;, &quot;w&quot;, stdout);
#else
    std::freopen(&quot;./test/20251008/offset/ex_offset5.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int T, n, q;
    std::cin &gt;&gt; T &gt;&gt; n &gt;&gt; q;
    std::vector&lt;long long&gt; bit(n + 1), bit1(n + 1), bit2(n + 1);
    auto lowbit = [&amp;](int x) &#123;
        return x &amp; -x;
    &#125;;
    auto add = [&amp;](long long x, long long v) &#123;
        auto v1 = x * v % mod, v2 = x * x % mod * v % mod;
        for (; x &lt;= n; x += lowbit(x)) &#123;
            (bit[x] += v) %= mod;
            (bit1[x] += v1) %= mod;
            (bit2[x] += v2) %= mod;
        &#125;
        return;
    &#125;;
    auto ask = [&amp;](long long x) &#123;
        auto res = 0ll, res1 = 0ll, res2 = 0ll;
        for (int i = x; i; i -= lowbit(i))
            (res += bit[i]) %= mod, (res1 += bit1[i]) %= mod, (res2 += bit2[i]) %= mod;
        return std::make_pair(((x + 1) * res + mod - res1) % mod, (x * (x + 1) % mod * res % mod + res1 + mod - res2) * inv2 % mod);
    &#125;;
    for (int i = 1, x; i &lt;= n; ++i)
        std::cin &gt;&gt; x, add(i, x), add(i + 1, mod - x);
    for (int op; q--; ) &#123;
        static auto la = 0ll;
        std::cin &gt;&gt; op;
        if (op == 1) &#123;
            int l, r, d;
            std::cin &gt;&gt; l &gt;&gt; r &gt;&gt; d;
            if (T == 1)
                l ^= la, r ^= la, d ^= la;
            add(l, d), add(r + 1, mod - d);
        &#125;
        else &#123;
            long long l, r;
            std::cin &gt;&gt; l &gt;&gt; r;
            if (T == 1)
                l ^= la, r ^= la;
            auto t1 = ask(r), t2 = ask(l - 1);
            auto res1 = t1.first + mod - t2.first, res2 = t1.second + mod - t2.second;
            la = (mod - res2 * res2 % mod + mod - (l - 1) * (r + 1) % mod * res1 % mod * res1 % mod + (l + r) * res1 % mod * res2 % mod) % mod;
            std::cout &lt;&lt; la &lt;&lt; &#39;\n&#39;;
        &#125;
    &#125;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;


A. Happy·Lovely·Everyday!
https://www.becoder.com.cn/contest/6639/problem/1

给定一个长为 \(n\) 的 01 序列，可以执行任意次（可以为 \(0\)）『把相邻两个数合并为其异或值』的操作，问最终能得到的本质不同的序列个数。
\(n\le 2\times 10^6\)。


对于一个最终序列，如果认为它是由某个存活元素『吞并』它左侧的连续死亡元素得到的，会发现最终序列中，此处的前缀异或值就是原序列的前缀异或值。
经典 trick：前缀和可以唯一对应原数组。所以『最终本质不同序列』会和『包含第 \(n\) 个元素的，原序列前缀异或和的本质不同子序列』形成双射。
统计包含第 \(n\) 个元素的，原序列前缀异或和的本质不同子序列即可。复杂度 \(O(n)\)。

How to 本质不同子序列？
令 \(f_i\) 表示 DP 到 \(i\)，且强制选 \(i\) 的本质不同子序列数量，记 \(pre_i\) 为 \(i\) 的前驱（没有则为 \(0\)）。令 \(f_0=1\)，那么：
\[
f_i\gets \sum\limits_{j=pre_i}^{i-1} f_{j}
\]
或，令 \(f_i\) 表示 DP 到 \(i\) 时（不强制选 \(i\)）本质不同子序列数量，记 \(pre_i\) 为 \(i\) 的前驱（没有则为 \(0\)）。令 \(f_0=0\)，那么：
\[
f_i=\begin{cases}
2\cdot f_{i-1}+1&amp;pre_i= 0\\
2\cdot f_{i-1}-f_{pre_i-1}&amp;\text{otherwise}
\end{cases}
\]


How to 强制选第 \(n\) 个元素的本质不同子序列？
令 \(f_i\) 表示 DP 到 \(i\)，且强制选 \(i\) 的本质不同子序列数量，则答案为：
\[
\sum\limits_{a_i=a_n} f_i
\]
或，令 \(f_i\) 表示 DP 到 \(i\)，且不强制选 \(i\) 的本质不同子序列数量，则答案为：
\[
\sum\limits_{a_i=a_n}\begin{cases}
f_{i-1}+1&amp;pre_i= 0\\
f_{i-1}-f_{pre_i-1}&amp;\text{otherwise}
\end{cases}
\]



#include &lt;bits/stdc++.h&gt;
const int mod = 998244353;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
    std::freopen(&quot;a.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;a.out&quot;, &quot;w&quot;, stdout);
#else
    std::freopen(&quot;./test/20251014/a/a1.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int T;
    for (std::cin &gt;&gt; T; T--; ) &#123;
        std::string s;
        std::cin &gt;&gt; s;
        int n = (int)s.length();
        s = &quot;#&quot; + s;
        std::vector&lt;int&gt; a(n + 1);
        for (int i = 1; i &lt;= n; ++i)
            a[i] = a[i - 1] ^ (s[i] - &#39;0&#39;);
        auto res = 0ll;
        std::vector&lt;long long&gt; f(n + 1), la(2);
        for (int i = 1; i &lt;= n; ++i) &#123;
            if (la[a[i]])
                f[i] = (2 * f[i - 1] + mod - f[la[a[i]] - 1]) % mod;
            else
                f[i] = (2 * f[i - 1] + 1) % mod;
            if (a[i] == a[n]) &#123;
                if (la[a[i]])
                    res += (f[i - 1] + mod - f[la[a[i]] - 1]) % mod;
                else
                    res += f[i - 1] + 1;
            &#125;
            la[a[i]] = i;
        &#125;
        std::cout &lt;&lt; res % mod &lt;&lt; &#39;\n&#39;;
    &#125;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;


B. 敬启，致那时的我
https://www.becoder.com.cn/contest/6639/problem/2

定义 \(f_0=f_1=1,f_i=f_{i-1}+f_{i-2}\)，给定 \(n,k\)，求：
\[
\left(\sum_{i=0}^n f_{i}\cdot [\text{popcount}(i)=k]\right)\bmod 10^9+7
\]
\(n\le 2^{2000},0\le k\le \log_2(n)\)。


考虑数位 DP，那么需要能够由 ...xxx 向 ...0xxx 和 ...1xxx 转移。
显然只关心向 ...1xxx 的转移，那么需要再转移 \(2^{?}\) 次，记录转移矩阵的 \(2^{?}\) 次方即可。
这一步也可以不用矩阵，而是用斐波那契 \(f(ab)=...\) 的性质，但显然二者是等价的，无甚必要
根据数位 DP 的实现方式，常数上顺序结构肯定是会吊打递归的。然而并不惯写顺序结构的数位 DP，whatever.


#include &lt;bits/stdc++.h&gt;
const int mod = 1e9 + 7;
struct matrix &#123;
    long long a[2][2];
    matrix() &#123;
        a[0][0] = a[0][1] = a[1][0] = a[1][1] = 0ll;
        return;
    &#125;
    long long* operator[] (const int q) &#123;
        return a[q];
    &#125;
    matrix operator* (matrix &amp;q) const &#123;
        matrix res;
        res[0][0] = (a[0][0] * q[0][0] + a[0][1] * q[1][0]) % mod;
        res[0][1] = (a[0][0] * q[0][1] + a[0][1] * q[1][1]) % mod;
        res[1][0] = (a[1][0] * q[0][0] + a[1][1] * q[1][0]) % mod;
        res[1][1] = (a[1][0] * q[0][1] + a[1][1] * q[1][1]) % mod;
        return res;
    &#125;
    matrix&amp; operator+= (matrix q) &#123;
        if ((a[0][0] += q[0][0]) &gt;= mod) a[0][0] -= mod;
        if ((a[0][1] += q[0][1]) &gt;= mod) a[0][1] -= mod;
        if ((a[1][0] += q[1][0]) &gt;= mod) a[1][0] -= mod;
        if ((a[1][1] += q[1][1]) &gt;= mod) a[1][1] -= mod;
        return *this;
    &#125;
&#125;;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
    std::freopen(&quot;b.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;b.out&quot;, &quot;w&quot;, stdout);
#else
    std::freopen(&quot;./test/20251014/b/b4.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, k;
    std::cin &gt;&gt; n &gt;&gt; k;
    std::vector&lt;int&gt; up(n);
    for (int i = 1; i &lt;= n; ++i) &#123;
        char t;
        std::cin &gt;&gt; t, up[n - i] = t - &#39;0&#39;;
    &#125;
    matrix init, zmat;
    init[0][0] = init[0][1] = 1ll;
    std::vector&lt;matrix&gt; mat(n);
    mat[0][0][1] = mat[0][1][0] = mat[0][1][1] = 1ll;
    for (int i = 1; i &lt; n; ++i)
        mat[i] = mat[i - 1] * mat[i - 1];
    std::vector&lt;std::vector&lt;int&gt; &gt; tag(n, std::vector&lt;int&gt; (k + 1));
    std::vector&lt;std::vector&lt;matrix&gt; &gt; f(n, std::vector&lt;matrix&gt; (k + 1));
    std::function&lt;matrix(int, int, int)&gt; DFS = [&amp;](int x, int k, int fl) &#123;
        if (x == -1) &#123;
            if (k == 0)
                return init;
            return zmat;
        &#125;
        if (!fl &amp;&amp; tag[x][k])
            return f[x][k];
        matrix res = DFS(x - 1, k, fl &amp;&amp; !up[x]);
        if (k &amp;&amp; (!fl || up[x]))
            res += DFS(x - 1, k - 1, fl) * mat[x];
        if (!fl)
            tag[x][k] = 1, f[x][k] = res;
        return res;
    &#125;;
    std::cout &lt;&lt; DFS(n - 1, k, 1)[0][0] &lt;&lt; &#39;\n&#39;;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;


C. Lead to shine more
https://www.becoder.com.cn/contest/6639/problem/3

第 \(0\) 次操作时变量 \(x=1\)，此后每次操作使 \(x\gets x+\text{popcount}(x)\)，给定 \(m\) 次询问：

给定 \(x&#39;\)，问 \(x\) 在第几次操作后变为 \(x&#39;\)，或报告 \(x&#39;\) 不会被经过。

\(m\le 10^5,x&#39;\le 10^{18}\)。


一个朴素的想法是分高低位，则因为每次操作带来的变化量不超过 60，远远低于低位的 \(2^30\)，所以一次操作至多给高位带来 1 的变化量。
高位对整体的贡献只取决于其 popcount，所以可以枚举高位 1 的数量，再枚举初始值，找到第一次让高位变化花的次数。
初始值的可能值有 \(60\) 个，而外层循环有 \(30\) 次，内层循环大概是 \(\dfrac {2^{30}}{60}\) 的，总之无法通过。
题解说方法是对上面的拓展。理解不能。出发点大概是考虑到让第 \(i\) 位变化相当于让 \(i+1\) 位变化两次，所以会有一个递推的关系。
令 \(f_{i, s, d}\) 为前 \(i-1\) 位的 popcount 为 \(d\)，初始值为 \(s\)，让 \(i\) 位变化一次的操作次数；\(g_{i,s,d}\) 为上述变化后 \(x\) 的值。记 \(pos=g_{i-1,s,d}\)，那么有：
\[
g_{i,pos,d}=g_{i-1,pos,d+1}\\
f_{i,pos,d}=f_{i-1,s,d}+f_{i-1,pos,d+1}
\]
其实是一个类似倍增的结构。但恕我实在无法解释怎么想到的。
显然这个式子在 \(i\le 5\) 时是有问题的，这部分我们暴力跑即可。忽略这一部分常数，预处理总复杂度 \(O(\log^3 n)\)。
考虑查询，按照类似数位 DP 的方法从高位到低位模拟进位过程即可。复杂度 \(O(\log n)\)。


#include &lt;bits/stdc++.h&gt;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
    std::freopen(&quot;c.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;c.out&quot;, &quot;w&quot;, stdout);
#else
    std::freopen(&quot;./test/20251014/c/c1.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    using arr = std::vector&lt;long long&gt;;
    using brr = std::vector&lt;arr&gt;;
    using crr = std::vector&lt;brr&gt;;
    crr f(61, brr(256, arr(61))), g(61, brr(256, arr(61)));
    for (int s = 0; s &lt; 256; ++s)
        for (int d = 0; d &lt;= 60; ++d)
            if (d || s) &#123;
                int x = s, cnt = 0;
                for (; x &lt; 256; x += __builtin_popcount(x) + d, ++cnt);
                f[8][s][d] = cnt, g[8][s][d] = x &amp; 255;
            &#125;
    for (int i = 9; i &lt;= 60; ++i)
        for (int s = 0; s &lt; 256; ++s)
            for (int d = 0; d &lt; 60; ++d) &#123;
                int pos = g[i - 1][s][d];
                g[i][s][d] = g[i - 1][pos][d + 1];
                f[i][s][d] = f[i - 1][s][d] + f[i - 1][pos][d + 1];
            &#125;
    int m;
    std::cin &gt;&gt; m;
    for (long long x; m--; ) &#123;
        std::cin &gt;&gt; x;
        auto pos = 1ll, cnt = 0ll, tot = 0ll;
        for (int i = 60; i &gt;= 8; --i)
            if ((x &gt;&gt; i) &amp; 1) &#123;
                cnt += f[i][pos][tot];
                pos = g[i][pos][tot++];
            &#125;
        for (; pos &lt; (x &amp; 255); pos += __builtin_popcountll(pos) + tot, ++cnt);
        // std::cout &lt;&lt; pos &lt;&lt; &#39; &#39; &lt;&lt; cnt &lt;&lt; &#39;\n&#39;;
        if (pos == (x &amp; 255))
            std::cout &lt;&lt; cnt &lt;&lt; &#39;\n&#39;;
        else
            std::cout &lt;&lt; -1 &lt;&lt; &#39;\n&#39;;
    &#125;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;


C. Query On A Tree 17
https://codeforces.com/gym/102759/problem/I

给定一个以 \(1\) 为根的树，点权初始为全 \(0\)。维护 \(m\) 次修改：

1 u，表示把 \(u\) 子树内的点权加一。
2 u v，表示把 \(u,v\) 简单路径上的点权加一。

每次修改后，输出树深度最小的带权重心。
\(n,m\le 10^5\)。


考虑链上的问题，考虑一点小奥做法，把所有点重复其出现次数次，从左到右排列，发现答案在中位数上。
（据组题人所言），这是用来提示正解的。事实上，这是一个和带权重心有关的 trick：

若一个点 \(u\) 是深度最小的带权重心，则其子树权值和必须严格大于总权值的一半。

证明显然，但结论不显然。Whatever.
由这一点会得到，（参照链上的做法），把点重复点权次，并按 dfn 排成一行，取中位数，那么取到的一定在深度最小的重心子树内，（这就是组题人说的提示正解）。
这一点反而没那么显然，推导过程是，深度最小的重心的子树占了大于一半，而其 dfn 又是连续的，（类似滑动窗口），故总能够到中位数。
考虑非深度最小的重心，此时就从严格大于变为不严格大于，导致没有办法很好地精准找到，需要从中位数左右偏移一位，显然是很丑陋的。
因此可以考虑线段树上二分找到中位数（容易发现线段树的 \(x\) 轴本来就是 dfn），然后从这个中位数往上跳，一直跳到满足『子树权值和严格大于总权值一半』的点，就是最浅的重心。
这一点采用倍增即可。

]]></content>
      <tags>
        <tag>DP</tag>
        <tag>树状数组</tag>
        <tag>倍增</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>学习笔记：树状数组</title>
    <url>/20251010/</url>
    <content><![CDATA[我有一个朋友今天才会树状数组（存疑）

因为到了今天还是不会

单点修改，区间查询

树状数组本身是一个多叉树结构。每个点 \(i\) 上保存 \([i-\text{lowbit}(i)+1,i]\) 的和，并指向若干个更小的子区间（彼此不重，且拼起来是自身）

图源 OI Wiki

修改 \(x\)：从包含 \(x\) 的最低点（id 为 \(x\) 且右端点为 \(x\)）一直向上修改包含 \(x\) 的区间。
查询 \([1, x]\)：从右端点为 \(x\) 的区间（id 为 \(x\)）出发，不断找到前方紧邻的区间（\(id\) 差为 lowbit），累加进答案。


区间修改，单点查询

运用序列问题上的技巧，转化为差分数组上的单点修改、前缀查询。
事实上除了基本结构以外的内容，树状数组本身并没有参与，只需当作一个输入单点修改，输出前缀和的黑盒即可。


区间修改，区间查询

考虑沿用差分的方法实现区间修改。考虑数学推导表达区间前缀和。
已知 \(d_i=a_i-a_{i-1}\)，则：
\[
\begin{aligned}
\sum\limits_{i=1}^x a_i=&amp;\sum\limits_{i=1}^x\sum_{j=1}^i d_j\\
=&amp;\sum\limits_{i=1}^x d_i\cdot (x-i+1)\\
=&amp;(x+1)\cdot \left(\sum\limits_{i=1}^x d_i\right) - \left(\sum\limits_{i=1}^x i\cdot d_i\right)
\end{aligned}
\]
故只需要在黑盒中维护 \(d_i\) 和 \(i\cdot d_i\) 的单点修改即可。
在实现时感到违和：对 \([l, r]\) 做区间修改时，对于 \(l\) 处的 \(i\cdot d_i\) 作出了 \(l\cdot \Delta\) 的修改，为何在 \(r+1\) 处作 \((r + 1)\cdot \Delta\) 的修改（而非也是 \(l\cdot \Delta\)？）
事实上，对于 \(i\cdot d_i\) 的修改是对 \(d_i\) 修改的字面反映，这个量本身并没有具体的含义。
感觉有点唐唐的，也就只有我会有这种疑惑了……


Excercise

维护 \(a_i\) 的区间加、\(a_i\) 的区间和查询、\(i\cdot a_i\) 的区间和查询。
令 \(d_i=a_i-a_{i-1}\)，考虑变形：
\[
\begin{aligned}
\sum\limits_{i=1}^x i\cdot a_i=&amp;\sum\limits_{i=1}^xi\cdot \sum_{j=1}^i d_j\\
=&amp;\sum\limits_{i=1}^x d_i\cdot \left(i+(i+1)+\cdots +x\right)\\
=&amp;\sum\limits_{i=1}^x d_i\cdot \dfrac {(x+i)\cdot (x-i+1)}2\\
=&amp;\sum\limits_{i=1}^x d_i\cdot \dfrac {x^2+x-i^2+i}2\\
=&amp;\dfrac{(x^2+x)\cdot \left(\sum\limits_{i=1}^x d_i\right) + \left(\sum\limits_{i=1}^x i\cdot d_i\right) - \left(\sum\limits_{i=1}^x i^2\cdot d_i\right)}2
\end{aligned}
\]
故只需要在黑盒中维护 \(d_i\)、\(i\cdot d_i\) 和 \(i^2\cdot d_i\) 的单点修改即可。
见 相互抵消。


Ex. 北校门外的回忆
https://loj.ac/p/510

定义 \(\text{lowbit}_K(x)\) 为 \(x\) 在 \(K\) 进制下最低非零位的值。有一个异或和树状数组，把原本代码中的 \(\text{lowbit}_2(x)\) 全部替换为 \(\text{lowbit}_K(x)\)，得到一个正确性和复杂度均错误的『树状数组』，现在给定若干次 add 和 ask 操作，你需要输出错误的代码运行的结果。
\(m\le 2\times 10^5\)。


需要意识到并不是真的要用树状数组模拟这个操作，一边转化一边要想办法把这个错误代码用正常 DS 的操作表述出来。
add 的本质是对于非零最低位乘二并进位。手玩可以发现，有的时候『非零最低位』的位置是不变的，有的时候『非零最低位』变成 \(0\) 了，就会前移。
这显然是个 \(x\to 2x\bmod K\) 的内向基环树森林，且当存在自环 \(0\) 时，一个树中的最大跳跃次数为 \(\log_2K\)。

mobai Grisses

故这个时候（即 \(x\) 包含了『\(K\) 除了 \(2\) 之外的因子』时 ）暴力跳即可。对于每一位都这么跳是可以接受的。
\(0\) 不在树中，最终会有一个循环节。不妨把经过的所有点拉出来成为一条链。
这个时候可以停下来想一想题目给的两个操作是在做什么。显然每个叶子会引导一条无限长的链，则 add 就是给这个链做了一个后缀加（\(N\) 的限制是没影响的），ask 则是问了 log 个点值。
则如果这个链真的可以被处理出来，只需要 bit 维护差分即可。
考虑倍增预处理 \(f(i,j)\) 表示 \(i\) 走了 \(2^j\) 步后到的点，模拟跳 \(0\)、倍增跳循环节即可。


BIT 上倍增
更偏数据结构技巧了，也重新回到结构上面。
对标线段树上二分，缺陷在于能维护的数据限制很大，优势在于常数很小。在出题人刻意只放树状数组过，或者树套树外层为树状数组的时候用处比较明显。

冰火战士
https://www.luogu.com.cn/problem/P6619

给定初始为空的二元组数组 \(A, B\)。对于阈值 \(k\)，令 \(s_A\) 表示 \(A\) 中关键字一 \(\le k\) 的元素关键字二之和，\(s_B\) 表示 \(B\) 中关键字一 \(\ge k\) 的元素关键字二之和。
维护若干次 \(A,B\) 的加点、删点操作，每次操作后输出：

自由选取 \(k\)，求 \(\min\{s_A,s_B\}\) 的最大值。

\(m\le 2\times 10^6\)，\(V\le 10^9\)。


不妨考虑固定状态下的询问。容易想到将 \(A,B\) 按关键字一升序排序。随着 \(k\) 的增大，\(s_A\) 是 \(A\) 关键字二的前缀和，\(s_B\) 是 \(B\) 关键字二的后缀和。
我并不会三分，但题解说因为有平台所以三分做不了。
但由于最高点同时是交点，可以二分找到最值点。离散化元素后维护此处的前缀和即可。
容易想到线段树上二分，然而常数太大难以通过。
如果改用树状数组呢？树状数组有办法进行类似线段树上二分的操作吗？
事实上，bit 的结构更适合倍增。其出发点和线段树上二分是相同的，在于规避重复询问。
假设当前在一个合法位置 \(p\)，已经累加到 \(s\)，要验证 \(p+2^k\)（\(\text{lowbit}(p+2^k)=2^k\)）是否仍然合法，仅需 check \(s+c_{p+2^k}\) 是否合法（结合树状数组结构想一想）。


其实 Peace 是有点难判的…… 我写了个结构题维护了数量用来判断。
#include &lt;bits/stdc++.h&gt;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int m;
    std::cin &gt;&gt; m;
    struct query &#123; int op, k, x, y; &#125;;
    std::vector&lt;query&gt; a(m + 1);
    std::vector&lt;int&gt; l(1);
    for (int i = 1; i &lt;= m; ++i) &#123;
        std::cin &gt;&gt; a[i].op &gt;&gt; a[i].k;
        if (a[i].op == 1) &#123;
            std::cin &gt;&gt; a[i].x &gt;&gt; a[i].y;
            l.push_back(a[i].x);
        &#125;
        else &#123;
            int k = a[i].k;
            a[i].op = -1;
            a[i].k = a[k].k, a[i].x = a[k].x, a[i].y = a[k].y;
        &#125;
    &#125;
    std::sort(l.begin() + 1, l.end());
    l.erase(std::unique(l.begin() + 1, l.end()), l.end());
    int n = (int)l.size();
    std::vector&lt;int&gt; cnt(2);
    std::vector&lt;long long&gt; sum(2);
    struct node &#123;
        int c;
        long long v;
        node(void): c(0), v(0ll) &#123;&#125;
        node(int c1, long long v1): c(c1), v(v1) &#123;&#125;
        node operator+ (const node &amp;q) const &#123;
            return node(c + q.c, v + q.v);
        &#125;
        node operator- (const node &amp;q) const &#123;
            return node(c - q.c, v - q.v);
        &#125;
        node&amp; operator+= (const node q) &#123;
            return *this = *this + q;
        &#125;
        node &amp;operator-= (const node &amp;q) &#123;
            return *this = *this - q;
        &#125;
    &#125;;
    std::vector&lt;std::vector&lt;node&gt; &gt; bit(2, std::vector&lt;node&gt; (n + 1)), s(2, std::vector&lt;node&gt; (n + 1));
    auto lowbit = [&amp;](int x) &#123; return x &amp; -x; &#125;;
    for (int i = 1; i &lt;= m; ++i) &#123;
        a[i].x = std::lower_bound(l.begin() + 1, l.end(), a[i].x) - l.begin() + a[i].k;
        cnt[a[i].k] += a[i].op, sum[a[i].k] += a[i].op * a[i].y;
        s[a[i].k][a[i].x] += node(a[i].op, a[i].op * a[i].y);
        for (int j = a[i].x; j &lt;= n; j += lowbit(j))
            bit[a[i].k][j] += node(a[i].op, a[i].op * a[i].y);
        if (std::min(cnt[0], cnt[1]) == 0)
            std::cout &lt;&lt; &quot;Peace\n&quot;;
        else &#123;
            int p = 0;
            node s0(0, 0ll), s1(cnt[1], sum[1]);
            for (int i = 20; ~i; --i)
                if (p + (1 &lt;&lt; i) &lt;= n &amp;&amp; (s0 + bit[0][p + (1 &lt;&lt; i)]).v &lt;= (s1 - bit[1][p + (1 &lt;&lt; i)]).v)
                    p += (1 &lt;&lt; i), s0 += bit[0][p], s1 -= bit[1][p];
            if (p + 1 &lt;= n &amp;&amp; s1.c != s[1][p + 1].c &amp;&amp; (s1 - s[1][p + 1]).v &gt;= s0.v) &#123;
                s1 -= s[1][p + 1], s0 = node(cnt[1], sum[1]), p = 0;
                for (int i = 20; ~i; --i)
                    if (p + (1 &lt;&lt; i) &lt;= n &amp;&amp; (s0 - bit[1][p + (1 &lt;&lt; i)]).v &gt;= s1.v)
                        p += (1 &lt;&lt; i), s0 -= bit[1][p];
                std::cout &lt;&lt; l[p] &lt;&lt; &#39; &#39; &lt;&lt; 2 * s1.v &lt;&lt; &#39;\n&#39;;
            &#125;
            else if (s0.c)
                std::cout &lt;&lt; l[p] &lt;&lt; &#39; &#39; &lt;&lt; 2 * s0.v &lt;&lt; &#39;\n&#39;;
            else
                std::cout &lt;&lt; &quot;Peace\n&quot;;
        &#125;
    &#125;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;


sails 船帆
https://www.luogu.com.cn/problem/P4647

需要意识到帆的顺序对答案没有影响，同一行帆的个数对答案有影响。
从这一点出发会有一个比较显然的贪心：把柱状图斜过来，把柱子按 \(h\) 从小到大排序，问题变为对于第 \(i\) 次操作，选 \(1\sim h_i\) 里最矮的几列使其高度 +1。
其实会有一些其他的贪心方法，比如我一开始想的是不排序，在 \(1\sim h_i\) 内，优先使最矮的高度 +1，高度相同的使编号更大的柱子高度 +1。这个的正确性也比较好证明，但是太复杂了，没什么好的优化。把贪心策略中的偏序关系提前到一次排序就会简单很多。
现在需要找到最矮的这几列。我会文艺平衡树
考虑更加天才的做法。如果我们需要用 bit，线段树这样的结构来维护操作，就会有一些问题： 为了快速修改，需要保证修改的元素是连续的。简单的方法是让元素有序地在 ds 中排列。但修改操作本身会破坏这样的偏序关系。
不妨假设元素降序排列（和后方的 0 衔接），那么需要把 \([h-k+1,h]\) 这段元素 +1，但这会造成部分元素的前移，考虑前移的过程到底发生了什么。
考虑这样的场景：

由于 delta 为 1，至多只会有一段数发生这样的前移。先 ask 一下 \(h-k+1\) 处的值，假设这一段的左右端点为 \([l,r]\)，只需要修改 \([l,l+(r-(h-k+1))]\) 和 \([r+1,h]\) 两段区间即可。
\([l,r]\) 是可以通过 bit 上倍增求出的。复杂度 \(O(n\log n)\)。


Insert
https://www.luogu.com.cn/problem/AT_abc392_f

维护每个数的位置，相当于给值在 \([P_i,i-1]\) 的元素做区间 +1，显然右端点是单增的，那么就转化为上一题。


买宝石
https://www.becoder.com.cn/contest/6620/problem/4
见 树套树。
]]></content>
      <tags>
        <tag>树状数组</tag>
        <tag>倍增</tag>
      </tags>
  </entry>
  <entry>
    <title>杂题选谈：生成树 III</title>
    <url>/20251013/</url>
    <content><![CDATA[mst，以及 mst related


Boruvka

用途：\(O(m\log n)\) 求 mst。
过程：

考虑和 Kruskal、Prim 类似的孤立点 \(\to\) 加边 \(\to\) 树。
每一轮算法，对于当前的每个连通块，找到其连向其它连通块的边中最小的一条，并在这一轮后加入边集（用并查集维护连通块合并）。
重复执行该算法，最终找到 mst。




图源 OI Wiki


复杂度：每一轮中，每个连通块都会被合并一次，故一轮之后现存连通块数量最坏情况下变为原来的一半。也即共执行 \(\log n\) 轮。复杂度 \(O(m\log n)\)。
优势：对于特殊边权的完全图 / 稠密图，边权并不由输入直接给定，而是由顶点计算得到，此时若可以依据性质直接找到连通块的最小边，则复杂度降低至 \(O(n\log n)\) 之类非常优秀的级别（注意并查集的 log 和 Boruvka 本身的 log 是平行的）。
『依据性质找到最小的边』的一个 Bonus：见 KDT + Boruvka 做法的 平面欧几里得最小生成树。


A - Jumping Around
https://www.luogu.com.cn/problem/CF1550F

本题就是『特殊边权完全图』的体现。定义任意两个点之间的边权为两个点相互跳需要的最小的 \(k=||x_0-x_1|-d|\)，那么只需求瓶颈路。
做 Boruvka 即可。考虑怎么求某个连通块的最小边，预处理出每个位置（包括空位）前 / 后第一个和自己颜色不同的非空位，每次 check \(i\pm d\)：

若该位置存在和当前位置不同颜色的点：连边。
否则，若该位置和当前位置颜色相同：转到刚刚求出的前驱、后继，选更小者连边。
否则该位为空。前驱、后继则转化为上面两种情况。

和双指针做法不同，似乎并不支持离散化，只能做到 \(O(V\log n)\)。


#include &lt;bits/stdc++.h&gt;
const int V = 1e6;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, q, s, d;
    std::cin &gt;&gt; n &gt;&gt; q &gt;&gt; s &gt;&gt; d;
    std::vector&lt;int&gt; a(n + 1), tab(V + 1);
    for (int i = 1; i &lt;= n; ++i)
        std::cin &gt;&gt; a[i], tab[a[i]] = i;
    std::vector&lt;std::pair&lt;int, int&gt; &gt; to(n + 1);
    std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; g(n + 1);
    std::vector&lt;int&gt; u(V + 1), pre(V + 1), nex(V + 1), mn(n + 1), f(n + 1), pos;
    std::iota(f.begin() + 1, f.end(), 1);
    std::function&lt;int(int)&gt; find = [&amp;](int x) &#123;
        return x == f[x] ? x : f[x] = find(f[x]);
    &#125;;
    for (int tot = n; tot != 1; ) &#123;
        pos.clear();
        for (int i = 1; i &lt;= n; ++i) &#123;
            if (f[i] == i) &#123;
                mn[i] = 0x3f3f3f3f, to[i] = &#123; 0, 0 &#125;;
                pos.push_back(i);
            &#125;
            u[a[i]] = find(i);
            if (u[a[i - 1]] == u[a[i]])
                pre[a[i]] = pre[a[i - 1]];
            else
                pre[a[i]] = a[i - 1];
        &#125;
        for (int i = 1; i &lt;= V; ++i)
            if (!u[i])
                pre[i] = u[i - 1] ? i - 1 : pre[i - 1];
        nex[a[n]] = V + 1;
        for (int i = n - 1; i; --i)
            if (u[a[i + 1]] == u[a[i]])
                nex[a[i]] = nex[a[i + 1]];
            else
                nex[a[i]] = a[i + 1];
        nex[V] = V + 1;
        for (int i = V - 1; i; --i)
            if (!u[i])
                nex[i] = u[i + 1] ? i + 1 : nex[i + 1];
        for (int i = 1; i &lt;= n; ++i) &#123;
            int x = a[i], now = 0x3f3f3f3f, pos = 0;
            auto upd = [&amp;](int x1) &#123;
                if (std::abs(std::abs(x - x1) - d) &lt; now)
                    now = std::abs(std::abs(x - x1) - d), pos = x1;
                return;
            &#125;;
            auto trans = [&amp;](int x1) &#123;
                if (pre[x1])
                    upd(pre[x1]);
                if (nex[x1] != V + 1)
                    upd(nex[x1]);
                return;
            &#125;;
            std::function&lt;void(int)&gt; work = [&amp;](int x1) &#123;
                if (u[x1] &amp;&amp; u[x1] != u[x])
                    upd(x1);
                else if (u[x1])
                    trans(x1);
                else &#123;
                    if (pre[x1])
                        work(pre[x1]);
                    if (nex[x1] != V + 1)
                        work(nex[x1]);
                &#125;
                return;
            &#125;;
            work(std::max(1, x - d)), work(std::min(V, x + d));
            if (now &lt; mn[u[x]])
                mn[u[x]] = now, to[u[x]] = &#123; i, tab[pos] &#125;;
        &#125;
        for (auto i : pos) &#123;
            int j = u[a[to[i].second]], x = to[i].first, y = to[i].second;
            if (find(i) != find(j)) &#123;
                --tot;
                f[find(i)] = find(j);
                g[x].emplace_back(y, mn[i]), g[y].emplace_back(x, mn[i]);
            &#125;
        &#125;
    &#125;
    std::vector&lt;int&gt; res(n + 1);
    std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int fa) &#123;
        for (auto [i, w] : g[x])
            if (i != fa) &#123;
                res[i] = std::max(res[x], w);
                DFS(i, x);
            &#125;
        return;
    &#125;;
    DFS(s, -1);
    for (int x, k; q--; ) &#123;
        std::cin &gt;&gt; x &gt;&gt; k;
        std::cout &lt;&lt; ((res[x] &lt;= k) ? &quot;Yes&quot; : &quot;No&quot;) &lt;&lt; &#39;\n&#39;;
    &#125;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;


B - Parametric MST
https://www.luogu.com.cn/problem/CF1656F

可以猜到能够把答案写出来，但是发现太抽象了以至于不太好模拟。
首先需要猜到题目给的 \(w\) 是可以继续化的，注意到 \(a_i\cdot a_j+t(a_i+a_j)\) 可以写成 \((a_j+t)\cdot a_i+t\cdot a_i\) 的一次函数形式，一个很重要的思路是放弃模拟 mst 转而从点出发贪心
\(t\) 会影响的是斜率 \(a_j+t\)，所以应该根据 \(a_j+t\) 的正负情况选择贪心策略。
当 \(a_j+t\le 0\) 时，使 \(a_j\) 向 \(a_{\max}\) 连边，否则向 \(a_{\min}\) 连边。
这其实是 Boruvka 第一轮的过程；此时只剩至多两个连通块，连边方式也就讨论一下 \(a_1+t\) 和 \(a_n+t\) 的正负，然后很显然了。
当 \(t\) 足够小时，所有点都会连向 \(a_{\max}\)；反之，当 \(t\) 足够大时，所有点都会连向 \(a_{\min}\)。
对于第一种情况，mst 的权为 \(a_{\max}\cdot (s - a_{\max}) + t\cdot ((n-1)\cdot a_{\max}+s-a_{\max})\)；第二种情况，mst 的权为 \(a_{\min}\cdot (s - a_{\min}) + t\cdot ((n-1)\cdot a_{\min}+s-a_{\min})\)，check \(t\) 的系数即可判 INF。
通过上面一种情况，可以注意到 \(t\in[-a_{\max},-a_{\min}]\)，进一步需要猜到 \(t\) 取某个 \(-a_i\)。由于连的边是很已知的，可以发现当 \(t\) 夹在两个连续的 \(-a\) 之间时，mst 的连边情况是不变的。
显然此时 mst 的权是一个关于 \(t\) 的一次函数，故 check 两端点即可。排序即可快速 check。
由于此时第二轮 Boruvka 要连的边一定是 \((a_1,a_n)\)，连上即可。


#include &lt;bits/stdc++.h&gt;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int T;
    for (std::cin &gt;&gt; T; T--; ) &#123;
        int n;
        std::cin &gt;&gt; n;
        std::vector&lt;long long&gt; a(n + 1), s(n + 1);
        for (int i = 1; i &lt;= n; ++i)
            std::cin &gt;&gt; a[i];
        std::sort(a.begin() + 1, a.end());
        std::partial_sum(a.begin() + 1, a.end(), s.begin() + 1);
        if ((n - 1) * a[n] + s[n - 1] &lt; 0ll || (n - 1) * a[1] + s[n] - a[1] &gt; 0ll)
            std::cout &lt;&lt; &quot;INF\n&quot;;
        else &#123;
            long long res = -1e18;
            for (int i = 1; i &lt;= n; ++i) &#123;
                auto t = -a[i], sl = s[i] - a[1], sr = s[n - 1] - s[i];
                res = std::max(res, a[n] * sl + a[1] * sr + t * ((i - 1) * a[n] + (n - 1 - i) * a[1] + sl + sr) + a[1] * a[n] + t * (a[1] + a[n]));
            &#125;
            std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
        &#125;
    &#125;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;


C - Star MST
https://www.luogu.com.cn/problem/CF1657E

模拟 Kruskal 的过程，在边权 \(w\) 处出现 \((1,x)\)，那么允许在 \(\ge w\) 处出现其他与 \(x\) 相关的边。
会有一个比较暴力的想法，设 \(f_{i,j,l}\) 表示已经分配完边权 \(i\)，共分配了 \(j\) 条与 \(1\) 相关的边，还剩下 \(l\) 条空闲边可以放，会有一个 \(O(k\cdot n^4)\) 的转移。
考虑优化。容易注意到没必要存 \(l\) 而是可以当场完成分配，但这样就导致 \(i\) 维的限制转化为『恰好』，需要额外枚举一轮。总之可以得到：
\[
f_{i,j}=\sum_{d_i=1}^{i}\sum_{d_j=1}^{j} C_{n-(j-d_j)}^{d_j}\times f_{i-d_i,j-d_j}\times (k-i+1)^{C_{d_j}^2+d_j\times (j-d_j)}
\]
此时复杂度为 \(O(k^2n^2\log k)\)，依然不够看；注意到交换求和顺序可以前缀和优化，故：
\[
f_{j, i}=\sum_{d_j=1}^{j} C_{n-(j-d_j)}^{d_j}\times (k-i+1)^{C_{d_j}^2+d_j\times (j-d_j)}\times \sum_{d_i=1}^{i}f_{j - d_j,i-d_i}
\]
复杂度 \(O(kn^2\log k)\)。\(\log\) 来源于快速幂。当然可以考虑预处理优化掉 log，whatever.


#include &lt;bits/stdc++.h&gt;
const int mod = 998244353;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, k;
    std::cin &gt;&gt; n &gt;&gt; k;
    std::vector&lt;std::vector&lt;long long&gt; &gt; C(n + 1, std::vector&lt;long long&gt; (n + 1));
    for (int i = 0; i &lt;= n; ++i) &#123;
        C[i][0] = 1ll;
        for (int j = 1; j &lt;= i; ++j)
            C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % mod;
    &#125;
    auto qkp = [&amp;](long long x, int y) &#123;
        auto res = 1ll;
        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)
            if (y &amp; 1)
                (res *= x) %= mod;
        return res;
    &#125;;
    std::vector&lt;std::vector&lt;long long&gt; &gt; s(n, std::vector&lt;long long&gt; (k + 1));
    for (int i = 0; i &lt;= k; ++i)
        s[0][i] = 1ll;
    for (int j = 1; j &lt; n; ++j)
        for (int i = 1; i &lt;= k; ++i) &#123;
            for (int dj = 1; dj &lt;= j; ++dj) 
                s[j][i] += C[n - (j - dj) - 1][dj] * qkp(k - i + 1, (C[dj][2] + dj * (j - dj)) % mod) % mod * s[j - dj][i - 1] % mod;
            (s[j][i] += s[j][i - 1]) %= mod;
        &#125;
    std::cout &lt;&lt; s[n - 1][k] &lt;&lt; &#39;\n&#39;;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;


D - Smooth Sailing (Hard Version)
https://www.luogu.com.cn/problem/CF1920F2

实在十分熟悉，之前在哪道 CF 题遇到过这个 trick，然而没什么回忆线索，遂放弃
一个连通块被包围的充要条件：从连通块边缘任意一个点向任意方向发一条射线，垂直经过路径奇数次。
垂直：即切线不切换奇偶状态。
这个东西其实来源于计算几何，但是我的数学水平只停留在听说过计算几何四个字的水平，故不深究了。
这种网格图上的图论问题，可以往欧拉定理（\(v-e+f=2\)），计算几何考虑，
怎么在保证这一点的前提下求 mst 呢？答案是丢到状态里。
找一个最靠左的点往左边引一条射线并标记沿路经过的点。令 \((x, y, 0/1)\) 表示走到 \((x, y)\)，经过关键点偶数次 / 奇数次。边权啥的也没什么好说的，点权前移即可。
询问的转化反而不太好想，其实就是问 \((x,y,0)\) 到 \((x,y,1)\) 的瓶颈路。
巧得有些不太自然，然而并没找到合理的解释。
询问建个 Kruskal 重构树找 LCA 即可，复杂度 \(O(nm\log nm)\)。


#include &lt;bits/stdc++.h&gt;
const int dir[][2] = &#123;&#123; -1, 0 &#125;, &#123; 1, 0 &#125;, &#123; 0, -1 &#125;, &#123; 0, 1 &#125;&#125;;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, m, q;
    std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;
    int cnt = 2 * n * m;
    std::vector&lt;int&gt; W(1);
    std::vector&lt;std::vector&lt;int&gt; &gt; g(2 * n * m + 1);
    auto fun = [&amp;](int i, int j, int k) &#123;
        return k * n * m + (i - 1) * m + j;
    &#125;;
    &#123;
        int px = 0, py = m + 1;
        std::vector&lt;std::vector&lt;char&gt; &gt; a(n + 1, std::vector&lt;char&gt; (m + 1));
        for (int i = 1; i &lt;= n; ++i)
            for (int j = 1; j &lt;= m; ++j) &#123;
                std::cin &gt;&gt; a[i][j];
                if (a[i][j] == &#39;#&#39; &amp;&amp; j &lt; py)
                    px = i, py = j;
            &#125;
        std::vector&lt;std::vector&lt;int&gt; &gt; w(n + 1, std::vector&lt;int&gt; (m + 1, 0x3f3f3f3f));
        &#123;
            std::queue&lt;std::pair&lt;int, int&gt; &gt; q;
            for (int i = 1; i &lt;= n; ++i)
                for (int j = 1; j &lt;= m; ++j)
                    if (a[i][j] == &#39;v&#39;)
                        q.emplace(i, j), w[i][j] = 0;
            for (; !q.empty(); ) &#123;
                auto [x, y] = q.front();
                q.pop();
                for (auto [fx, fy] : dir) &#123;
                    int nx = x + fx, ny = y + fy;
                    if (nx &gt;= 1 &amp;&amp; nx &lt;= n &amp;&amp; ny &gt;= 1 &amp;&amp; ny &lt;= m &amp;&amp; w[nx][ny] == 0x3f3f3f3f) &#123;
                        w[nx][ny] = w[x][y] + 1;
                        q.emplace(nx, ny);
                    &#125;
                &#125;
            &#125;
        &#125;
        struct edge &#123; int u, v, w; &#125;;
        std::vector&lt;edge&gt; e;
        for (int i = 1; i &lt;= n; ++i)
            for (int j = 1; j &lt;= m; ++j)
                if (a[i][j] != &#39;#&#39;) &#123;
                    if (j != m &amp;&amp; a[i][j + 1] != &#39;#&#39;) &#123;
                        e.push_back(&#123; fun(i, j, 0), fun(i, j + 1, 0), std::min(w[i][j], w[i][j + 1]) &#125;);
                        e.push_back(&#123; fun(i, j, 1), fun(i, j + 1, 1), std::min(w[i][j], w[i][j + 1]) &#125;);
                    &#125;
                    if (i != n &amp;&amp; a[i + 1][j] != &#39;#&#39;) &#123;
                        if (i + 1 == px &amp;&amp; j &lt;= py) &#123;
                            e.push_back(&#123; fun(i, j, 0), fun(i + 1, j, 1), std::min(w[i][j], w[i + 1][j]) &#125;);
                            e.push_back(&#123; fun(i, j, 1), fun(i + 1, j, 0), std::min(w[i][j], w[i + 1][j]) &#125;);
                        &#125;
                        else &#123;
                            e.push_back(&#123; fun(i, j, 0), fun(i + 1, j, 0), std::min(w[i][j], w[i + 1][j]) &#125;);
                            e.push_back(&#123; fun(i, j, 1), fun(i + 1, j, 1), std::min(w[i][j], w[i + 1][j]) &#125;);
                        &#125;
                    &#125;
                &#125;
        std::sort(e.begin(), e.end(), [&amp;](edge &amp;x, edge &amp;y) &#123; return x.w &gt; y.w; &#125;);
        std::vector&lt;int&gt; f(2 * n * m + 1);
        std::iota(f.begin() + 1, f.end(), 1);
        std::function&lt;int(int)&gt; find = [&amp;](int x) &#123;
            return x == f[x] ? x : f[x] = find(f[x]);
        &#125;;
        for (auto [x, y, w] : e)
            if (find(x) != find(y)) &#123;
                f.push_back(++cnt);
                W.push_back(w), g.emplace_back();
                g[cnt].push_back(find(x)), g[cnt].push_back(find(y));
                f[find(x)] = f[find(y)] = cnt;
            &#125;
    &#125;
    std::vector&lt;int&gt; fa(cnt + 1), siz(cnt + 1), dep(cnt + 1), son(cnt + 1), top(cnt + 1);
    std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;
        siz[x] = 1;
        for (auto i : g[x]) &#123;
            dep[i] = dep[x] + 1;
            DFS(i), fa[i] = x;
            siz[x] += siz[i];
            if (siz[i] &gt; siz[son[x]])
                son[x] = i;
        &#125;
        return;
    &#125;;
    dep[1] = 1, DFS(cnt);
    DFS = [&amp;](int x) &#123;
        if (son[x])
            top[son[x]] = top[x], DFS(son[x]);
        for (auto i : g[x])
            if (i != son[x])
                top[i] = i, DFS(i);
        return;
    &#125;;
    top[cnt] = cnt, DFS(cnt);
    auto ask = [&amp;](int x, int y) &#123;
        for (; top[x] != top[y]; x = fa[top[x]])
            if (dep[top[x]] &lt; dep[top[y]])
                std::swap(x, y);
        return dep[x] &lt; dep[y] ? x : y;
    &#125;;
    for (int x, y; q--; ) &#123;
        std::cin &gt;&gt; x &gt;&gt; y;
        std::cout &lt;&lt; W[ask(fun(x, y, 0), fun(x, y, 1)) - 2 * n * m] &lt;&lt; &#39;\n&#39;;
    &#125;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;


E - Turtle and Intersected Segments
https://www.luogu.com.cn/problem/CF1981E

考虑绝对值的几何意义，很容易发现有的边注定是无效的：

如图中三条线段形成一个环，权值如图，排除掉权值最大的边，发现只会连权值相邻的边

换句话说，对于数轴上的这个点，仅需把覆盖之的所有线段序列按 \(a\) 排序，连接相邻者即可。怎么更快地实现这个过程呢？
发现只需要在这个线段序列变化的时候连新的边，故用 multiset 维护这个序列，扫一遍，在加入新线段时连接它和前驱后继即可（结合前文论述发现删除的时候不用管）。


#include &lt;bits/stdc++.h&gt;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int T;
    for (std::cin &gt;&gt; T; T--; ) &#123;
        int n;
        std::cin &gt;&gt; n;
        struct node &#123; int l, r, v; &#125;;
        struct edge &#123; int u, v, w; &#125;;
        std::vector&lt;edge&gt; e;
        std::vector&lt;node&gt; a(n + 1);
        for (int i = 1; i &lt;= n; ++i)
            std::cin &gt;&gt; a[i].l &gt;&gt; a[i].r &gt;&gt; a[i].v;
        std::sort(a.begin() + 1, a.end(), [&amp;](node &amp;x, node &amp;y) &#123; return x.l &lt; y.l; &#125;);
        std::set&lt;std::tuple&lt;int, int, int&gt; &gt; t;
        std::set&lt;std::pair&lt;int, int&gt; &gt; now;
        for (int i = 1; i &lt;= n; ++i) &#123;
            for (; !t.empty();) &#123;
                auto [r, v, id] = *t.begin();
                if (r &gt;= a[i].l)
                    break;
                now.erase(std::make_pair(v, id));
                t.erase(t.begin());
            &#125;
            auto p = now.lower_bound(std::make_pair(a[i].v, i));
            if (p != now.end())
                e.push_back(&#123; i, p-&gt;second, p-&gt;first - a[i].v &#125;);
            if (p != now.begin()) &#123;
                --p;
                e.push_back(&#123; i, p-&gt;second, a[i].v - p-&gt;first &#125;);
            &#125;
            t.emplace(a[i].r, a[i].v, i), now.emplace(a[i].v, i);
        &#125;
        std::sort(e.begin(), e.end(), [&amp;](edge &amp;x, edge &amp;y) &#123; return x.w &lt; y.w; &#125;);
        auto res = 0ll;
        std::vector&lt;int&gt; f(n + 1);
        std::iota(f.begin() + 1, f.end(), 1);
        std::function&lt;int(int)&gt; find = [&amp;](int x) &#123;
            return x == f[x] ? x : f[x] = find(f[x]);
        &#125;;
        int cntm = 0;
        for (auto [u, v, w] : e)
            if (find(u) != find(v)) &#123;
                f[find(u)] = find(v);
                res += w, ++cntm;
            &#125;
        if (cntm == n - 1)
            std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
        else
            std::cout &lt;&lt; -1 &lt;&lt; &#39;\n&#39;;
    &#125;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;


F - Digital Village (Extreme Version)
https://www.luogu.com.cn/problem/CF2021E3

为啥会想到 DP（。）前面不都是神秘建图题吗（。）
会发现待求即为重构树上 LCA 的权值，但题设中的 Key 是设置了服务器的结点，二者不匹配。如果直接设 \(f_{x,j}\) 表示 \(x\) 子树内设了 \(j\) 个服务器，感觉不太可行。
当然也可能是因为我没做过重构树上的 DP。Whatever.
实际上需要结合重构树的性质考虑。发现一个子树内部不能消化，当且仅当

]]></content>
      <tags>
        <tag>最小生成树</tag>
        <tag>Kruskal 重构树</tag>
      </tags>
  </entry>
  <entry>
    <title>杂题选谈：生成树</title>
    <url>/20251020/</url>
    <content><![CDATA[mst，怎么还有 mst related


A - st-Spanning Tree
https://www.luogu.com.cn/problem/CF723F

看起来形似最小度限制生成树，但没有边权导致失去了凸性，wqs 二分不再可行。
这也启示我们放弃 mst 算法，重新回到连通性看待本题。即尝试在不影响连通性的前提下，让 \(s,t\) 在原图上的度数减少到对应值。
发现 \(s,t\) 的决策会相互影响：

好消息是有且仅有这两种情况会干扰决策。胡乱贪心即可。
考虑忽略与 \(s,t\) 有关的边跑一遍 DFS，得到若干连通块，显然它们会分为只与 \(s,t\) 中一者有关 / 与二者都有关两类。

连通块内部：建 DFS 树即可。
先处理对于只与 \(s,t\) 中的一个有关的连通块：将其与对应 \(s,t\) 相连。
再处理对于与二者都有关的连通块：若 \((s, t)\) 不连通，则先找一个把 \(s\) 和 \(t\) 连通起来；剩下的看看哪个能连就连哪个。
最后看看是否存在边 \((s, t)\) 且不存在上一种情况（也就是 \(s,t\) 不连通），如果满足就连起来。

为什么是这个连边顺序呢，发现 \((s,t)\) 会用一条边消耗两次度数，故放在最后；其他两者先解决更严格的一者。故有。


#include &lt;bits/stdc++.h&gt;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, m;
    std::cin &gt;&gt; n &gt;&gt; m;
    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1), ps(n + 1), pt(n + 1);
    for (int x, y; m--; ) &#123;
        std::cin &gt;&gt; x &gt;&gt; y;
        g[x].push_back(y), g[y].push_back(x);
    &#125;
    int s, t, ds, dt;
    std::cin &gt;&gt; s &gt;&gt; t &gt;&gt; ds &gt;&gt; dt;
    std::vector&lt;int&gt; col(n + 1);
    std::vector&lt;std::pair&lt;int, int&gt; &gt; res;
    int now = 0;
    std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;
        col[x] = now;
        for (auto i : g[x])
            if (i == s)
                ps[now].push_back(x);
            else if (i == t)
                pt[now].push_back(x);
            else if (!col[i])
                res.emplace_back(x, i), DFS(i);
        return;
    &#125;;
    for (int i = 1; i &lt;= n; ++i)
        if (i != s &amp;&amp; i != t &amp;&amp; !col[i])
            ++now, DFS(i);
    for (int i = 1; i &lt;= now; ++i)
        if (!ps[i].empty() &amp;&amp; !pt[i].empty());
        else if (!ps[i].empty())
            res.emplace_back(ps[i].back(), s), --ds;
        else
            res.emplace_back(pt[i].back(), t), --dt;
    if (ds &lt;= 0 || dt &lt;= 0) &#123;
        std::cout &lt;&lt; &quot;No&quot; &lt;&lt; &#39;\n&#39;;
        return 0;
    &#125;
    bool flag = false;
    for (int i = 1; i &lt;= now; ++i)
        if (!ps[i].empty() &amp;&amp; !pt[i].empty()) &#123;
            if (flag == false) &#123;
                res.emplace_back(ps[i].back(), s), --ds;
                res.emplace_back(pt[i].back(), t), --dt;
                flag = true;
            &#125;
            else if (ds)
                res.emplace_back(ps[i].back(), s), --ds;
            else if (dt)
                res.emplace_back(pt[i].back(), t), --dt;
            else &#123;
                std::cout &lt;&lt; &quot;No&quot; &lt;&lt; &#39;\n&#39;;
                return 0;
            &#125;
        &#125;
    if (flag == false)
        for (auto i : g[s])
            if (i == t) &#123;
                res.emplace_back(s, t);
                --ds, --dt, flag = true;
            &#125;
    if (flag == false) &#123;
        std::cout &lt;&lt; &quot;No&quot; &lt;&lt; &#39;\n&#39;;
        return 0;
    &#125;
    assert((int)res.size() == n - 1);
    std::cout &lt;&lt; &quot;Yes&quot; &lt;&lt; &#39;\n&#39;;
    for (auto [u, v] : res)
        std::cout &lt;&lt; u &lt;&lt; &#39; &#39; &lt;&lt; v &lt;&lt; &#39;\n&#39;;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;


B - 0-1 MST
https://www.luogu.com.cn/problem/CF1242B

发现实际上是在问删掉这 \(m\) 条边后还剩多少个连通块。
容易发现删的边相对来说比较少，或者说在 \(10^5\) 这个限制下很难分成很多个很大的连通块。
正解利用了鸽巢原理证明这个事情：相当于把 \(m\) 次删边分配给 \(n\) 个点，那么至少存在一个点，被删掉的边不超过 \(\left\lfloor \frac mn\right\rfloor\) 条。那么这个点带领的菊花形成了一个大小至少为 \(n-\left\lfloor \frac mn\right\rfloor\) 的连通子图。
剩余的 \(\left\lfloor \frac mn\right\rfloor\) 个点，目测不是很大，事实上又是神秘不等式：\(\left\lfloor \frac mn\right\rfloor^2&lt;n\times \left\lfloor \frac mn\right\rfloor=m\)。可以暴力枚举点对查看是否有边。
对于菊花上可能的其他连边，仍然神秘不等式，\(\left\lfloor \frac mn\right\rfloor\times (n-\left\lfloor \frac mn\right\rfloor)=\left\lfloor \frac mn\right\rfloor\times n-\left\lfloor \frac mn\right\rfloor^2&lt;\left\lfloor \frac mn\right\rfloor\times n=m\)，仍然暴力枚举即可。


#include &lt;bits/stdc++.h&gt;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, m;
    std::cin &gt;&gt; n &gt;&gt; m;
    std::vector&lt;int&gt; f(n + 1);
    std::iota(f.begin() + 1, f.end(), 1);
    std::function&lt;int(int)&gt; find = [&amp;](int x) &#123;
        return x == f[x] ? x : f[x] = find(f[x]);
    &#125;;
    auto merge = [&amp;](int x, int y) &#123;
        if (find(x) == find(y))
            return false;
        f[find(x)] = find(y);
        return true;
    &#125;;
    std::vector&lt;int&gt; deg(n + 1, n - 1);
    std::set&lt;std::pair&lt;int, int&gt; &gt; t;
    for (int u, v; m--; ) &#123;
        std::cin &gt;&gt; u &gt;&gt; v;
        t.emplace(std::min(u, v), std::max(u, v)), --deg[u], --deg[v];
    &#125;
    int u = std::max_element(deg.begin() + 1, deg.end()) - deg.begin();
    std::vector&lt;int&gt; p1, p2;
    for (int i = 1; i &lt;= n; ++i)
        if (i == u || !t.count(&#123; std::min(u, i), std::max(u, i) &#125;))
            p1.push_back(i), merge(u, i);
        else
            p2.push_back(i);
    int cnt = 1 + (int)p2.size();
    for (int i = 0; i &lt; (int)p2.size(); ++i) &#123;
        for (int j = 0; j &lt; i; ++j)
            if (!t.count(&#123; std::min(p2[i], p2[j]), std::max(p2[i], p2[j]) &#125;))
                cnt -= merge(p2[i], p2[j]);
        for (int j = 0; j &lt; (int)p1.size(); ++j)
            if (!t.count(&#123; std::min(p2[i], p1[j]), std::max(p2[i], p1[j]) &#125;))
                cnt -= merge(p2[i], p1[j]);
    &#125;
    std::cout &lt;&lt; cnt - 1 &lt;&lt; &#39;\n&#39;;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;


C - Magic Matrix
https://www.luogu.com.cn/problem/CF632F

神秘不等式。若边 \(A,B,C\) 组成三元环，显然有 \(A\le \max(A,B,C)\)。考虑 \(B\) 参与形成的另一个三元环 \(B,D,E\)，那么显然有 \(A\le \max(A,C,D,E)\)，（需要注意到此时仍是一个环，很容易证明），etc.
更可视化地叙述，令 \((x,y)\) 为边 \(A\) 的两端，则 \(A\) 参与构成的所有简单环，\(A\) 不大于环上边权最大值。反过来，若存在一个路径最大值小于 \(A\) 则判定失败。故 Kruskal 乱 check 一下即可，复杂度 \(O(n^2\log n)\)。
谁家好人写 \(O(n^2\log n^2)\) 的？咋看咋不对劲，好在发现问题，保住了高中生的名头。


#include &lt;bits/stdc++.h&gt;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n;
    std::cin &gt;&gt; n;
    std::vector&lt;std::vector&lt;int&gt; &gt; a(n + 1, std::vector&lt;int&gt; (n + 1));
    auto nosol = [&amp;](void) &#123;
        std::cout &lt;&lt; &quot;NOT MAGIC\n&quot;;
        exit(0);
        return;
    &#125;;
    for (int i = 1; i &lt;= n; ++i)
        for (int j = 1; j &lt;= n; ++j)
            std::cin &gt;&gt; a[i][j];
    std::vector&lt;int&gt; l(1);
    for (int i = 1; i &lt;= n; ++i) &#123;
        if (a[i][i] != 0)
            nosol();
        for (int j = 1; j &lt; i; ++j) &#123;
            l.push_back(a[i][j]);
            if (a[i][j] != a[j][i])
                nosol();
        &#125;
    &#125;
    std::sort(l.begin() + 1, l.end());
    l.erase(std::unique(l.begin() + 1, l.end()), l.end());
    int m = (int)l.size() - 1;
    std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; e(m + 1);
    for (int i = 1; i &lt;= n; ++i)
        for (int j = 1; j &lt; i; ++j) &#123;
            a[i][j] = std::lower_bound(l.begin() + 1, l.end(), a[i][j]) - l.begin();
            e[a[i][j]].emplace_back(i, j);
        &#125;
    std::vector&lt;int&gt; f(n + 1);
    std::iota(f.begin() + 1, f.end(), 1);
    std::function&lt;int(int)&gt; find = [&amp;](int x) &#123;
        return x == f[x] ? x : f[x] = find(f[x]);
    &#125;;
    for (int i = 1; i &lt;= m; ++i) &#123;
        for (auto [u, v] : e[i])
            if (find(u) == find(v))
                nosol();
        for (auto [u, v] : e[i])
            if (find(u) != find(v))
                f[find(u)] = find(v);
    &#125;
    std::cout &lt;&lt; &quot;MAGIC\n&quot;;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;


K - Jumbled Trees
https://www.luogu.com.cn/problem/CF1773J
]]></content>
      <tags>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title>杂题选谈</title>
    <url>/20251019/</url>
    <content><![CDATA[模拟赛 and so on


CF1923F Shrink-Reverse
https://www.luogu.com.cn/problem/CF1923F
需要想到贪心策略，但正确的策略并没有那么显然。

观察样例可以大胆猜测，SHRINK_REVERSE 只会用最多一次。尝试理解这一点：

只考虑 SHRINK，那么发现只有最后一次 SHRINK 是有效的。
只考虑 REVERSE，那么只需要将两次 REVERSE 中间的 SWAP 进行翻转，并删除这两次 REVERSE，就可以达到相同的作用。

综上，只需要保留最后一次 SHRINK_REVERSE，剩下的可以通过翻转对应的 SWAP 操作达到相同的效果，节省操作次数。且显然这次 SHRINK_REVERSE 应该放在操作序列的末尾。
因此，只需要讨论不 SHRINK_REVERSE、在最后 SHRINK_REVERSE 两种情况。
对于不 SHRINK_REVERSE 的情况，直接贪心即可。
对于最后再 SHRINK_REVERSE 的情况，不妨先 REVERSE，考虑找到 SHRINK 后对应的原始字符串上的区间。
也即考虑找到一个最短的子串，使得能够通过 \(k-1\) 次 SWAP 把子串外的 \(1\) 全部换到子串内。
问题具有一定的单调性，故可以双指针对于每个 \(l\) 找到最小的 \(r\)。接下来仍然可以贪心最小化答案。
很容易说明区间长最短的才能竞争最优：要么 \(l\) 初始为 \(1\)，要么区间长就是 \(1\) 总数；
很容易说明相同长度的参与竞争的区间，字典序最小的最优。
故接下来需要比较这 \(O(n)\) 个长度相同的答案区间的字典序。SA 即可。


#include &lt;bits/stdc++.h&gt;
const int mod = 1e9 + 7;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, k;
    std::string s, res1, res2;
    std::cin &gt;&gt; n &gt;&gt; k &gt;&gt; s, s = &#39;#&#39; + s;
    res1 = s;
    for (int i = 1, j = n, l = 1; l &lt;= k &amp;&amp; i &lt; j; ++i, --j, ++l) &#123;
        for (; i &lt; j &amp;&amp; res1[i] != &#39;1&#39;; ++i);
        for (; i &lt; j &amp;&amp; res1[j] != &#39;0&#39;; --j);
        if (i &lt; j)
            std::swap(res1[i], res1[j]);
    &#125;
    for (int i = 1; i &lt;= n; ++i)
        if (res1[i] == &#39;1&#39;) &#123;
            res1 = &#39;#&#39; + res1.substr(i, n - i + 1);
            break;
        &#125;
    std::reverse(s.begin() + 1, s.end());
    std::vector&lt;int&gt; pos;
    const int s1 = std::count(s.begin() + 1, s.end(), &#39;1&#39;);
    int len = n;
    for (int l = 1, r = 0, c1 = 0, c0 = 0; l &lt;= n; ++l) &#123;
        for (; r &lt; n &amp;&amp; (c0 &lt; s1 - c1 || s1 - c1 &gt; k - 1); )
            if (s[++r] == &#39;1&#39;) ++c1;
            else ++c0;
        if (c0 &gt;= s1 - c1 &amp;&amp; s1 - c1 &lt;= k - 1) &#123;
            if (r - l + 1 &lt; len)
                len = r - l + 1, pos.clear();
            if (r - l + 1 == len)
                pos.push_back(l);
        &#125;
        if (s[l] == &#39;1&#39;) --c1;
        else --c0;
    &#125;
    std::vector&lt;int&gt; sa(n + 1), rk(2 * n + 1);
    &#123;
        int m = 128;
        std::vector&lt;int&gt; c(std::max(n, m) + 1), id, la(2 * n + 1);
        std::copy(s.begin() + 1, s.end(), rk.begin() + 1);
        for (int i = 1; i &lt;= n; ++i)
            ++c[rk[i]];
        std::partial_sum(c.begin() + 1, c.begin() + m + 1, c.begin() + 1);
        for (int i = n; i; --i)
            sa[c[rk[i]]--] = i;
        for (int w = 1, p; ; w &lt;&lt;= 1, m = p) &#123;
            id.clear(), id.push_back(-1);
            for (int i = n - w + 1; i &lt;= n; ++i)
                id.push_back(i);
            for (int i = 1; i &lt;= n; ++i)
                if (sa[i] &gt; w)
                    id.push_back(sa[i] - w);
            std::fill(c.begin() + 1, c.begin() + m + 1, 0);
            for (int i = 1; i &lt;= n; ++i)
                ++c[rk[i]];
            std::partial_sum(c.begin() + 1, c.begin() + m + 1, c.begin() + 1);
            for (int i = n; i; --i)
                sa[c[rk[id[i]]]--] = id[i];
            p = 0;
            std::copy(rk.begin() + 1, rk.end(), la.begin() + 1);
            for (int i = 1; i &lt;= n; ++i)
                if (i != 1 &amp;&amp; la[sa[i]] == la[sa[i - 1]] &amp;&amp; la[sa[i] + w] == la[sa[i - 1] + w])
                    rk[sa[i]] = p;
                else
                    rk[sa[i]] = ++p;
            if (p == n)
                break;
        &#125;
    &#125;
    int id = 0;
    for (auto i : pos)
        if (id == 0 || rk[i] &lt; rk[id])
            id = i;
    if (id == 0)
        assert(len == n), id = 1;
    res2 = &#39;#&#39; + s.substr(id, len);
    int tot = s1 - std::count(res2.begin() + 1, res2.end(), &#39;1&#39;);
    for (int i = len; tot--; --i) &#123;
        for (; res2[i] != &#39;0&#39;; --i);
        res2[i] = &#39;1&#39;;
    &#125;
    if (res1.length() == res2.length())
        s = std::min(res1, res2);
    else if (res1.length() &lt; res2.length())
        s = res1;
    else
        s = res2;
    auto res = 0ll;
    for (int i = 1; i &lt; (int)s.size(); ++i)
        res = (res * 2 + s[i] - &#39;0&#39;) % mod;
    std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;


CF1859F Teleportation in Byteland
https://www.luogu.com.cn/problem/CF1859F

题设让树自然呈现一个分层图的结构。贪心地，最优的路径一定为 \(a_i\to u\)，（在 \(u\) 学习若干次），\(u\to b_i\)。
枚举一个学习次数 \(k\)（显然 \(k\) 不会超过 \(\left\lceil\log_2n\right\rceil\)），并令 \(d_k(u,v)\) 表示在学习 \(k\) 次后的分层图上 \(u\) 与 \(v\) 的距离。最后的答案可以表示为 \(\min\limits_{u,k}\{d_0(a_i,u)+d_k(u,b_i)+k\cdot T\}\)。
现在希望能够快速地找到，对于一个固定的 \(k\)，使答案最小的 \(u\)。询问与路径相关，所以期望一种能和路径挂钩的答案表示方法（似乎是经典 trick）。容易想到链 \((a_i,b_i)\) 上离 \(u\) 最近的点 \(v\)，答案可以改写成：
\[
\min\limits_{u,v}\{d_0(a_i,v)+d_k(v,b_i)+d_0(v,u)+d_k(u,v)\}+k\cdot T
\]
其中，\(d_0(v,u)+d_k(u,v)\) 与具体的 \(a,b\) 无关，可以用一次多源 Dij 预处理出每个 \(v\) 的答案（记为 \(s_k(v)\)）（需要注意到 \(d_0(v,u)\) 和 \(d_k(u,v)\) 可能不同时取最小，可以用 \(w_0+w_k\) 作边权）；\(d_0(a_i,v)+d_k(v,b_i)\) 则可以通过讨论 LCA 直接用深度表示，求出最值。
记 \(fa=\text{LCA}(a_i,b_i)\)，当 \(v\) 在 \(fa\to a_i\) 上时，答案为：
\[
(dep_k(v)+s_k(v)-dep_0(v))+(dep_k(b_i)-2dep_k(fa)+dep_0(a_i)+k\cdot T)
\]
当 \(v\) 在 \(fa\to b_i\) 上时，答案为：
\[
(dep_0(v)+s_k(v)-dep_k(v))+(dep_0(a_i)-2dep_0(fa)+dep_k(b_i)+k\cdot T)
\]
维护链上 \(dep_k(v)+s_k(v)-dep_0(v)\) 和 \(dep_0(v)+s_k(v)-dep_k(v)\) 的最小值即可。
由于是完全静态的树上路径问题，可以用倍增完成。注意考虑学 \(0\) 次的情况。复杂度 \(O(n\log^2 n)\)。
咦你怎么 MLE 了？只需要把所有询问离线下来，每个 \(k\) 就可以共用数组了。
看到 Limury 的做法是树剖 + st 表，薄纱所有人。Rosmist 树剖 + bit 三只 log 也薄纱倍增做法，我怎么会做这样的梦。


#include &lt;bits/stdc++.h&gt;
const int maxn = 1e5 + 5;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int T;
    for (std::cin &gt;&gt; T; T--; ) &#123;
        int n, t;
        std::cin &gt;&gt; n &gt;&gt; t;
        std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; g(n + 1);
        for (int i = 1, x, y, w; i &lt; n; ++i) &#123;
            std::cin &gt;&gt; x &gt;&gt; y &gt;&gt; w;
            g[x].emplace_back(y, w), g[y].emplace_back(x, w);
        &#125;
        std::vector&lt;int&gt; tag(n + 1);
        for (int i = 1; i &lt;= n; ++i) &#123;
            char t;
            std::cin &gt;&gt; t, tag[i] = t - &#39;0&#39;;
        &#125;
        auto fun = [&amp;](int w, int k) &#123;
            return (w + (1 &lt;&lt; k) - 1) &gt;&gt; k;
        &#125;;
        std::vector&lt;long long&gt; s(n + 1);
        std::vector&lt;int&gt; dep(n + 1), vis(n + 1);
        std::vector&lt;std::array&lt;int, 17&gt; &gt; fa(n + 1);
        std::vector&lt;std::array&lt;long long, 17&gt; &gt; f1(n + 1), f2(n + 1);
        std::vector&lt;std::vector&lt;long long&gt; &gt; dis(2, std::vector&lt;long long&gt; (n + 1));
        std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;
            for (auto [i, w] : g[x])
                if (i != fa[x][0]) &#123;
                    dep[i] = dep[x] + 1;
                    dis[0][i] = dis[0][x] + w;
                    fa[i][0] = x;
                    for (int j = 1; j &lt; 17; ++j)
                        fa[i][j] = fa[fa[i][j - 1]][j - 1];
                    DFS(i);
                &#125;
            return;
        &#125;;
        dep[1] = 1, DFS(1);
        auto getLCA = [&amp;](int x, int y) &#123;
            if (dep[x] &lt; dep[y])
                std::swap(x, y);
            for (int i = 16; ~i; --i)
                if (dep[fa[x][i]] &gt;= dep[y])
                    x = fa[x][i];
            if (x == y)
                return x;
            for (int i = 16; ~i; --i)
                if (fa[x][i] != fa[y][i])
                    x = fa[x][i], y = fa[y][i];
            return fa[x][0];
        &#125;;
        int m;
        std::cin &gt;&gt; m;
        std::vector&lt;long long&gt; res(m + 1);
        std::vector&lt;std::pair&lt;int, int&gt; &gt; q(m + 1);
        for (int i = 1, u, v; i &lt;= m; ++i) &#123;
            std::cin &gt;&gt; u &gt;&gt; v;
            res[i] = dis[0][u] + dis[0][v] - 2 * dis[0][getLCA(u, v)];;
            q[i] = &#123; u, v &#125;;
        &#125;
        for (int j = 0; j &lt; 17; ++j)
            f1[0][j] = f2[0][j] = 1e18;
        for (int k = 1; k &lt;= 20; ++k) &#123;
            &#123;
                std::priority_queue&lt;std::pair&lt;long long, int&gt; &gt; q;
                for (int i = 1; i &lt;= n; ++i) &#123;
                    vis[i] = 0;
                    if (tag[i])
                        s[i] = 0ll, q.emplace(0ll, i);
                    else
                        s[i] = 1e18;
                &#125;
                for (; !q.empty(); ) &#123;
                    int x = q.top().second;
                    q.pop();
                    if (vis[x])
                        continue;
                    vis[x] = 1;
                    for (auto [v, w] : g[x])
                        if (s[v] &gt; s[x] + fun(w, k) + w) &#123;
                            s[v] = s[x] + fun(w, k) + w;
                            q.emplace(-s[v], v);
                        &#125;
                &#125;
            &#125;
            DFS = [&amp;](int x) &#123;
                for (auto [i, w] : g[x])
                    if (i != fa[x][0]) &#123;
                        dis[1][i] = dis[1][x] + fun(w, k);
                        f1[i][0] = dis[1][i] + s[i] - dis[0][i];
                        f2[i][0] = dis[0][i] + s[i] - dis[1][i];
                        for (int j = 1; j &lt; 17; ++j) &#123;
                            f1[i][j] = std::min(f1[i][j - 1], f1[fa[i][j - 1]][j - 1]);
                            f2[i][j] = std::min(f2[i][j - 1], f2[fa[i][j - 1]][j - 1]);
                        &#125;
                        DFS(i);
                    &#125;
                return;
            &#125;;
            DFS(1);
            for (int i = 1; i &lt;= m; ++i) &#123;
                auto [u, v] = q[i];
                int x = u, y = v;
                long long s1 = 1e18, s2 = 1e18;
                if (dep[x] &gt; dep[y]) &#123;
                    for (int i = 16; ~i; --i)
                        if (dep[fa[x][i]] &gt;= dep[y]) &#123;
                            s1 = std::min(s1, f1[x][i]);
                            x = fa[x][i];
                        &#125;
                &#125;
                else &#123;
                    for (int i = 16; ~i; --i)
                        if (dep[fa[y][i]] &gt;= dep[x]) &#123;
                            s2 = std::min(s2, f2[y][i]);
                            y = fa[y][i];
                        &#125;
                &#125;
                if (x != y) &#123;
                    for (int i = 16; ~i; --i)
                        if (fa[x][i] != fa[y][i]) &#123;
                            s1 = std::min(s1, f1[x][i]);
                            s2 = std::min(s2, f2[y][i]);
                            x = fa[x][i], y = fa[y][i];
                        &#125;
                    s1 = std::min(s1, f1[x][0]);
                    s2 = std::min(s2, f2[y][0]);
                    x = fa[x][0];
                &#125;
                s1 = std::min(s1, dis[1][x] + s[x] - dis[0][x]);
                s2 = std::min(s2, dis[0][x] + s[x] - dis[1][x]);
                res[i] = std::min(res[i], k * t + dis[0][u] + dis[1][v] + std::min(s1 - 2 * dis[1][x], s2 - 2 * dis[0][x]));
            &#125;
        &#125;
        for (int i = 1; i &lt;= m; ++i)
            std::cout &lt;&lt; res[i] &lt;&lt; &#39;\n&#39;;
    &#125;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;


CF1556G Gates to Another World
https://www.luogu.com.cn/problem/CF1556G

快速做出来需要一定运气，需要把点顺序排布而不是像题目一样画晶胞（。）手玩一下 \(n=4\) 时的情况：

看到两个相邻点间连的边就应激想到线段树了，事实上把不同层的边提起来发现就是线段树的结构。

为什么这个图这么大（没啥用故折起来了）
tip：实际上那些相邻 / 相反的尖尖是重合的，为了好看一点故错开。


发现形成一个相邻子树对位连边的结构。这里线段树其实只有底层点是有意义的，其他点只起结构辅助作用。
实际上，对于两个有连边的点，它们『LCA』的高度是被 flip 的位。
很容易注意到一个线段树子树内的底层点是连通的，这一点也很容易递归地证明。
考虑动态开点线段树优化建图，对于动态开点出来的叶子（注意不是底层点），容易发现在题目限制下每个叶子内部都没有点被删除，是连通的（那么此时不妨认为叶子就代表了这个连通块）。
故将某个点进行连边时，并不要求找到对位的那个点（不一定存在），和走到头的叶子连边就可以达到相同的连通效果。这样就把底层点之间的连边转化为了叶子间的连边。
不妨先时光倒流 + 预处理出每个叶子最后（最早）存在的时间戳，考虑暴力连出来这些叶子间的边（对于每个点，将对位的叶子连边）并计算出边最后（最早）存在的时间戳。
发现暴力对位连边这个操作，是形似线段树合并但比线段树合并更劣的东西。咋分析复杂度。
边是双向的，考虑更深的叶子的贡献。那么其枚举 lca + flip 对应位（不存在则取路径上的叶子），一共会有 \(O(n)\) 次连边。共有 \(O(nm)\) 个叶子，摊下来暴力连边复杂度为 \(O(n^2m)\)。


空间很卡…… 不要把离线的加边数组开成 long long 了。
#include &lt;bits/stdc++.h&gt;
const int maxn = 32e5 + 5;
using ll = long long;
struct &#123; int l, r, d; &#125; t[maxn];
int tot;
#define lt t[p].l
#define rt t[p].r
#define leaf(p) (!t[p].l &amp;&amp; !t[p].r)
int newnode(void) &#123;
    ++tot, t[tot].l = t[tot].r = t[tot].d = 0;
    return tot;
&#125;
void pushdown(int p) &#123;
    if (t[p].d) &#123;
        if (!lt)
            lt = newnode();
        if (!rt)
            rt = newnode();
        t[lt].d = t[rt].d = t[p].d;
        t[p].d = 0;
    &#125;
    return;
&#125;
void upd(int &amp;p, ll l, ll r, ll ql, ll qr, int v) &#123;
    if (!p)
        p = newnode();
    if (ql &lt;= l &amp;&amp; r &lt;= qr) &#123;
        t[p].d = v;
        return;
    &#125;
    pushdown(p);
    auto mid = (l + r) &gt;&gt; 1;
    if (ql &lt;= mid)
        upd(lt, l, mid, ql, qr, v);
    if (qr &gt; mid)
        upd(rt, mid + 1, r, ql, qr, v);
    return;
&#125;
int ask(int p, ll l, ll r, ll x) &#123;
    if (leaf(p))
        return p;
    ll mid = (l + r) &gt;&gt; 1;
    if (x &lt;= mid)
        return ask(lt, l, mid, x);
    return ask(rt, mid + 1, r, x);
&#125;
#undef lt
#undef rt
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, m, rt = newnode();
    std::cin &gt;&gt; n &gt;&gt; m;
    t[rt].d = m + 1;
    const auto N = (1ll &lt;&lt; n) - 1;
    struct query &#123; int op; ll s, t; &#125;;
    std::vector&lt;query&gt; q(m + 1);
    for (int i = 1; i &lt;= m; ++i) &#123;
        std::string op;
        std::cin &gt;&gt; op;
        q[i].op = (op == &quot;ask&quot;) + 1;
        std::cin &gt;&gt; q[i].s &gt;&gt; q[i].t;
        if (q[i].op == 1)
            upd(rt, 0ll, N, q[i].s, q[i].t, i);
    &#125;
    std::vector&lt;int&gt; f(tot + 1);
    std::iota(f.begin() + 1, f.end(), 1);
    std::function&lt;int(int)&gt; find = [&amp;](int x) &#123;
        return x == f[x] ? x : f[x] = find(f[x]);
    &#125;;
    auto merge = [&amp;](int x, int y) &#123;
        f[find(x)] = find(y);
        return;
    &#125;;
    std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; u(m + 2);
    std::function&lt;void(int, int)&gt; link = [&amp;](int p, int q) &#123;
        if (leaf(p) &amp;&amp; leaf(q)) &#123;
            u[std::min(t[p].d, t[q].d)].emplace_back(p, q);
            return;
        &#125;
        else if (leaf(p))
            link(p, t[q].l), link(p, t[q].r);
        else if (leaf(q))
            link(t[p].l, q), link(t[p].r, q);
        else
            link(t[p].l, t[q].l), link(t[p].r, t[q].r);
        return;
    &#125;;
    for (int i = 1; i &lt;= tot; ++i)
        if (t[i].l &amp;&amp; t[i].r)
            link(t[i].l, t[i].r);
    for (auto [p, q] : u[m + 1])
        merge(p, q);
    std::vector&lt;int&gt; res;
    for (int i = m; i; --i)
        if (q[i].op == 2)
            res.push_back(find(ask(rt, 0, N, q[i].s)) == find(ask(rt, 0, N, q[i].t)));
        else
            for (auto [p, q] : u[i])
                merge(p, q);
    for (; !res.empty(); res.pop_back())
        std::cout &lt;&lt; res.back() &lt;&lt; &#39;\n&#39;;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;


C. 小 Z 爱优化
https://www.becoder.com.cn/contest/6662/problem/3

给定 \(a_{1\sim n}\)，将其分为若干连续段，满足每段长度为 \(1\) 或 \(2\)，定义一段的权值为元素之和，最小化段权值的极差并输出之。
\(n\le 2\times 10^5,V=10^9\)。


令 \(f_{i,j}\) 表示这一段以 \(i\) 结尾，最小值为 \(j\) 时的最大值。把最小值当状态是自然的想法，实际似乎差不多（。）得到（不重要）：
\[
f_{i,a_i}\gets f_{i-1,j},j\ge a_i\\
f_{i,a_i+a_{i-1}}\gets f_{i-2,j},j\ge a_i+a_{i-1}\\
f_{i,j}\gets \max(f_{i-1,j},a_i) ,j\le a_i\\
f_{i,j}\gets \max(f_{i-2,j},a_i+a_{i-1}) ,j\le a_i
\]
这个状态很矩阵，可以考虑下标分奇偶性继承，用线段树优化，矩阵作为元素；然而同时涉及两个维度，尤其是第一维的变化，实在是答辩啊！

By the way，广义矩乘的结合律？
对于一个 \(\oplus-\otimes\) 矩阵（内层为 \(\otimes\)，外层为 \(\oplus\)），其有结合律当且仅当同时满足：

\(\oplus\) 有交换律；
\(\otimes\) 有结合律；
\(\otimes\) 对 \(\oplus\) 有分配律。


来自 qkhm 关于广义矩阵乘法常见误区的一点纠正


发现第二维其实不会怎么变，或者说第二维其实起的是一个限制性的作用，可以考虑把第二维放到外层循环，相当于枚举限制。我们知道上面的做法可以很快地优化，所以拿出去了之后大概也能做。
若限制当前最小值不能小于 \(j\)，那么有：
\[
f_i\gets \max(f_{i-1},a_i),a_j\ge j\\
f_i\gets \max(f_{i-2},a_i+a_{i-1}),a_i+a_{i-1}\ge j
\]
发现这就很显然是一个 DDP 的形式了，每次 \(j\) 改变时，只需要改动对应位置的矩阵（即是否能进行转移），总修改次数是 \(O(n)\) 的。


#include &lt;bits/stdc++.h&gt;
const int maxn = 2e5 + 5;
const int inf = 0x7fffffff;
using mat = std::array&lt;std::array&lt;int, 2&gt;, 2&gt;;
int m[maxn][2][2];
void mul(mat &amp;res, mat &amp;p, mat &amp;q) &#123;
    res[0][0] = std::min(std::max(p[0][0], q[0][0]), std::max(p[0][1], q[1][0]));
    res[0][1] = std::min(std::max(p[0][0], q[0][1]), std::max(p[0][1], q[1][1]));
    res[1][0] = std::min(std::max(p[1][0], q[0][0]), std::max(p[1][1], q[1][0]));
    res[1][1] = std::min(std::max(p[1][0], q[0][1]), std::max(p[1][1], q[1][1]));
    return;
&#125;
struct &#123;
    int l, r;
    mat u;
&#125; t[maxn &lt;&lt; 2];
#define lt (p &lt;&lt; 1)
#define rt (lt | 1)
void bld(int p, int l, int r) &#123;
    t[p].l = l, t[p].r = r;
    if (l == r) &#123;
        t[p].u[0][0] = m[l][0][0];
        t[p].u[0][1] = m[l][0][1];
        t[p].u[1][0] = m[l][1][0];
        t[p].u[1][1] = m[l][1][1];
        return;
    &#125;
    int mid = (l + r) &gt;&gt; 1;
    bld(lt, l, mid), bld(rt, mid + 1, r);
    mul(t[p].u, t[lt].u, t[rt].u);
    return;
&#125;
void upd(int p, int x) &#123;
    if (t[p].l == t[p].r) &#123;
        t[p].u[0][1] = m[x][0][1];
        t[p].u[1][1] = m[x][1][1];
        return;
    &#125;
    int mid = (t[p].l + t[p].r) &gt;&gt; 1;
    if (x &lt;= mid)
        upd(lt, x);
    else
        upd(rt, x);
    mul(t[p].u, t[lt].u, t[rt].u);
    return;
&#125;
#undef lt
#undef rt
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
    std::freopen(&quot;opti.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;opti.out&quot;, &quot;w&quot;, stdout);
#else
    std::freopen(&quot;./test/20251021/opti/1.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    auto stime = std::chrono::steady_clock::now();
#endif
    int T;
    for (std::cin &gt;&gt; T; T--; ) &#123;
        int n;
        std::cin &gt;&gt; n;
        std::vector&lt;int&gt; a(n + 1), b(n + 1), l(1);
        for (int i = 1; i &lt;= n; ++i) &#123;
            std::cin &gt;&gt; a[i];
            l.push_back(a[i]);
            if (i &gt; 1)
                b[i] = a[i] + a[i - 1], l.push_back(b[i]);
        &#125;
        std::sort(l.begin() + 1, l.end());
        l.erase(std::unique(l.begin() + 1, l.end()), l.end());
        int m = (int)l.size() - 1;
        std::vector&lt;std::vector&lt;int&gt; &gt; ida(m + 1), idb(m + 1);
        for (int i = 1; i &lt;= n; ++i) &#123;
            a[i] = std::lower_bound(l.begin() + 1, l.end(), a[i]) - l.begin();
            ::m[i][1][1] = a[i], ida[a[i]].push_back(i);
            if (i &gt; 1) &#123;
                b[i] = std::lower_bound(l.begin() + 1, l.end(), b[i]) - l.begin();
                ::m[i][0][1] = b[i], idb[b[i]].push_back(i);
            &#125;
            else
                ::m[i][0][1] = inf;
            ::m[i][0][0] = inf, ::m[i][1][0] = 0;
        &#125;
        bld(1, 1, n);
        auto res = inf;
        for (int i = 1; i &lt;= m; ++i) &#123;
            if (std::min(t[1].u[0][1], t[1].u[1][1]) != inf)
                res = std::min(res, l[std::min(t[1].u[0][1], t[1].u[1][1])] - l[i]);
            for (auto j : ida[i])
                ::m[j][1][1] = inf, upd(1, j);
            for (auto j : idb[i])
                ::m[j][0][1] = inf, upd(1, j);
        &#125;
        std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
    &#125;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt;(std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s \n&quot;;
#endif
    return 0;
&#125;


D. 小 Z 爱考试
https://www.becoder.com.cn/contest/6662/problem/4

给定一个大小为 \(n\) 的内向基环树森林，每个点 \(u\) 上附有点权 \(a_u\)、收益 \(w_u\) 和一个进程，内容为：

若 \(u\) 指向的结点 \(fa\) 满足 \(a_{fa}&gt;a_u\)，则令 \(a_u\gets a_u+w_u\)。

给定 \(m\) 次操作，形如：

单点修改 \(a_u,w_u\)。
给定一个 \(u\)，输出：在 \(n!\) 种进程的执行序列中，\(a_u\) 最终值的期望。

\(n,m\le 2\times 10^5\)。保证每个点的入度 \(\le 3\)。


可以感受到操作的『后效性』是非常弱的，进一步感受到点可以粗暴地分为三种类型：

\(a_{fa}&gt;a_x\) 的；
\(a_{fa}+w_{fa} \le a_x\) 的；
\(a_{fa}\le a_x&lt;a_{fa} + w_{fa}\) 的；

点的类型是无依赖，可直接求的。显然，若 \(u\) 最终想取到 \(a_u+w_u\)，相当于走一条 \(u\) 开头，经过若干 3 类点，在 1 类点结尾的路径（这显然是确定的），假设路径包含 \(len\) 个点，答案为 \(\dfrac {(n-len)!\cdot C_{n}^{len}}{n!}=\dfrac 1{len!}\)。
换句话说，\(u\) 取不到 \(a_u+w_u\)，当且仅当路径上在出现 1 类点前出现了 2 类点或 3 类点的环（基环）。
考虑静态的情况，先处理所有基环：若只存在 3 类点，则标记全部非法；否则，任选一个 1 类点或者 2 类点开头，就可以 DP 出环上的 \(len\)。
对于所有树，直接大力 DP 即可。
接着考虑带修的情况，修改相当于改变点及其后继的状态（原来入度限制是拿来做这个的）。
发现没啥办法很好地做这个类 DDP 的问题。考虑到一场比赛不应该出现两道 DDP，故如果灵感迸发可能会想到干脆放弃预处理的想法，上重链，线段树维护区间 1 类点或 2 类点深度 max，即可做到两只 log。
如果发现树上没有这样的点，在环上也可以类似地找到第一个 1 类点或 2 类点。


感觉写复杂了，瞻仰了一下别人的代码又感觉流程上没什么区别
喜提最长代码，喜提最优解
#include &lt;bits/stdc++.h&gt;
const int mod = 1e9 + 7;
const int maxn = 6e5 + 5;
struct &#123;
    int l, r, lc, rc, u1, u2;
&#125; t[maxn &lt;&lt; 2];
#define lt t[p].lc
#define rt t[p].rc
int tot;
int ty[maxn], dep[maxn];
void bld(int &amp;p, int l, int r) &#123;
    p = ++tot;
    t[p].l = l, t[p].r = r;
    if (l == r) &#123;
        t[p].u1 = t[p].u2 = 0;
        if (ty[l] == 1)
            t[p].u1 = dep[l];
        else if (ty[l] == 2)
            t[p].u2 = dep[l];
        return;
    &#125;
    int mid = (l + r) &gt;&gt; 1;
    bld(lt, l, mid), bld(rt, mid + 1, r);
    t[p].u1 = std::max(t[lt].u1, t[rt].u1);
    t[p].u2 = std::max(t[lt].u2, t[rt].u2);
    return;
&#125;
void upd(int p, int x) &#123;
    if (t[p].l == t[p].r) &#123;
        t[p].u1 = t[p].u2 = 0;
        if (ty[x] == 1)
            t[p].u1 = dep[x];
        else if (ty[x] == 2)
            t[p].u2 = dep[x];
        return;
    &#125;
    int mid = (t[p].l + t[p].r) &gt;&gt; 1;
    if (x &lt;= mid)
        upd(lt, x);
    else
        upd(rt, x);
    t[p].u1 = std::max(t[lt].u1, t[rt].u1);
    t[p].u2 = std::max(t[lt].u2, t[rt].u2);
    return;
&#125;
std::pair&lt;int, int&gt; ask(int p, int l, int r) &#123;
    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r)
        return std::make_pair(t[p].u1, t[p].u2);
    int mid = (t[p].l + t[p].r) &gt;&gt; 1;
    std::pair&lt;int, int&gt; res(0, 0);
    if (l &lt;= mid)
        res = ask(lt, l, r);
    if (r &gt; mid) &#123;
        auto s(ask(rt, l, r));
        res.first = std::max(res.first, s.first);
        res.second = std::max(res.second, s.second);
    &#125;
    return res;
&#125;
#undef lt
#undef rt
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
    std::freopen(&quot;exam.out&quot;, &quot;w&quot;, stdout);
    std::freopen(&quot;exam.in&quot;, &quot;r&quot;, stdin);
#else
    std::freopen(&quot;./test/20251021/exam/3.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int T;
    for (std::cin &gt;&gt; T; T--; ) &#123;
        int n, m;
        std::cin &gt;&gt; n &gt;&gt; m;
        std::vector&lt;int&gt; f(n + 1);
        std::iota(f.begin() + 1, f.end(), 1);
        std::function&lt;int(int)&gt; find = [&amp;](int x) &#123;
            return x == f[x] ? x : f[x] = find(f[x]);
        &#125;;
        auto merge = [&amp;](int x, int y) &#123;
            f[find(x)] = find(y);
            return;
        &#125;;
        std::vector&lt;long long&gt; fac(n + 1), inv(n + 1);
        fac[0] = inv[0] = 1ll;
        for (int i = 1; i &lt;= n; ++i)
            fac[i] = fac[i - 1] * i % mod;
        auto qkp = [&amp;](long long x, int y) &#123;
            auto res = 1ll;
            for (; y; (x *= x) %= mod, y &gt;&gt;= 1)
                if (y &amp; 1)
                    (res *= x) %= mod;
            return res;
        &#125;;
        inv[n] = qkp(fac[n], mod - 2);
        for (int i = n - 1; i; --i)
            inv[i] = inv[i + 1] * (i + 1) % mod;
        std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);
        std::vector&lt;int&gt; a(n + 1), w(n + 1), to(n + 1), col(2 * n + 1);
        for (int i = 1; i &lt;= n; ++i) &#123;
            std::cin &gt;&gt; a[i] &gt;&gt; to[i] &gt;&gt; w[i];
            merge(i, to[i]);
            g[to[i]].push_back(i);
        &#125;
        int now = 0, tot = n;
        std::vector&lt;int&gt; tab(n + 1), tad(n + 1), vis(n + 1), L(2 * n + 1), R(2 * n + 1);
        auto getty = [&amp;](int x) &#123;
            if (a[to[x]] &gt; a[x])
                return 1;
            if (a[to[x]] + w[to[x]] &lt;= a[x])
                return 2;
            return 3;
        &#125;;
        for (int i = 1; i &lt;= n; ++i)
            if (f[i] == i) &#123;
                std::vector&lt;int&gt; vis(n + 1), t(1);
                std::stack&lt;int&gt; st;
                for (int x = i; ; ) &#123;
                    st.push(x);
                    if (!vis[to[x]])
                        vis[to[x]] = 1, x = to[x];
                    else &#123;
                        for (;;) &#123;
                            t.push_back(st.top());
                            if (st.top() == to[x])
                                break;
                            st.pop();
                        &#125;
                        break;
                    &#125;
                &#125;
                int k = (int)t.size() - 1;
                std::reverse(t.begin() + 1, t.end());
                t.resize(2 * k + 1);
                L[++tot] = now + 1;
                for (int i = 1; i &lt;= k; ++i) &#123;
                    tab[t[i]] = ++now;
                    col[t[i]] = tot;
                    ::dep[tab[t[i]]] = 2 * k - i + 1;
                    ::ty[tab[t[i]]] = getty(t[i]);
                &#125;
                for (int i = k + 1; i &lt;= 2 * k; ++i) &#123;
                    t[i] = t[i - k];
                    tad[t[i]] = ++now;
                    ::dep[tad[t[i]]] = 2 * k - i + 1;
                    ::ty[tad[t[i]]] = getty(t[i]);
                &#125;
                R[tot] = now;
            &#125;
        std::vector&lt;int&gt; fa(n + 1), siz(n + 1), son(n + 1), dep(n + 1);
        std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;
            siz[x] = 1;
            for (auto i : g[x])
                if (!tab[i]) &#123;
                    dep[i] = dep[x] + 1;
                    fa[i] = x, DFS(i);
                    siz[x] += siz[i];
                    if (siz[i] &gt; siz[son[x]])
                        son[x] = i;
                &#125;
            return;
        &#125;;
        for (int i = 1; i &lt;= n; ++i)
            if (tab[i])
                dep[i] = 1, DFS(i);
        std::vector&lt;int&gt; rt(2 * n + 1), dfn(n + 1), top(n + 1), bot(n + 1);
        DFS = [&amp;](int x) &#123;
            dfn[x] = ++now;
            ty[dfn[x]] = getty(x);
            ::dep[dfn[x]] = dep[x];
            bot[top[x]] = x;
            if (son[x])
                top[son[x]] = top[x], DFS(son[x]);
            for (auto i : g[x])
                if (i != son[x] &amp;&amp; !tab[i])
                    top[i] = i, DFS(i);
            if (x == top[x])
                bld(rt[x], dfn[x], dfn[bot[x]]);
            return;
        &#125;;
        for (int i = 1; i &lt;= n; ++i)
            if (tab[i])
                top[i] = i, DFS(i);
        for (int i = n + 1; i &lt;= tot; ++i)
            bld(rt[i], L[i], R[i]);
        auto work = [&amp;](int x) &#123;
            ty[dfn[x]] = getty(x);
            upd(rt[top[x]], dfn[x]);
            if (tab[x]) &#123;
                ty[tab[x]] = ty[tad[x]] = getty(x);
                upd(rt[col[x]], tab[x]), upd(rt[col[x]], tad[x]);
            &#125;
            return;
        &#125;;
        for (int op; m--; ) &#123;
            std::cin &gt;&gt; op;
            if (op == 1) &#123;
                int x;
                std::cin &gt;&gt; x, std::cin &gt;&gt; a[x];
                work(x);
                for (auto i : g[x])
                    work(i);
            &#125;
            else if (op == 2) &#123;
                int x;
                std::cin &gt;&gt; x, std::cin &gt;&gt; w[x];
                work(x);
                for (auto i : g[x])
                    work(i);
            &#125;
            else &#123;
                int x;
                std::cin &gt;&gt; x;
                auto calc = [&amp;](int x) &#123;
                    int len = 0, toq = 0;
                    for (; x; x = fa[top[x]]) &#123;
                        auto [u1, u2] = ask(rt[top[x]], dfn[top[x]], dfn[x]);
                        if (u1 &gt; u2)
                            return len + dep[x] - u1 + 1;
                        if (u2 &gt; u1)
                            return -1;
                        len += dep[x] - dep[fa[top[x]]], toq = top[x];
                    &#125;
                    auto [u1, u2] = ask(rt[col[toq]], tab[toq], R[col[toq]]);
                    if (u1 &gt; u2)
                        return len + ::dep[tab[toq]] - u1;
                    return -1;
                &#125;;
                auto t(calc(x));
                if (t == -1)
                    std::cout &lt;&lt; a[x] &lt;&lt; &#39;\n&#39;;
                else &#123;
                    // std::cout &lt;&lt; &quot;len = &quot; &lt;&lt; t &lt;&lt; &#39;\n&#39;;
                    std::cout &lt;&lt; ((a[x] + w[x]) * inv[t] % mod + (1ll + mod - inv[t]) % mod * a[x] % mod) % mod &lt;&lt; &#39;\n&#39;;
                &#125;
            &#125;
        &#125;
    &#125;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;


B. 炒鱿鱼
https://www.becoder.com.cn/contest/6666/problem/2

现在有一个栈。在接下来的 \(n\) 个时刻，每个时刻会发生一次事件，形如：

删除栈顶的 \(a_i\) 个元素，然后向栈顶加入 \(b_i\) 个元素。

现在每个时刻都让一个人去执行事件，需要满足每个元素，加入它的和删除它的不能是同一个人。问最少需要多少个人才能实现这一点。输出方案。有 SPJ。
\(n\le 10^5,V=10^9\)。


可以猜到答案只会为 1 2 3，尝试从图染色的角度考虑这个问题（怎么想到这一点？）。
一个元素在哪个时刻被加入 / 删除是固定的，故如果两天有冲突，可以考虑直接连边。考虑模拟，能够线性地求出来所有冲突关系，故边数是 \(O(n)\) 的。
由于这个栈的结构，发现不存在交错的边，或者说不同时存在 \((x_1,y_1)\) 和 \((x_2,y_2)\)，使得 \(x_1&lt;x_2&lt;y_1&lt;y_2\)。考虑构造解：
首先对于 \(1,n\) 任意涂色，忽略 \((1,n)\) 这条边（如果有），显然可以找到一个 \(mid\) 使得没有边跨过之，给其赋一个合法的颜色，接着就可以分治构造。
感觉这种构造不算太显然，只能算是能想到（实际上并没有）。
具体分治，由于性质比较好，直接取左端点对应范围内最远的边即可。
需要注意上述构造方案能保证可以构造出 \(k=3\) 的解，但不能保证是最优的（即不能保证 \(k=1\) 或 \(k=2\) 也能构造出对应的解），故需要特判没有边 + 二分图两种情况。


#include &lt;bits/stdc++.h&gt;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
    std::freopen(&quot;fire.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;fire.out&quot;, &quot;w&quot;, stdout);
#else
    // std::freopen(&quot;./test/20251022/fire/fire2.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n;
    std::cin &gt;&gt; n;
    std::vector&lt;std::pair&lt;int, int&gt; &gt; a(n + 1);
    for (int i = 1; i &lt;= n; ++i)
        std::cin &gt;&gt; a[i].first &gt;&gt; a[i].second;
    bool flag = true;
    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1), g1(n + 1);
    std::stack&lt;std::pair&lt;int, int&gt; &gt; st;
    for (int i = 1; i &lt;= n; ++i) &#123;
        for (int j = 0; j &lt; a[i].first; ) &#123;
            g[st.top().second].push_back(i);
            g1[st.top().second].push_back(i);
            g1[i].push_back(st.top().second);
            flag = false;
            int to = std::min(st.top().first, a[i].first - j);
            j += to, st.top().first -= to;
            if (st.top().first == 0)
                st.pop();
        &#125;
        if (a[i].second)
            st.emplace(a[i].second, i);
    &#125;
    if (flag == true) &#123;
        std::cout &lt;&lt; 1 &lt;&lt; &#39;\n&#39;;
        for (int i = 1; i &lt;= n; ++i)
            std::cout &lt;&lt; 1 &lt;&lt; &#39; &#39;;
        std::cout &lt;&lt; &#39;\n&#39;;
        return 0;
    &#125;
    std::vector&lt;int&gt; col(n + 1);
    std::function&lt;bool(int, int)&gt; DFS = [&amp;](int x, int now) &#123;
        col[x] = now;
        for (auto i : g1[x])
            if (!col[i]) &#123;
                if (!DFS(i, 3 - now))
                    return false;
            &#125;
            else if (col[i] == now)
                return false;
        return true;
    &#125;;
    for (int i = 1; i &lt;= n; ++i)
        if (!col[i] &amp;&amp; !DFS(i, 1))
            goto nosol;
    std::cout &lt;&lt; 2 &lt;&lt; &#39;\n&#39;;
    for (int i = 1; i &lt;= n; ++i)
        std::cout &lt;&lt; col[i] &lt;&lt; &#39; &#39;;
    std::cout &lt;&lt; &#39;\n&#39;;
    return 0;
nosol: ;
    col[1] = 1, col[n] = 2;
    std::function&lt;void(int, int)&gt; calc = [&amp;](int l, int r) &#123;
        if (r - l + 1 &lt;= 2)
            return;
        if (!g[l].empty() &amp;&amp; g[l].back() == r)
            g[l].pop_back();
        int pos = g[l].empty() ? l + 1 : g[l].back();
        col[pos] = 6 - col[l] - col[r];
        calc(l, pos), calc(pos, r);
        return;
    &#125;;
    calc(1, n);
    std::cout &lt;&lt; 3 &lt;&lt; &#39;\n&#39;;
    for (int i = 1; i &lt;= n; ++i)
        std::cout &lt;&lt; col[i] &lt;&lt; &#39; &#39;;
    std::cout &lt;&lt; &#39;\n&#39;;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;


C. 适格者
https://www.becoder.com.cn/contest/6666/problem/3

给定长度为 \(2^n\) 的数组 \(a_{0,\cdots,2^n-1}\)，维护 \(q\) 次操作：

修改：单点加；
修改：高维前缀加；
修改：高维后缀加；
询问：高维前缀和，对 \(998244353\) 取模；

\(n\le 20,q\le 10^5\)。


单点加 + 高维前缀和会反应出 ARC205E 的 trick
考虑怎么做后缀加，会反应过来和 bit 的区间修改 有一致性，修改相当于单点修改差分数组。考虑类似的推导：
\[
\begin{aligned}
\sum_{s\subseteq S}a_s&amp;=\sum_{s\subseteq S} \sum_{i\subseteq s} d_i\\
&amp;=\sum_{i\subseteq S} 2^{|S|-|i|}\times d_i
\end{aligned}
\]
故维护 \(2^{-|i|}\cdot d_i\) 即可（原来取模是拿来搞这个的）。类似地可以推导前缀加：
\[
\begin{aligned}
\sum_{s\subseteq S}a_s&amp;=\sum_{s\subseteq S} \sum_{i\supseteq s} d_i\\
&amp;=\sum_{i\subseteq S} 2^{|S \text{ bitand } i|}\times d_i
\end{aligned}
\]
发现这个 bitand 不太好搞，不过 bitand 是对位的，所以依然可以套在分块上
同时，因为问的是前缀和，所以单点的 \(S\text{ bitand } i\) 其实就是 \(i\)。这里有点囿于 fmt 的思维定势了，实际上可以直接认为 \(f_{s_1, s_2}\) 维护的是这个点处的答案，每次更新对 \(f_{s_1,*}\) 的贡献即可。


不知为何很慢
#include &lt;bits/stdc++.h&gt;
const int mod = 998244353;
const int inv2 = (mod + 1) &gt;&gt; 1;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
    std::freopen(&quot;gene.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;gene.out&quot;, &quot;w&quot;, stdout);
#else
    // std::freopen(&quot;./test/20251022/gene/gene5.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, q;
    std::cin &gt;&gt; n &gt;&gt; q;
    const int N1 = n / 2, N2 = n - N1, lim = 1 &lt;&lt; N2;
    std::vector&lt;long long&gt; inv(n + 1);
    inv[0]= 1ll;
    for (int i = 1; i &lt;= n; ++i)
        inv[i] = inv[i - 1] * inv2 % mod;
    std::vector&lt;std::vector&lt;long long&gt; &gt; s(1 &lt;&lt; N1, std::vector&lt;long long&gt; (lim));
    auto s1(s), s2(s);
    for (int op, x; q--; ) &#123;
        std::cin &gt;&gt; op &gt;&gt; x;
        int X1 = x &gt;&gt; N2, X2 = x &amp; (lim - 1);
        if (op == 0) &#123;
            auto res = 0ll, res1 = 0ll, res2 = 0ll;
            for (int i = 0; i &lt; (1 &lt;&lt; N1); ++i)
                res2 += (1 &lt;&lt; __builtin_popcount(i &amp; X1)) * s2[i][X2] % mod;
            for (int i = X1; ; i = X1 &amp; (i - 1)) &#123;
                res += s[i][X2];
                res1 += s1[i][X2] * (1 &lt;&lt; __builtin_popcount(x)) % mod;
                if (i == 0)
                    break;
            &#125;
            std::cout &lt;&lt; (res + res1 + res2) % mod &lt;&lt; &#39;\n&#39;;
        &#125;
        else if (op == 1) &#123;
            int v;
            std::cin &gt;&gt; v;
            int X3 = (lim - 1) ^ X2;
            for (int i = X3; ; i = X3 &amp; (i - 1)) &#123;
                (s[X1][(lim - 1) ^ i] += v) %= mod;
                if (i == 0)
                    break;
            &#125;
        &#125;
        else if (op == 2) &#123;
            long long v;
            std::cin &gt;&gt; v, (v *= inv[__builtin_popcount(x)]) %= mod;
            int X3 = (lim - 1) ^ X2;
            for (int i = X3; ; i = X3 &amp; (i - 1)) &#123;
                (s1[X1][(lim - 1) ^ i] += v) %= mod;
                if (i == 0)
                    break;
            &#125;
        &#125;
        else &#123;
            long long v;
            std::cin &gt;&gt; v;
            for (int i = 0; i &lt; lim; ++i)
                (s2[X1][i] += v * (1 &lt;&lt; __builtin_popcount(i &amp; X2))) %= mod;
        &#125;
    &#125;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;


CF1784C Monsters (hard version)
https://www.luogu.com.cn/problem/CF1784C

通过若干次 1 操作，把数列的值域变成包含 1 且连续的，然后执行 2 操作，一定不劣
考虑怎么快速维护这个东西，发现只关心初始序列和目标序列（从计算代价的式子可以看出来），故考虑这样一个构造最终序列的方式：

从前到后遍历值域上的每个空位，找到第一个大于之的元素，并放过来，重复执行直到上述步骤不能执行为止。

直接考虑一次加点带来的影响似乎非常复杂，但如果时光倒流，发现有贪心策略，直接把最后一次操作挪到这个新的空位即可。
电波题！用 set 维护即可。


#include &lt;bits/stdc++.h&gt;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int T;
    for (std::cin &gt;&gt; T; T--; ) &#123;
        int n;
        std::cin &gt;&gt; n;
        std::set&lt;std::pair&lt;int, int&gt; &gt; t;
        std::vector&lt;long long&gt; res(n + 1);
        std::vector&lt;int&gt; a(n + 1), to(n + 1), at(n + 1);
        for (int i = 1; i &lt;= n; ++i)
            std::cin &gt;&gt; a[i], t.emplace(a[i], i);
        int now;
        for (now = 1; ; ++now) &#123;
            auto p(t.lower_bound(&#123; now, 0 &#125;));
            if (p == t.end())
                break;
            at[now] = p-&gt;second;
            to[p-&gt;second] = now;
            res[n] += p-&gt;first - now;
            t.erase(p);
        &#125;
        --now;
        for (int i = n - 1; i; --i) &#123;
            res[i] = res[i + 1];
            if (to[i + 1]) &#123;
                res[i] -= a[i + 1] - to[i + 1];
                auto p = t.lower_bound(&#123; to[i + 1], 0 &#125;);
                if (p != t.end()) &#123;
                    at[to[i + 1]] = p-&gt;second;
                    to[p-&gt;second] = to[i + 1];
                    res[i] += a[p-&gt;second] - to[i + 1];
                    t.erase(p);
                &#125;
                else &#123;
                    res[i] -= a[at[now]] - to[at[now]];
                    res[i] += a[at[now]] - to[i + 1];
                    to[at[now]] = to[i + 1];
                    at[to[i + 1]] = at[now];
                    --now;
                &#125;
            &#125;
            else
                t.erase(&#123; a[i + 1], i + 1 &#125;);
        &#125;
        for (int i = 1; i &lt;= n; ++i)
            std::cout &lt;&lt; res[i] &lt;&lt; &#39; &#39;;
        std::cout &lt;&lt; &#39;\n&#39;;
    &#125;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;


CF891C Envy
https://www.luogu.com.cn/problem/CF891C
mobai ddxrS

经典结论：在做完权值 \(&lt;w\) 的 Kruskal 后，权值 \(=w\) 的边以任意顺序加入 Kruskal 后，并查集连通性完全一致。
Another 经典结论：一条权值为 \(w\) 的边可以属于 mst，当且仅当在做完权值 \(&lt;w\) 的 Kruskal 后，这条边加入不形成环。
重要事实：把并查集的 merge 操作打乱，连通性不变。
结合起来得到这个神秘做法：按照边权做 Kruskal 检验每条边是否可以加入 mst，如果可以则记录合并的两个根，作为新边（不带权）。
重要事实：对于 \(n-1\) 条新边，要么有环，要么形成 mst。
推广：对于任意条新边，要么有环，要么可以通过某种选取其他新边的方式形成 mst。
故 check 给定边的新边是否成环即可。算是一个 trick 吗？


#include &lt;bits/stdc++.h&gt;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    const int M = 5e5;
    int n, m;
    std::cin &gt;&gt; n &gt;&gt; m;
    std::vector&lt;std::pair&lt;int, int&gt; &gt; ne(m + 1);
    std::vector&lt;std::vector&lt;std::tuple&lt;int, int, int&gt; &gt; &gt; e(M + 1); 
    for (int i = 1, x, y, w; i &lt;= m; ++i) &#123;
        std::cin &gt;&gt; x &gt;&gt; y &gt;&gt; w;
        e[w].emplace_back(x, y, i);
    &#125;
    std::vector&lt;int&gt; f(n + 1);
    std::iota(f.begin() + 1, f.end(), 1);
    std::function&lt;int(int)&gt; find = [&amp;](int x) &#123;
        return x == f[x] ? x : f[x] = find(f[x]);
    &#125;;
    for (int i = 1; i &lt;= M; ++i) &#123;
        for (auto [u, v, id] : e[i])
            ne[id] = &#123; find(u), find(v) &#125;;
        for (auto [u, v, id] : e[i])
            f[find(u)] = find(v);
    &#125;
    std::iota(f.begin() + 1, f.end(), 1);
    int q;
    for (std::cin &gt;&gt; q; q--; ) &#123;
        int k;
        std::cin &gt;&gt; k;
        std::vector&lt;int&gt; pos;
        bool flag = true;
        for (int id; k--; ) &#123;
            std::cin &gt;&gt; id;
            if (find(ne[id].first) == find(ne[id].second))
                flag = false;
            f[find(ne[id].first)] = find(ne[id].second);
            pos.push_back(ne[id].first);
            pos.push_back(ne[id].second);
        &#125;
        std::cout &lt;&lt; (flag ? &quot;YES&quot; : &quot;NO&quot;) &lt;&lt; &#39;\n&#39;;
        for (auto i : pos)
            f[i] = i;
    &#125;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;


C. 山月记
https://www.becoder.com.cn/problem/52034

给定一棵大小为 \(n\) 的带权无根树 \(T\)，再给定 \(m\) 条额外的边，和 \(T\) 一起形成一个图 \(G\)。
定义一个点 \(u\) 是好的，当且仅当对于每一个 \(1\le v\le n\)，\(T\) 上的简单路径 \((u,v)\) 都可以被 \(G\) 的某个 MST 完整包含。
输出任意一个好的点。无解输出 \(0\)。有 SPJ。
\(n,m\le 10^5\)，\(w\le 10^9\)。


参考上一题，朴素做法是 \(O(n^2)\) 枚举某个 \(x\) 开头的路径，然后 \(O(len)\) 地 check；
注意到这个结构能很好地和 DFS + 回溯结合，用可撤销并查集维护即可在 \(O(n\log n)\) 内完成对一个 \(x\) 所有路径的 check。
发现：如果一条路径 \((u,v)\) 是非法的，进一步所有完整包含 \((u,v)\) 的路径都是非法的。
从路径反映到点上，会发现 \((u,v)\) 两侧的点都是非法的。下意识考虑不在 \((u,v)\) 两侧，但在 \((u,v)\) 之外的点，发现它们仍然有可能合法，只要满足如下情况：

也就是说，对于 \(x\)，如果它出发的所有路径都合法，那么 \(x\) 自己就是答案；
如果存在 \(\ge 2\) 条非法路径，那么无解；
否则，存在恰好一条边，在非法边所在的子树中递归求解，发现这很点分治，故可以 \(O(n\log^2 n)\) 解决。log 分别来自点分治和撤销并查集。
注：这里唐唐的，check 写成点分树子树内 check 了。点分治在这里只起保证递归层数的作用。


怎么跑得这么快？推测因为写的是按秩合并。
#include &lt;bits/stdc++.h&gt;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;./test/20251024/beast/beast1.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int T;
    for (std::cin &gt;&gt; T; T--; ) &#123;
        int n, m;
        std::cin &gt;&gt; n &gt;&gt; m;
        std::vector&lt;int&gt; l(1);
        std::vector&lt;std::pair&lt;int, int&gt; &gt; ne(m + 1);
        std::vector&lt;std::tuple&lt;int, int, int&gt; &gt; se(m + 1);
        std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; g(n + 1);
        std::vector&lt;std::vector&lt;std::tuple&lt;int, int, int&gt; &gt; &gt; e(m + 1); 
        for (int i = 1, x, y, w; i &lt;= m; ++i) &#123;
            std::cin &gt;&gt; x &gt;&gt; y &gt;&gt; w;
            se[i] = &#123; x, y, w &#125;, l.push_back(w);
            if (i &lt; n)
                g[x].emplace_back(y, i), g[y].emplace_back(x, i);
        &#125;
        std::sort(l.begin() + 1, l.end());
        l.erase(std::unique(l.begin() + 1, l.end()), l.end());
        for (int i = 1; i &lt;= m; ++i) &#123;
            auto [x, y, w] = se[i];
            w = std::lower_bound(l.begin() + 1, l.end(), w) - l.begin();
            e[w].emplace_back(x, y, i);
        &#125;
        std::vector&lt;int&gt; f(n + 1);
        std::iota(f.begin() + 1, f.end(), 1);
        std::function&lt;int(int)&gt; find = [&amp;](int x) &#123;
            return x == f[x] ? x : f[x] = find(f[x]);
        &#125;;
        for (int i = 1; i &lt;= m; ++i) &#123;
            for (auto [u, v, id] : e[i])
                ne[id] = &#123; find(u), find(v) &#125;;
            for (auto [u, v, id] : e[i])
                f[find(u)] = find(v);
        &#125;
        std::vector&lt;int&gt; tag(n + 1), p, siz(n + 1), mx(n + 1);
        std::function&lt;void(int, int)&gt; DFS1 = [&amp;](int x, int fa) &#123;
            p.push_back(x);
            siz[x] = 1, mx[x] = 0;
            for (auto [i, id] : g[x])
                if (i != fa &amp;&amp; !tag[i]) &#123;
                    DFS1(i, x);
                    siz[x] += siz[i];
                    mx[x] = std::max(mx[x], siz[i]);
                &#125;
            return;
        &#125;;
        auto findrt = [&amp;](int x) &#123;
            p.clear(), DFS1(x, -1);
            int n = (int)p.size();
            for (auto i : p)
                if (mx[i] &lt;= n / 2 &amp;&amp; n - siz[i] &lt;= n / 2)
                    return i;
            assert(0);
            return -1;
        &#125;;
        std::vector&lt;int&gt; rank(n + 1);
        std::stack&lt;std::tuple&lt;int, int, int&gt; &gt; st;
        find = [&amp;](int x) &#123;
            return x == f[x] ? x : find(f[x]);
        &#125;;
        auto merge = [&amp;](int x, int y) &#123;
            x = find(x), y = find(y);
            if (x == y)
                return true;
            if (rank[x] &lt;= rank[y])
                st.emplace(x, y, rank[y]), f[x] = y;
            else 
                st.emplace(y, x, rank[x]), f[y] = x;
            if (rank[x] == rank[y])
                ++rank[y];
            return false;
        &#125;;
        auto undo = [&amp;](void) &#123;
            assert(!st.empty());
            auto [x, y, ry] = st.top();
            st.pop();
            f[x] = x, rank[y] = ry;
            return;
        &#125;;
        std::function&lt;bool(int, int)&gt; DFS2 = [&amp;](int x, int fa) &#123;
            for (auto [i, id] : g[x])
                if (i != fa &amp;&amp; (merge(ne[id].first, ne[id].second) || DFS2(i, x))) &#123;
                    undo();
                    return true;
                &#125;
            undo();
            return false;
        &#125;;
        std::function&lt;bool(int)&gt; DFS = [&amp;](int x) &#123;
            x = findrt(x);
            int to = 0;
            for (auto [i, id] : g[x])
                if (merge(ne[id].first, ne[id].second) || DFS2(i, x)) &#123;
                    if (!to) to = i;
                    else &#123;
                        std::cout &lt;&lt; 0 &lt;&lt; &#39;\n&#39;;
                        return true;
                    &#125;
                &#125;
            assert(st.empty());
            tag[x] = 1;
            if (to) &#123;
                if (tag[to]) &#123;
                    std::cout &lt;&lt; 0 &lt;&lt; &#39;\n&#39;;
                    return true;
                &#125;
                return DFS(to);
            &#125;
            std::cout &lt;&lt; x &lt;&lt; &#39;\n&#39;;
            return true;
        &#125;;
        std::iota(f.begin() + 1, f.end(), 1);
        assert(DFS(1));
    &#125;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;


B. 电报 / A. 神灵庙 / CF2068D Morse Code
https://www.becoder.com.cn/contest/6676/problem/2 / https://www.becoder.com.cn/contest/5527/problem/1 / https://www.luogu.com.cn/problem/CF2068D

一个无限大的完全二叉树，根节点权值为 \(0\)，一个点的左儿子权值是这个点的权值 \(+1\)，右儿子为 \(+2\)。
给定 \(c_1,\cdots, c_n\)，挑选 \(n\) 个互不为祖孙的点，最终代价为点权 \(\times\) 对应的 \(c\) 之和。


一个基本的观察：权值对应相邻两种值的结点数总是构成类似斐波那契的结构。显然应该把权值和点权逆大小对应。
朴素 DP：令 \(f_{i,j,a,b}\) 表示当前枚举到权值 \(i\)，已经选了 \(j\) 个点，\(i-1\)、\(i\) 分别剩余 \(a,b\) 个点的最小代价，可以得到 \(n^5\) 的惊人转移。
经典 trick：最后一层循环的枚举是无必要的，可以一个一个转移（类似完全背包）。这样就少了一个 \(n\)。如果观察到最深取到 1.5 log（斐波那契）能砍成 \(O(n^3\log n)\)。
接着，发现可以费用提前计算（这里我觉得更像是算贡献），少枚举一个 \(i\)，这样就是 \(O(n^3)\) 的了。
发现没什么实现的头绪。目前有：
\[
f_{j,a,b}\to f_{j+1,a,b-1}\\
f_{j,a,b}+suf_{j+1}\to f_{j,b,a+b}
\]
以前没有注意到过，其实枚举顺序是由转移方程决定的：

第一种转移中，\(j\) 是递增的，\(a\) 水平，\(b\) 递减；
第二种转移中，\(j\) 水平，\(a\) 无法确定，\(b\) 不递减；

可以想到一个转移顺序：正序枚举 \(j\)，正序枚举 \(b\)；正序枚举 \(a\)。
此时第二种会有点问题，\(j\) 水平且 \(b\) 水平时，若 \(a\) 变小怎么办？发现这要求 \(b&lt;a\)，则 \(a+b&gt;b\) 恒成立，\(b\) 一定不水平。挺牛的这个。
卡空间了，滚动一下即可。复杂度 \(O(n^3)\)。绅士写了神秘玄学做法，瞻仰无果。


#include &lt;bits/stdc++.h&gt;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
    std::freopen(&quot;telegram.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;telegram.out&quot;, &quot;w&quot;, stdout);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n;
    std::cin &gt;&gt; n;
    std::vector&lt;int&gt; c(n + 1);
    for (int i = 1; i &lt;= n; ++i)
        std::cin &gt;&gt; c[i];
    std::sort(c.begin() + 1, c.end(), std::greater&lt;int&gt; ());
    std::partial_sum(c.rbegin(), c.rend(), c.rbegin());
    using arr = std::vector&lt;int&gt;;
    using brr = std::vector&lt;arr&gt;;
    using crr = std::vector&lt;brr&gt;;
    crr f(2, brr(n + 1, arr(n + 1))), tag(2, brr(n + 1, arr(n + 1, -1)));
    f[0][1][1] = c[1], tag[0][1][1] = 0;
    auto upd = [&amp;](int i, int &amp;t, int &amp;x, int y) &#123;
        if (t == i)
            x = std::min(x, y);
        else
            x = y, t = i;
        return;
    &#125;;
    for (int j = 0, k = 0; j &lt; n; ++j, k ^= 1) &#123;
        for (int b = 0; b &lt;= n; ++b)
            for (int a = 0; a &lt;= n; ++a)
                if (tag[k][b][a] == j) &#123;
                    if (b)
                        upd(j + 1, tag[k ^ 1][b - 1][a], f[k ^ 1][b - 1][a], f[k][b][a]);
                    if (a + b &lt;= n)
                        upd(j, tag[k][a + b][b], f[k][a + b][b], f[k][b][a] + c[j + 1]);
                &#125;
    &#125;
    auto res = 0x3f3f3f3f;
    for (int b = 0; b &lt;= n; ++b)
        for (int a = 0; a &lt;= n; ++a)
            if (tag[n &amp; 1][b][a] == n)
                res = std::min(res, f[n &amp; 1][b][a]);
    std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;


[COI 2019] TENIS
https://www.luogu.com.cn/problem/P11340

观察一：\(x\) 能获胜，当且仅当存在一个 \(y\)，使得 \(x\) 能战胜 \(y\)，且 \(y\) 能在剩下 \(n-1\) 个人中获胜。
发现这是一个递归，或者说链式的关系。
观察二：不妨把三个数组视为三条链，那么发现任意一个链首在任意局面总是能获胜。如果一个人能战胜链首，显然这个人能获胜。反过来，若不能通过任何方式战胜链首，显然无法获胜。
然后就变成连通性问题了。但很容易猜到带删边连通性没什么优化的前途。
只有加边的带修连通性问题：整体二分。
观察三：链首不能被 \(x\) 战胜，当且仅当存在一个 \(i\)，三条链的前 \(i\) 个元素集相同，且 \(x\) 位于最小的 \(i\) 之后。
这个看起来和 Puuding Monsters / Good Subsegments 比较像，实际上思路上也有共通之处：如果合法区间的值域是连续的，可以把条件转化为 min / max 问题。
考虑先使其询问区间内值域连续以套用这样的方法。可以对链 1 重标号为 \(1\cdots n\)，维护链 2、3 的答案；也可以维护三个 rank 上的答案。法一实现起来有很多不必要的令人讨厌的地方，故写法二。
相当于求一个最小的 \(i\) 使得链 1、2、3 在 \(i\) 之前的所有元素 rank 都不能比 \(i\) 大。主体为 \(i\) 时，（因为最小这个限制，和依次改动会带来很大的偏移），所以不太好维护；
但是正确的维护方式很难想到！令 \(f_i,g_i\) 分别表示链 2、3 的每个 \(1\le j\le n\)，满足 \(\min(r_{1/2/3,j})\)、\(\max(r_{1/2/3,j})= i\) 的 \(j\) 的数量。如果二者在 \(i\) 处的前缀和相等，那么 \(i\) 就是合法的。

Fractures（新角色）：这是个很常见的 trick。
Fractures：这个和 Pudding Monsters 哪里像了。是你唐。

维护 \(f_i-g_i\) 的前缀和；线段树维护区间修改和全局 min 即可。


莫名很慢。和 TTpandaS 相比多了一次建树（但不应该有这么大的影响才对）。
#include &lt;bits/stdc++.h&gt;
const int maxn = 1e5 + 5;
struct &#123; int l, r, mn, at, d; &#125; t[maxn &lt;&lt; 2];
#define lt (p &lt;&lt; 1)
#define rt (lt | 1)
void pushup(int p) &#123;
    t[p].mn = std::min(t[lt].mn, t[rt].mn);
    if (t[lt].mn == t[p].mn)
        t[p].at = t[lt].at;
    else
        t[p].at = t[rt].at;
    return;
&#125;
void pushdown(int p) &#123;
    if (t[p].d) &#123;
        t[lt].d += t[p].d, t[lt].mn += t[p].d;
        t[rt].d += t[p].d, t[rt].mn += t[p].d;
        t[p].d = 0;
    &#125;
    return;
&#125;
void bld(int p, int l, int r) &#123;
    t[p].l = l, t[p].r = r;
    if (l == r) &#123;
        t[p].at = l;
        return;
    &#125;
    int mid = (l + r) &gt;&gt; 1;
    bld(lt, l, mid), bld(rt, mid + 1, r);
    pushup(p);
    return;
&#125;
void add(int p, int l, int r, int v) &#123;
    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r) &#123;
        t[p].d += v, t[p].mn += v;
        return;
    &#125;
    pushdown(p);
    int mid = (t[p].l + t[p].r) &gt;&gt; 1;
    if (l &lt;= mid)
        add(lt, l, r, v);
    if (r &gt; mid)
        add(rt, l, r, v);
    pushup(p);
    return;
&#125;
#undef lt
#undef rt
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
    std::freopen(&quot;match.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;match.out&quot;, &quot;w&quot;, stdout);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, q;
    std::cin &gt;&gt; n &gt;&gt; q;
    std::vector&lt;std::vector&lt;int&gt; &gt; p(3, std::vector&lt;int&gt; (n + 1));
    for (int k = 0; k &lt; 3; ++k)
        for (int i = 1, x; i &lt;= n; ++i)
            std::cin &gt;&gt; x, p[k][x] = i;
    bld(1, 1, n);
    auto upd = [&amp;](int i, int k) &#123;
        add(1, std::min(&#123; p[0][i], p[1][i], p[2][i] &#125;), n, k);
        add(1, std::max(&#123; p[0][i], p[1][i], p[2][i] &#125;), n, -k);
        return;
    &#125;;
    for (int i = 1; i &lt;= n; ++i)
        upd(i, 1);
    int now = t[1].at;
    // printf(&quot;now = %d \n&quot;, now);
    for (int op; q--; ) &#123;
        std::cin &gt;&gt; op;
        if (op == 1) &#123;
            int x;
            std::cin &gt;&gt; x;
            std::cout &lt;&lt; (std::min(&#123; p[0][x], p[1][x], p[2][x] &#125;) &lt;= now ? &quot;Yes&quot; : &quot;No&quot;) &lt;&lt; &#39;\n&#39;;
        &#125;
        else &#123;
            int k, i, j;
            std::cin &gt;&gt; k &gt;&gt; i &gt;&gt; j, --k;
            upd(i, -1), upd(j, -1);
            std::swap(p[k][i], p[k][j]);
            upd(i, 1), upd(j, 1);
            now = t[1].at;
            // printf(&quot;now = %d \n&quot;, now);
        &#125;
    &#125;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;

]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>最小生成树</tag>
        <tag>贪心</tag>
        <tag>优化建图</tag>
        <tag>DP 优化</tag>
        <tag>点分治</tag>
      </tags>
  </entry>
  <entry>
    <title>杂题选谈：图论思维题</title>
    <url>/20251023/</url>
    <content><![CDATA[人类智慧题


A - Train Splitting
https://www.luogu.com.cn/problem/CF1776F

神秘构造题，猜 \(k=2\) 一定能构造
考虑直接从图上抠一个点下来，与之相关的边全部染成 1，剩下的染成 2
发现如果恰好选中了菊花的根就不行
需要找到一个度数不为 \(n-1\) 的点。完全图的话，从菊花的根上抠一条当颜色 3 即可。


#include &lt;bits/stdc++.h&gt;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int T;
    for (std::cin &gt;&gt; T; T--; ) &#123;
        int n, m;
        std::cin &gt;&gt; n &gt;&gt; m;
        std::vector&lt;int&gt; deg(n + 1);
        std::vector&lt;std::pair&lt;int, int&gt; &gt; e(m + 1);
        int pos = -1;
        for (int i = 1; i &lt;= m; ++i) &#123;
            std::cin &gt;&gt; e[i].first &gt;&gt; e[i].second;
            ++deg[e[i].first], ++deg[e[i].second];
        &#125;
        for (int i = 1; i &lt;= n; ++i)
            if (deg[i] != n - 1) &#123;
                pos = i;
                break;
            &#125;
        if (pos != -1) &#123;
            std::cout &lt;&lt; 2 &lt;&lt; &#39;\n&#39;;
            for (int i = 1; i &lt;= m; ++i)
                if (e[i].first == pos || e[i].second == pos)
                    std::cout &lt;&lt; 1 &lt;&lt; &#39; &#39;;
                else
                    std::cout &lt;&lt; 2 &lt;&lt; &#39; &#39;;
            std::cout &lt;&lt; &#39;\n&#39;;
        &#125;
        else &#123;
            std::cout &lt;&lt; 3 &lt;&lt; &#39;\n&#39;;
            pos = 1;
            bool flag = true;
            for (int i = 1; i &lt;= m; ++i)
                if (e[i].first == pos || e[i].second == pos) &#123;
                    if (flag)
                        std::cout &lt;&lt; 3 &lt;&lt; &#39; &#39;, flag = false;
                    else
                        std::cout &lt;&lt; 1 &lt;&lt; &#39; &#39;;
                &#125;
                else
                    std::cout &lt;&lt; 2 &lt;&lt; &#39; &#39;;
        &#125;
    &#125;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;


B - Graph Partition
https://www.luogu.com.cn/problem/AT_agc039_b

考虑二分图染色什么时候不行，即有奇环时
考虑有多少种颜色时能染奇环，发现都不行，故二分图染色即可判定。
真的只有绿吗？观察样例，猜测答案为图的直径。考虑构造：
枚举每个点并钦定其为唯一一个 \(1\)，然后依次向下染色。显然最后构造出来的是合法的。最大为直径长度 + 1。
也可以从差分约束的角度理解，但无甚必要。


#include &lt;bits/stdc++.h&gt;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n;
    std::cin &gt;&gt; n;
    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1), g1(n + 1, std::vector&lt;int&gt; (n + 1, 0x3f3f3f3f));
    for (int i = 1; i &lt;= n; ++i) &#123;
        g1[i][i] = 0;
        for (int j = 1; j &lt;= n; ++j) &#123;
            char t;
            std::cin &gt;&gt; t;
            if (t == &#39;1&#39;)
                g[i].push_back(j), g1[i][j] = 1;
        &#125;
    &#125;
    std::vector&lt;int&gt; col(n + 1);
    std::function&lt;bool(int, int)&gt; DFS = [&amp;](int x, int now) &#123;
        col[x] = now;
        for (auto i : g[x])
            if (!col[i]) &#123;
                if (!DFS(i, 3 - now))
                    return false;
            &#125;
            else if (col[i] == now)
                return false;
        return true;
    &#125;;
    if (!DFS(1, 1))
        std::cout &lt;&lt; -1 &lt;&lt; &#39;\n&#39;;
    else &#123;
        for (int k = 1; k &lt;= n; ++k)
            for (int i = 1; i &lt;= n; ++i)
                for (int j = 1; j &lt;= n; ++j)
                    g1[i][j] = std::min(g1[i][j], g1[i][k] + g1[k][j]);
        int mx = 0;
        for (int i = 1; i &lt;= n; ++i)
            for (int j = 1; j &lt;= n; ++j)
                mx = std::max(mx, g1[i][j] + 1);
        std::cout &lt;&lt; mx &lt;&lt; &#39;\n&#39;;
    &#125;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;


C - Strange Housing
https://www.luogu.com.cn/problem/CF1470D

第一反应是随便找一个生成树然后二分图染色，但是发现有当且仅当奇环时行为不太正确
考虑打个补丁，抛弃二分图染色的想法，不断尝试染成黑色，如果染了下一个点会出现黑黑边，那就不染它，对得比较显然。
当且仅当不连通时无解。


#include &lt;bits/stdc++.h&gt;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int T;
    for (std::cin &gt;&gt; T; T--; ) &#123;
        int n, m;
        std::cin &gt;&gt; n &gt;&gt; m;
        std::vector&lt;int&gt; f(n + 1);
        std::iota(f.begin() + 1, f.end(), 1);
        std::function&lt;int(int)&gt; find = [&amp;](int x) &#123;
            return x == f[x] ? x : f[x] = find(f[x]);
        &#125;;
        std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1), g1(n + 1);
        int cnt = 0;
        for (int x, y; m--; ) &#123;
            std::cin &gt;&gt; x &gt;&gt; y;
            g1[x].push_back(y), g1[y].push_back(x);
            if (find(x) != find(y)) &#123;
                f[find(x)] = find(y);
                ++cnt, g[x].push_back(y), g[y].push_back(x);
            &#125;
        &#125;
        if (cnt != n - 1) &#123;
            std::cout &lt;&lt; &quot;NO\n&quot;;
            continue;
        &#125;
        std::vector&lt;int&gt; col(n + 1);
        std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int fa) &#123;
            for (auto i : g[x])
                if (i != fa) &#123;
                    bool flag = true;
                    for (auto j : g1[i])
                        if (col[j] == 2) &#123;
                            flag = false;
                            break;
                        &#125;
                    if (flag)
                        col[i] = 2;
                    else
                        col[i] = 1;
                    DFS(i, x);
                &#125;
            return;
        &#125;;
        col[1] = 2, DFS(1, -1);
        std::vector&lt;int&gt; res;
        for (int i = 1; i &lt;= n; ++i)
            if (col[i] == 2)
                res.push_back(i);
        std::cout &lt;&lt; &quot;YES\n&quot; &lt;&lt; (int)res.size() &lt;&lt; &#39;\n&#39;;
        for (auto i : res)
            std::cout &lt;&lt; i &lt;&lt; &#39; &#39;;
        std::cout &lt;&lt; &#39;\n&#39;;
    &#125;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;


D - Defender of Childhood Dreams
https://www.luogu.com.cn/problem/CF1583F

考虑把每连续 \(k\) 个点分为一个一级组，每个一级组内全部连 \(1\) 边。显然组内边最长不超过 \(k-1\)。
接着把每连续 \(k\) 个一级组分为一个二级组，二级组内空闲边全部涂成颜色 \(2\)。
此时 \(a&lt;b\) 的条件就会派上用场：每个一级组的值域是没有交的，一级组之间的边都是同一个朝向。
这样就保证由颜色为 \(2\) 的边构成的连链来自不同的一级组，长度最多为 \(k-1\)。
依次类推，\(i\) 级组是大小为 \(k^i\) 的团，故 \(i\) 最大为 \(\left\lceil \log_kn\right\rceil\)。
按上述流程构造，即可 \(O(n^2)\) 完成。


#include &lt;bits/stdc++.h&gt;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, k;
    std::cin &gt;&gt; n &gt;&gt; k;
    using arr = std::vector&lt;int&gt;;
    using brr = std::vector&lt;arr&gt;;
    brr pos;
    for (int i = 1; i &lt;= n; ++i)
        pos.push_back(&#123; i &#125;);
    brr g(n + 1, arr(n + 1));
    std::function&lt;void(brr&amp;, int)&gt; calc = [&amp;](brr &amp;pos, int now) &#123;
        if ((int)pos.size() == 1) &#123;
            std::cout &lt;&lt; now &lt;&lt; &#39;\n&#39;;
            for (int i = 1; i &lt;= n; ++i)
                for (int j = i + 1; j &lt;= n; ++j)
                    std::cout &lt;&lt; g[i][j] &lt;&lt; &#39; &#39;;
            std::cout &lt;&lt; &#39;\n&#39;;
            return;
        &#125;
        brr p;
        ++now;
        for (int i = 0; i &lt; (int)pos.size(); i += k) &#123;
            p.emplace_back();
            for (int j = i; j &lt; i + k &amp;&amp; j &lt; (int)pos.size(); ++j) &#123;
                for (auto a : p.back())
                    for (auto b : pos[j])
                        g[a][b] = now;
                for (auto b : pos[j])
                    p.back().push_back(b);
            &#125;
        &#125;
        calc(p, now);
        return;
    &#125;;
    calc(pos, 0);
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;


E - Edge Split
https://www.luogu.com.cn/problem/CF1726D

题意有些许歧义，『红色连通块』其实是指删掉蓝边之后的连通块。考虑到 \(m\le n+2\) 而不是更多，考虑直接分讨。
考虑树的情况，对于任意颜色，删一条边就会带来 \(1\) 个连通块的代价，随便染色即可。
考虑基环树的情况，发现如果环上有某个颜色，那么钦定这个颜色第一次删边删的是环边，就会发现第一次删边不会有代价，故强制环上有两种颜色即可。
考虑 \(m=n+1\) 的情况，环可能有下面三种形态：

对于第一、二种，保证两个环上都有两种颜色即可，第三种乍一看有点复杂，其实还是一样的，保证两个环都有两种颜色即可，这样三个环显然都会有两种颜色。站在不饱和度的角度，第三个环其实是无意义的。
由此类推 \(m=n+2\) 的情况，发现只需要在并查集连边时令树边为蓝，反祖边为红即可。发现这样会且仅会在第一组样例的情况出问题：

如果中间的三角形在最后输入就不能得到最优解

怎么处理这个问题呢，我们使用人类智慧，发现这种情况最后三条红边构成三角形，我们只要发现构造出来的解是这样的三角形，由于造成这一点的顺序很苛刻，故一直 random_shuffle 输入，继续构造直到合法即可。
（？怎么最优解全是这么做的，我还以为只有我一个人会乱搞。）
当不饱和度为 4 的时候就会出现这种结构：

此时按照刚刚的方法就一定构造不出合法解了。这或许也是 \(m\le n+2\) 的原因。


#include &lt;bits/stdc++.h&gt;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    std::mt19937 rand(0xabcdef);
    int T;
    for (std::cin &gt;&gt; T; T--; ) &#123;
        int n, m;
        std::cin &gt;&gt; n &gt;&gt; m;
        std::vector&lt;int&gt; res(m + 1);
        std::vector&lt;std::tuple&lt;int, int, int&gt; &gt; e(m + 1);
        for (int i = 1, x, y; i &lt;= m; ++i) &#123;
            std::cin &gt;&gt; x &gt;&gt; y;
            e[i] = &#123; x, y, i &#125;;
        &#125;
        auto work = [&amp;](std::vector&lt;std::tuple&lt;int, int, int&gt; &gt; &amp;e) &#123;
            std::vector&lt;int&gt; f(n + 1);
            std::iota(f.begin() + 1, f.end(), 1);
            std::function&lt;int(int)&gt; find = [&amp;](int x) &#123;
                return x == f[x] ? x : f[x] = find(f[x]);
            &#125;;
            std::set&lt;int&gt; t;
            for (int i = 1; i &lt;= m; ++i) &#123;
                auto [x, y, id] = e[i];
                if (find(x) == find(y)) &#123;
                    t.insert(x), t.insert(y);
                    res[id] = 1;
                &#125;
                else &#123;
                    res[id] = 0;
                    f[find(x)] = find(y);
                &#125;
            &#125;
            return (int)t.size() != 3;
        &#125;;
        for (; !work(e); std::shuffle(e.begin() + 1, e.end(), rand));
        for (int i = 1; i &lt;= m; ++i)
            std::cout &lt;&lt; res[i];
        std::cout &lt;&lt; &#39;\n&#39;;
    &#125;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;


F - Fair Share
https://www.luogu.com.cn/problem/CF1634E
原来 \(L=R\) 是说两个可重集相等 不是说和相等

考虑把所有元素排得整齐一点：同一组的在同一行，同一值的在同一列（显然这就要求每列元素个数为偶）。这样要求就转化为：分组，并满足每行每组各占一半、每列每组各占一半。
参考 Ball，用连边可以体现二选一的操作，发现其实二选一就是一选二分之一，故在行列中连边，按照 \((1,2)\)，\((3,4)\) 这样连边，就可以满足一选二分之一。
因为元素可重，所以一行一列可能会有多个元素，这不太好；实际实现时，不妨记输入的第 \(i\) 个数组第 \(j\) 个元素为 \(a_{i,j}\)，实际上连的是 \((a_{i,j},a_{i,j\oplus 1})\)；记值为 \(i\) 的第 \(j\) 个元素为 \(b_{i,j}\)，实际上连的是 \((b_{i,j},b_{i,j\oplus 1})\)。
还是参照 Ball 中二分图的观点，发现这个图很能二分图染色。如果这个解法是足够优的，我们当然希望不包含奇环。由于一个点在 \(a\) 中至多被连一条边，在 \(b\) 中也至多被连一条边，所以一条路径一定是 a b 交错的，由此证毕。


#include &lt;bits/stdc++.h&gt;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, tot = 0, N = 0;
    std::cin &gt;&gt; n;
    std::unordered_map&lt;int, int&gt; tab;
    std::vector&lt;std::vector&lt;int&gt; &gt; a(n + 1), b(1);
    for (int i = 1, m; i &lt;= n; ++i) &#123;
        std::cin &gt;&gt; m;
        for (int x; m--; ) &#123;
            std::cin &gt;&gt; x, ++N;
            if (!tab.count(x))
                tab[x] = ++tot, b.emplace_back();
            a[i].push_back(N);
            b[tab[x]].push_back(N);
        &#125;
    &#125;
    std::vector&lt;std::vector&lt;int&gt; &gt; g(N + 1);
    for (int i = 1; i &lt;= n; ++i)
        for (int j = 0; j &lt; (int)a[i].size(); ++j)
            g[a[i][j]].push_back(a[i][j ^ 1]);
    for (int i = 1; i &lt;= tot; ++i) &#123;
        if ((int)b[i].size() &amp; 1) &#123;
            std::cout &lt;&lt; &quot;NO\n&quot;;
            return 0;
        &#125;
        for (int j = 0; j &lt; (int)b[i].size(); ++j)
            g[b[i][j]].push_back(b[i][j ^ 1]);
    &#125;
    std::cout &lt;&lt; &quot;YES\n&quot;;
    std::vector&lt;int&gt; col(N + 1);
    std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int now) &#123;
        col[x] = now;
        for (auto i : g[x])
            if (!col[i])
                DFS(i, 3 - now);
            else
                assert(col[i] != col[x]);
        return;
    &#125;;
    for (int i = 1; i &lt;= n; ++i) &#123;
        for (auto j : a[i]) &#123;
            if (!col[j])
                DFS(j, 1);
            std::cout &lt;&lt; (col[j] == 1 ? &#39;L&#39; : &#39;R&#39;);
        &#125;
        std::cout &lt;&lt; &#39;\n&#39;;
    &#125;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;


G - Lenient Vertex Cover
https://www.luogu.com.cn/problem/CF1680F

对于边不被完全覆盖的限制把问题转换成了一个近似二分图染色的形态，一个朴素的做法是枚举这样的边并染色，但似乎没什么优化前途，考虑更加二分图的做法。
从非法的角度考虑，相当于是问能不能抠掉 \(\le 1\) 条边使图变为二分图。显然这条边（如果存在）在奇环上且是所有奇环的交。
从合法的角度考虑，因为不是真的删边，而是相当于把所在的所有环长度 \(-1\)，所以这条边不能被任何一个偶环包含。
容易想到找生成树，标记偶环边并统计奇环。但显然没办法标记到所有偶环边，也没办法统计到所有奇环：


实际上这个做法可以证明是正确的，因为有一个前提：非树边总是可以和树边成环。
考虑两个疑点：

无法标记到所有偶环：当且仅当存在偶环需要 \(\ge 2\) 条非树边参与形成。需要证明这样的偶环上的树边不会被选中。
单看这个环上的树边，形成 \(\ge 2\) 个条分立的链。考虑它们在树上是怎么连通的：

中间相隔奇数条树边。那么会被另一条非树边标记为偶环。
中间相隔偶数条树边。那么这两条链一定不会被认定为可选的奇环边，因为一条非树边 + 这偶数条边会形成一个新的、与当前偶环分立的奇环。


无法判定到所有奇环：当且仅当存在奇环需要 \(\ge 2\) 条非树边参与形成。需要证明被选中的边被包含在这样的奇环中。
相似地，单看这个环上的树边，形成 \(\ge 2\) 个条分立的链。考虑它们在树上是怎么连通的：

中间相隔偶数条树边。上帝视角下共两个奇环，且公共边为这个奇环中除了另一条非树边以外的所有边。
实际上的行为也是正确的，另一条非树边参与形成并标记一个偶环，当前非树边形成并标记一个奇环。
中间相隔奇数条树边。那么会被另一条非树边标记为偶环，当前奇环中唯一可选的边为当前非树边。
实际行为也是正确的。比较显然。




故树上差分维护即可。


#include &lt;bits/stdc++.h&gt;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int T;
    for (std::cin &gt;&gt; T; T--; ) &#123;
        int n, m;
        std::cin &gt;&gt; n &gt;&gt; m;
        std::vector&lt;std::pair&lt;int, int&gt; &gt; e;
        std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1), g1(n + 1);
        for (int i = 1, x, y; i &lt;= m; ++i) &#123;
            std::cin &gt;&gt; x &gt;&gt; y;
            e.emplace_back(x, y);
            g1[x].push_back(y), g1[y].push_back(x);
        &#125;
        std::vector&lt;int&gt; col(n + 1);
        std::function&lt;bool(int, int)&gt; DFS = [&amp;](int x, int now) &#123;
            col[x] = now;
            for (auto i : g1[x])
                if (!col[i]) &#123;
                    if (!DFS(i, 3 - now))
                        return false;
                &#125;
                else if (col[i] == now)
                    return false;
            return true;
        &#125;;
        if (DFS(1, 1)) &#123;
            std::cout &lt;&lt; &quot;YES\n&quot;;
            for (int i = 1; i &lt;= n; ++i)
                std::cout &lt;&lt; col[i] - 1;
            std::cout &lt;&lt; &#39;\n&#39;;
            continue;
        &#125;
        std::vector&lt;int&gt; f(n + 1);
        std::iota(f.begin() + 1, f.end(), 1);
        std::vector&lt;std::pair&lt;int, int&gt; &gt; r;
        std::function&lt;int(int)&gt; find = [&amp;](int x) &#123; return x == f[x] ? x : f[x] = find(f[x]); &#125;;
        for (auto [u, v] : e)
            if (find(u) != find(v)) &#123;
                f[find(u)] = find(v);
                // printf(&quot;%d %d \n&quot;, u, v);
                g[u].push_back(v), g[v].push_back(u);
            &#125;
            else
                r.emplace_back(u, v);
        std::vector&lt;int&gt; dep(n + 1), son(n + 1), siz(n + 1), fa(n + 1);
        std::function&lt;void(int)&gt; DFS1 = [&amp;](int x) &#123;
            siz[x] = 1;
            for (auto i : g[x])
                if (i != fa[x]) &#123;
                    dep[i] = dep[x] + 1;
                    fa[i] = x, DFS1(i);
                    siz[x] += siz[i];
                    if (siz[i] &gt; siz[son[x]])
                        son[x] = i;
                &#125;
            return;
        &#125;;
        dep[1] = 1, DFS1(1);
        std::vector&lt;int&gt; top(n + 1);
        DFS1 = [&amp;](int x) &#123;
            if (son[x])
                top[son[x]] = top[x], DFS1(son[x]);
            for (auto i : g[x])
                if (i != fa[x] &amp;&amp; i != son[x])
                    top[i] = i, DFS1(i);
            return;
        &#125;;
        top[1] = 1, DFS1(1);
        auto askLCA = [&amp;](int x, int y) &#123;
            for (; top[x] != top[y]; x = fa[top[x]])
                if (dep[top[x]] &lt; dep[top[y]])
                    std::swap(x, y);
            return dep[x] &lt; dep[y] ? x : y;
        &#125;;
        int cnt = 0;
        std::pair&lt;int, int&gt; res;
        std::vector&lt;int&gt; tag(n + 1), s(n + 1);
        for (auto [u, v] : r) &#123;
            int fa = askLCA(u, v), dis = dep[u] + dep[v] - 2 * dep[fa];
            if (dis &amp; 1)
                ++tag[u], ++tag[v], tag[fa] -= 2;
            else &#123;
                res = &#123; 0, 0 &#125;;
                ++cnt, ++s[u], ++s[v], s[fa] -= 2;
                if (cnt == 1)
                    res = &#123; u, v &#125;;
            &#125;
        &#125;
        DFS1 = [&amp;](int x) &#123;
            for (auto i : g[x])
                if (i != fa[x]) &#123;
                    DFS1(i);
                    tag[x] += tag[i], s[x] += s[i];
                &#125;
            if (!tag[x] &amp;&amp; s[x] == cnt &amp;&amp; x != 1)
                res = &#123; fa[x], x &#125;;
            return;
        &#125;;
        DFS1(1);
        // printf(&quot;# %d %d \n&quot;, res.first, res.second);
        if (res.first) &#123;
            std::cout &lt;&lt; &quot;YES\n&quot;;
            std::fill(col.begin() + 1, col.end(), 0);
            std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int now) &#123;
                col[x] = now;
                for (auto i : g1[x])
                    if (!col[i])
                        DFS(i, 3 - now);
                return;
            &#125;;
            col[res.first] = col[res.second] = 2;
            DFS(res.first, 2), DFS(res.second, 2);
            for (int i = 1; i &lt;= n; ++i)
                std::cout &lt;&lt; col[i] - 1;
            std::cout &lt;&lt; &#39;\n&#39;;
        &#125;
        else
            std::cout &lt;&lt; &quot;NO\n&quot;;
    &#125;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;


H - Four Coloring
https://www.luogu.com.cn/problem/AT_code_festival_2017_quala_d

参见切比雪夫距离，则问题转化为，任意点为中心的边长为 \(2d+1\) 的正方形的边不能和这个点同色
直接按照 \(d\times d\) 进行划分即可。注意负数除法会影响正确性，故平移到正数即可。


#include &lt;bits/stdc++.h&gt;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, m, d;
    std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; d;
    for (int i = 1; i &lt;= n; ++i) &#123;
        for (int j = n + 1; j &lt;= n + m; ++j) &#123;
            int x = (i + j) / d, y = (j - i) / d;
            if (x % 2 == 0 &amp;&amp; y % 2 == 0)
                std::cout &lt;&lt; &#39;R&#39;;
            else if (x % 2 == 0)
                std::cout &lt;&lt; &#39;Y&#39;;
            else if (y % 2 == 0)
                std::cout &lt;&lt; &#39;G&#39;;
            else
                std::cout &lt;&lt; &#39;B&#39;;
        &#125;
        std::cout &lt;&lt; &#39;\n&#39;;
    &#125;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;


I - Diverse Coloring
https://vjudge.net/contest/759882#problem/I

可以很简单地猜到答案为 \(n\bmod 2\)，且唯一的例外是样例中 \(n=4\) 的菊花；
很难理解怎么想到构造方法的：从根节点开始 DFS，先向下递归处理儿子，如果儿子传上来未配对的点则与之配对，否则上传自己。
这样做之后，除了根可能为孤岛之外，树会被分为若干个大小为 2 或 3 的连通块，此时的染色策略就很明显了。

1 的连通块的存在价值是保证每个点在包含其的连通块内都能解决掉限制，大小 \(=3\) 的连通块是为了提供 \(1\) 或 \(-1\) 的代价用于调整。

对于孤岛根，一个很好的性质是其儿子所在连通块一定是下面的两层，故大力讨论前三层形态（实际上是前五层）：

神秘枚举


分讨即可。似乎并不用分这么多类，但是实现难度并不高。


#include &lt;bits/stdc++.h&gt;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int T;
    for (std::cin &gt;&gt; T; T--; ) &#123;
        int n;
        std::cin &gt;&gt; n;
        std::vector&lt;int&gt; deg(n + 1);
        std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);
        for (int i = 2, fa; i &lt;= n; ++i) &#123;
            std::cin &gt;&gt; fa;
            ++deg[fa], ++deg[i];
            g[fa].push_back(i);
            if (i == 4 &amp;&amp; *std::max_element(deg.begin() + 1, deg.begin() + 5) == 3)
                std::cout &lt;&lt; 2 &lt;&lt; &#39;\n&#39;;
            else
                std::cout &lt;&lt; i % 2 &lt;&lt; &#39;\n&#39;;
        &#125;
        std::vector&lt;int&gt; siz(n + 1);
        std::vector&lt;std::pair&lt;int, int&gt; &gt; p2;
        std::vector&lt;std::tuple&lt;int, int, int&gt; &gt; p3;
        std::function&lt;int(int)&gt; DFS = [&amp;](int x) &#123;
            std::vector&lt;int&gt; p;
            p.push_back(x);
            for (auto i : g[x])
                if (DFS(i) == 1)
                    p.push_back(i);
            if ((int)p.size() == 2)
                p2.emplace_back(p[0], p[1]);
            else if ((int)p.size() == 3)
                p3.emplace_back(p[0], p[1], p[2]);
            siz[x] = (int)p.size();
            return siz[x];
        &#125;;
        std::vector&lt;int&gt; col(n + 1);
        auto work = [&amp;](int now) &#123;
            for (auto [x, y] : p2)
                if (!col[x] &amp;&amp; !col[y])
                    col[x] = 1;
            for (auto [x, y, z] : p3)
                if (!col[x] &amp;&amp; !col[y] &amp;&amp; !col[z]) &#123;
                    if (now &gt;= 0)
                        col[x] = 1, --now;
                    else
                        col[y] = col[z] = 1, ++now;
                &#125;
            for (int i = 1; i &lt;= n; ++i)
                std::cout &lt;&lt; (col[i] ? &#39;b&#39; : &#39;w&#39;);
            std::cout &lt;&lt; &#39;\n&#39;;
            return;
        &#125;;
        DFS(1);
        int now = 0;
        if (siz[1] == 1) &#123;
            if ((int)g[1].size() == 1) &#123;
                int p2 = g[1][0];
                if (siz[p2] == 2)
                    col[p2] = 1, now = -1;
                else if (n == 4)
                    col[p2] = 1, now = -1;
                else &#123;
                    int p3 = g[g[p2][0]].empty() ? g[p2][1] : g[p2][0], p5 = g[p3][0];
                    col[p2] = col[p3] = 1;
                    if (siz[p5] == 2) &#123;
                        int p6 = siz[g[p5][0]] == 1 ? g[p5][0] : g[p5][1];
                        col[p6] = 1, now = 0;
                    &#125;
                    else &#123;
                        int p6 = g[p5][0], p7 = g[p5][1];
                        col[p6] = col[p7] = 1, now = 1;
                    &#125;
                &#125;
            &#125;
            else &#123;
                int p2 = g[1][0], p3 = g[1][1];
                if (siz[p2] &gt; siz[p3])
                    std::swap(p2, p3);
                if (siz[p2] == 2 &amp;&amp; siz[p3] == 2)
                    col[p2] = col[p3] = 1, now = -1;
                else if (siz[p2] == 2 &amp;&amp; siz[p3] == 3) &#123;
                    int p4 = siz[g[p2][0]] == 1 ? g[p2][0] : g[p2][1];
                    col[1] = col[p3] = col[p4] = 1, now = 0;
                &#125;
                else &#123;
                    int p4 = g[p2][0], p5 = g[p2][1];
                    col[1] = col[p3] = col[p4] = col[p5] = 1, now = 1;
                &#125;
            &#125;
        &#125;
        work(now);
    &#125;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;


J - Graph Coloring
https://www.luogu.com.cn/problem/CF662B

首先需要意识到，翻奇数次 / 偶数次可以归到翻 / 不翻的范畴里。
不妨枚举最后所有边颜色，那么就可以限定每条边的两端点翻转情况，发现这是并查集，但怎么求最小？难道要 2-SAT 吗？
发现最终的并查集一定是两两对应的，对应每一对，取最小开销者即可。


#include &lt;bits/stdc++.h&gt;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, m;
    std::cin &gt;&gt; n &gt;&gt; m;
    std::vector&lt;std::tuple&lt;int, int, int&gt; &gt; e;
    for (int i = 1, x, y; i &lt;= m; ++i) &#123;
        char t;
        std::cin &gt;&gt; x &gt;&gt; y &gt;&gt; t;
        e.emplace_back(x, y, t == &#39;R&#39;);
    &#125;
    std::vector&lt;int&gt; res1, res2;
    auto calc = [&amp;](std::vector&lt;int&gt; &amp;res) &#123;
        std::vector&lt;int&gt; f(2 * n + 1), siz(2 * n + 1);
        std::iota(f.begin() + 1, f.end(), 1);
        std::function&lt;int(int)&gt; find = [&amp;](int x) &#123;
            return x == f[x] ? x : f[x] = find(f[x]);
        &#125;;
        auto merge = [&amp;](int x, int y) &#123;
            f[find(x)] = find(y);
            return;
        &#125;;
        for (auto [x, y, w] : e)
            if (w)
                merge(x, y), merge(x + n, y + n);
            else
                merge(x, y + n), merge(x + n, y);
        for (int i = 1; i &lt;= n; ++i) &#123;
            ++siz[find(i)];
            if (find(i) == find(n + i))
                return false;
        &#125;
        std::vector&lt;int&gt; tag(2 * n + 1);
        for (int i = 1; i &lt;= n; ++i) &#123;
            if (!tag[find(i)]) &#123;
                tag[find(i)] = tag[find(i + n)] = 1;
                if (siz[find(i)] &lt;= siz[find(i + n)])
                    ++tag[find(i)];
                else
                    ++tag[find(i + n)];
            &#125;
            if (tag[find(i)] == 2)
                res.push_back(i);
        &#125;
        return true;
    &#125;;
    auto flag1 = calc(res1);
    for (auto &amp;[x, y, w] : e)
        w ^= 1;
    auto flag2 = calc(res2);
    if (!flag1 &amp;&amp; !flag2)
        std::cout &lt;&lt; -1 &lt;&lt; &#39;\n&#39;;
    else if (!flag2 || (flag1 &amp;&amp; res1.size() &lt; res2.size())) &#123;
        std::cout &lt;&lt; (int)res1.size() &lt;&lt; &#39;\n&#39;;
        for (auto i : res1)
            std::cout &lt;&lt; i &lt;&lt; &#39; &#39;;
        std::cout &lt;&lt; &#39;\n&#39;;
    &#125;
    else &#123;
        std::cout &lt;&lt; (int)res2.size() &lt;&lt; &#39;\n&#39;;
        for (auto i : res2)
            std::cout &lt;&lt; i &lt;&lt; &#39; &#39;;
        std::cout &lt;&lt; &#39;\n&#39;;
    &#125;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;

]]></content>
      <tags>
        <tag>并查集</tag>
        <tag>二分图</tag>
        <tag>构造</tag>
        <tag>思维</tag>
        <tag>随机化</tag>
      </tags>
  </entry>
  <entry>
    <title>杂题选谈</title>
    <url>/20251028/</url>
    <content><![CDATA[模拟赛的密度正在威胁其他文章的生存环境。


A. 排序
https://www.luogu.com.cn/problem/P14352

对于一个长度为 \(n\) 的排列 \(p\)，定义一轮冒泡：
for i in range(1, n):
    if p[i] &gt; p[i + 1]:
        swap(p[i], p[i + 1])
给定 \(n,k\)，问在所有长度为 \(n\) 的排列中，可以在 \(k\) 轮冒泡后单增的排列数量。对 \(998244353\) 取模。
\(n\le 10^{18},k\le 2\times 10^7\)。


反序表。令 \(a_i\) 表示 \(i\) 结尾的逆序对数，那么限制相当于说 \(\max\{a\}\le k\)。
也即限制一个元素之前大于之的元素数不超过 \(k\)，可以直接计数。想象把 \(1\sim n\) 依次填入排列的过程：

对于 \(1\sim n-k\)，只能填在剩余空位的左 \(k+1\) 个（因为填完它后，剩下的空位都比它大）；
对于 \(n-k+1\sim n\)，可以填在剩余任意一个空位。

故答案为 \((k+1)^{n-k}\cdot k!\)。


#include &lt;bits/stdc++.h&gt;
const int mod = 998244353;
int main() &#123;
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
    std::freopen(&quot;sorting.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;sorting.out&quot;, &quot;w&quot;, stdout);
    auto stime = std::chrono::steady_clock::now();
    long long n;
    int k;
    std::cin &gt;&gt; n &gt;&gt; k, k = std::min((long long)k, n);
    auto qkp = [&amp;](long long x, int y) &#123;
        auto res = 1ll;
        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)
            if (y &amp; 1)
                (res *= x) %= mod;
        return res;
    &#125;;
    auto res = qkp(k + 1, (n - k) % (mod - 1));
    for (int i = 1; i &lt;= k; ++i)
        (res *= i) %= mod;
    std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt;(std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s \n&quot;;
    return 0;
&#125;


B. 重排
https://www.luogu.com.cn/problem/P14353

给定一个初始为空的数组 \(a\)，再给出 \(n\) 次加数操作，每次加数后输出：
任意排列 \(a\)，得到的 \(\sum\limits_{i=2}^n |a_{i+1}-a_{i}|\) 的最大值。
\(n\le 3\times 10^6\)。


显然从小到大排列，答案是后 \(\left\lfloor \dfrac n2\right\rfloor\) 个数的和减去前 \(\left\lfloor \dfrac n2\right\rfloor\) 的和的差的二倍，再减去位于中间 2 / 3 个数中，相邻两个差的最小值。
这家伙在说什么呢.jpg
用大根堆 + 小根堆维护即可，因为 pbds 过不去


#include &lt;bits/stdc++.h&gt;
int main() &#123;
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
    std::freopen(&quot;rearrange.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;rearrange.out&quot;, &quot;w&quot;, stdout);
    auto stime = std::chrono::steady_clock::now();
    int n, T;
    std::cin &gt;&gt; n &gt;&gt; T;
    auto res = 0ll, la = 0ll, sL = 0ll, sR = 0ll;
    std::priority_queue&lt;int&gt; L;
    std::priority_queue&lt;int, std::vector&lt;int&gt;, std::greater&lt;int&gt; &gt; R;
    for (int i = 1, mid = 0; i &lt;= n; ++i) &#123;
        long long x;
        std::cin &gt;&gt; x;
        int b =  T ? x ^ la : x;
        if (i == 1)
            mid = b, la = 0ll;
        else if (i &amp; 1) &#123;
            if (b &lt; L.top()) &#123;
                mid = L.top(), sL -= mid;
                L.pop();
                sL += b, L.push(b);
            &#125;
            else if (b &gt; R.top()) &#123;
                mid = R.top(), sR -= mid;
                R.pop();
                sR += b, R.push(b);
            &#125;
            else
                mid = b;
            la = 2 * (sR - sL) - std::min(R.top() - mid, mid - L.top());
        &#125;
        else &#123;
            if (b &lt;= mid) &#123;
                sL += b, sR += mid;
                L.push(b), R.push(mid);
            &#125;
            else &#123;
                sL += mid, sR += b;
                L.push(mid), R.push(b);
            &#125;
            la = 2 * (sR - sL) - (R.top() - L.top());
        &#125;
        res ^= la;
    &#125;
    printf(&quot;%lld\n&quot;, res);
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt;(std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s \n&quot;;
    return 0;
&#125;


C. 整式比较 / qoj#10506. Waga
https://www.becoder.com.cn/contest/6685/problem/3 / https://qoj.ac/problem/10506

给定 \(a_{1\cdots n}\)，和一个称，如下操作称为一次『称重』：

选中 \(a\) 的一个子集，输入给称。记它们的和为 \(s\)，那么称会返回 \(\min(k,\left\lfloor \dfrac sc \right\rfloor)\)，其中，\(c\) 为给定常数。

现在对于每个无序对 \((i,j)\)（\(i\ne j\)），你需要判断：

在已知 \(a\) 中除 \(a_i,a_j\) 外所有元素值，且 \(a_i,a_j\) 数值未知的前提下，是否可以通过若干次称重确定 \(a_i,a_j\) 的大小关系。

\(n,c\le 8000,k\le 10^5,1\le a_i&lt; kc\)。


显然，\(a_i\) 和 \(a_j\) 能区分，当且仅当 \(\left\lfloor\dfrac {a_i}c\right\rfloor\ne \left\lfloor\dfrac {a_j}c\right\rfloor\)，或者存在一个其他元素的子集 \(s\)，使得 \(\left\lfloor\dfrac {a_i+s}c\right\rfloor\ne \left\lfloor\dfrac {a_j + s}c\right\rfloor\)。
反过来，如果 \(a_i\) 和 \(a_j\) 不能区分，一个前提是 \(\left\lfloor\dfrac {a_i}c\right\rfloor =\left\lfloor\dfrac {a_j}c\right\rfloor\)。
下意识猜要排序，排序后打表发现使 \(i\) 不合法的 \(j\) 总是连续的。

证明

需要证：对于 \(x&lt;y&lt;z\)，若 \(x,y\) 不可区分，且 \(y,z\) 不可区分，那么 \(x,z\) 不可区分。
记 \(\left\lfloor\dfrac {x}c\right\rfloor=\left\lfloor\dfrac {y}c\right\rfloor=\left\lfloor\dfrac {z}c\right\rfloor=w\)，不存在 \(s\le c\cdot (k-w)\)，使得 \(y\) 可以进位但 \(x\) 不可，也不存在这样的 \(s\) 使得 \(z\) 可以进位但 \(y\) 不可。
合并不等式容易得到不存在这样的 \(x\) 使得 \(z\) 可以进位但 \(x\) 不可。
需要证：对于 \(x&lt;y&lt;z\)，若 \(x,y\) 可区分或 \(y,z\) 可区分，则 \(x,z\) 可区分。
调整法易得。


故发现只需要讨论相邻两个元素是否可区分。需要知道所有可能的子集和用于 check，可以用分治预处理『只有某相邻两个元素不选』时的前后缀背包数组（到达某个余数时需要的最小整倍数），就可以 \(O(nc\log n)\) 解决问题。
考虑在做什么：删点在 \([l,mid]\)，那么 \([mid+1,r]\) 的 DP 数组不会受到影响；删点在 \([mid + 1, r]\)，那么 \([l,mid]\) 的 DP 数组不会受到影响。背包的物品是无顺序的，所以有正确性。
也就是说大部分信息是可继承的。为什么题解管这个叫 CDQ？是因为普通分治总会被叫 CDQ 吗？
做一个类似 01 背包滚动数组的东西，维护每个点前 / 后可以凑出来的背包值，在最后下传到单点时统计答案即可。


相邻两个的处理略显烧脑，但意外地简洁。
&gt;= 不要写成除，不然会慢成唐诗
#include &lt;bits/stdc++.h&gt;
const int maxn = 8e3 + 5;
char nec(void) &#123;
    static char buf[1 &lt;&lt; 20], *p = buf, *e = buf;
    if (p == e) &#123;
        e = buf + fread(buf, 1, 1 &lt;&lt; 20, stdin);
        p = buf;
    &#125;
    return *p++;
&#125;
int read(void) &#123;
    auto x = 0ll;
    char t = nec();
    for (; t &lt; &#39;0&#39; || t &gt; &#39;9&#39;; t = nec());
    for (; t &gt;= &#39;0&#39; &amp;&amp; t &lt;= &#39;9&#39;; t = nec())
        x = x * 10 + t - &#39;0&#39;;
    return x;
&#125;
int ok[maxn], m, k;
std::pair&lt;int, int&gt; a[maxn];
void calc(int l, int r, const std::vector&lt;int&gt; f) &#123;
    if (l &gt; r)
        return;
    if (l == r) &#123;
        if (a[l].first == a[l + 1].first)
            ok[l] = 1;
        else if (a[l].first / m == a[l + 1].first / m)
            ok[l] = (*std::min_element(f.begin() + m - a[l + 1].first % m, f.begin() + m - a[l].first % m) + a[l].first / m &gt;= k);
        return;
    &#125;
    int mid = (l + r) &gt;&gt; 1;
    auto g = f;
    for (int i = mid + 2; i &lt;= r + 1; ++i) &#123;
        auto h = g;
        for (int j = 0, k; j &lt; m; ++j) &#123;
            k = (j + m - a[i].first % m) % m;
            h[j] = std::min(h[j], g[k] + a[i].first / m + (k + a[i].first % m &gt;= m));
        &#125;
        h.swap(g);
    &#125;
    calc(l, mid, g);
    g = f;
    for (int i = l; i &lt;= mid; ++i) &#123;
        auto h = g;
        for (int j = 0, k; j &lt; m; ++j) &#123;
            k = (j + m - a[i].first % m) % m;
            h[j] = std::min(h[j], g[k] + a[i].first / m + (k + a[i].first % m &gt;= m));
        &#125;
        h.swap(g);
    &#125;
    calc(mid + 1, r, g);
    return;
&#125;;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
    std::freopen(&quot;intcmp.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;intcmp.out&quot;, &quot;w&quot;, stdout);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n = read();
    m = read(), k = read();
    for (int i = 1; i &lt;= n; ++i)
        a[i].first = read(), a[i].second = i;
    std::sort(a + 1, a + n + 1);
    std::vector&lt;int&gt; f(m, 0x3f3f3f3f);
    f[0] = 0;
    calc(1, n - 1, f);
    std::vector&lt;int&gt; resL(n + 1), resR(n + 1);
    int now = 0;
    for (int i = 1; i &lt;= n; ++i) &#123;
        resR[a[i].second] = i - 1 - now;
        if (i != n &amp;&amp; ok[i])
            ++now;
        else
            now = 0;
    &#125;
    now = 0;
    for (int i = n; i; --i) &#123;
        resL[a[i].second] = n - i - now;
        if (ok[i - 1])
            ++now;
        else
            now = 0;
    &#125;
    for (int i = 1; i &lt;= n; ++i)
        printf(&quot;%d %d \n&quot;, resL[i], resR[i]);
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;


B. 字符串转换
https://www.becoder.com.cn/problem/52055

给定等长 01 串 \(S,T\)，维护 \(Q\) 次操作：

修改：Flip \(S\) 的某个字符。
修改：Flip \(T\) 的某个字符。

每次操作后，问 \(S\) 能否通过若干次下列操作变为 \(T\)：

选择 \(S\) 中的一个 00，变为 10。
选择 \(S\) 中的一个 11，变为 01。

\(|S|,Q\le 3\times 10^5\)。


连续 00 / 11 操作，考虑奇数位取反。取反之后发现原操作等价于 \(a_i\gets a_{i+1}\)。
这个操作只会使连续段的数量减少，故要求每一个后缀，\(S\) 的连续段个数不少于 \(T\) 的连续段个数，而且二者结尾相同。
线段树维护即可。


#include &lt;bits/stdc++.h&gt;
const int maxn = 3e5 + 5;
struct &#123; int l, r, mn, d; &#125; t[maxn &lt;&lt; 2];
#define lt (p &lt;&lt; 1)
#define rt (lt | 1)
void bld(int p, int l, int r) &#123;
    t[p].l = l, t[p].r = r;
    t[p].mn = t[p].d = 0;
    if (l == r)
        return;
    int mid = (l + r) &gt;&gt; 1;
    bld(lt, l, mid), bld(rt, mid + 1, r);
    return;
&#125;
void pushdown(int p) &#123;
    if (t[p].d) &#123;
        t[lt].mn += t[p].d, t[lt].d += t[p].d;
        t[rt].mn += t[p].d, t[rt].d += t[p].d;
        t[p].d = 0;
    &#125;
    return;
&#125;
void add(int p, int l, int r, int v) &#123;
    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r) &#123;
        t[p].mn += v, t[p].d += v;
        return;
    &#125;
    pushdown(p);
    int mid = (t[p].l + t[p].r) &gt;&gt; 1;
    if (l &lt;= mid)
        add(lt, l, r, v);
    if (r &gt; mid)
        add(rt, l, r, v);
    t[p].mn = std::min(t[lt].mn, t[rt].mn);
    return;
&#125;
#undef lt
#undef rt
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
    std::freopen(&quot;string.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;string.out&quot;, &quot;w&quot;, stdout);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int T;
    for (std::cin &gt;&gt; T; T--; ) &#123;
        int n, q;
        std::cin &gt;&gt; n &gt;&gt; q;
        std::vector&lt;int&gt; a(n + 1), b(n + 1);
        bld(1, 1, n);
        for (int i = 1; i &lt;= n; ++i) &#123;
            char t;
            std::cin &gt;&gt; t, a[i] = (t == &#39;B&#39;);
            if (i &amp; 1)
                a[i] ^= 1;
        &#125;
        for (int i = 1; i &lt;= n; ++i) &#123;
            char t;
            std::cin &gt;&gt; t, b[i] = (t == &#39;B&#39;);
            if (i &amp; 1)
                b[i] ^= 1;
        &#125;
        for (int i = 1; i &lt;= n; ++i) &#123;
            int v = 0;
            v += (i == n || a[i] != a[i + 1]);
            v -= (i == n || b[i] != b[i + 1]);
            if (v)
                add(1, 1, i, v);
        &#125;
        for (char op; q--; ) &#123;
            int i;
            std::cin &gt;&gt; op &gt;&gt; i;
            if (op == &#39;X&#39;) &#123;
                int v = 0, v1 = 0;
                v -= (i == n || a[i] != a[i + 1]);
                v1 -= (i != 1 &amp;&amp; a[i] != a[i - 1]);
                a[i] ^= 1;
                v += (i == n || a[i] != a[i + 1]);
                v1 += (i != 1 &amp;&amp; a[i] != a[i - 1]);
                if (v)
                    add(1, 1, i, v);
                if (v1)
                    add(1, 1, i - 1, v1);
            &#125;
            else &#123;
                int v = 0, v1 = 0;
                v += (i == n || b[i] != b[i + 1]);
                v1 += (i != 1 &amp;&amp; b[i] != b[i - 1]);
                b[i] ^= 1;
                v -= (i == n || b[i] != b[i + 1]);
                v1 -= (i != 1 &amp;&amp; b[i] != b[i - 1]);
                if (v)
                    add(1, 1, i, v);
                if (v1)
                    add(1, 1, i - 1, v1);
            &#125;
            std::cout &lt;&lt; ((a[n] == b[n] &amp;&amp; t[1].mn &gt;= 0) ? &quot;YES&quot; : &quot;NO&quot;) &lt;&lt; &#39;\n&#39;;
        &#125;
    &#125;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;


C. 监控
https://www.becoder.com.cn/problem/52057

给定 \(n\) 个怪，每个怪有 \(B_i\) 滴血，也就是说每个怪能被打 \(\le B_i\) 次。
要求每个怪必须被打 \(\ge A_i\) 次，并认为被打恰好 \(A_i\) 次时这个怪是好的。
对于每个 \(1\le x\le \sum B_i\)，求：在攻击次数只能为 \(x\) 的倍数的前提下，不好的怪的最小值。你只需要输出答案的和。
\(N\le 10^5,1\le A_i&lt; B_i\le 10^5\)。


记 \(c_i=B_i-A_i\)，把 \(c_i\) 降序排列，记 \(s=\sum A_i\)，那么一个 \(x\) 的答案为：
\[
\min\left\{i\mid{\left\lceil \frac{s}x \right\rceil\cdot x - s\ge c_i}\right\}
\]
容易想到整除分块，枚举 \(\left\lceil \dfrac{s}x \right\rceil\) 的值 \(k\)，那么相当于想要找到 \([L_i,R_i]\) 中的每个 \(x\)，\(x\cdot k-s\) 会落在哪个 \(c\) 的管辖范围里。
不妨记 \(c_i\) 的管辖范围为 \([cL_i,cR_i]\)，那么转化为 \(x\cdot k-s\in [cL_i,cR_i]\)，枚举 \(c\) 解不等式即可。
但发现一个严重的问题：外层整除分块复杂度是 \(\sqrt(s)\) 的，最劣 \(10^5\) 级别，很坏了。
发现枚举商数劣的原因是使 \(\left\lceil \dfrac{s}x \right\rceil\) 很大的 \(x\) 并不多，却占用了很多枚举次数
如果做经典的整除分块同样会发现到后期块内元素远远少于 \(n\)，却要花费 \(n\) 次操作来处理它们。所以对于这部分数我们直接朴素二分。
取阈值为 1500 即可。


#include &lt;bits/stdc++.h&gt;
const int B = 1500;
const long long inf = 1e18;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n;
    std::cin &gt;&gt; n;
    std::vector&lt;long long&gt; c(n + 1);
    auto sa = 0ll, sb = 0ll;
    for (int i = 1, a, b; i &lt;= n; ++i) &#123;
        std::cin &gt;&gt; a &gt;&gt; b;
        sa += a, sb += b, c[i] = b - a;
    &#125;
    std::sort(c.begin() + 1, c.end(), std::greater&lt;int&gt; ());
    std::partial_sum(c.begin() + 1, c.end(), c.begin() + 1);
    auto L = sb + 1;
    std::stack&lt;std::pair&lt;long long, int&gt; &gt; st;
    for (int k = 1; k &lt;= 1500; ++k) &#123;
        auto l = (sa + k - 1) / k, r = L - 1;
        if (l &gt; r)
            continue;
        L = l;
        st.emplace(r, n + 1);
        for (int i = n; ~i; --i)
            st.emplace(std::min(r, (c[i] + sa) / k), i);
    &#125;
    for (int i = L - 1; i; --i)
        st.emplace(i, std::lower_bound(c.begin(), c.end(), ((sa + i - 1) / i) * i - sa) - c.begin());
    auto res = 0ll;
    for (auto l = 1ll; !st.empty(); ) &#123;
        auto [r, v] = st.top();
        st.pop();
        if (l &gt; r)
            continue;
        if (v == n + 1)
            v = 0;
        res += (r - l + 1) * v;
        l = r + 1;
    &#125;
    std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;


G - Range Set Modifying Query
https://atcoder.jp/contests/abc430/tasks/abc430_g

发现开 60 个线段树非常合理
接着发现是 beats 板子题。看似需要三只 log，其实只有两只。
参见 abc426，最近 abc 都喜欢 beats 板子题吗？

]]></content>
      <tags>
        <tag>分治</tag>
        <tag>分块</tag>
        <tag>背包</tag>
      </tags>
  </entry>
  <entry>
    <title>学习笔记：CDQ 分治</title>
    <url>/20251029/</url>
    <content><![CDATA[日常不理解算法本质


周末给 afewdgre 讲题，偶遇简单时间轴问题，拼尽全力勉强战胜
何为时间轴

特点：单向。
前面的修改会影响后面的查询；反过来，后面的修改不会影响前面的查询。
在大部分 DS 题目中，顺序操作是满足这个条件的。考虑不存在明显操作时间轴的问题，通常处理方式是扫描线：即用坐标轴当时间轴，这样做的前提条件也是『前面的修改影响后面的查询，但后面的修改不影响前面的查询』。这里拿给 afewdgre 讲的矩形面积并举例。
矩形面积并中，把一段 \(x\) 坐标上，每个 \(y\) 上矩形存在的状态转化成『某个时刻，一段 \(y\) 是否被覆盖』，矩形的增删则用差分的方式维护。


CDQ 分治

在需求时间轴的需求上，额外要求：
修改之间无依赖，或者说，单次修改对询问的影响是可求的。
这样就可以分治。大部分分治的基本目标都是，使相同的计算不用被多次进行。
每层 CDQ 会统计每个 \([l,mid]\) 的修改对 \([mid+1,r]\) 询问的影响。

好像讲完了？
]]></content>
      <tags>
        <tag>CDQ 分治</tag>
      </tags>
  </entry>
  <entry>
    <title>杂题选谈：数数 &amp; 容斥</title>
    <url>/20251103/</url>
    <content><![CDATA[数数，但是性质题


A - Reversi 2
https://www.luogu.com.cn/problem/AT_arc189_a

操作可以看成，任选一个点，找到两侧最近的颜色相异的点，进行推平。
或，任选一个极长连续段，推平为其两端的颜色。
很容易注意到最终序列被分为若干个极长连续段，彼此独立。对于起始序列，容易发现任意区间中的任意操作会减少 2 的不同段数量（故显然最终序列连续段长度应该为奇数，且两端颜色和目标颜色一致）。
令 \(f_i\) 为长度为 \(i\) 的连续段被推平的方案数（\(i\bmod2=1\)），那么有 \(f_i=(i - 2)\times f_{i-2}\)。
最终方案数应为所有极长段方案的多重集排列乘上它们各自独立方案数之积。


#include &lt;bits/stdc++.h&gt;
const int mod = 998244353;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::syns_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n;
    std::cin &gt;&gt; n;
    std::vector&lt;int&gt; a(n + 1);
    std::vector&lt;long long&gt; f(n + 1), fac(n + 1), inv(n + 1);
    fac[0] = inv[0] = 1ll;
    for (int i = 1; i &lt;= n; ++i) &#123;
        std::cin &gt;&gt; a[i];
        fac[i] = fac[i - 1] * i % mod;
    &#125;
    auto qkp = [&amp;](long long x, int y) &#123;
        auto res = 1ll;
        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)
            if (y &amp; 1)
                (res *= x) %= mod;
        return res;
    &#125;;
    inv[n] = qkp(fac[n], mod - 2);
    for (int i = n - 1; i; --i)
        inv[i] = inv[i + 1] * (i + 1) % mod;
    f[1] = 1;
    for (int i = 3; i &lt;= n; i += 2)
        f[i] = f[i - 2] * (i - 2) % mod;
    auto res = 1ll;
    int L = 1, cnt = 0;
    for (int i = 1; i &lt;= n; ++i)
        if (i == n || a[i + 1] != a[i]) &#123;
            if (a[i] != i % 2 || (i - L + 1) % 2 == 0) &#123;
                std::cout &lt;&lt; 0 &lt;&lt; &#39;\n&#39;;
                return 0;
            &#125;
            (res *= f[i - L + 1]) %= mod;
            (res *= inv[(i - L) / 2]) %= mod;
            cnt += (i - L) / 2;
            L = i + 1;
        &#125;
    std::cout &lt;&lt; res * fac[cnt] % mod &lt;&lt; &#39;\n&#39;;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;


B - Cigar Box
https://www.luogu.com.cn/problem/AT_arc112_e

发现一个数的状态只取决于，最后一次以它为主体的操作，及这次操作之后的所有操作
进一步地发现，按最后一次操作分类，可以分为，向左（L）、向右（R）、没被操作过（M）三种类型。
可以很显然地注意到，最终序列一定是 LLLMMMRRR 的形式，其中，仅要求 M 是递增的；现在需要计算有多少长度为 \(m\) 的操作序列对应所有的 LMR 序列（如果认为所有的 M 始终是不动的可能会更好理解）。
发现同种类数间，『最后一次操作』的相对顺序是固定的。进一步会发现这其实是第二类斯特林数，最后答案为：

\[
\sum_{L,R}\binom{L+R}{L}\cdot \begin{Bmatrix}m\\ L+R\end{Bmatrix}\cdot 2^{m-L-R}
\]

#include &lt;bits/stdc++.h&gt;
const int mod = 998244353;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::syns_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, m;
    std::cin &gt;&gt; n &gt;&gt; m;
    using arr = std::vector&lt;long long&gt;;
    arr pw(m + 1), fac(m + 1), inv(m + 1);
    std::vector&lt;arr&gt; f(m + 1, arr(m + 1));
    std::vector&lt;int&gt; a(n + 1);
    std::vector&lt;std::vector&lt;int&gt; &gt; ok(n + 1, std::vector&lt;int&gt; (n + 1));
    for (int i = 1; i &lt;= n; ++i)
        std::cin &gt;&gt; a[i];
    for (int l = 1; l &lt;= n; ++l)
        for (int r = l; r &lt;= n; ++r)
            if (r == l || a[r] &gt; a[r - 1])
                ok[l][r] = 1;
            else
                break;
    f[1][1] = 1ll, pw[0] = fac[0] = inv[0] = 1ll;
    for (int i = 2; i &lt;= m; ++i)
        for (int j = 1; j &lt;= i; ++j)
            f[i][j] = (f[i - 1][j - 1] + f[i - 1][j] * j) % mod;
    for (int i = 1; i &lt;= m; ++i) &#123;
        pw[i] = pw[i - 1] * 2 % mod;
        fac[i] = fac[i - 1] * i % mod;
    &#125;
    auto qkp = [&amp;](long long x, int y) &#123;
        auto res = 1ll;
        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)
            if (y &amp; 1)
                (res *= x) %= mod;
        return res;
    &#125;;
    inv[m] = qkp(fac[m], mod - 2);
    for (int i = m - 1; i; --i)
        inv[i] = inv[i + 1] * (i + 1) % mod;
    auto C = [&amp;](int n, int m) &#123;
        return fac[n] * inv[m] % mod * inv[n - m] % mod;
    &#125;;
    auto res = 0ll;
    for (int L = 0; L &lt;= m &amp;&amp; L &lt;= n; ++L)
        for (int R = 0; L + R &lt;= m &amp;&amp; L + R &lt;= n; ++R)
            if (L + 1 &gt; n - R || ok[L + 1][n - R])
                res += C(L + R, L) * f[m][L + R] % mod * pw[m - L - R] % mod;
    std::cout &lt;&lt; res % mod &lt;&lt; &#39;\n&#39;;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;


C - Swap Characters
https://www.luogu.com.cn/problem/AT_arc168_c

考虑值域为 \(0\) 和 \(1\) 的情况
发现这个很唐 好险，AI 差点比我先做出来了，转化成枚举操作次数 \(i\)，答案是
\[
\sum_{i\le\min(s_0,s_1)}\binom{s_0}{i}\cdot\binom{s_1}{i}
\]
根据这个可以得到启发，发现所谓任意交换可以转化为，每个字母的支出和收入相等，故考虑画个表：


A - LEQ and NEQ / Non-equal Neighbours
https://www.luogu.com.cn/problem/AT_arc115_e / https://www.luogu.com.cn/problem/CF1591F / https://www.luogu.com.cn/problem/CF1585F

容斥，钦定有 \(i\) 对相同元素，那么答案为 \(\sum\limits_{i=0}^{n-1} (-1)^{n-1-i} \cdot g_i\)，其中 \(g_i\) 表示至少有 \(i\) 对相同元素的方案数。
考虑 \(g_i\) 的计算，朴素的做法是二维 DP，令 \(f_{i, j}\) 表示 DP 到 \(i\)，已经有了至多 \(j\) 对不同元素的方案数（发现这样才更好 DP）。发现没啥好的 \(O(n^2)\) 转移，只能 \(O(n^3)\)：
\[
f_{i,j}=\sum_{k&lt;i}f_{k, j-1}\times \min\{A_{k+1\cdots i}\}
\]
一个适用于容斥 DP 的 nb 优化：发现系数只取决于 \(j\) 维的奇偶性，发现转移也只关注奇偶性，故设 \(f_{i,0/1}\) 减少一维。
同时，很显然存在一个单调栈优化的结构，这样就可以在 \(O(n)\) 内完成 DP。


#include &lt;bits/stdc++.h&gt;
const int mod = 998244353;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n;
    std::cin &gt;&gt; n;
    std::vector&lt;int&gt; a(n + 1);
    for (int i = 1; i &lt;= n; ++i)
        std::cin &gt;&gt; a[i];
    struct node &#123; int mn; long long c0, c1; &#125;;
    std::stack&lt;node&gt; st;
    std::vector&lt;std::array&lt;long long, 2&gt; &gt; f(n + 1);
    f[0][0] = 1ll, f[0][1] = 0ll;
    auto s0 = 0x3f3f3f3fll, s1 = 0ll;
    st.push(&#123; 0x3f3f3f3f, 1ll, 0ll &#125;);
    for (int i = 1; i &lt;= n; ++i) &#123;
        auto p0 = 0ll, p1 = 0ll;
        for (; !st.empty(); ) &#123;
            auto [mn, c0, c1] = st.top();
            if (mn &lt;= a[i])
                break;
            st.pop();
            p0 += c0, p1 += c1;
            (s0 += mod - c0 * (mn - a[i]) % mod) %= mod;
            (s1 += mod - c1 * (mn - a[i]) % mod) %= mod;
        &#125;
        st.push(&#123; a[i], p0 % mod, p1 % mod &#125;);
        f[i][0] = s1, f[i][1] = s0;
        (s0 += f[i][0] * 0x3f3f3f3f % mod) %= mod;
        (s1 += f[i][1] * 0x3f3f3f3f % mod) %= mod;
        st.push(&#123; 0x3f3f3f3f, f[i][0], f[i][1] &#125;);
    &#125;
    std::cout &lt;&lt; (f[n][n &amp; 1] + mod - f[n][(n &amp; 1) ^ 1]) % mod &lt;&lt; &#39;\n&#39;;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;


B - Unbranched
https://www.luogu.com.cn/problem/AT_abc180_f

注意到只会有环和链两种情况。发现消耗的点数和边数是不同的，再加上题目有边数限制，令 \(f_{i,j}\) 表示消耗了 \(i\) 个点 \(j\) 条边时的方案数。
转移是显然的：
对于环的情况，答案为圆排列去掉翻折，即 \(\dfrac {(k-1)!}2\)。特别地，二元环的圆排列不存在翻折，故答案为 \(1\)。
对于链的情况，去掉翻折即可，答案为 \(\dfrac {k!}2\)。
去重，参考典型的图计数问题，钦定没被选的点中，标号最小的必须被选，所以会有 \(C(n-(i-k)-1,k-1)\) 的系数。
显然对于最大值恰好为 \(L\) 的限制可以直接记一个 bool 量在状态里；尊重一下容斥的标题，用 \(L\) 的答案减去 \(L-1\) 的答案亦可。


#include &lt;bits/stdc++.h&gt;
const int mod = 1e9 + 7;
const int inv2 = (mod + 1) &gt;&gt; 1;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, m, L;
    std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; L;
    using arr = std::vector&lt;long long&gt;;
    using brr = std::vector&lt;arr&gt;;
    using crr = std::vector&lt;brr&gt;;
    arr fac(n + 1);
    brr C(n + 1, arr(n + 1));
    fac[0] = 1ll, C[0][0] = 1ll;
    for (int i = 1; i &lt;= n; ++i) &#123;
        C[i][0] = 1ll;
        fac[i] = fac[i - 1] * i % mod;
        for (int j = 1; j &lt;= i; ++j)
            C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % mod;
    &#125;
    crr f(n + 1, brr(m + 1, arr(2)));
    f[0][0][0] = 1ll;
    auto work = [&amp;](int i, int j, int k, int p1, int p2) &#123;
        if (k == 1)
            f[i][j][p2] += f[i - 1][j][p1];
        else if (k == 2) &#123;
            if (j &gt;= 2)
                f[i][j][p2] += f[i - 2][j - 2][p1] * C[n - (i - k) - 1][k - 1] % mod; 
            if (j &gt;= 1)
                f[i][j][p2] += f[i - 2][j - 1][p1] * C[n - (i - k) - 1][k - 1] % mod;
        &#125;
        else &#123;
            if (j &gt;= k)
                f[i][j][p2] += f[i - k][j - k][p1] * C[n - (i - k) - 1][k - 1] % mod * fac[k - 1] % mod * inv2 % mod;
            if (j &gt;= k - 1)
                f[i][j][p2] += f[i - k][j - k + 1][p1] * C[n - (i - k) - 1][k - 1] % mod * fac[k] % mod * inv2 % mod;
        &#125;
        return;
    &#125;;
    for (int i = 1; i &lt;= n; ++i)
        for (int j = 0; j &lt;= m; ++j) &#123;
            for (int k = 1; k &lt;= i &amp;&amp; k &lt;= L; ++k)
                if (k == L)
                    work(i, j, k, 0, 1), work(i, j, k, 1, 1);
                else
                    work(i, j, k, 0, 0), work(i, j, k, 1, 1);
            f[i][j][0] %= mod, f[i][j][1] %= mod;
        &#125;
    std::cout &lt;&lt; f[n][m][1] &lt;&lt; &#39;\n&#39;;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;


C - 局部极小值
https://www.luogu.com.cn/problem/P3160

重要性质：一个合法棋盘，X 的数量不会超过八个，故一个想法是只考虑 X 填的数，进而想到容斥
钦定至少有某些位置是 X 进行容斥，结合上面的性质发现空棋盘上的合法超集共 1000 多个，故可做，考虑单步钦定状态下的答案。
令 \(f_{i,S}\) 表示填了 \(j\) 个数，目前 X 集合已经填完了 \(S\) 内元素的方案数。


A - 数列
https://www.luogu.com.cn/problem/P7961

发现比较合理的 DP 方式是，令 \(f_{i,j,k,l}\) 表示当前正在 DP \(i\) 这个值，已经填了 \(j\) 个数，\(2^i\) 的个数，加上『进位』上来的，一共有 \(k\) 个，\(2^0\sim 2^i\) 总共有 \(l\) 个 1 的答案。那么有：
\[
f_{i+1,j+c,\left\lfloor\frac k2\right\rfloor+c,l+\left(\left\lfloor\frac k2\right\rfloor+c\right)\bmod 2}\gets f_{i,j,k,l}\times {v_{i + 1}}^c\times (c!)^{-1}
\]
其中 \((c!)^{-1}\) 为多重集排列。最后乘上 \(n!\) 即可。
最后若 \(l+\text{ctz}\left(\left\lfloor\frac k2\right\rfloor\right)\le K\) 即可统计 \(f_{m,n,k,l}\) 的贡献。
注意到 \(k\) 维始终不超过 \(n\)，故复杂度 \(O(mn^3K)\)，非常可过。


#include &lt;bits/stdc++.h&gt;
const int mod = 998244353;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, m, s;
    std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; s;
    using arr = std::vector&lt;long long&gt;;
    using brr = std::vector&lt;arr&gt;;
    brr v(m + 1, arr(n + 1));
    for (int i = 0; i &lt;= m; ++i) &#123;
        v[i][0] = 1ll;
        std::cin &gt;&gt; v[i][1];
        for (int j = 2; j &lt;= n; ++j)
            v[i][j] = v[i][j - 1] * v[i][1] % mod;
    &#125;
    arr inv(n + 1);
    inv[0] = 1ll;
    auto fac = 1ll;
    auto qkp = [&amp;](long long x, int y) &#123;
        auto res = 1ll;
        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)
            if (y &amp; 1)
                (res *= x) %= mod;
        return res;
    &#125;;
    for (int i = 1; i &lt;= n; ++i) &#123;
        (fac *= i) %= mod;
        inv[i] = qkp(fac, mod - 2);
    &#125;
    using crr = std::vector&lt;brr&gt;;
    std::vector&lt;crr&gt; f(m + 1, crr(n + 1, brr(n + 1, arr(s + 1))));
    for (int i = 0; i &lt;= n; ++i)
        f[0][i][i][i &amp; 1] = v[0][i] * inv[i] % mod;
    for (int i = 0; i &lt; m; ++i)
      for (int j = 0; j &lt;= n; ++j)
        for (int k = 0; k &lt;= n; ++k)
          for (int l = 0; l &lt;= s; ++l) &#123;
            f[i][j][k][l] %= mod;
            for (int c = 0; j + c &lt;= n &amp;&amp; k / 2 + c &lt;= n &amp;&amp; l + (k / 2 + c) % 2 &lt;= s; ++c)
                f[i + 1][j + c][k / 2 + c][l + (k / 2 + c) % 2] += f[i][j][k][l] * v[i + 1][c] % mod * inv[c] % mod;
          &#125;
    auto res = 0ll;
    for (int k = 0; k &lt;= n; ++k)
        for (int l = 0; l &lt;= s; ++l)
            if (l + __builtin_popcount(k / 2) &lt;= s)
                res += f[m][n][k][l] % mod;
    std::cout &lt;&lt; res % mod * fac % mod &lt;&lt; &#39;\n&#39;;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;


B - Vasya and Array
https://www.luogu.com.cn/problem/CF1093F

发现正着做避免不了记录相同段长度，所以考虑反过来容斥。
会发现这是一个类似于两双手的容斥结构。两双手还在输出
令 \(f_{i,j}\) 表示前 \(i\) 个均合法，且第 \(i\) 个元素为 \(j\) 的方案数，考虑什么时候会出现『前 \(i-1\) 个元素合法，到了第 \(i\) 个非法』的情况
发现即当前 \(i\) 前面有 \(len-1\) 个相同元素，且第 \(i\) 个成为第 \(len\) 个相同元素的情况。
显然有转移：
\[
f_{i,j}\gets \left(\sum_l f_{i-1,l}\right)-\left(\sum_{l\ne j} f_{i-len,l}\right)\times [a_{i-len+1\cdots i} = j\text{ is available}]
\]
记录一下 \(s_i=\sum\limits_{j}f_{i,j}\) 的值即可做到 \(O(nk)\)。


#include &lt;bits/stdc++.h&gt;
const int mod = 998244353;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, k, L;
    std::cin &gt;&gt; n &gt;&gt; k &gt;&gt; L;
    std::vector&lt;int&gt; a(n + 1);
    std::vector&lt;std::vector&lt;int&gt; &gt; cnt(n + 1, std::vector&lt;int&gt; (k + 1));
    for (int i = 1; i &lt;= n; ++i) &#123;
        std::cin &gt;&gt; a[i];
        for (int j = 1; j &lt;= k; ++j)
            cnt[i][j] = cnt[i - 1][j] + (a[i] == j);
        cnt[i][0] = cnt[i - 1][0] + (a[i] == -1);
    &#125;
    using arr = std::vector&lt;long long&gt;;
    using brr = std::vector&lt;arr&gt;;
    arr s(n + 1);
    brr f(n + 1, arr(k + 1));
    s[0] = 1ll;
    for (int i = 1; i &lt;= n; ++i)
        for (int j = 1; j &lt;= k; ++j)
            if (a[i] == -1 || a[i] == j) &#123;
                f[i][j] = s[i - 1];
                if (i &gt;= L &amp;&amp; (cnt[i][j] - cnt[i - L][j]) + (cnt[i][0] - cnt[i - L][0]) == L) &#123;
                    f[i][j] += mod - (s[i - L] - f[i - L][j]);
                    if (s[i - L] &lt; f[i - L][j])
                        f[i][j] -= mod;
                    if (f[i][j] &gt;= mod)
                        f[i][j] -= mod;
                &#125;
                s[i] += f[i][j];
                if (s[i] &gt;= mod)
                    s[i] -= mod;
            &#125;
    std::cout &lt;&lt; s[n] &lt;&lt; &#39;\n&#39;;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;


C - Road of the King
https://www.luogu.com.cn/problem/AT_codefestival_2016_final_f

发现最后的图是强连通的，当且仅当所有点都能走到 1。
最开始转化成『所有点都能通过操作序列走到 1』，错麻了 /qd
令 \(f_{i,j,k}\) 表示前 \(i\) 步，已经使得 \(j\) 个点能走到 1，当前已经访问过了 \(k\) 个不能走到 \(1\) 的点。
如果再次访问 \(j\) 个点中的其中一个，那么这 \(k\) 个点就能走到 1。转移是容易的。


#include &lt;bits/stdc++.h&gt;
const int mod = 1e9 + 7;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, m;
    std::cin &gt;&gt; n &gt;&gt; m;
    using arr = std::vector&lt;long long&gt;;
    using brr = std::vector&lt;arr&gt;;
    std::vector&lt;brr&gt; f(m + 1, brr(n + 1, arr(n + 1)));
    f[0][1][0] = 1ll;
    for (int i = 0; i &lt; m; ++i)
        for (int j = 1; j &lt;= n; ++j) &#123;
            for (int k = 0; k + j &lt;= n &amp;&amp; k + j &lt;= i + 1; ++k) &#123;
                f[i][j][k] %= mod;
                f[i + 1][j][k] += f[i][j][k] * k % mod;
                f[i + 1][j + k][0] += f[i][j][k] * j % mod;
                if (j + k != n)
                    f[i + 1][j][k + 1] += f[i][j][k] * (n - j - k) % mod;
            &#125;
        &#125;
    std::cout &lt;&lt; f[m][n][0] % mod &lt;&lt; &#39;\n&#39;;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;


D - チーム分け
https://www.luogu.com.cn/problem/AT_mujin_pc_2018_f

很容易得到一个 \(O(n^3)\) 的做法：给 \(a\) 排序，从大到小选每个组的『限制者』。
\(f_{i,j}\) 表示选到 \(i\)，还剩 \(j\) 个 \(\ge a_i\) 的人没有分组，则：
\[
f_{i-1,j+1-k}\gets f_{i,j}\quad(1\le k\le a_i)\\
f_{i-1,j+1}\gets f_{i,j}
\]
后面这个优化还是很难想的…… 主要是要注意到，可以不必在某个 \(a_i\) 处钦定其为『限制者』；而是在某个 \(i\) 处，给『未分组』的人分大小为 \(i\) 的组，而不关心具体谁是限制者，甚至不关心限制者的 \(a\) 值。
记 \(c_i\) 表示 \(i\) 处有几个 \(a\)，做多重集组合。仍然记录未分组人数 \(j\)，那么一个固定的 \(j\) 能贡献的大小为 \(i\) 的组满足调和级数，枚举组数 \(k\)，有：
\[
f_{i-1,j+c_i-k\cdot i}\gets f_{i+1,j}\times \binom{j+c_i}{i\cdot k}\times \frac{(i\cdot k)!}{(i!)^k\times k!}\quad\left(k\le \frac{j+c_i}i\right)
\]
一定要注意分母里的 \(k!\) 的含义（消序）！组是无序的。
复杂度 \(O(n^2\log n)\)。


#include &lt;bits/stdc++.h&gt;
const int mod = 998244353;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n;
    std::cin &gt;&gt; n;
    std::vector&lt;int&gt; c(n + 1);
    for (int i = 1, x; i &lt;= n; ++i)
        std::cin &gt;&gt; x, ++c[x];
    using arr = std::vector&lt;long long&gt;;
    using brr = std::vector&lt;arr&gt;;
    brr C(n + 1, arr(n + 1));
    C[0][0] = 1ll;
    for (int i = 1; i &lt;= n; ++i) &#123;
        C[i][0] = 1ll;
        for (int j = 1; j &lt;= i; ++j)
            C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % mod;
    &#125;
    arr fac(n + 1);
    fac[0] = 1ll;
    for (int i = 1; i &lt;= n; ++i)
        fac[i] = fac[i - 1] * i % mod;
    auto qkp = [&amp;](long long x, int y) &#123;
        auto res = 1ll;
        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)
            if (y &amp; 1)
                (res *= x) %= mod;
        return res;
    &#125;;
    brr pw(n + 1, arr(n + 1));
    for (int i = 0; i &lt;= n; ++i) &#123;
        pw[i][0] = 1ll, pw[i][1] = qkp(fac[i], mod - 2);
        for (int j = 2; j &lt;= n; ++j)
            pw[i][j] = pw[i][j - 1] * pw[i][1] % mod;
    &#125;
    brr f(n + 2, arr(n + 1));
    f[n + 1][0] = 1ll;
    for (int i = n; i; --i)
        for (int j = 0; j + c[i] &lt;= n; ++j)
            for (int k = 0, l = (j + c[i]) / i; k &lt;= l; ++k)
                (f[i][j + c[i] - k * i] += f[i + 1][j] * C[j + c[i]][i * k] % mod * fac[i * k] % mod * pw[i][k] % mod * pw[k][1] % mod) %= mod;
    std::cout &lt;&lt; f[1][0] &lt;&lt; &#39;\n&#39;;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;


E - Random Isolation
https://www.luogu.com.cn/problem/AT_arc165_e

发现期望可以拆贡献，每个局面下，每个大小 \(&gt;K\) 的连通块恰好贡献 1 次操作次数。
这里提一下，一开始有这样的想法：每个存在 \(&gt;K\) 连通块的局面都可以操作 1 次，所以一个局面有 1 的贡献；这是否和上面得到的结论矛盾？
答案是，统计局面的方案数权值和连通块的方案数权值是不一样的，但总和是一样的。且局面没什么好的统计方法，故统计连通块。
令 \(f_{x,i,j}\) 表示 \(x\) 为根，子树内选了大小为 \(i\) 的连通块，一共需要删除 \(j\) 个点。那么相当于要求这 \(j\) 个点的删除时间早于 \(i\) 内所有点。树上背包统计方案数，每个点处计算权值与贡献即可。
最后算权值的时候，把操作序列看成后几项无效的排列，那么要求这 \(j\) 个点的操作序列需要在所有 \(i\) 个点的前面
可以猜到一个答案：\(\dfrac {i!\times j!}{(i+j)!}\)。
但仔细想来并站不住脚：每个连通块的后几项在实际操作序列里是不存在的，整个操作序列的长短甚至都是未知的，好像没什么道理。
问了一圈没人说出来个靠谱的证明。算了。


#include &lt;bits/stdc++.h&gt;
const int mod = 998244353;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, k;
    std::cin &gt;&gt; n &gt;&gt; k;
    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);
    for (int i = 1, x, y; i &lt; n; ++i) &#123;
        std::cin &gt;&gt; x &gt;&gt; y;
        g[x].push_back(y), g[y].push_back(x);
    &#125;
    using arr = std::vector&lt;long long&gt;;
    using brr = std::vector&lt;arr&gt;;
    brr C(n + 1, arr(n + 1));
    for (int i = 0; i &lt;= n; ++i) &#123;
        C[i][0] = 1ll;
        for (int j = 1; j &lt;= i; ++j)
            C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % mod;
    &#125;
    auto qkp = [&amp;](long long x, int y) &#123;
        auto res = 1ll;
        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)
            if (y &amp; 1)
                (res *= x) %= mod;
        return res;
    &#125;;
    arr fac(n + 1), inv(n + 1);
    fac[0] = inv[0] = 1ll;
    for (int i = 1; i &lt;= n; ++i) &#123;
        fac[i] = fac[i - 1] * i % mod;
        inv[i] = qkp(fac[i], mod - 2);
    &#125;
    std::vector&lt;int&gt; siz(n + 1);
    brr h(n + 1, arr(n + 1));
    std::vector&lt;brr&gt; f(n + 1, brr(n + 1, arr(n + 1)));
    auto res = 0ll;
    std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int fa) &#123;
        f[x][1][(int)g[x].size()] = 1ll;
        siz[x] = 1;
        for (auto i : g[x])
            if (i != fa) &#123;
                DFS(i, x);
                h = f[x];
                for (int j = siz[x]; j; --j)
                  for (int a = 0; a &lt; n; ++a)
                    if (f[x][j][a + 1])
                      for (int k = siz[i]; ~k; --k)
                        for (int b = 0; a + b &lt; n; ++b)
                          f[x][j + k][a + b] += h[j][a + 1] * f[i][k][b + 1] % mod;
                siz[x] += siz[i];
            &#125;
        for (int i = 1; i &lt;= siz[x]; ++i)
            for (int j = 0; j &lt;= n; ++j)
                f[x][i][j] %= mod;
        for (int i = k + 1; i &lt;= siz[x]; ++i)
            for (int j = 0; i + j &lt;= n; ++j)
                res += f[x][i][j] * fac[i] % mod * fac[j] % mod * inv[i + j] % mod;
        res %= mod;
        return;
    &#125;;
    DFS(1, -1);
    std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;


A - 染色问题
https://www.luogu.com.cn/problem/P6076

题述转化成：恰好 \(n\) 行，恰好 \(m\) 列，恰好 \(c\) 种颜色即可容斥
将无色视为一个不参与容斥的颜色，容易写出答案式：
\[
\sum_{i=0}^{n}\sum_{j=0}^{m}\sum_{k=0}^{c} (-1)^{i+j+k}\times \binom ni\times \binom mj\times \binom ck\times (c-k+1)^{(n-i)(m-j)}
\]
预处理幂次即可。复杂度 \(O(nmc)\)。


#include &lt;bits/stdc++.h&gt;
const int mod = 1e9 + 7;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, m, c;
    std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; c;
    std::vector&lt;long long&gt; fac(n * m + 1), inv(n * m + 1);
    fac[0] = inv[0] = 1ll;
    for (int i = 1; i &lt;= n * m; ++i)
        fac[i] = fac[i - 1] * i % mod;
    auto qkp = [&amp;](long long x, int y) &#123;
        auto res = 1ll;
        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)
            if (y &amp; 1)
                (res *= x) %= mod;
        return res;
    &#125;;
    inv[n * m] = qkp(fac[n * m], mod - 2);
    for (int i = n * m - 1; i; --i)
        inv[i] = inv[i + 1] * (i + 1) % mod;
    auto C = [&amp;](int n, int m) &#123;
        if (n &lt; m || m &lt; 0)
            return 0ll;
        return fac[n] * inv[m] % mod * inv[n - m] % mod;
    &#125;;
    std::vector&lt;std::vector&lt;long long&gt; &gt; pw(c + 2, std::vector&lt;long long&gt; (n * m + 1));
    for (int i = 1; i &lt;= c + 1; ++i) &#123;
        pw[i][0] = 1ll;
        for (int j = 1; j &lt;= n * m; ++j)
            pw[i][j] = pw[i][j - 1] * i % mod;
    &#125;
    auto res = 0ll;
    for (int i = 0; i &lt;= n; ++i)
        for (int j = 0; j &lt;= m; ++j)
            for (int k = 0; k &lt;= c; ++k) &#123;
                int op = ((i + j + k) &amp; 1) ? mod - 1 : 1;
                res += op * C(n, i) % mod * C(m, j) % mod * C(c, k) % mod * pw[c - k + 1][(n - i) * (m - j)] % mod;
            &#125;
    std::cout &lt;&lt; res % mod &lt;&lt; &#39;\n&#39;;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;


B - Painting The Wall
https://www.luogu.com.cn/problem/CF398B

观察到初始被标记的行列之间等价，相似地，初始未被标记的行列之间等价。故可以粗暴地塞到状态里。
参照 Game with Probability Problem 中解决自转移的思路，考虑解方程。
设 \(f_{i,j}\) 表示剩余 \(i\) 行 \(j\) 列时的期望操作数，列出 DP 式：
\[
f_{i,j}
\]

]]></content>
      <tags>
        <tag>计数</tag>
        <tag>容斥</tag>
        <tag>二项式反演</tag>
      </tags>
  </entry>
  <entry>
    <title>杂题选谈</title>
    <url>/20251104/</url>
    <content><![CDATA[这么爱计数


A. 图 / HDU4903 The only survival
https://vjudge.net/problem/HDU-4903#author=DeepSeek_zh

很容易想到基于按 dis 从小到大枚举的做法
但是发现算方案就必须要知道每个点的具体 dis，就导致难以 DP，只能搜索，这样复杂度就不太好看。
一个显然的观察：并不关心 \(1,n\) 以外点的标号，所以可以把 \(O(n^k)\) 的暴搜优化到 \(O(\binom{n+k}k\cdot (n+k))\)，然后做多重集排列即可。
模数非质时的多重集排列：link


#include &lt;bits/stdc++.h&gt;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
    std::freopen(&quot;graph.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;graph.out&quot;, &quot;w&quot;, stdout);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, k, L, mod;
    std::cin &gt;&gt; n &gt;&gt; k &gt;&gt; L &gt;&gt; mod;
    if (L &lt; k) &#123;
        std::cout &lt;&lt; 0 &lt;&lt; &#39;\n&#39;;
        return 0;
    &#125;
    std::vector&lt;std::vector&lt;long long&gt; &gt; C(n + 1, std::vector&lt;long long&gt; (n + 1));
    C[0][0] = 1ll;
    for (int i = 1; i &lt;= n; ++i) &#123;
        C[i][0] = 1ll;
        for (int j = 1; j &lt;= i; ++j)
            C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % mod;
    &#125;
    std::vector&lt;int&gt; dis(n + 1), s;
    int res = 0;
    std::function&lt;void(int, int, long long)&gt; DFS = [&amp;](int x, int d, long long now) &#123;
        if (x == n) &#123;
            auto s0 = now, s1 = now;
            for (int i = 1; i &lt; n; ++i)
                if (dis[i] &gt;= k)
                    (s0 *= L) %= mod, (s1 *= L) %= mod;
                else if (L - (k - dis[i] - 1)) &#123;
                    (s0 *= L - (k - dis[i] - 1)) %= mod;
                    (s1 *= L - (k - dis[i] - 1) - 1) %= mod;
                &#125;
                else &#123;
                    s0 = s1 = 0ll;
                    break;
                &#125;
            dis[x] = k;
            auto u = 1ll;
            int cnt = n - 2;
            for (auto i : s)
                (u *= C[cnt][i]) %= mod, cnt -= i;
            (res += u * (s0 + mod - s1) % mod) %= mod;
            return;
        &#125;
        for (int i = d; i &lt;= k + 1; ++i) &#123;
            auto s0 = now, s1 = now;
            for (int j = 1; j &lt; x; ++j)
                if (dis[j] &gt;= i)
                    (s0 *= L) %= mod, (s1 *= L) %= mod;
                else if (L - (i - dis[j] - 1)) &#123;
                    (s0 *= L - (i - dis[j] - 1)) %= mod;
                    (s1 *= L - (i - dis[j] - 1) - 1) %= mod;
                &#125;
                else &#123;
                    s0 = s1 = 0ll;
                    break;
                &#125;
            dis[x] = i;
            if (dis[x] != dis[x - 1])
                s.push_back(1);
            else
                ++s.back();
            if (i == k + 1)
                s1 = 0ll;
            DFS(x + 1, i, (s0 + mod - s1) % mod);
            if (dis[x] != dis[x - 1])
                s.pop_back();
            else
                --s.back();
        &#125;
        return;
    &#125;;
    DFS(2, 1, 1);
    std::cout &lt;&lt; res % mod &lt;&lt; &#39;\n&#39;;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;


B. 路线 / ARC136E Non-coprime DAG
https://www.luogu.com.cn/problem/AT_arc136_e

做过 CF870F Paths 可以很快反应过来：\(x\) 和 \(y\) 是否可以同时被选，取决于它们各自的最小质因子是否能在 \(x,y\) 之间交汇（或用 \(2\) 作跳板）。
接着就发现由于 \(2\) 间隔出现，此时再分奇偶性就会显得非常合理。
两个偶数总是不能同时被选；对于奇数 \(x\) 和偶数 \(y\)，要求 \(y\in [x-f(x)+1,x+f(x)-1]\)。
考察奇数的选取。容易发现，钦定用 \(2\) 作跳板，则两个奇数 \(x,y(x&lt;y)\) 能同时被选，当且仅当：

记 \(f(i)\) 为 \(i\) 的最小质因子，则 \(x+f(x)&gt; y-f(y)\)。

发现实际上可以认为 \(x\) 代表区间 \([x-f(x),x+f(x)-1]\)。那么两个点可以同时被选当且仅当它们代表的区间有交（这样就去掉了 \(x,y\) 之间的偏序条件）
这样发现对『代表区间』的定义，在奇数视角和偶数视角下是冲突的，可以发现偶数视角的区间更紧；事实上，应该采用 \([x-f(x)+1,x+f(x)-1]\) 这个看似充分不必要的定义，因为端点总是奇数，导致 \(x+f(x)&gt; y-f(y)\) 和 \(x+f(x)-1&lt;y-f(y)+1\) 不能同时成立。
进一步推广结论，容易发现多个奇数可以同时被选，当且仅当它们代表的区间有交。故可以枚举值域中的点，找加权覆盖次数最大值。


#include &lt;bits/stdc++.h&gt;
using namespace std;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n;
    std::cin &gt;&gt; n;
    std::vector&lt;int&gt; fac(n + 1), l(n + 1), r(n + 1);
    for (int i = 2; i &lt;= n; ++i) &#123;
        if (!fac[i]) &#123;
            fac[i] = i;
            for (int j = 2 * i; j &lt;= n; j += i)
                if (!fac[j])
                   fac[j] = i;
        &#125;
        l[i] = std::max(1, i - fac[i] + 1);
        r[i] = std::min(i + fac[i] - 1, n);
    &#125;
    std::vector&lt;int&gt; a(n + 1);
    std::vector&lt;long long&gt; dif(n + 1);
    for (int i = 1; i &lt;= n; ++i) &#123;
        std::cin &gt;&gt; a[i];
        if (i == 1 || i % 2 == 0)
            continue;
        dif[l[i]] += a[i];
        if (r[i] != n)
            dif[r[i] + 1] -= a[i];
    &#125;
    auto res = 0ll;
    std::partial_sum(dif.begin(), dif.end(), dif.begin());
    for (int i = 1; i &lt;= n; ++i) &#123;
        auto now = a[1] + dif[i];
        if (i % 2 == 0)
            now += a[i];
        res = std::max(res, now);
    &#125;
    std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;


A. 列车扫除
https://www.becoder.com.cn/contest/6708/problem/1

绝对聪明的 A, B, C 在一起玩 Nim，有三堆石子 \(c_{1,2,3}\)，每次可以任选一堆拿走正整数个，不能拿的人扣一分，他的上一个人加一分。
给定 \(q\) 次询问，形如：

现在知道 \(\forall \, i=1,2,3,c_i\in[l_i,r_i]\)。对于这 \(\prod_{i=1,2,3}r_i-l_i+1\) 种可能的情况，对于每个人，求出分数之和。

\(q\le 10^6,V=10^9\)。


容易发现，胜，平，负三个状态会被分给三个人，且一共只有三种分配方式。
当只剩一堆石头时，操作者胜；石头状态为 \((0,1,1)\) 时，操作者负。


B. 换来换去
https://www.becoder.com.cn/contest/6708/problem/2

对 \(n\) 个有标号的球任意分成任意组，组是无顺序的，且要求每组球个数 \(\ge 2\)，求方案数，对质数取模。
\(n\le 10^7\)。


发现这是一个类斯特林数的问题，二项式反演得到答案式为：
\[
\sum_{i=0}^n (-1)^{n-i}\binom ni \sum_{j=0}^i \begin{Bmatrix} i\\ j\end{Bmatrix}
\]
用斯特林数通项展开：
\[
\sum_{i=0}^n (-1)^{n-i}\binom ni \sum_{j=0}^i \sum_{k=0}^j(-1)^{j-k}\dfrac {k^i}{(j-k)!\cdot k!}
\]
很容易注意到一个二项式定理的结构，故交换求和顺序：
\[
\sum_{j=0}^n \sum_{k=0}^j \dfrac {(-1)^{j-k}}{(j-k)!\cdot k!}\cdot \sum_{i=j}^n \binom ni (-1)^{n-i}k^i
\]
发现一个很严重的问题在于 \(i\) 的起始范围是 \(j\) 而不是 \(0\)，但如果我们把一开始的式子改写成这样：
\[
\sum_{i=0}^n (-1)^{n-i}\binom ni \sum_{j=0}^n \begin{Bmatrix} i\\ j\end{Bmatrix}
\]
容易发现当 \(j&gt;i\) 时 \(\begin{Bmatrix} i\\ j\end{Bmatrix}=0\)，和原式的值相同，且斯特林数通项对于 \(j&gt;i\) 也是成立的，故原式等价于
\[
\begin{aligned}
&amp;\sum_{j=0}^n \sum_{k=0}^j \dfrac {(-1)^{j-k}}{(j-k)!\cdot k!}\cdot \sum_{i=0}^n \binom ni (-1)^{n-i}k^i\\
=&amp;\sum_{j=0}^n \sum_{k=0}^j \dfrac {(-1)^{j-k}}{(j-k)!\cdot k!}\cdot (k-1)^n\\
=&amp;\sum_{k=0}^n \dfrac {(k-1)^n}{k!}\cdot \sum_{j=0}^{n-k} \dfrac {(-1)^j}{j!}\\
\end{aligned}
\]
后者内部与 \(k\) 无关，是可前缀和计算的，只需要考虑在 \(O(1)\) 内求出 \((k-1)^n\) 的值，筛一下，对于质数（约 \(\dfrac n{\ln n}\) 个）快速幂，合数用积性函数之类即可。


#include &lt;bits/stdc++.h&gt;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
    std::freopen(&quot;card.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;card.out&quot;, &quot;w&quot;, stdout);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int T;
    for (std::cin &gt;&gt; T; T--; ) &#123;
        int n, mod;
        std::cin &gt;&gt; n &gt;&gt; mod;
        std::vector&lt;int&gt; tag(n + 1), p, pw(n + 1);
        auto qkp = [&amp;](long long x, int y) &#123;
            auto res = 1ll;
            for (; y; (x *= x) %= mod, y &gt;&gt;= 1)
                if (y &amp; 1)
                    (res *= x) %= mod;
            return res;
        &#125;;
        pw[1] = 1ll;
        for (int i = 2; i &lt;= n; ++i) &#123;
            if (!tag[i]) &#123;
                pw[i] = qkp(i, n);
                p.push_back(i);
            &#125;
            for (auto j : p) &#123;
                if (i &gt; n / j)
                    break;
                tag[i * j] = 1;
                pw[i * j] = (long long)pw[i] * pw[j] % mod;
                if (i % j == 0)
                    break;
            &#125;
        &#125;
        std::vector&lt;int&gt; inv(n + 1), s(n + 1);
        inv[0] = 1ll;
        for (int j = 1; j &lt;= n; ++j)
            inv[j] = (long long)inv[j - 1] * j % mod;
        inv[n] = qkp(inv[n], mod - 2);
        for (int j = n - 1; j; --j)
            inv[j] = (long long)inv[j + 1] * (j + 1) % mod;
        s[0] = inv[0];
        for (int j = 1; j &lt;= n; ++j) &#123;
            if (j &amp; 1)
                s[j] = s[j - 1] + mod - inv[j];
            else
                s[j] = s[j - 1] + inv[j];
            if (s[j] &gt;= mod)
                s[j] -= mod;
        &#125;
        auto res = (long long)s[n] * ((n &amp; 1) ? mod - 1 : 1);
        for (int k = 1; k &lt;= n; ++k)
            res += (long long)pw[k - 1] * inv[k] % mod * s[n - k] % mod;
        std::cout &lt;&lt; res % mod &lt;&lt; &#39;\n&#39;;
    &#125;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;


C. 画家
https://www.becoder.com.cn/contest/6714/problem/3

ARC 特供删十字，故时光倒流，转化成在图上删相同颜色的十字 / 行 / 列。
令 \(f_{i,j}\) 表示合法的 \(i\) 行 \(j\) 列地图。发现同颜色的删行 + 删列会和直接删十字算重，


B. 灯光秀 / CF1545C AquaMoon and Permutations
https://www.luogu.com.cn/problem/CF1545C

第一步需要想到，如果某一列的某个数，只有一个排列有，那么这个排列必须被选入拉丁方；
用这个必选的排列，可以排除掉一些与之冲突、不能选入拉丁方的排列。



A. bot 的能量堆
https://www.becoder.com.cn/contest/6731/problem/1

⚡超越一切震慑凡人⚡
给定正整数 \(x,y\)，你可以执行下面三种操作：

将 \(x,y\) 同时加 1；
将 \(x,y\) 同时减一；
对于 \(\gcd(x,y)\) 的一个质因子 \(p\)，将 \(x,y\) 同时除以 \(p\)。

问最少花费多少次操作使得 \(\min(x,y)=1\)。多测。
\(T\le 300,1\le x,y\le 10^9\)。


不妨先考虑 \(x\ne y\) 的情况，发现三种操作都不会使 \(x,y\) 的相对大小关系改变。故令 \(x&lt;y\)，考虑让 \(x\) 变为 1。
记 \(d=y-x\)， 很容易注意到 \(d\) 的值不会在前两种操作中改变，由辗转相减，\(\gcd(x,y)=\gcd(d, x)\)，即操作三每次选取的 \(p\) 总是 \(d\) 的质因子，且总能通过若干次操作 1/2 让 \(p\) 能够执行。
每次执行操作 3 后，\(d\gets d\div p\)，每次只需让 \(x\) 变为 \(\lfloor \frac xp\rfloor\) 或 \(\lceil \frac xp\rceil\)。
直接记搜的话，容易发现状态总数是 V 因数总数。
对于 \(x=y\) 的情况，答案至多为 \(x\) 的质因子数量。暴搜 + 剪枝非常可过。

有一种神秘的处理方式…
if (x == y) &#123;
    auto calc = [&amp;](int x) &#123;
        int cnt = 0;
        for (int i = 2; i * i &lt;= x; ++i)
            for (; x % i == 0; ++cnt, x /= i);
        return cnt + (x != 1);
    &#125;;
    int to = calc(x), res = to;
    for (int i = std::max(x - to, 1); i &lt;= x + to; ++i)
        res = std::min(res, calc(i) + std::abs(i - x));
    std::cout &lt;&lt; x &lt;&lt; &#39;\n&#39;;
    continue;
&#125;
容易发现这东西没什么道理，反例大概率存在但在小范围内确实难以构造。总之数据没卡到。



B. bot 的矩阵
https://www.becoder.com.cn/contest/6731/problem/2

⚡带来终结机械降神⚡
有一个 \(n\times n\) 的二维数组，初始只知道 \(m\) 个位置的数 \(a_{x,y}\)，以及每行、每列的元素和 \(sx_{1\cdots n},sy_{1\cdots n}\)。
构造出一个合法的解，每个数在 \([-2^63,2^63)\) 内。
\(n\le 2000\),\(a_{x,y},sx_i,sy_i\in [-10^9,10^9]\)，\(m\le n^2\)。


听说很容易想到二分图，但实在反应不过来。但在乱填的时候发现，如果出现了『必填』的情况，是一个行列交错的链式反应，这样就很容易想到二分图了
原理是同时影响行 \(i\) 列 \(j\) 的元素只有 \((i, j)\)
相当于给一个 \(2n\) 个点 \(n^2\) 条边的二分图，其中一些边权是已知的，那么不妨认为这些边被删除了
同时也是一个 \(n^2\) 个元，\(2n-1\) 个方程的方程组（\(sx=sy\) 会消掉一条方程）；故很多元其实可以直接赋 \(0\)，只拿 \(2n-1\) 个元出来解方程。
在挖掉已知边的二分图上任意找生成树（森林）就可以满足 \(2n-1\) 的限制，结合树上高斯消元，从叶子开始解方程即可。


#include &lt;bits/stdc++.h&gt;
#define int long long
#define nec getchar
void read(int &amp;x) &#123;
    x = 0;
    char ch = nec();
    bool flag = false;
    for (; ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;; ch = nec())
        if (ch == &#39;-&#39;)
            flag = true;
    for (; ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;; ch = nec())
        x = x * 10 + ch - &#39;0&#39;;
    if (flag)
        x = -x;
    return;
&#125;
signed main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;matrix3.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int T;
    for (read(T); T--; ) &#123;
        int n, m;
        read(n), read(m);
        std::vector&lt;int&gt; sx(n + 1), sy(n + 1);
        for (int i = 1; i &lt;= n; ++i)
            read(sx[i]);
        for (int i = 1; i &lt;= n; ++i)
            read(sy[i]);
        std::vector&lt;std::vector&lt;int&gt; &gt; vis(n + 1, std::vector&lt;int&gt; (n + 1));
        std::vector&lt;std::vector&lt;long long&gt; &gt; a(n + 1, std::vector&lt;long long&gt; (n + 1));
        std::vector&lt;int&gt; tx(n + 1), ty(n + 1);
        auto work = [&amp;](int i, int j, int c) &#123;
            vis[i][j] = 1;
            ++tx[i], ++ty[j];
            sx[i] -= c, sy[j] -= c, a[i][j] = c;
            return;
        &#125;;
        for (int x, y, c; m--; ) &#123;
            read(x), read(y), read(c);
            work(x, y, c);
        &#125;
        if (std::accumulate(sx.begin() + 1, sx.end(), 0ll) != std::accumulate(sy.begin() + 1, sy.end(), 0ll)) &#123;
            std::cout &lt;&lt; &quot;NoSolution!&quot; &lt;&lt; &#39;\n&#39;;
            continue;
        &#125;
        std::vector&lt;int&gt; fx(n + 1), fy(n + 1);
        std::function&lt;bool(void)&gt; check = [&amp;](void) &#123;
            for (int x = 1; x &lt;= n; ++x)
                if (!fx[x]) &#123;
                    if (tx[x] == n) &#123;
                        if (sx[x] != 0)
                            return false;
                        fx[x] = 1;
                        if (!check())
                            return false;
                    &#125;
                    else if (tx[x] == n - 1) &#123;
                        for (int y = 1; y &lt;= n; ++y)
                            if (!vis[x][y]) &#123;
                                work(x, y, sx[x]);
                                fx[x] = 1;
                                if (!check())
                                    return false;
                            &#125;
                    &#125;
                &#125;
            for (int y = 1; y &lt;= n; ++y)
                if (!fy[y]) &#123;
                    if (ty[y] == n) &#123;
                        if (sy[y] != 0)
                            return false;
                        fy[y] = 1;
                        if (!check())
                            return false;
                    &#125;
                    else if (ty[y] == n - 1) &#123;
                        for (int x = 1; x &lt;= n; ++x)
                            if (!vis[x][y]) &#123;
                                work(x, y, sy[y]);
                                fy[y] = 1;
                                if (!check())
                                    return false;
                            &#125;
                    &#125;
                &#125;
            return true;
        &#125;;
        if (!check()) &#123;
            std::cout &lt;&lt; &quot;NoSolution!&quot; &lt;&lt; &#39;\n&#39;;
            continue;
        &#125;
        std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int op) &#123;
            if (op == 0) &#123;
                fx[x] = 1;
                for (int i = 1; i &lt;= n; ++i)
                    if (!vis[x][i] &amp;&amp; !fy[i]) &#123;
                        DFS(i, 1);
                        work(x, i, sy[i]);
                    &#125;
            &#125;
            else &#123;
                fy[x] = 1;
                for (int i = 1; i &lt;= n; ++i)
                    if (!vis[i][x] &amp;&amp; !fx[i]) &#123;
                        DFS(i, 0);
                        work(i, x, sx[i]);
                    &#125;
            &#125;
            return;
        &#125;;
        for (int i = 1; i &lt;= n; ++i)
            if (!fx[i])
                DFS(i, 0);
        for (int i = 1; i &lt;= n; ++i)
            if (!fy[i])
                DFS(i, 1);
        std::cout &lt;&lt; &quot;Botany!&quot; &lt;&lt; &#39;\n&#39;;
        for (int i = 1; i &lt;= n; ++i) &#123;
            for (int j = 1; j &lt;= n; ++j)
                std::cout &lt;&lt; a[i][j] &lt;&lt; &#39; &#39;;
            std::cout &lt;&lt; &#39;\n&#39;;
        &#125;
    &#125;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;


A. 数码串
https://www.becoder.com.cn/contest/6736/problem/1

给定一个长度为 \(n\) 的数字串，现在需要给它分为若干段，问在所有 \(2^{n-1}\) 种分段方式中，有多少种满足：

在任意相邻的两段中，有至少一段，其对应的十进制数是 \(D\) 的倍数。

答案对 \(10^9+7\) 取模。
多测，\(n\le 2\times 10^5,D\le 10^6,T\le 100\)。
部分分特殊性质：\(\gcd(D,10)=1\)。


发现若 \(a_{l\cdots r}\) 是 \(D\) 的倍数，记 \(s_i=s_{i+1}+a_i\times 10^{n-i}\)，那么 \(\dfrac{s_l-s_{r+1}}{10^{n-r}}\bmod D=0\)
题目要求，这个转移点和上个转移点，至少有一个满足该式。显然可以类 DP 地做。
对于 \(D\) 与 \(10\) 互质的情况，原条件等价于 \(s_l\equiv s_{r+1}\pmod D\)，用一个桶记录 DP 值即可
记 \(D=2^*\times 5^?\times m\)，发现 \(m\) 与 \(10\) 互质，或许可以套用上方的做法
由于 \(D\le 10^6 &lt; 2^{20}\)，对于一个固定的 \(r\)，所有 \(l\le r-20\) 项的 \(a_l\) 对 \(a_{l\cdots r}\bmod (2^*\times 5^?)\) 的贡献总是 \(0\)，故在只考虑 \(2^*\times 5^?\) 时， \(l\le r-20\) 的可选性和 \(l=r-20\) 的可选性相同。只需要对于 \(\bmod m\) 沿用桶做法即可。
对于 \(l\ge r-20\)，暴力即可，复杂度 \(O(T(n+D))\)。


注意 \(s_l-s_{r+1}\) 里的 \(r+1\)，调成鸲了
#include &lt;bits/stdc++.h&gt;
const int mod = 1e9 + 7;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
    std::freopen(&quot;digit.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;digit.out&quot;, &quot;w&quot;, stdout);
#else
    std::freopen(&quot;./test/20251113/digit/ex_digit1.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int T;
    std::vector&lt;std::array&lt;long long, 2&gt; &gt; c(1e6);
    for (std::cin &gt;&gt; T; T--; ) &#123;
        std::string a;
        int d, n, m, p;
        std::cin &gt;&gt; a &gt;&gt; d, n = (int)a.length();
        a = &quot;#&quot; + a;
        std::vector&lt;std::vector&lt;long long&gt; &gt; f(n + 1, std::vector&lt;long long&gt; (2));
        f[0][0] = 1ll;
        m = d;
        for (; m % 2 == 0; m /= 2);
        for (; m % 5 == 0; m /= 5);
        p = d / m;
        for (int i = 0; i &lt; m; ++i)
            c[i][0] = c[i][1] = 0ll;
        std::vector&lt;int&gt; s(n + 2);
        for (int i = n, k = 1; i; --i, (k *= 10) %= m)
            s[i] = (s[i + 1] + (a[i] - &#39;0&#39;) * k) % m;
        auto s0 = 0ll;
        for (int i = 1; i &lt;= n; ++i) &#123;
            int now = 0;
            for (int j = i, k = 1; j &gt; i - 20 &amp;&amp; j; --j, (k *= 10) %= d) &#123;
                (now += (a[j] - &#39;0&#39;) * k) %= d;
                if (now == 0)
                    (f[i][0] += f[j - 1][0] + f[j - 1][1]) %= mod;
                else
                    (f[i][1] += f[j - 1][0]) %= mod;
            &#125;
            if (i &gt; 20) &#123;
                (c[s[i - 20]][0] += f[i - 21][0]) %= mod;
                (c[s[i - 20]][1] += f[i - 21][1]) %= mod;
                (s0 += f[i - 21][0]) %= mod;
                int now = 0;
                for (int j = i, k = 1; j &gt;= i - 20; --j, (k *= 10) %= p)
                    (now += (a[j] - &#39;0&#39;) * k) %= p;
                if (now == 0) &#123;
                    (f[i][0] += c[s[i + 1]][0] + c[s[i + 1]][1]) %= mod;
                    (f[i][1] += s0 + mod - c[s[i + 1]][0]) %= mod;
                &#125;
                else
                    (f[i][1] += s0) %= mod;
            &#125;
        &#125;
        std::cout &lt;&lt; (f[n][0] + f[n][1]) % mod &lt;&lt; &#39;\n&#39;;
    &#125;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;


B. 背包
https://www.becoder.com.cn/contest/6736/problem/2

给定 \(n\) 种物品，第 \(i(1\le i\le n)\) 种有无穷多个，体积均为 \(v_i\)、价值均为 \(w_i\)。给定 \(Q\) 次询问，形如：

给定一个背包容积 \(m\)，回答两个问题：

有序地选取体积和恰好为 \(m\) 的物品，所能得到的最大价值。如果不存在这样的选取方式，回答 \(-1\)。
在上一问的条件下，可能的方案数。两个方案不同，当且仅当选取的物品数不同，或选物序列的某个位置不同。对 \(1092515507\) 取模，不存在则回答 \(-1\)。


\(n,Q,v_i\le 100, m,w_i\le 10^9\)。

mobai ddxrS

Tip：由于选取是有序的，所以朴素的『枚举物品 + 枚举体积』的 DP 是不可行的，而需要『枚举体积 + 枚举物品』。
很容易写出朴素的 DP：令二元组 \((a, b)_{m}\) 表示总体积 \(m\) 下的两问答案，则合并答案（定义为 \(+\) 运算）的过程可以写为：
\[
(a_1,b_1)_{m}+(a_2,b_2)_{m}=\begin{cases}
(a_1,b_1)_{m}&amp;a_1&gt;a_2\\
(a_1,b_1+b_2)_{m}&amp;a_1=a_2\\
(a_2, b_2)_{m}&amp;\text{otherwise}
\end{cases}
\]
相似地，状态转移（定义为 \(\times\) 运算）可以写为：
\[
(a_1,b_1)_{m_1}\times (a_2,b_2)_{m_2}=(a_1+a_2,b_1\times b_2)_{m_1+m_2}
\]
Tips：实际上是借鉴了矩阵乘法的含义进行定义，这样就可以尝试优化。
这样就有 \((f,g)_i = \sum\limits_{j=1}^n (f,g)_{i-v_j}\times (w_j,1)_{v_j}\)。
感性理解：显然，在直接背包时，\(+\) 运算与 \(\times\) 运算具有交换律，且 \(\times\) 对 \(+\) 有分配律。
那么此时广义矩乘具有结合律，可以优化。
体积最大为 \(100\)，考虑开 \(100\times 100\) 的矩阵（元素为二元组）维护 \((f,g)_{i-99}\sim (f,g)_i\)。考虑直接快速幂，发现复杂度是非常糟糕的 \(O(qv^3\log m)\)，非常糟糕。
初始矩阵是 \(1\times 100\) 的，这里的处理方式是预处理每一个 \(2^i\) 次幂（\(O(v^3\log m)\)），每次询问时二进制拆分 \(m\)，线性地乘过去，就可以把矩阵乘法优化为矩阵乘向量，复杂度降至 \(O(qv^2\log m)\)。


#include &lt;bits/stdc++.h&gt;
constexpr int N = 100;
const long long inf = 1e18;
const int mod = 1092515507;
struct node &#123;
    long long f, g;
    node(): f(-inf), g(0ll) &#123;&#125;
    node(long long f1, long long g1): f(f1), g(g1) &#123;
        if (g &gt;= mod)
            g -= mod;
        return;
    &#125;
    node operator* (const node &amp;q) const &#123;
        return node(f + q.f, g * q.g % mod);
    &#125;
    node operator+ (const node &amp;q) const &#123;
        if (f &gt; q.f)
            return *this;
        else if (f == q.f)
            return node(f, g + q.g);
        return q;
    &#125;
    node&amp; operator+= (const node &amp;q) &#123;
        return *this = *this + q;
    &#125;
&#125;;
struct mat &#123;
    std::vector&lt;std::vector&lt;node&gt; &gt; a;
    mat(void): a(N, std::vector&lt;node&gt; (N)) &#123;&#125;
    std::vector&lt;node&gt;&amp; operator[] (const int q) &#123;
        return a[q];
    &#125;
    mat operator* (mat &amp;q) const &#123;
        mat res;
        for (int i = 0; i &lt; N; ++i)
            for (int k = 0; k &lt; N; ++k)
                for (int j = 0; j &lt; N; ++j) 
                    res[i][j] += a[i][k] * q[k][j];
        return res;
    &#125;
&#125;;
struct vec &#123;
    std::vector&lt;node&gt; a;
    vec(void): a(N) &#123;&#125;
    node&amp; operator[] (const int q) &#123;
        return a[q];
    &#125;
    vec operator* (mat &amp;q) const &#123;
        vec res;
        for (int k = 0; k &lt; N; ++k)
            for (int j = 0; j &lt; N; ++j)
                res[j] += a[k] * q[k][j];
        return res;
    &#125;
    vec&amp; operator*= (mat &amp;q) &#123;
        return *this = *this * q;
    &#125;
&#125;;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
    std::freopen(&quot;pack.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;pack.out&quot;, &quot;w&quot;, stdout);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, q;
    std::cin &gt;&gt; n &gt;&gt; q;
    std::vector&lt;int&gt; v(n + 1), w(n + 1);
    for (int i = 1; i &lt;= n; ++i)
        std::cin &gt;&gt; v[i];
    for (int i = 1; i &lt;= n; ++i)
        std::cin &gt;&gt; w[i];
    std::vector&lt;mat&gt; t(30);
    for (int j = 0; j &lt; N - 1; ++j)
        t[0][j + 1][j] += node(0ll, 1ll);
    for (int i = 1; i &lt;= n; ++i)
        t[0][N - v[i]][N - 1] += node(w[i], 1ll);
    for (int i = 1; i &lt; 30; ++i)
        t[i] = t[i - 1] * t[i - 1];
    vec init;
    init[N - 1] = node(0ll, 1ll);
    for (int m; q--; ) &#123;
        std::cin &gt;&gt; m;
        auto res(init);
        for (int i = 29; ~i; --i)
            if ((m &gt;&gt; i) &amp; 1)
                res *= t[i];
        if (res[N - 1].f &lt;= 0)
            std::cout &lt;&lt; -1 &lt;&lt; &#39; &#39; &lt;&lt; -1 &lt;&lt; &#39;\n&#39;;
        else
            std::cout &lt;&lt; res[N - 1].f &lt;&lt; &#39; &#39; &lt;&lt; res[N - 1].g &lt;&lt; &#39;\n&#39;;
    &#125;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;


A. 关卡设计
https://www.becoder.com.cn/contest/6742/problem/1

给定 \(n\times m\) 的字符地图，其中 S 为起点（有且仅有一个），R，B 为红、蓝宝石（可能有多个），x 为障碍、. 为可通行地块。
现在需要把尽可能多的 . 变为 x，使得一种原来可以由 S 出发收集到的宝石在修改后的地图中仍能被收集。输出最多可修改的 . 的数量。
\(n\times m\le 10^6\)。


一种显然错误的做法：拆点 \((u,0/1/2/3)\) 分别表示走到 \(u\) 时的宝石收集状态，跑 01BFS。
错误的原因：路径会重复走一些边，但它们不能被重复记入代价。
结合『重复走一些边』的想法，发现路径一定有一个『分叉点』。枚举这样的分叉点，从 S、所有 R、所有 B 出发分别跑 01BFS。


#include &lt;bits/stdc++.h&gt;
const int dir[][2] = &#123; &#123; 0, -1 &#125;, &#123; 0, 1 &#125;, &#123; -1, 0 &#125;, &#123; 1, 0 &#125; &#125;;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
    std::freopen(&quot;design.out&quot;, &quot;w&quot;, stdout);
    std::freopen(&quot;design.in&quot;, &quot;r&quot;, stdin);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int T;
    for (std::cin &gt;&gt; T; T--; ) &#123;
        int n, m,  cnt = 0;
        std::cin &gt;&gt; n &gt;&gt; m;
        std::vector&lt;std::vector&lt;char&gt; &gt; a(n + 1, std::vector&lt;char&gt; (m + 1));
        for (int i = 1; i &lt;= n; ++i)
            for (int j = 1; j &lt;= m; ++j) &#123;
                std::cin &gt;&gt; a[i][j];
                cnt += (a[i][j] == &#39;.&#39;);
            &#125;
        const int N = n * m;
        auto id = [&amp;](int i, int j) &#123; return (i - 1) * m + j; &#125;;
        std::vector&lt;std::vector&lt;int&gt; &gt; dis(3, std::vector&lt;int&gt; (N + 1, N + 1));
        auto work = [&amp;](std::vector&lt;int&gt; &amp;dis, char S) &#123;
            std::deque&lt;int&gt; q;
            std::vector&lt;int&gt; vis(N + 1);
            for (int i = 1; i &lt;= n; ++i)
                for (int j = 1; j &lt;= m; ++j)
                    if (a[i][j] == S) &#123;
                        dis[id(i, j)] = 0;
                        q.push_back(id(i, j));
                    &#125;
            for (; !q.empty(); ) &#123;
                int x, y;
                &#123;
                    int t = q.front();
                    q.pop_front();
                    if (vis[t])
                        continue;
                    vis[t] = 1;
                    x = (t - 1) / m + 1, y = t - (x - 1) * m;
                &#125;
                for (auto [fx, fy] : dir) &#123;
                    int nx = x + fx, ny = y + fy;
                    if (nx &gt;= 1 &amp;&amp; ny &gt;= 1 &amp;&amp; nx &lt;= n &amp;&amp; ny &lt;= m &amp;&amp; a[nx][ny] != &#39;x&#39;) &#123;
                        if (a[nx][ny] != &#39;.&#39;) &#123;
                            if (dis[id(nx, ny)] &gt; dis[id(x, y)]) &#123;
                                dis[id(nx, ny)] = dis[id(x, y)];
                                q.push_front(id(nx, ny));
                            &#125;
                        &#125;
                        else if (dis[id(nx, ny)] &gt; dis[id(x, y)] + 1) &#123;
                            dis[id(nx, ny)] = dis[id(x, y)] + 1;
                            q.push_back(id(nx, ny));
                        &#125;
                    &#125;
                &#125;
            &#125;
        &#125;;
        work(dis[0], &#39;S&#39;), work(dis[1], &#39;R&#39;), work(dis[2], &#39;B&#39;);
        int mn1 = N + 1, mn2 = N + 1;
        for (int i = 1; i &lt;= n; ++i)
            for (int j = 1; j &lt;= m; ++j) &#123;
                mn1 = std::min(mn1, dis[0][id(i, j)] + std::min(dis[1][id(i, j)], dis[2][id(i, j)]) - (a[i][j] == &#39;.&#39;));
                mn2 = std::min(mn2, dis[0][id(i, j)] + dis[1][id(i, j)] + dis[2][id(i, j)] - (a[i][j] == &#39;.&#39;) * 2);
            &#125;
        if (mn2 != N + 1)
            std::cout &lt;&lt; cnt - mn2 &lt;&lt; &#39;\n&#39;;
        else if (mn1 != N + 1)
            std::cout &lt;&lt; cnt - mn1 &lt;&lt; &#39;\n&#39;;
        else
            std::cout &lt;&lt; cnt &lt;&lt; &#39;\n&#39;;
    &#125;;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;


C. 炼金术
https://www.becoder.com.cn/contest/6742/problem/3

给定 \(A_{1\cdots n}\) 和 \(B_{1\cdots n}\)，给定 \(m\) 次操作，形如：

1 l r x，将 \(A_{l\cdots r}\) 赋为 \(x\)。
2 l r，询问 \(\min\limits_{i\in [l, r]}\left\{ \text{lcm}(A_i,B_i)+\dfrac{\text{lcm}(A_i,B_i)}{\gcd(A_i,B_i)} \right\}\) 的值。

\(n,m\le 5\times 10^4,V=5\times 10^4\)。


待求没什么太好的性质，考虑更暴力的解决方式。
容易想到分块做法，对于整块赋值，容易想到对于每个 \(x\) 预处理块内答案。如何快速做到这一点？
一个想法是枚举 gcd 的值 \(p\)（显然只需枚举 \(x\) 的因子），计算 \(\dfrac {b_j\times x}p+\dfrac {b_j\times x}{p^2}\) 的最小值。
Tip：枚举到的 \(p\) 可能不是 gcd，但能保证一定能找到答案。
贪心地，只需对于块内 \(p\) 的最小倍数计算答案。这一点对于每个 \(b_i\) 枚举因数即能 \(O(n\sqrt V)\) 地预处理（因为有重复元素所以不是 \(O(V\log V)\)）、花费 \(O(V\log n)\) 的空间存储。
对于每个 \(x\)，复杂度不允许暴力枚举 \(x\) 的因子；发现 \(x\) 的因子是 \(x\) 与『对于所有 \(x\) 的质因子 \(m\)，\(\dfrac xm\) 的因子』的并。
考虑一个类 DP 的过程，则 \(f_x\gets f_{x\div m}\times m\)，再计算 \(x\) 自身的答案即可。由于 \(\omega(V)\) 平均为 \(\log\log V\)，此时预处理复杂度降低至 \(O(n\sqrt V + V\log V\sqrt n)\)。
用一点科技加速 gcd 即可。可选 \(O(1)\) gcd，或小范围打表 + 大范围暴力跳至小范围。


注意待求可能会爆 unsigned int，问就是挂分了。
#include &lt;bits/stdc++.h&gt;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
    std::freopen(&quot;alchemy.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;alchemy.out&quot;, &quot;w&quot;, stdout);
#else
    std::freopen(&quot;./test/20251115/alchemy/alchemy4.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    const long long inf = 1e18;
    const int M = 5000, N = 50000;
    std::vector&lt;std::vector&lt;int&gt; &gt; g(M + 1, std::vector&lt;int&gt; (M + 1));
    for (int i = 0; i &lt;= M; ++i) &#123;
        for (int j = 0; j &lt; i; ++j)
            g[i][j] = g[j][i];
        g[i][i] = i;
        for (int j = i + 1; j &lt;= M; ++j)
            g[i][j] = std::__gcd(i, j);
    &#125;
    std::function&lt;int(int, int)&gt; gcd = [&amp;](int x, int y) &#123;
        if (x &lt;= M &amp;&amp; y &lt;= M)
            return g[x][y];
        return y ? gcd(y, x % y) : x;
    &#125;;
    std::vector&lt;std::vector&lt;int&gt; &gt; fac(N + 1);
    for (int i = 2; i &lt;= N; ++i)
        if (fac[i].empty())
            for (int j = i; j &lt;= N; j += i)
                fac[j].push_back(i);
    int n, m;
    std::cin &gt;&gt; n &gt;&gt; m;
    std::vector&lt;long long&gt; a(n + 1), b(n + 1), p(n + 1);
    auto calc = [&amp;](long long x, long long y) &#123;
        auto g = gcd(x, y);
        return x * y / g + x * y / g / g;
    &#125;;
    for (int i = 1; i &lt;= n; ++i)
        std::cin &gt;&gt; a[i];
    for (int i = 1; i &lt;= n; ++i) &#123;
        std::cin &gt;&gt; b[i];
        p[i] = calc(a[i], b[i]);
    &#125;
    int siz = sqrt(n), k = (n + siz - 1) / siz;
    std::vector&lt;long long&gt; u(k + 1, inf);
    std::vector&lt;int&gt; L(k + 1), R(k + 1), id(n + 1), d(k + 1, -1);
    std::vector&lt;std::vector&lt;long long&gt; &gt; mn(k + 1, std::vector&lt;long long&gt; (N + 1, inf)), s(k + 1, std::vector&lt;long long&gt; (N + 1));
    for (int i = 1; i &lt;= k; ++i) &#123;
        L[i] = R[i - 1] + 1, R[i] = std::min(L[i] + siz - 1, n);
        for (int j = L[i]; j &lt;= R[i]; ++j) &#123;
            id[j] = i, u[i] = std::min(u[i], p[j]);
            for (int k = 1; k * k &lt;= b[j]; ++k)
                if (b[j] % k == 0) &#123;
                    mn[i][k] = std::min(mn[i][k], b[j]);
                    mn[i][b[j] / k] = std::min(mn[i][b[j] / k], b[j]);
                &#125;
        &#125;
        s[i][1] = mn[i][1] * 2;
        for (int j = 2; j &lt;= N; ++j) &#123;
            s[i][j] = mn[i][j] + mn[i][j] / j;
            for (auto k : fac[j])
                s[i][j] = std::min(s[i][j], s[i][j / k] * k);
        &#125;
    &#125;
    auto pushdown = [&amp;](int id) &#123;
        if (d[id] != -1) &#123;
            for (int i = L[id]; i &lt;= R[id]; ++i)
                p[i] = calc(d[id], b[i]);
            d[id] = -1;
        &#125;
        return;
    &#125;;
    auto ADD = [&amp;](int l, int r, int x) &#123;
        int pl = id[l], pr = id[r];
        pushdown(pl);
        if (pl == pr) &#123;
            for (int i = l; i &lt;= r; ++i)
                p[i] = calc(x, b[i]);
            u[pl] = *std::min_element(p.begin() + L[pl], p.begin() + R[pl] + 1);
            return;
        &#125;
        pushdown(pr);
        for (int i = l; i &lt;= R[pl]; ++i)
            p[i] = calc(x, b[i]);
        u[pl] = *std::min_element(p.begin() + L[pl], p.begin() + R[pl] + 1);
        for (int i = L[pr]; i &lt;= r; ++i)
            p[i] = calc(x, b[i]);
        u[pr] = *std::min_element(p.begin() + L[pr], p.begin() + R[pr] + 1);
        for (int i = pl + 1; i &lt; pr; ++i)
            d[i] = x, u[i] = s[i][x];
        return;
    &#125;;
    auto ASK = [&amp;](int l, int r) &#123;
        int pl = id[l], pr = id[r];
        pushdown(pl);
        if (pl == pr)
            return *std::min_element(p.begin() + l, p.begin() + r + 1);
        pushdown(pr);
        auto res = std::min(*std::min_element(p.begin() + l, p.begin() + R[pl] + 1), *std::min_element(p.begin() + L[pr], p.begin() + r + 1));
        if (pl + 1 != pr)
            res = std::min(res, *std::min_element(u.begin() + pl + 1, u.begin() + pr));
        return res;
    &#125;;
    for (int op, l, r; m--; ) &#123;
        std::cin &gt;&gt; op &gt;&gt; l &gt;&gt; r;
        if (op == 1) &#123;
            int x;
            std::cin &gt;&gt; x, ADD(l, r, x);
        &#125;
        else
            std::cout &lt;&lt; ASK(l, r) &lt;&lt; &#39;\n&#39;;
    &#125;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;

]]></content>
      <tags>
        <tag>二分图</tag>
        <tag>计数</tag>
        <tag>DP 套 DP</tag>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>学习笔记：一类序列区间排序问题</title>
    <url>/20251107/</url>
    <content><![CDATA[答辩题做累了，做点轻松愉快的数据结构


排序
https://www.luogu.com.cn/problem/P2824

给定排列 \(a_{1\cdots n}\)，维护 \(m\) 次操作，形如：

0/1 l r，将 \(a_{l\cdots r}\) 按升序 / 降序排列。

最后给定一个 \(p\)，问最终 \(a_p\) 的值。
\(n,m\le 10^5\)。


发现问题是类静态的，考虑离线做法。
在线做法放到后面的在线题目再讲，原因：在线做法 too dirty，杀鸡焉用牛刀。
发现如果值域为 \(\{0, 1\}\)，那么这样的排序是很简单的，直接统计区间内 0/1 个数然后推平即可。
这种转化后为 0/1 的情况，很容易想到二分答案：把 \(\le mid\) 的元素赋为 \(0\)，\(&gt;mid\) 的元素赋为 \(1\) 即可 \(O(n\log^2 n)\) 解决问题。


推平时操作区间长可能为 \(0\)，不判掉这个会 RE
#include &lt;bits/stdc++.h&gt;
const int maxn = 1e5 + 5;
struct &#123; int l, r, u, d; &#125; t[maxn &lt;&lt; 2];
int a[maxn];
#define lt (p &lt;&lt; 1)
#define rt (lt | 1)
void pushup(int p) &#123;
    t[p].u = t[lt].u + t[rt].u;
    return;
&#125;
void pushdown(int p) &#123;
    if (~t[p].d) &#123;
        t[lt].d = t[rt].d = t[p].d;
        t[lt].u = (t[lt].r - t[lt].l + 1) * t[p].d;
        t[rt].u = (t[rt].r - t[rt].l + 1) * t[p].d;
        t[p].d = -1;
    &#125;
    return;
&#125;
void bld(int p, int l, int r, int k) &#123;
    t[p].l = l, t[p].r = r;
    t[p].d = -1;
    if (l == r) &#123;
        t[p].u = (a[l] &gt;= k);
        return;
    &#125;
    int mid = (l + r) &gt;&gt; 1;
    bld(lt, l, mid, k);
    bld(rt, mid + 1, r, k);
    pushup(p);
    return;
&#125;
void upd(int p, int l, int r, int v) &#123;
    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r) &#123;
        t[p].d = v;
        t[p].u = (t[p].r - t[p].l + 1) * v;
        return;
    &#125;
    pushdown(p);
    int mid = (t[p].l + t[p].r) &gt;&gt; 1;
    if (l &lt;= mid)
        upd(lt, l, r, v);
    if (r &gt; mid)
        upd(rt, l, r, v);
    pushup(p);
    return;
&#125;
int ask(int p, int l, int r) &#123;
    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r)
        return t[p].u;
    pushdown(p);
    int mid = (t[p].l + t[p].r) &gt;&gt; 1, res = 0;
    if (l &lt;= mid)
        res = ask(lt, l, r);
    if (r &gt; mid)
        res += ask(rt, l, r);
    return res;
&#125;
#undef lt
#undef rt
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, m;
    std::cin &gt;&gt; n &gt;&gt; m;
    std::vector&lt;std::tuple&lt;int, int, int&gt; &gt; q(m);;
    for (int i = 1; i &lt;= n; ++i)
        std::cin &gt;&gt; a[i];
    for (int i = 0, op, l, r; i &lt; m; ++i) &#123;
        std::cin &gt;&gt; op &gt;&gt; l &gt;&gt; r;
        q[i] = &#123; op, l, r &#125;;
    &#125;
    int p;
    std::cin &gt;&gt; p;
    auto check = [&amp;](int mid) &#123;
        bld(1, 1, n, mid);
        for (int i = 0; i &lt; m; ++i) &#123;
            auto &amp;[op, l, r] = q[i];
            int t = ask(1, l, r);
            if (op == 0) &#123;
                t = (r - l + 1) - t;
                if (t &gt;= 1)
                    upd(1, l, l + t - 1, 0);
                if (l + t &lt;= r)
                    upd(1, l + t, r, 1);
            &#125;
            else &#123;
                if (t &gt;= 1)
                    upd(1, l, l + t - 1, 1);
                if (l + t &lt;= r)
                    upd(1, l + t, r, 0);
            &#125;
        &#125;
        return ask(1, p, p);
    &#125;;
    int res = -1;
    for (int l = 1, r = n, mid; l &lt;= r; ) &#123;
        mid = (l + r) &gt;&gt; 1;
        if (check(mid))
            res = mid, l = mid + 1;
        else
            r = mid - 1;
    &#125;
    std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;


Range Sort Query
https://www.luogu.com.cn/problem/AT_abc237_g

给定排列 \(a_{1\cdots n}\)，维护 \(m\) 次操作，形如：

0/1 l r，将 \(a_{l\cdots r}\) 按升序 / 降序排列。

最后给定一个 \(x\)，求满足 \(a_p=x\) 的 \(p\)。
\(n,m\le 2\times 10^5\)。


发现这个问题不可二分，但根据 \(x\) 设 0/1 的想法显然可以沿用。
有一个形似等差子序列的想法：
发现对于 \(x\)，它是 0 或 1 无所谓，且两种设法中，被影响到的只有 \(x\) 这个值。
故对于两种设法分别做一次，最后不同的位置即为 \(p\)。


#include &lt;bits/stdc++.h&gt;
const int maxn = 2e5 + 5;
struct &#123; int l, r, u, d; &#125; t[maxn &lt;&lt; 2];
int a[maxn];
#define lt (p &lt;&lt; 1)
#define rt (lt | 1)
void pushup(int p) &#123;
    t[p].u = t[lt].u + t[rt].u;
    return;
&#125;
void pushdown(int p) &#123;
    if (~t[p].d) &#123;
        t[lt].d = t[rt].d = t[p].d;
        t[lt].u = (t[lt].r - t[lt].l + 1) * t[p].d;
        t[rt].u = (t[rt].r - t[rt].l + 1) * t[p].d;
        t[p].d = -1;
    &#125;
    return;
&#125;
void bld(int p, int l, int r, int k) &#123;
    t[p].l = l, t[p].r = r;
    t[p].d = -1;
    if (l == r) &#123;
        t[p].u = (a[l] &gt;= k);
        return;
    &#125;
    int mid = (l + r) &gt;&gt; 1;
    bld(lt, l, mid, k);
    bld(rt, mid + 1, r, k);
    pushup(p);
    return;
&#125;
void upd(int p, int l, int r, int v) &#123;
    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r) &#123;
        t[p].d = v;
        t[p].u = (t[p].r - t[p].l + 1) * v;
        return;
    &#125;
    pushdown(p);
    int mid = (t[p].l + t[p].r) &gt;&gt; 1;
    if (l &lt;= mid)
        upd(lt, l, r, v);
    if (r &gt; mid)
        upd(rt, l, r, v);
    pushup(p);
    return;
&#125;
int ask(int p, int l, int r) &#123;
    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r)
        return t[p].u;
    pushdown(p);
    int mid = (t[p].l + t[p].r) &gt;&gt; 1, res = 0;
    if (l &lt;= mid)
        res = ask(lt, l, r);
    if (r &gt; mid)
        res += ask(rt, l, r);
    return res;
&#125;
#undef lt
#undef rt
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, m, k;
    std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;
    std::vector&lt;int&gt; b(n + 1);
    std::vector&lt;std::tuple&lt;int, int, int&gt; &gt; q(m);
    for (int i = 1; i &lt;= n; ++i)
        std::cin &gt;&gt; a[i];
    bld(1, 1, n, k + 1);
    for (int i = 0, op, l, r; i &lt; m; ++i) &#123;
        std::cin &gt;&gt; op &gt;&gt; l &gt;&gt; r;
        q[i] = &#123; op, l, r &#125;;
        int t = ask(1, l, r);
        if (op == 1) &#123;
            t = (r - l + 1) - t;
            if (t &gt;= 1)
                upd(1, l, l + t - 1, 0);
            if (l + t &lt;= r)
                upd(1, l + t, r, 1);
        &#125;
        else &#123;
            if (t &gt;= 1)
                upd(1, l, l + t - 1, 1);
            if (l + t &lt;= r)
                upd(1, l + t, r, 0);
        &#125;
    &#125;
    for (int i = 1; i &lt;= n; ++i)
        b[i] = ask(1, i, i);
    bld(1, 1, n, k);
    for (auto &amp;[op, l, r] : q) &#123;
        int t = ask(1, l, r);
        if (op == 1) &#123;
            t = (r - l + 1) - t;
            if (t &gt;= 1)
                upd(1, l, l + t - 1, 0);
            if (l + t &lt;= r)
                upd(1, l + t, r, 1);
        &#125;
        else &#123;
            if (t &gt;= 1)
                upd(1, l, l + t - 1, 1);
            if (l + t &lt;= r)
                upd(1, l + t, r, 0);
        &#125;
    &#125;
    for (int i = 1; i &lt;= n; ++i)
        if (ask(1, i, i) != b[i]) &#123;
            std::cout &lt;&lt; i &lt;&lt; &#39;\n&#39;;
            break;
        &#125;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;


A Simple Task
https://www.luogu.com.cn/problem/CF558E

给定字符串 \(s_{1\cdots n}\)，维护 \(m\) 次操作，形如：

0/1 l r，将 \(s_{l\cdots r}\) 按升序 / 降序排列。

输出所有操作后的 \(s\)。
\(n\le 10^5, m\le 5\times 10^4\)，\(s\) 由小写字母组成。


发现需要全局查询，上面设 0/1 的套路无法沿用
但发现这题本身值域就很小
所以只需要开 26 个线段树，暴力按 a ~ z 排序，做区间覆盖即可。
询问带 26 倍常数，故 \(m\) 会比 \(n\) 小。


From one to six
https://vjudge.net/problem/Gym-104254I#author=GPT_zh

给定序列 \(a_{1\cdots n}\)，只包含 \(1,2,3,4,5,6\)，维护 \(m\) 次操作，形如：

1 l r，将 \(a_{l\cdots r}\) 升序排列。
2 l r，输出 \([l, r]\) 内的 LIS。

最后给定一个 \(x\)，求满足 \(a_p=x\) 的 \(p\)。
\(n,m\le 2\times 10^5\)。


和上一题相似的，只需需要额外开一个新线段树记录当前的 \(a\)，同样只需区间覆盖即可。
转移直接套用朴素 LIS 的 DP 方式，很容易维护。


Philosopher
https://loj.ac/p/6189

给定 \(a_{1\cdots n}\)，维护 \(m\) 次操作，形如：

1 l r 0/1，将 \(a_{l\cdots r}\) 按升序 / 降序排列。
2 l r，询问区间内元素和。

\(1\le n,m\le 2\times 10^5,V=10^9\)。


在线区间排序的通解：用若干个权值线段树维护连续段（递增 / 递减）。外层用一个同样支持分裂 &amp; 合并 &amp; reverse 的结构，fhq，又一个线段树什么的，记录权值线段树的分布情况及增减状态，以及每个树的元素和。
这样查询时就可以通过类似分块的方法求解。
对于一次排序操作只需线段树分裂 + 线段树合并。一次操作中的分裂至多增加 2 势能，合并至少减少 1 势能。线段树分裂 &amp; 合并均摊单 log，故总复杂度单 log。
为何内层不用 fhq？不经过特殊处理的 fhq 在有交合并时带两只 log。


Point Set Range Sort Range Composite
https://vjudge.net/problem/Yosupo-point_set_range_sort_range_composite#author=GPT_zh

给定 \(n\) 个二元组，由函数 \(f_{1\cdots n}=k_i\cdot x+b_i\) 和排序权值 \(p_{1\cdots n}\) 组成，维护 \(m\) 次操作，形如：

0 i p k b，修改当前的第 \(i\) 个元素的 \(f_i\) 和 \(p_i\)。
1 l r x，询问 \(f_{r-1}(f_{r-2}(\cdots f_l(x)))\bmod 998244353\)。
2/3 l r，将当前第 \(l\sim r\) 个元素按照 \(p\) 值升序 / 降序排列。

\(1\le n,m\le 10^5,V=10^9\)。保证任意时刻，每个 \(p_i\) 互不相同。


和上一题没什么本质区别，换成了维护矩阵而已。额外注意矩阵 + reverse 的那些东西即可。


齐齐排序
https://ac.nowcoder.com/acm/problem/21439

给定序列 \(a_{1\cdots n}\)，维护 \(m\) 次操作，形如：

0 x，将 \(a_{1\cdots x}\) 按降序排列。
1 x，将 \(a_{1\cdots x}\) 按升序排列。

输出操作完成后的序列。
\(n,m\le 2\times 10^5,V=10^9\)。


诈骗题
发现只存在前缀操作，显然 \(x\) 较大的会覆盖 \(x\) 较小的操作
容易发现有效操作的 \(x\) 形成一个后缀最大值序列。用这些操作给数打升序 / 降序标记。
先填完没有被操作过的位置（显然这样的位置在序列末），然后用一个 multiset 装剩下所有数。倒序遍历还未填的位置，若这个位置上的标记是升序，则填最大值；否则填最小值。


#include &lt;bits/stdc++.h&gt;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, m;
    std::cin &gt;&gt; n &gt;&gt; m;
    std::vector&lt;int&gt; a(n + 1);
    for (int i = 1; i &lt;= n; ++i)
        std::cin &gt;&gt; a[i];
    std::vector&lt;std::pair&lt;int, int&gt; &gt; q(m + 1);
    for (int i = 1; i &lt;= m; ++i)
        std::cin &gt;&gt; q[i].first &gt;&gt; q[i].second;
    int mx = 0;
    std::vector&lt;int&gt; tag(n + 1);
    for (int i = m; i; --i)
        if (q[i].second &gt; mx) &#123;
            mx = q[i].second;
            tag[q[i].second] = q[i].first;
        &#125;
    std::multiset&lt;int&gt; t;
    for (int i = 1; i &lt;= mx; ++i)
        t.insert(a[i]);
    for (int i = mx, st = 0; i; --i) &#123;
        if (tag[i])
            st = tag[i];
        if (st == 1)
            a[i] = *--t.end(), t.erase(--t.end());
        else
            a[i] = *t.begin(), t.erase(t.begin());
    &#125;
    for (int i = 1; i &lt;= n; ++i)
        std::cout &lt;&lt; a[i] &lt;&lt; &#39; &#39;;
    std::cout &lt;&lt; &#39;\n&#39;;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;


정렬 게임
https://vjudge.net/problem/Baekjoon-13415#author=GPT_zh

给定序列 \(a_{1\cdots n}\)，维护 \(m\) 次操作，形如：

x y，将 \(a_{1\cdots x}\) 按升序排列，接着，对 \(a_{1\cdots y}\) 按降序排列。

输出操作完成后的序列。
\(n,m\le 10^5,|V|=10^4\)。


发现这个题严格弱于上一个题，没啥说的。


入れ替えと並び替え
https://www.luogu.com.cn/problem/AT_past202005_n

给定序列 \(a_{1\cdots n}\)，初始为 \(1,2,\cdots,n\)，维护 \(m\) 次操作，形如：

0 x，交换 \(a_x\) 与 \(a_{x+1}\)。
1 l r，将 \(a_{l\cdots r}\) 按升序排列。

输出操作完成后的序列。
\(n,m\le 2\times 10^5\)。


诈骗题⨉2
初始是有序的，保证了仅需要复原被打乱的项即可完成排序。
维护每次交换在 \((x-1,x)\)、\((x,x+1)\)、\((x+1,x+2)\) 三个位置创建 / 删除的逆序对。
手玩发现操作给出的交换和目的为复原的交换都有可能带来新的逆序对。考虑势能分析。
操作给出的交换至多增加一个逆序对（势能），而一次目的为复原的交换至少减少一个逆序对（势能）。
故直接暴力复原范围内逆序对，复杂度 \(O(Q\log Q)\)。


双向排序
https://www.luogu.com.cn/problem/P8747

给定排列 \(a_{1\cdots n}\)，初始为 \(1,2,\cdots,n\)，维护 \(m\) 次操作，形如：

0 x，将 \(a_{1\cdots x}\) 按降序排列。
1 x，将 \(a_{x\cdots n}\) 按升序排列。

输出操作完成后的序列。
\(n,m\le 2\times 10^5\)。


发现题目给的限制非常有意思，保证了最终序列一定满足前半截降序，后半截升序。
需要发现一个可怕的事实：操作相当于选取分割点 \(pos\) 左 / 右侧最小的数并挪到对侧。
维护每个点的 0/1 状态，线段树上二分并区间推平即可。
另一个很强的线性做法：只维护 \(pos\) 左边的点值，那么操作可以看作：
加入若干个最小的、不存在于左边的点 / 删除若干个存在于左边，且最小的点
用栈维护左边从小到大的所有连续段，每次加点暴力合并，删点则暴力删
发现加点只会增加最多一个连续段，且枚举连续段合并之后会减少对应的势能；删点同理。
故均摊线性。

]]></content>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>杂题选谈 计数</title>
    <url>/20251116/</url>
    <content><![CDATA[上一篇杂题里，新的题目严重阻碍了老题目的生长。为了解除顶端抑制，一部分伸长区被移植到这里了。


A - Range Set
https://www.luogu.com.cn/problem/AT_agc045_c

首先考虑 \(A\le B\) 的情况。覆盖类问题的一个想法是倒推回 ?（这种方法的优点在于，操作总能和原始操作一一对应，形成和正向操作序列的双射，通过倒推得到的性质总是充要的）。
则目标串为长度为 \(n\) 的 0? 串，起始串为待判定串，可进行的操作有：

选择一个长度为 \(B\) 的 1? 串，全部变为 ?；
选择一个长度为 \(A\) 的 0? 串，全部变为 ?。

容易发现，只要在任意时刻进行了一次 1 操作，总能通过若干次 1 2 操作扩展到一个长为 \(n\) 的 0? 序列（而一次 1 操作都不做只有一种情况，虽然在后面 DP 会自然统计到这种情况）。故目标转化为找到能够进行第一次（又一个经典技巧）1 操作的局面。
容易发现当且仅当能够通过若干次 2 操作，得到一个长度 \(\ge B\) 的 1? 串，显然的等价转换是，存在一个长度 \(\ge B\) 的子串，里面所有 0 的连续段长度均 \(\ge A\)。现在就可以想办法统计了。
接下来考虑 \(B&lt;A\) 的情况，容易发现，只要在任意时刻进行了一次 2 操作，总能通过若干次 1 2 操作扩展到一个长为 \(n\) 的 0? 序列。把上面得到所有合法串 flip 就可以得到这里的所有合法串，故并不需要分讨。
令 \(f_{i,j,0/1}\) 表示 DP 到 \(i\)，有一段长度为 \(j\) 的合法后缀，第 \(i-1\) 位的值为 \(0/1\) 的方案数，则：
\[
f_{i,j,1}=\sum_{k=1}^j f_{i-k,j-k,0}\\
f_{i,j,0}=\left(\sum_{k=1}^{\min(A-1,j-B)}f_{i-k,j-k,1}\right)+\left(\sum_{k=A}^j f_{i-k,j-k,1}\right)\\
f_{i,0,0}=\sum_{k=1}^{A-1}\sum_{j=0}^{B-1} f_{i-k,j,1}
\]
最后一种转移的优化是显然的；前两种转移中，\(i\) 和 \(j\) 的变化量是一致的，也可以前缀和优化。


#include &lt;bits/stdc++.h&gt;
const int mod = 1e9 + 7;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, a, b;
    std::cin &gt;&gt; n &gt;&gt; a &gt;&gt; b;
    if (a &gt; b)
        std::swap(a, b);
    using arr = std::vector&lt;long long&gt;;
    using brr = std::vector&lt;arr&gt;;
    using crr = std::vector&lt;brr&gt;;
    brr sum(n + 1, arr(n + 1));
    crr s(2, brr(n + 1, arr(n + 1)));
    sum[0][0] = 1ll;
    s[0][0][0] = s[1][0][0] = 1ll;
    auto fun = [&amp;](int op, int i, int j, int l, int r) &#123;
        if (l &gt; r)
            return 0ll;
        auto res = s[op][i - j][i - l];
        if (i &gt; r)
            res += mod - s[op][i - j][i - r - 1];
        return res &lt; mod ? res : res - mod;
    &#125;;
    auto res = 0ll;
    for (int i = 1; i &lt;= n; ++i) &#123;
        for (int j = 1; j &lt;= n &amp;&amp; j &lt;= i; ++j) &#123;
            auto f0 = fun(1, i, j, 1, std::min(a - 1, j - b)) + fun(1, i, j, a, j);
            auto f1 = fun(0, i, j, 1, j);
            if (f0 &gt;= mod)
                f0 -= mod;
            if ((s[0][i - j][i] = s[0][i - j][i - 1] + f0) &gt;= mod)
                s[0][i - j][i] -= mod;
            if ((s[1][i - j][i] = s[1][i - j][i - 1] + f1) &gt;= mod)
                s[1][i - j][i] -= mod;
            if (i == n &amp;&amp; j &gt;= b)
                res += f0 + f1;
            if ((sum[i][j] = sum[i][j - 1] + f1) &gt;= mod)
                sum[i][j] -= mod;
        &#125;
        s[0][i][i] = 0ll;
        for (int k = 1; k &lt; a &amp;&amp; k &lt;= i; ++k)
            s[0][i][i] += sum[i - k][std::min(b - 1, i - k)];
        s[0][i][i] %= mod;
    &#125;
    std::cout &lt;&lt; res % mod &lt;&lt; &#39;\n&#39;;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;


B - Popping Balls
https://www.luogu.com.cn/problem/AT_code_festival_2017_qualb_e

容易发现好的出发点应该是尽可能多地统计局面。容易发现应该尽量让 \(s\) 和 \(t\) 取到蓝色的球。
进一步发现，在第一次取蓝球时，\(t\) 应该在蓝球的队首处。直到取走了 \(B\) 个球，\(t\) 已经超出序列时，\(s\) 才可能发挥作用。
相似地，在这之后第一次取蓝球时，\(s\) 应该在蓝球的队首处。
很容易发现只需要统计两个点处分别取走了多少个蓝球（尽量让 \(t\) 取）就能统计。
具体地，设 \(t\) 处取走了 \(c\) 个、\(s\) 处取走了 \(d\) 个，则这两个点处的方案数为：
\[
\binom{B-1}{c-1}\times \binom{B-c-1}{d-1}
\]
此外，总共 \(A-(B-c)-(B-c-d)\) 个红球，可以在 \(t\) 进入决策之前，\(s\) 进入决策之前，\(s\) 决策完后三个时刻给出去。插板得到 \(\binom{A-(B-c)-(B-c-d)+2}2\) 种方案。
此外，还要考虑 \(s\) 与 \(t\) 重合，共 \(A+1\) 种方案。



#include &lt;bits/stdc++.h&gt;
const int mod = 1e9 + 7;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int A, B;
    std::cin &gt;&gt; A &gt;&gt; B;
    using arr = std::vector&lt;long long&gt;;
    using brr = std::vector&lt;arr&gt;;
    brr C(A + B + 1, arr(A + B + 1));
    C[0][0] = 1ll;
    for (int i = 1; i &lt;= A + B; ++i) &#123;
        C[i][0] = 1ll;
        for (int j = 1; j &lt;= i; ++j)
            C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % mod;
    &#125;
    auto res = A + 1;
    for (int c = 1; c &lt; B; ++c)
        for (int d = 1; c + d &lt;= B; ++d)
            (res += C[B - 1][c - 1] * C[B - c - 1][d - 1] % mod * C[std::max(0, A - (B - c) - (B - c - d) + 2)][2] % mod) %= mod;
    std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;


C - Minimum Bounding Box 2
https://www.luogu.com.cn/problem/AT_abc297_f

枚举矩形长宽，二项式算方案数即可，非常简单。


#include &lt;bits/stdc++.h&gt;
const int mod = 998244353;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, m, k;
    std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;
    using arr = std::vector&lt;long long&gt;;
    using brr = std::vector&lt;arr&gt;;
    arr fac(n * m + 1), inv(n * m + 1);
    fac[0] = inv[0] = 1ll;
    for (int i = 1; i &lt;= n * m; ++i)
        fac[i] = fac[i - 1] * i % mod;
    auto qkp = [&amp;](long long x, int y) &#123;
        auto res = 1ll;
        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)
            if (y &amp; 1)
                (res *= x) %= mod;
        return res;
    &#125;;
    inv[n * m] = qkp(fac[n * m], mod - 2);
    for (int i = n * m - 1; i; --i)
        inv[i] = inv[i + 1] * (i + 1) % mod;
    auto C = [&amp;](int n, int m) &#123;
        if (n &lt; m)
            return 0ll;
        return fac[n] * inv[m] % mod * inv[n - m] % mod;
    &#125;;
    auto res = 0ll;
    brr f(n + 1, arr(m + 1)), g(n + 1, arr(m + 1));
    for (int i = 1; i &lt;= n; ++i)
        for (int j = 1; j &lt;= m; ++j) &#123;
            g[i][j] = C(i * j, k);
            f[i][j] = g[i][j] - g[i - 1][j] * 2 - g[i][j - 1] * 2 + g[i - 1][j - 1] * 4;
            if (i &gt;= 2)
                f[i][j] += g[i - 2][j] - 2 * g[i - 2][j - 1];
            if (j &gt;= 2)
                f[i][j] += g[i][j - 2] - 2 * g[i - 1][j - 2];
            if (i &gt;= 2 &amp;&amp; j &gt;= 2)
                f[i][j] += g[i - 2][j - 2];
            f[i][j] = (f[i][j] % mod + mod) % mod;
            (res += i * j * f[i][j] % mod * (n - i + 1) % mod * (m - j + 1)) %= mod;
            // printf(&quot;f[%d][%d] = %lld \n&quot;, i, j, f[i][j]);
        &#125;
    std::cout &lt;&lt; res * qkp(C(n * m, k), mod - 2) % mod &lt;&lt; &#39;\n&#39;;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;


D - Colorful Candies 2
https://www.luogu.com.cn/problem/AT_abc215_g
啥啊。原来要拆贡献。

观察到类根号的复杂度，考虑把出现次数相同的数放在一起计算，元素种类就只有 \(O(\sqrt n)\) 个了。
DP 不太能处理这样的多重结构，故需要考虑更线性的计算方式，这里进行了拆贡献。
考虑一个出现了 \(c\) 次的数被选入的概率，为 \(1-\dfrac {C_{n-c}^K}{C_{n}^K}\)。相加即可。


#include &lt;bits/stdc++.h&gt;
const int mod = 998244353;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n;
    std::cin &gt;&gt; n;
    std::unordered_map&lt;int, int&gt; cnt;
    for (int i = 1, x; i &lt;= n; ++i)
        std::cin &gt;&gt; x, ++cnt[x];
    std::vector&lt;int&gt; b;
    for (auto [x, y] : cnt)
        b.push_back(y);
    std::sort(b.begin(), b.end());
    std::vector&lt;std::pair&lt;int, int&gt; &gt; a;
    std::vector&lt;long long&gt; fac(n + 1), inv(n + 1);
    fac[0] = inv[0] = 1ll;
    for (int i = 1; i &lt;= n; ++i)
        fac[i] = fac[i - 1] * i % mod;
    auto qkp = [&amp;](long long x, int y) &#123;
        auto res = 1ll;
        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)
            if (y &amp; 1)
                (res *= x) %= mod;
        return res;
    &#125;;
    inv[n] = qkp(fac[n], mod - 2);
    for (int i = n - 1; i; --i)
        inv[i] = inv[i + 1] * (i + 1) % mod;
    for (auto i : b)
        if (a.empty() || i != a.back().first)
            a.emplace_back(i, 1);
        else
            ++a.back().second;
    auto C = [&amp;](int n, int m) &#123;
        if (n &lt; m)
            return 0ll;
        return fac[n] * inv[m] % mod * inv[n - m] % mod;
    &#125;;
    for (int k = 1; k &lt;= n; ++k) &#123;
        auto res = 0ll;
        auto invC = qkp(C(n, k), mod - 2);
        for (auto [c, m] : a)
            res += m * (1ll + mod - C(n - c, k) * invC % mod);
        std::cout &lt;&lt; res % mod &lt;&lt; &#39;\n&#39;;
    &#125;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;


A - Catastrophic Roulette
https://www.luogu.com.cn/problem/AT_arc174_c

B - Swap Permutation
https://www.luogu.com.cn/problem/AT_arc176_d

发现最后关心的位置比较少，只有 \(O(n)\) 个。同时发现一件事：假设 \(A_i=x,A_{i+1}=y\)，那么最后 \(A_i\) 和 \(A_{i+1}\) 的值的可能情况只有：
\((x,y)\)，\((x,?)\)，\((y,x)\)，\((y,?)\)，\((?,x)\)，\((?,y)\)，\((?,?)\)
这 7 种情况。且每种情况的期望是相对好算的。发现每种情况出现的概率可以用矩阵求解。
发现矩阵有点大。题解区中的处理方法之一是经典的偏序 + 01，但为什么不能沿用原本的思路呢？
进一步把 \(A,B\) 视作同一个数，这样状态数就减少到 3 种 \((0,0),(0,1)/(1,0),(1,1)\)，相应的期望也是好算的，且矩阵大小会减少很多。
\[
M=\begin{bmatrix}
\dfrac {(n-2)(n-3)}2+1+2(n-4)&amp;2\times 2&amp;0\\
n-3&amp;2+(n-3)+\dfrac {(n-2)(n-3)}2&amp;1\\
0&amp;(n-2)\times 2&amp;1+\dfrac {(n-2)(n-3)}2
\end{bmatrix}
\]
检查技巧：保证每一行的和均为 \(\dfrac {n(n-1)}2\) 即可。


#include &lt;bits/stdc++.h&gt;
const int mod = 998244353, inv2 = (mod + 1) &gt;&gt; 1, N = 3;
struct mat &#123;
    std::vector&lt;std::vector&lt;long long&gt; &gt; a;
    mat(void): a(N, std::vector&lt;long long&gt; (N)) &#123;&#125;
    std::vector&lt;long long&gt;&amp; operator[](const int q) &#123;
        return a[q];
    &#125;
    mat operator* (mat &amp;q) const &#123;
        mat res;
        for (int i = 0; i &lt; N; ++i)
            for (int k = 0; k &lt; N; ++k)
                for (int j = 0; j &lt; N; ++j)
                    if ((res[i][j] += a[i][k] * q[k][j] % mod) &gt;= mod)
                        res[i][j] -= mod;
        return res;
    &#125;
&#125;;
struct vec &#123;
    std::vector&lt;long long&gt; a;
    vec(void): a(N) &#123;&#125;
    long long&amp; operator[](const int q) &#123;
        return a[q];
    &#125;
    vec operator* (mat &amp;q) const &#123;
        vec res;
        for (int k = 0; k &lt; N; ++k)
            for (int j = 0; j &lt; N; ++j)
                if ((res[j] += a[k] * q[k][j] % mod) &gt;= mod)
                    res[j] -= mod;
        return res;
    &#125;
&#125;;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    long long n, m;
    std::cin &gt;&gt; n &gt;&gt; m;
    std::vector&lt;long long&gt; a(n + 1);
    for (int i = 1; i &lt;= n; ++i)
        std::cin &gt;&gt; a[i];
    if (n == 2) &#123;
        std::cout &lt;&lt; std::abs(a[1] - a[2]) &lt;&lt; &#39;\n&#39;;
        return 0;
    &#125;
    auto qkp = [&amp;](long long x, int y) &#123;
        auto res = 1ll;
        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)
            if (y &amp; 1)
                (res *= x) %= mod;
        return res;
    &#125;;
    vec d;
    d[2] = 1ll;
    mat t;
    t[0][0] = ((n - 2) * (n - 3) / 2 + 1 + 2 * (n - 4)) % mod;
    t[0][1] = 2 * 2;
    t[1][0] = n - 3;
    t[1][1] = (2 + (n - 3) + (n - 2) * (n - 3) / 2) % mod;
    t[1][2] = 1;
    t[2][1] = (n - 2) * 2 % mod;
    t[2][2] = (1 + (n - 2) * (n - 3) / 2) % mod;
    for (int i = m; i; i &gt;&gt;= 1, t = t * t)
        if (i &amp; 1)
            d = d * t;
    auto s = 0ll;
    auto calc = [&amp;](long long l, long long r) &#123;
        return (l + r) * (r - l + 1) / 2 % mod;
    &#125;;
    for (int i = 1; i &lt;= n; ++i)
        s += (calc(i + 1, n) + mod - (long long)i * (n - (i + 1) + 1) % mod) % mod;
    auto res = 0ll, invM = qkp((long long)(n - 2) * (n - 3) / 2 % mod, mod - 2), invN2 = qkp(n - 2, mod - 2);
    for (int i = 1; i &lt; n; ++i) &#123;
        auto k = (calc(a[i] + 1, n) - a[i] * (n - (a[i] + 1) + 1) % mod + a[i] * (a[i] - 1) % mod - calc(1, a[i] - 1) - std::abs(a[i] - a[i + 1]) + calc(a[i + 1] + 1, n) - a[i + 1] * (n - (a[i + 1] + 1) + 1) % mod + a[i + 1] * (a[i + 1] - 1) % mod - calc(1, a[i + 1] - 1) - std::abs(a[i] - a[i + 1])) % mod, t = (s - k - std::abs(a[i] - a[i + 1])) % mod;
        res += t * invM % mod * d[0] % mod;
        res += d[1] % mod * invN2 % mod * inv2 % mod % mod * k % mod;
        res += std::abs(a[i] - a[i + 1]) * d[2] % mod;
    &#125;
    std::cout &lt;&lt; (res % mod + mod) % mod &lt;&lt; &#39;\n&#39;;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;


C - Random Walk on Tree
https://www.luogu.com.cn/problem/AT_arc185_d

即一个根上挂了 \(n\div m\) 条长为 \(m\) 的链。令 \(f_i\) 表示走到一条链底

]]></content>
      <tags>
        <tag>计数</tag>
      </tags>
  </entry>
  <entry>
    <title>杂文速读</title>
    <url>/20251118-1/</url>
    <content><![CDATA[知识点征集速报!!!! 第一期


01BFS 的扩展：定边权集 BFS

给定无向图，边权只会为 1 或 2，在线性复杂度内求出 \(s\to t\) 的最短路。

无法直接使用双端队列：\(1\) 直接加入队首会破坏单调性。
处理方式是开两个队列，对于两种边权分别放到队尾，取两个队首中更小的进行扩展。

给定无向图，边权集大小为常数，在线性复杂度内求出 \(s\to t\) 的最短路。

开常数个队列，类似地处理即可。


]]></content>
  </entry>
  <entry>
    <title>性质题</title>
    <url>/20251124/</url>
    <content><![CDATA[一身素青纱 ⚡ 草柄当头花 ⚡


A - Maximum Diameter
https://www.luogu.com.cn/problem/AT_abc290_f

考虑一个固定的序列，很容易发现可以用叶子来调整，使得树成为毛毛虫。
故最长直径为 \(n-cnt_1+2\)，其中 \(cnt_1\) 为叶子个数。
发现只需要 \(\forall\,i,a_i&gt;0\) 且 \(\sum a_i=2n-2\)，那么就有解。枚举叶子个数 \(k\) 再插板法算方案，得到答案为：
\[
\sum_{k=2}^{n-1} \binom{2n-2-k-(n-k)-1}{n-k-1}\times \binom nk\times (n-k+1)
\]
BB：注意边数比点数少 1。
题目没保证 \(\sum n\) 的范围，系数会变也不太方便预处理，考虑变形：
\[
\begin{aligned}
&amp;\sum_{k=2}^{n-1} \binom{n-3}{k-2}\times \binom n{k}\times (n-k+1)\\
=&amp;(n+1)\sum_{k=2}^{n-1} \binom{n-3}{k-2}\times \binom n{k}-\sum_{k=2}^{n-1} k\times \binom n{k}\times \binom{n-3}{k-2}\\
=&amp;(n+1)\binom{2n-3}{n-2}-n\times \sum_{k=2}^{n-1} \binom {n-1}{k-1}\times \binom{n-3}{k-2}\\
=&amp;(n+1)\times\binom{2n-3}{n-2}-n\times\binom{2n-4}{n-2}\\
\end{aligned}
\]
用到了：\(k\cdot C_n^k=n\cdot C_{n-1}^{k-1}\)、范德蒙德卷积 \(\sum_{i=0}^k C_n^i\cdot C_m^{k-i}=C_{n+m}^k\)。
只想说这种只涉及到高中组合知识，且放到高考数学卷子里我都拿不到分的式子就不要拿来考我了 :-)


#include &lt;bits/stdc++.h&gt;
const int mod = 998244353;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    const int N = 2e6;
    std::vector&lt;long long&gt; fac(N + 1), inv(N + 1);
    fac[0] = inv[0] = 1ll;
    for (int i = 1; i &lt;= N; ++i)
        fac[i] = fac[i - 1] * i % mod;
    auto qkp = [&amp;](long long x, int y) &#123;
        auto res = 1ll;
        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)
            if (y &amp; 1)
                (res *= x) %= mod;
        return res;
    &#125;;
    inv[N] = qkp(fac[N], mod - 2);
    for (int i = N - 1; i; --i)
        inv[i] = inv[i + 1] * (i + 1) % mod;
    auto C = [&amp;](int n, int m) &#123;
        return fac[n] * inv[m] % mod * inv[n - m] % mod;
    &#125;;
    int T;
    for (std::cin &gt;&gt; T; T--; ) &#123;
        int n;
        std::cin &gt;&gt; n;
        std::cout &lt;&lt; ((n + 1) * C(2 * n - 3, n - 2) + mod - n * C(2 * n - 4, n - 2) % mod) % mod &lt;&lt; &#39;\n&#39;;
    &#125;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;


B - Game on Graph
https://www.luogu.com.cn/problem/AT_abc261_h
merchant 统治全世界……

令 \(f_{u,0/1}\) 表示在 \(x\) 点且 A / B 执棋时的代价。则：
\[
f_{u,0}\gets \min\{f_{v,1}+w\}\\
f_{u,1}\gets \max\{f_{v,0}+w\}
\]
容易发现这大概是一个 Dij 的结构，对于出度为 \(0\) 的点 \(u\) 有 \(f_{u,0}=f_{u,1}=0\)，且出度为 \(0\) 恰好符合拓扑序，可以参照 merchant 中的处理方式，以 \(f_{*,0}\) 为主体做最短路 Dij，待 \(f_{*,1}\) 的出边将其更新完后加入优先队列（容易发现这个拓扑结构让它只会入队一次）。
虽然过程很简单，但是思想很巧妙。总之可以看一看，结合 merchant 思考一下。


#include &lt;bits/stdc++.h&gt;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    const long long inf = 1e18;
    int n, m, s;
    std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; s;
    std::vector&lt;int&gt; deg(n + 1);
    std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; g(n + 1);
    for (int x, y, w; m--; ) &#123;
        std::cin &gt;&gt; x &gt;&gt; y &gt;&gt; w;
        g[y].emplace_back(x, w);
        ++deg[x];
    &#125;
    std::vector&lt;int&gt; vis(n + 1);
    std::vector&lt;std::vector&lt;long long&gt; &gt; dis(n + 1, std::vector&lt;long long&gt; (2));
    struct node &#123;
        long long w;
        int k, x;
        bool operator&lt; (const node &amp;q) const &#123;
            return w &gt; q.w;
        &#125;
    &#125;;
    std::priority_queue&lt;node&gt; q;
    for (int i = 1; i &lt;= n; ++i)
        if (!deg[i]) &#123;
            dis[i][0] = dis[i][1] = 0ll;
            q.push(&#123; 0ll, 0, i &#125;);
            q.push(&#123; 0ll, 1, i &#125;);
        &#125;
        else
            dis[i][0] = inf;
    for (; !q.empty(); ) &#123;
        auto [d, k, x] = q.top();
        q.pop();
        if (k == 0) &#123;
            if (vis[x])
                continue;
            vis[x] = 1;
            for (auto [i, w] : g[x]) &#123;
                dis[i][1] = std::max(dis[i][1], std::min(d + w, inf));
                if (!--deg[i])
                    q.push(&#123; dis[i][1], 1, i &#125;);
            &#125;
        &#125;
        else
            for (auto [i, w] : g[x])
                if (dis[i][0] &gt; d + w) &#123;
                    dis[i][0] = d + w;
                    q.push(&#123; dis[i][0], 0, i &#125;);
                &#125;
    &#125;
    if (dis[s][0] == inf)
        std::cout &lt;&lt; &quot;INFINITY\n&quot;;
    else
        std::cout &lt;&lt; dis[s][0] &lt;&lt; &#39;\n&#39;;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;


C - Vertex Pairs
https://www.luogu.com.cn/problem/CF2042E
全新做法

有一个 naive 的想法：check 删去 \(n\) 后是否存在合法连通块。
如果存在，则至少有一个元素（\(a_n\)）只被一个连通块包含，那么答案连通块一定是这一个。
否则，说明 \(n\) 必选——这种情况当且仅当 \(n\) 的每一个子树（父亲）都不包含所有值时出现。
扩展一下，DFS 序 + 线段树统计信息（DS 大师自有办法），找到最后一个不必选的点，然后把它裂开，找到唯一合法连通块，抹掉被删掉的所有点的信息，重复这个过程即可，复杂度很对。
至于怎么统计这样的信息，点是两两配对的，以 DFS 序记录每一对 \((l, r)\)，对于 \(x\) 的子树，其存在不包含的值当且仅当，DFS 序区间落在 \([1,l)\)，或 \((l, r)\)，或 \((r+1,n)\)。维护每个 \(i\) 作为左端点，需求的最小右端点即可。
对于父亲方向的连通块，其存在不包含的值当且仅当，有某个 \([l,r]\) 完全落在 \(x\) 内。同样是好维护的。
这样就获得了 \(O(n\log n)\) 的暴力 DS 做法。没有任何思维点！


#include &lt;bits/stdc++.h&gt;
const int maxn = 4e5 + 5;
struct &#123;
    int l, r, u, mn, d;
&#125; t[maxn &lt;&lt; 2];
#define lt (p &lt;&lt; 1)
#define rt (lt | 1)
void bld(int p, int l, int r) &#123;
    t[p].mn = 0x3f3f3f3f;
    t[p].l = l, t[p].r = r;
    if (l == r)
        return;
    int mid = (l + r) &gt;&gt; 1;
    bld(lt, l, mid), bld(rt, mid + 1, r);
    return;
&#125;
void pushdown(int p) &#123;
    if (t[p].d) &#123;
        t[lt].u = std::max(t[lt].u, t[p].d);
        t[lt].d = std::max(t[lt].d, t[p].d);
        t[rt].u = std::max(t[rt].u, t[p].d);
        t[rt].d = std::max(t[rt].d, t[p].d);
        t[p].d = 0;
    &#125;
    return;
&#125;
void add(int p, int x, int v) &#123;
    t[p].mn = std::min(t[p].mn, v);
    if (t[p].l == t[p].r)
        return;
    int mid = (t[p].l + t[p].r) &gt;&gt; 1;
    if (x &lt;= mid)
        add(lt, x, v);
    else
        add(rt, x, v);
    return;
&#125;
void add(int p, int l, int r, int v) &#123;
    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r) &#123;
        t[p].u = std::max(t[p].u, v);
        t[p].d = std::max(t[p].d, v);
        return;
    &#125;
    pushdown(p);
    int mid = (t[p].l + t[p].r) &gt;&gt; 1;
    if (l &lt;= mid)
        add(lt, l, r, v);
    if (r &gt; mid)
        add(rt, l, r, v);
    t[p].u = std::max(t[lt].u, t[rt].u);
    return;
&#125;
int asku(int p, int x) &#123;
    if (t[p].l == t[p].r)
        return t[p].u;
    pushdown(p);
    int mid = (t[p].l + t[p].r) &gt;&gt; 1;
    if (x &lt;= mid)
        return asku(lt, x);
    return asku(rt, x);
&#125;
int askmn(int p, int l, int r) &#123;
    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r)
        return t[p].mn;
    int mid = (t[p].l + t[p].r) &gt;&gt; 1, res = 0x3f3f3f3f;
    if (l &lt;= mid)
        res = askmn(lt, l, r);
    if (r &gt; mid)
        res = std::min(res, askmn(rt, l, r));
    return res;
&#125;
#undef lt
#undef rt
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n;
    std::cin &gt;&gt; n;
    std::vector&lt;int&gt; a(2 * n + 1);
    for (int i = 1; i &lt;= 2 * n; ++i)
        std::cin &gt;&gt; a[i];
    std::vector&lt;std::vector&lt;int&gt; &gt; g(2 * n + 1);
    for (int i = 1, x, y; i &lt; 2 * n; ++i) &#123;
        std::cin &gt;&gt; x &gt;&gt; y;
        g[x].push_back(y), g[y].push_back(x);
    &#125;
    std::vector&lt;int&gt; dfn(2 * n + 1), rfn(2 * n + 1), fa(2 * n + 1), s(n + 1);
    std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;
        static int now = 0;
        dfn[x] = ++now, s[a[x]] += now;
        for (auto i : g[x])
            if (i != fa[x])
                fa[i] = x, DFS(i);
        rfn[x] = now;
        return;
    &#125;;
    DFS(1);
    std::vector&lt;int&gt; la(n + 1);
    bld(1, 1, 2 * n);
    for (int i = 1; i &lt;= 2 * n; ++i)
        if (la[a[i]]) &#123;
            int l = dfn[la[a[i]]], r = dfn[i];
            if (l &gt; r)
                std::swap(l, r);
            add(1, l, r);
            if (l != 1)
                add(1, 1, l - 1, l);
            if (l + 1 &lt;= r - 1)
                add(1, l + 1, r - 1, r);
            if (r != 2 * n)
                add(1, r + 1, 2 * n, 0x3f3f3f3f);
        &#125;
        else
            la[a[i]] = i;
    std::vector&lt;int&gt; del(2 * n + 1), res;
    for (int i = 2 * n; i; --i)
        if (!del[i]) &#123;
            int to = 0;
            for (auto j : g[i])
                if (!del[j] &amp;&amp; j != fa[i] &amp;&amp; asku(1, dfn[j]) &lt;= rfn[j]) &#123;
                    to = j;
                    break;
                &#125;
            if (!to &amp;&amp; (!fa[i] || del[fa[i]] || askmn(1, dfn[i], rfn[i]) &lt;= rfn[i]))
                res.push_back(i);
            else &#123;
                std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int fa) &#123;
                    assert(s[a[x]] &gt; dfn[x]);
                    s[a[x]] -= dfn[x];
                    add(1, s[a[x]], s[a[x]]);
                    if (s[a[x]] &lt; dfn[x]) &#123;
                        if (s[a[x]] != 2 * n)
                            add(1, s[a[x]] + 1, 2 * n, 0x3f3f3f3f);
                    &#125;
                    else
                        add(1, 1, s[a[x]], s[a[x]]);
                    del[x] = 1;
                    for (auto i : g[x])
                        if (!del[i] &amp;&amp; i != fa)
                            DFS(i, x);
                    return;
                &#125;;
                DFS(i, to ? to : fa[i]);
            &#125;
        &#125;
    std::cout &lt;&lt; (int)res.size() &lt;&lt; &#39;\n&#39;;
    std::reverse(res.begin(), res.end());
    for (auto i : res)
        std::cout &lt;&lt; i &lt;&lt; &#39; &#39;;
    std::cout &lt;&lt; &#39;\n&#39;;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;


D - Tree and Hamilton Path
https://www.luogu.com.cn/problem/AT_agc018_d
很难

如果问的是哈密顿回路，做法：
枚举每条边 \((u, v)\)

]]></content>
  </entry>
  <entry>
    <title>杂题选谈</title>
    <url>/20251118/</url>
    <content><![CDATA[古人总说：『日出而作，日落而息』。既然如此，在冬天的阴天就应该安眠一个下午。

但这样总有被误认为冬眠动物的风险。实际上是全年无休地努力摸鱼着！

C. meat
https://www.becoder.com.cn/contest/6752/problem/3

给定一个 \(n\) 个点 \(m\) 条边的简单无向图，点有点权，问图中所有四元环的权值和，对 \(10^9+7\) 取模。
\(n,m\le 10^5\)。


容易想到 meet in middle 的做法：把四元环 \((1,2,3,4)\) 拆解为 \(1-2-3\) 和 \(1-4-3\) 两个部分，从 \(1\) 出发，找到所有和 \(1\) 的距离为 \(2\) 的点 \(3&#39;\)，在 \(3\) 处完成统计。
做这么一件事：在每次『从 \(u\) 出发，找到所有和 \(u\) 的距离为 \(2\) 的点』之后，从图中删去 \(u\)。容易发现删点不会影响正确性。
注意这里要用 BFS 而非 DFS 保证复杂度。
钦定按点的度数从大到小做这个过程，则复杂度为 \(O(m\sqrt m)\)。证明参考三元环，考虑根号分治：

当点 \(u\) 的度数 \(deg_u&gt;\sqrt m\) 时，由于 \(\sum deg=2m\)，这样的点有 \(O(\sqrt m)\) 个；暴力 BFS 两步时，最劣复杂度为 \(O(m)\)。故该种情况下复杂度为 \(O(m\sqrt m)\)。
否则，\(deg_u\le \sqrt m\) 时，由于度数更大的都被删除了，\(u\) 能 BFS 到的点度数一定比 \(u\) 更小。
注意区分这一步和三元环重定向的区别：此时仍然允许在第 2 个点 \(\to\) 第 3 个点时，由小度数走向大度数，否则无法完全统计。三元环能重定向的原因是，不管如何重定向，三元环中总能找到一条 \(a\to b\to c\) 的有向路径。
故此时两步 BFS 的复杂度上界为 \(O({deg_u}^2)\)。
考虑整体复杂度上界，即找到一种对 \(2m\) 的划分方式，使得每一个元素不超过 \(\sqrt m\)，且最大化 \(\sum {deg_u}^2\)。最劣情况显然是全部取 \(\sqrt m\)，此时复杂度为 \(O(m\sqrt m)\)。

综上，整体复杂度为 \(O(m\sqrt m)\)，而且非常不满。

By the way, 无向图三元环计数？
按照大度数 \(\to\) 小度数对边重定向。由于三元环需要的信息更少，只需要 check『走两步能走到的点』和『走一步能走到的点』的交集，但仍需要两步 BFS。
根号分治证明复杂度，证明过程几乎一致。不赘述。



#include &lt;bits/stdc++.h&gt;
const int mod = 1e9 + 7;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
    std::freopen(&quot;meat.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;meat.out&quot;, &quot;w&quot;, stdout);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, m;
    std::cin &gt;&gt; n &gt;&gt; m;
    std::vector&lt;long long&gt; a(n + 1);
    for (int i = 1; i &lt;= n; ++i)
        std::cin &gt;&gt; a[i];
    std::vector&lt;int&gt; deg(n + 1), id(n);
    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);
    for (int x, y; m--; ) &#123;
        std::cin &gt;&gt; x &gt;&gt; y;
        ++deg[x], ++deg[y];
        g[x].push_back(y), g[y].push_back(x);
    &#125;
    std::iota(id.begin(), id.end(), 1);
    std::sort(id.begin(), id.end(), [&amp;](int i, int j) &#123; return deg[i] &gt; deg[j]; &#125;);
    std::vector&lt;long long&gt; s(n + 1);
    std::vector&lt;int&gt; tag(n + 1), cnt(n + 1);
    auto res = 0ll;
    for (auto i : id) &#123;
        std::vector&lt;int&gt; pos;
        tag[i] = 1;
        for (auto j : g[i]) 
            if (!tag[j])
                for (auto k : g[j])
                    if (!tag[k]) &#123;
                        pos.push_back(k);
                        ++cnt[k], (s[k] += a[j]) %= mod;
                    &#125;
        for (auto j : pos)
            if (cnt[j]) &#123;
                res += s[j] * (cnt[j] - 1) % mod;
                res += (a[i] + a[j]) % mod * (cnt[j] * (cnt[j] - 1) / 2 % mod) % mod;
                cnt[j] = s[j] = 0;
            &#125;
        res %= mod;
    &#125;
    std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;


B. port
https://www.becoder.com.cn/contest/6767/problem/2

给定 \(n\times n\) 的棋盘，初始放置了 \(k\) 个棋子 \((x_i, y_i)\)。现在可以额外放置若干棋子，问有多少种方案满足：

在最终的棋盘上，任意 \(m\times m\) 的矩形中，恰有一个棋子。

对 \(998244353\) 取模。
多测，\(T\le 2\times 10^5,m\le n\le 10^6,k\le \min(n^2,2\times 10^5),\sum k\le 2\times 10^5\)。


需要高强度手玩，然后概括出以下事实：

两个棋子不冲突的充要条件：行差为 \(m\) 的倍数或列差为 \(b\) 的倍数。
初始棋子不冲突的充要条件：任意两个棋子满足上一条。
合法局面的充要条件：每一行的棋子的列差均为 \(m\)，或每一列的棋子行差均为 \(m\)。

这样，只有第一行 / 列的选取是相对自由的。由此可以得到 \(k=0\) 时的答案：
\[
2\times(m^{\left\lfloor\frac{n}{m}\right\rfloor}\times(m-n\bmod m)+m^{\left\lfloor\frac{n}{m}\right\rfloor+1}\times(n\bmod m))-m^2
\]
对于 \(k\ne 0\) 的情况，统计两种填数方式一路上可以塞数的位置，顺便判定合法性即可。


#include &lt;bits/stdc++.h&gt;
const int mod = 998244353;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
    std::freopen(&quot;port.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;port.out&quot;, &quot;w&quot;, stdout);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int T;
    auto qkp = [&amp;](long long first, int second) &#123;
        auto res = 1ll;
        for (; second; (first *= first) %= mod, second &gt;&gt;= 1)
            if (second &amp; 1)
                (res *= first) %= mod;
        return res;
    &#125;;
    for (std::cin &gt;&gt; T; T--; ) &#123;
        int k;
        long long n, m;
        std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;
        std::vector&lt;std::pair&lt;int, int&gt; &gt; a(k + 1);
        for (int i = 1; i &lt;= k; ++i)
            std::cin &gt;&gt; a[i].first &gt;&gt; a[i].second;
        auto res = 0ll;
        if (m == 1) &#123;
            std::cout &lt;&lt; 1 &lt;&lt; &#39;\n&#39;;
            continue;
        &#125;
        if (k == 0) &#123;
            auto res = qkp(m, n / m) * (m + mod - n % m) % mod + qkp(m, n / m + 1) * (n % m) % mod;
            res = 2 * res % mod + mod - m * m % mod;
            std::cout &lt;&lt; res % mod &lt;&lt; &#39;\n&#39;;
            continue;
        &#125;
        std::sort(a.begin() + 1, a.end());
        int la = 0, now = 0;
        bool flag1 = true, flag2 = true;
        for (int i = 1, j = 1; i &lt;= k; i = j + 1) &#123;
            now = now + std::max(0ll, (a[i].first - la - 1) / m);
            if (la &amp;&amp; (a[i].first - la) % m != 0)
                flag1 = false;
            la = a[i].first;
            for (j = i; j &lt;= k &amp;&amp; a[i].first == a[j].first; ++j);
            --j;
            for (int k = i + 1; k &lt;= j; k++)
                if ((a[k].second - a[k - 1].second) % m != 0)
                    flag1 = false;
            i = j;
        &#125;
        now += (n - la) / m;
        if (flag1)
            (res += qkp(m, now)) %= mod;
        la = 0, now = 0;
        std::sort(a.begin() + 1, a.end(), [&amp;](auto &amp;x, auto &amp;y) &#123; return x.second == y.second ? x.first &lt; y.first : x.second &lt; y.second; &#125;);
        for (int i = 1, j = 1; i &lt;= k; i = j + 1) &#123;
            now = now + std::max(0ll, (a[i].second - la - 1) / m);
            if (la &amp;&amp; (a[i].second - la) % m != 0)
                flag2 = false;
            la = a[i].second;
            for (j = i; j &lt;= k &amp;&amp; a[i].second == a[j].second; ++j);
            --j;
            for (int k = i + 1; k &lt;= j; k++)
                if ((a[k].first - a[k - 1].first) % m != 0)
                    flag2 = false;
            i = j;
        &#125;
        now += (n - la) / m;
        if (flag2)
            (res += qkp(m, now)) %= mod;
        if (flag1 &amp;&amp; flag2)
            (res += mod - 1) %= mod;
        std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
    &#125;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;


C. west
https://www.becoder.com.cn/contest/6767/problem/3

给定长度为 \(n\) 的两个栈 A, B，两个栈内的元素分别是 \(n\) 的一个排列。通过执行以下操作构造一个序列：

（当 A 剩余元素不为 1 时）将 B 的栈顶加入序列，并弹出 A 的栈顶。
（当 B 剩余元素不为 1 时）将 A 的栈顶加入序列，并弹出 B 的栈顶。

容易发现最后的序列长总为 \(2n-2\)。问可以构造出多少种序列。对 \(998244353\) 取模。
\(n\le 5000\)。

机房里只有 1 个神仙、1 个人切了 T3。总算是得瑟上一回了！

发现：如果存在两种操作方式，使得它们结果序列的 \(1\sim i\) 项相同，那么可以转化为，它们的 \(1\sim i-1\) 相同，且第 \(i\) 项相同。
设 \(f_{i,j,0/1/2}\) 表示结果序列的第 \(i\) 项为 \(j\)，这个 \(j\) 由 A 贡献 / 由 B 贡献 / AB 都可以贡献的方案数。
发现用 \(i,j,0/1/2\) 三个信息可以唯一确定当前 A B 两个栈的状态（利用排列这个条件），然后就可以填表转移了。
需要注意的地方：\(f_{i,j,2}\) 用 A, B 反推可能得到不一样的结果（设为 \((A_1,B_1)/(A_2,B_2)\)），此时两种结果都有可能分岔 / 合并，共 \(2\times 2=4\) 种组合方式。
利用 \(A_1\ne A_2\land B_1\ne B_2\) 这一点可以发现，不会出现用 \(A_1,A_2,B_1,B_2\) 中的超过两个转移得到同样结果的情况。
反过来，可以像这里一样设 \(f_{*,*,2}\) 是因为我们默认了，如果一个状态可以通过多种转移路径得到，那么一定是恰好两种。
虽然比官方做法简单 10086 倍，但似乎过于凑巧了。
最后的答案为 \(\sum\limits_i f_{2n-2,i,*}\)。


一定要注意用 A, B 转移对应的条件是 B, A。
#include &lt;bits/stdc++.h&gt;
const int mod = 998244353;
int main() &#123;
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
    std::freopen(&quot;west.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;west.out&quot;, &quot;w&quot;, stdout);
    auto stime = std::chrono::steady_clock::now();
    int n;
    std::cin &gt;&gt; n;
    std::vector&lt;int&gt; a(n + 1), b(n + 1), pa(n + 1), pb(n + 1);
    for (int i = 1; i &lt;= n; ++i)
        std::cin &gt;&gt; a[i], pa[a[i]] = i;
    for (int i = 1; i &lt;= n; ++i)
        std::cin &gt;&gt; b[i], pb[b[i]] = i;
    using arr = std::vector&lt;long long&gt;;
    using brr = std::vector&lt;arr&gt;;
    using crr = std::vector&lt;brr&gt;;
    crr f(2, brr(n + 1, arr(3)));
    if (a[1] == b[1])
        f[1][a[1]][2] = 1ll;
    else
        f[1][a[1]][0] = f[1][b[1]][1] = 1ll;
    for (int i = 1, k = 1; i &lt; 2 * n - 2; ++i, k ^= 1) &#123;
        for (int j = 1; j &lt;= n; ++j)
            f[k ^ 1][j][0] = f[k ^ 1][j][1] = f[k ^ 1][j][2] = 0ll;
        for (int j = 1; j &lt;= n; ++j) &#123;
            if (f[k][j][0]) &#123;
                auto v = f[k][j][0];
                int A = pa[j], B = i - (A - 1) + 1;
                if (A != n &amp;&amp; B != n &amp;&amp; a[A] == b[B])
                    f[k ^ 1][a[A]][2] += v;
                else &#123;
                    if (B != n)
                        f[k ^ 1][a[A]][0] += v;
                    if (A != n)
                        f[k ^ 1][b[B]][1] += v;
                &#125;
            &#125;
            if (f[k][j][1]) &#123;
                auto v = f[k][j][1];
                int B = pb[j], A = i - (B - 1) + 1;
                if (A != n &amp;&amp; B != n &amp;&amp; a[A] == b[B])
                    f[k ^ 1][a[A]][2] += v;
                else &#123;
                    if (B != n)
                        f[k ^ 1][a[A]][0] += v;
                    if (A != n)
                        f[k ^ 1][b[B]][1] += v;
                &#125;
            &#125;
            if (f[k][j][2]) &#123;
                int A1 = pa[j], B1 = i - (A1 - 1) + 1;
                int B2 = pb[j], A2 = i - (B2 - 1) + 1;
                auto v = f[k][j][2];
                if (A1 == A2) &#123;
                    if (A1 != n &amp;&amp; B1 != n &amp;&amp; a[A1] == b[B1])
                        f[k ^ 1][a[A1]][2] += v;
                    else &#123;
                        if (B1 != n)
                            f[k ^ 1][a[A1]][0] += v;
                        if (A1 != n)
                            f[k ^ 1][b[B1]][1] += v;
                    &#125;
                &#125;
                else &#123;
                    int fA1 = 0, fB1 = 0, fA2 = 0, fB2 = 0;
                    if (A1 != n &amp;&amp; B1 != n &amp;&amp; a[A1] == b[B1]) &#123;
                        f[k ^ 1][a[A1]][2] += v;
                        fA1 = fB1 = 1;
                    &#125;
                    if (A1 != n &amp;&amp; B2 != n &amp;&amp; a[A2] == b[B1]) &#123;
                        f[k ^ 1][a[A2]][2] += v;
                        fA2 = fB1 = 1;
                    &#125;
                    if (A2 != n &amp;&amp; B1 != n &amp;&amp; a[A1] == b[B2]) &#123;
                        f[k ^ 1][a[A1]][2] += v;
                        fA1 = fB2 = 1;
                    &#125;
                    if (A2 != n &amp;&amp; B2 != n &amp;&amp; a[A2] == b[B2]) &#123;
                        f[k ^ 1][a[A2]][2] += v;
                        fA2 = fB2 = 1;
                    &#125;
                    if (!fA1 &amp;&amp; B1 != n)
                        f[k ^ 1][a[A1]][0] += v;
                    if (!fB1 &amp;&amp; A1 != n)
                        f[k ^ 1][b[B1]][1] += v;
                    if (!fA2 &amp;&amp; B2 != n)
                        f[k ^ 1][a[A2]][0] += v;
                    if (!fB2 &amp;&amp; A2 != n)
                        f[k ^ 1][b[B2]][1] += v;
                &#125;
            &#125;
        &#125;
        for (int j = 1; j &lt;= n; ++j) &#123;
            f[k ^ 1][j][0] %= mod;
            f[k ^ 1][j][1] %= mod;
            f[k ^ 1][j][2] %= mod;
        &#125;
    &#125;
    auto res = 0ll;
    for (int j = 1; j &lt;= n; ++j)
        res += (f[0][j][0] + f[0][j][1] + f[0][j][2]) % mod;
    std::cout &lt;&lt; res % mod &lt;&lt; &#39;\n&#39;;
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt;(std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
    return 0;
&#125;


D. egypt
https://www.becoder.com.cn/contest/6767/problem/4

给定字符串 \(s_{1\cdots n}，\)序列 \(h_{1\cdots n}\)、\(d_{1\cdots n}\) 和 \(w_{1\cdots n}\) 和参数 \(k\)。
定义 \(pre_k\) 为 \(s\) 长度为 \(k\) 的前缀。
定义 \(g(s_1, s_2)\) 为所有满足下列条件的字符串 \(t\) 组成的集合：

\(t\) 是 \(s_1,s_2\) 的公共后缀，且 \(t\) 是 \(s\) 的前缀。

求：
\[
\sum_{i\le j} [|h_i-h_j|\le k]\cdot (d_i+d_j)\cdot \max_{t\in g(pre_i, pre_j)} \{w_{|t|}\}
\]
\(n\le 2\times 10^5,h_i\le n,d_i,w_i\le 3000\)。2s。


发现最后一坨是一个 fail 树上的东西，故建出 fail 树森林，并求出每个点处的前缀最大值。
然后发现是一个 dsu on tree，以 \(h\) 为下标，树状数组统计 \(d\) 的和即可。


#include &lt;bits/stdc++.h&gt;
int main() &#123;
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
    std::freopen(&quot;beach.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;beach.out&quot;, &quot;w&quot;, stdout);
    auto stime = std::chrono::steady_clock::now();
    int n, k;
    std::string s;
    std::cin &gt;&gt; n &gt;&gt; k &gt;&gt; s, s = &quot;#&quot; + s;
    std::vector&lt;long long&gt; w(n + 1);
    std::vector&lt;int&gt; h(n + 1), d(n + 1), nex(n + 1);
    for (int i = 1; i &lt;= n; ++i)
        std::cin &gt;&gt; h[i];
    for (int i = 1; i &lt;= n; ++i)
        std::cin &gt;&gt; d[i];
    for (int i = 1; i &lt;= n; ++i)
        std::cin &gt;&gt; w[i];
    std::vector&lt;int&gt; deg(n + 1), rt;
    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);
    for (int i = 2, j = 0; i &lt;= n; ++i) &#123;
        for (; j &amp;&amp; s[i] != s[j + 1]; j = nex[j]);
        if (s[i] == s[j + 1])
            nex[i] = ++j;
        if (nex[i])
            g[nex[i]].push_back(i), ++deg[i];
    &#125;
    for (int i = 1; i &lt;= n; ++i)
        if (!deg[i])
            rt.push_back(i);
    std::vector&lt;int&gt; siz(n + 1), son(n + 1);
    std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;
        siz[x] = 1;
        for (auto i : g[x]) &#123;
            w[i] = std::max(w[i], w[x]);
            DFS(i);
            siz[x] += siz[i];
            if (siz[i] &gt; siz[son[x]])
                son[x] = i;
        &#125;
        return;
    &#125;;
    for (int i : rt)
        DFS(i);
    auto res = 0ll;
    std::vector&lt;int&gt; bit1(n + 1), bit2(n + 1);
    auto lowbit = [&amp;](int x) &#123; return x &amp; -x; &#125;;
    auto add = [&amp;](int x, int v, int op) &#123;
        for (; x &lt;= n; x += lowbit(x))
            bit1[x] += op, bit2[x] += v;
        return;
    &#125;;
    auto ask = [&amp;](int x) &#123;
        int res1 = 0, res2 = 0;
        for (; x; x -= lowbit(x))
            res1 += bit1[x], res2 += bit2[x];
        return std::make_pair(res1, res2);
    &#125;;
    std::vector&lt;int&gt; dfn(n + 1), rfn(n + 1), tab(n + 1);
    DFS = [&amp;](int x) &#123;
        static int now = 0;
        dfn[x] = rfn[x] = ++now, tab[now] = x;
        if (!son[x]) &#123;
            add(h[x], d[x], 1);
            return;
        &#125;
        for (auto i : g[x])
            if (i != son[x]) &#123;
                DFS(i);
                for (int j = dfn[i]; j &lt;= rfn[i]; ++j)
                    add(h[tab[j]], -d[tab[j]], -1);
            &#125;
        DFS(son[x]);
        auto [c2, s2] = ask(std::min(n, h[x] + k));
        auto [c1, s1] = ask(std::max(0, h[x] - k - 1));
        res += w[x] * ((c2 - c1) * d[x] + (s2 - s1));
        add(h[x], d[x], 1);
        for (auto i : g[x])
            if (i != son[x]) &#123;
                for (int j = dfn[i], v; j &lt;= rfn[i]; ++j) &#123;
                    v = tab[j];
                    auto [c2, s2] = ask(std::min(n, h[v] + k));
                    auto [c1, s1] = ask(std::max(0, h[v] - k - 1));
                    res += w[x] * ((c2 - c1) * d[v] + (s2 - s1));
                &#125;
                for (int j = dfn[i]; j &lt;= rfn[i]; ++j)
                    add(h[tab[j]], d[tab[j]], 1);
            &#125;
        rfn[x] = now;
        return;
    &#125;;
    for (auto i : rt) &#123;
        DFS(i);
        for (int j = dfn[i]; j &lt;= rfn[i]; ++j)
            add(h[tab[j]], -d[tab[j]], -1);
    &#125;
    std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt;(std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
    return 0;
&#125;


A. 千万道伤痕（wound）
https://www.becoder.com.cn/contest/6770/problem/1

给定大小为 \(n\) 的树，根为 \(1\)。每个点 \(u\) 有两个权值 \(a_u,b_u\)。你可以执行任意次下列操作：

选择有连边的两个点 \(u,v\)，其中 \(u\) 为父亲。交换 \(a_u,a_v\) 的值，随后 \(a_u\gets a_u+c,a_v\gets a_v-c\)，\(c\) 为给定常数。

你需要输出经过任意次操作后，\(\sum\limits_u |a_u-b_u|\) 可能达到的最小值。
\(n\le 2\times 10^5,V=[-10^{10},10^{10}]\)。


这类放在 A 题的无限操作类题目可能的手段不多，要么猜字面的最优答案能通过某种方法取到，要么尝试构造能取到的最优解。
发现可以进行重分配，即把所有 \(a,b\) 全部挪到 \(1\) 上，然后分别排序，重分配 \(a,b\)。


#include &lt;bits/stdc++.h&gt;
int main() &#123;
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
    auto stime = std::chrono::steady_clock::now();
    std::freopen(&quot;wound.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;wound.out&quot;, &quot;w&quot;, stdout);
    int n, c;
    std::cin &gt;&gt; n &gt;&gt; c;
    std::vector&lt;long long&gt; a(n + 1), b(n + 1);
    for (int i = 1; i &lt;= n; ++i)
        std::cin &gt;&gt; a[i];
    for (int j = 1; j &lt;= n; ++j)
        std::cin &gt;&gt; b[j];
    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);
    for (int i = 2, x; i &lt;= n; ++i) &#123;
        std::cin &gt;&gt; x;
        g[x].push_back(i);
    &#125;
    std::vector&lt;long long&gt; dep(n + 1);
    std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;
        for (auto i : g[x]) &#123;
            dep[i] = dep[x] + 1;
            DFS(i);
        &#125;
        return;
    &#125;;
    DFS(1);
    for (int i = 1; i &lt;= n; ++i)
        a[i] += c * dep[i], b[i] += c * dep[i];
    std::sort(a.begin(), a.end());
    std::sort(b.begin(), b.end());
    auto res = 0ll;
    for (int i = 1; i &lt;= n; ++i)
        res += std::abs(a[i] - b[i]);
    std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt;(std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
    return 0;
&#125;


B. 猫儿小（mex）/ CF1870G MEXanization
https://www.luogu.com.cn/problem/solution/CF1870G
简单在哪儿？*3300 实至名归。

对于 \(x\) 是最终 mex 的情况，考虑对 \(x\) 的 check：将 \([x+1,\inf]\) 的数通过一次 mex 置为 0。
从 \(p=x-1\) 开始向前遍历。定义 \(need\) 表示对于当前的 \(p\)，额外需要 \([0,p-1]\) 的个数，初值为 \(1\)。对于一次移动：

若 \(cnt_p\ge need\)，则可以将多余的置 0，此时 \(cnt_0\gets cnt_p-need\)。
若 \(cnt_p&lt;need\)，则需要前面凑 \(need-cnt_p\) 个 \(p\) 出来，即 \(need\gets need + cnt_p\)。

此时就有了一个 \(O(n^2)\) 动态增加当前答案的做法。
注意到 \(cnt_p&lt;need\) 发生的次数很少，具体地，每次触发这个事件的 \(p\) 不同，且额外需求 \(p\) 个元素。总共 \(n\) 个元素，最多支持发生 \(\sqrt n\) 次 \(cnt_p&lt;need\) 事件。
此时可以通过 \(\sqrt n\) 次线段树上二分得到所有 \(cnt_p&lt;need\) 事件；对于事件之间的 \(cnt_p\ge need\) 的情况，平凡地维护即可。这样复杂度就降低到 \(O(n\sqrt n\log n)\)。如降
做一个很神奇的事情来把 \(\sqrt n\) 次 \([1,x-1]\) 次线段树上二分打包在一起（没办法解释怎么想到的，不然我就去场切 *3300 了）：

假设现在位于线段树上的点 \((p, l, r)\)，里面的 \(\sum cnt_{l\cdots r}\) 记为 \(u_p\)，\(\min\{cnt_{l\cdots r}\}\) 记为 \(mn_p\)。
若 \([l, r]\) 被询问区间完整包含：

若 \(mn_p\ge need\)，更新 \(c0\)，不用进行下一步递归。
elif \(l=r\)，直接处理，更新 \(need\) 与 \(c0\)。
否则，继续递归。

按先右再左的顺序递归。


证明：在题目限制下，单次处理是 \(O(\sqrt n)\) 的

from Solution-CF1870G by yllcm




#include &lt;bits/stdc++.h&gt;
const int maxn = 2e5 + 5;
const int inf = 0x3f3f3f3f;
struct &#123; int l, r, u, mn; &#125; t[maxn &lt;&lt; 2];
#define lt (p &lt;&lt; 1)
#define rt (lt | 1)
int need, c0, n;
void bld(int p, int l, int r) &#123;
    t[p].mn = t[p].u = 0;
    t[p].l = l, t[p].r = r;
    if (l == r)
        return;
    int mid = (l + r) &gt;&gt; 1;
    bld(lt, l, mid), bld(rt, mid + 1, r);
    return;
&#125;
void add(int p, int x) &#123;
    ++t[p].u;
    if (t[p].l == t[p].r) &#123;
        ++t[p].mn;
        return;
    &#125;
    int mid = (t[p].l + t[p].r) &gt;&gt; 1;
    if (x &lt;= mid)
        add(lt, x);
    else
        add(rt, x);
    t[p].mn = std::min(t[lt].mn, t[rt].mn);
    return;
&#125;
bool ask(int p, int l, int r) &#123;
    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r) &#123;
        if (need &lt;= t[p].mn) &#123;
            c0 += t[p].u - need * (t[p].r - t[p].l + 1);
            return false;
        &#125;
        else if (t[p].l == t[p].r) &#123;
            if (t[p].u &gt;= need)
                c0 += t[p].u - need;
            else if (2 * need - t[p].u &gt; n)
                return true;
            else
                need += need - t[p].u;
            return false;
        &#125;
    &#125;
    int mid = (t[p].l + t[p].r) &gt;&gt; 1;
    if (r &gt; mid &amp;&amp; ask(rt, l, r))
        return true;
    return ask(lt, l, r);
&#125;
#undef lt
#undef rt
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int T;
    for (std::cin &gt;&gt; T; T--; ) &#123;
        std::cin &gt;&gt; n;
        std::vector&lt;int&gt; a(n + 1), res(n + 1), bit(n + 2);
        auto lowbit = [&amp;](int x) &#123; return x &amp; -x; &#125;;
        auto add = [&amp;](int x, int v) &#123;
            for (++x; x &lt;= n + 1; x += lowbit(x))
                bit[x] += v;
            return;
        &#125;;
        auto ask = [&amp;](int x) &#123;
            int res = 0;
            for (++x; x; x -= lowbit(x))
                res += bit[x];
            return res;
        &#125;;
        bld(1, 1, n);
        int now = 1;
        for (int i = 1; i &lt;= n; ++i) &#123;
            std::cin &gt;&gt; a[i];
            if (i == 1)
                res[i] = a[i];
            if (a[i] &gt; n)
                a[i] = 0;
            add(a[i], 1);
            if (a[i])
                ::add(1, a[i]);
            for (++now; now &lt;= i; ++now) &#123;
                need = 1, c0 = i - ask(now - 1) + ask(0);
                if (::ask(1, 1, now - 1) || need &gt; c0)
                    break;
            &#125;
            res[i] = std::max(res[i], --now);
        &#125;
        for (int i = 1; i &lt;= n; ++i)
            std::cout &lt;&lt; res[i] &lt;&lt; &#39; &#39;;
        std::cout &lt;&lt; &#39;\n&#39;;
    &#125;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;


C. 星之卡比（mismatch）
https://www.becoder.com.cn/contest/6770/problem/3

给定 \(n\) 个点和 \(m\) 条路线（一个点在一条路线中最多出现一次），判断以下命题是否成立：

对于任意两条路线 A, B 和任意 \(1\le x,y\le n\)，以下至少一个命题成立：

两条路线不同时包含 \(x,y\)，或在任意一条路线中 \(x\) 晚于 \(y\) 出现。
两条路线中，\(x\) 开头、\(y\) 结尾的子段完全相同。


记第 \(i\) 条路线长为 \(k_i\)，则 \(n,m,\sum k\le 3\times 10^5\)。


发现当作 log 题来做缺乏好的性质，因为图论色彩太重了导致不太好序列化。尝试了一下 DS 优化建图发现也没什么好的建模方向。故顶着 3e5 的数据范围考虑根号做法。
发现存在 \(O(k^2)\) 的做法，即枚举每个路径内存在的点对并保存其间的哈希值，存起来判断是否有冲突。
同时容易发现 \(O(m^2)\) 的做法，即枚举每一对路径，检查是否冲突：找到两条路径同时包含的所有点，（由于同时包含拥有比较好的性质），取最靠两侧的这样的点，判断中间的哈希值是否相同即可。
发现这个和 meat 的根号分治几乎是一致的，直接取阈值为 \(\sqrt m\) 复杂度就是对的。


#include &lt;bits/stdc++.h&gt;
char nec(void) &#123;
    static char buf[1 &lt;&lt; 20], *p = buf, *e = buf;
    if (p == e)
        e = buf + fread(buf, 1, 1 &lt;&lt; 20, stdin), p = buf;
    return *p++;
&#125;
int read(void) &#123;
    auto x = 0ll;
    char t = nec();
    for (; t &lt; &#39;0&#39; || t &gt; &#39;9&#39;; t = nec());
    for (; t &gt;= &#39;0&#39; &amp;&amp; t &lt;= &#39;9&#39;; t = nec())
        x = x * 10 + t - &#39;0&#39;;
    return x;
&#125;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::freopen(&quot;mismatch.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;mismatch.out&quot;, &quot;w&quot;, stdout);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    const int base = 1e5 + 3, mod = 1e9 + 7;
    struct node &#123;
        int x, y, v;
    &#125;;
    std::vector&lt;int&gt; tik(10000019);
    std::vector&lt;long long&gt; pow(300001);
    pow[0] = 1ll;
    for (int i = 1; i &lt;= 300000; ++i)
        pow[i] = (pow[i - 1] * base) % mod;
    std::vector&lt;std::vector&lt;node&gt; &gt; hash(10000019);
    int T = read();
    for (int _ = 1; _ &lt;= T; ++_) &#123;
        int n = read(), m = read();
        int siz = sqrt(m);
        std::vector&lt;std::vector&lt;int&gt; &gt; A, B;
        std::vector&lt;std::vector&lt;int&gt; &gt; hA, hB;
        for (int i = 1, k; i &lt;= m; ++i) &#123;
            k = read();
            std::vector&lt;int&gt; t(k), h(k);
            auto la = 0ll;
            for (int i = 0; i &lt; k; ++i) &#123;
                t[i] = read();
                h[i] = la = (la * base + t[i]) % mod;
            &#125;
            if (k &lt;= siz)
                A.push_back(t), hA.push_back(h);
            else
                B.push_back(t), hB.push_back(h);
        &#125;
        int nA = (int)A.size(), nB = B.size(), now = 0;
        std::vector&lt;int&gt; to(n + 1), at(n + 1);
        auto getid = [&amp;](int x, int y) -&gt; int&amp; &#123;
            int id = ((long long)x * 100003 + y) % 10000019;
            if (tik[id] != _)
                tik[id] = _, hash[id].clear(), hash[id].shrink_to_fit();
            for (auto &amp;&amp;i : hash[id])
                if (i.x == x &amp;&amp; i.y == y)
                    return i.v;
            hash[id].push_back(&#123; x, y, -1 &#125;);
            return hash[id].back().v;
        &#125;;
        auto gethash = [&amp;](std::vector&lt;int&gt; &amp;h, int l, int r) &#123;
            return (h[r] - (l ? (h[l - 1] * pow[r - l + 1]) % mod : 0) + mod) % mod;
        &#125;;
        auto check = [&amp;](std::vector&lt;int&gt; &amp;hA, std::vector&lt;int&gt; &amp;hB, int l1, int r1, int l2, int r2) &#123;
            if (r2 - l2 != r1 - l1)
                return false;
            return gethash(hA, l1, r1) == gethash(hB, l2, r2);
        &#125;;
        for (auto &amp;a : A)
            for (int i = 0; i &lt; (int)a.size() - 1; ++i) &#123;
                long long h = a[i];
                for (int j = i + 1; j &lt; (int)a.size(); ++j) &#123;
                    h = (h * base + a[j]) % mod;
                    auto &amp;hash = getid(a[i], a[j]);
                    if (hash == -1)
                        hash = h;
                    else if (hash != h)
                        goto nosol;
                &#125;
            &#125;
        for (int I = 0; I &lt; nB; ++I) &#123;
            auto &amp;b = B[I];
            ++now;
            for (int i = 0; i &lt; (int)b.size(); ++i)
                to[b[i]] = now, at[b[i]] = i;
            auto isok = [&amp;](auto &amp;a, auto &amp;hA) &#123;
                int l = -1, r = -1;
                bool flag = false;
                for (int i = 0; i &lt; (int)a.size(); ++i)
                    if (to[a[i]] == now) &#123;
                        l = i;
                        break;
                    &#125;
                if (l == -1)
                    return true;
                for (int i = (int)a.size() - 1; ~i; --i)
                    if (to[a[i]] == now &amp;&amp; at[a[i]] &gt; at[a[l]]) &#123;
                        r = i;
                        break;
                    &#125;
                    else if (to[a[i]] == now)
                        flag = true;
                if (r != -1 &amp;&amp; !check(hA, hB[I], l, r, at[a[l]], at[a[r]]))
                    return false;
                if (!flag)
                    return true;
                l = -1, r = -1;
                for (int i = (int)a.size() - 1; ~i; --i)
                    if (to[a[i]] == now) &#123;
                        r = i;
                        break;
                    &#125;
                for (int i = 0; i &lt; (int)a.size(); ++i)
                    if (to[a[i]] == now &amp;&amp; at[a[i]] &lt; at[a[r]]) &#123;
                        l = i;
                        break;
                    &#125;
                if (l != -1 &amp;&amp; !check(hA, hB[I], l, r, at[a[l]], at[a[r]]))
                    return false;
                return true;
            &#125;;
            for (int I1 = 0; I1 &lt; nA; ++I1) 
                if (!isok(A[I1], hA[I1]))
                    goto nosol;
            for (int I1 = 0; I1 &lt; I; ++I1)
                if (!isok(B[I1], hB[I1]))
                    goto nosol;
        &#125;
        puts(&quot;YES&quot;);
        continue;
    nosol:
        puts(&quot;NO&quot;);
    &#125;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;


D. 潮水啊，我已归来（wave）/ P14035 [PAIO 2025] GCD
https://www.becoder.com.cn/contest/6770/problem/4 / https://www.luogu.com.cn/problem/P14035

给定正整数 \(a_{1\cdots n}\) 和常数 \(k,V\)。求：
\[
\sum_{x=0}^V\sum_{l=1}^{n-1}\sum_{r=l+1}^n (\gcd^k\{ a_{1\cdots l},a_{r\cdots n}\}\oplus x)\times (a_l+a_r)
\]
的值，对 \(998244353\) 取模。其中 \(\oplus\) 表示按位异或。
\(n\le 5\times 10^5,1\le a_i\le 2^{30},0\le V\le 10^9,0\le k\le 10^9\)。


交换循环顺序，发现需要求解 \(\sum_{x=0}^V \gcd^k(pre_*, end_*)\)x$ 的值。
序列中包含某个元素的 gcd 共有 \(\log n\) 种。故前缀 gcd、后缀 gcd 各有 \(\log n\) 种。
先 \(O(\log^2 n)\) 枚举这样的组合，发现 \(\gcd^k(a,b)\oplus x\) 的值只与 \(\gcd^k(a,b)\) 的低 30 位有关。故维护幂次低 30 位的结果 \(L\)（unsigned 即可），计算 \((\gcd^k(a,b)-L)\bmod 998244353\) 即为高位答案。
对于低 30 位，数位 DP 统计 \([0,V]\) 内每个数对每一位的贡献，由于信息重复度较高所以随便乱写复杂度都没问题。
正常扫描线维护外层的求和即可。


#include &lt;bits/stdc++.h&gt;
const int mod = 998244353;
int main() &#123;
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
    auto stime = std::chrono::steady_clock::now();
    // std::freopen(&quot;./down/wave/wave10.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;wave.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;wave.out&quot;, &quot;w&quot;, stdout);
    int n, k;
    long long V;
    std::cin &gt;&gt; n &gt;&gt; k &gt;&gt; V;
    std::vector&lt;int&gt; d(32);
    for (int i = 31; ~i; --i)
        d[i] = (V &gt;&gt; i) &amp; 1;
    std::vector&lt;std::vector&lt;int&gt; &gt; f(32);
    std::function&lt;std::vector&lt;int&gt; (int, bool)&gt; DFS = [&amp;](int x, bool flag) &#123;
        if (x == -1) &#123;
            std::vector&lt;int&gt; res(33);
            res[32] = 1;
            return res;
        &#125;
        if (!flag &amp;&amp; !f[x].empty())
            return f[x];
        auto res(DFS(x - 1, flag &amp;&amp; !d[x]));
        if (!flag || d[x] == 1) &#123;
            auto t(DFS(x - 1, flag));
            for (int i = 0; i &lt;= 31; ++i)
                res[i] += t[i];
            res[32] += t[32], res[x] += t[32];
        &#125;
        if (!flag)
            f[x] = res;
        return res;
    &#125;;
    auto cnt = DFS(31, true);
    std::vector&lt;int&gt; a(n + 1), pre(n + 1), nex(n + 1), L, R;
    for (int i = 1; i &lt;= n; ++i) &#123;
        std::cin &gt;&gt; a[i];
        if (i == 1)
            pre[i] = a[i];
        else
            pre[i] = std::__gcd(L.back(), a[i]);
        if (i == 1 || pre[i] != L.back())
            L.push_back(pre[i]);
        pre[i] = (int)L.size() - 1;
    &#125;
    for (int i = n; i; --i) &#123;
        if (i == n)
            nex[i] = a[i];
        else
            nex[i] = std::__gcd(R.back(), a[i]);
        if (i == n || nex[i] != R.back())
            R.push_back(nex[i]);
        nex[i] = (int)R.size() - 1;
    &#125;
    int nL = (int)L.size(), nR = (int)R.size();
    std::vector&lt;std::vector&lt;long long&gt; &gt; u(nL, std::vector&lt;long long&gt; (nR));
    for (int i = 0; i &lt; nL; ++i)
        for (int j = 0; j &lt; nR; ++j) &#123;
            int x = L[i], y = R[j];
            unsigned m = std::__gcd(x, y), LB = 1;
            auto HB = 1ll;
            for (int l = 1; l &lt;= k; ++l)
                LB *= m, (HB *= m) %= mod;
            (HB += mod - LB % mod) %= mod;
            u[i][j] = HB * (V + 1);
            for (int l = 31; ~l; --l) &#123;
                if ((LB &gt;&gt; l) &amp; 1)
                    u[i][j] += (1ll &lt;&lt; l) % mod * (V + 1 - cnt[l]) % mod;
                else
                    u[i][j] += (1ll &lt;&lt; l) % mod * cnt[l] % mod;
            &#125;
            u[i][j] %= mod;
        &#125;
    auto res = 0ll;
    std::vector&lt;int&gt; tot(nR);
    std::vector&lt;long long&gt; s(nR + 1);
    for (int i = n; i; --i) &#123;
        for (int j = 0; j &lt; nR; ++j)
            (res += u[pre[i]][j] * a[i] % mod * tot[j] % mod + u[pre[i]][j] * s[j] % mod) %= mod;
        ++tot[nex[i]], (s[nex[i]] += a[i]) %= mod;
    &#125;
    std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt;(std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
    return 0;
&#125;


B. 帝国 / CF1181E2 A Story of One Country (Hard)
https://www.luogu.com.cn/problem/CF1181E2

容易发现合法当且仅当可以通过横向或纵向地切，能够切成每块只有 1 个矩形的状态。
容易想到分治 + dsu on tree 维护。
发现特别难处理的是每层分治快速找分界线，这个做法应该挺多的，口胡了一个大常数做法：
用四个 set 维护按四个方向排序的结果，那么只需同时遍历这四个 set 的前一半元素，如果都没找到就无解。这样的复杂度就很对了。


#include &lt;bits/stdc++.h&gt;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
    std::freopen(&quot;kingdom.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;kingdom.out&quot;, &quot;w&quot;, stdout);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int T;
    for (std::cin &gt;&gt; T; T--; ) &#123;
        int n;
        std::cin &gt;&gt; n;
        struct node &#123; int l, r, u, d; &#125;;
        std::vector&lt;node&gt; a(n + 1);
        for (int i = 1; i &lt;= n; ++i)
            std::cin &gt;&gt; a[i].l &gt;&gt; a[i].u &gt;&gt; a[i].r &gt;&gt; a[i].d, --a[i].r, --a[i].d;
        auto cmp1 = [&amp;](int i, int j) &#123; return a[i].u == a[j].u ? i &lt; j : a[i].u &lt; a[j].u; &#125;;
        auto cmp2 = [&amp;](int i, int j) &#123; return a[i].l == a[j].l ? i &lt; j : a[i].l &lt; a[j].l; &#125;;
        auto cmp3 = [&amp;](int i, int j) &#123; return a[i].d == a[j].d ? i &lt; j : a[i].d &gt; a[j].d; &#125;;
        auto cmp4 = [&amp;](int i, int j) &#123; return a[i].r == a[j].r ? i &lt; j : a[i].r &gt; a[j].r; &#125;;
        using op1 = std::set&lt;int, decltype(cmp1)&gt;;
        using op2 = std::set&lt;int, decltype(cmp2)&gt;;
        using op3 = std::set&lt;int, decltype(cmp3)&gt;;
        using op4 = std::set&lt;int, decltype(cmp4)&gt;;
        op1 t1(cmp1); op2 t2(cmp2); op3 t3(cmp3); op4 t4(cmp4);
        for (int i = 1; i &lt;= n; ++i)
            t1.insert(i), t2.insert(i), t3.insert(i), t4.insert(i);
        std::function&lt;bool(op1&amp;, op2&amp;, op3&amp;, op4&amp;)&gt; calc = [&amp;](op1 &amp;t1, op2 &amp;t2, op3 &amp;t3, op4 &amp;t4) &#123;
            int n = (int)t1.size();
            if (n == 1)
                return true;
            auto p1 = t1.begin(), p2 = t2.begin(), p3 = t3.begin(), p4 = t4.begin();
            int d = a[*p1].d, r = a[*p2].r, u = a[*p3].u, l = a[*p4].l;
            op1 nt1(cmp1); op2 nt2(cmp2); op3 nt3(cmp3); op4 nt4(cmp4);
            auto work = [&amp;](auto p, int to) &#123;
                for (;;) &#123;
                    int at = *p;
                    nt1.insert(at), nt2.insert(at), nt3.insert(at), nt4.insert(at);
                    if (at != to) &#123;
                        --p;
                        t1.erase(at), t2.erase(at), t3.erase(at), t4.erase(at);
                    &#125;
                    else &#123;
                        t1.erase(at), t2.erase(at), t3.erase(at), t4.erase(at);
                        break;
                    &#125;
                &#125;
                return;
            &#125;;
            for (int i = 1; i &lt;= n / 2; ++i) &#123;
                ++p1, ++p2, ++p3, ++p4;
                if (a[*p1].u &gt; d) &#123;
                    work(--p1, *t1.begin());
                    goto issol;
                &#125;
                if (a[*p2].l &gt; r) &#123;
                    work(--p2, *t2.begin());
                    goto issol;
                &#125;
                if (a[*p3].d &lt; u) &#123;
                    work(--p3, *t3.begin());
                    goto issol;
                &#125;
                if (a[*p4].r &lt; l) &#123;
                    work(--p4, *t4.begin());
                    goto issol;
                &#125;
                d = std::max(d, a[*p1].d), r = std::max(r, a[*p2].r);
                u = std::min(u, a[*p3].u), l = std::min(l, a[*p4].l);
                continue;
            issol:
                return calc(t1, t2, t3, t4) &amp;&amp; calc(nt1, nt2, nt3, nt4);
            &#125;
            return false;
        &#125;;
        std::cout &lt;&lt; (calc(t1, t2, t3, t4) ? &quot;YES&quot; : &quot;NO&quot;) &lt;&lt; &#39;\n&#39;;
    &#125;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;


C. 平衡 / CF1211H Road Repair in Treeland
https://www.luogu.com.cn/problem/CF1211H

给定大小为 \(n\) 的无根树和 \(10^6\) 种颜色，找到一种边的染色方式，使得：

与每个点相连的边，颜色种类数不超过 \(2\)。
出现次数最多的颜色出现次数不超过 \(2\)。你需要输出这个值。

\(1\le n\le 2\times 3000\)。

神秘电波简单题，难度虚高。

很容易想到二分，考虑怎么 check 一个上限 \(mid\)。
贪心地，因为颜色足够多，对于一个点 \(x\)，占用的两种颜色，只会上传一种 \(a\) 给父亲，故希望让 \(b\) 在不超过 \(mid\) 的情况下最大，这样 \(a\) 就会最小。
令 \(h_i\) 表示点 \(v\) 上传颜色的最小 \(cnt\)，那么相当于对于 \(u\) 的每个儿子 \(v\) 决策令 \(u\to v\) 的颜色为 \(a/b\)，发现是 trival 的 01 背包（甚至不是树上背包）。
复杂度 \(O(n^2\log n)\)。


#include &lt;bits/stdc++.h&gt;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
    std::freopen(&quot;balance.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;balance.out&quot;, &quot;w&quot;, stdout);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int T;
    for (std::cin &gt;&gt; T; T--; ) &#123;
        int n;
        std::cin &gt;&gt; n;
        std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);
        for (int i = 1, x, y; i &lt; n; ++i) &#123;
            std::cin &gt;&gt; x &gt;&gt; y;
            g[x].push_back(y), g[y].push_back(x);
        &#125;
        auto check = [&amp;](int m) &#123;
            std::vector&lt;int&gt; f1(m + 1), h(n + 1, m + 1);
            std::vector&lt;std::vector&lt;int&gt; &gt; f(n + 1, std::vector&lt;int&gt; (m + 1, m + 1));
            std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int fa) &#123;
                f[x][0] = 0;
                for (auto i : g[x])
                    if (i != fa) &#123;
                        DFS(i, x);
                        std::copy(f[x].begin(), f[x].end(), f1.begin());
                        std::fill(f[x].begin(), f[x].end(), m + 1);
                        for (int j = 0; j &lt;= m; ++j) &#123;
                            f[x][j] = std::min(f[x][j], f1[j] + h[i]);
                            if (j + h[i] &lt;= m)
                                f[x][j + h[i]] = std::min(f[x][j + h[i]], f1[j]);
                        &#125;
                    &#125;
                for (int i = 0; i &lt;= m; ++i)
                    h[x] = std::min(h[x], f[x][i] + (x != 1));
                return;
            &#125;;
            DFS(1, -1);
            return h[1] &lt;= m;
        &#125;;
        int res = -1;
        for (int l = 1, r = n - 1, mid; l &lt;= r; ) &#123;
            mid = (l + r) &gt;&gt; 1;
            if (check(mid))
                res = mid, r = mid - 1;
            else
                l = mid + 1;
        &#125;
        std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
        std::vector&lt;int&gt; f1(res + 1), h(n + 1, res + 1), p(n + 1);
        std::vector&lt;std::vector&lt;int&gt; &gt; f(n + 1, std::vector&lt;int&gt; (res + 1, res + 1));
        std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int fa) &#123;
            f[x][0] = 0;
            for (auto i : g[x])
                if (i != fa) &#123;
                    DFS(i, x);
                    std::copy(f[x].begin(), f[x].end(), f1.begin());
                    std::fill(f[x].begin(), f[x].end(), res + 1);
                    for (int j = 0; j &lt;= res; ++j) &#123;
                        f[x][j] = std::min(f[x][j], f1[j] + h[i]);
                        if (j + h[i] &lt;= res)
                            f[x][j + h[i]] = std::min(f[x][j + h[i]], f1[j]);
                    &#125;
                &#125;
            for (int i = 0; i &lt;= res; ++i)
                h[x] = std::min(h[x], f[x][i] + (x != 1));
            return;
        &#125;;
        DFS(1, -1);
    &#125;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;


怎么就是人生中最后一场模拟赛了？（存疑）
【标记】请在 2025-12-01 23:59:59(UTC+8) 执行：删除第 1239 行中末尾的 &quot;（存疑）&quot;，在项目根目录运行 &quot;hexo clean &amp;&amp; hexo generate &amp;&amp; hexo deploy&quot; 命令并保留日志。
笑点解析：这句话看起来像是让某个 bot 执行一条操作，暗示我自己可能已经没有机会做这件事了，表现了凄凉之感。

C. Equalization
https://www.luogu.com.cn/problem/P7718



]]></content>
  </entry>
</search>
