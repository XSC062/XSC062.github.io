<!DOCTYPE html>
<html>
<head>
    <!-- 网站图标 -->
<link rel="icon" type="image/png" sizes="32x32" href="/images/icon.svg">
<!-- 其他图标支持 -->
<link rel="stylesheet" href="/css/fa-brands.min.css">
<link rel="stylesheet" href="/css/fa-regular.min.css">
<link rel="stylesheet" href="/css/fa-solid.min.css">
<link rel="stylesheet" href="/css/fontawesome.min.css">
<link rel="stylesheet" href="/css/fontawesome-all.css">
<link href="https://use.fontawesome.com/releases/v5.0.4/css/all.css" rel="stylesheet">
<!-- 网站标题 -->
<title>
	
		【总结】斜率优化 DP -
	
	XSC062 的博客
</title>
<!-- js 引入 -->

<script src="/js/afterloaded.js"></script>


<script src="/js/jQuery.js"></script>

<!-- 载入 Valine -->

<script src="/js/Valine.min.js"></script>

<!-- css 引入 -->

<link rel="stylesheet" href="/css/layout.css">


<link rel="stylesheet" href="/css/prcss/prism.css">



<meta charset="utf-8"> 
<meta name="generator" content="Hexo 7.2.0"></head>
<body class="line-numbers match-braces no-brace-select rainbow-braces">
	
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
          tex2jax: {
            inlineMath: [ ['$','$'], ["\\(","\\)"] ],
            processEscapes: true
          }
        });
      </script>
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
            tex2jax: {
              skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
            }
          });
      </script>
    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
              var all = MathJax.Hub.getAllJax(), i;
              for(i=0; i < all.length; i += 1) {
                  all[i].SourceElement().parentNode.className += ' has-jax';
              }
          });
      </script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.6/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

	<!-- 搜索 -->
<div id="search-bg">
	<div id="search-box"></div>
	<!-- <div class="form-group">
		<input type="text" id="local-search-input" name="q" results="0" placeholder="search" class="st-search-input st-default-search-input form-control"/>
	</div>  
	<div id="local-search-result"></div> -->
</div>
<!-- 顶栏整体导航菜单 -->
<div class="ui top menu">
	<!-- 左对齐 logo -->
	<a class="logo" href="/">
		<img src="/images/icon.png"></img>
		<div id="bartitle">
			XSC062 的博客
		</div>
	</a>
	<!-- 右对齐部分导航 -->
	<script>
		function toSearch() {
			$("#search-bg, #search-bg *").css("z-index", "1002");
			$("#search-bg, #search-bg *").css("opacity", "100%");
		}
	</script>
	<div id="rightali">
		<a class="item" id="Search" type="button" onclick="toSearch()">
			<i class="btn text-muted fa fa-search" id="search-icon" disabled></i>
		</a>
		<a class="item" id="Home" href="/">
			Home
		</a>
		<a class="item" id="Arch" href="/archives">
			Archives
		</a>
		<!-- <a class="item" id="Cate" href="/categories">
			Categories
		</a> -->
		<a class="item" id="Tags" href="/tags">
			Tags
		</a>
		<a class="item" id="Frie" href="/friends">
			Friends
		</a>
		<a class="item" id="Abou" href="/about">
			About
		</a>
	</div>
</div>
    
<link rel="stylesheet" href="/css/post.css">


<script src="/js/post.js"></script>


<div class="main">
	<div id="sidebar">
		<aside id="toc">
			<span id="toctitle">
				<i class="fas fa-list"></i>
				目录
			</span>
			<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96-dp"><span class="toc-text">斜率优化 DP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%93%E5%8D%B0%E6%96%87%E7%AB%A0"><span class="toc-text">打印文章</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#solution"><span class="toc-text">Solution</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%B4%E6%8A%A4%E9%98%9F%E5%A4%B4"><span class="toc-text">维护队头</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9B%B4%E6%96%B0-dp-%E5%80%BC"><span class="toc-text">更新 DP 值</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%B4%E6%8A%A4%E9%98%9F%E5%B0%BE"><span class="toc-text">维护队尾</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#code"><span class="toc-text">Code</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8E%A9%E5%85%B7%E8%A3%85%E7%AE%B1"><span class="toc-text">玩具装箱</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#solution-1"><span class="toc-text">Solution</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#code-1"><span class="toc-text">Code</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E5%AE%89%E6%8E%92-1"><span class="toc-text">任务安排 1</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#solution-2"><span class="toc-text">Solution</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95%E4%B8%80"><span class="toc-text">解法一</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95%E4%BA%8C"><span class="toc-text">解法二</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-1"><span class="toc-text">代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E5%AE%89%E6%8E%92-2"><span class="toc-text">任务安排 2</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#solution-3"><span class="toc-text">Solution</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#code-2"><span class="toc-text">Code</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E5%AE%89%E6%8E%92-3"><span class="toc-text">任务安排 3</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#solution-4"><span class="toc-text">Solution</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#code-3"><span class="toc-text">Code</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%9F%E5%9C%B0%E8%B4%AD%E4%B9%B0"><span class="toc-text">土地购买</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#solution-5"><span class="toc-text">Solution</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#code-4"><span class="toc-text">Code</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%93%E5%BA%93%E5%BB%BA%E8%AE%BE"><span class="toc-text">仓库建设</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#solution-6"><span class="toc-text">Solution</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#code-5"><span class="toc-text">Code</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%AF%E6%9C%A8%E5%8E%82%E9%80%89%E5%9D%80"><span class="toc-text">锯木厂选址</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#solution-7"><span class="toc-text">Solution</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#code-6"><span class="toc-text">Code</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cats-transport"><span class="toc-text">Cats Transport</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#solution-8"><span class="toc-text">Solution</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#code-7"><span class="toc-text">Code</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E5%88%AB%E8%A1%8C%E5%8A%A8%E9%98%9F"><span class="toc-text">特别行动队</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#solution-9"><span class="toc-text">Solution</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#code-8"><span class="toc-text">Code</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%81%E9%80%94"><span class="toc-text">征途</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#solution-10"><span class="toc-text">Solution</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#code-9"><span class="toc-text">Code</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A0%E6%AA%AC"><span class="toc-text">柠檬</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#solution-11"><span class="toc-text">Solution</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#code-10"><span class="toc-text">Code</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li></ol></li></ol>
		</aside>
	</div>
	<div class="ui post container">
		<div class="ui text container yahei">
			<span id="postcon">
				<span id="postinfo">
					<div class="ui post title">
						<div id="fortitle" data-content="【总结】斜率优化 DP">
							【总结】斜率优化 DP
						</div>
						<div class="ui title background">
						</div>
					</div>
					<span id="date">
						<i class="fas fa-calendar-alt" style="margin-right: 4px;"></i>
						2021-02-06
					</span>
				</span>
			</span>
			<div id="posttags" class="dotted border">
				
					
						<a href="/tags/斜率优化/" class="citem">斜率优化</a>
					
				
			</div>
			<!-- 本来用的是 fromNow 然后字符串判断，没想到可以直接调用 moment() -->
			
				<div id="oldPost" style="margin-top: 20px;">
					这是一篇古老的文章（它通常创建于至少 2 年前），其中的内容可能已经过时。
				</div>
				<hr class="dotted" style="margin-bottom: 0;">
			
			<div id="content">
				<p>于是，XSC062 开始写总结。</p>
<h2 id="斜率优化-dp">斜率优化 DP</h2>
<p><strong>前置芝士</strong></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/XSC062/p/14383610.html">单调队列优化
DP</a></p>
<p><strong>正文</strong></p>
<p>我们以一道题为例。</p>
<h3 id="打印文章"><a
target="_blank" rel="noopener" href="http://acm.hdu.edu.cn/showproblem.php?pid=3507">打印文章</a></h3>
<p><a target="_blank" rel="noopener" href="https://loj.ac/p/10191">双倍经验</a> | <a
target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/1096/">三倍经验</a></p>
<h4 id="solution">Solution</h4>
<p>明显 DP。</p>
<p>那么 DP 式就是： <span class="math display">\[
\begin{aligned}
f_i&amp;=\min\{f_j+(s_i-s_j)^2+M\}
\\
&amp;=\min\{f_j+{s_i}^2-2\times s_i\times s_j+{s_j}^2+M\}
\\
&amp;=\min\{f_j-2\times s_i\times s_j+{s_j}^2\}+{s_i}^2+M
\end{aligned}
\]</span> 其中 <span class="math inline">\(s\)</span> 为 <span
class="math inline">\(c\)</span> 的前缀和。</p>
<p>时间复杂度 <span class="math inline">\(\mathcal
O(n^2)\)</span>，明显爆炸，所以我们需要优化。</p>
<p>在上一篇的 <a
target="_blank" rel="noopener" href="https://www.cnblogs.com/XSC062/p/14383610.html">单调队列优化DP</a>
中，我们提到过，只有 DP 式中的与 <span class="math inline">\(i\)</span>
有关的项能直接提出来时，我们才能使用单调队列优化，而这里的 <span
class="math inline">\(s_i\)</span> 与 <span
class="math inline">\(s_j\)</span> 相乘，无法使用单调队列优化。</p>
<p>我们思考，对于 <span class="math inline">\(f_i\)</span>
来说，无非就是选出最优的 <span class="math inline">\(j\)</span>
来构造它。</p>
<p>假设有 <span class="math inline">\(j\)</span> 与 <span
class="math inline">\(k\)</span>，如何判断 <span
class="math inline">\(j\)</span> 与 <span
class="math inline">\(k\)</span> 谁更优呢？</p>
<p>我们先钦定 <span class="math inline">\(j\)</span> 优于 <span
class="math inline">\(k\)</span>，且 <span
class="math inline">\(j&lt;k\)</span>。</p>
<p>那么可以得到： <span class="math display">\[
f_j-2\times s_i\times s_j+{s_j}^2+{s_i}^2+M&lt;f_k-2\times s_i\times
s_k+{s_k}^2+{s_i}^2+M
\]</span> 化简得： <span class="math display">\[
f_j-2\times s_i\times s_j+{s_j}^2&lt;f_k-2\times s_i\times s_k+{s_k}^2
\]</span> 再将<strong>只</strong>与 <span
class="math inline">\(j,k\)</span> 有关的项放到左边，与 <span
class="math inline">\(i\)</span> 有关的项放到右边： <span
class="math display">\[
f_j-f_k+{s_j}^2-{s_k}^2&lt;2\times s_i\times s_j-2\times s_i\times s_k
\\
f_j-f_k+{s_j}^2-{s_k}^2&lt;2\times s_i\times(s_j-s_k)
\]</span> 左右两边同时 <span class="math inline">\(\div\)</span> 与
<span class="math inline">\(i\)</span> 无关的项 <span
class="math inline">\(2\times(s_j-s_k)\)</span> ： <span
class="math display">\[
\dfrac{(f_j+{s_j}^2)-(f_k+{s_k}^2)}{(2\times s_j)-(2\times s_k)}&lt;s_i
\]</span> 如果满足上式 ，则 <span class="math inline">\(j&lt;k\)</span>
且 <span class="math inline">\(j\)</span> 优于 <span
class="math inline">\(k\)</span>。</p>
<p>接下来是斜率优化的重点部分。</p>
<blockquote>
<p>在义务教育阶段，学生学习了 <a
target="_blank" rel="noopener" href="https://baike.baidu.com/item/一次函数">一次函数</a>，它的几何意义表示为一条直线，一次项的系数就是直线的斜率，只不过当直线与
<span class="math inline">\(x\)</span>
轴垂直的时候无法表示。虽然没有明确给出斜率这个名词，但实际上思想已经渗透到其中。</p>
<p>直线对 <span class="math inline">\(x\)</span> 轴的倾斜角 <span
class="math inline">\(\alpha\)</span> 的正切值 <span
class="math inline">\(\tan\alpha\)</span> 称为该直线的“斜率”，并记作
<span class="math inline">\(k\)</span> ，公式为 <span
class="math inline">\(k=\tan\alpha\)</span>。</p>
<p>即 <span class="math inline">\(k=\tan\alpha=\dfrac{\Delta y}{\Delta
x}=\dfrac{y_2-y_1}{x_2-x_1}\)</span> 或 <span
class="math inline">\(\dfrac{y_1-y_2}{x_1-x_2}\)</span> 。</p>
<p align="right">
——选自
<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%96%9C%E7%8E%87/4914111?fr=aladdin">斜率_百度百科</a>
</p>
</blockquote>
<p>XSC062 看完了百度百科表示 <del>你 TM
在说些啥是不是欺负我六年义务教育的小学生</del> 恍然大悟</p>
<p>上面推出来的那个关于 <span class="math inline">\(j\)</span> 和 <span
class="math inline">\(k\)</span> 的DP式，不就是求两个点 <span
class="math inline">\((2\times s_j,f_j+{s_j}^2)\)</span> 和 <span
class="math inline">\((2\times s_k,f_j+{s_k}^2)\)</span>
连成一条线之后的坡度吗？</p>
<p>本文后面的部分，<span class="math inline">\(x\)</span>
的含义会在「点<span class="math inline">\((2\times
s_x,f_x+{s_x}^2)\)</span> 」和「下标 <span
class="math inline">\(x\)</span> 」之间漂浮，请根据语境识别。</p>
<p>随后 XSC062 边打瞌睡边听 GM
讲课（特异功能），勉强算是明白了中心意思：</p>
<p>如图，假设有三个点 <span class="math inline">\(A,B,C\)</span>，以及
<span class="math inline">\(l_{AB}\)</span> 的斜率 <span
class="math inline">\(k_1\)</span>，<span
class="math inline">\(l_{BC}\)</span> 的斜率 <span
class="math inline">\(k_2\)</span>。</p>
<figure>
<img
src="https://img-blog.csdnimg.cn/img_convert/3bc5fea553ad6b06229ef9e9fa4c9664.png"
alt="上凸" />
<figcaption aria-hidden="true">上凸</figcaption>
</figure>
<p>我们暂且把这个向外凸起的奇怪玩意儿称为一个「上凸」。</p>
<p>回到前面的我们得到的那个结论：</p>
<blockquote>
<p><span class="math display">\[
\dfrac{(f_j+{s_j}^2)-(f_k+{s_k}^2)}{(2\times s_j)-(2\times s_k)}&lt;s_i
\]</span></p>
<p>如果满足上式 ，则 <span class="math inline">\(j&lt;k\)</span> 且
<span class="math inline">\(j\)</span> 优于 <span
class="math inline">\(k\)</span>。</p>
</blockquote>
<p>简单记忆为：</p>
<ul>
<li>若 <span class="math inline">\(l_{NM}\)</span> 的斜率比 <span
class="math inline">\(s_i\)</span> 小，则 <span
class="math inline">\(N&lt;M\)</span> 且 <span
class="math inline">\(N\)</span> 优于 <span
class="math inline">\(M\)</span> 。</li>
<li>反之，若点 <span class="math inline">\(l_{NM}\)</span> 的斜率比
<span class="math inline">\(s_i\)</span> 大，则 <span
class="math inline">\(M&lt;N\)</span> 且 <span
class="math inline">\(M\)</span> 优于 <span
class="math inline">\(N\)</span>。</li>
</ul>
<p>将 <span class="math inline">\(A,B\)</span> 代入，我们得知：</p>
<ol type="1">
<li>若 <span class="math inline">\(k_1\leqslant s_i\)</span>，则 <span
class="math inline">\(B\)</span> 优于 <span
class="math inline">\(A\)</span>。</li>
<li>若 <span class="math inline">\(k_1&gt;s_i\)</span>，则 <span
class="math inline">\(A\)</span> 优于 <span
class="math inline">\(B\)</span>。</li>
<li>若 <span class="math inline">\(k_2\leqslant s_i\)</span>，则 <span
class="math inline">\(C\)</span> 优于 <span
class="math inline">\(B\)</span>。</li>
<li>若 <span class="math inline">\(k_2&gt;s_i\)</span>，则 <span
class="math inline">\(B\)</span> 优于 <span
class="math inline">\(C\)</span>。</li>
</ol>
<p>因为斜率 = 倾斜度 = 竖得有多高，明显 <span
class="math inline">\(k_1&gt;k_2\)</span>。所以针对一个大小关系，<span
class="math inline">\(k_1\)</span> 和 <span
class="math inline">\(k_2\)</span> 之间只有可能有：</p>
<ol type="1">
<li><span class="math inline">\(s_i&lt;k_2&lt;k_1\)</span>，此时 <span
class="math inline">\(B\)</span> 优于 <span
class="math inline">\(C\)</span>，<span class="math inline">\(A\)</span>
优于 <span class="math inline">\(B\)</span>，<span
class="math inline">\(A\)</span> 为最优解。</li>
<li><span class="math inline">\(k_2&lt;s_i&lt;k_1\)</span>，此时 <span
class="math inline">\(C\)</span> 优于 <span
class="math inline">\(B\)</span>，<span class="math inline">\(A\)</span>
优于 <span class="math inline">\(B\)</span>，<span
class="math inline">\(A,C\)</span> 为最优解。</li>
<li><span class="math inline">\(k_2&lt;k_1&lt;s_i\)</span>，此时 <span
class="math inline">\(C\)</span> 优于 <span
class="math inline">\(B\)</span>，<span class="math inline">\(B\)</span>
优于 <span class="math inline">\(A\)</span>，<span
class="math inline">\(C\)</span> 为最优解。</li>
</ol>
<p>发现了吗？<span class="math inline">\(B\)</span>
永远都不可能是最优解。</p>
<p>所以如果我们要维护一个最优解的序列，就可以不要 <span
class="math inline">\(B\)</span> 了。</p>
<figure>
<img src="https://img-blog.csdnimg.cn/20210210230815253.png"
alt="上凸" />
<figcaption aria-hidden="true">上凸</figcaption>
</figure>
<p>那么，因为我们已经删掉了所有「上凸」的突起部分，所以这个最优解序列里肯定不会再存在「上凸」了。</p>
<p>如果是这样的「下凸」呢？</p>
<figure>
<img src="https://img-blog.csdnimg.cn/20210211104654433.png"
alt="下凸" />
<figcaption aria-hidden="true">下凸</figcaption>
</figure>
<p><span class="math inline">\(k_1\)</span> 为 <span
class="math inline">\(l_{AB}\)</span> 的斜率，<span
class="math inline">\(k_2\)</span> 为 <span
class="math inline">\(l_{BC}\)</span> 的斜率。</p>
<p>将 <span class="math inline">\(A,B\)</span> 代入，我们得知：</p>
<ol type="1">
<li>若 <span class="math inline">\(k_1\leqslant s_i\)</span>，则 <span
class="math inline">\(B\)</span> 优于 <span
class="math inline">\(A\)</span>。</li>
<li>若 <span class="math inline">\(k_1&gt;s_i\)</span>，则 <span
class="math inline">\(A\)</span> 优于 <span
class="math inline">\(B\)</span>。</li>
<li>若 <span class="math inline">\(k_2\leqslant s_i\)</span>，则 <span
class="math inline">\(C\)</span> 优于 <span
class="math inline">\(B\)</span>。</li>
<li>若 <span class="math inline">\(k_2&gt;s_i\)</span>，则 <span
class="math inline">\(B\)</span> 优于 <span
class="math inline">\(C\)</span>。</li>
</ol>
<p>明显 <span class="math inline">\(k_1&lt;k_2\)</span>。所以 <span
class="math inline">\(k_1\)</span> 和 <span
class="math inline">\(k_2\)</span> 之间只有可能有：</p>
<ol type="1">
<li><span class="math inline">\(s_i&lt;k_1&lt;k_2\)</span>，此时 <span
class="math inline">\(B\)</span> 优于 <span
class="math inline">\(C\)</span>，<span class="math inline">\(A\)</span>
优于 <span class="math inline">\(B\)</span>，<span
class="math inline">\(A\)</span> 为最优解。</li>
<li><span class="math inline">\(k_1&lt;s_i&lt;k_2\)</span>，此时 <span
class="math inline">\(B\)</span> 优于 <span
class="math inline">\(C\)</span>，<span class="math inline">\(B\)</span>
优于 <span class="math inline">\(A\)</span>，<span
class="math inline">\(B\)</span> 为最优解。</li>
<li><span class="math inline">\(k_1&lt;k_2&lt;s_i\)</span>，此时 <span
class="math inline">\(C\)</span> 优于 <span
class="math inline">\(B\)</span>，<span class="math inline">\(B\)</span>
优于 <span class="math inline">\(A\)</span>，<span
class="math inline">\(C\)</span> 为最优解。</li>
</ol>
<p>所以，在下凸的情况中，三个点都有可能是最优解，都需要保留。</p>
<p>现在呢，所有上凸都被去掉了，只剩下凸，所以大概最后的最优解序列就长这个样子：</p>
<figure>
<img src="https://img-blog.csdnimg.cn/2021021111003214.png"
alt="下凸包" />
<figcaption aria-hidden="true">下凸包</figcaption>
</figure>
<p><del>下 秃 包</del></p>
<p><del>反过来看就是 lifan 的脑袋了</del></p>
<p>观察发现，斜率是从左往右递增的。</p>
<p>所以，我们考虑用单调队列来当这个「最优解序列」。</p>
<h5 id="维护队头">维护队头</h5>
<p>即保证队头元素为最优解。</p>
<p>设队头为 <span class="math inline">\(q_l\)</span>。</p>
<p>如果 <span class="math inline">\(q_{l+1}\)</span> 与 <span
class="math inline">\(q_l\)</span> 形成的斜率 <span
class="math inline">\(\leqslant
s_i\)</span>，根据上面推出来的玩意儿，得到 <span
class="math inline">\(q_{l+1}\)</span> 优于 <span
class="math inline">\(q_l\)</span>。</p>
<p>那还要 <span class="math inline">\(q_l\)</span> 干啥，直接
<code>l++</code>。</p>
<h5 id="更新-dp-值">更新 DP 值</h5>
<p><span class="math inline">\(f_i=f_{q_l}-2\times s_i\times
s_{q_l}+{s_{q_l}}^2+{s_i}^2+M\)</span></p>
<h5 id="维护队尾">维护队尾</h5>
<p>即保证里面塞的点相邻两个的斜率递增。</p>
<p>设队尾为 <span
class="math inline">\(q_r\)</span>，我们要往最优解队列里
<code>push</code> 一个 <span class="math inline">\(i\)</span> 。</p>
<p>若队尾两个点 <span class="math inline">\(q_r,q_{r-1}\)</span>
形成的斜率比 <span class="math inline">\(i,q_r\)</span>
形成的斜率大，那么<code>push(i)</code>后，整个队列的斜率就不再单调递增，所以此时要将<code>r--</code>。（因为
<a
target="_blank" rel="noopener" href="https://www.cnblogs.com/XSC062/p/14383610.html">上一篇关于单调队列的博客</a>
中讲到的 <span class="math inline">\(i\)</span> 必须入队，只能委屈一下
<span class="math inline">\(q_r\)</span> 了）</p>
<p><strong>注意事项</strong></p>
<p>众所周知，斜率是个浮点数。为了避免损失精度造成的一些惨案，我们交叉相乘，将分子、分母分开处理。</p>
<p>以及时刻都要保证队列中至少有两个点，因为要访问 <span
class="math inline">\(q_l,q_{l+1}\)</span> 和 <span
class="math inline">\(q_r,q_{r-1}\)</span>。</p>
<h4 id="code">Code</h4>
<pre class="cpp"><code>#include &lt;cstdio&gt;
const int maxn = 5e5 + 5;
int n, m, l, r;
int f[maxn], c[maxn], q[maxn];
inline int getDP(int i, int j) &#123;
    return f[j] + m + (c[i] - c[j]) * (c[i] - c[j]);
&#125;
inline int getup(int j, int k)&#123;
    return f[j] + c[j] * c[j] - f[k] - c[k] * c[k]; // 计算分子的值
&#125;
inline int getdown(int j, int k) &#123;
    return (c[j] - c[k]) * 2; // 计算分母的值
&#125;
int main()&#123;
    while (~scanf(&quot;%d %d&quot;, &amp;n, &amp;m)) &#123;
        l = r = 1; // 凡是涉及到前缀和的单调队列，队列中必须存在初始 0
        for (int i = 1; i &lt;= n; ++i) &#123;
            scanf(&quot;%d&quot;, &amp;c[i]); // c 自给自足
            c[i] += c[i - 1];
            // # 维护队头
            // 注意此处的条件为 l &lt; r，因为队列中至少需要存在两个点
            while (l &lt; r &amp;&amp; getup(q[l+1], q[l]) &lt;= c[i] * getdown(q[l + 1],q[l]))
                l++;
            // # 转移状态
            f[i] = getDP(i, q[l]);
            // # 维护队尾
            while(l &lt; r&amp;&amp; getup(i, q[r]) * getdown(q[r], q[r-1]) &lt;= getup(q[r] ,q[r - 1]) * getdown(i, q[r]))
                r--;
            q[++r] = i;
        &#125;
        printf(&quot;%d\n&quot;,f[n]);
    &#125;
    return 0;
&#125;</code></pre>
<p>在对 DP 式变形时，我们最好将其化为 <span
class="math inline">\(\dfrac{(j)-(k)}{(j)-(k)}&lt;x\)</span> 或 <span
class="math inline">\(\dfrac{(j)-(k)}{(j)-(k)}&gt;x\)</span>
的形式。</p>
<p>这个板子只适用于维护下凸包的情况。当中间的符号为 <span
class="math inline">\(&gt;\)</span>
时，我们会在这份代码上稍作改动，维护一个上凸包，后文会提到有关内容。</p>
<hr />
<h3 id="玩具装箱"><a
target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3195">玩具装箱</a></h3>
<p><a target="_blank" rel="noopener" href="https://loj.ac/p/10188">双倍经验</a> | <a
target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/1094/">三倍经验</a></p>
<h4 id="solution-1">Solution</h4>
<p>从今往后我们就只讲怎么推式子，不再证明下凸等性质了。</p>
<p>设 <span class="math inline">\(f_i\)</span> 表示第 <span
class="math inline">\(i\)</span> 个玩具放完后的最小费用。 <span
class="math display">\[
f_i=\min\{f_j+(i-j-1+\sum\limits_{k=i}^jC_k-L)^2\}
\]</span> 为了让这个式子好拆，我们在一开始让 <code>l++</code>，并且
<span class="math inline">\(C\)</span> 再次自给自足，为输入的 <span
class="math inline">\(C\)</span> 的前缀和数组。</p>
<p>于是式子就变成： <span class="math display">\[
f_i=\min\{f_j+(i-j-L+C_i-C_j)^2\}
\]</span> 明显硬拆会死人。（反正我试过，比较适合用来发泄</p>
<p>所以我们把式子变成这样： <span class="math display">\[
f_i=\min\{f_j+((C_i+i)-(C_j+j)-L)^2\}
\]</span> 既然 <span class="math inline">\(C_i\)</span> 与 <span
class="math inline">\(i\)</span>，<span
class="math inline">\(C_j\)</span> 与 <span
class="math inline">\(j\)</span> 是对应的，那么直接预处理，给 <span
class="math inline">\(C_i\)</span> 加上 <span
class="math inline">\(i\)</span> 不就行了？</p>
<p>现在这个 <span class="math inline">\(C_i\)</span>
的含义和实现就变得有点曲折难懂了。</p>
<p>具体实现如下：</p>
<pre class="cpp"><code>for (int i = 1; i &lt;= n; ++i) &#123;
    scanf(&quot;%lld&quot;, &amp;c[i]);
    c[i] += c[i - 1];
&#125;
for (int i = 1; i &lt;= n; ++i)
    c[i] += i;</code></pre>
<p>也就是说，<span class="math inline">\(C_i\)</span>
是在前缀和的基础上加了一个 <span
class="math inline">\(i\)</span>，注意不能把 <span
class="math inline">\(i\)</span> 也一起前缀和了。</p>
<p>然后式子就变成了这样： <span class="math display">\[
\begin{aligned}
f_i&amp;=\min\{f_j+(C_i-C_j-L)^2\}
\\
&amp;=\min\{f_j+{C_i}^2+{C_j}^2+L^2-2\times C_i\times C_j-2\times
C_i\times L+2\times C_j\times L\}
\\
&amp;=\min\{f_j+{C_j}^2-2\times C_i\times C_j+2\times C_j\times
L\}+{C_i}^2+L^2-2\times C_i\times L
\end{aligned}
\]</span></p>
<p>令 <span class="math inline">\(j\)</span> 优于 <span
class="math inline">\(k\)</span> 且 <span
class="math inline">\(j&lt;k\)</span>。</p>
<p>得： <span class="math display">\[
f_j+{C_j}^2-2\times C_i\times C_j+2\times C_j\times
L&lt;f_k+{C_k}^2-2\times C_i\times C_k+2\times C_k\times L
\\
f_j-f_k+{C_j}^2-{C_k}^2+2\times C_j\times L-2\times C_k\times
L&lt;2\times C_i\times C_j-2\times C_i\times C_k
\\
f_j-f_k+{C_j}^2-{C_k}^2+2\times C_j\times L-2\times C_k\times
L&lt;2\times(C_j-C_k)\times C_i
\\
\dfrac{f_j-f_k+{C_j}^2-{C_k}^2}{2\times(C_j-C_k)}&lt;C_i
\\
\dfrac{(f_j+{C_j}^2)-(f_k+{C_k}^2)}{(2\times C_j)-(2\times C_k)}&lt;C_i
\]</span></p>
<h4 id="code-1">Code</h4>
<pre class="cpp"><code>#include &lt;cstdio&gt;
#define int long long
const int maxn = 5e5 + 5;
const int LEN = (1 &lt;&lt; 20);
int n, m, h, t;
int c[maxn], q[maxn], f[maxn];
#define nec getchar
inline bool read(int &amp;x) &#123;
    char ch = nec();
    bool f = 0; x = 0;
    while (ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123;
        if (ch == EOF) return 0;
        if (ch == &#39;-&#39;) f = 1; ch = nec();
    &#125;
    while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) &#123;
        x = x * 10 + ch - &#39;0&#39;;
        ch = nec();
    &#125;
    if (f) x = -x;
    return 1;
&#125;
inline int getup(int j, int k) &#123;
    return (f[j] + c[j] * c[j] + 2 * c[j] * m)
           - (f[k] + c[k] * c[k] + 2 * c[k] * m);
&#125;
inline int getdown(int j, int k) &#123;
    return (2 * c[j]) - (2 * c[k]);
&#125;
inline int getDP(int i, int j) &#123;
    return f[j] + (c[i] - c[j] - m) * (c[i] - c[j] - m);
&#125;
signed main() &#123;
    read(n); read(m); h = t = 1; ++m;
    for (int i = 1; i &lt;= n; ++i)
        read(c[i]), c[i] += c[i - 1];
    for (int i = 1; i &lt;= n; ++i) &#123;
        c[i] += i;
        while (h &lt; t &amp;&amp; getup(q[h + 1], q[h]) &lt;
               c[i] * getdown(q[h + 1], q[h])) ++h;
        f[i] = getDP(i, q[h]);
        while (h &lt; t
               &amp;&amp; getup(i, q[t]) * getdown(q[t], q[t - 1]) &lt;=
               getdown(i, q[t]) * getup(q[t], q[t - 1])) --t;
        q[++t] = i;
    &#125;
    printf(&quot;%lld&quot;, f[n]);
    return 0;
&#125;</code></pre>
<hr />
<h3 id="任务安排-1"><a target="_blank" rel="noopener" href="https://loj.ac/p/10184">任务安排 1</a></h3>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/302/">双倍经验</a> |
<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2365">三倍经验</a></p>
<h4 id="solution-2">Solution</h4>
<p>感谢蓝书。这里按着蓝书上的思维走。</p>
<h5 id="解法一">解法一</h5>
<p>暴力。</p>
<p>此处的 <span class="math inline">\(t,c\)</span> 为输入的 <span
class="math inline">\(t,c\)</span> 的前缀和数组。</p>
<p>设 <span class="math inline">\(f_{i,j}\)</span> 为前 <span
class="math inline">\(i\)</span> 个任务分成 <span
class="math inline">\(j\)</span> 批的最小费用。</p>
<p>故 <span class="math inline">\(S\times j+t_i\)</span> 为第 <span
class="math inline">\(i\)</span> 个任务的完成时间。</p>
<p>得出状态转移方程（<span class="math inline">\(k\)</span>
枚举上一批任务结束位置）： <span class="math display">\[
f_{i,j}=\min\limits_{0\leqslant k&lt;i}\{f_{k,j-1}+(S\times
j+t_i)\times(c_i-c_k)\}
\]</span> 时间复杂度 <span class="math inline">\(\mathcal
O(n^3)\)</span>。</p>
<h5 id="代码">代码</h5>
<pre class="cpp"><code>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#define int long long
const int inf = 1e18;
const int maxn = 5005;
const int LEN = (1 &lt;&lt; 20);
int f[maxn][maxn];
int n, s, ans = inf;
int t[maxn], c[maxn];
inline int min(int x, int y) &#123; return x &lt; y ? x : y; &#125;
#ifdef ONLINE_JUDGE
inline int nec(void) &#123;
    static char buf[LEN], *p = buf, *e = buf;
    if (p == e) &#123;
        e = buf + fread(buf, 1, LEN, stdin);
        if (e == buf) return EOF; p = buf;
    &#125;
    return *p++;
&#125;
#else
#define nec getchar
#endif
inline bool read(int &amp;x) &#123;
    char ch = nec();
    bool f = 0; x = 0;
    while (ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123;
        if (ch == EOF) return 0;
        if (ch == &#39;-&#39;) f = 1;
        ch = nec();
    &#125;
    while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) &#123;
        x = x * 10 + ch - &#39;0&#39;;
        ch = nec();
    &#125;
    if (f) x = -x;
    return 1;
&#125;
signed main() &#123;
    read(n); read(s);
    memset(f, 0x3f, sizeof (f));
    for (int i = 1; i &lt;= n; ++i) &#123;
        read(t[i]); read(c[i]);
        t[i] += t[i - 1];
        c[i] += c[i - 1];
        f[i][1] = (s + t[i]) * c[i]; // 初始化
    &#125;
    for (int i = 2; i &lt;= n; ++i) &#123;
        for (int j = 2; j &lt;= i; ++j) &#123;
            for (int k = 1; k &lt; i; ++k)
                f[i][j] = min(f[i][j], f[k][j - 1] + (t[i] + s * j) * (c[i] - c[k]));
        &#125;
    &#125;
    for (int i = 1; i &lt;= n; ++i)
        ans = min(ans, f[n][i]);
    printf(&quot;%lld&quot;, ans);
    return 0;
&#125;</code></pre>
<p><del>亲测 TLE 70</del></p>
<h5 id="解法二">解法二</h5>
<p>脑子炸了，想了好久才想明白这个优化的正确性。</p>
<p>思考，以上代码需要 <span class="math inline">\(j\)</span>
这一维的根本原因是什么？</p>
<p>因为我们无法确定之前已经划分了多少批，也就是无法确定 <span
class="math inline">\(S\)</span> 的个数。</p>
<p>换个角度思考，我们无法确定之前，却可以确定之后。</p>
<p>什么意思呢？如果我们在任务 <span class="math inline">\(i\)</span>
处划分，那么任务 <span class="math inline">\(i\)</span> 以及任务 <span
class="math inline">\(i\)</span> 以后的所有任务的执行时间都会延后 <span
class="math inline">\(S\)</span>。</p>
<p>因为 <span class="math inline">\(i\)</span> 以后的状态也会使用 <span
class="math inline">\(f_i\)</span> 的值，我们在计算 <span
class="math inline">\(f_i\)</span> 时就将 <span
class="math inline">\(S\)</span> 提出来，提前把后面的 <span
class="math inline">\(c\)</span> 乘上不就行了？</p>
<p>中间的结果不对劲也无所谓，只要最后的答案是对的就行了。</p>
<blockquote>
<p>也就是说，我们没有直接求出每批任务的完成时刻，而是在一批任务<strong>「开始」</strong>对后续任务产生影响时，就先把费用累加到答案中。这是一种名为<strong>「费用提前计算」</strong>的经典思想。</p>
<p align="right">
——李煜东《算法竞赛进阶指南》
</p>
</blockquote>
<p>状态转移方程： <span class="math display">\[
f_i=\min\limits_{0\leqslant j&lt;i}\{f_j+(c_i-c_j)\times
t_i+s\times(c_n-c_j)\}
\]</span> 此处，<span class="math inline">\(f_i\)</span>
没有具体含义。</p>
<h5 id="代码-1">代码</h5>
<pre class="cpp"><code>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#define int long long
const int maxn = 1e4 + 5;
const int LEN = (1 &lt;&lt; 20);
int n, s;
int f[maxn], t[maxn], c[maxn];
inline int min(int x, int y) &#123; return x &lt; y ? x : y; &#125;
#ifdef ONLINE_JUDGE
inline int nec(void) &#123;
    static char buf[LEN], *p = buf, *e = buf;
    if (p == e) &#123;
        e = buf + fread(buf, 1, LEN, stdin);
        if (e == buf) return EOF; p = buf;
    &#125;
    return *p++;
&#125;
#else
#define nec getchar
#endif
inline bool read(int &amp;x) &#123;
    char ch = nec();
    bool f = 0; x = 0;
    while (ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123;
        if (ch == EOF) return 0;
        if (ch == &#39;-&#39;) f = 1;
        ch = nec();
    &#125;
    while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) &#123;
        x = x * 10 + ch - &#39;0&#39;;
        ch = nec();
    &#125;
    if (f) x = -x;
    return 1;
&#125;
signed main() &#123;
    read(n); read(s);
    memset(f, 0x3f, sizeof (f));
    for (int i = 1; i &lt;= n; ++i) &#123;
        read(t[i]); read(c[i]);
        t[i] += t[i - 1];
        c[i] += c[i - 1];
    &#125;
    f[0] = 0;
    for (int i = 1; i &lt;= n; ++i) &#123;
        for (int j = 0; j &lt; i; ++j)
            f[i] = min(f[i], f[j] + t[i]* (c[i] - c[j]) + s * (c[n] - c[j]));
    &#125;
    printf(&quot;%lld&quot;, f[n]);
    return 0;
&#125;</code></pre>
<hr />
<h3 id="任务安排-2"><a target="_blank" rel="noopener" href="https://loj.ac/p/10185">任务安排 2</a></h3>
<p><a
target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/303/">双倍经验</a></p>
<p><span class="math inline">\(n\)</span> 的范围变大了，<span
class="math inline">\(n^2\)</span> 过不了。</p>
<h4 id="solution-3">Solution</h4>
<p>这不随手加个斜率优化的事儿吗。</p>
<p>我们继续瞎搞这个式子。 <span class="math display">\[
\begin{aligned}
f_i&amp;=\min\{f_j+(c_i-c_j)\times t_i+s\times(c_n-c_j)\}
\\
&amp;=\min\{f_j+c_i\times t_i-c_j\times t_i+s\times c_n-s\times c_j\}
\\
&amp;=\min\{f_j-c_j\times t_i-s\times c_j\}+c_i\times t_i+s\times c_n
\end{aligned}
\]</span> 令 <span class="math inline">\(j\)</span> 优于 <span
class="math inline">\(k\)</span> 且 <span
class="math inline">\(j&lt;k\)</span> 。</p>
<p>则有： <span class="math display">\[
f_j-c_j\times t_i-s\times c_j&lt;f_k-c_k\times t_i-s\times c_k
\\
f_j-f_k-s\times c_j+s\times c_k&lt;c_j\times t_i-c_k\times t_i
\\
f_j-f_k-s\times c_j+s\times c_k&lt;t_i\times(c_j-c_k)
\\
\dfrac{(f_j-s\times c_j)-(f_k-s\times c_k)}{(c_j)-(c_k)}&lt;t_i
\]</span> 然后就是老套路。</p>
<p>时间复杂度 <span class="math inline">\(\mathcal O(n)\)</span>。</p>
<h4 id="code-2">Code</h4>
<pre class="cpp"><code>#include &lt;cstdio&gt;
#define int long long
const int maxn = 5e5 + 5;
const int LEN = (1 &lt;&lt; 20);
int n, s, L, R;
int f[maxn], t[maxn], c[maxn], q[maxn];
#define nec getchar
inline bool read(int &amp;x) &#123;
    char ch = nec();
    bool f = 0; x = 0;
    while (ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123;
        if (ch == EOF) return 0;
        if (ch == &#39;-&#39;) f = 1; ch = nec();
    &#125;
    while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) &#123;
        x = x * 10 + ch - &#39;0&#39;;
        ch = nec();
    &#125;
    if (f) x = -x;
    return 1;
&#125;
inline int getup(int j, int k) &#123; return (f[j] - s * c[j]) - (f[k] - s * c[k]); &#125;
inline int getdown(int j, int k) &#123; return (c[j]) - (c[k]); &#125;
inline int getDP(int i, int j) &#123; return f[j] + (c[i] - c[j]) * t[i] + s * (c[n] - c[j]); &#125;
signed main() &#123;
    read(n); read(s);
    L = R = 1;
    for (int i = 1; i &lt;= n; ++i) &#123;
        read(t[i]); read(c[i]);
        t[i] += t[i - 1];
        c[i] += c[i - 1];
    &#125;
    for (int i = 1; i &lt;= n; ++i) &#123;
        while (L &lt; R &amp;&amp; getup(q[L + 1], q[L]) &lt;= t[i] * getdown(q[L + 1], q[L]))
            ++L;
        f[i] = getDP(i, q[L]);
        while (L &lt; R &amp;&amp; getup(i, q[R]) * getdown(q[R], q[R - 1]) &lt;= getdown(i, q[R]) * getup(q[R], q[R - 1]))
            --R;
        q[++R] = i;
    &#125;
    printf(&quot;%lld&quot;, f[n]);
    return 0;
&#125;</code></pre>
<hr />
<h3 id="任务安排-3"><a
target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P5785">任务安排 3</a></h3>
<p><a target="_blank" rel="noopener" href="https://loj.ac/p/10186">双倍经验</a> | <a
target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/304/">三倍经验</a></p>
<p>注意 <span class="math inline">\(t\)</span> 有可能是负数。</p>
<h4 id="solution-4">Solution</h4>
<p><span class="math inline">\(t\)</span> （输入）有可能为负，代表着
<span
class="math inline">\(t\)</span>（前缀和）不再单调递增，用不单调的对象作为单调队列的条件一看就十分不讲武德，这样维护出来的队头显然不是正确答案。</p>
<p>后面的 <span class="math inline">\(t,c\)</span> 默认为前缀和。</p>
<p>我们感性证明一下。</p>
<p>一个最普通的例子，假设输入了一个负数，导致 <span
class="math inline">\(t_i&lt;t_{i-1}\)</span>，且有一斜率 <span
class="math inline">\(&gt;t_i\)</span> 且 <span
class="math inline">\(&lt;t_{i-1}\)</span>。</p>
<p>那么在 <span class="math inline">\(i-1\)</span>
时，它就被维护队头的操作剔掉了，但也许它凑巧就是 <span
class="math inline">\(i\)</span> 的最优解，呜呼哀哉。</p>
<p>于是我们不能删队头元素了。那怎么查询最优解呢？</p>
<p>单调队列里装的始终还是个具有单调性的下凸包，于是我们可以在队列中二分一个
<span class="math inline">\(pos\)</span>，<span
class="math inline">\(pos\)</span> 与 <span
class="math inline">\(pos-1\)</span> 形成的斜率比 <span
class="math inline">\(t_i\)</span> 小，<span
class="math inline">\(pos+1\)</span> 与 <span
class="math inline">\(pos\)</span> 形成的斜率比 <span
class="math inline">\(t_i\)</span> 大。</p>
<p>然后把 <span class="math inline">\(pos\)</span> 当成 <span
class="math inline">\(q_l\)</span> 来处理就好了。</p>
<p>队尾还是维护一个下凸。</p>
<p>时间复杂度 <span class="math inline">\(\mathcal
O(n\log_2n)\)</span>。</p>
<h4 id="code-3">Code</h4>
<p><em>强烈建议不要去动 AcWing 版本的那道。</em></p>
<p><em>最后两组数据堪称毒瘤。</em></p>
<p><em>卡 <code>long long</code> 乘法，卡 <code>__int128</code> 时限，卡
<code>double</code>精度，非 T 即 WA。</em></p>
<p><em>反正我搞了半个小时硬是没有搞出来。</em></p>
<pre class="cpp"><code>#include &lt;cstdio&gt;
#define int long long
const int maxn = 3e5 + 5;
const int LEN = (1 &lt;&lt; 20);
int n, s, L, R;
int f[maxn], t[maxn], c[maxn], q[maxn];
#define nec getchar
inline bool read(int &amp;x) &#123;
    char ch = nec();
    bool f = 0; x = 0;
    while (ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123;
        if (ch == EOF) return 0;
        if (ch == &#39;-&#39;) f = 1; ch = nec();
    &#125;
    while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) &#123;
        x = x * 10 + ch - &#39;0&#39;;
        ch = nec();
    &#125;
    if (f) x = -x;
    return 1;
&#125;
inline int getup(int j, int k) &#123; return (f[j] - s * c[j]) - (f[k] - s * c[k]); &#125;
inline int getdown(int j, int k) &#123; return (c[j]) - (c[k]); &#125;
inline int getDP(int i, int j) &#123; return f[j] + t[i] * (c[i] - c[j]) + s * (c[n] - c[j]); &#125;
inline int Func(int u) &#123;
    if (L == R) return q[L];
    int l = L, r = R;
    while (l &lt; r) &#123;
        int mid = l + r &gt;&gt; 1;
        if (getup(q[mid + 1], q[mid]) &lt;= u * getdown(q[mid + 1], q[mid]))
            l = mid + 1;
        else r = mid;
    &#125;
    return l;
&#125;
signed main() &#123;
    read(n); read(s);
    L = R = 1;
    for (int i = 1; i &lt;= n; ++i) &#123;
        read(t[i]); read(c[i]);
        t[i] += t[i - 1];
        c[i] += c[i - 1];
    &#125;
    for (int i = 1; i &lt;= n; ++i) &#123;
        int Best = Func(t[i]);
        f[i] = getDP(i, q[Best]);
        while (L &lt; R &amp;&amp; getup(i, q[R]) * getdown(q[R], q[R - 1]) &lt;= getdown(i, q[R]) * getup(q[R], q[R - 1]))
            --R;
        q[++R] = i;
    &#125;
    printf(&quot;%lld&quot;, f[n]);
    return 0;
&#125;</code></pre>
<hr />
<h3 id="土地购买"><a
target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2900">土地购买</a></h3>
<h4 id="solution-5">Solution</h4>
<p>首先我们想明白一件事情：如果一块土地，有另一块土地的长和宽都比它大，那就不用再理它了，直接从总序列里剔除。</p>
<pre class="cpp"><code>struct _ &#123;
    int w, l;
    bool operator&lt; (const _ q) const &#123;
        return w == q.w ? l &gt; q.l : w &gt; q.w;
    &#125;
&#125; a[maxn];
...

std::sort(a + 1, a + n + 1);
for (int i = 1; i &lt;= n; ++i) &#123;
    if (a[i].l &gt; a[cnt].l)
        a[++cnt] = a[i];
&#125;</code></pre>
<p>然后就推式子。</p>
<p>贪心地想，在前面的操作后，<span class="math inline">\(a\)</span>
是一个 <span class="math inline">\(w\)</span> 递减，<span
class="math inline">\(l\)</span> 递增的土地序列。</p>
<p>所以我们选择将连续的一段区间分为一组，这样的话，一个组里的一段连续的土地
<span class="math inline">\([x,y]\)</span> 就只有 <span
class="math inline">\(w_x\)</span> 和 <span
class="math inline">\(l_y\)</span>
起了作用，又没有中间那一段的事了。</p>
<p>设 <span class="math inline">\(f_i\)</span> 表示分配完第 <span
class="math inline">\(i\)</span> 块土地后的最小花费。</p>
<p>则有： <span class="math display">\[
f_i=\min\{f_j+w_{j+1}\times l_i\}
\]</span> 令 <span class="math inline">\(j\)</span> 优于 <span
class="math inline">\(k\)</span>。</p>
<p>则有： <span class="math display">\[
f_j+w_{j+1}\times l_i&lt;f_k+w_{k+1}\times l_i
\\
f_j-f_k&lt;(-w_{j+1}+w_{k+1})\times l_i
\\
\dfrac{(f_j)-(f_k)}{(-w_{j+1})+(w_{k+1})}&lt;l_i
\]</span></p>
<h4 id="code-4">Code</h4>
<pre class="cpp"><code>#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#define int long long
const int maxn = 5e4 + 5;
struct _ &#123;
    int w, l;
    bool operator&lt; (const _ q) const&#123;
        return w == q.w ? l &gt; q.l : w &gt; q.w;
    &#125;
&#125;;
_ a[maxn];
int n, cnt, l, r;
int q[maxn], f[maxn];
int getup(int j, int k) &#123; return f[j] - f[k]; &#125;
int getdown(int j,int k) &#123; return a[k + 1].w - a[j + 1].w; &#125;
int getDP(int i,int j) &#123; return f[j] + a[j + 1].w * a[i].l; &#125;
signed main() &#123;
    scanf(&quot;%lld&quot;, &amp;n);
    for(int i = 1; i &lt;= n; ++i)
        scanf(&quot;%lld %lld&quot;, &amp;a[i].w, &amp;a[i].l);
    std::sort(a + 1, a + n + 1);
    for (int i = 1; i &lt;= n; ++i) &#123;
        if (a[i].l &gt; a[cnt].l)
            a[++cnt] = a[i];
    &#125;
    n = cnt; l = r = 1;
    for (int i = 1; i &lt;= n; ++i) &#123;
        while (l &lt; r &amp;&amp; getup(q[l + 1], q[l]) &lt;= a[i].l * getdown(q[l + 1], q[l]))
            l++;
        f[i] = getDP(i, q[l]);
        while (l &lt; r &amp;&amp; getup(i, q[r]) * getdown(q[r], q[r - 1]) &lt;= getup(q[r],q[r - 1]) * getdown(i, q[r]))
            r--;
        q[++r] = i;
    &#125;
    printf(&quot;%lld&quot;, f[n]);
    return 0;
&#125;</code></pre>
<hr />
<h3 id="仓库建设"><a
target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2120">仓库建设</a></h3>
<p><a target="_blank" rel="noopener" href="https://loj.ac/p/10189">双倍经验</a> | <a
target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/description/1095/">三倍经验</a></p>
<h4 id="solution-6">Solution</h4>
<p>设 <span class="math inline">\(f_i\)</span> 表示在 <span
class="math inline">\(i\)</span> 工厂建立仓库的最小花费。</p>
<p>则有： <span class="math display">\[
\begin{aligned}
f_i&amp;=\min\{f_j+\sum\limits_{k=j+1}^{i-1}[(x_i-x_k)\times p_k]+c_i\}
\\
&amp;=\min\{f_j+\sum\limits_{k=j+1}^{i-1}(x_i\times
p_k)-\sum\limits_{k=j+1}^{i-1}(x_k\times p_k)\}+c_i
\\
&amp;=\min\{f_j+x_i\times\sum\limits_{k=j+1}^{i-1}p_k-\sum\limits_{k=j+1}^{i-1}(x_k\times
p_k)\}+c_i
\end{aligned}
\]</span> 利用前缀和优化：设 <span class="math inline">\(a\)</span> 为
<span class="math inline">\(p\)</span> 的前缀和数组，<span
class="math inline">\(b\)</span> 为 <span
class="math inline">\(x_i\times p_i\)</span> 的前缀和数组。</p>
<p>则原式可化为： <span class="math display">\[
\begin{aligned}
f_i&amp;=\min\{f_j+x_i\times(a_{i-1}-a_j)-(b_{i-1}-b_j)\}+c_i
\\
&amp;=\min\{f_j+x_i\times a_{i-1}-x_i\times a_j-b_{i-1}+b_j\}+c_i
\\
&amp;=\min\{f_j-x_i\times a_j+b_j\}+x_i\times a_{i-1}-b_{i-1}+c_i
\end{aligned}
\]</span> 令 <span class="math inline">\(j\)</span> 优于 <span
class="math inline">\(k\)</span> 。</p>
<p>则有： <span class="math display">\[
f_j-x_i\times a_j+b_j&lt;f_k-x_i\times a_k+b_k
\\
f_j-f_k+b_j-b_k&lt;x_i\times a_j-x_i\times a_k
\\
\dfrac{(f_j+b_j)-(f_k+b_k)}{a_j-a_k}&lt;x_i
\]</span></p>
<h4 id="code-5">Code</h4>
<p><em>想感受人生的同学们可以尝试做一下 AcWing 那个版本，非 MLE 即
WA，爽到炸。</em></p>
<pre class="cpp"><code>#include &lt;cstdio&gt;
#define int long long
const int maxn = 1e6 + 5;
const int LEN = (1 &lt;&lt; 20);
int n, L, R;
int f[maxn], x[maxn], p[maxn];
int a[maxn], b[maxn], c[maxn], q[maxn];
#ifdef ONLINE_JUDGE
inline int nec(void) &#123;
    static char buf[LEN], *p = buf, *e = buf;
    if (p == e) &#123;
        e = buf + fread(buf, 1, LEN, stdin);
        if (e == buf) return EOF; p = buf;
    &#125;
    return *p++;
&#125;
#else
#define nec getchar
#endif
inline bool read(int &amp;x) &#123;
    char ch = nec();
    bool f = 0; x = 0;
    while (ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123;
        if (ch == EOF) return 0;
        if (ch == &#39;-&#39;) f = 1;
        ch = nec();
    &#125;
    while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) &#123;
        x = x * 10 + ch - &#39;0&#39;;
        ch = nec();
    &#125;
    if (f) x = -x;
    return 1;
&#125;
inline int getup(int j, int k) &#123; return (f[j] + b[j]) - (f[k] + b[k]); &#125;
inline int getdown(int j, int k) &#123; return (a[j]) - (a[k]); &#125;
inline int getDP(int i, int j) &#123; return f[j] - x[i] * a[j] + b[j] + x[i] * a[i - 1] - b[i - 1] + c[i]; &#125;
signed main() &#123;
    read(n); L = R = 1;
    for (int i = 1; i &lt;= n; ++i) &#123;
        read(x[i]); read(p[i]); read(c[i]);
        a[i] = a[i - 1] + p[i];
        b[i] = b[i - 1] + x[i] * p[i];
    &#125;
    for (int i = 1; i &lt;= n; ++i) &#123;
        while (L &lt; R &amp;&amp; getup(q[L + 1], q[L]) &lt;= x[i] * getdown(q[L + 1], q[L]))
            ++L;
        f[i] = getDP(i, q[L]);
        while (L &lt; R &amp;&amp; getup(i, q[R]) * getdown(q[R], q[R - 1]) &lt;= getdown(i, q[R]) * getup(q[R], q[R - 1]))
            --R;
        q[++R] = i;
    &#125;
    printf(&quot;%lld&quot;, f[n]);
    return 0;
&#125;</code></pre>
<hr />
<h3 id="锯木厂选址"><a
target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P4360">锯木厂选址</a></h3>
<p><a target="_blank" rel="noopener" href="https://loj.ac/p/10192">双倍经验</a> | <a
target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/1097/">三倍经验</a></p>
<h4 id="solution-7">Solution</h4>
<p>和仓库建设很像。</p>
<p>设 <span
class="math inline">\(A_i=\sum\limits_{j=i}^nd_j\)</span>，表示第 <span
class="math inline">\(i\)</span> 棵树与山脚的距离；<span
class="math inline">\(B_i=\sum\limits_{j=1}^iw_j\)</span>，表示 <span
class="math inline">\(w\)</span> 的前缀和；<span
class="math inline">\(S=\sum\limits_{i=1}^nA_i\times
w_i\)</span>，表示将所有树全部运到山脚的花费总和。</p>
<p>假设在 <span class="math inline">\(j\)</span> 处建立第 <span
class="math inline">\(1\)</span> 座锯木厂，在 <span
class="math inline">\(i\)</span> 处建立第 <span
class="math inline">\(2\)</span> 座锯木厂，此时：</p>
<ul>
<li>对于第 <span class="math inline">\(1\sim j\)</span> 棵树来说，<span
class="math inline">\(S\)</span> 比实际情况多运了 <span
class="math inline">\(A_j\)</span> 的路程；</li>
<li>对于第 <span class="math inline">\(j+1\sim i\)</span>
棵树来说，<span class="math inline">\(S\)</span> 比实际情况多运了 <span
class="math inline">\(A_i\)</span> 的路程。</li>
</ul>
<p>将对应的多运的距离与花费相乘的结果，让 <span
class="math inline">\(S\)</span> 将其减去即可。 <span
class="math display">\[
\begin{aligned}
ans&amp;=\min\{S-A_j\times B_j-(B_i-B_j)\times A_i\}\\
   &amp;=\min\{A_i\times B_j-A_j\times B_j\}+S-A_i\times B_i
\end{aligned}
\]</span> 令 <span class="math inline">\(j&lt;k\)</span> 且 <span
class="math inline">\(j\)</span> 优于 <span
class="math inline">\(k\)</span>，则有： <span class="math display">\[
\begin{aligned}
A_i\times B_j-A_j\times B_j&amp;&lt;A_i\times B_k-A_k\times B_k\\
-A_j\times B_j+A_k\times B_k&amp;&lt;-A_i\times B_j+A_i\times B_k\\
\dfrac{-A_j\times B_j+A_k\times B_k}{-B_j+B_k}&amp;&lt;A_i\\
\dfrac{A_j\times B_j-A_k\times B_k}{B_j-B_k}&amp;&lt;A_i\\
\end{aligned}
\]</span> 其中，<span class="math inline">\(A_i\)</span>
具有单调性，可以直接套板子。</p>
<h4 id="code-6">Code</h4>
<pre class="cpp"><code>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#define int long long
const int inf = 1e18;
const int maxn = 1e6 + 5;
const int LEN = (1 &lt;&lt; 20);
int w[maxn], d[maxn];
int n, L, R, s, ans = inf;
int q[maxn], a[maxn], b[maxn];
inline int min(int x, int y) &#123; return x &lt; y ? x : y; &#125;
inline int getDP(int i, int j) &#123;
    return s - a[j] * b[j] - (b[i] - b[j]) * a[i];
&#125;
inline int getup(int j, int k) &#123;
    return a[j] * b[j] - a[k] * b[k];
&#125;
inline int getdown(int j, int k) &#123;
    return b[j] - b[k];
&#125;
#ifdef ONLINE_JUDGE
inline int nec(void) &#123;
    static char buf[LEN], *p = buf, *e = buf;
    if (p == e) &#123;
        e = buf + fread(buf, 1, LEN, stdin);
        if (e == buf) return EOF; p = buf;
    &#125;
    return *p++;
&#125;
#else
#define nec getchar
#endif
inline bool read(int &amp;x) &#123;
    char ch = nec();
    bool f = 0; x = 0;
    while (ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123;
        if (ch == EOF) return 0;
        if (ch == &#39;-&#39;) f = 1;
        ch = nec();
    &#125;
    while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) &#123;
        x = x * 10 + ch - &#39;0&#39;;
        ch = nec();
    &#125;
    if (f) x = -x;
    return 1;
&#125;
signed main() &#123;
    read(n);
    L = R = 1;
    for (int i = 1; i &lt;= n; ++i) &#123;
        read(w[i]), read(d[i]);
        b[i] = b[i - 1] + w[i];
    &#125;
    for (int i = n; i; --i) &#123;
        a[i] = a[i + 1] + d[i];
        s += a[i] * w[i];
    &#125;
    for (int i = 1; i &lt;= n; ++i) &#123;
        while (L &lt; R &amp;&amp; getup(q[L + 1], q[L]) &gt;= a[i] * getdown(q[L + 1], q[L]))
            ++L;
        ans = min(ans, getDP(i, q[L]));
        while (L &lt; R &amp;&amp; getup(i, q[R]) * getdown(q[R], q[R - 1]) &gt;= getup(q[R], q[R - 1]) * getdown(i, q[R]))
            --R;
        q[++R] = i;
    &#125;
    printf(&quot;%lld&quot;, ans);
    return 0;
&#125;</code></pre>
<hr />
<h3 id="cats-transport"><a
target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/CF311B">Cats Transport</a></h3>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/305/">双倍经验</a> |
<a
target="_blank" rel="noopener" href="http://codeforces.com/problemset/problem/311/B">三倍经验</a></p>
<p>经验：洛谷的题面比蓝书和 AcWing 上的标准多了，蓝书的题意不清。</p>
<h4 id="solution-8">Solution</h4>
<p>研究表明，边猛灌养乐多边看蓝书有助于理解。</p>
<p>这道题难在推式子。<del>不然还能难在哪里</del></p>
<p>设 <span class="math inline">\(A_i\)</span> 表示要接到第 <span
class="math inline">\(i\)</span>
只猫的最早出发时间，也就是说，在此时出发，猫 <span
class="math inline">\(i\)</span> 的等待时间为 <span
class="math inline">\(0\)</span>。</p>
<p>即 <span
class="math inline">\(A_i=T_i-\sum\limits_{j=1}^{H_i}D_j\)</span>，也就是出发时间=到达时间-经过时间。</p>
<p>此时我们可以把其他所有因素去掉，题意转换为：</p>
<blockquote>
<p>已知在 <span class="math inline">\(\geqslant A_i\)</span>
的时刻出发可以接到猫 <span class="math inline">\(i\)</span> ，在 <span
class="math inline">\(P\)</span>
次出发次数的限制内接到所有猫，猫的等待时间之和最小是多少？</p>
</blockquote>
<p>假设饲养员在 <span class="math inline">\(t\)</span> 时刻出发，猫
<span class="math inline">\(i\)</span> 的等待时间就是 <span
class="math inline">\(t-A_i\)</span>。</p>
<p>对 <span class="math inline">\(A_i\)</span> 从小到大排序。</p>
<p>显然，一次接一段连续的猫，花费自然是最小的。</p>
<p>若我们要接 <span class="math inline">\([k+1,j]\)</span>
范围内的猫，它们的等待时间之和就是： <span class="math display">\[
\begin{aligned}
\sum\limits_{p=k+1}^{j}(A_j-A_p)&amp;=[j-(k+1)+1]A_j-\sum\limits_{p=k+1}^{j}A_p
\\
&amp;=(j-k)\times A_j-(S_j-S_k)
\\
&amp;=j\times A_j-k\times A_j-S_j+S_k
\end{aligned}
\]</span> 其中 <span class="math inline">\(S\)</span> 为 <span
class="math inline">\(A\)</span> 的前缀和。</p>
<p>设 <span class="math inline">\(f_{i,j}\)</span> 表示前 <span
class="math inline">\(i\)</span> 个饲养员带走前 <span
class="math inline">\(j\)</span> 只猫的最小花费。</p>
<p>则有： <span class="math display">\[
\begin{aligned}
f_{i,j}&amp;=\min\{f_{i-1,k}+j\times A_j-k\times A_j-S_j+S_k\}
\\
&amp;=\min\{f_{i-1,k}-A_j\times k+S_k\}+A_j\times j-S_j
\end{aligned}
\]</span></p>
<p>我们将循环地枚举每个饲养员的循环变量 <span
class="math inline">\(i\)</span> 看做常量。</p>
<p>令 <span class="math inline">\(x\)</span> 优于 <span
class="math inline">\(y\)</span>，则有： <span class="math display">\[
f_{i-1,x}-A_j\times x+S_x&lt;f_{i-1,y}-A_j\times y+S_y
\\
\dfrac{(f_{i-1,x}+S_x)-(f_{i-1,y+S_y})}{x-y}&lt;A_j
\]</span> <strong>注意事项</strong></p>
<p><span class="math inline">\(f\)</span> 初始化为极大值。</p>
<h4 id="code-7">Code</h4>
<pre class="cpp"><code>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#define int long long
const int maxp = 105;
const int maxn = 1e5 + 5;
const int LEN = (1 &lt;&lt; 20);
int f[maxp][maxn];
int n, m, p, L, R, t, h;
int q[maxn], a[maxn], d[maxn], s[maxn];
inline int getDP(int i, int j, int k) &#123;
    return f[i - 1][k] + (j - k) * a[j] - (s[j] - s[k]);
&#125;
inline int getup(int i, int j, int k) &#123;
    return (f[i - 1][j] + s[j]) - (f[i - 1][k] + s[k]);
&#125;
inline int getdown(int j, int k) &#123;
    return (j) - (k);
&#125;
#ifdef ONLINE_JUDGE
inline int nec(void) &#123;
    static char buf[LEN], *p = buf, *e = buf;
    if (p == e) &#123;
        e = buf + fread(buf, 1, LEN, stdin);
        if (e == buf) return EOF; p = buf;
    &#125;
    return *p++;
&#125;
#else
#define nec getchar
#endif
inline bool read(int &amp;x) &#123;
    char ch = nec();
    bool f = 0; x = 0;
    while (ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123;
        if (ch == EOF) return 0;
        if (ch == &#39;-&#39;) f = 1;
        ch = nec();
    &#125;
    while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) &#123;
        x = x * 10 + ch - &#39;0&#39;;
        ch = nec();
    &#125;
    if (f) x = -x;
    return 1;
&#125;
signed main() &#123;
    read(n); read(m); read(p);
    memset(f, 0x3f, sizeof (f));
    for (int i = 2; i &lt;= n; ++i)
        read(d[i]), d[i] += d[i - 1];
    for (int i = 1; i &lt;= m; ++i) &#123;
        read(h); read(t);
        a[i] = t - d[h];
    &#125;
    std::sort(a + 1, a + m + 1);
    for (int i = 1; i &lt;= m; ++i)
        s[i] = s[i - 1] + a[i];
    f[0][0] = 0;
    for (int i = 1; i &lt;= p; ++i) &#123;
        L = R = 1;
        for (int j = 1; j &lt;= m; ++j) &#123;
            while (L &lt; R &amp;&amp; getup(i, q[L + 1], q[L]) &lt;= a[j] * getdown(q[L + 1], q[L]))
                ++L;
            f[i][j] = getDP(i, j, q[L]);
            while (L &lt; R &amp;&amp; getup(i, j, q[R]) * getdown(q[R], q[R - 1]) &lt;= getup(i, q[R], q[R - 1]) * getdown(j, q[R]))
                --R;
            q[++R] = j;
        &#125;
    &#125;
    printf(&quot;%lld&quot;, f[p][m]);
    return 0;
&#125;</code></pre>
<hr />
<h3 id="特别行动队"><a
target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3628">特别行动队</a></h3>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/337/">双倍经验</a> |
<a target="_blank" rel="noopener" href="https://loj.ac/p/10190">三倍经验</a></p>
<h4 id="solution-9">Solution</h4>
<p>直接推式子。 <span class="math display">\[
\begin{aligned}
f_i&amp;=\max\{f_j+a\times(s_i-s_j)^2+b\times(s_i-s_j)+c\ \}\\
&amp;=\max\{f_j+a\times({s_i}^2-2\times s_i\times s_j+{s_j}^2)+b\times
s_i-b\times s_j\ \}+c\\
&amp;=\max\{f_j+a\times{s_i}^2-2\times a\times s_i\times
s_j+a\times{s_j}^2-b\times s_j\ \}+b\times s_i+c\\
&amp;=\max\{f_j-2\times a\times s_i\times s_j+a\times{s_j}^2-b\times
s_j\ \}+a\times{s_i}^2+b\times s_i+c\\
\end{aligned}
\]</span> 令 <span class="math inline">\(j\)</span> 优于 <span
class="math inline">\(k\)</span>，则有： <span class="math display">\[
\begin{aligned}
f_j-2\times a\times s_i\times s_j+a\times{s_j}^2-b\times
s_j&amp;&gt;f_k-2\times a\times s_i\times s_k+a\times{s_k}^2-b\times
s_k\\
(f_j+a\times{s_j}^2-b\times s_j)-(f_k+a\times{s_k}^2-b\times
s_k)&amp;&gt;(2\times a\times s_i\times s_j)-(2\times a\times s_i\times
s_k)\\
\dfrac{(f_j+a\times{s_j}^2-b\times s_j)-(f_k+a\times{s_k}^2-b\times
s_k)}{(2\times a\times s_j) - (2\times a\times s_k)}&amp;&gt;s_i\\
\end{aligned}
\]</span> 我们发现中间的符号是 <span
class="math inline">\(&gt;\)</span>。</p>
<p>所以我们在弹队头的时候，要把判断条件中的符号反过来。</p>
<h4 id="code-8">Code</h4>
<pre class="cpp"><code>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#define int long long
const int maxn = 1e6 + 5;
const int LEN = (1 &lt;&lt; 20);
int n, L, R, a, b ,c;
int q[maxn], s[maxn], f[maxn];
inline int getDP(int i, int j) &#123;
    return f[j] + a * (s[i] - s[j]) * (s[i] - s[j]) + b * (s[i] - s[j]) + c;
&#125;
inline int getup(int j, int k) &#123;
    return (f[j] + a * s[j] * s[j] - b * s[j]) - (f[k] + a * s[k] * s[k] - b * s[k]);
&#125;
inline int getdown(int j, int k) &#123;
    return (2 * a * s[j]) - (2 * a * s[k]);
&#125;
#ifdef ONLINE_JUDGE
inline int nec(void) &#123;
    static char buf[LEN], *p = buf, *e = buf;
    if (p == e) &#123;
        e = buf + fread(buf, 1, LEN, stdin);
        if (e == buf) return EOF; p = buf;
    &#125;
    return *p++;
&#125;
#else
#define nec getchar
#endif
inline bool read(int &amp;x) &#123;
    char ch = nec();
    bool f = 0; x = 0;
    while (ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123;
        if (ch == EOF) return 0;
        if (ch == &#39;-&#39;) f = 1;
        ch = nec();
    &#125;
    while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) &#123;
        x = x * 10 + ch - &#39;0&#39;;
        ch = nec();
    &#125;
    if (f) x = -x;
    return 1;
&#125;
signed main() &#123;
    read(n); read(a); read(b); read(c);
    L = R = 1;
    for (int i = 1; i &lt;= n; ++i) &#123;
        read(s[i]), s[i] += s[i - 1];
        while (L &lt; R &amp;&amp; getup(q[L + 1], q[L]) &gt;= s[i] * getdown(q[L + 1], q[L]))
            ++L;
        f[i] = getDP(i, q[L]);
        while (L &lt; R &amp;&amp; getup(i, q[R]) * getdown(q[R], q[R - 1]) &lt;= getup(q[R], q[R - 1]) * getdown(i, q[R]))
            --R;
        q[++R] = i;
    &#125;
    printf(&quot;%lld&quot;, f[n]);
    return 0;
&#125;</code></pre>
<hr />
<h3 id="征途"><a
target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P4072">征途</a></h3>
<p><a target="_blank" rel="noopener" href="https://loj.ac/p/2035">双倍经验</a> | <a
target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/2575/">三倍经验</a></p>
<h4 id="solution-10">Solution</h4>
<p>明显，不化掉 <span class="math inline">\(v\times m^2\)</span>
就无法进行优化。</p>
<p>设 <span class="math inline">\(x\)</span>
为当前休息站点与上一休息站点的距离， <span
class="math inline">\(x_0\)</span> 为 <span
class="math inline">\(x_1\sim x_n\)</span> 的平均数，<span
class="math inline">\(S\)</span> 为 <span
class="math inline">\(x\)</span> 的前缀和。 <span
class="math display">\[
\begin{aligned}
V\times m^2&amp;=[(x_1-x_0)^2+(x_2-x_0)^2+\cdots+(x_m-x_0)^2]\times m
\\
&amp;=m\times \sum\limits_{i=1}^{m}{x_i}^2+(m\times {x_0})^2-2\times
(x_0\times m)\times \sum\limits_{i=1}^{m}x_i
\\
&amp;=m\times \sum\limits_{i=1}^{m}{x_i}^2+{S_m}^2-2\times{S_m}^2
\\
&amp;=m\times \sum\limits_{i=1}^{m}{x_i}^2-{S_m}^2
\end{aligned}
\]</span></p>
<p>其中 <span class="math inline">\(S_m\)</span>
是一个定值（即输入所有路的长度和）。</p>
<p>唯一需要计算的，就是 <span
class="math inline">\(\sum\limits_{i=1}^{m}{x_i}^{2}\)</span>，所以我们就来
DP 它。</p>
<p>设 <span class="math inline">\(a\)</span>
为输入道路长度的前缀和数组，<span class="math inline">\(f_{i,j}\)</span>
表示第 <span class="math inline">\(i\)</span> 次休息在 <span
class="math inline">\(j\)</span> 处时 <span
class="math inline">\(\min\{\sum\limits_{k=1}^{i}{x_k}^2\}\)</span>
的值，则有： <span class="math display">\[
\begin{aligned}
f_{i,j}&amp;=\min\{f_{i-1,j}+(a_i-a_j)^2\}
\\
&amp;=\min\{f_{i-1,j}+{a_i}^2-2\times a_i\times a_j+{a_j}^2\}
\end{aligned}
\]</span> 令 <span class="math inline">\(j\)</span> 优于 <span
class="math inline">\(k\)</span>，则有： <span class="math display">\[
f_{i-1,j}-2\times a_i\times a_j+{a_j}^2&lt;f_{i-1,k}-2\times a_i\times
a_k+{a_k}^2
\\
f_{i-1,j}-f_{i-1,k}+{a_j}^2-{a_k}^2&lt;2\times a_i\times(a_j-a_k)
\\
\dfrac{f_{i-1,j}-f_{i-1,k}+{a_j}^2-{a_k}^2}{2\times(a_j-a_k)}&lt;a_i
\]</span> ##### 注意事项</p>
<p>初始化。</p>
<p>将 <span class="math inline">\(f\)</span> 初始化为极大值。</p>
<h4 id="code-9">Code</h4>
<p>在 AcWing 上将 <code>memset</code> 改为初始化
<code>f[0][i] = a[i] * a[i]</code> 就可以过了，不然会
MLE，也许是因为没开滚动。（本来也用不着滚</p>
<pre class="cpp"><code>#include &lt;cstdio&gt;
#define int long long
const int inf = 1e18;
const int maxn = 3005;
const int LEN = (1 &lt;&lt; 20);
int f[maxn][maxn];
int a[maxn], q[maxn];
int n, m, L, R, ans = inf;
#ifdef ONLINE_JUDGE
inline int nec(void) &#123;
    static char buf[LEN], *p = buf, *e = buf;
    if (p == e) &#123;
        e = buf + fread(buf, 1, LEN, stdin);
        if (e == buf) return EOF; p = buf;
    &#125;
    return *p++;
&#125;
#else
#define nec getchar
#endif
inline bool read(int &amp;x) &#123;
    char ch = nec();
    bool f = 0; x = 0;
    while (ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123;
        if (ch == EOF) return 0;
        if (ch == &#39;-&#39;) f = 1;
        ch = nec();
    &#125;
    while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) &#123;
        x = x * 10 + ch - &#39;0&#39;;
        ch = nec();
    &#125;
    if (f) x = -x;
    return 1;
&#125;
inline int min(int x, int y) &#123; return x &lt; y ? x : y; &#125;
int getDP(int i, int j, int k) &#123;
    return f[k - 1][j] + (a[i] - a[j]) * (a[i] - a[j]);
&#125;
int getup(int j, int k, int i) &#123;
    return f[i - 1][j] - f[i - 1][k] + a[j] * a[j] - a[k] * a[k];
&#125;
int getdown(int j, int k) &#123;
    return (a[j] - a[k]) &lt;&lt; 1;
&#125;
signed main()&#123;
    read(n); read(m);
    for (int i = 1; i &lt;= n; ++i) &#123;
        read(a[i]);
        a[i] += a[i - 1];
        f[0][i] = a[i] * a[i];
    &#125;
    for (int i = 1; i &lt; m; ++i) &#123;
        L = R = 1; q[L] = i;
        for (int j = i; j &lt;= n; ++j) &#123;
            while (L &lt; R &amp;&amp; getup(q[L + 1], q[L], i) &lt;= a[j] * getdown(q[L + 1], q[L]))
                ++L;
            f[i][j] = getDP(j, q[L], i);
            while (L &lt; R &amp;&amp; getup(i, q[R], i) * getdown(q[R], q[R - 1]) &lt;= getup(q[R], q[R - 1], i) * getdown(i, q[R]))
                --R;
            q[++R] = j;
        &#125;
    &#125;
    printf(&quot;%lld&quot;,m * f[m - 1][n] - a[n] * a[n]);
    return 0;
&#125;</code></pre>
<hr />
<h3 id="柠檬"><a
target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P5504">柠檬</a></h3>
<p><a
target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/2396/">双倍经验</a></p>
<h4 id="solution-11">Solution</h4>
<p>是边写这篇题解边做的（</p>
<p>题意：</p>
<p>有一个含有 <span class="math inline">\(n\)</span> 个元素的序列 <span
class="math inline">\(s\)</span>。将这个序列分成连续的若干段，定义每一段的价值为「在这一段当中任选某个元素的个数的平方再乘上这个元素」的最大值。求将
<span class="math inline">\(s\)</span> 划分后的最大价值。</p>
<p>不难想到分成的每一段首尾元素必须相等。</p>
<p>比如有这样一个序列 <span
class="math inline">\(x,a_1,a_2,a_3,\cdots,a_k,x,y\)</span>
。假设我们求的是这一段包含 <span class="math inline">\(x\)</span>
的个数的平方，那么完全可以将 <span class="math inline">\(y\)</span>
从这一段中分离，单独为一段，明显更优。</p>
<p>而其他所有情况都是这种情况的拓展。</p>
<p>于是得到式子： <span class="math display">\[
f_i=\max\{f_{j-1}+s_i\times(cnt_i-cnt_j+1)^2\}
\]</span> 其中 <span class="math inline">\(cnt_i\)</span> 为 <span
class="math inline">\(s_i\)</span> 已经出现了多少次。</p>
<p>然后就是套路。 <span class="math display">\[
\begin{aligned}
f_i&amp;=\max\{f_{j-1}+s_i\times({cnt_i}^2+{cnt_j}^2-2\times cnt_i\times
cnt_j+2\times cnt_i-2\times cnt_j+1)\}
\\
&amp;=\max\{f_{j-1}+s_i\times{cnt_i}^2+s_i\times{cnt_j}^2-2\times
s_i\times cnt_i\times cnt_j+2\times s_i\times cnt_i-2\times s_i\times
cnt_j+s_i\}
\\
&amp;=\max\{f_{j-1}+s_i\times {cnt_j}^2-2\times s_i\times cnt_i\times
cnt_j-2\times s_i\times cnt_j\}+s_i\times {cnt_i}^2+2\times s_i\times
cnt_i+s_i
\end{aligned}
\]</span> 这次不是 <span class="math inline">\(\min\)</span>，而是 <span
class="math inline">\(\max\)</span>，我们还能像以前那样推吗？</p>
<p>不急，我们先按以前的方法试试，见机行事。</p>
<p>令 <span class="math inline">\(j\)</span> 优于 <span
class="math inline">\(k\)</span>，则有： <span class="math display">\[
f_{j-1}+s_i\times {cnt_j}^2-2\times s_i\times cnt_i\times cnt_j-2\times
s_i\times cnt_j&gt;f_{k-1}+s_i\times {cnt_k}^2-2\times s_i\times
cnt_i\times cnt_k-2\times s_i\times cnt_k
\]</span> 暴力搞不出来，因为那个 <span
class="math inline">\(s_i\)</span> 乘上的平方项。</p>
<p>那我们想一个办法，把 <span class="math inline">\(s_i\)</span>
给灭掉就行了。</p>
<p>既然我们已知一段的首尾元素必须相等，那不就说明 <span
class="math inline">\(s_i,s_j,s_k\)</span> 可以相互替换吗？</p>
<p>继续搞。 <span class="math display">\[
f_{j-1}+s_j\times {cnt_j}^2-2\times s_i\times cnt_i\times cnt_j-2\times
s_j\times cnt_j&gt;f_{k-1}+s_k\times {cnt_k}^2-2\times s_i\times
cnt_i\times cnt_k-2\times s_k\times cnt_k
\\
f_{j-1}-f_{k-1}+s_j\times {cnt_j}^2-s_k\times {cnt_k}^2-2\times
s_j\times cnt_j+2\times s_k\times cnt_k&gt;2\times s_i\times cnt_i\times
cnt_j-2\times s_i\times cnt_i\times cnt_k
\\
\dfrac{f_{j-1}-f_{k-1}+s_j\times {cnt_j}^2-s_k\times {cnt_k}^2-2\times
s_j\times cnt_j+2\times s_k\times cnt_k}{cnt_j-cnt_k}&gt;2\times
s_i\times cnt_i
\]</span></p>
<p>这里的符号变成 <span class="math inline">\(&gt;\)</span> 了。</p>
<p>易得，这里要维护的是一个斜率单调递减的上凸包最优解序列。</p>
<p>因为 <span class="math inline">\(s_i\)</span> 必须与 <span
class="math inline">\(s_j,s_k\)</span> 相同，明显要针对每个 <span
class="math inline">\(s_i\)</span>
维护不同的最优解序列，在每次对应的序列中计算。</p>
<p>维护的斜率单调递减，而对于每一个相等的 <span
class="math inline">\(s_i\)</span>， <span class="math inline">\(2\times
s_i\times cnt_i\)</span>
一定是单调递增的，导致了这个序列大概长这个样子：斜率单调递减，但末尾的最小的斜率仍大于
<span class="math inline">\(2\times s_i\times cnt_i\)</span>。</p>
<p>单调栈可以自行研究，因为作者瞄了一眼时间发现已经是明天了。（什</p>
<h4 id="code-10">Code</h4>
<pre class="cpp"><code>#include&lt;cstdio&gt;
#include&lt;vector&gt;
using namespace std;
#define int long long
#define top q[x].size() - 1
const int maxn = 1e5 + 5;
const int maxm = 1e4 + 5;
int n;
vector&lt;int&gt; q[maxm]; // 不用 vector 会 MLE
int f[maxn], s[maxn];
int cnt[maxn], tot[maxm];
int getDP(int i,int j)&#123;
    return f[j-1]+(cnt[i]-cnt[j]+1)*(cnt[i]-cnt[j]+1)*s[i];
&#125;
int getup(int j,int k)&#123;
    return f[j-1]-f[k-1]+s[j]*cnt[j]*cnt[j]-s[k]*cnt[k]*cnt[k]-2*s[j]*cnt[j]+2*s[k]*cnt[k];
&#125;
int getdown(int j,int k)&#123;
    return cnt[j]-cnt[k];
&#125;
signed main()&#123;
    scanf(&quot;%lld&quot;,&amp;n);
    for(int i=1;i&lt;=n;++i)&#123;
        scanf(&quot;%lld&quot;,&amp;s[i]);
        cnt[i]=++tot[s[i]];
    &#125;
    for(int i=1;i&lt;=n;++i)&#123;
        int x=s[i];
        while(q[x].size()&gt;=2&amp;&amp;getup(q[x][top-1],i)*getdown(q[x][top-1],q[x][top])&gt;=getup(q[x][top-1],q[x][top])*getdown(q[x][top-1],i))
            q[x].pop_back();
        q[x].push_back(i);
        while(q[x].size()&gt;=2&amp;&amp;getDP(i,q[x][top])&lt;=getDP(i,q[x][top-1]))
            q[x].pop_back();
        f[i]=getDP(i,q[x][top]);
    &#125;
    printf(&quot;%lld&quot;,f[n]);
    return 0;
&#125;</code></pre>
<hr />
<h3 id="总结">总结</h3>
<p>总结斜优的步骤：</p>
<ol type="1">
<li>推 DP 式子</li>
<li>对式子进行巧妙的优化，使其易于化简</li>
<li>假设 <span class="math inline">\(j\)</span> 优于 <span
class="math inline">\(k\)</span>，将式子化成 <span
class="math inline">\(\dfrac{(j)-(k)}{(j)-(k)}&gt; \text{or}
&lt;x\)</span> 的形式</li>
<li>单调队列或单调栈优化</li>
</ol>

			</div>
			<hr class="dotted">
			<div class="post footer">
				<div id="hitokoto">
					<h3 id="hitokoto-title">
						一言 - Hitokoto
					</h3>
					<div id="hitokoto-content">
					</div>
					<div id="hitokoto-from">
					</div>
				</div>
				<div class="button flex">
					<div id="prev">
						
							<!-- 吐槽，为啥还需要加 / -->
							<a href="/20220927/">
								<i class="fas fa-angle-double-left" style="margin-right: 10px;"></i>
								悬线法
							</a>
						
					</div>
					<div id="next">
						
					</div>
				</div>
				<div id="vcomments" class="yahei"></div>
<script>
	new Valine({
		el: '#vcomments',
		appId: 'OlmvQ0a2Zw7xo3no2bwabOzx-gzGzoHsz',
		appKey: 'TW6t8mFeGLmhPjWisvmllvvo',
		recordIP: true,
		enableQQ: true, 
		// 目前 Valine 的 QQ 自动获取昵称似乎不可用 故不建议开启
		pageSize: 10,
		requiredFields:
			
				['nick']
			,
		placeholder: "The world is but a little place after all...\n能够根据邮箱获取你的 Gravatar 头像。昵称是必填项，长度需不低于 3。",
		avatar: 'mp',
		avatar_cdn: 'https://cravatar.cn/avatar/',
		emojiCDN: 'https://xsc062.netlify.app/em/', 
		emojiMaps: {
			
				"微笑": "wx.gif",
			
				"龇牙": "cy.gif",
			
				"流泪": "ll.gif",
			
				"笑哭": "xk.gif",
			
				"流汗": "lh.gif",
			
				"擦汗": "ch.gif",
			
				"亲亲": "qq.gif",
			
				"色": "se.gif",
			
				"疑问": "yiw.gif",
			
				"发呆": "fd.gif",
			
				"晕": "yun.gif",
			
				"鼓掌": "gz.gif",
			
				"憨笑": "hanx.gif",
			
				"快哭了": "kk.gif",
			
				"得意": "dy.gif",
			
				"狂笑": "kx.gif",
			
				"害羞": "hx.gif",
			
				"妈妈生的": "dz.gif",
			
				"糗大了": "qd.gif",
			
				"吃瓜": "cg.gif",
			
				"睁眼": "zy.webp",
			
				"辣眼睛": "lyj.gif",
			
				"酸了": "nm.gif",
			
				"滚": "gun.webp",
			
				"惊恐": "jk.gif",
			
				"幽灵": "youl.gif",
			
				"无聊": "wul.gif",
			
				"吃": "eat.gif",
			
				"你很棒棒": "bb.gif",
			
				"赞": "qiang.gif",
			
				"踩": "ruo.gif",
			
				"握手": "wsh.gif",
			
				"发抖": "fad.gif",
			
				"挥手": "hsh.gif",
			
				"磕头": "kt.gif",
			
				"怄火": "oh.gif",
			
		},
	})
</script>
			</div>
			<script>setHitokoto();</script>
		</div> 
	</div>
</div>
    <!-- 页脚开始 -->
<div id="footer" class="yahei">
    Powered by
    <a target="_blank" rel="noopener" href="https://hexo.io">
        Hexo
    </a>
    &
    <a href="/about-this-theme">
        iwll
    </a>
    <p style="margin-top: 5px;">
        2021 - 2025
    </p>
</div>
<!-- Valine 相关配置 -->
<script>
    const getValineDomTimer = setInterval(() => {
        // 不知道为什么 我从原博客 js 文件粘过来的参数是
        // "#valine .vcards .vcard"
        // DEBUG 了半天才定位到这个问题。。。
        const vcards =
            document.querySelectorAll('#valine, .vcards, .vcard');
        if (vcards.length > 0) {
            let author = 'XSC062';
            for (let vcard of vcards) {
                const vnick_dom = vcard.querySelector('.vhead .vnick');
                if (vnick_dom != null) {
                    const vnick = vnick_dom.innerHTML;
                    if (vnick === author) {
                        vnick_dom.innerHTML =
                        `${vnick} <span id="rootitem" class="fira">root</span>`
                    }
                }
            }
        }
        else {
            clearInterval(getValineDomTimer);
        }
    }, 2000);
    SetActiveItem();
    setDetailsSummary();
    setTitleAnchor();
    setEmptyToc();
    setCodeClassName();
</script>


<!-- js -->
<!-- 搜索功能相关配置 -->

<script src="/js/search.js"></script>

<script type="text/javascript">
var search_path = "search.xml";
if (search_path.length == 0) {
    search_path = "search.xml";
}
var path = "/" + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script>
<!-- prism 相关配置 -->
<script type="text/javascript" src="/js/prism.js" defer></script>
<!-- 代码块复制功能 -->
<script type="text/javascript" src="/js/clipboard.min.js"></script>
<script type="text/javascript" src="/js/clipboard-use.js"></script>
<!-- 页脚结束 -->
</body>
</html>