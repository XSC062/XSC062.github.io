<!DOCTYPE html>
<html>
<head>
    <!-- 网站图标 -->
<link rel="icon" type="image/png" sizes="32x32" href="/images/icon.svg">
<!-- 其他图标支持 -->
<link rel="stylesheet" href="/css/facss/fa-brands.min.css">
<link rel="stylesheet" href="/css/facss/fa-regular.min.css">
<link rel="stylesheet" href="/css/facss/fa-solid.min.css">
<link rel="stylesheet" href="/css/facss/fontawesome.min.css">
<link rel="stylesheet" href="/css/facss/fontawesome-all.css">
<link href="https://use.fontawesome.com/releases/v5.0.4/css/all.css" rel="stylesheet">
<!-- 网站标题 -->
<title>
	
		杂题 -
	
	XSC062 的博客
</title>
<!-- js 引入 -->

<script src="/js/afterloaded.js"></script>


<script src="/js/jQuery.js"></script>

<!-- 载入 Valine -->

<script src="/js/Valine.min.js"></script>

<!-- css 引入 -->

<link rel="stylesheet" href="/css/layout.css">


<link rel="stylesheet" href="/css/prcss/prism.css">



<meta charset="utf-8"> 
<meta name="generator" content="Hexo 7.2.0"></head>
<body class="line-numbers match-braces no-brace-select rainbow-braces">
	
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
          tex2jax: {
            inlineMath: [ ['$','$'], ["\\(","\\)"] ],
            processEscapes: true
          }
        });
      </script>
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
            tex2jax: {
              skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
            }
          });
      </script>
    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
              var all = MathJax.Hub.getAllJax(), i;
              for(i=0; i < all.length; i += 1) {
                  all[i].SourceElement().parentNode.className += ' has-jax';
              }
          });
      </script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.6/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

	<!-- 搜索 -->
<div id="search-bg">
	<div id="search-box">
		<input type="text" id="search-input" placeholder="Type to search...">
		<div id="search-results"></div>
		<p>恭喜你触发了这个 box，由于我还没有写关闭键，你只能通过刷新页面来关闭它。非常抱歉 ;-)</p>
		<p>为了证明我没有摆烂，在这里放一个进度：</p>
		<p>- 250715：尝试实现搜索功能，初步成功，能够搜索到包含关键词的文章了（也能关掉了）。不知道为啥输入 123 可以匹配所有文章，但是输入 1234 就一篇都匹配不上。</p>
		<p>- 250716：尝试加入关键词上下文来 de 上面的 bug，然后把 js 写成史了，现在这个框框并不具备搜索功能（也不具备关闭功能） :-(</p>
	</div>
</div>
<!-- 顶栏整体导航菜单 -->
<div class="ui top menu">
	<!-- 左对齐 logo -->
	<a class="logo" href="/">
		<img src="/images/icon.png"></img>
		<div id="bartitle">
			XSC062 的博客
		</div>
	</a>
	<!-- 右对齐部分导航 -->
	<script>
		function toSearch() {
			// goto search.ejs
			$("#search-bg, #search-bg *").css("z-index", "1002"); 
			$("#search-bg, #search-bg *").css("opacity", "100%");
		}
	</script>
	<div id="rightali">
		<a class="item" id="Search" type="button" onclick="toSearch()">
			<i class="btn text-muted fa fa-search" id="search-icon" disabled></i>
		</a>
		<a class="item" id="Home" href="/">
			Home
		</a>
		<a class="item" id="Arch" href="/archives">
			Archives
		</a>
		<!-- <a class="item" id="Cate" href="/categories">
			Categories
		</a> -->
		<a class="item" id="Tags" href="/tags">
			Tags
		</a>
		<a class="item" id="Frie" href="/friends">
			Friends
		</a>
		<a class="item" id="Abou" href="/about">
			About
		</a>
	</div>
</div>
    
<link rel="stylesheet" href="/css/post.css">


<script src="/js/post.js"></script>


<div class="main">
	<div id="sidebar">
		<aside id="toc">
			<span id="toctitle">
				<i class="fas fa-list"></i>
				目录
			</span>
			<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#a---pass-to-next"><span class="toc-text">A - Pass to Next</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#b---%E7%BB%BF%E5%AE%9D%E7%9F%B3%E4%B9%8B%E5%B2%9B"><span class="toc-text">B - 绿宝石之岛</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#c---uddered-but-not-herd-g"><span class="toc-text">C - Uddered but not Herd G</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#d---min-max-subarrays-p"><span class="toc-text">D - Min Max Subarrays P</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#a---mst-on-line"><span class="toc-text">A - MST on Line++</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#b---existence-counting"><span class="toc-text">B - Existence Counting</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#c---1-loop-bubble-sort"><span class="toc-text">C - 1 Loop Bubble Sort</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#f---1.-intro"><span class="toc-text">(F - 1). Intro</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#f.-distance-to-the-path"><span class="toc-text">F. Distance to the Path</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#a---ina-of-the-mountain"><span class="toc-text">A - Ina of the Mountain</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#b---miriany-and-matchstick"><span class="toc-text">B - Miriany and Matchstick</span></a></li></ol>
		</aside>
	</div>
	<div class="ui post container">
		<div class="ui text container">
			<span id="postcon">
				<span id="postinfo">
					<div class="ui post title">
						<div id="fortitle" data-content="杂题">
							杂题
						</div>
						<div class="ui title background">
						</div>
					</div>
					<span id="date">
						<i class="fas fa-calendar-alt" style="margin-right: 4px;"></i>
						2025-05-10
					</span>
				</span>
			</span>
			<div id="posttags" class="dotted border">
				
					
						<a href="/tags/DP/" class="citem">DP</a>
					
						<a href="/tags/容斥原理/" class="citem">容斥原理</a>
					
						<a href="/tags/树链剖分/" class="citem">树链剖分</a>
					
						<a href="/tags/反悔贪心/" class="citem">反悔贪心</a>
					
				
			</div>
			<!-- 本来用的是 fromNow 然后字符串判断，没想到可以直接调用 moment() -->
			
			<div id="content">
				<p>啊啊。小封条。</p>
<span id="more"></span>
<hr />
<h2 id="a---pass-to-next">A - Pass to Next</h2>
<p><a target="_blank" rel="noopener" href="https://atcoder.jp/contests/arc124/tasks/arc124_e" class="uri">https://atcoder.jp/contests/arc124/tasks/arc124_e</a></p>
<p>感觉其他一些题解讲得不是特别清楚，这里参考了 <a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43960287/article/details/119140590">XJX 的文章</a>。</p>
<p>要求的答案是 <span class="math inline">\(\prod a&#39;_i\)</span>，<mark>发现运算是乘法，比较怪；由此考虑转化为方案数，也就是假设每个人有 <span class="math inline">\(a&#39;_i\)</span> 个互不相同的球，每个人在其中选出恰好一个的方案数</mark>。</p>
<p>考虑 DP。发现每个人手上的球分为『自己的』和『左边的人传过来的』两种类型；<mark>显然第二种会有来自上一个人的限制，考虑把第二种在上一个人就完成求解</mark>。具体地，设 <span class="math inline">\(f_{i,0}\)</span> 表示第 <span class="math inline">\(i\)</span> 个人选取自己的球，但只记录 <span class="math inline">\(1\sim i-1\)</span> 的方案；<span class="math inline">\(f_{i,1}\)</span> 表示第 <span class="math inline">\(i\)</span> 个人选取第 <span class="math inline">\(i-1\)</span> 个人的球，并记入答案的方案。<em>你可能需要注意到：最后一个被记入方案的球来自第 <span class="math inline">\(i-1\)</span> 个人</em>。</p>
<p>但这样会有个小问题。我们让所有人多往右边传一个球，那么在我们的这种分割方法看来是不一样的局面；但实际上它们是等价的。从每个人传出了多少个球（设为 <span class="math inline">\(x_i\)</span>）的角度来看，对于 <span class="math inline">\(\min\{x_n\}\ne 0\)</span>，只需要不断执行 <span class="math inline">\(\forall\, x_i\gets x_i-1\)</span> 就可以在局面不变的情况下使 <span class="math inline">\(\min\{x_n\}\ne 0\)</span>。这是在说，可以让 <span class="math inline">\(\min\{x_n\}\ne 0\)</span> 的方案和终局一一对应。</p>
<p>发现可以容斥：钦定 <span class="math inline">\(x_i\ge 1\)</span>，也就是每个人必须往右传至少一个，相似地算一遍就能得到非法方案。</p>
<p>考虑转移，令 <span class="math inline">\(x_i\)</span> 可选最小值为 <span class="math inline">\(l\)</span>，有：</p>
<ul>
<li><span class="math inline">\(f_{i+1,0}\gets f_{i,0}\)</span>：将第 <span class="math inline">\(i\)</span> 个人未被记入的自己的球记入，球数可能为 <span class="math inline">\([0,a_i-l]\)</span>。等差数列求和即可。</li>
<li><span class="math inline">\(f_{i+1,0}\gets f_{i,1}\)</span>：没有球需要被记入，但是这种情况对应多种 <span class="math inline">\(x_i\)</span>。具体地，<span class="math inline">\(x_i\in [l,a_i]\)</span>。共有 <span class="math inline">\(a_i-l+1\)</span> 种方案。</li>
<li><span class="math inline">\(f_{i+1,1}\gets f_{i,0}\)</span>：将第 <span class="math inline">\(i\)</span> 个人的 <span class="math inline">\(a_i\)</span> 个球分给 <span class="math inline">\(i\)</span> 和 <span class="math inline">\(i+1\)</span>。共有 <span class="math inline">\(x_i\cdot (a_i-x_i)\)</span> 种可能，也就是 <span class="math inline">\(\left(a_i\cdot \sum_{x_i=l}^{a_i} x_i\right)-\left(\sum_{x_i=l}^{a_i}{x_i}^2\right)\)</span> 种方案。</li>
<li><span class="math inline">\(f_{i+1,1}\gets f_{i,1}\)</span>：将第 <span class="math inline">\(i+1\)</span> 个人得到的第 <span class="math inline">\(i\)</span> 个人的球记入，同第一条。</li>
</ul>
<p>破环为链，分别钦定第一个人是用自己的球还是上一个人的球来解决问题（必须对于两种可能性分开计算；否则就不知道答案应该取 <span class="math inline">\(f_{n,0}\)</span> 还是 <span class="math inline">\(f_{n,1}\)</span>）。</p>
<details>
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;
const int mod = 998244353, inv2 = (mod + 1) &gt;&gt; 1, inv6 = 166374059;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n;
    std::cin &gt;&gt; n;
    std::vector&lt;long long&gt; a(n);
    for (int i = 1; i &lt;= n; ++i)
        std::cin &gt;&gt; a[i % n];
    auto sum = [&amp;](long long r) &#123;
        return r * (r + 1) % mod * inv2 % mod;
    &#125;;
    auto sum2 = [&amp;](long long r) &#123;
        return r * (r + 1) % mod * (2 * r % mod + 1) % mod * inv6 % mod;
    &#125;;
    std::vector&lt;std::vector&lt;long long&gt; &gt; f0(n, std::vector&lt;long long&gt; (2)), f1(n, std::vector&lt;long long&gt; (2));
    auto calc = [&amp;](long long l, std::vector&lt;std::vector&lt;long long&gt; &gt; &amp;f) &#123;
        f[0][0] = 1ll;
        for (int i = 0; i &lt; n; ++i) &#123;
            int j = (i + 1) % n;
            f[j][0] = f[i][0] * sum(a[i] - l) % mod;
            (f[j][0] += f[i][1] * (a[i] - l + 1)) %= mod;
            f[j][1] = f[i][0] * (a[i] * sum(a[i]) % mod - sum2(a[i])) % mod;
            (f[j][1] += f[i][1] * sum(a[i]) % mod) %= mod;
            // printf(&quot;0, l = %lld, f[%d]: %lld / %lld\n&quot;, l, j, f[j][0], f[j][1]);
        &#125;
        auto res(f[0][0]);
        f.assign(n, std::vector&lt;long long&gt; (2));
        f[0][1] = 1ll;
        for (int i = 0; i &lt; n; ++i) &#123;
            int j = (i + 1) % n;
            f[j][0] = f[i][0] * sum(a[i] - l) % mod;
            (f[j][0] += f[i][1] * (a[i] - l + 1)) %= mod;
            f[j][1] = f[i][0] * (a[i] * sum(a[i]) % mod - sum2(a[i])) % mod;
            (f[j][1] += f[i][1] * sum(a[i]) % mod) %= mod;
            // printf(&quot;1, l = %lld, f[%d]: %lld / %lld\n&quot;, l, j, f[j][0], f[j][1]);
        &#125;
        return (res + f[0][1]) % mod;
    &#125;;
    std::cout &lt;&lt; (calc(0, f0) + mod - calc(1, f1)) % mod &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;</code></pre>
</details>
<hr />
<h2 id="b---绿宝石之岛">B - 绿宝石之岛</h2>
<p><a target="_blank" rel="noopener" href="https://loj.ac/p/6406" class="uri">https://loj.ac/p/6406</a></p>
<p>因为只关心最终状态，原题可以转化为：将 <span class="math inline">\(d\)</span> 分成 <span class="math inline">\(n\)</span> 个非负整数，前 <span class="math inline">\(r\)</span> 大数之和的期望（当然你需要加上初始的 <span class="math inline">\(r\)</span> 个）。</p>
<p>关于非负整数拆分：设 <span class="math inline">\(f_{i,j}\)</span> 表示将 <span class="math inline">\(i\)</span> 分成 <span class="math inline">\(j\)</span> 个 <strong>非负整数</strong> 的方案，钦定其中恰有 <span class="math inline">\(k\)</span> 个 <strong>正整数</strong> 进行转移，给这 <span class="math inline">\(k\)</span> 个数先分一个 <span class="math inline">\(1\)</span>，则 <span class="math inline">\(f_{i,j}=\sum\limits_{k=0}^{\min(i,j)} C_j^k\cdot f_{i-k,k}\)</span>。</p>
<p>再设 <span class="math inline">\(g_{i,j}\)</span> 表示将 <span class="math inline">\(i\)</span> 分成 <span class="math inline">\(j\)</span> 个非负整数的所有方案中、前 <span class="math inline">\(r\)</span> 大的数之和。类似地，有 <span class="math inline">\(g_{i,j}=\sum\limits_{k=0}^{\min(i,j)} C_j^k\cdot (g_{i-k,k}+\min(k,r)\cdot f_{i-k,k})\)</span>。其中，<span class="math inline">\(\min(k,r)\)</span> 的来源是，只有 <span class="math inline">\(k\)</span> 个数有值，前 <span class="math inline">\(r\)</span> 大的数一定在这 <span class="math inline">\(k\)</span> 个数里面。</p>
<p>答案为 <span class="math inline">\(\dfrac {g_{d,n}}{f_{d,n}}+r\)</span>，复杂度 <span class="math inline">\(O(n^3)\)</span>。</p>
<details>
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n, d, r;
    std::cin &gt;&gt; n &gt;&gt; d &gt;&gt; r;
    using arr = std::vector&lt;double&gt;;
    std::vector&lt;arr&gt; f(d + 1, arr(n + 1)), g(d + 1, arr(n + 1)), C(n + 1, arr(n + 1));
    for (int i = 0; i &lt;= n; ++i) &#123;
        C[i][0] = 1.;
        for (int j = 1; j &lt;= i; ++j)
            C[i][j] = C[i - 1][j - 1] + C[i - 1][j];
    &#125;
    f[0].assign(n + 1, 1.);
    for (int i = 1; i &lt;= d; ++i)
        for (int j = 1; j &lt;= n; ++j) &#123;
            for (int k = 1; k &lt;= i &amp;&amp; k &lt;= j; ++k) &#123;
                f[i][j] += C[j][k] * f[i - k][k];
                g[i][j] += C[j][k] * (g[i - k][k] + std::min(k, r) * f[i - k][k]);
                // printf(&quot;  k = %d, %.0lf + %.0lf\n&quot;, k, C[j][k] * g[i - k][k], std::min(k, r) * f[i - k][k]);
            &#125;
            // printf(&quot;f[%d][%d] = %.0lf, g[%d][%d] = %.0lf\n&quot;, i, j, f[i][j], i, j, g[i][j]);
        &#125;
    std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(8) &lt;&lt; g[d][n] / f[d][n] + r &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;</code></pre>
</details>
<hr />
<h2 id="c---uddered-but-not-herd-g">C - Uddered but not Herd G</h2>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P7296" class="uri">https://www.luogu.com.cn/problem/P7296</a></p>
<p>给每个字母分配一个标号 <span class="math inline">\(x\)</span>，那么最小段数就是 <span class="math inline">\(\sum \left[x_i\ge x_{i+1}\right]\)</span>。</p>
<p>考虑状压完成映射操作，令 <span class="math inline">\(f_{s}\)</span> 表示给标号 <span class="math inline">\(1\sim |s|\)</span> 分配字母后，占用字符集 <span class="math inline">\(s\)</span> 的方案数，那么就能 <span class="math inline">\(O(1)\)</span> 得到贡献——只需预处理出 <span class="math inline">\(f_{c, s}\)</span> 表示分配到字母 <span class="math inline">\(c\)</span> 时，已经先给 <span class="math inline">\(s\)</span> 中字母分配了更小标号时的贡献。</p>
<p>注意字符集大小只有 <span class="math inline">\(20\)</span>，可以 <span class="math inline">\(O(|S|\cdot 2^{|S|})\)</span> 解决问题，<mark>注意到预处理的内容是类高维前缀最值的形式，可以递推降低复杂度</mark>。</p>
<details>
<pre data-line="26-28" class="cpp language-cpp"><code data-line="26-28" class="cpp language-cpp">#include &lt;bits/stdc++.h>
const int inf = 0x3f3f3f3f;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(".in", "r", stdin);
    std::freopen(".out", "w", stdout);
#endif
    int n;
    std::string t;
    std::cin >> t, n = (int)t.length(), t = "#" + t;
    std::vector&lt;int> a, tag(26, -1), s(n + 1);
    for (int i = 1; i &lt;= n; ++i) &#123;
        if (tag[t[i] - 'a'] == -1)
            tag[t[i] - 'a'] = (int)a.size(), a.push_back(t[i] - 'a');
        s[i] = tag[t[i] - 'a'];
    &#125;
    int m = (int)a.size(), siz = 1 &lt;&lt; m;
    std::vector&lt;std::vector&lt;int> > cnt(m, std::vector&lt;int> (m));
    for (int i = 1; i &lt; n; ++i)
        ++cnt[s[i]][s[i + 1]];
    std::vector&lt;std::vector&lt;int> > g(m, std::vector&lt;int> (siz));
    for (int i = 0; i &lt; m; ++i)
        for (int k = 0; k &lt; m; ++k) // 注意这里相当于是钦定从 k 处转移
            for (int j = (1 &lt;&lt; k); j &lt; (2 &lt;&lt; k); ++j) // 枚举的是 k 位为 1 的所有数；这两层循环的复杂度为 O(siz)
                g[i][j] = g[i][j ^ (1 &lt;&lt; k)] + cnt[i][k]; // 目的是此处的内存连续访问优化，把 ^ 看作 - 应该就能理解为什么第二维是连续的
    std::vector&lt;int> f(siz, inf);
    f[0] = 1;
    for (int i = 1; i &lt; siz; ++i)
        for (int j = 0; j &lt; m; ++j)
            if ((i >> j) & 1)
                f[i] = std::min(f[i], f[i ^ (1 &lt;&lt; j)] + g[j][i]);
    std::cout &lt;&lt; f[siz - 1] &lt;&lt; '\n';
    return 0;
&#125;</code></pre>
</details>
<hr />
<h2 id="d---min-max-subarrays-p">D - Min Max Subarrays P</h2>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P11845" class="uri">https://www.luogu.com.cn/problem/P11845</a></p>
<p>先考虑 <span class="math inline">\(01\)</span> 序列的答案：如果序列中存在相邻的 <span class="math inline">\(2\)</span> 个 <span class="math inline">\(1\)</span>，总能保证最后的一个是 <span class="math inline">\(1\)</span>。</p>
<p>如果序列中存在 <span class="math inline">\(\ge 3\)</span> 个 <span class="math inline">\(1\)</span>，可以牺牲其中的一些使得 <span class="math inline">\(2\)</span> 个 <span class="math inline">\(1\)</span> 相邻。</p>
<p>当序列中只有 <span class="math inline">\(2\)</span> 个 <span class="math inline">\(1\)</span> 时，只有因为剩下的 <span class="math inline">\(0\)</span> 不太够，导致我们无法随意『上下其手』时不能将 <span class="math inline">\(2\)</span> 个 <span class="math inline">\(1\)</span> 挪到一起。</p>
<p>令两个 <span class="math inline">\(1\)</span> 为序列最大值与次大值，暴搜处理序列长度较小的情况，剩下的直接用奇偶性判断两个 <span class="math inline">\(1\)</span> 取哪个。</p>
<hr />
<h2 id="a---mst-on-line">A - MST on Line++</h2>
<p><a target="_blank" rel="noopener" href="https://atcoder.jp/contests/arc167/tasks/arc167_c" class="uri">https://atcoder.jp/contests/arc167/tasks/arc167_c</a></p>
<p>相当于把 <span class="math inline">\(a\)</span> 打乱然后处理原问题。考虑每个 <span class="math inline">\(a_i\)</span> 的贡献次数。模拟 Kruskal 连边，从小到大把点 <span class="math inline">\(a_i\)</span> 加入图，<span class="math inline">\(a_i\)</span> 可以向 <span class="math inline">\(a_{[i-K,i+K]}\)</span> 内所有连通块连边。</p>
<p>连通块数量当且仅当 <span class="math inline">\([i-K,i)\)</span> 内最靠右的点和 <span class="math inline">\((i, i+K]\)</span> 内最靠左的点距离 <span class="math inline">\(&gt;K\)</span> 时为 <span class="math inline">\(2\)</span>，其余情况为 <span class="math inline">\(1\)</span>。</p>
<p>但要是从这个角度想这个题就不太好做了。正确的想法应该是<mark>拆分为『若 <span class="math inline">\([i-K,i)\)</span> 中有点，贡献次数 <span class="math inline">\(+1\)</span>』和『若 <span class="math inline">\((i,i+K]\)</span> 中有点 <span class="math inline">\(j\)</span> 满足 <span class="math inline">\([j-K,j)\)</span> 中无点，贡献次数 <span class="math inline">\(+1\)</span>』</mark>。对于第一个问题，贡献次数将前 <span class="math inline">\(i-1\)</span> 大的数分配至少一个到 <span class="math inline">\([i-K,i)\)</span> 中的方案数；对于第二个问题，枚举 <span class="math inline">\(j\)</span>，贡献次数为将前 <span class="math inline">\(i-1\)</span> 大的数分配到 <span class="math inline">\(j\)</span> 和 <span class="math inline">\([1,j-K)\cup (j, n]\)</span> 中的方案数。</p>
<details>
<p>实现的时候千万注意循环变量枚举的是位置还是值！不然你会调得很痛苦。</p>
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;
const int mod = 998244353;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;03-max-01.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n, k;
    std::cin &gt;&gt; n &gt;&gt; k;
    std::vector&lt;int&gt; a(n + 1);
    for (int i = 1; i &lt;= n; ++i)
        std::cin &gt;&gt; a[i];
    std::sort(a.begin() + 1, a.end());
    std::vector&lt;long long&gt; fac(n + 1), inv(n + 1);
    fac[0] = inv[0] = 1ll;
    for (int i = 1; i &lt;= n; ++i)
        fac[i] = fac[i - 1] * i % mod;
    auto qkp = [](long long x, int y) &#123;
        auto res(1ll);
        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)
            if (y &amp; 1)
                (res *= x) %= mod;
        return res;
    &#125;;
    inv[n] = qkp(fac[n], mod - 2);
    for (int i = n - 1; i; --i)
        inv[i] = inv[i + 1] * (i + 1) % mod;
    auto A = [&amp;](int n, int m) &#123;
        if (n &lt; m)
            return 0ll;
        return fac[n] * inv[n - m] % mod;
    &#125;;
    auto C = [&amp;](int n, int m) &#123;
        return A(n, m) * inv[m] % mod;
    &#125;;
    long long res = 0ll;
    for (int i = 2; i &lt;= n; ++i) &#123;
        for (int j = 1; j &lt;= n; ++j)
            (res += a[i] * (fac[n - 1] + mod - A(n - 1 - (j - std::max(1, j - k)), i - 1) * fac[n - i] % mod) % mod) %= mod;
        for (int j = 2; j &lt;= n; ++j)
            (res += a[i] * C(i - 1, i - 2) % mod * C(j - std::max(1, j - k), 1) % mod * A(n - (j - std::max(1, j - k) + 1), i - 2) % mod * fac[n - i] % mod) %= mod;
    &#125;
    std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;</code></pre>
</details>
<hr />
<h2 id="b---existence-counting">B - Existence Counting</h2>
<p><a target="_blank" rel="noopener" href="https://atcoder.jp/contests/arc174/tasks/arc174_e" class="uri">https://atcoder.jp/contests/arc174/tasks/arc174_e</a></p>
<p>发现可以分类讨论。假设 <span class="math inline">\(a&#39;\)</span> 中第一个异于 <span class="math inline">\(a\)</span> 的位置为 <span class="math inline">\(i\)</span>，<span class="math inline">\(x\)</span> 在 <span class="math inline">\(a\)</span> 中位置为 <span class="math inline">\(pos_x\)</span>（不存在则 <span class="math inline">\(pos_x=k+1\)</span>）。令 <span class="math inline">\(f_i\)</span> 为若 <span class="math inline">\(1\sim i-1\)</span> 均相同，<span class="math inline">\(i\)</span> 位置可选的选项数。则 <span class="math inline">\(x\)</span> 出现的次数：</p>
<table>
<colgroup>
<col style="width: 25%" />
<col style="width: 25%" />
<col style="width: 25%" />
<col style="width: 25%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;"></th>
<th style="text-align: center;"><span class="math inline">\(pos_x&lt;i\)</span></th>
<th style="text-align: center;"><span class="math inline">\(pos_x=i\)</span></th>
<th style="text-align: center;"><span class="math inline">\(pos_x&gt;i,i&lt;k\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">\(x\le a_i\)</span></td>
<td style="text-align: center;"><span class="math inline">\(1+f_i\cdot A_{n-i}^{k-i}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(f_i\cdot C_{k-i}^1\cdot A_{n-i-1}^{k-i-1}\)</span></td>
<td style="text-align: center;"><span class="math inline">\((f_i-1)\cdot C_{k-i}^1\cdot A_{n-i-1}^{k-i-1}+A_{n-i}^{k-i}\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math inline">\(x&gt;a_i\)</span></td>
<td style="text-align: center;"><span class="math inline">\(f_i\cdot A_{n-i}^{k-i}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(0\)</span></td>
<td style="text-align: center;"><span class="math inline">\(f_i\cdot C_{k-i}^1\cdot A_{n-i-1}^{k-i-1}\)</span></td>
</tr>
</tbody>
</table>
<p>故，对于任意 <span class="math inline">\(x\)</span>，答案为：</p>
<p><span class="math display">\[
\begin{aligned}
&amp;1+\left(\sum_{i=pos_x+1}^k f_i\cdot A_{n-i}^{k-i}\right)
+\sum_{i=1}^{pos_x} (f_i-[x&lt; a_i])\cdot C_{k-i}^1\cdot A_{n-i-1}^{k-i-1}+[x&lt; a_i]\cdot A_{n-i}^{k-i}\\
=&amp;1+\left(\sum_{i=pos_x+1}^k f_i\cdot A_{n-i}^{k-i}\right)
+\left(\sum_{i=1}^{pos_x} f_i\cdot C_{k-i}^1\cdot A_{n-i-1}^{k-i-1}\right)+\sum_{i=1,a_i&gt; x}^{pos_x}A_{n-i}^{k-i}-C_{k-i}^1\cdot A_{n-i-1}^{k-i-1}\\
\end{aligned}
\]</span></p>
<p>预处理出 <span class="math inline">\(f_i=\sum\limits_{j=i+1}^k [a_j&lt; a_i]\)</span>（需要数据结构）、<span class="math inline">\(g_i=\sum\limits_{j=1}^i f_j\cdot A_{n-j}^{k-j}\)</span> 和 <span class="math inline">\(h_j=\sum\limits_{j=1}^i f_i\cdot C_{k-i}^1\cdot A_{n-i-1}^{k-i-1}\)</span>，再用数据结构计算 <span class="math inline">\(\sum\limits_{i=1,a_i&gt;x}^{pos_x}C_{k-i}^1\cdot A_{n-i-1}^{k-i-1} - A_{n-i}^{k-i}\)</span> 即可。</p>
<details>
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;
const int mod = 998244353;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n, k;
    std::cin &gt;&gt; n &gt;&gt; k;
    std::vector&lt;int&gt; a(k + 1), p(n + 1, k + 1);
    for (int i = 1; i &lt;= k; ++i)
        std::cin &gt;&gt; a[i], p[a[i]] = i;
    std::vector&lt;long long&gt; fac(n + 1), inv(n + 1);
    &#123;
        fac[0] = inv[0] = 1ll;
        for (int i = 1; i &lt;= n; ++i)
            fac[i] = fac[i - 1] * i % mod;
        auto qkp = [](long long x, int y) &#123;
            auto res(1ll);
            for (; y; (x *= x) %= mod, y &gt;&gt;= 1)
                if (y &amp; 1)
                    (res *= x) %= mod;
            return res;
        &#125;;
        inv[n] = qkp(fac[n], mod - 2);
        for (int i = n - 1; i; --i)
            inv[i] = inv[i + 1] * (i + 1) % mod;
    &#125;
    auto A = [&amp;](int n, int m) &#123;
        if (n &lt; m || m &lt; 0)
            return 0ll;
        return fac[n] * inv[n - m] % mod;
    &#125;;
    std::vector&lt;long long&gt; f(k + 1), g(k + 1), h(k + 1);
    std::vector&lt;long long&gt; bit(n + 1);
    auto lowbit = [](int x) &#123;
        return x &amp; -x;
    &#125;;
    auto add = [&amp;](int x, int v) &#123;
        for (; x &lt;= n; x += lowbit(x))
            (bit[x] += v) %= mod;
        return;
    &#125;;
    auto ask = [&amp;](int x) &#123;
        auto res(0ll);
        for (; x; x -= lowbit(x))
            (res += bit[x]) %= mod;
        return res;
    &#125;;
    for (int i = 1; i &lt;= n; ++i)
        if (p[i] == k + 1)
            add(i, 1);
    for (int i = k; i; --i)
        f[i] = ask(a[i]), add(a[i], 1);
    for (int i = 1; i &lt;= k; ++i) &#123;
        g[i] = (g[i - 1] + f[i] * A(n - i, k - i)) % mod;
        h[i] = (h[i - 1] + f[i] * (k - i) % mod * A(n - i - 1, k - i - 1)) % mod;
        // printf(&quot;%d: f = %lld, g = %lld, h = %lld\n&quot;, i, f[i], g[i], h[i]);
    &#125;
    std::vector&lt;long long&gt; res(n + 1);
    bit.assign(n + 1, 0ll);
    auto s(0ll);
    for (int i = 1; i &lt;= k; ++i) &#123;
        // printf(&quot;%d: %lld + %lld + %lld\n&quot;, a[i], 1 + g[k] - g[i], h[i], s - ask(a[i]));
        res[a[i]] = (1 + g[k] - g[i] + h[i] + (s - ask(a[i]))) % mod;
        res[a[i]] = (res[a[i]] + mod) % mod;
        (s += A(n - i, k - i) - (k - i) * A(n - i - 1, k - i - 1)) %= mod;
        add(a[i], (A(n - i, k - i) - (k - i) * A(n - i - 1, k - i - 1)) % mod);
    &#125;
    for (int i = 1; i &lt;= n; ++i)
        if (p[i] == k + 1) &#123;
            res[i] = (h[k] + (s - ask(i))) % mod;
            res[i] = (res[i] + mod) % mod;
        &#125;
    for (int x = 1; x &lt;= n; ++x)
        std::cout &lt;&lt; res[x] &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;</code></pre>
</details>
<hr />
<h2 id="c---1-loop-bubble-sort">C - 1 Loop Bubble Sort</h2>
<p><a target="_blank" rel="noopener" href="https://atcoder.jp/contests/arc187/tasks/arc187_c" class="uri">https://atcoder.jp/contests/arc187/tasks/arc187_c</a></p>
<p>首先是被考烂了的：对序列进行一次冒泡排序，等价于将序列在前缀最大值处分段，并将其从段首移到段尾；且满足排序前为前缀最大值的元素，排序后仍为前缀最大值。</p>
<p>考虑用 DP 解决问题。注意状态要从 <span class="math inline">\(P\)</span> 的角度出发——假如 <span class="math inline">\(Q\)</span> 中不存在 <span class="math inline">\(-1\)</span>，发现也需要 DP。此时再设计有关 <span class="math inline">\(Q\)</span> 的状态就很扯淡了，考虑令 <span class="math inline">\(f_{i,j}\)</span> 表示 <span class="math inline">\(P\)</span> 中直到第 <span class="math inline">\(i\)</span> 位的前缀最大值为 <span class="math inline">\(j\)</span> 的方案数。为什么把前缀最大值作为状态呢？因为它可以表示分段；同时限制段间数的取值。具体地，考虑转移：</p>
<ol type="1">
<li>若令 <span class="math inline">\(P_i=j\)</span>，则在 <span class="math inline">\(i\)</span> 处分段。对应到 <span class="math inline">\(Q\)</span> 中，<span class="math inline">\(i-1\)</span> 位是上一个前缀最大值，那么这要求 <span class="math inline">\(Q_{i-1}&lt;j\)</span>，且 <span class="math inline">\(Q_{i-1}\)</span> 是一个前缀最大值。也即：当 <span class="math inline">\(Q_{i-1}\ne -1\)</span> 时，<span class="math inline">\(f_{i,j}\gets f_{i-1, Q_{i-1}}\)</span>；否则，<span class="math inline">\(f_{i,j}\gets \sum\limits_{k&lt;j} f_{i-1,k}\)</span>。其中，二式都要求转移来源为前缀最大值。</li>
<li>若令 <span class="math inline">\(P_i&lt;j\)</span>，则 <span class="math inline">\(i\)</span> 在 <span class="math inline">\(Q\)</span> 中恰好前移一位，即 <span class="math inline">\(Q_{i-1}=P_i&lt;j\)</span>。则当 <span class="math inline">\(Q_{i-1}\ne -1\)</span> 时，该位确定，<span class="math inline">\(f_{i,j}\gets f_{i-1,j}\)</span>；否则，<span class="math inline">\(Q_{i-1}\)</span> 可选的值为 <span class="math inline">\(&lt;j\)</span> 的所有未选数（定值，可预处理）。</li>
</ol>
<p>关于初值，可以在 <span class="math inline">\(P\)</span> 前加一个 <span class="math inline">\(0\)</span> 作为排列的一部分（那么按照冒泡排序的规则 <span class="math inline">\(Q\)</span> 的第一位也一定是 <span class="math inline">\(0\)</span>）来处理就好了。</p>
<details>
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;
const int mod = 998244353;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n;
    std::cin &gt;&gt; n;
    std::vector&lt;int&gt; q(n + 1), t(n + 1), c(n + 1), pos(n + 1);
    for (int i = 1; i &lt;= n; ++i) &#123;
        std::cin &gt;&gt; q[i], c[i] = c[i - 1];
        if (q[i] == -1)
            ++c[i];
        else
            pos[q[i]] = i;
    &#125;
    for (int i = 1; i &lt; n; ++i) &#123;
        // printf(&quot;t[%d] = %d\n&quot;, i, t[i]);
        if (!pos[i])
            for (int j = i + 1; j &lt;= n; ++j)
                ++t[j];
    &#125;
    std::vector&lt;std::vector&lt;long long&gt; &gt; f(n + 1, std::vector&lt;long long&gt; (n + 1)), s(n + 1, std::vector&lt;long long&gt; (n + 1));
    f[0][0] = 1ll;
    s[0].assign(n + 1, 1ll);
    for (int i = 1; i &lt;= n; ++i)
        for (int j = 1; j &lt;= n; ++j) &#123;
            if (q[i - 1] == -1)
                f[i][j] = (s[i - 1][j - 1] + f[i - 1][j] * std::max(0, 1 + t[j] - c[i - 1])) % mod;
            else if (q[i - 1] &lt; j)
                f[i][j] = (f[i - 1][q[i - 1]] + f[i - 1][j]) % mod;
            s[i][j] = s[i][j - 1];
            if (q[i] == j || !pos[j]) // 满足前缀最大值
                (s[i][j] += f[i][j]) %= mod;
            // printf(&quot;f[%d][%d] = %lld\n&quot;, i, j, f[i][j]);
        &#125;
    std::cout &lt;&lt; f[n][n] &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;</code></pre>
</details>
<hr />
<h2 id="f---1.-intro">(F - 1). Intro</h2>
<blockquote>
<p>给定一个大小为 <span class="math inline">\(n\)</span> 的树，点有点权。给定 <span class="math inline">\(q\)</span> 次操作，分为两种：</p>
<ol type="1">
<li><code>1 x</code>：查询 <span class="math inline">\(x\)</span> 的点权。</li>
<li><code>2 x d v</code> 对于所有距 <span class="math inline">\(x\)</span> 不超过 <span class="math inline">\(d\)</span> 的点，将它们的权值加上 <span class="math inline">\(v\)</span>。</li>
</ol>
<p><span class="math inline">\(n,q\le 10^5,d\le 20\)</span>。</p>
</blockquote>
<p>由于 <span class="math inline">\(d\)</span> 很小，我们可能需要枚举与 <span class="math inline">\(x\)</span> 距离 <span class="math inline">\(0\sim d\)</span> 的点进行修改；那么对距离 <span class="math inline">\(x\)</span> 为 <span class="math inline">\(i\)</span> 的点的更改存储在 <span class="math inline">\(f_{x,i}\)</span>，查询 <span class="math inline">\(v\)</span> 时就可以从 <span class="math inline">\(\sum\limits_i f_{fa(v,i),i}\)</span> 求得答案。</p>
<p>考虑修改。记 <span class="math inline">\(S_{x,d}\)</span> 为距 <span class="math inline">\(x\)</span> 为 <span class="math inline">\(d\)</span> 的点集。<span class="math inline">\(x\)</span> 子树内是好处理的，但子树外的呢？发现 <span class="math inline">\(S_{fa,d-1}\)</span> 中 <span class="math inline">\(x\)</span> 子树外的点，就是 <span class="math inline">\(fa\)</span> 子树下、<span class="math inline">\(x\)</span> 子树外距离 <span class="math inline">\(x\)</span> 为 <span class="math inline">\(d\)</span> 的所有点。</p>
<p>由于所有 <span class="math inline">\(S_{fa(x,i),d-i}\)</span> 无交，这可能满足我们每个待操作点被不重不漏加一次的要求。考虑将所有 <span class="math inline">\(S_{fa(x,i),d-i}\)</span> 标记出来：</p>
<figure>
<img src="1.png" alt="粉色虚线框是待操作点集" /><figcaption>粉色虚线框是待操作点集</figcaption>
</figure>
<p>然后我们可以一眼发现被叉的点和未被叉的待操作点是交错的！这意味着我们只需要再补充上所有 <span class="math inline">\(S_{fa(x,i),d-i-1}\)</span> 即可（显然它们之间、它们和所有 <span class="math inline">\(S_{fa(x,i),d-i}\)</span> 之间都不交）。</p>
<figure>
<img src="2.png" alt="虚线叉为 S_{fa(x,i),d-i-1}" /><figcaption>虚线叉为 <span class="math inline">\(S_{fa(x,i),d-i-1}\)</span></figcaption>
</figure>
<p>此时就可以不重不漏。当然，也会存在一些细节：比如说 <span class="math inline">\(fa(x,i)\)</span> 不存在之类。只需要在根节点 <span class="math inline">\(1\)</span> 处将剩余的 <span class="math inline">\(S_{1,i\to 0}\)</span> 全部更新即可。</p>
<p>故每次修改操作只需要修改 <span class="math inline">\(O(d)\)</span> 坨点。时间复杂度 <span class="math inline">\(O(qd)\)</span>。</p>
<hr />
<h2 id="f.-distance-to-the-path">F. Distance to the Path</h2>
<p><a target="_blank" rel="noopener" href="https://codeforces.com/problemset/problem/1749/F" class="uri">https://codeforces.com/problemset/problem/1749/F</a></p>
<p>本例中将单点修改替换为路径修改；考虑树剖解决问题。</p>
<p>对于路径上的所有点 <span class="math inline">\(u\)</span>，容易发现只需要修改所有的 <span class="math inline">\(S_{u,d}\)</span> 就可以完成对『<strong>一部分路径内侧的点</strong>』的修改。这『一部分』，是因为不包括距离 LCA <span class="math inline">\(\le d\)</span> 的点。</p>
<p>而『<strong>另一部分路径内侧的点</strong>（距 LCA <span class="math inline">\(\le d\)</span>：见上一行说明）』及『<strong>路径外侧的点</strong>（距 LCA <span class="math inline">\(\le d\)</span>：因为路径在 LCA 子树内，LCA 能够到最远的外侧点）』，等价于『<strong>距 LCA <span class="math inline">\(\le d\)</span> 的点</strong>』，只需要把 LCA 代入上例中方式修改即可。</p>
<p>修改路径上所有点 <span class="math inline">\(u\)</span> 的 <span class="math inline">\(S_{u,d}\)</span> 时，可以对所有 <span class="math inline">\(f_{*,i}\)</span> 建立数据结构，由于只需要区间修改、单点查询，使用差分树状数组即可。</p>
<details>
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt; 
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n, m;
    std::cin &gt;&gt; n;
    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);
    for (int i = 1, x, y; i &lt; n; ++i) &#123;
        std::cin &gt;&gt; x &gt;&gt; y;
        g[x].push_back(y), g[y].push_back(x);
    &#125;
    std::vector&lt;int&gt; siz(n + 1), dep(n + 1), fa(n + 1), son(n + 1);
    std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int faa) &#123;
        siz[x] = 1;
        for (auto i : g[x])
            if (i != faa) &#123;
                fa[i] = x, dep[i] = dep[x] + 1;
                DFS(i, x);
                siz[x] += siz[i];
                if (siz[i] &gt; siz[son[x]])
                    son[x] = i;
            &#125;
        return;
    &#125;;
    DFS(1, -1);
    std::vector&lt;int&gt; dfn(n + 1), top(n + 1);
    DFS = [&amp;](int x, int toop) &#123;
        static int now = 0;
        dfn[x] = ++now, top[x] = toop;
        if (son[x])
            DFS(son[x], toop);
        for (auto i : g[x])
            if (i != fa[x] &amp;&amp; i != son[x])
                DFS(i, i);
        return;
    &#125;;
    DFS(1, 1);
    std::vector&lt;std::vector&lt;long long&gt; &gt; bit(21, std::vector&lt;long long&gt; (n + 1));
    auto lowbit = [&amp;](int x) &#123;
        return x &amp; -x;
    &#125;;
    auto add = [&amp;](auto &amp;bit, int x, int v) &#123;
        for (; x &lt;= n; x += lowbit(x))
            bit[x] += v;
        return;
    &#125;;
    auto ask = [&amp;](auto &amp;bit, int x) &#123;
        auto res(0ll);
        for (; x; x -= lowbit(x))
            res += bit[x];
        return res;
    &#125;;
    std::cin &gt;&gt; m;
    for (int op; m--; ) &#123;
        std::cin &gt;&gt; op;
        if (op == 1) &#123;
            int x;
            std::cin &gt;&gt; x;
            auto res(0ll);
            for (int i = 0; i &lt;= 20 &amp;&amp; x; ++i, x = fa[x])
                res += ask(bit[i], dfn[x]);
            std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
        &#125;
        else &#123;
            int x, y, v, d;
            std::cin &gt;&gt; x &gt;&gt; y &gt;&gt; v &gt;&gt; d;
            for (; top[x] != top[y]; x = fa[top[x]]) &#123;
                if (dep[top[x]] &lt; dep[top[y]])
                    std::swap(x, y);
                add(bit[d], dfn[top[x]], v);
                add(bit[d], dfn[x] + 1, -v);
            &#125;
            if (dep[x] &gt; dep[y])
                std::swap(x, y);
            add(bit[d], dfn[x] + 1, v), add(bit[d], dfn[y] + 1, -v);
            for (x = x, y = d; ~y &amp;&amp; x; x = fa[x], --y) &#123;
                add(bit[y], dfn[x], v), add(bit[y], dfn[x] + 1, -v);
                if (y &amp;&amp; fa[x])
                    add(bit[y - 1], dfn[x], v), add(bit[y - 1], dfn[x] + 1, -v);
            &#125;
            if (x == 0)
                for (; ~y; --y)
                    add(bit[y], dfn[1], v), add(bit[y], dfn[1] + 1, -v);
        &#125;
    &#125;
    return 0;
&#125;</code></pre>
</details>
<hr />
<h2 id="a---ina-of-the-mountain">A - Ina of the Mountain</h2>
<p><a target="_blank" rel="noopener" href="https://codeforces.com/problemset/problem/1852/C" class="uri">https://codeforces.com/problemset/problem/1852/C</a></p>
<p>考虑这么一个简化版的问题：</p>
<blockquote>
<p>给定 <span class="math inline">\(\{a_n\}\)</span>，每次可以进行区间 <span class="math inline">\(-1\)</span>，问操作多少次才能将所有元素变为 <span class="math inline">\(0\)</span>。</p>
</blockquote>
<p>会想到差分；对原数组进行差分，一次操作相当于令 <span class="math inline">\(d_l\gets d_l-1\)</span> 而 <span class="math inline">\(d_{r+1}\gets d_{r+1}+1\)</span>，最后要让 <span class="math inline">\(\forall \,d_i=0\)</span>。那么答案就是差分数组中正数之和嘛。</p>
<p>回到原问题。原问题等价于把上述问题变为：</p>
<blockquote>
<p>给定 <span class="math inline">\(\{a_n\}\)</span>，每次可以进行区间 <span class="math inline">\(-1\)</span>，每个数的总操作次数对 <span class="math inline">\(k\)</span> 取模，问操作多少次才能将所有元素变为 <span class="math inline">\(0\)</span>。</p>
</blockquote>
<p>怎么套回到刚刚的问题上呢？还原被取模掉的操作即可。具体来说，提前在 <span class="math inline">\(d\)</span> 上进行若干次操作（记为操作 1），形如令 <span class="math inline">\(d_i\gets d_i+k\)</span>，同时 <span class="math inline">\(d_{i+1}\gets d_{i+1}-k\)</span>。</p>
<p>会发现相邻的操作 <span class="math inline">\(1\)</span> 对一个数加加减减影响判断；发现可以合并一段连续的操作 1，表现在 <span class="math inline">\(a\)</span> 上也就是区间 <span class="math inline">\(+k\)</span>。此时可以发现，一个位置上只会剩下若干次 <span class="math inline">\(+k\)</span> 或若干次 <span class="math inline">\(-k\)</span> （否则可以把 <span class="math inline">\(+k\)</span> 和 <span class="math inline">\(-k\)</span> 代表的不同操作合并），就不会有互相影响一说了。这也是有的题解说可以提前在 <span class="math inline">\(a\)</span> 上区间 <span class="math inline">\(+k\)</span> 的原因。</p>
<p>此时问题变为在 <span class="math inline">\(d\)</span> 进行任意次前加 <span class="math inline">\(k\)</span> 后减 <span class="math inline">\(k\)</span> 的操作，使得 <span class="math inline">\(\sum\limits_{d_i&gt;0}d_i\)</span> 最大化。那么显然如果要使代价更小，只可能在原本 <span class="math inline">\(&lt;0\)</span> 的位置做加法、<span class="math inline">\(&gt;0\)</span> 的位置做减法（其他情况会发现一定不优）。考虑两个数 <span class="math inline">\(d_l,d_r\)</span>，可以感受到对于一个 <span class="math inline">\(r\)</span>，选最小的 <span class="math inline">\(d_l\)</span> 是最优的，但什么时候应该选呢？</p>
<ul>
<li><span class="math inline">\(d_l\le -k,d_r\ge k\)</span>：当然可选，<span class="math inline">\(k\)</span> 被完全利用，答案减少 <span class="math inline">\(k\)</span>。</li>
<li><p><span class="math inline">\(d_l&gt;-k,d_r\ge k\)</span>：此时 <span class="math inline">\(k\)</span> 未被完全利用，但必须选：选择其他更大的数，<span class="math inline">\(k\)</span> 的利用率只会更低；如果不选，答案也无法减少。</p>
<p>Q：此时是否需要尝试找到一个 <span class="math inline">\(l&#39;&lt;l\)</span> 与 <span class="math inline">\(l\)</span> 做操作，使得 <span class="math inline">\(l\)</span> 重新变为负数呢？</p>
A：否。因为你可以将这两次操作合并，发现相当于是直接对 <span class="math inline">\((l&#39;,r)\)</span> 做操作，是更劣的。</li>
<li><span class="math inline">\(d_l\le -k,d_r&lt;k\)</span>：此时 <span class="math inline">\(k\)</span> 未被完全利用，<span class="math inline">\(d_r\)</span> 成为负数。这意味着 <span class="math inline">\(d_r\)</span> 将会成为某个 <span class="math inline">\(r&#39;\)</span> 的可选项。考察 <span class="math inline">\(d_{r&#39;}\)</span> 可用的最小值。如果 <span class="math inline">\(d_r\)</span> 在当前不应该作为右端点，它就一定会被 <span class="math inline">\(d_{r&#39;}\)</span> 选择。具体的有点抽象，但是你可以理解为 <span class="math inline">\(d_r\)</span> 选了 <span class="math inline">\(d_l\)</span> 的贡献是被整合到 <span class="math inline">\(d_r\)</span> 里的；如果 <span class="math inline">\(d_r\)</span> 被选了就说明 <span class="math inline">\(d_{r&#39;}\)</span> 选 <span class="math inline">\(d_l\)</span> 会拥有更大的优势。</li>
<li><p><span class="math inline">\(d_l&gt;-k,d_r&lt;k\)</span>：和上面的情况相似；但这种情况下答案可能反而变得更大，因为没有后效性，所以至少要保证单步最优。此时不能选。</p>
<p>说到单步最优，就会发现这里就是反悔贪心；单步最优一定是全局最优，但更靠前的局部最优可能被否定掉。而『否定』的方法表现为一次操作。</p></li>
</ul>
<p>综上，从前往后扫，优先队列实时维护负数最小值，对于每个正数，check 选最小值是否优于当前答案，有就选。如果正数被减为负，加入队列。</p>
<details>
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int T;
    for (std::cin &gt;&gt; T; T--; ) &#123;
        int n, k;
        std::cin &gt;&gt; n &gt;&gt; k;
        std::vector&lt;int&gt; a(n + 1), d(n + 1);
        long long res(0ll);
        for (int i = 1; i &lt;= n; ++i) &#123;
            std::cin &gt;&gt; a[i], a[i] %= k;
            d[i] = a[i] - a[i - 1];
            if (d[i] &gt; 0)
                (res += d[i]);
        &#125;
        std::priority_queue&lt;int&gt; q;
        for (int i = 1; i &lt;= n; ++i)
            if (d[i] &lt; 0)
                q.push(-d[i]);
            else &#123;
                for (; !q.empty() &amp;&amp; d[i] &gt; 0; ) &#123;
                    int x = -q.top(), y = d[i];
                    auto t(res - y);
                    x += k, y -= k;
                    if (x &gt; 0)
                        t += x;
                    if (y &gt; 0)
                        t += y;
                    if (t &gt;= res)
                        break;
                    q.pop();
                    res = t, d[i] = y;
                    if (d[i] &lt; 0)
                        q.push(-d[i]);
                &#125;
            &#125;
        std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
    &#125;
    return 0;
&#125;</code></pre>
</details>
<hr />
<h2 id="b---miriany-and-matchstick">B - Miriany and Matchstick</h2>
<p><a target="_blank" rel="noopener" href="https://codeforces.com/problemset/problem/1852/D" class="uri">https://codeforces.com/problemset/problem/1852/D</a></p>
<p>从构造的角度出发，看到『恰好为 <span class="math inline">\(k\)</span>』，会想到找到上界和下界并证明中间每一个数都能取到。</p>
<p>但似乎很容易证伪：例如对于 <code>AAAA</code>，下界为 <span class="math inline">\(0\)</span>，上界为 <span class="math inline">\(4\)</span>，但有且仅有 <span class="math inline">\(1\)</span> 取不到。但该想法并未破产——可以感受到这样的位置很少。进一步地，你 <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/article/2mmg5rjd">可以证明只有一个这样的位置</a>，也可以 <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/article/679cwjgl">大胆猜想这样的位置一定出现在 <span class="math inline">\(l+1\)</span>，<span class="math inline">\(r-1\)</span></a>。总之现在我们的状态就减少了（或者说状态变成 DP 值了）。预处理出这个东西之后大力搜索找方案即可。</p>
<details>
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int T;
    for (std::cin &gt;&gt; T; T--; ) &#123;
        int n, k;
        std::cin &gt;&gt; n &gt;&gt; k;
        std::vector&lt;int&gt; a(n + 1);
        for (int i = 1; i &lt;= n; ++i) &#123;
            char t;
            std::cin &gt;&gt; t, a[i] = (t == &#39;A&#39;);
            if (i &gt;= 2)
                k -= (a[i] ^ a[i - 1]);
        &#125;
        std::vector&lt;std::array&lt;std::tuple&lt;int, int, int&gt;, 2&gt; &gt; f(n + 1);
        f[n][0] = &#123; a[n], a[n], 0 &#125;, f[n][1] = &#123; !a[n], !a[n], 0 &#125;;
        auto merge = [&amp;](int i, int l0, int r0, int p0, int l1, int r1, int p1) &#123;
            if (l0 &gt; l1)
                std::swap(l0, l1), std::swap(r0, r1), std::swap(p0, p1);
            int l = l0, r = std::max(r0, r1), p = 0;
            if (!p0 &amp;&amp; !p1) &#123;
                if (r0 &lt; l1 - 1)
                    assert(r0 == l1 - 2), p = r0 + 1;
                else;
            &#125;
            else if (p0 &amp;&amp; p1) &#123;
                if (p0 == p1)
                    p = p0;
                else &#123;
                    int tag0 = (l1 &lt;= p0 &amp;&amp; p0 &lt;= r1), tag1 = (l0 &lt;= p1 &amp;&amp; p1 &lt;= r0);
                    if (!tag0 &amp;&amp; !tag1);
                    else if (!tag0)
                        p = p0;
                    else if (!tag1)
                        p = p1;
                    else;
                &#125;
            &#125;
            else if (p0) &#123;
                if (l1 &lt;= p0 &amp;&amp; p0 &lt;= r1);
                else
                    p = p0;
            &#125;
            else &#123;
                if (l0 &lt;= p1 &amp;&amp; p1 &lt;= r0);
                else
                    p = p1;
            &#125;
            assert(p != l &amp;&amp; p != r &amp;&amp; l &lt;= r);
            return std::make_tuple(l, r, p);
        &#125;;
        for (int i = n - 1; i; --i) &#123;
            &#123;
                auto [l0, r0, p0] = f[i + 1][0];
                auto [l1, r1, p1] = f[i + 1][1];
                if (a[i]) &#123;
                    ++l0, ++r0, ++l1, ++r1;
                    if (p0) ++p0;
                    if (p1) ++p1;
                &#125;
                ++l1, ++r1;
                if (p1) ++p1;
                f[i][0] = merge(i, l0, r0, p0, l1, r1, p1);
            &#125;
            &#123;
                auto [l0, r0, p0] = f[i + 1][0];
                auto [l1, r1, p1] = f[i + 1][1];
                if (!a[i]) &#123;
                    ++l0, ++r0, ++l1, ++r1;
                    if (p0) ++p0;
                    if (p1) ++p1;
                &#125;
                ++l0, ++r0;
                if (p0) ++p0;
                f[i][1] = merge(i, l0, r0, p0, l1, r1, p1);
            &#125;
        &#125;
        std::vector&lt;int&gt; res(n + 1);
        std::function&lt;bool(int, int, int)&gt; DFS = [&amp;](int x, int cnt, int la) &#123;
            if (x == n + 1)
                return cnt == k;
            auto [l0, r0, p0] = f[x][0];
            auto [l1, r1, p1] = f[x][1];
            if (cnt + (la == 1) + l0 &lt;= k &amp;&amp; cnt + (la == 1) + r0 &gt;= k &amp;&amp; (!p0 || cnt + (la == 1) + p0 != k) &amp;&amp; DFS(x + 1, cnt + (la == 1) + a[x], 0))
                res[x] = 0;
            else if (cnt + !la + l1 &lt;= k &amp;&amp; cnt + !la + r1 &gt;= k &amp;&amp; (!p1 || cnt + !la + p1 != k) &amp;&amp; DFS(x + 1, cnt + !la + !a[x], 1))
                res[x] = 1;
            else
                return false;
            return true;
        &#125;;
        if (DFS(1, 0, -1)) &#123;
            std::cout &lt;&lt; &quot;YES\n&quot;;
            for (int i = 1; i &lt;= n; ++i)
                std::cout &lt;&lt; (res[i] ? &#39;A&#39; : &#39;B&#39;);
            std::cout &lt;&lt; &#39;\n&#39;;
        &#125;
        else
            std::cout &lt;&lt; &quot;NO\n&quot;;
    &#125;
    return 0;
&#125;</code></pre>
</details>

			</div>
			<hr class="dotted">
			<div class="post footer">
				<div id="hitokoto">
					<h3 id="hitokoto-title">
						言论
					</h3>
					<div id="hitokoto-content">
					</div>
					<div id="hitokoto-from">
					</div>
				</div>
				<div class="button flex">
					<div id="prev">
						
							<!-- 吐槽，为啥还需要加 / -->
							<a href="/20250518/">
								<i class="fas fa-angle-double-left" style="margin-right: 10px;"></i>
								构造类问题的很少解题方法
							</a>
						
					</div>
					<div id="next">
						
							<a href="/20250505/">
								解题报告 喝醉的兔子
								<i class="fas fa-angle-double-right" style="margin-left: 10px;"></i>
							</a>
						
					</div>
				</div>
				<div id="vcomments" class="yahei"></div>
<script>
	new Valine({
		el: '#vcomments',
		appId: 'OlmvQ0a2Zw7xo3no2bwabOzx-gzGzoHsz',
		appKey: 'TW6t8mFeGLmhPjWisvmllvvo',
		recordIP: true,
		enableQQ: true, 
		// 目前 Valine 的 QQ 自动获取昵称似乎不可用 故不建议开启
		pageSize: 10,
		requiredFields:
			
				['nick']
			,
		placeholder: "The world is but a little place after all...\n能够根据邮箱获取你的 Gravatar 头像。昵称是必填项，长度需不低于 3。",
		avatar: 'mp',
		avatar_cdn: 'https://cravatar.cn/avatar/',
		emojiCDN: 'https://xsc062.netlify.app/em/', 
		emojiMaps: {
			
				"微笑": "wx.gif",
			
				"龇牙": "cy.gif",
			
				"流泪": "ll.gif",
			
				"笑哭": "xk.gif",
			
				"流汗": "lh.gif",
			
				"擦汗": "ch.gif",
			
				"亲亲": "qq.gif",
			
				"色": "se.gif",
			
				"疑问": "yiw.gif",
			
				"发呆": "fd.gif",
			
				"晕": "yun.gif",
			
				"鼓掌": "gz.gif",
			
				"憨笑": "hanx.gif",
			
				"快哭了": "kk.gif",
			
				"得意": "dy.gif",
			
				"狂笑": "kx.gif",
			
				"害羞": "hx.gif",
			
				"妈妈生的": "dz.gif",
			
				"糗大了": "qd.gif",
			
				"吃瓜": "cg.gif",
			
				"睁眼": "zy.webp",
			
				"辣眼睛": "lyj.gif",
			
				"酸了": "nm.gif",
			
				"滚": "gun.webp",
			
				"惊恐": "jk.gif",
			
				"幽灵": "youl.gif",
			
				"无聊": "wul.gif",
			
				"吃": "eat.gif",
			
				"你很棒棒": "bb.gif",
			
				"赞": "qiang.gif",
			
				"踩": "ruo.gif",
			
				"握手": "wsh.gif",
			
				"发抖": "fad.gif",
			
				"挥手": "hsh.gif",
			
				"磕头": "kt.gif",
			
				"怄火": "oh.gif",
			
		},
	})
</script>
			</div>
			<script>setHitokoto();</script>
		</div> 
	</div>
</div>
    <!-- 页脚开始 -->
<div id="footer" class="yahei">
    Powered by
    <a target="_blank" rel="noopener" href="https://hexo.io">
        Hexo
    </a>
    &
    <a href="/about-this-theme">
        iwll
    </a>
    <p style="margin-top: 5px;">
        2021 - 2025
    </p>
</div>
<!-- Valine 相关配置 -->
<script>
    const getValineDomTimer = setInterval(() => {
        // 不知道为什么 我从原博客 js 文件粘过来的参数是
        // "#valine .vcards .vcard"
        // DEBUG 了半天才定位到这个问题。。。
        const vcards =
            document.querySelectorAll('#valine, .vcards, .vcard');
        if (vcards.length > 0) {
            let author = 'XSC062';
            for (let vcard of vcards) {
                const vnick_dom = vcard.querySelector('.vhead .vnick');
                if (vnick_dom != null) {
                    const vnick = vnick_dom.innerHTML;
                    if (vnick === author) {
                        vnick_dom.innerHTML =
                        `${vnick} <span id="rootitem" class="fira">root</span>`
                    }
                }
            }
        }
        else {
            clearInterval(getValineDomTimer);
        }
    }, 2000);
    SetActiveItem();
    setDetailsSummary();
    setTitleAnchor();
    setEmptyToc();
    setCodeClassName();
</script>


<!-- js -->
<!-- 搜索功能相关配置 -->

<script src="/js/search.js"></script>

</script>
<!-- prism 相关配置 -->
<script type="text/javascript" src="/js/prism.js" defer></script>
<!-- 代码块复制功能 -->
<script type="text/javascript" src="/js/clipboard.min.js"></script>
<script type="text/javascript" src="/js/clipboard-use.js"></script>
<!-- 页脚结束 -->
</body>
</html>