<!DOCTYPE html>
<html>
<head>
    <!-- 网站图标 -->
<link rel="icon" type="image/png" sizes="32x32" href="/images/icon.svg">
<!-- 其他图标支持 -->
<link rel="stylesheet" href="/css/facss/fa-brands.min.css">
<link rel="stylesheet" href="/css/facss/fa-regular.min.css">
<link rel="stylesheet" href="/css/facss/fa-solid.min.css">
<link rel="stylesheet" href="/css/facss/fontawesome.min.css">
<link rel="stylesheet" href="/css/facss/fontawesome-all.css">
<link href="https://use.fontawesome.com/releases/v5.0.4/css/all.css" rel="stylesheet">
<!-- 网站标题 -->
<title>
	
		图论思维题 -
	
	XSC062 的博客
</title>
<!-- js 引入 -->
<script>
const searchPath = "/search.xml"
</script>

<script src="/js/afterloaded.js"></script>


<script src="/js/jQuery.js"></script>

<!-- 载入 Valine -->

<script src="/js/Valine.min.js"></script>

<!-- css 引入 -->

<link rel="stylesheet" href="/css/layout.css">


<link rel="stylesheet" href="/css/prcss/prism.css">



<!-- rss -->
<link rel="alternate" type="application/rss+xml" title="" href="https://xsc062.netlify.app/rss.xml" />
<link rel="alternate" type="application/atom+xml" title="" href="https://xsc062.netlify.app/atom.xml" />
<link rel="alternate" type="application/json" title="" href="https://xsc062.netlify.app/feed.json" />

<meta charset="utf-8"> 
<meta name="generator" content="Hexo 7.2.0"></head>
<body class="line-numbers match-braces no-brace-select rainbow-braces">
	
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
          tex2jax: {
            inlineMath: [ ['$','$'], ["\\(","\\)"] ],
            processEscapes: true
          }
        });
      </script>
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
            tex2jax: {
              skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
            }
          });
      </script>
    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
              var all = MathJax.Hub.getAllJax(), i;
              for(i=0; i < all.length; i += 1) {
                  all[i].SourceElement().parentNode.className += ' has-jax';
              }
          });
      </script>
    <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS_CHTML"></script>

	<!-- 搜索 -->
<div id="search-bg">
	<div id="search-box">
		<input type="text" id="search-input" placeholder="Type to search...">
		<div id="search-results"><div id="emptyInput">键入以搜索…</div></div>
	</div>
</div>
<!-- 顶栏整体导航菜单 -->
<div class="ui top menu">
	<!-- 左对齐 logo -->
	<a class="logo" href="/">
		<img src="/images/icon.png"></img>
		<div id="bartitle" class="text">
			XSC062 的博客
		</div>
	</a>
	<!-- 右对齐部分导航 -->
	<div id="rightali" class="serif">
		<a class="item" id="Search" type="button">
			<i class="btn text-muted fa fa-search" id="search-icon" disabled></i>
		</a>
		<a class="item" id="Home" href="/">
			Home
		</a>
		<a class="item" id="Arch" href="/archives">
			Archives
		</a>
		<!-- <a class="item" id="Cate" href="/categories">
			Categories
		</a> -->
		<a class="item" id="Tags" href="/tags">
			Tags
		</a>
		<a class="item" id="Frie" href="/friends">
			Friends
		</a>
		<a class="item" id="Abou" href="/about">
			About
		</a>
	</div>
</div>
    
<link rel="stylesheet" href="/css/post.css">


<script src="/js/post.js"></script>


<div class="main">
	<div id="sidebar" class="text">
		<aside id="toc">
			<span id="toctitle">
				<i class="fas fa-list"></i>
				目录
			</span>
			<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#a---train-splitting"><span class="toc-text">A - Train Splitting</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#b---graph-partition"><span class="toc-text">B - Graph Partition</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#c---strange-housing"><span class="toc-text">C - Strange Housing</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#d---defender-of-childhood-dreams"><span class="toc-text">D - Defender of Childhood Dreams</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#e---edge-split"><span class="toc-text">E - Edge Split</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#f---fair-share"><span class="toc-text">F - Fair Share</span></a></li></ol>
		</aside>
	</div>
	<div class="ui post container">
		<div class="ui text container">
			<span id="postcon">
				<span id="postinfo">
					<div class="ui post title serif">
						<div id="fortitle" data-content="图论思维题">
							图论思维题
						</div>
						<div class="ui title background">
						</div>
					</div>
					<span id="date">
						<i class="fas fa-calendar-alt" style="margin-right: 4px;"></i>
						2025-10-23
					</span>
				</span>
			</span>
			<div id="posttags" class="dotted border">
				
					
						<a href="/tags/思维/" class="citem">思维</a>
					
				
			</div>
			<!-- 本来用的是 fromNow 然后字符串判断，没想到可以直接调用 moment() -->
			
			<div id="content">
				<p>人类智慧题</p>
<span id="more"></span>
<hr />
<h2 id="a---train-splitting">A - Train Splitting</h2>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/CF1776F" class="uri">https://www.luogu.com.cn/problem/CF1776F</a></p>
<ul>
<li>神秘构造题，猜 <span class="math inline">\(k=2\)</span> 一定能构造</li>
<li>考虑直接从图上抠一个点下来，与之相关的边全部染成 1，剩下的染成 2</li>
<li>发现如果恰好选中了菊花的根就不行；需要找到一个度数不为 <span class="math inline">\(n-1\)</span> 的点。那完全图怎么办呢，从根上抠一条当颜色 3 即可。</li>
</ul>
<details>
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int T;
    for (std::cin &gt;&gt; T; T--; ) &#123;
        int n, m;
        std::cin &gt;&gt; n &gt;&gt; m;
        std::vector&lt;int&gt; deg(n + 1);
        std::vector&lt;std::pair&lt;int, int&gt; &gt; e(m + 1);
        int pos = -1;
        for (int i = 1; i &lt;= m; ++i) &#123;
            std::cin &gt;&gt; e[i].first &gt;&gt; e[i].second;
            ++deg[e[i].first], ++deg[e[i].second];
        &#125;
        for (int i = 1; i &lt;= n; ++i)
            if (deg[i] != n - 1) &#123;
                pos = i;
                break;
            &#125;
        if (pos != -1) &#123;
            std::cout &lt;&lt; 2 &lt;&lt; &#39;\n&#39;;
            for (int i = 1; i &lt;= m; ++i)
                if (e[i].first == pos || e[i].second == pos)
                    std::cout &lt;&lt; 1 &lt;&lt; &#39; &#39;;
                else
                    std::cout &lt;&lt; 2 &lt;&lt; &#39; &#39;;
            std::cout &lt;&lt; &#39;\n&#39;;
        &#125;
        else &#123;
            std::cout &lt;&lt; 3 &lt;&lt; &#39;\n&#39;;
            pos = 1;
            bool flag = true;
            for (int i = 1; i &lt;= m; ++i)
                if (e[i].first == pos || e[i].second == pos) &#123;
                    if (flag)
                        std::cout &lt;&lt; 3 &lt;&lt; &#39; &#39;, flag = false;
                    else
                        std::cout &lt;&lt; 1 &lt;&lt; &#39; &#39;;
                &#125;
                else
                    std::cout &lt;&lt; 2 &lt;&lt; &#39; &#39;;
        &#125;
    &#125;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;</code></pre>
</details>
<hr />
<h2 id="b---graph-partition">B - Graph Partition</h2>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/AT_agc039_b" class="uri">https://www.luogu.com.cn/problem/AT_agc039_b</a></p>
<ul>
<li>考虑二分图染色什么时候不行，即有奇环时</li>
<li>考虑有多少种颜色时能染奇环，发现都不行，故二分图染色即可判定。</li>
<li><p>真的只有绿吗？观察样例，猜测答案为图的直径。考虑构造：</p>
<p>枚举每个点并钦定其为唯一一个 <span class="math inline">\(1\)</span>，然后依次向下染色。显然最后构造出来的是合法的。最大为直径长度 + 1。</p>
<p>也可以从差分约束的角度理解，但无甚必要。</p></li>
</ul>
<details>
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n;
    std::cin &gt;&gt; n;
    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1), g1(n + 1, std::vector&lt;int&gt; (n + 1, 0x3f3f3f3f));
    for (int i = 1; i &lt;= n; ++i) &#123;
        g1[i][i] = 0;
        for (int j = 1; j &lt;= n; ++j) &#123;
            char t;
            std::cin &gt;&gt; t;
            if (t == &#39;1&#39;)
                g[i].push_back(j), g1[i][j] = 1;
        &#125;
    &#125;
    std::vector&lt;int&gt; col(n + 1);
    std::function&lt;bool(int, int)&gt; DFS = [&amp;](int x, int now) &#123;
        col[x] = now;
        for (auto i : g[x])
            if (!col[i]) &#123;
                if (!DFS(i, 3 - now))
                    return false;
            &#125;
            else if (col[i] == now)
                return false;
        return true;
    &#125;;
    if (!DFS(1, 1))
        std::cout &lt;&lt; -1 &lt;&lt; &#39;\n&#39;;
    else &#123;
        for (int k = 1; k &lt;= n; ++k)
            for (int i = 1; i &lt;= n; ++i)
                for (int j = 1; j &lt;= n; ++j)
                    g1[i][j] = std::min(g1[i][j], g1[i][k] + g1[k][j]);
        int mx = 0;
        for (int i = 1; i &lt;= n; ++i)
            for (int j = 1; j &lt;= n; ++j)
                mx = std::max(mx, g1[i][j] + 1);
        std::cout &lt;&lt; mx &lt;&lt; &#39;\n&#39;;
    &#125;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;</code></pre>
</details>
<hr />
<h2 id="c---strange-housing">C - Strange Housing</h2>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/CF1470D" class="uri">https://www.luogu.com.cn/problem/CF1470D</a></p>
<ul>
<li>第一反应是随便找一个生成树然后二分图染色，但是发现有当且仅当奇环时行为不太正确</li>
<li>考虑打个补丁，抛弃二分图染色的想法，不断尝试染成黑色，如果染了下一个点会出现黑黑边，那就不染它，对得比较显然。</li>
<li>当且仅当不连通时无解。</li>
</ul>
<details>
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int T;
    for (std::cin &gt;&gt; T; T--; ) &#123;
        int n, m;
        std::cin &gt;&gt; n &gt;&gt; m;
        std::vector&lt;int&gt; f(n + 1);
        std::iota(f.begin() + 1, f.end(), 1);
        std::function&lt;int(int)&gt; find = [&amp;](int x) &#123;
            return x == f[x] ? x : f[x] = find(f[x]);
        &#125;;
        std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1), g1(n + 1);
        int cnt = 0;
        for (int x, y; m--; ) &#123;
            std::cin &gt;&gt; x &gt;&gt; y;
            g1[x].push_back(y), g1[y].push_back(x);
            if (find(x) != find(y)) &#123;
                f[find(x)] = find(y);
                ++cnt, g[x].push_back(y), g[y].push_back(x);
            &#125;
        &#125;
        if (cnt != n - 1) &#123;
            std::cout &lt;&lt; &quot;NO\n&quot;;
            continue;
        &#125;
        std::vector&lt;int&gt; col(n + 1);
        std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int fa) &#123;
            for (auto i : g[x])
                if (i != fa) &#123;
                    bool flag = true;
                    for (auto j : g1[i])
                        if (col[j] == 2) &#123;
                            flag = false;
                            break;
                        &#125;
                    if (flag)
                        col[i] = 2;
                    else
                        col[i] = 1;
                    DFS(i, x);
                &#125;
            return;
        &#125;;
        col[1] = 2, DFS(1, -1);
        std::vector&lt;int&gt; res;
        for (int i = 1; i &lt;= n; ++i)
            if (col[i] == 2)
                res.push_back(i);
        std::cout &lt;&lt; &quot;YES\n&quot; &lt;&lt; (int)res.size() &lt;&lt; &#39;\n&#39;;
        for (auto i : res)
            std::cout &lt;&lt; i &lt;&lt; &#39; &#39;;
        std::cout &lt;&lt; &#39;\n&#39;;
    &#125;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;</code></pre>
</details>
<hr />
<h2 id="d---defender-of-childhood-dreams">D - Defender of Childhood Dreams</h2>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/CF1583F" class="uri">https://www.luogu.com.cn/problem/CF1583F</a></p>
<ul>
<li>考虑把每连续 <span class="math inline">\(k\)</span> 个点分为一个一级组，每个一级组内全部连 <span class="math inline">\(1\)</span> 边。显然组内边最长不超过 <span class="math inline">\(k-1\)</span>。</li>
<li>接着把每连续 <span class="math inline">\(k\)</span> 个一级组分为一个二级组，二级组内空闲边全部涂成颜色 <span class="math inline">\(2\)</span>。此时 <span class="math inline">\(a&lt;b\)</span> 的条件就会派上用场——每个一级组的值域是没有交的，一级组之间的边都是同一个朝向。这样就保证由颜色为 <span class="math inline">\(2\)</span> 的边构成的连链来自不同的一级组，长度最多为 <span class="math inline">\(k-1\)</span>。</li>
<li>依次类推，<span class="math inline">\(i\)</span> 级组是大小为 <span class="math inline">\(k^i\)</span> 的团，故 <span class="math inline">\(i\)</span> 最大为 <span class="math inline">\(\left\lceil \log_kn\right\rceil\)</span>。</li>
<li>按上述流程构造，即可 <span class="math inline">\(O(n^2)\)</span> 完成。</li>
</ul>
<details>
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, k;
    std::cin &gt;&gt; n &gt;&gt; k;
    using arr = std::vector&lt;int&gt;;
    using brr = std::vector&lt;arr&gt;;
    brr pos;
    for (int i = 1; i &lt;= n; ++i)
        pos.push_back(&#123; i &#125;);
    brr g(n + 1, arr(n + 1));
    std::function&lt;void(brr&amp;, int)&gt; calc = [&amp;](brr &amp;pos, int now) &#123;
        if ((int)pos.size() == 1) &#123;
            std::cout &lt;&lt; now &lt;&lt; &#39;\n&#39;;
            for (int i = 1; i &lt;= n; ++i)
                for (int j = i + 1; j &lt;= n; ++j)
                    std::cout &lt;&lt; g[i][j] &lt;&lt; &#39; &#39;;
            std::cout &lt;&lt; &#39;\n&#39;;
            return;
        &#125;
        brr p;
        ++now;
        for (int i = 0; i &lt; (int)pos.size(); i += k) &#123;
            p.emplace_back();
            for (int j = i; j &lt; i + k &amp;&amp; j &lt; (int)pos.size(); ++j) &#123;
                for (auto a : p.back())
                    for (auto b : pos[j])
                        g[a][b] = now;
                for (auto b : pos[j])
                    p.back().push_back(b);
            &#125;
        &#125;
        calc(p, now);
        return;
    &#125;;
    calc(pos, 0);
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;</code></pre>
</details>
<hr />
<h2 id="e---edge-split">E - Edge Split</h2>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/CF1726D" class="uri">https://www.luogu.com.cn/problem/CF1726D</a></p>
<ul>
<li>题意有些许歧义，『红色连通块』其实是指删掉蓝边之后的连通块。考虑到 <span class="math inline">\(m\le n+2\)</span> 而不是更多，考虑直接分讨。</li>
<li>考虑树的情况，对于任意颜色，删一条边就会带来 <span class="math inline">\(1\)</span> 个连通块的代价，随便染色即可。</li>
<li><p>考虑基环树的情况，发现如果环上有某个颜色，那么钦定这个颜色第一次删边删的是环边，就会发现第一次删边不会有代价，故强制环上有两种颜色即可。</p>
<p>考虑 <span class="math inline">\(m=n+1\)</span> 的情况，环可能有下面三种形态：</p>
<p><img src="image.png" /></p>
<p>对于第一、二种，保证两个环上都有两种颜色即可，第三种乍一看有点复杂，其实还是一样的，保证两个环都有两种颜色即可，这样三个环显然都会有两种颜色。站在不饱和度的角度，第三个环其实是无意义的。</p></li>
<li><p>由此类推 <span class="math inline">\(m=n+2\)</span> 的情况，发现只需要在并查集连边时令树边为蓝，反祖边为红即可。发现这样会且仅会在第一组样例的情况出问题：</p>
<figure>
<img src="image-1.png" alt="如果中间的三角形在最后输入就不能得到最优解" /><figcaption>如果中间的三角形在最后输入就不能得到最优解</figcaption>
</figure>
<p>怎么处理这个问题呢，我们使用人类智慧，发现这种情况最后三条红边构成三角形，我们只要发现构造出来的解是这样的三角形，由于造成这一点的顺序很苛刻，故一直 <code>random_shuffle</code> 输入，继续构造直到合法即可。</p>
<p>（？怎么最优解全是这么做的，我还以为只有我一个人会乱搞。）</p></li>
<li><p>当不饱和度为 4 的时候就会出现这种结构：</p>
<p><img src="image-2.png" /></p>
<p>此时按照刚刚的方法就一定构造不出合法解了。这或许也是 <span class="math inline">\(m\le n+2\)</span> 的原因。</p></li>
</ul>
<details>
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    std::mt19937 rand(0xabcdef);
    int T;
    for (std::cin &gt;&gt; T; T--; ) &#123;
        int n, m;
        std::cin &gt;&gt; n &gt;&gt; m;
        std::vector&lt;int&gt; res(m + 1);
        std::vector&lt;std::tuple&lt;int, int, int&gt; &gt; e(m + 1);
        for (int i = 1, x, y; i &lt;= m; ++i) &#123;
            std::cin &gt;&gt; x &gt;&gt; y;
            e[i] = &#123; x, y, i &#125;;
        &#125;
        auto work = [&amp;](std::vector&lt;std::tuple&lt;int, int, int&gt; &gt; &amp;e) &#123;
            std::vector&lt;int&gt; f(n + 1);
            std::iota(f.begin() + 1, f.end(), 1);
            std::function&lt;int(int)&gt; find = [&amp;](int x) &#123;
                return x == f[x] ? x : f[x] = find(f[x]);
            &#125;;
            std::set&lt;int&gt; t;
            for (int i = 1; i &lt;= m; ++i) &#123;
                auto [x, y, id] = e[i];
                if (find(x) == find(y)) &#123;
                    t.insert(x), t.insert(y);
                    res[id] = 1;
                &#125;
                else &#123;
                    res[id] = 0;
                    f[find(x)] = find(y);
                &#125;
            &#125;
            return (int)t.size() != 3;
        &#125;;
        for (; !work(e); std::shuffle(e.begin() + 1, e.end(), rand));
        for (int i = 1; i &lt;= m; ++i)
            std::cout &lt;&lt; res[i];
        std::cout &lt;&lt; &#39;\n&#39;;
    &#125;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;</code></pre>
</details>
<hr />
<h2 id="f---fair-share">F - Fair Share</h2>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/CF1634E" class="uri">https://www.luogu.com.cn/problem/CF1634E</a></p>

			</div>
			<hr class="dotted">
			<div class="post footer">
				<div id="hitokoto">
					<h3 id="hitokoto-title">
						言论
					</h3>
					<div id="hitokoto-content">
					</div>
					<div id="hitokoto-from">
					</div>
				</div>
				<div class="button flex">
					<div id="prev">
						
					</div>
					<div id="next">
						
							<a href="/20251020/">
								Spanning Tree Again
								<i class="fas fa-angle-double-right" style="margin-left: 10px;"></i>
							</a>
						
					</div>
				</div>
				<div id="vcomments" class="text"></div>
<script>
	new Valine({
		el: '#vcomments',
		appId: 'OlmvQ0a2Zw7xo3no2bwabOzx-gzGzoHsz',
		appKey: 'TW6t8mFeGLmhPjWisvmllvvo',
		recordIP: true,
		enableQQ: true, 
		// [EDITED] 目前 Valine 的 QQ 自动获取昵称似乎不可用
		// 该问题在 v1.5.3 中已修复
		pageSize: 10,
		requiredFields:
			
				['nick']
			,
		placeholder: "The world is but a little place after all...\n能够根据邮箱获取你的 Gravatar 头像。昵称是必填项，长度需不低于 3。",
		avatar: 'identicon',
		avatar_cdn: 'https://cravatar.cn/avatar/',
		emojiCDN: 'https://xsc062.netlify.app/em/', 
		emojiMaps: {
			
				"微笑": "wx.gif",
			
				"龇牙": "cy.gif",
			
				"流泪": "ll.gif",
			
				"笑哭": "xk.gif",
			
				"流汗": "lh.gif",
			
				"擦汗": "ch.gif",
			
				"亲亲": "qq.gif",
			
				"色": "se.gif",
			
				"疑问": "yiw.gif",
			
				"发呆": "fd.gif",
			
				"晕": "yun.gif",
			
				"鼓掌": "gz.gif",
			
				"憨笑": "hanx.gif",
			
				"快哭了": "kk.gif",
			
				"得意": "dy.gif",
			
				"狂笑": "kx.gif",
			
				"害羞": "hx.gif",
			
				"妈妈生的": "dz.gif",
			
				"糗大了": "qd.gif",
			
				"吃瓜": "cg.gif",
			
				"睁眼": "zy.webp",
			
				"辣眼睛": "lyj.gif",
			
				"酸了": "nm.gif",
			
				"滚": "gun.webp",
			
				"惊恐": "jk.gif",
			
				"幽灵": "youl.gif",
			
				"无聊": "wul.gif",
			
				"吃": "eat.gif",
			
				"你很棒棒": "bb.gif",
			
				"赞": "qiang.gif",
			
				"踩": "ruo.gif",
			
				"握手": "wsh.gif",
			
				"发抖": "fad.gif",
			
				"挥手": "hsh.gif",
			
				"磕头": "kt.gif",
			
				"怄火": "oh.gif",
			
		},
	})
</script>
			</div>
			<script>setHitokoto();</script>
		</div> 
	</div>
</div>
    <!-- 页脚开始 -->
<div id="footer" class="serif">
    Powered by
    <a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a>
    &
    <a href="/about-this-theme">
        iwll
    </a>
    <p style="margin-top: 5px;">
        2021 - 2025
    </p>
</div>
<!-- Valine 相关配置 -->
<script>
    const getValineDomTimer = setInterval(() => {
        // 不知道为什么 我从原博客 js 文件粘过来的参数是
        // "#valine .vcards .vcard"
        // DEBUG 了半天才定位到这个问题。。。
        const vcards =
            document.querySelectorAll('#valine, .vcards, .vcard');
        if (vcards.length > 0) {
            let author = 'XSC062';
            for (let vcard of vcards) {
                const vnick_dom = vcard.querySelector('.vhead .vnick');
                if (vnick_dom != null) {
                    const vnick = vnick_dom.innerHTML;
                    if (vnick === author) {
                        vnick_dom.innerHTML =
                        `${vnick} <span id="rootitem" class="code">root</span>`
                    }
                }
            }
        }
        else {
            clearInterval(getValineDomTimer);
        }
    }, 2000);
    SetActiveItem();
    setDetailsSummary();
    setTitleAnchor();
    setEmptyToc();
    setCodeClassName();
</script>


<!-- js -->
<!-- 搜索功能相关配置 -->

<script src="/js/search.js"></script>


<script src="/js/local-search.js"></script>

</script>
<!-- prism 相关配置 -->
<script type="text/javascript" src="/js/prism.js" defer></script>
<!-- 代码块复制功能 -->
<script type="text/javascript" src="/js/clipboard.min.js"></script>
<script type="text/javascript" src="/js/clipboard-use.js"></script>
<!-- 页脚结束 -->
</body>
</html>