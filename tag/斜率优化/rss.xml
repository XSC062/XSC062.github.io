<?xml version="1.0"?>
<rss version="2.0">
    <channel>
        <title> • Posts by &#34;斜率优化&#34; tag</title>
        <link>https://xsc062.netlify.app</link>
        <description></description>
        <language>zh-CN</language>
        <pubDate>Tue, 15 Jul 2025 14:13:24 +0800</pubDate>
        <lastBuildDate>Tue, 15 Jul 2025 14:13:24 +0800</lastBuildDate>
        <category>并查集</category>
        <category>斜率优化</category>
        <category>悬线法</category>
        <category>哈希</category>
        <category>字典树</category>
        <category>DP</category>
        <category>单调队列</category>
        <category>分治</category>
        <category>二分图</category>
        <category>CRT / exCRT</category>
        <category>排列组合</category>
        <category>网络流</category>
        <category>费用流</category>
        <category>二分</category>
        <category>上下界网络流</category>
        <category>容斥原理</category>
        <category>线段树</category>
        <category>树状数组</category>
        <category>区间 DP</category>
        <category>构造</category>
        <category>数据结构</category>
        <category>Tarjan</category>
        <category>下饭</category>
        <category>LCA</category>
        <category>倍增</category>
        <category>鸽巢原理</category>
        <category>概率期望</category>
        <category>调和级数</category>
        <category>差分</category>
        <category>思维</category>
        <category>树形 DP</category>
        <category>最小生成树</category>
        <category>SAM</category>
        <category>状压</category>
        <category>分块</category>
        <category>可持久化</category>
        <category>笛卡尔树</category>
        <category>高维前缀和</category>
        <category>闲话</category>
        <category>欧拉回路</category>
        <category>树链剖分</category>
        <category>长链剖分</category>
        <category>KMP</category>
        <category>border</category>
        <category>字符串</category>
        <category>AC 自动机</category>
        <category>SA</category>
        <category>数学</category>
        <category>树上差分</category>
        <category>FWT</category>
        <category>堆</category>
        <category>树的重心</category>
        <category>二项式定理</category>
        <category>二项式反演</category>
        <category>贪心</category>
        <category>均摊</category>
        <category>计数</category>
        <category>优化建图</category>
        <category>反悔贪心</category>
        <category>调整法</category>
        <category>背包</category>
        <category>博弈论</category>
        <category>DP 优化</category>
        <category>虚树</category>
        <category>点分治</category>
        <category>WQS 二分</category>
        <category>闵可夫斯基和</category>
        <category>slope trick</category>
        <category>四边形不等式</category>
        <category>状压 DP</category>
        <category>组合数学</category>
        <category>支配对</category>
        <category>DDP</category>
        <category>容斥</category>
        <category>Kruskal 重构树</category>
        <category>高精度</category>
        <category>最短路</category>
        <category>李超线段树</category>
        <item>
            <guid isPermalink="true">https://xsc062.netlify.app/20250715/</guid>
            <title>练习 决策单调性</title>
            <link>https://xsc062.netlify.app/20250715/</link>
            <category>斜率优化</category>
            <category>DP</category>
            <category>四边形不等式</category>
            <pubDate>Tue, 15 Jul 2025 14:13:24 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;『心静自然凉』大抵是因为情绪平和时副交感神经兴奋，体温略有降低导致的。吗？&lt;/p&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;
&lt;p&gt;其实是因为心脏停跳后血液循环终止、代谢中断，导致产热低于散热（？）&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;a---征途&#34;&gt;A - 征途&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P4072&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P4072&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;用完全平方公式展开得到 &lt;span class=&#34;math inline&#34;&gt;\(m^2\sigma^2=m\left(\sum {x_i}^2\right)-S^2\)&lt;/span&gt;，其中 &lt;span class=&#34;math inline&#34;&gt;\(S\)&lt;/span&gt; 为求和。&lt;/p&gt;
&lt;p&gt;所以目标是最小化 &lt;span class=&#34;math inline&#34;&gt;\(\sum {x_i}^2\)&lt;/span&gt; 这个东西。令 &lt;span class=&#34;math inline&#34;&gt;\(f_{i,j}\)&lt;/span&gt; 表示第 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 天走到 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt;，得到：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
\begin{aligned}
f_{i,j}&amp;amp;=\min\{f_{i-1,k}+(s_j-s_k)^2\}\\
&amp;amp;=\min\{f_{i-1,k}-2\times s_j\times s_k+{s_k}^2\}+{s_j}^2
\end{aligned}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;最后得到的斜率式子是 &lt;span class=&#34;math inline&#34;&gt;\(\dfrac {f_{i - 1, a}-f_{i - 1, b}+{s_a}^2-{s_b}^2}{2(s_a-s_b)}&amp;lt;s_j\)&lt;/span&gt;，由于 &lt;span class=&#34;math inline&#34;&gt;\(s_j\)&lt;/span&gt; 单增，&lt;del&gt;单调队列维护递减斜率即可&lt;/del&gt; &lt;strong&gt;更正：是递增斜率。原因是 &lt;span class=&#34;math inline&#34;&gt;\(&amp;lt;\)&lt;/span&gt; 是弹出条件，而非保留条件……&lt;/strong&gt;&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const long long inf = 1e9;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#endif
    int n, m;
    std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
    std::vector&amp;lt;int&amp;gt; a(n + 1);
    std::vector&amp;lt;long long&amp;gt; s(n + 1);
    auto sum(0ll);
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        std::cin &amp;gt;&amp;gt; a[i];
        s[i] = s[i - 1] + a[i];
        sum += a[i];
    &amp;#125;
    std::vector&amp;lt;std::vector&amp;lt;long long&amp;gt; &amp;gt; f(m + 1, std::vector&amp;lt;long long&amp;gt; (n + 1, inf));
    f[0][0] = 0ll;
    for (int i = 1; i &amp;lt;= m; ++i) &amp;#123;
        auto f1 = [&amp;amp;](int a, int b) &amp;#123;
            return f[i - 1][a] - f[i - 1][b] + s[a] * s[a] - s[b] * s[b];
        &amp;#125;;
        auto f2 = [&amp;amp;](int a, int b) &amp;#123;
            return 2 * (s[a] - s[b]);
        &amp;#125;;
        std::vector&amp;lt;int&amp;gt; q(n + 1);
        int h = 0, t = -1;
        q[++t] = i - 1;
        for (int j = i; j &amp;lt;= n; ++j) &amp;#123;
            for (; h &amp;lt; t &amp;amp;&amp;amp; f1(q[h + 1], q[h]) &amp;lt; s[j] * f2(q[h + 1], q[h]); ++h);
            f[i][j] = f[i - 1][q[h]] + (s[j] - s[q[h]]) * (s[j] - s[q[h]]);
            for (; h &amp;lt; t &amp;amp;&amp;amp; f1(j, q[t]) * f2(q[t], q[t - 1]) &amp;lt; f1(q[t], q[t - 1]) * f2(j, q[t]); --t);
            q[++t] = j;
        &amp;#125;
    &amp;#125;
    std::cout &amp;lt;&amp;lt; m * f[m][n] - sum * sum &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;b---刷野-iii&#34;&gt;B - 刷野 III&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P10074&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P10074&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;发现最坏情况就是每次『试探』都不中的情况，再试探中最坏的那一个。为啥呢，相当于我们每次攻击的一定是未知元素中血最多的一个。既然已经试探出了比阈值大的所有元素，那么下一个攻击的就一定是阈值本身，如果这次跳过它，它就会成为下一次试探失败的元素。这显然不如一开始就直接用新阈值试探。&lt;/p&gt;
&lt;p&gt;从大到小排序。令 &lt;span class=&#34;math inline&#34;&gt;\(f_{j, i}\)&lt;/span&gt; 表示只确定了前 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 大的数，已经杀了 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; 个人的最坏情况最小代价。那么显然这一次的阈值是 &lt;span class=&#34;math inline&#34;&gt;\(a_i\)&lt;/span&gt;。随便选出上一次的阈值 &lt;span class=&#34;math inline&#34;&gt;\(a_k\)&lt;/span&gt;，那么中间这一段待确定的元素数量为 &lt;span class=&#34;math inline&#34;&gt;\(i-k\)&lt;/span&gt;。那么有：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
\begin{aligned}
f_{j, i}&amp;amp;=\min\limits_{k&amp;lt;i}\{f_{j-1,k}+(i-k)\times a_i\}\\
&amp;amp;=\min\limits_{k&amp;lt;i}\{f_{j-1,k}-k\times a_i\}+i\times a_i
\end{aligned}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;经过验证，虽然这个式子和题解长得不一样，但是是对的 &lt;del&gt;因为我 n^3 暴力 A 了&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;推出斜优形式 &lt;span class=&#34;math inline&#34;&gt;\(\dfrac {f_{j-1,A}-f_{j-1,B}}{A-B}&amp;lt;a_i\)&lt;/span&gt;，但我的朋友，&lt;span class=&#34;math inline&#34;&gt;\(a_i\)&lt;/span&gt; 是递减的。所以用单调栈维护递增斜率即可。&lt;del&gt;或者你也可以学习 grisses 打一个单调队列上二分&lt;/del&gt;&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const long long inf = 1e12;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;P10074_4.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#endif
    int n, m;
    std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
    std::vector&amp;lt;long long&amp;gt; a(n + 1);
    for (int i = 1; i &amp;lt;= n; ++i)
        std::cin &amp;gt;&amp;gt; a[i];
    std::sort(a.begin() + 1, a.end(), std::greater&amp;lt;long long&amp;gt; ());
    std::vector&amp;lt;std::vector&amp;lt;long long&amp;gt; &amp;gt; f(m + 1, std::vector&amp;lt;long long&amp;gt; (n + 1, inf));
    f[0][0] = 0ll;
    for (int j = 1; j &amp;lt;= m; ++j) &amp;#123;
        std::vector&amp;lt;int&amp;gt; q(n + 1);
        int t = -1;
        q[++t] = j - 1;
        auto f1 = [&amp;amp;](int A, int B) &amp;#123;
            return f[j - 1][A] - f[j - 1][B];
        &amp;#125;;
        auto f2 =[&amp;amp;](int A, int B) &amp;#123;
            return A - B;
        &amp;#125;;
        for (int i = j; i &amp;lt;= n; ++i) &amp;#123;
            for (; t &amp;gt;= 1 &amp;amp;&amp;amp; f1(q[t], q[t - 1]) &amp;gt; a[i] * f2(q[t], q[t - 1]); --t);
            f[j][i] = f[j - 1][q[t]] + (i - q[t]) * a[i];
            for (; t &amp;gt;= 1 &amp;amp;&amp;amp; f1(i, q[t]) * f2(q[t], q[t - 1]) &amp;lt; f1(q[t], q[t - 1]) * f2(i, q[t]); --t);
            q[++t] = i;
        &amp;#125;
    &amp;#125;
    auto res(inf);
    for (int i = m; i &amp;lt;= n; ++i)
        res = std::min(res, f[m][i]);
    std::cout &amp;lt;&amp;lt; res &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;c---traka&#34;&gt;C - TRAKA&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P7747&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P7747&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;稍微手玩一下就可以发现，假如第 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; 个人在第 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 次的工作时间为 &lt;span class=&#34;math inline&#34;&gt;\([L_{j,i},R_{j,i}]\)&lt;/span&gt;，第 &lt;span class=&#34;math inline&#34;&gt;\(i-1\)&lt;/span&gt; 次为 &lt;span class=&#34;math inline&#34;&gt;\([L_{j,i-1},R_{j,i-1}]\)&lt;/span&gt;，那么要求 &lt;span class=&#34;math inline&#34;&gt;\(L_{j,i}\ge R_{j,i-1}\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;令 &lt;span class=&#34;math inline&#34;&gt;\(s_j\)&lt;/span&gt; 为 &lt;span class=&#34;math inline&#34;&gt;\(t\)&lt;/span&gt; 的前缀和。假设第 &lt;span class=&#34;math inline&#34;&gt;\(i-1\)&lt;/span&gt; 次加工于 &lt;span class=&#34;math inline&#34;&gt;\(x_{i-1}\)&lt;/span&gt; 开始，那么我们可以把上式转写为 &lt;span class=&#34;math inline&#34;&gt;\(x_{i}+s_{j-1}\times f_{i}\ge x_{i-1}+s_j\times f_{i-1}\)&lt;/span&gt;。也即 &lt;span class=&#34;math inline&#34;&gt;\(x_i-x_{i-1}\ge s_j\times f_{i-1}-s_{j-1}\times f_i\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;显然需要找到一个 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; 使得 RSH 取得最大值；现在就可以考虑斜率优化了。由于所有项都和 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 有关，想到两边同除 &lt;span class=&#34;math inline&#34;&gt;\(f_{i}\)&lt;/span&gt; 消掉一个 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 有关的系数，最后化出来的斜优形式是 &lt;span class=&#34;math inline&#34;&gt;\(\dfrac {s_A-s_B}{s_{A-1}-s_{B-1}}&amp;gt;\dfrac {f_{i-1}}{f_i}\)&lt;/span&gt;。由于 RSH 不单调，把所有 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; 塞到队列里维护递减斜率，打二分即可。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#endif
    int n, m;
    std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
    std::vector&amp;lt;long long&amp;gt; a(n + 1), w(m + 1), s(n + 1);
    for (int i = 1; i &amp;lt;= n; ++i)
        std::cin &amp;gt;&amp;gt; a[i], s[i] = s[i - 1] + a[i];
    for (int i = 1; i &amp;lt;= m; ++i)
        std::cin &amp;gt;&amp;gt; w[i];
    std::vector&amp;lt;long long&amp;gt; f(m + 1);
    std::vector&amp;lt;int&amp;gt; q(n + 1);
    int h = 0, t = -1;
    q[++t] = 1;
    for (int i = 2; i &amp;lt;= n; ++i) &amp;#123;
        for (; h &amp;lt; t &amp;amp;&amp;amp; (s[i] - s[q[t]]) * (s[q[t] - 1] - s[q[t - 1] - 1]) &amp;gt; (s[q[t]] - s[q[t - 1]]) * (s[i - 1] - s[q[t] - 1]); --t);
        q[++t] = i;
    &amp;#125;
    for (int i = 2; i &amp;lt;= m; ++i) &amp;#123;
        int to = q[h];
        for (int l = h + 1, r = t, mid; l &amp;lt;= r; ) &amp;#123;
            mid = (l + r) &amp;gt;&amp;gt; 1;
            if ((s[q[mid]] - s[q[mid - 1]]) * w[i - 1] &amp;gt; w[i] * (s[q[mid] - 1] - s[q[mid - 1] - 1]))
                to = q[mid], l = mid + 1;
            else
                r = mid - 1;
        &amp;#125;
        f[i] = f[i - 1] + s[to] * w[i - 1] - s[to - 1] * w[i];
    &amp;#125;
    std::cout &amp;lt;&amp;lt; f[m] + w[m] * s[n] &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;d---柠檬&#34;&gt;D - 柠檬&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P5504&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P5504&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;观察零：原问题『从两端取』可以转化为分段问题，故从其中一端考虑即可。&lt;/li&gt;
&lt;li&gt;观察一：若有一段连续的 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt;，完整的比拆开的更优。&lt;/li&gt;
&lt;li&gt;观察二：如果一段 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 中夹杂了一些其他元素，那么在哪里分段是说不准的。&lt;/li&gt;
&lt;li&gt;观察三：如果选取的区间是 &lt;span class=&#34;math inline&#34;&gt;\([1,r]\)&lt;/span&gt;，那么贪心地想，&lt;span class=&#34;math inline&#34;&gt;\(a_r\)&lt;/span&gt; 一定是关键值，不然取 &lt;span class=&#34;math inline&#34;&gt;\(a_r\)&lt;/span&gt; 就浪费了。&lt;/li&gt;
&lt;li&gt;观察四：如果选取的区间是 &lt;span class=&#34;math inline&#34;&gt;\([l,r]\)&lt;/span&gt;，那么由观察四，&lt;span class=&#34;math inline&#34;&gt;\(a_l=a_r\)&lt;/span&gt;，且该值为关键值。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;结合这几个观察，令 &lt;span class=&#34;math inline&#34;&gt;\(c_i\)&lt;/span&gt; 表示 &lt;span class=&#34;math inline&#34;&gt;\(a_i\)&lt;/span&gt; 在 &lt;span class=&#34;math inline&#34;&gt;\([1,i]\)&lt;/span&gt; 中出现次数，&lt;span class=&#34;math inline&#34;&gt;\(f_i\)&lt;/span&gt; 表示这一段以 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 结尾的最大价值：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
\begin{aligned}
f_i&amp;amp;=\max\limits_{j&amp;lt;i,a_{j+1}=a_i}\{f_j+a_i\times (c_i-c_{j + 1} + 1)^2\}\\
&amp;amp;=\max\limits_{j&amp;lt;i,a_{j+1}=a_i}\{f_j+a_{j+1}\times {c_{j+1}}^2-2\times c_i\times a_{j+1}\times c_{j+1}-2\times c_{j+1}\times a_{j+1}\}+a_i\times(c_i-1)^2
\end{aligned}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;（怎么这么大一堆。）最后可以化出 &lt;span class=&#34;math inline&#34;&gt;\(\dfrac {f_A-f_B+a_{A+1}\cdot c_{A+1}\cdot (c_{A+1}-2)-a_{B+1}\cdot c_{B+1}\cdot (c_{B+1}-2)}{2(c_{A+1} - c_{B+1})}&amp;gt;c_i\times a_i\)&lt;/span&gt;。发现对于每一种 &lt;span class=&#34;math inline&#34;&gt;\(a_i\)&lt;/span&gt;，&lt;span class=&#34;math inline&#34;&gt;\(c_i\times a_i\)&lt;/span&gt; 是单增的。单调栈维护即可。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;这其实提醒我们关于代换的问题——显然，当与 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 的项、与 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; 有关的项之间存在代换关系时，应该尽量往 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; 的方向靠。&lt;/em&gt;&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;7.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#endif
    int n;
    std::cin &amp;gt;&amp;gt; n;
    std::vector&amp;lt;long long&amp;gt; a(n + 1), c(n + 1), la(10001);
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        std::cin &amp;gt;&amp;gt; a[i];
        c[i] = c[la[a[i]]] + 1, la[a[i]] = i;
    &amp;#125;
    std::vector&amp;lt;long long&amp;gt; f(n + 1);
    std::vector&amp;lt;int&amp;gt; _t(10001, -1);
    std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; _q(10001);
    auto f1 = [&amp;amp;](int A, int B) &amp;#123;
        return f[A] - f[B] + a[A + 1] * c[A + 1] * (c[A + 1] - 2) - a[B + 1] * c[B + 1] * (c[B + 1] - 2);
    &amp;#125;;
    auto f2 = [&amp;amp;](int A, int B) &amp;#123;
        return 2 * (c[A + 1] - c[B + 1]);
    &amp;#125;;
    ++_t[a[1]], _q[a[1]].push_back(0);
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        &amp;#123;
            auto &amp;amp;t = _t[a[i]];
            auto &amp;amp;q = _q[a[i]];
            for (; t &amp;gt;= 1 &amp;amp;&amp;amp; f1(q[t], q[t - 1]) &amp;lt; c[i] * a[i] * f2(q[t], q[t - 1]); --t);
            f[i] = f[q[t]] + a[i] * (c[i] - c[q[t] + 1] + 1) * (c[i] - c[q[t] + 1] + 1);
        &amp;#125;
        if (i &amp;lt; n) &amp;#123;
            auto &amp;amp;t = _t[a[i + 1]];
            auto &amp;amp;q = _q[a[i + 1]];
            for (; t &amp;gt;= 1 &amp;amp;&amp;amp; f1(i, q[t]) * f2(q[t], q[t - 1]) &amp;gt; f1(q[t], q[t - 1]) * f2(i, q[t]); --t);
            q.resize(++t + 1), q[t] = i;
        &amp;#125;
    &amp;#125;
    std::cout &amp;lt;&amp;lt; f[n] &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;e---knapsack-with-diminishing-values&#34;&gt;E - Knapsack with Diminishing Values&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/abc373/tasks/abc373_f&#34; class=&#34;uri&#34;&gt;https://atcoder.jp/contests/abc373/tasks/abc373_f&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;发现和 &lt;a href=&#34;/20250707-1/#例单调队列优化多重背包&#34;&gt;单调队列优化多重背包&lt;/a&gt; 有异曲同工之妙。&lt;/p&gt;
&lt;p&gt;不妨令 &lt;span class=&#34;math inline&#34;&gt;\(v_i\)&lt;/span&gt; 表示体积，&lt;span class=&#34;math inline&#34;&gt;\(w_i\)&lt;/span&gt; 表示价值。对于每一个 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt;，把所有体积按模 &lt;span class=&#34;math inline&#34;&gt;\(v_i\)&lt;/span&gt; 的余数分类，设为 &lt;span class=&#34;math inline&#34;&gt;\(j\cdot v_i+x\)&lt;/span&gt;。对于 &lt;span class=&#34;math inline&#34;&gt;\(k\cdot v_i+x\)&lt;/span&gt;，有：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
\begin{aligned}
f_{i,j\cdot v_i+x}&amp;amp;=\max\limits_{k&amp;lt;j}\{f_{i-1,k\cdot v_i+x}+(j-k)\cdot w_i-(j-k)^2\}\\
&amp;amp;=\max\limits_{k&amp;lt;j}\{f_{i-1,k\cdot v_i+x}-k\cdot w_i-k^2+2\times j\times k\}-j^2+j\cdot w_i
\end{aligned}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;则得到 &lt;span class=&#34;math inline&#34;&gt;\(\dfrac {f_{i-1,A\cdot v_i+x}-f_{i-1,B\cdot v_i+x}+(B-A)\cdot w_i - A^2+B^2}{2(B-A)}&amp;lt;j\)&lt;/span&gt;。注意分母为负。总之单调队列维护递增斜率即可。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#endif
    int n, m;
    std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
    std::vector&amp;lt;long long&amp;gt; v(n + 1), w(n + 1);
    std::vector&amp;lt;std::vector&amp;lt;long long&amp;gt; &amp;gt; f(n + 1, std::vector&amp;lt;long long&amp;gt; (m + 1));
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        std::cin &amp;gt;&amp;gt; v[i] &amp;gt;&amp;gt; w[i];
        for (int x = 0; x &amp;lt; v[i]; ++x) &amp;#123;
            int h = 0, t = -1;
            std::vector&amp;lt;int&amp;gt; q;
            auto f1 = [&amp;amp;](int A, int B) &amp;#123;
                return f[i - 1][A * v[i] + x] - f[i - 1][B * v[i] + x] + (B - A) * w[i] - A * A + B * B;
            &amp;#125;;
            auto f2 = [&amp;amp;](int A, int B) &amp;#123;
                return 2 * (B - A);
            &amp;#125;;
            for (int j = 0, J = x; J &amp;lt;= m; ++j, J += v[i]) &amp;#123;
                for (; h &amp;lt; t &amp;amp;&amp;amp; f1(q[h + 1], q[h]) &amp;gt; j * f2(q[h + 1], q[h]); ++h);
                f[i][J] = f[i - 1][J];
                if (h &amp;lt;= t)
                    f[i][J] = std::max(f[i][J], f[i - 1][q[h] * v[i] + x] + (j - q[h]) * w[i] - (j - q[h]) * (j - q[h]));
                for (; h &amp;lt; t &amp;amp;&amp;amp; f1(j, q[t]) * f2(q[t], q[t - 1]) &amp;lt; f1(q[t], q[t - 1]) * f2(j, q[t]); --t);
                q.resize(++t + 1), q[t] = j;
            &amp;#125;
        &amp;#125;
    &amp;#125;
    std::cout &amp;lt;&amp;lt; f[n][m] &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;f---managing-telephone-poles&#34;&gt;F - Managing Telephone Poles&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://codeforces.com/problemset/problem/1575/M&#34; class=&#34;uri&#34;&gt;https://codeforces.com/problemset/problem/1575/M&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;？观察到性质然后被自己忽略了。非常值得批评。&lt;/p&gt;
&lt;p&gt;不难写出类似斜率优化的式子 &lt;span class=&#34;math inline&#34;&gt;\(S(i,j)=\min\{ {x_k}^2-2\times i\times x_k+{y_k}^2-2\times j \times y_k\}+i^2+j^2\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;会下意识尝试固定 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt;，就可以 &lt;span class=&#34;math inline&#34;&gt;\(O(n^2m)\)&lt;/span&gt; 完成任务，似乎不太行。顺着这个想法会观察到，固定 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 之后，每一列的 poles 中只有和第 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 行最近的才会有贡献。&lt;/p&gt;
&lt;p&gt;这个是好做的，且这样的相邻点数量是 &lt;span class=&#34;math inline&#34;&gt;\(O(m)\)&lt;/span&gt; 的；于是将 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 视为常数进行变形，若将所有 poles 按 &lt;span class=&#34;math inline&#34;&gt;\(y\)&lt;/span&gt; 从小到大排序就能得到斜率形式 &lt;span class=&#34;math inline&#34;&gt;\(\dfrac { {x_A}^2-{x_B}^2+{y_A}^2-{y_B}^2-2\times i\times(x_A-x_B)}{2(y_A-y_B)}&amp;lt;j\)&lt;/span&gt;。维护递增斜率就能 &lt;span class=&#34;math inline&#34;&gt;\(O(n^2)\)&lt;/span&gt; 完成问题。&lt;/p&gt;
&lt;p&gt;那么找相邻点这一步大可以摆烂写二分。所以总共是 &lt;span class=&#34;math inline&#34;&gt;\(O(nm\log m)\)&lt;/span&gt; 的。&lt;/p&gt;
&lt;p&gt;不要像我一样把两边最近的都加进队列，不然你会有分母为 &lt;span class=&#34;math inline&#34;&gt;\(0\)&lt;/span&gt; 的斜率 &lt;img src=&#34;/em/hsh.gif&#34; /&gt;&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#endif
    int n, m;
    std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m, ++n, ++m;
    std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; tag(n + 1, std::vector&amp;lt;int&amp;gt; (m + 1));
    std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; g(m + 1);
    for (int i = 1; i &amp;lt;= n; ++i)
        for (int j = 1; j &amp;lt;= m; ++j) &amp;#123;
            char t;
            std::cin &amp;gt;&amp;gt; t;
            if (t == &amp;#39;1&amp;#39;)
                g[j].push_back(i), tag[i][j] = 1;
        &amp;#125;
    struct node &amp;#123; long long x, y; &amp;#125;;
    auto res(0ll);
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        std::vector&amp;lt;node&amp;gt; p;
        for (int j = 1; j &amp;lt;= m; ++j) &amp;#123;
            int to = std::lower_bound(g[j].begin(), g[j].end(), i) - g[j].begin();
            if (to &amp;lt; (int)g[j].size()) &amp;#123;
                p.push_back(&amp;#123; g[j][to], j &amp;#125;);
                if (g[j][to] != i &amp;amp;&amp;amp; to != 0 &amp;amp;&amp;amp; g[j][to] - i &amp;gt; i - g[j][to - 1])
                    p.back() = &amp;#123; g[j][to - 1], j &amp;#125;;
            &amp;#125;
            else if (to != 0)
                p.push_back(&amp;#123; g[j][to - 1], j &amp;#125;);
        &amp;#125;
        std::vector&amp;lt;int&amp;gt; q(m + 1);
        int h = 0, t = -1;
        auto f1 = [&amp;amp;](node A, node B) &amp;#123;
            return A.x * A.x - B.x * B.x + A.y * A.y - B.y * B.y - 2 * i * (A.x - B.x);
        &amp;#125;;
        auto f2 = [&amp;amp;](node A, node B) &amp;#123;
            return 2 * (A.y - B.y);
        &amp;#125;;
        for (int j = 0; j &amp;lt; (int)p.size(); ++j) &amp;#123;
            for (; h &amp;lt; t &amp;amp;&amp;amp; f1(p[j], p[q[t]]) * f2(p[q[t]], p[q[t - 1]]) &amp;lt; f1(p[q[t]], p[q[t - 1]]) * f2(p[j], p[q[t]]); --t);
            q[++t] = j;
        &amp;#125;
        for (int j = 1; j &amp;lt;= m; ++j) &amp;#123;  
            for (; h &amp;lt; t &amp;amp;&amp;amp; f1(p[q[h + 1]], p[q[h]]) &amp;lt; j * f2(p[q[h + 1]], p[q[h]]); ++h);
            res += (p[q[h]].x - i) * (p[q[h]].x - i) + (p[q[h]].y - j) * (p[q[h]].y - j);
        &amp;#125;
    &amp;#125;
    std::cout &amp;lt;&amp;lt; res &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;g---partition-game&#34;&gt;G - Partition Game&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://codeforces.com/problemset/problem/1527/E&#34; class=&#34;uri&#34;&gt;https://codeforces.com/problemset/problem/1527/E&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;发现不太斜优，终于给我浸泡了两天斜优内容的大脑加了勺新的底物。&lt;/p&gt;
&lt;p&gt;令 &lt;span class=&#34;math inline&#34;&gt;\(f_{i,j}\)&lt;/span&gt; 表示第 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 段以 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; 结尾的最小代价；对 &lt;span class=&#34;math inline&#34;&gt;\(w\)&lt;/span&gt; 套用四边形不等式变式 &lt;span class=&#34;math inline&#34;&gt;\(w(l-1,r+1)+w(l,r)\ge w(l-1,r)+w(l,r+1)\)&lt;/span&gt; 发现成立（其中大多数时候能取等；部分特殊情况取到大于号）。&lt;/p&gt;
&lt;p&gt;那么发现可以用分治优化。发现 &lt;span class=&#34;math inline&#34;&gt;\(w\)&lt;/span&gt; 不那么能快速求；还是套用 &lt;a href=&#34;/20250707-1/#例yet-another-minimization-problem&#34;&gt;Yet Another Minimization Problem&lt;/a&gt; 中的方法，用类似莫队的方式求解。&lt;/p&gt;
&lt;p&gt;发现这个莫队套路也很熟悉了，直接用双端队列维护即可。复杂度 &lt;span class=&#34;math inline&#34;&gt;\(O(nk\log n)\)&lt;/span&gt;，看着不太安全。但注意到我们在 20 个月前的提交中使用了 &lt;span class=&#34;math inline&#34;&gt;\(O(nk\log n)\)&lt;/span&gt; 的线段树，所以能过的兄弟。&lt;/p&gt;
&lt;details&gt;
&lt;p&gt;鉴于 deque 的时空常数都大得吓人，所以我用静态 vector 模拟 deque 了。&lt;/p&gt;
&lt;p&gt;跑得比我之前线段树的一半还快，兄弟。&lt;/p&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int inf = 1e18;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#endif
    int n, m;
    std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
    std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; pos(n + 1);
    std::vector&amp;lt;int&amp;gt; a(n + 1), _h(n + 1), _t(n + 1, -1);
    for (int i = 1; i &amp;lt;= n; ++i)
        std::cin &amp;gt;&amp;gt; a[i], pos[a[i]].push_back(i);
    std::vector&amp;lt;std::vector&amp;lt;long long&amp;gt; &amp;gt; f(m + 1, std::vector&amp;lt;long long&amp;gt; (n + 1, inf));
    f[0][0] = 0ll;
    auto w = [&amp;amp;](int ql, int qr) &amp;#123;
        static int l = 1, r = 0;
        static auto res(0ll);
        for (; l &amp;gt; ql; ) &amp;#123;
            --l;
            auto &amp;amp;h = _h[a[l]], &amp;amp;t = _t[a[l]];
            auto &amp;amp;q = pos[a[l]];
            if (h &amp;lt;= t)
                res -= q[t] - q[h];
            res += q[t] - q[--h];
        &amp;#125;
        for (; r &amp;gt; qr; ) &amp;#123;
            auto &amp;amp;h = _h[a[r]], &amp;amp;t = _t[a[r]];
            auto &amp;amp;q = pos[a[r]];
            res -= q[t--] - q[h];
            if (h &amp;lt;= t)
                res += q[t] - q[h];
            --r;
        &amp;#125;
        for (; r &amp;lt; qr; ) &amp;#123;
            ++r;
            auto &amp;amp;h = _h[a[r]], &amp;amp;t = _t[a[r]];
            auto &amp;amp;q = pos[a[r]];
            if (h &amp;lt;= t)
                res -= q[t] - q[h];
            res += q[++t] - q[h];
        &amp;#125;
        for (; l &amp;lt; ql; ) &amp;#123;
            auto &amp;amp;h = _h[a[l]], &amp;amp;t = _t[a[l]];
            auto &amp;amp;q = pos[a[l]];
            res -= q[t] - q[h++];
            if (h &amp;lt;= t)
                res += q[t] - q[h];
            ++l;
        &amp;#125;
        return res;
    &amp;#125;;
    for (int t = 1; t &amp;lt;= m; ++t) &amp;#123;
        std::function&amp;lt;void(int, int, int, int)&amp;gt; calc = [&amp;amp;](int l, int r, int lp, int rp) &amp;#123;
            if (l &amp;gt; r)
                return;
            if (l == r) &amp;#123;
                for (int i = lp; i &amp;lt;= rp &amp;amp;&amp;amp; i &amp;lt; l; ++i)
                    f[t][l] = std::min(f[t][l], f[t - 1][i] + w(i + 1, l));
                return;
            &amp;#125;
            int mid = (l + r) &amp;gt;&amp;gt; 1, p = -1;
            for (int i = lp; i &amp;lt;= rp &amp;amp;&amp;amp; i &amp;lt; mid; ++i)
                if (f[t - 1][i] + w(i + 1, mid) &amp;lt; f[t][mid])
                    f[t][mid] = f[t - 1][i] + w(i + 1, mid), p = i;
            calc(l, mid - 1, lp, p), calc(mid + 1, r, p, rp);
            return;
        &amp;#125;;
        calc(t, n, t - 1, n - 1);
    &amp;#125;
    std::cout &amp;lt;&amp;lt; f[m][n] &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;h---battle-lemmings&#34;&gt;H - Battle Lemmings&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://codeforces.com/problemset/problem/1420/E&#34; class=&#34;uri&#34;&gt;https://codeforces.com/problemset/problem/1420/E&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;容易发现 &lt;span class=&#34;math inline&#34;&gt;\(0\)&lt;/span&gt; 的数目不变，答案就是 &lt;span class=&#34;math inline&#34;&gt;\(0\)&lt;/span&gt; 的对数 - 连续 &lt;span class=&#34;math inline&#34;&gt;\(0\)&lt;/span&gt; 的对数。&lt;/p&gt;
&lt;p&gt;然后有一个我们很熟悉的 trick，随便找一个目标序列，那么花费的操作次数就是每个对应的 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt; 的位置差。令 &lt;span class=&#34;math inline&#34;&gt;\(f_{i,j,k}\)&lt;/span&gt; 表示用了 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 次操作、&lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; 个 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt;、最后一个 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt; 在 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 的最小连续 &lt;span class=&#34;math inline&#34;&gt;\(0\)&lt;/span&gt; 对数。那么有：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
\begin{aligned}
f_{i,j,k}&amp;amp;=\min\limits_{p&amp;lt;k}\left\{f_{i-|k-pos_j|,j-1,p}+\dfrac {(k-p-1)(k-p-2)}2\right\}\\
&amp;amp;=\min\left\{f_{i-|k-pos_j|,j-1,p}-k\cdot p+\dfrac {p(p + 2)}2\right\}+\dfrac {k^2-3k+2}2
\end{aligned}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;发现这个式子是 &lt;span class=&#34;math inline&#34;&gt;\(O(n^5)\)&lt;/span&gt; 的，而且看起来很斜优，化为斜率形式 &lt;span class=&#34;math inline&#34;&gt;\(\dfrac{2\times f_A-2\times f_B+A(A+2)-B(B+2)}{2(A-B)}&amp;lt;k\)&lt;/span&gt;。维护递增斜率就可以 &lt;span class=&#34;math inline&#34;&gt;\(O(n^4)\)&lt;/span&gt; 做了。&lt;/p&gt;
&lt;p&gt;Tip：当时写着写着愣住了，比如这个 &lt;span class=&#34;math inline&#34;&gt;\(i-|k-pos_j|\)&lt;/span&gt; 不是一直在动吗。解决方案？同时维护很多个队列即可。&lt;/p&gt;
&lt;details&gt;
&lt;p&gt;注意还要把最后一个 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt; 之后连续 &lt;span class=&#34;math inline&#34;&gt;\(0\)&lt;/span&gt; 的代价算上。&lt;/p&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const long long inf = 1e9;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#endif
    int n;
    std::cin &amp;gt;&amp;gt; n;
    std::vector&amp;lt;int&amp;gt; a(n + 1);
    std::vector&amp;lt;long long&amp;gt; pos(1);
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        std::cin &amp;gt;&amp;gt; a[i];
        if (a[i] == 1)
            pos.push_back(i);
    &amp;#125;
    int m = n * (n - 1) / 2;
    std::vector&amp;lt;std::vector&amp;lt;std::vector&amp;lt;long long&amp;gt; &amp;gt; &amp;gt; f(pos.size(), std::vector&amp;lt;std::vector&amp;lt;long long&amp;gt; &amp;gt; (m + 1, std::vector&amp;lt;long long&amp;gt; (n + 1, inf)));
    f[0][0][0] = 0ll;
    for (int j = 1; j &amp;lt; (int)pos.size(); ++j) &amp;#123;
        std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; _q(m + 1, std::vector&amp;lt;int&amp;gt; (n + 1));
        std::vector&amp;lt;int&amp;gt; _h(m + 1), _t(m + 1, -1);
        for (int k = 0; k &amp;lt;= n; ++k)
            for (int i = m; i &amp;gt;= 0; --i) &amp;#123;
                if (i &amp;gt;= std::abs(k - pos[j])) &amp;#123;
                    auto f1 = [&amp;amp;](long long A, long long B) &amp;#123;
                        return 2 * f[j - 1][i - std::abs(k - pos[j])][A] - 2 * f[j - 1][i - std::abs(k - pos[j])][B] + A * (A + 2) - B * (B + 2);
                    &amp;#125;;
                    auto f2 = [&amp;amp;](long long A, long long B) &amp;#123;
                        return 2 * (A - B);
                    &amp;#125;;
                    auto &amp;amp;h = _h[i - std::abs(k - pos[j])], &amp;amp;t = _t[i - std::abs(k - pos[j])];
                    auto &amp;amp;q = _q[i - std::abs(k - pos[j])];
                    for (; h &amp;lt; t &amp;amp;&amp;amp; f1(q[h + 1], q[h]) &amp;lt; k * f2(q[h + 1], q[h]); ++h) &amp;#123;&amp;#125;
                    if (h &amp;lt;= t)
                        f[j][i][k] = std::min(inf, f[j - 1][i - std::abs(k - pos[j])][q[h]] + (k - q[h] - 1) * (k - q[h] - 2) / 2);
                &amp;#125;
                auto f1 = [&amp;amp;](long long A, long long B) &amp;#123;
                    return 2 * f[j - 1][i][A] - 2 * f[j - 1][i][B] + A * (A + 2) - B * (B + 2);
                &amp;#125;;
                auto f2 = [&amp;amp;](long long A, long long B) &amp;#123;
                    return 2 * (A - B);
                &amp;#125;;
                auto &amp;amp;h = _h[i], &amp;amp;t = _t[i];
                auto &amp;amp;q = _q[i];
                for (; h &amp;lt; t &amp;amp;&amp;amp; f1(k, q[t]) * f2(q[t], q[t - 1]) &amp;lt; f1(q[t], q[t - 1]) * f2(k, q[t]); --t);
                q[++t] = k;
            &amp;#125;
    &amp;#125;
    auto res(-inf);
    int cnt = n - (int)pos.size() + 1;
    cnt = cnt * (cnt - 1) / 2;
    for (int i = 0; i &amp;lt;= m; ++i) &amp;#123;
        for (int k = 0; k &amp;lt;= n; ++k)
            res = std::max(res, cnt - f.back()[i][k] - (n - k) * (n - k - 1) / 2);
        std::cout &amp;lt;&amp;lt; res &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
    &amp;#125;
    std::cout &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;a---yakiniku-restaurants&#34;&gt;A - Yakiniku Restaurants&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/arc067/tasks/arc067_d&#34; class=&#34;uri&#34;&gt;https://atcoder.jp/contests/arc067/tasks/arc067_d&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;发现固定左右端点后，收益是可以贪心算的；下意识想到只固定左端点，那么右端点应该就可以用单调队列之类的搞一搞。&lt;/p&gt;
&lt;p&gt;先提前把所有东西塞到队列里。左端点一开始在最右边；往左边动一下之后，就可以更新每种菜的队列；发现在所有元素中作决策点的不总是队头；这个地方用 &lt;strong&gt;单调递减的单调栈&lt;/strong&gt; 是极好的。这里的单调栈其实就类似 &lt;a href=&#34;/20250707-1/#优化-dp单调数据结构&#34;&gt;四边形不等式中的单调数据结构&lt;/a&gt; 了。&lt;/p&gt;
&lt;p&gt;维护单调栈中每个决策点的影响区间；显然每个右端点的答案变化量相同；用个类似于差分的东西记录一下就好了。&lt;/p&gt;
&lt;p&gt;复杂度 &lt;span class=&#34;math inline&#34;&gt;\(O(n^2)\)&lt;/span&gt;。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const long long inf = 1e18;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#endif
    int n, m;
    std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
    std::vector&amp;lt;long long&amp;gt; s(n + 1), f(n + 1);
    for (int i = 2; i &amp;lt;= n; ++i) &amp;#123;
        std::cin &amp;gt;&amp;gt; s[i], s[i] += s[i - 1];
        f[i] = -s[i];
    &amp;#125;
    std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; a(n + 1, std::vector&amp;lt;int&amp;gt; (m + 1));
    for (int i = 1; i &amp;lt;= n; ++i)
        for (int j = 1; j &amp;lt;= m; ++j)
            std::cin &amp;gt;&amp;gt; a[i][j];
    struct node &amp;#123; int j, l, r; &amp;#125;;
    std::vector&amp;lt;std::stack&amp;lt;node&amp;gt; &amp;gt; _q(m + 1);
    auto res(-inf);
    for (int l = n; l; --l) &amp;#123;
        std::vector&amp;lt;long long&amp;gt; d(n + 1);
        auto add = [&amp;amp;](int l, int r, long long v) &amp;#123;
            d[l] += v;
            if (r != n)
                d[r + 1] -= v;
            return;
        &amp;#125;;
        for (int j = 1; j &amp;lt;= m; ++j) &amp;#123;
            auto &amp;amp;q = _q[j];
            node now = &amp;#123; j, l, l &amp;#125;;
            add(l, l, a[l][j]);
            for (; !q.empty() &amp;amp;&amp;amp; a[l][j] &amp;gt;= a[q.top().l][q.top().j]; q.pop()) &amp;#123;
                now.r = q.top().r;
                add(q.top().l, q.top().r, a[l][j] - a[q.top().l][q.top().j]);
            &amp;#125;
            q.push(now);
        &amp;#125;
        std::partial_sum(d.begin() + 1, d.end(), d.begin() + 1);
        for (int r = l; r &amp;lt;= n; ++r) &amp;#123;
            f[r] += d[r];
            res = std::max(res, f[r] + s[l]);
        &amp;#125;
    &amp;#125;
    std::cout &amp;lt;&amp;lt; res &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;b---jellyfish-and-miku&#34;&gt;B - Jellyfish and Miku&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://codeforces.com/problemset/problem/1874/D&#34; class=&#34;uri&#34;&gt;https://codeforces.com/problemset/problem/1874/D&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;唉数列。唉概统。在数学讲义上折磨了我一遍之后还要到这儿来折磨我。&lt;/p&gt;
&lt;p&gt;假设已经知道了 &lt;span class=&#34;math inline&#34;&gt;\(a\)&lt;/span&gt;，考虑求期望步数。设 &lt;span class=&#34;math inline&#34;&gt;\(E_i\)&lt;/span&gt; 为从 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 出发走到 &lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt; 的期望步数。那么有：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
E_i=\begin{cases}
E_1+1&amp;amp;i=0\\
0&amp;amp;i=n\\
E_i=(E_{i-1}+1)\cdot \dfrac {a_i}{a_{i+1}+a_i}+(E_{i+1}+1)\cdot \dfrac {a_{i+1}}{a_{i+1}+a_{i}}&amp;amp;\text{otherwise}
\end{cases}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;（提示：从『&lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 下一步会走哪个方向』考虑。）&lt;/p&gt;
&lt;p&gt;接下来就可以利用你的高中数学知识进行一个 &lt;span class=&#34;math inline&#34;&gt;\(f_0\)&lt;/span&gt; 的求，（一堆过程），得到 &lt;span class=&#34;math inline&#34;&gt;\(E_0=n+2\times \sum\limits_{i=1}^n\dfrac {\sum_{j\le i}a_j}{a_i}\)&lt;/span&gt;，然后想要最小化这个东西。&lt;/p&gt;
&lt;p&gt;不妨令 &lt;span class=&#34;math inline&#34;&gt;\(f_{i,j}\)&lt;/span&gt; 表示到 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 时已经分配走了 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; 体积，&lt;span class=&#34;math inline&#34;&gt;\(\sum_{k=1}^i \dfrac {\sum_{l\le k}a_l}{a_k}\)&lt;/span&gt; 的最小值，有 &lt;span class=&#34;math inline&#34;&gt;\(f_{i,j}=\min\limits_{k&amp;lt;j}\left\{f_{i-1,k}+\dfrac {k}{j - k}\right\}\)&lt;/span&gt;。发现它大抵是满足四边形不等式的，按照 &lt;a href=&#34;/20250707-1/#d1d-dp-优化&#34;&gt;2D/1D DP 优化的结论&lt;/a&gt;，代入 &lt;span class=&#34;math inline&#34;&gt;\(p_{i,j-1}&amp;lt;p_{i,j}&amp;lt;p_{i+1,j}\)&lt;/span&gt; 可以 &lt;span class=&#34;math inline&#34;&gt;\(O(nm)\)&lt;/span&gt; 解决问题。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#endif
    int n, m;
    std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
    std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; p(n + 1, std::vector&amp;lt;int&amp;gt; (m + 1));
    std::vector&amp;lt;std::vector&amp;lt;long double&amp;gt; &amp;gt; f(n + 1, std::vector&amp;lt;long double&amp;gt; (m + 1, 1e18));
    f[0][0] = 0ll;
    for (int j = 1; j &amp;lt;= m; ++j)
        for (int i = std::min(j, n); i; --i) &amp;#123;
            int to = ((i == std::min(j, n)) ? j : std::min(p[i + 1][j], j));
            for (int k = p[i][j - 1]; k &amp;lt;= to; ++k)
                if (f[i - 1][k] + k * 1. / (j - k) &amp;lt; f[i][j])
                    f[i][j] = f[i - 1][k] + k * 1. / (j - k), p[i][j] = k;
            // printf(&amp;quot;f[%d][%d] = %Lf, p = %d\n&amp;quot;, i, j, f[i][j], p[i][j]);
        &amp;#125;
    std::cout &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(10) &amp;lt;&amp;lt; n + 2 * f[n][m] &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;cut-the-sequence&#34;&gt;Cut the Sequence&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P10977&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P10977&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;通知区间最值-不满足-四边形不等式&#34;&gt;&lt;mark&gt;通知：区间最值 不满足 四边形不等式。&lt;/mark&gt;&lt;/h1&gt;
&lt;p&gt;其实在猜的时候是举了反例的，但是大脑萎缩了推着推着忘记符号了 😅&lt;/p&gt;
&lt;p&gt;看到 &lt;span class=&#34;math inline&#34;&gt;\(f_i=\min\limits_{g(i)\le j&amp;lt;i}\{f_j+\max\{a_{j+1\sim i}\}\}\)&lt;/span&gt; 这个 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; 的范围其实是有点单调队列优化的感觉的，但这个最大值传统的单调队列不是很可做。可以注意到最大值这一项有点 &lt;strong&gt;单调队列&lt;/strong&gt; 后缀最大值的感觉（实际上就是）；一个很自然的想法是利用这个最大值影响的区间，维护 &lt;span class=&#34;math inline&#34;&gt;\(f\)&lt;/span&gt; 的线段树来暴力做。&lt;/p&gt;
&lt;p&gt;另一个比较牛的做法是发现同一个下标的 &lt;span class=&#34;math inline&#34;&gt;\(f\)&lt;/span&gt; 和 &lt;span class=&#34;math inline&#34;&gt;\(a\)&lt;/span&gt; 的关系。首先需要注意到 &lt;span class=&#34;math inline&#34;&gt;\(f\)&lt;/span&gt; 单调不降；对于同一个 &lt;span class=&#34;math inline&#34;&gt;\(a\)&lt;/span&gt;，能取到的 &lt;span class=&#34;math inline&#34;&gt;\(f\)&lt;/span&gt; 就是最靠前的；维护一个 &lt;span class=&#34;math inline&#34;&gt;\(a\)&lt;/span&gt; 的单减队列，那么共用同一个 &lt;span class=&#34;math inline&#34;&gt;\(a\)&lt;/span&gt; 的就是相邻两个下标之间的部分，其最优决策在能取到的最前端取得；需要注意到队列里的贡献并不单调，需要用一个 multiset 来存储所有贡献并查找、更新。&lt;/p&gt;
&lt;p&gt;需要注意单调队列里某个元素 &lt;span class=&#34;math inline&#34;&gt;\(f_{q_i}\)&lt;/span&gt; 结合的其实是 &lt;span class=&#34;math inline&#34;&gt;\(a_{q_{i+1}}\)&lt;/span&gt;。还需要注意队头的维护，可能需要一些小巧思。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;1.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#endif
    int n, m;
    std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
    std::vector&amp;lt;int&amp;gt; a(n + 1);
    std::vector&amp;lt;long long&amp;gt; s(n + 1);
    for (int i = 1; i &amp;lt;= n; ++i)
        std::cin &amp;gt;&amp;gt; a[i], s[i] = s[i - 1] + a[i];
    int h = 0, t = -1;
    std::multiset&amp;lt;long long&amp;gt; st;
    std::vector&amp;lt;long long&amp;gt; f(n + 1);
    std::vector&amp;lt;std::pair&amp;lt;int, int&amp;gt; &amp;gt; q(n + 1);
    q[++t] = &amp;#123; 0, 0 &amp;#125;, a[0] = 0x3f3f3f3f;
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        for (; s[i] - s[q[h].second] &amp;gt; m; ) &amp;#123;
            st.erase(st.find(f[q[h].second] + a[q[h + 1].first]));
            if (++q[h].second &amp;gt;= q[h + 1].first)
                a[q[++h].first] = 0x3f3f3f3f;
            else
                st.insert(f[q[h].second] + a[q[h + 1].first]);
        &amp;#125;
        for (; h &amp;lt; t &amp;amp;&amp;amp; a[q[t].first] &amp;lt;= a[i]; --t)
            st.erase(st.find(f[q[t - 1].second] + a[q[t].first]));
        st.insert(f[q[t].second] + a[i]), q[++t] = &amp;#123; i, i &amp;#125;;
        f[i] = *st.begin();
    &amp;#125;
    std::cout &amp;lt;&amp;lt; f[n] &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://xsc062.netlify.app/20210214/</guid>
            <title>【总结】斜率优化 DP</title>
            <link>https://xsc062.netlify.app/20210214/</link>
            <category>斜率优化</category>
            <pubDate>Sat, 06 Feb 2021 23:59:00 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;于是，XSC062 开始写总结。&lt;/p&gt;
&lt;h2 id=&#34;斜率优化-dp&#34;&gt;斜率优化 DP&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;前置芝士&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.cnblogs.com/XSC062/p/14383610.html&#34;&gt;单调队列优化 DP&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;正文&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们以一道题为例。&lt;/p&gt;
&lt;h3 id=&#34;打印文章&#34;&gt;&lt;a href=&#34;http://acm.hdu.edu.cn/showproblem.php?pid=3507&#34;&gt;打印文章&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://loj.ac/p/10191&#34;&gt;双倍经验&lt;/a&gt; | &lt;a href=&#34;https://www.acwing.com/problem/content/1096/&#34;&gt;三倍经验&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&#34;solution&#34;&gt;Solution&lt;/h4&gt;
&lt;p&gt;明显 DP。&lt;/p&gt;
&lt;p&gt;那么 DP 式就是： &lt;span class=&#34;math display&#34;&gt;\[
\begin{aligned}
f_i&amp;amp;=\min\{f_j+(s_i-s_j)^2+M\}
\\
&amp;amp;=\min\{f_j+{s_i}^2-2\times s_i\times s_j+{s_j}^2+M\}
\\
&amp;amp;=\min\{f_j-2\times s_i\times s_j+{s_j}^2\}+{s_i}^2+M
\end{aligned}
\]&lt;/span&gt; 其中 &lt;span class=&#34;math inline&#34;&gt;\(s\)&lt;/span&gt; 为 &lt;span class=&#34;math inline&#34;&gt;\(c\)&lt;/span&gt; 的前缀和。&lt;/p&gt;
&lt;p&gt;时间复杂度 &lt;span class=&#34;math inline&#34;&gt;\(\mathcal O(n^2)\)&lt;/span&gt;，明显爆炸，所以我们需要优化。&lt;/p&gt;
&lt;p&gt;在上一篇的 &lt;a href=&#34;https://www.cnblogs.com/XSC062/p/14383610.html&#34;&gt;单调队列优化DP&lt;/a&gt; 中，我们提到过，只有 DP 式中的与 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 有关的项能直接提出来时，我们才能使用单调队列优化，而这里的 &lt;span class=&#34;math inline&#34;&gt;\(s_i\)&lt;/span&gt; 与 &lt;span class=&#34;math inline&#34;&gt;\(s_j\)&lt;/span&gt; 相乘，无法使用单调队列优化。&lt;/p&gt;
&lt;p&gt;我们思考，对于 &lt;span class=&#34;math inline&#34;&gt;\(f_i\)&lt;/span&gt; 来说，无非就是选出最优的 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; 来构造它。&lt;/p&gt;
&lt;p&gt;假设有 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; 与 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt;，如何判断 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; 与 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 谁更优呢？&lt;/p&gt;
&lt;p&gt;我们先钦定 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; 优于 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt;，且 &lt;span class=&#34;math inline&#34;&gt;\(j&amp;lt;k\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;那么可以得到： &lt;span class=&#34;math display&#34;&gt;\[
f_j-2\times s_i\times s_j+{s_j}^2+{s_i}^2+M&amp;lt;f_k-2\times s_i\times s_k+{s_k}^2+{s_i}^2+M
\]&lt;/span&gt; 化简得： &lt;span class=&#34;math display&#34;&gt;\[
f_j-2\times s_i\times s_j+{s_j}^2&amp;lt;f_k-2\times s_i\times s_k+{s_k}^2
\]&lt;/span&gt; 再将&lt;strong&gt;只&lt;/strong&gt;与 &lt;span class=&#34;math inline&#34;&gt;\(j,k\)&lt;/span&gt; 有关的项放到左边，与 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 有关的项放到右边： &lt;span class=&#34;math display&#34;&gt;\[
f_j-f_k+{s_j}^2-{s_k}^2&amp;lt;2\times s_i\times s_j-2\times s_i\times s_k
\\
f_j-f_k+{s_j}^2-{s_k}^2&amp;lt;2\times s_i\times(s_j-s_k)
\]&lt;/span&gt; 左右两边同时 &lt;span class=&#34;math inline&#34;&gt;\(\div\)&lt;/span&gt; 与 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 无关的项 &lt;span class=&#34;math inline&#34;&gt;\(2\times(s_j-s_k)\)&lt;/span&gt; ： &lt;span class=&#34;math display&#34;&gt;\[
\dfrac{(f_j+{s_j}^2)-(f_k+{s_k}^2)}{(2\times s_j)-(2\times s_k)}&amp;lt;s_i
\]&lt;/span&gt; 如果满足上式 ，则 &lt;span class=&#34;math inline&#34;&gt;\(j&amp;lt;k\)&lt;/span&gt; 且 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; 优于 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;接下来是斜率优化的重点部分。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在义务教育阶段，学生学习了 &lt;a href=&#34;https://baike.baidu.com/item/一次函数&#34;&gt;一次函数&lt;/a&gt;，它的几何意义表示为一条直线，一次项的系数就是直线的斜率，只不过当直线与 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 轴垂直的时候无法表示。虽然没有明确给出斜率这个名词，但实际上思想已经渗透到其中。&lt;/p&gt;
&lt;p&gt;直线对 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 轴的倾斜角 &lt;span class=&#34;math inline&#34;&gt;\(\alpha\)&lt;/span&gt; 的正切值 &lt;span class=&#34;math inline&#34;&gt;\(\tan\alpha\)&lt;/span&gt; 称为该直线的“斜率”，并记作 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; ，公式为 &lt;span class=&#34;math inline&#34;&gt;\(k=\tan\alpha\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;即 &lt;span class=&#34;math inline&#34;&gt;\(k=\tan\alpha=\dfrac{\Delta y}{\Delta x}=\dfrac{y_2-y_1}{x_2-x_1}\)&lt;/span&gt; 或 &lt;span class=&#34;math inline&#34;&gt;\(\dfrac{y_1-y_2}{x_1-x_2}\)&lt;/span&gt; 。&lt;/p&gt;
&lt;p align=&#34;right&#34;&gt;
——选自 &lt;a href=&#34;https://baike.baidu.com/item/%E6%96%9C%E7%8E%87/4914111?fr=aladdin&#34;&gt;斜率_百度百科&lt;/a&gt;
&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;XSC062 看完了百度百科表示 &lt;del&gt;你 TM 在说些啥是不是欺负我六年义务教育的小学生&lt;/del&gt; 恍然大悟&lt;/p&gt;
&lt;p&gt;上面推出来的那个关于 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; 和 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 的DP式，不就是求两个点 &lt;span class=&#34;math inline&#34;&gt;\((2\times s_j,f_j+{s_j}^2)\)&lt;/span&gt; 和 &lt;span class=&#34;math inline&#34;&gt;\((2\times s_k,f_j+{s_k}^2)\)&lt;/span&gt; 连成一条线之后的坡度吗？&lt;/p&gt;
&lt;p&gt;本文后面的部分，&lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 的含义会在「点&lt;span class=&#34;math inline&#34;&gt;\((2\times s_x,f_x+{s_x}^2)\)&lt;/span&gt; 」和「下标 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 」之间漂浮，请根据语境识别。&lt;/p&gt;
&lt;p&gt;随后 XSC062 边打瞌睡边听 GM 讲课（特异功能），勉强算是明白了中心意思：&lt;/p&gt;
&lt;p&gt;如图，假设有三个点 &lt;span class=&#34;math inline&#34;&gt;\(A,B,C\)&lt;/span&gt;，以及 &lt;span class=&#34;math inline&#34;&gt;\(l_{AB}\)&lt;/span&gt; 的斜率 &lt;span class=&#34;math inline&#34;&gt;\(k_1\)&lt;/span&gt;，&lt;span class=&#34;math inline&#34;&gt;\(l_{BC}\)&lt;/span&gt; 的斜率 &lt;span class=&#34;math inline&#34;&gt;\(k_2\)&lt;/span&gt;。&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&#34;https://img-blog.csdnimg.cn/img_convert/3bc5fea553ad6b06229ef9e9fa4c9664.png&#34; alt=&#34;上凸&#34; /&gt;&lt;figcaption&gt;上凸&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;我们暂且把这个向外凸起的奇怪玩意儿称为一个「上凸」。&lt;/p&gt;
&lt;p&gt;回到前面的我们得到的那个结论：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
\dfrac{(f_j+{s_j}^2)-(f_k+{s_k}^2)}{(2\times s_j)-(2\times s_k)}&amp;lt;s_i
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;如果满足上式 ，则 &lt;span class=&#34;math inline&#34;&gt;\(j&amp;lt;k\)&lt;/span&gt; 且 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; 优于 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;简单记忆为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;若 &lt;span class=&#34;math inline&#34;&gt;\(l_{NM}\)&lt;/span&gt; 的斜率比 &lt;span class=&#34;math inline&#34;&gt;\(s_i\)&lt;/span&gt; 小，则 &lt;span class=&#34;math inline&#34;&gt;\(N&amp;lt;M\)&lt;/span&gt; 且 &lt;span class=&#34;math inline&#34;&gt;\(N\)&lt;/span&gt; 优于 &lt;span class=&#34;math inline&#34;&gt;\(M\)&lt;/span&gt; 。&lt;/li&gt;
&lt;li&gt;反之，若点 &lt;span class=&#34;math inline&#34;&gt;\(l_{NM}\)&lt;/span&gt; 的斜率比 &lt;span class=&#34;math inline&#34;&gt;\(s_i\)&lt;/span&gt; 大，则 &lt;span class=&#34;math inline&#34;&gt;\(M&amp;lt;N\)&lt;/span&gt; 且 &lt;span class=&#34;math inline&#34;&gt;\(M\)&lt;/span&gt; 优于 &lt;span class=&#34;math inline&#34;&gt;\(N\)&lt;/span&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;将 &lt;span class=&#34;math inline&#34;&gt;\(A,B\)&lt;/span&gt; 代入，我们得知：&lt;/p&gt;
&lt;ol type=&#34;1&#34;&gt;
&lt;li&gt;若 &lt;span class=&#34;math inline&#34;&gt;\(k_1\leqslant s_i\)&lt;/span&gt;，则 &lt;span class=&#34;math inline&#34;&gt;\(B\)&lt;/span&gt; 优于 &lt;span class=&#34;math inline&#34;&gt;\(A\)&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;若 &lt;span class=&#34;math inline&#34;&gt;\(k_1&amp;gt;s_i\)&lt;/span&gt;，则 &lt;span class=&#34;math inline&#34;&gt;\(A\)&lt;/span&gt; 优于 &lt;span class=&#34;math inline&#34;&gt;\(B\)&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;若 &lt;span class=&#34;math inline&#34;&gt;\(k_2\leqslant s_i\)&lt;/span&gt;，则 &lt;span class=&#34;math inline&#34;&gt;\(C\)&lt;/span&gt; 优于 &lt;span class=&#34;math inline&#34;&gt;\(B\)&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;若 &lt;span class=&#34;math inline&#34;&gt;\(k_2&amp;gt;s_i\)&lt;/span&gt;，则 &lt;span class=&#34;math inline&#34;&gt;\(B\)&lt;/span&gt; 优于 &lt;span class=&#34;math inline&#34;&gt;\(C\)&lt;/span&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;因为斜率 = 倾斜度 = 竖得有多高，明显 &lt;span class=&#34;math inline&#34;&gt;\(k_1&amp;gt;k_2\)&lt;/span&gt;。所以针对一个大小关系，&lt;span class=&#34;math inline&#34;&gt;\(k_1\)&lt;/span&gt; 和 &lt;span class=&#34;math inline&#34;&gt;\(k_2\)&lt;/span&gt; 之间只有可能有：&lt;/p&gt;
&lt;ol type=&#34;1&#34;&gt;
&lt;li&gt;&lt;span class=&#34;math inline&#34;&gt;\(s_i&amp;lt;k_2&amp;lt;k_1\)&lt;/span&gt;，此时 &lt;span class=&#34;math inline&#34;&gt;\(B\)&lt;/span&gt; 优于 &lt;span class=&#34;math inline&#34;&gt;\(C\)&lt;/span&gt;，&lt;span class=&#34;math inline&#34;&gt;\(A\)&lt;/span&gt; 优于 &lt;span class=&#34;math inline&#34;&gt;\(B\)&lt;/span&gt;，&lt;span class=&#34;math inline&#34;&gt;\(A\)&lt;/span&gt; 为最优解。&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;math inline&#34;&gt;\(k_2&amp;lt;s_i&amp;lt;k_1\)&lt;/span&gt;，此时 &lt;span class=&#34;math inline&#34;&gt;\(C\)&lt;/span&gt; 优于 &lt;span class=&#34;math inline&#34;&gt;\(B\)&lt;/span&gt;，&lt;span class=&#34;math inline&#34;&gt;\(A\)&lt;/span&gt; 优于 &lt;span class=&#34;math inline&#34;&gt;\(B\)&lt;/span&gt;，&lt;span class=&#34;math inline&#34;&gt;\(A,C\)&lt;/span&gt; 为最优解。&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;math inline&#34;&gt;\(k_2&amp;lt;k_1&amp;lt;s_i\)&lt;/span&gt;，此时 &lt;span class=&#34;math inline&#34;&gt;\(C\)&lt;/span&gt; 优于 &lt;span class=&#34;math inline&#34;&gt;\(B\)&lt;/span&gt;，&lt;span class=&#34;math inline&#34;&gt;\(B\)&lt;/span&gt; 优于 &lt;span class=&#34;math inline&#34;&gt;\(A\)&lt;/span&gt;，&lt;span class=&#34;math inline&#34;&gt;\(C\)&lt;/span&gt; 为最优解。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;发现了吗？&lt;span class=&#34;math inline&#34;&gt;\(B\)&lt;/span&gt; 永远都不可能是最优解。&lt;/p&gt;
&lt;p&gt;所以如果我们要维护一个最优解的序列，就可以不要 &lt;span class=&#34;math inline&#34;&gt;\(B\)&lt;/span&gt; 了。&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&#34;0.png&#34; alt=&#34;上凸&#34; /&gt;&lt;figcaption&gt;上凸&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;那么，因为我们已经删掉了所有「上凸」的突起部分，所以这个最优解序列里肯定不会再存在「上凸」了。&lt;/p&gt;
&lt;p&gt;如果是这样的「下凸」呢？&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&#34;1.png&#34; alt=&#34;下凸&#34; /&gt;&lt;figcaption&gt;下凸&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(k_1\)&lt;/span&gt; 为 &lt;span class=&#34;math inline&#34;&gt;\(l_{AB}\)&lt;/span&gt; 的斜率，&lt;span class=&#34;math inline&#34;&gt;\(k_2\)&lt;/span&gt; 为 &lt;span class=&#34;math inline&#34;&gt;\(l_{BC}\)&lt;/span&gt; 的斜率。&lt;/p&gt;
&lt;p&gt;将 &lt;span class=&#34;math inline&#34;&gt;\(A,B\)&lt;/span&gt; 代入，我们得知：&lt;/p&gt;
&lt;ol type=&#34;1&#34;&gt;
&lt;li&gt;若 &lt;span class=&#34;math inline&#34;&gt;\(k_1\leqslant s_i\)&lt;/span&gt;，则 &lt;span class=&#34;math inline&#34;&gt;\(B\)&lt;/span&gt; 优于 &lt;span class=&#34;math inline&#34;&gt;\(A\)&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;若 &lt;span class=&#34;math inline&#34;&gt;\(k_1&amp;gt;s_i\)&lt;/span&gt;，则 &lt;span class=&#34;math inline&#34;&gt;\(A\)&lt;/span&gt; 优于 &lt;span class=&#34;math inline&#34;&gt;\(B\)&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;若 &lt;span class=&#34;math inline&#34;&gt;\(k_2\leqslant s_i\)&lt;/span&gt;，则 &lt;span class=&#34;math inline&#34;&gt;\(C\)&lt;/span&gt; 优于 &lt;span class=&#34;math inline&#34;&gt;\(B\)&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;若 &lt;span class=&#34;math inline&#34;&gt;\(k_2&amp;gt;s_i\)&lt;/span&gt;，则 &lt;span class=&#34;math inline&#34;&gt;\(B\)&lt;/span&gt; 优于 &lt;span class=&#34;math inline&#34;&gt;\(C\)&lt;/span&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;明显 &lt;span class=&#34;math inline&#34;&gt;\(k_1&amp;lt;k_2\)&lt;/span&gt;。所以 &lt;span class=&#34;math inline&#34;&gt;\(k_1\)&lt;/span&gt; 和 &lt;span class=&#34;math inline&#34;&gt;\(k_2\)&lt;/span&gt; 之间只有可能有：&lt;/p&gt;
&lt;ol type=&#34;1&#34;&gt;
&lt;li&gt;&lt;span class=&#34;math inline&#34;&gt;\(s_i&amp;lt;k_1&amp;lt;k_2\)&lt;/span&gt;，此时 &lt;span class=&#34;math inline&#34;&gt;\(B\)&lt;/span&gt; 优于 &lt;span class=&#34;math inline&#34;&gt;\(C\)&lt;/span&gt;，&lt;span class=&#34;math inline&#34;&gt;\(A\)&lt;/span&gt; 优于 &lt;span class=&#34;math inline&#34;&gt;\(B\)&lt;/span&gt;，&lt;span class=&#34;math inline&#34;&gt;\(A\)&lt;/span&gt; 为最优解。&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;math inline&#34;&gt;\(k_1&amp;lt;s_i&amp;lt;k_2\)&lt;/span&gt;，此时 &lt;span class=&#34;math inline&#34;&gt;\(B\)&lt;/span&gt; 优于 &lt;span class=&#34;math inline&#34;&gt;\(C\)&lt;/span&gt;，&lt;span class=&#34;math inline&#34;&gt;\(B\)&lt;/span&gt; 优于 &lt;span class=&#34;math inline&#34;&gt;\(A\)&lt;/span&gt;，&lt;span class=&#34;math inline&#34;&gt;\(B\)&lt;/span&gt; 为最优解。&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;math inline&#34;&gt;\(k_1&amp;lt;k_2&amp;lt;s_i\)&lt;/span&gt;，此时 &lt;span class=&#34;math inline&#34;&gt;\(C\)&lt;/span&gt; 优于 &lt;span class=&#34;math inline&#34;&gt;\(B\)&lt;/span&gt;，&lt;span class=&#34;math inline&#34;&gt;\(B\)&lt;/span&gt; 优于 &lt;span class=&#34;math inline&#34;&gt;\(A\)&lt;/span&gt;，&lt;span class=&#34;math inline&#34;&gt;\(C\)&lt;/span&gt; 为最优解。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;所以，在下凸的情况中，三个点都有可能是最优解，都需要保留。&lt;/p&gt;
&lt;p&gt;现在呢，所有上凸都被去掉了，只剩下凸，所以大概最后的最优解序列就长这个样子：&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&#34;2.png&#34; alt=&#34;下凸包&#34; /&gt;&lt;figcaption&gt;下凸包&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;&lt;del&gt;下 秃 包&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;&lt;del&gt;反过来看就是 lifan 的脑袋了&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;观察发现，斜率是从左往右递增的。&lt;/p&gt;
&lt;p&gt;所以，我们考虑用单调队列来当这个「最优解序列」。&lt;/p&gt;
&lt;h5 id=&#34;维护队头&#34;&gt;维护队头&lt;/h5&gt;
&lt;p&gt;即保证队头元素为最优解。&lt;/p&gt;
&lt;p&gt;设队头为 &lt;span class=&#34;math inline&#34;&gt;\(q_l\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;如果 &lt;span class=&#34;math inline&#34;&gt;\(q_{l+1}\)&lt;/span&gt; 与 &lt;span class=&#34;math inline&#34;&gt;\(q_l\)&lt;/span&gt; 形成的斜率 &lt;span class=&#34;math inline&#34;&gt;\(\leqslant s_i\)&lt;/span&gt;，根据上面推出来的玩意儿，得到 &lt;span class=&#34;math inline&#34;&gt;\(q_{l+1}\)&lt;/span&gt; 优于 &lt;span class=&#34;math inline&#34;&gt;\(q_l\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;那还要 &lt;span class=&#34;math inline&#34;&gt;\(q_l\)&lt;/span&gt; 干啥，直接 &lt;code&gt;l++&lt;/code&gt;。&lt;/p&gt;
&lt;h5 id=&#34;更新-dp-值&#34;&gt;更新 DP 值&lt;/h5&gt;
&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(f_i=f_{q_l}-2\times s_i\times s_{q_l}+{s_{q_l}}^2+{s_i}^2+M\)&lt;/span&gt;&lt;/p&gt;
&lt;h5 id=&#34;维护队尾&#34;&gt;维护队尾&lt;/h5&gt;
&lt;p&gt;即保证里面塞的点相邻两个的斜率递增。&lt;/p&gt;
&lt;p&gt;设队尾为 &lt;span class=&#34;math inline&#34;&gt;\(q_r\)&lt;/span&gt;，我们要往最优解队列里 &lt;code&gt;push&lt;/code&gt; 一个 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 。&lt;/p&gt;
&lt;p&gt;若队尾两个点 &lt;span class=&#34;math inline&#34;&gt;\(q_r,q_{r-1}\)&lt;/span&gt; 形成的斜率比 &lt;span class=&#34;math inline&#34;&gt;\(i,q_r\)&lt;/span&gt; 形成的斜率大，那么&lt;code&gt;push(i)&lt;/code&gt;后，整个队列的斜率就不再单调递增，所以此时要将&lt;code&gt;r--&lt;/code&gt;。（因为 &lt;a href=&#34;https://www.cnblogs.com/XSC062/p/14383610.html&#34;&gt;上一篇关于单调队列的博客&lt;/a&gt; 中讲到的 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 必须入队，只能委屈一下 &lt;span class=&#34;math inline&#34;&gt;\(q_r\)&lt;/span&gt; 了）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意事项&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;众所周知，斜率是个浮点数。为了避免损失精度造成的一些惨案，我们交叉相乘，将分子、分母分开处理。&lt;/p&gt;
&lt;p&gt;以及时刻都要保证队列中至少有两个点，因为要访问 &lt;span class=&#34;math inline&#34;&gt;\(q_l,q_{l+1}\)&lt;/span&gt; 和 &lt;span class=&#34;math inline&#34;&gt;\(q_r,q_{r-1}\)&lt;/span&gt;。&lt;/p&gt;
&lt;h4 id=&#34;code&#34;&gt;Code&lt;/h4&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;cstdio&amp;gt;
const int maxn = 5e5 + 5;
int n, m, l, r;
int f[maxn], c[maxn], q[maxn];
inline int getDP(int i, int j) &amp;#123;
    return f[j] + m + (c[i] - c[j]) * (c[i] - c[j]);
&amp;#125;
inline int getup(int j, int k)&amp;#123;
    return f[j] + c[j] * c[j] - f[k] - c[k] * c[k]; // 计算分子的值
&amp;#125;
inline int getdown(int j, int k) &amp;#123;
    return (c[j] - c[k]) * 2; // 计算分母的值
&amp;#125;
int main()&amp;#123;
    while (~scanf(&amp;quot;%d %d&amp;quot;, &amp;amp;n, &amp;amp;m)) &amp;#123;
        l = r = 1; // 凡是涉及到前缀和的单调队列，队列中必须存在初始 0
        for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
            scanf(&amp;quot;%d&amp;quot;, &amp;amp;c[i]); // c 自给自足
            c[i] += c[i - 1];
            // # 维护队头
            // 注意此处的条件为 l &amp;lt; r，因为队列中至少需要存在两个点
            while (l &amp;lt; r &amp;amp;&amp;amp; getup(q[l+1], q[l]) &amp;lt;= c[i] * getdown(q[l + 1],q[l]))
                l++;
            // # 转移状态
            f[i] = getDP(i, q[l]);
            // # 维护队尾
            while(l &amp;lt; r&amp;amp;&amp;amp; getup(i, q[r]) * getdown(q[r], q[r-1]) &amp;lt;= getup(q[r] ,q[r - 1]) * getdown(i, q[r]))
                r--;
            q[++r] = i;
        &amp;#125;
        printf(&amp;quot;%d\n&amp;quot;,f[n]);
    &amp;#125;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在对 DP 式变形时，我们最好将其化为 &lt;span class=&#34;math inline&#34;&gt;\(\dfrac{(j)-(k)}{(j)-(k)}&amp;lt;x\)&lt;/span&gt; 或 &lt;span class=&#34;math inline&#34;&gt;\(\dfrac{(j)-(k)}{(j)-(k)}&amp;gt;x\)&lt;/span&gt; 的形式。&lt;/p&gt;
&lt;p&gt;这个板子只适用于维护下凸包的情况。当中间的符号为 &lt;span class=&#34;math inline&#34;&gt;\(&amp;gt;\)&lt;/span&gt; 时，我们会在这份代码上稍作改动，维护一个上凸包，后文会提到有关内容。&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;玩具装箱&#34;&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P3195&#34;&gt;玩具装箱&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://loj.ac/p/10188&#34;&gt;双倍经验&lt;/a&gt; | &lt;a href=&#34;https://www.acwing.com/problem/content/1094/&#34;&gt;三倍经验&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;从今往后我们就只讲怎么推式子，不再证明下凸等性质了。&lt;/p&gt;
&lt;p&gt;设 &lt;span class=&#34;math inline&#34;&gt;\(f_i\)&lt;/span&gt; 表示第 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 个玩具放完后的最小费用。 &lt;span class=&#34;math display&#34;&gt;\[
f_i=\min\{f_j+(i-j-1+\sum\limits_{k=i}^jC_k-L)^2\}
\]&lt;/span&gt; 为了让这个式子好拆，我们在一开始让 &lt;code&gt;l++&lt;/code&gt;，并且 &lt;span class=&#34;math inline&#34;&gt;\(C\)&lt;/span&gt; 再次自给自足，为输入的 &lt;span class=&#34;math inline&#34;&gt;\(C\)&lt;/span&gt; 的前缀和数组。&lt;/p&gt;
&lt;p&gt;于是式子就变成： &lt;span class=&#34;math display&#34;&gt;\[
f_i=\min\{f_j+(i-j-L+C_i-C_j)^2\}
\]&lt;/span&gt; 明显硬拆会死人。（反正我试过，比较适合用来发泄&lt;/p&gt;
&lt;p&gt;所以我们把式子变成这样： &lt;span class=&#34;math display&#34;&gt;\[
f_i=\min\{f_j+((C_i+i)-(C_j+j)-L)^2\}
\]&lt;/span&gt; 既然 &lt;span class=&#34;math inline&#34;&gt;\(C_i\)&lt;/span&gt; 与 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt;，&lt;span class=&#34;math inline&#34;&gt;\(C_j\)&lt;/span&gt; 与 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; 是对应的，那么直接预处理，给 &lt;span class=&#34;math inline&#34;&gt;\(C_i\)&lt;/span&gt; 加上 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 不就行了？&lt;/p&gt;
&lt;p&gt;现在这个 &lt;span class=&#34;math inline&#34;&gt;\(C_i\)&lt;/span&gt; 的含义和实现就变得有点曲折难懂了。&lt;/p&gt;
&lt;p&gt;具体实现如下：&lt;/p&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
    scanf(&amp;quot;%lld&amp;quot;, &amp;amp;c[i]);
    c[i] += c[i - 1];
&amp;#125;
for (int i = 1; i &amp;lt;= n; ++i)
    c[i] += i;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;也就是说，&lt;span class=&#34;math inline&#34;&gt;\(C_i\)&lt;/span&gt; 是在前缀和的基础上加了一个 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt;，注意不能把 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 也一起前缀和了。&lt;/p&gt;
&lt;p&gt;然后式子就变成了这样： &lt;span class=&#34;math display&#34;&gt;\[
\begin{aligned}
f_i&amp;amp;=\min\{f_j+(C_i-C_j-L)^2\}
\\
&amp;amp;=\min\{f_j+{C_i}^2+{C_j}^2+L^2-2\times C_i\times C_j-2\times C_i\times L+2\times C_j\times L\}
\\
&amp;amp;=\min\{f_j+{C_j}^2-2\times C_i\times C_j+2\times C_j\times L\}+{C_i}^2+L^2-2\times C_i\times L
\end{aligned}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;令 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; 优于 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 且 &lt;span class=&#34;math inline&#34;&gt;\(j&amp;lt;k\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;得： &lt;span class=&#34;math display&#34;&gt;\[
f_j+{C_j}^2-2\times C_i\times C_j+2\times C_j\times L&amp;lt;f_k+{C_k}^2-2\times C_i\times C_k+2\times C_k\times L
\\
f_j-f_k+{C_j}^2-{C_k}^2+2\times C_j\times L-2\times C_k\times L&amp;lt;2\times C_i\times C_j-2\times C_i\times C_k
\\
f_j-f_k+{C_j}^2-{C_k}^2+2\times C_j\times L-2\times C_k\times L&amp;lt;2\times(C_j-C_k)\times C_i
\\
\dfrac{f_j-f_k+{C_j}^2-{C_k}^2}{2\times(C_j-C_k)}&amp;lt;C_i
\\
\dfrac{(f_j+{C_j}^2)-(f_k+{C_k}^2)}{(2\times C_j)-(2\times C_k)}&amp;lt;C_i
\]&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;cstdio&amp;gt;
#define int long long
const int maxn = 5e5 + 5;
const int LEN = (1 &amp;lt;&amp;lt; 20);
int n, m, h, t;
int c[maxn], q[maxn], f[maxn];
#define nec getchar
inline bool read(int &amp;amp;x) &amp;#123;
    char ch = nec();
    bool f = 0; x = 0;
    while (ch &amp;lt; &amp;#39;0&amp;#39; || ch &amp;gt; &amp;#39;9&amp;#39;) &amp;#123;
        if (ch == EOF) return 0;
        if (ch == &amp;#39;-&amp;#39;) f = 1; ch = nec();
    &amp;#125;
    while (ch &amp;gt;= &amp;#39;0&amp;#39; &amp;amp;&amp;amp; ch &amp;lt;= &amp;#39;9&amp;#39;) &amp;#123;
        x = x * 10 + ch - &amp;#39;0&amp;#39;;
        ch = nec();
    &amp;#125;
    if (f) x = -x;
    return 1;
&amp;#125;
inline int getup(int j, int k) &amp;#123;
    return (f[j] + c[j] * c[j] + 2 * c[j] * m)
           - (f[k] + c[k] * c[k] + 2 * c[k] * m);
&amp;#125;
inline int getdown(int j, int k) &amp;#123;
    return (2 * c[j]) - (2 * c[k]);
&amp;#125;
inline int getDP(int i, int j) &amp;#123;
    return f[j] + (c[i] - c[j] - m) * (c[i] - c[j] - m);
&amp;#125;
signed main() &amp;#123;
    read(n); read(m); h = t = 1; ++m;
    for (int i = 1; i &amp;lt;= n; ++i)
        read(c[i]), c[i] += c[i - 1];
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        c[i] += i;
        while (h &amp;lt; t &amp;amp;&amp;amp; getup(q[h + 1], q[h]) &amp;lt;
               c[i] * getdown(q[h + 1], q[h])) ++h;
        f[i] = getDP(i, q[h]);
        while (h &amp;lt; t
               &amp;amp;&amp;amp; getup(i, q[t]) * getdown(q[t], q[t - 1]) &amp;lt;=
               getdown(i, q[t]) * getup(q[t], q[t - 1])) --t;
        q[++t] = i;
    &amp;#125;
    printf(&amp;quot;%lld&amp;quot;, f[n]);
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;任务安排-1&#34;&gt;&lt;a href=&#34;https://loj.ac/p/10184&#34;&gt;任务安排 1&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.acwing.com/problem/content/302/&#34;&gt;双倍经验&lt;/a&gt; | &lt;a href=&#34;https://www.luogu.com.cn/problem/P2365&#34;&gt;三倍经验&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;感谢蓝书。这里按着蓝书上的思维走。&lt;/p&gt;
&lt;h4 id=&#34;解法一&#34;&gt;解法一&lt;/h4&gt;
&lt;p&gt;暴力。&lt;/p&gt;
&lt;p&gt;此处的 &lt;span class=&#34;math inline&#34;&gt;\(t,c\)&lt;/span&gt; 为输入的 &lt;span class=&#34;math inline&#34;&gt;\(t,c\)&lt;/span&gt; 的前缀和数组。&lt;/p&gt;
&lt;p&gt;设 &lt;span class=&#34;math inline&#34;&gt;\(f_{i,j}\)&lt;/span&gt; 为前 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 个任务分成 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; 批的最小费用。&lt;/p&gt;
&lt;p&gt;故 &lt;span class=&#34;math inline&#34;&gt;\(S\times j+t_i\)&lt;/span&gt; 为第 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 个任务的完成时间。&lt;/p&gt;
&lt;p&gt;得出状态转移方程（&lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 枚举上一批任务结束位置）： &lt;span class=&#34;math display&#34;&gt;\[
f_{i,j}=\min\limits_{0\leqslant k&amp;lt;i}\{f_{k,j-1}+(S\times j+t_i)\times(c_i-c_k)\}
\]&lt;/span&gt; 时间复杂度 &lt;span class=&#34;math inline&#34;&gt;\(\mathcal O(n^3)\)&lt;/span&gt;。&lt;/p&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;cstdio&amp;gt;
#include &amp;lt;cstring&amp;gt;
#define int long long
const int inf = 1e18;
const int maxn = 5005;
const int LEN = (1 &amp;lt;&amp;lt; 20);
int f[maxn][maxn];
int n, s, ans = inf;
int t[maxn], c[maxn];
inline int min(int x, int y) &amp;#123; return x &amp;lt; y ? x : y; &amp;#125;
#ifdef ONLINE_JUDGE
inline int nec(void) &amp;#123;
    static char buf[LEN], *p = buf, *e = buf;
    if (p == e) &amp;#123;
        e = buf + fread(buf, 1, LEN, stdin);
        if (e == buf) return EOF; p = buf;
    &amp;#125;
    return *p++;
&amp;#125;
#else
#define nec getchar
#endif
inline bool read(int &amp;amp;x) &amp;#123;
    char ch = nec();
    bool f = 0; x = 0;
    while (ch &amp;lt; &amp;#39;0&amp;#39; || ch &amp;gt; &amp;#39;9&amp;#39;) &amp;#123;
        if (ch == EOF) return 0;
        if (ch == &amp;#39;-&amp;#39;) f = 1;
        ch = nec();
    &amp;#125;
    while (ch &amp;gt;= &amp;#39;0&amp;#39; &amp;amp;&amp;amp; ch &amp;lt;= &amp;#39;9&amp;#39;) &amp;#123;
        x = x * 10 + ch - &amp;#39;0&amp;#39;;
        ch = nec();
    &amp;#125;
    if (f) x = -x;
    return 1;
&amp;#125;
signed main() &amp;#123;
    read(n); read(s);
    memset(f, 0x3f, sizeof (f));
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        read(t[i]); read(c[i]);
        t[i] += t[i - 1];
        c[i] += c[i - 1];
        f[i][1] = (s + t[i]) * c[i]; // 初始化
    &amp;#125;
    for (int i = 2; i &amp;lt;= n; ++i) &amp;#123;
        for (int j = 2; j &amp;lt;= i; ++j) &amp;#123;
            for (int k = 1; k &amp;lt; i; ++k)
                f[i][j] = min(f[i][j], f[k][j - 1] + (t[i] + s * j) * (c[i] - c[k]));
        &amp;#125;
    &amp;#125;
    for (int i = 1; i &amp;lt;= n; ++i)
        ans = min(ans, f[n][i]);
    printf(&amp;quot;%lld&amp;quot;, ans);
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;del&gt;亲测 TLE 70&lt;/del&gt;&lt;/p&gt;
&lt;h4 id=&#34;解法二&#34;&gt;解法二&lt;/h4&gt;
&lt;p&gt;脑子炸了，想了好久才想明白这个优化的正确性。&lt;/p&gt;
&lt;p&gt;思考，以上代码需要 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; 这一维的根本原因是什么？&lt;/p&gt;
&lt;p&gt;因为我们无法确定之前已经划分了多少批，也就是无法确定 &lt;span class=&#34;math inline&#34;&gt;\(S\)&lt;/span&gt; 的个数。&lt;/p&gt;
&lt;p&gt;换个角度思考，我们无法确定之前，却可以确定之后。&lt;/p&gt;
&lt;p&gt;什么意思呢？如果我们在任务 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 处划分，那么任务 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 以及任务 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 以后的所有任务的执行时间都会延后 &lt;span class=&#34;math inline&#34;&gt;\(S\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;因为 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 以后的状态也会使用 &lt;span class=&#34;math inline&#34;&gt;\(f_i\)&lt;/span&gt; 的值，我们在计算 &lt;span class=&#34;math inline&#34;&gt;\(f_i\)&lt;/span&gt; 时就将 &lt;span class=&#34;math inline&#34;&gt;\(S\)&lt;/span&gt; 提出来，提前把后面的 &lt;span class=&#34;math inline&#34;&gt;\(c\)&lt;/span&gt; 乘上不就行了？&lt;/p&gt;
&lt;p&gt;中间的结果不对劲也无所谓，只要最后的答案是对的就行了。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;也就是说，我们没有直接求出每批任务的完成时刻，而是在一批任务&lt;strong&gt;「开始」&lt;/strong&gt;对后续任务产生影响时，就先把费用累加到答案中。这是一种名为&lt;strong&gt;「费用提前计算」&lt;/strong&gt;的经典思想。&lt;/p&gt;
&lt;p align=&#34;right&#34;&gt;
——李煜东《算法竞赛进阶指南》
&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;状态转移方程： &lt;span class=&#34;math display&#34;&gt;\[
f_i=\min\limits_{0\leqslant j&amp;lt;i}\{f_j+(c_i-c_j)\times t_i+s\times(c_n-c_j)\}
\]&lt;/span&gt; 此处，&lt;span class=&#34;math inline&#34;&gt;\(f_i\)&lt;/span&gt; 没有具体含义。&lt;/p&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;cstdio&amp;gt;
#include &amp;lt;cstring&amp;gt;
#define int long long
const int maxn = 1e4 + 5;
const int LEN = (1 &amp;lt;&amp;lt; 20);
int n, s;
int f[maxn], t[maxn], c[maxn];
inline int min(int x, int y) &amp;#123; return x &amp;lt; y ? x : y; &amp;#125;
#ifdef ONLINE_JUDGE
inline int nec(void) &amp;#123;
    static char buf[LEN], *p = buf, *e = buf;
    if (p == e) &amp;#123;
        e = buf + fread(buf, 1, LEN, stdin);
        if (e == buf) return EOF; p = buf;
    &amp;#125;
    return *p++;
&amp;#125;
#else
#define nec getchar
#endif
inline bool read(int &amp;amp;x) &amp;#123;
    char ch = nec();
    bool f = 0; x = 0;
    while (ch &amp;lt; &amp;#39;0&amp;#39; || ch &amp;gt; &amp;#39;9&amp;#39;) &amp;#123;
        if (ch == EOF) return 0;
        if (ch == &amp;#39;-&amp;#39;) f = 1;
        ch = nec();
    &amp;#125;
    while (ch &amp;gt;= &amp;#39;0&amp;#39; &amp;amp;&amp;amp; ch &amp;lt;= &amp;#39;9&amp;#39;) &amp;#123;
        x = x * 10 + ch - &amp;#39;0&amp;#39;;
        ch = nec();
    &amp;#125;
    if (f) x = -x;
    return 1;
&amp;#125;
signed main() &amp;#123;
    read(n); read(s);
    memset(f, 0x3f, sizeof (f));
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        read(t[i]); read(c[i]);
        t[i] += t[i - 1];
        c[i] += c[i - 1];
    &amp;#125;
    f[0] = 0;
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        for (int j = 0; j &amp;lt; i; ++j)
            f[i] = min(f[i], f[j] + t[i]* (c[i] - c[j]) + s * (c[n] - c[j]));
    &amp;#125;
    printf(&amp;quot;%lld&amp;quot;, f[n]);
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;任务安排-2&#34;&gt;&lt;a href=&#34;https://loj.ac/p/10185&#34;&gt;任务安排 2&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.acwing.com/problem/content/303/&#34;&gt;双倍经验&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt; 的范围变大了，&lt;span class=&#34;math inline&#34;&gt;\(n^2\)&lt;/span&gt; 过不了。&lt;/p&gt;
&lt;p&gt;这不随手加个斜率优化的事儿吗。&lt;/p&gt;
&lt;p&gt;我们继续瞎搞这个式子。 &lt;span class=&#34;math display&#34;&gt;\[
\begin{aligned}
f_i&amp;amp;=\min\{f_j+(c_i-c_j)\times t_i+s\times(c_n-c_j)\}
\\
&amp;amp;=\min\{f_j+c_i\times t_i-c_j\times t_i+s\times c_n-s\times c_j\}
\\
&amp;amp;=\min\{f_j-c_j\times t_i-s\times c_j\}+c_i\times t_i+s\times c_n
\end{aligned}
\]&lt;/span&gt; 令 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; 优于 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 且 &lt;span class=&#34;math inline&#34;&gt;\(j&amp;lt;k\)&lt;/span&gt; 。&lt;/p&gt;
&lt;p&gt;则有： &lt;span class=&#34;math display&#34;&gt;\[
f_j-c_j\times t_i-s\times c_j&amp;lt;f_k-c_k\times t_i-s\times c_k
\\
f_j-f_k-s\times c_j+s\times c_k&amp;lt;c_j\times t_i-c_k\times t_i
\\
f_j-f_k-s\times c_j+s\times c_k&amp;lt;t_i\times(c_j-c_k)
\\
\dfrac{(f_j-s\times c_j)-(f_k-s\times c_k)}{(c_j)-(c_k)}&amp;lt;t_i
\]&lt;/span&gt; 然后就是老套路。&lt;/p&gt;
&lt;p&gt;时间复杂度 &lt;span class=&#34;math inline&#34;&gt;\(\mathcal O(n)\)&lt;/span&gt;。&lt;/p&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;cstdio&amp;gt;
#define int long long
const int maxn = 5e5 + 5;
const int LEN = (1 &amp;lt;&amp;lt; 20);
int n, s, L, R;
int f[maxn], t[maxn], c[maxn], q[maxn];
#define nec getchar
inline bool read(int &amp;amp;x) &amp;#123;
    char ch = nec();
    bool f = 0; x = 0;
    while (ch &amp;lt; &amp;#39;0&amp;#39; || ch &amp;gt; &amp;#39;9&amp;#39;) &amp;#123;
        if (ch == EOF) return 0;
        if (ch == &amp;#39;-&amp;#39;) f = 1; ch = nec();
    &amp;#125;
    while (ch &amp;gt;= &amp;#39;0&amp;#39; &amp;amp;&amp;amp; ch &amp;lt;= &amp;#39;9&amp;#39;) &amp;#123;
        x = x * 10 + ch - &amp;#39;0&amp;#39;;
        ch = nec();
    &amp;#125;
    if (f) x = -x;
    return 1;
&amp;#125;
inline int getup(int j, int k) &amp;#123; return (f[j] - s * c[j]) - (f[k] - s * c[k]); &amp;#125;
inline int getdown(int j, int k) &amp;#123; return (c[j]) - (c[k]); &amp;#125;
inline int getDP(int i, int j) &amp;#123; return f[j] + (c[i] - c[j]) * t[i] + s * (c[n] - c[j]); &amp;#125;
signed main() &amp;#123;
    read(n); read(s);
    L = R = 1;
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        read(t[i]); read(c[i]);
        t[i] += t[i - 1];
        c[i] += c[i - 1];
    &amp;#125;
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        while (L &amp;lt; R &amp;amp;&amp;amp; getup(q[L + 1], q[L]) &amp;lt;= t[i] * getdown(q[L + 1], q[L]))
            ++L;
        f[i] = getDP(i, q[L]);
        while (L &amp;lt; R &amp;amp;&amp;amp; getup(i, q[R]) * getdown(q[R], q[R - 1]) &amp;lt;= getdown(i, q[R]) * getup(q[R], q[R - 1]))
            --R;
        q[++R] = i;
    &amp;#125;
    printf(&amp;quot;%lld&amp;quot;, f[n]);
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;任务安排-3&#34;&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P5785&#34;&gt;任务安排 3&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://loj.ac/p/10186&#34;&gt;双倍经验&lt;/a&gt; | &lt;a href=&#34;https://www.acwing.com/problem/content/304/&#34;&gt;三倍经验&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;注意 &lt;span class=&#34;math inline&#34;&gt;\(t\)&lt;/span&gt; 有可能是负数。&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(t\)&lt;/span&gt; （输入）有可能为负，代表着 &lt;span class=&#34;math inline&#34;&gt;\(t\)&lt;/span&gt;（前缀和）不再单调递增，用不单调的对象作为单调队列的条件一看就十分不讲武德，这样维护出来的队头显然不是正确答案。&lt;/p&gt;
&lt;p&gt;后面的 &lt;span class=&#34;math inline&#34;&gt;\(t,c\)&lt;/span&gt; 默认为前缀和。&lt;/p&gt;
&lt;p&gt;我们感性证明一下。&lt;/p&gt;
&lt;p&gt;一个最普通的例子，假设输入了一个负数，导致 &lt;span class=&#34;math inline&#34;&gt;\(t_i&amp;lt;t_{i-1}\)&lt;/span&gt;，且有一斜率 &lt;span class=&#34;math inline&#34;&gt;\(&amp;gt;t_i\)&lt;/span&gt; 且 &lt;span class=&#34;math inline&#34;&gt;\(&amp;lt;t_{i-1}\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;那么在 &lt;span class=&#34;math inline&#34;&gt;\(i-1\)&lt;/span&gt; 时，它就被维护队头的操作剔掉了，但也许它凑巧就是 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 的最优解，呜呼哀哉。&lt;/p&gt;
&lt;p&gt;于是我们不能删队头元素了。那怎么查询最优解呢？&lt;/p&gt;
&lt;p&gt;单调队列里装的始终还是个具有单调性的下凸包，于是我们可以在队列中二分一个 &lt;span class=&#34;math inline&#34;&gt;\(pos\)&lt;/span&gt;，&lt;span class=&#34;math inline&#34;&gt;\(pos\)&lt;/span&gt; 与 &lt;span class=&#34;math inline&#34;&gt;\(pos-1\)&lt;/span&gt; 形成的斜率比 &lt;span class=&#34;math inline&#34;&gt;\(t_i\)&lt;/span&gt; 小，&lt;span class=&#34;math inline&#34;&gt;\(pos+1\)&lt;/span&gt; 与 &lt;span class=&#34;math inline&#34;&gt;\(pos\)&lt;/span&gt; 形成的斜率比 &lt;span class=&#34;math inline&#34;&gt;\(t_i\)&lt;/span&gt; 大。&lt;/p&gt;
&lt;p&gt;然后把 &lt;span class=&#34;math inline&#34;&gt;\(pos\)&lt;/span&gt; 当成 &lt;span class=&#34;math inline&#34;&gt;\(q_l\)&lt;/span&gt; 来处理就好了。&lt;/p&gt;
&lt;p&gt;队尾还是维护一个下凸。&lt;/p&gt;
&lt;p&gt;时间复杂度 &lt;span class=&#34;math inline&#34;&gt;\(\mathcal O(n\log_2n)\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;强烈建议不要去动 AcWing 版本的那道。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;最后两组数据堪称毒瘤。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;卡 &lt;code&gt;long long&lt;/code&gt; 乘法，卡 &lt;code&gt;__int128&lt;/code&gt; 时限，卡 &lt;code&gt;double&lt;/code&gt;精度，非 T 即 WA。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;反正我搞了半个小时硬是没有搞出来。&lt;/em&gt;&lt;/p&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;cstdio&amp;gt;
#define int long long
const int maxn = 3e5 + 5;
const int LEN = (1 &amp;lt;&amp;lt; 20);
int n, s, L, R;
int f[maxn], t[maxn], c[maxn], q[maxn];
#define nec getchar
inline bool read(int &amp;amp;x) &amp;#123;
    char ch = nec();
    bool f = 0; x = 0;
    while (ch &amp;lt; &amp;#39;0&amp;#39; || ch &amp;gt; &amp;#39;9&amp;#39;) &amp;#123;
        if (ch == EOF) return 0;
        if (ch == &amp;#39;-&amp;#39;) f = 1; ch = nec();
    &amp;#125;
    while (ch &amp;gt;= &amp;#39;0&amp;#39; &amp;amp;&amp;amp; ch &amp;lt;= &amp;#39;9&amp;#39;) &amp;#123;
        x = x * 10 + ch - &amp;#39;0&amp;#39;;
        ch = nec();
    &amp;#125;
    if (f) x = -x;
    return 1;
&amp;#125;
inline int getup(int j, int k) &amp;#123; return (f[j] - s * c[j]) - (f[k] - s * c[k]); &amp;#125;
inline int getdown(int j, int k) &amp;#123; return (c[j]) - (c[k]); &amp;#125;
inline int getDP(int i, int j) &amp;#123; return f[j] + t[i] * (c[i] - c[j]) + s * (c[n] - c[j]); &amp;#125;
inline int Func(int u) &amp;#123;
    if (L == R) return q[L];
    int l = L, r = R;
    while (l &amp;lt; r) &amp;#123;
        int mid = l + r &amp;gt;&amp;gt; 1;
        if (getup(q[mid + 1], q[mid]) &amp;lt;= u * getdown(q[mid + 1], q[mid]))
            l = mid + 1;
        else r = mid;
    &amp;#125;
    return l;
&amp;#125;
signed main() &amp;#123;
    read(n); read(s);
    L = R = 1;
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        read(t[i]); read(c[i]);
        t[i] += t[i - 1];
        c[i] += c[i - 1];
    &amp;#125;
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        int Best = Func(t[i]);
        f[i] = getDP(i, q[Best]);
        while (L &amp;lt; R &amp;amp;&amp;amp; getup(i, q[R]) * getdown(q[R], q[R - 1]) &amp;lt;= getdown(i, q[R]) * getup(q[R], q[R - 1]))
            --R;
        q[++R] = i;
    &amp;#125;
    printf(&amp;quot;%lld&amp;quot;, f[n]);
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;土地购买&#34;&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P2900&#34;&gt;土地购买&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;首先我们想明白一件事情：如果一块土地，有另一块土地的长和宽都比它大，那就不用再理它了，直接从总序列里剔除。&lt;/p&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;struct _ &amp;#123;
    int w, l;
    bool operator&amp;lt; (const _ q) const &amp;#123;
        return w == q.w ? l &amp;gt; q.l : w &amp;gt; q.w;
    &amp;#125;
&amp;#125; a[maxn];
...

std::sort(a + 1, a + n + 1);
for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
    if (a[i].l &amp;gt; a[cnt].l)
        a[++cnt] = a[i];
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后就推式子。&lt;/p&gt;
&lt;p&gt;贪心地想，在前面的操作后，&lt;span class=&#34;math inline&#34;&gt;\(a\)&lt;/span&gt; 是一个 &lt;span class=&#34;math inline&#34;&gt;\(w\)&lt;/span&gt; 递减，&lt;span class=&#34;math inline&#34;&gt;\(l\)&lt;/span&gt; 递增的土地序列。&lt;/p&gt;
&lt;p&gt;所以我们选择将连续的一段区间分为一组，这样的话，一个组里的一段连续的土地 &lt;span class=&#34;math inline&#34;&gt;\([x,y]\)&lt;/span&gt; 就只有 &lt;span class=&#34;math inline&#34;&gt;\(w_x\)&lt;/span&gt; 和 &lt;span class=&#34;math inline&#34;&gt;\(l_y\)&lt;/span&gt; 起了作用，又没有中间那一段的事了。&lt;/p&gt;
&lt;p&gt;设 &lt;span class=&#34;math inline&#34;&gt;\(f_i\)&lt;/span&gt; 表示分配完第 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 块土地后的最小花费。&lt;/p&gt;
&lt;p&gt;则有： &lt;span class=&#34;math display&#34;&gt;\[
f_i=\min\{f_j+w_{j+1}\times l_i\}
\]&lt;/span&gt; 令 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; 优于 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;则有： &lt;span class=&#34;math display&#34;&gt;\[
f_j+w_{j+1}\times l_i&amp;lt;f_k+w_{k+1}\times l_i
\\
f_j-f_k&amp;lt;(-w_{j+1}+w_{k+1})\times l_i
\\
\dfrac{(f_j)-(f_k)}{(-w_{j+1})+(w_{k+1})}&amp;lt;l_i
\]&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;cstdio&amp;gt;
#include &amp;lt;algorithm&amp;gt;
#define int long long
const int maxn = 5e4 + 5;
struct _ &amp;#123;
    int w, l;
    bool operator&amp;lt; (const _ q) const&amp;#123;
        return w == q.w ? l &amp;gt; q.l : w &amp;gt; q.w;
    &amp;#125;
&amp;#125;;
_ a[maxn];
int n, cnt, l, r;
int q[maxn], f[maxn];
int getup(int j, int k) &amp;#123; return f[j] - f[k]; &amp;#125;
int getdown(int j,int k) &amp;#123; return a[k + 1].w - a[j + 1].w; &amp;#125;
int getDP(int i,int j) &amp;#123; return f[j] + a[j + 1].w * a[i].l; &amp;#125;
signed main() &amp;#123;
    scanf(&amp;quot;%lld&amp;quot;, &amp;amp;n);
    for(int i = 1; i &amp;lt;= n; ++i)
        scanf(&amp;quot;%lld %lld&amp;quot;, &amp;amp;a[i].w, &amp;amp;a[i].l);
    std::sort(a + 1, a + n + 1);
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        if (a[i].l &amp;gt; a[cnt].l)
            a[++cnt] = a[i];
    &amp;#125;
    n = cnt; l = r = 1;
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        while (l &amp;lt; r &amp;amp;&amp;amp; getup(q[l + 1], q[l]) &amp;lt;= a[i].l * getdown(q[l + 1], q[l]))
            l++;
        f[i] = getDP(i, q[l]);
        while (l &amp;lt; r &amp;amp;&amp;amp; getup(i, q[r]) * getdown(q[r], q[r - 1]) &amp;lt;= getup(q[r],q[r - 1]) * getdown(i, q[r]))
            r--;
        q[++r] = i;
    &amp;#125;
    printf(&amp;quot;%lld&amp;quot;, f[n]);
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;仓库建设&#34;&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P2120&#34;&gt;仓库建设&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://loj.ac/p/10189&#34;&gt;双倍经验&lt;/a&gt; | &lt;a href=&#34;https://www.acwing.com/problem/content/description/1095/&#34;&gt;三倍经验&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;设 &lt;span class=&#34;math inline&#34;&gt;\(f_i\)&lt;/span&gt; 表示在 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 工厂建立仓库的最小花费。&lt;/p&gt;
&lt;p&gt;则有： &lt;span class=&#34;math display&#34;&gt;\[
\begin{aligned}
f_i&amp;amp;=\min\{f_j+\sum\limits_{k=j+1}^{i-1}[(x_i-x_k)\times p_k]+c_i\}
\\
&amp;amp;=\min\{f_j+\sum\limits_{k=j+1}^{i-1}(x_i\times p_k)-\sum\limits_{k=j+1}^{i-1}(x_k\times p_k)\}+c_i
\\
&amp;amp;=\min\{f_j+x_i\times\sum\limits_{k=j+1}^{i-1}p_k-\sum\limits_{k=j+1}^{i-1}(x_k\times p_k)\}+c_i
\end{aligned}
\]&lt;/span&gt; 利用前缀和优化：设 &lt;span class=&#34;math inline&#34;&gt;\(a\)&lt;/span&gt; 为 &lt;span class=&#34;math inline&#34;&gt;\(p\)&lt;/span&gt; 的前缀和数组，&lt;span class=&#34;math inline&#34;&gt;\(b\)&lt;/span&gt; 为 &lt;span class=&#34;math inline&#34;&gt;\(x_i\times p_i\)&lt;/span&gt; 的前缀和数组。&lt;/p&gt;
&lt;p&gt;则原式可化为： &lt;span class=&#34;math display&#34;&gt;\[
\begin{aligned}
f_i&amp;amp;=\min\{f_j+x_i\times(a_{i-1}-a_j)-(b_{i-1}-b_j)\}+c_i
\\
&amp;amp;=\min\{f_j+x_i\times a_{i-1}-x_i\times a_j-b_{i-1}+b_j\}+c_i
\\
&amp;amp;=\min\{f_j-x_i\times a_j+b_j\}+x_i\times a_{i-1}-b_{i-1}+c_i
\end{aligned}
\]&lt;/span&gt; 令 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; 优于 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 。&lt;/p&gt;
&lt;p&gt;则有： &lt;span class=&#34;math display&#34;&gt;\[
f_j-x_i\times a_j+b_j&amp;lt;f_k-x_i\times a_k+b_k
\\
f_j-f_k+b_j-b_k&amp;lt;x_i\times a_j-x_i\times a_k
\\
\dfrac{(f_j+b_j)-(f_k+b_k)}{a_j-a_k}&amp;lt;x_i
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;想感受人生的同学们可以尝试做一下 AcWing 那个版本，非 MLE 即 WA，爽到炸。&lt;/em&gt;&lt;/p&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;cstdio&amp;gt;
#define int long long
const int maxn = 1e6 + 5;
const int LEN = (1 &amp;lt;&amp;lt; 20);
int n, L, R;
int f[maxn], x[maxn], p[maxn];
int a[maxn], b[maxn], c[maxn], q[maxn];
#ifdef ONLINE_JUDGE
inline int nec(void) &amp;#123;
    static char buf[LEN], *p = buf, *e = buf;
    if (p == e) &amp;#123;
        e = buf + fread(buf, 1, LEN, stdin);
        if (e == buf) return EOF; p = buf;
    &amp;#125;
    return *p++;
&amp;#125;
#else
#define nec getchar
#endif
inline bool read(int &amp;amp;x) &amp;#123;
    char ch = nec();
    bool f = 0; x = 0;
    while (ch &amp;lt; &amp;#39;0&amp;#39; || ch &amp;gt; &amp;#39;9&amp;#39;) &amp;#123;
        if (ch == EOF) return 0;
        if (ch == &amp;#39;-&amp;#39;) f = 1;
        ch = nec();
    &amp;#125;
    while (ch &amp;gt;= &amp;#39;0&amp;#39; &amp;amp;&amp;amp; ch &amp;lt;= &amp;#39;9&amp;#39;) &amp;#123;
        x = x * 10 + ch - &amp;#39;0&amp;#39;;
        ch = nec();
    &amp;#125;
    if (f) x = -x;
    return 1;
&amp;#125;
inline int getup(int j, int k) &amp;#123; return (f[j] + b[j]) - (f[k] + b[k]); &amp;#125;
inline int getdown(int j, int k) &amp;#123; return (a[j]) - (a[k]); &amp;#125;
inline int getDP(int i, int j) &amp;#123; return f[j] - x[i] * a[j] + b[j] + x[i] * a[i - 1] - b[i - 1] + c[i]; &amp;#125;
signed main() &amp;#123;
    read(n); L = R = 1;
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        read(x[i]); read(p[i]); read(c[i]);
        a[i] = a[i - 1] + p[i];
        b[i] = b[i - 1] + x[i] * p[i];
    &amp;#125;
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        while (L &amp;lt; R &amp;amp;&amp;amp; getup(q[L + 1], q[L]) &amp;lt;= x[i] * getdown(q[L + 1], q[L]))
            ++L;
        f[i] = getDP(i, q[L]);
        while (L &amp;lt; R &amp;amp;&amp;amp; getup(i, q[R]) * getdown(q[R], q[R - 1]) &amp;lt;= getdown(i, q[R]) * getup(q[R], q[R - 1]))
            --R;
        q[++R] = i;
    &amp;#125;
    printf(&amp;quot;%lld&amp;quot;, f[n]);
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;锯木厂选址&#34;&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P4360&#34;&gt;锯木厂选址&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://loj.ac/p/10192&#34;&gt;双倍经验&lt;/a&gt; | &lt;a href=&#34;https://www.acwing.com/problem/content/1097/&#34;&gt;三倍经验&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;和仓库建设很像。&lt;/p&gt;
&lt;p&gt;设 &lt;span class=&#34;math inline&#34;&gt;\(A_i=\sum\limits_{j=i}^nd_j\)&lt;/span&gt;，表示第 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 棵树与山脚的距离；&lt;span class=&#34;math inline&#34;&gt;\(B_i=\sum\limits_{j=1}^iw_j\)&lt;/span&gt;，表示 &lt;span class=&#34;math inline&#34;&gt;\(w\)&lt;/span&gt; 的前缀和；&lt;span class=&#34;math inline&#34;&gt;\(S=\sum\limits_{i=1}^nA_i\times w_i\)&lt;/span&gt;，表示将所有树全部运到山脚的花费总和。&lt;/p&gt;
&lt;p&gt;假设在 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; 处建立第 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt; 座锯木厂，在 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 处建立第 &lt;span class=&#34;math inline&#34;&gt;\(2\)&lt;/span&gt; 座锯木厂，此时：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于第 &lt;span class=&#34;math inline&#34;&gt;\(1\sim j\)&lt;/span&gt; 棵树来说，&lt;span class=&#34;math inline&#34;&gt;\(S\)&lt;/span&gt; 比实际情况多运了 &lt;span class=&#34;math inline&#34;&gt;\(A_j\)&lt;/span&gt; 的路程；&lt;/li&gt;
&lt;li&gt;对于第 &lt;span class=&#34;math inline&#34;&gt;\(j+1\sim i\)&lt;/span&gt; 棵树来说，&lt;span class=&#34;math inline&#34;&gt;\(S\)&lt;/span&gt; 比实际情况多运了 &lt;span class=&#34;math inline&#34;&gt;\(A_i\)&lt;/span&gt; 的路程。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;将对应的多运的距离与花费相乘的结果，让 &lt;span class=&#34;math inline&#34;&gt;\(S\)&lt;/span&gt; 将其减去即可。 &lt;span class=&#34;math display&#34;&gt;\[
\begin{aligned}
ans&amp;amp;=\min\{S-A_j\times B_j-(B_i-B_j)\times A_i\}\\
   &amp;amp;=\min\{A_i\times B_j-A_j\times B_j\}+S-A_i\times B_i
\end{aligned}
\]&lt;/span&gt; 令 &lt;span class=&#34;math inline&#34;&gt;\(j&amp;lt;k\)&lt;/span&gt; 且 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; 优于 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt;，则有： &lt;span class=&#34;math display&#34;&gt;\[
\begin{aligned}
A_i\times B_j-A_j\times B_j&amp;amp;&amp;lt;A_i\times B_k-A_k\times B_k\\
-A_j\times B_j+A_k\times B_k&amp;amp;&amp;lt;-A_i\times B_j+A_i\times B_k\\
\dfrac{-A_j\times B_j+A_k\times B_k}{-B_j+B_k}&amp;amp;&amp;lt;A_i\\
\dfrac{A_j\times B_j-A_k\times B_k}{B_j-B_k}&amp;amp;&amp;lt;A_i\\
\end{aligned}
\]&lt;/span&gt; 其中，&lt;span class=&#34;math inline&#34;&gt;\(A_i\)&lt;/span&gt; 具有单调性，可以直接套板子。&lt;/p&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;cstdio&amp;gt;
#include &amp;lt;cstring&amp;gt;
#include &amp;lt;algorithm&amp;gt;
#define int long long
const int inf = 1e18;
const int maxn = 1e6 + 5;
const int LEN = (1 &amp;lt;&amp;lt; 20);
int w[maxn], d[maxn];
int n, L, R, s, ans = inf;
int q[maxn], a[maxn], b[maxn];
inline int min(int x, int y) &amp;#123; return x &amp;lt; y ? x : y; &amp;#125;
inline int getDP(int i, int j) &amp;#123;
    return s - a[j] * b[j] - (b[i] - b[j]) * a[i];
&amp;#125;
inline int getup(int j, int k) &amp;#123;
    return a[j] * b[j] - a[k] * b[k];
&amp;#125;
inline int getdown(int j, int k) &amp;#123;
    return b[j] - b[k];
&amp;#125;
#ifdef ONLINE_JUDGE
inline int nec(void) &amp;#123;
    static char buf[LEN], *p = buf, *e = buf;
    if (p == e) &amp;#123;
        e = buf + fread(buf, 1, LEN, stdin);
        if (e == buf) return EOF; p = buf;
    &amp;#125;
    return *p++;
&amp;#125;
#else
#define nec getchar
#endif
inline bool read(int &amp;amp;x) &amp;#123;
    char ch = nec();
    bool f = 0; x = 0;
    while (ch &amp;lt; &amp;#39;0&amp;#39; || ch &amp;gt; &amp;#39;9&amp;#39;) &amp;#123;
        if (ch == EOF) return 0;
        if (ch == &amp;#39;-&amp;#39;) f = 1;
        ch = nec();
    &amp;#125;
    while (ch &amp;gt;= &amp;#39;0&amp;#39; &amp;amp;&amp;amp; ch &amp;lt;= &amp;#39;9&amp;#39;) &amp;#123;
        x = x * 10 + ch - &amp;#39;0&amp;#39;;
        ch = nec();
    &amp;#125;
    if (f) x = -x;
    return 1;
&amp;#125;
signed main() &amp;#123;
    read(n);
    L = R = 1;
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        read(w[i]), read(d[i]);
        b[i] = b[i - 1] + w[i];
    &amp;#125;
    for (int i = n; i; --i) &amp;#123;
        a[i] = a[i + 1] + d[i];
        s += a[i] * w[i];
    &amp;#125;
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        while (L &amp;lt; R &amp;amp;&amp;amp; getup(q[L + 1], q[L]) &amp;gt;= a[i] * getdown(q[L + 1], q[L]))
            ++L;
        ans = min(ans, getDP(i, q[L]));
        while (L &amp;lt; R &amp;amp;&amp;amp; getup(i, q[R]) * getdown(q[R], q[R - 1]) &amp;gt;= getup(q[R], q[R - 1]) * getdown(i, q[R]))
            --R;
        q[++R] = i;
    &amp;#125;
    printf(&amp;quot;%lld&amp;quot;, ans);
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;cats-transport&#34;&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/CF311B&#34;&gt;Cats Transport&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.acwing.com/problem/content/305/&#34;&gt;双倍经验&lt;/a&gt; | &lt;a href=&#34;http://codeforces.com/problemset/problem/311/B&#34;&gt;三倍经验&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;经验：洛谷的题面比蓝书和 AcWing 上的标准多了，蓝书的题意不清。&lt;/p&gt;
&lt;p&gt;研究表明，边猛灌养乐多边看蓝书有助于理解。&lt;/p&gt;
&lt;p&gt;这道题难在推式子。&lt;del&gt;不然还能难在哪里&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;设 &lt;span class=&#34;math inline&#34;&gt;\(A_i\)&lt;/span&gt; 表示要接到第 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 只猫的最早出发时间，也就是说，在此时出发，猫 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 的等待时间为 &lt;span class=&#34;math inline&#34;&gt;\(0\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;即 &lt;span class=&#34;math inline&#34;&gt;\(A_i=T_i-\sum\limits_{j=1}^{H_i}D_j\)&lt;/span&gt;，也就是出发时间=到达时间-经过时间。&lt;/p&gt;
&lt;p&gt;此时我们可以把其他所有因素去掉，题意转换为：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;已知在 &lt;span class=&#34;math inline&#34;&gt;\(\geqslant A_i\)&lt;/span&gt; 的时刻出发可以接到猫 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; ，在 &lt;span class=&#34;math inline&#34;&gt;\(P\)&lt;/span&gt; 次出发次数的限制内接到所有猫，猫的等待时间之和最小是多少？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;假设饲养员在 &lt;span class=&#34;math inline&#34;&gt;\(t\)&lt;/span&gt; 时刻出发，猫 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 的等待时间就是 &lt;span class=&#34;math inline&#34;&gt;\(t-A_i\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;对 &lt;span class=&#34;math inline&#34;&gt;\(A_i\)&lt;/span&gt; 从小到大排序。&lt;/p&gt;
&lt;p&gt;显然，一次接一段连续的猫，花费自然是最小的。&lt;/p&gt;
&lt;p&gt;若我们要接 &lt;span class=&#34;math inline&#34;&gt;\([k+1,j]\)&lt;/span&gt; 范围内的猫，它们的等待时间之和就是： &lt;span class=&#34;math display&#34;&gt;\[
\begin{aligned}
\sum\limits_{p=k+1}^{j}(A_j-A_p)&amp;amp;=[j-(k+1)+1]A_j-\sum\limits_{p=k+1}^{j}A_p
\\
&amp;amp;=(j-k)\times A_j-(S_j-S_k)
\\
&amp;amp;=j\times A_j-k\times A_j-S_j+S_k
\end{aligned}
\]&lt;/span&gt; 其中 &lt;span class=&#34;math inline&#34;&gt;\(S\)&lt;/span&gt; 为 &lt;span class=&#34;math inline&#34;&gt;\(A\)&lt;/span&gt; 的前缀和。&lt;/p&gt;
&lt;p&gt;设 &lt;span class=&#34;math inline&#34;&gt;\(f_{i,j}\)&lt;/span&gt; 表示前 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 个饲养员带走前 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; 只猫的最小花费。&lt;/p&gt;
&lt;p&gt;则有： &lt;span class=&#34;math display&#34;&gt;\[
\begin{aligned}
f_{i,j}&amp;amp;=\min\{f_{i-1,k}+j\times A_j-k\times A_j-S_j+S_k\}
\\
&amp;amp;=\min\{f_{i-1,k}-A_j\times k+S_k\}+A_j\times j-S_j
\end{aligned}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;我们将循环地枚举每个饲养员的循环变量 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 看做常量。&lt;/p&gt;
&lt;p&gt;令 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 优于 &lt;span class=&#34;math inline&#34;&gt;\(y\)&lt;/span&gt;，则有： &lt;span class=&#34;math display&#34;&gt;\[
f_{i-1,x}-A_j\times x+S_x&amp;lt;f_{i-1,y}-A_j\times y+S_y
\\
\dfrac{(f_{i-1,x}+S_x)-(f_{i-1,y+S_y})}{x-y}&amp;lt;A_j
\]&lt;/span&gt; &lt;strong&gt;注意事项&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(f\)&lt;/span&gt; 初始化为极大值。&lt;/p&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;cstdio&amp;gt;
#include &amp;lt;cstring&amp;gt;
#include &amp;lt;algorithm&amp;gt;
#define int long long
const int maxp = 105;
const int maxn = 1e5 + 5;
const int LEN = (1 &amp;lt;&amp;lt; 20);
int f[maxp][maxn];
int n, m, p, L, R, t, h;
int q[maxn], a[maxn], d[maxn], s[maxn];
inline int getDP(int i, int j, int k) &amp;#123;
    return f[i - 1][k] + (j - k) * a[j] - (s[j] - s[k]);
&amp;#125;
inline int getup(int i, int j, int k) &amp;#123;
    return (f[i - 1][j] + s[j]) - (f[i - 1][k] + s[k]);
&amp;#125;
inline int getdown(int j, int k) &amp;#123;
    return (j) - (k);
&amp;#125;
#ifdef ONLINE_JUDGE
inline int nec(void) &amp;#123;
    static char buf[LEN], *p = buf, *e = buf;
    if (p == e) &amp;#123;
        e = buf + fread(buf, 1, LEN, stdin);
        if (e == buf) return EOF; p = buf;
    &amp;#125;
    return *p++;
&amp;#125;
#else
#define nec getchar
#endif
inline bool read(int &amp;amp;x) &amp;#123;
    char ch = nec();
    bool f = 0; x = 0;
    while (ch &amp;lt; &amp;#39;0&amp;#39; || ch &amp;gt; &amp;#39;9&amp;#39;) &amp;#123;
        if (ch == EOF) return 0;
        if (ch == &amp;#39;-&amp;#39;) f = 1;
        ch = nec();
    &amp;#125;
    while (ch &amp;gt;= &amp;#39;0&amp;#39; &amp;amp;&amp;amp; ch &amp;lt;= &amp;#39;9&amp;#39;) &amp;#123;
        x = x * 10 + ch - &amp;#39;0&amp;#39;;
        ch = nec();
    &amp;#125;
    if (f) x = -x;
    return 1;
&amp;#125;
signed main() &amp;#123;
    read(n); read(m); read(p);
    memset(f, 0x3f, sizeof (f));
    for (int i = 2; i &amp;lt;= n; ++i)
        read(d[i]), d[i] += d[i - 1];
    for (int i = 1; i &amp;lt;= m; ++i) &amp;#123;
        read(h); read(t);
        a[i] = t - d[h];
    &amp;#125;
    std::sort(a + 1, a + m + 1);
    for (int i = 1; i &amp;lt;= m; ++i)
        s[i] = s[i - 1] + a[i];
    f[0][0] = 0;
    for (int i = 1; i &amp;lt;= p; ++i) &amp;#123;
        L = R = 1;
        for (int j = 1; j &amp;lt;= m; ++j) &amp;#123;
            while (L &amp;lt; R &amp;amp;&amp;amp; getup(i, q[L + 1], q[L]) &amp;lt;= a[j] * getdown(q[L + 1], q[L]))
                ++L;
            f[i][j] = getDP(i, j, q[L]);
            while (L &amp;lt; R &amp;amp;&amp;amp; getup(i, j, q[R]) * getdown(q[R], q[R - 1]) &amp;lt;= getup(i, q[R], q[R - 1]) * getdown(j, q[R]))
                --R;
            q[++R] = j;
        &amp;#125;
    &amp;#125;
    printf(&amp;quot;%lld&amp;quot;, f[p][m]);
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;特别行动队&#34;&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P3628&#34;&gt;特别行动队&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.acwing.com/problem/content/337/&#34;&gt;双倍经验&lt;/a&gt; | &lt;a href=&#34;https://loj.ac/p/10190&#34;&gt;三倍经验&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;直接推式子。 &lt;span class=&#34;math display&#34;&gt;\[
\begin{aligned}
f_i&amp;amp;=\max\{f_j+a\times(s_i-s_j)^2+b\times(s_i-s_j)+c\ \}\\
&amp;amp;=\max\{f_j+a\times({s_i}^2-2\times s_i\times s_j+{s_j}^2)+b\times s_i-b\times s_j\ \}+c\\
&amp;amp;=\max\{f_j+a\times{s_i}^2-2\times a\times s_i\times s_j+a\times{s_j}^2-b\times s_j\ \}+b\times s_i+c\\
&amp;amp;=\max\{f_j-2\times a\times s_i\times s_j+a\times{s_j}^2-b\times s_j\ \}+a\times{s_i}^2+b\times s_i+c\\
\end{aligned}
\]&lt;/span&gt; 令 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; 优于 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt;，则有： &lt;span class=&#34;math display&#34;&gt;\[
\begin{aligned}
f_j-2\times a\times s_i\times s_j+a\times{s_j}^2-b\times s_j&amp;amp;&amp;gt;f_k-2\times a\times s_i\times s_k+a\times{s_k}^2-b\times s_k\\
(f_j+a\times{s_j}^2-b\times s_j)-(f_k+a\times{s_k}^2-b\times s_k)&amp;amp;&amp;gt;(2\times a\times s_i\times s_j)-(2\times a\times s_i\times s_k)\\
\dfrac{(f_j+a\times{s_j}^2-b\times s_j)-(f_k+a\times{s_k}^2-b\times s_k)}{(2\times a\times s_j) - (2\times a\times s_k)}&amp;amp;&amp;gt;s_i\\
\end{aligned}
\]&lt;/span&gt; 我们发现中间的符号是 &lt;span class=&#34;math inline&#34;&gt;\(&amp;gt;\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;所以我们在弹队头的时候，要把判断条件中的符号反过来。&lt;/p&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;cstdio&amp;gt;
#include &amp;lt;cstring&amp;gt;
#include &amp;lt;algorithm&amp;gt;
#define int long long
const int maxn = 1e6 + 5;
const int LEN = (1 &amp;lt;&amp;lt; 20);
int n, L, R, a, b ,c;
int q[maxn], s[maxn], f[maxn];
inline int getDP(int i, int j) &amp;#123;
    return f[j] + a * (s[i] - s[j]) * (s[i] - s[j]) + b * (s[i] - s[j]) + c;
&amp;#125;
inline int getup(int j, int k) &amp;#123;
    return (f[j] + a * s[j] * s[j] - b * s[j]) - (f[k] + a * s[k] * s[k] - b * s[k]);
&amp;#125;
inline int getdown(int j, int k) &amp;#123;
    return (2 * a * s[j]) - (2 * a * s[k]);
&amp;#125;
#ifdef ONLINE_JUDGE
inline int nec(void) &amp;#123;
    static char buf[LEN], *p = buf, *e = buf;
    if (p == e) &amp;#123;
        e = buf + fread(buf, 1, LEN, stdin);
        if (e == buf) return EOF; p = buf;
    &amp;#125;
    return *p++;
&amp;#125;
#else
#define nec getchar
#endif
inline bool read(int &amp;amp;x) &amp;#123;
    char ch = nec();
    bool f = 0; x = 0;
    while (ch &amp;lt; &amp;#39;0&amp;#39; || ch &amp;gt; &amp;#39;9&amp;#39;) &amp;#123;
        if (ch == EOF) return 0;
        if (ch == &amp;#39;-&amp;#39;) f = 1;
        ch = nec();
    &amp;#125;
    while (ch &amp;gt;= &amp;#39;0&amp;#39; &amp;amp;&amp;amp; ch &amp;lt;= &amp;#39;9&amp;#39;) &amp;#123;
        x = x * 10 + ch - &amp;#39;0&amp;#39;;
        ch = nec();
    &amp;#125;
    if (f) x = -x;
    return 1;
&amp;#125;
signed main() &amp;#123;
    read(n); read(a); read(b); read(c);
    L = R = 1;
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        read(s[i]), s[i] += s[i - 1];
        while (L &amp;lt; R &amp;amp;&amp;amp; getup(q[L + 1], q[L]) &amp;gt;= s[i] * getdown(q[L + 1], q[L]))
            ++L;
        f[i] = getDP(i, q[L]);
        while (L &amp;lt; R &amp;amp;&amp;amp; getup(i, q[R]) * getdown(q[R], q[R - 1]) &amp;lt;= getup(q[R], q[R - 1]) * getdown(i, q[R]))
            --R;
        q[++R] = i;
    &amp;#125;
    printf(&amp;quot;%lld&amp;quot;, f[n]);
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;征途&#34;&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P4072&#34;&gt;征途&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://loj.ac/p/2035&#34;&gt;双倍经验&lt;/a&gt; | &lt;a href=&#34;https://www.acwing.com/problem/content/2575/&#34;&gt;三倍经验&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;明显，不化掉 &lt;span class=&#34;math inline&#34;&gt;\(v\times m^2\)&lt;/span&gt; 就无法进行优化。&lt;/p&gt;
&lt;p&gt;设 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 为当前休息站点与上一休息站点的距离， &lt;span class=&#34;math inline&#34;&gt;\(x_0\)&lt;/span&gt; 为 &lt;span class=&#34;math inline&#34;&gt;\(x_1\sim x_n\)&lt;/span&gt; 的平均数，&lt;span class=&#34;math inline&#34;&gt;\(S\)&lt;/span&gt; 为 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 的前缀和。 &lt;span class=&#34;math display&#34;&gt;\[
\begin{aligned}
V\times m^2&amp;amp;=[(x_1-x_0)^2+(x_2-x_0)^2+\cdots+(x_m-x_0)^2]\times m
\\
&amp;amp;=m\times \sum\limits_{i=1}^{m}{x_i}^2+(m\times {x_0})^2-2\times (x_0\times m)\times \sum\limits_{i=1}^{m}x_i
\\
&amp;amp;=m\times \sum\limits_{i=1}^{m}{x_i}^2+{S_m}^2-2\times{S_m}^2
\\
&amp;amp;=m\times \sum\limits_{i=1}^{m}{x_i}^2-{S_m}^2
\end{aligned}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其中 &lt;span class=&#34;math inline&#34;&gt;\(S_m\)&lt;/span&gt; 是一个定值（即输入所有路的长度和）。&lt;/p&gt;
&lt;p&gt;唯一需要计算的，就是 &lt;span class=&#34;math inline&#34;&gt;\(\sum\limits_{i=1}^{m}{x_i}^{2}\)&lt;/span&gt;，所以我们就来 DP 它。&lt;/p&gt;
&lt;p&gt;设 &lt;span class=&#34;math inline&#34;&gt;\(a\)&lt;/span&gt; 为输入道路长度的前缀和数组，&lt;span class=&#34;math inline&#34;&gt;\(f_{i,j}\)&lt;/span&gt; 表示第 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 次休息在 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; 处时 &lt;span class=&#34;math inline&#34;&gt;\(\min\{\sum\limits_{k=1}^{i}{x_k}^2\}\)&lt;/span&gt; 的值，则有： &lt;span class=&#34;math display&#34;&gt;\[
\begin{aligned}
f_{i,j}&amp;amp;=\min\{f_{i-1,j}+(a_i-a_j)^2\}
\\
&amp;amp;=\min\{f_{i-1,j}+{a_i}^2-2\times a_i\times a_j+{a_j}^2\}
\end{aligned}
\]&lt;/span&gt; 令 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; 优于 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt;，则有： &lt;span class=&#34;math display&#34;&gt;\[
f_{i-1,j}-2\times a_i\times a_j+{a_j}^2&amp;lt;f_{i-1,k}-2\times a_i\times a_k+{a_k}^2
\\
f_{i-1,j}-f_{i-1,k}+{a_j}^2-{a_k}^2&amp;lt;2\times a_i\times(a_j-a_k)
\\
\dfrac{f_{i-1,j}-f_{i-1,k}+{a_j}^2-{a_k}^2}{2\times(a_j-a_k)}&amp;lt;a_i
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;初始化。&lt;/p&gt;
&lt;p&gt;将 &lt;span class=&#34;math inline&#34;&gt;\(f\)&lt;/span&gt; 初始化为极大值。&lt;/p&gt;
&lt;p&gt;在 AcWing 上将 &lt;code&gt;memset&lt;/code&gt; 改为初始化 &lt;code&gt;f[0][i] = a[i] * a[i]&lt;/code&gt; 就可以过了，不然会 MLE，也许是因为没开滚动。（本来也用不着滚&lt;/p&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;cstdio&amp;gt;
#define int long long
const int inf = 1e18;
const int maxn = 3005;
const int LEN = (1 &amp;lt;&amp;lt; 20);
int f[maxn][maxn];
int a[maxn], q[maxn];
int n, m, L, R, ans = inf;
#ifdef ONLINE_JUDGE
inline int nec(void) &amp;#123;
    static char buf[LEN], *p = buf, *e = buf;
    if (p == e) &amp;#123;
        e = buf + fread(buf, 1, LEN, stdin);
        if (e == buf) return EOF; p = buf;
    &amp;#125;
    return *p++;
&amp;#125;
#else
#define nec getchar
#endif
inline bool read(int &amp;amp;x) &amp;#123;
    char ch = nec();
    bool f = 0; x = 0;
    while (ch &amp;lt; &amp;#39;0&amp;#39; || ch &amp;gt; &amp;#39;9&amp;#39;) &amp;#123;
        if (ch == EOF) return 0;
        if (ch == &amp;#39;-&amp;#39;) f = 1;
        ch = nec();
    &amp;#125;
    while (ch &amp;gt;= &amp;#39;0&amp;#39; &amp;amp;&amp;amp; ch &amp;lt;= &amp;#39;9&amp;#39;) &amp;#123;
        x = x * 10 + ch - &amp;#39;0&amp;#39;;
        ch = nec();
    &amp;#125;
    if (f) x = -x;
    return 1;
&amp;#125;
inline int min(int x, int y) &amp;#123; return x &amp;lt; y ? x : y; &amp;#125;
int getDP(int i, int j, int k) &amp;#123;
    return f[k - 1][j] + (a[i] - a[j]) * (a[i] - a[j]);
&amp;#125;
int getup(int j, int k, int i) &amp;#123;
    return f[i - 1][j] - f[i - 1][k] + a[j] * a[j] - a[k] * a[k];
&amp;#125;
int getdown(int j, int k) &amp;#123;
    return (a[j] - a[k]) &amp;lt;&amp;lt; 1;
&amp;#125;
signed main()&amp;#123;
    read(n); read(m);
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        read(a[i]);
        a[i] += a[i - 1];
        f[0][i] = a[i] * a[i];
    &amp;#125;
    for (int i = 1; i &amp;lt; m; ++i) &amp;#123;
        L = R = 1; q[L] = i;
        for (int j = i; j &amp;lt;= n; ++j) &amp;#123;
            while (L &amp;lt; R &amp;amp;&amp;amp; getup(q[L + 1], q[L], i) &amp;lt;= a[j] * getdown(q[L + 1], q[L]))
                ++L;
            f[i][j] = getDP(j, q[L], i);
            while (L &amp;lt; R &amp;amp;&amp;amp; getup(i, q[R], i) * getdown(q[R], q[R - 1]) &amp;lt;= getup(q[R], q[R - 1], i) * getdown(i, q[R]))
                --R;
            q[++R] = j;
        &amp;#125;
    &amp;#125;
    printf(&amp;quot;%lld&amp;quot;,m * f[m - 1][n] - a[n] * a[n]);
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;柠檬&#34;&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P5504&#34;&gt;柠檬&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.acwing.com/problem/content/2396/&#34;&gt;双倍经验&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;是边写这篇题解边做的（&lt;/p&gt;
&lt;p&gt;题意：&lt;/p&gt;
&lt;p&gt;有一个含有 &lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt; 个元素的序列 &lt;span class=&#34;math inline&#34;&gt;\(s\)&lt;/span&gt;。将这个序列分成连续的若干段，定义每一段的价值为「在这一段当中任选某个元素的个数的平方再乘上这个元素」的最大值。求将 &lt;span class=&#34;math inline&#34;&gt;\(s\)&lt;/span&gt; 划分后的最大价值。&lt;/p&gt;
&lt;p&gt;不难想到分成的每一段首尾元素必须相等。&lt;/p&gt;
&lt;p&gt;比如有这样一个序列 &lt;span class=&#34;math inline&#34;&gt;\(x,a_1,a_2,a_3,\cdots,a_k,x,y\)&lt;/span&gt; 。假设我们求的是这一段包含 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 的个数的平方，那么完全可以将 &lt;span class=&#34;math inline&#34;&gt;\(y\)&lt;/span&gt; 从这一段中分离，单独为一段，明显更优。&lt;/p&gt;
&lt;p&gt;而其他所有情况都是这种情况的拓展。&lt;/p&gt;
&lt;p&gt;于是得到式子： &lt;span class=&#34;math display&#34;&gt;\[
f_i=\max\{f_{j-1}+s_i\times(cnt_i-cnt_j+1)^2\}
\]&lt;/span&gt; 其中 &lt;span class=&#34;math inline&#34;&gt;\(cnt_i\)&lt;/span&gt; 为 &lt;span class=&#34;math inline&#34;&gt;\(s_i\)&lt;/span&gt; 已经出现了多少次。&lt;/p&gt;
&lt;p&gt;然后就是套路。 &lt;span class=&#34;math display&#34;&gt;\[
\begin{aligned}
f_i&amp;amp;=\max\{f_{j-1}+s_i\times({cnt_i}^2+{cnt_j}^2-2\times cnt_i\times cnt_j+2\times cnt_i-2\times cnt_j+1)\}
\\
&amp;amp;=\max\{f_{j-1}+s_i\times{cnt_i}^2+s_i\times{cnt_j}^2-2\times s_i\times cnt_i\times cnt_j+2\times s_i\times cnt_i-2\times s_i\times cnt_j+s_i\}
\\
&amp;amp;=\max\{f_{j-1}+s_i\times {cnt_j}^2-2\times s_i\times cnt_i\times cnt_j-2\times s_i\times cnt_j\}+s_i\times {cnt_i}^2+2\times s_i\times cnt_i+s_i
\end{aligned}
\]&lt;/span&gt; 这次不是 &lt;span class=&#34;math inline&#34;&gt;\(\min\)&lt;/span&gt;，而是 &lt;span class=&#34;math inline&#34;&gt;\(\max\)&lt;/span&gt;，我们还能像以前那样推吗？&lt;/p&gt;
&lt;p&gt;不急，我们先按以前的方法试试，见机行事。&lt;/p&gt;
&lt;p&gt;令 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; 优于 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt;，则有： &lt;span class=&#34;math display&#34;&gt;\[
f_{j-1}+s_i\times {cnt_j}^2-2\times s_i\times cnt_i\times cnt_j-2\times s_i\times cnt_j&amp;gt;f_{k-1}+s_i\times {cnt_k}^2-2\times s_i\times cnt_i\times cnt_k-2\times s_i\times cnt_k
\]&lt;/span&gt; 暴力搞不出来，因为那个 &lt;span class=&#34;math inline&#34;&gt;\(s_i\)&lt;/span&gt; 乘上的平方项。&lt;/p&gt;
&lt;p&gt;那我们想一个办法，把 &lt;span class=&#34;math inline&#34;&gt;\(s_i\)&lt;/span&gt; 给灭掉就行了。&lt;/p&gt;
&lt;p&gt;既然我们已知一段的首尾元素必须相等，那不就说明 &lt;span class=&#34;math inline&#34;&gt;\(s_i,s_j,s_k\)&lt;/span&gt; 可以相互替换吗？&lt;/p&gt;
&lt;p&gt;继续搞。 &lt;span class=&#34;math display&#34;&gt;\[
f_{j-1}+s_j\times {cnt_j}^2-2\times s_i\times cnt_i\times cnt_j-2\times s_j\times cnt_j&amp;gt;f_{k-1}+s_k\times {cnt_k}^2-2\times s_i\times cnt_i\times cnt_k-2\times s_k\times cnt_k
\\
f_{j-1}-f_{k-1}+s_j\times {cnt_j}^2-s_k\times {cnt_k}^2-2\times s_j\times cnt_j+2\times s_k\times cnt_k&amp;gt;2\times s_i\times cnt_i\times cnt_j-2\times s_i\times cnt_i\times cnt_k
\\
\dfrac{f_{j-1}-f_{k-1}+s_j\times {cnt_j}^2-s_k\times {cnt_k}^2-2\times s_j\times cnt_j+2\times s_k\times cnt_k}{cnt_j-cnt_k}&amp;gt;2\times s_i\times cnt_i
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这里的符号变成 &lt;span class=&#34;math inline&#34;&gt;\(&amp;gt;\)&lt;/span&gt; 了。&lt;/p&gt;
&lt;p&gt;易得，这里要维护的是一个斜率单调递减的上凸包最优解序列。&lt;/p&gt;
&lt;p&gt;因为 &lt;span class=&#34;math inline&#34;&gt;\(s_i\)&lt;/span&gt; 必须与 &lt;span class=&#34;math inline&#34;&gt;\(s_j,s_k\)&lt;/span&gt; 相同，明显要针对每个 &lt;span class=&#34;math inline&#34;&gt;\(s_i\)&lt;/span&gt; 维护不同的最优解序列，在每次对应的序列中计算。&lt;/p&gt;
&lt;p&gt;维护的斜率单调递减，而对于每一个相等的 &lt;span class=&#34;math inline&#34;&gt;\(s_i\)&lt;/span&gt;， &lt;span class=&#34;math inline&#34;&gt;\(2\times s_i\times cnt_i\)&lt;/span&gt; 一定是单调递增的，导致了这个序列大概长这个样子：斜率单调递减，但末尾的最小的斜率仍大于 &lt;span class=&#34;math inline&#34;&gt;\(2\times s_i\times cnt_i\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;单调栈可以自行研究，因为作者瞄了一眼时间发现已经是明天了。（什&lt;/p&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;vector&amp;gt;
using namespace std;
#define int long long
#define top q[x].size() - 1
const int maxn = 1e5 + 5;
const int maxm = 1e4 + 5;
int n;
vector&amp;lt;int&amp;gt; q[maxm]; // 不用 vector 会 MLE
int f[maxn], s[maxn];
int cnt[maxn], tot[maxm];
int getDP(int i,int j)&amp;#123;
    return f[j-1]+(cnt[i]-cnt[j]+1)*(cnt[i]-cnt[j]+1)*s[i];
&amp;#125;
int getup(int j,int k)&amp;#123;
    return f[j-1]-f[k-1]+s[j]*cnt[j]*cnt[j]-s[k]*cnt[k]*cnt[k]-2*s[j]*cnt[j]+2*s[k]*cnt[k];
&amp;#125;
int getdown(int j,int k)&amp;#123;
    return cnt[j]-cnt[k];
&amp;#125;
signed main()&amp;#123;
    scanf(&amp;quot;%lld&amp;quot;,&amp;amp;n);
    for(int i=1;i&amp;lt;=n;++i)&amp;#123;
        scanf(&amp;quot;%lld&amp;quot;,&amp;amp;s[i]);
        cnt[i]=++tot[s[i]];
    &amp;#125;
    for(int i=1;i&amp;lt;=n;++i)&amp;#123;
        int x=s[i];
        while(q[x].size()&amp;gt;=2&amp;amp;&amp;amp;getup(q[x][top-1],i)*getdown(q[x][top-1],q[x][top])&amp;gt;=getup(q[x][top-1],q[x][top])*getdown(q[x][top-1],i))
            q[x].pop_back();
        q[x].push_back(i);
        while(q[x].size()&amp;gt;=2&amp;amp;&amp;amp;getDP(i,q[x][top])&amp;lt;=getDP(i,q[x][top-1]))
            q[x].pop_back();
        f[i]=getDP(i,q[x][top]);
    &amp;#125;
    printf(&amp;quot;%lld&amp;quot;,f[n]);
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;总结&#34;&gt;总结&lt;/h3&gt;
&lt;p&gt;总结斜优的步骤：&lt;/p&gt;
&lt;ol type=&#34;1&#34;&gt;
&lt;li&gt;推 DP 式子&lt;/li&gt;
&lt;li&gt;对式子进行巧妙的优化，使其易于化简&lt;/li&gt;
&lt;li&gt;假设 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; 优于 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt;，将式子化成 &lt;span class=&#34;math inline&#34;&gt;\(\dfrac{(j)-(k)}{(j)-(k)}&amp;gt; \text{or} &amp;lt;x\)&lt;/span&gt; 的形式&lt;/li&gt;
&lt;li&gt;单调队列或单调栈优化&lt;/li&gt;
&lt;/ol&gt;
 ]]></description>
        </item>
    </channel>
</rss>
