{
    "version": "https://jsonfeed.org/version/1",
    "title": "null • All posts by \"斜率优化\" tag",
    "description": "",
    "home_page_url": "https://xsc062.netlify.app",
    "items": [
        {
            "id": "https://xsc062.netlify.app/20250715/",
            "url": "https://xsc062.netlify.app/20250715/",
            "title": "练习 决策单调性",
            "date_published": "2025-07-15T06:13:24.000Z",
            "content_html": "<p>『心静自然凉』大抵是因为情绪平和时副交感神经兴奋，体温略有降低导致的。吗？</p>\n<span id=\"more\"></span>\n<p>其实是因为心脏停跳后血液循环终止、代谢中断，导致产热低于散热（？）</p>\n<hr />\n<h2 id=\"a---征途\">A - 征途</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P4072\" class=\"uri\">https://www.luogu.com.cn/problem/P4072</a></p>\n<p>用完全平方公式展开得到 <span class=\"math inline\">\\(m^2\\sigma^2=m\\left(\\sum {x_i}^2\\right)-S^2\\)</span>，其中 <span class=\"math inline\">\\(S\\)</span> 为求和。</p>\n<p>所以目标是最小化 <span class=\"math inline\">\\(\\sum {x_i}^2\\)</span> 这个东西。令 <span class=\"math inline\">\\(f_{i,j}\\)</span> 表示第 <span class=\"math inline\">\\(i\\)</span> 天走到 <span class=\"math inline\">\\(j\\)</span>，得到：</p>\n<p><span class=\"math display\">\\[\n\\begin{aligned}\nf_{i,j}&amp;=\\min\\{f_{i-1,k}+(s_j-s_k)^2\\}\\\\\n&amp;=\\min\\{f_{i-1,k}-2\\times s_j\\times s_k+{s_k}^2\\}+{s_j}^2\n\\end{aligned}\n\\]</span></p>\n<p>最后得到的斜率式子是 <span class=\"math inline\">\\(\\dfrac {f_{i - 1, a}-f_{i - 1, b}+{s_a}^2-{s_b}^2}{2(s_a-s_b)}&lt;s_j\\)</span>，由于 <span class=\"math inline\">\\(s_j\\)</span> 单增，<del>单调队列维护递减斜率即可</del> <strong>更正：是递增斜率。原因是 <span class=\"math inline\">\\(&lt;\\)</span> 是弹出条件，而非保留条件……</strong></p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst long long inf = 1e9;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, m;\n    std::cin &gt;&gt; n &gt;&gt; m;\n    std::vector&lt;int&gt; a(n + 1);\n    std::vector&lt;long long&gt; s(n + 1);\n    auto sum(0ll);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; a[i];\n        s[i] = s[i - 1] + a[i];\n        sum += a[i];\n    &#125;\n    std::vector&lt;std::vector&lt;long long&gt; &gt; f(m + 1, std::vector&lt;long long&gt; (n + 1, inf));\n    f[0][0] = 0ll;\n    for (int i = 1; i &lt;= m; ++i) &#123;\n        auto f1 = [&amp;](int a, int b) &#123;\n            return f[i - 1][a] - f[i - 1][b] + s[a] * s[a] - s[b] * s[b];\n        &#125;;\n        auto f2 = [&amp;](int a, int b) &#123;\n            return 2 * (s[a] - s[b]);\n        &#125;;\n        std::vector&lt;int&gt; q(n + 1);\n        int h = 0, t = -1;\n        q[++t] = i - 1;\n        for (int j = i; j &lt;= n; ++j) &#123;\n            for (; h &lt; t &amp;&amp; f1(q[h + 1], q[h]) &lt; s[j] * f2(q[h + 1], q[h]); ++h);\n            f[i][j] = f[i - 1][q[h]] + (s[j] - s[q[h]]) * (s[j] - s[q[h]]);\n            for (; h &lt; t &amp;&amp; f1(j, q[t]) * f2(q[t], q[t - 1]) &lt; f1(q[t], q[t - 1]) * f2(j, q[t]); --t);\n            q[++t] = j;\n        &#125;\n    &#125;\n    std::cout &lt;&lt; m * f[m][n] - sum * sum &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"b---刷野-iii\">B - 刷野 III</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P10074\" class=\"uri\">https://www.luogu.com.cn/problem/P10074</a></p>\n<p>发现最坏情况就是每次『试探』都不中的情况，再试探中最坏的那一个。为啥呢，相当于我们每次攻击的一定是未知元素中血最多的一个。既然已经试探出了比阈值大的所有元素，那么下一个攻击的就一定是阈值本身，如果这次跳过它，它就会成为下一次试探失败的元素。这显然不如一开始就直接用新阈值试探。</p>\n<p>从大到小排序。令 <span class=\"math inline\">\\(f_{j, i}\\)</span> 表示只确定了前 <span class=\"math inline\">\\(i\\)</span> 大的数，已经杀了 <span class=\"math inline\">\\(j\\)</span> 个人的最坏情况最小代价。那么显然这一次的阈值是 <span class=\"math inline\">\\(a_i\\)</span>。随便选出上一次的阈值 <span class=\"math inline\">\\(a_k\\)</span>，那么中间这一段待确定的元素数量为 <span class=\"math inline\">\\(i-k\\)</span>。那么有：</p>\n<p><span class=\"math display\">\\[\n\\begin{aligned}\nf_{j, i}&amp;=\\min\\limits_{k&lt;i}\\{f_{j-1,k}+(i-k)\\times a_i\\}\\\\\n&amp;=\\min\\limits_{k&lt;i}\\{f_{j-1,k}-k\\times a_i\\}+i\\times a_i\n\\end{aligned}\n\\]</span></p>\n<p>经过验证，虽然这个式子和题解长得不一样，但是是对的 <del>因为我 n^3 暴力 A 了</del></p>\n<p>推出斜优形式 <span class=\"math inline\">\\(\\dfrac {f_{j-1,A}-f_{j-1,B}}{A-B}&lt;a_i\\)</span>，但我的朋友，<span class=\"math inline\">\\(a_i\\)</span> 是递减的。所以用单调栈维护递增斜率即可。<del>或者你也可以学习 grisses 打一个单调队列上二分</del></p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst long long inf = 1e12;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;P10074_4.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, m;\n    std::cin &gt;&gt; n &gt;&gt; m;\n    std::vector&lt;long long&gt; a(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i];\n    std::sort(a.begin() + 1, a.end(), std::greater&lt;long long&gt; ());\n    std::vector&lt;std::vector&lt;long long&gt; &gt; f(m + 1, std::vector&lt;long long&gt; (n + 1, inf));\n    f[0][0] = 0ll;\n    for (int j = 1; j &lt;= m; ++j) &#123;\n        std::vector&lt;int&gt; q(n + 1);\n        int t = -1;\n        q[++t] = j - 1;\n        auto f1 = [&amp;](int A, int B) &#123;\n            return f[j - 1][A] - f[j - 1][B];\n        &#125;;\n        auto f2 =[&amp;](int A, int B) &#123;\n            return A - B;\n        &#125;;\n        for (int i = j; i &lt;= n; ++i) &#123;\n            for (; t &gt;= 1 &amp;&amp; f1(q[t], q[t - 1]) &gt; a[i] * f2(q[t], q[t - 1]); --t);\n            f[j][i] = f[j - 1][q[t]] + (i - q[t]) * a[i];\n            for (; t &gt;= 1 &amp;&amp; f1(i, q[t]) * f2(q[t], q[t - 1]) &lt; f1(q[t], q[t - 1]) * f2(i, q[t]); --t);\n            q[++t] = i;\n        &#125;\n    &#125;\n    auto res(inf);\n    for (int i = m; i &lt;= n; ++i)\n        res = std::min(res, f[m][i]);\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"c---traka\">C - TRAKA</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P7747\" class=\"uri\">https://www.luogu.com.cn/problem/P7747</a></p>\n<p>稍微手玩一下就可以发现，假如第 <span class=\"math inline\">\\(j\\)</span> 个人在第 <span class=\"math inline\">\\(i\\)</span> 次的工作时间为 <span class=\"math inline\">\\([L_{j,i},R_{j,i}]\\)</span>，第 <span class=\"math inline\">\\(i-1\\)</span> 次为 <span class=\"math inline\">\\([L_{j,i-1},R_{j,i-1}]\\)</span>，那么要求 <span class=\"math inline\">\\(L_{j,i}\\ge R_{j,i-1}\\)</span>。</p>\n<p>令 <span class=\"math inline\">\\(s_j\\)</span> 为 <span class=\"math inline\">\\(t\\)</span> 的前缀和。假设第 <span class=\"math inline\">\\(i-1\\)</span> 次加工于 <span class=\"math inline\">\\(x_{i-1}\\)</span> 开始，那么我们可以把上式转写为 <span class=\"math inline\">\\(x_{i}+s_{j-1}\\times f_{i}\\ge x_{i-1}+s_j\\times f_{i-1}\\)</span>。也即 <span class=\"math inline\">\\(x_i-x_{i-1}\\ge s_j\\times f_{i-1}-s_{j-1}\\times f_i\\)</span>。</p>\n<p>显然需要找到一个 <span class=\"math inline\">\\(j\\)</span> 使得 RSH 取得最大值；现在就可以考虑斜率优化了。由于所有项都和 <span class=\"math inline\">\\(i\\)</span> 有关，想到两边同除 <span class=\"math inline\">\\(f_{i}\\)</span> 消掉一个 <span class=\"math inline\">\\(i\\)</span> 有关的系数，最后化出来的斜优形式是 <span class=\"math inline\">\\(\\dfrac {s_A-s_B}{s_{A-1}-s_{B-1}}&gt;\\dfrac {f_{i-1}}{f_i}\\)</span>。由于 RSH 不单调，把所有 <span class=\"math inline\">\\(j\\)</span> 塞到队列里维护递减斜率，打二分即可。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, m;\n    std::cin &gt;&gt; n &gt;&gt; m;\n    std::vector&lt;long long&gt; a(n + 1), w(m + 1), s(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i], s[i] = s[i - 1] + a[i];\n    for (int i = 1; i &lt;= m; ++i)\n        std::cin &gt;&gt; w[i];\n    std::vector&lt;long long&gt; f(m + 1);\n    std::vector&lt;int&gt; q(n + 1);\n    int h = 0, t = -1;\n    q[++t] = 1;\n    for (int i = 2; i &lt;= n; ++i) &#123;\n        for (; h &lt; t &amp;&amp; (s[i] - s[q[t]]) * (s[q[t] - 1] - s[q[t - 1] - 1]) &gt; (s[q[t]] - s[q[t - 1]]) * (s[i - 1] - s[q[t] - 1]); --t);\n        q[++t] = i;\n    &#125;\n    for (int i = 2; i &lt;= m; ++i) &#123;\n        int to = q[h];\n        for (int l = h + 1, r = t, mid; l &lt;= r; ) &#123;\n            mid = (l + r) &gt;&gt; 1;\n            if ((s[q[mid]] - s[q[mid - 1]]) * w[i - 1] &gt; w[i] * (s[q[mid] - 1] - s[q[mid - 1] - 1]))\n                to = q[mid], l = mid + 1;\n            else\n                r = mid - 1;\n        &#125;\n        f[i] = f[i - 1] + s[to] * w[i - 1] - s[to - 1] * w[i];\n    &#125;\n    std::cout &lt;&lt; f[m] + w[m] * s[n] &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"d---柠檬\">D - 柠檬</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P5504\" class=\"uri\">https://www.luogu.com.cn/problem/P5504</a></p>\n<ul>\n<li>观察零：原问题『从两端取』可以转化为分段问题，故从其中一端考虑即可。</li>\n<li>观察一：若有一段连续的 <span class=\"math inline\">\\(x\\)</span>，完整的比拆开的更优。</li>\n<li>观察二：如果一段 <span class=\"math inline\">\\(x\\)</span> 中夹杂了一些其他元素，那么在哪里分段是说不准的。</li>\n<li>观察三：如果选取的区间是 <span class=\"math inline\">\\([1,r]\\)</span>，那么贪心地想，<span class=\"math inline\">\\(a_r\\)</span> 一定是关键值，不然取 <span class=\"math inline\">\\(a_r\\)</span> 就浪费了。</li>\n<li>观察四：如果选取的区间是 <span class=\"math inline\">\\([l,r]\\)</span>，那么由观察四，<span class=\"math inline\">\\(a_l=a_r\\)</span>，且该值为关键值。</li>\n</ul>\n<p>结合这几个观察，令 <span class=\"math inline\">\\(c_i\\)</span> 表示 <span class=\"math inline\">\\(a_i\\)</span> 在 <span class=\"math inline\">\\([1,i]\\)</span> 中出现次数，<span class=\"math inline\">\\(f_i\\)</span> 表示这一段以 <span class=\"math inline\">\\(i\\)</span> 结尾的最大价值：</p>\n<p><span class=\"math display\">\\[\n\\begin{aligned}\nf_i&amp;=\\max\\limits_{j&lt;i,a_{j+1}=a_i}\\{f_j+a_i\\times (c_i-c_{j + 1} + 1)^2\\}\\\\\n&amp;=\\max\\limits_{j&lt;i,a_{j+1}=a_i}\\{f_j+a_{j+1}\\times {c_{j+1}}^2-2\\times c_i\\times a_{j+1}\\times c_{j+1}-2\\times c_{j+1}\\times a_{j+1}\\}+a_i\\times(c_i-1)^2\n\\end{aligned}\n\\]</span></p>\n<p>（怎么这么大一堆。）最后可以化出 <span class=\"math inline\">\\(\\dfrac {f_A-f_B+a_{A+1}\\cdot c_{A+1}\\cdot (c_{A+1}-2)-a_{B+1}\\cdot c_{B+1}\\cdot (c_{B+1}-2)}{2(c_{A+1} - c_{B+1})}&gt;c_i\\times a_i\\)</span>。发现对于每一种 <span class=\"math inline\">\\(a_i\\)</span>，<span class=\"math inline\">\\(c_i\\times a_i\\)</span> 是单增的。单调栈维护即可。</p>\n<p><em>这其实提醒我们关于代换的问题——显然，当与 <span class=\"math inline\">\\(i\\)</span> 的项、与 <span class=\"math inline\">\\(j\\)</span> 有关的项之间存在代换关系时，应该尽量往 <span class=\"math inline\">\\(j\\)</span> 的方向靠。</em></p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;7.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;long long&gt; a(n + 1), c(n + 1), la(10001);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; a[i];\n        c[i] = c[la[a[i]]] + 1, la[a[i]] = i;\n    &#125;\n    std::vector&lt;long long&gt; f(n + 1);\n    std::vector&lt;int&gt; _t(10001, -1);\n    std::vector&lt;std::vector&lt;int&gt; &gt; _q(10001);\n    auto f1 = [&amp;](int A, int B) &#123;\n        return f[A] - f[B] + a[A + 1] * c[A + 1] * (c[A + 1] - 2) - a[B + 1] * c[B + 1] * (c[B + 1] - 2);\n    &#125;;\n    auto f2 = [&amp;](int A, int B) &#123;\n        return 2 * (c[A + 1] - c[B + 1]);\n    &#125;;\n    ++_t[a[1]], _q[a[1]].push_back(0);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        &#123;\n            auto &amp;t = _t[a[i]];\n            auto &amp;q = _q[a[i]];\n            for (; t &gt;= 1 &amp;&amp; f1(q[t], q[t - 1]) &lt; c[i] * a[i] * f2(q[t], q[t - 1]); --t);\n            f[i] = f[q[t]] + a[i] * (c[i] - c[q[t] + 1] + 1) * (c[i] - c[q[t] + 1] + 1);\n        &#125;\n        if (i &lt; n) &#123;\n            auto &amp;t = _t[a[i + 1]];\n            auto &amp;q = _q[a[i + 1]];\n            for (; t &gt;= 1 &amp;&amp; f1(i, q[t]) * f2(q[t], q[t - 1]) &gt; f1(q[t], q[t - 1]) * f2(i, q[t]); --t);\n            q.resize(++t + 1), q[t] = i;\n        &#125;\n    &#125;\n    std::cout &lt;&lt; f[n] &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"e---knapsack-with-diminishing-values\">E - Knapsack with Diminishing Values</h2>\n<p><a href=\"https://atcoder.jp/contests/abc373/tasks/abc373_f\" class=\"uri\">https://atcoder.jp/contests/abc373/tasks/abc373_f</a></p>\n<p>发现和 <a href=\"/20250707-1/#例单调队列优化多重背包\">单调队列优化多重背包</a> 有异曲同工之妙。</p>\n<p>不妨令 <span class=\"math inline\">\\(v_i\\)</span> 表示体积，<span class=\"math inline\">\\(w_i\\)</span> 表示价值。对于每一个 <span class=\"math inline\">\\(i\\)</span>，把所有体积按模 <span class=\"math inline\">\\(v_i\\)</span> 的余数分类，设为 <span class=\"math inline\">\\(j\\cdot v_i+x\\)</span>。对于 <span class=\"math inline\">\\(k\\cdot v_i+x\\)</span>，有：</p>\n<p><span class=\"math display\">\\[\n\\begin{aligned}\nf_{i,j\\cdot v_i+x}&amp;=\\max\\limits_{k&lt;j}\\{f_{i-1,k\\cdot v_i+x}+(j-k)\\cdot w_i-(j-k)^2\\}\\\\\n&amp;=\\max\\limits_{k&lt;j}\\{f_{i-1,k\\cdot v_i+x}-k\\cdot w_i-k^2+2\\times j\\times k\\}-j^2+j\\cdot w_i\n\\end{aligned}\n\\]</span></p>\n<p>则得到 <span class=\"math inline\">\\(\\dfrac {f_{i-1,A\\cdot v_i+x}-f_{i-1,B\\cdot v_i+x}+(B-A)\\cdot w_i - A^2+B^2}{2(B-A)}&lt;j\\)</span>。注意分母为负。总之单调队列维护递增斜率即可。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, m;\n    std::cin &gt;&gt; n &gt;&gt; m;\n    std::vector&lt;long long&gt; v(n + 1), w(n + 1);\n    std::vector&lt;std::vector&lt;long long&gt; &gt; f(n + 1, std::vector&lt;long long&gt; (m + 1));\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; v[i] &gt;&gt; w[i];\n        for (int x = 0; x &lt; v[i]; ++x) &#123;\n            int h = 0, t = -1;\n            std::vector&lt;int&gt; q;\n            auto f1 = [&amp;](int A, int B) &#123;\n                return f[i - 1][A * v[i] + x] - f[i - 1][B * v[i] + x] + (B - A) * w[i] - A * A + B * B;\n            &#125;;\n            auto f2 = [&amp;](int A, int B) &#123;\n                return 2 * (B - A);\n            &#125;;\n            for (int j = 0, J = x; J &lt;= m; ++j, J += v[i]) &#123;\n                for (; h &lt; t &amp;&amp; f1(q[h + 1], q[h]) &gt; j * f2(q[h + 1], q[h]); ++h);\n                f[i][J] = f[i - 1][J];\n                if (h &lt;= t)\n                    f[i][J] = std::max(f[i][J], f[i - 1][q[h] * v[i] + x] + (j - q[h]) * w[i] - (j - q[h]) * (j - q[h]));\n                for (; h &lt; t &amp;&amp; f1(j, q[t]) * f2(q[t], q[t - 1]) &lt; f1(q[t], q[t - 1]) * f2(j, q[t]); --t);\n                q.resize(++t + 1), q[t] = j;\n            &#125;\n        &#125;\n    &#125;\n    std::cout &lt;&lt; f[n][m] &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"f---managing-telephone-poles\">F - Managing Telephone Poles</h2>\n<p><a href=\"https://codeforces.com/problemset/problem/1575/M\" class=\"uri\">https://codeforces.com/problemset/problem/1575/M</a></p>\n<p>？观察到性质然后被自己忽略了。非常值得批评。</p>\n<p>不难写出类似斜率优化的式子 <span class=\"math inline\">\\(S(i,j)=\\min\\{ {x_k}^2-2\\times i\\times x_k+{y_k}^2-2\\times j \\times y_k\\}+i^2+j^2\\)</span>。</p>\n<p>会下意识尝试固定 <span class=\"math inline\">\\(i\\)</span>，就可以 <span class=\"math inline\">\\(O(n^2m)\\)</span> 完成任务，似乎不太行。顺着这个想法会观察到，固定 <span class=\"math inline\">\\(i\\)</span> 之后，每一列的 poles 中只有和第 <span class=\"math inline\">\\(i\\)</span> 行最近的才会有贡献。</p>\n<p>这个是好做的，且这样的相邻点数量是 <span class=\"math inline\">\\(O(m)\\)</span> 的；于是将 <span class=\"math inline\">\\(i\\)</span> 视为常数进行变形，若将所有 poles 按 <span class=\"math inline\">\\(y\\)</span> 从小到大排序就能得到斜率形式 <span class=\"math inline\">\\(\\dfrac { {x_A}^2-{x_B}^2+{y_A}^2-{y_B}^2-2\\times i\\times(x_A-x_B)}{2(y_A-y_B)}&lt;j\\)</span>。维护递增斜率就能 <span class=\"math inline\">\\(O(n^2)\\)</span> 完成问题。</p>\n<p>那么找相邻点这一步大可以摆烂写二分。所以总共是 <span class=\"math inline\">\\(O(nm\\log m)\\)</span> 的。</p>\n<p>不要像我一样把两边最近的都加进队列，不然你会有分母为 <span class=\"math inline\">\\(0\\)</span> 的斜率 <img src=\"/em/hsh.gif\" /></p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, m;\n    std::cin &gt;&gt; n &gt;&gt; m, ++n, ++m;\n    std::vector&lt;std::vector&lt;int&gt; &gt; tag(n + 1, std::vector&lt;int&gt; (m + 1));\n    std::vector&lt;std::vector&lt;int&gt; &gt; g(m + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        for (int j = 1; j &lt;= m; ++j) &#123;\n            char t;\n            std::cin &gt;&gt; t;\n            if (t == &#39;1&#39;)\n                g[j].push_back(i), tag[i][j] = 1;\n        &#125;\n    struct node &#123; long long x, y; &#125;;\n    auto res(0ll);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::vector&lt;node&gt; p;\n        for (int j = 1; j &lt;= m; ++j) &#123;\n            int to = std::lower_bound(g[j].begin(), g[j].end(), i) - g[j].begin();\n            if (to &lt; (int)g[j].size()) &#123;\n                p.push_back(&#123; g[j][to], j &#125;);\n                if (g[j][to] != i &amp;&amp; to != 0 &amp;&amp; g[j][to] - i &gt; i - g[j][to - 1])\n                    p.back() = &#123; g[j][to - 1], j &#125;;\n            &#125;\n            else if (to != 0)\n                p.push_back(&#123; g[j][to - 1], j &#125;);\n        &#125;\n        std::vector&lt;int&gt; q(m + 1);\n        int h = 0, t = -1;\n        auto f1 = [&amp;](node A, node B) &#123;\n            return A.x * A.x - B.x * B.x + A.y * A.y - B.y * B.y - 2 * i * (A.x - B.x);\n        &#125;;\n        auto f2 = [&amp;](node A, node B) &#123;\n            return 2 * (A.y - B.y);\n        &#125;;\n        for (int j = 0; j &lt; (int)p.size(); ++j) &#123;\n            for (; h &lt; t &amp;&amp; f1(p[j], p[q[t]]) * f2(p[q[t]], p[q[t - 1]]) &lt; f1(p[q[t]], p[q[t - 1]]) * f2(p[j], p[q[t]]); --t);\n            q[++t] = j;\n        &#125;\n        for (int j = 1; j &lt;= m; ++j) &#123;  \n            for (; h &lt; t &amp;&amp; f1(p[q[h + 1]], p[q[h]]) &lt; j * f2(p[q[h + 1]], p[q[h]]); ++h);\n            res += (p[q[h]].x - i) * (p[q[h]].x - i) + (p[q[h]].y - j) * (p[q[h]].y - j);\n        &#125;\n    &#125;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"g---partition-game\">G - Partition Game</h2>\n<p><a href=\"https://codeforces.com/problemset/problem/1527/E\" class=\"uri\">https://codeforces.com/problemset/problem/1527/E</a></p>\n<p>发现不太斜优，终于给我浸泡了两天斜优内容的大脑加了勺新的底物。</p>\n<p>令 <span class=\"math inline\">\\(f_{i,j}\\)</span> 表示第 <span class=\"math inline\">\\(i\\)</span> 段以 <span class=\"math inline\">\\(j\\)</span> 结尾的最小代价；对 <span class=\"math inline\">\\(w\\)</span> 套用四边形不等式变式 <span class=\"math inline\">\\(w(l-1,r+1)+w(l,r)\\ge w(l-1,r)+w(l,r+1)\\)</span> 发现成立（其中大多数时候能取等；部分特殊情况取到大于号）。</p>\n<p>那么发现可以用分治优化。发现 <span class=\"math inline\">\\(w\\)</span> 不那么能快速求；还是套用 <a href=\"/20250707-1/#例yet-another-minimization-problem\">Yet Another Minimization Problem</a> 中的方法，用类似莫队的方式求解。</p>\n<p>发现这个莫队套路也很熟悉了，直接用双端队列维护即可。复杂度 <span class=\"math inline\">\\(O(nk\\log n)\\)</span>，看着不太安全。但注意到我们在 20 个月前的提交中使用了 <span class=\"math inline\">\\(O(nk\\log n)\\)</span> 的线段树，所以能过的兄弟。</p>\n<details>\n<p>鉴于 deque 的时空常数都大得吓人，所以我用静态 vector 模拟 deque 了。</p>\n<p>跑得比我之前线段树的一半还快，兄弟。</p>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int inf = 1e18;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, m;\n    std::cin &gt;&gt; n &gt;&gt; m;\n    std::vector&lt;std::vector&lt;int&gt; &gt; pos(n + 1);\n    std::vector&lt;int&gt; a(n + 1), _h(n + 1), _t(n + 1, -1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i], pos[a[i]].push_back(i);\n    std::vector&lt;std::vector&lt;long long&gt; &gt; f(m + 1, std::vector&lt;long long&gt; (n + 1, inf));\n    f[0][0] = 0ll;\n    auto w = [&amp;](int ql, int qr) &#123;\n        static int l = 1, r = 0;\n        static auto res(0ll);\n        for (; l &gt; ql; ) &#123;\n            --l;\n            auto &amp;h = _h[a[l]], &amp;t = _t[a[l]];\n            auto &amp;q = pos[a[l]];\n            if (h &lt;= t)\n                res -= q[t] - q[h];\n            res += q[t] - q[--h];\n        &#125;\n        for (; r &gt; qr; ) &#123;\n            auto &amp;h = _h[a[r]], &amp;t = _t[a[r]];\n            auto &amp;q = pos[a[r]];\n            res -= q[t--] - q[h];\n            if (h &lt;= t)\n                res += q[t] - q[h];\n            --r;\n        &#125;\n        for (; r &lt; qr; ) &#123;\n            ++r;\n            auto &amp;h = _h[a[r]], &amp;t = _t[a[r]];\n            auto &amp;q = pos[a[r]];\n            if (h &lt;= t)\n                res -= q[t] - q[h];\n            res += q[++t] - q[h];\n        &#125;\n        for (; l &lt; ql; ) &#123;\n            auto &amp;h = _h[a[l]], &amp;t = _t[a[l]];\n            auto &amp;q = pos[a[l]];\n            res -= q[t] - q[h++];\n            if (h &lt;= t)\n                res += q[t] - q[h];\n            ++l;\n        &#125;\n        return res;\n    &#125;;\n    for (int t = 1; t &lt;= m; ++t) &#123;\n        std::function&lt;void(int, int, int, int)&gt; calc = [&amp;](int l, int r, int lp, int rp) &#123;\n            if (l &gt; r)\n                return;\n            if (l == r) &#123;\n                for (int i = lp; i &lt;= rp &amp;&amp; i &lt; l; ++i)\n                    f[t][l] = std::min(f[t][l], f[t - 1][i] + w(i + 1, l));\n                return;\n            &#125;\n            int mid = (l + r) &gt;&gt; 1, p = -1;\n            for (int i = lp; i &lt;= rp &amp;&amp; i &lt; mid; ++i)\n                if (f[t - 1][i] + w(i + 1, mid) &lt; f[t][mid])\n                    f[t][mid] = f[t - 1][i] + w(i + 1, mid), p = i;\n            calc(l, mid - 1, lp, p), calc(mid + 1, r, p, rp);\n            return;\n        &#125;;\n        calc(t, n, t - 1, n - 1);\n    &#125;\n    std::cout &lt;&lt; f[m][n] &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"h---battle-lemmings\">H - Battle Lemmings</h2>\n<p><a href=\"https://codeforces.com/problemset/problem/1420/E\" class=\"uri\">https://codeforces.com/problemset/problem/1420/E</a></p>\n<p>容易发现 <span class=\"math inline\">\\(0\\)</span> 的数目不变，答案就是 <span class=\"math inline\">\\(0\\)</span> 的对数 - 连续 <span class=\"math inline\">\\(0\\)</span> 的对数。</p>\n<p>然后有一个我们很熟悉的 trick，随便找一个目标序列，那么花费的操作次数就是每个对应的 <span class=\"math inline\">\\(1\\)</span> 的位置差。令 <span class=\"math inline\">\\(f_{i,j,k}\\)</span> 表示用了 <span class=\"math inline\">\\(i\\)</span> 次操作、<span class=\"math inline\">\\(j\\)</span> 个 <span class=\"math inline\">\\(1\\)</span>、最后一个 <span class=\"math inline\">\\(1\\)</span> 在 <span class=\"math inline\">\\(k\\)</span> 的最小连续 <span class=\"math inline\">\\(0\\)</span> 对数。那么有：</p>\n<p><span class=\"math display\">\\[\n\\begin{aligned}\nf_{i,j,k}&amp;=\\min\\limits_{p&lt;k}\\left\\{f_{i-|k-pos_j|,j-1,p}+\\dfrac {(k-p-1)(k-p-2)}2\\right\\}\\\\\n&amp;=\\min\\left\\{f_{i-|k-pos_j|,j-1,p}-k\\cdot p+\\dfrac {p(p + 2)}2\\right\\}+\\dfrac {k^2-3k+2}2\n\\end{aligned}\n\\]</span></p>\n<p>发现这个式子是 <span class=\"math inline\">\\(O(n^5)\\)</span> 的，而且看起来很斜优，化为斜率形式 <span class=\"math inline\">\\(\\dfrac{2\\times f_A-2\\times f_B+A(A+2)-B(B+2)}{2(A-B)}&lt;k\\)</span>。维护递增斜率就可以 <span class=\"math inline\">\\(O(n^4)\\)</span> 做了。</p>\n<p>Tip：当时写着写着愣住了，比如这个 <span class=\"math inline\">\\(i-|k-pos_j|\\)</span> 不是一直在动吗。解决方案？同时维护很多个队列即可。</p>\n<details>\n<p>注意还要把最后一个 <span class=\"math inline\">\\(1\\)</span> 之后连续 <span class=\"math inline\">\\(0\\)</span> 的代价算上。</p>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst long long inf = 1e9;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;int&gt; a(n + 1);\n    std::vector&lt;long long&gt; pos(1);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; a[i];\n        if (a[i] == 1)\n            pos.push_back(i);\n    &#125;\n    int m = n * (n - 1) / 2;\n    std::vector&lt;std::vector&lt;std::vector&lt;long long&gt; &gt; &gt; f(pos.size(), std::vector&lt;std::vector&lt;long long&gt; &gt; (m + 1, std::vector&lt;long long&gt; (n + 1, inf)));\n    f[0][0][0] = 0ll;\n    for (int j = 1; j &lt; (int)pos.size(); ++j) &#123;\n        std::vector&lt;std::vector&lt;int&gt; &gt; _q(m + 1, std::vector&lt;int&gt; (n + 1));\n        std::vector&lt;int&gt; _h(m + 1), _t(m + 1, -1);\n        for (int k = 0; k &lt;= n; ++k)\n            for (int i = m; i &gt;= 0; --i) &#123;\n                if (i &gt;= std::abs(k - pos[j])) &#123;\n                    auto f1 = [&amp;](long long A, long long B) &#123;\n                        return 2 * f[j - 1][i - std::abs(k - pos[j])][A] - 2 * f[j - 1][i - std::abs(k - pos[j])][B] + A * (A + 2) - B * (B + 2);\n                    &#125;;\n                    auto f2 = [&amp;](long long A, long long B) &#123;\n                        return 2 * (A - B);\n                    &#125;;\n                    auto &amp;h = _h[i - std::abs(k - pos[j])], &amp;t = _t[i - std::abs(k - pos[j])];\n                    auto &amp;q = _q[i - std::abs(k - pos[j])];\n                    for (; h &lt; t &amp;&amp; f1(q[h + 1], q[h]) &lt; k * f2(q[h + 1], q[h]); ++h) &#123;&#125;\n                    if (h &lt;= t)\n                        f[j][i][k] = std::min(inf, f[j - 1][i - std::abs(k - pos[j])][q[h]] + (k - q[h] - 1) * (k - q[h] - 2) / 2);\n                &#125;\n                auto f1 = [&amp;](long long A, long long B) &#123;\n                    return 2 * f[j - 1][i][A] - 2 * f[j - 1][i][B] + A * (A + 2) - B * (B + 2);\n                &#125;;\n                auto f2 = [&amp;](long long A, long long B) &#123;\n                    return 2 * (A - B);\n                &#125;;\n                auto &amp;h = _h[i], &amp;t = _t[i];\n                auto &amp;q = _q[i];\n                for (; h &lt; t &amp;&amp; f1(k, q[t]) * f2(q[t], q[t - 1]) &lt; f1(q[t], q[t - 1]) * f2(k, q[t]); --t);\n                q[++t] = k;\n            &#125;\n    &#125;\n    auto res(-inf);\n    int cnt = n - (int)pos.size() + 1;\n    cnt = cnt * (cnt - 1) / 2;\n    for (int i = 0; i &lt;= m; ++i) &#123;\n        for (int k = 0; k &lt;= n; ++k)\n            res = std::max(res, cnt - f.back()[i][k] - (n - k) * (n - k - 1) / 2);\n        std::cout &lt;&lt; res &lt;&lt; &#39; &#39;;\n    &#125;\n    std::cout &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"a---yakiniku-restaurants\">A - Yakiniku Restaurants</h2>\n<p><a href=\"https://atcoder.jp/contests/arc067/tasks/arc067_d\" class=\"uri\">https://atcoder.jp/contests/arc067/tasks/arc067_d</a></p>\n<p>发现固定左右端点后，收益是可以贪心算的；下意识想到只固定左端点，那么右端点应该就可以用单调队列之类的搞一搞。</p>\n<p>先提前把所有东西塞到队列里。左端点一开始在最右边；往左边动一下之后，就可以更新每种菜的队列；发现在所有元素中作决策点的不总是队头；这个地方用 <strong>单调递减的单调栈</strong> 是极好的。这里的单调栈其实就类似 <a href=\"/20250707-1/#优化-dp单调数据结构\">四边形不等式中的单调数据结构</a> 了。</p>\n<p>维护单调栈中每个决策点的影响区间；显然每个右端点的答案变化量相同；用个类似于差分的东西记录一下就好了。</p>\n<p>复杂度 <span class=\"math inline\">\\(O(n^2)\\)</span>。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst long long inf = 1e18;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, m;\n    std::cin &gt;&gt; n &gt;&gt; m;\n    std::vector&lt;long long&gt; s(n + 1), f(n + 1);\n    for (int i = 2; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; s[i], s[i] += s[i - 1];\n        f[i] = -s[i];\n    &#125;\n    std::vector&lt;std::vector&lt;int&gt; &gt; a(n + 1, std::vector&lt;int&gt; (m + 1));\n    for (int i = 1; i &lt;= n; ++i)\n        for (int j = 1; j &lt;= m; ++j)\n            std::cin &gt;&gt; a[i][j];\n    struct node &#123; int j, l, r; &#125;;\n    std::vector&lt;std::stack&lt;node&gt; &gt; _q(m + 1);\n    auto res(-inf);\n    for (int l = n; l; --l) &#123;\n        std::vector&lt;long long&gt; d(n + 1);\n        auto add = [&amp;](int l, int r, long long v) &#123;\n            d[l] += v;\n            if (r != n)\n                d[r + 1] -= v;\n            return;\n        &#125;;\n        for (int j = 1; j &lt;= m; ++j) &#123;\n            auto &amp;q = _q[j];\n            node now = &#123; j, l, l &#125;;\n            add(l, l, a[l][j]);\n            for (; !q.empty() &amp;&amp; a[l][j] &gt;= a[q.top().l][q.top().j]; q.pop()) &#123;\n                now.r = q.top().r;\n                add(q.top().l, q.top().r, a[l][j] - a[q.top().l][q.top().j]);\n            &#125;\n            q.push(now);\n        &#125;\n        std::partial_sum(d.begin() + 1, d.end(), d.begin() + 1);\n        for (int r = l; r &lt;= n; ++r) &#123;\n            f[r] += d[r];\n            res = std::max(res, f[r] + s[l]);\n        &#125;\n    &#125;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"b---jellyfish-and-miku\">B - Jellyfish and Miku</h2>\n<p><a href=\"https://codeforces.com/problemset/problem/1874/D\" class=\"uri\">https://codeforces.com/problemset/problem/1874/D</a></p>\n<p>唉数列。唉概统。在数学讲义上折磨了我一遍之后还要到这儿来折磨我。</p>\n<p>假设已经知道了 <span class=\"math inline\">\\(a\\)</span>，考虑求期望步数。设 <span class=\"math inline\">\\(E_i\\)</span> 为从 <span class=\"math inline\">\\(i\\)</span> 出发走到 <span class=\"math inline\">\\(n\\)</span> 的期望步数。那么有：</p>\n<p><span class=\"math display\">\\[\nE_i=\\begin{cases}\nE_1+1&amp;i=0\\\\\n0&amp;i=n\\\\\nE_i=(E_{i-1}+1)\\cdot \\dfrac {a_i}{a_{i+1}+a_i}+(E_{i+1}+1)\\cdot \\dfrac {a_{i+1}}{a_{i+1}+a_{i}}&amp;\\text{otherwise}\n\\end{cases}\n\\]</span></p>\n<p>（提示：从『<span class=\"math inline\">\\(i\\)</span> 下一步会走哪个方向』考虑。）</p>\n<p>接下来就可以利用你的高中数学知识进行一个 <span class=\"math inline\">\\(f_0\\)</span> 的求，（一堆过程），得到 <span class=\"math inline\">\\(E_0=n+2\\times \\sum\\limits_{i=1}^n\\dfrac {\\sum_{j\\le i}a_j}{a_i}\\)</span>，然后想要最小化这个东西。</p>\n<p>不妨令 <span class=\"math inline\">\\(f_{i,j}\\)</span> 表示到 <span class=\"math inline\">\\(i\\)</span> 时已经分配走了 <span class=\"math inline\">\\(j\\)</span> 体积，<span class=\"math inline\">\\(\\sum_{k=1}^i \\dfrac {\\sum_{l\\le k}a_l}{a_k}\\)</span> 的最小值，有 <span class=\"math inline\">\\(f_{i,j}=\\min\\limits_{k&lt;j}\\left\\{f_{i-1,k}+\\dfrac {k}{j - k}\\right\\}\\)</span>。发现它大抵是满足四边形不等式的，按照 <a href=\"/20250707-1/#d1d-dp-优化\">2D/1D DP 优化的结论</a>，代入 <span class=\"math inline\">\\(p_{i,j-1}&lt;p_{i,j}&lt;p_{i+1,j}\\)</span> 可以 <span class=\"math inline\">\\(O(nm)\\)</span> 解决问题。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, m;\n    std::cin &gt;&gt; n &gt;&gt; m;\n    std::vector&lt;std::vector&lt;int&gt; &gt; p(n + 1, std::vector&lt;int&gt; (m + 1));\n    std::vector&lt;std::vector&lt;long double&gt; &gt; f(n + 1, std::vector&lt;long double&gt; (m + 1, 1e18));\n    f[0][0] = 0ll;\n    for (int j = 1; j &lt;= m; ++j)\n        for (int i = std::min(j, n); i; --i) &#123;\n            int to = ((i == std::min(j, n)) ? j : std::min(p[i + 1][j], j));\n            for (int k = p[i][j - 1]; k &lt;= to; ++k)\n                if (f[i - 1][k] + k * 1. / (j - k) &lt; f[i][j])\n                    f[i][j] = f[i - 1][k] + k * 1. / (j - k), p[i][j] = k;\n            // printf(&quot;f[%d][%d] = %Lf, p = %d\\n&quot;, i, j, f[i][j], p[i][j]);\n        &#125;\n    std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(10) &lt;&lt; n + 2 * f[n][m] &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"cut-the-sequence\">Cut the Sequence</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P10977\" class=\"uri\">https://www.luogu.com.cn/problem/P10977</a></p>\n<h1 id=\"通知区间最值-不满足-四边形不等式\"><mark>通知：区间最值 不满足 四边形不等式。</mark></h1>\n<p>其实在猜的时候是举了反例的，但是大脑萎缩了推着推着忘记符号了 😅</p>\n<p>看到 <span class=\"math inline\">\\(f_i=\\min\\limits_{g(i)\\le j&lt;i}\\{f_j+\\max\\{a_{j+1\\sim i}\\}\\}\\)</span> 这个 <span class=\"math inline\">\\(j\\)</span> 的范围其实是有点单调队列优化的感觉的，但这个最大值传统的单调队列不是很可做。可以注意到最大值这一项有点 <strong>单调队列</strong> 后缀最大值的感觉（实际上就是）；一个很自然的想法是利用这个最大值影响的区间，维护 <span class=\"math inline\">\\(f\\)</span> 的线段树来暴力做。</p>\n<p>另一个比较牛的做法是发现同一个下标的 <span class=\"math inline\">\\(f\\)</span> 和 <span class=\"math inline\">\\(a\\)</span> 的关系。首先需要注意到 <span class=\"math inline\">\\(f\\)</span> 单调不降；对于同一个 <span class=\"math inline\">\\(a\\)</span>，能取到的 <span class=\"math inline\">\\(f\\)</span> 就是最靠前的；维护一个 <span class=\"math inline\">\\(a\\)</span> 的单减队列，那么共用同一个 <span class=\"math inline\">\\(a\\)</span> 的就是相邻两个下标之间的部分，其最优决策在能取到的最前端取得；需要注意到队列里的贡献并不单调，需要用一个 multiset 来存储所有贡献并查找、更新。</p>\n<p>需要注意单调队列里某个元素 <span class=\"math inline\">\\(f_{q_i}\\)</span> 结合的其实是 <span class=\"math inline\">\\(a_{q_{i+1}}\\)</span>。还需要注意队头的维护，可能需要一些小巧思。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;1.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, m;\n    std::cin &gt;&gt; n &gt;&gt; m;\n    std::vector&lt;int&gt; a(n + 1);\n    std::vector&lt;long long&gt; s(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i], s[i] = s[i - 1] + a[i];\n    int h = 0, t = -1;\n    std::multiset&lt;long long&gt; st;\n    std::vector&lt;long long&gt; f(n + 1);\n    std::vector&lt;std::pair&lt;int, int&gt; &gt; q(n + 1);\n    q[++t] = &#123; 0, 0 &#125;, a[0] = 0x3f3f3f3f;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        for (; s[i] - s[q[h].second] &gt; m; ) &#123;\n            st.erase(st.find(f[q[h].second] + a[q[h + 1].first]));\n            if (++q[h].second &gt;= q[h + 1].first)\n                a[q[++h].first] = 0x3f3f3f3f;\n            else\n                st.insert(f[q[h].second] + a[q[h + 1].first]);\n        &#125;\n        for (; h &lt; t &amp;&amp; a[q[t].first] &lt;= a[i]; --t)\n            st.erase(st.find(f[q[t - 1].second] + a[q[t].first]));\n        st.insert(f[q[t].second] + a[i]), q[++t] = &#123; i, i &#125;;\n        f[i] = *st.begin();\n    &#125;\n    std::cout &lt;&lt; f[n] &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n",
            "tags": [
                "斜率优化",
                "DP",
                "四边形不等式"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20210214/",
            "url": "https://xsc062.netlify.app/20210214/",
            "title": "【总结】斜率优化 DP",
            "date_published": "2021-02-06T15:59:00.000Z",
            "content_html": "<p>于是，XSC062 开始写总结。</p>\n<h2 id=\"斜率优化-dp\">斜率优化 DP</h2>\n<p><strong>前置芝士</strong></p>\n<p><a href=\"https://www.cnblogs.com/XSC062/p/14383610.html\">单调队列优化 DP</a></p>\n<p><strong>正文</strong></p>\n<p>我们以一道题为例。</p>\n<h3 id=\"打印文章\"><a href=\"http://acm.hdu.edu.cn/showproblem.php?pid=3507\">打印文章</a></h3>\n<p><a href=\"https://loj.ac/p/10191\">双倍经验</a> | <a href=\"https://www.acwing.com/problem/content/1096/\">三倍经验</a></p>\n<h4 id=\"solution\">Solution</h4>\n<p>明显 DP。</p>\n<p>那么 DP 式就是： <span class=\"math display\">\\[\n\\begin{aligned}\nf_i&amp;=\\min\\{f_j+(s_i-s_j)^2+M\\}\n\\\\\n&amp;=\\min\\{f_j+{s_i}^2-2\\times s_i\\times s_j+{s_j}^2+M\\}\n\\\\\n&amp;=\\min\\{f_j-2\\times s_i\\times s_j+{s_j}^2\\}+{s_i}^2+M\n\\end{aligned}\n\\]</span> 其中 <span class=\"math inline\">\\(s\\)</span> 为 <span class=\"math inline\">\\(c\\)</span> 的前缀和。</p>\n<p>时间复杂度 <span class=\"math inline\">\\(\\mathcal O(n^2)\\)</span>，明显爆炸，所以我们需要优化。</p>\n<p>在上一篇的 <a href=\"https://www.cnblogs.com/XSC062/p/14383610.html\">单调队列优化DP</a> 中，我们提到过，只有 DP 式中的与 <span class=\"math inline\">\\(i\\)</span> 有关的项能直接提出来时，我们才能使用单调队列优化，而这里的 <span class=\"math inline\">\\(s_i\\)</span> 与 <span class=\"math inline\">\\(s_j\\)</span> 相乘，无法使用单调队列优化。</p>\n<p>我们思考，对于 <span class=\"math inline\">\\(f_i\\)</span> 来说，无非就是选出最优的 <span class=\"math inline\">\\(j\\)</span> 来构造它。</p>\n<p>假设有 <span class=\"math inline\">\\(j\\)</span> 与 <span class=\"math inline\">\\(k\\)</span>，如何判断 <span class=\"math inline\">\\(j\\)</span> 与 <span class=\"math inline\">\\(k\\)</span> 谁更优呢？</p>\n<p>我们先钦定 <span class=\"math inline\">\\(j\\)</span> 优于 <span class=\"math inline\">\\(k\\)</span>，且 <span class=\"math inline\">\\(j&lt;k\\)</span>。</p>\n<p>那么可以得到： <span class=\"math display\">\\[\nf_j-2\\times s_i\\times s_j+{s_j}^2+{s_i}^2+M&lt;f_k-2\\times s_i\\times s_k+{s_k}^2+{s_i}^2+M\n\\]</span> 化简得： <span class=\"math display\">\\[\nf_j-2\\times s_i\\times s_j+{s_j}^2&lt;f_k-2\\times s_i\\times s_k+{s_k}^2\n\\]</span> 再将<strong>只</strong>与 <span class=\"math inline\">\\(j,k\\)</span> 有关的项放到左边，与 <span class=\"math inline\">\\(i\\)</span> 有关的项放到右边： <span class=\"math display\">\\[\nf_j-f_k+{s_j}^2-{s_k}^2&lt;2\\times s_i\\times s_j-2\\times s_i\\times s_k\n\\\\\nf_j-f_k+{s_j}^2-{s_k}^2&lt;2\\times s_i\\times(s_j-s_k)\n\\]</span> 左右两边同时 <span class=\"math inline\">\\(\\div\\)</span> 与 <span class=\"math inline\">\\(i\\)</span> 无关的项 <span class=\"math inline\">\\(2\\times(s_j-s_k)\\)</span> ： <span class=\"math display\">\\[\n\\dfrac{(f_j+{s_j}^2)-(f_k+{s_k}^2)}{(2\\times s_j)-(2\\times s_k)}&lt;s_i\n\\]</span> 如果满足上式 ，则 <span class=\"math inline\">\\(j&lt;k\\)</span> 且 <span class=\"math inline\">\\(j\\)</span> 优于 <span class=\"math inline\">\\(k\\)</span>。</p>\n<p>接下来是斜率优化的重点部分。</p>\n<blockquote>\n<p>在义务教育阶段，学生学习了 <a href=\"https://baike.baidu.com/item/一次函数\">一次函数</a>，它的几何意义表示为一条直线，一次项的系数就是直线的斜率，只不过当直线与 <span class=\"math inline\">\\(x\\)</span> 轴垂直的时候无法表示。虽然没有明确给出斜率这个名词，但实际上思想已经渗透到其中。</p>\n<p>直线对 <span class=\"math inline\">\\(x\\)</span> 轴的倾斜角 <span class=\"math inline\">\\(\\alpha\\)</span> 的正切值 <span class=\"math inline\">\\(\\tan\\alpha\\)</span> 称为该直线的“斜率”，并记作 <span class=\"math inline\">\\(k\\)</span> ，公式为 <span class=\"math inline\">\\(k=\\tan\\alpha\\)</span>。</p>\n<p>即 <span class=\"math inline\">\\(k=\\tan\\alpha=\\dfrac{\\Delta y}{\\Delta x}=\\dfrac{y_2-y_1}{x_2-x_1}\\)</span> 或 <span class=\"math inline\">\\(\\dfrac{y_1-y_2}{x_1-x_2}\\)</span> 。</p>\n<p align=\"right\">\n——选自 <a href=\"https://baike.baidu.com/item/%E6%96%9C%E7%8E%87/4914111?fr=aladdin\">斜率_百度百科</a>\n</p>\n</blockquote>\n<p>XSC062 看完了百度百科表示 <del>你 TM 在说些啥是不是欺负我六年义务教育的小学生</del> 恍然大悟</p>\n<p>上面推出来的那个关于 <span class=\"math inline\">\\(j\\)</span> 和 <span class=\"math inline\">\\(k\\)</span> 的DP式，不就是求两个点 <span class=\"math inline\">\\((2\\times s_j,f_j+{s_j}^2)\\)</span> 和 <span class=\"math inline\">\\((2\\times s_k,f_j+{s_k}^2)\\)</span> 连成一条线之后的坡度吗？</p>\n<p>本文后面的部分，<span class=\"math inline\">\\(x\\)</span> 的含义会在「点<span class=\"math inline\">\\((2\\times s_x,f_x+{s_x}^2)\\)</span> 」和「下标 <span class=\"math inline\">\\(x\\)</span> 」之间漂浮，请根据语境识别。</p>\n<p>随后 XSC062 边打瞌睡边听 GM 讲课（特异功能），勉强算是明白了中心意思：</p>\n<p>如图，假设有三个点 <span class=\"math inline\">\\(A,B,C\\)</span>，以及 <span class=\"math inline\">\\(l_{AB}\\)</span> 的斜率 <span class=\"math inline\">\\(k_1\\)</span>，<span class=\"math inline\">\\(l_{BC}\\)</span> 的斜率 <span class=\"math inline\">\\(k_2\\)</span>。</p>\n<figure>\n<img src=\"https://img-blog.csdnimg.cn/img_convert/3bc5fea553ad6b06229ef9e9fa4c9664.png\" alt=\"上凸\" /><figcaption>上凸</figcaption>\n</figure>\n<p>我们暂且把这个向外凸起的奇怪玩意儿称为一个「上凸」。</p>\n<p>回到前面的我们得到的那个结论：</p>\n<blockquote>\n<p><span class=\"math display\">\\[\n\\dfrac{(f_j+{s_j}^2)-(f_k+{s_k}^2)}{(2\\times s_j)-(2\\times s_k)}&lt;s_i\n\\]</span></p>\n<p>如果满足上式 ，则 <span class=\"math inline\">\\(j&lt;k\\)</span> 且 <span class=\"math inline\">\\(j\\)</span> 优于 <span class=\"math inline\">\\(k\\)</span>。</p>\n</blockquote>\n<p>简单记忆为：</p>\n<ul>\n<li>若 <span class=\"math inline\">\\(l_{NM}\\)</span> 的斜率比 <span class=\"math inline\">\\(s_i\\)</span> 小，则 <span class=\"math inline\">\\(N&lt;M\\)</span> 且 <span class=\"math inline\">\\(N\\)</span> 优于 <span class=\"math inline\">\\(M\\)</span> 。</li>\n<li>反之，若点 <span class=\"math inline\">\\(l_{NM}\\)</span> 的斜率比 <span class=\"math inline\">\\(s_i\\)</span> 大，则 <span class=\"math inline\">\\(M&lt;N\\)</span> 且 <span class=\"math inline\">\\(M\\)</span> 优于 <span class=\"math inline\">\\(N\\)</span>。</li>\n</ul>\n<p>将 <span class=\"math inline\">\\(A,B\\)</span> 代入，我们得知：</p>\n<ol type=\"1\">\n<li>若 <span class=\"math inline\">\\(k_1\\leqslant s_i\\)</span>，则 <span class=\"math inline\">\\(B\\)</span> 优于 <span class=\"math inline\">\\(A\\)</span>。</li>\n<li>若 <span class=\"math inline\">\\(k_1&gt;s_i\\)</span>，则 <span class=\"math inline\">\\(A\\)</span> 优于 <span class=\"math inline\">\\(B\\)</span>。</li>\n<li>若 <span class=\"math inline\">\\(k_2\\leqslant s_i\\)</span>，则 <span class=\"math inline\">\\(C\\)</span> 优于 <span class=\"math inline\">\\(B\\)</span>。</li>\n<li>若 <span class=\"math inline\">\\(k_2&gt;s_i\\)</span>，则 <span class=\"math inline\">\\(B\\)</span> 优于 <span class=\"math inline\">\\(C\\)</span>。</li>\n</ol>\n<p>因为斜率 = 倾斜度 = 竖得有多高，明显 <span class=\"math inline\">\\(k_1&gt;k_2\\)</span>。所以针对一个大小关系，<span class=\"math inline\">\\(k_1\\)</span> 和 <span class=\"math inline\">\\(k_2\\)</span> 之间只有可能有：</p>\n<ol type=\"1\">\n<li><span class=\"math inline\">\\(s_i&lt;k_2&lt;k_1\\)</span>，此时 <span class=\"math inline\">\\(B\\)</span> 优于 <span class=\"math inline\">\\(C\\)</span>，<span class=\"math inline\">\\(A\\)</span> 优于 <span class=\"math inline\">\\(B\\)</span>，<span class=\"math inline\">\\(A\\)</span> 为最优解。</li>\n<li><span class=\"math inline\">\\(k_2&lt;s_i&lt;k_1\\)</span>，此时 <span class=\"math inline\">\\(C\\)</span> 优于 <span class=\"math inline\">\\(B\\)</span>，<span class=\"math inline\">\\(A\\)</span> 优于 <span class=\"math inline\">\\(B\\)</span>，<span class=\"math inline\">\\(A,C\\)</span> 为最优解。</li>\n<li><span class=\"math inline\">\\(k_2&lt;k_1&lt;s_i\\)</span>，此时 <span class=\"math inline\">\\(C\\)</span> 优于 <span class=\"math inline\">\\(B\\)</span>，<span class=\"math inline\">\\(B\\)</span> 优于 <span class=\"math inline\">\\(A\\)</span>，<span class=\"math inline\">\\(C\\)</span> 为最优解。</li>\n</ol>\n<p>发现了吗？<span class=\"math inline\">\\(B\\)</span> 永远都不可能是最优解。</p>\n<p>所以如果我们要维护一个最优解的序列，就可以不要 <span class=\"math inline\">\\(B\\)</span> 了。</p>\n<figure>\n<img src=\"0.png\" alt=\"上凸\" /><figcaption>上凸</figcaption>\n</figure>\n<p>那么，因为我们已经删掉了所有「上凸」的突起部分，所以这个最优解序列里肯定不会再存在「上凸」了。</p>\n<p>如果是这样的「下凸」呢？</p>\n<figure>\n<img src=\"1.png\" alt=\"下凸\" /><figcaption>下凸</figcaption>\n</figure>\n<p><span class=\"math inline\">\\(k_1\\)</span> 为 <span class=\"math inline\">\\(l_{AB}\\)</span> 的斜率，<span class=\"math inline\">\\(k_2\\)</span> 为 <span class=\"math inline\">\\(l_{BC}\\)</span> 的斜率。</p>\n<p>将 <span class=\"math inline\">\\(A,B\\)</span> 代入，我们得知：</p>\n<ol type=\"1\">\n<li>若 <span class=\"math inline\">\\(k_1\\leqslant s_i\\)</span>，则 <span class=\"math inline\">\\(B\\)</span> 优于 <span class=\"math inline\">\\(A\\)</span>。</li>\n<li>若 <span class=\"math inline\">\\(k_1&gt;s_i\\)</span>，则 <span class=\"math inline\">\\(A\\)</span> 优于 <span class=\"math inline\">\\(B\\)</span>。</li>\n<li>若 <span class=\"math inline\">\\(k_2\\leqslant s_i\\)</span>，则 <span class=\"math inline\">\\(C\\)</span> 优于 <span class=\"math inline\">\\(B\\)</span>。</li>\n<li>若 <span class=\"math inline\">\\(k_2&gt;s_i\\)</span>，则 <span class=\"math inline\">\\(B\\)</span> 优于 <span class=\"math inline\">\\(C\\)</span>。</li>\n</ol>\n<p>明显 <span class=\"math inline\">\\(k_1&lt;k_2\\)</span>。所以 <span class=\"math inline\">\\(k_1\\)</span> 和 <span class=\"math inline\">\\(k_2\\)</span> 之间只有可能有：</p>\n<ol type=\"1\">\n<li><span class=\"math inline\">\\(s_i&lt;k_1&lt;k_2\\)</span>，此时 <span class=\"math inline\">\\(B\\)</span> 优于 <span class=\"math inline\">\\(C\\)</span>，<span class=\"math inline\">\\(A\\)</span> 优于 <span class=\"math inline\">\\(B\\)</span>，<span class=\"math inline\">\\(A\\)</span> 为最优解。</li>\n<li><span class=\"math inline\">\\(k_1&lt;s_i&lt;k_2\\)</span>，此时 <span class=\"math inline\">\\(B\\)</span> 优于 <span class=\"math inline\">\\(C\\)</span>，<span class=\"math inline\">\\(B\\)</span> 优于 <span class=\"math inline\">\\(A\\)</span>，<span class=\"math inline\">\\(B\\)</span> 为最优解。</li>\n<li><span class=\"math inline\">\\(k_1&lt;k_2&lt;s_i\\)</span>，此时 <span class=\"math inline\">\\(C\\)</span> 优于 <span class=\"math inline\">\\(B\\)</span>，<span class=\"math inline\">\\(B\\)</span> 优于 <span class=\"math inline\">\\(A\\)</span>，<span class=\"math inline\">\\(C\\)</span> 为最优解。</li>\n</ol>\n<p>所以，在下凸的情况中，三个点都有可能是最优解，都需要保留。</p>\n<p>现在呢，所有上凸都被去掉了，只剩下凸，所以大概最后的最优解序列就长这个样子：</p>\n<figure>\n<img src=\"2.png\" alt=\"下凸包\" /><figcaption>下凸包</figcaption>\n</figure>\n<p><del>下 秃 包</del></p>\n<p><del>反过来看就是 lifan 的脑袋了</del></p>\n<p>观察发现，斜率是从左往右递增的。</p>\n<p>所以，我们考虑用单调队列来当这个「最优解序列」。</p>\n<h5 id=\"维护队头\">维护队头</h5>\n<p>即保证队头元素为最优解。</p>\n<p>设队头为 <span class=\"math inline\">\\(q_l\\)</span>。</p>\n<p>如果 <span class=\"math inline\">\\(q_{l+1}\\)</span> 与 <span class=\"math inline\">\\(q_l\\)</span> 形成的斜率 <span class=\"math inline\">\\(\\leqslant s_i\\)</span>，根据上面推出来的玩意儿，得到 <span class=\"math inline\">\\(q_{l+1}\\)</span> 优于 <span class=\"math inline\">\\(q_l\\)</span>。</p>\n<p>那还要 <span class=\"math inline\">\\(q_l\\)</span> 干啥，直接 <code>l++</code>。</p>\n<h5 id=\"更新-dp-值\">更新 DP 值</h5>\n<p><span class=\"math inline\">\\(f_i=f_{q_l}-2\\times s_i\\times s_{q_l}+{s_{q_l}}^2+{s_i}^2+M\\)</span></p>\n<h5 id=\"维护队尾\">维护队尾</h5>\n<p>即保证里面塞的点相邻两个的斜率递增。</p>\n<p>设队尾为 <span class=\"math inline\">\\(q_r\\)</span>，我们要往最优解队列里 <code>push</code> 一个 <span class=\"math inline\">\\(i\\)</span> 。</p>\n<p>若队尾两个点 <span class=\"math inline\">\\(q_r,q_{r-1}\\)</span> 形成的斜率比 <span class=\"math inline\">\\(i,q_r\\)</span> 形成的斜率大，那么<code>push(i)</code>后，整个队列的斜率就不再单调递增，所以此时要将<code>r--</code>。（因为 <a href=\"https://www.cnblogs.com/XSC062/p/14383610.html\">上一篇关于单调队列的博客</a> 中讲到的 <span class=\"math inline\">\\(i\\)</span> 必须入队，只能委屈一下 <span class=\"math inline\">\\(q_r\\)</span> 了）</p>\n<p><strong>注意事项</strong></p>\n<p>众所周知，斜率是个浮点数。为了避免损失精度造成的一些惨案，我们交叉相乘，将分子、分母分开处理。</p>\n<p>以及时刻都要保证队列中至少有两个点，因为要访问 <span class=\"math inline\">\\(q_l,q_{l+1}\\)</span> 和 <span class=\"math inline\">\\(q_r,q_{r-1}\\)</span>。</p>\n<h4 id=\"code\">Code</h4>\n<pre class=\"cpp\"><code>#include &lt;cstdio&gt;\nconst int maxn = 5e5 + 5;\nint n, m, l, r;\nint f[maxn], c[maxn], q[maxn];\ninline int getDP(int i, int j) &#123;\n    return f[j] + m + (c[i] - c[j]) * (c[i] - c[j]);\n&#125;\ninline int getup(int j, int k)&#123;\n    return f[j] + c[j] * c[j] - f[k] - c[k] * c[k]; // 计算分子的值\n&#125;\ninline int getdown(int j, int k) &#123;\n    return (c[j] - c[k]) * 2; // 计算分母的值\n&#125;\nint main()&#123;\n    while (~scanf(&quot;%d %d&quot;, &amp;n, &amp;m)) &#123;\n        l = r = 1; // 凡是涉及到前缀和的单调队列，队列中必须存在初始 0\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            scanf(&quot;%d&quot;, &amp;c[i]); // c 自给自足\n            c[i] += c[i - 1];\n            // # 维护队头\n            // 注意此处的条件为 l &lt; r，因为队列中至少需要存在两个点\n            while (l &lt; r &amp;&amp; getup(q[l+1], q[l]) &lt;= c[i] * getdown(q[l + 1],q[l]))\n                l++;\n            // # 转移状态\n            f[i] = getDP(i, q[l]);\n            // # 维护队尾\n            while(l &lt; r&amp;&amp; getup(i, q[r]) * getdown(q[r], q[r-1]) &lt;= getup(q[r] ,q[r - 1]) * getdown(i, q[r]))\n                r--;\n            q[++r] = i;\n        &#125;\n        printf(&quot;%d\\n&quot;,f[n]);\n    &#125;\n    return 0;\n&#125;</code></pre>\n<p>在对 DP 式变形时，我们最好将其化为 <span class=\"math inline\">\\(\\dfrac{(j)-(k)}{(j)-(k)}&lt;x\\)</span> 或 <span class=\"math inline\">\\(\\dfrac{(j)-(k)}{(j)-(k)}&gt;x\\)</span> 的形式。</p>\n<p>这个板子只适用于维护下凸包的情况。当中间的符号为 <span class=\"math inline\">\\(&gt;\\)</span> 时，我们会在这份代码上稍作改动，维护一个上凸包，后文会提到有关内容。</p>\n<hr />\n<h3 id=\"玩具装箱\"><a href=\"https://www.luogu.com.cn/problem/P3195\">玩具装箱</a></h3>\n<p><a href=\"https://loj.ac/p/10188\">双倍经验</a> | <a href=\"https://www.acwing.com/problem/content/1094/\">三倍经验</a></p>\n<p>从今往后我们就只讲怎么推式子，不再证明下凸等性质了。</p>\n<p>设 <span class=\"math inline\">\\(f_i\\)</span> 表示第 <span class=\"math inline\">\\(i\\)</span> 个玩具放完后的最小费用。 <span class=\"math display\">\\[\nf_i=\\min\\{f_j+(i-j-1+\\sum\\limits_{k=i}^jC_k-L)^2\\}\n\\]</span> 为了让这个式子好拆，我们在一开始让 <code>l++</code>，并且 <span class=\"math inline\">\\(C\\)</span> 再次自给自足，为输入的 <span class=\"math inline\">\\(C\\)</span> 的前缀和数组。</p>\n<p>于是式子就变成： <span class=\"math display\">\\[\nf_i=\\min\\{f_j+(i-j-L+C_i-C_j)^2\\}\n\\]</span> 明显硬拆会死人。（反正我试过，比较适合用来发泄</p>\n<p>所以我们把式子变成这样： <span class=\"math display\">\\[\nf_i=\\min\\{f_j+((C_i+i)-(C_j+j)-L)^2\\}\n\\]</span> 既然 <span class=\"math inline\">\\(C_i\\)</span> 与 <span class=\"math inline\">\\(i\\)</span>，<span class=\"math inline\">\\(C_j\\)</span> 与 <span class=\"math inline\">\\(j\\)</span> 是对应的，那么直接预处理，给 <span class=\"math inline\">\\(C_i\\)</span> 加上 <span class=\"math inline\">\\(i\\)</span> 不就行了？</p>\n<p>现在这个 <span class=\"math inline\">\\(C_i\\)</span> 的含义和实现就变得有点曲折难懂了。</p>\n<p>具体实现如下：</p>\n<pre class=\"cpp\"><code>for (int i = 1; i &lt;= n; ++i) &#123;\n    scanf(&quot;%lld&quot;, &amp;c[i]);\n    c[i] += c[i - 1];\n&#125;\nfor (int i = 1; i &lt;= n; ++i)\n    c[i] += i;</code></pre>\n<p>也就是说，<span class=\"math inline\">\\(C_i\\)</span> 是在前缀和的基础上加了一个 <span class=\"math inline\">\\(i\\)</span>，注意不能把 <span class=\"math inline\">\\(i\\)</span> 也一起前缀和了。</p>\n<p>然后式子就变成了这样： <span class=\"math display\">\\[\n\\begin{aligned}\nf_i&amp;=\\min\\{f_j+(C_i-C_j-L)^2\\}\n\\\\\n&amp;=\\min\\{f_j+{C_i}^2+{C_j}^2+L^2-2\\times C_i\\times C_j-2\\times C_i\\times L+2\\times C_j\\times L\\}\n\\\\\n&amp;=\\min\\{f_j+{C_j}^2-2\\times C_i\\times C_j+2\\times C_j\\times L\\}+{C_i}^2+L^2-2\\times C_i\\times L\n\\end{aligned}\n\\]</span></p>\n<p>令 <span class=\"math inline\">\\(j\\)</span> 优于 <span class=\"math inline\">\\(k\\)</span> 且 <span class=\"math inline\">\\(j&lt;k\\)</span>。</p>\n<p>得： <span class=\"math display\">\\[\nf_j+{C_j}^2-2\\times C_i\\times C_j+2\\times C_j\\times L&lt;f_k+{C_k}^2-2\\times C_i\\times C_k+2\\times C_k\\times L\n\\\\\nf_j-f_k+{C_j}^2-{C_k}^2+2\\times C_j\\times L-2\\times C_k\\times L&lt;2\\times C_i\\times C_j-2\\times C_i\\times C_k\n\\\\\nf_j-f_k+{C_j}^2-{C_k}^2+2\\times C_j\\times L-2\\times C_k\\times L&lt;2\\times(C_j-C_k)\\times C_i\n\\\\\n\\dfrac{f_j-f_k+{C_j}^2-{C_k}^2}{2\\times(C_j-C_k)}&lt;C_i\n\\\\\n\\dfrac{(f_j+{C_j}^2)-(f_k+{C_k}^2)}{(2\\times C_j)-(2\\times C_k)}&lt;C_i\n\\]</span></p>\n<pre class=\"cpp\"><code>#include &lt;cstdio&gt;\n#define int long long\nconst int maxn = 5e5 + 5;\nconst int LEN = (1 &lt;&lt; 20);\nint n, m, h, t;\nint c[maxn], q[maxn], f[maxn];\n#define nec getchar\ninline bool read(int &amp;x) &#123;\n    char ch = nec();\n    bool f = 0; x = 0;\n    while (ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123;\n        if (ch == EOF) return 0;\n        if (ch == &#39;-&#39;) f = 1; ch = nec();\n    &#125;\n    while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) &#123;\n        x = x * 10 + ch - &#39;0&#39;;\n        ch = nec();\n    &#125;\n    if (f) x = -x;\n    return 1;\n&#125;\ninline int getup(int j, int k) &#123;\n    return (f[j] + c[j] * c[j] + 2 * c[j] * m)\n           - (f[k] + c[k] * c[k] + 2 * c[k] * m);\n&#125;\ninline int getdown(int j, int k) &#123;\n    return (2 * c[j]) - (2 * c[k]);\n&#125;\ninline int getDP(int i, int j) &#123;\n    return f[j] + (c[i] - c[j] - m) * (c[i] - c[j] - m);\n&#125;\nsigned main() &#123;\n    read(n); read(m); h = t = 1; ++m;\n    for (int i = 1; i &lt;= n; ++i)\n        read(c[i]), c[i] += c[i - 1];\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        c[i] += i;\n        while (h &lt; t &amp;&amp; getup(q[h + 1], q[h]) &lt;\n               c[i] * getdown(q[h + 1], q[h])) ++h;\n        f[i] = getDP(i, q[h]);\n        while (h &lt; t\n               &amp;&amp; getup(i, q[t]) * getdown(q[t], q[t - 1]) &lt;=\n               getdown(i, q[t]) * getup(q[t], q[t - 1])) --t;\n        q[++t] = i;\n    &#125;\n    printf(&quot;%lld&quot;, f[n]);\n    return 0;\n&#125;</code></pre>\n<hr />\n<h3 id=\"任务安排-1\"><a href=\"https://loj.ac/p/10184\">任务安排 1</a></h3>\n<p><a href=\"https://www.acwing.com/problem/content/302/\">双倍经验</a> | <a href=\"https://www.luogu.com.cn/problem/P2365\">三倍经验</a></p>\n<p>感谢蓝书。这里按着蓝书上的思维走。</p>\n<h4 id=\"解法一\">解法一</h4>\n<p>暴力。</p>\n<p>此处的 <span class=\"math inline\">\\(t,c\\)</span> 为输入的 <span class=\"math inline\">\\(t,c\\)</span> 的前缀和数组。</p>\n<p>设 <span class=\"math inline\">\\(f_{i,j}\\)</span> 为前 <span class=\"math inline\">\\(i\\)</span> 个任务分成 <span class=\"math inline\">\\(j\\)</span> 批的最小费用。</p>\n<p>故 <span class=\"math inline\">\\(S\\times j+t_i\\)</span> 为第 <span class=\"math inline\">\\(i\\)</span> 个任务的完成时间。</p>\n<p>得出状态转移方程（<span class=\"math inline\">\\(k\\)</span> 枚举上一批任务结束位置）： <span class=\"math display\">\\[\nf_{i,j}=\\min\\limits_{0\\leqslant k&lt;i}\\{f_{k,j-1}+(S\\times j+t_i)\\times(c_i-c_k)\\}\n\\]</span> 时间复杂度 <span class=\"math inline\">\\(\\mathcal O(n^3)\\)</span>。</p>\n<pre class=\"cpp\"><code>#include &lt;cstdio&gt;\n#include &lt;cstring&gt;\n#define int long long\nconst int inf = 1e18;\nconst int maxn = 5005;\nconst int LEN = (1 &lt;&lt; 20);\nint f[maxn][maxn];\nint n, s, ans = inf;\nint t[maxn], c[maxn];\ninline int min(int x, int y) &#123; return x &lt; y ? x : y; &#125;\n#ifdef ONLINE_JUDGE\ninline int nec(void) &#123;\n    static char buf[LEN], *p = buf, *e = buf;\n    if (p == e) &#123;\n        e = buf + fread(buf, 1, LEN, stdin);\n        if (e == buf) return EOF; p = buf;\n    &#125;\n    return *p++;\n&#125;\n#else\n#define nec getchar\n#endif\ninline bool read(int &amp;x) &#123;\n    char ch = nec();\n    bool f = 0; x = 0;\n    while (ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123;\n        if (ch == EOF) return 0;\n        if (ch == &#39;-&#39;) f = 1;\n        ch = nec();\n    &#125;\n    while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) &#123;\n        x = x * 10 + ch - &#39;0&#39;;\n        ch = nec();\n    &#125;\n    if (f) x = -x;\n    return 1;\n&#125;\nsigned main() &#123;\n    read(n); read(s);\n    memset(f, 0x3f, sizeof (f));\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        read(t[i]); read(c[i]);\n        t[i] += t[i - 1];\n        c[i] += c[i - 1];\n        f[i][1] = (s + t[i]) * c[i]; // 初始化\n    &#125;\n    for (int i = 2; i &lt;= n; ++i) &#123;\n        for (int j = 2; j &lt;= i; ++j) &#123;\n            for (int k = 1; k &lt; i; ++k)\n                f[i][j] = min(f[i][j], f[k][j - 1] + (t[i] + s * j) * (c[i] - c[k]));\n        &#125;\n    &#125;\n    for (int i = 1; i &lt;= n; ++i)\n        ans = min(ans, f[n][i]);\n    printf(&quot;%lld&quot;, ans);\n    return 0;\n&#125;</code></pre>\n<p><del>亲测 TLE 70</del></p>\n<h4 id=\"解法二\">解法二</h4>\n<p>脑子炸了，想了好久才想明白这个优化的正确性。</p>\n<p>思考，以上代码需要 <span class=\"math inline\">\\(j\\)</span> 这一维的根本原因是什么？</p>\n<p>因为我们无法确定之前已经划分了多少批，也就是无法确定 <span class=\"math inline\">\\(S\\)</span> 的个数。</p>\n<p>换个角度思考，我们无法确定之前，却可以确定之后。</p>\n<p>什么意思呢？如果我们在任务 <span class=\"math inline\">\\(i\\)</span> 处划分，那么任务 <span class=\"math inline\">\\(i\\)</span> 以及任务 <span class=\"math inline\">\\(i\\)</span> 以后的所有任务的执行时间都会延后 <span class=\"math inline\">\\(S\\)</span>。</p>\n<p>因为 <span class=\"math inline\">\\(i\\)</span> 以后的状态也会使用 <span class=\"math inline\">\\(f_i\\)</span> 的值，我们在计算 <span class=\"math inline\">\\(f_i\\)</span> 时就将 <span class=\"math inline\">\\(S\\)</span> 提出来，提前把后面的 <span class=\"math inline\">\\(c\\)</span> 乘上不就行了？</p>\n<p>中间的结果不对劲也无所谓，只要最后的答案是对的就行了。</p>\n<blockquote>\n<p>也就是说，我们没有直接求出每批任务的完成时刻，而是在一批任务<strong>「开始」</strong>对后续任务产生影响时，就先把费用累加到答案中。这是一种名为<strong>「费用提前计算」</strong>的经典思想。</p>\n<p align=\"right\">\n——李煜东《算法竞赛进阶指南》\n</p>\n</blockquote>\n<p>状态转移方程： <span class=\"math display\">\\[\nf_i=\\min\\limits_{0\\leqslant j&lt;i}\\{f_j+(c_i-c_j)\\times t_i+s\\times(c_n-c_j)\\}\n\\]</span> 此处，<span class=\"math inline\">\\(f_i\\)</span> 没有具体含义。</p>\n<pre class=\"cpp\"><code>#include &lt;cstdio&gt;\n#include &lt;cstring&gt;\n#define int long long\nconst int maxn = 1e4 + 5;\nconst int LEN = (1 &lt;&lt; 20);\nint n, s;\nint f[maxn], t[maxn], c[maxn];\ninline int min(int x, int y) &#123; return x &lt; y ? x : y; &#125;\n#ifdef ONLINE_JUDGE\ninline int nec(void) &#123;\n    static char buf[LEN], *p = buf, *e = buf;\n    if (p == e) &#123;\n        e = buf + fread(buf, 1, LEN, stdin);\n        if (e == buf) return EOF; p = buf;\n    &#125;\n    return *p++;\n&#125;\n#else\n#define nec getchar\n#endif\ninline bool read(int &amp;x) &#123;\n    char ch = nec();\n    bool f = 0; x = 0;\n    while (ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123;\n        if (ch == EOF) return 0;\n        if (ch == &#39;-&#39;) f = 1;\n        ch = nec();\n    &#125;\n    while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) &#123;\n        x = x * 10 + ch - &#39;0&#39;;\n        ch = nec();\n    &#125;\n    if (f) x = -x;\n    return 1;\n&#125;\nsigned main() &#123;\n    read(n); read(s);\n    memset(f, 0x3f, sizeof (f));\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        read(t[i]); read(c[i]);\n        t[i] += t[i - 1];\n        c[i] += c[i - 1];\n    &#125;\n    f[0] = 0;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        for (int j = 0; j &lt; i; ++j)\n            f[i] = min(f[i], f[j] + t[i]* (c[i] - c[j]) + s * (c[n] - c[j]));\n    &#125;\n    printf(&quot;%lld&quot;, f[n]);\n    return 0;\n&#125;</code></pre>\n<hr />\n<h3 id=\"任务安排-2\"><a href=\"https://loj.ac/p/10185\">任务安排 2</a></h3>\n<p><a href=\"https://www.acwing.com/problem/content/303/\">双倍经验</a></p>\n<p><span class=\"math inline\">\\(n\\)</span> 的范围变大了，<span class=\"math inline\">\\(n^2\\)</span> 过不了。</p>\n<p>这不随手加个斜率优化的事儿吗。</p>\n<p>我们继续瞎搞这个式子。 <span class=\"math display\">\\[\n\\begin{aligned}\nf_i&amp;=\\min\\{f_j+(c_i-c_j)\\times t_i+s\\times(c_n-c_j)\\}\n\\\\\n&amp;=\\min\\{f_j+c_i\\times t_i-c_j\\times t_i+s\\times c_n-s\\times c_j\\}\n\\\\\n&amp;=\\min\\{f_j-c_j\\times t_i-s\\times c_j\\}+c_i\\times t_i+s\\times c_n\n\\end{aligned}\n\\]</span> 令 <span class=\"math inline\">\\(j\\)</span> 优于 <span class=\"math inline\">\\(k\\)</span> 且 <span class=\"math inline\">\\(j&lt;k\\)</span> 。</p>\n<p>则有： <span class=\"math display\">\\[\nf_j-c_j\\times t_i-s\\times c_j&lt;f_k-c_k\\times t_i-s\\times c_k\n\\\\\nf_j-f_k-s\\times c_j+s\\times c_k&lt;c_j\\times t_i-c_k\\times t_i\n\\\\\nf_j-f_k-s\\times c_j+s\\times c_k&lt;t_i\\times(c_j-c_k)\n\\\\\n\\dfrac{(f_j-s\\times c_j)-(f_k-s\\times c_k)}{(c_j)-(c_k)}&lt;t_i\n\\]</span> 然后就是老套路。</p>\n<p>时间复杂度 <span class=\"math inline\">\\(\\mathcal O(n)\\)</span>。</p>\n<pre class=\"cpp\"><code>#include &lt;cstdio&gt;\n#define int long long\nconst int maxn = 5e5 + 5;\nconst int LEN = (1 &lt;&lt; 20);\nint n, s, L, R;\nint f[maxn], t[maxn], c[maxn], q[maxn];\n#define nec getchar\ninline bool read(int &amp;x) &#123;\n    char ch = nec();\n    bool f = 0; x = 0;\n    while (ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123;\n        if (ch == EOF) return 0;\n        if (ch == &#39;-&#39;) f = 1; ch = nec();\n    &#125;\n    while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) &#123;\n        x = x * 10 + ch - &#39;0&#39;;\n        ch = nec();\n    &#125;\n    if (f) x = -x;\n    return 1;\n&#125;\ninline int getup(int j, int k) &#123; return (f[j] - s * c[j]) - (f[k] - s * c[k]); &#125;\ninline int getdown(int j, int k) &#123; return (c[j]) - (c[k]); &#125;\ninline int getDP(int i, int j) &#123; return f[j] + (c[i] - c[j]) * t[i] + s * (c[n] - c[j]); &#125;\nsigned main() &#123;\n    read(n); read(s);\n    L = R = 1;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        read(t[i]); read(c[i]);\n        t[i] += t[i - 1];\n        c[i] += c[i - 1];\n    &#125;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        while (L &lt; R &amp;&amp; getup(q[L + 1], q[L]) &lt;= t[i] * getdown(q[L + 1], q[L]))\n            ++L;\n        f[i] = getDP(i, q[L]);\n        while (L &lt; R &amp;&amp; getup(i, q[R]) * getdown(q[R], q[R - 1]) &lt;= getdown(i, q[R]) * getup(q[R], q[R - 1]))\n            --R;\n        q[++R] = i;\n    &#125;\n    printf(&quot;%lld&quot;, f[n]);\n    return 0;\n&#125;</code></pre>\n<hr />\n<h3 id=\"任务安排-3\"><a href=\"https://www.luogu.com.cn/problem/P5785\">任务安排 3</a></h3>\n<p><a href=\"https://loj.ac/p/10186\">双倍经验</a> | <a href=\"https://www.acwing.com/problem/content/304/\">三倍经验</a></p>\n<p>注意 <span class=\"math inline\">\\(t\\)</span> 有可能是负数。</p>\n<p><span class=\"math inline\">\\(t\\)</span> （输入）有可能为负，代表着 <span class=\"math inline\">\\(t\\)</span>（前缀和）不再单调递增，用不单调的对象作为单调队列的条件一看就十分不讲武德，这样维护出来的队头显然不是正确答案。</p>\n<p>后面的 <span class=\"math inline\">\\(t,c\\)</span> 默认为前缀和。</p>\n<p>我们感性证明一下。</p>\n<p>一个最普通的例子，假设输入了一个负数，导致 <span class=\"math inline\">\\(t_i&lt;t_{i-1}\\)</span>，且有一斜率 <span class=\"math inline\">\\(&gt;t_i\\)</span> 且 <span class=\"math inline\">\\(&lt;t_{i-1}\\)</span>。</p>\n<p>那么在 <span class=\"math inline\">\\(i-1\\)</span> 时，它就被维护队头的操作剔掉了，但也许它凑巧就是 <span class=\"math inline\">\\(i\\)</span> 的最优解，呜呼哀哉。</p>\n<p>于是我们不能删队头元素了。那怎么查询最优解呢？</p>\n<p>单调队列里装的始终还是个具有单调性的下凸包，于是我们可以在队列中二分一个 <span class=\"math inline\">\\(pos\\)</span>，<span class=\"math inline\">\\(pos\\)</span> 与 <span class=\"math inline\">\\(pos-1\\)</span> 形成的斜率比 <span class=\"math inline\">\\(t_i\\)</span> 小，<span class=\"math inline\">\\(pos+1\\)</span> 与 <span class=\"math inline\">\\(pos\\)</span> 形成的斜率比 <span class=\"math inline\">\\(t_i\\)</span> 大。</p>\n<p>然后把 <span class=\"math inline\">\\(pos\\)</span> 当成 <span class=\"math inline\">\\(q_l\\)</span> 来处理就好了。</p>\n<p>队尾还是维护一个下凸。</p>\n<p>时间复杂度 <span class=\"math inline\">\\(\\mathcal O(n\\log_2n)\\)</span>。</p>\n<p><em>强烈建议不要去动 AcWing 版本的那道。</em></p>\n<p><em>最后两组数据堪称毒瘤。</em></p>\n<p><em>卡 <code>long long</code> 乘法，卡 <code>__int128</code> 时限，卡 <code>double</code>精度，非 T 即 WA。</em></p>\n<p><em>反正我搞了半个小时硬是没有搞出来。</em></p>\n<pre class=\"cpp\"><code>#include &lt;cstdio&gt;\n#define int long long\nconst int maxn = 3e5 + 5;\nconst int LEN = (1 &lt;&lt; 20);\nint n, s, L, R;\nint f[maxn], t[maxn], c[maxn], q[maxn];\n#define nec getchar\ninline bool read(int &amp;x) &#123;\n    char ch = nec();\n    bool f = 0; x = 0;\n    while (ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123;\n        if (ch == EOF) return 0;\n        if (ch == &#39;-&#39;) f = 1; ch = nec();\n    &#125;\n    while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) &#123;\n        x = x * 10 + ch - &#39;0&#39;;\n        ch = nec();\n    &#125;\n    if (f) x = -x;\n    return 1;\n&#125;\ninline int getup(int j, int k) &#123; return (f[j] - s * c[j]) - (f[k] - s * c[k]); &#125;\ninline int getdown(int j, int k) &#123; return (c[j]) - (c[k]); &#125;\ninline int getDP(int i, int j) &#123; return f[j] + t[i] * (c[i] - c[j]) + s * (c[n] - c[j]); &#125;\ninline int Func(int u) &#123;\n    if (L == R) return q[L];\n    int l = L, r = R;\n    while (l &lt; r) &#123;\n        int mid = l + r &gt;&gt; 1;\n        if (getup(q[mid + 1], q[mid]) &lt;= u * getdown(q[mid + 1], q[mid]))\n            l = mid + 1;\n        else r = mid;\n    &#125;\n    return l;\n&#125;\nsigned main() &#123;\n    read(n); read(s);\n    L = R = 1;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        read(t[i]); read(c[i]);\n        t[i] += t[i - 1];\n        c[i] += c[i - 1];\n    &#125;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        int Best = Func(t[i]);\n        f[i] = getDP(i, q[Best]);\n        while (L &lt; R &amp;&amp; getup(i, q[R]) * getdown(q[R], q[R - 1]) &lt;= getdown(i, q[R]) * getup(q[R], q[R - 1]))\n            --R;\n        q[++R] = i;\n    &#125;\n    printf(&quot;%lld&quot;, f[n]);\n    return 0;\n&#125;</code></pre>\n<hr />\n<h3 id=\"土地购买\"><a href=\"https://www.luogu.com.cn/problem/P2900\">土地购买</a></h3>\n<p>首先我们想明白一件事情：如果一块土地，有另一块土地的长和宽都比它大，那就不用再理它了，直接从总序列里剔除。</p>\n<pre class=\"cpp\"><code>struct _ &#123;\n    int w, l;\n    bool operator&lt; (const _ q) const &#123;\n        return w == q.w ? l &gt; q.l : w &gt; q.w;\n    &#125;\n&#125; a[maxn];\n...\n\nstd::sort(a + 1, a + n + 1);\nfor (int i = 1; i &lt;= n; ++i) &#123;\n    if (a[i].l &gt; a[cnt].l)\n        a[++cnt] = a[i];\n&#125;</code></pre>\n<p>然后就推式子。</p>\n<p>贪心地想，在前面的操作后，<span class=\"math inline\">\\(a\\)</span> 是一个 <span class=\"math inline\">\\(w\\)</span> 递减，<span class=\"math inline\">\\(l\\)</span> 递增的土地序列。</p>\n<p>所以我们选择将连续的一段区间分为一组，这样的话，一个组里的一段连续的土地 <span class=\"math inline\">\\([x,y]\\)</span> 就只有 <span class=\"math inline\">\\(w_x\\)</span> 和 <span class=\"math inline\">\\(l_y\\)</span> 起了作用，又没有中间那一段的事了。</p>\n<p>设 <span class=\"math inline\">\\(f_i\\)</span> 表示分配完第 <span class=\"math inline\">\\(i\\)</span> 块土地后的最小花费。</p>\n<p>则有： <span class=\"math display\">\\[\nf_i=\\min\\{f_j+w_{j+1}\\times l_i\\}\n\\]</span> 令 <span class=\"math inline\">\\(j\\)</span> 优于 <span class=\"math inline\">\\(k\\)</span>。</p>\n<p>则有： <span class=\"math display\">\\[\nf_j+w_{j+1}\\times l_i&lt;f_k+w_{k+1}\\times l_i\n\\\\\nf_j-f_k&lt;(-w_{j+1}+w_{k+1})\\times l_i\n\\\\\n\\dfrac{(f_j)-(f_k)}{(-w_{j+1})+(w_{k+1})}&lt;l_i\n\\]</span></p>\n<pre class=\"cpp\"><code>#include &lt;cstdio&gt;\n#include &lt;algorithm&gt;\n#define int long long\nconst int maxn = 5e4 + 5;\nstruct _ &#123;\n    int w, l;\n    bool operator&lt; (const _ q) const&#123;\n        return w == q.w ? l &gt; q.l : w &gt; q.w;\n    &#125;\n&#125;;\n_ a[maxn];\nint n, cnt, l, r;\nint q[maxn], f[maxn];\nint getup(int j, int k) &#123; return f[j] - f[k]; &#125;\nint getdown(int j,int k) &#123; return a[k + 1].w - a[j + 1].w; &#125;\nint getDP(int i,int j) &#123; return f[j] + a[j + 1].w * a[i].l; &#125;\nsigned main() &#123;\n    scanf(&quot;%lld&quot;, &amp;n);\n    for(int i = 1; i &lt;= n; ++i)\n        scanf(&quot;%lld %lld&quot;, &amp;a[i].w, &amp;a[i].l);\n    std::sort(a + 1, a + n + 1);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        if (a[i].l &gt; a[cnt].l)\n            a[++cnt] = a[i];\n    &#125;\n    n = cnt; l = r = 1;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        while (l &lt; r &amp;&amp; getup(q[l + 1], q[l]) &lt;= a[i].l * getdown(q[l + 1], q[l]))\n            l++;\n        f[i] = getDP(i, q[l]);\n        while (l &lt; r &amp;&amp; getup(i, q[r]) * getdown(q[r], q[r - 1]) &lt;= getup(q[r],q[r - 1]) * getdown(i, q[r]))\n            r--;\n        q[++r] = i;\n    &#125;\n    printf(&quot;%lld&quot;, f[n]);\n    return 0;\n&#125;</code></pre>\n<hr />\n<h3 id=\"仓库建设\"><a href=\"https://www.luogu.com.cn/problem/P2120\">仓库建设</a></h3>\n<p><a href=\"https://loj.ac/p/10189\">双倍经验</a> | <a href=\"https://www.acwing.com/problem/content/description/1095/\">三倍经验</a></p>\n<p>设 <span class=\"math inline\">\\(f_i\\)</span> 表示在 <span class=\"math inline\">\\(i\\)</span> 工厂建立仓库的最小花费。</p>\n<p>则有： <span class=\"math display\">\\[\n\\begin{aligned}\nf_i&amp;=\\min\\{f_j+\\sum\\limits_{k=j+1}^{i-1}[(x_i-x_k)\\times p_k]+c_i\\}\n\\\\\n&amp;=\\min\\{f_j+\\sum\\limits_{k=j+1}^{i-1}(x_i\\times p_k)-\\sum\\limits_{k=j+1}^{i-1}(x_k\\times p_k)\\}+c_i\n\\\\\n&amp;=\\min\\{f_j+x_i\\times\\sum\\limits_{k=j+1}^{i-1}p_k-\\sum\\limits_{k=j+1}^{i-1}(x_k\\times p_k)\\}+c_i\n\\end{aligned}\n\\]</span> 利用前缀和优化：设 <span class=\"math inline\">\\(a\\)</span> 为 <span class=\"math inline\">\\(p\\)</span> 的前缀和数组，<span class=\"math inline\">\\(b\\)</span> 为 <span class=\"math inline\">\\(x_i\\times p_i\\)</span> 的前缀和数组。</p>\n<p>则原式可化为： <span class=\"math display\">\\[\n\\begin{aligned}\nf_i&amp;=\\min\\{f_j+x_i\\times(a_{i-1}-a_j)-(b_{i-1}-b_j)\\}+c_i\n\\\\\n&amp;=\\min\\{f_j+x_i\\times a_{i-1}-x_i\\times a_j-b_{i-1}+b_j\\}+c_i\n\\\\\n&amp;=\\min\\{f_j-x_i\\times a_j+b_j\\}+x_i\\times a_{i-1}-b_{i-1}+c_i\n\\end{aligned}\n\\]</span> 令 <span class=\"math inline\">\\(j\\)</span> 优于 <span class=\"math inline\">\\(k\\)</span> 。</p>\n<p>则有： <span class=\"math display\">\\[\nf_j-x_i\\times a_j+b_j&lt;f_k-x_i\\times a_k+b_k\n\\\\\nf_j-f_k+b_j-b_k&lt;x_i\\times a_j-x_i\\times a_k\n\\\\\n\\dfrac{(f_j+b_j)-(f_k+b_k)}{a_j-a_k}&lt;x_i\n\\]</span></p>\n<p><em>想感受人生的同学们可以尝试做一下 AcWing 那个版本，非 MLE 即 WA，爽到炸。</em></p>\n<pre class=\"cpp\"><code>#include &lt;cstdio&gt;\n#define int long long\nconst int maxn = 1e6 + 5;\nconst int LEN = (1 &lt;&lt; 20);\nint n, L, R;\nint f[maxn], x[maxn], p[maxn];\nint a[maxn], b[maxn], c[maxn], q[maxn];\n#ifdef ONLINE_JUDGE\ninline int nec(void) &#123;\n    static char buf[LEN], *p = buf, *e = buf;\n    if (p == e) &#123;\n        e = buf + fread(buf, 1, LEN, stdin);\n        if (e == buf) return EOF; p = buf;\n    &#125;\n    return *p++;\n&#125;\n#else\n#define nec getchar\n#endif\ninline bool read(int &amp;x) &#123;\n    char ch = nec();\n    bool f = 0; x = 0;\n    while (ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123;\n        if (ch == EOF) return 0;\n        if (ch == &#39;-&#39;) f = 1;\n        ch = nec();\n    &#125;\n    while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) &#123;\n        x = x * 10 + ch - &#39;0&#39;;\n        ch = nec();\n    &#125;\n    if (f) x = -x;\n    return 1;\n&#125;\ninline int getup(int j, int k) &#123; return (f[j] + b[j]) - (f[k] + b[k]); &#125;\ninline int getdown(int j, int k) &#123; return (a[j]) - (a[k]); &#125;\ninline int getDP(int i, int j) &#123; return f[j] - x[i] * a[j] + b[j] + x[i] * a[i - 1] - b[i - 1] + c[i]; &#125;\nsigned main() &#123;\n    read(n); L = R = 1;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        read(x[i]); read(p[i]); read(c[i]);\n        a[i] = a[i - 1] + p[i];\n        b[i] = b[i - 1] + x[i] * p[i];\n    &#125;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        while (L &lt; R &amp;&amp; getup(q[L + 1], q[L]) &lt;= x[i] * getdown(q[L + 1], q[L]))\n            ++L;\n        f[i] = getDP(i, q[L]);\n        while (L &lt; R &amp;&amp; getup(i, q[R]) * getdown(q[R], q[R - 1]) &lt;= getdown(i, q[R]) * getup(q[R], q[R - 1]))\n            --R;\n        q[++R] = i;\n    &#125;\n    printf(&quot;%lld&quot;, f[n]);\n    return 0;\n&#125;</code></pre>\n<hr />\n<h3 id=\"锯木厂选址\"><a href=\"https://www.luogu.com.cn/problem/P4360\">锯木厂选址</a></h3>\n<p><a href=\"https://loj.ac/p/10192\">双倍经验</a> | <a href=\"https://www.acwing.com/problem/content/1097/\">三倍经验</a></p>\n<p>和仓库建设很像。</p>\n<p>设 <span class=\"math inline\">\\(A_i=\\sum\\limits_{j=i}^nd_j\\)</span>，表示第 <span class=\"math inline\">\\(i\\)</span> 棵树与山脚的距离；<span class=\"math inline\">\\(B_i=\\sum\\limits_{j=1}^iw_j\\)</span>，表示 <span class=\"math inline\">\\(w\\)</span> 的前缀和；<span class=\"math inline\">\\(S=\\sum\\limits_{i=1}^nA_i\\times w_i\\)</span>，表示将所有树全部运到山脚的花费总和。</p>\n<p>假设在 <span class=\"math inline\">\\(j\\)</span> 处建立第 <span class=\"math inline\">\\(1\\)</span> 座锯木厂，在 <span class=\"math inline\">\\(i\\)</span> 处建立第 <span class=\"math inline\">\\(2\\)</span> 座锯木厂，此时：</p>\n<ul>\n<li>对于第 <span class=\"math inline\">\\(1\\sim j\\)</span> 棵树来说，<span class=\"math inline\">\\(S\\)</span> 比实际情况多运了 <span class=\"math inline\">\\(A_j\\)</span> 的路程；</li>\n<li>对于第 <span class=\"math inline\">\\(j+1\\sim i\\)</span> 棵树来说，<span class=\"math inline\">\\(S\\)</span> 比实际情况多运了 <span class=\"math inline\">\\(A_i\\)</span> 的路程。</li>\n</ul>\n<p>将对应的多运的距离与花费相乘的结果，让 <span class=\"math inline\">\\(S\\)</span> 将其减去即可。 <span class=\"math display\">\\[\n\\begin{aligned}\nans&amp;=\\min\\{S-A_j\\times B_j-(B_i-B_j)\\times A_i\\}\\\\\n   &amp;=\\min\\{A_i\\times B_j-A_j\\times B_j\\}+S-A_i\\times B_i\n\\end{aligned}\n\\]</span> 令 <span class=\"math inline\">\\(j&lt;k\\)</span> 且 <span class=\"math inline\">\\(j\\)</span> 优于 <span class=\"math inline\">\\(k\\)</span>，则有： <span class=\"math display\">\\[\n\\begin{aligned}\nA_i\\times B_j-A_j\\times B_j&amp;&lt;A_i\\times B_k-A_k\\times B_k\\\\\n-A_j\\times B_j+A_k\\times B_k&amp;&lt;-A_i\\times B_j+A_i\\times B_k\\\\\n\\dfrac{-A_j\\times B_j+A_k\\times B_k}{-B_j+B_k}&amp;&lt;A_i\\\\\n\\dfrac{A_j\\times B_j-A_k\\times B_k}{B_j-B_k}&amp;&lt;A_i\\\\\n\\end{aligned}\n\\]</span> 其中，<span class=\"math inline\">\\(A_i\\)</span> 具有单调性，可以直接套板子。</p>\n<pre class=\"cpp\"><code>#include &lt;cstdio&gt;\n#include &lt;cstring&gt;\n#include &lt;algorithm&gt;\n#define int long long\nconst int inf = 1e18;\nconst int maxn = 1e6 + 5;\nconst int LEN = (1 &lt;&lt; 20);\nint w[maxn], d[maxn];\nint n, L, R, s, ans = inf;\nint q[maxn], a[maxn], b[maxn];\ninline int min(int x, int y) &#123; return x &lt; y ? x : y; &#125;\ninline int getDP(int i, int j) &#123;\n    return s - a[j] * b[j] - (b[i] - b[j]) * a[i];\n&#125;\ninline int getup(int j, int k) &#123;\n    return a[j] * b[j] - a[k] * b[k];\n&#125;\ninline int getdown(int j, int k) &#123;\n    return b[j] - b[k];\n&#125;\n#ifdef ONLINE_JUDGE\ninline int nec(void) &#123;\n    static char buf[LEN], *p = buf, *e = buf;\n    if (p == e) &#123;\n        e = buf + fread(buf, 1, LEN, stdin);\n        if (e == buf) return EOF; p = buf;\n    &#125;\n    return *p++;\n&#125;\n#else\n#define nec getchar\n#endif\ninline bool read(int &amp;x) &#123;\n    char ch = nec();\n    bool f = 0; x = 0;\n    while (ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123;\n        if (ch == EOF) return 0;\n        if (ch == &#39;-&#39;) f = 1;\n        ch = nec();\n    &#125;\n    while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) &#123;\n        x = x * 10 + ch - &#39;0&#39;;\n        ch = nec();\n    &#125;\n    if (f) x = -x;\n    return 1;\n&#125;\nsigned main() &#123;\n    read(n);\n    L = R = 1;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        read(w[i]), read(d[i]);\n        b[i] = b[i - 1] + w[i];\n    &#125;\n    for (int i = n; i; --i) &#123;\n        a[i] = a[i + 1] + d[i];\n        s += a[i] * w[i];\n    &#125;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        while (L &lt; R &amp;&amp; getup(q[L + 1], q[L]) &gt;= a[i] * getdown(q[L + 1], q[L]))\n            ++L;\n        ans = min(ans, getDP(i, q[L]));\n        while (L &lt; R &amp;&amp; getup(i, q[R]) * getdown(q[R], q[R - 1]) &gt;= getup(q[R], q[R - 1]) * getdown(i, q[R]))\n            --R;\n        q[++R] = i;\n    &#125;\n    printf(&quot;%lld&quot;, ans);\n    return 0;\n&#125;</code></pre>\n<hr />\n<h3 id=\"cats-transport\"><a href=\"https://www.luogu.com.cn/problem/CF311B\">Cats Transport</a></h3>\n<p><a href=\"https://www.acwing.com/problem/content/305/\">双倍经验</a> | <a href=\"http://codeforces.com/problemset/problem/311/B\">三倍经验</a></p>\n<p>经验：洛谷的题面比蓝书和 AcWing 上的标准多了，蓝书的题意不清。</p>\n<p>研究表明，边猛灌养乐多边看蓝书有助于理解。</p>\n<p>这道题难在推式子。<del>不然还能难在哪里</del></p>\n<p>设 <span class=\"math inline\">\\(A_i\\)</span> 表示要接到第 <span class=\"math inline\">\\(i\\)</span> 只猫的最早出发时间，也就是说，在此时出发，猫 <span class=\"math inline\">\\(i\\)</span> 的等待时间为 <span class=\"math inline\">\\(0\\)</span>。</p>\n<p>即 <span class=\"math inline\">\\(A_i=T_i-\\sum\\limits_{j=1}^{H_i}D_j\\)</span>，也就是出发时间=到达时间-经过时间。</p>\n<p>此时我们可以把其他所有因素去掉，题意转换为：</p>\n<blockquote>\n<p>已知在 <span class=\"math inline\">\\(\\geqslant A_i\\)</span> 的时刻出发可以接到猫 <span class=\"math inline\">\\(i\\)</span> ，在 <span class=\"math inline\">\\(P\\)</span> 次出发次数的限制内接到所有猫，猫的等待时间之和最小是多少？</p>\n</blockquote>\n<p>假设饲养员在 <span class=\"math inline\">\\(t\\)</span> 时刻出发，猫 <span class=\"math inline\">\\(i\\)</span> 的等待时间就是 <span class=\"math inline\">\\(t-A_i\\)</span>。</p>\n<p>对 <span class=\"math inline\">\\(A_i\\)</span> 从小到大排序。</p>\n<p>显然，一次接一段连续的猫，花费自然是最小的。</p>\n<p>若我们要接 <span class=\"math inline\">\\([k+1,j]\\)</span> 范围内的猫，它们的等待时间之和就是： <span class=\"math display\">\\[\n\\begin{aligned}\n\\sum\\limits_{p=k+1}^{j}(A_j-A_p)&amp;=[j-(k+1)+1]A_j-\\sum\\limits_{p=k+1}^{j}A_p\n\\\\\n&amp;=(j-k)\\times A_j-(S_j-S_k)\n\\\\\n&amp;=j\\times A_j-k\\times A_j-S_j+S_k\n\\end{aligned}\n\\]</span> 其中 <span class=\"math inline\">\\(S\\)</span> 为 <span class=\"math inline\">\\(A\\)</span> 的前缀和。</p>\n<p>设 <span class=\"math inline\">\\(f_{i,j}\\)</span> 表示前 <span class=\"math inline\">\\(i\\)</span> 个饲养员带走前 <span class=\"math inline\">\\(j\\)</span> 只猫的最小花费。</p>\n<p>则有： <span class=\"math display\">\\[\n\\begin{aligned}\nf_{i,j}&amp;=\\min\\{f_{i-1,k}+j\\times A_j-k\\times A_j-S_j+S_k\\}\n\\\\\n&amp;=\\min\\{f_{i-1,k}-A_j\\times k+S_k\\}+A_j\\times j-S_j\n\\end{aligned}\n\\]</span></p>\n<p>我们将循环地枚举每个饲养员的循环变量 <span class=\"math inline\">\\(i\\)</span> 看做常量。</p>\n<p>令 <span class=\"math inline\">\\(x\\)</span> 优于 <span class=\"math inline\">\\(y\\)</span>，则有： <span class=\"math display\">\\[\nf_{i-1,x}-A_j\\times x+S_x&lt;f_{i-1,y}-A_j\\times y+S_y\n\\\\\n\\dfrac{(f_{i-1,x}+S_x)-(f_{i-1,y+S_y})}{x-y}&lt;A_j\n\\]</span> <strong>注意事项</strong></p>\n<p><span class=\"math inline\">\\(f\\)</span> 初始化为极大值。</p>\n<pre class=\"cpp\"><code>#include &lt;cstdio&gt;\n#include &lt;cstring&gt;\n#include &lt;algorithm&gt;\n#define int long long\nconst int maxp = 105;\nconst int maxn = 1e5 + 5;\nconst int LEN = (1 &lt;&lt; 20);\nint f[maxp][maxn];\nint n, m, p, L, R, t, h;\nint q[maxn], a[maxn], d[maxn], s[maxn];\ninline int getDP(int i, int j, int k) &#123;\n    return f[i - 1][k] + (j - k) * a[j] - (s[j] - s[k]);\n&#125;\ninline int getup(int i, int j, int k) &#123;\n    return (f[i - 1][j] + s[j]) - (f[i - 1][k] + s[k]);\n&#125;\ninline int getdown(int j, int k) &#123;\n    return (j) - (k);\n&#125;\n#ifdef ONLINE_JUDGE\ninline int nec(void) &#123;\n    static char buf[LEN], *p = buf, *e = buf;\n    if (p == e) &#123;\n        e = buf + fread(buf, 1, LEN, stdin);\n        if (e == buf) return EOF; p = buf;\n    &#125;\n    return *p++;\n&#125;\n#else\n#define nec getchar\n#endif\ninline bool read(int &amp;x) &#123;\n    char ch = nec();\n    bool f = 0; x = 0;\n    while (ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123;\n        if (ch == EOF) return 0;\n        if (ch == &#39;-&#39;) f = 1;\n        ch = nec();\n    &#125;\n    while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) &#123;\n        x = x * 10 + ch - &#39;0&#39;;\n        ch = nec();\n    &#125;\n    if (f) x = -x;\n    return 1;\n&#125;\nsigned main() &#123;\n    read(n); read(m); read(p);\n    memset(f, 0x3f, sizeof (f));\n    for (int i = 2; i &lt;= n; ++i)\n        read(d[i]), d[i] += d[i - 1];\n    for (int i = 1; i &lt;= m; ++i) &#123;\n        read(h); read(t);\n        a[i] = t - d[h];\n    &#125;\n    std::sort(a + 1, a + m + 1);\n    for (int i = 1; i &lt;= m; ++i)\n        s[i] = s[i - 1] + a[i];\n    f[0][0] = 0;\n    for (int i = 1; i &lt;= p; ++i) &#123;\n        L = R = 1;\n        for (int j = 1; j &lt;= m; ++j) &#123;\n            while (L &lt; R &amp;&amp; getup(i, q[L + 1], q[L]) &lt;= a[j] * getdown(q[L + 1], q[L]))\n                ++L;\n            f[i][j] = getDP(i, j, q[L]);\n            while (L &lt; R &amp;&amp; getup(i, j, q[R]) * getdown(q[R], q[R - 1]) &lt;= getup(i, q[R], q[R - 1]) * getdown(j, q[R]))\n                --R;\n            q[++R] = j;\n        &#125;\n    &#125;\n    printf(&quot;%lld&quot;, f[p][m]);\n    return 0;\n&#125;</code></pre>\n<hr />\n<h3 id=\"特别行动队\"><a href=\"https://www.luogu.com.cn/problem/P3628\">特别行动队</a></h3>\n<p><a href=\"https://www.acwing.com/problem/content/337/\">双倍经验</a> | <a href=\"https://loj.ac/p/10190\">三倍经验</a></p>\n<p>直接推式子。 <span class=\"math display\">\\[\n\\begin{aligned}\nf_i&amp;=\\max\\{f_j+a\\times(s_i-s_j)^2+b\\times(s_i-s_j)+c\\ \\}\\\\\n&amp;=\\max\\{f_j+a\\times({s_i}^2-2\\times s_i\\times s_j+{s_j}^2)+b\\times s_i-b\\times s_j\\ \\}+c\\\\\n&amp;=\\max\\{f_j+a\\times{s_i}^2-2\\times a\\times s_i\\times s_j+a\\times{s_j}^2-b\\times s_j\\ \\}+b\\times s_i+c\\\\\n&amp;=\\max\\{f_j-2\\times a\\times s_i\\times s_j+a\\times{s_j}^2-b\\times s_j\\ \\}+a\\times{s_i}^2+b\\times s_i+c\\\\\n\\end{aligned}\n\\]</span> 令 <span class=\"math inline\">\\(j\\)</span> 优于 <span class=\"math inline\">\\(k\\)</span>，则有： <span class=\"math display\">\\[\n\\begin{aligned}\nf_j-2\\times a\\times s_i\\times s_j+a\\times{s_j}^2-b\\times s_j&amp;&gt;f_k-2\\times a\\times s_i\\times s_k+a\\times{s_k}^2-b\\times s_k\\\\\n(f_j+a\\times{s_j}^2-b\\times s_j)-(f_k+a\\times{s_k}^2-b\\times s_k)&amp;&gt;(2\\times a\\times s_i\\times s_j)-(2\\times a\\times s_i\\times s_k)\\\\\n\\dfrac{(f_j+a\\times{s_j}^2-b\\times s_j)-(f_k+a\\times{s_k}^2-b\\times s_k)}{(2\\times a\\times s_j) - (2\\times a\\times s_k)}&amp;&gt;s_i\\\\\n\\end{aligned}\n\\]</span> 我们发现中间的符号是 <span class=\"math inline\">\\(&gt;\\)</span>。</p>\n<p>所以我们在弹队头的时候，要把判断条件中的符号反过来。</p>\n<pre class=\"cpp\"><code>#include &lt;cstdio&gt;\n#include &lt;cstring&gt;\n#include &lt;algorithm&gt;\n#define int long long\nconst int maxn = 1e6 + 5;\nconst int LEN = (1 &lt;&lt; 20);\nint n, L, R, a, b ,c;\nint q[maxn], s[maxn], f[maxn];\ninline int getDP(int i, int j) &#123;\n    return f[j] + a * (s[i] - s[j]) * (s[i] - s[j]) + b * (s[i] - s[j]) + c;\n&#125;\ninline int getup(int j, int k) &#123;\n    return (f[j] + a * s[j] * s[j] - b * s[j]) - (f[k] + a * s[k] * s[k] - b * s[k]);\n&#125;\ninline int getdown(int j, int k) &#123;\n    return (2 * a * s[j]) - (2 * a * s[k]);\n&#125;\n#ifdef ONLINE_JUDGE\ninline int nec(void) &#123;\n    static char buf[LEN], *p = buf, *e = buf;\n    if (p == e) &#123;\n        e = buf + fread(buf, 1, LEN, stdin);\n        if (e == buf) return EOF; p = buf;\n    &#125;\n    return *p++;\n&#125;\n#else\n#define nec getchar\n#endif\ninline bool read(int &amp;x) &#123;\n    char ch = nec();\n    bool f = 0; x = 0;\n    while (ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123;\n        if (ch == EOF) return 0;\n        if (ch == &#39;-&#39;) f = 1;\n        ch = nec();\n    &#125;\n    while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) &#123;\n        x = x * 10 + ch - &#39;0&#39;;\n        ch = nec();\n    &#125;\n    if (f) x = -x;\n    return 1;\n&#125;\nsigned main() &#123;\n    read(n); read(a); read(b); read(c);\n    L = R = 1;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        read(s[i]), s[i] += s[i - 1];\n        while (L &lt; R &amp;&amp; getup(q[L + 1], q[L]) &gt;= s[i] * getdown(q[L + 1], q[L]))\n            ++L;\n        f[i] = getDP(i, q[L]);\n        while (L &lt; R &amp;&amp; getup(i, q[R]) * getdown(q[R], q[R - 1]) &lt;= getup(q[R], q[R - 1]) * getdown(i, q[R]))\n            --R;\n        q[++R] = i;\n    &#125;\n    printf(&quot;%lld&quot;, f[n]);\n    return 0;\n&#125;</code></pre>\n<hr />\n<h3 id=\"征途\"><a href=\"https://www.luogu.com.cn/problem/P4072\">征途</a></h3>\n<p><a href=\"https://loj.ac/p/2035\">双倍经验</a> | <a href=\"https://www.acwing.com/problem/content/2575/\">三倍经验</a></p>\n<p>明显，不化掉 <span class=\"math inline\">\\(v\\times m^2\\)</span> 就无法进行优化。</p>\n<p>设 <span class=\"math inline\">\\(x\\)</span> 为当前休息站点与上一休息站点的距离， <span class=\"math inline\">\\(x_0\\)</span> 为 <span class=\"math inline\">\\(x_1\\sim x_n\\)</span> 的平均数，<span class=\"math inline\">\\(S\\)</span> 为 <span class=\"math inline\">\\(x\\)</span> 的前缀和。 <span class=\"math display\">\\[\n\\begin{aligned}\nV\\times m^2&amp;=[(x_1-x_0)^2+(x_2-x_0)^2+\\cdots+(x_m-x_0)^2]\\times m\n\\\\\n&amp;=m\\times \\sum\\limits_{i=1}^{m}{x_i}^2+(m\\times {x_0})^2-2\\times (x_0\\times m)\\times \\sum\\limits_{i=1}^{m}x_i\n\\\\\n&amp;=m\\times \\sum\\limits_{i=1}^{m}{x_i}^2+{S_m}^2-2\\times{S_m}^2\n\\\\\n&amp;=m\\times \\sum\\limits_{i=1}^{m}{x_i}^2-{S_m}^2\n\\end{aligned}\n\\]</span></p>\n<p>其中 <span class=\"math inline\">\\(S_m\\)</span> 是一个定值（即输入所有路的长度和）。</p>\n<p>唯一需要计算的，就是 <span class=\"math inline\">\\(\\sum\\limits_{i=1}^{m}{x_i}^{2}\\)</span>，所以我们就来 DP 它。</p>\n<p>设 <span class=\"math inline\">\\(a\\)</span> 为输入道路长度的前缀和数组，<span class=\"math inline\">\\(f_{i,j}\\)</span> 表示第 <span class=\"math inline\">\\(i\\)</span> 次休息在 <span class=\"math inline\">\\(j\\)</span> 处时 <span class=\"math inline\">\\(\\min\\{\\sum\\limits_{k=1}^{i}{x_k}^2\\}\\)</span> 的值，则有： <span class=\"math display\">\\[\n\\begin{aligned}\nf_{i,j}&amp;=\\min\\{f_{i-1,j}+(a_i-a_j)^2\\}\n\\\\\n&amp;=\\min\\{f_{i-1,j}+{a_i}^2-2\\times a_i\\times a_j+{a_j}^2\\}\n\\end{aligned}\n\\]</span> 令 <span class=\"math inline\">\\(j\\)</span> 优于 <span class=\"math inline\">\\(k\\)</span>，则有： <span class=\"math display\">\\[\nf_{i-1,j}-2\\times a_i\\times a_j+{a_j}^2&lt;f_{i-1,k}-2\\times a_i\\times a_k+{a_k}^2\n\\\\\nf_{i-1,j}-f_{i-1,k}+{a_j}^2-{a_k}^2&lt;2\\times a_i\\times(a_j-a_k)\n\\\\\n\\dfrac{f_{i-1,j}-f_{i-1,k}+{a_j}^2-{a_k}^2}{2\\times(a_j-a_k)}&lt;a_i\n\\]</span></p>\n<p>初始化。</p>\n<p>将 <span class=\"math inline\">\\(f\\)</span> 初始化为极大值。</p>\n<p>在 AcWing 上将 <code>memset</code> 改为初始化 <code>f[0][i] = a[i] * a[i]</code> 就可以过了，不然会 MLE，也许是因为没开滚动。（本来也用不着滚</p>\n<pre class=\"cpp\"><code>#include &lt;cstdio&gt;\n#define int long long\nconst int inf = 1e18;\nconst int maxn = 3005;\nconst int LEN = (1 &lt;&lt; 20);\nint f[maxn][maxn];\nint a[maxn], q[maxn];\nint n, m, L, R, ans = inf;\n#ifdef ONLINE_JUDGE\ninline int nec(void) &#123;\n    static char buf[LEN], *p = buf, *e = buf;\n    if (p == e) &#123;\n        e = buf + fread(buf, 1, LEN, stdin);\n        if (e == buf) return EOF; p = buf;\n    &#125;\n    return *p++;\n&#125;\n#else\n#define nec getchar\n#endif\ninline bool read(int &amp;x) &#123;\n    char ch = nec();\n    bool f = 0; x = 0;\n    while (ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123;\n        if (ch == EOF) return 0;\n        if (ch == &#39;-&#39;) f = 1;\n        ch = nec();\n    &#125;\n    while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) &#123;\n        x = x * 10 + ch - &#39;0&#39;;\n        ch = nec();\n    &#125;\n    if (f) x = -x;\n    return 1;\n&#125;\ninline int min(int x, int y) &#123; return x &lt; y ? x : y; &#125;\nint getDP(int i, int j, int k) &#123;\n    return f[k - 1][j] + (a[i] - a[j]) * (a[i] - a[j]);\n&#125;\nint getup(int j, int k, int i) &#123;\n    return f[i - 1][j] - f[i - 1][k] + a[j] * a[j] - a[k] * a[k];\n&#125;\nint getdown(int j, int k) &#123;\n    return (a[j] - a[k]) &lt;&lt; 1;\n&#125;\nsigned main()&#123;\n    read(n); read(m);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        read(a[i]);\n        a[i] += a[i - 1];\n        f[0][i] = a[i] * a[i];\n    &#125;\n    for (int i = 1; i &lt; m; ++i) &#123;\n        L = R = 1; q[L] = i;\n        for (int j = i; j &lt;= n; ++j) &#123;\n            while (L &lt; R &amp;&amp; getup(q[L + 1], q[L], i) &lt;= a[j] * getdown(q[L + 1], q[L]))\n                ++L;\n            f[i][j] = getDP(j, q[L], i);\n            while (L &lt; R &amp;&amp; getup(i, q[R], i) * getdown(q[R], q[R - 1]) &lt;= getup(q[R], q[R - 1], i) * getdown(i, q[R]))\n                --R;\n            q[++R] = j;\n        &#125;\n    &#125;\n    printf(&quot;%lld&quot;,m * f[m - 1][n] - a[n] * a[n]);\n    return 0;\n&#125;</code></pre>\n<hr />\n<h3 id=\"柠檬\"><a href=\"https://www.luogu.com.cn/problem/P5504\">柠檬</a></h3>\n<p><a href=\"https://www.acwing.com/problem/content/2396/\">双倍经验</a></p>\n<p>是边写这篇题解边做的（</p>\n<p>题意：</p>\n<p>有一个含有 <span class=\"math inline\">\\(n\\)</span> 个元素的序列 <span class=\"math inline\">\\(s\\)</span>。将这个序列分成连续的若干段，定义每一段的价值为「在这一段当中任选某个元素的个数的平方再乘上这个元素」的最大值。求将 <span class=\"math inline\">\\(s\\)</span> 划分后的最大价值。</p>\n<p>不难想到分成的每一段首尾元素必须相等。</p>\n<p>比如有这样一个序列 <span class=\"math inline\">\\(x,a_1,a_2,a_3,\\cdots,a_k,x,y\\)</span> 。假设我们求的是这一段包含 <span class=\"math inline\">\\(x\\)</span> 的个数的平方，那么完全可以将 <span class=\"math inline\">\\(y\\)</span> 从这一段中分离，单独为一段，明显更优。</p>\n<p>而其他所有情况都是这种情况的拓展。</p>\n<p>于是得到式子： <span class=\"math display\">\\[\nf_i=\\max\\{f_{j-1}+s_i\\times(cnt_i-cnt_j+1)^2\\}\n\\]</span> 其中 <span class=\"math inline\">\\(cnt_i\\)</span> 为 <span class=\"math inline\">\\(s_i\\)</span> 已经出现了多少次。</p>\n<p>然后就是套路。 <span class=\"math display\">\\[\n\\begin{aligned}\nf_i&amp;=\\max\\{f_{j-1}+s_i\\times({cnt_i}^2+{cnt_j}^2-2\\times cnt_i\\times cnt_j+2\\times cnt_i-2\\times cnt_j+1)\\}\n\\\\\n&amp;=\\max\\{f_{j-1}+s_i\\times{cnt_i}^2+s_i\\times{cnt_j}^2-2\\times s_i\\times cnt_i\\times cnt_j+2\\times s_i\\times cnt_i-2\\times s_i\\times cnt_j+s_i\\}\n\\\\\n&amp;=\\max\\{f_{j-1}+s_i\\times {cnt_j}^2-2\\times s_i\\times cnt_i\\times cnt_j-2\\times s_i\\times cnt_j\\}+s_i\\times {cnt_i}^2+2\\times s_i\\times cnt_i+s_i\n\\end{aligned}\n\\]</span> 这次不是 <span class=\"math inline\">\\(\\min\\)</span>，而是 <span class=\"math inline\">\\(\\max\\)</span>，我们还能像以前那样推吗？</p>\n<p>不急，我们先按以前的方法试试，见机行事。</p>\n<p>令 <span class=\"math inline\">\\(j\\)</span> 优于 <span class=\"math inline\">\\(k\\)</span>，则有： <span class=\"math display\">\\[\nf_{j-1}+s_i\\times {cnt_j}^2-2\\times s_i\\times cnt_i\\times cnt_j-2\\times s_i\\times cnt_j&gt;f_{k-1}+s_i\\times {cnt_k}^2-2\\times s_i\\times cnt_i\\times cnt_k-2\\times s_i\\times cnt_k\n\\]</span> 暴力搞不出来，因为那个 <span class=\"math inline\">\\(s_i\\)</span> 乘上的平方项。</p>\n<p>那我们想一个办法，把 <span class=\"math inline\">\\(s_i\\)</span> 给灭掉就行了。</p>\n<p>既然我们已知一段的首尾元素必须相等，那不就说明 <span class=\"math inline\">\\(s_i,s_j,s_k\\)</span> 可以相互替换吗？</p>\n<p>继续搞。 <span class=\"math display\">\\[\nf_{j-1}+s_j\\times {cnt_j}^2-2\\times s_i\\times cnt_i\\times cnt_j-2\\times s_j\\times cnt_j&gt;f_{k-1}+s_k\\times {cnt_k}^2-2\\times s_i\\times cnt_i\\times cnt_k-2\\times s_k\\times cnt_k\n\\\\\nf_{j-1}-f_{k-1}+s_j\\times {cnt_j}^2-s_k\\times {cnt_k}^2-2\\times s_j\\times cnt_j+2\\times s_k\\times cnt_k&gt;2\\times s_i\\times cnt_i\\times cnt_j-2\\times s_i\\times cnt_i\\times cnt_k\n\\\\\n\\dfrac{f_{j-1}-f_{k-1}+s_j\\times {cnt_j}^2-s_k\\times {cnt_k}^2-2\\times s_j\\times cnt_j+2\\times s_k\\times cnt_k}{cnt_j-cnt_k}&gt;2\\times s_i\\times cnt_i\n\\]</span></p>\n<p>这里的符号变成 <span class=\"math inline\">\\(&gt;\\)</span> 了。</p>\n<p>易得，这里要维护的是一个斜率单调递减的上凸包最优解序列。</p>\n<p>因为 <span class=\"math inline\">\\(s_i\\)</span> 必须与 <span class=\"math inline\">\\(s_j,s_k\\)</span> 相同，明显要针对每个 <span class=\"math inline\">\\(s_i\\)</span> 维护不同的最优解序列，在每次对应的序列中计算。</p>\n<p>维护的斜率单调递减，而对于每一个相等的 <span class=\"math inline\">\\(s_i\\)</span>， <span class=\"math inline\">\\(2\\times s_i\\times cnt_i\\)</span> 一定是单调递增的，导致了这个序列大概长这个样子：斜率单调递减，但末尾的最小的斜率仍大于 <span class=\"math inline\">\\(2\\times s_i\\times cnt_i\\)</span>。</p>\n<p>单调栈可以自行研究，因为作者瞄了一眼时间发现已经是明天了。（什</p>\n<pre class=\"cpp\"><code>#include&lt;cstdio&gt;\n#include&lt;vector&gt;\nusing namespace std;\n#define int long long\n#define top q[x].size() - 1\nconst int maxn = 1e5 + 5;\nconst int maxm = 1e4 + 5;\nint n;\nvector&lt;int&gt; q[maxm]; // 不用 vector 会 MLE\nint f[maxn], s[maxn];\nint cnt[maxn], tot[maxm];\nint getDP(int i,int j)&#123;\n    return f[j-1]+(cnt[i]-cnt[j]+1)*(cnt[i]-cnt[j]+1)*s[i];\n&#125;\nint getup(int j,int k)&#123;\n    return f[j-1]-f[k-1]+s[j]*cnt[j]*cnt[j]-s[k]*cnt[k]*cnt[k]-2*s[j]*cnt[j]+2*s[k]*cnt[k];\n&#125;\nint getdown(int j,int k)&#123;\n    return cnt[j]-cnt[k];\n&#125;\nsigned main()&#123;\n    scanf(&quot;%lld&quot;,&amp;n);\n    for(int i=1;i&lt;=n;++i)&#123;\n        scanf(&quot;%lld&quot;,&amp;s[i]);\n        cnt[i]=++tot[s[i]];\n    &#125;\n    for(int i=1;i&lt;=n;++i)&#123;\n        int x=s[i];\n        while(q[x].size()&gt;=2&amp;&amp;getup(q[x][top-1],i)*getdown(q[x][top-1],q[x][top])&gt;=getup(q[x][top-1],q[x][top])*getdown(q[x][top-1],i))\n            q[x].pop_back();\n        q[x].push_back(i);\n        while(q[x].size()&gt;=2&amp;&amp;getDP(i,q[x][top])&lt;=getDP(i,q[x][top-1]))\n            q[x].pop_back();\n        f[i]=getDP(i,q[x][top]);\n    &#125;\n    printf(&quot;%lld&quot;,f[n]);\n    return 0;\n&#125;</code></pre>\n<hr />\n<h3 id=\"总结\">总结</h3>\n<p>总结斜优的步骤：</p>\n<ol type=\"1\">\n<li>推 DP 式子</li>\n<li>对式子进行巧妙的优化，使其易于化简</li>\n<li>假设 <span class=\"math inline\">\\(j\\)</span> 优于 <span class=\"math inline\">\\(k\\)</span>，将式子化成 <span class=\"math inline\">\\(\\dfrac{(j)-(k)}{(j)-(k)}&gt; \\text{or} &lt;x\\)</span> 的形式</li>\n<li>单调队列或单调栈优化</li>\n</ol>\n",
            "tags": [
                "斜率优化"
            ]
        }
    ]
}