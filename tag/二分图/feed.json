{
    "version": "https://jsonfeed.org/version/1",
    "title": "null • All posts by \"二分图\" tag",
    "description": "",
    "home_page_url": "https://xsc062.netlify.app",
    "items": [
        {
            "id": "https://xsc062.netlify.app/20230509/",
            "url": "https://xsc062.netlify.app/20230509/",
            "title": "二分图",
            "date_published": "2023-05-09T12:48:00.000Z",
            "content_html": "<p>你说得对，所以我打网络流。</p>\n<span id=\"more\"></span>\n<hr />\n<h2 id=\"二分图\">二分图</h2>\n<p><del>二分图总体概念不难</del>。主要是其应用广泛，需要注意什么样的题目可以联系到二分图上来。</p>\n<h3 id=\"概念\">概念</h3>\n<p>若图 <span class=\"math inline\">\\(G\\)</span> 可将点集 <span class=\"math inline\">\\(V\\)</span> 分成两个互不相交的子集 <span class=\"math inline\">\\(X\\)</span> 和 <span class=\"math inline\">\\(Y\\)</span>，且每条边连接的两个点都满足一个在 <span class=\"math inline\">\\(X\\)</span> 中，一个在 <span class=\"math inline\">\\(Y\\)</span> 中，则称 <span class=\"math inline\">\\(G\\)</span> 为二分图。</p>\n<p>也就是说，如果一个图有任何一种分组方式满足：把图中的点分成两组，每一组的点两两之间没有连边，那么这个图就是二分图。</p>\n<p>举个例子：</p>\n<figure>\n<img src=\"https://pic.imgdb.cn/item/62c8cd2cf54cd3f9371c4818.jpg\" alt=\"每一组中的点两两之间没有连边，所以该图是二分图。\" /><figcaption>每一组中的点两两之间没有连边，所以该图是二分图。</figcaption>\n</figure>\n<h3 id=\"性质\">性质</h3>\n<ul>\n<li><p>二分图的每条边连接的点属于不同的集合。</p>\n<p>显然。</p></li>\n<li><p>二分图中可能存在环，且长度一定为偶数。</p>\n<p>我们指定环中任意一个点，从该点出发，易得，经过奇数条边时到达另一个集合，反之回到该集合。因为路径是一个环，所以我们最后一定会回到起点所在集合，即经过偶数条边。</p></li>\n</ul>\n<h3 id=\"判定\">判定</h3>\n<p>通常，我们使用图的深度优先遍历每一个点 <span class=\"math inline\">\\(u\\)</span>。</p>\n<p>显然，若已知点 <span class=\"math inline\">\\(u\\)</span> 在 <span class=\"math inline\">\\(X\\)</span> 集，那么所有与 <span class=\"math inline\">\\(u\\)</span> 有连边的点 <span class=\"math inline\">\\(v\\)</span> 一定在 <span class=\"math inline\">\\(Y\\)</span> 集（反之同理）。</p>\n<p>当然，很多图是有环的，不免会产生 <span class=\"math inline\">\\(v\\)</span> 已经被分组的情况。若此时 <span class=\"math inline\">\\(v\\)</span> 恰好在 <span class=\"math inline\">\\(Y\\)</span> 集，皆大欢喜；若 <span class=\"math inline\">\\(v\\)</span> 也在 <span class=\"math inline\">\\(X\\)</span> 集，那么该图一定不为二分图。</p>\n<p>由于每个点最多搜索一次，时间复杂度 <span class=\"math inline\">\\(O(n)\\)</span>。</p>\n<pre class=\"cpp\"><code>int col[maxn];\nbool DFS(int x, int c) &#123;\n    col[x] = c;\n    for (auto i : g[x]) &#123;\n        if (col[i]) &#123;\n            if (col[i] == c)\n                return 0;\n        &#125;\n        else if (!DFS(i, 3 - c))\n            return 0;\n    &#125;\n    return 1;\n&#125;\nint main() &#123; DFS(1, 1); &#125;</code></pre>\n<p>厚颜无耻地推销一下 <a href=\"https://www.luogu.com.cn/problem/U283873\">题目</a>（（（</p>\n<h3 id=\"匹配\">匹配</h3>\n<p>定义：对于一个二分图中的若干条边，若这些边没有任何公共点，则称这些边组成的集合 <span class=\"math inline\">\\(M\\)</span> 是数量为 <span class=\"math inline\">\\(|M|\\)</span> 的 <strong>匹配</strong>。</p>\n<figure>\n<img src=\"https://pic.imgdb.cn/item/62c8cd75f54cd3f9371c866f.jpg\" alt=\"图中红色边展示了一个数量为 4 的匹配\" /><figcaption>图中红色边展示了一个数量为 4 的匹配</figcaption>\n</figure>\n<p>容易看出，对于点 <span class=\"math inline\">\\(u\\)</span>，只会存在 「有一条 <span class=\"math inline\">\\(M\\)</span> 集合内的边与 <span class=\"math inline\">\\(u\\)</span> 相连接」 和 「<span class=\"math inline\">\\(u\\)</span> 连接的边均不在 <span class=\"math inline\">\\(M\\)</span> 集合内」 两种情况。也就是说，从 <span class=\"math inline\">\\(u\\)</span> 出发的 <span class=\"math inline\">\\(M\\)</span> 集合内的边，最多有 <span class=\"math inline\">\\(1\\)</span> 条。</p>\n<p>接下来，我们称 「有任何一条与之相连的边在匹配集合内」 的点为匹配点，「在匹配集合内的边」 为匹配边。</p>\n<h3 id=\"完备匹配\">完备匹配</h3>\n<p>如果 <span class=\"math inline\">\\(|M|=\\dfrac n2\\)</span>，即 <span class=\"math inline\">\\(M\\)</span> 恰好连接了 <span class=\"math inline\">\\(1\\sim n\\)</span> 所有点，我们就称匹配 <span class=\"math inline\">\\(M\\)</span> 为 <strong>完备匹配</strong>。</p>\n<figure>\n<img src=\"https://pic.imgdb.cn/item/62c902d9f54cd3f93755faf9.jpg\" alt=\"一个完备匹配的例子\" /><figcaption>一个完备匹配的例子</figcaption>\n</figure>\n<p>比方说，现在我们知道一些男孩和女孩，他们之间有若干条互相喜欢的关系，我们把此关系抽象成一个二分图，如果每个人都能与自己喜欢的异性配对，那么我们认为这个关系网存在完备匹配。</p>\n<p>显然，完备匹配存在，仅当两集合大小相等。</p>\n<hr />\n<h2 id=\"匈牙利算法\">匈牙利算法</h2>\n<p>匈牙利算法一般用于求解 <span class=\"math inline\">\\(\\max\\{|M|\\}\\)</span>。</p>\n<p>我们将图上满足下列条件的路径 <span class=\"math inline\">\\(P\\)</span> 称为<strong>增广路</strong>：</p>\n<ul>\n<li><span class=\"math inline\">\\(P\\)</span> 的起点和终点均是非匹配点</li>\n<li><span class=\"math inline\">\\(P\\)</span> 的起点和终点不在二分图的同一组内</li>\n<li>路径 <span class=\"math inline\">\\(P\\)</span> 经过的边按 <strong>非</strong> 匹配边，匹配边，<span class=\"math inline\">\\(\\cdots\\)</span>，<strong>非</strong> 匹配边的规律交替。</li>\n</ul>\n<p>最终，<span class=\"math inline\">\\(P\\)</span> 会呈类 「<span class=\"math inline\">\\(\\text Z\\)</span>」 形（值得一提的是，增广路不能经过一整个环，否则其长度将会因为二分图中只存在偶环而变为无穷大）。</p>\n<p>显然，非匹配边比匹配边的数量始终多 <span class=\"math inline\">\\(1\\)</span>。</p>\n<p>此时，我们对 <span class=\"math inline\">\\(P\\)</span> 上匹配的状态取反。也就是说，原来的非匹配边变成匹配边，匹配边变成非匹配边。这样做相当于是在匹配边集仍然合法的情况下将匹配边集的大小扩大了 <span class=\"math inline\">\\(1\\)</span>。</p>\n<p>那么增广路经过的边按非匹配边，匹配边，<span class=\"math inline\">\\(\\cdots\\)</span>，非匹配边顺序交替的原因就很显而易见了。取反前，匹配边不可能连续出现；取反后，匹配边（即取反前的非匹配边）也不可能连续出现。</p>\n<p>而匈牙利算法的主要思路，就是反复寻找增广路，直到无法找到为止。</p>\n<p>这里就必须再提到一个性质：<span class=\"math inline\">\\(M\\)</span> 为图 <span class=\"math inline\">\\(G\\)</span> 的最大匹配，当且仅当无法在 <span class=\"math inline\">\\(M\\)</span> 的基础上找到增广路。</p>\n<p>证明如下：</p>\n<ul>\n<li><p>有引理：对于图 <span class=\"math inline\">\\(G\\)</span> 的任意两个匹配 <span class=\"math inline\">\\(M\\)</span> 和 <span class=\"math inline\">\\(M&#39;\\)</span>，它们的 <a href=\"https://baike.baidu.com/item/%E5%AF%B9%E7%A7%B0%E5%B7%AE\">对称差</a> <span class=\"math inline\">\\(M\\Delta M&#39;\\)</span> 中的每一个连通块都是一条链或一个包含边数为偶数的环。</p>\n<p>证明：</p>\n<p>根据对称差的定义，对于任意边 <span class=\"math inline\">\\(e\\in M\\Delta M&#39;\\)</span>，<span class=\"math inline\">\\(e\\)</span> 要么是 <span class=\"math inline\">\\(M\\)</span> 中的一条匹配边，要么是 <span class=\"math inline\">\\(M&#39;\\)</span> 中的一条匹配边，但不同时被 <span class=\"math inline\">\\(M\\)</span> 和 <span class=\"math inline\">\\(M&#39;\\)</span> 包含。</p>\n<p>因为在同一个匹配中，任意两条匹配边不存在公共顶点，所以对于任意与 <span class=\"math inline\">\\(e\\)</span> 有公共顶点的匹配边 <span class=\"math inline\">\\(e&#39;\\)</span>，<span class=\"math inline\">\\(e\\)</span> 和 <span class=\"math inline\">\\(e&#39;\\)</span> 必然来自两个不同的匹配。</p>\n<p>由此可得，对于任意匹配点 <span class=\"math inline\">\\(u\\)</span>，<span class=\"math inline\">\\(u\\)</span> 的度数为 <span class=\"math inline\">\\(1\\)</span> 或 <span class=\"math inline\">\\(2\\)</span>。</p>\n<p>所以，对称差中的每一个连通块都是链或环。</p>\n<p>对于其中的环，所有相邻的边必定来自不同的匹配，所以环包含的边数为偶数。</p></li>\n<li><p>必要性：当 <span class=\"math inline\">\\(M\\)</span> 为最大匹配时，无法找到 <span class=\"math inline\">\\(M\\)</span> 的增广路。</p>\n<p>我们已经知道了，找到某匹配的增广路 <span class=\"math inline\">\\(P\\)</span> 并将其匹配状态取反，可以使匹配大小加一。</p>\n<p>如果 <span class=\"math inline\">\\(M\\)</span> 存在增广路，则我们可以将其取反，得到一个比 <span class=\"math inline\">\\(M\\)</span> 大小更大的匹配。与 <span class=\"math inline\">\\(M\\)</span> 是最大匹配矛盾。</p>\n<p>所以一定不存在 <span class=\"math inline\">\\(M\\)</span> 的增广路。</p></li>\n<li><p>充分性：如果不存在 <span class=\"math inline\">\\(M\\)</span> 的增广路，<span class=\"math inline\">\\(M\\)</span> 为 <span class=\"math inline\">\\(G\\)</span> 的最大匹配。</p>\n<p>设 <span class=\"math inline\">\\(M&#39;\\)</span> 是一个比 <span class=\"math inline\">\\(M\\)</span> 更大的匹配。</p>\n<p>由引理得：</p>\n<p>在它们的对称差 <span class=\"math inline\">\\(M\\Delta M&#39;\\)</span> 中，连通块为链或环。</p>\n<p>其中，环包含边的数量为偶数，所以必然有同样多的边来自 <span class=\"math inline\">\\(M\\)</span> 和 <span class=\"math inline\">\\(M&#39;\\)</span>。所以我们可以忽视这些环。</p>\n<p>由于 <span class=\"math inline\">\\(|M|&lt;|M&#39;|\\)</span>，存在至少一条链 <span class=\"math inline\">\\(L\\)</span>，且 <span class=\"math inline\">\\(|L|=k-1\\)</span>，包含 <span class=\"math inline\">\\(k\\)</span> 条 <span class=\"math inline\">\\(M\\)</span> 中的边，<span class=\"math inline\">\\(k+1\\)</span> 条来自于 <span class=\"math inline\">\\(M&#39;\\)</span> 的边。</p>\n<p>显然，<span class=\"math inline\">\\(L\\)</span> 就是一条 <span class=\"math inline\">\\(M\\)</span> 的增广路，所以我们必然可以找到一条 <span class=\"math inline\">\\(M\\)</span> 的增广路，命题成立。</p></li>\n</ul>\n<p>对于 「寻找增广路」 这个过程，我们使用 DFS 算法实现。</p>\n<p>对于点 <span class=\"math inline\">\\(x\\)</span>，若与 <span class=\"math inline\">\\(x\\)</span> 有连边的点 <span class=\"math inline\">\\(y\\)</span> 可匹配上 <span class=\"math inline\">\\(x\\)</span>，需要满足下列两个条件之一：</p>\n<ul>\n<li><span class=\"math inline\">\\(y\\)</span> 是非匹配点，此时 <span class=\"math inline\">\\(x\\to y\\)</span> 构成一条增广路，非匹配边的数量已经比匹配边数量多 <span class=\"math inline\">\\(1\\)</span>。</li>\n<li><span class=\"math inline\">\\((u,y)\\)</span> 是已匹配边，且 <span class=\"math inline\">\\((u,v)\\)</span> 是未匹配但合法的边，此时 <span class=\"math inline\">\\(x\\to y\\to u\\to v\\)</span> 构成一条增广路。</li>\n</ul>\n<p>在实现中，我们依次令 <span class=\"math inline\">\\(1\\sim n\\)</span> 内 <strong>所有的非匹配点</strong> 作为起始点 <span class=\"math inline\">\\(x\\)</span> 尝试找到任何一条增广路。当碰到任意非匹配点时结束（增广路判定：起点与终点均为非匹配点），否则向 <strong>该匹配点匹配的点</strong> 继续搜索。</p>\n<p>也就是说，一层 DFS 会寻找一条非匹配边并作为起点，产生以下两种行为：</p>\n<ol type=\"1\">\n<li>该非匹配边终点为非匹配点，以该匹配边结束增广路。</li>\n<li>经过该非匹配边后还能再找到一条匹配边（若情况 1 不满足，显然一定能找到这样一条边），则在终点进行下一层 DFS，寻找下一条非匹配边。</li>\n</ol>\n<p>时间复杂度为 <span class=\"math inline\">\\(O(n^2+nm)\\)</span>，但一般二分图题目的 <span class=\"math inline\">\\(X\\)</span> 与 <span class=\"math inline\">\\(Y\\)</span> 部间的连边偏稠密，所以简化为 <span class=\"math inline\">\\(O(nm)\\)</span>。</p>\n<pre class=\"cpp\"><code>bool Find(int x) &#123;\n    vis[x] = now; // 时间戳标记\n    for (auto i : g[x]) &#123;\n        if (vis[i] == now) // 不经过访问过的 i\n            continue;\n        if (!mat[i] /* 非匹配点，即终点 */ ||\n            (vis[mat[i]] != now /* mat[i] 未访问过，可以经过 */\n            &amp;&amp; Find(mat[i]) /* 可找到增广路 */)) &#123;\n            mat[i] = x; // 匹配\n            return 1;\n        &#125;\n    &#125;\n    return 0;\n&#125;\nint Hungary(int n) &#123;\n    int res = 0;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        ++now;\n        res += Find(i);\n    &#125;\n    return res;\n&#125;</code></pre>\n<p>一般来说，二分图题目对点、边、分组方法和匹配范围的识别较为模糊。但一般的二分图题目都会有一些特点：</p>\n<ul>\n<li>结点能分为两组，且各组内结点间没有连边</li>\n<li>每个结点只能与一条边匹配</li>\n</ul>\n<p>有时候，题目要求判定是否存在 「完备匹配」，也就是说，<span class=\"math inline\">\\(ans=n\\)</span>。即任意一次 <code>find(i)</code> 返回 <code>false</code> 时，完备匹配不存在。</p>\n<p>最后给出与匈牙利算法有关的两个问题：</p>\n<ol type=\"1\">\n<li><p>最小点覆盖：给定一个二分图，求出一个最小的点集，使得这个点集发出的所有边可以覆盖整个二分图。</p>\n<p>定理：该点集的大小是二分图的最大匹配包含的边数。</p></li>\n<li><p>最大独立集：给定一个无向图，求出一个最大的点集，使得该点集中的所有点两两之间没有边相连。</p>\n<p>定理：当该无向图是二分图时，最大独立集的大小等于 <span class=\"math inline\">\\(n\\)</span> 减去最大匹配数。</p>\n<p>证明：由于最小点覆盖可以覆盖所有边，故不存在两个点，使得它们不属于最小点覆盖且有连边。</p>\n<p>所以，当去掉最小点覆盖后，剩余点两两之间没有连边。因为最小点覆盖大小就是最大匹配大小，故原命题成立。</p></li>\n</ol>\n<hr />\n<p>注意二分图的点和边是可以互相转化的，即，若发现信息集中在点上，也可以用二分图解决。匹配边的数量即最终参与匹配的点数较多的一方的匹配点数量。</p>\n<p>对于二分图建图的一个判断方式是，找冲突。找到彼此之间有冲突的两方，连边。这样就能建出二分图。当然要保证两方之间没有交集。</p>\n<p>所谓冲突，就是我们通常理解中的选了一个就不能选另一个。因此也可以通过冲突存在的形式思考建图方式。</p>\n<hr />\n<h3 id=\"a.-棋盘上的骑士\">A. 棋盘上的骑士</h3>\n<p><a href=\"http://222.180.160.110:61235/contest/3699/problem/1\" class=\"uri\">http://222.180.160.110:61235/contest/3699/problem/1</a></p>\n<p>这道题就是我们提到的边转化为点的情况。</p>\n<p>为棋盘上的每个格子编号。骑士走的是日字，所以我们要把周围每个格子日字方向八个格子都连上边。</p>\n<p>那要怎么将所有 <span class=\"math inline\">\\(n\\times n\\)</span> 个格子分为有冲突的两方呢？注意到日字连接的两个格子一定奇偶性相异，故我们以奇偶性分类。</p>\n<p>被挖掉的格子无视即可，不能连任何边，否则该边都有可能被选。然后跑一个最大匹配就行。</p>\n<details>\n<pre class=\"cpp\"><code>namespace XSC062 &#123;\nusing namespace fastIO;\nconst int maxn = 205;\nconst int maxm = 1e5 + 5;\nconst int fx[] = &#123; 1, 1, -1, -1, 2, 2, -2, -2 &#125;;\nconst int fy[] = &#123; 2, -2, 2, -2, 1, -1, 1, -1 &#125;;\nint a[maxn][maxn];\nint mat[maxm], vis[maxm];\nstd::vector&lt;int&gt; g[maxm];\nint n, m, x, y, now, cnt, tot;\nbool Find(int x) &#123;\n    vis[x] = now;\n    for (auto i : g[x]) &#123;\n        if (vis[i] == now)\n            continue;\n        if (!mat[i] || (vis[mat[i]] != now\n                            &amp;&amp; Find(mat[i]))) &#123;\n            mat[i] = x;\n            return 1;\n        &#125;\n    &#125;\n    return 0;\n&#125;\nint Hungary(int n) &#123;\n    int res = 0;\n    for (int i = 1; i &lt;= n; ++i)\n        ++now, res += Find(i);\n    return res;\n&#125;\nvoid add(int x, int y) &#123;\n    g[x].push_back(y);\n    return;\n&#125;\nint main() &#123;\n    read(n), read(m);\n    while (m--) &#123;\n        read(x), read(y);\n        a[x][y] = -1;\n    &#125;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        for (int j = 1; j &lt;= n; ++j) &#123;\n            if (a[i][j] != -1 &amp;&amp; !((i + j) &amp; 1))\n                a[i][j] = ++cnt;\n        &#125;\n    &#125;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        for (int j = 1; j &lt;= n; ++j) &#123;\n            if (a[i][j] == -1 || !((i + j) &amp; 1))\n                continue;\n            a[i][j] = ++tot;\n            for (int k = 0; k &lt; 8; ++k) &#123;\n                int nx = i + fx[k];\n                int ny = j + fy[k];\n                if (nx &lt; 1 || ny &lt; 1 || nx &gt; n ||\n                    ny &gt; n || a[nx][ny] == -1)\n                    continue;\n                add(a[i][j], a[nx][ny] + n * n);\n            &#125;\n        &#125;\n    &#125;\n    print(cnt + tot - Hungary(tot), &#39;\\n&#39;);\n    return 0;\n&#125;\n&#125; // namespace XSC062</code></pre>\n</details>\n<hr />\n<h3 id=\"b.-火力网\">B. 火力网</h3>\n<p><a href=\"http://222.180.160.110:61235/contest/3699/problem/2\" class=\"uri\">http://222.180.160.110:61235/contest/3699/problem/2</a></p>\n<p>这里用到了二分图在地图上一个较为常用的分组方法。</p>\n<p>找到每行每列的「连通块」，满足在行上的连通块任意放一个炮台，炮台覆盖连通块内所有点，所有点均被连通块覆盖，列范围内同理。为连通块分别编号，则样例的情况可转化如下：</p>\n<pre class=\"plain\"><code>/* 对于行 */        /* 对于列 */\n  1 - 2 2            1 - 5 6\n  3 3 3 3            1 3 5 6\n  - - 4 4            - - 5 6\n  5 5 5 5            2 4 5 6</code></pre>\n<p>若一个格子为空地，则将其在行 / 列范围内所属的连通块连边。这样，我们在选取该格后，就相当于选取了这条边，由于匹配边不共点，所以合法。</p>\n<details>\n<pre class=\"cpp\"><code>namespace XSC062 &#123;\nusing namespace fastIO;\nconst int maxn = 25;\nconst int maxm = 1e5 + 5;\nchar a[maxn][maxn];\nint mat[maxm], vis[maxm];\nstd::vector&lt;int&gt; g[maxm];\nint n, x, y, now, cnt1, cnt2;\nint t[maxn][maxn], p[maxn][maxn];\nbool Find(int x) &#123;\n    vis[x] = now;\n    for (auto i : g[x]) &#123;\n        if (vis[i] == now)\n            continue;\n        if (!mat[i] || (vis[mat[i]] != now\n                            &amp;&amp; Find(mat[i]))) &#123;\n            mat[i] = x;\n            return 1;\n        &#125;\n    &#125;\n    return 0;\n&#125;\nint Hungary(int n) &#123;\n    int res = 0;\n    for (int i = 1; i &lt;= n; ++i)\n        ++now, res += Find(i);\n    return res;\n&#125;\nvoid add(int x, int y) &#123;\n    g[x].push_back(y);\n    return;\n&#125;\nint main() &#123;\n    scanf(&quot;%d&quot;, &amp;n);\n    for (int i = 1; i &lt;= n; ++i)\n        scanf(&quot;%s&quot;, a[i] + 1);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        for (int j = 1; j &lt;= n; ++j) &#123;\n            if (a[i][j] == &#39;X&#39;)\n                continue;\n            if (a[i][j - 1] != &#39;.&#39;)\n                t[i][j] = ++cnt1;\n            else t[i][j] = t[i][j - 1];\n        &#125;\n    &#125;\n    for (int j = 1; j &lt;= n; ++j) &#123;\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            if (a[i][j] == &#39;X&#39;)\n                continue;\n            if (a[i - 1][j] != &#39;.&#39;)\n                p[i][j] = ++cnt2;\n            else p[i][j] = p[i - 1][j];\n        &#125;\n    &#125;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        for (int j = 1; j &lt;= n; ++j) &#123;\n            if (a[i][j] == &#39;.&#39;)\n                add(t[i][j], p[i][j] + cnt1);\n        &#125;\n    &#125;\n    print(Hungary(cnt1), &#39;\\n&#39;);\n    return 0;\n&#125;\n&#125; // namespace XSC062</code></pre>\n</details>\n<hr />\n<h3 id=\"c.-超级英雄-hero\">C. 超级英雄 Hero</h3>\n<p><a href=\"http://222.180.160.110:61235/contest/3699/problem/3\" class=\"uri\">http://222.180.160.110:61235/contest/3699/problem/3</a></p>\n<p>分析冲突。每个锦囊只能被一道题使用，一道题只能使用一个锦囊，故考虑将锦囊和题连边。题目要求连续解题最多，故以题目进行匈牙利。</p>\n<p>最后输出匹配数组即可。</p>\n<details>\n<pre class=\"cpp\"><code>namespace XSC062 &#123;\nusing namespace fastIO;\nconst int maxn = 2e4 + 5;\nint n, m, x, y, now, t;\nint mat[maxn], vis[maxn];\nstd::vector&lt;int&gt; g[maxn];\nbool Find(int x) &#123;\n    vis[x] = now;\n    for (auto i : g[x]) &#123;\n        if (vis[i] == now)\n            continue;\n        if (!mat[i] || (vis[mat[i]] != now\n                            &amp;&amp; Find(mat[i]))) &#123;\n            mat[i] = x, mat[x] = i;\n            return 1;\n        &#125;\n    &#125;\n    return 0;\n&#125;\nint Hungary(int n) &#123;\n    int res = 0;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        ++now;\n        if (Find(i))\n            ++res;\n        else break;\n    &#125;\n    return res;\n&#125;\nvoid add(int x, int y) &#123;\n    g[x].push_back(y);\n    return;\n&#125;\nint main() &#123;\n    read(n), read(m);\n    for (int i = 1; i &lt;= m; ++i) &#123;\n        read(x), read(y);\n        add(i, x + m + 1);\n        add(i, y + m + 1);\n    &#125;\n    print(t = Hungary(m), &#39;\\n&#39;);\n    for (int i = 1; i &lt;= t; ++i)\n        print(mat[i] - m - 1, &#39;\\n&#39;);\n    return 0;\n&#125;\n&#125; // namespace XSC062</code></pre>\n</details>\n<hr />\n<h2 id=\"km-算法\">KM 算法</h2>\n<p>还没写…… 咕咕咕</p>\n<hr />\n<h3 id=\"a.-ants\">A. Ants</h3>\n<p><a href=\"https://vjudge.net/contest/554888#problem/A\" class=\"uri\">https://vjudge.net/contest/554888#problem/A</a></p>\n<p>板板题。把黑蚂蚁和白蚂蚁按欧几里得距离连边后 KM 即可。</p>\n<details>\n<pre class=\"cpp\"><code>namespace XSC062 &#123;\nusing namespace fastIO;\ntypedef double db;\nconst db inf = 1e18;\nconst db eps = 1e-5;\nconst int maxn = 205;\nint n, now;\ndb g[maxn][maxn];\ndb u[maxn], up[maxn];\nint vis[maxn], mat[maxn];\nint a[maxn][2], b[maxn][2];\ndb max(db x, db y) &#123;\n    return x &gt; y ? x : y;\n&#125;\ndb min(db x, db y) &#123;\n    return x &lt; y ? x : y;\n&#125;\nbool eq(db x, db y) &#123;\n    return fabs(x - y) &lt;= eps;\n&#125;\nbool Find(int x) &#123;\n    vis[x] = now;\n    for (int i = n + 1; i &lt;= 2 * n; ++i) &#123;\n        if (vis[i] == now)\n            continue;\n        if (eq(u[x] + u[i], g[x][i])) &#123;\n            vis[i] = now;\n            if (!mat[i] || (vis[mat[i]] != now\n                            &amp;&amp; Find(mat[i]))) &#123;\n                mat[i] = x;\n                return 1;\n            &#125;\n        &#125;\n        else &#123;\n            up[i] = min(up[i],\n                u[x] + u[i] - g[x][i]);\n        &#125;\n    &#125;\n    return 0;\n&#125;\nvoid Solve(void) &#123;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        u[i] = -inf;\n        for (int j = n + 1; j &lt;= 2 * n; ++j)\n            u[i] = max(u[i], g[i][j]);\n    &#125;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        for (;;) &#123;\n            ++now;\n            for (int j = n + 1; j &lt;= 2 * n; ++j)\n                up[j] = inf;\n            if (Find(i))\n                break;\n            db Delta = inf;\n            for (int j = n + 1;\n                            j &lt;= 2 * n; ++j) &#123;\n                if (vis[j] != now)\n                    Delta = min(Delta, up[j]);\n            &#125;            for (int j = 1; j &lt;= n; ++j) &#123;\n                if (vis[j] == now)\n                    u[j] -= Delta;\n            &#125;\n            for (int j = n + 1;\n                            j &lt;= 2 * n; ++j) &#123;\n                if (vis[j] == now)\n                    u[j] += Delta;\n            &#125;\n        &#125;\n    &#125;\n    return;\n&#125;\ndb dist(int x1, int y1, int x2, int y2) &#123;\n    return sqrt((db)(x1 - x2) * (x1 - x2) +\n                    (y1 - y2) * (y1 - y2));\n&#125;\nint main() &#123;\n    read(n);\n    for (int i = 1; i &lt;= n; ++i)\n        read(a[i][0]), read(a[i][1]);\n    for (int i = 1; i &lt;= n; ++i)\n        read(b[i][0]), read(b[i][1]);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        for (int j = 1; j &lt;= n; ++j) &#123;\n            g[j][i + n] = -dist(a[i][0], a[i][1],\n                            b[j][0], b[j][1]);\n        &#125;\n    &#125;\n    Solve();\n    for (int i = n + 1; i &lt;= 2 * n; ++i)\n        print(mat[i], &#39;\\n&#39;);\n    return 0;\n&#125;\n&#125; // namespace XSC062</code></pre>\n</details>\n<h3 id=\"b.-奔小康赚大钱\">B. 奔小康赚大钱</h3>\n<p><a href=\"https://vjudge.net/contest/554888#problem/B\" class=\"uri\">https://vjudge.net/contest/554888#problem/B</a></p>\n<p>板板题。把居民和房子连边即可。</p>\n<details>\n<pre class=\"cpp\"><code>namespace XSC062 &#123;\nusing namespace fastIO;\nconst int maxn = 605;\nconst int inf = 0x3f3f3f3f;\nint n, now, res;\nint g[maxn][maxn];\nint u[maxn], up[maxn];\nint vis[maxn], mat[maxn];\nint max(int x, int y) &#123;\n    return x &gt; y ? x : y;\n&#125;\nint min(int x, int y) &#123;\n    return x &lt; y ? x : y;\n&#125;\nbool Find(int x) &#123;\n    vis[x] = now;\n    for (int i = n + 1; i &lt;= 2 * n; ++i) &#123;\n        if (vis[i] == now)\n            continue;\n        if (u[x] + u[i] == g[x][i]) &#123;\n            vis[i] = now;\n            if (!mat[i] || (vis[mat[i]] != now\n                            &amp;&amp; Find(mat[i]))) &#123;\n                mat[i] = x;\n                return 1;\n            &#125;\n        &#125;\n        else &#123;\n            up[i] = min(up[i],\n                u[x] + u[i] - g[x][i]);\n        &#125;\n    &#125;\n    return 0;\n&#125;\nvoid Solve(void) &#123;\n    for (int i = 1; i &lt;= 2 * n; ++i)\n        mat[i] = u[i] = 0;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        u[i] = -inf;\n        for (int j = n + 1; j &lt;= 2 * n; ++j)\n            u[i] = max(u[i], g[i][j]);\n    &#125;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        for (;;) &#123;\n            ++now;\n            for (int j = n + 1; j &lt;= 2 * n; ++j)\n                up[j] = inf;\n            if (Find(i))\n                break;\n            int Delta = inf;\n            for (int j = n + 1;\n                            j &lt;= 2 * n; ++j) &#123;\n                if (vis[j] != now)\n                    Delta = min(Delta, up[j]);\n            &#125;\n            for (int j = 1; j &lt;= n; ++j) &#123;\n                if (vis[j] == now)\n                    u[j] -= Delta;\n            &#125;\n            for (int j = n + 1;\n                            j &lt;= 2 * n; ++j) &#123;\n                if (vis[j] == now)\n                    u[j] += Delta;\n            &#125;\n        &#125;\n    &#125;\n    return;\n&#125;\nint main() &#123;\n    while(read(n)) &#123;\n        res = 0;\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            for (int j = 1; j &lt;= n; ++j)\n                read(g[i][j + n]);\n        &#125;\n        Solve();\n        for (int i = n + 1; i &lt;= 2 * n; ++i)\n            res += g[mat[i]][i];\n        print(res, &#39;\\n&#39;);\n    &#125;\n    return 0;\n&#125;\n&#125; // namespace XSC062</code></pre>\n</details>\n<hr />\n<h3 id=\"c.-going-home\">C. Going Home</h3>\n<p><a href=\"https://vjudge.net/contest/554888#problem/C\" class=\"uri\">https://vjudge.net/contest/554888#problem/C</a></p>\n<p>板板题。把人和房子按曼哈顿距离连边即可。</p>\n<details>\n<pre class=\"cpp\"><code>namespace XSC062 &#123;\nusing namespace fastIO;\nconst int maxn = 205;\nconst int inf = 0x3f3f3f3f;\nint g[maxn][maxn];\nchar s[maxn][maxn];\nint u[maxn], up[maxn];\nint h, w, n, m, now, res;\nint vis[maxn], mat[maxn];\nint a[maxn][2], b[maxn][2];\nint max(int x, int y) &#123;\n    return x &gt; y ? x : y;\n&#125;\nint min(int x, int y) &#123;\n    return x &lt; y ? x : y;\n&#125;\nbool Find(int x) &#123;\n    vis[x] = now;\n    for (int i = n + 1; i &lt;= 2 * n; ++i) &#123;\n        if (vis[i] == now)\n            continue;\n        if (u[x] + u[i] == g[x][i]) &#123;\n            vis[i] = now;\n            if (!mat[i] || (vis[mat[i]] != now\n                            &amp;&amp; Find(mat[i]))) &#123;\n                mat[i] = x;\n                return 1;\n            &#125;\n        &#125;\n        else &#123;\n            up[i] = min(up[i],\n                u[x] + u[i] - g[x][i]);\n        &#125;\n    &#125;\n    return 0;\n&#125;\nvoid Solve(void) &#123;\n    for (int i = 1; i &lt;= 2 * n; ++i)\n        mat[i] = u[i] = 0;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        u[i] = -inf;\n        for (int j = n + 1; j &lt;= 2 * n; ++j)\n            u[i] = max(u[i], g[i][j]);\n    &#125;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        for (;;) &#123;\n            ++now;\n            for (int j = n + 1; j &lt;= 2 * n; ++j)\n                up[j] = inf;\n            if (Find(i))\n                break;\n            int Delta = inf;\n            for (int j = n + 1;\n                            j &lt;= 2 * n; ++j) &#123;\n                if (vis[j] != now)\n                    Delta = min(Delta, up[j]);\n            &#125;\n            for (int j = 1; j &lt;= n; ++j) &#123;\n                if (vis[j] == now)\n                    u[j] -= Delta;\n            &#125;\n            for (int j = n + 1;\n                            j &lt;= 2 * n; ++j) &#123;\n                if (vis[j] == now)\n                    u[j] += Delta;\n            &#125;\n        &#125;\n    &#125;\n    return;\n&#125;\nint abs(int x) &#123;\n    return x &gt;= 0 ? x : -x;\n&#125;\nint dist(int x1, int y1, int x2, int y2) &#123;\n    return abs(x1 - x2) + abs(y1- y2);\n&#125;\nvoid Init(void) &#123;\n    res = n = m = 0;\n    memset(g, 0, sizeof (g));\n    return;\n&#125;\nint main() &#123;\n    scanf(&quot;%d %d&quot;, &amp;h, &amp;w);\n    while (h || w) &#123;\n        Init();\n        for (int i = 1; i &lt;= h; ++i) &#123;\n            scanf(&quot;%s&quot;, s[i] + 1);\n            for (int j = 1; j &lt;= w; ++j) &#123;\n                if (s[i][j] == &#39;H&#39;)\n                    a[++n][0] = i, a[n][1] = j;\n                else if (s[i][j] == &#39;m&#39;)\n                    b[++m][0] = i, b[m][1] = j;\n            &#125;\n        &#125;\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            for (int j = 1; j &lt;= n; ++j) &#123;\n                g[i][j + n] = -dist(a[i][0],\n                    a[i][1], b[j][0], b[j][1]);\n            &#125;\n        &#125;\n        Solve();\n        for (int i = n + 1; i &lt;= 2 * n; ++i)\n            res += g[mat[i]][i];\n        print(-res, &#39;\\n&#39;);\n        scanf(&quot;%d %d&quot;, &amp;h, &amp;w);\n    &#125;\n    return 0;\n&#125;\n&#125; // namespace XSC062</code></pre>\n</details>\n<hr />\n<h3 id=\"d.-cyclic-tour\">D. Cyclic Tour</h3>\n<p><a href=\"https://vjudge.net/contest/554888#problem/D\" class=\"uri\">https://vjudge.net/contest/554888#problem/D</a></p>\n<p>题意在讲什么啊，看了半天看不懂。</p>\n<p>给定一个有向图，找到若干个互不相交的环覆盖整个图，使得所有环上边权和最小，若找不到方案输出 -1。</p>\n<p>我们知道与这道题相类似的最小路径覆盖问题可以用二分图 + 拆点来解决。那么这里我们也可以小小地拆一拆点。把一个点拆成两个，一个作为起点，一个作为终点，两个点之间连双向边，这样该图就和原图等价。</p>\n<p>拆出来起点之间没有边，拆出来的终点之间也没有边，所以原图是二分图。</p>\n<p>不难发现，假设原图中的环上共有 <span class=\"math inline\">\\(x\\)</span> 个点、<span class=\"math inline\">\\(x\\)</span> 条边，那么拆点后就会有 <span class=\"math inline\">\\(2\\times x\\)</span> 个点和 <span class=\"math inline\">\\(2\\times x\\)</span> 条边，其中 <span class=\"math inline\">\\(x\\)</span> 条边是点 <span class=\"math inline\">\\(i\\)</span> 连向点 <span class=\"math inline\">\\(i&#39;\\)</span>（或反之）的边。</p>\n<p>需要匹配到剩余的实边（而非自己连向自己的虚边）共有 <span class=\"math inline\">\\(x\\)</span> 条，左右部节点都有 <span class=\"math inline\">\\(x\\)</span> 个，考虑设虚边边权为正无穷，进行最小权完美匹配（点和自己连边的操作保证了一定能找到解，不会进入死循环）。</p>\n<p>那么什么时候无解呢？当算法不得不选中虚边时，就说明找不到环了。所以我们判一下匹配有没有包含正无穷边即可。</p>\n<p>记得判重边！</p>\n<details>\n<pre class=\"cpp\"><code>namespace XSC062 &#123;\nusing namespace fastIO;\nconst int maxn = 205;\nconst int inf = 0x3f3f3f3f;\nint g[maxn][maxn];\nint u[maxn], up[maxn];\nint vis[maxn], mat[maxn];\nint n, m, x, y, now, res, w;\nint max(int x, int y) &#123;\n    return x &gt; y ? x : y;\n&#125;\nint min(int x, int y) &#123;\n    return x &lt; y ? x : y;\n&#125;\nbool Find(int x) &#123;\n    vis[x] = now;\n    for (int i = n + 1; i &lt;= 2 * n; ++i) &#123;\n        if (vis[i] == now)\n            continue;\n        if (u[x] + u[i] == g[x][i]) &#123;\n            vis[i] = now;\n            if (!mat[i] || (vis[mat[i]] != now\n                            &amp;&amp; Find(mat[i]))) &#123;\n                mat[i] = x;\n                return 1;\n            &#125;\n        &#125;\n        else &#123;\n            up[i] = min(up[i],\n                u[x] + u[i] - g[x][i]);\n        &#125;\n    &#125;\n    return 0;\n&#125;\nvoid Solve(void) &#123;\n    for (int i = 1; i &lt;= 2 * n; ++i)\n        mat[i] = u[i] = 0;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        u[i] = -inf;\n        for (int j = n + 1; j &lt;= 2 * n; ++j)\n            u[i] = max(u[i], g[i][j]);\n    &#125;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        for (;;) &#123;\n            ++now;\n            for (int j = n + 1; j &lt;= 2 * n; ++j)\n                up[j] = inf;\n            if (Find(i))\n                break;\n            int Delta = inf;\n            for (int j = n + 1;\n                            j &lt;= 2 * n; ++j) &#123;\n                if (vis[j] != now)\n                    Delta = min(Delta, up[j]);\n            &#125;\n            for (int j = 1; j &lt;= n; ++j) &#123;\n                if (vis[j] == now)\n                    u[j] -= Delta;\n            &#125;\n            for (int j = n + 1;\n                            j &lt;= 2 * n; ++j) &#123;\n                if (vis[j] == now)\n                    u[j] += Delta;\n            &#125;\n        &#125;\n    &#125;\n    return;\n&#125;\nint main() &#123;\n    while (read(n)) &#123;\n        read(m);\n        res = 0;\n        for (int i = 1; i &lt;= 2 * n; ++i) &#123;\n            for (int j = 1; j &lt;= 2 * n; ++j) \n                g[i][j] = -inf;\n        &#125;\n        while (m--) &#123;\n            read(x), read(y), read(w);\n            g[x][y + n] = max(g[x][y + n], -w);\n        &#125;\n        Solve();\n        for (int i = n + 1; i &lt;= 2 * n; ++i) &#123;\n            if (g[mat[i]][i] &lt;= -inf) &#123;\n                puts(&quot;-1&quot;);\n                goto NoSol;\n            &#125;\n            res += -g[mat[i]][i];\n        &#125;\n        print(res, &#39;\\n&#39;);\n        NoSol: ;\n    &#125;\n    return 0;\n&#125;\n&#125; // namespace XSC062</code></pre>\n</details>\n<hr />\n<h3 id=\"e.-tour\">E. Tour</h3>\n<p><a href=\"https://vjudge.net/contest/554888#problem/E\" class=\"uri\">https://vjudge.net/contest/554888#problem/E</a></p>\n<p>把上一题输入方式和数据范围改一改就好了。</p>\n<details>\n<pre class=\"cpp\"><code>namespace XSC062 &#123;\nusing namespace fastIO;\nconst int maxn = 405;\nconst int inf = 0x3f3f3f3f;\nint g[maxn][maxn];\nint u[maxn], up[maxn];\nint vis[maxn], mat[maxn];\nint T, n, m, x, y, now, res, w;\nint max(int x, int y) &#123;\n    return x &gt; y ? x : y;\n&#125;\nint min(int x, int y) &#123;\n    return x &lt; y ? x : y;\n&#125;\nbool Find(int x) &#123;\n    vis[x] = now;\n    for (int i = n + 1; i &lt;= 2 * n; ++i) &#123;\n        if (vis[i] == now)\n            continue;\n        if (u[x] + u[i] == g[x][i]) &#123;\n            vis[i] = now;\n            if (!mat[i] || (vis[mat[i]] != now\n                            &amp;&amp; Find(mat[i]))) &#123;\n                mat[i] = x;\n                return 1;\n            &#125;\n        &#125;\n        else &#123;\n            up[i] = min(up[i],\n                u[x] + u[i] - g[x][i]);\n        &#125;\n    &#125;\n    return 0;\n&#125;\nvoid Solve(void) &#123;\n    for (int i = 1; i &lt;= 2 * n; ++i)\n        mat[i] = u[i] = 0;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        u[i] = -inf;\n        for (int j = n + 1; j &lt;= 2 * n; ++j)\n            u[i] = max(u[i], g[i][j]);\n    &#125;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        for (;;) &#123;\n            ++now;\n            for (int j = n + 1; j &lt;= 2 * n; ++j)\n                up[j] = inf;\n            if (Find(i))\n                break;\n            int Delta = inf;\n            for (int j = n + 1;\n                            j &lt;= 2 * n; ++j) &#123;\n                if (vis[j] != now)\n                    Delta = min(Delta, up[j]);\n            &#125;\n            for (int j = 1; j &lt;= n; ++j) &#123;\n                if (vis[j] == now)\n                    u[j] -= Delta;\n            &#125;\n            for (int j = n + 1;\n                            j &lt;= 2 * n; ++j) &#123;\n                if (vis[j] == now)\n                    u[j] += Delta;\n            &#125;\n        &#125;\n    &#125;\n    return;\n&#125;\nint main() &#123;\n    read(T);\n    while(T--) &#123;\n        read(n), read(m);\n        res = 0;\n        for (int i = 1; i &lt;= 2 * n; ++i) &#123;\n            for (int j = 1; j &lt;= 2 * n; ++j) \n                g[i][j] = -inf;\n        &#125;\n        while (m--) &#123;\n            read(x), read(y), read(w);\n            g[x][y + n] = max(g[x][y + n], -w);\n        &#125;\n        Solve();\n        for (int i = n + 1; i &lt;= 2 * n; ++i) &#123;\n            if (g[mat[i]][i] &lt;= -inf) &#123;\n                puts(&quot;-1&quot;);\n                goto NoSol;\n            &#125;\n            res += -g[mat[i]][i];\n        &#125;\n        print(res, &#39;\\n&#39;);\n        NoSol: ;\n    &#125;\n    return 0;\n&#125;\n&#125; // namespace XSC062</code></pre>\n</details>\n<hr />\n<h3 id=\"d.-导弹防御塔\">D. 导弹防御塔</h3>\n<p><a href=\"http://222.180.160.110:61235/contest/3699/problem/4\" class=\"uri\">http://222.180.160.110:61235/contest/3699/problem/4</a></p>\n<p>GM 说的好哇（指 <em>毛病多，一会儿分钟一会儿秒</em>）。</p>\n<p>寻找冲突。一个敌人只能被一炮打死，故考虑</p>\n<p>但一个塔可以打很多炮，考虑拆点。</p>\n",
            "tags": [
                "二分图"
            ]
        }
    ]
}