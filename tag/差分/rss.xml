<?xml version="1.0"?>
<rss version="2.0">
    <channel>
        <title> • Posts by &#34;差分&#34; tag</title>
        <link>https://xsc062.netlify.app</link>
        <description></description>
        <language>zh-CN</language>
        <pubDate>Wed, 23 Jul 2025 15:06:07 +0800</pubDate>
        <lastBuildDate>Wed, 23 Jul 2025 15:06:07 +0800</lastBuildDate>
        <category>并查集</category>
        <category>斜率优化</category>
        <category>悬线法</category>
        <category>哈希</category>
        <category>字典树</category>
        <category>DP</category>
        <category>单调队列</category>
        <category>分治</category>
        <category>计数</category>
        <category>二分图</category>
        <category>CRT / exCRT</category>
        <category>排列组合</category>
        <category>网络流</category>
        <category>费用流</category>
        <category>二分</category>
        <category>上下界网络流</category>
        <category>容斥原理</category>
        <category>线段树</category>
        <category>树状数组</category>
        <category>区间 DP</category>
        <category>构造</category>
        <category>数据结构</category>
        <category>Tarjan</category>
        <category>下饭</category>
        <category>LCA</category>
        <category>倍增</category>
        <category>鸽巢原理</category>
        <category>概率期望</category>
        <category>调和级数</category>
        <category>差分</category>
        <category>思维</category>
        <category>树形 DP</category>
        <category>最小生成树</category>
        <category>SAM</category>
        <category>状压</category>
        <category>分块</category>
        <category>可持久化</category>
        <category>笛卡尔树</category>
        <category>高维前缀和</category>
        <category>闲话</category>
        <category>欧拉回路</category>
        <category>树链剖分</category>
        <category>长链剖分</category>
        <category>KMP</category>
        <category>border</category>
        <category>字符串</category>
        <category>AC 自动机</category>
        <category>SA</category>
        <category>数学</category>
        <category>树上差分</category>
        <category>FWT</category>
        <category>堆</category>
        <category>树的重心</category>
        <category>二项式定理</category>
        <category>二项式反演</category>
        <category>贪心</category>
        <category>均摊</category>
        <category>优化建图</category>
        <category>反悔贪心</category>
        <category>调整法</category>
        <category>背包</category>
        <category>博弈论</category>
        <category>DP 优化</category>
        <category>虚树</category>
        <category>点分治</category>
        <category>WQS 二分</category>
        <category>闵可夫斯基和</category>
        <category>slope trick</category>
        <category>四边形不等式</category>
        <category>状压 DP</category>
        <category>组合数学</category>
        <category>支配对</category>
        <category>DDP</category>
        <category>容斥</category>
        <category>Kruskal 重构树</category>
        <category>高精度</category>
        <category>最短路</category>
        <category>树套树</category>
        <category>Boruvka</category>
        <category>树链剖分 - 最小生成树</category>
        <category>李超线段树</category>
        <item>
            <guid isPermalink="true">https://xsc062.netlify.app/20250723/</guid>
            <title>vp 记录 edu 181</title>
            <link>https://xsc062.netlify.app/20250723/</link>
            <category>差分</category>
            <category>背包</category>
            <pubDate>Wed, 23 Jul 2025 15:06:07 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;tzl 太强了！真挚的膜拜&lt;/p&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;
&lt;p&gt;lhy 太强了！真挚的膜拜&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;e.-sets-of-complementary-sums&#34;&gt;E. Sets of Complementary Sums&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://codeforces.com/contest/2125/problem/E&#34; class=&#34;uri&#34;&gt;https://codeforces.com/contest/2125/problem/E&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;分拆数、其实是个不牛的东西，但是写假了 😅&lt;/p&gt;
&lt;p&gt;令集合元素升序排列为 &lt;span class=&#34;math inline&#34;&gt;\(b_{1\sim n}\)&lt;/span&gt;。显然有结论 &lt;span class=&#34;math inline&#34;&gt;\(\sum b\geqslant (n-1)(b_n+1)\)&lt;/span&gt;，化一下就有 &lt;span class=&#34;math inline&#34;&gt;\(b_n\geqslant \left(\sum\limits_{i=1}^{n-1} b_n-b_i\right)+(n-1)\)&lt;/span&gt;。发现 RSH 取值对 LSH 无影响（从取等开始，RSH 不变，若 &lt;span class=&#34;math inline&#34;&gt;\(b_n\gets b_n+1\)&lt;/span&gt;，只需将每个 &lt;span class=&#34;math inline&#34;&gt;\(b_i\gets b_i+1\)&lt;/span&gt; 即可构造出一组解），故只用考虑 RSH 的每种取值下的方案。&lt;/p&gt;
&lt;p&gt;然后就可以做 &lt;a href=&#34;/20250807/&#34;&gt;分拆数&lt;/a&gt; 了。发现会 MLE，滚动即可。每次暴力 assign 会很慢，可以用一点巧思清空滚动数组。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int mod = 998244353;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#endif
    int T;
    for (std::cin &amp;gt;&amp;gt; T; T--; ) &amp;#123;
        long long n, m;
        std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
        if (n * (n - 1) / 2 &amp;gt; m) &amp;#123;
            std::cout &amp;lt;&amp;lt; 0 &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
            continue;
        &amp;#125;
        if (n == 1) &amp;#123;
            std::cout &amp;lt;&amp;lt; m &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
            continue;
        &amp;#125;
        --n;
        std::vector&amp;lt;std::vector&amp;lt;long long&amp;gt; &amp;gt; f(2, std::vector &amp;lt;long long&amp;gt; (m + 1));
        f[0][0] = 1ll;
        for (int j = 1, at = 1; j &amp;lt;= n; ++j, at ^= 1)
            for (int i = 0; i &amp;lt;= m; ++i) &amp;#123;
                if (i &amp;lt; j)
                    f[at][i] = 0;
                else
                    f[at][i] = (f[at ^ 1][i - j] + f[at][i - j]) % mod;
            &amp;#125;
        auto res(0ll);
        for (int i = 1; i &amp;lt;= m - n; ++i)
            (res += f[n &amp;amp; 1][i] * (m - (i + n) + 1)) %= mod;
        std::cout &amp;lt;&amp;lt; res &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    &amp;#125;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;vp-记录&#34;&gt;vp 记录&lt;/h2&gt;
&lt;h3 id=&#34;a&#34;&gt;A&lt;/h3&gt;
&lt;p&gt;1:43 切。打 &lt;code&gt;std::&lt;/code&gt; 还是太费时间了。&lt;/p&gt;
&lt;h3 id=&#34;b&#34;&gt;B&lt;/h3&gt;
&lt;p&gt;5:46 切，看完题没想到 gcd，输出的时候想到了。莼菜。&lt;/p&gt;
&lt;h3 id=&#34;c&#34;&gt;C&lt;/h3&gt;
&lt;p&gt;11:23 切，原因是容斥符号乱写。&lt;/p&gt;
&lt;h3 id=&#34;d&#34;&gt;D&lt;/h3&gt;
&lt;p&gt;24:21 切，中间重构了一次并且前缀和的部分考虑得有点问题。绅士（38:35）问我为啥做这么快。&lt;/p&gt;
&lt;h3 id=&#34;e.0&#34;&gt;E.0&lt;/h3&gt;
&lt;p&gt;看了一眼感觉不太可做。quack 说 F 板板，故跳。&lt;/p&gt;
&lt;h3 id=&#34;f&#34;&gt;F&lt;/h3&gt;
&lt;p&gt;01:13:41 草完。奇怪的 WQS 二分板板。吃了一发罚时，原因是没人合法的时候要输出 &lt;span class=&#34;math inline&#34;&gt;\(0\)&lt;/span&gt;。但和 maimai 的 30 发比起来还是相形见绌。绅士考虑了这个，但是没判目标 &lt;span class=&#34;math inline&#34;&gt;\(&amp;lt;\)&lt;/span&gt; 当前的情况遗憾 4 题离场。&lt;/p&gt;
&lt;p&gt;场下看了 Diagnostics，发现其实第二发有个地方是 RE 了的（长度不足 &lt;span class=&#34;math inline&#34;&gt;\(6\)&lt;/span&gt; 我的 &lt;code&gt;*std::max_element&lt;/code&gt; 会飞起来），但是不知道为啥就是 A 了。&lt;/p&gt;
&lt;h3 id=&#34;e.1&#34;&gt;E.1&lt;/h3&gt;
&lt;p&gt;猜到结论之后止步于此。试着打了分拆数然后（实际上是）写挂了，怀疑自己结论出错直到 5 题招笑离场 😅&lt;/p&gt;
&lt;h3 id=&#34;b.1&#34;&gt;B.1&lt;/h3&gt;
&lt;p&gt;哈哈 B 的 gcd 没开 &lt;code&gt;long long&lt;/code&gt; 被 hack 了，rk55 to 6000+&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://xsc062.netlify.app/20240131/</guid>
            <title>USACO2024JAN 三组连打</title>
            <link>https://xsc062.netlify.app/20240131/</link>
            <category>鸽巢原理</category>
            <category>调和级数</category>
            <category>差分</category>
            <category>思维</category>
            <category>树形 DP</category>
            <pubDate>Wed, 31 Jan 2024 10:30:29 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;假的，只连打了两组。Ag 没时间了。日后再补吧。&lt;/p&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;
&lt;p&gt;&lt;img src=&#34;https://pic.imgdb.cn/item/65b7b152871b83018ac5e7b7.gif&#34; /&gt;&lt;/p&gt;
&lt;p&gt;无意中存了题面，但代码大部分因为系统还原消失了，只有文字题解，将就着看吧。&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;cu-a.-majority-opinion&#34;&gt;Cu A. Majority Opinion&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P10131&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P10131&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;省流：任意区间内，若某元素出现个数严格大于区间长度一半，则可将整个区间推平为该值。问最终可以使整个序列被推平为哪些值。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;注意到当任意长度 &lt;span class=&#34;math inline&#34;&gt;\(\ge 2\)&lt;/span&gt; 的区间可以被推平为某种元素时，整个数列都可以被推平为该元素。故目标转化为对于某种元素判定是否存在一个可被其推平的区间。&lt;/p&gt;
&lt;p&gt;统计元素个数采用前缀和。令 &lt;span class=&#34;math inline&#34;&gt;\(s_i\)&lt;/span&gt; 表示 &lt;span class=&#34;math inline&#34;&gt;\(h_i\)&lt;/span&gt; 在前 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 项中出现的次数，假设有 &lt;span class=&#34;math inline&#34;&gt;\([j,i]\)&lt;/span&gt; 满足条件，贪心可知 &lt;span class=&#34;math inline&#34;&gt;\(h_i=h_j\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;那么由定义有 &lt;span class=&#34;math inline&#34;&gt;\(i-j+1&amp;lt;2\times (s_i-s_j+1)\)&lt;/span&gt;。典中典，直接移项分离变量。则有 &lt;span class=&#34;math inline&#34;&gt;\(i-2\times s_i-1&amp;lt;j-2\times s_j\)&lt;/span&gt;。令 &lt;span class=&#34;math inline&#34;&gt;\(t_p\gets p-2\times s_p\)&lt;/span&gt;，对于每个 &lt;span class=&#34;math inline&#34;&gt;\(h\)&lt;/span&gt; 记录 &lt;span class=&#34;math inline&#34;&gt;\(t_j\)&lt;/span&gt; 最大值查看是否有 &lt;span class=&#34;math inline&#34;&gt;\(i,j\)&lt;/span&gt; 满足条件即可。&lt;/p&gt;
&lt;h3 id=&#34;cu-b.-cannonball&#34;&gt;Cu B. Cannonball&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P10132&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P10132&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;省流：有 &lt;span class=&#34;math inline&#34;&gt;\(N\)&lt;/span&gt; 个格子，从 &lt;span class=&#34;math inline&#34;&gt;\(s\)&lt;/span&gt; 格子开始以 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt; 为初始能量向右跳，跳一步的距离为能量大小。格子分两种，一种经过加一定能量并反向，另一种若当前能量大于一定值则可永久摧毁，问跳出范围或无限长时间后可摧毁格子个数。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;不难发现若忽略增加能量为 &lt;span class=&#34;math inline&#34;&gt;\(0\)&lt;/span&gt; 的跳板则每经过一个跳板可跳距离增加 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt;，最多增加到 &lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt;，否则会跳出去。&lt;/p&gt;
&lt;p&gt;注意到调和级数，故直接模拟跳的过程。唯一导致时间无限的情况是存在相邻的增加能量为 &lt;span class=&#34;math inline&#34;&gt;\(0\)&lt;/span&gt; 的跳板，但其实它具体是什么并不重要，反正我们跳的次数严格大于调和级数后就可以认为进入死循环，直接结束模拟即可。我这里嫌麻烦直接拿了 &lt;span class=&#34;math inline&#34;&gt;\(2\times 10^8\)&lt;/span&gt; 作阈值。&lt;/p&gt;
&lt;h3 id=&#34;cu-c.-balancing-bacteria&#34;&gt;Cu C. Balancing Bacteria&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P10133&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P10133&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;省流：定义一次操作为选取一个整数 &lt;span class=&#34;math inline&#34;&gt;\(\Delta\le N\)&lt;/span&gt;，并从 &lt;span class=&#34;math inline&#34;&gt;\(N\)&lt;/span&gt; 到 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt;，令 &lt;span class=&#34;math inline&#34;&gt;\(a_i\gets a_i+\Delta\)&lt;/span&gt; 并令 &lt;span class=&#34;math inline&#34;&gt;\(\Delta\)&lt;/span&gt; 向 &lt;span class=&#34;math inline&#34;&gt;\(0\)&lt;/span&gt; 靠近 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt;，&lt;span class=&#34;math inline&#34;&gt;\(\Delta=0\)&lt;/span&gt; 时停止。问令所有 &lt;span class=&#34;math inline&#34;&gt;\(a_i=0\)&lt;/span&gt; 所需最少操作次数。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;挺有意思的思维题，首先需要进行一个思维转化。&lt;span class=&#34;math inline&#34;&gt;\(\Delta\le N\)&lt;/span&gt; 是一个利于解题的限制，这意味着我们想让任何一个 &lt;span class=&#34;math inline&#34;&gt;\(a_i\)&lt;/span&gt; 改变 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt; 而不影响到之前的值，从让 &lt;span class=&#34;math inline&#34;&gt;\(a_1\gets 0\)&lt;/span&gt; 入手，进行一次操作后每个 &lt;span class=&#34;math inline&#34;&gt;\(a_i\)&lt;/span&gt; 分到的 &lt;span class=&#34;math inline&#34;&gt;\(\Delta\)&lt;/span&gt; 应依次加 1 或依次减 1。则差分数组为 &lt;span class=&#34;math inline&#34;&gt;\(0\)&lt;/span&gt; 后跟着一截 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt; 是理想状态。中间每有一项不满足规律都会带来额外的操作次数。&lt;/p&gt;
&lt;p&gt;归纳为差分数组的差分数组绝对值之和即为答案。&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;ag-a.-cowmpetency&#34;&gt;Ag A. Cowmpetency&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P10134&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P10134&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;省流：有若干条限制，每条形如 &lt;span class=&#34;math inline&#34;&gt;\(\max\limits_{i=1}^{a_h-1}\{A_i\}=\max\limits_{i=1}^{a_j}\{A_i\}\)&lt;/span&gt; 且 &lt;span class=&#34;math inline&#34;&gt;\(A_{a_h}&amp;gt;\max\limits_{i=1}^{a_h-1}\{A_i\}\)&lt;/span&gt;，部分数已知，构造出符合条件且字典序最小的序列。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;是本场最难题吧，但也没啥卡的。画个线段图容易发现，若将 &lt;span class=&#34;math inline&#34;&gt;\([a,h)\)&lt;/span&gt; 视作一条线段，那么除非 &lt;span class=&#34;math inline&#34;&gt;\(h\)&lt;/span&gt; 相同，否则两条线段不能有交集。不然的话就无解。以及如果存在不满足条件的定值也显然无解。&lt;/p&gt;
&lt;p&gt;从前往后看每个 &lt;span class=&#34;math inline&#34;&gt;\(h\)&lt;/span&gt; 并尝试赋值，对于每个 &lt;span class=&#34;math inline&#34;&gt;\(1\sim a\)&lt;/span&gt; 记录一个需要满足的最大值数值，按照此数值从后往前填空格。&lt;/p&gt;
&lt;p&gt;填完过后扫一遍看看是不是全部合法，可以证明若此时不合法则无解。&lt;/p&gt;
&lt;h3 id=&#34;ag-b.-potion-farming&#34;&gt;Ag B. Potion Farming&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P10135&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P10135&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;省流：一棵树，每个点上有若干个物品，对于每条从根到叶子的简单路径，可以选择路径上的一个物品，每个物品只能被选一次，问最多可选物品数。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;如果一个点引导的子树下所有叶子有没有分配到的，就可以把这个点的物品分配给该叶子。&lt;/p&gt;
&lt;p&gt;跑一个树形 DP 即可。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;namespace XSC062 &amp;#123;
using namespace fastIO;
const int maxn = 1e5 + 5;
int n, x, y;
int cnt[maxn];
std::vector&amp;lt;int&amp;gt; g[maxn];
int a[maxn], f[maxn], p[maxn];
int min(int x, int y) &amp;#123;
    return x &amp;lt; y ? x : y;
&amp;#125;
void DFS(int x, int fa) &amp;#123;
    if ((int)g[x].size() == 1)
        cnt[x] = 1;
    for (auto i : g[x]) &amp;#123;
        if (i == fa) continue;
        DFS(i, x);
        f[x] += f[i];
        cnt[x] += cnt[i];
    &amp;#125;
    if (f[x] &amp;lt; cnt[x])
        f[x] = min(f[x] + a[x], cnt[x]);
    return;
&amp;#125;
void add(int x, int y) &amp;#123;
    g[x].push_back(y);
    return;
&amp;#125;
int main() &amp;#123;
    read(n);
    for (int i = 1; i &amp;lt;= n; ++i) read(p[i]);
    for (int i = 1; i &amp;lt; n; ++i) &amp;#123;
        read(x), read(y);
        add(x, y), add(y, x);
    &amp;#125;
    int tot = 0;
    for (int i = 2; i &amp;lt;= n; ++i)
        tot += ((int)g[i].size() == 1);
    for (int i = 1; i &amp;lt;= tot; ++i) ++a[p[i]];
    DFS(1, -1);
    print(f[1], &amp;#39;\n&amp;#39;);
    return 0;
&amp;#125;
&amp;#125; // namespace XSC062&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h3 id=&#34;ag-c.-cowlendar&#34;&gt;Ag C. Cowlendar&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P10136&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P10136&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;省流：对于给定的序列 &lt;span class=&#34;math inline&#34;&gt;\(a\)&lt;/span&gt;，找出所有满足 &lt;span class=&#34;math inline&#34;&gt;\(a_i\bmod L\)&lt;/span&gt; 的值的种类最多为 3 的 &lt;span class=&#34;math inline&#34;&gt;\(L\)&lt;/span&gt;。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;也是挺有意思的数学题了。若将 &lt;span class=&#34;math inline&#34;&gt;\(a_i\)&lt;/span&gt; 按照模 &lt;span class=&#34;math inline&#34;&gt;\(L\)&lt;/span&gt; 的情况分组，则对于任意一个 &lt;span class=&#34;math inline&#34;&gt;\(a_i\)&lt;/span&gt;，在 &lt;span class=&#34;math inline&#34;&gt;\((a_i,a_i+L)\)&lt;/span&gt; 中最多包含两个分别来自其余两组的数。&lt;/p&gt;
&lt;p&gt;对于去重后 &lt;span class=&#34;math inline&#34;&gt;\(n&amp;gt;3\)&lt;/span&gt; 的情况，由鸽巢得必定有两个数可分为一组。故我们枚举可能的组间间隔，而可能的 &lt;span class=&#34;math inline&#34;&gt;\(L\)&lt;/span&gt; 就是这些间隔的因数。&lt;/p&gt;
&lt;p&gt;由上面我们推出一个合法组间间隔中最多间隔三个数，我们将所有 &lt;span class=&#34;math inline&#34;&gt;\(a_{i+3}-a_i\)&lt;/span&gt;、&lt;span class=&#34;math inline&#34;&gt;\(a_{i+2}-a_i\)&lt;/span&gt; 和 &lt;span class=&#34;math inline&#34;&gt;\(a_{i+1}-a_i\)&lt;/span&gt; 纳入考虑范围即可。对于所有可能的 &lt;span class=&#34;math inline&#34;&gt;\(L\)&lt;/span&gt;，直接 &lt;span class=&#34;math inline&#34;&gt;\(O(n)\)&lt;/span&gt; 跑一个 &lt;code&gt;check&lt;/code&gt; 检查是否合法。&lt;/p&gt;
&lt;p&gt;因子个数照理来说是 &lt;span class=&#34;math inline&#34;&gt;\(\sqrt{V}\times n\)&lt;/span&gt; 级别的，但是实测 &lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt; 最多只有一百多。估计是因为 &lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt; 太大就很难构造出更多的合法解吧。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#define int long long
namespace XSC062 &amp;#123;
using namespace fastIO;
const int maxn = 1e4 + 5;
const int maxm = 3e4 + 5;
std::set&amp;lt;int&amp;gt; u;
int n, res, mn, tot;
int a[maxn], b[maxm];
bool check(int x) &amp;#123;
    int l1 = 0, l2 = 0, l3 = 0;
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        if (l1 == 0) l1 = a[i];
        else if (x &amp;amp;&amp;amp; (a[i] - l1) % x == 0) l1 = a[i];
        else if (l2 == 0) l2 = a[i];
        else if (x &amp;amp;&amp;amp; (a[i] - l2) % x == 0) l2 = a[i];
        else if (l3 == 0) l3 = a[i];
        else if (x &amp;amp;&amp;amp; (a[i] - l3) % x == 0) l3 = a[i];
        else return 0;
    &amp;#125;
    return 1;
&amp;#125;
int main() &amp;#123;
    read(n);
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        read(a[i]);
        if (!mn || a[i] / 4 &amp;lt; mn) mn = a[i] / 4;
    &amp;#125;
    std::sort(a + 1, a + n + 1);
    n = std::unique(a + 1, a + n + 1) - a - 1;
    if (check(0)) &amp;#123;
        print(mn * (mn + 1) / 2, &amp;#39;\n&amp;#39;);
        return 0;
    &amp;#125;
    for (int i = 2; i &amp;lt;= n; ++i) &amp;#123;
        b[++tot] = a[i] - a[i - 1];
        if (i &amp;gt;= 3) b[++tot] = a[i] - a[i - 2];
        if (i &amp;gt;= 4) b[++tot] = a[i] - a[i - 3];
    &amp;#125;
    std::sort(b + 1, b + tot + 1);
    tot = std::unique(b + 1, b + tot + 1) - b - 1;
    for (int i = 1; i &amp;lt;= tot; ++i) &amp;#123;
        if (check(b[i])) &amp;#123;
            for (int j = 1; j * j &amp;lt;= b[i]; ++j) &amp;#123;
                if (b[i] % j == 0)
                    u.insert(j), u.insert(b[i] / j);
            &amp;#125;
        &amp;#125;
    &amp;#125;
    for (auto i : u) &amp;#123;
        if (i &amp;gt; mn) break;
        res += i;
    &amp;#125;
    print(res, &amp;#39;\n&amp;#39;);
    return 0;
&amp;#125;
&amp;#125; // namespace XSC062
#undef int&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;/deteails&gt;&lt;/p&gt;
 ]]></description>
        </item>
    </channel>
</rss>
