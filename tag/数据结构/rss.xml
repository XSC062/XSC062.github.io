<?xml version="1.0"?>
<rss version="2.0">
    <channel>
        <title> • Posts by &#34;数据结构&#34; tag</title>
        <link>https://xsc062.netlify.app</link>
        <description></description>
        <language>zh-CN</language>
        <pubDate>Sun, 12 Nov 2023 16:42:43 +0800</pubDate>
        <lastBuildDate>Sun, 12 Nov 2023 16:42:43 +0800</lastBuildDate>
        <category>并查集</category>
        <category>斜率优化</category>
        <category>悬线法</category>
        <category>哈希</category>
        <category>字典树</category>
        <category>DP</category>
        <category>单调队列</category>
        <category>分治</category>
        <category>二分图</category>
        <category>CRT / exCRT</category>
        <category>排列组合</category>
        <category>网络流</category>
        <category>费用流</category>
        <category>二分</category>
        <category>上下界网络流</category>
        <category>容斥原理</category>
        <category>线段树</category>
        <category>树状数组</category>
        <category>区间 DP</category>
        <category>构造</category>
        <category>Tarjan</category>
        <category>数据结构</category>
        <category>下饭</category>
        <category>LCA</category>
        <category>倍增</category>
        <category>鸽巢原理</category>
        <category>概率期望</category>
        <category>调和级数</category>
        <category>差分</category>
        <category>思维</category>
        <category>树形 DP</category>
        <category>最小生成树</category>
        <category>SAM</category>
        <category>状压</category>
        <category>分块</category>
        <category>可持久化</category>
        <category>笛卡尔树</category>
        <category>高维前缀和</category>
        <category>闲话</category>
        <category>欧拉回路</category>
        <category>树链剖分</category>
        <category>长链剖分</category>
        <category>KMP</category>
        <category>border</category>
        <category>字符串</category>
        <category>AC 自动机</category>
        <category>SA</category>
        <category>数学</category>
        <category>树上差分</category>
        <category>FWT</category>
        <category>堆</category>
        <category>树的重心</category>
        <category>二项式定理</category>
        <category>二项式反演</category>
        <category>贪心</category>
        <category>均摊</category>
        <category>计数</category>
        <category>优化建图</category>
        <category>反悔贪心</category>
        <category>调整法</category>
        <category>背包</category>
        <category>博弈论</category>
        <category>DP 优化</category>
        <category>虚树</category>
        <category>点分治</category>
        <category>WQS 二分</category>
        <category>闵可夫斯基和</category>
        <category>slope trick</category>
        <category>四边形不等式</category>
        <category>暴力</category>
        <category>状压 DP</category>
        <category>组合数学</category>
        <category>支配对</category>
        <category>DDP</category>
        <category>平衡树</category>
        <category>容斥</category>
        <category>猫树</category>
        <category>Kruskal 重构树</category>
        <category>李超线段树</category>
        <item>
            <guid isPermalink="true">https://xsc062.netlify.app/20231112/</guid>
            <title>杂题</title>
            <link>https://xsc062.netlify.app/20231112/</link>
            <category>数据结构</category>
            <pubDate>Sun, 12 Nov 2023 16:42:43 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;&lt;a href=&#34;http://222.180.160.110:61235/contest/4424&#34;&gt;NOIP S&lt;/a&gt; &amp;amp; &lt;a href=&#34;http://222.180.160.110:61235/contest/4423&#34;&gt;周考 16&lt;/a&gt; &amp;amp; 杂题。&lt;/p&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;a.-数字游戏&#34;&gt;A. 数字游戏&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;http://222.180.160.110:61235/contest/4424/problem/1&#34; class=&#34;uri&#34;&gt;http://222.180.160.110:61235/contest/4424/problem/1&lt;/a&gt;&lt;/p&gt;
&lt;details&gt;
&lt;p&gt;&lt;summary&gt;闲话&lt;/summary&gt;&lt;/p&gt;
&lt;p&gt;一开始忘了怎么做的然后从 Cindy 的做法开始回忆，一边回忆一边写下文，结果发现写着写着变成 wjf 的做法了 /cf&lt;/p&gt;
&lt;p&gt;upd：变成菌的做法了 /cf /cf /cf&lt;/p&gt;
&lt;p&gt;upd：变成 zmq 的做法了，我已经懒得 /cf 了。&lt;/p&gt;
&lt;/details&gt;
&lt;p&gt;题意转化一下，大致就是一个每次往右拓展一位的询问区间，每次查询该询问区间内最大值并拿走之。&lt;/p&gt;
&lt;p&gt;我们先感性地想，对于一个 &lt;strong&gt;很大的值&lt;/strong&gt;，它一进入询问范围就会被当场拿走。&lt;/p&gt;
&lt;p&gt;那如果没有被拿走是因为什么呢？因为在前面积存下来的元素中还有比它大的。&lt;/p&gt;
&lt;p&gt;那为什么前面的比它大的元素没有被当场拿走呢？因为在更前面积存下来的有比这个元素大的…… 那么最开始的积存是怎么来的呢？是最初询问区间为 &lt;span class=&#34;math inline&#34;&gt;\([1,p_i]\)&lt;/span&gt; 而非 &lt;span class=&#34;math inline&#34;&gt;\([1,1]\)&lt;/span&gt; 导致的。&lt;/p&gt;
&lt;p&gt;被积存下的数被拿出来用掉的时刻，就是往后碰到了一个比它小的值，然后顶替掉这个值被用掉。被顶替的就进入积存区。&lt;/p&gt;
&lt;p&gt;所以这个时候我们直接 &lt;strong&gt;模拟&lt;/strong&gt; 积存数被用掉的过程。&lt;/p&gt;
&lt;p&gt;对于全序列中的最大值，当场用掉。次大值呢，若它比最大值先进入询问区间，皆大欢喜，当场用掉；又因为最大值不可能被积存，就算它在最大值之后，也可以当场用掉。&lt;/p&gt;
&lt;p&gt;第三大的，就可能进积存区。假设它要出来，首先要满足出来的时间（在进入积存区之后，有点废话），然后如果它一出来就碰到了比它更大的，很不幸，出不来了。但是因为除了最大和次大之外没有元素比它大了，它就可以在剩下的位置里面随便挑——当然是挑最靠前的。后面的和第三大道理就差不多了。&lt;/p&gt;
&lt;p&gt;所以这个时候我们就可以得到一个大致的做法了，我们把元素从大到小排序，顺便记录一下它进入询问范围的时间 &lt;span class=&#34;math inline&#34;&gt;\(t\)&lt;/span&gt;。然后我们优先让这个值在 &lt;span class=&#34;math inline&#34;&gt;\(t\)&lt;/span&gt; 时刻直接被拿走。那假如 &lt;span class=&#34;math inline&#34;&gt;\(t\)&lt;/span&gt; 这个位置已经被更大的元素占领了，就找这之后第一个空位。&lt;/p&gt;
&lt;p&gt;那么这个「第一个空位」怎么找呢？我们用一个初值为 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt; 的 &lt;span class=&#34;math inline&#34;&gt;\(pos\)&lt;/span&gt;，对于当场拿走的情况，肯定是不会有冲突的，所以冲突都发生在积存区。积存区又都是从 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt; 开始的，所以我们只需要对于不是当场拿走的情况，把 &lt;span class=&#34;math inline&#34;&gt;\(pos\)&lt;/span&gt; 移到距离 &lt;strong&gt;当前值&lt;/strong&gt; 最近的空位然后放进去就可以了。因为 &lt;span class=&#34;math inline&#34;&gt;\(pos\)&lt;/span&gt; 全程只会右移，摊出来是 &lt;span class=&#34;math inline&#34;&gt;\(O(n)\)&lt;/span&gt; 的。&lt;/p&gt;
&lt;p&gt;因为我们只要在最开始排个序，总时间复杂度 &lt;span class=&#34;math inline&#34;&gt;\(O(n\log n + nq)\)&lt;/span&gt;。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#define int long long
namespace XSC062 &amp;#123;
using namespace fastIO;
const int maxn = 1e5 + 5;
struct _ &amp;#123;
    int x, i;
    bool operator&amp;lt; (const _ &amp;amp;q) const &amp;#123;
        return x &amp;gt; q.x;
    &amp;#125;
&amp;#125;;
_ a[maxn];
int flag[maxn];
int n, m, p, res, pos;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    freopen(&amp;quot;game.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    freopen(&amp;quot;game.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#endif
    read(n), read(m);
    for (int i = 1; i &amp;lt;= n; ++i)
        read(a[i].x), a[i].i = i;
    std::sort(a + 1, a + n + 1);
    while (m--) &amp;#123;
        read(p), res = 0, pos = 1;
        for (int i = 1; i &amp;lt;= n; ++i)
            flag[i] = 0;
        for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
            int id =
            (a[i].i &amp;lt; p ? 1 : a[i].i - p + 1);
            if (flag[id]) &amp;#123;
                while (flag[pos]) ++pos;
                flag[pos] = i;
            &amp;#125;
            else flag[id] = i;
        &amp;#125;
        for (int i = 1, j = 1; i &amp;lt;= n; ++i, j = -j) 
            res += j * a[flag[i]].x;
        print(res, &amp;#39;\n&amp;#39;);
    &amp;#125;
    return 0;
&amp;#125;
&amp;#125; // namespace XSC062
#undef int&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;b.-过河卒ii&#34;&gt;B. 过河卒II&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;http://222.180.160.110:61235/contest/4424/problem/2&#34; class=&#34;uri&#34;&gt;http://222.180.160.110:61235/contest/4424/problem/2&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;以及 &lt;a href=&#34;https://www.luogu.com.cn/problem/P6234&#34;&gt;这&lt;/a&gt; 是原题。&lt;/p&gt;
&lt;p&gt;读错题了整整 3.5h /youl&lt;/p&gt;
&lt;p&gt;我们接下来把「特殊格子」记为 &lt;code&gt;-&lt;/code&gt;，「特殊格子」四个方向相邻的点记作 &lt;code&gt;O&lt;/code&gt;，除此之外的点因为没有可能被选到，我们不做讨论。&lt;/p&gt;
&lt;pre class=&#34;plain&#34;&gt;&lt;code&gt;  -
- O -
  -&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对于一个关键点，我们发现找 T 字本身不太方便，所以我们可以把这个转化成在十字里面抠掉一个最小值。&lt;/p&gt;
&lt;p&gt;接下来，我们假设有另一个关键点的十字和这一个的十字有重合并不相邻，那么大抵是形如这个样子的：&lt;/p&gt;
&lt;pre class=&#34;plain&#34;&gt;&lt;code&gt;  -   -
- O - O -
  -   -&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个时候，我们发现一共有 7 个 &lt;code&gt;-&lt;/code&gt;，一共需要 6 个 &lt;code&gt;-&lt;/code&gt;，所以我们试着随便抠掉一个。&lt;/p&gt;
&lt;pre class=&#34;plain&#34;&gt;&lt;code&gt;  X   | -
- O - | O -
  -   | -&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们发现这个时候一定是能找到一个 &lt;strong&gt;确定的&lt;/strong&gt; 方案去划分 T 字的。&lt;/p&gt;
&lt;p&gt;所以对于两个 &lt;code&gt;O&lt;/code&gt; 的情况，我们抠掉七个 &lt;code&gt;-&lt;/code&gt; 当中的最小值即可。&lt;/p&gt;
&lt;p&gt;接下来假设有三个 &lt;code&gt;O&lt;/code&gt;，那么会有 10 个 &lt;code&gt;-&lt;/code&gt;，但我们需要 9 个，于是抠掉最小值，依然存在一种 &lt;strong&gt;确定的&lt;/strong&gt; 方案去划分 T 字。&lt;/p&gt;
&lt;p&gt;不难发现，&lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt; 彼此影响还不相邻的 &lt;code&gt;O&lt;/code&gt; 会带来 &lt;span class=&#34;math inline&#34;&gt;\(3\times n-1\)&lt;/span&gt; 个 &lt;code&gt;-&lt;/code&gt;（小学数学计算即可），我们将最小者删除即可得到最大答案。&lt;/p&gt;
&lt;p&gt;推广一下结论，其实是我们对于 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 个相互影响的 &lt;code&gt;O&lt;/code&gt;（注意这里 &lt;strong&gt;没有强调&lt;/strong&gt; 不相邻），删掉一些使得 &lt;code&gt;-&lt;/code&gt; 的数量为 &lt;span class=&#34;math inline&#34;&gt;\(3x\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;那么我们又知道对于最理想的情况，也就是上面讲到的相互影响又不相邻，&lt;code&gt;-&lt;/code&gt; 的个数是 &lt;span class=&#34;math inline&#34;&gt;\(3\times x+1\)&lt;/span&gt;，我们又只能进行抠掉 &lt;code&gt;-&lt;/code&gt; 这一个操作。&lt;/p&gt;
&lt;p&gt;所以对于一个 &lt;code&gt;O/-&lt;/code&gt; 连通块，要求其 &lt;code&gt;-&lt;/code&gt; 的个数要么是 &lt;span class=&#34;math inline&#34;&gt;\(3x\)&lt;/span&gt;（不然 &lt;code&gt;-&lt;/code&gt; 就不够用了，以及 &lt;code&gt;-&lt;/code&gt; 的缺失是相邻的 &lt;code&gt;O&lt;/code&gt; 和边界导致的；边界外的 &lt;code&gt;-&lt;/code&gt; 肯定是不能算的），要么为 &lt;span class=&#34;math inline&#34;&gt;\(3x+1\)&lt;/span&gt;（只用删一个也保证了正确性）。&lt;/p&gt;
&lt;p&gt;所以我们跑一个类 Flood-fill，一边搜一边找最小的 &lt;code&gt;-&lt;/code&gt;，还要统计 &lt;code&gt;-&lt;/code&gt; 和 &lt;code&gt;O&lt;/code&gt; 的总个数，还要计算 &lt;span class=&#34;math inline&#34;&gt;\(sum\)&lt;/span&gt;。然后就完了。&lt;/p&gt;
&lt;p&gt;虽然说这个 Flood-fill 没什么技术含量，但是我们要注意只能从 &lt;code&gt;-&lt;/code&gt; 出发只能通往 &lt;code&gt;O&lt;/code&gt; 而非另一个 &lt;code&gt;-&lt;/code&gt;，因为相邻的两个 &lt;code&gt;-&lt;/code&gt; 其实是不会互相交叉的相互影响的。&lt;/p&gt;
&lt;p&gt;Flood-fill 带来的总时间复杂度为 &lt;span class=&#34;math inline&#34;&gt;\(O(nm)\)&lt;/span&gt;。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;namespace XSC062 &amp;#123;
using namespace fastIO;
const int maxk = 1e6 + 5;
const int inf = 0x3f3f3f3f;
const int fx[] = &amp;#123; 0, 0, 1, -1 &amp;#125;;
const int fy[] = &amp;#123; 1, -1, 0, 0 &amp;#125;;
int n, m, k, x, y, res;
int mn, sum, cnt1, cnt2;
std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; a, b, c;
int min(int x, int y) &amp;#123; return x &amp;lt; y ? x : y; &amp;#125;
int max(int x, int y) &amp;#123; return x &amp;gt; y ? x : y; &amp;#125;
void DFS(int x, int y) &amp;#123;
    sum += a[x][y];
    if (b[x][y] == 1) ++cnt1;
    else ++cnt2, mn = min(mn, a[x][y]);
    c[x][y] = 1;
    for (int i = 0; i &amp;lt; 4; ++i) &amp;#123;
        int nx = x + fx[i],
            ny = y + fy[i];
        if (!nx || !ny || nx &amp;gt; n || ny &amp;gt; m)
            continue;
        if (c[nx][ny]) continue;
        if ((b[x][y] == 1 &amp;amp;&amp;amp; b[nx][ny] == 1)
         || (b[x][y] == 1 &amp;amp;&amp;amp; b[nx][ny] == 2)
          || (b[x][y] == 2 &amp;amp;&amp;amp; b[nx][ny] == 1))
            DFS(nx, ny);
    &amp;#125;
    return;
&amp;#125;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    freopen(&amp;quot;pawn.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    freopen(&amp;quot;pawn.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#endif
    read(n), read(m);
    a.push_back(std::vector&amp;lt;int&amp;gt;(m + 1));
    b.push_back(std::vector&amp;lt;int&amp;gt;(m + 1));
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        a.push_back(std::vector&amp;lt;int&amp;gt;(m + 1));
        b.push_back(std::vector&amp;lt;int&amp;gt;(m + 1));
        for (int j = 1; j &amp;lt;= m; ++j)
            read(a[i][j]);
    &amp;#125;
    c = b, read(k);
    for (int i = 1; i &amp;lt;= k; ++i) &amp;#123;
        read(x), read(y), ++x, ++y;
        b[x][y] = 1;
        if (x + 1 &amp;lt;= n &amp;amp;&amp;amp; !b[x + 1][y]) b[x + 1][y] = 2;
        if (y + 1 &amp;lt;= m &amp;amp;&amp;amp; !b[x][y + 1]) b[x][y + 1] = 2;
        if (x - 1 &amp;gt;= 1 &amp;amp;&amp;amp; !b[x - 1][y]) b[x - 1][y] = 2;
        if (y - 1 &amp;gt;= 1 &amp;amp;&amp;amp; !b[x][y - 1]) b[x][y - 1] = 2;
    &amp;#125;
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        for (int j = 1; j &amp;lt;= m; ++j) &amp;#123;
            if (b[i][j] &amp;amp;&amp;amp; !c[i][j]) &amp;#123;
                mn = inf;
                cnt1 = cnt2 = sum = 0;
                DFS(i, j);
                if (cnt2 == cnt1 * 3) res += sum;
                else if (cnt2 == cnt1 * 3 + 1) res += sum - mn;
                else &amp;#123; puts(&amp;quot;No&amp;quot;); return 0; &amp;#125;
            &amp;#125;
        &amp;#125;
    &amp;#125;
    print(res, &amp;#39;\n&amp;#39;);
    return 0;
&amp;#125;
&amp;#125; // namespace XSC062&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;c.-树图&#34;&gt;C. 树图&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;http://222.180.160.110:61235/contest/4424/problem/3&#34; class=&#34;uri&#34;&gt;http://222.180.160.110:61235/contest/4424/problem/3&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;DJ：你们去打一下动态树 DP 的板子就可以了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;此时无声胜有声。&lt;/p&gt;
&lt;p&gt;这里仅仅介绍一下 40pts 的做法。我们理所当然地想到 DP 一个点染成某种颜色所需的最小代价。&lt;/p&gt;
&lt;p&gt;这里说的染成某种颜色其实不太准确，应该是「代表着」哪种颜色。像 0 可以代表 1 也可以代表 2，1 就只能代表 1，2 也只能代表 2。&lt;/p&gt;
&lt;p&gt;令 &lt;span class=&#34;math inline&#34;&gt;\(f_{u,1}\)&lt;/span&gt; 表示以 &lt;span class=&#34;math inline&#34;&gt;\(u\)&lt;/span&gt; 为根的子树中不保留颜色 2 的最小代价（代表 1），&lt;span class=&#34;math inline&#34;&gt;\(f_{u, 2}\)&lt;/span&gt; 表示以 &lt;span class=&#34;math inline&#34;&gt;\(u\)&lt;/span&gt; 为根的子树中不保留颜色 1 的最小代价（代表 2）。&lt;/p&gt;
&lt;p&gt;那么对于颜色已经确定为 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt; 的点 &lt;span class=&#34;math inline&#34;&gt;\(u_1\)&lt;/span&gt;，&lt;span class=&#34;math inline&#34;&gt;\(f_{u_1,2}=\inf\)&lt;/span&gt;；对于颜色已经确定为 &lt;span class=&#34;math inline&#34;&gt;\(2\)&lt;/span&gt; 的点 &lt;span class=&#34;math inline&#34;&gt;\(u_2\)&lt;/span&gt;，&lt;span class=&#34;math inline&#34;&gt;\(f_{u_2,1}=\inf\)&lt;/span&gt;；颜色为 0 的 &lt;span class=&#34;math inline&#34;&gt;\(u_0\)&lt;/span&gt; 就不用管。&lt;/p&gt;
&lt;p&gt;然后如果 &lt;span class=&#34;math inline&#34;&gt;\(u_1\)&lt;/span&gt; 有一个 2 颜色的儿子 &lt;span class=&#34;math inline&#34;&gt;\(v_2\)&lt;/span&gt;，就要切断这条边；反之，如果这个儿子的颜色为 1，就不用切断。&lt;/p&gt;
&lt;p&gt;所以有：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
f_{u,c}=\sum_{v\in son_u} \min(f_{v,c},f_{v,3-c}+1)
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;那么就完了。每次询问的时候跑一个完整的树 DP，或者我们也可以发现只用更新 &lt;span class=&#34;math inline&#34;&gt;\(u\)&lt;/span&gt; 到目标点这一条链上的 DP 值，然后就可以根据这个做一个并不会实际改进复杂度的优化。&lt;/p&gt;
&lt;p&gt;总体时间复杂度 &lt;span class=&#34;math inline&#34;&gt;\(O(nq)\)&lt;/span&gt;。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;namespace XSC062 &amp;#123;
using namespace fastIO;
const int maxn = 1e5 + 5;
const int inf = 0x3f3f3f3f;
int col[maxn];
int f[maxn][3];
int n, x, y, q;
std::vector&amp;lt;int&amp;gt; g[maxn];
int min(int x, int y) &amp;#123;
    return x &amp;lt; y ? x : y;
&amp;#125;
void DFS(int x, int fa, int to) &amp;#123;
    f[x][1] = f[x][2] = 0;
    if (col[x] == 1) f[x][2] = inf;
    else if (col[x] == 2) f[x][1] = inf;
    for (auto i : g[x]) &amp;#123;
        if (i == fa) continue;
        if (x != to) DFS(i, x, to);
        f[x][1] += min(f[i][1], f[i][2] + 1);
        f[x][2] += min(f[i][2], f[i][1] + 1);
    &amp;#125;
    return;
&amp;#125;
void add(int x, int y) &amp;#123;
    g[x].push_back(y);
    return;
&amp;#125;
int main() &amp;#123;
#ifdef ONLINE_JUDGE 
    freopen(&amp;quot;diagrams.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    freopen(&amp;quot;diagrams.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#endif
    read(n);
    for (int i = 1; i &amp;lt; n; ++i) &amp;#123;
        read(x), read(y);
        add(x, y), add(y, x);
    &amp;#125;
    read(q);
    while (q--) &amp;#123;
        read(x), read(y);
        col[y] = (x &amp;lt;= 2) ? x : 0;
        DFS(1, -1, y);
        print(min(f[1][1], f[1][2]), &amp;#39;\n&amp;#39;);
    &amp;#125;
    return 0;
&amp;#125;
&amp;#125; // namespace XSC062&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;e.-字符串-string&#34;&gt;E. 字符串 string&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;http://222.180.160.110:61235/contest/4423/problem/5&#34; class=&#34;uri&#34;&gt;http://222.180.160.110:61235/contest/4423/problem/5&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;原题：&lt;a href=&#34;https://codeforces.com/problemset/problem/756/D&#34;&gt;CF756D - Bacterial Melee&lt;/a&gt;。&lt;/p&gt;
&lt;details&gt;
&lt;p&gt;&lt;summary&gt;怪话&lt;/summary&gt;&lt;/p&gt;
&lt;p&gt;兔子：我谴责你。&lt;/p&gt;
&lt;p&gt;我：？&lt;/p&gt;
&lt;p&gt;兔子：为什么你的 last 要缩写成 &lt;code&gt;la&lt;/code&gt;。我没看你题解直接看的代码看了半天没看懂。&lt;/p&gt;
&lt;p&gt;我：不缩写成 &lt;code&gt;la&lt;/code&gt; 难道要写成 &lt;code&gt;lst&lt;/code&gt; 吗？&lt;/p&gt;
&lt;p&gt;兔子：不然呢？&lt;/p&gt;
&lt;p&gt;好吧，大家都是异教徒。&lt;/p&gt;
&lt;/details&gt;
&lt;p&gt;可以很简单的想到，最终字符串一定由原串中的部分字符，按照其在原串中的顺序，经过若干次重复得到。那么我们把一段连续的相同字符视为一个字符，得到的这个串就是原串的一个子序列。&lt;/p&gt;
&lt;p&gt;所以我们只需要求出原串的不同子序列个数，再经过一定的排列组合就可以求出方案数。&lt;/p&gt;
&lt;p&gt;比如，我们知道一个长度为 &lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt; 的串中有 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 个长度为 &lt;span class=&#34;math inline&#34;&gt;\(m\)&lt;/span&gt; 的子序列，那么由插板法可得这 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 个子序列会贡献 &lt;span class=&#34;math inline&#34;&gt;\(C_{n-1}^{m-1}\times k\)&lt;/span&gt; 的方案数。&lt;/p&gt;
&lt;p&gt;那么不同子序列个数怎么求呢？显而易见需要 DP，规定 &lt;span class=&#34;math inline&#34;&gt;\(f_{i,j}\)&lt;/span&gt; 表示一个长度为 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 的子序列最后一位为 &lt;span class=&#34;math inline&#34;&gt;\(s_j\)&lt;/span&gt; 的方案数，就可以直接 &lt;span class=&#34;math inline&#34;&gt;\(f_{i,j}=\sum f_{i-1,k}\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;但这样做有一个问题，就是会重复计算。假如原串中在 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 位置有一个 &lt;code&gt;&#39;o&#39;&lt;/code&gt;，&lt;span class=&#34;math inline&#34;&gt;\(i+1\)&lt;/span&gt; 位置又有一个 &lt;code&gt;&#39;o&#39;&lt;/code&gt;，两个都可以从前面某个位置（假设为 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt;；假设 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; 上其中一个被计入方案数的合法子序列为 &lt;code&gt;&#34;hyac&#34;&lt;/code&gt;），那么转移到 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 时，计算了 &lt;code&gt;&#34;hyaco&#34;&lt;/code&gt;，到了 &lt;span class=&#34;math inline&#34;&gt;\(i+1\)&lt;/span&gt;，依然可以从 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; 处得到 &lt;code&gt;&#34;hyaco&#34;&lt;/code&gt;，就会重复计算。&lt;/p&gt;
&lt;p&gt;那么怎么避免这一点呢？对于一个位置 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt;，假设其上一个相同字母的位置为 &lt;span class=&#34;math inline&#34;&gt;\(last_i\)&lt;/span&gt;，我们规定其仅可从 &lt;span class=&#34;math inline&#34;&gt;\((last_i,i)\)&lt;/span&gt; 进行转移即可（注意两边都是开区间）。&lt;/p&gt;
&lt;p&gt;初始化是对于每一个没有前驱的 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt;，&lt;span class=&#34;math inline&#34;&gt;\(f_{1,i}=1\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;实现上，因为 &lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt; 的大小是 &lt;span class=&#34;math inline&#34;&gt;\(5\times 10^3\)&lt;/span&gt;，转移区间又是连续的，我们用一个前缀和进行优化即可。&lt;/p&gt;
&lt;p&gt;时间复杂度 &lt;span class=&#34;math inline&#34;&gt;\(O(n^2)\)&lt;/span&gt;，应该比官方题解讲的方法具象一些。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#define int long long
namespace XSC062 &amp;#123;
using namespace fastIO;
const int mod = 1e9 + 7;
const int maxn = 5e3 + 5;
int n, res;
char s[maxn];
int fac[maxn];
int la[maxn], p[maxn];
int f[maxn][maxn], u[maxn][maxn];
int max(int x, int y) &amp;#123; return x &amp;gt; y ? x : y; &amp;#125;
int qkp(int x, int y) &amp;#123;
    int res = 1;
    while (y) &amp;#123;
        if (y &amp;amp; 1) (res *= x) %= mod;
        (x *= x) %= mod, y &amp;gt;&amp;gt;= 1;
    &amp;#125;
    return res;
&amp;#125;
int inv(int x) &amp;#123; return qkp(x, mod - 2); &amp;#125;
int A(int n, int m) &amp;#123;
    return fac[n] * inv(fac[n - m]) % mod;
&amp;#125;
int C(int n, int m) &amp;#123;
    return A(n, m) * inv(fac[m]) % mod;
&amp;#125;
int main() &amp;#123;
    scanf(&amp;quot;%lld %s&amp;quot;, &amp;amp;n, s + 1);
    fac[0] = 1;
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        la[i] = p[s[i] - &amp;#39;a&amp;#39; + 1];
        if (!la[i]) f[1][i] = 1, ++res;
        u[1][i] = u[1][i - 1] + f[1][i];
        p[s[i] - &amp;#39;a&amp;#39; + 1] = i;
        fac[i] = (fac[i - 1] * i) % mod;
    &amp;#125;
    for (int i = 2; i &amp;lt;= n; ++i) &amp;#123;
        int sum = 0;
        for (int j = i; j &amp;lt;= n; ++j) &amp;#123;
            int k = max(i - 1, la[j] + 1);
            if (k &amp;lt;= j - 1)
                f[i][j] = (u[i - 1][j - 1] - u[i - 1][k - 1]) % mod;
            u[i][j] = (u[i][j - 1] + f[i][j]) % mod;
            (sum += f[i][j]) %= mod;
        &amp;#125;
        res += C(n - 1, i - 1) * sum % mod;
        res %= mod;
    &amp;#125;
    res = (res + mod) % mod;
    print(res, &amp;#39;\n&amp;#39;);
    return 0;
&amp;#125;
&amp;#125; // namespace XSC062
#undef int&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;abc328f---good-set-query&#34;&gt;ABC328F - Good Set Query&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/abc328/tasks/abc328_f&#34; class=&#34;uri&#34;&gt;https://atcoder.jp/contests/abc328/tasks/abc328_f&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;一个加权并查集。&lt;/p&gt;
&lt;p&gt;我们用并查集维护关系，在合并两个集合的时候给被合并者的原本根打一个懒标记，意为该并查集需要整体更新的 delta。&lt;/p&gt;
&lt;p&gt;在每次 &lt;code&gt;find&lt;/code&gt; 时，路径上的点均从 &lt;strong&gt;直系父亲&lt;/strong&gt; 处继承懒标记。然后因为有了路径压缩，所以每个点在查询时均能得到不重复的懒标记（因为自己的祖先已经被直系父亲继承过了）。&lt;/p&gt;
&lt;p&gt;同样也是因为弱势一方才被打标记，保证了根节点上不会有标记，路径压缩后就将父亲更新为根，保证不会因为多次 &lt;code&gt;find&lt;/code&gt; 导致标记重复计算。&lt;/p&gt;
&lt;p&gt;每次尝试合并的时候，因为首先需要进行 &lt;code&gt;find&lt;/code&gt;，保证 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 和 &lt;span class=&#34;math inline&#34;&gt;\(y\)&lt;/span&gt; 均是最新状态。若 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 和 &lt;span class=&#34;math inline&#34;&gt;\(y\)&lt;/span&gt; 已经在同一个集合了，直接判断两个差值是否为 &lt;span class=&#34;math inline&#34;&gt;\(d\)&lt;/span&gt;；否则，合并两个集合并给弱势方打上标记。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#define int long long
namespace XSC062 &amp;#123;
using namespace fastIO;
const int maxn = 2e5 + 5;
int n, q, x, y, d;
int f[maxn], u[maxn];
int find(int x) &amp;#123;
    if (f[x] == x) return x;
    int fa = find(f[x]);
    u[x] += u[f[x]];
    return f[x] = fa;
&amp;#125;
bool merge(int x, int y, int d) &amp;#123;
    int fx = find(x), fy = find(y);
    if (fx == fy) return u[x] - u[y] == d;
    f[fx] = fy, u[fx] = d - (u[x] - u[y]);
    return 1;
&amp;#125;
int main() &amp;#123;
    read(n), read(q);
    for (int i = 1; i &amp;lt;= n; ++i)
        f[i] = i;
    for (int i = 1; i &amp;lt;= q; ++i) &amp;#123;
        read(x), read(y), read(d);
        if (merge(x, y, d)) print(i, &amp;#39; &amp;#39;);
    &amp;#125;
    putchar(&amp;#39;\n&amp;#39;);
    return 0;
&amp;#125;
&amp;#125; // namespace XSC062
#undef int&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;cf1701f---points&#34;&gt;CF1701F - Points&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;http://codeforces.com/problemset/problem/1701/F&#34; class=&#34;uri&#34;&gt;http://codeforces.com/problemset/problem/1701/F&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我们先考虑对于一个单点 &lt;span class=&#34;math inline&#34;&gt;\(p\)&lt;/span&gt;，假设 &lt;span class=&#34;math inline&#34;&gt;\([p-d, p)\)&lt;/span&gt; 中共有 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 个点，那么答案就是 &lt;span class=&#34;math inline&#34;&gt;\(C_k^2=\dfrac {k(k-1)}2\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;假如范围内新加入了一个点，&lt;span class=&#34;math inline&#34;&gt;\(k\gets k+1\)&lt;/span&gt;，那么答案就是 &lt;span class=&#34;math inline&#34;&gt;\(C_{k+1}^2=\dfrac {k(k+1)}{2}\)&lt;/span&gt;，较原来增加了 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt;。相应地，若范围内减少了一个点，&lt;span class=&#34;math inline&#34;&gt;\(k\gets k-1\)&lt;/span&gt;，答案较原来就会减少 &lt;span class=&#34;math inline&#34;&gt;\(k-1\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;当我们加入一个点 &lt;span class=&#34;math inline&#34;&gt;\(p\)&lt;/span&gt;，区间 &lt;span class=&#34;math inline&#34;&gt;\((p,p+d]\)&lt;/span&gt; 都会收到影响。假设该区间内原本的每个点之 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 的和是 &lt;span class=&#34;math inline&#34;&gt;\(s_k\)&lt;/span&gt;，那么总体的答案就会减少 &lt;span class=&#34;math inline&#34;&gt;\(s_k\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;那么 &lt;span class=&#34;math inline&#34;&gt;\(s_k\)&lt;/span&gt; 怎么去维护呢？插入点 &lt;span class=&#34;math inline&#34;&gt;\(p\)&lt;/span&gt; 时，答案先加上当前 &lt;span class=&#34;math inline&#34;&gt;\(s_k\)&lt;/span&gt; 和新点的 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt;，再将 &lt;span class=&#34;math inline&#34;&gt;\((p, p+d]\)&lt;/span&gt; 内的 &lt;span class=&#34;math inline&#34;&gt;\(s_k\)&lt;/span&gt; 全部 +1；删除点 &lt;span class=&#34;math inline&#34;&gt;\(p\)&lt;/span&gt; 时，答案减去 &lt;span class=&#34;math inline&#34;&gt;\(s_k-c\)&lt;/span&gt; 和待删点的答案（其中 &lt;span class=&#34;math inline&#34;&gt;\(c\)&lt;/span&gt; 是 &lt;span class=&#34;math inline&#34;&gt;\((p,p+d]\)&lt;/span&gt; 中的点数），再将 &lt;span class=&#34;math inline&#34;&gt;\((p, p+d]\)&lt;/span&gt; 内的 &lt;span class=&#34;math inline&#34;&gt;\(s_k\)&lt;/span&gt; 全部 -1。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#define int long long
namespace XSC062 &amp;#123;
using namespace fastIO;
const int lim = 2e5;
const int maxn = 2e5 + 5;
#define lt (p &amp;lt;&amp;lt; 1)
#define rt (lt | 1)
struct _ &amp;#123; int u, p, d, l, r; &amp;#125;;
_ t[maxn &amp;lt;&amp;lt; 2];
int q, d, x, res;
int min(int x, int y) &amp;#123; return x &amp;lt; y ? x : y; &amp;#125;
int max(int x, int y) &amp;#123; return x &amp;gt; y ? x : y; &amp;#125;
void pushdown(int p) &amp;#123;
    if (t[p].d) &amp;#123;
        t[lt].u += t[lt].p * t[p].d;
        t[rt].u += t[rt].p * t[p].d;
        t[lt].d += t[p].d;
        t[rt].d += t[p].d;
        t[p].d = 0;
    &amp;#125;
    return;
&amp;#125;
void bld(int p, int l, int r) &amp;#123;
    t[p].l = l, t[p].r = r;
    if (l == r) return;
    int mid = (l + r) &amp;gt;&amp;gt; 1;
    bld(lt, l, mid), bld(rt, mid + 1, r);
    return;
&amp;#125;
int ask(int p, int l, int r) &amp;#123;
    if (l &amp;lt;= t[p].l &amp;amp;&amp;amp; t[p].r &amp;lt;= r)
        return t[p].p;
    int res = 0, mid = (t[p].l + t[p].r) &amp;gt;&amp;gt; 1;
    if (l &amp;lt;= mid) res = ask(lt, l, r);
    if (r &amp;gt; mid) res += ask(rt, l, r);
    return res;
&amp;#125;
int qry(int p, int l, int r) &amp;#123;
    if (l &amp;lt;= t[p].l &amp;amp;&amp;amp; t[p].r &amp;lt;= r)
        return t[p].u;
    int res = 0, mid = (t[p].l + t[p].r) &amp;gt;&amp;gt; 1;
    pushdown(p);
    if (l &amp;lt;= mid) res = qry(lt, l, r);
    if (r &amp;gt; mid) res += qry(rt, l, r);
    return res;
&amp;#125;
void upd(int p, int l, int r, int x) &amp;#123;
    if (l &amp;lt;= t[p].l &amp;amp;&amp;amp; t[p].r &amp;lt;= r) &amp;#123;
        t[p].d += x;
        t[p].u += t[p].p * x;
        return;
    &amp;#125;
    int mid = (t[p].l + t[p].r) &amp;gt;&amp;gt; 1;
    pushdown(p);
    if (l &amp;lt;= mid) upd(lt, l, r, x);
    if (r &amp;gt; mid) upd(rt, l, r, x);
    t[p].u = t[lt].u + t[rt].u;
    return;
&amp;#125;
void clr(int p, int x) &amp;#123;
    --t[p].p;
    if (t[p].l == t[p].r) &amp;#123;
        res -= t[p].u * (t[p].u - 1) / 2;
        t[p].u = t[p].d = t[p].p = 0;
        return;
    &amp;#125;
    int mid = (t[p].l + t[p].r) &amp;gt;&amp;gt; 1;
    pushdown(p);
    if (x &amp;lt;= mid) clr(lt, x);
    else clr(rt, x);
    t[p].u = t[lt].u + t[rt].u;
    return;
&amp;#125;
void add(int p, int x, int v) &amp;#123;
    ++t[p].p;
    if (t[p].l == t[p].r) &amp;#123;
        res += v * (v - 1) / 2;
        t[p].u = v, t[p].p = 1;
        return;
    &amp;#125;
    int mid = (t[p].l + t[p].r) &amp;gt;&amp;gt; 1;
    pushdown(p);
    if (x &amp;lt;= mid) add(lt, x, v);
    else add(rt, x, v);
    t[p].u = t[lt].u + t[rt].u;
    return;
&amp;#125;
void upd(int l, int r, int x) &amp;#123;
    upd(1, min(l, lim), min(r, lim), x);
    return;
&amp;#125;
int qry(int l, int r) &amp;#123;
    return qry(1, min(l, lim), min(r, lim));
&amp;#125;
int ask(int l, int r) &amp;#123;
    return ask(1, max(1, min(l, lim)), max(1, min(r, lim)));
&amp;#125;
int main() &amp;#123;
    read(q), read(d);
    bld(1, 1, lim);
    while (q--) &amp;#123;
        read(x);
        if (ask(x, x)) &amp;#123;
            int u = qry(x + 1, x + d) - ask(x + 1, x + d);
            res -= u, upd(x + 1, x + d, -1), clr(1, x);
        &amp;#125;
        else &amp;#123;
            int u = qry(x + 1, x + d);
            res += u, upd(x + 1, x + d, 1);
            add(1, x, ask(x - d, x - 1));
        &amp;#125;
        print(res, &amp;#39;\n&amp;#39;);
    &amp;#125;
    return 0;
&amp;#125;
&amp;#125; // namespace XSC062
#undef int&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
 ]]></description>
        </item>
    </channel>
</rss>
