{
    "version": "https://jsonfeed.org/version/1",
    "title": "null â€¢ All posts by \"è™šæ ‘\" tag",
    "description": "",
    "home_page_url": "https://xsc062.netlify.app",
    "items": [
        {
            "id": "https://xsc062.netlify.app/20250816/",
            "url": "https://xsc062.netlify.app/20250816/",
            "title": "è¿‘æœŸæ‚é¢˜ II",
            "date_published": "2025-08-16T08:14:12.000Z",
            "content_html": "<p>å’Œ Aug 9th çš„æ‚é¢˜ä¸å¤ªèƒ½åˆå¹¶ï¼Œæ‰€ä»¥åˆ†å¼€äº†</p>\n<span id=\"more\"></span>\n<hr />\n<h2 id=\"b.-gas-fire-extinguishers\">B. GAS-Fire Extinguishers</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P3479\" class=\"uri\">https://www.luogu.com.cn/problem/P3479</a></p>\n<p>æ˜¾ç„¶å¯ä»¥è´ªå¿ƒï¼Œä¸å¦¨ä»ä¸‹åˆ°ä¸Šï¼Œè®°å½•å½“å‰éå†è¿‡çš„ã€ç©ºä½™å‡ºæ¥çš„ç­ç«å™¨ï¼ˆå…¶å®ç®—çš„æ˜¯å¯ä»¥ä¾›ç»™çš„æˆ¿é—´æ•°ï¼‰å’Œè¿˜æœªåˆ†é…ç­ç«å™¨çš„æˆ¿é—´ï¼ŒæŒ‰è·ç¦»ä¸º <span class=\"math inline\">\\(0\\sim k\\)</span> åˆ†ç»„ã€‚</p>\n<p>ä¸éš¾å‘ç°å¦‚æœåœ¨æŸä¸ªç‚¹ <span class=\"math inline\">\\(u\\)</span> å¤„å­˜åœ¨è·ç¦»ä¸º <span class=\"math inline\">\\(k\\)</span> çš„ç©ºé—²ç­ç«å™¨ï¼Œå¯ä»¥è´ªå¿ƒåœ°åˆ†é…ç»™ <span class=\"math inline\">\\(u\\)</span>ï¼›å¦‚æœå­˜åœ¨è·ç¦»ä¸º <span class=\"math inline\">\\(k\\)</span> çš„æœªåˆ†é…æˆ¿é—´ï¼Œä¹Ÿå¯ä»¥åœ¨ <span class=\"math inline\">\\(u\\)</span> å¤„æ”¾ç½®ç­ç«å™¨å¹¶åˆ†é…ç»™è¿™äº›æˆ¿é—´ã€‚ç±»ä¼¼åœ°ï¼Œè¿›è¡Œä¸¤ä¸¤é…å¯¹ä¸€å®šæ˜¯ä¸åŠ£çš„ã€‚</p>\n<p>å‘ç°åŒå­æ ‘å†…è·ç¦»ä¸º <span class=\"math inline\">\\(k-1\\)</span> çš„ç‚¹å¯¹ç•™åˆ° <span class=\"math inline\">\\(fa\\)</span> å†åŒ¹é…æ˜¯ä¸è¡Œçš„ï¼Œå› ä¸ºè¿™æ—¶è·ç¦»ä¼šå˜æˆ <span class=\"math inline\">\\(k+1\\)</span>ï¼Œä¸èƒ½åŒ¹é…ä¸Šï¼›å¯ä»¥æ„Ÿå—åˆ°è¿™æ ·æ˜¯æ›´åŠ£çš„ã€‚</p>\n<p>ç„¶åå°±å¯ä»¥åšäº†ï¼Œæ ¹èŠ‚ç‚¹ç‰¹æ®Šä¹±è´ªå¿ƒä¸€ä¸‹å°±è¡Œäº†ã€‚è®°å¾—å¼€ long longã€‚</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\n#define int long long\nsigned main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, s, k, res = 0;\n    std::cin &gt;&gt; n &gt;&gt; s &gt;&gt; k;\n    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1), p(n + 1, std::vector&lt;int&gt; (k + 1)), q(n + 1, std::vector&lt;int&gt; (k + 1));\n    for (int i = 1, x, y; i &lt; n; ++i) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y;\n        g[x].push_back(y), g[y].push_back(x);\n    &#125;\n    std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int fa) &#123;\n        for (auto i : g[x])\n            if (i != fa)  &#123;\n                DFS(i, x);\n                for (int j = 0; j &lt; k; ++j)\n                    p[x][j + 1] += p[i][j], q[x][j + 1] += q[i][j];\n            &#125;\n        ++q[x][0];\n        if (x != 1) &#123;\n            int v = (q[x][k] + s - 1) / s;\n            p[x][0] = v * s, res += v;\n            for (int i = 0; i &lt;= k; ++i) &#123;\n                int v = std::min(p[x][i], q[x][k - i]);\n                p[x][i] -= v, q[x][k - i] -= v;\n            &#125;\n            for (int i = 0; i &lt; k; ++i) &#123;\n                int v = std::min(p[x][i], q[x][k - 1 - i]);\n                p[x][i] -= v, q[x][k - 1 - i] -= v;\n            &#125;\n        &#125;\n        else &#123;\n            // std::cerr &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n            int sum = 0ll, r = 0;\n            for (int i = k; ~i; --i) &#123;\n                sum += p[x][k - i];\n                // std::cerr &lt;&lt; sum &lt;&lt; &#39;\\n&#39;;\n                int v = std::min(sum, q[x][i]);\n                sum -= v, q[x][i] -= v;\n                r += q[x][i];\n            &#125;\n            res += (r + s - 1) / s;\n        &#125;\n        return;\n    &#125;;\n    DFS(1, -1);\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"c.-æ‰«åœ°æœºå™¨äºº\">C. æ‰«åœ°æœºå™¨äºº</h2>\n<p><a href=\"http://222.180.160.110:61235/contest/6502/problem/3\" class=\"uri\">http://222.180.160.110:61235/contest/6502/problem/3</a></p>\n<blockquote>\n<p>é¢˜æ„ï¼šç»™å®š <span class=\"math inline\">\\(n\\)</span> å †è´§ç‰©ï¼Œæ¯å †è´§ç‰©æœ‰é‡é‡ <span class=\"math inline\">\\(v_i\\)</span> å’Œä¸€ä¸ªå‚æ•° <span class=\"math inline\">\\(a_i\\)</span>ã€‚æœ‰ä¸€ä¸ªåˆå§‹è´Ÿè½½ä¸º <span class=\"math inline\">\\(0\\)</span>ã€è´Ÿè½½ä¸Šé™ä¸º <span class=\"math inline\">\\(c\\)</span> çš„æœºå™¨äººï¼Œä» <span class=\"math inline\">\\(1\\)</span> åˆ° <span class=\"math inline\">\\(n\\)</span> éå†è¿™äº›è´§ç‰©ï¼Œå¯¹æ¯ä¸€å¤„è´§ç‰©æ‰§è¡Œä»¥ä¸‹æ“ä½œï¼Œç›´åˆ°æ¸…ç©ºè¿™å †è´§ç‰©ï¼š</p>\n<ul>\n<li>å½“å‰è´Ÿè½½æœªæ»¡ï¼šå¯ä»¥é€‰æ‹©è¿›è¡Œè£…è½½ç›´åˆ°è¾¾åˆ°è´Ÿè½½ä¸Šé™ï¼Œæˆ–è´§ç‰©æ¸…ç©ºã€‚èŠ±è´¹ <span class=\"math inline\">\\(a_i\\)</span> çš„ä»£ä»·ã€‚</li>\n<li>ä¸ç®¡å½“å‰è´Ÿè½½æ»¡æ²¡æ»¡ï¼šå¯ä»¥é€‰æ‹©æ¸…ç©ºå½“å‰è´Ÿè½½ï¼ŒèŠ±è´¹ <span class=\"math inline\">\\(b\\)</span> çš„ä»£ä»·ã€‚</li>\n</ul>\n<p>æ¯ä¸€å¤„å¯ä»¥ä»»æ„æ“ä½œï¼Œè¦æ±‚éå†å®Œä¹‹åæœºå™¨äººè´Ÿè½½ä¸º <span class=\"math inline\">\\(0\\)</span>ï¼Œé—®æœ€å°ä»£ä»·ã€‚<span class=\"math inline\">\\(n\\le 2\\times 10^5,c\\le 10^9\\)</span>ã€‚</p>\n</blockquote>\n<p><em>é¢˜é¢æ˜¯é‡æ„è¿‡çš„ï¼ŒåŸæ¥çš„é¢˜é¢å¤ªæœ‰æ­§ä¹‰äº†ã€‚ç»å¤§å¤šæ•°äººæ²¡åšå‡ºæ¥å°±æ˜¯å› ä¸ºæ²¡çœ‹æ‡‚é¢˜å§ï¼</em></p>\n<p>è€ƒè™‘æš´åŠ›ï¼Œå¯ä»¥æƒ³åˆ°ä»¤ <span class=\"math inline\">\\(f_{i,j}\\)</span> è¡¨ç¤ºå¤„ç†å®Œ <span class=\"math inline\">\\(i\\)</span> è¿‡åè´Ÿè½½ä¸º <span class=\"math inline\">\\(j\\)</span> çš„æœ€å°ä»£ä»·ï¼ˆæ˜¾ç„¶ <span class=\"math inline\">\\(f_{i,c}\\)</span> å’Œ <span class=\"math inline\">\\(f_{i,0}\\)</span> æ˜¯ç­‰æ•ˆçš„ï¼Œæ•…èˆå¼ƒå‰è€…ï¼‰ã€‚è®° <span class=\"math inline\">\\(k=\\left\\lceil\\dfrac {v_i}c\\right\\rceil,w=(v_i\\bmod c - 1)\\bmod c+1\\)</span>ï¼Œé‚£ä¹ˆæœ‰ï¼š</p>\n<p><span class=\"math display\">\\[\nf_{i,(j+v_i)\\bmod c}\\gets f_{i-1,j}+k\\cdot a_i+(k-1)\\cdot b +\n\\begin{cases}\nb&amp;j+w=c\\\\\na_i+b&amp;j+w&gt; c\\\\\n0&amp;\\text{otherwise}\n\\end{cases}\\\\\nf_{i,0}\\gets f_{i,j}+b\n\\]</span></p>\n<p>å‘ç° <span class=\"math inline\">\\(f_{i-1}\\)</span> å’Œ <span class=\"math inline\">\\(f_i\\)</span> ä¹‹é—´æ˜¯å­˜åœ¨å¯¹åº”å…³ç³»çš„ï¼Œæ‰€ä»¥è€ƒè™‘ç›´æ¥ç»§æ‰¿ï¼ˆçœŸå®çš„ <span class=\"math inline\">\\(0\\)</span> åº”è¯¥ä½äº <span class=\"math inline\">\\(-s_i\\)</span> çš„ä½ç½®ï¼‰ï¼Œå†åšå…¨å±€åŠ ã€åŒºé—´åŠ ï¼Œ<span class=\"math inline\">\\(f_{i,0}\\)</span> çš„è½¬ç§»æ˜¯å…¨å±€ minï¼Œçº¿æ®µæ ‘ç»´æŠ¤å³å¯ï¼›æ¯æ¬¡åªä¼šæ–°å¢ä¸€ä¸ªçŠ¶æ€ï¼ŒåŠ¨æ€å¼€ç‚¹å³å¯ã€‚</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 5e6 + 5;\nconst __int128 inf = 1e18;\nstruct &#123;\n    int l, r;\n    __int128 u, d;\n&#125; t[maxn];\n#define lt t[p].l\n#define rt t[p].r\nint tot;\nvoid pushdown(int p) &#123;\n    if (t[p].d) &#123;\n        t[lt].d += t[p].d, t[lt].u += t[p].d;\n        t[rt].d += t[p].d, t[rt].u += t[p].d;\n        t[p].d = 0ll;\n    &#125;\n    return;\n&#125;\nvoid upd(int &amp;p, int l, int r, int x, __int128 v) &#123;\n    if (!p)\n        p = ++tot, t[p].u = v;\n    else\n        t[p].u = std::min(t[p].u, v);\n    if (l == r)\n        return;\n    pushdown(p);\n    int mid = (l + r) &gt;&gt; 1;\n    if (x &lt;= mid)\n        upd(lt, l, mid, x, v);\n    else\n        upd(rt, mid + 1, r, x, v);\n    return;\n&#125;\nvoid add(int p, int l, int r, int ql, int qr, __int128 v) &#123;\n    if (!p)\n        return;\n    if (ql &lt;= l &amp;&amp; r &lt;= qr) &#123;\n        t[p].d += v, t[p].u += v;\n        return;\n    &#125;\n    int mid = (l + r) &gt;&gt; 1;\n    pushdown(p);\n    if (ql &lt;= mid)\n        add(lt, l, mid, ql, qr, v);\n    if (qr &gt; mid)\n        add(rt, mid + 1, r, ql, qr, v);\n    t[p].u = std::min(t[lt].u, t[rt].u);\n    return;\n&#125;\n__int128 ask(int p, int l, int r, int x) &#123;\n    if (l == r)\n        return t[p].u;\n    int mid = (l + r) &gt;&gt; 1;\n    pushdown(p);\n    if (x &lt;= mid)\n        return ask(lt, l, mid, x);\n    return ask(rt, mid + 1, r, x);\n&#125;\n#undef lt\n#undef rt\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n    std::freopen(&quot;robot.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;robot.out&quot;, &quot;w&quot;, stdout);\n#else\n    std::freopen(&quot;ex_robot4.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    t[0].u = inf;\n    int n, b, c, p0 = 0, rt = 0;\n    std::cin &gt;&gt; n &gt;&gt; c &gt;&gt; b;\n    std::vector&lt;int&gt; a(n + 1), v(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i];\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; v[i];\n    upd(rt, 0, c - 1, 0, 0ll);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        __int128 k = (v[i] + c - 1) / c, w = (v[i] % c == 0 ? c : v[i] % c);\n        t[rt].d += k * a[i] + (k - 1) * b;\n        t[rt].u += k * a[i] + (k - 1) * b;\n        if (w &lt;= c)\n            add(rt, 0, c - 1, (c - w + p0) % c, (c - w + p0) % c, b);\n        if (w != 1) &#123;\n            int l = (c - w + p0 + 1) % c, r = (p0 + c - 1) % c;\n            if (l &lt;= r)\n                add(rt, 0, c - 1, l, r, a[i] + b);\n            else &#123;\n                add(rt, 0, c - 1, 0, r, a[i] + b);\n                add(rt, 0, c - 1, l, c - 1, a[i] + b);\n            &#125;\n        &#125;\n        p0 = (p0 + c - v[i] % c) % c;\n        upd(rt, 0, c - 1, p0, t[rt].u + b);\n    &#125;\n    std::cout &lt;&lt; (long long)ask(rt, 0, c - 1, p0) &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"d.-å¥—å¨ƒ\">D. å¥—å¨ƒ</h2>\n<p><a href=\"http://222.180.160.110:61235/contest/6502/problem/4\" class=\"uri\">http://222.180.160.110:61235/contest/6502/problem/4</a></p>\n<blockquote>\n<p>é¢˜æ„ï¼šç»™å®šåˆå§‹ä¸ºå…¨ <span class=\"math inline\">\\(0\\)</span> çš„æ•°ç»„ <span class=\"math inline\">\\(a_{1\\sim n + 1}\\)</span> å’Œ <span class=\"math inline\">\\(n\\)</span> æ¬¡å•ç‚¹ +1 æ“ä½œï¼Œæ¯æ¬¡æ“ä½œåï¼Œæ±‚è§£ï¼š</p>\n<p>ä»¤ <span class=\"math inline\">\\(a\\)</span> çš„å‰ç¼€å’Œæ•°ç»„ä¸º <span class=\"math inline\">\\(s\\)</span>ï¼Œæ‰¾åˆ°ä¸€ä¸ªæœ€å°çš„ <span class=\"math inline\">\\(k\\)</span>ï¼Œä½¿å¾—å¯¹äºæ¯ä¸ª <span class=\"math inline\">\\(i\\)</span>ï¼Œå‡æœ‰ <span class=\"math inline\">\\(k\\cdot i\\ge s_i\\)</span> æˆç«‹ã€‚</p>\n<p><span class=\"math inline\">\\(n\\le 10^6\\)</span>ï¼Œæ—¶é™ 0.5sã€‚</p>\n</blockquote>\n<details>\n<p><summary>è¶£äº‹ä¸€åˆ™</summary></p>\n<p>è€ƒåœºä¸Šæœ€å 10min æ‹¿åˆ°é¢˜ï¼Œæ†‹äº†ä¸€ä¸ªèƒ½æ‹¿åˆ° 96pts çš„å‡åšæ³•ï¼šæ³¨æ„åˆ°å‰ç¼€å’Œæ˜¯å•å¢çš„ï¼Œéœ€è¦ç»´æŠ¤æœ€å¤§çš„ <span class=\"math inline\">\\(\\dfrac {s_i}i\\)</span>ï¼Œç”±äºåç¼€ +1 å¸¦æ¥çš„å½±å“å¾ˆå°ï¼Œæ‰€ä»¥å¯ä»¥çŒœæµ‹åœ¨å¤§å¤šæ•°æƒ…å†µä¸‹æœ€å¤§çš„ <span class=\"math inline\">\\(i\\)</span> åªä¼šåœ¨åŸæ¥çš„å’Œä¿®æ”¹çš„ç‚¹ä¹‹é—´å˜åŒ–ã€‚åªç”¨ 10 è¡Œçš„æ ¸å¿ƒä»£ç å°±èƒ½æ‹¿åˆ°å¾ˆå¤šåˆ†ã€‚ä½†æ˜¯å±…ç„¶æœ‰è¿™ä¹ˆå¤šï¼Œå¯èƒ½å‡ºé¢˜äººéƒ½æ²¡æœ‰æƒ³åˆ°çœŸæœ‰äººæ•¢äº¤è¿™ç§åšæ³•å§ã€‚</p>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n    std::freopen(&quot;doll.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;doll.out&quot;, &quot;w&quot;, stdout);\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n    auto stime = std::chrono::steady_clock::now();\n    int n, res = 0;\n    std::cin &gt;&gt; n;\n    std::vector&lt;int&gt; bit(n + 2);\n    auto lowbit = [](int x) &#123;\n        return x &amp; -x;\n    &#125;;\n    auto add = [&amp;](int x) &#123;\n        for (; x &lt;= n + 1; x += lowbit(x))\n            ++bit[x];\n        return;\n    &#125;;\n    auto ask = [&amp;](int x) &#123;\n        int res = 0;\n        for (; x; x -= lowbit(x))\n            res += bit[x];\n        return res;\n    &#125;;\n    int p = 1;\n    for (int i = 1, x; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; x, add(++x);\n        long long s = ask(x), t = ask(p);\n        if (s * p == t * x ? x &gt; p : s * p &gt; t * x)\n            p = x;\n        else\n            s = t;\n        if (s &gt; p * res)\n            ++res;\n        std::cout &lt;&lt; res &lt;&lt; &#39; &#39;;\n    &#125;\n    std::cout &lt;&lt; &#39;\\n&#39;;\n    std::cerr &lt;&lt; std::chrono::duration&lt;double&gt;(std::chrono::steady_clock::now() - stime).count() &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<p>å¾ˆå®¹æ˜“å†™å‡ºæš´åŠ›ï¼Œè§‚å¯Ÿæ ·ä¾‹å°±èƒ½å‘ç°æ¯æ¬¡ä¿®æ”¹åç­”æ¡ˆæœ€å¤šå¢åŠ  <span class=\"math inline\">\\(1\\)</span>ã€‚è®°å½“å‰ç­”æ¡ˆä¸º <span class=\"math inline\">\\(res\\)</span>ï¼Œçº¿æ®µæ ‘ç»´æŠ¤ <span class=\"math inline\">\\(s_i-res\\cdot i\\)</span> çš„æœ€å°å€¼ï¼Œè‹¥å…¶ä¸ºè´Ÿåˆ™ res++ï¼Œç„¶åé‡æ„çº¿æ®µæ ‘ï¼ˆç­‰å·®æ•°åˆ—å’Œ min ä¸å…¼å®¹ï¼‰ã€‚</p>\n<p>æ€ä¹ˆåˆæœ‰ä¸ç­‰å¼ ğŸ˜±</p>\n<p>ç›®çš„æ˜¯åœ¨æœ¬æ¥åˆæ³•çš„èŒƒå›´é‡Œæ‰¾åˆ°æ–°çš„ä¸åˆæ³•å€¼ã€‚è€ƒè™‘åˆæ³•èŒƒå›´ï¼š<span class=\"math inline\">\\(s_i-res\\cdot i\\ge 0\\)</span>ï¼Œè§£ä¸€ä¸‹å¾—åˆ° <span class=\"math inline\">\\(i\\le \\dfrac {s_i}{res}\\)</span>ï¼Œæ”¾ç¼©å¾—åˆ° <span class=\"math inline\">\\(i\\le\\dfrac {n}{res}\\)</span>ï¼Œæ¯æ¬¡ <span class=\"math inline\">\\(res\\)</span> å˜åŒ–æ—¶åªé‡æ„ <span class=\"math inline\">\\(\\dfrac {n}{res}\\)</span> ä»¥å‰çš„ä½ç½®ï¼Œé‡æ„çš„æ€»é•¿æ˜¯ <span class=\"math inline\">\\(O(n\\ln n)\\)</span> çš„ã€‚ï¼ˆçº¿æ®µæ ‘å»ºæ ‘æ˜¯çº¿æ€§çš„ï¼‰</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 1e6 + 5;\nconst int inf = 0x3f3f3f3f;\nstruct &#123;\n    int l, r, u, d;\n&#125; t[maxn &lt;&lt; 2];\n#define lt (p &lt;&lt; 1)\n#define rt (lt | 1)\nvoid bld(int p, int l, int r) &#123;\n    t[p].u = t[p].l = l, t[p].r = r;\n    if (l == r)\n        return;\n    int mid = (l + r) &gt;&gt; 1;\n    bld(lt, l, mid), bld(rt, mid + 1, r);\n    return;\n&#125;\nvoid pushdown(int p) &#123;\n    if (t[p].d) &#123;\n        t[lt].d += t[p].d, t[rt].d += t[p].d;\n        t[lt].u -= t[p].d, t[rt].u -= t[p].d;\n        t[p].d = 0;\n    &#125;\n    return;\n&#125;\nvoid add(int p, int x) &#123;\n    if (x &lt;= t[p].l) &#123;\n        ++t[p].d, --t[p].u;\n        return;\n    &#125;\n    pushdown(p);\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (x &lt;= mid)\n        add(lt, x);\n    add(rt, x);\n    t[p].u = std::min(t[lt].u, t[rt].u);\n    // printf(&quot;[%d, %d]: %d, [%d, %d]: %d\\n&quot;, t[p].l, mid, t[lt].u, mid + 1, t[p].r, t[rt].u);\n    return;\n&#125;\nvoid rem(int p, int r) &#123;\n    if (t[p].l == t[p].r) &#123;\n        t[p].u += t[p].l;\n        return;\n    &#125;\n    pushdown(p);\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (r &lt;= mid)\n        rem(lt, r), t[rt].u = inf;\n    else\n        rem(lt, r), rem(rt, r);\n    t[p].u = std::min(t[lt].u, t[rt].u);\n    return;\n&#125;\n#undef lt\n#undef rt\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n    std::freopen(&quot;doll.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;doll.out&quot;, &quot;w&quot;, stdout);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    bld(1, 1, n + 1);\n    for (int i = 1, x, res = 1, now = n; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; x;\n        if (x &lt;= now)\n            add(1, ++x);\n        if (t[1].u &lt; 0) &#123;\n            std::cout &lt;&lt; ++res &lt;&lt; &#39; &#39;;\n            rem(1, now = n / res);\n        &#125;\n        else\n            std::cout &lt;&lt; res &lt;&lt; &#39; &#39;;\n        // puts(&quot;&quot;);\n    &#125;\n    std::cout &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"e---subarray-sum-divisibility\">E - Subarray Sum Divisibility</h2>\n<p><a href=\"https://atcoder.jp/contests/abc419/tasks/abc419_e\" class=\"uri\">https://atcoder.jp/contests/abc419/tasks/abc419_e</a></p>\n<p>æ¨¡æ„ä¹‰ä¸‹çš„æ•°åˆ—å…¨ç­‰ï¼Œå¯ä»¥å¯¹åº”åŸæ•°ç»„å…¨ç­‰ã€å·®åˆ†å…¨ç­‰ã€å‰ç¼€å’Œå…¨ç­‰ï¼ˆéƒ½æ˜¯æ¨¡æ„ä¹‰ä¸‹çš„ï¼Œè¿˜æœ‰å…¶ä»–çš„ä¸€äº›çº¿æ€§å’Œéçº¿æ€§çš„å˜æ¢ä¹Ÿå¯ä»¥ï¼‰</p>\n<p>æœ¬ç€ä¿®æ”¹çš„ç‚¹å°½é‡å°‘çš„æƒ³æ³•ï¼Œå¦‚æœé¢˜ç›®ç»™å®šå•ç‚¹ä¿®æ”¹å°±å¯ä»¥åœ¨åŸæ•°ç»„ä¸Šåšæ–‡ç« ï¼Œç»™å®šåŒºé—´ä¿®æ”¹å¯ä»¥è€ƒè™‘å·®åˆ†æ•°ç»„ï¼Œå‰ç¼€å’Œå¯¹äºä¸€äº›åŒºé—´æŸ¥è¯¢æœ‰ä¼˜åŠ¿</p>\n<p>å…¶ä»–ä¸¤ç§ç”¨å¾—ä¹Ÿå¾ˆå¤šï¼Œåƒè¿™é¢˜åªéœ€è¦ç”¨åŸæ•°ç»„å…¨ç­‰å°±å¯ä»¥åšäº†</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int inf = 0x3f3f3f3f;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, m, l;\n    std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; l;\n    std::vector&lt;int&gt; a(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i];\n    std::vector&lt;std::vector&lt;int&gt; &gt; u(l + 1, std::vector&lt;int&gt; (m));\n    for (int i = 1; i &lt;= l; ++i)\n        for (int j = 0; j &lt; m; ++j)\n            for (int k = i; k &lt;= n; k += l)\n                u[i][j] += (j + m - a[k]) % m;\n    std::vector&lt;std::vector&lt;int&gt; &gt; f(l + 1, std::vector&lt;int&gt; (m, inf));\n    f[0][0] = 0;\n    for (int i = 1; i &lt;= l; ++i)\n        for (int j = 0; j &lt; m; ++j)\n            for (int k = 0; k &lt; m; ++k)\n                f[i][(j + k) % m] = std::min(f[i][(j + k) % m], f[i - 1][j] + u[i][k]);\n    std::cout &lt;&lt; f[l][0] &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;\n</code></pre>\n</details>\n<hr />\n<h2 id=\"f---all-included\">F - All Included</h2>\n<p><a href=\"https://atcoder.jp/contests/abc419/tasks/abc419_f\" class=\"uri\">https://atcoder.jp/contests/abc419/tasks/abc419_f</a></p>\n<p>åŸé¢˜æ„è½¬åŒ–ä¸ºåœ¨ AC è‡ªåŠ¨æœºä¸Šèµ° <span class=\"math inline\">\\(L\\)</span> æ­¥ï¼Œè¦æ±‚ç»è¿‡ <span class=\"math inline\">\\(n\\)</span> ä¸ªå¶å­çš„æ–¹æ¡ˆæ•°ã€‚ä¸å¤ªå¯åšï¼Œè½¬åŒ–æˆå®¹æ–¥ï¼ˆä»¤å­—ç¬¦ä¸²ç»ˆç‚¹ä¸å¯è¾¾ï¼‰ã€‚åœ¨å¤–å±‚æšä¸¾æ­¥æ•°æš´åŠ›æ¸¸èµ°ã€‚</p>\n<p>è¦æ±‚æ°å¥½èµ° <span class=\"math inline\">\\(L\\)</span> æ­¥ï¼Œä¹Ÿå¯ä»¥ç”¨çŸ©é˜µï¼›ä½†åŸå›¾å¾ˆç¨€ç–ï¼Œæ‰€ä»¥çŸ©é˜µå¹¶æ²¡æœ‰ä¼˜åŠ¿ã€‚</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 998244353;\nint tot = 1, T[805][26], fail[805];\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, l;\n    std::cin &gt;&gt; n &gt;&gt; l;\n    std::vector&lt;std::string&gt; a;\n    &#123;\n        std::vector&lt;std::string&gt; s(n + 1);\n        for (int i = 1; i &lt;= n; ++i)\n            std::cin &gt;&gt; s[i];\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            bool flag = 1;\n            for (int j = 1; j &lt;= n; ++j)\n                if (j != i)\n                    if (s[j].find(s[i]) != std::string::npos) &#123;\n                        flag = 0;\n                        break;\n                    &#125;\n            if (flag)\n                a.push_back(s[i]);\n        &#125;\n        n = (int)a.size();\n    &#125;\n    std::vector&lt;int&gt; pos(n);\n    for (int i = 0; i &lt; n; ++i) &#123;\n        int &amp;p = pos[i];\n        for (auto j : a[i]) &#123;\n            if (!T[p][j - &#39;a&#39;])\n                T[p][j - &#39;a&#39;] = tot++;\n            p = T[p][j - &#39;a&#39;];\n        &#125;\n    &#125;\n    &#123;\n        std::queue&lt;int&gt; q;\n        for (int i = 0; i &lt; 26; ++i)\n            if (T[0][i])\n                q.push(T[0][i]);\n        for (; !q.empty(); ) &#123;\n            int u = q.front();\n            q.pop();\n            for (int i = 0; i &lt; 26; ++i)\n                if (T[u][i]) &#123;\n                    int v = T[u][i];\n                    fail[v] = T[fail[u]][i];\n                    q.push(v);\n                &#125;\n                else\n                    T[u][i] = T[fail[u]][i];\n        &#125;\n    &#125;\n    auto res = 0ll;\n    int siz = 1 &lt;&lt; n;\n    for (int i = 0; i &lt; siz; ++i) &#123;\n        std::vector&lt;int&gt; tag(tot);\n        for (int j = 0; j &lt; n; ++j)\n            if ((i &gt;&gt; j) &amp; 1)\n                tag[pos[j]] = 1;\n        std::vector&lt;std::vector&lt;long long&gt; &gt; f(l + 1, std::vector&lt;long long&gt; (tot));\n        f[0][0] = 1ll;\n        for (int j = 0; j &lt; l; ++j)\n            for (int k = 0; k &lt; tot; ++k)\n                for (int a = 0; a &lt; 26; ++a) &#123;\n                    if (!tag[T[k][a]])\n                        (f[j + 1][T[k][a]] += f[j][k]) %= mod;\n                &#125;\n        int k = (__builtin_popcount(i) &amp; 1 ? mod - 1 : 1);\n        auto s = 0ll;\n        for (int j = 0; j &lt; tot; ++j)\n            if (!tag[j])\n                (s += f[l][j]) %= mod;\n        (res += k * s) %= mod;\n    &#125;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"g---count-simple-paths-2\">G - Count Simple Paths 2</h2>\n<p><a href=\"https://atcoder.jp/contests/abc419/tasks/abc419_g\" class=\"uri\">https://atcoder.jp/contests/abc419/tasks/abc419_g</a></p>\n<p>å¾ˆæ–°çš„æ€§è´¨ã€‚è€ƒè™‘ã€ä»¥ <span class=\"math inline\">\\(1\\)</span> ä¸ºèµ·ç‚¹çš„ç®€å•è·¯å¾„æ•°ã€å’Œåç¥–è¾¹æ•°é‡çš„å…³ç³»ï¼šé€‰å®šä¸€æ¡åç¥–è¾¹å¿…é¡»è¢«ç»è¿‡æ—¶ï¼ˆæ˜¾ç„¶åªæœ‰ä¸€ç§å¯èƒ½çš„ç»è¿‡æ–¹å‘ï¼‰ï¼Œæ ‘çš„å½¢æ€å‘ç”Ÿå˜åŒ–ï¼š</p>\n<p><img src=\"image.png\" /></p>\n<p>ä¹Ÿå°±æ˜¯è¯´ï¼Œä¸€ç§åç¥–è¾¹çš„é€‰å–æ–¹æ¡ˆå¯¹åº”ä¸€ç§æ ‘ï¼Œéå†å…¶ä» <span class=\"math inline\">\\(1\\)</span> å¼€å§‹çš„ç®€å•è·¯å¾„å¤æ‚åº¦ä¸º <span class=\"math inline\">\\(O(n)\\)</span>ã€‚è®¾åç¥–è¾¹æ•°é‡ä¸º <span class=\"math inline\">\\(k\\)</span>ï¼Œé‚£ä¹ˆåˆæ³•çš„æ–¹æ¡ˆæ•°ä¸è¶…è¿‡ <span class=\"math inline\">\\(2^k\\)</span>ï¼Œæš´åŠ› DFS çš„æ•´ä¸ªå›¾å¤æ‚åº¦ä¸º <span class=\"math inline\">\\(O(2^k\\cdot n)\\)</span>ã€‚</p>\n<p>å‘ç°å¾ˆå¤šè·Ÿåç¥–è¾¹æ— å…³çš„éå†æ˜¯ä¸å¿…è¦çš„ï¼ˆåªæœ‰ä¸€ç§èµ°æ³•ï¼Œå¯ä»¥è®¾æˆè¾¹æƒï¼‰ï¼Œè€ƒè™‘å¯¹æ‰€æœ‰è¿æ¥åç¥–è¾¹çš„ç‚¹å»ºç«‹è™šæ ‘ï¼Œå¹¶æŠŠåŸæ ‘ä¸Šçš„åç¥–è¾¹ä¹Ÿç§»åˆ°è™šæ ‘ä¸Šï¼Œå°±èƒ½ <span class=\"math inline\">\\(O(2^k\\cdot k)\\)</span> è§£å†³é—®é¢˜ã€‚</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, m;\n    std::cin &gt;&gt; n &gt;&gt; m;\n    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1), g1(n + 1);\n    std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; g2(n + 1);\n    for (int x, y; m--; ) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y;\n        g[x].push_back(y), g[y].push_back(x);\n    &#125;\n    std::vector&lt;int&gt; tag(n + 1), vis(n + 1);\n    std::vector&lt;std::pair&lt;int, int&gt; &gt; be;\n    std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int fa) &#123;\n        static int now = 0;\n        tag[x] = 1, vis[x] = ++now;\n        for (auto i : g[x])\n            if (!tag[i]) &#123;\n                // fprintf(stderr, &quot;%d -&gt; %d\\n&quot;, x, i);\n                g1[x].push_back(i), DFS(i, x);\n            &#125;\n            else if (i != fa &amp;&amp; vis[i] &lt; vis[x])\n                be.emplace_back(i, x);\n        return;\n    &#125;;\n    DFS(1, -1);\n    &#123; // æ±‚è™šæ ‘\n        std::vector&lt;int&gt; dep(n + 1), fa(n + 1), top(n + 1), siz(n + 1), son(n + 1), dfn(n + 1), rfn(n + 1);\n        std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;\n            siz[x] = 1;\n            for (auto i : g1[x]) &#123;\n                dep[i] = dep[x] + 1;\n                fa[i] = x, DFS(i);\n                siz[x] += siz[i];\n                if (siz[i] &gt; siz[son[x]])\n                    son[x] = i;\n            &#125;\n            return;\n        &#125;;\n        DFS(1);\n        DFS = [&amp;](int x) &#123;\n            static int now = 0;\n            dfn[x] = ++now;\n            if (son[x])\n                top[son[x]] = top[x], DFS(son[x]);\n            for (auto i : g1[x])\n                if (i != son[x])\n                    top[i] = i, DFS(i);\n            rfn[x] = now;\n            // printf(&quot;%d: [%d, %d]\\n&quot;, x, dfn[x], rfn[x]);\n            return;\n        &#125;;\n        top[1] = 1, DFS(1);\n        auto getLCA = [&amp;](int x, int y) &#123;\n            for (; top[x] != top[y]; x = fa[top[x]])\n                if (dep[top[x]] &lt; dep[top[y]])\n                    std::swap(x, y);\n            return dep[x] &lt; dep[y] ? x : y;\n        &#125;;\n        tag.assign(n + 1, 0);\n        tag[1] = tag[n] = 1;\n        for (auto [u, v] : be)\n            tag[u] = 1, tag[v] = 1;\n        std::vector&lt;int&gt; p;\n        for (int i = 1; i &lt;= n; ++i)\n            if (tag[i])\n                p.push_back(i);\n        std::sort(p.begin(), p.end(), [&amp;](int i, int j) &#123; return dfn[i] &lt; dfn[j]; &#125;);\n        for (int i = 1; i &lt; (int)p.size(); ++i) &#123;\n            int fa = getLCA(p[i], p[i - 1]);\n            if (!tag[fa])\n                tag[fa] = 1;\n        &#125;\n        p.clear();\n        for (int i = 1; i &lt;= n; ++i)\n            if (tag[i])\n                p.push_back(i);\n        std::sort(p.begin(), p.end(), [&amp;](int i, int j) &#123; return dfn[i] &lt; dfn[j]; &#125;);\n        std::vector&lt;int&gt; st;\n        for (auto i : p) &#123;\n            if (st.empty())\n                st.push_back(i);\n            else &#123;\n                for (; rfn[st.back()] &lt; dfn[i]; st.pop_back());\n                g2[st.back()].emplace_back(i, dep[i] - dep[st.back()]);\n                g2[i].emplace_back(st.back(), dep[i] - dep[st.back()]);\n                // printf(&quot;add (%d, %d): %d\\n&quot;, st.back(), i, dep[i] - dep[st.back()]);\n                st.push_back(i);\n            &#125;\n        &#125;\n        for (auto [u, v] : be) &#123;\n            g2[u].emplace_back(v, 1), g2[v].emplace_back(u, 1);\n            // printf(&quot;# add(%d, %d): 1\\n&quot;, u, v);\n        &#125;\n    &#125;\n    tag.assign(n + 1, 0);\n    std::vector&lt;int&gt; res(n + 1);\n    DFS = [&amp;](int x, int s) &#123;\n        if (x == n)\n            ++res[s];\n        tag[x] = 1;\n        for (auto [i, w] : g2[x])\n            if (!tag[i])\n                DFS(i, s + w);\n        tag[x] = 0;\n        return;\n    &#125;;\n    DFS(1, 0);\n    for (int i = 1; i &lt; n; ++i)\n        std::cout &lt;&lt; res[i] &lt;&lt; &#39; &#39;;\n    std::cout &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n",
            "tags": [
                "çº¿æ®µæ ‘",
                "AC è‡ªåŠ¨æœº",
                "è´ªå¿ƒ",
                "DP ä¼˜åŒ–",
                "è™šæ ‘"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20250603/",
            "url": "https://xsc062.netlify.app/20250603/",
            "title": "è™šæ ‘",
            "date_published": "2025-06-03T12:15:29.000Z",
            "content_html": "<p>å‡¡æ‰€æœ‰ç›¸ï¼Œçš†æ˜¯è™šå¦„â‘ ã€‚</p>\n<p><em>æ³¨é‡Šï¼šâ‘ è™šå¦„ï¼šçŠ¹è¨€è™šæ ‘æ˜¯ç‹‚å¦„çš„ç®—æ³•ã€‚</em></p>\n<span id=\"more\"></span>\n<hr />\n<h2 id=\"å®šä¹‰\">å®šä¹‰</h2>\n<p>ç»™å®šä¸€ä¸ªå¤§å°ä¸º <span class=\"math inline\">\\(n\\)</span> çš„æ ‘å’Œæ ‘ä¸Š <span class=\"math inline\">\\(k\\)</span> ä¸ªå…³é”®ç‚¹ã€‚å–å‡ºè¿™ <span class=\"math inline\">\\(k\\)</span> ä¸ªå…³é”®ç‚¹å’Œå®ƒä»¬ä»»æ„ä¸¤ä¸ªé—´çš„ LCA ä½œä¸ºè™šæ ‘çš„ç‚¹é›†ï¼ŒæŒ‰ç…§åŸæ ‘ä¸Šçš„ç¥–å­™å…³ç³»è¿è¾¹å¾—åˆ°è™šæ ‘ã€‚</p>\n<p><img src=\"1.png\" /></p>\n<hr />\n<h2 id=\"æ±‚è™šæ ‘\">æ±‚è™šæ ‘</h2>\n<p>æŒ‰ç…§ DFN æ’åºï¼Œè·å–ä»»æ„ç›¸é‚»ä¸¤ç‚¹ LCAï¼Œå³å¯ç”Ÿæˆè™šæ ‘ç‚¹é›†ã€‚å°†ç‚¹é›†æŒ‰ DFN æ’åºåè¿è¾¹ï¼Œå¤æ‚åº¦ä¸º <span class=\"math inline\">\\(O(k\\log k)\\)</span>ã€‚</p>\n<p>è‡³å°‘ä¸¤ä¸ªå®ç‚¹å¯¹åº”ä¸€ä¸ªè™šç‚¹ï¼Œæ•…è€Œè™šæ ‘å¤§å°ä¸º <span class=\"math inline\">\\(O(k)\\)</span>ã€‚</p>\n<hr />\n<h2 id=\"ç”¨é€”\">ç”¨é€”</h2>\n<p>æ³¨æ„åˆ°æ— è®ºæ˜¯æ„å»ºè¿˜æ˜¯éå†è™šæ ‘å¤æ‚åº¦éƒ½ä¸ <span class=\"math inline\">\\(n\\)</span> æ— å…³ã€‚å› è€Œé€‚ç”¨äºå¯¹ <span class=\"math inline\">\\(\\sum k\\)</span> æœ‰é™åˆ¶çš„é¢˜ç›®ã€‚</p>\n<hr />\n<h3 id=\"b---leaf-color\">B - Leaf Color</h3>\n<p><a href=\"https://atcoder.jp/contests/abc340/tasks/abc340_g\" class=\"uri\">https://atcoder.jp/contests/abc340/tasks/abc340_g</a></p>\n<p>æšä¸¾æ‰€æœ‰é¢œè‰²ï¼Œæ¯æ¬¡å¯¹è¯¥é¢œè‰²å¯¹åº”çš„æ‰€æœ‰ç‚¹å»ºç«‹è™šæ ‘ï¼Œå‘ç°ä¸èƒ½é€‰è™šæ ‘å¤–çš„å…¶ä»–ç‚¹ï¼Œè™šæ ‘ä¸Š DP å³å¯ã€‚</p>\n<p>æ³¨æ„æ ¹æœ‰å¯èƒ½æ˜¯å¶å­ã€‚éœ€è¦ç‰¹åˆ¤ä¸€ä¸‹ã€‚</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 998244353;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;int&gt; a(n + 1);\n    std::vector&lt;std::vector&lt;int&gt; &gt; g1(n + 1), t(n + 1), g(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i], t[a[i]].push_back(i);\n    for (int i = 1, x, y; i &lt; n; ++i) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y;\n        g1[x].push_back(y), g1[y].push_back(x);\n    &#125;\n    std::vector&lt;int&gt; siz(n + 1), son(n + 1), dep(n + 1), fa(n + 1);\n    std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int faa) &#123;\n        siz[x] = 1;\n        for (auto i : g1[x])\n            if (i != faa) &#123;\n                dep[i] = dep[x] + 1;\n                fa[i] = x;\n                DFS(i, x);\n                if (siz[i] &gt; siz[son[x]])\n                    son[x] = i;\n            &#125;\n        return;\n    &#125;;\n    DFS(1, -1);\n    std::vector&lt;int&gt; dfn(n + 1), rfn(n + 1), top(n + 1);\n    DFS = [&amp;](int x, int fa) &#123;\n        static int now = 0;\n        dfn[x] = ++now;\n        if (son[x])\n            top[son[x]] = top[x], DFS(son[x], x);\n        for (auto i : g1[x])\n            if (i != fa &amp;&amp; i != son[x])\n                top[i] = i, DFS(i, x);\n        rfn[x] = now;\n        return;\n    &#125;;\n    top[1] = 1, DFS(1, -1);\n    auto getLCA = [&amp;](int x, int y) &#123;\n        for (; top[x] != top[y]; x = fa[top[x]])\n            if (dep[top[x]] &lt; dep[top[y]])\n                std::swap(x, y);\n        return dep[x] &lt; dep[y] ? x : y;\n    &#125;;\n    std::vector&lt;int&gt; tag(n + 1);\n    std::vector&lt;long long&gt; f(n + 1);\n    auto res(0ll);\n    for (int k = 1; k &lt;= n; ++k)\n        if (!t[k].empty()) &#123;\n            std::sort(t[k].begin(), t[k].end(), [&amp;](int x, int y) &#123; return dfn[x] &lt; dfn[y]; &#125;);\n            std::vector&lt;int&gt; p;\n            for (auto i : t[k])\n                tag[i] = 1, p.push_back(i);\n            for (int i = 1; i &lt; (int)t[k].size(); ++i) &#123;\n                int fa = getLCA(t[k][i - 1], t[k][i]);\n                if (!tag[fa])\n                    tag[fa] = 1, p.push_back(fa);\n            &#125;\n            std::sort(p.begin(), p.end(), [&amp;](int x, int y) &#123; return dfn[x] &lt; dfn[y]; &#125;);\n            std::vector&lt;int&gt; tmp;\n            for (auto i : p) &#123;\n                if (!tmp.empty()) &#123;\n                    for (; rfn[tmp.back()] &lt; dfn[i]; tmp.pop_back());\n                    g[tmp.back()].push_back(i);\n                &#125;\n                tmp.push_back(i);\n            &#125;\n            std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;\n                f[x] = 1ll;\n                auto s(1ll);\n                for (auto i : g[x]) &#123;\n                    DFS(i), (s += f[i]) %= mod;\n                    (f[x] *= f[i] + 1) %= mod;\n                &#125;\n                if (a[x] != k)\n                    (f[x] += mod - s) %= mod;\n                // printf(&quot;color = %d, res += f[%d](%lld)\\n&quot;, k, x, f[x]);\n                (res += f[x]) %= mod;\n                if (a[x] != k)\n                    --s, (f[x] += s) %= mod;\n                return;\n            &#125;;\n            DFS(p.front());\n            for (auto i : p) &#123;\n                tag[i] = 0, f[i] = 0ll;\n                std::vector&lt;int&gt;().swap(g[i]);\n            &#125;\n        &#125;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"c---watching-cowflix-p\">C - Watching Cowflix P</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P9132\" class=\"uri\">https://www.luogu.com.cn/problem/P9132</a></p>\n<p>ä¼šæƒ³åˆ°é’¦å®š <span class=\"math inline\">\\(k\\)</span> å†æ¥åšã€‚å‘ç°ä»»æ„æƒ…å†µä¸‹éƒ½æœ‰ï¼šå‡å¦‚ä¸¤ä¸ªè¿é€šå—è·ç¦» <span class=\"math inline\">\\(\\le k\\)</span>ï¼Œé‚£ä¹ˆåˆå¹¶èµ·æ¥ä¸åŠ£ã€‚æ‰€ä»¥æŠŠè·ç¦» <span class=\"math inline\">\\(\\le k\\)</span> çš„æ‰€æœ‰ç‚¹éƒ½åˆå¹¶èµ·æ¥å‘ç°åªå‰©ä¸‹ <span class=\"math inline\">\\(O(\\frac nk)\\)</span> ä¸ªç‚¹äº†ï¼Œæƒ³åˆ°ç”¨è™šæ ‘ã€‚</p>\n<p>ç„¶åè™šæ ‘ä¸Šæšä¸¾ç‚¹é€‰ä¸é€‰ï¼ŒDP ä¸€ä¸‹å°±å®Œäº†ã€‚</p>\n<p>ä½†æ˜¯å®ç°èµ·æ¥å¥½å²å•Šã€‚åˆå¹¶éœ€è¦ç”¨å¹¶æŸ¥é›†ç»´æŠ¤çˆ¶äº²ï¼ˆè€Œéæœ¬èº«ï¼‰ï¼Œç‰¹åˆ«æ‰“è„‘å£³ã€‚</p>\n<details>\n<p>æˆ‘çš„å¤©å“ªæ»”å¤©å·¨å²ã€‚</p>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int inf = 0x3f3f3f3f;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, rt;\n    std::cin &gt;&gt; n;\n    std::vector&lt;int&gt; p, tag(n + 1);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        char t;\n        std::cin &gt;&gt; t;\n        if (t == &#39;1&#39;)\n            p.push_back(i), tag[i] = 1;\n    &#125;\n    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1), g1(n + 1);\n    for (int i = 1, x, y; i &lt; n; ++i) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y;\n        g1[x].push_back(y), g1[y].push_back(x);\n    &#125;\n    std::set&lt;int&gt; st;\n    std::vector&lt;int&gt; to(n + 1), len(n + 1), cnt(n + 1), dfn(n + 1);\n    &#123;\n        std::vector&lt;int&gt; siz(n + 1), son(n + 1), fa(n + 1), dep(n + 1);\n        std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int faa) &#123;\n            siz[x] = 1;\n            for (auto i : g1[x])\n                if (i != faa) &#123;\n                    dep[i] = dep[x] + 1;\n                    fa[i] = x, DFS(i, x);\n                    siz[x] += siz[i];\n                    if (siz[i] &gt; siz[son[x]])\n                        son[x] = i;\n                &#125;\n            return;\n        &#125;;\n        DFS(1, -1);\n        std::vector&lt;int&gt; rfn(n + 1), top(n + 1);\n        DFS = [&amp;](int x, int fa) &#123;\n            static int now = 0;\n            dfn[x] = ++now;\n            if (son[x])\n                top[son[x]] = top[x], DFS(son[x], x);\n            for (auto i : g1[x])\n                if (i != son[x] &amp;&amp; i != fa)\n                    top[i] = i, DFS(i, x);\n            rfn[x] = now;\n            return;\n        &#125;;\n        DFS(1, -1);\n        auto getLCA = [&amp;](int x, int y) &#123;\n            for (; top[x] != top[y]; x = fa[top[x]])\n                if (dep[top[x]] &lt; dep[top[y]])\n                    std::swap(x, y);\n            return dep[x] &lt; dep[y] ? x : y;\n        &#125;;\n        std::sort(p.begin(), p.end(), [&amp;](int x, int y) &#123; return dfn[x] &lt; dfn[y]; &#125;);\n        std::vector&lt;int&gt; vis(tag), t(p);\n        for (int i = 1; i &lt; (int)p.size(); ++i) &#123;\n            int fa = getLCA(p[i - 1], p[i]);\n            if (!vis[fa])\n                vis[fa] = 1, t.push_back(fa);\n        &#125;\n        std::sort(t.begin(), t.end(), [&amp;](int x, int y) &#123; return dfn[x] &lt; dfn[y]; &#125;);\n        rt = t.front();\n        std::vector&lt;int&gt; stk;\n        for (auto i : t) &#123;\n            if (!stk.empty()) &#123;\n                for (; rfn[stk.back()] &lt; dfn[i]; stk.pop_back());\n                to[i] = stk.back(), len[i] = dep[i] - dep[to[i]] - 1;\n            &#125;\n            st.insert(i), stk.push_back(i);\n        &#125;\n    &#125;\n    std::vector&lt;int&gt; fa(n + 1), siz(n + 1, 1);\n    std::iota(fa.begin() + 1, fa.end(), 1);\n    std::function&lt;int(int)&gt; find = [&amp;](int x) &#123;\n        return x == fa[x] ? x : fa[x] = find(fa[x]);\n    &#125;;\n    std::vector&lt;std::array&lt;int, 2&gt; &gt; f(n + 1);\n    std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int k) &#123;\n        if (tag[x])\n            f[x][0] = inf;\n        f[x][1] = siz[x] + k;\n        for (auto i : g[x]) &#123;\n            DFS(i, k);\n            if (!tag[x])\n                f[x][0] += std::min(f[i][0], f[i][1]);\n            f[x][1] += std::min(&#123; f[i][0], f[i][1], f[i][1] + len[i] - k &#125;);\n        &#125;\n        return;\n    &#125;;\n    std::function&lt;void(int, int, int)&gt; DFS1 = [&amp;](int x, bool flag, int k) &#123;\n        for (auto i : g[x])\n            if (flag) &#123;\n                if (f[i][0] &lt;= std::min(f[i][1], f[i][1] + len[i] - k))\n                    DFS1(i, 0, k);\n                else &#123;\n                    DFS1(i, 1, k);\n                    if (f[i][1] + len[i] - k &lt; f[i][1]) &#123;\n                        tag[x] |= tag[i];\n                        siz[x] += siz[i] + len[i];\n                        st.erase(i), fa[i] = x;\n                    &#125;\n                &#125;\n            &#125;\n            else &#123;\n                if (f[i][0] &lt;= f[i][1])\n                    DFS1(i, 0, k);\n                else\n                    DFS1(i, 1, k);\n            &#125;\n        return;\n    &#125;;\n    for (int k = 1; k &lt;= n; ++k) &#123;\n        std::vector&lt;int&gt; p;\n        for (auto i : st) &#123;\n            p.push_back(i);\n            if (to[i])\n                g[find(to[i])].push_back(i);\n        &#125;\n        DFS(rt, k);\n        std::cout &lt;&lt; std::min(f[rt][0], f[rt][1]) &lt;&lt; &#39;\\n&#39;;\n        DFS1(rt, f[rt][1] &lt;= f[rt][0], k);\n        for (auto i : st)\n            f[i][0] = f[i][1] = 0, std::vector&lt;int&gt;().swap(g[i]);\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"d---smuggling-marbles\">D - Smuggling Marbles</h3>\n<p><a href=\"https://atcoder.jp/contests/arc086/tasks/arc086_c\" class=\"uri\">https://atcoder.jp/contests/arc086/tasks/arc086_c</a></p>\n<p>å®¹æ˜“æƒ³åˆ°ä»è´¡çŒ®è§’åº¦æ€è€ƒé—®é¢˜ï¼›é‚£ä¹ˆæ¯ä¸ªç‚¹åªä¸åŒæ·±åº¦çš„æ‰€æœ‰ç‚¹å­˜åœ¨ç«äº‰å…³ç³»ã€‚</p>\n<p>æŠŠæ¯ä¸ªæ·±åº¦çš„ç‚¹æ‹¿å‡ºæ¥å»ºè™šæ ‘ï¼Œåœ¨è™šæ ‘ä¸Šè·‘ DP å³å¯ã€‚</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 1e9 + 7;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, m = 0;\n    std::cin &gt;&gt; n, ++n;\n    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1), g1(n + 1);\n    for (int i = 2, x; i &lt;= n; ++i)\n        std::cin &gt;&gt; x, g1[x + 1].push_back(i);\n    std::vector&lt;int&gt; top(n + 1), dep(n + 1), dfn(n + 1), rfn(n + 1), fa(n + 1);\n    &#123;\n        std::vector&lt;int&gt; siz(n + 1), son(n + 1);\n        std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;\n            siz[x] = 1;\n            m = std::max(m, dep[x]);\n            for (auto i : g1[x]) &#123;\n                dep[i] = dep[x] + 1;\n                fa[i] = x, DFS(i);\n                siz[x] += siz[i];\n                if (siz[i] &gt; siz[son[x]])\n                    son[x] = i;\n            &#125;\n            return;\n        &#125;;\n        dep[1] = 1, DFS(1);\n        DFS = [&amp;](int x) &#123;\n            static int now = 0;\n            dfn[x] = ++now;\n            if (son[x])\n                top[son[x]] = top[x], DFS(son[x]);\n            for (auto i : g1[x])\n                if (i != son[x])\n                    top[i] = i, DFS(i);\n            rfn[x] = now;\n            return;\n        &#125;;\n        top[1] = 1, DFS(1);\n    &#125;\n    auto getLCA = [&amp;](int x, int y) &#123;\n        for (; top[x] != top[y]; x = fa[top[x]])\n            if (dep[top[x]] &lt; dep[top[y]])\n                std::swap(x, y);\n        return dep[x] &lt; dep[y] ? x : y;\n    &#125;;\n    std::vector&lt;std::vector&lt;int&gt; &gt; _p(m + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        _p[dep[i]].push_back(i);\n    std::vector&lt;int&gt; tag(n + 1), flag(n + 1);\n    std::vector&lt;std::array&lt;long long, 2&gt; &gt; f(n + 1);\n    std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;\n        f[x][0] = 1ll + flag[x], f[x][1] = flag[x];\n        auto s(1ll);\n        for (auto i : g[x]) &#123;\n            DFS(i);\n            f[x][1] = (f[x][1] * f[i][0] + s * f[i][1]) % mod;\n            (f[x][0] *= f[i][0] + f[i][1]) %= mod;\n            (s *= f[i][0]) %= mod;\n        &#125;\n        (f[x][0] += mod - f[x][1]) %= mod;\n        // printf(&quot;f[%d][0] = %lld, f[%d][1] = %lld\\n&quot;, x, f[x][0], x, f[x][1]);\n        return;\n    &#125;;\n    auto qkp = [&amp;](long long x, int y) &#123;\n        auto res(1ll);\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    auto res(0ll);\n    for (int k = 1; k &lt;= m; ++k) &#123;\n        auto &amp;p = _p[k], t(p);\n        for (auto i : p)\n            flag[i] = 1;\n        std::sort(p.begin(), p.end(), [&amp;](int x, int y) &#123; return dfn[x] &lt; dfn[y]; &#125;);\n        for (int i = 1; i &lt; (int)p.size(); ++i) &#123;\n            int fa = getLCA(p[i - 1], p[i]);\n            if (!tag[fa])\n                tag[fa] = 1, t.push_back(fa);\n        &#125;\n        std::sort(t.begin(), t.end(), [&amp;](int x, int y) &#123; return dfn[x] &lt; dfn[y]; &#125;);\n        int rt = t.front();\n        std::vector&lt;int&gt; st;\n        for (auto i : t) &#123;\n            if (!st.empty()) &#123;\n                for (; rfn[st.back()] &lt; dfn[i]; st.pop_back());\n                g[st.back()].push_back(i);\n            &#125;\n            st.push_back(i);\n        &#125;\n        DFS(rt);\n        (res += f[rt][1] * qkp(2ll, n - (int)p.size())) %= mod;\n        // std::cout &lt;&lt; f[rt][1] * qkp(2ll, n - (int)p.size()) % mod &lt;&lt; &#39;\\n&#39;;\n        for (auto i : t) &#123;\n            tag[i] = flag[i] = 0;\n            std::vector&lt;int&gt;().swap(g[i]);\n        &#125;\n    &#125;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"e---ä¸–ç•Œæ ‘\">E - ä¸–ç•Œæ ‘</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P3233\" class=\"uri\">https://www.luogu.com.cn/problem/P3233</a></p>\n<p>ä¼šæƒ³åˆ°åœ¨è™šæ ‘ä¸Šä¸¤æ¬¡ DFS æ‰¾åˆ°ç¦»ä»»æ„ç‚¹æœ€è¿‘çš„å®ç‚¹ã€‚å…·ä½“åœ°ï¼Œç¬¬ä¸€æ¬¡æ‰¾ä¸‹æ–¹ï¼Œç¬¬äºŒæ¬¡å°è¯•ç”¨ä¸Šæ–¹æ›´æ–°ã€‚</p>\n<p>æ¥ç€å‘ç°å¯¹äºè™šæ ‘ä¸Šçš„å®ç‚¹æ˜¯å¥½åšçš„ï¼›å¯¹äºå®ç‚¹çš„ä¸åœ¨æ ‘ä¸Šçš„å„¿å­æ˜¯å¥½åšçš„ï¼›æ¥ä¸‹æ¥æ˜¯è™šç‚¹åŠå…¶ä¸åœ¨æ ‘ä¸Šçš„å„¿å­ã€‚</p>\n<p>å°±è¦ç”¨åˆ°åˆšåˆšæ±‚çš„ä¿¡æ¯äº†ã€‚æ˜¾ç„¶äºŒåˆ†ä¸€ä¸‹å°±å¯ä»¥äº†ã€‚è¯´èµ·æ¥å¾ˆç®€å•ï¼Œç„¶è€Œå®é™…ä¸Šå†™èµ·æ¥å¾ˆè‹¦æ¼ <img src=\"/em/ll.gif\" /></p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, q;\n    std::cin &gt;&gt; n;\n    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1), g1(n + 1);\n    for (int i = 1, x, y; i &lt; n; ++i) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y;\n        g1[x].push_back(y), g1[y].push_back(x);\n    &#125;\n    std::vector&lt;std::array&lt;int, 21&gt; &gt; fa(n + 1);\n    std::vector&lt;int&gt; siz(n + 1), top(n + 1), dep(n + 1), dfn(n + 1), rfn(n + 1);\n    &#123;\n        std::vector&lt;int&gt; son(n + 1);\n        std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int faa) &#123;\n            siz[x] = 1;\n            for (auto i : g1[x])\n                if (i != faa) &#123;\n                    dep[i] = dep[x] + 1;\n                    fa[i][0] = x;\n                    for (int j = 1; j &lt;= 20; ++j)\n                        fa[i][j] = fa[fa[i][j - 1]][j - 1];\n                    DFS(i, x);\n                    siz[x] += siz[i];\n                    if (siz[i] &gt; siz[son[x]])\n                        son[x] = i;\n                &#125;\n            return;\n        &#125;;\n        DFS(1, -1);\n        int now = 0;\n        DFS = [&amp;](int x, int fa) &#123;\n            dfn[x] = ++now;\n            if (son[x])\n                top[son[x]] = top[x], DFS(son[x], x);\n            for (auto i : g1[x])\n                if (i != fa &amp;&amp; i != son[x])\n                    top[i] = i, DFS(i, x);\n            rfn[x] = now;\n            return;\n        &#125;;\n        top[1] = 1, DFS(1, -1);\n    &#125;\n    auto getLCA = [&amp;](int x, int y) &#123;\n        for (; top[x] != top[y]; x = fa[top[x]][0])\n            if (dep[top[x]] &lt; dep[top[y]])\n                std::swap(x, y);\n        return dep[x] &lt; dep[y] ? x : y;\n    &#125;;\n    auto getfa = [&amp;](int x, int p) &#123;\n        for (int i = 20; ~i; --i)\n            if (p &gt;= (1 &lt;&lt; i))\n                x = fa[x][i], p -= (1 &lt;&lt; i);\n        return x;\n    &#125;;\n    std::vector&lt;int&gt; to(n + 1);\n    std::vector&lt;int&gt; tag(n + 1), flag(n + 1), res(n + 1);\n    std::cin &gt;&gt; q;\n    auto dis = [&amp;](int x, int y) &#123;\n        return std::make_pair(dep[x] + dep[y] - 2 * dep[getLCA(x, y)], y);\n    &#125;;\n    std::function&lt;void(int)&gt; DFS1 = [&amp;](int x) &#123;\n        to[x] = (flag[x] ? x : -1);\n        for (auto i : g[x]) &#123;\n            DFS1(i);\n            if (~to[i] &amp;&amp; (to[x] == -1 || dis(x, to[i]) &lt; dis(x, to[x])))\n                to[x] = to[i];\n        &#125;\n        // printf(&quot;to[%d] = %d\\n&quot;, x, to[x]);\n        return;\n    &#125;, DFS2 = [&amp;](int x) &#123;\n        // printf(&quot;to[%d] = %d\\n&quot;, x, to[x]);\n        for (auto i : g[x]) &#123;\n            if (to[i] == -1 || dis(i, to[x]) &lt; dis(i, to[i]))\n                to[i] = to[x];\n            DFS2(i);\n        &#125;\n        return;\n    &#125;, DFS3 = [&amp;](int x) &#123;\n        res[to[x]] += siz[x];\n        for (auto i : g[x]) &#123;\n            res[to[x]] -= siz[getfa(i, dep[i] - dep[x] - 1)];\n            DFS3(i);\n        &#125;\n        // printf(&quot;res[%d] = %d\\n&quot;, x, res[x]);\n        return;\n    &#125;, DFS4 = [&amp;](int x) &#123;\n        for (auto i : g[x]) &#123;\n            if (to[x] == to[i])\n                res[to[x]] += siz[getfa(i, dep[i] - dep[x] - 1)] - siz[i];\n            else &#123;\n                auto dx(dis(x, to[x])), di(dis(i, to[i]));\n                int at = -1, len = dep[i] - dep[x] - 1;\n                for (int l = 0, r = len, mid; l &lt;= r; ) &#123;\n                    mid = (l + r) &gt;&gt; 1;\n                    if ([&amp;](auto dx, auto dy) &#123;\n                        dx.first += mid, dy.first += len - mid + 1;\n                        return dx &lt; dy;\n                    &#125; (dx, di))\n                        at = mid, l = mid + 1;\n                    else\n                        r = mid - 1;\n                &#125;\n                int fa = getfa(i, len - at);\n                res[to[x]] += siz[getfa(i, len)] - siz[fa];\n                res[to[i]] += siz[fa] - siz[i];\n            &#125;\n            DFS4(i);\n        &#125;\n        return;\n    &#125;;\n    for (int k; q--; ) &#123;\n        std::cin &gt;&gt; k;\n        std::vector&lt;int&gt; p(k);\n        for (int i = 0; i &lt; k; ++i)\n            std::cin &gt;&gt; p[i], tag[p[i]] = flag[p[i]] = 1;\n        auto org(p);\n        std::sort(p.begin(), p.end(), [&amp;](int x, int y) &#123; return dfn[x] &lt; dfn[y]; &#125;);\n        std::vector&lt;int&gt; t(p);\n        for (int i = 1; i &lt; (int)p.size(); ++i) &#123;\n            int fa = getLCA(p[i - 1], p[i]);\n            if (!tag[fa])\n                tag[fa] = 1, t.push_back(fa);\n        &#125;\n        if (!tag[1])\n            t.push_back(1), tag[1] = 1;\n        std::sort(t.begin(), t.end(), [&amp;](int x, int y) &#123; return dfn[x] &lt; dfn[y]; &#125;);\n        std::vector&lt;int&gt; st;\n        for (auto i : t) &#123;\n            if (!st.empty()) &#123;\n                for (; rfn[st.back()] &lt; dfn[i]; st.pop_back());\n                g[st.back()].push_back(i);\n            &#125;\n            st.push_back(i);\n        &#125;\n        DFS1(1), DFS2(1), DFS3(1), DFS4(1);\n        for (auto i : org)\n            std::cout &lt;&lt; res[i] &lt;&lt; &#39; &#39;;\n        std::cout &lt;&lt; &#39;\\n&#39;;\n        for (auto i : t) &#123;\n            res[i] = 0;\n            tag[i] = flag[i] = 0;\n            std::vector&lt;int&gt;().swap(g[i]);\n        &#125;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"f---å¤§å·¥ç¨‹\">F - å¤§å·¥ç¨‹</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P4103\" class=\"uri\">https://www.luogu.com.cn/problem/P4103</a></p>\n<p>è™šæ ‘ä¸Š DP ç»Ÿè®¡ç›¸å…³ä¿¡æ¯å³å¯ã€‚</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst long long inf = 0x3f3f3f3f;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, q;\n    std::cin &gt;&gt; n;\n    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1), g1(n + 1);\n    for (int i = 1, x, y; i &lt; n; ++i) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y;\n        g1[x].push_back(y), g1[y].push_back(x);\n    &#125;\n    std::vector&lt;int&gt; top(n + 1), dep(n + 1), dfn(n + 1), rfn(n + 1), fa(n + 1);\n    &#123;\n        std::vector&lt;int&gt; siz(n + 1), son(n + 1);\n        std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int faa) &#123;\n            siz[x] = 1;\n            for (auto i : g1[x])\n                if (i != faa) &#123;\n                    dep[i] = dep[x] + 1;\n                    fa[i] = x, DFS(i, x);\n                    siz[x] += siz[i];\n                    if (siz[i] &gt; siz[son[x]])\n                        son[x] = i;\n                &#125;\n            return;\n        &#125;;\n        DFS(1, -1);\n        int now = 0;\n        DFS = [&amp;](int x, int fa) &#123;\n            dfn[x] = ++now;\n            if (son[x])\n                top[son[x]] = top[x], DFS(son[x], x);\n            for (auto i : g1[x])\n                if (i != fa &amp;&amp; i != son[x])\n                    top[i] = i, DFS(i, x);\n            rfn[x] = now;\n            return;\n        &#125;;\n        top[1] = 1, DFS(1, -1);\n    &#125;\n    auto getLCA = [&amp;](int x, int y) &#123;\n        for (; top[x] != top[y]; x = fa[top[x]])\n            if (dep[top[x]] &lt; dep[top[y]])\n                std::swap(x, y);\n        return dep[x] &lt; dep[y] ? x : y;\n    &#125;;\n    std::vector&lt;long long&gt; s(n + 1);\n    std::vector&lt;int&gt; mx(n + 1), mn(n + 1);\n    std::vector&lt;int&gt; tag(n + 1), siz(n + 1), flag(n + 1);\n    int rmx, rmn;\n    long long rs;\n    std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;\n        if (flag[x]) &#123;\n            siz[x] = 1;\n            mx[x] = mn[x] = s[x] = 0;\n        &#125;\n        else &#123;\n            siz[x] = s[x] = 0;\n            mn[x] = inf, mx[x] = -inf;\n        &#125;\n        for (auto i : g[x]) &#123;\n            DFS(i);\n            int len = dep[i] - dep[x];\n            rmx = std::max(rmx, mx[x] + mx[i] + len);\n            mx[x] = std::max(mx[x], mx[i] + len);\n            rmn = std::min(rmn, mn[x] + mn[i] + len);\n            mn[x] = std::min(mn[x], mn[i] + len);\n            rs += siz[x] * (s[i] + (long long)siz[i] * len) + siz[i] * s[x]; \n            s[x] += s[i] + (long long)siz[i] * len;\n            siz[x] += siz[i];\n            // printf(&quot;%d -&gt; %d, mx = %d, mn = %d, s = %lld\\n&quot;, x, i, rmx, rmn, rs);\n        &#125;\n        return;\n    &#125;;\n    std::cin &gt;&gt; q;\n    for (int k; q--; ) &#123;\n        std::cin &gt;&gt; k;\n        std::vector&lt;int&gt; p(k);\n        for (int i = 0; i &lt; k; ++i)\n            std::cin &gt;&gt; p[i], tag[p[i]] = flag[p[i]] = 1;\n        std::sort(p.begin(), p.end(), [&amp;](int x, int y) &#123; return dfn[x] &lt; dfn[y]; &#125;);\n        std::vector&lt;int&gt; t(p);\n        for (int i = 1; i &lt; (int)p.size(); ++i) &#123;\n            int fa = getLCA(p[i - 1], p[i]);\n            if (!tag[fa])\n                tag[fa] = 1, t.push_back(fa);\n        &#125;\n        std::sort(t.begin(), t.end(), [&amp;](int x, int y) &#123; return dfn[x] &lt; dfn[y]; &#125;);\n        int rt = t.front();\n        std::vector&lt;int&gt; st;\n        for (auto i : t) &#123;\n            if (!st.empty()) &#123;\n                for (; rfn[st.back()] &lt; dfn[i]; st.pop_back());\n                g[st.back()].push_back(i);\n            &#125;\n            st.push_back(i);\n        &#125;\n        rs = 0ll, rmx = -inf, rmn = inf;\n        DFS(rt);\n        std::cout &lt;&lt; rs &lt;&lt; &#39; &#39; &lt;&lt; rmn &lt;&lt; &#39; &#39; &lt;&lt; rmx &lt;&lt; &#39;\\n&#39;;\n        for (auto i : t) &#123;\n            tag[i] = flag[i] = 0;\n            std::vector&lt;int&gt;().swap(g[i]);\n        &#125;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n",
            "tags": [
                "è™šæ ‘"
            ]
        }
    ]
}