{
    "version": "https://jsonfeed.org/version/1",
    "title": "null • All posts by \"分块\" tag",
    "description": "",
    "home_page_url": "https://xsc062.netlify.app",
    "items": [
        {
            "id": "https://xsc062.netlify.app/20240501/",
            "url": "https://xsc062.netlify.app/20240501/",
            "title": "五一杂题",
            "date_published": "2024-05-01T07:44:48.000Z",
            "content_html": "<p><a href=\"http://222.180.160.110:61235/contest/5169\">SAM 杂题</a> + <a href=\"http://222.180.160.110:61235/contest/5170\">NOIPS8</a> + <a href=\"http://222.180.160.110:61235/contest/5175\">周考</a> 选讲。</p>\n<p>看看这个标签列表长度就知道这三天做的题有多杂。</p>\n<span id=\"more\"></span>\n<hr />\n<h3 id=\"d.-字符串\">D. 字符串</h3>\n<p><a href=\"http://222.180.160.110:61235/contest/5169/problem/4\" class=\"uri\">http://222.180.160.110:61235/contest/5169/problem/4</a></p>\n<p>和 SA 的做法一样，先二分 <span class=\"math inline\">\\(s_{c\\sim d}\\)</span> 的前缀长度 <span class=\"math inline\">\\(mid\\)</span>，只需 check <span class=\"math inline\">\\(s_{c \\sim c + mid - 1}\\)</span> 是否在 <span class=\"math inline\">\\(s_{a\\sim b}\\)</span> 中出现过。</p>\n<p>考虑怎么快速 check。从 <span class=\"math inline\">\\(c\\)</span> 一步一步跳到 <span class=\"math inline\">\\(c+mid-1\\)</span> 显然会起飞，考虑到查询是静态的，我们事先预处理一下然后倍增地跳即可。</p>\n<p>此时只需看当前状态的 <span class=\"math inline\">\\(\\text {endpos}\\)</span> 是否在 <span class=\"math inline\">\\([a + mid - 1, b]\\)</span> 出现过。</p>\n<p>因为这个不能用最大最小简单代替，所以就到了我们喜闻乐见的线段树合并环节。将插入后的每个单点 <span class=\"math inline\">\\(\\text {endpos}\\)</span> 在权值线段树上更新，在 parent tree 上暴力线段树合并即可。</p>\n<p>之前一直有一个误区，就是觉得线段树合并是一次性的，比如用 A 树和 B 树并出来了 C 树之后，A 树和 B 树的数据就无效了。</p>\n<p>但这显然是很荒谬的，同样因为我们的查询是静态的，所以完全可以用一种类似于可持久化的方式，建立一些新的点表示合并后的信息状态点，一些可以保留的点就保留作儿子。</p>\n<p>在对应的状态上查询即可。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxm = 35;\nconst int maxn = 6e5 + 5;\nconst int maxk = 8e7 + 5;\nstruct _ &#123;\n    int l, f;\n    int ne[maxm]; \n    _() &#123;&#125;\n    _(int l1, int f1): l(l1), f(f1) &#123;&#125;\n&#125;;\n_ t[maxn &lt;&lt; 1];\nint vis[maxn &lt;&lt; 1];\nint fa[maxn][maxm];\nint n, la, tot, siz;\nstruct &#123; int l, r, u; &#125; t1[maxk];\nint tab[maxn &lt;&lt; 1], cnt[maxn &lt;&lt; 1];\nvoid Init(void) &#123;\n    la = tot = 1;\n    t[1] = _(0, 0);\n    return;\n&#125;\nvoid ext(int c) &#123;\n    int p = la, np = ++tot;\n    la = tot;\n    t[np] = _(t[p].l + 1, 0);\n    while (p &amp;&amp; !t[p].ne[c])\n        t[p].ne[c] = np, p = t[p].f;\n    if (!p)\n        t[np].f = 1;\n    else &#123;\n        int q = t[p].ne[c];\n        if (t[q].l == t[p].l + 1)\n            t[np].f = q;\n        else &#123;\n            int nq = ++tot;\n            t[nq] = _(t[p].l + 1, t[q].f);\n            std::copy(t[q].ne, t[q].ne + 26, t[nq].ne);\n            while (p &amp;&amp; t[p].ne[c] == q)\n                t[p].ne[c] = nq, p = t[p].f;\n            t[q].f = nq;\n            t[np].f = nq;\n        &#125;\n    &#125;\n    return;\n&#125;\nint now = 0;\nvoid ins(int &amp;p, int l, int r, int v) &#123;\n    if (!p)\n        p = ++now;\n    ++t1[p].u;\n    if (l == r)\n        return;\n    int mid = (l + r) &gt;&gt; 1;\n    if (v &lt;= mid)\n        ins(t1[p].l, l, mid, v);\n    else\n        ins(t1[p].r, mid + 1, r, v);\n    return;\n&#125;\nint ask(int p, int l, int r, int ql, int qr) &#123;\n    if (ql &lt;= l &amp;&amp; r &lt;= qr)\n        return t1[p].u;\n    int mid = (l + r) &gt;&gt; 1, res = 0;\n    if (ql &lt;= mid)\n        res = ask(t1[p].l, l, mid, ql, qr);\n    if (qr &gt; mid)\n        res += ask(t1[p].r, mid + 1, r, ql, qr);\n    return res;\n&#125;\nint merge(int p, int q, int l, int r) &#123;\n    if (!p || !q)\n        return p + q;\n    int np = ++now, mid = (l + r) &gt;&gt; 1;\n    t1[np].u = t1[p].u + t1[q].u;\n    if (l == r) return np;\n    t1[np].l = merge(t1[p].l, t1[q].l, l, mid);\n    t1[np].r = merge(t1[p].r, t1[q].r, mid + 1, r);\n    return np;\n&#125;\nint pos[maxn], rt[maxn &lt;&lt; 1];\nbool check(int x, int a, int b, int c, int d) &#123;\n    assert(c + x - 1 &gt;= 0);\n    int p = pos[c + x - 1];\n    for (int i = siz; ~i; --i)\n        if (fa[p][i] &amp;&amp; t[fa[p][i]].l &gt;= x)\n            p = fa[p][i];\n    return ask(rt[p], 0, n - 1, a + x - 1, b) &gt; 0;\n&#125;\nint solve(int a, int b, int c, int d) &#123;\n    int l = 1, r = std::min(d - c + 1, b - a + 1), res = 0;\n    while (l &lt;= r) &#123;\n        int mid = (l + r) &gt;&gt; 1;\n        if (check(mid, a, b, c, d))\n            l = mid + 1, res = mid;\n        else\n            r = mid - 1;\n    &#125;\n    return res;\n&#125;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    std::cout.tie(nullptr);\n#endif\n    int m;\n    std::string s;\n    std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; s;\n    Init();\n    for (int i = 0; i &lt; n; ++i) &#123;\n        ext(s[i] - &#39;a&#39;);\n        pos[i] = la;\n        ins(rt[la], 0, n - 1, i);\n    &#125;\n    siz = log(tot) / log(2.0);\n    for (int i = 1; i &lt;= tot; ++i)\n        ++cnt[t[i].l];\n    std::partial_sum(cnt + 1, cnt + tot + 1, cnt + 1);\n    for (int i = 1; i &lt;= tot; ++i)\n        tab[cnt[t[i].l]--] = i;\n    for (int i = 1; i &lt;= tot; ++i) &#123;\n        int u = tab[i];\n        fa[u][0] = t[u].f;\n        for (int j = 1; j &lt;= siz; ++j)\n            fa[u][j] = fa[fa[u][j - 1]][j - 1];\n    &#125;\n    for (int i = tot; i; --i) &#123;\n        int u = tab[i];\n        if (t[u].f)\n            rt[t[u].f] = merge(rt[t[u].f], rt[u], 0, n - 1);\n    &#125;\n    while (m--) &#123;\n        int a, b, c, d;\n        std::cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;\n        std::cout &lt;&lt; solve(a - 1, b - 1, c - 1, d - 1) &lt;&lt; &#39;\\n&#39;;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"f.-security\">F. Security</h3>\n<p><a href=\"http://222.180.160.110:61235/contest/5169/problem/6\" class=\"uri\">http://222.180.160.110:61235/contest/5169/problem/6</a></p>\n<p>对我们来说应该是会 D 就会 F 的。所以只打了 10min。</p>\n<p>首先考虑一个大家喜闻乐见的 DFS 求最小字典序。显然地，如果存在和当前位相等的字符，那么优先跳相等字符，进入下一层深搜；否则找到最小的更大字符，然后直接 out。</p>\n<p>此时 SAM 就是我们用来判断 <span class=\"math inline\">\\(S_{l, r}\\)</span> 中是否存在某状态的工具了。甚至比上一题简单，因为不用写二分和倍增。</p>\n<p>值得注意的是如果 <span class=\"math inline\">\\(S_{l, r}\\)</span> 包含 <span class=\"math inline\">\\(T\\)</span> 那么还要在后面随便加一个字符以字典序保证严格大于 <span class=\"math inline\">\\(T\\)</span>。</p>\n<details>\n<p>值得注意的是因为我写的太丑了以至于在 CF 上会光荣 MLE #46。然后分屏左半边看我代码右半边写的 zwb 却没有。啧。为什么呢。</p>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxm = 35;\nconst int maxn = 6e5 + 5;\nconst int maxk = 8e7 + 5;\nstruct _ &#123;\n    int l, f;\n    int ne[maxm]; \n    _() &#123;&#125;\n    _(int l1, int f1): l(l1), f(f1) &#123;&#125;\n&#125;;\n_ t[maxn &lt;&lt; 1];\nint vis[maxn &lt;&lt; 1];\nint fa[maxn][maxm];\nint n, la, tot, siz;\nstruct &#123; int l, r, u; &#125; t1[maxk];\nint tab[maxn &lt;&lt; 1], cnt[maxn &lt;&lt; 1];\nvoid Init(void) &#123;\n    la = tot = 1;\n    t[1] = _(0, 0);\n    return;\n&#125;\nvoid ext(int c) &#123;\n    int p = la, np = ++tot;\n    la = tot;\n    t[np] = _(t[p].l + 1, 0);\n    while (p &amp;&amp; !t[p].ne[c])\n        t[p].ne[c] = np, p = t[p].f;\n    if (!p)\n        t[np].f = 1;\n    else &#123;\n        int q = t[p].ne[c];\n        if (t[q].l == t[p].l + 1)\n            t[np].f = q;\n        else &#123;\n            int nq = ++tot;\n            t[nq] = _(t[p].l + 1, t[q].f);\n            std::copy(t[q].ne, t[q].ne + 26, t[nq].ne);\n            while (p &amp;&amp; t[p].ne[c] == q)\n                t[p].ne[c] = nq, p = t[p].f;\n            t[q].f = nq;\n            t[np].f = nq;\n        &#125;\n    &#125;\n    return;\n&#125;\nint now = 0;\nvoid ins(int &amp;p, int l, int r, int v) &#123;\n    if (!p)\n        p = ++now;\n    ++t1[p].u;\n    if (l == r)\n        return;\n    int mid = (l + r) &gt;&gt; 1;\n    if (v &lt;= mid)\n        ins(t1[p].l, l, mid, v);\n    else\n        ins(t1[p].r, mid + 1, r, v);\n    return;\n&#125;\nint ask(int p, int l, int r, int ql, int qr) &#123;\n    if (ql &lt;= l &amp;&amp; r &lt;= qr)\n        return t1[p].u;\n    int mid = (l + r) &gt;&gt; 1, res = 0;\n    if (ql &lt;= mid)\n        res = ask(t1[p].l, l, mid, ql, qr);\n    if (qr &gt; mid)\n        res += ask(t1[p].r, mid + 1, r, ql, qr);\n    return res;\n&#125;\nint merge(int p, int q, int l, int r) &#123;\n    if (!p || !q)\n        return p + q;\n    int np = ++now, mid = (l + r) &gt;&gt; 1;\n    t1[np].u = t1[p].u + t1[q].u;\n    if (l == r) return np;\n    t1[np].l = merge(t1[p].l, t1[q].l, l, mid);\n    t1[np].r = merge(t1[p].r, t1[q].r, mid + 1, r);\n    return np;\n&#125;\nint pos[maxn], rt[maxn &lt;&lt; 1];\nbool check(int p, int ch, int l, int r) &#123;\n    return ask(rt[t[p].ne[ch]], 0, n - 1, l, r) &gt; 0;\n&#125;\nbool fun(std::string &amp;res, std::string now, std::string &amp;t, int x, int p, int l, int r) &#123;\n    // std::cout &lt;&lt; &quot;x = &quot; &lt;&lt; x &lt;&lt; &quot;, now = \\&quot;&quot; &lt;&lt; now &lt;&lt; &quot;\\&quot;;\\n&quot;;\n    if (x != (int)t.length() &amp;&amp; check(p, t[x] - &#39;a&#39;, l + x, r) &amp;&amp; fun(res, now + t[x], t, x + 1, ::t[p].ne[t[x] - &#39;a&#39;], l, r))\n        return 1;\n    for (int i = (x == (int)t.length()) ? 0 : t[x] - &#39;a&#39; + 1; i &lt; 26; ++i) &#123;\n        if (check(p, i, l + x, r)) &#123;\n            now += i + &#39;a&#39;;\n            res = now;\n            return 1;\n        &#125;\n    &#125;\n    return 0;\n&#125;\nstd::string solve(std::string &amp;t, int l, int r) &#123;\n    std::string res;\n    return fun(res, &quot;&quot;, t, 0, 1, l, r) ? res : &quot;-1&quot;;\n&#125;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    std::cout.tie(nullptr);\n#endif\n    int q;\n    std::string s;\n    std::cin &gt;&gt; s &gt;&gt; q;\n    n = (int)s.length();\n    Init();\n    for (int i = 0; i &lt; n; ++i) &#123;\n        ext(s[i] - &#39;a&#39;);\n        pos[i] = la;\n        ins(rt[la], 0, n - 1, i);\n    &#125;\n    siz = log(tot) / log(2.0);\n    for (int i = 1; i &lt;= tot; ++i)\n        ++cnt[t[i].l];\n    std::partial_sum(cnt + 1, cnt + tot + 1, cnt + 1);\n    for (int i = 1; i &lt;= tot; ++i)\n        tab[cnt[t[i].l]--] = i;\n    for (int i = 1; i &lt;= tot; ++i) &#123;\n        int u = tab[i];\n        fa[u][0] = t[u].f;\n        for (int j = 1; j &lt;= siz; ++j)\n            fa[u][j] = fa[fa[u][j - 1]][j - 1];\n    &#125;\n    for (int i = tot; i; --i) &#123;\n        int u = tab[i];\n        if (t[u].f)\n            rt[t[u].f] = merge(rt[t[u].f], rt[u], 0, n - 1);\n    &#125;\n    while (q--) &#123;\n        int l, r;\n        std::string t;\n        std::cin &gt;&gt; l &gt;&gt; r &gt;&gt; t;\n        std::cout &lt;&lt; solve(t, l - 1, r - 1) &lt;&lt; &#39;\\n&#39;;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"a.-六出祁山\">A. 六出祁山</h3>\n<p><a href=\"http://222.180.160.110:61235/contest/5170/problem/1\" class=\"uri\">http://222.180.160.110:61235/contest/5170/problem/1</a></p>\n<p>是能用贪心拿 60pts 的 DP 题 /tuu</p>\n<p>需要先把暴力的式子写出来。设 <span class=\"math inline\">\\(f_{i, j}\\)</span> 为将 <span class=\"math inline\">\\(i\\)</span> 山修改高度为 <span class=\"math inline\">\\(j\\)</span> 的代价，则：</p>\n<p><span class=\"math display\">\\[\nf_{i, j} = \\min\\limits_{k\\in [j-d, j+d]}\\left\\{f_{i-1, k}\\right\\} + |h_i - j|\n\\]</span></p>\n<p>注意到可以单调队列优化。但是这样做复杂度还是 <span class=\"math inline\">\\(O(nV)\\)</span> 的，根本原因在于第二维这个 <span class=\"math inline\">\\(V\\)</span> 的状态数太多了。</p>\n<p>根据直觉，最后 <span class=\"math inline\">\\(j\\)</span> 的值应为 <span class=\"math inline\">\\(k+d\\)</span> 或 <span class=\"math inline\">\\(k-d\\)</span> 或 <span class=\"math inline\">\\(a_i\\)</span>。也就是说，我们可以认为，合法的状态数为所有的 <span class=\"math inline\">\\(a_i+x\\times d, x\\in[-n, n]\\)</span>。</p>\n<details>\n<p><summary>正确性证明……</summary></p>\n<p>考虑全部更改完后的结束状态，即最后的最优状态。</p>\n<p>考虑所有山中最矮的山 <span class=\"math inline\">\\(i\\)</span>，此山的高度要么为 <span class=\"math inline\">\\(h_i\\)</span>，要么为前一座山的高度 <span class=\"math inline\">\\(-d\\)</span>，要么为后一座山的高度 <span class=\"math inline\">\\(-d\\)</span>。</p>\n<p>考虑第二矮的山，以此类推即可。</p>\n</details>\n<p>将第二维的状态集大小减少为 <span class=\"math inline\">\\(O(n^2)\\)</span>，总时间复杂度为 <span class=\"math inline\">\\(O(n^3)\\)</span>。</p>\n<details>\n<p>需注意到因为 <span class=\"math inline\">\\(a_i+x\\times d\\)</span> 中的 <span class=\"math inline\">\\(x\\)</span> 范围为 <span class=\"math inline\">\\([-n, n]\\)</span> 共 <span class=\"math inline\">\\(2\\times n\\)</span>，所以 DP 数组第二维大小一定要开 <span class=\"math inline\">\\(2\\times n^2\\)</span> 呀！！！</p>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nusing ll = long long;\nconst int maxn = 305;\nconst int maxm = 18e4 + 5;\nconst ll inf = 0x3f3f3f3f3f3f3f3f;\nll d;\nint n;\nll h[maxn];\nll f[maxn][maxm];\nint main() &#123;\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    std::cout.tie(nullptr);\n    memset(f, 0x3f, sizeof (f));\n    std::cin &gt;&gt; n &gt;&gt; d;\n    std::vector&lt;ll&gt; st;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; h[i];\n        for (ll j = -n; j &lt;= n; ++j)\n            st.push_back(h[i] + j * d);\n    &#125;\n    std::sort(st.begin(), st.end());\n    st.erase(std::unique(st.begin(), st.end()), st.end());\n    auto abs = [&amp;](ll x) -&gt; ll &#123; return x &gt;= 0 ? x : -x; &#125;;\n    f[1][lower_bound(st.begin(), st.end(), h[1]) - st.begin()] = 0;\n    for (int i = 2; i &lt;= n; ++i) &#123;\n        int h(1), t(0), p(-1);\n        static int q[maxm];\n        for (int j = 0; j &lt; (int)st.size(); ++j) &#123;\n            while (p &lt; (int)st.size() &amp;&amp; st[p + 1] &lt;= st[j] + d) &#123;\n                ++p;\n                while (h &lt;= t &amp;&amp; f[i - 1][p] &lt;= f[i - 1][q[t]])\n                    --t;\n                q[++t] = p;\n            &#125;\n            while (h &lt;= t &amp;&amp; st[q[h]] &lt; st[j] - d)\n                ++h;\n            if (h &lt;= t)\n                f[i][j] = std::min(inf, f[i - 1][q[h]] + abs(st[j] - ::h[i]));\n        &#125;\n    &#125;\n    ll res = f[n][std::lower_bound(st.begin(), st.end(), h[n]) - st.begin()];\n    std::cout &lt;&lt; (res == inf ? -1 : res) &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"b.-水淹七军\">B. 水淹七军</h3>\n<p><a href=\"http://222.180.160.110:61235/contest/5170/problem/2\" class=\"uri\">http://222.180.160.110:61235/contest/5170/problem/2</a></p>\n<p>容易发现最后连出来一定是没有环的。所以一定是一个 DAG。</p>\n<p>我们知道状态压缩是会遍历到每一种情况的，所以我们可以假设当前的 DAG 就是该状态下的最优。</p>\n<p>至于这个「最优」如何定义就要交给我们了。我们不妨强制认为这个 DAG 是按层序遍历得到的，也就是说连续遍历到的点属于同一层（这里的层是指某点到任意源点的最长路长度）。</p>\n<p>显然只有一组相互之间没有任何连边的点才能组成同一层。不妨枚举点集然后暴力转移，转移时记录路径即可。</p>\n<details>\n<p>注意到在写这玩意儿的时候我还不会 <a href=\"/2024/05/17/20240517/\">状压枚举子集</a>，所以枚举子集的部分可能打得比较抽象。</p>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 25;\nconst int inf = 0x3f3f3f3f;\nconst int maxm = (1 &lt;&lt; 16) + 5;\nint n, res;\nint tag[maxn][maxn];\nint f[maxn], g[maxn];\nint solve(std::vector&lt;int&gt;&amp; a) &#123;\n    static int g[maxn];\n    static int f[maxm], p[maxm];\n    int n(a.size()), siz(1 &lt;&lt; n);\n    std::fill(g, g + n, 0);\n    std::fill(p, p + siz + 1, 0);\n    std::fill(f, f + siz + 1, inf);\n    std::vector&lt;int&gt; st;\n    for (int i = 0; i &lt; n; ++i) &#123;\n        for (int j = 0; j &lt; n; ++j) &#123;\n            if (::g[a[i]] &amp; (1 &lt;&lt; a[j]))\n                g[i] |= 1 &lt;&lt; j;\n        &#125;\n    &#125;\n    for (int i = 1; i &lt; siz; ++i) &#123;\n        int now = 0;\n        for (int j = 0; j &lt; n; ++j) &#123;\n            if (i &amp; (1 &lt;&lt; j))\n                now |= g[j];\n        &#125;\n        if (!(now &amp; i))\n            st.push_back(i), f[i] = 0, p[i] = i;\n        for (auto j : st) &#123;\n            if (!(i &amp; j)) &#123;\n                if (f[i | j] &gt; f[i] + 1)\n                    f[i | j] = f[i] + 1, p[i | j] = j;\n            &#125;\n        &#125;\n    &#125;\n    int now = siz - 1;\n    while (now) &#123;\n        int fa = now ^ p[now];\n        for (int i = 0; i &lt; n; ++i)\n            if (p[now] &amp; (1 &lt;&lt; i))\n                for (int j = 0; j &lt; n; ++j)\n                    if ((fa &amp; (1 &lt;&lt; j)) &amp;&amp; tag[a[j]][a[i]] == 2)\n                        tag[a[j]][a[i]] = 1, tag[a[i]][a[j]] = -1;\n        now = fa;\n    &#125;\n    return f[siz - 1];\n&#125;\nint find(int x) &#123;\n    return x == f[x] ? x : f[x] = find(f[x]);\n&#125;\nint main() &#123;\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    std::cout.tie(nullptr);\n    int m;\n    std::cin &gt;&gt; n &gt;&gt; m;\n    std::vector&lt;std::pair&lt;int, int&gt; &gt; edge;\n    for (int i = 0; i &lt; n; ++i)\n        f[i] = i;\n    while (m--) &#123;\n        int x, y;\n        std::cin &gt;&gt; x &gt;&gt; y;\n        edge.emplace_back(--x, --y);\n        f[find(x)] = find(y);\n        g[x] |= 1 &lt;&lt; y;\n        g[y] |= 1 &lt;&lt; x;\n        tag[x][y] = tag[y][x] = 2;\n    &#125;\n    std::vector&lt;int&gt; ver[maxn];\n    for (int i = 0; i &lt; n; ++i) &#123;\n        ver[find(i)].push_back(i);\n    &#125;\n    for (int i = 0; i &lt; n; ++i) &#123;\n        if (f[i] == i)\n            res = std::max(res, solve(ver[i]));\n    &#125;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    for (auto i : edge) &#123;\n        if (tag[i.first][i.second] == 1)\n            std::cout &lt;&lt; i.first + 1 &lt;&lt; &#39; &#39; &lt;&lt; i.second + 1 &lt;&lt; &#39;\\n&#39;;\n        else std::cout &lt;&lt; i.second + 1 &lt;&lt; &#39; &#39; &lt;&lt; i.first + 1 &lt;&lt; &#39;\\n&#39;;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"c.-煮酒论英雄\">C. 煮酒论英雄</h3>\n<p><a href=\"http://222.180.160.110:61235/contest/5170/problem/3\" class=\"uri\">http://222.180.160.110:61235/contest/5170/problem/3</a></p>\n<p>注意到如果存在串被其他串包含那么直接将其毙掉就可以了。</p>\n<p>对于相互不完全包含的串，我们令 <span class=\"math inline\">\\(mx_{i, j, 0/1, 0/1}\\)</span> 表示将正序 / 逆序的 <span class=\"math inline\">\\(i\\)</span> 串拼到正序 / 逆序的 <span class=\"math inline\">\\(j\\)</span> 串之前，两者共用相接公共部分的串长。这个可以用字符串哈希暴力求。</p>\n<p>用状压枚举拼接顺序，求得最小总串长即可。</p>\n<p>注意如果去掉被包含串后 <span class=\"math inline\">\\(n=1\\)</span> 时需直接输出串的 border；以及答案需和 <span class=\"math inline\">\\(2\\)</span> 取 <span class=\"math inline\">\\(\\max\\)</span>。</p>\n<p>实现起来又臭又长，但实际上思路确实非常简单。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nusing ll = long long;\nconst int p = 131;\nconst int maxn = 25;\nconst int lim = 2e4;\nconst int maxl = 2e4 + 5;\nconst int mod = 998244353;\nconst int inf = 0x3f3f3f3f;\nconst int maxm = (1 &lt;&lt; 16) + 5;\nint n;\nstd::vector&lt;std::string&gt; s;\nstd::vector&lt;std::vector&lt;ll&gt; &gt; h[2];\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    std::cout.tie(nullptr);\n#endif\n    std::cin &gt;&gt; n;\n    s.resize(n);\n    h[0].resize(n);\n    h[1].resize(n);\n    static ll base[maxl];\n    static bool del[maxn];\n    base[0] = 1;\n    for (int i = 1; i &lt;= lim; ++i)\n        base[i] = base[i - 1] * p % mod;\n\n    for (int i = 0; i &lt; n; ++i) &#123;\n        std::cin &gt;&gt; s[i];\n        h[0][i].resize((int)s[i].length());\n        h[1][i].resize((int)s[i].length());\n        ll x = 0;\n        for (int j = 0; j &lt; (int)s[i].length(); ++j, (x *= p) %= mod)\n            h[0][i][j] = ((x += s[i][j]) %= mod);\n        std::reverse(s[i].begin(), s[i].end());\n        x = 0;\n        for (int j = 0; j &lt; (int)s[i].length(); ++j, (x *= p) %= mod)\n            h[1][i][j] = ((x += s[i][j]) %= mod);\n        std::reverse(s[i].begin(), s[i].end());\n    &#125;\n\n    std::vector&lt;int&gt; tab;\n    auto gethash = [&amp;](int i, int l, int r, bool t) -&gt; ll &#123;\n        if (l &gt; r) return 0;\n        ll res = (h[t][i][r] - (l ? h[t][i][l - 1] : 0) * base[r - l + 1] % mod);\n        return (res % mod + mod) % mod;\n    &#125;;\n    // ll now = 0;\n    // for (int i = 0; i &lt;= 4; ++i)\n    //     now = (now * p + s[1][i]) % mod;\n    // printf(&quot;now = %lld\\n&quot;, now);\n    // now = 0;\n    // for (int i = 3; i &lt;= 7; ++i)\n    //     now = (now * p + s[0][i]) % mod;\n    // printf(&quot;now = %lld\\n&quot;, now);\n    // printf(&quot;# %lld\\n&quot;, h[0][0].back());\n    for (int i = 0; i &lt; n; ++i) &#123;\n        tab.push_back(i);\n        for (int j = 0; j &lt; n; ++j)\n            if (!del[j] &amp;&amp; i != j)\n                for (int k = 0; k &lt;= ((int)s[j].length()) - ((int)s[i].length()); ++k) &#123;\n                    // printf(&quot;i = %d, j = %d, k = %d, %lld / %lld\\n&quot;, i, j, k,\n                    //         gethash(i, 0, ((int)s[i].length()) - 1, 0), gethash(j, k, k + ((int)s[i].length()) - 1, 0));\n                    if (h[0][i].back() == gethash(j, k, k + ((int)s[i].length()) - 1, 0)) &#123;\n                        tab.pop_back();\n                        del[i] = 1;\n                        goto outo;\n                    &#125;\n                &#125;\n        outo: ;\n    &#125;\n    n = (int)tab.size();\n    if (n == 1) &#123;\n        int border;\n        for (border = ((int)s[tab[0]].length()) - 1; ~border; --border) &#123;\n            if (gethash(tab[0], 0, border - 1, 0) == gethash(tab[0], ((int)s[tab[0]].length()) - border, ((int)s[tab[0]].length()) - 1, 0))\n                break;\n        &#125;\n        std::cout &lt;&lt; std::max(2, ((int)s[tab[0]].length()) - border) &lt;&lt; &#39;\\n&#39;;\n    &#125;\n    else &#123;\n        static int mx[maxn][maxn][2][2];\n        for (int i = 0; i &lt; n; ++i)\n            for (int j = 0; j &lt; n; ++j)\n                for (int a = 0; a &lt; 2; ++a)\n                    for (int b = 0; b &lt; 2; ++b)\n                        for (int k = std::min((int)s[tab[i]].length(), (int)s[tab[j]].length()); ~k; --k) &#123;\n                            if (gethash(tab[i], ((int)s[tab[i]].length()) - k, ((int)s[tab[i]].length()) - 1, a) ==\n                                                                                            gethash(tab[j], 0, k - 1, b)) &#123;\n                                mx[i][j][a][b] = (int)s[tab[j]].length() - k;\n                                // printf(&quot;%d(%d) + %d(%d) = %d, k = %d\\n&quot;, i, a, j, b, mx[i][j][a][b], k);\n                                break;\n                            &#125;\n                        &#125;\n        static int f[maxm][maxn][2];\n        memset(f, 0x3f, sizeof (f));\n\n        int siz = 1 &lt;&lt; n, res = inf;\n        f[1][0][0] = (int)s[tab[0]].length();\n        for (int i = 1; i &lt; siz; ++i)\n            for (int j = 0; j &lt; n; ++j)\n                if (i &amp; (1 &lt;&lt; j))\n                    for (int a = 0; a &lt; 2; ++a) &#123;\n                        // printf(&quot;f[%d][%d][%d] = %d\\n&quot;, i, j, a, f[i][j][a]);\n                        for (int k = 0; k &lt; n; ++k)\n                            if (!(i &amp; (1 &lt;&lt; k)))\n                                for (int b = 0; b &lt; 2; ++b)\n                                    f[i | (1 &lt;&lt; k)][k][b] = std::min(f[i | (1 &lt;&lt; k)][k][b], f[i][j][a] + mx[j][k][a][b]);\n                        if (i == siz - 1)\n                            res = std::min(res, f[i][j][a] - (int)s[tab[0]].length() + mx[j][0][a][0]);\n                    &#125;\n        \n        std::cout &lt;&lt; std::max(2, res) &lt;&lt; &#39;\\n&#39;;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"a.-捏斑马\">A. 捏斑马</h3>\n<p><a href=\"http://222.180.160.110:61235/contest/5175/problem/1\" class=\"uri\">http://222.180.160.110:61235/contest/5175/problem/1</a></p>\n<p>我甚至不会（）</p>\n<p>翻转 + 拼接本质上就是首尾相接。我们把字符串整个拼到自己后边儿，然后任取一段长度为 <span class=\"math inline\">\\(n\\)</span> 的串就可以得到一个倒过来的操作后的字符串。</p>\n<p>注意到可以操作很多次。但是既然我们操作后的串也可以在这个拼接后的串中找到了，那么其实多次操作后的也行。</p>\n<p>所以呢我们在拼接后的串种枚举每一个长度为 <span class=\"math inline\">\\(n\\)</span> 的串计算答案即可。</p>\n<p>具体怎么算呢？注意到只看开头，也就是在新串中只看离我们当前枚举的右端点最近的那一段，所以我们打一个双指针，看这一段是否在右移后仍然合法，如果非法就把答案区间左端点更新为右端点自己。以及注意到左右端点的距离不能超过 <span class=\"math inline\">\\(n\\)</span>。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint res;\nstd::string s;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    std::cout.tie(nullptr);\n#endif\n    std::cin &gt;&gt; s;\n    int l = 0, r = -1, n = (int)s.length();\n    char la = 0;\n    s += s;\n    while (++r &lt; (int)s.length()) &#123;\n        if (s[r] == la)\n            l = r;\n        while (r - l + 1 &gt; n) ++l;\n        la = s[r];\n        res = std::max(res, r - l + 1);\n    &#125;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"d.-链状闪电\">D. 链状闪电</h3>\n<p><a href=\"http://222.180.160.110:61235/contest/5175/problem/4\" class=\"uri\">http://222.180.160.110:61235/contest/5175/problem/4</a></p>\n<p>莫名其妙且又臭又长的根号做法。</p>\n<p>容易发现一个怪被杀掉了序列就会裂开成两段连续子序列，以及最先被杀掉的怪物一定血量最少。在裂开来的两段连续子序列中也满足此规律，以此类推。</p>\n<p>考虑对序列建立笛卡尔树。令树根为 <span class=\"math inline\">\\(rt\\)</span>，当前攻击力为 <span class=\"math inline\">\\(k\\)</span>，记 <span class=\"math inline\">\\(t_{x, k}=\\left\\lceil \\dfrac {h_x}k \\right\\rceil\\)</span>，即不考虑其他条件时击倒 <span class=\"math inline\">\\(x\\)</span> 所需次数。</p>\n<p>那么对于 <span class=\"math inline\">\\(rt\\)</span> 的左、右儿子 <span class=\"math inline\">\\(l,r\\)</span>，单考虑这三个怪物所需的总击倒次数，容易发现为 <span class=\"math inline\">\\(t_{rt,k}+(t_{l,k}-t_{rt,k})+(t_{r,k}-t_{rt,k})\\)</span>。</p>\n<p>对于 <span class=\"math inline\">\\(l\\)</span> 引导的子树，此时的实际已攻击次数为 <span class=\"math inline\">\\(t_{l,k}\\)</span>；所以对于 <span class=\"math inline\">\\(l\\)</span> 的左右儿子 <span class=\"math inline\">\\(l&#39;,r&#39;\\)</span>，击倒这两个怪物的所需次数为 <span class=\"math inline\">\\((t_{l&#39;,k} - t_{l,k})+(t_{r&#39;,k}-t_{l,k})\\)</span>。<span class=\"math inline\">\\(r\\)</span> 引导的子树同理。</p>\n<p>所以我们就可以知道，如果存在树边 <span class=\"math inline\">\\(u\\to v\\)</span>，那么击倒 <span class=\"math inline\">\\(v\\)</span> 的所需次数为 <span class=\"math inline\">\\(t_{v,k}-t_{u,k}\\)</span>；特别地，击倒 <span class=\"math inline\">\\(rt\\)</span> 的所需次数为 <span class=\"math inline\">\\(t_{rt,k}\\)</span>。</p>\n<p>那么我们就可以通过一次 <span class=\"math inline\">\\(O(n)\\)</span> 的树上 DFS 对于一个 <span class=\"math inline\">\\(k\\)</span> 找到答案了。</p>\n<p>那么对于 <span class=\"math inline\">\\(2\\times 10^4\\)</span> 范围内的所有 <span class=\"math inline\">\\(k\\)</span>，应该怎么办呢？这个时候就要利用 <span class=\"math inline\">\\(t\\)</span> 的性质进行根号分治了。</p>\n<ul>\n<li><p>对于 <span class=\"math inline\">\\(k\\le \\sqrt {2\\times 10^4}\\)</span>，我们大可以直接做这么多次 DFS 得到答案；</p></li>\n<li><p>对于 <span class=\"math inline\">\\(k&gt;\\sqrt {2\\times 10^4}\\)</span>：</p>\n<p>我们容易发现最终的结果是若干个 <span class=\"math inline\">\\(t\\)</span> 的值相加减得到的，而每个 <span class=\"math inline\">\\(t\\)</span> 的权值 <span class=\"math inline\">\\(cnt\\)</span> 取决于其在笛卡尔树上的儿子个数，有多少就在 <span class=\"math inline\">\\(1\\)</span> 的基础上减去多少。</p>\n<p>由于 <span class=\"math inline\">\\(t\\)</span> 实在过于特殊，考虑整除分块 / 数论分块。对于每个 <span class=\"math inline\">\\(x\\)</span>，对于任意 <span class=\"math inline\">\\(k&#39;\\in (\\sqrt {2\\times 10^4}, 2\\times 10^4]\\)</span>，可能的 <span class=\"math inline\">\\(t\\)</span> 值只有 <span class=\"math inline\">\\(\\sqrt {2\\times 10^4 }\\)</span> 种。计算出对于每个 <span class=\"math inline\">\\(t&#39;\\)</span>，满足 <span class=\"math inline\">\\(\\left\\lceil \\dfrac {h_x}{k&#39;} \\right\\rceil=t&#39;\\)</span> 的 <span class=\"math inline\">\\(k&#39;\\)</span> 范围，对该范围 <span class=\"math inline\">\\(k&#39;\\)</span> 的答案区间加上 <span class=\"math inline\">\\(t&#39;\\times cnt\\)</span> 即可，可以使用差分。</p>\n<p>至此，就可以在一次 DFS 内解决这种情况下的问题。</p></li>\n</ul>\n<p>总时间复杂度为 <span class=\"math inline\">\\(O(n\\sqrt {2\\times 10^4})\\)</span>。</p>\n<details>\n<p>值得注意的是，我在做这道题的时候并没有意识到自己用到了笛卡尔树，</p>\n<p>所以代码中笛卡尔树的建树部分可能长得特别抽象（</p>\n<p>这里是使用了下标上的 ST 表带 log 地求解了左右儿子。</p>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxm = 35;\nconst int maxn = 1e5 + 5;\nusing ll = long long;\nll res;\nint n, k, l;\nint g[maxn][2];\nint f[maxn][maxm];\nint a[maxn], t[maxn];\nll dif[maxn], cnt[maxn];\nint ask(int l, int r) &#123;\n    if (l &gt; r) return 0;\n    int k = log(r - l + 1) / log(2.0);\n    return (a[f[l][k]] &lt; a[f[r - (1 &lt;&lt; k) + 1][k]]) ? f[l][k] : f[r - (1 &lt;&lt; k) + 1][k];\n&#125;\nvoid bld(int rt, int l, int r) &#123;\n    if (rt != l) &#123;\n        g[rt][0] = ask(l, rt - 1);\n        bld(g[rt][0], l, rt - 1);\n    &#125;\n    if (rt != r) &#123;\n        g[rt][1] = ask(rt + 1, r);\n        bld(g[rt][1], rt + 1, r);\n    &#125;\n    return;\n&#125;\n// k &lt;= sqrt(lim)\nvoid DFS(int x, int k, int fa) &#123;\n    t[x] = (a[x] + k - 1) / k;\n    res += t[x] - t[fa];\n    for (int i = 0; i &lt; 2; ++i) &#123;\n        if (g[x][i])\n            DFS(g[x][i], k, x);\n    &#125;\n    return;\n&#125;\n// k &gt; sqrt(lim)\nvoid DFS(int x, int fa) &#123;\n    ++cnt[x];\n    --cnt[fa];\n    for (int i = 0; i &lt; 2; ++i) &#123;\n        if (g[x][i])\n            DFS(g[x][i], x);\n    &#125;\n    int l = k + 1, r;\n    // 注意这里 i 的范围判定，如果直接写成 i * i &lt;= k 会少计算一些情况\n    for (int i = 1; (i - 1) * (i - 1) &lt; k; ++i) &#123;\n        r = l - 1;\n        l = (a[x] + i - 1) / i;\n        // fprintf(stderr, &quot;%d: [%d, %d] += %d * %d\\n&quot;, a[x], l, r, cnt[x], i);\n        dif[l] += i * cnt[x], dif[r + 1] -= i * cnt[x];\n    &#125;\n    return;\n&#125;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    std::cout.tie(nullptr);\n#endif\n    std::cin &gt;&gt; n;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; a[i];\n        f[i][0] = i;\n        k = std::max(k, a[i]);\n    &#125;\n    for (int j = 1; (1 &lt;&lt; j) &lt;= n; ++j)\n        for (int i = 1; i + (1 &lt;&lt; j) - 1 &lt;= n; ++i)\n            f[i][j] = (a[f[i][j - 1]] &lt; a[f[i + (1 &lt;&lt; (j - 1))][j - 1]]) ? f[i][j - 1] : f[i + (1 &lt;&lt; (j - 1))][j - 1];\n    int rt = ask(1, n);\n    bld(rt, 1, n);\n    for (int i = 1; i * i &lt;= k; ++i) &#123;\n        res = 0;\n        DFS(rt, i, 0);\n        std::cout &lt;&lt; res &lt;&lt; &#39; &#39;;\n        l = i + 1;\n    &#125;\n    // fputs(&quot;\\n&quot;, stderr);\n    DFS(rt, 0);\n    std::partial_sum(dif + 1, dif + k + 1, dif + 1);\n    for (int i = l; i &lt;= k; ++i)\n        std::cout &lt;&lt; dif[i] &lt;&lt; &#39; &#39;;\n    std::cout &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"f.-弹飞绵羊\">F. 弹飞绵羊</h3>\n<p><a href=\"http://222.180.160.110:61235/contest/5175/problem/6\" class=\"uri\">http://222.180.160.110:61235/contest/5175/problem/6</a></p>\n<p>很棒可持久化分块，使我 lxl 旋转。</p>\n<p>笑话：赛后 5s 才交上去。然后 A 了。</p>\n<p>我们猜大家都会普通的弹飞绵羊这道题。就是块间暴力跳嘛。</p>\n<p>这里给一个我自己整的简单实现方法。</p>\n<p>我们把分出来的块视作若干个无关联的散块并纳入块集合；对于每一个版本，用一个大小为 <span class=\"math inline\">\\(\\sqrt n\\)</span> 的 <span class=\"math inline\">\\(id\\)</span> 数组记录每一位置的块在块集合中对应的位置。</p>\n<p>然后该怎么搞怎么搞即可。</p>\n<p>P.S. zwb 坚定不移信仰 lxl 神教于是决定用可持久化平衡树实现可持久化分块，结果当然是因为多了个 <span class=\"math inline\">\\(\\log\\)</span> 被卡飞了，最后气急败坏慌不择路恼羞成怒抄起了我的代码。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxk = 320;\nconst int maxn = 2e5 + 5;\nclass devicer &#123;\npublic:\n    int l, r;\n    std::vector&lt;int&gt; ne, u, a;\n    int &amp;nex(int x);\n    int &amp;val(int x);\n&#125;;\nint id[maxn][maxk];\nstd::vector&lt;devicer&gt; b;\nint n, q, ty, siz, k, la;\nint a[maxn], tab[maxn], blk[maxn];\nvoid upd(int x, int a, devicer &amp;p) &#123;\n    if (x + a &gt; n)\n        p.nex(x) = -1, p.val(x) = 1;\n    else if (x + a &gt; p.r)\n        p.nex(x) = x + a, p.val(x) = 1;\n    else\n        p.nex(x) = p.nex(x + a), p.val(x) = p.val(x + a) + 1;\n    // printf(&quot;x = %d, a = %d, r = %d, upd ne[%d] to %d\\n&quot;, x, a, p.r, x, p.nex(x));\n    return;\n&#125;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    std::cout.tie(nullptr);\n#endif\n    std::cin &gt;&gt; n &gt;&gt; q &gt;&gt; ty;\n    siz = sqrt(n);\n    k = (n + siz - 1) / siz;\n    b.resize(k);\n    int la = 0, now = k - 1;\n    for (auto &amp;i : b)\n        i.l = la + 1, la = i.r = i.l + siz - 1;\n    b.back().r = n;\n    for (int i = 0; i &lt; k; ++i) &#123;\n        id[0][i] = i;\n        b[i].a.resize(b[i].r - b[i].l + 1);\n        b[i].u.resize(b[i].r - b[i].l + 1);\n        b[i].ne.resize(b[i].r - b[i].l + 1);\n        for (int j = b[i].l; j &lt;= b[i].r; ++j)\n            tab[j] = j - b[i].l, blk[j] = i;\n    &#125;\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; b[blk[i]].a[tab[i]];\n    for (int i = n; i; --i)\n        upd(i, b[blk[i]].a[tab[i]], b[blk[i]]);\n    int ver = 0;\n    while (q--) &#123;\n        int op, pr, x;\n        static int res = 0;\n        std::cin &gt;&gt; op &gt;&gt; pr &gt;&gt; x;\n        if (!ty)\n            res = 0;\n        x ^= res;\n        if (op == 1) &#123;\n            std::copy(id[pr], id[pr] + k, id[++ver]);\n            b.push_back(b[id[ver][blk[x]]]);\n            id[ver][blk[x]] = ++now;\n            std::cin &gt;&gt; b.back().a[tab[x]];\n            b.back().a[tab[x]] ^= res;\n            for (int i = x; i &gt;= b.back().l; --i)\n                upd(i, b.back().a[tab[i]], b.back());\n        &#125;\n        else &#123;\n            int p = x;\n            res = 0;\n            while (~p) &#123;\n                // printf(&quot;p = %d\\n&quot;, p);\n                res += b[id[pr][blk[p]]].u[tab[p]];\n                p = b[id[pr][blk[p]]].ne[tab[p]];\n            &#125;\n            std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n        &#125;\n    &#125;\n    return 0;\n&#125;\nint&amp; devicer::nex(int x) &#123;\n    return ne[tab[x]];\n&#125;\nint&amp; devicer::val(int x) &#123;\n    return u[tab[x]];\n&#125;</code></pre>\n</details>\n",
            "tags": [
                "DP",
                "SAM",
                "状压",
                "分块",
                "可持久化",
                "笛卡尔树"
            ]
        }
    ]
}