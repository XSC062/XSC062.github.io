<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://xsc062.netlify.app</id>
    <title> • Posts by &#34;字典树&#34; tag</title>
    <link href="https://xsc062.netlify.app" />
    <updated>2025-08-09T04:33:17.000Z</updated>
    <category term="并查集" />
    <category term="斜率优化" />
    <category term="悬线法" />
    <category term="哈希" />
    <category term="字典树" />
    <category term="DP" />
    <category term="单调队列" />
    <category term="分治" />
    <category term="二分图" />
    <category term="CRT / exCRT" />
    <category term="排列组合" />
    <category term="网络流" />
    <category term="费用流" />
    <category term="二分" />
    <category term="上下界网络流" />
    <category term="容斥原理" />
    <category term="线段树" />
    <category term="树状数组" />
    <category term="区间 DP" />
    <category term="构造" />
    <category term="Tarjan" />
    <category term="数据结构" />
    <category term="下饭" />
    <category term="LCA" />
    <category term="倍增" />
    <category term="鸽巢原理" />
    <category term="概率期望" />
    <category term="调和级数" />
    <category term="差分" />
    <category term="思维" />
    <category term="树形 DP" />
    <category term="最小生成树" />
    <category term="SAM" />
    <category term="状压" />
    <category term="分块" />
    <category term="可持久化" />
    <category term="笛卡尔树" />
    <category term="高维前缀和" />
    <category term="闲话" />
    <category term="欧拉回路" />
    <category term="树链剖分" />
    <category term="长链剖分" />
    <category term="KMP" />
    <category term="border" />
    <category term="字符串" />
    <category term="AC 自动机" />
    <category term="SA" />
    <category term="数学" />
    <category term="树上差分" />
    <category term="FWT" />
    <category term="堆" />
    <category term="树的重心" />
    <category term="二项式定理" />
    <category term="二项式反演" />
    <category term="贪心" />
    <category term="均摊" />
    <category term="计数" />
    <category term="优化建图" />
    <category term="反悔贪心" />
    <category term="调整法" />
    <category term="背包" />
    <category term="博弈论" />
    <category term="DP 优化" />
    <category term="虚树" />
    <category term="点分治" />
    <category term="WQS 二分" />
    <category term="闵可夫斯基和" />
    <category term="slope trick" />
    <category term="四边形不等式" />
    <category term="暴力" />
    <category term="状压 DP" />
    <category term="组合数学" />
    <category term="支配对" />
    <category term="DDP" />
    <category term="平衡树" />
    <category term="容斥" />
    <category term="猫树" />
    <category term="Kruskal 重构树" />
    <category term="李超线段树" />
    <entry>
        <id>https://xsc062.netlify.app/20250809/</id>
        <title>近期杂题</title>
        <link rel="alternate" href="https://xsc062.netlify.app/20250809/"/>
        <content type="html">&lt;p&gt;这段时间比赛的一些题 和 nKessi、duanyu 讲的题目。太偏计数、数学的基本上没办法做了。&lt;/p&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;a.-出关&#34;&gt;A. 出关&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://222.180.160.110:61235/contest/6462/problem/1&#34; class=&#34;uri&#34;&gt;http://222.180.160.110:61235/contest/6462/problem/1&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定 &lt;span class=&#34;math inline&#34;&gt;\(s\)&lt;/span&gt;，对于一个空串，任意利用下列三种操作，使其变为 &lt;span class=&#34;math inline&#34;&gt;\(s\)&lt;/span&gt;，求最小代价：&lt;/p&gt;
&lt;ol type=&#34;1&#34;&gt;
&lt;li&gt;在末尾添加字符 &lt;span class=&#34;math inline&#34;&gt;\(c\)&lt;/span&gt;，代价为 &lt;span class=&#34;math inline&#34;&gt;\(t_{0,c}\)&lt;/span&gt;；&lt;/li&gt;
&lt;li&gt;复制整个字符串并粘贴在末尾，代价为 &lt;span class=&#34;math inline&#34;&gt;\(t_1\)&lt;/span&gt;；&lt;/li&gt;
&lt;li&gt;删除末尾字符，代价为 &lt;span class=&#34;math inline&#34;&gt;\(t_2\)&lt;/span&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(|s|\le 10^6\)&lt;/span&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可以预处理出对于每个 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 结尾，最多可以复制到哪个地方，发现要求 &lt;span class=&#34;math inline&#34;&gt;\(z_i=lcp(s_{1\dots n},s_{i+1\dots n})\)&lt;/span&gt;。那么一个 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 的最远转移点 &lt;span class=&#34;math inline&#34;&gt;\(r_i=i+z_{i+1}\)&lt;/span&gt;，用单调队列就能维护，会 exkmp 就能线性；&lt;/p&gt;
&lt;p&gt;否则可以二分 + 哈希多个 log，后面也有理由偷懒用优先队列了。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int p = 31;
const int mod = 998244353;
int main() &amp;#123;
    std::freopen(&amp;quot;laozi.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;laozi.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
    std::string s;
    std::cin &amp;gt;&amp;gt; s;
    int n = (int)s.length(), t1, t2;
    std::vector&amp;lt;long long&amp;gt; h(n + 1), base(n + 1);
    std::vector&amp;lt;int&amp;gt; a(n + 1), t0(27), z(n + 1), r(n + 1);
    base[0] = 1ll;
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        a[i] = s[i - 1] - &amp;#39;a&amp;#39; + 1;
        h[i] = (h[i - 1] * p + a[i]) % mod;
        base[i] = base[i - 1] * p % mod;
    &amp;#125;
    auto gethash = [&amp;amp;](int l, int r) &amp;#123;
        return (h[r] - h[l - 1] * base[r - l + 1] % mod + mod) % mod;
    &amp;#125;;
    for (int i = 1; i &amp;lt;= n; ++i)
        for (int l = 1, r = std::min(i - 1, n - i + 1), mid; l &amp;lt;= r; ) &amp;#123;
            mid = (l + r) &amp;gt;&amp;gt; 1;
            if (gethash(1, mid) == gethash(i, i + mid - 1))
                z[i] = mid, l = mid + 1;
            else
                r = mid - 1;
        &amp;#125;
    for (int i = 1; i &amp;lt; n; ++i)
        r[i] = i + std::min(i, z[i + 1]);
    for (int i = 1; i &amp;lt;= 26; ++i)
        std::cin &amp;gt;&amp;gt; t0[i];
    std::cin &amp;gt;&amp;gt; t1 &amp;gt;&amp;gt; t2;
    std::vector&amp;lt;long long&amp;gt; f(n + 1);
    std::priority_queue&amp;lt;std::pair&amp;lt;long long, int&amp;gt; &amp;gt; q;
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        f[i] = f[i - 1] + t0[a[i]];
        for (; !q.empty() &amp;amp;&amp;amp; r[q.top().second] &amp;lt; i; q.pop());
        if (!q.empty())
            f[i] = std::min(f[i], t1 - q.top().first - (long long)t2 * i);
        if (i != n)
            q.emplace(-(f[i] + 2ll * t2 * i), i);
    &amp;#125;
    std::cout &amp;lt;&amp;lt; f[n] &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;d.-非攻&#34;&gt;D. 非攻&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://222.180.160.110:61235/contest/6462/problem/4&#34; class=&#34;uri&#34;&gt;http://222.180.160.110:61235/contest/6462/problem/4&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定 &lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt;，对于一个 &lt;span class=&#34;math inline&#34;&gt;\(1\sim n\)&lt;/span&gt; 的排列，使用最小的交换次数使得其单增。在该前提下，定义代价为每次交换的两个数之积。对于所有 &lt;span class=&#34;math inline&#34;&gt;\(n!\)&lt;/span&gt; 个排列，计算最小代价之和。&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(n\le 10^7\)&lt;/span&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;转化成，把 &lt;span class=&#34;math inline&#34;&gt;\(1\sim n\)&lt;/span&gt; 分成无标号的若干组，每组的代价是 最小值 &lt;span class=&#34;math inline&#34;&gt;\(\times\)&lt;/span&gt; 其他元素的和，还有一个项链问题的系数，发现组间的符号是求和，考虑计算贡献。&lt;/p&gt;
&lt;p&gt;枚举 &lt;span class=&#34;math inline&#34;&gt;\(i,j\)&lt;/span&gt; 并钦定两个同属一个环，且 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 为最小值，枚举环大小 &lt;span class=&#34;math inline&#34;&gt;\(s+2\)&lt;/span&gt;，那么有：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
\begin{aligned}
res&amp;amp;=\sum_{i=1}^{n-1}\sum_{j=i+1}^n i\cdot j \cdot \sum_{s=0}^{n-i-1}\binom{n-i-1}s \cdot (s+1)!\cdot (n-s-2)!\\
&amp;amp;=\sum_{i=1}^{n-1}i\cdot \dfrac {(i+n+1)(n-i)}2 \cdot \sum_{s=0}^{n-i-1}\binom{n-i-1}s\cdot (s+1)!\cdot (n-s-2)!\\
&amp;amp;=\frac 12\times\sum_{i=1}^{n-1}i\cdot (i+n+1)\cdot (n-i)!\cdot\sum_{s=0}^{n-i-1}\dfrac {(s + 1)\cdot (n-s-2)!}{(n-i-1-s)!}\\
\end{aligned}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;令 &lt;span class=&#34;math inline&#34;&gt;\(T=n-i-1\)&lt;/span&gt;，发现我们需要快速计算 &lt;span class=&#34;math inline&#34;&gt;\(f_T=\sum\limits_{i=0}^T \dfrac{(i+1)\cdot (n-i-2)!}{(T-i)!}\)&lt;/span&gt;。记 &lt;span class=&#34;math inline&#34;&gt;\(m=n-2\)&lt;/span&gt;，变形得 &lt;span class=&#34;math inline&#34;&gt;\(f_T=(m-T)!\cdot \sum\limits_{i=0}^{T} (i+1) \binom{m-i}{m-T}\)&lt;/span&gt;，发现似乎可以简化，令 &lt;span class=&#34;math inline&#34;&gt;\(k=m-T,t=T+1\)&lt;/span&gt;，则 &lt;span class=&#34;math inline&#34;&gt;\(f_T=\sum\limits_{i=1}^T i\cdot \binom {k+t-i}k\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;然后是经典的组合意义保平安环节，即从 &lt;span class=&#34;math inline&#34;&gt;\(k+t\)&lt;/span&gt; 个有标号小球中选择一条分界线，分界线左边选一个球、右边选 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 个球的方案数。发现分界线的存在很诡异，故用分界线后方的第一个球代替，在 &lt;span class=&#34;math inline&#34;&gt;\(t+1\)&lt;/span&gt; 处新建一个虚球，规定在前 &lt;span class=&#34;math inline&#34;&gt;\(t+1\)&lt;/span&gt; 个球中选两个球，并令后一个为分界线，且令前 &lt;span class=&#34;math inline&#34;&gt;\(t+1\)&lt;/span&gt; 个中的其他球为实球，就能建立双射。在分界线后再选 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 个球，容易发现直接在范围内选 &lt;span class=&#34;math inline&#34;&gt;\(k+2\)&lt;/span&gt; 个球就能满足条件，故 &lt;span class=&#34;math inline&#34;&gt;\(f_T=(n-T-2)!\cdot \binom{t+k+1}{k+2}\)&lt;/span&gt;。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int mod = 1e9 + 7;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
    std::freopen(&amp;quot;mozi.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;mozi.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#endif
    int n;
    std::cin &amp;gt;&amp;gt; n;
    std::vector&amp;lt;long long&amp;gt; fac(n + 1), inv(n + 1), f(n + 1);
    fac[0] = inv[0] = 1ll;
    for (int i = 1; i &amp;lt;= n; ++i)
        fac[i] = fac[i - 1] * i % mod;
    auto qkp = [&amp;amp;](long long x, int y) &amp;#123;
        auto res(1ll);
        for (; y; (x *= x) %= mod, y &amp;gt;&amp;gt;= 1)
            if (y &amp;amp; 1)
                (res *= x) %= mod;
        return res;
    &amp;#125;;
    inv[n] = qkp(fac[n], mod - 2);
    for (int i = n - 1; i; --i)
        inv[i] = inv[i + 1] * (i + 1) % mod;
    auto C = [&amp;amp;](int n, int m) &amp;#123;
        return fac[n] * inv[n - m] % mod * inv[m] % mod;
    &amp;#125;;
    int m = n - 2;
    for (int T = 0; T &amp;lt;= n - 2; ++T) &amp;#123;
        int k = m - T, t = T + 1;
        f[T] = C(t + k + 1, k + 2) * fac[m - T] % mod;
    &amp;#125;
    auto res = 0ll;
    for (int i = 1; i &amp;lt;= n - 1; ++i)
        (res += (long long)i * (i + n + 1) % mod * fac[n - i] % mod * f[n - i - 1] % mod) %= mod;
    std::cout &amp;lt;&amp;lt; res * inv[2] % mod &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;c---destruction-of-walls&#34;&gt;C - Destruction of Walls&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/arc203/tasks/arc203_c&#34; class=&#34;uri&#34;&gt;https://atcoder.jp/contests/arc203/tasks/arc203_c&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;d---insert-xor&#34;&gt;D - Insert XOR&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/arc203/tasks/arc203_d&#34; class=&#34;uri&#34;&gt;https://atcoder.jp/contests/arc203/tasks/arc203_d&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;a---记忆&#34;&gt;A - 记忆&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://ac.nowcoder.com/acm/problem/274793&#34; class=&#34;uri&#34;&gt;https://ac.nowcoder.com/acm/problem/274793&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;需要意识到问题是静态的，并且不能用线段树之类维护；故考虑离线下来，想办法在 LCA 处统计答案。&lt;/p&gt;
&lt;p&gt;这个时候发现需要合并子树状态、整体异或、整体 +1，很容易想到 Trie。把 &lt;span class=&#34;math inline&#34;&gt;\(u\to\)&lt;/span&gt; LCA 的答案保存在 LCA 处，然后再用 DFS + 回溯统计 LCA &lt;span class=&#34;math inline&#34;&gt;\(\to v\)&lt;/span&gt; 的答案。想了半天没想到把上下拆开来做也是神了 😅&lt;/p&gt;
&lt;p&gt;可能比较考验对字典树的理解？做个比喻，字典树的 id 就相当于对这个点上信息的『引用』。&lt;/p&gt;
&lt;details&gt;
&lt;p&gt;字典树合并的时候可以考虑回收废弃点，不然可能有点卡。&lt;/p&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int X = 50;
const int maxn = 2e7 + 5;
long long d[maxn];
int tot, T[maxn][2], f[maxn], fa[maxn];
#define lc(p) T[p][0]
#define rc(p) T[p][1]
int find(int x) &amp;#123; return x == f[x] ? x : f[x] = find(f[x]); &amp;#125;
int newnode(void) &amp;#123;
    int p = ++tot;
    assert(p &amp;lt; maxn);
    d[p] = lc(p) = rc(p) = 0, f[p] = p;
    return p;
&amp;#125;
void pushdown(int p) &amp;#123;
    if (d[p]) &amp;#123;
        if (d[p] &amp;amp; 1)
            std::swap(lc(p), rc(p));
        d[p] &amp;gt;&amp;gt;= 1;
        if (lc(p))
            d[lc(p)] ^= d[p];
        if (rc(p))
            d[rc(p)] ^= d[p];
        d[p] = 0;
    &amp;#125;
    return;
&amp;#125;
int ins(int p, long long x) &amp;#123;
    for (int i = 0; i &amp;lt; X; ++i) &amp;#123;
        pushdown(p);
        if (!T[p][(x &amp;gt;&amp;gt; i) &amp;amp; 1]) &amp;#123;
            T[p][(x &amp;gt;&amp;gt; i) &amp;amp; 1] = newnode();
            fa[T[p][(x &amp;gt;&amp;gt; i) &amp;amp; 1]] = p;
        &amp;#125;
        p = T[p][(x &amp;gt;&amp;gt; i) &amp;amp; 1];
    &amp;#125;
    return p;
&amp;#125;
void merge(int &amp;amp;p, int q) &amp;#123;
    if (!q)
        return;
    if (!p) &amp;#123;
        p = q;
        return;
    &amp;#125;
    pushdown(p), pushdown(q);
    fa[lc(q)] = p, fa[rc(q)] = p;
    merge(lc(p), lc(q)), merge(rc(p), rc(q));
    assert(f[p] == p), assert(f[q] == q), f[q] = p;
    return;
&amp;#125;
long long ask(int p) &amp;#123;
    std::vector&amp;lt;int&amp;gt; st;
    for (int i = 0, j = p; i &amp;lt; X; ++i)
        st.push_back(fa[j]), j = fa[j];
    for (int i = 0; i &amp;lt; X; ++i)
        pushdown(st.back()), st.pop_back();
    long long x = 0;
    for (int i = 0; i &amp;lt; X; ++i) &amp;#123;
        x = x * 2 + (p == rc(fa[p]));
        p = fa[p];
    &amp;#125;
    return x;
&amp;#125;
void add(int p) &amp;#123;
    for (int i = 0; p &amp;amp;&amp;amp; i &amp;lt; X; ++i) &amp;#123;
        pushdown(p);
        std::swap(lc(p), rc(p));
        p = lc(p);
    &amp;#125;
    return;
&amp;#125;
void del(int p) &amp;#123;
    for (int i = 0; p &amp;amp;&amp;amp; i &amp;lt; X; ++i) &amp;#123;
        pushdown(p);
        std::swap(lc(p), rc(p));
        p = rc(p);
    &amp;#125;
    return;
&amp;#125;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#endif
    int n, m;
    std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
    std::vector&amp;lt;int&amp;gt; a(n + 1);
    for (int i = 1; i &amp;lt;= n; ++i)
        std::cin &amp;gt;&amp;gt; a[i];
    std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; g(n + 1);
    for (int i = 1, x, y; i &amp;lt; n; ++i) &amp;#123;
        std::cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; y;
        g[x].push_back(y), g[y].push_back(x);
    &amp;#125;
    std::vector&amp;lt;int&amp;gt; siz(n + 1), son(n + 1), top(n + 1), fa(n + 1), dep(n + 1);
    std::function&amp;lt;void(int)&amp;gt; DFS = [&amp;amp;](int x) &amp;#123;
        siz[x] = 1;
        for (auto i : g[x])
            if (i != fa[x]) &amp;#123;
                dep[i] = dep[x] + 1;
                fa[i] = x, DFS(i);
                siz[x] += siz[i];
                if (siz[i] &amp;gt; siz[son[x]])
                    son[x] = i;
            &amp;#125;
        return;
    &amp;#125;;
    DFS(1);
    DFS = [&amp;amp;](int x) &amp;#123;
        if (son[x])
            top[son[x]] = top[x], DFS(son[x]);
        for (auto i : g[x])
            if (i != son[x] &amp;amp;&amp;amp; i != fa[x])
                top[i] = i, DFS(i);
        return;
    &amp;#125;;
    top[1] = 1, DFS(1);
    auto askLCA = [&amp;amp;](int x, int y) &amp;#123;
        for (; top[x] != top[y]; x = fa[top[x]])
            if (dep[top[x]] &amp;lt; dep[top[y]])
                std::swap(x, y);
        return dep[x] &amp;lt; dep[y] ? x : y;
    &amp;#125;;
    struct node &amp;#123; long long x; int u, v; &amp;#125;;
    std::vector&amp;lt;node&amp;gt; q(m + 1);
    std::vector&amp;lt;int&amp;gt; id(m + 1);
    std::vector&amp;lt;long long&amp;gt; res(m + 1), ans(m + 1);
    std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; up(n + 1), dn(n + 1), ed(n + 1);
    for (int i = 1, x, u, v; i &amp;lt;= m; ++i) &amp;#123;
        std::cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; u &amp;gt;&amp;gt; v;
        q[i] = &amp;#123; x, u, v &amp;#125;;
        up[u].push_back(i), dn[askLCA(u, v)].push_back(i), ed[v].push_back(i);
    &amp;#125;
    std::vector&amp;lt;int&amp;gt; rt(n + 1);
    DFS = [&amp;amp;](int x) &amp;#123;
        rt[x] = newnode();
        for (auto i : g[x])
            if (i != fa[x]) &amp;#123;
                DFS(i);
                merge(rt[x], rt[i]);
            &amp;#125;
        add(rt[x]);
        for (auto i : up[x])
            id[i] = ins(rt[x], q[i].x);
        d[rt[x]] ^= a[x];
        for (auto i : dn[x])
            res[i] = ask(find(id[i]));
        return;
    &amp;#125;;
    DFS(1);
    tot = 0, rt[0] = newnode();
    std::fill(id.begin() + 1, id.end(), 0);
    DFS = [&amp;amp;](int x) &amp;#123;
        d[rt[0]] ^= a[x];
        for (auto i : dn[x])
            id[i] = ins(rt[0], res[i]);
        for (auto i : ed[x])
            ans[i] = ask(id[i]);
        add(rt[0]);
        for (auto i : g[x])
            if (i != fa[x])
                DFS(i);
        del(rt[0]);
        d[rt[0]] ^= a[x];
        return;
    &amp;#125;;
    DFS(1);
    for (int i = 1; i &amp;lt;= m; ++i)
        std::cout &amp;lt;&amp;lt; ans[i] &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;b---ビーバーの会合-2-meetings-2&#34;&gt;B - ビーバーの会合 2 (Meetings 2)&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/AT_joisc2021_j&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/AT_joisc2021_j&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;定义所求点为『局部重心』；类似树的重心，容易发现当关键点数量为奇时，只存在一个局部重心；否则，局部重心组成一条链。&lt;/p&gt;
&lt;p&gt;即对于每一个 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt;，需要找到一条最长链，使得其两端存在大小为 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 的子树（容易发现取后缀 max 即可得到真实答案）。使用点分治，精细实现容易做到 &lt;span class=&#34;math inline&#34;&gt;\(O(n\log n)\)&lt;/span&gt;。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#endif
    int n;
    std::cin &amp;gt;&amp;gt; n;
    std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; g(n + 1);
    for (int i = 1, x, y; i &amp;lt; n; ++i) &amp;#123;
        std::cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; y;
        g[x].push_back(y), g[y].push_back(x);
    &amp;#125;
    std::vector&amp;lt;int&amp;gt; mx(n + 1), siz(n + 1), p, tag(n + 1), res(n + 1, 1);
    std::function&amp;lt;void(int, int)&amp;gt; DFS1 = [&amp;amp;](int x, int fa) &amp;#123;
        p.push_back(x);
        siz[x] = 1, mx[x] = 0;
        for (auto i : g[x])
            if (!tag[i] &amp;amp;&amp;amp; i != fa) &amp;#123;
                DFS1(i, x);
                siz[x] += siz[i];
                mx[x] = std::max(mx[x], siz[i]);
            &amp;#125;
        return;
    &amp;#125;;
    auto findrt = [&amp;amp;](int x) &amp;#123;
        p.clear(), DFS1(x, -1);
        int n = (int)p.size();
        for (auto i : p)
            if (mx[i] &amp;lt;= n / 2 &amp;amp;&amp;amp; n - siz[i] &amp;lt;= n / 2)
                return i;
        assert(0);
        return -1;
    &amp;#125;;
    struct node &amp;#123;
        int u1, u2, id1, id2;
        node(): u1(0), u2(0), id1(0), id2(0) &amp;#123;&amp;#125;
        void upd(int u, int id) &amp;#123;
            if (id1 == id)
                u1 = std::max(u1, u);
            else if (u &amp;gt;= u1)
                u2 = u1, id2 = id1, u1 = u, id1 = id;
            else if (u &amp;gt;= u2)
                u2 = u, id2 = id;
            return;
        &amp;#125;
    &amp;#125;;
    std::vector&amp;lt;node&amp;gt; s(n + 1);
    std::function&amp;lt;void(int, int, int, int)&amp;gt; DFS2 = [&amp;amp;](int x, int fa, int dep, int anc) &amp;#123;
        s[siz[x]].upd(dep, anc);
        for (auto i : g[x])
            if (!tag[i] &amp;amp;&amp;amp; i != fa)
                DFS2(i, x, dep + 1, anc);
        return;
    &amp;#125;;
    std::function&amp;lt;void(int, int, int, int)&amp;gt; DFS3 = [&amp;amp;](int x, int fa, int dep, int anc) &amp;#123;
        int v = ((s[siz[x]].id1 == anc) ? s[siz[x]].u2 : s[siz[x]].u1);
        res[2 * siz[x]] = std::max(res[2 * siz[x]], dep + 1 + v);
        for (auto i : g[x])
            if (!tag[i] &amp;amp;&amp;amp; i != fa)
                DFS3(i, x, dep + 1, anc);
        return;
    &amp;#125;;
    std::function&amp;lt;void(int)&amp;gt; DFS = [&amp;amp;](int x) &amp;#123;
        x = findrt(x), p.clear(), DFS1(x, -1);
        // printf(&amp;quot;rt = %d\n&amp;quot;, x);
        for (auto i : g[x])
            if (!tag[i])
                DFS2(i, x, 1, i);
        for (int i = siz[x] - 1; i; --i) &amp;#123;
            s[i].upd(s[i + 1].u1, s[i + 1].id1);
            s[i].upd(s[i + 1].u2, s[i + 1].id2);
        &amp;#125;
        for (auto i : g[x])
            if (!tag[i])
                DFS3(i, x, 1, i);
        tag[x] = 1;
        for (int i = 1; i &amp;lt; siz[x]; ++i)
            s[i] = node();
        for (auto i : g[x])
            if (!tag[i])
                DFS(i);
        return;
    &amp;#125;;
    DFS(1);
    for (int i = (n &amp;gt;&amp;gt; 1) * 2; i; --i)
        if (i + 2 &amp;lt;= n)
            res[i] = std::max(res[i], res[i + 2]);
    for (int i = 1; i &amp;lt;= n; ++i)
        std::cout &amp;lt;&amp;lt; res[i] &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;c---the-closest-pair&#34;&gt;C - The Closest Pair&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://ac.nowcoder.com/acm/problem/262593&#34; class=&#34;uri&#34;&gt;https://ac.nowcoder.com/acm/problem/262593&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;常规方法&lt;/strong&gt;：考虑&lt;strong&gt;支配对&lt;/strong&gt;，对于每个 &lt;span class=&#34;math inline&#34;&gt;\(a_i\)&lt;/span&gt;，找到所有合法的 &lt;span class=&#34;math inline&#34;&gt;\(a_j\)&lt;/span&gt;。容易想到枚举 &lt;span class=&#34;math inline&#34;&gt;\(a_i\div a_j\)&lt;/span&gt; 来做；假设存在 &lt;span class=&#34;math inline&#34;&gt;\(a_k\div a_i=a_j\div a_i\)&lt;/span&gt; 且 &lt;span class=&#34;math inline&#34;&gt;\(k&amp;gt;j\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;不妨设 &lt;span class=&#34;math inline&#34;&gt;\(a_j=K\cdot a_i+p,a_k=K\cdot a_i+q\)&lt;/span&gt;，&lt;span class=&#34;math inline&#34;&gt;\((a_i,a_j),(a_i,a_k)\)&lt;/span&gt; 均合法当且仅当下列条件全部成立：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class=&#34;math inline&#34;&gt;\(a_j\bmod a_i&amp;gt;a_k\bmod a_i\)&lt;/span&gt;； 则 &lt;span class=&#34;math inline&#34;&gt;\(a_j&amp;gt;a_k\)&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;math inline&#34;&gt;\(a_j\bmod a_k&amp;gt;a_k\bmod a_i\)&lt;/span&gt;；又 &lt;span class=&#34;math inline&#34;&gt;\(p-q\ge a_j\bmod a_k\)&lt;/span&gt;（&lt;strong&gt;太牛了这一步&lt;/strong&gt;），即 &lt;span class=&#34;math inline&#34;&gt;\(p-q&amp;gt;q\iff p&amp;gt;2q\)&lt;/span&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;证得只关心同一个 &lt;span class=&#34;math inline&#34;&gt;\(a_j\div a_i\)&lt;/span&gt; 时的支配对数量为 &lt;span class=&#34;math inline&#34;&gt;\(\log n\)&lt;/span&gt; 级别；总对数 &lt;span class=&#34;math inline&#34;&gt;\(O(n\log n\ln n)\)&lt;/span&gt;。离线下来扫描线就行了。&lt;/p&gt;
&lt;details&gt;
&lt;p&gt;对着 单点修改 区间最值 想了 1h 的单 log 做法 😰 果然小脑掉线太可怕了，第二天早上重置大脑 1s 发现自己是斯波 😓&lt;/p&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int LEN = (1 &amp;lt;&amp;lt; 20);
int nec(void) &amp;#123;
    static char buf[LEN], *p = buf, *e = buf;
    if (p == e) &amp;#123;
        e = buf + fread(buf, 1, LEN, stdin);
        if (e == buf) return EOF;
        p = buf;
    &amp;#125;
    return *p++;
&amp;#125;
bool read(int &amp;amp;x) &amp;#123;
    x = 0;
    bool f = 0;
    char ch = nec();
    while (ch &amp;lt; &amp;#39;0&amp;#39; || ch &amp;gt; &amp;#39;9&amp;#39;) &amp;#123;
        if (ch == EOF) return 0;
        if (ch == &amp;#39;-&amp;#39;) f = 1;
        ch = nec();
    &amp;#125;
    while (ch &amp;gt;= &amp;#39;0&amp;#39; &amp;amp;&amp;amp; ch &amp;lt;= &amp;#39;9&amp;#39;) &amp;#123;
        x = x * 10 + ch - &amp;#39;0&amp;#39;;
        ch = nec();
    &amp;#125;
    if (f) x = -x;
    return 1;
&amp;#125;
void print(int x) &amp;#123;
    if (x &amp;lt; 0)
        putchar(&amp;#39;-&amp;#39;), x = -x;
    if (x &amp;gt;= 10) print(x / 10);
    putchar(x % 10 + &amp;#39;0&amp;#39;);
    return;
&amp;#125;
void print(int x, char ch) &amp;#123;
    print(x), putchar(ch);
    return;
&amp;#125;
const int maxn = 4e6 + 5;
struct &amp;#123; int l, r, u[2]; &amp;#125; t[maxn];
#define lt (t[p].l)
#define rt (t[p].r)
int tot[2];
void add(int &amp;amp;p, int l, int r, int x, int v, int i) &amp;#123;
    if (!p)
        p = ++tot[i], t[p].u[0] = -1, t[p].u[1] = 0x3f3f3f3f;
    if (i == 0)
        t[p].u[0] = std::max(t[p].u[0], v);
    else
        t[p].u[1] = std::min(t[p].u[1], v);
    if (l == r)
        return;
    int mid = (l + r) &amp;gt;&amp;gt; 1;
    if (x &amp;lt;= mid)
        add(lt, l, mid, x, v, i);
    else
        add(rt, mid + 1, r, x, v, i);
    return;
&amp;#125;
int ask(int p, int l, int r, int ql, int qr, int i) &amp;#123;
    if (!p || (ql &amp;lt;= l &amp;amp;&amp;amp; r &amp;lt;= qr))
        return t[p].u[i];
    int mid = (l + r) &amp;gt;&amp;gt; 1;
    if (qr &amp;lt;= mid)
        return ask(lt, l, mid, ql, qr, i);
    if (ql &amp;gt; mid)
        return ask(rt, mid + 1, r, ql, qr, i);
    if (i == 0)
        return std::max(ask(lt, l, mid, ql, qr, 0), ask(rt, mid + 1, r, ql, qr, 0));
    return std::min(ask(lt, l, mid, ql, qr, 1), ask(rt, mid + 1, r, ql, qr, 1));
&amp;#125;
#undef lt
#undef rt
int main() &amp;#123;
#ifndef ONLINE_JUDGE
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    const int m = 1e6;
    int rt[2] = &amp;#123; 0 &amp;#125;, n;
    t[0].u[0] = -1, t[0].u[1] = 0x3f3f3f3f;
    read(n);
    std::vector&amp;lt;int&amp;gt; a(n + 1);
    for (int i = 1; i &amp;lt;= n; ++i)
        read(a[i]);
    std::vector&amp;lt;std::vector&amp;lt;std::pair&amp;lt;int, int&amp;gt; &amp;gt; &amp;gt; t(n + 1);
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        if (i != 1) &amp;#123;
            for (int K = a[i]; K &amp;lt;= m; K += a[i]) &amp;#123;
                for (int mx = std::min(a[i] - 1, m - K); ; ) &amp;#123;
                    int k = ask(rt[0], 1, m, K, K + mx, 0);
                    if (k == -1)
                        break;
                    t[i].emplace_back(k, a[k] - K);
                    if (k == 1 || !(a[k] - K))
                        break;
                    mx = (a[k] - K - 1) / 2;
                &amp;#125;
            &amp;#125;
        &amp;#125;
        add(rt[0], 1, m, a[i], i, 0);
    &amp;#125;
    for (int i = n; i; --i) &amp;#123;
        if (i != n)
            for (int K = a[i]; K &amp;lt;= m; K += a[i])
                for (int mx = std::min(a[i] - 1, m - K); ; ) &amp;#123;
                    int k = ask(rt[1], 1, m, K, K + mx, 1);
                    if (k == 0x3f3f3f3f)
                        break;
                    t[k].emplace_back(i, a[k] - K);
                    if (k == n || !(a[k] - K))
                        break;
                    mx = (a[k] - K - 1) / 2;
                &amp;#125;
        add(rt[1], 1, m, a[i], i, 1);
    &amp;#125;
    int q;
    read(q);
    std::vector&amp;lt;int&amp;gt; res(q + 1);
    std::vector&amp;lt;std::vector&amp;lt;std::pair&amp;lt;int, int&amp;gt; &amp;gt; &amp;gt; u(n + 1);
    for (int i = 1, l, r; i &amp;lt;= q; ++i) &amp;#123;
        read(l), read(r);
        if (l &amp;gt; r)
            std::swap(l, r);
        u[r].emplace_back(l, i);
    &amp;#125;
    std::vector&amp;lt;int&amp;gt; bit(n + 1, 0x3f3f3f3f);
    auto lowbit = [&amp;amp;](int x) &amp;#123; return x &amp;amp; -x; &amp;#125;;
    auto add = [&amp;amp;](int x, int v) &amp;#123;
        for (; x &amp;lt;= n; x += lowbit(x))
            bit[x] = std::min(bit[x], v);
        return;
    &amp;#125;;
    auto ask = [&amp;amp;](int x) &amp;#123;
        auto res = 0x3f3f3f3f;
        for (; x; x -= lowbit(x))
            res = std::min(res, bit[x]);
        return res;
    &amp;#125;;
    for (int r = 1; r &amp;lt;= n; ++r) &amp;#123;
        for (auto [l, v] : t[r])
            add(n - l + 1, v);
        for (auto [l, i] : u[r])
            res[i] = ask(n - l + 1);
    &amp;#125;
    for (int i = 1; i &amp;lt;= q; ++i)
        print(res[i], &amp;#39;\n&amp;#39;);
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;p&gt;求支配对的过程也要带 log（线段树），再加上扫描线的 3log，总共是常数比较大的 3log（卡了一个上午的常也是有了）。所以接下来讲解另一种奇技淫巧。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;暴力分治&lt;/strong&gt;：注意到对于比较长（&lt;span class=&#34;math inline&#34;&gt;\(len&amp;gt; B\)&lt;/span&gt;）的区间，答案比较小；故考虑分治。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于长询问（&lt;span class=&#34;math inline&#34;&gt;\(len&amp;gt;B\)&lt;/span&gt;），从小到大枚举答案并 check；预处理某个范围（&lt;span class=&#34;math inline&#34;&gt;\(V\)&lt;/span&gt;）内的 &lt;span class=&#34;math inline&#34;&gt;\(res\)&lt;/span&gt; 出现的所有位置，平衡的时候还要算上调和级数和 bit。&lt;/li&gt;
&lt;li&gt;对于短询问（&lt;span class=&#34;math inline&#34;&gt;\(len\le B\)&lt;/span&gt;），发现每次区间内暴力是 &lt;span class=&#34;math inline&#34;&gt;\(O(B^2q)\)&lt;/span&gt; 的；把询问离线下来，精细实现，利用询问的公共部分使得&lt;strong&gt;每一对数只被枚举一次&lt;/strong&gt;就能达到 &lt;span class=&#34;math inline&#34;&gt;\(O(B^2 + Bq)\)&lt;/span&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最优解取 &lt;span class=&#34;math inline&#34;&gt;\(B=333,V=483\)&lt;/span&gt;，不自己实现一遍了。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;d---仙人掌&#34;&gt;D - 仙人掌&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P3687&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P3687&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;把边双从图中删除、问题转化为树上&lt;strong&gt;边&lt;/strong&gt;不交的链覆盖，使得&lt;strong&gt;所有链长 &lt;span class=&#34;math inline&#34;&gt;\(\ge 2\)&lt;/span&gt;&lt;/strong&gt; 的方案数。发现由于&lt;strong&gt;边可以不被覆盖&lt;/strong&gt;，常规 DP 会使得在父节点处合并时需要额外的数量维，参考树上背包，复杂度 &lt;span class=&#34;math inline&#34;&gt;\(O(n^2)\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;思考时会注意到两个限制可以抵消——如果认为长为 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt; 的链就是不被覆盖的边，覆盖所有树边，显然可以建立和合法解的双射。此时合并是非常方便的，注意到每个儿子的系数一定都参与『分步』，只需要求出『分类』的系数。这个可以预处理（和 &lt;a href=&#34;/20250407/#a.-二分图染色&#34;&gt;二分图染色&lt;/a&gt; 这个题有点像），令 &lt;span class=&#34;math inline&#34;&gt;\(f_i\)&lt;/span&gt; 表示一个点度数为 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 时的答案，参考错排的思路，则 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 可以不参与配对，也可以乱选一个点配对，如果选中了已配对的点就令其和 &lt;span class=&#34;math inline&#34;&gt;\(i-1\)&lt;/span&gt; 交换，可以建立和合法解的双射。则 &lt;span class=&#34;math inline&#34;&gt;\(f_i=f_{i-1}+(n-1)f_{i-2}\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;首先需要 check 原图是否为仙人掌，顺带回忆一下连通性的知识——在 DFS 树上差分，检查是否有边被覆盖两次即可。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int mod = 998244353;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int T;
    for (std::cin &amp;gt;&amp;gt; T; T--; ) &amp;#123;
        int n, m;
        std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
        std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; g1(n + 1);
        for (int x, y; m--; ) &amp;#123;
            std::cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; y;
            g1[x].push_back(y), g1[y].push_back(x);
        &amp;#125;
        bool flag = 1;
        int now = 0, cnt = 0;
        std::vector&amp;lt;int&amp;gt; st, dfn(n + 1), low(n + 1), col(n + 1), diff(n + 1);
        std::function&amp;lt;void(int, int)&amp;gt; DFS = [&amp;amp;](int x, int fa) &amp;#123;
            st.push_back(x);
            dfn[x] = low[x] = ++now;
            for (auto i : g1[x])
                if (!dfn[i]) &amp;#123;
                    // printf(&amp;quot;x = %d, %d -&amp;gt; %d\n&amp;quot;, x, x, i);
                    DFS(i, x);
                    diff[x] += diff[i];
                    // printf(&amp;quot;x = %d, diff[%d] += diff[%d]\n&amp;quot;, x, x, i);
                    low[x] = std::min(low[x], low[i]);
                &amp;#125;
                else if (i != fa &amp;amp;&amp;amp; dfn[i] &amp;lt; dfn[x]) &amp;#123;
                    low[x] = std::min(low[x], dfn[i]);
                    ++diff[x], --diff[i];
                    // printf(&amp;quot;x = %d, ++diff[%d], --diff[%d]\n&amp;quot;, x, x, i);
                &amp;#125;
            if (diff[x] &amp;gt;= 2)
                flag = 0;
            // printf(&amp;quot;x = %d, diff[%d] = %d\n&amp;quot;, x, x, diff[x]);
            if (low[x] == dfn[x]) &amp;#123;
                ++cnt;
                for (int p = -1; p != x; ) &amp;#123;
                    p = st.back(), st.pop_back();
                    col[p] = cnt;
                &amp;#125;
            &amp;#125;
            return;
        &amp;#125;;
        DFS(1, -1);
        if (!flag) &amp;#123;
            std::cout &amp;lt;&amp;lt; 0 &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
            continue;
        &amp;#125;
        std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; g(n + 1);
        for (int i = 1; i &amp;lt;= n; ++i)
            for (auto j : g1[i])
                if (col[i] != col[j])
                    g[i].push_back(j);
        std::vector&amp;lt;long long&amp;gt; f(n + 1), dp(n + 1);
        dp[0] = 1ll, dp[1] = 1ll;
        for (int i = 2; i &amp;lt;= n; ++i)
            dp[i] = (dp[i - 1] + (i - 1) * dp[i - 2]) % mod;
        std::vector&amp;lt;int&amp;gt; tag(n + 1);
        DFS = [&amp;amp;](int x, int fa) &amp;#123;
            f[x] = 1ll, tag[x] = 1;
            for (auto i : g[x])
                if (i != fa) &amp;#123;
                    DFS(i, x);
                    (f[x] *= f[i]) %= mod;
                &amp;#125;
            (f[x] *= dp[(int)g[x].size()]) %= mod;
            return;
        &amp;#125;;
        auto res(1ll);
        for (int i = 1; i &amp;lt;= n; ++i)
            if (!tag[i])
                DFS(i, -1), (res *= f[i]) %= mod;
        std::cout &amp;lt;&amp;lt; res &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    &amp;#125;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;p&gt;E. Many Minimizations 是数学题，跳了。&lt;/p&gt;
&lt;hr /&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;无名题&#34;&gt;无名题&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;背景：给定 &lt;span class=&#34;math inline&#34;&gt;\(n,k\)&lt;/span&gt;，对于 &lt;span class=&#34;math inline&#34;&gt;\(\forall\, 1\le i\le n\)&lt;/span&gt;，令 &lt;span class=&#34;math inline&#34;&gt;\(a_i=i\bmod k\)&lt;/span&gt;，问一共有多少个本质不同的子序列？对于 &lt;span class=&#34;math inline&#34;&gt;\(k=1,2,\cdots,n\)&lt;/span&gt; 分别求出答案。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;maimai&#34;&gt;maimai&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://ac.nowcoder.com/acm/contest/66112/F&#34; class=&#34;uri&#34;&gt;https://ac.nowcoder.com/acm/contest/66112/F&lt;/a&gt;&lt;/p&gt;
</content>
        <category term="字典树" />
        <category term="字符串" />
        <category term="组合数学" />
        <category term="支配对" />
        <updated>2025-08-09T04:33:17.000Z</updated>
    </entry>
    <entry>
        <id>https://xsc062.netlify.app/20230110/</id>
        <title>背单词</title>
        <link rel="alternate" href="https://xsc062.netlify.app/20230110/"/>
        <content type="html">&lt;p&gt;Solution to&lt;a href=&#34;http://222.180.160.110:61235/problem/59&#34;&gt;「SCOI2016」背单词&lt;/a&gt;。&lt;/p&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;
&lt;hr /&gt;
&lt;p&gt;题解 P3294。&lt;/p&gt;
&lt;p&gt;我们看到字典树这个标签，下意识想到了前缀。&lt;/p&gt;
&lt;p&gt;但是题目让我们求后缀，所以我们把所有字符串先 &lt;code&gt;reverse&lt;/code&gt; 一下，将问题转化为前缀，方便描述。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;我们发现，因为 &lt;span class=&#34;math inline&#34;&gt;\(y &amp;lt; x \le n\)&lt;/span&gt;，所以三种情况的花费排序为 &lt;span class=&#34;math inline&#34;&gt;\(x-y&amp;lt;x&amp;lt;n\times n\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;不难发现，我们可以很简单地通过「把某单词的所有前缀单词放到它之前」消除开销为 &lt;span class=&#34;math inline&#34;&gt;\(n\times n\)&lt;/span&gt; 的情况。此时开销最劣情况下为 &lt;span class=&#34;math inline&#34;&gt;\(\sum\limits_{i=1}^ni &amp;lt; n\times n\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;接下来，问题在于怎样在满足「把某单词的所有前缀单词放到它之前」的条件下，最小化开销。不难发现，当我们去除第一种情况后，剩下的 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 和 &lt;span class=&#34;math inline&#34;&gt;\(x-y\)&lt;/span&gt; 都包含 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 项，也就是说，我们只需要最小化 &lt;span class=&#34;math inline&#34;&gt;\(\sum -y\)&lt;/span&gt; 的值，也就是最大化 &lt;span class=&#34;math inline&#34;&gt;\(\sum y\)&lt;/span&gt; 的值。而 &lt;span class=&#34;math inline&#34;&gt;\(\sum x\)&lt;/span&gt; 为定值 &lt;span class=&#34;math inline&#34;&gt;\(\sum\limits_{i=1}^ni\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关于处理方式：不难发现一个单词的最长前缀单词最多只有一个，但以该单词为最长前缀单词的单词可能有多个，联想到树。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我们将每个单词的最长前缀和该单词连边，会得到一个森林。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;不妨先考虑问题的简化，假设有两条链（即，不会同时存在多个单词，使得它们的最长前缀单词相同），应该如何安排其顺序。&lt;/p&gt;
&lt;p&gt;如图所示，考虑「同一条链均匀分散到序列中」和「同一条链集中在一起」两种有规律的安排方式，得到：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;1.jpg&#34; /&gt;&lt;/p&gt;
&lt;p&gt;可以发现，第二种情况明显更优。&lt;/p&gt;
&lt;p&gt;所以我们扩展猜想：对于某一单词，以它为前缀的所有单词必须紧随其后。该结论是可递归的。&lt;/p&gt;
&lt;p&gt;继续处理细节部分。考虑两条链长度不同，应如何排列它们的位置？&lt;/p&gt;
&lt;p&gt;下图展示了「前短后长」和「前长后短」两种方案：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;2.jpg&#34; /&gt;&lt;/p&gt;
&lt;p&gt;可以发现，前短后长的方案更优。&lt;/p&gt;
&lt;p&gt;扩展得到猜想，同一单词的所有子树中，大小更小的应在更前面。该结论是可递归的。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;接下来对猜想进行证明。&lt;/p&gt;
&lt;p&gt;假设现在已有一条链。我们只有把整条链连在一起，短单词放到长单词前面这一种方法。&lt;/p&gt;
&lt;p&gt;然后新来了一个不属于这条链的节点，明显，因为节点不管放到哪里，其 &lt;span class=&#34;math inline&#34;&gt;\(y\)&lt;/span&gt; 值不变，但会改变已有链的 &lt;span class=&#34;math inline&#34;&gt;\(y\)&lt;/span&gt; 值，所以放到最前面最优。&lt;/p&gt;
&lt;p&gt;又来了一个节点，和刚才新增的节点属于同一条链，一样，不管这个节点何去何从，其 &lt;span class=&#34;math inline&#34;&gt;\(y\)&lt;/span&gt; 不变，但放在越前面，后面的节点的 &lt;span class=&#34;math inline&#34;&gt;\(y\)&lt;/span&gt; 值增加得越多。&lt;/p&gt;
&lt;p&gt;以此类推可得到结论，同一条链放到一起。短链放到长链前面也是比较好想的。假设有两条链，短链长度为 &lt;span class=&#34;math inline&#34;&gt;\(a\)&lt;/span&gt;，长链长度为 &lt;span class=&#34;math inline&#34;&gt;\(b\)&lt;/span&gt;，放置起点为 &lt;span class=&#34;math inline&#34;&gt;\(l\)&lt;/span&gt;，则前短后长和钱长后短的 y 之和分别为 &lt;span class=&#34;math inline&#34;&gt;\(\dfrac{(l + l + a - 2) \times (a - 1) + (l + a + l + a + b - 2) \times (b - 1)} 2\)&lt;/span&gt; 和 &lt;span class=&#34;math inline&#34;&gt;\(\dfrac{(l + l + b - 2) \times (b - 1) + (l + b + l + b + a - 2) \times (b - 1)} 2\)&lt;/span&gt;（运用等差数列求和公式），解不等式可得前短后长一定更优。&lt;/p&gt;
&lt;p&gt;接下来是从链扩展到树。那么我们想到了什么？树链剖分。&lt;/p&gt;
&lt;p&gt;我们化用树剖思想，以最轻边为剖分条件，将树划分为有顺序的链，按照上述方式排列其顺序即可。&lt;/p&gt;
&lt;p&gt;此时我们记录下每个单词的直系父亲（即其最长前缀单词），在唯一序列中模拟计分操作，即可得到答案。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;为了方便，可将所有入度为 &lt;span class=&#34;math inline&#34;&gt;\(0\)&lt;/span&gt; 的点与一个虚点相连，将森林转化为树。&lt;/p&gt;
&lt;p&gt;注意 &lt;code&gt;long long&lt;/code&gt;。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;namespace XSC062 &amp;#123;
using namespace fastIO;
using str = std::string;
const int maxn = 1e6 + 5;
const int maxm = 1e6 + 5;
str s[maxn];
int T[maxm][26];
int kaz[maxn], siz[maxn]; // kaz 表示单词在最终序列中所处的位置
std::vector&amp;lt;int&amp;gt; g[maxn];
int n, l, res, cnt = 1, ti;
int tot[maxm], fa[maxn], deg[maxn];
void Insert(int k) &amp;#123; 
    int f = 1, len = s[k].length();
    for(int i = 0; i &amp;lt; len; ++i) &amp;#123;
        if (!T[f][s[k][i] - &amp;#39;a&amp;#39;]) 
            T[f][s[k][i] - &amp;#39;a&amp;#39;] = ++cnt;
        f = T[f][s[k][i]-&amp;#39;a&amp;#39;];
    &amp;#125;
    tot[f] = k;
    return;
&amp;#125;
void Search(int k) &amp;#123;
    int f = 1;
    int len = s[k].length();
    for (int i = 0; i &amp;lt; len; ++i) &amp;#123;
        f = T[f][s[k][i] - &amp;#39;a&amp;#39;];
        if (tot[f]) &amp;#123;
            if (tot[f] != k)
                fa[k] = tot[f]; // 记录当前最长前缀
        &amp;#125;
    &amp;#125;
    return;
&amp;#125;
void add(int x, int y) &amp;#123;
    ++deg[y];
    g[x].push_back(y);
    return;
&amp;#125;
void DFS1(int x) &amp;#123; // 提前计算每个子树的 size
    siz[x] = 1;
    for (auto i : g[x]) &amp;#123;
        DFS1(i);
        siz[x] += siz[i];
    &amp;#125;
    return;
&amp;#125;
void DFS2(int x) &amp;#123;
    kaz[x] = ti++;  // 时间戳即为单词位置
    std::sort(g[x].begin(), g[x].end(),
        [&amp;amp;](int x, int y) &amp;#123; return siz[x] &amp;lt; siz[y]; &amp;#125;); // 按子树 size 排序
    for (auto i : g[x])
        DFS2(i);
    return;
&amp;#125;
int main() &amp;#123;
    scanf(&amp;quot;%lld&amp;quot;, &amp;amp;n);
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        std::cin &amp;gt;&amp;gt; s[i];
        std::reverse(s[i].begin(), s[i].end());  // 后缀转前缀
        Insert(i);
        res += i;
    &amp;#125;
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        Search(i);
        if (fa[i])
            add(fa[i], i); // 建图
    &amp;#125;
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        if (!deg[i]) // 建虚点方便操作
            add(n + 1, i), fa[i] = n + 1;
    &amp;#125;
    DFS1(n + 1), DFS2(n + 1);
    for (int i = 1; i &amp;lt;= n; ++i)
        res -= kaz[fa[i]]; // 处理 y 值
    print(res);
    return 0;
&amp;#125;
&amp;#125; // namespace XSC062&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
</content>
        <category term="字典树" />
        <updated>2023-01-09T18:27:46.000Z</updated>
    </entry>
</feed>
