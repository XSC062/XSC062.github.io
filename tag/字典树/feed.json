{
    "version": "https://jsonfeed.org/version/1",
    "title": "null • All posts by \"字典树\" tag",
    "description": "",
    "home_page_url": "https://xsc062.netlify.app",
    "items": [
        {
            "id": "https://xsc062.netlify.app/20250809/",
            "url": "https://xsc062.netlify.app/20250809/",
            "title": "近期杂题",
            "date_published": "2025-08-09T04:33:17.000Z",
            "content_html": "<p>这段时间比赛的一些题 和 nKessi、duanyu 讲的题目。太偏计数、数学的基本上没办法做了。</p>\n<span id=\"more\"></span>\n<hr />\n<h2 id=\"a.-出关\">A. 出关</h2>\n<p><a href=\"http://222.180.160.110:61235/contest/6462/problem/1\" class=\"uri\">http://222.180.160.110:61235/contest/6462/problem/1</a></p>\n<blockquote>\n<p>给定 <span class=\"math inline\">\\(s\\)</span>，对于一个空串，任意利用下列三种操作，使其变为 <span class=\"math inline\">\\(s\\)</span>，求最小代价：</p>\n<ol type=\"1\">\n<li>在末尾添加字符 <span class=\"math inline\">\\(c\\)</span>，代价为 <span class=\"math inline\">\\(t_{0,c}\\)</span>；</li>\n<li>复制整个字符串并粘贴在末尾，代价为 <span class=\"math inline\">\\(t_1\\)</span>；</li>\n<li>删除末尾字符，代价为 <span class=\"math inline\">\\(t_2\\)</span>。</li>\n</ol>\n<p><span class=\"math inline\">\\(|s|\\le 10^6\\)</span>。</p>\n</blockquote>\n<p>可以预处理出对于每个 <span class=\"math inline\">\\(i\\)</span> 结尾，最多可以复制到哪个地方，发现要求 <span class=\"math inline\">\\(z_i=lcp(s_{1\\dots n},s_{i+1\\dots n})\\)</span>。那么一个 <span class=\"math inline\">\\(i\\)</span> 的最远转移点 <span class=\"math inline\">\\(r_i=i+z_{i+1}\\)</span>，用单调队列就能维护，会 exkmp 就能线性；</p>\n<p>否则可以二分 + 哈希多个 log，后面也有理由偷懒用优先队列了。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int p = 31;\nconst int mod = 998244353;\nint main() &#123;\n    std::freopen(&quot;laozi.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;laozi.out&quot;, &quot;w&quot;, stdout);\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n    std::string s;\n    std::cin &gt;&gt; s;\n    int n = (int)s.length(), t1, t2;\n    std::vector&lt;long long&gt; h(n + 1), base(n + 1);\n    std::vector&lt;int&gt; a(n + 1), t0(27), z(n + 1), r(n + 1);\n    base[0] = 1ll;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        a[i] = s[i - 1] - &#39;a&#39; + 1;\n        h[i] = (h[i - 1] * p + a[i]) % mod;\n        base[i] = base[i - 1] * p % mod;\n    &#125;\n    auto gethash = [&amp;](int l, int r) &#123;\n        return (h[r] - h[l - 1] * base[r - l + 1] % mod + mod) % mod;\n    &#125;;\n    for (int i = 1; i &lt;= n; ++i)\n        for (int l = 1, r = std::min(i - 1, n - i + 1), mid; l &lt;= r; ) &#123;\n            mid = (l + r) &gt;&gt; 1;\n            if (gethash(1, mid) == gethash(i, i + mid - 1))\n                z[i] = mid, l = mid + 1;\n            else\n                r = mid - 1;\n        &#125;\n    for (int i = 1; i &lt; n; ++i)\n        r[i] = i + std::min(i, z[i + 1]);\n    for (int i = 1; i &lt;= 26; ++i)\n        std::cin &gt;&gt; t0[i];\n    std::cin &gt;&gt; t1 &gt;&gt; t2;\n    std::vector&lt;long long&gt; f(n + 1);\n    std::priority_queue&lt;std::pair&lt;long long, int&gt; &gt; q;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        f[i] = f[i - 1] + t0[a[i]];\n        for (; !q.empty() &amp;&amp; r[q.top().second] &lt; i; q.pop());\n        if (!q.empty())\n            f[i] = std::min(f[i], t1 - q.top().first - (long long)t2 * i);\n        if (i != n)\n            q.emplace(-(f[i] + 2ll * t2 * i), i);\n    &#125;\n    std::cout &lt;&lt; f[n] &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"d.-非攻\">D. 非攻</h2>\n<p><a href=\"http://222.180.160.110:61235/contest/6462/problem/4\" class=\"uri\">http://222.180.160.110:61235/contest/6462/problem/4</a></p>\n<blockquote>\n<p>给定 <span class=\"math inline\">\\(n\\)</span>，对于一个 <span class=\"math inline\">\\(1\\sim n\\)</span> 的排列，使用最小的交换次数使得其单增。在该前提下，定义代价为每次交换的两个数之积。对于所有 <span class=\"math inline\">\\(n!\\)</span> 个排列，计算最小代价之和。</p>\n<p><span class=\"math inline\">\\(n\\le 10^7\\)</span>。</p>\n</blockquote>\n<p>转化成，把 <span class=\"math inline\">\\(1\\sim n\\)</span> 分成无标号的若干组，每组的代价是 最小值 <span class=\"math inline\">\\(\\times\\)</span> 其他元素的和，还有一个项链问题的系数，发现组间的符号是求和，考虑计算贡献。</p>\n<p>枚举 <span class=\"math inline\">\\(i,j\\)</span> 并钦定两个同属一个环，且 <span class=\"math inline\">\\(i\\)</span> 为最小值，枚举环大小 <span class=\"math inline\">\\(s+2\\)</span>，那么有：</p>\n<p><span class=\"math display\">\\[\n\\begin{aligned}\nres&amp;=\\sum_{i=1}^{n-1}\\sum_{j=i+1}^n i\\cdot j \\cdot \\sum_{s=0}^{n-i-1}\\binom{n-i-1}s \\cdot (s+1)!\\cdot (n-s-2)!\\\\\n&amp;=\\sum_{i=1}^{n-1}i\\cdot \\dfrac {(i+n+1)(n-i)}2 \\cdot \\sum_{s=0}^{n-i-1}\\binom{n-i-1}s\\cdot (s+1)!\\cdot (n-s-2)!\\\\\n&amp;=\\frac 12\\times\\sum_{i=1}^{n-1}i\\cdot (i+n+1)\\cdot (n-i)!\\cdot\\sum_{s=0}^{n-i-1}\\dfrac {(s + 1)\\cdot (n-s-2)!}{(n-i-1-s)!}\\\\\n\\end{aligned}\n\\]</span></p>\n<p>令 <span class=\"math inline\">\\(T=n-i-1\\)</span>，发现我们需要快速计算 <span class=\"math inline\">\\(f_T=\\sum\\limits_{i=0}^T \\dfrac{(i+1)\\cdot (n-i-2)!}{(T-i)!}\\)</span>。记 <span class=\"math inline\">\\(m=n-2\\)</span>，变形得 <span class=\"math inline\">\\(f_T=(m-T)!\\cdot \\sum\\limits_{i=0}^{T} (i+1) \\binom{m-i}{m-T}\\)</span>，发现似乎可以简化，令 <span class=\"math inline\">\\(k=m-T,t=T+1\\)</span>，则 <span class=\"math inline\">\\(f_T=\\sum\\limits_{i=1}^T i\\cdot \\binom {k+t-i}k\\)</span>。</p>\n<p>然后是经典的组合意义保平安环节，即从 <span class=\"math inline\">\\(k+t\\)</span> 个有标号小球中选择一条分界线，分界线左边选一个球、右边选 <span class=\"math inline\">\\(k\\)</span> 个球的方案数。发现分界线的存在很诡异，故用分界线后方的第一个球代替，在 <span class=\"math inline\">\\(t+1\\)</span> 处新建一个虚球，规定在前 <span class=\"math inline\">\\(t+1\\)</span> 个球中选两个球，并令后一个为分界线，且令前 <span class=\"math inline\">\\(t+1\\)</span> 个中的其他球为实球，就能建立双射。在分界线后再选 <span class=\"math inline\">\\(k\\)</span> 个球，容易发现直接在范围内选 <span class=\"math inline\">\\(k+2\\)</span> 个球就能满足条件，故 <span class=\"math inline\">\\(f_T=(n-T-2)!\\cdot \\binom{t+k+1}{k+2}\\)</span>。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 1e9 + 7;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n    std::freopen(&quot;mozi.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;mozi.out&quot;, &quot;w&quot;, stdout);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;long long&gt; fac(n + 1), inv(n + 1), f(n + 1);\n    fac[0] = inv[0] = 1ll;\n    for (int i = 1; i &lt;= n; ++i)\n        fac[i] = fac[i - 1] * i % mod;\n    auto qkp = [&amp;](long long x, int y) &#123;\n        auto res(1ll);\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    inv[n] = qkp(fac[n], mod - 2);\n    for (int i = n - 1; i; --i)\n        inv[i] = inv[i + 1] * (i + 1) % mod;\n    auto C = [&amp;](int n, int m) &#123;\n        return fac[n] * inv[n - m] % mod * inv[m] % mod;\n    &#125;;\n    int m = n - 2;\n    for (int T = 0; T &lt;= n - 2; ++T) &#123;\n        int k = m - T, t = T + 1;\n        f[T] = C(t + k + 1, k + 2) * fac[m - T] % mod;\n    &#125;\n    auto res = 0ll;\n    for (int i = 1; i &lt;= n - 1; ++i)\n        (res += (long long)i * (i + n + 1) % mod * fac[n - i] % mod * f[n - i - 1] % mod) %= mod;\n    std::cout &lt;&lt; res * inv[2] % mod &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"c---destruction-of-walls\">C - Destruction of Walls</h2>\n<p><a href=\"https://atcoder.jp/contests/arc203/tasks/arc203_c\" class=\"uri\">https://atcoder.jp/contests/arc203/tasks/arc203_c</a></p>\n<hr />\n<h2 id=\"d---insert-xor\">D - Insert XOR</h2>\n<p><a href=\"https://atcoder.jp/contests/arc203/tasks/arc203_d\" class=\"uri\">https://atcoder.jp/contests/arc203/tasks/arc203_d</a></p>\n<hr />\n<h2 id=\"a---记忆\">A - 记忆</h2>\n<p><a href=\"https://ac.nowcoder.com/acm/problem/274793\" class=\"uri\">https://ac.nowcoder.com/acm/problem/274793</a></p>\n<p>需要意识到问题是静态的，并且不能用线段树之类维护；故考虑离线下来，想办法在 LCA 处统计答案。</p>\n<p>这个时候发现需要合并子树状态、整体异或、整体 +1，很容易想到 Trie。把 <span class=\"math inline\">\\(u\\to\\)</span> LCA 的答案保存在 LCA 处，然后再用 DFS + 回溯统计 LCA <span class=\"math inline\">\\(\\to v\\)</span> 的答案。想了半天没想到把上下拆开来做也是神了 😅</p>\n<p>可能比较考验对字典树的理解？做个比喻，字典树的 id 就相当于对这个点上信息的『引用』。</p>\n<details>\n<p>字典树合并的时候可以考虑回收废弃点，不然可能有点卡。</p>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int X = 50;\nconst int maxn = 2e7 + 5;\nlong long d[maxn];\nint tot, T[maxn][2], f[maxn], fa[maxn];\n#define lc(p) T[p][0]\n#define rc(p) T[p][1]\nint find(int x) &#123; return x == f[x] ? x : f[x] = find(f[x]); &#125;\nint newnode(void) &#123;\n    int p = ++tot;\n    assert(p &lt; maxn);\n    d[p] = lc(p) = rc(p) = 0, f[p] = p;\n    return p;\n&#125;\nvoid pushdown(int p) &#123;\n    if (d[p]) &#123;\n        if (d[p] &amp; 1)\n            std::swap(lc(p), rc(p));\n        d[p] &gt;&gt;= 1;\n        if (lc(p))\n            d[lc(p)] ^= d[p];\n        if (rc(p))\n            d[rc(p)] ^= d[p];\n        d[p] = 0;\n    &#125;\n    return;\n&#125;\nint ins(int p, long long x) &#123;\n    for (int i = 0; i &lt; X; ++i) &#123;\n        pushdown(p);\n        if (!T[p][(x &gt;&gt; i) &amp; 1]) &#123;\n            T[p][(x &gt;&gt; i) &amp; 1] = newnode();\n            fa[T[p][(x &gt;&gt; i) &amp; 1]] = p;\n        &#125;\n        p = T[p][(x &gt;&gt; i) &amp; 1];\n    &#125;\n    return p;\n&#125;\nvoid merge(int &amp;p, int q) &#123;\n    if (!q)\n        return;\n    if (!p) &#123;\n        p = q;\n        return;\n    &#125;\n    pushdown(p), pushdown(q);\n    fa[lc(q)] = p, fa[rc(q)] = p;\n    merge(lc(p), lc(q)), merge(rc(p), rc(q));\n    assert(f[p] == p), assert(f[q] == q), f[q] = p;\n    return;\n&#125;\nlong long ask(int p) &#123;\n    std::vector&lt;int&gt; st;\n    for (int i = 0, j = p; i &lt; X; ++i)\n        st.push_back(fa[j]), j = fa[j];\n    for (int i = 0; i &lt; X; ++i)\n        pushdown(st.back()), st.pop_back();\n    long long x = 0;\n    for (int i = 0; i &lt; X; ++i) &#123;\n        x = x * 2 + (p == rc(fa[p]));\n        p = fa[p];\n    &#125;\n    return x;\n&#125;\nvoid add(int p) &#123;\n    for (int i = 0; p &amp;&amp; i &lt; X; ++i) &#123;\n        pushdown(p);\n        std::swap(lc(p), rc(p));\n        p = lc(p);\n    &#125;\n    return;\n&#125;\nvoid del(int p) &#123;\n    for (int i = 0; p &amp;&amp; i &lt; X; ++i) &#123;\n        pushdown(p);\n        std::swap(lc(p), rc(p));\n        p = rc(p);\n    &#125;\n    return;\n&#125;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, m;\n    std::cin &gt;&gt; n &gt;&gt; m;\n    std::vector&lt;int&gt; a(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i];\n    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);\n    for (int i = 1, x, y; i &lt; n; ++i) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y;\n        g[x].push_back(y), g[y].push_back(x);\n    &#125;\n    std::vector&lt;int&gt; siz(n + 1), son(n + 1), top(n + 1), fa(n + 1), dep(n + 1);\n    std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;\n        siz[x] = 1;\n        for (auto i : g[x])\n            if (i != fa[x]) &#123;\n                dep[i] = dep[x] + 1;\n                fa[i] = x, DFS(i);\n                siz[x] += siz[i];\n                if (siz[i] &gt; siz[son[x]])\n                    son[x] = i;\n            &#125;\n        return;\n    &#125;;\n    DFS(1);\n    DFS = [&amp;](int x) &#123;\n        if (son[x])\n            top[son[x]] = top[x], DFS(son[x]);\n        for (auto i : g[x])\n            if (i != son[x] &amp;&amp; i != fa[x])\n                top[i] = i, DFS(i);\n        return;\n    &#125;;\n    top[1] = 1, DFS(1);\n    auto askLCA = [&amp;](int x, int y) &#123;\n        for (; top[x] != top[y]; x = fa[top[x]])\n            if (dep[top[x]] &lt; dep[top[y]])\n                std::swap(x, y);\n        return dep[x] &lt; dep[y] ? x : y;\n    &#125;;\n    struct node &#123; long long x; int u, v; &#125;;\n    std::vector&lt;node&gt; q(m + 1);\n    std::vector&lt;int&gt; id(m + 1);\n    std::vector&lt;long long&gt; res(m + 1), ans(m + 1);\n    std::vector&lt;std::vector&lt;int&gt; &gt; up(n + 1), dn(n + 1), ed(n + 1);\n    for (int i = 1, x, u, v; i &lt;= m; ++i) &#123;\n        std::cin &gt;&gt; x &gt;&gt; u &gt;&gt; v;\n        q[i] = &#123; x, u, v &#125;;\n        up[u].push_back(i), dn[askLCA(u, v)].push_back(i), ed[v].push_back(i);\n    &#125;\n    std::vector&lt;int&gt; rt(n + 1);\n    DFS = [&amp;](int x) &#123;\n        rt[x] = newnode();\n        for (auto i : g[x])\n            if (i != fa[x]) &#123;\n                DFS(i);\n                merge(rt[x], rt[i]);\n            &#125;\n        add(rt[x]);\n        for (auto i : up[x])\n            id[i] = ins(rt[x], q[i].x);\n        d[rt[x]] ^= a[x];\n        for (auto i : dn[x])\n            res[i] = ask(find(id[i]));\n        return;\n    &#125;;\n    DFS(1);\n    tot = 0, rt[0] = newnode();\n    std::fill(id.begin() + 1, id.end(), 0);\n    DFS = [&amp;](int x) &#123;\n        d[rt[0]] ^= a[x];\n        for (auto i : dn[x])\n            id[i] = ins(rt[0], res[i]);\n        for (auto i : ed[x])\n            ans[i] = ask(id[i]);\n        add(rt[0]);\n        for (auto i : g[x])\n            if (i != fa[x])\n                DFS(i);\n        del(rt[0]);\n        d[rt[0]] ^= a[x];\n        return;\n    &#125;;\n    DFS(1);\n    for (int i = 1; i &lt;= m; ++i)\n        std::cout &lt;&lt; ans[i] &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"b---ビーバーの会合-2-meetings-2\">B - ビーバーの会合 2 (Meetings 2)</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/AT_joisc2021_j\" class=\"uri\">https://www.luogu.com.cn/problem/AT_joisc2021_j</a></p>\n<p>定义所求点为『局部重心』；类似树的重心，容易发现当关键点数量为奇时，只存在一个局部重心；否则，局部重心组成一条链。</p>\n<p>即对于每一个 <span class=\"math inline\">\\(i\\)</span>，需要找到一条最长链，使得其两端存在大小为 <span class=\"math inline\">\\(i\\)</span> 的子树（容易发现取后缀 max 即可得到真实答案）。使用点分治，精细实现容易做到 <span class=\"math inline\">\\(O(n\\log n)\\)</span>。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);\n    for (int i = 1, x, y; i &lt; n; ++i) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y;\n        g[x].push_back(y), g[y].push_back(x);\n    &#125;\n    std::vector&lt;int&gt; mx(n + 1), siz(n + 1), p, tag(n + 1), res(n + 1, 1);\n    std::function&lt;void(int, int)&gt; DFS1 = [&amp;](int x, int fa) &#123;\n        p.push_back(x);\n        siz[x] = 1, mx[x] = 0;\n        for (auto i : g[x])\n            if (!tag[i] &amp;&amp; i != fa) &#123;\n                DFS1(i, x);\n                siz[x] += siz[i];\n                mx[x] = std::max(mx[x], siz[i]);\n            &#125;\n        return;\n    &#125;;\n    auto findrt = [&amp;](int x) &#123;\n        p.clear(), DFS1(x, -1);\n        int n = (int)p.size();\n        for (auto i : p)\n            if (mx[i] &lt;= n / 2 &amp;&amp; n - siz[i] &lt;= n / 2)\n                return i;\n        assert(0);\n        return -1;\n    &#125;;\n    struct node &#123;\n        int u1, u2, id1, id2;\n        node(): u1(0), u2(0), id1(0), id2(0) &#123;&#125;\n        void upd(int u, int id) &#123;\n            if (id1 == id)\n                u1 = std::max(u1, u);\n            else if (u &gt;= u1)\n                u2 = u1, id2 = id1, u1 = u, id1 = id;\n            else if (u &gt;= u2)\n                u2 = u, id2 = id;\n            return;\n        &#125;\n    &#125;;\n    std::vector&lt;node&gt; s(n + 1);\n    std::function&lt;void(int, int, int, int)&gt; DFS2 = [&amp;](int x, int fa, int dep, int anc) &#123;\n        s[siz[x]].upd(dep, anc);\n        for (auto i : g[x])\n            if (!tag[i] &amp;&amp; i != fa)\n                DFS2(i, x, dep + 1, anc);\n        return;\n    &#125;;\n    std::function&lt;void(int, int, int, int)&gt; DFS3 = [&amp;](int x, int fa, int dep, int anc) &#123;\n        int v = ((s[siz[x]].id1 == anc) ? s[siz[x]].u2 : s[siz[x]].u1);\n        res[2 * siz[x]] = std::max(res[2 * siz[x]], dep + 1 + v);\n        for (auto i : g[x])\n            if (!tag[i] &amp;&amp; i != fa)\n                DFS3(i, x, dep + 1, anc);\n        return;\n    &#125;;\n    std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;\n        x = findrt(x), p.clear(), DFS1(x, -1);\n        // printf(&quot;rt = %d\\n&quot;, x);\n        for (auto i : g[x])\n            if (!tag[i])\n                DFS2(i, x, 1, i);\n        for (int i = siz[x] - 1; i; --i) &#123;\n            s[i].upd(s[i + 1].u1, s[i + 1].id1);\n            s[i].upd(s[i + 1].u2, s[i + 1].id2);\n        &#125;\n        for (auto i : g[x])\n            if (!tag[i])\n                DFS3(i, x, 1, i);\n        tag[x] = 1;\n        for (int i = 1; i &lt; siz[x]; ++i)\n            s[i] = node();\n        for (auto i : g[x])\n            if (!tag[i])\n                DFS(i);\n        return;\n    &#125;;\n    DFS(1);\n    for (int i = (n &gt;&gt; 1) * 2; i; --i)\n        if (i + 2 &lt;= n)\n            res[i] = std::max(res[i], res[i + 2]);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cout &lt;&lt; res[i] &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"c---the-closest-pair\">C - The Closest Pair</h2>\n<p><a href=\"https://ac.nowcoder.com/acm/problem/262593\" class=\"uri\">https://ac.nowcoder.com/acm/problem/262593</a></p>\n<p><strong>常规方法</strong>：考虑<strong>支配对</strong>，对于每个 <span class=\"math inline\">\\(a_i\\)</span>，找到所有合法的 <span class=\"math inline\">\\(a_j\\)</span>。容易想到枚举 <span class=\"math inline\">\\(a_i\\div a_j\\)</span> 来做；假设存在 <span class=\"math inline\">\\(a_k\\div a_i=a_j\\div a_i\\)</span> 且 <span class=\"math inline\">\\(k&gt;j\\)</span>。</p>\n<p>不妨设 <span class=\"math inline\">\\(a_j=K\\cdot a_i+p,a_k=K\\cdot a_i+q\\)</span>，<span class=\"math inline\">\\((a_i,a_j),(a_i,a_k)\\)</span> 均合法当且仅当下列条件全部成立：</p>\n<ul>\n<li><span class=\"math inline\">\\(a_j\\bmod a_i&gt;a_k\\bmod a_i\\)</span>； 则 <span class=\"math inline\">\\(a_j&gt;a_k\\)</span>。</li>\n<li><span class=\"math inline\">\\(a_j\\bmod a_k&gt;a_k\\bmod a_i\\)</span>；又 <span class=\"math inline\">\\(p-q\\ge a_j\\bmod a_k\\)</span>（<strong>太牛了这一步</strong>），即 <span class=\"math inline\">\\(p-q&gt;q\\iff p&gt;2q\\)</span>。</li>\n</ul>\n<p>证得只关心同一个 <span class=\"math inline\">\\(a_j\\div a_i\\)</span> 时的支配对数量为 <span class=\"math inline\">\\(\\log n\\)</span> 级别；总对数 <span class=\"math inline\">\\(O(n\\log n\\ln n)\\)</span>。离线下来扫描线就行了。</p>\n<details>\n<p>对着 单点修改 区间最值 想了 1h 的单 log 做法 😰 果然小脑掉线太可怕了，第二天早上重置大脑 1s 发现自己是斯波 😓</p>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int LEN = (1 &lt;&lt; 20);\nint nec(void) &#123;\n    static char buf[LEN], *p = buf, *e = buf;\n    if (p == e) &#123;\n        e = buf + fread(buf, 1, LEN, stdin);\n        if (e == buf) return EOF;\n        p = buf;\n    &#125;\n    return *p++;\n&#125;\nbool read(int &amp;x) &#123;\n    x = 0;\n    bool f = 0;\n    char ch = nec();\n    while (ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123;\n        if (ch == EOF) return 0;\n        if (ch == &#39;-&#39;) f = 1;\n        ch = nec();\n    &#125;\n    while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) &#123;\n        x = x * 10 + ch - &#39;0&#39;;\n        ch = nec();\n    &#125;\n    if (f) x = -x;\n    return 1;\n&#125;\nvoid print(int x) &#123;\n    if (x &lt; 0)\n        putchar(&#39;-&#39;), x = -x;\n    if (x &gt;= 10) print(x / 10);\n    putchar(x % 10 + &#39;0&#39;);\n    return;\n&#125;\nvoid print(int x, char ch) &#123;\n    print(x), putchar(ch);\n    return;\n&#125;\nconst int maxn = 4e6 + 5;\nstruct &#123; int l, r, u[2]; &#125; t[maxn];\n#define lt (t[p].l)\n#define rt (t[p].r)\nint tot[2];\nvoid add(int &amp;p, int l, int r, int x, int v, int i) &#123;\n    if (!p)\n        p = ++tot[i], t[p].u[0] = -1, t[p].u[1] = 0x3f3f3f3f;\n    if (i == 0)\n        t[p].u[0] = std::max(t[p].u[0], v);\n    else\n        t[p].u[1] = std::min(t[p].u[1], v);\n    if (l == r)\n        return;\n    int mid = (l + r) &gt;&gt; 1;\n    if (x &lt;= mid)\n        add(lt, l, mid, x, v, i);\n    else\n        add(rt, mid + 1, r, x, v, i);\n    return;\n&#125;\nint ask(int p, int l, int r, int ql, int qr, int i) &#123;\n    if (!p || (ql &lt;= l &amp;&amp; r &lt;= qr))\n        return t[p].u[i];\n    int mid = (l + r) &gt;&gt; 1;\n    if (qr &lt;= mid)\n        return ask(lt, l, mid, ql, qr, i);\n    if (ql &gt; mid)\n        return ask(rt, mid + 1, r, ql, qr, i);\n    if (i == 0)\n        return std::max(ask(lt, l, mid, ql, qr, 0), ask(rt, mid + 1, r, ql, qr, 0));\n    return std::min(ask(lt, l, mid, ql, qr, 1), ask(rt, mid + 1, r, ql, qr, 1));\n&#125;\n#undef lt\n#undef rt\nint main() &#123;\n#ifndef ONLINE_JUDGE\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    const int m = 1e6;\n    int rt[2] = &#123; 0 &#125;, n;\n    t[0].u[0] = -1, t[0].u[1] = 0x3f3f3f3f;\n    read(n);\n    std::vector&lt;int&gt; a(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        read(a[i]);\n    std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; t(n + 1);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        if (i != 1) &#123;\n            for (int K = a[i]; K &lt;= m; K += a[i]) &#123;\n                for (int mx = std::min(a[i] - 1, m - K); ; ) &#123;\n                    int k = ask(rt[0], 1, m, K, K + mx, 0);\n                    if (k == -1)\n                        break;\n                    t[i].emplace_back(k, a[k] - K);\n                    if (k == 1 || !(a[k] - K))\n                        break;\n                    mx = (a[k] - K - 1) / 2;\n                &#125;\n            &#125;\n        &#125;\n        add(rt[0], 1, m, a[i], i, 0);\n    &#125;\n    for (int i = n; i; --i) &#123;\n        if (i != n)\n            for (int K = a[i]; K &lt;= m; K += a[i])\n                for (int mx = std::min(a[i] - 1, m - K); ; ) &#123;\n                    int k = ask(rt[1], 1, m, K, K + mx, 1);\n                    if (k == 0x3f3f3f3f)\n                        break;\n                    t[k].emplace_back(i, a[k] - K);\n                    if (k == n || !(a[k] - K))\n                        break;\n                    mx = (a[k] - K - 1) / 2;\n                &#125;\n        add(rt[1], 1, m, a[i], i, 1);\n    &#125;\n    int q;\n    read(q);\n    std::vector&lt;int&gt; res(q + 1);\n    std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; u(n + 1);\n    for (int i = 1, l, r; i &lt;= q; ++i) &#123;\n        read(l), read(r);\n        if (l &gt; r)\n            std::swap(l, r);\n        u[r].emplace_back(l, i);\n    &#125;\n    std::vector&lt;int&gt; bit(n + 1, 0x3f3f3f3f);\n    auto lowbit = [&amp;](int x) &#123; return x &amp; -x; &#125;;\n    auto add = [&amp;](int x, int v) &#123;\n        for (; x &lt;= n; x += lowbit(x))\n            bit[x] = std::min(bit[x], v);\n        return;\n    &#125;;\n    auto ask = [&amp;](int x) &#123;\n        auto res = 0x3f3f3f3f;\n        for (; x; x -= lowbit(x))\n            res = std::min(res, bit[x]);\n        return res;\n    &#125;;\n    for (int r = 1; r &lt;= n; ++r) &#123;\n        for (auto [l, v] : t[r])\n            add(n - l + 1, v);\n        for (auto [l, i] : u[r])\n            res[i] = ask(n - l + 1);\n    &#125;\n    for (int i = 1; i &lt;= q; ++i)\n        print(res[i], &#39;\\n&#39;);\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<p>求支配对的过程也要带 log（线段树），再加上扫描线的 3log，总共是常数比较大的 3log（卡了一个上午的常也是有了）。所以接下来讲解另一种奇技淫巧。</p>\n<p><strong>暴力分治</strong>：注意到对于比较长（<span class=\"math inline\">\\(len&gt; B\\)</span>）的区间，答案比较小；故考虑分治。</p>\n<ul>\n<li>对于长询问（<span class=\"math inline\">\\(len&gt;B\\)</span>），从小到大枚举答案并 check；预处理某个范围（<span class=\"math inline\">\\(V\\)</span>）内的 <span class=\"math inline\">\\(res\\)</span> 出现的所有位置，平衡的时候还要算上调和级数和 bit。</li>\n<li>对于短询问（<span class=\"math inline\">\\(len\\le B\\)</span>），发现每次区间内暴力是 <span class=\"math inline\">\\(O(B^2q)\\)</span> 的；把询问离线下来，精细实现，利用询问的公共部分使得<strong>每一对数只被枚举一次</strong>就能达到 <span class=\"math inline\">\\(O(B^2 + Bq)\\)</span>。</li>\n</ul>\n<p>最优解取 <span class=\"math inline\">\\(B=333,V=483\\)</span>，不自己实现一遍了。</p>\n<hr />\n<h2 id=\"d---仙人掌\">D - 仙人掌</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P3687\" class=\"uri\">https://www.luogu.com.cn/problem/P3687</a></p>\n<p>把边双从图中删除、问题转化为树上<strong>边</strong>不交的链覆盖，使得<strong>所有链长 <span class=\"math inline\">\\(\\ge 2\\)</span></strong> 的方案数。发现由于<strong>边可以不被覆盖</strong>，常规 DP 会使得在父节点处合并时需要额外的数量维，参考树上背包，复杂度 <span class=\"math inline\">\\(O(n^2)\\)</span>。</p>\n<p>思考时会注意到两个限制可以抵消——如果认为长为 <span class=\"math inline\">\\(1\\)</span> 的链就是不被覆盖的边，覆盖所有树边，显然可以建立和合法解的双射。此时合并是非常方便的，注意到每个儿子的系数一定都参与『分步』，只需要求出『分类』的系数。这个可以预处理（和 <a href=\"/20250407/#a.-二分图染色\">二分图染色</a> 这个题有点像），令 <span class=\"math inline\">\\(f_i\\)</span> 表示一个点度数为 <span class=\"math inline\">\\(i\\)</span> 时的答案，参考错排的思路，则 <span class=\"math inline\">\\(i\\)</span> 可以不参与配对，也可以乱选一个点配对，如果选中了已配对的点就令其和 <span class=\"math inline\">\\(i-1\\)</span> 交换，可以建立和合法解的双射。则 <span class=\"math inline\">\\(f_i=f_{i-1}+(n-1)f_{i-2}\\)</span>。</p>\n<p>首先需要 check 原图是否为仙人掌，顺带回忆一下连通性的知识——在 DFS 树上差分，检查是否有边被覆盖两次即可。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 998244353;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int T;\n    for (std::cin &gt;&gt; T; T--; ) &#123;\n        int n, m;\n        std::cin &gt;&gt; n &gt;&gt; m;\n        std::vector&lt;std::vector&lt;int&gt; &gt; g1(n + 1);\n        for (int x, y; m--; ) &#123;\n            std::cin &gt;&gt; x &gt;&gt; y;\n            g1[x].push_back(y), g1[y].push_back(x);\n        &#125;\n        bool flag = 1;\n        int now = 0, cnt = 0;\n        std::vector&lt;int&gt; st, dfn(n + 1), low(n + 1), col(n + 1), diff(n + 1);\n        std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int fa) &#123;\n            st.push_back(x);\n            dfn[x] = low[x] = ++now;\n            for (auto i : g1[x])\n                if (!dfn[i]) &#123;\n                    // printf(&quot;x = %d, %d -&gt; %d\\n&quot;, x, x, i);\n                    DFS(i, x);\n                    diff[x] += diff[i];\n                    // printf(&quot;x = %d, diff[%d] += diff[%d]\\n&quot;, x, x, i);\n                    low[x] = std::min(low[x], low[i]);\n                &#125;\n                else if (i != fa &amp;&amp; dfn[i] &lt; dfn[x]) &#123;\n                    low[x] = std::min(low[x], dfn[i]);\n                    ++diff[x], --diff[i];\n                    // printf(&quot;x = %d, ++diff[%d], --diff[%d]\\n&quot;, x, x, i);\n                &#125;\n            if (diff[x] &gt;= 2)\n                flag = 0;\n            // printf(&quot;x = %d, diff[%d] = %d\\n&quot;, x, x, diff[x]);\n            if (low[x] == dfn[x]) &#123;\n                ++cnt;\n                for (int p = -1; p != x; ) &#123;\n                    p = st.back(), st.pop_back();\n                    col[p] = cnt;\n                &#125;\n            &#125;\n            return;\n        &#125;;\n        DFS(1, -1);\n        if (!flag) &#123;\n            std::cout &lt;&lt; 0 &lt;&lt; &#39;\\n&#39;;\n            continue;\n        &#125;\n        std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);\n        for (int i = 1; i &lt;= n; ++i)\n            for (auto j : g1[i])\n                if (col[i] != col[j])\n                    g[i].push_back(j);\n        std::vector&lt;long long&gt; f(n + 1), dp(n + 1);\n        dp[0] = 1ll, dp[1] = 1ll;\n        for (int i = 2; i &lt;= n; ++i)\n            dp[i] = (dp[i - 1] + (i - 1) * dp[i - 2]) % mod;\n        std::vector&lt;int&gt; tag(n + 1);\n        DFS = [&amp;](int x, int fa) &#123;\n            f[x] = 1ll, tag[x] = 1;\n            for (auto i : g[x])\n                if (i != fa) &#123;\n                    DFS(i, x);\n                    (f[x] *= f[i]) %= mod;\n                &#125;\n            (f[x] *= dp[(int)g[x].size()]) %= mod;\n            return;\n        &#125;;\n        auto res(1ll);\n        for (int i = 1; i &lt;= n; ++i)\n            if (!tag[i])\n                DFS(i, -1), (res *= f[i]) %= mod;\n        std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<p>E. Many Minimizations 是数学题，跳了。</p>\n<hr />\n<hr />\n<h2 id=\"无名题\">无名题</h2>\n<blockquote>\n<p>背景：给定 <span class=\"math inline\">\\(n,k\\)</span>，对于 <span class=\"math inline\">\\(\\forall\\, 1\\le i\\le n\\)</span>，令 <span class=\"math inline\">\\(a_i=i\\bmod k\\)</span>，问一共有多少个本质不同的子序列？对于 <span class=\"math inline\">\\(k=1,2,\\cdots,n\\)</span> 分别求出答案。</p>\n</blockquote>\n<hr />\n<h2 id=\"maimai\">maimai</h2>\n<p><a href=\"https://ac.nowcoder.com/acm/contest/66112/F\" class=\"uri\">https://ac.nowcoder.com/acm/contest/66112/F</a></p>\n",
            "tags": [
                "字典树",
                "字符串",
                "组合数学",
                "支配对"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20230110/",
            "url": "https://xsc062.netlify.app/20230110/",
            "title": "背单词",
            "date_published": "2023-01-09T18:27:46.000Z",
            "content_html": "<p>Solution to<a href=\"http://222.180.160.110:61235/problem/59\">「SCOI2016」背单词</a>。</p>\n<span id=\"more\"></span>\n<hr />\n<p>题解 P3294。</p>\n<p>我们看到字典树这个标签，下意识想到了前缀。</p>\n<p>但是题目让我们求后缀，所以我们把所有字符串先 <code>reverse</code> 一下，将问题转化为前缀，方便描述。</p>\n<hr />\n<p>我们发现，因为 <span class=\"math inline\">\\(y &lt; x \\le n\\)</span>，所以三种情况的花费排序为 <span class=\"math inline\">\\(x-y&lt;x&lt;n\\times n\\)</span>。</p>\n<p>不难发现，我们可以很简单地通过「把某单词的所有前缀单词放到它之前」消除开销为 <span class=\"math inline\">\\(n\\times n\\)</span> 的情况。此时开销最劣情况下为 <span class=\"math inline\">\\(\\sum\\limits_{i=1}^ni &lt; n\\times n\\)</span>。</p>\n<p>接下来，问题在于怎样在满足「把某单词的所有前缀单词放到它之前」的条件下，最小化开销。不难发现，当我们去除第一种情况后，剩下的 <span class=\"math inline\">\\(x\\)</span> 和 <span class=\"math inline\">\\(x-y\\)</span> 都包含 <span class=\"math inline\">\\(x\\)</span> 项，也就是说，我们只需要最小化 <span class=\"math inline\">\\(\\sum -y\\)</span> 的值，也就是最大化 <span class=\"math inline\">\\(\\sum y\\)</span> 的值。而 <span class=\"math inline\">\\(\\sum x\\)</span> 为定值 <span class=\"math inline\">\\(\\sum\\limits_{i=1}^ni\\)</span>。</p>\n<p><strong>关于处理方式：不难发现一个单词的最长前缀单词最多只有一个，但以该单词为最长前缀单词的单词可能有多个，联想到树。</strong></p>\n<p><strong>我们将每个单词的最长前缀和该单词连边，会得到一个森林。</strong></p>\n<p>不妨先考虑问题的简化，假设有两条链（即，不会同时存在多个单词，使得它们的最长前缀单词相同），应该如何安排其顺序。</p>\n<p>如图所示，考虑「同一条链均匀分散到序列中」和「同一条链集中在一起」两种有规律的安排方式，得到：</p>\n<p><img src=\"1.jpg\" /></p>\n<p>可以发现，第二种情况明显更优。</p>\n<p>所以我们扩展猜想：对于某一单词，以它为前缀的所有单词必须紧随其后。该结论是可递归的。</p>\n<p>继续处理细节部分。考虑两条链长度不同，应如何排列它们的位置？</p>\n<p>下图展示了「前短后长」和「前长后短」两种方案：</p>\n<p><img src=\"2.jpg\" /></p>\n<p>可以发现，前短后长的方案更优。</p>\n<p>扩展得到猜想，同一单词的所有子树中，大小更小的应在更前面。该结论是可递归的。</p>\n<hr />\n<p>接下来对猜想进行证明。</p>\n<p>假设现在已有一条链。我们只有把整条链连在一起，短单词放到长单词前面这一种方法。</p>\n<p>然后新来了一个不属于这条链的节点，明显，因为节点不管放到哪里，其 <span class=\"math inline\">\\(y\\)</span> 值不变，但会改变已有链的 <span class=\"math inline\">\\(y\\)</span> 值，所以放到最前面最优。</p>\n<p>又来了一个节点，和刚才新增的节点属于同一条链，一样，不管这个节点何去何从，其 <span class=\"math inline\">\\(y\\)</span> 不变，但放在越前面，后面的节点的 <span class=\"math inline\">\\(y\\)</span> 值增加得越多。</p>\n<p>以此类推可得到结论，同一条链放到一起。短链放到长链前面也是比较好想的。假设有两条链，短链长度为 <span class=\"math inline\">\\(a\\)</span>，长链长度为 <span class=\"math inline\">\\(b\\)</span>，放置起点为 <span class=\"math inline\">\\(l\\)</span>，则前短后长和钱长后短的 y 之和分别为 <span class=\"math inline\">\\(\\dfrac{(l + l + a - 2) \\times (a - 1) + (l + a + l + a + b - 2) \\times (b - 1)} 2\\)</span> 和 <span class=\"math inline\">\\(\\dfrac{(l + l + b - 2) \\times (b - 1) + (l + b + l + b + a - 2) \\times (b - 1)} 2\\)</span>（运用等差数列求和公式），解不等式可得前短后长一定更优。</p>\n<p>接下来是从链扩展到树。那么我们想到了什么？树链剖分。</p>\n<p>我们化用树剖思想，以最轻边为剖分条件，将树划分为有顺序的链，按照上述方式排列其顺序即可。</p>\n<p>此时我们记录下每个单词的直系父亲（即其最长前缀单词），在唯一序列中模拟计分操作，即可得到答案。</p>\n<hr />\n<p>为了方便，可将所有入度为 <span class=\"math inline\">\\(0\\)</span> 的点与一个虚点相连，将森林转化为树。</p>\n<p>注意 <code>long long</code>。</p>\n<details>\n<pre class=\"cpp\"><code>namespace XSC062 &#123;\nusing namespace fastIO;\nusing str = std::string;\nconst int maxn = 1e6 + 5;\nconst int maxm = 1e6 + 5;\nstr s[maxn];\nint T[maxm][26];\nint kaz[maxn], siz[maxn]; // kaz 表示单词在最终序列中所处的位置\nstd::vector&lt;int&gt; g[maxn];\nint n, l, res, cnt = 1, ti;\nint tot[maxm], fa[maxn], deg[maxn];\nvoid Insert(int k) &#123; \n    int f = 1, len = s[k].length();\n    for(int i = 0; i &lt; len; ++i) &#123;\n        if (!T[f][s[k][i] - &#39;a&#39;]) \n            T[f][s[k][i] - &#39;a&#39;] = ++cnt;\n        f = T[f][s[k][i]-&#39;a&#39;];\n    &#125;\n    tot[f] = k;\n    return;\n&#125;\nvoid Search(int k) &#123;\n    int f = 1;\n    int len = s[k].length();\n    for (int i = 0; i &lt; len; ++i) &#123;\n        f = T[f][s[k][i] - &#39;a&#39;];\n        if (tot[f]) &#123;\n            if (tot[f] != k)\n                fa[k] = tot[f]; // 记录当前最长前缀\n        &#125;\n    &#125;\n    return;\n&#125;\nvoid add(int x, int y) &#123;\n    ++deg[y];\n    g[x].push_back(y);\n    return;\n&#125;\nvoid DFS1(int x) &#123; // 提前计算每个子树的 size\n    siz[x] = 1;\n    for (auto i : g[x]) &#123;\n        DFS1(i);\n        siz[x] += siz[i];\n    &#125;\n    return;\n&#125;\nvoid DFS2(int x) &#123;\n    kaz[x] = ti++;  // 时间戳即为单词位置\n    std::sort(g[x].begin(), g[x].end(),\n        [&amp;](int x, int y) &#123; return siz[x] &lt; siz[y]; &#125;); // 按子树 size 排序\n    for (auto i : g[x])\n        DFS2(i);\n    return;\n&#125;\nint main() &#123;\n    scanf(&quot;%lld&quot;, &amp;n);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; s[i];\n        std::reverse(s[i].begin(), s[i].end());  // 后缀转前缀\n        Insert(i);\n        res += i;\n    &#125;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        Search(i);\n        if (fa[i])\n            add(fa[i], i); // 建图\n    &#125;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        if (!deg[i]) // 建虚点方便操作\n            add(n + 1, i), fa[i] = n + 1;\n    &#125;\n    DFS1(n + 1), DFS2(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        res -= kaz[fa[i]]; // 处理 y 值\n    print(res);\n    return 0;\n&#125;\n&#125; // namespace XSC062</code></pre>\n</details>\n",
            "tags": [
                "字典树"
            ]
        }
    ]
}