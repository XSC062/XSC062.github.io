{
    "version": "https://jsonfeed.org/version/1",
    "title": "null • All posts by \"线段树\" tag",
    "description": "",
    "home_page_url": "https://xsc062.netlify.app",
    "items": [
        {
            "id": "https://xsc062.netlify.app/20250819/",
            "url": "https://xsc062.netlify.app/20250819/",
            "title": "log 数据结构的一些题",
            "date_published": "2025-08-19T01:44:25.000Z",
            "content_html": "<p>线段树、树状数组、倍增、分治（朴素分治 / CDQ / 整体二分）、平衡树、字典树、笛卡尔树</p>\n<p>多乎哉？不多也。</p>\n<span id=\"more\"></span>\n<hr />\n<p>题目来源：</p>\n<ol type=\"1\">\n<li>llsw’s pdf</li>\n<li>洛谷文章广场题解区搜索对应算法</li>\n<li>自己以前的一些零散题解</li>\n</ol>\n<p>找了一些有数据结构方面思维难点的题，实现难度通常不会很大，也有少许粑粑夹杂其中</p>\n<hr />\n<p><code>#</code> 是缺题解，<code>*</code> 是缺代码</p>\n<hr />\n<h2 id=\"线段树\">线段树</h2>\n<h3 id=\"维护特殊信息\">维护特殊信息</h3>\n<h4 id=\"金鱼草区间覆盖信息\">金鱼草（区间覆盖信息）</h4>\n<p><a href=\"http://222.180.160.110:61235/contest/6051/problem/4\" class=\"uri\">http://222.180.160.110:61235/contest/6051/problem/4</a></p>\n<blockquote>\n<p>给定 <span class=\"math inline\">\\(n\\)</span> 个区间 <span class=\"math inline\">\\([l,r]\\)</span>，给出 <span class=\"math inline\">\\(q\\)</span> 个询问，每次询问 <span class=\"math inline\">\\([L,R]\\)</span> 是否能被表示为若干 <span class=\"math inline\">\\([l,r]\\)</span> 的并集。注意不能覆盖到 <span class=\"math inline\">\\([L,R]\\)</span> 之外的点。</p>\n<p><span class=\"math inline\">\\(n,q\\le 5\\times 10^5,|V|\\le 10^9\\)</span>。</p>\n</blockquote>\n<ul>\n<li>题目所求等价于 check 满足 <span class=\"math inline\">\\(l\\ge L\\land r\\le R\\)</span> 的所有区间是否能够覆盖 <span class=\"math inline\">\\([L,R]\\)</span></li>\n<li>这个很简单，需要区间修改的做法就不提了。可以想一下有没有只需要单点修改的做法</li>\n<li><p>发现权值线段树可以维护「一段连续左端点对应区间的并」是否是连续的：</p>\n维护位于区间内的左端点最后一个覆盖到的点 <span class=\"math inline\">\\(rv\\)</span>（可以在区间外；发现从区间左端点到 <span class=\"math inline\">\\(rv\\)</span> 会被连续覆盖），<strong>区间内</strong>最后一个没有被覆盖到的点 <span class=\"math inline\">\\(p\\)</span>，和表示区间是否能被完整覆盖的标记 <span class=\"math inline\">\\(flag\\)</span>。pushup 是容易的。</li>\n<li><p>容易发现如果我们在树上询问 <span class=\"math inline\">\\([L,R]\\)</span> 中所有左端点的 <span class=\"math inline\">\\(flag\\)</span>，无法保证参与覆盖的 <span class=\"math inline\">\\(r\\le R\\)</span>。故离线下来扫描线即可。</p>\n<p>实际上由于未知原因跑得很可能不如区间修改的方法快 TAT</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 5e5 + 5;\nstruct _ &#123;\n    bool flag;\n    int l, r, rv, p;\n&#125; t[maxn &lt;&lt; 2];\n#define lt (p &lt;&lt; 1)\n#define rt (lt | 1)\nvoid pushup(int p) &#123;\n    t[p].rv = std::max(t[lt].rv, t[rt].rv);\n    if (!t[lt].flag) &#123;\n        t[p].flag = 0;\n        if (!t[rt].flag &amp;&amp; t[lt].rv &lt; t[rt].p)\n            t[p].p = t[rt].p;\n        else\n            t[p].p = t[lt].p;\n    &#125;\n    else if (!t[rt].flag &amp;&amp; t[lt].rv &lt; t[rt].p)\n        t[p].flag = 0, t[p].p = t[rt].p;\n    else\n        t[p].flag = 1, t[p].p = 0;\n    return;\n&#125;\nvoid bld(int p, int l, int r) &#123;\n    t[p].l = l, t[p].r = t[p].p = r;\n    if (l == r)\n        return;\n    int mid = (l + r) &gt;&gt; 1;\n    bld(lt, l, mid), bld(rt, mid + 1, r);\n    return;\n&#125;\nvoid add(int p, int x, int v) &#123;\n    if(t[p].l == t[p].r) &#123;\n        t[p].flag = 1, t[p].p = 0;\n        t[p].rv = std::max(t[p].rv, v);\n        return;\n    &#125;\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (x &lt;= mid)\n        add(lt, x, v);\n    else\n        add(rt, x, v);\n    pushup(p);\n    return;\n&#125;\n_ ask(int p, int l, int r) &#123;\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r)\n        return t[p];\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (r &lt;= mid)\n        return ask(lt, l, r);\n    if (l &gt; mid)\n        return ask(rt, l, r);\n    auto ls(ask(lt, l, r)), rs(ask(rt, l, r));\n    if (!ls.flag) &#123;\n        if (!rs.flag &amp;&amp; ls.rv &lt; rs.p)\n            ls.p = rs.p;\n    &#125;\n    else if (!rs.flag &amp;&amp; ls.rv &lt; rs.p)\n        ls.flag = 0, ls.p = rs.p;\n    ls.rv = std::max(ls.rv, rs.rv);\n    return ls;\n&#125;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n    std::freopen(&quot;snapdragon.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;snapdragon.out&quot;, &quot;w&quot;, stdout);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, m, q;\n    std::cin &gt;&gt; m &gt;&gt; n &gt;&gt; q;\n    bld(1, 1, m);\n    std::vector&lt;std::vector&lt;int&gt; &gt; t(m + 1);\n    for (int i = 1, l, r; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; l &gt;&gt; r;\n        t[r].push_back(l);\n    &#125;\n    std::vector&lt;int&gt; res(q + 1);\n    std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; tq(m + 1);\n    for (int i = 1, l, r; i &lt;= q; ++i) &#123;\n        std::cin &gt;&gt; l &gt;&gt; r;\n        tq[r].emplace_back(l, i);\n    &#125;\n    for (int i = 1; i &lt;= m; ++i) &#123;\n        for (auto l : t[i])\n            add(1, l, i);\n        for (auto [l, id] : tq[i])\n            res[id] = ask(1, l, i).flag;\n    &#125;\n    for (int i = 1; i &lt;= q; ++i)\n        std::cout &lt;&lt; (res[i] ? &quot;YES&quot; : &quot;NO&quot;) &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<h4 id=\"题日-zapatak哈希\"># 题日 Zapatak（哈希）</h4>\n<p><a href=\"https://www.luogu.com.cn/problem/P11262\" class=\"uri\">https://www.luogu.com.cn/problem/P11262</a></p>\n<h4 id=\"简单数据结构带一点递推性质\">简单数据结构（带一点递推性质）</h4>\n<p><a href=\"https://pjudge.ac/problem/21636\" class=\"uri\">https://pjudge.ac/problem/21636</a></p>\n<blockquote>\n<p>给定初始为空的多重集 <span class=\"math inline\">\\(p\\)</span>, <span class=\"math inline\">\\(q\\)</span>，这两个多重集中的元素都有 <span class=\"math inline\">\\(a,b\\)</span> 两种属性。需要需要维护 <span class=\"math inline\">\\(p\\)</span> 和 <span class=\"math inline\">\\(q\\)</span> 的加点和删点操作，询问 <span class=\"math inline\">\\(\\forall \\,i\\in p,j\\in q\\)</span>，<span class=\"math inline\">\\(\\max(i_x + j_x, i_y + j_y)\\)</span> 的最小值。</p>\n<p><span class=\"math inline\">\\(m\\le 10^6,V\\le 10^9\\)</span>。</p>\n</blockquote>\n<ul>\n<li>考虑<strong>对不等式恒等变形，转化为偏序问题</strong>。若 <span class=\"math inline\">\\(a_{i,0}+b_{j,0}\\ge a_{i,1}+b_{j,1}\\)</span>，则 <span class=\"math inline\">\\(a_{i,0}-a_{i,1}\\ge b_{j,1}-b_{j,0}\\)</span>。</li>\n<li><p>把 <span class=\"math inline\">\\(a\\)</span> 按照 <span class=\"math inline\">\\(a_{i,0}-a_{i,1}\\)</span> 排序、把 <span class=\"math inline\">\\(b\\)</span> 按照 <span class=\"math inline\">\\(b_{j,1}-b_{j,0}\\)</span> 排序。</p>\n<p>要求某个时刻的答案，需要对于每一个 <span class=\"math inline\">\\(i\\)</span> 找到最小的 <span class=\"math inline\">\\(b_{j,0}\\)</span>，使得 <span class=\"math inline\">\\(b_{j,1}-b_{j,0}\\)</span> 在 <span class=\"math inline\">\\([-\\infty, a_{i,0}-a_{i,1}]\\)</span> 中，同时找到最小的 <span class=\"math inline\">\\(b_{j,1}\\)</span>，使得 <span class=\"math inline\">\\(b_{j,1}-b_{j,0}\\)</span> 在 <span class=\"math inline\">\\([a_{i, 0}-a_{i,1},+\\infty]\\)</span> 中。</p>\n<p>这个带有一点递推的性质，在线段树 pushup 的时候，用左边的 <span class=\"math inline\">\\(b_{j,0}\\)</span> 结合右边的答案得到父亲的答案。</p></li>\n</ul>\n<p><em>听说我之前赛时切了这题？怎么没印象。llsw 讲题的时候说要离线，但是没想到离线做法 orz</em></p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int inf = 2e9 + 1;\nstruct _ &#123; long long aa, ab, ba, bb, u; int l, r, id; &#125;;\nstd::vector&lt;_&gt; t(1);\nstd::vector&lt;std::multiset&lt;long long&gt; &gt; aa(1), ab(1), ba(1), bb(1);\nint tot, cnt;\n#define lt t[p].l\n#define rt t[p].r\nvoid pushup(int p) &#123;\n    t[p].aa = t[p].ab = t[p].ba = t[p].bb = t[p].u = inf;\n    if (lt) &#123;\n        t[p].u = t[lt].u;\n        t[p].aa = t[lt].aa, t[p].ab = t[lt].ab, t[p].ba = t[lt].ba, t[p].bb = t[lt].bb;\n    &#125;\n    if (rt) &#123;\n        t[p].u = std::min(t[p].u, t[rt].u);\n        t[p].aa = std::min(t[p].aa, t[rt].aa);\n        t[p].ab = std::min(t[p].ab, t[rt].ab);\n        t[p].ba = std::min(t[p].ba, t[rt].ba);\n        t[p].bb = std::min(t[p].bb, t[rt].bb);\n    &#125;\n    if (lt &amp;&amp; rt)\n        t[p].u = std::min(&#123; t[p].u, t[lt].ba + t[rt].aa, t[lt].ab + t[rt].bb &#125;);\n    return;\n&#125;\nint adda(int p, long long l, long long r, int x, int a, int b) &#123;\n    if (!p)\n        p = ++tot, t.emplace_back(), t[p].aa = t[p].ab = t[p].ba = t[p].bb = t[p].u = inf;\n    if (l == r) &#123;\n        if (!t[p].id)\n            t[p].id = ++cnt, aa.emplace_back(), ab.emplace_back(), ba.emplace_back(), bb.emplace_back();\n        int id = t[p].id;\n        aa[id].insert(a), ab[id].insert(b);\n        t[p].aa = *aa[id].begin(), t[p].ab = *ab[id].begin();\n        if (!aa[id].empty() &amp;&amp; !ba[id].empty())\n            t[p].u = std::min(*aa[id].begin() + *ba[id].begin(), *ab[id].begin() + *bb[id].begin());\n        else\n            t[p].u = inf;\n        return p;\n    &#125;\n    long long mid = (l + r) &gt;&gt; 1;\n    if (x &lt;= mid) &#123;\n        auto s(adda(lt, l, mid, x, a, b));\n        lt = s;\n    &#125;\n    else &#123;\n        auto s(adda(rt, mid + 1, r, x, a, b));\n        rt = s;\n    &#125;\n    pushup(p);\n    return p;\n&#125;\nint addb(int p, long long l, long long r, int x, int a, int b) &#123;\n    if (!p)\n        p = ++tot, t.emplace_back(), t[p].aa = t[p].ab = t[p].ba = t[p].bb = t[p].u = inf;\n    if (l == r) &#123;\n        if (!t[p].id)\n            t[p].id = ++cnt, aa.emplace_back(), ab.emplace_back(), ba.emplace_back(), bb.emplace_back();\n        int id = t[p].id;\n        ba[id].insert(a), bb[id].insert(b);\n        t[p].ba = *ba[id].begin(), t[p].bb = *bb[id].begin();\n        if (!aa[id].empty() &amp;&amp; !ba[id].empty())\n            t[p].u = std::min(*aa[id].begin() + *ba[id].begin(), *ab[id].begin() + *bb[id].begin());\n        else\n            t[p].u = inf;\n        return p;\n    &#125;\n    long long mid = (l + r) &gt;&gt; 1;\n    if (x &lt;= mid) &#123;\n        auto s(addb(lt, l, mid, x, a, b));\n        lt = s;\n    &#125;\n    else &#123;\n        auto s(addb(rt, mid + 1, r, x, a, b));\n        rt = s;\n    &#125;\n    pushup(p);\n    return p;\n&#125;\nvoid dela(int p, long long l, long long r, int x, int a, int b) &#123;\n    if (l == r) &#123;\n        int id = t[p].id;\n        aa[id].erase(aa[id].find(a)), ab[id].erase(ab[id].find(b));\n        t[p].aa = (aa[id].empty() ? inf : *aa[id].begin());\n        t[p].ab = (ab[id].empty() ? inf : *ab[id].begin());\n        if (!aa[id].empty() &amp;&amp; !ba[id].empty())\n            t[p].u = std::min(*aa[id].begin() + *ba[id].begin(), *ab[id].begin() + *bb[id].begin());\n        else\n            t[p].u = inf;\n        return;\n    &#125;\n    long long mid = (l + r) &gt;&gt; 1;\n    if (x &lt;= mid)\n        dela(lt, l, mid, x, a, b);\n    else\n        dela(rt, mid + 1, r, x, a, b);\n    pushup(p);\n    return;\n&#125;\nvoid delb(int p, long long l, long long r, int x, int a, int b) &#123;\n    if (l == r) &#123;\n        int id = t[p].id;\n        ba[id].erase(ba[id].find(a)), bb[id].erase(bb[id].find(b));\n        t[p].ba = (ba[id].empty() ? inf : *ba[id].begin());\n        t[p].bb = (bb[id].empty() ? inf : *bb[id].begin());\n        if (!aa[id].empty() &amp;&amp; !ba[id].empty())\n            t[p].u = std::min(*aa[id].begin() + *ba[id].begin(), *ab[id].begin() + *bb[id].begin());\n        else\n            t[p].u = inf;\n        return;\n    &#125;\n    long long mid = (l + r) &gt;&gt; 1;\n    if (x &lt;= mid)\n        delb(lt, l, mid, x, a, b);\n    else\n        delb(rt, mid + 1, r, x, a, b);\n    pushup(p);\n    return;\n&#125;\n#undef lt\n#undef rt\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n    std::freopen(&quot;set.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;set.out&quot;, &quot;w&quot;, stdout);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int q, rt = 0;\n    std::cin &gt;&gt; q;\n    for (int i = 1; i &lt;= q; ++i) &#123;\n        int op, d, a, b;\n        std::cin &gt;&gt; op &gt;&gt; d &gt;&gt; a &gt;&gt; b;\n        if (op == 0 &amp;&amp; d == 0)\n            dela(rt, -inf, inf, a - b, a, b);\n        else if (op == 0)\n            delb(rt, -inf, inf, b - a, a, b);\n        else if (d == 0)\n            rt = adda(rt, -inf, inf, a - b, a, b);\n        else\n            rt = addb(rt, -inf, inf, b - a, a, b);\n        std::cout &lt;&lt; (t[1].u == inf ? -1 : t[1].u) &lt;&lt; &#39;\\n&#39;;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h4 id=\"命运利用线段树的分治结构递推\"># 命运（利用线段树的分治结构递推）</h4>\n<p><a href=\"https://www.luogu.com.cn/problem/P6773\" class=\"uri\">https://www.luogu.com.cn/problem/P6773</a></p>\n<hr />\n<h4 id=\"对数据结构的爱维护函数\">* 对数据结构的爱（维护函数）</h4>\n<p><a href=\"https://www.luogu.com.cn/problem/P5609\" class=\"uri\">https://www.luogu.com.cn/problem/P5609</a></p>\n<blockquote>\n<p>给定长度为 <span class=\"math inline\">\\(n\\)</span> 的数组 <span class=\"math inline\">\\(a\\)</span> 和模数 <span class=\"math inline\">\\(p\\)</span>（<span class=\"math inline\">\\(a_i\\)</span> 初始可能比 <span class=\"math inline\">\\(p\\)</span> 大很多，还有可能为负），给定 <span class=\"math inline\">\\(m\\)</span> 次询问，每次问区间 <span class=\"math inline\">\\([l,r]\\)</span>，进行这样的操作：</p>\n<p>初始 <span class=\"math inline\">\\(sum=0\\)</span>，从 <span class=\"math inline\">\\(l\\)</span> 到 <span class=\"math inline\">\\(r\\)</span>，依次令 <span class=\"math inline\">\\(sum\\gets sum+a_i\\)</span>，当且仅当 <span class=\"math inline\">\\(sum\\ge p\\)</span> 时令 <span class=\"math inline\">\\(sum\\gets sum-p\\)</span>（注意这不是取模，减完之后还是可能 <span class=\"math inline\">\\(\\ge p\\)</span>）。</p>\n<p>问最终 <span class=\"math inline\">\\(sum\\)</span> 的值。<span class=\"math inline\">\\(n\\le 10^6,m\\le 2\\times 10^5\\)</span>。</p>\n</blockquote>\n<p>考虑线段树维护函数。定义 <span class=\"math inline\">\\(f(x)\\)</span> 表示区间上想要减去 <span class=\"math inline\">\\(x\\)</span> 次 <span class=\"math inline\">\\(p\\)</span> 需要的最小初始值（这样才能让定义域和区间长有关），查询时直接二分即可；考虑初始化时如何合并。</p>\n<p>首先思考较为暴力的做法，对于左侧点 <span class=\"math inline\">\\(a\\)</span> 和右侧点 <span class=\"math inline\">\\(b\\)</span>，若 <span class=\"math inline\">\\(f(a+1)-1+s_l-a\\cdot p\\ge f(b)\\)</span>，也即可以减去 <span class=\"math inline\">\\(a+b\\)</span> 次，就可以用 <span class=\"math inline\">\\(\\max(f(a),f(b)-s_l+a\\cdot p)\\)</span> 来更新 <span class=\"math inline\">\\(f(a+b)\\)</span>。</p>\n<p>发现 <span class=\"math inline\">\\((a,b)\\)</span> 的贡献一定小于 <span class=\"math inline\">\\((a+1,b-1)\\)</span> 的贡献；具体地，发现 <span class=\"math inline\">\\(f(x+1)-f(x)\\ge p\\)</span> 后就很显然了。采用双指针，优先移动 <span class=\"math inline\">\\(b\\)</span>，就能把最短区间扫一遍。</p>\n<details>\n<p><summary>关于线段树维护函数</summary></p>\n<p>维护一个函数，形如 <span class=\"math inline\">\\(f_{[l,r]}(x)\\)</span> 表示在 <span class=\"math inline\">\\([l,r]\\)</span> 区间上，<span class=\"math inline\">\\(x\\)</span> 的一个映射</p>\n<p>如果相邻区间的函数可以用某种方式合并，就可以用线段树来维护</p>\n<p>把树建在值域上，就可以在节点内把这段区间每个点对应的函数值存下来。一般来说是静态的，因为这是一个类前缀和的形式，没办法修改</p>\n<p>每个点的点值数组会在当前层被扫一遍，上一层被扫一遍，如果合并能够做到线性，总复杂度就是单 <span class=\"math inline\">\\(\\log\\)</span> 的。</p>\n<p>实际情形下函数本身可能很隐秘、很抽象，怎么优化到线性合并也不太好想</p>\n</details>\n<hr />\n<h4 id=\"compounds模意义下问题\">* COmPoUNdS（模意义下问题）</h4>\n<p><a href=\"https://www.luogu.com.cn/problem/P12389\" class=\"uri\">https://www.luogu.com.cn/problem/P12389</a></p>\n<blockquote>\n<p>给定常数模数，维护模意义下的区间加、区间哈希。<span class=\"math inline\">\\(n\\le 10^6\\)</span>。</p>\n</blockquote>\n<p><strong>线段树哈希是可以维护区间加的</strong>，但是没办法维护区间取模</p>\n<p>类似 <a href=\"/20250816/#e---subarray-sum-divisibility\">ABC419E</a> 里面用到的，模意义下序列全等可以转化成差分全等，区间修改就可以简化成单点修改了</p>\n<p>额外判一下开头的元素（维护原数组或者是差分数组之和）是否相等就可以了</p>\n<hr />\n<h4 id=\"改进代码模意义下问题\">* 改进代码（模意义下问题）</h4>\n<p><a href=\"https://www.luogu.com.cn/problem/P4635\" class=\"uri\">https://www.luogu.com.cn/problem/P4635</a></p>\n<blockquote>\n<p>给定序列 <span class=\"math inline\">\\(a_{1\\sim n}\\)</span> 和常数 <span class=\"math inline\">\\(p\\)</span>，维护:</p>\n<ul>\n<li>修改：模 <span class=\"math inline\">\\(p\\)</span> 意义下区间加；</li>\n<li>询问：区间中 <span class=\"math inline\">\\(\\sum\\limits_{i=l}^{r-1}[a_i&gt;a_{i+1}]\\)</span>。</li>\n</ul>\n<p><span class=\"math inline\">\\(n\\le 10^5,p\\le 10^6\\)</span>。</p>\n</blockquote>\n<p>询问也和模意义差分有关系，假如 <span class=\"math inline\">\\(s\\)</span> 为当前差分数组前缀和模 <span class=\"math inline\">\\(p\\)</span> 的值（也就是原数），发现<strong>前一个数 <span class=\"math inline\">\\(&gt;\\)</span> 后一个数当且仅当 <span class=\"math inline\">\\(s\\)</span> 加爆了</strong>。维护原数组用来确定 <span class=\"math inline\">\\(s\\)</span> 的初值。再维护区间内差分数组之和（不取模），<strong>在这个和里有多少个 <span class=\"math inline\">\\(p\\)</span> 就会爆多少次</strong>。</p>\n<hr />\n<h4 id=\"黑白树很新的东西\">黑白树（很新的东西）</h4>\n<p><a href=\"http://222.180.160.110:61235/problem/46907\" class=\"uri\">http://222.180.160.110:61235/problem/46907</a></p>\n<hr />\n<h3 id=\"以楼房重建为代表的-log2-一类前缀信息维护\">以楼房重建为代表的 <span class=\"math inline\">\\(\\log^2\\)</span> 一类前缀信息维护</h3>\n<p>特点：pushup 时需要先获得一边的信息，在另一边进行线段树上二分，单次操作是 <span class=\"math inline\">\\(O(\\log^2)\\)</span> 的</p>\n<p>本质是一类具有<strong>单调性</strong>的前 / 后缀信息，<strong>区间对全局的贡献</strong>和<strong>区间外的信息</strong>有关，故不能直接维护对全局的贡献，只能维护区间内的答案。但由于两个子区间答案可以合并出大区间答案（通过线段树上二分得到需要的信息），所以只需要逐层向上合并就可以得到全局答案</p>\n<p>一个名字是『线段树维护前缀信息』，感觉不很精确。log 方线段树又是什么鬼名字？更多还是叫的楼房重建线段树吧</p>\n<hr />\n<h4 id=\"楼房重建\">楼房重建</h4>\n<p><a href=\"https://www.luogu.com.cn/problem/P4198\" class=\"uri\">https://www.luogu.com.cn/problem/P4198</a></p>\n<blockquote>\n<p>给定 <span class=\"math inline\">\\(a_{1\\sim n}\\)</span>，维护 <span class=\"math inline\">\\(q\\)</span> 次操作：</p>\n<ul>\n<li>单点修改；</li>\n<li>查询 <span class=\"math inline\">\\(\\dfrac{a_i}i\\)</span> 的前缀最大值序列长度。</li>\n</ul>\n<p><span class=\"math inline\">\\(n,q\\le 10^5\\)</span>。</p>\n</blockquote>\n<p>Fractures 说当年（初一）是他力荐 gm 给我们拉这个题的。dashena！</p>\n<ul>\n<li>线段树维护单调栈，或者说前缀最值，维护方式过于经典，使得『楼房重建』成为该 trick 称呼之一</li>\n<li><p>考虑 pushup。保留左边整段区间，对于左区间序列末的元素 <code>l.rv</code>，我们在右区间内找到第一个大于之的元素 <span class=\"math inline\">\\(x\\)</span>，从它开始的序列就是答案。</p>\n反证法易得 <span class=\"math inline\">\\(x\\)</span> 一定在右区间答案序列内：若 <span class=\"math inline\">\\(x\\)</span> 不在答案序列内，则右区间内存在一个 <span class=\"math inline\">\\(&gt;x\\)</span> 且位于 <span class=\"math inline\">\\(x\\)</span> 之前的元素，那么 <span class=\"math inline\">\\(x\\)</span> 就不是第一个 <code>&gt; l.rv</code> 的元素，矛盾。</li>\n<li><p>故在右区间中二分能够接上去的区间长度，加起来即可。</p>\n<p>题目只要求总区间答案，故不需要查询。动态开点可能需要小心处理一下。</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 1e5 + 5;\nstruct &#123;\n    int l, r, u;\n    double lv, rv, mv;\n&#125; t[maxn &lt;&lt; 2];\nint tot;\n#define lt t[p].l\n#define rt t[p].r\nint askt(int p, int l, int r, double v) &#123;\n    if (l == r)\n        return t[p].u;\n    int mid = (l + r) &gt;&gt; 1;\n    if (lt &amp;&amp; t[p].mv &gt; v)\n        return t[p].u - t[lt].u + askt(lt, l, mid, v);\n    return askt(rt, mid + 1, r, v);\n&#125;\nvoid pushup(int p, int l, int r) &#123;\n    t[p].mv = t[lt].rv;\n    if (lt &amp;&amp; rt) &#123;\n        t[p].lv = t[lt].lv;\n        t[p].rv = std::max(t[lt].rv, t[rt].rv);\n        if (t[lt].rv &lt; t[rt].lv)\n            t[p].u = t[lt].u + t[rt].u;\n        else if (t[lt].rv &gt;= t[rt].rv)\n            t[p].u = t[lt].u;\n        else &#123;\n            int mid = (l + r) &gt;&gt; 1;\n            t[p].u = t[lt].u + askt(rt, mid + 1, r, t[lt].rv);\n        &#125;\n    &#125;\n    else &#123;\n        t[p].u = t[lt + rt].u;\n        t[p].lv = t[lt + rt].lv, t[p].rv = t[lt + rt].rv;\n    &#125;\n    return;\n&#125;\nvoid upd(int &amp;p, int l, int r, int x, double v) &#123;\n    if (!p)\n        p = ++tot;\n    if (l == r) &#123;\n        t[p].lv = t[p].rv = v, t[p].u = 1;\n        return;\n    &#125;\n    int mid = (l + r) &gt;&gt; 1;\n    if (x &lt;= mid)\n        upd(lt, l, mid, x, v);\n    else\n        upd(rt, mid + 1, r, x, v);\n    pushup(p, l, r);\n    return;\n&#125;\n#undef lt\n#undef rt\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;P4198_2.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, m, rt = 0;\n    std::cin &gt;&gt; n &gt;&gt; m;\n    std::vector&lt;double&gt; a(n + 1);\n    for (int x; m--; ) &#123;\n        double y;\n        std::cin &gt;&gt; x &gt;&gt; y;\n        a[x] = y / x;\n        upd(rt, 1, n, x, y / x);\n        std::cout &lt;&lt; t[1].u &lt;&lt; &#39;\\n&#39;;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h4 id=\"二叉搜索树\">二叉搜索树</h4>\n<p><a href=\"https://pjudge.ac/problem/21889\" class=\"uri\">https://pjudge.ac/problem/21889</a></p>\n<blockquote>\n<p>给定一个大小为 <span class=\"math inline\">\\(n\\)</span> 的树，树上每个元素是一个 BST，你需要维护 <span class=\"math inline\">\\(q\\)</span> 次操作：</p>\n<ol type=\"1\">\n<li>对于树上的一条路径 <span class=\"math inline\">\\((u,v)\\)</span>，在经过的所有节点上的 BST 插入 <span class=\"math inline\">\\(x\\)</span>，保证任意时刻 BST 中无相同值</li>\n<li>在点 <span class=\"math inline\">\\(u\\)</span> 查找 <span class=\"math inline\">\\(x\\)</span>，如果 <span class=\"math inline\">\\(x\\)</span> 存在则返回其到 BST 根的元素和，否则返回查找时最远走到的那个点，到 BST 根的元素和。</li>\n</ol>\n<p><span class=\"math inline\">\\(n,q\\le 2\\times 10^5\\)</span>。</p>\n</blockquote>\n<ul>\n<li>考虑链上问题。差分，把更新 <span class=\"math inline\">\\([l, r]\\)</span> 看作在差分数组 <span class=\"math inline\">\\(l\\)</span> 处插入，在 <span class=\"math inline\">\\(r+1\\)</span> 处删除，离线下来再从左到右扫一遍操作就能更新。</li>\n<li>考虑查询。<span class=\"math inline\">\\(i\\)</span> 树上存在过的所有元素是已知的，考虑如何基于此获取 <span class=\"math inline\">\\(i\\)</span> 树上 <span class=\"math inline\">\\(t_0\\)</span> 时刻，<span class=\"math inline\">\\(x\\)</span> 的所有祖先。</li>\n<li><p>对于比 <span class=\"math inline\">\\(x\\)</span> 大的元素，考虑祖先 <span class=\"math inline\">\\(p_a\\)</span> 和非祖先 <span class=\"math inline\">\\(p\\)</span> 的区别：</p>\n<p>根据 BST 的性质易得，对于最低的右侧祖先 <span class=\"math inline\">\\({p_a}_0\\)</span>，其是 <span class=\"math inline\">\\(\\ge x\\)</span> 的最小的元素（加入时刻 <span class=\"math inline\">\\(t_a&lt;t_0\\)</span>）；</p>\n同理可以找到 <span class=\"math inline\">\\({p_a}_0\\)</span> 右侧最低的祖先（其左侧的祖先显然也在 <span class=\"math inline\">\\(x\\)</span> 左侧），该祖先满足 <span class=\"math inline\">\\(t&lt;t_a\\)</span>。从左右两边分别得到 <span class=\"math inline\">\\(x\\)</span> 的所有祖先。容易证明该过程对于不在树上的 <span class=\"math inline\">\\(x\\)</span> 也是正确的。</li>\n<li>具体地，需要能够求出 <span class=\"math inline\">\\(\\ge x\\)</span> 的元素中，以 <span class=\"math inline\">\\(t_0\\)</span> 为起点的前缀最小值序列的区间和。线段树维护单调栈容易解决不带 <span class=\"math inline\">\\(t_0\\)</span> 限制的答案；再次利用性质就能满足限制。</li>\n<li><p>对于树的情况，把差分放到树上，线段树合并即可。</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int lim = 2e5;\nconst int maxn = 2e7 + 5;\nconst int inf = 0x3f3f3f3f;\nstruct &#123;\n    int l, r, rv;\n    long long u;\n&#125; t[maxn];\nstd::vector&lt;int&gt; tr;\n#define lt t[p].l\n#define rt t[p].r\nint newnode(void) &#123;\n    static int tot = 0;\n    if (tr.empty())\n        return ++tot;\n    auto p(tr.back());\n    t[p].l = t[p].r = 0;\n    tr.pop_back();\n    return p;\n&#125;\nlong long askv(int p, int l, int r, int v) &#123;\n    if (l == r)\n        return t[p].rv &lt; v ? t[p].u : 0;\n    int mid = (l + r) &gt;&gt; 1;\n    if (v &gt; t[lt].rv)\n        return t[p].u - t[lt].u + askv(lt, l, mid, v);\n    return askv(rt, mid + 1, r, v);\n&#125;\nvoid pushup(int p, int l, int r) &#123;\n    t[p].rv = std::min(t[lt].rv, t[rt].rv);\n    int mid = (l + r) &gt;&gt; 1;\n    t[p].u = t[lt].u + askv(rt, mid + 1, r, t[lt].rv);\n    return;\n&#125;\nvoid upd(int &amp;p, int l, int r, int x, int v, int u) &#123;\n    if (!p)\n        p = newnode();\n    if (l == r) &#123;\n        t[p].rv = v, t[p].u = u;\n        return;\n    &#125;\n    int mid = (l + r) &gt;&gt; 1;\n    if (x &lt;= mid)\n        upd(lt, l, mid, x, v, u);\n    else\n        upd(rt, mid + 1, r, x, v, u);\n    pushup(p, l, r);\n    return;\n&#125;\nvoid merge(int &amp;p, int q, int l, int r) &#123;\n    if (!p || !q) &#123;\n        p += q;\n        return;\n    &#125;\n    if (l == r) &#123;\n        t[p].rv = std::min(t[p].rv, t[q].rv);\n        t[p].u = std::max(t[p].u, t[q].u);\n        return;\n    &#125;\n    int mid = (l + r) &gt;&gt; 1;\n    merge(t[p].l, t[q].l, l, mid), merge(t[p].r, t[q].r, mid + 1, r);\n    pushup(p, l, r), tr.push_back(q);\n    return;\n&#125;\nint qv = inf;\nlong long ask(int p, int l, int r, int ql, int qr) &#123;\n    if (ql &lt;= l &amp;&amp; r &lt;= qr) &#123;\n        auto s(askv(p, l, r, qv));\n        qv = std::min(qv, t[p].rv);\n        return s;\n    &#125;\n    int mid = (l + r) &gt;&gt; 1;\n    long long res = 0ll;\n    if (ql &lt;= mid)\n        res = ask(lt, l, mid, ql, qr);\n    if (qr &gt; mid)\n        res += ask(rt, mid + 1, r, ql, qr);\n    return res;\n&#125;\n#undef lt\n#undef rt\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;ex_problem4.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, m;\n    std::cin &gt;&gt; n &gt;&gt; m;\n    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);\n    for (int i = 1, x, y; i &lt; n; ++i) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y;\n        g[x].push_back(y), g[y].push_back(x);\n    &#125;\n    std::vector&lt;int&gt; top(n + 1), fa(n + 1), siz(n + 1), son(n + 1), dep(n + 1);\n    std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int faa) &#123;\n        siz[x] = 1;\n        for (auto i : g[x])\n            if (i != faa) &#123;\n                fa[i] = x, dep[i] = dep[x] + 1;\n                DFS(i, x), siz[x] += siz[i];\n                if (siz[i] &gt; siz[son[x]])\n                    son[x] = i;\n            &#125;\n        return;\n    &#125;;\n    DFS(1, -1);\n    DFS = [&amp;](int x, int topp) &#123;\n        top[x] = topp;\n        if (son[x])\n            DFS(son[x], topp);\n        for (auto i : g[x])\n            if (i != fa[x] &amp;&amp; i != son[x])\n                DFS(i, i);\n        return;\n    &#125;;\n    DFS(1, 1);\n    auto getLCA = [&amp;](int x, int y) &#123;\n        for (; top[x] != top[y]; x = fa[top[x]])\n            if (dep[top[y]] &gt; dep[top[x]])\n                std::swap(x, y);\n        return (dep[x] &lt; dep[y] ? x : y);\n    &#125;;\n    std::vector&lt;std::vector&lt;int&gt; &gt; d(n + 1);\n    std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; u(n + 1);\n    std::vector&lt;std::vector&lt;std::tuple&lt;int, int, int&gt; &gt; &gt; q(n + 1);\n    int cnt = 0;\n    for (int i = 1; i &lt;= m; ++i) &#123;\n        int op;\n        std::cin &gt;&gt; op;\n        if (op == 0) &#123;\n            int x, v;\n            std::cin &gt;&gt; x &gt;&gt; v;\n            q[x].emplace_back(++cnt, i, v);\n        &#125; else &#123;\n            int x, y, v;\n            std::cin &gt;&gt; x &gt;&gt; y &gt;&gt; v;\n            int faa = getLCA(x, y);\n            u[x].emplace_back(i, v), u[y].emplace_back(i, v);\n            if (fa[faa])\n                d[fa[faa]].emplace_back(v);\n        &#125;\n    &#125;\n    std::vector&lt;long long&gt; res(cnt + 1);\n    std::vector&lt;std::vector&lt;int&gt; &gt; rt(2, std::vector&lt;int&gt; (n + 1));\n    t[0].rv = inf;\n    DFS = [&amp;](int x, int fa) &#123;\n        for (auto i : g[x])\n            if (i != fa) &#123;\n                DFS(i, x);\n                merge(rt[0][x], rt[0][i], 1, lim);\n                merge(rt[1][x], rt[1][i], 1, lim);\n            &#125;\n        for (auto [t, v] : u[x]) &#123;\n            upd(rt[0][x], 1, lim, v, t, v);\n            upd(rt[1][x], 1, lim, lim - v + 1, t, v);\n        &#125;\n        for (auto v : d[x]) &#123;\n            upd(rt[0][x], 1, lim, v, inf, 0);\n            upd(rt[1][x], 1, lim, lim - v + 1, inf, 0);\n        &#125;\n        for (auto [id, t, v] : q[x]) &#123;\n            qv = t, res[id] = ask(rt[0][x], 1, lim, v, lim);\n            qv = t, res[id] += ask(rt[1][x], 1, lim, lim - v + 1, lim);\n            qv = t, res[id] -= ask(rt[0][x], 1, lim, v, v);\n        &#125;\n    &#125;;\n    DFS(1, -1);\n    for (int i = 1; i &lt;= cnt; ++i)\n        std::cout &lt;&lt; res[i] &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h4 id=\"nastya-and-cbs\">Nastya and CBS</h4>\n<p><a href=\"https://www.luogu.com.cn/problem/CF1340F\" class=\"uri\">https://www.luogu.com.cn/problem/CF1340F</a></p>\n<blockquote>\n<p>给定长度为 <span class=\"math inline\">\\(n\\)</span> 的括号序列，由 <span class=\"math inline\">\\(k\\)</span> 种括号对（<span class=\"math inline\">\\(-i,i\\)</span> 表示第 <span class=\"math inline\">\\(i\\)</span> 种左、右括号）组成，你需要维护单点修改元素、区间查询是否为合法括号序列。</p>\n<p><span class=\"math inline\">\\(1\\le k\\le n\\le 10^5,q\\le 10^5\\)</span>。</p>\n</blockquote>\n<ul>\n<li>考虑不带修且允许 <span class=\"math inline\">\\(O(n)\\)</span> 询问的情景，经典题，扫一遍，用栈维护即可；</li>\n<li><p><span class=\"math inline\">\\(k=1\\)</span> 时是线段树经典题，可以类比这个经典题，从刻画合法的条件入手。</p>\n如果存在相邻且可以匹配的可以直接消掉，一直重复这样的操作，此时要么包含不能匹配的子串，如 <code>&#123;[)&#125;</code>，要么是 <code>)]&#125; (&#123;[&#123;&#123;</code> 的形式。</li>\n<li>考虑怎么 pushup，发现中间生成的一段 <code>([()])</code> 必须完全匹配，消掉它们之后，大区间又变成 <code>)]&#125; (&#123;[&#123;&#123;</code> 的形式。</li>\n<li>每次 pushup 要合并的区间很长，考虑怎么快速地做『消除相邻匹配括号』这一步。容易想到记录一段括号（例：<code>([&#123;</code>）及其对应反括号（例：<code>&#125;])</code>）的哈希值，check 是否相等，然后就可以不管它们了，并不是真的要删去。</li>\n<li><p>线段树不能维护每个前后缀的哈希值，但需要的只是在<strong>删除连续匹配括号后</strong>长度为 <span class=\"math inline\">\\(len\\)</span> 的哈希值，可以线段树上二分。</p>\n这个过程有点困难，需要在询问的同时匹配、消除；但发现所谓消除就是对位相减，注意一下什么时候移位，还是好写的。</li>\n<li><p>询问看似不太可做，因为中途的答案不是线段树的节点；如果把询问看成一次修改，就可以用类似可持久化的方式实现。</p>\n<p>由于并不是真的要可持久化，询问新建的点可以重复利用。如果不重复利用，每次询问最多新建 <span class=\"math inline\">\\(O(\\log n)\\)</span> 个点，空间复杂度 <span class=\"math inline\">\\(O(q\\log n)\\)</span>，在 CF 上有点卡，也是能过的。</p></li>\n</ul>\n<details>\n<p>Hint：有卡 998244353 的 Hack，故可以用 1e9 + 7 当模数；WA on 7 是正确性有巨大问题，WA on 8 可能是 long long 没开完 / 数组开小了 / 哈希方向有问题 / 线段树上二分写挂了（通常是消括号消错了）。前人踩坑后人嘲笑。</p>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 1e9 + 7;\nconst int base = 1e5 + 3;\nconst int maxn = 7e5 + 5;\nstruct Node &#123;\n    bool flag;\n    long long hr0, hl1;\n    int l, r, lc, rc, ll, rl;\n    Node&amp; operator= (const Node &amp;q) &#123;\n        flag = q.flag, hr0 = q.hr0, hl1 = q.hl1;\n        l = q.l, r = q.r, ll = q.ll, rl = q.rl;\n        return *this;\n    &#125;\n    Node operator+ (const Node &amp;q) const;\n&#125; t[maxn &lt;&lt; 2];\nint tot;\nint a[maxn];\nlong long bpow[maxn], inv[maxn];\nlong long askhl1(const Node &amp;p, int k) &#123;\n    if (k == 0)\n        return 0ll;\n    if (k &gt; p.ll)\n        return -1ll;\n    if (p.ll == k)\n        return p.hl1;\n    int ll = t[p.lc].ll, rl = t[p.lc].rl;\n    if (ll &gt;= k)\n        return askhl1(t[p.lc], k);\n    k -= ll, k += rl;\n    auto hl1 = askhl1(t[p.rc], k);\n    hl1 = ((hl1 + mod - t[p.lc].hr0) * inv[rl] % mod * bpow[ll] % mod + t[p.lc].hl1) % mod;\n    return hl1;\n&#125;\nlong long askhr0(const Node &amp;p, int k) &#123;\n    if (k == 0)\n        return 0ll;\n    if (k &gt; p.rl)\n        return -1ll;\n    if (p.rl == k)\n        return p.hr0;\n    int rl = t[p.rc].rl, ll = t[p.rc].ll;\n    if (rl &gt;= k)\n        return askhr0(t[p.rc], k);\n    k -= rl, k += ll;\n    auto hr0 = askhr0(t[p.lc], k);\n    hr0 = ((hr0 + mod - t[p.rc].hl1) * inv[ll] % mod * bpow[rl] % mod + t[p.rc].hr0) % mod;\n    return hr0;\n&#125;\nNode Node::operator+ (const Node &amp;q) const  &#123;\n    Node res;\n    res.l = l, res.r = q.r;\n    if (flag || q.flag)\n        res.flag = 1;\n    else &#123;\n        if (rl == q.ll) &#123;\n            if (hr0 == q.hl1) &#123;\n                res.flag = 0;\n                res.ll = ll, res.rl = q.rl;\n                res.hl1 = hl1, res.hr0 = q.hr0;\n            &#125;\n            else\n                res.flag = 1;\n        &#125;\n        else if (rl &lt; q.ll) &#123;\n            auto qhl1 = askhl1(q, rl);\n            if (hr0 == qhl1) &#123;\n                res.flag = 0;\n                res.ll = ll + q.ll - rl, res.rl = q.rl;\n                res.hl1 = ((q.hl1 + mod - qhl1) % mod * inv[rl] % mod * bpow[ll] % mod + hl1) % mod;\n                res.hr0 = q.hr0;\n            &#125;\n            else\n                res.flag = 1;\n        &#125;\n        else &#123;\n            auto phr0 = askhr0(*this, q.ll);\n            if (phr0 == q.hl1) &#123;\n                res.flag = 0;\n                res.ll = ll, res.rl = rl - q.ll + q.rl;\n                res.hl1 = hl1;\n                res.hr0 = ((hr0 + mod - phr0) % mod * inv[q.ll] % mod * bpow[q.rl] % mod + q.hr0) % mod;\n            &#125;\n            else\n                res.flag = 1;\n        &#125;\n    &#125;\n    return res;\n&#125;\nvoid bld(int &amp;p, int l, int r) &#123;\n    p = ++tot;\n    if (l == r) &#123;\n        t[p].l = t[p].r = l;\n        if (a[l] &lt; 0)\n            t[p].ll = 1, t[p].hl1 = -a[l];\n        else\n            t[p].rl = 1, t[p].hr0 = a[l];\n        return;\n    &#125;\n    int mid = (l + r) &gt;&gt; 1;\n    bld(t[p].lc, l, mid), bld(t[p].rc, mid + 1, r);\n    t[p] = t[t[p].lc] + t[t[p].rc];\n    return;\n&#125;\nvoid add(int p, int x, int v) &#123;\n    if (t[p].l == t[p].r) &#123;\n        if (v &lt; 0) &#123;\n            t[p].rl = 0, t[p].hr0 = 0ll;\n            t[p].ll = 1, t[p].hl1 = -v;\n        &#125;\n        else &#123;\n            t[p].ll = 0, t[p].hl1 = 0ll;\n            t[p].rl = 1, t[p].hr0 = v;\n        &#125;\n        return;\n    &#125;\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (x &lt;= mid)\n        add(t[p].lc, x, v);\n    else\n        add(t[p].rc, x, v);\n    t[p] = t[t[p].lc] + t[t[p].rc];\n    return;\n&#125;\nint ask(int p, int l, int r) &#123;\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r)\n        return p;\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (r &lt;= mid)\n        return ask(t[p].lc, l, r);\n    if (l &gt; mid)\n        return ask(t[p].rc, l, r);\n    int q = ++tot;\n    t[q].lc = ask(t[p].lc, l, r);\n    t[q].rc = ask(t[p].rc, l, r);\n    t[q] = t[t[q].lc] + t[t[q].rc];\n    return q;\n&#125;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, k, rt = 0;\n    std::cin &gt;&gt; n &gt;&gt; k;\n    bpow[0] = inv[0] = 1ll;\n    auto qkp = [&amp;](long long x, int y) &#123;\n        auto res(1ll);\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    inv[1] = qkp(base, mod - 2);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; a[i];\n        bpow[i] = bpow[i - 1] * base % mod;\n        if (i &gt;= 2)\n            inv[i] = inv[i - 1] * inv[1] % mod;\n    &#125;\n    bld(rt, 1, n);\n    int q;\n    std::cin &gt;&gt; q;\n    for (int op; q--; ) &#123;\n        std::cin &gt;&gt; op;\n        if (op == 1) &#123;\n            int x, v;\n            std::cin &gt;&gt; x &gt;&gt; v;\n            add(1, x, v);\n        &#125;\n        else &#123;\n            int l, r;\n            std::cin &gt;&gt; l &gt;&gt; r;\n            if ((r - l + 1) &amp; 1)\n                std::cout &lt;&lt; &quot;No&quot; &lt;&lt; &#39;\\n&#39;;\n            else &#123;\n                auto s(ask(1, l, r));\n                std::cout &lt;&lt; ((!t[s].flag &amp;&amp; !t[s].ll &amp;&amp; !t[s].rl) ? &quot;Yes&quot; : &quot;No&quot;) &lt;&lt; &#39;\\n&#39;;\n            &#125;\n        &#125;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h4 id=\"hungry-cow-p\"># Hungry Cow P</h4>\n<p><a href=\"https://www.luogu.com.cn/problem/P9130\" class=\"uri\">https://www.luogu.com.cn/problem/P9130</a></p>\n<hr />\n<h4 id=\"牛半仙的妹子序列\"># 牛半仙的妹子序列</h4>\n<p><a href=\"http://222.180.160.110:61235/problem/29550\" class=\"uri\">http://222.180.160.110:61235/problem/29550</a></p>\n<hr />\n<h4 id=\"organizing-a-race\"># Organizing a Race</h4>\n<p><a href=\"https://www.luogu.com.cn/problem/CF671E\" class=\"uri\">https://www.luogu.com.cn/problem/CF671E</a></p>\n<p>这个题不太应该放在这里的，因为存在只用一只 log 的纯线段树上二分做法，用楼房重建显得有点唐了</p>\n<hr />\n<h4 id=\"转盘\"># 转盘</h4>\n<p><a href=\"https://www.luogu.com.cn/problem/P4425\" class=\"uri\">https://www.luogu.com.cn/problem/P4425</a></p>\n<hr />\n<h4 id=\"前进四楼房重建-ver\"># 前进四（楼房重建 ver）</h4>\n<p><a href=\"https://uoj.ac/problem/515\" class=\"uri\">https://uoj.ac/problem/515</a></p>\n<p>另见 <a href=\"#-前进四segment-tree-beats-ver\">segment tree beats ver</a></p>\n<h3 id=\"可持久化线段树\">可持久化线段树</h3>\n<h4 id=\"card-game\"># Card Game</h4>\n<p><a href=\"https://qoj.ac/problem/8240\" class=\"uri\">https://qoj.ac/problem/8240</a></p>\n<hr />\n<h3 id=\"历史信息\">历史信息</h3>\n<h4 id=\"比赛\"># 比赛</h4>\n<p><a href=\"https://www.luogu.com.cn/problem/P8868\" class=\"uri\">https://www.luogu.com.cn/problem/P8868</a></p>\n<hr />\n<h4 id=\"v\"># V</h4>\n<p><a href=\"https://uoj.ac/problem/164\" class=\"uri\">https://uoj.ac/problem/164</a></p>\n<hr />\n<h4 id=\"cartesian-tree\"># Cartesian Tree</h4>\n<p><a href=\"https://www.luogu.com.cn/problem/CF1290E\" class=\"uri\">https://www.luogu.com.cn/problem/CF1290E</a></p>\n<hr />\n<h4 id=\"rprmq1\"># rprmq1</h4>\n<p><a href=\"https://www.luogu.com.cn/problem/P6109\" class=\"uri\">https://www.luogu.com.cn/problem/P6109</a></p>\n<hr />\n<h4 id=\"rpfrdtzls\"># rpfrdtzls</h4>\n<p><a href=\"https://www.luogu.com.cn/problem/P9057\" class=\"uri\">https://www.luogu.com.cn/problem/P9057</a></p>\n<hr />\n<h4 id=\"test_90\"># TEST_90</h4>\n<p><a href=\"https://www.luogu.com.cn/problem/P9990\" class=\"uri\">https://www.luogu.com.cn/problem/P9990</a></p>\n<hr />\n<h3 id=\"线段树合并\">线段树合并</h3>\n<p>树上的线段树合并都很熟悉了，利用了线段树合并是线性的，以及 dsu on tree</p>\n<p>不如说绝大多数线段树合并都有树上背景，因为自带合并顺序和复杂度保证</p>\n<p>Tip：树上合并的背景下，线段树合并的表现会比主席树优秀很多，因为前者跑不满</p>\n<p>不在树上的问题，题目可能会通过各种方式保证复杂度，比如保证每个点只会被合并一次之类</p>\n<hr />\n<h4 id=\"迁移计划-migration-plan\"># 迁移计划 / Migration Plan</h4>\n<p><a href=\"https://www.luogu.com.cn/problem/P11993\" class=\"uri\">https://www.luogu.com.cn/problem/P11993</a></p>\n<hr />\n<h4 id=\"永无乡\"># 永无乡</h4>\n<p><a href=\"https://www.luogu.com.cn/problem/P3224\" class=\"uri\">https://www.luogu.com.cn/problem/P3224</a></p>\n<hr />\n<h4 id=\"语言\"># 语言</h4>\n<p><a href=\"https://www.luogu.com.cn/problem/P5327\" class=\"uri\">https://www.luogu.com.cn/problem/P5327</a></p>\n<hr />\n<h4 id=\"梦幻布丁\"># 梦幻布丁</h4>\n<p><a href=\"https://www.luogu.com.cn/problem/P3201\" class=\"uri\">https://www.luogu.com.cn/problem/P3201</a></p>\n<hr />\n<p>还有两个比较屎的 P7563 和 P7963</p>\n<h3 id=\"扫描线\">扫描线</h3>\n<p>离线，按照下标排序，扫一遍处理询问，就可以利用『所有更靠前的下标都以被计算过』来处理问题</p>\n<p>不只局限于区间询问，单点的可能反而更难一点，需要发现和下标大小有关的性质</p>\n<h4 id=\"等差子序列\">等差子序列</h4>\n<p><a href=\"https://www.luogu.com.cn/problem/P2757\" class=\"uri\">https://www.luogu.com.cn/problem/P2757</a></p>\n<blockquote>\n<p>给定一个 <span class=\"math inline\">\\(n\\)</span> 的排列，问是否能找到 <span class=\"math inline\">\\(len\\ge 3\\)</span> 的子序列，使得其是等差的。</p>\n<p><span class=\"math inline\">\\(n\\le 5\\times 10^5\\)</span>。</p>\n</blockquote>\n<p>根据单调性，可以简化为 <span class=\"math inline\">\\(len=3\\)</span> 时的答案</p>\n<p>也就是对于中项 <span class=\"math inline\">\\(j\\)</span>，能不能找到 <span class=\"math inline\">\\(i&lt;j&lt;k\\)</span>，使得 <span class=\"math inline\">\\(a_j-a_i=a_k-a_j\\)</span>。从下标出发，差值是不好维护的；注意到是排列，可以从值出发，转化成是否存在一个 <span class=\"math inline\">\\(d\\)</span>，使得 <span class=\"math inline\">\\(a_j-d\\)</span> 在之前出现，<span class=\"math inline\">\\(a_j+d\\)</span> 在之后出现。</p>\n<p>利用下标『之前』和『之后』的限制，做扫描线，查看是否存在 <span class=\"math inline\">\\(d\\)</span> 使 <span class=\"math inline\">\\(a_j-d\\)</span> 出现过但是 <span class=\"math inline\">\\(a_j+d\\)</span> 没有出现过；还是因为是排列，数量只会为 <span class=\"math inline\">\\(0\\)</span> 或 <span class=\"math inline\">\\(1\\)</span>，如果非法说明 <span class=\"math inline\">\\(a_j-d\\)</span> 和 <span class=\"math inline\">\\(a_j+d\\)</span> 都是 <span class=\"math inline\">\\(0\\)</span> 或者都是 <span class=\"math inline\">\\(1\\)</span>，发现是关于 <span class=\"math inline\">\\(a_j\\)</span> 的回文，故权值线段树维护哈希，如果 <span class=\"math inline\">\\(a_j\\)</span> 两侧全部回文，说明 <span class=\"math inline\">\\(j\\)</span> 不是合法中项。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nnamespace fastIO &#123;\nconst int LEN = (1 &lt;&lt; 20);\n#ifdef ONLINE_JUDGE\ninline int nec(void) &#123;\n    static char buf[LEN], *p = buf, *e = buf;\n    if (p == e) &#123;\n        e = buf + fread(buf, 1, LEN, stdin);\n        if (e == buf)\n            return EOF;\n        p = buf;\n    &#125;\n    return *p++;\n&#125;\n#else\n#define nec getchar\n#endif\ninline bool read(int &amp;x) &#123;\n    x = 0;\n    bool f = 0;\n    char ch = nec();\n    while (ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123;\n        if (ch == EOF)\n            return 0;\n        if (ch == &#39;-&#39;)\n            f = 1;\n        ch = nec();\n    &#125;\n    while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) &#123;\n        x = x * 10 + ch - &#39;0&#39;;\n        ch = nec();\n    &#125;\n    if (f)\n        x = -x;\n    return 1;\n&#125;\nvoid print(int x) &#123;\n    if (x &lt; 0) &#123;\n        putchar(&#39;-&#39;);\n        x = -x;\n    &#125;\n    if (x &gt;= 10)\n        print(x / 10);\n    putchar(x % 10 + &#39;0&#39;);\n    return;\n&#125;\nvoid print(int x, char ch) &#123;\n    print(x);\n    putchar(ch);\n    return;\n&#125;\n&#125; // namespace fastIO\nnamespace XSC062 &#123;\nusing namespace fastIO;\n#define lt (p &lt;&lt; 1)\n#define rt (lt | 1)\nusing sc = unsigned long long;\nconst int p = 13331; // 0103 ¿É°®µÎÄó \nconst int lim = 5e5;\nconst int maxn = 5e5 + 5;\nstruct _ &#123;\n    int l, r;\n    sc lh, rh;\n&#125;;\nint T, n;\nint a[maxn];\nsc base[maxn];\n_ t[maxn &lt;&lt; 2];\nint min(int x, int y) &#123;\n    return x &lt; y ? x : y;\n&#125;\nint max(int x, int y) &#123;\n    return x &gt; y ? x : y;\n&#125;\nvoid pushup(int p) &#123;\n    int ll = t[lt].r - t[lt].l + 1;\n    int rl = t[rt].r - t[rt].l + 1;\n    t[p].lh = t[lt].lh * base[rl] + t[rt].lh;\n    t[p].rh = t[rt].rh * base[ll] + t[lt].rh;\n    return;\n&#125;\nvoid bld(int p, int l, int r) &#123;\n    t[p].lh = t[p].rh = 0;\n    t[p].l = l, t[p].r = r;\n    if (l == r)\n        return;\n    int mid = (l + r) &gt;&gt; 1;\n    bld(lt, l, mid);\n    bld(rt, mid + 1, r);\n    return;\n&#125;\nvoid upd(int p, int x, int v) &#123;\n    if (t[p].l == t[p].r) &#123;\n        t[p].lh = t[p].rh = v;\n        return;\n    &#125;\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (x &lt;= mid)\n        upd(lt, x, v);\n    else upd(rt, x, v);\n    pushup(p);\n    return;\n&#125;\nsc qryl(int p, int l, int r) &#123;\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r)\n        return t[p].lh;\n    sc ans = 0;\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (l &lt;= mid)\n        ans = qryl(lt, l, r);\n    if (r &gt; mid) &#123;\n        ans *= base[min(r, t[p].r) - mid];\n        ans += qryl(rt, l, r);\n    &#125;\n    return ans;\n&#125;\nsc qryr(int p, int l, int r) &#123;\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r)\n        return t[p].rh;\n    sc ans = 0;\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (r &gt; mid)\n        ans = qryr(rt, l, r);\n    if (l &lt;= mid) &#123;\n        ans *= base[mid - max(l, t[p].l) + 1];\n        ans += qryr(lt, l, r);\n    &#125;\n    return ans;\n&#125;\nint main() &#123;\n    read(T);\n    base[0] = 1;\n    for (int i = 1; i &lt;= lim; ++i)\n        base[i] = base[i - 1] * p;\n    while (T--) &#123;\n        read(n);\n        bld(1, 1, n);\n        for (int i = 1; i &lt;= n; ++i)\n            read(a[i]);\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            int len = min(n - a[i], a[i] - 1);\n            if (i &gt; 1) &#123;\n                upd(1, a[i - 1], 1);\n            &#125;\n            if (len == 0)\n                continue;\n            int l = a[i] - len;\n            int r = a[i] + len;\n            if (qryl(1, l, a[i] - 1) !=\n                qryr(1, a[i] + 1, r)) &#123;\n                puts(&quot;Y&quot;);\n                goto isSol;\n            &#125;\n        &#125;\n        puts(&quot;N&quot;);\n        isSol: ;\n    &#125;\n    return 0;\n&#125;\n&#125; // namespace XSC062\nint main() &#123;\n    XSC062::main();\n    return 0;\n&#125;</code></pre>\n</details>\n<h4 id=\"小奇的糖果\">小奇的糖果</h4>\n<p><a href=\"https://hydro.ac/p/bzoj-P4548\" class=\"uri\">https://hydro.ac/p/bzoj-P4548</a></p>\n<blockquote>\n<p>有 <span class=\"math inline\">\\(N\\)</span> 个有颜色（<span class=\"math inline\">\\(M\\)</span> 种）的点在平面上，在平面上取一条水平的线段，可以选择线段上方的所有点，也可以选择下方的所有点。找出一条线段和选取的方向，使得在选取的点不包含所有颜色的前提下，最大化选到点的数量。</p>\n<p><span class=\"math inline\">\\(N,M\\le 10^6,|x|,|y|\\le 10^9\\)</span>。</p>\n</blockquote>\n<p>先离散化 + 按 <span class=\"math inline\">\\(y\\)</span> 排序降一维，贪心地枚举某种颜色 <span class=\"math inline\">\\(c\\)</span> 不选。考虑线段在平面最底部时的答案，取出所有颜色为 <span class=\"math inline\">\\(c\\)</span> 的点的 <span class=\"math inline\">\\(x\\)</span> 坐标，只能选择相邻的 <span class=\"math inline\">\\(x\\)</span> 之间的所有点。枚举每一对相邻的点计算答案。把线段上移，如果碰到了一个颜色为 <span class=\"math inline\">\\(c\\)</span> 的点，就说明这个点不再参与限制，删去即可，该点原前驱和后继围出来的区间就能够更新答案。用链表 / 单调栈就能很快地维护。</p>\n<p>先枚举颜色再跑扫描线是 <span class=\"math inline\">\\(O(n^2\\log n)\\)</span> 的，考虑优化。注意到数据结构里存在当前颜色没有影响，因为一定不在询问区间内。整体做扫描线，复杂度 <span class=\"math inline\">\\(O(n\\log n)\\)</span>。</p>\n<details>\n<pre class=\"cpp\"><code>namespace XSC062 &#123;\nusing namespace fastIO;\nconst int maxn = 2e5 + 5;\nstruct _ &#123;\n    int x, y, c;\n    bool operator&lt; (const _ &amp;q) const &#123;\n        return y &lt; q.y;\n    &#125;\n&#125;;\n_ a[maxn];\nint s[maxn], t[maxn];\nint ls[maxn], rs[maxn];\nint cp[maxn], cn[maxn];\nint pre[maxn], nex[maxn];\nstd::vector&lt;int&gt; g[maxn];\nint div[maxn], Bit[maxn];\nint T, n, k, tot, cnt, now, res;\nint max(int x, int y) &#123; return x &gt; y ? x : y; &#125;\nint lowbit(int x) &#123; return x &amp; -x; &#125;\nvoid add(int x, int v) &#123;\n    for (; x &lt;= n; x += lowbit(x)) Bit[x] += v;\n    return;\n&#125;\nint ask(int x) &#123;\n    int res = 0;\n    for (; x; x -= lowbit(x)) res += Bit[x];\n    return res;\n&#125;\nint ask(int l, int r) &#123;\n    if (l &gt; r) return 0;\n    return ask(r) - ask(l - 1);\n&#125;\nint main() &#123;\n//  freopen(&quot;1.in&quot;, &quot;r&quot;, stdin); \n    read(T);\n    while (T--) &#123;\n        read(n), read(k), now = res = 0;\n        for (int i = 1; i &lt;= k; ++i) &#123;\n            s[i] = ++now, t[i] = ++now;\n            div[s[i]] = 0, div[t[i]] = n + 1;\n            nex[s[i]] = t[i], pre[t[i]] = s[i];\n            pre[s[i]] = nex[t[i]] = 0;\n        &#125;\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            read(a[i].x), read(a[i].y), read(a[i].c);\n            ls[i] = a[i].x, rs[i] = a[i].y;\n        &#125;\n        std::sort(a + 1, a + n + 1, [&amp;](_ x, _ y) &#123; return x.x &lt; y.x; &#125;);\n        std::sort(ls + 1, ls + n + 1);\n        std::sort(rs + 1, rs + n + 1);\n        tot = std::unique(ls + 1, ls + n + 1) - ls - 1;\n        cnt = std::unique(rs + 1, rs + n + 1) - rs - 1;\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            a[i].x = std::lower_bound(ls + 1, ls + tot + 1, a[i].x) - ls;\n            a[i].y = std::lower_bound(rs + 1, rs + cnt + 1, a[i].y) - rs;\n        &#125;\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            div[++now] = a[i].x;\n            add(a[i].x, 1), g[a[i].y].push_back(now);\n            pre[now] = pre[t[a[i].c]], nex[pre[t[a[i].c]]] = now;\n            pre[t[a[i].c]] = now, nex[now] = t[a[i].c];\n        &#125;\n        memcpy(cp, pre, sizeof (cp));\n        memcpy(cn, nex, sizeof (cn));\n        for (int i = 1; i &lt;= k; ++i) &#123;\n            for (int j = s[i]; j != t[i]; j = nex[j])\n                res = max(res, ask(div[j] + 1, div[nex[j]] - 1));\n        &#125;\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            for (auto j : g[i]) add(div[j], -1);\n            for (auto j : g[i]) &#123;\n                res = max(res, ask(div[pre[j]] + 1, div[nex[j]] - 1));\n                nex[pre[j]] = nex[j], pre[nex[j]] = pre[j];\n            &#125;\n        &#125;\n        for (int i = 1; i &lt;= n; ++i) add(a[i].x, 1);\n        for (int i = n; i; --i) &#123;\n            for (auto j : g[i]) add(div[j], -1);\n            for (auto j : g[i]) &#123;\n                res = max(res, ask(div[cp[j]] + 1, div[cn[j]] - 1));\n                cn[cp[j]] = cn[j], cp[cn[j]] = cp[j];\n            &#125;\n        &#125;\n        print(res, &#39;\\n&#39;);\n        for (int i = 1; i &lt;= n; ++i)\n            g[i].clear(), g[i].shrink_to_fit();\n    &#125;\n    return 0;\n&#125;\n&#125; // namespace XSC062</code></pre>\n</details>\n<hr />\n<h4 id=\"rmscne\">rmscne</h4>\n<p><a href=\"https://www.luogu.com.cn/problem/P7907\" class=\"uri\">https://www.luogu.com.cn/problem/P7907</a></p>\n<blockquote>\n<p>给定长为 <span class=\"math inline\">\\(n\\)</span> 的序列，<span class=\"math inline\">\\(q\\)</span> 次询问 <span class=\"math inline\">\\([l,r]\\)</span> 中的最短子区间 <span class=\"math inline\">\\([l&#39;,r&#39;]\\)</span>，使得其包含 <span class=\"math inline\">\\([l,r]\\)</span> 中出现的全部值。输出长度即可。</p>\n<p><span class=\"math inline\">\\(n,q,V\\le 2\\times 10^6\\)</span>。</p>\n</blockquote>\n<p>区间里面找子区间也是扫描线经典问题。</p>\n<p>区间种类数会有几种思路：集合哈希、前驱后继、莫队之类。PS：这个题用 ODT 可以拿到最优解</p>\n<p>对于 <span class=\"math inline\">\\(i=1\\sim n\\)</span>，依次考虑 <span class=\"math inline\">\\(i\\)</span> 作为右端点的情况。线段树维护每个 <span class=\"math inline\">\\(j\\)</span> 作为左端点时的 <span class=\"math inline\">\\(i-r_j\\)</span>，其中 <span class=\"math inline\">\\([j, r_j]\\)</span> 是与 <span class=\"math inline\">\\([j,i]\\)</span> 种类相同的最小区间。</p>\n<p>询问的时候，只需要找到最大的 <span class=\"math inline\">\\(j&#39;\\)</span>，满足 <span class=\"math inline\">\\([j, r]\\)</span> 与 <span class=\"math inline\">\\([l, r]\\)</span> 种类相同，求 <span class=\"math inline\">\\([l, j&#39;]\\)</span> 的区间和即可。找 <span class=\"math inline\">\\(j&#39;\\)</span> 可以记录前驱后继，初始每个 <span class=\"math inline\">\\(l\\)</span> 对应的 <span class=\"math inline\">\\(j&#39;\\)</span> 就是自己。若加入了一个与 <span class=\"math inline\">\\(l\\)</span> 相同的新元素，那么 <span class=\"math inline\">\\(l\\)</span> 就不再有贡献，此时 <span class=\"math inline\">\\(l\\)</span> 的 <span class=\"math inline\">\\(j&#39;\\)</span> 就会继承 <span class=\"math inline\">\\(l+1\\)</span> 的 <span class=\"math inline\">\\(j&#39;\\)</span>，这个过程用并查集即可简单维护。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int lim = 2e6;\nconst int maxn = 2e6 + 5;\nconst int maxm = 5e7 + 5;\nconst int inf = 0x3f3f3f3f;\nstruct &#123; int l, r, u, d; &#125; t[maxn &lt;&lt; 2];\nint tot;\n#define lt (p &lt;&lt; 1)\n#define rt (lt | 1)\nvoid pushdown(int p) &#123;\n    if (~t[p].d) &#123;\n        t[lt].d = t[rt].d = t[p].d;\n        t[lt].u = t[p].d - t[lt].r + 1;\n        t[rt].u = t[p].d - t[rt].r + 1;\n        t[p].d = -1;\n    &#125;\n    return;\n&#125;\nvoid bld(int p, int l, int r) &#123;\n    t[p].l = l, t[p].r = r, t[p].d = -1;\n    if (l == r)\n        return;\n    int mid = (l + r) &gt;&gt; 1;\n    bld(lt, l, mid), bld(rt, mid + 1, r);\n    return;\n&#125;\nvoid upd(int p, int l, int r, int v) &#123;\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r) &#123;\n        t[p].d = v, t[p].u = v - t[p].r + 1;\n        return;\n    &#125;\n    pushdown(p);\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (l &lt;= mid)\n        upd(lt, l, r, v);\n    if (r &gt; mid)\n        upd(rt, l, r, v);\n    t[p].u = std::min(t[lt].u, t[rt].u);\n    return;\n&#125;\nint ask(int p, int l, int r) &#123;\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r)\n        return t[p].u;\n    pushdown(p);\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1, res = inf;\n    if (l &lt;= mid)\n        res = ask(lt, l, r);\n    if (r &gt; mid)\n        res = std::min(res, ask(rt, l, r));\n    return res;\n&#125;\n#undef lt\n#undef rt\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, q;\n    std::cin &gt;&gt; n;\n    std::vector&lt;int&gt; a(n + 1), la(lim + 1), pre(n + 1), f(n + 1);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; a[i];\n        pre[i] = la[a[i]], la[a[i]] = i, f[i] = i;\n    &#125;\n    std::cin &gt;&gt; q;\n    std::vector&lt;int&gt; res(q + 1);\n    std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; t(n + 1);\n    for (int i = 1, l, r; i &lt;= q; ++i) &#123;\n        std::cin &gt;&gt; l &gt;&gt; r;\n        t[r].emplace_back(l, i);\n    &#125;\n    bld(1, 1, n);\n    std::function&lt;int(int)&gt; find = [&amp;](int x) &#123;\n        return x == f[x] ? x : f[x] = find(f[x]);\n    &#125;;\n    auto merge = [&amp;](int x, int y) &#123;\n        x = find(x), y = find(y);\n        f[std::min(x, y)] = std::max(x, y);\n        return;\n    &#125;;\n    for (int r = 1; r &lt;= n; ++r) &#123;\n        if (pre[r])\n            merge(pre[r], pre[r] + 1);\n        upd(1, pre[r] + 1, r, r);\n        for (auto [l, i] : t[r])\n            res[i] = ask(1, l, find(l));\n    &#125;\n    for (int i = 1; i &lt;= q; ++i)\n        std::cout &lt;&lt; res[i] &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h4 id=\"颜色\"># 颜色</h4>\n<p><a href=\"https://www.luogu.com.cn/problem/P4065\" class=\"uri\">https://www.luogu.com.cn/problem/P4065</a></p>\n<blockquote>\n<p>给定 <span class=\"math inline\">\\(n\\)</span> 个元素，每个元素有一个颜色。选择若干颜色（不能全选或全不选），问有多少种选取方案使得拥有这些颜色的点是一段连续的区间。</p>\n<p><span class=\"math inline\">\\(n\\le 3\\times 10^5\\)</span>。</p>\n</blockquote>\n<hr />\n<h3 id=\"势能线段树\">势能线段树</h3>\n<h4 id=\"市场\"># 市场</h4>\n<p><a href=\"https://loj.ac/p/6029\" class=\"uri\">https://loj.ac/p/6029</a></p>\n<hr />\n<h4 id=\"segment-tree-beats\"># Segment Tree Beats!</h4>\n<blockquote>\n<p>维护区间取 min，区间求和。</p>\n</blockquote>\n<p>pdf P57</p>\n<hr />\n<h4 id=\"segment-tree-beats-plus\"># Segment Tree Beats! Plus</h4>\n<blockquote>\n<p>维护区间加，区间取 min，区间求和。</p>\n</blockquote>\n<p>pdf P60</p>\n<hr />\n<h4 id=\"最假女选手\"># 最假女选手</h4>\n<p><a href=\"https://loj.ac/p/6565\" class=\"uri\">https://loj.ac/p/6565</a></p>\n<hr />\n<h4 id=\"mzl-loves-segment-tree\"># Mzl loves segment tree</h4>\n<p><a href=\"http://222.180.160.110:61235/problem/10203\" class=\"uri\">http://222.180.160.110:61235/problem/10203</a></p>\n<p>pdf P66</p>\n<hr />\n<h4 id=\"ctsn-loves-segment-tree\"># CTSN loves segment tree</h4>\n<p><a href=\"https://www.luogu.com.cn/problem/U180387\" class=\"uri\">https://www.luogu.com.cn/problem/U180387</a></p>\n<hr />\n<h4 id=\"前进四segment-tree-beats-ver\"># 前进四（segment tree beats ver）</h4>\n<p><a href=\"https://uoj.ac/problem/515\" class=\"uri\">https://uoj.ac/problem/515</a></p>\n<p>另见 <a href=\"#-前进四楼房重建-ver\">楼房重建 ver</a></p>\n<hr />\n<h4 id=\"基础数据结构练习题\"># 基础数据结构练习题</h4>\n<p><a href=\"https://uoj.ac/problem/228\" class=\"uri\">https://uoj.ac/problem/228</a></p>\n<hr />\n<h4 id=\"线段树-3\"># 线段树 3</h4>\n<p><a href=\"https://www.luogu.com.cn/problem/P6242\" class=\"uri\">https://www.luogu.com.cn/problem/P6242</a></p>\n<hr />\n<h4 id=\"赛格蒙特彼茨\"># 赛格蒙特彼茨</h4>\n<p>pdf P70</p>\n<hr />\n<h4 id=\"堕天作战-test_98\"># 堕天作战 TEST_98</h4>\n<p><a href=\"https://www.luogu.com.cn/problem/P9069\" class=\"uri\">https://www.luogu.com.cn/problem/P9069</a></p>\n<hr />\n<h3 id=\"线段树分治\">线段树分治</h3>\n<h4 id=\"八纵八横\"># 八纵八横</h4>\n<p><a href=\"https://www.luogu.com.cn/problem/P3733\" class=\"uri\">https://www.luogu.com.cn/problem/P3733</a></p>\n<h2 id=\"笛卡尔树\">笛卡尔树</h2>\n<p>一些思考方式和 trick 吧</p>\n<h3 id=\"由乃救爷爷\">* 由乃救爷爷</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P3793\" class=\"uri\">https://www.luogu.com.cn/problem/P3793</a></p>\n<blockquote>\n<p>尽可能快地维护随机序列区间最值。</p>\n</blockquote>\n<p>随机序列笛卡尔树期望深度是 <span class=\"math inline\">\\(\\log\\)</span>。就可以做了。</p>\n<p>来自 <a href=\"https://www.luogu.com/article/hj9ci08q\">UnyieldingTrilobite 的文章</a>：同样可以用悬线！<a href=\"/20231117/#随机序列悬线结合分块\">悬线 + 分块</a> 就可以做了。</p>\n<hr />\n<h3 id=\"情景剧最值的性质维护方式的取舍\">* 情景剧（最值的性质，维护方式的取舍）</h3>\n<p><a href=\"http://222.180.160.110:61235/contest/4273/problem/1\" class=\"uri\">http://222.180.160.110:61235/contest/4273/problem/1</a></p>\n<blockquote>\n<p>给定长度为 <span class=\"math inline\">\\(n\\)</span> 的序列 <span class=\"math inline\">\\(a_{1\\sim n}\\)</span>，找到一个区间，使得 区间长度 <span class=\"math inline\">\\(\\times\\)</span> 区间最大值 <span class=\"math inline\">\\(\\times\\)</span> 区间最小值 最大。输出最大值。</p>\n<p><span class=\"math inline\">\\(n\\le 10^6,V\\le 10^9\\)</span>。</p>\n</blockquote>\n<ul>\n<li>容易想到建笛卡尔树。这里的 最大值 和 最小值 地位相等吗？为什么？</li>\n<li>如果我们是钦定最大值，再去最大化『最小值 <span class=\"math inline\">\\(\\times\\)</span> 区间长』，好像没办法做，因为这个最大贡献没什么性质</li>\n<li><p>但如果钦定最小值，能取到的最长区间就是在小根笛卡尔树上的管辖区间，显然区间越长取到的最大值也越大，直接取这里的最大值即可</p>\n所以最大值和最小值地位不等是因为，区间长和最大值大小是正相关的，所以只需要最大化区间长，最大值也就最大化了</li>\n<li><p>所以在小根笛卡尔树上维护区间最大值即可</p></li>\n</ul>\n<hr />\n<h3 id=\"小蓝的好友\"># 小蓝的好友</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P2611\" class=\"uri\">https://www.luogu.com.cn/problem/P2611</a></p>\n<hr />\n<h3 id=\"星白-by-ttpandas笛卡尔树-dsu-on-tree\">星白 by TTpandaS（笛卡尔树 + dsu on tree）</h3>\n<p><a href=\"http://222.180.160.110:61235/contest/6517/problem/3\" class=\"uri\">http://222.180.160.110:61235/contest/6517/problem/3</a></p>\n<blockquote>\n<p>给定 <span class=\"math inline\">\\(n\\)</span> 的排列 <span class=\"math inline\">\\(a_{1\\sim n}\\)</span>，回答 <span class=\"math inline\">\\(q\\)</span> 个询问：</p>\n<ul>\n<li><p>给定 <span class=\"math inline\">\\([l,r]\\)</span>，是否存在 <span class=\"math inline\">\\(l\\le x&lt;y\\le r\\)</span>，使得：</p>\n<ul>\n<li><span class=\"math inline\">\\(a_x&lt;a_y\\)</span>，且 <span class=\"math inline\">\\(a_x\\)</span> 不为 <span class=\"math inline\">\\([x,y]\\)</span> 中最小值；</li>\n<li>令 <span class=\"math inline\">\\(a_i\\)</span> 为 <span class=\"math inline\">\\([x, y]\\)</span> 中最小值，则 <span class=\"math inline\">\\(a_i\\mid (a_x\\cdot a_y)\\)</span>。</li>\n</ul></li>\n</ul>\n<p><span class=\"math inline\">\\(n\\le 3\\times 10^5,q\\le10^6\\)</span>。</p>\n</blockquote>\n<ul>\n<li>容易想到对于 <span class=\"math inline\">\\(i\\)</span> 反过来找 <span class=\"math inline\">\\([x,y]\\)</span>。如果建立小根笛卡尔树，在 <span class=\"math inline\">\\(i\\)</span> 的左边找 <span class=\"math inline\">\\(x\\)</span>、右边找 <span class=\"math inline\">\\(y\\)</span>。</li>\n<li><p>一个自然的想法是对于左侧的每个 <span class=\"math inline\">\\(x\\)</span>，维护最近的合法 <span class=\"math inline\">\\(y\\)</span>；或是对于右侧的每个 <span class=\"math inline\">\\(y\\)</span>，维护最近的合法 <span class=\"math inline\">\\(x\\)</span>。</p>\n做一个 DSU on Tree，哪边区间短就维护哪边，是单 <span class=\"math inline\">\\(\\log\\)</span> 的。</li>\n<li><p>需要解决点内预处理，以 <span class=\"math inline\">\\(x\\)</span> 为例，对于每个 <span class=\"math inline\">\\(x\\)</span> 和当前点 <span class=\"math inline\">\\((p,l,r)\\)</span>，需要查询 <span class=\"math inline\">\\((p, r]\\)</span> 中最小的 <span class=\"math inline\">\\(y\\)</span>，使得 <span class=\"math inline\">\\(a_y\\)</span> 是 <span class=\"math inline\">\\(\\dfrac {a_p}{\\gcd(a_x,a_p)}\\)</span> 的倍数。离线下来扫描线，<del>开 <span class=\"math inline\">\\(n\\)</span> 棵线段树</del>，跑 <span class=\"math inline\">\\(n\\)</span> 次树状数组，用 <span class=\"math inline\">\\(y\\)</span> 更新所有 <span class=\"math inline\">\\(a_y\\)</span> 因数在 <span class=\"math inline\">\\(a_y\\)</span> 处的 min / max，可以在两个 log 内获得支配对类似物。</p>\n不是很理解为什么题目要再加一个偏序限制，除了增加代码量和用时外似乎并没有什么作用？</li>\n<li><p>查询时直接 rmq（这里唐了写了 st 表，实际上只需要前后缀）即可。整体复杂度 <span class=\"math inline\">\\(O(n\\log^2 n)\\)</span>。</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int LEN = (1 &lt;&lt; 20);\n#ifdef ONLINE_JUDGE\nint nec(void) &#123;\n    static char buf[LEN], *p = buf, *e = buf;\n    if (p == e) &#123;\n        e = buf + fread(buf, 1, LEN, stdin);\n        if (e == buf) return EOF;\n        p = buf;\n    &#125;\n    return *p++;\n&#125;\n#else\n#define nec getchar\n#endif\nbool read(int &amp;x) &#123;\n    x = 0;\n    bool f = 0;\n    char ch = nec();\n    while (ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123;\n        if (ch == EOF) return 0;\n        if (ch == &#39;-&#39;) f = 1;\n        ch = nec();\n    &#125;\n    while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) &#123;\n        x = x * 10 + ch - &#39;0&#39;;\n        ch = nec();\n    &#125;\n    if (f) x = -x;\n    return 1;\n&#125;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n;\n    read(n);\n    std::vector&lt;std::vector&lt;int&gt; &gt; mul(n + 1);\n    std::vector&lt;int&gt; a(n + 1), l(n + 1), r(n + 1), pos(n + 1);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        read(a[i]), pos[a[i]] = i;\n        for (l[i] = i; l[i] != 1 &amp;&amp; a[i] &lt; a[l[i] - 1]; l[i] = l[l[i] - 1]);\n    &#125;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        for (int j = i; j &lt;= n; j += i)\n            mul[i].push_back(pos[j]);\n        std::sort(mul[i].begin(), mul[i].end());\n    &#125;\n    for (int i = n; i; --i)\n        for (r[i] = i; r[i] != n &amp;&amp; a[i] &lt; a[r[i] + 1]; r[i] = r[r[i] + 1]);\n    struct query &#123; int id, l, r; &#125;;\n    std::vector&lt;std::vector&lt;query&gt; &gt; ql(n + 1), qr(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        if (i - l[i] &lt; r[i] - i)\n            for (int j = l[i]; j &lt; i; ++j)\n                qr[a[i] / std::__gcd(a[i], a[j])].push_back(&#123; j, i + 1, r[i] &#125;);\n        else\n            for (int j = i + 1; j &lt;= r[i]; ++j)\n                ql[a[i] / std::__gcd(a[i], a[j])].push_back(&#123; j, l[i], i - 1 &#125;);\n    std::vector&lt;int&gt; u(n + 1), rt(n + 1), bit(n + 1);\n    auto lowbit = [](int x) &#123;\n        return x &amp; -x;\n    &#125;;\n    auto add = [&amp;](int x, int v) &#123;\n        for (; x &lt;= n; x += lowbit(x))\n            bit[x] = v;\n        return;\n    &#125;;\n    std::function&lt;int(int)&gt; ask = [&amp;](int x) &#123;\n        int res = 0;\n        for (; x; x -= lowbit(x))\n            res = std::max(res, bit[x]);\n        return res;\n    &#125;;\n    for (int fac = 1; fac &lt;= n; ++fac) &#123;\n        std::sort(ql[fac].begin(), ql[fac].end(), [&amp;](query x, query y) &#123; return x.r &lt; y.r; &#125;);\n        auto i = mul[fac].begin();\n        for (auto [id, l, r] : ql[fac]) &#123;\n            for (; i != mul[fac].end() &amp;&amp; *i &lt;= r; ++i)\n                add(a[*i], *i);\n            auto mx(ask(a[id]));\n            if (mx &gt;= l)\n                u[id] = std::max(u[id], mx);\n        &#125;\n        for (auto i : mul[fac])\n            add(a[i], 0);\n    &#125;\n    bit.assign(n + 1, 0x3f3f3f3f);\n    ask = [&amp;](int x) &#123;\n        int res = 0x3f3f3f3f;\n        for (; x; x -= lowbit(x))\n            res = std::min(res, bit[x]);\n        return res;\n    &#125;;\n    for (int fac = 1; fac &lt;= n; ++fac) &#123;\n        std::sort(qr[fac].begin(), qr[fac].end(), [&amp;](query x, query y) &#123; return x.l &gt; y.l; &#125;);\n        std::reverse(mul[fac].begin(), mul[fac].end());\n        auto i = mul[fac].begin();\n        for (auto [id, l, r] : qr[fac]) &#123;\n            for (; i != mul[fac].end() &amp;&amp; *i &gt;= l; ++i)\n                add(n - a[*i] + 1, *i);\n            auto mn(ask(n - a[id] + 1));\n            if (mn &lt;= r)\n                u[mn] = std::max(u[mn], id);\n        &#125;\n        for (auto i : mul[fac])\n            add(n - a[i] + 1, 0x3f3f3f3f);\n    &#125;\n    std::vector&lt;std::vector&lt;int&gt; &gt; st(20, std::vector&lt;int&gt; (n + 1));\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        // if (u[i] != 0)\n        //     printf(&quot;%d %d\\n&quot;, u[i], i);\n        st[0][i] = u[i];\n    &#125;\n    for (int j = 1; (1 &lt;&lt; j) &lt;= n; ++j)\n        for (int i = 1; i + (1 &lt;&lt; j) - 1 &lt;= n; ++i)\n            st[j][i] = std::max(st[j - 1][i], st[j - 1][i + (1 &lt;&lt; (j - 1))]);\n    auto askmx = [&amp;](int l, int r) &#123;\n        int k = std::__lg(r - l + 1);\n        return std::max(st[k][l], st[k][r - (1 &lt;&lt; k) + 1]);\n    &#125;;\n    int q;\n    read(q);\n    for (int l, r; q--; ) &#123;\n        read(l), read(r);\n        std::cout &lt;&lt; (askmx(l, r) &gt;= l ? &quot;Yes&quot; : &quot;No&quot;) &lt;&lt; &#39;\\n&#39;;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"periodni\"># PERIODNI</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P6453\" class=\"uri\">https://www.luogu.com.cn/problem/P6453</a></p>\n<hr />\n<h2 id=\"cdq-分治\">CDQ 分治</h2>\n<h3 id=\"coloring-nodes偏序很隐秘\"># Coloring Nodes（偏序很隐秘）</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P12423\" class=\"uri\">https://www.luogu.com.cn/problem/P12423</a></p>\n<hr />\n<h2 id=\"字典树\">字典树</h2>\n<p>字典树作为 log 数据结构的时候，等价权值线段树，而且支持合并、分裂（权值线段树 also OK，强调一下而已）</p>\n<p>有些情景 Trie 写起来会比权值线段树舒服一些，比如值域操作、二进制操作之类</p>\n<h3 id=\"异或粽子\"># 异或粽子</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P5283\" class=\"uri\">https://www.luogu.com.cn/problem/P5283</a></p>\n<hr />\n<h3 id=\"friends\"># Friends</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/CF241B\" class=\"uri\">https://www.luogu.com.cn/problem/CF241B</a></p>\n",
            "tags": [
                "线段树"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20250816/",
            "url": "https://xsc062.netlify.app/20250816/",
            "title": "近期杂题 II",
            "date_published": "2025-08-16T08:14:12.000Z",
            "content_html": "<p>和 Aug 9th 的杂题不太能合并，所以分开了</p>\n<span id=\"more\"></span>\n<hr />\n<h2 id=\"b.-gas-fire-extinguishers\">B. GAS-Fire Extinguishers</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P3479\" class=\"uri\">https://www.luogu.com.cn/problem/P3479</a></p>\n<p>显然可以贪心，不妨从下到上，记录当前遍历过的、空余出来的灭火器（其实算的是可以供给的房间数）和还未分配灭火器的房间，按距离为 <span class=\"math inline\">\\(0\\sim k\\)</span> 分组。</p>\n<p>不难发现如果在某个点 <span class=\"math inline\">\\(u\\)</span> 处存在距离为 <span class=\"math inline\">\\(k\\)</span> 的空闲灭火器，可以贪心地分配给 <span class=\"math inline\">\\(u\\)</span>；如果存在距离为 <span class=\"math inline\">\\(k\\)</span> 的未分配房间，也可以在 <span class=\"math inline\">\\(u\\)</span> 处放置灭火器并分配给这些房间。类似地，进行两两配对一定是不劣的。</p>\n<p>发现同子树内距离为 <span class=\"math inline\">\\(k-1\\)</span> 的点对留到 <span class=\"math inline\">\\(fa\\)</span> 再匹配是不行的，因为这时距离会变成 <span class=\"math inline\">\\(k+1\\)</span>，不能匹配上；可以感受到这样是更劣的。</p>\n<p>然后就可以做了，根节点特殊乱贪心一下就行了。记得开 long long。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\n#define int long long\nsigned main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, s, k, res = 0;\n    std::cin &gt;&gt; n &gt;&gt; s &gt;&gt; k;\n    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1), p(n + 1, std::vector&lt;int&gt; (k + 1)), q(n + 1, std::vector&lt;int&gt; (k + 1));\n    for (int i = 1, x, y; i &lt; n; ++i) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y;\n        g[x].push_back(y), g[y].push_back(x);\n    &#125;\n    std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int fa) &#123;\n        for (auto i : g[x])\n            if (i != fa)  &#123;\n                DFS(i, x);\n                for (int j = 0; j &lt; k; ++j)\n                    p[x][j + 1] += p[i][j], q[x][j + 1] += q[i][j];\n            &#125;\n        ++q[x][0];\n        if (x != 1) &#123;\n            int v = (q[x][k] + s - 1) / s;\n            p[x][0] = v * s, res += v;\n            for (int i = 0; i &lt;= k; ++i) &#123;\n                int v = std::min(p[x][i], q[x][k - i]);\n                p[x][i] -= v, q[x][k - i] -= v;\n            &#125;\n            for (int i = 0; i &lt; k; ++i) &#123;\n                int v = std::min(p[x][i], q[x][k - 1 - i]);\n                p[x][i] -= v, q[x][k - 1 - i] -= v;\n            &#125;\n        &#125;\n        else &#123;\n            // std::cerr &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n            int sum = 0ll, r = 0;\n            for (int i = k; ~i; --i) &#123;\n                sum += p[x][k - i];\n                // std::cerr &lt;&lt; sum &lt;&lt; &#39;\\n&#39;;\n                int v = std::min(sum, q[x][i]);\n                sum -= v, q[x][i] -= v;\n                r += q[x][i];\n            &#125;\n            res += (r + s - 1) / s;\n        &#125;\n        return;\n    &#125;;\n    DFS(1, -1);\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"c.-扫地机器人\">C. 扫地机器人</h2>\n<p><a href=\"http://222.180.160.110:61235/contest/6502/problem/3\" class=\"uri\">http://222.180.160.110:61235/contest/6502/problem/3</a></p>\n<blockquote>\n<p>题意：给定 <span class=\"math inline\">\\(n\\)</span> 堆货物，每堆货物有重量 <span class=\"math inline\">\\(v_i\\)</span> 和一个参数 <span class=\"math inline\">\\(a_i\\)</span>。有一个初始负载为 <span class=\"math inline\">\\(0\\)</span>、负载上限为 <span class=\"math inline\">\\(c\\)</span> 的机器人，从 <span class=\"math inline\">\\(1\\)</span> 到 <span class=\"math inline\">\\(n\\)</span> 遍历这些货物，对每一处货物执行以下操作，直到清空这堆货物：</p>\n<ul>\n<li>当前负载未满：可以选择进行装载直到达到负载上限，或货物清空。花费 <span class=\"math inline\">\\(a_i\\)</span> 的代价。</li>\n<li>不管当前负载满没满：可以选择清空当前负载，花费 <span class=\"math inline\">\\(b\\)</span> 的代价。</li>\n</ul>\n<p>每一处可以任意操作，要求遍历完之后机器人负载为 <span class=\"math inline\">\\(0\\)</span>，问最小代价。<span class=\"math inline\">\\(n\\le 2\\times 10^5,c\\le 10^9\\)</span>。</p>\n</blockquote>\n<p><em>题面是重构过的，原来的题面太有歧义了。绝大多数人没做出来就是因为没看懂题吧！</em></p>\n<p>考虑暴力，可以想到令 <span class=\"math inline\">\\(f_{i,j}\\)</span> 表示处理完 <span class=\"math inline\">\\(i\\)</span> 过后负载为 <span class=\"math inline\">\\(j\\)</span> 的最小代价（显然 <span class=\"math inline\">\\(f_{i,c}\\)</span> 和 <span class=\"math inline\">\\(f_{i,0}\\)</span> 是等效的，故舍弃前者）。记 <span class=\"math inline\">\\(k=\\left\\lceil\\dfrac {v_i}c\\right\\rceil,w=(v_i\\bmod c - 1)\\bmod c+1\\)</span>，那么有：</p>\n<p><span class=\"math display\">\\[\nf_{i,(j+v_i)\\bmod c}\\gets f_{i-1,j}+k\\cdot a_i+(k-1)\\cdot b +\n\\begin{cases}\nb&amp;j+w=c\\\\\na_i+b&amp;j+w&gt; c\\\\\n0&amp;\\text{otherwise}\n\\end{cases}\\\\\nf_{i,0}\\gets f_{i,j}+b\n\\]</span></p>\n<p>发现 <span class=\"math inline\">\\(f_{i-1}\\)</span> 和 <span class=\"math inline\">\\(f_i\\)</span> 之间是存在对应关系的，所以考虑直接继承（真实的 <span class=\"math inline\">\\(0\\)</span> 应该位于 <span class=\"math inline\">\\(-s_i\\)</span> 的位置），再做全局加、区间加，<span class=\"math inline\">\\(f_{i,0}\\)</span> 的转移是全局 min，线段树维护即可；每次只会新增一个状态，动态开点即可。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 5e6 + 5;\nconst __int128 inf = 1e18;\nstruct &#123;\n    int l, r;\n    __int128 u, d;\n&#125; t[maxn];\n#define lt t[p].l\n#define rt t[p].r\nint tot;\nvoid pushdown(int p) &#123;\n    if (t[p].d) &#123;\n        t[lt].d += t[p].d, t[lt].u += t[p].d;\n        t[rt].d += t[p].d, t[rt].u += t[p].d;\n        t[p].d = 0ll;\n    &#125;\n    return;\n&#125;\nvoid upd(int &amp;p, int l, int r, int x, __int128 v) &#123;\n    if (!p)\n        p = ++tot, t[p].u = v;\n    else\n        t[p].u = std::min(t[p].u, v);\n    if (l == r)\n        return;\n    pushdown(p);\n    int mid = (l + r) &gt;&gt; 1;\n    if (x &lt;= mid)\n        upd(lt, l, mid, x, v);\n    else\n        upd(rt, mid + 1, r, x, v);\n    return;\n&#125;\nvoid add(int p, int l, int r, int ql, int qr, __int128 v) &#123;\n    if (!p)\n        return;\n    if (ql &lt;= l &amp;&amp; r &lt;= qr) &#123;\n        t[p].d += v, t[p].u += v;\n        return;\n    &#125;\n    int mid = (l + r) &gt;&gt; 1;\n    pushdown(p);\n    if (ql &lt;= mid)\n        add(lt, l, mid, ql, qr, v);\n    if (qr &gt; mid)\n        add(rt, mid + 1, r, ql, qr, v);\n    t[p].u = std::min(t[lt].u, t[rt].u);\n    return;\n&#125;\n__int128 ask(int p, int l, int r, int x) &#123;\n    if (l == r)\n        return t[p].u;\n    int mid = (l + r) &gt;&gt; 1;\n    pushdown(p);\n    if (x &lt;= mid)\n        return ask(lt, l, mid, x);\n    return ask(rt, mid + 1, r, x);\n&#125;\n#undef lt\n#undef rt\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n    std::freopen(&quot;robot.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;robot.out&quot;, &quot;w&quot;, stdout);\n#else\n    std::freopen(&quot;ex_robot4.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    t[0].u = inf;\n    int n, b, c, p0 = 0, rt = 0;\n    std::cin &gt;&gt; n &gt;&gt; c &gt;&gt; b;\n    std::vector&lt;int&gt; a(n + 1), v(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i];\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; v[i];\n    upd(rt, 0, c - 1, 0, 0ll);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        __int128 k = (v[i] + c - 1) / c, w = (v[i] % c == 0 ? c : v[i] % c);\n        t[rt].d += k * a[i] + (k - 1) * b;\n        t[rt].u += k * a[i] + (k - 1) * b;\n        if (w &lt;= c)\n            add(rt, 0, c - 1, (c - w + p0) % c, (c - w + p0) % c, b);\n        if (w != 1) &#123;\n            int l = (c - w + p0 + 1) % c, r = (p0 + c - 1) % c;\n            if (l &lt;= r)\n                add(rt, 0, c - 1, l, r, a[i] + b);\n            else &#123;\n                add(rt, 0, c - 1, 0, r, a[i] + b);\n                add(rt, 0, c - 1, l, c - 1, a[i] + b);\n            &#125;\n        &#125;\n        p0 = (p0 + c - v[i] % c) % c;\n        upd(rt, 0, c - 1, p0, t[rt].u + b);\n    &#125;\n    std::cout &lt;&lt; (long long)ask(rt, 0, c - 1, p0) &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"d.-套娃\">D. 套娃</h2>\n<p><a href=\"http://222.180.160.110:61235/contest/6502/problem/4\" class=\"uri\">http://222.180.160.110:61235/contest/6502/problem/4</a></p>\n<blockquote>\n<p>题意：给定初始为全 <span class=\"math inline\">\\(0\\)</span> 的数组 <span class=\"math inline\">\\(a_{1\\sim n + 1}\\)</span> 和 <span class=\"math inline\">\\(n\\)</span> 次单点 +1 操作，每次操作后，求解：</p>\n<p>令 <span class=\"math inline\">\\(a\\)</span> 的前缀和数组为 <span class=\"math inline\">\\(s\\)</span>，找到一个最小的 <span class=\"math inline\">\\(k\\)</span>，使得对于每个 <span class=\"math inline\">\\(i\\)</span>，均有 <span class=\"math inline\">\\(k\\cdot i\\ge s_i\\)</span> 成立。</p>\n<p><span class=\"math inline\">\\(n\\le 10^6\\)</span>，时限 0.5s。</p>\n</blockquote>\n<details>\n<p><summary>趣事一则</summary></p>\n<p>考场上最后 10min 拿到题，憋了一个能拿到 96pts 的假做法：注意到前缀和是单增的，需要维护最大的 <span class=\"math inline\">\\(\\dfrac {s_i}i\\)</span>，由于后缀 +1 带来的影响很小，所以可以猜测在大多数情况下最大的 <span class=\"math inline\">\\(i\\)</span> 只会在原来的和修改的点之间变化。只用 10 行的核心代码就能拿到很多分。但是居然有这么多，可能出题人都没有想到真有人敢交这种做法吧。</p>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n    std::freopen(&quot;doll.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;doll.out&quot;, &quot;w&quot;, stdout);\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n    auto stime = std::chrono::steady_clock::now();\n    int n, res = 0;\n    std::cin &gt;&gt; n;\n    std::vector&lt;int&gt; bit(n + 2);\n    auto lowbit = [](int x) &#123;\n        return x &amp; -x;\n    &#125;;\n    auto add = [&amp;](int x) &#123;\n        for (; x &lt;= n + 1; x += lowbit(x))\n            ++bit[x];\n        return;\n    &#125;;\n    auto ask = [&amp;](int x) &#123;\n        int res = 0;\n        for (; x; x -= lowbit(x))\n            res += bit[x];\n        return res;\n    &#125;;\n    int p = 1;\n    for (int i = 1, x; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; x, add(++x);\n        long long s = ask(x), t = ask(p);\n        if (s * p == t * x ? x &gt; p : s * p &gt; t * x)\n            p = x;\n        else\n            s = t;\n        if (s &gt; p * res)\n            ++res;\n        std::cout &lt;&lt; res &lt;&lt; &#39; &#39;;\n    &#125;\n    std::cout &lt;&lt; &#39;\\n&#39;;\n    std::cerr &lt;&lt; std::chrono::duration&lt;double&gt;(std::chrono::steady_clock::now() - stime).count() &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<p>很容易写出暴力，观察样例就能发现每次修改后答案最多增加 <span class=\"math inline\">\\(1\\)</span>。记当前答案为 <span class=\"math inline\">\\(res\\)</span>，线段树维护 <span class=\"math inline\">\\(s_i-res\\cdot i\\)</span> 的最小值，若其为负则 res++，然后重构线段树（等差数列和 min 不兼容）。</p>\n<p>怎么又有不等式 😱</p>\n<p>目的是在本来合法的范围里找到新的不合法值。考虑合法范围：<span class=\"math inline\">\\(s_i-res\\cdot i\\ge 0\\)</span>，解一下得到 <span class=\"math inline\">\\(i\\le \\dfrac {s_i}{res}\\)</span>，放缩得到 <span class=\"math inline\">\\(i\\le\\dfrac {n}{res}\\)</span>，每次 <span class=\"math inline\">\\(res\\)</span> 变化时只重构 <span class=\"math inline\">\\(\\dfrac {n}{res}\\)</span> 以前的位置，重构的总长是 <span class=\"math inline\">\\(O(n\\ln n)\\)</span> 的。（线段树建树是线性的）</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 1e6 + 5;\nconst int inf = 0x3f3f3f3f;\nstruct &#123;\n    int l, r, u, d;\n&#125; t[maxn &lt;&lt; 2];\n#define lt (p &lt;&lt; 1)\n#define rt (lt | 1)\nvoid bld(int p, int l, int r) &#123;\n    t[p].u = t[p].l = l, t[p].r = r;\n    if (l == r)\n        return;\n    int mid = (l + r) &gt;&gt; 1;\n    bld(lt, l, mid), bld(rt, mid + 1, r);\n    return;\n&#125;\nvoid pushdown(int p) &#123;\n    if (t[p].d) &#123;\n        t[lt].d += t[p].d, t[rt].d += t[p].d;\n        t[lt].u -= t[p].d, t[rt].u -= t[p].d;\n        t[p].d = 0;\n    &#125;\n    return;\n&#125;\nvoid add(int p, int x) &#123;\n    if (x &lt;= t[p].l) &#123;\n        ++t[p].d, --t[p].u;\n        return;\n    &#125;\n    pushdown(p);\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (x &lt;= mid)\n        add(lt, x);\n    add(rt, x);\n    t[p].u = std::min(t[lt].u, t[rt].u);\n    // printf(&quot;[%d, %d]: %d, [%d, %d]: %d\\n&quot;, t[p].l, mid, t[lt].u, mid + 1, t[p].r, t[rt].u);\n    return;\n&#125;\nvoid rem(int p, int r) &#123;\n    if (t[p].l == t[p].r) &#123;\n        t[p].u += t[p].l;\n        return;\n    &#125;\n    pushdown(p);\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (r &lt;= mid)\n        rem(lt, r), t[rt].u = inf;\n    else\n        rem(lt, r), rem(rt, r);\n    t[p].u = std::min(t[lt].u, t[rt].u);\n    return;\n&#125;\n#undef lt\n#undef rt\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n    std::freopen(&quot;doll.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;doll.out&quot;, &quot;w&quot;, stdout);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    bld(1, 1, n + 1);\n    for (int i = 1, x, res = 1, now = n; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; x;\n        if (x &lt;= now)\n            add(1, ++x);\n        if (t[1].u &lt; 0) &#123;\n            std::cout &lt;&lt; ++res &lt;&lt; &#39; &#39;;\n            rem(1, now = n / res);\n        &#125;\n        else\n            std::cout &lt;&lt; res &lt;&lt; &#39; &#39;;\n        // puts(&quot;&quot;);\n    &#125;\n    std::cout &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"e---subarray-sum-divisibility\">E - Subarray Sum Divisibility</h2>\n<p><a href=\"https://atcoder.jp/contests/abc419/tasks/abc419_e\" class=\"uri\">https://atcoder.jp/contests/abc419/tasks/abc419_e</a></p>\n<p>模意义下的数列全等，可以对应原数组全等、差分全等、前缀和全等（都是模意义下的，还有其他的一些线性和非线性的变换也可以）</p>\n<p>本着修改的点尽量少的想法，如果题目给定单点修改就可以在原数组上做文章，给定区间修改可以考虑差分数组，前缀和对于一些区间查询有优势</p>\n<p>其他两种用得也很多，像这题只需要用原数组全等就可以做了</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int inf = 0x3f3f3f3f;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, m, l;\n    std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; l;\n    std::vector&lt;int&gt; a(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i];\n    std::vector&lt;std::vector&lt;int&gt; &gt; u(l + 1, std::vector&lt;int&gt; (m));\n    for (int i = 1; i &lt;= l; ++i)\n        for (int j = 0; j &lt; m; ++j)\n            for (int k = i; k &lt;= n; k += l)\n                u[i][j] += (j + m - a[k]) % m;\n    std::vector&lt;std::vector&lt;int&gt; &gt; f(l + 1, std::vector&lt;int&gt; (m, inf));\n    f[0][0] = 0;\n    for (int i = 1; i &lt;= l; ++i)\n        for (int j = 0; j &lt; m; ++j)\n            for (int k = 0; k &lt; m; ++k)\n                f[i][(j + k) % m] = std::min(f[i][(j + k) % m], f[i - 1][j] + u[i][k]);\n    std::cout &lt;&lt; f[l][0] &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;\n</code></pre>\n</details>\n<hr />\n<h2 id=\"f---all-included\">F - All Included</h2>\n<p><a href=\"https://atcoder.jp/contests/abc419/tasks/abc419_f\" class=\"uri\">https://atcoder.jp/contests/abc419/tasks/abc419_f</a></p>\n<p>原题意转化为在 AC 自动机上走 <span class=\"math inline\">\\(L\\)</span> 步，要求经过 <span class=\"math inline\">\\(n\\)</span> 个叶子的方案数。不太可做，转化成容斥（令字符串终点不可达）。在外层枚举步数暴力游走。</p>\n<p>要求恰好走 <span class=\"math inline\">\\(L\\)</span> 步，也可以用矩阵；但原图很稀疏，所以矩阵并没有优势。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 998244353;\nint tot = 1, T[805][26], fail[805];\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, l;\n    std::cin &gt;&gt; n &gt;&gt; l;\n    std::vector&lt;std::string&gt; a;\n    &#123;\n        std::vector&lt;std::string&gt; s(n + 1);\n        for (int i = 1; i &lt;= n; ++i)\n            std::cin &gt;&gt; s[i];\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            bool flag = 1;\n            for (int j = 1; j &lt;= n; ++j)\n                if (j != i)\n                    if (s[j].find(s[i]) != std::string::npos) &#123;\n                        flag = 0;\n                        break;\n                    &#125;\n            if (flag)\n                a.push_back(s[i]);\n        &#125;\n        n = (int)a.size();\n    &#125;\n    std::vector&lt;int&gt; pos(n);\n    for (int i = 0; i &lt; n; ++i) &#123;\n        int &amp;p = pos[i];\n        for (auto j : a[i]) &#123;\n            if (!T[p][j - &#39;a&#39;])\n                T[p][j - &#39;a&#39;] = tot++;\n            p = T[p][j - &#39;a&#39;];\n        &#125;\n    &#125;\n    &#123;\n        std::queue&lt;int&gt; q;\n        for (int i = 0; i &lt; 26; ++i)\n            if (T[0][i])\n                q.push(T[0][i]);\n        for (; !q.empty(); ) &#123;\n            int u = q.front();\n            q.pop();\n            for (int i = 0; i &lt; 26; ++i)\n                if (T[u][i]) &#123;\n                    int v = T[u][i];\n                    fail[v] = T[fail[u]][i];\n                    q.push(v);\n                &#125;\n                else\n                    T[u][i] = T[fail[u]][i];\n        &#125;\n    &#125;\n    auto res = 0ll;\n    int siz = 1 &lt;&lt; n;\n    for (int i = 0; i &lt; siz; ++i) &#123;\n        std::vector&lt;int&gt; tag(tot);\n        for (int j = 0; j &lt; n; ++j)\n            if ((i &gt;&gt; j) &amp; 1)\n                tag[pos[j]] = 1;\n        std::vector&lt;std::vector&lt;long long&gt; &gt; f(l + 1, std::vector&lt;long long&gt; (tot));\n        f[0][0] = 1ll;\n        for (int j = 0; j &lt; l; ++j)\n            for (int k = 0; k &lt; tot; ++k)\n                for (int a = 0; a &lt; 26; ++a) &#123;\n                    if (!tag[T[k][a]])\n                        (f[j + 1][T[k][a]] += f[j][k]) %= mod;\n                &#125;\n        int k = (__builtin_popcount(i) &amp; 1 ? mod - 1 : 1);\n        auto s = 0ll;\n        for (int j = 0; j &lt; tot; ++j)\n            if (!tag[j])\n                (s += f[l][j]) %= mod;\n        (res += k * s) %= mod;\n    &#125;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"g---count-simple-paths-2\">G - Count Simple Paths 2</h2>\n<p><a href=\"https://atcoder.jp/contests/abc419/tasks/abc419_g\" class=\"uri\">https://atcoder.jp/contests/abc419/tasks/abc419_g</a></p>\n<p>很新的性质。考虑『以 <span class=\"math inline\">\\(1\\)</span> 为起点的简单路径数』和反祖边数量的关系：选定一条反祖边必须被经过时（显然只有一种可能的经过方向），树的形态发生变化：</p>\n<p><img src=\"image.png\" /></p>\n<p>也就是说，一种反祖边的选取方案对应一种树，遍历其从 <span class=\"math inline\">\\(1\\)</span> 开始的简单路径复杂度为 <span class=\"math inline\">\\(O(n)\\)</span>。设反祖边数量为 <span class=\"math inline\">\\(k\\)</span>，那么合法的方案数不超过 <span class=\"math inline\">\\(2^k\\)</span>，暴力 DFS 的整个图复杂度为 <span class=\"math inline\">\\(O(2^k\\cdot n)\\)</span>。</p>\n<p>发现很多跟反祖边无关的遍历是不必要的（只有一种走法，可以设成边权），考虑对所有连接反祖边的点建立虚树，并把原树上的反祖边也移到虚树上，就能 <span class=\"math inline\">\\(O(2^k\\cdot k)\\)</span> 解决问题。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, m;\n    std::cin &gt;&gt; n &gt;&gt; m;\n    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1), g1(n + 1);\n    std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; g2(n + 1);\n    for (int x, y; m--; ) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y;\n        g[x].push_back(y), g[y].push_back(x);\n    &#125;\n    std::vector&lt;int&gt; tag(n + 1), vis(n + 1);\n    std::vector&lt;std::pair&lt;int, int&gt; &gt; be;\n    std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int fa) &#123;\n        static int now = 0;\n        tag[x] = 1, vis[x] = ++now;\n        for (auto i : g[x])\n            if (!tag[i]) &#123;\n                // fprintf(stderr, &quot;%d -&gt; %d\\n&quot;, x, i);\n                g1[x].push_back(i), DFS(i, x);\n            &#125;\n            else if (i != fa &amp;&amp; vis[i] &lt; vis[x])\n                be.emplace_back(i, x);\n        return;\n    &#125;;\n    DFS(1, -1);\n    &#123; // 求虚树\n        std::vector&lt;int&gt; dep(n + 1), fa(n + 1), top(n + 1), siz(n + 1), son(n + 1), dfn(n + 1), rfn(n + 1);\n        std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;\n            siz[x] = 1;\n            for (auto i : g1[x]) &#123;\n                dep[i] = dep[x] + 1;\n                fa[i] = x, DFS(i);\n                siz[x] += siz[i];\n                if (siz[i] &gt; siz[son[x]])\n                    son[x] = i;\n            &#125;\n            return;\n        &#125;;\n        DFS(1);\n        DFS = [&amp;](int x) &#123;\n            static int now = 0;\n            dfn[x] = ++now;\n            if (son[x])\n                top[son[x]] = top[x], DFS(son[x]);\n            for (auto i : g1[x])\n                if (i != son[x])\n                    top[i] = i, DFS(i);\n            rfn[x] = now;\n            // printf(&quot;%d: [%d, %d]\\n&quot;, x, dfn[x], rfn[x]);\n            return;\n        &#125;;\n        top[1] = 1, DFS(1);\n        auto getLCA = [&amp;](int x, int y) &#123;\n            for (; top[x] != top[y]; x = fa[top[x]])\n                if (dep[top[x]] &lt; dep[top[y]])\n                    std::swap(x, y);\n            return dep[x] &lt; dep[y] ? x : y;\n        &#125;;\n        tag.assign(n + 1, 0);\n        tag[1] = tag[n] = 1;\n        for (auto [u, v] : be)\n            tag[u] = 1, tag[v] = 1;\n        std::vector&lt;int&gt; p;\n        for (int i = 1; i &lt;= n; ++i)\n            if (tag[i])\n                p.push_back(i);\n        std::sort(p.begin(), p.end(), [&amp;](int i, int j) &#123; return dfn[i] &lt; dfn[j]; &#125;);\n        for (int i = 1; i &lt; (int)p.size(); ++i) &#123;\n            int fa = getLCA(p[i], p[i - 1]);\n            if (!tag[fa])\n                tag[fa] = 1;\n        &#125;\n        p.clear();\n        for (int i = 1; i &lt;= n; ++i)\n            if (tag[i])\n                p.push_back(i);\n        std::sort(p.begin(), p.end(), [&amp;](int i, int j) &#123; return dfn[i] &lt; dfn[j]; &#125;);\n        std::vector&lt;int&gt; st;\n        for (auto i : p) &#123;\n            if (st.empty())\n                st.push_back(i);\n            else &#123;\n                for (; rfn[st.back()] &lt; dfn[i]; st.pop_back());\n                g2[st.back()].emplace_back(i, dep[i] - dep[st.back()]);\n                g2[i].emplace_back(st.back(), dep[i] - dep[st.back()]);\n                // printf(&quot;add (%d, %d): %d\\n&quot;, st.back(), i, dep[i] - dep[st.back()]);\n                st.push_back(i);\n            &#125;\n        &#125;\n        for (auto [u, v] : be) &#123;\n            g2[u].emplace_back(v, 1), g2[v].emplace_back(u, 1);\n            // printf(&quot;# add(%d, %d): 1\\n&quot;, u, v);\n        &#125;\n    &#125;\n    tag.assign(n + 1, 0);\n    std::vector&lt;int&gt; res(n + 1);\n    DFS = [&amp;](int x, int s) &#123;\n        if (x == n)\n            ++res[s];\n        tag[x] = 1;\n        for (auto [i, w] : g2[x])\n            if (!tag[i])\n                DFS(i, s + w);\n        tag[x] = 0;\n        return;\n    &#125;;\n    DFS(1, 0);\n    for (int i = 1; i &lt; n; ++i)\n        std::cout &lt;&lt; res[i] &lt;&lt; &#39; &#39;;\n    std::cout &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n",
            "tags": [
                "线段树",
                "AC 自动机",
                "贪心",
                "DP 优化",
                "虚树"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20250814/",
            "url": "https://xsc062.netlify.app/20250814/",
            "title": "DDP 与 GBT 练习",
            "date_published": "2025-08-14T09:08:21.000Z",
            "content_html": "<p>线段树是对的（存疑）</p>\n<span id=\"more\"></span>\n<hr />\n<h2 id=\"a---数据传输\">A - 数据传输</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P8820\" class=\"uri\">https://www.luogu.com.cn/problem/P8820</a></p>\n<p>我在上一篇文章中提到了 <a href=\"/20250812/#树上路径查询\">DDP &amp; 路径查询问题</a>，在这个题中就有体现。</p>\n<p>设 <span class=\"math inline\">\\(f_{u,0/1/2}\\)</span> 表示数据保存在 <span class=\"math inline\">\\(u\\)</span> 往下数 <span class=\"math inline\">\\(0/1/2\\)</span> 个点处的最小代价，手玩容易发现 <span class=\"math inline\">\\(k=3\\)</span> 时<strong>最优路径可能会往某个 <span class=\"math inline\">\\(x\\)</span> 或 <span class=\"math inline\">\\(fa\\)</span> 处的最小代价儿子处绕一圈来避免这个 <span class=\"math inline\">\\(x\\)</span> 或 <span class=\"math inline\">\\(fa\\)</span> 的代价</strong>。但该值是定值，问题还是纯路径问题，就可以 DDP 了。</p>\n<figure>\n<img src=\"image.png\" alt=\"共两种可能性（任意一个箭头长度不为 3 时绕一圈一定不比直接走更优）\" /><figcaption>共两种可能性（任意一个箭头长度不为 <span class=\"math inline\">\\(3\\)</span> 时绕一圈一定不比直接走更优）</figcaption>\n</figure>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nstruct mat &#123;\n    long long a[3][3];\n    long long* operator[] (const int q) &#123;\n        return a[q];\n    &#125;\n    mat() &#123;\n        memset(a, 0x3f, sizeof (a));\n        return;\n    &#125;\n    mat(int flag) &#123;\n        memset(a, 0x3f, sizeof (a));\n        a[0][0] = a[1][1] = a[2][2] = 0ll;\n        return;\n    &#125;\n    mat operator* (mat &amp;q) const &#123;\n        mat res;\n        for (int i = 0; i &lt; 3; ++i)\n            for (int k = 0; k &lt; 3; ++k)\n                for (int j = 0; j &lt; 3; ++j)\n                    res[i][k] = std::min(res[i][k], a[i][j] + q[j][k]);\n        return res;\n    &#125;\n    mat&amp; operator*= (mat &amp;q) &#123;\n        return *this = *this * q;\n    &#125;\n&#125;;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, q, k;\n    std::cin &gt;&gt; n &gt;&gt; q &gt;&gt; k;\n    std::vector&lt;int&gt; a(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i];\n    std::vector&lt;int&gt; mx(n + 1, 0x3f3f3f3f);\n    std::vector&lt;std::vector&lt;int&gt; &gt; g1(n + 1);\n    for (int i = 1, x, y; i &lt; n; ++i) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y;\n        mx[x] = std::min(mx[x], a[y]);\n        mx[y] = std::min(mx[y], a[x]);\n        g1[x].push_back(y), g1[y].push_back(x);\n    &#125;\n    std::vector&lt;int&gt; dep(n + 1);\n    std::vector&lt;std::array&lt;int, 18&gt; &gt; f(n + 1);\n    std::vector&lt;std::array&lt;mat, 18&gt; &gt; u(n + 1), d(n + 1);\n    u[0][0] = d[0][0] = mat(1);\n    std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;\n        for (auto i : g1[x])\n            if (i != f[x][0]) &#123;\n                f[i][0] = x;\n                &#123;\n                    mat s;\n                    s[0][0] = a[x];\n                    if (k &gt;= 2) &#123;\n                        s[0][1] = 0;\n                        s[1][0] = a[x];\n                    &#125;\n                    if (k &gt;= 3) &#123;\n                        s[1][2] = 0;\n                        s[2][0] = a[x];\n                        s[1][1] = mx[x];\n                        s[2][2] = mx[i];\n                    &#125;\n                    u[i][0] = s; \n                    s[0][0] = a[i];\n                    if (k &gt;= 2)\n                        s[1][0] = a[i];\n                    if (k &gt;= 3) &#123;\n                        s[2][0] = a[i];\n                        s[1][1] = mx[i];\n                        s[2][2] = mx[x];\n                    &#125;\n                    d[i][0] = s; \n                &#125;\n                for (int j = 1; j &lt; 18; ++j) &#123;\n                    f[i][j] = f[f[i][j - 1]][j - 1];\n                    u[i][j] = u[i][j - 1] * u[f[i][j - 1]][j - 1];\n                    d[i][j] = d[f[i][j - 1]][j - 1] * d[i][j - 1];\n                &#125;\n                dep[i] = dep[x] + 1;\n                DFS(i);\n            &#125;\n        return;\n    &#125;;\n    dep[1] = 1, DFS(1);\n    for (int x, y; q--; ) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y;\n        long long res = a[x];\n        mat r1(1), r2(1);\n        if (dep[x] &gt; dep[y]) &#123;\n            for (int i = 17; ~i; --i)\n                if (dep[f[x][i]] &gt;= dep[y]) &#123;\n                    r1 = r1 * u[x][i];\n                    x = f[x][i];\n                &#125;\n        &#125;\n        else if (dep[y] &gt; dep[x]) &#123;\n            for (int i = 17; ~i; --i)\n                if (dep[f[y][i]] &gt;= dep[x]) &#123;\n                    r2 = d[y][i] * r2;\n                    y = f[y][i];\n                &#125;\n        &#125;\n        if (x != y) &#123;\n            for (int i = 17; ~i; --i)\n                if (f[x][i] != f[y][i]) &#123;\n                    r1 = r1 * u[x][i];\n                    r2 = d[y][i] * r2;\n                    x = f[x][i], y = f[y][i];\n                &#125;\n            r1 = r1 * u[x][0], r2 = d[y][0] * r2;\n        &#125;\n        std::cout &lt;&lt; res + (r1 * r2)[0][0] &lt;&lt; &#39;\\n&#39;;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"b---the-silk-road-with-robots\">B - The Silk Road … with Robots!</h2>\n<p><a href=\"https://qoj.ac/problem/10410\" class=\"uri\">https://qoj.ac/problem/10410</a></p>\n<blockquote>\n<p>题意：初始有一个长为 <span class=\"math inline\">\\(10^8\\)</span> 的空数轴，给定 <span class=\"math inline\">\\(n\\)</span> 次操作，每次操作在数轴上的一个空位放一个 A 类点或 B 类点。每个 A 类点有其<strong>价值</strong>。</p>\n<p>任意在数轴上移动这些 B 类点，<strong>总价值</strong>为所有被经过的 A 类点的<strong>价值</strong> - B 类点移动总路程。每次操作后输出最大<strong>总价值</strong>，重复经过的 A 类点只计一次。</p>\n<p><span class=\"math inline\">\\(n\\le 2\\times 10^5\\)</span>。</p>\n</blockquote>\n<p>这个题确实可以带来很多启发，我一开始直接设 <span class=\"math inline\">\\(f_j\\)</span> 为状态，这样对于暴力是可做的，但是会出现一些需要被区间修改的系数，比如<strong>前缀和</strong>。最好设计状态，让转移的时候只需要用到常数、差分值等修改次数很少的系数。</p>\n<p>设 <span class=\"math inline\">\\(f_{i,0/1/2/3}\\)</span> 分别表示：</p>\n<p><img src=\"image-1.png\" /></p>\n<p>那么可以写出转移式：</p>\n<p><span class=\"math display\">\\[\nf_{i,0}=\\max(mx+a_i+x_i,f_{i-1,0}+a_i)\\\\\nf_{i,1}=\\max(mx+a_i+2x_i,f_{i-1,1}+a_i)\\\\\nf_{i,2}=f_{i-1,2}-(x_i-x_{i-1}) + a_i\\\\\nf_{i,3}=f_{i-1,3}-2(x_i-x_{i-1})+a_i\n\\]</span></p>\n<p>其中 <span class=\"math inline\">\\(mx\\)</span> 为 <span class=\"math inline\">\\(f_{i,2/3}\\)</span> 的前缀最大值。在 B 类点处可以让 <span class=\"math inline\">\\(f_{2/3}\\)</span> 继承对应的 <span class=\"math inline\">\\(f_{0/1}\\)</span>，新开一维记录 <span class=\"math inline\">\\(mx\\)</span> 就可以维护矩乘了。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int lim = 1e8;\nconst int maxn = 5e6 + 5;\nconst long long inf = 1e12;\nstruct mat &#123;\n    long long a[5][5];\n    mat() &#123;&#125;\n    long long* operator[] (const int q) &#123;\n        return a[q];\n    &#125;\n    mat operator* (mat &amp;q) const &#123;\n        mat res;\n        for (int i = 0; i &lt; 5; ++i)\n            for (int k = 0; k &lt; 5; ++k) &#123;\n                auto u(-inf);\n                for (int j = 0; j &lt; 5; ++j)\n                    u = std::max(u, a[i][j] + q[j][k]);\n                res[i][k] = u;\n            &#125;\n        return res;\n    &#125;\n    mat&amp; operator*= (mat &amp;q) &#123;\n        return *this = *this * q;\n    &#125;\n&#125;;\nstruct &#123; int l, r; mat u; &#125; t[maxn];\n#define lt t[p].l\n#define rt t[p].r\nvoid add(int &amp;p, int l, int r, int x, mat &amp;v) &#123;\n    static int tot = 0;\n    if (!p)\n        p = ++tot;\n    if (l == r) &#123;\n        t[p].u = v;\n        return;\n    &#125;\n    int mid = (l + r) &gt;&gt; 1;\n    if (x &lt;= mid)\n        add(lt, l, mid, x, v);\n    else\n        add(rt, mid + 1, r, x, v);\n    t[p].u = t[lt].u * t[rt].u;\n    return;\n&#125;\n#undef lt\n#undef rt\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    &#123;\n        mat &amp;u = t[0].u;\n        for (int i = 0; i &lt; 5; ++i)\n            for (int j = 0; j &lt; 5; ++j)\n                u[i][j] = -inf;\n        u[0][0] = u[1][1] = u[2][2] = u[3][3] = u[4][4] = 0ll;\n    &#125;\n    int m, rt = 0;\n    std::cin &gt;&gt; m;\n    std::vector&lt;mat&gt; a(m + 1);\n    std::vector&lt;int&gt; ty(m + 1);\n    std::set&lt;std::pair&lt;long long, int&gt; &gt; s;\n    s.emplace(-inf, 0);\n    for (int op, x, i = 1; i &lt;= m; ++i) &#123;\n        std::cin &gt;&gt; op &gt;&gt; x;\n        auto &amp;u = a[i];\n        for (int i = 0; i &lt; 5; ++i)\n            for (int j = 0; j &lt; 5; ++j)\n                u[i][j] = -inf;\n        auto p = --s.lower_bound(std::make_pair(x, 0)), q = s.upper_bound(std::make_pair(x, 0));\n        int v = 0;\n        if (op == 2)\n            std::cin &gt;&gt; v;\n        u[0][0] = v, u[1][1] = v, u[4][0] = v + x, u[4][1] = v + 2 * x;\n        if (op == 1) &#123;\n            ty[i] = 0;\n            u[4][2] = u[4][1] - 2 * x;\n            u[1][2] = u[1][1] - 2 * x;\n            u[4][3] = u[4][0] - x;\n            u[0][3] = u[0][0] - x;\n        &#125;\n        else &#123;\n            ty[i] = 1;\n            u[2][2] = v - (x - p-&gt;first);\n            u[3][3] = v - 2 * (x - p-&gt;first);\n        &#125;\n        u[4][4] = std::max(&#123; 0ll, u[4][2], u[4][3] &#125;);\n        u[1][4] = u[1][2], u[0][4] = u[0][3], u[2][4] = u[2][2], u[3][4] = u[3][3];\n        add(rt, 0, lim, x, u);\n        if (q != s.end() &amp;&amp; ty[q-&gt;second] == 1) &#123;\n            auto &amp;u = a[q-&gt;second];\n            u[2][2] -= p-&gt;first, u[2][2] += x;\n            u[3][3] -= 2 * p-&gt;first, u[3][3] += 2 * x;\n            u[2][4] = u[2][2], u[3][4] = u[3][3];\n            add(rt, 0, lim, q-&gt;first, a[q-&gt;second]);\n        &#125;\n        s.emplace(x, i);\n        std::cout &lt;&lt; t[1].u[4][4] &lt;&lt; &#39;\\n&#39;;\n        // for (int i = 0; i &lt; 5; ++i, puts(&quot;&quot;))\n        //     for (int j = 0; j &lt; 5; ++j)\n        //         if (t[1].u[i][j] &lt; -200)\n        //             printf(&quot;  x &quot;);\n        //         else\n        //             printf(&quot;%3lld &quot;, t[1].u[i][j]);\n        // puts(&quot;=============&quot;);\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"c---密码箱\">C - 密码箱</h2>\n<p><a href=\"/20250818/#c---%E5%AF%86%E7%A0%81%E7%AE%B1\">link</a>;</p>\n",
            "tags": [
                "线段树",
                "DDP"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20250812/",
            "url": "https://xsc062.netlify.app/20250812/",
            "title": "DDP 与全局平衡二叉树",
            "date_published": "2025-08-12T00:16:52.000Z",
            "content_html": "<p>其实动态 DP 不是动态树 DP 的同义词</p>\n<span id=\"more\"></span>\n<hr />\n<h2 id=\"动态-dp\">动态 DP</h2>\n<p>对于转移只依赖前几项的 DP，可以放进矩阵。</p>\n<p>默认转移范围是 <span class=\"math inline\">\\([1,n]\\)</span>；如果我们需要改变求解范围，发现如果能获取转移矩阵的乘积就很快了。考虑存下来。</p>\n<p>如果需要单点修改，等价于修改其所在矩阵，则想要尽可能少地修改存储的答案，考虑使用线段树优化该过程。</p>\n<h3 id=\"例海报\">例：海报</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P9790\" class=\"uri\">https://www.luogu.com.cn/problem/P9790</a></p>\n<p>容易列出暴力 DP 式：令 <span class=\"math inline\">\\(f_{i,j}\\)</span> 表示枚举到 <span class=\"math inline\">\\(i\\)</span> 时，包含 <span class=\"math inline\">\\(i\\)</span> 在内已经有 <span class=\"math inline\">\\(j\\)</span> 个连续的人举起海报，易得：</p>\n<p><span class=\"math display\">\\[\nf_{i,0}=\\max(f_{i-1,0},f_{i-1,1},f_{i-1,2},f_{i-1,3})\\\\\nf_{i,j}=f_{i-1,j-1}+a_i \\forall 1\\le j\\le 3\n\\]</span></p>\n<p>发现满足 + / max <strong>矩阵乘法</strong> 的形式；想到用线段树保存每段区间对应矩阵（对应性质：结合律），每次修改 / 查询就能在 <span class=\"math inline\">\\(O(\\log n)\\)</span> 之内完成。</p>\n<p>原问题是环形的，可以再加一维 <span class=\"math inline\">\\(k\\)</span> 表示钦定选了前 <span class=\"math inline\">\\(k\\)</span> 个且不选第 <span class=\"math inline\">\\(k+1\\)</span> 个时的答案。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 4e4 + 5;\nconst long long inf = 1e18;\nstruct mat &#123;\n    int n, m;\n    long long a[4][4];\n    mat() &#123;&#125;\n    mat(int n1, int m1): n(n1), m(m1) &#123;\n        for (int i = 0; i &lt; n; ++i)\n            for (int j = 0; j &lt; m; ++j)\n                a[i][j] = -inf;\n        return;\n    &#125;\n    long long* operator[] (const int q) &#123;\n        return a[q];\n    &#125;\n    mat operator* (mat &amp;q) const &#123;\n        mat res(n, q.m);\n        for (int i = 0; i &lt; n; ++i)\n            for (int k = 0; k &lt; q.m; ++k)\n                for (int j = 0; j &lt; m; ++j)\n                    res[i][k] = std::max(res[i][k], a[i][j] + q[j][k]);\n        return res;\n    &#125;\n    mat&amp; operator*= (mat &amp;q) &#123;\n        return *this = *this * q;\n    &#125;\n&#125;;\nstruct &#123; int l, r; mat u[4]; &#125; t[maxn &lt;&lt; 2];\nint a[maxn];\n#define lt (p &lt;&lt; 1)\n#define rt (lt | 1)\n#define c t[p].u[i]\nvoid bld(int p, int l, int r) &#123;\n    t[p].l = l, t[p].r = r;\n    if (l == r) &#123;\n        for (int i = 0; i &lt;= 3; ++i) &#123;\n            c = mat(4, 4);\n            if (l &gt; i + 1) &#123;\n                c[0][0] = c[1][0] = c[2][0] = c[3][0] = 0;\n                c[0][1] = c[1][2] = c[2][3] = a[l];\n            &#125;\n            else if (l == i + 1)\n                c[0][0] = c[1][0] = c[2][0] = c[3][0] = 0;\n            else\n                c[0][1] = c[1][2] = c[2][3] = a[l];\n        &#125;\n        return;\n    &#125;\n    int mid = (l + r) &gt;&gt; 1;\n    bld(lt, l, mid), bld(rt, mid + 1, r);\n    for (int i = 0; i &lt;= 3; ++i)\n        t[p].u[i] = t[lt].u[i] * t[rt].u[i];\n    return;\n&#125;\nvoid add(int p, int x, int v) &#123;\n    if (t[p].l == t[p].r) &#123;\n        for (int i = 0; i &lt;= 3; ++i)\n            if (t[p].l != i + 1) \n                c[0][1] = c[1][2] = c[2][3] = v;\n        return;\n    &#125;\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (x &lt;= mid)\n        add(lt, x, v);\n    else\n        add(rt, x, v);\n    for (int i = 0; i &lt;= 3; ++i)\n        t[p].u[i] = t[lt].u[i] * t[rt].u[i];\n    return;\n&#125;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i];\n    bld(1, 1, n);\n    auto calc = [&amp;](void) &#123;\n        mat f(1, 4);\n        f[0][0] = 0;\n        auto res = -inf;\n        for (int i = 0; i &lt;= 3; ++i) &#123;\n            auto r = (f * t[1].u[i]);\n            for (int j = 0; j &lt;= 3; ++j)\n                if (i + j &lt;= 3) &#123;\n                    res = std::max(res, r[0][j]);\n                    // printf(&quot;f[%d][%d] = %lld\\n&quot;, i, j, f[i][j]);\n                &#125;\n        &#125;\n        return res;\n    &#125;;\n    std::cout &lt;&lt; calc() &lt;&lt; &#39;\\n&#39;;\n    int q;\n    std::cin &gt;&gt; q;\n    for (int x, v; q--; ) &#123;\n        std::cin &gt;&gt; x &gt;&gt; v;\n        add(1, x, v);\n        std::cout &lt;&lt; calc() &lt;&lt; &#39;\\n&#39;;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<p>发现矩阵本身和 <span class=\"math inline\">\\(k\\)</span> 无关，还可以可以共用一个线段树上的信息，就可以只开一个线段树了。</p>\n<details>\n<p>我写这一版本的原因是 <code>maxn</code> 开大了导致 MLE，实际上四个线段树是没有任何空间压力的 😅</p>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 4e5 + 5;\nconst long long inf = 1e18;\nstruct mat &#123;\n    int n, m;\n    long long a[4][4];\n    mat() &#123;&#125;\n    mat(int n1, int m1): n(n1), m(m1) &#123;\n        for (int i = 0; i &lt; n; ++i)\n            for (int j = 0; j &lt; m; ++j)\n                a[i][j] = -inf;\n        return;\n    &#125;\n    long long* operator[] (const int q) &#123;\n        return a[q];\n    &#125;\n    mat operator* (mat q) const &#123;\n        mat res(n, q.m);\n        for (int i = 0; i &lt; n; ++i)\n            for (int k = 0; k &lt; q.m; ++k)\n                for (int j = 0; j &lt; m; ++j)\n                    res[i][k] = std::max(res[i][k], a[i][j] + q[j][k]);\n        return res;\n    &#125;\n    mat&amp; operator*= (mat &amp;q) &#123;\n        return *this = *this * q;\n    &#125;\n&#125;;\nstruct &#123; int l, r; mat u; &#125; t[maxn &lt;&lt; 2];\nint a[maxn];\n#define lt (p &lt;&lt; 1)\n#define rt (lt | 1)\nvoid bld(int p, int l, int r) &#123;\n    t[p].l = l, t[p].r = r;\n    if (l == r) &#123;\n        t[p].u = mat(4, 4);\n        t[p].u[0][0] = t[p].u[1][0] = t[p].u[2][0] = t[p].u[3][0] = 0;\n        t[p].u[0][1] = t[p].u[1][2] = t[p].u[2][3] = a[l];\n        return;\n    &#125;\n    int mid = (l + r) &gt;&gt; 1;\n    bld(lt, l, mid), bld(rt, mid + 1, r);\n    t[p].u = t[lt].u * t[rt].u;\n    return;\n&#125;\nvoid add(int p, int x, int v) &#123;\n    if (t[p].l == t[p].r) &#123;\n        t[p].u[0][1] = t[p].u[1][2] = t[p].u[2][3] = v;\n        return;\n    &#125;\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (x &lt;= mid)\n        add(lt, x, v);\n    else\n        add(rt, x, v);\n    t[p].u = t[lt].u * t[rt].u;\n    return;\n&#125;\nmat ask(int p, int l, int r) &#123;\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r)\n        return t[p].u;\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (r &lt;= mid)\n        return ask(lt, l, r);\n    if (l &gt; mid)\n        return ask(rt, l, r);\n    return ask(lt, l, r) * ask(rt, l, r);\n&#125;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i];\n    bld(1, 1, n);\n    auto calc = [&amp;](void) &#123;\n        mat f(1, 4);\n        f[0][0] = 0, f[0][1] = f[0][2] = f[0][3] = -inf;\n        auto r(f * ask(1, 2, n));\n        auto res(*std::max_element(r[0], r[0] + 4));\n        mat z(4, 4);\n        z[0][0] = z[1][0] = z[2][0] = z[3][0] = 0ll;\n        for (int i = 1; i &lt;= 3; ++i) &#123;\n            mat op(4, 4);\n            op[0][1] = op[1][2] = op[2][3] = a[i];\n            f *= op;\n            if (i + 2 &lt;= n)\n                r = f * z * ask(1, i + 2, n);\n            else\n                r = f * z;\n            res = std::max(res, *std::max_element(r[0], r[0] + 4 - i));\n        &#125;\n        return res;\n    &#125;;\n    std::cout &lt;&lt; calc() &lt;&lt; &#39;\\n&#39;;\n    int q;\n    std::cin &gt;&gt; q;\n    for (int x, v; q--; ) &#123;\n        std::cin &gt;&gt; x &gt;&gt; v, a[x] = v;\n        add(1, x, v);\n        std::cout &lt;&lt; calc() &lt;&lt; &#39;\\n&#39;;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"经典题gss3\">经典题：GSS3</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/SP1716\" class=\"uri\">https://www.luogu.com.cn/problem/SP1716</a></p>\n<p>怎么是子段和 😓</p>\n<p>同样列出能够矩阵乘法的 DP 式，发现限制在于至少要选一个数。设 <span class=\"math inline\">\\(f_{i}\\)</span> 表示选了 <span class=\"math inline\">\\(i\\)</span> 的最大值，<span class=\"math inline\">\\(g_i\\)</span> 表示历史最大值，则：</p>\n<p><span class=\"math display\">\\[\nf_i=\\max(f_{i-1}+a_i,0+a_i)\\\\\ng_i=\\max(g_{i-1}+0,f_{i-1}+a_i,0+a_i)\n\\]</span></p>\n<p>容易发现是一个 + / max 矩乘，线段树维护即可。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 4e5 + 5;\nconst long long inf = 1e18;\nstruct mat &#123;\n    int n, m;\n    long long a[3][3];\n    mat() &#123;&#125;\n    mat(int n1, int m1): n(n1), m(m1) &#123;\n        for (int i = 0; i &lt; n; ++i)\n            for (int j = 0; j &lt; m; ++j)\n                a[i][j] = -inf;\n        return;\n    &#125;\n    long long* operator[] (const int q) &#123;\n        return a[q];\n    &#125;\n    mat operator* (mat q) const &#123;\n        mat res(n, q.m);\n        for (int i = 0; i &lt; n; ++i)\n            for (int k = 0; k &lt; q.m; ++k)\n                for (int j = 0; j &lt; m; ++j)\n                    res[i][k] = std::max(res[i][k], a[i][j] + q[j][k]);\n        return res;\n    &#125;\n    mat&amp; operator*= (mat &amp;q) &#123;\n        return *this = *this * q;\n    &#125;\n&#125;;\nstruct &#123; int l, r; mat u; &#125; t[maxn &lt;&lt; 2]; \nint a[maxn];\n#define lt (p &lt;&lt; 1)\n#define rt (lt | 1)\nvoid bld(int p, int l, int r) &#123;\n    t[p].l = l, t[p].r = r;\n    if (l == r) &#123;\n        t[p].u = mat(3, 3);\n        t[p].u[0][0] = t[p].u[2][0] = a[l];\n        t[p].u[0][1] = a[l], t[p].u[1][1] = 0ll, t[p].u[2][1] = a[l];\n        t[p].u[2][2] = 0ll;\n        return;\n    &#125;\n    int mid = (l + r) &gt;&gt; 1;\n    bld(lt, l, mid), bld(rt, mid + 1, r);\n    t[p].u = t[lt].u * t[rt].u;\n    return;\n&#125;\nvoid add(int p, int x, int v) &#123;\n    if (t[p].l == t[p].r) &#123;\n        t[p].u[0][0] = t[p].u[2][0] = t[p].u[0][1] = t[p].u[2][1] = v;\n        return;\n    &#125;\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (x &lt;= mid)\n        add(lt, x, v);\n    else\n        add(rt, x, v);\n    t[p].u = t[lt].u * t[rt].u;\n    return;\n&#125;\nmat ask(int p, int l, int r) &#123;\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r)\n        return t[p].u;\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (r &lt;= mid)\n        return ask(lt, l, r);\n    if (l &gt; mid)\n        return ask(rt, l, r);\n    return ask(lt, l, r) * ask(rt, l, r);\n&#125;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i];\n    bld(1, 1, n);\n    auto calc = [&amp;](int l, int r) &#123;\n        mat f(1, 3);\n        f[0][2] = 0ll;\n        auto res(f * ask(1, l, r));\n        return res[0][1];\n    &#125;;\n    int q;\n    std::cin &gt;&gt; q;\n    for (int op; q--; ) &#123;\n        std::cin &gt;&gt; op;\n        if (op == 1) &#123;\n            int l, r;\n            std::cin &gt;&gt; l &gt;&gt; r;\n            std::cout &lt;&lt; calc(l, r) &lt;&lt; &#39;\\n&#39;;\n        &#125;\n        else &#123;\n            int x, v;\n            std::cin &gt;&gt; x &gt;&gt; v;\n            a[x] = v, add(1, x, v);\n        &#125;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"动态树-dp\">动态树 DP</h2>\n<p>把上述过程放到树上，很容易想到树剖 + 线段树。</p>\n<p>由于认为线段树上的矩乘只能进行从重儿子到父亲的转移，轻儿子的转移会被合并为一个新函数（同时是矩阵的系数），在跳重链的时候被单独更新。</p>\n<p>由于两个函数相互依赖，需要思考清楚更新的先后顺序。</p>\n<h3 id=\"模板动态-dp\">【模板】动态 DP</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P4719\" class=\"uri\">https://www.luogu.com.cn/problem/P4719</a></p>\n<p>令 <span class=\"math inline\">\\(f_{u,0/1}\\)</span> 表示在 <span class=\"math inline\">\\(u\\)</span> 上，选 / 不选 <span class=\"math inline\">\\(u\\)</span> 的最大价值。容易得出转移：</p>\n<p><span class=\"math display\">\\[\nf_{u,0}=\\sum\\max(f_{v,0},f_{v,1})\\\\\nf_{u,1}=a_i+\\sum f_{v,0}\n\\]</span></p>\n<p>把转移矩阵放到树剖上后，考虑更新，发现求和这一步很困难。解决方案是<strong>直接将求和用另一个函数代替</strong>。定义 <span class=\"math inline\">\\(g_{u,0}\\)</span> 表示取 <span class=\"math inline\">\\(u\\)</span>、不取 <span class=\"math inline\">\\(u\\)</span> 的所有轻儿子的答案，<span class=\"math inline\">\\(g_{u,1}\\)</span> 不取 <span class=\"math inline\">\\(u\\)</span>，轻儿子可选可不选的答案。</p>\n<p><span class=\"math inline\">\\(g\\)</span> 是可求的，且只需要在跳重链的时候更新 <span class=\"math inline\">\\(g\\)</span>。具体更新起来非常绞，因为 <span class=\"math inline\">\\(g\\)</span> 和 <span class=\"math inline\">\\(f\\)</span> 是相互依赖的，需要分清楚先后关系。</p>\n<p>首先 <span class=\"math inline\">\\(g_u\\)</span> 和 <span class=\"math inline\">\\(f_u\\)</span> 都会被更新；接着，重链上其它的 <span class=\"math inline\">\\(g\\)</span> 不会被影响，而链顶的 <span class=\"math inline\">\\(f\\)</span> 需要被新的 <span class=\"math inline\">\\(g_u\\)</span> 更新；由此链顶父亲的 <span class=\"math inline\">\\(g\\)</span> 被更新；依次类推。注意到对于一个链顶，其 <span class=\"math inline\">\\(f\\)</span> 值是整条重链的乘积，故需要记录链底。</p>\n<p>复杂度 <span class=\"math inline\">\\(O(q\\log ^2n)\\)</span>。注意很重要的一点是线段树内乘法应从右往左。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 1e5 + 5;\nconst int inf = 0x3f3f3f3f;\nstruct mat &#123;\n    int n, m, a[2][2];\n    mat() &#123;&#125;\n    mat(int n1, int m1): n(n1), m(m1) &#123;\n        for (int i = 0; i &lt; n; ++i)\n            for (int j = 0; j &lt; m; ++j)\n                a[i][j] = -inf;\n        return;\n    &#125;\n    int* operator[] (const int q) &#123;\n        return a[q];\n    &#125;\n    mat operator* (mat q) const &#123;\n        mat res(n, q.m);\n        for (int i = 0; i &lt; n; ++i)\n            for (int k = 0; k &lt; q.m; ++k)\n                for (int j = 0; j &lt; m; ++j)\n                    res[i][k] = std::max(res[i][k], a[i][j] + q[j][k]);\n        return res;\n    &#125;\n    mat&amp; operator*= (mat &amp;q) &#123;\n        return *this = *this * q;\n    &#125;\n&#125;;\nstruct &#123; int l, r; mat u; &#125; t[maxn &lt;&lt; 2]; \nint g[maxn][2], tab[maxn];\n#define lt (p &lt;&lt; 1)\n#define rt (lt | 1)\nvoid bld(int p, int l, int r) &#123;\n    t[p].l = l, t[p].r = r;\n    if (l == r) &#123;\n        int u = tab[l];\n        t[p].u = mat(2, 2);\n        t[p].u[0][0] = t[p].u[1][0] = g[u][1];\n        t[p].u[0][1] = g[u][0];\n        return;\n    &#125;\n    int mid = (l + r) &gt;&gt; 1;\n    bld(lt, l, mid), bld(rt, mid + 1, r);\n    t[p].u = t[rt].u * t[lt].u;\n    return;\n&#125;\nvoid add(int p, int x) &#123;\n    if (t[p].l == t[p].r) &#123;\n        int u = tab[x];\n        t[p].u[0][0] = t[p].u[1][0] = g[u][1];\n        t[p].u[0][1] = g[u][0];\n        return;\n    &#125;\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (x &lt;= mid)\n        add(lt, x);\n    else\n        add(rt, x);\n    t[p].u = t[rt].u * t[lt].u;\n    return;\n&#125;\nmat ask(int p, int l, int r) &#123;\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r)\n        return t[p].u;\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (r &lt;= mid)\n        return ask(lt, l, r);\n    if (l &gt; mid)\n        return ask(rt, l, r);\n    return ask(rt, l, r) * ask(lt, l, r);\n&#125;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, q;\n    std::cin &gt;&gt; n &gt;&gt; q;\n    std::vector&lt;int&gt; a(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i];\n    std::vector&lt;std::vector&lt;int&gt; &gt; g1(n + 1);\n    for (int i = 1, x, y; i &lt; n; ++i) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y;\n        g1[x].push_back(y), g1[y].push_back(x);\n    &#125;\n    std::vector&lt;int&gt; siz(n + 1), son(n + 1), fa(n + 1);\n    std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;\n        siz[x] = 1;\n        for (auto i : g1[x])\n            if (i != fa[x]) &#123;\n                fa[i] = x, DFS(i);\n                siz[x] += siz[i];\n                if (siz[i] &gt; siz[son[x]])\n                    son[x] = i;\n            &#125;\n        return;\n    &#125;;\n    DFS(1);\n    std::vector&lt;std::array&lt;int, 2&gt; &gt; f(n + 1);\n    std::vector&lt;int&gt; top(n + 1), bot(n + 1), dfn(n + 1);\n    DFS = [&amp;](int x) &#123;\n        static int now = 0;\n        dfn[x] = ++now, tab[now] = x;\n        if (son[x]) &#123;\n            top[son[x]] = top[x], DFS(son[x]);\n            bot[x] = bot[son[x]];\n            g[x][0] = a[x];\n            for (auto i : g1[x])\n                if (i != son[x] &amp;&amp; i != fa[x]) &#123;\n                    top[i] = i, DFS(i);\n                    g[x][0] += f[i][0];\n                    g[x][1] += std::max(f[i][1], f[i][0]);\n                &#125;\n            f[x][0] = g[x][1] + std::max(f[son[x]][0], f[son[x]][1]);\n            f[x][1] = g[x][0] + f[son[x]][0];\n        &#125;\n        else\n            f[x][1] = g[x][0] = a[x], bot[x] = x;\n        return;\n    &#125;;\n    top[1] = 1, DFS(1);\n    bld(1, 1, n);\n    for (int x, v; q--; ) &#123;\n        std::cin &gt;&gt; x &gt;&gt; v;\n        g[x][0] -= a[x], g[x][0] += v, a[x] = v;\n        for (; top[x] != 1; ) &#123;\n            auto r = ask(1, dfn[top[x]], dfn[bot[x]]);\n            f[top[x]][0] = r[0][0], f[top[x]][1] = r[0][1];\n            g[fa[top[x]]][0] -= f[top[x]][0];\n            g[fa[top[x]]][1] -= std::max(f[top[x]][0], f[top[x]][1]);\n            add(1, dfn[x]);\n            r = ask(1, dfn[top[x]], dfn[bot[x]]);\n            f[top[x]][0] = r[0][0], f[top[x]][1] = r[0][1];\n            g[fa[top[x]]][0] += f[top[x]][0];\n            g[fa[top[x]]][1] += std::max(f[top[x]][0], f[top[x]][1]);\n            x = fa[top[x]];\n        &#125;\n        add(1, dfn[x]);\n        auto r = ask(1, dfn[1], dfn[bot[1]]);\n        f[1][0] = r[0][0], f[1][1] = r[0][1];\n        std::cout &lt;&lt; std::max(f[1][0], f[1][1]) &lt;&lt; &#39;\\n&#39;;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"全局平衡二叉树\">全局平衡二叉树</h2>\n<p>回顾树剖（重剖），功能在于解决路径问题，单次操作能够在 <span class=\"math inline\">\\(O(\\log^2 n)\\)</span> 的时间内完成。这个功能可以被<strong>全局平衡二叉树（GBT）</strong>上位替代。GBT 能够在单次 <span class=\"math inline\">\\(O(\\log n)\\)</span> 的复杂度内完成链操作、子树操作。<em><a href=\"QTREE解法的一些研究.pdf\">Yang Zhe - SPOJ375 QTREE 解法的一些研究</a> 中更为详细严谨地对 GBT 进行了说明，我传了份文件上来。</em></p>\n<p>考虑树剖能被卡的原因：每次线段树询问都会卡满 <span class=\"math inline\">\\(O(\\log n)\\)</span>，找一条卡得满 <span class=\"math inline\">\\(O(\\log n)\\)</span> 次跳重链次数的路径一直薅，就可以卡到 <span class=\"math inline\">\\(O(\\log^2 n)\\)</span>。</p>\n<p>在实现线段树时发现，对于<strong>路径操作</strong>和<strong>单点操作</strong>，树剖只需要维护同一条重链的信息，建一个大线段树会产生许多重链间的无效维护。故一种经典的树剖卡常技巧是对于每一条重链建出线段树。</p>\n<p>在本文中定义<strong>全局二叉树</strong>：将单个线段树按照在原树上重链顶的相对祖孙关系连边得到的模型。这里为了和<strong>全局平衡二叉树</strong>形成照应而命名，实际上模型并不是二叉树。容易发现<strong>修改某个点花费的操作次数和其在全局二叉树中的深度相同</strong>。</p>\n<p>考虑本方法理论上仍可卡到 <span class=\"math inline\">\\(O(\\log^2 n)\\)</span> 单次操作的原因，虽然单个线段树平衡，但<strong>全局二叉树</strong>并不平衡；能够构造数据使得树高达到 <span class=\"math inline\">\\(\\log^2 n\\)</span>。考虑使得全局二叉树平衡，即调整线段树结构使得任何一个点在全局二叉树上的左右儿子大小最接近。发现是易做的，只需在建线段树时移动左右儿子分割点使得两边子树大小均为全树的一半即可。</p>\n<p>法一：求出每个点的轻子树大小 <span class=\"math inline\">\\(ls_u=1+\\sum siz_v\\)</span>，作为加权在线段树上找 mid 就能满足全局平衡；证明可以见上面的论文。这里用线段树代替了 BST，常数很大。</p>\n<p>法二：用一个 BST 实现上述功能，需要满足：任意子树的根为子树的带权 mid；BST 的中序遍历为原重链。显然有：树高为 log 级别。这就决定了所有问题都可以通过暴力爬山解决。</p>\n<p>GBT 能够快速维护<strong>普通树剖操作</strong>和 <strong>DDP 信息</strong>。</p>\n<hr />\n<h3 id=\"维护-ddp模板动态-dp加强版\">维护 DDP：【模板】动态 DP（加强版）</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P4751\" class=\"uri\">https://www.luogu.com.cn/problem/P4751</a></p>\n<p>和未加强版类似，把所有线段树操作替换为 BST 即可。如果写得丑可能需要一些额外的卡常技巧。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 1e6 + 5;\nconst int inf = 0x3f3f3f3f;\nconst int LEN = (1 &lt;&lt; 20);\nint nec(void) &#123;\n    static char buf[LEN], *p = buf, *e = buf;\n    if (p == e) &#123;\n        e = buf + fread(buf, 1, LEN, stdin);\n        if (e == buf) return EOF;\n        p = buf;\n    &#125;\n    return *p++;\n&#125;\nbool read(int &amp;x) &#123;\n    x = 0;\n    bool f = 0;\n    char ch = nec();\n    while (ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123;\n        if (ch == EOF) return 0;\n        if (ch == &#39;-&#39;) f = 1;\n        ch = nec();\n    &#125;\n    while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) &#123;\n        x = x * 10 + ch - &#39;0&#39;;\n        ch = nec();\n    &#125;\n    if (f) x = -x;\n    return 1;\n&#125;\nvoid print(int x) &#123;\n    if (x &lt; 0)\n        putchar(&#39;-&#39;), x = -x;\n    if (x &gt;= 10) print(x / 10);\n    putchar(x % 10 + &#39;0&#39;);\n    return;\n&#125;\nvoid print(int x, char ch) &#123;\n    print(x), putchar(ch);\n    return;\n&#125;\nstruct mat &#123;\n    int a[2][2];\n    int* operator[] (const int q) &#123; \n        return a[q];\n    &#125;\n    mat operator* (mat &amp;q) const &#123;\n        mat res;\n        res[0][0] = res[0][1] = res[1][0] = res[1][1] = -inf;\n        for (int i = 0; i &lt; 2; ++i)\n            for (int k = 0; k &lt; 2; ++k)\n                for (int j = 0; j &lt; 2; ++j)\n                    res[i][k] = std::max(res[i][k], a[i][j] + q[j][k]);\n        return res;\n    &#125;\n    mat&amp; operator*= (mat &amp;q) &#123;\n        return *this = *this * q;\n    &#125;\n&#125;;\nstruct &#123; int lc, rc, fa; mat u; &#125; t[maxn]; \nint g[maxn][2], tab[maxn], ls[maxn];\nmat p[maxn];\nvoid pushup(int x) &#123;\n    t[x].u = t[t[x].rc].u * p[x] * t[t[x].lc].u;\n    return;\n&#125;\nvoid bld(int &amp;x, int l, int r) &#123;\n    if (l &gt; r)\n        return;\n    int s = 0, k = 0;\n    for (int i = l; i &lt;= r; ++i)\n        s += ls[tab[i]];\n    for (int i = l; i &lt;= r; ++i, k += ls[tab[i]])\n        if ((k + ls[tab[i]]) * 2 &gt; s) &#123;\n            x = tab[i];\n            bld(t[x].lc, l, i - 1), t[t[x].lc].fa = x;\n            bld(t[x].rc, i + 1, r), t[t[x].rc].fa = x;\n            pushup(x);\n            break;\n        &#125;\n    return;\n&#125;\n#undef lt\n#undef rt\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    t[0].u[0][0] = t[0].u[1][1] = 0, t[0].u[0][1] = t[0].u[1][0] = -inf;\n    int n, q;\n    read(n), read(q);\n    std::vector&lt;int&gt; a(n + 1), rt(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        read(a[i]);\n    std::vector&lt;std::vector&lt;int&gt; &gt; g1(n + 1);\n    for (int i = 1, x, y; i &lt; n; ++i) &#123;\n        read(x), read(y);\n        g1[x].push_back(y), g1[y].push_back(x);\n    &#125;\n    std::vector&lt;int&gt; son(n + 1), fa(n + 1), siz(n + 1);\n    std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;\n        siz[x] = 1;\n        for (auto i : g1[x])\n            if (i != fa[x]) &#123;\n                fa[i] = x, DFS(i);\n                siz[x] += siz[i];\n                if (siz[i] &gt; siz[son[x]])\n                    son[x] = i;\n            &#125;\n        return;\n    &#125;;\n    DFS(1);\n    std::vector&lt;std::array&lt;int, 2&gt; &gt; f(n + 1);\n    std::vector&lt;int&gt; top(n + 1), bot(n + 1), dfn(n + 1);\n    DFS = [&amp;](int x) &#123;\n        static int now = 0;\n        dfn[x] = ++now, tab[now] = x, ls[x] = 1;\n        if (son[x]) &#123;\n            top[son[x]] = top[x], DFS(son[x]);\n            bot[x] = bot[son[x]];\n            g[x][0] = a[x];\n            for (auto i : g1[x])\n                if (i != son[x] &amp;&amp; i != fa[x]) &#123;\n                    top[i] = i, DFS(i), t[rt[i]].fa = x;\n                    ls[x] += siz[i];\n                    g[x][0] += f[i][0];\n                    g[x][1] += std::max(f[i][1], f[i][0]);\n                &#125;\n            f[x][0] = g[x][1] + std::max(f[son[x]][0], f[son[x]][1]);\n            f[x][1] = g[x][0] + f[son[x]][0];\n        &#125;\n        else\n            f[x][1] = g[x][0] = a[x], bot[x] = x;\n        p[x][0][0] = p[x][1][0] = g[x][1];\n        p[x][0][1] = g[x][0], p[x][1][1] = -inf;\n        if (x == top[x])\n            bld(rt[x], dfn[x], dfn[bot[x]]);\n        return;\n    &#125;;\n    top[1] = 1, DFS(1);\n    for (int x, v, la = 0; q--; ) &#123;\n        read(x), read(v), x ^= la;\n        p[x][0][1] += v - a[x], a[x] = v;\n        for (; x; ) &#123;\n            int fa = t[x].fa;\n            if (fa &amp;&amp; x != t[fa].lc &amp;&amp; x != t[fa].rc) &#123;\n                int f0 = t[x].u[0][0], f1 = std::max(f0, t[x].u[0][1]);\n                pushup(x);\n                int F0 = t[x].u[0][0], F1 = std::max(F0, t[x].u[0][1]);\n                p[fa][0][0] += F1 - f1, p[fa][1][0] += F1 - f1;\n                p[fa][0][1] += F0 - f0;\n            &#125;\n            else\n                pushup(x);\n            x = fa;\n        &#125;\n        print(la = std::max(t[rt[1]].u[0][0], t[rt[1]].u[0][1]), &#39;\\n&#39;);\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<p>也给出一个线段树版本的</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 1e6 + 5;\nconst int inf = 0x3f3f3f3f;\nconst int LEN = (1 &lt;&lt; 20);\nint nec(void) &#123;\n    static char buf[LEN], *p = buf, *e = buf;\n    if (p == e) &#123;\n        e = buf + fread(buf, 1, LEN, stdin);\n        if (e == buf) return EOF;\n        p = buf;\n    &#125;\n    return *p++;\n&#125;\nbool read(int &amp;x) &#123;\n    x = 0;\n    bool f = 0;\n    char ch = nec();\n    while (ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123;\n        if (ch == EOF) return 0;\n        if (ch == &#39;-&#39;) f = 1;\n        ch = nec();\n    &#125;\n    while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) &#123;\n        x = x * 10 + ch - &#39;0&#39;;\n        ch = nec();\n    &#125;\n    if (f) x = -x;\n    return 1;\n&#125;\nvoid print(int x) &#123;\n    if (x &lt; 0)\n        putchar(&#39;-&#39;), x = -x;\n    if (x &gt;= 10) print(x / 10);\n    putchar(x % 10 + &#39;0&#39;);\n    return;\n&#125;\nvoid print(int x, char ch) &#123;\n    print(x), putchar(ch);\n    return;\n&#125;\nstruct mat &#123;\n    int a[2][2];\n    int* operator[] (const int q) &#123;\n        return a[q];\n    &#125;\n    mat operator* (mat q) const &#123;\n        mat res;\n        res[0][0] = res[0][1] = res[1][0] = res[1][1] = -inf;\n        for (int i = 0; i &lt; 2; ++i)\n            for (int k = 0; k &lt; 2; ++k)\n                for (int j = 0; j &lt; 2; ++j)\n                    res[i][k] = std::max(res[i][k], a[i][j] + q[j][k]);\n        return res;\n    &#125;\n    mat&amp; operator*= (mat &amp;q) &#123;\n        return *this = *this * q;\n    &#125;\n&#125;;\nstruct &#123; int lc, rc, l, r, mid; mat u; &#125; t[maxn &lt;&lt; 2]; \nint g[maxn][2], tab[maxn], ls[maxn];\n#define lt t[p].lc\n#define rt t[p].rc\nvoid bld(int &amp;p, int l, int r) &#123;\n    static int tot = 0;\n    p = ++tot, t[p].l = l, t[p].r = r;\n    if (l == r) &#123;\n        int u = tab[l];\n        t[p].u[0][0] = t[p].u[1][0] = g[u][1];\n        t[p].u[0][1] = g[u][0], t[p].u[1][1] = -inf;\n        return;\n    &#125;\n    int s = 0, u = ls[tab[l]];\n    for (int i = l; i &lt;= r; ++i)\n        s += ls[tab[i]];\n    s &gt;&gt;= 1;\n    t[p].mid = r - 1;\n    for (int i = l + 1; i &lt; r; ++i) &#123;\n        u += ls[tab[i]];\n        if (u + ls[tab[i + 1]] &gt; s) &#123;\n            t[p].mid = i;\n            break;\n        &#125;\n    &#125;\n    bld(lt, l, t[p].mid), bld(rt, t[p].mid + 1, r);\n    t[p].u = t[rt].u * t[lt].u;\n    return;\n&#125;\nvoid add(int p, int x) &#123;\n    if (t[p].l == t[p].r) &#123;\n        int u = tab[x];\n        t[p].u[0][0] = t[p].u[1][0] = g[u][1];\n        t[p].u[0][1] = g[u][0];\n        return;\n    &#125;\n    if (x &lt;= t[p].mid)\n        add(lt, x);\n    else\n        add(rt, x);\n    t[p].u = t[rt].u * t[lt].u;\n    return;\n&#125;\nmat ask(int p, int l, int r) &#123;\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r)\n        return t[p].u;\n    if (r &lt;= t[p].mid)\n        return ask(lt, l, r);\n    if (l &gt; t[p].mid)\n        return ask(rt, l, r);\n    return ask(rt, l, r) * ask(lt, l, r);\n&#125;\n#undef lt\n#undef rt\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, q;\n    read(n), read(q);\n    std::vector&lt;int&gt; a(n + 1), rt(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        read(a[i]);\n    std::vector&lt;std::vector&lt;int&gt; &gt; g1(n + 1);\n    for (int i = 1, x, y; i &lt; n; ++i) &#123;\n        read(x), read(y);\n        g1[x].push_back(y), g1[y].push_back(x);\n    &#125;\n    std::vector&lt;int&gt; siz(n + 1), son(n + 1), fa(n + 1);\n    std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;\n        siz[x] = 1;\n        for (auto i : g1[x])\n            if (i != fa[x]) &#123;\n                fa[i] = x, DFS(i);\n                siz[x] += siz[i];\n                if (siz[i] &gt; siz[son[x]])\n                    son[x] = i;\n            &#125;\n        return;\n    &#125;;\n    DFS(1);\n    std::vector&lt;std::array&lt;int, 2&gt; &gt; f(n + 1);\n    std::vector&lt;int&gt; top(n + 1), bot(n + 1), dfn(n + 1);\n    DFS = [&amp;](int x) &#123;\n        static int now = 0;\n        dfn[x] = ++now, tab[now] = x;\n        ls[x] = 1;\n        if (son[x]) &#123;\n            top[son[x]] = top[x], DFS(son[x]);\n            bot[x] = bot[son[x]];\n            g[x][0] = a[x];\n            for (auto i : g1[x])\n                if (i != son[x] &amp;&amp; i != fa[x]) &#123;\n                    top[i] = i, DFS(i);\n                    ls[x] += siz[i];\n                    g[x][0] += f[i][0];\n                    g[x][1] += std::max(f[i][1], f[i][0]);\n                &#125;\n            f[x][0] = g[x][1] + std::max(f[son[x]][0], f[son[x]][1]);\n            f[x][1] = g[x][0] + f[son[x]][0];\n        &#125;\n        else\n            f[x][1] = g[x][0] = a[x], bot[x] = x;\n        if (x == top[x])\n            bld(rt[x], dfn[x], dfn[bot[x]]);\n        return;\n    &#125;;\n    top[1] = 1, DFS(1);\n    for (int x, v, la = 0; q--; ) &#123;\n        read(x), read(v), x ^= la;\n        g[x][0] -= a[x], g[x][0] += v, a[x] = v;\n        for (; top[x] != 1; ) &#123;\n            auto r = t[rt[top[x]]].u;\n            f[top[x]][0] = r[0][0], f[top[x]][1] = r[0][1];\n            g[fa[top[x]]][0] -= f[top[x]][0];\n            g[fa[top[x]]][1] -= std::max(f[top[x]][0], f[top[x]][1]);\n            add(rt[top[x]], dfn[x]);\n            r = t[rt[top[x]]].u;\n            f[top[x]][0] = r[0][0], f[top[x]][1] = r[0][1];\n            g[fa[top[x]]][0] += f[top[x]][0];\n            g[fa[top[x]]][1] += std::max(f[top[x]][0], f[top[x]][1]);\n            x = fa[top[x]];\n        &#125;\n        add(rt[1], dfn[x]);\n        auto r =  t[rt[1]].u;\n        f[1][0] = r[0][0], f[1][1] = r[0][1];\n        std::cout &lt;&lt; (la = std::max(f[1][0], f[1][1])) &lt;&lt; &#39;\\n&#39;;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"树上路径问题染色\">树上路径问题：染色</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P2486\" class=\"uri\">https://www.luogu.com.cn/problem/P2486</a></p>\n<p>GBT 上的<strong>路径问题</strong>。</p>\n<p>BST：首先暴力爬山到 LCA，统计一路上的答案；然后跳到当前 BST 的根。由于本题有标记，所以需要在跳的同时想办法把标记问题解决一下。</p>\n<p>线段树：把树剖的线段树略改一下就过了。从上一行模棱两可的描述就可以看出来 BST 实现起来不太轻松；还是线段树更轮椅啊！</p>\n<details>\n<p>跑得没纯树剖快，因为数据没有刻意构造导致树高很低，再加上常数的影响吧。</p>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 1e5 + 5;\nconst int LEN = (1 &lt;&lt; 20);\nint nec(void) &#123;\n    static char buf[LEN], *p = buf, *e = buf;\n    if (p == e) &#123;\n        e = buf + fread(buf, 1, LEN, stdin);\n        if (e == buf) return EOF;\n        p = buf;\n    &#125;\n    return *p++;\n&#125;\nbool read(int &amp;x) &#123;\n    x = 0;\n    bool f = 0;\n    char ch = nec();\n    while (ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123;\n        if (ch == EOF) return 0;\n        if (ch == &#39;-&#39;) f = 1;\n        ch = nec();\n    &#125;\n    while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) &#123;\n        x = x * 10 + ch - &#39;0&#39;;\n        ch = nec();\n    &#125;\n    if (f) x = -x;\n    return 1;\n&#125;\nvoid read(char &amp;x) &#123;\n    for (x = nec(); x != &#39;C&#39; &amp;&amp; x != &#39;Q&#39;; x = nec());\n    return;\n&#125;\nvoid print(int x) &#123;\n    if (x &lt; 0)\n        putchar(&#39;-&#39;), x = -x;\n    if (x &gt;= 10) print(x / 10);\n    putchar(x % 10 + &#39;0&#39;);\n    return;\n&#125;\nvoid print(int x, char ch) &#123;\n    print(x), putchar(ch);\n    return;\n&#125;\nclass node &#123;\nprivate:\n    int lt, rt;\npublic:\n    int l, r, mid, lc, rc, u, d;\n    node(): u(-1) &#123;&#125;\n    inline int&amp; ls(void) &#123; return lt; &#125;\n    inline int&amp; rs(void) &#123; return rt; &#125;\n    node&amp; operator= (const node &amp;q) &#123;\n        lc = q.lc, rc = q.rc, u = q.u;\n        return *this;\n    &#125;\n    node operator+ (const node &amp;q) const &#123;\n        if (u == -1)\n            return q;\n        if (q.u == -1)\n            return *this;\n        node res;\n        res.lc = lc, res.rc = q.rc, res.u = u + q.u - (rc == q.lc);\n        return res;\n    &#125;\n    inline void swap(void) &#123;\n        if (~u)\n            lc ^= rc ^= lc ^= rc;\n        return;\n    &#125;\n&#125; t[maxn &lt;&lt; 2]; \nint tab[maxn], ls[maxn], a[maxn];\n#define lt t[p].ls()\n#define rt t[p].rs()\nvoid bld(int &amp;p, int l, int r) &#123;\n    static int tot = 0;\n    p = ++tot, t[p].l = l, t[p].r = r;\n    if (l == r) &#123;\n        t[p].u = 1;\n        t[p].lc = t[p].rc = a[tab[l]];\n        return;\n    &#125;\n    int s = 0, u = ls[tab[l]];\n    for (int i = l; i &lt;= r; ++i)\n        s += ls[tab[i]];\n    s &gt;&gt;= 1;\n    t[p].mid = r - 1;\n    for (int i = l + 1; i &lt; r; ++i) &#123;\n        u += ls[tab[i]];\n        if (u + ls[tab[i + 1]] &gt; s) &#123;\n            t[p].mid = i;\n            break;\n        &#125;\n    &#125;\n    bld(lt, l, t[p].mid), bld(rt, t[p].mid + 1, r);\n    t[p] = t[lt] + t[rt];\n    return;\n&#125;\nvoid pushdown(int p) &#123;\n    if (t[p].d) &#123;\n        t[lt].d = t[lt].lc = t[lt].rc = t[rt].d = t[rt].lc = t[rt].rc = t[p].d;\n        t[lt].u = t[rt].u = 1;\n        t[p].d = 0;\n    &#125;\n    return;\n&#125;\nvoid add(int p, int l, int r, int v) &#123;\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r) &#123;\n        t[p].u = 1;\n        t[p].lc = t[p].rc = t[p].d = v;\n        return;\n    &#125;\n    pushdown(p);\n    if (l &lt;= t[p].mid)\n        add(lt, l, r, v);\n    if (r &gt; t[p].mid)\n        add(rt, l, r, v);\n    t[p] = t[lt] + t[rt];\n    return;\n&#125;\nnode ask(int p, int l, int r) &#123;\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r)\n        return t[p];\n    pushdown(p);\n    if (r &lt;= t[p].mid)\n        return ask(lt, l, r);\n    if (l &gt; t[p].mid)\n        return ask(rt, l, r);\n    return ask(lt, l, r) + ask(rt, l, r);\n&#125;\n#undef lt\n#undef rt\nint main() &#123;\n#ifdef ONLINE_JUDGE\n#else\n    std::freopen(&quot;paint17.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, q;\n    read(n), read(q);\n    std::vector&lt;int&gt; rt(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        read(a[i]);\n    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);\n    for (int i = 1, x, y; i &lt; n; ++i) &#123;\n        read(x), read(y);\n        g[x].push_back(y), g[y].push_back(x);\n    &#125;\n    std::vector&lt;int&gt; siz(n + 1), son(n + 1), fa(n + 1), dep(n + 1);\n    std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;\n        siz[x] = 1;\n        for (auto i : g[x])\n            if (i != fa[x]) &#123;\n                dep[i] = dep[x] + 1;\n                fa[i] = x, DFS(i);\n                siz[x] += siz[i];\n                if (siz[i] &gt; siz[son[x]])\n                    son[x] = i;\n            &#125;\n        return;\n    &#125;;\n    DFS(1);\n    std::vector&lt;std::array&lt;int, 2&gt; &gt; f(n + 1);\n    std::vector&lt;int&gt; top(n + 1), bot(n + 1), dfn(n + 1);\n    DFS = [&amp;](int x) &#123;\n        static int now = 0;\n        dfn[x] = ++now, tab[now] = x, ls[x] = 1;\n        if (son[x]) &#123;\n            top[son[x]] = top[x], DFS(son[x]);\n            bot[x] = bot[son[x]];\n        &#125;\n        else\n            bot[x] = x;\n        for (auto i : g[x])\n            if (i != son[x] &amp;&amp; i != fa[x]) &#123;\n                top[i] = i;\n                DFS(i);\n                ls[x] += siz[i];\n            &#125;\n        if (x == top[x])\n            bld(rt[x], dfn[x], dfn[bot[x]]);\n        return;\n    &#125;;\n    top[1] = 1, DFS(1);\n    for (char op; q--; ) &#123;\n        read(op);\n        if (op == &#39;C&#39;) &#123;\n            int x, y, c;\n            read(x), read(y), read(c);\n            for (; top[x] != top[y]; x = fa[top[x]]) &#123;\n                if (dep[top[x]] &lt; dep[top[y]])\n                    std::swap(x, y);\n                add(rt[top[x]], dfn[top[x]], dfn[x], c);\n            &#125;\n            if (dep[x] &gt; dep[y])\n                std::swap(x, y);\n            add(rt[top[x]], dfn[x], dfn[y], c);\n        &#125;\n        else &#123;\n            int x, y;\n            read(x), read(y);\n            node res1, res2;\n            for (; top[x] != top[y]; )\n                if (dep[top[x]] &lt; dep[top[y]]) &#123;\n                    res2 = ask(rt[top[y]], dfn[top[y]], dfn[y]) + res2;\n                    y = fa[top[y]];\n                &#125;\n                else &#123;\n                    res1 = ask(rt[top[x]], dfn[top[x]], dfn[x]) + res1;\n                    x = fa[top[x]];\n                &#125;\n            if (dep[x] &gt; dep[y])\n                res1 = ask(rt[top[y]], dfn[y], dfn[x]) + res1;\n            else\n                res2 = ask(rt[top[x]], dfn[x], dfn[y]) + res2;\n            res1.swap();\n            print((res1 + res2).u, &#39;\\n&#39;);\n        &#125;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"树上路径查询\">树上路径查询？</h3>\n<p>做题的时候可以感受到，路径询问的存在很诡异，因为只需要一条链的操作，更偏向链上 DDP 而非树上的；<strong>轻儿子的信息是不用维护的</strong>，形式上更像树剖（DS）；当成链上的 DDP 就可以解决了。</p>\n<p>可以用倍增维护 DDP（不用考虑轻重儿子，只用维护父子关系，进一步向序列 DDP 靠近），就不用打 GBT 了，常数也会小一些。</p>\n<hr />\n<h2 id=\"习题\">习题</h2>\n<p>GBT 就统一用线段树了。DDP 也就可以顺带用 GBT 优化了。</p>\n<hr />\n<h3 id=\"e---猫或狗-cats-or-dogs\">E - 猫或狗 / Cats or Dogs</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P9597\" class=\"uri\">https://www.luogu.com.cn/problem/P9597</a></p>\n<p>设 <span class=\"math inline\">\\(f_{u,0/1}\\)</span> 表示从根上颜色为 <span class=\"math inline\">\\(0/1\\)</span> 时的最小断边数，显然无色可以视作任选一个颜色。那么有：</p>\n<p><span class=\"math display\">\\[\nf_{u,a}=\\sum\\limits_v\\min\\limits_{b\\in\\{0,1\\}}\\{f_{v,b}+[a\\ne b]\\}\n\\]</span></p>\n<p>直接把轻儿子的项提出来，记 <span class=\"math inline\">\\(g_{u,0/1}\\)</span> 表示 <span class=\"math inline\">\\(f_{u,0/1}\\)</span> 对应的轻儿子贡献即可。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 1e5 + 5;\nconst int inf = 0x3f3f3f3f;\nstruct mat &#123;\n    int a[2][2];\n    int* operator[] (const int q) &#123; \n        return a[q];\n    &#125;\n    mat operator* (mat &amp;q) const &#123;\n        mat res;\n        res[0][0] = res[0][1] = res[1][0] = res[1][1] = inf;\n        for (int i = 0; i &lt; 2; ++i)\n            for (int k = 0; k &lt; 2; ++k)\n                for (int j = 0; j &lt; 2; ++j)\n                    res[i][k] = std::min(res[i][k], a[i][j] + q[j][k]);\n        return res;\n    &#125;\n    mat&amp; operator*= (mat &amp;q) &#123;\n        return *this = *this * q;\n    &#125;\n&#125; p[maxn];\nstruct &#123; int lc, rc, l, r, mid; mat u; &#125; t[maxn &lt;&lt; 2]; \nint ls[maxn], tab[maxn], g[maxn][2], rt[maxn], top[maxn], dfn[maxn], fa[maxn];\nstd::vector&lt;int&gt; a;\n#define lt t[p].lc\n#define rt t[p].rc\nvoid bld(int &amp;p, int l, int r) &#123;\n    static int tot = 0;\n    p = ++tot, t[p].l = l, t[p].r = r;\n    if (l == r) &#123;\n        t[p].u[0][1] = t[p].u[1][0] = 1;\n        return;\n    &#125;\n    int s = 0, u = ls[tab[l]];\n    for (int i = l; i &lt;= r; ++i)\n        s += ls[tab[i]];\n    s &gt;&gt;= 1;\n    t[p].mid = r - 1;\n    for (int i = l + 1; i &lt; r; ++i) &#123;\n        u += ls[tab[i]];\n        if (u + ls[tab[i + 1]] &gt; s) &#123;\n            t[p].mid = i;\n            break;\n        &#125;\n    &#125;\n    bld(lt, l, t[p].mid), bld(rt, t[p].mid + 1, r);\n    t[p].u = t[rt].u * t[lt].u;\n    return;\n&#125;\nvoid add(int p, int x) &#123;\n    if (t[p].l == t[p].r) &#123;\n        int u = tab[x], g0 = (a[u] == 1 ? inf : g[u][0]), g1 = (a[u] == 0 ? inf : g[u][1]);\n        t[p].u[0][0] = g0, t[p].u[0][1] = g1 + 1;\n        t[p].u[1][0] = g0 + 1, t[p].u[1][1] = g1;\n        return;\n    &#125;\n    if (x &lt;= t[p].mid)\n        add(lt, x);\n    else\n        add(rt, x);\n    t[p].u = t[rt].u * t[lt].u;\n    return;\n&#125;\n#undef lt\n#undef rt\nvoid initialize(int n, std::vector&lt;int&gt; A, std::vector&lt;int&gt; B) &#123;\n    a.assign(n + 1, -1);\n    std::vector&lt;std::vector&lt;int&gt; &gt; g1(n + 1);\n    for (int i = 0; i &lt; n - 1; ++i)\n        g1[A[i]].push_back(B[i]), g1[B[i]].push_back(A[i]);\n    std::vector&lt;int&gt; siz(n + 1), son(n + 1);\n    std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;\n        siz[x] = 1;\n        for (auto i : g1[x])\n            if (i != fa[x]) &#123;\n                fa[i] = x, DFS(i);\n                siz[x] += siz[i];\n                if (siz[i] &gt; siz[son[x]])\n                    son[x] = i;\n            &#125;\n        return;\n    &#125;;\n    DFS(1);\n    std::vector&lt;int&gt; bot(n + 1);\n    DFS = [&amp;](int x) &#123;\n        static int now = 0;\n        dfn[x] = ++now, tab[now] = x, ls[x] = 1;\n        if (son[x]) &#123;\n            top[son[x]] = top[x], DFS(son[x]);\n            bot[x] = bot[son[x]];\n            for (auto i : g1[x])\n                if (i != son[x] &amp;&amp; i != fa[x]) &#123;\n                    top[i] = i, DFS(i);\n                    ls[x] += siz[i];\n                &#125;\n        &#125;\n        else\n            bot[x] = x;\n        if (x == top[x])\n            bld(rt[x], dfn[x], dfn[bot[x]]);\n        return;\n    &#125;;\n    top[1] = 1, DFS(1);\n    return;\n&#125;\nint upd(int x) &#123;\n    for (; top[x] != 1; ) &#123;\n        int faa = fa[top[x]];\n        auto &amp;id = t[rt[top[x]]].u;\n        int f0 = std::min(id[0][0], id[1][0]), f1 = std::min(id[0][1], id[1][1]);\n        g[faa][0] -= std::min(f0, f1 + 1);\n        g[faa][1] -= std::min(f0 + 1, f1);\n        add(rt[top[x]], dfn[x]);\n        f0 = std::min(id[0][0], id[1][0]), f1 = std::min(id[0][1], id[1][1]);\n        // printf(&quot;%d: f0 = %d, f1 = %d\\n&quot;, top[x], f0, f1);\n        g[faa][0] += std::min(f0, f1 + 1);\n        g[faa][1] += std::min(f0 + 1, f1);\n        x = faa;\n    &#125;\n    add(rt[1], dfn[x]);\n    auto &amp;id = t[rt[1]].u;\n    int f0 = std::min(id[0][0], id[1][0]), f1 = std::min(id[0][1], id[1][1]);\n    // printf(&quot;%d: f0 = %d, f1 = %d\\n&quot;, 1, f0, f1);\n    return std::min(f0, f1);\n&#125;\nint cat(int x) &#123;\n    a[x] = 0;\n    return upd(x);\n&#125;\nint dog(int x) &#123;\n    a[x] = 1;\n    return upd(x);\n&#125;\nint neighbor(int x) &#123;\n    a[x] = -1;\n    return upd(x);\n&#125;\n#ifndef ONLINE_JUDGE\nint main() &#123;\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;int&gt; A(n - 1), B(n - 1);\n    for (int i = 0; i &lt; n - 1; ++i)\n        std::cin &gt;&gt; A[i] &gt;&gt; B[i];\n    initialize(n, A, B);\n    int q;\n    std::cin &gt;&gt; q;\n    for (int op, x; q--; ) &#123;\n        std::cin &gt;&gt; op &gt;&gt; x;\n        std::cout &lt;&lt; (op == 1 ? cat(x) : (op == 2 ? dog(x) : neighbor(x))) &lt;&lt; &#39;\\n&#39;;\n    &#125;\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n    return 0;\n&#125;\n#endif</code></pre>\n</details>\n<hr />\n<h3 id=\"f---hash-on-tree\">F - Hash on Tree</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/AT_abc351_g\" class=\"uri\">https://www.luogu.com.cn/problem/AT_abc351_g</a></p>\n<p>记 <span class=\"math inline\">\\(g_x\\)</span> 为轻儿子的哈希值之积，则 <span class=\"math inline\">\\(f_u=A_u+f_{son}\\cdot g_u\\)</span>。</p>\n<p>然后开一个常数维即可。快速幂的 log 省不掉，所以是双 log 的。</p>\n<p>初值和修改都有可能为 <span class=\"math inline\">\\(0\\)</span>，需要维护实际哈希值和去掉 <span class=\"math inline\">\\(0\\)</span> 的哈希值。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 1e6 + 5;\nconst int LEN = (1 &lt;&lt; 20);\nconst int mod = 998244353;\nint nec(void) &#123;\n    static char buf[LEN], *p = buf, *e = buf;\n    if (p == e) &#123;\n        e = buf + fread(buf, 1, LEN, stdin);\n        if (e == buf) return EOF;\n        p = buf;\n    &#125;\n    return *p++;\n&#125;\nbool read(int &amp;x) &#123;\n    x = 0;\n    bool f = 0;\n    char ch = nec();\n    while (ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123;\n        if (ch == EOF) return 0;\n        if (ch == &#39;-&#39;) f = 1;\n        ch = nec();\n    &#125;\n    while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) &#123;\n        x = x * 10 + ch - &#39;0&#39;;\n        ch = nec();\n    &#125;\n    if (f) x = -x;\n    return 1;\n&#125;\nvoid print(int x) &#123;\n    if (x &lt; 0)\n        putchar(&#39;-&#39;), x = -x;\n    if (x &gt;= 10) print(x / 10);\n    putchar(x % 10 + &#39;0&#39;);\n    return;\n&#125;\nvoid print(int x, char ch) &#123;\n    print(x), putchar(ch);\n    return;\n&#125;\nstruct mat &#123;\n    int n, m;\n    long long a[2][2];\n    long long* operator[] (const int q) &#123;\n        return a[q];\n    &#125;\n    mat operator* (mat &amp;q) const &#123;\n        mat res;\n        res.n = n, res.m = q.m;\n        res[0][0] = res[0][1] = res[1][0] = res[1][1] = 0ll;\n        for (int i = 0; i &lt; n; ++i)\n            for (int k = 0; k &lt; q.m; ++k) &#123;\n                for (int j = 0; j &lt; m; ++j)\n                    res[i][k] += a[i][j] * q[j][k];\n                res[i][k] %= mod;\n            &#125;\n        return res;\n    &#125;\n    mat&amp; operator*= (mat &amp;q) &#123;\n        return *this = *this * q;\n    &#125;\n&#125;;\nstruct &#123; int lc, rc, l, r, mid; mat u; &#125; t[maxn &lt;&lt; 2]; \nlong long g[maxn];\nint tab[maxn], ls[maxn], a[maxn];\n#define lt t[p].lc\n#define rt t[p].rc\nvoid bld(int &amp;p, int l, int r) &#123;\n    static int tot = 0;\n    p = ++tot, t[p].l = l, t[p].r = r;\n    if (l == r) &#123;\n        int u = tab[l];\n        t[p].u.n = t[p].u.m = 2;\n        t[p].u[0][0] = g[u];\n        t[p].u[0][1] = 0ll;\n        t[p].u[1][0] = a[u];\n        t[p].u[1][1] = 1ll;\n        return;\n    &#125;\n    int s = 0, u = ls[tab[l]];\n    for (int i = l; i &lt;= r; ++i)\n        s += ls[tab[i]];\n    s &gt;&gt;= 1;\n    t[p].mid = r - 1;\n    for (int i = l + 1; i &lt; r; ++i) &#123;\n        u += ls[tab[i]];\n        if (u + ls[tab[i + 1]] &gt; s) &#123;\n            t[p].mid = i;\n            break;\n        &#125;\n    &#125;\n    bld(lt, l, t[p].mid), bld(rt, t[p].mid + 1, r);\n    t[p].u = t[rt].u * t[lt].u;\n    return;\n&#125;\nvoid add(int p, int x) &#123;\n    if (t[p].l == t[p].r) &#123;\n        int u = tab[x];\n        t[p].u[0][0] = g[u];\n        t[p].u[1][0] = a[u];\n        return;\n    &#125;\n    if (x &lt;= t[p].mid)\n        add(lt, x);\n    else\n        add(rt, x);\n    t[p].u = t[rt].u * t[lt].u;\n    return;\n&#125;\n#undef lt\n#undef rt\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, q;\n    read(n), read(q);\n    std::vector&lt;int&gt; rt(n + 1);\n    std::vector&lt;std::vector&lt;int&gt; &gt; g1(n + 1);\n    for (int i = 2, x; i &lt;= n; ++i) &#123;\n        read(x);\n        g1[i].push_back(x), g1[x].push_back(i);\n    &#125;\n    for (int i = 1; i &lt;= n; ++i)\n        read(a[i]);\n    std::vector&lt;int&gt; siz(n + 1), son(n + 1), fa(n + 1);\n    std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;\n        siz[x] = 1;\n        for (auto i : g1[x])\n            if (i != fa[x]) &#123;\n                fa[i] = x, DFS(i);\n                siz[x] += siz[i];\n                if (siz[i] &gt; siz[son[x]])\n                    son[x] = i;\n            &#125;\n        return;\n    &#125;;\n    DFS(1);\n    std::vector&lt;long long&gt; f(n + 1);\n    std::vector&lt;int&gt; top(n + 1), bot(n + 1), dfn(n + 1), la(n + 1), cnt(n + 1);\n    DFS = [&amp;](int x) &#123;\n        static int now = 0;\n        dfn[x] = ++now, tab[now] = x, ls[x] = 1;\n        if (son[x]) &#123;\n            top[son[x]] = top[x], DFS(son[x]);\n            bot[x] = bot[son[x]];\n            g[x] = 1ll;\n            for (auto i : g1[x])\n                if (i != son[x] &amp;&amp; i != fa[x]) &#123;\n                    top[i] = i, DFS(i);\n                    ls[x] += siz[i];\n                    if (f[i] == 0ll)\n                        ++cnt[x];\n                    else\n                        (la[x] *= f[i]) %= mod;\n                    (g[x] *= f[i]) %= mod;\n                &#125;\n            f[x] = (a[x] + g[x] * f[son[x]]) % mod;\n        &#125;\n        else\n            f[x] = a[x], bot[x] = x;\n        // printf(&quot;f[%d] = %lld\\n&quot;, x, f[x]);\n        if (x == top[x])\n            bld(rt[x], dfn[x], dfn[bot[x]]);\n        return;\n    &#125;;\n    top[1] = 1, DFS(1);\n    mat init;\n    init.n = 1, init.m = 2;\n    init[0][0] = 0ll, init[0][1] = 1ll;\n    auto qkp = [&amp;](long long x, int y) &#123;\n        auto res(1ll);\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    auto inv = [&amp;](int x) &#123;\n        return qkp(x, mod - 2);\n    &#125;;\n    for (int x, v; q--; ) &#123;\n        read(x), read(v);\n        a[x] = v;\n        for (; top[x] != 1; ) &#123;\n            int faa = fa[top[x]];\n            auto &amp;id = t[rt[top[x]]].u;\n            int f = (init * id)[0][0];\n            if (f == 0) &#123;\n                if (--cnt[faa] == 0)\n                    g[faa] = la[faa];\n            &#125;\n            else &#123;\n                f = inv(f);\n                (g[faa] *= f) %= mod;\n                (la[faa] *= f) %= mod;\n            &#125;\n            add(rt[top[x]], dfn[x]);\n            f = (init * id)[0][0];\n            if (f == 0) &#123;\n                if (cnt[faa]++ == 0)\n                    la[faa] = g[faa];\n                g[faa] = 0ll;\n            &#125;\n            else &#123;\n                (g[faa] *= f) %= mod;\n                (la[faa] *= f) %= mod;\n            &#125;\n            x = faa;\n        &#125;\n        add(rt[1], dfn[x]);\n        auto &amp;id = t[rt[1]].u;\n        int f = (init * id)[0][0];\n        std::cout &lt;&lt; f &lt;&lt; &#39;\\n&#39;;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"g---考试-2\">G - 考试 2</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P10626\" class=\"uri\">https://www.luogu.com.cn/problem/P10626</a></p>\n<p>运算均是线性的，容易想到『按位』维护，即只维护某个特定点值。如果将询问离线下来排序，每个函数的点值只会变化 <span class=\"math inline\">\\(O(1)\\)</span> 次。</p>\n<p>建出符号二叉树，进行 DDP 即可。具体地，令 <span class=\"math inline\">\\(f_u\\)</span> 表示在运算 <span class=\"math inline\">\\(u\\)</span> 处的答案，计算 <span class=\"math inline\">\\(g_u\\)</span> 为轻儿子的答案，按照 <span class=\"math inline\">\\(u\\)</span> 处的符号写矩阵即可。叶子不是一次运算，应该直接填入点值（注意线段树上的叶子不一定是原树上的叶子）。</p>\n<p>建树和矩阵更新有点史，适当封装一下感觉会好一点</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 1e6 + 5;\nconst char mp[] = &quot;x!&amp;|^&quot;;\nconst int LEN = (1 &lt;&lt; 20);\n#define nec getchar\ninline bool read(int &amp;x) &#123;\n    x = 0;\n    bool f = 0;\n    char ch = nec();\n    while (ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123;\n        if (ch == EOF) return 0;\n        if (ch == &#39;-&#39;) f = 1;\n        ch = nec();\n    &#125;\n    while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) &#123;\n        x = x * 10 + ch - &#39;0&#39;;\n        ch = nec();\n    &#125;\n    if (f) x = -x;\n    return 1;\n&#125;\nvoid print(int x) &#123;\n    if (x &lt; 0)\n        putchar(&#39;-&#39;), x = -x;\n    if (x &gt;= 10) print(x / 10);\n    putchar(x % 10 + &#39;0&#39;);\n    return;\n&#125;\nvoid print(int x, char ch) &#123;\n    print(x), putchar(ch);\n    return;\n&#125;\nstruct mat &#123;\n    int n, m;\n    int a[2][2];\n    int* operator[] (const int q) &#123;\n        return a[q];\n    &#125;\n    inline mat operator* (mat &amp;q) const &#123;\n        mat res;\n        res.n = n, res.m = q.m;\n        res[0][0] = res[0][1] = res[1][0] = res[1][1] = 0ll;\n        for (int i = 0; i &lt; n; ++i)\n            for (int k = 0; k &lt; q.m; ++k)\n                for (int j = 0; j &lt; m; ++j)\n                    res[i][k] += a[i][j] * q[j][k];\n        return res;\n    &#125;\n    mat&amp; operator*= (mat &amp;q) &#123;\n        return *this = *this * q;\n    &#125;\n&#125;;\nstruct &#123; int lc, rc, l, r, mid; mat u; &#125; t[maxn &lt;&lt; 2]; \nint g1[maxn][2];\nint g[maxn], ty[maxn];\nint tab[maxn], ls[maxn], lim[maxn];\n#define lt t[p].lc\n#define rt t[p].rc\nvoid fillmat(mat &amp;a, int op, int g) &#123;\n    if (op == 0) &#123;\n        a.n = 1, a.m = 2;\n        a[0][!g] = 0, a[0][g] = 1;\n        return;\n    &#125;\n    a.n = 2, a.m = 2;\n    switch (op) &#123;\n    case 1: // !\n        a[0][0] = 0, a[0][1] = 1;\n        a[1][0] = 1, a[1][1] = 0;\n        break;\n    case 2: // &amp;\n        a[0][0] = 1, a[0][1] = 0;\n        a[1][0] = !g, a[1][1] = g;\n        break;\n    case 3: // |\n        a[0][0] = !g, a[0][1] = g;\n        a[1][0] = 0, a[1][1] = 1;\n        break;\n    case 4: // ^\n        a[0][0] = !g, a[0][1] = g;\n        a[1][0] = g, a[1][1] = !g;\n        break;\n    default:\n        assert(0);\n    &#125;\n    return;\n&#125;\nvoid bld(int &amp;p, int l, int r) &#123;\n    static int tot = 0;\n    p = ++tot, t[p].l = l, t[p].r = r;\n    if (l == r) &#123;\n        fillmat(t[p].u, ty[tab[l]], g[tab[l]]);\n        return;\n    &#125;\n    int s = 0, u = ls[tab[l]];\n    for (int i = l; i &lt;= r; ++i)\n        s += ls[tab[i]];\n    s &gt;&gt;= 1;\n    t[p].mid = r - 1;\n    for (int i = l + 1; i &lt; r; ++i) &#123;\n        u += ls[tab[i]];\n        if (u + ls[tab[i + 1]] &gt; s) &#123;\n            t[p].mid = i;\n            break;\n        &#125;\n    &#125;\n    bld(lt, l, t[p].mid), bld(rt, t[p].mid + 1, r);\n    t[p].u = t[rt].u * t[lt].u;\n    return;\n&#125;\nvoid add(int p, int x) &#123;\n    if (t[p].l == t[p].r) &#123;\n        fillmat(t[p].u, ty[tab[t[p].l]], g[tab[t[p].l]]);\n        return;\n    &#125;\n    if (x &lt;= t[p].mid)\n        add(lt, x);\n    else\n        add(rt, x);\n    t[p].u = t[rt].u * t[lt].u;\n    return;\n&#125;\n#undef lt\n#undef rt\nint main() &#123;\n#ifndef ONLINE_JUDGE\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n = 0, q, p;\n    read(q), read(q);\n    &#123;\n        std::string s;\n        std::cin &gt;&gt; s;\n        std::stringstream in(s);\n        std::stack&lt;char&gt; op;\n        std::stack&lt;int&gt; id;\n        auto trans = [&amp;](char t) &#123;\n            switch (t) &#123;\n            case &#39;!&#39;:\n                return 1;\n            case &#39;&amp;&#39;:\n                return 2;\n            case &#39;|&#39;:\n                return 3;\n            case &#39;^&#39;:\n                return 4;\n            &#125;\n            assert(0);\n            return -1;\n        &#125;;\n        auto calcNot = [&amp;](void) &#123;\n            for (; !op.empty() &amp;&amp; op.top() == &#39;!&#39;; ) &#123;\n                ty[++n] = trans(op.top());\n                g1[n][0] = id.top(), id.pop(), id.push(n);\n                op.pop();\n            &#125;\n            return;\n        &#125;;\n        auto opt = [&amp;](void) &#123;\n            ty[++n] = trans(op.top());\n            g1[n][0] = id.top(), id.pop();\n            g1[n][1] = id.top(), id.pop();\n            id.push(n), op.pop();\n            return;\n        &#125;;\n        for (char t; in &gt;&gt; t; )\n            if (t == &#39;[&#39;) &#123;\n                int x;\n                in &gt;&gt; x, in &gt;&gt; t;\n                lim[++n] = x - 1;\n                id.push(n), calcNot();\n            &#125;\n            else if (t == &#39;(&#39;)\n                op.push(t);\n            else if (t == &#39;)&#39;) &#123;\n                for (; op.top() != &#39;(&#39;; opt());\n                op.pop(), calcNot();\n            &#125;\n            else if (t == &#39;&amp;&#39;)\n                op.push(t);\n            else if (t == &#39;^&#39;) &#123;\n                for (; !op.empty() &amp;&amp; op.top() == &#39;&amp;&#39;; opt());\n                op.push(t);\n            &#125;\n            else if (t == &#39;|&#39;) &#123;\n                for (; !op.empty() &amp;&amp; (op.top() == &#39;&amp;&#39; || op.top() == &#39;^&#39;); opt());\n                op.push(t);\n            &#125;\n            else &#123;\n                assert(t == &#39;!&#39;);\n                op.push(t);\n            &#125;\n        for (; !op.empty(); opt());\n        p = id.top();\n    &#125;\n    std::vector&lt;int&gt; rt(n + 1);\n    std::vector&lt;int&gt; siz(n + 1), son(n + 1), fa(n + 1);\n    std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;\n        siz[x] = 1;\n        for (auto i : g1[x])\n            if (i != 0) &#123;\n                fa[i] = x, DFS(i);\n                siz[x] += siz[i];\n                if (siz[i] &gt; siz[son[x]])\n                    son[x] = i;\n            &#125;\n        return;\n    &#125;;\n    DFS(p);\n    std::vector&lt;long long&gt; f(n + 1);\n    std::vector&lt;int&gt; top(n + 1), bot(n + 1), dfn(n + 1);\n    DFS = [&amp;](int x) &#123;\n        static int now = 0;\n        dfn[x] = ++now, tab[now] = x, ls[x] = 1;\n        if (son[x]) &#123;\n            top[son[x]] = top[x], DFS(son[x]);\n            bot[x] = bot[son[x]];\n            for (auto i : g1[x])\n                if (i != son[x] &amp;&amp; i != 0) &#123;\n                    top[i] = i, DFS(i);\n                    ls[x] += siz[i], g[x] = f[i];\n                &#125;\n            switch (ty[x]) &#123;\n            case 1:\n                f[x] = !f[son[x]];\n                break;\n            case 2:\n                f[x] = g[x] &amp; f[son[x]];\n                break;\n            case 3:\n                f[x] = g[x] | f[son[x]];\n                break;\n            case 4:\n                f[x] = g[x] ^ f[son[x]];\n                break;\n            default:\n                assert(0);\n                break;\n            &#125;\n        &#125;\n        else\n            assert(!ty[x]), f[x] = g[x] = 0, bot[x] = x;\n        if (x == top[x])\n            bld(rt[x], dfn[x], dfn[bot[x]]);\n        return;\n    &#125;;\n    top[p] = p, DFS(p);\n    std::vector&lt;int&gt; a(q + 1), res(q + 1);\n    for (int i = 1; i &lt;= q; ++i)\n        read(a[i]);\n    std::vector&lt;int&gt; qid(q), nid;\n    for (int i = 1; i &lt;= n; ++i)\n        if (ty[i] == 0)\n            nid.push_back(i);\n    std::iota(qid.begin(), qid.end(), 1);\n    std::sort(qid.begin(), qid.end(), [&amp;](int x, int y) &#123; return a[x] &lt; a[y]; &#125;);\n    std::sort(nid.begin(), nid.end(), [&amp;](int x, int y) &#123; return lim[x] &gt; lim[y]; &#125;);\n    for (auto i : qid) &#123;\n        for (; !nid.empty() &amp;&amp; lim[nid.back()] &lt; a[i]; ) &#123;\n            int x = nid.back();\n            nid.pop_back();\n            g[x] = 1;\n            for (; top[x] != p; ) &#123;\n                add(rt[top[x]], dfn[x]);\n                g[fa[top[x]]] = t[rt[top[x]]].u[0][1];\n                x = fa[top[x]];\n            &#125;\n            add(rt[p], dfn[x]);\n        &#125;\n        res[i] = t[rt[p]].u[0][1];\n    &#125;\n    for (int i = 1; i &lt;= q; ++i)\n        if (res[i])\n            std::cout &lt;&lt; &quot;True\\n&quot;;\n        else\n            std::cout &lt;&lt; &quot;False\\n&quot;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n",
            "tags": [
                "线段树",
                "DDP"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20250524/",
            "url": "https://xsc062.netlify.app/20250524/",
            "title": "周考",
            "date_published": "2025-05-24T06:29:44.000Z",
            "content_html": "<p>并非周考。</p>\n<span id=\"more\"></span>\n<hr />\n<h2 id=\"b---carousel-of-combinations\">B - Carousel of Combinations</h2>\n<p><a href=\"https://codeforces.com/problemset/problem/1957/E\" class=\"uri\">https://codeforces.com/problemset/problem/1957/E</a></p>\n<blockquote>\n<p><span class=\"math inline\">\\(q\\)</span> 次询问，每次给定一个 <span class=\"math inline\">\\(n\\)</span>，求：</p>\n<p><span class=\"math display\">\\[\n\\left(\\sum\\limits_{i=1}^n\\sum\\limits_{j=1}^i \\dfrac {i!}{(i-j)!\\cdot j!}\\bmod j\\right) \\bmod 10^9+7\n\\]</span></p>\n<p><span class=\"math inline\">\\(n,q\\le 10^6\\)</span>。</p>\n</blockquote>\n<p>赛时打表 <span class=\"math inline\">\\(\\dfrac {i!}{(i-j)!\\cdot j!}\\bmod j\\)</span> 易发现只有 <span class=\"math inline\">\\(j=4\\)</span> 或 <span class=\"math inline\">\\(j\\)</span> 为质数的列上有值；且仅当 <span class=\"math inline\">\\(\\left\\lfloor \\dfrac ij\\right\\rfloor\\)</span> 发生变化时，<span class=\"math inline\">\\((i,j)\\)</span> 的值不同。</p>\n<p>于是乎埃筛找每个 <span class=\"math inline\">\\(j\\)</span> 的倍数，由于每个值会持续一段 <span class=\"math inline\">\\(i\\)</span> 上的区间，考虑维护差分数组。前缀和得到原数组，再前缀和就能得到答案。</p>\n<details>\n<p><summary>证明</summary></p>\n<p>考虑转化为组合数形式方便证明。当 <span class=\"math inline\">\\(j\\)</span> 为质数时：</p>\n<p><span class=\"math display\">\\[\n\\begin{aligned}\n\\dfrac {i!}{(i-j)!\\cdot j!}\\bmod j\n&amp;=C_i^j\\cdot (j-1)!\\bmod j\\\\\n&amp;=C_{i\\bmod j}^{j\\bmod j}\\cdot C_{\\lfloor \\frac ij\\rfloor}^{\\frac jj}\\cdot (j-1)!\\bmod j\\\\\n&amp;=\\left\\lfloor \\frac ij\\right\\rfloor\\cdot (j-1)!\\bmod j\\\\\n&amp;=\\left\\lfloor \\frac ij\\right\\rfloor\\cdot (j-1)\\bmod j\n\\end{aligned}\n\\]</span></p>\n<p>当 <span class=\"math inline\">\\(j\\)</span> 为合数时：</p>\n<p><span class=\"math display\">\\[\n\\dfrac {i!}{(i-j)!\\cdot j!}\\bmod j=\\left\\lfloor \\frac ij\\right\\rfloor\\cdot (j-1)!\\bmod j\n\\]</span></p>\n<ul>\n<li><p>当 <span class=\"math inline\">\\(j=p^2\\)</span>，其中 <span class=\"math inline\">\\(p\\)</span> 为质数时：</p>\n<ul>\n<li>当 <span class=\"math inline\">\\(j\\ne 4\\)</span> 时，<span class=\"math inline\">\\(\\dfrac jp \\ge 3\\)</span>，代表在 <span class=\"math inline\">\\(1\\sim j-1\\)</span> 中至少出现了两个 <span class=\"math inline\">\\(p\\)</span> 的倍数，即 <span class=\"math inline\">\\((j-1)\\bmod j = 0\\)</span>。</li>\n<li>否则，原式转化为 <span class=\"math inline\">\\(2\\cdot \\left\\lfloor \\frac i4\\right\\rfloor\\bmod 4\\)</span>。</li>\n</ul></li>\n<li><p>否则：可以找到至少一组 <span class=\"math inline\">\\(j=i\\cdot k\\)</span> 满足 <span class=\"math inline\">\\(i\\ne k\\)</span>，则 <span class=\"math inline\">\\(i,k\\)</span> 出现在 <span class=\"math inline\">\\(1\\sim j-1\\)</span> 中，即 <span class=\"math inline\">\\((j-1)\\bmod j = 0\\)</span>。</p></li>\n</ul>\n<p>得到上述结论。</p>\n<p>Tips：</p>\n<ul>\n<li>卢卡斯定理：懒得写了。</li>\n<li>威尔逊定理：对于质数 <span class=\"math inline\">\\(p\\)</span>，<span class=\"math inline\">\\((p-1)!\\equiv -1\\pmod p\\)</span>。</li>\n</ul>\n</details>\n<hr />\n<h2 id=\"c---玻利维亚-bolivija\">C - 玻利维亚 / Bolivija</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P12401\" class=\"uri\">https://www.luogu.com.cn/problem/P12401</a></p>\n<blockquote>\n<p>给定若干次区间的插入与删除操作，对于所有值域内未被覆盖极长段 <span class=\"math inline\">\\(i\\)</span>，令 <span class=\"math inline\">\\(len_i\\)</span> 为其长度；每次操作后询问 <span class=\"math inline\">\\(\\sum \\frac {len_i\\cdot (len_i-1)}2+len_i\\)</span>。</p>\n</blockquote>\n<p>来一点新奇的思路。假如你和我一样，很不幸地不知道维护最小值这个 trick，怎么解决这道题？</p>\n<p>容易想到线段树维护节点内贡献和左侧、右侧极长未覆盖长度。加入区间是简单的：对于线段树上被完全覆盖的节点，更新其贡献为 <span class=\"math inline\">\\(0\\)</span>。依次 <code>pushup</code> 即可。</p>\n<p>删除区间，对于被这段区间完全覆盖的节点，发现如果整体被覆盖次数减少 <span class=\"math inline\">\\(1\\)</span>，有可能出现新的、未被覆盖的点，如果暴力 check 左右儿子是否出现了这样的点并更新，复杂度就不太美观了。</p>\n<p>故而对于一个节点，<strong>将『完全覆盖它的区间』和『部分覆盖它的区间』分开考虑</strong>，在维护该节点所有实时信息（记为 <span class=\"math inline\">\\(s\\)</span>）的同时，<strong>维护另一份只考虑了『部分覆盖它地区间』的信息（记为 <span class=\"math inline\">\\(s&#39;\\)</span>）</strong>：</p>\n<ul>\n<li><p>如果一个『部分覆盖它的区间』被删除：</p>\n<ul>\n<li>如果存在『完全覆盖它的区间』：<span class=\"math inline\">\\(s\\)</span> 不变；向下修改儿子的 <span class=\"math inline\">\\(s\\)</span>，<span class=\"math inline\">\\(s&#39;\\)</span> 需要从儿子的 <span class=\"math inline\">\\(s\\)</span> 更新。</li>\n</ul></li>\n<li><p>如果一个『完全覆盖它的区间』被删除：</p>\n<ul>\n<li>如果还存在其他『完全覆盖它的区间』：<span class=\"math inline\">\\(s,s&#39;\\)</span> 都不变。</li>\n<li>如果不存在其他『完全覆盖它的区间』：用 <span class=\"math inline\">\\(s&#39;\\)</span> 更新 <span class=\"math inline\">\\(s\\)</span>。</li>\n</ul></li>\n</ul>\n<p>这样就能 <span class=\"math inline\">\\(O(q\\log V)\\)</span> 解决上述问题。本方法较维护最小值的优势在于——似乎没有。想了许多种情况，它们大抵是等价的——且本方法更难写（哭）。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 654205;\nstruct &#123;\n    int cnt;\n    long long u, s;\n    int l, r, lu, ru, ls, rs;\n&#125; t[maxn &lt;&lt; 2];\n#define lt (p &lt;&lt; 1)\n#define rt (lt | 1)\n#define len(p) (t[p].r - t[p].l + 1)\nvoid pushup(int p) &#123;\n    t[p].s = t[lt].u + t[rt].u + (long long)t[lt].ru * t[rt].lu;\n    if (t[lt].lu == len(lt))\n        t[p].ls = len(lt) + t[rt].lu;\n    else\n        t[p].ls = t[lt].lu;\n    if (t[rt].ru == len(rt))\n        t[p].rs = t[lt].ru + len(rt);\n    else\n        t[p].rs = t[rt].ru;\n    if (!t[p].cnt)\n        t[p].u = t[p].s, t[p].lu = t[p].ls, t[p].ru = t[p].rs;\n    return;\n&#125;\nvoid bld(int p, int l, int r) &#123;\n    t[p].l = l, t[p].r = r;\n    if (l == r) &#123;\n        t[p].u = t[p].s = 1ll;\n        t[p].lu = t[p].ru = t[p].ls = t[p].rs = 1;\n        return;\n    &#125;\n    int mid = (l + r) &gt;&gt; 1;\n    bld(lt, l, mid), bld(rt, mid + 1, r);\n    pushup(p);\n    return;\n&#125;\nvoid add(int p, int l, int r) &#123;\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r) &#123;\n        ++t[p].cnt, t[p].u = 0ll, t[p].lu = t[p].ru = 0;\n        return;\n    &#125;\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (l &lt;= mid)\n        add(lt, l, r);\n    if (r &gt; mid)\n        add(rt, l, r);\n    pushup(p);\n    return;\n&#125;\nvoid rem(int p, int l, int r) &#123;\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r) &#123;\n        if (!--t[p].cnt)\n            t[p].u = t[p].s, t[p].lu = t[p].ls, t[p].ru = t[p].rs;\n        return;\n    &#125;\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (l &lt;= mid)\n        rem(lt, l, r);\n    if (r &gt; mid)\n        rem(rt, l, r);\n    pushup(p);\n    return;\n&#125;\nint main() &#123;\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n    int n, q;\n    std::cin &gt;&gt; n &gt;&gt; q;\n    std::vector&lt;int&gt; a(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i];\n    int u = (n + 1) / 2;\n    const int N = a[u];\n    bld(1, 1, N);\n    for (int i = 1; i &lt; u; ++i)\n        if (a[i] != a[n - i + 1])\n            add(1, std::min(a[i], a[n - i + 1]) + 1, std::max(a[i], a[n - i + 1]));\n    std::cout &lt;&lt; t[1].u &lt;&lt; &#39;\\n&#39;;\n    for (int i, v; q--; ) &#123;\n        std::cin &gt;&gt; i &gt;&gt; v;\n        if (a[i] != a[n - i + 1])\n            rem(1, std::min(a[i], a[n - i + 1]) + 1, std::max(a[i], a[n - i + 1]));\n        a[i] = v;\n        if (a[i] != a[n - i + 1])\n            add(1, std::min(a[i], a[n - i + 1]) + 1, std::max(a[i], a[n - i + 1]));\n        std::cout &lt;&lt; t[1].u &lt;&lt; &#39;\\n&#39;;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"d---移动金币\">D - 移动金币</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P5363\" class=\"uri\">https://www.luogu.com.cn/problem/P5363</a></p>\n<p>最后一个棋子的移动等价于丢掉最后一部分空格；中间棋子的移动等价于把左边间隔里的一段空格拿到右边的间隔里。发现原问题转化为『阶梯 Nim 博弈』。</p>\n<details>\n<p><summary>关于阶梯 Nim 博弈…</summary></p>\n<blockquote>\n<p>给定 <span class=\"math inline\">\\(n\\)</span> 层石头，每次行动可以选择以下操作中的一种：</p>\n<ol type=\"1\">\n<li>选择 <span class=\"math inline\">\\(2\\le i\\le n\\)</span>，从第 <span class=\"math inline\">\\(i\\)</span> 层石头中拿走若干颗，全部放到第 <span class=\"math inline\">\\(i-1\\)</span> 层里。</li>\n<li>从第 <span class=\"math inline\">\\(1\\)</span> 层石头中拿走若干颗，全部丢弃。</li>\n</ol>\n<p>不能行动者输。</p>\n</blockquote>\n<p>本问题可以等效为 Nim 游戏：</p>\n<p>对于第偶数层，若 Alice 选择从第 <span class=\"math inline\">\\(2i\\)</span> 层中移动 <span class=\"math inline\">\\(x\\)</span> 个石头到 <span class=\"math inline\">\\(2i-1\\)</span>，Bob 可以立即从 <span class=\"math inline\">\\(2i-1\\)</span> 层中将这 <span class=\"math inline\">\\(x\\)</span> 个石头移动到 <span class=\"math inline\">\\(2i-2\\)</span>（或丢弃）。</p>\n<p>也就是说，Alice 在偶数层中的操作不会对 Bob 带来任何限制。偶数层的石头可以被视作不存在；从奇数层移动到偶数层的石头可以被视为丢弃；进而，奇数堆中的移动等效为『丢弃』，将原问题中所有奇数堆抽离出来，等效成普通的 Nim 游戏。</p>\n</details>\n<p>问题转化成，将 <span class=\"math inline\">\\(n-m\\)</span> 个元素放到编号 <span class=\"math inline\">\\(0\\sim m+1\\)</span> 的盒子里，满足奇数号盒子球个数异或和为 <span class=\"math inline\">\\(0\\)</span> 的方案数。小容斥一下，用总数减去异或和为 <span class=\"math inline\">\\(0\\)</span> 者。</p>\n",
            "tags": [
                "线段树",
                "博弈论"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20250217/",
            "url": "https://xsc062.netlify.app/20250217/",
            "title": "线段树维护前缀最值序列信息",
            "date_published": "2025-02-17T11:09:57.000Z",
            "content_html": "<p>人类不应该使用 <code>std::vector</code> 实现线段树的 2 个原因：</p>\n<span id=\"more\"></span>\n<ol type=\"1\">\n<li>当你的参数包含引用时，扩容操作，包括显式的 <code>resize()</code> 和隐式的 <code>push_back()</code> 均会导致引用失效。</li>\n<li>当你的左值为引用时，由于 <code>=</code> 左右计算顺序是不确定的（C++14），由于 1 中所述原因，引用可能失效。</li>\n<li><code>terminate called after throwing an instance of 'std::bad_alloc' what():  std::bad_alloc</code></li>\n</ol>\n<p>笑点解析：首先通过「……的 2 个原因」暗示声明一个长度为 2 的 <code>vector</code>，接着在试图访问第 3 个元素时抛出错误。</p>\n<p>什么？你说我的下标是从 1 开始的？恭喜你发现了 <code>vector</code> 的第 0 个笑点。</p>\n<hr />\n<h2 id=\"楼房重建\">楼房重建</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P4198\" class=\"uri\">https://www.luogu.com.cn/problem/P4198</a></p>\n<p>考虑用线段树解决问题。难点在于如何合并两个区间的信息——直觉地，大区间的信息一定与两个子区间有关。</p>\n<p>考虑理想的情况：我们现在知道左右两边区间的答案序列。显然我们需要保留左边整段区间，对于左区间序列末的元素 <span class=\"math inline\">\\(rv_l\\)</span>，我们在右区间内找到第一个大于之的元素 <span class=\"math inline\">\\(x\\)</span>，从它开始的序列就是答案。</p>\n<p>反证法易得 <span class=\"math inline\">\\(x\\)</span> 一定在右区间答案序列内：若 <span class=\"math inline\">\\(x\\)</span> 不在答案序列内，则右区间内存在一个 <span class=\"math inline\">\\(&gt;x\\)</span> 且位于 <span class=\"math inline\">\\(x\\)</span> 之前的元素，那么 <span class=\"math inline\">\\(x\\)</span> 就不是第一个 <span class=\"math inline\">\\(&gt;rv_l\\)</span> 的元素，矛盾。</p>\n<p>那么现在对于左右序列未知的情况，我们取左区间的答案，再在右区间中单 <span class=\"math inline\">\\(\\log\\)</span> 查找能够接上去的区间长度，加起来即可。</p>\n<p>题目只要求总区间答案，故不需要查询。动态开点可能需要小心处理一下。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 1e5 + 5;\nstruct &#123;\n    int l, r, u;\n    double lv, rv, mv;\n&#125; t[maxn &lt;&lt; 2];\nint tot;\n#define lt t[p].l\n#define rt t[p].r\nint askt(int p, int l, int r, double v) &#123;\n    if (l == r)\n        return t[p].u;\n    int mid = (l + r) &gt;&gt; 1;\n    if (lt &amp;&amp; t[p].mv &gt; v)\n        return t[p].u - t[lt].u + askt(lt, l, mid, v);\n    return askt(rt, mid + 1, r, v);\n&#125;\nvoid pushup(int p, int l, int r) &#123;\n    t[p].mv = t[lt].rv;\n    if (lt &amp;&amp; rt) &#123;\n        t[p].lv = t[lt].lv;\n        t[p].rv = std::max(t[lt].rv, t[rt].rv);\n        if (t[lt].rv &lt; t[rt].lv)\n            t[p].u = t[lt].u + t[rt].u;\n        else if (t[lt].rv &gt;= t[rt].rv)\n            t[p].u = t[lt].u;\n        else &#123;\n            int mid = (l + r) &gt;&gt; 1;\n            t[p].u = t[lt].u + askt(rt, mid + 1, r, t[lt].rv);\n        &#125;\n    &#125;\n    else &#123;\n        t[p].u = t[lt + rt].u;\n        t[p].lv = t[lt + rt].lv, t[p].rv = t[lt + rt].rv;\n    &#125;\n    return;\n&#125;\nvoid upd(int &amp;p, int l, int r, int x, double v) &#123;\n    if (!p)\n        p = ++tot;\n    if (l == r) &#123;\n        t[p].lv = t[p].rv = v, t[p].u = 1;\n        return;\n    &#125;\n    int mid = (l + r) &gt;&gt; 1;\n    if (x &lt;= mid)\n        upd(lt, l, mid, x, v);\n    else\n        upd(rt, mid + 1, r, x, v);\n    pushup(p, l, r);\n    return;\n&#125;\n#undef lt\n#undef rt\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;P4198_2.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, m, rt = 0;\n    std::cin &gt;&gt; n &gt;&gt; m;\n    std::vector&lt;double&gt; a(n + 1);\n    for (int x; m--; ) &#123;\n        double y;\n        std::cin &gt;&gt; x &gt;&gt; y;\n        a[x] = y / x;\n        upd(rt, 1, n, x, y / x);\n        std::cout &lt;&lt; t[1].u &lt;&lt; &#39;\\n&#39;;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n",
            "tags": [
                "线段树"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20250216/",
            "url": "https://xsc062.netlify.app/20250216/",
            "title": "Public Round 15 前两题",
            "date_published": "2025-02-16T11:44:38.000Z",
            "content_html": "<p><a href=\"https://pjudge.ac/contest/1914\">PR #15</a> 前两题题解。</p>\n<span id=\"more\"></span>\n<hr />\n<h2 id=\"最小表示法\">最小表示法</h2>\n<p><a href=\"https://pjudge.ac/contest/1914/problem/21888\" class=\"uri\">https://pjudge.ac/contest/1914/problem/21888</a></p>\n<p>首先不妨假设每个 <span class=\"math inline\">\\(f\\)</span> 在值域内等概率取值以简化问题。那么手玩一下可以轻松地得到规律：不妨将 <span class=\"math inline\">\\(\\{s\\}\\)</span> 循环右移一位的结果记为 <span class=\"math inline\">\\(\\{t\\}\\)</span>，那么 <span class=\"math inline\">\\(res=\\sum\\frac 1{\\max(|s_i|,|t_i|)}\\)</span>。</p>\n<p>这看起来令人疑惑：对于不同的 <span class=\"math inline\">\\(i\\)</span>，<span class=\"math inline\">\\([f(s_i)=f(t_i)]\\)</span> 的期望似乎是彼此独立的，十分奇怪。这其实与表达式的来源有关，记 <span class=\"math inline\">\\(g(s_i, j)\\)</span> 表示 <span class=\"math inline\">\\(f(s_i)=j\\)</span> 的概率，那么上述等式可以转写为 <span class=\"math inline\">\\(res=\\sum\\limits_i\\sum\\limits_jg({s_i},j)\\times g(t_i,j)\\)</span>。</p>\n<p>那么将最小表示法带来的偏差纳入考虑范围，我们发现 <span class=\"math inline\">\\(g(s,j)\\)</span> 对于不同的 <span class=\"math inline\">\\(j\\)</span> 并不永远相等。具体地，当 <span class=\"math inline\">\\(s\\)</span> 具有循环节时，最小循环节的第一处结尾会享有更大的取得概率。</p>\n<p>枚举 <span class=\"math inline\">\\(s_i\\)</span> 的因数作为最小循环节长度的情况，显然，对于最小循环节为 <span class=\"math inline\">\\(j\\)</span> 的情况（该情况出现的概率，容斥得到 <span class=\"math inline\">\\(p_j=26^j-\\sum_{k\\mid j}p_k\\)</span>），<span class=\"math inline\">\\(f(s_i)\\)</span> 的取值在 <span class=\"math inline\">\\(1\\sim j\\)</span> 上等概率分布，差分即可统计每个值在不同循环节长度下被取到的概率和。</p>\n<p>用埃筛解决每个数的因数和 <span class=\"math inline\">\\(p\\)</span> 值，那么此时复杂度瓶颈在于 <span class=\"math inline\">\\(g(s_i, j)\\)</span> 和 <span class=\"math inline\">\\(\\sum\\limits_i\\sum\\limits_jg({s_i},j)\\times g(t_i,j)\\)</span> 的求解。容易发现只有每个 <span class=\"math inline\">\\(g(s_i,j),j\\mid |s_i|\\)</span> 的值是有效的（其他的和它们值都相同），考虑只求解和利用这些值，类 <code>std::merge</code>（即归并排序）地求解答案。</p>\n<p>注意特判 <span class=\"math inline\">\\(n=1\\)</span>。会得到错误答案的原因是此时存在 <span class=\"math inline\">\\(s_i=t_i\\)</span>，不满足基本要求。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int lim = 1e5;\nconst int mod = 998244353;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    if (n == 1) &#123;\n        std::cout &lt;&lt; 1 &lt;&lt; &#39;\\n&#39;;\n        return 0;\n    &#125;\n    auto qkp = [](long long x, int y) &#123;\n        long long res = 1ll;\n        for (; y; y &gt;&gt;= 1, (x *= x) %= mod)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    auto inv = [&amp;](int x) &#123;\n        return qkp(x, mod - 2);\n    &#125;;\n    std::vector&lt;long long&gt; f(lim + 1);\n    std::vector&lt;std::vector&lt;int&gt; &gt; fac(lim + 1);\n    for (int i = 1; i &lt;= lim; ++i) &#123;\n        static long long now = 26;\n        (f[i] += now) %= mod;\n        fac[i].push_back(i);\n        for (int j = 2 * i; j &lt;= lim; j += i)\n            (f[j] += mod - f[i]) %= mod, fac[j].push_back(i);\n        (now *= 26) %= mod;\n    &#125;\n    for (int i = 1; i &lt;= lim; ++i)\n        (f[i] *= inv(i)) %= mod;\n    std::vector&lt;int&gt; a(n + 1);\n    struct _ &#123; int l, r; long long f; &#125;;\n    std::vector&lt;std::vector&lt;_&gt; &gt; g(lim + 1);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; a[i];\n        if (g[a[i]].empty()) &#123;\n            g[a[i]].resize(fac[a[i]].size());\n            for (int j = 0; j &lt; (int)fac[a[i]].size(); ++j) &#123;\n                g[a[i]][j].l = (j ? g[a[i]][j - 1].r + 1 : 1);\n                g[a[i]][j].r = fac[a[i]][j];\n                (g[a[i]][0].f += f[fac[a[i]][j]]) %= mod;\n                if (j != (int)fac[a[i]].size() - 1)\n                    (g[a[i]][j + 1].f += mod - f[fac[a[i]][j]]) %= mod;\n            &#125;\n            for (int j = 1; j &lt; (int)fac[a[i]].size(); ++j)\n                (g[a[i]][j].f += g[a[i]][j - 1].f) %= mod;\n            int getinv = inv(qkp(26, a[i]));\n            for (int j = 0; j &lt; (int)fac[a[i]].size(); ++j)\n                (g[a[i]][j].f *= getinv) %= mod;\n        &#125;\n    &#125;\n    std::vector&lt;int&gt; b(n + 1);\n    std::rotate_copy(a.begin() + 1, --a.end(), a.end(), b.begin() + 1);\n    long long res = 0ll;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        for (int j = 0, k = 0, now = 0;\n            j &lt; (int)fac[a[i]].size() &amp;&amp; k &lt; (int)fac[b[i]].size(); )\n            if (g[a[i]][j].r &lt; g[b[i]][k].r) &#123;\n                (res += g[a[i]][j].f * g[b[i]][k].f % mod\n                    * (g[a[i]][j].r - now) % mod) %= mod;\n                now = g[a[i]][j].r, ++j;\n            &#125;\n            else if (g[a[i]][j].r == g[b[i]][k].r) &#123;\n                (res += g[a[i]][j].f * g[b[i]][k].f % mod\n                    * (g[a[i]][j].r - now) % mod) %= mod;\n                now = g[a[i]][j].r, ++j, ++k;\n            &#125;\n            else &#123;\n                (res += g[a[i]][j].f * g[b[i]][k].f % mod\n                    * (g[b[i]][k].r - now) % mod) %= mod;\n                now = g[b[i]][k].r, ++k;\n            &#125;\n    &#125;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"二叉搜索树\">二叉搜索树</h2>\n<p><a href=\"https://pjudge.ac/contest/1914/problem/21889\" class=\"uri\">https://pjudge.ac/contest/1914/problem/21889</a></p>\n<p>当我们处理链的部分分时，很容易想到用差分解决问题。把更新 <span class=\"math inline\">\\([l, r]\\)</span> 看作在差分数组 <span class=\"math inline\">\\(l\\)</span> 处插入，在 <span class=\"math inline\">\\(r+1\\)</span> 处删除，离线下来再从左到右扫一遍操作，考虑如何解决查询问题。</p>\n<p>考虑如何获取 <span class=\"math inline\">\\(i\\)</span> 树上 <span class=\"math inline\">\\(t_0\\)</span> 时刻点 <span class=\"math inline\">\\(x\\)</span> 的所有祖先。根据前面的操作，我们可以获取 <span class=\"math inline\">\\(i\\)</span> 树上存在过的所有元素。</p>\n<p>对于比 <span class=\"math inline\">\\(x\\)</span> 大的元素，考虑祖先 <span class=\"math inline\">\\(p_a\\)</span> 和非祖先 <span class=\"math inline\">\\(p\\)</span> 有什么区别。根据 BST 的性质易得，对于最低的右侧祖先 <span class=\"math inline\">\\({p_a}_0\\)</span>，其是 <span class=\"math inline\">\\(\\ge x\\)</span> 的最小的元素（当然其加入时刻 <span class=\"math inline\">\\(t_a&lt;t_0\\)</span>）；那么同理可以找到 <span class=\"math inline\">\\({p_a}_0\\)</span> 右侧最低的祖先（其左侧的祖先显然也 <span class=\"math inline\">\\(x\\)</span> 左侧），该祖先满足 <span class=\"math inline\">\\(t&lt;t_a\\)</span>。那么我们就从左右两边分别得到 <span class=\"math inline\">\\(x\\)</span> 的所有祖先。容易证明该过程对于不在树上的 <span class=\"math inline\">\\(x\\)</span> 也是正确的。</p>\n<p>具体地，我们需要一个数据结构，能够求出 <span class=\"math inline\">\\(\\ge x\\)</span> 的元素中，以 <span class=\"math inline\">\\(t_0\\)</span> 为起点的前缀最小值序列的区间和。</p>\n<p>欸 ☝🤓 这是什么？<a href=\"/20250217\">楼房重建</a>！秒一下！</p>\n<p>进一步地，本题需要完成对于 <span class=\"math inline\">\\(t_0\\)</span> 为序列头的查询。再次利用性质，每次 <span class=\"math inline\">\\(O(\\log V)\\)</span> 地合并答案。</p>\n<p>好的那么怎么把链搞到树上呢？把差分放到树上，写个线段树合并即可。</p>\n<p><strong>注意由于这题细节太多了，所以你可能需要舍弃不必要的时空优化换取代码简洁度以方便调试。</strong></p>\n<details>\n<pre data-line=\"12\" class=\"cpp language-cpp\"><code data-line=\"12\" class=\"cpp language-cpp\">#include &lt;bits/stdc++.h&gt;\nconst int lim = 2e5;\nconst int maxn = 2e7 + 5;\nconst int inf = 0x3f3f3f3f;\nstruct &#123;\n    int l, r, rv;\n    long long u;\n&#125; t[maxn];\nstd::vector&lt;int> tr;\n#define lt t[p].l\n#define rt t[p].r\nint newnode(void) &#123;         // 我知道你要说什么，但这属于「必要的」空间优化 😥\n    static int tot = 0;\n    if (tr.empty())\n        return ++tot;\n    auto p(tr.back());\n    t[p].l = t[p].r = 0;\n    tr.pop_back();\n    return p;\n&#125;\nlong long askv(int p, int l, int r, int v) &#123;\n    if (l == r)\n        return t[p].rv < v ? t[p].u : 0;\n    int mid = (l + r) >> 1;\n    if (v > t[lt].rv)\n        return t[p].u - t[lt].u + askv(lt, l, mid, v);\n    return askv(rt, mid + 1, r, v);\n&#125;\nvoid pushup(int p, int l, int r) &#123;\n    t[p].rv = std::min(t[lt].rv, t[rt].rv);\n    int mid = (l + r) >> 1;\n    t[p].u = t[lt].u + askv(rt, mid + 1, r, t[lt].rv);\n    return;\n&#125;\nvoid upd(int &p, int l, int r, int x, int v, int u) &#123;\n    if (!p)\n        p = newnode();\n    if (l == r) &#123;\n        t[p].rv = v, t[p].u = u;\n        return;\n    &#125;\n    int mid = (l + r) >> 1;\n    if (x <= mid)\n        upd(lt, l, mid, x, v, u);\n    else\n        upd(rt, mid + 1, r, x, v, u);\n    pushup(p, l, r);\n    return;\n&#125;\nvoid merge(int &p, int q, int l, int r) &#123;\n    if (!p || !q) &#123;\n        p += q;\n        return;\n    &#125;\n    if (l == r) &#123;\n        t[p].rv = std::min(t[p].rv, t[q].rv);\n        t[p].u = std::max(t[p].u, t[q].u);\n        return;\n    &#125;\n    int mid = (l + r) >> 1;\n    merge(t[p].l, t[q].l, l, mid), merge(t[p].r, t[q].r, mid + 1, r);\n    pushup(p, l, r), tr.push_back(q);\n    return;\n&#125;\nint qv = inf;\nlong long ask(int p, int l, int r, int ql, int qr) &#123;\n    if (ql <= l && r <= qr) &#123;\n        auto s(askv(p, l, r, qv));\n        qv = std::min(qv, t[p].rv);\n        return s;\n    &#125;\n    int mid = (l + r) >> 1;\n    long long res = 0ll;\n    if (ql <= mid)\n        res = ask(lt, l, mid, ql, qr);\n    if (qr > mid)\n        res += ask(rt, mid + 1, r, ql, qr);\n    return res;\n&#125;\n#undef lt\n#undef rt\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(\"ex_problem4.in\", \"r\", stdin);\n    std::freopen(\".out\", \"w\", stdout);\n#endif\n    int n, m;\n    std::cin >> n >> m;\n    std::vector&lt;std::vector&lt;int> > g(n + 1);\n    for (int i = 1, x, y; i < n; ++i) &#123;\n        std::cin >> x >> y;\n        g[x].push_back(y), g[y].push_back(x);\n    &#125;\n    std::vector&lt;int> top(n + 1), fa(n + 1), siz(n + 1), son(n + 1), dep(n + 1);\n    std::function&lt;void(int, int)> DFS = [&](int x, int faa) &#123;\n        siz[x] = 1;\n        for (auto i : g[x])\n            if (i != faa) &#123;\n                fa[i] = x, dep[i] = dep[x] + 1;\n                DFS(i, x), siz[x] += siz[i];\n                if (siz[i] > siz[son[x]])\n                    son[x] = i;\n            &#125;\n        return;\n    &#125;;\n    DFS(1, -1);\n    DFS = [&](int x, int topp) &#123;\n        top[x] = topp;\n        if (son[x])\n            DFS(son[x], topp);\n        for (auto i : g[x])\n            if (i != fa[x] && i != son[x])\n                DFS(i, i);\n        return;\n    &#125;;\n    DFS(1, 1);\n    auto getLCA = [&](int x, int y) &#123;\n        for (; top[x] != top[y]; x = fa[top[x]])\n            if (dep[top[y]] > dep[top[x]])\n                std::swap(x, y);\n        return (dep[x] < dep[y] ? x : y);\n    &#125;;\n    std::vector&lt;std::vector&lt;int> > d(n + 1);\n    std::vector&lt;std::vector&lt;std::pair&lt;int, int> > > u(n + 1);\n    std::vector&lt;std::vector&lt;std::tuple&lt;int, int, int> > > q(n + 1);\n    int cnt = 0;\n    for (int i = 1; i <= m; ++i) &#123;\n        int op;\n        std::cin >> op;\n        if (op == 0) &#123;\n            int x, v;\n            std::cin >> x >> v;\n            q[x].emplace_back(++cnt, i, v);\n        &#125; else &#123;\n            int x, y, v;\n            std::cin >> x >> y >> v;\n            int faa = getLCA(x, y);\n            u[x].emplace_back(i, v), u[y].emplace_back(i, v);\n            if (fa[faa])\n                d[fa[faa]].emplace_back(v);\n        &#125;\n    &#125;\n    std::vector&lt;long long> res(cnt + 1);\n    std::vector&lt;std::vector&lt;int> > rt(2, std::vector&lt;int> (n + 1));\n    t[0].rv = inf;\n    DFS = [&](int x, int fa) &#123;\n        for (auto i : g[x])\n            if (i != fa) &#123;\n                DFS(i, x);\n                merge(rt[0][x], rt[0][i], 1, lim);\n                merge(rt[1][x], rt[1][i], 1, lim);\n            &#125;\n        for (auto [t, v] : u[x]) &#123;\n            upd(rt[0][x], 1, lim, v, t, v);\n            upd(rt[1][x], 1, lim, lim - v + 1, t, v);\n        &#125;\n        for (auto v : d[x]) &#123;\n            upd(rt[0][x], 1, lim, v, inf, 0);\n            upd(rt[1][x], 1, lim, lim - v + 1, inf, 0);\n        &#125;\n        for (auto [id, t, v] : q[x]) &#123;\n            qv = t, res[id] = ask(rt[0][x], 1, lim, v, lim);\n            qv = t, res[id] += ask(rt[1][x], 1, lim, lim - v + 1, lim);\n            qv = t, res[id] -= ask(rt[0][x], 1, lim, v, v);\n        &#125;\n    &#125;;\n    DFS(1, -1);\n    for (int i = 1; i <= cnt; ++i)\n        std::cout << res[i] << '\\n';\n    return 0;\n&#125;</code></pre>\n</details>\n",
            "tags": [
                "线段树",
                "数学",
                "树上差分"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20241021/",
            "url": "https://xsc062.netlify.app/20241021/",
            "title": "字符串",
            "date_published": "2024-10-21T00:32:59.000Z",
            "content_html": "<p>标题本来叫「哈希」，后来发现第二天的很多题虽然打了哈希的 tag 但是只有 KMP 做法，故忍痛改成「字符串」。</p>\n<span id=\"more\"></span>\n<hr />\n<h2 id=\"a.-two-permutations\">A. Two Permutations</h2>\n<p><a href=\"http://222.180.160.110:61235/contest/5653/problem/1\" class=\"uri\">http://222.180.160.110:61235/contest/5653/problem/1</a></p>\n<p>有个很重要的性质是 <span class=\"math inline\">\\(a\\)</span> 和 <span class=\"math inline\">\\(b\\)</span> 都是排列。然后我们就知道了 <span class=\"math inline\">\\(x\\in [0,m-n]\\)</span>，且每个 <span class=\"math inline\">\\(a_i+x\\)</span> 在 <span class=\"math inline\">\\(b\\)</span> 中有元素与之唯一对应。<mark>于是问题可以转化成，<span class=\"math inline\">\\(b\\)</span> 中在 <span class=\"math inline\">\\([1+x,n+x]\\)</span> 范围中的元素按顺序哈希起来和 <span class=\"math inline\">\\(a\\)</span> 序列是否完全一致</mark>。</p>\n<p>我们就有了一个想法：枚举这个 <span class=\"math inline\">\\(x\\)</span>，通过某种方法快速查询这个长度固定的值域区间按顺序哈希起来的值。<mark>然后就是典中典之线段树维护哈希，只需在枚举 <span class=\"math inline\">\\(x\\)</span> 时滑动窗口，剔除头部元素，新增尾部元素，查询全局哈希值即可</mark>。</p>\n<p>还有一个小细节是关于实时维护全局加 <span class=\"math inline\">\\(x\\)</span> 后的 <span class=\"math inline\">\\(a\\)</span>。由于哈希用乘的肯定拆不开，只能用加哈希了。每次 <span class=\"math inline\">\\(x\\)</span> 加一的时候全局哈希值加上 <span class=\"math inline\">\\(\\sum p_i\\)</span> 即可。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int p = 998244353;\nconst int mod = 1e9 + 7;\nconst int maxn = 2e5 + 5;\nstruct &#123;\n    int l, r, s;\n    long long u;\n&#125; t[maxn &lt;&lt; 2];\nlong long base[maxn];\n#define lt (p &lt;&lt; 1)\n#define rt (lt | 1)\nvoid pushup(int p) &#123;\n    t[p].u = (t[lt].u * base[t[rt].s] % mod + t[rt].u) % mod;\n    return;\n&#125;\nvoid bld(int p, int l, int r) &#123;\n    t[p].l = l, t[p].r = r;\n    if (l == r)\n        return;\n    int mid = (l + r) &gt;&gt; 1;\n    bld(lt, l, mid), bld(rt, mid + 1, r);\n    return;\n&#125;\nvoid add(int p, int x, int v) &#123;\n    t[p].s += (v &gt;= 0 ? 1 : -1);\n    if (t[p].l == t[p].r) &#123;\n        t[p].u += v;\n        return;\n    &#125;\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (x &lt;= mid)\n        add(lt, x, v);\n    else\n        add(rt, x, v);\n    pushup(p);\n    return;\n&#125;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, m;\n    std::cin &gt;&gt; n &gt;&gt; m;\n    std::vector&lt;int&gt; a(n + 1), b(m + 1), pos(m + 1);\n    base[0] = 1;\n    long long s = 1;\n    for (int i = 1; i &lt;= m; ++i) &#123;\n        base[i] = base[i - 1] * p % mod;\n        if (i &lt; n)\n            (s += base[i]) %= mod;\n    &#125;\n    long long now = 0;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; a[i];\n        now = (now * p % mod + a[i]) % mod;\n    &#125;\n    for (int i = 1; i &lt;= m; ++i)\n        std::cin &gt;&gt; b[i], pos[b[i]] = i;\n    int res = 0;\n    bld(1, 1, m);\n    for (int x = 0; x &lt;= m - n; ++x) &#123;\n        for (static int l = 1; l &lt; 1 + x; add(1, pos[l], -l), ++l);\n            // printf(&quot;add %d: %d\\n&quot;, pos[l], -l);\n        for (static int r = 1; r &lt;= n + x; add(1, pos[r], r), ++r);\n            // printf(&quot;add %d: %d\\n&quot;, pos[r], r);\n        (res += (now == t[1].u));\n        // printf(&quot;x = %d, now = %lld, t[1].u = %lld\\n&quot;, x, now, t[1].u);\n        (now += s) %= mod;\n    &#125;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"b.-k-substrings\">B. k-substrings</h2>\n<p><a href=\"http://222.180.160.110:61235/contest/5653/problem/2\" class=\"uri\">http://222.180.160.110:61235/contest/5653/problem/2</a></p>\n<p>我们可以发现这 <span class=\"math inline\">\\(\\left\\lceil\\dfrac n2\\right\\rceil\\)</span> 个串都有共同中点，而<mark>不管其位于元素还是元素间的空隙，两边的 border 都应关于其对称</mark>。啥叫奇 border 呢，就是每个 border 都能取到元素上的中点，<mark>也就是说这俩中点是关于全串中点对称的</mark>。</p>\n<p>我们枚举这 <span class=\"math inline\">\\(\\left\\lfloor\\dfrac n2\\right\\rfloor\\)</span> 对可能的 border 中点，分别二分 border 长度。假设最后该对中点最长合法 border 为 <span class=\"math inline\">\\([l_1,r_1]\\)</span> 与 <span class=\"math inline\">\\([l_2,r_2]\\)</span>，用 <span class=\"math inline\">\\(r_1-l_1+1-2\\times k\\)</span> 更新 <span class=\"math inline\">\\(l_1+k\\)</span> 处的答案即可。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int p = 131;\nconst int mod = 1e9 + 7;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;char&gt; a(n + 1);\n    std::vector&lt;int&gt; res(n + 1, -1);\n    std::vector&lt;long long&gt; h(n + 1), base(n + 1);\n    base[0] = 1;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; a[i];\n        h[i] = (h[i - 1] * p + a[i]) % mod;\n        base[i] = base[i - 1] * p % mod;\n    &#125;\n    auto geth = [&amp;](int l, int r) &#123;\n        return (h[r] + mod - h[l - 1] * base[r - l + 1] % mod) % mod;\n    &#125;;\n    for (int l = n / 2, r = (n + 1) / 2 + 1; r &lt;= n; --l, ++r)\n        if (a[l] == a[r]) &#123;\n            int t = 0;\n            for (int ll = 1, rr = l, mid; ll &lt;= rr; ) &#123;\n                mid = (ll + rr) &gt;&gt; 1;\n                if (geth(l - mid + 1, l + mid - 1) == geth(r - mid + 1, r + mid - 1))\n                    t = mid, ll = mid + 1;\n                else\n                    rr = mid - 1;\n            &#125;\n            res[l - t + 1] = std::max(res[l - t + 1], 2 * t - 1);\n        &#125;\n    for (int i = 1; i &lt;= (n + 1) / 2; ++i) &#123;\n        res[i] = std::max(res[i - 1] - 2, res[i]);\n        std::cout &lt;&lt; res[i] &lt;&lt; &#39; &#39;;\n    &#125;\n    std::cout &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"c.-kefa-and-watch\">C. Kefa and Watch</h2>\n<p><a href=\"http://222.180.160.110:61235/contest/5653/problem/3\" class=\"uri\">http://222.180.160.110:61235/contest/5653/problem/3</a></p>\n<p>一个挺常用的 trick 是，<mark><span class=\"math inline\">\\(S_{l\\sim r}\\)</span> 存在长度为 <span class=\"math inline\">\\(d\\)</span> 的循环节 <span class=\"math inline\">\\(\\iff S_{l\\sim (r-d)}=S_{(l+d+)\\sim r}\\)</span></mark>。而题目要求为混循环节，刚好也可以用这个方法判定。线段树随便维护一下哈希就行。assign 操作就是将长度为 <span class=\"math inline\">\\(len\\)</span> 的区间哈希值更改为 <span class=\"math inline\">\\(t\\times \\sum_{i=0}^{len-1}p^i\\)</span>。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int p = 131;\nconst int mod = 1e9 + 7;\nconst int maxn = 1e5 + 5;\nstruct &#123;\n    int l, r, d;\n    long long u;\n&#125; t[maxn &lt;&lt; 2];\nint a[maxn];\nlong long base[maxn], s[maxn];\n#define lt (p &lt;&lt; 1)\n#define rt (lt | 1)\nvoid pushup(int p) &#123;\n    t[p].u = (t[lt].u * base[t[rt].r - t[rt].l + 1] % mod + t[rt].u) % mod;\n    return;\n&#125;\nvoid pushdown(int p) &#123;\n    if (~t[p].d) &#123;\n        t[lt].d = t[rt].d = t[p].d;\n        t[lt].u = t[p].d * s[t[lt].r - t[lt].l] % mod;\n        t[rt].u = t[p].d * s[t[rt].r - t[rt].l] % mod;\n        t[p].d = -1;\n    &#125;\n    return;\n&#125;\nvoid bld(int p, int l, int r) &#123;\n    t[p].l = l, t[p].r = r, t[p].d = -1;\n    if (l == r) &#123;\n        t[p].u = a[l];\n        return;\n    &#125;\n    int mid = (l + r) &gt;&gt; 1;\n    bld(lt, l, mid), bld(rt, mid + 1, r);\n    pushup(p);\n    return;\n&#125;\nvoid ass(int p, int l, int r, int v) &#123;\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r) &#123;\n        t[p].d = v;\n        t[p].u = v * s[t[p].r - t[p].l] % mod;\n        return;\n    &#125;\n    pushdown(p);\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (l &lt;= mid)\n        ass(lt, l, r, v);\n    if (r &gt; mid)\n        ass(rt, l, r, v);\n    pushup(p);\n    return;\n&#125;\nlong long ask(int p, int l, int r) &#123;\n    // printf(&quot;p = %d, u = %lld, [%d, %d] of [%d, %d]\\n&quot;, p, t[p].u, t[p].l, t[p].r, l, r);\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r)\n        return t[p].u;\n    pushdown(p);\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (r &lt;= mid)\n        return ask(lt, l, r);\n    if (l &gt; mid)\n        return ask(rt, l, r);\n    return (ask(lt, l, r) * base[std::min(r, t[p].r) - mid] % mod + ask(rt, l, r)) % mod;\n&#125;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, m, k;\n    std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;\n    base[0] = s[0] = 1;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        char t;\n        std::cin &gt;&gt; t;\n        a[i] = t - &#39;0&#39;;\n        base[i] = base[i - 1] * p % mod;\n        s[i] = (s[i - 1] + base[i]) % mod;\n    &#125;\n    bld(1, 1, n);\n    for (int q = m + k; q--; ) &#123;\n        int op;\n        std::cin &gt;&gt; op;\n        if (op == 1) &#123;\n            int l, r, t;\n            std::cin &gt;&gt; l &gt;&gt; r &gt;&gt; t;\n            ass(1, l, r, t);\n        &#125;\n        else &#123;\n            int l, r, d;\n            std::cin &gt;&gt; l &gt;&gt; r &gt;&gt; d;\n            // if (d != r - l + 1)\n            //     printf(&quot;%lld / %lld\\n&quot;, ask(1, l, r - d), ask(1, l + d, r));\n            std::cout &lt;&lt; ((d == r - l + 1 || ask(1, l, r - d) == ask(1, l + d, r)) ? &quot;YES&quot; : &quot;NO&quot;) &lt;&lt; &#39;\\n&#39;;\n        &#125;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"d.-misha-and-lcp-on-tree\">D. Misha and LCP on Tree</h2>\n<p><a href=\"http://222.180.160.110:61235/contest/5653/problem/4\" class=\"uri\">http://222.180.160.110:61235/contest/5653/problem/4</a></p>\n<p>一个很显然的做法是，我们二分一个长度，然后在 <span class=\"math inline\">\\(a\\to fa\\)</span> 上正哈希，<span class=\"math inline\">\\(b\\to fa\\)</span> 上反哈希，<span class=\"math inline\">\\(O(1)\\)</span> check。</p>\n<p>笑话：本来想用倍增求 <span class=\"math inline\">\\(a\\to fa\\)</span> 和 <span class=\"math inline\">\\(b\\to fa\\)</span> 的哈希（当然双 <span class=\"math inline\">\\(\\log\\)</span> 肯定是会被卡飞的），后来发现<mark>哈希具有可减性，我们又只需求一条链上的哈希值，直接减掉就行</mark>。</p>\n<p>还有一个点就是 <span class=\"math inline\">\\(O(1)\\)</span> 求 <span class=\"math inline\">\\(k\\)</span> 级祖先，有长剖预处理的做法。<a href=\"/20241021-1\">具体做法</a>。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int p = 131;\nconst int mod = 1e9 + 7;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;int&gt; to(n + 1);\n    std::vector&lt;char&gt; a(n + 1);\n    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);\n    std::vector&lt;long long&gt; base(n + 1), inv(n + 1);\n    auto qkp = [](long long x, int y) &#123;\n        long long res = 1;\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    base[0] = inv[0] = 1;\n    for (int i = 1, mx = 0; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; a[i];\n        base[i] = base[i - 1] * p % mod;\n        inv[i] = qkp(base[i], mod - 2);\n        if (i &gt;= (1 &lt;&lt; mx) * 2)\n            ++mx;\n        to[i] = mx;\n    &#125;\n    for (int i = 1, x, y; i &lt; n; ++i) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y;\n        g[x].push_back(y), g[y].push_back(x);\n    &#125;\n    std::vector&lt;long long&gt; h1(n + 1), h2(n + 1);\n    std::vector&lt;std::array&lt;int, 21&gt; &gt; fa(n + 1);\n    std::vector&lt;int&gt; h(n + 1, 1), son(n + 1), dep(n + 1);\n    h[0] = 0;\n    std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;\n        h1[x] = (h1[fa[x][0]] * p % mod + a[x]) % mod;\n        h2[x] = (h2[fa[x][0]] + a[x] * base[dep[x] - 1]) % mod;\n        for (auto i : g[x])\n            if (i != fa[x][0]) &#123;\n                fa[i][0] = x;\n                for (int j = 1; j &lt;= 20; ++j)\n                    fa[i][j] = fa[fa[i][j - 1]][j - 1];\n                dep[i] = dep[x] + 1;\n                DFS(i);\n                if (h[i] &gt;= h[son[x]])\n                    son[x] = i, h[x] = h[i] + 1;\n            &#125;\n        return;\n    &#125;;\n    dep[1] = 1, DFS(1);\n    std::vector&lt;int&gt; top(n + 1), id(n + 1);\n    std::vector&lt;std::vector&lt;int&gt; &gt; anc(n + 1), des(n + 1, std::vector&lt;int&gt; (1));\n    std::function&lt;void(int, int)&gt; DFS1 = [&amp;](int x, int toq) &#123;\n        top[x] = toq;\n        if (son[x])\n            DFS1(son[x], toq);\n        for (auto i : g[x])\n            if (i != fa[x][0] &amp;&amp; i != son[x])\n                DFS1(i, i);\n        des[toq].push_back(x);\n        id[x] = (int)des[toq].size() - 1;\n        if (x == toq) &#123;\n            anc[x].push_back(x);\n            for (int j = 1, now = x; j &lt;= id[x]; ++j, now = fa[now][0])\n                anc[x].push_back(fa[now][0]);\n        &#125;\n        return;\n    &#125;;\n    DFS1(1, 1);\n    auto getLCA = [&amp;](int x, int y) &#123;\n        if (dep[x] &lt; dep[y])\n            std::swap(x, y);\n        for (int i = 20; ~i; --i)\n            if (dep[fa[x][i]] &gt;= dep[y])\n                x = fa[x][i];\n        if (x == y)\n            return x;\n        for (int i = 20; ~i; --i)\n            if (fa[x][i] != fa[y][i])\n                x = fa[x][i], y = fa[y][i];\n        return fa[x][0];\n    &#125;;\n    auto ask = [&amp;](int x, int k) &#123;\n        assert(dep[x] - 1 &gt;= k);\n        int x1 = x;\n        if (!k)\n            return x;\n        x = fa[x][to[k]];\n        if (dep[x] - dep[top[x]] &gt;= k - (1 &lt;&lt; to[k]))\n            return des[top[x]][id[x] + k - (1 &lt;&lt; to[k])];\n        return anc[top[x]][k - (1 &lt;&lt; to[k]) - (dep[x] - dep[top[x]])];\n    &#125;;\n    auto dis = [&amp;](int x, int y, int fa) &#123;\n        return dep[x] + dep[y] - 2 * dep[fa];\n    &#125;;\n    auto gethash = [&amp;](int x, int y, int f, int k) &#123;\n        if (!k)\n            return 0ll;\n        if (k &lt;= dep[x] - dep[f] + 1) &#123;\n            f = ask(x, k - 1);\n            return (h2[x] + mod - h2[fa[f][0]]) % mod * inv[dep[f] - 1] % mod;\n        &#125;\n        long long h = (h2[x] + mod - h2[fa[f][0]]) % mod * inv[dep[f] - 1] % mod;\n        k -= (dep[x] - dep[f] + 1);\n        y = ask(y, (dep[y] - dep[f]) - k);\n        h = (h * base[dep[y] - dep[f]] % mod + (h1[y] + mod - h1[f] * base[dep[y] - dep[f]] % mod) % mod) % mod;\n        return h;\n    &#125;;\n    int m;\n    std::cin &gt;&gt; m;\n    for (int x, y, a, b; m--; ) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y &gt;&gt; a &gt;&gt; b;\n        int fa1 = getLCA(x, y), fa2 = getLCA(a, b), res = 0;\n        for (int l = 0, r = std::min(dis(x, y, fa1), dis(a, b, fa2)) + 1, mid; l &lt;= r; ) &#123;\n            mid = (l + r) &gt;&gt; 1;\n            if (gethash(x, y, fa1, mid) == gethash(a, b, fa2, mid))\n                res = mid, l = mid + 1;\n            else\n                r = mid - 1;\n        &#125;\n        std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"a.-song-of-the-sirens\">A. Song of the Sirens</h2>\n<p><a href=\"http://222.180.160.110:61235/contest/5658/problem/1\" class=\"uri\">http://222.180.160.110:61235/contest/5658/problem/1</a></p>\n<p>笑话：是 <span class=\"math inline\">\\(s_it_is_i\\)</span> 而不是 <span class=\"math inline\">\\(s_its_i\\)</span>。</p>\n<p>我们发现 <span class=\"math inline\">\\(s_0\\)</span> 很短，所以直接枚举起始位置把 <span class=\"math inline\">\\(s_0\\)</span> 和匹配串大力匹配，把空位挖出来组成新的匹配串再考虑 <span class=\"math inline\">\\(t\\)</span> 的问题（因为所有 <span class=\"math inline\">\\(s_i\\)</span> 最开头都有一个完整的 <span class=\"math inline\">\\(s_0\\)</span>，所以可以随便选断点）。</p>\n<p>我们知道 <span class=\"math inline\">\\(t\\)</span> 的下标是一个自底向上从 <span class=\"math inline\">\\(1\\)</span> 到 <span class=\"math inline\">\\(n\\)</span> 的满二叉树的中序遍历，其中 <mark><span class=\"math inline\">\\(t_1\\)</span> 间隔一位出现；于是我们仿照对 <span class=\"math inline\">\\(s\\)</span> 的处理方式，再把 <span class=\"math inline\">\\(t_1\\)</span> 挖掉。注意到此时 <span class=\"math inline\">\\(t_2\\)</span> 又成为二叉树最底层，间隔一位出现，这就变成了一个 <span class=\"math inline\">\\(\\mathcal O(n\\log n)\\)</span> 递归的问题</mark>。</p>\n<p>至于答案，当 <span class=\"math inline\">\\(t\\)</span> 被删空时，假设删掉的最后一个元素为 <span class=\"math inline\">\\(t_p\\)</span>，<span class=\"math inline\">\\(t\\)</span> 的出现次数即为二叉树中 <span class=\"math inline\">\\(p\\)</span> 层点数，为 <span class=\"math inline\">\\(2^{k-p}\\)</span>。</p>\n<p>有一个细节，就是如果当前删到 <span class=\"math inline\">\\(i\\)</span> 了，<span class=\"math inline\">\\(t\\)</span> 的长度只剩 <span class=\"math inline\">\\(1\\)</span>，就会有一个很尴尬的问题——这个元素不一定就是 <span class=\"math inline\">\\(t_i\\)</span>，而应该是 <span class=\"math inline\">\\(\\{j \\mid j\\ge i\\land t_j=t_i\\}\\)</span>。统计 <span class=\"math inline\">\\(t_{i\\sim k}\\)</span> 中值为 <span class=\"math inline\">\\(t_i\\)</span> 的元素个数（前缀和），乘上对应的层数即可。这个可以用一点小技巧搞定，前缀和时忽略 <span class=\"math inline\">\\(k\\)</span> 乘上 <span class=\"math inline\">\\(k=n\\)</span> 时的系数，统计答案时乘上 <span class=\"math inline\">\\(2^{n-k}\\)</span> 即可。</p>\n<p>不是，那我缺的哈希这块谁来补啊？？？</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 1e9 + 7;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;sirens1.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, q, m;\n    std::string s;\n    std::cin &gt;&gt; n &gt;&gt; q &gt;&gt; s;\n    s = &#39;\\0&#39; + s, m = (int)s.length() - 1;\n    std::vector&lt;char&gt; t(n + 1);\n    std::vector&lt;long long&gt; base(n + 1), inv(n + 1);\n    std::vector&lt;std::array&lt;long long, 26&gt; &gt; a(n + 1);\n    auto qkp = [](long long x, int y) &#123;\n        long long res = 1ll;\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    base[0] = 1ll, inv[0] = 1ll, inv[1] = qkp(2, mod - 2);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; t[i];\n        base[i] = base[i - 1] * 2 % mod;\n        if (i != 1)\n            inv[i] = inv[i - 1] * inv[1] % mod;\n    &#125;\n    for (int i = 1; i &lt;= n; ++i)\n        a[i] = a[i - 1], (a[i][t[i] - &#39;a&#39;] += base[n - i]) %= mod;\n    for (int k; q--; ) &#123;\n        std::string p;\n        std::cin &gt;&gt; k &gt;&gt; p;\n        p = &#39;\\0&#39; + p;\n        long long res = 0;\n        int l = (int)p.length() - 1;\n        std::vector&lt;char&gt; u;\n        std::function&lt;void(int, std::vector&lt;char&gt; &amp;)&gt; calc = [&amp;](int x, std::vector&lt;char&gt; &amp;p) &#123;\n            int m = (int)p.size() - 1;\n            if (m == 0) &#123;\n                // puts(&quot;# 45&quot;);\n                // printf(&quot;0, += %lld\\n&quot;, base[k - x + 1]);\n                (res += base[k - x + 1]) %= mod;\n                return;\n            &#125;\n            if (x &gt; k)\n                return;\n            if (m == 1) &#123;\n                // puts(&quot;# 50&quot;);\n                // printf(&quot;1, += %lld(%lld)\\n&quot;, (a[k][p[1] - &#39;a&#39;] + mod - a[x - 1][p[1] - &#39;a&#39;]) % mod * inv[n - k] % mod, inv[n - k] % mod);\n                (res += (a[k][p[1] - &#39;a&#39;] + mod - a[x - 1][p[1] - &#39;a&#39;]) % mod * inv[n - k] % mod) %= mod;\n                return;\n            &#125;\n            bool flag0 = 1, flag1 = 1;\n            std::vector&lt;char&gt; t0(1), t1(1);\n            for (int i = 1; i &lt;= m; ++i)\n                if (!(i &amp; 1)) &#123;\n                    if (flag0)\n                        t0.push_back(p[i]);\n                    flag1 &amp;= (p[i] == t[x]);\n                &#125;\n                else &#123;\n                    if (flag1)\n                        t1.push_back(p[i]);\n                    flag0 &amp;= (p[i] == t[x]);\n                &#125;\n            if (flag0)\n                calc(x + 1, t0);\n            if (flag1)\n                calc(x + 1, t1);\n            return;\n        &#125;;\n        for (int i = 1; i &lt;= m + 1; ++i) &#123;\n            std::vector&lt;char&gt;(1).swap(u);\n            for (int j = i, now = 1; now &lt;= l; ++now) &#123;\n                if (j == m + 1)\n                    j = 1, u.push_back(p[now]);\n                else if (p[now] != s[j])\n                    goto nosol;\n                else\n                    ++j;\n            &#125;\n            // printf(&quot;u: &quot;);\n            // for (int i = 1; i &lt; (int)u.size(); ++i)\n            //     std::cout &lt;&lt; u[i];\n            // puts(&quot;&quot;);\n            calc(1, u);\n        nosol: ;\n        &#125;\n        std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"b.-prefix-of-suffixes\">B. Prefix of Suffixes</h2>\n<p><a href=\"http://222.180.160.110:61235/contest/5658/problem/2\" class=\"uri\">http://222.180.160.110:61235/contest/5658/problem/2</a></p>\n<p>还是太科幻了。哦哦 border 我的 border。</p>\n<h3 id=\"法一\">法一</h3>\n<p>考虑每次增量，若加入 <span class=\"math inline\">\\(S_i\\)</span> 后有 <span class=\"math inline\">\\(z_j\\)</span> 的值增加 <span class=\"math inline\">\\(1\\)</span>，那么这对 <span class=\"math inline\">\\((i, j)\\)</span> 就会贡献 <span class=\"math inline\">\\(A_j\\cdot B_i\\)</span> 的增量；<mark>反之，<span class=\"math inline\">\\(z_j\\)</span> 在以后也不会增加</mark>。</p>\n<p>我们维护当前没有确定下来的所有 <span class=\"math inline\">\\(z_j\\)</span>，对于每个 <span class=\"math inline\">\\(i\\)</span> 暴力 check <span class=\"math inline\">\\(z_j\\)</span> 是否确定并更新答案，<strong>因为数据比较弱</strong>，在 CF 神机上跑得飞快 <img src=\"/em/dy.gif\" /> 但是 QOJ 上死活过不了 <img src=\"/em/ll.gif\" /></p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    long long res = 0, s = 0;\n    std::cin &gt;&gt; n;\n    std::vector&lt;int&gt; now;\n    std::vector&lt;int&gt; a(n + 1), b(n + 1), t(n + 1);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; t[i] &gt;&gt; a[i] &gt;&gt; b[i];\n        t[i] = (res + t[i]) % n;\n        if (t[i] == t[1])\n            s += b[i], now.push_back(i);\n        std::vector&lt;int&gt; g(std::move(now));\n        for (auto j : g)\n            if (t[i] == t[i - j + 1])\n                now.push_back(j);\n            else\n                s -= b[j];\n        res += a[i] * s;\n        std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n<h3 id=\"法二\">法二</h3>\n<p>依然考虑增量。<mark><span class=\"math inline\">\\(z_j\\)</span> 增加 <span class=\"math inline\">\\(\\iff S_{j\\to i}\\)</span> 为 <span class=\"math inline\">\\(S_{1\\sim i}\\)</span> 的一个 border</mark>。考虑对于每一个 <span class=\"math inline\">\\(S_i\\)</span>，border 的组成。</p>\n<ol type=\"1\">\n<li>若 <span class=\"math inline\">\\(S_1=S_i\\)</span>，那么将会新增一个长度为 <span class=\"math inline\">\\(1\\)</span> 的 border。</li>\n<li>对于在 <span class=\"math inline\">\\(i-1\\)</span> 处合法的 border <span class=\"math inline\">\\(S_{j\\sim i-1}\\)</span>，若 <span class=\"math inline\">\\(S_i=S_{i-j+1}\\)</span>，则该 border 仍合法；否则非法。</li>\n</ol>\n<p>我们的法一其实相当于是暴力 check 了所有合法 border 是否仍然合法，但这显然最坏是 <span class=\"math inline\">\\(O(n^2)\\)</span> 的。我们考虑从 border 角度优化一下。</p>\n<p>我们发现，比如说 <span class=\"math inline\">\\(\\texttt{abababa + b}\\)</span>，我们会进行很多次不必要的 check，当然这个时候我们会本能大力跳 fail，但是这里有一个 <a href=\"https://www.luogu.com/article/e08ebmz6\">border 的等差数列性质</a>，若 <span class=\"math inline\">\\(x+1\\)</span> 与 <span class=\"math inline\">\\(i\\)</span> 能够匹配，那么与 <span class=\"math inline\">\\(x\\)</span> 同属一个等差数列的所有 <span class=\"math inline\">\\(x&#39;+1\\)</span> 都应和 <span class=\"math inline\">\\(i\\)</span> 匹配。</p>\n<p>对于正在 check 的 <span class=\"math inline\">\\(x\\)</span>，如果 check 成功则跳到上一条链的链尾；否则跳到链头。总的复杂度是 <span class=\"math inline\">\\(O(n\\log n)\\)</span> 的。找一下和每个 <span class=\"math inline\">\\(i\\)</span> 匹配不了的第一个链头，甚至可以因为某些我太菜了所以不知道的不明原因整到线性。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    long long res = 0, s = 0;\n    std::cin &gt;&gt; n;\n    std::vector&lt;int&gt; a(n + 1), b(n + 1), t(n + 1), ne(n + 1), to(n + 1);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; t[i] &gt;&gt; a[i] &gt;&gt; b[i];\n        t[i] = (res + t[i]) % n;\n        if (i == 1)\n            s += b[i], res = (long long)a[i] * b[i];\n        else &#123;\n            int j = ne[i - 1];\n            for (; j &amp;&amp; t[j + 1] != t[i]; j = ne[j]);\n            if (t[j + 1] == t[i])\n                ++j;\n            ne[i] = j;\n            if (t[i] == t[1])\n                s += b[i];\n            to[i - 1] = (t[ne[i - 1] + 1] == t[i] ? to[ne[i - 1]] : ne[i - 1]);\n            for (int j = i - 1; j; )\n                if (t[j + 1] == t[i])\n                    j = to[j];\n                else\n                    for (int at = to[j]; j != at; s -= b[i - j], j = ne[j]);\n            res += a[i] * s;\n        &#125;\n        std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"c.-matching\">C. Matching</h2>\n<p><a href=\"http://222.180.160.110:61235/contest/5658/problem/3\" class=\"uri\">http://222.180.160.110:61235/contest/5658/problem/3</a></p>\n<p>我们发现，如果我们直接要 check 一段 <span class=\"math inline\">\\(a\\)</span> 和 <span class=\"math inline\">\\(p\\)</span>，感觉不太好整。</p>\n<p>然后考虑这么一个问题，假如我们通过神秘方法让我们每次 check 的 <span class=\"math inline\">\\(a\\)</span></p>\n",
            "tags": [
                "哈希",
                "线段树",
                "KMP",
                "border"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20240106/",
            "url": "https://xsc062.netlify.app/20240106/",
            "title": "杂题全谈",
            "date_published": "2024-01-06T03:27:39.000Z",
            "content_html": "<p>想不到好标题了。</p>\n<span id=\"more\"></span>\n<p>有句话怎么说来着，罗马不是一天建成的，是一天天建成的。</p>\n<p>还有什么，Do in Rome as the Romans’ do，还有一句，All roads leads to Rome。</p>\n<hr />\n<h3 id=\"a.-连续的零-zero\">A. 连续的零 zero</h3>\n<p><a href=\"http://222.180.160.110:61235/contest/4647/problem/1\" class=\"uri\">http://222.180.160.110:61235/contest/4647/problem/1</a></p>\n<p>做个前缀和，看看任意一个长度为 <span class=\"math inline\">\\(k\\)</span> 的区间中有几个 <span class=\"math inline\">\\(1\\)</span>。复杂度 <span class=\"math inline\">\\(O(n)\\)</span>。</p>\n<details>\n<pre class=\"cpp\"><code>namespace XSC062 &#123;\nusing namespace fastIO;\nconst int maxn = 5e5 + 5;\nconst int inf = 0x3f3f3f3f;\nint n, m, res = inf;\nint a[maxn], s[maxn];\nint min(int x, int y) &#123;\n    return x &lt; y ? x : y;\n&#125;\nint main() &#123;\n    scanf(&quot;%d %d&quot;, &amp;n, &amp;m);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        scanf(&quot;%1d&quot;, &amp;a[i]);\n        s[i] = s[i - 1] + a[i];\n        if (i &gt;= m)\n            res = min(res, s[i] - s[i - m]);\n    &#125;\n    print(res, &#39;\\n&#39;);\n    return 0;\n&#125;\n&#125; // namespace XSC062</code></pre>\n</details>\n<hr />\n<h3 id=\"b.-反回文串-anti\">B. 反回文串 anti</h3>\n<p><a href=\"http://222.180.160.110:61235/contest/4647/problem/2\" class=\"uri\">http://222.180.160.110:61235/contest/4647/problem/2</a></p>\n<p>当 <span class=\"math inline\">\\(n\\)</span> 为奇时，中间的元素一定和自己相等，故无解。</p>\n<p>当数量最多的一个字符个数超过 <span class=\"math inline\">\\(\\dfrac n2\\)</span> 时，由鸽巢得无解。</p>\n<p>剩下的情况一定有解。</p>\n<details>\n<p><summary>证明</summary></p>\n<p>可以找到一种合法的构造方式。我们列出一个列数为 <span class=\"math inline\">\\(2\\)</span>，行数为 <span class=\"math inline\">\\(\\dfrac n2\\)</span> 的表格，将所有相同字母排列在一起，按照从左到右，从上到下的方式将字母填入表格，最后将第 <span class=\"math inline\">\\(i\\)</span> 行第一列的字母填入 <span class=\"math inline\">\\(a_i\\)</span>，第 <span class=\"math inline\">\\(i\\)</span> 行第二列的字母填入 <span class=\"math inline\">\\(a_{n-i+1}\\)</span>，即可完成构造。</p>\n<p>一种字母只在第一列或第二列出现当然合法，如果从第一列持续到第二列，因为任意字母出现次数不超过 <span class=\"math inline\">\\(\\dfrac n2\\)</span> 次，所以同一行的两列不会出现同一种字母。</p>\n<p>这叫什么，有字证明。</p>\n<p><del>感觉可以拿去出一道类似于「找到字符串字典序最小的反回文串」之类的小水题</del></p>\n</details>\n<p>然后现在我们知道有解了，怎么找到最优解呢。</p>\n<p>比如有一组 <span class=\"math inline\">\\((a_i,a_{n-i+1})=(\\texttt a, \\texttt a)\\)</span>，还有一组 <span class=\"math inline\">\\((a_j, a_{n-j+1})=(\\texttt b, \\texttt b)\\)</span>，那我们直接把 <span class=\"math inline\">\\(a_i\\)</span> 和 <span class=\"math inline\">\\(a_j\\)</span> 交换，皆大欢喜。</p>\n<p>这就说明我们需要把值不相等的非法 <span class=\"math inline\">\\(a_i\\)</span> 与 <span class=\"math inline\">\\(a_j\\)</span> 配对。</p>\n<p>然后我们就可以沿用证明中的构造方式，分组配对，一定最优，每组代价为 <span class=\"math inline\">\\(1\\)</span>。</p>\n<p>同一行两个值 <span class=\"math inline\">\\(v\\)</span> 相等，因为已经最优了，所以不能再在非法串中寻找答案。应该找合法对中某个值交换，每组代价为 <span class=\"math inline\">\\(2\\)</span>。具体和谁交换我们不用担心，只要找到一组 <span class=\"math inline\">\\((a_i,a_{n-i+1})\\)</span> 满足 <span class=\"math inline\">\\(a_i\\ne v\\)</span> 且 <span class=\"math inline\">\\(a_{n-i+1}\\ne v\\)</span> 就可以了，然后我们又知道 <span class=\"math inline\">\\(v\\)</span> 的个数 <span class=\"math inline\">\\(\\ne \\dfrac n2\\)</span>，假设 <span class=\"math inline\">\\(\\dfrac n2\\)</span> 对中每队都有至少一个 <span class=\"math inline\">\\(v\\)</span>，由于当前这一对有两个相同的 <span class=\"math inline\">\\(v\\)</span>，那么 <span class=\"math inline\">\\(v\\)</span> 的个数就会大于 <span class=\"math inline\">\\(\\dfrac n2\\)</span>，矛盾了，所以一定能找到。</p>\n<p>对于非法总对数是奇数的情况，我们要钦定一个非法对强制让其和合法对交换，贪心一下取非法对数量最多的 <span class=\"math inline\">\\(v\\)</span> 的某一对最优。</p>\n<details>\n<pre class=\"cpp\"><code>namespace XSC062 &#123;\nusing namespace fastIO;\nconst int maxm = 35;\nconst int maxn = 2e5 + 5;\nchar s[maxn];\nint cnt[maxm], p[maxn];\nint T, n, tot, res, now;\nint main() &#123;\n    scanf(&quot;%d&quot;, &amp;T);\n    while (T--) &#123;\n        tot = 0;\n        scanf(&quot;%d %s&quot;, &amp;n, s + 1);\n        if (n &amp; 1) &#123;\n            puts(&quot;-1&quot;);\n            continue;\n        &#125;\n        memset(cnt, 0, sizeof (cnt));\n        for (int i = 1; i &lt;= n; ++i)\n            ++cnt[s[i] - &#39;a&#39; + 1];\n        for (int i = 1; i &lt;= 26; ++i) &#123;\n            if (cnt[i] * 2 &gt; n) &#123;\n                puts(&quot;-1&quot;);\n                goto noSol;\n            &#125;\n        &#125;\n        memset(cnt, 0, sizeof (cnt));\n        for (int i = 1; i * 2 &lt;= n; ++i) &#123;\n            if (s[i] == s[n - i + 1])\n                ++cnt[s[i] - &#39;a&#39; + 1], ++tot;\n        &#125;\n        std::sort(cnt + 1, cnt + 27,\n                    std::greater&lt;int&gt;());\n        res = now = 0;\n        if (tot &amp; 1) &#123;\n            res = 1, --cnt[1];\n            std::sort(cnt + 1, cnt + 27,\n                        std::greater&lt;int&gt;());\n        &#125;\n        for (int i = 1; i &lt;= 26; ++i) &#123;\n            while (cnt[i]--) &#123;\n                if (++now &gt; tot / 2) &#123;\n                    if (i == p[now - tot / 2])\n                        res += 2;\n                    else ++res;\n                &#125;\n                else p[now] = i;\n            &#125;\n        &#125;\n        print(res, &#39;\\n&#39;);\n        noSol: ;\n    &#125;\n    return 0;\n&#125;\n&#125; // namespace XSC062</code></pre>\n</details>\n<hr />\n<h3 id=\"c.-除与减-divsub\">C. 除与减 divsub</h3>\n<p><a href=\"http://222.180.160.110:61235/contest/4647/problem/3\" class=\"uri\">http://222.180.160.110:61235/contest/4647/problem/3</a></p>\n<p>小数学，还好。</p>\n<p>假设 <span class=\"math inline\">\\(n=d\\times k^p\\)</span>，其中 <span class=\"math inline\">\\(k\\nmid d\\)</span>，那么我们分两种情况讨论。</p>\n<ol type=\"1\">\n<li><p><span class=\"math inline\">\\(p=0\\)</span>，即 <span class=\"math inline\">\\(k\\nmid n\\)</span>，那么 <span class=\"math inline\">\\(n\\bmod k=1\\)</span>，即 <span class=\"math inline\">\\(k\\mid (n-1)\\)</span>。</p>\n这个时候问 <span class=\"math inline\">\\(k\\)</span> 的个数就相当于是在问 <span class=\"math inline\">\\(n-1\\)</span> 除 <span class=\"math inline\">\\(1\\)</span> 以外的因子个数。假设 <span class=\"math inline\">\\(n-1={x_1}^{p_1}{x_2}^{p_2}\\cdots {x_m}^{p_m}\\)</span>，那么答案为 <span class=\"math inline\">\\((\\prod p_i+1)-1\\)</span>，减去的是 <span class=\"math inline\">\\(1\\)</span>。</li>\n<li><p><span class=\"math inline\">\\(p\\ne 0\\)</span>，<span class=\"math inline\">\\(k\\mid n\\)</span>。</p>\n<p>这个时候好像并没有什么好的转化。好消息是 <span class=\"math inline\">\\(n\\)</span> 的范围是 <span class=\"math inline\">\\(10^{12}\\)</span>，根号枚举因数复杂度跑得过。所以我们就可以暴力判定 <span class=\"math inline\">\\(n\\)</span> 的所有因数是否满足条件。</p></li>\n</ol>\n<p>时间复杂度，<span class=\"math inline\">\\(O(\\sqrt n\\times \\log n)\\)</span>，枚举因数是根号，算次数（也就是算 <span class=\"math inline\">\\(d\\)</span>）是 <span class=\"math inline\">\\(\\log\\)</span>。</p>\n<details>\n<pre class=\"cpp\"><code>#define int long long\nnamespace XSC062 &#123;\nusing namespace fastIO;\nint n, m, res, cnt;\nint main() &#123;\n    read(n), m = n;\n    for (int i = 2; i * i &lt;= n; ++i) &#123;\n        if (n % i == 0) &#123;\n            m = n;\n            while (m % i == 0) m /= i;\n            if (m % i == 1) ++res;\n            if (i * i != n) &#123;\n                m = n;\n                while (m % (n / i) == 0)\n                    m /= (n / i);\n                if (m % (n / i) == 1) ++res;\n            &#125;\n        &#125;\n    &#125;\n    m = n - 1, cnt = 1;\n    for (int i = 2; i * i &lt;= m; ++i) &#123;\n        if (m % i == 0) &#123;\n            int now = 0;\n            while (m % i == 0)\n                ++now, m /= i;\n            cnt *= now + 1;\n        &#125;\n    &#125;\n    if (m != 1) cnt *= 2;\n    print(res + cnt, &#39;\\n&#39;);\n    return 0;\n&#125;\n&#125; // namespace XSC062\n#undef int</code></pre>\n</details>\n<hr />\n<h3 id=\"d.-图书管理员-librarian\">D. 图书管理员 librarian</h3>\n<p><a href=\"http://222.180.160.110:61235/contest/4647/problem/4\" class=\"uri\">http://222.180.160.110:61235/contest/4647/problem/4</a></p>\n<p>[SDOI2008] 郁闷的小 J。</p>\n<p>关于这个，我们发现自己不会考场现冲主席树。哎，打 CDQ 又怕写挂。</p>\n<p>我们发现这道题的修改都是单点的，询问也只关于某一种颜色，不同的颜色之间没有影响。</p>\n<p>于是我们可以把操作离线下来，初始视作将某颜色在某位置增加，修改视作将某颜色在某位置删除，将另一颜色在该位置增加，将所有操作按颜色离散化分类然后 <code>vector</code> 下来，对于所有颜色从前到后树状数组做一遍操作就能 <span class=\"math inline\">\\(O(n\\log n+q\\log n)\\)</span> 解决。</p>\n<p>树状数组清空是肯定不能 <code>memset</code> 的，复杂度不对。那么怎么办呢？把所有操作撤回去就可以了。</p>\n<p>顺带一提我是洛谷上最优解。</p>\n<details>\n<pre class=\"cpp\"><code>namespace XSC062 &#123;\nusing namespace fastIO;\nconst int maxn = 2e5 + 5;\nstruct __ &#123;\n    int ty, l, r, v;\n    __() &#123;&#125;\n    __(int t1, int l1, int r1, int v1 = 0) &#123;\n        if (t1 == 0)\n            ty = 0, l = l1, v = r1;\n        else ty = 1, l = l1, r = r1, v = v1;\n    &#125;\n&#125;;\nchar ty;\nstd::map&lt;int, int&gt; tab;\nstd::vector&lt;__&gt; q[maxn];\nint n, m, tot, x, y, v, id;\nint Bit[maxn], a[maxn], res[maxn];\nint lowbit(int x) &#123; return x &amp; -x; &#125;\nvoid add(int x, int v) &#123;\n    for (; x &lt;= n; x += lowbit(x))\n        Bit[x] += v;\n    return;\n&#125;\nint ask(int x) &#123;\n    int res = 0;\n    for (; x; x -= lowbit(x)) res += Bit[x];\n    return res;\n&#125;\nint main() &#123;\n    read(n), read(m);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        read(a[i]);\n        if (!tab.count(a[i]))\n            tab[a[i]] = ++tot;\n        a[i] = tab[a[i]];\n        q[a[i]].emplace_back(0, i, 1);\n    &#125;\n    while (m--) &#123;\n        scanf(&quot;%1s&quot;, &amp;ty);\n        if (ty == &#39;C&#39;) &#123;\n            read(x), read(y);\n            if (!tab.count(y))\n                tab[y] = ++tot;\n            y = tab[y];\n            q[a[x]].emplace_back(0, x, -1);\n            q[a[x] = y].emplace_back(0, x, 1);\n        &#125;\n        else &#123;\n            ++id;\n            read(x), read(y), read(v);\n            if (!tab.count(v)) continue;\n            v = tab[v];\n            q[v].emplace_back(1, x, y, id);\n        &#125;\n    &#125;\n    for (int i = 1; i &lt;= tot; ++i) &#123;\n        for (auto &amp;j : q[i]) &#123;\n            if (j.ty == 0) add(j.l, j.v);\n            else &#123;\n                res[j.v] =\n                    ask(j.r) - ask(j.l - 1);\n            &#125;\n        &#125;\n        for (auto &amp;j : q[i])\n            if (j.ty == 0) add(j.l, -j.v);\n    &#125;\n    for (int i = 1; i &lt;= id; ++i)\n        print(res[i], &#39;\\n&#39;);\n    return 0;\n&#125;\n&#125; // namespace XSC062</code></pre>\n</details>\n<hr />\n<p>E 会单独开一篇。</p>\n<hr />\n<h3 id=\"f.-树-tree\">F. 树 tree</h3>\n<p><a href=\"http://222.180.160.110:61235/contest/4647/problem/6\" class=\"uri\">http://222.180.160.110:61235/contest/4647/problem/6</a></p>\n<p>CF916E。</p>\n<p>大分讨给我整不会了，更给我整不会的是下来过后发现这只是个小分讨。</p>\n<p>更新子树和子树查询我们都会。换根 DP 我们也都写过，都知道换根并不会对子树结构产生大的影响。所以应当是能根据已知信息推测出子树在原树上对应的点集的。</p>\n<p>记 <span class=\"math inline\">\\(r\\)</span> 为当前树根，<span class=\"math inline\">\\(\\text {LCA}(x,y)\\)</span> 为 <span class=\"math inline\">\\(x,y\\)</span> 在 <span class=\"math inline\">\\(1\\)</span> 为根时的 LCA，<span class=\"math inline\">\\(\\text {LCA}&#39;(x,y)\\)</span> 表示 <span class=\"math inline\">\\(x,y\\)</span> 在 <span class=\"math inline\">\\(r\\)</span> 为根时的 LCA。</p>\n<p>那么对于 <span class=\"math inline\">\\(\\text {LCA}&#39;(x,y)\\)</span>，肯定是要讨论 <span class=\"math inline\">\\(x,y\\)</span> 和 <span class=\"math inline\">\\(r\\)</span> 的位置关系的。</p>\n<ol type=\"1\">\n<li><span class=\"math inline\">\\(\\text {LCA}(x,y)\\)</span> 是 <span class=\"math inline\">\\(r\\)</span> 的子孙。此时 <span class=\"math inline\">\\(\\text {LCA}&#39;(x,y) = \\text {LCA}(x,y)\\)</span>。</li>\n<li><span class=\"math inline\">\\(\\text {LCA}(x,y)\\)</span> 是 <span class=\"math inline\">\\(r\\)</span> 的祖先。那么说明至少有一个点不是 <span class=\"math inline\">\\(r\\)</span> 的子孙。此时 <span class=\"math inline\">\\(\\text {LCA}(x,y)&#39;\\)</span> 的值为 <span class=\"math inline\">\\(r\\)</span> 为另一个点的 LCA。</li>\n</ol>\n<p>整理可得 <span class=\"math inline\">\\(\\text {LCA}&#39;(x,y)\\)</span> 是 <span class=\"math inline\">\\(\\text {LCA}(x,y)\\)</span>、<span class=\"math inline\">\\(\\text {LCA}(x,r)\\)</span> 和 <span class=\"math inline\">\\(\\text {LCA}(y,r)\\)</span> 中的深度最大者。</p>\n<p>对于以 <span class=\"math inline\">\\(r\\)</span> 为根时的子树 <span class=\"math inline\">\\(x\\)</span>：</p>\n<ol type=\"1\">\n<li><span class=\"math inline\">\\(x=r\\)</span>，此时子树为整棵树。</li>\n<li><span class=\"math inline\">\\(\\text {LCA}(x,r)\\ne x\\)</span>，即 <span class=\"math inline\">\\(r\\)</span> 不为 <span class=\"math inline\">\\(x\\)</span> 的子孙，此时子树就是以 <span class=\"math inline\">\\(1\\)</span> 为根是的子树 <span class=\"math inline\">\\(x\\)</span>。</li>\n<li><span class=\"math inline\">\\(\\text {LCA}(x,y)=x\\)</span>，即 <span class=\"math inline\">\\(r\\)</span> 为 <span class=\"math inline\">\\(x\\)</span> 的子孙，此时子树是整棵树除开 <span class=\"math inline\">\\(x\\)</span> 包含 <span class=\"math inline\">\\(r\\)</span> 的儿子及其子孙。修改和查询的时候容斥一下就好。这个时候的子树倍增跳一下就能找到。</li>\n</ol>\n<p>然后就是常规线段树维护了。时间复杂度 <span class=\"math inline\">\\(O(n\\log n)\\)</span>。</p>\n<details>\n<pre class=\"cpp\"><code>namespace XSC062 &#123;\nusing namespace fastIO;\nconst int maxm = 35;\nconst int maxn = 1e5 + 5;\n#define lt (p &lt;&lt; 1)\n#define rt (lt | 1)\nstruct _ &#123; int l, r, u, d; &#125;;\n_ t[maxn &lt;&lt; 2];\nint f[maxn][maxm];\nstd::vector&lt;int&gt; g[maxn];\nint a[maxn], dfn[maxn], rfn[maxn];\nint n, q, r, ty, x, y, v, si, now;\nint top[maxn], dep[maxn], tab[maxn];\nvoid swap(int &amp;x, int &amp;y) &#123;\n    x ^= y ^= x ^= y;\n    return;\n&#125;\nvoid DFS(int x) &#123;\n    dep[x] = dep[f[x][0]] + 1;\n    dfn[x] = ++now, tab[now] = x;\n    for (auto i : g[x]) &#123;\n        if (i == f[x][0]) continue;\n        f[i][0] = x;\n        for (int j = 1; j &lt;= si; ++j)\n            f[i][j] = f[f[i][j - 1]][j - 1];\n        DFS(i);\n    &#125;\n    rfn[x] = now;\n    return;\n&#125;\nvoid pushup(int p) &#123;\n    t[p].u = t[lt].u + t[rt].u;\n    return;\n&#125;\nvoid pushdown(int p) &#123;\n    if (t[p].d) &#123;\n        t[lt].d += t[p].d;\n        t[rt].d += t[p].d;\n        t[lt].u += t[p].d *\n                (t[lt].r - t[lt].l + 1);\n        t[rt].u += t[p].d *\n                (t[rt].r - t[rt].l + 1);\n        t[p].d = 0;\n    &#125;\n    return;\n&#125;\nvoid bld(int p, int l, int r) &#123;\n    t[p].l = l, t[p].r = r;\n    if (l == r) &#123;\n        t[p].u = a[tab[l]];\n        return;\n    &#125;\n    int mid = (l + r) &gt;&gt; 1;\n    bld(lt, l, mid), bld(rt, mid + 1, r);\n    pushup(p);\n    return;\n&#125;\nvoid add(int p, int x, int v) &#123;\n    t[p].u += v;\n    if (t[p].l == t[p].r) return;\n    pushdown(p);\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (x &lt;= mid) add(lt, x, v);\n    else add(rt, x, v);\n    return;\n&#125;\nvoid add(int p, int l, int r, int v) &#123;\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r) &#123;\n        t[p].d += v;\n        t[p].u += (t[p].r - t[p].l + 1) * v;\n        return;\n    &#125;\n    pushdown(p);\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (l &lt;= mid) add(lt, l, r, v);\n    if (r &gt; mid) add(rt, l, r, v);\n    pushup(p);\n    return;\n&#125;\nint ask(int p, int l, int r) &#123;\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r)\n        return t[p].u;\n    pushdown(p);\n    int res = 0,\n        mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (l &lt;= mid) res = ask(lt, l, r);\n    if (r &gt; mid) res += ask(rt, l, r);\n    return res;\n&#125;\nint LCA(int x, int y) &#123;\n    if (dep[x] &lt; dep[y]) swap(x, y);\n    for (int i = si; ~i; --i) &#123;\n        if (dep[f[x][i]] &gt;= dep[y])\n            x = f[x][i];\n    &#125;\n    if (x == y) return x;\n    for (int i = si; ~i; --i) &#123;\n        if (f[x][i] != f[y][i])\n            x = f[x][i], y = f[y][i];\n    &#125;\n    return f[x][0];\n&#125;\nvoid Add(int x, int v) &#123;\n    int rlca = LCA(r, x);\n    if (x == r) add(1, 1, n, v);\n    else if (rlca != x)\n        add(1, dfn[x], rfn[x], v);\n    else &#123;\n        add(1, 1, n, v);\n        int p = r;\n        for (int i = si; ~i; --i) &#123;\n            if (dep[f[p][i]] &gt;= dep[x] + 1)\n                p = f[p][i];\n        &#125;\n        add(1, dfn[p], rfn[p], -v);\n    &#125;\n    return;\n&#125;\nvoid tAdd(int x, int y, int v) &#123;\n    int llca = LCA(r, x), rlca = LCA(r, y),\n        ulca = LCA(x, y);\n    if (dep[llca] &gt;= dep[rlca] &amp;&amp;\n        dep[llca] &gt;= dep[ulca]) Add(llca, v);\n    else if (dep[rlca] &gt;= dep[llca] &amp;&amp;\n        dep[rlca] &gt;= dep[ulca]) Add(rlca, v);\n    else Add(ulca, v);\n    return;\n&#125;\nint tAsk(int x) &#123;\n    int rlca = LCA(r, x);\n    if (x == r) return t[1].u;\n    if (rlca != x)\n        return ask(1, dfn[x], rfn[x]);\n    int p = r;\n    for (int i = si; ~i; --i) &#123;\n        if (dep[f[p][i]] &gt;= dep[x] + 1)\n            p = f[p][i];\n    &#125;\n    return t[1].u - ask(1, dfn[p], rfn[p]);\n&#125;\nvoid add(int x, int y) &#123;\n    g[x].push_back(y);\n    return;\n&#125;\nint main() &#123;\n    read(n), read(q), r = 1;\n    si = log(n) / log(2.0);\n    for (int i = 1; i &lt;= n; ++i) read(a[i]);\n    for (int i = 1; i &lt; n; ++i) &#123;\n        read(x), read(y);\n        add(x, y), add(y, x);\n    &#125;\n    dep[0] = 1, DFS(1), dep[0] = 0;\n    bld(1, 1, n);\n    while (q--) &#123;\n        read(ty);\n        if (ty == 1) read(r);\n        else if (ty == 2) &#123;\n            read(x), read(y), read(v);\n            tAdd(x, y, v);\n        &#125;\n        else &#123;\n            read(x);\n            print(tAsk(x), &#39;\\n&#39;);\n        &#125;\n    &#125;\n    return 0;\n&#125;\n&#125; // namespace XSC062\n#undef int</code></pre>\n</details>\n",
            "tags": [
                "线段树",
                "树状数组",
                "LCA",
                "倍增",
                "鸽巢原理"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20231003/",
            "url": "https://xsc062.netlify.app/20231003/",
            "title": "杂题",
            "date_published": "2023-10-03T08:42:43.000Z",
            "content_html": "<p><a href=\"http://222.180.160.110:61235/contest/4268\">周考 14</a>。</p>\n<span id=\"more\"></span>\n<hr />\n<p>医生问我对药有什么要求吗，我说我宁死不喝冲剂。</p>\n<p>然后医生给我开了五盒胶囊，告诉我说一天三次，一次六个。</p>\n<p>哈哈哈，我自找的。以此为证，A 一道题磕一片！！！</p>\n<hr />\n<h3 id=\"a.-修改序列\">A. 修改序列</h3>\n<p><a href=\"http://222.180.160.110:61235/contest/4268/problem/1\" class=\"uri\">http://222.180.160.110:61235/contest/4268/problem/1</a></p>\n<p>注意到一增一减，全数列的和 <span class=\"math inline\">\\(s\\)</span> 不变，考虑这一点带来的提示。</p>\n<p>假设最后要求一部分数为 <span class=\"math inline\">\\(p\\)</span>，另一部分为 <span class=\"math inline\">\\(p+1\\)</span>，那么有 <span class=\"math inline\">\\(p = \\lfloor \\dfrac sn \\rfloor\\)</span>，<span class=\"math inline\">\\(p+1\\)</span> 的数量 <span class=\"math inline\">\\(c_r=s\\bmod n\\)</span>，<span class=\"math inline\">\\(p\\)</span> 的数量 <span class=\"math inline\">\\(c_l=n-c_r\\)</span>。</p>\n<p>那么我们让 <span class=\"math inline\">\\(\\le p\\)</span> 的变成 <span class=\"math inline\">\\(p\\)</span>，<span class=\"math inline\">\\(\\ge p + 1\\)</span> 的变成 <span class=\"math inline\">\\(p + 1\\)</span>。直接求两数距离，最后将总和除以二即为答案、</p>\n<details>\n<p><summary>正确性证明…</summary></p>\n<p>这样做的最优性毫无疑问，问题无非就在于这么做的正确性，换言之，为什么一定能找到合法的操作序列还原我们的求解过程。</p>\n<p>将原数列分为两部分，数值 <span class=\"math inline\">\\(\\le p\\)</span> 的（记为 <span class=\"math inline\">\\(X\\)</span>）和数值 <span class=\"math inline\">\\(\\ge p + 1\\)</span> 的（记为 <span class=\"math inline\">\\(Y\\)</span>）。</p>\n<p>再把我们的目标状态分为两部分，数值 <span class=\"math inline\">\\(= p\\)</span> 的（记为 <span class=\"math inline\">\\(A\\)</span>）和 数值 <span class=\"math inline\">\\(=p + 1\\)</span> 的（记为 <span class=\"math inline\">\\(B\\)</span>）。</p>\n<p>那么有 <span class=\"math inline\">\\(\\begin{cases}X+Y=s\\\\A+B=s\\end{cases}\\)</span>，由等式的基本性质得 <span class=\"math inline\">\\(X-A+Y-B = 0\\)</span>，移项得 <span class=\"math inline\">\\(Y-B=A-X\\)</span>。也就是说，<span class=\"math inline\">\\(Y\\)</span> 部分与 <span class=\"math inline\">\\(p+1\\)</span> 的差的总和正好等于 <span class=\"math inline\">\\(X\\)</span> 部分与 <span class=\"math inline\">\\(p\\)</span> 的差的总和。</p>\n<p>这个时候我们的正确性就有了保证。</p>\n<p>这个时候你可能就有疑问了，<span class=\"math inline\">\\(X,Y\\)</span> 中的元素个数和 <span class=\"math inline\">\\(A,B\\)</span> 中的元素个数并不对应，怎么办呢？</p>\n<p>我们发现上面的原理式并不会随元素个数的变化而变化，所以依然可以用它来解答这个问题。没有人规定 <span class=\"math inline\">\\(Y-B\\)</span> 和 <span class=\"math inline\">\\(A-X\\)</span> 不能为负，为负时我们把 <span class=\"math inline\">\\(A\\)</span> 中塞不下的 <span class=\"math inline\">\\(X\\)</span> 拿到 <span class=\"math inline\">\\(B\\)</span> 里面去即可，反之同理。</p>\n</details>\n<p>那么代码还是很好写的。时间复杂度 <span class=\"math inline\">\\(O(n)\\)</span>。</p>\n<details>\n<pre class=\"cpp\"><code>namespace XSC062 &#123;\nusing namespace fastIO;\nconst int maxn = 2e5 + 5;\nint a[maxn];\nint n, s, p, cl, cg, res;\nint main() &#123;\n    read(n);\n    for (int i = 1; i &lt;= n; ++i)\n        read(a[i]), s += a[i];\n    p = s / n, cg = s - p * n, cl = n - cg;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        if (a[i] &lt;= p) &#123;\n            if (cl) res += p - a[i], --cl;\n            else res += p - a[i] + 1, --cg;\n        &#125;\n        else &#123;\n            if (cg) res += a[i] - p - 1, --cg;\n            else res += a[i] - p, --cl;\n        &#125;\n    &#125;\n    print(res / 2, &#39;\\n&#39;);\n    return 0;\n&#125;\n&#125; // namespace XSC062</code></pre>\n</details>\n<hr />\n<h3 id=\"b.-knuth-表示法\">B. Knuth 表示法</h3>\n<p><a href=\"http://222.180.160.110:61235/contest/4268/problem/2\" class=\"uri\">http://222.180.160.110:61235/contest/4268/problem/2</a></p>\n<p>模拟。输入的数用 <code>map</code> 转化为 <span class=\"math inline\">\\(10\\)</span> 的次幂形式，然后幂次直接相加即表示指数相乘。</p>\n<p>最后按位数从大到小将次幂形式转化为字符串、再按位数从小到大输出。</p>\n<p>注意到开头的字符串不是 <code>one</code> 就是 <code>ten</code>，需要在没有抽出来 <code>ten</code> 的时候补 <code>one</code>。</p>\n<details>\n<pre class=\"cpp\"><code>namespace XSC062 &#123;\nusing namespace fastIO;\nusing str = std::string;\nconst str u[] = &#123; &quot;one&quot;, &quot;ten&quot;, &quot;hundred&quot;, &quot;myriad&quot;, &quot;myllion&quot;, &quot;byllion&quot;, &quot;tryllion&quot;,\n                  &quot;quadryllion&quot;, &quot;quintyllion&quot;, &quot;sextyllion&quot;, &quot;septyllion&quot;, &quot;octyllion&quot;,\n                  &quot;nonyllion&quot;, &quot;decyllion&quot; &#125;;\nstr x;\nint res = 0;\nstd::stack&lt;str&gt; s;\nstd::map&lt;str, int&gt; t;\nvoid get(str &amp;x) &#123;\n    str y;\n    std::stringstream p(x);\n    while (p &gt;&gt; y) &#123;\n        if (y == &quot;one&quot;) continue;\n        res += 1 &lt;&lt; (t[y] - 1);\n    &#125;\n    return;\n&#125;\nint main() &#123;\n    for (int i = 0; i &lt;= 13; ++i) t[u[i]] = i;\n    std::getline(std::cin, x), get(x);\n    std::getline(std::cin, x), get(x);\n    for (int i = 13; i; --i) &#123;\n        if (res &amp; (1 &lt;&lt; (i - 1)))\n            s.push(u[i]), res ^= (1 &lt;&lt; (i - 1));\n    &#125;\n    if (s.top() != &quot;ten&quot;) s.push(&quot;one&quot;);\n    while (!s.empty())\n        std::cout &lt;&lt; s.top() &lt;&lt; &#39; &#39;, s.pop();\n    return 0;\n&#125;\n&#125; // namespace XSC062</code></pre>\n</details>\n<hr />\n<h3 id=\"c.-魔力塔\">C. 魔力塔</h3>\n<p><a href=\"http://222.180.160.110:61235/contest/4268/problem/3\" class=\"uri\">http://222.180.160.110:61235/contest/4268/problem/3</a></p>\n<p>神奇的线段树优化建图。这拿来放 T3？不合适吧。</p>\n<p>很好想到对于 <span class=\"math inline\">\\(a_i\\ne -1\\)</span>，连边 <span class=\"math inline\">\\(i\\to a_i\\)</span>；否则，连边 <span class=\"math inline\">\\(i\\to x(x\\in [i+1,\\min(i + k,n+1)])\\)</span>。BFS 遍历，复杂度 <span class=\"math inline\">\\(O(n\\times k)\\)</span>。</p>\n<p>问题在于无用边太多，例如 <span class=\"math inline\">\\(i\\)</span> 和 <span class=\"math inline\">\\(i+1\\)</span> 共同可达的点有整整 <span class=\"math inline\">\\(k-1\\)</span> 个，造成大量浪费。</p>\n<p>考虑到实际进入 BFS 的点只有 <span class=\"math inline\">\\(n\\)</span> 个，及由传送门构成的连通块均呈棒棒糖状（即链套环），我们直接优化掉 <span class=\"math inline\">\\(a_i=-1\\)</span> 时的连边。使用线段树查询 <span class=\"math inline\">\\([i+1,\\min(i + k,n+1)]\\)</span> 内的所有剩余点，连边入队并从线段树中删除。</p>\n<p>这样，每个点只会入队一次（忽视无用环），时间复杂度控制在 <span class=\"math inline\">\\(O(n\\log n)\\)</span>，<span class=\"math inline\">\\(\\log\\)</span> 来源于线段树，写得不好就是 <span class=\"math inline\">\\(\\log^2\\)</span>，写得好一点就只有一个。</p>\n<details>\n<p><summary>然而…</summary></p>\n<p>会 T，因为常数太大了。</p>\n<p>所以我们需要另一种 <span class=\"math inline\">\\(\\log\\)</span> 的做法，并且短小精悍。</p>\n<p>用 <code>set</code> 存储所有未入队的点，每次 <code>lower_bound</code> 并依次弹出、入队。</p>\n</details>\n<p>用迭代器的话代码很短，美汁汁。</p>\n<p>时间复杂度 <span class=\"math inline\">\\(O(n\\log n)\\)</span>，但等我先磕片药先。</p>\n<details>\n<pre class=\"cpp\"><code>namespace XSC062 &#123;\nusing namespace fastIO;\nconst int maxn = 5e5 + 5;\nint a[maxn];\nint n, k, res;\nbool vis[maxn];\nstd::set&lt;int&gt; t;\nstd::vector&lt;int&gt; g[maxn]; \nint max(int x, int y) &#123; return x &gt; y ? x : y; &#125;\nvoid DFS(int x) &#123;\n    res = max(res, x);\n    if (a[x] == -1) &#123;\n        auto p = t.lower_bound(x + 1);\n        while (p != t.end() &amp;&amp; *p &lt;= x + k) &#123;\n            g[x].push_back(*p);\n            t.erase(*p++);\n        &#125;\n    &#125;\n    for (auto i : g[x]) &#123;\n        if (vis[i]) continue;\n        vis[i] = 1, DFS(i);\n    &#125;\n    return;\n&#125;\nint main() &#123;\n    read(n), read(k);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        read(a[i]), t.insert(i + 1);\n        if (~a[i]) g[i].push_back(a[i]);\n    &#125;\n    DFS(1), print(res, &#39;\\n&#39;);\n    return 0;\n&#125;\n&#125; // namespace XSC062</code></pre>\n</details>\n<hr />\n<h3 id=\"d.-卡牌游戏\">D. 卡牌游戏</h3>\n<p><a href=\"http://222.180.160.110:61235/contest/4268/problem/4\" class=\"uri\">http://222.180.160.110:61235/contest/4268/problem/4</a></p>\n<p>怎么说呢，爆搜可以拿 80pts！！！然而正解是区间 DP，哭唧唧。他这个数据范围给得很神奇，让人只会往搜索上面想。</p>\n<p>摧毁操作是一换一，不会更改串长，而入栈操作会增加初始串的长度。</p>\n<p>所以我们考虑 <strong>逆序 DP</strong>，从最终状态入手，用 <span class=\"math inline\">\\(f_{x, i, j}\\)</span> 表示是否可以使用一个字符 <span class=\"math inline\">\\(x\\)</span> 经过一系列操作消掉 <span class=\"math inline\">\\(w_{i\\sim j}\\)</span>。</p>\n<p>那么明显若一条摧毁操作为可用字符 <span class=\"math inline\">\\(a\\)</span> 摧毁 <span class=\"math inline\">\\(w_i\\)</span>，有 <span class=\"math inline\">\\(f_{a, i, i} = 1\\)</span>。</p>\n<p>若一条入栈操作为用字符 <span class=\"math inline\">\\(a\\)</span> 换字符 <span class=\"math inline\">\\(b,c\\)</span>，枚举区间断点 <span class=\"math inline\">\\(k\\)</span>，有 <span class=\"math inline\">\\(f_{a, i, j} = f_{b, i, k} \\times f_{c, k + 1, j}\\)</span>。</p>\n<p>最后答案为 <span class=\"math inline\">\\(f_{\\texttt S,i,|w_i|}\\)</span>。</p>\n<p>注意循环顺序，区间的枚举应在字符的枚举之外。最终时间复杂度 <span class=\"math inline\">\\(O(T\\times |w_i|^3\\times N_2)\\)</span>，注意到字母的枚举属于常数。胶囊好吃滴捏。</p>\n<details>\n<pre class=\"cpp\"><code>namespace XSC062 &#123;\nusing namespace fastIO;\nconst int maxn = 25;\nconst int maxm = 1e3 + 5;\nint n, m, l;\nchar w[maxn];\nbool r1[maxm][maxm];\nbool f[maxm][maxn][maxn];\nstruct &#123; int u, a, b; &#125; r2[maxn];\nint main() &#123;\n    scanf(&quot;%d %d&quot;, &amp;n, &amp;m);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        scanf(&quot;%s&quot;, w + 1);\n        r1[(int)w[1]][(int)w[4]] = 1;\n    &#125;\n    for (int i = 1; i &lt;= m; ++i) &#123;\n        scanf(&quot;%s&quot;, w + 1);\n        r2[i].u = w[1];\n        r2[i].a = w[4], r2[i].b = w[5];\n    &#125;\n    while (~scanf(&quot;%s&quot;, w + 1)) &#123;\n        memset(f, 0, sizeof (f));\n        l = strlen(w + 1);\n        for (int i = &#39;A&#39;; i &lt;= &#39;Z&#39;; ++i) &#123;\n            for (int j = 1; j &lt;= l; ++j) &#123;\n                if (r1[i][(int)w[j]])\n                    f[i][j][j] = 1;\n            &#125;\n        &#125;\n        for (int len = 1; len &lt;= l; ++len) &#123;\n            for (int i = 1; i &lt;= l - len + 1; ++i) &#123;\n                int j = i + len - 1;\n                for (int t = &#39;A&#39;; t &lt;= &#39;Z&#39;; ++t) &#123;\n                    for (int k = i; k &lt; j; ++k) &#123;\n                        for (int p = 1; p &lt;= m; ++p) &#123;\n                            if (r2[p].u != t) continue;\n                            f[t][i][j] |= f[r2[p].a][i][k] &amp;&amp; f[r2[p].b][k + 1][j];\n                        &#125;\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n        puts(f[&#39;S&#39;][1][l] ? &quot;YES&quot; : &quot;NO&quot;);\n    &#125;\n    return 0;\n&#125;\n&#125; // namespace XSC062</code></pre>\n</details>\n<hr />\n<h3 id=\"e.-生长树\">E. 生长树</h3>\n<p><a href=\"http://222.180.160.110:61235/contest/4268/problem/5\" class=\"uri\">http://222.180.160.110:61235/contest/4268/problem/5</a></p>\n<p>一道很菜的题。我们发现有子树操作，第一时间想到树剖，那么接下来要考虑的内容就是线段树如何维护。</p>\n<p>题意换句话说就是往下数 0 代是加，数 1 代是减，数 2 代是加，以此类推。那么不难想到奇偶性。</p>\n<p>如果起点的深度是奇数，那么子树中所有奇数深度权值增加，偶数深度权值减少，反之同理。</p>\n<p>但是我们操作线段树的时候怎么知道点在树中的深度奇偶性呢？我们只能在线段树外才知道呀。</p>\n<p>所以观察询问，询问是单点的，所以我们知道了，可以只在线段树外对奇偶性进行处理。简单来说，假设更改起点深度为奇数，那么增加整个子树的「奇加偶减计数器」；反之，增加整个子树的「奇减偶加计数器」。</p>\n<p>最后查询的时候，如果该点深度为奇，那么答案为对应的「奇加偶减计数器」减去「奇减偶加计数器」的值，反之同理。</p>\n<p>做到最后发现根本不用树剖，就是一个 DFN 上线段树。时间复杂度 <span class=\"math inline\">\\(O(m\\log n)\\)</span>。</p>\n<p>胶囊真好吃！！！</p>\n<details>\n<pre class=\"cpp\"><code>namespace XSC062 &#123;\nusing namespace fastIO;\n#define lt (p &lt;&lt; 1)\n#define rt (lt | 1)\nconst int maxn = 2e5 + 5;\nstruct _ &#123;\n    int l, r;\n    int u1, u2, d1, d2;\n&#125;; \n_ t[maxn &lt;&lt; 2];\nint a[maxn], dep[maxn];\nstd::vector&lt;int&gt; g[maxn];\nint n, m, x, y, tot, typ;\nint end[maxn], dfn[maxn], tab[maxn];\n// u 只用维护最底层信息\n// 所以不用打 pushup \n// 但维护起来好看一些 所以还是打了\nvoid pushup(int p) &#123;\n    t[p].u1 = t[lt].u1 + t[rt].u1;\n    t[p].u2 = t[lt].u2 + t[rt].u2;\n    return;\n&#125;\nvoid pushdown(int p) &#123;\n    if (t[p].d1) &#123;\n        t[lt].d1 += t[p].d1;\n        t[rt].d1 += t[p].d1;\n        t[lt].u1 += t[p].d1 * (t[lt].r - t[lt].l + 1);\n        t[rt].u1 += t[p].d1 * (t[rt].r - t[rt].l + 1);\n        t[p].d1 = 0;\n    &#125;\n    if (t[p].d2) &#123;\n        t[lt].d2 += t[p].d2;\n        t[rt].d2 += t[p].d2;\n        t[lt].u2 += t[p].d2 * (t[lt].r - t[lt].l + 1);\n        t[rt].u2 += t[p].d2 * (t[rt].r - t[rt].l + 1);\n        t[p].d2 = 0;\n    &#125;\n    return;\n&#125;\nvoid bld(int p, int l, int r) &#123;\n    t[p].l = l, t[p].r = r;\n    if (l == r) &#123;\n        if (dep[tab[l]] &amp; 1)\n            t[p].u1 = a[tab[l]];\n        else t[p].u2 = a[tab[l]];\n        return;\n    &#125;\n    int mid = (l + r) &gt;&gt; 1;\n    bld(lt, l, mid), bld(rt, mid + 1, r);\n    pushup(p);\n    return;\n&#125;\nvoid add1(int p, int l, int r, int x) &#123;\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r) &#123;\n        t[p].d1 += x;\n        t[p].u1 += (t[p].r - t[p].l + 1) * x;\n        return;\n    &#125;\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    pushdown(p);\n    if (l &lt;= mid) add1(lt, l, r, x);\n    if (r &gt; mid) add1(rt, l, r, x);\n    pushup(p);\n    return;\n&#125;\nvoid add2(int p, int l, int r, int x) &#123;\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r) &#123;\n        t[p].d2 += x;\n        t[p].u2 += (t[p].r - t[p].l + 1) * x;\n        return;\n    &#125;\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    pushdown(p);\n    if (l &lt;= mid) add2(lt, l, r, x);\n    if (r &gt; mid) add2(rt, l, r, x);\n    pushup(p);\n    return;\n&#125;\nint ask(int p, int x) &#123;\n    if (t[p].l == t[p].r)\n        return t[p].u1 - t[p].u2;\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    pushdown(p);\n    if (x &lt;= mid) return ask(lt, x);\n    return ask(rt, x);\n&#125;\nvoid DFS(int x, int fa) &#123;\n    dfn[x] = ++tot, tab[tot] = x;\n    for (auto i : g[x]) &#123;\n        if (i == fa) continue;\n        dep[i] = dep[x] + 1;\n        DFS(i, x);\n    &#125;\n    end[x] = tot;\n    return;\n&#125;\nvoid add(int x, int y) &#123;\n    g[x].push_back(y);\n    return;\n&#125;\nint main() &#123;\n    read(n), read(m);\n    for (int i = 1; i &lt;= n; ++i)\n        read(a[i]);\n    for (int i = 1; i &lt; n; ++i) &#123;\n        read(x), read(y);\n        add(x, y), add(y, x);\n    &#125;\n    dep[1] = 1, DFS(1, -1);\n    bld(1, 1, n);\n    while (m--) &#123;\n        read(typ), read(x);\n        if (typ == 1) &#123;\n            read(y);\n            if (dep[x] &amp; 1)\n                add1(1, dfn[x], end[x], y);\n            else add2(1, dfn[x], end[x], y);\n        &#125;\n        else &#123;\n            int res = ask(1, dfn[x]);\n            if (dep[x] &amp; 1)\n                print(res, &#39;\\n&#39;);\n            else print(-res, &#39;\\n&#39;);\n        &#125;\n    &#125;\n    return 0;\n&#125;\n&#125; // namespace XSC062</code></pre>\n</details>\n<hr />\n<h3 id=\"f.-单词\">F. 单词</h3>\n<p><a href=\"http://222.180.160.110:61235/contest/4268/problem/6\" class=\"uri\">http://222.180.160.110:61235/contest/4268/problem/6</a></p>\n<p><span class=\"math inline\">\\(n \\le 20\\)</span>，考虑状压。用 <span class=\"math inline\">\\(f_x\\)</span> 表示状态为 <span class=\"math inline\">\\(x\\)</span> 时的最小代价，其中 <span class=\"math inline\">\\(x\\)</span> 是字符串合法情况的状态压缩。</p>\n<p>对于每一个待满足的串，枚举去满足它的哪一位，那么满足方式分两种情况：</p>\n<ul>\n<li>把它变成一个新的值</li>\n<li><p>把和它重合的变成新的值</p>\n<p>我们注意到 <span class=\"math inline\">\\(n \\le 20 \\le 26\\)</span>，所以一定能找到一种方法让每个串的这一位都不一样。</p>\n<p>接着，反正我们都要改这一位了，那就贪心地把要改的全部改成完全不一样的。那么这些要改的串也在这一位上满足了条件。</p></li>\n</ul>\n<p>所以，假设对于状态 <span class=\"math inline\">\\(i\\)</span>，有串 <span class=\"math inline\">\\(j\\)</span> 未满足，枚举位置 <span class=\"math inline\">\\(k\\)</span>，有：</p>\n<pre class=\"cpp\"><code>f[i | (1 &lt;&lt; (j - 1))] = min(f[i | (1 &lt;&lt; (j - 1))], f[i] + a[j][k]); \nf[i | lac[j][k]] = min(f[i | lac[j][k]], f[i] + mx[j][k]);</code></pre>\n<p>其中 <code>lac[j][k]</code> 和 <code>mx[j][k]</code> 都是预处理出来的值。<code>lac[j][k]</code> 表示与第 <span class=\"math inline\">\\(j\\)</span> 个串的第 <span class=\"math inline\">\\(k\\)</span> 位相同串的状态压缩；<code>mx[j][k]</code> 表示通过第二种方式将 <span class=\"math inline\">\\(j\\)</span> 串的第 <span class=\"math inline\">\\(k\\)</span> 位变得合法的最小费用。</p>\n<p><code>lac[j][k]</code> 的求法没有任何疑问，主要是在 <code>mx[j][k]</code> 上。注意到假设这一位上有 <span class=\"math inline\">\\(x\\)</span> 个串与 <span class=\"math inline\">\\(j\\)</span> 串的第 <span class=\"math inline\">\\(k\\)</span> 位相同（包括其本身），而我们只需要将这当中的 <span class=\"math inline\">\\(x-1\\)</span> 个变成两两不同的全新字符就可以同时满足这 <span class=\"math inline\">\\(x\\)</span> 串的条件，那我们为什么不把不动的这一个串设置为 <span class=\"math inline\">\\(x\\)</span> 个串中改这一位代价最大的那个呢？</p>\n<p>那么问题来了。我们枚举状态、枚举状态中的每一个 <code>0</code>，枚举每一个串的每一位，实际上是 <span class=\"math inline\">\\(O(n\\times m\\times 2^n)\\)</span> 的。虽然跑不满，但这个时间复杂度仍然是有问题的。我们需要优化。</p>\n<p>我们枚举的是状态中的每一个 <code>0</code>，假设我们的状态是 <code>000</code>，我们的解决方案是将三个 <code>0</code> 位置的方案共同处理，表示为 <code>'0--'</code> + <code>'-0-'</code> + <code>'--0'</code>。但实际上，我们只用实际求解一个 <code>0</code> 位置的答案，表示为 <code>'0--'</code> + <code>'-00'</code> 。</p>\n<p>也就是说，我们原本需要枚举每一个状态为 <code>0</code> 的 <span class=\"math inline\">\\(j\\)</span> 并用 <span class=\"math inline\">\\(O(m)\\)</span> 的时间进行计算，现在我们碰到一个状态为 <code>0</code> 的 <span class=\"math inline\">\\(j\\)</span> 就开始计算，得到完全相同的答案。</p>\n<p>很 NB 并且很实用的优化，已加入 <a href=\"/20231117/\">下饭操作合集</a>。</p>\n<details>\n<pre class=\"cpp\"><code>namespace XSC062 &#123;\nusing namespace fastIO;\nconst int maxn = 205;\nconst int maxm = (1 &lt;&lt; 25) + 5;\nint f[maxm];\nint n, m, siz;\nchar s[maxn][maxn];\nint lac[maxn][maxn];\nint a[maxn][maxn], mx[maxn][maxn];\nint min(int x, int y) &#123; return x &lt; y ? x : y; &#125;\nint max(int x, int y) &#123; return x &gt; y ? x : y; &#125;\nint main() &#123;\n    while(~scanf(&quot;%d %d&quot;, &amp;n, &amp;m)) &#123;\n        memset(f, 0x3f, sizeof (f));\n        f[0] = 0, siz = 1 &lt;&lt; n;\n        for (int i = 1; i &lt;= n; ++i)\n            scanf(&quot;%s&quot;, s[i] + 1);\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            for (int j = 1; j &lt;= m; ++j)\n                scanf(&quot;%d&quot;, &amp;a[i][j]);\n        &#125;\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            for (int j = 1; j &lt;= m; ++j) &#123;\n                int sum = 0;\n                lac[i][j] = mx[i][j] = 0;\n                for (int k = 1; k &lt;= n; ++k) &#123;\n                    if (s[k][j] == s[i][j]) &#123;\n                        lac[i][j] |= 1 &lt;&lt; (k - 1);\n                        sum += a[k][j];\n                        mx[i][j] = max(mx[i][j], a[k][j]);\n                    &#125;\n                &#125;\n                mx[i][j] = sum - mx[i][j];\n            &#125;\n        &#125;\n        for (int i = 0, j; i &lt; siz - 1; ++i) &#123;\n            for (j = 1; j &lt;= n; ++j) &#123;\n                if (!(i &amp; (1 &lt;&lt; (j - 1))))\n                    break;\n            &#125;\n            for (int k = 1; k &lt;= m; ++k) &#123;\n                f[i | (1 &lt;&lt; (j - 1))] =\n                    min(f[i | (1 &lt;&lt; (j - 1))], f[i] + a[j][k]); \n                f[i | lac[j][k]] =\n                    min(f[i | lac[j][k]], f[i] + mx[j][k]);\n            &#125;\n        &#125;\n        print(f[siz - 1], &#39;\\n&#39;);\n    &#125;\n    return 0;\n&#125;\n&#125; // namespace XSC062</code></pre>\n</details>\n<hr />\n<p>这次暴露出的问题：</p>\n<ul>\n<li>深度乱求，打代码的时候考虑过要放在递归之前，但是由于精力不集中最后还是放在了递归后面。</li>\n</ul>\n<p>没了。这次主要问题出在 T5。T3 估计真的想不到，先不强求自己。</p>\n<p>这次学到的新知识：</p>\n<ul>\n<li>对于子集合并最优性的问题，可以用单点 + 集合代替集合 + 集合枚举。</li>\n</ul>\n",
            "tags": [
                "DP",
                "线段树"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20230928/",
            "url": "https://xsc062.netlify.app/20230928/",
            "title": "颜色",
            "date_published": "2023-09-28T08:44:30.000Z",
            "content_html": "<p>Solution to <a href=\"https://vjudge.net/contest/583230#problem/B\">颜色</a>。</p>\n<span id=\"more\"></span>\n<hr />\n<h3 id=\"b---颜色\">B - 颜色</h3>\n<p><a href=\"https://vjudge.net/contest/583230#problem/B\" class=\"uri\">https://vjudge.net/contest/583230#problem/B</a></p>\n<p>颜色删完过后剩下的肯定是一段区间。</p>\n<p>那么区间外的所有颜色都会被删掉，如果要满足题目条件的话，删掉的颜色不能出现在区间内。</p>\n<p>那么就可以有这么一个题意的转化：寻找区间的个数，满足区间内的颜色只出现在区间内。</p>\n<p>然后你可能就要问了，不是还要满足区间外的所有颜色都不出现在区间内吗。但是你想想，要是它出现在区间内了，它作为区间内的颜色，不就不满足我们上面说的那条规则了吗。</p>\n<p>这个转化是非常厉害的。那么这个时候有一个显而易见暴力做法，我们记录一个颜色在整个序列中出现的第一个位置（记为 <span class=\"math inline\">\\(L_x\\)</span>）和最后一个位置（记作 <span class=\"math inline\">\\(R_x\\)</span>），然后枚举每一个区间 <span class=\"math inline\">\\([i, j]\\)</span>，再枚举其中的每一个颜色，看看有没有超出去就好，复杂度 <span class=\"math inline\">\\(O(n^3)\\)</span>。</p>\n<details>\n<summary>对纯暴力的一点小优化</summary> 上述区间内枚举过程转化为判定区间是否满足 <span class=\"math inline\">\\({L_x}_{\\min} \\ge i\\)</span> 且 <span class=\"math inline\">\\({R_x}_{\\max} \\le j\\)</span>，采用数据结构维护，就可以优化到 <span class=\"math inline\">\\(O(n^2\\log)\\)</span>。为什么要专门提一嘴这个呢，因为这个模型我没想到。我真 NB。\n</details>\n<p>接下来又是一个我想不到的模型。我们发现复杂度瓶颈出在枚举区间上，所以考虑通过固定区间右端点，用较小的复杂度直接求解满足条件的左端点数量来解决问题。为什么不是固定左端点呢？</p>\n<p>「因为题解都是写的固定右端点。」 0# 如是说。</p>\n<p>对于正在枚举的右端点 <span class=\"math inline\">\\(j\\)</span> 右边的颜色 <span class=\"math inline\">\\(x\\)</span>，我们记录它们上一次出现的位置 <span class=\"math inline\">\\(p_x\\)</span>，并用线段树找到范围内最右值 <span class=\"math inline\">\\((p_x)_{\\max}\\)</span>，那么左端点 <span class=\"math inline\">\\(i&gt;(p_x)_{\\max}\\)</span>。取 <span class=\"math inline\">\\(i&#39;=(p_x)_{\\max}+1\\)</span>，这样我们就初步得到了一个 <span class=\"math inline\">\\([i&#39;, j]\\)</span>。相对于纯暴力的做法，<span class=\"math inline\">\\(R_x\\le j\\)</span> 的等价条件已经满足，但还有一个条件，就是 <span class=\"math inline\">\\(L_x\\)</span> 不能小于 <span class=\"math inline\">\\(i\\)</span>。</p>\n<p>为了方便数据结构维护 <span class=\"math inline\">\\(p_x\\)</span>，我们逆序枚举 <span class=\"math inline\">\\(j\\)</span>，这样又可以得到一个性质：<span class=\"math inline\">\\(i&#39;\\)</span> 单调不降。这个时候我们逆向思维，处理出对于每个 <span class=\"math inline\">\\(i\\ge i&#39;\\)</span>，其能够到的最远的 <span class=\"math inline\">\\(j\\)</span>，记为 <span class=\"math inline\">\\(f_i\\)</span>，那么我们对于 <span class=\"math inline\">\\(f_i\\)</span> 建一个权值线段树，然后在枚举过程中查询权值在 <span class=\"math inline\">\\([j, +\\infty)\\)</span> 的 <span class=\"math inline\">\\(i\\)</span> 的个数就是答案。由于求的是个数，所以可以对超出范围的 <span class=\"math inline\">\\(i\\)</span> 对应的 <span class=\"math inline\">\\(f_i\\)</span> 进行删除操作。</p>\n<p>那么 <span class=\"math inline\">\\(f_i\\)</span> 又该怎么求呢？暴力地再建一个权值线段树维护 <span class=\"math inline\">\\(L_x\\)</span>，在 <span class=\"math inline\">\\((-\\infty, i)\\)</span> 权值范围内查询下标 <span class=\"math inline\">\\(k\\)</span> 的最小值，此时的 <span class=\"math inline\">\\(k\\)</span> 就是 <span class=\"math inline\">\\(f_i\\)</span>。</p>\n<p>因为 0# 讲课的时候我在开飞机，所以我也不知道 0# 是不是这么讲的，总之我这么做应该能做出来，就是要维护的东西实在有亿点点多。</p>\n<p>但是注意到一个线段树和两个权值线段树维护的大区间其实是一样的，所以我们只用一个线段树同时维护三个信息就好。最后时间复杂度 <span class=\"math inline\">\\(O(n\\log n)\\)</span>。</p>\n<details>\n<pre class=\"cpp\"><code>namespace XSC062 &#123;\nusing namespace fastIO;\n#define lt (p &lt;&lt; 1)\n#define rt (lt | 1)\n#define mid (t[p].l + t[p].r) / 2\nconst int maxn = 3e5 + 5;\n// shaber monotonicity\n// destroy my youth \nstruct _ &#123; int l, r, u, d; &#125;;\nstruct __ &#123;\n    int u, i;\n    __() &#123;&#125;\n    __(int u1, int i1) &#123;\n        u = u1, i = i1;\n    &#125;\n&#125;;\nint T, n, res;\n_ t[maxn &lt;&lt; 2];\nint a[maxn], L[maxn], R[maxn];\nint max(int x, int y) &#123; return x &gt; y ? x : y; &#125;\nint min(int x, int y) &#123; return x &lt; y ? x : y; &#125;\nvoid pushup(int p) &#123;\n    t[p].u = t[lt].u + t[rt].u;\n    return;\n&#125;\nvoid pushdown(int p) &#123;\n    if (t[p].d) &#123;\n        t[lt].d = t[rt].d = 1;\n        t[lt].u = t[lt].r - t[lt].l + 1;\n        t[rt].u = t[rt].r - t[rt].l + 1;\n        t[p].d = 0;\n    &#125;\n    return;\n&#125;\nvoid bld(int p, int l, int r) &#123;\n    t[p].u = t[p].d = 0;\n    t[p].l = l, t[p].r = r;\n    if (l == r) return;\n    bld(lt, l, mid), bld(rt, mid + 1, r);\n    return;\n&#125;\nvoid add(int p, int l, int r) &#123;\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r) &#123;\n        t[p].u = t[p].r - t[p].l + 1;\n        t[p].d = 1;\n        return;\n    &#125;\n    pushdown(p);\n    if (l &lt;= mid) add(lt, l, r);\n    if (r &gt; mid) add(rt, l, r);\n    pushup(p);\n    return;\n&#125;\nint ask(int p, int l, int r) &#123;\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r)\n        return t[p].u;\n    int res = 0; pushdown(p);\n    if (l &lt;= mid) res = ask(lt, l, r);\n    if (r &gt; mid) res += ask(rt, l, r);\n    return res;\n&#125;\nint main() &#123;\n    read(T);\n    while (T--) &#123;\n        read(n), res = 0;\n        std::stack&lt;__&gt; p;\n        std::fill(L + 1, L + n + 1, n + 5);\n        std::fill(R + 1, R + n + 1, 0);\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            read(a[i]), R[a[i]] = i;\n            if (L[a[i]] == n + 5) L[a[i]] = i;\n        &#125;\n        bld(1, 1, n);\n        for (int i = 1, j; i &lt;= n; ++i) &#123;\n            if (i == R[a[i]] &amp;&amp; i != L[a[i]])\n                add(1, L[a[i]] + 1, R[a[i]]);\n            else p.push(__(a[i], i));\n            while (!p.empty() &amp;&amp; R[p.top().u] &lt;= i) p.pop();\n            j = p.size() ? p.top().i : 0;\n            if (i != j) res += i - j - ask(1, j + 1, i);\n        &#125;\n        print(res, &#39;\\n&#39;);\n    &#125;\n    return 0;\n&#125;\n&#125; // namespace XSC062</code></pre>\n</details>\n",
            "tags": [
                "线段树"
            ]
        }
    ]
}