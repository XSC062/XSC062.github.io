{
    "version": "https://jsonfeed.org/version/1",
    "title": "null • All posts by \"线段树\" tag",
    "description": "",
    "home_page_url": "https://xsc062.netlify.app",
    "items": [
        {
            "id": "https://xsc062.netlify.app/20251019/",
            "url": "https://xsc062.netlify.app/20251019/",
            "title": "杂题",
            "date_published": "2025-10-19T06:17:38.000Z",
            "content_html": "<p>模拟赛 and so on</p>\n<span id=\"more\"></span>\n<hr />\n<h2 id=\"cf1923f-shrink-reverse\">CF1923F Shrink-Reverse</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/CF1923F\" class=\"uri\">https://www.luogu.com.cn/problem/CF1923F</a></p>\n<p>需要想到贪心策略，但正确的策略并没有<strong>那么</strong>显然。</p>\n<ul>\n<li><p>观察样例可以大胆猜测，<code>SHRINK_REVERSE</code> 只会用最多一次。尝试理解这一点：</p>\n<ul>\n<li>只考虑 <code>SHRINK</code>，那么发现只有最后一次 <code>SHRINK</code> 是有效的。</li>\n<li>只考虑 <code>REVERSE</code>，那么只需要将两次 <code>REVERSE</code> 中间的 <code>SWAP</code> 进行翻转，并删除这两次 <code>REVERSE</code>，就可以达到相同的作用。</li>\n</ul>\n<p>综上，只需要保留最后一次 <code>SHRINK_REVERSE</code>，剩下的可以通过翻转对应的 <code>SWAP</code> 操作达到相同的效果，节省操作次数。且显然这次 <code>SHRINK_REVERSE</code> 应该放在操作序列的末尾。</p></li>\n<li><p>因此，只需要讨论不 <code>SHRINK_REVERSE</code>、在最后 <code>SHRINK_REVERSE</code> 两种情况。</p>\n<p>对于不 <code>SHRINK_REVERSE</code> 的情况，直接贪心即可。</p></li>\n<li><p>对于最后再 <code>SHRINK_REVERSE</code> 的情况，不妨先 <code>REVERSE</code>，考虑找到 <code>SHRINK</code> 后对应的原始字符串上的区间。</p>\n<p>也即考虑找到一个最短的子串，使得能够通过 <span class=\"math inline\">\\(k-1\\)</span> 次 <code>SWAP</code> 把子串外的 <span class=\"math inline\">\\(1\\)</span> 全部换到子串内。</p></li>\n<li><p>问题具有一定的单调性，故可以双指针对于每个 <span class=\"math inline\">\\(l\\)</span> 找到最小的 <span class=\"math inline\">\\(r\\)</span>。接下来仍然可以贪心最小化答案。</p>\n<p>很容易说明区间长最短的才能竞争最优：要么 <span class=\"math inline\">\\(l\\)</span> 初始为 <span class=\"math inline\">\\(1\\)</span>，要么区间长就是 <span class=\"math inline\">\\(1\\)</span> 总数；</p>\n<p>很容易说明相同长度的参与竞争的区间，字典序最小的最优。</p></li>\n<li><p>故接下来需要比较这 <span class=\"math inline\">\\(O(n)\\)</span> 个长度相同的答案区间的字典序。SA 即可。</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 1e9 + 7;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, k;\n    std::string s, res1, res2;\n    std::cin &gt;&gt; n &gt;&gt; k &gt;&gt; s, s = &#39;#&#39; + s;\n    res1 = s;\n    for (int i = 1, j = n, l = 1; l &lt;= k &amp;&amp; i &lt; j; ++i, --j, ++l) &#123;\n        for (; i &lt; j &amp;&amp; res1[i] != &#39;1&#39;; ++i);\n        for (; i &lt; j &amp;&amp; res1[j] != &#39;0&#39;; --j);\n        if (i &lt; j)\n            std::swap(res1[i], res1[j]);\n    &#125;\n    for (int i = 1; i &lt;= n; ++i)\n        if (res1[i] == &#39;1&#39;) &#123;\n            res1 = &#39;#&#39; + res1.substr(i, n - i + 1);\n            break;\n        &#125;\n    std::reverse(s.begin() + 1, s.end());\n    std::vector&lt;int&gt; pos;\n    const int s1 = std::count(s.begin() + 1, s.end(), &#39;1&#39;);\n    int len = n;\n    for (int l = 1, r = 0, c1 = 0, c0 = 0; l &lt;= n; ++l) &#123;\n        for (; r &lt; n &amp;&amp; (c0 &lt; s1 - c1 || s1 - c1 &gt; k - 1); )\n            if (s[++r] == &#39;1&#39;) ++c1;\n            else ++c0;\n        if (c0 &gt;= s1 - c1 &amp;&amp; s1 - c1 &lt;= k - 1) &#123;\n            if (r - l + 1 &lt; len)\n                len = r - l + 1, pos.clear();\n            if (r - l + 1 == len)\n                pos.push_back(l);\n        &#125;\n        if (s[l] == &#39;1&#39;) --c1;\n        else --c0;\n    &#125;\n    std::vector&lt;int&gt; sa(n + 1), rk(2 * n + 1);\n    &#123;\n        int m = 128;\n        std::vector&lt;int&gt; c(std::max(n, m) + 1), id, la(2 * n + 1);\n        std::copy(s.begin() + 1, s.end(), rk.begin() + 1);\n        for (int i = 1; i &lt;= n; ++i)\n            ++c[rk[i]];\n        std::partial_sum(c.begin() + 1, c.begin() + m + 1, c.begin() + 1);\n        for (int i = n; i; --i)\n            sa[c[rk[i]]--] = i;\n        for (int w = 1, p; ; w &lt;&lt;= 1, m = p) &#123;\n            id.clear(), id.push_back(-1);\n            for (int i = n - w + 1; i &lt;= n; ++i)\n                id.push_back(i);\n            for (int i = 1; i &lt;= n; ++i)\n                if (sa[i] &gt; w)\n                    id.push_back(sa[i] - w);\n            std::fill(c.begin() + 1, c.begin() + m + 1, 0);\n            for (int i = 1; i &lt;= n; ++i)\n                ++c[rk[i]];\n            std::partial_sum(c.begin() + 1, c.begin() + m + 1, c.begin() + 1);\n            for (int i = n; i; --i)\n                sa[c[rk[id[i]]]--] = id[i];\n            p = 0;\n            std::copy(rk.begin() + 1, rk.end(), la.begin() + 1);\n            for (int i = 1; i &lt;= n; ++i)\n                if (i != 1 &amp;&amp; la[sa[i]] == la[sa[i - 1]] &amp;&amp; la[sa[i] + w] == la[sa[i - 1] + w])\n                    rk[sa[i]] = p;\n                else\n                    rk[sa[i]] = ++p;\n            if (p == n)\n                break;\n        &#125;\n    &#125;\n    int id = 0;\n    for (auto i : pos)\n        if (id == 0 || rk[i] &lt; rk[id])\n            id = i;\n    if (id == 0)\n        assert(len == n), id = 1;\n    res2 = &#39;#&#39; + s.substr(id, len);\n    int tot = s1 - std::count(res2.begin() + 1, res2.end(), &#39;1&#39;);\n    for (int i = len; tot--; --i) &#123;\n        for (; res2[i] != &#39;0&#39;; --i);\n        res2[i] = &#39;1&#39;;\n    &#125;\n    if (res1.length() == res2.length())\n        s = std::min(res1, res2);\n    else if (res1.length() &lt; res2.length())\n        s = res1;\n    else\n        s = res2;\n    auto res = 0ll;\n    for (int i = 1; i &lt; (int)s.size(); ++i)\n        res = (res * 2 + s[i] - &#39;0&#39;) % mod;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"cf1859f-teleportation-in-byteland\">CF1859F Teleportation in Byteland</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/CF1859F\" class=\"uri\">https://www.luogu.com.cn/problem/CF1859F</a></p>\n<ul>\n<li><p>题设让树自然呈现一个分层图的结构。贪心地，最优的路径一定为 <span class=\"math inline\">\\(a_i\\to u\\)</span>，（在 <span class=\"math inline\">\\(u\\)</span> 学习若干次），<span class=\"math inline\">\\(u\\to b_i\\)</span>。</p>\n<p>枚举一个学习次数 <span class=\"math inline\">\\(k\\)</span>（显然 <span class=\"math inline\">\\(k\\)</span> 不会超过 <span class=\"math inline\">\\(\\left\\lceil\\log_2n\\right\\rceil\\)</span>），并令 <span class=\"math inline\">\\(d_k(u,v)\\)</span> 表示在学习 <span class=\"math inline\">\\(k\\)</span> 次后的分层图上 <span class=\"math inline\">\\(u\\)</span> 与 <span class=\"math inline\">\\(v\\)</span> 的距离。最后的答案可以表示为 <span class=\"math inline\">\\(\\min\\limits_{u,k}\\{d_0(a_i,u)+d_k(u,b_i)+k\\cdot T\\}\\)</span>。</p></li>\n<li><p>现在希望能够快速地找到，对于一个固定的 <span class=\"math inline\">\\(k\\)</span>，使答案最小的 <span class=\"math inline\">\\(u\\)</span>。询问与路径相关，所以期望一种能和路径挂钩的答案表示方法（似乎是经典 trick）。容易想到链 <span class=\"math inline\">\\((a_i,b_i)\\)</span> 上离 <span class=\"math inline\">\\(u\\)</span> 最近的点 <span class=\"math inline\">\\(v\\)</span>，答案可以改写成：</p>\n<p><span class=\"math display\">\\[\n\\min\\limits_{u,v}\\{d_0(a_i,v)+d_k(v,b_i)+d_0(v,u)+d_k(u,v)\\}+k\\cdot T\n\\]</span></p>\n<p>其中，<span class=\"math inline\">\\(d_0(v,u)+d_k(u,v)\\)</span> 与具体的 <span class=\"math inline\">\\(a,b\\)</span> 无关，可以用一次多源 Dij 预处理出每个 <span class=\"math inline\">\\(v\\)</span> 的答案（记为 <span class=\"math inline\">\\(s_k(v)\\)</span>）（需要注意到 <span class=\"math inline\">\\(d_0(v,u)\\)</span> 和 <span class=\"math inline\">\\(d_k(u,v)\\)</span> 可能不同时取最小，可以用 <span class=\"math inline\">\\(w_0+w_k\\)</span> 作边权）；<span class=\"math inline\">\\(d_0(a_i,v)+d_k(v,b_i)\\)</span> 则可以通过讨论 LCA 直接用深度表示，求出最值。</p></li>\n<li><p>记 <span class=\"math inline\">\\(fa=\\text{LCA}(a_i,b_i)\\)</span>，当 <span class=\"math inline\">\\(v\\)</span> 在 <span class=\"math inline\">\\(fa\\to a_i\\)</span> 上时，答案为：</p>\n<p><span class=\"math display\">\\[\n(dep_k(v)+s_k(v)-dep_0(v))+(dep_k(b_i)-2dep_k(fa)+dep_0(a_i)+k\\cdot T)\n\\]</span></p>\n<p>当 <span class=\"math inline\">\\(v\\)</span> 在 <span class=\"math inline\">\\(fa\\to b_i\\)</span> 上时，答案为：</p>\n<p><span class=\"math display\">\\[\n(dep_0(v)+s_k(v)-dep_k(v))+(dep_0(a_i)-2dep_0(fa)+dep_k(b_i)+k\\cdot T)\n\\]</span></p>\n<p>维护链上 <span class=\"math inline\">\\(dep_k(v)+s_k(v)-dep_0(v)\\)</span> 和 <span class=\"math inline\">\\(dep_0(v)+s_k(v)-dep_k(v)\\)</span> 的最小值即可。</p></li>\n<li>由于是完全静态的树上路径问题，可以用倍增完成。注意考虑学 <span class=\"math inline\">\\(0\\)</span> 次的情况。复杂度 <span class=\"math inline\">\\(O(n\\log^2 n)\\)</span>。</li>\n<li><p>咦你怎么 MLE 了？只需要把所有询问离线下来，每个 <span class=\"math inline\">\\(k\\)</span> 就可以共用数组了。</p>\n<p>看到 Limury 的做法是树剖 + st 表，薄纱所有人。Rosmist 树剖 + bit 三只 log 也薄纱倍增做法，我怎么会做这样的梦。</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 1e5 + 5;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int T;\n    for (std::cin &gt;&gt; T; T--; ) &#123;\n        int n, t;\n        std::cin &gt;&gt; n &gt;&gt; t;\n        std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; g(n + 1);\n        for (int i = 1, x, y, w; i &lt; n; ++i) &#123;\n            std::cin &gt;&gt; x &gt;&gt; y &gt;&gt; w;\n            g[x].emplace_back(y, w), g[y].emplace_back(x, w);\n        &#125;\n        std::vector&lt;int&gt; tag(n + 1);\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            char t;\n            std::cin &gt;&gt; t, tag[i] = t - &#39;0&#39;;\n        &#125;\n        auto fun = [&amp;](int w, int k) &#123;\n            return (w + (1 &lt;&lt; k) - 1) &gt;&gt; k;\n        &#125;;\n        std::vector&lt;long long&gt; s(n + 1);\n        std::vector&lt;int&gt; dep(n + 1), vis(n + 1);\n        std::vector&lt;std::array&lt;int, 17&gt; &gt; fa(n + 1);\n        std::vector&lt;std::array&lt;long long, 17&gt; &gt; f1(n + 1), f2(n + 1);\n        std::vector&lt;std::vector&lt;long long&gt; &gt; dis(2, std::vector&lt;long long&gt; (n + 1));\n        std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;\n            for (auto [i, w] : g[x])\n                if (i != fa[x][0]) &#123;\n                    dep[i] = dep[x] + 1;\n                    dis[0][i] = dis[0][x] + w;\n                    fa[i][0] = x;\n                    for (int j = 1; j &lt; 17; ++j)\n                        fa[i][j] = fa[fa[i][j - 1]][j - 1];\n                    DFS(i);\n                &#125;\n            return;\n        &#125;;\n        dep[1] = 1, DFS(1);\n        auto getLCA = [&amp;](int x, int y) &#123;\n            if (dep[x] &lt; dep[y])\n                std::swap(x, y);\n            for (int i = 16; ~i; --i)\n                if (dep[fa[x][i]] &gt;= dep[y])\n                    x = fa[x][i];\n            if (x == y)\n                return x;\n            for (int i = 16; ~i; --i)\n                if (fa[x][i] != fa[y][i])\n                    x = fa[x][i], y = fa[y][i];\n            return fa[x][0];\n        &#125;;\n        int m;\n        std::cin &gt;&gt; m;\n        std::vector&lt;long long&gt; res(m + 1);\n        std::vector&lt;std::pair&lt;int, int&gt; &gt; q(m + 1);\n        for (int i = 1, u, v; i &lt;= m; ++i) &#123;\n            std::cin &gt;&gt; u &gt;&gt; v;\n            res[i] = dis[0][u] + dis[0][v] - 2 * dis[0][getLCA(u, v)];;\n            q[i] = &#123; u, v &#125;;\n        &#125;\n        for (int j = 0; j &lt; 17; ++j)\n            f1[0][j] = f2[0][j] = 1e18;\n        for (int k = 1; k &lt;= 20; ++k) &#123;\n            &#123;\n                std::priority_queue&lt;std::pair&lt;long long, int&gt; &gt; q;\n                for (int i = 1; i &lt;= n; ++i) &#123;\n                    vis[i] = 0;\n                    if (tag[i])\n                        s[i] = 0ll, q.emplace(0ll, i);\n                    else\n                        s[i] = 1e18;\n                &#125;\n                for (; !q.empty(); ) &#123;\n                    int x = q.top().second;\n                    q.pop();\n                    if (vis[x])\n                        continue;\n                    vis[x] = 1;\n                    for (auto [v, w] : g[x])\n                        if (s[v] &gt; s[x] + fun(w, k) + w) &#123;\n                            s[v] = s[x] + fun(w, k) + w;\n                            q.emplace(-s[v], v);\n                        &#125;\n                &#125;\n            &#125;\n            DFS = [&amp;](int x) &#123;\n                for (auto [i, w] : g[x])\n                    if (i != fa[x][0]) &#123;\n                        dis[1][i] = dis[1][x] + fun(w, k);\n                        f1[i][0] = dis[1][i] + s[i] - dis[0][i];\n                        f2[i][0] = dis[0][i] + s[i] - dis[1][i];\n                        for (int j = 1; j &lt; 17; ++j) &#123;\n                            f1[i][j] = std::min(f1[i][j - 1], f1[fa[i][j - 1]][j - 1]);\n                            f2[i][j] = std::min(f2[i][j - 1], f2[fa[i][j - 1]][j - 1]);\n                        &#125;\n                        DFS(i);\n                    &#125;\n                return;\n            &#125;;\n            DFS(1);\n            for (int i = 1; i &lt;= m; ++i) &#123;\n                auto [u, v] = q[i];\n                int x = u, y = v;\n                long long s1 = 1e18, s2 = 1e18;\n                if (dep[x] &gt; dep[y]) &#123;\n                    for (int i = 16; ~i; --i)\n                        if (dep[fa[x][i]] &gt;= dep[y]) &#123;\n                            s1 = std::min(s1, f1[x][i]);\n                            x = fa[x][i];\n                        &#125;\n                &#125;\n                else &#123;\n                    for (int i = 16; ~i; --i)\n                        if (dep[fa[y][i]] &gt;= dep[x]) &#123;\n                            s2 = std::min(s2, f2[y][i]);\n                            y = fa[y][i];\n                        &#125;\n                &#125;\n                if (x != y) &#123;\n                    for (int i = 16; ~i; --i)\n                        if (fa[x][i] != fa[y][i]) &#123;\n                            s1 = std::min(s1, f1[x][i]);\n                            s2 = std::min(s2, f2[y][i]);\n                            x = fa[x][i], y = fa[y][i];\n                        &#125;\n                    s1 = std::min(s1, f1[x][0]);\n                    s2 = std::min(s2, f2[y][0]);\n                    x = fa[x][0];\n                &#125;\n                s1 = std::min(s1, dis[1][x] + s[x] - dis[0][x]);\n                s2 = std::min(s2, dis[0][x] + s[x] - dis[1][x]);\n                res[i] = std::min(res[i], k * t + dis[0][u] + dis[1][v] + std::min(s1 - 2 * dis[1][x], s2 - 2 * dis[0][x]));\n            &#125;\n        &#125;\n        for (int i = 1; i &lt;= m; ++i)\n            std::cout &lt;&lt; res[i] &lt;&lt; &#39;\\n&#39;;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"cf1556g-gates-to-another-world\">CF1556G Gates to Another World</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/CF1556G\" class=\"uri\">https://www.luogu.com.cn/problem/CF1556G</a></p>\n<ul>\n<li><p>快速做出来需要一定运气，需要把点顺序排布而不是像题目一样画晶胞（。）手玩一下 <span class=\"math inline\">\\(n=4\\)</span> 时的情况：</p>\n<p><img src=\"image.png\" /></p>\n<p>看到两个相邻点间连的边就应激想到线段树了，事实上把不同层的边提起来发现就是线段树的结构。</p>\n<details>\n<p><summary>为什么这个图这么大（没啥用故折起来了）</summary></p>\n<p>tip：实际上那些相邻 / 相反的尖尖是重合的，为了好看一点故错开。</p>\n<p><img src=\"image-1.png\" /></p>\n</details>\n<p>发现形成一个<strong>相邻子树对位连边</strong>的结构。这里线段树其实只有底层点是有意义的，其他点只起结构辅助作用。</p>\n<p>实际上，对于两个有连边的点，它们『LCA』的高度是被 flip 的位。</p></li>\n<li><p>很容易注意到一个线段树子树内的底层点是连通的，这一点也很容易递归地证明。</p>\n<p>考虑动态开点线段树优化建图，对于动态开点出来的叶子（注意不是底层点），容易发现在题目限制下每个叶子内部都没有点被删除，是连通的（那么此时不妨认为叶子就代表了这个连通块）。</p>\n<p>故将某个点进行连边时，并不要求找到对位的那个点（不一定存在），和走到头的叶子连边就可以达到相同的连通效果。这样就把底层点之间的连边转化为了<strong>叶子间</strong>的连边。</p></li>\n<li><p>不妨先时光倒流 + 预处理出每个叶子最后（最早）存在的时间戳，考虑暴力连出来这些叶子间的边（对于每个点，将对位的叶子连边）并计算出边最后（最早）存在的时间戳。</p>\n<p>发现暴力对位连边这个操作，是形似线段树合并但比线段树合并更劣的东西。咋分析复杂度。</p>\n<p>边是双向的，考虑更深的叶子的贡献。那么其枚举 lca + flip 对应位（不存在则取路径上的叶子），一共会有 <span class=\"math inline\">\\(O(n)\\)</span> 次连边。共有 <span class=\"math inline\">\\(O(nm)\\)</span> 个叶子，摊下来暴力连边复杂度为 <span class=\"math inline\">\\(O(n^2m)\\)</span>。</p></li>\n</ul>\n<details>\n<p>空间很卡…… 不要把离线的加边数组开成 <code>long long</code> 了。</p>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 32e5 + 5;\nusing ll = long long;\nstruct &#123; int l, r, d; &#125; t[maxn];\nint tot;\n#define lt t[p].l\n#define rt t[p].r\n#define leaf(p) (!t[p].l &amp;&amp; !t[p].r)\nint newnode(void) &#123;\n    ++tot, t[tot].l = t[tot].r = t[tot].d = 0;\n    return tot;\n&#125;\nvoid pushdown(int p) &#123;\n    if (t[p].d) &#123;\n        if (!lt)\n            lt = newnode();\n        if (!rt)\n            rt = newnode();\n        t[lt].d = t[rt].d = t[p].d;\n        t[p].d = 0;\n    &#125;\n    return;\n&#125;\nvoid upd(int &amp;p, ll l, ll r, ll ql, ll qr, int v) &#123;\n    if (!p)\n        p = newnode();\n    if (ql &lt;= l &amp;&amp; r &lt;= qr) &#123;\n        t[p].d = v;\n        return;\n    &#125;\n    pushdown(p);\n    auto mid = (l + r) &gt;&gt; 1;\n    if (ql &lt;= mid)\n        upd(lt, l, mid, ql, qr, v);\n    if (qr &gt; mid)\n        upd(rt, mid + 1, r, ql, qr, v);\n    return;\n&#125;\nint ask(int p, ll l, ll r, ll x) &#123;\n    if (leaf(p))\n        return p;\n    ll mid = (l + r) &gt;&gt; 1;\n    if (x &lt;= mid)\n        return ask(lt, l, mid, x);\n    return ask(rt, mid + 1, r, x);\n&#125;\n#undef lt\n#undef rt\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, m, rt = newnode();\n    std::cin &gt;&gt; n &gt;&gt; m;\n    t[rt].d = m + 1;\n    const auto N = (1ll &lt;&lt; n) - 1;\n    struct query &#123; int op; ll s, t; &#125;;\n    std::vector&lt;query&gt; q(m + 1);\n    for (int i = 1; i &lt;= m; ++i) &#123;\n        std::string op;\n        std::cin &gt;&gt; op;\n        q[i].op = (op == &quot;ask&quot;) + 1;\n        std::cin &gt;&gt; q[i].s &gt;&gt; q[i].t;\n        if (q[i].op == 1)\n            upd(rt, 0ll, N, q[i].s, q[i].t, i);\n    &#125;\n    std::vector&lt;int&gt; f(tot + 1);\n    std::iota(f.begin() + 1, f.end(), 1);\n    std::function&lt;int(int)&gt; find = [&amp;](int x) &#123;\n        return x == f[x] ? x : f[x] = find(f[x]);\n    &#125;;\n    auto merge = [&amp;](int x, int y) &#123;\n        f[find(x)] = find(y);\n        return;\n    &#125;;\n    std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; u(m + 2);\n    std::function&lt;void(int, int)&gt; link = [&amp;](int p, int q) &#123;\n        if (leaf(p) &amp;&amp; leaf(q)) &#123;\n            u[std::min(t[p].d, t[q].d)].emplace_back(p, q);\n            return;\n        &#125;\n        else if (leaf(p))\n            link(p, t[q].l), link(p, t[q].r);\n        else if (leaf(q))\n            link(t[p].l, q), link(t[p].r, q);\n        else\n            link(t[p].l, t[q].l), link(t[p].r, t[q].r);\n        return;\n    &#125;;\n    for (int i = 1; i &lt;= tot; ++i)\n        if (t[i].l &amp;&amp; t[i].r)\n            link(t[i].l, t[i].r);\n    for (auto [p, q] : u[m + 1])\n        merge(p, q);\n    std::vector&lt;int&gt; res;\n    for (int i = m; i; --i)\n        if (q[i].op == 2)\n            res.push_back(find(ask(rt, 0, N, q[i].s)) == find(ask(rt, 0, N, q[i].t)));\n        else\n            for (auto [p, q] : u[i])\n                merge(p, q);\n    for (; !res.empty(); res.pop_back())\n        std::cout &lt;&lt; res.back() &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"c.-小-z-爱优化\">C. 小 Z 爱优化</h2>\n<p><a href=\"https://www.becoder.com.cn/contest/6662/problem/3\" class=\"uri\">https://www.becoder.com.cn/contest/6662/problem/3</a></p>\n<blockquote>\n<p>给定 <span class=\"math inline\">\\(a_{1\\sim n}\\)</span>，将其分为若干连续段，满足每段长度为 <span class=\"math inline\">\\(1\\)</span> 或 <span class=\"math inline\">\\(2\\)</span>，定义一段的权值为元素之和，最小化段权值的极差并输出之。</p>\n<p><span class=\"math inline\">\\(n\\le 2\\times 10^5,V=10^9\\)</span>。</p>\n</blockquote>\n<ul>\n<li><p>令 <span class=\"math inline\">\\(f_{i,j}\\)</span> 表示这一段以 <span class=\"math inline\">\\(i\\)</span> 结尾，最小值为 <span class=\"math inline\">\\(j\\)</span> 时的最大值。把最小值当状态是自然的想法，实际似乎差不多（。）得到（<strong>不重要</strong>）：</p>\n<p><span class=\"math display\">\\[\nf_{i,a_i}\\gets f_{i-1,j},j\\ge a_i\\\\\nf_{i,a_i+a_{i-1}}\\gets f_{i-2,j},j\\ge a_i+a_{i-1}\\\\\nf_{i,j}\\gets \\max(f_{i-1,j},a_i) ,j\\le a_i\\\\\nf_{i,j}\\gets \\max(f_{i-2,j},a_i+a_{i-1}) ,j\\le a_i\n\\]</span></p></li>\n<li><p>这个状态很矩阵，可以考虑下标分奇偶性继承，用线段树优化，矩阵作为元素；然而同时涉及两个维度，尤其是第一维的变化，实在是答辩啊！</p>\n<details>\n<p><summary>By the way，广义矩乘的结合律？</summary></p>\n<p>对于一个 <span class=\"math inline\">\\(\\oplus-\\otimes\\)</span> 矩阵（内层为 <span class=\"math inline\">\\(\\otimes\\)</span>，外层为 <span class=\"math inline\">\\(\\oplus\\)</span>），其有结合律当且仅当同时满足：</p>\n<ol type=\"1\">\n<li><span class=\"math inline\">\\(\\oplus\\)</span> 有交换律；</li>\n<li><span class=\"math inline\">\\(\\otimes\\)</span> 有结合律；</li>\n<li><span class=\"math inline\">\\(\\otimes\\)</span> 对 <span class=\"math inline\">\\(\\oplus\\)</span> 有分配律。</li>\n</ol>\n<figure>\n<img src=\"image-2.png\" alt=\"来自 qkhm 关于广义矩阵乘法常见误区的一点纠正\" /><figcaption>来自 qkhm <a href=\"https://www.cnblogs.com/qkhm/p/19055513/ddp\">关于广义矩阵乘法常见误区的一点纠正</a></figcaption>\n</figure>\n</details>\n<p>发现第二维其实不会怎么变，或者说第二维其实起的是一个<strong>限制</strong>性的作用，可以考虑把第二维放到外层循环，相当于枚举<strong>限制</strong>。我们知道上面的做法可以很快地优化，所以拿出去了之后大概也能做。</p></li>\n<li><p>若限制当前最小值不能小于 <span class=\"math inline\">\\(j\\)</span>，那么有：</p>\n<p><span class=\"math display\">\\[\nf_i\\gets \\max(f_{i-1},a_i),a_j\\ge j\\\\\nf_i\\gets \\max(f_{i-2},a_i+a_{i-1}),a_i+a_{i-1}\\ge j\n\\]</span></p>\n<p>发现这就很显然是一个 DDP 的形式了，每次 <span class=\"math inline\">\\(j\\)</span> 改变时，只需要改动对应位置的矩阵（即是否能进行转移），总修改次数是 <span class=\"math inline\">\\(O(n)\\)</span> 的。</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 2e5 + 5;\nconst int inf = 0x7fffffff;\nusing mat = std::array&lt;std::array&lt;int, 2&gt;, 2&gt;;\nint m[maxn][2][2];\nvoid mul(mat &amp;res, mat &amp;p, mat &amp;q) &#123;\n    res[0][0] = std::min(std::max(p[0][0], q[0][0]), std::max(p[0][1], q[1][0]));\n    res[0][1] = std::min(std::max(p[0][0], q[0][1]), std::max(p[0][1], q[1][1]));\n    res[1][0] = std::min(std::max(p[1][0], q[0][0]), std::max(p[1][1], q[1][0]));\n    res[1][1] = std::min(std::max(p[1][0], q[0][1]), std::max(p[1][1], q[1][1]));\n    return;\n&#125;\nstruct &#123;\n    int l, r;\n    mat u;\n&#125; t[maxn &lt;&lt; 2];\n#define lt (p &lt;&lt; 1)\n#define rt (lt | 1)\nvoid bld(int p, int l, int r) &#123;\n    t[p].l = l, t[p].r = r;\n    if (l == r) &#123;\n        t[p].u[0][0] = m[l][0][0];\n        t[p].u[0][1] = m[l][0][1];\n        t[p].u[1][0] = m[l][1][0];\n        t[p].u[1][1] = m[l][1][1];\n        return;\n    &#125;\n    int mid = (l + r) &gt;&gt; 1;\n    bld(lt, l, mid), bld(rt, mid + 1, r);\n    mul(t[p].u, t[lt].u, t[rt].u);\n    return;\n&#125;\nvoid upd(int p, int x) &#123;\n    if (t[p].l == t[p].r) &#123;\n        t[p].u[0][1] = m[x][0][1];\n        t[p].u[1][1] = m[x][1][1];\n        return;\n    &#125;\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (x &lt;= mid)\n        upd(lt, x);\n    else\n        upd(rt, x);\n    mul(t[p].u, t[lt].u, t[rt].u);\n    return;\n&#125;\n#undef lt\n#undef rt\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n    std::freopen(&quot;opti.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;opti.out&quot;, &quot;w&quot;, stdout);\n#else\n    std::freopen(&quot;./test/20251021/opti/1.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    auto stime = std::chrono::steady_clock::now();\n#endif\n    int T;\n    for (std::cin &gt;&gt; T; T--; ) &#123;\n        int n;\n        std::cin &gt;&gt; n;\n        std::vector&lt;int&gt; a(n + 1), b(n + 1), l(1);\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            std::cin &gt;&gt; a[i];\n            l.push_back(a[i]);\n            if (i &gt; 1)\n                b[i] = a[i] + a[i - 1], l.push_back(b[i]);\n        &#125;\n        std::sort(l.begin() + 1, l.end());\n        l.erase(std::unique(l.begin() + 1, l.end()), l.end());\n        int m = (int)l.size() - 1;\n        std::vector&lt;std::vector&lt;int&gt; &gt; ida(m + 1), idb(m + 1);\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            a[i] = std::lower_bound(l.begin() + 1, l.end(), a[i]) - l.begin();\n            ::m[i][1][1] = a[i], ida[a[i]].push_back(i);\n            if (i &gt; 1) &#123;\n                b[i] = std::lower_bound(l.begin() + 1, l.end(), b[i]) - l.begin();\n                ::m[i][0][1] = b[i], idb[b[i]].push_back(i);\n            &#125;\n            else\n                ::m[i][0][1] = inf;\n            ::m[i][0][0] = inf, ::m[i][1][0] = 0;\n        &#125;\n        bld(1, 1, n);\n        auto res = inf;\n        for (int i = 1; i &lt;= m; ++i) &#123;\n            if (std::min(t[1].u[0][1], t[1].u[1][1]) != inf)\n                res = std::min(res, l[std::min(t[1].u[0][1], t[1].u[1][1])] - l[i]);\n            for (auto j : ida[i])\n                ::m[j][1][1] = inf, upd(1, j);\n            for (auto j : idb[i])\n                ::m[j][0][1] = inf, upd(1, j);\n        &#125;\n        std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt;(std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s \\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"d.-小-z-爱考试\">D. 小 Z 爱考试</h2>\n<p><a href=\"https://www.becoder.com.cn/contest/6662/problem/4\" class=\"uri\">https://www.becoder.com.cn/contest/6662/problem/4</a></p>\n<blockquote>\n<p>给定一个大小为 <span class=\"math inline\">\\(n\\)</span> 的内向基环树森林，每个点 <span class=\"math inline\">\\(u\\)</span> 上附有点权 <span class=\"math inline\">\\(a_u\\)</span>、收益 <span class=\"math inline\">\\(w_u\\)</span> 和一个进程，内容为：</p>\n<ul>\n<li>若 <span class=\"math inline\">\\(u\\)</span> 指向的结点 <span class=\"math inline\">\\(fa\\)</span> 满足 <span class=\"math inline\">\\(a_{fa}&gt;a_u\\)</span>，则令 <span class=\"math inline\">\\(a_u\\gets a_u+w_u\\)</span>。</li>\n</ul>\n<p>给定 <span class=\"math inline\">\\(m\\)</span> 次操作，形如：</p>\n<ul>\n<li>单点修改 <span class=\"math inline\">\\(a_u,w_u\\)</span>。</li>\n<li>给定一个 <span class=\"math inline\">\\(u\\)</span>，输出：在 <span class=\"math inline\">\\(n!\\)</span> 种进程的执行序列中，<span class=\"math inline\">\\(a_u\\)</span> 最终值的期望。</li>\n</ul>\n<p><span class=\"math inline\">\\(n,m\\le 2\\times 10^5\\)</span>。<strong>保证每个点的入度 <span class=\"math inline\">\\(\\le 3\\)</span></strong>。</p>\n</blockquote>\n<ul>\n<li><p>可以感受到操作的『后效性』是非常弱的，进一步感受到点可以粗暴地分为三种类型：</p>\n<ol type=\"1\">\n<li><span class=\"math inline\">\\(a_{fa}&gt;a_x\\)</span> 的；</li>\n<li><span class=\"math inline\">\\(a_{fa}+w_{fa} \\le a_x\\)</span> 的；</li>\n<li><span class=\"math inline\">\\(a_{fa}\\le a_x&lt;a_{fa} + w_{fa}\\)</span> 的；</li>\n</ol>\n<p>点的类型是无依赖，可直接求的。显然，若 <span class=\"math inline\">\\(u\\)</span> 最终想取到 <span class=\"math inline\">\\(a_u+w_u\\)</span>，相当于走一条 <span class=\"math inline\">\\(u\\)</span> 开头，经过若干 3 类点，在 1 类点结尾的路径（这显然是确定的），假设路径包含 <span class=\"math inline\">\\(len\\)</span> 个点，答案为 <span class=\"math inline\">\\(\\dfrac {(n-len)!\\cdot C_{n}^{len}}{n!}=\\dfrac 1{len!}\\)</span>。</p>\n<p>换句话说，<span class=\"math inline\">\\(u\\)</span> 取不到 <span class=\"math inline\">\\(a_u+w_u\\)</span>，当且仅当路径上在出现 1 类点前出现了 2 类点或 3 类点的环（基环）。</p></li>\n<li><p>考虑静态的情况，先处理所有基环：若只存在 3 类点，则标记全部非法；否则，任选一个 1 类点或者 2 类点开头，就可以 DP 出环上的 <span class=\"math inline\">\\(len\\)</span>。</p>\n<p>对于所有树，直接大力 DP 即可。</p></li>\n<li><p>接着考虑带修的情况，修改相当于改变点及其后继的状态（原来入度限制是拿来做这个的）。</p>\n<p>发现没啥办法很好地做这个类 DDP 的问题。考虑到一场比赛不应该出现两道 DDP，故如果灵感迸发可能会想到干脆放弃预处理的想法，上重链，线段树维护区间 1 类点或 2 类点深度 max，即可做到两只 log。</p>\n<p>如果发现树上没有这样的点，在环上也可以类似地找到第一个 1 类点或 2 类点。</p></li>\n</ul>\n<details>\n<p>感觉写复杂了，瞻仰了一下别人的代码又感觉流程上没什么区别</p>\n<p>喜提最长代码，喜提最优解</p>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 1e9 + 7;\nconst int maxn = 6e5 + 5;\nstruct &#123;\n    int l, r, lc, rc, u1, u2;\n&#125; t[maxn &lt;&lt; 2];\n#define lt t[p].lc\n#define rt t[p].rc\nint tot;\nint ty[maxn], dep[maxn];\nvoid bld(int &amp;p, int l, int r) &#123;\n    p = ++tot;\n    t[p].l = l, t[p].r = r;\n    if (l == r) &#123;\n        t[p].u1 = t[p].u2 = 0;\n        if (ty[l] == 1)\n            t[p].u1 = dep[l];\n        else if (ty[l] == 2)\n            t[p].u2 = dep[l];\n        return;\n    &#125;\n    int mid = (l + r) &gt;&gt; 1;\n    bld(lt, l, mid), bld(rt, mid + 1, r);\n    t[p].u1 = std::max(t[lt].u1, t[rt].u1);\n    t[p].u2 = std::max(t[lt].u2, t[rt].u2);\n    return;\n&#125;\nvoid upd(int p, int x) &#123;\n    if (t[p].l == t[p].r) &#123;\n        t[p].u1 = t[p].u2 = 0;\n        if (ty[x] == 1)\n            t[p].u1 = dep[x];\n        else if (ty[x] == 2)\n            t[p].u2 = dep[x];\n        return;\n    &#125;\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (x &lt;= mid)\n        upd(lt, x);\n    else\n        upd(rt, x);\n    t[p].u1 = std::max(t[lt].u1, t[rt].u1);\n    t[p].u2 = std::max(t[lt].u2, t[rt].u2);\n    return;\n&#125;\nstd::pair&lt;int, int&gt; ask(int p, int l, int r) &#123;\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r)\n        return std::make_pair(t[p].u1, t[p].u2);\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    std::pair&lt;int, int&gt; res(0, 0);\n    if (l &lt;= mid)\n        res = ask(lt, l, r);\n    if (r &gt; mid) &#123;\n        auto s(ask(rt, l, r));\n        res.first = std::max(res.first, s.first);\n        res.second = std::max(res.second, s.second);\n    &#125;\n    return res;\n&#125;\n#undef lt\n#undef rt\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n    std::freopen(&quot;exam.out&quot;, &quot;w&quot;, stdout);\n    std::freopen(&quot;exam.in&quot;, &quot;r&quot;, stdin);\n#else\n    std::freopen(&quot;./test/20251021/exam/3.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int T;\n    for (std::cin &gt;&gt; T; T--; ) &#123;\n        int n, m;\n        std::cin &gt;&gt; n &gt;&gt; m;\n        std::vector&lt;int&gt; f(n + 1);\n        std::iota(f.begin() + 1, f.end(), 1);\n        std::function&lt;int(int)&gt; find = [&amp;](int x) &#123;\n            return x == f[x] ? x : f[x] = find(f[x]);\n        &#125;;\n        auto merge = [&amp;](int x, int y) &#123;\n            f[find(x)] = find(y);\n            return;\n        &#125;;\n        std::vector&lt;long long&gt; fac(n + 1), inv(n + 1);\n        fac[0] = inv[0] = 1ll;\n        for (int i = 1; i &lt;= n; ++i)\n            fac[i] = fac[i - 1] * i % mod;\n        auto qkp = [&amp;](long long x, int y) &#123;\n            auto res = 1ll;\n            for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n                if (y &amp; 1)\n                    (res *= x) %= mod;\n            return res;\n        &#125;;\n        inv[n] = qkp(fac[n], mod - 2);\n        for (int i = n - 1; i; --i)\n            inv[i] = inv[i + 1] * (i + 1) % mod;\n        std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);\n        std::vector&lt;int&gt; a(n + 1), w(n + 1), to(n + 1), col(2 * n + 1);\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            std::cin &gt;&gt; a[i] &gt;&gt; to[i] &gt;&gt; w[i];\n            merge(i, to[i]);\n            g[to[i]].push_back(i);\n        &#125;\n        int now = 0, tot = n;\n        std::vector&lt;int&gt; tab(n + 1), tad(n + 1), vis(n + 1), L(2 * n + 1), R(2 * n + 1);\n        auto getty = [&amp;](int x) &#123;\n            if (a[to[x]] &gt; a[x])\n                return 1;\n            if (a[to[x]] + w[to[x]] &lt;= a[x])\n                return 2;\n            return 3;\n        &#125;;\n        for (int i = 1; i &lt;= n; ++i)\n            if (f[i] == i) &#123;\n                std::vector&lt;int&gt; vis(n + 1), t(1);\n                std::stack&lt;int&gt; st;\n                for (int x = i; ; ) &#123;\n                    st.push(x);\n                    if (!vis[to[x]])\n                        vis[to[x]] = 1, x = to[x];\n                    else &#123;\n                        for (;;) &#123;\n                            t.push_back(st.top());\n                            if (st.top() == to[x])\n                                break;\n                            st.pop();\n                        &#125;\n                        break;\n                    &#125;\n                &#125;\n                int k = (int)t.size() - 1;\n                std::reverse(t.begin() + 1, t.end());\n                t.resize(2 * k + 1);\n                L[++tot] = now + 1;\n                for (int i = 1; i &lt;= k; ++i) &#123;\n                    tab[t[i]] = ++now;\n                    col[t[i]] = tot;\n                    ::dep[tab[t[i]]] = 2 * k - i + 1;\n                    ::ty[tab[t[i]]] = getty(t[i]);\n                &#125;\n                for (int i = k + 1; i &lt;= 2 * k; ++i) &#123;\n                    t[i] = t[i - k];\n                    tad[t[i]] = ++now;\n                    ::dep[tad[t[i]]] = 2 * k - i + 1;\n                    ::ty[tad[t[i]]] = getty(t[i]);\n                &#125;\n                R[tot] = now;\n            &#125;\n        std::vector&lt;int&gt; fa(n + 1), siz(n + 1), son(n + 1), dep(n + 1);\n        std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;\n            siz[x] = 1;\n            for (auto i : g[x])\n                if (!tab[i]) &#123;\n                    dep[i] = dep[x] + 1;\n                    fa[i] = x, DFS(i);\n                    siz[x] += siz[i];\n                    if (siz[i] &gt; siz[son[x]])\n                        son[x] = i;\n                &#125;\n            return;\n        &#125;;\n        for (int i = 1; i &lt;= n; ++i)\n            if (tab[i])\n                dep[i] = 1, DFS(i);\n        std::vector&lt;int&gt; rt(2 * n + 1), dfn(n + 1), top(n + 1), bot(n + 1);\n        DFS = [&amp;](int x) &#123;\n            dfn[x] = ++now;\n            ty[dfn[x]] = getty(x);\n            ::dep[dfn[x]] = dep[x];\n            bot[top[x]] = x;\n            if (son[x])\n                top[son[x]] = top[x], DFS(son[x]);\n            for (auto i : g[x])\n                if (i != son[x] &amp;&amp; !tab[i])\n                    top[i] = i, DFS(i);\n            if (x == top[x])\n                bld(rt[x], dfn[x], dfn[bot[x]]);\n            return;\n        &#125;;\n        for (int i = 1; i &lt;= n; ++i)\n            if (tab[i])\n                top[i] = i, DFS(i);\n        for (int i = n + 1; i &lt;= tot; ++i)\n            bld(rt[i], L[i], R[i]);\n        auto work = [&amp;](int x) &#123;\n            ty[dfn[x]] = getty(x);\n            upd(rt[top[x]], dfn[x]);\n            if (tab[x]) &#123;\n                ty[tab[x]] = ty[tad[x]] = getty(x);\n                upd(rt[col[x]], tab[x]), upd(rt[col[x]], tad[x]);\n            &#125;\n            return;\n        &#125;;\n        for (int op; m--; ) &#123;\n            std::cin &gt;&gt; op;\n            if (op == 1) &#123;\n                int x;\n                std::cin &gt;&gt; x, std::cin &gt;&gt; a[x];\n                work(x);\n                for (auto i : g[x])\n                    work(i);\n            &#125;\n            else if (op == 2) &#123;\n                int x;\n                std::cin &gt;&gt; x, std::cin &gt;&gt; w[x];\n                work(x);\n                for (auto i : g[x])\n                    work(i);\n            &#125;\n            else &#123;\n                int x;\n                std::cin &gt;&gt; x;\n                auto calc = [&amp;](int x) &#123;\n                    int len = 0, toq = 0;\n                    for (; x; x = fa[top[x]]) &#123;\n                        auto [u1, u2] = ask(rt[top[x]], dfn[top[x]], dfn[x]);\n                        if (u1 &gt; u2)\n                            return len + dep[x] - u1 + 1;\n                        if (u2 &gt; u1)\n                            return -1;\n                        len += dep[x] - dep[fa[top[x]]], toq = top[x];\n                    &#125;\n                    auto [u1, u2] = ask(rt[col[toq]], tab[toq], R[col[toq]]);\n                    if (u1 &gt; u2)\n                        return len + ::dep[tab[toq]] - u1;\n                    return -1;\n                &#125;;\n                auto t(calc(x));\n                if (t == -1)\n                    std::cout &lt;&lt; a[x] &lt;&lt; &#39;\\n&#39;;\n                else &#123;\n                    // std::cout &lt;&lt; &quot;len = &quot; &lt;&lt; t &lt;&lt; &#39;\\n&#39;;\n                    std::cout &lt;&lt; ((a[x] + w[x]) * inv[t] % mod + (1ll + mod - inv[t]) % mod * a[x] % mod) % mod &lt;&lt; &#39;\\n&#39;;\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"b.-炒鱿鱼\">B. 炒鱿鱼</h2>\n<p><a href=\"https://www.becoder.com.cn/contest/6666/problem/2\" class=\"uri\">https://www.becoder.com.cn/contest/6666/problem/2</a></p>\n<blockquote>\n<p>现在有一个栈。在接下来的 <span class=\"math inline\">\\(n\\)</span> 个时刻，每个时刻会发生一次事件，形如：</p>\n<ul>\n<li>删除栈顶的 <span class=\"math inline\">\\(a_i\\)</span> 个元素，然后向栈顶加入 <span class=\"math inline\">\\(b_i\\)</span> 个元素。</li>\n</ul>\n<p>现在每个时刻都让一个人去执行事件，需要满足每个元素，加入它的和删除它的不能是同一个人。问最少需要多少个人才能实现这一点。输出方案。有 SPJ。</p>\n<p><span class=\"math inline\">\\(n\\le 10^5,V=10^9\\)</span>。</p>\n</blockquote>\n<ul>\n<li>可以猜到答案只会为 1 2 3，尝试从图染色的角度考虑这个问题（<strong>怎么想到这一点？</strong>）。</li>\n<li>一个元素在哪个时刻被加入 / 删除是固定的，故如果两天有冲突，可以考虑直接连边。考虑模拟，能够线性地求出来所有冲突关系，故边数是 <span class=\"math inline\">\\(O(n)\\)</span> 的。</li>\n<li><p>由于这个栈的结构，发现不存在交错的边，或者说不同时存在 <span class=\"math inline\">\\((x_1,y_1)\\)</span> 和 <span class=\"math inline\">\\((x_2,y_2)\\)</span>，使得 <span class=\"math inline\">\\(x_1&lt;x_2&lt;y_1&lt;y_2\\)</span>。考虑构造解：</p>\n<p>首先对于 <span class=\"math inline\">\\(1,n\\)</span> 任意涂色，忽略 <span class=\"math inline\">\\((1,n)\\)</span> 这条边（如果有），显然可以找到一个 <span class=\"math inline\">\\(mid\\)</span> 使得没有边跨过之，给其赋一个合法的颜色，接着就可以分治构造。</p>\n<p>感觉这种构造不算太显然，只能算是能想到（实际上并没有）。</p>\n<p>具体分治，由于性质比较好，直接取左端点对应范围内最远的边即可。</p></li>\n<li><p>需要注意上述构造方案能保证可以构造出 <span class=\"math inline\">\\(k=3\\)</span> 的解，但不能保证是最优的（即不能保证 <span class=\"math inline\">\\(k=1\\)</span> 或 <span class=\"math inline\">\\(k=2\\)</span> 也能构造出对应的解），故需要特判没有边 + 二分图两种情况。</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n    std::freopen(&quot;fire.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;fire.out&quot;, &quot;w&quot;, stdout);\n#else\n    // std::freopen(&quot;./test/20251022/fire/fire2.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;std::pair&lt;int, int&gt; &gt; a(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i].first &gt;&gt; a[i].second;\n    bool flag = true;\n    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1), g1(n + 1);\n    std::stack&lt;std::pair&lt;int, int&gt; &gt; st;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        for (int j = 0; j &lt; a[i].first; ) &#123;\n            g[st.top().second].push_back(i);\n            g1[st.top().second].push_back(i);\n            g1[i].push_back(st.top().second);\n            flag = false;\n            int to = std::min(st.top().first, a[i].first - j);\n            j += to, st.top().first -= to;\n            if (st.top().first == 0)\n                st.pop();\n        &#125;\n        if (a[i].second)\n            st.emplace(a[i].second, i);\n    &#125;\n    if (flag == true) &#123;\n        std::cout &lt;&lt; 1 &lt;&lt; &#39;\\n&#39;;\n        for (int i = 1; i &lt;= n; ++i)\n            std::cout &lt;&lt; 1 &lt;&lt; &#39; &#39;;\n        std::cout &lt;&lt; &#39;\\n&#39;;\n        return 0;\n    &#125;\n    std::vector&lt;int&gt; col(n + 1);\n    std::function&lt;bool(int, int)&gt; DFS = [&amp;](int x, int now) &#123;\n        col[x] = now;\n        for (auto i : g1[x])\n            if (!col[i]) &#123;\n                if (!DFS(i, 3 - now))\n                    return false;\n            &#125;\n            else if (col[i] == now)\n                return false;\n        return true;\n    &#125;;\n    for (int i = 1; i &lt;= n; ++i)\n        if (!col[i] &amp;&amp; !DFS(i, 1))\n            goto nosol;\n    std::cout &lt;&lt; 2 &lt;&lt; &#39;\\n&#39;;\n    for (int i = 1; i &lt;= n; ++i)\n        std::cout &lt;&lt; col[i] &lt;&lt; &#39; &#39;;\n    std::cout &lt;&lt; &#39;\\n&#39;;\n    return 0;\nnosol: ;\n    col[1] = 1, col[n] = 2;\n    std::function&lt;void(int, int)&gt; calc = [&amp;](int l, int r) &#123;\n        if (r - l + 1 &lt;= 2)\n            return;\n        if (!g[l].empty() &amp;&amp; g[l].back() == r)\n            g[l].pop_back();\n        int pos = g[l].empty() ? l + 1 : g[l].back();\n        col[pos] = 6 - col[l] - col[r];\n        calc(l, pos), calc(pos, r);\n        return;\n    &#125;;\n    calc(1, n);\n    std::cout &lt;&lt; 3 &lt;&lt; &#39;\\n&#39;;\n    for (int i = 1; i &lt;= n; ++i)\n        std::cout &lt;&lt; col[i] &lt;&lt; &#39; &#39;;\n    std::cout &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"c.-适格者\">C. 适格者</h2>\n<p><a href=\"https://www.becoder.com.cn/contest/6666/problem/3\" class=\"uri\">https://www.becoder.com.cn/contest/6666/problem/3</a></p>\n<blockquote>\n<p>给定长度为 <span class=\"math inline\">\\(2^n\\)</span> 的数组 <span class=\"math inline\">\\(a_{0,\\cdots,2^n-1}\\)</span>，维护 <span class=\"math inline\">\\(q\\)</span> 次操作：</p>\n<ul>\n<li>修改：单点加；</li>\n<li>修改：高维前缀加；</li>\n<li>修改：高维后缀加；</li>\n<li>询问：高维前缀和，对 <span class=\"math inline\">\\(998244353\\)</span> 取模；</li>\n</ul>\n<p><span class=\"math inline\">\\(n\\le 20,q\\le 10^5\\)</span>。</p>\n</blockquote>\n<ul>\n<li>单点加 + 高维前缀和会反应出 <a href=\"/20250907/#e---subset-product-problem\">ARC205E</a> 的 trick</li>\n<li><p>考虑怎么做后缀加，会反应过来和 <a href=\"/20251010/#区间修改区间查询\">bit 的区间修改</a> 有一致性，修改相当于单点修改差分数组。考虑类似的推导：</p>\n<p><span class=\"math display\">\\[\n\\begin{aligned}\n\\sum_{s\\subseteq S}a_s&amp;=\\sum_{s\\subseteq S} \\sum_{i\\subseteq s} d_i\\\\\n&amp;=\\sum_{i\\subseteq S} 2^{|S|-|i|}\\times d_i\n\\end{aligned}\n\\]</span></p>\n<p>故维护 <span class=\"math inline\">\\(2^{-|i|}\\cdot d_i\\)</span> 即可（原来取模是拿来搞这个的）。类似地可以推导前缀加：</p>\n<p><span class=\"math display\">\\[\n\\begin{aligned}\n\\sum_{s\\subseteq S}a_s&amp;=\\sum_{s\\subseteq S} \\sum_{i\\supseteq s} d_i\\\\\n&amp;=\\sum_{i\\subseteq S} 2^{|S \\text{ bitand } i|}\\times d_i\n\\end{aligned}\n\\]</span></p>\n<p>发现这个 bitand 不太好搞，不过 bitand 是对位的，所以依然可以套在分块上</p>\n<p>同时，因为问的是前缀和，所以单点的 <span class=\"math inline\">\\(S\\text{ bitand } i\\)</span> 其实就是 <span class=\"math inline\">\\(i\\)</span>。这里有点囿于 fmt 的思维定势了，实际上可以直接认为 <span class=\"math inline\">\\(f_{s_1, s_2}\\)</span> 维护的是这个点处的答案，每次更新对 <span class=\"math inline\">\\(f_{s_1,*}\\)</span> 的贡献即可。</p></li>\n</ul>\n<details>\n<p>不知为何很慢</p>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 998244353;\nconst int inv2 = (mod + 1) &gt;&gt; 1;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n    std::freopen(&quot;gene.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;gene.out&quot;, &quot;w&quot;, stdout);\n#else\n    // std::freopen(&quot;./test/20251022/gene/gene5.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, q;\n    std::cin &gt;&gt; n &gt;&gt; q;\n    const int N1 = n / 2, N2 = n - N1, lim = 1 &lt;&lt; N2;\n    std::vector&lt;long long&gt; inv(n + 1);\n    inv[0]= 1ll;\n    for (int i = 1; i &lt;= n; ++i)\n        inv[i] = inv[i - 1] * inv2 % mod;\n    std::vector&lt;std::vector&lt;long long&gt; &gt; s(1 &lt;&lt; N1, std::vector&lt;long long&gt; (lim));\n    auto s1(s), s2(s);\n    for (int op, x; q--; ) &#123;\n        std::cin &gt;&gt; op &gt;&gt; x;\n        int X1 = x &gt;&gt; N2, X2 = x &amp; (lim - 1);\n        if (op == 0) &#123;\n            auto res = 0ll, res1 = 0ll, res2 = 0ll;\n            for (int i = 0; i &lt; (1 &lt;&lt; N1); ++i)\n                res2 += (1 &lt;&lt; __builtin_popcount(i &amp; X1)) * s2[i][X2] % mod;\n            for (int i = X1; ; i = X1 &amp; (i - 1)) &#123;\n                res += s[i][X2];\n                res1 += s1[i][X2] * (1 &lt;&lt; __builtin_popcount(x)) % mod;\n                if (i == 0)\n                    break;\n            &#125;\n            std::cout &lt;&lt; (res + res1 + res2) % mod &lt;&lt; &#39;\\n&#39;;\n        &#125;\n        else if (op == 1) &#123;\n            int v;\n            std::cin &gt;&gt; v;\n            int X3 = (lim - 1) ^ X2;\n            for (int i = X3; ; i = X3 &amp; (i - 1)) &#123;\n                (s[X1][(lim - 1) ^ i] += v) %= mod;\n                if (i == 0)\n                    break;\n            &#125;\n        &#125;\n        else if (op == 2) &#123;\n            long long v;\n            std::cin &gt;&gt; v, (v *= inv[__builtin_popcount(x)]) %= mod;\n            int X3 = (lim - 1) ^ X2;\n            for (int i = X3; ; i = X3 &amp; (i - 1)) &#123;\n                (s1[X1][(lim - 1) ^ i] += v) %= mod;\n                if (i == 0)\n                    break;\n            &#125;\n        &#125;\n        else &#123;\n            long long v;\n            std::cin &gt;&gt; v;\n            for (int i = 0; i &lt; lim; ++i)\n                (s2[X1][i] += v * (1 &lt;&lt; __builtin_popcount(i &amp; X2))) %= mod;\n        &#125;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"cf1784c-monsters-hard-version\">CF1784C Monsters (hard version)</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/CF1784C\" class=\"uri\">https://www.luogu.com.cn/problem/CF1784C</a></p>\n<ul>\n<li><p>通过若干次 1 操作，把数列的值域变成包含 1 且连续的，然后执行 2 操作，一定不劣</p></li>\n<li><p>考虑怎么快速维护这个东西，发现只关心初始序列和目标序列（从计算代价的式子可以看出来），故考虑这样一个构造最终序列的方式：</p>\n<ul>\n<li>从前到后遍历值域上的每个空位，找到第一个大于之的元素，并放过来，重复执行直到上述步骤不能执行为止。</li>\n</ul>\n<p>直接考虑一次加点带来的影响似乎非常复杂，但如果时光倒流，发现有贪心策略，直接把最后一次操作挪到这个新的空位即可。</p></li>\n<li><p>电波题！用 set 维护即可。</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int T;\n    for (std::cin &gt;&gt; T; T--; ) &#123;\n        int n;\n        std::cin &gt;&gt; n;\n        std::set&lt;std::pair&lt;int, int&gt; &gt; t;\n        std::vector&lt;long long&gt; res(n + 1);\n        std::vector&lt;int&gt; a(n + 1), to(n + 1), at(n + 1);\n        for (int i = 1; i &lt;= n; ++i)\n            std::cin &gt;&gt; a[i], t.emplace(a[i], i);\n        int now;\n        for (now = 1; ; ++now) &#123;\n            auto p(t.lower_bound(&#123; now, 0 &#125;));\n            if (p == t.end())\n                break;\n            at[now] = p-&gt;second;\n            to[p-&gt;second] = now;\n            res[n] += p-&gt;first - now;\n            t.erase(p);\n        &#125;\n        --now;\n        for (int i = n - 1; i; --i) &#123;\n            res[i] = res[i + 1];\n            if (to[i + 1]) &#123;\n                res[i] -= a[i + 1] - to[i + 1];\n                auto p = t.lower_bound(&#123; to[i + 1], 0 &#125;);\n                if (p != t.end()) &#123;\n                    at[to[i + 1]] = p-&gt;second;\n                    to[p-&gt;second] = to[i + 1];\n                    res[i] += a[p-&gt;second] - to[i + 1];\n                    t.erase(p);\n                &#125;\n                else &#123;\n                    res[i] -= a[at[now]] - to[at[now]];\n                    res[i] += a[at[now]] - to[i + 1];\n                    to[at[now]] = to[i + 1];\n                    at[to[i + 1]] = at[now];\n                    --now;\n                &#125;\n            &#125;\n            else\n                t.erase(&#123; a[i + 1], i + 1 &#125;);\n        &#125;\n        for (int i = 1; i &lt;= n; ++i)\n            std::cout &lt;&lt; res[i] &lt;&lt; &#39; &#39;;\n        std::cout &lt;&lt; &#39;\\n&#39;;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"cf891c-envy\">CF891C Envy</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/CF891C\" class=\"uri\">https://www.luogu.com.cn/problem/CF891C</a></p>\n<p>mobai ddxrS</p>\n<ul>\n<li><p>经典结论：在做完权值 <span class=\"math inline\">\\(&lt;w\\)</span> 的 Kruskal 后，权值 <span class=\"math inline\">\\(=w\\)</span> 的边以任意顺序加入 Kruskal 后，并查集连通性完全一致。</p></li>\n<li><p>Another 经典结论：一条权值为 <span class=\"math inline\">\\(w\\)</span> 的边可以属于 mst，当且仅当在做完权值 <span class=\"math inline\">\\(&lt;w\\)</span> 的 Kruskal 后，这条边加入不形成环。</p></li>\n<li><p>重要事实：把并查集的 <code>merge</code> 操作打乱，连通性不变。</p></li>\n<li><p>结合起来得到这个神秘做法：按照边权做 Kruskal 检验每条边是否可以加入 mst，如果可以则记录合并的两个根，作为<strong>新边</strong>（不带权）。</p>\n<p><mark>重要事实：对于 <span class=\"math inline\">\\(n-1\\)</span> 条<strong>新边</strong>，要么有环，要么形成 mst。</mark></p>\n<p>推广：对于任意条<strong>新边</strong>，要么有环，要么可以通过某种选取其他<strong>新边</strong>的方式形成 mst。</p>\n<p>故 check 给定边的<strong>新边</strong>是否成环即可。算是一个 trick 吗？</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    const int M = 5e5;\n    int n, m;\n    std::cin &gt;&gt; n &gt;&gt; m;\n    std::vector&lt;std::pair&lt;int, int&gt; &gt; ne(m + 1);\n    std::vector&lt;std::vector&lt;std::tuple&lt;int, int, int&gt; &gt; &gt; e(M + 1); \n    for (int i = 1, x, y, w; i &lt;= m; ++i) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y &gt;&gt; w;\n        e[w].emplace_back(x, y, i);\n    &#125;\n    std::vector&lt;int&gt; f(n + 1);\n    std::iota(f.begin() + 1, f.end(), 1);\n    std::function&lt;int(int)&gt; find = [&amp;](int x) &#123;\n        return x == f[x] ? x : f[x] = find(f[x]);\n    &#125;;\n    for (int i = 1; i &lt;= M; ++i) &#123;\n        for (auto [u, v, id] : e[i])\n            ne[id] = &#123; find(u), find(v) &#125;;\n        for (auto [u, v, id] : e[i])\n            f[find(u)] = find(v);\n    &#125;\n    std::iota(f.begin() + 1, f.end(), 1);\n    int q;\n    for (std::cin &gt;&gt; q; q--; ) &#123;\n        int k;\n        std::cin &gt;&gt; k;\n        std::vector&lt;int&gt; pos;\n        bool flag = true;\n        for (int id; k--; ) &#123;\n            std::cin &gt;&gt; id;\n            if (find(ne[id].first) == find(ne[id].second))\n                flag = false;\n            f[find(ne[id].first)] = find(ne[id].second);\n            pos.push_back(ne[id].first);\n            pos.push_back(ne[id].second);\n        &#125;\n        std::cout &lt;&lt; (flag ? &quot;YES&quot; : &quot;NO&quot;) &lt;&lt; &#39;\\n&#39;;\n        for (auto i : pos)\n            f[i] = i;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"c.-山月记\">C. 山月记</h2>\n<p><a href=\"https://www.becoder.com.cn/problem/52034\" class=\"uri\">https://www.becoder.com.cn/problem/52034</a></p>\n<blockquote>\n<p>给定一棵大小为 <span class=\"math inline\">\\(n\\)</span> 的带权无根树 <span class=\"math inline\">\\(T\\)</span>，再给定 <span class=\"math inline\">\\(m\\)</span> 条额外的边，和 <span class=\"math inline\">\\(T\\)</span> 一起形成一个图 <span class=\"math inline\">\\(G\\)</span>。</p>\n<p>定义一个点 <span class=\"math inline\">\\(u\\)</span> 是好的，当且仅当对于<strong>每一个</strong> <span class=\"math inline\">\\(1\\le v\\le n\\)</span>，<strong><span class=\"math inline\">\\(T\\)</span> 上的</strong>简单路径 <span class=\"math inline\">\\((u,v)\\)</span> 都可以被 <span class=\"math inline\">\\(G\\)</span> 的某个 MST <strong>完整</strong>包含。</p>\n<p>输出任意一个好的点。无解输出 <span class=\"math inline\">\\(0\\)</span>。有 SPJ。</p>\n<p><span class=\"math inline\">\\(n,m\\le 10^5\\)</span>，<span class=\"math inline\">\\(w\\le 10^9\\)</span>。</p>\n</blockquote>\n<ul>\n<li><p>参考上一题，朴素做法是 <span class=\"math inline\">\\(O(n^2)\\)</span> 枚举某个 <span class=\"math inline\">\\(x\\)</span> 开头的路径，然后 <span class=\"math inline\">\\(O(len)\\)</span> 地 check；</p>\n<p>注意到这个结构能很好地和 DFS + 回溯结合，用可撤销并查集维护即可在 <span class=\"math inline\">\\(O(n\\log n)\\)</span> 内完成对一个 <span class=\"math inline\">\\(x\\)</span> 所有路径的 check。</p></li>\n<li><p>发现：如果一条路径 <span class=\"math inline\">\\((u,v)\\)</span> 是非法的，进一步所有完整包含 <span class=\"math inline\">\\((u,v)\\)</span> 的路径都是非法的。</p>\n<p><strong>从路径反映到点上</strong>，会发现 <span class=\"math inline\">\\((u,v)\\)</span> 两侧的点都是非法的。下意识考虑不在 <span class=\"math inline\">\\((u,v)\\)</span> 两侧，但在 <span class=\"math inline\">\\((u,v)\\)</span> 之外的点，发现它们仍然有可能合法，只要满足如下情况：</p>\n<p><img src=\"image-3.png\" /></p></li>\n<li><p>也就是说，对于 <span class=\"math inline\">\\(x\\)</span>，如果它出发的所有路径都合法，那么 <span class=\"math inline\">\\(x\\)</span> 自己就是答案；</p>\n<p>如果存在 <span class=\"math inline\">\\(\\ge 2\\)</span> 条非法路径，那么无解；</p>\n<p>否则，存在恰好一条边，在非法边所在的子树中递归求解，发现这很点分治，故可以 <span class=\"math inline\">\\(O(n\\log^2 n)\\)</span> 解决。log 分别来自点分治和撤销并查集。</p></li>\n<li><p>注：这里唐唐的，check 写成点分树子树内 check 了。点分治在这里只起保证递归层数的作用。</p></li>\n</ul>\n<details>\n<p>怎么跑得这么快？推测因为写的是按秩合并。</p>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;./test/20251024/beast/beast1.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int T;\n    for (std::cin &gt;&gt; T; T--; ) &#123;\n        int n, m;\n        std::cin &gt;&gt; n &gt;&gt; m;\n        std::vector&lt;int&gt; l(1);\n        std::vector&lt;std::pair&lt;int, int&gt; &gt; ne(m + 1);\n        std::vector&lt;std::tuple&lt;int, int, int&gt; &gt; se(m + 1);\n        std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; g(n + 1);\n        std::vector&lt;std::vector&lt;std::tuple&lt;int, int, int&gt; &gt; &gt; e(m + 1); \n        for (int i = 1, x, y, w; i &lt;= m; ++i) &#123;\n            std::cin &gt;&gt; x &gt;&gt; y &gt;&gt; w;\n            se[i] = &#123; x, y, w &#125;, l.push_back(w);\n            if (i &lt; n)\n                g[x].emplace_back(y, i), g[y].emplace_back(x, i);\n        &#125;\n        std::sort(l.begin() + 1, l.end());\n        l.erase(std::unique(l.begin() + 1, l.end()), l.end());\n        for (int i = 1; i &lt;= m; ++i) &#123;\n            auto [x, y, w] = se[i];\n            w = std::lower_bound(l.begin() + 1, l.end(), w) - l.begin();\n            e[w].emplace_back(x, y, i);\n        &#125;\n        std::vector&lt;int&gt; f(n + 1);\n        std::iota(f.begin() + 1, f.end(), 1);\n        std::function&lt;int(int)&gt; find = [&amp;](int x) &#123;\n            return x == f[x] ? x : f[x] = find(f[x]);\n        &#125;;\n        for (int i = 1; i &lt;= m; ++i) &#123;\n            for (auto [u, v, id] : e[i])\n                ne[id] = &#123; find(u), find(v) &#125;;\n            for (auto [u, v, id] : e[i])\n                f[find(u)] = find(v);\n        &#125;\n        std::vector&lt;int&gt; tag(n + 1), p, siz(n + 1), mx(n + 1);\n        std::function&lt;void(int, int)&gt; DFS1 = [&amp;](int x, int fa) &#123;\n            p.push_back(x);\n            siz[x] = 1, mx[x] = 0;\n            for (auto [i, id] : g[x])\n                if (i != fa &amp;&amp; !tag[i]) &#123;\n                    DFS1(i, x);\n                    siz[x] += siz[i];\n                    mx[x] = std::max(mx[x], siz[i]);\n                &#125;\n            return;\n        &#125;;\n        auto findrt = [&amp;](int x) &#123;\n            p.clear(), DFS1(x, -1);\n            int n = (int)p.size();\n            for (auto i : p)\n                if (mx[i] &lt;= n / 2 &amp;&amp; n - siz[i] &lt;= n / 2)\n                    return i;\n            assert(0);\n            return -1;\n        &#125;;\n        std::vector&lt;int&gt; rank(n + 1);\n        std::stack&lt;std::tuple&lt;int, int, int&gt; &gt; st;\n        find = [&amp;](int x) &#123;\n            return x == f[x] ? x : find(f[x]);\n        &#125;;\n        auto merge = [&amp;](int x, int y) &#123;\n            x = find(x), y = find(y);\n            if (x == y)\n                return true;\n            if (rank[x] &lt;= rank[y])\n                st.emplace(x, y, rank[y]), f[x] = y;\n            else \n                st.emplace(y, x, rank[x]), f[y] = x;\n            if (rank[x] == rank[y])\n                ++rank[y];\n            return false;\n        &#125;;\n        auto undo = [&amp;](void) &#123;\n            assert(!st.empty());\n            auto [x, y, ry] = st.top();\n            st.pop();\n            f[x] = x, rank[y] = ry;\n            return;\n        &#125;;\n        std::function&lt;bool(int, int)&gt; DFS2 = [&amp;](int x, int fa) &#123;\n            for (auto [i, id] : g[x])\n                if (i != fa &amp;&amp; (merge(ne[id].first, ne[id].second) || DFS2(i, x))) &#123;\n                    undo();\n                    return true;\n                &#125;\n            undo();\n            return false;\n        &#125;;\n        std::function&lt;bool(int)&gt; DFS = [&amp;](int x) &#123;\n            x = findrt(x);\n            int to = 0;\n            for (auto [i, id] : g[x])\n                if (merge(ne[id].first, ne[id].second) || DFS2(i, x)) &#123;\n                    if (!to) to = i;\n                    else &#123;\n                        std::cout &lt;&lt; 0 &lt;&lt; &#39;\\n&#39;;\n                        return true;\n                    &#125;\n                &#125;\n            assert(st.empty());\n            tag[x] = 1;\n            if (to) &#123;\n                if (tag[to]) &#123;\n                    std::cout &lt;&lt; 0 &lt;&lt; &#39;\\n&#39;;\n                    return true;\n                &#125;\n                return DFS(to);\n            &#125;\n            std::cout &lt;&lt; x &lt;&lt; &#39;\\n&#39;;\n            return true;\n        &#125;;\n        std::iota(f.begin() + 1, f.end(), 1);\n        assert(DFS(1));\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"b.-电报-a.-神灵庙-cf2068d-morse-code\">B. 电报 / A. 神灵庙 / CF2068D Morse Code</h2>\n<p><a href=\"https://www.becoder.com.cn/contest/6676/problem/2\" class=\"uri\">https://www.becoder.com.cn/contest/6676/problem/2</a> / <a href=\"https://www.becoder.com.cn/contest/5527/problem/1\" class=\"uri\">https://www.becoder.com.cn/contest/5527/problem/1</a> / <a href=\"https://www.luogu.com.cn/problem/CF2068D\" class=\"uri\">https://www.luogu.com.cn/problem/CF2068D</a></p>\n<blockquote>\n<p>一个无限大的完全二叉树，根节点权值为 <span class=\"math inline\">\\(0\\)</span>，一个点的左儿子权值是这个点的权值 <span class=\"math inline\">\\(+1\\)</span>，右儿子为 <span class=\"math inline\">\\(+2\\)</span>。</p>\n<p>给定 <span class=\"math inline\">\\(c_1,\\cdots, c_n\\)</span>，挑选 <span class=\"math inline\">\\(n\\)</span> 个互不为祖孙的点，最终代价为点权 <span class=\"math inline\">\\(\\times\\)</span> 对应的 <span class=\"math inline\">\\(c\\)</span> 之和。</p>\n</blockquote>\n<ul>\n<li><p>一个基本的观察：权值对应相邻两种值的结点数总是构成类似斐波那契的结构。显然应该把权值和点权逆大小对应。</p>\n<p>朴素 DP：令 <span class=\"math inline\">\\(f_{i,j,a,b}\\)</span> 表示当前枚举到权值 <span class=\"math inline\">\\(i\\)</span>，已经选了 <span class=\"math inline\">\\(j\\)</span> 个点，<span class=\"math inline\">\\(i-1\\)</span>、<span class=\"math inline\">\\(i\\)</span> 分别剩余 <span class=\"math inline\">\\(a,b\\)</span> 个点的最小代价，可以得到 <span class=\"math inline\">\\(n^5\\)</span> 的惊人转移。</p></li>\n<li><p>经典 trick：最后一层循环的枚举是无必要的，可以一个一个转移（类似完全背包）。这样就少了一个 <span class=\"math inline\">\\(n\\)</span>。如果观察到最深取到 1.5 log（斐波那契）能砍成 <span class=\"math inline\">\\(O(n^3\\log n)\\)</span>。</p></li>\n<li><p>接着，发现可以费用提前计算（这里我觉得更像是算贡献），少枚举一个 <span class=\"math inline\">\\(i\\)</span>，这样就是 <span class=\"math inline\">\\(O(n^3)\\)</span> 的了。</p>\n<p>发现没什么实现的头绪。目前有：</p>\n<p><span class=\"math display\">\\[\nf_{j,a,b}\\to f_{j+1,a,b-1}\\\\\nf_{j,a,b}+suf_{j+1}\\to f_{j,b,a+b}\n\\]</span></p>\n<p>以前没有注意到过，其实<strong>枚举顺序是由转移方程决定的</strong>：</p>\n<ul>\n<li>第一种转移中，<span class=\"math inline\">\\(j\\)</span> 是递增的，<span class=\"math inline\">\\(a\\)</span> 水平，<span class=\"math inline\">\\(b\\)</span> 递减；</li>\n<li>第二种转移中，<span class=\"math inline\">\\(j\\)</span> 水平，<span class=\"math inline\">\\(a\\)</span> 无法确定，<span class=\"math inline\">\\(b\\)</span> 不递减；</li>\n</ul>\n<p>可以想到一个转移顺序：正序枚举 <span class=\"math inline\">\\(j\\)</span>，正序枚举 <span class=\"math inline\">\\(b\\)</span>；正序枚举 <span class=\"math inline\">\\(a\\)</span>。</p>\n<p>此时第二种会有点问题，<span class=\"math inline\">\\(j\\)</span> 水平且 <span class=\"math inline\">\\(b\\)</span> 水平时，若 <span class=\"math inline\">\\(a\\)</span> 变小怎么办？发现这要求 <span class=\"math inline\">\\(b&lt;a\\)</span>，则 <span class=\"math inline\">\\(a+b&gt;b\\)</span> 恒成立，<span class=\"math inline\">\\(b\\)</span> 一定不水平。挺牛的这个。</p></li>\n<li><p>卡空间了，滚动一下即可。复杂度 <span class=\"math inline\">\\(O(n^3)\\)</span>。绅士写了神秘玄学<a href=\"https://www.becoder.com.cn/submission/3177578\">做法</a>，瞻仰无果。</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n    std::freopen(&quot;telegram.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;telegram.out&quot;, &quot;w&quot;, stdout);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;int&gt; c(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; c[i];\n    std::sort(c.begin() + 1, c.end(), std::greater&lt;int&gt; ());\n    std::partial_sum(c.rbegin(), c.rend(), c.rbegin());\n    using arr = std::vector&lt;int&gt;;\n    using brr = std::vector&lt;arr&gt;;\n    using crr = std::vector&lt;brr&gt;;\n    crr f(2, brr(n + 1, arr(n + 1))), tag(2, brr(n + 1, arr(n + 1, -1)));\n    f[0][1][1] = c[1], tag[0][1][1] = 0;\n    auto upd = [&amp;](int i, int &amp;t, int &amp;x, int y) &#123;\n        if (t == i)\n            x = std::min(x, y);\n        else\n            x = y, t = i;\n        return;\n    &#125;;\n    for (int j = 0, k = 0; j &lt; n; ++j, k ^= 1) &#123;\n        for (int b = 0; b &lt;= n; ++b)\n            for (int a = 0; a &lt;= n; ++a)\n                if (tag[k][b][a] == j) &#123;\n                    if (b)\n                        upd(j + 1, tag[k ^ 1][b - 1][a], f[k ^ 1][b - 1][a], f[k][b][a]);\n                    if (a + b &lt;= n)\n                        upd(j, tag[k][a + b][b], f[k][a + b][b], f[k][b][a] + c[j + 1]);\n                &#125;\n    &#125;\n    auto res = 0x3f3f3f3f;\n    for (int b = 0; b &lt;= n; ++b)\n        for (int a = 0; a &lt;= n; ++a)\n            if (tag[n &amp; 1][b][a] == n)\n                res = std::min(res, f[n &amp; 1][b][a]);\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"coi-2019-tenis\">[COI 2019] TENIS</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P11340\" class=\"uri\">https://www.luogu.com.cn/problem/P11340</a></p>\n<ul>\n<li><p>观察一：<span class=\"math inline\">\\(x\\)</span> 能获胜，当且仅当存在一个 <span class=\"math inline\">\\(y\\)</span>，使得 <span class=\"math inline\">\\(x\\)</span> 能战胜 <span class=\"math inline\">\\(y\\)</span>，且 <span class=\"math inline\">\\(y\\)</span> 能在剩下 <span class=\"math inline\">\\(n-1\\)</span> 个人中获胜。</p>\n<p>发现这是一个递归，或者说链式的关系。</p></li>\n<li><p>观察二：不妨把三个数组视为三条链，那么发现任意一个链首在任意局面总是能获胜。如果一个人能战胜链首，显然这个人能获胜。反过来，若不能通过任何方式战胜链首，显然无法获胜。</p>\n<p>然后就变成连通性问题了。但很容易猜到带删边连通性没什么优化的前途。</p>\n<p><em>只有加边的带修连通性问题：<a href=\"https://www.luogu.com.cn/article/taefjy3d\">整体二分</a></em>。</p></li>\n<li><p>观察三：链首不能被 <span class=\"math inline\">\\(x\\)</span> 战胜，当且仅当存在一个 <span class=\"math inline\">\\(i\\)</span>，三条链的前 <span class=\"math inline\">\\(i\\)</span> 个元素集相同，且 <span class=\"math inline\">\\(x\\)</span> 位于最小的 <span class=\"math inline\">\\(i\\)</span> 之后。</p>\n<p>这个看起来和 <a href=\"https://www.luogu.com.cn/problem/CF526F\">Puuding Monsters</a> / <a href=\"https://www.luogu.com.cn/problem/CF997E\">Good Subsegments</a> 比较像，实际上思路上也有共通之处：<strong>如果合法区间的值域是连续的，可以把条件转化为 min / max 问题。</strong></p>\n<p>考虑先使其<strong>询问区间内值域连续</strong>以套用这样的方法。可以对链 1 重标号为 <span class=\"math inline\">\\(1\\cdots n\\)</span>，维护链 2、3 的答案；也可以维护三个 rank 上的答案。法一实现起来有很多不必要的令人讨厌的地方，故写法二。</p></li>\n<li><p>相当于求一个最小的 <span class=\"math inline\">\\(i\\)</span> 使得链 1、2、3 在 <span class=\"math inline\">\\(i\\)</span> 之前的所有元素 rank 都不能比 <span class=\"math inline\">\\(i\\)</span> 大。主体为 <span class=\"math inline\">\\(i\\)</span> 时，（因为最小这个限制，和依次改动会带来很大的偏移），所以不太好维护；</p>\n<p>但是正确的维护方式很难想到！令 <span class=\"math inline\">\\(f_i,g_i\\)</span> 分别表示链 2、3 的每个 <span class=\"math inline\">\\(1\\le j\\le n\\)</span>，满足 <span class=\"math inline\">\\(\\min(r_{1/2/3,j})\\)</span>、<span class=\"math inline\">\\(\\max(r_{1/2/3,j})= i\\)</span> 的 <span class=\"math inline\">\\(j\\)</span> 的数量。如果二者在 <span class=\"math inline\">\\(i\\)</span> 处的前缀和相等，那么 <span class=\"math inline\">\\(i\\)</span> 就是合法的。</p>\n<blockquote>\n<p>Fractures（新角色）：这是个很常见的 trick。</p>\n<p>Fractures：这个和 Pudding Monsters 哪里像了。是你唐。</p>\n</blockquote>\n<p>维护 <span class=\"math inline\">\\(f_i-g_i\\)</span> 的前缀和；线段树维护区间修改和全局 min 即可。</p></li>\n</ul>\n<details>\n<p>莫名很慢。和 TTpandaS 相比多了一次建树（但不应该有这么大的影响才对）。</p>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 1e5 + 5;\nstruct &#123; int l, r, mn, at, d; &#125; t[maxn &lt;&lt; 2];\n#define lt (p &lt;&lt; 1)\n#define rt (lt | 1)\nvoid pushup(int p) &#123;\n    t[p].mn = std::min(t[lt].mn, t[rt].mn);\n    if (t[lt].mn == t[p].mn)\n        t[p].at = t[lt].at;\n    else\n        t[p].at = t[rt].at;\n    return;\n&#125;\nvoid pushdown(int p) &#123;\n    if (t[p].d) &#123;\n        t[lt].d += t[p].d, t[lt].mn += t[p].d;\n        t[rt].d += t[p].d, t[rt].mn += t[p].d;\n        t[p].d = 0;\n    &#125;\n    return;\n&#125;\nvoid bld(int p, int l, int r) &#123;\n    t[p].l = l, t[p].r = r;\n    if (l == r) &#123;\n        t[p].at = l;\n        return;\n    &#125;\n    int mid = (l + r) &gt;&gt; 1;\n    bld(lt, l, mid), bld(rt, mid + 1, r);\n    pushup(p);\n    return;\n&#125;\nvoid add(int p, int l, int r, int v) &#123;\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r) &#123;\n        t[p].d += v, t[p].mn += v;\n        return;\n    &#125;\n    pushdown(p);\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (l &lt;= mid)\n        add(lt, l, r, v);\n    if (r &gt; mid)\n        add(rt, l, r, v);\n    pushup(p);\n    return;\n&#125;\n#undef lt\n#undef rt\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n    std::freopen(&quot;match.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;match.out&quot;, &quot;w&quot;, stdout);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, q;\n    std::cin &gt;&gt; n &gt;&gt; q;\n    std::vector&lt;std::vector&lt;int&gt; &gt; p(3, std::vector&lt;int&gt; (n + 1));\n    for (int k = 0; k &lt; 3; ++k)\n        for (int i = 1, x; i &lt;= n; ++i)\n            std::cin &gt;&gt; x, p[k][x] = i;\n    bld(1, 1, n);\n    auto upd = [&amp;](int i, int k) &#123;\n        add(1, std::min(&#123; p[0][i], p[1][i], p[2][i] &#125;), n, k);\n        add(1, std::max(&#123; p[0][i], p[1][i], p[2][i] &#125;), n, -k);\n        return;\n    &#125;;\n    for (int i = 1; i &lt;= n; ++i)\n        upd(i, 1);\n    int now = t[1].at;\n    // printf(&quot;now = %d \\n&quot;, now);\n    for (int op; q--; ) &#123;\n        std::cin &gt;&gt; op;\n        if (op == 1) &#123;\n            int x;\n            std::cin &gt;&gt; x;\n            std::cout &lt;&lt; (std::min(&#123; p[0][x], p[1][x], p[2][x] &#125;) &lt;= now ? &quot;Yes&quot; : &quot;No&quot;) &lt;&lt; &#39;\\n&#39;;\n        &#125;\n        else &#123;\n            int k, i, j;\n            std::cin &gt;&gt; k &gt;&gt; i &gt;&gt; j, --k;\n            upd(i, -1), upd(j, -1);\n            std::swap(p[k][i], p[k][j]);\n            upd(i, 1), upd(j, 1);\n            now = t[1].at;\n            // printf(&quot;now = %d \\n&quot;, now);\n        &#125;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n",
            "tags": [
                "线段树",
                "贪心",
                "优化建图",
                "DP 优化",
                "树链剖分 - 最小生成树"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20250921/",
            "url": "https://xsc062.netlify.app/20250921/",
            "title": "线段树杂题",
            "date_published": "2025-09-21T08:44:54.000Z",
            "content_html": "<p>信息转化为主</p>\n<span id=\"more\"></span>\n<hr />\n<h2 id=\"b---into-blocks-hard-version\">B - Into Blocks (hard version)</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/CF1209G2\" class=\"uri\">https://www.luogu.com.cn/problem/CF1209G2</a></p>\n<ul>\n<li>trick：考察每个颜色出现的区间 <span class=\"math inline\">\\([s_{col},t_{col}]\\)</span>，对每个 <span class=\"math inline\">\\([s_{col},t_{col})\\)</span> 打标记，则没有被打过标记的点后能够进行一次分段。</li>\n<li><p>对于每一段，其代价为段长度 - 众数出现次数。</p>\n这个众数乍一看有点吓人，实际上发现由于每个元素出现的所有位置都在这个段里，所以可以记录每个元素的个数，对于每个元素只钦定其中一个位置来记录即可快速维护。</li>\n<li>发现线段树能够比较容易地维护全局查询：维护 <span class=\"math inline\">\\(0\\)</span> 位置是经典 trick；且容易发现『段长』之和为 <span class=\"math inline\">\\(n\\)</span>，故只需维护众数。</li>\n<li><p>实现技巧：单点本身就是自己的最小值，从这一点出发可以规避很多边界情况。</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int lim = 2e5;\nconst int maxn = 2e5 + 5;\nstruct node &#123;\n    int l, r, u, d;\n    int lu, ru, mn, mx;\n    node operator+ (const node &amp;q) const &#123;\n        node res;\n        res.d = 0;\n        res.l = l, res.r = q.r;\n        res.mx = std::max(mx, q.mx);\n        res.mn = std::min(mn, q.mn);\n        if (mn &lt; q.mn) &#123;\n            res.mn = mn, res.u = u;\n            res.lu = lu, res.ru = std::max(q.mx, ru);\n        &#125;\n        else if (q.mn &lt; mn) &#123;\n            res.mn = q.mn, res.u = q.u;\n            res.lu = std::max(mx, q.lu), res.ru = q.ru;\n        &#125;\n        else &#123;\n            res.lu = lu, res.ru = q.ru;\n            res.u = u + q.u + std::max(ru, q.lu);\n        &#125;\n        return res;\n    &#125;\n&#125; t[maxn &lt;&lt; 2];\n#define lt (p &lt;&lt; 1)\n#define rt (lt | 1)\nvoid bld(int p, int l, int r) &#123;\n    t[p].l = l, t[p].r = r;\n    if (l == r)\n        return;\n    int mid = (l + r) &gt;&gt; 1;\n    bld(lt, l, mid), bld(rt, mid + 1, r);\n    return;\n&#125;\nvoid pushval(int p, int d) &#123;\n    t[p].mn += d, t[p].d += d;\n    return;\n&#125;\nvoid pushdown(int p) &#123;\n    pushval(lt, t[p].d), pushval(rt, t[p].d);\n    t[p].d = 0;\n    return;\n&#125;\nvoid upd(int p, int x, int v) &#123;\n    if (t[p].l == t[p].r) &#123;\n        t[p].u = t[p].mx = v;\n        return;\n    &#125;\n    pushdown(p);\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (x &lt;= mid)\n        upd(lt, x, v);\n    else\n        upd(rt, x, v);\n    t[p] = t[lt] + t[rt];\n    return;\n&#125;\nvoid add(int p, int l, int r, int v) &#123;\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r) &#123;\n        pushval(p, v);\n        return;\n    &#125;\n    pushdown(p);\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (l &lt;= mid)\n        add(lt, l, r, v);\n    if (r &gt; mid)\n        add(rt, l, r, v);\n    t[p] = t[lt] + t[rt];\n    return;\n&#125;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, q;\n    std::cin &gt;&gt; n &gt;&gt; q;\n    std::vector&lt;int&gt; a(n + 1);\n    std::vector&lt;std::set&lt;int&gt; &gt; st(lim + 1);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; a[i];\n        st[a[i]].emplace(i);\n    &#125;\n    bld(1, 1, n);\n    for (int i = 1; i &lt;= lim; ++i)\n        if (!st[i].empty()) &#123;\n            int s = *st[i].begin(), t = *--st[i].end();\n            if (s &lt;= t - 1)\n                add(1, s, t - 1, 1);\n            upd(1, s, (int)st[i].size());\n        &#125;\n    std::cout &lt;&lt; n - ::t[1].u - ::t[1].lu - ::t[1].ru  &lt;&lt; &#39;\\n&#39;;\n    auto work = [&amp;](int v, int k) &#123;\n        if (st[v].empty())\n            return;\n        int s = *st[v].begin(), t = *--st[v].end();\n        if (s &lt;= t - 1)\n            add(1, s, t - 1, k);\n        upd(1, s, k == 1 ? (int)st[v].size() : 0);\n        return;\n    &#125;;\n    for (int i, x; q--; ) &#123;\n        std::cin &gt;&gt; i &gt;&gt; x;\n        work(a[i], -1), st[a[i]].erase(i), work(a[i], 1);\n        a[i] = x;\n        work(a[i], -1), st[a[i]].insert(i), work(a[i], 1);\n        std::cout &lt;&lt; n - ::t[1].u - ::t[1].lu - ::t[1].ru  &lt;&lt; &#39;\\n&#39;;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"c---seats-排座位\">C - seats 排座位</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P4898\" class=\"uri\">https://www.luogu.com.cn/problem/P4898</a></p>\n<p>很有价值的一个题</p>\n<ul>\n<li><p>对于一个固定的 <span class=\"math inline\">\\(k\\)</span>，考虑怎么刻画合法矩形</p>\n<p>发现『前 <span class=\"math inline\">\\(k\\)</span> 个元素构成矩形』比『大小为 <span class=\"math inline\">\\(k\\)</span> 的矩形包含前 <span class=\"math inline\">\\(k\\)</span> 个元素』更合理</p></li>\n<li><p>考虑前 <span class=\"math inline\">\\(k\\)</span> 个元素在满足什么条件时构成矩形</p>\n<p>我最开始的想法是『记录这 <span class=\"math inline\">\\(k\\)</span> 个元素占据的最大、最小、最左、最右，如果乘起来为 <span class=\"math inline\">\\(k\\)</span>，那么合法』</p>\n<p>但会发现这个转化是不好做的，或者说就又往上面那个错误的判定转化（大小为 <span class=\"math inline\">\\(k\\)</span> 的矩形包含前 <span class=\"math inline\">\\(k\\)</span> 个元素）靠了。两个都有一个共同的问题，就是过于依赖这个 <span class=\"math inline\">\\(k\\)</span>，限制太具体了，导致不能很好地应用到每个 <span class=\"math inline\">\\(k\\)</span></p>\n<p>现在这个判定的转化比较合理的地方就在于，对矩形本身不存在约束，只是要求构成矩形。这样就允许直接从图形出发，<strong>更多地考虑怎样用单点信息合并出矩形与否</strong></p></li>\n<li><p>把 <span class=\"math inline\">\\([0,k)\\)</span> 染成黑色，其他为白色，那么有一个粗暴但简单的方法来刻画『矩形』这个要求：</p>\n<blockquote>\n<p>图形存在四个『角』。</p>\n</blockquote>\n<p>再刻画一下『角』：黑点左上 / 左下 / 右上 / 右下两个点都为白。</p>\n<p><strong>当然这样是很荒谬的，因为下图显然不只有四个角。</strong></p>\n<p><img src=\"image-1.png\" /></p>\n<p>所以我们不得不把一个凹角也算作角，不难发现把上方凸角的定义中的主体换成白点即可定义凹角。</p></li>\n<li><p>优化：算贡献</p>\n<p>维护当前时刻，所有 <span class=\"math inline\">\\(4nm\\)</span> 个角在 <span class=\"math inline\">\\(k\\)</span> 处是否存在</p>\n<p>此时要用一个类似维护 <span class=\"math inline\">\\(0\\)</span> 个数的方法来维护有 <span class=\"math inline\">\\(4\\)</span> 个角个数的 <span class=\"math inline\">\\(k\\)</span> 个数。</p></li>\n<li><p>考虑这么一个可能的角：</p>\n<p><img src=\"image.png\" /></p>\n<p>其存在当且仅当 <span class=\"math inline\">\\(A\\)</span> 为黑，<span class=\"math inline\">\\(B,C\\)</span> 为白（凸角），或 <span class=\"math inline\">\\(A\\)</span> 为白，<span class=\"math inline\">\\(B,C\\)</span> 为黑（凹角）。</p>\n<p>考察 <span class=\"math inline\">\\(A,B,C\\)</span> 第一次变黑的时间 <span class=\"math inline\">\\(k_A,k_B,k_C\\)</span>，那么 <span class=\"math inline\">\\(A\\)</span> 能够对所有 <span class=\"math inline\">\\(k\\in[k_A,\\min\\{k_B,k_C\\})\\)</span> 和 <span class=\"math inline\">\\(k\\in[\\max\\{k_B,k_C\\},k_A)\\)</span> 造成贡献。</p></li>\n<li>每次修改只会做 <span class=\"math inline\">\\(O(1)\\)</span> 次区间加，是可维护的。注意两个被交换的点可能会有公共的相邻点，需要特别处理一下。</li>\n<li><p>这个东西本质上可以看作一个 2⨉2 的<a href=\"https://blog.csdn.net/asplh/article/details/136652197\">Soble 算子</a>，所以可以抠出来一般定义上的角</p></li>\n</ul>\n<details>\n<p>non-interactive version:</p>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int dir[][2] = &#123; &#123; 0, -1 &#125;, &#123; 0, 1 &#125;, &#123; -1, 0 &#125;, &#123; 1, 0 &#125; &#125;;\nconst int maxn = 1e6 + 5;\nstruct node &#123;\n    int l, r, u, d, mn;\n    node operator+ (const node &amp;q) const &#123;\n        node res;\n        res.l = l, res.r = q.r, res.d = 0;\n        res.mn = std::min(mn, q.mn), res.u = 0;\n        if (mn == res.mn)\n            res.u = u;\n        if (q.mn == res.mn)\n            res.u += q.u;\n        return res;\n    &#125;\n&#125; t[maxn &lt;&lt; 2];\n#define lt (p &lt;&lt; 1)\n#define rt (lt | 1)\nvoid bld(int p, int l, int r) &#123;\n    t[p].l = l, t[p].r = r, t[p].u = r - l + 1;\n    if (l == r)\n        return;\n    int mid = (l + r) &gt;&gt; 1;\n    bld(lt, l, mid), bld(rt, mid + 1, r);\n    return;\n&#125;\nvoid pushval(int p, int v) &#123;\n    t[p].mn += v, t[p].d += v;\n    return;\n&#125;\nvoid pushdown(int p) &#123;\n    pushval(lt, t[p].d), pushval(rt, t[p].d);\n    t[p].d = 0;\n    return;\n&#125;\nvoid add(int p, int l, int r, int v) &#123;\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r) &#123;\n        pushval(p, v);\n        return;\n    &#125;\n    pushdown(p);\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (l &lt;= mid)\n        add(lt, l, r, v);\n    if (r &gt; mid)\n        add(rt, l, r, v);\n    t[p] = t[lt] + t[rt];\n    return;\n&#125;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, m, q;\n    std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;\n    const int N = n * m;\n    std::vector&lt;std::pair&lt;int, int&gt; &gt; pos(N + 1);\n    std::vector&lt;std::vector&lt;int&gt; &gt; id(n + 2, std::vector&lt;int&gt; (m + 2, N + 1));\n    for (int i = 1, x, y; i &lt;= N; ++i) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y, ++x, ++y;\n        id[x][y] = i, pos[i] = &#123; x, y &#125;;\n    &#125;\n    bld(1, 1, N);\n    auto work = [&amp;](int x, int y, int k) &#123;\n        for (int i = 0; i &lt; 2; ++i)\n            for (int j = 2; j &lt; 4; ++j) &#123;\n                int x1 = x + dir[j][0], y1 = y + dir[i][1];\n                if (id[x][y] &lt; std::min(id[x1][y], id[x][y1]))\n                    add(1, id[x][y], std::min(id[x1][y], id[x][y1]) - 1, k);\n                if (std::max(id[x1][y], id[x][y1]) &lt; id[x][y])\n                    add(1, std::max(id[x1][y], id[x][y1]), id[x][y] - 1, k);\n            &#125;\n        return;\n    &#125;;\n    for (int i = 1; i &lt;= n; ++i)\n        for (int j = 1; j &lt;= m; ++j)\n            work(i, j, 1);\n    for (int i1, i2; q--; ) &#123;\n        std::cin &gt;&gt; i1 &gt;&gt; i2, ++i1, ++i2;\n        auto [x1, y1] = pos[i1];\n        auto [x2, y2] = pos[i2];\n        std::set&lt;std::pair&lt;int, int&gt; &gt; st;\n        st.emplace(x1, y1);\n        for (auto [fx, fy] : dir) &#123;\n            int x = x1 + fx, y = y1 + fy;\n            if (x &gt;= 1 &amp;&amp; x &lt;= n &amp;&amp; y &gt;= 1 &amp;&amp; y &lt;= m)\n                st.emplace(x, y);\n        &#125;\n        st.emplace(x2, y2);\n        for (auto [fx, fy] : dir) &#123;\n            int x = x2 + fx, y = y2 + fy;\n            if (x &gt;= 1 &amp;&amp; x &lt;= n &amp;&amp; y &gt;= 1 &amp;&amp; y &lt;= m)\n                st.emplace(x, y);\n        &#125;\n        for (auto [x, y] : st)\n            work(x, y, -1);\n        std::swap(id[x1][y1], id[x2][y2]), std::swap(pos[i1], pos[i2]);\n        for (auto [x, y] : st)\n            work(x, y, 1);\n        std::cout &lt;&lt; t[1].u &lt;&lt; &#39;\\n&#39;;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n<p>interactive version:</p>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\n#ifdef ONLINE_JUDGE\n#include &quot;seats.h&quot;\n#endif\nconst int dir[][2] = &#123; &#123; 0, -1 &#125;, &#123; 0, 1 &#125;, &#123; -1, 0 &#125;, &#123; 1, 0 &#125; &#125;;\nconst int maxn = 1e6 + 5;\nstruct node &#123;\n    int l, r, u, d, mn;\n    node operator+ (const node &amp;q) const &#123;\n        node res;\n        res.l = l, res.r = q.r, res.d = 0;\n        res.mn = std::min(mn, q.mn), res.u = 0;\n        if (mn == res.mn)\n            res.u = u;\n        if (q.mn == res.mn)\n            res.u += q.u;\n        return res;\n    &#125;\n&#125; t[maxn &lt;&lt; 2];\n#define lt (p &lt;&lt; 1)\n#define rt (lt | 1)\nvoid bld(int p, int l, int r) &#123;\n    t[p].l = l, t[p].r = r, t[p].u = r - l + 1;\n    if (l == r)\n        return;\n    int mid = (l + r) &gt;&gt; 1;\n    bld(lt, l, mid), bld(rt, mid + 1, r);\n    return;\n&#125;\nvoid pushval(int p, int v) &#123;\n    t[p].mn += v, t[p].d += v;\n    return;\n&#125;\nvoid pushdown(int p) &#123;\n    pushval(lt, t[p].d), pushval(rt, t[p].d);\n    t[p].d = 0;\n    return;\n&#125;\nvoid add(int p, int l, int r, int v) &#123;\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r) &#123;\n        pushval(p, v);\n        return;\n    &#125;\n    pushdown(p);\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (l &lt;= mid)\n        add(lt, l, r, v);\n    if (r &gt; mid)\n        add(rt, l, r, v);\n    t[p] = t[lt] + t[rt];\n    return;\n&#125;\nint n, m, N;\nstd::vector&lt;std::pair&lt;int, int&gt; &gt; pos;\nstd::vector&lt;std::vector&lt;int&gt; &gt; id(n + 2, std::vector&lt;int&gt; (m + 2, N + 1));\nvoid work(int x, int y, int k) &#123;\n    for (int i = 0; i &lt; 2; ++i)\n        for (int j = 2; j &lt; 4; ++j) &#123;\n            int x1 = x + dir[j][0], y1 = y + dir[i][1];\n            if (id[x][y] &lt; std::min(id[x1][y], id[x][y1]))\n                add(1, id[x][y], std::min(id[x1][y], id[x][y1]) - 1, k);\n            if (std::max(id[x1][y], id[x][y1]) &lt; id[x][y])\n                add(1, std::max(id[x1][y], id[x][y1]), id[x][y] - 1, k);\n        &#125;\n    return;\n&#125;;\nvoid give_initial_chart(int n, int m, std::vector&lt;int&gt; R, std::vector&lt;int&gt; C) &#123;\n    ::n = n, ::m = m, N = n * m;\n    pos.resize(N + 1);\n    id.assign(n + 2, std::vector&lt;int&gt; (m + 2, N + 1));\n    for (int i = 0; i &lt; N; ++i) &#123;\n        int x = R[i] + 1, y = C[i] + 1;\n        id[x][y] = i + 1, pos[i + 1] = &#123; x, y &#125;;\n    &#125;\n    bld(1, 1, N);\n    for (int i = 1; i &lt;= n; ++i)\n        for (int j = 1; j &lt;= m; ++j)\n            work(i, j, 1);\n    return;\n&#125;\nint swap_seats(int i1, int i2) &#123;\n    ++i1, ++i2;\n    auto [x1, y1] = pos[i1];\n    auto [x2, y2] = pos[i2];\n    std::set&lt;std::pair&lt;int, int&gt; &gt; st;\n    st.emplace(x1, y1);\n    for (auto [fx, fy] : dir) &#123;\n        int x = x1 + fx, y = y1 + fy;\n        if (x &gt;= 1 &amp;&amp; x &lt;= n &amp;&amp; y &gt;= 1 &amp;&amp; y &lt;= m)\n            st.emplace(x, y);\n    &#125;\n    st.emplace(x2, y2);\n    for (auto [fx, fy] : dir) &#123;\n        int x = x2 + fx, y = y2 + fy;\n        if (x &gt;= 1 &amp;&amp; x &lt;= n &amp;&amp; y &gt;= 1 &amp;&amp; y &lt;= m)\n            st.emplace(x, y);\n    &#125;\n    for (auto [x, y] : st)\n        work(x, y, -1);\n    std::swap(id[x1][y1], id[x2][y2]), std::swap(pos[i1], pos[i2]);\n    for (auto [x, y] : st)\n        work(x, y, 1);\n    return t[1].u;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"d---单旋\">D - 单旋</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P3721\" class=\"uri\">https://www.luogu.com.cn/problem/P3721</a></p>\n<ul>\n<li>发现任意时刻参与旋转的都是最值，简单分析可以发现做的这件事情是把最值移到根，其他点相对关系不变，转化为维护深度</li>\n<li>考虑新加入点，可以利用 BST 的性质，直接查询 <span class=\"math inline\">\\(x\\)</span> 的前驱、后继，则二者存在祖孙关系，把 <span class=\"math inline\">\\(x\\)</span> 接在矮的下面即可</li>\n<li>考虑做一个先删再加的过程，删会影响儿子的深度（显然只有一侧儿子），加会影响全树深度</li>\n</ul>\n<hr />\n<h2 id=\"e---nekameleoni\">E - NEKAMELEONI</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P7230\" class=\"uri\">https://www.luogu.com.cn/problem/P7230</a></p>\n",
            "tags": [
                "线段树"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20250911/",
            "url": "https://xsc062.netlify.app/20250911/",
            "title": "吉司机 + 历史和练习",
            "date_published": "2025-09-11T09:27:05.000Z",
            "content_html": "<p>并非所有历史和都是吉司机</p>\n<span id=\"more\"></span>\n<hr />\n<h2 id=\"a---just-another-game-of-stones\">A - Just Another Game of Stones</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P9631\" class=\"uri\">https://www.luogu.com.cn/problem/P9631</a></p>\n<ul>\n<li>发现如果选定了这一步取的位置 <span class=\"math inline\">\\(i\\)</span>，那么要拿的石子是定值 <span class=\"math inline\">\\(a_i-a_i\\oplus s\\)</span>，当 <span class=\"math inline\">\\(a_i\\le a_i\\oplus s\\)</span> 时不合法。</li>\n<li><p>可以用吉司机维护修改和区间异或和，那么询问需要转化。</p>\n答案为 <span class=\"math inline\">\\(a_i&gt;a_i\\oplus s\\)</span> 的次数，结合<strong>异或是不带进位的区间加</strong>的观点，考察『加数』<span class=\"math inline\">\\(s\\)</span> 的最高位，当且仅当 <span class=\"math inline\">\\(a_i\\)</span> 在这一位为 <span class=\"math inline\">\\(1\\)</span> 时有贡献。</li>\n<li><p>故再维护一下每一位为 <span class=\"math inline\">\\(1\\)</span> 的个数即可。复杂度 <span class=\"math inline\">\\(O(q\\log n\\log V)\\)</span>。</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int inf = 1 &lt;&lt; 30;\nconst int maxn = 2e5 + 5;\nstruct &#123;\n    std::array&lt;int, 30&gt; u;\n    int l, r, cnt, mn, se, d, s;\n&#125; t[maxn &lt;&lt; 2];\n#define lt (p &lt;&lt; 1)\n#define rt (lt | 1)\nint a[maxn];\nvoid pushup(int p) &#123;\n    if (t[lt].mn == t[rt].mn) &#123;\n        t[p].mn = t[lt].mn, t[p].cnt = t[lt].cnt + t[rt].cnt;\n        t[p].se = std::min(t[lt].se, t[rt].se);\n    &#125;\n    else if (t[lt].mn &lt; t[rt].mn) &#123;\n        t[p].mn = t[lt].mn, t[p].cnt = t[lt].cnt;\n        t[p].se = std::min(t[lt].se, t[rt].mn);\n    &#125;\n    else &#123;\n        t[p].mn = t[rt].mn, t[p].cnt = t[rt].cnt;\n        t[p].se = std::min(t[lt].mn, t[rt].se);\n    &#125;\n    t[p].s = t[lt].s ^ t[rt].s;\n    for (int i = 0; i &lt; 30; ++i)\n        t[p].u[i] = t[lt].u[i] + t[rt].u[i];\n    return;\n&#125;\nvoid bld(int p, int l, int r) &#123;\n    t[p].d = -inf;\n    t[p].l = l, t[p].r = r;\n    if (l == r) &#123;\n        for (int i = 0; i &lt; 30; ++i)\n            t[p].u[i] = (a[l] &gt;&gt; i) &amp; 1;\n        t[p].s = t[p].mn = a[l], t[p].cnt = 1, t[p].se = inf;\n        return;\n    &#125;\n    int mid = (l + r) &gt;&gt; 1;\n    bld(lt, l, mid), bld(rt, mid + 1, r);\n    pushup(p);\n    return;\n&#125;\nvoid pushval(int p, int v) &#123;\n    if (v &gt; t[p].mn) &#123;\n        for (int i = 0; i &lt; 30; ++i) &#123;\n            if ((t[p].mn &gt;&gt; i) &amp; 1)\n                t[p].u[i] -= t[p].cnt;\n            if ((v &gt;&gt; i) &amp; 1)\n                t[p].u[i] += t[p].cnt;\n        &#125;\n        if (t[p].cnt &amp; 1)\n            t[p].s ^= t[p].mn ^ v;\n        t[p].mn = t[p].d = v;\n    &#125;\n    return;\n&#125;\nvoid pushdown(int p) &#123;\n    if (t[p].d != -inf) &#123;\n        pushval(lt, t[p].d), pushval(rt, t[p].d);\n        t[p].d = -inf;\n    &#125;\n    return;\n&#125;\nvoid add(int p, int l, int r, int v) &#123;\n    if (t[p].mn &gt;= v)\n        return;\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r &amp;&amp; v &lt; t[p].se) &#123;\n        pushval(p, v);\n        return;\n    &#125;\n    pushdown(p);\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (l &lt;= mid)\n        add(lt, l, r, v);\n    if (r &gt; mid)\n        add(rt, l, r, v);\n    pushup(p);\n    return;\n&#125;\nint askt(int p, int l, int r, int i) &#123;\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r)\n        return t[p].u[i];\n    pushdown(p);\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1, res = 0;\n    if (l &lt;= mid)\n        res = askt(lt, l, r, i);\n    if (r &gt; mid)\n        res += askt(rt, l, r, i);\n    return res;\n&#125;\nint asks(int p, int l, int r) &#123;\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r)\n        return t[p].s;\n    pushdown(p);\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1, res = 0;\n    if (l &lt;= mid)\n        res = asks(lt, l, r);\n    if (r &gt; mid)\n        res ^= asks(rt, l, r);\n    return res;\n&#125;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, m;\n    std::cin &gt;&gt; n &gt;&gt; m;\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i];\n    bld(1, 1, n);\n    for (int op, l, r, v; m--; ) &#123;\n        std::cin &gt;&gt; op &gt;&gt; l &gt;&gt; r &gt;&gt; v;\n        if (op == 1)\n            add(1, l, r, v);\n        else &#123;\n            int s = asks(1, l, r) ^ v;\n            if (s == 0) &#123;\n                std::cout &lt;&lt; 0 &lt;&lt; &#39;\\n&#39;;\n                continue;\n            &#125;\n            int t = std::__lg(s);\n            std::cout &lt;&lt; askt(1, l, r, t) + ((v &gt;&gt; t) &amp; 1) &lt;&lt; &#39;\\n&#39;;\n        &#125;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"b---prof.-pangs-sequence-c---test_90\">B - Prof. Pang’s sequence / C - TEST_90</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P10822\" class=\"uri\">https://www.luogu.com.cn/problem/P10822</a> / <a href=\"https://www.luogu.com.cn/problem/P9990\" class=\"uri\">https://www.luogu.com.cn/problem/P9990</a></p>\n<ul>\n<li>历史和维护子区间问题是一个固定的 trick，只需要对于每一个 <span class=\"math inline\">\\(r\\)</span>，给合法的 <span class=\"math inline\">\\(l\\)</span> 加一。</li>\n<li>离线扫描线，对于当前右端点 <span class=\"math inline\">\\(r\\)</span>，记录每种数最后一次出现的位置 <span class=\"math inline\">\\(pos\\)</span>。令 <span class=\"math inline\">\\(r\\)</span> 的颜色为 <code>1</code>，从右到左，每碰到一个新的 <span class=\"math inline\">\\(pos\\)</span> 就切换颜色</li>\n<li>显然对于当前 <span class=\"math inline\">\\(r\\)</span>，应该被加一的 <span class=\"math inline\">\\(l\\)</span> 就是颜色为 <code>1</code> 的这些位置。</li>\n<li>考虑更快地维护这个过程，也就是在 <span class=\"math inline\">\\(r\\)</span> 的颜色和 <span class=\"math inline\">\\(r-1\\)</span> 不同时就可以对 <span class=\"math inline\">\\([1,r)\\)</span> 做一次 flip，是可行的</li>\n<li>在每个 <span class=\"math inline\">\\(r\\)</span> 处查询 <span class=\"math inline\">\\([l,r]\\)</span> 的区间和即可。</li>\n<li>吐槽：并非所有历史和都是吉司机</li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 5e5 + 5;\nstruct &#123;\n    long long s;\n    int l, r, d0, d1, df, ds, u0, u1;\n&#125; t[maxn &lt;&lt; 2];\n#define lt (p &lt;&lt; 1)\n#define rt (lt | 1)\nvoid pushup(int p) &#123;\n    t[p].u0 = t[lt].u0 + t[rt].u0;\n    t[p].u1 = t[lt].u1 + t[rt].u1;\n    return;\n&#125;\nvoid pushval(int p, long long v0, long long v1, bool f) &#123;\n    if (f) &#123;\n        t[p].df ^= 1;\n        std::swap(t[p].u0, t[p].u1);\n        std::swap(t[p].d0, t[p].d1);\n    &#125;\n    t[p].d0 += v0, t[p].d1 += v1;\n    t[p].s += t[p].u0 * v0 + t[p].u1 * v1;\n    return;\n&#125;\nvoid pushdown(int p) &#123;\n    pushval(lt, t[p].d0, t[p].d1, t[p].df);\n    pushval(rt, t[p].d0, t[p].d1, t[p].df);\n    t[p].d0 = t[p].d1 = t[p].df = 0;\n    return;\n&#125;\nvoid bld(int p, int l, int r) &#123;\n    t[p].l = l, t[p].r = r;\n    t[p].u0 = r - l + 1;\n    if (l == r)\n        return;\n    int mid = (l + r) &gt;&gt; 1;\n    bld(lt, l, mid), bld(rt, mid + 1, r);\n    return;\n&#125;\nvoid flip(int p, int l, int r) &#123;\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r) &#123;\n        pushval(p, 0, 0, 1);\n        return;\n    &#125;\n    pushdown(p);\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (l &lt;= mid)\n        flip(lt, l, r);\n    if (r &gt; mid)\n        flip(rt, l, r);\n    pushup(p);\n    return;\n&#125;\nlong long ask(int p, int l, int r) &#123;\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r)\n        return t[p].s;\n    pushdown(p);\n    auto res(0ll);\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (l &lt;= mid)\n        res = ask(lt, l, r);\n    if (r &gt; mid)\n        res += ask(rt, l, r);\n    return res;\n&#125;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;int&gt; a(n + 1), la(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i];\n    int m;\n    std::cin &gt;&gt; m;\n    std::vector&lt;long long&gt; res(m + 1);\n    std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; u(n + 1);\n    for (int i = 1, l, r; i &lt;= m; ++i) &#123;\n        std::cin &gt;&gt; l &gt;&gt; r;\n        u[r].emplace_back(l, i);\n    &#125;\n    bld(1, 1, n);\n    for (int r = 1; r &lt;= n; ++r) &#123;\n        flip(1, la[a[r]] + 1, r);\n        pushval(1, 0, 1, 0);\n        for (auto [l, id] : u[r])\n            res[id] = ask(1, l, r);\n        la[a[r]] = r;\n    &#125;\n    for (int i = 1; i &lt;= m; ++i)\n        std::cout &lt;&lt; res[i] &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"d---stations\">D - Stations</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/CF1572F\" class=\"uri\">https://www.luogu.com.cn/problem/CF1572F</a></p>\n<ul>\n<li>不太能直接维护 <span class=\"math inline\">\\(b\\)</span>，但发现如果维护每个 <span class=\"math inline\">\\(i\\)</span> 最远能到达的点，发现每次更新 <span class=\"math inline\">\\(j\\)</span> 会把 <span class=\"math inline\">\\(j\\)</span> 左边的所有点值和 <span class=\"math inline\">\\(j-1\\)</span> 取 min。</li>\n<li>发现吉司机能够在取 min 的同时在另一个树状树组里维护差分</li>\n<li>需要注意更新的时机，应该是每次线段树更新函数访问到完整节点时。</li>\n<li>复杂度 <span class=\"math inline\">\\(O(q\\log^2n)\\)</span>。但真的吗？单点修改似乎对势能有影响？然而并不会相关分析。</li>\n</ul>\n<p>看起来有点激进了，没想到确实是正解。</p>\n<details>\n<p>可以发现树状数组在时间上确实是有优势的</p>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 2e5 + 5;\nconst int inf = 0x3f3f3f3f;\nstruct &#123;\n    int l, r, mx, se, d, cnt;\n&#125; t[maxn &lt;&lt; 2];\n#define lt (p &lt;&lt; 1)\n#define rt (lt | 1)\nint n;\nlong long bit[maxn][2];\nint lowbit(int x) &#123; return x &amp; -x; &#125;\nvoid add(int x, long long v) &#123;\n    for (int i = x; i &lt;= n; i += lowbit(i))\n        bit[i][0] += v, bit[i][1] += v * (x - 1);\n    return;\n&#125;\nlong long ask(int x) &#123;\n    auto res = 0ll;\n    for (int i = x; i; i -= lowbit(i))\n        res += bit[i][0] * x - bit[i][1];\n    return res;\n&#125;\nvoid pushup(int p) &#123;\n    if (t[lt].mx == t[rt].mx) &#123;\n        t[p].mx = t[lt].mx, t[p].cnt = t[lt].cnt + t[rt].cnt;\n        t[p].se = std::max(t[lt].se, t[rt].se);\n    &#125;\n    else if (t[lt].mx &gt; t[rt].mx) &#123;\n        t[p].mx = t[lt].mx, t[p].cnt = t[lt].cnt;\n        t[p].se = std::max(t[lt].se, t[rt].mx);\n    &#125;\n    else &#123;\n        t[p].mx = t[rt].mx, t[p].cnt = t[rt].cnt;\n        t[p].se = std::max(t[lt].mx, t[rt].se);\n    &#125;\n    return;\n&#125;\nvoid bld(int p, int l, int r) &#123;\n    t[p].d = inf;\n    t[p].l = l, t[p].r = r;\n    if (l == r) &#123;\n        add(l, 1), add(l + 1, -1);\n        t[p].mx = l, t[p].se = -1, t[p].cnt = 1;\n        return;\n    &#125;\n    int mid = (l + r) &gt;&gt; 1;\n    bld(lt, l, mid), bld(rt, mid + 1, r);\n    pushup(p);\n    return;\n&#125;\nvoid pushval(int p, int v) &#123;\n    if (v &lt;= t[p].mx)\n        t[p].mx = t[p].d = v;\n    return;\n&#125;\nvoid pushdown(int p) &#123;\n    if (t[p].d != inf) &#123;\n        pushval(lt, t[p].d), pushval(rt, t[p].d);\n        t[p].d = inf;\n    &#125;\n    return;\n&#125;\nvoid add(int p, int l, int r, int v) &#123;\n    if (t[p].mx &lt;= v)\n        return;\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r &amp;&amp; v &gt; t[p].se) &#123;\n        add(t[p].mx + 1, t[p].cnt);\n        add(v + 1, -t[p].cnt);\n        pushval(p, v);\n        return;\n    &#125;\n    pushdown(p);\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (l &lt;= mid)\n        add(lt, l, r, v);\n    if (r &gt; mid)\n        add(rt, l, r, v);\n    pushup(p);\n    return;\n&#125;\nvoid upd(int p, int x, int v) &#123;\n    if (t[p].l == t[p].r) &#123;\n        add(t[p].mx + 1, 1), add(v + 1, -1);\n        t[p].mx = v;\n        return;\n    &#125;\n    pushdown(p);\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (x &lt;= mid)\n        upd(lt, x, v);\n    else\n        upd(rt, x, v);\n    pushup(p);\n    return;\n&#125;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int m;\n    std::cin &gt;&gt; n &gt;&gt; m;\n    bld(1, 1, n);\n    for (int op; m--; ) &#123;\n        std::cin &gt;&gt; op;\n        if (op == 1) &#123;\n            int x, v;\n            std::cin &gt;&gt; x &gt;&gt; v;\n            if (x != 1)\n                add(1, 1, x - 1, x - 1);\n            upd(1, x, v);\n            // for (int i = 1; i &lt;= n; ++i)\n            //     std::cout &lt;&lt; ask(i) - ask(i - 1) &lt;&lt; &#39; &#39;;\n            // std::cout &lt;&lt; &#39;\\n&#39;;\n        &#125;\n        else &#123;\n            int l, r;\n            std::cin &gt;&gt; l &gt;&gt; r;\n            std::cout &lt;&lt; ask(r) - ask(l - 1) &lt;&lt; &#39;\\n&#39;;\n        &#125;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"e---luotianyi-and-the-function\">E - LuoTianyi and the Function</h2>\n<p><a href=\"https://codeforces.com/problemset/problem/1824/D\" class=\"uri\">https://codeforces.com/problemset/problem/1824/D</a></p>\n<ul>\n<li>由于 <span class=\"math inline\">\\(j\\)</span> 和函数关联更强，考虑把 <span class=\"math inline\">\\(j\\)</span> 这一维扫描线 + 差分掉</li>\n<li>经典套路，维护每个 <span class=\"math inline\">\\(x\\)</span> 从右向左第一次出现的位置 <span class=\"math inline\">\\(pos_x\\)</span></li>\n<li>每次 <span class=\"math inline\">\\(j\\)</span> 移动一下，会更新一段区间（可能不存在）的 <span class=\"math inline\">\\(g\\)</span> 值，它们原本为 <span class=\"math inline\">\\(pos_{a_j}\\)</span>，需要被更新为下一个 <span class=\"math inline\">\\(pos\\)</span>。</li>\n<li>记录值为 <span class=\"math inline\">\\(pos_x\\)</span> 的区间，做区间赋值历史和即可。</li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 1e6 + 5;\nstruct &#123;\n    int l, r;\n    long long d1, d2, d3, u, s;\n&#125; t[maxn &lt;&lt; 2];\n#define lt (p &lt;&lt; 1)\n#define rt (lt | 1)\nvoid pushup(int p) &#123;\n    t[p].u = t[lt].u + t[rt].u;\n    t[p].s = t[lt].s + t[rt].s;\n    return;\n&#125;\nvoid pushval(int p, long long d1, long long d2, long long d3) &#123;\n    t[p].s += t[p].u * d2 + d3 * (t[p].r - t[p].l + 1);\n    t[p].d3 += d3;\n    if (t[p].d1)\n        t[p].d3 += t[p].d1 * d2;\n    else\n        t[p].d2 += d2;\n    if (d1) &#123;\n        t[p].u = d1 * (t[p].r - t[p].l + 1);\n        t[p].d1 = d1;\n    &#125;\n    return;\n&#125;\nvoid pushdown(int p) &#123;\n    pushval(lt, t[p].d1, t[p].d2, t[p].d3);\n    pushval(rt, t[p].d1, t[p].d2, t[p].d3);\n    t[p].d1 = t[p].d2 = t[p].d3 = 0ll;\n    return;\n&#125;\nvoid bld(int p, int l, int r) &#123;\n    t[p].l = l, t[p].r = r;\n    if (l == r)\n        return;\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    bld(lt, l, mid), bld(rt, mid + 1, r);\n    return;\n&#125;\nvoid upd(int p, int l, int r, long long v) &#123;\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r) &#123;\n        pushval(p, v, 0ll, 0ll);\n        return;\n    &#125;\n    pushdown(p);\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (l &lt;= mid)\n        upd(lt, l, r, v);\n    if (r &gt; mid)\n        upd(rt, l, r, v);\n    pushup(p);\n    return;\n&#125;\nlong long ask(int p, int l, int r) &#123;\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r)\n        return t[p].s;\n    pushdown(p);\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    auto res = 0ll;\n    if (l &lt;= mid)\n        res = ask(lt, l, r);\n    if (r &gt; mid)\n        res += ask(rt, l, r);\n    return res;\n&#125;\nsigned main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, q;\n    std::cin &gt;&gt; n &gt;&gt; q;\n    std::vector&lt;int&gt; a(n + 1), la(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i];\n    struct query &#123; int l, r, id, k; &#125;;\n    std::vector&lt;long long&gt; res(q + 1);\n    std::vector&lt;std::vector&lt;query&gt; &gt; u(n + 1);\n    for (int i = 1, l, r, x, y; i &lt;= q; ++i) &#123;\n        std::cin &gt;&gt; l &gt;&gt; r &gt;&gt; x &gt;&gt; y;\n        if (x != 1)\n            u[x - 1].push_back(&#123; l, r, i, -1 &#125;);\n        u[y].push_back(&#123; l, r, i, 1 &#125;);\n    &#125;\n    bld(1, 1, n);\n    std::vector&lt;int&gt; pre(n + 2), nex(n + 2), l(n + 2);\n    pre[n + 1] = 0, nex[0] = n + 1;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        int p = la[a[i]];\n        nex[pre[n + 1]] = i, pre[i] = pre[n + 1], pre[n + 1] = i, nex[i] = n + 1;\n        l[i] = i;\n        if (p != 0) &#123;\n            upd(1, l[p], p, nex[p]);\n            l[nex[p]] = l[p];\n            pre[nex[p]] = pre[p], nex[pre[p]] = nex[p];\n        &#125;\n        upd(1, i, i, i);\n        pushval(1, 0, 1, 0);\n        for (auto [l, r, id, k] : u[i])\n            res[id] += k * ask(1, l, r);\n        la[a[i]] = i;\n    &#125;\n    for (int i = 1; i &lt;= q; ++i)\n        std::cout &lt;&lt; res[i] &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"f---yunlis-subarray-queries-extreme-version\">F - Yunli’s Subarray Queries (extreme version)</h2>\n<p><a href=\"https://codeforces.com/problemset/problem/2009/G3\" class=\"uri\">https://codeforces.com/problemset/problem/2009/G3</a></p>\n<ul>\n<li>考虑对 <span class=\"math inline\">\\(\\forall i\\)</span>，令 <span class=\"math inline\">\\(a_i\\gets a_i-i\\)</span>，那么能够参与同一个连续子段的元素值应相同</li>\n<li><p>显然对于任意一个长度为 <span class=\"math inline\">\\(k\\)</span> 的子段，其答案为 <span class=\"math inline\">\\(k\\)</span> 减去众数出现次数（<span class=\"math inline\">\\([l, r]\\)</span> 处答案记为 <span class=\"math inline\">\\(g_r\\)</span>）</p>\n这一点可以用类似莫队的方法来做</li>\n<li><p>那么对于更长的子段 <span class=\"math inline\">\\([l, r]\\)</span>，其 <span class=\"math inline\">\\(f\\)</span> 就是 <span class=\"math inline\">\\(\\min\\limits_{l+k-1\\le i\\le r}\\{g_i\\}\\)</span></p>\n原问题中的一次 <span class=\"math inline\">\\([l, r]\\)</span> 的询问就可以转化为 <span class=\"math inline\">\\(\\sum\\limits_{i=l+k-1}^r\\sum\\limits_{j=i}^r\\min\\{ g_{i\\sim j}\\}\\)</span></li>\n<li><p>这里有一个 trick：扫描线时可以用单调栈的想法来维护最小值操作，那么就把最值操作转化为一般的区间加历史和了。</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 1e6 + 5;\nstruct &#123;\n    int l, r;\n    long long d1, d2, d3, u, s;\n&#125; t[maxn &lt;&lt; 2];\n#define lt (p &lt;&lt; 1)\n#define rt (lt | 1)\nvoid pushup(int p) &#123;\n    t[p].u = t[lt].u + t[rt].u;\n    t[p].s = t[lt].s + t[rt].s;\n    return;\n&#125;\nvoid pushval(int p, long long d1, long long d2, long long d3) &#123;\n    t[p].s += t[p].u * d2 + d3 * (t[p].r - t[p].l + 1);\n    t[p].d3 += d3 + t[p].d1 * d2;\n    t[p].d2 += d2;\n    t[p].u += d1 * (t[p].r - t[p].l + 1);\n    t[p].d1 += d1;\n    return;\n&#125;\nvoid pushdown(int p) &#123;\n    pushval(lt, t[p].d1, t[p].d2, t[p].d3);\n    pushval(rt, t[p].d1, t[p].d2, t[p].d3);\n    t[p].d1 = t[p].d2 = t[p].d3 = 0ll;\n    return;\n&#125;\nvoid bld(int p, int l, int r) &#123;\n    t[p].l = l, t[p].r = r;\n    t[p].u = t[p].s = 0ll;\n    t[p].d1 = t[p].d2 = t[p].d3 = 0;\n    if (l == r)\n        return;\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    bld(lt, l, mid), bld(rt, mid + 1, r);\n    return;\n&#125;\nvoid add(int p, int l, int r, long long v) &#123;\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r) &#123;\n        pushval(p, v, 0ll, 0ll);\n        return;\n    &#125;\n    pushdown(p);\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (l &lt;= mid)\n        add(lt, l, r, v);\n    if (r &gt; mid)\n        add(rt, l, r, v);\n    pushup(p);\n    return;\n&#125;\nlong long ask(int p, int l, int r) &#123;\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r)\n        return t[p].s;\n    pushdown(p);\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    auto res = 0ll;\n    if (l &lt;= mid)\n        res = ask(lt, l, r);\n    if (r &gt; mid)\n        res += ask(rt, l, r);\n    return res;\n&#125;\nsigned main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int T;\n    for (std::cin &gt;&gt; T; T--; ) &#123;\n        int n, k, q;\n        std::cin &gt;&gt; n &gt;&gt; k &gt;&gt; q;\n        std::vector&lt;int&gt; a(n + 1);\n        for (int i = 1; i &lt;= n; ++i)\n            std::cin &gt;&gt; a[i], a[i] -= i;\n        bld(1, 1, n);\n        std::vector&lt;int&gt; g(n + 1);\n        std::unordered_map&lt;int, int&gt; cnt;\n        std::multiset&lt;int&gt; t;\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            if (i &gt; k) &#123;\n                t.erase(t.find(cnt[a[i - k]]));\n                if (--cnt[a[i - k]])\n                    t.insert(cnt[a[i - k]]);\n            &#125;\n            if (cnt[a[i]])\n                t.erase(t.find(cnt[a[i]]));\n            t.insert(++cnt[a[i]]);\n            if (i &gt;= k)\n                g[i] = k - *--t.end();\n        &#125;\n        std::vector&lt;long long&gt; res(q + 1);\n        std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; u(n + 1);\n        for (int i = 1, l, r; i &lt;= q; ++i) &#123;\n            std::cin &gt;&gt; l &gt;&gt; r;\n            u[r].emplace_back(l + k - 1, i);\n        &#125;\n        std::stack&lt;std::pair&lt;int, int&gt; &gt; st;\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            std::pair&lt;int, int&gt; now(g[i], i);\n            add(1, i, i, g[i]);\n            for (; !st.empty() &amp;&amp; st.top() &gt; now; st.pop()) &#123;\n                auto [v, p] = st.top();\n                add(1, p, now.second - 1, g[i] - v);\n                now.second = p;\n            &#125;\n            st.push(now);\n            pushval(1, 0ll, 1ll, 0ll);\n            for (auto [l, id] : u[i])\n                res[id] = ask(1, l, i);\n        &#125;\n        for (int i = 1; i &lt;= q; ++i)\n            std::cout &lt;&lt; res[i] &lt;&lt; &#39;\\n&#39;;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n",
            "tags": [
                "线段树"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20250909/",
            "url": "https://xsc062.netlify.app/20250909/",
            "title": "吉司机线段树",
            "date_published": "2025-09-09T14:24:31.000Z",
            "content_html": "<p>势能，但仅限于势能吗？</p>\n<span id=\"more\"></span>\n<p><a href=\"数据结构选讲(一)%20by%20crashed.pdf\">数据结构选讲(一) by crashed.pdf</a></p>\n<hr />\n<p>需要知道线段树并非万能，很多看起来兼容的操作其实是不兼容的。举例：</p>\n<ul>\n<li><p>区间取 min, max、区间查询 min, max</p>\n<p>发现在涉及最值操作的时候，把区间元素值看作分段函数和取最值的性质是比较贴的。</p>\n那么相当于把所有大于 / 小于 <span class=\"math inline\">\\(v\\)</span> 的部分推平。查询是好做的。</li>\n<li><p>区间加、区间查询 min, max</p>\n相当于竖直方向平移。</li>\n<li><p>区间加等差数列、区间查询 min, max</p>\n发现是和另一个固定的一次函数做线性加；发现是不可做的。</li>\n<li><p>区间取 min、区间求和</p>\n<p>也即把所有大于 / 小于 <span class=\"math inline\">\\(v\\)</span> 的部分推平，还要求点值之和。</p>\n<p>看起来不可做，因为求和没办法用这样的语言体系简单阐释，只能考虑脱离这个语言体系，真的去找到这样的凸起。这样看起来是特别慢的。</p></li>\n</ul>\n<p>但实际上最后一条是可做的，吉如一发明了一种特定的方法，并证明了在仅有区间取 min / max + 区间求和操作时，复杂度是 <span class=\"math inline\">\\(O(q\\log n)\\)</span> 的；如果再增加其他任何区间操作，复杂度是 <span class=\"math inline\">\\(O(q\\log^2 n)\\)</span> 的。</p>\n<hr />\n<h2 id=\"区间取-min-区间求和\">区间取 min / 区间求和</h2>\n<p>例：<a href=\"https://acm.hdu.edu.cn/showproblem.php?pid=5306\">Gorgeous Sequence</a></p>\n<p>记录最大值 <span class=\"math inline\">\\(mx\\)</span>、次大值 <span class=\"math inline\">\\(se\\)</span>、最大值出现次数 <span class=\"math inline\">\\(cnt\\)</span>。当 <span class=\"math inline\">\\(v\\in(se,mx)\\)</span> 时，发现只有 <span class=\"math inline\">\\(mx\\)</span> 需要被更新。此时 <span class=\"math inline\">\\(s\\gets s-(mx-v)\\cdot cnt\\)</span>。</p>\n<p>否则，<span class=\"math inline\">\\(se\\)</span> 也需要被更新，暴力递归直到满足上一条后停止。复杂度 <span class=\"math inline\">\\(O(q\\log n)\\)</span>。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 1e6 + 5;\nconst int inf = 0x3f3f3f3f;\nstruct &#123;\n    long long s;\n    int l, r, mx, se, d, cnt;\n&#125; t[maxn &lt;&lt; 2];\n#define lt (p &lt;&lt; 1)\n#define rt (lt | 1)\nint a[maxn];\nvoid pushup(int p) &#123;\n    if (t[lt].mx == t[rt].mx) &#123;\n        t[p].mx = t[lt].mx, t[p].cnt = t[lt].cnt + t[rt].cnt;\n        t[p].se = std::max(t[lt].se, t[rt].se);\n    &#125;\n    else if (t[lt].mx &gt; t[rt].mx) &#123;\n        t[p].mx = t[lt].mx, t[p].cnt = t[lt].cnt;\n        t[p].se = std::max(t[lt].se, t[rt].mx);\n    &#125;\n    else &#123;\n        t[p].mx = t[rt].mx, t[p].cnt = t[rt].cnt;\n        t[p].se = std::max(t[lt].mx, t[rt].se);\n    &#125;\n    t[p].s = t[lt].s + t[rt].s;\n    return;\n&#125;\nvoid bld(int p, int l, int r) &#123;\n    t[p].d = inf;\n    t[p].l = l, t[p].r = r;\n    if (l == r) &#123;\n        t[p].s = t[p].mx = a[l], t[p].cnt = 1, t[p].se = 0;\n        return;\n    &#125;\n    int mid = (l + r) &gt;&gt; 1;\n    bld(lt, l, mid), bld(rt, mid + 1, r);\n    pushup(p);\n    return;\n&#125;\nvoid pushval(int p, int v) &#123;\n    if (v &lt;= t[p].mx) &#123;\n        t[p].s -= (long long)(t[p].mx - v) * t[p].cnt;\n        t[p].mx = t[p].d = v;\n    &#125;\n    return;\n&#125;\nvoid pushdown(int p) &#123;\n    if (t[p].d != inf) &#123;\n        pushval(lt, t[p].d), pushval(rt, t[p].d);\n        t[p].d = inf;\n    &#125;\n    return;\n&#125;\nvoid add(int p, int l, int r, int v) &#123;\n    if (t[p].mx &lt;= v)\n        return;\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r &amp;&amp; v &gt; t[p].se) &#123;\n        pushval(p, v);\n        return;\n    &#125;\n    pushdown(p);\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (l &lt;= mid)\n        add(lt, l, r, v);\n    if (r &gt; mid)\n        add(rt, l, r, v);\n    pushup(p);\n    return;\n&#125;\nint askmx(int p, int l, int r) &#123;\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r)\n        return t[p].mx;\n    pushdown(p);\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1, res = 0;\n    if (l &lt;= mid)\n        res = askmx(lt, l, r);\n    if (r &gt; mid)\n        res = std::max(res, askmx(rt, l, r));\n    return res;\n&#125;\nlong long asks(int p, int l, int r) &#123;\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r)\n        return t[p].s;\n    pushdown(p);\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    auto res = 0ll;\n    if (l &lt;= mid)\n        res = asks(lt, l, r);\n    if (r &gt; mid)\n        res += asks(rt, l, r);\n    return res;\n&#125;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int T;\n    for (std::cin &gt;&gt; T; T--; ) &#123;\n        int n, m;\n        std::cin &gt;&gt; n &gt;&gt; m;\n        for (int i = 1; i &lt;= n; ++i)\n            std::cin &gt;&gt; a[i];\n        bld(1, 1, n);\n        for (int op, l, r; m--; ) &#123;\n            std::cin &gt;&gt; op &gt;&gt; l &gt;&gt; r;\n            if (op == 0) &#123;\n                int v;\n                std::cin &gt;&gt; v;\n                add(1, l, r, v);\n            &#125;\n            else if (op == 1)\n                std::cout &lt;&lt; askmx(1, l, r) &lt;&lt; &#39;\\n&#39;;\n            else\n                std::cout &lt;&lt; asks(1, l, r) &lt;&lt; &#39;\\n&#39;;\n        &#125;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"区间取-min区间操作区间求和\">区间取 min、区间操作、区间求和</h2>\n<p>例：<a href=\"https://loj.ac/p/6565\">最假女选手</a></p>\n<p>可以用相似的方法来维护；</p>\n",
            "tags": [
                "线段树"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20250819/",
            "url": "https://xsc062.netlify.app/20250819/",
            "title": "log 数据结构的一些题",
            "date_published": "2025-08-19T01:44:25.000Z",
            "content_html": "<p>线段树、树状数组、倍增、分治（朴素分治 / CDQ / 整体二分）、平衡树、字典树、笛卡尔树</p>\n<p>多乎哉？不多也。</p>\n<span id=\"more\"></span>\n<hr />\n<p>题目来源：</p>\n<ol type=\"1\">\n<li><p>llsw’s pdf</p>\n<p>caijianhong /bx /bx</p>\n<p><a href=\"https://www.cnblogs.com/caijianhong/p/18709963\">【笔记】数据结构选讲-李雷思问 2025.2.10</a></p></li>\n<li>洛谷文章广场题解区搜索对应算法</li>\n<li><p>自己以前的一些零散题解</p></li>\n</ol>\n<p>找了一些有数据结构方面思维难点的题，实现难度通常不会很大，也有少许粑粑夹杂其中</p>\n<hr />\n<p><code>#</code> 是缺题解，<code>*</code> 是缺代码</p>\n<hr />\n<h2 id=\"线段树\">线段树</h2>\n<h3 id=\"维护特殊信息\">维护特殊信息</h3>\n<h4 id=\"金鱼草-curtains区间覆盖信息\">金鱼草 / Curtains（区间覆盖信息）</h4>\n<p><a href=\"https://www.luogu.com.cn/problem/P11536\" class=\"uri\">https://www.luogu.com.cn/problem/P11536</a></p>\n<blockquote>\n<p>给定 <span class=\"math inline\">\\(n\\)</span> 个区间 <span class=\"math inline\">\\([l,r]\\)</span>，给出 <span class=\"math inline\">\\(q\\)</span> 个询问，每次询问 <span class=\"math inline\">\\([L,R]\\)</span> 是否能被表示为若干 <span class=\"math inline\">\\([l,r]\\)</span> 的并集。注意不能覆盖到 <span class=\"math inline\">\\([L,R]\\)</span> 之外的点。</p>\n<p><span class=\"math inline\">\\(n,q\\le 5\\times 10^5,|V|\\le 10^9\\)</span>。</p>\n</blockquote>\n<ul>\n<li>题目所求等价于 check 满足 <span class=\"math inline\">\\(l\\ge L\\land r\\le R\\)</span> 的所有区间是否能够覆盖 <span class=\"math inline\">\\([L,R]\\)</span></li>\n<li>这个很简单，需要区间修改的做法就不提了。可以想一下有没有只需要单点修改的做法</li>\n<li><p>发现权值线段树可以维护「一段连续左端点对应区间的并」是否是连续的：</p>\n维护位于区间内的左端点最后一个覆盖到的点 <span class=\"math inline\">\\(rv\\)</span>（可以在区间外；发现从区间左端点到 <span class=\"math inline\">\\(rv\\)</span> 会被连续覆盖），<strong>区间内</strong>最后一个没有被覆盖到的点 <span class=\"math inline\">\\(p\\)</span>，和表示区间是否能被完整覆盖的标记 flag。pushup 是容易的。</li>\n<li><p>容易发现如果我们在树上询问 <span class=\"math inline\">\\([L,R]\\)</span> 中所有左端点的 flag，无法保证参与覆盖的 <span class=\"math inline\">\\(r\\le R\\)</span>。故离线下来扫描线即可。</p>\n<p>实际上由于未知原因跑得很可能不如区间修改的方法快 TAT</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 5e5 + 5;\nstruct _ &#123;\n    bool flag;\n    int l, r, rv, p;\n&#125; t[maxn &lt;&lt; 2];\n#define lt (p &lt;&lt; 1)\n#define rt (lt | 1)\nvoid pushup(int p) &#123;\n    t[p].rv = std::max(t[lt].rv, t[rt].rv);\n    if (!t[lt].flag) &#123;\n        t[p].flag = 0;\n        if (!t[rt].flag &amp;&amp; t[lt].rv &lt; t[rt].p)\n            t[p].p = t[rt].p;\n        else\n            t[p].p = t[lt].p;\n    &#125;\n    else if (!t[rt].flag &amp;&amp; t[lt].rv &lt; t[rt].p)\n        t[p].flag = 0, t[p].p = t[rt].p;\n    else\n        t[p].flag = 1, t[p].p = 0;\n    return;\n&#125;\nvoid bld(int p, int l, int r) &#123;\n    t[p].l = l, t[p].r = t[p].p = r;\n    if (l == r)\n        return;\n    int mid = (l + r) &gt;&gt; 1;\n    bld(lt, l, mid), bld(rt, mid + 1, r);\n    return;\n&#125;\nvoid add(int p, int x, int v) &#123;\n    if(t[p].l == t[p].r) &#123;\n        t[p].flag = 1, t[p].p = 0;\n        t[p].rv = std::max(t[p].rv, v);\n        return;\n    &#125;\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (x &lt;= mid)\n        add(lt, x, v);\n    else\n        add(rt, x, v);\n    pushup(p);\n    return;\n&#125;\n_ ask(int p, int l, int r) &#123;\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r)\n        return t[p];\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (r &lt;= mid)\n        return ask(lt, l, r);\n    if (l &gt; mid)\n        return ask(rt, l, r);\n    auto ls(ask(lt, l, r)), rs(ask(rt, l, r));\n    if (!ls.flag) &#123;\n        if (!rs.flag &amp;&amp; ls.rv &lt; rs.p)\n            ls.p = rs.p;\n    &#125;\n    else if (!rs.flag &amp;&amp; ls.rv &lt; rs.p)\n        ls.flag = 0, ls.p = rs.p;\n    ls.rv = std::max(ls.rv, rs.rv);\n    return ls;\n&#125;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, m, q;\n    std::cin &gt;&gt; m &gt;&gt; n &gt;&gt; q;\n    bld(1, 1, m);\n    std::vector&lt;std::vector&lt;int&gt; &gt; t(m + 1);\n    for (int i = 1, l, r; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; l &gt;&gt; r;\n        t[r].push_back(l);\n    &#125;\n    std::vector&lt;int&gt; res(q + 1);\n    std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; tq(m + 1);\n    for (int i = 1, l, r; i &lt;= q; ++i) &#123;\n        std::cin &gt;&gt; l &gt;&gt; r;\n        tq[r].emplace_back(l, i);\n    &#125;\n    for (int i = 1; i &lt;= m; ++i) &#123;\n        for (auto l : t[i])\n            add(1, l, i);\n        for (auto [l, id] : tq[i])\n            res[id] = ask(1, l, i).flag;\n    &#125;\n    for (int i = 1; i &lt;= q; ++i)\n        std::cout &lt;&lt; (res[i] ? &quot;YES&quot; : &quot;NO&quot;) &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<h4 id=\"题日-zapatak哈希\"># 题日 Zapatak（哈希）</h4>\n<p><a href=\"https://www.luogu.com.cn/problem/P11262\" class=\"uri\">https://www.luogu.com.cn/problem/P11262</a></p>\n<h4 id=\"简单数据结构带一点递推性质\">简单数据结构（带一点递推性质）</h4>\n<p><a href=\"https://pjudge.ac/problem/21636\" class=\"uri\">https://pjudge.ac/problem/21636</a></p>\n<blockquote>\n<p>给定初始为空的多重集 <span class=\"math inline\">\\(p\\)</span>, <span class=\"math inline\">\\(q\\)</span>，这两个多重集中的元素都有 <span class=\"math inline\">\\(a,b\\)</span> 两种属性。需要需要维护 <span class=\"math inline\">\\(p\\)</span> 和 <span class=\"math inline\">\\(q\\)</span> 的加点和删点操作，询问 <span class=\"math inline\">\\(\\forall \\,i\\in p,j\\in q\\)</span>，<span class=\"math inline\">\\(\\max(i_x + j_x, i_y + j_y)\\)</span> 的最小值。</p>\n<p><span class=\"math inline\">\\(m\\le 10^6,V\\le 10^9\\)</span>。</p>\n</blockquote>\n<ul>\n<li>考虑<strong>对不等式恒等变形，转化为偏序问题</strong>。若 <span class=\"math inline\">\\(a_{i,0}+b_{j,0}\\ge a_{i,1}+b_{j,1}\\)</span>，则 <span class=\"math inline\">\\(a_{i,0}-a_{i,1}\\ge b_{j,1}-b_{j,0}\\)</span>。</li>\n<li><p>把 <span class=\"math inline\">\\(a\\)</span> 按照 <span class=\"math inline\">\\(a_{i,0}-a_{i,1}\\)</span> 排序、把 <span class=\"math inline\">\\(b\\)</span> 按照 <span class=\"math inline\">\\(b_{j,1}-b_{j,0}\\)</span> 排序。</p>\n<p>要求某个时刻的答案，需要对于每一个 <span class=\"math inline\">\\(i\\)</span> 找到最小的 <span class=\"math inline\">\\(b_{j,0}\\)</span>，使得 <span class=\"math inline\">\\(b_{j,1}-b_{j,0}\\)</span> 在 <span class=\"math inline\">\\([-\\infty, a_{i,0}-a_{i,1}]\\)</span> 中，同时找到最小的 <span class=\"math inline\">\\(b_{j,1}\\)</span>，使得 <span class=\"math inline\">\\(b_{j,1}-b_{j,0}\\)</span> 在 <span class=\"math inline\">\\([a_{i, 0}-a_{i,1},+\\infty]\\)</span> 中。</p>\n<p>这个带有一点递推的性质，在线段树 pushup 的时候，用左边的 <span class=\"math inline\">\\(b_{j,0}\\)</span> 结合右边的答案得到父亲的答案。</p></li>\n</ul>\n<p><em>听说我之前赛时切了这题？怎么没印象。llsw 讲题的时候说要离线，但是没想到离线做法 orz</em></p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int inf = 2e9 + 1;\nstruct _ &#123; long long aa, ab, ba, bb, u; int l, r, id; &#125;;\nstd::vector&lt;_&gt; t(1);\nstd::vector&lt;std::multiset&lt;long long&gt; &gt; aa(1), ab(1), ba(1), bb(1);\nint tot, cnt;\n#define lt t[p].l\n#define rt t[p].r\nvoid pushup(int p) &#123;\n    t[p].aa = t[p].ab = t[p].ba = t[p].bb = t[p].u = inf;\n    if (lt) &#123;\n        t[p].u = t[lt].u;\n        t[p].aa = t[lt].aa, t[p].ab = t[lt].ab, t[p].ba = t[lt].ba, t[p].bb = t[lt].bb;\n    &#125;\n    if (rt) &#123;\n        t[p].u = std::min(t[p].u, t[rt].u);\n        t[p].aa = std::min(t[p].aa, t[rt].aa);\n        t[p].ab = std::min(t[p].ab, t[rt].ab);\n        t[p].ba = std::min(t[p].ba, t[rt].ba);\n        t[p].bb = std::min(t[p].bb, t[rt].bb);\n    &#125;\n    if (lt &amp;&amp; rt)\n        t[p].u = std::min(&#123; t[p].u, t[lt].ba + t[rt].aa, t[lt].ab + t[rt].bb &#125;);\n    return;\n&#125;\nint adda(int p, long long l, long long r, int x, int a, int b) &#123;\n    if (!p)\n        p = ++tot, t.emplace_back(), t[p].aa = t[p].ab = t[p].ba = t[p].bb = t[p].u = inf;\n    if (l == r) &#123;\n        if (!t[p].id)\n            t[p].id = ++cnt, aa.emplace_back(), ab.emplace_back(), ba.emplace_back(), bb.emplace_back();\n        int id = t[p].id;\n        aa[id].insert(a), ab[id].insert(b);\n        t[p].aa = *aa[id].begin(), t[p].ab = *ab[id].begin();\n        if (!aa[id].empty() &amp;&amp; !ba[id].empty())\n            t[p].u = std::min(*aa[id].begin() + *ba[id].begin(), *ab[id].begin() + *bb[id].begin());\n        else\n            t[p].u = inf;\n        return p;\n    &#125;\n    long long mid = (l + r) &gt;&gt; 1;\n    if (x &lt;= mid) &#123;\n        auto s(adda(lt, l, mid, x, a, b));\n        lt = s;\n    &#125;\n    else &#123;\n        auto s(adda(rt, mid + 1, r, x, a, b));\n        rt = s;\n    &#125;\n    pushup(p);\n    return p;\n&#125;\nint addb(int p, long long l, long long r, int x, int a, int b) &#123;\n    if (!p)\n        p = ++tot, t.emplace_back(), t[p].aa = t[p].ab = t[p].ba = t[p].bb = t[p].u = inf;\n    if (l == r) &#123;\n        if (!t[p].id)\n            t[p].id = ++cnt, aa.emplace_back(), ab.emplace_back(), ba.emplace_back(), bb.emplace_back();\n        int id = t[p].id;\n        ba[id].insert(a), bb[id].insert(b);\n        t[p].ba = *ba[id].begin(), t[p].bb = *bb[id].begin();\n        if (!aa[id].empty() &amp;&amp; !ba[id].empty())\n            t[p].u = std::min(*aa[id].begin() + *ba[id].begin(), *ab[id].begin() + *bb[id].begin());\n        else\n            t[p].u = inf;\n        return p;\n    &#125;\n    long long mid = (l + r) &gt;&gt; 1;\n    if (x &lt;= mid) &#123;\n        auto s(addb(lt, l, mid, x, a, b));\n        lt = s;\n    &#125;\n    else &#123;\n        auto s(addb(rt, mid + 1, r, x, a, b));\n        rt = s;\n    &#125;\n    pushup(p);\n    return p;\n&#125;\nvoid dela(int p, long long l, long long r, int x, int a, int b) &#123;\n    if (l == r) &#123;\n        int id = t[p].id;\n        aa[id].erase(aa[id].find(a)), ab[id].erase(ab[id].find(b));\n        t[p].aa = (aa[id].empty() ? inf : *aa[id].begin());\n        t[p].ab = (ab[id].empty() ? inf : *ab[id].begin());\n        if (!aa[id].empty() &amp;&amp; !ba[id].empty())\n            t[p].u = std::min(*aa[id].begin() + *ba[id].begin(), *ab[id].begin() + *bb[id].begin());\n        else\n            t[p].u = inf;\n        return;\n    &#125;\n    long long mid = (l + r) &gt;&gt; 1;\n    if (x &lt;= mid)\n        dela(lt, l, mid, x, a, b);\n    else\n        dela(rt, mid + 1, r, x, a, b);\n    pushup(p);\n    return;\n&#125;\nvoid delb(int p, long long l, long long r, int x, int a, int b) &#123;\n    if (l == r) &#123;\n        int id = t[p].id;\n        ba[id].erase(ba[id].find(a)), bb[id].erase(bb[id].find(b));\n        t[p].ba = (ba[id].empty() ? inf : *ba[id].begin());\n        t[p].bb = (bb[id].empty() ? inf : *bb[id].begin());\n        if (!aa[id].empty() &amp;&amp; !ba[id].empty())\n            t[p].u = std::min(*aa[id].begin() + *ba[id].begin(), *ab[id].begin() + *bb[id].begin());\n        else\n            t[p].u = inf;\n        return;\n    &#125;\n    long long mid = (l + r) &gt;&gt; 1;\n    if (x &lt;= mid)\n        delb(lt, l, mid, x, a, b);\n    else\n        delb(rt, mid + 1, r, x, a, b);\n    pushup(p);\n    return;\n&#125;\n#undef lt\n#undef rt\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n    std::freopen(&quot;set.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;set.out&quot;, &quot;w&quot;, stdout);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int q, rt = 0;\n    std::cin &gt;&gt; q;\n    for (int i = 1; i &lt;= q; ++i) &#123;\n        int op, d, a, b;\n        std::cin &gt;&gt; op &gt;&gt; d &gt;&gt; a &gt;&gt; b;\n        if (op == 0 &amp;&amp; d == 0)\n            dela(rt, -inf, inf, a - b, a, b);\n        else if (op == 0)\n            delb(rt, -inf, inf, b - a, a, b);\n        else if (d == 0)\n            rt = adda(rt, -inf, inf, a - b, a, b);\n        else\n            rt = addb(rt, -inf, inf, b - a, a, b);\n        std::cout &lt;&lt; (t[1].u == inf ? -1 : t[1].u) &lt;&lt; &#39;\\n&#39;;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h4 id=\"命运利用线段树的分治结构递推\"># 命运（利用线段树的分治结构递推）</h4>\n<p><a href=\"https://www.luogu.com.cn/problem/P6773\" class=\"uri\">https://www.luogu.com.cn/problem/P6773</a></p>\n<hr />\n<h4 id=\"对数据结构的爱维护函数\">* 对数据结构的爱（维护函数）</h4>\n<p><a href=\"https://www.luogu.com.cn/problem/P5609\" class=\"uri\">https://www.luogu.com.cn/problem/P5609</a></p>\n<blockquote>\n<p>给定长度为 <span class=\"math inline\">\\(n\\)</span> 的数组 <span class=\"math inline\">\\(a\\)</span> 和模数 <span class=\"math inline\">\\(p\\)</span>（<span class=\"math inline\">\\(a_i\\)</span> 初始可能比 <span class=\"math inline\">\\(p\\)</span> 大很多，还有可能为负），给定 <span class=\"math inline\">\\(m\\)</span> 次询问，每次问区间 <span class=\"math inline\">\\([l,r]\\)</span>，进行这样的操作：</p>\n<p>初始 <span class=\"math inline\">\\(sum=0\\)</span>，从 <span class=\"math inline\">\\(l\\)</span> 到 <span class=\"math inline\">\\(r\\)</span>，依次令 <span class=\"math inline\">\\(sum\\gets sum+a_i\\)</span>，当且仅当 <span class=\"math inline\">\\(sum\\ge p\\)</span> 时令 <span class=\"math inline\">\\(sum\\gets sum-p\\)</span>（注意这不是取模，减完之后还是可能 <span class=\"math inline\">\\(\\ge p\\)</span>）。</p>\n<p>问最终 <span class=\"math inline\">\\(sum\\)</span> 的值。<span class=\"math inline\">\\(n\\le 10^6,m\\le 2\\times 10^5\\)</span>。</p>\n</blockquote>\n<p>考虑线段树维护函数。定义 <span class=\"math inline\">\\(f(x)\\)</span> 表示区间上想要减去 <span class=\"math inline\">\\(x\\)</span> 次 <span class=\"math inline\">\\(p\\)</span> 需要的最小初始值（这样才能让定义域和区间长有关），查询时直接二分即可；考虑初始化时如何合并。</p>\n<p>首先思考较为暴力的做法，对于左侧点 <span class=\"math inline\">\\(a\\)</span> 和右侧点 <span class=\"math inline\">\\(b\\)</span>，若 <span class=\"math inline\">\\(f(a+1)-1+s_l-a\\cdot p\\ge f(b)\\)</span>，也即可以减去 <span class=\"math inline\">\\(a+b\\)</span> 次，就可以用 <span class=\"math inline\">\\(\\max(f(a),f(b)-s_l+a\\cdot p)\\)</span> 来更新 <span class=\"math inline\">\\(f(a+b)\\)</span>。</p>\n<p>发现 <span class=\"math inline\">\\((a,b)\\)</span> 的贡献一定小于 <span class=\"math inline\">\\((a+1,b-1)\\)</span> 的贡献；具体地，发现 <span class=\"math inline\">\\(f(x+1)-f(x)\\ge p\\)</span> 后就很显然了。采用双指针，优先移动 <span class=\"math inline\">\\(b\\)</span>，就能把最短区间扫一遍。</p>\n<details>\n<p><summary>关于线段树维护函数</summary></p>\n<p>维护一个函数，形如 <span class=\"math inline\">\\(f_{[l,r]}(x)\\)</span> 表示在 <span class=\"math inline\">\\([l,r]\\)</span> 区间上，<span class=\"math inline\">\\(x\\)</span> 的一个映射</p>\n<p>如果相邻区间的函数可以用某种方式合并，就可以用线段树来维护</p>\n<p>把树建在值域上，就可以在节点内把这段区间每个点对应的函数值存下来。一般来说是静态的，因为这是一个类前缀和的形式，没办法修改</p>\n<p>每个点的点值数组会在当前层被扫一遍，上一层被扫一遍，如果合并能够做到线性，总复杂度就是单 <span class=\"math inline\">\\(\\log\\)</span> 的。</p>\n<p>实际情形下函数本身可能很隐秘、很抽象，怎么优化到线性合并也不太好想</p>\n</details>\n<hr />\n<h4 id=\"compounds模意义下问题\">* COmPoUNdS（模意义下问题）</h4>\n<p><a href=\"https://www.luogu.com.cn/problem/P12389\" class=\"uri\">https://www.luogu.com.cn/problem/P12389</a></p>\n<blockquote>\n<p>给定常数模数，维护模意义下的区间加、区间哈希（即判断两段区间是否全等）。<span class=\"math inline\">\\(n\\le 10^6\\)</span>。</p>\n</blockquote>\n<p><strong>线段树哈希是可以维护区间加的</strong>，但是没办法维护区间取模</p>\n<p>类似 <a href=\"/20250816/#e---subarray-sum-divisibility\">ABC419E</a> 里面用到的，模意义下序列全等可以转化成差分全等，区间修改就可以简化成单点修改了</p>\n<p>额外判一下开头的元素（维护原数组或者是差分数组之和）是否相等就可以了</p>\n<hr />\n<h4 id=\"改进代码模意义下问题\">* 改进代码（模意义下问题）</h4>\n<p><a href=\"https://www.luogu.com.cn/problem/P4635\" class=\"uri\">https://www.luogu.com.cn/problem/P4635</a></p>\n<blockquote>\n<p>给定序列 <span class=\"math inline\">\\(a_{1\\sim n}\\)</span> 和常数 <span class=\"math inline\">\\(p\\)</span>，维护:</p>\n<ul>\n<li>修改：模 <span class=\"math inline\">\\(p\\)</span> 意义下区间加；</li>\n<li>询问：区间中 <span class=\"math inline\">\\(\\sum\\limits_{i=l}^{r-1}[a_i&gt;a_{i+1}]\\)</span>。</li>\n</ul>\n<p><span class=\"math inline\">\\(n\\le 10^5,p\\le 10^6\\)</span>。</p>\n</blockquote>\n<p>询问也和模意义差分有关系，假如 <span class=\"math inline\">\\(s\\)</span> 为当前差分数组前缀和模 <span class=\"math inline\">\\(p\\)</span> 的值（也就是原数），发现<strong>前一个数 <span class=\"math inline\">\\(&gt;\\)</span> 后一个数当且仅当 <span class=\"math inline\">\\(s\\)</span> 加爆了</strong>。维护原数组用来确定 <span class=\"math inline\">\\(s\\)</span> 的初值。再维护区间内差分数组之和（不取模），<strong>在这个和里有多少个 <span class=\"math inline\">\\(p\\)</span> 就会爆多少次</strong>。</p>\n<hr />\n<h4 id=\"黑白树很新的东西\">黑白树（很新的东西）</h4>\n<p><a href=\"http://222.180.160.110:61235/problem/46907\" class=\"uri\">http://222.180.160.110:61235/problem/46907</a></p>\n<hr />\n<h3 id=\"以楼房重建为代表的-log2-一类前缀信息维护\">以楼房重建为代表的 <span class=\"math inline\">\\(\\log^2\\)</span> 一类前缀信息维护</h3>\n<p>特点：pushup 时需要先获得一边的信息，在另一边进行线段树上二分，单次操作是 <span class=\"math inline\">\\(O(\\log^2)\\)</span> 的</p>\n<p>本质是一类具有<strong>单调性</strong>的前 / 后缀信息，<strong>区间对全局的贡献</strong>和<strong>区间外的信息</strong>有关，故不能直接维护对全局的贡献，只能维护区间内的答案。但由于两个子区间答案可以合并出大区间答案（通过线段树上二分得到需要的信息），所以只需要逐层向上合并就可以得到全局答案</p>\n<p>一个名字是『线段树维护前缀信息』，感觉不很精确。log 方线段树又是什么鬼名字？兔队线段树又是谁起的（upd：疑似皎月半洒花）？更多还是叫的楼房重建线段树吧</p>\n<hr />\n<h4 id=\"楼房重建\">楼房重建</h4>\n<p><a href=\"https://www.luogu.com.cn/problem/P4198\" class=\"uri\">https://www.luogu.com.cn/problem/P4198</a></p>\n<blockquote>\n<p>给定 <span class=\"math inline\">\\(a_{1\\sim n}\\)</span>，维护 <span class=\"math inline\">\\(q\\)</span> 次操作：</p>\n<ul>\n<li>单点修改；</li>\n<li>查询 <span class=\"math inline\">\\(\\dfrac{a_i}i\\)</span> 的前缀最大值序列长度。</li>\n</ul>\n<p><span class=\"math inline\">\\(n,q\\le 10^5\\)</span>。</p>\n</blockquote>\n<p>Fractures 说当年（初一）是他力荐 gm 给我们拉这个题的。dashena！</p>\n<ul>\n<li>线段树维护单调栈，或者说前缀最值，维护方式过于经典，使得『楼房重建』成为该 trick 称呼之一</li>\n<li><p>考虑 pushup。保留左边整段区间，对于左区间序列末的元素 <code>l.rv</code>，我们在右区间内找到第一个大于之的元素 <span class=\"math inline\">\\(x\\)</span>，从它开始的序列就是答案。</p>\n反证法易得 <span class=\"math inline\">\\(x\\)</span> 一定在右区间答案序列内：若 <span class=\"math inline\">\\(x\\)</span> 不在答案序列内，则右区间内存在一个 <span class=\"math inline\">\\(&gt;x\\)</span> 且位于 <span class=\"math inline\">\\(x\\)</span> 之前的元素，那么 <span class=\"math inline\">\\(x\\)</span> 就不是第一个 <code>&gt; l.rv</code> 的元素，矛盾。</li>\n<li><p>故在右区间中二分能够接上去的区间长度，加起来即可。</p>\n<p>题目只要求总区间答案，故不需要查询。动态开点可能需要小心处理一下。</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 1e5 + 5;\nstruct &#123;\n    int l, r, u;\n    double lv, rv, mv;\n&#125; t[maxn &lt;&lt; 2];\nint tot;\n#define lt t[p].l\n#define rt t[p].r\nint askt(int p, int l, int r, double v) &#123;\n    if (l == r)\n        return t[p].u;\n    int mid = (l + r) &gt;&gt; 1;\n    if (lt &amp;&amp; t[p].mv &gt; v)\n        return t[p].u - t[lt].u + askt(lt, l, mid, v);\n    return askt(rt, mid + 1, r, v);\n&#125;\nvoid pushup(int p, int l, int r) &#123;\n    t[p].mv = t[lt].rv;\n    if (lt &amp;&amp; rt) &#123;\n        t[p].lv = t[lt].lv;\n        t[p].rv = std::max(t[lt].rv, t[rt].rv);\n        if (t[lt].rv &lt; t[rt].lv)\n            t[p].u = t[lt].u + t[rt].u;\n        else if (t[lt].rv &gt;= t[rt].rv)\n            t[p].u = t[lt].u;\n        else &#123;\n            int mid = (l + r) &gt;&gt; 1;\n            t[p].u = t[lt].u + askt(rt, mid + 1, r, t[lt].rv);\n        &#125;\n    &#125;\n    else &#123;\n        t[p].u = t[lt + rt].u;\n        t[p].lv = t[lt + rt].lv, t[p].rv = t[lt + rt].rv;\n    &#125;\n    return;\n&#125;\nvoid upd(int &amp;p, int l, int r, int x, double v) &#123;\n    if (!p)\n        p = ++tot;\n    if (l == r) &#123;\n        t[p].lv = t[p].rv = v, t[p].u = 1;\n        return;\n    &#125;\n    int mid = (l + r) &gt;&gt; 1;\n    if (x &lt;= mid)\n        upd(lt, l, mid, x, v);\n    else\n        upd(rt, mid + 1, r, x, v);\n    pushup(p, l, r);\n    return;\n&#125;\n#undef lt\n#undef rt\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;P4198_2.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, m, rt = 0;\n    std::cin &gt;&gt; n &gt;&gt; m;\n    std::vector&lt;double&gt; a(n + 1);\n    for (int x; m--; ) &#123;\n        double y;\n        std::cin &gt;&gt; x &gt;&gt; y;\n        a[x] = y / x;\n        upd(rt, 1, n, x, y / x);\n        std::cout &lt;&lt; t[1].u &lt;&lt; &#39;\\n&#39;;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h4 id=\"二叉搜索树\">二叉搜索树</h4>\n<p><a href=\"https://pjudge.ac/problem/21889\" class=\"uri\">https://pjudge.ac/problem/21889</a></p>\n<blockquote>\n<p>给定一个大小为 <span class=\"math inline\">\\(n\\)</span> 的树，树上每个元素是一个 BST，你需要维护 <span class=\"math inline\">\\(q\\)</span> 次操作：</p>\n<ol type=\"1\">\n<li>对于树上的一条路径 <span class=\"math inline\">\\((u,v)\\)</span>，在经过的所有节点上的 BST 插入 <span class=\"math inline\">\\(x\\)</span>，保证任意时刻 BST 中无相同值</li>\n<li>在点 <span class=\"math inline\">\\(u\\)</span> 查找 <span class=\"math inline\">\\(x\\)</span>，如果 <span class=\"math inline\">\\(x\\)</span> 存在则返回其到 BST 根的元素和，否则返回查找时最远走到的那个点，到 BST 根的元素和。</li>\n</ol>\n<p><span class=\"math inline\">\\(n,q\\le 2\\times 10^5\\)</span>。</p>\n</blockquote>\n<ul>\n<li>考虑链上问题。差分，把更新 <span class=\"math inline\">\\([l, r]\\)</span> 看作在差分数组 <span class=\"math inline\">\\(l\\)</span> 处插入，在 <span class=\"math inline\">\\(r+1\\)</span> 处删除，离线下来再从左到右扫一遍操作就能更新。</li>\n<li>考虑查询。<span class=\"math inline\">\\(i\\)</span> 树上存在过的所有元素是已知的，考虑如何基于此获取 <span class=\"math inline\">\\(i\\)</span> 树上 <span class=\"math inline\">\\(t_0\\)</span> 时刻，<span class=\"math inline\">\\(x\\)</span> 的所有祖先。</li>\n<li><p>对于比 <span class=\"math inline\">\\(x\\)</span> 大的元素，考虑祖先 <span class=\"math inline\">\\(p_a\\)</span> 和非祖先 <span class=\"math inline\">\\(p\\)</span> 的区别：</p>\n<p>根据 BST 的性质易得，对于最低的右侧祖先 <span class=\"math inline\">\\({p_a}_0\\)</span>，其是 <span class=\"math inline\">\\(\\ge x\\)</span> 的最小的元素（加入时刻 <span class=\"math inline\">\\(t_a&lt;t_0\\)</span>）；</p>\n同理可以找到 <span class=\"math inline\">\\({p_a}_0\\)</span> 右侧最低的祖先（其左侧的祖先显然也在 <span class=\"math inline\">\\(x\\)</span> 左侧），该祖先满足 <span class=\"math inline\">\\(t&lt;t_a\\)</span>。从左右两边分别得到 <span class=\"math inline\">\\(x\\)</span> 的所有祖先。容易证明该过程对于不在树上的 <span class=\"math inline\">\\(x\\)</span> 也是正确的。</li>\n<li>具体地，需要能够求出 <span class=\"math inline\">\\(\\ge x\\)</span> 的元素中，以 <span class=\"math inline\">\\(t_0\\)</span> 为起点的前缀最小值序列的区间和。线段树维护单调栈容易解决不带 <span class=\"math inline\">\\(t_0\\)</span> 限制的答案；再次利用性质就能满足限制。</li>\n<li><p>对于树的情况，把差分放到树上，线段树合并即可。</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int lim = 2e5;\nconst int maxn = 2e7 + 5;\nconst int inf = 0x3f3f3f3f;\nstruct &#123;\n    int l, r, rv;\n    long long u;\n&#125; t[maxn];\nstd::vector&lt;int&gt; tr;\n#define lt t[p].l\n#define rt t[p].r\nint newnode(void) &#123;\n    static int tot = 0;\n    if (tr.empty())\n        return ++tot;\n    auto p(tr.back());\n    t[p].l = t[p].r = 0;\n    tr.pop_back();\n    return p;\n&#125;\nlong long askv(int p, int l, int r, int v) &#123;\n    if (l == r)\n        return t[p].rv &lt; v ? t[p].u : 0;\n    int mid = (l + r) &gt;&gt; 1;\n    if (v &gt; t[lt].rv)\n        return t[p].u - t[lt].u + askv(lt, l, mid, v);\n    return askv(rt, mid + 1, r, v);\n&#125;\nvoid pushup(int p, int l, int r) &#123;\n    t[p].rv = std::min(t[lt].rv, t[rt].rv);\n    int mid = (l + r) &gt;&gt; 1;\n    t[p].u = t[lt].u + askv(rt, mid + 1, r, t[lt].rv);\n    return;\n&#125;\nvoid upd(int &amp;p, int l, int r, int x, int v, int u) &#123;\n    if (!p)\n        p = newnode();\n    if (l == r) &#123;\n        t[p].rv = v, t[p].u = u;\n        return;\n    &#125;\n    int mid = (l + r) &gt;&gt; 1;\n    if (x &lt;= mid)\n        upd(lt, l, mid, x, v, u);\n    else\n        upd(rt, mid + 1, r, x, v, u);\n    pushup(p, l, r);\n    return;\n&#125;\nvoid merge(int &amp;p, int q, int l, int r) &#123;\n    if (!p || !q) &#123;\n        p += q;\n        return;\n    &#125;\n    if (l == r) &#123;\n        t[p].rv = std::min(t[p].rv, t[q].rv);\n        t[p].u = std::max(t[p].u, t[q].u);\n        return;\n    &#125;\n    int mid = (l + r) &gt;&gt; 1;\n    merge(t[p].l, t[q].l, l, mid), merge(t[p].r, t[q].r, mid + 1, r);\n    pushup(p, l, r), tr.push_back(q);\n    return;\n&#125;\nint qv = inf;\nlong long ask(int p, int l, int r, int ql, int qr) &#123;\n    if (ql &lt;= l &amp;&amp; r &lt;= qr) &#123;\n        auto s(askv(p, l, r, qv));\n        qv = std::min(qv, t[p].rv);\n        return s;\n    &#125;\n    int mid = (l + r) &gt;&gt; 1;\n    long long res = 0ll;\n    if (ql &lt;= mid)\n        res = ask(lt, l, mid, ql, qr);\n    if (qr &gt; mid)\n        res += ask(rt, mid + 1, r, ql, qr);\n    return res;\n&#125;\n#undef lt\n#undef rt\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;ex_problem4.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, m;\n    std::cin &gt;&gt; n &gt;&gt; m;\n    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);\n    for (int i = 1, x, y; i &lt; n; ++i) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y;\n        g[x].push_back(y), g[y].push_back(x);\n    &#125;\n    std::vector&lt;int&gt; top(n + 1), fa(n + 1), siz(n + 1), son(n + 1), dep(n + 1);\n    std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int faa) &#123;\n        siz[x] = 1;\n        for (auto i : g[x])\n            if (i != faa) &#123;\n                fa[i] = x, dep[i] = dep[x] + 1;\n                DFS(i, x), siz[x] += siz[i];\n                if (siz[i] &gt; siz[son[x]])\n                    son[x] = i;\n            &#125;\n        return;\n    &#125;;\n    DFS(1, -1);\n    DFS = [&amp;](int x, int topp) &#123;\n        top[x] = topp;\n        if (son[x])\n            DFS(son[x], topp);\n        for (auto i : g[x])\n            if (i != fa[x] &amp;&amp; i != son[x])\n                DFS(i, i);\n        return;\n    &#125;;\n    DFS(1, 1);\n    auto getLCA = [&amp;](int x, int y) &#123;\n        for (; top[x] != top[y]; x = fa[top[x]])\n            if (dep[top[y]] &gt; dep[top[x]])\n                std::swap(x, y);\n        return (dep[x] &lt; dep[y] ? x : y);\n    &#125;;\n    std::vector&lt;std::vector&lt;int&gt; &gt; d(n + 1);\n    std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; u(n + 1);\n    std::vector&lt;std::vector&lt;std::tuple&lt;int, int, int&gt; &gt; &gt; q(n + 1);\n    int cnt = 0;\n    for (int i = 1; i &lt;= m; ++i) &#123;\n        int op;\n        std::cin &gt;&gt; op;\n        if (op == 0) &#123;\n            int x, v;\n            std::cin &gt;&gt; x &gt;&gt; v;\n            q[x].emplace_back(++cnt, i, v);\n        &#125; else &#123;\n            int x, y, v;\n            std::cin &gt;&gt; x &gt;&gt; y &gt;&gt; v;\n            int faa = getLCA(x, y);\n            u[x].emplace_back(i, v), u[y].emplace_back(i, v);\n            if (fa[faa])\n                d[fa[faa]].emplace_back(v);\n        &#125;\n    &#125;\n    std::vector&lt;long long&gt; res(cnt + 1);\n    std::vector&lt;std::vector&lt;int&gt; &gt; rt(2, std::vector&lt;int&gt; (n + 1));\n    t[0].rv = inf;\n    DFS = [&amp;](int x, int fa) &#123;\n        for (auto i : g[x])\n            if (i != fa) &#123;\n                DFS(i, x);\n                merge(rt[0][x], rt[0][i], 1, lim);\n                merge(rt[1][x], rt[1][i], 1, lim);\n            &#125;\n        for (auto [t, v] : u[x]) &#123;\n            upd(rt[0][x], 1, lim, v, t, v);\n            upd(rt[1][x], 1, lim, lim - v + 1, t, v);\n        &#125;\n        for (auto v : d[x]) &#123;\n            upd(rt[0][x], 1, lim, v, inf, 0);\n            upd(rt[1][x], 1, lim, lim - v + 1, inf, 0);\n        &#125;\n        for (auto [id, t, v] : q[x]) &#123;\n            qv = t, res[id] = ask(rt[0][x], 1, lim, v, lim);\n            qv = t, res[id] += ask(rt[1][x], 1, lim, lim - v + 1, lim);\n            qv = t, res[id] -= ask(rt[0][x], 1, lim, v, v);\n        &#125;\n    &#125;;\n    DFS(1, -1);\n    for (int i = 1; i &lt;= cnt; ++i)\n        std::cout &lt;&lt; res[i] &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h4 id=\"nastya-and-cbs\">Nastya and CBS</h4>\n<p><a href=\"https://www.luogu.com.cn/problem/CF1340F\" class=\"uri\">https://www.luogu.com.cn/problem/CF1340F</a></p>\n<blockquote>\n<p>给定长度为 <span class=\"math inline\">\\(n\\)</span> 的括号序列，由 <span class=\"math inline\">\\(k\\)</span> 种括号对（<span class=\"math inline\">\\(-i,i\\)</span> 表示第 <span class=\"math inline\">\\(i\\)</span> 种左、右括号）组成，你需要维护单点修改元素、区间查询是否为合法括号序列。</p>\n<p><span class=\"math inline\">\\(1\\le k\\le n\\le 10^5,q\\le 10^5\\)</span>。</p>\n</blockquote>\n<ul>\n<li>考虑不带修且允许 <span class=\"math inline\">\\(O(n)\\)</span> 询问的情景，经典题，扫一遍，用栈维护即可；</li>\n<li><p><span class=\"math inline\">\\(k=1\\)</span> 时是线段树经典题，可以类比这个经典题，从刻画合法的条件入手。</p>\n如果存在相邻且可以匹配的可以直接消掉，一直重复这样的操作，此时要么包含不能匹配的子串，如 <code>&#123;[)&#125;</code>，要么是 <code>)]&#125; (&#123;[&#123;&#123;</code> 的形式。</li>\n<li>考虑怎么 pushup，发现中间生成的一段 <code>([()])</code> 必须完全匹配，消掉它们之后，大区间又变成 <code>)]&#125; (&#123;[&#123;&#123;</code> 的形式。</li>\n<li>每次 pushup 要合并的区间很长，考虑怎么快速地做『消除相邻匹配括号』这一步。容易想到记录一段括号（例：<code>([&#123;</code>）及其对应反括号（例：<code>&#125;])</code>）的哈希值，check 是否相等，然后就可以不管它们了，并不是真的要删去。</li>\n<li><p>线段树不能维护每个前后缀的哈希值，但需要的只是在<strong>删除连续匹配括号后</strong>长度为 <span class=\"math inline\">\\(len\\)</span> 的哈希值，可以线段树上二分。</p>\n这个过程有点困难，需要在询问的同时匹配、消除；但发现所谓消除就是对位相减，注意一下什么时候移位，还是好写的。</li>\n<li><p>询问看似不太可做，因为中途的答案不是线段树的节点；如果把询问看成一次修改，就可以用类似可持久化的方式实现。</p>\n<p>由于并不是真的要可持久化，询问新建的点可以重复利用。如果不重复利用，每次询问最多新建 <span class=\"math inline\">\\(O(\\log n)\\)</span> 个点，空间复杂度 <span class=\"math inline\">\\(O(q\\log n)\\)</span>，在 CF 上有点卡，也是能过的。</p></li>\n</ul>\n<details>\n<p>Hint：有卡 998244353 的 Hack，故可以用 1e9 + 7 当模数；WA on 7 是正确性有巨大问题，WA on 8 可能是 long long 没开完 / 数组开小了 / 哈希方向有问题 / 线段树上二分写挂了（通常是消括号消错了）。前人踩坑后人嘲笑。</p>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 1e9 + 7;\nconst int base = 1e5 + 3;\nconst int maxn = 7e5 + 5;\nstruct Node &#123;\n    bool flag;\n    long long hr0, hl1;\n    int l, r, lc, rc, ll, rl;\n    Node&amp; operator= (const Node &amp;q) &#123;\n        flag = q.flag, hr0 = q.hr0, hl1 = q.hl1;\n        l = q.l, r = q.r, ll = q.ll, rl = q.rl;\n        return *this;\n    &#125;\n    Node operator+ (const Node &amp;q) const;\n&#125; t[maxn &lt;&lt; 2];\nint tot;\nint a[maxn];\nlong long bpow[maxn], inv[maxn];\nlong long askhl1(const Node &amp;p, int k) &#123;\n    if (k == 0)\n        return 0ll;\n    if (k &gt; p.ll)\n        return -1ll;\n    if (p.ll == k)\n        return p.hl1;\n    int ll = t[p.lc].ll, rl = t[p.lc].rl;\n    if (ll &gt;= k)\n        return askhl1(t[p.lc], k);\n    k -= ll, k += rl;\n    auto hl1 = askhl1(t[p.rc], k);\n    hl1 = ((hl1 + mod - t[p.lc].hr0) * inv[rl] % mod * bpow[ll] % mod + t[p.lc].hl1) % mod;\n    return hl1;\n&#125;\nlong long askhr0(const Node &amp;p, int k) &#123;\n    if (k == 0)\n        return 0ll;\n    if (k &gt; p.rl)\n        return -1ll;\n    if (p.rl == k)\n        return p.hr0;\n    int rl = t[p.rc].rl, ll = t[p.rc].ll;\n    if (rl &gt;= k)\n        return askhr0(t[p.rc], k);\n    k -= rl, k += ll;\n    auto hr0 = askhr0(t[p.lc], k);\n    hr0 = ((hr0 + mod - t[p.rc].hl1) * inv[ll] % mod * bpow[rl] % mod + t[p.rc].hr0) % mod;\n    return hr0;\n&#125;\nNode Node::operator+ (const Node &amp;q) const  &#123;\n    Node res;\n    res.l = l, res.r = q.r;\n    if (flag || q.flag)\n        res.flag = 1;\n    else &#123;\n        if (rl == q.ll) &#123;\n            if (hr0 == q.hl1) &#123;\n                res.flag = 0;\n                res.ll = ll, res.rl = q.rl;\n                res.hl1 = hl1, res.hr0 = q.hr0;\n            &#125;\n            else\n                res.flag = 1;\n        &#125;\n        else if (rl &lt; q.ll) &#123;\n            auto qhl1 = askhl1(q, rl);\n            if (hr0 == qhl1) &#123;\n                res.flag = 0;\n                res.ll = ll + q.ll - rl, res.rl = q.rl;\n                res.hl1 = ((q.hl1 + mod - qhl1) % mod * inv[rl] % mod * bpow[ll] % mod + hl1) % mod;\n                res.hr0 = q.hr0;\n            &#125;\n            else\n                res.flag = 1;\n        &#125;\n        else &#123;\n            auto phr0 = askhr0(*this, q.ll);\n            if (phr0 == q.hl1) &#123;\n                res.flag = 0;\n                res.ll = ll, res.rl = rl - q.ll + q.rl;\n                res.hl1 = hl1;\n                res.hr0 = ((hr0 + mod - phr0) % mod * inv[q.ll] % mod * bpow[q.rl] % mod + q.hr0) % mod;\n            &#125;\n            else\n                res.flag = 1;\n        &#125;\n    &#125;\n    return res;\n&#125;\nvoid bld(int &amp;p, int l, int r) &#123;\n    p = ++tot;\n    if (l == r) &#123;\n        t[p].l = t[p].r = l;\n        if (a[l] &lt; 0)\n            t[p].ll = 1, t[p].hl1 = -a[l];\n        else\n            t[p].rl = 1, t[p].hr0 = a[l];\n        return;\n    &#125;\n    int mid = (l + r) &gt;&gt; 1;\n    bld(t[p].lc, l, mid), bld(t[p].rc, mid + 1, r);\n    t[p] = t[t[p].lc] + t[t[p].rc];\n    return;\n&#125;\nvoid add(int p, int x, int v) &#123;\n    if (t[p].l == t[p].r) &#123;\n        if (v &lt; 0) &#123;\n            t[p].rl = 0, t[p].hr0 = 0ll;\n            t[p].ll = 1, t[p].hl1 = -v;\n        &#125;\n        else &#123;\n            t[p].ll = 0, t[p].hl1 = 0ll;\n            t[p].rl = 1, t[p].hr0 = v;\n        &#125;\n        return;\n    &#125;\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (x &lt;= mid)\n        add(t[p].lc, x, v);\n    else\n        add(t[p].rc, x, v);\n    t[p] = t[t[p].lc] + t[t[p].rc];\n    return;\n&#125;\nint ask(int p, int l, int r) &#123;\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r)\n        return p;\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (r &lt;= mid)\n        return ask(t[p].lc, l, r);\n    if (l &gt; mid)\n        return ask(t[p].rc, l, r);\n    int q = ++tot;\n    t[q].lc = ask(t[p].lc, l, r);\n    t[q].rc = ask(t[p].rc, l, r);\n    t[q] = t[t[q].lc] + t[t[q].rc];\n    return q;\n&#125;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, k, rt = 0;\n    std::cin &gt;&gt; n &gt;&gt; k;\n    bpow[0] = inv[0] = 1ll;\n    auto qkp = [&amp;](long long x, int y) &#123;\n        auto res(1ll);\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    inv[1] = qkp(base, mod - 2);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; a[i];\n        bpow[i] = bpow[i - 1] * base % mod;\n        if (i &gt;= 2)\n            inv[i] = inv[i - 1] * inv[1] % mod;\n    &#125;\n    bld(rt, 1, n);\n    int q;\n    std::cin &gt;&gt; q;\n    for (int op; q--; ) &#123;\n        std::cin &gt;&gt; op;\n        if (op == 1) &#123;\n            int x, v;\n            std::cin &gt;&gt; x &gt;&gt; v;\n            add(1, x, v);\n        &#125;\n        else &#123;\n            int l, r;\n            std::cin &gt;&gt; l &gt;&gt; r;\n            if ((r - l + 1) &amp; 1)\n                std::cout &lt;&lt; &quot;No&quot; &lt;&lt; &#39;\\n&#39;;\n            else &#123;\n                auto s(ask(1, l, r));\n                std::cout &lt;&lt; ((!t[s].flag &amp;&amp; !t[s].ll &amp;&amp; !t[s].rl) ? &quot;Yes&quot; : &quot;No&quot;) &lt;&lt; &#39;\\n&#39;;\n            &#125;\n        &#125;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h4 id=\"hungry-cow-p\"># Hungry Cow P</h4>\n<p><a href=\"https://www.luogu.com.cn/problem/P9130\" class=\"uri\">https://www.luogu.com.cn/problem/P9130</a></p>\n<hr />\n<h4 id=\"牛半仙的妹子序列\"># 牛半仙的妹子序列</h4>\n<p><a href=\"http://222.180.160.110:61235/problem/29550\" class=\"uri\">http://222.180.160.110:61235/problem/29550</a></p>\n<hr />\n<h4 id=\"organizing-a-race\"># Organizing a Race</h4>\n<p><a href=\"https://www.luogu.com.cn/problem/CF671E\" class=\"uri\">https://www.luogu.com.cn/problem/CF671E</a></p>\n<p>这个题不太应该放在这里的，因为存在只用一只 log 的纯线段树上二分做法，用楼房重建显得有点唐了</p>\n<hr />\n<h4 id=\"转盘\"># 转盘</h4>\n<p><a href=\"https://www.luogu.com.cn/problem/P4425\" class=\"uri\">https://www.luogu.com.cn/problem/P4425</a></p>\n<hr />\n<h4 id=\"前进四楼房重建-ver\"># 前进四（楼房重建 ver）</h4>\n<p><a href=\"https://uoj.ac/problem/515\" class=\"uri\">https://uoj.ac/problem/515</a></p>\n<p>另见 <a href=\"#-前进四segment-tree-beats-ver\">segment tree beats ver</a></p>\n<h3 id=\"可持久化线段树\">可持久化线段树</h3>\n<h4 id=\"card-game\"># Card Game</h4>\n<p><a href=\"https://qoj.ac/problem/8240\" class=\"uri\">https://qoj.ac/problem/8240</a></p>\n<hr />\n<h3 id=\"历史信息\">历史信息</h3>\n<ul>\n<li>一类形如『询问 <span class=\"math inline\">\\([l,r]\\)</span> 内合法子区间数量』的题目是可以考虑历史信息的</li>\n<li>具体地，扫描线，对于每个 <span class=\"math inline\">\\(r\\)</span>，把合法的 <span class=\"math inline\">\\(l\\)</span> 答案加一</li>\n<li>在每个 <span class=\"math inline\">\\(r\\)</span> 处查询 <span class=\"math inline\">\\([l,r]\\)</span> 的区间和就可以得出答案</li>\n</ul>\n<h4 id=\"铃原露露\">铃原露露</h4>\n<p><a href=\"https://www.luogu.com.cn/problem/P8528\" class=\"uri\">https://www.luogu.com.cn/problem/P8528</a></p>\n<ul>\n<li>题目形式满足树上支配对，考虑寻找支配关系</li>\n<li><p>固定一个 LCA <span class=\"math inline\">\\(z\\)</span>，讨论 <span class=\"math inline\">\\(a_z\\)</span> 与 <span class=\"math inline\">\\(a_x,a_y\\)</span> 的大小关系给 <span class=\"math inline\">\\([1,a_x]\\)</span> 间的 <span class=\"math inline\">\\(l\\)</span> 带来的限制：</p>\n<ul>\n<li><span class=\"math inline\">\\(a_z\\in[a_x,a_y]\\)</span>，<span class=\"math inline\">\\((x,y)\\)</span> 总是合法，无限制。</li>\n<li><span class=\"math inline\">\\(a_z&lt;a_x\\)</span>，对于 <span class=\"math inline\">\\(r\\ge a_y\\)</span>，当 <span class=\"math inline\">\\(l\\in(a_z,a_x]\\)</span> 时，<span class=\"math inline\">\\((x,y)\\)</span> 非法。</li>\n<li><span class=\"math inline\">\\(a_z&gt;a_y\\)</span>，当 <span class=\"math inline\">\\(r\\in[a_y,a_z)\\)</span> 时，<span class=\"math inline\">\\((x,y)\\)</span> 总是非法。此时所有 <span class=\"math inline\">\\(l\\in[1,a_x]\\)</span> 不可选。</li>\n</ul></li>\n<li>发现固定 <span class=\"math inline\">\\(a_z,a_x\\)</span>，那么当 <span class=\"math inline\">\\(a_y\\)</span> 越靠近 <span class=\"math inline\">\\(a_x\\)</span> 时给出的限制越紧，反之亦然，就可以得到这样的支配关系</li>\n<li>容易发现当 <span class=\"math inline\">\\(a_z\\notin [a_x,a_y]\\)</span> 时，<span class=\"math inline\">\\((x,y)\\)</span> 不合法；故只需要在 dsu on tree 上找到 <span class=\"math inline\">\\(a_x\\)</span> 的前驱、后继并统计支配对即可</li>\n<li><p>考虑询问，发现需要维护区间加、区间历史 0 个数，是好做的（这里的区间加并不对应 summary 中提到的区间加；对 0 的更新才是）。</p></li>\n</ul>\n<p>历史标记的下传需要格外注意一下，应该只保证标记期间存在 0 的区间拥有懒标记；具体地，<strong>只应将其下传到和当前区间最小值相同的子区间</strong>（具体可以看代码），容易证明是对的。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 2e5 + 5;\nstruct node &#123;\n    long long s;\n    int l, r, u, c, d, d1;\n    node operator+ (const node q) const &#123;\n        node res;\n        res.s = s + q.s;\n        res.l = l, res.r = q.r;\n        res.u = std::min(u, q.u);\n        res.d = res.d1 = res.c = 0;\n        if (u == res.u)\n            res.c = c;\n        if (q.u == res.u)\n            res.c += q.c;\n        return res;\n    &#125;\n&#125; t[maxn &lt;&lt; 2];\n#define lt (p &lt;&lt; 1)\n#define rt (lt | 1)\nvoid bld(int p, int l, int r) &#123;\n    t[p].c = r - l + 1;\n    t[p].l = l, t[p].r = r;\n    if (l == r)\n        return;\n    int mid = (l + r) &gt;&gt; 1;\n    bld(lt, l, mid), bld(rt, mid + 1, r);\n    return;\n&#125;\nvoid pushdown(int p) &#123;\n    if (t[p].d) &#123;\n        t[lt].d += t[p].d, t[lt].u += t[p].d;\n        t[rt].d += t[p].d, t[rt].u += t[p].d;\n        t[p].d = 0;\n    &#125;\n    if (t[p].d1) &#123;\n        if (t[lt].u == t[p].u) &#123;\n            t[lt].s += (long long)t[lt].c * t[p].d1;\n            t[lt].d1 += t[p].d1;\n        &#125;\n        if (t[rt].u == t[p].u) &#123;\n            t[rt].s += (long long)t[rt].c * t[p].d1;\n            t[rt].d1 += t[p].d1;\n        &#125;\n        t[p].d1 = 0;\n    &#125;\n    return;\n&#125;\nvoid add(int p, int l, int r, int v) &#123;\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r) &#123;\n        t[p].d += v, t[p].u += v;\n        return;\n    &#125;\n    pushdown(p);\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (l &lt;= mid)\n        add(lt, l, r, v);\n    if (r &gt; mid)\n        add(rt, l, r, v);\n    t[p] = t[lt] + t[rt];\n    return;\n&#125;\nvoid upd(int p, int l, int r) &#123;\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r) &#123;\n        if (!t[p].u)\n            t[p].s += t[p].c, ++t[p].d1;\n        return;\n    &#125;\n    pushdown(p);\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (l &lt;= mid)\n        upd(lt, l, r);\n    if (r &gt; mid)\n        upd(rt, l, r);\n    t[p] = t[lt] + t[rt];\n    return;\n&#125;\nlong long ask(int p, int l, int r) &#123;\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r)\n        return t[p].s;\n    pushdown(p);\n    auto res(0ll);\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (l &lt;= mid)\n        res = ask(lt, l, r);\n    if (r &gt; mid)\n        res += ask(rt, l, r);\n    return res;\n&#125;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, m;\n    std::cin &gt;&gt; n &gt;&gt; m;\n    std::vector&lt;int&gt; a(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i];\n    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1); \n    for (int i = 2, x; i &lt;= n; ++i)\n        std::cin &gt;&gt; x, g[x].push_back(i);\n    std::vector&lt;int&gt; siz(n + 1), son(n + 1);\n    std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;\n        siz[x] = 1;\n        for (auto i : g[x]) &#123;\n            DFS(i);\n            siz[x] += siz[i];\n            if (siz[i] &gt; siz[son[x]])\n                son[x] = i;\n        &#125;\n        return;\n    &#125;;\n    DFS(1);\n    std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; u1(n + 1), u2(n + 1);\n    std::function&lt;void(int, int, std::set&lt;int&gt; &amp;)&gt; DFS2 = [&amp;](int col, int x, std::set&lt;int&gt; &amp;t) &#123;\n        auto p = t.lower_bound(a[x]);\n        if (col == -1)\n            t.insert(a[x]);\n        else &#123;\n            if (p != t.begin()) &#123;\n                int y = *std::prev(p);\n                if (col &lt; y)\n                    u1[a[x]].emplace_back(col + 1, y);\n                else if (col &gt; a[x]) &#123;\n                    u1[a[x]].emplace_back(1, y);\n                    u2[col].emplace_back(1, y);\n                &#125;\n            &#125;\n            if (p != t.end()) &#123;\n                int y = *p;\n                if (col &lt; a[x])\n                    u1[y].emplace_back(col + 1, a[x]);\n                else if (col &gt; y) &#123;\n                    u1[y].emplace_back(1, a[x]);\n                    u2[col].emplace_back(1, a[x]);\n                &#125;\n            &#125;\n        &#125;\n        for (auto i : g[x])\n            DFS2(col, i, t);\n        return;\n    &#125;;\n    std::function&lt;void(int, std::set&lt;int&gt; &amp;)&gt; DFS1 = [&amp;](int x, std::set&lt;int&gt; &amp;t) &#123;\n        if (son[x])\n            DFS1(son[x], t);\n        for (auto i : g[x])\n            if (i != son[x]) &#123;\n                std::set&lt;int&gt; nt;\n                DFS1(i, nt);\n            &#125;\n        t.insert(a[x]);\n        for (auto i : g[x])\n            if (i != son[x])\n                DFS2(a[x], i, t), DFS2(-1, i, t);\n        return;\n    &#125;;\n    &#123;\n        std::set&lt;int&gt; t;\n        DFS1(1, t);\n    &#125;\n    std::vector&lt;long long&gt; res(m + 1);\n    std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; t(n + 1);\n    for (int i = 1, l, r; i &lt;= m; ++i) &#123;\n        std::cin &gt;&gt; l &gt;&gt; r;\n        t[r].emplace_back(l, i);\n    &#125;\n    bld(1, 1, n);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        for (auto [l, r] : u1[i])\n            add(1, l, r, 1);\n        for (auto [l, r] : u2[i])\n            add(1, l, r, -1);\n        upd(1, 1, i);\n        for (auto [l, id] : t[i])\n            res[id] = ask(1, l, i);\n    &#125;\n    for (int i = 1; i &lt;= m; ++i)\n        std::cout &lt;&lt; res[i] &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h4 id=\"prof.-pangs-sequence-test_90\">Prof. Pang’s sequence / TEST_90</h4>\n<p><a href=\"https://www.luogu.com.cn/problem/P10822\" class=\"uri\">https://www.luogu.com.cn/problem/P10822</a> / <a href=\"https://www.luogu.com.cn/problem/P9990\" class=\"uri\">https://www.luogu.com.cn/problem/P9990</a></p>\n<ul>\n<li>离线扫描线，对于当前右端点 <span class=\"math inline\">\\(r\\)</span>，记录每种数最后一次出现的位置 <span class=\"math inline\">\\(pos\\)</span>。令 <span class=\"math inline\">\\(r\\)</span> 的颜色为 <code>1</code>，从右到左，每碰到一个新的 <span class=\"math inline\">\\(pos\\)</span> 就切换颜色。</li>\n<li>显然对于当前 <span class=\"math inline\">\\(r\\)</span>，应该被加一的 <span class=\"math inline\">\\(l\\)</span> 就是颜色为 <code>1</code> 的这些位置。</li>\n<li>考虑更快地维护这个过程，也就是在 <span class=\"math inline\">\\(r\\)</span> 的颜色和 <span class=\"math inline\">\\(r-1\\)</span> 不同时就可以对 <span class=\"math inline\">\\([1,r)\\)</span> 做一次 flip，是可行的</li>\n<li>在每个 <span class=\"math inline\">\\(r\\)</span> 处查询 <span class=\"math inline\">\\([l,r]\\)</span> 的区间和即可。</li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 5e5 + 5;\nstruct &#123;\n    long long s;\n    int l, r, d0, d1, df, ds, u0, u1;\n&#125; t[maxn &lt;&lt; 2];\n#define lt (p &lt;&lt; 1)\n#define rt (lt | 1)\nvoid pushup(int p) &#123;\n    t[p].u0 = t[lt].u0 + t[rt].u0;\n    t[p].u1 = t[lt].u1 + t[rt].u1;\n    return;\n&#125;\nvoid pushval(int p, long long v0, long long v1, bool f) &#123;\n    if (f) &#123;\n        t[p].df ^= 1;\n        std::swap(t[p].u0, t[p].u1);\n        std::swap(t[p].d0, t[p].d1);\n    &#125;\n    t[p].d0 += v0, t[p].d1 += v1;\n    t[p].s += t[p].u0 * v0 + t[p].u1 * v1;\n    return;\n&#125;\nvoid pushdown(int p) &#123;\n    pushval(lt, t[p].d0, t[p].d1, t[p].df);\n    pushval(rt, t[p].d0, t[p].d1, t[p].df);\n    t[p].d0 = t[p].d1 = t[p].df = 0;\n    return;\n&#125;\nvoid bld(int p, int l, int r) &#123;\n    t[p].l = l, t[p].r = r;\n    t[p].u0 = r - l + 1;\n    if (l == r)\n        return;\n    int mid = (l + r) &gt;&gt; 1;\n    bld(lt, l, mid), bld(rt, mid + 1, r);\n    return;\n&#125;\nvoid flip(int p, int l, int r) &#123;\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r) &#123;\n        pushval(p, 0, 0, 1);\n        return;\n    &#125;\n    pushdown(p);\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (l &lt;= mid)\n        flip(lt, l, r);\n    if (r &gt; mid)\n        flip(rt, l, r);\n    pushup(p);\n    return;\n&#125;\nlong long ask(int p, int l, int r) &#123;\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r)\n        return t[p].s;\n    pushdown(p);\n    auto res(0ll);\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (l &lt;= mid)\n        res = ask(lt, l, r);\n    if (r &gt; mid)\n        res += ask(rt, l, r);\n    return res;\n&#125;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;int&gt; a(n + 1), la(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i];\n    int m;\n    std::cin &gt;&gt; m;\n    std::vector&lt;long long&gt; res(m + 1);\n    std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; u(n + 1);\n    for (int i = 1, l, r; i &lt;= m; ++i) &#123;\n        std::cin &gt;&gt; l &gt;&gt; r;\n        u[r].emplace_back(l, i);\n    &#125;\n    bld(1, 1, n);\n    for (int r = 1; r &lt;= n; ++r) &#123;\n        flip(1, la[a[r]] + 1, r);\n        pushval(1, 0, 1, 0);\n        for (auto [l, id] : u[r])\n            res[id] = ask(1, l, r);\n        la[a[r]] = r;\n    &#125;\n    for (int i = 1; i &lt;= m; ++i)\n        std::cout &lt;&lt; res[i] &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h4 id=\"比赛\"># 比赛</h4>\n<p><a href=\"https://www.luogu.com.cn/problem/P8868\" class=\"uri\">https://www.luogu.com.cn/problem/P8868</a></p>\n<hr />\n<h4 id=\"v\"># V</h4>\n<p><a href=\"https://uoj.ac/problem/164\" class=\"uri\">https://uoj.ac/problem/164</a></p>\n<hr />\n<h4 id=\"cartesian-tree\"># Cartesian Tree</h4>\n<p><a href=\"https://www.luogu.com.cn/problem/CF1290E\" class=\"uri\">https://www.luogu.com.cn/problem/CF1290E</a></p>\n<hr />\n<h4 id=\"rprmq1\"># rprmq1</h4>\n<p><a href=\"https://www.luogu.com.cn/problem/P6109\" class=\"uri\">https://www.luogu.com.cn/problem/P6109</a></p>\n<hr />\n<h4 id=\"rpfrdtzls\"># rpfrdtzls</h4>\n<p><a href=\"https://www.luogu.com.cn/problem/P9057\" class=\"uri\">https://www.luogu.com.cn/problem/P9057</a></p>\n<hr />\n<h3 id=\"线段树合并\">线段树合并</h3>\n<p>树上的线段树合并都很熟悉了，利用了线段树合并是线性的，以及 dsu on tree</p>\n<p>不如说绝大多数线段树合并都有树上背景，因为自带合并顺序和复杂度保证</p>\n<p>Tip：树上合并的背景下，线段树合并的表现会比主席树优秀很多，因为前者跑不满</p>\n<p>不在树上的问题，题目可能会通过各种方式保证复杂度，比如保证每个点只会被合并一次之类</p>\n<hr />\n<h4 id=\"迁移计划-migration-plan\"># 迁移计划 / Migration Plan</h4>\n<p><a href=\"https://www.luogu.com.cn/problem/P11993\" class=\"uri\">https://www.luogu.com.cn/problem/P11993</a></p>\n<hr />\n<h4 id=\"永无乡\"># 永无乡</h4>\n<p><a href=\"https://www.luogu.com.cn/problem/P3224\" class=\"uri\">https://www.luogu.com.cn/problem/P3224</a></p>\n<hr />\n<h4 id=\"语言\"># 语言</h4>\n<p><a href=\"https://www.luogu.com.cn/problem/P5327\" class=\"uri\">https://www.luogu.com.cn/problem/P5327</a></p>\n<hr />\n<h4 id=\"梦幻布丁\"># 梦幻布丁</h4>\n<p><a href=\"https://www.luogu.com.cn/problem/P3201\" class=\"uri\">https://www.luogu.com.cn/problem/P3201</a></p>\n<hr />\n<p>还有两个比较屎的 P7563 和 P7963</p>\n<h3 id=\"扫描线\">扫描线</h3>\n<p>离线，按照下标排序，扫一遍处理询问，就可以利用『所有更靠前的下标都以被计算过』来处理问题</p>\n<p>不只局限于区间询问，单点的可能反而更难一点，需要发现和下标大小有关的性质</p>\n<h4 id=\"等差子序列\">等差子序列</h4>\n<p><a href=\"https://www.luogu.com.cn/problem/P2757\" class=\"uri\">https://www.luogu.com.cn/problem/P2757</a></p>\n<blockquote>\n<p>给定一个 <span class=\"math inline\">\\(n\\)</span> 的排列，问是否能找到 <span class=\"math inline\">\\(len\\ge 3\\)</span> 的子序列，使得其是等差的。</p>\n<p><span class=\"math inline\">\\(n\\le 5\\times 10^5\\)</span>。</p>\n</blockquote>\n<p>根据单调性，可以简化为 <span class=\"math inline\">\\(len=3\\)</span> 时的答案</p>\n<p>也就是对于中项 <span class=\"math inline\">\\(j\\)</span>，能不能找到 <span class=\"math inline\">\\(i&lt;j&lt;k\\)</span>，使得 <span class=\"math inline\">\\(a_j-a_i=a_k-a_j\\)</span>。从下标出发，差值是不好维护的；注意到是排列，可以从值出发，转化成是否存在一个 <span class=\"math inline\">\\(d\\)</span>，使得 <span class=\"math inline\">\\(a_j-d\\)</span> 在之前出现，<span class=\"math inline\">\\(a_j+d\\)</span> 在之后出现。</p>\n<p>利用下标『之前』和『之后』的限制，做扫描线，查看是否存在 <span class=\"math inline\">\\(d\\)</span> 使 <span class=\"math inline\">\\(a_j-d\\)</span> 出现过但是 <span class=\"math inline\">\\(a_j+d\\)</span> 没有出现过；还是因为是排列，数量只会为 <span class=\"math inline\">\\(0\\)</span> 或 <span class=\"math inline\">\\(1\\)</span>，如果非法说明 <span class=\"math inline\">\\(a_j-d\\)</span> 和 <span class=\"math inline\">\\(a_j+d\\)</span> 都是 <span class=\"math inline\">\\(0\\)</span> 或者都是 <span class=\"math inline\">\\(1\\)</span>，发现是关于 <span class=\"math inline\">\\(a_j\\)</span> 的回文，故权值线段树维护哈希，如果 <span class=\"math inline\">\\(a_j\\)</span> 两侧全部回文，说明 <span class=\"math inline\">\\(j\\)</span> 不是合法中项。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nnamespace fastIO &#123;\nconst int LEN = (1 &lt;&lt; 20);\n#ifdef ONLINE_JUDGE\ninline int nec(void) &#123;\n    static char buf[LEN], *p = buf, *e = buf;\n    if (p == e) &#123;\n        e = buf + fread(buf, 1, LEN, stdin);\n        if (e == buf)\n            return EOF;\n        p = buf;\n    &#125;\n    return *p++;\n&#125;\n#else\n#define nec getchar\n#endif\ninline bool read(int &amp;x) &#123;\n    x = 0;\n    bool f = 0;\n    char ch = nec();\n    while (ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123;\n        if (ch == EOF)\n            return 0;\n        if (ch == &#39;-&#39;)\n            f = 1;\n        ch = nec();\n    &#125;\n    while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) &#123;\n        x = x * 10 + ch - &#39;0&#39;;\n        ch = nec();\n    &#125;\n    if (f)\n        x = -x;\n    return 1;\n&#125;\nvoid print(int x) &#123;\n    if (x &lt; 0) &#123;\n        putchar(&#39;-&#39;);\n        x = -x;\n    &#125;\n    if (x &gt;= 10)\n        print(x / 10);\n    putchar(x % 10 + &#39;0&#39;);\n    return;\n&#125;\nvoid print(int x, char ch) &#123;\n    print(x);\n    putchar(ch);\n    return;\n&#125;\n&#125; // namespace fastIO\nnamespace XSC062 &#123;\nusing namespace fastIO;\n#define lt (p &lt;&lt; 1)\n#define rt (lt | 1)\nusing sc = unsigned long long;\nconst int p = 13331; // 0103 ¿É°®µÎÄó \nconst int lim = 5e5;\nconst int maxn = 5e5 + 5;\nstruct _ &#123;\n    int l, r;\n    sc lh, rh;\n&#125;;\nint T, n;\nint a[maxn];\nsc base[maxn];\n_ t[maxn &lt;&lt; 2];\nint min(int x, int y) &#123;\n    return x &lt; y ? x : y;\n&#125;\nint max(int x, int y) &#123;\n    return x &gt; y ? x : y;\n&#125;\nvoid pushup(int p) &#123;\n    int ll = t[lt].r - t[lt].l + 1;\n    int rl = t[rt].r - t[rt].l + 1;\n    t[p].lh = t[lt].lh * base[rl] + t[rt].lh;\n    t[p].rh = t[rt].rh * base[ll] + t[lt].rh;\n    return;\n&#125;\nvoid bld(int p, int l, int r) &#123;\n    t[p].lh = t[p].rh = 0;\n    t[p].l = l, t[p].r = r;\n    if (l == r)\n        return;\n    int mid = (l + r) &gt;&gt; 1;\n    bld(lt, l, mid);\n    bld(rt, mid + 1, r);\n    return;\n&#125;\nvoid upd(int p, int x, int v) &#123;\n    if (t[p].l == t[p].r) &#123;\n        t[p].lh = t[p].rh = v;\n        return;\n    &#125;\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (x &lt;= mid)\n        upd(lt, x, v);\n    else upd(rt, x, v);\n    pushup(p);\n    return;\n&#125;\nsc qryl(int p, int l, int r) &#123;\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r)\n        return t[p].lh;\n    sc ans = 0;\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (l &lt;= mid)\n        ans = qryl(lt, l, r);\n    if (r &gt; mid) &#123;\n        ans *= base[min(r, t[p].r) - mid];\n        ans += qryl(rt, l, r);\n    &#125;\n    return ans;\n&#125;\nsc qryr(int p, int l, int r) &#123;\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r)\n        return t[p].rh;\n    sc ans = 0;\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (r &gt; mid)\n        ans = qryr(rt, l, r);\n    if (l &lt;= mid) &#123;\n        ans *= base[mid - max(l, t[p].l) + 1];\n        ans += qryr(lt, l, r);\n    &#125;\n    return ans;\n&#125;\nint main() &#123;\n    read(T);\n    base[0] = 1;\n    for (int i = 1; i &lt;= lim; ++i)\n        base[i] = base[i - 1] * p;\n    while (T--) &#123;\n        read(n);\n        bld(1, 1, n);\n        for (int i = 1; i &lt;= n; ++i)\n            read(a[i]);\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            int len = min(n - a[i], a[i] - 1);\n            if (i &gt; 1) &#123;\n                upd(1, a[i - 1], 1);\n            &#125;\n            if (len == 0)\n                continue;\n            int l = a[i] - len;\n            int r = a[i] + len;\n            if (qryl(1, l, a[i] - 1) !=\n                qryr(1, a[i] + 1, r)) &#123;\n                puts(&quot;Y&quot;);\n                goto isSol;\n            &#125;\n        &#125;\n        puts(&quot;N&quot;);\n        isSol: ;\n    &#125;\n    return 0;\n&#125;\n&#125; // namespace XSC062\nint main() &#123;\n    XSC062::main();\n    return 0;\n&#125;</code></pre>\n</details>\n<h4 id=\"小奇的糖果\">小奇的糖果</h4>\n<p><a href=\"https://hydro.ac/p/bzoj-P4548\" class=\"uri\">https://hydro.ac/p/bzoj-P4548</a></p>\n<blockquote>\n<p>有 <span class=\"math inline\">\\(N\\)</span> 个有颜色（<span class=\"math inline\">\\(M\\)</span> 种）的点在平面上，在平面上取一条水平的线段，可以选择线段上方的所有点，也可以选择下方的所有点。找出一条线段和选取的方向，使得在选取的点不包含所有颜色的前提下，最大化选到点的数量。</p>\n<p><span class=\"math inline\">\\(N,M\\le 10^6,|x|,|y|\\le 10^9\\)</span>。</p>\n</blockquote>\n<p>先离散化 + 按 <span class=\"math inline\">\\(y\\)</span> 排序降一维，贪心地枚举某种颜色 <span class=\"math inline\">\\(c\\)</span> 不选。考虑线段在平面最底部时的答案，取出所有颜色为 <span class=\"math inline\">\\(c\\)</span> 的点的 <span class=\"math inline\">\\(x\\)</span> 坐标，只能选择相邻的 <span class=\"math inline\">\\(x\\)</span> 之间的所有点。枚举每一对相邻的点计算答案。把线段上移，如果碰到了一个颜色为 <span class=\"math inline\">\\(c\\)</span> 的点，就说明这个点不再参与限制，删去即可，该点原前驱和后继围出来的区间就能够更新答案。用链表 / 单调栈就能很快地维护。</p>\n<p>先枚举颜色再跑扫描线是 <span class=\"math inline\">\\(O(n^2\\log n)\\)</span> 的，考虑优化。注意到数据结构里存在当前颜色没有影响，因为一定不在询问区间内。整体做扫描线，复杂度 <span class=\"math inline\">\\(O(n\\log n)\\)</span>。</p>\n<details>\n<pre class=\"cpp\"><code>namespace XSC062 &#123;\nusing namespace fastIO;\nconst int maxn = 2e5 + 5;\nstruct _ &#123;\n    int x, y, c;\n    bool operator&lt; (const _ &amp;q) const &#123;\n        return y &lt; q.y;\n    &#125;\n&#125;;\n_ a[maxn];\nint s[maxn], t[maxn];\nint ls[maxn], rs[maxn];\nint cp[maxn], cn[maxn];\nint pre[maxn], nex[maxn];\nstd::vector&lt;int&gt; g[maxn];\nint div[maxn], Bit[maxn];\nint T, n, k, tot, cnt, now, res;\nint max(int x, int y) &#123; return x &gt; y ? x : y; &#125;\nint lowbit(int x) &#123; return x &amp; -x; &#125;\nvoid add(int x, int v) &#123;\n    for (; x &lt;= n; x += lowbit(x)) Bit[x] += v;\n    return;\n&#125;\nint ask(int x) &#123;\n    int res = 0;\n    for (; x; x -= lowbit(x)) res += Bit[x];\n    return res;\n&#125;\nint ask(int l, int r) &#123;\n    if (l &gt; r) return 0;\n    return ask(r) - ask(l - 1);\n&#125;\nint main() &#123;\n//  freopen(&quot;1.in&quot;, &quot;r&quot;, stdin); \n    read(T);\n    while (T--) &#123;\n        read(n), read(k), now = res = 0;\n        for (int i = 1; i &lt;= k; ++i) &#123;\n            s[i] = ++now, t[i] = ++now;\n            div[s[i]] = 0, div[t[i]] = n + 1;\n            nex[s[i]] = t[i], pre[t[i]] = s[i];\n            pre[s[i]] = nex[t[i]] = 0;\n        &#125;\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            read(a[i].x), read(a[i].y), read(a[i].c);\n            ls[i] = a[i].x, rs[i] = a[i].y;\n        &#125;\n        std::sort(a + 1, a + n + 1, [&amp;](_ x, _ y) &#123; return x.x &lt; y.x; &#125;);\n        std::sort(ls + 1, ls + n + 1);\n        std::sort(rs + 1, rs + n + 1);\n        tot = std::unique(ls + 1, ls + n + 1) - ls - 1;\n        cnt = std::unique(rs + 1, rs + n + 1) - rs - 1;\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            a[i].x = std::lower_bound(ls + 1, ls + tot + 1, a[i].x) - ls;\n            a[i].y = std::lower_bound(rs + 1, rs + cnt + 1, a[i].y) - rs;\n        &#125;\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            div[++now] = a[i].x;\n            add(a[i].x, 1), g[a[i].y].push_back(now);\n            pre[now] = pre[t[a[i].c]], nex[pre[t[a[i].c]]] = now;\n            pre[t[a[i].c]] = now, nex[now] = t[a[i].c];\n        &#125;\n        memcpy(cp, pre, sizeof (cp));\n        memcpy(cn, nex, sizeof (cn));\n        for (int i = 1; i &lt;= k; ++i) &#123;\n            for (int j = s[i]; j != t[i]; j = nex[j])\n                res = max(res, ask(div[j] + 1, div[nex[j]] - 1));\n        &#125;\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            for (auto j : g[i]) add(div[j], -1);\n            for (auto j : g[i]) &#123;\n                res = max(res, ask(div[pre[j]] + 1, div[nex[j]] - 1));\n                nex[pre[j]] = nex[j], pre[nex[j]] = pre[j];\n            &#125;\n        &#125;\n        for (int i = 1; i &lt;= n; ++i) add(a[i].x, 1);\n        for (int i = n; i; --i) &#123;\n            for (auto j : g[i]) add(div[j], -1);\n            for (auto j : g[i]) &#123;\n                res = max(res, ask(div[cp[j]] + 1, div[cn[j]] - 1));\n                cn[cp[j]] = cn[j], cp[cn[j]] = cp[j];\n            &#125;\n        &#125;\n        print(res, &#39;\\n&#39;);\n        for (int i = 1; i &lt;= n; ++i)\n            g[i].clear(), g[i].shrink_to_fit();\n    &#125;\n    return 0;\n&#125;\n&#125; // namespace XSC062</code></pre>\n</details>\n<hr />\n<h4 id=\"rmscne\">rmscne</h4>\n<p><a href=\"https://www.luogu.com.cn/problem/P7907\" class=\"uri\">https://www.luogu.com.cn/problem/P7907</a></p>\n<blockquote>\n<p>给定长为 <span class=\"math inline\">\\(n\\)</span> 的序列，<span class=\"math inline\">\\(q\\)</span> 次询问 <span class=\"math inline\">\\([l,r]\\)</span> 中的最短子区间 <span class=\"math inline\">\\([l&#39;,r&#39;]\\)</span>，使得其包含 <span class=\"math inline\">\\([l,r]\\)</span> 中出现的全部值。输出长度即可。</p>\n<p><span class=\"math inline\">\\(n,q,V\\le 2\\times 10^6\\)</span>。</p>\n</blockquote>\n<p>区间里面找子区间也是扫描线经典问题。</p>\n<p>区间种类数会有几种思路：集合哈希、前驱后继、莫队之类。PS：这个题用 ODT 可以拿到最优解</p>\n<p>对于 <span class=\"math inline\">\\(i=1\\sim n\\)</span>，依次考虑 <span class=\"math inline\">\\(i\\)</span> 作为右端点的情况。线段树维护每个 <span class=\"math inline\">\\(j\\)</span> 作为左端点时的 <span class=\"math inline\">\\(i-r_j\\)</span>，其中 <span class=\"math inline\">\\([j, r_j]\\)</span> 是与 <span class=\"math inline\">\\([j,i]\\)</span> 种类相同的最小区间。</p>\n<p>询问的时候，只需要找到最大的 <span class=\"math inline\">\\(j&#39;\\)</span>，满足 <span class=\"math inline\">\\([j, r]\\)</span> 与 <span class=\"math inline\">\\([l, r]\\)</span> 种类相同，求 <span class=\"math inline\">\\([l, j&#39;]\\)</span> 的区间和即可。找 <span class=\"math inline\">\\(j&#39;\\)</span> 可以记录前驱后继，初始每个 <span class=\"math inline\">\\(l\\)</span> 对应的 <span class=\"math inline\">\\(j&#39;\\)</span> 就是自己。若加入了一个与 <span class=\"math inline\">\\(l\\)</span> 相同的新元素，那么 <span class=\"math inline\">\\(l\\)</span> 就不再有贡献，此时 <span class=\"math inline\">\\(l\\)</span> 的 <span class=\"math inline\">\\(j&#39;\\)</span> 就会继承 <span class=\"math inline\">\\(l+1\\)</span> 的 <span class=\"math inline\">\\(j&#39;\\)</span>，这个过程用并查集即可简单维护。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int lim = 2e6;\nconst int maxn = 2e6 + 5;\nconst int maxm = 5e7 + 5;\nconst int inf = 0x3f3f3f3f;\nstruct &#123; int l, r, u, d; &#125; t[maxn &lt;&lt; 2];\nint tot;\n#define lt (p &lt;&lt; 1)\n#define rt (lt | 1)\nvoid pushdown(int p) &#123;\n    if (~t[p].d) &#123;\n        t[lt].d = t[rt].d = t[p].d;\n        t[lt].u = t[p].d - t[lt].r + 1;\n        t[rt].u = t[p].d - t[rt].r + 1;\n        t[p].d = -1;\n    &#125;\n    return;\n&#125;\nvoid bld(int p, int l, int r) &#123;\n    t[p].l = l, t[p].r = r, t[p].d = -1;\n    if (l == r)\n        return;\n    int mid = (l + r) &gt;&gt; 1;\n    bld(lt, l, mid), bld(rt, mid + 1, r);\n    return;\n&#125;\nvoid upd(int p, int l, int r, int v) &#123;\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r) &#123;\n        t[p].d = v, t[p].u = v - t[p].r + 1;\n        return;\n    &#125;\n    pushdown(p);\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (l &lt;= mid)\n        upd(lt, l, r, v);\n    if (r &gt; mid)\n        upd(rt, l, r, v);\n    t[p].u = std::min(t[lt].u, t[rt].u);\n    return;\n&#125;\nint ask(int p, int l, int r) &#123;\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r)\n        return t[p].u;\n    pushdown(p);\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1, res = inf;\n    if (l &lt;= mid)\n        res = ask(lt, l, r);\n    if (r &gt; mid)\n        res = std::min(res, ask(rt, l, r));\n    return res;\n&#125;\n#undef lt\n#undef rt\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, q;\n    std::cin &gt;&gt; n;\n    std::vector&lt;int&gt; a(n + 1), la(lim + 1), pre(n + 1), f(n + 1);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; a[i];\n        pre[i] = la[a[i]], la[a[i]] = i, f[i] = i;\n    &#125;\n    std::cin &gt;&gt; q;\n    std::vector&lt;int&gt; res(q + 1);\n    std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; t(n + 1);\n    for (int i = 1, l, r; i &lt;= q; ++i) &#123;\n        std::cin &gt;&gt; l &gt;&gt; r;\n        t[r].emplace_back(l, i);\n    &#125;\n    bld(1, 1, n);\n    std::function&lt;int(int)&gt; find = [&amp;](int x) &#123;\n        return x == f[x] ? x : f[x] = find(f[x]);\n    &#125;;\n    auto merge = [&amp;](int x, int y) &#123;\n        x = find(x), y = find(y);\n        f[std::min(x, y)] = std::max(x, y);\n        return;\n    &#125;;\n    for (int r = 1; r &lt;= n; ++r) &#123;\n        if (pre[r])\n            merge(pre[r], pre[r] + 1);\n        upd(1, pre[r] + 1, r, r);\n        for (auto [l, i] : t[r])\n            res[i] = ask(1, l, find(l));\n    &#125;\n    for (int i = 1; i &lt;= q; ++i)\n        std::cout &lt;&lt; res[i] &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h4 id=\"颜色\"># 颜色</h4>\n<p><a href=\"https://www.luogu.com.cn/problem/P4065\" class=\"uri\">https://www.luogu.com.cn/problem/P4065</a></p>\n<blockquote>\n<p>给定 <span class=\"math inline\">\\(n\\)</span> 个元素，每个元素有一个颜色。选择若干颜色（不能全选或全不选），问有多少种选取方案使得拥有这些颜色的点是一段连续的区间。</p>\n<p><span class=\"math inline\">\\(n\\le 3\\times 10^5\\)</span>。</p>\n</blockquote>\n<hr />\n<h3 id=\"势能线段树\">势能线段树</h3>\n<h4 id=\"市场\"># 市场</h4>\n<p><a href=\"https://loj.ac/p/6029\" class=\"uri\">https://loj.ac/p/6029</a></p>\n<hr />\n<h4 id=\"segment-tree-beats\"># Segment Tree Beats!</h4>\n<blockquote>\n<p>维护区间取 min，区间求和。</p>\n</blockquote>\n<p>pdf P57</p>\n<hr />\n<h4 id=\"segment-tree-beats-plus\"># Segment Tree Beats! Plus</h4>\n<blockquote>\n<p>维护区间加，区间取 min，区间求和。</p>\n</blockquote>\n<p>pdf P60</p>\n<hr />\n<h4 id=\"最假女选手\"># 最假女选手</h4>\n<p><a href=\"https://loj.ac/p/6565\" class=\"uri\">https://loj.ac/p/6565</a></p>\n<hr />\n<h4 id=\"mzl-loves-segment-tree\"># Mzl loves segment tree</h4>\n<p><a href=\"http://222.180.160.110:61235/problem/10203\" class=\"uri\">http://222.180.160.110:61235/problem/10203</a></p>\n<p>pdf P66</p>\n<hr />\n<h4 id=\"ctsn-loves-segment-tree\"># CTSN loves segment tree</h4>\n<p><a href=\"https://www.luogu.com.cn/problem/U180387\" class=\"uri\">https://www.luogu.com.cn/problem/U180387</a></p>\n<hr />\n<h4 id=\"前进四segment-tree-beats-ver\"># 前进四（segment tree beats ver）</h4>\n<p><a href=\"https://uoj.ac/problem/515\" class=\"uri\">https://uoj.ac/problem/515</a></p>\n<p>另见 <a href=\"#-前进四楼房重建-ver\">楼房重建 ver</a></p>\n<hr />\n<h4 id=\"基础数据结构练习题\"># 基础数据结构练习题</h4>\n<p><a href=\"https://uoj.ac/problem/228\" class=\"uri\">https://uoj.ac/problem/228</a></p>\n<hr />\n<h4 id=\"线段树-3\"># 线段树 3</h4>\n<p><a href=\"https://www.luogu.com.cn/problem/P6242\" class=\"uri\">https://www.luogu.com.cn/problem/P6242</a></p>\n<hr />\n<h4 id=\"赛格蒙特彼茨\"># 赛格蒙特彼茨</h4>\n<p>pdf P70</p>\n<hr />\n<h4 id=\"堕天作战-test_98\"># 堕天作战 TEST_98</h4>\n<p><a href=\"https://www.luogu.com.cn/problem/P9069\" class=\"uri\">https://www.luogu.com.cn/problem/P9069</a></p>\n<hr />\n<h3 id=\"线段树分治\">线段树分治</h3>\n<h4 id=\"meetings-会议\"># meetings 会议</h4>\n<p><a href=\"https://www.luogu.com.cn/problem/P5044\" class=\"uri\">https://www.luogu.com.cn/problem/P5044</a></p>\n<h4 id=\"八纵八横\"># 八纵八横</h4>\n<p><a href=\"https://www.luogu.com.cn/problem/P3733\" class=\"uri\">https://www.luogu.com.cn/problem/P3733</a></p>\n<h2 id=\"笛卡尔树\">笛卡尔树</h2>\n<p>一些思考方式和 trick 吧</p>\n<h3 id=\"由乃救爷爷\">* 由乃救爷爷</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P3793\" class=\"uri\">https://www.luogu.com.cn/problem/P3793</a></p>\n<blockquote>\n<p>尽可能快地维护随机序列区间最值。</p>\n</blockquote>\n<p>随机序列笛卡尔树期望深度是 <span class=\"math inline\">\\(\\log\\)</span>。就可以做了。</p>\n<p>来自 <a href=\"https://www.luogu.com/article/hj9ci08q\">UnyieldingTrilobite 的文章</a>：同样可以用悬线！<a href=\"/20231117/#随机序列悬线结合分块\">悬线 + 分块</a> 就可以做了。</p>\n<hr />\n<h3 id=\"情景剧最值的性质维护方式的取舍\">* 情景剧（最值的性质，维护方式的取舍）</h3>\n<p><a href=\"http://222.180.160.110:61235/contest/4273/problem/1\" class=\"uri\">http://222.180.160.110:61235/contest/4273/problem/1</a></p>\n<blockquote>\n<p>给定长度为 <span class=\"math inline\">\\(n\\)</span> 的序列 <span class=\"math inline\">\\(a_{1\\sim n}\\)</span>，找到一个区间，使得 区间长度 <span class=\"math inline\">\\(\\times\\)</span> 区间最大值 <span class=\"math inline\">\\(\\times\\)</span> 区间最小值 最大。输出最大值。</p>\n<p><span class=\"math inline\">\\(n\\le 10^6,V\\le 10^9\\)</span>。</p>\n</blockquote>\n<ul>\n<li>容易想到建笛卡尔树。这里的 最大值 和 最小值 地位相等吗？为什么？</li>\n<li>如果我们是钦定最大值，再去最大化『最小值 <span class=\"math inline\">\\(\\times\\)</span> 区间长』，好像没办法做，因为这个最大贡献没什么性质</li>\n<li><p>但如果钦定最小值，能取到的最长区间就是在小根笛卡尔树上的管辖区间，显然区间越长取到的最大值也越大，直接取这里的最大值即可</p>\n所以最大值和最小值地位不等是因为，区间长和最大值大小是正相关的，所以只需要最大化区间长，最大值也就最大化了</li>\n<li><p>所以在小根笛卡尔树上维护区间最大值即可</p></li>\n</ul>\n<hr />\n<h3 id=\"小蓝的好友\"># 小蓝的好友</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P2611\" class=\"uri\">https://www.luogu.com.cn/problem/P2611</a></p>\n<hr />\n<h3 id=\"星白-by-ttpandas笛卡尔树-dsu-on-tree\">星白 by TTpandaS（笛卡尔树 + dsu on tree）</h3>\n<p><a href=\"http://222.180.160.110:61235/contest/6517/problem/3\" class=\"uri\">http://222.180.160.110:61235/contest/6517/problem/3</a></p>\n<blockquote>\n<p>给定 <span class=\"math inline\">\\(n\\)</span> 的排列 <span class=\"math inline\">\\(a_{1\\sim n}\\)</span>，回答 <span class=\"math inline\">\\(q\\)</span> 个询问：</p>\n<ul>\n<li><p>给定 <span class=\"math inline\">\\([l,r]\\)</span>，是否存在 <span class=\"math inline\">\\(l\\le x&lt;y\\le r\\)</span>，使得：</p>\n<ul>\n<li><span class=\"math inline\">\\(a_x&lt;a_y\\)</span>，且 <span class=\"math inline\">\\(a_x\\)</span> 不为 <span class=\"math inline\">\\([x,y]\\)</span> 中最小值；</li>\n<li>令 <span class=\"math inline\">\\(a_i\\)</span> 为 <span class=\"math inline\">\\([x, y]\\)</span> 中最小值，则 <span class=\"math inline\">\\(a_i\\mid (a_x\\cdot a_y)\\)</span>。</li>\n</ul></li>\n</ul>\n<p><span class=\"math inline\">\\(n\\le 3\\times 10^5,q\\le10^6\\)</span>。</p>\n</blockquote>\n<ul>\n<li>容易想到对于 <span class=\"math inline\">\\(i\\)</span> 反过来找 <span class=\"math inline\">\\([x,y]\\)</span>。如果建立小根笛卡尔树，在 <span class=\"math inline\">\\(i\\)</span> 的左边找 <span class=\"math inline\">\\(x\\)</span>、右边找 <span class=\"math inline\">\\(y\\)</span>。</li>\n<li><p>一个自然的想法是对于左侧的每个 <span class=\"math inline\">\\(x\\)</span>，维护最近的合法 <span class=\"math inline\">\\(y\\)</span>；或是对于右侧的每个 <span class=\"math inline\">\\(y\\)</span>，维护最近的合法 <span class=\"math inline\">\\(x\\)</span>。</p>\n做一个 DSU on Tree，哪边区间短就维护哪边，是单 <span class=\"math inline\">\\(\\log\\)</span> 的。</li>\n<li><p>需要解决点内预处理，以 <span class=\"math inline\">\\(x\\)</span> 为例，对于每个 <span class=\"math inline\">\\(x\\)</span> 和当前点 <span class=\"math inline\">\\((p,l,r)\\)</span>，需要查询 <span class=\"math inline\">\\((p, r]\\)</span> 中最小的 <span class=\"math inline\">\\(y\\)</span>，使得 <span class=\"math inline\">\\(a_y\\)</span> 是 <span class=\"math inline\">\\(\\dfrac {a_p}{\\gcd(a_x,a_p)}\\)</span> 的倍数。离线下来扫描线，<del>开 <span class=\"math inline\">\\(n\\)</span> 棵线段树</del>，跑 <span class=\"math inline\">\\(n\\)</span> 次树状数组，用 <span class=\"math inline\">\\(y\\)</span> 更新所有 <span class=\"math inline\">\\(a_y\\)</span> 因数在 <span class=\"math inline\">\\(a_y\\)</span> 处的 min / max，可以在两个 log 内获得支配对类似物。</p>\n不是很理解为什么题目要再加一个偏序限制，除了增加代码量和用时外似乎并没有什么作用？</li>\n<li><p>查询时直接 rmq（这里唐了写了 st 表，实际上只需要前后缀）即可。整体复杂度 <span class=\"math inline\">\\(O(n\\log^2 n)\\)</span>。</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int LEN = (1 &lt;&lt; 20);\n#ifdef ONLINE_JUDGE\nint nec(void) &#123;\n    static char buf[LEN], *p = buf, *e = buf;\n    if (p == e) &#123;\n        e = buf + fread(buf, 1, LEN, stdin);\n        if (e == buf) return EOF;\n        p = buf;\n    &#125;\n    return *p++;\n&#125;\n#else\n#define nec getchar\n#endif\nbool read(int &amp;x) &#123;\n    x = 0;\n    bool f = 0;\n    char ch = nec();\n    while (ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123;\n        if (ch == EOF) return 0;\n        if (ch == &#39;-&#39;) f = 1;\n        ch = nec();\n    &#125;\n    while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) &#123;\n        x = x * 10 + ch - &#39;0&#39;;\n        ch = nec();\n    &#125;\n    if (f) x = -x;\n    return 1;\n&#125;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n;\n    read(n);\n    std::vector&lt;std::vector&lt;int&gt; &gt; mul(n + 1);\n    std::vector&lt;int&gt; a(n + 1), l(n + 1), r(n + 1), pos(n + 1);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        read(a[i]), pos[a[i]] = i;\n        for (l[i] = i; l[i] != 1 &amp;&amp; a[i] &lt; a[l[i] - 1]; l[i] = l[l[i] - 1]);\n    &#125;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        for (int j = i; j &lt;= n; j += i)\n            mul[i].push_back(pos[j]);\n        std::sort(mul[i].begin(), mul[i].end());\n    &#125;\n    for (int i = n; i; --i)\n        for (r[i] = i; r[i] != n &amp;&amp; a[i] &lt; a[r[i] + 1]; r[i] = r[r[i] + 1]);\n    struct query &#123; int id, l, r; &#125;;\n    std::vector&lt;std::vector&lt;query&gt; &gt; ql(n + 1), qr(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        if (i - l[i] &lt; r[i] - i)\n            for (int j = l[i]; j &lt; i; ++j)\n                qr[a[i] / std::__gcd(a[i], a[j])].push_back(&#123; j, i + 1, r[i] &#125;);\n        else\n            for (int j = i + 1; j &lt;= r[i]; ++j)\n                ql[a[i] / std::__gcd(a[i], a[j])].push_back(&#123; j, l[i], i - 1 &#125;);\n    std::vector&lt;int&gt; u(n + 1), rt(n + 1), bit(n + 1);\n    auto lowbit = [](int x) &#123;\n        return x &amp; -x;\n    &#125;;\n    auto add = [&amp;](int x, int v) &#123;\n        for (; x &lt;= n; x += lowbit(x))\n            bit[x] = v;\n        return;\n    &#125;;\n    std::function&lt;int(int)&gt; ask = [&amp;](int x) &#123;\n        int res = 0;\n        for (; x; x -= lowbit(x))\n            res = std::max(res, bit[x]);\n        return res;\n    &#125;;\n    for (int fac = 1; fac &lt;= n; ++fac) &#123;\n        std::sort(ql[fac].begin(), ql[fac].end(), [&amp;](query x, query y) &#123; return x.r &lt; y.r; &#125;);\n        auto i = mul[fac].begin();\n        for (auto [id, l, r] : ql[fac]) &#123;\n            for (; i != mul[fac].end() &amp;&amp; *i &lt;= r; ++i)\n                add(a[*i], *i);\n            auto mx(ask(a[id]));\n            if (mx &gt;= l)\n                u[id] = std::max(u[id], mx);\n        &#125;\n        for (auto i : mul[fac])\n            add(a[i], 0);\n    &#125;\n    bit.assign(n + 1, 0x3f3f3f3f);\n    ask = [&amp;](int x) &#123;\n        int res = 0x3f3f3f3f;\n        for (; x; x -= lowbit(x))\n            res = std::min(res, bit[x]);\n        return res;\n    &#125;;\n    for (int fac = 1; fac &lt;= n; ++fac) &#123;\n        std::sort(qr[fac].begin(), qr[fac].end(), [&amp;](query x, query y) &#123; return x.l &gt; y.l; &#125;);\n        std::reverse(mul[fac].begin(), mul[fac].end());\n        auto i = mul[fac].begin();\n        for (auto [id, l, r] : qr[fac]) &#123;\n            for (; i != mul[fac].end() &amp;&amp; *i &gt;= l; ++i)\n                add(n - a[*i] + 1, *i);\n            auto mn(ask(n - a[id] + 1));\n            if (mn &lt;= r)\n                u[mn] = std::max(u[mn], id);\n        &#125;\n        for (auto i : mul[fac])\n            add(n - a[i] + 1, 0x3f3f3f3f);\n    &#125;\n    std::vector&lt;std::vector&lt;int&gt; &gt; st(20, std::vector&lt;int&gt; (n + 1));\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        // if (u[i] != 0)\n        //     printf(&quot;%d %d\\n&quot;, u[i], i);\n        st[0][i] = u[i];\n    &#125;\n    for (int j = 1; (1 &lt;&lt; j) &lt;= n; ++j)\n        for (int i = 1; i + (1 &lt;&lt; j) - 1 &lt;= n; ++i)\n            st[j][i] = std::max(st[j - 1][i], st[j - 1][i + (1 &lt;&lt; (j - 1))]);\n    auto askmx = [&amp;](int l, int r) &#123;\n        int k = std::__lg(r - l + 1);\n        return std::max(st[k][l], st[k][r - (1 &lt;&lt; k) + 1]);\n    &#125;;\n    int q;\n    read(q);\n    for (int l, r; q--; ) &#123;\n        read(l), read(r);\n        std::cout &lt;&lt; (askmx(l, r) &gt;= l ? &quot;Yes&quot; : &quot;No&quot;) &lt;&lt; &#39;\\n&#39;;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"periodni\"># PERIODNI</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P6453\" class=\"uri\">https://www.luogu.com.cn/problem/P6453</a></p>\n<hr />\n<h2 id=\"cdq-分治\">CDQ 分治</h2>\n<h3 id=\"coloring-nodes偏序很隐秘\"># Coloring Nodes（偏序很隐秘）</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P12423\" class=\"uri\">https://www.luogu.com.cn/problem/P12423</a></p>\n<hr />\n<h2 id=\"字典树\">字典树</h2>\n<p>字典树作为 log 数据结构的时候，等价权值线段树，而且支持合并、分裂（权值线段树 also OK，强调一下而已）</p>\n<p>有些情景 Trie 写起来会比权值线段树舒服一些，比如值域操作、二进制操作之类</p>\n<h3 id=\"异或粽子\"># 异或粽子</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P5283\" class=\"uri\">https://www.luogu.com.cn/problem/P5283</a></p>\n<hr />\n<h3 id=\"friends\"># Friends</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/CF241B\" class=\"uri\">https://www.luogu.com.cn/problem/CF241B</a></p>\n",
            "tags": [
                "线段树"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20250816/",
            "url": "https://xsc062.netlify.app/20250816/",
            "title": "近期杂题 II",
            "date_published": "2025-08-16T08:14:12.000Z",
            "content_html": "<p>和 Aug 9th 的杂题不太能合并，所以分开了</p>\n<span id=\"more\"></span>\n<hr />\n<h2 id=\"b.-gas-fire-extinguishers\">B. GAS-Fire Extinguishers</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P3479\" class=\"uri\">https://www.luogu.com.cn/problem/P3479</a></p>\n<p>显然可以贪心，不妨从下到上，记录当前遍历过的、空余出来的灭火器（其实算的是可以供给的房间数）和还未分配灭火器的房间，按距离为 <span class=\"math inline\">\\(0\\sim k\\)</span> 分组。</p>\n<p>不难发现如果在某个点 <span class=\"math inline\">\\(u\\)</span> 处存在距离为 <span class=\"math inline\">\\(k\\)</span> 的空闲灭火器，可以贪心地分配给 <span class=\"math inline\">\\(u\\)</span>；如果存在距离为 <span class=\"math inline\">\\(k\\)</span> 的未分配房间，也可以在 <span class=\"math inline\">\\(u\\)</span> 处放置灭火器并分配给这些房间。类似地，进行两两配对一定是不劣的。</p>\n<p>发现同子树内距离为 <span class=\"math inline\">\\(k-1\\)</span> 的点对留到 <span class=\"math inline\">\\(fa\\)</span> 再匹配是不行的，因为这时距离会变成 <span class=\"math inline\">\\(k+1\\)</span>，不能匹配上；可以感受到这样是更劣的。</p>\n<p>然后就可以做了，根节点特殊乱贪心一下就行了。记得开 long long。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\n#define int long long\nsigned main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, s, k, res = 0;\n    std::cin &gt;&gt; n &gt;&gt; s &gt;&gt; k;\n    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1), p(n + 1, std::vector&lt;int&gt; (k + 1)), q(n + 1, std::vector&lt;int&gt; (k + 1));\n    for (int i = 1, x, y; i &lt; n; ++i) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y;\n        g[x].push_back(y), g[y].push_back(x);\n    &#125;\n    std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int fa) &#123;\n        for (auto i : g[x])\n            if (i != fa)  &#123;\n                DFS(i, x);\n                for (int j = 0; j &lt; k; ++j)\n                    p[x][j + 1] += p[i][j], q[x][j + 1] += q[i][j];\n            &#125;\n        ++q[x][0];\n        if (x != 1) &#123;\n            int v = (q[x][k] + s - 1) / s;\n            p[x][0] = v * s, res += v;\n            for (int i = 0; i &lt;= k; ++i) &#123;\n                int v = std::min(p[x][i], q[x][k - i]);\n                p[x][i] -= v, q[x][k - i] -= v;\n            &#125;\n            for (int i = 0; i &lt; k; ++i) &#123;\n                int v = std::min(p[x][i], q[x][k - 1 - i]);\n                p[x][i] -= v, q[x][k - 1 - i] -= v;\n            &#125;\n        &#125;\n        else &#123;\n            // std::cerr &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n            int sum = 0ll, r = 0;\n            for (int i = k; ~i; --i) &#123;\n                sum += p[x][k - i];\n                // std::cerr &lt;&lt; sum &lt;&lt; &#39;\\n&#39;;\n                int v = std::min(sum, q[x][i]);\n                sum -= v, q[x][i] -= v;\n                r += q[x][i];\n            &#125;\n            res += (r + s - 1) / s;\n        &#125;\n        return;\n    &#125;;\n    DFS(1, -1);\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"c.-扫地机器人\">C. 扫地机器人</h2>\n<p><a href=\"http://222.180.160.110:61235/contest/6502/problem/3\" class=\"uri\">http://222.180.160.110:61235/contest/6502/problem/3</a></p>\n<blockquote>\n<p>题意：给定 <span class=\"math inline\">\\(n\\)</span> 堆货物，每堆货物有重量 <span class=\"math inline\">\\(v_i\\)</span> 和一个参数 <span class=\"math inline\">\\(a_i\\)</span>。有一个初始负载为 <span class=\"math inline\">\\(0\\)</span>、负载上限为 <span class=\"math inline\">\\(c\\)</span> 的机器人，从 <span class=\"math inline\">\\(1\\)</span> 到 <span class=\"math inline\">\\(n\\)</span> 遍历这些货物，对每一处货物执行以下操作，直到清空这堆货物：</p>\n<ul>\n<li>当前负载未满：可以选择进行装载直到达到负载上限，或货物清空。花费 <span class=\"math inline\">\\(a_i\\)</span> 的代价。</li>\n<li>不管当前负载满没满：可以选择清空当前负载，花费 <span class=\"math inline\">\\(b\\)</span> 的代价。</li>\n</ul>\n<p>每一处可以任意操作，要求遍历完之后机器人负载为 <span class=\"math inline\">\\(0\\)</span>，问最小代价。<span class=\"math inline\">\\(n\\le 2\\times 10^5,c\\le 10^9\\)</span>。</p>\n</blockquote>\n<p><em>题面是重构过的，原来的题面太有歧义了。绝大多数人没做出来就是因为没看懂题吧！</em></p>\n<p>考虑暴力，可以想到令 <span class=\"math inline\">\\(f_{i,j}\\)</span> 表示处理完 <span class=\"math inline\">\\(i\\)</span> 过后负载为 <span class=\"math inline\">\\(j\\)</span> 的最小代价（显然 <span class=\"math inline\">\\(f_{i,c}\\)</span> 和 <span class=\"math inline\">\\(f_{i,0}\\)</span> 是等效的，故舍弃前者）。记 <span class=\"math inline\">\\(k=\\left\\lceil\\dfrac {v_i}c\\right\\rceil,w=(v_i\\bmod c - 1)\\bmod c+1\\)</span>，那么有：</p>\n<p><span class=\"math display\">\\[\nf_{i,(j+v_i)\\bmod c}\\gets f_{i-1,j}+k\\cdot a_i+(k-1)\\cdot b +\n\\begin{cases}\nb&amp;j+w=c\\\\\na_i+b&amp;j+w&gt; c\\\\\n0&amp;\\text{otherwise}\n\\end{cases}\\\\\nf_{i,0}\\gets f_{i,j}+b\n\\]</span></p>\n<p>发现 <span class=\"math inline\">\\(f_{i-1}\\)</span> 和 <span class=\"math inline\">\\(f_i\\)</span> 之间是存在对应关系的，所以考虑直接继承（真实的 <span class=\"math inline\">\\(0\\)</span> 应该位于 <span class=\"math inline\">\\(-s_i\\)</span> 的位置），再做全局加、区间加，<span class=\"math inline\">\\(f_{i,0}\\)</span> 的转移是全局 min，线段树维护即可；每次只会新增一个状态，动态开点即可。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 5e6 + 5;\nconst __int128 inf = 1e18;\nstruct &#123;\n    int l, r;\n    __int128 u, d;\n&#125; t[maxn];\n#define lt t[p].l\n#define rt t[p].r\nint tot;\nvoid pushdown(int p) &#123;\n    if (t[p].d) &#123;\n        t[lt].d += t[p].d, t[lt].u += t[p].d;\n        t[rt].d += t[p].d, t[rt].u += t[p].d;\n        t[p].d = 0ll;\n    &#125;\n    return;\n&#125;\nvoid upd(int &amp;p, int l, int r, int x, __int128 v) &#123;\n    if (!p)\n        p = ++tot, t[p].u = v;\n    else\n        t[p].u = std::min(t[p].u, v);\n    if (l == r)\n        return;\n    pushdown(p);\n    int mid = (l + r) &gt;&gt; 1;\n    if (x &lt;= mid)\n        upd(lt, l, mid, x, v);\n    else\n        upd(rt, mid + 1, r, x, v);\n    return;\n&#125;\nvoid add(int p, int l, int r, int ql, int qr, __int128 v) &#123;\n    if (!p)\n        return;\n    if (ql &lt;= l &amp;&amp; r &lt;= qr) &#123;\n        t[p].d += v, t[p].u += v;\n        return;\n    &#125;\n    int mid = (l + r) &gt;&gt; 1;\n    pushdown(p);\n    if (ql &lt;= mid)\n        add(lt, l, mid, ql, qr, v);\n    if (qr &gt; mid)\n        add(rt, mid + 1, r, ql, qr, v);\n    t[p].u = std::min(t[lt].u, t[rt].u);\n    return;\n&#125;\n__int128 ask(int p, int l, int r, int x) &#123;\n    if (l == r)\n        return t[p].u;\n    int mid = (l + r) &gt;&gt; 1;\n    pushdown(p);\n    if (x &lt;= mid)\n        return ask(lt, l, mid, x);\n    return ask(rt, mid + 1, r, x);\n&#125;\n#undef lt\n#undef rt\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n    std::freopen(&quot;robot.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;robot.out&quot;, &quot;w&quot;, stdout);\n#else\n    std::freopen(&quot;ex_robot4.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    t[0].u = inf;\n    int n, b, c, p0 = 0, rt = 0;\n    std::cin &gt;&gt; n &gt;&gt; c &gt;&gt; b;\n    std::vector&lt;int&gt; a(n + 1), v(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i];\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; v[i];\n    upd(rt, 0, c - 1, 0, 0ll);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        __int128 k = (v[i] + c - 1) / c, w = (v[i] % c == 0 ? c : v[i] % c);\n        t[rt].d += k * a[i] + (k - 1) * b;\n        t[rt].u += k * a[i] + (k - 1) * b;\n        if (w &lt;= c)\n            add(rt, 0, c - 1, (c - w + p0) % c, (c - w + p0) % c, b);\n        if (w != 1) &#123;\n            int l = (c - w + p0 + 1) % c, r = (p0 + c - 1) % c;\n            if (l &lt;= r)\n                add(rt, 0, c - 1, l, r, a[i] + b);\n            else &#123;\n                add(rt, 0, c - 1, 0, r, a[i] + b);\n                add(rt, 0, c - 1, l, c - 1, a[i] + b);\n            &#125;\n        &#125;\n        p0 = (p0 + c - v[i] % c) % c;\n        upd(rt, 0, c - 1, p0, t[rt].u + b);\n    &#125;\n    std::cout &lt;&lt; (long long)ask(rt, 0, c - 1, p0) &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"d.-套娃\">D. 套娃</h2>\n<p><a href=\"http://222.180.160.110:61235/contest/6502/problem/4\" class=\"uri\">http://222.180.160.110:61235/contest/6502/problem/4</a></p>\n<blockquote>\n<p>题意：给定初始为全 <span class=\"math inline\">\\(0\\)</span> 的数组 <span class=\"math inline\">\\(a_{1\\sim n + 1}\\)</span> 和 <span class=\"math inline\">\\(n\\)</span> 次单点 +1 操作，每次操作后，求解：</p>\n<p>令 <span class=\"math inline\">\\(a\\)</span> 的前缀和数组为 <span class=\"math inline\">\\(s\\)</span>，找到一个最小的 <span class=\"math inline\">\\(k\\)</span>，使得对于每个 <span class=\"math inline\">\\(i\\)</span>，均有 <span class=\"math inline\">\\(k\\cdot i\\ge s_i\\)</span> 成立。</p>\n<p><span class=\"math inline\">\\(n\\le 10^6\\)</span>，时限 0.5s。</p>\n</blockquote>\n<details>\n<p><summary>趣事一则</summary></p>\n<p>考场上最后 10min 拿到题，憋了一个能拿到 96pts 的假做法：注意到前缀和是单增的，需要维护最大的 <span class=\"math inline\">\\(\\dfrac {s_i}i\\)</span>，由于后缀 +1 带来的影响很小，所以可以猜测在大多数情况下最大的 <span class=\"math inline\">\\(i\\)</span> 只会在原来的和修改的点之间变化。只用 10 行的核心代码就能拿到很多分。但是居然有这么多，可能出题人都没有想到真有人敢交这种做法吧。</p>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n    std::freopen(&quot;doll.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;doll.out&quot;, &quot;w&quot;, stdout);\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n    auto stime = std::chrono::steady_clock::now();\n    int n, res = 0;\n    std::cin &gt;&gt; n;\n    std::vector&lt;int&gt; bit(n + 2);\n    auto lowbit = [](int x) &#123;\n        return x &amp; -x;\n    &#125;;\n    auto add = [&amp;](int x) &#123;\n        for (; x &lt;= n + 1; x += lowbit(x))\n            ++bit[x];\n        return;\n    &#125;;\n    auto ask = [&amp;](int x) &#123;\n        int res = 0;\n        for (; x; x -= lowbit(x))\n            res += bit[x];\n        return res;\n    &#125;;\n    int p = 1;\n    for (int i = 1, x; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; x, add(++x);\n        long long s = ask(x), t = ask(p);\n        if (s * p == t * x ? x &gt; p : s * p &gt; t * x)\n            p = x;\n        else\n            s = t;\n        if (s &gt; p * res)\n            ++res;\n        std::cout &lt;&lt; res &lt;&lt; &#39; &#39;;\n    &#125;\n    std::cout &lt;&lt; &#39;\\n&#39;;\n    std::cerr &lt;&lt; std::chrono::duration&lt;double&gt;(std::chrono::steady_clock::now() - stime).count() &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<p>很容易写出暴力，观察样例就能发现每次修改后答案最多增加 <span class=\"math inline\">\\(1\\)</span>。记当前答案为 <span class=\"math inline\">\\(res\\)</span>，线段树维护 <span class=\"math inline\">\\(s_i-res\\cdot i\\)</span> 的最小值，若其为负则 res++，然后重构线段树（等差数列和 min 不兼容）。</p>\n<p>怎么又有不等式 😱</p>\n<p>目的是在本来合法的范围里找到新的不合法值。考虑合法范围：<span class=\"math inline\">\\(s_i-res\\cdot i\\ge 0\\)</span>，解一下得到 <span class=\"math inline\">\\(i\\le \\dfrac {s_i}{res}\\)</span>，放缩得到 <span class=\"math inline\">\\(i\\le\\dfrac {n}{res}\\)</span>，每次 <span class=\"math inline\">\\(res\\)</span> 变化时只重构 <span class=\"math inline\">\\(\\dfrac {n}{res}\\)</span> 以前的位置，重构的总长是 <span class=\"math inline\">\\(O(n\\ln n)\\)</span> 的。（线段树建树是线性的）</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 1e6 + 5;\nconst int inf = 0x3f3f3f3f;\nstruct &#123;\n    int l, r, u, d;\n&#125; t[maxn &lt;&lt; 2];\n#define lt (p &lt;&lt; 1)\n#define rt (lt | 1)\nvoid bld(int p, int l, int r) &#123;\n    t[p].u = t[p].l = l, t[p].r = r;\n    if (l == r)\n        return;\n    int mid = (l + r) &gt;&gt; 1;\n    bld(lt, l, mid), bld(rt, mid + 1, r);\n    return;\n&#125;\nvoid pushdown(int p) &#123;\n    if (t[p].d) &#123;\n        t[lt].d += t[p].d, t[rt].d += t[p].d;\n        t[lt].u -= t[p].d, t[rt].u -= t[p].d;\n        t[p].d = 0;\n    &#125;\n    return;\n&#125;\nvoid add(int p, int x) &#123;\n    if (x &lt;= t[p].l) &#123;\n        ++t[p].d, --t[p].u;\n        return;\n    &#125;\n    pushdown(p);\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (x &lt;= mid)\n        add(lt, x);\n    add(rt, x);\n    t[p].u = std::min(t[lt].u, t[rt].u);\n    // printf(&quot;[%d, %d]: %d, [%d, %d]: %d\\n&quot;, t[p].l, mid, t[lt].u, mid + 1, t[p].r, t[rt].u);\n    return;\n&#125;\nvoid rem(int p, int r) &#123;\n    if (t[p].l == t[p].r) &#123;\n        t[p].u += t[p].l;\n        return;\n    &#125;\n    pushdown(p);\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (r &lt;= mid)\n        rem(lt, r), t[rt].u = inf;\n    else\n        rem(lt, r), rem(rt, r);\n    t[p].u = std::min(t[lt].u, t[rt].u);\n    return;\n&#125;\n#undef lt\n#undef rt\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n    std::freopen(&quot;doll.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;doll.out&quot;, &quot;w&quot;, stdout);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    bld(1, 1, n + 1);\n    for (int i = 1, x, res = 1, now = n; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; x;\n        if (x &lt;= now)\n            add(1, ++x);\n        if (t[1].u &lt; 0) &#123;\n            std::cout &lt;&lt; ++res &lt;&lt; &#39; &#39;;\n            rem(1, now = n / res);\n        &#125;\n        else\n            std::cout &lt;&lt; res &lt;&lt; &#39; &#39;;\n        // puts(&quot;&quot;);\n    &#125;\n    std::cout &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"e---subarray-sum-divisibility\">E - Subarray Sum Divisibility</h2>\n<p><a href=\"https://atcoder.jp/contests/abc419/tasks/abc419_e\" class=\"uri\">https://atcoder.jp/contests/abc419/tasks/abc419_e</a></p>\n<p>模意义下的数列全等，可以对应原数组全等、差分全等、前缀和全等（都是模意义下的，还有其他的一些线性和非线性的变换也可以）</p>\n<p>本着修改的点尽量少的想法，如果题目给定单点修改就可以在原数组上做文章，给定区间修改可以考虑差分数组，前缀和对于一些区间查询有优势</p>\n<p>其他两种用得也很多，像这题只需要用原数组全等就可以做了</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int inf = 0x3f3f3f3f;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, m, l;\n    std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; l;\n    std::vector&lt;int&gt; a(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i];\n    std::vector&lt;std::vector&lt;int&gt; &gt; u(l + 1, std::vector&lt;int&gt; (m));\n    for (int i = 1; i &lt;= l; ++i)\n        for (int j = 0; j &lt; m; ++j)\n            for (int k = i; k &lt;= n; k += l)\n                u[i][j] += (j + m - a[k]) % m;\n    std::vector&lt;std::vector&lt;int&gt; &gt; f(l + 1, std::vector&lt;int&gt; (m, inf));\n    f[0][0] = 0;\n    for (int i = 1; i &lt;= l; ++i)\n        for (int j = 0; j &lt; m; ++j)\n            for (int k = 0; k &lt; m; ++k)\n                f[i][(j + k) % m] = std::min(f[i][(j + k) % m], f[i - 1][j] + u[i][k]);\n    std::cout &lt;&lt; f[l][0] &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;\n</code></pre>\n</details>\n<hr />\n<h2 id=\"f---all-included\">F - All Included</h2>\n<p><a href=\"https://atcoder.jp/contests/abc419/tasks/abc419_f\" class=\"uri\">https://atcoder.jp/contests/abc419/tasks/abc419_f</a></p>\n<p>原题意转化为在 AC 自动机上走 <span class=\"math inline\">\\(L\\)</span> 步，要求经过 <span class=\"math inline\">\\(n\\)</span> 个叶子的方案数。不太可做，转化成容斥（令字符串终点不可达）。在外层枚举步数暴力游走。</p>\n<p>要求恰好走 <span class=\"math inline\">\\(L\\)</span> 步，也可以用矩阵；但原图很稀疏，所以矩阵并没有优势。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 998244353;\nint tot = 1, T[805][26], fail[805];\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, l;\n    std::cin &gt;&gt; n &gt;&gt; l;\n    std::vector&lt;std::string&gt; a;\n    &#123;\n        std::vector&lt;std::string&gt; s(n + 1);\n        for (int i = 1; i &lt;= n; ++i)\n            std::cin &gt;&gt; s[i];\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            bool flag = 1;\n            for (int j = 1; j &lt;= n; ++j)\n                if (j != i)\n                    if (s[j].find(s[i]) != std::string::npos) &#123;\n                        flag = 0;\n                        break;\n                    &#125;\n            if (flag)\n                a.push_back(s[i]);\n        &#125;\n        n = (int)a.size();\n    &#125;\n    std::vector&lt;int&gt; pos(n);\n    for (int i = 0; i &lt; n; ++i) &#123;\n        int &amp;p = pos[i];\n        for (auto j : a[i]) &#123;\n            if (!T[p][j - &#39;a&#39;])\n                T[p][j - &#39;a&#39;] = tot++;\n            p = T[p][j - &#39;a&#39;];\n        &#125;\n    &#125;\n    &#123;\n        std::queue&lt;int&gt; q;\n        for (int i = 0; i &lt; 26; ++i)\n            if (T[0][i])\n                q.push(T[0][i]);\n        for (; !q.empty(); ) &#123;\n            int u = q.front();\n            q.pop();\n            for (int i = 0; i &lt; 26; ++i)\n                if (T[u][i]) &#123;\n                    int v = T[u][i];\n                    fail[v] = T[fail[u]][i];\n                    q.push(v);\n                &#125;\n                else\n                    T[u][i] = T[fail[u]][i];\n        &#125;\n    &#125;\n    auto res = 0ll;\n    int siz = 1 &lt;&lt; n;\n    for (int i = 0; i &lt; siz; ++i) &#123;\n        std::vector&lt;int&gt; tag(tot);\n        for (int j = 0; j &lt; n; ++j)\n            if ((i &gt;&gt; j) &amp; 1)\n                tag[pos[j]] = 1;\n        std::vector&lt;std::vector&lt;long long&gt; &gt; f(l + 1, std::vector&lt;long long&gt; (tot));\n        f[0][0] = 1ll;\n        for (int j = 0; j &lt; l; ++j)\n            for (int k = 0; k &lt; tot; ++k)\n                for (int a = 0; a &lt; 26; ++a) &#123;\n                    if (!tag[T[k][a]])\n                        (f[j + 1][T[k][a]] += f[j][k]) %= mod;\n                &#125;\n        int k = (__builtin_popcount(i) &amp; 1 ? mod - 1 : 1);\n        auto s = 0ll;\n        for (int j = 0; j &lt; tot; ++j)\n            if (!tag[j])\n                (s += f[l][j]) %= mod;\n        (res += k * s) %= mod;\n    &#125;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"g---count-simple-paths-2\">G - Count Simple Paths 2</h2>\n<p><a href=\"https://atcoder.jp/contests/abc419/tasks/abc419_g\" class=\"uri\">https://atcoder.jp/contests/abc419/tasks/abc419_g</a></p>\n<p>很新的性质。考虑『以 <span class=\"math inline\">\\(1\\)</span> 为起点的简单路径数』和反祖边数量的关系：选定一条反祖边必须被经过时（显然只有一种可能的经过方向），树的形态发生变化：</p>\n<p><img src=\"image.png\" /></p>\n<p>也就是说，一种反祖边的选取方案对应一种树，遍历其从 <span class=\"math inline\">\\(1\\)</span> 开始的简单路径复杂度为 <span class=\"math inline\">\\(O(n)\\)</span>。设反祖边数量为 <span class=\"math inline\">\\(k\\)</span>，那么合法的方案数不超过 <span class=\"math inline\">\\(2^k\\)</span>，暴力 DFS 的整个图复杂度为 <span class=\"math inline\">\\(O(2^k\\cdot n)\\)</span>。</p>\n<p>发现很多跟反祖边无关的遍历是不必要的（只有一种走法，可以设成边权），考虑对所有连接反祖边的点建立虚树，并把原树上的反祖边也移到虚树上，就能 <span class=\"math inline\">\\(O(2^k\\cdot k)\\)</span> 解决问题。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, m;\n    std::cin &gt;&gt; n &gt;&gt; m;\n    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1), g1(n + 1);\n    std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; g2(n + 1);\n    for (int x, y; m--; ) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y;\n        g[x].push_back(y), g[y].push_back(x);\n    &#125;\n    std::vector&lt;int&gt; tag(n + 1), vis(n + 1);\n    std::vector&lt;std::pair&lt;int, int&gt; &gt; be;\n    std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int fa) &#123;\n        static int now = 0;\n        tag[x] = 1, vis[x] = ++now;\n        for (auto i : g[x])\n            if (!tag[i]) &#123;\n                // fprintf(stderr, &quot;%d -&gt; %d\\n&quot;, x, i);\n                g1[x].push_back(i), DFS(i, x);\n            &#125;\n            else if (i != fa &amp;&amp; vis[i] &lt; vis[x])\n                be.emplace_back(i, x);\n        return;\n    &#125;;\n    DFS(1, -1);\n    &#123; // 求虚树\n        std::vector&lt;int&gt; dep(n + 1), fa(n + 1), top(n + 1), siz(n + 1), son(n + 1), dfn(n + 1), rfn(n + 1);\n        std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;\n            siz[x] = 1;\n            for (auto i : g1[x]) &#123;\n                dep[i] = dep[x] + 1;\n                fa[i] = x, DFS(i);\n                siz[x] += siz[i];\n                if (siz[i] &gt; siz[son[x]])\n                    son[x] = i;\n            &#125;\n            return;\n        &#125;;\n        DFS(1);\n        DFS = [&amp;](int x) &#123;\n            static int now = 0;\n            dfn[x] = ++now;\n            if (son[x])\n                top[son[x]] = top[x], DFS(son[x]);\n            for (auto i : g1[x])\n                if (i != son[x])\n                    top[i] = i, DFS(i);\n            rfn[x] = now;\n            // printf(&quot;%d: [%d, %d]\\n&quot;, x, dfn[x], rfn[x]);\n            return;\n        &#125;;\n        top[1] = 1, DFS(1);\n        auto getLCA = [&amp;](int x, int y) &#123;\n            for (; top[x] != top[y]; x = fa[top[x]])\n                if (dep[top[x]] &lt; dep[top[y]])\n                    std::swap(x, y);\n            return dep[x] &lt; dep[y] ? x : y;\n        &#125;;\n        tag.assign(n + 1, 0);\n        tag[1] = tag[n] = 1;\n        for (auto [u, v] : be)\n            tag[u] = 1, tag[v] = 1;\n        std::vector&lt;int&gt; p;\n        for (int i = 1; i &lt;= n; ++i)\n            if (tag[i])\n                p.push_back(i);\n        std::sort(p.begin(), p.end(), [&amp;](int i, int j) &#123; return dfn[i] &lt; dfn[j]; &#125;);\n        for (int i = 1; i &lt; (int)p.size(); ++i) &#123;\n            int fa = getLCA(p[i], p[i - 1]);\n            if (!tag[fa])\n                tag[fa] = 1;\n        &#125;\n        p.clear();\n        for (int i = 1; i &lt;= n; ++i)\n            if (tag[i])\n                p.push_back(i);\n        std::sort(p.begin(), p.end(), [&amp;](int i, int j) &#123; return dfn[i] &lt; dfn[j]; &#125;);\n        std::vector&lt;int&gt; st;\n        for (auto i : p) &#123;\n            if (st.empty())\n                st.push_back(i);\n            else &#123;\n                for (; rfn[st.back()] &lt; dfn[i]; st.pop_back());\n                g2[st.back()].emplace_back(i, dep[i] - dep[st.back()]);\n                g2[i].emplace_back(st.back(), dep[i] - dep[st.back()]);\n                // printf(&quot;add (%d, %d): %d\\n&quot;, st.back(), i, dep[i] - dep[st.back()]);\n                st.push_back(i);\n            &#125;\n        &#125;\n        for (auto [u, v] : be) &#123;\n            g2[u].emplace_back(v, 1), g2[v].emplace_back(u, 1);\n            // printf(&quot;# add(%d, %d): 1\\n&quot;, u, v);\n        &#125;\n    &#125;\n    tag.assign(n + 1, 0);\n    std::vector&lt;int&gt; res(n + 1);\n    DFS = [&amp;](int x, int s) &#123;\n        if (x == n)\n            ++res[s];\n        tag[x] = 1;\n        for (auto [i, w] : g2[x])\n            if (!tag[i])\n                DFS(i, s + w);\n        tag[x] = 0;\n        return;\n    &#125;;\n    DFS(1, 0);\n    for (int i = 1; i &lt; n; ++i)\n        std::cout &lt;&lt; res[i] &lt;&lt; &#39; &#39;;\n    std::cout &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n",
            "tags": [
                "线段树",
                "AC 自动机",
                "贪心",
                "DP 优化",
                "虚树"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20250814/",
            "url": "https://xsc062.netlify.app/20250814/",
            "title": "DDP 与 GBT 练习",
            "date_published": "2025-08-14T09:08:21.000Z",
            "content_html": "<p>线段树是对的（存疑）</p>\n<span id=\"more\"></span>\n<hr />\n<h2 id=\"a---数据传输\">A - 数据传输</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P8820\" class=\"uri\">https://www.luogu.com.cn/problem/P8820</a></p>\n<p>我在上一篇文章中提到了 <a href=\"/20250812/#树上路径查询\">DDP &amp; 路径查询问题</a>，在这个题中就有体现。</p>\n<p>设 <span class=\"math inline\">\\(f_{u,0/1/2}\\)</span> 表示数据保存在 <span class=\"math inline\">\\(u\\)</span> 往下数 <span class=\"math inline\">\\(0/1/2\\)</span> 个点处的最小代价，手玩容易发现 <span class=\"math inline\">\\(k=3\\)</span> 时<strong>最优路径可能会往某个 <span class=\"math inline\">\\(x\\)</span> 或 <span class=\"math inline\">\\(fa\\)</span> 处的最小代价儿子处绕一圈来避免这个 <span class=\"math inline\">\\(x\\)</span> 或 <span class=\"math inline\">\\(fa\\)</span> 的代价</strong>。但该值是定值，问题还是纯路径问题，就可以 DDP 了。</p>\n<figure>\n<img src=\"image.png\" alt=\"共两种可能性（任意一个箭头长度不为 3 时绕一圈一定不比直接走更优）\" /><figcaption>共两种可能性（任意一个箭头长度不为 <span class=\"math inline\">\\(3\\)</span> 时绕一圈一定不比直接走更优）</figcaption>\n</figure>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nstruct mat &#123;\n    long long a[3][3];\n    long long* operator[] (const int q) &#123;\n        return a[q];\n    &#125;\n    mat() &#123;\n        memset(a, 0x3f, sizeof (a));\n        return;\n    &#125;\n    mat(int flag) &#123;\n        memset(a, 0x3f, sizeof (a));\n        a[0][0] = a[1][1] = a[2][2] = 0ll;\n        return;\n    &#125;\n    mat operator* (mat &amp;q) const &#123;\n        mat res;\n        for (int i = 0; i &lt; 3; ++i)\n            for (int k = 0; k &lt; 3; ++k)\n                for (int j = 0; j &lt; 3; ++j)\n                    res[i][k] = std::min(res[i][k], a[i][j] + q[j][k]);\n        return res;\n    &#125;\n    mat&amp; operator*= (mat &amp;q) &#123;\n        return *this = *this * q;\n    &#125;\n&#125;;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, q, k;\n    std::cin &gt;&gt; n &gt;&gt; q &gt;&gt; k;\n    std::vector&lt;int&gt; a(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i];\n    std::vector&lt;int&gt; mx(n + 1, 0x3f3f3f3f);\n    std::vector&lt;std::vector&lt;int&gt; &gt; g1(n + 1);\n    for (int i = 1, x, y; i &lt; n; ++i) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y;\n        mx[x] = std::min(mx[x], a[y]);\n        mx[y] = std::min(mx[y], a[x]);\n        g1[x].push_back(y), g1[y].push_back(x);\n    &#125;\n    std::vector&lt;int&gt; dep(n + 1);\n    std::vector&lt;std::array&lt;int, 18&gt; &gt; f(n + 1);\n    std::vector&lt;std::array&lt;mat, 18&gt; &gt; u(n + 1), d(n + 1);\n    u[0][0] = d[0][0] = mat(1);\n    std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;\n        for (auto i : g1[x])\n            if (i != f[x][0]) &#123;\n                f[i][0] = x;\n                &#123;\n                    mat s;\n                    s[0][0] = a[x];\n                    if (k &gt;= 2) &#123;\n                        s[0][1] = 0;\n                        s[1][0] = a[x];\n                    &#125;\n                    if (k &gt;= 3) &#123;\n                        s[1][2] = 0;\n                        s[2][0] = a[x];\n                        s[1][1] = mx[x];\n                        s[2][2] = mx[i];\n                    &#125;\n                    u[i][0] = s; \n                    s[0][0] = a[i];\n                    if (k &gt;= 2)\n                        s[1][0] = a[i];\n                    if (k &gt;= 3) &#123;\n                        s[2][0] = a[i];\n                        s[1][1] = mx[i];\n                        s[2][2] = mx[x];\n                    &#125;\n                    d[i][0] = s; \n                &#125;\n                for (int j = 1; j &lt; 18; ++j) &#123;\n                    f[i][j] = f[f[i][j - 1]][j - 1];\n                    u[i][j] = u[i][j - 1] * u[f[i][j - 1]][j - 1];\n                    d[i][j] = d[f[i][j - 1]][j - 1] * d[i][j - 1];\n                &#125;\n                dep[i] = dep[x] + 1;\n                DFS(i);\n            &#125;\n        return;\n    &#125;;\n    dep[1] = 1, DFS(1);\n    for (int x, y; q--; ) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y;\n        long long res = a[x];\n        mat r1(1), r2(1);\n        if (dep[x] &gt; dep[y]) &#123;\n            for (int i = 17; ~i; --i)\n                if (dep[f[x][i]] &gt;= dep[y]) &#123;\n                    r1 = r1 * u[x][i];\n                    x = f[x][i];\n                &#125;\n        &#125;\n        else if (dep[y] &gt; dep[x]) &#123;\n            for (int i = 17; ~i; --i)\n                if (dep[f[y][i]] &gt;= dep[x]) &#123;\n                    r2 = d[y][i] * r2;\n                    y = f[y][i];\n                &#125;\n        &#125;\n        if (x != y) &#123;\n            for (int i = 17; ~i; --i)\n                if (f[x][i] != f[y][i]) &#123;\n                    r1 = r1 * u[x][i];\n                    r2 = d[y][i] * r2;\n                    x = f[x][i], y = f[y][i];\n                &#125;\n            r1 = r1 * u[x][0], r2 = d[y][0] * r2;\n        &#125;\n        std::cout &lt;&lt; res + (r1 * r2)[0][0] &lt;&lt; &#39;\\n&#39;;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"b---the-silk-road-with-robots\">B - The Silk Road … with Robots!</h2>\n<p><a href=\"https://qoj.ac/problem/10410\" class=\"uri\">https://qoj.ac/problem/10410</a></p>\n<blockquote>\n<p>题意：初始有一个长为 <span class=\"math inline\">\\(10^8\\)</span> 的空数轴，给定 <span class=\"math inline\">\\(n\\)</span> 次操作，每次操作在数轴上的一个空位放一个 A 类点或 B 类点。每个 A 类点有其<strong>价值</strong>。</p>\n<p>任意在数轴上移动这些 B 类点，<strong>总价值</strong>为所有被经过的 A 类点的<strong>价值</strong> - B 类点移动总路程。每次操作后输出最大<strong>总价值</strong>，重复经过的 A 类点只计一次。</p>\n<p><span class=\"math inline\">\\(n\\le 2\\times 10^5\\)</span>。</p>\n</blockquote>\n<p>这个题确实可以带来很多启发，我一开始直接设 <span class=\"math inline\">\\(f_j\\)</span> 为状态，这样对于暴力是可做的，但是会出现一些需要被区间修改的系数，比如<strong>前缀和</strong>。最好设计状态，让转移的时候只需要用到常数、差分值等修改次数很少的系数。</p>\n<p>设 <span class=\"math inline\">\\(f_{i,0/1/2/3}\\)</span> 分别表示：</p>\n<p><img src=\"image-1.png\" /></p>\n<p>那么可以写出转移式：</p>\n<p><span class=\"math display\">\\[\nf_{i,0}=\\max(mx+a_i+x_i,f_{i-1,0}+a_i)\\\\\nf_{i,1}=\\max(mx+a_i+2x_i,f_{i-1,1}+a_i)\\\\\nf_{i,2}=f_{i-1,2}-(x_i-x_{i-1}) + a_i\\\\\nf_{i,3}=f_{i-1,3}-2(x_i-x_{i-1})+a_i\n\\]</span></p>\n<p>其中 <span class=\"math inline\">\\(mx\\)</span> 为 <span class=\"math inline\">\\(f_{i,2/3}\\)</span> 的前缀最大值。在 B 类点处可以让 <span class=\"math inline\">\\(f_{2/3}\\)</span> 继承对应的 <span class=\"math inline\">\\(f_{0/1}\\)</span>，新开一维记录 <span class=\"math inline\">\\(mx\\)</span> 就可以维护矩乘了。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int lim = 1e8;\nconst int maxn = 5e6 + 5;\nconst long long inf = 1e12;\nstruct mat &#123;\n    long long a[5][5];\n    mat() &#123;&#125;\n    long long* operator[] (const int q) &#123;\n        return a[q];\n    &#125;\n    mat operator* (mat &amp;q) const &#123;\n        mat res;\n        for (int i = 0; i &lt; 5; ++i)\n            for (int k = 0; k &lt; 5; ++k) &#123;\n                auto u(-inf);\n                for (int j = 0; j &lt; 5; ++j)\n                    u = std::max(u, a[i][j] + q[j][k]);\n                res[i][k] = u;\n            &#125;\n        return res;\n    &#125;\n    mat&amp; operator*= (mat &amp;q) &#123;\n        return *this = *this * q;\n    &#125;\n&#125;;\nstruct &#123; int l, r; mat u; &#125; t[maxn];\n#define lt t[p].l\n#define rt t[p].r\nvoid add(int &amp;p, int l, int r, int x, mat &amp;v) &#123;\n    static int tot = 0;\n    if (!p)\n        p = ++tot;\n    if (l == r) &#123;\n        t[p].u = v;\n        return;\n    &#125;\n    int mid = (l + r) &gt;&gt; 1;\n    if (x &lt;= mid)\n        add(lt, l, mid, x, v);\n    else\n        add(rt, mid + 1, r, x, v);\n    t[p].u = t[lt].u * t[rt].u;\n    return;\n&#125;\n#undef lt\n#undef rt\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    &#123;\n        mat &amp;u = t[0].u;\n        for (int i = 0; i &lt; 5; ++i)\n            for (int j = 0; j &lt; 5; ++j)\n                u[i][j] = -inf;\n        u[0][0] = u[1][1] = u[2][2] = u[3][3] = u[4][4] = 0ll;\n    &#125;\n    int m, rt = 0;\n    std::cin &gt;&gt; m;\n    std::vector&lt;mat&gt; a(m + 1);\n    std::vector&lt;int&gt; ty(m + 1);\n    std::set&lt;std::pair&lt;long long, int&gt; &gt; s;\n    s.emplace(-inf, 0);\n    for (int op, x, i = 1; i &lt;= m; ++i) &#123;\n        std::cin &gt;&gt; op &gt;&gt; x;\n        auto &amp;u = a[i];\n        for (int i = 0; i &lt; 5; ++i)\n            for (int j = 0; j &lt; 5; ++j)\n                u[i][j] = -inf;\n        auto p = --s.lower_bound(std::make_pair(x, 0)), q = s.upper_bound(std::make_pair(x, 0));\n        int v = 0;\n        if (op == 2)\n            std::cin &gt;&gt; v;\n        u[0][0] = v, u[1][1] = v, u[4][0] = v + x, u[4][1] = v + 2 * x;\n        if (op == 1) &#123;\n            ty[i] = 0;\n            u[4][2] = u[4][1] - 2 * x;\n            u[1][2] = u[1][1] - 2 * x;\n            u[4][3] = u[4][0] - x;\n            u[0][3] = u[0][0] - x;\n        &#125;\n        else &#123;\n            ty[i] = 1;\n            u[2][2] = v - (x - p-&gt;first);\n            u[3][3] = v - 2 * (x - p-&gt;first);\n        &#125;\n        u[4][4] = std::max(&#123; 0ll, u[4][2], u[4][3] &#125;);\n        u[1][4] = u[1][2], u[0][4] = u[0][3], u[2][4] = u[2][2], u[3][4] = u[3][3];\n        add(rt, 0, lim, x, u);\n        if (q != s.end() &amp;&amp; ty[q-&gt;second] == 1) &#123;\n            auto &amp;u = a[q-&gt;second];\n            u[2][2] -= p-&gt;first, u[2][2] += x;\n            u[3][3] -= 2 * p-&gt;first, u[3][3] += 2 * x;\n            u[2][4] = u[2][2], u[3][4] = u[3][3];\n            add(rt, 0, lim, q-&gt;first, a[q-&gt;second]);\n        &#125;\n        s.emplace(x, i);\n        std::cout &lt;&lt; t[1].u[4][4] &lt;&lt; &#39;\\n&#39;;\n        // for (int i = 0; i &lt; 5; ++i, puts(&quot;&quot;))\n        //     for (int j = 0; j &lt; 5; ++j)\n        //         if (t[1].u[i][j] &lt; -200)\n        //             printf(&quot;  x &quot;);\n        //         else\n        //             printf(&quot;%3lld &quot;, t[1].u[i][j]);\n        // puts(&quot;=============&quot;);\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"c---密码箱\">C - 密码箱</h2>\n<p><a href=\"/20250818/#c---%E5%AF%86%E7%A0%81%E7%AE%B1\">link</a>;</p>\n",
            "tags": [
                "线段树",
                "DDP"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20250812/",
            "url": "https://xsc062.netlify.app/20250812/",
            "title": "DDP 与全局平衡二叉树",
            "date_published": "2025-08-12T00:16:52.000Z",
            "content_html": "<p>其实动态 DP 不是动态树 DP 的同义词</p>\n<span id=\"more\"></span>\n<hr />\n<h2 id=\"动态-dp\">动态 DP</h2>\n<p>对于转移只依赖前几项的 DP，可以放进矩阵。</p>\n<p>默认转移范围是 <span class=\"math inline\">\\([1,n]\\)</span>；如果我们需要改变求解范围，发现如果能获取转移矩阵的乘积就很快了。考虑存下来。</p>\n<p>如果需要单点修改，等价于修改其所在矩阵，则想要尽可能少地修改存储的答案，考虑使用线段树优化该过程。</p>\n<h3 id=\"例海报\">例：海报</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P9790\" class=\"uri\">https://www.luogu.com.cn/problem/P9790</a></p>\n<p>容易列出暴力 DP 式：令 <span class=\"math inline\">\\(f_{i,j}\\)</span> 表示枚举到 <span class=\"math inline\">\\(i\\)</span> 时，包含 <span class=\"math inline\">\\(i\\)</span> 在内已经有 <span class=\"math inline\">\\(j\\)</span> 个连续的人举起海报，易得：</p>\n<p><span class=\"math display\">\\[\nf_{i,0}=\\max(f_{i-1,0},f_{i-1,1},f_{i-1,2},f_{i-1,3})\\\\\nf_{i,j}=f_{i-1,j-1}+a_i \\forall 1\\le j\\le 3\n\\]</span></p>\n<p>发现满足 + / max <strong>矩阵乘法</strong> 的形式；想到用线段树保存每段区间对应矩阵（对应性质：结合律），每次修改 / 查询就能在 <span class=\"math inline\">\\(O(\\log n)\\)</span> 之内完成。</p>\n<p>原问题是环形的，可以再加一维 <span class=\"math inline\">\\(k\\)</span> 表示钦定选了前 <span class=\"math inline\">\\(k\\)</span> 个且不选第 <span class=\"math inline\">\\(k+1\\)</span> 个时的答案。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 4e4 + 5;\nconst long long inf = 1e18;\nstruct mat &#123;\n    int n, m;\n    long long a[4][4];\n    mat() &#123;&#125;\n    mat(int n1, int m1): n(n1), m(m1) &#123;\n        for (int i = 0; i &lt; n; ++i)\n            for (int j = 0; j &lt; m; ++j)\n                a[i][j] = -inf;\n        return;\n    &#125;\n    long long* operator[] (const int q) &#123;\n        return a[q];\n    &#125;\n    mat operator* (mat &amp;q) const &#123;\n        mat res(n, q.m);\n        for (int i = 0; i &lt; n; ++i)\n            for (int k = 0; k &lt; q.m; ++k)\n                for (int j = 0; j &lt; m; ++j)\n                    res[i][k] = std::max(res[i][k], a[i][j] + q[j][k]);\n        return res;\n    &#125;\n    mat&amp; operator*= (mat &amp;q) &#123;\n        return *this = *this * q;\n    &#125;\n&#125;;\nstruct &#123; int l, r; mat u[4]; &#125; t[maxn &lt;&lt; 2];\nint a[maxn];\n#define lt (p &lt;&lt; 1)\n#define rt (lt | 1)\n#define c t[p].u[i]\nvoid bld(int p, int l, int r) &#123;\n    t[p].l = l, t[p].r = r;\n    if (l == r) &#123;\n        for (int i = 0; i &lt;= 3; ++i) &#123;\n            c = mat(4, 4);\n            if (l &gt; i + 1) &#123;\n                c[0][0] = c[1][0] = c[2][0] = c[3][0] = 0;\n                c[0][1] = c[1][2] = c[2][3] = a[l];\n            &#125;\n            else if (l == i + 1)\n                c[0][0] = c[1][0] = c[2][0] = c[3][0] = 0;\n            else\n                c[0][1] = c[1][2] = c[2][3] = a[l];\n        &#125;\n        return;\n    &#125;\n    int mid = (l + r) &gt;&gt; 1;\n    bld(lt, l, mid), bld(rt, mid + 1, r);\n    for (int i = 0; i &lt;= 3; ++i)\n        t[p].u[i] = t[lt].u[i] * t[rt].u[i];\n    return;\n&#125;\nvoid add(int p, int x, int v) &#123;\n    if (t[p].l == t[p].r) &#123;\n        for (int i = 0; i &lt;= 3; ++i)\n            if (t[p].l != i + 1) \n                c[0][1] = c[1][2] = c[2][3] = v;\n        return;\n    &#125;\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (x &lt;= mid)\n        add(lt, x, v);\n    else\n        add(rt, x, v);\n    for (int i = 0; i &lt;= 3; ++i)\n        t[p].u[i] = t[lt].u[i] * t[rt].u[i];\n    return;\n&#125;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i];\n    bld(1, 1, n);\n    auto calc = [&amp;](void) &#123;\n        mat f(1, 4);\n        f[0][0] = 0;\n        auto res = -inf;\n        for (int i = 0; i &lt;= 3; ++i) &#123;\n            auto r = (f * t[1].u[i]);\n            for (int j = 0; j &lt;= 3; ++j)\n                if (i + j &lt;= 3) &#123;\n                    res = std::max(res, r[0][j]);\n                    // printf(&quot;f[%d][%d] = %lld\\n&quot;, i, j, f[i][j]);\n                &#125;\n        &#125;\n        return res;\n    &#125;;\n    std::cout &lt;&lt; calc() &lt;&lt; &#39;\\n&#39;;\n    int q;\n    std::cin &gt;&gt; q;\n    for (int x, v; q--; ) &#123;\n        std::cin &gt;&gt; x &gt;&gt; v;\n        add(1, x, v);\n        std::cout &lt;&lt; calc() &lt;&lt; &#39;\\n&#39;;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<p>发现矩阵本身和 <span class=\"math inline\">\\(k\\)</span> 无关，还可以可以共用一个线段树上的信息，就可以只开一个线段树了。</p>\n<details>\n<p>我写这一版本的原因是 <code>maxn</code> 开大了导致 MLE，实际上四个线段树是没有任何空间压力的 😅</p>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 4e5 + 5;\nconst long long inf = 1e18;\nstruct mat &#123;\n    int n, m;\n    long long a[4][4];\n    mat() &#123;&#125;\n    mat(int n1, int m1): n(n1), m(m1) &#123;\n        for (int i = 0; i &lt; n; ++i)\n            for (int j = 0; j &lt; m; ++j)\n                a[i][j] = -inf;\n        return;\n    &#125;\n    long long* operator[] (const int q) &#123;\n        return a[q];\n    &#125;\n    mat operator* (mat q) const &#123;\n        mat res(n, q.m);\n        for (int i = 0; i &lt; n; ++i)\n            for (int k = 0; k &lt; q.m; ++k)\n                for (int j = 0; j &lt; m; ++j)\n                    res[i][k] = std::max(res[i][k], a[i][j] + q[j][k]);\n        return res;\n    &#125;\n    mat&amp; operator*= (mat &amp;q) &#123;\n        return *this = *this * q;\n    &#125;\n&#125;;\nstruct &#123; int l, r; mat u; &#125; t[maxn &lt;&lt; 2];\nint a[maxn];\n#define lt (p &lt;&lt; 1)\n#define rt (lt | 1)\nvoid bld(int p, int l, int r) &#123;\n    t[p].l = l, t[p].r = r;\n    if (l == r) &#123;\n        t[p].u = mat(4, 4);\n        t[p].u[0][0] = t[p].u[1][0] = t[p].u[2][0] = t[p].u[3][0] = 0;\n        t[p].u[0][1] = t[p].u[1][2] = t[p].u[2][3] = a[l];\n        return;\n    &#125;\n    int mid = (l + r) &gt;&gt; 1;\n    bld(lt, l, mid), bld(rt, mid + 1, r);\n    t[p].u = t[lt].u * t[rt].u;\n    return;\n&#125;\nvoid add(int p, int x, int v) &#123;\n    if (t[p].l == t[p].r) &#123;\n        t[p].u[0][1] = t[p].u[1][2] = t[p].u[2][3] = v;\n        return;\n    &#125;\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (x &lt;= mid)\n        add(lt, x, v);\n    else\n        add(rt, x, v);\n    t[p].u = t[lt].u * t[rt].u;\n    return;\n&#125;\nmat ask(int p, int l, int r) &#123;\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r)\n        return t[p].u;\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (r &lt;= mid)\n        return ask(lt, l, r);\n    if (l &gt; mid)\n        return ask(rt, l, r);\n    return ask(lt, l, r) * ask(rt, l, r);\n&#125;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i];\n    bld(1, 1, n);\n    auto calc = [&amp;](void) &#123;\n        mat f(1, 4);\n        f[0][0] = 0, f[0][1] = f[0][2] = f[0][3] = -inf;\n        auto r(f * ask(1, 2, n));\n        auto res(*std::max_element(r[0], r[0] + 4));\n        mat z(4, 4);\n        z[0][0] = z[1][0] = z[2][0] = z[3][0] = 0ll;\n        for (int i = 1; i &lt;= 3; ++i) &#123;\n            mat op(4, 4);\n            op[0][1] = op[1][2] = op[2][3] = a[i];\n            f *= op;\n            if (i + 2 &lt;= n)\n                r = f * z * ask(1, i + 2, n);\n            else\n                r = f * z;\n            res = std::max(res, *std::max_element(r[0], r[0] + 4 - i));\n        &#125;\n        return res;\n    &#125;;\n    std::cout &lt;&lt; calc() &lt;&lt; &#39;\\n&#39;;\n    int q;\n    std::cin &gt;&gt; q;\n    for (int x, v; q--; ) &#123;\n        std::cin &gt;&gt; x &gt;&gt; v, a[x] = v;\n        add(1, x, v);\n        std::cout &lt;&lt; calc() &lt;&lt; &#39;\\n&#39;;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"经典题gss3\">经典题：GSS3</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/SP1716\" class=\"uri\">https://www.luogu.com.cn/problem/SP1716</a></p>\n<p>怎么是子段和 😓</p>\n<p>同样列出能够矩阵乘法的 DP 式，发现限制在于至少要选一个数。设 <span class=\"math inline\">\\(f_{i}\\)</span> 表示选了 <span class=\"math inline\">\\(i\\)</span> 的最大值，<span class=\"math inline\">\\(g_i\\)</span> 表示历史最大值，则：</p>\n<p><span class=\"math display\">\\[\nf_i=\\max(f_{i-1}+a_i,0+a_i)\\\\\ng_i=\\max(g_{i-1}+0,f_{i-1}+a_i,0+a_i)\n\\]</span></p>\n<p>容易发现是一个 + / max 矩乘，线段树维护即可。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 4e5 + 5;\nconst long long inf = 1e18;\nstruct mat &#123;\n    int n, m;\n    long long a[3][3];\n    mat() &#123;&#125;\n    mat(int n1, int m1): n(n1), m(m1) &#123;\n        for (int i = 0; i &lt; n; ++i)\n            for (int j = 0; j &lt; m; ++j)\n                a[i][j] = -inf;\n        return;\n    &#125;\n    long long* operator[] (const int q) &#123;\n        return a[q];\n    &#125;\n    mat operator* (mat q) const &#123;\n        mat res(n, q.m);\n        for (int i = 0; i &lt; n; ++i)\n            for (int k = 0; k &lt; q.m; ++k)\n                for (int j = 0; j &lt; m; ++j)\n                    res[i][k] = std::max(res[i][k], a[i][j] + q[j][k]);\n        return res;\n    &#125;\n    mat&amp; operator*= (mat &amp;q) &#123;\n        return *this = *this * q;\n    &#125;\n&#125;;\nstruct &#123; int l, r; mat u; &#125; t[maxn &lt;&lt; 2]; \nint a[maxn];\n#define lt (p &lt;&lt; 1)\n#define rt (lt | 1)\nvoid bld(int p, int l, int r) &#123;\n    t[p].l = l, t[p].r = r;\n    if (l == r) &#123;\n        t[p].u = mat(3, 3);\n        t[p].u[0][0] = t[p].u[2][0] = a[l];\n        t[p].u[0][1] = a[l], t[p].u[1][1] = 0ll, t[p].u[2][1] = a[l];\n        t[p].u[2][2] = 0ll;\n        return;\n    &#125;\n    int mid = (l + r) &gt;&gt; 1;\n    bld(lt, l, mid), bld(rt, mid + 1, r);\n    t[p].u = t[lt].u * t[rt].u;\n    return;\n&#125;\nvoid add(int p, int x, int v) &#123;\n    if (t[p].l == t[p].r) &#123;\n        t[p].u[0][0] = t[p].u[2][0] = t[p].u[0][1] = t[p].u[2][1] = v;\n        return;\n    &#125;\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (x &lt;= mid)\n        add(lt, x, v);\n    else\n        add(rt, x, v);\n    t[p].u = t[lt].u * t[rt].u;\n    return;\n&#125;\nmat ask(int p, int l, int r) &#123;\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r)\n        return t[p].u;\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (r &lt;= mid)\n        return ask(lt, l, r);\n    if (l &gt; mid)\n        return ask(rt, l, r);\n    return ask(lt, l, r) * ask(rt, l, r);\n&#125;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i];\n    bld(1, 1, n);\n    auto calc = [&amp;](int l, int r) &#123;\n        mat f(1, 3);\n        f[0][2] = 0ll;\n        auto res(f * ask(1, l, r));\n        return res[0][1];\n    &#125;;\n    int q;\n    std::cin &gt;&gt; q;\n    for (int op; q--; ) &#123;\n        std::cin &gt;&gt; op;\n        if (op == 1) &#123;\n            int l, r;\n            std::cin &gt;&gt; l &gt;&gt; r;\n            std::cout &lt;&lt; calc(l, r) &lt;&lt; &#39;\\n&#39;;\n        &#125;\n        else &#123;\n            int x, v;\n            std::cin &gt;&gt; x &gt;&gt; v;\n            a[x] = v, add(1, x, v);\n        &#125;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"动态树-dp\">动态树 DP</h2>\n<p>把上述过程放到树上，很容易想到树剖 + 线段树。</p>\n<p>由于认为线段树上的矩乘只能进行从重儿子到父亲的转移，轻儿子的转移会被合并为一个新函数（同时是矩阵的系数），在跳重链的时候被单独更新。</p>\n<p>由于两个函数相互依赖，需要思考清楚更新的先后顺序。</p>\n<h3 id=\"模板动态-dp\">【模板】动态 DP</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P4719\" class=\"uri\">https://www.luogu.com.cn/problem/P4719</a></p>\n<p>令 <span class=\"math inline\">\\(f_{u,0/1}\\)</span> 表示在 <span class=\"math inline\">\\(u\\)</span> 上，选 / 不选 <span class=\"math inline\">\\(u\\)</span> 的最大价值。容易得出转移：</p>\n<p><span class=\"math display\">\\[\nf_{u,0}=\\sum\\max(f_{v,0},f_{v,1})\\\\\nf_{u,1}=a_i+\\sum f_{v,0}\n\\]</span></p>\n<p>把转移矩阵放到树剖上后，考虑更新，发现求和这一步很困难。解决方案是<strong>直接将求和用另一个函数代替</strong>。定义 <span class=\"math inline\">\\(g_{u,0}\\)</span> 表示取 <span class=\"math inline\">\\(u\\)</span>、不取 <span class=\"math inline\">\\(u\\)</span> 的所有轻儿子的答案，<span class=\"math inline\">\\(g_{u,1}\\)</span> 不取 <span class=\"math inline\">\\(u\\)</span>，轻儿子可选可不选的答案。</p>\n<p><span class=\"math inline\">\\(g\\)</span> 是可求的，且只需要在跳重链的时候更新 <span class=\"math inline\">\\(g\\)</span>。具体更新起来非常绞，因为 <span class=\"math inline\">\\(g\\)</span> 和 <span class=\"math inline\">\\(f\\)</span> 是相互依赖的，需要分清楚先后关系。</p>\n<p>首先 <span class=\"math inline\">\\(g_u\\)</span> 和 <span class=\"math inline\">\\(f_u\\)</span> 都会被更新；接着，重链上其它的 <span class=\"math inline\">\\(g\\)</span> 不会被影响，而链顶的 <span class=\"math inline\">\\(f\\)</span> 需要被新的 <span class=\"math inline\">\\(g_u\\)</span> 更新；由此链顶父亲的 <span class=\"math inline\">\\(g\\)</span> 被更新；依次类推。注意到对于一个链顶，其 <span class=\"math inline\">\\(f\\)</span> 值是整条重链的乘积，故需要记录链底。</p>\n<p>复杂度 <span class=\"math inline\">\\(O(q\\log ^2n)\\)</span>。注意很重要的一点是线段树内乘法应从右往左。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 1e5 + 5;\nconst int inf = 0x3f3f3f3f;\nstruct mat &#123;\n    int n, m, a[2][2];\n    mat() &#123;&#125;\n    mat(int n1, int m1): n(n1), m(m1) &#123;\n        for (int i = 0; i &lt; n; ++i)\n            for (int j = 0; j &lt; m; ++j)\n                a[i][j] = -inf;\n        return;\n    &#125;\n    int* operator[] (const int q) &#123;\n        return a[q];\n    &#125;\n    mat operator* (mat q) const &#123;\n        mat res(n, q.m);\n        for (int i = 0; i &lt; n; ++i)\n            for (int k = 0; k &lt; q.m; ++k)\n                for (int j = 0; j &lt; m; ++j)\n                    res[i][k] = std::max(res[i][k], a[i][j] + q[j][k]);\n        return res;\n    &#125;\n    mat&amp; operator*= (mat &amp;q) &#123;\n        return *this = *this * q;\n    &#125;\n&#125;;\nstruct &#123; int l, r; mat u; &#125; t[maxn &lt;&lt; 2]; \nint g[maxn][2], tab[maxn];\n#define lt (p &lt;&lt; 1)\n#define rt (lt | 1)\nvoid bld(int p, int l, int r) &#123;\n    t[p].l = l, t[p].r = r;\n    if (l == r) &#123;\n        int u = tab[l];\n        t[p].u = mat(2, 2);\n        t[p].u[0][0] = t[p].u[1][0] = g[u][1];\n        t[p].u[0][1] = g[u][0];\n        return;\n    &#125;\n    int mid = (l + r) &gt;&gt; 1;\n    bld(lt, l, mid), bld(rt, mid + 1, r);\n    t[p].u = t[rt].u * t[lt].u;\n    return;\n&#125;\nvoid add(int p, int x) &#123;\n    if (t[p].l == t[p].r) &#123;\n        int u = tab[x];\n        t[p].u[0][0] = t[p].u[1][0] = g[u][1];\n        t[p].u[0][1] = g[u][0];\n        return;\n    &#125;\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (x &lt;= mid)\n        add(lt, x);\n    else\n        add(rt, x);\n    t[p].u = t[rt].u * t[lt].u;\n    return;\n&#125;\nmat ask(int p, int l, int r) &#123;\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r)\n        return t[p].u;\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (r &lt;= mid)\n        return ask(lt, l, r);\n    if (l &gt; mid)\n        return ask(rt, l, r);\n    return ask(rt, l, r) * ask(lt, l, r);\n&#125;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, q;\n    std::cin &gt;&gt; n &gt;&gt; q;\n    std::vector&lt;int&gt; a(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i];\n    std::vector&lt;std::vector&lt;int&gt; &gt; g1(n + 1);\n    for (int i = 1, x, y; i &lt; n; ++i) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y;\n        g1[x].push_back(y), g1[y].push_back(x);\n    &#125;\n    std::vector&lt;int&gt; siz(n + 1), son(n + 1), fa(n + 1);\n    std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;\n        siz[x] = 1;\n        for (auto i : g1[x])\n            if (i != fa[x]) &#123;\n                fa[i] = x, DFS(i);\n                siz[x] += siz[i];\n                if (siz[i] &gt; siz[son[x]])\n                    son[x] = i;\n            &#125;\n        return;\n    &#125;;\n    DFS(1);\n    std::vector&lt;std::array&lt;int, 2&gt; &gt; f(n + 1);\n    std::vector&lt;int&gt; top(n + 1), bot(n + 1), dfn(n + 1);\n    DFS = [&amp;](int x) &#123;\n        static int now = 0;\n        dfn[x] = ++now, tab[now] = x;\n        if (son[x]) &#123;\n            top[son[x]] = top[x], DFS(son[x]);\n            bot[x] = bot[son[x]];\n            g[x][0] = a[x];\n            for (auto i : g1[x])\n                if (i != son[x] &amp;&amp; i != fa[x]) &#123;\n                    top[i] = i, DFS(i);\n                    g[x][0] += f[i][0];\n                    g[x][1] += std::max(f[i][1], f[i][0]);\n                &#125;\n            f[x][0] = g[x][1] + std::max(f[son[x]][0], f[son[x]][1]);\n            f[x][1] = g[x][0] + f[son[x]][0];\n        &#125;\n        else\n            f[x][1] = g[x][0] = a[x], bot[x] = x;\n        return;\n    &#125;;\n    top[1] = 1, DFS(1);\n    bld(1, 1, n);\n    for (int x, v; q--; ) &#123;\n        std::cin &gt;&gt; x &gt;&gt; v;\n        g[x][0] -= a[x], g[x][0] += v, a[x] = v;\n        for (; top[x] != 1; ) &#123;\n            auto r = ask(1, dfn[top[x]], dfn[bot[x]]);\n            f[top[x]][0] = r[0][0], f[top[x]][1] = r[0][1];\n            g[fa[top[x]]][0] -= f[top[x]][0];\n            g[fa[top[x]]][1] -= std::max(f[top[x]][0], f[top[x]][1]);\n            add(1, dfn[x]);\n            r = ask(1, dfn[top[x]], dfn[bot[x]]);\n            f[top[x]][0] = r[0][0], f[top[x]][1] = r[0][1];\n            g[fa[top[x]]][0] += f[top[x]][0];\n            g[fa[top[x]]][1] += std::max(f[top[x]][0], f[top[x]][1]);\n            x = fa[top[x]];\n        &#125;\n        add(1, dfn[x]);\n        auto r = ask(1, dfn[1], dfn[bot[1]]);\n        f[1][0] = r[0][0], f[1][1] = r[0][1];\n        std::cout &lt;&lt; std::max(f[1][0], f[1][1]) &lt;&lt; &#39;\\n&#39;;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"全局平衡二叉树\">全局平衡二叉树</h2>\n<p>回顾树剖（重剖），功能在于解决路径问题，单次操作能够在 <span class=\"math inline\">\\(O(\\log^2 n)\\)</span> 的时间内完成。这个功能可以被<strong>全局平衡二叉树（GBT）</strong>上位替代。GBT 能够在单次 <span class=\"math inline\">\\(O(\\log n)\\)</span> 的复杂度内完成链操作、子树操作。<em><a href=\"QTREE解法的一些研究.pdf\">Yang Zhe - SPOJ375 QTREE 解法的一些研究</a> 中更为详细严谨地对 GBT 进行了说明，我传了份文件上来。</em></p>\n<p>考虑树剖能被卡的原因：每次线段树询问都会卡满 <span class=\"math inline\">\\(O(\\log n)\\)</span>，找一条卡得满 <span class=\"math inline\">\\(O(\\log n)\\)</span> 次跳重链次数的路径一直薅，就可以卡到 <span class=\"math inline\">\\(O(\\log^2 n)\\)</span>。</p>\n<p>在实现线段树时发现，对于<strong>路径操作</strong>和<strong>单点操作</strong>，树剖只需要维护同一条重链的信息，建一个大线段树会产生许多重链间的无效维护。故一种经典的树剖卡常技巧是对于每一条重链建出线段树。</p>\n<p>在本文中定义<strong>全局二叉树</strong>：将单个线段树按照在原树上重链顶的相对祖孙关系连边得到的模型。这里为了和<strong>全局平衡二叉树</strong>形成照应而命名，实际上模型并不是二叉树。容易发现<strong>修改某个点花费的操作次数和其在全局二叉树中的深度相同</strong>。</p>\n<p>考虑本方法理论上仍可卡到 <span class=\"math inline\">\\(O(\\log^2 n)\\)</span> 单次操作的原因，虽然单个线段树平衡，但<strong>全局二叉树</strong>并不平衡；能够构造数据使得树高达到 <span class=\"math inline\">\\(\\log^2 n\\)</span>。考虑使得全局二叉树平衡，即调整线段树结构使得任何一个点在全局二叉树上的左右儿子大小最接近。发现是易做的，只需在建线段树时移动左右儿子分割点使得两边子树大小均为全树的一半即可。</p>\n<p>法一：求出每个点的轻子树大小 <span class=\"math inline\">\\(ls_u=1+\\sum siz_v\\)</span>，作为加权在线段树上找 mid 就能满足全局平衡；证明可以见上面的论文。这里用线段树代替了 BST，常数很大。</p>\n<p>法二：用一个 BST 实现上述功能，需要满足：任意子树的根为子树的带权 mid；BST 的中序遍历为原重链。显然有：树高为 log 级别。这就决定了所有问题都可以通过暴力爬山解决。</p>\n<p>GBT 能够快速维护<strong>普通树剖操作</strong>和 <strong>DDP 信息</strong>。</p>\n<hr />\n<h3 id=\"维护-ddp模板动态-dp加强版\">维护 DDP：【模板】动态 DP（加强版）</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P4751\" class=\"uri\">https://www.luogu.com.cn/problem/P4751</a></p>\n<p>和未加强版类似，把所有线段树操作替换为 BST 即可。如果写得丑可能需要一些额外的卡常技巧。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 1e6 + 5;\nconst int inf = 0x3f3f3f3f;\nconst int LEN = (1 &lt;&lt; 20);\nint nec(void) &#123;\n    static char buf[LEN], *p = buf, *e = buf;\n    if (p == e) &#123;\n        e = buf + fread(buf, 1, LEN, stdin);\n        if (e == buf) return EOF;\n        p = buf;\n    &#125;\n    return *p++;\n&#125;\nbool read(int &amp;x) &#123;\n    x = 0;\n    bool f = 0;\n    char ch = nec();\n    while (ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123;\n        if (ch == EOF) return 0;\n        if (ch == &#39;-&#39;) f = 1;\n        ch = nec();\n    &#125;\n    while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) &#123;\n        x = x * 10 + ch - &#39;0&#39;;\n        ch = nec();\n    &#125;\n    if (f) x = -x;\n    return 1;\n&#125;\nvoid print(int x) &#123;\n    if (x &lt; 0)\n        putchar(&#39;-&#39;), x = -x;\n    if (x &gt;= 10) print(x / 10);\n    putchar(x % 10 + &#39;0&#39;);\n    return;\n&#125;\nvoid print(int x, char ch) &#123;\n    print(x), putchar(ch);\n    return;\n&#125;\nstruct mat &#123;\n    int a[2][2];\n    int* operator[] (const int q) &#123; \n        return a[q];\n    &#125;\n    mat operator* (mat &amp;q) const &#123;\n        mat res;\n        res[0][0] = res[0][1] = res[1][0] = res[1][1] = -inf;\n        for (int i = 0; i &lt; 2; ++i)\n            for (int k = 0; k &lt; 2; ++k)\n                for (int j = 0; j &lt; 2; ++j)\n                    res[i][k] = std::max(res[i][k], a[i][j] + q[j][k]);\n        return res;\n    &#125;\n    mat&amp; operator*= (mat &amp;q) &#123;\n        return *this = *this * q;\n    &#125;\n&#125;;\nstruct &#123; int lc, rc, fa; mat u; &#125; t[maxn]; \nint g[maxn][2], tab[maxn], ls[maxn];\nmat p[maxn];\nvoid pushup(int x) &#123;\n    t[x].u = t[t[x].rc].u * p[x] * t[t[x].lc].u;\n    return;\n&#125;\nvoid bld(int &amp;x, int l, int r) &#123;\n    if (l &gt; r)\n        return;\n    int s = 0, k = 0;\n    for (int i = l; i &lt;= r; ++i)\n        s += ls[tab[i]];\n    for (int i = l; i &lt;= r; ++i, k += ls[tab[i]])\n        if ((k + ls[tab[i]]) * 2 &gt; s) &#123;\n            x = tab[i];\n            bld(t[x].lc, l, i - 1), t[t[x].lc].fa = x;\n            bld(t[x].rc, i + 1, r), t[t[x].rc].fa = x;\n            pushup(x);\n            break;\n        &#125;\n    return;\n&#125;\n#undef lt\n#undef rt\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    t[0].u[0][0] = t[0].u[1][1] = 0, t[0].u[0][1] = t[0].u[1][0] = -inf;\n    int n, q;\n    read(n), read(q);\n    std::vector&lt;int&gt; a(n + 1), rt(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        read(a[i]);\n    std::vector&lt;std::vector&lt;int&gt; &gt; g1(n + 1);\n    for (int i = 1, x, y; i &lt; n; ++i) &#123;\n        read(x), read(y);\n        g1[x].push_back(y), g1[y].push_back(x);\n    &#125;\n    std::vector&lt;int&gt; son(n + 1), fa(n + 1), siz(n + 1);\n    std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;\n        siz[x] = 1;\n        for (auto i : g1[x])\n            if (i != fa[x]) &#123;\n                fa[i] = x, DFS(i);\n                siz[x] += siz[i];\n                if (siz[i] &gt; siz[son[x]])\n                    son[x] = i;\n            &#125;\n        return;\n    &#125;;\n    DFS(1);\n    std::vector&lt;std::array&lt;int, 2&gt; &gt; f(n + 1);\n    std::vector&lt;int&gt; top(n + 1), bot(n + 1), dfn(n + 1);\n    DFS = [&amp;](int x) &#123;\n        static int now = 0;\n        dfn[x] = ++now, tab[now] = x, ls[x] = 1;\n        if (son[x]) &#123;\n            top[son[x]] = top[x], DFS(son[x]);\n            bot[x] = bot[son[x]];\n            g[x][0] = a[x];\n            for (auto i : g1[x])\n                if (i != son[x] &amp;&amp; i != fa[x]) &#123;\n                    top[i] = i, DFS(i), t[rt[i]].fa = x;\n                    ls[x] += siz[i];\n                    g[x][0] += f[i][0];\n                    g[x][1] += std::max(f[i][1], f[i][0]);\n                &#125;\n            f[x][0] = g[x][1] + std::max(f[son[x]][0], f[son[x]][1]);\n            f[x][1] = g[x][0] + f[son[x]][0];\n        &#125;\n        else\n            f[x][1] = g[x][0] = a[x], bot[x] = x;\n        p[x][0][0] = p[x][1][0] = g[x][1];\n        p[x][0][1] = g[x][0], p[x][1][1] = -inf;\n        if (x == top[x])\n            bld(rt[x], dfn[x], dfn[bot[x]]);\n        return;\n    &#125;;\n    top[1] = 1, DFS(1);\n    for (int x, v, la = 0; q--; ) &#123;\n        read(x), read(v), x ^= la;\n        p[x][0][1] += v - a[x], a[x] = v;\n        for (; x; ) &#123;\n            int fa = t[x].fa;\n            if (fa &amp;&amp; x != t[fa].lc &amp;&amp; x != t[fa].rc) &#123;\n                int f0 = t[x].u[0][0], f1 = std::max(f0, t[x].u[0][1]);\n                pushup(x);\n                int F0 = t[x].u[0][0], F1 = std::max(F0, t[x].u[0][1]);\n                p[fa][0][0] += F1 - f1, p[fa][1][0] += F1 - f1;\n                p[fa][0][1] += F0 - f0;\n            &#125;\n            else\n                pushup(x);\n            x = fa;\n        &#125;\n        print(la = std::max(t[rt[1]].u[0][0], t[rt[1]].u[0][1]), &#39;\\n&#39;);\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<p>也给出一个线段树版本的</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 1e6 + 5;\nconst int inf = 0x3f3f3f3f;\nconst int LEN = (1 &lt;&lt; 20);\nint nec(void) &#123;\n    static char buf[LEN], *p = buf, *e = buf;\n    if (p == e) &#123;\n        e = buf + fread(buf, 1, LEN, stdin);\n        if (e == buf) return EOF;\n        p = buf;\n    &#125;\n    return *p++;\n&#125;\nbool read(int &amp;x) &#123;\n    x = 0;\n    bool f = 0;\n    char ch = nec();\n    while (ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123;\n        if (ch == EOF) return 0;\n        if (ch == &#39;-&#39;) f = 1;\n        ch = nec();\n    &#125;\n    while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) &#123;\n        x = x * 10 + ch - &#39;0&#39;;\n        ch = nec();\n    &#125;\n    if (f) x = -x;\n    return 1;\n&#125;\nvoid print(int x) &#123;\n    if (x &lt; 0)\n        putchar(&#39;-&#39;), x = -x;\n    if (x &gt;= 10) print(x / 10);\n    putchar(x % 10 + &#39;0&#39;);\n    return;\n&#125;\nvoid print(int x, char ch) &#123;\n    print(x), putchar(ch);\n    return;\n&#125;\nstruct mat &#123;\n    int a[2][2];\n    int* operator[] (const int q) &#123;\n        return a[q];\n    &#125;\n    mat operator* (mat q) const &#123;\n        mat res;\n        res[0][0] = res[0][1] = res[1][0] = res[1][1] = -inf;\n        for (int i = 0; i &lt; 2; ++i)\n            for (int k = 0; k &lt; 2; ++k)\n                for (int j = 0; j &lt; 2; ++j)\n                    res[i][k] = std::max(res[i][k], a[i][j] + q[j][k]);\n        return res;\n    &#125;\n    mat&amp; operator*= (mat &amp;q) &#123;\n        return *this = *this * q;\n    &#125;\n&#125;;\nstruct &#123; int lc, rc, l, r, mid; mat u; &#125; t[maxn &lt;&lt; 2]; \nint g[maxn][2], tab[maxn], ls[maxn];\n#define lt t[p].lc\n#define rt t[p].rc\nvoid bld(int &amp;p, int l, int r) &#123;\n    static int tot = 0;\n    p = ++tot, t[p].l = l, t[p].r = r;\n    if (l == r) &#123;\n        int u = tab[l];\n        t[p].u[0][0] = t[p].u[1][0] = g[u][1];\n        t[p].u[0][1] = g[u][0], t[p].u[1][1] = -inf;\n        return;\n    &#125;\n    int s = 0, u = ls[tab[l]];\n    for (int i = l; i &lt;= r; ++i)\n        s += ls[tab[i]];\n    s &gt;&gt;= 1;\n    t[p].mid = r - 1;\n    for (int i = l + 1; i &lt; r; ++i) &#123;\n        u += ls[tab[i]];\n        if (u + ls[tab[i + 1]] &gt; s) &#123;\n            t[p].mid = i;\n            break;\n        &#125;\n    &#125;\n    bld(lt, l, t[p].mid), bld(rt, t[p].mid + 1, r);\n    t[p].u = t[rt].u * t[lt].u;\n    return;\n&#125;\nvoid add(int p, int x) &#123;\n    if (t[p].l == t[p].r) &#123;\n        int u = tab[x];\n        t[p].u[0][0] = t[p].u[1][0] = g[u][1];\n        t[p].u[0][1] = g[u][0];\n        return;\n    &#125;\n    if (x &lt;= t[p].mid)\n        add(lt, x);\n    else\n        add(rt, x);\n    t[p].u = t[rt].u * t[lt].u;\n    return;\n&#125;\nmat ask(int p, int l, int r) &#123;\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r)\n        return t[p].u;\n    if (r &lt;= t[p].mid)\n        return ask(lt, l, r);\n    if (l &gt; t[p].mid)\n        return ask(rt, l, r);\n    return ask(rt, l, r) * ask(lt, l, r);\n&#125;\n#undef lt\n#undef rt\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, q;\n    read(n), read(q);\n    std::vector&lt;int&gt; a(n + 1), rt(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        read(a[i]);\n    std::vector&lt;std::vector&lt;int&gt; &gt; g1(n + 1);\n    for (int i = 1, x, y; i &lt; n; ++i) &#123;\n        read(x), read(y);\n        g1[x].push_back(y), g1[y].push_back(x);\n    &#125;\n    std::vector&lt;int&gt; siz(n + 1), son(n + 1), fa(n + 1);\n    std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;\n        siz[x] = 1;\n        for (auto i : g1[x])\n            if (i != fa[x]) &#123;\n                fa[i] = x, DFS(i);\n                siz[x] += siz[i];\n                if (siz[i] &gt; siz[son[x]])\n                    son[x] = i;\n            &#125;\n        return;\n    &#125;;\n    DFS(1);\n    std::vector&lt;std::array&lt;int, 2&gt; &gt; f(n + 1);\n    std::vector&lt;int&gt; top(n + 1), bot(n + 1), dfn(n + 1);\n    DFS = [&amp;](int x) &#123;\n        static int now = 0;\n        dfn[x] = ++now, tab[now] = x;\n        ls[x] = 1;\n        if (son[x]) &#123;\n            top[son[x]] = top[x], DFS(son[x]);\n            bot[x] = bot[son[x]];\n            g[x][0] = a[x];\n            for (auto i : g1[x])\n                if (i != son[x] &amp;&amp; i != fa[x]) &#123;\n                    top[i] = i, DFS(i);\n                    ls[x] += siz[i];\n                    g[x][0] += f[i][0];\n                    g[x][1] += std::max(f[i][1], f[i][0]);\n                &#125;\n            f[x][0] = g[x][1] + std::max(f[son[x]][0], f[son[x]][1]);\n            f[x][1] = g[x][0] + f[son[x]][0];\n        &#125;\n        else\n            f[x][1] = g[x][0] = a[x], bot[x] = x;\n        if (x == top[x])\n            bld(rt[x], dfn[x], dfn[bot[x]]);\n        return;\n    &#125;;\n    top[1] = 1, DFS(1);\n    for (int x, v, la = 0; q--; ) &#123;\n        read(x), read(v), x ^= la;\n        g[x][0] -= a[x], g[x][0] += v, a[x] = v;\n        for (; top[x] != 1; ) &#123;\n            auto r = t[rt[top[x]]].u;\n            f[top[x]][0] = r[0][0], f[top[x]][1] = r[0][1];\n            g[fa[top[x]]][0] -= f[top[x]][0];\n            g[fa[top[x]]][1] -= std::max(f[top[x]][0], f[top[x]][1]);\n            add(rt[top[x]], dfn[x]);\n            r = t[rt[top[x]]].u;\n            f[top[x]][0] = r[0][0], f[top[x]][1] = r[0][1];\n            g[fa[top[x]]][0] += f[top[x]][0];\n            g[fa[top[x]]][1] += std::max(f[top[x]][0], f[top[x]][1]);\n            x = fa[top[x]];\n        &#125;\n        add(rt[1], dfn[x]);\n        auto r =  t[rt[1]].u;\n        f[1][0] = r[0][0], f[1][1] = r[0][1];\n        std::cout &lt;&lt; (la = std::max(f[1][0], f[1][1])) &lt;&lt; &#39;\\n&#39;;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"树上路径问题染色\">树上路径问题：染色</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P2486\" class=\"uri\">https://www.luogu.com.cn/problem/P2486</a></p>\n<p>GBT 上的<strong>路径问题</strong>。</p>\n<p>BST：首先暴力爬山到 LCA，统计一路上的答案；然后跳到当前 BST 的根。由于本题有标记，所以需要在跳的同时想办法把标记问题解决一下。</p>\n<p>线段树：把树剖的线段树略改一下就过了。从上一行模棱两可的描述就可以看出来 BST 实现起来不太轻松；还是线段树更轮椅啊！</p>\n<details>\n<p>跑得没纯树剖快，因为数据没有刻意构造导致树高很低，再加上常数的影响吧。</p>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 1e5 + 5;\nconst int LEN = (1 &lt;&lt; 20);\nint nec(void) &#123;\n    static char buf[LEN], *p = buf, *e = buf;\n    if (p == e) &#123;\n        e = buf + fread(buf, 1, LEN, stdin);\n        if (e == buf) return EOF;\n        p = buf;\n    &#125;\n    return *p++;\n&#125;\nbool read(int &amp;x) &#123;\n    x = 0;\n    bool f = 0;\n    char ch = nec();\n    while (ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123;\n        if (ch == EOF) return 0;\n        if (ch == &#39;-&#39;) f = 1;\n        ch = nec();\n    &#125;\n    while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) &#123;\n        x = x * 10 + ch - &#39;0&#39;;\n        ch = nec();\n    &#125;\n    if (f) x = -x;\n    return 1;\n&#125;\nvoid read(char &amp;x) &#123;\n    for (x = nec(); x != &#39;C&#39; &amp;&amp; x != &#39;Q&#39;; x = nec());\n    return;\n&#125;\nvoid print(int x) &#123;\n    if (x &lt; 0)\n        putchar(&#39;-&#39;), x = -x;\n    if (x &gt;= 10) print(x / 10);\n    putchar(x % 10 + &#39;0&#39;);\n    return;\n&#125;\nvoid print(int x, char ch) &#123;\n    print(x), putchar(ch);\n    return;\n&#125;\nclass node &#123;\nprivate:\n    int lt, rt;\npublic:\n    int l, r, mid, lc, rc, u, d;\n    node(): u(-1) &#123;&#125;\n    inline int&amp; ls(void) &#123; return lt; &#125;\n    inline int&amp; rs(void) &#123; return rt; &#125;\n    node&amp; operator= (const node &amp;q) &#123;\n        lc = q.lc, rc = q.rc, u = q.u;\n        return *this;\n    &#125;\n    node operator+ (const node &amp;q) const &#123;\n        if (u == -1)\n            return q;\n        if (q.u == -1)\n            return *this;\n        node res;\n        res.lc = lc, res.rc = q.rc, res.u = u + q.u - (rc == q.lc);\n        return res;\n    &#125;\n    inline void swap(void) &#123;\n        if (~u)\n            lc ^= rc ^= lc ^= rc;\n        return;\n    &#125;\n&#125; t[maxn &lt;&lt; 2]; \nint tab[maxn], ls[maxn], a[maxn];\n#define lt t[p].ls()\n#define rt t[p].rs()\nvoid bld(int &amp;p, int l, int r) &#123;\n    static int tot = 0;\n    p = ++tot, t[p].l = l, t[p].r = r;\n    if (l == r) &#123;\n        t[p].u = 1;\n        t[p].lc = t[p].rc = a[tab[l]];\n        return;\n    &#125;\n    int s = 0, u = ls[tab[l]];\n    for (int i = l; i &lt;= r; ++i)\n        s += ls[tab[i]];\n    s &gt;&gt;= 1;\n    t[p].mid = r - 1;\n    for (int i = l + 1; i &lt; r; ++i) &#123;\n        u += ls[tab[i]];\n        if (u + ls[tab[i + 1]] &gt; s) &#123;\n            t[p].mid = i;\n            break;\n        &#125;\n    &#125;\n    bld(lt, l, t[p].mid), bld(rt, t[p].mid + 1, r);\n    t[p] = t[lt] + t[rt];\n    return;\n&#125;\nvoid pushdown(int p) &#123;\n    if (t[p].d) &#123;\n        t[lt].d = t[lt].lc = t[lt].rc = t[rt].d = t[rt].lc = t[rt].rc = t[p].d;\n        t[lt].u = t[rt].u = 1;\n        t[p].d = 0;\n    &#125;\n    return;\n&#125;\nvoid add(int p, int l, int r, int v) &#123;\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r) &#123;\n        t[p].u = 1;\n        t[p].lc = t[p].rc = t[p].d = v;\n        return;\n    &#125;\n    pushdown(p);\n    if (l &lt;= t[p].mid)\n        add(lt, l, r, v);\n    if (r &gt; t[p].mid)\n        add(rt, l, r, v);\n    t[p] = t[lt] + t[rt];\n    return;\n&#125;\nnode ask(int p, int l, int r) &#123;\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r)\n        return t[p];\n    pushdown(p);\n    if (r &lt;= t[p].mid)\n        return ask(lt, l, r);\n    if (l &gt; t[p].mid)\n        return ask(rt, l, r);\n    return ask(lt, l, r) + ask(rt, l, r);\n&#125;\n#undef lt\n#undef rt\nint main() &#123;\n#ifdef ONLINE_JUDGE\n#else\n    std::freopen(&quot;paint17.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, q;\n    read(n), read(q);\n    std::vector&lt;int&gt; rt(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        read(a[i]);\n    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);\n    for (int i = 1, x, y; i &lt; n; ++i) &#123;\n        read(x), read(y);\n        g[x].push_back(y), g[y].push_back(x);\n    &#125;\n    std::vector&lt;int&gt; siz(n + 1), son(n + 1), fa(n + 1), dep(n + 1);\n    std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;\n        siz[x] = 1;\n        for (auto i : g[x])\n            if (i != fa[x]) &#123;\n                dep[i] = dep[x] + 1;\n                fa[i] = x, DFS(i);\n                siz[x] += siz[i];\n                if (siz[i] &gt; siz[son[x]])\n                    son[x] = i;\n            &#125;\n        return;\n    &#125;;\n    DFS(1);\n    std::vector&lt;std::array&lt;int, 2&gt; &gt; f(n + 1);\n    std::vector&lt;int&gt; top(n + 1), bot(n + 1), dfn(n + 1);\n    DFS = [&amp;](int x) &#123;\n        static int now = 0;\n        dfn[x] = ++now, tab[now] = x, ls[x] = 1;\n        if (son[x]) &#123;\n            top[son[x]] = top[x], DFS(son[x]);\n            bot[x] = bot[son[x]];\n        &#125;\n        else\n            bot[x] = x;\n        for (auto i : g[x])\n            if (i != son[x] &amp;&amp; i != fa[x]) &#123;\n                top[i] = i;\n                DFS(i);\n                ls[x] += siz[i];\n            &#125;\n        if (x == top[x])\n            bld(rt[x], dfn[x], dfn[bot[x]]);\n        return;\n    &#125;;\n    top[1] = 1, DFS(1);\n    for (char op; q--; ) &#123;\n        read(op);\n        if (op == &#39;C&#39;) &#123;\n            int x, y, c;\n            read(x), read(y), read(c);\n            for (; top[x] != top[y]; x = fa[top[x]]) &#123;\n                if (dep[top[x]] &lt; dep[top[y]])\n                    std::swap(x, y);\n                add(rt[top[x]], dfn[top[x]], dfn[x], c);\n            &#125;\n            if (dep[x] &gt; dep[y])\n                std::swap(x, y);\n            add(rt[top[x]], dfn[x], dfn[y], c);\n        &#125;\n        else &#123;\n            int x, y;\n            read(x), read(y);\n            node res1, res2;\n            for (; top[x] != top[y]; )\n                if (dep[top[x]] &lt; dep[top[y]]) &#123;\n                    res2 = ask(rt[top[y]], dfn[top[y]], dfn[y]) + res2;\n                    y = fa[top[y]];\n                &#125;\n                else &#123;\n                    res1 = ask(rt[top[x]], dfn[top[x]], dfn[x]) + res1;\n                    x = fa[top[x]];\n                &#125;\n            if (dep[x] &gt; dep[y])\n                res1 = ask(rt[top[y]], dfn[y], dfn[x]) + res1;\n            else\n                res2 = ask(rt[top[x]], dfn[x], dfn[y]) + res2;\n            res1.swap();\n            print((res1 + res2).u, &#39;\\n&#39;);\n        &#125;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"树上路径查询\">树上路径查询？</h3>\n<p>做题的时候可以感受到，路径询问的存在很诡异，因为只需要一条链的操作，更偏向链上 DDP 而非树上的；<strong>轻儿子的信息是不用维护的</strong>，形式上更像树剖（DS）；当成链上的 DDP 就可以解决了。</p>\n<p>可以用倍增维护 DDP（不用考虑轻重儿子，只用维护父子关系，进一步向序列 DDP 靠近），就不用打 GBT 了，常数也会小一些。</p>\n<hr />\n<h2 id=\"习题\">习题</h2>\n<p>GBT 就统一用线段树了。DDP 也就可以顺带用 GBT 优化了。</p>\n<hr />\n<h3 id=\"e---猫或狗-cats-or-dogs\">E - 猫或狗 / Cats or Dogs</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P9597\" class=\"uri\">https://www.luogu.com.cn/problem/P9597</a></p>\n<p>设 <span class=\"math inline\">\\(f_{u,0/1}\\)</span> 表示从根上颜色为 <span class=\"math inline\">\\(0/1\\)</span> 时的最小断边数，显然无色可以视作任选一个颜色。那么有：</p>\n<p><span class=\"math display\">\\[\nf_{u,a}=\\sum\\limits_v\\min\\limits_{b\\in\\{0,1\\}}\\{f_{v,b}+[a\\ne b]\\}\n\\]</span></p>\n<p>直接把轻儿子的项提出来，记 <span class=\"math inline\">\\(g_{u,0/1}\\)</span> 表示 <span class=\"math inline\">\\(f_{u,0/1}\\)</span> 对应的轻儿子贡献即可。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 1e5 + 5;\nconst int inf = 0x3f3f3f3f;\nstruct mat &#123;\n    int a[2][2];\n    int* operator[] (const int q) &#123; \n        return a[q];\n    &#125;\n    mat operator* (mat &amp;q) const &#123;\n        mat res;\n        res[0][0] = res[0][1] = res[1][0] = res[1][1] = inf;\n        for (int i = 0; i &lt; 2; ++i)\n            for (int k = 0; k &lt; 2; ++k)\n                for (int j = 0; j &lt; 2; ++j)\n                    res[i][k] = std::min(res[i][k], a[i][j] + q[j][k]);\n        return res;\n    &#125;\n    mat&amp; operator*= (mat &amp;q) &#123;\n        return *this = *this * q;\n    &#125;\n&#125; p[maxn];\nstruct &#123; int lc, rc, l, r, mid; mat u; &#125; t[maxn &lt;&lt; 2]; \nint ls[maxn], tab[maxn], g[maxn][2], rt[maxn], top[maxn], dfn[maxn], fa[maxn];\nstd::vector&lt;int&gt; a;\n#define lt t[p].lc\n#define rt t[p].rc\nvoid bld(int &amp;p, int l, int r) &#123;\n    static int tot = 0;\n    p = ++tot, t[p].l = l, t[p].r = r;\n    if (l == r) &#123;\n        t[p].u[0][1] = t[p].u[1][0] = 1;\n        return;\n    &#125;\n    int s = 0, u = ls[tab[l]];\n    for (int i = l; i &lt;= r; ++i)\n        s += ls[tab[i]];\n    s &gt;&gt;= 1;\n    t[p].mid = r - 1;\n    for (int i = l + 1; i &lt; r; ++i) &#123;\n        u += ls[tab[i]];\n        if (u + ls[tab[i + 1]] &gt; s) &#123;\n            t[p].mid = i;\n            break;\n        &#125;\n    &#125;\n    bld(lt, l, t[p].mid), bld(rt, t[p].mid + 1, r);\n    t[p].u = t[rt].u * t[lt].u;\n    return;\n&#125;\nvoid add(int p, int x) &#123;\n    if (t[p].l == t[p].r) &#123;\n        int u = tab[x], g0 = (a[u] == 1 ? inf : g[u][0]), g1 = (a[u] == 0 ? inf : g[u][1]);\n        t[p].u[0][0] = g0, t[p].u[0][1] = g1 + 1;\n        t[p].u[1][0] = g0 + 1, t[p].u[1][1] = g1;\n        return;\n    &#125;\n    if (x &lt;= t[p].mid)\n        add(lt, x);\n    else\n        add(rt, x);\n    t[p].u = t[rt].u * t[lt].u;\n    return;\n&#125;\n#undef lt\n#undef rt\nvoid initialize(int n, std::vector&lt;int&gt; A, std::vector&lt;int&gt; B) &#123;\n    a.assign(n + 1, -1);\n    std::vector&lt;std::vector&lt;int&gt; &gt; g1(n + 1);\n    for (int i = 0; i &lt; n - 1; ++i)\n        g1[A[i]].push_back(B[i]), g1[B[i]].push_back(A[i]);\n    std::vector&lt;int&gt; siz(n + 1), son(n + 1);\n    std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;\n        siz[x] = 1;\n        for (auto i : g1[x])\n            if (i != fa[x]) &#123;\n                fa[i] = x, DFS(i);\n                siz[x] += siz[i];\n                if (siz[i] &gt; siz[son[x]])\n                    son[x] = i;\n            &#125;\n        return;\n    &#125;;\n    DFS(1);\n    std::vector&lt;int&gt; bot(n + 1);\n    DFS = [&amp;](int x) &#123;\n        static int now = 0;\n        dfn[x] = ++now, tab[now] = x, ls[x] = 1;\n        if (son[x]) &#123;\n            top[son[x]] = top[x], DFS(son[x]);\n            bot[x] = bot[son[x]];\n            for (auto i : g1[x])\n                if (i != son[x] &amp;&amp; i != fa[x]) &#123;\n                    top[i] = i, DFS(i);\n                    ls[x] += siz[i];\n                &#125;\n        &#125;\n        else\n            bot[x] = x;\n        if (x == top[x])\n            bld(rt[x], dfn[x], dfn[bot[x]]);\n        return;\n    &#125;;\n    top[1] = 1, DFS(1);\n    return;\n&#125;\nint upd(int x) &#123;\n    for (; top[x] != 1; ) &#123;\n        int faa = fa[top[x]];\n        auto &amp;id = t[rt[top[x]]].u;\n        int f0 = std::min(id[0][0], id[1][0]), f1 = std::min(id[0][1], id[1][1]);\n        g[faa][0] -= std::min(f0, f1 + 1);\n        g[faa][1] -= std::min(f0 + 1, f1);\n        add(rt[top[x]], dfn[x]);\n        f0 = std::min(id[0][0], id[1][0]), f1 = std::min(id[0][1], id[1][1]);\n        // printf(&quot;%d: f0 = %d, f1 = %d\\n&quot;, top[x], f0, f1);\n        g[faa][0] += std::min(f0, f1 + 1);\n        g[faa][1] += std::min(f0 + 1, f1);\n        x = faa;\n    &#125;\n    add(rt[1], dfn[x]);\n    auto &amp;id = t[rt[1]].u;\n    int f0 = std::min(id[0][0], id[1][0]), f1 = std::min(id[0][1], id[1][1]);\n    // printf(&quot;%d: f0 = %d, f1 = %d\\n&quot;, 1, f0, f1);\n    return std::min(f0, f1);\n&#125;\nint cat(int x) &#123;\n    a[x] = 0;\n    return upd(x);\n&#125;\nint dog(int x) &#123;\n    a[x] = 1;\n    return upd(x);\n&#125;\nint neighbor(int x) &#123;\n    a[x] = -1;\n    return upd(x);\n&#125;\n#ifndef ONLINE_JUDGE\nint main() &#123;\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;int&gt; A(n - 1), B(n - 1);\n    for (int i = 0; i &lt; n - 1; ++i)\n        std::cin &gt;&gt; A[i] &gt;&gt; B[i];\n    initialize(n, A, B);\n    int q;\n    std::cin &gt;&gt; q;\n    for (int op, x; q--; ) &#123;\n        std::cin &gt;&gt; op &gt;&gt; x;\n        std::cout &lt;&lt; (op == 1 ? cat(x) : (op == 2 ? dog(x) : neighbor(x))) &lt;&lt; &#39;\\n&#39;;\n    &#125;\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n    return 0;\n&#125;\n#endif</code></pre>\n</details>\n<hr />\n<h3 id=\"f---hash-on-tree\">F - Hash on Tree</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/AT_abc351_g\" class=\"uri\">https://www.luogu.com.cn/problem/AT_abc351_g</a></p>\n<p>记 <span class=\"math inline\">\\(g_x\\)</span> 为轻儿子的哈希值之积，则 <span class=\"math inline\">\\(f_u=A_u+f_{son}\\cdot g_u\\)</span>。</p>\n<p>然后开一个常数维即可。快速幂的 log 省不掉，所以是双 log 的。</p>\n<p>初值和修改都有可能为 <span class=\"math inline\">\\(0\\)</span>，需要维护实际哈希值和去掉 <span class=\"math inline\">\\(0\\)</span> 的哈希值。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 1e6 + 5;\nconst int LEN = (1 &lt;&lt; 20);\nconst int mod = 998244353;\nint nec(void) &#123;\n    static char buf[LEN], *p = buf, *e = buf;\n    if (p == e) &#123;\n        e = buf + fread(buf, 1, LEN, stdin);\n        if (e == buf) return EOF;\n        p = buf;\n    &#125;\n    return *p++;\n&#125;\nbool read(int &amp;x) &#123;\n    x = 0;\n    bool f = 0;\n    char ch = nec();\n    while (ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123;\n        if (ch == EOF) return 0;\n        if (ch == &#39;-&#39;) f = 1;\n        ch = nec();\n    &#125;\n    while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) &#123;\n        x = x * 10 + ch - &#39;0&#39;;\n        ch = nec();\n    &#125;\n    if (f) x = -x;\n    return 1;\n&#125;\nvoid print(int x) &#123;\n    if (x &lt; 0)\n        putchar(&#39;-&#39;), x = -x;\n    if (x &gt;= 10) print(x / 10);\n    putchar(x % 10 + &#39;0&#39;);\n    return;\n&#125;\nvoid print(int x, char ch) &#123;\n    print(x), putchar(ch);\n    return;\n&#125;\nstruct mat &#123;\n    int n, m;\n    long long a[2][2];\n    long long* operator[] (const int q) &#123;\n        return a[q];\n    &#125;\n    mat operator* (mat &amp;q) const &#123;\n        mat res;\n        res.n = n, res.m = q.m;\n        res[0][0] = res[0][1] = res[1][0] = res[1][1] = 0ll;\n        for (int i = 0; i &lt; n; ++i)\n            for (int k = 0; k &lt; q.m; ++k) &#123;\n                for (int j = 0; j &lt; m; ++j)\n                    res[i][k] += a[i][j] * q[j][k];\n                res[i][k] %= mod;\n            &#125;\n        return res;\n    &#125;\n    mat&amp; operator*= (mat &amp;q) &#123;\n        return *this = *this * q;\n    &#125;\n&#125;;\nstruct &#123; int lc, rc, l, r, mid; mat u; &#125; t[maxn &lt;&lt; 2]; \nlong long g[maxn];\nint tab[maxn], ls[maxn], a[maxn];\n#define lt t[p].lc\n#define rt t[p].rc\nvoid bld(int &amp;p, int l, int r) &#123;\n    static int tot = 0;\n    p = ++tot, t[p].l = l, t[p].r = r;\n    if (l == r) &#123;\n        int u = tab[l];\n        t[p].u.n = t[p].u.m = 2;\n        t[p].u[0][0] = g[u];\n        t[p].u[0][1] = 0ll;\n        t[p].u[1][0] = a[u];\n        t[p].u[1][1] = 1ll;\n        return;\n    &#125;\n    int s = 0, u = ls[tab[l]];\n    for (int i = l; i &lt;= r; ++i)\n        s += ls[tab[i]];\n    s &gt;&gt;= 1;\n    t[p].mid = r - 1;\n    for (int i = l + 1; i &lt; r; ++i) &#123;\n        u += ls[tab[i]];\n        if (u + ls[tab[i + 1]] &gt; s) &#123;\n            t[p].mid = i;\n            break;\n        &#125;\n    &#125;\n    bld(lt, l, t[p].mid), bld(rt, t[p].mid + 1, r);\n    t[p].u = t[rt].u * t[lt].u;\n    return;\n&#125;\nvoid add(int p, int x) &#123;\n    if (t[p].l == t[p].r) &#123;\n        int u = tab[x];\n        t[p].u[0][0] = g[u];\n        t[p].u[1][0] = a[u];\n        return;\n    &#125;\n    if (x &lt;= t[p].mid)\n        add(lt, x);\n    else\n        add(rt, x);\n    t[p].u = t[rt].u * t[lt].u;\n    return;\n&#125;\n#undef lt\n#undef rt\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, q;\n    read(n), read(q);\n    std::vector&lt;int&gt; rt(n + 1);\n    std::vector&lt;std::vector&lt;int&gt; &gt; g1(n + 1);\n    for (int i = 2, x; i &lt;= n; ++i) &#123;\n        read(x);\n        g1[i].push_back(x), g1[x].push_back(i);\n    &#125;\n    for (int i = 1; i &lt;= n; ++i)\n        read(a[i]);\n    std::vector&lt;int&gt; siz(n + 1), son(n + 1), fa(n + 1);\n    std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;\n        siz[x] = 1;\n        for (auto i : g1[x])\n            if (i != fa[x]) &#123;\n                fa[i] = x, DFS(i);\n                siz[x] += siz[i];\n                if (siz[i] &gt; siz[son[x]])\n                    son[x] = i;\n            &#125;\n        return;\n    &#125;;\n    DFS(1);\n    std::vector&lt;long long&gt; f(n + 1);\n    std::vector&lt;int&gt; top(n + 1), bot(n + 1), dfn(n + 1), la(n + 1), cnt(n + 1);\n    DFS = [&amp;](int x) &#123;\n        static int now = 0;\n        dfn[x] = ++now, tab[now] = x, ls[x] = 1;\n        if (son[x]) &#123;\n            top[son[x]] = top[x], DFS(son[x]);\n            bot[x] = bot[son[x]];\n            g[x] = 1ll;\n            for (auto i : g1[x])\n                if (i != son[x] &amp;&amp; i != fa[x]) &#123;\n                    top[i] = i, DFS(i);\n                    ls[x] += siz[i];\n                    if (f[i] == 0ll)\n                        ++cnt[x];\n                    else\n                        (la[x] *= f[i]) %= mod;\n                    (g[x] *= f[i]) %= mod;\n                &#125;\n            f[x] = (a[x] + g[x] * f[son[x]]) % mod;\n        &#125;\n        else\n            f[x] = a[x], bot[x] = x;\n        // printf(&quot;f[%d] = %lld\\n&quot;, x, f[x]);\n        if (x == top[x])\n            bld(rt[x], dfn[x], dfn[bot[x]]);\n        return;\n    &#125;;\n    top[1] = 1, DFS(1);\n    mat init;\n    init.n = 1, init.m = 2;\n    init[0][0] = 0ll, init[0][1] = 1ll;\n    auto qkp = [&amp;](long long x, int y) &#123;\n        auto res(1ll);\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    auto inv = [&amp;](int x) &#123;\n        return qkp(x, mod - 2);\n    &#125;;\n    for (int x, v; q--; ) &#123;\n        read(x), read(v);\n        a[x] = v;\n        for (; top[x] != 1; ) &#123;\n            int faa = fa[top[x]];\n            auto &amp;id = t[rt[top[x]]].u;\n            int f = (init * id)[0][0];\n            if (f == 0) &#123;\n                if (--cnt[faa] == 0)\n                    g[faa] = la[faa];\n            &#125;\n            else &#123;\n                f = inv(f);\n                (g[faa] *= f) %= mod;\n                (la[faa] *= f) %= mod;\n            &#125;\n            add(rt[top[x]], dfn[x]);\n            f = (init * id)[0][0];\n            if (f == 0) &#123;\n                if (cnt[faa]++ == 0)\n                    la[faa] = g[faa];\n                g[faa] = 0ll;\n            &#125;\n            else &#123;\n                (g[faa] *= f) %= mod;\n                (la[faa] *= f) %= mod;\n            &#125;\n            x = faa;\n        &#125;\n        add(rt[1], dfn[x]);\n        auto &amp;id = t[rt[1]].u;\n        int f = (init * id)[0][0];\n        std::cout &lt;&lt; f &lt;&lt; &#39;\\n&#39;;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"g---考试-2\">G - 考试 2</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P10626\" class=\"uri\">https://www.luogu.com.cn/problem/P10626</a></p>\n<p>运算均是线性的，容易想到『按位』维护，即只维护某个特定点值。如果将询问离线下来排序，每个函数的点值只会变化 <span class=\"math inline\">\\(O(1)\\)</span> 次。</p>\n<p>建出符号二叉树，进行 DDP 即可。具体地，令 <span class=\"math inline\">\\(f_u\\)</span> 表示在运算 <span class=\"math inline\">\\(u\\)</span> 处的答案，计算 <span class=\"math inline\">\\(g_u\\)</span> 为轻儿子的答案，按照 <span class=\"math inline\">\\(u\\)</span> 处的符号写矩阵即可。叶子不是一次运算，应该直接填入点值（注意线段树上的叶子不一定是原树上的叶子）。</p>\n<p>建树和矩阵更新有点史，适当封装一下感觉会好一点</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 1e6 + 5;\nconst char mp[] = &quot;x!&amp;|^&quot;;\nconst int LEN = (1 &lt;&lt; 20);\n#define nec getchar\ninline bool read(int &amp;x) &#123;\n    x = 0;\n    bool f = 0;\n    char ch = nec();\n    while (ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123;\n        if (ch == EOF) return 0;\n        if (ch == &#39;-&#39;) f = 1;\n        ch = nec();\n    &#125;\n    while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) &#123;\n        x = x * 10 + ch - &#39;0&#39;;\n        ch = nec();\n    &#125;\n    if (f) x = -x;\n    return 1;\n&#125;\nvoid print(int x) &#123;\n    if (x &lt; 0)\n        putchar(&#39;-&#39;), x = -x;\n    if (x &gt;= 10) print(x / 10);\n    putchar(x % 10 + &#39;0&#39;);\n    return;\n&#125;\nvoid print(int x, char ch) &#123;\n    print(x), putchar(ch);\n    return;\n&#125;\nstruct mat &#123;\n    int n, m;\n    int a[2][2];\n    int* operator[] (const int q) &#123;\n        return a[q];\n    &#125;\n    inline mat operator* (mat &amp;q) const &#123;\n        mat res;\n        res.n = n, res.m = q.m;\n        res[0][0] = res[0][1] = res[1][0] = res[1][1] = 0ll;\n        for (int i = 0; i &lt; n; ++i)\n            for (int k = 0; k &lt; q.m; ++k)\n                for (int j = 0; j &lt; m; ++j)\n                    res[i][k] += a[i][j] * q[j][k];\n        return res;\n    &#125;\n    mat&amp; operator*= (mat &amp;q) &#123;\n        return *this = *this * q;\n    &#125;\n&#125;;\nstruct &#123; int lc, rc, l, r, mid; mat u; &#125; t[maxn &lt;&lt; 2]; \nint g1[maxn][2];\nint g[maxn], ty[maxn];\nint tab[maxn], ls[maxn], lim[maxn];\n#define lt t[p].lc\n#define rt t[p].rc\nvoid fillmat(mat &amp;a, int op, int g) &#123;\n    if (op == 0) &#123;\n        a.n = 1, a.m = 2;\n        a[0][!g] = 0, a[0][g] = 1;\n        return;\n    &#125;\n    a.n = 2, a.m = 2;\n    switch (op) &#123;\n    case 1: // !\n        a[0][0] = 0, a[0][1] = 1;\n        a[1][0] = 1, a[1][1] = 0;\n        break;\n    case 2: // &amp;\n        a[0][0] = 1, a[0][1] = 0;\n        a[1][0] = !g, a[1][1] = g;\n        break;\n    case 3: // |\n        a[0][0] = !g, a[0][1] = g;\n        a[1][0] = 0, a[1][1] = 1;\n        break;\n    case 4: // ^\n        a[0][0] = !g, a[0][1] = g;\n        a[1][0] = g, a[1][1] = !g;\n        break;\n    default:\n        assert(0);\n    &#125;\n    return;\n&#125;\nvoid bld(int &amp;p, int l, int r) &#123;\n    static int tot = 0;\n    p = ++tot, t[p].l = l, t[p].r = r;\n    if (l == r) &#123;\n        fillmat(t[p].u, ty[tab[l]], g[tab[l]]);\n        return;\n    &#125;\n    int s = 0, u = ls[tab[l]];\n    for (int i = l; i &lt;= r; ++i)\n        s += ls[tab[i]];\n    s &gt;&gt;= 1;\n    t[p].mid = r - 1;\n    for (int i = l + 1; i &lt; r; ++i) &#123;\n        u += ls[tab[i]];\n        if (u + ls[tab[i + 1]] &gt; s) &#123;\n            t[p].mid = i;\n            break;\n        &#125;\n    &#125;\n    bld(lt, l, t[p].mid), bld(rt, t[p].mid + 1, r);\n    t[p].u = t[rt].u * t[lt].u;\n    return;\n&#125;\nvoid add(int p, int x) &#123;\n    if (t[p].l == t[p].r) &#123;\n        fillmat(t[p].u, ty[tab[t[p].l]], g[tab[t[p].l]]);\n        return;\n    &#125;\n    if (x &lt;= t[p].mid)\n        add(lt, x);\n    else\n        add(rt, x);\n    t[p].u = t[rt].u * t[lt].u;\n    return;\n&#125;\n#undef lt\n#undef rt\nint main() &#123;\n#ifndef ONLINE_JUDGE\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n = 0, q, p;\n    read(q), read(q);\n    &#123;\n        std::string s;\n        std::cin &gt;&gt; s;\n        std::stringstream in(s);\n        std::stack&lt;char&gt; op;\n        std::stack&lt;int&gt; id;\n        auto trans = [&amp;](char t) &#123;\n            switch (t) &#123;\n            case &#39;!&#39;:\n                return 1;\n            case &#39;&amp;&#39;:\n                return 2;\n            case &#39;|&#39;:\n                return 3;\n            case &#39;^&#39;:\n                return 4;\n            &#125;\n            assert(0);\n            return -1;\n        &#125;;\n        auto calcNot = [&amp;](void) &#123;\n            for (; !op.empty() &amp;&amp; op.top() == &#39;!&#39;; ) &#123;\n                ty[++n] = trans(op.top());\n                g1[n][0] = id.top(), id.pop(), id.push(n);\n                op.pop();\n            &#125;\n            return;\n        &#125;;\n        auto opt = [&amp;](void) &#123;\n            ty[++n] = trans(op.top());\n            g1[n][0] = id.top(), id.pop();\n            g1[n][1] = id.top(), id.pop();\n            id.push(n), op.pop();\n            return;\n        &#125;;\n        for (char t; in &gt;&gt; t; )\n            if (t == &#39;[&#39;) &#123;\n                int x;\n                in &gt;&gt; x, in &gt;&gt; t;\n                lim[++n] = x - 1;\n                id.push(n), calcNot();\n            &#125;\n            else if (t == &#39;(&#39;)\n                op.push(t);\n            else if (t == &#39;)&#39;) &#123;\n                for (; op.top() != &#39;(&#39;; opt());\n                op.pop(), calcNot();\n            &#125;\n            else if (t == &#39;&amp;&#39;)\n                op.push(t);\n            else if (t == &#39;^&#39;) &#123;\n                for (; !op.empty() &amp;&amp; op.top() == &#39;&amp;&#39;; opt());\n                op.push(t);\n            &#125;\n            else if (t == &#39;|&#39;) &#123;\n                for (; !op.empty() &amp;&amp; (op.top() == &#39;&amp;&#39; || op.top() == &#39;^&#39;); opt());\n                op.push(t);\n            &#125;\n            else &#123;\n                assert(t == &#39;!&#39;);\n                op.push(t);\n            &#125;\n        for (; !op.empty(); opt());\n        p = id.top();\n    &#125;\n    std::vector&lt;int&gt; rt(n + 1);\n    std::vector&lt;int&gt; siz(n + 1), son(n + 1), fa(n + 1);\n    std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;\n        siz[x] = 1;\n        for (auto i : g1[x])\n            if (i != 0) &#123;\n                fa[i] = x, DFS(i);\n                siz[x] += siz[i];\n                if (siz[i] &gt; siz[son[x]])\n                    son[x] = i;\n            &#125;\n        return;\n    &#125;;\n    DFS(p);\n    std::vector&lt;long long&gt; f(n + 1);\n    std::vector&lt;int&gt; top(n + 1), bot(n + 1), dfn(n + 1);\n    DFS = [&amp;](int x) &#123;\n        static int now = 0;\n        dfn[x] = ++now, tab[now] = x, ls[x] = 1;\n        if (son[x]) &#123;\n            top[son[x]] = top[x], DFS(son[x]);\n            bot[x] = bot[son[x]];\n            for (auto i : g1[x])\n                if (i != son[x] &amp;&amp; i != 0) &#123;\n                    top[i] = i, DFS(i);\n                    ls[x] += siz[i], g[x] = f[i];\n                &#125;\n            switch (ty[x]) &#123;\n            case 1:\n                f[x] = !f[son[x]];\n                break;\n            case 2:\n                f[x] = g[x] &amp; f[son[x]];\n                break;\n            case 3:\n                f[x] = g[x] | f[son[x]];\n                break;\n            case 4:\n                f[x] = g[x] ^ f[son[x]];\n                break;\n            default:\n                assert(0);\n                break;\n            &#125;\n        &#125;\n        else\n            assert(!ty[x]), f[x] = g[x] = 0, bot[x] = x;\n        if (x == top[x])\n            bld(rt[x], dfn[x], dfn[bot[x]]);\n        return;\n    &#125;;\n    top[p] = p, DFS(p);\n    std::vector&lt;int&gt; a(q + 1), res(q + 1);\n    for (int i = 1; i &lt;= q; ++i)\n        read(a[i]);\n    std::vector&lt;int&gt; qid(q), nid;\n    for (int i = 1; i &lt;= n; ++i)\n        if (ty[i] == 0)\n            nid.push_back(i);\n    std::iota(qid.begin(), qid.end(), 1);\n    std::sort(qid.begin(), qid.end(), [&amp;](int x, int y) &#123; return a[x] &lt; a[y]; &#125;);\n    std::sort(nid.begin(), nid.end(), [&amp;](int x, int y) &#123; return lim[x] &gt; lim[y]; &#125;);\n    for (auto i : qid) &#123;\n        for (; !nid.empty() &amp;&amp; lim[nid.back()] &lt; a[i]; ) &#123;\n            int x = nid.back();\n            nid.pop_back();\n            g[x] = 1;\n            for (; top[x] != p; ) &#123;\n                add(rt[top[x]], dfn[x]);\n                g[fa[top[x]]] = t[rt[top[x]]].u[0][1];\n                x = fa[top[x]];\n            &#125;\n            add(rt[p], dfn[x]);\n        &#125;\n        res[i] = t[rt[p]].u[0][1];\n    &#125;\n    for (int i = 1; i &lt;= q; ++i)\n        if (res[i])\n            std::cout &lt;&lt; &quot;True\\n&quot;;\n        else\n            std::cout &lt;&lt; &quot;False\\n&quot;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n",
            "tags": [
                "线段树",
                "树链剖分",
                "DDP"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20250524/",
            "url": "https://xsc062.netlify.app/20250524/",
            "title": "周考",
            "date_published": "2025-05-24T06:29:44.000Z",
            "content_html": "<p>并非周考。</p>\n<span id=\"more\"></span>\n<hr />\n<h2 id=\"b---carousel-of-combinations\">B - Carousel of Combinations</h2>\n<p><a href=\"https://codeforces.com/problemset/problem/1957/E\" class=\"uri\">https://codeforces.com/problemset/problem/1957/E</a></p>\n<blockquote>\n<p><span class=\"math inline\">\\(q\\)</span> 次询问，每次给定一个 <span class=\"math inline\">\\(n\\)</span>，求：</p>\n<p><span class=\"math display\">\\[\n\\left(\\sum\\limits_{i=1}^n\\sum\\limits_{j=1}^i \\dfrac {i!}{(i-j)!\\cdot j!}\\bmod j\\right) \\bmod 10^9+7\n\\]</span></p>\n<p><span class=\"math inline\">\\(n,q\\le 10^6\\)</span>。</p>\n</blockquote>\n<p>赛时打表 <span class=\"math inline\">\\(\\dfrac {i!}{(i-j)!\\cdot j!}\\bmod j\\)</span> 易发现只有 <span class=\"math inline\">\\(j=4\\)</span> 或 <span class=\"math inline\">\\(j\\)</span> 为质数的列上有值；且仅当 <span class=\"math inline\">\\(\\left\\lfloor \\dfrac ij\\right\\rfloor\\)</span> 发生变化时，<span class=\"math inline\">\\((i,j)\\)</span> 的值不同。</p>\n<p>于是乎埃筛找每个 <span class=\"math inline\">\\(j\\)</span> 的倍数，由于每个值会持续一段 <span class=\"math inline\">\\(i\\)</span> 上的区间，考虑维护差分数组。前缀和得到原数组，再前缀和就能得到答案。</p>\n<details>\n<p><summary>证明</summary></p>\n<p>考虑转化为组合数形式方便证明。当 <span class=\"math inline\">\\(j\\)</span> 为质数时：</p>\n<p><span class=\"math display\">\\[\n\\begin{aligned}\n\\dfrac {i!}{(i-j)!\\cdot j!}\\bmod j\n&amp;=C_i^j\\cdot (j-1)!\\bmod j\\\\\n&amp;=C_{i\\bmod j}^{j\\bmod j}\\cdot C_{\\lfloor \\frac ij\\rfloor}^{\\frac jj}\\cdot (j-1)!\\bmod j\\\\\n&amp;=\\left\\lfloor \\frac ij\\right\\rfloor\\cdot (j-1)!\\bmod j\\\\\n&amp;=\\left\\lfloor \\frac ij\\right\\rfloor\\cdot (j-1)\\bmod j\n\\end{aligned}\n\\]</span></p>\n<p>当 <span class=\"math inline\">\\(j\\)</span> 为合数时：</p>\n<p><span class=\"math display\">\\[\n\\dfrac {i!}{(i-j)!\\cdot j!}\\bmod j=\\left\\lfloor \\frac ij\\right\\rfloor\\cdot (j-1)!\\bmod j\n\\]</span></p>\n<ul>\n<li><p>当 <span class=\"math inline\">\\(j=p^2\\)</span>，其中 <span class=\"math inline\">\\(p\\)</span> 为质数时：</p>\n<ul>\n<li>当 <span class=\"math inline\">\\(j\\ne 4\\)</span> 时，<span class=\"math inline\">\\(\\dfrac jp \\ge 3\\)</span>，代表在 <span class=\"math inline\">\\(1\\sim j-1\\)</span> 中至少出现了两个 <span class=\"math inline\">\\(p\\)</span> 的倍数，即 <span class=\"math inline\">\\((j-1)\\bmod j = 0\\)</span>。</li>\n<li>否则，原式转化为 <span class=\"math inline\">\\(2\\cdot \\left\\lfloor \\frac i4\\right\\rfloor\\bmod 4\\)</span>。</li>\n</ul></li>\n<li><p>否则：可以找到至少一组 <span class=\"math inline\">\\(j=i\\cdot k\\)</span> 满足 <span class=\"math inline\">\\(i\\ne k\\)</span>，则 <span class=\"math inline\">\\(i,k\\)</span> 出现在 <span class=\"math inline\">\\(1\\sim j-1\\)</span> 中，即 <span class=\"math inline\">\\((j-1)\\bmod j = 0\\)</span>。</p></li>\n</ul>\n<p>得到上述结论。</p>\n<p>Tips：</p>\n<ul>\n<li>卢卡斯定理：懒得写了。</li>\n<li>威尔逊定理：对于质数 <span class=\"math inline\">\\(p\\)</span>，<span class=\"math inline\">\\((p-1)!\\equiv -1\\pmod p\\)</span>。</li>\n</ul>\n</details>\n<hr />\n<h2 id=\"c---玻利维亚-bolivija\">C - 玻利维亚 / Bolivija</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P12401\" class=\"uri\">https://www.luogu.com.cn/problem/P12401</a></p>\n<blockquote>\n<p>给定若干次区间的插入与删除操作，对于所有值域内未被覆盖极长段 <span class=\"math inline\">\\(i\\)</span>，令 <span class=\"math inline\">\\(len_i\\)</span> 为其长度；每次操作后询问 <span class=\"math inline\">\\(\\sum \\frac {len_i\\cdot (len_i-1)}2+len_i\\)</span>。</p>\n</blockquote>\n<p>来一点新奇的思路。假如你和我一样，很不幸地不知道维护最小值这个 trick，怎么解决这道题？</p>\n<p>容易想到线段树维护节点内贡献和左侧、右侧极长未覆盖长度。加入区间是简单的：对于线段树上被完全覆盖的节点，更新其贡献为 <span class=\"math inline\">\\(0\\)</span>。依次 <code>pushup</code> 即可。</p>\n<p>删除区间，对于被这段区间完全覆盖的节点，发现如果整体被覆盖次数减少 <span class=\"math inline\">\\(1\\)</span>，有可能出现新的、未被覆盖的点，如果暴力 check 左右儿子是否出现了这样的点并更新，复杂度就不太美观了。</p>\n<p>故而对于一个节点，<strong>将『完全覆盖它的区间』和『部分覆盖它的区间』分开考虑</strong>，在维护该节点所有实时信息（记为 <span class=\"math inline\">\\(s\\)</span>）的同时，<strong>维护另一份只考虑了『部分覆盖它地区间』的信息（记为 <span class=\"math inline\">\\(s&#39;\\)</span>）</strong>：</p>\n<ul>\n<li><p>如果一个『部分覆盖它的区间』被删除：</p>\n<ul>\n<li>如果存在『完全覆盖它的区间』：<span class=\"math inline\">\\(s\\)</span> 不变；向下修改儿子的 <span class=\"math inline\">\\(s\\)</span>，<span class=\"math inline\">\\(s&#39;\\)</span> 需要从儿子的 <span class=\"math inline\">\\(s\\)</span> 更新。</li>\n</ul></li>\n<li><p>如果一个『完全覆盖它的区间』被删除：</p>\n<ul>\n<li>如果还存在其他『完全覆盖它的区间』：<span class=\"math inline\">\\(s,s&#39;\\)</span> 都不变。</li>\n<li>如果不存在其他『完全覆盖它的区间』：用 <span class=\"math inline\">\\(s&#39;\\)</span> 更新 <span class=\"math inline\">\\(s\\)</span>。</li>\n</ul></li>\n</ul>\n<p>这样就能 <span class=\"math inline\">\\(O(q\\log V)\\)</span> 解决上述问题。本方法较维护最小值的优势在于——似乎没有。想了许多种情况，它们大抵是等价的——且本方法更难写（哭）。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 654205;\nstruct &#123;\n    int cnt;\n    long long u, s;\n    int l, r, lu, ru, ls, rs;\n&#125; t[maxn &lt;&lt; 2];\n#define lt (p &lt;&lt; 1)\n#define rt (lt | 1)\n#define len(p) (t[p].r - t[p].l + 1)\nvoid pushup(int p) &#123;\n    t[p].s = t[lt].u + t[rt].u + (long long)t[lt].ru * t[rt].lu;\n    if (t[lt].lu == len(lt))\n        t[p].ls = len(lt) + t[rt].lu;\n    else\n        t[p].ls = t[lt].lu;\n    if (t[rt].ru == len(rt))\n        t[p].rs = t[lt].ru + len(rt);\n    else\n        t[p].rs = t[rt].ru;\n    if (!t[p].cnt)\n        t[p].u = t[p].s, t[p].lu = t[p].ls, t[p].ru = t[p].rs;\n    return;\n&#125;\nvoid bld(int p, int l, int r) &#123;\n    t[p].l = l, t[p].r = r;\n    if (l == r) &#123;\n        t[p].u = t[p].s = 1ll;\n        t[p].lu = t[p].ru = t[p].ls = t[p].rs = 1;\n        return;\n    &#125;\n    int mid = (l + r) &gt;&gt; 1;\n    bld(lt, l, mid), bld(rt, mid + 1, r);\n    pushup(p);\n    return;\n&#125;\nvoid add(int p, int l, int r) &#123;\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r) &#123;\n        ++t[p].cnt, t[p].u = 0ll, t[p].lu = t[p].ru = 0;\n        return;\n    &#125;\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (l &lt;= mid)\n        add(lt, l, r);\n    if (r &gt; mid)\n        add(rt, l, r);\n    pushup(p);\n    return;\n&#125;\nvoid rem(int p, int l, int r) &#123;\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r) &#123;\n        if (!--t[p].cnt)\n            t[p].u = t[p].s, t[p].lu = t[p].ls, t[p].ru = t[p].rs;\n        return;\n    &#125;\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (l &lt;= mid)\n        rem(lt, l, r);\n    if (r &gt; mid)\n        rem(rt, l, r);\n    pushup(p);\n    return;\n&#125;\nint main() &#123;\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n    int n, q;\n    std::cin &gt;&gt; n &gt;&gt; q;\n    std::vector&lt;int&gt; a(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i];\n    int u = (n + 1) / 2;\n    const int N = a[u];\n    bld(1, 1, N);\n    for (int i = 1; i &lt; u; ++i)\n        if (a[i] != a[n - i + 1])\n            add(1, std::min(a[i], a[n - i + 1]) + 1, std::max(a[i], a[n - i + 1]));\n    std::cout &lt;&lt; t[1].u &lt;&lt; &#39;\\n&#39;;\n    for (int i, v; q--; ) &#123;\n        std::cin &gt;&gt; i &gt;&gt; v;\n        if (a[i] != a[n - i + 1])\n            rem(1, std::min(a[i], a[n - i + 1]) + 1, std::max(a[i], a[n - i + 1]));\n        a[i] = v;\n        if (a[i] != a[n - i + 1])\n            add(1, std::min(a[i], a[n - i + 1]) + 1, std::max(a[i], a[n - i + 1]));\n        std::cout &lt;&lt; t[1].u &lt;&lt; &#39;\\n&#39;;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"d---移动金币\">D - 移动金币</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P5363\" class=\"uri\">https://www.luogu.com.cn/problem/P5363</a></p>\n<p>最后一个棋子的移动等价于丢掉最后一部分空格；中间棋子的移动等价于把左边间隔里的一段空格拿到右边的间隔里。发现原问题转化为『阶梯 Nim 博弈』。</p>\n<details>\n<p><summary>关于阶梯 Nim 博弈…</summary></p>\n<blockquote>\n<p>给定 <span class=\"math inline\">\\(n\\)</span> 层石头，每次行动可以选择以下操作中的一种：</p>\n<ol type=\"1\">\n<li>选择 <span class=\"math inline\">\\(2\\le i\\le n\\)</span>，从第 <span class=\"math inline\">\\(i\\)</span> 层石头中拿走若干颗，全部放到第 <span class=\"math inline\">\\(i-1\\)</span> 层里。</li>\n<li>从第 <span class=\"math inline\">\\(1\\)</span> 层石头中拿走若干颗，全部丢弃。</li>\n</ol>\n<p>不能行动者输。</p>\n</blockquote>\n<p>本问题可以等效为 Nim 游戏：</p>\n<p>对于第偶数层，若 Alice 选择从第 <span class=\"math inline\">\\(2i\\)</span> 层中移动 <span class=\"math inline\">\\(x\\)</span> 个石头到 <span class=\"math inline\">\\(2i-1\\)</span>，Bob 可以立即从 <span class=\"math inline\">\\(2i-1\\)</span> 层中将这 <span class=\"math inline\">\\(x\\)</span> 个石头移动到 <span class=\"math inline\">\\(2i-2\\)</span>（或丢弃）。</p>\n<p>也就是说，Alice 在偶数层中的操作不会对 Bob 带来任何限制。偶数层的石头可以被视作不存在；从奇数层移动到偶数层的石头可以被视为丢弃；进而，奇数堆中的移动等效为『丢弃』，将原问题中所有奇数堆抽离出来，等效成普通的 Nim 游戏。</p>\n</details>\n<p>问题转化成，将 <span class=\"math inline\">\\(n-m\\)</span> 个元素放到编号 <span class=\"math inline\">\\(0\\sim m+1\\)</span> 的盒子里，满足奇数号盒子球个数异或和为 <span class=\"math inline\">\\(0\\)</span> 的方案数。小容斥一下，用总数减去异或和为 <span class=\"math inline\">\\(0\\)</span> 者。</p>\n",
            "tags": [
                "线段树",
                "博弈论"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20250217/",
            "url": "https://xsc062.netlify.app/20250217/",
            "title": "线段树维护前缀最值序列信息",
            "date_published": "2025-02-17T11:09:57.000Z",
            "content_html": "<p>人类不应该使用 <code>std::vector</code> 实现线段树的 2 个原因：</p>\n<span id=\"more\"></span>\n<ol type=\"1\">\n<li>当你的参数包含引用时，扩容操作，包括显式的 <code>resize()</code> 和隐式的 <code>push_back()</code> 均会导致引用失效。</li>\n<li>当你的左值为引用时，由于 <code>=</code> 左右计算顺序是不确定的（C++14），由于 1 中所述原因，引用可能失效。</li>\n<li><code>terminate called after throwing an instance of 'std::bad_alloc' what():  std::bad_alloc</code></li>\n</ol>\n<p>笑点解析：首先通过「……的 2 个原因」暗示声明一个长度为 2 的 <code>vector</code>，接着在试图访问第 3 个元素时抛出错误。</p>\n<p>什么？你说我的下标是从 1 开始的？恭喜你发现了 <code>vector</code> 的第 0 个笑点。</p>\n<hr />\n<h2 id=\"楼房重建\">楼房重建</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P4198\" class=\"uri\">https://www.luogu.com.cn/problem/P4198</a></p>\n<p>考虑用线段树解决问题。难点在于如何合并两个区间的信息——直觉地，大区间的信息一定与两个子区间有关。</p>\n<p>考虑理想的情况：我们现在知道左右两边区间的答案序列。显然我们需要保留左边整段区间，对于左区间序列末的元素 <span class=\"math inline\">\\(rv_l\\)</span>，我们在右区间内找到第一个大于之的元素 <span class=\"math inline\">\\(x\\)</span>，从它开始的序列就是答案。</p>\n<p>反证法易得 <span class=\"math inline\">\\(x\\)</span> 一定在右区间答案序列内：若 <span class=\"math inline\">\\(x\\)</span> 不在答案序列内，则右区间内存在一个 <span class=\"math inline\">\\(&gt;x\\)</span> 且位于 <span class=\"math inline\">\\(x\\)</span> 之前的元素，那么 <span class=\"math inline\">\\(x\\)</span> 就不是第一个 <span class=\"math inline\">\\(&gt;rv_l\\)</span> 的元素，矛盾。</p>\n<p>那么现在对于左右序列未知的情况，我们取左区间的答案，再在右区间中单 <span class=\"math inline\">\\(\\log\\)</span> 查找能够接上去的区间长度，加起来即可。</p>\n<p>题目只要求总区间答案，故不需要查询。动态开点可能需要小心处理一下。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 1e5 + 5;\nstruct &#123;\n    int l, r, u;\n    double lv, rv, mv;\n&#125; t[maxn &lt;&lt; 2];\nint tot;\n#define lt t[p].l\n#define rt t[p].r\nint askt(int p, int l, int r, double v) &#123;\n    if (l == r)\n        return t[p].u;\n    int mid = (l + r) &gt;&gt; 1;\n    if (lt &amp;&amp; t[p].mv &gt; v)\n        return t[p].u - t[lt].u + askt(lt, l, mid, v);\n    return askt(rt, mid + 1, r, v);\n&#125;\nvoid pushup(int p, int l, int r) &#123;\n    t[p].mv = t[lt].rv;\n    if (lt &amp;&amp; rt) &#123;\n        t[p].lv = t[lt].lv;\n        t[p].rv = std::max(t[lt].rv, t[rt].rv);\n        if (t[lt].rv &lt; t[rt].lv)\n            t[p].u = t[lt].u + t[rt].u;\n        else if (t[lt].rv &gt;= t[rt].rv)\n            t[p].u = t[lt].u;\n        else &#123;\n            int mid = (l + r) &gt;&gt; 1;\n            t[p].u = t[lt].u + askt(rt, mid + 1, r, t[lt].rv);\n        &#125;\n    &#125;\n    else &#123;\n        t[p].u = t[lt + rt].u;\n        t[p].lv = t[lt + rt].lv, t[p].rv = t[lt + rt].rv;\n    &#125;\n    return;\n&#125;\nvoid upd(int &amp;p, int l, int r, int x, double v) &#123;\n    if (!p)\n        p = ++tot;\n    if (l == r) &#123;\n        t[p].lv = t[p].rv = v, t[p].u = 1;\n        return;\n    &#125;\n    int mid = (l + r) &gt;&gt; 1;\n    if (x &lt;= mid)\n        upd(lt, l, mid, x, v);\n    else\n        upd(rt, mid + 1, r, x, v);\n    pushup(p, l, r);\n    return;\n&#125;\n#undef lt\n#undef rt\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;P4198_2.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, m, rt = 0;\n    std::cin &gt;&gt; n &gt;&gt; m;\n    std::vector&lt;double&gt; a(n + 1);\n    for (int x; m--; ) &#123;\n        double y;\n        std::cin &gt;&gt; x &gt;&gt; y;\n        a[x] = y / x;\n        upd(rt, 1, n, x, y / x);\n        std::cout &lt;&lt; t[1].u &lt;&lt; &#39;\\n&#39;;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n",
            "tags": [
                "线段树"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20250216/",
            "url": "https://xsc062.netlify.app/20250216/",
            "title": "Public Round 15 前两题",
            "date_published": "2025-02-16T11:44:38.000Z",
            "content_html": "<p><a href=\"https://pjudge.ac/contest/1914\">PR #15</a> 前两题题解。</p>\n<span id=\"more\"></span>\n<hr />\n<h2 id=\"最小表示法\">最小表示法</h2>\n<p><a href=\"https://pjudge.ac/contest/1914/problem/21888\" class=\"uri\">https://pjudge.ac/contest/1914/problem/21888</a></p>\n<p>首先不妨假设每个 <span class=\"math inline\">\\(f\\)</span> 在值域内等概率取值以简化问题。那么手玩一下可以轻松地得到规律：不妨将 <span class=\"math inline\">\\(\\{s\\}\\)</span> 循环右移一位的结果记为 <span class=\"math inline\">\\(\\{t\\}\\)</span>，那么 <span class=\"math inline\">\\(res=\\sum\\frac 1{\\max(|s_i|,|t_i|)}\\)</span>。</p>\n<p>这看起来令人疑惑：对于不同的 <span class=\"math inline\">\\(i\\)</span>，<span class=\"math inline\">\\([f(s_i)=f(t_i)]\\)</span> 的期望似乎是彼此独立的，十分奇怪。这其实与表达式的来源有关，记 <span class=\"math inline\">\\(g(s_i, j)\\)</span> 表示 <span class=\"math inline\">\\(f(s_i)=j\\)</span> 的概率，那么上述等式可以转写为 <span class=\"math inline\">\\(res=\\sum\\limits_i\\sum\\limits_jg({s_i},j)\\times g(t_i,j)\\)</span>。</p>\n<p>那么将最小表示法带来的偏差纳入考虑范围，我们发现 <span class=\"math inline\">\\(g(s,j)\\)</span> 对于不同的 <span class=\"math inline\">\\(j\\)</span> 并不永远相等。具体地，当 <span class=\"math inline\">\\(s\\)</span> 具有循环节时，最小循环节的第一处结尾会享有更大的取得概率。</p>\n<p>枚举 <span class=\"math inline\">\\(s_i\\)</span> 的因数作为最小循环节长度的情况，显然，对于最小循环节为 <span class=\"math inline\">\\(j\\)</span> 的情况（该情况出现的概率，容斥得到 <span class=\"math inline\">\\(p_j=26^j-\\sum_{k\\mid j}p_k\\)</span>），<span class=\"math inline\">\\(f(s_i)\\)</span> 的取值在 <span class=\"math inline\">\\(1\\sim j\\)</span> 上等概率分布，差分即可统计每个值在不同循环节长度下被取到的概率和。</p>\n<p>用埃筛解决每个数的因数和 <span class=\"math inline\">\\(p\\)</span> 值，那么此时复杂度瓶颈在于 <span class=\"math inline\">\\(g(s_i, j)\\)</span> 和 <span class=\"math inline\">\\(\\sum\\limits_i\\sum\\limits_jg({s_i},j)\\times g(t_i,j)\\)</span> 的求解。容易发现只有每个 <span class=\"math inline\">\\(g(s_i,j),j\\mid |s_i|\\)</span> 的值是有效的（其他的和它们值都相同），考虑只求解和利用这些值，类 <code>std::merge</code>（即归并排序）地求解答案。</p>\n<p>注意特判 <span class=\"math inline\">\\(n=1\\)</span>。会得到错误答案的原因是此时存在 <span class=\"math inline\">\\(s_i=t_i\\)</span>，不满足基本要求。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int lim = 1e5;\nconst int mod = 998244353;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    if (n == 1) &#123;\n        std::cout &lt;&lt; 1 &lt;&lt; &#39;\\n&#39;;\n        return 0;\n    &#125;\n    auto qkp = [](long long x, int y) &#123;\n        long long res = 1ll;\n        for (; y; y &gt;&gt;= 1, (x *= x) %= mod)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    auto inv = [&amp;](int x) &#123;\n        return qkp(x, mod - 2);\n    &#125;;\n    std::vector&lt;long long&gt; f(lim + 1);\n    std::vector&lt;std::vector&lt;int&gt; &gt; fac(lim + 1);\n    for (int i = 1; i &lt;= lim; ++i) &#123;\n        static long long now = 26;\n        (f[i] += now) %= mod;\n        fac[i].push_back(i);\n        for (int j = 2 * i; j &lt;= lim; j += i)\n            (f[j] += mod - f[i]) %= mod, fac[j].push_back(i);\n        (now *= 26) %= mod;\n    &#125;\n    for (int i = 1; i &lt;= lim; ++i)\n        (f[i] *= inv(i)) %= mod;\n    std::vector&lt;int&gt; a(n + 1);\n    struct _ &#123; int l, r; long long f; &#125;;\n    std::vector&lt;std::vector&lt;_&gt; &gt; g(lim + 1);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; a[i];\n        if (g[a[i]].empty()) &#123;\n            g[a[i]].resize(fac[a[i]].size());\n            for (int j = 0; j &lt; (int)fac[a[i]].size(); ++j) &#123;\n                g[a[i]][j].l = (j ? g[a[i]][j - 1].r + 1 : 1);\n                g[a[i]][j].r = fac[a[i]][j];\n                (g[a[i]][0].f += f[fac[a[i]][j]]) %= mod;\n                if (j != (int)fac[a[i]].size() - 1)\n                    (g[a[i]][j + 1].f += mod - f[fac[a[i]][j]]) %= mod;\n            &#125;\n            for (int j = 1; j &lt; (int)fac[a[i]].size(); ++j)\n                (g[a[i]][j].f += g[a[i]][j - 1].f) %= mod;\n            int getinv = inv(qkp(26, a[i]));\n            for (int j = 0; j &lt; (int)fac[a[i]].size(); ++j)\n                (g[a[i]][j].f *= getinv) %= mod;\n        &#125;\n    &#125;\n    std::vector&lt;int&gt; b(n + 1);\n    std::rotate_copy(a.begin() + 1, --a.end(), a.end(), b.begin() + 1);\n    long long res = 0ll;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        for (int j = 0, k = 0, now = 0;\n            j &lt; (int)fac[a[i]].size() &amp;&amp; k &lt; (int)fac[b[i]].size(); )\n            if (g[a[i]][j].r &lt; g[b[i]][k].r) &#123;\n                (res += g[a[i]][j].f * g[b[i]][k].f % mod\n                    * (g[a[i]][j].r - now) % mod) %= mod;\n                now = g[a[i]][j].r, ++j;\n            &#125;\n            else if (g[a[i]][j].r == g[b[i]][k].r) &#123;\n                (res += g[a[i]][j].f * g[b[i]][k].f % mod\n                    * (g[a[i]][j].r - now) % mod) %= mod;\n                now = g[a[i]][j].r, ++j, ++k;\n            &#125;\n            else &#123;\n                (res += g[a[i]][j].f * g[b[i]][k].f % mod\n                    * (g[b[i]][k].r - now) % mod) %= mod;\n                now = g[b[i]][k].r, ++k;\n            &#125;\n    &#125;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"二叉搜索树\">二叉搜索树</h2>\n<p><a href=\"https://pjudge.ac/contest/1914/problem/21889\" class=\"uri\">https://pjudge.ac/contest/1914/problem/21889</a></p>\n<p>当我们处理链的部分分时，很容易想到用差分解决问题。把更新 <span class=\"math inline\">\\([l, r]\\)</span> 看作在差分数组 <span class=\"math inline\">\\(l\\)</span> 处插入，在 <span class=\"math inline\">\\(r+1\\)</span> 处删除，离线下来再从左到右扫一遍操作，考虑如何解决查询问题。</p>\n<p>考虑如何获取 <span class=\"math inline\">\\(i\\)</span> 树上 <span class=\"math inline\">\\(t_0\\)</span> 时刻点 <span class=\"math inline\">\\(x\\)</span> 的所有祖先。根据前面的操作，我们可以获取 <span class=\"math inline\">\\(i\\)</span> 树上存在过的所有元素。</p>\n<p>对于比 <span class=\"math inline\">\\(x\\)</span> 大的元素，考虑祖先 <span class=\"math inline\">\\(p_a\\)</span> 和非祖先 <span class=\"math inline\">\\(p\\)</span> 有什么区别。根据 BST 的性质易得，对于最低的右侧祖先 <span class=\"math inline\">\\({p_a}_0\\)</span>，其是 <span class=\"math inline\">\\(\\ge x\\)</span> 的最小的元素（当然其加入时刻 <span class=\"math inline\">\\(t_a&lt;t_0\\)</span>）；那么同理可以找到 <span class=\"math inline\">\\({p_a}_0\\)</span> 右侧最低的祖先（其左侧的祖先显然也 <span class=\"math inline\">\\(x\\)</span> 左侧），该祖先满足 <span class=\"math inline\">\\(t&lt;t_a\\)</span>。那么我们就从左右两边分别得到 <span class=\"math inline\">\\(x\\)</span> 的所有祖先。容易证明该过程对于不在树上的 <span class=\"math inline\">\\(x\\)</span> 也是正确的。</p>\n<p>具体地，我们需要一个数据结构，能够求出 <span class=\"math inline\">\\(\\ge x\\)</span> 的元素中，以 <span class=\"math inline\">\\(t_0\\)</span> 为起点的前缀最小值序列的区间和。</p>\n<p>欸 ☝🤓 这是什么？<a href=\"/20250217\">楼房重建</a>！秒一下！</p>\n<p>进一步地，本题需要完成对于 <span class=\"math inline\">\\(t_0\\)</span> 为序列头的查询。再次利用性质，每次 <span class=\"math inline\">\\(O(\\log V)\\)</span> 地合并答案。</p>\n<p>好的那么怎么把链搞到树上呢？把差分放到树上，写个线段树合并即可。</p>\n<p><strong>注意由于这题细节太多了，所以你可能需要舍弃不必要的时空优化换取代码简洁度以方便调试。</strong></p>\n<details>\n<pre data-line=\"12\" class=\"cpp language-cpp\"><code data-line=\"12\" class=\"cpp language-cpp\">#include &lt;bits/stdc++.h&gt;\nconst int lim = 2e5;\nconst int maxn = 2e7 + 5;\nconst int inf = 0x3f3f3f3f;\nstruct &#123;\n    int l, r, rv;\n    long long u;\n&#125; t[maxn];\nstd::vector&lt;int> tr;\n#define lt t[p].l\n#define rt t[p].r\nint newnode(void) &#123;         // 我知道你要说什么，但这属于「必要的」空间优化 😥\n    static int tot = 0;\n    if (tr.empty())\n        return ++tot;\n    auto p(tr.back());\n    t[p].l = t[p].r = 0;\n    tr.pop_back();\n    return p;\n&#125;\nlong long askv(int p, int l, int r, int v) &#123;\n    if (l == r)\n        return t[p].rv < v ? t[p].u : 0;\n    int mid = (l + r) >> 1;\n    if (v > t[lt].rv)\n        return t[p].u - t[lt].u + askv(lt, l, mid, v);\n    return askv(rt, mid + 1, r, v);\n&#125;\nvoid pushup(int p, int l, int r) &#123;\n    t[p].rv = std::min(t[lt].rv, t[rt].rv);\n    int mid = (l + r) >> 1;\n    t[p].u = t[lt].u + askv(rt, mid + 1, r, t[lt].rv);\n    return;\n&#125;\nvoid upd(int &p, int l, int r, int x, int v, int u) &#123;\n    if (!p)\n        p = newnode();\n    if (l == r) &#123;\n        t[p].rv = v, t[p].u = u;\n        return;\n    &#125;\n    int mid = (l + r) >> 1;\n    if (x <= mid)\n        upd(lt, l, mid, x, v, u);\n    else\n        upd(rt, mid + 1, r, x, v, u);\n    pushup(p, l, r);\n    return;\n&#125;\nvoid merge(int &p, int q, int l, int r) &#123;\n    if (!p || !q) &#123;\n        p += q;\n        return;\n    &#125;\n    if (l == r) &#123;\n        t[p].rv = std::min(t[p].rv, t[q].rv);\n        t[p].u = std::max(t[p].u, t[q].u);\n        return;\n    &#125;\n    int mid = (l + r) >> 1;\n    merge(t[p].l, t[q].l, l, mid), merge(t[p].r, t[q].r, mid + 1, r);\n    pushup(p, l, r), tr.push_back(q);\n    return;\n&#125;\nint qv = inf;\nlong long ask(int p, int l, int r, int ql, int qr) &#123;\n    if (ql <= l && r <= qr) &#123;\n        auto s(askv(p, l, r, qv));\n        qv = std::min(qv, t[p].rv);\n        return s;\n    &#125;\n    int mid = (l + r) >> 1;\n    long long res = 0ll;\n    if (ql <= mid)\n        res = ask(lt, l, mid, ql, qr);\n    if (qr > mid)\n        res += ask(rt, mid + 1, r, ql, qr);\n    return res;\n&#125;\n#undef lt\n#undef rt\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(\"ex_problem4.in\", \"r\", stdin);\n    std::freopen(\".out\", \"w\", stdout);\n#endif\n    int n, m;\n    std::cin >> n >> m;\n    std::vector&lt;std::vector&lt;int> > g(n + 1);\n    for (int i = 1, x, y; i < n; ++i) &#123;\n        std::cin >> x >> y;\n        g[x].push_back(y), g[y].push_back(x);\n    &#125;\n    std::vector&lt;int> top(n + 1), fa(n + 1), siz(n + 1), son(n + 1), dep(n + 1);\n    std::function&lt;void(int, int)> DFS = [&](int x, int faa) &#123;\n        siz[x] = 1;\n        for (auto i : g[x])\n            if (i != faa) &#123;\n                fa[i] = x, dep[i] = dep[x] + 1;\n                DFS(i, x), siz[x] += siz[i];\n                if (siz[i] > siz[son[x]])\n                    son[x] = i;\n            &#125;\n        return;\n    &#125;;\n    DFS(1, -1);\n    DFS = [&](int x, int topp) &#123;\n        top[x] = topp;\n        if (son[x])\n            DFS(son[x], topp);\n        for (auto i : g[x])\n            if (i != fa[x] && i != son[x])\n                DFS(i, i);\n        return;\n    &#125;;\n    DFS(1, 1);\n    auto getLCA = [&](int x, int y) &#123;\n        for (; top[x] != top[y]; x = fa[top[x]])\n            if (dep[top[y]] > dep[top[x]])\n                std::swap(x, y);\n        return (dep[x] < dep[y] ? x : y);\n    &#125;;\n    std::vector&lt;std::vector&lt;int> > d(n + 1);\n    std::vector&lt;std::vector&lt;std::pair&lt;int, int> > > u(n + 1);\n    std::vector&lt;std::vector&lt;std::tuple&lt;int, int, int> > > q(n + 1);\n    int cnt = 0;\n    for (int i = 1; i <= m; ++i) &#123;\n        int op;\n        std::cin >> op;\n        if (op == 0) &#123;\n            int x, v;\n            std::cin >> x >> v;\n            q[x].emplace_back(++cnt, i, v);\n        &#125; else &#123;\n            int x, y, v;\n            std::cin >> x >> y >> v;\n            int faa = getLCA(x, y);\n            u[x].emplace_back(i, v), u[y].emplace_back(i, v);\n            if (fa[faa])\n                d[fa[faa]].emplace_back(v);\n        &#125;\n    &#125;\n    std::vector&lt;long long> res(cnt + 1);\n    std::vector&lt;std::vector&lt;int> > rt(2, std::vector&lt;int> (n + 1));\n    t[0].rv = inf;\n    DFS = [&](int x, int fa) &#123;\n        for (auto i : g[x])\n            if (i != fa) &#123;\n                DFS(i, x);\n                merge(rt[0][x], rt[0][i], 1, lim);\n                merge(rt[1][x], rt[1][i], 1, lim);\n            &#125;\n        for (auto [t, v] : u[x]) &#123;\n            upd(rt[0][x], 1, lim, v, t, v);\n            upd(rt[1][x], 1, lim, lim - v + 1, t, v);\n        &#125;\n        for (auto v : d[x]) &#123;\n            upd(rt[0][x], 1, lim, v, inf, 0);\n            upd(rt[1][x], 1, lim, lim - v + 1, inf, 0);\n        &#125;\n        for (auto [id, t, v] : q[x]) &#123;\n            qv = t, res[id] = ask(rt[0][x], 1, lim, v, lim);\n            qv = t, res[id] += ask(rt[1][x], 1, lim, lim - v + 1, lim);\n            qv = t, res[id] -= ask(rt[0][x], 1, lim, v, v);\n        &#125;\n    &#125;;\n    DFS(1, -1);\n    for (int i = 1; i <= cnt; ++i)\n        std::cout << res[i] << '\\n';\n    return 0;\n&#125;</code></pre>\n</details>\n",
            "tags": [
                "线段树",
                "数学",
                "树上差分"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20241021/",
            "url": "https://xsc062.netlify.app/20241021/",
            "title": "字符串",
            "date_published": "2024-10-21T00:32:59.000Z",
            "content_html": "<p>标题本来叫「哈希」，后来发现第二天的很多题虽然打了哈希的 tag 但是只有 KMP 做法，故忍痛改成「字符串」。</p>\n<span id=\"more\"></span>\n<hr />\n<h2 id=\"a.-two-permutations\">A. Two Permutations</h2>\n<p><a href=\"http://222.180.160.110:61235/contest/5653/problem/1\" class=\"uri\">http://222.180.160.110:61235/contest/5653/problem/1</a></p>\n<p>有个很重要的性质是 <span class=\"math inline\">\\(a\\)</span> 和 <span class=\"math inline\">\\(b\\)</span> 都是排列。然后我们就知道了 <span class=\"math inline\">\\(x\\in [0,m-n]\\)</span>，且每个 <span class=\"math inline\">\\(a_i+x\\)</span> 在 <span class=\"math inline\">\\(b\\)</span> 中有元素与之唯一对应。<mark>于是问题可以转化成，<span class=\"math inline\">\\(b\\)</span> 中在 <span class=\"math inline\">\\([1+x,n+x]\\)</span> 范围中的元素按顺序哈希起来和 <span class=\"math inline\">\\(a\\)</span> 序列是否完全一致</mark>。</p>\n<p>我们就有了一个想法：枚举这个 <span class=\"math inline\">\\(x\\)</span>，通过某种方法快速查询这个长度固定的值域区间按顺序哈希起来的值。<mark>然后就是典中典之线段树维护哈希，只需在枚举 <span class=\"math inline\">\\(x\\)</span> 时滑动窗口，剔除头部元素，新增尾部元素，查询全局哈希值即可</mark>。</p>\n<p>还有一个小细节是关于实时维护全局加 <span class=\"math inline\">\\(x\\)</span> 后的 <span class=\"math inline\">\\(a\\)</span>。由于哈希用乘的肯定拆不开，只能用加哈希了。每次 <span class=\"math inline\">\\(x\\)</span> 加一的时候全局哈希值加上 <span class=\"math inline\">\\(\\sum p_i\\)</span> 即可。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int p = 998244353;\nconst int mod = 1e9 + 7;\nconst int maxn = 2e5 + 5;\nstruct &#123;\n    int l, r, s;\n    long long u;\n&#125; t[maxn &lt;&lt; 2];\nlong long base[maxn];\n#define lt (p &lt;&lt; 1)\n#define rt (lt | 1)\nvoid pushup(int p) &#123;\n    t[p].u = (t[lt].u * base[t[rt].s] % mod + t[rt].u) % mod;\n    return;\n&#125;\nvoid bld(int p, int l, int r) &#123;\n    t[p].l = l, t[p].r = r;\n    if (l == r)\n        return;\n    int mid = (l + r) &gt;&gt; 1;\n    bld(lt, l, mid), bld(rt, mid + 1, r);\n    return;\n&#125;\nvoid add(int p, int x, int v) &#123;\n    t[p].s += (v &gt;= 0 ? 1 : -1);\n    if (t[p].l == t[p].r) &#123;\n        t[p].u += v;\n        return;\n    &#125;\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (x &lt;= mid)\n        add(lt, x, v);\n    else\n        add(rt, x, v);\n    pushup(p);\n    return;\n&#125;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, m;\n    std::cin &gt;&gt; n &gt;&gt; m;\n    std::vector&lt;int&gt; a(n + 1), b(m + 1), pos(m + 1);\n    base[0] = 1;\n    long long s = 1;\n    for (int i = 1; i &lt;= m; ++i) &#123;\n        base[i] = base[i - 1] * p % mod;\n        if (i &lt; n)\n            (s += base[i]) %= mod;\n    &#125;\n    long long now = 0;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; a[i];\n        now = (now * p % mod + a[i]) % mod;\n    &#125;\n    for (int i = 1; i &lt;= m; ++i)\n        std::cin &gt;&gt; b[i], pos[b[i]] = i;\n    int res = 0;\n    bld(1, 1, m);\n    for (int x = 0; x &lt;= m - n; ++x) &#123;\n        for (static int l = 1; l &lt; 1 + x; add(1, pos[l], -l), ++l);\n            // printf(&quot;add %d: %d\\n&quot;, pos[l], -l);\n        for (static int r = 1; r &lt;= n + x; add(1, pos[r], r), ++r);\n            // printf(&quot;add %d: %d\\n&quot;, pos[r], r);\n        (res += (now == t[1].u));\n        // printf(&quot;x = %d, now = %lld, t[1].u = %lld\\n&quot;, x, now, t[1].u);\n        (now += s) %= mod;\n    &#125;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"b.-k-substrings\">B. k-substrings</h2>\n<p><a href=\"http://222.180.160.110:61235/contest/5653/problem/2\" class=\"uri\">http://222.180.160.110:61235/contest/5653/problem/2</a></p>\n<p>我们可以发现这 <span class=\"math inline\">\\(\\left\\lceil\\dfrac n2\\right\\rceil\\)</span> 个串都有共同中点，而<mark>不管其位于元素还是元素间的空隙，两边的 border 都应关于其对称</mark>。啥叫奇 border 呢，就是每个 border 都能取到元素上的中点，<mark>也就是说这俩中点是关于全串中点对称的</mark>。</p>\n<p>我们枚举这 <span class=\"math inline\">\\(\\left\\lfloor\\dfrac n2\\right\\rfloor\\)</span> 对可能的 border 中点，分别二分 border 长度。假设最后该对中点最长合法 border 为 <span class=\"math inline\">\\([l_1,r_1]\\)</span> 与 <span class=\"math inline\">\\([l_2,r_2]\\)</span>，用 <span class=\"math inline\">\\(r_1-l_1+1-2\\times k\\)</span> 更新 <span class=\"math inline\">\\(l_1+k\\)</span> 处的答案即可。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int p = 131;\nconst int mod = 1e9 + 7;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;char&gt; a(n + 1);\n    std::vector&lt;int&gt; res(n + 1, -1);\n    std::vector&lt;long long&gt; h(n + 1), base(n + 1);\n    base[0] = 1;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; a[i];\n        h[i] = (h[i - 1] * p + a[i]) % mod;\n        base[i] = base[i - 1] * p % mod;\n    &#125;\n    auto geth = [&amp;](int l, int r) &#123;\n        return (h[r] + mod - h[l - 1] * base[r - l + 1] % mod) % mod;\n    &#125;;\n    for (int l = n / 2, r = (n + 1) / 2 + 1; r &lt;= n; --l, ++r)\n        if (a[l] == a[r]) &#123;\n            int t = 0;\n            for (int ll = 1, rr = l, mid; ll &lt;= rr; ) &#123;\n                mid = (ll + rr) &gt;&gt; 1;\n                if (geth(l - mid + 1, l + mid - 1) == geth(r - mid + 1, r + mid - 1))\n                    t = mid, ll = mid + 1;\n                else\n                    rr = mid - 1;\n            &#125;\n            res[l - t + 1] = std::max(res[l - t + 1], 2 * t - 1);\n        &#125;\n    for (int i = 1; i &lt;= (n + 1) / 2; ++i) &#123;\n        res[i] = std::max(res[i - 1] - 2, res[i]);\n        std::cout &lt;&lt; res[i] &lt;&lt; &#39; &#39;;\n    &#125;\n    std::cout &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"c.-kefa-and-watch\">C. Kefa and Watch</h2>\n<p><a href=\"http://222.180.160.110:61235/contest/5653/problem/3\" class=\"uri\">http://222.180.160.110:61235/contest/5653/problem/3</a></p>\n<p>一个挺常用的 trick 是，<mark><span class=\"math inline\">\\(S_{l\\sim r}\\)</span> 存在长度为 <span class=\"math inline\">\\(d\\)</span> 的循环节 <span class=\"math inline\">\\(\\iff S_{l\\sim (r-d)}=S_{(l+d+)\\sim r}\\)</span></mark>。而题目要求为混循环节，刚好也可以用这个方法判定。线段树随便维护一下哈希就行。assign 操作就是将长度为 <span class=\"math inline\">\\(len\\)</span> 的区间哈希值更改为 <span class=\"math inline\">\\(t\\times \\sum_{i=0}^{len-1}p^i\\)</span>。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int p = 131;\nconst int mod = 1e9 + 7;\nconst int maxn = 1e5 + 5;\nstruct &#123;\n    int l, r, d;\n    long long u;\n&#125; t[maxn &lt;&lt; 2];\nint a[maxn];\nlong long base[maxn], s[maxn];\n#define lt (p &lt;&lt; 1)\n#define rt (lt | 1)\nvoid pushup(int p) &#123;\n    t[p].u = (t[lt].u * base[t[rt].r - t[rt].l + 1] % mod + t[rt].u) % mod;\n    return;\n&#125;\nvoid pushdown(int p) &#123;\n    if (~t[p].d) &#123;\n        t[lt].d = t[rt].d = t[p].d;\n        t[lt].u = t[p].d * s[t[lt].r - t[lt].l] % mod;\n        t[rt].u = t[p].d * s[t[rt].r - t[rt].l] % mod;\n        t[p].d = -1;\n    &#125;\n    return;\n&#125;\nvoid bld(int p, int l, int r) &#123;\n    t[p].l = l, t[p].r = r, t[p].d = -1;\n    if (l == r) &#123;\n        t[p].u = a[l];\n        return;\n    &#125;\n    int mid = (l + r) &gt;&gt; 1;\n    bld(lt, l, mid), bld(rt, mid + 1, r);\n    pushup(p);\n    return;\n&#125;\nvoid ass(int p, int l, int r, int v) &#123;\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r) &#123;\n        t[p].d = v;\n        t[p].u = v * s[t[p].r - t[p].l] % mod;\n        return;\n    &#125;\n    pushdown(p);\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (l &lt;= mid)\n        ass(lt, l, r, v);\n    if (r &gt; mid)\n        ass(rt, l, r, v);\n    pushup(p);\n    return;\n&#125;\nlong long ask(int p, int l, int r) &#123;\n    // printf(&quot;p = %d, u = %lld, [%d, %d] of [%d, %d]\\n&quot;, p, t[p].u, t[p].l, t[p].r, l, r);\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r)\n        return t[p].u;\n    pushdown(p);\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (r &lt;= mid)\n        return ask(lt, l, r);\n    if (l &gt; mid)\n        return ask(rt, l, r);\n    return (ask(lt, l, r) * base[std::min(r, t[p].r) - mid] % mod + ask(rt, l, r)) % mod;\n&#125;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, m, k;\n    std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;\n    base[0] = s[0] = 1;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        char t;\n        std::cin &gt;&gt; t;\n        a[i] = t - &#39;0&#39;;\n        base[i] = base[i - 1] * p % mod;\n        s[i] = (s[i - 1] + base[i]) % mod;\n    &#125;\n    bld(1, 1, n);\n    for (int q = m + k; q--; ) &#123;\n        int op;\n        std::cin &gt;&gt; op;\n        if (op == 1) &#123;\n            int l, r, t;\n            std::cin &gt;&gt; l &gt;&gt; r &gt;&gt; t;\n            ass(1, l, r, t);\n        &#125;\n        else &#123;\n            int l, r, d;\n            std::cin &gt;&gt; l &gt;&gt; r &gt;&gt; d;\n            // if (d != r - l + 1)\n            //     printf(&quot;%lld / %lld\\n&quot;, ask(1, l, r - d), ask(1, l + d, r));\n            std::cout &lt;&lt; ((d == r - l + 1 || ask(1, l, r - d) == ask(1, l + d, r)) ? &quot;YES&quot; : &quot;NO&quot;) &lt;&lt; &#39;\\n&#39;;\n        &#125;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"d.-misha-and-lcp-on-tree\">D. Misha and LCP on Tree</h2>\n<p><a href=\"http://222.180.160.110:61235/contest/5653/problem/4\" class=\"uri\">http://222.180.160.110:61235/contest/5653/problem/4</a></p>\n<p>一个很显然的做法是，我们二分一个长度，然后在 <span class=\"math inline\">\\(a\\to fa\\)</span> 上正哈希，<span class=\"math inline\">\\(b\\to fa\\)</span> 上反哈希，<span class=\"math inline\">\\(O(1)\\)</span> check。</p>\n<p>笑话：本来想用倍增求 <span class=\"math inline\">\\(a\\to fa\\)</span> 和 <span class=\"math inline\">\\(b\\to fa\\)</span> 的哈希（当然双 <span class=\"math inline\">\\(\\log\\)</span> 肯定是会被卡飞的），后来发现<mark>哈希具有可减性，我们又只需求一条链上的哈希值，直接减掉就行</mark>。</p>\n<p>还有一个点就是 <span class=\"math inline\">\\(O(1)\\)</span> 求 <span class=\"math inline\">\\(k\\)</span> 级祖先，有长剖预处理的做法。<a href=\"/20241021-1\">具体做法</a>。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int p = 131;\nconst int mod = 1e9 + 7;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;int&gt; to(n + 1);\n    std::vector&lt;char&gt; a(n + 1);\n    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);\n    std::vector&lt;long long&gt; base(n + 1), inv(n + 1);\n    auto qkp = [](long long x, int y) &#123;\n        long long res = 1;\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    base[0] = inv[0] = 1;\n    for (int i = 1, mx = 0; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; a[i];\n        base[i] = base[i - 1] * p % mod;\n        inv[i] = qkp(base[i], mod - 2);\n        if (i &gt;= (1 &lt;&lt; mx) * 2)\n            ++mx;\n        to[i] = mx;\n    &#125;\n    for (int i = 1, x, y; i &lt; n; ++i) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y;\n        g[x].push_back(y), g[y].push_back(x);\n    &#125;\n    std::vector&lt;long long&gt; h1(n + 1), h2(n + 1);\n    std::vector&lt;std::array&lt;int, 21&gt; &gt; fa(n + 1);\n    std::vector&lt;int&gt; h(n + 1, 1), son(n + 1), dep(n + 1);\n    h[0] = 0;\n    std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;\n        h1[x] = (h1[fa[x][0]] * p % mod + a[x]) % mod;\n        h2[x] = (h2[fa[x][0]] + a[x] * base[dep[x] - 1]) % mod;\n        for (auto i : g[x])\n            if (i != fa[x][0]) &#123;\n                fa[i][0] = x;\n                for (int j = 1; j &lt;= 20; ++j)\n                    fa[i][j] = fa[fa[i][j - 1]][j - 1];\n                dep[i] = dep[x] + 1;\n                DFS(i);\n                if (h[i] &gt;= h[son[x]])\n                    son[x] = i, h[x] = h[i] + 1;\n            &#125;\n        return;\n    &#125;;\n    dep[1] = 1, DFS(1);\n    std::vector&lt;int&gt; top(n + 1), id(n + 1);\n    std::vector&lt;std::vector&lt;int&gt; &gt; anc(n + 1), des(n + 1, std::vector&lt;int&gt; (1));\n    std::function&lt;void(int, int)&gt; DFS1 = [&amp;](int x, int toq) &#123;\n        top[x] = toq;\n        if (son[x])\n            DFS1(son[x], toq);\n        for (auto i : g[x])\n            if (i != fa[x][0] &amp;&amp; i != son[x])\n                DFS1(i, i);\n        des[toq].push_back(x);\n        id[x] = (int)des[toq].size() - 1;\n        if (x == toq) &#123;\n            anc[x].push_back(x);\n            for (int j = 1, now = x; j &lt;= id[x]; ++j, now = fa[now][0])\n                anc[x].push_back(fa[now][0]);\n        &#125;\n        return;\n    &#125;;\n    DFS1(1, 1);\n    auto getLCA = [&amp;](int x, int y) &#123;\n        if (dep[x] &lt; dep[y])\n            std::swap(x, y);\n        for (int i = 20; ~i; --i)\n            if (dep[fa[x][i]] &gt;= dep[y])\n                x = fa[x][i];\n        if (x == y)\n            return x;\n        for (int i = 20; ~i; --i)\n            if (fa[x][i] != fa[y][i])\n                x = fa[x][i], y = fa[y][i];\n        return fa[x][0];\n    &#125;;\n    auto ask = [&amp;](int x, int k) &#123;\n        assert(dep[x] - 1 &gt;= k);\n        int x1 = x;\n        if (!k)\n            return x;\n        x = fa[x][to[k]];\n        if (dep[x] - dep[top[x]] &gt;= k - (1 &lt;&lt; to[k]))\n            return des[top[x]][id[x] + k - (1 &lt;&lt; to[k])];\n        return anc[top[x]][k - (1 &lt;&lt; to[k]) - (dep[x] - dep[top[x]])];\n    &#125;;\n    auto dis = [&amp;](int x, int y, int fa) &#123;\n        return dep[x] + dep[y] - 2 * dep[fa];\n    &#125;;\n    auto gethash = [&amp;](int x, int y, int f, int k) &#123;\n        if (!k)\n            return 0ll;\n        if (k &lt;= dep[x] - dep[f] + 1) &#123;\n            f = ask(x, k - 1);\n            return (h2[x] + mod - h2[fa[f][0]]) % mod * inv[dep[f] - 1] % mod;\n        &#125;\n        long long h = (h2[x] + mod - h2[fa[f][0]]) % mod * inv[dep[f] - 1] % mod;\n        k -= (dep[x] - dep[f] + 1);\n        y = ask(y, (dep[y] - dep[f]) - k);\n        h = (h * base[dep[y] - dep[f]] % mod + (h1[y] + mod - h1[f] * base[dep[y] - dep[f]] % mod) % mod) % mod;\n        return h;\n    &#125;;\n    int m;\n    std::cin &gt;&gt; m;\n    for (int x, y, a, b; m--; ) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y &gt;&gt; a &gt;&gt; b;\n        int fa1 = getLCA(x, y), fa2 = getLCA(a, b), res = 0;\n        for (int l = 0, r = std::min(dis(x, y, fa1), dis(a, b, fa2)) + 1, mid; l &lt;= r; ) &#123;\n            mid = (l + r) &gt;&gt; 1;\n            if (gethash(x, y, fa1, mid) == gethash(a, b, fa2, mid))\n                res = mid, l = mid + 1;\n            else\n                r = mid - 1;\n        &#125;\n        std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"a.-song-of-the-sirens\">A. Song of the Sirens</h2>\n<p><a href=\"http://222.180.160.110:61235/contest/5658/problem/1\" class=\"uri\">http://222.180.160.110:61235/contest/5658/problem/1</a></p>\n<p>笑话：是 <span class=\"math inline\">\\(s_it_is_i\\)</span> 而不是 <span class=\"math inline\">\\(s_its_i\\)</span>。</p>\n<p>我们发现 <span class=\"math inline\">\\(s_0\\)</span> 很短，所以直接枚举起始位置把 <span class=\"math inline\">\\(s_0\\)</span> 和匹配串大力匹配，把空位挖出来组成新的匹配串再考虑 <span class=\"math inline\">\\(t\\)</span> 的问题（因为所有 <span class=\"math inline\">\\(s_i\\)</span> 最开头都有一个完整的 <span class=\"math inline\">\\(s_0\\)</span>，所以可以随便选断点）。</p>\n<p>我们知道 <span class=\"math inline\">\\(t\\)</span> 的下标是一个自底向上从 <span class=\"math inline\">\\(1\\)</span> 到 <span class=\"math inline\">\\(n\\)</span> 的满二叉树的中序遍历，其中 <mark><span class=\"math inline\">\\(t_1\\)</span> 间隔一位出现；于是我们仿照对 <span class=\"math inline\">\\(s\\)</span> 的处理方式，再把 <span class=\"math inline\">\\(t_1\\)</span> 挖掉。注意到此时 <span class=\"math inline\">\\(t_2\\)</span> 又成为二叉树最底层，间隔一位出现，这就变成了一个 <span class=\"math inline\">\\(\\mathcal O(n\\log n)\\)</span> 递归的问题</mark>。</p>\n<p>至于答案，当 <span class=\"math inline\">\\(t\\)</span> 被删空时，假设删掉的最后一个元素为 <span class=\"math inline\">\\(t_p\\)</span>，<span class=\"math inline\">\\(t\\)</span> 的出现次数即为二叉树中 <span class=\"math inline\">\\(p\\)</span> 层点数，为 <span class=\"math inline\">\\(2^{k-p}\\)</span>。</p>\n<p>有一个细节，就是如果当前删到 <span class=\"math inline\">\\(i\\)</span> 了，<span class=\"math inline\">\\(t\\)</span> 的长度只剩 <span class=\"math inline\">\\(1\\)</span>，就会有一个很尴尬的问题——这个元素不一定就是 <span class=\"math inline\">\\(t_i\\)</span>，而应该是 <span class=\"math inline\">\\(\\{j \\mid j\\ge i\\land t_j=t_i\\}\\)</span>。统计 <span class=\"math inline\">\\(t_{i\\sim k}\\)</span> 中值为 <span class=\"math inline\">\\(t_i\\)</span> 的元素个数（前缀和），乘上对应的层数即可。这个可以用一点小技巧搞定，前缀和时忽略 <span class=\"math inline\">\\(k\\)</span> 乘上 <span class=\"math inline\">\\(k=n\\)</span> 时的系数，统计答案时乘上 <span class=\"math inline\">\\(2^{n-k}\\)</span> 即可。</p>\n<p>不是，那我缺的哈希这块谁来补啊？？？</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 1e9 + 7;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;sirens1.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, q, m;\n    std::string s;\n    std::cin &gt;&gt; n &gt;&gt; q &gt;&gt; s;\n    s = &#39;\\0&#39; + s, m = (int)s.length() - 1;\n    std::vector&lt;char&gt; t(n + 1);\n    std::vector&lt;long long&gt; base(n + 1), inv(n + 1);\n    std::vector&lt;std::array&lt;long long, 26&gt; &gt; a(n + 1);\n    auto qkp = [](long long x, int y) &#123;\n        long long res = 1ll;\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    base[0] = 1ll, inv[0] = 1ll, inv[1] = qkp(2, mod - 2);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; t[i];\n        base[i] = base[i - 1] * 2 % mod;\n        if (i != 1)\n            inv[i] = inv[i - 1] * inv[1] % mod;\n    &#125;\n    for (int i = 1; i &lt;= n; ++i)\n        a[i] = a[i - 1], (a[i][t[i] - &#39;a&#39;] += base[n - i]) %= mod;\n    for (int k; q--; ) &#123;\n        std::string p;\n        std::cin &gt;&gt; k &gt;&gt; p;\n        p = &#39;\\0&#39; + p;\n        long long res = 0;\n        int l = (int)p.length() - 1;\n        std::vector&lt;char&gt; u;\n        std::function&lt;void(int, std::vector&lt;char&gt; &amp;)&gt; calc = [&amp;](int x, std::vector&lt;char&gt; &amp;p) &#123;\n            int m = (int)p.size() - 1;\n            if (m == 0) &#123;\n                // puts(&quot;# 45&quot;);\n                // printf(&quot;0, += %lld\\n&quot;, base[k - x + 1]);\n                (res += base[k - x + 1]) %= mod;\n                return;\n            &#125;\n            if (x &gt; k)\n                return;\n            if (m == 1) &#123;\n                // puts(&quot;# 50&quot;);\n                // printf(&quot;1, += %lld(%lld)\\n&quot;, (a[k][p[1] - &#39;a&#39;] + mod - a[x - 1][p[1] - &#39;a&#39;]) % mod * inv[n - k] % mod, inv[n - k] % mod);\n                (res += (a[k][p[1] - &#39;a&#39;] + mod - a[x - 1][p[1] - &#39;a&#39;]) % mod * inv[n - k] % mod) %= mod;\n                return;\n            &#125;\n            bool flag0 = 1, flag1 = 1;\n            std::vector&lt;char&gt; t0(1), t1(1);\n            for (int i = 1; i &lt;= m; ++i)\n                if (!(i &amp; 1)) &#123;\n                    if (flag0)\n                        t0.push_back(p[i]);\n                    flag1 &amp;= (p[i] == t[x]);\n                &#125;\n                else &#123;\n                    if (flag1)\n                        t1.push_back(p[i]);\n                    flag0 &amp;= (p[i] == t[x]);\n                &#125;\n            if (flag0)\n                calc(x + 1, t0);\n            if (flag1)\n                calc(x + 1, t1);\n            return;\n        &#125;;\n        for (int i = 1; i &lt;= m + 1; ++i) &#123;\n            std::vector&lt;char&gt;(1).swap(u);\n            for (int j = i, now = 1; now &lt;= l; ++now) &#123;\n                if (j == m + 1)\n                    j = 1, u.push_back(p[now]);\n                else if (p[now] != s[j])\n                    goto nosol;\n                else\n                    ++j;\n            &#125;\n            // printf(&quot;u: &quot;);\n            // for (int i = 1; i &lt; (int)u.size(); ++i)\n            //     std::cout &lt;&lt; u[i];\n            // puts(&quot;&quot;);\n            calc(1, u);\n        nosol: ;\n        &#125;\n        std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"b.-prefix-of-suffixes\">B. Prefix of Suffixes</h2>\n<p><a href=\"http://222.180.160.110:61235/contest/5658/problem/2\" class=\"uri\">http://222.180.160.110:61235/contest/5658/problem/2</a></p>\n<p>还是太科幻了。哦哦 border 我的 border。</p>\n<h3 id=\"法一\">法一</h3>\n<p>考虑每次增量，若加入 <span class=\"math inline\">\\(S_i\\)</span> 后有 <span class=\"math inline\">\\(z_j\\)</span> 的值增加 <span class=\"math inline\">\\(1\\)</span>，那么这对 <span class=\"math inline\">\\((i, j)\\)</span> 就会贡献 <span class=\"math inline\">\\(A_j\\cdot B_i\\)</span> 的增量；<mark>反之，<span class=\"math inline\">\\(z_j\\)</span> 在以后也不会增加</mark>。</p>\n<p>我们维护当前没有确定下来的所有 <span class=\"math inline\">\\(z_j\\)</span>，对于每个 <span class=\"math inline\">\\(i\\)</span> 暴力 check <span class=\"math inline\">\\(z_j\\)</span> 是否确定并更新答案，<strong>因为数据比较弱</strong>，在 CF 神机上跑得飞快 <img src=\"/em/dy.gif\" /> 但是 QOJ 上死活过不了 <img src=\"/em/ll.gif\" /></p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    long long res = 0, s = 0;\n    std::cin &gt;&gt; n;\n    std::vector&lt;int&gt; now;\n    std::vector&lt;int&gt; a(n + 1), b(n + 1), t(n + 1);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; t[i] &gt;&gt; a[i] &gt;&gt; b[i];\n        t[i] = (res + t[i]) % n;\n        if (t[i] == t[1])\n            s += b[i], now.push_back(i);\n        std::vector&lt;int&gt; g(std::move(now));\n        for (auto j : g)\n            if (t[i] == t[i - j + 1])\n                now.push_back(j);\n            else\n                s -= b[j];\n        res += a[i] * s;\n        std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n<h3 id=\"法二\">法二</h3>\n<p>依然考虑增量。<mark><span class=\"math inline\">\\(z_j\\)</span> 增加 <span class=\"math inline\">\\(\\iff S_{j\\to i}\\)</span> 为 <span class=\"math inline\">\\(S_{1\\sim i}\\)</span> 的一个 border</mark>。考虑对于每一个 <span class=\"math inline\">\\(S_i\\)</span>，border 的组成。</p>\n<ol type=\"1\">\n<li>若 <span class=\"math inline\">\\(S_1=S_i\\)</span>，那么将会新增一个长度为 <span class=\"math inline\">\\(1\\)</span> 的 border。</li>\n<li>对于在 <span class=\"math inline\">\\(i-1\\)</span> 处合法的 border <span class=\"math inline\">\\(S_{j\\sim i-1}\\)</span>，若 <span class=\"math inline\">\\(S_i=S_{i-j+1}\\)</span>，则该 border 仍合法；否则非法。</li>\n</ol>\n<p>我们的法一其实相当于是暴力 check 了所有合法 border 是否仍然合法，但这显然最坏是 <span class=\"math inline\">\\(O(n^2)\\)</span> 的。我们考虑从 border 角度优化一下。</p>\n<p>我们发现，比如说 <span class=\"math inline\">\\(\\texttt{abababa + b}\\)</span>，我们会进行很多次不必要的 check，当然这个时候我们会本能大力跳 fail，但是这里有一个 <a href=\"https://www.luogu.com/article/e08ebmz6\">border 的等差数列性质</a>，若 <span class=\"math inline\">\\(x+1\\)</span> 与 <span class=\"math inline\">\\(i\\)</span> 能够匹配，那么与 <span class=\"math inline\">\\(x\\)</span> 同属一个等差数列的所有 <span class=\"math inline\">\\(x&#39;+1\\)</span> 都应和 <span class=\"math inline\">\\(i\\)</span> 匹配。</p>\n<p>对于正在 check 的 <span class=\"math inline\">\\(x\\)</span>，如果 check 成功则跳到上一条链的链尾；否则跳到链头。总的复杂度是 <span class=\"math inline\">\\(O(n\\log n)\\)</span> 的。找一下和每个 <span class=\"math inline\">\\(i\\)</span> 匹配不了的第一个链头，甚至可以因为某些我太菜了所以不知道的不明原因整到线性。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    long long res = 0, s = 0;\n    std::cin &gt;&gt; n;\n    std::vector&lt;int&gt; a(n + 1), b(n + 1), t(n + 1), ne(n + 1), to(n + 1);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; t[i] &gt;&gt; a[i] &gt;&gt; b[i];\n        t[i] = (res + t[i]) % n;\n        if (i == 1)\n            s += b[i], res = (long long)a[i] * b[i];\n        else &#123;\n            int j = ne[i - 1];\n            for (; j &amp;&amp; t[j + 1] != t[i]; j = ne[j]);\n            if (t[j + 1] == t[i])\n                ++j;\n            ne[i] = j;\n            if (t[i] == t[1])\n                s += b[i];\n            to[i - 1] = (t[ne[i - 1] + 1] == t[i] ? to[ne[i - 1]] : ne[i - 1]);\n            for (int j = i - 1; j; )\n                if (t[j + 1] == t[i])\n                    j = to[j];\n                else\n                    for (int at = to[j]; j != at; s -= b[i - j], j = ne[j]);\n            res += a[i] * s;\n        &#125;\n        std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"c.-matching\">C. Matching</h2>\n<p><a href=\"http://222.180.160.110:61235/contest/5658/problem/3\" class=\"uri\">http://222.180.160.110:61235/contest/5658/problem/3</a></p>\n<p>我们发现，如果我们直接要 check 一段 <span class=\"math inline\">\\(a\\)</span> 和 <span class=\"math inline\">\\(p\\)</span>，感觉不太好整。</p>\n<p>然后考虑这么一个问题，假如我们通过神秘方法让我们每次 check 的 <span class=\"math inline\">\\(a\\)</span></p>\n",
            "tags": [
                "哈希",
                "线段树",
                "KMP",
                "border"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20240106/",
            "url": "https://xsc062.netlify.app/20240106/",
            "title": "杂题全谈",
            "date_published": "2024-01-06T03:27:39.000Z",
            "content_html": "<p>想不到好标题了。</p>\n<span id=\"more\"></span>\n<p>有句话怎么说来着，罗马不是一天建成的，是一天天建成的。</p>\n<p>还有什么，Do in Rome as the Romans’ do，还有一句，All roads leads to Rome。</p>\n<hr />\n<h3 id=\"a.-连续的零-zero\">A. 连续的零 zero</h3>\n<p><a href=\"http://222.180.160.110:61235/contest/4647/problem/1\" class=\"uri\">http://222.180.160.110:61235/contest/4647/problem/1</a></p>\n<p>做个前缀和，看看任意一个长度为 <span class=\"math inline\">\\(k\\)</span> 的区间中有几个 <span class=\"math inline\">\\(1\\)</span>。复杂度 <span class=\"math inline\">\\(O(n)\\)</span>。</p>\n<details>\n<pre class=\"cpp\"><code>namespace XSC062 &#123;\nusing namespace fastIO;\nconst int maxn = 5e5 + 5;\nconst int inf = 0x3f3f3f3f;\nint n, m, res = inf;\nint a[maxn], s[maxn];\nint min(int x, int y) &#123;\n    return x &lt; y ? x : y;\n&#125;\nint main() &#123;\n    scanf(&quot;%d %d&quot;, &amp;n, &amp;m);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        scanf(&quot;%1d&quot;, &amp;a[i]);\n        s[i] = s[i - 1] + a[i];\n        if (i &gt;= m)\n            res = min(res, s[i] - s[i - m]);\n    &#125;\n    print(res, &#39;\\n&#39;);\n    return 0;\n&#125;\n&#125; // namespace XSC062</code></pre>\n</details>\n<hr />\n<h3 id=\"b.-反回文串-anti\">B. 反回文串 anti</h3>\n<p><a href=\"http://222.180.160.110:61235/contest/4647/problem/2\" class=\"uri\">http://222.180.160.110:61235/contest/4647/problem/2</a></p>\n<p>当 <span class=\"math inline\">\\(n\\)</span> 为奇时，中间的元素一定和自己相等，故无解。</p>\n<p>当数量最多的一个字符个数超过 <span class=\"math inline\">\\(\\dfrac n2\\)</span> 时，由鸽巢得无解。</p>\n<p>剩下的情况一定有解。</p>\n<details>\n<p><summary>证明</summary></p>\n<p>可以找到一种合法的构造方式。我们列出一个列数为 <span class=\"math inline\">\\(2\\)</span>，行数为 <span class=\"math inline\">\\(\\dfrac n2\\)</span> 的表格，将所有相同字母排列在一起，按照从左到右，从上到下的方式将字母填入表格，最后将第 <span class=\"math inline\">\\(i\\)</span> 行第一列的字母填入 <span class=\"math inline\">\\(a_i\\)</span>，第 <span class=\"math inline\">\\(i\\)</span> 行第二列的字母填入 <span class=\"math inline\">\\(a_{n-i+1}\\)</span>，即可完成构造。</p>\n<p>一种字母只在第一列或第二列出现当然合法，如果从第一列持续到第二列，因为任意字母出现次数不超过 <span class=\"math inline\">\\(\\dfrac n2\\)</span> 次，所以同一行的两列不会出现同一种字母。</p>\n<p>这叫什么，有字证明。</p>\n<p><del>感觉可以拿去出一道类似于「找到字符串字典序最小的反回文串」之类的小水题</del></p>\n</details>\n<p>然后现在我们知道有解了，怎么找到最优解呢。</p>\n<p>比如有一组 <span class=\"math inline\">\\((a_i,a_{n-i+1})=(\\texttt a, \\texttt a)\\)</span>，还有一组 <span class=\"math inline\">\\((a_j, a_{n-j+1})=(\\texttt b, \\texttt b)\\)</span>，那我们直接把 <span class=\"math inline\">\\(a_i\\)</span> 和 <span class=\"math inline\">\\(a_j\\)</span> 交换，皆大欢喜。</p>\n<p>这就说明我们需要把值不相等的非法 <span class=\"math inline\">\\(a_i\\)</span> 与 <span class=\"math inline\">\\(a_j\\)</span> 配对。</p>\n<p>然后我们就可以沿用证明中的构造方式，分组配对，一定最优，每组代价为 <span class=\"math inline\">\\(1\\)</span>。</p>\n<p>同一行两个值 <span class=\"math inline\">\\(v\\)</span> 相等，因为已经最优了，所以不能再在非法串中寻找答案。应该找合法对中某个值交换，每组代价为 <span class=\"math inline\">\\(2\\)</span>。具体和谁交换我们不用担心，只要找到一组 <span class=\"math inline\">\\((a_i,a_{n-i+1})\\)</span> 满足 <span class=\"math inline\">\\(a_i\\ne v\\)</span> 且 <span class=\"math inline\">\\(a_{n-i+1}\\ne v\\)</span> 就可以了，然后我们又知道 <span class=\"math inline\">\\(v\\)</span> 的个数 <span class=\"math inline\">\\(\\ne \\dfrac n2\\)</span>，假设 <span class=\"math inline\">\\(\\dfrac n2\\)</span> 对中每队都有至少一个 <span class=\"math inline\">\\(v\\)</span>，由于当前这一对有两个相同的 <span class=\"math inline\">\\(v\\)</span>，那么 <span class=\"math inline\">\\(v\\)</span> 的个数就会大于 <span class=\"math inline\">\\(\\dfrac n2\\)</span>，矛盾了，所以一定能找到。</p>\n<p>对于非法总对数是奇数的情况，我们要钦定一个非法对强制让其和合法对交换，贪心一下取非法对数量最多的 <span class=\"math inline\">\\(v\\)</span> 的某一对最优。</p>\n<details>\n<pre class=\"cpp\"><code>namespace XSC062 &#123;\nusing namespace fastIO;\nconst int maxm = 35;\nconst int maxn = 2e5 + 5;\nchar s[maxn];\nint cnt[maxm], p[maxn];\nint T, n, tot, res, now;\nint main() &#123;\n    scanf(&quot;%d&quot;, &amp;T);\n    while (T--) &#123;\n        tot = 0;\n        scanf(&quot;%d %s&quot;, &amp;n, s + 1);\n        if (n &amp; 1) &#123;\n            puts(&quot;-1&quot;);\n            continue;\n        &#125;\n        memset(cnt, 0, sizeof (cnt));\n        for (int i = 1; i &lt;= n; ++i)\n            ++cnt[s[i] - &#39;a&#39; + 1];\n        for (int i = 1; i &lt;= 26; ++i) &#123;\n            if (cnt[i] * 2 &gt; n) &#123;\n                puts(&quot;-1&quot;);\n                goto noSol;\n            &#125;\n        &#125;\n        memset(cnt, 0, sizeof (cnt));\n        for (int i = 1; i * 2 &lt;= n; ++i) &#123;\n            if (s[i] == s[n - i + 1])\n                ++cnt[s[i] - &#39;a&#39; + 1], ++tot;\n        &#125;\n        std::sort(cnt + 1, cnt + 27,\n                    std::greater&lt;int&gt;());\n        res = now = 0;\n        if (tot &amp; 1) &#123;\n            res = 1, --cnt[1];\n            std::sort(cnt + 1, cnt + 27,\n                        std::greater&lt;int&gt;());\n        &#125;\n        for (int i = 1; i &lt;= 26; ++i) &#123;\n            while (cnt[i]--) &#123;\n                if (++now &gt; tot / 2) &#123;\n                    if (i == p[now - tot / 2])\n                        res += 2;\n                    else ++res;\n                &#125;\n                else p[now] = i;\n            &#125;\n        &#125;\n        print(res, &#39;\\n&#39;);\n        noSol: ;\n    &#125;\n    return 0;\n&#125;\n&#125; // namespace XSC062</code></pre>\n</details>\n<hr />\n<h3 id=\"c.-除与减-divsub\">C. 除与减 divsub</h3>\n<p><a href=\"http://222.180.160.110:61235/contest/4647/problem/3\" class=\"uri\">http://222.180.160.110:61235/contest/4647/problem/3</a></p>\n<p>小数学，还好。</p>\n<p>假设 <span class=\"math inline\">\\(n=d\\times k^p\\)</span>，其中 <span class=\"math inline\">\\(k\\nmid d\\)</span>，那么我们分两种情况讨论。</p>\n<ol type=\"1\">\n<li><p><span class=\"math inline\">\\(p=0\\)</span>，即 <span class=\"math inline\">\\(k\\nmid n\\)</span>，那么 <span class=\"math inline\">\\(n\\bmod k=1\\)</span>，即 <span class=\"math inline\">\\(k\\mid (n-1)\\)</span>。</p>\n这个时候问 <span class=\"math inline\">\\(k\\)</span> 的个数就相当于是在问 <span class=\"math inline\">\\(n-1\\)</span> 除 <span class=\"math inline\">\\(1\\)</span> 以外的因子个数。假设 <span class=\"math inline\">\\(n-1={x_1}^{p_1}{x_2}^{p_2}\\cdots {x_m}^{p_m}\\)</span>，那么答案为 <span class=\"math inline\">\\((\\prod p_i+1)-1\\)</span>，减去的是 <span class=\"math inline\">\\(1\\)</span>。</li>\n<li><p><span class=\"math inline\">\\(p\\ne 0\\)</span>，<span class=\"math inline\">\\(k\\mid n\\)</span>。</p>\n<p>这个时候好像并没有什么好的转化。好消息是 <span class=\"math inline\">\\(n\\)</span> 的范围是 <span class=\"math inline\">\\(10^{12}\\)</span>，根号枚举因数复杂度跑得过。所以我们就可以暴力判定 <span class=\"math inline\">\\(n\\)</span> 的所有因数是否满足条件。</p></li>\n</ol>\n<p>时间复杂度，<span class=\"math inline\">\\(O(\\sqrt n\\times \\log n)\\)</span>，枚举因数是根号，算次数（也就是算 <span class=\"math inline\">\\(d\\)</span>）是 <span class=\"math inline\">\\(\\log\\)</span>。</p>\n<details>\n<pre class=\"cpp\"><code>#define int long long\nnamespace XSC062 &#123;\nusing namespace fastIO;\nint n, m, res, cnt;\nint main() &#123;\n    read(n), m = n;\n    for (int i = 2; i * i &lt;= n; ++i) &#123;\n        if (n % i == 0) &#123;\n            m = n;\n            while (m % i == 0) m /= i;\n            if (m % i == 1) ++res;\n            if (i * i != n) &#123;\n                m = n;\n                while (m % (n / i) == 0)\n                    m /= (n / i);\n                if (m % (n / i) == 1) ++res;\n            &#125;\n        &#125;\n    &#125;\n    m = n - 1, cnt = 1;\n    for (int i = 2; i * i &lt;= m; ++i) &#123;\n        if (m % i == 0) &#123;\n            int now = 0;\n            while (m % i == 0)\n                ++now, m /= i;\n            cnt *= now + 1;\n        &#125;\n    &#125;\n    if (m != 1) cnt *= 2;\n    print(res + cnt, &#39;\\n&#39;);\n    return 0;\n&#125;\n&#125; // namespace XSC062\n#undef int</code></pre>\n</details>\n<hr />\n<h3 id=\"d.-图书管理员-librarian\">D. 图书管理员 librarian</h3>\n<p><a href=\"http://222.180.160.110:61235/contest/4647/problem/4\" class=\"uri\">http://222.180.160.110:61235/contest/4647/problem/4</a></p>\n<p>[SDOI2008] 郁闷的小 J。</p>\n<p>关于这个，我们发现自己不会考场现冲主席树。哎，打 CDQ 又怕写挂。</p>\n<p>我们发现这道题的修改都是单点的，询问也只关于某一种颜色，不同的颜色之间没有影响。</p>\n<p>于是我们可以把操作离线下来，初始视作将某颜色在某位置增加，修改视作将某颜色在某位置删除，将另一颜色在该位置增加，将所有操作按颜色离散化分类然后 <code>vector</code> 下来，对于所有颜色从前到后树状数组做一遍操作就能 <span class=\"math inline\">\\(O(n\\log n+q\\log n)\\)</span> 解决。</p>\n<p>树状数组清空是肯定不能 <code>memset</code> 的，复杂度不对。那么怎么办呢？把所有操作撤回去就可以了。</p>\n<p>顺带一提我是洛谷上最优解。</p>\n<details>\n<pre class=\"cpp\"><code>namespace XSC062 &#123;\nusing namespace fastIO;\nconst int maxn = 2e5 + 5;\nstruct __ &#123;\n    int ty, l, r, v;\n    __() &#123;&#125;\n    __(int t1, int l1, int r1, int v1 = 0) &#123;\n        if (t1 == 0)\n            ty = 0, l = l1, v = r1;\n        else ty = 1, l = l1, r = r1, v = v1;\n    &#125;\n&#125;;\nchar ty;\nstd::map&lt;int, int&gt; tab;\nstd::vector&lt;__&gt; q[maxn];\nint n, m, tot, x, y, v, id;\nint Bit[maxn], a[maxn], res[maxn];\nint lowbit(int x) &#123; return x &amp; -x; &#125;\nvoid add(int x, int v) &#123;\n    for (; x &lt;= n; x += lowbit(x))\n        Bit[x] += v;\n    return;\n&#125;\nint ask(int x) &#123;\n    int res = 0;\n    for (; x; x -= lowbit(x)) res += Bit[x];\n    return res;\n&#125;\nint main() &#123;\n    read(n), read(m);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        read(a[i]);\n        if (!tab.count(a[i]))\n            tab[a[i]] = ++tot;\n        a[i] = tab[a[i]];\n        q[a[i]].emplace_back(0, i, 1);\n    &#125;\n    while (m--) &#123;\n        scanf(&quot;%1s&quot;, &amp;ty);\n        if (ty == &#39;C&#39;) &#123;\n            read(x), read(y);\n            if (!tab.count(y))\n                tab[y] = ++tot;\n            y = tab[y];\n            q[a[x]].emplace_back(0, x, -1);\n            q[a[x] = y].emplace_back(0, x, 1);\n        &#125;\n        else &#123;\n            ++id;\n            read(x), read(y), read(v);\n            if (!tab.count(v)) continue;\n            v = tab[v];\n            q[v].emplace_back(1, x, y, id);\n        &#125;\n    &#125;\n    for (int i = 1; i &lt;= tot; ++i) &#123;\n        for (auto &amp;j : q[i]) &#123;\n            if (j.ty == 0) add(j.l, j.v);\n            else &#123;\n                res[j.v] =\n                    ask(j.r) - ask(j.l - 1);\n            &#125;\n        &#125;\n        for (auto &amp;j : q[i])\n            if (j.ty == 0) add(j.l, -j.v);\n    &#125;\n    for (int i = 1; i &lt;= id; ++i)\n        print(res[i], &#39;\\n&#39;);\n    return 0;\n&#125;\n&#125; // namespace XSC062</code></pre>\n</details>\n<hr />\n<p>E 会单独开一篇。</p>\n<hr />\n<h3 id=\"f.-树-tree\">F. 树 tree</h3>\n<p><a href=\"http://222.180.160.110:61235/contest/4647/problem/6\" class=\"uri\">http://222.180.160.110:61235/contest/4647/problem/6</a></p>\n<p>CF916E。</p>\n<p>大分讨给我整不会了，更给我整不会的是下来过后发现这只是个小分讨。</p>\n<p>更新子树和子树查询我们都会。换根 DP 我们也都写过，都知道换根并不会对子树结构产生大的影响。所以应当是能根据已知信息推测出子树在原树上对应的点集的。</p>\n<p>记 <span class=\"math inline\">\\(r\\)</span> 为当前树根，<span class=\"math inline\">\\(\\text {LCA}(x,y)\\)</span> 为 <span class=\"math inline\">\\(x,y\\)</span> 在 <span class=\"math inline\">\\(1\\)</span> 为根时的 LCA，<span class=\"math inline\">\\(\\text {LCA}&#39;(x,y)\\)</span> 表示 <span class=\"math inline\">\\(x,y\\)</span> 在 <span class=\"math inline\">\\(r\\)</span> 为根时的 LCA。</p>\n<p>那么对于 <span class=\"math inline\">\\(\\text {LCA}&#39;(x,y)\\)</span>，肯定是要讨论 <span class=\"math inline\">\\(x,y\\)</span> 和 <span class=\"math inline\">\\(r\\)</span> 的位置关系的。</p>\n<ol type=\"1\">\n<li><span class=\"math inline\">\\(\\text {LCA}(x,y)\\)</span> 是 <span class=\"math inline\">\\(r\\)</span> 的子孙。此时 <span class=\"math inline\">\\(\\text {LCA}&#39;(x,y) = \\text {LCA}(x,y)\\)</span>。</li>\n<li><span class=\"math inline\">\\(\\text {LCA}(x,y)\\)</span> 是 <span class=\"math inline\">\\(r\\)</span> 的祖先。那么说明至少有一个点不是 <span class=\"math inline\">\\(r\\)</span> 的子孙。此时 <span class=\"math inline\">\\(\\text {LCA}(x,y)&#39;\\)</span> 的值为 <span class=\"math inline\">\\(r\\)</span> 为另一个点的 LCA。</li>\n</ol>\n<p>整理可得 <span class=\"math inline\">\\(\\text {LCA}&#39;(x,y)\\)</span> 是 <span class=\"math inline\">\\(\\text {LCA}(x,y)\\)</span>、<span class=\"math inline\">\\(\\text {LCA}(x,r)\\)</span> 和 <span class=\"math inline\">\\(\\text {LCA}(y,r)\\)</span> 中的深度最大者。</p>\n<p>对于以 <span class=\"math inline\">\\(r\\)</span> 为根时的子树 <span class=\"math inline\">\\(x\\)</span>：</p>\n<ol type=\"1\">\n<li><span class=\"math inline\">\\(x=r\\)</span>，此时子树为整棵树。</li>\n<li><span class=\"math inline\">\\(\\text {LCA}(x,r)\\ne x\\)</span>，即 <span class=\"math inline\">\\(r\\)</span> 不为 <span class=\"math inline\">\\(x\\)</span> 的子孙，此时子树就是以 <span class=\"math inline\">\\(1\\)</span> 为根是的子树 <span class=\"math inline\">\\(x\\)</span>。</li>\n<li><span class=\"math inline\">\\(\\text {LCA}(x,y)=x\\)</span>，即 <span class=\"math inline\">\\(r\\)</span> 为 <span class=\"math inline\">\\(x\\)</span> 的子孙，此时子树是整棵树除开 <span class=\"math inline\">\\(x\\)</span> 包含 <span class=\"math inline\">\\(r\\)</span> 的儿子及其子孙。修改和查询的时候容斥一下就好。这个时候的子树倍增跳一下就能找到。</li>\n</ol>\n<p>然后就是常规线段树维护了。时间复杂度 <span class=\"math inline\">\\(O(n\\log n)\\)</span>。</p>\n<details>\n<pre class=\"cpp\"><code>namespace XSC062 &#123;\nusing namespace fastIO;\nconst int maxm = 35;\nconst int maxn = 1e5 + 5;\n#define lt (p &lt;&lt; 1)\n#define rt (lt | 1)\nstruct _ &#123; int l, r, u, d; &#125;;\n_ t[maxn &lt;&lt; 2];\nint f[maxn][maxm];\nstd::vector&lt;int&gt; g[maxn];\nint a[maxn], dfn[maxn], rfn[maxn];\nint n, q, r, ty, x, y, v, si, now;\nint top[maxn], dep[maxn], tab[maxn];\nvoid swap(int &amp;x, int &amp;y) &#123;\n    x ^= y ^= x ^= y;\n    return;\n&#125;\nvoid DFS(int x) &#123;\n    dep[x] = dep[f[x][0]] + 1;\n    dfn[x] = ++now, tab[now] = x;\n    for (auto i : g[x]) &#123;\n        if (i == f[x][0]) continue;\n        f[i][0] = x;\n        for (int j = 1; j &lt;= si; ++j)\n            f[i][j] = f[f[i][j - 1]][j - 1];\n        DFS(i);\n    &#125;\n    rfn[x] = now;\n    return;\n&#125;\nvoid pushup(int p) &#123;\n    t[p].u = t[lt].u + t[rt].u;\n    return;\n&#125;\nvoid pushdown(int p) &#123;\n    if (t[p].d) &#123;\n        t[lt].d += t[p].d;\n        t[rt].d += t[p].d;\n        t[lt].u += t[p].d *\n                (t[lt].r - t[lt].l + 1);\n        t[rt].u += t[p].d *\n                (t[rt].r - t[rt].l + 1);\n        t[p].d = 0;\n    &#125;\n    return;\n&#125;\nvoid bld(int p, int l, int r) &#123;\n    t[p].l = l, t[p].r = r;\n    if (l == r) &#123;\n        t[p].u = a[tab[l]];\n        return;\n    &#125;\n    int mid = (l + r) &gt;&gt; 1;\n    bld(lt, l, mid), bld(rt, mid + 1, r);\n    pushup(p);\n    return;\n&#125;\nvoid add(int p, int x, int v) &#123;\n    t[p].u += v;\n    if (t[p].l == t[p].r) return;\n    pushdown(p);\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (x &lt;= mid) add(lt, x, v);\n    else add(rt, x, v);\n    return;\n&#125;\nvoid add(int p, int l, int r, int v) &#123;\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r) &#123;\n        t[p].d += v;\n        t[p].u += (t[p].r - t[p].l + 1) * v;\n        return;\n    &#125;\n    pushdown(p);\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (l &lt;= mid) add(lt, l, r, v);\n    if (r &gt; mid) add(rt, l, r, v);\n    pushup(p);\n    return;\n&#125;\nint ask(int p, int l, int r) &#123;\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r)\n        return t[p].u;\n    pushdown(p);\n    int res = 0,\n        mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (l &lt;= mid) res = ask(lt, l, r);\n    if (r &gt; mid) res += ask(rt, l, r);\n    return res;\n&#125;\nint LCA(int x, int y) &#123;\n    if (dep[x] &lt; dep[y]) swap(x, y);\n    for (int i = si; ~i; --i) &#123;\n        if (dep[f[x][i]] &gt;= dep[y])\n            x = f[x][i];\n    &#125;\n    if (x == y) return x;\n    for (int i = si; ~i; --i) &#123;\n        if (f[x][i] != f[y][i])\n            x = f[x][i], y = f[y][i];\n    &#125;\n    return f[x][0];\n&#125;\nvoid Add(int x, int v) &#123;\n    int rlca = LCA(r, x);\n    if (x == r) add(1, 1, n, v);\n    else if (rlca != x)\n        add(1, dfn[x], rfn[x], v);\n    else &#123;\n        add(1, 1, n, v);\n        int p = r;\n        for (int i = si; ~i; --i) &#123;\n            if (dep[f[p][i]] &gt;= dep[x] + 1)\n                p = f[p][i];\n        &#125;\n        add(1, dfn[p], rfn[p], -v);\n    &#125;\n    return;\n&#125;\nvoid tAdd(int x, int y, int v) &#123;\n    int llca = LCA(r, x), rlca = LCA(r, y),\n        ulca = LCA(x, y);\n    if (dep[llca] &gt;= dep[rlca] &amp;&amp;\n        dep[llca] &gt;= dep[ulca]) Add(llca, v);\n    else if (dep[rlca] &gt;= dep[llca] &amp;&amp;\n        dep[rlca] &gt;= dep[ulca]) Add(rlca, v);\n    else Add(ulca, v);\n    return;\n&#125;\nint tAsk(int x) &#123;\n    int rlca = LCA(r, x);\n    if (x == r) return t[1].u;\n    if (rlca != x)\n        return ask(1, dfn[x], rfn[x]);\n    int p = r;\n    for (int i = si; ~i; --i) &#123;\n        if (dep[f[p][i]] &gt;= dep[x] + 1)\n            p = f[p][i];\n    &#125;\n    return t[1].u - ask(1, dfn[p], rfn[p]);\n&#125;\nvoid add(int x, int y) &#123;\n    g[x].push_back(y);\n    return;\n&#125;\nint main() &#123;\n    read(n), read(q), r = 1;\n    si = log(n) / log(2.0);\n    for (int i = 1; i &lt;= n; ++i) read(a[i]);\n    for (int i = 1; i &lt; n; ++i) &#123;\n        read(x), read(y);\n        add(x, y), add(y, x);\n    &#125;\n    dep[0] = 1, DFS(1), dep[0] = 0;\n    bld(1, 1, n);\n    while (q--) &#123;\n        read(ty);\n        if (ty == 1) read(r);\n        else if (ty == 2) &#123;\n            read(x), read(y), read(v);\n            tAdd(x, y, v);\n        &#125;\n        else &#123;\n            read(x);\n            print(tAsk(x), &#39;\\n&#39;);\n        &#125;\n    &#125;\n    return 0;\n&#125;\n&#125; // namespace XSC062\n#undef int</code></pre>\n</details>\n",
            "tags": [
                "线段树",
                "树状数组",
                "LCA",
                "倍增",
                "鸽巢原理"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20231003/",
            "url": "https://xsc062.netlify.app/20231003/",
            "title": "杂题",
            "date_published": "2023-10-03T08:42:43.000Z",
            "content_html": "<p><a href=\"http://222.180.160.110:61235/contest/4268\">周考 14</a>。</p>\n<span id=\"more\"></span>\n<hr />\n<p>医生问我对药有什么要求吗，我说我宁死不喝冲剂。</p>\n<p>然后医生给我开了五盒胶囊，告诉我说一天三次，一次六个。</p>\n<p>哈哈哈，我自找的。以此为证，A 一道题磕一片！！！</p>\n<hr />\n<h3 id=\"a.-修改序列\">A. 修改序列</h3>\n<p><a href=\"http://222.180.160.110:61235/contest/4268/problem/1\" class=\"uri\">http://222.180.160.110:61235/contest/4268/problem/1</a></p>\n<p>注意到一增一减，全数列的和 <span class=\"math inline\">\\(s\\)</span> 不变，考虑这一点带来的提示。</p>\n<p>假设最后要求一部分数为 <span class=\"math inline\">\\(p\\)</span>，另一部分为 <span class=\"math inline\">\\(p+1\\)</span>，那么有 <span class=\"math inline\">\\(p = \\lfloor \\dfrac sn \\rfloor\\)</span>，<span class=\"math inline\">\\(p+1\\)</span> 的数量 <span class=\"math inline\">\\(c_r=s\\bmod n\\)</span>，<span class=\"math inline\">\\(p\\)</span> 的数量 <span class=\"math inline\">\\(c_l=n-c_r\\)</span>。</p>\n<p>那么我们让 <span class=\"math inline\">\\(\\le p\\)</span> 的变成 <span class=\"math inline\">\\(p\\)</span>，<span class=\"math inline\">\\(\\ge p + 1\\)</span> 的变成 <span class=\"math inline\">\\(p + 1\\)</span>。直接求两数距离，最后将总和除以二即为答案、</p>\n<details>\n<p><summary>正确性证明…</summary></p>\n<p>这样做的最优性毫无疑问，问题无非就在于这么做的正确性，换言之，为什么一定能找到合法的操作序列还原我们的求解过程。</p>\n<p>将原数列分为两部分，数值 <span class=\"math inline\">\\(\\le p\\)</span> 的（记为 <span class=\"math inline\">\\(X\\)</span>）和数值 <span class=\"math inline\">\\(\\ge p + 1\\)</span> 的（记为 <span class=\"math inline\">\\(Y\\)</span>）。</p>\n<p>再把我们的目标状态分为两部分，数值 <span class=\"math inline\">\\(= p\\)</span> 的（记为 <span class=\"math inline\">\\(A\\)</span>）和 数值 <span class=\"math inline\">\\(=p + 1\\)</span> 的（记为 <span class=\"math inline\">\\(B\\)</span>）。</p>\n<p>那么有 <span class=\"math inline\">\\(\\begin{cases}X+Y=s\\\\A+B=s\\end{cases}\\)</span>，由等式的基本性质得 <span class=\"math inline\">\\(X-A+Y-B = 0\\)</span>，移项得 <span class=\"math inline\">\\(Y-B=A-X\\)</span>。也就是说，<span class=\"math inline\">\\(Y\\)</span> 部分与 <span class=\"math inline\">\\(p+1\\)</span> 的差的总和正好等于 <span class=\"math inline\">\\(X\\)</span> 部分与 <span class=\"math inline\">\\(p\\)</span> 的差的总和。</p>\n<p>这个时候我们的正确性就有了保证。</p>\n<p>这个时候你可能就有疑问了，<span class=\"math inline\">\\(X,Y\\)</span> 中的元素个数和 <span class=\"math inline\">\\(A,B\\)</span> 中的元素个数并不对应，怎么办呢？</p>\n<p>我们发现上面的原理式并不会随元素个数的变化而变化，所以依然可以用它来解答这个问题。没有人规定 <span class=\"math inline\">\\(Y-B\\)</span> 和 <span class=\"math inline\">\\(A-X\\)</span> 不能为负，为负时我们把 <span class=\"math inline\">\\(A\\)</span> 中塞不下的 <span class=\"math inline\">\\(X\\)</span> 拿到 <span class=\"math inline\">\\(B\\)</span> 里面去即可，反之同理。</p>\n</details>\n<p>那么代码还是很好写的。时间复杂度 <span class=\"math inline\">\\(O(n)\\)</span>。</p>\n<details>\n<pre class=\"cpp\"><code>namespace XSC062 &#123;\nusing namespace fastIO;\nconst int maxn = 2e5 + 5;\nint a[maxn];\nint n, s, p, cl, cg, res;\nint main() &#123;\n    read(n);\n    for (int i = 1; i &lt;= n; ++i)\n        read(a[i]), s += a[i];\n    p = s / n, cg = s - p * n, cl = n - cg;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        if (a[i] &lt;= p) &#123;\n            if (cl) res += p - a[i], --cl;\n            else res += p - a[i] + 1, --cg;\n        &#125;\n        else &#123;\n            if (cg) res += a[i] - p - 1, --cg;\n            else res += a[i] - p, --cl;\n        &#125;\n    &#125;\n    print(res / 2, &#39;\\n&#39;);\n    return 0;\n&#125;\n&#125; // namespace XSC062</code></pre>\n</details>\n<hr />\n<h3 id=\"b.-knuth-表示法\">B. Knuth 表示法</h3>\n<p><a href=\"http://222.180.160.110:61235/contest/4268/problem/2\" class=\"uri\">http://222.180.160.110:61235/contest/4268/problem/2</a></p>\n<p>模拟。输入的数用 <code>map</code> 转化为 <span class=\"math inline\">\\(10\\)</span> 的次幂形式，然后幂次直接相加即表示指数相乘。</p>\n<p>最后按位数从大到小将次幂形式转化为字符串、再按位数从小到大输出。</p>\n<p>注意到开头的字符串不是 <code>one</code> 就是 <code>ten</code>，需要在没有抽出来 <code>ten</code> 的时候补 <code>one</code>。</p>\n<details>\n<pre class=\"cpp\"><code>namespace XSC062 &#123;\nusing namespace fastIO;\nusing str = std::string;\nconst str u[] = &#123; &quot;one&quot;, &quot;ten&quot;, &quot;hundred&quot;, &quot;myriad&quot;, &quot;myllion&quot;, &quot;byllion&quot;, &quot;tryllion&quot;,\n                  &quot;quadryllion&quot;, &quot;quintyllion&quot;, &quot;sextyllion&quot;, &quot;septyllion&quot;, &quot;octyllion&quot;,\n                  &quot;nonyllion&quot;, &quot;decyllion&quot; &#125;;\nstr x;\nint res = 0;\nstd::stack&lt;str&gt; s;\nstd::map&lt;str, int&gt; t;\nvoid get(str &amp;x) &#123;\n    str y;\n    std::stringstream p(x);\n    while (p &gt;&gt; y) &#123;\n        if (y == &quot;one&quot;) continue;\n        res += 1 &lt;&lt; (t[y] - 1);\n    &#125;\n    return;\n&#125;\nint main() &#123;\n    for (int i = 0; i &lt;= 13; ++i) t[u[i]] = i;\n    std::getline(std::cin, x), get(x);\n    std::getline(std::cin, x), get(x);\n    for (int i = 13; i; --i) &#123;\n        if (res &amp; (1 &lt;&lt; (i - 1)))\n            s.push(u[i]), res ^= (1 &lt;&lt; (i - 1));\n    &#125;\n    if (s.top() != &quot;ten&quot;) s.push(&quot;one&quot;);\n    while (!s.empty())\n        std::cout &lt;&lt; s.top() &lt;&lt; &#39; &#39;, s.pop();\n    return 0;\n&#125;\n&#125; // namespace XSC062</code></pre>\n</details>\n<hr />\n<h3 id=\"c.-魔力塔\">C. 魔力塔</h3>\n<p><a href=\"http://222.180.160.110:61235/contest/4268/problem/3\" class=\"uri\">http://222.180.160.110:61235/contest/4268/problem/3</a></p>\n<p>神奇的线段树优化建图。这拿来放 T3？不合适吧。</p>\n<p>很好想到对于 <span class=\"math inline\">\\(a_i\\ne -1\\)</span>，连边 <span class=\"math inline\">\\(i\\to a_i\\)</span>；否则，连边 <span class=\"math inline\">\\(i\\to x(x\\in [i+1,\\min(i + k,n+1)])\\)</span>。BFS 遍历，复杂度 <span class=\"math inline\">\\(O(n\\times k)\\)</span>。</p>\n<p>问题在于无用边太多，例如 <span class=\"math inline\">\\(i\\)</span> 和 <span class=\"math inline\">\\(i+1\\)</span> 共同可达的点有整整 <span class=\"math inline\">\\(k-1\\)</span> 个，造成大量浪费。</p>\n<p>考虑到实际进入 BFS 的点只有 <span class=\"math inline\">\\(n\\)</span> 个，及由传送门构成的连通块均呈棒棒糖状（即链套环），我们直接优化掉 <span class=\"math inline\">\\(a_i=-1\\)</span> 时的连边。使用线段树查询 <span class=\"math inline\">\\([i+1,\\min(i + k,n+1)]\\)</span> 内的所有剩余点，连边入队并从线段树中删除。</p>\n<p>这样，每个点只会入队一次（忽视无用环），时间复杂度控制在 <span class=\"math inline\">\\(O(n\\log n)\\)</span>，<span class=\"math inline\">\\(\\log\\)</span> 来源于线段树，写得不好就是 <span class=\"math inline\">\\(\\log^2\\)</span>，写得好一点就只有一个。</p>\n<details>\n<p><summary>然而…</summary></p>\n<p>会 T，因为常数太大了。</p>\n<p>所以我们需要另一种 <span class=\"math inline\">\\(\\log\\)</span> 的做法，并且短小精悍。</p>\n<p>用 <code>set</code> 存储所有未入队的点，每次 <code>lower_bound</code> 并依次弹出、入队。</p>\n</details>\n<p>用迭代器的话代码很短，美汁汁。</p>\n<p>时间复杂度 <span class=\"math inline\">\\(O(n\\log n)\\)</span>，但等我先磕片药先。</p>\n<details>\n<pre class=\"cpp\"><code>namespace XSC062 &#123;\nusing namespace fastIO;\nconst int maxn = 5e5 + 5;\nint a[maxn];\nint n, k, res;\nbool vis[maxn];\nstd::set&lt;int&gt; t;\nstd::vector&lt;int&gt; g[maxn]; \nint max(int x, int y) &#123; return x &gt; y ? x : y; &#125;\nvoid DFS(int x) &#123;\n    res = max(res, x);\n    if (a[x] == -1) &#123;\n        auto p = t.lower_bound(x + 1);\n        while (p != t.end() &amp;&amp; *p &lt;= x + k) &#123;\n            g[x].push_back(*p);\n            t.erase(*p++);\n        &#125;\n    &#125;\n    for (auto i : g[x]) &#123;\n        if (vis[i]) continue;\n        vis[i] = 1, DFS(i);\n    &#125;\n    return;\n&#125;\nint main() &#123;\n    read(n), read(k);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        read(a[i]), t.insert(i + 1);\n        if (~a[i]) g[i].push_back(a[i]);\n    &#125;\n    DFS(1), print(res, &#39;\\n&#39;);\n    return 0;\n&#125;\n&#125; // namespace XSC062</code></pre>\n</details>\n<hr />\n<h3 id=\"d.-卡牌游戏\">D. 卡牌游戏</h3>\n<p><a href=\"http://222.180.160.110:61235/contest/4268/problem/4\" class=\"uri\">http://222.180.160.110:61235/contest/4268/problem/4</a></p>\n<p>怎么说呢，爆搜可以拿 80pts！！！然而正解是区间 DP，哭唧唧。他这个数据范围给得很神奇，让人只会往搜索上面想。</p>\n<p>摧毁操作是一换一，不会更改串长，而入栈操作会增加初始串的长度。</p>\n<p>所以我们考虑 <strong>逆序 DP</strong>，从最终状态入手，用 <span class=\"math inline\">\\(f_{x, i, j}\\)</span> 表示是否可以使用一个字符 <span class=\"math inline\">\\(x\\)</span> 经过一系列操作消掉 <span class=\"math inline\">\\(w_{i\\sim j}\\)</span>。</p>\n<p>那么明显若一条摧毁操作为可用字符 <span class=\"math inline\">\\(a\\)</span> 摧毁 <span class=\"math inline\">\\(w_i\\)</span>，有 <span class=\"math inline\">\\(f_{a, i, i} = 1\\)</span>。</p>\n<p>若一条入栈操作为用字符 <span class=\"math inline\">\\(a\\)</span> 换字符 <span class=\"math inline\">\\(b,c\\)</span>，枚举区间断点 <span class=\"math inline\">\\(k\\)</span>，有 <span class=\"math inline\">\\(f_{a, i, j} = f_{b, i, k} \\times f_{c, k + 1, j}\\)</span>。</p>\n<p>最后答案为 <span class=\"math inline\">\\(f_{\\texttt S,i,|w_i|}\\)</span>。</p>\n<p>注意循环顺序，区间的枚举应在字符的枚举之外。最终时间复杂度 <span class=\"math inline\">\\(O(T\\times |w_i|^3\\times N_2)\\)</span>，注意到字母的枚举属于常数。胶囊好吃滴捏。</p>\n<details>\n<pre class=\"cpp\"><code>namespace XSC062 &#123;\nusing namespace fastIO;\nconst int maxn = 25;\nconst int maxm = 1e3 + 5;\nint n, m, l;\nchar w[maxn];\nbool r1[maxm][maxm];\nbool f[maxm][maxn][maxn];\nstruct &#123; int u, a, b; &#125; r2[maxn];\nint main() &#123;\n    scanf(&quot;%d %d&quot;, &amp;n, &amp;m);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        scanf(&quot;%s&quot;, w + 1);\n        r1[(int)w[1]][(int)w[4]] = 1;\n    &#125;\n    for (int i = 1; i &lt;= m; ++i) &#123;\n        scanf(&quot;%s&quot;, w + 1);\n        r2[i].u = w[1];\n        r2[i].a = w[4], r2[i].b = w[5];\n    &#125;\n    while (~scanf(&quot;%s&quot;, w + 1)) &#123;\n        memset(f, 0, sizeof (f));\n        l = strlen(w + 1);\n        for (int i = &#39;A&#39;; i &lt;= &#39;Z&#39;; ++i) &#123;\n            for (int j = 1; j &lt;= l; ++j) &#123;\n                if (r1[i][(int)w[j]])\n                    f[i][j][j] = 1;\n            &#125;\n        &#125;\n        for (int len = 1; len &lt;= l; ++len) &#123;\n            for (int i = 1; i &lt;= l - len + 1; ++i) &#123;\n                int j = i + len - 1;\n                for (int t = &#39;A&#39;; t &lt;= &#39;Z&#39;; ++t) &#123;\n                    for (int k = i; k &lt; j; ++k) &#123;\n                        for (int p = 1; p &lt;= m; ++p) &#123;\n                            if (r2[p].u != t) continue;\n                            f[t][i][j] |= f[r2[p].a][i][k] &amp;&amp; f[r2[p].b][k + 1][j];\n                        &#125;\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n        puts(f[&#39;S&#39;][1][l] ? &quot;YES&quot; : &quot;NO&quot;);\n    &#125;\n    return 0;\n&#125;\n&#125; // namespace XSC062</code></pre>\n</details>\n<hr />\n<h3 id=\"e.-生长树\">E. 生长树</h3>\n<p><a href=\"http://222.180.160.110:61235/contest/4268/problem/5\" class=\"uri\">http://222.180.160.110:61235/contest/4268/problem/5</a></p>\n<p>一道很菜的题。我们发现有子树操作，第一时间想到树剖，那么接下来要考虑的内容就是线段树如何维护。</p>\n<p>题意换句话说就是往下数 0 代是加，数 1 代是减，数 2 代是加，以此类推。那么不难想到奇偶性。</p>\n<p>如果起点的深度是奇数，那么子树中所有奇数深度权值增加，偶数深度权值减少，反之同理。</p>\n<p>但是我们操作线段树的时候怎么知道点在树中的深度奇偶性呢？我们只能在线段树外才知道呀。</p>\n<p>所以观察询问，询问是单点的，所以我们知道了，可以只在线段树外对奇偶性进行处理。简单来说，假设更改起点深度为奇数，那么增加整个子树的「奇加偶减计数器」；反之，增加整个子树的「奇减偶加计数器」。</p>\n<p>最后查询的时候，如果该点深度为奇，那么答案为对应的「奇加偶减计数器」减去「奇减偶加计数器」的值，反之同理。</p>\n<p>做到最后发现根本不用树剖，就是一个 DFN 上线段树。时间复杂度 <span class=\"math inline\">\\(O(m\\log n)\\)</span>。</p>\n<p>胶囊真好吃！！！</p>\n<details>\n<pre class=\"cpp\"><code>namespace XSC062 &#123;\nusing namespace fastIO;\n#define lt (p &lt;&lt; 1)\n#define rt (lt | 1)\nconst int maxn = 2e5 + 5;\nstruct _ &#123;\n    int l, r;\n    int u1, u2, d1, d2;\n&#125;; \n_ t[maxn &lt;&lt; 2];\nint a[maxn], dep[maxn];\nstd::vector&lt;int&gt; g[maxn];\nint n, m, x, y, tot, typ;\nint end[maxn], dfn[maxn], tab[maxn];\n// u 只用维护最底层信息\n// 所以不用打 pushup \n// 但维护起来好看一些 所以还是打了\nvoid pushup(int p) &#123;\n    t[p].u1 = t[lt].u1 + t[rt].u1;\n    t[p].u2 = t[lt].u2 + t[rt].u2;\n    return;\n&#125;\nvoid pushdown(int p) &#123;\n    if (t[p].d1) &#123;\n        t[lt].d1 += t[p].d1;\n        t[rt].d1 += t[p].d1;\n        t[lt].u1 += t[p].d1 * (t[lt].r - t[lt].l + 1);\n        t[rt].u1 += t[p].d1 * (t[rt].r - t[rt].l + 1);\n        t[p].d1 = 0;\n    &#125;\n    if (t[p].d2) &#123;\n        t[lt].d2 += t[p].d2;\n        t[rt].d2 += t[p].d2;\n        t[lt].u2 += t[p].d2 * (t[lt].r - t[lt].l + 1);\n        t[rt].u2 += t[p].d2 * (t[rt].r - t[rt].l + 1);\n        t[p].d2 = 0;\n    &#125;\n    return;\n&#125;\nvoid bld(int p, int l, int r) &#123;\n    t[p].l = l, t[p].r = r;\n    if (l == r) &#123;\n        if (dep[tab[l]] &amp; 1)\n            t[p].u1 = a[tab[l]];\n        else t[p].u2 = a[tab[l]];\n        return;\n    &#125;\n    int mid = (l + r) &gt;&gt; 1;\n    bld(lt, l, mid), bld(rt, mid + 1, r);\n    pushup(p);\n    return;\n&#125;\nvoid add1(int p, int l, int r, int x) &#123;\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r) &#123;\n        t[p].d1 += x;\n        t[p].u1 += (t[p].r - t[p].l + 1) * x;\n        return;\n    &#125;\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    pushdown(p);\n    if (l &lt;= mid) add1(lt, l, r, x);\n    if (r &gt; mid) add1(rt, l, r, x);\n    pushup(p);\n    return;\n&#125;\nvoid add2(int p, int l, int r, int x) &#123;\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r) &#123;\n        t[p].d2 += x;\n        t[p].u2 += (t[p].r - t[p].l + 1) * x;\n        return;\n    &#125;\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    pushdown(p);\n    if (l &lt;= mid) add2(lt, l, r, x);\n    if (r &gt; mid) add2(rt, l, r, x);\n    pushup(p);\n    return;\n&#125;\nint ask(int p, int x) &#123;\n    if (t[p].l == t[p].r)\n        return t[p].u1 - t[p].u2;\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    pushdown(p);\n    if (x &lt;= mid) return ask(lt, x);\n    return ask(rt, x);\n&#125;\nvoid DFS(int x, int fa) &#123;\n    dfn[x] = ++tot, tab[tot] = x;\n    for (auto i : g[x]) &#123;\n        if (i == fa) continue;\n        dep[i] = dep[x] + 1;\n        DFS(i, x);\n    &#125;\n    end[x] = tot;\n    return;\n&#125;\nvoid add(int x, int y) &#123;\n    g[x].push_back(y);\n    return;\n&#125;\nint main() &#123;\n    read(n), read(m);\n    for (int i = 1; i &lt;= n; ++i)\n        read(a[i]);\n    for (int i = 1; i &lt; n; ++i) &#123;\n        read(x), read(y);\n        add(x, y), add(y, x);\n    &#125;\n    dep[1] = 1, DFS(1, -1);\n    bld(1, 1, n);\n    while (m--) &#123;\n        read(typ), read(x);\n        if (typ == 1) &#123;\n            read(y);\n            if (dep[x] &amp; 1)\n                add1(1, dfn[x], end[x], y);\n            else add2(1, dfn[x], end[x], y);\n        &#125;\n        else &#123;\n            int res = ask(1, dfn[x]);\n            if (dep[x] &amp; 1)\n                print(res, &#39;\\n&#39;);\n            else print(-res, &#39;\\n&#39;);\n        &#125;\n    &#125;\n    return 0;\n&#125;\n&#125; // namespace XSC062</code></pre>\n</details>\n<hr />\n<h3 id=\"f.-单词\">F. 单词</h3>\n<p><a href=\"http://222.180.160.110:61235/contest/4268/problem/6\" class=\"uri\">http://222.180.160.110:61235/contest/4268/problem/6</a></p>\n<p><span class=\"math inline\">\\(n \\le 20\\)</span>，考虑状压。用 <span class=\"math inline\">\\(f_x\\)</span> 表示状态为 <span class=\"math inline\">\\(x\\)</span> 时的最小代价，其中 <span class=\"math inline\">\\(x\\)</span> 是字符串合法情况的状态压缩。</p>\n<p>对于每一个待满足的串，枚举去满足它的哪一位，那么满足方式分两种情况：</p>\n<ul>\n<li>把它变成一个新的值</li>\n<li><p>把和它重合的变成新的值</p>\n<p>我们注意到 <span class=\"math inline\">\\(n \\le 20 \\le 26\\)</span>，所以一定能找到一种方法让每个串的这一位都不一样。</p>\n<p>接着，反正我们都要改这一位了，那就贪心地把要改的全部改成完全不一样的。那么这些要改的串也在这一位上满足了条件。</p></li>\n</ul>\n<p>所以，假设对于状态 <span class=\"math inline\">\\(i\\)</span>，有串 <span class=\"math inline\">\\(j\\)</span> 未满足，枚举位置 <span class=\"math inline\">\\(k\\)</span>，有：</p>\n<pre class=\"cpp\"><code>f[i | (1 &lt;&lt; (j - 1))] = min(f[i | (1 &lt;&lt; (j - 1))], f[i] + a[j][k]); \nf[i | lac[j][k]] = min(f[i | lac[j][k]], f[i] + mx[j][k]);</code></pre>\n<p>其中 <code>lac[j][k]</code> 和 <code>mx[j][k]</code> 都是预处理出来的值。<code>lac[j][k]</code> 表示与第 <span class=\"math inline\">\\(j\\)</span> 个串的第 <span class=\"math inline\">\\(k\\)</span> 位相同串的状态压缩；<code>mx[j][k]</code> 表示通过第二种方式将 <span class=\"math inline\">\\(j\\)</span> 串的第 <span class=\"math inline\">\\(k\\)</span> 位变得合法的最小费用。</p>\n<p><code>lac[j][k]</code> 的求法没有任何疑问，主要是在 <code>mx[j][k]</code> 上。注意到假设这一位上有 <span class=\"math inline\">\\(x\\)</span> 个串与 <span class=\"math inline\">\\(j\\)</span> 串的第 <span class=\"math inline\">\\(k\\)</span> 位相同（包括其本身），而我们只需要将这当中的 <span class=\"math inline\">\\(x-1\\)</span> 个变成两两不同的全新字符就可以同时满足这 <span class=\"math inline\">\\(x\\)</span> 串的条件，那我们为什么不把不动的这一个串设置为 <span class=\"math inline\">\\(x\\)</span> 个串中改这一位代价最大的那个呢？</p>\n<p>那么问题来了。我们枚举状态、枚举状态中的每一个 <code>0</code>，枚举每一个串的每一位，实际上是 <span class=\"math inline\">\\(O(n\\times m\\times 2^n)\\)</span> 的。虽然跑不满，但这个时间复杂度仍然是有问题的。我们需要优化。</p>\n<p>我们枚举的是状态中的每一个 <code>0</code>，假设我们的状态是 <code>000</code>，我们的解决方案是将三个 <code>0</code> 位置的方案共同处理，表示为 <code>'0--'</code> + <code>'-0-'</code> + <code>'--0'</code>。但实际上，我们只用实际求解一个 <code>0</code> 位置的答案，表示为 <code>'0--'</code> + <code>'-00'</code> 。</p>\n<p>也就是说，我们原本需要枚举每一个状态为 <code>0</code> 的 <span class=\"math inline\">\\(j\\)</span> 并用 <span class=\"math inline\">\\(O(m)\\)</span> 的时间进行计算，现在我们碰到一个状态为 <code>0</code> 的 <span class=\"math inline\">\\(j\\)</span> 就开始计算，得到完全相同的答案。</p>\n<p>很 NB 并且很实用的优化，已加入 <a href=\"/20231117/\">下饭操作合集</a>。</p>\n<details>\n<pre class=\"cpp\"><code>namespace XSC062 &#123;\nusing namespace fastIO;\nconst int maxn = 205;\nconst int maxm = (1 &lt;&lt; 25) + 5;\nint f[maxm];\nint n, m, siz;\nchar s[maxn][maxn];\nint lac[maxn][maxn];\nint a[maxn][maxn], mx[maxn][maxn];\nint min(int x, int y) &#123; return x &lt; y ? x : y; &#125;\nint max(int x, int y) &#123; return x &gt; y ? x : y; &#125;\nint main() &#123;\n    while(~scanf(&quot;%d %d&quot;, &amp;n, &amp;m)) &#123;\n        memset(f, 0x3f, sizeof (f));\n        f[0] = 0, siz = 1 &lt;&lt; n;\n        for (int i = 1; i &lt;= n; ++i)\n            scanf(&quot;%s&quot;, s[i] + 1);\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            for (int j = 1; j &lt;= m; ++j)\n                scanf(&quot;%d&quot;, &amp;a[i][j]);\n        &#125;\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            for (int j = 1; j &lt;= m; ++j) &#123;\n                int sum = 0;\n                lac[i][j] = mx[i][j] = 0;\n                for (int k = 1; k &lt;= n; ++k) &#123;\n                    if (s[k][j] == s[i][j]) &#123;\n                        lac[i][j] |= 1 &lt;&lt; (k - 1);\n                        sum += a[k][j];\n                        mx[i][j] = max(mx[i][j], a[k][j]);\n                    &#125;\n                &#125;\n                mx[i][j] = sum - mx[i][j];\n            &#125;\n        &#125;\n        for (int i = 0, j; i &lt; siz - 1; ++i) &#123;\n            for (j = 1; j &lt;= n; ++j) &#123;\n                if (!(i &amp; (1 &lt;&lt; (j - 1))))\n                    break;\n            &#125;\n            for (int k = 1; k &lt;= m; ++k) &#123;\n                f[i | (1 &lt;&lt; (j - 1))] =\n                    min(f[i | (1 &lt;&lt; (j - 1))], f[i] + a[j][k]); \n                f[i | lac[j][k]] =\n                    min(f[i | lac[j][k]], f[i] + mx[j][k]);\n            &#125;\n        &#125;\n        print(f[siz - 1], &#39;\\n&#39;);\n    &#125;\n    return 0;\n&#125;\n&#125; // namespace XSC062</code></pre>\n</details>\n<hr />\n<p>这次暴露出的问题：</p>\n<ul>\n<li>深度乱求，打代码的时候考虑过要放在递归之前，但是由于精力不集中最后还是放在了递归后面。</li>\n</ul>\n<p>没了。这次主要问题出在 T5。T3 估计真的想不到，先不强求自己。</p>\n<p>这次学到的新知识：</p>\n<ul>\n<li>对于子集合并最优性的问题，可以用单点 + 集合代替集合 + 集合枚举。</li>\n</ul>\n",
            "tags": [
                "DP",
                "线段树"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20230928/",
            "url": "https://xsc062.netlify.app/20230928/",
            "title": "颜色",
            "date_published": "2023-09-28T08:44:30.000Z",
            "content_html": "<p>Solution to <a href=\"https://vjudge.net/contest/583230#problem/B\">颜色</a>。</p>\n<span id=\"more\"></span>\n<hr />\n<h3 id=\"b---颜色\">B - 颜色</h3>\n<p><a href=\"https://vjudge.net/contest/583230#problem/B\" class=\"uri\">https://vjudge.net/contest/583230#problem/B</a></p>\n<p>颜色删完过后剩下的肯定是一段区间。</p>\n<p>那么区间外的所有颜色都会被删掉，如果要满足题目条件的话，删掉的颜色不能出现在区间内。</p>\n<p>那么就可以有这么一个题意的转化：寻找区间的个数，满足区间内的颜色只出现在区间内。</p>\n<p>然后你可能就要问了，不是还要满足区间外的所有颜色都不出现在区间内吗。但是你想想，要是它出现在区间内了，它作为区间内的颜色，不就不满足我们上面说的那条规则了吗。</p>\n<p>这个转化是非常厉害的。那么这个时候有一个显而易见暴力做法，我们记录一个颜色在整个序列中出现的第一个位置（记为 <span class=\"math inline\">\\(L_x\\)</span>）和最后一个位置（记作 <span class=\"math inline\">\\(R_x\\)</span>），然后枚举每一个区间 <span class=\"math inline\">\\([i, j]\\)</span>，再枚举其中的每一个颜色，看看有没有超出去就好，复杂度 <span class=\"math inline\">\\(O(n^3)\\)</span>。</p>\n<details>\n<summary>对纯暴力的一点小优化</summary> 上述区间内枚举过程转化为判定区间是否满足 <span class=\"math inline\">\\({L_x}_{\\min} \\ge i\\)</span> 且 <span class=\"math inline\">\\({R_x}_{\\max} \\le j\\)</span>，采用数据结构维护，就可以优化到 <span class=\"math inline\">\\(O(n^2\\log)\\)</span>。为什么要专门提一嘴这个呢，因为这个模型我没想到。我真 NB。\n</details>\n<p>接下来又是一个我想不到的模型。我们发现复杂度瓶颈出在枚举区间上，所以考虑通过固定区间右端点，用较小的复杂度直接求解满足条件的左端点数量来解决问题。为什么不是固定左端点呢？</p>\n<p>「因为题解都是写的固定右端点。」 0# 如是说。</p>\n<p>对于正在枚举的右端点 <span class=\"math inline\">\\(j\\)</span> 右边的颜色 <span class=\"math inline\">\\(x\\)</span>，我们记录它们上一次出现的位置 <span class=\"math inline\">\\(p_x\\)</span>，并用线段树找到范围内最右值 <span class=\"math inline\">\\((p_x)_{\\max}\\)</span>，那么左端点 <span class=\"math inline\">\\(i&gt;(p_x)_{\\max}\\)</span>。取 <span class=\"math inline\">\\(i&#39;=(p_x)_{\\max}+1\\)</span>，这样我们就初步得到了一个 <span class=\"math inline\">\\([i&#39;, j]\\)</span>。相对于纯暴力的做法，<span class=\"math inline\">\\(R_x\\le j\\)</span> 的等价条件已经满足，但还有一个条件，就是 <span class=\"math inline\">\\(L_x\\)</span> 不能小于 <span class=\"math inline\">\\(i\\)</span>。</p>\n<p>为了方便数据结构维护 <span class=\"math inline\">\\(p_x\\)</span>，我们逆序枚举 <span class=\"math inline\">\\(j\\)</span>，这样又可以得到一个性质：<span class=\"math inline\">\\(i&#39;\\)</span> 单调不降。这个时候我们逆向思维，处理出对于每个 <span class=\"math inline\">\\(i\\ge i&#39;\\)</span>，其能够到的最远的 <span class=\"math inline\">\\(j\\)</span>，记为 <span class=\"math inline\">\\(f_i\\)</span>，那么我们对于 <span class=\"math inline\">\\(f_i\\)</span> 建一个权值线段树，然后在枚举过程中查询权值在 <span class=\"math inline\">\\([j, +\\infty)\\)</span> 的 <span class=\"math inline\">\\(i\\)</span> 的个数就是答案。由于求的是个数，所以可以对超出范围的 <span class=\"math inline\">\\(i\\)</span> 对应的 <span class=\"math inline\">\\(f_i\\)</span> 进行删除操作。</p>\n<p>那么 <span class=\"math inline\">\\(f_i\\)</span> 又该怎么求呢？暴力地再建一个权值线段树维护 <span class=\"math inline\">\\(L_x\\)</span>，在 <span class=\"math inline\">\\((-\\infty, i)\\)</span> 权值范围内查询下标 <span class=\"math inline\">\\(k\\)</span> 的最小值，此时的 <span class=\"math inline\">\\(k\\)</span> 就是 <span class=\"math inline\">\\(f_i\\)</span>。</p>\n<p>因为 0# 讲课的时候我在开飞机，所以我也不知道 0# 是不是这么讲的，总之我这么做应该能做出来，就是要维护的东西实在有亿点点多。</p>\n<p>但是注意到一个线段树和两个权值线段树维护的大区间其实是一样的，所以我们只用一个线段树同时维护三个信息就好。最后时间复杂度 <span class=\"math inline\">\\(O(n\\log n)\\)</span>。</p>\n<details>\n<pre class=\"cpp\"><code>namespace XSC062 &#123;\nusing namespace fastIO;\n#define lt (p &lt;&lt; 1)\n#define rt (lt | 1)\n#define mid (t[p].l + t[p].r) / 2\nconst int maxn = 3e5 + 5;\n// shaber monotonicity\n// destroy my youth \nstruct _ &#123; int l, r, u, d; &#125;;\nstruct __ &#123;\n    int u, i;\n    __() &#123;&#125;\n    __(int u1, int i1) &#123;\n        u = u1, i = i1;\n    &#125;\n&#125;;\nint T, n, res;\n_ t[maxn &lt;&lt; 2];\nint a[maxn], L[maxn], R[maxn];\nint max(int x, int y) &#123; return x &gt; y ? x : y; &#125;\nint min(int x, int y) &#123; return x &lt; y ? x : y; &#125;\nvoid pushup(int p) &#123;\n    t[p].u = t[lt].u + t[rt].u;\n    return;\n&#125;\nvoid pushdown(int p) &#123;\n    if (t[p].d) &#123;\n        t[lt].d = t[rt].d = 1;\n        t[lt].u = t[lt].r - t[lt].l + 1;\n        t[rt].u = t[rt].r - t[rt].l + 1;\n        t[p].d = 0;\n    &#125;\n    return;\n&#125;\nvoid bld(int p, int l, int r) &#123;\n    t[p].u = t[p].d = 0;\n    t[p].l = l, t[p].r = r;\n    if (l == r) return;\n    bld(lt, l, mid), bld(rt, mid + 1, r);\n    return;\n&#125;\nvoid add(int p, int l, int r) &#123;\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r) &#123;\n        t[p].u = t[p].r - t[p].l + 1;\n        t[p].d = 1;\n        return;\n    &#125;\n    pushdown(p);\n    if (l &lt;= mid) add(lt, l, r);\n    if (r &gt; mid) add(rt, l, r);\n    pushup(p);\n    return;\n&#125;\nint ask(int p, int l, int r) &#123;\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r)\n        return t[p].u;\n    int res = 0; pushdown(p);\n    if (l &lt;= mid) res = ask(lt, l, r);\n    if (r &gt; mid) res += ask(rt, l, r);\n    return res;\n&#125;\nint main() &#123;\n    read(T);\n    while (T--) &#123;\n        read(n), res = 0;\n        std::stack&lt;__&gt; p;\n        std::fill(L + 1, L + n + 1, n + 5);\n        std::fill(R + 1, R + n + 1, 0);\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            read(a[i]), R[a[i]] = i;\n            if (L[a[i]] == n + 5) L[a[i]] = i;\n        &#125;\n        bld(1, 1, n);\n        for (int i = 1, j; i &lt;= n; ++i) &#123;\n            if (i == R[a[i]] &amp;&amp; i != L[a[i]])\n                add(1, L[a[i]] + 1, R[a[i]]);\n            else p.push(__(a[i], i));\n            while (!p.empty() &amp;&amp; R[p.top().u] &lt;= i) p.pop();\n            j = p.size() ? p.top().i : 0;\n            if (i != j) res += i - j - ask(1, j + 1, i);\n        &#125;\n        print(res, &#39;\\n&#39;);\n    &#125;\n    return 0;\n&#125;\n&#125; // namespace XSC062</code></pre>\n</details>\n",
            "tags": [
                "线段树"
            ]
        }
    ]
}