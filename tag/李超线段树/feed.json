{
    "version": "https://jsonfeed.org/version/1",
    "title": "null • All posts by \"李超线段树\" tag",
    "description": "",
    "home_page_url": "https://xsc062.netlify.app",
    "items": [
        {
            "id": "https://xsc062.netlify.app/20231230/",
            "url": "https://xsc062.netlify.app/20231230/",
            "title": "解题报告：[SDOI2016] 游戏",
            "date_published": "2023-12-30T04:12:30.000Z",
            "content_html": "<p>可以看出来出题人很想出一道把李超和别的什么东西凑起来的题目，于是给了这么一个缝合怪。</p>\n<span id=\"more\"></span>\n<hr />\n<p><a href=\"https://www.luogu.com.cn/problem/P4069\" class=\"uri\">https://www.luogu.com.cn/problem/P4069</a></p>\n<p>符号有点混乱。比如箭头又可以表示路径又可以表示赋值，代入语境应该还是好理解的。</p>\n<hr />\n<p>看到 <span class=\"math inline\">\\(a\\times dis + b\\)</span> 就应激反应出来是李超了，看到 <span class=\"math inline\">\\(s\\to t\\)</span> 又瞬间反应过来是树剖，但是树剖的 DFN 和 <span class=\"math inline\">\\(dis\\)</span> 没有直接关联，赛时想不到怎么做就跑路了。</p>\n<p>实际上这个转化很板。因为这是条路径，我们还在树链上跳，每次跳过的一个链上的 DFN 是连续的，对应的 <span class=\"math inline\">\\(dis\\)</span> 也是连续的。</p>\n<p>估计是打 T4 的子树问题打傻了，没想到这个。</p>\n<p>所以我们就相当于是给一条重链上的某个连续区间加了一个斜率为 <span class=\"math inline\">\\(a\\)</span>，截距为 <span class=\"math inline\">\\(b\\)</span> 加上 <em>一坨东西</em> 的线段。用李超维护即可。</p>\n<hr />\n<p>感觉讲的不清不楚的，那就再讲讲。</p>\n<p>我们要让李超上任意一个点 <span class=\"math inline\">\\(u\\)</span> 代表的 <span class=\"math inline\">\\(x\\)</span> 是个定值。<em>一坨东西</em> 维护了这条线段相对于 <span class=\"math inline\">\\(s\\)</span> 的偏移量。令 <span class=\"math inline\">\\(r\\gets \\text{LCA of } s \\text { and } t\\)</span>，<span class=\"math inline\">\\(R\\)</span> 表示整棵树的根，<span class=\"math inline\">\\(d(u,v)\\gets \\text {distance between } u \\text { and } v\\)</span>。</p>\n<ol type=\"1\">\n<li><p>对于 <span class=\"math inline\">\\(s\\to r\\)</span> 上的每个点 <span class=\"math inline\">\\(u\\)</span>：</p>\n<p><span class=\"math display\">\\[\n\\begin{aligned}\nval_u&amp;=a\\times d(s, u)+b\\\\\n&amp;=a\\times[d(s,R)-d(u,R)]+b\\\\\n&amp;=-a\\times d(u,R)+[a\\times d(s,R)+b]\n\\end{aligned}\n\\]</span> <span class=\"math inline\">\\(a\\times d(s,R)+b\\)</span> 是和 <span class=\"math inline\">\\(u\\)</span> 无关的定值（这意味着可以在同一个询问的树剖时直接线段树），<span class=\"math inline\">\\(d(u,R)\\)</span> 是只和 <span class=\"math inline\">\\(u\\)</span> 相关的值（这意味着对于任意询问都成立）。令斜率为 <span class=\"math inline\">\\(-a\\)</span>，截距为 <span class=\"math inline\">\\(a\\times d(s,R)+b\\)</span>，李超上任意点 <span class=\"math inline\">\\(u\\)</span> 代表 <span class=\"math inline\">\\(x\\)</span> 为 <span class=\"math inline\">\\(d(x,R)\\)</span>，维护如此一条线段即可。</p></li>\n<li><p>对于 <span class=\"math inline\">\\(r\\to t\\)</span> 上的每个点 <span class=\"math inline\">\\(v\\)</span>： <span class=\"math display\">\\[\n\\begin{aligned}\nval_v&amp;=a\\times d(s,v)+b\\\\\n&amp;= a\\times [d(r,v)+d(s,r)]+b\\\\\n&amp;=a\\times [d(v,R)-d(r,R)+d(s,r)]+b\\\\\n&amp;=a\\times d(v,R)+[-a\\times d(r,R)+a\\times d(s,r)+b]\n\\end{aligned}\n\\]</span> <span class=\"math inline\">\\(-a\\times d(r,R)+a\\times d(s,r)+b\\)</span> 是和 <span class=\"math inline\">\\(v\\)</span> 无关，只和询问中固定的 <span class=\"math inline\">\\(s,r,a,b\\)</span> 有关的定值；<span class=\"math inline\">\\(d(v,R)\\)</span> 是只和 <span class=\"math inline\">\\(v\\)</span> 相关的值且和上一个 case 里的 <span class=\"math inline\">\\(d(u,R)\\)</span> 同构，也用李超这么维护即可。</p></li>\n</ol>\n<p>用李超维护把原问题转化为每次向若干重链上连续区间插入线段，求最低交点的问题。</p>\n<p>注意到区间查询，李超需要加一个 pushup。具体怎么去操作呢？在加线段的时候除编号外新增一个变量维护当前区间内最低交点；我们就 pushup 这个东西。然后查询的时候就是在散区间的时候和原来一样查，整区间就在散区间答案的基础上再和当前区间的整体最低交点比一个 min。</p>\n<details>\n<pre class=\"cpp\"><code>#define int long long\nnamespace XSC062 &#123;\nusing namespace fastIO;\nconst int maxk = 25;\nconst int maxn = 1e6 + 5;\nconst int maxm = 1e6 + 5;\nconst int inf = 123456789123456789;\n//#define DEBUG\n\n#ifdef DEBUG\n#define Z(x) x\n#else\n#define Z(x)\n#endif\n#define lt (p &lt;&lt; 1)\n#define rt (lt | 1)\nstruct __ &#123; int k, b; &#125;;\nstruct _ &#123; int l, r, u, d; &#125;;\nstruct ____ &#123;\n    int v, w;\n    ____() &#123;&#125;\n    ____(int v1, int w1) &#123;\n        v = v1, w = w1; \n    &#125;\n&#125;;\n__ a[maxm];\n_ t[maxn &lt;&lt; 2];\nint tot, si, now;\nint f[maxn][maxk];\nint dis[maxn], dep[maxn];\nint dfn[maxn], tab[maxn];\nstd::vector&lt;____&gt; g[maxn];\nint n, m, ty, x, y, w, k, b;\nint siz[maxn], top[maxn], son[maxn];\nint max(int x, int y) &#123;\n    return x &gt; y ? x : y;\n&#125;\nint min(int x, int y) &#123;\n    return x &lt; y ? x : y;\n&#125;\nvoid swap(int &amp;x, int &amp;y) &#123;\n    x ^= y ^= x ^= y;\n    return;\n&#125;\nvoid DFS1(int x) &#123;\n    siz[x] = 1;\n    for (auto i : g[x]) &#123;\n        if (i.v == f[x][0]) continue;\n        f[i.v][0] = x;\n        for (int j = 1; j &lt;= si; ++j)\n            f[i.v][j] = f[f[i.v][j - 1]][j - 1];\n        dep[i.v] = dep[x] + 1;\n        dis[i.v] = dis[x] + i.w;\n        DFS1(i.v);\n        if (siz[i.v] &gt; siz[son[x]])\n            son[x] = i.v;\n        siz[x] += siz[i.v];\n    &#125;\n    return;\n&#125;\nvoid DFS2(int x, int t) &#123;\n    top[x] = t;\n    dfn[x] = ++now, tab[now] = x;\n    if (son[x]) DFS2(son[x], t);\n    for (auto i : g[x]) &#123;\n        if (i.v == f[x][0] || i.v == son[x])\n            continue;\n        DFS2(i.v, i.v);\n    &#125;\n    return;\n&#125;\nvoid bld(int p, int l, int r) &#123;\n    t[p].l = l, t[p].r = r, t[p].d = inf;\n    if (l == r) return;\n    int mid = (l + r) &gt;&gt; 1;\n    bld(lt, l, mid), bld(rt, mid + 1, r);\n    return;\n&#125;\nint getv(int id, int x) &#123;\n    if (!id) return inf;\n    Z(printf(&quot;get (%lld, %lld) = %lld\\n&quot;,\n        id, x, dis[tab[x]] * a[id].k + a[id].b));\n    return dis[tab[x]] * a[id].k + a[id].b;\n&#125;\nvoid pushup(int p) &#123;\n    if (t[p].l == t[p].r) return;\n    t[p].d = min(t[p].d, min(t[lt].d, t[rt].d));\n    Z(printf(&quot;[%lld, %lld]: pushup to %lld\\n&quot;,\n        t[p].l, t[p].r, t[p].d));\n    return;\n&#125;\nvoid chg(int p, int id) &#123;\n    t[p].u = id;\n    Z(int tmp = t[p].d);\n    t[p].d = min(getv(id, t[p].l),\n                 getv(id, t[p].r));\n    Z(printf(&quot;[%lld, %lld]: %lld -&gt; %lld\\n&quot;,\n                t[p].l, t[p].r, tmp, t[p].d)); \n    return;\n&#125;\nvoid upd(int p, int id) &#123;\n    if (!t[p].u) &#123;\n        chg(p, id), pushup(p);\n        return;\n    &#125;\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    int v1 = getv(t[p].u, mid),\n        v2 = getv(id, mid);\n    if (v2 &lt; v1) swap(t[p].u, id);\n    v1 = getv(t[p].u, t[p].l);\n    v2 = getv(id, t[p].l);\n    if (v2 &lt; v1) upd(lt, id);\n    v1 = getv(t[p].u, t[p].r);\n    v2 = getv(id, t[p].r);\n    if (v2 &lt; v1) upd(rt, id);\n    chg(p, t[p].u);\n    pushup(p);\n    return;\n&#125;\nvoid add(int p, int l, int r, int id) &#123;\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r) &#123;\n        upd(p, id);\n        return;\n    &#125;\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (l &lt;= mid) add(lt, l, r, id);\n    if (r &gt; mid) add(rt, l, r, id);\n    pushup(p);\n    return;\n&#125;\nint ask(int p, int l, int r) &#123;\n    l = max(l, t[p].l);\n    r = min(r, t[p].r);\n    int res = min(getv(t[p].u, l),\n                  getv(t[p].u, r));\n    Z(printf(&quot;[%lld, %lld]: res = %lld\\n&quot;,\n        t[p].l, t[p].r, res));\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r)\n        return min(res, t[p].d);\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (l &lt;= mid) res = min(res, ask(lt, l, r));\n    if (r &gt; mid) res = min(res, ask(rt, l, r));\n    Z(printf(&quot;[%lld, %lld]: res = %lld\\n&quot;,\n        t[p].l, t[p].r, res));\n    return res;\n&#125;\nvoid add(int x, int y, int w) &#123;\n    g[x].push_back(____(y, w));\n    return;\n&#125;\nvoid ins(int l, int r, int k, int b) &#123;\n    a[++tot].k = k, a[tot].b = b;\n    add(1, l, r, tot);\n    return;\n&#125;\nint getLCA(int x, int y) &#123;\n    if (dep[x] &lt; dep[y]) swap(x, y);\n    for (int i = si; ~i; --i) &#123;\n        if (dep[f[x][i]] &gt;= dep[y])\n            x = f[x][i];\n    &#125;\n    if (x == y) return x;\n    for (int i = si; ~i; --i) &#123;\n        if (f[x][i] != f[y][i])\n            x = f[x][i], y = f[y][i];\n    &#125;\n    return f[x][0];\n&#125;\nvoid inst(int s, int t, int k, int b) &#123;\n    int r = getLCA(s, t), u = s;\n    while (top[u] != top[r]) &#123;\n        ins(dfn[top[u]], dfn[u],\n                    -k, k * dis[s] + b);\n        u = f[top[u]][0];\n    &#125;\n    ins(dfn[r], dfn[u], -k, k * dis[s] + b);\n    u = t;\n    int d = dis[s] - dis[r];\n    while (top[u] != top[r]) &#123;\n        ins(dfn[top[u]], dfn[u],\n                k, -k * dis[r] + k * d + b);\n        u = f[top[u]][0];\n    &#125;\n    ins(dfn[r], dfn[u],\n            k, -k * dis[r] + k * d + b);\n    return;\n&#125;\nint qry(int x, int y) &#123;\n    int res = inf;\n    while (top[x] != top[y]) &#123;\n        if (dep[top[x]] &lt; dep[top[y]])\n            swap(x, y);\n        Z(printf(&quot;ask %lld -&gt; %lld: %lld\\n&quot;,\n            x, top[x],\n            ask(1, dfn[top[x]], dfn[x])));\n        res = min(res,\n            ask(1, dfn[top[x]], dfn[x]));\n        x = f[top[x]][0];\n    &#125;\n    if (dep[x] &lt; dep[y]) swap(x, y);\n    Z(printf(&quot;ask %lld -&gt; %lld: %lld\\n&quot;,\n        x, y, ask(1, dfn[y], dfn[x])));\n    res = min(res, ask(1, dfn[y], dfn[x]));\n    return res;\n&#125;\nint main() &#123;\n//  freopen(&quot;game1.in&quot;, &quot;r&quot;, stdin);\n    read(n), read(m);\n    si = log(n) / log(2.0);\n    for (int i = 1; i &lt; n; ++i) &#123;\n        read(x), read(y), read(w);\n        add(x, y, w), add(y, x, w);\n    &#125;\n    bld(1, 1, n);\n    dep[1] = 1, DFS1(1), DFS2(1, -1);\n    Z(for (int i = 1; i &lt;= n; ++i)\n        printf(&quot;dfn[%lld] = %lld\\n&quot;, i, dfn[i]));\n    while (m--) &#123;\n        read(ty), read(x), read(y);\n        if (ty == 1) &#123;\n            read(k), read(b);\n            inst(x, y, k, b);\n        &#125;\n        else print(qry(x, y), &#39;\\n&#39;);\n    &#125;\n    return 0;\n&#125;\n&#125; // namespace XSC062\n#undef int</code></pre>\n</details>\n",
            "tags": [
                "李超线段树",
                "树链剖分"
            ]
        }
    ]
}