{
    "version": "https://jsonfeed.org/version/1",
    "title": "null • All posts by \"状压 dp\" tag",
    "description": "",
    "home_page_url": "https://xsc062.netlify.app",
    "items": [
        {
            "id": "https://xsc062.netlify.app/20250805/",
            "url": "https://xsc062.netlify.app/20250805/",
            "title": "状压 DP",
            "date_published": "2025-08-05T06:33:55.000Z",
            "content_html": "<p>没补完（1/3），动作还是太慢了</p>\n<span id=\"more\"></span>\n<hr />\n<h2 id=\"a---只不过是长的领带-2-just-long-neckties-2\">A - 只不过是长的领带 2 / Just Long Neckties 2</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P11665\" class=\"uri\">https://www.luogu.com.cn/problem/P11665</a></p>\n<p>需要观察到，任意时刻 <span class=\"math inline\">\\(B\\)</span> 中不存在重复元素。把 <span class=\"math inline\">\\(B\\)</span> 压出来，令 <span class=\"math inline\">\\(f_{i,S}\\)</span> 表示选了 <span class=\"math inline\">\\(i\\)</span>，当前 <span class=\"math inline\">\\(B\\)</span> 为 <span class=\"math inline\">\\(S\\)</span> 是否可行，能够 <span class=\"math inline\">\\(O(n\\cdot 2^V)\\)</span>。对于某个 <span class=\"math inline\">\\(S\\)</span>，只关心它最远能到达哪个 <span class=\"math inline\">\\(i\\)</span>，故令 <span class=\"math inline\">\\(f_S\\)</span> 记录之。对于每一个 <span class=\"math inline\">\\(S\\)</span>，都可以找到 <span class=\"math inline\">\\(f_S\\)</span> 后第一对 <span class=\"math inline\">\\(a_i,a_{i+1}\\notin S\\)</span>，用其刷表。</p>\n<p>发现『找 <span class=\"math inline\">\\(f_S\\)</span> 后第一对非法元素』是很慢的，考虑优化；对于每个 <span class=\"math inline\">\\(i\\)</span> 维护 <span class=\"math inline\">\\(p\\)</span> 在其后第一次出现的位置 <span class=\"math inline\">\\(x\\)</span>，对于每个 <span class=\"math inline\">\\(a_x=p\\)</span> 维护 <span class=\"math inline\">\\(x\\)</span> 后方 <span class=\"math inline\">\\(a_y=p,a_{y+1}=q\\)</span> 第一次出现的位置，相当于<strong>先找 <span class=\"math inline\">\\(p\\)</span> 再找 <span class=\"math inline\">\\((p,q)\\)</span></strong>，就可以做到 <span class=\"math inline\">\\(O(V^2\\cdot 2^V+n\\cdot V)\\)</span>。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;int&gt; a(n + 1);\n    int V = 0;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; a[i];\n        V = std::max(V, a[i]--);\n    &#125;\n    std::vector&lt;std::vector&lt;int&gt; &gt; tx(n + 1, std::vector&lt;int&gt; (V)), ty(n + 1, std::vector&lt;int&gt; (V));\n    std::vector&lt;int&gt; lp(V);\n    std::vector&lt;std::vector&lt;int&gt; &gt; lpq(V, std::vector&lt;int&gt; (V));\n    for (int i = n; ~i; --i) &#123;\n        if (i &amp;&amp; i != n)\n            lpq[a[i]][a[i + 1]] = i;\n        for (int j = 0; j &lt; V; ++j) &#123;\n            tx[i][j] = lp[j];\n            if (i != n)\n                ty[i][j] = lpq[a[i]][j];\n        &#125;\n        if (i != 0)\n            lp[a[i]] = i;\n    &#125;\n    int siz = 1 &lt;&lt; V, res = 21;\n    std::vector&lt;int&gt; f(siz);\n    for (int i = 0; i &lt; siz; ++i) &#123;\n        std::vector&lt;int&gt; p0, p1;\n        for (int j = 0; j &lt; V; ++j)\n            if ((i &gt;&gt; j) &amp; 1)\n                p1.push_back(j);\n            else\n                p0.push_back(j);\n        int j = n;\n        for (auto p : p0)\n            if (tx[f[i]][p])\n                for (auto q : p0)\n                    if (ty[tx[f[i]][p]][q])\n                        j = std::min(j, ty[tx[f[i]][p]][q]);\n        if (j != n) &#123;\n            f[i ^ (1 &lt;&lt; a[j])] = std::max(f[i ^ (1 &lt;&lt; a[j])], j);\n            f[i ^ (1 &lt;&lt; a[j + 1])] = std::max(f[i ^ (1 &lt;&lt; a[j + 1])], j + 1);\n            for (auto k : p1) &#123;\n                f[i ^ (1 &lt;&lt; k) ^ (1 &lt;&lt; a[j])] = std::max(f[i ^ (1 &lt;&lt; k) ^ (1 &lt;&lt; a[j])], j);\n                f[i ^ (1 &lt;&lt; k) ^ (1 &lt;&lt; a[j + 1])] = std::max(f[i ^ (1 &lt;&lt; k) ^ (1 &lt;&lt; a[j + 1])], j + 1);\n            &#125;\n        &#125;\n        else\n            res = std::min(res, __builtin_popcount(i));\n    &#125;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"b---cut-and-reorder\">B - Cut and Reorder</h2>\n<p><a href=\"https://atcoder.jp/contests/abc328/tasks/abc328_g\" class=\"uri\">https://atcoder.jp/contests/abc328/tasks/abc328_g</a></p>\n<p>不妨先重排再修改，令 <span class=\"math inline\">\\(f_{i,S}\\)</span> 表示已经重排好新序列的前 <span class=\"math inline\">\\(i\\)</span> 个元素，对应原序列状态 <span class=\"math inline\">\\(S\\)</span> 的最小代价。枚举新区间容易转移。可以发现枚举 <span class=\"math inline\">\\(i,S\\)</span> 的实际复杂度为 <span class=\"math inline\">\\(O(2^n)\\)</span>（空间也可以这么优化），预处理之后总时间复杂度 <span class=\"math inline\">\\(O(n^2\\cdot 2^n)\\)</span>，跑不满，可以通过。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst long long inf = 1e18;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    long long c;\n    std::cin &gt;&gt; n &gt;&gt; c;\n    std::vector&lt;long long&gt; a(n), b(n);\n    for (int i = 0; i &lt; n; ++i)\n        std::cin &gt;&gt; a[i];\n    for (int i = 0; i &lt; n; ++i)\n        std::cin &gt;&gt; b[i];\n    using arr = std::vector&lt;long long&gt;;\n    using brr = std::vector&lt;arr&gt;;\n    using crr = std::vector&lt;brr&gt;;\n    brr p(n, arr(n));\n    crr g(n, brr(n, arr(n)));\n    for (int l = 0; l &lt; n; ++l)\n        for (int r = l; r &lt; n; ++r) &#123;\n            for (int k = l; k &lt;= r; ++k)\n                p[l][r] ^= (1 &lt;&lt; k);\n            for (int R = r - l; R &lt; n; ++R)\n                for (int L = R, j = r; j &gt;= l; --L, --j)\n                    g[l][r][R] += std::abs(b[L] - a[j]);\n        &#125;\n    int siz = 1 &lt;&lt; n;\n    std::vector&lt;long long&gt; f(siz, inf);\n    f[0] = 0ll;\n    for (int j = 1; j &lt; siz; ++j) &#123;\n        int i = __builtin_popcount(j) - 1;\n        for (int r = 0; r &lt; n; ++r)\n            for (int l = r; ~l &amp;&amp; ((j &gt;&gt; l) &amp; 1); --l)\n                f[j] = std::min(f[j], f[j ^ p[l][r]] + g[l][r][i] + c);\n    &#125;\n    std::cout &lt;&lt; f[siz - 1] - c &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"c---electric-circuit\">C - Electric Circuit</h2>\n<p><a href=\"https://atcoder.jp/contests/abc321/tasks/abc321_g\" class=\"uri\">https://atcoder.jp/contests/abc321/tasks/abc321_g</a></p>\n<p>很像<a href=\"/20250430/#有标号无向图计数\">无向图容斥</a>？令 <span class=\"math inline\">\\(f_S\\)</span> 表示让 <span class=\"math inline\">\\(S\\)</span> 内部完成配对，可以不连通的方案数，那么当且仅当 <span class=\"math inline\">\\(S\\)</span> 内部点出、入度之和相等（记为 <span class=\"math inline\">\\(cnt\\)</span>）时，<span class=\"math inline\">\\(f_S\\)</span> 有值 <span class=\"math inline\">\\(cnt!\\)</span>。相似地，设 <span class=\"math inline\">\\(g_S\\)</span> 表示让 <span class=\"math inline\">\\(S\\)</span> 完成配对，成为一个连通块的方案数，得到 <span class=\"math inline\">\\(g_S=f_S-\\sum\\limits_{v\\in S} f_{S\\oplus v}\\cdot g_v\\)</span>。让 <span class=\"math inline\">\\(v\\)</span> 必须包含 <span class=\"math inline\">\\(S\\)</span> 中编号最小的点就可以去重。</p>\n<p>从贡献的角度出发，<span class=\"math inline\">\\(S\\)</span> 带来的贡献就是 <span class=\"math inline\">\\(g_S\\cdot f_{U\\oplus S}\\)</span>，其中 <span class=\"math inline\">\\(U\\)</span> 是全集。最后除以 <span class=\"math inline\">\\(M!\\)</span> 求出期望。</p>\n<p>复杂度 <span class=\"math inline\">\\(O(3^n)\\)</span>。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 998244353;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, m;\n    std::cin &gt;&gt; n &gt;&gt; m;\n    std::vector&lt;int&gt; ci(n), co(n);\n    for (int i = 1, x; i &lt;= m; ++i)\n        std::cin &gt;&gt; x, ++ci[x - 1];\n    for (int i = 1, x; i &lt;= m; ++i)\n        std::cin &gt;&gt; x, ++co[x - 1];\n    std::vector&lt;long long&gt; fac(m + 1);\n    fac[0] = 1ll;\n    for (int i = 1; i &lt;= m; ++i)\n        fac[i] = fac[i - 1] * i % mod;\n    auto qkp = [&amp;](long long x, int y) &#123;\n        auto res(1ll);\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    int siz = 1 &lt;&lt; n;\n    std::vector&lt;long long&gt; f(siz), g(siz);\n    for (int i = 1; i &lt; siz; ++i) &#123;\n        int si = 0, so = 0;\n        for (int j = 0; j &lt; n; ++j)\n            if ((i &gt;&gt; j) &amp; 1)\n                si += ci[j], so += co[j];\n        if (si == so)\n            f[i] = fac[si];\n    &#125;\n    auto res(0ll);\n    for (int i = 1; i &lt; siz; ++i) &#123;\n        g[i] = f[i];\n        int mn = 0;\n        for (int j = 0; j &lt; n; ++j)\n            if ((i &gt;&gt; j) &amp; 1) &#123;\n                mn = j;\n                break;\n            &#125;\n        int s = i ^ (1 &lt;&lt; mn);\n        (g[i] += mod - g[1 &lt;&lt; mn] * f[s] % mod) %= mod;\n        for (int j = (s - 1) &amp; s; j; j = (j - 1) &amp; s)\n            (g[i] += mod - g[j ^ (1 &lt;&lt; mn)] * f[s ^ j] % mod) %= mod;\n        if (i != siz - 1)\n            (res += g[i] * f[(siz - 1) ^ i]) %= mod;\n        else\n            (res += g[i]) %= mod;\n    &#125;\n    std::cout &lt;&lt; res * qkp(fac[m], mod - 2) % mod &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"d---count-grid-3-coloring\">D - Count Grid 3-coloring</h2>\n<p><a href=\"https://atcoder.jp/contests/abc379/tasks/abc379_g\" class=\"uri\">https://atcoder.jp/contests/abc379/tasks/abc379_g</a></p>\n<p>轮廓线 DP。把每一列已经确定的最靠下的元素压起来，每行逐个确定即可。</p>\n<p>发现有效状态中只能容许最多一对相邻相同元素，这样复杂度就能降下来了。注意特判 <span class=\"math inline\">\\(1\\times 1\\)</span> 的情况。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 998244353;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, m;\n    std::cin &gt;&gt; n &gt;&gt; m;\n    std::array&lt;int, 15&gt; p;\n    p[0] = 1;\n    for (int i = 1; i &lt; 15; ++i)\n        p[i] = p[i - 1] * 3;\n    std::vector&lt;std::vector&lt;int&gt; &gt; a;\n    if (n &gt;= m) &#123;\n        a.assign(n + 1, std::vector&lt;int&gt; (m + 1));\n        for (int i = 1; i &lt;= n; ++i) \n            for (int j = 1; j &lt;= m; ++j) &#123;\n                char t;\n                std::cin &gt;&gt; t, a[i][j] = (t == &#39;?&#39; ? -1 : t - &#39;1&#39;);\n            &#125;\n    &#125;\n    else &#123;\n        std::swap(n, m);\n        a.assign(n + 1, std::vector&lt;int&gt; (m + 1));\n        for (int i = 1; i &lt;= m; ++i)\n            for (int j = 1; j &lt;= n; ++j) &#123;\n                char t;\n                std::cin &gt;&gt; t, a[j][i] = (t == &#39;?&#39; ? -1 : t - &#39;1&#39;);\n            &#125;\n    &#125;\n    int siz = p[m];\n    using arr = std::vector&lt;long long&gt;;\n    using brr = std::vector&lt;arr&gt;;\n    using crr = std::vector&lt;brr&gt;;\n    std::vector&lt;int&gt; s, tab(siz, -1);\n    auto getv_1 = [&amp;](int j, int i) &#123;\n        return (j / p[i - 1]) % 3;\n    &#125;;\n    auto getv = [&amp;](int j, int i) &#123;\n        return (s[j] / p[i - 1]) % 3;\n    &#125;;\n    auto chg = [&amp;](int j, int i, int v) &#123;\n        return tab[s[j] - p[i - 1] * getv(j, i) + p[i - 1] * v];\n    &#125;;\n    auto out = [&amp;](int i) &#123;\n        std::string s;\n        for (int j = 1; j &lt;= m; ++j)\n            s += &#39;1&#39; + getv_1(i, j);\n        return s.c_str();\n    &#125;;\n    for (int i = 0; i &lt; siz; ++i) &#123;\n        s.push_back(i);\n        int cnt = 0;\n        for (int j = 2; j &lt;= m; ++j)\n            if (getv_1(i, j - 1) == getv_1(i, j) &amp;&amp; ++cnt &gt;= 2) &#123;\n                s.pop_back();\n                break;\n            &#125;\n    &#125;\n    for (int i = 0; i &lt; (int)s.size(); ++i)\n        tab[s[i]] = i;\n    siz = (int)s.size();\n    if (n == 1) &#123;\n        std::cout &lt;&lt; (a[1][1] == -1 ? 3 : 1) &lt;&lt; &#39;\\n&#39;;\n        return 0;\n    &#125;\n    crr f(n + 1, brr(m + 1, arr(siz)));\n    for (int i = 0; i &lt; siz; ++i)\n        if ([&amp;](int i, int s) &#123;\n            for (int j = 1; j &lt;= m; ++j) &#123;\n                if (a[i][j] != -1 &amp;&amp; a[i][j] != getv(s, j))\n                    return false;\n                if (j != 1 &amp;&amp; getv(s, j) == getv(s, j - 1))\n                    return false;\n            &#125;\n            return true;\n        &#125; (1, i)) &#123;\n            for (int p = 0; p &lt; 3; ++p)\n                if ((a[2][1] == -1 || a[2][1] == p) &amp;&amp; getv(i, 1) != p &amp;&amp; ~chg(i, 1, p))\n                    (++f[2][1][chg(i, 1, p)]) %= mod;\n        &#125;\n    for (int i = 2; i &lt;= n; ++i) &#123;\n        for (int k = 1; k &lt; m; ++k)\n            for (int j = 0; j &lt; siz; ++j)\n                if (f[i][k][j]) &#123;\n                    // printf(&quot;f[%d][%d][%s] = %lld\\n&quot;, i, k, out(s[j]), f[i][k][j]);\n                    for (int p = 0; p &lt; 3; ++p)\n                        if ((a[i][k + 1] == -1 || a[i][k + 1] == p) &amp;&amp; getv(j, k) != p &amp;&amp; getv(j, k + 1) != p &amp;&amp; ~chg(j, k + 1, p))\n                            (f[i][k + 1][chg(j, k + 1, p)] += f[i][k][j]) %= mod;\n                &#125;\n        for (int j = 0; j &lt; siz; ++j)\n            if (i != n &amp;&amp; f[i][m][j])\n                for (int p = 0; p &lt; 3; ++p)\n                    if ((a[i + 1][1] == -1 || a[i + 1][1] == p) &amp;&amp; getv(j, 1) != p &amp;&amp; ~chg(j, 1, p))\n                        (f[i + 1][1][chg(j, 1, p)] += f[i][m][j]) %= mod;\n    &#125;\n    auto res = 0ll;\n    for (int i = 0; i &lt; siz; ++i)\n        (res += f[n][m][i]) %= mod;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"e---pure-straight\">E - Pure Straight</h2>\n<p><a href=\"https://atcoder.jp/contests/arc126/tasks/arc126_d\" class=\"uri\">https://atcoder.jp/contests/arc126/tasks/arc126_d</a></p>\n<p>手玩发现只要最终序列确定，那么移动的顺序不影响答案。故考虑确定目标位置和移动序列。考虑绝对值的几何意义，不妨令目标子序列中元素集中到被选中位置的中间元素，此时的代价可以计算。用点二进制技巧和库函数可以 <span class=\"math inline\">\\(O(1)\\)</span> 算代价。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, k;\n    std::cin &gt;&gt; n &gt;&gt; k;\n    int siz = 1 &lt;&lt; k;\n    std::vector&lt;int&gt; a(n + 1), f(siz, 0x3f3f3f3f);\n    auto out = [&amp;](int j) &#123;\n        std::string s;\n        for (int i = 0; i &lt; k; ++i)\n            s += (&#39;0&#39; + ((j &gt;&gt; i) &amp; 1));\n        return s.c_str();\n    &#125;;\n    f[0] = 0;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; a[i], --a[i];\n        for (int j = siz - 1; j &gt;= 0; --j) &#123;\n            if (!((j &gt;&gt; a[i]) &amp; 1))\n                f[j | (1 &lt;&lt; a[i])] = std::min(f[j | (1 &lt;&lt; a[i])], f[j] + __builtin_popcount(j &amp; (~((1 &lt;&lt; a[i]) - 1))));\n            f[j] += std::min(__builtin_popcount(j), k - __builtin_popcount(j));\n        &#125;\n    &#125;\n    std::cout &lt;&lt; f[siz - 1] &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"f---123-set\">F - 123 Set</h2>\n<p><a href=\"https://atcoder.jp/contests/arc184/tasks/arc184_b\" class=\"uri\">https://atcoder.jp/contests/arc184/tasks/arc184_b</a></p>\n<p>做过 <a href=\"https://www.luogu.com.cn/problem/P3226\">集合选数</a>（这个 trick 见过很多次了，应该不只这一道，但我想不起来了）很容易想到画一个表格或者 DAG 出来，其实都能做</p>\n<p>对于表格左上角和 DAG 的源点，肯定是一个 <span class=\"math inline\">\\(x\\)</span>，其不是 <span class=\"math inline\">\\(2\\)</span> 或 <span class=\"math inline\">\\(3\\)</span> 的倍数。如果画表，横乘 3 竖乘 2，观察一下是包含了 <span class=\"math inline\">\\(1\\sim n\\)</span> 恰好一次的很多个杨表（没什么用，提一嘴而已），考虑转化目标，发现是用一个不可旋转的倒 L 形骨牌可叠放地铺满异形表格，可以考虑轮廓线 DP</p>\n<p>具体地，用 1 来表示拐角处，0 表示其他，叠放的时候 1 的优先级比 0 高，然后就可以做了。以 3 为行，悲观估计单个表格大概有 <span class=\"math inline\">\\(31\\times 2^{19}\\)</span> 个状态，运算次数差不多 <span class=\"math inline\">\\(31\\times 19\\times 2^{19}\\)</span>；再发现长得一模一样的表格肯定方案数是一样的，如果把任意一个表格全部除以 <span class=\"math inline\">\\(x\\)</span>，就会得到 <span class=\"math inline\">\\(n=10^9\\div x\\)</span> 时 <span class=\"math inline\">\\(1\\)</span> 为左上角的杨表，就是说长相只和 <span class=\"math inline\">\\(10^9\\div x\\)</span> 的值有关，可以整除分块 😱 可预计的跑得非常不满，实践下来是可以过的（但是很慢）</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    auto calc = [&amp;](int r) &#123;\n        return r - r / 2 - r / 3 + r / 6;\n    &#125;;\n    auto dp = [&amp;](int lim) &#123;\n        if (lim == 1) &#123;\n            // printf(&quot;lim = 1, ret 1&quot;);\n            return 1;\n        &#125;\n        int n = 1, m = 1;\n        for (int k = 1; k * 2 &lt;= lim; ++n, k *= 2);\n        for (int k = 1; k * 3 &lt;= lim; ++m, k *= 3);\n        int siz = 1 &lt;&lt; m;\n        std::vector&lt;std::vector&lt;std::vector&lt;int&gt; &gt; &gt; f(2, std::vector&lt;std::vector&lt;int&gt; &gt; (2, std::vector&lt;int&gt; (siz))), p(n + 1, std::vector&lt;std::vector&lt;int&gt; &gt; (m));\n        std::vector&lt;std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; &gt; t(2, std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; (2, std::vector&lt;std::pair&lt;int, int&gt; &gt; (siz))); // sb\n        auto upd = [&amp;](int i, int k, int j, int v) &#123;\n            if (t[i &amp; 1][k &amp; 1][j] != std::make_pair(i, k)) &#123;\n                p[i][k].push_back(j);\n                t[i &amp; 1][k &amp; 1][j] = &#123; i, k &#125;, f[i &amp; 1][k &amp; 1][j] = v;\n            &#125;\n            else\n                f[i &amp; 1][k &amp; 1][j] = std::min(f[i &amp; 1][k &amp; 1][j], v);\n            return;\n        &#125;;\n        auto chg = [&amp;](int i, int j, int v) &#123;\n            return i ^ (((i &gt;&gt; j) &amp; 1) &lt;&lt; j) ^ (v &lt;&lt; j);\n        &#125;;\n        for (int i = 0; i &lt; siz; ++i) &#123;\n            bool flag = 0;\n            for (int j = 0; j &lt; m; ++j)\n                if (((i &gt;&gt; j) &amp; 1) || (j &amp;&amp; ((i &gt;&gt; (j - 1)) &amp; 1)));\n                else &#123;\n                    flag = 1;\n                    break;\n                &#125;\n            if (!flag)\n                upd(1, m - 1, i, __builtin_popcount(i));\n        &#125;\n        for (int i = 2; i &lt;= n; i++) &#123;\n            int m1 = 1;\n            for (int x = (1 &lt;&lt; (i - 1)); x * 3ll &lt;= lim; ++m1, x *= 3);\n            int siz1 = 1 &lt;&lt; m1;\n            for (auto j : p[i - 1][m - 1]) &#123;\n                if (j &amp; 1)\n                    upd(i, 0, chg(j &amp; (siz1 - 1), 0, 0), f[(i - 1) &amp; 1][(m - 1) &amp; 1][j]);\n                upd(i, 0, chg(j &amp; (siz1 - 1), 0, 1), f[(i - 1) &amp; 1][(m - 1) &amp; 1][j] + 1);\n            &#125;\n            m = m1, siz = siz1;\n            for (int k = 0; k &lt; m - 1; ++k)\n                for (auto j : p[i][k]) &#123;\n                    if (((j &gt;&gt; k) &amp; 1) || ((j &gt;&gt; (k + 1)) &amp; 1))\n                        upd(i, k + 1, chg(j, k + 1, 0), f[i &amp; 1][k &amp; 1][j]);\n                    upd(i, k + 1, chg(j, k + 1, 1), f[i &amp; 1][k &amp; 1][j] + 1);\n                &#125;\n        &#125;\n        int res = 0x3f3f3f3f;\n        for (auto i : p[n][m - 1])\n            res = std::min(res, f[n &amp; 1][(m - 1) &amp; 1][i]);\n        return res;\n    &#125;;\n    int res = 0;\n    for (int l = 1, r; l &lt;= n; l = r + 1) &#123;\n        r = n / (n / l);\n        if (calc(r) - calc(l - 1))\n            res += (calc(r) - calc(l - 1)) * dp(n / l);\n    &#125;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n",
            "tags": [
                "DP",
                "状压 DP"
            ]
        }
    ]
}