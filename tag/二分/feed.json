{
    "version": "https://jsonfeed.org/version/1",
    "title": "null • All posts by \"二分\" tag",
    "description": "",
    "home_page_url": "https://xsc062.netlify.app",
    "items": [
        {
            "id": "https://xsc062.netlify.app/20250726/",
            "url": "https://xsc062.netlify.app/20250726/",
            "title": "解题报告 [GCJ 2018 #1B] Transmutation",
            "date_published": "2025-07-26T06:47:23.000Z",
            "content_html": "<p>对于『跑 <span class=\"math inline\">\\(n\\)</span> 遍』性质的利用。</p>\n<span id=\"more\"></span>\n<hr />\n<p><a href=\"https://www.luogu.com.cn/problem/P10805\" class=\"uri\">https://www.luogu.com.cn/problem/P10805</a></p>\n<p>容易注意到可以二分答案；但似乎没办法找到一种很好的方法在 <span class=\"math inline\">\\(O(n)\\)</span> 内完成一次 check。</p>\n<p>化用一下网络流中流量的概念；例如下面这个图，假如先从 <span class=\"math inline\">\\(0\\)</span> 开始跑，发现没办法很好地确定 <span class=\"math inline\">\\(8\\to 2\\)</span> 这条边的流量（原因：没办法确定 <span class=\"math inline\">\\(8\\)</span> 和 <span class=\"math inline\">\\(2\\)</span> 的搜索顺序）。</p>\n<p><img src=\"image.png\" /></p>\n<p>这个时候想到；如果是 <span class=\"math inline\">\\(2\\)</span> 先被搜到，自然很好；但如果是 <span class=\"math inline\">\\(8\\)</span> 先被搜到，可以忽略这条由它出发、且未确定的边，先由现在认为的流出量确定流入量。等搜到 <span class=\"math inline\">\\(2\\)</span> 的时候，再更新一下 <span class=\"math inline\">\\(8\\to 2\\)</span> 的流量。这样 <span class=\"math inline\">\\(8\\)</span> 的流入量就是错的；容易想到再搜一次来更新。</p>\n<p><strong>类比一下 SPFA，可以认为跑 <span class=\"math inline\">\\(n\\)</span> 遍就已经达到能更新的最终状态</strong>。此时 check 一下是否每个点都合法。</p>\n",
            "tags": [
                "二分",
                "暴力"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20250721/",
            "url": "https://xsc062.netlify.app/20250721/",
            "title": "解题报告 CF1804F Approximate Diameter",
            "date_published": "2025-07-21T14:00:00.000Z",
            "content_html": "<p>唉确实没见过这种二分形式。</p>\n<span id=\"more\"></span>\n<hr />\n<p><a href=\"https://codeforces.com/problemset/problem/1804/F\" class=\"uri\">https://codeforces.com/problemset/problem/1804/F</a></p>\n<p>注意到这个范围基本上就是 <a href=\"/20231117/#树的直径图的直径\">图直径的这个性质</a>，但是我不认识 😅</p>\n<p>每次修改做一次 BFS 过于抽象，发现这个上界多了个 <span class=\"math inline\">\\(2\\)</span> 的系数，把主元换成 <span class=\"math inline\">\\(d\\)</span> 可以得到 <span class=\"math inline\">\\(d\\in[0.5s,2s]\\)</span>。有一个很牛的操作，假设在当前图上求出来了一个 <span class=\"math inline\">\\(s&#39;\\)</span>，显然一直加边，<span class=\"math inline\">\\(2s\\)</span> 这个上界是在变小的，但只要 <span class=\"math inline\">\\(s&#39;\\le 2s\\)</span> 成立，<span class=\"math inline\">\\(s&#39;\\)</span> 就一直可以作为区间里的一个估值。如果不成立，发现除以二就成立了。</p>\n<p>转化成二分 <span class=\"math inline\">\\(s&#39;\\)</span> 最远可以达到的距离即可。每次 <span class=\"math inline\">\\(s&#39;\\)</span> 除以二，共除了 <span class=\"math inline\">\\(\\log n\\)</span> 次；复杂度 <span class=\"math inline\">\\(O(n\\log^2 n)\\)</span>。</p>\n<p>然后注意不要每次 check 都复制一遍原数组然后加边；应该预先在原图上加好所有边，记录版本。原因是申请空间特别费时间。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, m, q;\n    std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;\n    std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; g(n + 1);\n    for (int x, y; m--; ) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y;\n        g[x].emplace_back(y, 0), g[y].emplace_back(x, 0);\n    &#125;\n    for (int i = 1, x, y; i &lt;= q; ++i) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y;\n        g[x].emplace_back(y, i), g[y].emplace_back(x, i);\n    &#125;\n    std::vector&lt;int&gt; mem(q + 1, -1);\n    auto calc = [&amp;](int id) &#123;\n        if (~mem[id])\n            return mem[id];\n        std::queue&lt;std::pair&lt;int, int&gt; &gt; q;\n        std::vector&lt;int&gt; tag(n + 1);\n        q.emplace(1, 0), tag[1] = 1;\n        int mx = 0;\n        for (; !q.empty(); ) &#123;\n            auto [x, w] = q.front();\n            q.pop(), mx = w;\n            for (auto [i, ver] : g[x])\n                if (ver &lt;= id &amp;&amp; !tag[i]) &#123;\n                    tag[i] = 1;\n                    q.emplace(i, w + 1);\n                &#125;\n        &#125;\n        return mem[id] = mx;\n    &#125;;\n    int s = calc(0);\n    for (int i = 0; i &lt;= q; ) &#123;\n        int j = i;\n        for (int l = i + 1, r = q, mid; l &lt;= r; ) &#123;\n            mid = (l + r) &gt;&gt; 1;\n            if (s &lt;= 2 * calc(mid))\n                j = mid, l = mid + 1;\n            else\n                r = mid - 1;\n        &#125;\n        for (; i &lt;= j; ++i)\n            std::cout &lt;&lt; s &lt;&lt; &#39; &#39;;\n        s /= 2;\n    &#125;\n    std::cout &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n",
            "tags": [
                "二分"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20230813/",
            "url": "https://xsc062.netlify.app/20230813/",
            "title": "pn、pm 和 plmm",
            "date_published": "2023-08-13T08:46:13.000Z",
            "content_html": "<p>Sotution to <a href=\"https://codeforces.com/problemset/problem/258/C\">CF258C Little Elephant and LCM</a>。</p>\n<span id=\"more\"></span>\n<hr />\n<p>0#：那么这个 pn 可以等于什么？它只能等于 pm。（露出看到 plmm 一般的猥琐坏笑）</p>\n<hr />\n<p>方便起见，下面 <span class=\"math inline\">\\(b_{\\text{lcm}}\\)</span> 的意思就是 <span class=\"math inline\">\\(\\text{lcm}\\{b_1,b_2,\\cdots,b_n\\}\\)</span>，<span class=\"math inline\">\\(\\max\\)</span> 什么的也同理。</p>\n<p>首先我们都能反应过来，如果 <span class=\"math inline\">\\(b_{\\text{lcm}}=b_{\\max}\\)</span>，那么 <span class=\"math inline\">\\(b\\)</span> 中的最大值就得是 <span class=\"math inline\">\\(b_{\\text {lcm}}\\)</span>，而其他元素都得是 <span class=\"math inline\">\\(b_{\\max}\\)</span> 的因数。</p>\n<p>既然涉及到求 <span class=\"math inline\">\\(b_{\\max}\\)</span> 的因数，那我们势必避免不了枚举 <span class=\"math inline\">\\(b_{\\max}\\)</span>。我一开始陷入了一个 trick：我并不知道 <span class=\"math inline\">\\(b_{\\max}\\)</span> 应该处于哪一个位置。但其实这不重要，它对我们最后的方案没有影响，有影响的是「有多少个位置可以取到当前枚举的 <span class=\"math inline\">\\(b_{\\max}\\)</span>」。</p>\n<p>对于当前枚举的 <span class=\"math inline\">\\(b_{\\max}\\)</span>（假设为 <span class=\"math inline\">\\(k\\)</span>），我们找到它的所有因数 <span class=\"math inline\">\\(p_1\\sim p_m\\)</span>，按从小到大的顺序排列。对于一个 <span class=\"math inline\">\\(a_i\\)</span>，当且仅当 <span class=\"math inline\">\\(a_i\\ge p_j\\)</span> 时，<span class=\"math inline\">\\(a_i\\)</span> 可以选择 <span class=\"math inline\">\\(p_j\\)</span>。那么我们找到 <span class=\"math inline\">\\(a_i\\)</span> 可以选到的最大的 <span class=\"math inline\">\\(p_j\\)</span>，此时 <span class=\"math inline\">\\(a_i\\)</span> 的选择就是 <span class=\"math inline\">\\(p_1\\sim p_j\\)</span>，共 <span class=\"math inline\">\\(j\\)</span> 种。</p>\n<p>那么我们在外面已经有一层枚举 <span class=\"math inline\">\\(k\\)</span> 的循环的前提下，再遍历 <span class=\"math inline\">\\(a\\)</span> 数组无疑是会起飞的，我们考虑倒过来，遍历 <span class=\"math inline\">\\(p\\)</span>，对于每个 <span class=\"math inline\">\\(p_j\\)</span>，找到它是多少个 <span class=\"math inline\">\\(a_i\\)</span> 的最大选择（假设为 <span class=\"math inline\">\\(x_j\\)</span>），那么对于 <span class=\"math inline\">\\(p_j\\)</span>，它贡献的答案就是 <span class=\"math inline\">\\(j^{x_j}\\)</span>。</p>\n<p><span class=\"math inline\">\\(x_j\\)</span> 的计算也不难，我们用两个二分找到满足 <span class=\"math inline\">\\(p_j\\le a_i &lt; p_j + 1\\)</span> 的 <span class=\"math inline\">\\(a_i\\)</span> 数量就可以了。那么总方案数就是 <span class=\"math inline\">\\(\\prod j^{x_j}\\)</span>。</p>\n<p>但是别忘了还有 <span class=\"math inline\">\\(k\\)</span> 为 <span class=\"math inline\">\\(b_{\\max}\\)</span> 的限制。找到 <span class=\"math inline\">\\(x_m\\)</span>，怎么去满足至少有一个 <span class=\"math inline\">\\(a_i=k\\)</span> 呢？一个微型容斥，用总方案数减去一个 <span class=\"math inline\">\\(k\\)</span> 都没有的方案数。那么就规定了每个可以取到 <span class=\"math inline\">\\(k\\)</span> 的数都必须不取 <span class=\"math inline\">\\(k\\)</span>，本来有 <span class=\"math inline\">\\(m\\)</span> 种选择，现在只剩下 <span class=\"math inline\">\\(m−1\\)</span> 种，所以答案就是 <span class=\"math inline\">\\((m−1)^{x_m}\\)</span>，容斥后为 <span class=\"math inline\">\\(m^{x_m}−(m−1)^{x_m}\\)</span>。</p>\n<p>对于 <span class=\"math inline\">\\(b_{\\max}=k\\)</span>，最终结果为 <span class=\"math inline\">\\((\\prod\\limits_{j=1}^{m−1}j^{x_j})\\times (m^{x_m}−(m−1)^{x_m})\\)</span>。加法原理把所有 <span class=\"math inline\">\\(k\\)</span> 的情况加起来即可。</p>\n<p>对于时间复杂度，枚举 <span class=\"math inline\">\\(k\\)</span> 是 <span class=\"math inline\">\\(O(V)\\)</span> 的，找因数是 <span class=\"math inline\">\\(O(\\sqrt V)\\)</span> 的，枚举 <span class=\"math inline\">\\(p_j\\)</span> 是 <span class=\"math inline\">\\(\\log V\\)</span> 的，二分是 <span class=\"math inline\">\\(\\log n\\)</span> 的。所以最终时间复杂度为 <span class=\"math inline\">\\(O(V\\times \\max\\{\\sqrt V,\\log V\\times \\log n\\})\\)</span>。</p>\n<details>\n<pre class=\"cpp\"><code>#define int long long\nnamespace XSC062 &#123;\nusing namespace fastIO;\nconst int mod = 1e9 + 7;\nconst int maxn = 1e5 + 5;\nint a[maxn];\nint n, mx, ans, res;\nint qkp(int x, int y) &#123;\n    int res = 1;\n    while (y) &#123;\n        if (y &amp; 1) (res *= x) %= mod;\n        (x *= x) %= mod, y &gt;&gt;= 1;\n    &#125;\n    return res;\n&#125;\nint max(int x, int y) &#123; return x &gt; y ? x : y; &#125;\nint main() &#123;\n    read(n);\n    for (int i = 1; i &lt;= n; ++i) \n        read(a[i]), mx = max(mx, a[i]);\n    std::sort(a + 1, a + n + 1);\n    for (int k = 1; k &lt;= mx; ++k) &#123;\n        res = 1;\n        std::vector&lt;int&gt; p;\n        p.push_back(-1); // 占位符，方便下标对齐 \n        for (int i = 1; i * i &lt;= k; ++i) &#123;\n            if (k % i == 0) &#123;\n                p.push_back(i);\n                if (i * i != k) p.push_back(k / i);\n            &#125;\n        &#125;\n        std::sort(p.begin() + 1, p.end());\n        // 先算前 m - 1 个 \n        int m = p.size() - 1;\n        for (int j = 1; j &lt;= m - 1; ++j) &#123;\n            int l, r, x;\n            l = std::lower_bound(a + 1, a + n + 1, p[j]) - a;\n            r = std::lower_bound(a + 1, a + n + 1, p[j + 1]) - a - 1;\n            x = r - l + 1, (res *= qkp(j, x)) %= mod;\n        &#125;\n        int l, r, x;\n        l = std::lower_bound(a + 1, a + n + 1, p[m]) - a;\n        r = n, x = r - l + 1;\n        (res *= (qkp(m, x) - qkp(m - 1, x))) %= mod;\n        (ans += res) %= mod;\n    &#125;\n    print((ans + mod) % mod, &#39;\\n&#39;);\n    return 0;\n&#125;\n&#125; // namespace XSC062\n#undef int</code></pre>\n</details>\n",
            "tags": [
                "二分",
                "容斥原理"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20230729/",
            "url": "https://xsc062.netlify.app/20230729/",
            "title": "矩阵",
            "date_published": "2023-07-29T07:38:36.000Z",
            "content_html": "<p>Solution to <a href=\"http://222.180.160.110:61235/contest/3825/problem/7\">BZOJ2406 矩阵</a>。</p>\n<span id=\"more\"></span>\n<hr />\n<blockquote>\n<p>赛时公告</p>\n<p>现在呢？：现在有弹窗了吗 「2023-07-19 16:45:07」</p>\n</blockquote>\n<p>此时无声胜有声。</p>\n<hr />\n<h3 id=\"f.bzoj2406矩阵\">F.「BZOJ2406」矩阵</h3>\n<p><a href=\"http://222.180.160.110:61235/contest/3825/problem/7\" class=\"uri\">http://222.180.160.110:61235/contest/3825/problem/7</a></p>\n<p>这是头一次见识到把矩阵和网络流结合在一起的题目。不过这种处理方式也是我们在学习二分图时的常客了：把行和列连边表示某一元素。</p>\n<p>我们发现 <span class=\"math inline\">\\(B_{i, j}\\)</span> 有给定的上下界，故我们考虑 <strong>上下界网络流</strong>。那怎么去表示 <span class=\"math inline\">\\(B_{i, j}\\)</span> 呢？这就要联系到我们刚刚说过的连边方式：用边 <span class=\"math inline\">\\(i\\to j\\)</span> 的流量来表示 <span class=\"math inline\">\\(B_{i, j}\\)</span>，有 <span class=\"math inline\">\\([L, R]\\)</span> 的上下界。</p>\n<p>可是我们除了 <span class=\"math inline\">\\([L,R]\\)</span> 的限制，还有最大值这个条件呀，怎么办呢？</p>\n<p>注意到题目要求最大的最小，自然想到二分答案。设答案为 <span class=\"math inline\">\\(x\\)</span>，则我们需要保证每行每列的答案都 <span class=\"math inline\">\\(\\le x\\)</span>。每行每列，这刚好是我们的建点方式。这对点本身作出了要求，这套路我们熟，让大源点向行连边、列向大汇点连边就好。</p>\n<p>那么这些边的上下界怎么办呢？我们已知 <span class=\"math inline\">\\(|S_A-S_B|\\le x\\)</span>，那么变形得：</p>\n<p><span class=\"math display\">\\[\n\\begin{cases}\nS_B\\ge S_A-x &amp;(S_B \\le S_A) \\\\\nS_B\\le S_A+x &amp;(S_B \\ge S_A)\n\\end{cases}\n\\]</span></p>\n<p>照理来说，两行的符号相反，我们现在已经得到了一个具有对称美的上下界：<span class=\"math inline\">\\(S_A-x\\le S_B\\le S_A+x\\)</span>，就应该速速连边了，可是我怎么看都觉得不舒坦：这个不等式可是带条件的，就这么直接拿来做上下界真的没问题吗？</p>\n<p><del>答案是没问题，因为我看的题解是这么写的</del> 本着探索求真精神，我们考虑尊重原不等式（因为原不等式的每一行刚好也有两个相反的符号），将这些边拆成两条，一条的上下界是 <span class=\"math inline\">\\([S_A-x, S_A]\\)</span>，另一条是 <span class=\"math inline\">\\([S_A,S_A+x]\\)</span>。6。我明白题解为什么这么写了，一个的下界就是另一个的上界，那直接合并不就行了，这个 naive trick 题解都不屑于写出来。</p>\n<p>然后跑个可行流就可以了。注意要保证边的下界为非负。</p>\n<details>\n<pre class=\"cpp\"><code>#define int long long\nnamespace XSC062 &#123;\nusing namespace fastIO;\nconst int lim = 2e5;\nconst int maxn = 405;\nconst int inf = 1e18;\nconst int maxm = 3e5 + 5;\nstruct _ &#123;\n    int v, w, n;\n    _() &#123;&#125;\n    _(int v1, int w1, int n1) &#123;\n        v = v1, w = w1, n = n1;\n    &#125;\n&#125;;\n_ u[maxm];\nint gs, gt, tot;\nint a[maxn][maxn];\nint l, mid, r, res;\nint h[maxn], dif[maxn];\nint n, m, cnt, s, t, L, R;\nint vis[maxn], now[maxn], dep[maxn];\nint max(int x, int y) &#123; return x &gt; y ? x : y; &#125;\nint min(int x, int y) &#123; return x &lt; y ? x : y; &#125;\nbool BFS(int n) &#123;\n    std::fill(vis + 1, vis + n + 1, 0);\n    std::fill(dep + 1, dep + n + 1, 0); \n    std::queue&lt;int&gt; q;\n    dep[gs] = 1, vis[gs] = 1;\n    q.push(gs), now[gs] = h[gs];\n    while (!q.empty()) &#123;\n        int f = q.front(); q.pop();\n        for (int i = h[f]; i; i = u[i].n) &#123;\n            int v = u[i].v, w = u[i].w;\n            if (vis[v] == 1 || w == 0) continue;\n            vis[v] = 1, now[v] = h[v];\n            dep[v] = dep[f] + 1, q.push(v);\n            if (v == gt) return 1;\n        &#125;\n    &#125;\n    return 0;\n&#125;\nint findP(int x, int flow = inf) &#123;\n    if (x == gt) return flow;\n    int rest = flow, i;\n    for (i = now[x]; rest &amp;&amp; i; i = u[i].n) &#123;\n        now[x] = i;\n        int v = u[i].v, w = u[i].w;\n        if (dep[v] != dep[x] + 1 || w == 0) continue;\n        int t = findP(v, min(rest, w));\n        if (t == 0) dep[v] = 0;\n        rest -= t, u[i].w -= t, u[i ^ 1].w += t;\n    &#125;\n    return flow - rest;\n&#125;\nint Dinic(int n) &#123;\n    int res = 0;\n    while (BFS(n)) &#123;\n        int t = findP(gs);\n        while (t) res += t, t = findP(gs);\n    &#125;\n    return res;\n&#125;\nvoid add(int x, int y, int w) &#123;\n    u[++tot] = _(y, w, h[x]), h[x] = tot;\n    return;\n&#125;\nvoid add(int x, int y, int d, int u) &#123;\n    add(x, y, u - d), add(y, x, 0);\n    dif[x] -= d, dif[y] += d;\n    return;\n&#125;\nvoid Init(void) &#123;\n    tot = 1, cnt = 0;\n    memset(h, 0, sizeof (h));\n    memset(dif, 0, sizeof (dif));\n    return;\n&#125;\nbool check(int x) &#123;\n    Init();\n    s = n + m + 1, t = s + 1;\n    add(t, s, inf), add(s, t, 0);\n    gs = t + 1, gt = t + 2;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        for (int j = 1; j &lt;= m; ++j)\n            add(i, j + n, L, R);\n    &#125;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        int sum = 0;\n        for (int j = 1; j &lt;= m; ++j)\n            sum += a[i][j];\n        add(s, i, max(0, sum - x), sum + x);\n    &#125;\n    for (int j = 1; j &lt;= m; ++j) &#123;\n        int sum = 0;\n        for (int i = 1; i &lt;= n; ++i)\n            sum += a[i][j];\n        add(j + n, t, max(sum - x, 0), sum + x);\n    &#125;\n    for (int i = 1; i &lt;= t; ++i) &#123;\n        if (dif[i] &lt; 0)\n            add(i, gt, -dif[i]), add(gt, i, 0);\n        else if (dif[i] &gt; 0) &#123;\n            add(gs, i, dif[i]);\n            add(i, gs, 0), cnt += dif[i];\n        &#125;\n    &#125;\n    return (Dinic(gt) == cnt);\n&#125;\nint main() &#123;\n    read(n), read(m);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        for (int j = 1; j &lt;= m; ++j)\n            read(a[i][j]);\n    &#125;\n    read(L), read(R);\n    l = 0, r = lim, res = -1;\n    while (l &lt;= r) &#123;\n        mid = (l + r) &gt;&gt; 1;\n        if (check(mid))\n            res = mid, r = mid - 1;\n        else l = mid + 1;\n    &#125;\n    print(res);\n    return 0;\n&#125;\n&#125; // namespace XSC062\n#undef int</code></pre>\n</details>\n<hr />\n<p>你最好有要事相求.jpg</p>\n",
            "tags": [
                "网络流",
                "二分",
                "上下界网络流"
            ]
        }
    ]
}