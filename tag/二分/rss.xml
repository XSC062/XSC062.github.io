<?xml version="1.0"?>
<rss version="2.0">
    <channel>
        <title> • Posts by &#34;二分&#34; tag</title>
        <link>https://xsc062.netlify.app</link>
        <description></description>
        <language>zh-CN</language>
        <pubDate>Wed, 24 Sep 2025 14:27:15 +0800</pubDate>
        <lastBuildDate>Wed, 24 Sep 2025 14:27:15 +0800</lastBuildDate>
        <category>并查集</category>
        <category>斜率优化</category>
        <category>悬线法</category>
        <category>哈希</category>
        <category>字典树</category>
        <category>DP</category>
        <category>单调队列</category>
        <category>分治</category>
        <category>计数</category>
        <category>二分图</category>
        <category>CRT / exCRT</category>
        <category>排列组合</category>
        <category>网络流</category>
        <category>费用流</category>
        <category>二分</category>
        <category>上下界网络流</category>
        <category>容斥原理</category>
        <category>线段树</category>
        <category>树状数组</category>
        <category>区间 DP</category>
        <category>构造</category>
        <category>数据结构</category>
        <category>Tarjan</category>
        <category>下饭</category>
        <category>LCA</category>
        <category>倍增</category>
        <category>鸽巢原理</category>
        <category>概率期望</category>
        <category>调和级数</category>
        <category>差分</category>
        <category>思维</category>
        <category>树形 DP</category>
        <category>最小生成树</category>
        <category>SAM</category>
        <category>状压</category>
        <category>分块</category>
        <category>可持久化</category>
        <category>笛卡尔树</category>
        <category>高维前缀和</category>
        <category>闲话</category>
        <category>欧拉回路</category>
        <category>树链剖分</category>
        <category>长链剖分</category>
        <category>KMP</category>
        <category>border</category>
        <category>字符串</category>
        <category>AC 自动机</category>
        <category>SA</category>
        <category>数学</category>
        <category>树上差分</category>
        <category>FWT</category>
        <category>堆</category>
        <category>树的重心</category>
        <category>二项式定理</category>
        <category>二项式反演</category>
        <category>贪心</category>
        <category>均摊</category>
        <category>优化建图</category>
        <category>反悔贪心</category>
        <category>调整法</category>
        <category>背包</category>
        <category>博弈论</category>
        <category>DP 优化</category>
        <category>虚树</category>
        <category>点分治</category>
        <category>WQS 二分</category>
        <category>闵可夫斯基和</category>
        <category>slope trick</category>
        <category>四边形不等式</category>
        <category>状压 DP</category>
        <category>组合数学</category>
        <category>支配对</category>
        <category>DDP</category>
        <category>容斥</category>
        <category>Kruskal 重构树</category>
        <category>高精度</category>
        <category>最短路</category>
        <category>树套树</category>
        <category>Boruvka</category>
        <category>树链剖分 - 最小生成树</category>
        <category>李超线段树</category>
        <item>
            <guid isPermalink="true">https://xsc062.netlify.app/20250924/</guid>
            <title>最短路练习</title>
            <link>https://xsc062.netlify.app/20250924/</link>
            <category>DP</category>
            <category>二分</category>
            <category>倍增</category>
            <category>调整法</category>
            <category>最短路</category>
            <pubDate>Wed, 24 Sep 2025 14:27:15 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;最短路为背景的题 + 做法是最短路的题&lt;/p&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;a---minimum-path&#34;&gt;A - Minimum Path&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/CF1473E&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/CF1473E&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;经典套路，发现可以把 max 和 min 换成任意路径中的边，然后 max 和 min 就会最小化这个式子&lt;/li&gt;
&lt;li&gt;故写一个 Dijkstra + DP，求这个式子的最小值即可&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, m;
    std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
    using arr = std::vector&amp;lt;long long&amp;gt;;
    using brr = std::vector&amp;lt;arr&amp;gt;;
    std::vector&amp;lt;std::vector&amp;lt;std::pair&amp;lt;int, int&amp;gt; &amp;gt; &amp;gt; g(n + 1);
    std::vector&amp;lt;brr&amp;gt; dis(2, brr(2, arr(n + 1, 1e18))), vis(2, brr(2, arr(n + 1)));
    for (int x, y, w; m--; ) &amp;#123;
        std::cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; y &amp;gt;&amp;gt; w;
        g[x].emplace_back(y, w);
        g[y].emplace_back(x, w);
    &amp;#125;
    dis[0][0][1] = 0;
    std::array&amp;lt;std::array&amp;lt;std::priority_queue&amp;lt;std::pair&amp;lt;long long, int&amp;gt; &amp;gt;, 2&amp;gt;, 2&amp;gt; q;
    q[0][0].emplace(0, 1);
    for (int i = 0; i &amp;lt; 2; ++i) &amp;#123;
        for (int j = 0; j &amp;lt; 2; ++j) &amp;#123;
            for (; !q[i][j].empty(); ) &amp;#123;
                int f = q[i][j].top().second;
                q[i][j].pop();
                if (vis[i][j][f])
                    continue;
                vis[i][j][f] = 1;
                for (auto k : g[f]) &amp;#123;
                    if (dis[i][j][k.first] &amp;gt; dis[i][j][f] + k.second) &amp;#123;
                        dis[i][j][k.first] = dis[i][j][f] + k.second;
                        q[i][j].emplace(-dis[i][j][k.first], k.first);
                    &amp;#125;
                    if (!i &amp;amp;&amp;amp; dis[1][j][k.first] &amp;gt; dis[i][j][f]) &amp;#123;
                        dis[1][j][k.first] = dis[i][j][f];
                        q[1][j].emplace(-dis[1][j][k.first], k.first);
                    &amp;#125;
                    if (!j &amp;amp;&amp;amp; dis[i][1][k.first] &amp;gt; dis[i][j][f] + 2 * k.second) &amp;#123;
                        dis[i][1][k.first] = dis[i][j][f] + 2 * k.second;
                        q[i][1].emplace(-dis[i][1][k.first], k.first);
                    &amp;#125;
                &amp;#125;
            &amp;#125;
        &amp;#125;
    &amp;#125;
    for (int i = 2; i &amp;lt;= n; ++i)
        std::cout &amp;lt;&amp;lt; std::min(&amp;#123; dis[0][0][i], dis[1][1][i] &amp;#125;) &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
    std::cout &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;b---train-delay&#34;&gt;B - Train Delay&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://vjudge.net/contest/750645#problem/B&#34; class=&#34;uri&#34;&gt;https://vjudge.net/contest/750645#problem/B&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;简化题目很重要的一个转化是&lt;strong&gt;由于 &lt;span class=&#34;math inline&#34;&gt;\(S\le T\)&lt;/span&gt; 带来的 &lt;span class=&#34;math inline&#34;&gt;\(S\)&lt;/span&gt; 和 &lt;span class=&#34;math inline&#34;&gt;\(T\)&lt;/span&gt; 地位平等，考虑把出发和到达分别看作一次事件处理。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;按照所有事件的发生时刻排序，有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于一次出发事件，可以得到在其之前该站点所有到达事件的 &lt;span class=&#34;math inline&#34;&gt;\(\max\{T&amp;#39;\}\)&lt;/span&gt;，用之更新 &lt;span class=&#34;math inline&#34;&gt;\(X\)&lt;/span&gt; 即可。&lt;/li&gt;
&lt;li&gt;对于一次到达事件，由于对应的 &lt;span class=&#34;math inline&#34;&gt;\(X\)&lt;/span&gt; 已经确定，更新该站点当前最大值即可。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, m;
    std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
    std::vector&amp;lt;int&amp;gt; d(m + 1);
    std::cin &amp;gt;&amp;gt; d[1];
    struct event &amp;#123;
        int t, op, id, x;
    &amp;#125;;
    std::vector&amp;lt;event&amp;gt; a;
    std::vector&amp;lt;int&amp;gt; mx(n + 1);
    for (int i = 1, x, y, s, t; i &amp;lt;= m; ++i) &amp;#123;
        std::cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; y &amp;gt;&amp;gt; s &amp;gt;&amp;gt; t;
        a.push_back(&amp;#123; s, 0, i, x &amp;#125;);
        a.push_back(&amp;#123; t, 1, i, y &amp;#125;);
    &amp;#125;
    std::sort(a.begin(), a.end(), [&amp;amp;](event &amp;amp;x, event &amp;amp;y) &amp;#123; return x.t == y.t ? x.op &amp;gt; y.op : x.t &amp;lt; y.t; &amp;#125;);
    for (auto [t, op, id, x] : a)
        if (op == 1)
            mx[x] = std::max(mx[x], t + d[id]);
        else if (id != 1)
            d[id] = std::max(mx[x] - t, 0);
    for (int i = 2; i &amp;lt;= m; ++i)
        std::cout &amp;lt;&amp;lt; d[i] &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
    std::cout &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;c---complete-the-graph&#34;&gt;C - Complete The Graph&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/CF715B&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/CF715B&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;神仙二分&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果初始把所有白边置为 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt;，那么会想到调整法构造&lt;/li&gt;
&lt;li&gt;但是不知道应该在哪些边上调整，确定调整多少似乎也没有什么简单的做法&lt;/li&gt;
&lt;li&gt;&lt;p&gt;故&lt;strong&gt;平均用力&lt;/strong&gt;，构造一个 边1 += 1，边2 += 1，边3 += 1, …, 边cnt0 += 1, 边1 += 1, 边2 += 1, … 的操作序列&lt;/p&gt;
容易&lt;strong&gt;发现每次操作最多让当前最短路长度增加 1&lt;/strong&gt;，而且有单调性&lt;/li&gt;
&lt;li&gt;&lt;p&gt;故二分答案即可&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const __int128 inf = 1e18;
const __int128 inff = 1e23;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, m, s, t, l, cnt = 0;
    std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m &amp;gt;&amp;gt; l &amp;gt;&amp;gt; s &amp;gt;&amp;gt; t, ++s, ++t;
    std::vector&amp;lt;std::tuple&amp;lt;int, int, long long&amp;gt; &amp;gt; u(m + 1);
    std::vector&amp;lt;std::vector&amp;lt;std::pair&amp;lt;int, long long&amp;gt; &amp;gt; &amp;gt; g(n + 1);
    for (int i = 1, x, y; i &amp;lt;= m; ++i) &amp;#123;
        long long w;
        std::cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; y &amp;gt;&amp;gt; w, ++x, ++y;
        if (w == 0)
            w = -(++cnt);
        g[x].emplace_back(y, w), g[y].emplace_back(x, w);
        u[i] = &amp;#123; x, y, w &amp;#125;;
    &amp;#125;
    std::vector&amp;lt;int&amp;gt; vis(n + 1);
    std::vector&amp;lt;__int128&amp;gt; dis(n + 1);
    std::vector&amp;lt;long long&amp;gt; k(cnt + 1);
    __int128 res = -1;
    auto check = [&amp;amp;](__int128 x) &amp;#123;
        for (int i = 1; i &amp;lt;= cnt; ++i)
            k[i] = x / cnt + (i &amp;lt;= x % cnt);
        std::fill(vis.begin() + 1, vis.end(), 0);
        std::fill(dis.begin() + 1, dis.end(), inf);
        std::priority_queue&amp;lt;std::pair&amp;lt;__int128, int&amp;gt; &amp;gt; q;
        dis[s] = 0, q.emplace(0, s);
        for (; !q.empty(); ) &amp;#123;
            int f = q.top().second;
            q.pop();
            if (vis[f])
                continue;
            vis[f] = 1;
            for (auto [v, w] : g[f]) &amp;#123;
                if (w &amp;lt; 0)
                    w = k[-w];
                if (dis[v] &amp;gt; dis[f] + w) &amp;#123;
                    dis[v] = dis[f] + w;
                    q.emplace(-dis[v], v);
                &amp;#125;
            &amp;#125;
        &amp;#125;
        return dis[t] &amp;lt;= l;
    &amp;#125;;
    for (__int128 l = cnt, r = cnt * inf, mid; l &amp;lt;= r; ) &amp;#123;
        mid = (l + r) &amp;gt;&amp;gt; 1;
        if (check(mid))
            res = mid, l = mid + 1;
        else
            r = mid - 1;
    &amp;#125;
    if (res == -1)
        std::cout &amp;lt;&amp;lt; &amp;quot;NO\n&amp;quot;;
    else &amp;#123;
        check(res);
        if (dis[t] != l)
            std::cout &amp;lt;&amp;lt; &amp;quot;NO\n&amp;quot;;
        else &amp;#123;
            std::cout &amp;lt;&amp;lt; &amp;quot;YES\n&amp;quot;;
            for (int i = 1; i &amp;lt;= m; ++i) &amp;#123;
                auto [x, y, w] = u[i];
                if (w &amp;lt; 0)
                    w = k[-w];
                std::cout &amp;lt;&amp;lt; x - 1 &amp;lt;&amp;lt; &amp;#39; &amp;#39; &amp;lt;&amp;lt; y - 1 &amp;lt;&amp;lt; &amp;#39; &amp;#39; &amp;lt;&amp;lt; w &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
            &amp;#125;
        &amp;#125;
    &amp;#125;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;a---重力球&#34;&gt;A - 重力球&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P7473&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P7473&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class=&#34;math inline&#34;&gt;\(m\)&lt;/span&gt; 相对很小，看看有没有什么基于 &lt;span class=&#34;math inline&#34;&gt;\(m\)&lt;/span&gt; 的做法&lt;/li&gt;
&lt;li&gt;每次球停下的位置一定是某个障碍物（或边界）上 / 下 / 左 / 右的格子，故可以在这 &lt;span class=&#34;math inline&#34;&gt;\(O(n + m)\)&lt;/span&gt; 个点上建图&lt;/li&gt;
&lt;li&gt;怎么同时维护两个球的信息呢，发现 &lt;span class=&#34;math inline&#34;&gt;\(m\)&lt;/span&gt; 还是很小，所以可以把两个球塞一起作为一个状态&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(m^2\)&lt;/span&gt; 次 Dij 还是太激进了 进一步思考发现可能的终点共 &lt;span class=&#34;math inline&#34;&gt;\(m\)&lt;/span&gt; 个 并且彼此不区分&lt;/p&gt;
&lt;p&gt;故以这 &lt;span class=&#34;math inline&#34;&gt;\(m\)&lt;/span&gt; 个终点跑多源最短路即可&lt;/p&gt;
&lt;p&gt;但 5e6 跑 Dij 还是太勉强了。&lt;strong&gt;发现边权为 1，为什么不 BFS 呢 😅&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;发现起点可能不在我们限定的点上，但可以人为选择一次重力方向，然后就回到刚刚的问题了&lt;/p&gt;
&lt;p&gt;或者离线也是一种方法&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;疑似常数太大，拼尽全力勉强卡过&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int LEN = (1 &amp;lt;&amp;lt; 20);
#ifdef ONLINE_JUDGE
inline int nec(void) &amp;#123;
    static char buf[LEN], *p = buf, *e = buf;
    if (p == e) &amp;#123;
        e = buf + fread(buf, 1, LEN, stdin);
        if (e == buf)
            return EOF;
        p = buf;
    &amp;#125;
    return *p++;
&amp;#125;
#else
#define nec getchar
#endif
inline bool read(int &amp;amp;x) &amp;#123;
    x = 0;
    bool f = 0;
    char ch = nec();
    while (ch &amp;lt; &amp;#39;0&amp;#39; || ch &amp;gt; &amp;#39;9&amp;#39;) &amp;#123;
        if (ch == EOF)
            return 0;
        if (ch == &amp;#39;-&amp;#39;)
            f = 1;
        ch = nec();
    &amp;#125;
    while (ch &amp;gt;= &amp;#39;0&amp;#39; &amp;amp;&amp;amp; ch &amp;lt;= &amp;#39;9&amp;#39;) &amp;#123;
        x = x * 10 + ch - &amp;#39;0&amp;#39;;
        ch = nec();
    &amp;#125;
    if (f)
        x = -x;
    return 1;
&amp;#125;
void print(int x) &amp;#123;
    if (x &amp;lt; 0) &amp;#123;
        putchar(&amp;#39;-&amp;#39;);
        x = -x;
    &amp;#125;
    if (x &amp;gt;= 10)
        print(x / 10);
    putchar(x % 10 + &amp;#39;0&amp;#39;);
    return;
&amp;#125;
void print(int x, char ch) &amp;#123;
    print(x);
    putchar(ch);
    return;
&amp;#125;
const int inf = 0x3f3f3f3f;
const int dir[][2] = &amp;#123;&amp;#123; -1, 0 &amp;#125;, &amp;#123; 1, 0 &amp;#125;, &amp;#123; 0, -1 &amp;#125;, &amp;#123; 0, 1 &amp;#125;&amp;#125;;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, m, q;
    read(n), read(m), read(q);
    std::vector&amp;lt;std::pair&amp;lt;int, int&amp;gt; &amp;gt; pos(m + 1);
    std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; a(n + 1, std::vector&amp;lt;int&amp;gt; (n + 1));
    for (int i = 1, x, y; i &amp;lt;= m; ++i) &amp;#123;
        read(x), read(y);
        pos[i] = &amp;#123; x, y &amp;#125;, a[x][y] = -1;
    &amp;#125;
    for (int i = 1; i &amp;lt;= n; ++i)
        pos.emplace_back(0, i), ++m;
    for (int i = 1; i &amp;lt;= n; ++i)
        pos.emplace_back(i, n + 1), ++m;
    for (int i = 1; i &amp;lt;= n; ++i)
        pos.emplace_back(n + 1, i), ++m;
    for (int i = 1; i &amp;lt;= n; ++i)
        pos.emplace_back(i, 0), ++m;
    int cnt = 0;
    std::vector&amp;lt;std::pair&amp;lt;int, int&amp;gt; &amp;gt; u(1);
    for (int i = 1; i &amp;lt;= m; ++i)
        for (auto [fx, fy] : dir) &amp;#123;
            int nx = pos[i].first + fx, ny = pos[i].second + fy;
            if (nx &amp;gt;= 1 &amp;amp;&amp;amp; nx &amp;lt;= n &amp;amp;&amp;amp; ny &amp;gt;= 1 &amp;amp;&amp;amp; ny &amp;lt;= n &amp;amp;&amp;amp; !a[nx][ny])
                a[nx][ny] = ++cnt, u.emplace_back(nx, ny);
        &amp;#125;
    std::vector&amp;lt;std::vector&amp;lt;std::array&amp;lt;int, 4&amp;gt; &amp;gt; &amp;gt; top(n + 1, std::vector&amp;lt;std::array&amp;lt;int, 4&amp;gt; &amp;gt; (n + 1));
    for (int j = 1; j &amp;lt;= n; ++j) &amp;#123;
        for (int i = 1; i &amp;lt;= n; ++i)
            if (a[i][j] != -1) &amp;#123;
                if (i == 1 || a[i - 1][j] == -1)
                    top[i][j][0] = a[i][j];
                else
                    top[i][j][0] = top[i - 1][j][0];
            &amp;#125;
        for (int i = n; i; --i)
            if (a[i][j] != -1) &amp;#123;
                if (i == n || a[i + 1][j] == -1)
                    top[i][j][1] = a[i][j];
                else
                    top[i][j][1] = top[i + 1][j][1];
            &amp;#125;
    &amp;#125;
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        for (int j = 1; j &amp;lt;= n; ++j)
            if (a[i][j] != -1) &amp;#123;
                if (j == 1 || a[i][j - 1] == -1)
                    top[i][j][2] = a[i][j];
                else
                    top[i][j][2] = top[i][j - 1][2];
            &amp;#125;
        for (int j = n; j; --j)
            if (a[i][j] != -1) &amp;#123;
                if (j == n || a[i][j + 1] == -1)
                    top[i][j][3] = a[i][j];
                else
                    top[i][j][3] = top[i][j + 1][3];
            &amp;#125;
    &amp;#125;
    const int N = cnt * cnt;
    std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; g(N + 1);
    auto encode = [&amp;amp;](int x, int y) &amp;#123;
        return (x - 1) * cnt + y;
    &amp;#125;;
    auto decode = [&amp;amp;](int id) &amp;#123;
        return std::make_pair((id - 1) / cnt + 1, (id - 1) % cnt + 1);
    &amp;#125;;
    for (int i = 1; i &amp;lt;= N; ++i)
        for (int j = 0; j &amp;lt; 4; ++j) &amp;#123;
            auto [a, b] = decode(i);
            g[encode(top[u[a].first][u[a].second][j], top[u[b].first][u[b].second][j])].emplace_back(i);
        &amp;#125;
    std::vector&amp;lt;int&amp;gt; dis(N + 1, inf), vis(N + 1);
    &amp;#123;
        std::queue&amp;lt;int&amp;gt; q;
        for (int i = 1; i &amp;lt;= cnt; ++i)
            dis[encode(i, i)] = 0, q.push(encode(i, i)), vis[encode(i, i)] = 1;
        for (; !q.empty(); ) &amp;#123;
            int x = q.front();
            q.pop();
            for (auto i : g[x])
                if (!vis[i])
                    dis[i] = dis[x] + 1, vis[i] = 1, q.push(i);
        &amp;#125;
    &amp;#125;
    for (int a, b, c, d; q--; ) &amp;#123;
        read(a), read(b), read(c), read(d);
        if (a == c &amp;amp;&amp;amp; b == d)
            print(0, &amp;#39;\n&amp;#39;);
        else &amp;#123;
            int res = inf;
            for (int j = 0; j &amp;lt; 4; ++j)
                res = std::min(res, dis[encode(top[a][b][j], top[c][d][j])] + 1);
            if (res == inf)
                print(-1, &amp;#39;\n&amp;#39;);
            else
                print(res, &amp;#39;\n&amp;#39;);
        &amp;#125;
    &amp;#125;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;b---矩阵游戏&#34;&gt;B - 矩阵游戏&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P7515&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P7515&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;把问题形式化一下，现在有 &lt;span class=&#34;math inline&#34;&gt;\(n\times m\)&lt;/span&gt; 个未知数和 &lt;span class=&#34;math inline&#34;&gt;\((n-1)\times (m-1)\)&lt;/span&gt; 个方程&lt;/p&gt;
&lt;p&gt;那么可以对边上一圈任意赋值，限制是左上角这 &lt;span class=&#34;math inline&#34;&gt;\((n-1)\times (m-1)\)&lt;/span&gt; 个未知数必须落在 &lt;span class=&#34;math inline&#34;&gt;\([0,10^6]\)&lt;/span&gt; 上&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;有一个很容易观察到的性质，对于一个 &lt;span class=&#34;math inline&#34;&gt;\(a\)&lt;/span&gt;，选取一个 &lt;span class=&#34;math inline&#34;&gt;\(v\)&lt;/span&gt;，并把棋盘黑白染色，那么把所有黑格 &lt;span class=&#34;math inline&#34;&gt;\(+=v\)&lt;/span&gt;，白格 &lt;span class=&#34;math inline&#34;&gt;\(-=v\)&lt;/span&gt;，对应的 &lt;span class=&#34;math inline&#34;&gt;\(b\)&lt;/span&gt; 是不会变的。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;这个操作是涉及全局的，太苛刻了&lt;/strong&gt;，有没有什么更 mild 的构造？&lt;/p&gt;
&lt;p&gt;发现只对一行 / 列黑白染色并操作也可以得到相同的结果。能感受到&lt;strong&gt;操作无法再简化了&lt;/strong&gt;。考虑用这个版本的操作&lt;strong&gt;调整&lt;/strong&gt;。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;故大力令周围一圈的临时解 &lt;span class=&#34;math inline&#34;&gt;\(a&amp;#39;\)&lt;/span&gt; 为 &lt;span class=&#34;math inline&#34;&gt;\(0\)&lt;/span&gt;，令每行、列的调整 delta 为 &lt;span class=&#34;math inline&#34;&gt;\(r_i,c_i\)&lt;/span&gt;，可以得到若干个关于 &lt;span class=&#34;math inline&#34;&gt;\(0\)&lt;/span&gt; 和 &lt;span class=&#34;math inline&#34;&gt;\(10^6\)&lt;/span&gt; 的约束。最后建出来一个完全二分图状物，跑差分约束即可，容易发现复杂度正确。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;实现技巧：规划一下 &lt;span class=&#34;math inline&#34;&gt;\(r\)&lt;/span&gt; 和 &lt;span class=&#34;math inline&#34;&gt;\(c\)&lt;/span&gt; 的染色方式，使得它们错开，可以把所有位置都写作 &lt;span class=&#34;math inline&#34;&gt;\(a&amp;#39;_{i,j}+c-r\)&lt;/span&gt; 或 &lt;span class=&#34;math inline&#34;&gt;\(a&amp;#39;_{i,j}+r-c\)&lt;/span&gt; 的形式，便于差分约束&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;c---tax&#34;&gt;C - Tax&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P6822&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P6822&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;容易想到分类讨论，如果钦定是入边贡献边权，那么出边边权不能大于入边边权；否则，出边贡献边权。&lt;/li&gt;
&lt;li&gt;考虑把每个点上的出边按边权从小到大排序，显然需要入边贡献的是一段前缀，需要出边贡献的是一段后缀，就可以做一个前后缀优化建图。&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const long long inf = 1e18;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, m;
    std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
    struct edge &amp;#123; int v, w, id, pi, si; &amp;#125;;
    std::vector&amp;lt;std::vector&amp;lt;edge&amp;gt; &amp;gt; g1(n + 2);
    std::vector&amp;lt;std::vector&amp;lt;std::pair&amp;lt;int, int&amp;gt; &amp;gt; &amp;gt; g(1);
    int cnt = 0;
    for (int x, y, w; m--; ) &amp;#123;
        std::cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; y &amp;gt;&amp;gt; w;
        g1[x].push_back(&amp;#123; y, w, ++cnt, 0, 0 &amp;#125;);
        g1[y].push_back(&amp;#123; x, w, ++cnt, 0, 0 &amp;#125;);
        g.emplace_back(), g.emplace_back();
    &amp;#125;
    int s = ++cnt, t = ++cnt;
    g1[0].push_back(&amp;#123; 1, 0, s, 0, 0 &amp;#125;), g1[n].push_back(&amp;#123; n + 1, 0, t, 0, 0 &amp;#125;);
    g.emplace_back(), g.emplace_back();
    for (int i = 0; i &amp;lt;= n + 1; ++i)
        if (!g1[i].empty()) &amp;#123;
            std::sort(g1[i].begin(), g1[i].end(), [&amp;amp;](edge &amp;amp;x, edge &amp;amp;y) &amp;#123; return x.w &amp;lt; y.w; &amp;#125;);
            for (int j = 0; j &amp;lt; (int)g1[i].size(); ++j) &amp;#123;
                g1[i][j].pi = ++cnt, g.emplace_back();
                if (j != 0)
                    g[cnt].emplace_back(cnt - 1, 0);
                g[cnt].emplace_back(g1[i][j].id, 0);
            &amp;#125;
            for (int j = (int)g1[i].size() - 1; ~j; --j) &amp;#123;
                g1[i][j].si = ++cnt, g.emplace_back();
                if (j != (int)g1[i].size() - 1)
                    g[cnt].emplace_back(cnt - 1, 0);
                g[cnt].emplace_back(g1[i][j].id, g1[i][j].w);
            &amp;#125;
        &amp;#125;
    for (int i = 0; i &amp;lt;= n + 1; ++i)
        for (auto &amp;amp;[v, w, id, pi, si] : g1[i]) &amp;#123;
            auto to = std::upper_bound(g1[v].begin(), g1[v].end(), w, [&amp;amp;](int x, edge &amp;amp;y) &amp;#123; return x &amp;lt; y.w; &amp;#125;);
            if (to != g1[v].end())
                g[id].emplace_back(to-&amp;gt;si, 0);
            if (to != g1[v].begin())
                g[id].emplace_back((--to)-&amp;gt;pi, w);
        &amp;#125;
    std::vector&amp;lt;int&amp;gt; vis(cnt + 1, 0);
    std::vector&amp;lt;long long&amp;gt; dis(cnt + 1, inf);
    std::priority_queue&amp;lt;std::pair&amp;lt;long long, int&amp;gt; &amp;gt; q;
    dis[s] = 0, q.emplace(0, s);
    for (; !q.empty(); ) &amp;#123;
        int f = q.top().second;
        q.pop();
        if (vis[f])
            continue;
        vis[f] = 1;
        for (auto [v, w] : g[f])
            if (dis[v] &amp;gt; dis[f] + w) &amp;#123;
                dis[v] = dis[f] + w;
                q.emplace(-dis[v], v);
            &amp;#125;
    &amp;#125;
    std::cout &amp;lt;&amp;lt; dis[t] &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;d---travelling-through-the-snow-queens-kingdom&#34;&gt;D - Travelling Through the Snow Queen’s Kingdom&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/CF685E&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/CF685E&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;目前见过的数据范围提示性极弱（误导性极强）的循环结构题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;[BZOJ3620] 似乎在梦中见过的样子&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/20240906/#字符合并&#34;&gt;字符合并&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/20250907/#e---subset-product-problem&#34;&gt;[ARC205E] Subset Product Problem&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;正赛因为有部分分，应该不会出现不敢写的问题&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;考虑离线询问，逆序加边；原文无边权；边的通行时刻只决定到达点的时刻。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;借鉴 &lt;a href=&#34;/20231113/#b.-商人&#34;&gt;merchant&lt;/a&gt; 中的思路，只需要更新当前边两侧点为起点的 DP 数组。&lt;/p&gt;
&lt;p&gt;需要注意边从某种意义上说是『有向』的。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int inf = 0x3f3f3f3f;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, m, q;
    std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m &amp;gt;&amp;gt; q;
    struct query &amp;#123; int r, s, t, id; &amp;#125;;
    std::vector&amp;lt;int&amp;gt; res(q + 1);
    std::vector&amp;lt;std::vector&amp;lt;query&amp;gt; &amp;gt; u(m + 1);
    std::vector&amp;lt;std::pair&amp;lt;int, int&amp;gt; &amp;gt; e(m + 1);
    for (int i = 1; i &amp;lt;= m; ++i)
        std::cin &amp;gt;&amp;gt; e[i].first &amp;gt;&amp;gt; e[i].second;
    for (int i = 1, l, r, s, t; i &amp;lt;= q; ++i) &amp;#123;
        std::cin &amp;gt;&amp;gt; l &amp;gt;&amp;gt; r &amp;gt;&amp;gt; s &amp;gt;&amp;gt; t;
        u[l].push_back(&amp;#123; r, s, t, i &amp;#125;);
    &amp;#125;
    std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; g(n + 1, std::vector&amp;lt;int&amp;gt; (n + 1, inf));
    for (int i = m; i; --i) &amp;#123;
        auto [x, y] = e[i];
        g[x][y] = g[y][x] = i;
        for (int j = 1; j &amp;lt;= n; ++j)
            g[x][j] = g[y][j] = std::min(g[x][j], g[y][j]);
        for (auto [r, s, t, id] : u[i])
            if (g[s][t] &amp;lt;= r)
                res[id] = 1;
    &amp;#125;
    for (int i = 1; i &amp;lt;= q; ++i)
        std::cout &amp;lt;&amp;lt; (res[i] ? &amp;quot;Yes&amp;quot; : &amp;quot;No&amp;quot;) &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;e---culture-code&#34;&gt;E - Culture Code&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/CF1197E&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/CF1197E&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;先按 &lt;span class=&#34;math inline&#34;&gt;\(out\)&lt;/span&gt; 排序，做一个前缀优化建图。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;容易发现除了最外层，每一个套娃都会提供 &lt;span class=&#34;math inline&#34;&gt;\(in_i-out_i\)&lt;/span&gt; 的代价，而最外层会提供 &lt;span class=&#34;math inline&#34;&gt;\(in_x\)&lt;/span&gt; 的代价。&lt;/p&gt;
&lt;del&gt;好在要求的是最长路，这样就可以 Dij 了&lt;/del&gt;，并不需要真正把图建出来，发现这个形式更序列，直接在序列上二分前缀 + DP 即可。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;求方案是容易的。最后统计 DP 值最大，&lt;strong&gt;且不能被其他套娃包含的元素&lt;/strong&gt;即可。&lt;/p&gt;
&lt;p&gt;Tip：在求解过程中并不用考虑当前元素和前缀 min 元素间能否加入其他套娃，因为保证 &lt;span class=&#34;math inline&#34;&gt;\(out&amp;gt;in\)&lt;/span&gt;，如果存在这样的套娃，其 DP 值会比前缀 min 更小，矛盾。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int mod = 1e9 + 7;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n;
    std::cin &amp;gt;&amp;gt; n;
    std::vector&amp;lt;std::pair&amp;lt;int, int&amp;gt; &amp;gt; a(n + 1);
    int mxi = 0;
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        std::cin &amp;gt;&amp;gt; a[i].first &amp;gt;&amp;gt; a[i].second;
        mxi = std::max(mxi, a[i].second);
    &amp;#125;
    std::sort(a.begin() + 1, a.end());
    std::vector&amp;lt;long long&amp;gt; g(n + 1), mxg(n + 1), f(n + 1), mx(n + 1);
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        int j = std::upper_bound(a.begin() + 1, a.begin() + i, std::make_pair(a[i].second, 0x3f3f3f3f)) - a.begin() - 1;
        if (j == 0)
            f[i] = a[i].second, g[i] = 1ll;
        else
            f[i] = mx[j] + a[i].second, g[i] = mxg[j];
        long long now = f[i] - a[i].first;
        if (now &amp;lt; mx[i - 1])
            mx[i] = now, mxg[i] = g[i];
        else if (now == mx[i - 1])
            mx[i] = now, mxg[i] = (mxg[i - 1] + g[i]) % mod;
        else
            mx[i] = mx[i - 1], mxg[i] = mxg[i - 1];
    &amp;#125;
    auto now = 0x3f3f3f3fll, res = 0ll;
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        if (a[i].first &amp;lt;= mxi)
            continue;
        if (f[i] &amp;lt; now)
            now = f[i], res = g[i];
        else if (f[i] == now)
            (res += g[i]) %= mod;
    &amp;#125;
    std::cout &amp;lt;&amp;lt; res &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;a---awesome-arrowland-adventure&#34;&gt;A - Awesome Arrowland Adventure&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P6233&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P6233&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;没什么好说的建图，注意只能顺时针转&lt;/li&gt;
&lt;li&gt;代码略&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;b---地铁线路&#34;&gt;B - 地铁线路&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P6096&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P6096&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;考虑做一个神秘拆点，把每个点附上线路和运行方向的信息（所以是单向的）&lt;/li&gt;
&lt;li&gt;认为路径代价是二元组，那么同条线路中的点通行代价为 &lt;span class=&#34;math inline&#34;&gt;\((0,-1)\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;换乘需要优化建图，每个点可以花 &lt;span class=&#34;math inline&#34;&gt;\((0,0)\)&lt;/span&gt; 的代价走到这个点的『换乘点』，再花 &lt;span class=&#34;math inline&#34;&gt;\((1,0)\)&lt;/span&gt; 的代价走到另一个分点&lt;/li&gt;
&lt;li&gt;&lt;p&gt;但 &lt;strong&gt;15 年的时候 SPFA 已经死了&lt;/strong&gt;，所以需要好好考虑怎么实现最短路。&lt;/p&gt;
&lt;p&gt;分两问是有提示性在的，可以想到 01 BFS 解决第一个关键字，比较对的想法是&lt;strong&gt;把所有最短路拿出来形成 DAG，在 DAG 上对第二关键字 DP&lt;/strong&gt;。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, m;
    std::cin &amp;gt;&amp;gt; m &amp;gt;&amp;gt; n;
    std::unordered_map&amp;lt;std::string, int&amp;gt; tab;
    std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; l(n + 1);
    std::vector&amp;lt;std::vector&amp;lt;std::tuple&amp;lt;int, int, int&amp;gt; &amp;gt; &amp;gt; g0(n + 1), g1(n + 1);
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        std::string s;
        std::cin &amp;gt;&amp;gt; s, tab[s] = i;
    &amp;#125;
    int tot = n;
    for (int i = 1, k; i &amp;lt;= m; ++i) &amp;#123;
        std::cin &amp;gt;&amp;gt; k;
        int lp = 0, lq = 0;
        for (std::string s; k--; ) &amp;#123;
            std::cin &amp;gt;&amp;gt; s;
            int p = ++tot, q = ++tot, id = tab[s];
            g0.emplace_back(), g0.emplace_back();
            g1.emplace_back(), g1.emplace_back();
            if (lp) &amp;#123;
                g0[p].emplace_back(lp, 0, 1), g0[lq].emplace_back(q, 0, 1);
                g1[lp].emplace_back(p, 0, 1), g1[q].emplace_back(lq, 0, 1);
            &amp;#125;
            g0[p].emplace_back(id, 0, 0), g0[id].emplace_back(p, 1, 0);
            g1[id].emplace_back(p, 0, 0), g1[p].emplace_back(id, 1, 0);
            g0[q].emplace_back(id, 0, 0), g0[id].emplace_back(q, 1, 0);
            g1[id].emplace_back(q, 0, 0), g1[q].emplace_back(id, 1, 0);
            l[id].push_back(p), l[id].push_back(q);
            lp = p, lq = q;
        &amp;#125;
    &amp;#125;
    int s, t;
    &amp;#123;
        std::string s1, s2;
        std::cin &amp;gt;&amp;gt; s1 &amp;gt;&amp;gt; s2;
        s = ++tot, t = tab[s2];
        g0.emplace_back(), g1.emplace_back();
        int p = tab[s1];
        for (auto i : l[p])
            g0[s].emplace_back(i, 1, 0), g1[i].emplace_back(s, 1, 0);
    &amp;#125;
    std::vector&amp;lt;int&amp;gt; dis0(tot + 1, 0x3f3f3f3f), dis1(tot + 1, 0x3f3f3f3f);
    auto BFS = [&amp;amp;](decltype(g0) &amp;amp;g, decltype(dis0) &amp;amp;dis, int s) &amp;#123;
        std::deque&amp;lt;int&amp;gt; q;
        std::vector&amp;lt;int&amp;gt; vis(tot + 1);
        q.push_back(s), dis[s] = 0;
        for (; !q.empty(); ) &amp;#123;
            int x = q.front();
            q.pop_front();
            if (vis[x])
                continue;
            vis[x] = 1;
            for (auto [v, w1, w2] : g[x])
                if (dis[x] + w1 &amp;lt; dis[v]) &amp;#123;
                    dis[v] = dis[x] + w1;
                    if (w1 == 0)
                        q.push_front(v);
                    else
                        q.push_back(v);
                &amp;#125;
        &amp;#125;
        return;
    &amp;#125;;
    BFS(g0, dis0, s), BFS(g1, dis1, t);
    std::cout &amp;lt;&amp;lt; dis0[t] &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    std::vector&amp;lt;int&amp;gt; deg(tot + 1);
    std::vector&amp;lt;std::vector&amp;lt;std::pair&amp;lt;int, int&amp;gt; &amp;gt; &amp;gt; g(tot + 1);
    for (int i = 1; i &amp;lt;= tot; ++i)
        for (auto [j, w1, w2] : g0[i])
            if (dis0[i] + dis1[j] + w1 == dis0[t])
                g[i].emplace_back(j, w2), ++deg[j];
    std::queue&amp;lt;int&amp;gt; q;
    for (int i = 1; i &amp;lt;= tot; ++i)
        if (!deg[i])
            q.push(i);
    std::vector&amp;lt;int&amp;gt; f(tot + 1);
    for (; !q.empty(); ) &amp;#123;
        int x = q.front();
        q.pop();
        for (auto [v, w] : g[x]) &amp;#123;
            f[v] = std::max(f[v], f[x] + w);
            if (!--deg[v])
                q.push(v);
        &amp;#125;
    &amp;#125;
    std::cout &amp;lt;&amp;lt; f[t] &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;c---droga-do-domu&#34;&gt;C - Droga do domu&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P9402&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P9402&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;还是做一个和上一题类似的优化建图&lt;/li&gt;
&lt;li&gt;此外就是一个普通的 Dij 上 DP 了。&lt;strong&gt;图没有环&lt;/strong&gt;，直接拓扑即可。&lt;/li&gt;
&lt;li&gt;可以滚动优化空间，但似乎并无必要。代码略。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;d---tickets-p&#34;&gt;D - Tickets P&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P7984&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P7984&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;没什么好说的线段树优化建图，难点在于如何同时获取 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt; 和 &lt;span class=&#34;math inline&#34;&gt;\(N\)&lt;/span&gt; 的信息&lt;/li&gt;
&lt;li&gt;&lt;p&gt;发现从某个点走到 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt; 和 &lt;span class=&#34;math inline&#34;&gt;\(N\)&lt;/span&gt;，有一种不劣的走法：&lt;/p&gt;
&lt;img src=&#34;image.png&#34; /&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;维护一下每个点单独走到 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt;，&lt;span class=&#34;math inline&#34;&gt;\(N\)&lt;/span&gt; 的最小代价和同时走到 &lt;span class=&#34;math inline&#34;&gt;\(1,N\)&lt;/span&gt; 的最小代价&lt;/p&gt;
看到一种更加对的写法是&lt;strong&gt;令 &lt;span class=&#34;math inline&#34;&gt;\(f_u\)&lt;/span&gt; 表示 &lt;span class=&#34;math inline&#34;&gt;\(v\)&lt;/span&gt; 的答案，那么可以用 &lt;span class=&#34;math inline&#34;&gt;\(f_v+w(u,v)\)&lt;/span&gt; 更新 &lt;span class=&#34;math inline&#34;&gt;\(f_u\)&lt;/span&gt;&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;那么可以从 &lt;span class=&#34;math inline&#34;&gt;\(1,N\)&lt;/span&gt; 出发做一个 Dij。代码略。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;e---监狱&#34;&gt;E - 监狱&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P9520&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P9520&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;注意要走简单路径，也就是说不存在绕路让道的可能性。容易推出：若输入合法，总能找到一种方式使得每个人受到的指令是连续给出的。&lt;/p&gt;
&lt;p&gt;P.S. 这个结论挪到图上就不成立了，很容易举出反例。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image-1.png&#34; /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;若一个人的起点 / 终点在另一个人的路径上，那么这两个人之间存在先后关系。建图后检查是否为 DAG 即可。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;但建图显然是比较困难的，容易构造出数据使得边数来到 &lt;span class=&#34;math inline&#34;&gt;\(n^2\)&lt;/span&gt; 级别。考虑优化建图。&lt;/p&gt;
&lt;p&gt;发现可以用一个树剖 / 倍增的结构来建图。&lt;/p&gt;
Tips：这一点同样是一个树上路径问题。参见 &lt;a href=&#34;/20231117/#树上问题&#34;&gt;树上问题，倍增和树剖的选择？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;这里的路径要求两端都是开的，这就导致倍增写着很困难（虽然树剖可能也是），不排除我写丑了&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int K = 19;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;01-02.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int T;
    for (std::cin &amp;gt;&amp;gt; T; T--; ) &amp;#123;
        int n, m;
        std::cin &amp;gt;&amp;gt; n;
        std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; g1(n + 1);
        std::vector&amp;lt;int&amp;gt; s(n + 1), t(n + 1);
        for (int i = 1, x, y; i &amp;lt; n; ++i) &amp;#123;
            std::cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; y;
            g1[x].push_back(y), g1[y].push_back(x);
        &amp;#125;
        std::cin &amp;gt;&amp;gt; m;
        std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; g(m + 1);
        std::vector&amp;lt;std::pair&amp;lt;int, int&amp;gt; &amp;gt; a(m + 1);
        for (int i = 1; i &amp;lt;= m; ++i) &amp;#123;
            std::cin &amp;gt;&amp;gt; a[i].first &amp;gt;&amp;gt; a[i].second;
            s[a[i].first] = i;
            t[a[i].second] = i;
        &amp;#125;
        int cnt = m;
        struct node &amp;#123; int fa, i0, i1; &amp;#125;;
        std::vector&amp;lt;std::array&amp;lt;node, K + 1&amp;gt; &amp;gt; p(n + 1);
        std::vector&amp;lt;int&amp;gt; i0(n + 1), i1(n + 1), dep(n + 1), deg(m + 1);
        auto init = [&amp;amp;](void) &amp;#123;
            g.emplace_back(), deg.emplace_back();
            return ++cnt;
        &amp;#125;;
        auto add = [&amp;amp;](int x, int y) &amp;#123;
            g[x].push_back(y), ++deg[y];
            return;
        &amp;#125;;
        for (int i = 1; i &amp;lt;= n; ++i)
            i0[i] = init(), i1[i] = init();
        std::function&amp;lt;void(int, int)&amp;gt; DFS = [&amp;amp;](int x, int fa) &amp;#123;
            if (s[x])
                add(s[x], i1[x]);
            if (t[x])
                add(i0[x], t[x]);
            for (auto i : g1[x])
                if (i != fa) &amp;#123;
                    dep[i] = dep[x] + 1;
                    p[i][0].fa = x;
                    p[i][0].i0 = init(), p[i][0].i1 = init();
                    add(p[i][0].i0, i0[i]), add(i1[i], p[i][0].i1);
                    for (int j = 1; j &amp;lt;= K; ++j) &amp;#123;
                        p[i][j].fa = p[p[i][j - 1].fa][j - 1].fa;
                        if (!p[i][j].fa)
                            break;
                        p[i][j].i0 = init(), p[i][j].i1 = init();
                        add(p[i][j].i0, p[i][j - 1].i0);
                        add(p[i][j].i0, p[p[i][j - 1].fa][j - 1].i0);
                        add(p[i][j - 1].i1, p[i][j].i1);
                        add(p[p[i][j - 1].fa][j - 1].i1, p[i][j].i1);
                    &amp;#125;
                    DFS(i, x);
                &amp;#125;
            return;
        &amp;#125;;
        dep[1] = 1, DFS(1, -1);
        for (int i = 1; i &amp;lt;= m; ++i) &amp;#123;
            auto [x, y] = a[i];
            if (x == y)
                continue;
            if (t[x])
                add(i, t[x]);
            if (s[y])
                add(s[y], i);
            if (dep[x] &amp;lt; dep[y])
                std::swap(x, y);
            x = p[x][0].fa;
            if (dep[x] &amp;gt;= dep[y]) &amp;#123;
                for (int j = K; ~j; --j)
                    if (dep[p[x][j].fa] &amp;gt;= dep[y]) &amp;#123;
                        add(i, p[x][j].i0), add(p[x][j].i1, i);
                        x = p[x][j].fa;
                    &amp;#125;
                if (x == y)
                    continue;
                add(i, p[x][0].i0), add(p[x][0].i1, i);
                x = p[x][0].fa;
            &amp;#125;
            y = p[y][0].fa;
            if (x != y) &amp;#123;
                for (int j = K; ~j; --j)
                    if (p[x][j].fa != p[y][j].fa) &amp;#123;
                        add(i, p[x][j].i0), add(i, p[y][j].i0);
                        add(p[x][j].i1, i), add(p[y][j].i1, i);
                        x = p[x][j].fa, y = p[y][j].fa;
                    &amp;#125;
                add(i, p[x][0].i0), add(i, p[y][0].i0);
                add(p[x][0].i1, i), add(p[y][0].i1, i);
                x = p[x][0].fa;
            &amp;#125;
            add(i, i0[x]), add(i1[x], i);
        &amp;#125;
        std::queue&amp;lt;int&amp;gt; q;
        for (int i = 1; i &amp;lt;= cnt; ++i)
            if (!deg[i])
                q.push(i);
        int tot = 0;
        for (; !q.empty(); ) &amp;#123;
            int x = q.front();
            q.pop(), ++tot;
            for (auto i : g[x])
                if (!--deg[i])
                    q.push(i);
        &amp;#125;
        std::cout &amp;lt;&amp;lt; (tot == cnt ? &amp;quot;Yes&amp;quot; : &amp;quot;No&amp;quot;) &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    &amp;#125;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://xsc062.netlify.app/20250721/</guid>
            <title>解题报告 CF1804F Approximate Diameter</title>
            <link>https://xsc062.netlify.app/20250721/</link>
            <category>二分</category>
            <pubDate>Mon, 21 Jul 2025 22:00:00 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;唉确实没见过这种二分形式。&lt;/p&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;a href=&#34;https://codeforces.com/problemset/problem/1804/F&#34; class=&#34;uri&#34;&gt;https://codeforces.com/problemset/problem/1804/F&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;注意到这个范围基本上就是 &lt;a href=&#34;/20231117/#树的直径图的直径&#34;&gt;图直径的这个性质&lt;/a&gt;，但是我不认识 😅&lt;/p&gt;
&lt;p&gt;每次修改做一次 BFS 过于抽象，发现这个上界多了个 &lt;span class=&#34;math inline&#34;&gt;\(2\)&lt;/span&gt; 的系数，把主元换成 &lt;span class=&#34;math inline&#34;&gt;\(d\)&lt;/span&gt; 可以得到 &lt;span class=&#34;math inline&#34;&gt;\(d\in[0.5s,2s]\)&lt;/span&gt;。有一个很牛的操作，假设在当前图上求出来了一个 &lt;span class=&#34;math inline&#34;&gt;\(s&amp;#39;\)&lt;/span&gt;，显然一直加边，&lt;span class=&#34;math inline&#34;&gt;\(2s\)&lt;/span&gt; 这个上界是在变小的，但只要 &lt;span class=&#34;math inline&#34;&gt;\(s&amp;#39;\le 2s\)&lt;/span&gt; 成立，&lt;span class=&#34;math inline&#34;&gt;\(s&amp;#39;\)&lt;/span&gt; 就一直可以作为区间里的一个估值。如果不成立，发现除以二就成立了。&lt;/p&gt;
&lt;p&gt;转化成二分 &lt;span class=&#34;math inline&#34;&gt;\(s&amp;#39;\)&lt;/span&gt; 最远可以达到的距离即可。每次 &lt;span class=&#34;math inline&#34;&gt;\(s&amp;#39;\)&lt;/span&gt; 除以二，共除了 &lt;span class=&#34;math inline&#34;&gt;\(\log n\)&lt;/span&gt; 次；复杂度 &lt;span class=&#34;math inline&#34;&gt;\(O(n\log^2 n)\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;然后注意不要每次 check 都复制一遍原数组然后加边；应该预先在原图上加好所有边，记录版本。原因是申请空间特别费时间。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#endif
    int n, m, q;
    std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m &amp;gt;&amp;gt; q;
    std::vector&amp;lt;std::vector&amp;lt;std::pair&amp;lt;int, int&amp;gt; &amp;gt; &amp;gt; g(n + 1);
    for (int x, y; m--; ) &amp;#123;
        std::cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; y;
        g[x].emplace_back(y, 0), g[y].emplace_back(x, 0);
    &amp;#125;
    for (int i = 1, x, y; i &amp;lt;= q; ++i) &amp;#123;
        std::cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; y;
        g[x].emplace_back(y, i), g[y].emplace_back(x, i);
    &amp;#125;
    std::vector&amp;lt;int&amp;gt; mem(q + 1, -1);
    auto calc = [&amp;amp;](int id) &amp;#123;
        if (~mem[id])
            return mem[id];
        std::queue&amp;lt;std::pair&amp;lt;int, int&amp;gt; &amp;gt; q;
        std::vector&amp;lt;int&amp;gt; tag(n + 1);
        q.emplace(1, 0), tag[1] = 1;
        int mx = 0;
        for (; !q.empty(); ) &amp;#123;
            auto [x, w] = q.front();
            q.pop(), mx = w;
            for (auto [i, ver] : g[x])
                if (ver &amp;lt;= id &amp;amp;&amp;amp; !tag[i]) &amp;#123;
                    tag[i] = 1;
                    q.emplace(i, w + 1);
                &amp;#125;
        &amp;#125;
        return mem[id] = mx;
    &amp;#125;;
    int s = calc(0);
    for (int i = 0; i &amp;lt;= q; ) &amp;#123;
        int j = i;
        for (int l = i + 1, r = q, mid; l &amp;lt;= r; ) &amp;#123;
            mid = (l + r) &amp;gt;&amp;gt; 1;
            if (s &amp;lt;= 2 * calc(mid))
                j = mid, l = mid + 1;
            else
                r = mid - 1;
        &amp;#125;
        for (; i &amp;lt;= j; ++i)
            std::cout &amp;lt;&amp;lt; s &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
        s /= 2;
    &amp;#125;
    std::cout &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://xsc062.netlify.app/20230813/</guid>
            <title>pn、pm 和 plmm</title>
            <link>https://xsc062.netlify.app/20230813/</link>
            <category>二分</category>
            <category>容斥原理</category>
            <pubDate>Sun, 13 Aug 2023 16:46:13 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;Sotution to &lt;a href=&#34;https://codeforces.com/problemset/problem/258/C&#34;&gt;CF258C Little Elephant and LCM&lt;/a&gt;。&lt;/p&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;
&lt;hr /&gt;
&lt;p&gt;0#：那么这个 pn 可以等于什么？它只能等于 pm。（露出看到 plmm 一般的猥琐坏笑）&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;方便起见，下面 &lt;span class=&#34;math inline&#34;&gt;\(b_{\text{lcm}}\)&lt;/span&gt; 的意思就是 &lt;span class=&#34;math inline&#34;&gt;\(\text{lcm}\{b_1,b_2,\cdots,b_n\}\)&lt;/span&gt;，&lt;span class=&#34;math inline&#34;&gt;\(\max\)&lt;/span&gt; 什么的也同理。&lt;/p&gt;
&lt;p&gt;首先我们都能反应过来，如果 &lt;span class=&#34;math inline&#34;&gt;\(b_{\text{lcm}}=b_{\max}\)&lt;/span&gt;，那么 &lt;span class=&#34;math inline&#34;&gt;\(b\)&lt;/span&gt; 中的最大值就得是 &lt;span class=&#34;math inline&#34;&gt;\(b_{\text {lcm}}\)&lt;/span&gt;，而其他元素都得是 &lt;span class=&#34;math inline&#34;&gt;\(b_{\max}\)&lt;/span&gt; 的因数。&lt;/p&gt;
&lt;p&gt;既然涉及到求 &lt;span class=&#34;math inline&#34;&gt;\(b_{\max}\)&lt;/span&gt; 的因数，那我们势必避免不了枚举 &lt;span class=&#34;math inline&#34;&gt;\(b_{\max}\)&lt;/span&gt;。我一开始陷入了一个 trick：我并不知道 &lt;span class=&#34;math inline&#34;&gt;\(b_{\max}\)&lt;/span&gt; 应该处于哪一个位置。但其实这不重要，它对我们最后的方案没有影响，有影响的是「有多少个位置可以取到当前枚举的 &lt;span class=&#34;math inline&#34;&gt;\(b_{\max}\)&lt;/span&gt;」。&lt;/p&gt;
&lt;p&gt;对于当前枚举的 &lt;span class=&#34;math inline&#34;&gt;\(b_{\max}\)&lt;/span&gt;（假设为 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt;），我们找到它的所有因数 &lt;span class=&#34;math inline&#34;&gt;\(p_1\sim p_m\)&lt;/span&gt;，按从小到大的顺序排列。对于一个 &lt;span class=&#34;math inline&#34;&gt;\(a_i\)&lt;/span&gt;，当且仅当 &lt;span class=&#34;math inline&#34;&gt;\(a_i\ge p_j\)&lt;/span&gt; 时，&lt;span class=&#34;math inline&#34;&gt;\(a_i\)&lt;/span&gt; 可以选择 &lt;span class=&#34;math inline&#34;&gt;\(p_j\)&lt;/span&gt;。那么我们找到 &lt;span class=&#34;math inline&#34;&gt;\(a_i\)&lt;/span&gt; 可以选到的最大的 &lt;span class=&#34;math inline&#34;&gt;\(p_j\)&lt;/span&gt;，此时 &lt;span class=&#34;math inline&#34;&gt;\(a_i\)&lt;/span&gt; 的选择就是 &lt;span class=&#34;math inline&#34;&gt;\(p_1\sim p_j\)&lt;/span&gt;，共 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; 种。&lt;/p&gt;
&lt;p&gt;那么我们在外面已经有一层枚举 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 的循环的前提下，再遍历 &lt;span class=&#34;math inline&#34;&gt;\(a\)&lt;/span&gt; 数组无疑是会起飞的，我们考虑倒过来，遍历 &lt;span class=&#34;math inline&#34;&gt;\(p\)&lt;/span&gt;，对于每个 &lt;span class=&#34;math inline&#34;&gt;\(p_j\)&lt;/span&gt;，找到它是多少个 &lt;span class=&#34;math inline&#34;&gt;\(a_i\)&lt;/span&gt; 的最大选择（假设为 &lt;span class=&#34;math inline&#34;&gt;\(x_j\)&lt;/span&gt;），那么对于 &lt;span class=&#34;math inline&#34;&gt;\(p_j\)&lt;/span&gt;，它贡献的答案就是 &lt;span class=&#34;math inline&#34;&gt;\(j^{x_j}\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(x_j\)&lt;/span&gt; 的计算也不难，我们用两个二分找到满足 &lt;span class=&#34;math inline&#34;&gt;\(p_j\le a_i &amp;lt; p_j + 1\)&lt;/span&gt; 的 &lt;span class=&#34;math inline&#34;&gt;\(a_i\)&lt;/span&gt; 数量就可以了。那么总方案数就是 &lt;span class=&#34;math inline&#34;&gt;\(\prod j^{x_j}\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;但是别忘了还有 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 为 &lt;span class=&#34;math inline&#34;&gt;\(b_{\max}\)&lt;/span&gt; 的限制。找到 &lt;span class=&#34;math inline&#34;&gt;\(x_m\)&lt;/span&gt;，怎么去满足至少有一个 &lt;span class=&#34;math inline&#34;&gt;\(a_i=k\)&lt;/span&gt; 呢？一个微型容斥，用总方案数减去一个 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 都没有的方案数。那么就规定了每个可以取到 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 的数都必须不取 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt;，本来有 &lt;span class=&#34;math inline&#34;&gt;\(m\)&lt;/span&gt; 种选择，现在只剩下 &lt;span class=&#34;math inline&#34;&gt;\(m−1\)&lt;/span&gt; 种，所以答案就是 &lt;span class=&#34;math inline&#34;&gt;\((m−1)^{x_m}\)&lt;/span&gt;，容斥后为 &lt;span class=&#34;math inline&#34;&gt;\(m^{x_m}−(m−1)^{x_m}\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;对于 &lt;span class=&#34;math inline&#34;&gt;\(b_{\max}=k\)&lt;/span&gt;，最终结果为 &lt;span class=&#34;math inline&#34;&gt;\((\prod\limits_{j=1}^{m−1}j^{x_j})\times (m^{x_m}−(m−1)^{x_m})\)&lt;/span&gt;。加法原理把所有 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 的情况加起来即可。&lt;/p&gt;
&lt;p&gt;对于时间复杂度，枚举 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 是 &lt;span class=&#34;math inline&#34;&gt;\(O(V)\)&lt;/span&gt; 的，找因数是 &lt;span class=&#34;math inline&#34;&gt;\(O(\sqrt V)\)&lt;/span&gt; 的，枚举 &lt;span class=&#34;math inline&#34;&gt;\(p_j\)&lt;/span&gt; 是 &lt;span class=&#34;math inline&#34;&gt;\(\log V\)&lt;/span&gt; 的，二分是 &lt;span class=&#34;math inline&#34;&gt;\(\log n\)&lt;/span&gt; 的。所以最终时间复杂度为 &lt;span class=&#34;math inline&#34;&gt;\(O(V\times \max\{\sqrt V,\log V\times \log n\})\)&lt;/span&gt;。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#define int long long
namespace XSC062 &amp;#123;
using namespace fastIO;
const int mod = 1e9 + 7;
const int maxn = 1e5 + 5;
int a[maxn];
int n, mx, ans, res;
int qkp(int x, int y) &amp;#123;
    int res = 1;
    while (y) &amp;#123;
        if (y &amp;amp; 1) (res *= x) %= mod;
        (x *= x) %= mod, y &amp;gt;&amp;gt;= 1;
    &amp;#125;
    return res;
&amp;#125;
int max(int x, int y) &amp;#123; return x &amp;gt; y ? x : y; &amp;#125;
int main() &amp;#123;
    read(n);
    for (int i = 1; i &amp;lt;= n; ++i) 
        read(a[i]), mx = max(mx, a[i]);
    std::sort(a + 1, a + n + 1);
    for (int k = 1; k &amp;lt;= mx; ++k) &amp;#123;
        res = 1;
        std::vector&amp;lt;int&amp;gt; p;
        p.push_back(-1); // 占位符，方便下标对齐 
        for (int i = 1; i * i &amp;lt;= k; ++i) &amp;#123;
            if (k % i == 0) &amp;#123;
                p.push_back(i);
                if (i * i != k) p.push_back(k / i);
            &amp;#125;
        &amp;#125;
        std::sort(p.begin() + 1, p.end());
        // 先算前 m - 1 个 
        int m = p.size() - 1;
        for (int j = 1; j &amp;lt;= m - 1; ++j) &amp;#123;
            int l, r, x;
            l = std::lower_bound(a + 1, a + n + 1, p[j]) - a;
            r = std::lower_bound(a + 1, a + n + 1, p[j + 1]) - a - 1;
            x = r - l + 1, (res *= qkp(j, x)) %= mod;
        &amp;#125;
        int l, r, x;
        l = std::lower_bound(a + 1, a + n + 1, p[m]) - a;
        r = n, x = r - l + 1;
        (res *= (qkp(m, x) - qkp(m - 1, x))) %= mod;
        (ans += res) %= mod;
    &amp;#125;
    print((ans + mod) % mod, &amp;#39;\n&amp;#39;);
    return 0;
&amp;#125;
&amp;#125; // namespace XSC062
#undef int&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://xsc062.netlify.app/20230729/</guid>
            <title>矩阵</title>
            <link>https://xsc062.netlify.app/20230729/</link>
            <category>网络流</category>
            <category>二分</category>
            <category>上下界网络流</category>
            <pubDate>Sat, 29 Jul 2023 15:38:36 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;Solution to &lt;a href=&#34;http://222.180.160.110:61235/contest/3825/problem/7&#34;&gt;BZOJ2406 矩阵&lt;/a&gt;。&lt;/p&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;
&lt;hr /&gt;
&lt;blockquote&gt;
&lt;p&gt;赛时公告&lt;/p&gt;
&lt;p&gt;现在呢？：现在有弹窗了吗 「2023-07-19 16:45:07」&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;此时无声胜有声。&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;f.bzoj2406矩阵&#34;&gt;F.「BZOJ2406」矩阵&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;http://222.180.160.110:61235/contest/3825/problem/7&#34; class=&#34;uri&#34;&gt;http://222.180.160.110:61235/contest/3825/problem/7&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这是头一次见识到把矩阵和网络流结合在一起的题目。不过这种处理方式也是我们在学习二分图时的常客了：把行和列连边表示某一元素。&lt;/p&gt;
&lt;p&gt;我们发现 &lt;span class=&#34;math inline&#34;&gt;\(B_{i, j}\)&lt;/span&gt; 有给定的上下界，故我们考虑 &lt;strong&gt;上下界网络流&lt;/strong&gt;。那怎么去表示 &lt;span class=&#34;math inline&#34;&gt;\(B_{i, j}\)&lt;/span&gt; 呢？这就要联系到我们刚刚说过的连边方式：用边 &lt;span class=&#34;math inline&#34;&gt;\(i\to j\)&lt;/span&gt; 的流量来表示 &lt;span class=&#34;math inline&#34;&gt;\(B_{i, j}\)&lt;/span&gt;，有 &lt;span class=&#34;math inline&#34;&gt;\([L, R]\)&lt;/span&gt; 的上下界。&lt;/p&gt;
&lt;p&gt;可是我们除了 &lt;span class=&#34;math inline&#34;&gt;\([L,R]\)&lt;/span&gt; 的限制，还有最大值这个条件呀，怎么办呢？&lt;/p&gt;
&lt;p&gt;注意到题目要求最大的最小，自然想到二分答案。设答案为 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt;，则我们需要保证每行每列的答案都 &lt;span class=&#34;math inline&#34;&gt;\(\le x\)&lt;/span&gt;。每行每列，这刚好是我们的建点方式。这对点本身作出了要求，这套路我们熟，让大源点向行连边、列向大汇点连边就好。&lt;/p&gt;
&lt;p&gt;那么这些边的上下界怎么办呢？我们已知 &lt;span class=&#34;math inline&#34;&gt;\(|S_A-S_B|\le x\)&lt;/span&gt;，那么变形得：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
\begin{cases}
S_B\ge S_A-x &amp;amp;(S_B \le S_A) \\
S_B\le S_A+x &amp;amp;(S_B \ge S_A)
\end{cases}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;照理来说，两行的符号相反，我们现在已经得到了一个具有对称美的上下界：&lt;span class=&#34;math inline&#34;&gt;\(S_A-x\le S_B\le S_A+x\)&lt;/span&gt;，就应该速速连边了，可是我怎么看都觉得不舒坦：这个不等式可是带条件的，就这么直接拿来做上下界真的没问题吗？&lt;/p&gt;
&lt;p&gt;&lt;del&gt;答案是没问题，因为我看的题解是这么写的&lt;/del&gt; 本着探索求真精神，我们考虑尊重原不等式（因为原不等式的每一行刚好也有两个相反的符号），将这些边拆成两条，一条的上下界是 &lt;span class=&#34;math inline&#34;&gt;\([S_A-x, S_A]\)&lt;/span&gt;，另一条是 &lt;span class=&#34;math inline&#34;&gt;\([S_A,S_A+x]\)&lt;/span&gt;。6。我明白题解为什么这么写了，一个的下界就是另一个的上界，那直接合并不就行了，这个 naive trick 题解都不屑于写出来。&lt;/p&gt;
&lt;p&gt;然后跑个可行流就可以了。注意要保证边的下界为非负。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#define int long long
namespace XSC062 &amp;#123;
using namespace fastIO;
const int lim = 2e5;
const int maxn = 405;
const int inf = 1e18;
const int maxm = 3e5 + 5;
struct _ &amp;#123;
    int v, w, n;
    _() &amp;#123;&amp;#125;
    _(int v1, int w1, int n1) &amp;#123;
        v = v1, w = w1, n = n1;
    &amp;#125;
&amp;#125;;
_ u[maxm];
int gs, gt, tot;
int a[maxn][maxn];
int l, mid, r, res;
int h[maxn], dif[maxn];
int n, m, cnt, s, t, L, R;
int vis[maxn], now[maxn], dep[maxn];
int max(int x, int y) &amp;#123; return x &amp;gt; y ? x : y; &amp;#125;
int min(int x, int y) &amp;#123; return x &amp;lt; y ? x : y; &amp;#125;
bool BFS(int n) &amp;#123;
    std::fill(vis + 1, vis + n + 1, 0);
    std::fill(dep + 1, dep + n + 1, 0); 
    std::queue&amp;lt;int&amp;gt; q;
    dep[gs] = 1, vis[gs] = 1;
    q.push(gs), now[gs] = h[gs];
    while (!q.empty()) &amp;#123;
        int f = q.front(); q.pop();
        for (int i = h[f]; i; i = u[i].n) &amp;#123;
            int v = u[i].v, w = u[i].w;
            if (vis[v] == 1 || w == 0) continue;
            vis[v] = 1, now[v] = h[v];
            dep[v] = dep[f] + 1, q.push(v);
            if (v == gt) return 1;
        &amp;#125;
    &amp;#125;
    return 0;
&amp;#125;
int findP(int x, int flow = inf) &amp;#123;
    if (x == gt) return flow;
    int rest = flow, i;
    for (i = now[x]; rest &amp;amp;&amp;amp; i; i = u[i].n) &amp;#123;
        now[x] = i;
        int v = u[i].v, w = u[i].w;
        if (dep[v] != dep[x] + 1 || w == 0) continue;
        int t = findP(v, min(rest, w));
        if (t == 0) dep[v] = 0;
        rest -= t, u[i].w -= t, u[i ^ 1].w += t;
    &amp;#125;
    return flow - rest;
&amp;#125;
int Dinic(int n) &amp;#123;
    int res = 0;
    while (BFS(n)) &amp;#123;
        int t = findP(gs);
        while (t) res += t, t = findP(gs);
    &amp;#125;
    return res;
&amp;#125;
void add(int x, int y, int w) &amp;#123;
    u[++tot] = _(y, w, h[x]), h[x] = tot;
    return;
&amp;#125;
void add(int x, int y, int d, int u) &amp;#123;
    add(x, y, u - d), add(y, x, 0);
    dif[x] -= d, dif[y] += d;
    return;
&amp;#125;
void Init(void) &amp;#123;
    tot = 1, cnt = 0;
    memset(h, 0, sizeof (h));
    memset(dif, 0, sizeof (dif));
    return;
&amp;#125;
bool check(int x) &amp;#123;
    Init();
    s = n + m + 1, t = s + 1;
    add(t, s, inf), add(s, t, 0);
    gs = t + 1, gt = t + 2;
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        for (int j = 1; j &amp;lt;= m; ++j)
            add(i, j + n, L, R);
    &amp;#125;
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        int sum = 0;
        for (int j = 1; j &amp;lt;= m; ++j)
            sum += a[i][j];
        add(s, i, max(0, sum - x), sum + x);
    &amp;#125;
    for (int j = 1; j &amp;lt;= m; ++j) &amp;#123;
        int sum = 0;
        for (int i = 1; i &amp;lt;= n; ++i)
            sum += a[i][j];
        add(j + n, t, max(sum - x, 0), sum + x);
    &amp;#125;
    for (int i = 1; i &amp;lt;= t; ++i) &amp;#123;
        if (dif[i] &amp;lt; 0)
            add(i, gt, -dif[i]), add(gt, i, 0);
        else if (dif[i] &amp;gt; 0) &amp;#123;
            add(gs, i, dif[i]);
            add(i, gs, 0), cnt += dif[i];
        &amp;#125;
    &amp;#125;
    return (Dinic(gt) == cnt);
&amp;#125;
int main() &amp;#123;
    read(n), read(m);
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        for (int j = 1; j &amp;lt;= m; ++j)
            read(a[i][j]);
    &amp;#125;
    read(L), read(R);
    l = 0, r = lim, res = -1;
    while (l &amp;lt;= r) &amp;#123;
        mid = (l + r) &amp;gt;&amp;gt; 1;
        if (check(mid))
            res = mid, r = mid - 1;
        else l = mid + 1;
    &amp;#125;
    print(res);
    return 0;
&amp;#125;
&amp;#125; // namespace XSC062
#undef int&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;p&gt;你最好有要事相求.jpg&lt;/p&gt;
 ]]></description>
        </item>
    </channel>
</rss>
