<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://xsc062.netlify.app</id>
    <title> • Posts by &#34;二分&#34; tag</title>
    <link href="https://xsc062.netlify.app" />
    <updated>2025-07-26T06:47:23.000Z</updated>
    <category term="并查集" />
    <category term="斜率优化" />
    <category term="悬线法" />
    <category term="哈希" />
    <category term="字典树" />
    <category term="DP" />
    <category term="单调队列" />
    <category term="分治" />
    <category term="二分图" />
    <category term="CRT / exCRT" />
    <category term="排列组合" />
    <category term="网络流" />
    <category term="费用流" />
    <category term="二分" />
    <category term="上下界网络流" />
    <category term="容斥原理" />
    <category term="线段树" />
    <category term="树状数组" />
    <category term="区间 DP" />
    <category term="构造" />
    <category term="Tarjan" />
    <category term="数据结构" />
    <category term="下饭" />
    <category term="LCA" />
    <category term="倍增" />
    <category term="鸽巢原理" />
    <category term="概率期望" />
    <category term="调和级数" />
    <category term="差分" />
    <category term="思维" />
    <category term="树形 DP" />
    <category term="最小生成树" />
    <category term="SAM" />
    <category term="状压" />
    <category term="分块" />
    <category term="可持久化" />
    <category term="笛卡尔树" />
    <category term="高维前缀和" />
    <category term="闲话" />
    <category term="欧拉回路" />
    <category term="树链剖分" />
    <category term="长链剖分" />
    <category term="KMP" />
    <category term="border" />
    <category term="字符串" />
    <category term="AC 自动机" />
    <category term="SA" />
    <category term="数学" />
    <category term="树上差分" />
    <category term="FWT" />
    <category term="堆" />
    <category term="树的重心" />
    <category term="二项式定理" />
    <category term="二项式反演" />
    <category term="贪心" />
    <category term="均摊" />
    <category term="计数" />
    <category term="优化建图" />
    <category term="反悔贪心" />
    <category term="调整法" />
    <category term="背包" />
    <category term="博弈论" />
    <category term="DP 优化" />
    <category term="虚树" />
    <category term="点分治" />
    <category term="WQS 二分" />
    <category term="闵可夫斯基和" />
    <category term="slope trick" />
    <category term="四边形不等式" />
    <category term="暴力" />
    <category term="状压 DP" />
    <category term="组合数学" />
    <category term="支配对" />
    <category term="DDP" />
    <category term="平衡树" />
    <category term="容斥" />
    <category term="猫树" />
    <category term="Kruskal 重构树" />
    <category term="李超线段树" />
    <entry>
        <id>https://xsc062.netlify.app/20250726/</id>
        <title>解题报告 [GCJ 2018 #1B] Transmutation</title>
        <link rel="alternate" href="https://xsc062.netlify.app/20250726/"/>
        <content type="html">&lt;p&gt;对于『跑 &lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt; 遍』性质的利用。&lt;/p&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P10805&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P10805&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;容易注意到可以二分答案；但似乎没办法找到一种很好的方法在 &lt;span class=&#34;math inline&#34;&gt;\(O(n)\)&lt;/span&gt; 内完成一次 check。&lt;/p&gt;
&lt;p&gt;化用一下网络流中流量的概念；例如下面这个图，假如先从 &lt;span class=&#34;math inline&#34;&gt;\(0\)&lt;/span&gt; 开始跑，发现没办法很好地确定 &lt;span class=&#34;math inline&#34;&gt;\(8\to 2\)&lt;/span&gt; 这条边的流量（原因：没办法确定 &lt;span class=&#34;math inline&#34;&gt;\(8\)&lt;/span&gt; 和 &lt;span class=&#34;math inline&#34;&gt;\(2\)&lt;/span&gt; 的搜索顺序）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;这个时候想到；如果是 &lt;span class=&#34;math inline&#34;&gt;\(2\)&lt;/span&gt; 先被搜到，自然很好；但如果是 &lt;span class=&#34;math inline&#34;&gt;\(8\)&lt;/span&gt; 先被搜到，可以忽略这条由它出发、且未确定的边，先由现在认为的流出量确定流入量。等搜到 &lt;span class=&#34;math inline&#34;&gt;\(2\)&lt;/span&gt; 的时候，再更新一下 &lt;span class=&#34;math inline&#34;&gt;\(8\to 2\)&lt;/span&gt; 的流量。这样 &lt;span class=&#34;math inline&#34;&gt;\(8\)&lt;/span&gt; 的流入量就是错的；容易想到再搜一次来更新。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;类比一下 SPFA，可以认为跑 &lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt; 遍就已经达到能更新的最终状态&lt;/strong&gt;。此时 check 一下是否每个点都合法。&lt;/p&gt;
</content>
        <category term="二分" />
        <category term="暴力" />
        <updated>2025-07-26T06:47:23.000Z</updated>
    </entry>
    <entry>
        <id>https://xsc062.netlify.app/20250721/</id>
        <title>解题报告 CF1804F Approximate Diameter</title>
        <link rel="alternate" href="https://xsc062.netlify.app/20250721/"/>
        <content type="html">&lt;p&gt;唉确实没见过这种二分形式。&lt;/p&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;a href=&#34;https://codeforces.com/problemset/problem/1804/F&#34; class=&#34;uri&#34;&gt;https://codeforces.com/problemset/problem/1804/F&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;注意到这个范围基本上就是 &lt;a href=&#34;/20231117/#树的直径图的直径&#34;&gt;图直径的这个性质&lt;/a&gt;，但是我不认识 😅&lt;/p&gt;
&lt;p&gt;每次修改做一次 BFS 过于抽象，发现这个上界多了个 &lt;span class=&#34;math inline&#34;&gt;\(2\)&lt;/span&gt; 的系数，把主元换成 &lt;span class=&#34;math inline&#34;&gt;\(d\)&lt;/span&gt; 可以得到 &lt;span class=&#34;math inline&#34;&gt;\(d\in[0.5s,2s]\)&lt;/span&gt;。有一个很牛的操作，假设在当前图上求出来了一个 &lt;span class=&#34;math inline&#34;&gt;\(s&amp;#39;\)&lt;/span&gt;，显然一直加边，&lt;span class=&#34;math inline&#34;&gt;\(2s\)&lt;/span&gt; 这个上界是在变小的，但只要 &lt;span class=&#34;math inline&#34;&gt;\(s&amp;#39;\le 2s\)&lt;/span&gt; 成立，&lt;span class=&#34;math inline&#34;&gt;\(s&amp;#39;\)&lt;/span&gt; 就一直可以作为区间里的一个估值。如果不成立，发现除以二就成立了。&lt;/p&gt;
&lt;p&gt;转化成二分 &lt;span class=&#34;math inline&#34;&gt;\(s&amp;#39;\)&lt;/span&gt; 最远可以达到的距离即可。每次 &lt;span class=&#34;math inline&#34;&gt;\(s&amp;#39;\)&lt;/span&gt; 除以二，共除了 &lt;span class=&#34;math inline&#34;&gt;\(\log n\)&lt;/span&gt; 次；复杂度 &lt;span class=&#34;math inline&#34;&gt;\(O(n\log^2 n)\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;然后注意不要每次 check 都复制一遍原数组然后加边；应该预先在原图上加好所有边，记录版本。原因是申请空间特别费时间。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#endif
    int n, m, q;
    std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m &amp;gt;&amp;gt; q;
    std::vector&amp;lt;std::vector&amp;lt;std::pair&amp;lt;int, int&amp;gt; &amp;gt; &amp;gt; g(n + 1);
    for (int x, y; m--; ) &amp;#123;
        std::cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; y;
        g[x].emplace_back(y, 0), g[y].emplace_back(x, 0);
    &amp;#125;
    for (int i = 1, x, y; i &amp;lt;= q; ++i) &amp;#123;
        std::cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; y;
        g[x].emplace_back(y, i), g[y].emplace_back(x, i);
    &amp;#125;
    std::vector&amp;lt;int&amp;gt; mem(q + 1, -1);
    auto calc = [&amp;amp;](int id) &amp;#123;
        if (~mem[id])
            return mem[id];
        std::queue&amp;lt;std::pair&amp;lt;int, int&amp;gt; &amp;gt; q;
        std::vector&amp;lt;int&amp;gt; tag(n + 1);
        q.emplace(1, 0), tag[1] = 1;
        int mx = 0;
        for (; !q.empty(); ) &amp;#123;
            auto [x, w] = q.front();
            q.pop(), mx = w;
            for (auto [i, ver] : g[x])
                if (ver &amp;lt;= id &amp;amp;&amp;amp; !tag[i]) &amp;#123;
                    tag[i] = 1;
                    q.emplace(i, w + 1);
                &amp;#125;
        &amp;#125;
        return mem[id] = mx;
    &amp;#125;;
    int s = calc(0);
    for (int i = 0; i &amp;lt;= q; ) &amp;#123;
        int j = i;
        for (int l = i + 1, r = q, mid; l &amp;lt;= r; ) &amp;#123;
            mid = (l + r) &amp;gt;&amp;gt; 1;
            if (s &amp;lt;= 2 * calc(mid))
                j = mid, l = mid + 1;
            else
                r = mid - 1;
        &amp;#125;
        for (; i &amp;lt;= j; ++i)
            std::cout &amp;lt;&amp;lt; s &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
        s /= 2;
    &amp;#125;
    std::cout &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
</content>
        <category term="二分" />
        <updated>2025-07-21T14:00:00.000Z</updated>
    </entry>
    <entry>
        <id>https://xsc062.netlify.app/20230813/</id>
        <title>pn、pm 和 plmm</title>
        <link rel="alternate" href="https://xsc062.netlify.app/20230813/"/>
        <content type="html">&lt;p&gt;Sotution to &lt;a href=&#34;https://codeforces.com/problemset/problem/258/C&#34;&gt;CF258C Little Elephant and LCM&lt;/a&gt;。&lt;/p&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;
&lt;hr /&gt;
&lt;p&gt;0#：那么这个 pn 可以等于什么？它只能等于 pm。（露出看到 plmm 一般的猥琐坏笑）&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;方便起见，下面 &lt;span class=&#34;math inline&#34;&gt;\(b_{\text{lcm}}\)&lt;/span&gt; 的意思就是 &lt;span class=&#34;math inline&#34;&gt;\(\text{lcm}\{b_1,b_2,\cdots,b_n\}\)&lt;/span&gt;，&lt;span class=&#34;math inline&#34;&gt;\(\max\)&lt;/span&gt; 什么的也同理。&lt;/p&gt;
&lt;p&gt;首先我们都能反应过来，如果 &lt;span class=&#34;math inline&#34;&gt;\(b_{\text{lcm}}=b_{\max}\)&lt;/span&gt;，那么 &lt;span class=&#34;math inline&#34;&gt;\(b\)&lt;/span&gt; 中的最大值就得是 &lt;span class=&#34;math inline&#34;&gt;\(b_{\text {lcm}}\)&lt;/span&gt;，而其他元素都得是 &lt;span class=&#34;math inline&#34;&gt;\(b_{\max}\)&lt;/span&gt; 的因数。&lt;/p&gt;
&lt;p&gt;既然涉及到求 &lt;span class=&#34;math inline&#34;&gt;\(b_{\max}\)&lt;/span&gt; 的因数，那我们势必避免不了枚举 &lt;span class=&#34;math inline&#34;&gt;\(b_{\max}\)&lt;/span&gt;。我一开始陷入了一个 trick：我并不知道 &lt;span class=&#34;math inline&#34;&gt;\(b_{\max}\)&lt;/span&gt; 应该处于哪一个位置。但其实这不重要，它对我们最后的方案没有影响，有影响的是「有多少个位置可以取到当前枚举的 &lt;span class=&#34;math inline&#34;&gt;\(b_{\max}\)&lt;/span&gt;」。&lt;/p&gt;
&lt;p&gt;对于当前枚举的 &lt;span class=&#34;math inline&#34;&gt;\(b_{\max}\)&lt;/span&gt;（假设为 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt;），我们找到它的所有因数 &lt;span class=&#34;math inline&#34;&gt;\(p_1\sim p_m\)&lt;/span&gt;，按从小到大的顺序排列。对于一个 &lt;span class=&#34;math inline&#34;&gt;\(a_i\)&lt;/span&gt;，当且仅当 &lt;span class=&#34;math inline&#34;&gt;\(a_i\ge p_j\)&lt;/span&gt; 时，&lt;span class=&#34;math inline&#34;&gt;\(a_i\)&lt;/span&gt; 可以选择 &lt;span class=&#34;math inline&#34;&gt;\(p_j\)&lt;/span&gt;。那么我们找到 &lt;span class=&#34;math inline&#34;&gt;\(a_i\)&lt;/span&gt; 可以选到的最大的 &lt;span class=&#34;math inline&#34;&gt;\(p_j\)&lt;/span&gt;，此时 &lt;span class=&#34;math inline&#34;&gt;\(a_i\)&lt;/span&gt; 的选择就是 &lt;span class=&#34;math inline&#34;&gt;\(p_1\sim p_j\)&lt;/span&gt;，共 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; 种。&lt;/p&gt;
&lt;p&gt;那么我们在外面已经有一层枚举 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 的循环的前提下，再遍历 &lt;span class=&#34;math inline&#34;&gt;\(a\)&lt;/span&gt; 数组无疑是会起飞的，我们考虑倒过来，遍历 &lt;span class=&#34;math inline&#34;&gt;\(p\)&lt;/span&gt;，对于每个 &lt;span class=&#34;math inline&#34;&gt;\(p_j\)&lt;/span&gt;，找到它是多少个 &lt;span class=&#34;math inline&#34;&gt;\(a_i\)&lt;/span&gt; 的最大选择（假设为 &lt;span class=&#34;math inline&#34;&gt;\(x_j\)&lt;/span&gt;），那么对于 &lt;span class=&#34;math inline&#34;&gt;\(p_j\)&lt;/span&gt;，它贡献的答案就是 &lt;span class=&#34;math inline&#34;&gt;\(j^{x_j}\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(x_j\)&lt;/span&gt; 的计算也不难，我们用两个二分找到满足 &lt;span class=&#34;math inline&#34;&gt;\(p_j\le a_i &amp;lt; p_j + 1\)&lt;/span&gt; 的 &lt;span class=&#34;math inline&#34;&gt;\(a_i\)&lt;/span&gt; 数量就可以了。那么总方案数就是 &lt;span class=&#34;math inline&#34;&gt;\(\prod j^{x_j}\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;但是别忘了还有 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 为 &lt;span class=&#34;math inline&#34;&gt;\(b_{\max}\)&lt;/span&gt; 的限制。找到 &lt;span class=&#34;math inline&#34;&gt;\(x_m\)&lt;/span&gt;，怎么去满足至少有一个 &lt;span class=&#34;math inline&#34;&gt;\(a_i=k\)&lt;/span&gt; 呢？一个微型容斥，用总方案数减去一个 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 都没有的方案数。那么就规定了每个可以取到 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 的数都必须不取 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt;，本来有 &lt;span class=&#34;math inline&#34;&gt;\(m\)&lt;/span&gt; 种选择，现在只剩下 &lt;span class=&#34;math inline&#34;&gt;\(m−1\)&lt;/span&gt; 种，所以答案就是 &lt;span class=&#34;math inline&#34;&gt;\((m−1)^{x_m}\)&lt;/span&gt;，容斥后为 &lt;span class=&#34;math inline&#34;&gt;\(m^{x_m}−(m−1)^{x_m}\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;对于 &lt;span class=&#34;math inline&#34;&gt;\(b_{\max}=k\)&lt;/span&gt;，最终结果为 &lt;span class=&#34;math inline&#34;&gt;\((\prod\limits_{j=1}^{m−1}j^{x_j})\times (m^{x_m}−(m−1)^{x_m})\)&lt;/span&gt;。加法原理把所有 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 的情况加起来即可。&lt;/p&gt;
&lt;p&gt;对于时间复杂度，枚举 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 是 &lt;span class=&#34;math inline&#34;&gt;\(O(V)\)&lt;/span&gt; 的，找因数是 &lt;span class=&#34;math inline&#34;&gt;\(O(\sqrt V)\)&lt;/span&gt; 的，枚举 &lt;span class=&#34;math inline&#34;&gt;\(p_j\)&lt;/span&gt; 是 &lt;span class=&#34;math inline&#34;&gt;\(\log V\)&lt;/span&gt; 的，二分是 &lt;span class=&#34;math inline&#34;&gt;\(\log n\)&lt;/span&gt; 的。所以最终时间复杂度为 &lt;span class=&#34;math inline&#34;&gt;\(O(V\times \max\{\sqrt V,\log V\times \log n\})\)&lt;/span&gt;。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#define int long long
namespace XSC062 &amp;#123;
using namespace fastIO;
const int mod = 1e9 + 7;
const int maxn = 1e5 + 5;
int a[maxn];
int n, mx, ans, res;
int qkp(int x, int y) &amp;#123;
    int res = 1;
    while (y) &amp;#123;
        if (y &amp;amp; 1) (res *= x) %= mod;
        (x *= x) %= mod, y &amp;gt;&amp;gt;= 1;
    &amp;#125;
    return res;
&amp;#125;
int max(int x, int y) &amp;#123; return x &amp;gt; y ? x : y; &amp;#125;
int main() &amp;#123;
    read(n);
    for (int i = 1; i &amp;lt;= n; ++i) 
        read(a[i]), mx = max(mx, a[i]);
    std::sort(a + 1, a + n + 1);
    for (int k = 1; k &amp;lt;= mx; ++k) &amp;#123;
        res = 1;
        std::vector&amp;lt;int&amp;gt; p;
        p.push_back(-1); // 占位符，方便下标对齐 
        for (int i = 1; i * i &amp;lt;= k; ++i) &amp;#123;
            if (k % i == 0) &amp;#123;
                p.push_back(i);
                if (i * i != k) p.push_back(k / i);
            &amp;#125;
        &amp;#125;
        std::sort(p.begin() + 1, p.end());
        // 先算前 m - 1 个 
        int m = p.size() - 1;
        for (int j = 1; j &amp;lt;= m - 1; ++j) &amp;#123;
            int l, r, x;
            l = std::lower_bound(a + 1, a + n + 1, p[j]) - a;
            r = std::lower_bound(a + 1, a + n + 1, p[j + 1]) - a - 1;
            x = r - l + 1, (res *= qkp(j, x)) %= mod;
        &amp;#125;
        int l, r, x;
        l = std::lower_bound(a + 1, a + n + 1, p[m]) - a;
        r = n, x = r - l + 1;
        (res *= (qkp(m, x) - qkp(m - 1, x))) %= mod;
        (ans += res) %= mod;
    &amp;#125;
    print((ans + mod) % mod, &amp;#39;\n&amp;#39;);
    return 0;
&amp;#125;
&amp;#125; // namespace XSC062
#undef int&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
</content>
        <category term="二分" />
        <category term="容斥原理" />
        <updated>2023-08-13T08:46:13.000Z</updated>
    </entry>
    <entry>
        <id>https://xsc062.netlify.app/20230729/</id>
        <title>矩阵</title>
        <link rel="alternate" href="https://xsc062.netlify.app/20230729/"/>
        <content type="html">&lt;p&gt;Solution to &lt;a href=&#34;http://222.180.160.110:61235/contest/3825/problem/7&#34;&gt;BZOJ2406 矩阵&lt;/a&gt;。&lt;/p&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;
&lt;hr /&gt;
&lt;blockquote&gt;
&lt;p&gt;赛时公告&lt;/p&gt;
&lt;p&gt;现在呢？：现在有弹窗了吗 「2023-07-19 16:45:07」&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;此时无声胜有声。&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;f.bzoj2406矩阵&#34;&gt;F.「BZOJ2406」矩阵&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;http://222.180.160.110:61235/contest/3825/problem/7&#34; class=&#34;uri&#34;&gt;http://222.180.160.110:61235/contest/3825/problem/7&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这是头一次见识到把矩阵和网络流结合在一起的题目。不过这种处理方式也是我们在学习二分图时的常客了：把行和列连边表示某一元素。&lt;/p&gt;
&lt;p&gt;我们发现 &lt;span class=&#34;math inline&#34;&gt;\(B_{i, j}\)&lt;/span&gt; 有给定的上下界，故我们考虑 &lt;strong&gt;上下界网络流&lt;/strong&gt;。那怎么去表示 &lt;span class=&#34;math inline&#34;&gt;\(B_{i, j}\)&lt;/span&gt; 呢？这就要联系到我们刚刚说过的连边方式：用边 &lt;span class=&#34;math inline&#34;&gt;\(i\to j\)&lt;/span&gt; 的流量来表示 &lt;span class=&#34;math inline&#34;&gt;\(B_{i, j}\)&lt;/span&gt;，有 &lt;span class=&#34;math inline&#34;&gt;\([L, R]\)&lt;/span&gt; 的上下界。&lt;/p&gt;
&lt;p&gt;可是我们除了 &lt;span class=&#34;math inline&#34;&gt;\([L,R]\)&lt;/span&gt; 的限制，还有最大值这个条件呀，怎么办呢？&lt;/p&gt;
&lt;p&gt;注意到题目要求最大的最小，自然想到二分答案。设答案为 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt;，则我们需要保证每行每列的答案都 &lt;span class=&#34;math inline&#34;&gt;\(\le x\)&lt;/span&gt;。每行每列，这刚好是我们的建点方式。这对点本身作出了要求，这套路我们熟，让大源点向行连边、列向大汇点连边就好。&lt;/p&gt;
&lt;p&gt;那么这些边的上下界怎么办呢？我们已知 &lt;span class=&#34;math inline&#34;&gt;\(|S_A-S_B|\le x\)&lt;/span&gt;，那么变形得：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
\begin{cases}
S_B\ge S_A-x &amp;amp;(S_B \le S_A) \\
S_B\le S_A+x &amp;amp;(S_B \ge S_A)
\end{cases}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;照理来说，两行的符号相反，我们现在已经得到了一个具有对称美的上下界：&lt;span class=&#34;math inline&#34;&gt;\(S_A-x\le S_B\le S_A+x\)&lt;/span&gt;，就应该速速连边了，可是我怎么看都觉得不舒坦：这个不等式可是带条件的，就这么直接拿来做上下界真的没问题吗？&lt;/p&gt;
&lt;p&gt;&lt;del&gt;答案是没问题，因为我看的题解是这么写的&lt;/del&gt; 本着探索求真精神，我们考虑尊重原不等式（因为原不等式的每一行刚好也有两个相反的符号），将这些边拆成两条，一条的上下界是 &lt;span class=&#34;math inline&#34;&gt;\([S_A-x, S_A]\)&lt;/span&gt;，另一条是 &lt;span class=&#34;math inline&#34;&gt;\([S_A,S_A+x]\)&lt;/span&gt;。6。我明白题解为什么这么写了，一个的下界就是另一个的上界，那直接合并不就行了，这个 naive trick 题解都不屑于写出来。&lt;/p&gt;
&lt;p&gt;然后跑个可行流就可以了。注意要保证边的下界为非负。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#define int long long
namespace XSC062 &amp;#123;
using namespace fastIO;
const int lim = 2e5;
const int maxn = 405;
const int inf = 1e18;
const int maxm = 3e5 + 5;
struct _ &amp;#123;
    int v, w, n;
    _() &amp;#123;&amp;#125;
    _(int v1, int w1, int n1) &amp;#123;
        v = v1, w = w1, n = n1;
    &amp;#125;
&amp;#125;;
_ u[maxm];
int gs, gt, tot;
int a[maxn][maxn];
int l, mid, r, res;
int h[maxn], dif[maxn];
int n, m, cnt, s, t, L, R;
int vis[maxn], now[maxn], dep[maxn];
int max(int x, int y) &amp;#123; return x &amp;gt; y ? x : y; &amp;#125;
int min(int x, int y) &amp;#123; return x &amp;lt; y ? x : y; &amp;#125;
bool BFS(int n) &amp;#123;
    std::fill(vis + 1, vis + n + 1, 0);
    std::fill(dep + 1, dep + n + 1, 0); 
    std::queue&amp;lt;int&amp;gt; q;
    dep[gs] = 1, vis[gs] = 1;
    q.push(gs), now[gs] = h[gs];
    while (!q.empty()) &amp;#123;
        int f = q.front(); q.pop();
        for (int i = h[f]; i; i = u[i].n) &amp;#123;
            int v = u[i].v, w = u[i].w;
            if (vis[v] == 1 || w == 0) continue;
            vis[v] = 1, now[v] = h[v];
            dep[v] = dep[f] + 1, q.push(v);
            if (v == gt) return 1;
        &amp;#125;
    &amp;#125;
    return 0;
&amp;#125;
int findP(int x, int flow = inf) &amp;#123;
    if (x == gt) return flow;
    int rest = flow, i;
    for (i = now[x]; rest &amp;amp;&amp;amp; i; i = u[i].n) &amp;#123;
        now[x] = i;
        int v = u[i].v, w = u[i].w;
        if (dep[v] != dep[x] + 1 || w == 0) continue;
        int t = findP(v, min(rest, w));
        if (t == 0) dep[v] = 0;
        rest -= t, u[i].w -= t, u[i ^ 1].w += t;
    &amp;#125;
    return flow - rest;
&amp;#125;
int Dinic(int n) &amp;#123;
    int res = 0;
    while (BFS(n)) &amp;#123;
        int t = findP(gs);
        while (t) res += t, t = findP(gs);
    &amp;#125;
    return res;
&amp;#125;
void add(int x, int y, int w) &amp;#123;
    u[++tot] = _(y, w, h[x]), h[x] = tot;
    return;
&amp;#125;
void add(int x, int y, int d, int u) &amp;#123;
    add(x, y, u - d), add(y, x, 0);
    dif[x] -= d, dif[y] += d;
    return;
&amp;#125;
void Init(void) &amp;#123;
    tot = 1, cnt = 0;
    memset(h, 0, sizeof (h));
    memset(dif, 0, sizeof (dif));
    return;
&amp;#125;
bool check(int x) &amp;#123;
    Init();
    s = n + m + 1, t = s + 1;
    add(t, s, inf), add(s, t, 0);
    gs = t + 1, gt = t + 2;
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        for (int j = 1; j &amp;lt;= m; ++j)
            add(i, j + n, L, R);
    &amp;#125;
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        int sum = 0;
        for (int j = 1; j &amp;lt;= m; ++j)
            sum += a[i][j];
        add(s, i, max(0, sum - x), sum + x);
    &amp;#125;
    for (int j = 1; j &amp;lt;= m; ++j) &amp;#123;
        int sum = 0;
        for (int i = 1; i &amp;lt;= n; ++i)
            sum += a[i][j];
        add(j + n, t, max(sum - x, 0), sum + x);
    &amp;#125;
    for (int i = 1; i &amp;lt;= t; ++i) &amp;#123;
        if (dif[i] &amp;lt; 0)
            add(i, gt, -dif[i]), add(gt, i, 0);
        else if (dif[i] &amp;gt; 0) &amp;#123;
            add(gs, i, dif[i]);
            add(i, gs, 0), cnt += dif[i];
        &amp;#125;
    &amp;#125;
    return (Dinic(gt) == cnt);
&amp;#125;
int main() &amp;#123;
    read(n), read(m);
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        for (int j = 1; j &amp;lt;= m; ++j)
            read(a[i][j]);
    &amp;#125;
    read(L), read(R);
    l = 0, r = lim, res = -1;
    while (l &amp;lt;= r) &amp;#123;
        mid = (l + r) &amp;gt;&amp;gt; 1;
        if (check(mid))
            res = mid, r = mid - 1;
        else l = mid + 1;
    &amp;#125;
    print(res);
    return 0;
&amp;#125;
&amp;#125; // namespace XSC062
#undef int&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;p&gt;你最好有要事相求.jpg&lt;/p&gt;
</content>
        <category term="网络流" />
        <category term="二分" />
        <category term="上下界网络流" />
        <updated>2023-07-29T07:38:36.000Z</updated>
    </entry>
</feed>
