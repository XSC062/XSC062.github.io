<?xml version="1.0"?>
<rss version="2.0">
    <channel>
        <title> • Posts by &#34;cdq 分治&#34; tag</title>
        <link>https://xsc062.netlify.app</link>
        <description></description>
        <language>zh-CN</language>
        <pubDate>Wed, 29 Oct 2025 15:36:06 +0800</pubDate>
        <lastBuildDate>Wed, 29 Oct 2025 15:36:06 +0800</lastBuildDate>
        <category>并查集</category>
        <category>斜率优化</category>
        <category>悬线法</category>
        <category>哈希</category>
        <category>字典树</category>
        <category>DP</category>
        <category>单调队列</category>
        <category>分治</category>
        <category>计数</category>
        <category>容斥</category>
        <category>二分图</category>
        <category>CRT / exCRT</category>
        <category>排列组合</category>
        <category>网络流</category>
        <category>二分</category>
        <category>容斥原理</category>
        <category>线段树</category>
        <category>树状数组</category>
        <category>区间 DP</category>
        <category>构造</category>
        <category>数据结构</category>
        <category>Tarjan</category>
        <category>下饭</category>
        <category>李超线段树</category>
        <category>树链剖分</category>
        <category>LCA</category>
        <category>倍增</category>
        <category>鸽巢原理</category>
        <category>数学</category>
        <category>调和级数</category>
        <category>差分</category>
        <category>思维</category>
        <category>树形 DP</category>
        <category>最小生成树</category>
        <category>状压</category>
        <category>高维前缀和</category>
        <category>SAM</category>
        <category>分块</category>
        <category>可持久化</category>
        <category>笛卡尔树</category>
        <category>闲话</category>
        <category>欧拉回路</category>
        <category>长链剖分</category>
        <category>KMP</category>
        <category>border</category>
        <category>随机化</category>
        <category>字符串</category>
        <category>AC 自动机</category>
        <category>SA</category>
        <category>树上差分</category>
        <category>FWT</category>
        <category>堆</category>
        <category>树的重心</category>
        <category>贪心</category>
        <category>均摊</category>
        <category>优化建图</category>
        <category>反悔贪心</category>
        <category>调整法</category>
        <category>背包</category>
        <category>博弈论</category>
        <category>DP 优化</category>
        <category>虚树</category>
        <category>点分治</category>
        <category>四边形不等式</category>
        <category>支配对</category>
        <category>DDP</category>
        <category>CDQ 分治</category>
        <category>猫树</category>
        <category>DP 套 DP</category>
        <category>Kruskal 重构树</category>
        <category>高精度</category>
        <category>最短路</category>
        <category>树套树</category>
        <category>二项式反演</category>
        <category>搜索</category>
        <item>
            <guid isPermalink="true">https://xsc062.netlify.app/20251029/</guid>
            <title>CDQ 小记</title>
            <link>https://xsc062.netlify.app/20251029/</link>
            <category>CDQ 分治</category>
            <pubDate>Wed, 29 Oct 2025 15:36:06 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;日常不理解算法本质&lt;/p&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;
&lt;hr /&gt;
&lt;p&gt;周末给 afewdgre 讲题，偶遇简单时间轴问题，拼尽全力勉强战胜&lt;/p&gt;
&lt;h2 id=&#34;何为时间轴&#34;&gt;何为时间轴&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;特点：单向。&lt;/p&gt;
&lt;p&gt;前面的修改会影响后面的查询；反过来，后面的修改不会影响前面的查询。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在大部分 DS 题目中，顺序操作是满足这个条件的。考虑不存在明显操作时间轴的问题，通常处理方式是扫描线：即用坐标轴当时间轴，这样做的前提条件也是『前面的修改影响后面的查询，但后面的修改不影响前面的查询』。这里拿给 afewdgre 讲的矩形面积并举例。&lt;/p&gt;
&lt;p&gt;矩形面积并中，把一段 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 坐标上，每个 &lt;span class=&#34;math inline&#34;&gt;\(y\)&lt;/span&gt; 上矩形存在的状态转化成『某个时刻，一段 &lt;span class=&#34;math inline&#34;&gt;\(y\)&lt;/span&gt; 是否被覆盖』，矩形的增删则用差分的方式维护。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;cdq-分治&#34;&gt;CDQ 分治&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;在需求时间轴的需求上，额外要求：&lt;/p&gt;
&lt;p&gt;修改之间无依赖，或者说，&lt;strong&gt;单次修改对询问的影响是可求的。&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;这样就可以分治。大部分分治的基本目标都是，使相同的计算不用被多次进行。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;每层 CDQ 会统计每个 &lt;span class=&#34;math inline&#34;&gt;\([l,mid]\)&lt;/span&gt; 的修改对 &lt;span class=&#34;math inline&#34;&gt;\([mid+1,r]\)&lt;/span&gt; 询问的影响。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;好像讲完了？&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://xsc062.netlify.app/20250820/</guid>
            <title>杂题</title>
            <link>https://xsc062.netlify.app/20250820/</link>
            <category>DP</category>
            <category>计数</category>
            <category>CDQ 分治</category>
            <pubDate>Wed, 20 Aug 2025 20:26:44 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;困难&lt;/p&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;b.-beauty拆贡献&#34;&gt;B. beauty（拆贡献）&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.becoder.com.cn/contest/6513/problem/2&#34; class=&#34;uri&#34;&gt;https://www.becoder.com.cn/contest/6513/problem/2&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定 &lt;span class=&#34;math inline&#34;&gt;\(n,V\)&lt;/span&gt;，求出对于所有长度为 &lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt;，值域为 &lt;span class=&#34;math inline&#34;&gt;\([1,V]\)&lt;/span&gt; 的序列 &lt;span class=&#34;math inline&#34;&gt;\(a_{1\sim n}\)&lt;/span&gt;，&lt;span class=&#34;math inline&#34;&gt;\(\sum_{i=1}^n |a_i-a_{n-i+1}|\)&lt;/span&gt; 的和。&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(n,V\le 5000\)&lt;/span&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;容易想到算贡献，会有一个 &lt;span class=&#34;math inline&#34;&gt;\(O(n^2V)\)&lt;/span&gt; 的做法。但是想 &lt;span class=&#34;math inline&#34;&gt;\(O(nV)\)&lt;/span&gt; 做是很抽象的，和 &lt;span class=&#34;math inline&#34;&gt;\(O(n^2V)\)&lt;/span&gt; 的思路已经很不一样了&lt;/li&gt;
&lt;li&gt;经典 trick，&lt;span class=&#34;math inline&#34;&gt;\(a_{i+n/2}-a_i=\sum\limits_{x=0}^{+\infty} [a_i\le x&amp;lt;a_{i+n/2}]\)&lt;/span&gt; 拆贡献 。故要算 &lt;span class=&#34;math inline&#34;&gt;\(a_{i}-a_{i+n/2}\)&lt;/span&gt;，只需要对于每个 &lt;span class=&#34;math inline&#34;&gt;\(x\in[a_i,a_{i+n/2})\)&lt;/span&gt; 计算贡献。&lt;/li&gt;
&lt;li&gt;枚举 &lt;span class=&#34;math inline&#34;&gt;\(x\in [1,V)\)&lt;/span&gt;，再枚举最大的 &lt;span class=&#34;math inline&#34;&gt;\(t\)&lt;/span&gt;，满足 &lt;span class=&#34;math inline&#34;&gt;\(a_t\ge x\)&lt;/span&gt;。那么有 &lt;span class=&#34;math inline&#34;&gt;\(t\)&lt;/span&gt; 个 &lt;span class=&#34;math inline&#34;&gt;\(a_i\le x\)&lt;/span&gt;，同时有 &lt;span class=&#34;math inline&#34;&gt;\(n-t\)&lt;/span&gt; 个 &lt;span class=&#34;math inline&#34;&gt;\(a_i&amp;gt;x\)&lt;/span&gt;；满足 &lt;span class=&#34;math inline&#34;&gt;\(i\le n/2\)&lt;/span&gt; 的 &lt;span class=&#34;math inline&#34;&gt;\(a_{i},a_{i+n/2}\)&lt;/span&gt; 对数应该是 &lt;span class=&#34;math inline&#34;&gt;\(\min(t,n-t)\)&lt;/span&gt;。故对于一个确定的序列，&lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 共有 &lt;span class=&#34;math inline&#34;&gt;\(\min(t,n-t)\)&lt;/span&gt; 的贡献。&lt;/li&gt;
&lt;li&gt;考虑计数满足 &lt;span class=&#34;math inline&#34;&gt;\(a_t\le x\)&lt;/span&gt; 的 &lt;span class=&#34;math inline&#34;&gt;\(a\)&lt;/span&gt;，这要求第 &lt;span class=&#34;math inline&#34;&gt;\(t\)&lt;/span&gt; 大的数 &lt;span class=&#34;math inline&#34;&gt;\(\le x\)&lt;/span&gt; 而第 &lt;span class=&#34;math inline&#34;&gt;\(t+1\)&lt;/span&gt; 大的数 &lt;span class=&#34;math inline&#34;&gt;\(&amp;gt;x\)&lt;/span&gt;，也即在 &lt;span class=&#34;math inline&#34;&gt;\([1,x]\)&lt;/span&gt; 里找 &lt;span class=&#34;math inline&#34;&gt;\(t\)&lt;/span&gt; 个数再在 &lt;span class=&#34;math inline&#34;&gt;\((x,V]\)&lt;/span&gt; 里找 &lt;span class=&#34;math inline&#34;&gt;\(n-t\)&lt;/span&gt; 个数，注意还要再乘上这两种数拼起来的方案数。&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int mod = 998244353;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
    std::freopen(&amp;quot;beauty.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;beauty.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int T;
    std::vector&amp;lt;long long&amp;gt; fac(5001), inv(5001);
    std::vector&amp;lt;std::vector&amp;lt;long long&amp;gt; &amp;gt; pw(5001, std::vector&amp;lt;long long&amp;gt; (5001));
    fac[0] = inv[0] = 1ll;
    for (int i = 1; i &amp;lt;= 5000; ++i) &amp;#123;
        fac[i] = fac[i - 1] * i % mod;
        pw[i][0] = 1ll;
        for (int j = 1; j &amp;lt;= 5000; ++j)
            pw[i][j] = pw[i][j - 1] * i % mod;
    &amp;#125;
    auto qkp = [](long long x, int y) &amp;#123;
        auto res(1ll);
        for (; y; (x *= x) %= mod, y &amp;gt;&amp;gt;= 1)
            if (y &amp;amp; 1)
                (res *= x) %= mod;
        return res;
    &amp;#125;;
    inv[5000] = qkp(fac[5000], mod - 2);
    for (int i = 4999; i; --i)
        inv[i] = inv[i + 1] * (i + 1) % mod;
    auto C = [&amp;amp;](int n, int m) &amp;#123;
        return fac[n] * inv[m] % mod * inv[n - m] % mod;
    &amp;#125;;
    for (std::cin &amp;gt;&amp;gt; T; T--; ) &amp;#123;
        int n, V;
        std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; V;
        auto res(0ll);
        for (int x = 1; x &amp;lt; V; ++x)
            for (int t = 1; t &amp;lt; n; ++t) &amp;#123;
                int k = std::min(t, n - t);
                (res += k * pw[x][t] % mod * pw[V - x][n - t] % mod * C(n, t) % mod) %= mod;
            &amp;#125;
        std::cout &amp;lt;&amp;lt; res * 2 % mod &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    &amp;#125;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;c.-drink-bar容斥-偏序&#34;&gt;C. Drink Bar（容斥 + 偏序）&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/AT_snuke21_j&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/AT_snuke21_j&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;三个属性都是排列，可以推理出只要两个三元组中，作出贡献的元素不完全相同，两个三元组就不同。讨论作出贡献的元素数量。&lt;/li&gt;
&lt;li&gt;只有一个元素作出贡献，答案为 &lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;有两个元素作出贡献，任选的话答案为 &lt;span class=&#34;math inline&#34;&gt;\(C_n^2\)&lt;/span&gt;，要减去一个元素严格优于另一个元素的情况，三维偏序即可。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;有三个元素作出贡献，是个有点复杂的容斥，不妨设三元组为 &lt;span class=&#34;math inline&#34;&gt;\((i,j,k)\)&lt;/span&gt;，其中贡献次数最多的为 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt;&lt;/p&gt;
&lt;ol type=&#34;1&#34;&gt;
&lt;li&gt;&lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 贡献了 &lt;span class=&#34;math inline&#34;&gt;\(\ge 1\)&lt;/span&gt; 次，方案数为 &lt;span class=&#34;math inline&#34;&gt;\(C_n^3\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 贡献了 &lt;span class=&#34;math inline&#34;&gt;\(\ge 2\)&lt;/span&gt; 次，枚举作出两次贡献的属性，以 &lt;span class=&#34;math inline&#34;&gt;\(a,b\)&lt;/span&gt; 为例，那么有 &lt;span class=&#34;math inline&#34;&gt;\(a_j,a_k&amp;lt;a_i\)&lt;/span&gt;，以及 &lt;span class=&#34;math inline&#34;&gt;\(b_j,b_k&amp;lt;b_i\)&lt;/span&gt;，二维偏序即可&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 贡献了 &lt;span class=&#34;math inline&#34;&gt;\(\ge 3\)&lt;/span&gt; 次，依然是三维偏序，可以用『两个元素做出贡献』中 cdq 得到的值算出答案。记得乘 2，因为被多减了 2 次。&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n;
    std::cin &amp;gt;&amp;gt; n;
    struct node &amp;#123; int a, b, c, res; &amp;#125;;
    std::vector&amp;lt;node&amp;gt; a(n + 1);
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        std::cin &amp;gt;&amp;gt; a[i].a &amp;gt;&amp;gt; a[i].b &amp;gt;&amp;gt; a[i].c;
        a[i].res = 0;
    &amp;#125;
    long long res = n;
    res += (long long)n * (n - 1) / 2;
    std::vector&amp;lt;int&amp;gt; bit(n + 1);
    auto lowbit = [](int x) &amp;#123;
        return x &amp;amp; -x;
    &amp;#125;;
    auto add = [&amp;amp;](int x, int v) &amp;#123;
        for (; x &amp;lt;= n; x += lowbit(x))
            bit[x] += v;
        return;
    &amp;#125;;
    auto ask = [&amp;amp;](int x) &amp;#123;
        int res = 0;
        for (; x; x -= lowbit(x))
            res += bit[x];
        return res;
    &amp;#125;;
    std::function&amp;lt;void(int, int)&amp;gt; calc = [&amp;amp;](int l, int r) &amp;#123;
        if (l == r)
            return;
        int mid = (l + r) &amp;gt;&amp;gt; 1;
        calc(l, mid), calc(mid + 1, r);
        int j = l;
        for (int i = mid + 1; i &amp;lt;= r; ++i) &amp;#123;
            for (; j &amp;lt;= mid &amp;amp;&amp;amp; a[j].b &amp;lt; a[i].b; ++j)
                add(a[j].c, 1);
            a[i].res += ask(a[i].c);
        &amp;#125;
        for (int i = l; i &amp;lt; j; ++i)
            add(a[i].c, -1);
        std::inplace_merge(a.begin() + l, a.begin() + mid + 1, a.begin() + r + 1, [&amp;amp;](node x, node y) &amp;#123; return x.b &amp;lt; y.b; &amp;#125;);
        return;
    &amp;#125;;
    std::sort(a.begin() + 1, a.end(), [&amp;amp;](node x, node y) &amp;#123; return x.a &amp;lt; y.a; &amp;#125;);
    calc(1, n);
    for (int i = 1; i &amp;lt;= n; ++i)
        res -= a[i].res;
    res += (long long)n * (n - 1) * (n - 2) / 6;
    for (int k = 0; k &amp;lt; 3; ++k) &amp;#123;
        std::sort(a.begin() + 1, a.end(), [&amp;amp;](node x, node y) &amp;#123; return x.a &amp;lt; y.a; &amp;#125;);
        std::fill(bit.begin() + 1, bit.end(), 0);
        for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
            int t = ask(a[i].b);
            res -= (long long)t * (t - 1) / 2;
            add(a[i].b, 1);
            std::tie(a[i].a, a[i].b, a[i].c) = std::make_tuple(a[i].b, a[i].c, a[i].a);
        &amp;#125;
    &amp;#125;
    for (int i = 1; i &amp;lt;= n; ++i)
        res += (long long)a[i].res * (a[i].res - 1);
    std::cout &amp;lt;&amp;lt; res &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;c.-星白-by-ttpandas笛卡尔树-dsu-on-tree&#34;&gt;C. 星白 by TTpandaS（笛卡尔树 + dsu on tree）&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;/20250819/#星白-by-ttpandas笛卡尔树-dsu-on-tree&#34;&gt;link&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;c.-isn&#34;&gt;C. isn&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://hydro.ac/p/bzoj-P4361&#34; class=&#34;uri&#34;&gt;https://hydro.ac/p/bzoj-P4361&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;最后一个删去的一定是连接 &lt;code&gt;&amp;gt;&lt;/code&gt; 的数，可以 DP 还剩一个数没删时可能的序列。&lt;/p&gt;
令 &lt;span class=&#34;math inline&#34;&gt;\(f_{i,j,0/1}\)&lt;/span&gt; 表示最后一个元素为 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt;，序列长为 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt;，最后一个被删去的数（未）被确定的方案数。&lt;strong&gt;注意确定最后一个被删去的数要在转移过程中进行，而不是作为一个 DP 节点&lt;/strong&gt;，很容易发现后者是错的。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;优化的思路就不一样了。因为要乘上 &lt;span class=&#34;math inline&#34;&gt;\((n-j)!\)&lt;/span&gt;，所以 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; 的这一维是省不掉的&lt;/p&gt;
考虑不管最后一个被删掉的数，直接令 &lt;span class=&#34;math inline&#34;&gt;\(f_{i,j}\)&lt;/span&gt; 表示最后一个元素为 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt;，序列长为 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; 的方案数。有 &lt;span class=&#34;math inline&#34;&gt;\(f_{i,j}=\sum\limits_{a_k\le a_i}f_{k,j - 1}\)&lt;/span&gt;，可以 DS 优化。但这样会产生不合法的情况。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;考察什么样的序列合法，发现&lt;strong&gt;删去的最后一个数一定是非法的，也就是包含之的序列都是非法的；反之易得被合法序列包含的序列都非法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;明白了这一点过后就会知道长度为 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; 的合法序列系数都为 &lt;span class=&#34;math inline&#34;&gt;\((n-j)!\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;故容斥，令 &lt;span class=&#34;math inline&#34;&gt;\(g_i\)&lt;/span&gt; 表示序列长为 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 的方案数，&lt;span class=&#34;math inline&#34;&gt;\(h_i\)&lt;/span&gt; 表示序列长为 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 的合法方案数。从异或角度考虑，易得 &lt;span class=&#34;math inline&#34;&gt;\(h_i=g_i-\sum\limits_{j=i+1}h_j\times (j-i)!\times C_j^i\)&lt;/span&gt;。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int mod = 1e9 + 7;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
    std::freopen(&amp;quot;isn.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;isn.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n;
    std::cin &amp;gt;&amp;gt; n;
    std::vector&amp;lt;int&amp;gt; a(n + 1), l(1);
    std::vector&amp;lt;long long&amp;gt; fac(n + 1), inv(n + 1);
    fac[0] = inv[0] = 1ll;
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        std::cin &amp;gt;&amp;gt; a[i], l.push_back(a[i]);
        fac[i] = fac[i - 1] * i % mod;
    &amp;#125;
    auto qkp = [](long long x, int y) &amp;#123;
        auto res(1ll);
        for (; y; (x *= x) %= mod, y &amp;gt;&amp;gt;= 1)
            if (y &amp;amp; 1)
                (res *= x) %= mod;
        return res;
    &amp;#125;;
    inv[n] = qkp(fac[n], mod - 2);
    for (int i = n - 1; i; --i)
        inv[i] = inv[i + 1] * (i + 1) % mod;
    auto C = [&amp;amp;](int n, int m) &amp;#123;
        return fac[n] * inv[m] % mod * inv[n - m] % mod;
    &amp;#125;;
    std::sort(l.begin(), l.end());
    l.erase(std::unique(l.begin(), l.end()), l.end());
    for (int i = 0; i &amp;lt;= n; ++i)
        a[i] = std::lower_bound(l.begin(), l.end(), a[i]) - l.begin() + 1;
    int m = (int)l.size();
    std::vector&amp;lt;std::vector&amp;lt;long long&amp;gt; &amp;gt; bit(n + 1, std::vector&amp;lt;long long&amp;gt; (m + 1));
    auto lowbit = [](int x) &amp;#123;
        return x &amp;amp; -x;
    &amp;#125;;
    auto add = [&amp;amp;](int id, int x, long long v) &amp;#123;
        for (; x &amp;lt;= m; x += lowbit(x))
            (bit[id][x] += v) %= mod;
        return;
    &amp;#125;;
    auto ask = [&amp;amp;](int id, int x) &amp;#123;
        auto res(0ll);
        for (; x; x -= lowbit(x))
            (res += bit[id][x]) %= mod;
        return res;
    &amp;#125;;
    std::vector&amp;lt;long long&amp;gt; g(n + 1), h(n + 1);
    std::vector&amp;lt;std::vector&amp;lt;long long&amp;gt; &amp;gt; f(n + 1, std::vector&amp;lt;long long&amp;gt; (n + 1));
    add(0, a[0], 1ll), f[0][0] = 1ll;
    for (int i = 1; i &amp;lt;= n; ++i)
        for (int j = n; j; --j) &amp;#123;
            f[i][j] = ask(j - 1, a[i]);
            add(j, a[i], f[i][j]);
            (g[j] += f[i][j] * fac[n - j]) %= mod;
        &amp;#125;
    auto res(0ll);
    for (int i = n; i; --i) &amp;#123;
        h[i] = g[i];
        for (int j = i + 1; j &amp;lt;= n; ++j)
            (h[i] += mod - h[j] * fac[j - i] % mod * C(j, i) % mod) %= mod;
        (res += h[i]) %= mod;
    &amp;#125;
    std::cout &amp;lt;&amp;lt; res &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;d.-thepowers&#34;&gt;D. ThePowers&lt;/h3&gt;
&lt;p&gt;TopCoder - 12185，原题交不了故不放链接了&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.becoder.com.cn/contest/6522/problem/4&#34; class=&#34;uri&#34;&gt;https://www.becoder.com.cn/contest/6522/problem/4&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定 &lt;span class=&#34;math inline&#34;&gt;\(A,B\)&lt;/span&gt;，对于所有 &lt;span class=&#34;math inline&#34;&gt;\(X\le A,Y\le B\)&lt;/span&gt;，求 &lt;span class=&#34;math inline&#34;&gt;\(X^Y\)&lt;/span&gt; 的可能取值数量。&lt;span class=&#34;math inline&#34;&gt;\(A,B\le10^9\)&lt;/span&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;考虑什么时候算重。发现当且仅当 &lt;span class=&#34;math inline&#34;&gt;\(x^a=y^b\)&lt;/span&gt;，此时记 &lt;span class=&#34;math inline&#34;&gt;\(a&amp;#39;=a\div\gcd(a,b),b&amp;#39;=b\div \gcd(a,b)\)&lt;/span&gt;，那么 &lt;span class=&#34;math inline&#34;&gt;\(t=\sqrt[a&amp;#39;]x=\sqrt[b&amp;#39;]y\)&lt;/span&gt; 为整（写成质因数乘积是易证的），则 &lt;span class=&#34;math inline&#34;&gt;\(x=t^b,y=t^a\)&lt;/span&gt;，是同一个数的不同次幂&lt;/li&gt;
&lt;li&gt;&lt;p&gt;故把 &lt;span class=&#34;math inline&#34;&gt;\(A\)&lt;/span&gt; 内所有数分组，记 &lt;span class=&#34;math inline&#34;&gt;\(S_x\)&lt;/span&gt; 表示所有 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 的次幂，其中 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 不是其他数的次幂&lt;/p&gt;
发现一个对于 &lt;span class=&#34;math inline&#34;&gt;\(&amp;gt;\sqrt A\)&lt;/span&gt; 的数 &lt;span class=&#34;math inline&#34;&gt;\(y\)&lt;/span&gt;，只有可能属于 &lt;span class=&#34;math inline&#34;&gt;\(S_y\)&lt;/span&gt;，或一个 &lt;span class=&#34;math inline&#34;&gt;\(x\le \sqrt A\)&lt;/span&gt; 的 &lt;span class=&#34;math inline&#34;&gt;\(S_x\)&lt;/span&gt;。每组最多有 &lt;span class=&#34;math inline&#34;&gt;\(30\)&lt;/span&gt; 个，故扫一遍 &lt;span class=&#34;math inline&#34;&gt;\(\le\sqrt A\)&lt;/span&gt; 的数即可完成分组。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;这样就只用考虑同组内的计数。即对于 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 和 &lt;span class=&#34;math inline&#34;&gt;\(p\le |S_x|,y\le B\)&lt;/span&gt;，&lt;span class=&#34;math inline&#34;&gt;\(x^{py}\)&lt;/span&gt; 有多少种取值，也即 &lt;span class=&#34;math inline&#34;&gt;\(py\)&lt;/span&gt; 有多少种取值&lt;/p&gt;
发现因为值域是连续的，对于一个 &lt;span class=&#34;math inline&#34;&gt;\(p\)&lt;/span&gt;，只要 &lt;span class=&#34;math inline&#34;&gt;\(pB\)&lt;/span&gt; 范围内某个数是 &lt;span class=&#34;math inline&#34;&gt;\(p\)&lt;/span&gt; 的倍数就可以取到，枚举 &lt;span class=&#34;math inline&#34;&gt;\([(p-1)B+1,pB]\)&lt;/span&gt;，对于每个 &lt;span class=&#34;math inline&#34;&gt;\(p\)&lt;/span&gt; 容斥，就需要计算 &lt;span class=&#34;math inline&#34;&gt;\(p\sim |S_x|\)&lt;/span&gt; 的每个子集，复杂度会爆炸。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;对于 &lt;span class=&#34;math inline&#34;&gt;\(x,y\in[p,|S_x|]\)&lt;/span&gt;，如果 &lt;span class=&#34;math inline&#34;&gt;\(y\)&lt;/span&gt; 是 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 的倍数，就可以 skip，只在剩下的元素里枚举子集，可以代码验证一下 &lt;span class=&#34;math inline&#34;&gt;\(30\)&lt;/span&gt; 以内最多剩下 &lt;span class=&#34;math inline&#34;&gt;\(15\)&lt;/span&gt; 个数，可以接受，注意子集信息类似高维前缀和地 &lt;span class=&#34;math inline&#34;&gt;\(O(1)\)&lt;/span&gt; 求就行了&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
    std::freopen(&amp;quot;power.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;power.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    long long A, B, mx = 1ll;
    std::cin &amp;gt;&amp;gt; A &amp;gt;&amp;gt; B;
    if (A == 1) &amp;#123;
        std::cout &amp;lt;&amp;lt; 1 &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
        return 0;
    &amp;#125;
    int cnt = 1;
    long long res = 1ll;
    for (; (mx + 1) * (mx + 1) &amp;lt;= A; ++mx);
    std::vector&amp;lt;int&amp;gt; tag(mx + 1);
    for (int i = 2; i &amp;lt;= mx; ++i)
        if (!tag[i]) &amp;#123;
            int siz = 1;
            for (long long j = i; j &amp;lt;= A; j *= i, ++siz)
                if (j &amp;lt;= mx)
                    tag[j] = 1;
            cnt += --siz;
            for (int j = 1; j &amp;lt;= siz; ++j) &amp;#123;
                std::vector&amp;lt;int&amp;gt; p(&amp;#123; j &amp;#125;);
                for (int k = j + 1; k &amp;lt;= siz; ++k) &amp;#123;
                    bool flag = 1;
                    for (auto l : p)
                        if (k % l == 0) &amp;#123;
                            flag = 0;
                            break;
                        &amp;#125;
                    if (flag)
                        p.push_back(k);
                &amp;#125;
                int m = (int)p.size(), s = 1 &amp;lt;&amp;lt; m;
                std::vector&amp;lt;long long&amp;gt; mul(s);
                mul[0] = 1ll;
                auto lcm = [&amp;amp;](long long x, long long y) &amp;#123;
                    return x / std::__gcd(x, y) * y;
                &amp;#125;;
                for (int k = 1; k &amp;lt; s; ++k) &amp;#123;
                    mul[k] = lcm(p[std::__lg(k ^ ((k - 1) &amp;amp; k))], mul[(k - 1) &amp;amp; k]);
                    if (__builtin_popcount(k) &amp;amp; 1)
                        res += j * B / mul[k] - (j - 1) * B / mul[k];
                    else
                        res -= j * B / mul[k] - (j - 1) * B / mul[k];
                &amp;#125;
            &amp;#125;
        &amp;#125;
    res += (A - cnt) * B;
    std::cout &amp;lt;&amp;lt; res &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;p&gt;搜索做法本质上是一样的，就不赘述了&lt;/p&gt;
 ]]></description>
        </item>
    </channel>
</rss>
