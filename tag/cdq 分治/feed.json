{
    "version": "https://jsonfeed.org/version/1",
    "title": "null • All posts by \"cdq 分治\" tag",
    "description": "",
    "home_page_url": "https://xsc062.netlify.app",
    "items": [
        {
            "id": "https://xsc062.netlify.app/20251029/",
            "url": "https://xsc062.netlify.app/20251029/",
            "title": "CDQ 小记",
            "date_published": "2025-10-29T07:36:06.000Z",
            "content_html": "<p>日常不理解算法本质</p>\n<span id=\"more\"></span>\n<hr />\n<p>周末给 afewdgre 讲题，偶遇简单时间轴问题，拼尽全力勉强战胜</p>\n<h2 id=\"何为时间轴\">何为时间轴</h2>\n<ul>\n<li><p>特点：单向。</p>\n<p>前面的修改会影响后面的查询；反过来，后面的修改不会影响前面的查询。</p></li>\n<li><p>在大部分 DS 题目中，顺序操作是满足这个条件的。考虑不存在明显操作时间轴的问题，通常处理方式是扫描线：即用坐标轴当时间轴，这样做的前提条件也是『前面的修改影响后面的查询，但后面的修改不影响前面的查询』。这里拿给 afewdgre 讲的矩形面积并举例。</p>\n<p>矩形面积并中，把一段 <span class=\"math inline\">\\(x\\)</span> 坐标上，每个 <span class=\"math inline\">\\(y\\)</span> 上矩形存在的状态转化成『某个时刻，一段 <span class=\"math inline\">\\(y\\)</span> 是否被覆盖』，矩形的增删则用差分的方式维护。</p></li>\n</ul>\n<hr />\n<h2 id=\"cdq-分治\">CDQ 分治</h2>\n<ul>\n<li><p>在需求时间轴的需求上，额外要求：</p>\n<p>修改之间无依赖，或者说，<strong>单次修改对询问的影响是可求的。</strong></p></li>\n<li><p>这样就可以分治。大部分分治的基本目标都是，使相同的计算不用被多次进行。</p></li>\n<li><p>每层 CDQ 会统计每个 <span class=\"math inline\">\\([l,mid]\\)</span> 的修改对 <span class=\"math inline\">\\([mid+1,r]\\)</span> 询问的影响。</p></li>\n</ul>\n<p>好像讲完了？</p>\n",
            "tags": [
                "CDQ 分治"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20250820/",
            "url": "https://xsc062.netlify.app/20250820/",
            "title": "杂题",
            "date_published": "2025-08-20T12:26:44.000Z",
            "content_html": "<p>困难</p>\n<span id=\"more\"></span>\n<hr />\n<h3 id=\"b.-beauty拆贡献\">B. beauty（拆贡献）</h3>\n<p><a href=\"https://www.becoder.com.cn/contest/6513/problem/2\" class=\"uri\">https://www.becoder.com.cn/contest/6513/problem/2</a></p>\n<blockquote>\n<p>给定 <span class=\"math inline\">\\(n,V\\)</span>，求出对于所有长度为 <span class=\"math inline\">\\(n\\)</span>，值域为 <span class=\"math inline\">\\([1,V]\\)</span> 的序列 <span class=\"math inline\">\\(a_{1\\sim n}\\)</span>，<span class=\"math inline\">\\(\\sum_{i=1}^n |a_i-a_{n-i+1}|\\)</span> 的和。</p>\n<p><span class=\"math inline\">\\(n,V\\le 5000\\)</span>。</p>\n</blockquote>\n<ul>\n<li>容易想到算贡献，会有一个 <span class=\"math inline\">\\(O(n^2V)\\)</span> 的做法。但是想 <span class=\"math inline\">\\(O(nV)\\)</span> 做是很抽象的，和 <span class=\"math inline\">\\(O(n^2V)\\)</span> 的思路已经很不一样了</li>\n<li>经典 trick，<span class=\"math inline\">\\(a_{i+n/2}-a_i=\\sum\\limits_{x=0}^{+\\infty} [a_i\\le x&lt;a_{i+n/2}]\\)</span> 拆贡献 。故要算 <span class=\"math inline\">\\(a_{i}-a_{i+n/2}\\)</span>，只需要对于每个 <span class=\"math inline\">\\(x\\in[a_i,a_{i+n/2})\\)</span> 计算贡献。</li>\n<li>枚举 <span class=\"math inline\">\\(x\\in [1,V)\\)</span>，再枚举最大的 <span class=\"math inline\">\\(t\\)</span>，满足 <span class=\"math inline\">\\(a_t\\ge x\\)</span>。那么有 <span class=\"math inline\">\\(t\\)</span> 个 <span class=\"math inline\">\\(a_i\\le x\\)</span>，同时有 <span class=\"math inline\">\\(n-t\\)</span> 个 <span class=\"math inline\">\\(a_i&gt;x\\)</span>；满足 <span class=\"math inline\">\\(i\\le n/2\\)</span> 的 <span class=\"math inline\">\\(a_{i},a_{i+n/2}\\)</span> 对数应该是 <span class=\"math inline\">\\(\\min(t,n-t)\\)</span>。故对于一个确定的序列，<span class=\"math inline\">\\(x\\)</span> 共有 <span class=\"math inline\">\\(\\min(t,n-t)\\)</span> 的贡献。</li>\n<li>考虑计数满足 <span class=\"math inline\">\\(a_t\\le x\\)</span> 的 <span class=\"math inline\">\\(a\\)</span>，这要求第 <span class=\"math inline\">\\(t\\)</span> 大的数 <span class=\"math inline\">\\(\\le x\\)</span> 而第 <span class=\"math inline\">\\(t+1\\)</span> 大的数 <span class=\"math inline\">\\(&gt;x\\)</span>，也即在 <span class=\"math inline\">\\([1,x]\\)</span> 里找 <span class=\"math inline\">\\(t\\)</span> 个数再在 <span class=\"math inline\">\\((x,V]\\)</span> 里找 <span class=\"math inline\">\\(n-t\\)</span> 个数，注意还要再乘上这两种数拼起来的方案数。</li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 998244353;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n    std::freopen(&quot;beauty.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;beauty.out&quot;, &quot;w&quot;, stdout);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int T;\n    std::vector&lt;long long&gt; fac(5001), inv(5001);\n    std::vector&lt;std::vector&lt;long long&gt; &gt; pw(5001, std::vector&lt;long long&gt; (5001));\n    fac[0] = inv[0] = 1ll;\n    for (int i = 1; i &lt;= 5000; ++i) &#123;\n        fac[i] = fac[i - 1] * i % mod;\n        pw[i][0] = 1ll;\n        for (int j = 1; j &lt;= 5000; ++j)\n            pw[i][j] = pw[i][j - 1] * i % mod;\n    &#125;\n    auto qkp = [](long long x, int y) &#123;\n        auto res(1ll);\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    inv[5000] = qkp(fac[5000], mod - 2);\n    for (int i = 4999; i; --i)\n        inv[i] = inv[i + 1] * (i + 1) % mod;\n    auto C = [&amp;](int n, int m) &#123;\n        return fac[n] * inv[m] % mod * inv[n - m] % mod;\n    &#125;;\n    for (std::cin &gt;&gt; T; T--; ) &#123;\n        int n, V;\n        std::cin &gt;&gt; n &gt;&gt; V;\n        auto res(0ll);\n        for (int x = 1; x &lt; V; ++x)\n            for (int t = 1; t &lt; n; ++t) &#123;\n                int k = std::min(t, n - t);\n                (res += k * pw[x][t] % mod * pw[V - x][n - t] % mod * C(n, t) % mod) %= mod;\n            &#125;\n        std::cout &lt;&lt; res * 2 % mod &lt;&lt; &#39;\\n&#39;;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"c.-drink-bar容斥-偏序\">C. Drink Bar（容斥 + 偏序）</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/AT_snuke21_j\" class=\"uri\">https://www.luogu.com.cn/problem/AT_snuke21_j</a></p>\n<ul>\n<li>三个属性都是排列，可以推理出只要两个三元组中，作出贡献的元素不完全相同，两个三元组就不同。讨论作出贡献的元素数量。</li>\n<li>只有一个元素作出贡献，答案为 <span class=\"math inline\">\\(n\\)</span>。</li>\n<li>有两个元素作出贡献，任选的话答案为 <span class=\"math inline\">\\(C_n^2\\)</span>，要减去一个元素严格优于另一个元素的情况，三维偏序即可。</li>\n<li><p>有三个元素作出贡献，是个有点复杂的容斥，不妨设三元组为 <span class=\"math inline\">\\((i,j,k)\\)</span>，其中贡献次数最多的为 <span class=\"math inline\">\\(i\\)</span></p>\n<ol type=\"1\">\n<li><span class=\"math inline\">\\(i\\)</span> 贡献了 <span class=\"math inline\">\\(\\ge 1\\)</span> 次，方案数为 <span class=\"math inline\">\\(C_n^3\\)</span></li>\n<li><span class=\"math inline\">\\(i\\)</span> 贡献了 <span class=\"math inline\">\\(\\ge 2\\)</span> 次，枚举作出两次贡献的属性，以 <span class=\"math inline\">\\(a,b\\)</span> 为例，那么有 <span class=\"math inline\">\\(a_j,a_k&lt;a_i\\)</span>，以及 <span class=\"math inline\">\\(b_j,b_k&lt;b_i\\)</span>，二维偏序即可</li>\n<li><span class=\"math inline\">\\(i\\)</span> 贡献了 <span class=\"math inline\">\\(\\ge 3\\)</span> 次，依然是三维偏序，可以用『两个元素做出贡献』中 cdq 得到的值算出答案。记得乘 2，因为被多减了 2 次。</li>\n</ol></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    struct node &#123; int a, b, c, res; &#125;;\n    std::vector&lt;node&gt; a(n + 1);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; a[i].a &gt;&gt; a[i].b &gt;&gt; a[i].c;\n        a[i].res = 0;\n    &#125;\n    long long res = n;\n    res += (long long)n * (n - 1) / 2;\n    std::vector&lt;int&gt; bit(n + 1);\n    auto lowbit = [](int x) &#123;\n        return x &amp; -x;\n    &#125;;\n    auto add = [&amp;](int x, int v) &#123;\n        for (; x &lt;= n; x += lowbit(x))\n            bit[x] += v;\n        return;\n    &#125;;\n    auto ask = [&amp;](int x) &#123;\n        int res = 0;\n        for (; x; x -= lowbit(x))\n            res += bit[x];\n        return res;\n    &#125;;\n    std::function&lt;void(int, int)&gt; calc = [&amp;](int l, int r) &#123;\n        if (l == r)\n            return;\n        int mid = (l + r) &gt;&gt; 1;\n        calc(l, mid), calc(mid + 1, r);\n        int j = l;\n        for (int i = mid + 1; i &lt;= r; ++i) &#123;\n            for (; j &lt;= mid &amp;&amp; a[j].b &lt; a[i].b; ++j)\n                add(a[j].c, 1);\n            a[i].res += ask(a[i].c);\n        &#125;\n        for (int i = l; i &lt; j; ++i)\n            add(a[i].c, -1);\n        std::inplace_merge(a.begin() + l, a.begin() + mid + 1, a.begin() + r + 1, [&amp;](node x, node y) &#123; return x.b &lt; y.b; &#125;);\n        return;\n    &#125;;\n    std::sort(a.begin() + 1, a.end(), [&amp;](node x, node y) &#123; return x.a &lt; y.a; &#125;);\n    calc(1, n);\n    for (int i = 1; i &lt;= n; ++i)\n        res -= a[i].res;\n    res += (long long)n * (n - 1) * (n - 2) / 6;\n    for (int k = 0; k &lt; 3; ++k) &#123;\n        std::sort(a.begin() + 1, a.end(), [&amp;](node x, node y) &#123; return x.a &lt; y.a; &#125;);\n        std::fill(bit.begin() + 1, bit.end(), 0);\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            int t = ask(a[i].b);\n            res -= (long long)t * (t - 1) / 2;\n            add(a[i].b, 1);\n            std::tie(a[i].a, a[i].b, a[i].c) = std::make_tuple(a[i].b, a[i].c, a[i].a);\n        &#125;\n    &#125;\n    for (int i = 1; i &lt;= n; ++i)\n        res += (long long)a[i].res * (a[i].res - 1);\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"c.-星白-by-ttpandas笛卡尔树-dsu-on-tree\">C. 星白 by TTpandaS（笛卡尔树 + dsu on tree）</h3>\n<p><a href=\"/20250819/#星白-by-ttpandas笛卡尔树-dsu-on-tree\">link</a></p>\n<hr />\n<h3 id=\"c.-isn\">C. isn</h3>\n<p><a href=\"https://hydro.ac/p/bzoj-P4361\" class=\"uri\">https://hydro.ac/p/bzoj-P4361</a></p>\n<ul>\n<li><p>最后一个删去的一定是连接 <code>&gt;</code> 的数，可以 DP 还剩一个数没删时可能的序列。</p>\n令 <span class=\"math inline\">\\(f_{i,j,0/1}\\)</span> 表示最后一个元素为 <span class=\"math inline\">\\(i\\)</span>，序列长为 <span class=\"math inline\">\\(j\\)</span>，最后一个被删去的数（未）被确定的方案数。<strong>注意确定最后一个被删去的数要在转移过程中进行，而不是作为一个 DP 节点</strong>，很容易发现后者是错的。</li>\n<li><p>优化的思路就不一样了。因为要乘上 <span class=\"math inline\">\\((n-j)!\\)</span>，所以 <span class=\"math inline\">\\(j\\)</span> 的这一维是省不掉的</p>\n考虑不管最后一个被删掉的数，直接令 <span class=\"math inline\">\\(f_{i,j}\\)</span> 表示最后一个元素为 <span class=\"math inline\">\\(i\\)</span>，序列长为 <span class=\"math inline\">\\(j\\)</span> 的方案数。有 <span class=\"math inline\">\\(f_{i,j}=\\sum\\limits_{a_k\\le a_i}f_{k,j - 1}\\)</span>，可以 DS 优化。但这样会产生不合法的情况。</li>\n<li><p>考察什么样的序列合法，发现<strong>删去的最后一个数一定是非法的，也就是包含之的序列都是非法的；反之易得被合法序列包含的序列都非法</strong></p>\n<p>明白了这一点过后就会知道长度为 <span class=\"math inline\">\\(j\\)</span> 的合法序列系数都为 <span class=\"math inline\">\\((n-j)!\\)</span></p>\n<p>故容斥，令 <span class=\"math inline\">\\(g_i\\)</span> 表示序列长为 <span class=\"math inline\">\\(i\\)</span> 的方案数，<span class=\"math inline\">\\(h_i\\)</span> 表示序列长为 <span class=\"math inline\">\\(i\\)</span> 的合法方案数。从异或角度考虑，易得 <span class=\"math inline\">\\(h_i=g_i-\\sum\\limits_{j=i+1}h_j\\times (j-i)!\\times C_j^i\\)</span>。</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 1e9 + 7;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n    std::freopen(&quot;isn.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;isn.out&quot;, &quot;w&quot;, stdout);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;int&gt; a(n + 1), l(1);\n    std::vector&lt;long long&gt; fac(n + 1), inv(n + 1);\n    fac[0] = inv[0] = 1ll;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; a[i], l.push_back(a[i]);\n        fac[i] = fac[i - 1] * i % mod;\n    &#125;\n    auto qkp = [](long long x, int y) &#123;\n        auto res(1ll);\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    inv[n] = qkp(fac[n], mod - 2);\n    for (int i = n - 1; i; --i)\n        inv[i] = inv[i + 1] * (i + 1) % mod;\n    auto C = [&amp;](int n, int m) &#123;\n        return fac[n] * inv[m] % mod * inv[n - m] % mod;\n    &#125;;\n    std::sort(l.begin(), l.end());\n    l.erase(std::unique(l.begin(), l.end()), l.end());\n    for (int i = 0; i &lt;= n; ++i)\n        a[i] = std::lower_bound(l.begin(), l.end(), a[i]) - l.begin() + 1;\n    int m = (int)l.size();\n    std::vector&lt;std::vector&lt;long long&gt; &gt; bit(n + 1, std::vector&lt;long long&gt; (m + 1));\n    auto lowbit = [](int x) &#123;\n        return x &amp; -x;\n    &#125;;\n    auto add = [&amp;](int id, int x, long long v) &#123;\n        for (; x &lt;= m; x += lowbit(x))\n            (bit[id][x] += v) %= mod;\n        return;\n    &#125;;\n    auto ask = [&amp;](int id, int x) &#123;\n        auto res(0ll);\n        for (; x; x -= lowbit(x))\n            (res += bit[id][x]) %= mod;\n        return res;\n    &#125;;\n    std::vector&lt;long long&gt; g(n + 1), h(n + 1);\n    std::vector&lt;std::vector&lt;long long&gt; &gt; f(n + 1, std::vector&lt;long long&gt; (n + 1));\n    add(0, a[0], 1ll), f[0][0] = 1ll;\n    for (int i = 1; i &lt;= n; ++i)\n        for (int j = n; j; --j) &#123;\n            f[i][j] = ask(j - 1, a[i]);\n            add(j, a[i], f[i][j]);\n            (g[j] += f[i][j] * fac[n - j]) %= mod;\n        &#125;\n    auto res(0ll);\n    for (int i = n; i; --i) &#123;\n        h[i] = g[i];\n        for (int j = i + 1; j &lt;= n; ++j)\n            (h[i] += mod - h[j] * fac[j - i] % mod * C(j, i) % mod) %= mod;\n        (res += h[i]) %= mod;\n    &#125;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"d.-thepowers\">D. ThePowers</h3>\n<p>TopCoder - 12185，原题交不了故不放链接了</p>\n<p><a href=\"https://www.becoder.com.cn/contest/6522/problem/4\" class=\"uri\">https://www.becoder.com.cn/contest/6522/problem/4</a></p>\n<blockquote>\n<p>给定 <span class=\"math inline\">\\(A,B\\)</span>，对于所有 <span class=\"math inline\">\\(X\\le A,Y\\le B\\)</span>，求 <span class=\"math inline\">\\(X^Y\\)</span> 的可能取值数量。<span class=\"math inline\">\\(A,B\\le10^9\\)</span>。</p>\n</blockquote>\n<ul>\n<li>考虑什么时候算重。发现当且仅当 <span class=\"math inline\">\\(x^a=y^b\\)</span>，此时记 <span class=\"math inline\">\\(a&#39;=a\\div\\gcd(a,b),b&#39;=b\\div \\gcd(a,b)\\)</span>，那么 <span class=\"math inline\">\\(t=\\sqrt[a&#39;]x=\\sqrt[b&#39;]y\\)</span> 为整（写成质因数乘积是易证的），则 <span class=\"math inline\">\\(x=t^b,y=t^a\\)</span>，是同一个数的不同次幂</li>\n<li><p>故把 <span class=\"math inline\">\\(A\\)</span> 内所有数分组，记 <span class=\"math inline\">\\(S_x\\)</span> 表示所有 <span class=\"math inline\">\\(x\\)</span> 的次幂，其中 <span class=\"math inline\">\\(x\\)</span> 不是其他数的次幂</p>\n发现一个对于 <span class=\"math inline\">\\(&gt;\\sqrt A\\)</span> 的数 <span class=\"math inline\">\\(y\\)</span>，只有可能属于 <span class=\"math inline\">\\(S_y\\)</span>，或一个 <span class=\"math inline\">\\(x\\le \\sqrt A\\)</span> 的 <span class=\"math inline\">\\(S_x\\)</span>。每组最多有 <span class=\"math inline\">\\(30\\)</span> 个，故扫一遍 <span class=\"math inline\">\\(\\le\\sqrt A\\)</span> 的数即可完成分组。</li>\n<li><p>这样就只用考虑同组内的计数。即对于 <span class=\"math inline\">\\(x\\)</span> 和 <span class=\"math inline\">\\(p\\le |S_x|,y\\le B\\)</span>，<span class=\"math inline\">\\(x^{py}\\)</span> 有多少种取值，也即 <span class=\"math inline\">\\(py\\)</span> 有多少种取值</p>\n发现因为值域是连续的，对于一个 <span class=\"math inline\">\\(p\\)</span>，只要 <span class=\"math inline\">\\(pB\\)</span> 范围内某个数是 <span class=\"math inline\">\\(p\\)</span> 的倍数就可以取到，枚举 <span class=\"math inline\">\\([(p-1)B+1,pB]\\)</span>，对于每个 <span class=\"math inline\">\\(p\\)</span> 容斥，就需要计算 <span class=\"math inline\">\\(p\\sim |S_x|\\)</span> 的每个子集，复杂度会爆炸。</li>\n<li><p>对于 <span class=\"math inline\">\\(x,y\\in[p,|S_x|]\\)</span>，如果 <span class=\"math inline\">\\(y\\)</span> 是 <span class=\"math inline\">\\(x\\)</span> 的倍数，就可以 skip，只在剩下的元素里枚举子集，可以代码验证一下 <span class=\"math inline\">\\(30\\)</span> 以内最多剩下 <span class=\"math inline\">\\(15\\)</span> 个数，可以接受，注意子集信息类似高维前缀和地 <span class=\"math inline\">\\(O(1)\\)</span> 求就行了</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n    std::freopen(&quot;power.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;power.out&quot;, &quot;w&quot;, stdout);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    long long A, B, mx = 1ll;\n    std::cin &gt;&gt; A &gt;&gt; B;\n    if (A == 1) &#123;\n        std::cout &lt;&lt; 1 &lt;&lt; &#39;\\n&#39;;\n        return 0;\n    &#125;\n    int cnt = 1;\n    long long res = 1ll;\n    for (; (mx + 1) * (mx + 1) &lt;= A; ++mx);\n    std::vector&lt;int&gt; tag(mx + 1);\n    for (int i = 2; i &lt;= mx; ++i)\n        if (!tag[i]) &#123;\n            int siz = 1;\n            for (long long j = i; j &lt;= A; j *= i, ++siz)\n                if (j &lt;= mx)\n                    tag[j] = 1;\n            cnt += --siz;\n            for (int j = 1; j &lt;= siz; ++j) &#123;\n                std::vector&lt;int&gt; p(&#123; j &#125;);\n                for (int k = j + 1; k &lt;= siz; ++k) &#123;\n                    bool flag = 1;\n                    for (auto l : p)\n                        if (k % l == 0) &#123;\n                            flag = 0;\n                            break;\n                        &#125;\n                    if (flag)\n                        p.push_back(k);\n                &#125;\n                int m = (int)p.size(), s = 1 &lt;&lt; m;\n                std::vector&lt;long long&gt; mul(s);\n                mul[0] = 1ll;\n                auto lcm = [&amp;](long long x, long long y) &#123;\n                    return x / std::__gcd(x, y) * y;\n                &#125;;\n                for (int k = 1; k &lt; s; ++k) &#123;\n                    mul[k] = lcm(p[std::__lg(k ^ ((k - 1) &amp; k))], mul[(k - 1) &amp; k]);\n                    if (__builtin_popcount(k) &amp; 1)\n                        res += j * B / mul[k] - (j - 1) * B / mul[k];\n                    else\n                        res -= j * B / mul[k] - (j - 1) * B / mul[k];\n                &#125;\n            &#125;\n        &#125;\n    res += (A - cnt) * B;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<p>搜索做法本质上是一样的，就不赘述了</p>\n",
            "tags": [
                "DP",
                "计数",
                "CDQ 分治"
            ]
        }
    ]
}