{
    "version": "https://jsonfeed.org/version/1",
    "title": "null • All posts by \"区间 dp\" tag",
    "description": "",
    "home_page_url": "https://xsc062.netlify.app",
    "items": [
        {
            "id": "https://xsc062.netlify.app/20231004-1/",
            "url": "https://xsc062.netlify.app/20231004-1/",
            "title": "杂题",
            "date_published": "2023-10-04T08:41:40.000Z",
            "content_html": "<p><a href=\"http://222.180.160.110:61235/contest/4272\">牛客普及</a>。</p>\n<span id=\"more\"></span>\n<hr />\n<h3 id=\"a.-学习求余\">A. 学习求余</h3>\n<p><a href=\"http://222.180.160.110:61235/contest/4272/problem/1\" class=\"uri\">http://222.180.160.110:61235/contest/4272/problem/1</a></p>\n<p>今天我们来学习求余！这种题放普及 T1 不合适吧！</p>\n<p>令 <span class=\"math inline\">\\(k=\\left\\lfloor \\dfrac n2 \\right\\rfloor + 1\\)</span>，直接输出 <span class=\"math inline\">\\(k\\times (n - k)\\)</span> 即可。</p>\n<details>\n<p><summary>我是不是证复杂了…</summary></p>\n<p>我们可以简单地发现一个道理，对于任意 <span class=\"math inline\">\\(\\dfrac n2&lt;x\\le n\\)</span>，<span class=\"math inline\">\\(n\\bmod x\\)</span> 的值是 <span class=\"math inline\">\\(n - x\\)</span>；</p>\n<p>根据基本不等式（<del>wjs 直接感动得哭出声来</del>）或小学知识「和不变，差小积大」，我们可以知道当 <span class=\"math inline\">\\(x=\\left\\lfloor \\dfrac n2 \\right\\rfloor + 1\\)</span> 时，<span class=\"math inline\">\\(x\\times (n-x)\\)</span> 取最大值。</p>\n<p>故有：当 <span class=\"math inline\">\\(x=\\left\\lfloor \\dfrac n2 \\right\\rfloor + 1\\)</span> 时，<span class=\"math inline\">\\(x\\times (n\\bmod x)\\)</span> 取最大值。</p>\n<p>而对于 <span class=\"math inline\">\\(y\\le \\dfrac n2\\)</span>，由余数小于除数得，<span class=\"math inline\">\\(n\\bmod y&lt;y\\le \\dfrac n2\\)</span>。由于 <span class=\"math inline\">\\(0&lt;y&lt;x=\\left\\lfloor \\dfrac n2 \\right\\rfloor + 1\\)</span> 且 <span class=\"math inline\">\\(0\\le n\\bmod y\\le \\left\\lfloor \\dfrac n2 \\right\\rfloor - 1\\le n - \\left\\lfloor \\dfrac n2 \\right\\rfloor - 1=n\\bmod x\\)</span>，由不等式的基本性质得 <span class=\"math inline\">\\(x\\times(n\\bmod x)&gt;y\\times (n\\bmod y)\\)</span>。</p>\n<p>综上，对于 <span class=\"math inline\">\\(1\\le x\\le n\\)</span>，当 <span class=\"math inline\">\\(x=\\left\\lfloor \\dfrac n2 \\right\\rfloor + 1\\)</span> 时，<span class=\"math inline\">\\(x\\times (n\\bmod x)\\)</span> 有最大值。</p>\n</details>\n<p>然后如果你要问我怎么发现这一点的呢，我当时没有思路，然后随手输出了 <span class=\"math inline\">\\(n=100\\)</span> 时 <span class=\"math inline\">\\(n\\bmod i\\)</span> 的所有值。然后发现 <span class=\"math inline\">\\(k=51\\)</span> 时余数是 <span class=\"math inline\">\\(49\\)</span>…… 然后就会了。</p>\n<details>\n<pre class=\"cpp\"><code>#define int long long\nnamespace XSC062 &#123;\nusing namespace fastIO;\nint n, k;\nint main() &#123;\n    read(n), k = n / 2 + 1;\n    print(k * (n % k));\n    return 0;\n&#125;\n&#125; // namespace XSC062\n#undef int</code></pre>\n<p><del>头一次在题解里贴这么短的代码</del></p>\n</details>\n<hr />\n<h3 id=\"b.-提取数字\">B. 提取数字</h3>\n<p><a href=\"http://222.180.160.110:61235/contest/4272/problem/2\" class=\"uri\">http://222.180.160.110:61235/contest/4272/problem/2</a></p>\n<p>我被这道题（疑似 T1）坑到了！交了三遍才过！这合理吗？</p>\n<p>首先要开 <code>long long</code>！然后注意，你的判定条件应为「当前是否已存储数」而非「当前存数变量是否为 0」！因为数据中会有单个 0 的情况出现！</p>\n<p>然后就没有了。</p>\n<details>\n<pre class=\"cpp\"><code>#define int long long\nnamespace XSC062 &#123;\nusing namespace fastIO;\nconst int maxn = 1e5 + 5;\nbool flag;\nchar s[maxn]; \nint n, ans, cnt;\nint main() &#123;\n    scanf(&quot;%*s %s&quot;, s + 1);\n    n = strlen(s + 1);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        if (s[i] &gt;= &#39;0&#39; &amp;&amp; s[i] &lt;= &#39;9&#39;)\n            cnt = cnt * 10 + s[i] - &#39;0&#39;, flag = 1;\n        else if (flag)\n            ans += (cnt + 5), cnt = 0, flag = 0;\n    &#125;\n    if (flag) ans += (cnt + 5);\n    print(ans, &#39;\\n&#39;);\n    return 0;\n&#125;\n&#125; // namespace XSC062\n#undef int</code></pre>\n</details>\n<hr />\n<h3 id=\"c.-武器选择\">C. 武器选择</h3>\n<p><a href=\"http://222.180.160.110:61235/contest/4272/problem/3\" class=\"uri\">http://222.180.160.110:61235/contest/4272/problem/3</a></p>\n<details>\n<p><summary>首先是我想了半个小时的狂拽酷炫吊炸天的法一：离线</summary></p>\n<p>我当时一边打一边怀疑现在的普及组是什么神仙，T3 考这么神奇的离线，难道是我落后于时代了？</p>\n<p>（之所以认为这是 T3 是因为括号那道题确实是正常 T4 风格）</p>\n<p>我们预处理出对于每一个可能获得武器 <span class=\"math inline\">\\(i\\)</span> 的位置，应该从哪个位置第一次捡到武器 <span class=\"math inline\">\\(i\\)</span>，由于这一段内的所有武器 <span class=\"math inline\">\\(i\\)</span> 都需要被拾取，我们将其作为区间 <span class=\"math inline\">\\([L_i, R_i]\\)</span> 来记录。</p>\n<p>那么询问可以转化为，在 <span class=\"math inline\">\\([l, r]\\)</span> 内 <strong>不同颜色</strong> <span class=\"math inline\">\\([L_i, R_i]\\)</span> 的数量。</p>\n<p>考虑将询问离线。将询问按左端点从大到小排序，信息区间 <span class=\"math inline\">\\([L_i, R_i]\\)</span> 也按左端点从大到小排序。</p>\n<p>对于每次询问 <span class=\"math inline\">\\(l, r\\)</span>，在树状数组中将被 <span class=\"math inline\">\\([l, n]\\)</span> 完全包含的所有 <span class=\"math inline\">\\([L_i, R_i]\\)</span>（其实就是 <span class=\"math inline\">\\(l\\le L_i\\)</span> 的所有 <span class=\"math inline\">\\(L_i\\)</span>）在右端点 <span class=\"math inline\">\\(R_i\\)</span> 处加一，我们就统计到了可以捡到武器的所有位置。</p>\n<p>怎么区分颜色呢？很简单，我们让每个颜色只被算一次。算哪一次呢？就算当前已加入的 <span class=\"math inline\">\\([L_i, R_i]\\)</span> 内，比选中概率最大的一次。</p>\n<p>我们树状数组统计的是 <span class=\"math inline\">\\([1, r]\\)</span> 内的值，所以我们要让概率最大的话，就要让 <span class=\"math inline\">\\(R_i\\)</span> 尽量的小。</p>\n<p>我们记录每个颜色当前合法 <span class=\"math inline\">\\([L_i, R_i]\\)</span> 的最小右端点 <span class=\"math inline\">\\(\\min_R\\)</span>。加入一个新的 <span class=\"math inline\">\\([L_i, R_i]\\)</span> 时，如果 <span class=\"math inline\">\\(R_i\\ge \\min_R\\)</span>，那么不会产生影响，跳过；否则，当 <span class=\"math inline\">\\(R_i&lt;\\min_R\\)</span> 时，我们就要先消除当前 <span class=\"math inline\">\\(\\min_R\\)</span> 的影响（即在树状数组中将该位置加上的 1 减去），再加上 <span class=\"math inline\">\\(R_i\\)</span> 的影响（即在树状数组中加上该位置的 1）。</p>\n<p>此时我们对 <span class=\"math inline\">\\([1, r]\\)</span> 的询问就是答案。</p>\n<p>复杂度 <span class=\"math inline\">\\(O(n\\log n + m\\log m + m\\log n)\\)</span>，其中 <span class=\"math inline\">\\(n\\log n\\)</span> 来自于对 <span class=\"math inline\">\\([L_i, R_i]\\)</span> 的排序，<span class=\"math inline\">\\(m\\log m\\)</span> 来自于对询问的排序，<span class=\"math inline\">\\(m\\log n\\)</span> 来自于离线树状数组。</p>\n</details>\n<p>接下来讲题解给的正解…… 这个是真的妙。</p>\n<p>考虑所有种类数，在 <span class=\"math inline\">\\(n\\)</span> 个数内满足条件的种类 <span class=\"math inline\">\\(x\\)</span> 最优条件下也不过 <span class=\"math inline\">\\(\\dfrac {x\\times (x+1)}2=n\\)</span>，所以满足条件武器的数量最多只有 <span class=\"math inline\">\\(\\sqrt n\\)</span> 级别。</p>\n<p>所以我们对所有合法种类做前缀和，每次询问检查所有合法种类是否在该区间内出现对应次数，然后统计答案。复杂度 <span class=\"math inline\">\\(O(m\\sqrt n + n\\sqrt n)\\)</span>。<span class=\"math inline\">\\(n\\sqrt n\\)</span> 是前面前缀和来的，<span class=\"math inline\">\\(m\\sqrt n\\)</span> 是暴力统计来的。</p>\n<p>但是根号可耻，所以我的法一更 NB！！！🤡🤡🤡</p>\n<details>\n<p><summary>狂拽酷炫吊炸天的法一代码</summary></p>\n<pre class=\"cpp\"><code>#define int long long\nnamespace XSC062 &#123;\nusing namespace fastIO;\nconst int maxn = 1e5 + 5;\nstruct _ &#123;\n    int l, r, k, i;\n    bool operator&lt; (const _ &amp;q) const &#123;\n        return l &lt; q.l;\n    &#125;\n&#125;;\nstruct __ &#123;\n    int l, r, nxt, x;\n    bool operator&lt; (const __ &amp;q) const &#123;\n        return l &lt; q.l;\n    &#125;\n&#125;;\n_ q[maxn];\n__ a[maxn];\nstd::map&lt;int, int&gt; t;\nstd::vector&lt;int&gt; u[maxn];\nint ans[maxn], now[maxn];\nint mnr[maxn], Bit[maxn];\nint n, m, tot, x, cnt, pos;\nint lowbit(int x) &#123; return x &amp; -x; &#125;\nvoid add(int x, int v) &#123;\n    for (int i = x; i &lt;= n; i += lowbit(i))\n        Bit[i] += v;\n    return;\n&#125;\nint ask(int x) &#123;\n    int res = 0;\n    for (int i = x; i; i -= lowbit(i))\n        res += Bit[i];\n    return res;\n&#125;\nint calc(int x, int k) &#123;\n    int res = 1;\n    for (int i = 1; i &lt;= k; ++i)\n        res *= x--;\n    for (int i = 1; i &lt;= k; ++i)\n        res /= i;\n    return res;\n&#125;\nint main() &#123;\n    read(n);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        read(x);\n        if (!t.count(x)) t[x] = ++tot;\n        int id = t[x];\n        u[id].push_back(i);\n        if ((int)u[id].size() &gt;= x) &#123;\n            a[++cnt].l = u[id][(int)u[id].size() - x];\n            a[cnt].r = i, a[now[id]].nxt = cnt;\n            a[cnt].x = x, mnr[x] = n + 1;\n            now[id] = cnt;\n        &#125;\n    &#125;\n    read(m);\n    for (int i = 1; i &lt;= m; ++i) &#123;\n        read(q[i].l), read(q[i].r);\n        read(q[i].k), q[i].i = i;\n    &#125;\n    std::sort(q + 1, q + m + 1);\n    std::sort(a + 1, a + cnt + 1);\n    pos = cnt;\n    for (int i = m; i; --i) &#123;\n        while (a[pos].l &gt;= q[i].l) &#123;\n            if (a[pos].r &lt; mnr[a[pos].x]) &#123;\n                if (mnr[a[pos].x] &lt;= n)\n                    add(mnr[a[pos].x], -1);\n                add(a[pos].r, 1);\n                mnr[a[pos].x] = a[pos].r;\n            &#125;\n            --pos;\n        &#125;\n        ans[q[i].i] = calc(ask(q[i].r), q[i].k);\n    &#125;\n    for (int i = 1; i &lt;= m; ++i)\n        print(ans[i], &#39;\\n&#39;);\n    return 0;\n&#125;\n&#125; // namespace XSC062\n#undef int</code></pre>\n<p>我甚至打完了就过了样例然后直接就 A 了，好久没有这么爽地过过这种大码量 <del>正确性还未知</del> 的题了。</p>\n</details>\n<p>而且我相信全场只有我一个 <del>小丑</del> 帅哥打离线，所以我是最强的！！！🤡🤡🤡</p>\n<details>\n<p><summary>绝对不如法一的法二代码</summary></p>\n<pre class=\"cpp\"><code>#define int long long\nnamespace XSC062 &#123;\nusing namespace fastIO;\nconst int maxm = 505;\nconst int maxn = 1e5 + 5;\nint a[maxn];\nint cnt[maxn];\nint sum[maxm][maxn];\nint n, tot, m, l, r, k, res;\nint calc(int x, int k) &#123;\n    int res = 1;\n    for (int i = 1; i &lt;= k; ++i)\n        res *= x--;\n    for (int i = 1; i &lt;= k; ++i)\n        res /= i;\n    return res;\n&#125;\nint main() &#123;\n    read(n);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        read(a[i]);\n        if (a[i] &lt;= n) ++cnt[a[i]];\n    &#125;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        if (cnt[i] &gt;= i) &#123;\n            sum[++tot][n + 1] = i;\n            for (int j = 1; j &lt;= n; ++j)\n                sum[tot][j] = sum[tot][j - 1] + (a[j] == i);\n        &#125;\n    &#125;\n    read(m);\n    while (m--) &#123;\n        read(l), read(r), read(k);\n        res = 0;\n        for (int i = 1; i &lt;= tot; ++i)\n            res += (sum[i][r] - sum[i][l - 1] &gt;= sum[i][n + 1]);\n        print(calc(res, k), &#39;\\n&#39;);\n    &#125;\n    return 0;\n&#125;\n&#125; // namespace XSC062\n#undef int</code></pre>\n</details>\n<hr />\n<h3 id=\"d.-括号序列\">D. 括号序列</h3>\n<p>http://222.180.160.110:61235/contest/4272/problem/4</p>\n<p>呃呃呃，这，有什么好讲的吗？做过原题的应该都会吧……</p>\n<p>反正就是个比较裸的区间 DP，转移的时候注意一下究竟哪些是同一对括号，哪些是相邻括号就好。</p>\n<p>复杂度 <span class=\"math inline\">\\(O(n^2)\\)</span>。</p>\n<details>\n<pre class=\"cpp\"><code>namespace XSC062 &#123;\nusing namespace fastIO;\nconst int maxn = 1e3 + 5;\nint n, res;\nchar s[maxn];\nstd::stack&lt;int&gt; t;\nint mat[maxn], c[5];\nint f[maxn][maxn][3][3];\nint max(int x, int y) &#123; return x &gt; y ? x : y; &#125;\nvoid upd(int &amp;x, int y) &#123; x = max(x, y); return; &#125;\nint main() &#123;\n    memset(f, -0x3f, sizeof (f));\n    scanf(&quot;%d %d %d&quot;, &amp;n, &amp;c[1], &amp;c[2]);\n    scanf(&quot;%s&quot;, s + 1);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        if (s[i] == &#39;(&#39;) t.push(i);\n        else mat[t.top()] = i, t.pop();\n    &#125;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        if (mat[i] == i + 1) &#123;\n            for (int k = 0; k &lt;= 2; ++k)\n                f[i][i + 1][k][k] = c[k];\n        &#125;\n    &#125;\n    for (int l = 4; l &lt;= n; l += 2) &#123;\n        for (int i = 1; i &lt;= n - l + 1; ++i) &#123;\n            int j = i + l - 1;\n            if (mat[i] == j) &#123;\n                // ((...))\n                // xy...zx\n                for (int x = 0; x &lt;= 2; ++x) &#123;\n                    for (int y = 0; y &lt;= 2; ++y) &#123;\n                        if (y == x) continue;\n                        for (int z = 0; z &lt;= 2; ++z) &#123;\n                            if (z == x) continue;\n                            upd(f[i][j][x][x], f[i + 1][j - 1][y][z] + c[x]);\n                        &#125;\n                    &#125;\n                &#125;\n            &#125;\n            else &#123;\n                // ()(...)\n                // xxy...z\n                for (int x = 0; x &lt;= 2; ++x) &#123;\n                    for (int y = 0; y &lt;= 2; ++y) &#123;\n                        if (y == x) continue;\n                        for (int z = 0; z &lt;= 2; ++z)\n                            upd(f[i][j][x][z], f[i][mat[i]][x][x] + f[mat[i] + 1][j][y][z]);\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n    for (int i = 0; i &lt;= 2; ++i) &#123;\n        for (int j = 0; j &lt;= 2; ++j)\n            res = max(res, f[1][n][i][j]);\n    &#125;\n    print(res, &#39;\\n&#39;);\n    return 0;\n&#125;\n&#125; // namespace XSC062</code></pre>\n</details>\n",
            "tags": [
                "树状数组",
                "区间 DP"
            ]
        }
    ]
}