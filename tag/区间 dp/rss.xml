<?xml version="1.0"?>
<rss version="2.0">
    <channel>
        <title> • Posts by &#34;区间 dp&#34; tag</title>
        <link>https://xsc062.netlify.app</link>
        <description></description>
        <language>zh-CN</language>
        <pubDate>Wed, 04 Oct 2023 16:41:40 +0800</pubDate>
        <lastBuildDate>Wed, 04 Oct 2023 16:41:40 +0800</lastBuildDate>
        <category>悬线法</category>
        <category>斜率优化</category>
        <category>并查集</category>
        <category>哈希</category>
        <category>DP</category>
        <category>单调队列</category>
        <category>字典树</category>
        <category>二分图</category>
        <category>分治</category>
        <category>计数</category>
        <category>容斥</category>
        <category>CRT / exCRT</category>
        <category>排列组合</category>
        <category>网络流</category>
        <category>二分</category>
        <category>容斥原理</category>
        <category>线段树</category>
        <category>树状数组</category>
        <category>区间 DP</category>
        <category>数据结构</category>
        <category>构造</category>
        <category>Tarjan</category>
        <category>下饭</category>
        <category>李超线段树</category>
        <category>树链剖分</category>
        <category>LCA</category>
        <category>倍增</category>
        <category>鸽巢原理</category>
        <category>数学</category>
        <category>调和级数</category>
        <category>差分</category>
        <category>思维</category>
        <category>树形 DP</category>
        <category>最小生成树</category>
        <category>SAM</category>
        <category>状压</category>
        <category>分块</category>
        <category>可持久化</category>
        <category>笛卡尔树</category>
        <category>高维前缀和</category>
        <category>闲话</category>
        <category>欧拉回路</category>
        <category>长链剖分</category>
        <category>KMP</category>
        <category>border</category>
        <category>随机化</category>
        <category>字符串</category>
        <category>AC 自动机</category>
        <category>SA</category>
        <category>树上差分</category>
        <category>FWT</category>
        <category>堆</category>
        <category>树的重心</category>
        <category>贪心</category>
        <category>均摊</category>
        <category>反悔贪心</category>
        <category>优化建图</category>
        <category>调整法</category>
        <category>博弈论</category>
        <category>DP 优化</category>
        <category>虚树</category>
        <category>点分治</category>
        <category>四边形不等式</category>
        <category>背包</category>
        <category>支配对</category>
        <category>DDP</category>
        <category>CDQ 分治</category>
        <category>猫树</category>
        <category>DP 套 DP</category>
        <category>Kruskal 重构树</category>
        <category>高精度</category>
        <category>最短路</category>
        <category>树套树</category>
        <category>二项式反演</category>
        <category>搜索</category>
        <item>
            <guid isPermalink="true">https://xsc062.netlify.app/20231004-1/</guid>
            <title>杂题选谈</title>
            <link>https://xsc062.netlify.app/20231004-1/</link>
            <category>树状数组</category>
            <category>区间 DP</category>
            <pubDate>Wed, 04 Oct 2023 16:41:40 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;&lt;a href=&#34;https://www.becoder.com.cn/contest/4272&#34;&gt;牛客普及&lt;/a&gt;。&lt;/p&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;a.-学习求余&#34;&gt;A. 学习求余&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.becoder.com.cn/contest/4272/problem/1&#34; class=&#34;uri&#34;&gt;https://www.becoder.com.cn/contest/4272/problem/1&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;今天我们来学习求余！这种题放普及 T1 不合适吧！&lt;/p&gt;
&lt;p&gt;令 &lt;span class=&#34;math inline&#34;&gt;\(k=\left\lfloor \dfrac n2 \right\rfloor + 1\)&lt;/span&gt;，直接输出 &lt;span class=&#34;math inline&#34;&gt;\(k\times (n - k)\)&lt;/span&gt; 即可。&lt;/p&gt;
&lt;details&gt;
&lt;p&gt;&lt;summary&gt;我是不是证复杂了…&lt;/summary&gt;&lt;/p&gt;
&lt;p&gt;我们可以简单地发现一个道理，对于任意 &lt;span class=&#34;math inline&#34;&gt;\(\dfrac n2&amp;lt;x\le n\)&lt;/span&gt;，&lt;span class=&#34;math inline&#34;&gt;\(n\bmod x\)&lt;/span&gt; 的值是 &lt;span class=&#34;math inline&#34;&gt;\(n - x\)&lt;/span&gt;；&lt;/p&gt;
&lt;p&gt;根据基本不等式（&lt;del&gt;wjs 直接感动得哭出声来&lt;/del&gt;）或小学知识「和不变，差小积大」，我们可以知道当 &lt;span class=&#34;math inline&#34;&gt;\(x=\left\lfloor \dfrac n2 \right\rfloor + 1\)&lt;/span&gt; 时，&lt;span class=&#34;math inline&#34;&gt;\(x\times (n-x)\)&lt;/span&gt; 取最大值。&lt;/p&gt;
&lt;p&gt;故有：当 &lt;span class=&#34;math inline&#34;&gt;\(x=\left\lfloor \dfrac n2 \right\rfloor + 1\)&lt;/span&gt; 时，&lt;span class=&#34;math inline&#34;&gt;\(x\times (n\bmod x)\)&lt;/span&gt; 取最大值。&lt;/p&gt;
&lt;p&gt;而对于 &lt;span class=&#34;math inline&#34;&gt;\(y\le \dfrac n2\)&lt;/span&gt;，由余数小于除数得，&lt;span class=&#34;math inline&#34;&gt;\(n\bmod y&amp;lt;y\le \dfrac n2\)&lt;/span&gt;。由于 &lt;span class=&#34;math inline&#34;&gt;\(0&amp;lt;y&amp;lt;x=\left\lfloor \dfrac n2 \right\rfloor + 1\)&lt;/span&gt; 且 &lt;span class=&#34;math inline&#34;&gt;\(0\le n\bmod y\le \left\lfloor \dfrac n2 \right\rfloor - 1\le n - \left\lfloor \dfrac n2 \right\rfloor - 1=n\bmod x\)&lt;/span&gt;，由不等式的基本性质得 &lt;span class=&#34;math inline&#34;&gt;\(x\times(n\bmod x)&amp;gt;y\times (n\bmod y)\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;综上，对于 &lt;span class=&#34;math inline&#34;&gt;\(1\le x\le n\)&lt;/span&gt;，当 &lt;span class=&#34;math inline&#34;&gt;\(x=\left\lfloor \dfrac n2 \right\rfloor + 1\)&lt;/span&gt; 时，&lt;span class=&#34;math inline&#34;&gt;\(x\times (n\bmod x)\)&lt;/span&gt; 有最大值。&lt;/p&gt;
&lt;/details&gt;
&lt;p&gt;然后如果你要问我怎么发现这一点的呢，我当时没有思路，然后随手输出了 &lt;span class=&#34;math inline&#34;&gt;\(n=100\)&lt;/span&gt; 时 &lt;span class=&#34;math inline&#34;&gt;\(n\bmod i\)&lt;/span&gt; 的所有值。然后发现 &lt;span class=&#34;math inline&#34;&gt;\(k=51\)&lt;/span&gt; 时余数是 &lt;span class=&#34;math inline&#34;&gt;\(49\)&lt;/span&gt;…… 然后就会了。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#define int long long
namespace XSC062 &amp;#123;
using namespace fastIO;
int n, k;
int main() &amp;#123;
    read(n), k = n / 2 + 1;
    print(k * (n % k));
    return 0;
&amp;#125;
&amp;#125; // namespace XSC062
#undef int&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;del&gt;头一次在题解里贴这么短的代码&lt;/del&gt;&lt;/p&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;b.-提取数字&#34;&gt;B. 提取数字&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.becoder.com.cn/contest/4272/problem/2&#34; class=&#34;uri&#34;&gt;https://www.becoder.com.cn/contest/4272/problem/2&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我被这道题（疑似 T1）坑到了！交了三遍才过！这合理吗？&lt;/p&gt;
&lt;p&gt;首先要开 &lt;code&gt;long long&lt;/code&gt;！然后注意，你的判定条件应为「当前是否已存储数」而非「当前存数变量是否为 0」！因为数据中会有单个 0 的情况出现！&lt;/p&gt;
&lt;p&gt;然后就没有了。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#define int long long
namespace XSC062 &amp;#123;
using namespace fastIO;
const int maxn = 1e5 + 5;
bool flag;
char s[maxn]; 
int n, ans, cnt;
int main() &amp;#123;
    scanf(&amp;quot;%*s %s&amp;quot;, s + 1);
    n = strlen(s + 1);
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        if (s[i] &amp;gt;= &amp;#39;0&amp;#39; &amp;amp;&amp;amp; s[i] &amp;lt;= &amp;#39;9&amp;#39;)
            cnt = cnt * 10 + s[i] - &amp;#39;0&amp;#39;, flag = 1;
        else if (flag)
            ans += (cnt + 5), cnt = 0, flag = 0;
    &amp;#125;
    if (flag) ans += (cnt + 5);
    print(ans, &amp;#39;\n&amp;#39;);
    return 0;
&amp;#125;
&amp;#125; // namespace XSC062
#undef int&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;c.-武器选择&#34;&gt;C. 武器选择&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.becoder.com.cn/contest/4272/problem/3&#34; class=&#34;uri&#34;&gt;https://www.becoder.com.cn/contest/4272/problem/3&lt;/a&gt;&lt;/p&gt;
&lt;details&gt;
&lt;p&gt;&lt;summary&gt;首先是我想了半个小时的狂拽酷炫吊炸天的法一：离线&lt;/summary&gt;&lt;/p&gt;
&lt;p&gt;我当时一边打一边怀疑现在的普及组是什么神仙，T3 考这么神奇的离线，难道是我落后于时代了？&lt;/p&gt;
&lt;p&gt;（之所以认为这是 T3 是因为括号那道题确实是正常 T4 风格）&lt;/p&gt;
&lt;p&gt;我们预处理出对于每一个可能获得武器 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 的位置，应该从哪个位置第一次捡到武器 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt;，由于这一段内的所有武器 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 都需要被拾取，我们将其作为区间 &lt;span class=&#34;math inline&#34;&gt;\([L_i, R_i]\)&lt;/span&gt; 来记录。&lt;/p&gt;
&lt;p&gt;那么询问可以转化为，在 &lt;span class=&#34;math inline&#34;&gt;\([l, r]\)&lt;/span&gt; 内 &lt;strong&gt;不同颜色&lt;/strong&gt; &lt;span class=&#34;math inline&#34;&gt;\([L_i, R_i]\)&lt;/span&gt; 的数量。&lt;/p&gt;
&lt;p&gt;考虑将询问离线。将询问按左端点从大到小排序，信息区间 &lt;span class=&#34;math inline&#34;&gt;\([L_i, R_i]\)&lt;/span&gt; 也按左端点从大到小排序。&lt;/p&gt;
&lt;p&gt;对于每次询问 &lt;span class=&#34;math inline&#34;&gt;\(l, r\)&lt;/span&gt;，在树状数组中将被 &lt;span class=&#34;math inline&#34;&gt;\([l, n]\)&lt;/span&gt; 完全包含的所有 &lt;span class=&#34;math inline&#34;&gt;\([L_i, R_i]\)&lt;/span&gt;（其实就是 &lt;span class=&#34;math inline&#34;&gt;\(l\le L_i\)&lt;/span&gt; 的所有 &lt;span class=&#34;math inline&#34;&gt;\(L_i\)&lt;/span&gt;）在右端点 &lt;span class=&#34;math inline&#34;&gt;\(R_i\)&lt;/span&gt; 处加一，我们就统计到了可以捡到武器的所有位置。&lt;/p&gt;
&lt;p&gt;怎么区分颜色呢？很简单，我们让每个颜色只被算一次。算哪一次呢？就算当前已加入的 &lt;span class=&#34;math inline&#34;&gt;\([L_i, R_i]\)&lt;/span&gt; 内，比选中概率最大的一次。&lt;/p&gt;
&lt;p&gt;我们树状数组统计的是 &lt;span class=&#34;math inline&#34;&gt;\([1, r]\)&lt;/span&gt; 内的值，所以我们要让概率最大的话，就要让 &lt;span class=&#34;math inline&#34;&gt;\(R_i\)&lt;/span&gt; 尽量的小。&lt;/p&gt;
&lt;p&gt;我们记录每个颜色当前合法 &lt;span class=&#34;math inline&#34;&gt;\([L_i, R_i]\)&lt;/span&gt; 的最小右端点 &lt;span class=&#34;math inline&#34;&gt;\(\min_R\)&lt;/span&gt;。加入一个新的 &lt;span class=&#34;math inline&#34;&gt;\([L_i, R_i]\)&lt;/span&gt; 时，如果 &lt;span class=&#34;math inline&#34;&gt;\(R_i\ge \min_R\)&lt;/span&gt;，那么不会产生影响，跳过；否则，当 &lt;span class=&#34;math inline&#34;&gt;\(R_i&amp;lt;\min_R\)&lt;/span&gt; 时，我们就要先消除当前 &lt;span class=&#34;math inline&#34;&gt;\(\min_R\)&lt;/span&gt; 的影响（即在树状数组中将该位置加上的 1 减去），再加上 &lt;span class=&#34;math inline&#34;&gt;\(R_i\)&lt;/span&gt; 的影响（即在树状数组中加上该位置的 1）。&lt;/p&gt;
&lt;p&gt;此时我们对 &lt;span class=&#34;math inline&#34;&gt;\([1, r]\)&lt;/span&gt; 的询问就是答案。&lt;/p&gt;
&lt;p&gt;复杂度 &lt;span class=&#34;math inline&#34;&gt;\(O(n\log n + m\log m + m\log n)\)&lt;/span&gt;，其中 &lt;span class=&#34;math inline&#34;&gt;\(n\log n\)&lt;/span&gt; 来自于对 &lt;span class=&#34;math inline&#34;&gt;\([L_i, R_i]\)&lt;/span&gt; 的排序，&lt;span class=&#34;math inline&#34;&gt;\(m\log m\)&lt;/span&gt; 来自于对询问的排序，&lt;span class=&#34;math inline&#34;&gt;\(m\log n\)&lt;/span&gt; 来自于离线树状数组。&lt;/p&gt;
&lt;/details&gt;
&lt;p&gt;接下来讲题解给的正解…… 这个是真的妙。&lt;/p&gt;
&lt;p&gt;考虑所有种类数，在 &lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt; 个数内满足条件的种类 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 最优条件下也不过 &lt;span class=&#34;math inline&#34;&gt;\(\dfrac {x\times (x+1)}2=n\)&lt;/span&gt;，所以满足条件武器的数量最多只有 &lt;span class=&#34;math inline&#34;&gt;\(\sqrt n\)&lt;/span&gt; 级别。&lt;/p&gt;
&lt;p&gt;所以我们对所有合法种类做前缀和，每次询问检查所有合法种类是否在该区间内出现对应次数，然后统计答案。复杂度 &lt;span class=&#34;math inline&#34;&gt;\(O(m\sqrt n + n\sqrt n)\)&lt;/span&gt;。&lt;span class=&#34;math inline&#34;&gt;\(n\sqrt n\)&lt;/span&gt; 是前面前缀和来的，&lt;span class=&#34;math inline&#34;&gt;\(m\sqrt n\)&lt;/span&gt; 是暴力统计来的。&lt;/p&gt;
&lt;p&gt;但是根号可耻，所以我的法一更 NB！！！🤡🤡🤡&lt;/p&gt;
&lt;details&gt;
&lt;p&gt;&lt;summary&gt;狂拽酷炫吊炸天的法一代码&lt;/summary&gt;&lt;/p&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#define int long long
namespace XSC062 &amp;#123;
using namespace fastIO;
const int maxn = 1e5 + 5;
struct _ &amp;#123;
    int l, r, k, i;
    bool operator&amp;lt; (const _ &amp;amp;q) const &amp;#123;
        return l &amp;lt; q.l;
    &amp;#125;
&amp;#125;;
struct __ &amp;#123;
    int l, r, nxt, x;
    bool operator&amp;lt; (const __ &amp;amp;q) const &amp;#123;
        return l &amp;lt; q.l;
    &amp;#125;
&amp;#125;;
_ q[maxn];
__ a[maxn];
std::map&amp;lt;int, int&amp;gt; t;
std::vector&amp;lt;int&amp;gt; u[maxn];
int ans[maxn], now[maxn];
int mnr[maxn], Bit[maxn];
int n, m, tot, x, cnt, pos;
int lowbit(int x) &amp;#123; return x &amp;amp; -x; &amp;#125;
void add(int x, int v) &amp;#123;
    for (int i = x; i &amp;lt;= n; i += lowbit(i))
        Bit[i] += v;
    return;
&amp;#125;
int ask(int x) &amp;#123;
    int res = 0;
    for (int i = x; i; i -= lowbit(i))
        res += Bit[i];
    return res;
&amp;#125;
int calc(int x, int k) &amp;#123;
    int res = 1;
    for (int i = 1; i &amp;lt;= k; ++i)
        res *= x--;
    for (int i = 1; i &amp;lt;= k; ++i)
        res /= i;
    return res;
&amp;#125;
int main() &amp;#123;
    read(n);
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        read(x);
        if (!t.count(x)) t[x] = ++tot;
        int id = t[x];
        u[id].push_back(i);
        if ((int)u[id].size() &amp;gt;= x) &amp;#123;
            a[++cnt].l = u[id][(int)u[id].size() - x];
            a[cnt].r = i, a[now[id]].nxt = cnt;
            a[cnt].x = x, mnr[x] = n + 1;
            now[id] = cnt;
        &amp;#125;
    &amp;#125;
    read(m);
    for (int i = 1; i &amp;lt;= m; ++i) &amp;#123;
        read(q[i].l), read(q[i].r);
        read(q[i].k), q[i].i = i;
    &amp;#125;
    std::sort(q + 1, q + m + 1);
    std::sort(a + 1, a + cnt + 1);
    pos = cnt;
    for (int i = m; i; --i) &amp;#123;
        while (a[pos].l &amp;gt;= q[i].l) &amp;#123;
            if (a[pos].r &amp;lt; mnr[a[pos].x]) &amp;#123;
                if (mnr[a[pos].x] &amp;lt;= n)
                    add(mnr[a[pos].x], -1);
                add(a[pos].r, 1);
                mnr[a[pos].x] = a[pos].r;
            &amp;#125;
            --pos;
        &amp;#125;
        ans[q[i].i] = calc(ask(q[i].r), q[i].k);
    &amp;#125;
    for (int i = 1; i &amp;lt;= m; ++i)
        print(ans[i], &amp;#39;\n&amp;#39;);
    return 0;
&amp;#125;
&amp;#125; // namespace XSC062
#undef int&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我甚至打完了就过了样例然后直接就 A 了，好久没有这么爽地过过这种大码量 &lt;del&gt;正确性还未知&lt;/del&gt; 的题了。&lt;/p&gt;
&lt;/details&gt;
&lt;p&gt;而且我相信全场只有我一个 &lt;del&gt;小丑&lt;/del&gt; 帅哥打离线，所以我是最强的！！！🤡🤡🤡&lt;/p&gt;
&lt;details&gt;
&lt;p&gt;&lt;summary&gt;绝对不如法一的法二代码&lt;/summary&gt;&lt;/p&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#define int long long
namespace XSC062 &amp;#123;
using namespace fastIO;
const int maxm = 505;
const int maxn = 1e5 + 5;
int a[maxn];
int cnt[maxn];
int sum[maxm][maxn];
int n, tot, m, l, r, k, res;
int calc(int x, int k) &amp;#123;
    int res = 1;
    for (int i = 1; i &amp;lt;= k; ++i)
        res *= x--;
    for (int i = 1; i &amp;lt;= k; ++i)
        res /= i;
    return res;
&amp;#125;
int main() &amp;#123;
    read(n);
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        read(a[i]);
        if (a[i] &amp;lt;= n) ++cnt[a[i]];
    &amp;#125;
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        if (cnt[i] &amp;gt;= i) &amp;#123;
            sum[++tot][n + 1] = i;
            for (int j = 1; j &amp;lt;= n; ++j)
                sum[tot][j] = sum[tot][j - 1] + (a[j] == i);
        &amp;#125;
    &amp;#125;
    read(m);
    while (m--) &amp;#123;
        read(l), read(r), read(k);
        res = 0;
        for (int i = 1; i &amp;lt;= tot; ++i)
            res += (sum[i][r] - sum[i][l - 1] &amp;gt;= sum[i][n + 1]);
        print(calc(res, k), &amp;#39;\n&amp;#39;);
    &amp;#125;
    return 0;
&amp;#125;
&amp;#125; // namespace XSC062
#undef int&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;d.-括号序列&#34;&gt;D. 括号序列&lt;/h3&gt;
&lt;p&gt;https://www.becoder.com.cn/contest/4272/problem/4&lt;/p&gt;
&lt;p&gt;呃呃呃，这，有什么好讲的吗？做过原题的应该都会吧……&lt;/p&gt;
&lt;p&gt;反正就是个比较裸的区间 DP，转移的时候注意一下究竟哪些是同一对括号，哪些是相邻括号就好。&lt;/p&gt;
&lt;p&gt;复杂度 &lt;span class=&#34;math inline&#34;&gt;\(O(n^2)\)&lt;/span&gt;。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;namespace XSC062 &amp;#123;
using namespace fastIO;
const int maxn = 1e3 + 5;
int n, res;
char s[maxn];
std::stack&amp;lt;int&amp;gt; t;
int mat[maxn], c[5];
int f[maxn][maxn][3][3];
int max(int x, int y) &amp;#123; return x &amp;gt; y ? x : y; &amp;#125;
void upd(int &amp;amp;x, int y) &amp;#123; x = max(x, y); return; &amp;#125;
int main() &amp;#123;
    memset(f, -0x3f, sizeof (f));
    scanf(&amp;quot;%d %d %d&amp;quot;, &amp;amp;n, &amp;amp;c[1], &amp;amp;c[2]);
    scanf(&amp;quot;%s&amp;quot;, s + 1);
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        if (s[i] == &amp;#39;(&amp;#39;) t.push(i);
        else mat[t.top()] = i, t.pop();
    &amp;#125;
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        if (mat[i] == i + 1) &amp;#123;
            for (int k = 0; k &amp;lt;= 2; ++k)
                f[i][i + 1][k][k] = c[k];
        &amp;#125;
    &amp;#125;
    for (int l = 4; l &amp;lt;= n; l += 2) &amp;#123;
        for (int i = 1; i &amp;lt;= n - l + 1; ++i) &amp;#123;
            int j = i + l - 1;
            if (mat[i] == j) &amp;#123;
                // ((...))
                // xy...zx
                for (int x = 0; x &amp;lt;= 2; ++x) &amp;#123;
                    for (int y = 0; y &amp;lt;= 2; ++y) &amp;#123;
                        if (y == x) continue;
                        for (int z = 0; z &amp;lt;= 2; ++z) &amp;#123;
                            if (z == x) continue;
                            upd(f[i][j][x][x], f[i + 1][j - 1][y][z] + c[x]);
                        &amp;#125;
                    &amp;#125;
                &amp;#125;
            &amp;#125;
            else &amp;#123;
                // ()(...)
                // xxy...z
                for (int x = 0; x &amp;lt;= 2; ++x) &amp;#123;
                    for (int y = 0; y &amp;lt;= 2; ++y) &amp;#123;
                        if (y == x) continue;
                        for (int z = 0; z &amp;lt;= 2; ++z)
                            upd(f[i][j][x][z], f[i][mat[i]][x][x] + f[mat[i] + 1][j][y][z]);
                    &amp;#125;
                &amp;#125;
            &amp;#125;
        &amp;#125;
    &amp;#125;
    for (int i = 0; i &amp;lt;= 2; ++i) &amp;#123;
        for (int j = 0; j &amp;lt;= 2; ++j)
            res = max(res, f[1][n][i][j]);
    &amp;#125;
    print(res, &amp;#39;\n&amp;#39;);
    return 0;
&amp;#125;
&amp;#125; // namespace XSC062&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
 ]]></description>
        </item>
    </channel>
</rss>
