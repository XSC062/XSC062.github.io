<?xml version="1.0"?>
<rss version="2.0">
    <channel>
        <title> • Posts by &#34;sa&#34; tag</title>
        <link>https://xsc062.netlify.app</link>
        <description></description>
        <language>zh-CN</language>
        <pubDate>Sun, 02 Feb 2025 08:27:44 +0800</pubDate>
        <lastBuildDate>Sun, 02 Feb 2025 08:27:44 +0800</lastBuildDate>
        <category>并查集</category>
        <category>斜率优化</category>
        <category>悬线法</category>
        <category>哈希</category>
        <category>字典树</category>
        <category>DP</category>
        <category>单调队列</category>
        <category>分治</category>
        <category>二分图</category>
        <category>CRT / exCRT</category>
        <category>排列组合</category>
        <category>网络流</category>
        <category>费用流</category>
        <category>二分</category>
        <category>上下界网络流</category>
        <category>容斥原理</category>
        <category>线段树</category>
        <category>树状数组</category>
        <category>区间 DP</category>
        <category>构造</category>
        <category>Tarjan</category>
        <category>数据结构</category>
        <category>下饭</category>
        <category>LCA</category>
        <category>倍增</category>
        <category>鸽巢原理</category>
        <category>概率期望</category>
        <category>调和级数</category>
        <category>差分</category>
        <category>思维</category>
        <category>树形 DP</category>
        <category>最小生成树</category>
        <category>SAM</category>
        <category>状压</category>
        <category>分块</category>
        <category>可持久化</category>
        <category>笛卡尔树</category>
        <category>高维前缀和</category>
        <category>闲话</category>
        <category>欧拉回路</category>
        <category>树链剖分</category>
        <category>长链剖分</category>
        <category>KMP</category>
        <category>border</category>
        <category>字符串</category>
        <category>AC 自动机</category>
        <category>SA</category>
        <category>数学</category>
        <category>树上差分</category>
        <category>FWT</category>
        <category>堆</category>
        <category>树的重心</category>
        <category>二项式定理</category>
        <category>二项式反演</category>
        <category>贪心</category>
        <category>均摊</category>
        <category>计数</category>
        <category>优化建图</category>
        <category>反悔贪心</category>
        <category>调整法</category>
        <category>背包</category>
        <category>博弈论</category>
        <category>DP 优化</category>
        <category>虚树</category>
        <category>点分治</category>
        <category>WQS 二分</category>
        <category>闵可夫斯基和</category>
        <category>slope trick</category>
        <category>四边形不等式</category>
        <category>暴力</category>
        <category>状压 DP</category>
        <category>组合数学</category>
        <category>支配对</category>
        <category>DDP</category>
        <category>平衡树</category>
        <category>容斥</category>
        <category>猫树</category>
        <category>Kruskal 重构树</category>
        <category>李超线段树</category>
        <item>
            <guid isPermalink="true">https://xsc062.netlify.app/20250202/</guid>
            <title>学习笔记：后缀数组</title>
            <link>https://xsc062.netlify.app/20250202/</link>
            <category>字符串</category>
            <category>SA</category>
            <pubDate>Sun, 02 Feb 2025 08:27:44 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;非常后知后觉地意识到 SA(Suffix Array) 和 SAM(Suffix Automaton) 的 A 不是同一个 A &lt;img src=&#34;/em/fad.gif&#34; /&gt;&lt;/p&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;定义&#34;&gt;定义&lt;/h2&gt;
&lt;p&gt;显而易见一个长度为 &lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt; 的字符串中有 &lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt; 个长度分别为 &lt;span class=&#34;math inline&#34;&gt;\(1\sim n\)&lt;/span&gt; 的后缀，如果我们对其按字典序排序，分别存储下排名 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 的后缀 &lt;span class=&#34;math inline&#34;&gt;\(sa_i\)&lt;/span&gt; 和每个后缀 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 的排名 &lt;span class=&#34;math inline&#34;&gt;\(rk_i\)&lt;/span&gt;。虽然看着挺没头没尾的，但是很有用。&lt;/p&gt;
&lt;h2 id=&#34;求解&#34;&gt;求解&lt;/h2&gt;
&lt;h3 id=&#34;哈希-排序&#34;&gt;哈希 + 排序&lt;/h3&gt;
&lt;p&gt;直接把所有后缀拿来排序的话，字符串比较是 &lt;span class=&#34;math inline&#34;&gt;\(O(n)\)&lt;/span&gt; 的。如果我们用哈希 + 二分优化比较过程，就可以把整个排序优化到 &lt;span class=&#34;math inline&#34;&gt;\(O(n\log^2 n)\)&lt;/span&gt;。&lt;/p&gt;
&lt;h3 id=&#34;倍增&#34;&gt;倍增&lt;/h3&gt;
&lt;p&gt;先对所有后缀按 &lt;strong&gt;第一个字符&lt;/strong&gt; 排序，记排序后排名序列为 &lt;span class=&#34;math inline&#34;&gt;\(a\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;那么怎么按 &lt;strong&gt;前两个字符&lt;/strong&gt; 排序呢？对于第 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 组字符，我们用 &lt;span class=&#34;math inline&#34;&gt;\((a_i,a_{i+1})\)&lt;/span&gt; 双关键字排序即可。记此时排名序列为 &lt;span class=&#34;math inline&#34;&gt;\(b\)&lt;/span&gt;，那么如果需要按照前四个字符排序，用 &lt;span class=&#34;math inline&#34;&gt;\((b_i,b_{i+2})\)&lt;/span&gt; 进行双关键字排序即可。总共需要进行 &lt;span class=&#34;math inline&#34;&gt;\(\log n\)&lt;/span&gt; 次排序。复杂度为 &lt;span class=&#34;math inline&#34;&gt;\(O(n\log^2n)\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;此时我们注意到排名数组的值域为 &lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt;，那么我们用桶排就能少一个 &lt;span class=&#34;math inline&#34;&gt;\(\log\)&lt;/span&gt;。&lt;/p&gt;
&lt;h2 id=&#34;实现&#34;&gt;实现&lt;/h2&gt;
&lt;p&gt;哈希很好实现，这里就按下不表，主要讲解倍增法的实现。&lt;/p&gt;
&lt;p&gt;描述起来很简单，实现起来很要命。OI wiki 上的实现算是相对好理解的：&lt;/p&gt;
&lt;p&gt;首先了解双关键字桶排的方法，首先用单关键字桶排完成对 &lt;strong&gt;第二关键字&lt;/strong&gt; 的排序；对于第一关键字，令桶 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 记录前 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 个元素的数量；遍历排序后的第二关键字数组，将元素放到桶中记录数值对应的下标中，并将桶中数值 &lt;span class=&#34;math inline&#34;&gt;\(-1\)&lt;/span&gt;。实际上桶 &lt;span class=&#34;math inline&#34;&gt;\(c\)&lt;/span&gt; 充当计算下标范围的作用，&lt;span class=&#34;math inline&#34;&gt;\((c_{i-1},c_i]\)&lt;/span&gt; 即为 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 分布的范围。&lt;/p&gt;
&lt;p&gt;显然，当且仅当排名种类为 &lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt;，即没有并列排名时，排序完成。设本轮区间长度为 &lt;span class=&#34;math inline&#34;&gt;\(w\)&lt;/span&gt;，对于一轮操作：&lt;/p&gt;
&lt;ol type=&#34;1&#34;&gt;
&lt;li&gt;计算每个区间按后半段 &lt;span class=&#34;math inline&#34;&gt;\(\frac w2\)&lt;/span&gt; 长度字符排序的结果：&lt;span class=&#34;math inline&#34;&gt;\((n-w,n]\)&lt;/span&gt; 开头的区间后半段均为空，直接放在序列首端；接着按照上一轮 &lt;span class=&#34;math inline&#34;&gt;\(sa\)&lt;/span&gt; 结果，把能够作为后半段的元素依次放入。&lt;/li&gt;
&lt;li&gt;依照上一轮的 &lt;span class=&#34;math inline&#34;&gt;\(rk\)&lt;/span&gt; 作为前半段排名，进行双关键字桶排。&lt;/li&gt;
&lt;li&gt;依照 &lt;span class=&#34;math inline&#34;&gt;\(sa\)&lt;/span&gt; 和第二关键字（处理并列），求出 &lt;span class=&#34;math inline&#34;&gt;\(rk\)&lt;/span&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;std::vector&amp;lt;int&amp;gt; la(n + 2);
std::copy(s.begin(), s.end(), rk.begin());
int m = 128;
&amp;#123;
    std::vector&amp;lt;int&amp;gt; c(m + 1);
    for (int i = 1; i &amp;lt;= n; ++i)
        ++c[rk[i]];
    std::partial_sum(c.begin(), c.end(), c.begin());
    for (int i = n; i; --i)
        sa[c[rk[i]]--] = i;
&amp;#125; 
for (int w = 1, p; ; w &amp;lt;&amp;lt;= 1, m = p) &amp;#123;
    std::vector&amp;lt;int&amp;gt; id(1);
    for (int i = n - w + 1; i &amp;lt;= n; ++i)
        id.push_back(i);
    for (int i = 1; i &amp;lt;= n; ++i)
        if (sa[i] &amp;gt; w)
            id.push_back(sa[i] - w);
    std::vector&amp;lt;int&amp;gt; c(m + 1);
    for (int i = 1; i &amp;lt;= n; ++i)
        ++c[rk[i]];
    std::partial_sum(c.begin(), c.end(), c.begin());
    for (int i = n; i; --i)
        sa[c[rk[id[i]]]--] = id[i];
    p = 0;
    std::copy(rk.begin(), rk.end(), la.begin());
    for (int i = 1; i &amp;lt;= n; ++i)
        if (la[sa[i]] == la[sa[i - 1]] &amp;amp;&amp;amp; la[sa[i] + w] == la[sa[i - 1] + w])
            rk[sa[i]] = p;
        else
            rk[sa[i]] = ++p;
    if (p == n)
        break;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;纯-sa-的应用&#34;&gt;纯 SA 的应用&lt;/h2&gt;
&lt;h3 id=&#34;最小表示法&#34;&gt;最小表示法&lt;/h3&gt;
&lt;p&gt;模板：&lt;a href=&#34;https://www.luogu.com.cn/problem/P1368&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P1368&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;对于循环位移相关要求，首先考虑将字符串重复一遍。&lt;/p&gt;
&lt;p&gt;在 &lt;span class=&#34;math inline&#34;&gt;\(ss\)&lt;/span&gt; 中找到排名第一个 &lt;span class=&#34;math inline&#34;&gt;\(sa_i\le n\)&lt;/span&gt; 即为答案。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#endif
    int n;
    std::cin &amp;gt;&amp;gt; n;
    std::vector&amp;lt;int&amp;gt; s(2 * n + 1);
    for (int i = 1; i &amp;lt;= n; ++i)
        std::cin &amp;gt;&amp;gt; s[i], s[n + i] = s[i];
    std::vector&amp;lt;int&amp;gt; sa(2 * n + 1), rk(s);
    &amp;#123;
        int m = 29;
        &amp;#123;
            std::vector&amp;lt;int&amp;gt; c(m + 1);
            for (int i = 1; i &amp;lt;= 2 * n; ++i)
                ++c[rk[i]];
            std::partial_sum(c.begin(), c.end(), c.begin());
            for (int i = 2 * n; i; --i)
                sa[c[rk[i]]--] = i;
        &amp;#125;
        for (int w = 1, p; ; w &amp;lt;&amp;lt;= 1, m = p) &amp;#123;
            std::vector&amp;lt;int&amp;gt; id(1);
            for (int i = 2 * n - w + 1; i &amp;lt;= 2 * n; ++i)
                id.push_back(i);
            for (int i = 1; i &amp;lt;= 2 * n; ++i)
                if (sa[i] &amp;gt; w)
                    id.push_back(sa[i] - w);
            std::vector&amp;lt;int&amp;gt; c(m + 1);
            for (int i = 1; i &amp;lt;= 2 * n; ++i)
                ++c[rk[i]];
            std::partial_sum(c.begin(), c.end(), c.begin());
            for (int i = 2 * n; i; --i)
                sa[c[rk[id[i]]]--] = id[i];
            auto la(rk);
            p = 0;
            for (int i = 1; i &amp;lt;= 2 * n; ++i)
                if (i != 1 &amp;amp;&amp;amp; la[sa[i]] == la[sa[i - 1]] &amp;amp;&amp;amp; la[sa[i] + w] == la[sa[i - 1] + w])
                    rk[sa[i]] = p;
                else
                    rk[sa[i]] = ++p;
            if (p == 2 * n)
                break;
        &amp;#125;
    &amp;#125;
    for (int i = 1; i &amp;lt;= 2 * n; ++i)
        if (sa[i] &amp;lt;= n) &amp;#123;
            for (int j = sa[i]; j &amp;lt; n + sa[i]; ++j)
                std::cout &amp;lt;&amp;lt; s[j] &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
            std::cout &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
            break;
        &amp;#125;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;字符串匹配&#34;&gt;字符串匹配&lt;/h3&gt;
&lt;p&gt;二分，复杂度 &lt;span class=&#34;math inline&#34;&gt;\(O(|S|\log |T|)\)&lt;/span&gt;。求出现次数则二分左右边界。&lt;/p&gt;
&lt;p&gt;太麻烦了且没有实际应用价值，代码略。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;height-数组&#34;&gt;height 数组&lt;/h2&gt;
&lt;p&gt;定义 &lt;span class=&#34;math inline&#34;&gt;\(h_i=\text {lcp}(sa_i, sa_i-1)\)&lt;/span&gt;，特别地，&lt;span class=&#34;math inline&#34;&gt;\(h_1=0\)&lt;/span&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;有引理：&lt;span class=&#34;math inline&#34;&gt;\(h_{rk_i}\ge h_{rk_{i-1}}-1\)&lt;/span&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;假设已经求出 &lt;span class=&#34;math inline&#34;&gt;\(h_{rk_{i-1}}\)&lt;/span&gt;，那么可以从 &lt;span class=&#34;math inline&#34;&gt;\(h_{rk_{i-1}}-1\)&lt;/span&gt; 出发暴力看下一个字符是否相等得到答案。那么我们会发现从前往后 &lt;span class=&#34;math inline&#34;&gt;\(h\)&lt;/span&gt; 值每次最多 &lt;span class=&#34;math inline&#34;&gt;\(-1\)&lt;/span&gt;，所以复杂度摊下来是 &lt;span class=&#34;math inline&#34;&gt;\(O(n)\)&lt;/span&gt; 的。&lt;/p&gt;
&lt;p&gt;&lt;mark&gt;记住记住一定是 &lt;span class=&#34;math inline&#34;&gt;\(rk_{i-1}\)&lt;/span&gt; 而不是下意识的 &lt;span class=&#34;math inline&#34;&gt;\(rk_i-1\)&lt;/span&gt;！！！&lt;/mark&gt;所以为了保证求解顺序循环枚举的一定是下标而非排名。但是注意定义却是和 &lt;span class=&#34;math inline&#34;&gt;\(rk_i-1\)&lt;/span&gt; 的 lcp！！！所以求 height 的写法是相对固定的，不能觉得好像是对的就随便乱改。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;height-数组的应用&#34;&gt;height 数组的应用&lt;/h2&gt;
&lt;p&gt;相当于背板子，因为应用太多且形式大多固定。&lt;/p&gt;
&lt;h3 id=&#34;求任意两个后缀的-lcp&#34;&gt;求任意两个后缀的 lcp&lt;/h3&gt;
&lt;p&gt;易得 &lt;span class=&#34;math inline&#34;&gt;\(\text{lcp}(sa_i, sa_j)=\min\{h_{i+1}, \cdots, h_j\}\)&lt;/span&gt;。&lt;strong&gt;故应将一些复杂 lcp 问题的解决方式和 RMQ 联系起来&lt;/strong&gt;。&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;子串大小关系&#34;&gt;子串大小关系&lt;/h3&gt;
&lt;p&gt;即比较 &lt;span class=&#34;math inline&#34;&gt;\(S_{l_1, r_1}\)&lt;/span&gt; 和 &lt;span class=&#34;math inline&#34;&gt;\(S_{l_2, r_2}\)&lt;/span&gt; 的大小关系。比较导致 lcp 不能继续延伸的元素大小即可。&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;本质不同子串数量&#34;&gt;本质不同子串数量&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;子串等价于「后缀的前缀」&lt;/strong&gt;。按顺序枚举每个后缀，减去和已枚举的所有后缀的 lcp 即可。鉴于 &lt;span class=&#34;math inline&#34;&gt;\(\min\{h_{j+1},\cdots,h_i\}\)&lt;/span&gt; 单调不减，直接减去 &lt;span class=&#34;math inline&#34;&gt;\(h_i\)&lt;/span&gt; 即可。&lt;/p&gt;
&lt;p&gt;最后答案即为 &lt;span class=&#34;math inline&#34;&gt;\(\frac {n(n-1)}2 - \sum\limits_{i=2}^nh_i\)&lt;/span&gt;。&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;至少出现-k-次子串的最大长度&#34;&gt;至少出现 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 次子串的最大长度&lt;/h3&gt;
&lt;p&gt;模板：&lt;a href=&#34;https://www.luogu.com.cn/problem/P2852&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P2852&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;出现 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 次 &lt;span class=&#34;math inline&#34;&gt;\(\iff\)&lt;/span&gt; 在后缀数组中连续出现 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 次 &lt;span class=&#34;math inline&#34;&gt;\(\iff\)&lt;/span&gt; 是任意连续 &lt;span class=&#34;math inline&#34;&gt;\(k-1\)&lt;/span&gt; 个 &lt;span class=&#34;math inline&#34;&gt;\(h\)&lt;/span&gt; 的最小值，需要最大化该最小值，考虑滑动窗口。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;P2852_7.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#endif
    int n, k;
    std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; k, --k;
    std::vector&amp;lt;int&amp;gt; s(n + 1);
    for (int i = 1; i &amp;lt;= n; ++i)
        std::cin &amp;gt;&amp;gt; s[i];
    std::vector&amp;lt;int&amp;gt; sa(n + 1), rk(s), h(n + 1);
    &amp;#123;
        int m = 1000001;
        &amp;#123;
            std::vector&amp;lt;int&amp;gt; c(m + 1);
            for (int i = 1; i &amp;lt;= n; ++i)
                ++c[rk[i]];
            std::partial_sum(c.begin(), c.end(), c.begin());
            for (int i = n; i; --i)
                sa[c[rk[i]]--] = i;
        &amp;#125;
        for (int w = 1, p; ; w &amp;lt;&amp;lt;= 1, m = p) &amp;#123;
            std::vector&amp;lt;int&amp;gt; id(1);
            for (int i = n - w + 1; i &amp;lt;= n; ++i)
                id.push_back(i);
            for (int i = 1; i &amp;lt;= n; ++i)
                if (sa[i] &amp;gt; w)
                    id.push_back(sa[i] - w);
            std::vector&amp;lt;int&amp;gt; c(m + 1);
            for (int i = 1; i &amp;lt;= n; ++i)
                ++c[rk[i]];
            std::partial_sum(c.begin(), c.end(), c.begin());
            for (int i = n; i; --i)
                sa[c[rk[id[i]]]--] = id[i];
            auto la(rk);
            p = 0;
            for (int i = 1; i &amp;lt;= n; ++i)
                if (i != 1 &amp;amp;&amp;amp; la[sa[i]] == la[sa[i - 1]] &amp;amp;&amp;amp; la[sa[i] + w] == la[sa[i - 1] + w])
                    rk[sa[i]] = p;
                else
                    rk[sa[i]] = ++p;
            if (p == n)
                break;
        &amp;#125;
        for (int i = 1, to = 0; i &amp;lt;= n; ++i)
            if (rk[i]) &amp;#123;
                for (to = std::max(to - 1, 0); s[i + to] == s[sa[rk[i] - 1] + to]; ++to);
                h[rk[i]] = to;
            &amp;#125;
    &amp;#125;
    std::vector&amp;lt;int&amp;gt; q(n + 1);
    int res = 0;
    for (int i = 1, l = 1, r = 0; i &amp;lt;= n; ++i) &amp;#123;
        // printf(&amp;quot;%d\n&amp;quot;, h[i]);
        for (; l &amp;lt;= r &amp;amp;&amp;amp; i - q[l] &amp;gt;= k; ++l);
        for (; l &amp;lt;= r &amp;amp;&amp;amp; h[i] &amp;lt;= h[q[r]]; --r);
        q[++r] = i;
        if (i &amp;gt;= k)
            res = std::max(res, h[q[l]]);
    &amp;#125;
    std::cout &amp;lt;&amp;lt; res &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;最长不重叠多次出现子串&#34;&gt;最长不重叠多次出现子串&lt;/h3&gt;
&lt;p&gt;&lt;del&gt;bb：定式太多太杂以至于让人怀疑某些定式是否存在应用场景&lt;/del&gt; &lt;img src=&#34;/em/kt.gif&#34; /&gt;&lt;/p&gt;
&lt;p&gt;发现满足单调性，二分子串长度 &lt;span class=&#34;math inline&#34;&gt;\(len\)&lt;/span&gt;，那么显然 &lt;span class=&#34;math inline&#34;&gt;\(\text {lcp}\ge len\)&lt;/span&gt;；将 &lt;span class=&#34;math inline&#34;&gt;\(h\)&lt;/span&gt; 划分为连续 &lt;span class=&#34;math inline&#34;&gt;\(\ge len\)&lt;/span&gt; 的段，在每段内找到下标极差与 &lt;span class=&#34;math inline&#34;&gt;\(len\)&lt;/span&gt; 比较即可。&lt;/p&gt;
&lt;p&gt;也可以用于判定是否存在不重叠多次出现子串。&lt;/p&gt;
&lt;p&gt;甚至可以考虑限制至少出现次数为 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt;，那大概多个 &lt;span class=&#34;math inline&#34;&gt;\(\log\)&lt;/span&gt;，看看一段里有没有 &lt;span class=&#34;math inline&#34;&gt;\(\ge k\)&lt;/span&gt; 个相互相差 &lt;span class=&#34;math inline&#34;&gt;\(\ge len\)&lt;/span&gt; 的。排序贪心求解。&lt;/p&gt;
&lt;p&gt;那么上面的至少出现 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 次子串也可以用这个方法来解，但是多个 &lt;span class=&#34;math inline&#34;&gt;\(\log\)&lt;/span&gt; 没必要。&lt;/p&gt;
&lt;p&gt;也可以限制多次出现但长度至少为 &lt;span class=&#34;math inline&#34;&gt;\(len\)&lt;/span&gt;，那甚至少了二分的 &lt;span class=&#34;math inline&#34;&gt;\(\log\)&lt;/span&gt;，直接跑一遍 check 即可。&lt;/p&gt;
&lt;p&gt;&lt;del&gt;？？？到底为什么会有这么多奇怪的定式，是因为真的有题这么出吗？？？&lt;/del&gt; &lt;img src=&#34;/em/oh.gif&#34; /&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;最长公共子串问题&#34;&gt;最长公共子串问题&lt;/h3&gt;
&lt;p&gt;求 &lt;span class=&#34;math inline&#34;&gt;\(S\)&lt;/span&gt; 和 &lt;span class=&#34;math inline&#34;&gt;\(T\)&lt;/span&gt; 的最长公共子串（注意不是 LCS）。设 &lt;span class=&#34;math inline&#34;&gt;\(S\)&lt;/span&gt; 长为 &lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt;，&lt;span class=&#34;math inline&#34;&gt;\(T\)&lt;/span&gt; 长为 &lt;span class=&#34;math inline&#34;&gt;\(m\)&lt;/span&gt;，那么将 &lt;span class=&#34;math inline&#34;&gt;\(S\)&lt;/span&gt; 与 &lt;span class=&#34;math inline&#34;&gt;\(T\)&lt;/span&gt; 拼接，答案就是 &lt;span class=&#34;math inline&#34;&gt;\(\max \{\text{lcp}(i,j)\},i\le n&amp;lt;j\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;但这里不直接枚举 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 和 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt;，还是照例先从 &lt;span class=&#34;math inline&#34;&gt;\(h\)&lt;/span&gt; 下手再卡条件，若 &lt;span class=&#34;math inline&#34;&gt;\(sa_{i-1}\le n&amp;lt;sa_{i}\)&lt;/span&gt;（或者反过来），就可以用 &lt;span class=&#34;math inline&#34;&gt;\(h_i\)&lt;/span&gt; 更新答案。容易证明这样总可以找到最大值。&lt;/p&gt;
&lt;h4 id=&#34;eg1.-找相同字符&#34;&gt;eg1. 找相同字符&lt;/h4&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P3181&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P3181&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;要求方案数，那么答案为 &lt;span class=&#34;math inline&#34;&gt;\(\text{lcp}(i,j),i\le n&amp;lt;j\)&lt;/span&gt;。（我已经帮你们试过了容斥比直接做更麻烦），考虑用单调栈维护左 / 右侧区间 lcp 求解右 / 左侧答案。关于单调栈的描述可见 &lt;a href=&#34;#结合单调栈&#34;&gt;本页后部内容&lt;/a&gt;。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#endif
    int n, n1;
    std::string s, t;
    std::cin &amp;gt;&amp;gt; s &amp;gt;&amp;gt; t;
    n = (int)s.length(), n1 = n + (int)t.length() + 1;
    s = &amp;quot;#&amp;quot; + s + &amp;quot;$&amp;quot; + t;
    std::vector&amp;lt;int&amp;gt; sa(n1 + 1), rk(n1 + 1), h(n1 + 1);
    &amp;#123;
        std::copy(s.begin() + 1, s.end(), rk.begin() + 1);
        int m = 128;
        &amp;#123;
            std::vector&amp;lt;int&amp;gt; c(m + 1);
            for (int i = 1; i &amp;lt;= n1; ++i)
                ++c[rk[i]];
            std::partial_sum(c.begin(), c.end(), c.begin());
            for (int i = n1; i; --i)
                sa[c[rk[i]]--] = i;
        &amp;#125;
        for (int w = 1, p; ; w &amp;lt;&amp;lt;= 1, m = p) &amp;#123;
            std::vector&amp;lt;int&amp;gt; id(w + 1);
            std::iota(id.begin() + 1, id.end(), n1 - w + 1);
            for (int i = 1; i &amp;lt;= n1; ++i)
                if (sa[i] &amp;gt; w)
                    id.push_back(sa[i] - w);
            std::vector&amp;lt;int&amp;gt; c(m + 1);
            for (int i = 1; i &amp;lt;= n1; ++i)
                ++c[rk[i]];
            std::partial_sum(c.begin(), c.end(), c.begin());
            for (int i = n1; i; --i)
                sa[c[rk[id[i]]]--] = id[i];
            p = 0;
            auto la(rk);
            for (int i = 1; i &amp;lt;= n1; ++i)
                if (i != 1 &amp;amp;&amp;amp; la[sa[i]] == la[sa[i - 1]] &amp;amp;&amp;amp; la[sa[i] + w] == la[sa[i - 1] + w])
                    rk[sa[i]] = p;
                else
                    rk[sa[i]] = ++p;
            if (p == n1)
                break;
        &amp;#125;
        for (int i = 1, to = 0; i &amp;lt;= n1; ++i) &amp;#123;
            for (to = std::max(to - 1, 0); s[i + to] == s[sa[rk[i] - 1] + to]; ++to);
            h[rk[i]] = to;
        &amp;#125;
    &amp;#125;
    std::vector&amp;lt;std::pair&amp;lt;int, long long&amp;gt; &amp;gt; q1, q2;
    std::vector&amp;lt;int&amp;gt; tot1(n1 + 1), tot2(n1 + 1);
    for (int i = 1; i &amp;lt;= n1; ++i) &amp;#123;
        tot1[i] = tot1[i - 1] + (sa[i] &amp;lt;= n);
        tot2[i] = tot2[i - 1] + (sa[i] &amp;gt; n + 1);
    &amp;#125;
    long long res = 0ll;
    q1.emplace_back(1, 0ll), q2.emplace_back(1, 0ll);
    for (int i = 1; i &amp;lt;= n1; ++i) &amp;#123;
        for (; !q1.empty() &amp;amp;&amp;amp; h[i] &amp;lt; h[q1.back().first]; q1.pop_back());
        q1.emplace_back(i, (tot1[i - 1] - tot1[q1.back().first - 1]) * h[i] + q1.back().second);
        if (sa[i] &amp;gt; n + 1)
            res += q1.back().second;
        for (; !q2.empty() &amp;amp;&amp;amp; h[i] &amp;lt; h[q2.back().first]; q2.pop_back());
        q2.emplace_back(i, (tot2[i - 1] - tot2[q2.back().first - 1]) * h[i] + q2.back().second);
        if (sa[i] &amp;lt;= n)
            res += q2.back().second;
    &amp;#125;
    std::cout &amp;lt;&amp;lt; res &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h4 id=&#34;eg2.-公共串&#34;&gt;eg2. 公共串&lt;/h4&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P5546&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P5546&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;要求多串最长公共子串，仍然考虑将多个串拼在一起。仿照前面二分的方式处理，问题转化为找到最长的 &lt;span class=&#34;math inline&#34;&gt;\(len\)&lt;/span&gt;，使得存在一段最小值 &lt;span class=&#34;math inline&#34;&gt;\(\ge len\)&lt;/span&gt; 的区间，其覆盖了 &lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt; 段串。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#endif
    int n, l = 0, r = 0;
    std::cin &amp;gt;&amp;gt; n;
    std::string s;
    std::vector&amp;lt;std::pair&amp;lt;int, int&amp;gt; &amp;gt; lim(n + 1);
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        std::string t;
        std::cin &amp;gt;&amp;gt; t;
        lim[i] = &amp;#123; (int)s.length() + 1, s.length() + t.length() &amp;#125;;
        s += &amp;quot;#&amp;quot; + t;
        r = std::max(r, (int)t.length());
        // printf(&amp;quot;[%d, %d]\n&amp;quot;, lim[i].first, lim[i].second);
    &amp;#125;
    int n1 = lim.back().second;
    std::vector&amp;lt;int&amp;gt; sa(n1 + 1), rk(n1 + 1), h(n1 + 1);
    &amp;#123;
        std::copy(s.begin() + 1, s.end(), rk.begin() + 1);
        int m = 128;
        &amp;#123;
            std::vector&amp;lt;int&amp;gt; c(m + 1);
            for (int i = 1; i &amp;lt;= n1; ++i)
                ++c[rk[i]];
            std::partial_sum(c.begin(), c.end(), c.begin());
            for (int i = n1; i; --i)
                sa[c[rk[i]]--] = i;
        &amp;#125;
        for (int w = 1, p; ; w &amp;lt;&amp;lt;= 1, m = p) &amp;#123;
            std::vector&amp;lt;int&amp;gt; id(w + 1);
            std::iota(id.begin() + 1, id.end(), n1 - w + 1);
            for (int i = 1; i &amp;lt;= n1; ++i)
                if (sa[i] &amp;gt; w)
                    id.push_back(sa[i] - w);
            std::vector&amp;lt;int&amp;gt; c(m + 1);
            for (int i = 1; i &amp;lt;= n1; ++i)
                ++c[rk[i]];
            std::partial_sum(c.begin(), c.end(), c.begin());
            for (int i = n1; i; --i)
                sa[c[rk[id[i]]]--] = id[i];
            p = 0;
            auto la(rk);
            for (int i = 1; i &amp;lt;= n1; ++i)
                if (i != 1 &amp;amp;&amp;amp; la[sa[i]] == la[sa[i - 1]] &amp;amp;&amp;amp; la[sa[i] + w] == la[sa[i - 1] + w])
                    rk[sa[i]] = p;
                else
                    rk[sa[i]] = ++p;
            if (p == n1)
                break;
        &amp;#125;
        for (int i = 1, to = 0; i &amp;lt;= n1; ++i) &amp;#123;
            for (to = std::max(to - 1, 0); s[i + to] == s[sa[rk[i] - 1] + to]; ++to);
            h[rk[i]] = to;
        &amp;#125;
    &amp;#125;
    // for (int i = 1; i &amp;lt;= n1; ++i)
    //     printf(&amp;quot;h[%d] = %d\n&amp;quot;, sa[i], h[i]);
    int res = 0;
    auto check = [&amp;amp;](int len) &amp;#123;
        // printf(&amp;quot;check %d: \n&amp;quot;, len);
        std::vector&amp;lt;int&amp;gt; cnt(n + 1);
        for (int i = 1; i &amp;lt;= n1; ++i) &amp;#123;
            if (h[i] &amp;lt; len) &amp;#123;
                if (*std::min_element(cnt.begin() + 1, cnt.end()))
                    return 1;
                cnt.assign(n + 1, 0);
            &amp;#125;
            else
                for (int j = 1; j &amp;lt;= n; ++j) &amp;#123;
                    if (lim[j].first &amp;lt;= sa[i - 1] &amp;amp;&amp;amp; sa[i - 1] &amp;lt;= lim[j].second)
                        cnt[j] = 1;
                    if (lim[j].first &amp;lt;= sa[i] &amp;amp;&amp;amp; sa[i] &amp;lt;= lim[j].second)
                        cnt[j] = 1;
                &amp;#125;
        &amp;#125;
        // printf(&amp;quot;\n%d\n&amp;quot;, *std::min_element(cnt.begin() + 1, cnt.end()));
        return *std::min_element(cnt.begin() + 1, cnt.end());
    &amp;#125;;
    for (int mid; l &amp;lt;= r; ) &amp;#123;
        mid = (l + r) &amp;gt;&amp;gt; 1;
        if (check(mid))
            l = mid + 1, res = mid;
        else
            r = mid - 1;
    &amp;#125;
    std::cout &amp;lt;&amp;lt; res &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;p&gt;但是看了题解发现居然还有线性做法（当然不看建 SA 的 &lt;span class=&#34;math inline&#34;&gt;\(\log\)&lt;/span&gt;），对于覆盖全部 &lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt; 段串找区间最小值，发现需要最小化区间，考虑双指针。&lt;/p&gt;
&lt;p&gt;区间最小值用单调队列求解，细想可能会觉得不太对劲，但是容易证明答案不大于队首且不小于最大队首，所以最大队首就是答案。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#endif
    int n, l = 0, r = 0;
    std::cin &amp;gt;&amp;gt; n;
    std::string s;
    std::vector&amp;lt;std::pair&amp;lt;int, int&amp;gt; &amp;gt; lim(n + 1);
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        std::string t;
        std::cin &amp;gt;&amp;gt; t;
        lim[i] = &amp;#123; (int)s.length() + 1, s.length() + t.length() &amp;#125;;
        s += (char)(&amp;#39;A&amp;#39; + i - 1) + t;
        r = std::max(r, (int)t.length());
    &amp;#125;
    int n1 = lim.back().second;
    std::vector&amp;lt;int&amp;gt; sa(n1 + 1), rk(n1 + 1), h(n1 + 1);
    &amp;#123;
        std::copy(s.begin() + 1, s.end(), rk.begin() + 1);
        int m = 128;
        &amp;#123;
            std::vector&amp;lt;int&amp;gt; c(m + 1);
            for (int i = 1; i &amp;lt;= n1; ++i)
                ++c[rk[i]];
            std::partial_sum(c.begin(), c.end(), c.begin());
            for (int i = n1; i; --i)
                sa[c[rk[i]]--] = i;
        &amp;#125;
        for (int w = 1, p; ; w &amp;lt;&amp;lt;= 1, m = p) &amp;#123;
            std::vector&amp;lt;int&amp;gt; id(w + 1);
            std::iota(id.begin() + 1, id.end(), n1 - w + 1);
            for (int i = 1; i &amp;lt;= n1; ++i)
                if (sa[i] &amp;gt; w)
                    id.push_back(sa[i] - w);
            std::vector&amp;lt;int&amp;gt; c(m + 1);
            for (int i = 1; i &amp;lt;= n1; ++i)
                ++c[rk[i]];
            std::partial_sum(c.begin(), c.end(), c.begin());
            for (int i = n1; i; --i)
                sa[c[rk[id[i]]]--] = id[i];
            p = 0;
            auto la(rk);
            for (int i = 1; i &amp;lt;= n1; ++i)
                if (i != 1 &amp;amp;&amp;amp; la[sa[i]] == la[sa[i - 1]] &amp;amp;&amp;amp; la[sa[i] + w] == la[sa[i - 1] + w])
                    rk[sa[i]] = p;
                else
                    rk[sa[i]] = ++p;
            if (p == n1)
                break;
        &amp;#125;
        for (int i = 1, to = 0; i &amp;lt;= n1; ++i) &amp;#123;
            for (to = std::max(to - 1, 0); s[i + to] == s[sa[rk[i] - 1] + to]; ++to);
            h[rk[i]] = to;
        &amp;#125;
    &amp;#125;
    int res = 0;
    std::vector&amp;lt;int&amp;gt; q(n1 + 1), cnt(n + 1);
    // for (int i = 1; i &amp;lt;= n1; ++i)
    //     printf(&amp;quot;%d: %d\n&amp;quot;, sa[i], h[i]);
    for (int l = 1, r = 0, ql = 1, qr = 0; l &amp;lt;= n1; ++l) &amp;#123;
        for (; r &amp;lt; n1 &amp;amp;&amp;amp; !*std::min_element(cnt.begin() + 1, cnt.end()); ) &amp;#123;
            ++r;
            for (int i = 1; i &amp;lt;= n; ++i)
                if (lim[i].first &amp;lt;= sa[r] &amp;amp;&amp;amp; sa[r] &amp;lt;= lim[i].second) &amp;#123;
                    ++cnt[i];
                    break;
                &amp;#125;
            for (; ql &amp;lt;= qr &amp;amp;&amp;amp; h[r] &amp;lt;= h[q[qr]]; --qr);
            q[++qr] = r;
        &amp;#125;
        if (*std::min_element(cnt.begin() + 1, cnt.end())) &amp;#123;
            // printf(&amp;quot;[%d, %d]: %d\n&amp;quot;, l, r, h[q[ql]]);
            res = std::max(res, h[q[ql]]);
        &amp;#125;
        for (; ql &amp;lt;= qr &amp;amp;&amp;amp; q[ql] &amp;lt;= l; ++ql);
        if (l != 1) &amp;#123;
            for (int i = 1; i &amp;lt;= n; ++i)
                if (lim[i].first &amp;lt;= sa[l - 1] &amp;amp;&amp;amp; sa[l - 1] &amp;lt;= lim[i].second) &amp;#123;
                    --cnt[i];
                    break;
                &amp;#125;
        &amp;#125;
    &amp;#125;
    std::cout &amp;lt;&amp;lt; res &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;texttt-aa-式子串处理&#34;&gt;&lt;span class=&#34;math inline&#34;&gt;\(\texttt {AA}\)&lt;/span&gt; 式子串处理&lt;/h3&gt;
&lt;p&gt;即对于连续相同子串问题的处理，有一个定的思路，由例题分析。&lt;/p&gt;
&lt;h4 id=&#34;eg1.-优秀的拆分&#34;&gt;eg1. 优秀的拆分&lt;/h4&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P1117&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P1117&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;还是从中间分开，按前后分别处理。这里有个 trick，我们枚举 &lt;span class=&#34;math inline&#34;&gt;\(\texttt B\)&lt;/span&gt; 的长度 &lt;span class=&#34;math inline&#34;&gt;\(len\)&lt;/span&gt;，在 &lt;span class=&#34;math inline&#34;&gt;\(S\)&lt;/span&gt; 中每隔 &lt;span class=&#34;math inline&#34;&gt;\(len\)&lt;/span&gt; 打一个标记。那么显然，任意一个长度为 &lt;span class=&#34;math inline&#34;&gt;\(2\times len\)&lt;/span&gt; 的子串都会经过恰好两个标记（充分的），这样就可以筛选出所有可能的串。&lt;/p&gt;
&lt;p&gt;我们枚举所有连续两个标记（总复杂度为调和级数），求它们对应后缀的 lcp 和对应前缀的 lcs（翻转求 SA 即可），如果二者加起来 &lt;span class=&#34;math inline&#34;&gt;\(\ge len\)&lt;/span&gt; 就说明存在这样的 &lt;span class=&#34;math inline&#34;&gt;\(\texttt {AA}\)&lt;/span&gt;。在 &lt;span class=&#34;math inline&#34;&gt;\(\text {lcs}+\text {lcp}\)&lt;/span&gt; 中任取 &lt;span class=&#34;math inline&#34;&gt;\(len\)&lt;/span&gt; 长度即为一对 &lt;span class=&#34;math inline&#34;&gt;\(\texttt {AA}\)&lt;/span&gt;。用差分给可能的起点和终点区间加即可。&lt;/p&gt;
&lt;p&gt;小细节：lcp 和 lcs 均需要对 &lt;span class=&#34;math inline&#34;&gt;\(len\)&lt;/span&gt; 取 &lt;span class=&#34;math inline&#34;&gt;\(\min\)&lt;/span&gt;，否则取到的串可能不会经过当前选中的两个标记。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
class SA &amp;#123;
public:
    std::vector&amp;lt;int&amp;gt; sa, rk, h;
    std::vector&amp;lt;std::vector&amp;lt;int&amp;gt;  &amp;gt; st;
    SA(int n, std::string s): sa(n + 1), rk(n + 2), h(n + 1), st(20, std::vector&amp;lt;int&amp;gt; (n + 1)) &amp;#123;
        std::vector&amp;lt;int&amp;gt; la(n + 2);
        std::copy(s.begin(), s.end(), rk.begin());
        int m = 128;
        &amp;#123;
            std::vector&amp;lt;int&amp;gt; c(m + 1);
            for (int i = 1; i &amp;lt;= n; ++i)
                ++c[rk[i]];
            std::partial_sum(c.begin(), c.end(), c.begin());
            for (int i = n; i; --i)
                sa[c[rk[i]]--] = i;
        &amp;#125;
        for (int w = 1, p; ; w &amp;lt;&amp;lt;= 1, m = p) &amp;#123;
            std::vector&amp;lt;int&amp;gt; id(1);
            for (int i = n - w + 1; i &amp;lt;= n; ++i)
                id.push_back(i);
            for (int i = 1; i &amp;lt;= n; ++i)
                if (sa[i] &amp;gt; w)
                    id.push_back(sa[i] - w);
            std::vector&amp;lt;int&amp;gt; c(m + 1);
            for (int i = 1; i &amp;lt;= n; ++i)
                ++c[rk[i]];
            std::partial_sum(c.begin(), c.end(), c.begin());
            for (int i = n; i; --i)
                sa[c[rk[id[i]]]--] = id[i];
            p = 0;
            std::copy(rk.begin(), rk.end(), la.begin());
            for (int i = 1; i &amp;lt;= n; ++i)
                if (la[sa[i]] == la[sa[i - 1]] &amp;amp;&amp;amp; la[sa[i] + w] == la[sa[i - 1] + w])
                    rk[sa[i]] = p;
                else
                    rk[sa[i]] = ++p;
            if (p == n)
                break;
        &amp;#125;
        for (int i = 1, to = 0; i &amp;lt;= n; ++i)
            if (rk[i]) &amp;#123;
                for (to = std::max(to - 1, 0); s[i + to] == s[sa[rk[i] - 1] + to]; ++to);
                h[rk[i]] = to;
            &amp;#125;
        for (int i = 1; i &amp;lt;= n; ++i)
            st[0][i] = h[i];
        for (int j = 1; (1 &amp;lt;&amp;lt; j) &amp;lt;= n; ++j)
            for (int i = 1; i + (1 &amp;lt;&amp;lt; j) - 1 &amp;lt;= n; ++i)
                st[j][i] = std::min(st[j - 1][i], st[j - 1][i + (1 &amp;lt;&amp;lt; (j - 1))]);
        rk.emplace_back();
        return;
    &amp;#125;
private:
    int ask(int l, int r) &amp;#123;
        // fprintf(stderr, &amp;quot;l = %d, r = %d\n&amp;quot;, l, r);
        int k = std::__lg(r - l + 1);
        return std::min(st[k][l], st[k][r - (1 &amp;lt;&amp;lt; k) + 1]);
    &amp;#125;
public:
    int lcp(int l, int r) &amp;#123;
        return ask(std::min(rk[l], rk[r]) + 1, std::max(rk[l], rk[r]));
    &amp;#125;
&amp;#125;;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#endif
    int T;
    for (std::cin &amp;gt;&amp;gt; T; T--; ) &amp;#123;
        std::string s;
        std::cin &amp;gt;&amp;gt; s;
        int n = (int)s.length();
        s = &amp;quot;#&amp;quot; + s;
        SA p(n, s);
        std::reverse(s.begin() + 1, s.end());
        SA q(n, s);
        std::vector&amp;lt;int&amp;gt; f(n + 2), g(n + 2);
        for (int len = 1; len &amp;lt;= n / 2; ++len)
            for (int i = len; i + len &amp;lt;= n; i += len) &amp;#123;
                int l = i, r = i + len, lcp = std::min(len, p.lcp(l, r)), lcs = std::min(len - 1, q.lcp(n - l + 2, n - r + 2));
                if (lcp + lcs &amp;gt;= len) &amp;#123;
                    int t = lcp + lcs - len + 1;
                    // fprintf(stderr, &amp;quot;(%d, %d), %d, %d\n&amp;quot;, l, r, lcp, lcs);
                    ++g[l - lcs], --g[l - lcs + t], ++f[r + lcp - t], --f[r + lcp];
                &amp;#125;
            &amp;#125;
        std::partial_sum(f.begin(), f.end(), f.begin());
        std::partial_sum(g.begin(), g.end(), g.begin());
        long long res = 0ll;
        for (int i = 1; i &amp;lt; n; ++i)
            res += (long long)f[i] * g[i + 1];
        std::cout &amp;lt;&amp;lt; res &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    &amp;#125;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h4 id=&#34;eg2.-tandem&#34;&gt;eg2. tandem&lt;/h4&gt;
&lt;p&gt;&lt;a href=&#34;https://www.codechef.com/problems/TANDEM&#34; class=&#34;uri&#34;&gt;https://www.codechef.com/problems/TANDEM&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;注意到多了一个限制，前一个好处理，找到经过 &lt;span class=&#34;math inline&#34;&gt;\(3\)&lt;/span&gt; 个标记的串即可。对于后一个限制，画图可以发现对于 interesting ones，每次只会出现最多一个；当且仅当 &lt;span class=&#34;math inline&#34;&gt;\(\text {lcp}&amp;gt;len\)&lt;/span&gt; 时不存在。&lt;/p&gt;
&lt;p&gt;对于 uninteresting ones，用每次能提供的总数减去 interesting ones 的数量即可。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
class SA &amp;#123;
public:
    std::vector&amp;lt;int&amp;gt; sa, rk, h;
    std::vector&amp;lt;std::vector&amp;lt;int&amp;gt;  &amp;gt; st;
    SA(int n, std::string s): sa(n + 1), rk(n + 2), h(n + 1), st(20, std::vector&amp;lt;int&amp;gt; (n + 1)) &amp;#123;
        std::vector&amp;lt;int&amp;gt; la(n + 2);
        std::copy(s.begin(), s.end(), rk.begin());
        int m = 128;
        &amp;#123;
            std::vector&amp;lt;int&amp;gt; c(m + 1);
            for (int i = 1; i &amp;lt;= n; ++i)
                ++c[rk[i]];
            std::partial_sum(c.begin(), c.end(), c.begin());
            for (int i = n; i; --i)
                sa[c[rk[i]]--] = i;
        &amp;#125;
        for (int w = 1, p; ; w &amp;lt;&amp;lt;= 1, m = p) &amp;#123;
            std::vector&amp;lt;int&amp;gt; id(1);
            for (int i = n - w + 1; i &amp;lt;= n; ++i)
                id.push_back(i);
            for (int i = 1; i &amp;lt;= n; ++i)
                if (sa[i] &amp;gt; w)
                    id.push_back(sa[i] - w);
            std::vector&amp;lt;int&amp;gt; c(m + 1);
            for (int i = 1; i &amp;lt;= n; ++i)
                ++c[rk[i]];
            std::partial_sum(c.begin(), c.end(), c.begin());
            for (int i = n; i; --i)
                sa[c[rk[id[i]]]--] = id[i];
            p = 0;
            std::copy(rk.begin(), rk.end(), la.begin());
            for (int i = 1; i &amp;lt;= n; ++i)
                if (la[sa[i]] == la[sa[i - 1]] &amp;amp;&amp;amp; la[sa[i] + w] == la[sa[i - 1] + w])
                    rk[sa[i]] = p;
                else
                    rk[sa[i]] = ++p;
            if (p == n)
                break;
        &amp;#125;
        for (int i = 1, to = 0; i &amp;lt;= n; ++i)
            if (rk[i]) &amp;#123;
                for (to = std::max(to - 1, 0); s[i + to] == s[sa[rk[i] - 1] + to]; ++to);
                h[rk[i]] = to;
            &amp;#125;
        for (int i = 1; i &amp;lt;= n; ++i)
            st[0][i] = h[i];
        for (int j = 1; (1 &amp;lt;&amp;lt; j) &amp;lt;= n; ++j)
            for (int i = 1; i + (1 &amp;lt;&amp;lt; j) - 1 &amp;lt;= n; ++i)
                st[j][i] = std::min(st[j - 1][i], st[j - 1][i + (1 &amp;lt;&amp;lt; (j - 1))]);
        rk.emplace_back();
        return;
    &amp;#125;
private:
    int ask(int l, int r) &amp;#123;
        // fprintf(stderr, &amp;quot;l = %d, r = %d\n&amp;quot;, l, r);
        int k = std::__lg(r - l + 1);
        return std::min(st[k][l], st[k][r - (1 &amp;lt;&amp;lt; k) + 1]);
    &amp;#125;
public:
    int lcp(int l, int r) &amp;#123;
        return ask(std::min(rk[l], rk[r]) + 1, std::max(rk[l], rk[r]));
    &amp;#125;
&amp;#125;;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#endif
    std::string s;
    std::cin &amp;gt;&amp;gt; s;
    int n = (int)s.length();
    s = &amp;quot;#&amp;quot; + s;
    SA p(n, s);
    std::reverse(s.begin() + 1, s.end());
    SA q(n, s);
    std::reverse(s.begin() + 1, s.end());
    long long res1 = 0ll, res2 = 0ll;
    for (int len = 1; len &amp;lt;= n; ++len)
        for (int i = len, j = 2 * len, k = 3 * len; k &amp;lt;= n; i += len, j += len, k += len) &amp;#123;
            int lcp = std::min(p.lcp(i, j), p.lcp(j, k)), lcs = std::min(&amp;#123; len - 1, q.lcp(n - i + 2, n - j + 2), q.lcp(n - j + 2, n - k + 2) &amp;#125;);
            if (std::min(len, lcp) + lcs &amp;gt;= len) &amp;#123;
                // printf(&amp;quot;(%d, %d, %d), %d, %d, %d\n&amp;quot;, i, j, k, lcs, lcp, len);
                int t = (lcp &amp;lt;= len);
                res1 += t, res2 += std::min(len, lcp) + lcs - len + 1 - t;
            &amp;#125;
            // else
            //     printf(&amp;quot;# (%d, %d, %d), %d, %d, %d\n&amp;quot;, i, j, k, lcs, lcp, len);
        &amp;#125;
    std::cout &amp;lt;&amp;lt; res1 &amp;lt;&amp;lt; &amp;#39; &amp;#39; &amp;lt;&amp;lt; res2 &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h4 id=&#34;eg3.-repeats&#34;&gt;eg3. repeats&lt;/h4&gt;
&lt;p&gt;&lt;a href=&#34;https://www.spoj.com/problems/REPEATS/&#34; class=&#34;uri&#34;&gt;https://www.spoj.com/problems/REPEATS/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;重复次数最多，只需经过标记点最多。显然经过标记点的数量就是该字符串长除以 &lt;span class=&#34;math inline&#34;&gt;\(len\)&lt;/span&gt; 向下取整就可以得到重复次数减 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt; 的值。&lt;/p&gt;
&lt;p&gt;选择两个连续标记点，对于 lcp 和 lcs（显然此时不需要对 &lt;span class=&#34;math inline&#34;&gt;\(len\)&lt;/span&gt; 取 &lt;span class=&#34;math inline&#34;&gt;\(\min\)&lt;/span&gt;），计算 &lt;span class=&#34;math inline&#34;&gt;\(\dfrac {\text{lcp}+\text{lcs}}{len}+1\)&lt;/span&gt; 取最大即可。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
class SA &amp;#123;
public:
    std::vector&amp;lt;int&amp;gt; sa, rk, h;
    std::vector&amp;lt;std::vector&amp;lt;int&amp;gt;  &amp;gt; st;
    SA(int n, std::string s): sa(n + 1), rk(n + 2), h(n + 1), st(20, std::vector&amp;lt;int&amp;gt; (n + 1)) &amp;#123;
        std::vector&amp;lt;int&amp;gt; la(n + 2);
        std::copy(s.begin(), s.end(), rk.begin());
        int m = 128;
        &amp;#123;
            std::vector&amp;lt;int&amp;gt; c(m + 1);
            for (int i = 1; i &amp;lt;= n; ++i)
                ++c[rk[i]];
            std::partial_sum(c.begin(), c.end(), c.begin());
            for (int i = n; i; --i)
                sa[c[rk[i]]--] = i;
        &amp;#125;
        for (int w = 1, p; ; w &amp;lt;&amp;lt;= 1, m = p) &amp;#123;
            std::vector&amp;lt;int&amp;gt; id(1);
            for (int i = n - w + 1; i &amp;lt;= n; ++i)
                id.push_back(i);
            for (int i = 1; i &amp;lt;= n; ++i)
                if (sa[i] &amp;gt; w)
                    id.push_back(sa[i] - w);
            std::vector&amp;lt;int&amp;gt; c(m + 1);
            for (int i = 1; i &amp;lt;= n; ++i)
                ++c[rk[i]];
            std::partial_sum(c.begin(), c.end(), c.begin());
            for (int i = n; i; --i)
                sa[c[rk[id[i]]]--] = id[i];
            p = 0;
            std::copy(rk.begin(), rk.end(), la.begin());
            for (int i = 1; i &amp;lt;= n; ++i)
                if (la[sa[i]] == la[sa[i - 1]] &amp;amp;&amp;amp; la[sa[i] + w] == la[sa[i - 1] + w])
                    rk[sa[i]] = p;
                else
                    rk[sa[i]] = ++p;
            if (p == n)
                break;
        &amp;#125;
        for (int i = 1, to = 0; i &amp;lt;= n; ++i)
            if (rk[i]) &amp;#123;
                for (to = std::max(to - 1, 0); s[i + to] == s[sa[rk[i] - 1] + to]; ++to);
                h[rk[i]] = to;
            &amp;#125;
        for (int i = 1; i &amp;lt;= n; ++i)
            st[0][i] = h[i];
        for (int j = 1; (1 &amp;lt;&amp;lt; j) &amp;lt;= n; ++j)
            for (int i = 1; i + (1 &amp;lt;&amp;lt; j) - 1 &amp;lt;= n; ++i)
                st[j][i] = std::min(st[j - 1][i], st[j - 1][i + (1 &amp;lt;&amp;lt; (j - 1))]);
        rk.emplace_back();
        return;
    &amp;#125;
private:
    int ask(int l, int r) &amp;#123;
        // fprintf(stderr, &amp;quot;l = %d, r = %d\n&amp;quot;, l, r);
        int k = std::__lg(r - l + 1);
        return std::min(st[k][l], st[k][r - (1 &amp;lt;&amp;lt; k) + 1]);
    &amp;#125;
public:
    int lcp(int l, int r) &amp;#123;
        return ask(std::min(rk[l], rk[r]) + 1, std::max(rk[l], rk[r]));
    &amp;#125;
&amp;#125;;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#endif
    int T;
    for (std::cin &amp;gt;&amp;gt; T; T--; ) &amp;#123;
        int n;
        std::cin &amp;gt;&amp;gt; n;
        std::string s = &amp;quot;#&amp;quot;;
        for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
            char t;
            std::cin &amp;gt;&amp;gt; t;
            s.push_back(t);
        &amp;#125;
        SA p(n, s);
        std::reverse(s.begin() + 1, s.end());
        SA q(n, s);
        int res = 0;
        for (int len = 1; len &amp;lt;= n; ++len)
            for (int i = len, j = 2 * len; j &amp;lt;= n; i += len, j += len) &amp;#123;
                int lcp = p.lcp(i, j), lcs = q.lcp(n - i + 2, n - j + 2);
                if (lcp + lcs &amp;gt;= len)
                    res = std::max(res, (lcp + lcs) / len + 1);
            &amp;#125;
        std::cout &amp;lt;&amp;lt; res &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    &amp;#125;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;结合并查集&#34;&gt;结合并查集&lt;/h3&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;结合单调栈&#34;&gt;结合单调栈&lt;/h3&gt;
 ]]></description>
        </item>
    </channel>
</rss>
