{
    "version": "https://jsonfeed.org/version/1",
    "title": "null • All posts by \"sa\" tag",
    "description": "",
    "home_page_url": "https://xsc062.netlify.app",
    "items": [
        {
            "id": "https://xsc062.netlify.app/20250202/",
            "url": "https://xsc062.netlify.app/20250202/",
            "title": "学习笔记：后缀数组",
            "date_published": "2025-02-02T00:27:44.000Z",
            "content_html": "<p>非常后知后觉地意识到 SA(Suffix Array) 和 SAM(Suffix Automaton) 的 A 不是同一个 A <img src=\"/em/fad.gif\" /></p>\n<span id=\"more\"></span>\n<hr />\n<h2 id=\"定义\">定义</h2>\n<p>显而易见一个长度为 <span class=\"math inline\">\\(n\\)</span> 的字符串中有 <span class=\"math inline\">\\(n\\)</span> 个长度分别为 <span class=\"math inline\">\\(1\\sim n\\)</span> 的后缀，如果我们对其按字典序排序，分别存储下排名 <span class=\"math inline\">\\(i\\)</span> 的后缀 <span class=\"math inline\">\\(sa_i\\)</span> 和每个后缀 <span class=\"math inline\">\\(i\\)</span> 的排名 <span class=\"math inline\">\\(rk_i\\)</span>。虽然看着挺没头没尾的，但是很有用。</p>\n<h2 id=\"求解\">求解</h2>\n<h3 id=\"哈希-排序\">哈希 + 排序</h3>\n<p>直接把所有后缀拿来排序的话，字符串比较是 <span class=\"math inline\">\\(O(n)\\)</span> 的。如果我们用哈希 + 二分优化比较过程，就可以把整个排序优化到 <span class=\"math inline\">\\(O(n\\log^2 n)\\)</span>。</p>\n<h3 id=\"倍增\">倍增</h3>\n<p>先对所有后缀按 <strong>第一个字符</strong> 排序，记排序后排名序列为 <span class=\"math inline\">\\(a\\)</span>。</p>\n<p>那么怎么按 <strong>前两个字符</strong> 排序呢？对于第 <span class=\"math inline\">\\(i\\)</span> 组字符，我们用 <span class=\"math inline\">\\((a_i,a_{i+1})\\)</span> 双关键字排序即可。记此时排名序列为 <span class=\"math inline\">\\(b\\)</span>，那么如果需要按照前四个字符排序，用 <span class=\"math inline\">\\((b_i,b_{i+2})\\)</span> 进行双关键字排序即可。总共需要进行 <span class=\"math inline\">\\(\\log n\\)</span> 次排序。复杂度为 <span class=\"math inline\">\\(O(n\\log^2n)\\)</span>。</p>\n<p>此时我们注意到排名数组的值域为 <span class=\"math inline\">\\(n\\)</span>，那么我们用桶排就能少一个 <span class=\"math inline\">\\(\\log\\)</span>。</p>\n<h2 id=\"实现\">实现</h2>\n<p>哈希很好实现，这里就按下不表，主要讲解倍增法的实现。</p>\n<p>描述起来很简单，实现起来很要命。OI wiki 上的实现算是相对好理解的：</p>\n<p>首先了解双关键字桶排的方法，首先用单关键字桶排完成对 <strong>第二关键字</strong> 的排序；对于第一关键字，令桶 <span class=\"math inline\">\\(i\\)</span> 记录前 <span class=\"math inline\">\\(i\\)</span> 个元素的数量；遍历排序后的第二关键字数组，将元素放到桶中记录数值对应的下标中，并将桶中数值 <span class=\"math inline\">\\(-1\\)</span>。实际上桶 <span class=\"math inline\">\\(c\\)</span> 充当计算下标范围的作用，<span class=\"math inline\">\\((c_{i-1},c_i]\\)</span> 即为 <span class=\"math inline\">\\(i\\)</span> 分布的范围。</p>\n<p>显然，当且仅当排名种类为 <span class=\"math inline\">\\(n\\)</span>，即没有并列排名时，排序完成。设本轮区间长度为 <span class=\"math inline\">\\(w\\)</span>，对于一轮操作：</p>\n<ol type=\"1\">\n<li>计算每个区间按后半段 <span class=\"math inline\">\\(\\frac w2\\)</span> 长度字符排序的结果：<span class=\"math inline\">\\((n-w,n]\\)</span> 开头的区间后半段均为空，直接放在序列首端；接着按照上一轮 <span class=\"math inline\">\\(sa\\)</span> 结果，把能够作为后半段的元素依次放入。</li>\n<li>依照上一轮的 <span class=\"math inline\">\\(rk\\)</span> 作为前半段排名，进行双关键字桶排。</li>\n<li>依照 <span class=\"math inline\">\\(sa\\)</span> 和第二关键字（处理并列），求出 <span class=\"math inline\">\\(rk\\)</span>。</li>\n</ol>\n<details>\n<pre class=\"cpp\"><code>std::vector&lt;int&gt; la(n + 2);\nstd::copy(s.begin(), s.end(), rk.begin());\nint m = 128;\n&#123;\n    std::vector&lt;int&gt; c(m + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        ++c[rk[i]];\n    std::partial_sum(c.begin(), c.end(), c.begin());\n    for (int i = n; i; --i)\n        sa[c[rk[i]]--] = i;\n&#125; \nfor (int w = 1, p; ; w &lt;&lt;= 1, m = p) &#123;\n    std::vector&lt;int&gt; id(1);\n    for (int i = n - w + 1; i &lt;= n; ++i)\n        id.push_back(i);\n    for (int i = 1; i &lt;= n; ++i)\n        if (sa[i] &gt; w)\n            id.push_back(sa[i] - w);\n    std::vector&lt;int&gt; c(m + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        ++c[rk[i]];\n    std::partial_sum(c.begin(), c.end(), c.begin());\n    for (int i = n; i; --i)\n        sa[c[rk[id[i]]]--] = id[i];\n    p = 0;\n    std::copy(rk.begin(), rk.end(), la.begin());\n    for (int i = 1; i &lt;= n; ++i)\n        if (la[sa[i]] == la[sa[i - 1]] &amp;&amp; la[sa[i] + w] == la[sa[i - 1] + w])\n            rk[sa[i]] = p;\n        else\n            rk[sa[i]] = ++p;\n    if (p == n)\n        break;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"纯-sa-的应用\">纯 SA 的应用</h2>\n<h3 id=\"最小表示法\">最小表示法</h3>\n<p>模板：<a href=\"https://www.luogu.com.cn/problem/P1368\" class=\"uri\">https://www.luogu.com.cn/problem/P1368</a>。</p>\n<p>对于循环位移相关要求，首先考虑将字符串重复一遍。</p>\n<p>在 <span class=\"math inline\">\\(ss\\)</span> 中找到排名第一个 <span class=\"math inline\">\\(sa_i\\le n\\)</span> 即为答案。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;int&gt; s(2 * n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; s[i], s[n + i] = s[i];\n    std::vector&lt;int&gt; sa(2 * n + 1), rk(s);\n    &#123;\n        int m = 29;\n        &#123;\n            std::vector&lt;int&gt; c(m + 1);\n            for (int i = 1; i &lt;= 2 * n; ++i)\n                ++c[rk[i]];\n            std::partial_sum(c.begin(), c.end(), c.begin());\n            for (int i = 2 * n; i; --i)\n                sa[c[rk[i]]--] = i;\n        &#125;\n        for (int w = 1, p; ; w &lt;&lt;= 1, m = p) &#123;\n            std::vector&lt;int&gt; id(1);\n            for (int i = 2 * n - w + 1; i &lt;= 2 * n; ++i)\n                id.push_back(i);\n            for (int i = 1; i &lt;= 2 * n; ++i)\n                if (sa[i] &gt; w)\n                    id.push_back(sa[i] - w);\n            std::vector&lt;int&gt; c(m + 1);\n            for (int i = 1; i &lt;= 2 * n; ++i)\n                ++c[rk[i]];\n            std::partial_sum(c.begin(), c.end(), c.begin());\n            for (int i = 2 * n; i; --i)\n                sa[c[rk[id[i]]]--] = id[i];\n            auto la(rk);\n            p = 0;\n            for (int i = 1; i &lt;= 2 * n; ++i)\n                if (i != 1 &amp;&amp; la[sa[i]] == la[sa[i - 1]] &amp;&amp; la[sa[i] + w] == la[sa[i - 1] + w])\n                    rk[sa[i]] = p;\n                else\n                    rk[sa[i]] = ++p;\n            if (p == 2 * n)\n                break;\n        &#125;\n    &#125;\n    for (int i = 1; i &lt;= 2 * n; ++i)\n        if (sa[i] &lt;= n) &#123;\n            for (int j = sa[i]; j &lt; n + sa[i]; ++j)\n                std::cout &lt;&lt; s[j] &lt;&lt; &#39; &#39;;\n            std::cout &lt;&lt; &#39;\\n&#39;;\n            break;\n        &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"字符串匹配\">字符串匹配</h3>\n<p>二分，复杂度 <span class=\"math inline\">\\(O(|S|\\log |T|)\\)</span>。求出现次数则二分左右边界。</p>\n<p>太麻烦了且没有实际应用价值，代码略。</p>\n<hr />\n<h2 id=\"height-数组\">height 数组</h2>\n<p>定义 <span class=\"math inline\">\\(h_i=\\text {lcp}(sa_i, sa_i-1)\\)</span>，特别地，<span class=\"math inline\">\\(h_1=0\\)</span>。</p>\n<blockquote>\n<p>有引理：<span class=\"math inline\">\\(h_{rk_i}\\ge h_{rk_{i-1}}-1\\)</span>。</p>\n</blockquote>\n<p>假设已经求出 <span class=\"math inline\">\\(h_{rk_{i-1}}\\)</span>，那么可以从 <span class=\"math inline\">\\(h_{rk_{i-1}}-1\\)</span> 出发暴力看下一个字符是否相等得到答案。那么我们会发现从前往后 <span class=\"math inline\">\\(h\\)</span> 值每次最多 <span class=\"math inline\">\\(-1\\)</span>，所以复杂度摊下来是 <span class=\"math inline\">\\(O(n)\\)</span> 的。</p>\n<p><mark>记住记住一定是 <span class=\"math inline\">\\(rk_{i-1}\\)</span> 而不是下意识的 <span class=\"math inline\">\\(rk_i-1\\)</span>！！！</mark>所以为了保证求解顺序循环枚举的一定是下标而非排名。但是注意定义却是和 <span class=\"math inline\">\\(rk_i-1\\)</span> 的 lcp！！！所以求 height 的写法是相对固定的，不能觉得好像是对的就随便乱改。</p>\n<hr />\n<h2 id=\"height-数组的应用\">height 数组的应用</h2>\n<p>相当于背板子，因为应用太多且形式大多固定。</p>\n<h3 id=\"求任意两个后缀的-lcp\">求任意两个后缀的 lcp</h3>\n<p>易得 <span class=\"math inline\">\\(\\text{lcp}(sa_i, sa_j)=\\min\\{h_{i+1}, \\cdots, h_j\\}\\)</span>。<strong>故应将一些复杂 lcp 问题的解决方式和 RMQ 联系起来</strong>。</p>\n<hr />\n<h3 id=\"子串大小关系\">子串大小关系</h3>\n<p>即比较 <span class=\"math inline\">\\(S_{l_1, r_1}\\)</span> 和 <span class=\"math inline\">\\(S_{l_2, r_2}\\)</span> 的大小关系。比较导致 lcp 不能继续延伸的元素大小即可。</p>\n<hr />\n<h3 id=\"本质不同子串数量\">本质不同子串数量</h3>\n<p><strong>子串等价于「后缀的前缀」</strong>。按顺序枚举每个后缀，减去和已枚举的所有后缀的 lcp 即可。鉴于 <span class=\"math inline\">\\(\\min\\{h_{j+1},\\cdots,h_i\\}\\)</span> 单调不减，直接减去 <span class=\"math inline\">\\(h_i\\)</span> 即可。</p>\n<p>最后答案即为 <span class=\"math inline\">\\(\\frac {n(n-1)}2 - \\sum\\limits_{i=2}^nh_i\\)</span>。</p>\n<hr />\n<h3 id=\"至少出现-k-次子串的最大长度\">至少出现 <span class=\"math inline\">\\(k\\)</span> 次子串的最大长度</h3>\n<p>模板：<a href=\"https://www.luogu.com.cn/problem/P2852\" class=\"uri\">https://www.luogu.com.cn/problem/P2852</a>。</p>\n<p>出现 <span class=\"math inline\">\\(k\\)</span> 次 <span class=\"math inline\">\\(\\iff\\)</span> 在后缀数组中连续出现 <span class=\"math inline\">\\(k\\)</span> 次 <span class=\"math inline\">\\(\\iff\\)</span> 是任意连续 <span class=\"math inline\">\\(k-1\\)</span> 个 <span class=\"math inline\">\\(h\\)</span> 的最小值，需要最大化该最小值，考虑滑动窗口。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;P2852_7.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, k;\n    std::cin &gt;&gt; n &gt;&gt; k, --k;\n    std::vector&lt;int&gt; s(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; s[i];\n    std::vector&lt;int&gt; sa(n + 1), rk(s), h(n + 1);\n    &#123;\n        int m = 1000001;\n        &#123;\n            std::vector&lt;int&gt; c(m + 1);\n            for (int i = 1; i &lt;= n; ++i)\n                ++c[rk[i]];\n            std::partial_sum(c.begin(), c.end(), c.begin());\n            for (int i = n; i; --i)\n                sa[c[rk[i]]--] = i;\n        &#125;\n        for (int w = 1, p; ; w &lt;&lt;= 1, m = p) &#123;\n            std::vector&lt;int&gt; id(1);\n            for (int i = n - w + 1; i &lt;= n; ++i)\n                id.push_back(i);\n            for (int i = 1; i &lt;= n; ++i)\n                if (sa[i] &gt; w)\n                    id.push_back(sa[i] - w);\n            std::vector&lt;int&gt; c(m + 1);\n            for (int i = 1; i &lt;= n; ++i)\n                ++c[rk[i]];\n            std::partial_sum(c.begin(), c.end(), c.begin());\n            for (int i = n; i; --i)\n                sa[c[rk[id[i]]]--] = id[i];\n            auto la(rk);\n            p = 0;\n            for (int i = 1; i &lt;= n; ++i)\n                if (i != 1 &amp;&amp; la[sa[i]] == la[sa[i - 1]] &amp;&amp; la[sa[i] + w] == la[sa[i - 1] + w])\n                    rk[sa[i]] = p;\n                else\n                    rk[sa[i]] = ++p;\n            if (p == n)\n                break;\n        &#125;\n        for (int i = 1, to = 0; i &lt;= n; ++i)\n            if (rk[i]) &#123;\n                for (to = std::max(to - 1, 0); s[i + to] == s[sa[rk[i] - 1] + to]; ++to);\n                h[rk[i]] = to;\n            &#125;\n    &#125;\n    std::vector&lt;int&gt; q(n + 1);\n    int res = 0;\n    for (int i = 1, l = 1, r = 0; i &lt;= n; ++i) &#123;\n        // printf(&quot;%d\\n&quot;, h[i]);\n        for (; l &lt;= r &amp;&amp; i - q[l] &gt;= k; ++l);\n        for (; l &lt;= r &amp;&amp; h[i] &lt;= h[q[r]]; --r);\n        q[++r] = i;\n        if (i &gt;= k)\n            res = std::max(res, h[q[l]]);\n    &#125;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"最长不重叠多次出现子串\">最长不重叠多次出现子串</h3>\n<p><del>bb：定式太多太杂以至于让人怀疑某些定式是否存在应用场景</del> <img src=\"/em/kt.gif\" /></p>\n<p>发现满足单调性，二分子串长度 <span class=\"math inline\">\\(len\\)</span>，那么显然 <span class=\"math inline\">\\(\\text {lcp}\\ge len\\)</span>；将 <span class=\"math inline\">\\(h\\)</span> 划分为连续 <span class=\"math inline\">\\(\\ge len\\)</span> 的段，在每段内找到下标极差与 <span class=\"math inline\">\\(len\\)</span> 比较即可。</p>\n<p>也可以用于判定是否存在不重叠多次出现子串。</p>\n<p>甚至可以考虑限制至少出现次数为 <span class=\"math inline\">\\(k\\)</span>，那大概多个 <span class=\"math inline\">\\(\\log\\)</span>，看看一段里有没有 <span class=\"math inline\">\\(\\ge k\\)</span> 个相互相差 <span class=\"math inline\">\\(\\ge len\\)</span> 的。排序贪心求解。</p>\n<p>那么上面的至少出现 <span class=\"math inline\">\\(k\\)</span> 次子串也可以用这个方法来解，但是多个 <span class=\"math inline\">\\(\\log\\)</span> 没必要。</p>\n<p>也可以限制多次出现但长度至少为 <span class=\"math inline\">\\(len\\)</span>，那甚至少了二分的 <span class=\"math inline\">\\(\\log\\)</span>，直接跑一遍 check 即可。</p>\n<p><del>？？？到底为什么会有这么多奇怪的定式，是因为真的有题这么出吗？？？</del> <img src=\"/em/oh.gif\" /></p>\n<hr />\n<h3 id=\"最长公共子串问题\">最长公共子串问题</h3>\n<p>求 <span class=\"math inline\">\\(S\\)</span> 和 <span class=\"math inline\">\\(T\\)</span> 的最长公共子串（注意不是 LCS）。设 <span class=\"math inline\">\\(S\\)</span> 长为 <span class=\"math inline\">\\(n\\)</span>，<span class=\"math inline\">\\(T\\)</span> 长为 <span class=\"math inline\">\\(m\\)</span>，那么将 <span class=\"math inline\">\\(S\\)</span> 与 <span class=\"math inline\">\\(T\\)</span> 拼接，答案就是 <span class=\"math inline\">\\(\\max \\{\\text{lcp}(i,j)\\},i\\le n&lt;j\\)</span>。</p>\n<p>但这里不直接枚举 <span class=\"math inline\">\\(i\\)</span> 和 <span class=\"math inline\">\\(j\\)</span>，还是照例先从 <span class=\"math inline\">\\(h\\)</span> 下手再卡条件，若 <span class=\"math inline\">\\(sa_{i-1}\\le n&lt;sa_{i}\\)</span>（或者反过来），就可以用 <span class=\"math inline\">\\(h_i\\)</span> 更新答案。容易证明这样总可以找到最大值。</p>\n<h4 id=\"eg1.-找相同字符\">eg1. 找相同字符</h4>\n<p><a href=\"https://www.luogu.com.cn/problem/P3181\" class=\"uri\">https://www.luogu.com.cn/problem/P3181</a></p>\n<p>要求方案数，那么答案为 <span class=\"math inline\">\\(\\text{lcp}(i,j),i\\le n&lt;j\\)</span>。（我已经帮你们试过了容斥比直接做更麻烦），考虑用单调栈维护左 / 右侧区间 lcp 求解右 / 左侧答案。关于单调栈的描述可见 <a href=\"#结合单调栈\">本页后部内容</a>。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, n1;\n    std::string s, t;\n    std::cin &gt;&gt; s &gt;&gt; t;\n    n = (int)s.length(), n1 = n + (int)t.length() + 1;\n    s = &quot;#&quot; + s + &quot;$&quot; + t;\n    std::vector&lt;int&gt; sa(n1 + 1), rk(n1 + 1), h(n1 + 1);\n    &#123;\n        std::copy(s.begin() + 1, s.end(), rk.begin() + 1);\n        int m = 128;\n        &#123;\n            std::vector&lt;int&gt; c(m + 1);\n            for (int i = 1; i &lt;= n1; ++i)\n                ++c[rk[i]];\n            std::partial_sum(c.begin(), c.end(), c.begin());\n            for (int i = n1; i; --i)\n                sa[c[rk[i]]--] = i;\n        &#125;\n        for (int w = 1, p; ; w &lt;&lt;= 1, m = p) &#123;\n            std::vector&lt;int&gt; id(w + 1);\n            std::iota(id.begin() + 1, id.end(), n1 - w + 1);\n            for (int i = 1; i &lt;= n1; ++i)\n                if (sa[i] &gt; w)\n                    id.push_back(sa[i] - w);\n            std::vector&lt;int&gt; c(m + 1);\n            for (int i = 1; i &lt;= n1; ++i)\n                ++c[rk[i]];\n            std::partial_sum(c.begin(), c.end(), c.begin());\n            for (int i = n1; i; --i)\n                sa[c[rk[id[i]]]--] = id[i];\n            p = 0;\n            auto la(rk);\n            for (int i = 1; i &lt;= n1; ++i)\n                if (i != 1 &amp;&amp; la[sa[i]] == la[sa[i - 1]] &amp;&amp; la[sa[i] + w] == la[sa[i - 1] + w])\n                    rk[sa[i]] = p;\n                else\n                    rk[sa[i]] = ++p;\n            if (p == n1)\n                break;\n        &#125;\n        for (int i = 1, to = 0; i &lt;= n1; ++i) &#123;\n            for (to = std::max(to - 1, 0); s[i + to] == s[sa[rk[i] - 1] + to]; ++to);\n            h[rk[i]] = to;\n        &#125;\n    &#125;\n    std::vector&lt;std::pair&lt;int, long long&gt; &gt; q1, q2;\n    std::vector&lt;int&gt; tot1(n1 + 1), tot2(n1 + 1);\n    for (int i = 1; i &lt;= n1; ++i) &#123;\n        tot1[i] = tot1[i - 1] + (sa[i] &lt;= n);\n        tot2[i] = tot2[i - 1] + (sa[i] &gt; n + 1);\n    &#125;\n    long long res = 0ll;\n    q1.emplace_back(1, 0ll), q2.emplace_back(1, 0ll);\n    for (int i = 1; i &lt;= n1; ++i) &#123;\n        for (; !q1.empty() &amp;&amp; h[i] &lt; h[q1.back().first]; q1.pop_back());\n        q1.emplace_back(i, (tot1[i - 1] - tot1[q1.back().first - 1]) * h[i] + q1.back().second);\n        if (sa[i] &gt; n + 1)\n            res += q1.back().second;\n        for (; !q2.empty() &amp;&amp; h[i] &lt; h[q2.back().first]; q2.pop_back());\n        q2.emplace_back(i, (tot2[i - 1] - tot2[q2.back().first - 1]) * h[i] + q2.back().second);\n        if (sa[i] &lt;= n)\n            res += q2.back().second;\n    &#125;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<h4 id=\"eg2.-公共串\">eg2. 公共串</h4>\n<p><a href=\"https://www.luogu.com.cn/problem/P5546\" class=\"uri\">https://www.luogu.com.cn/problem/P5546</a></p>\n<p>要求多串最长公共子串，仍然考虑将多个串拼在一起。仿照前面二分的方式处理，问题转化为找到最长的 <span class=\"math inline\">\\(len\\)</span>，使得存在一段最小值 <span class=\"math inline\">\\(\\ge len\\)</span> 的区间，其覆盖了 <span class=\"math inline\">\\(n\\)</span> 段串。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, l = 0, r = 0;\n    std::cin &gt;&gt; n;\n    std::string s;\n    std::vector&lt;std::pair&lt;int, int&gt; &gt; lim(n + 1);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::string t;\n        std::cin &gt;&gt; t;\n        lim[i] = &#123; (int)s.length() + 1, s.length() + t.length() &#125;;\n        s += &quot;#&quot; + t;\n        r = std::max(r, (int)t.length());\n        // printf(&quot;[%d, %d]\\n&quot;, lim[i].first, lim[i].second);\n    &#125;\n    int n1 = lim.back().second;\n    std::vector&lt;int&gt; sa(n1 + 1), rk(n1 + 1), h(n1 + 1);\n    &#123;\n        std::copy(s.begin() + 1, s.end(), rk.begin() + 1);\n        int m = 128;\n        &#123;\n            std::vector&lt;int&gt; c(m + 1);\n            for (int i = 1; i &lt;= n1; ++i)\n                ++c[rk[i]];\n            std::partial_sum(c.begin(), c.end(), c.begin());\n            for (int i = n1; i; --i)\n                sa[c[rk[i]]--] = i;\n        &#125;\n        for (int w = 1, p; ; w &lt;&lt;= 1, m = p) &#123;\n            std::vector&lt;int&gt; id(w + 1);\n            std::iota(id.begin() + 1, id.end(), n1 - w + 1);\n            for (int i = 1; i &lt;= n1; ++i)\n                if (sa[i] &gt; w)\n                    id.push_back(sa[i] - w);\n            std::vector&lt;int&gt; c(m + 1);\n            for (int i = 1; i &lt;= n1; ++i)\n                ++c[rk[i]];\n            std::partial_sum(c.begin(), c.end(), c.begin());\n            for (int i = n1; i; --i)\n                sa[c[rk[id[i]]]--] = id[i];\n            p = 0;\n            auto la(rk);\n            for (int i = 1; i &lt;= n1; ++i)\n                if (i != 1 &amp;&amp; la[sa[i]] == la[sa[i - 1]] &amp;&amp; la[sa[i] + w] == la[sa[i - 1] + w])\n                    rk[sa[i]] = p;\n                else\n                    rk[sa[i]] = ++p;\n            if (p == n1)\n                break;\n        &#125;\n        for (int i = 1, to = 0; i &lt;= n1; ++i) &#123;\n            for (to = std::max(to - 1, 0); s[i + to] == s[sa[rk[i] - 1] + to]; ++to);\n            h[rk[i]] = to;\n        &#125;\n    &#125;\n    // for (int i = 1; i &lt;= n1; ++i)\n    //     printf(&quot;h[%d] = %d\\n&quot;, sa[i], h[i]);\n    int res = 0;\n    auto check = [&amp;](int len) &#123;\n        // printf(&quot;check %d: \\n&quot;, len);\n        std::vector&lt;int&gt; cnt(n + 1);\n        for (int i = 1; i &lt;= n1; ++i) &#123;\n            if (h[i] &lt; len) &#123;\n                if (*std::min_element(cnt.begin() + 1, cnt.end()))\n                    return 1;\n                cnt.assign(n + 1, 0);\n            &#125;\n            else\n                for (int j = 1; j &lt;= n; ++j) &#123;\n                    if (lim[j].first &lt;= sa[i - 1] &amp;&amp; sa[i - 1] &lt;= lim[j].second)\n                        cnt[j] = 1;\n                    if (lim[j].first &lt;= sa[i] &amp;&amp; sa[i] &lt;= lim[j].second)\n                        cnt[j] = 1;\n                &#125;\n        &#125;\n        // printf(&quot;\\n%d\\n&quot;, *std::min_element(cnt.begin() + 1, cnt.end()));\n        return *std::min_element(cnt.begin() + 1, cnt.end());\n    &#125;;\n    for (int mid; l &lt;= r; ) &#123;\n        mid = (l + r) &gt;&gt; 1;\n        if (check(mid))\n            l = mid + 1, res = mid;\n        else\n            r = mid - 1;\n    &#125;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<p>但是看了题解发现居然还有线性做法（当然不看建 SA 的 <span class=\"math inline\">\\(\\log\\)</span>），对于覆盖全部 <span class=\"math inline\">\\(n\\)</span> 段串找区间最小值，发现需要最小化区间，考虑双指针。</p>\n<p>区间最小值用单调队列求解，细想可能会觉得不太对劲，但是容易证明答案不大于队首且不小于最大队首，所以最大队首就是答案。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, l = 0, r = 0;\n    std::cin &gt;&gt; n;\n    std::string s;\n    std::vector&lt;std::pair&lt;int, int&gt; &gt; lim(n + 1);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::string t;\n        std::cin &gt;&gt; t;\n        lim[i] = &#123; (int)s.length() + 1, s.length() + t.length() &#125;;\n        s += (char)(&#39;A&#39; + i - 1) + t;\n        r = std::max(r, (int)t.length());\n    &#125;\n    int n1 = lim.back().second;\n    std::vector&lt;int&gt; sa(n1 + 1), rk(n1 + 1), h(n1 + 1);\n    &#123;\n        std::copy(s.begin() + 1, s.end(), rk.begin() + 1);\n        int m = 128;\n        &#123;\n            std::vector&lt;int&gt; c(m + 1);\n            for (int i = 1; i &lt;= n1; ++i)\n                ++c[rk[i]];\n            std::partial_sum(c.begin(), c.end(), c.begin());\n            for (int i = n1; i; --i)\n                sa[c[rk[i]]--] = i;\n        &#125;\n        for (int w = 1, p; ; w &lt;&lt;= 1, m = p) &#123;\n            std::vector&lt;int&gt; id(w + 1);\n            std::iota(id.begin() + 1, id.end(), n1 - w + 1);\n            for (int i = 1; i &lt;= n1; ++i)\n                if (sa[i] &gt; w)\n                    id.push_back(sa[i] - w);\n            std::vector&lt;int&gt; c(m + 1);\n            for (int i = 1; i &lt;= n1; ++i)\n                ++c[rk[i]];\n            std::partial_sum(c.begin(), c.end(), c.begin());\n            for (int i = n1; i; --i)\n                sa[c[rk[id[i]]]--] = id[i];\n            p = 0;\n            auto la(rk);\n            for (int i = 1; i &lt;= n1; ++i)\n                if (i != 1 &amp;&amp; la[sa[i]] == la[sa[i - 1]] &amp;&amp; la[sa[i] + w] == la[sa[i - 1] + w])\n                    rk[sa[i]] = p;\n                else\n                    rk[sa[i]] = ++p;\n            if (p == n1)\n                break;\n        &#125;\n        for (int i = 1, to = 0; i &lt;= n1; ++i) &#123;\n            for (to = std::max(to - 1, 0); s[i + to] == s[sa[rk[i] - 1] + to]; ++to);\n            h[rk[i]] = to;\n        &#125;\n    &#125;\n    int res = 0;\n    std::vector&lt;int&gt; q(n1 + 1), cnt(n + 1);\n    // for (int i = 1; i &lt;= n1; ++i)\n    //     printf(&quot;%d: %d\\n&quot;, sa[i], h[i]);\n    for (int l = 1, r = 0, ql = 1, qr = 0; l &lt;= n1; ++l) &#123;\n        for (; r &lt; n1 &amp;&amp; !*std::min_element(cnt.begin() + 1, cnt.end()); ) &#123;\n            ++r;\n            for (int i = 1; i &lt;= n; ++i)\n                if (lim[i].first &lt;= sa[r] &amp;&amp; sa[r] &lt;= lim[i].second) &#123;\n                    ++cnt[i];\n                    break;\n                &#125;\n            for (; ql &lt;= qr &amp;&amp; h[r] &lt;= h[q[qr]]; --qr);\n            q[++qr] = r;\n        &#125;\n        if (*std::min_element(cnt.begin() + 1, cnt.end())) &#123;\n            // printf(&quot;[%d, %d]: %d\\n&quot;, l, r, h[q[ql]]);\n            res = std::max(res, h[q[ql]]);\n        &#125;\n        for (; ql &lt;= qr &amp;&amp; q[ql] &lt;= l; ++ql);\n        if (l != 1) &#123;\n            for (int i = 1; i &lt;= n; ++i)\n                if (lim[i].first &lt;= sa[l - 1] &amp;&amp; sa[l - 1] &lt;= lim[i].second) &#123;\n                    --cnt[i];\n                    break;\n                &#125;\n        &#125;\n    &#125;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"texttt-aa-式子串处理\"><span class=\"math inline\">\\(\\texttt {AA}\\)</span> 式子串处理</h3>\n<p>即对于连续相同子串问题的处理，有一个定的思路，由例题分析。</p>\n<h4 id=\"eg1.-优秀的拆分\">eg1. 优秀的拆分</h4>\n<p><a href=\"https://www.luogu.com.cn/problem/P1117\" class=\"uri\">https://www.luogu.com.cn/problem/P1117</a></p>\n<p>还是从中间分开，按前后分别处理。这里有个 trick，我们枚举 <span class=\"math inline\">\\(\\texttt B\\)</span> 的长度 <span class=\"math inline\">\\(len\\)</span>，在 <span class=\"math inline\">\\(S\\)</span> 中每隔 <span class=\"math inline\">\\(len\\)</span> 打一个标记。那么显然，任意一个长度为 <span class=\"math inline\">\\(2\\times len\\)</span> 的子串都会经过恰好两个标记（充分的），这样就可以筛选出所有可能的串。</p>\n<p>我们枚举所有连续两个标记（总复杂度为调和级数），求它们对应后缀的 lcp 和对应前缀的 lcs（翻转求 SA 即可），如果二者加起来 <span class=\"math inline\">\\(\\ge len\\)</span> 就说明存在这样的 <span class=\"math inline\">\\(\\texttt {AA}\\)</span>。在 <span class=\"math inline\">\\(\\text {lcs}+\\text {lcp}\\)</span> 中任取 <span class=\"math inline\">\\(len\\)</span> 长度即为一对 <span class=\"math inline\">\\(\\texttt {AA}\\)</span>。用差分给可能的起点和终点区间加即可。</p>\n<p>小细节：lcp 和 lcs 均需要对 <span class=\"math inline\">\\(len\\)</span> 取 <span class=\"math inline\">\\(\\min\\)</span>，否则取到的串可能不会经过当前选中的两个标记。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nclass SA &#123;\npublic:\n    std::vector&lt;int&gt; sa, rk, h;\n    std::vector&lt;std::vector&lt;int&gt;  &gt; st;\n    SA(int n, std::string s): sa(n + 1), rk(n + 2), h(n + 1), st(20, std::vector&lt;int&gt; (n + 1)) &#123;\n        std::vector&lt;int&gt; la(n + 2);\n        std::copy(s.begin(), s.end(), rk.begin());\n        int m = 128;\n        &#123;\n            std::vector&lt;int&gt; c(m + 1);\n            for (int i = 1; i &lt;= n; ++i)\n                ++c[rk[i]];\n            std::partial_sum(c.begin(), c.end(), c.begin());\n            for (int i = n; i; --i)\n                sa[c[rk[i]]--] = i;\n        &#125;\n        for (int w = 1, p; ; w &lt;&lt;= 1, m = p) &#123;\n            std::vector&lt;int&gt; id(1);\n            for (int i = n - w + 1; i &lt;= n; ++i)\n                id.push_back(i);\n            for (int i = 1; i &lt;= n; ++i)\n                if (sa[i] &gt; w)\n                    id.push_back(sa[i] - w);\n            std::vector&lt;int&gt; c(m + 1);\n            for (int i = 1; i &lt;= n; ++i)\n                ++c[rk[i]];\n            std::partial_sum(c.begin(), c.end(), c.begin());\n            for (int i = n; i; --i)\n                sa[c[rk[id[i]]]--] = id[i];\n            p = 0;\n            std::copy(rk.begin(), rk.end(), la.begin());\n            for (int i = 1; i &lt;= n; ++i)\n                if (la[sa[i]] == la[sa[i - 1]] &amp;&amp; la[sa[i] + w] == la[sa[i - 1] + w])\n                    rk[sa[i]] = p;\n                else\n                    rk[sa[i]] = ++p;\n            if (p == n)\n                break;\n        &#125;\n        for (int i = 1, to = 0; i &lt;= n; ++i)\n            if (rk[i]) &#123;\n                for (to = std::max(to - 1, 0); s[i + to] == s[sa[rk[i] - 1] + to]; ++to);\n                h[rk[i]] = to;\n            &#125;\n        for (int i = 1; i &lt;= n; ++i)\n            st[0][i] = h[i];\n        for (int j = 1; (1 &lt;&lt; j) &lt;= n; ++j)\n            for (int i = 1; i + (1 &lt;&lt; j) - 1 &lt;= n; ++i)\n                st[j][i] = std::min(st[j - 1][i], st[j - 1][i + (1 &lt;&lt; (j - 1))]);\n        rk.emplace_back();\n        return;\n    &#125;\nprivate:\n    int ask(int l, int r) &#123;\n        // fprintf(stderr, &quot;l = %d, r = %d\\n&quot;, l, r);\n        int k = std::__lg(r - l + 1);\n        return std::min(st[k][l], st[k][r - (1 &lt;&lt; k) + 1]);\n    &#125;\npublic:\n    int lcp(int l, int r) &#123;\n        return ask(std::min(rk[l], rk[r]) + 1, std::max(rk[l], rk[r]));\n    &#125;\n&#125;;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int T;\n    for (std::cin &gt;&gt; T; T--; ) &#123;\n        std::string s;\n        std::cin &gt;&gt; s;\n        int n = (int)s.length();\n        s = &quot;#&quot; + s;\n        SA p(n, s);\n        std::reverse(s.begin() + 1, s.end());\n        SA q(n, s);\n        std::vector&lt;int&gt; f(n + 2), g(n + 2);\n        for (int len = 1; len &lt;= n / 2; ++len)\n            for (int i = len; i + len &lt;= n; i += len) &#123;\n                int l = i, r = i + len, lcp = std::min(len, p.lcp(l, r)), lcs = std::min(len - 1, q.lcp(n - l + 2, n - r + 2));\n                if (lcp + lcs &gt;= len) &#123;\n                    int t = lcp + lcs - len + 1;\n                    // fprintf(stderr, &quot;(%d, %d), %d, %d\\n&quot;, l, r, lcp, lcs);\n                    ++g[l - lcs], --g[l - lcs + t], ++f[r + lcp - t], --f[r + lcp];\n                &#125;\n            &#125;\n        std::partial_sum(f.begin(), f.end(), f.begin());\n        std::partial_sum(g.begin(), g.end(), g.begin());\n        long long res = 0ll;\n        for (int i = 1; i &lt; n; ++i)\n            res += (long long)f[i] * g[i + 1];\n        std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h4 id=\"eg2.-tandem\">eg2. tandem</h4>\n<p><a href=\"https://www.codechef.com/problems/TANDEM\" class=\"uri\">https://www.codechef.com/problems/TANDEM</a></p>\n<p>注意到多了一个限制，前一个好处理，找到经过 <span class=\"math inline\">\\(3\\)</span> 个标记的串即可。对于后一个限制，画图可以发现对于 interesting ones，每次只会出现最多一个；当且仅当 <span class=\"math inline\">\\(\\text {lcp}&gt;len\\)</span> 时不存在。</p>\n<p>对于 uninteresting ones，用每次能提供的总数减去 interesting ones 的数量即可。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nclass SA &#123;\npublic:\n    std::vector&lt;int&gt; sa, rk, h;\n    std::vector&lt;std::vector&lt;int&gt;  &gt; st;\n    SA(int n, std::string s): sa(n + 1), rk(n + 2), h(n + 1), st(20, std::vector&lt;int&gt; (n + 1)) &#123;\n        std::vector&lt;int&gt; la(n + 2);\n        std::copy(s.begin(), s.end(), rk.begin());\n        int m = 128;\n        &#123;\n            std::vector&lt;int&gt; c(m + 1);\n            for (int i = 1; i &lt;= n; ++i)\n                ++c[rk[i]];\n            std::partial_sum(c.begin(), c.end(), c.begin());\n            for (int i = n; i; --i)\n                sa[c[rk[i]]--] = i;\n        &#125;\n        for (int w = 1, p; ; w &lt;&lt;= 1, m = p) &#123;\n            std::vector&lt;int&gt; id(1);\n            for (int i = n - w + 1; i &lt;= n; ++i)\n                id.push_back(i);\n            for (int i = 1; i &lt;= n; ++i)\n                if (sa[i] &gt; w)\n                    id.push_back(sa[i] - w);\n            std::vector&lt;int&gt; c(m + 1);\n            for (int i = 1; i &lt;= n; ++i)\n                ++c[rk[i]];\n            std::partial_sum(c.begin(), c.end(), c.begin());\n            for (int i = n; i; --i)\n                sa[c[rk[id[i]]]--] = id[i];\n            p = 0;\n            std::copy(rk.begin(), rk.end(), la.begin());\n            for (int i = 1; i &lt;= n; ++i)\n                if (la[sa[i]] == la[sa[i - 1]] &amp;&amp; la[sa[i] + w] == la[sa[i - 1] + w])\n                    rk[sa[i]] = p;\n                else\n                    rk[sa[i]] = ++p;\n            if (p == n)\n                break;\n        &#125;\n        for (int i = 1, to = 0; i &lt;= n; ++i)\n            if (rk[i]) &#123;\n                for (to = std::max(to - 1, 0); s[i + to] == s[sa[rk[i] - 1] + to]; ++to);\n                h[rk[i]] = to;\n            &#125;\n        for (int i = 1; i &lt;= n; ++i)\n            st[0][i] = h[i];\n        for (int j = 1; (1 &lt;&lt; j) &lt;= n; ++j)\n            for (int i = 1; i + (1 &lt;&lt; j) - 1 &lt;= n; ++i)\n                st[j][i] = std::min(st[j - 1][i], st[j - 1][i + (1 &lt;&lt; (j - 1))]);\n        rk.emplace_back();\n        return;\n    &#125;\nprivate:\n    int ask(int l, int r) &#123;\n        // fprintf(stderr, &quot;l = %d, r = %d\\n&quot;, l, r);\n        int k = std::__lg(r - l + 1);\n        return std::min(st[k][l], st[k][r - (1 &lt;&lt; k) + 1]);\n    &#125;\npublic:\n    int lcp(int l, int r) &#123;\n        return ask(std::min(rk[l], rk[r]) + 1, std::max(rk[l], rk[r]));\n    &#125;\n&#125;;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    std::string s;\n    std::cin &gt;&gt; s;\n    int n = (int)s.length();\n    s = &quot;#&quot; + s;\n    SA p(n, s);\n    std::reverse(s.begin() + 1, s.end());\n    SA q(n, s);\n    std::reverse(s.begin() + 1, s.end());\n    long long res1 = 0ll, res2 = 0ll;\n    for (int len = 1; len &lt;= n; ++len)\n        for (int i = len, j = 2 * len, k = 3 * len; k &lt;= n; i += len, j += len, k += len) &#123;\n            int lcp = std::min(p.lcp(i, j), p.lcp(j, k)), lcs = std::min(&#123; len - 1, q.lcp(n - i + 2, n - j + 2), q.lcp(n - j + 2, n - k + 2) &#125;);\n            if (std::min(len, lcp) + lcs &gt;= len) &#123;\n                // printf(&quot;(%d, %d, %d), %d, %d, %d\\n&quot;, i, j, k, lcs, lcp, len);\n                int t = (lcp &lt;= len);\n                res1 += t, res2 += std::min(len, lcp) + lcs - len + 1 - t;\n            &#125;\n            // else\n            //     printf(&quot;# (%d, %d, %d), %d, %d, %d\\n&quot;, i, j, k, lcs, lcp, len);\n        &#125;\n    std::cout &lt;&lt; res1 &lt;&lt; &#39; &#39; &lt;&lt; res2 &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h4 id=\"eg3.-repeats\">eg3. repeats</h4>\n<p><a href=\"https://www.spoj.com/problems/REPEATS/\" class=\"uri\">https://www.spoj.com/problems/REPEATS/</a></p>\n<p>重复次数最多，只需经过标记点最多。显然经过标记点的数量就是该字符串长除以 <span class=\"math inline\">\\(len\\)</span> 向下取整就可以得到重复次数减 <span class=\"math inline\">\\(1\\)</span> 的值。</p>\n<p>选择两个连续标记点，对于 lcp 和 lcs（显然此时不需要对 <span class=\"math inline\">\\(len\\)</span> 取 <span class=\"math inline\">\\(\\min\\)</span>），计算 <span class=\"math inline\">\\(\\dfrac {\\text{lcp}+\\text{lcs}}{len}+1\\)</span> 取最大即可。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nclass SA &#123;\npublic:\n    std::vector&lt;int&gt; sa, rk, h;\n    std::vector&lt;std::vector&lt;int&gt;  &gt; st;\n    SA(int n, std::string s): sa(n + 1), rk(n + 2), h(n + 1), st(20, std::vector&lt;int&gt; (n + 1)) &#123;\n        std::vector&lt;int&gt; la(n + 2);\n        std::copy(s.begin(), s.end(), rk.begin());\n        int m = 128;\n        &#123;\n            std::vector&lt;int&gt; c(m + 1);\n            for (int i = 1; i &lt;= n; ++i)\n                ++c[rk[i]];\n            std::partial_sum(c.begin(), c.end(), c.begin());\n            for (int i = n; i; --i)\n                sa[c[rk[i]]--] = i;\n        &#125;\n        for (int w = 1, p; ; w &lt;&lt;= 1, m = p) &#123;\n            std::vector&lt;int&gt; id(1);\n            for (int i = n - w + 1; i &lt;= n; ++i)\n                id.push_back(i);\n            for (int i = 1; i &lt;= n; ++i)\n                if (sa[i] &gt; w)\n                    id.push_back(sa[i] - w);\n            std::vector&lt;int&gt; c(m + 1);\n            for (int i = 1; i &lt;= n; ++i)\n                ++c[rk[i]];\n            std::partial_sum(c.begin(), c.end(), c.begin());\n            for (int i = n; i; --i)\n                sa[c[rk[id[i]]]--] = id[i];\n            p = 0;\n            std::copy(rk.begin(), rk.end(), la.begin());\n            for (int i = 1; i &lt;= n; ++i)\n                if (la[sa[i]] == la[sa[i - 1]] &amp;&amp; la[sa[i] + w] == la[sa[i - 1] + w])\n                    rk[sa[i]] = p;\n                else\n                    rk[sa[i]] = ++p;\n            if (p == n)\n                break;\n        &#125;\n        for (int i = 1, to = 0; i &lt;= n; ++i)\n            if (rk[i]) &#123;\n                for (to = std::max(to - 1, 0); s[i + to] == s[sa[rk[i] - 1] + to]; ++to);\n                h[rk[i]] = to;\n            &#125;\n        for (int i = 1; i &lt;= n; ++i)\n            st[0][i] = h[i];\n        for (int j = 1; (1 &lt;&lt; j) &lt;= n; ++j)\n            for (int i = 1; i + (1 &lt;&lt; j) - 1 &lt;= n; ++i)\n                st[j][i] = std::min(st[j - 1][i], st[j - 1][i + (1 &lt;&lt; (j - 1))]);\n        rk.emplace_back();\n        return;\n    &#125;\nprivate:\n    int ask(int l, int r) &#123;\n        // fprintf(stderr, &quot;l = %d, r = %d\\n&quot;, l, r);\n        int k = std::__lg(r - l + 1);\n        return std::min(st[k][l], st[k][r - (1 &lt;&lt; k) + 1]);\n    &#125;\npublic:\n    int lcp(int l, int r) &#123;\n        return ask(std::min(rk[l], rk[r]) + 1, std::max(rk[l], rk[r]));\n    &#125;\n&#125;;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int T;\n    for (std::cin &gt;&gt; T; T--; ) &#123;\n        int n;\n        std::cin &gt;&gt; n;\n        std::string s = &quot;#&quot;;\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            char t;\n            std::cin &gt;&gt; t;\n            s.push_back(t);\n        &#125;\n        SA p(n, s);\n        std::reverse(s.begin() + 1, s.end());\n        SA q(n, s);\n        int res = 0;\n        for (int len = 1; len &lt;= n; ++len)\n            for (int i = len, j = 2 * len; j &lt;= n; i += len, j += len) &#123;\n                int lcp = p.lcp(i, j), lcs = q.lcp(n - i + 2, n - j + 2);\n                if (lcp + lcs &gt;= len)\n                    res = std::max(res, (lcp + lcs) / len + 1);\n            &#125;\n        std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"结合并查集\">结合并查集</h3>\n<hr />\n<h3 id=\"结合单调栈\">结合单调栈</h3>\n",
            "tags": [
                "字符串",
                "SA"
            ]
        }
    ]
}