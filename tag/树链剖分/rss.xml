<?xml version="1.0"?>
<rss version="2.0">
    <channel>
        <title> • Posts by &#34;树链剖分&#34; tag</title>
        <link>https://xsc062.netlify.app</link>
        <description></description>
        <language>zh-CN</language>
        <pubDate>Tue, 12 Aug 2025 08:16:52 +0800</pubDate>
        <lastBuildDate>Tue, 12 Aug 2025 08:16:52 +0800</lastBuildDate>
        <category>并查集</category>
        <category>斜率优化</category>
        <category>悬线法</category>
        <category>哈希</category>
        <category>字典树</category>
        <category>DP</category>
        <category>单调队列</category>
        <category>分治</category>
        <category>计数</category>
        <category>容斥</category>
        <category>二分图</category>
        <category>CRT / exCRT</category>
        <category>排列组合</category>
        <category>网络流</category>
        <category>二分</category>
        <category>容斥原理</category>
        <category>线段树</category>
        <category>树状数组</category>
        <category>区间 DP</category>
        <category>构造</category>
        <category>数据结构</category>
        <category>Tarjan</category>
        <category>下饭</category>
        <category>李超线段树</category>
        <category>树链剖分</category>
        <category>LCA</category>
        <category>倍增</category>
        <category>鸽巢原理</category>
        <category>数学</category>
        <category>调和级数</category>
        <category>差分</category>
        <category>思维</category>
        <category>树形 DP</category>
        <category>最小生成树</category>
        <category>状压</category>
        <category>高维前缀和</category>
        <category>SAM</category>
        <category>分块</category>
        <category>可持久化</category>
        <category>笛卡尔树</category>
        <category>闲话</category>
        <category>欧拉回路</category>
        <category>长链剖分</category>
        <category>KMP</category>
        <category>border</category>
        <category>随机化</category>
        <category>字符串</category>
        <category>AC 自动机</category>
        <category>SA</category>
        <category>树上差分</category>
        <category>FWT</category>
        <category>堆</category>
        <category>树的重心</category>
        <category>贪心</category>
        <category>均摊</category>
        <category>优化建图</category>
        <category>反悔贪心</category>
        <category>调整法</category>
        <category>背包</category>
        <category>博弈论</category>
        <category>DP 优化</category>
        <category>虚树</category>
        <category>点分治</category>
        <category>四边形不等式</category>
        <category>支配对</category>
        <category>DDP</category>
        <category>CDQ 分治</category>
        <category>猫树</category>
        <category>DP 套 DP</category>
        <category>Kruskal 重构树</category>
        <category>高精度</category>
        <category>最短路</category>
        <category>树套树</category>
        <category>二项式反演</category>
        <category>搜索</category>
        <item>
            <guid isPermalink="true">https://xsc062.netlify.app/20250812/</guid>
            <title>DDP 与全局平衡二叉树</title>
            <link>https://xsc062.netlify.app/20250812/</link>
            <category>线段树</category>
            <category>树链剖分</category>
            <category>DDP</category>
            <pubDate>Tue, 12 Aug 2025 08:16:52 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;其实动态 DP 不是动态树 DP 的同义词&lt;/p&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;动态-dp&#34;&gt;动态 DP&lt;/h2&gt;
&lt;p&gt;对于转移只依赖前几项的 DP，可以放进矩阵。&lt;/p&gt;
&lt;p&gt;默认转移范围是 &lt;span class=&#34;math inline&#34;&gt;\([1,n]\)&lt;/span&gt;；如果我们需要改变求解范围，发现如果能获取转移矩阵的乘积就很快了。考虑存下来。&lt;/p&gt;
&lt;p&gt;如果需要单点修改，等价于修改其所在矩阵，则想要尽可能少地修改存储的答案，考虑使用线段树优化该过程。&lt;/p&gt;
&lt;h3 id=&#34;例海报&#34;&gt;例：海报&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P9790&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P9790&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;容易列出暴力 DP 式：令 &lt;span class=&#34;math inline&#34;&gt;\(f_{i,j}\)&lt;/span&gt; 表示枚举到 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 时，包含 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 在内已经有 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; 个连续的人举起海报，易得：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
f_{i,0}=\max(f_{i-1,0},f_{i-1,1},f_{i-1,2},f_{i-1,3})\\
f_{i,j}=f_{i-1,j-1}+a_i \forall 1\le j\le 3
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;发现满足 + / max &lt;strong&gt;矩阵乘法&lt;/strong&gt; 的形式；想到用线段树保存每段区间对应矩阵（对应性质：结合律），每次修改 / 查询就能在 &lt;span class=&#34;math inline&#34;&gt;\(O(\log n)\)&lt;/span&gt; 之内完成。&lt;/p&gt;
&lt;p&gt;原问题是环形的，可以再加一维 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 表示钦定选了前 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 个且不选第 &lt;span class=&#34;math inline&#34;&gt;\(k+1\)&lt;/span&gt; 个时的答案。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int maxn = 4e4 + 5;
const long long inf = 1e18;
struct mat &amp;#123;
    int n, m;
    long long a[4][4];
    mat() &amp;#123;&amp;#125;
    mat(int n1, int m1): n(n1), m(m1) &amp;#123;
        for (int i = 0; i &amp;lt; n; ++i)
            for (int j = 0; j &amp;lt; m; ++j)
                a[i][j] = -inf;
        return;
    &amp;#125;
    long long* operator[] (const int q) &amp;#123;
        return a[q];
    &amp;#125;
    mat operator* (mat &amp;amp;q) const &amp;#123;
        mat res(n, q.m);
        for (int i = 0; i &amp;lt; n; ++i)
            for (int k = 0; k &amp;lt; q.m; ++k)
                for (int j = 0; j &amp;lt; m; ++j)
                    res[i][k] = std::max(res[i][k], a[i][j] + q[j][k]);
        return res;
    &amp;#125;
    mat&amp;amp; operator*= (mat &amp;amp;q) &amp;#123;
        return *this = *this * q;
    &amp;#125;
&amp;#125;;
struct &amp;#123; int l, r; mat u[4]; &amp;#125; t[maxn &amp;lt;&amp;lt; 2];
int a[maxn];
#define lt (p &amp;lt;&amp;lt; 1)
#define rt (lt | 1)
#define c t[p].u[i]
void bld(int p, int l, int r) &amp;#123;
    t[p].l = l, t[p].r = r;
    if (l == r) &amp;#123;
        for (int i = 0; i &amp;lt;= 3; ++i) &amp;#123;
            c = mat(4, 4);
            if (l &amp;gt; i + 1) &amp;#123;
                c[0][0] = c[1][0] = c[2][0] = c[3][0] = 0;
                c[0][1] = c[1][2] = c[2][3] = a[l];
            &amp;#125;
            else if (l == i + 1)
                c[0][0] = c[1][0] = c[2][0] = c[3][0] = 0;
            else
                c[0][1] = c[1][2] = c[2][3] = a[l];
        &amp;#125;
        return;
    &amp;#125;
    int mid = (l + r) &amp;gt;&amp;gt; 1;
    bld(lt, l, mid), bld(rt, mid + 1, r);
    for (int i = 0; i &amp;lt;= 3; ++i)
        t[p].u[i] = t[lt].u[i] * t[rt].u[i];
    return;
&amp;#125;
void add(int p, int x, int v) &amp;#123;
    if (t[p].l == t[p].r) &amp;#123;
        for (int i = 0; i &amp;lt;= 3; ++i)
            if (t[p].l != i + 1) 
                c[0][1] = c[1][2] = c[2][3] = v;
        return;
    &amp;#125;
    int mid = (t[p].l + t[p].r) &amp;gt;&amp;gt; 1;
    if (x &amp;lt;= mid)
        add(lt, x, v);
    else
        add(rt, x, v);
    for (int i = 0; i &amp;lt;= 3; ++i)
        t[p].u[i] = t[lt].u[i] * t[rt].u[i];
    return;
&amp;#125;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n;
    std::cin &amp;gt;&amp;gt; n;
    for (int i = 1; i &amp;lt;= n; ++i)
        std::cin &amp;gt;&amp;gt; a[i];
    bld(1, 1, n);
    auto calc = [&amp;amp;](void) &amp;#123;
        mat f(1, 4);
        f[0][0] = 0;
        auto res = -inf;
        for (int i = 0; i &amp;lt;= 3; ++i) &amp;#123;
            auto r = (f * t[1].u[i]);
            for (int j = 0; j &amp;lt;= 3; ++j)
                if (i + j &amp;lt;= 3) &amp;#123;
                    res = std::max(res, r[0][j]);
                    // printf(&amp;quot;f[%d][%d] = %lld\n&amp;quot;, i, j, f[i][j]);
                &amp;#125;
        &amp;#125;
        return res;
    &amp;#125;;
    std::cout &amp;lt;&amp;lt; calc() &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    int q;
    std::cin &amp;gt;&amp;gt; q;
    for (int x, v; q--; ) &amp;#123;
        std::cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; v;
        add(1, x, v);
        std::cout &amp;lt;&amp;lt; calc() &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    &amp;#125;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;p&gt;发现矩阵本身和 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 无关，还可以可以共用一个线段树上的信息，就可以只开一个线段树了。&lt;/p&gt;
&lt;details&gt;
&lt;p&gt;我写这一版本的原因是 &lt;code&gt;maxn&lt;/code&gt; 开大了导致 MLE，实际上四个线段树是没有任何空间压力的 😅&lt;/p&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int maxn = 4e5 + 5;
const long long inf = 1e18;
struct mat &amp;#123;
    int n, m;
    long long a[4][4];
    mat() &amp;#123;&amp;#125;
    mat(int n1, int m1): n(n1), m(m1) &amp;#123;
        for (int i = 0; i &amp;lt; n; ++i)
            for (int j = 0; j &amp;lt; m; ++j)
                a[i][j] = -inf;
        return;
    &amp;#125;
    long long* operator[] (const int q) &amp;#123;
        return a[q];
    &amp;#125;
    mat operator* (mat q) const &amp;#123;
        mat res(n, q.m);
        for (int i = 0; i &amp;lt; n; ++i)
            for (int k = 0; k &amp;lt; q.m; ++k)
                for (int j = 0; j &amp;lt; m; ++j)
                    res[i][k] = std::max(res[i][k], a[i][j] + q[j][k]);
        return res;
    &amp;#125;
    mat&amp;amp; operator*= (mat &amp;amp;q) &amp;#123;
        return *this = *this * q;
    &amp;#125;
&amp;#125;;
struct &amp;#123; int l, r; mat u; &amp;#125; t[maxn &amp;lt;&amp;lt; 2];
int a[maxn];
#define lt (p &amp;lt;&amp;lt; 1)
#define rt (lt | 1)
void bld(int p, int l, int r) &amp;#123;
    t[p].l = l, t[p].r = r;
    if (l == r) &amp;#123;
        t[p].u = mat(4, 4);
        t[p].u[0][0] = t[p].u[1][0] = t[p].u[2][0] = t[p].u[3][0] = 0;
        t[p].u[0][1] = t[p].u[1][2] = t[p].u[2][3] = a[l];
        return;
    &amp;#125;
    int mid = (l + r) &amp;gt;&amp;gt; 1;
    bld(lt, l, mid), bld(rt, mid + 1, r);
    t[p].u = t[lt].u * t[rt].u;
    return;
&amp;#125;
void add(int p, int x, int v) &amp;#123;
    if (t[p].l == t[p].r) &amp;#123;
        t[p].u[0][1] = t[p].u[1][2] = t[p].u[2][3] = v;
        return;
    &amp;#125;
    int mid = (t[p].l + t[p].r) &amp;gt;&amp;gt; 1;
    if (x &amp;lt;= mid)
        add(lt, x, v);
    else
        add(rt, x, v);
    t[p].u = t[lt].u * t[rt].u;
    return;
&amp;#125;
mat ask(int p, int l, int r) &amp;#123;
    if (l &amp;lt;= t[p].l &amp;amp;&amp;amp; t[p].r &amp;lt;= r)
        return t[p].u;
    int mid = (t[p].l + t[p].r) &amp;gt;&amp;gt; 1;
    if (r &amp;lt;= mid)
        return ask(lt, l, r);
    if (l &amp;gt; mid)
        return ask(rt, l, r);
    return ask(lt, l, r) * ask(rt, l, r);
&amp;#125;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n;
    std::cin &amp;gt;&amp;gt; n;
    for (int i = 1; i &amp;lt;= n; ++i)
        std::cin &amp;gt;&amp;gt; a[i];
    bld(1, 1, n);
    auto calc = [&amp;amp;](void) &amp;#123;
        mat f(1, 4);
        f[0][0] = 0, f[0][1] = f[0][2] = f[0][3] = -inf;
        auto r(f * ask(1, 2, n));
        auto res(*std::max_element(r[0], r[0] + 4));
        mat z(4, 4);
        z[0][0] = z[1][0] = z[2][0] = z[3][0] = 0ll;
        for (int i = 1; i &amp;lt;= 3; ++i) &amp;#123;
            mat op(4, 4);
            op[0][1] = op[1][2] = op[2][3] = a[i];
            f *= op;
            if (i + 2 &amp;lt;= n)
                r = f * z * ask(1, i + 2, n);
            else
                r = f * z;
            res = std::max(res, *std::max_element(r[0], r[0] + 4 - i));
        &amp;#125;
        return res;
    &amp;#125;;
    std::cout &amp;lt;&amp;lt; calc() &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    int q;
    std::cin &amp;gt;&amp;gt; q;
    for (int x, v; q--; ) &amp;#123;
        std::cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; v, a[x] = v;
        add(1, x, v);
        std::cout &amp;lt;&amp;lt; calc() &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    &amp;#125;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;经典题gss3&#34;&gt;经典题：GSS3&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/SP1716&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/SP1716&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;怎么是子段和 😓&lt;/p&gt;
&lt;p&gt;同样列出能够矩阵乘法的 DP 式，发现限制在于至少要选一个数。设 &lt;span class=&#34;math inline&#34;&gt;\(f_{i}\)&lt;/span&gt; 表示选了 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 的最大值，&lt;span class=&#34;math inline&#34;&gt;\(g_i\)&lt;/span&gt; 表示历史最大值，则：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
f_i=\max(f_{i-1}+a_i,0+a_i)\\
g_i=\max(g_{i-1}+0,f_{i-1}+a_i,0+a_i)
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;容易发现是一个 + / max 矩乘，线段树维护即可。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int maxn = 4e5 + 5;
const long long inf = 1e18;
struct mat &amp;#123;
    int n, m;
    long long a[3][3];
    mat() &amp;#123;&amp;#125;
    mat(int n1, int m1): n(n1), m(m1) &amp;#123;
        for (int i = 0; i &amp;lt; n; ++i)
            for (int j = 0; j &amp;lt; m; ++j)
                a[i][j] = -inf;
        return;
    &amp;#125;
    long long* operator[] (const int q) &amp;#123;
        return a[q];
    &amp;#125;
    mat operator* (mat q) const &amp;#123;
        mat res(n, q.m);
        for (int i = 0; i &amp;lt; n; ++i)
            for (int k = 0; k &amp;lt; q.m; ++k)
                for (int j = 0; j &amp;lt; m; ++j)
                    res[i][k] = std::max(res[i][k], a[i][j] + q[j][k]);
        return res;
    &amp;#125;
    mat&amp;amp; operator*= (mat &amp;amp;q) &amp;#123;
        return *this = *this * q;
    &amp;#125;
&amp;#125;;
struct &amp;#123; int l, r; mat u; &amp;#125; t[maxn &amp;lt;&amp;lt; 2]; 
int a[maxn];
#define lt (p &amp;lt;&amp;lt; 1)
#define rt (lt | 1)
void bld(int p, int l, int r) &amp;#123;
    t[p].l = l, t[p].r = r;
    if (l == r) &amp;#123;
        t[p].u = mat(3, 3);
        t[p].u[0][0] = t[p].u[2][0] = a[l];
        t[p].u[0][1] = a[l], t[p].u[1][1] = 0ll, t[p].u[2][1] = a[l];
        t[p].u[2][2] = 0ll;
        return;
    &amp;#125;
    int mid = (l + r) &amp;gt;&amp;gt; 1;
    bld(lt, l, mid), bld(rt, mid + 1, r);
    t[p].u = t[lt].u * t[rt].u;
    return;
&amp;#125;
void add(int p, int x, int v) &amp;#123;
    if (t[p].l == t[p].r) &amp;#123;
        t[p].u[0][0] = t[p].u[2][0] = t[p].u[0][1] = t[p].u[2][1] = v;
        return;
    &amp;#125;
    int mid = (t[p].l + t[p].r) &amp;gt;&amp;gt; 1;
    if (x &amp;lt;= mid)
        add(lt, x, v);
    else
        add(rt, x, v);
    t[p].u = t[lt].u * t[rt].u;
    return;
&amp;#125;
mat ask(int p, int l, int r) &amp;#123;
    if (l &amp;lt;= t[p].l &amp;amp;&amp;amp; t[p].r &amp;lt;= r)
        return t[p].u;
    int mid = (t[p].l + t[p].r) &amp;gt;&amp;gt; 1;
    if (r &amp;lt;= mid)
        return ask(lt, l, r);
    if (l &amp;gt; mid)
        return ask(rt, l, r);
    return ask(lt, l, r) * ask(rt, l, r);
&amp;#125;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n;
    std::cin &amp;gt;&amp;gt; n;
    for (int i = 1; i &amp;lt;= n; ++i)
        std::cin &amp;gt;&amp;gt; a[i];
    bld(1, 1, n);
    auto calc = [&amp;amp;](int l, int r) &amp;#123;
        mat f(1, 3);
        f[0][2] = 0ll;
        auto res(f * ask(1, l, r));
        return res[0][1];
    &amp;#125;;
    int q;
    std::cin &amp;gt;&amp;gt; q;
    for (int op; q--; ) &amp;#123;
        std::cin &amp;gt;&amp;gt; op;
        if (op == 1) &amp;#123;
            int l, r;
            std::cin &amp;gt;&amp;gt; l &amp;gt;&amp;gt; r;
            std::cout &amp;lt;&amp;lt; calc(l, r) &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
        &amp;#125;
        else &amp;#123;
            int x, v;
            std::cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; v;
            a[x] = v, add(1, x, v);
        &amp;#125;
    &amp;#125;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;动态树-dp&#34;&gt;动态树 DP&lt;/h2&gt;
&lt;p&gt;把上述过程放到树上，很容易想到树剖 + 线段树。&lt;/p&gt;
&lt;p&gt;由于认为线段树上的矩乘只能进行从重儿子到父亲的转移，轻儿子的转移会被合并为一个新函数（同时是矩阵的系数），在跳重链的时候被单独更新。&lt;/p&gt;
&lt;p&gt;由于两个函数相互依赖，需要思考清楚更新的先后顺序。&lt;/p&gt;
&lt;h3 id=&#34;模板动态-dp&#34;&gt;【模板】动态 DP&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P4719&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P4719&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;令 &lt;span class=&#34;math inline&#34;&gt;\(f_{u,0/1}\)&lt;/span&gt; 表示在 &lt;span class=&#34;math inline&#34;&gt;\(u\)&lt;/span&gt; 上，选 / 不选 &lt;span class=&#34;math inline&#34;&gt;\(u\)&lt;/span&gt; 的最大价值。容易得出转移：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
f_{u,0}=\sum\max(f_{v,0},f_{v,1})\\
f_{u,1}=a_i+\sum f_{v,0}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;把转移矩阵放到树剖上后，考虑更新，发现求和这一步很困难。解决方案是&lt;strong&gt;直接将求和用另一个函数代替&lt;/strong&gt;。定义 &lt;span class=&#34;math inline&#34;&gt;\(g_{u,0}\)&lt;/span&gt; 表示取 &lt;span class=&#34;math inline&#34;&gt;\(u\)&lt;/span&gt;、不取 &lt;span class=&#34;math inline&#34;&gt;\(u\)&lt;/span&gt; 的所有轻儿子的答案，&lt;span class=&#34;math inline&#34;&gt;\(g_{u,1}\)&lt;/span&gt; 不取 &lt;span class=&#34;math inline&#34;&gt;\(u\)&lt;/span&gt;，轻儿子可选可不选的答案。&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(g\)&lt;/span&gt; 是可求的，且只需要在跳重链的时候更新 &lt;span class=&#34;math inline&#34;&gt;\(g\)&lt;/span&gt;。具体更新起来非常绞，因为 &lt;span class=&#34;math inline&#34;&gt;\(g\)&lt;/span&gt; 和 &lt;span class=&#34;math inline&#34;&gt;\(f\)&lt;/span&gt; 是相互依赖的，需要分清楚先后关系。&lt;/p&gt;
&lt;p&gt;首先 &lt;span class=&#34;math inline&#34;&gt;\(g_u\)&lt;/span&gt; 和 &lt;span class=&#34;math inline&#34;&gt;\(f_u\)&lt;/span&gt; 都会被更新；接着，重链上其它的 &lt;span class=&#34;math inline&#34;&gt;\(g\)&lt;/span&gt; 不会被影响，而链顶的 &lt;span class=&#34;math inline&#34;&gt;\(f\)&lt;/span&gt; 需要被新的 &lt;span class=&#34;math inline&#34;&gt;\(g_u\)&lt;/span&gt; 更新；由此链顶父亲的 &lt;span class=&#34;math inline&#34;&gt;\(g\)&lt;/span&gt; 被更新；依次类推。注意到对于一个链顶，其 &lt;span class=&#34;math inline&#34;&gt;\(f\)&lt;/span&gt; 值是整条重链的乘积，故需要记录链底。&lt;/p&gt;
&lt;p&gt;复杂度 &lt;span class=&#34;math inline&#34;&gt;\(O(q\log ^2n)\)&lt;/span&gt;。注意很重要的一点是线段树内乘法应从右往左。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int maxn = 1e5 + 5;
const int inf = 0x3f3f3f3f;
struct mat &amp;#123;
    int n, m, a[2][2];
    mat() &amp;#123;&amp;#125;
    mat(int n1, int m1): n(n1), m(m1) &amp;#123;
        for (int i = 0; i &amp;lt; n; ++i)
            for (int j = 0; j &amp;lt; m; ++j)
                a[i][j] = -inf;
        return;
    &amp;#125;
    int* operator[] (const int q) &amp;#123;
        return a[q];
    &amp;#125;
    mat operator* (mat q) const &amp;#123;
        mat res(n, q.m);
        for (int i = 0; i &amp;lt; n; ++i)
            for (int k = 0; k &amp;lt; q.m; ++k)
                for (int j = 0; j &amp;lt; m; ++j)
                    res[i][k] = std::max(res[i][k], a[i][j] + q[j][k]);
        return res;
    &amp;#125;
    mat&amp;amp; operator*= (mat &amp;amp;q) &amp;#123;
        return *this = *this * q;
    &amp;#125;
&amp;#125;;
struct &amp;#123; int l, r; mat u; &amp;#125; t[maxn &amp;lt;&amp;lt; 2]; 
int g[maxn][2], tab[maxn];
#define lt (p &amp;lt;&amp;lt; 1)
#define rt (lt | 1)
void bld(int p, int l, int r) &amp;#123;
    t[p].l = l, t[p].r = r;
    if (l == r) &amp;#123;
        int u = tab[l];
        t[p].u = mat(2, 2);
        t[p].u[0][0] = t[p].u[1][0] = g[u][1];
        t[p].u[0][1] = g[u][0];
        return;
    &amp;#125;
    int mid = (l + r) &amp;gt;&amp;gt; 1;
    bld(lt, l, mid), bld(rt, mid + 1, r);
    t[p].u = t[rt].u * t[lt].u;
    return;
&amp;#125;
void add(int p, int x) &amp;#123;
    if (t[p].l == t[p].r) &amp;#123;
        int u = tab[x];
        t[p].u[0][0] = t[p].u[1][0] = g[u][1];
        t[p].u[0][1] = g[u][0];
        return;
    &amp;#125;
    int mid = (t[p].l + t[p].r) &amp;gt;&amp;gt; 1;
    if (x &amp;lt;= mid)
        add(lt, x);
    else
        add(rt, x);
    t[p].u = t[rt].u * t[lt].u;
    return;
&amp;#125;
mat ask(int p, int l, int r) &amp;#123;
    if (l &amp;lt;= t[p].l &amp;amp;&amp;amp; t[p].r &amp;lt;= r)
        return t[p].u;
    int mid = (t[p].l + t[p].r) &amp;gt;&amp;gt; 1;
    if (r &amp;lt;= mid)
        return ask(lt, l, r);
    if (l &amp;gt; mid)
        return ask(rt, l, r);
    return ask(rt, l, r) * ask(lt, l, r);
&amp;#125;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, q;
    std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; q;
    std::vector&amp;lt;int&amp;gt; a(n + 1);
    for (int i = 1; i &amp;lt;= n; ++i)
        std::cin &amp;gt;&amp;gt; a[i];
    std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; g1(n + 1);
    for (int i = 1, x, y; i &amp;lt; n; ++i) &amp;#123;
        std::cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; y;
        g1[x].push_back(y), g1[y].push_back(x);
    &amp;#125;
    std::vector&amp;lt;int&amp;gt; siz(n + 1), son(n + 1), fa(n + 1);
    std::function&amp;lt;void(int)&amp;gt; DFS = [&amp;amp;](int x) &amp;#123;
        siz[x] = 1;
        for (auto i : g1[x])
            if (i != fa[x]) &amp;#123;
                fa[i] = x, DFS(i);
                siz[x] += siz[i];
                if (siz[i] &amp;gt; siz[son[x]])
                    son[x] = i;
            &amp;#125;
        return;
    &amp;#125;;
    DFS(1);
    std::vector&amp;lt;std::array&amp;lt;int, 2&amp;gt; &amp;gt; f(n + 1);
    std::vector&amp;lt;int&amp;gt; top(n + 1), bot(n + 1), dfn(n + 1);
    DFS = [&amp;amp;](int x) &amp;#123;
        static int now = 0;
        dfn[x] = ++now, tab[now] = x;
        if (son[x]) &amp;#123;
            top[son[x]] = top[x], DFS(son[x]);
            bot[x] = bot[son[x]];
            g[x][0] = a[x];
            for (auto i : g1[x])
                if (i != son[x] &amp;amp;&amp;amp; i != fa[x]) &amp;#123;
                    top[i] = i, DFS(i);
                    g[x][0] += f[i][0];
                    g[x][1] += std::max(f[i][1], f[i][0]);
                &amp;#125;
            f[x][0] = g[x][1] + std::max(f[son[x]][0], f[son[x]][1]);
            f[x][1] = g[x][0] + f[son[x]][0];
        &amp;#125;
        else
            f[x][1] = g[x][0] = a[x], bot[x] = x;
        return;
    &amp;#125;;
    top[1] = 1, DFS(1);
    bld(1, 1, n);
    for (int x, v; q--; ) &amp;#123;
        std::cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; v;
        g[x][0] -= a[x], g[x][0] += v, a[x] = v;
        for (; top[x] != 1; ) &amp;#123;
            auto r = ask(1, dfn[top[x]], dfn[bot[x]]);
            f[top[x]][0] = r[0][0], f[top[x]][1] = r[0][1];
            g[fa[top[x]]][0] -= f[top[x]][0];
            g[fa[top[x]]][1] -= std::max(f[top[x]][0], f[top[x]][1]);
            add(1, dfn[x]);
            r = ask(1, dfn[top[x]], dfn[bot[x]]);
            f[top[x]][0] = r[0][0], f[top[x]][1] = r[0][1];
            g[fa[top[x]]][0] += f[top[x]][0];
            g[fa[top[x]]][1] += std::max(f[top[x]][0], f[top[x]][1]);
            x = fa[top[x]];
        &amp;#125;
        add(1, dfn[x]);
        auto r = ask(1, dfn[1], dfn[bot[1]]);
        f[1][0] = r[0][0], f[1][1] = r[0][1];
        std::cout &amp;lt;&amp;lt; std::max(f[1][0], f[1][1]) &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    &amp;#125;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;全局平衡二叉树&#34;&gt;全局平衡二叉树&lt;/h2&gt;
&lt;p&gt;回顾树剖（重剖），功能在于解决路径问题，单次操作能够在 &lt;span class=&#34;math inline&#34;&gt;\(O(\log^2 n)\)&lt;/span&gt; 的时间内完成。这个功能可以被&lt;strong&gt;全局平衡二叉树（GBT）&lt;/strong&gt;上位替代。GBT 能够在单次 &lt;span class=&#34;math inline&#34;&gt;\(O(\log n)\)&lt;/span&gt; 的复杂度内完成链操作、子树操作。&lt;em&gt;&lt;a href=&#34;QTREE解法的一些研究.pdf&#34;&gt;Yang Zhe - SPOJ375 QTREE 解法的一些研究&lt;/a&gt; 中更为详细严谨地对 GBT 进行了说明，我传了份文件上来。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;考虑树剖能被卡的原因：每次线段树询问都会卡满 &lt;span class=&#34;math inline&#34;&gt;\(O(\log n)\)&lt;/span&gt;，找一条卡得满 &lt;span class=&#34;math inline&#34;&gt;\(O(\log n)\)&lt;/span&gt; 次跳重链次数的路径一直薅，就可以卡到 &lt;span class=&#34;math inline&#34;&gt;\(O(\log^2 n)\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;在实现线段树时发现，对于&lt;strong&gt;路径操作&lt;/strong&gt;和&lt;strong&gt;单点操作&lt;/strong&gt;，树剖只需要维护同一条重链的信息，建一个大线段树会产生许多重链间的无效维护。故一种经典的树剖卡常技巧是对于每一条重链建出线段树。&lt;/p&gt;
&lt;p&gt;在本文中定义&lt;strong&gt;全局二叉树&lt;/strong&gt;：将单个线段树按照在原树上重链顶的相对祖孙关系连边得到的模型。这里为了和&lt;strong&gt;全局平衡二叉树&lt;/strong&gt;形成照应而命名，实际上模型并不是二叉树。容易发现&lt;strong&gt;修改某个点花费的操作次数和其在全局二叉树中的深度相同&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;考虑本方法理论上仍可卡到 &lt;span class=&#34;math inline&#34;&gt;\(O(\log^2 n)\)&lt;/span&gt; 单次操作的原因，虽然单个线段树平衡，但&lt;strong&gt;全局二叉树&lt;/strong&gt;并不平衡；能够构造数据使得树高达到 &lt;span class=&#34;math inline&#34;&gt;\(\log^2 n\)&lt;/span&gt;。考虑使得全局二叉树平衡，即调整线段树结构使得任何一个点在全局二叉树上的左右儿子大小最接近。发现是易做的，只需在建线段树时移动左右儿子分割点使得两边子树大小均为全树的一半即可。&lt;/p&gt;
&lt;p&gt;法一：求出每个点的轻子树大小 &lt;span class=&#34;math inline&#34;&gt;\(ls_u=1+\sum siz_v\)&lt;/span&gt;，作为加权在线段树上找 mid 就能满足全局平衡；证明可以见上面的论文。这里用线段树代替了 BST，常数很大。&lt;/p&gt;
&lt;p&gt;法二：用一个 BST 实现上述功能，需要满足：任意子树的根为子树的带权 mid；BST 的中序遍历为原重链。显然有：树高为 log 级别。这就决定了所有问题都可以通过暴力爬山解决。&lt;/p&gt;
&lt;p&gt;GBT 能够快速维护&lt;strong&gt;普通树剖操作&lt;/strong&gt;和 &lt;strong&gt;DDP 信息&lt;/strong&gt;。&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;维护-ddp模板动态-dp加强版&#34;&gt;维护 DDP：【模板】动态 DP（加强版）&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P4751&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P4751&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;和未加强版类似，把所有线段树操作替换为 BST 即可。如果写得丑可能需要一些额外的卡常技巧。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int maxn = 1e6 + 5;
const int inf = 0x3f3f3f3f;
const int LEN = (1 &amp;lt;&amp;lt; 20);
int nec(void) &amp;#123;
    static char buf[LEN], *p = buf, *e = buf;
    if (p == e) &amp;#123;
        e = buf + fread(buf, 1, LEN, stdin);
        if (e == buf) return EOF;
        p = buf;
    &amp;#125;
    return *p++;
&amp;#125;
bool read(int &amp;amp;x) &amp;#123;
    x = 0;
    bool f = 0;
    char ch = nec();
    while (ch &amp;lt; &amp;#39;0&amp;#39; || ch &amp;gt; &amp;#39;9&amp;#39;) &amp;#123;
        if (ch == EOF) return 0;
        if (ch == &amp;#39;-&amp;#39;) f = 1;
        ch = nec();
    &amp;#125;
    while (ch &amp;gt;= &amp;#39;0&amp;#39; &amp;amp;&amp;amp; ch &amp;lt;= &amp;#39;9&amp;#39;) &amp;#123;
        x = x * 10 + ch - &amp;#39;0&amp;#39;;
        ch = nec();
    &amp;#125;
    if (f) x = -x;
    return 1;
&amp;#125;
void print(int x) &amp;#123;
    if (x &amp;lt; 0)
        putchar(&amp;#39;-&amp;#39;), x = -x;
    if (x &amp;gt;= 10) print(x / 10);
    putchar(x % 10 + &amp;#39;0&amp;#39;);
    return;
&amp;#125;
void print(int x, char ch) &amp;#123;
    print(x), putchar(ch);
    return;
&amp;#125;
struct mat &amp;#123;
    int a[2][2];
    int* operator[] (const int q) &amp;#123; 
        return a[q];
    &amp;#125;
    mat operator* (mat &amp;amp;q) const &amp;#123;
        mat res;
        res[0][0] = res[0][1] = res[1][0] = res[1][1] = -inf;
        for (int i = 0; i &amp;lt; 2; ++i)
            for (int k = 0; k &amp;lt; 2; ++k)
                for (int j = 0; j &amp;lt; 2; ++j)
                    res[i][k] = std::max(res[i][k], a[i][j] + q[j][k]);
        return res;
    &amp;#125;
    mat&amp;amp; operator*= (mat &amp;amp;q) &amp;#123;
        return *this = *this * q;
    &amp;#125;
&amp;#125;;
struct &amp;#123; int lc, rc, fa; mat u; &amp;#125; t[maxn]; 
int g[maxn][2], tab[maxn], ls[maxn];
mat p[maxn];
void pushup(int x) &amp;#123;
    t[x].u = t[t[x].rc].u * p[x] * t[t[x].lc].u;
    return;
&amp;#125;
void bld(int &amp;amp;x, int l, int r) &amp;#123;
    if (l &amp;gt; r)
        return;
    int s = 0, k = 0;
    for (int i = l; i &amp;lt;= r; ++i)
        s += ls[tab[i]];
    for (int i = l; i &amp;lt;= r; ++i, k += ls[tab[i]])
        if ((k + ls[tab[i]]) * 2 &amp;gt; s) &amp;#123;
            x = tab[i];
            bld(t[x].lc, l, i - 1), t[t[x].lc].fa = x;
            bld(t[x].rc, i + 1, r), t[t[x].rc].fa = x;
            pushup(x);
            break;
        &amp;#125;
    return;
&amp;#125;
#undef lt
#undef rt
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    t[0].u[0][0] = t[0].u[1][1] = 0, t[0].u[0][1] = t[0].u[1][0] = -inf;
    int n, q;
    read(n), read(q);
    std::vector&amp;lt;int&amp;gt; a(n + 1), rt(n + 1);
    for (int i = 1; i &amp;lt;= n; ++i)
        read(a[i]);
    std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; g1(n + 1);
    for (int i = 1, x, y; i &amp;lt; n; ++i) &amp;#123;
        read(x), read(y);
        g1[x].push_back(y), g1[y].push_back(x);
    &amp;#125;
    std::vector&amp;lt;int&amp;gt; son(n + 1), fa(n + 1), siz(n + 1);
    std::function&amp;lt;void(int)&amp;gt; DFS = [&amp;amp;](int x) &amp;#123;
        siz[x] = 1;
        for (auto i : g1[x])
            if (i != fa[x]) &amp;#123;
                fa[i] = x, DFS(i);
                siz[x] += siz[i];
                if (siz[i] &amp;gt; siz[son[x]])
                    son[x] = i;
            &amp;#125;
        return;
    &amp;#125;;
    DFS(1);
    std::vector&amp;lt;std::array&amp;lt;int, 2&amp;gt; &amp;gt; f(n + 1);
    std::vector&amp;lt;int&amp;gt; top(n + 1), bot(n + 1), dfn(n + 1);
    DFS = [&amp;amp;](int x) &amp;#123;
        static int now = 0;
        dfn[x] = ++now, tab[now] = x, ls[x] = 1;
        if (son[x]) &amp;#123;
            top[son[x]] = top[x], DFS(son[x]);
            bot[x] = bot[son[x]];
            g[x][0] = a[x];
            for (auto i : g1[x])
                if (i != son[x] &amp;amp;&amp;amp; i != fa[x]) &amp;#123;
                    top[i] = i, DFS(i), t[rt[i]].fa = x;
                    ls[x] += siz[i];
                    g[x][0] += f[i][0];
                    g[x][1] += std::max(f[i][1], f[i][0]);
                &amp;#125;
            f[x][0] = g[x][1] + std::max(f[son[x]][0], f[son[x]][1]);
            f[x][1] = g[x][0] + f[son[x]][0];
        &amp;#125;
        else
            f[x][1] = g[x][0] = a[x], bot[x] = x;
        p[x][0][0] = p[x][1][0] = g[x][1];
        p[x][0][1] = g[x][0], p[x][1][1] = -inf;
        if (x == top[x])
            bld(rt[x], dfn[x], dfn[bot[x]]);
        return;
    &amp;#125;;
    top[1] = 1, DFS(1);
    for (int x, v, la = 0; q--; ) &amp;#123;
        read(x), read(v), x ^= la;
        p[x][0][1] += v - a[x], a[x] = v;
        for (; x; ) &amp;#123;
            int fa = t[x].fa;
            if (fa &amp;amp;&amp;amp; x != t[fa].lc &amp;amp;&amp;amp; x != t[fa].rc) &amp;#123;
                int f0 = t[x].u[0][0], f1 = std::max(f0, t[x].u[0][1]);
                pushup(x);
                int F0 = t[x].u[0][0], F1 = std::max(F0, t[x].u[0][1]);
                p[fa][0][0] += F1 - f1, p[fa][1][0] += F1 - f1;
                p[fa][0][1] += F0 - f0;
            &amp;#125;
            else
                pushup(x);
            x = fa;
        &amp;#125;
        print(la = std::max(t[rt[1]].u[0][0], t[rt[1]].u[0][1]), &amp;#39;\n&amp;#39;);
    &amp;#125;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;p&gt;也给出一个线段树版本的&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int maxn = 1e6 + 5;
const int inf = 0x3f3f3f3f;
const int LEN = (1 &amp;lt;&amp;lt; 20);
int nec(void) &amp;#123;
    static char buf[LEN], *p = buf, *e = buf;
    if (p == e) &amp;#123;
        e = buf + fread(buf, 1, LEN, stdin);
        if (e == buf) return EOF;
        p = buf;
    &amp;#125;
    return *p++;
&amp;#125;
bool read(int &amp;amp;x) &amp;#123;
    x = 0;
    bool f = 0;
    char ch = nec();
    while (ch &amp;lt; &amp;#39;0&amp;#39; || ch &amp;gt; &amp;#39;9&amp;#39;) &amp;#123;
        if (ch == EOF) return 0;
        if (ch == &amp;#39;-&amp;#39;) f = 1;
        ch = nec();
    &amp;#125;
    while (ch &amp;gt;= &amp;#39;0&amp;#39; &amp;amp;&amp;amp; ch &amp;lt;= &amp;#39;9&amp;#39;) &amp;#123;
        x = x * 10 + ch - &amp;#39;0&amp;#39;;
        ch = nec();
    &amp;#125;
    if (f) x = -x;
    return 1;
&amp;#125;
void print(int x) &amp;#123;
    if (x &amp;lt; 0)
        putchar(&amp;#39;-&amp;#39;), x = -x;
    if (x &amp;gt;= 10) print(x / 10);
    putchar(x % 10 + &amp;#39;0&amp;#39;);
    return;
&amp;#125;
void print(int x, char ch) &amp;#123;
    print(x), putchar(ch);
    return;
&amp;#125;
struct mat &amp;#123;
    int a[2][2];
    int* operator[] (const int q) &amp;#123;
        return a[q];
    &amp;#125;
    mat operator* (mat q) const &amp;#123;
        mat res;
        res[0][0] = res[0][1] = res[1][0] = res[1][1] = -inf;
        for (int i = 0; i &amp;lt; 2; ++i)
            for (int k = 0; k &amp;lt; 2; ++k)
                for (int j = 0; j &amp;lt; 2; ++j)
                    res[i][k] = std::max(res[i][k], a[i][j] + q[j][k]);
        return res;
    &amp;#125;
    mat&amp;amp; operator*= (mat &amp;amp;q) &amp;#123;
        return *this = *this * q;
    &amp;#125;
&amp;#125;;
struct &amp;#123; int lc, rc, l, r, mid; mat u; &amp;#125; t[maxn &amp;lt;&amp;lt; 2]; 
int g[maxn][2], tab[maxn], ls[maxn];
#define lt t[p].lc
#define rt t[p].rc
void bld(int &amp;amp;p, int l, int r) &amp;#123;
    static int tot = 0;
    p = ++tot, t[p].l = l, t[p].r = r;
    if (l == r) &amp;#123;
        int u = tab[l];
        t[p].u[0][0] = t[p].u[1][0] = g[u][1];
        t[p].u[0][1] = g[u][0], t[p].u[1][1] = -inf;
        return;
    &amp;#125;
    int s = 0, u = ls[tab[l]];
    for (int i = l; i &amp;lt;= r; ++i)
        s += ls[tab[i]];
    s &amp;gt;&amp;gt;= 1;
    t[p].mid = r - 1;
    for (int i = l + 1; i &amp;lt; r; ++i) &amp;#123;
        u += ls[tab[i]];
        if (u + ls[tab[i + 1]] &amp;gt; s) &amp;#123;
            t[p].mid = i;
            break;
        &amp;#125;
    &amp;#125;
    bld(lt, l, t[p].mid), bld(rt, t[p].mid + 1, r);
    t[p].u = t[rt].u * t[lt].u;
    return;
&amp;#125;
void add(int p, int x) &amp;#123;
    if (t[p].l == t[p].r) &amp;#123;
        int u = tab[x];
        t[p].u[0][0] = t[p].u[1][0] = g[u][1];
        t[p].u[0][1] = g[u][0];
        return;
    &amp;#125;
    if (x &amp;lt;= t[p].mid)
        add(lt, x);
    else
        add(rt, x);
    t[p].u = t[rt].u * t[lt].u;
    return;
&amp;#125;
mat ask(int p, int l, int r) &amp;#123;
    if (l &amp;lt;= t[p].l &amp;amp;&amp;amp; t[p].r &amp;lt;= r)
        return t[p].u;
    if (r &amp;lt;= t[p].mid)
        return ask(lt, l, r);
    if (l &amp;gt; t[p].mid)
        return ask(rt, l, r);
    return ask(rt, l, r) * ask(lt, l, r);
&amp;#125;
#undef lt
#undef rt
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, q;
    read(n), read(q);
    std::vector&amp;lt;int&amp;gt; a(n + 1), rt(n + 1);
    for (int i = 1; i &amp;lt;= n; ++i)
        read(a[i]);
    std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; g1(n + 1);
    for (int i = 1, x, y; i &amp;lt; n; ++i) &amp;#123;
        read(x), read(y);
        g1[x].push_back(y), g1[y].push_back(x);
    &amp;#125;
    std::vector&amp;lt;int&amp;gt; siz(n + 1), son(n + 1), fa(n + 1);
    std::function&amp;lt;void(int)&amp;gt; DFS = [&amp;amp;](int x) &amp;#123;
        siz[x] = 1;
        for (auto i : g1[x])
            if (i != fa[x]) &amp;#123;
                fa[i] = x, DFS(i);
                siz[x] += siz[i];
                if (siz[i] &amp;gt; siz[son[x]])
                    son[x] = i;
            &amp;#125;
        return;
    &amp;#125;;
    DFS(1);
    std::vector&amp;lt;std::array&amp;lt;int, 2&amp;gt; &amp;gt; f(n + 1);
    std::vector&amp;lt;int&amp;gt; top(n + 1), bot(n + 1), dfn(n + 1);
    DFS = [&amp;amp;](int x) &amp;#123;
        static int now = 0;
        dfn[x] = ++now, tab[now] = x;
        ls[x] = 1;
        if (son[x]) &amp;#123;
            top[son[x]] = top[x], DFS(son[x]);
            bot[x] = bot[son[x]];
            g[x][0] = a[x];
            for (auto i : g1[x])
                if (i != son[x] &amp;amp;&amp;amp; i != fa[x]) &amp;#123;
                    top[i] = i, DFS(i);
                    ls[x] += siz[i];
                    g[x][0] += f[i][0];
                    g[x][1] += std::max(f[i][1], f[i][0]);
                &amp;#125;
            f[x][0] = g[x][1] + std::max(f[son[x]][0], f[son[x]][1]);
            f[x][1] = g[x][0] + f[son[x]][0];
        &amp;#125;
        else
            f[x][1] = g[x][0] = a[x], bot[x] = x;
        if (x == top[x])
            bld(rt[x], dfn[x], dfn[bot[x]]);
        return;
    &amp;#125;;
    top[1] = 1, DFS(1);
    for (int x, v, la = 0; q--; ) &amp;#123;
        read(x), read(v), x ^= la;
        g[x][0] -= a[x], g[x][0] += v, a[x] = v;
        for (; top[x] != 1; ) &amp;#123;
            auto r = t[rt[top[x]]].u;
            f[top[x]][0] = r[0][0], f[top[x]][1] = r[0][1];
            g[fa[top[x]]][0] -= f[top[x]][0];
            g[fa[top[x]]][1] -= std::max(f[top[x]][0], f[top[x]][1]);
            add(rt[top[x]], dfn[x]);
            r = t[rt[top[x]]].u;
            f[top[x]][0] = r[0][0], f[top[x]][1] = r[0][1];
            g[fa[top[x]]][0] += f[top[x]][0];
            g[fa[top[x]]][1] += std::max(f[top[x]][0], f[top[x]][1]);
            x = fa[top[x]];
        &amp;#125;
        add(rt[1], dfn[x]);
        auto r =  t[rt[1]].u;
        f[1][0] = r[0][0], f[1][1] = r[0][1];
        std::cout &amp;lt;&amp;lt; (la = std::max(f[1][0], f[1][1])) &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    &amp;#125;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;树上路径问题染色&#34;&gt;树上路径问题：染色&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P2486&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P2486&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;GBT 上的&lt;strong&gt;路径问题&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;BST：首先暴力爬山到 LCA，统计一路上的答案；然后跳到当前 BST 的根。由于本题有标记，所以需要在跳的同时想办法把标记问题解决一下。&lt;/p&gt;
&lt;p&gt;线段树：把树剖的线段树略改一下就过了。从上一行模棱两可的描述就可以看出来 BST 实现起来不太轻松；还是线段树更轮椅啊！&lt;/p&gt;
&lt;details&gt;
&lt;p&gt;跑得没纯树剖快，因为数据没有刻意构造导致树高很低，再加上常数的影响吧。&lt;/p&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int maxn = 1e5 + 5;
const int LEN = (1 &amp;lt;&amp;lt; 20);
int nec(void) &amp;#123;
    static char buf[LEN], *p = buf, *e = buf;
    if (p == e) &amp;#123;
        e = buf + fread(buf, 1, LEN, stdin);
        if (e == buf) return EOF;
        p = buf;
    &amp;#125;
    return *p++;
&amp;#125;
bool read(int &amp;amp;x) &amp;#123;
    x = 0;
    bool f = 0;
    char ch = nec();
    while (ch &amp;lt; &amp;#39;0&amp;#39; || ch &amp;gt; &amp;#39;9&amp;#39;) &amp;#123;
        if (ch == EOF) return 0;
        if (ch == &amp;#39;-&amp;#39;) f = 1;
        ch = nec();
    &amp;#125;
    while (ch &amp;gt;= &amp;#39;0&amp;#39; &amp;amp;&amp;amp; ch &amp;lt;= &amp;#39;9&amp;#39;) &amp;#123;
        x = x * 10 + ch - &amp;#39;0&amp;#39;;
        ch = nec();
    &amp;#125;
    if (f) x = -x;
    return 1;
&amp;#125;
void read(char &amp;amp;x) &amp;#123;
    for (x = nec(); x != &amp;#39;C&amp;#39; &amp;amp;&amp;amp; x != &amp;#39;Q&amp;#39;; x = nec());
    return;
&amp;#125;
void print(int x) &amp;#123;
    if (x &amp;lt; 0)
        putchar(&amp;#39;-&amp;#39;), x = -x;
    if (x &amp;gt;= 10) print(x / 10);
    putchar(x % 10 + &amp;#39;0&amp;#39;);
    return;
&amp;#125;
void print(int x, char ch) &amp;#123;
    print(x), putchar(ch);
    return;
&amp;#125;
class node &amp;#123;
private:
    int lt, rt;
public:
    int l, r, mid, lc, rc, u, d;
    node(): u(-1) &amp;#123;&amp;#125;
    inline int&amp;amp; ls(void) &amp;#123; return lt; &amp;#125;
    inline int&amp;amp; rs(void) &amp;#123; return rt; &amp;#125;
    node&amp;amp; operator= (const node &amp;amp;q) &amp;#123;
        lc = q.lc, rc = q.rc, u = q.u;
        return *this;
    &amp;#125;
    node operator+ (const node &amp;amp;q) const &amp;#123;
        if (u == -1)
            return q;
        if (q.u == -1)
            return *this;
        node res;
        res.lc = lc, res.rc = q.rc, res.u = u + q.u - (rc == q.lc);
        return res;
    &amp;#125;
    inline void swap(void) &amp;#123;
        if (~u)
            lc ^= rc ^= lc ^= rc;
        return;
    &amp;#125;
&amp;#125; t[maxn &amp;lt;&amp;lt; 2]; 
int tab[maxn], ls[maxn], a[maxn];
#define lt t[p].ls()
#define rt t[p].rs()
void bld(int &amp;amp;p, int l, int r) &amp;#123;
    static int tot = 0;
    p = ++tot, t[p].l = l, t[p].r = r;
    if (l == r) &amp;#123;
        t[p].u = 1;
        t[p].lc = t[p].rc = a[tab[l]];
        return;
    &amp;#125;
    int s = 0, u = ls[tab[l]];
    for (int i = l; i &amp;lt;= r; ++i)
        s += ls[tab[i]];
    s &amp;gt;&amp;gt;= 1;
    t[p].mid = r - 1;
    for (int i = l + 1; i &amp;lt; r; ++i) &amp;#123;
        u += ls[tab[i]];
        if (u + ls[tab[i + 1]] &amp;gt; s) &amp;#123;
            t[p].mid = i;
            break;
        &amp;#125;
    &amp;#125;
    bld(lt, l, t[p].mid), bld(rt, t[p].mid + 1, r);
    t[p] = t[lt] + t[rt];
    return;
&amp;#125;
void pushdown(int p) &amp;#123;
    if (t[p].d) &amp;#123;
        t[lt].d = t[lt].lc = t[lt].rc = t[rt].d = t[rt].lc = t[rt].rc = t[p].d;
        t[lt].u = t[rt].u = 1;
        t[p].d = 0;
    &amp;#125;
    return;
&amp;#125;
void add(int p, int l, int r, int v) &amp;#123;
    if (l &amp;lt;= t[p].l &amp;amp;&amp;amp; t[p].r &amp;lt;= r) &amp;#123;
        t[p].u = 1;
        t[p].lc = t[p].rc = t[p].d = v;
        return;
    &amp;#125;
    pushdown(p);
    if (l &amp;lt;= t[p].mid)
        add(lt, l, r, v);
    if (r &amp;gt; t[p].mid)
        add(rt, l, r, v);
    t[p] = t[lt] + t[rt];
    return;
&amp;#125;
node ask(int p, int l, int r) &amp;#123;
    if (l &amp;lt;= t[p].l &amp;amp;&amp;amp; t[p].r &amp;lt;= r)
        return t[p];
    pushdown(p);
    if (r &amp;lt;= t[p].mid)
        return ask(lt, l, r);
    if (l &amp;gt; t[p].mid)
        return ask(rt, l, r);
    return ask(lt, l, r) + ask(rt, l, r);
&amp;#125;
#undef lt
#undef rt
int main() &amp;#123;
#ifdef ONLINE_JUDGE
#else
    std::freopen(&amp;quot;paint17.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, q;
    read(n), read(q);
    std::vector&amp;lt;int&amp;gt; rt(n + 1);
    for (int i = 1; i &amp;lt;= n; ++i)
        read(a[i]);
    std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; g(n + 1);
    for (int i = 1, x, y; i &amp;lt; n; ++i) &amp;#123;
        read(x), read(y);
        g[x].push_back(y), g[y].push_back(x);
    &amp;#125;
    std::vector&amp;lt;int&amp;gt; siz(n + 1), son(n + 1), fa(n + 1), dep(n + 1);
    std::function&amp;lt;void(int)&amp;gt; DFS = [&amp;amp;](int x) &amp;#123;
        siz[x] = 1;
        for (auto i : g[x])
            if (i != fa[x]) &amp;#123;
                dep[i] = dep[x] + 1;
                fa[i] = x, DFS(i);
                siz[x] += siz[i];
                if (siz[i] &amp;gt; siz[son[x]])
                    son[x] = i;
            &amp;#125;
        return;
    &amp;#125;;
    DFS(1);
    std::vector&amp;lt;std::array&amp;lt;int, 2&amp;gt; &amp;gt; f(n + 1);
    std::vector&amp;lt;int&amp;gt; top(n + 1), bot(n + 1), dfn(n + 1);
    DFS = [&amp;amp;](int x) &amp;#123;
        static int now = 0;
        dfn[x] = ++now, tab[now] = x, ls[x] = 1;
        if (son[x]) &amp;#123;
            top[son[x]] = top[x], DFS(son[x]);
            bot[x] = bot[son[x]];
        &amp;#125;
        else
            bot[x] = x;
        for (auto i : g[x])
            if (i != son[x] &amp;amp;&amp;amp; i != fa[x]) &amp;#123;
                top[i] = i;
                DFS(i);
                ls[x] += siz[i];
            &amp;#125;
        if (x == top[x])
            bld(rt[x], dfn[x], dfn[bot[x]]);
        return;
    &amp;#125;;
    top[1] = 1, DFS(1);
    for (char op; q--; ) &amp;#123;
        read(op);
        if (op == &amp;#39;C&amp;#39;) &amp;#123;
            int x, y, c;
            read(x), read(y), read(c);
            for (; top[x] != top[y]; x = fa[top[x]]) &amp;#123;
                if (dep[top[x]] &amp;lt; dep[top[y]])
                    std::swap(x, y);
                add(rt[top[x]], dfn[top[x]], dfn[x], c);
            &amp;#125;
            if (dep[x] &amp;gt; dep[y])
                std::swap(x, y);
            add(rt[top[x]], dfn[x], dfn[y], c);
        &amp;#125;
        else &amp;#123;
            int x, y;
            read(x), read(y);
            node res1, res2;
            for (; top[x] != top[y]; )
                if (dep[top[x]] &amp;lt; dep[top[y]]) &amp;#123;
                    res2 = ask(rt[top[y]], dfn[top[y]], dfn[y]) + res2;
                    y = fa[top[y]];
                &amp;#125;
                else &amp;#123;
                    res1 = ask(rt[top[x]], dfn[top[x]], dfn[x]) + res1;
                    x = fa[top[x]];
                &amp;#125;
            if (dep[x] &amp;gt; dep[y])
                res1 = ask(rt[top[y]], dfn[y], dfn[x]) + res1;
            else
                res2 = ask(rt[top[x]], dfn[x], dfn[y]) + res2;
            res1.swap();
            print((res1 + res2).u, &amp;#39;\n&amp;#39;);
        &amp;#125;
    &amp;#125;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;树上路径查询&#34;&gt;树上路径查询？&lt;/h3&gt;
&lt;p&gt;做题的时候可以感受到，路径询问的存在很诡异，因为只需要一条链的操作，更偏向链上 DDP 而非树上的；&lt;strong&gt;轻儿子的信息是不用维护的&lt;/strong&gt;，形式上更像树剖（DS）；当成链上的 DDP 就可以解决了。&lt;/p&gt;
&lt;p&gt;可以用倍增维护 DDP（不用考虑轻重儿子，只用维护父子关系，进一步向序列 DDP 靠近），就不用打 GBT 了，常数也会小一些。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;习题&#34;&gt;习题&lt;/h2&gt;
&lt;p&gt;GBT 就统一用线段树了。DDP 也就可以顺带用 GBT 优化了。&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;e---猫或狗-cats-or-dogs&#34;&gt;E - 猫或狗 / Cats or Dogs&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P9597&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P9597&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;设 &lt;span class=&#34;math inline&#34;&gt;\(f_{u,0/1}\)&lt;/span&gt; 表示从根上颜色为 &lt;span class=&#34;math inline&#34;&gt;\(0/1\)&lt;/span&gt; 时的最小断边数，显然无色可以视作任选一个颜色。那么有：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
f_{u,a}=\sum\limits_v\min\limits_{b\in\{0,1\}}\{f_{v,b}+[a\ne b]\}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;直接把轻儿子的项提出来，记 &lt;span class=&#34;math inline&#34;&gt;\(g_{u,0/1}\)&lt;/span&gt; 表示 &lt;span class=&#34;math inline&#34;&gt;\(f_{u,0/1}\)&lt;/span&gt; 对应的轻儿子贡献即可。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int maxn = 1e5 + 5;
const int inf = 0x3f3f3f3f;
struct mat &amp;#123;
    int a[2][2];
    int* operator[] (const int q) &amp;#123; 
        return a[q];
    &amp;#125;
    mat operator* (mat &amp;amp;q) const &amp;#123;
        mat res;
        res[0][0] = res[0][1] = res[1][0] = res[1][1] = inf;
        for (int i = 0; i &amp;lt; 2; ++i)
            for (int k = 0; k &amp;lt; 2; ++k)
                for (int j = 0; j &amp;lt; 2; ++j)
                    res[i][k] = std::min(res[i][k], a[i][j] + q[j][k]);
        return res;
    &amp;#125;
    mat&amp;amp; operator*= (mat &amp;amp;q) &amp;#123;
        return *this = *this * q;
    &amp;#125;
&amp;#125; p[maxn];
struct &amp;#123; int lc, rc, l, r, mid; mat u; &amp;#125; t[maxn &amp;lt;&amp;lt; 2]; 
int ls[maxn], tab[maxn], g[maxn][2], rt[maxn], top[maxn], dfn[maxn], fa[maxn];
std::vector&amp;lt;int&amp;gt; a;
#define lt t[p].lc
#define rt t[p].rc
void bld(int &amp;amp;p, int l, int r) &amp;#123;
    static int tot = 0;
    p = ++tot, t[p].l = l, t[p].r = r;
    if (l == r) &amp;#123;
        t[p].u[0][1] = t[p].u[1][0] = 1;
        return;
    &amp;#125;
    int s = 0, u = ls[tab[l]];
    for (int i = l; i &amp;lt;= r; ++i)
        s += ls[tab[i]];
    s &amp;gt;&amp;gt;= 1;
    t[p].mid = r - 1;
    for (int i = l + 1; i &amp;lt; r; ++i) &amp;#123;
        u += ls[tab[i]];
        if (u + ls[tab[i + 1]] &amp;gt; s) &amp;#123;
            t[p].mid = i;
            break;
        &amp;#125;
    &amp;#125;
    bld(lt, l, t[p].mid), bld(rt, t[p].mid + 1, r);
    t[p].u = t[rt].u * t[lt].u;
    return;
&amp;#125;
void add(int p, int x) &amp;#123;
    if (t[p].l == t[p].r) &amp;#123;
        int u = tab[x], g0 = (a[u] == 1 ? inf : g[u][0]), g1 = (a[u] == 0 ? inf : g[u][1]);
        t[p].u[0][0] = g0, t[p].u[0][1] = g1 + 1;
        t[p].u[1][0] = g0 + 1, t[p].u[1][1] = g1;
        return;
    &amp;#125;
    if (x &amp;lt;= t[p].mid)
        add(lt, x);
    else
        add(rt, x);
    t[p].u = t[rt].u * t[lt].u;
    return;
&amp;#125;
#undef lt
#undef rt
void initialize(int n, std::vector&amp;lt;int&amp;gt; A, std::vector&amp;lt;int&amp;gt; B) &amp;#123;
    a.assign(n + 1, -1);
    std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; g1(n + 1);
    for (int i = 0; i &amp;lt; n - 1; ++i)
        g1[A[i]].push_back(B[i]), g1[B[i]].push_back(A[i]);
    std::vector&amp;lt;int&amp;gt; siz(n + 1), son(n + 1);
    std::function&amp;lt;void(int)&amp;gt; DFS = [&amp;amp;](int x) &amp;#123;
        siz[x] = 1;
        for (auto i : g1[x])
            if (i != fa[x]) &amp;#123;
                fa[i] = x, DFS(i);
                siz[x] += siz[i];
                if (siz[i] &amp;gt; siz[son[x]])
                    son[x] = i;
            &amp;#125;
        return;
    &amp;#125;;
    DFS(1);
    std::vector&amp;lt;int&amp;gt; bot(n + 1);
    DFS = [&amp;amp;](int x) &amp;#123;
        static int now = 0;
        dfn[x] = ++now, tab[now] = x, ls[x] = 1;
        if (son[x]) &amp;#123;
            top[son[x]] = top[x], DFS(son[x]);
            bot[x] = bot[son[x]];
            for (auto i : g1[x])
                if (i != son[x] &amp;amp;&amp;amp; i != fa[x]) &amp;#123;
                    top[i] = i, DFS(i);
                    ls[x] += siz[i];
                &amp;#125;
        &amp;#125;
        else
            bot[x] = x;
        if (x == top[x])
            bld(rt[x], dfn[x], dfn[bot[x]]);
        return;
    &amp;#125;;
    top[1] = 1, DFS(1);
    return;
&amp;#125;
int upd(int x) &amp;#123;
    for (; top[x] != 1; ) &amp;#123;
        int faa = fa[top[x]];
        auto &amp;amp;id = t[rt[top[x]]].u;
        int f0 = std::min(id[0][0], id[1][0]), f1 = std::min(id[0][1], id[1][1]);
        g[faa][0] -= std::min(f0, f1 + 1);
        g[faa][1] -= std::min(f0 + 1, f1);
        add(rt[top[x]], dfn[x]);
        f0 = std::min(id[0][0], id[1][0]), f1 = std::min(id[0][1], id[1][1]);
        // printf(&amp;quot;%d: f0 = %d, f1 = %d\n&amp;quot;, top[x], f0, f1);
        g[faa][0] += std::min(f0, f1 + 1);
        g[faa][1] += std::min(f0 + 1, f1);
        x = faa;
    &amp;#125;
    add(rt[1], dfn[x]);
    auto &amp;amp;id = t[rt[1]].u;
    int f0 = std::min(id[0][0], id[1][0]), f1 = std::min(id[0][1], id[1][1]);
    // printf(&amp;quot;%d: f0 = %d, f1 = %d\n&amp;quot;, 1, f0, f1);
    return std::min(f0, f1);
&amp;#125;
int cat(int x) &amp;#123;
    a[x] = 0;
    return upd(x);
&amp;#125;
int dog(int x) &amp;#123;
    a[x] = 1;
    return upd(x);
&amp;#125;
int neighbor(int x) &amp;#123;
    a[x] = -1;
    return upd(x);
&amp;#125;
#ifndef ONLINE_JUDGE
int main() &amp;#123;
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
    int n;
    std::cin &amp;gt;&amp;gt; n;
    std::vector&amp;lt;int&amp;gt; A(n - 1), B(n - 1);
    for (int i = 0; i &amp;lt; n - 1; ++i)
        std::cin &amp;gt;&amp;gt; A[i] &amp;gt;&amp;gt; B[i];
    initialize(n, A, B);
    int q;
    std::cin &amp;gt;&amp;gt; q;
    for (int op, x; q--; ) &amp;#123;
        std::cin &amp;gt;&amp;gt; op &amp;gt;&amp;gt; x;
        std::cout &amp;lt;&amp;lt; (op == 1 ? cat(x) : (op == 2 ? dog(x) : neighbor(x))) &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    &amp;#125;
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
    return 0;
&amp;#125;
#endif&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;f---hash-on-tree&#34;&gt;F - Hash on Tree&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/AT_abc351_g&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/AT_abc351_g&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;记 &lt;span class=&#34;math inline&#34;&gt;\(g_x\)&lt;/span&gt; 为轻儿子的哈希值之积，则 &lt;span class=&#34;math inline&#34;&gt;\(f_u=A_u+f_{son}\cdot g_u\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;然后开一个常数维即可。快速幂的 log 省不掉，所以是双 log 的。&lt;/p&gt;
&lt;p&gt;初值和修改都有可能为 &lt;span class=&#34;math inline&#34;&gt;\(0\)&lt;/span&gt;，需要维护实际哈希值和去掉 &lt;span class=&#34;math inline&#34;&gt;\(0\)&lt;/span&gt; 的哈希值。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int maxn = 1e6 + 5;
const int LEN = (1 &amp;lt;&amp;lt; 20);
const int mod = 998244353;
int nec(void) &amp;#123;
    static char buf[LEN], *p = buf, *e = buf;
    if (p == e) &amp;#123;
        e = buf + fread(buf, 1, LEN, stdin);
        if (e == buf) return EOF;
        p = buf;
    &amp;#125;
    return *p++;
&amp;#125;
bool read(int &amp;amp;x) &amp;#123;
    x = 0;
    bool f = 0;
    char ch = nec();
    while (ch &amp;lt; &amp;#39;0&amp;#39; || ch &amp;gt; &amp;#39;9&amp;#39;) &amp;#123;
        if (ch == EOF) return 0;
        if (ch == &amp;#39;-&amp;#39;) f = 1;
        ch = nec();
    &amp;#125;
    while (ch &amp;gt;= &amp;#39;0&amp;#39; &amp;amp;&amp;amp; ch &amp;lt;= &amp;#39;9&amp;#39;) &amp;#123;
        x = x * 10 + ch - &amp;#39;0&amp;#39;;
        ch = nec();
    &amp;#125;
    if (f) x = -x;
    return 1;
&amp;#125;
void print(int x) &amp;#123;
    if (x &amp;lt; 0)
        putchar(&amp;#39;-&amp;#39;), x = -x;
    if (x &amp;gt;= 10) print(x / 10);
    putchar(x % 10 + &amp;#39;0&amp;#39;);
    return;
&amp;#125;
void print(int x, char ch) &amp;#123;
    print(x), putchar(ch);
    return;
&amp;#125;
struct mat &amp;#123;
    int n, m;
    long long a[2][2];
    long long* operator[] (const int q) &amp;#123;
        return a[q];
    &amp;#125;
    mat operator* (mat &amp;amp;q) const &amp;#123;
        mat res;
        res.n = n, res.m = q.m;
        res[0][0] = res[0][1] = res[1][0] = res[1][1] = 0ll;
        for (int i = 0; i &amp;lt; n; ++i)
            for (int k = 0; k &amp;lt; q.m; ++k) &amp;#123;
                for (int j = 0; j &amp;lt; m; ++j)
                    res[i][k] += a[i][j] * q[j][k];
                res[i][k] %= mod;
            &amp;#125;
        return res;
    &amp;#125;
    mat&amp;amp; operator*= (mat &amp;amp;q) &amp;#123;
        return *this = *this * q;
    &amp;#125;
&amp;#125;;
struct &amp;#123; int lc, rc, l, r, mid; mat u; &amp;#125; t[maxn &amp;lt;&amp;lt; 2]; 
long long g[maxn];
int tab[maxn], ls[maxn], a[maxn];
#define lt t[p].lc
#define rt t[p].rc
void bld(int &amp;amp;p, int l, int r) &amp;#123;
    static int tot = 0;
    p = ++tot, t[p].l = l, t[p].r = r;
    if (l == r) &amp;#123;
        int u = tab[l];
        t[p].u.n = t[p].u.m = 2;
        t[p].u[0][0] = g[u];
        t[p].u[0][1] = 0ll;
        t[p].u[1][0] = a[u];
        t[p].u[1][1] = 1ll;
        return;
    &amp;#125;
    int s = 0, u = ls[tab[l]];
    for (int i = l; i &amp;lt;= r; ++i)
        s += ls[tab[i]];
    s &amp;gt;&amp;gt;= 1;
    t[p].mid = r - 1;
    for (int i = l + 1; i &amp;lt; r; ++i) &amp;#123;
        u += ls[tab[i]];
        if (u + ls[tab[i + 1]] &amp;gt; s) &amp;#123;
            t[p].mid = i;
            break;
        &amp;#125;
    &amp;#125;
    bld(lt, l, t[p].mid), bld(rt, t[p].mid + 1, r);
    t[p].u = t[rt].u * t[lt].u;
    return;
&amp;#125;
void add(int p, int x) &amp;#123;
    if (t[p].l == t[p].r) &amp;#123;
        int u = tab[x];
        t[p].u[0][0] = g[u];
        t[p].u[1][0] = a[u];
        return;
    &amp;#125;
    if (x &amp;lt;= t[p].mid)
        add(lt, x);
    else
        add(rt, x);
    t[p].u = t[rt].u * t[lt].u;
    return;
&amp;#125;
#undef lt
#undef rt
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, q;
    read(n), read(q);
    std::vector&amp;lt;int&amp;gt; rt(n + 1);
    std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; g1(n + 1);
    for (int i = 2, x; i &amp;lt;= n; ++i) &amp;#123;
        read(x);
        g1[i].push_back(x), g1[x].push_back(i);
    &amp;#125;
    for (int i = 1; i &amp;lt;= n; ++i)
        read(a[i]);
    std::vector&amp;lt;int&amp;gt; siz(n + 1), son(n + 1), fa(n + 1);
    std::function&amp;lt;void(int)&amp;gt; DFS = [&amp;amp;](int x) &amp;#123;
        siz[x] = 1;
        for (auto i : g1[x])
            if (i != fa[x]) &amp;#123;
                fa[i] = x, DFS(i);
                siz[x] += siz[i];
                if (siz[i] &amp;gt; siz[son[x]])
                    son[x] = i;
            &amp;#125;
        return;
    &amp;#125;;
    DFS(1);
    std::vector&amp;lt;long long&amp;gt; f(n + 1);
    std::vector&amp;lt;int&amp;gt; top(n + 1), bot(n + 1), dfn(n + 1), la(n + 1), cnt(n + 1);
    DFS = [&amp;amp;](int x) &amp;#123;
        static int now = 0;
        dfn[x] = ++now, tab[now] = x, ls[x] = 1;
        if (son[x]) &amp;#123;
            top[son[x]] = top[x], DFS(son[x]);
            bot[x] = bot[son[x]];
            g[x] = 1ll;
            for (auto i : g1[x])
                if (i != son[x] &amp;amp;&amp;amp; i != fa[x]) &amp;#123;
                    top[i] = i, DFS(i);
                    ls[x] += siz[i];
                    if (f[i] == 0ll)
                        ++cnt[x];
                    else
                        (la[x] *= f[i]) %= mod;
                    (g[x] *= f[i]) %= mod;
                &amp;#125;
            f[x] = (a[x] + g[x] * f[son[x]]) % mod;
        &amp;#125;
        else
            f[x] = a[x], bot[x] = x;
        // printf(&amp;quot;f[%d] = %lld\n&amp;quot;, x, f[x]);
        if (x == top[x])
            bld(rt[x], dfn[x], dfn[bot[x]]);
        return;
    &amp;#125;;
    top[1] = 1, DFS(1);
    mat init;
    init.n = 1, init.m = 2;
    init[0][0] = 0ll, init[0][1] = 1ll;
    auto qkp = [&amp;amp;](long long x, int y) &amp;#123;
        auto res(1ll);
        for (; y; (x *= x) %= mod, y &amp;gt;&amp;gt;= 1)
            if (y &amp;amp; 1)
                (res *= x) %= mod;
        return res;
    &amp;#125;;
    auto inv = [&amp;amp;](int x) &amp;#123;
        return qkp(x, mod - 2);
    &amp;#125;;
    for (int x, v; q--; ) &amp;#123;
        read(x), read(v);
        a[x] = v;
        for (; top[x] != 1; ) &amp;#123;
            int faa = fa[top[x]];
            auto &amp;amp;id = t[rt[top[x]]].u;
            int f = (init * id)[0][0];
            if (f == 0) &amp;#123;
                if (--cnt[faa] == 0)
                    g[faa] = la[faa];
            &amp;#125;
            else &amp;#123;
                f = inv(f);
                (g[faa] *= f) %= mod;
                (la[faa] *= f) %= mod;
            &amp;#125;
            add(rt[top[x]], dfn[x]);
            f = (init * id)[0][0];
            if (f == 0) &amp;#123;
                if (cnt[faa]++ == 0)
                    la[faa] = g[faa];
                g[faa] = 0ll;
            &amp;#125;
            else &amp;#123;
                (g[faa] *= f) %= mod;
                (la[faa] *= f) %= mod;
            &amp;#125;
            x = faa;
        &amp;#125;
        add(rt[1], dfn[x]);
        auto &amp;amp;id = t[rt[1]].u;
        int f = (init * id)[0][0];
        std::cout &amp;lt;&amp;lt; f &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    &amp;#125;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;g---考试-2&#34;&gt;G - 考试 2&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P10626&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P10626&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;运算均是线性的，容易想到『按位』维护，即只维护某个特定点值。如果将询问离线下来排序，每个函数的点值只会变化 &lt;span class=&#34;math inline&#34;&gt;\(O(1)\)&lt;/span&gt; 次。&lt;/p&gt;
&lt;p&gt;建出符号二叉树，进行 DDP 即可。具体地，令 &lt;span class=&#34;math inline&#34;&gt;\(f_u\)&lt;/span&gt; 表示在运算 &lt;span class=&#34;math inline&#34;&gt;\(u\)&lt;/span&gt; 处的答案，计算 &lt;span class=&#34;math inline&#34;&gt;\(g_u\)&lt;/span&gt; 为轻儿子的答案，按照 &lt;span class=&#34;math inline&#34;&gt;\(u\)&lt;/span&gt; 处的符号写矩阵即可。叶子不是一次运算，应该直接填入点值（注意线段树上的叶子不一定是原树上的叶子）。&lt;/p&gt;
&lt;p&gt;建树和矩阵更新有点史，适当封装一下感觉会好一点&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int maxn = 1e6 + 5;
const char mp[] = &amp;quot;x!&amp;amp;|^&amp;quot;;
const int LEN = (1 &amp;lt;&amp;lt; 20);
#define nec getchar
inline bool read(int &amp;amp;x) &amp;#123;
    x = 0;
    bool f = 0;
    char ch = nec();
    while (ch &amp;lt; &amp;#39;0&amp;#39; || ch &amp;gt; &amp;#39;9&amp;#39;) &amp;#123;
        if (ch == EOF) return 0;
        if (ch == &amp;#39;-&amp;#39;) f = 1;
        ch = nec();
    &amp;#125;
    while (ch &amp;gt;= &amp;#39;0&amp;#39; &amp;amp;&amp;amp; ch &amp;lt;= &amp;#39;9&amp;#39;) &amp;#123;
        x = x * 10 + ch - &amp;#39;0&amp;#39;;
        ch = nec();
    &amp;#125;
    if (f) x = -x;
    return 1;
&amp;#125;
void print(int x) &amp;#123;
    if (x &amp;lt; 0)
        putchar(&amp;#39;-&amp;#39;), x = -x;
    if (x &amp;gt;= 10) print(x / 10);
    putchar(x % 10 + &amp;#39;0&amp;#39;);
    return;
&amp;#125;
void print(int x, char ch) &amp;#123;
    print(x), putchar(ch);
    return;
&amp;#125;
struct mat &amp;#123;
    int n, m;
    int a[2][2];
    int* operator[] (const int q) &amp;#123;
        return a[q];
    &amp;#125;
    inline mat operator* (mat &amp;amp;q) const &amp;#123;
        mat res;
        res.n = n, res.m = q.m;
        res[0][0] = res[0][1] = res[1][0] = res[1][1] = 0ll;
        for (int i = 0; i &amp;lt; n; ++i)
            for (int k = 0; k &amp;lt; q.m; ++k)
                for (int j = 0; j &amp;lt; m; ++j)
                    res[i][k] += a[i][j] * q[j][k];
        return res;
    &amp;#125;
    mat&amp;amp; operator*= (mat &amp;amp;q) &amp;#123;
        return *this = *this * q;
    &amp;#125;
&amp;#125;;
struct &amp;#123; int lc, rc, l, r, mid; mat u; &amp;#125; t[maxn &amp;lt;&amp;lt; 2]; 
int g1[maxn][2];
int g[maxn], ty[maxn];
int tab[maxn], ls[maxn], lim[maxn];
#define lt t[p].lc
#define rt t[p].rc
void fillmat(mat &amp;amp;a, int op, int g) &amp;#123;
    if (op == 0) &amp;#123;
        a.n = 1, a.m = 2;
        a[0][!g] = 0, a[0][g] = 1;
        return;
    &amp;#125;
    a.n = 2, a.m = 2;
    switch (op) &amp;#123;
    case 1: // !
        a[0][0] = 0, a[0][1] = 1;
        a[1][0] = 1, a[1][1] = 0;
        break;
    case 2: // &amp;amp;
        a[0][0] = 1, a[0][1] = 0;
        a[1][0] = !g, a[1][1] = g;
        break;
    case 3: // |
        a[0][0] = !g, a[0][1] = g;
        a[1][0] = 0, a[1][1] = 1;
        break;
    case 4: // ^
        a[0][0] = !g, a[0][1] = g;
        a[1][0] = g, a[1][1] = !g;
        break;
    default:
        assert(0);
    &amp;#125;
    return;
&amp;#125;
void bld(int &amp;amp;p, int l, int r) &amp;#123;
    static int tot = 0;
    p = ++tot, t[p].l = l, t[p].r = r;
    if (l == r) &amp;#123;
        fillmat(t[p].u, ty[tab[l]], g[tab[l]]);
        return;
    &amp;#125;
    int s = 0, u = ls[tab[l]];
    for (int i = l; i &amp;lt;= r; ++i)
        s += ls[tab[i]];
    s &amp;gt;&amp;gt;= 1;
    t[p].mid = r - 1;
    for (int i = l + 1; i &amp;lt; r; ++i) &amp;#123;
        u += ls[tab[i]];
        if (u + ls[tab[i + 1]] &amp;gt; s) &amp;#123;
            t[p].mid = i;
            break;
        &amp;#125;
    &amp;#125;
    bld(lt, l, t[p].mid), bld(rt, t[p].mid + 1, r);
    t[p].u = t[rt].u * t[lt].u;
    return;
&amp;#125;
void add(int p, int x) &amp;#123;
    if (t[p].l == t[p].r) &amp;#123;
        fillmat(t[p].u, ty[tab[t[p].l]], g[tab[t[p].l]]);
        return;
    &amp;#125;
    if (x &amp;lt;= t[p].mid)
        add(lt, x);
    else
        add(rt, x);
    t[p].u = t[rt].u * t[lt].u;
    return;
&amp;#125;
#undef lt
#undef rt
int main() &amp;#123;
#ifndef ONLINE_JUDGE
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n = 0, q, p;
    read(q), read(q);
    &amp;#123;
        std::string s;
        std::cin &amp;gt;&amp;gt; s;
        std::stringstream in(s);
        std::stack&amp;lt;char&amp;gt; op;
        std::stack&amp;lt;int&amp;gt; id;
        auto trans = [&amp;amp;](char t) &amp;#123;
            switch (t) &amp;#123;
            case &amp;#39;!&amp;#39;:
                return 1;
            case &amp;#39;&amp;amp;&amp;#39;:
                return 2;
            case &amp;#39;|&amp;#39;:
                return 3;
            case &amp;#39;^&amp;#39;:
                return 4;
            &amp;#125;
            assert(0);
            return -1;
        &amp;#125;;
        auto calcNot = [&amp;amp;](void) &amp;#123;
            for (; !op.empty() &amp;amp;&amp;amp; op.top() == &amp;#39;!&amp;#39;; ) &amp;#123;
                ty[++n] = trans(op.top());
                g1[n][0] = id.top(), id.pop(), id.push(n);
                op.pop();
            &amp;#125;
            return;
        &amp;#125;;
        auto opt = [&amp;amp;](void) &amp;#123;
            ty[++n] = trans(op.top());
            g1[n][0] = id.top(), id.pop();
            g1[n][1] = id.top(), id.pop();
            id.push(n), op.pop();
            return;
        &amp;#125;;
        for (char t; in &amp;gt;&amp;gt; t; )
            if (t == &amp;#39;[&amp;#39;) &amp;#123;
                int x;
                in &amp;gt;&amp;gt; x, in &amp;gt;&amp;gt; t;
                lim[++n] = x - 1;
                id.push(n), calcNot();
            &amp;#125;
            else if (t == &amp;#39;(&amp;#39;)
                op.push(t);
            else if (t == &amp;#39;)&amp;#39;) &amp;#123;
                for (; op.top() != &amp;#39;(&amp;#39;; opt());
                op.pop(), calcNot();
            &amp;#125;
            else if (t == &amp;#39;&amp;amp;&amp;#39;)
                op.push(t);
            else if (t == &amp;#39;^&amp;#39;) &amp;#123;
                for (; !op.empty() &amp;amp;&amp;amp; op.top() == &amp;#39;&amp;amp;&amp;#39;; opt());
                op.push(t);
            &amp;#125;
            else if (t == &amp;#39;|&amp;#39;) &amp;#123;
                for (; !op.empty() &amp;amp;&amp;amp; (op.top() == &amp;#39;&amp;amp;&amp;#39; || op.top() == &amp;#39;^&amp;#39;); opt());
                op.push(t);
            &amp;#125;
            else &amp;#123;
                assert(t == &amp;#39;!&amp;#39;);
                op.push(t);
            &amp;#125;
        for (; !op.empty(); opt());
        p = id.top();
    &amp;#125;
    std::vector&amp;lt;int&amp;gt; rt(n + 1);
    std::vector&amp;lt;int&amp;gt; siz(n + 1), son(n + 1), fa(n + 1);
    std::function&amp;lt;void(int)&amp;gt; DFS = [&amp;amp;](int x) &amp;#123;
        siz[x] = 1;
        for (auto i : g1[x])
            if (i != 0) &amp;#123;
                fa[i] = x, DFS(i);
                siz[x] += siz[i];
                if (siz[i] &amp;gt; siz[son[x]])
                    son[x] = i;
            &amp;#125;
        return;
    &amp;#125;;
    DFS(p);
    std::vector&amp;lt;long long&amp;gt; f(n + 1);
    std::vector&amp;lt;int&amp;gt; top(n + 1), bot(n + 1), dfn(n + 1);
    DFS = [&amp;amp;](int x) &amp;#123;
        static int now = 0;
        dfn[x] = ++now, tab[now] = x, ls[x] = 1;
        if (son[x]) &amp;#123;
            top[son[x]] = top[x], DFS(son[x]);
            bot[x] = bot[son[x]];
            for (auto i : g1[x])
                if (i != son[x] &amp;amp;&amp;amp; i != 0) &amp;#123;
                    top[i] = i, DFS(i);
                    ls[x] += siz[i], g[x] = f[i];
                &amp;#125;
            switch (ty[x]) &amp;#123;
            case 1:
                f[x] = !f[son[x]];
                break;
            case 2:
                f[x] = g[x] &amp;amp; f[son[x]];
                break;
            case 3:
                f[x] = g[x] | f[son[x]];
                break;
            case 4:
                f[x] = g[x] ^ f[son[x]];
                break;
            default:
                assert(0);
                break;
            &amp;#125;
        &amp;#125;
        else
            assert(!ty[x]), f[x] = g[x] = 0, bot[x] = x;
        if (x == top[x])
            bld(rt[x], dfn[x], dfn[bot[x]]);
        return;
    &amp;#125;;
    top[p] = p, DFS(p);
    std::vector&amp;lt;int&amp;gt; a(q + 1), res(q + 1);
    for (int i = 1; i &amp;lt;= q; ++i)
        read(a[i]);
    std::vector&amp;lt;int&amp;gt; qid(q), nid;
    for (int i = 1; i &amp;lt;= n; ++i)
        if (ty[i] == 0)
            nid.push_back(i);
    std::iota(qid.begin(), qid.end(), 1);
    std::sort(qid.begin(), qid.end(), [&amp;amp;](int x, int y) &amp;#123; return a[x] &amp;lt; a[y]; &amp;#125;);
    std::sort(nid.begin(), nid.end(), [&amp;amp;](int x, int y) &amp;#123; return lim[x] &amp;gt; lim[y]; &amp;#125;);
    for (auto i : qid) &amp;#123;
        for (; !nid.empty() &amp;amp;&amp;amp; lim[nid.back()] &amp;lt; a[i]; ) &amp;#123;
            int x = nid.back();
            nid.pop_back();
            g[x] = 1;
            for (; top[x] != p; ) &amp;#123;
                add(rt[top[x]], dfn[x]);
                g[fa[top[x]]] = t[rt[top[x]]].u[0][1];
                x = fa[top[x]];
            &amp;#125;
            add(rt[p], dfn[x]);
        &amp;#125;
        res[i] = t[rt[p]].u[0][1];
    &amp;#125;
    for (int i = 1; i &amp;lt;= q; ++i)
        if (res[i])
            std::cout &amp;lt;&amp;lt; &amp;quot;True\n&amp;quot;;
        else
            std::cout &amp;lt;&amp;lt; &amp;quot;False\n&amp;quot;;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://xsc062.netlify.app/20250510/</guid>
            <title>杂题</title>
            <link>https://xsc062.netlify.app/20250510/</link>
            <category>DP</category>
            <category>容斥原理</category>
            <category>树链剖分</category>
            <category>反悔贪心</category>
            <pubDate>Sat, 10 May 2025 10:18:21 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;啊啊。小封条。&lt;/p&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;a---pass-to-next&#34;&gt;A - Pass to Next&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/arc124/tasks/arc124_e&#34; class=&#34;uri&#34;&gt;https://atcoder.jp/contests/arc124/tasks/arc124_e&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;感觉其他一些题解讲得不是特别清楚，这里参考了 &lt;a href=&#34;https://blog.csdn.net/weixin_43960287/article/details/119140590&#34;&gt;XJX 的文章&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;要求的答案是 &lt;span class=&#34;math inline&#34;&gt;\(\prod a&amp;#39;_i\)&lt;/span&gt;，&lt;mark&gt;发现运算是乘法，比较怪；由此考虑转化为方案数，也就是假设每个人有 &lt;span class=&#34;math inline&#34;&gt;\(a&amp;#39;_i\)&lt;/span&gt; 个互不相同的球，每个人在其中选出恰好一个的方案数&lt;/mark&gt;。&lt;/p&gt;
&lt;p&gt;考虑 DP。发现每个人手上的球分为『自己的』和『左边的人传过来的』两种类型；&lt;mark&gt;显然第二种会有来自上一个人的限制，考虑把第二种在上一个人就完成求解&lt;/mark&gt;。具体地，设 &lt;span class=&#34;math inline&#34;&gt;\(f_{i,0}\)&lt;/span&gt; 表示第 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 个人选取自己的球，但只记录 &lt;span class=&#34;math inline&#34;&gt;\(1\sim i-1\)&lt;/span&gt; 的方案；&lt;span class=&#34;math inline&#34;&gt;\(f_{i,1}\)&lt;/span&gt; 表示第 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 个人选取第 &lt;span class=&#34;math inline&#34;&gt;\(i-1\)&lt;/span&gt; 个人的球，并记入答案的方案。&lt;em&gt;你可能需要注意到：最后一个被记入方案的球来自第 &lt;span class=&#34;math inline&#34;&gt;\(i-1\)&lt;/span&gt; 个人&lt;/em&gt;。&lt;/p&gt;
&lt;p&gt;但这样会有个小问题。我们让所有人多往右边传一个球，那么在我们的这种分割方法看来是不一样的局面；但实际上它们是等价的。从每个人传出了多少个球（设为 &lt;span class=&#34;math inline&#34;&gt;\(x_i\)&lt;/span&gt;）的角度来看，对于 &lt;span class=&#34;math inline&#34;&gt;\(\min\{x_n\}\ne 0\)&lt;/span&gt;，只需要不断执行 &lt;span class=&#34;math inline&#34;&gt;\(\forall\, x_i\gets x_i-1\)&lt;/span&gt; 就可以在局面不变的情况下使 &lt;span class=&#34;math inline&#34;&gt;\(\min\{x_n\}\ne 0\)&lt;/span&gt;。这是在说，可以让 &lt;span class=&#34;math inline&#34;&gt;\(\min\{x_n\}\ne 0\)&lt;/span&gt; 的方案和终局一一对应。&lt;/p&gt;
&lt;p&gt;发现可以容斥：钦定 &lt;span class=&#34;math inline&#34;&gt;\(x_i\ge 1\)&lt;/span&gt;，也就是每个人必须往右传至少一个，相似地算一遍就能得到非法方案。&lt;/p&gt;
&lt;p&gt;考虑转移，令 &lt;span class=&#34;math inline&#34;&gt;\(x_i\)&lt;/span&gt; 可选最小值为 &lt;span class=&#34;math inline&#34;&gt;\(l\)&lt;/span&gt;，有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class=&#34;math inline&#34;&gt;\(f_{i+1,0}\gets f_{i,0}\)&lt;/span&gt;：将第 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 个人未被记入的自己的球记入，球数可能为 &lt;span class=&#34;math inline&#34;&gt;\([0,a_i-l]\)&lt;/span&gt;。等差数列求和即可。&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;math inline&#34;&gt;\(f_{i+1,0}\gets f_{i,1}\)&lt;/span&gt;：没有球需要被记入，但是这种情况对应多种 &lt;span class=&#34;math inline&#34;&gt;\(x_i\)&lt;/span&gt;。具体地，&lt;span class=&#34;math inline&#34;&gt;\(x_i\in [l,a_i]\)&lt;/span&gt;。共有 &lt;span class=&#34;math inline&#34;&gt;\(a_i-l+1\)&lt;/span&gt; 种方案。&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;math inline&#34;&gt;\(f_{i+1,1}\gets f_{i,0}\)&lt;/span&gt;：将第 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 个人的 &lt;span class=&#34;math inline&#34;&gt;\(a_i\)&lt;/span&gt; 个球分给 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 和 &lt;span class=&#34;math inline&#34;&gt;\(i+1\)&lt;/span&gt;。共有 &lt;span class=&#34;math inline&#34;&gt;\(x_i\cdot (a_i-x_i)\)&lt;/span&gt; 种可能，也就是 &lt;span class=&#34;math inline&#34;&gt;\(\left(a_i\cdot \sum_{x_i=l}^{a_i} x_i\right)-\left(\sum_{x_i=l}^{a_i}{x_i}^2\right)\)&lt;/span&gt; 种方案。&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;math inline&#34;&gt;\(f_{i+1,1}\gets f_{i,1}\)&lt;/span&gt;：将第 &lt;span class=&#34;math inline&#34;&gt;\(i+1\)&lt;/span&gt; 个人得到的第 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 个人的球记入，同第一条。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;破环为链，分别钦定第一个人是用自己的球还是上一个人的球来解决问题（必须对于两种可能性分开计算；否则就不知道答案应该取 &lt;span class=&#34;math inline&#34;&gt;\(f_{n,0}\)&lt;/span&gt; 还是 &lt;span class=&#34;math inline&#34;&gt;\(f_{n,1}\)&lt;/span&gt;）。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int mod = 998244353, inv2 = (mod + 1) &amp;gt;&amp;gt; 1, inv6 = 166374059;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#endif
    int n;
    std::cin &amp;gt;&amp;gt; n;
    std::vector&amp;lt;long long&amp;gt; a(n);
    for (int i = 1; i &amp;lt;= n; ++i)
        std::cin &amp;gt;&amp;gt; a[i % n];
    auto sum = [&amp;amp;](long long r) &amp;#123;
        return r * (r + 1) % mod * inv2 % mod;
    &amp;#125;;
    auto sum2 = [&amp;amp;](long long r) &amp;#123;
        return r * (r + 1) % mod * (2 * r % mod + 1) % mod * inv6 % mod;
    &amp;#125;;
    std::vector&amp;lt;std::vector&amp;lt;long long&amp;gt; &amp;gt; f0(n, std::vector&amp;lt;long long&amp;gt; (2)), f1(n, std::vector&amp;lt;long long&amp;gt; (2));
    auto calc = [&amp;amp;](long long l, std::vector&amp;lt;std::vector&amp;lt;long long&amp;gt; &amp;gt; &amp;amp;f) &amp;#123;
        f[0][0] = 1ll;
        for (int i = 0; i &amp;lt; n; ++i) &amp;#123;
            int j = (i + 1) % n;
            f[j][0] = f[i][0] * sum(a[i] - l) % mod;
            (f[j][0] += f[i][1] * (a[i] - l + 1)) %= mod;
            f[j][1] = f[i][0] * (a[i] * sum(a[i]) % mod - sum2(a[i])) % mod;
            (f[j][1] += f[i][1] * sum(a[i]) % mod) %= mod;
            // printf(&amp;quot;0, l = %lld, f[%d]: %lld / %lld\n&amp;quot;, l, j, f[j][0], f[j][1]);
        &amp;#125;
        auto res(f[0][0]);
        f.assign(n, std::vector&amp;lt;long long&amp;gt; (2));
        f[0][1] = 1ll;
        for (int i = 0; i &amp;lt; n; ++i) &amp;#123;
            int j = (i + 1) % n;
            f[j][0] = f[i][0] * sum(a[i] - l) % mod;
            (f[j][0] += f[i][1] * (a[i] - l + 1)) %= mod;
            f[j][1] = f[i][0] * (a[i] * sum(a[i]) % mod - sum2(a[i])) % mod;
            (f[j][1] += f[i][1] * sum(a[i]) % mod) %= mod;
            // printf(&amp;quot;1, l = %lld, f[%d]: %lld / %lld\n&amp;quot;, l, j, f[j][0], f[j][1]);
        &amp;#125;
        return (res + f[0][1]) % mod;
    &amp;#125;;
    std::cout &amp;lt;&amp;lt; (calc(0, f0) + mod - calc(1, f1)) % mod &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;b---绿宝石之岛&#34;&gt;B - 绿宝石之岛&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://loj.ac/p/6406&#34; class=&#34;uri&#34;&gt;https://loj.ac/p/6406&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;因为只关心最终状态，原题可以转化为：将 &lt;span class=&#34;math inline&#34;&gt;\(d\)&lt;/span&gt; 分成 &lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt; 个非负整数，前 &lt;span class=&#34;math inline&#34;&gt;\(r\)&lt;/span&gt; 大数之和的期望（当然你需要加上初始的 &lt;span class=&#34;math inline&#34;&gt;\(r\)&lt;/span&gt; 个）。&lt;/p&gt;
&lt;p&gt;关于非负整数拆分：设 &lt;span class=&#34;math inline&#34;&gt;\(f_{i,j}\)&lt;/span&gt; 表示将 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 分成 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; 个 &lt;strong&gt;非负整数&lt;/strong&gt; 的方案，钦定其中恰有 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 个 &lt;strong&gt;正整数&lt;/strong&gt; 进行转移，给这 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 个数先分一个 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt;，则 &lt;span class=&#34;math inline&#34;&gt;\(f_{i,j}=\sum\limits_{k=0}^{\min(i,j)} C_j^k\cdot f_{i-k,k}\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;再设 &lt;span class=&#34;math inline&#34;&gt;\(g_{i,j}\)&lt;/span&gt; 表示将 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 分成 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; 个非负整数的所有方案中、前 &lt;span class=&#34;math inline&#34;&gt;\(r\)&lt;/span&gt; 大的数之和。类似地，有 &lt;span class=&#34;math inline&#34;&gt;\(g_{i,j}=\sum\limits_{k=0}^{\min(i,j)} C_j^k\cdot (g_{i-k,k}+\min(k,r)\cdot f_{i-k,k})\)&lt;/span&gt;。其中，&lt;span class=&#34;math inline&#34;&gt;\(\min(k,r)\)&lt;/span&gt; 的来源是，只有 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 个数有值，前 &lt;span class=&#34;math inline&#34;&gt;\(r\)&lt;/span&gt; 大的数一定在这 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 个数里面。&lt;/p&gt;
&lt;p&gt;答案为 &lt;span class=&#34;math inline&#34;&gt;\(\dfrac {g_{d,n}}{f_{d,n}}+r\)&lt;/span&gt;，复杂度 &lt;span class=&#34;math inline&#34;&gt;\(O(n^3)\)&lt;/span&gt;。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#endif
    int n, d, r;
    std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; d &amp;gt;&amp;gt; r;
    using arr = std::vector&amp;lt;double&amp;gt;;
    std::vector&amp;lt;arr&amp;gt; f(d + 1, arr(n + 1)), g(d + 1, arr(n + 1)), C(n + 1, arr(n + 1));
    for (int i = 0; i &amp;lt;= n; ++i) &amp;#123;
        C[i][0] = 1.;
        for (int j = 1; j &amp;lt;= i; ++j)
            C[i][j] = C[i - 1][j - 1] + C[i - 1][j];
    &amp;#125;
    f[0].assign(n + 1, 1.);
    for (int i = 1; i &amp;lt;= d; ++i)
        for (int j = 1; j &amp;lt;= n; ++j) &amp;#123;
            for (int k = 1; k &amp;lt;= i &amp;amp;&amp;amp; k &amp;lt;= j; ++k) &amp;#123;
                f[i][j] += C[j][k] * f[i - k][k];
                g[i][j] += C[j][k] * (g[i - k][k] + std::min(k, r) * f[i - k][k]);
                // printf(&amp;quot;  k = %d, %.0lf + %.0lf\n&amp;quot;, k, C[j][k] * g[i - k][k], std::min(k, r) * f[i - k][k]);
            &amp;#125;
            // printf(&amp;quot;f[%d][%d] = %.0lf, g[%d][%d] = %.0lf\n&amp;quot;, i, j, f[i][j], i, j, g[i][j]);
        &amp;#125;
    std::cout &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(8) &amp;lt;&amp;lt; g[d][n] / f[d][n] + r &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;c---uddered-but-not-herd-g&#34;&gt;C - Uddered but not Herd G&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P7296&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P7296&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;给每个字母分配一个标号 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt;，那么最小段数就是 &lt;span class=&#34;math inline&#34;&gt;\(\sum \left[x_i\ge x_{i+1}\right]\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;考虑状压完成映射操作，令 &lt;span class=&#34;math inline&#34;&gt;\(f_{s}\)&lt;/span&gt; 表示给标号 &lt;span class=&#34;math inline&#34;&gt;\(1\sim |s|\)&lt;/span&gt; 分配字母后，占用字符集 &lt;span class=&#34;math inline&#34;&gt;\(s\)&lt;/span&gt; 的方案数，那么就能 &lt;span class=&#34;math inline&#34;&gt;\(O(1)\)&lt;/span&gt; 得到贡献——只需预处理出 &lt;span class=&#34;math inline&#34;&gt;\(f_{c, s}\)&lt;/span&gt; 表示分配到字母 &lt;span class=&#34;math inline&#34;&gt;\(c\)&lt;/span&gt; 时，已经先给 &lt;span class=&#34;math inline&#34;&gt;\(s\)&lt;/span&gt; 中字母分配了更小标号时的贡献。&lt;/p&gt;
&lt;p&gt;注意字符集大小只有 &lt;span class=&#34;math inline&#34;&gt;\(20\)&lt;/span&gt;，可以 &lt;span class=&#34;math inline&#34;&gt;\(O(|S|\cdot 2^{|S|})\)&lt;/span&gt; 解决问题，&lt;mark&gt;注意到预处理的内容是类高维前缀最值的形式，可以递推降低复杂度&lt;/mark&gt;。&lt;/p&gt;
&lt;details&gt;
&lt;pre data-line=&#34;26-28&#34; class=&#34;cpp language-cpp&#34;&gt;&lt;code data-line=&#34;26-28&#34; class=&#34;cpp language-cpp&#34;&gt;#include &amp;lt;bits/stdc++.h&gt;
const int inf = 0x3f3f3f3f;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&#34;.in&#34;, &#34;r&#34;, stdin);
    std::freopen(&#34;.out&#34;, &#34;w&#34;, stdout);
#endif
    int n;
    std::string t;
    std::cin &gt;&gt; t, n = (int)t.length(), t = &#34;#&#34; + t;
    std::vector&amp;lt;int&gt; a, tag(26, -1), s(n + 1);
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        if (tag[t[i] - &#39;a&#39;] == -1)
            tag[t[i] - &#39;a&#39;] = (int)a.size(), a.push_back(t[i] - &#39;a&#39;);
        s[i] = tag[t[i] - &#39;a&#39;];
    &amp;#125;
    int m = (int)a.size(), siz = 1 &amp;lt;&amp;lt; m;
    std::vector&amp;lt;std::vector&amp;lt;int&gt; &gt; cnt(m, std::vector&amp;lt;int&gt; (m));
    for (int i = 1; i &amp;lt; n; ++i)
        ++cnt[s[i]][s[i + 1]];
    std::vector&amp;lt;std::vector&amp;lt;int&gt; &gt; g(m, std::vector&amp;lt;int&gt; (siz));
    for (int i = 0; i &amp;lt; m; ++i)
        for (int k = 0; k &amp;lt; m; ++k) // 注意这里相当于是钦定从 k 处转移
            for (int j = (1 &amp;lt;&amp;lt; k); j &amp;lt; (2 &amp;lt;&amp;lt; k); ++j) // 枚举的是 k 位为 1 的所有数；这两层循环的复杂度为 O(siz)
                g[i][j] = g[i][j ^ (1 &amp;lt;&amp;lt; k)] + cnt[i][k]; // 目的是此处的内存连续访问优化，把 ^ 看作 - 应该就能理解为什么第二维是连续的
    std::vector&amp;lt;int&gt; f(siz, inf);
    f[0] = 1;
    for (int i = 1; i &amp;lt; siz; ++i)
        for (int j = 0; j &amp;lt; m; ++j)
            if ((i &gt;&gt; j) &amp; 1)
                f[i] = std::min(f[i], f[i ^ (1 &amp;lt;&amp;lt; j)] + g[j][i]);
    std::cout &amp;lt;&amp;lt; f[siz - 1] &amp;lt;&amp;lt; &#39;\n&#39;;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;d---min-max-subarrays-p&#34;&gt;D - Min Max Subarrays P&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P11845&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P11845&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;先考虑 &lt;span class=&#34;math inline&#34;&gt;\(01\)&lt;/span&gt; 序列的答案：如果序列中存在相邻的 &lt;span class=&#34;math inline&#34;&gt;\(2\)&lt;/span&gt; 个 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt;，总能保证最后的一个是 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;如果序列中存在 &lt;span class=&#34;math inline&#34;&gt;\(\ge 3\)&lt;/span&gt; 个 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt;，可以牺牲其中的一些使得 &lt;span class=&#34;math inline&#34;&gt;\(2\)&lt;/span&gt; 个 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt; 相邻。&lt;/p&gt;
&lt;p&gt;当序列中只有 &lt;span class=&#34;math inline&#34;&gt;\(2\)&lt;/span&gt; 个 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt; 时，只有因为剩下的 &lt;span class=&#34;math inline&#34;&gt;\(0\)&lt;/span&gt; 不太够，导致我们无法随意『上下其手』时不能将 &lt;span class=&#34;math inline&#34;&gt;\(2\)&lt;/span&gt; 个 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt; 挪到一起。&lt;/p&gt;
&lt;p&gt;令两个 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt; 为序列最大值与次大值，暴搜处理序列长度较小的情况，剩下的直接用奇偶性判断两个 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt; 取哪个。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;a---mst-on-line&#34;&gt;A - MST on Line++&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/arc167/tasks/arc167_c&#34; class=&#34;uri&#34;&gt;https://atcoder.jp/contests/arc167/tasks/arc167_c&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;相当于把 &lt;span class=&#34;math inline&#34;&gt;\(a\)&lt;/span&gt; 打乱然后处理原问题。考虑每个 &lt;span class=&#34;math inline&#34;&gt;\(a_i\)&lt;/span&gt; 的贡献次数。模拟 Kruskal 连边，从小到大把点 &lt;span class=&#34;math inline&#34;&gt;\(a_i\)&lt;/span&gt; 加入图，&lt;span class=&#34;math inline&#34;&gt;\(a_i\)&lt;/span&gt; 可以向 &lt;span class=&#34;math inline&#34;&gt;\(a_{[i-K,i+K]}\)&lt;/span&gt; 内所有连通块连边。&lt;/p&gt;
&lt;p&gt;连通块数量当且仅当 &lt;span class=&#34;math inline&#34;&gt;\([i-K,i)\)&lt;/span&gt; 内最靠右的点和 &lt;span class=&#34;math inline&#34;&gt;\((i, i+K]\)&lt;/span&gt; 内最靠左的点距离 &lt;span class=&#34;math inline&#34;&gt;\(&amp;gt;K\)&lt;/span&gt; 时为 &lt;span class=&#34;math inline&#34;&gt;\(2\)&lt;/span&gt;，其余情况为 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;但要是从这个角度想这个题就不太好做了。正确的想法应该是&lt;mark&gt;拆分为『若 &lt;span class=&#34;math inline&#34;&gt;\([i-K,i)\)&lt;/span&gt; 中有点，贡献次数 &lt;span class=&#34;math inline&#34;&gt;\(+1\)&lt;/span&gt;』和『若 &lt;span class=&#34;math inline&#34;&gt;\((i,i+K]\)&lt;/span&gt; 中有点 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; 满足 &lt;span class=&#34;math inline&#34;&gt;\([j-K,j)\)&lt;/span&gt; 中无点，贡献次数 &lt;span class=&#34;math inline&#34;&gt;\(+1\)&lt;/span&gt;』&lt;/mark&gt;。对于第一个问题，贡献次数将前 &lt;span class=&#34;math inline&#34;&gt;\(i-1\)&lt;/span&gt; 大的数分配至少一个到 &lt;span class=&#34;math inline&#34;&gt;\([i-K,i)\)&lt;/span&gt; 中的方案数；对于第二个问题，枚举 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt;，贡献次数为将前 &lt;span class=&#34;math inline&#34;&gt;\(i-1\)&lt;/span&gt; 大的数分配到 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; 和 &lt;span class=&#34;math inline&#34;&gt;\([1,j-K)\cup (j, n]\)&lt;/span&gt; 中的方案数。&lt;/p&gt;
&lt;details&gt;
&lt;p&gt;实现的时候千万注意循环变量枚举的是位置还是值！不然你会调得很痛苦。&lt;/p&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int mod = 998244353;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;03-max-01.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#endif
    int n, k;
    std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; k;
    std::vector&amp;lt;int&amp;gt; a(n + 1);
    for (int i = 1; i &amp;lt;= n; ++i)
        std::cin &amp;gt;&amp;gt; a[i];
    std::sort(a.begin() + 1, a.end());
    std::vector&amp;lt;long long&amp;gt; fac(n + 1), inv(n + 1);
    fac[0] = inv[0] = 1ll;
    for (int i = 1; i &amp;lt;= n; ++i)
        fac[i] = fac[i - 1] * i % mod;
    auto qkp = [](long long x, int y) &amp;#123;
        auto res(1ll);
        for (; y; (x *= x) %= mod, y &amp;gt;&amp;gt;= 1)
            if (y &amp;amp; 1)
                (res *= x) %= mod;
        return res;
    &amp;#125;;
    inv[n] = qkp(fac[n], mod - 2);
    for (int i = n - 1; i; --i)
        inv[i] = inv[i + 1] * (i + 1) % mod;
    auto A = [&amp;amp;](int n, int m) &amp;#123;
        if (n &amp;lt; m)
            return 0ll;
        return fac[n] * inv[n - m] % mod;
    &amp;#125;;
    auto C = [&amp;amp;](int n, int m) &amp;#123;
        return A(n, m) * inv[m] % mod;
    &amp;#125;;
    long long res = 0ll;
    for (int i = 2; i &amp;lt;= n; ++i) &amp;#123;
        for (int j = 1; j &amp;lt;= n; ++j)
            (res += a[i] * (fac[n - 1] + mod - A(n - 1 - (j - std::max(1, j - k)), i - 1) * fac[n - i] % mod) % mod) %= mod;
        for (int j = 2; j &amp;lt;= n; ++j)
            (res += a[i] * C(i - 1, i - 2) % mod * C(j - std::max(1, j - k), 1) % mod * A(n - (j - std::max(1, j - k) + 1), i - 2) % mod * fac[n - i] % mod) %= mod;
    &amp;#125;
    std::cout &amp;lt;&amp;lt; res &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;b---existence-counting&#34;&gt;B - Existence Counting&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/arc174/tasks/arc174_e&#34; class=&#34;uri&#34;&gt;https://atcoder.jp/contests/arc174/tasks/arc174_e&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;发现可以分类讨论。假设 &lt;span class=&#34;math inline&#34;&gt;\(a&amp;#39;\)&lt;/span&gt; 中第一个异于 &lt;span class=&#34;math inline&#34;&gt;\(a\)&lt;/span&gt; 的位置为 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt;，&lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 在 &lt;span class=&#34;math inline&#34;&gt;\(a\)&lt;/span&gt; 中位置为 &lt;span class=&#34;math inline&#34;&gt;\(pos_x\)&lt;/span&gt;（不存在则 &lt;span class=&#34;math inline&#34;&gt;\(pos_x=k+1\)&lt;/span&gt;）。令 &lt;span class=&#34;math inline&#34;&gt;\(f_i\)&lt;/span&gt; 为若 &lt;span class=&#34;math inline&#34;&gt;\(1\sim i-1\)&lt;/span&gt; 均相同，&lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 位置可选的选项数。则 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 出现的次数：&lt;/p&gt;
&lt;table&gt;
&lt;colgroup&gt;
&lt;col style=&#34;width: 25%&#34; /&gt;
&lt;col style=&#34;width: 25%&#34; /&gt;
&lt;col style=&#34;width: 25%&#34; /&gt;
&lt;col style=&#34;width: 25%&#34; /&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr class=&#34;header&#34;&gt;
&lt;th style=&#34;text-align: center;&#34;&gt;&lt;/th&gt;
&lt;th style=&#34;text-align: center;&#34;&gt;&lt;span class=&#34;math inline&#34;&gt;\(pos_x&amp;lt;i\)&lt;/span&gt;&lt;/th&gt;
&lt;th style=&#34;text-align: center;&#34;&gt;&lt;span class=&#34;math inline&#34;&gt;\(pos_x=i\)&lt;/span&gt;&lt;/th&gt;
&lt;th style=&#34;text-align: center;&#34;&gt;&lt;span class=&#34;math inline&#34;&gt;\(pos_x&amp;gt;i,i&amp;lt;k\)&lt;/span&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;&lt;span class=&#34;math inline&#34;&gt;\(x\le a_i\)&lt;/span&gt;&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;&lt;span class=&#34;math inline&#34;&gt;\(1+f_i\cdot A_{n-i}^{k-i}\)&lt;/span&gt;&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;&lt;span class=&#34;math inline&#34;&gt;\(f_i\cdot C_{k-i}^1\cdot A_{n-i-1}^{k-i-1}\)&lt;/span&gt;&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;&lt;span class=&#34;math inline&#34;&gt;\((f_i-1)\cdot C_{k-i}^1\cdot A_{n-i-1}^{k-i-1}+A_{n-i}^{k-i}\)&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;&lt;span class=&#34;math inline&#34;&gt;\(x&amp;gt;a_i\)&lt;/span&gt;&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;&lt;span class=&#34;math inline&#34;&gt;\(f_i\cdot A_{n-i}^{k-i}\)&lt;/span&gt;&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;&lt;span class=&#34;math inline&#34;&gt;\(0\)&lt;/span&gt;&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;&lt;span class=&#34;math inline&#34;&gt;\(f_i\cdot C_{k-i}^1\cdot A_{n-i-1}^{k-i-1}\)&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;故，对于任意 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt;，答案为：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
\begin{aligned}
&amp;amp;1+\left(\sum_{i=pos_x+1}^k f_i\cdot A_{n-i}^{k-i}\right)
+\sum_{i=1}^{pos_x} (f_i-[x&amp;lt; a_i])\cdot C_{k-i}^1\cdot A_{n-i-1}^{k-i-1}+[x&amp;lt; a_i]\cdot A_{n-i}^{k-i}\\
=&amp;amp;1+\left(\sum_{i=pos_x+1}^k f_i\cdot A_{n-i}^{k-i}\right)
+\left(\sum_{i=1}^{pos_x} f_i\cdot C_{k-i}^1\cdot A_{n-i-1}^{k-i-1}\right)+\sum_{i=1,a_i&amp;gt; x}^{pos_x}A_{n-i}^{k-i}-C_{k-i}^1\cdot A_{n-i-1}^{k-i-1}\\
\end{aligned}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;预处理出 &lt;span class=&#34;math inline&#34;&gt;\(f_i=\sum\limits_{j=i+1}^k [a_j&amp;lt; a_i]\)&lt;/span&gt;（需要数据结构）、&lt;span class=&#34;math inline&#34;&gt;\(g_i=\sum\limits_{j=1}^i f_j\cdot A_{n-j}^{k-j}\)&lt;/span&gt; 和 &lt;span class=&#34;math inline&#34;&gt;\(h_j=\sum\limits_{j=1}^i f_i\cdot C_{k-i}^1\cdot A_{n-i-1}^{k-i-1}\)&lt;/span&gt;，再用数据结构计算 &lt;span class=&#34;math inline&#34;&gt;\(\sum\limits_{i=1,a_i&amp;gt;x}^{pos_x}C_{k-i}^1\cdot A_{n-i-1}^{k-i-1} - A_{n-i}^{k-i}\)&lt;/span&gt; 即可。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int mod = 998244353;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#endif
    int n, k;
    std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; k;
    std::vector&amp;lt;int&amp;gt; a(k + 1), p(n + 1, k + 1);
    for (int i = 1; i &amp;lt;= k; ++i)
        std::cin &amp;gt;&amp;gt; a[i], p[a[i]] = i;
    std::vector&amp;lt;long long&amp;gt; fac(n + 1), inv(n + 1);
    &amp;#123;
        fac[0] = inv[0] = 1ll;
        for (int i = 1; i &amp;lt;= n; ++i)
            fac[i] = fac[i - 1] * i % mod;
        auto qkp = [](long long x, int y) &amp;#123;
            auto res(1ll);
            for (; y; (x *= x) %= mod, y &amp;gt;&amp;gt;= 1)
                if (y &amp;amp; 1)
                    (res *= x) %= mod;
            return res;
        &amp;#125;;
        inv[n] = qkp(fac[n], mod - 2);
        for (int i = n - 1; i; --i)
            inv[i] = inv[i + 1] * (i + 1) % mod;
    &amp;#125;
    auto A = [&amp;amp;](int n, int m) &amp;#123;
        if (n &amp;lt; m || m &amp;lt; 0)
            return 0ll;
        return fac[n] * inv[n - m] % mod;
    &amp;#125;;
    std::vector&amp;lt;long long&amp;gt; f(k + 1), g(k + 1), h(k + 1);
    std::vector&amp;lt;long long&amp;gt; bit(n + 1);
    auto lowbit = [](int x) &amp;#123;
        return x &amp;amp; -x;
    &amp;#125;;
    auto add = [&amp;amp;](int x, int v) &amp;#123;
        for (; x &amp;lt;= n; x += lowbit(x))
            (bit[x] += v) %= mod;
        return;
    &amp;#125;;
    auto ask = [&amp;amp;](int x) &amp;#123;
        auto res(0ll);
        for (; x; x -= lowbit(x))
            (res += bit[x]) %= mod;
        return res;
    &amp;#125;;
    for (int i = 1; i &amp;lt;= n; ++i)
        if (p[i] == k + 1)
            add(i, 1);
    for (int i = k; i; --i)
        f[i] = ask(a[i]), add(a[i], 1);
    for (int i = 1; i &amp;lt;= k; ++i) &amp;#123;
        g[i] = (g[i - 1] + f[i] * A(n - i, k - i)) % mod;
        h[i] = (h[i - 1] + f[i] * (k - i) % mod * A(n - i - 1, k - i - 1)) % mod;
        // printf(&amp;quot;%d: f = %lld, g = %lld, h = %lld\n&amp;quot;, i, f[i], g[i], h[i]);
    &amp;#125;
    std::vector&amp;lt;long long&amp;gt; res(n + 1);
    bit.assign(n + 1, 0ll);
    auto s(0ll);
    for (int i = 1; i &amp;lt;= k; ++i) &amp;#123;
        // printf(&amp;quot;%d: %lld + %lld + %lld\n&amp;quot;, a[i], 1 + g[k] - g[i], h[i], s - ask(a[i]));
        res[a[i]] = (1 + g[k] - g[i] + h[i] + (s - ask(a[i]))) % mod;
        res[a[i]] = (res[a[i]] + mod) % mod;
        (s += A(n - i, k - i) - (k - i) * A(n - i - 1, k - i - 1)) %= mod;
        add(a[i], (A(n - i, k - i) - (k - i) * A(n - i - 1, k - i - 1)) % mod);
    &amp;#125;
    for (int i = 1; i &amp;lt;= n; ++i)
        if (p[i] == k + 1) &amp;#123;
            res[i] = (h[k] + (s - ask(i))) % mod;
            res[i] = (res[i] + mod) % mod;
        &amp;#125;
    for (int x = 1; x &amp;lt;= n; ++x)
        std::cout &amp;lt;&amp;lt; res[x] &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;c---1-loop-bubble-sort&#34;&gt;C - 1 Loop Bubble Sort&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/arc187/tasks/arc187_c&#34; class=&#34;uri&#34;&gt;https://atcoder.jp/contests/arc187/tasks/arc187_c&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;首先是被考烂了的：对序列进行一次冒泡排序，等价于将序列在前缀最大值处分段，并将其从段首移到段尾；且满足排序前为前缀最大值的元素，排序后仍为前缀最大值。&lt;/p&gt;
&lt;p&gt;考虑用 DP 解决问题。注意状态要从 &lt;span class=&#34;math inline&#34;&gt;\(P\)&lt;/span&gt; 的角度出发——假如 &lt;span class=&#34;math inline&#34;&gt;\(Q\)&lt;/span&gt; 中不存在 &lt;span class=&#34;math inline&#34;&gt;\(-1\)&lt;/span&gt;，发现也需要 DP。此时再设计有关 &lt;span class=&#34;math inline&#34;&gt;\(Q\)&lt;/span&gt; 的状态就很扯淡了，考虑令 &lt;span class=&#34;math inline&#34;&gt;\(f_{i,j}\)&lt;/span&gt; 表示 &lt;span class=&#34;math inline&#34;&gt;\(P\)&lt;/span&gt; 中直到第 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 位的前缀最大值为 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; 的方案数。为什么把前缀最大值作为状态呢？因为它可以表示分段；同时限制段间数的取值。具体地，考虑转移：&lt;/p&gt;
&lt;ol type=&#34;1&#34;&gt;
&lt;li&gt;若令 &lt;span class=&#34;math inline&#34;&gt;\(P_i=j\)&lt;/span&gt;，则在 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 处分段。对应到 &lt;span class=&#34;math inline&#34;&gt;\(Q\)&lt;/span&gt; 中，&lt;span class=&#34;math inline&#34;&gt;\(i-1\)&lt;/span&gt; 位是上一个前缀最大值，那么这要求 &lt;span class=&#34;math inline&#34;&gt;\(Q_{i-1}&amp;lt;j\)&lt;/span&gt;，且 &lt;span class=&#34;math inline&#34;&gt;\(Q_{i-1}\)&lt;/span&gt; 是一个前缀最大值。也即：当 &lt;span class=&#34;math inline&#34;&gt;\(Q_{i-1}\ne -1\)&lt;/span&gt; 时，&lt;span class=&#34;math inline&#34;&gt;\(f_{i,j}\gets f_{i-1, Q_{i-1}}\)&lt;/span&gt;；否则，&lt;span class=&#34;math inline&#34;&gt;\(f_{i,j}\gets \sum\limits_{k&amp;lt;j} f_{i-1,k}\)&lt;/span&gt;。其中，二式都要求转移来源为前缀最大值。&lt;/li&gt;
&lt;li&gt;若令 &lt;span class=&#34;math inline&#34;&gt;\(P_i&amp;lt;j\)&lt;/span&gt;，则 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 在 &lt;span class=&#34;math inline&#34;&gt;\(Q\)&lt;/span&gt; 中恰好前移一位，即 &lt;span class=&#34;math inline&#34;&gt;\(Q_{i-1}=P_i&amp;lt;j\)&lt;/span&gt;。则当 &lt;span class=&#34;math inline&#34;&gt;\(Q_{i-1}\ne -1\)&lt;/span&gt; 时，该位确定，&lt;span class=&#34;math inline&#34;&gt;\(f_{i,j}\gets f_{i-1,j}\)&lt;/span&gt;；否则，&lt;span class=&#34;math inline&#34;&gt;\(Q_{i-1}\)&lt;/span&gt; 可选的值为 &lt;span class=&#34;math inline&#34;&gt;\(&amp;lt;j\)&lt;/span&gt; 的所有未选数（定值，可预处理）。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;关于初值，可以在 &lt;span class=&#34;math inline&#34;&gt;\(P\)&lt;/span&gt; 前加一个 &lt;span class=&#34;math inline&#34;&gt;\(0\)&lt;/span&gt; 作为排列的一部分（那么按照冒泡排序的规则 &lt;span class=&#34;math inline&#34;&gt;\(Q\)&lt;/span&gt; 的第一位也一定是 &lt;span class=&#34;math inline&#34;&gt;\(0\)&lt;/span&gt;）来处理就好了。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int mod = 998244353;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#endif
    int n;
    std::cin &amp;gt;&amp;gt; n;
    std::vector&amp;lt;int&amp;gt; q(n + 1), t(n + 1), c(n + 1), pos(n + 1);
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        std::cin &amp;gt;&amp;gt; q[i], c[i] = c[i - 1];
        if (q[i] == -1)
            ++c[i];
        else
            pos[q[i]] = i;
    &amp;#125;
    for (int i = 1; i &amp;lt; n; ++i) &amp;#123;
        // printf(&amp;quot;t[%d] = %d\n&amp;quot;, i, t[i]);
        if (!pos[i])
            for (int j = i + 1; j &amp;lt;= n; ++j)
                ++t[j];
    &amp;#125;
    std::vector&amp;lt;std::vector&amp;lt;long long&amp;gt; &amp;gt; f(n + 1, std::vector&amp;lt;long long&amp;gt; (n + 1)), s(n + 1, std::vector&amp;lt;long long&amp;gt; (n + 1));
    f[0][0] = 1ll;
    s[0].assign(n + 1, 1ll);
    for (int i = 1; i &amp;lt;= n; ++i)
        for (int j = 1; j &amp;lt;= n; ++j) &amp;#123;
            if (q[i - 1] == -1)
                f[i][j] = (s[i - 1][j - 1] + f[i - 1][j] * std::max(0, 1 + t[j] - c[i - 1])) % mod;
            else if (q[i - 1] &amp;lt; j)
                f[i][j] = (f[i - 1][q[i - 1]] + f[i - 1][j]) % mod;
            s[i][j] = s[i][j - 1];
            if (q[i] == j || !pos[j]) // 满足前缀最大值
                (s[i][j] += f[i][j]) %= mod;
            // printf(&amp;quot;f[%d][%d] = %lld\n&amp;quot;, i, j, f[i][j]);
        &amp;#125;
    std::cout &amp;lt;&amp;lt; f[n][n] &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;f---1.-intro&#34;&gt;(F - 1). Intro&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;给定一个大小为 &lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt; 的树，点有点权。给定 &lt;span class=&#34;math inline&#34;&gt;\(q\)&lt;/span&gt; 次操作，分为两种：&lt;/p&gt;
&lt;ol type=&#34;1&#34;&gt;
&lt;li&gt;&lt;code&gt;1 x&lt;/code&gt;：查询 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 的点权。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;2 x d v&lt;/code&gt; 对于所有距 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 不超过 &lt;span class=&#34;math inline&#34;&gt;\(d\)&lt;/span&gt; 的点，将它们的权值加上 &lt;span class=&#34;math inline&#34;&gt;\(v\)&lt;/span&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(n,q\le 10^5,d\le 20\)&lt;/span&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;由于 &lt;span class=&#34;math inline&#34;&gt;\(d\)&lt;/span&gt; 很小，我们可能需要枚举与 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 距离 &lt;span class=&#34;math inline&#34;&gt;\(0\sim d\)&lt;/span&gt; 的点进行修改；那么对距离 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 为 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 的点的更改存储在 &lt;span class=&#34;math inline&#34;&gt;\(f_{x,i}\)&lt;/span&gt;，查询 &lt;span class=&#34;math inline&#34;&gt;\(v\)&lt;/span&gt; 时就可以从 &lt;span class=&#34;math inline&#34;&gt;\(\sum\limits_i f_{fa(v,i),i}\)&lt;/span&gt; 求得答案。&lt;/p&gt;
&lt;p&gt;考虑修改。记 &lt;span class=&#34;math inline&#34;&gt;\(S_{x,d}\)&lt;/span&gt; 为距 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 为 &lt;span class=&#34;math inline&#34;&gt;\(d\)&lt;/span&gt; 的点集。&lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 子树内是好处理的，但子树外的呢？发现 &lt;span class=&#34;math inline&#34;&gt;\(S_{fa,d-1}\)&lt;/span&gt; 中 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 子树外的点，就是 &lt;span class=&#34;math inline&#34;&gt;\(fa\)&lt;/span&gt; 子树下、&lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 子树外距离 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 为 &lt;span class=&#34;math inline&#34;&gt;\(d\)&lt;/span&gt; 的所有点。&lt;/p&gt;
&lt;p&gt;由于所有 &lt;span class=&#34;math inline&#34;&gt;\(S_{fa(x,i),d-i}\)&lt;/span&gt; 无交，这可能满足我们每个待操作点被不重不漏加一次的要求。考虑将所有 &lt;span class=&#34;math inline&#34;&gt;\(S_{fa(x,i),d-i}\)&lt;/span&gt; 标记出来：&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&#34;1.png&#34; alt=&#34;粉色虚线框是待操作点集&#34; /&gt;&lt;figcaption&gt;粉色虚线框是待操作点集&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;然后我们可以一眼发现被叉的点和未被叉的待操作点是交错的！这意味着我们只需要再补充上所有 &lt;span class=&#34;math inline&#34;&gt;\(S_{fa(x,i),d-i-1}\)&lt;/span&gt; 即可（显然它们之间、它们和所有 &lt;span class=&#34;math inline&#34;&gt;\(S_{fa(x,i),d-i}\)&lt;/span&gt; 之间都不交）。&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&#34;2.png&#34; alt=&#34;虚线叉为 S_{fa(x,i),d-i-1}&#34; /&gt;&lt;figcaption&gt;虚线叉为 &lt;span class=&#34;math inline&#34;&gt;\(S_{fa(x,i),d-i-1}\)&lt;/span&gt;&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;此时就可以不重不漏。当然，也会存在一些细节：比如说 &lt;span class=&#34;math inline&#34;&gt;\(fa(x,i)\)&lt;/span&gt; 不存在之类。只需要在根节点 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt; 处将剩余的 &lt;span class=&#34;math inline&#34;&gt;\(S_{1,i\to 0}\)&lt;/span&gt; 全部更新即可。&lt;/p&gt;
&lt;p&gt;故每次修改操作只需要修改 &lt;span class=&#34;math inline&#34;&gt;\(O(d)\)&lt;/span&gt; 坨点。时间复杂度 &lt;span class=&#34;math inline&#34;&gt;\(O(qd)\)&lt;/span&gt;。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;f.-distance-to-the-path&#34;&gt;F. Distance to the Path&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://codeforces.com/problemset/problem/1749/F&#34; class=&#34;uri&#34;&gt;https://codeforces.com/problemset/problem/1749/F&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本例中将单点修改替换为路径修改；考虑树剖解决问题。&lt;/p&gt;
&lt;p&gt;对于路径上的所有点 &lt;span class=&#34;math inline&#34;&gt;\(u\)&lt;/span&gt;，容易发现只需要修改所有的 &lt;span class=&#34;math inline&#34;&gt;\(S_{u,d}\)&lt;/span&gt; 就可以完成对『&lt;strong&gt;一部分路径内侧的点&lt;/strong&gt;』的修改。这『一部分』，是因为不包括距离 LCA &lt;span class=&#34;math inline&#34;&gt;\(\le d\)&lt;/span&gt; 的点。&lt;/p&gt;
&lt;p&gt;而『&lt;strong&gt;另一部分路径内侧的点&lt;/strong&gt;（距 LCA &lt;span class=&#34;math inline&#34;&gt;\(\le d\)&lt;/span&gt;：见上一行说明）』及『&lt;strong&gt;路径外侧的点&lt;/strong&gt;（距 LCA &lt;span class=&#34;math inline&#34;&gt;\(\le d\)&lt;/span&gt;：因为路径在 LCA 子树内，LCA 能够到最远的外侧点）』，等价于『&lt;strong&gt;距 LCA &lt;span class=&#34;math inline&#34;&gt;\(\le d\)&lt;/span&gt; 的点&lt;/strong&gt;』，只需要把 LCA 代入上例中方式修改即可。&lt;/p&gt;
&lt;p&gt;修改路径上所有点 &lt;span class=&#34;math inline&#34;&gt;\(u\)&lt;/span&gt; 的 &lt;span class=&#34;math inline&#34;&gt;\(S_{u,d}\)&lt;/span&gt; 时，可以对所有 &lt;span class=&#34;math inline&#34;&gt;\(f_{*,i}\)&lt;/span&gt; 建立数据结构，由于只需要区间修改、单点查询，使用差分树状数组即可。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt; 
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#endif
    int n, m;
    std::cin &amp;gt;&amp;gt; n;
    std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; g(n + 1);
    for (int i = 1, x, y; i &amp;lt; n; ++i) &amp;#123;
        std::cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; y;
        g[x].push_back(y), g[y].push_back(x);
    &amp;#125;
    std::vector&amp;lt;int&amp;gt; siz(n + 1), dep(n + 1), fa(n + 1), son(n + 1);
    std::function&amp;lt;void(int, int)&amp;gt; DFS = [&amp;amp;](int x, int faa) &amp;#123;
        siz[x] = 1;
        for (auto i : g[x])
            if (i != faa) &amp;#123;
                fa[i] = x, dep[i] = dep[x] + 1;
                DFS(i, x);
                siz[x] += siz[i];
                if (siz[i] &amp;gt; siz[son[x]])
                    son[x] = i;
            &amp;#125;
        return;
    &amp;#125;;
    DFS(1, -1);
    std::vector&amp;lt;int&amp;gt; dfn(n + 1), top(n + 1);
    DFS = [&amp;amp;](int x, int toop) &amp;#123;
        static int now = 0;
        dfn[x] = ++now, top[x] = toop;
        if (son[x])
            DFS(son[x], toop);
        for (auto i : g[x])
            if (i != fa[x] &amp;amp;&amp;amp; i != son[x])
                DFS(i, i);
        return;
    &amp;#125;;
    DFS(1, 1);
    std::vector&amp;lt;std::vector&amp;lt;long long&amp;gt; &amp;gt; bit(21, std::vector&amp;lt;long long&amp;gt; (n + 1));
    auto lowbit = [&amp;amp;](int x) &amp;#123;
        return x &amp;amp; -x;
    &amp;#125;;
    auto add = [&amp;amp;](auto &amp;amp;bit, int x, int v) &amp;#123;
        for (; x &amp;lt;= n; x += lowbit(x))
            bit[x] += v;
        return;
    &amp;#125;;
    auto ask = [&amp;amp;](auto &amp;amp;bit, int x) &amp;#123;
        auto res(0ll);
        for (; x; x -= lowbit(x))
            res += bit[x];
        return res;
    &amp;#125;;
    std::cin &amp;gt;&amp;gt; m;
    for (int op; m--; ) &amp;#123;
        std::cin &amp;gt;&amp;gt; op;
        if (op == 1) &amp;#123;
            int x;
            std::cin &amp;gt;&amp;gt; x;
            auto res(0ll);
            for (int i = 0; i &amp;lt;= 20 &amp;amp;&amp;amp; x; ++i, x = fa[x])
                res += ask(bit[i], dfn[x]);
            std::cout &amp;lt;&amp;lt; res &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
        &amp;#125;
        else &amp;#123;
            int x, y, v, d;
            std::cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; y &amp;gt;&amp;gt; v &amp;gt;&amp;gt; d;
            for (; top[x] != top[y]; x = fa[top[x]]) &amp;#123;
                if (dep[top[x]] &amp;lt; dep[top[y]])
                    std::swap(x, y);
                add(bit[d], dfn[top[x]], v);
                add(bit[d], dfn[x] + 1, -v);
            &amp;#125;
            if (dep[x] &amp;gt; dep[y])
                std::swap(x, y);
            add(bit[d], dfn[x] + 1, v), add(bit[d], dfn[y] + 1, -v);
            for (x = x, y = d; ~y &amp;amp;&amp;amp; x; x = fa[x], --y) &amp;#123;
                add(bit[y], dfn[x], v), add(bit[y], dfn[x] + 1, -v);
                if (y &amp;amp;&amp;amp; fa[x])
                    add(bit[y - 1], dfn[x], v), add(bit[y - 1], dfn[x] + 1, -v);
            &amp;#125;
            if (x == 0)
                for (; ~y; --y)
                    add(bit[y], dfn[1], v), add(bit[y], dfn[1] + 1, -v);
        &amp;#125;
    &amp;#125;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;a---ina-of-the-mountain&#34;&gt;A - Ina of the Mountain&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://codeforces.com/problemset/problem/1852/C&#34; class=&#34;uri&#34;&gt;https://codeforces.com/problemset/problem/1852/C&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;考虑这么一个简化版的问题：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定 &lt;span class=&#34;math inline&#34;&gt;\(\{a_n\}\)&lt;/span&gt;，每次可以进行区间 &lt;span class=&#34;math inline&#34;&gt;\(-1\)&lt;/span&gt;，问操作多少次才能将所有元素变为 &lt;span class=&#34;math inline&#34;&gt;\(0\)&lt;/span&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;会想到差分；对原数组进行差分，一次操作相当于令 &lt;span class=&#34;math inline&#34;&gt;\(d_l\gets d_l-1\)&lt;/span&gt; 而 &lt;span class=&#34;math inline&#34;&gt;\(d_{r+1}\gets d_{r+1}+1\)&lt;/span&gt;，最后要让 &lt;span class=&#34;math inline&#34;&gt;\(\forall \,d_i=0\)&lt;/span&gt;。那么答案就是差分数组中正数之和嘛。&lt;/p&gt;
&lt;p&gt;回到原问题。原问题等价于把上述问题变为：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定 &lt;span class=&#34;math inline&#34;&gt;\(\{a_n\}\)&lt;/span&gt;，每次可以进行区间 &lt;span class=&#34;math inline&#34;&gt;\(-1\)&lt;/span&gt;，每个数的总操作次数对 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 取模，问操作多少次才能将所有元素变为 &lt;span class=&#34;math inline&#34;&gt;\(0\)&lt;/span&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;怎么套回到刚刚的问题上呢？还原被取模掉的操作即可。具体来说，提前在 &lt;span class=&#34;math inline&#34;&gt;\(d\)&lt;/span&gt; 上进行若干次操作（记为操作 1），形如令 &lt;span class=&#34;math inline&#34;&gt;\(d_i\gets d_i+k\)&lt;/span&gt;，同时 &lt;span class=&#34;math inline&#34;&gt;\(d_{i+1}\gets d_{i+1}-k\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;会发现相邻的操作 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt; 对一个数加加减减影响判断；发现可以合并一段连续的操作 1，表现在 &lt;span class=&#34;math inline&#34;&gt;\(a\)&lt;/span&gt; 上也就是区间 &lt;span class=&#34;math inline&#34;&gt;\(+k\)&lt;/span&gt;。此时可以发现，一个位置上只会剩下若干次 &lt;span class=&#34;math inline&#34;&gt;\(+k\)&lt;/span&gt; 或若干次 &lt;span class=&#34;math inline&#34;&gt;\(-k\)&lt;/span&gt; （否则可以把 &lt;span class=&#34;math inline&#34;&gt;\(+k\)&lt;/span&gt; 和 &lt;span class=&#34;math inline&#34;&gt;\(-k\)&lt;/span&gt; 代表的不同操作合并），就不会有互相影响一说了。这也是有的题解说可以提前在 &lt;span class=&#34;math inline&#34;&gt;\(a\)&lt;/span&gt; 上区间 &lt;span class=&#34;math inline&#34;&gt;\(+k\)&lt;/span&gt; 的原因。&lt;/p&gt;
&lt;p&gt;此时问题变为在 &lt;span class=&#34;math inline&#34;&gt;\(d\)&lt;/span&gt; 进行任意次前加 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 后减 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 的操作，使得 &lt;span class=&#34;math inline&#34;&gt;\(\sum\limits_{d_i&amp;gt;0}d_i\)&lt;/span&gt; 最大化。那么显然如果要使代价更小，只可能在原本 &lt;span class=&#34;math inline&#34;&gt;\(&amp;lt;0\)&lt;/span&gt; 的位置做加法、&lt;span class=&#34;math inline&#34;&gt;\(&amp;gt;0\)&lt;/span&gt; 的位置做减法（其他情况会发现一定不优）。考虑两个数 &lt;span class=&#34;math inline&#34;&gt;\(d_l,d_r\)&lt;/span&gt;，可以感受到对于一个 &lt;span class=&#34;math inline&#34;&gt;\(r\)&lt;/span&gt;，选最小的 &lt;span class=&#34;math inline&#34;&gt;\(d_l\)&lt;/span&gt; 是最优的，但什么时候应该选呢？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class=&#34;math inline&#34;&gt;\(d_l\le -k,d_r\ge k\)&lt;/span&gt;：当然可选，&lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 被完全利用，答案减少 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(d_l&amp;gt;-k,d_r\ge k\)&lt;/span&gt;：此时 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 未被完全利用，但必须选：选择其他更大的数，&lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 的利用率只会更低；如果不选，答案也无法减少。&lt;/p&gt;
&lt;p&gt;Q：此时是否需要尝试找到一个 &lt;span class=&#34;math inline&#34;&gt;\(l&amp;#39;&amp;lt;l\)&lt;/span&gt; 与 &lt;span class=&#34;math inline&#34;&gt;\(l\)&lt;/span&gt; 做操作，使得 &lt;span class=&#34;math inline&#34;&gt;\(l\)&lt;/span&gt; 重新变为负数呢？&lt;/p&gt;
A：否。因为你可以将这两次操作合并，发现相当于是直接对 &lt;span class=&#34;math inline&#34;&gt;\((l&amp;#39;,r)\)&lt;/span&gt; 做操作，是更劣的。&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;math inline&#34;&gt;\(d_l\le -k,d_r&amp;lt;k\)&lt;/span&gt;：此时 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 未被完全利用，&lt;span class=&#34;math inline&#34;&gt;\(d_r\)&lt;/span&gt; 成为负数。这意味着 &lt;span class=&#34;math inline&#34;&gt;\(d_r\)&lt;/span&gt; 将会成为某个 &lt;span class=&#34;math inline&#34;&gt;\(r&amp;#39;\)&lt;/span&gt; 的可选项。考察 &lt;span class=&#34;math inline&#34;&gt;\(d_{r&amp;#39;}\)&lt;/span&gt; 可用的最小值。如果 &lt;span class=&#34;math inline&#34;&gt;\(d_r\)&lt;/span&gt; 在当前不应该作为右端点，它就一定会被 &lt;span class=&#34;math inline&#34;&gt;\(d_{r&amp;#39;}\)&lt;/span&gt; 选择。具体的有点抽象，但是你可以理解为 &lt;span class=&#34;math inline&#34;&gt;\(d_r\)&lt;/span&gt; 选了 &lt;span class=&#34;math inline&#34;&gt;\(d_l\)&lt;/span&gt; 的贡献是被整合到 &lt;span class=&#34;math inline&#34;&gt;\(d_r\)&lt;/span&gt; 里的；如果 &lt;span class=&#34;math inline&#34;&gt;\(d_r\)&lt;/span&gt; 被选了就说明 &lt;span class=&#34;math inline&#34;&gt;\(d_{r&amp;#39;}\)&lt;/span&gt; 选 &lt;span class=&#34;math inline&#34;&gt;\(d_l\)&lt;/span&gt; 会拥有更大的优势。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(d_l&amp;gt;-k,d_r&amp;lt;k\)&lt;/span&gt;：和上面的情况相似；但这种情况下答案可能反而变得更大，因为没有后效性，所以至少要保证单步最优。此时不能选。&lt;/p&gt;
&lt;p&gt;说到单步最优，就会发现这里就是反悔贪心；单步最优一定是全局最优，但更靠前的局部最优可能被否定掉。而『否定』的方法表现为一次操作。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;综上，从前往后扫，优先队列实时维护负数最小值，对于每个正数，check 选最小值是否优于当前答案，有就选。如果正数被减为负，加入队列。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#endif
    int T;
    for (std::cin &amp;gt;&amp;gt; T; T--; ) &amp;#123;
        int n, k;
        std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; k;
        std::vector&amp;lt;int&amp;gt; a(n + 1), d(n + 1);
        long long res(0ll);
        for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
            std::cin &amp;gt;&amp;gt; a[i], a[i] %= k;
            d[i] = a[i] - a[i - 1];
            if (d[i] &amp;gt; 0)
                (res += d[i]);
        &amp;#125;
        std::priority_queue&amp;lt;int&amp;gt; q;
        for (int i = 1; i &amp;lt;= n; ++i)
            if (d[i] &amp;lt; 0)
                q.push(-d[i]);
            else &amp;#123;
                for (; !q.empty() &amp;amp;&amp;amp; d[i] &amp;gt; 0; ) &amp;#123;
                    int x = -q.top(), y = d[i];
                    auto t(res - y);
                    x += k, y -= k;
                    if (x &amp;gt; 0)
                        t += x;
                    if (y &amp;gt; 0)
                        t += y;
                    if (t &amp;gt;= res)
                        break;
                    q.pop();
                    res = t, d[i] = y;
                    if (d[i] &amp;lt; 0)
                        q.push(-d[i]);
                &amp;#125;
            &amp;#125;
        std::cout &amp;lt;&amp;lt; res &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    &amp;#125;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;b---miriany-and-matchstick&#34;&gt;B - Miriany and Matchstick&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://codeforces.com/problemset/problem/1852/D&#34; class=&#34;uri&#34;&gt;https://codeforces.com/problemset/problem/1852/D&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;从构造的角度出发，看到『恰好为 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt;』，会想到找到上界和下界并证明中间每一个数都能取到。&lt;/p&gt;
&lt;p&gt;但似乎很容易证伪：例如对于 &lt;code&gt;AAAA&lt;/code&gt;，下界为 &lt;span class=&#34;math inline&#34;&gt;\(0\)&lt;/span&gt;，上界为 &lt;span class=&#34;math inline&#34;&gt;\(4\)&lt;/span&gt;，但有且仅有 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt; 取不到。但该想法并未破产——可以感受到这样的位置很少。进一步地，你 &lt;a href=&#34;https://www.luogu.com.cn/article/2mmg5rjd&#34;&gt;可以证明只有一个这样的位置&lt;/a&gt;，也可以 &lt;a href=&#34;https://www.luogu.com.cn/article/679cwjgl&#34;&gt;大胆猜想这样的位置一定出现在 &lt;span class=&#34;math inline&#34;&gt;\(l+1\)&lt;/span&gt;，&lt;span class=&#34;math inline&#34;&gt;\(r-1\)&lt;/span&gt;&lt;/a&gt;。总之现在我们的状态就减少了（或者说状态变成 DP 值了）。预处理出这个东西之后大力搜索找方案即可。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#endif
    int T;
    for (std::cin &amp;gt;&amp;gt; T; T--; ) &amp;#123;
        int n, k;
        std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; k;
        std::vector&amp;lt;int&amp;gt; a(n + 1);
        for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
            char t;
            std::cin &amp;gt;&amp;gt; t, a[i] = (t == &amp;#39;A&amp;#39;);
            if (i &amp;gt;= 2)
                k -= (a[i] ^ a[i - 1]);
        &amp;#125;
        std::vector&amp;lt;std::array&amp;lt;std::tuple&amp;lt;int, int, int&amp;gt;, 2&amp;gt; &amp;gt; f(n + 1);
        f[n][0] = &amp;#123; a[n], a[n], 0 &amp;#125;, f[n][1] = &amp;#123; !a[n], !a[n], 0 &amp;#125;;
        auto merge = [&amp;amp;](int i, int l0, int r0, int p0, int l1, int r1, int p1) &amp;#123;
            if (l0 &amp;gt; l1)
                std::swap(l0, l1), std::swap(r0, r1), std::swap(p0, p1);
            int l = l0, r = std::max(r0, r1), p = 0;
            if (!p0 &amp;amp;&amp;amp; !p1) &amp;#123;
                if (r0 &amp;lt; l1 - 1)
                    assert(r0 == l1 - 2), p = r0 + 1;
                else;
            &amp;#125;
            else if (p0 &amp;amp;&amp;amp; p1) &amp;#123;
                if (p0 == p1)
                    p = p0;
                else &amp;#123;
                    int tag0 = (l1 &amp;lt;= p0 &amp;amp;&amp;amp; p0 &amp;lt;= r1), tag1 = (l0 &amp;lt;= p1 &amp;amp;&amp;amp; p1 &amp;lt;= r0);
                    if (!tag0 &amp;amp;&amp;amp; !tag1);
                    else if (!tag0)
                        p = p0;
                    else if (!tag1)
                        p = p1;
                    else;
                &amp;#125;
            &amp;#125;
            else if (p0) &amp;#123;
                if (l1 &amp;lt;= p0 &amp;amp;&amp;amp; p0 &amp;lt;= r1);
                else
                    p = p0;
            &amp;#125;
            else &amp;#123;
                if (l0 &amp;lt;= p1 &amp;amp;&amp;amp; p1 &amp;lt;= r0);
                else
                    p = p1;
            &amp;#125;
            assert(p != l &amp;amp;&amp;amp; p != r &amp;amp;&amp;amp; l &amp;lt;= r);
            return std::make_tuple(l, r, p);
        &amp;#125;;
        for (int i = n - 1; i; --i) &amp;#123;
            &amp;#123;
                auto [l0, r0, p0] = f[i + 1][0];
                auto [l1, r1, p1] = f[i + 1][1];
                if (a[i]) &amp;#123;
                    ++l0, ++r0, ++l1, ++r1;
                    if (p0) ++p0;
                    if (p1) ++p1;
                &amp;#125;
                ++l1, ++r1;
                if (p1) ++p1;
                f[i][0] = merge(i, l0, r0, p0, l1, r1, p1);
            &amp;#125;
            &amp;#123;
                auto [l0, r0, p0] = f[i + 1][0];
                auto [l1, r1, p1] = f[i + 1][1];
                if (!a[i]) &amp;#123;
                    ++l0, ++r0, ++l1, ++r1;
                    if (p0) ++p0;
                    if (p1) ++p1;
                &amp;#125;
                ++l0, ++r0;
                if (p0) ++p0;
                f[i][1] = merge(i, l0, r0, p0, l1, r1, p1);
            &amp;#125;
        &amp;#125;
        std::vector&amp;lt;int&amp;gt; res(n + 1);
        std::function&amp;lt;bool(int, int, int)&amp;gt; DFS = [&amp;amp;](int x, int cnt, int la) &amp;#123;
            if (x == n + 1)
                return cnt == k;
            auto [l0, r0, p0] = f[x][0];
            auto [l1, r1, p1] = f[x][1];
            if (cnt + (la == 1) + l0 &amp;lt;= k &amp;amp;&amp;amp; cnt + (la == 1) + r0 &amp;gt;= k &amp;amp;&amp;amp; (!p0 || cnt + (la == 1) + p0 != k) &amp;amp;&amp;amp; DFS(x + 1, cnt + (la == 1) + a[x], 0))
                res[x] = 0;
            else if (cnt + !la + l1 &amp;lt;= k &amp;amp;&amp;amp; cnt + !la + r1 &amp;gt;= k &amp;amp;&amp;amp; (!p1 || cnt + !la + p1 != k) &amp;amp;&amp;amp; DFS(x + 1, cnt + !la + !a[x], 1))
                res[x] = 1;
            else
                return false;
            return true;
        &amp;#125;;
        if (DFS(1, 0, -1)) &amp;#123;
            std::cout &amp;lt;&amp;lt; &amp;quot;YES\n&amp;quot;;
            for (int i = 1; i &amp;lt;= n; ++i)
                std::cout &amp;lt;&amp;lt; (res[i] ? &amp;#39;A&amp;#39; : &amp;#39;B&amp;#39;);
            std::cout &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
        &amp;#125;
        else
            std::cout &amp;lt;&amp;lt; &amp;quot;NO\n&amp;quot;;
    &amp;#125;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://xsc062.netlify.app/20241021-1/</guid>
            <title>长链剖分 学习笔记</title>
            <link>https://xsc062.netlify.app/20241021-1/</link>
            <category>树链剖分</category>
            <category>长链剖分</category>
            <pubDate>Mon, 21 Oct 2024 16:33:47 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;&lt;em&gt;半端な生命の関数を / 少々ここらでオーバーライド&lt;/em&gt;&lt;/p&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;内容-性质&#34;&gt;内容 &amp;amp; 性质&lt;/h2&gt;
&lt;p&gt;把重链剖分选的 siz 最大的儿子换成高度最大的儿子就是长剖了。同样具有一些美妙的性质。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;任意点到根节点经过的链数最劣为 &lt;span class=&#34;math inline&#34;&gt;\(\sqrt n\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;考虑构造一条经过了 &lt;span class=&#34;math inline&#34;&gt;\(\sqrt n+1\)&lt;/span&gt; 条链的路径，发现构造不出来。得证。（？）&lt;/p&gt;
这点也决定了长剖和重剖走的不是一条赛道，更多的是处理一些和深度有关的场景下的问题。用法有点像 dsu on tree。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;任意点 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 的 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 级祖先 &lt;span class=&#34;math inline&#34;&gt;\(fa\)&lt;/span&gt; 所在链长 &lt;span class=&#34;math inline&#34;&gt;\(\ge k\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;考虑反证。若 &lt;span class=&#34;math inline&#34;&gt;\(fa\)&lt;/span&gt; 所在链长度 &lt;span class=&#34;math inline&#34;&gt;\(&amp;lt;k\)&lt;/span&gt;，则 &lt;span class=&#34;math inline&#34;&gt;\(fa\to x\)&lt;/span&gt; 更优，矛盾。故原命题成立。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;求-k-级祖先&#34;&gt;求 k 级祖先&lt;/h2&gt;
&lt;p&gt;长剖的一个典型应用是 &lt;span class=&#34;math inline&#34;&gt;\(O(n\log n)-O(1)\)&lt;/span&gt; 求 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 级祖先。先考虑相对暴力的做法，可以 &lt;span class=&#34;math inline&#34;&gt;\(O(n\sqrt n)\)&lt;/span&gt; 预处理每个点的 &lt;span class=&#34;math inline&#34;&gt;\(1\sim \sqrt n\)&lt;/span&gt; 级祖先然后块间块内随便跳一跳就是 &lt;span class=&#34;math inline&#34;&gt;\(O(\sqrt n)\)&lt;/span&gt; 的单次查询了。&lt;/p&gt;
&lt;p&gt;把这个暴力结合「任意点 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 级祖先所在链长 &lt;span class=&#34;math inline&#34;&gt;\(\ge k\)&lt;/span&gt;」的性质，令 &lt;span class=&#34;math inline&#34;&gt;\(r=\dfrac k2\)&lt;/span&gt;，那么 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 的 &lt;span class=&#34;math inline&#34;&gt;\(r\)&lt;/span&gt; 级祖先所在链长 &lt;span class=&#34;math inline&#34;&gt;\(\ge r\)&lt;/span&gt;。假设我们现在已经知道 &lt;span class=&#34;math inline&#34;&gt;\(r\)&lt;/span&gt; 级祖先 &lt;span class=&#34;math inline&#34;&gt;\(fa_r\)&lt;/span&gt;，预处理出链内点序列、链顶向上的链长个祖先（均摊 &lt;span class=&#34;math inline&#34;&gt;\(O(n)\)&lt;/span&gt;），就可以 &lt;span class=&#34;math inline&#34;&gt;\(O(1)\)&lt;/span&gt; 访问 &lt;span class=&#34;math inline&#34;&gt;\(fa_k\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;怎么找到 &lt;span class=&#34;math inline&#34;&gt;\(fa_r\)&lt;/span&gt; 呢？这看似是递归的问题，实际上发现 &lt;span class=&#34;math inline&#34;&gt;\(r\)&lt;/span&gt; 的取值只需 &lt;span class=&#34;math inline&#34;&gt;\(\ge \dfrac k2\)&lt;/span&gt;，对于 &lt;span class=&#34;math inline&#34;&gt;\(1\sim n\)&lt;/span&gt; 的每一个 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt;，找到其最高二进制位 &lt;span class=&#34;math inline&#34;&gt;\(r\)&lt;/span&gt;（显然 &lt;span class=&#34;math inline&#34;&gt;\(r\)&lt;/span&gt; 的可能取值有 &lt;span class=&#34;math inline&#34;&gt;\(\log n\)&lt;/span&gt; 种），对于每个点，预处理出其 &lt;span class=&#34;math inline&#34;&gt;\(\log n\)&lt;/span&gt; 个不同的 &lt;span class=&#34;math inline&#34;&gt;\(r\)&lt;/span&gt; 级祖先。这个就是倍增了。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;for (int i = 1, mx = 0; i &amp;lt;= n; ++i) &amp;#123;
    if (i &amp;gt;= (1 &amp;lt;&amp;lt; mx) * 2)
        ++mx;
    to[i] = mx;
&amp;#125;
std::vector&amp;lt;std::array&amp;lt;int, 21&amp;gt; &amp;gt; fa(n + 1);
std::vector&amp;lt;int&amp;gt; h(n + 1, 1), son(n + 1), dep(n + 1);
h[0] = 0;
std::function&amp;lt;void(int)&amp;gt; DFS = [&amp;amp;](int x) &amp;#123;
    for (auto i : g[x])
        if (i != fa[x][0]) &amp;#123;
            fa[i][0] = x;
            for (int j = 1; j &amp;lt;= 20; ++j)
                fa[i][j] = fa[fa[i][j - 1]][j - 1];
            dep[i] = dep[x] + 1;
            DFS(i);
            if (h[i] &amp;gt;= h[son[x]])
                son[x] = i, h[x] = h[i] + 1;
        &amp;#125;
    return;
&amp;#125;;
dep[1] = 1, DFS(1);
std::vector&amp;lt;int&amp;gt; top(n + 1), id(n + 1);
std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; anc(n + 1), des(n + 1, std::vector&amp;lt;int&amp;gt; (1));
std::function&amp;lt;void(int, int)&amp;gt; DFS1 = [&amp;amp;](int x, int toq) &amp;#123;
    top[x] = toq;
    if (son[x])
        DFS1(son[x], toq);
    for (auto i : g[x])
        if (i != fa[x][0] &amp;amp;&amp;amp; i != son[x])
            DFS1(i, i);
    des[toq].push_back(x);
    id[x] = (int)des[toq].size() - 1;
    if (x == toq) &amp;#123;
        anc[x].push_back(x);
        for (int j = 1, now = x; j &amp;lt;= id[x]; ++j, now = fa[now][0])
            anc[x].push_back(fa[now][0]);
    &amp;#125;
    return;
&amp;#125;;
DFS1(1, 1);
auto ask = [&amp;amp;](int x, int k) &amp;#123;
    int x1 = x;
    if (!k)
        return x;
    x = fa[x][to[k]];
    if (dep[x] - dep[top[x]] &amp;gt;= k - (1 &amp;lt;&amp;lt; to[k]))
        return des[top[x]][id[x] + k - (1 &amp;lt;&amp;lt; to[k])];
    return anc[top[x]][k - (1 &amp;lt;&amp;lt; to[k]) - (dep[x] - dep[top[x]])];
&amp;#125;;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;优化-dp&#34;&gt;优化 DP&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;yly：管它这那的，只要是有关深度直接上长剖就是了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;和 DSU on tree 类似，主要利用每条链只会被算一次实现 &lt;span class=&#34;math inline&#34;&gt;\(O(n)\)&lt;/span&gt; DP。具体地，尽可能地『继承』长链的信息，『短链』则暴力合并。&lt;/p&gt;
&lt;p&gt;值得注意的是，一般『深度』这一维信息会以『与 &lt;span class=&#34;math inline&#34;&gt;\(u\)&lt;/span&gt; 的距离』的形式，结合指针来维护（因为直接记录深度会更史）。&lt;/p&gt;
&lt;p&gt;具体地，用一个全局大数组容纳所有信息，为每个点分配相应的数组头指针。正常情况下需要用到的元素最多为 &lt;span class=&#34;math inline&#34;&gt;\(2n\)&lt;/span&gt;，但如果存在一些诡异的前移后移操作就另当别论了。&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;p5904-poi-2014-hot-hotels-加强版&#34;&gt;P5904 [POI 2014] HOT-Hotels 加强版&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P5904&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P5904&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;首先 &lt;del&gt;不难&lt;/del&gt; 得到 &lt;span class=&#34;math inline&#34;&gt;\(O(n^2)\)&lt;/span&gt; 做法：显然存在一个点到三个点距离相等。这个点既可能是它们的 LCA，也可能是其中一个点的子孙，另外两个点的 LCA。综上，&lt;strong&gt;在 LCA 处统计答案是可行的&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;令 &lt;span class=&#34;math inline&#34;&gt;\(f_{i,j}\)&lt;/span&gt; 表示 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 子树中距离 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 为 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; 的点数；&lt;span class=&#34;math inline&#34;&gt;\(g_{i,j}\)&lt;/span&gt; 表示 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 子树中距离 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 为 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt;、或者距 LCA 为 &lt;span class=&#34;math inline&#34;&gt;\(d\)&lt;/span&gt; 且 LCA 距离 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 为 &lt;span class=&#34;math inline&#34;&gt;\(d-j\)&lt;/span&gt; 的点对数；随便做就可以了。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#endif
    int n;
    std::cin &amp;gt;&amp;gt; n;
    std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; g1(n + 1);
    for (int i = 1, x, y; i &amp;lt; n; ++i) &amp;#123;
        std::cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; y;
        g1[x].push_back(y), g1[y].push_back(x);
    &amp;#125;
    auto res(0ll);
    std::vector&amp;lt;int&amp;gt; h(n + 1);
    std::vector&amp;lt;std::vector&amp;lt;long long&amp;gt; &amp;gt; f(n + 1), g(n + 1);
    std::function&amp;lt;void(int, int)&amp;gt; DFS = [&amp;amp;](int x, int fa) &amp;#123;
        h[x] = 1;
        for (auto i : g1[x])
            if (i != fa) &amp;#123;
                DFS(i, x);
                h[x] = std::max(h[x], h[i] + 1);
            &amp;#125;
        f[x].resize(h[x] + 1), g[x].resize(h[x] + 1);
        f[x][0] = 1ll;
        for (auto i : g1[x])
            if (i != fa) &amp;#123;
                for (int j = 0; j &amp;lt;= h[i]; ++j) &amp;#123;
                    if (j &amp;gt;= 1)
                        res += g[x][j] * f[i][j - 1];
                    if (j &amp;gt;= 1 &amp;amp;&amp;amp; j + 1 &amp;lt;= h[i])
                        res += f[x][j] * g[i][j + 1];
                    if (j &amp;gt;= 1) &amp;#123;
                        g[x][j] += f[x][j] * f[i][j - 1];
                        f[x][j] += f[i][j - 1];
                    &amp;#125;
                    if (j + 1 &amp;lt;= h[i])
                        g[x][j] += g[i][j + 1];
                &amp;#125;
                std::vector&amp;lt;long long&amp;gt;().swap(f[i]);
                std::vector&amp;lt;long long&amp;gt;().swap(g[i]);
            &amp;#125;
        res += g[x][0];
        return;
    &amp;#125;;
    DFS(1, -1);
    std::cout &amp;lt;&amp;lt; res &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;p&gt;然后对于每个 &lt;span class=&#34;math inline&#34;&gt;\(u\)&lt;/span&gt;，类似 DSU on tree，继承其长儿子的数据（整体前移 / 后移一位，使用指针实现），再把短儿子暴力合并上来。&lt;/p&gt;
&lt;p&gt;每次合并短儿子，数组长为短儿子链长；&lt;span class=&#34;math inline&#34;&gt;\(u\)&lt;/span&gt; 向上合并时，数组长为长儿子链长。故所有链被合并恰好一次，复杂度 &lt;span class=&#34;math inline&#34;&gt;\(O(n)\)&lt;/span&gt;。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#endif
    int n;
    std::cin &amp;gt;&amp;gt; n;
    std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; g1(n + 1);
    for (int i = 1, x, y; i &amp;lt; n; ++i) &amp;#123;
        std::cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; y;
        g1[x].push_back(y), g1[y].push_back(x);
    &amp;#125;
    std::vector&amp;lt;int&amp;gt; h(n + 1), son(n + 1);
    std::vector&amp;lt;long long&amp;gt; df(5 * n + 1), dg(5 * n + 1);
    std::function&amp;lt;void(int, int)&amp;gt; DFS = [&amp;amp;](int x, int fa) &amp;#123;
        h[x] = 1;
        for (auto i : g1[x])
            if (i != fa) &amp;#123;
                DFS(i, x);
                h[x] = std::max(h[x], h[i] + 1);
                if (h[i] &amp;gt; h[son[x]])
                    son[x] = i;
            &amp;#125;
        return;
    &amp;#125;;
    DFS(1, -1);
    auto pos(dg.begin() + 3 * n);
    std::vector&amp;lt;decltype(df.begin())&amp;gt; f(n + 1), g(n + 1);
    auto res(0ll);
    DFS = [&amp;amp;](int x, int fa) &amp;#123;
        f[x][0] = 1ll;
        if (son[x]) &amp;#123;
            f[son[x]] = std::next(f[x]), g[son[x]] = std::prev(g[x]);
            DFS(son[x], x);
        &amp;#125;
        for (auto i : g1[x])
            if (i != fa &amp;amp;&amp;amp; i != son[x]) &amp;#123;
                f[i] = std::next(f[x], h[x] + 1);
                std::fill(f[i], f[i] + h[i] + 2, 0ll);
                g[i] = std::next(pos, h[i]), pos = std::next(g[i], h[i]);
                std::fill(std::prev(g[i]), g[i] + h[i] + 2, 0ll);
                DFS(i, x);
                for (int j = 0; j &amp;lt;= h[i]; ++j) &amp;#123;
                    if (j &amp;gt;= 1)
                        res += g[x][j] * f[i][j - 1];
                    if (j &amp;gt;= 1 &amp;amp;&amp;amp; j + 1 &amp;lt;= h[i])
                        res += f[x][j] * g[i][j + 1];
                    if (j &amp;gt;= 1) &amp;#123;
                        g[x][j] += f[x][j] * f[i][j - 1];
                        f[x][j] += f[i][j - 1];
                    &amp;#125;
                    if (j + 1 &amp;lt;= h[i])
                        g[x][j] += g[i][j + 1];
                &amp;#125;
            &amp;#125;
        res += g[x][0];
        return;
    &amp;#125;;
    f[1] = df.begin(), g[1] = dg.begin() + 2 * n;
    DFS(1, -1);
    std::cout &amp;lt;&amp;lt; res &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;cf1585g-poachers&#34;&gt;CF1585G Poachers&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://codeforces.com/problemset/problem/1585/G&#34; class=&#34;uri&#34;&gt;https://codeforces.com/problemset/problem/1585/G&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;公平博弈。我们现在要算每个根的 SG 值。设 &lt;span class=&#34;math inline&#34;&gt;\(f_{u,j}\)&lt;/span&gt; 表示在点 &lt;span class=&#34;math inline&#34;&gt;\(u\)&lt;/span&gt;，删了距离它为 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; 这一层的 SG 值，那么有：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
f_{u,j}=
\begin{cases}
\text{mex}\{f_{v,0}\}&amp;amp;j=0\\
\bigoplus f_{v,j-1}&amp;amp;\text{otherwise}
\end{cases}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;然后发现有深度维。大力长剖。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int inf = 0x3f3f3f3f;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#endif
    int T;
    for (std::cin &amp;gt;&amp;gt; T; T--; ) &amp;#123;
        int n;
        std::cin &amp;gt;&amp;gt; n;
        std::vector&amp;lt;int&amp;gt; rt;
        std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; g(n + 1);
        for (int i = 1, x; i &amp;lt;= n; ++i) &amp;#123;
            std::cin &amp;gt;&amp;gt; x;
            if (x)
                g[x].push_back(i);
            else
                rt.push_back(i);
        &amp;#125;
        std::vector&amp;lt;int&amp;gt; h(n + 1), son(n + 1), to(n + 1, inf);
        std::function&amp;lt;void(int)&amp;gt; DFS = [&amp;amp;](int x) &amp;#123;
            h[x] = 1;
            for (auto i : g[x]) &amp;#123;
                DFS(i);
                h[x] = std::max(h[x], h[i] + 1);
                to[x] = std::min(to[x], to[i] + 1);
                if (h[i] &amp;gt; h[son[x]])
                    son[x] = i;
            &amp;#125;
            to[x] = std::min(to[x], h[x]);
            return;
        &amp;#125;;
        for (auto i : rt)
            DFS(i);
        std::vector&amp;lt;int&amp;gt; _f(5 * n + 1), top(n + 1);
        std::vector&amp;lt;decltype(_f.begin())&amp;gt; f(n + 1);
        std::vector&amp;lt;std::unordered_set&amp;lt;int&amp;gt; &amp;gt; s(n + 1);
        auto p(_f.begin());
        DFS = [&amp;amp;](int x) &amp;#123;
            if (son[x]) &amp;#123;
                f[son[x]] = std::next(f[x]);
                top[son[x]] = top[x], DFS(son[x]);
            &amp;#125;
            if ((int)g[x].size() == 1) &amp;#123;
                s[top[x]].insert(f[son[x]][0]);
                for (int now = f[son[x]][0] + 1; ; ++now)
                    if (!s[top[x]].count(now)) &amp;#123;
                        f[x][0] = now;
                        break;
                    &amp;#125;
                return;
            &amp;#125;
            for (auto i : g[x])
                if (i != son[x]) &amp;#123;
                    f[i] = p, p = std::next(p, h[i] + 1);
                    top[i] = i, DFS(i);
                    for (int j = 1; j &amp;lt;= to[i] + 1; ++j)
                        f[x][j] ^= f[i][j - 1];
                &amp;#125;
            std::unordered_set&amp;lt;int&amp;gt;().swap(s[top[x]]);
            for (int j = 1; j &amp;lt;= to[x]; ++j)
                s[top[x]].insert(f[x][j]);
            for (int now = 0; ; ++now)
                if (!s[top[x]].count(now)) &amp;#123;
                    f[x][0] = now;
                    break;
                &amp;#125;
            return;
        &amp;#125;;
        int res = 0;
        for (auto i : rt) &amp;#123;
            f[i] = p, p = std::next(p, h[i] + 1);
            DFS(i), res ^= f[i][0];
        &amp;#125;
        std::cout &amp;lt;&amp;lt; (res ? &amp;quot;YES&amp;quot; : &amp;quot;NO&amp;quot;) &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    &amp;#125;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://xsc062.netlify.app/20231230/</guid>
            <title>解题报告 [SDOI2016] 游戏</title>
            <link>https://xsc062.netlify.app/20231230/</link>
            <category>李超线段树</category>
            <category>树链剖分</category>
            <pubDate>Sat, 30 Dec 2023 12:12:30 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;可以看出来出题人很想出一道把李超和别的什么东西凑起来的题目，于是给了这么一个缝合怪。&lt;/p&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P4069&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P4069&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;符号有点混乱。比如箭头又可以表示路径又可以表示赋值，代入语境应该还是好理解的。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;看到 &lt;span class=&#34;math inline&#34;&gt;\(a\times dis + b\)&lt;/span&gt; 就应激反应出来是李超了，看到 &lt;span class=&#34;math inline&#34;&gt;\(s\to t\)&lt;/span&gt; 又瞬间反应过来是树剖，但是树剖的 DFN 和 &lt;span class=&#34;math inline&#34;&gt;\(dis\)&lt;/span&gt; 没有直接关联，赛时想不到怎么做就跑路了。&lt;/p&gt;
&lt;p&gt;实际上这个转化很板。因为这是条路径，我们还在树链上跳，每次跳过的一个链上的 DFN 是连续的，对应的 &lt;span class=&#34;math inline&#34;&gt;\(dis\)&lt;/span&gt; 也是连续的。&lt;/p&gt;
&lt;p&gt;估计是打 T4 的子树问题打傻了，没想到这个。&lt;/p&gt;
&lt;p&gt;所以我们就相当于是给一条重链上的某个连续区间加了一个斜率为 &lt;span class=&#34;math inline&#34;&gt;\(a\)&lt;/span&gt;，截距为 &lt;span class=&#34;math inline&#34;&gt;\(b\)&lt;/span&gt; 加上 &lt;em&gt;一坨东西&lt;/em&gt; 的线段。用李超维护即可。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;感觉讲的不清不楚的，那就再讲讲。&lt;/p&gt;
&lt;p&gt;我们要让李超上任意一个点 &lt;span class=&#34;math inline&#34;&gt;\(u\)&lt;/span&gt; 代表的 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 是个定值。&lt;em&gt;一坨东西&lt;/em&gt; 维护了这条线段相对于 &lt;span class=&#34;math inline&#34;&gt;\(s\)&lt;/span&gt; 的偏移量。令 &lt;span class=&#34;math inline&#34;&gt;\(r\gets \text{LCA of } s \text { and } t\)&lt;/span&gt;，&lt;span class=&#34;math inline&#34;&gt;\(R\)&lt;/span&gt; 表示整棵树的根，&lt;span class=&#34;math inline&#34;&gt;\(d(u,v)\gets \text {distance between } u \text { and } v\)&lt;/span&gt;。&lt;/p&gt;
&lt;ol type=&#34;1&#34;&gt;
&lt;li&gt;&lt;p&gt;对于 &lt;span class=&#34;math inline&#34;&gt;\(s\to r\)&lt;/span&gt; 上的每个点 &lt;span class=&#34;math inline&#34;&gt;\(u\)&lt;/span&gt;：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
\begin{aligned}
val_u&amp;amp;=a\times d(s, u)+b\\
&amp;amp;=a\times[d(s,R)-d(u,R)]+b\\
&amp;amp;=-a\times d(u,R)+[a\times d(s,R)+b]
\end{aligned}
\]&lt;/span&gt; &lt;span class=&#34;math inline&#34;&gt;\(a\times d(s,R)+b\)&lt;/span&gt; 是和 &lt;span class=&#34;math inline&#34;&gt;\(u\)&lt;/span&gt; 无关的定值（这意味着可以在同一个询问的树剖时直接线段树），&lt;span class=&#34;math inline&#34;&gt;\(d(u,R)\)&lt;/span&gt; 是只和 &lt;span class=&#34;math inline&#34;&gt;\(u\)&lt;/span&gt; 相关的值（这意味着对于任意询问都成立）。令斜率为 &lt;span class=&#34;math inline&#34;&gt;\(-a\)&lt;/span&gt;，截距为 &lt;span class=&#34;math inline&#34;&gt;\(a\times d(s,R)+b\)&lt;/span&gt;，李超上任意点 &lt;span class=&#34;math inline&#34;&gt;\(u\)&lt;/span&gt; 代表 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 为 &lt;span class=&#34;math inline&#34;&gt;\(d(x,R)\)&lt;/span&gt;，维护如此一条线段即可。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;对于 &lt;span class=&#34;math inline&#34;&gt;\(r\to t\)&lt;/span&gt; 上的每个点 &lt;span class=&#34;math inline&#34;&gt;\(v\)&lt;/span&gt;： &lt;span class=&#34;math display&#34;&gt;\[
\begin{aligned}
val_v&amp;amp;=a\times d(s,v)+b\\
&amp;amp;= a\times [d(r,v)+d(s,r)]+b\\
&amp;amp;=a\times [d(v,R)-d(r,R)+d(s,r)]+b\\
&amp;amp;=a\times d(v,R)+[-a\times d(r,R)+a\times d(s,r)+b]
\end{aligned}
\]&lt;/span&gt; &lt;span class=&#34;math inline&#34;&gt;\(-a\times d(r,R)+a\times d(s,r)+b\)&lt;/span&gt; 是和 &lt;span class=&#34;math inline&#34;&gt;\(v\)&lt;/span&gt; 无关，只和询问中固定的 &lt;span class=&#34;math inline&#34;&gt;\(s,r,a,b\)&lt;/span&gt; 有关的定值；&lt;span class=&#34;math inline&#34;&gt;\(d(v,R)\)&lt;/span&gt; 是只和 &lt;span class=&#34;math inline&#34;&gt;\(v\)&lt;/span&gt; 相关的值且和上一个 case 里的 &lt;span class=&#34;math inline&#34;&gt;\(d(u,R)\)&lt;/span&gt; 同构，也用李超这么维护即可。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;用李超维护把原问题转化为每次向若干重链上连续区间插入线段，求最低交点的问题。&lt;/p&gt;
&lt;p&gt;注意到区间查询，李超需要加一个 pushup。具体怎么去操作呢？在加线段的时候除编号外新增一个变量维护当前区间内最低交点；我们就 pushup 这个东西。然后查询的时候就是在散区间的时候和原来一样查，整区间就在散区间答案的基础上再和当前区间的整体最低交点比一个 min。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#define int long long
namespace XSC062 &amp;#123;
using namespace fastIO;
const int maxk = 25;
const int maxn = 1e6 + 5;
const int maxm = 1e6 + 5;
const int inf = 123456789123456789;
//#define DEBUG

#ifdef DEBUG
#define Z(x) x
#else
#define Z(x)
#endif
#define lt (p &amp;lt;&amp;lt; 1)
#define rt (lt | 1)
struct __ &amp;#123; int k, b; &amp;#125;;
struct _ &amp;#123; int l, r, u, d; &amp;#125;;
struct ____ &amp;#123;
    int v, w;
    ____() &amp;#123;&amp;#125;
    ____(int v1, int w1) &amp;#123;
        v = v1, w = w1; 
    &amp;#125;
&amp;#125;;
__ a[maxm];
_ t[maxn &amp;lt;&amp;lt; 2];
int tot, si, now;
int f[maxn][maxk];
int dis[maxn], dep[maxn];
int dfn[maxn], tab[maxn];
std::vector&amp;lt;____&amp;gt; g[maxn];
int n, m, ty, x, y, w, k, b;
int siz[maxn], top[maxn], son[maxn];
int max(int x, int y) &amp;#123;
    return x &amp;gt; y ? x : y;
&amp;#125;
int min(int x, int y) &amp;#123;
    return x &amp;lt; y ? x : y;
&amp;#125;
void swap(int &amp;amp;x, int &amp;amp;y) &amp;#123;
    x ^= y ^= x ^= y;
    return;
&amp;#125;
void DFS1(int x) &amp;#123;
    siz[x] = 1;
    for (auto i : g[x]) &amp;#123;
        if (i.v == f[x][0]) continue;
        f[i.v][0] = x;
        for (int j = 1; j &amp;lt;= si; ++j)
            f[i.v][j] = f[f[i.v][j - 1]][j - 1];
        dep[i.v] = dep[x] + 1;
        dis[i.v] = dis[x] + i.w;
        DFS1(i.v);
        if (siz[i.v] &amp;gt; siz[son[x]])
            son[x] = i.v;
        siz[x] += siz[i.v];
    &amp;#125;
    return;
&amp;#125;
void DFS2(int x, int t) &amp;#123;
    top[x] = t;
    dfn[x] = ++now, tab[now] = x;
    if (son[x]) DFS2(son[x], t);
    for (auto i : g[x]) &amp;#123;
        if (i.v == f[x][0] || i.v == son[x])
            continue;
        DFS2(i.v, i.v);
    &amp;#125;
    return;
&amp;#125;
void bld(int p, int l, int r) &amp;#123;
    t[p].l = l, t[p].r = r, t[p].d = inf;
    if (l == r) return;
    int mid = (l + r) &amp;gt;&amp;gt; 1;
    bld(lt, l, mid), bld(rt, mid + 1, r);
    return;
&amp;#125;
int getv(int id, int x) &amp;#123;
    if (!id) return inf;
    Z(printf(&amp;quot;get (%lld, %lld) = %lld\n&amp;quot;,
        id, x, dis[tab[x]] * a[id].k + a[id].b));
    return dis[tab[x]] * a[id].k + a[id].b;
&amp;#125;
void pushup(int p) &amp;#123;
    if (t[p].l == t[p].r) return;
    t[p].d = min(t[p].d, min(t[lt].d, t[rt].d));
    Z(printf(&amp;quot;[%lld, %lld]: pushup to %lld\n&amp;quot;,
        t[p].l, t[p].r, t[p].d));
    return;
&amp;#125;
void chg(int p, int id) &amp;#123;
    t[p].u = id;
    Z(int tmp = t[p].d);
    t[p].d = min(getv(id, t[p].l),
                 getv(id, t[p].r));
    Z(printf(&amp;quot;[%lld, %lld]: %lld -&amp;gt; %lld\n&amp;quot;,
                t[p].l, t[p].r, tmp, t[p].d)); 
    return;
&amp;#125;
void upd(int p, int id) &amp;#123;
    if (!t[p].u) &amp;#123;
        chg(p, id), pushup(p);
        return;
    &amp;#125;
    int mid = (t[p].l + t[p].r) &amp;gt;&amp;gt; 1;
    int v1 = getv(t[p].u, mid),
        v2 = getv(id, mid);
    if (v2 &amp;lt; v1) swap(t[p].u, id);
    v1 = getv(t[p].u, t[p].l);
    v2 = getv(id, t[p].l);
    if (v2 &amp;lt; v1) upd(lt, id);
    v1 = getv(t[p].u, t[p].r);
    v2 = getv(id, t[p].r);
    if (v2 &amp;lt; v1) upd(rt, id);
    chg(p, t[p].u);
    pushup(p);
    return;
&amp;#125;
void add(int p, int l, int r, int id) &amp;#123;
    if (l &amp;lt;= t[p].l &amp;amp;&amp;amp; t[p].r &amp;lt;= r) &amp;#123;
        upd(p, id);
        return;
    &amp;#125;
    int mid = (t[p].l + t[p].r) &amp;gt;&amp;gt; 1;
    if (l &amp;lt;= mid) add(lt, l, r, id);
    if (r &amp;gt; mid) add(rt, l, r, id);
    pushup(p);
    return;
&amp;#125;
int ask(int p, int l, int r) &amp;#123;
    l = max(l, t[p].l);
    r = min(r, t[p].r);
    int res = min(getv(t[p].u, l),
                  getv(t[p].u, r));
    Z(printf(&amp;quot;[%lld, %lld]: res = %lld\n&amp;quot;,
        t[p].l, t[p].r, res));
    if (l &amp;lt;= t[p].l &amp;amp;&amp;amp; t[p].r &amp;lt;= r)
        return min(res, t[p].d);
    int mid = (t[p].l + t[p].r) &amp;gt;&amp;gt; 1;
    if (l &amp;lt;= mid) res = min(res, ask(lt, l, r));
    if (r &amp;gt; mid) res = min(res, ask(rt, l, r));
    Z(printf(&amp;quot;[%lld, %lld]: res = %lld\n&amp;quot;,
        t[p].l, t[p].r, res));
    return res;
&amp;#125;
void add(int x, int y, int w) &amp;#123;
    g[x].push_back(____(y, w));
    return;
&amp;#125;
void ins(int l, int r, int k, int b) &amp;#123;
    a[++tot].k = k, a[tot].b = b;
    add(1, l, r, tot);
    return;
&amp;#125;
int getLCA(int x, int y) &amp;#123;
    if (dep[x] &amp;lt; dep[y]) swap(x, y);
    for (int i = si; ~i; --i) &amp;#123;
        if (dep[f[x][i]] &amp;gt;= dep[y])
            x = f[x][i];
    &amp;#125;
    if (x == y) return x;
    for (int i = si; ~i; --i) &amp;#123;
        if (f[x][i] != f[y][i])
            x = f[x][i], y = f[y][i];
    &amp;#125;
    return f[x][0];
&amp;#125;
void inst(int s, int t, int k, int b) &amp;#123;
    int r = getLCA(s, t), u = s;
    while (top[u] != top[r]) &amp;#123;
        ins(dfn[top[u]], dfn[u],
                    -k, k * dis[s] + b);
        u = f[top[u]][0];
    &amp;#125;
    ins(dfn[r], dfn[u], -k, k * dis[s] + b);
    u = t;
    int d = dis[s] - dis[r];
    while (top[u] != top[r]) &amp;#123;
        ins(dfn[top[u]], dfn[u],
                k, -k * dis[r] + k * d + b);
        u = f[top[u]][0];
    &amp;#125;
    ins(dfn[r], dfn[u],
            k, -k * dis[r] + k * d + b);
    return;
&amp;#125;
int qry(int x, int y) &amp;#123;
    int res = inf;
    while (top[x] != top[y]) &amp;#123;
        if (dep[top[x]] &amp;lt; dep[top[y]])
            swap(x, y);
        Z(printf(&amp;quot;ask %lld -&amp;gt; %lld: %lld\n&amp;quot;,
            x, top[x],
            ask(1, dfn[top[x]], dfn[x])));
        res = min(res,
            ask(1, dfn[top[x]], dfn[x]));
        x = f[top[x]][0];
    &amp;#125;
    if (dep[x] &amp;lt; dep[y]) swap(x, y);
    Z(printf(&amp;quot;ask %lld -&amp;gt; %lld: %lld\n&amp;quot;,
        x, y, ask(1, dfn[y], dfn[x])));
    res = min(res, ask(1, dfn[y], dfn[x]));
    return res;
&amp;#125;
int main() &amp;#123;
//  freopen(&amp;quot;game1.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    read(n), read(m);
    si = log(n) / log(2.0);
    for (int i = 1; i &amp;lt; n; ++i) &amp;#123;
        read(x), read(y), read(w);
        add(x, y, w), add(y, x, w);
    &amp;#125;
    bld(1, 1, n);
    dep[1] = 1, DFS1(1), DFS2(1, -1);
    Z(for (int i = 1; i &amp;lt;= n; ++i)
        printf(&amp;quot;dfn[%lld] = %lld\n&amp;quot;, i, dfn[i]));
    while (m--) &amp;#123;
        read(ty), read(x), read(y);
        if (ty == 1) &amp;#123;
            read(k), read(b);
            inst(x, y, k, b);
        &amp;#125;
        else print(qry(x, y), &amp;#39;\n&amp;#39;);
    &amp;#125;
    return 0;
&amp;#125;
&amp;#125; // namespace XSC062
#undef int&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
 ]]></description>
        </item>
    </channel>
</rss>
