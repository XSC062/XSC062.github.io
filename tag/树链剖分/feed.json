{
    "version": "https://jsonfeed.org/version/1",
    "title": "null â€¢ All posts by \"æ ‘é“¾å‰–åˆ†\" tag",
    "description": "",
    "home_page_url": "https://xsc062.netlify.app",
    "items": [
        {
            "id": "https://xsc062.netlify.app/20250812/",
            "url": "https://xsc062.netlify.app/20250812/",
            "title": "DDP ä¸å…¨å±€å¹³è¡¡äºŒå‰æ ‘",
            "date_published": "2025-08-12T00:16:52.000Z",
            "content_html": "<p>å…¶å®åŠ¨æ€ DP ä¸æ˜¯åŠ¨æ€æ ‘ DP çš„åŒä¹‰è¯</p>\n<span id=\"more\"></span>\n<hr />\n<h2 id=\"åŠ¨æ€-dp\">åŠ¨æ€ DP</h2>\n<p>å¯¹äºè½¬ç§»åªä¾èµ–å‰å‡ é¡¹çš„ DPï¼Œå¯ä»¥æ”¾è¿›çŸ©é˜µã€‚</p>\n<p>é»˜è®¤è½¬ç§»èŒƒå›´æ˜¯ <span class=\"math inline\">\\([1,n]\\)</span>ï¼›å¦‚æœæˆ‘ä»¬éœ€è¦æ”¹å˜æ±‚è§£èŒƒå›´ï¼Œå‘ç°å¦‚æœèƒ½è·å–è½¬ç§»çŸ©é˜µçš„ä¹˜ç§¯å°±å¾ˆå¿«äº†ã€‚è€ƒè™‘å­˜ä¸‹æ¥ã€‚</p>\n<p>å¦‚æœéœ€è¦å•ç‚¹ä¿®æ”¹ï¼Œç­‰ä»·äºä¿®æ”¹å…¶æ‰€åœ¨çŸ©é˜µï¼Œåˆ™æƒ³è¦å°½å¯èƒ½å°‘åœ°ä¿®æ”¹å­˜å‚¨çš„ç­”æ¡ˆï¼Œè€ƒè™‘ä½¿ç”¨çº¿æ®µæ ‘ä¼˜åŒ–è¯¥è¿‡ç¨‹ã€‚</p>\n<h3 id=\"ä¾‹æµ·æŠ¥\">ä¾‹ï¼šæµ·æŠ¥</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P9790\" class=\"uri\">https://www.luogu.com.cn/problem/P9790</a></p>\n<p>å®¹æ˜“åˆ—å‡ºæš´åŠ› DP å¼ï¼šä»¤ <span class=\"math inline\">\\(f_{i,j}\\)</span> è¡¨ç¤ºæšä¸¾åˆ° <span class=\"math inline\">\\(i\\)</span> æ—¶ï¼ŒåŒ…å« <span class=\"math inline\">\\(i\\)</span> åœ¨å†…å·²ç»æœ‰ <span class=\"math inline\">\\(j\\)</span> ä¸ªè¿ç»­çš„äººä¸¾èµ·æµ·æŠ¥ï¼Œæ˜“å¾—ï¼š</p>\n<p><span class=\"math display\">\\[\nf_{i,0}=\\max(f_{i-1,0},f_{i-1,1},f_{i-1,2},f_{i-1,3})\\\\\nf_{i,j}=f_{i-1,j-1}+a_i \\forall 1\\le j\\le 3\n\\]</span></p>\n<p>å‘ç°æ»¡è¶³ + / max <strong>çŸ©é˜µä¹˜æ³•</strong> çš„å½¢å¼ï¼›æƒ³åˆ°ç”¨çº¿æ®µæ ‘ä¿å­˜æ¯æ®µåŒºé—´å¯¹åº”çŸ©é˜µï¼ˆå¯¹åº”æ€§è´¨ï¼šç»“åˆå¾‹ï¼‰ï¼Œæ¯æ¬¡ä¿®æ”¹ / æŸ¥è¯¢å°±èƒ½åœ¨ <span class=\"math inline\">\\(O(\\log n)\\)</span> ä¹‹å†…å®Œæˆã€‚</p>\n<p>åŸé—®é¢˜æ˜¯ç¯å½¢çš„ï¼Œå¯ä»¥å†åŠ ä¸€ç»´ <span class=\"math inline\">\\(k\\)</span> è¡¨ç¤ºé’¦å®šé€‰äº†å‰ <span class=\"math inline\">\\(k\\)</span> ä¸ªä¸”ä¸é€‰ç¬¬ <span class=\"math inline\">\\(k+1\\)</span> ä¸ªæ—¶çš„ç­”æ¡ˆã€‚</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 4e4 + 5;\nconst long long inf = 1e18;\nstruct mat &#123;\n    int n, m;\n    long long a[4][4];\n    mat() &#123;&#125;\n    mat(int n1, int m1): n(n1), m(m1) &#123;\n        for (int i = 0; i &lt; n; ++i)\n            for (int j = 0; j &lt; m; ++j)\n                a[i][j] = -inf;\n        return;\n    &#125;\n    long long* operator[] (const int q) &#123;\n        return a[q];\n    &#125;\n    mat operator* (mat &amp;q) const &#123;\n        mat res(n, q.m);\n        for (int i = 0; i &lt; n; ++i)\n            for (int k = 0; k &lt; q.m; ++k)\n                for (int j = 0; j &lt; m; ++j)\n                    res[i][k] = std::max(res[i][k], a[i][j] + q[j][k]);\n        return res;\n    &#125;\n    mat&amp; operator*= (mat &amp;q) &#123;\n        return *this = *this * q;\n    &#125;\n&#125;;\nstruct &#123; int l, r; mat u[4]; &#125; t[maxn &lt;&lt; 2];\nint a[maxn];\n#define lt (p &lt;&lt; 1)\n#define rt (lt | 1)\n#define c t[p].u[i]\nvoid bld(int p, int l, int r) &#123;\n    t[p].l = l, t[p].r = r;\n    if (l == r) &#123;\n        for (int i = 0; i &lt;= 3; ++i) &#123;\n            c = mat(4, 4);\n            if (l &gt; i + 1) &#123;\n                c[0][0] = c[1][0] = c[2][0] = c[3][0] = 0;\n                c[0][1] = c[1][2] = c[2][3] = a[l];\n            &#125;\n            else if (l == i + 1)\n                c[0][0] = c[1][0] = c[2][0] = c[3][0] = 0;\n            else\n                c[0][1] = c[1][2] = c[2][3] = a[l];\n        &#125;\n        return;\n    &#125;\n    int mid = (l + r) &gt;&gt; 1;\n    bld(lt, l, mid), bld(rt, mid + 1, r);\n    for (int i = 0; i &lt;= 3; ++i)\n        t[p].u[i] = t[lt].u[i] * t[rt].u[i];\n    return;\n&#125;\nvoid add(int p, int x, int v) &#123;\n    if (t[p].l == t[p].r) &#123;\n        for (int i = 0; i &lt;= 3; ++i)\n            if (t[p].l != i + 1) \n                c[0][1] = c[1][2] = c[2][3] = v;\n        return;\n    &#125;\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (x &lt;= mid)\n        add(lt, x, v);\n    else\n        add(rt, x, v);\n    for (int i = 0; i &lt;= 3; ++i)\n        t[p].u[i] = t[lt].u[i] * t[rt].u[i];\n    return;\n&#125;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i];\n    bld(1, 1, n);\n    auto calc = [&amp;](void) &#123;\n        mat f(1, 4);\n        f[0][0] = 0;\n        auto res = -inf;\n        for (int i = 0; i &lt;= 3; ++i) &#123;\n            auto r = (f * t[1].u[i]);\n            for (int j = 0; j &lt;= 3; ++j)\n                if (i + j &lt;= 3) &#123;\n                    res = std::max(res, r[0][j]);\n                    // printf(&quot;f[%d][%d] = %lld\\n&quot;, i, j, f[i][j]);\n                &#125;\n        &#125;\n        return res;\n    &#125;;\n    std::cout &lt;&lt; calc() &lt;&lt; &#39;\\n&#39;;\n    int q;\n    std::cin &gt;&gt; q;\n    for (int x, v; q--; ) &#123;\n        std::cin &gt;&gt; x &gt;&gt; v;\n        add(1, x, v);\n        std::cout &lt;&lt; calc() &lt;&lt; &#39;\\n&#39;;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<p>å‘ç°çŸ©é˜µæœ¬èº«å’Œ <span class=\"math inline\">\\(k\\)</span> æ— å…³ï¼Œè¿˜å¯ä»¥å¯ä»¥å…±ç”¨ä¸€ä¸ªçº¿æ®µæ ‘ä¸Šçš„ä¿¡æ¯ï¼Œå°±å¯ä»¥åªå¼€ä¸€ä¸ªçº¿æ®µæ ‘äº†ã€‚</p>\n<details>\n<p>æˆ‘å†™è¿™ä¸€ç‰ˆæœ¬çš„åŸå› æ˜¯ <code>maxn</code> å¼€å¤§äº†å¯¼è‡´ MLEï¼Œå®é™…ä¸Šå››ä¸ªçº¿æ®µæ ‘æ˜¯æ²¡æœ‰ä»»ä½•ç©ºé—´å‹åŠ›çš„ ğŸ˜…</p>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 4e5 + 5;\nconst long long inf = 1e18;\nstruct mat &#123;\n    int n, m;\n    long long a[4][4];\n    mat() &#123;&#125;\n    mat(int n1, int m1): n(n1), m(m1) &#123;\n        for (int i = 0; i &lt; n; ++i)\n            for (int j = 0; j &lt; m; ++j)\n                a[i][j] = -inf;\n        return;\n    &#125;\n    long long* operator[] (const int q) &#123;\n        return a[q];\n    &#125;\n    mat operator* (mat q) const &#123;\n        mat res(n, q.m);\n        for (int i = 0; i &lt; n; ++i)\n            for (int k = 0; k &lt; q.m; ++k)\n                for (int j = 0; j &lt; m; ++j)\n                    res[i][k] = std::max(res[i][k], a[i][j] + q[j][k]);\n        return res;\n    &#125;\n    mat&amp; operator*= (mat &amp;q) &#123;\n        return *this = *this * q;\n    &#125;\n&#125;;\nstruct &#123; int l, r; mat u; &#125; t[maxn &lt;&lt; 2];\nint a[maxn];\n#define lt (p &lt;&lt; 1)\n#define rt (lt | 1)\nvoid bld(int p, int l, int r) &#123;\n    t[p].l = l, t[p].r = r;\n    if (l == r) &#123;\n        t[p].u = mat(4, 4);\n        t[p].u[0][0] = t[p].u[1][0] = t[p].u[2][0] = t[p].u[3][0] = 0;\n        t[p].u[0][1] = t[p].u[1][2] = t[p].u[2][3] = a[l];\n        return;\n    &#125;\n    int mid = (l + r) &gt;&gt; 1;\n    bld(lt, l, mid), bld(rt, mid + 1, r);\n    t[p].u = t[lt].u * t[rt].u;\n    return;\n&#125;\nvoid add(int p, int x, int v) &#123;\n    if (t[p].l == t[p].r) &#123;\n        t[p].u[0][1] = t[p].u[1][2] = t[p].u[2][3] = v;\n        return;\n    &#125;\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (x &lt;= mid)\n        add(lt, x, v);\n    else\n        add(rt, x, v);\n    t[p].u = t[lt].u * t[rt].u;\n    return;\n&#125;\nmat ask(int p, int l, int r) &#123;\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r)\n        return t[p].u;\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (r &lt;= mid)\n        return ask(lt, l, r);\n    if (l &gt; mid)\n        return ask(rt, l, r);\n    return ask(lt, l, r) * ask(rt, l, r);\n&#125;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i];\n    bld(1, 1, n);\n    auto calc = [&amp;](void) &#123;\n        mat f(1, 4);\n        f[0][0] = 0, f[0][1] = f[0][2] = f[0][3] = -inf;\n        auto r(f * ask(1, 2, n));\n        auto res(*std::max_element(r[0], r[0] + 4));\n        mat z(4, 4);\n        z[0][0] = z[1][0] = z[2][0] = z[3][0] = 0ll;\n        for (int i = 1; i &lt;= 3; ++i) &#123;\n            mat op(4, 4);\n            op[0][1] = op[1][2] = op[2][3] = a[i];\n            f *= op;\n            if (i + 2 &lt;= n)\n                r = f * z * ask(1, i + 2, n);\n            else\n                r = f * z;\n            res = std::max(res, *std::max_element(r[0], r[0] + 4 - i));\n        &#125;\n        return res;\n    &#125;;\n    std::cout &lt;&lt; calc() &lt;&lt; &#39;\\n&#39;;\n    int q;\n    std::cin &gt;&gt; q;\n    for (int x, v; q--; ) &#123;\n        std::cin &gt;&gt; x &gt;&gt; v, a[x] = v;\n        add(1, x, v);\n        std::cout &lt;&lt; calc() &lt;&lt; &#39;\\n&#39;;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"ç»å…¸é¢˜gss3\">ç»å…¸é¢˜ï¼šGSS3</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/SP1716\" class=\"uri\">https://www.luogu.com.cn/problem/SP1716</a></p>\n<p>æ€ä¹ˆæ˜¯å­æ®µå’Œ ğŸ˜“</p>\n<p>åŒæ ·åˆ—å‡ºèƒ½å¤ŸçŸ©é˜µä¹˜æ³•çš„ DP å¼ï¼Œå‘ç°é™åˆ¶åœ¨äºè‡³å°‘è¦é€‰ä¸€ä¸ªæ•°ã€‚è®¾ <span class=\"math inline\">\\(f_{i}\\)</span> è¡¨ç¤ºé€‰äº† <span class=\"math inline\">\\(i\\)</span> çš„æœ€å¤§å€¼ï¼Œ<span class=\"math inline\">\\(g_i\\)</span> è¡¨ç¤ºå†å²æœ€å¤§å€¼ï¼Œåˆ™ï¼š</p>\n<p><span class=\"math display\">\\[\nf_i=\\max(f_{i-1}+a_i,0+a_i)\\\\\ng_i=\\max(g_{i-1}+0,f_{i-1}+a_i,0+a_i)\n\\]</span></p>\n<p>å®¹æ˜“å‘ç°æ˜¯ä¸€ä¸ª + / max çŸ©ä¹˜ï¼Œçº¿æ®µæ ‘ç»´æŠ¤å³å¯ã€‚</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 4e5 + 5;\nconst long long inf = 1e18;\nstruct mat &#123;\n    int n, m;\n    long long a[3][3];\n    mat() &#123;&#125;\n    mat(int n1, int m1): n(n1), m(m1) &#123;\n        for (int i = 0; i &lt; n; ++i)\n            for (int j = 0; j &lt; m; ++j)\n                a[i][j] = -inf;\n        return;\n    &#125;\n    long long* operator[] (const int q) &#123;\n        return a[q];\n    &#125;\n    mat operator* (mat q) const &#123;\n        mat res(n, q.m);\n        for (int i = 0; i &lt; n; ++i)\n            for (int k = 0; k &lt; q.m; ++k)\n                for (int j = 0; j &lt; m; ++j)\n                    res[i][k] = std::max(res[i][k], a[i][j] + q[j][k]);\n        return res;\n    &#125;\n    mat&amp; operator*= (mat &amp;q) &#123;\n        return *this = *this * q;\n    &#125;\n&#125;;\nstruct &#123; int l, r; mat u; &#125; t[maxn &lt;&lt; 2]; \nint a[maxn];\n#define lt (p &lt;&lt; 1)\n#define rt (lt | 1)\nvoid bld(int p, int l, int r) &#123;\n    t[p].l = l, t[p].r = r;\n    if (l == r) &#123;\n        t[p].u = mat(3, 3);\n        t[p].u[0][0] = t[p].u[2][0] = a[l];\n        t[p].u[0][1] = a[l], t[p].u[1][1] = 0ll, t[p].u[2][1] = a[l];\n        t[p].u[2][2] = 0ll;\n        return;\n    &#125;\n    int mid = (l + r) &gt;&gt; 1;\n    bld(lt, l, mid), bld(rt, mid + 1, r);\n    t[p].u = t[lt].u * t[rt].u;\n    return;\n&#125;\nvoid add(int p, int x, int v) &#123;\n    if (t[p].l == t[p].r) &#123;\n        t[p].u[0][0] = t[p].u[2][0] = t[p].u[0][1] = t[p].u[2][1] = v;\n        return;\n    &#125;\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (x &lt;= mid)\n        add(lt, x, v);\n    else\n        add(rt, x, v);\n    t[p].u = t[lt].u * t[rt].u;\n    return;\n&#125;\nmat ask(int p, int l, int r) &#123;\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r)\n        return t[p].u;\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (r &lt;= mid)\n        return ask(lt, l, r);\n    if (l &gt; mid)\n        return ask(rt, l, r);\n    return ask(lt, l, r) * ask(rt, l, r);\n&#125;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i];\n    bld(1, 1, n);\n    auto calc = [&amp;](int l, int r) &#123;\n        mat f(1, 3);\n        f[0][2] = 0ll;\n        auto res(f * ask(1, l, r));\n        return res[0][1];\n    &#125;;\n    int q;\n    std::cin &gt;&gt; q;\n    for (int op; q--; ) &#123;\n        std::cin &gt;&gt; op;\n        if (op == 1) &#123;\n            int l, r;\n            std::cin &gt;&gt; l &gt;&gt; r;\n            std::cout &lt;&lt; calc(l, r) &lt;&lt; &#39;\\n&#39;;\n        &#125;\n        else &#123;\n            int x, v;\n            std::cin &gt;&gt; x &gt;&gt; v;\n            a[x] = v, add(1, x, v);\n        &#125;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"åŠ¨æ€æ ‘-dp\">åŠ¨æ€æ ‘ DP</h2>\n<p>æŠŠä¸Šè¿°è¿‡ç¨‹æ”¾åˆ°æ ‘ä¸Šï¼Œå¾ˆå®¹æ˜“æƒ³åˆ°æ ‘å‰– + çº¿æ®µæ ‘ã€‚</p>\n<p>ç”±äºè®¤ä¸ºçº¿æ®µæ ‘ä¸Šçš„çŸ©ä¹˜åªèƒ½è¿›è¡Œä»é‡å„¿å­åˆ°çˆ¶äº²çš„è½¬ç§»ï¼Œè½»å„¿å­çš„è½¬ç§»ä¼šè¢«åˆå¹¶ä¸ºä¸€ä¸ªæ–°å‡½æ•°ï¼ˆåŒæ—¶æ˜¯çŸ©é˜µçš„ç³»æ•°ï¼‰ï¼Œåœ¨è·³é‡é“¾çš„æ—¶å€™è¢«å•ç‹¬æ›´æ–°ã€‚</p>\n<p>ç”±äºä¸¤ä¸ªå‡½æ•°ç›¸äº’ä¾èµ–ï¼Œéœ€è¦æ€è€ƒæ¸…æ¥šæ›´æ–°çš„å…ˆåé¡ºåºã€‚</p>\n<h3 id=\"æ¨¡æ¿åŠ¨æ€-dp\">ã€æ¨¡æ¿ã€‘åŠ¨æ€ DP</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P4719\" class=\"uri\">https://www.luogu.com.cn/problem/P4719</a></p>\n<p>ä»¤ <span class=\"math inline\">\\(f_{u,0/1}\\)</span> è¡¨ç¤ºåœ¨ <span class=\"math inline\">\\(u\\)</span> ä¸Šï¼Œé€‰ / ä¸é€‰ <span class=\"math inline\">\\(u\\)</span> çš„æœ€å¤§ä»·å€¼ã€‚å®¹æ˜“å¾—å‡ºè½¬ç§»ï¼š</p>\n<p><span class=\"math display\">\\[\nf_{u,0}=\\sum\\max(f_{v,0},f_{v,1})\\\\\nf_{u,1}=a_i+\\sum f_{v,0}\n\\]</span></p>\n<p>æŠŠè½¬ç§»çŸ©é˜µæ”¾åˆ°æ ‘å‰–ä¸Šåï¼Œè€ƒè™‘æ›´æ–°ï¼Œå‘ç°æ±‚å’Œè¿™ä¸€æ­¥å¾ˆå›°éš¾ã€‚è§£å†³æ–¹æ¡ˆæ˜¯<strong>ç›´æ¥å°†æ±‚å’Œç”¨å¦ä¸€ä¸ªå‡½æ•°ä»£æ›¿</strong>ã€‚å®šä¹‰ <span class=\"math inline\">\\(g_{u,0}\\)</span> è¡¨ç¤ºå– <span class=\"math inline\">\\(u\\)</span>ã€ä¸å– <span class=\"math inline\">\\(u\\)</span> çš„æ‰€æœ‰è½»å„¿å­çš„ç­”æ¡ˆï¼Œ<span class=\"math inline\">\\(g_{u,1}\\)</span> ä¸å– <span class=\"math inline\">\\(u\\)</span>ï¼Œè½»å„¿å­å¯é€‰å¯ä¸é€‰çš„ç­”æ¡ˆã€‚</p>\n<p><span class=\"math inline\">\\(g\\)</span> æ˜¯å¯æ±‚çš„ï¼Œä¸”åªéœ€è¦åœ¨è·³é‡é“¾çš„æ—¶å€™æ›´æ–° <span class=\"math inline\">\\(g\\)</span>ã€‚å…·ä½“æ›´æ–°èµ·æ¥éå¸¸ç»ï¼Œå› ä¸º <span class=\"math inline\">\\(g\\)</span> å’Œ <span class=\"math inline\">\\(f\\)</span> æ˜¯ç›¸äº’ä¾èµ–çš„ï¼Œéœ€è¦åˆ†æ¸…æ¥šå…ˆåå…³ç³»ã€‚</p>\n<p>é¦–å…ˆ <span class=\"math inline\">\\(g_u\\)</span> å’Œ <span class=\"math inline\">\\(f_u\\)</span> éƒ½ä¼šè¢«æ›´æ–°ï¼›æ¥ç€ï¼Œé‡é“¾ä¸Šå…¶å®ƒçš„ <span class=\"math inline\">\\(g\\)</span> ä¸ä¼šè¢«å½±å“ï¼Œè€Œé“¾é¡¶çš„ <span class=\"math inline\">\\(f\\)</span> éœ€è¦è¢«æ–°çš„ <span class=\"math inline\">\\(g_u\\)</span> æ›´æ–°ï¼›ç”±æ­¤é“¾é¡¶çˆ¶äº²çš„ <span class=\"math inline\">\\(g\\)</span> è¢«æ›´æ–°ï¼›ä¾æ¬¡ç±»æ¨ã€‚æ³¨æ„åˆ°å¯¹äºä¸€ä¸ªé“¾é¡¶ï¼Œå…¶ <span class=\"math inline\">\\(f\\)</span> å€¼æ˜¯æ•´æ¡é‡é“¾çš„ä¹˜ç§¯ï¼Œæ•…éœ€è¦è®°å½•é“¾åº•ã€‚</p>\n<p>å¤æ‚åº¦ <span class=\"math inline\">\\(O(q\\log ^2n)\\)</span>ã€‚æ³¨æ„å¾ˆé‡è¦çš„ä¸€ç‚¹æ˜¯çº¿æ®µæ ‘å†…ä¹˜æ³•åº”ä»å³å¾€å·¦ã€‚</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 1e5 + 5;\nconst int inf = 0x3f3f3f3f;\nstruct mat &#123;\n    int n, m, a[2][2];\n    mat() &#123;&#125;\n    mat(int n1, int m1): n(n1), m(m1) &#123;\n        for (int i = 0; i &lt; n; ++i)\n            for (int j = 0; j &lt; m; ++j)\n                a[i][j] = -inf;\n        return;\n    &#125;\n    int* operator[] (const int q) &#123;\n        return a[q];\n    &#125;\n    mat operator* (mat q) const &#123;\n        mat res(n, q.m);\n        for (int i = 0; i &lt; n; ++i)\n            for (int k = 0; k &lt; q.m; ++k)\n                for (int j = 0; j &lt; m; ++j)\n                    res[i][k] = std::max(res[i][k], a[i][j] + q[j][k]);\n        return res;\n    &#125;\n    mat&amp; operator*= (mat &amp;q) &#123;\n        return *this = *this * q;\n    &#125;\n&#125;;\nstruct &#123; int l, r; mat u; &#125; t[maxn &lt;&lt; 2]; \nint g[maxn][2], tab[maxn];\n#define lt (p &lt;&lt; 1)\n#define rt (lt | 1)\nvoid bld(int p, int l, int r) &#123;\n    t[p].l = l, t[p].r = r;\n    if (l == r) &#123;\n        int u = tab[l];\n        t[p].u = mat(2, 2);\n        t[p].u[0][0] = t[p].u[1][0] = g[u][1];\n        t[p].u[0][1] = g[u][0];\n        return;\n    &#125;\n    int mid = (l + r) &gt;&gt; 1;\n    bld(lt, l, mid), bld(rt, mid + 1, r);\n    t[p].u = t[rt].u * t[lt].u;\n    return;\n&#125;\nvoid add(int p, int x) &#123;\n    if (t[p].l == t[p].r) &#123;\n        int u = tab[x];\n        t[p].u[0][0] = t[p].u[1][0] = g[u][1];\n        t[p].u[0][1] = g[u][0];\n        return;\n    &#125;\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (x &lt;= mid)\n        add(lt, x);\n    else\n        add(rt, x);\n    t[p].u = t[rt].u * t[lt].u;\n    return;\n&#125;\nmat ask(int p, int l, int r) &#123;\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r)\n        return t[p].u;\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (r &lt;= mid)\n        return ask(lt, l, r);\n    if (l &gt; mid)\n        return ask(rt, l, r);\n    return ask(rt, l, r) * ask(lt, l, r);\n&#125;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, q;\n    std::cin &gt;&gt; n &gt;&gt; q;\n    std::vector&lt;int&gt; a(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i];\n    std::vector&lt;std::vector&lt;int&gt; &gt; g1(n + 1);\n    for (int i = 1, x, y; i &lt; n; ++i) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y;\n        g1[x].push_back(y), g1[y].push_back(x);\n    &#125;\n    std::vector&lt;int&gt; siz(n + 1), son(n + 1), fa(n + 1);\n    std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;\n        siz[x] = 1;\n        for (auto i : g1[x])\n            if (i != fa[x]) &#123;\n                fa[i] = x, DFS(i);\n                siz[x] += siz[i];\n                if (siz[i] &gt; siz[son[x]])\n                    son[x] = i;\n            &#125;\n        return;\n    &#125;;\n    DFS(1);\n    std::vector&lt;std::array&lt;int, 2&gt; &gt; f(n + 1);\n    std::vector&lt;int&gt; top(n + 1), bot(n + 1), dfn(n + 1);\n    DFS = [&amp;](int x) &#123;\n        static int now = 0;\n        dfn[x] = ++now, tab[now] = x;\n        if (son[x]) &#123;\n            top[son[x]] = top[x], DFS(son[x]);\n            bot[x] = bot[son[x]];\n            g[x][0] = a[x];\n            for (auto i : g1[x])\n                if (i != son[x] &amp;&amp; i != fa[x]) &#123;\n                    top[i] = i, DFS(i);\n                    g[x][0] += f[i][0];\n                    g[x][1] += std::max(f[i][1], f[i][0]);\n                &#125;\n            f[x][0] = g[x][1] + std::max(f[son[x]][0], f[son[x]][1]);\n            f[x][1] = g[x][0] + f[son[x]][0];\n        &#125;\n        else\n            f[x][1] = g[x][0] = a[x], bot[x] = x;\n        return;\n    &#125;;\n    top[1] = 1, DFS(1);\n    bld(1, 1, n);\n    for (int x, v; q--; ) &#123;\n        std::cin &gt;&gt; x &gt;&gt; v;\n        g[x][0] -= a[x], g[x][0] += v, a[x] = v;\n        for (; top[x] != 1; ) &#123;\n            auto r = ask(1, dfn[top[x]], dfn[bot[x]]);\n            f[top[x]][0] = r[0][0], f[top[x]][1] = r[0][1];\n            g[fa[top[x]]][0] -= f[top[x]][0];\n            g[fa[top[x]]][1] -= std::max(f[top[x]][0], f[top[x]][1]);\n            add(1, dfn[x]);\n            r = ask(1, dfn[top[x]], dfn[bot[x]]);\n            f[top[x]][0] = r[0][0], f[top[x]][1] = r[0][1];\n            g[fa[top[x]]][0] += f[top[x]][0];\n            g[fa[top[x]]][1] += std::max(f[top[x]][0], f[top[x]][1]);\n            x = fa[top[x]];\n        &#125;\n        add(1, dfn[x]);\n        auto r = ask(1, dfn[1], dfn[bot[1]]);\n        f[1][0] = r[0][0], f[1][1] = r[0][1];\n        std::cout &lt;&lt; std::max(f[1][0], f[1][1]) &lt;&lt; &#39;\\n&#39;;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"å…¨å±€å¹³è¡¡äºŒå‰æ ‘\">å…¨å±€å¹³è¡¡äºŒå‰æ ‘</h2>\n<p>å›é¡¾æ ‘å‰–ï¼ˆé‡å‰–ï¼‰ï¼ŒåŠŸèƒ½åœ¨äºè§£å†³è·¯å¾„é—®é¢˜ï¼Œå•æ¬¡æ“ä½œèƒ½å¤Ÿåœ¨ <span class=\"math inline\">\\(O(\\log^2 n)\\)</span> çš„æ—¶é—´å†…å®Œæˆã€‚è¿™ä¸ªåŠŸèƒ½å¯ä»¥è¢«<strong>å…¨å±€å¹³è¡¡äºŒå‰æ ‘ï¼ˆGBTï¼‰</strong>ä¸Šä½æ›¿ä»£ã€‚GBT èƒ½å¤Ÿåœ¨å•æ¬¡ <span class=\"math inline\">\\(O(\\log n)\\)</span> çš„å¤æ‚åº¦å†…å®Œæˆé“¾æ“ä½œã€å­æ ‘æ“ä½œã€‚<em><a href=\"QTREEè§£æ³•çš„ä¸€äº›ç ”ç©¶.pdf\">Yang Zhe - SPOJ375 QTREE è§£æ³•çš„ä¸€äº›ç ”ç©¶</a> ä¸­æ›´ä¸ºè¯¦ç»†ä¸¥è°¨åœ°å¯¹ GBT è¿›è¡Œäº†è¯´æ˜ï¼Œæˆ‘ä¼ äº†ä»½æ–‡ä»¶ä¸Šæ¥ã€‚</em></p>\n<p>è€ƒè™‘æ ‘å‰–èƒ½è¢«å¡çš„åŸå› ï¼šæ¯æ¬¡çº¿æ®µæ ‘è¯¢é—®éƒ½ä¼šå¡æ»¡ <span class=\"math inline\">\\(O(\\log n)\\)</span>ï¼Œæ‰¾ä¸€æ¡å¡å¾—æ»¡ <span class=\"math inline\">\\(O(\\log n)\\)</span> æ¬¡è·³é‡é“¾æ¬¡æ•°çš„è·¯å¾„ä¸€ç›´è–…ï¼Œå°±å¯ä»¥å¡åˆ° <span class=\"math inline\">\\(O(\\log^2 n)\\)</span>ã€‚</p>\n<p>åœ¨å®ç°çº¿æ®µæ ‘æ—¶å‘ç°ï¼Œå¯¹äº<strong>è·¯å¾„æ“ä½œ</strong>å’Œ<strong>å•ç‚¹æ“ä½œ</strong>ï¼Œæ ‘å‰–åªéœ€è¦ç»´æŠ¤åŒä¸€æ¡é‡é“¾çš„ä¿¡æ¯ï¼Œå»ºä¸€ä¸ªå¤§çº¿æ®µæ ‘ä¼šäº§ç”Ÿè®¸å¤šé‡é“¾é—´çš„æ— æ•ˆç»´æŠ¤ã€‚æ•…ä¸€ç§ç»å…¸çš„æ ‘å‰–å¡å¸¸æŠ€å·§æ˜¯å¯¹äºæ¯ä¸€æ¡é‡é“¾å»ºå‡ºçº¿æ®µæ ‘ã€‚</p>\n<p>åœ¨æœ¬æ–‡ä¸­å®šä¹‰<strong>å…¨å±€äºŒå‰æ ‘</strong>ï¼šå°†å•ä¸ªçº¿æ®µæ ‘æŒ‰ç…§åœ¨åŸæ ‘ä¸Šé‡é“¾é¡¶çš„ç›¸å¯¹ç¥–å­™å…³ç³»è¿è¾¹å¾—åˆ°çš„æ¨¡å‹ã€‚è¿™é‡Œä¸ºäº†å’Œ<strong>å…¨å±€å¹³è¡¡äºŒå‰æ ‘</strong>å½¢æˆç…§åº”è€Œå‘½åï¼Œå®é™…ä¸Šæ¨¡å‹å¹¶ä¸æ˜¯äºŒå‰æ ‘ã€‚å®¹æ˜“å‘ç°<strong>ä¿®æ”¹æŸä¸ªç‚¹èŠ±è´¹çš„æ“ä½œæ¬¡æ•°å’Œå…¶åœ¨å…¨å±€äºŒå‰æ ‘ä¸­çš„æ·±åº¦ç›¸åŒ</strong>ã€‚</p>\n<p>è€ƒè™‘æœ¬æ–¹æ³•ç†è®ºä¸Šä»å¯å¡åˆ° <span class=\"math inline\">\\(O(\\log^2 n)\\)</span> å•æ¬¡æ“ä½œçš„åŸå› ï¼Œè™½ç„¶å•ä¸ªçº¿æ®µæ ‘å¹³è¡¡ï¼Œä½†<strong>å…¨å±€äºŒå‰æ ‘</strong>å¹¶ä¸å¹³è¡¡ï¼›èƒ½å¤Ÿæ„é€ æ•°æ®ä½¿å¾—æ ‘é«˜è¾¾åˆ° <span class=\"math inline\">\\(\\log^2 n\\)</span>ã€‚è€ƒè™‘ä½¿å¾—å…¨å±€äºŒå‰æ ‘å¹³è¡¡ï¼Œå³è°ƒæ•´çº¿æ®µæ ‘ç»“æ„ä½¿å¾—ä»»ä½•ä¸€ä¸ªç‚¹åœ¨å…¨å±€äºŒå‰æ ‘ä¸Šçš„å·¦å³å„¿å­å¤§å°æœ€æ¥è¿‘ã€‚å‘ç°æ˜¯æ˜“åšçš„ï¼Œåªéœ€åœ¨å»ºçº¿æ®µæ ‘æ—¶ç§»åŠ¨å·¦å³å„¿å­åˆ†å‰²ç‚¹ä½¿å¾—ä¸¤è¾¹å­æ ‘å¤§å°å‡ä¸ºå…¨æ ‘çš„ä¸€åŠå³å¯ã€‚</p>\n<p>æ³•ä¸€ï¼šæ±‚å‡ºæ¯ä¸ªç‚¹çš„è½»å­æ ‘å¤§å° <span class=\"math inline\">\\(ls_u=1+\\sum siz_v\\)</span>ï¼Œä½œä¸ºåŠ æƒåœ¨çº¿æ®µæ ‘ä¸Šæ‰¾ mid å°±èƒ½æ»¡è¶³å…¨å±€å¹³è¡¡ï¼›è¯æ˜å¯ä»¥è§ä¸Šé¢çš„è®ºæ–‡ã€‚è¿™é‡Œç”¨çº¿æ®µæ ‘ä»£æ›¿äº† BSTï¼Œå¸¸æ•°å¾ˆå¤§ã€‚</p>\n<p>æ³•äºŒï¼šç”¨ä¸€ä¸ª BST å®ç°ä¸Šè¿°åŠŸèƒ½ï¼Œéœ€è¦æ»¡è¶³ï¼šä»»æ„å­æ ‘çš„æ ¹ä¸ºå­æ ‘çš„å¸¦æƒ midï¼›BST çš„ä¸­åºéå†ä¸ºåŸé‡é“¾ã€‚æ˜¾ç„¶æœ‰ï¼šæ ‘é«˜ä¸º log çº§åˆ«ã€‚è¿™å°±å†³å®šäº†æ‰€æœ‰é—®é¢˜éƒ½å¯ä»¥é€šè¿‡æš´åŠ›çˆ¬å±±è§£å†³ã€‚</p>\n<p>GBT èƒ½å¤Ÿå¿«é€Ÿç»´æŠ¤<strong>æ™®é€šæ ‘å‰–æ“ä½œ</strong>å’Œ <strong>DDP ä¿¡æ¯</strong>ã€‚</p>\n<hr />\n<h3 id=\"ç»´æŠ¤-ddpæ¨¡æ¿åŠ¨æ€-dpåŠ å¼ºç‰ˆ\">ç»´æŠ¤ DDPï¼šã€æ¨¡æ¿ã€‘åŠ¨æ€ DPï¼ˆåŠ å¼ºç‰ˆï¼‰</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P4751\" class=\"uri\">https://www.luogu.com.cn/problem/P4751</a></p>\n<p>å’ŒæœªåŠ å¼ºç‰ˆç±»ä¼¼ï¼ŒæŠŠæ‰€æœ‰çº¿æ®µæ ‘æ“ä½œæ›¿æ¢ä¸º BST å³å¯ã€‚å¦‚æœå†™å¾—ä¸‘å¯èƒ½éœ€è¦ä¸€äº›é¢å¤–çš„å¡å¸¸æŠ€å·§ã€‚</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 1e6 + 5;\nconst int inf = 0x3f3f3f3f;\nconst int LEN = (1 &lt;&lt; 20);\nint nec(void) &#123;\n    static char buf[LEN], *p = buf, *e = buf;\n    if (p == e) &#123;\n        e = buf + fread(buf, 1, LEN, stdin);\n        if (e == buf) return EOF;\n        p = buf;\n    &#125;\n    return *p++;\n&#125;\nbool read(int &amp;x) &#123;\n    x = 0;\n    bool f = 0;\n    char ch = nec();\n    while (ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123;\n        if (ch == EOF) return 0;\n        if (ch == &#39;-&#39;) f = 1;\n        ch = nec();\n    &#125;\n    while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) &#123;\n        x = x * 10 + ch - &#39;0&#39;;\n        ch = nec();\n    &#125;\n    if (f) x = -x;\n    return 1;\n&#125;\nvoid print(int x) &#123;\n    if (x &lt; 0)\n        putchar(&#39;-&#39;), x = -x;\n    if (x &gt;= 10) print(x / 10);\n    putchar(x % 10 + &#39;0&#39;);\n    return;\n&#125;\nvoid print(int x, char ch) &#123;\n    print(x), putchar(ch);\n    return;\n&#125;\nstruct mat &#123;\n    int a[2][2];\n    int* operator[] (const int q) &#123; \n        return a[q];\n    &#125;\n    mat operator* (mat &amp;q) const &#123;\n        mat res;\n        res[0][0] = res[0][1] = res[1][0] = res[1][1] = -inf;\n        for (int i = 0; i &lt; 2; ++i)\n            for (int k = 0; k &lt; 2; ++k)\n                for (int j = 0; j &lt; 2; ++j)\n                    res[i][k] = std::max(res[i][k], a[i][j] + q[j][k]);\n        return res;\n    &#125;\n    mat&amp; operator*= (mat &amp;q) &#123;\n        return *this = *this * q;\n    &#125;\n&#125;;\nstruct &#123; int lc, rc, fa; mat u; &#125; t[maxn]; \nint g[maxn][2], tab[maxn], ls[maxn];\nmat p[maxn];\nvoid pushup(int x) &#123;\n    t[x].u = t[t[x].rc].u * p[x] * t[t[x].lc].u;\n    return;\n&#125;\nvoid bld(int &amp;x, int l, int r) &#123;\n    if (l &gt; r)\n        return;\n    int s = 0, k = 0;\n    for (int i = l; i &lt;= r; ++i)\n        s += ls[tab[i]];\n    for (int i = l; i &lt;= r; ++i, k += ls[tab[i]])\n        if ((k + ls[tab[i]]) * 2 &gt; s) &#123;\n            x = tab[i];\n            bld(t[x].lc, l, i - 1), t[t[x].lc].fa = x;\n            bld(t[x].rc, i + 1, r), t[t[x].rc].fa = x;\n            pushup(x);\n            break;\n        &#125;\n    return;\n&#125;\n#undef lt\n#undef rt\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    t[0].u[0][0] = t[0].u[1][1] = 0, t[0].u[0][1] = t[0].u[1][0] = -inf;\n    int n, q;\n    read(n), read(q);\n    std::vector&lt;int&gt; a(n + 1), rt(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        read(a[i]);\n    std::vector&lt;std::vector&lt;int&gt; &gt; g1(n + 1);\n    for (int i = 1, x, y; i &lt; n; ++i) &#123;\n        read(x), read(y);\n        g1[x].push_back(y), g1[y].push_back(x);\n    &#125;\n    std::vector&lt;int&gt; son(n + 1), fa(n + 1), siz(n + 1);\n    std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;\n        siz[x] = 1;\n        for (auto i : g1[x])\n            if (i != fa[x]) &#123;\n                fa[i] = x, DFS(i);\n                siz[x] += siz[i];\n                if (siz[i] &gt; siz[son[x]])\n                    son[x] = i;\n            &#125;\n        return;\n    &#125;;\n    DFS(1);\n    std::vector&lt;std::array&lt;int, 2&gt; &gt; f(n + 1);\n    std::vector&lt;int&gt; top(n + 1), bot(n + 1), dfn(n + 1);\n    DFS = [&amp;](int x) &#123;\n        static int now = 0;\n        dfn[x] = ++now, tab[now] = x, ls[x] = 1;\n        if (son[x]) &#123;\n            top[son[x]] = top[x], DFS(son[x]);\n            bot[x] = bot[son[x]];\n            g[x][0] = a[x];\n            for (auto i : g1[x])\n                if (i != son[x] &amp;&amp; i != fa[x]) &#123;\n                    top[i] = i, DFS(i), t[rt[i]].fa = x;\n                    ls[x] += siz[i];\n                    g[x][0] += f[i][0];\n                    g[x][1] += std::max(f[i][1], f[i][0]);\n                &#125;\n            f[x][0] = g[x][1] + std::max(f[son[x]][0], f[son[x]][1]);\n            f[x][1] = g[x][0] + f[son[x]][0];\n        &#125;\n        else\n            f[x][1] = g[x][0] = a[x], bot[x] = x;\n        p[x][0][0] = p[x][1][0] = g[x][1];\n        p[x][0][1] = g[x][0], p[x][1][1] = -inf;\n        if (x == top[x])\n            bld(rt[x], dfn[x], dfn[bot[x]]);\n        return;\n    &#125;;\n    top[1] = 1, DFS(1);\n    for (int x, v, la = 0; q--; ) &#123;\n        read(x), read(v), x ^= la;\n        p[x][0][1] += v - a[x], a[x] = v;\n        for (; x; ) &#123;\n            int fa = t[x].fa;\n            if (fa &amp;&amp; x != t[fa].lc &amp;&amp; x != t[fa].rc) &#123;\n                int f0 = t[x].u[0][0], f1 = std::max(f0, t[x].u[0][1]);\n                pushup(x);\n                int F0 = t[x].u[0][0], F1 = std::max(F0, t[x].u[0][1]);\n                p[fa][0][0] += F1 - f1, p[fa][1][0] += F1 - f1;\n                p[fa][0][1] += F0 - f0;\n            &#125;\n            else\n                pushup(x);\n            x = fa;\n        &#125;\n        print(la = std::max(t[rt[1]].u[0][0], t[rt[1]].u[0][1]), &#39;\\n&#39;);\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<p>ä¹Ÿç»™å‡ºä¸€ä¸ªçº¿æ®µæ ‘ç‰ˆæœ¬çš„</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 1e6 + 5;\nconst int inf = 0x3f3f3f3f;\nconst int LEN = (1 &lt;&lt; 20);\nint nec(void) &#123;\n    static char buf[LEN], *p = buf, *e = buf;\n    if (p == e) &#123;\n        e = buf + fread(buf, 1, LEN, stdin);\n        if (e == buf) return EOF;\n        p = buf;\n    &#125;\n    return *p++;\n&#125;\nbool read(int &amp;x) &#123;\n    x = 0;\n    bool f = 0;\n    char ch = nec();\n    while (ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123;\n        if (ch == EOF) return 0;\n        if (ch == &#39;-&#39;) f = 1;\n        ch = nec();\n    &#125;\n    while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) &#123;\n        x = x * 10 + ch - &#39;0&#39;;\n        ch = nec();\n    &#125;\n    if (f) x = -x;\n    return 1;\n&#125;\nvoid print(int x) &#123;\n    if (x &lt; 0)\n        putchar(&#39;-&#39;), x = -x;\n    if (x &gt;= 10) print(x / 10);\n    putchar(x % 10 + &#39;0&#39;);\n    return;\n&#125;\nvoid print(int x, char ch) &#123;\n    print(x), putchar(ch);\n    return;\n&#125;\nstruct mat &#123;\n    int a[2][2];\n    int* operator[] (const int q) &#123;\n        return a[q];\n    &#125;\n    mat operator* (mat q) const &#123;\n        mat res;\n        res[0][0] = res[0][1] = res[1][0] = res[1][1] = -inf;\n        for (int i = 0; i &lt; 2; ++i)\n            for (int k = 0; k &lt; 2; ++k)\n                for (int j = 0; j &lt; 2; ++j)\n                    res[i][k] = std::max(res[i][k], a[i][j] + q[j][k]);\n        return res;\n    &#125;\n    mat&amp; operator*= (mat &amp;q) &#123;\n        return *this = *this * q;\n    &#125;\n&#125;;\nstruct &#123; int lc, rc, l, r, mid; mat u; &#125; t[maxn &lt;&lt; 2]; \nint g[maxn][2], tab[maxn], ls[maxn];\n#define lt t[p].lc\n#define rt t[p].rc\nvoid bld(int &amp;p, int l, int r) &#123;\n    static int tot = 0;\n    p = ++tot, t[p].l = l, t[p].r = r;\n    if (l == r) &#123;\n        int u = tab[l];\n        t[p].u[0][0] = t[p].u[1][0] = g[u][1];\n        t[p].u[0][1] = g[u][0], t[p].u[1][1] = -inf;\n        return;\n    &#125;\n    int s = 0, u = ls[tab[l]];\n    for (int i = l; i &lt;= r; ++i)\n        s += ls[tab[i]];\n    s &gt;&gt;= 1;\n    t[p].mid = r - 1;\n    for (int i = l + 1; i &lt; r; ++i) &#123;\n        u += ls[tab[i]];\n        if (u + ls[tab[i + 1]] &gt; s) &#123;\n            t[p].mid = i;\n            break;\n        &#125;\n    &#125;\n    bld(lt, l, t[p].mid), bld(rt, t[p].mid + 1, r);\n    t[p].u = t[rt].u * t[lt].u;\n    return;\n&#125;\nvoid add(int p, int x) &#123;\n    if (t[p].l == t[p].r) &#123;\n        int u = tab[x];\n        t[p].u[0][0] = t[p].u[1][0] = g[u][1];\n        t[p].u[0][1] = g[u][0];\n        return;\n    &#125;\n    if (x &lt;= t[p].mid)\n        add(lt, x);\n    else\n        add(rt, x);\n    t[p].u = t[rt].u * t[lt].u;\n    return;\n&#125;\nmat ask(int p, int l, int r) &#123;\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r)\n        return t[p].u;\n    if (r &lt;= t[p].mid)\n        return ask(lt, l, r);\n    if (l &gt; t[p].mid)\n        return ask(rt, l, r);\n    return ask(rt, l, r) * ask(lt, l, r);\n&#125;\n#undef lt\n#undef rt\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, q;\n    read(n), read(q);\n    std::vector&lt;int&gt; a(n + 1), rt(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        read(a[i]);\n    std::vector&lt;std::vector&lt;int&gt; &gt; g1(n + 1);\n    for (int i = 1, x, y; i &lt; n; ++i) &#123;\n        read(x), read(y);\n        g1[x].push_back(y), g1[y].push_back(x);\n    &#125;\n    std::vector&lt;int&gt; siz(n + 1), son(n + 1), fa(n + 1);\n    std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;\n        siz[x] = 1;\n        for (auto i : g1[x])\n            if (i != fa[x]) &#123;\n                fa[i] = x, DFS(i);\n                siz[x] += siz[i];\n                if (siz[i] &gt; siz[son[x]])\n                    son[x] = i;\n            &#125;\n        return;\n    &#125;;\n    DFS(1);\n    std::vector&lt;std::array&lt;int, 2&gt; &gt; f(n + 1);\n    std::vector&lt;int&gt; top(n + 1), bot(n + 1), dfn(n + 1);\n    DFS = [&amp;](int x) &#123;\n        static int now = 0;\n        dfn[x] = ++now, tab[now] = x;\n        ls[x] = 1;\n        if (son[x]) &#123;\n            top[son[x]] = top[x], DFS(son[x]);\n            bot[x] = bot[son[x]];\n            g[x][0] = a[x];\n            for (auto i : g1[x])\n                if (i != son[x] &amp;&amp; i != fa[x]) &#123;\n                    top[i] = i, DFS(i);\n                    ls[x] += siz[i];\n                    g[x][0] += f[i][0];\n                    g[x][1] += std::max(f[i][1], f[i][0]);\n                &#125;\n            f[x][0] = g[x][1] + std::max(f[son[x]][0], f[son[x]][1]);\n            f[x][1] = g[x][0] + f[son[x]][0];\n        &#125;\n        else\n            f[x][1] = g[x][0] = a[x], bot[x] = x;\n        if (x == top[x])\n            bld(rt[x], dfn[x], dfn[bot[x]]);\n        return;\n    &#125;;\n    top[1] = 1, DFS(1);\n    for (int x, v, la = 0; q--; ) &#123;\n        read(x), read(v), x ^= la;\n        g[x][0] -= a[x], g[x][0] += v, a[x] = v;\n        for (; top[x] != 1; ) &#123;\n            auto r = t[rt[top[x]]].u;\n            f[top[x]][0] = r[0][0], f[top[x]][1] = r[0][1];\n            g[fa[top[x]]][0] -= f[top[x]][0];\n            g[fa[top[x]]][1] -= std::max(f[top[x]][0], f[top[x]][1]);\n            add(rt[top[x]], dfn[x]);\n            r = t[rt[top[x]]].u;\n            f[top[x]][0] = r[0][0], f[top[x]][1] = r[0][1];\n            g[fa[top[x]]][0] += f[top[x]][0];\n            g[fa[top[x]]][1] += std::max(f[top[x]][0], f[top[x]][1]);\n            x = fa[top[x]];\n        &#125;\n        add(rt[1], dfn[x]);\n        auto r =  t[rt[1]].u;\n        f[1][0] = r[0][0], f[1][1] = r[0][1];\n        std::cout &lt;&lt; (la = std::max(f[1][0], f[1][1])) &lt;&lt; &#39;\\n&#39;;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"æ ‘ä¸Šè·¯å¾„é—®é¢˜æŸ“è‰²\">æ ‘ä¸Šè·¯å¾„é—®é¢˜ï¼šæŸ“è‰²</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P2486\" class=\"uri\">https://www.luogu.com.cn/problem/P2486</a></p>\n<p>GBT ä¸Šçš„<strong>è·¯å¾„é—®é¢˜</strong>ã€‚</p>\n<p>BSTï¼šé¦–å…ˆæš´åŠ›çˆ¬å±±åˆ° LCAï¼Œç»Ÿè®¡ä¸€è·¯ä¸Šçš„ç­”æ¡ˆï¼›ç„¶åè·³åˆ°å½“å‰ BST çš„æ ¹ã€‚ç”±äºæœ¬é¢˜æœ‰æ ‡è®°ï¼Œæ‰€ä»¥éœ€è¦åœ¨è·³çš„åŒæ—¶æƒ³åŠæ³•æŠŠæ ‡è®°é—®é¢˜è§£å†³ä¸€ä¸‹ã€‚</p>\n<p>çº¿æ®µæ ‘ï¼šæŠŠæ ‘å‰–çš„çº¿æ®µæ ‘ç•¥æ”¹ä¸€ä¸‹å°±è¿‡äº†ã€‚ä»ä¸Šä¸€è¡Œæ¨¡æ£±ä¸¤å¯çš„æè¿°å°±å¯ä»¥çœ‹å‡ºæ¥ BST å®ç°èµ·æ¥ä¸å¤ªè½»æ¾ï¼›è¿˜æ˜¯çº¿æ®µæ ‘æ›´è½®æ¤…å•Šï¼</p>\n<details>\n<p>è·‘å¾—æ²¡çº¯æ ‘å‰–å¿«ï¼Œå› ä¸ºæ•°æ®æ²¡æœ‰åˆ»æ„æ„é€ å¯¼è‡´æ ‘é«˜å¾ˆä½ï¼Œå†åŠ ä¸Šå¸¸æ•°çš„å½±å“å§ã€‚</p>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 1e5 + 5;\nconst int LEN = (1 &lt;&lt; 20);\nint nec(void) &#123;\n    static char buf[LEN], *p = buf, *e = buf;\n    if (p == e) &#123;\n        e = buf + fread(buf, 1, LEN, stdin);\n        if (e == buf) return EOF;\n        p = buf;\n    &#125;\n    return *p++;\n&#125;\nbool read(int &amp;x) &#123;\n    x = 0;\n    bool f = 0;\n    char ch = nec();\n    while (ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123;\n        if (ch == EOF) return 0;\n        if (ch == &#39;-&#39;) f = 1;\n        ch = nec();\n    &#125;\n    while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) &#123;\n        x = x * 10 + ch - &#39;0&#39;;\n        ch = nec();\n    &#125;\n    if (f) x = -x;\n    return 1;\n&#125;\nvoid read(char &amp;x) &#123;\n    for (x = nec(); x != &#39;C&#39; &amp;&amp; x != &#39;Q&#39;; x = nec());\n    return;\n&#125;\nvoid print(int x) &#123;\n    if (x &lt; 0)\n        putchar(&#39;-&#39;), x = -x;\n    if (x &gt;= 10) print(x / 10);\n    putchar(x % 10 + &#39;0&#39;);\n    return;\n&#125;\nvoid print(int x, char ch) &#123;\n    print(x), putchar(ch);\n    return;\n&#125;\nclass node &#123;\nprivate:\n    int lt, rt;\npublic:\n    int l, r, mid, lc, rc, u, d;\n    node(): u(-1) &#123;&#125;\n    inline int&amp; ls(void) &#123; return lt; &#125;\n    inline int&amp; rs(void) &#123; return rt; &#125;\n    node&amp; operator= (const node &amp;q) &#123;\n        lc = q.lc, rc = q.rc, u = q.u;\n        return *this;\n    &#125;\n    node operator+ (const node &amp;q) const &#123;\n        if (u == -1)\n            return q;\n        if (q.u == -1)\n            return *this;\n        node res;\n        res.lc = lc, res.rc = q.rc, res.u = u + q.u - (rc == q.lc);\n        return res;\n    &#125;\n    inline void swap(void) &#123;\n        if (~u)\n            lc ^= rc ^= lc ^= rc;\n        return;\n    &#125;\n&#125; t[maxn &lt;&lt; 2]; \nint tab[maxn], ls[maxn], a[maxn];\n#define lt t[p].ls()\n#define rt t[p].rs()\nvoid bld(int &amp;p, int l, int r) &#123;\n    static int tot = 0;\n    p = ++tot, t[p].l = l, t[p].r = r;\n    if (l == r) &#123;\n        t[p].u = 1;\n        t[p].lc = t[p].rc = a[tab[l]];\n        return;\n    &#125;\n    int s = 0, u = ls[tab[l]];\n    for (int i = l; i &lt;= r; ++i)\n        s += ls[tab[i]];\n    s &gt;&gt;= 1;\n    t[p].mid = r - 1;\n    for (int i = l + 1; i &lt; r; ++i) &#123;\n        u += ls[tab[i]];\n        if (u + ls[tab[i + 1]] &gt; s) &#123;\n            t[p].mid = i;\n            break;\n        &#125;\n    &#125;\n    bld(lt, l, t[p].mid), bld(rt, t[p].mid + 1, r);\n    t[p] = t[lt] + t[rt];\n    return;\n&#125;\nvoid pushdown(int p) &#123;\n    if (t[p].d) &#123;\n        t[lt].d = t[lt].lc = t[lt].rc = t[rt].d = t[rt].lc = t[rt].rc = t[p].d;\n        t[lt].u = t[rt].u = 1;\n        t[p].d = 0;\n    &#125;\n    return;\n&#125;\nvoid add(int p, int l, int r, int v) &#123;\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r) &#123;\n        t[p].u = 1;\n        t[p].lc = t[p].rc = t[p].d = v;\n        return;\n    &#125;\n    pushdown(p);\n    if (l &lt;= t[p].mid)\n        add(lt, l, r, v);\n    if (r &gt; t[p].mid)\n        add(rt, l, r, v);\n    t[p] = t[lt] + t[rt];\n    return;\n&#125;\nnode ask(int p, int l, int r) &#123;\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r)\n        return t[p];\n    pushdown(p);\n    if (r &lt;= t[p].mid)\n        return ask(lt, l, r);\n    if (l &gt; t[p].mid)\n        return ask(rt, l, r);\n    return ask(lt, l, r) + ask(rt, l, r);\n&#125;\n#undef lt\n#undef rt\nint main() &#123;\n#ifdef ONLINE_JUDGE\n#else\n    std::freopen(&quot;paint17.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, q;\n    read(n), read(q);\n    std::vector&lt;int&gt; rt(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        read(a[i]);\n    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);\n    for (int i = 1, x, y; i &lt; n; ++i) &#123;\n        read(x), read(y);\n        g[x].push_back(y), g[y].push_back(x);\n    &#125;\n    std::vector&lt;int&gt; siz(n + 1), son(n + 1), fa(n + 1), dep(n + 1);\n    std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;\n        siz[x] = 1;\n        for (auto i : g[x])\n            if (i != fa[x]) &#123;\n                dep[i] = dep[x] + 1;\n                fa[i] = x, DFS(i);\n                siz[x] += siz[i];\n                if (siz[i] &gt; siz[son[x]])\n                    son[x] = i;\n            &#125;\n        return;\n    &#125;;\n    DFS(1);\n    std::vector&lt;std::array&lt;int, 2&gt; &gt; f(n + 1);\n    std::vector&lt;int&gt; top(n + 1), bot(n + 1), dfn(n + 1);\n    DFS = [&amp;](int x) &#123;\n        static int now = 0;\n        dfn[x] = ++now, tab[now] = x, ls[x] = 1;\n        if (son[x]) &#123;\n            top[son[x]] = top[x], DFS(son[x]);\n            bot[x] = bot[son[x]];\n        &#125;\n        else\n            bot[x] = x;\n        for (auto i : g[x])\n            if (i != son[x] &amp;&amp; i != fa[x]) &#123;\n                top[i] = i;\n                DFS(i);\n                ls[x] += siz[i];\n            &#125;\n        if (x == top[x])\n            bld(rt[x], dfn[x], dfn[bot[x]]);\n        return;\n    &#125;;\n    top[1] = 1, DFS(1);\n    for (char op; q--; ) &#123;\n        read(op);\n        if (op == &#39;C&#39;) &#123;\n            int x, y, c;\n            read(x), read(y), read(c);\n            for (; top[x] != top[y]; x = fa[top[x]]) &#123;\n                if (dep[top[x]] &lt; dep[top[y]])\n                    std::swap(x, y);\n                add(rt[top[x]], dfn[top[x]], dfn[x], c);\n            &#125;\n            if (dep[x] &gt; dep[y])\n                std::swap(x, y);\n            add(rt[top[x]], dfn[x], dfn[y], c);\n        &#125;\n        else &#123;\n            int x, y;\n            read(x), read(y);\n            node res1, res2;\n            for (; top[x] != top[y]; )\n                if (dep[top[x]] &lt; dep[top[y]]) &#123;\n                    res2 = ask(rt[top[y]], dfn[top[y]], dfn[y]) + res2;\n                    y = fa[top[y]];\n                &#125;\n                else &#123;\n                    res1 = ask(rt[top[x]], dfn[top[x]], dfn[x]) + res1;\n                    x = fa[top[x]];\n                &#125;\n            if (dep[x] &gt; dep[y])\n                res1 = ask(rt[top[y]], dfn[y], dfn[x]) + res1;\n            else\n                res2 = ask(rt[top[x]], dfn[x], dfn[y]) + res2;\n            res1.swap();\n            print((res1 + res2).u, &#39;\\n&#39;);\n        &#125;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"æ ‘ä¸Šè·¯å¾„æŸ¥è¯¢\">æ ‘ä¸Šè·¯å¾„æŸ¥è¯¢ï¼Ÿ</h3>\n<p>åšé¢˜çš„æ—¶å€™å¯ä»¥æ„Ÿå—åˆ°ï¼Œè·¯å¾„è¯¢é—®çš„å­˜åœ¨å¾ˆè¯¡å¼‚ï¼Œå› ä¸ºåªéœ€è¦ä¸€æ¡é“¾çš„æ“ä½œï¼Œæ›´åå‘é“¾ä¸Š DDP è€Œéæ ‘ä¸Šçš„ï¼›<strong>è½»å„¿å­çš„ä¿¡æ¯æ˜¯ä¸ç”¨ç»´æŠ¤çš„</strong>ï¼Œå½¢å¼ä¸Šæ›´åƒæ ‘å‰–ï¼ˆDSï¼‰ï¼›å½“æˆé“¾ä¸Šçš„ DDP å°±å¯ä»¥è§£å†³äº†ã€‚</p>\n<p>å¯ä»¥ç”¨å€å¢ç»´æŠ¤ DDPï¼ˆä¸ç”¨è€ƒè™‘è½»é‡å„¿å­ï¼Œåªç”¨ç»´æŠ¤çˆ¶å­å…³ç³»ï¼Œè¿›ä¸€æ­¥å‘åºåˆ— DDP é è¿‘ï¼‰ï¼Œå°±ä¸ç”¨æ‰“ GBT äº†ï¼Œå¸¸æ•°ä¹Ÿä¼šå°ä¸€äº›ã€‚</p>\n<hr />\n<h2 id=\"ä¹ é¢˜\">ä¹ é¢˜</h2>\n<p>GBT å°±ç»Ÿä¸€ç”¨çº¿æ®µæ ‘äº†ã€‚DDP ä¹Ÿå°±å¯ä»¥é¡ºå¸¦ç”¨ GBT ä¼˜åŒ–äº†ã€‚</p>\n<hr />\n<h3 id=\"e---çŒ«æˆ–ç‹—-cats-or-dogs\">E - çŒ«æˆ–ç‹— / Cats or Dogs</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P9597\" class=\"uri\">https://www.luogu.com.cn/problem/P9597</a></p>\n<p>è®¾ <span class=\"math inline\">\\(f_{u,0/1}\\)</span> è¡¨ç¤ºä»æ ¹ä¸Šé¢œè‰²ä¸º <span class=\"math inline\">\\(0/1\\)</span> æ—¶çš„æœ€å°æ–­è¾¹æ•°ï¼Œæ˜¾ç„¶æ— è‰²å¯ä»¥è§†ä½œä»»é€‰ä¸€ä¸ªé¢œè‰²ã€‚é‚£ä¹ˆæœ‰ï¼š</p>\n<p><span class=\"math display\">\\[\nf_{u,a}=\\sum\\limits_v\\min\\limits_{b\\in\\{0,1\\}}\\{f_{v,b}+[a\\ne b]\\}\n\\]</span></p>\n<p>ç›´æ¥æŠŠè½»å„¿å­çš„é¡¹æå‡ºæ¥ï¼Œè®° <span class=\"math inline\">\\(g_{u,0/1}\\)</span> è¡¨ç¤º <span class=\"math inline\">\\(f_{u,0/1}\\)</span> å¯¹åº”çš„è½»å„¿å­è´¡çŒ®å³å¯ã€‚</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 1e5 + 5;\nconst int inf = 0x3f3f3f3f;\nstruct mat &#123;\n    int a[2][2];\n    int* operator[] (const int q) &#123; \n        return a[q];\n    &#125;\n    mat operator* (mat &amp;q) const &#123;\n        mat res;\n        res[0][0] = res[0][1] = res[1][0] = res[1][1] = inf;\n        for (int i = 0; i &lt; 2; ++i)\n            for (int k = 0; k &lt; 2; ++k)\n                for (int j = 0; j &lt; 2; ++j)\n                    res[i][k] = std::min(res[i][k], a[i][j] + q[j][k]);\n        return res;\n    &#125;\n    mat&amp; operator*= (mat &amp;q) &#123;\n        return *this = *this * q;\n    &#125;\n&#125; p[maxn];\nstruct &#123; int lc, rc, l, r, mid; mat u; &#125; t[maxn &lt;&lt; 2]; \nint ls[maxn], tab[maxn], g[maxn][2], rt[maxn], top[maxn], dfn[maxn], fa[maxn];\nstd::vector&lt;int&gt; a;\n#define lt t[p].lc\n#define rt t[p].rc\nvoid bld(int &amp;p, int l, int r) &#123;\n    static int tot = 0;\n    p = ++tot, t[p].l = l, t[p].r = r;\n    if (l == r) &#123;\n        t[p].u[0][1] = t[p].u[1][0] = 1;\n        return;\n    &#125;\n    int s = 0, u = ls[tab[l]];\n    for (int i = l; i &lt;= r; ++i)\n        s += ls[tab[i]];\n    s &gt;&gt;= 1;\n    t[p].mid = r - 1;\n    for (int i = l + 1; i &lt; r; ++i) &#123;\n        u += ls[tab[i]];\n        if (u + ls[tab[i + 1]] &gt; s) &#123;\n            t[p].mid = i;\n            break;\n        &#125;\n    &#125;\n    bld(lt, l, t[p].mid), bld(rt, t[p].mid + 1, r);\n    t[p].u = t[rt].u * t[lt].u;\n    return;\n&#125;\nvoid add(int p, int x) &#123;\n    if (t[p].l == t[p].r) &#123;\n        int u = tab[x], g0 = (a[u] == 1 ? inf : g[u][0]), g1 = (a[u] == 0 ? inf : g[u][1]);\n        t[p].u[0][0] = g0, t[p].u[0][1] = g1 + 1;\n        t[p].u[1][0] = g0 + 1, t[p].u[1][1] = g1;\n        return;\n    &#125;\n    if (x &lt;= t[p].mid)\n        add(lt, x);\n    else\n        add(rt, x);\n    t[p].u = t[rt].u * t[lt].u;\n    return;\n&#125;\n#undef lt\n#undef rt\nvoid initialize(int n, std::vector&lt;int&gt; A, std::vector&lt;int&gt; B) &#123;\n    a.assign(n + 1, -1);\n    std::vector&lt;std::vector&lt;int&gt; &gt; g1(n + 1);\n    for (int i = 0; i &lt; n - 1; ++i)\n        g1[A[i]].push_back(B[i]), g1[B[i]].push_back(A[i]);\n    std::vector&lt;int&gt; siz(n + 1), son(n + 1);\n    std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;\n        siz[x] = 1;\n        for (auto i : g1[x])\n            if (i != fa[x]) &#123;\n                fa[i] = x, DFS(i);\n                siz[x] += siz[i];\n                if (siz[i] &gt; siz[son[x]])\n                    son[x] = i;\n            &#125;\n        return;\n    &#125;;\n    DFS(1);\n    std::vector&lt;int&gt; bot(n + 1);\n    DFS = [&amp;](int x) &#123;\n        static int now = 0;\n        dfn[x] = ++now, tab[now] = x, ls[x] = 1;\n        if (son[x]) &#123;\n            top[son[x]] = top[x], DFS(son[x]);\n            bot[x] = bot[son[x]];\n            for (auto i : g1[x])\n                if (i != son[x] &amp;&amp; i != fa[x]) &#123;\n                    top[i] = i, DFS(i);\n                    ls[x] += siz[i];\n                &#125;\n        &#125;\n        else\n            bot[x] = x;\n        if (x == top[x])\n            bld(rt[x], dfn[x], dfn[bot[x]]);\n        return;\n    &#125;;\n    top[1] = 1, DFS(1);\n    return;\n&#125;\nint upd(int x) &#123;\n    for (; top[x] != 1; ) &#123;\n        int faa = fa[top[x]];\n        auto &amp;id = t[rt[top[x]]].u;\n        int f0 = std::min(id[0][0], id[1][0]), f1 = std::min(id[0][1], id[1][1]);\n        g[faa][0] -= std::min(f0, f1 + 1);\n        g[faa][1] -= std::min(f0 + 1, f1);\n        add(rt[top[x]], dfn[x]);\n        f0 = std::min(id[0][0], id[1][0]), f1 = std::min(id[0][1], id[1][1]);\n        // printf(&quot;%d: f0 = %d, f1 = %d\\n&quot;, top[x], f0, f1);\n        g[faa][0] += std::min(f0, f1 + 1);\n        g[faa][1] += std::min(f0 + 1, f1);\n        x = faa;\n    &#125;\n    add(rt[1], dfn[x]);\n    auto &amp;id = t[rt[1]].u;\n    int f0 = std::min(id[0][0], id[1][0]), f1 = std::min(id[0][1], id[1][1]);\n    // printf(&quot;%d: f0 = %d, f1 = %d\\n&quot;, 1, f0, f1);\n    return std::min(f0, f1);\n&#125;\nint cat(int x) &#123;\n    a[x] = 0;\n    return upd(x);\n&#125;\nint dog(int x) &#123;\n    a[x] = 1;\n    return upd(x);\n&#125;\nint neighbor(int x) &#123;\n    a[x] = -1;\n    return upd(x);\n&#125;\n#ifndef ONLINE_JUDGE\nint main() &#123;\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;int&gt; A(n - 1), B(n - 1);\n    for (int i = 0; i &lt; n - 1; ++i)\n        std::cin &gt;&gt; A[i] &gt;&gt; B[i];\n    initialize(n, A, B);\n    int q;\n    std::cin &gt;&gt; q;\n    for (int op, x; q--; ) &#123;\n        std::cin &gt;&gt; op &gt;&gt; x;\n        std::cout &lt;&lt; (op == 1 ? cat(x) : (op == 2 ? dog(x) : neighbor(x))) &lt;&lt; &#39;\\n&#39;;\n    &#125;\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n    return 0;\n&#125;\n#endif</code></pre>\n</details>\n<hr />\n<h3 id=\"f---hash-on-tree\">F - Hash on Tree</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/AT_abc351_g\" class=\"uri\">https://www.luogu.com.cn/problem/AT_abc351_g</a></p>\n<p>è®° <span class=\"math inline\">\\(g_x\\)</span> ä¸ºè½»å„¿å­çš„å“ˆå¸Œå€¼ä¹‹ç§¯ï¼Œåˆ™ <span class=\"math inline\">\\(f_u=A_u+f_{son}\\cdot g_u\\)</span>ã€‚</p>\n<p>ç„¶åå¼€ä¸€ä¸ªå¸¸æ•°ç»´å³å¯ã€‚å¿«é€Ÿå¹‚çš„ log çœä¸æ‰ï¼Œæ‰€ä»¥æ˜¯åŒ log çš„ã€‚</p>\n<p>åˆå€¼å’Œä¿®æ”¹éƒ½æœ‰å¯èƒ½ä¸º <span class=\"math inline\">\\(0\\)</span>ï¼Œéœ€è¦ç»´æŠ¤å®é™…å“ˆå¸Œå€¼å’Œå»æ‰ <span class=\"math inline\">\\(0\\)</span> çš„å“ˆå¸Œå€¼ã€‚</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 1e6 + 5;\nconst int LEN = (1 &lt;&lt; 20);\nconst int mod = 998244353;\nint nec(void) &#123;\n    static char buf[LEN], *p = buf, *e = buf;\n    if (p == e) &#123;\n        e = buf + fread(buf, 1, LEN, stdin);\n        if (e == buf) return EOF;\n        p = buf;\n    &#125;\n    return *p++;\n&#125;\nbool read(int &amp;x) &#123;\n    x = 0;\n    bool f = 0;\n    char ch = nec();\n    while (ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123;\n        if (ch == EOF) return 0;\n        if (ch == &#39;-&#39;) f = 1;\n        ch = nec();\n    &#125;\n    while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) &#123;\n        x = x * 10 + ch - &#39;0&#39;;\n        ch = nec();\n    &#125;\n    if (f) x = -x;\n    return 1;\n&#125;\nvoid print(int x) &#123;\n    if (x &lt; 0)\n        putchar(&#39;-&#39;), x = -x;\n    if (x &gt;= 10) print(x / 10);\n    putchar(x % 10 + &#39;0&#39;);\n    return;\n&#125;\nvoid print(int x, char ch) &#123;\n    print(x), putchar(ch);\n    return;\n&#125;\nstruct mat &#123;\n    int n, m;\n    long long a[2][2];\n    long long* operator[] (const int q) &#123;\n        return a[q];\n    &#125;\n    mat operator* (mat &amp;q) const &#123;\n        mat res;\n        res.n = n, res.m = q.m;\n        res[0][0] = res[0][1] = res[1][0] = res[1][1] = 0ll;\n        for (int i = 0; i &lt; n; ++i)\n            for (int k = 0; k &lt; q.m; ++k) &#123;\n                for (int j = 0; j &lt; m; ++j)\n                    res[i][k] += a[i][j] * q[j][k];\n                res[i][k] %= mod;\n            &#125;\n        return res;\n    &#125;\n    mat&amp; operator*= (mat &amp;q) &#123;\n        return *this = *this * q;\n    &#125;\n&#125;;\nstruct &#123; int lc, rc, l, r, mid; mat u; &#125; t[maxn &lt;&lt; 2]; \nlong long g[maxn];\nint tab[maxn], ls[maxn], a[maxn];\n#define lt t[p].lc\n#define rt t[p].rc\nvoid bld(int &amp;p, int l, int r) &#123;\n    static int tot = 0;\n    p = ++tot, t[p].l = l, t[p].r = r;\n    if (l == r) &#123;\n        int u = tab[l];\n        t[p].u.n = t[p].u.m = 2;\n        t[p].u[0][0] = g[u];\n        t[p].u[0][1] = 0ll;\n        t[p].u[1][0] = a[u];\n        t[p].u[1][1] = 1ll;\n        return;\n    &#125;\n    int s = 0, u = ls[tab[l]];\n    for (int i = l; i &lt;= r; ++i)\n        s += ls[tab[i]];\n    s &gt;&gt;= 1;\n    t[p].mid = r - 1;\n    for (int i = l + 1; i &lt; r; ++i) &#123;\n        u += ls[tab[i]];\n        if (u + ls[tab[i + 1]] &gt; s) &#123;\n            t[p].mid = i;\n            break;\n        &#125;\n    &#125;\n    bld(lt, l, t[p].mid), bld(rt, t[p].mid + 1, r);\n    t[p].u = t[rt].u * t[lt].u;\n    return;\n&#125;\nvoid add(int p, int x) &#123;\n    if (t[p].l == t[p].r) &#123;\n        int u = tab[x];\n        t[p].u[0][0] = g[u];\n        t[p].u[1][0] = a[u];\n        return;\n    &#125;\n    if (x &lt;= t[p].mid)\n        add(lt, x);\n    else\n        add(rt, x);\n    t[p].u = t[rt].u * t[lt].u;\n    return;\n&#125;\n#undef lt\n#undef rt\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, q;\n    read(n), read(q);\n    std::vector&lt;int&gt; rt(n + 1);\n    std::vector&lt;std::vector&lt;int&gt; &gt; g1(n + 1);\n    for (int i = 2, x; i &lt;= n; ++i) &#123;\n        read(x);\n        g1[i].push_back(x), g1[x].push_back(i);\n    &#125;\n    for (int i = 1; i &lt;= n; ++i)\n        read(a[i]);\n    std::vector&lt;int&gt; siz(n + 1), son(n + 1), fa(n + 1);\n    std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;\n        siz[x] = 1;\n        for (auto i : g1[x])\n            if (i != fa[x]) &#123;\n                fa[i] = x, DFS(i);\n                siz[x] += siz[i];\n                if (siz[i] &gt; siz[son[x]])\n                    son[x] = i;\n            &#125;\n        return;\n    &#125;;\n    DFS(1);\n    std::vector&lt;long long&gt; f(n + 1);\n    std::vector&lt;int&gt; top(n + 1), bot(n + 1), dfn(n + 1), la(n + 1), cnt(n + 1);\n    DFS = [&amp;](int x) &#123;\n        static int now = 0;\n        dfn[x] = ++now, tab[now] = x, ls[x] = 1;\n        if (son[x]) &#123;\n            top[son[x]] = top[x], DFS(son[x]);\n            bot[x] = bot[son[x]];\n            g[x] = 1ll;\n            for (auto i : g1[x])\n                if (i != son[x] &amp;&amp; i != fa[x]) &#123;\n                    top[i] = i, DFS(i);\n                    ls[x] += siz[i];\n                    if (f[i] == 0ll)\n                        ++cnt[x];\n                    else\n                        (la[x] *= f[i]) %= mod;\n                    (g[x] *= f[i]) %= mod;\n                &#125;\n            f[x] = (a[x] + g[x] * f[son[x]]) % mod;\n        &#125;\n        else\n            f[x] = a[x], bot[x] = x;\n        // printf(&quot;f[%d] = %lld\\n&quot;, x, f[x]);\n        if (x == top[x])\n            bld(rt[x], dfn[x], dfn[bot[x]]);\n        return;\n    &#125;;\n    top[1] = 1, DFS(1);\n    mat init;\n    init.n = 1, init.m = 2;\n    init[0][0] = 0ll, init[0][1] = 1ll;\n    auto qkp = [&amp;](long long x, int y) &#123;\n        auto res(1ll);\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    auto inv = [&amp;](int x) &#123;\n        return qkp(x, mod - 2);\n    &#125;;\n    for (int x, v; q--; ) &#123;\n        read(x), read(v);\n        a[x] = v;\n        for (; top[x] != 1; ) &#123;\n            int faa = fa[top[x]];\n            auto &amp;id = t[rt[top[x]]].u;\n            int f = (init * id)[0][0];\n            if (f == 0) &#123;\n                if (--cnt[faa] == 0)\n                    g[faa] = la[faa];\n            &#125;\n            else &#123;\n                f = inv(f);\n                (g[faa] *= f) %= mod;\n                (la[faa] *= f) %= mod;\n            &#125;\n            add(rt[top[x]], dfn[x]);\n            f = (init * id)[0][0];\n            if (f == 0) &#123;\n                if (cnt[faa]++ == 0)\n                    la[faa] = g[faa];\n                g[faa] = 0ll;\n            &#125;\n            else &#123;\n                (g[faa] *= f) %= mod;\n                (la[faa] *= f) %= mod;\n            &#125;\n            x = faa;\n        &#125;\n        add(rt[1], dfn[x]);\n        auto &amp;id = t[rt[1]].u;\n        int f = (init * id)[0][0];\n        std::cout &lt;&lt; f &lt;&lt; &#39;\\n&#39;;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"g---è€ƒè¯•-2\">G - è€ƒè¯• 2</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P10626\" class=\"uri\">https://www.luogu.com.cn/problem/P10626</a></p>\n<p>è¿ç®—å‡æ˜¯çº¿æ€§çš„ï¼Œå®¹æ˜“æƒ³åˆ°ã€æŒ‰ä½ã€ç»´æŠ¤ï¼Œå³åªç»´æŠ¤æŸä¸ªç‰¹å®šç‚¹å€¼ã€‚å¦‚æœå°†è¯¢é—®ç¦»çº¿ä¸‹æ¥æ’åºï¼Œæ¯ä¸ªå‡½æ•°çš„ç‚¹å€¼åªä¼šå˜åŒ– <span class=\"math inline\">\\(O(1)\\)</span> æ¬¡ã€‚</p>\n<p>å»ºå‡ºç¬¦å·äºŒå‰æ ‘ï¼Œè¿›è¡Œ DDP å³å¯ã€‚å…·ä½“åœ°ï¼Œä»¤ <span class=\"math inline\">\\(f_u\\)</span> è¡¨ç¤ºåœ¨è¿ç®— <span class=\"math inline\">\\(u\\)</span> å¤„çš„ç­”æ¡ˆï¼Œè®¡ç®— <span class=\"math inline\">\\(g_u\\)</span> ä¸ºè½»å„¿å­çš„ç­”æ¡ˆï¼ŒæŒ‰ç…§ <span class=\"math inline\">\\(u\\)</span> å¤„çš„ç¬¦å·å†™çŸ©é˜µå³å¯ã€‚å¶å­ä¸æ˜¯ä¸€æ¬¡è¿ç®—ï¼Œåº”è¯¥ç›´æ¥å¡«å…¥ç‚¹å€¼ï¼ˆæ³¨æ„çº¿æ®µæ ‘ä¸Šçš„å¶å­ä¸ä¸€å®šæ˜¯åŸæ ‘ä¸Šçš„å¶å­ï¼‰ã€‚</p>\n<p>å»ºæ ‘å’ŒçŸ©é˜µæ›´æ–°æœ‰ç‚¹å²ï¼Œé€‚å½“å°è£…ä¸€ä¸‹æ„Ÿè§‰ä¼šå¥½ä¸€ç‚¹</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 1e6 + 5;\nconst char mp[] = &quot;x!&amp;|^&quot;;\nconst int LEN = (1 &lt;&lt; 20);\n#define nec getchar\ninline bool read(int &amp;x) &#123;\n    x = 0;\n    bool f = 0;\n    char ch = nec();\n    while (ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123;\n        if (ch == EOF) return 0;\n        if (ch == &#39;-&#39;) f = 1;\n        ch = nec();\n    &#125;\n    while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) &#123;\n        x = x * 10 + ch - &#39;0&#39;;\n        ch = nec();\n    &#125;\n    if (f) x = -x;\n    return 1;\n&#125;\nvoid print(int x) &#123;\n    if (x &lt; 0)\n        putchar(&#39;-&#39;), x = -x;\n    if (x &gt;= 10) print(x / 10);\n    putchar(x % 10 + &#39;0&#39;);\n    return;\n&#125;\nvoid print(int x, char ch) &#123;\n    print(x), putchar(ch);\n    return;\n&#125;\nstruct mat &#123;\n    int n, m;\n    int a[2][2];\n    int* operator[] (const int q) &#123;\n        return a[q];\n    &#125;\n    inline mat operator* (mat &amp;q) const &#123;\n        mat res;\n        res.n = n, res.m = q.m;\n        res[0][0] = res[0][1] = res[1][0] = res[1][1] = 0ll;\n        for (int i = 0; i &lt; n; ++i)\n            for (int k = 0; k &lt; q.m; ++k)\n                for (int j = 0; j &lt; m; ++j)\n                    res[i][k] += a[i][j] * q[j][k];\n        return res;\n    &#125;\n    mat&amp; operator*= (mat &amp;q) &#123;\n        return *this = *this * q;\n    &#125;\n&#125;;\nstruct &#123; int lc, rc, l, r, mid; mat u; &#125; t[maxn &lt;&lt; 2]; \nint g1[maxn][2];\nint g[maxn], ty[maxn];\nint tab[maxn], ls[maxn], lim[maxn];\n#define lt t[p].lc\n#define rt t[p].rc\nvoid fillmat(mat &amp;a, int op, int g) &#123;\n    if (op == 0) &#123;\n        a.n = 1, a.m = 2;\n        a[0][!g] = 0, a[0][g] = 1;\n        return;\n    &#125;\n    a.n = 2, a.m = 2;\n    switch (op) &#123;\n    case 1: // !\n        a[0][0] = 0, a[0][1] = 1;\n        a[1][0] = 1, a[1][1] = 0;\n        break;\n    case 2: // &amp;\n        a[0][0] = 1, a[0][1] = 0;\n        a[1][0] = !g, a[1][1] = g;\n        break;\n    case 3: // |\n        a[0][0] = !g, a[0][1] = g;\n        a[1][0] = 0, a[1][1] = 1;\n        break;\n    case 4: // ^\n        a[0][0] = !g, a[0][1] = g;\n        a[1][0] = g, a[1][1] = !g;\n        break;\n    default:\n        assert(0);\n    &#125;\n    return;\n&#125;\nvoid bld(int &amp;p, int l, int r) &#123;\n    static int tot = 0;\n    p = ++tot, t[p].l = l, t[p].r = r;\n    if (l == r) &#123;\n        fillmat(t[p].u, ty[tab[l]], g[tab[l]]);\n        return;\n    &#125;\n    int s = 0, u = ls[tab[l]];\n    for (int i = l; i &lt;= r; ++i)\n        s += ls[tab[i]];\n    s &gt;&gt;= 1;\n    t[p].mid = r - 1;\n    for (int i = l + 1; i &lt; r; ++i) &#123;\n        u += ls[tab[i]];\n        if (u + ls[tab[i + 1]] &gt; s) &#123;\n            t[p].mid = i;\n            break;\n        &#125;\n    &#125;\n    bld(lt, l, t[p].mid), bld(rt, t[p].mid + 1, r);\n    t[p].u = t[rt].u * t[lt].u;\n    return;\n&#125;\nvoid add(int p, int x) &#123;\n    if (t[p].l == t[p].r) &#123;\n        fillmat(t[p].u, ty[tab[t[p].l]], g[tab[t[p].l]]);\n        return;\n    &#125;\n    if (x &lt;= t[p].mid)\n        add(lt, x);\n    else\n        add(rt, x);\n    t[p].u = t[rt].u * t[lt].u;\n    return;\n&#125;\n#undef lt\n#undef rt\nint main() &#123;\n#ifndef ONLINE_JUDGE\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n = 0, q, p;\n    read(q), read(q);\n    &#123;\n        std::string s;\n        std::cin &gt;&gt; s;\n        std::stringstream in(s);\n        std::stack&lt;char&gt; op;\n        std::stack&lt;int&gt; id;\n        auto trans = [&amp;](char t) &#123;\n            switch (t) &#123;\n            case &#39;!&#39;:\n                return 1;\n            case &#39;&amp;&#39;:\n                return 2;\n            case &#39;|&#39;:\n                return 3;\n            case &#39;^&#39;:\n                return 4;\n            &#125;\n            assert(0);\n            return -1;\n        &#125;;\n        auto calcNot = [&amp;](void) &#123;\n            for (; !op.empty() &amp;&amp; op.top() == &#39;!&#39;; ) &#123;\n                ty[++n] = trans(op.top());\n                g1[n][0] = id.top(), id.pop(), id.push(n);\n                op.pop();\n            &#125;\n            return;\n        &#125;;\n        auto opt = [&amp;](void) &#123;\n            ty[++n] = trans(op.top());\n            g1[n][0] = id.top(), id.pop();\n            g1[n][1] = id.top(), id.pop();\n            id.push(n), op.pop();\n            return;\n        &#125;;\n        for (char t; in &gt;&gt; t; )\n            if (t == &#39;[&#39;) &#123;\n                int x;\n                in &gt;&gt; x, in &gt;&gt; t;\n                lim[++n] = x - 1;\n                id.push(n), calcNot();\n            &#125;\n            else if (t == &#39;(&#39;)\n                op.push(t);\n            else if (t == &#39;)&#39;) &#123;\n                for (; op.top() != &#39;(&#39;; opt());\n                op.pop(), calcNot();\n            &#125;\n            else if (t == &#39;&amp;&#39;)\n                op.push(t);\n            else if (t == &#39;^&#39;) &#123;\n                for (; !op.empty() &amp;&amp; op.top() == &#39;&amp;&#39;; opt());\n                op.push(t);\n            &#125;\n            else if (t == &#39;|&#39;) &#123;\n                for (; !op.empty() &amp;&amp; (op.top() == &#39;&amp;&#39; || op.top() == &#39;^&#39;); opt());\n                op.push(t);\n            &#125;\n            else &#123;\n                assert(t == &#39;!&#39;);\n                op.push(t);\n            &#125;\n        for (; !op.empty(); opt());\n        p = id.top();\n    &#125;\n    std::vector&lt;int&gt; rt(n + 1);\n    std::vector&lt;int&gt; siz(n + 1), son(n + 1), fa(n + 1);\n    std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;\n        siz[x] = 1;\n        for (auto i : g1[x])\n            if (i != 0) &#123;\n                fa[i] = x, DFS(i);\n                siz[x] += siz[i];\n                if (siz[i] &gt; siz[son[x]])\n                    son[x] = i;\n            &#125;\n        return;\n    &#125;;\n    DFS(p);\n    std::vector&lt;long long&gt; f(n + 1);\n    std::vector&lt;int&gt; top(n + 1), bot(n + 1), dfn(n + 1);\n    DFS = [&amp;](int x) &#123;\n        static int now = 0;\n        dfn[x] = ++now, tab[now] = x, ls[x] = 1;\n        if (son[x]) &#123;\n            top[son[x]] = top[x], DFS(son[x]);\n            bot[x] = bot[son[x]];\n            for (auto i : g1[x])\n                if (i != son[x] &amp;&amp; i != 0) &#123;\n                    top[i] = i, DFS(i);\n                    ls[x] += siz[i], g[x] = f[i];\n                &#125;\n            switch (ty[x]) &#123;\n            case 1:\n                f[x] = !f[son[x]];\n                break;\n            case 2:\n                f[x] = g[x] &amp; f[son[x]];\n                break;\n            case 3:\n                f[x] = g[x] | f[son[x]];\n                break;\n            case 4:\n                f[x] = g[x] ^ f[son[x]];\n                break;\n            default:\n                assert(0);\n                break;\n            &#125;\n        &#125;\n        else\n            assert(!ty[x]), f[x] = g[x] = 0, bot[x] = x;\n        if (x == top[x])\n            bld(rt[x], dfn[x], dfn[bot[x]]);\n        return;\n    &#125;;\n    top[p] = p, DFS(p);\n    std::vector&lt;int&gt; a(q + 1), res(q + 1);\n    for (int i = 1; i &lt;= q; ++i)\n        read(a[i]);\n    std::vector&lt;int&gt; qid(q), nid;\n    for (int i = 1; i &lt;= n; ++i)\n        if (ty[i] == 0)\n            nid.push_back(i);\n    std::iota(qid.begin(), qid.end(), 1);\n    std::sort(qid.begin(), qid.end(), [&amp;](int x, int y) &#123; return a[x] &lt; a[y]; &#125;);\n    std::sort(nid.begin(), nid.end(), [&amp;](int x, int y) &#123; return lim[x] &gt; lim[y]; &#125;);\n    for (auto i : qid) &#123;\n        for (; !nid.empty() &amp;&amp; lim[nid.back()] &lt; a[i]; ) &#123;\n            int x = nid.back();\n            nid.pop_back();\n            g[x] = 1;\n            for (; top[x] != p; ) &#123;\n                add(rt[top[x]], dfn[x]);\n                g[fa[top[x]]] = t[rt[top[x]]].u[0][1];\n                x = fa[top[x]];\n            &#125;\n            add(rt[p], dfn[x]);\n        &#125;\n        res[i] = t[rt[p]].u[0][1];\n    &#125;\n    for (int i = 1; i &lt;= q; ++i)\n        if (res[i])\n            std::cout &lt;&lt; &quot;True\\n&quot;;\n        else\n            std::cout &lt;&lt; &quot;False\\n&quot;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n",
            "tags": [
                "çº¿æ®µæ ‘",
                "æ ‘é“¾å‰–åˆ†",
                "DDP"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20250510/",
            "url": "https://xsc062.netlify.app/20250510/",
            "title": "æ‚é¢˜",
            "date_published": "2025-05-10T02:18:21.000Z",
            "content_html": "<p>å•Šå•Šã€‚å°å°æ¡ã€‚</p>\n<span id=\"more\"></span>\n<hr />\n<h2 id=\"a---pass-to-next\">A - Pass to Next</h2>\n<p><a href=\"https://atcoder.jp/contests/arc124/tasks/arc124_e\" class=\"uri\">https://atcoder.jp/contests/arc124/tasks/arc124_e</a></p>\n<p>æ„Ÿè§‰å…¶ä»–ä¸€äº›é¢˜è§£è®²å¾—ä¸æ˜¯ç‰¹åˆ«æ¸…æ¥šï¼Œè¿™é‡Œå‚è€ƒäº† <a href=\"https://blog.csdn.net/weixin_43960287/article/details/119140590\">XJX çš„æ–‡ç« </a>ã€‚</p>\n<p>è¦æ±‚çš„ç­”æ¡ˆæ˜¯ <span class=\"math inline\">\\(\\prod a&#39;_i\\)</span>ï¼Œ<mark>å‘ç°è¿ç®—æ˜¯ä¹˜æ³•ï¼Œæ¯”è¾ƒæ€ªï¼›ç”±æ­¤è€ƒè™‘è½¬åŒ–ä¸ºæ–¹æ¡ˆæ•°ï¼Œä¹Ÿå°±æ˜¯å‡è®¾æ¯ä¸ªäººæœ‰ <span class=\"math inline\">\\(a&#39;_i\\)</span> ä¸ªäº’ä¸ç›¸åŒçš„çƒï¼Œæ¯ä¸ªäººåœ¨å…¶ä¸­é€‰å‡ºæ°å¥½ä¸€ä¸ªçš„æ–¹æ¡ˆæ•°</mark>ã€‚</p>\n<p>è€ƒè™‘ DPã€‚å‘ç°æ¯ä¸ªäººæ‰‹ä¸Šçš„çƒåˆ†ä¸ºã€è‡ªå·±çš„ã€å’Œã€å·¦è¾¹çš„äººä¼ è¿‡æ¥çš„ã€ä¸¤ç§ç±»å‹ï¼›<mark>æ˜¾ç„¶ç¬¬äºŒç§ä¼šæœ‰æ¥è‡ªä¸Šä¸€ä¸ªäººçš„é™åˆ¶ï¼Œè€ƒè™‘æŠŠç¬¬äºŒç§åœ¨ä¸Šä¸€ä¸ªäººå°±å®Œæˆæ±‚è§£</mark>ã€‚å…·ä½“åœ°ï¼Œè®¾ <span class=\"math inline\">\\(f_{i,0}\\)</span> è¡¨ç¤ºç¬¬ <span class=\"math inline\">\\(i\\)</span> ä¸ªäººé€‰å–è‡ªå·±çš„çƒï¼Œä½†åªè®°å½• <span class=\"math inline\">\\(1\\sim i-1\\)</span> çš„æ–¹æ¡ˆï¼›<span class=\"math inline\">\\(f_{i,1}\\)</span> è¡¨ç¤ºç¬¬ <span class=\"math inline\">\\(i\\)</span> ä¸ªäººé€‰å–ç¬¬ <span class=\"math inline\">\\(i-1\\)</span> ä¸ªäººçš„çƒï¼Œå¹¶è®°å…¥ç­”æ¡ˆçš„æ–¹æ¡ˆã€‚<em>ä½ å¯èƒ½éœ€è¦æ³¨æ„åˆ°ï¼šæœ€åä¸€ä¸ªè¢«è®°å…¥æ–¹æ¡ˆçš„çƒæ¥è‡ªç¬¬ <span class=\"math inline\">\\(i-1\\)</span> ä¸ªäºº</em>ã€‚</p>\n<p>ä½†è¿™æ ·ä¼šæœ‰ä¸ªå°é—®é¢˜ã€‚æˆ‘ä»¬è®©æ‰€æœ‰äººå¤šå¾€å³è¾¹ä¼ ä¸€ä¸ªçƒï¼Œé‚£ä¹ˆåœ¨æˆ‘ä»¬çš„è¿™ç§åˆ†å‰²æ–¹æ³•çœ‹æ¥æ˜¯ä¸ä¸€æ ·çš„å±€é¢ï¼›ä½†å®é™…ä¸Šå®ƒä»¬æ˜¯ç­‰ä»·çš„ã€‚ä»æ¯ä¸ªäººä¼ å‡ºäº†å¤šå°‘ä¸ªçƒï¼ˆè®¾ä¸º <span class=\"math inline\">\\(x_i\\)</span>ï¼‰çš„è§’åº¦æ¥çœ‹ï¼Œå¯¹äº <span class=\"math inline\">\\(\\min\\{x_n\\}\\ne 0\\)</span>ï¼Œåªéœ€è¦ä¸æ–­æ‰§è¡Œ <span class=\"math inline\">\\(\\forall\\, x_i\\gets x_i-1\\)</span> å°±å¯ä»¥åœ¨å±€é¢ä¸å˜çš„æƒ…å†µä¸‹ä½¿ <span class=\"math inline\">\\(\\min\\{x_n\\}\\ne 0\\)</span>ã€‚è¿™æ˜¯åœ¨è¯´ï¼Œå¯ä»¥è®© <span class=\"math inline\">\\(\\min\\{x_n\\}\\ne 0\\)</span> çš„æ–¹æ¡ˆå’Œç»ˆå±€ä¸€ä¸€å¯¹åº”ã€‚</p>\n<p>å‘ç°å¯ä»¥å®¹æ–¥ï¼šé’¦å®š <span class=\"math inline\">\\(x_i\\ge 1\\)</span>ï¼Œä¹Ÿå°±æ˜¯æ¯ä¸ªäººå¿…é¡»å¾€å³ä¼ è‡³å°‘ä¸€ä¸ªï¼Œç›¸ä¼¼åœ°ç®—ä¸€éå°±èƒ½å¾—åˆ°éæ³•æ–¹æ¡ˆã€‚</p>\n<p>è€ƒè™‘è½¬ç§»ï¼Œä»¤ <span class=\"math inline\">\\(x_i\\)</span> å¯é€‰æœ€å°å€¼ä¸º <span class=\"math inline\">\\(l\\)</span>ï¼Œæœ‰ï¼š</p>\n<ul>\n<li><span class=\"math inline\">\\(f_{i+1,0}\\gets f_{i,0}\\)</span>ï¼šå°†ç¬¬ <span class=\"math inline\">\\(i\\)</span> ä¸ªäººæœªè¢«è®°å…¥çš„è‡ªå·±çš„çƒè®°å…¥ï¼Œçƒæ•°å¯èƒ½ä¸º <span class=\"math inline\">\\([0,a_i-l]\\)</span>ã€‚ç­‰å·®æ•°åˆ—æ±‚å’Œå³å¯ã€‚</li>\n<li><span class=\"math inline\">\\(f_{i+1,0}\\gets f_{i,1}\\)</span>ï¼šæ²¡æœ‰çƒéœ€è¦è¢«è®°å…¥ï¼Œä½†æ˜¯è¿™ç§æƒ…å†µå¯¹åº”å¤šç§ <span class=\"math inline\">\\(x_i\\)</span>ã€‚å…·ä½“åœ°ï¼Œ<span class=\"math inline\">\\(x_i\\in [l,a_i]\\)</span>ã€‚å…±æœ‰ <span class=\"math inline\">\\(a_i-l+1\\)</span> ç§æ–¹æ¡ˆã€‚</li>\n<li><span class=\"math inline\">\\(f_{i+1,1}\\gets f_{i,0}\\)</span>ï¼šå°†ç¬¬ <span class=\"math inline\">\\(i\\)</span> ä¸ªäººçš„ <span class=\"math inline\">\\(a_i\\)</span> ä¸ªçƒåˆ†ç»™ <span class=\"math inline\">\\(i\\)</span> å’Œ <span class=\"math inline\">\\(i+1\\)</span>ã€‚å…±æœ‰ <span class=\"math inline\">\\(x_i\\cdot (a_i-x_i)\\)</span> ç§å¯èƒ½ï¼Œä¹Ÿå°±æ˜¯ <span class=\"math inline\">\\(\\left(a_i\\cdot \\sum_{x_i=l}^{a_i} x_i\\right)-\\left(\\sum_{x_i=l}^{a_i}{x_i}^2\\right)\\)</span> ç§æ–¹æ¡ˆã€‚</li>\n<li><span class=\"math inline\">\\(f_{i+1,1}\\gets f_{i,1}\\)</span>ï¼šå°†ç¬¬ <span class=\"math inline\">\\(i+1\\)</span> ä¸ªäººå¾—åˆ°çš„ç¬¬ <span class=\"math inline\">\\(i\\)</span> ä¸ªäººçš„çƒè®°å…¥ï¼ŒåŒç¬¬ä¸€æ¡ã€‚</li>\n</ul>\n<p>ç ´ç¯ä¸ºé“¾ï¼Œåˆ†åˆ«é’¦å®šç¬¬ä¸€ä¸ªäººæ˜¯ç”¨è‡ªå·±çš„çƒè¿˜æ˜¯ä¸Šä¸€ä¸ªäººçš„çƒæ¥è§£å†³é—®é¢˜ï¼ˆå¿…é¡»å¯¹äºä¸¤ç§å¯èƒ½æ€§åˆ†å¼€è®¡ç®—ï¼›å¦åˆ™å°±ä¸çŸ¥é“ç­”æ¡ˆåº”è¯¥å– <span class=\"math inline\">\\(f_{n,0}\\)</span> è¿˜æ˜¯ <span class=\"math inline\">\\(f_{n,1}\\)</span>ï¼‰ã€‚</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 998244353, inv2 = (mod + 1) &gt;&gt; 1, inv6 = 166374059;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;long long&gt; a(n);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i % n];\n    auto sum = [&amp;](long long r) &#123;\n        return r * (r + 1) % mod * inv2 % mod;\n    &#125;;\n    auto sum2 = [&amp;](long long r) &#123;\n        return r * (r + 1) % mod * (2 * r % mod + 1) % mod * inv6 % mod;\n    &#125;;\n    std::vector&lt;std::vector&lt;long long&gt; &gt; f0(n, std::vector&lt;long long&gt; (2)), f1(n, std::vector&lt;long long&gt; (2));\n    auto calc = [&amp;](long long l, std::vector&lt;std::vector&lt;long long&gt; &gt; &amp;f) &#123;\n        f[0][0] = 1ll;\n        for (int i = 0; i &lt; n; ++i) &#123;\n            int j = (i + 1) % n;\n            f[j][0] = f[i][0] * sum(a[i] - l) % mod;\n            (f[j][0] += f[i][1] * (a[i] - l + 1)) %= mod;\n            f[j][1] = f[i][0] * (a[i] * sum(a[i]) % mod - sum2(a[i])) % mod;\n            (f[j][1] += f[i][1] * sum(a[i]) % mod) %= mod;\n            // printf(&quot;0, l = %lld, f[%d]: %lld / %lld\\n&quot;, l, j, f[j][0], f[j][1]);\n        &#125;\n        auto res(f[0][0]);\n        f.assign(n, std::vector&lt;long long&gt; (2));\n        f[0][1] = 1ll;\n        for (int i = 0; i &lt; n; ++i) &#123;\n            int j = (i + 1) % n;\n            f[j][0] = f[i][0] * sum(a[i] - l) % mod;\n            (f[j][0] += f[i][1] * (a[i] - l + 1)) %= mod;\n            f[j][1] = f[i][0] * (a[i] * sum(a[i]) % mod - sum2(a[i])) % mod;\n            (f[j][1] += f[i][1] * sum(a[i]) % mod) %= mod;\n            // printf(&quot;1, l = %lld, f[%d]: %lld / %lld\\n&quot;, l, j, f[j][0], f[j][1]);\n        &#125;\n        return (res + f[0][1]) % mod;\n    &#125;;\n    std::cout &lt;&lt; (calc(0, f0) + mod - calc(1, f1)) % mod &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"b---ç»¿å®çŸ³ä¹‹å²›\">B - ç»¿å®çŸ³ä¹‹å²›</h2>\n<p><a href=\"https://loj.ac/p/6406\" class=\"uri\">https://loj.ac/p/6406</a></p>\n<p>å› ä¸ºåªå…³å¿ƒæœ€ç»ˆçŠ¶æ€ï¼ŒåŸé¢˜å¯ä»¥è½¬åŒ–ä¸ºï¼šå°† <span class=\"math inline\">\\(d\\)</span> åˆ†æˆ <span class=\"math inline\">\\(n\\)</span> ä¸ªéè´Ÿæ•´æ•°ï¼Œå‰ <span class=\"math inline\">\\(r\\)</span> å¤§æ•°ä¹‹å’Œçš„æœŸæœ›ï¼ˆå½“ç„¶ä½ éœ€è¦åŠ ä¸Šåˆå§‹çš„ <span class=\"math inline\">\\(r\\)</span> ä¸ªï¼‰ã€‚</p>\n<p>å…³äºéè´Ÿæ•´æ•°æ‹†åˆ†ï¼šè®¾ <span class=\"math inline\">\\(f_{i,j}\\)</span> è¡¨ç¤ºå°† <span class=\"math inline\">\\(i\\)</span> åˆ†æˆ <span class=\"math inline\">\\(j\\)</span> ä¸ª <strong>éè´Ÿæ•´æ•°</strong> çš„æ–¹æ¡ˆï¼Œé’¦å®šå…¶ä¸­æ°æœ‰ <span class=\"math inline\">\\(k\\)</span> ä¸ª <strong>æ­£æ•´æ•°</strong> è¿›è¡Œè½¬ç§»ï¼Œç»™è¿™ <span class=\"math inline\">\\(k\\)</span> ä¸ªæ•°å…ˆåˆ†ä¸€ä¸ª <span class=\"math inline\">\\(1\\)</span>ï¼Œåˆ™ <span class=\"math inline\">\\(f_{i,j}=\\sum\\limits_{k=0}^{\\min(i,j)} C_j^k\\cdot f_{i-k,k}\\)</span>ã€‚</p>\n<p>å†è®¾ <span class=\"math inline\">\\(g_{i,j}\\)</span> è¡¨ç¤ºå°† <span class=\"math inline\">\\(i\\)</span> åˆ†æˆ <span class=\"math inline\">\\(j\\)</span> ä¸ªéè´Ÿæ•´æ•°çš„æ‰€æœ‰æ–¹æ¡ˆä¸­ã€å‰ <span class=\"math inline\">\\(r\\)</span> å¤§çš„æ•°ä¹‹å’Œã€‚ç±»ä¼¼åœ°ï¼Œæœ‰ <span class=\"math inline\">\\(g_{i,j}=\\sum\\limits_{k=0}^{\\min(i,j)} C_j^k\\cdot (g_{i-k,k}+\\min(k,r)\\cdot f_{i-k,k})\\)</span>ã€‚å…¶ä¸­ï¼Œ<span class=\"math inline\">\\(\\min(k,r)\\)</span> çš„æ¥æºæ˜¯ï¼Œåªæœ‰ <span class=\"math inline\">\\(k\\)</span> ä¸ªæ•°æœ‰å€¼ï¼Œå‰ <span class=\"math inline\">\\(r\\)</span> å¤§çš„æ•°ä¸€å®šåœ¨è¿™ <span class=\"math inline\">\\(k\\)</span> ä¸ªæ•°é‡Œé¢ã€‚</p>\n<p>ç­”æ¡ˆä¸º <span class=\"math inline\">\\(\\dfrac {g_{d,n}}{f_{d,n}}+r\\)</span>ï¼Œå¤æ‚åº¦ <span class=\"math inline\">\\(O(n^3)\\)</span>ã€‚</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, d, r;\n    std::cin &gt;&gt; n &gt;&gt; d &gt;&gt; r;\n    using arr = std::vector&lt;double&gt;;\n    std::vector&lt;arr&gt; f(d + 1, arr(n + 1)), g(d + 1, arr(n + 1)), C(n + 1, arr(n + 1));\n    for (int i = 0; i &lt;= n; ++i) &#123;\n        C[i][0] = 1.;\n        for (int j = 1; j &lt;= i; ++j)\n            C[i][j] = C[i - 1][j - 1] + C[i - 1][j];\n    &#125;\n    f[0].assign(n + 1, 1.);\n    for (int i = 1; i &lt;= d; ++i)\n        for (int j = 1; j &lt;= n; ++j) &#123;\n            for (int k = 1; k &lt;= i &amp;&amp; k &lt;= j; ++k) &#123;\n                f[i][j] += C[j][k] * f[i - k][k];\n                g[i][j] += C[j][k] * (g[i - k][k] + std::min(k, r) * f[i - k][k]);\n                // printf(&quot;  k = %d, %.0lf + %.0lf\\n&quot;, k, C[j][k] * g[i - k][k], std::min(k, r) * f[i - k][k]);\n            &#125;\n            // printf(&quot;f[%d][%d] = %.0lf, g[%d][%d] = %.0lf\\n&quot;, i, j, f[i][j], i, j, g[i][j]);\n        &#125;\n    std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(8) &lt;&lt; g[d][n] / f[d][n] + r &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"c---uddered-but-not-herd-g\">C - Uddered but not Herd G</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P7296\" class=\"uri\">https://www.luogu.com.cn/problem/P7296</a></p>\n<p>ç»™æ¯ä¸ªå­—æ¯åˆ†é…ä¸€ä¸ªæ ‡å· <span class=\"math inline\">\\(x\\)</span>ï¼Œé‚£ä¹ˆæœ€å°æ®µæ•°å°±æ˜¯ <span class=\"math inline\">\\(\\sum \\left[x_i\\ge x_{i+1}\\right]\\)</span>ã€‚</p>\n<p>è€ƒè™‘çŠ¶å‹å®Œæˆæ˜ å°„æ“ä½œï¼Œä»¤ <span class=\"math inline\">\\(f_{s}\\)</span> è¡¨ç¤ºç»™æ ‡å· <span class=\"math inline\">\\(1\\sim |s|\\)</span> åˆ†é…å­—æ¯åï¼Œå ç”¨å­—ç¬¦é›† <span class=\"math inline\">\\(s\\)</span> çš„æ–¹æ¡ˆæ•°ï¼Œé‚£ä¹ˆå°±èƒ½ <span class=\"math inline\">\\(O(1)\\)</span> å¾—åˆ°è´¡çŒ®â€”â€”åªéœ€é¢„å¤„ç†å‡º <span class=\"math inline\">\\(f_{c, s}\\)</span> è¡¨ç¤ºåˆ†é…åˆ°å­—æ¯ <span class=\"math inline\">\\(c\\)</span> æ—¶ï¼Œå·²ç»å…ˆç»™ <span class=\"math inline\">\\(s\\)</span> ä¸­å­—æ¯åˆ†é…äº†æ›´å°æ ‡å·æ—¶çš„è´¡çŒ®ã€‚</p>\n<p>æ³¨æ„å­—ç¬¦é›†å¤§å°åªæœ‰ <span class=\"math inline\">\\(20\\)</span>ï¼Œå¯ä»¥ <span class=\"math inline\">\\(O(|S|\\cdot 2^{|S|})\\)</span> è§£å†³é—®é¢˜ï¼Œ<mark>æ³¨æ„åˆ°é¢„å¤„ç†çš„å†…å®¹æ˜¯ç±»é«˜ç»´å‰ç¼€æœ€å€¼çš„å½¢å¼ï¼Œå¯ä»¥é€’æ¨é™ä½å¤æ‚åº¦</mark>ã€‚</p>\n<details>\n<pre data-line=\"26-28\" class=\"cpp language-cpp\"><code data-line=\"26-28\" class=\"cpp language-cpp\">#include &lt;bits/stdc++.h>\nconst int inf = 0x3f3f3f3f;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(\".in\", \"r\", stdin);\n    std::freopen(\".out\", \"w\", stdout);\n#endif\n    int n;\n    std::string t;\n    std::cin >> t, n = (int)t.length(), t = \"#\" + t;\n    std::vector&lt;int> a, tag(26, -1), s(n + 1);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        if (tag[t[i] - 'a'] == -1)\n            tag[t[i] - 'a'] = (int)a.size(), a.push_back(t[i] - 'a');\n        s[i] = tag[t[i] - 'a'];\n    &#125;\n    int m = (int)a.size(), siz = 1 &lt;&lt; m;\n    std::vector&lt;std::vector&lt;int> > cnt(m, std::vector&lt;int> (m));\n    for (int i = 1; i &lt; n; ++i)\n        ++cnt[s[i]][s[i + 1]];\n    std::vector&lt;std::vector&lt;int> > g(m, std::vector&lt;int> (siz));\n    for (int i = 0; i &lt; m; ++i)\n        for (int k = 0; k &lt; m; ++k) // æ³¨æ„è¿™é‡Œç›¸å½“äºæ˜¯é’¦å®šä» k å¤„è½¬ç§»\n            for (int j = (1 &lt;&lt; k); j &lt; (2 &lt;&lt; k); ++j) // æšä¸¾çš„æ˜¯ k ä½ä¸º 1 çš„æ‰€æœ‰æ•°ï¼›è¿™ä¸¤å±‚å¾ªç¯çš„å¤æ‚åº¦ä¸º O(siz)\n                g[i][j] = g[i][j ^ (1 &lt;&lt; k)] + cnt[i][k]; // ç›®çš„æ˜¯æ­¤å¤„çš„å†…å­˜è¿ç»­è®¿é—®ä¼˜åŒ–ï¼ŒæŠŠ ^ çœ‹ä½œ - åº”è¯¥å°±èƒ½ç†è§£ä¸ºä»€ä¹ˆç¬¬äºŒç»´æ˜¯è¿ç»­çš„\n    std::vector&lt;int> f(siz, inf);\n    f[0] = 1;\n    for (int i = 1; i &lt; siz; ++i)\n        for (int j = 0; j &lt; m; ++j)\n            if ((i >> j) & 1)\n                f[i] = std::min(f[i], f[i ^ (1 &lt;&lt; j)] + g[j][i]);\n    std::cout &lt;&lt; f[siz - 1] &lt;&lt; '\\n';\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"d---min-max-subarrays-p\">D - Min Max Subarrays P</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P11845\" class=\"uri\">https://www.luogu.com.cn/problem/P11845</a></p>\n<p>å…ˆè€ƒè™‘ <span class=\"math inline\">\\(01\\)</span> åºåˆ—çš„ç­”æ¡ˆï¼šå¦‚æœåºåˆ—ä¸­å­˜åœ¨ç›¸é‚»çš„ <span class=\"math inline\">\\(2\\)</span> ä¸ª <span class=\"math inline\">\\(1\\)</span>ï¼Œæ€»èƒ½ä¿è¯æœ€åçš„ä¸€ä¸ªæ˜¯ <span class=\"math inline\">\\(1\\)</span>ã€‚</p>\n<p>å¦‚æœåºåˆ—ä¸­å­˜åœ¨ <span class=\"math inline\">\\(\\ge 3\\)</span> ä¸ª <span class=\"math inline\">\\(1\\)</span>ï¼Œå¯ä»¥ç‰ºç‰²å…¶ä¸­çš„ä¸€äº›ä½¿å¾— <span class=\"math inline\">\\(2\\)</span> ä¸ª <span class=\"math inline\">\\(1\\)</span> ç›¸é‚»ã€‚</p>\n<p>å½“åºåˆ—ä¸­åªæœ‰ <span class=\"math inline\">\\(2\\)</span> ä¸ª <span class=\"math inline\">\\(1\\)</span> æ—¶ï¼Œåªæœ‰å› ä¸ºå‰©ä¸‹çš„ <span class=\"math inline\">\\(0\\)</span> ä¸å¤ªå¤Ÿï¼Œå¯¼è‡´æˆ‘ä»¬æ— æ³•éšæ„ã€ä¸Šä¸‹å…¶æ‰‹ã€æ—¶ä¸èƒ½å°† <span class=\"math inline\">\\(2\\)</span> ä¸ª <span class=\"math inline\">\\(1\\)</span> æŒªåˆ°ä¸€èµ·ã€‚</p>\n<p>ä»¤ä¸¤ä¸ª <span class=\"math inline\">\\(1\\)</span> ä¸ºåºåˆ—æœ€å¤§å€¼ä¸æ¬¡å¤§å€¼ï¼Œæš´æœå¤„ç†åºåˆ—é•¿åº¦è¾ƒå°çš„æƒ…å†µï¼Œå‰©ä¸‹çš„ç›´æ¥ç”¨å¥‡å¶æ€§åˆ¤æ–­ä¸¤ä¸ª <span class=\"math inline\">\\(1\\)</span> å–å“ªä¸ªã€‚</p>\n<hr />\n<h2 id=\"a---mst-on-line\">A - MST on Line++</h2>\n<p><a href=\"https://atcoder.jp/contests/arc167/tasks/arc167_c\" class=\"uri\">https://atcoder.jp/contests/arc167/tasks/arc167_c</a></p>\n<p>ç›¸å½“äºæŠŠ <span class=\"math inline\">\\(a\\)</span> æ‰“ä¹±ç„¶åå¤„ç†åŸé—®é¢˜ã€‚è€ƒè™‘æ¯ä¸ª <span class=\"math inline\">\\(a_i\\)</span> çš„è´¡çŒ®æ¬¡æ•°ã€‚æ¨¡æ‹Ÿ Kruskal è¿è¾¹ï¼Œä»å°åˆ°å¤§æŠŠç‚¹ <span class=\"math inline\">\\(a_i\\)</span> åŠ å…¥å›¾ï¼Œ<span class=\"math inline\">\\(a_i\\)</span> å¯ä»¥å‘ <span class=\"math inline\">\\(a_{[i-K,i+K]}\\)</span> å†…æ‰€æœ‰è¿é€šå—è¿è¾¹ã€‚</p>\n<p>è¿é€šå—æ•°é‡å½“ä¸”ä»…å½“ <span class=\"math inline\">\\([i-K,i)\\)</span> å†…æœ€é å³çš„ç‚¹å’Œ <span class=\"math inline\">\\((i, i+K]\\)</span> å†…æœ€é å·¦çš„ç‚¹è·ç¦» <span class=\"math inline\">\\(&gt;K\\)</span> æ—¶ä¸º <span class=\"math inline\">\\(2\\)</span>ï¼Œå…¶ä½™æƒ…å†µä¸º <span class=\"math inline\">\\(1\\)</span>ã€‚</p>\n<p>ä½†è¦æ˜¯ä»è¿™ä¸ªè§’åº¦æƒ³è¿™ä¸ªé¢˜å°±ä¸å¤ªå¥½åšäº†ã€‚æ­£ç¡®çš„æƒ³æ³•åº”è¯¥æ˜¯<mark>æ‹†åˆ†ä¸ºã€è‹¥ <span class=\"math inline\">\\([i-K,i)\\)</span> ä¸­æœ‰ç‚¹ï¼Œè´¡çŒ®æ¬¡æ•° <span class=\"math inline\">\\(+1\\)</span>ã€å’Œã€è‹¥ <span class=\"math inline\">\\((i,i+K]\\)</span> ä¸­æœ‰ç‚¹ <span class=\"math inline\">\\(j\\)</span> æ»¡è¶³ <span class=\"math inline\">\\([j-K,j)\\)</span> ä¸­æ— ç‚¹ï¼Œè´¡çŒ®æ¬¡æ•° <span class=\"math inline\">\\(+1\\)</span>ã€</mark>ã€‚å¯¹äºç¬¬ä¸€ä¸ªé—®é¢˜ï¼Œè´¡çŒ®æ¬¡æ•°å°†å‰ <span class=\"math inline\">\\(i-1\\)</span> å¤§çš„æ•°åˆ†é…è‡³å°‘ä¸€ä¸ªåˆ° <span class=\"math inline\">\\([i-K,i)\\)</span> ä¸­çš„æ–¹æ¡ˆæ•°ï¼›å¯¹äºç¬¬äºŒä¸ªé—®é¢˜ï¼Œæšä¸¾ <span class=\"math inline\">\\(j\\)</span>ï¼Œè´¡çŒ®æ¬¡æ•°ä¸ºå°†å‰ <span class=\"math inline\">\\(i-1\\)</span> å¤§çš„æ•°åˆ†é…åˆ° <span class=\"math inline\">\\(j\\)</span> å’Œ <span class=\"math inline\">\\([1,j-K)\\cup (j, n]\\)</span> ä¸­çš„æ–¹æ¡ˆæ•°ã€‚</p>\n<details>\n<p>å®ç°çš„æ—¶å€™åƒä¸‡æ³¨æ„å¾ªç¯å˜é‡æšä¸¾çš„æ˜¯ä½ç½®è¿˜æ˜¯å€¼ï¼ä¸ç„¶ä½ ä¼šè°ƒå¾—å¾ˆç—›è‹¦ã€‚</p>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 998244353;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;03-max-01.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, k;\n    std::cin &gt;&gt; n &gt;&gt; k;\n    std::vector&lt;int&gt; a(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i];\n    std::sort(a.begin() + 1, a.end());\n    std::vector&lt;long long&gt; fac(n + 1), inv(n + 1);\n    fac[0] = inv[0] = 1ll;\n    for (int i = 1; i &lt;= n; ++i)\n        fac[i] = fac[i - 1] * i % mod;\n    auto qkp = [](long long x, int y) &#123;\n        auto res(1ll);\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    inv[n] = qkp(fac[n], mod - 2);\n    for (int i = n - 1; i; --i)\n        inv[i] = inv[i + 1] * (i + 1) % mod;\n    auto A = [&amp;](int n, int m) &#123;\n        if (n &lt; m)\n            return 0ll;\n        return fac[n] * inv[n - m] % mod;\n    &#125;;\n    auto C = [&amp;](int n, int m) &#123;\n        return A(n, m) * inv[m] % mod;\n    &#125;;\n    long long res = 0ll;\n    for (int i = 2; i &lt;= n; ++i) &#123;\n        for (int j = 1; j &lt;= n; ++j)\n            (res += a[i] * (fac[n - 1] + mod - A(n - 1 - (j - std::max(1, j - k)), i - 1) * fac[n - i] % mod) % mod) %= mod;\n        for (int j = 2; j &lt;= n; ++j)\n            (res += a[i] * C(i - 1, i - 2) % mod * C(j - std::max(1, j - k), 1) % mod * A(n - (j - std::max(1, j - k) + 1), i - 2) % mod * fac[n - i] % mod) %= mod;\n    &#125;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"b---existence-counting\">B - Existence Counting</h2>\n<p><a href=\"https://atcoder.jp/contests/arc174/tasks/arc174_e\" class=\"uri\">https://atcoder.jp/contests/arc174/tasks/arc174_e</a></p>\n<p>å‘ç°å¯ä»¥åˆ†ç±»è®¨è®ºã€‚å‡è®¾ <span class=\"math inline\">\\(a&#39;\\)</span> ä¸­ç¬¬ä¸€ä¸ªå¼‚äº <span class=\"math inline\">\\(a\\)</span> çš„ä½ç½®ä¸º <span class=\"math inline\">\\(i\\)</span>ï¼Œ<span class=\"math inline\">\\(x\\)</span> åœ¨ <span class=\"math inline\">\\(a\\)</span> ä¸­ä½ç½®ä¸º <span class=\"math inline\">\\(pos_x\\)</span>ï¼ˆä¸å­˜åœ¨åˆ™ <span class=\"math inline\">\\(pos_x=k+1\\)</span>ï¼‰ã€‚ä»¤ <span class=\"math inline\">\\(f_i\\)</span> ä¸ºè‹¥ <span class=\"math inline\">\\(1\\sim i-1\\)</span> å‡ç›¸åŒï¼Œ<span class=\"math inline\">\\(i\\)</span> ä½ç½®å¯é€‰çš„é€‰é¡¹æ•°ã€‚åˆ™ <span class=\"math inline\">\\(x\\)</span> å‡ºç°çš„æ¬¡æ•°ï¼š</p>\n<table>\n<colgroup>\n<col style=\"width: 25%\" />\n<col style=\"width: 25%\" />\n<col style=\"width: 25%\" />\n<col style=\"width: 25%\" />\n</colgroup>\n<thead>\n<tr class=\"header\">\n<th style=\"text-align: center;\"></th>\n<th style=\"text-align: center;\"><span class=\"math inline\">\\(pos_x&lt;i\\)</span></th>\n<th style=\"text-align: center;\"><span class=\"math inline\">\\(pos_x=i\\)</span></th>\n<th style=\"text-align: center;\"><span class=\"math inline\">\\(pos_x&gt;i,i&lt;k\\)</span></th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td style=\"text-align: center;\"><span class=\"math inline\">\\(x\\le a_i\\)</span></td>\n<td style=\"text-align: center;\"><span class=\"math inline\">\\(1+f_i\\cdot A_{n-i}^{k-i}\\)</span></td>\n<td style=\"text-align: center;\"><span class=\"math inline\">\\(f_i\\cdot C_{k-i}^1\\cdot A_{n-i-1}^{k-i-1}\\)</span></td>\n<td style=\"text-align: center;\"><span class=\"math inline\">\\((f_i-1)\\cdot C_{k-i}^1\\cdot A_{n-i-1}^{k-i-1}+A_{n-i}^{k-i}\\)</span></td>\n</tr>\n<tr class=\"even\">\n<td style=\"text-align: center;\"><span class=\"math inline\">\\(x&gt;a_i\\)</span></td>\n<td style=\"text-align: center;\"><span class=\"math inline\">\\(f_i\\cdot A_{n-i}^{k-i}\\)</span></td>\n<td style=\"text-align: center;\"><span class=\"math inline\">\\(0\\)</span></td>\n<td style=\"text-align: center;\"><span class=\"math inline\">\\(f_i\\cdot C_{k-i}^1\\cdot A_{n-i-1}^{k-i-1}\\)</span></td>\n</tr>\n</tbody>\n</table>\n<p>æ•…ï¼Œå¯¹äºä»»æ„ <span class=\"math inline\">\\(x\\)</span>ï¼Œç­”æ¡ˆä¸ºï¼š</p>\n<p><span class=\"math display\">\\[\n\\begin{aligned}\n&amp;1+\\left(\\sum_{i=pos_x+1}^k f_i\\cdot A_{n-i}^{k-i}\\right)\n+\\sum_{i=1}^{pos_x} (f_i-[x&lt; a_i])\\cdot C_{k-i}^1\\cdot A_{n-i-1}^{k-i-1}+[x&lt; a_i]\\cdot A_{n-i}^{k-i}\\\\\n=&amp;1+\\left(\\sum_{i=pos_x+1}^k f_i\\cdot A_{n-i}^{k-i}\\right)\n+\\left(\\sum_{i=1}^{pos_x} f_i\\cdot C_{k-i}^1\\cdot A_{n-i-1}^{k-i-1}\\right)+\\sum_{i=1,a_i&gt; x}^{pos_x}A_{n-i}^{k-i}-C_{k-i}^1\\cdot A_{n-i-1}^{k-i-1}\\\\\n\\end{aligned}\n\\]</span></p>\n<p>é¢„å¤„ç†å‡º <span class=\"math inline\">\\(f_i=\\sum\\limits_{j=i+1}^k [a_j&lt; a_i]\\)</span>ï¼ˆéœ€è¦æ•°æ®ç»“æ„ï¼‰ã€<span class=\"math inline\">\\(g_i=\\sum\\limits_{j=1}^i f_j\\cdot A_{n-j}^{k-j}\\)</span> å’Œ <span class=\"math inline\">\\(h_j=\\sum\\limits_{j=1}^i f_i\\cdot C_{k-i}^1\\cdot A_{n-i-1}^{k-i-1}\\)</span>ï¼Œå†ç”¨æ•°æ®ç»“æ„è®¡ç®— <span class=\"math inline\">\\(\\sum\\limits_{i=1,a_i&gt;x}^{pos_x}C_{k-i}^1\\cdot A_{n-i-1}^{k-i-1} - A_{n-i}^{k-i}\\)</span> å³å¯ã€‚</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 998244353;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, k;\n    std::cin &gt;&gt; n &gt;&gt; k;\n    std::vector&lt;int&gt; a(k + 1), p(n + 1, k + 1);\n    for (int i = 1; i &lt;= k; ++i)\n        std::cin &gt;&gt; a[i], p[a[i]] = i;\n    std::vector&lt;long long&gt; fac(n + 1), inv(n + 1);\n    &#123;\n        fac[0] = inv[0] = 1ll;\n        for (int i = 1; i &lt;= n; ++i)\n            fac[i] = fac[i - 1] * i % mod;\n        auto qkp = [](long long x, int y) &#123;\n            auto res(1ll);\n            for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n                if (y &amp; 1)\n                    (res *= x) %= mod;\n            return res;\n        &#125;;\n        inv[n] = qkp(fac[n], mod - 2);\n        for (int i = n - 1; i; --i)\n            inv[i] = inv[i + 1] * (i + 1) % mod;\n    &#125;\n    auto A = [&amp;](int n, int m) &#123;\n        if (n &lt; m || m &lt; 0)\n            return 0ll;\n        return fac[n] * inv[n - m] % mod;\n    &#125;;\n    std::vector&lt;long long&gt; f(k + 1), g(k + 1), h(k + 1);\n    std::vector&lt;long long&gt; bit(n + 1);\n    auto lowbit = [](int x) &#123;\n        return x &amp; -x;\n    &#125;;\n    auto add = [&amp;](int x, int v) &#123;\n        for (; x &lt;= n; x += lowbit(x))\n            (bit[x] += v) %= mod;\n        return;\n    &#125;;\n    auto ask = [&amp;](int x) &#123;\n        auto res(0ll);\n        for (; x; x -= lowbit(x))\n            (res += bit[x]) %= mod;\n        return res;\n    &#125;;\n    for (int i = 1; i &lt;= n; ++i)\n        if (p[i] == k + 1)\n            add(i, 1);\n    for (int i = k; i; --i)\n        f[i] = ask(a[i]), add(a[i], 1);\n    for (int i = 1; i &lt;= k; ++i) &#123;\n        g[i] = (g[i - 1] + f[i] * A(n - i, k - i)) % mod;\n        h[i] = (h[i - 1] + f[i] * (k - i) % mod * A(n - i - 1, k - i - 1)) % mod;\n        // printf(&quot;%d: f = %lld, g = %lld, h = %lld\\n&quot;, i, f[i], g[i], h[i]);\n    &#125;\n    std::vector&lt;long long&gt; res(n + 1);\n    bit.assign(n + 1, 0ll);\n    auto s(0ll);\n    for (int i = 1; i &lt;= k; ++i) &#123;\n        // printf(&quot;%d: %lld + %lld + %lld\\n&quot;, a[i], 1 + g[k] - g[i], h[i], s - ask(a[i]));\n        res[a[i]] = (1 + g[k] - g[i] + h[i] + (s - ask(a[i]))) % mod;\n        res[a[i]] = (res[a[i]] + mod) % mod;\n        (s += A(n - i, k - i) - (k - i) * A(n - i - 1, k - i - 1)) %= mod;\n        add(a[i], (A(n - i, k - i) - (k - i) * A(n - i - 1, k - i - 1)) % mod);\n    &#125;\n    for (int i = 1; i &lt;= n; ++i)\n        if (p[i] == k + 1) &#123;\n            res[i] = (h[k] + (s - ask(i))) % mod;\n            res[i] = (res[i] + mod) % mod;\n        &#125;\n    for (int x = 1; x &lt;= n; ++x)\n        std::cout &lt;&lt; res[x] &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"c---1-loop-bubble-sort\">C - 1 Loop Bubble Sort</h2>\n<p><a href=\"https://atcoder.jp/contests/arc187/tasks/arc187_c\" class=\"uri\">https://atcoder.jp/contests/arc187/tasks/arc187_c</a></p>\n<p>é¦–å…ˆæ˜¯è¢«è€ƒçƒ‚äº†çš„ï¼šå¯¹åºåˆ—è¿›è¡Œä¸€æ¬¡å†’æ³¡æ’åºï¼Œç­‰ä»·äºå°†åºåˆ—åœ¨å‰ç¼€æœ€å¤§å€¼å¤„åˆ†æ®µï¼Œå¹¶å°†å…¶ä»æ®µé¦–ç§»åˆ°æ®µå°¾ï¼›ä¸”æ»¡è¶³æ’åºå‰ä¸ºå‰ç¼€æœ€å¤§å€¼çš„å…ƒç´ ï¼Œæ’åºåä»ä¸ºå‰ç¼€æœ€å¤§å€¼ã€‚</p>\n<p>è€ƒè™‘ç”¨ DP è§£å†³é—®é¢˜ã€‚æ³¨æ„çŠ¶æ€è¦ä» <span class=\"math inline\">\\(P\\)</span> çš„è§’åº¦å‡ºå‘â€”â€”å‡å¦‚ <span class=\"math inline\">\\(Q\\)</span> ä¸­ä¸å­˜åœ¨ <span class=\"math inline\">\\(-1\\)</span>ï¼Œå‘ç°ä¹Ÿéœ€è¦ DPã€‚æ­¤æ—¶å†è®¾è®¡æœ‰å…³ <span class=\"math inline\">\\(Q\\)</span> çš„çŠ¶æ€å°±å¾ˆæ‰¯æ·¡äº†ï¼Œè€ƒè™‘ä»¤ <span class=\"math inline\">\\(f_{i,j}\\)</span> è¡¨ç¤º <span class=\"math inline\">\\(P\\)</span> ä¸­ç›´åˆ°ç¬¬ <span class=\"math inline\">\\(i\\)</span> ä½çš„å‰ç¼€æœ€å¤§å€¼ä¸º <span class=\"math inline\">\\(j\\)</span> çš„æ–¹æ¡ˆæ•°ã€‚ä¸ºä»€ä¹ˆæŠŠå‰ç¼€æœ€å¤§å€¼ä½œä¸ºçŠ¶æ€å‘¢ï¼Ÿå› ä¸ºå®ƒå¯ä»¥è¡¨ç¤ºåˆ†æ®µï¼›åŒæ—¶é™åˆ¶æ®µé—´æ•°çš„å–å€¼ã€‚å…·ä½“åœ°ï¼Œè€ƒè™‘è½¬ç§»ï¼š</p>\n<ol type=\"1\">\n<li>è‹¥ä»¤ <span class=\"math inline\">\\(P_i=j\\)</span>ï¼Œåˆ™åœ¨ <span class=\"math inline\">\\(i\\)</span> å¤„åˆ†æ®µã€‚å¯¹åº”åˆ° <span class=\"math inline\">\\(Q\\)</span> ä¸­ï¼Œ<span class=\"math inline\">\\(i-1\\)</span> ä½æ˜¯ä¸Šä¸€ä¸ªå‰ç¼€æœ€å¤§å€¼ï¼Œé‚£ä¹ˆè¿™è¦æ±‚ <span class=\"math inline\">\\(Q_{i-1}&lt;j\\)</span>ï¼Œä¸” <span class=\"math inline\">\\(Q_{i-1}\\)</span> æ˜¯ä¸€ä¸ªå‰ç¼€æœ€å¤§å€¼ã€‚ä¹Ÿå³ï¼šå½“ <span class=\"math inline\">\\(Q_{i-1}\\ne -1\\)</span> æ—¶ï¼Œ<span class=\"math inline\">\\(f_{i,j}\\gets f_{i-1, Q_{i-1}}\\)</span>ï¼›å¦åˆ™ï¼Œ<span class=\"math inline\">\\(f_{i,j}\\gets \\sum\\limits_{k&lt;j} f_{i-1,k}\\)</span>ã€‚å…¶ä¸­ï¼ŒäºŒå¼éƒ½è¦æ±‚è½¬ç§»æ¥æºä¸ºå‰ç¼€æœ€å¤§å€¼ã€‚</li>\n<li>è‹¥ä»¤ <span class=\"math inline\">\\(P_i&lt;j\\)</span>ï¼Œåˆ™ <span class=\"math inline\">\\(i\\)</span> åœ¨ <span class=\"math inline\">\\(Q\\)</span> ä¸­æ°å¥½å‰ç§»ä¸€ä½ï¼Œå³ <span class=\"math inline\">\\(Q_{i-1}=P_i&lt;j\\)</span>ã€‚åˆ™å½“ <span class=\"math inline\">\\(Q_{i-1}\\ne -1\\)</span> æ—¶ï¼Œè¯¥ä½ç¡®å®šï¼Œ<span class=\"math inline\">\\(f_{i,j}\\gets f_{i-1,j}\\)</span>ï¼›å¦åˆ™ï¼Œ<span class=\"math inline\">\\(Q_{i-1}\\)</span> å¯é€‰çš„å€¼ä¸º <span class=\"math inline\">\\(&lt;j\\)</span> çš„æ‰€æœ‰æœªé€‰æ•°ï¼ˆå®šå€¼ï¼Œå¯é¢„å¤„ç†ï¼‰ã€‚</li>\n</ol>\n<p>å…³äºåˆå€¼ï¼Œå¯ä»¥åœ¨ <span class=\"math inline\">\\(P\\)</span> å‰åŠ ä¸€ä¸ª <span class=\"math inline\">\\(0\\)</span> ä½œä¸ºæ’åˆ—çš„ä¸€éƒ¨åˆ†ï¼ˆé‚£ä¹ˆæŒ‰ç…§å†’æ³¡æ’åºçš„è§„åˆ™ <span class=\"math inline\">\\(Q\\)</span> çš„ç¬¬ä¸€ä½ä¹Ÿä¸€å®šæ˜¯ <span class=\"math inline\">\\(0\\)</span>ï¼‰æ¥å¤„ç†å°±å¥½äº†ã€‚</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 998244353;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;int&gt; q(n + 1), t(n + 1), c(n + 1), pos(n + 1);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; q[i], c[i] = c[i - 1];\n        if (q[i] == -1)\n            ++c[i];\n        else\n            pos[q[i]] = i;\n    &#125;\n    for (int i = 1; i &lt; n; ++i) &#123;\n        // printf(&quot;t[%d] = %d\\n&quot;, i, t[i]);\n        if (!pos[i])\n            for (int j = i + 1; j &lt;= n; ++j)\n                ++t[j];\n    &#125;\n    std::vector&lt;std::vector&lt;long long&gt; &gt; f(n + 1, std::vector&lt;long long&gt; (n + 1)), s(n + 1, std::vector&lt;long long&gt; (n + 1));\n    f[0][0] = 1ll;\n    s[0].assign(n + 1, 1ll);\n    for (int i = 1; i &lt;= n; ++i)\n        for (int j = 1; j &lt;= n; ++j) &#123;\n            if (q[i - 1] == -1)\n                f[i][j] = (s[i - 1][j - 1] + f[i - 1][j] * std::max(0, 1 + t[j] - c[i - 1])) % mod;\n            else if (q[i - 1] &lt; j)\n                f[i][j] = (f[i - 1][q[i - 1]] + f[i - 1][j]) % mod;\n            s[i][j] = s[i][j - 1];\n            if (q[i] == j || !pos[j]) // æ»¡è¶³å‰ç¼€æœ€å¤§å€¼\n                (s[i][j] += f[i][j]) %= mod;\n            // printf(&quot;f[%d][%d] = %lld\\n&quot;, i, j, f[i][j]);\n        &#125;\n    std::cout &lt;&lt; f[n][n] &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"f---1.-intro\">(F - 1). Intro</h2>\n<blockquote>\n<p>ç»™å®šä¸€ä¸ªå¤§å°ä¸º <span class=\"math inline\">\\(n\\)</span> çš„æ ‘ï¼Œç‚¹æœ‰ç‚¹æƒã€‚ç»™å®š <span class=\"math inline\">\\(q\\)</span> æ¬¡æ“ä½œï¼Œåˆ†ä¸ºä¸¤ç§ï¼š</p>\n<ol type=\"1\">\n<li><code>1 x</code>ï¼šæŸ¥è¯¢ <span class=\"math inline\">\\(x\\)</span> çš„ç‚¹æƒã€‚</li>\n<li><code>2 x d v</code> å¯¹äºæ‰€æœ‰è· <span class=\"math inline\">\\(x\\)</span> ä¸è¶…è¿‡ <span class=\"math inline\">\\(d\\)</span> çš„ç‚¹ï¼Œå°†å®ƒä»¬çš„æƒå€¼åŠ ä¸Š <span class=\"math inline\">\\(v\\)</span>ã€‚</li>\n</ol>\n<p><span class=\"math inline\">\\(n,q\\le 10^5,d\\le 20\\)</span>ã€‚</p>\n</blockquote>\n<p>ç”±äº <span class=\"math inline\">\\(d\\)</span> å¾ˆå°ï¼Œæˆ‘ä»¬å¯èƒ½éœ€è¦æšä¸¾ä¸ <span class=\"math inline\">\\(x\\)</span> è·ç¦» <span class=\"math inline\">\\(0\\sim d\\)</span> çš„ç‚¹è¿›è¡Œä¿®æ”¹ï¼›é‚£ä¹ˆå¯¹è·ç¦» <span class=\"math inline\">\\(x\\)</span> ä¸º <span class=\"math inline\">\\(i\\)</span> çš„ç‚¹çš„æ›´æ”¹å­˜å‚¨åœ¨ <span class=\"math inline\">\\(f_{x,i}\\)</span>ï¼ŒæŸ¥è¯¢ <span class=\"math inline\">\\(v\\)</span> æ—¶å°±å¯ä»¥ä» <span class=\"math inline\">\\(\\sum\\limits_i f_{fa(v,i),i}\\)</span> æ±‚å¾—ç­”æ¡ˆã€‚</p>\n<p>è€ƒè™‘ä¿®æ”¹ã€‚è®° <span class=\"math inline\">\\(S_{x,d}\\)</span> ä¸ºè· <span class=\"math inline\">\\(x\\)</span> ä¸º <span class=\"math inline\">\\(d\\)</span> çš„ç‚¹é›†ã€‚<span class=\"math inline\">\\(x\\)</span> å­æ ‘å†…æ˜¯å¥½å¤„ç†çš„ï¼Œä½†å­æ ‘å¤–çš„å‘¢ï¼Ÿå‘ç° <span class=\"math inline\">\\(S_{fa,d-1}\\)</span> ä¸­ <span class=\"math inline\">\\(x\\)</span> å­æ ‘å¤–çš„ç‚¹ï¼Œå°±æ˜¯ <span class=\"math inline\">\\(fa\\)</span> å­æ ‘ä¸‹ã€<span class=\"math inline\">\\(x\\)</span> å­æ ‘å¤–è·ç¦» <span class=\"math inline\">\\(x\\)</span> ä¸º <span class=\"math inline\">\\(d\\)</span> çš„æ‰€æœ‰ç‚¹ã€‚</p>\n<p>ç”±äºæ‰€æœ‰ <span class=\"math inline\">\\(S_{fa(x,i),d-i}\\)</span> æ— äº¤ï¼Œè¿™å¯èƒ½æ»¡è¶³æˆ‘ä»¬æ¯ä¸ªå¾…æ“ä½œç‚¹è¢«ä¸é‡ä¸æ¼åŠ ä¸€æ¬¡çš„è¦æ±‚ã€‚è€ƒè™‘å°†æ‰€æœ‰ <span class=\"math inline\">\\(S_{fa(x,i),d-i}\\)</span> æ ‡è®°å‡ºæ¥ï¼š</p>\n<figure>\n<img src=\"1.png\" alt=\"ç²‰è‰²è™šçº¿æ¡†æ˜¯å¾…æ“ä½œç‚¹é›†\" /><figcaption>ç²‰è‰²è™šçº¿æ¡†æ˜¯å¾…æ“ä½œç‚¹é›†</figcaption>\n</figure>\n<p>ç„¶åæˆ‘ä»¬å¯ä»¥ä¸€çœ¼å‘ç°è¢«å‰çš„ç‚¹å’Œæœªè¢«å‰çš„å¾…æ“ä½œç‚¹æ˜¯äº¤é”™çš„ï¼è¿™æ„å‘³ç€æˆ‘ä»¬åªéœ€è¦å†è¡¥å……ä¸Šæ‰€æœ‰ <span class=\"math inline\">\\(S_{fa(x,i),d-i-1}\\)</span> å³å¯ï¼ˆæ˜¾ç„¶å®ƒä»¬ä¹‹é—´ã€å®ƒä»¬å’Œæ‰€æœ‰ <span class=\"math inline\">\\(S_{fa(x,i),d-i}\\)</span> ä¹‹é—´éƒ½ä¸äº¤ï¼‰ã€‚</p>\n<figure>\n<img src=\"2.png\" alt=\"è™šçº¿å‰ä¸º S_{fa(x,i),d-i-1}\" /><figcaption>è™šçº¿å‰ä¸º <span class=\"math inline\">\\(S_{fa(x,i),d-i-1}\\)</span></figcaption>\n</figure>\n<p>æ­¤æ—¶å°±å¯ä»¥ä¸é‡ä¸æ¼ã€‚å½“ç„¶ï¼Œä¹Ÿä¼šå­˜åœ¨ä¸€äº›ç»†èŠ‚ï¼šæ¯”å¦‚è¯´ <span class=\"math inline\">\\(fa(x,i)\\)</span> ä¸å­˜åœ¨ä¹‹ç±»ã€‚åªéœ€è¦åœ¨æ ¹èŠ‚ç‚¹ <span class=\"math inline\">\\(1\\)</span> å¤„å°†å‰©ä½™çš„ <span class=\"math inline\">\\(S_{1,i\\to 0}\\)</span> å…¨éƒ¨æ›´æ–°å³å¯ã€‚</p>\n<p>æ•…æ¯æ¬¡ä¿®æ”¹æ“ä½œåªéœ€è¦ä¿®æ”¹ <span class=\"math inline\">\\(O(d)\\)</span> å¨ç‚¹ã€‚æ—¶é—´å¤æ‚åº¦ <span class=\"math inline\">\\(O(qd)\\)</span>ã€‚</p>\n<hr />\n<h2 id=\"f.-distance-to-the-path\">F. Distance to the Path</h2>\n<p><a href=\"https://codeforces.com/problemset/problem/1749/F\" class=\"uri\">https://codeforces.com/problemset/problem/1749/F</a></p>\n<p>æœ¬ä¾‹ä¸­å°†å•ç‚¹ä¿®æ”¹æ›¿æ¢ä¸ºè·¯å¾„ä¿®æ”¹ï¼›è€ƒè™‘æ ‘å‰–è§£å†³é—®é¢˜ã€‚</p>\n<p>å¯¹äºè·¯å¾„ä¸Šçš„æ‰€æœ‰ç‚¹ <span class=\"math inline\">\\(u\\)</span>ï¼Œå®¹æ˜“å‘ç°åªéœ€è¦ä¿®æ”¹æ‰€æœ‰çš„ <span class=\"math inline\">\\(S_{u,d}\\)</span> å°±å¯ä»¥å®Œæˆå¯¹ã€<strong>ä¸€éƒ¨åˆ†è·¯å¾„å†…ä¾§çš„ç‚¹</strong>ã€çš„ä¿®æ”¹ã€‚è¿™ã€ä¸€éƒ¨åˆ†ã€ï¼Œæ˜¯å› ä¸ºä¸åŒ…æ‹¬è·ç¦» LCA <span class=\"math inline\">\\(\\le d\\)</span> çš„ç‚¹ã€‚</p>\n<p>è€Œã€<strong>å¦ä¸€éƒ¨åˆ†è·¯å¾„å†…ä¾§çš„ç‚¹</strong>ï¼ˆè· LCA <span class=\"math inline\">\\(\\le d\\)</span>ï¼šè§ä¸Šä¸€è¡Œè¯´æ˜ï¼‰ã€åŠã€<strong>è·¯å¾„å¤–ä¾§çš„ç‚¹</strong>ï¼ˆè· LCA <span class=\"math inline\">\\(\\le d\\)</span>ï¼šå› ä¸ºè·¯å¾„åœ¨ LCA å­æ ‘å†…ï¼ŒLCA èƒ½å¤Ÿåˆ°æœ€è¿œçš„å¤–ä¾§ç‚¹ï¼‰ã€ï¼Œç­‰ä»·äºã€<strong>è· LCA <span class=\"math inline\">\\(\\le d\\)</span> çš„ç‚¹</strong>ã€ï¼Œåªéœ€è¦æŠŠ LCA ä»£å…¥ä¸Šä¾‹ä¸­æ–¹å¼ä¿®æ”¹å³å¯ã€‚</p>\n<p>ä¿®æ”¹è·¯å¾„ä¸Šæ‰€æœ‰ç‚¹ <span class=\"math inline\">\\(u\\)</span> çš„ <span class=\"math inline\">\\(S_{u,d}\\)</span> æ—¶ï¼Œå¯ä»¥å¯¹æ‰€æœ‰ <span class=\"math inline\">\\(f_{*,i}\\)</span> å»ºç«‹æ•°æ®ç»“æ„ï¼Œç”±äºåªéœ€è¦åŒºé—´ä¿®æ”¹ã€å•ç‚¹æŸ¥è¯¢ï¼Œä½¿ç”¨å·®åˆ†æ ‘çŠ¶æ•°ç»„å³å¯ã€‚</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt; \nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, m;\n    std::cin &gt;&gt; n;\n    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);\n    for (int i = 1, x, y; i &lt; n; ++i) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y;\n        g[x].push_back(y), g[y].push_back(x);\n    &#125;\n    std::vector&lt;int&gt; siz(n + 1), dep(n + 1), fa(n + 1), son(n + 1);\n    std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int faa) &#123;\n        siz[x] = 1;\n        for (auto i : g[x])\n            if (i != faa) &#123;\n                fa[i] = x, dep[i] = dep[x] + 1;\n                DFS(i, x);\n                siz[x] += siz[i];\n                if (siz[i] &gt; siz[son[x]])\n                    son[x] = i;\n            &#125;\n        return;\n    &#125;;\n    DFS(1, -1);\n    std::vector&lt;int&gt; dfn(n + 1), top(n + 1);\n    DFS = [&amp;](int x, int toop) &#123;\n        static int now = 0;\n        dfn[x] = ++now, top[x] = toop;\n        if (son[x])\n            DFS(son[x], toop);\n        for (auto i : g[x])\n            if (i != fa[x] &amp;&amp; i != son[x])\n                DFS(i, i);\n        return;\n    &#125;;\n    DFS(1, 1);\n    std::vector&lt;std::vector&lt;long long&gt; &gt; bit(21, std::vector&lt;long long&gt; (n + 1));\n    auto lowbit = [&amp;](int x) &#123;\n        return x &amp; -x;\n    &#125;;\n    auto add = [&amp;](auto &amp;bit, int x, int v) &#123;\n        for (; x &lt;= n; x += lowbit(x))\n            bit[x] += v;\n        return;\n    &#125;;\n    auto ask = [&amp;](auto &amp;bit, int x) &#123;\n        auto res(0ll);\n        for (; x; x -= lowbit(x))\n            res += bit[x];\n        return res;\n    &#125;;\n    std::cin &gt;&gt; m;\n    for (int op; m--; ) &#123;\n        std::cin &gt;&gt; op;\n        if (op == 1) &#123;\n            int x;\n            std::cin &gt;&gt; x;\n            auto res(0ll);\n            for (int i = 0; i &lt;= 20 &amp;&amp; x; ++i, x = fa[x])\n                res += ask(bit[i], dfn[x]);\n            std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n        &#125;\n        else &#123;\n            int x, y, v, d;\n            std::cin &gt;&gt; x &gt;&gt; y &gt;&gt; v &gt;&gt; d;\n            for (; top[x] != top[y]; x = fa[top[x]]) &#123;\n                if (dep[top[x]] &lt; dep[top[y]])\n                    std::swap(x, y);\n                add(bit[d], dfn[top[x]], v);\n                add(bit[d], dfn[x] + 1, -v);\n            &#125;\n            if (dep[x] &gt; dep[y])\n                std::swap(x, y);\n            add(bit[d], dfn[x] + 1, v), add(bit[d], dfn[y] + 1, -v);\n            for (x = x, y = d; ~y &amp;&amp; x; x = fa[x], --y) &#123;\n                add(bit[y], dfn[x], v), add(bit[y], dfn[x] + 1, -v);\n                if (y &amp;&amp; fa[x])\n                    add(bit[y - 1], dfn[x], v), add(bit[y - 1], dfn[x] + 1, -v);\n            &#125;\n            if (x == 0)\n                for (; ~y; --y)\n                    add(bit[y], dfn[1], v), add(bit[y], dfn[1] + 1, -v);\n        &#125;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"a---ina-of-the-mountain\">A - Ina of the Mountain</h2>\n<p><a href=\"https://codeforces.com/problemset/problem/1852/C\" class=\"uri\">https://codeforces.com/problemset/problem/1852/C</a></p>\n<p>è€ƒè™‘è¿™ä¹ˆä¸€ä¸ªç®€åŒ–ç‰ˆçš„é—®é¢˜ï¼š</p>\n<blockquote>\n<p>ç»™å®š <span class=\"math inline\">\\(\\{a_n\\}\\)</span>ï¼Œæ¯æ¬¡å¯ä»¥è¿›è¡ŒåŒºé—´ <span class=\"math inline\">\\(-1\\)</span>ï¼Œé—®æ“ä½œå¤šå°‘æ¬¡æ‰èƒ½å°†æ‰€æœ‰å…ƒç´ å˜ä¸º <span class=\"math inline\">\\(0\\)</span>ã€‚</p>\n</blockquote>\n<p>ä¼šæƒ³åˆ°å·®åˆ†ï¼›å¯¹åŸæ•°ç»„è¿›è¡Œå·®åˆ†ï¼Œä¸€æ¬¡æ“ä½œç›¸å½“äºä»¤ <span class=\"math inline\">\\(d_l\\gets d_l-1\\)</span> è€Œ <span class=\"math inline\">\\(d_{r+1}\\gets d_{r+1}+1\\)</span>ï¼Œæœ€åè¦è®© <span class=\"math inline\">\\(\\forall \\,d_i=0\\)</span>ã€‚é‚£ä¹ˆç­”æ¡ˆå°±æ˜¯å·®åˆ†æ•°ç»„ä¸­æ­£æ•°ä¹‹å’Œå˜›ã€‚</p>\n<p>å›åˆ°åŸé—®é¢˜ã€‚åŸé—®é¢˜ç­‰ä»·äºæŠŠä¸Šè¿°é—®é¢˜å˜ä¸ºï¼š</p>\n<blockquote>\n<p>ç»™å®š <span class=\"math inline\">\\(\\{a_n\\}\\)</span>ï¼Œæ¯æ¬¡å¯ä»¥è¿›è¡ŒåŒºé—´ <span class=\"math inline\">\\(-1\\)</span>ï¼Œæ¯ä¸ªæ•°çš„æ€»æ“ä½œæ¬¡æ•°å¯¹ <span class=\"math inline\">\\(k\\)</span> å–æ¨¡ï¼Œé—®æ“ä½œå¤šå°‘æ¬¡æ‰èƒ½å°†æ‰€æœ‰å…ƒç´ å˜ä¸º <span class=\"math inline\">\\(0\\)</span>ã€‚</p>\n</blockquote>\n<p>æ€ä¹ˆå¥—å›åˆ°åˆšåˆšçš„é—®é¢˜ä¸Šå‘¢ï¼Ÿè¿˜åŸè¢«å–æ¨¡æ‰çš„æ“ä½œå³å¯ã€‚å…·ä½“æ¥è¯´ï¼Œæå‰åœ¨ <span class=\"math inline\">\\(d\\)</span> ä¸Šè¿›è¡Œè‹¥å¹²æ¬¡æ“ä½œï¼ˆè®°ä¸ºæ“ä½œ 1ï¼‰ï¼Œå½¢å¦‚ä»¤ <span class=\"math inline\">\\(d_i\\gets d_i+k\\)</span>ï¼ŒåŒæ—¶ <span class=\"math inline\">\\(d_{i+1}\\gets d_{i+1}-k\\)</span>ã€‚</p>\n<p>ä¼šå‘ç°ç›¸é‚»çš„æ“ä½œ <span class=\"math inline\">\\(1\\)</span> å¯¹ä¸€ä¸ªæ•°åŠ åŠ å‡å‡å½±å“åˆ¤æ–­ï¼›å‘ç°å¯ä»¥åˆå¹¶ä¸€æ®µè¿ç»­çš„æ“ä½œ 1ï¼Œè¡¨ç°åœ¨ <span class=\"math inline\">\\(a\\)</span> ä¸Šä¹Ÿå°±æ˜¯åŒºé—´ <span class=\"math inline\">\\(+k\\)</span>ã€‚æ­¤æ—¶å¯ä»¥å‘ç°ï¼Œä¸€ä¸ªä½ç½®ä¸Šåªä¼šå‰©ä¸‹è‹¥å¹²æ¬¡ <span class=\"math inline\">\\(+k\\)</span> æˆ–è‹¥å¹²æ¬¡ <span class=\"math inline\">\\(-k\\)</span> ï¼ˆå¦åˆ™å¯ä»¥æŠŠ <span class=\"math inline\">\\(+k\\)</span> å’Œ <span class=\"math inline\">\\(-k\\)</span> ä»£è¡¨çš„ä¸åŒæ“ä½œåˆå¹¶ï¼‰ï¼Œå°±ä¸ä¼šæœ‰äº’ç›¸å½±å“ä¸€è¯´äº†ã€‚è¿™ä¹Ÿæ˜¯æœ‰çš„é¢˜è§£è¯´å¯ä»¥æå‰åœ¨ <span class=\"math inline\">\\(a\\)</span> ä¸ŠåŒºé—´ <span class=\"math inline\">\\(+k\\)</span> çš„åŸå› ã€‚</p>\n<p>æ­¤æ—¶é—®é¢˜å˜ä¸ºåœ¨ <span class=\"math inline\">\\(d\\)</span> è¿›è¡Œä»»æ„æ¬¡å‰åŠ  <span class=\"math inline\">\\(k\\)</span> åå‡ <span class=\"math inline\">\\(k\\)</span> çš„æ“ä½œï¼Œä½¿å¾— <span class=\"math inline\">\\(\\sum\\limits_{d_i&gt;0}d_i\\)</span> æœ€å¤§åŒ–ã€‚é‚£ä¹ˆæ˜¾ç„¶å¦‚æœè¦ä½¿ä»£ä»·æ›´å°ï¼Œåªå¯èƒ½åœ¨åŸæœ¬ <span class=\"math inline\">\\(&lt;0\\)</span> çš„ä½ç½®åšåŠ æ³•ã€<span class=\"math inline\">\\(&gt;0\\)</span> çš„ä½ç½®åšå‡æ³•ï¼ˆå…¶ä»–æƒ…å†µä¼šå‘ç°ä¸€å®šä¸ä¼˜ï¼‰ã€‚è€ƒè™‘ä¸¤ä¸ªæ•° <span class=\"math inline\">\\(d_l,d_r\\)</span>ï¼Œå¯ä»¥æ„Ÿå—åˆ°å¯¹äºä¸€ä¸ª <span class=\"math inline\">\\(r\\)</span>ï¼Œé€‰æœ€å°çš„ <span class=\"math inline\">\\(d_l\\)</span> æ˜¯æœ€ä¼˜çš„ï¼Œä½†ä»€ä¹ˆæ—¶å€™åº”è¯¥é€‰å‘¢ï¼Ÿ</p>\n<ul>\n<li><span class=\"math inline\">\\(d_l\\le -k,d_r\\ge k\\)</span>ï¼šå½“ç„¶å¯é€‰ï¼Œ<span class=\"math inline\">\\(k\\)</span> è¢«å®Œå…¨åˆ©ç”¨ï¼Œç­”æ¡ˆå‡å°‘ <span class=\"math inline\">\\(k\\)</span>ã€‚</li>\n<li><p><span class=\"math inline\">\\(d_l&gt;-k,d_r\\ge k\\)</span>ï¼šæ­¤æ—¶ <span class=\"math inline\">\\(k\\)</span> æœªè¢«å®Œå…¨åˆ©ç”¨ï¼Œä½†å¿…é¡»é€‰ï¼šé€‰æ‹©å…¶ä»–æ›´å¤§çš„æ•°ï¼Œ<span class=\"math inline\">\\(k\\)</span> çš„åˆ©ç”¨ç‡åªä¼šæ›´ä½ï¼›å¦‚æœä¸é€‰ï¼Œç­”æ¡ˆä¹Ÿæ— æ³•å‡å°‘ã€‚</p>\n<p>Qï¼šæ­¤æ—¶æ˜¯å¦éœ€è¦å°è¯•æ‰¾åˆ°ä¸€ä¸ª <span class=\"math inline\">\\(l&#39;&lt;l\\)</span> ä¸ <span class=\"math inline\">\\(l\\)</span> åšæ“ä½œï¼Œä½¿å¾— <span class=\"math inline\">\\(l\\)</span> é‡æ–°å˜ä¸ºè´Ÿæ•°å‘¢ï¼Ÿ</p>\nAï¼šå¦ã€‚å› ä¸ºä½ å¯ä»¥å°†è¿™ä¸¤æ¬¡æ“ä½œåˆå¹¶ï¼Œå‘ç°ç›¸å½“äºæ˜¯ç›´æ¥å¯¹ <span class=\"math inline\">\\((l&#39;,r)\\)</span> åšæ“ä½œï¼Œæ˜¯æ›´åŠ£çš„ã€‚</li>\n<li><span class=\"math inline\">\\(d_l\\le -k,d_r&lt;k\\)</span>ï¼šæ­¤æ—¶ <span class=\"math inline\">\\(k\\)</span> æœªè¢«å®Œå…¨åˆ©ç”¨ï¼Œ<span class=\"math inline\">\\(d_r\\)</span> æˆä¸ºè´Ÿæ•°ã€‚è¿™æ„å‘³ç€ <span class=\"math inline\">\\(d_r\\)</span> å°†ä¼šæˆä¸ºæŸä¸ª <span class=\"math inline\">\\(r&#39;\\)</span> çš„å¯é€‰é¡¹ã€‚è€ƒå¯Ÿ <span class=\"math inline\">\\(d_{r&#39;}\\)</span> å¯ç”¨çš„æœ€å°å€¼ã€‚å¦‚æœ <span class=\"math inline\">\\(d_r\\)</span> åœ¨å½“å‰ä¸åº”è¯¥ä½œä¸ºå³ç«¯ç‚¹ï¼Œå®ƒå°±ä¸€å®šä¼šè¢« <span class=\"math inline\">\\(d_{r&#39;}\\)</span> é€‰æ‹©ã€‚å…·ä½“çš„æœ‰ç‚¹æŠ½è±¡ï¼Œä½†æ˜¯ä½ å¯ä»¥ç†è§£ä¸º <span class=\"math inline\">\\(d_r\\)</span> é€‰äº† <span class=\"math inline\">\\(d_l\\)</span> çš„è´¡çŒ®æ˜¯è¢«æ•´åˆåˆ° <span class=\"math inline\">\\(d_r\\)</span> é‡Œçš„ï¼›å¦‚æœ <span class=\"math inline\">\\(d_r\\)</span> è¢«é€‰äº†å°±è¯´æ˜ <span class=\"math inline\">\\(d_{r&#39;}\\)</span> é€‰ <span class=\"math inline\">\\(d_l\\)</span> ä¼šæ‹¥æœ‰æ›´å¤§çš„ä¼˜åŠ¿ã€‚</li>\n<li><p><span class=\"math inline\">\\(d_l&gt;-k,d_r&lt;k\\)</span>ï¼šå’Œä¸Šé¢çš„æƒ…å†µç›¸ä¼¼ï¼›ä½†è¿™ç§æƒ…å†µä¸‹ç­”æ¡ˆå¯èƒ½åè€Œå˜å¾—æ›´å¤§ï¼Œå› ä¸ºæ²¡æœ‰åæ•ˆæ€§ï¼Œæ‰€ä»¥è‡³å°‘è¦ä¿è¯å•æ­¥æœ€ä¼˜ã€‚æ­¤æ—¶ä¸èƒ½é€‰ã€‚</p>\n<p>è¯´åˆ°å•æ­¥æœ€ä¼˜ï¼Œå°±ä¼šå‘ç°è¿™é‡Œå°±æ˜¯åæ‚”è´ªå¿ƒï¼›å•æ­¥æœ€ä¼˜ä¸€å®šæ˜¯å…¨å±€æœ€ä¼˜ï¼Œä½†æ›´é å‰çš„å±€éƒ¨æœ€ä¼˜å¯èƒ½è¢«å¦å®šæ‰ã€‚è€Œã€å¦å®šã€çš„æ–¹æ³•è¡¨ç°ä¸ºä¸€æ¬¡æ“ä½œã€‚</p></li>\n</ul>\n<p>ç»¼ä¸Šï¼Œä»å‰å¾€åæ‰«ï¼Œä¼˜å…ˆé˜Ÿåˆ—å®æ—¶ç»´æŠ¤è´Ÿæ•°æœ€å°å€¼ï¼Œå¯¹äºæ¯ä¸ªæ­£æ•°ï¼Œcheck é€‰æœ€å°å€¼æ˜¯å¦ä¼˜äºå½“å‰ç­”æ¡ˆï¼Œæœ‰å°±é€‰ã€‚å¦‚æœæ­£æ•°è¢«å‡ä¸ºè´Ÿï¼ŒåŠ å…¥é˜Ÿåˆ—ã€‚</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int T;\n    for (std::cin &gt;&gt; T; T--; ) &#123;\n        int n, k;\n        std::cin &gt;&gt; n &gt;&gt; k;\n        std::vector&lt;int&gt; a(n + 1), d(n + 1);\n        long long res(0ll);\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            std::cin &gt;&gt; a[i], a[i] %= k;\n            d[i] = a[i] - a[i - 1];\n            if (d[i] &gt; 0)\n                (res += d[i]);\n        &#125;\n        std::priority_queue&lt;int&gt; q;\n        for (int i = 1; i &lt;= n; ++i)\n            if (d[i] &lt; 0)\n                q.push(-d[i]);\n            else &#123;\n                for (; !q.empty() &amp;&amp; d[i] &gt; 0; ) &#123;\n                    int x = -q.top(), y = d[i];\n                    auto t(res - y);\n                    x += k, y -= k;\n                    if (x &gt; 0)\n                        t += x;\n                    if (y &gt; 0)\n                        t += y;\n                    if (t &gt;= res)\n                        break;\n                    q.pop();\n                    res = t, d[i] = y;\n                    if (d[i] &lt; 0)\n                        q.push(-d[i]);\n                &#125;\n            &#125;\n        std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"b---miriany-and-matchstick\">B - Miriany and Matchstick</h2>\n<p><a href=\"https://codeforces.com/problemset/problem/1852/D\" class=\"uri\">https://codeforces.com/problemset/problem/1852/D</a></p>\n<p>ä»æ„é€ çš„è§’åº¦å‡ºå‘ï¼Œçœ‹åˆ°ã€æ°å¥½ä¸º <span class=\"math inline\">\\(k\\)</span>ã€ï¼Œä¼šæƒ³åˆ°æ‰¾åˆ°ä¸Šç•Œå’Œä¸‹ç•Œå¹¶è¯æ˜ä¸­é—´æ¯ä¸€ä¸ªæ•°éƒ½èƒ½å–åˆ°ã€‚</p>\n<p>ä½†ä¼¼ä¹å¾ˆå®¹æ˜“è¯ä¼ªï¼šä¾‹å¦‚å¯¹äº <code>AAAA</code>ï¼Œä¸‹ç•Œä¸º <span class=\"math inline\">\\(0\\)</span>ï¼Œä¸Šç•Œä¸º <span class=\"math inline\">\\(4\\)</span>ï¼Œä½†æœ‰ä¸”ä»…æœ‰ <span class=\"math inline\">\\(1\\)</span> å–ä¸åˆ°ã€‚ä½†è¯¥æƒ³æ³•å¹¶æœªç ´äº§â€”â€”å¯ä»¥æ„Ÿå—åˆ°è¿™æ ·çš„ä½ç½®å¾ˆå°‘ã€‚è¿›ä¸€æ­¥åœ°ï¼Œä½  <a href=\"https://www.luogu.com.cn/article/2mmg5rjd\">å¯ä»¥è¯æ˜åªæœ‰ä¸€ä¸ªè¿™æ ·çš„ä½ç½®</a>ï¼Œä¹Ÿå¯ä»¥ <a href=\"https://www.luogu.com.cn/article/679cwjgl\">å¤§èƒ†çŒœæƒ³è¿™æ ·çš„ä½ç½®ä¸€å®šå‡ºç°åœ¨ <span class=\"math inline\">\\(l+1\\)</span>ï¼Œ<span class=\"math inline\">\\(r-1\\)</span></a>ã€‚æ€»ä¹‹ç°åœ¨æˆ‘ä»¬çš„çŠ¶æ€å°±å‡å°‘äº†ï¼ˆæˆ–è€…è¯´çŠ¶æ€å˜æˆ DP å€¼äº†ï¼‰ã€‚é¢„å¤„ç†å‡ºè¿™ä¸ªä¸œè¥¿ä¹‹åå¤§åŠ›æœç´¢æ‰¾æ–¹æ¡ˆå³å¯ã€‚</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int T;\n    for (std::cin &gt;&gt; T; T--; ) &#123;\n        int n, k;\n        std::cin &gt;&gt; n &gt;&gt; k;\n        std::vector&lt;int&gt; a(n + 1);\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            char t;\n            std::cin &gt;&gt; t, a[i] = (t == &#39;A&#39;);\n            if (i &gt;= 2)\n                k -= (a[i] ^ a[i - 1]);\n        &#125;\n        std::vector&lt;std::array&lt;std::tuple&lt;int, int, int&gt;, 2&gt; &gt; f(n + 1);\n        f[n][0] = &#123; a[n], a[n], 0 &#125;, f[n][1] = &#123; !a[n], !a[n], 0 &#125;;\n        auto merge = [&amp;](int i, int l0, int r0, int p0, int l1, int r1, int p1) &#123;\n            if (l0 &gt; l1)\n                std::swap(l0, l1), std::swap(r0, r1), std::swap(p0, p1);\n            int l = l0, r = std::max(r0, r1), p = 0;\n            if (!p0 &amp;&amp; !p1) &#123;\n                if (r0 &lt; l1 - 1)\n                    assert(r0 == l1 - 2), p = r0 + 1;\n                else;\n            &#125;\n            else if (p0 &amp;&amp; p1) &#123;\n                if (p0 == p1)\n                    p = p0;\n                else &#123;\n                    int tag0 = (l1 &lt;= p0 &amp;&amp; p0 &lt;= r1), tag1 = (l0 &lt;= p1 &amp;&amp; p1 &lt;= r0);\n                    if (!tag0 &amp;&amp; !tag1);\n                    else if (!tag0)\n                        p = p0;\n                    else if (!tag1)\n                        p = p1;\n                    else;\n                &#125;\n            &#125;\n            else if (p0) &#123;\n                if (l1 &lt;= p0 &amp;&amp; p0 &lt;= r1);\n                else\n                    p = p0;\n            &#125;\n            else &#123;\n                if (l0 &lt;= p1 &amp;&amp; p1 &lt;= r0);\n                else\n                    p = p1;\n            &#125;\n            assert(p != l &amp;&amp; p != r &amp;&amp; l &lt;= r);\n            return std::make_tuple(l, r, p);\n        &#125;;\n        for (int i = n - 1; i; --i) &#123;\n            &#123;\n                auto [l0, r0, p0] = f[i + 1][0];\n                auto [l1, r1, p1] = f[i + 1][1];\n                if (a[i]) &#123;\n                    ++l0, ++r0, ++l1, ++r1;\n                    if (p0) ++p0;\n                    if (p1) ++p1;\n                &#125;\n                ++l1, ++r1;\n                if (p1) ++p1;\n                f[i][0] = merge(i, l0, r0, p0, l1, r1, p1);\n            &#125;\n            &#123;\n                auto [l0, r0, p0] = f[i + 1][0];\n                auto [l1, r1, p1] = f[i + 1][1];\n                if (!a[i]) &#123;\n                    ++l0, ++r0, ++l1, ++r1;\n                    if (p0) ++p0;\n                    if (p1) ++p1;\n                &#125;\n                ++l0, ++r0;\n                if (p0) ++p0;\n                f[i][1] = merge(i, l0, r0, p0, l1, r1, p1);\n            &#125;\n        &#125;\n        std::vector&lt;int&gt; res(n + 1);\n        std::function&lt;bool(int, int, int)&gt; DFS = [&amp;](int x, int cnt, int la) &#123;\n            if (x == n + 1)\n                return cnt == k;\n            auto [l0, r0, p0] = f[x][0];\n            auto [l1, r1, p1] = f[x][1];\n            if (cnt + (la == 1) + l0 &lt;= k &amp;&amp; cnt + (la == 1) + r0 &gt;= k &amp;&amp; (!p0 || cnt + (la == 1) + p0 != k) &amp;&amp; DFS(x + 1, cnt + (la == 1) + a[x], 0))\n                res[x] = 0;\n            else if (cnt + !la + l1 &lt;= k &amp;&amp; cnt + !la + r1 &gt;= k &amp;&amp; (!p1 || cnt + !la + p1 != k) &amp;&amp; DFS(x + 1, cnt + !la + !a[x], 1))\n                res[x] = 1;\n            else\n                return false;\n            return true;\n        &#125;;\n        if (DFS(1, 0, -1)) &#123;\n            std::cout &lt;&lt; &quot;YES\\n&quot;;\n            for (int i = 1; i &lt;= n; ++i)\n                std::cout &lt;&lt; (res[i] ? &#39;A&#39; : &#39;B&#39;);\n            std::cout &lt;&lt; &#39;\\n&#39;;\n        &#125;\n        else\n            std::cout &lt;&lt; &quot;NO\\n&quot;;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n",
            "tags": [
                "DP",
                "å®¹æ–¥åŸç†",
                "æ ‘é“¾å‰–åˆ†",
                "åæ‚”è´ªå¿ƒ"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20241021-1/",
            "url": "https://xsc062.netlify.app/20241021-1/",
            "title": "é•¿é“¾å‰–åˆ† å­¦ä¹ ç¬”è®°",
            "date_published": "2024-10-21T08:33:47.000Z",
            "content_html": "<p><em>åŠç«¯ãªç”Ÿå‘½ã®é–¢æ•°ã‚’ / å°‘ã€…ã“ã“ã‚‰ã§ã‚ªãƒ¼ãƒãƒ¼ãƒ©ã‚¤ãƒ‰</em></p>\n<span id=\"more\"></span>\n<hr />\n<h2 id=\"å†…å®¹-æ€§è´¨\">å†…å®¹ &amp; æ€§è´¨</h2>\n<p>æŠŠé‡é“¾å‰–åˆ†é€‰çš„ siz æœ€å¤§çš„å„¿å­æ¢æˆé«˜åº¦æœ€å¤§çš„å„¿å­å°±æ˜¯é•¿å‰–äº†ã€‚åŒæ ·å…·æœ‰ä¸€äº›ç¾å¦™çš„æ€§è´¨ã€‚</p>\n<ul>\n<li><p>ä»»æ„ç‚¹åˆ°æ ¹èŠ‚ç‚¹ç»è¿‡çš„é“¾æ•°æœ€åŠ£ä¸º <span class=\"math inline\">\\(\\sqrt n\\)</span>ã€‚</p>\n<p>è€ƒè™‘æ„é€ ä¸€æ¡ç»è¿‡äº† <span class=\"math inline\">\\(\\sqrt n+1\\)</span> æ¡é“¾çš„è·¯å¾„ï¼Œå‘ç°æ„é€ ä¸å‡ºæ¥ã€‚å¾—è¯ã€‚ï¼ˆï¼Ÿï¼‰</p>\nè¿™ç‚¹ä¹Ÿå†³å®šäº†é•¿å‰–å’Œé‡å‰–èµ°çš„ä¸æ˜¯ä¸€æ¡èµ›é“ï¼Œæ›´å¤šçš„æ˜¯å¤„ç†ä¸€äº›å’Œæ·±åº¦æœ‰å…³çš„åœºæ™¯ä¸‹çš„é—®é¢˜ã€‚ç”¨æ³•æœ‰ç‚¹åƒ dsu on treeã€‚</li>\n<li><p>ä»»æ„ç‚¹ <span class=\"math inline\">\\(x\\)</span> çš„ <span class=\"math inline\">\\(k\\)</span> çº§ç¥–å…ˆ <span class=\"math inline\">\\(fa\\)</span> æ‰€åœ¨é“¾é•¿ <span class=\"math inline\">\\(\\ge k\\)</span>ã€‚</p>\n<p>è€ƒè™‘åè¯ã€‚è‹¥ <span class=\"math inline\">\\(fa\\)</span> æ‰€åœ¨é“¾é•¿åº¦ <span class=\"math inline\">\\(&lt;k\\)</span>ï¼Œåˆ™ <span class=\"math inline\">\\(fa\\to x\\)</span> æ›´ä¼˜ï¼ŒçŸ›ç›¾ã€‚æ•…åŸå‘½é¢˜æˆç«‹ã€‚</p></li>\n</ul>\n<hr />\n<h2 id=\"æ±‚-k-çº§ç¥–å…ˆ\">æ±‚ k çº§ç¥–å…ˆ</h2>\n<p>é•¿å‰–çš„ä¸€ä¸ªå…¸å‹åº”ç”¨æ˜¯ <span class=\"math inline\">\\(O(n\\log n)-O(1)\\)</span> æ±‚ <span class=\"math inline\">\\(k\\)</span> çº§ç¥–å…ˆã€‚å…ˆè€ƒè™‘ç›¸å¯¹æš´åŠ›çš„åšæ³•ï¼Œå¯ä»¥ <span class=\"math inline\">\\(O(n\\sqrt n)\\)</span> é¢„å¤„ç†æ¯ä¸ªç‚¹çš„ <span class=\"math inline\">\\(1\\sim \\sqrt n\\)</span> çº§ç¥–å…ˆç„¶åå—é—´å—å†…éšä¾¿è·³ä¸€è·³å°±æ˜¯ <span class=\"math inline\">\\(O(\\sqrt n)\\)</span> çš„å•æ¬¡æŸ¥è¯¢äº†ã€‚</p>\n<p>æŠŠè¿™ä¸ªæš´åŠ›ç»“åˆã€Œä»»æ„ç‚¹ <span class=\"math inline\">\\(k\\)</span> çº§ç¥–å…ˆæ‰€åœ¨é“¾é•¿ <span class=\"math inline\">\\(\\ge k\\)</span>ã€çš„æ€§è´¨ï¼Œä»¤ <span class=\"math inline\">\\(r=\\dfrac k2\\)</span>ï¼Œé‚£ä¹ˆ <span class=\"math inline\">\\(x\\)</span> çš„ <span class=\"math inline\">\\(r\\)</span> çº§ç¥–å…ˆæ‰€åœ¨é“¾é•¿ <span class=\"math inline\">\\(\\ge r\\)</span>ã€‚å‡è®¾æˆ‘ä»¬ç°åœ¨å·²ç»çŸ¥é“ <span class=\"math inline\">\\(r\\)</span> çº§ç¥–å…ˆ <span class=\"math inline\">\\(fa_r\\)</span>ï¼Œé¢„å¤„ç†å‡ºé“¾å†…ç‚¹åºåˆ—ã€é“¾é¡¶å‘ä¸Šçš„é“¾é•¿ä¸ªç¥–å…ˆï¼ˆå‡æ‘Š <span class=\"math inline\">\\(O(n)\\)</span>ï¼‰ï¼Œå°±å¯ä»¥ <span class=\"math inline\">\\(O(1)\\)</span> è®¿é—® <span class=\"math inline\">\\(fa_k\\)</span>ã€‚</p>\n<p>æ€ä¹ˆæ‰¾åˆ° <span class=\"math inline\">\\(fa_r\\)</span> å‘¢ï¼Ÿè¿™çœ‹ä¼¼æ˜¯é€’å½’çš„é—®é¢˜ï¼Œå®é™…ä¸Šå‘ç° <span class=\"math inline\">\\(r\\)</span> çš„å–å€¼åªéœ€ <span class=\"math inline\">\\(\\ge \\dfrac k2\\)</span>ï¼Œå¯¹äº <span class=\"math inline\">\\(1\\sim n\\)</span> çš„æ¯ä¸€ä¸ª <span class=\"math inline\">\\(k\\)</span>ï¼Œæ‰¾åˆ°å…¶æœ€é«˜äºŒè¿›åˆ¶ä½ <span class=\"math inline\">\\(r\\)</span>ï¼ˆæ˜¾ç„¶ <span class=\"math inline\">\\(r\\)</span> çš„å¯èƒ½å–å€¼æœ‰ <span class=\"math inline\">\\(\\log n\\)</span> ç§ï¼‰ï¼Œå¯¹äºæ¯ä¸ªç‚¹ï¼Œé¢„å¤„ç†å‡ºå…¶ <span class=\"math inline\">\\(\\log n\\)</span> ä¸ªä¸åŒçš„ <span class=\"math inline\">\\(r\\)</span> çº§ç¥–å…ˆã€‚è¿™ä¸ªå°±æ˜¯å€å¢äº†ã€‚</p>\n<details>\n<pre class=\"cpp\"><code>for (int i = 1, mx = 0; i &lt;= n; ++i) &#123;\n    if (i &gt;= (1 &lt;&lt; mx) * 2)\n        ++mx;\n    to[i] = mx;\n&#125;\nstd::vector&lt;std::array&lt;int, 21&gt; &gt; fa(n + 1);\nstd::vector&lt;int&gt; h(n + 1, 1), son(n + 1), dep(n + 1);\nh[0] = 0;\nstd::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;\n    for (auto i : g[x])\n        if (i != fa[x][0]) &#123;\n            fa[i][0] = x;\n            for (int j = 1; j &lt;= 20; ++j)\n                fa[i][j] = fa[fa[i][j - 1]][j - 1];\n            dep[i] = dep[x] + 1;\n            DFS(i);\n            if (h[i] &gt;= h[son[x]])\n                son[x] = i, h[x] = h[i] + 1;\n        &#125;\n    return;\n&#125;;\ndep[1] = 1, DFS(1);\nstd::vector&lt;int&gt; top(n + 1), id(n + 1);\nstd::vector&lt;std::vector&lt;int&gt; &gt; anc(n + 1), des(n + 1, std::vector&lt;int&gt; (1));\nstd::function&lt;void(int, int)&gt; DFS1 = [&amp;](int x, int toq) &#123;\n    top[x] = toq;\n    if (son[x])\n        DFS1(son[x], toq);\n    for (auto i : g[x])\n        if (i != fa[x][0] &amp;&amp; i != son[x])\n            DFS1(i, i);\n    des[toq].push_back(x);\n    id[x] = (int)des[toq].size() - 1;\n    if (x == toq) &#123;\n        anc[x].push_back(x);\n        for (int j = 1, now = x; j &lt;= id[x]; ++j, now = fa[now][0])\n            anc[x].push_back(fa[now][0]);\n    &#125;\n    return;\n&#125;;\nDFS1(1, 1);\nauto ask = [&amp;](int x, int k) &#123;\n    int x1 = x;\n    if (!k)\n        return x;\n    x = fa[x][to[k]];\n    if (dep[x] - dep[top[x]] &gt;= k - (1 &lt;&lt; to[k]))\n        return des[top[x]][id[x] + k - (1 &lt;&lt; to[k])];\n    return anc[top[x]][k - (1 &lt;&lt; to[k]) - (dep[x] - dep[top[x]])];\n&#125;;</code></pre>\n</details>\n<hr />\n<h2 id=\"ä¼˜åŒ–-dp\">ä¼˜åŒ– DP</h2>\n<blockquote>\n<p>ylyï¼šç®¡å®ƒè¿™é‚£çš„ï¼Œåªè¦æ˜¯æœ‰å…³æ·±åº¦ç›´æ¥ä¸Šé•¿å‰–å°±æ˜¯äº†ã€‚</p>\n</blockquote>\n<p>å’Œ DSU on tree ç±»ä¼¼ï¼Œä¸»è¦åˆ©ç”¨æ¯æ¡é“¾åªä¼šè¢«ç®—ä¸€æ¬¡å®ç° <span class=\"math inline\">\\(O(n)\\)</span> DPã€‚å…·ä½“åœ°ï¼Œå°½å¯èƒ½åœ°ã€ç»§æ‰¿ã€é•¿é“¾çš„ä¿¡æ¯ï¼Œã€çŸ­é“¾ã€åˆ™æš´åŠ›åˆå¹¶ã€‚</p>\n<p>å€¼å¾—æ³¨æ„çš„æ˜¯ï¼Œä¸€èˆ¬ã€æ·±åº¦ã€è¿™ä¸€ç»´ä¿¡æ¯ä¼šä»¥ã€ä¸ <span class=\"math inline\">\\(u\\)</span> çš„è·ç¦»ã€çš„å½¢å¼ï¼Œç»“åˆæŒ‡é’ˆæ¥ç»´æŠ¤ï¼ˆå› ä¸ºç›´æ¥è®°å½•æ·±åº¦ä¼šæ›´å²ï¼‰ã€‚</p>\n<p>å…·ä½“åœ°ï¼Œç”¨ä¸€ä¸ªå…¨å±€å¤§æ•°ç»„å®¹çº³æ‰€æœ‰ä¿¡æ¯ï¼Œä¸ºæ¯ä¸ªç‚¹åˆ†é…ç›¸åº”çš„æ•°ç»„å¤´æŒ‡é’ˆã€‚æ­£å¸¸æƒ…å†µä¸‹éœ€è¦ç”¨åˆ°çš„å…ƒç´ æœ€å¤šä¸º <span class=\"math inline\">\\(2n\\)</span>ï¼Œä½†å¦‚æœå­˜åœ¨ä¸€äº›è¯¡å¼‚çš„å‰ç§»åç§»æ“ä½œå°±å¦å½“åˆ«è®ºäº†ã€‚</p>\n<hr />\n<h3 id=\"p5904-poi-2014-hot-hotels-åŠ å¼ºç‰ˆ\">P5904 [POI 2014] HOT-Hotels åŠ å¼ºç‰ˆ</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P5904\" class=\"uri\">https://www.luogu.com.cn/problem/P5904</a></p>\n<p>é¦–å…ˆ <del>ä¸éš¾</del> å¾—åˆ° <span class=\"math inline\">\\(O(n^2)\\)</span> åšæ³•ï¼šæ˜¾ç„¶å­˜åœ¨ä¸€ä¸ªç‚¹åˆ°ä¸‰ä¸ªç‚¹è·ç¦»ç›¸ç­‰ã€‚è¿™ä¸ªç‚¹æ—¢å¯èƒ½æ˜¯å®ƒä»¬çš„ LCAï¼Œä¹Ÿå¯èƒ½æ˜¯å…¶ä¸­ä¸€ä¸ªç‚¹çš„å­å­™ï¼Œå¦å¤–ä¸¤ä¸ªç‚¹çš„ LCAã€‚ç»¼ä¸Šï¼Œ<strong>åœ¨ LCA å¤„ç»Ÿè®¡ç­”æ¡ˆæ˜¯å¯è¡Œçš„</strong>ã€‚</p>\n<p>ä»¤ <span class=\"math inline\">\\(f_{i,j}\\)</span> è¡¨ç¤º <span class=\"math inline\">\\(i\\)</span> å­æ ‘ä¸­è·ç¦» <span class=\"math inline\">\\(i\\)</span> ä¸º <span class=\"math inline\">\\(j\\)</span> çš„ç‚¹æ•°ï¼›<span class=\"math inline\">\\(g_{i,j}\\)</span> è¡¨ç¤º <span class=\"math inline\">\\(i\\)</span> å­æ ‘ä¸­è·ç¦» <span class=\"math inline\">\\(i\\)</span> ä¸º <span class=\"math inline\">\\(j\\)</span>ã€æˆ–è€…è· LCA ä¸º <span class=\"math inline\">\\(d\\)</span> ä¸” LCA è·ç¦» <span class=\"math inline\">\\(i\\)</span> ä¸º <span class=\"math inline\">\\(d-j\\)</span> çš„ç‚¹å¯¹æ•°ï¼›éšä¾¿åšå°±å¯ä»¥äº†ã€‚</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;std::vector&lt;int&gt; &gt; g1(n + 1);\n    for (int i = 1, x, y; i &lt; n; ++i) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y;\n        g1[x].push_back(y), g1[y].push_back(x);\n    &#125;\n    auto res(0ll);\n    std::vector&lt;int&gt; h(n + 1);\n    std::vector&lt;std::vector&lt;long long&gt; &gt; f(n + 1), g(n + 1);\n    std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int fa) &#123;\n        h[x] = 1;\n        for (auto i : g1[x])\n            if (i != fa) &#123;\n                DFS(i, x);\n                h[x] = std::max(h[x], h[i] + 1);\n            &#125;\n        f[x].resize(h[x] + 1), g[x].resize(h[x] + 1);\n        f[x][0] = 1ll;\n        for (auto i : g1[x])\n            if (i != fa) &#123;\n                for (int j = 0; j &lt;= h[i]; ++j) &#123;\n                    if (j &gt;= 1)\n                        res += g[x][j] * f[i][j - 1];\n                    if (j &gt;= 1 &amp;&amp; j + 1 &lt;= h[i])\n                        res += f[x][j] * g[i][j + 1];\n                    if (j &gt;= 1) &#123;\n                        g[x][j] += f[x][j] * f[i][j - 1];\n                        f[x][j] += f[i][j - 1];\n                    &#125;\n                    if (j + 1 &lt;= h[i])\n                        g[x][j] += g[i][j + 1];\n                &#125;\n                std::vector&lt;long long&gt;().swap(f[i]);\n                std::vector&lt;long long&gt;().swap(g[i]);\n            &#125;\n        res += g[x][0];\n        return;\n    &#125;;\n    DFS(1, -1);\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<p>ç„¶åå¯¹äºæ¯ä¸ª <span class=\"math inline\">\\(u\\)</span>ï¼Œç±»ä¼¼ DSU on treeï¼Œç»§æ‰¿å…¶é•¿å„¿å­çš„æ•°æ®ï¼ˆæ•´ä½“å‰ç§» / åç§»ä¸€ä½ï¼Œä½¿ç”¨æŒ‡é’ˆå®ç°ï¼‰ï¼Œå†æŠŠçŸ­å„¿å­æš´åŠ›åˆå¹¶ä¸Šæ¥ã€‚</p>\n<p>æ¯æ¬¡åˆå¹¶çŸ­å„¿å­ï¼Œæ•°ç»„é•¿ä¸ºçŸ­å„¿å­é“¾é•¿ï¼›<span class=\"math inline\">\\(u\\)</span> å‘ä¸Šåˆå¹¶æ—¶ï¼Œæ•°ç»„é•¿ä¸ºé•¿å„¿å­é“¾é•¿ã€‚æ•…æ‰€æœ‰é“¾è¢«åˆå¹¶æ°å¥½ä¸€æ¬¡ï¼Œå¤æ‚åº¦ <span class=\"math inline\">\\(O(n)\\)</span>ã€‚</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;std::vector&lt;int&gt; &gt; g1(n + 1);\n    for (int i = 1, x, y; i &lt; n; ++i) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y;\n        g1[x].push_back(y), g1[y].push_back(x);\n    &#125;\n    std::vector&lt;int&gt; h(n + 1), son(n + 1);\n    std::vector&lt;long long&gt; df(5 * n + 1), dg(5 * n + 1);\n    std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int fa) &#123;\n        h[x] = 1;\n        for (auto i : g1[x])\n            if (i != fa) &#123;\n                DFS(i, x);\n                h[x] = std::max(h[x], h[i] + 1);\n                if (h[i] &gt; h[son[x]])\n                    son[x] = i;\n            &#125;\n        return;\n    &#125;;\n    DFS(1, -1);\n    auto pos(dg.begin() + 3 * n);\n    std::vector&lt;decltype(df.begin())&gt; f(n + 1), g(n + 1);\n    auto res(0ll);\n    DFS = [&amp;](int x, int fa) &#123;\n        f[x][0] = 1ll;\n        if (son[x]) &#123;\n            f[son[x]] = std::next(f[x]), g[son[x]] = std::prev(g[x]);\n            DFS(son[x], x);\n        &#125;\n        for (auto i : g1[x])\n            if (i != fa &amp;&amp; i != son[x]) &#123;\n                f[i] = std::next(f[x], h[x] + 1);\n                std::fill(f[i], f[i] + h[i] + 2, 0ll);\n                g[i] = std::next(pos, h[i]), pos = std::next(g[i], h[i]);\n                std::fill(std::prev(g[i]), g[i] + h[i] + 2, 0ll);\n                DFS(i, x);\n                for (int j = 0; j &lt;= h[i]; ++j) &#123;\n                    if (j &gt;= 1)\n                        res += g[x][j] * f[i][j - 1];\n                    if (j &gt;= 1 &amp;&amp; j + 1 &lt;= h[i])\n                        res += f[x][j] * g[i][j + 1];\n                    if (j &gt;= 1) &#123;\n                        g[x][j] += f[x][j] * f[i][j - 1];\n                        f[x][j] += f[i][j - 1];\n                    &#125;\n                    if (j + 1 &lt;= h[i])\n                        g[x][j] += g[i][j + 1];\n                &#125;\n            &#125;\n        res += g[x][0];\n        return;\n    &#125;;\n    f[1] = df.begin(), g[1] = dg.begin() + 2 * n;\n    DFS(1, -1);\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"cf1585g-poachers\">CF1585G Poachers</h3>\n<p><a href=\"https://codeforces.com/problemset/problem/1585/G\" class=\"uri\">https://codeforces.com/problemset/problem/1585/G</a></p>\n<p>å…¬å¹³åšå¼ˆã€‚æˆ‘ä»¬ç°åœ¨è¦ç®—æ¯ä¸ªæ ¹çš„ SG å€¼ã€‚è®¾ <span class=\"math inline\">\\(f_{u,j}\\)</span> è¡¨ç¤ºåœ¨ç‚¹ <span class=\"math inline\">\\(u\\)</span>ï¼Œåˆ äº†è·ç¦»å®ƒä¸º <span class=\"math inline\">\\(j\\)</span> è¿™ä¸€å±‚çš„ SG å€¼ï¼Œé‚£ä¹ˆæœ‰ï¼š</p>\n<p><span class=\"math display\">\\[\nf_{u,j}=\n\\begin{cases}\n\\text{mex}\\{f_{v,0}\\}&amp;j=0\\\\\n\\bigoplus f_{v,j-1}&amp;\\text{otherwise}\n\\end{cases}\n\\]</span></p>\n<p>ç„¶åå‘ç°æœ‰æ·±åº¦ç»´ã€‚å¤§åŠ›é•¿å‰–ã€‚</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int inf = 0x3f3f3f3f;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int T;\n    for (std::cin &gt;&gt; T; T--; ) &#123;\n        int n;\n        std::cin &gt;&gt; n;\n        std::vector&lt;int&gt; rt;\n        std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);\n        for (int i = 1, x; i &lt;= n; ++i) &#123;\n            std::cin &gt;&gt; x;\n            if (x)\n                g[x].push_back(i);\n            else\n                rt.push_back(i);\n        &#125;\n        std::vector&lt;int&gt; h(n + 1), son(n + 1), to(n + 1, inf);\n        std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;\n            h[x] = 1;\n            for (auto i : g[x]) &#123;\n                DFS(i);\n                h[x] = std::max(h[x], h[i] + 1);\n                to[x] = std::min(to[x], to[i] + 1);\n                if (h[i] &gt; h[son[x]])\n                    son[x] = i;\n            &#125;\n            to[x] = std::min(to[x], h[x]);\n            return;\n        &#125;;\n        for (auto i : rt)\n            DFS(i);\n        std::vector&lt;int&gt; _f(5 * n + 1), top(n + 1);\n        std::vector&lt;decltype(_f.begin())&gt; f(n + 1);\n        std::vector&lt;std::unordered_set&lt;int&gt; &gt; s(n + 1);\n        auto p(_f.begin());\n        DFS = [&amp;](int x) &#123;\n            if (son[x]) &#123;\n                f[son[x]] = std::next(f[x]);\n                top[son[x]] = top[x], DFS(son[x]);\n            &#125;\n            if ((int)g[x].size() == 1) &#123;\n                s[top[x]].insert(f[son[x]][0]);\n                for (int now = f[son[x]][0] + 1; ; ++now)\n                    if (!s[top[x]].count(now)) &#123;\n                        f[x][0] = now;\n                        break;\n                    &#125;\n                return;\n            &#125;\n            for (auto i : g[x])\n                if (i != son[x]) &#123;\n                    f[i] = p, p = std::next(p, h[i] + 1);\n                    top[i] = i, DFS(i);\n                    for (int j = 1; j &lt;= to[i] + 1; ++j)\n                        f[x][j] ^= f[i][j - 1];\n                &#125;\n            std::unordered_set&lt;int&gt;().swap(s[top[x]]);\n            for (int j = 1; j &lt;= to[x]; ++j)\n                s[top[x]].insert(f[x][j]);\n            for (int now = 0; ; ++now)\n                if (!s[top[x]].count(now)) &#123;\n                    f[x][0] = now;\n                    break;\n                &#125;\n            return;\n        &#125;;\n        int res = 0;\n        for (auto i : rt) &#123;\n            f[i] = p, p = std::next(p, h[i] + 1);\n            DFS(i), res ^= f[i][0];\n        &#125;\n        std::cout &lt;&lt; (res ? &quot;YES&quot; : &quot;NO&quot;) &lt;&lt; &#39;\\n&#39;;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n",
            "tags": [
                "æ ‘é“¾å‰–åˆ†",
                "é•¿é“¾å‰–åˆ†"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/231230/",
            "url": "https://xsc062.netlify.app/231230/",
            "title": "è§£é¢˜æŠ¥å‘Š [SDOI2016] æ¸¸æˆ",
            "date_published": "2023-12-30T04:12:30.000Z",
            "content_html": "<p>å¯ä»¥çœ‹å‡ºæ¥å‡ºé¢˜äººå¾ˆæƒ³å‡ºä¸€é“æŠŠæè¶…å’Œåˆ«çš„ä»€ä¹ˆä¸œè¥¿å‡‘èµ·æ¥çš„é¢˜ç›®ï¼Œäºæ˜¯ç»™äº†è¿™ä¹ˆä¸€ä¸ªç¼åˆæ€ªã€‚</p>\n<span id=\"more\"></span>\n<hr />\n<p><a href=\"https://www.luogu.com.cn/problem/P4069\" class=\"uri\">https://www.luogu.com.cn/problem/P4069</a></p>\n<p>ç¬¦å·æœ‰ç‚¹æ··ä¹±ã€‚æ¯”å¦‚ç®­å¤´åˆå¯ä»¥è¡¨ç¤ºè·¯å¾„åˆå¯ä»¥è¡¨ç¤ºèµ‹å€¼ï¼Œä»£å…¥è¯­å¢ƒåº”è¯¥è¿˜æ˜¯å¥½ç†è§£çš„ã€‚</p>\n<hr />\n<p>çœ‹åˆ° <span class=\"math inline\">\\(a\\times dis + b\\)</span> å°±åº”æ¿€ååº”å‡ºæ¥æ˜¯æè¶…äº†ï¼Œçœ‹åˆ° <span class=\"math inline\">\\(s\\to t\\)</span> åˆç¬é—´ååº”è¿‡æ¥æ˜¯æ ‘å‰–ï¼Œä½†æ˜¯æ ‘å‰–çš„ DFN å’Œ <span class=\"math inline\">\\(dis\\)</span> æ²¡æœ‰ç›´æ¥å…³è”ï¼Œèµ›æ—¶æƒ³ä¸åˆ°æ€ä¹ˆåšå°±è·‘è·¯äº†ã€‚</p>\n<p>å®é™…ä¸Šè¿™ä¸ªè½¬åŒ–å¾ˆæ¿ã€‚å› ä¸ºè¿™æ˜¯æ¡è·¯å¾„ï¼Œæˆ‘ä»¬è¿˜åœ¨æ ‘é“¾ä¸Šè·³ï¼Œæ¯æ¬¡è·³è¿‡çš„ä¸€ä¸ªé“¾ä¸Šçš„ DFN æ˜¯è¿ç»­çš„ï¼Œå¯¹åº”çš„ <span class=\"math inline\">\\(dis\\)</span> ä¹Ÿæ˜¯è¿ç»­çš„ã€‚</p>\n<p>ä¼°è®¡æ˜¯æ‰“ T4 çš„å­æ ‘é—®é¢˜æ‰“å‚»äº†ï¼Œæ²¡æƒ³åˆ°è¿™ä¸ªã€‚</p>\n<p>æ‰€ä»¥æˆ‘ä»¬å°±ç›¸å½“äºæ˜¯ç»™ä¸€æ¡é‡é“¾ä¸Šçš„æŸä¸ªè¿ç»­åŒºé—´åŠ äº†ä¸€ä¸ªæ–œç‡ä¸º <span class=\"math inline\">\\(a\\)</span>ï¼Œæˆªè·ä¸º <span class=\"math inline\">\\(b\\)</span> åŠ ä¸Š <em>ä¸€å¨ä¸œè¥¿</em> çš„çº¿æ®µã€‚ç”¨æè¶…ç»´æŠ¤å³å¯ã€‚</p>\n<hr />\n<p>æ„Ÿè§‰è®²çš„ä¸æ¸…ä¸æ¥šçš„ï¼Œé‚£å°±å†è®²è®²ã€‚</p>\n<p>æˆ‘ä»¬è¦è®©æè¶…ä¸Šä»»æ„ä¸€ä¸ªç‚¹ <span class=\"math inline\">\\(u\\)</span> ä»£è¡¨çš„ <span class=\"math inline\">\\(x\\)</span> æ˜¯ä¸ªå®šå€¼ã€‚<em>ä¸€å¨ä¸œè¥¿</em> ç»´æŠ¤äº†è¿™æ¡çº¿æ®µç›¸å¯¹äº <span class=\"math inline\">\\(s\\)</span> çš„åç§»é‡ã€‚ä»¤ <span class=\"math inline\">\\(r\\gets \\text{LCA of } s \\text { and } t\\)</span>ï¼Œ<span class=\"math inline\">\\(R\\)</span> è¡¨ç¤ºæ•´æ£µæ ‘çš„æ ¹ï¼Œ<span class=\"math inline\">\\(d(u,v)\\gets \\text {distance between } u \\text { and } v\\)</span>ã€‚</p>\n<ol type=\"1\">\n<li><p>å¯¹äº <span class=\"math inline\">\\(s\\to r\\)</span> ä¸Šçš„æ¯ä¸ªç‚¹ <span class=\"math inline\">\\(u\\)</span>ï¼š</p>\n<p><span class=\"math display\">\\[\n\\begin{aligned}\nval_u&amp;=a\\times d(s, u)+b\\\\\n&amp;=a\\times[d(s,R)-d(u,R)]+b\\\\\n&amp;=-a\\times d(u,R)+[a\\times d(s,R)+b]\n\\end{aligned}\n\\]</span> <span class=\"math inline\">\\(a\\times d(s,R)+b\\)</span> æ˜¯å’Œ <span class=\"math inline\">\\(u\\)</span> æ— å…³çš„å®šå€¼ï¼ˆè¿™æ„å‘³ç€å¯ä»¥åœ¨åŒä¸€ä¸ªè¯¢é—®çš„æ ‘å‰–æ—¶ç›´æ¥çº¿æ®µæ ‘ï¼‰ï¼Œ<span class=\"math inline\">\\(d(u,R)\\)</span> æ˜¯åªå’Œ <span class=\"math inline\">\\(u\\)</span> ç›¸å…³çš„å€¼ï¼ˆè¿™æ„å‘³ç€å¯¹äºä»»æ„è¯¢é—®éƒ½æˆç«‹ï¼‰ã€‚ä»¤æ–œç‡ä¸º <span class=\"math inline\">\\(-a\\)</span>ï¼Œæˆªè·ä¸º <span class=\"math inline\">\\(a\\times d(s,R)+b\\)</span>ï¼Œæè¶…ä¸Šä»»æ„ç‚¹ <span class=\"math inline\">\\(u\\)</span> ä»£è¡¨ <span class=\"math inline\">\\(x\\)</span> ä¸º <span class=\"math inline\">\\(d(x,R)\\)</span>ï¼Œç»´æŠ¤å¦‚æ­¤ä¸€æ¡çº¿æ®µå³å¯ã€‚</p></li>\n<li><p>å¯¹äº <span class=\"math inline\">\\(r\\to t\\)</span> ä¸Šçš„æ¯ä¸ªç‚¹ <span class=\"math inline\">\\(v\\)</span>ï¼š <span class=\"math display\">\\[\n\\begin{aligned}\nval_v&amp;=a\\times d(s,v)+b\\\\\n&amp;= a\\times [d(r,v)+d(s,r)]+b\\\\\n&amp;=a\\times [d(v,R)-d(r,R)+d(s,r)]+b\\\\\n&amp;=a\\times d(v,R)+[-a\\times d(r,R)+a\\times d(s,r)+b]\n\\end{aligned}\n\\]</span> <span class=\"math inline\">\\(-a\\times d(r,R)+a\\times d(s,r)+b\\)</span> æ˜¯å’Œ <span class=\"math inline\">\\(v\\)</span> æ— å…³ï¼Œåªå’Œè¯¢é—®ä¸­å›ºå®šçš„ <span class=\"math inline\">\\(s,r,a,b\\)</span> æœ‰å…³çš„å®šå€¼ï¼›<span class=\"math inline\">\\(d(v,R)\\)</span> æ˜¯åªå’Œ <span class=\"math inline\">\\(v\\)</span> ç›¸å…³çš„å€¼ä¸”å’Œä¸Šä¸€ä¸ª case é‡Œçš„ <span class=\"math inline\">\\(d(u,R)\\)</span> åŒæ„ï¼Œä¹Ÿç”¨æè¶…è¿™ä¹ˆç»´æŠ¤å³å¯ã€‚</p></li>\n</ol>\n<p>ç”¨æè¶…ç»´æŠ¤æŠŠåŸé—®é¢˜è½¬åŒ–ä¸ºæ¯æ¬¡å‘è‹¥å¹²é‡é“¾ä¸Šè¿ç»­åŒºé—´æ’å…¥çº¿æ®µï¼Œæ±‚æœ€ä½äº¤ç‚¹çš„é—®é¢˜ã€‚</p>\n<p>æ³¨æ„åˆ°åŒºé—´æŸ¥è¯¢ï¼Œæè¶…éœ€è¦åŠ ä¸€ä¸ª pushupã€‚å…·ä½“æ€ä¹ˆå»æ“ä½œå‘¢ï¼Ÿåœ¨åŠ çº¿æ®µçš„æ—¶å€™é™¤ç¼–å·å¤–æ–°å¢ä¸€ä¸ªå˜é‡ç»´æŠ¤å½“å‰åŒºé—´å†…æœ€ä½äº¤ç‚¹ï¼›æˆ‘ä»¬å°± pushup è¿™ä¸ªä¸œè¥¿ã€‚ç„¶åæŸ¥è¯¢çš„æ—¶å€™å°±æ˜¯åœ¨æ•£åŒºé—´çš„æ—¶å€™å’ŒåŸæ¥ä¸€æ ·æŸ¥ï¼Œæ•´åŒºé—´å°±åœ¨æ•£åŒºé—´ç­”æ¡ˆçš„åŸºç¡€ä¸Šå†å’Œå½“å‰åŒºé—´çš„æ•´ä½“æœ€ä½äº¤ç‚¹æ¯”ä¸€ä¸ª minã€‚</p>\n<details>\n<pre class=\"cpp\"><code>#define int long long\nnamespace XSC062 &#123;\nusing namespace fastIO;\nconst int maxk = 25;\nconst int maxn = 1e6 + 5;\nconst int maxm = 1e6 + 5;\nconst int inf = 123456789123456789;\n//#define DEBUG\n\n#ifdef DEBUG\n#define Z(x) x\n#else\n#define Z(x)\n#endif\n#define lt (p &lt;&lt; 1)\n#define rt (lt | 1)\nstruct __ &#123; int k, b; &#125;;\nstruct _ &#123; int l, r, u, d; &#125;;\nstruct ____ &#123;\n    int v, w;\n    ____() &#123;&#125;\n    ____(int v1, int w1) &#123;\n        v = v1, w = w1; \n    &#125;\n&#125;;\n__ a[maxm];\n_ t[maxn &lt;&lt; 2];\nint tot, si, now;\nint f[maxn][maxk];\nint dis[maxn], dep[maxn];\nint dfn[maxn], tab[maxn];\nstd::vector&lt;____&gt; g[maxn];\nint n, m, ty, x, y, w, k, b;\nint siz[maxn], top[maxn], son[maxn];\nint max(int x, int y) &#123;\n    return x &gt; y ? x : y;\n&#125;\nint min(int x, int y) &#123;\n    return x &lt; y ? x : y;\n&#125;\nvoid swap(int &amp;x, int &amp;y) &#123;\n    x ^= y ^= x ^= y;\n    return;\n&#125;\nvoid DFS1(int x) &#123;\n    siz[x] = 1;\n    for (auto i : g[x]) &#123;\n        if (i.v == f[x][0]) continue;\n        f[i.v][0] = x;\n        for (int j = 1; j &lt;= si; ++j)\n            f[i.v][j] = f[f[i.v][j - 1]][j - 1];\n        dep[i.v] = dep[x] + 1;\n        dis[i.v] = dis[x] + i.w;\n        DFS1(i.v);\n        if (siz[i.v] &gt; siz[son[x]])\n            son[x] = i.v;\n        siz[x] += siz[i.v];\n    &#125;\n    return;\n&#125;\nvoid DFS2(int x, int t) &#123;\n    top[x] = t;\n    dfn[x] = ++now, tab[now] = x;\n    if (son[x]) DFS2(son[x], t);\n    for (auto i : g[x]) &#123;\n        if (i.v == f[x][0] || i.v == son[x])\n            continue;\n        DFS2(i.v, i.v);\n    &#125;\n    return;\n&#125;\nvoid bld(int p, int l, int r) &#123;\n    t[p].l = l, t[p].r = r, t[p].d = inf;\n    if (l == r) return;\n    int mid = (l + r) &gt;&gt; 1;\n    bld(lt, l, mid), bld(rt, mid + 1, r);\n    return;\n&#125;\nint getv(int id, int x) &#123;\n    if (!id) return inf;\n    Z(printf(&quot;get (%lld, %lld) = %lld\\n&quot;,\n        id, x, dis[tab[x]] * a[id].k + a[id].b));\n    return dis[tab[x]] * a[id].k + a[id].b;\n&#125;\nvoid pushup(int p) &#123;\n    if (t[p].l == t[p].r) return;\n    t[p].d = min(t[p].d, min(t[lt].d, t[rt].d));\n    Z(printf(&quot;[%lld, %lld]: pushup to %lld\\n&quot;,\n        t[p].l, t[p].r, t[p].d));\n    return;\n&#125;\nvoid chg(int p, int id) &#123;\n    t[p].u = id;\n    Z(int tmp = t[p].d);\n    t[p].d = min(getv(id, t[p].l),\n                 getv(id, t[p].r));\n    Z(printf(&quot;[%lld, %lld]: %lld -&gt; %lld\\n&quot;,\n                t[p].l, t[p].r, tmp, t[p].d)); \n    return;\n&#125;\nvoid upd(int p, int id) &#123;\n    if (!t[p].u) &#123;\n        chg(p, id), pushup(p);\n        return;\n    &#125;\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    int v1 = getv(t[p].u, mid),\n        v2 = getv(id, mid);\n    if (v2 &lt; v1) swap(t[p].u, id);\n    v1 = getv(t[p].u, t[p].l);\n    v2 = getv(id, t[p].l);\n    if (v2 &lt; v1) upd(lt, id);\n    v1 = getv(t[p].u, t[p].r);\n    v2 = getv(id, t[p].r);\n    if (v2 &lt; v1) upd(rt, id);\n    chg(p, t[p].u);\n    pushup(p);\n    return;\n&#125;\nvoid add(int p, int l, int r, int id) &#123;\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r) &#123;\n        upd(p, id);\n        return;\n    &#125;\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (l &lt;= mid) add(lt, l, r, id);\n    if (r &gt; mid) add(rt, l, r, id);\n    pushup(p);\n    return;\n&#125;\nint ask(int p, int l, int r) &#123;\n    l = max(l, t[p].l);\n    r = min(r, t[p].r);\n    int res = min(getv(t[p].u, l),\n                  getv(t[p].u, r));\n    Z(printf(&quot;[%lld, %lld]: res = %lld\\n&quot;,\n        t[p].l, t[p].r, res));\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r)\n        return min(res, t[p].d);\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (l &lt;= mid) res = min(res, ask(lt, l, r));\n    if (r &gt; mid) res = min(res, ask(rt, l, r));\n    Z(printf(&quot;[%lld, %lld]: res = %lld\\n&quot;,\n        t[p].l, t[p].r, res));\n    return res;\n&#125;\nvoid add(int x, int y, int w) &#123;\n    g[x].push_back(____(y, w));\n    return;\n&#125;\nvoid ins(int l, int r, int k, int b) &#123;\n    a[++tot].k = k, a[tot].b = b;\n    add(1, l, r, tot);\n    return;\n&#125;\nint getLCA(int x, int y) &#123;\n    if (dep[x] &lt; dep[y]) swap(x, y);\n    for (int i = si; ~i; --i) &#123;\n        if (dep[f[x][i]] &gt;= dep[y])\n            x = f[x][i];\n    &#125;\n    if (x == y) return x;\n    for (int i = si; ~i; --i) &#123;\n        if (f[x][i] != f[y][i])\n            x = f[x][i], y = f[y][i];\n    &#125;\n    return f[x][0];\n&#125;\nvoid inst(int s, int t, int k, int b) &#123;\n    int r = getLCA(s, t), u = s;\n    while (top[u] != top[r]) &#123;\n        ins(dfn[top[u]], dfn[u],\n                    -k, k * dis[s] + b);\n        u = f[top[u]][0];\n    &#125;\n    ins(dfn[r], dfn[u], -k, k * dis[s] + b);\n    u = t;\n    int d = dis[s] - dis[r];\n    while (top[u] != top[r]) &#123;\n        ins(dfn[top[u]], dfn[u],\n                k, -k * dis[r] + k * d + b);\n        u = f[top[u]][0];\n    &#125;\n    ins(dfn[r], dfn[u],\n            k, -k * dis[r] + k * d + b);\n    return;\n&#125;\nint qry(int x, int y) &#123;\n    int res = inf;\n    while (top[x] != top[y]) &#123;\n        if (dep[top[x]] &lt; dep[top[y]])\n            swap(x, y);\n        Z(printf(&quot;ask %lld -&gt; %lld: %lld\\n&quot;,\n            x, top[x],\n            ask(1, dfn[top[x]], dfn[x])));\n        res = min(res,\n            ask(1, dfn[top[x]], dfn[x]));\n        x = f[top[x]][0];\n    &#125;\n    if (dep[x] &lt; dep[y]) swap(x, y);\n    Z(printf(&quot;ask %lld -&gt; %lld: %lld\\n&quot;,\n        x, y, ask(1, dfn[y], dfn[x])));\n    res = min(res, ask(1, dfn[y], dfn[x]));\n    return res;\n&#125;\nint main() &#123;\n//  freopen(&quot;game1.in&quot;, &quot;r&quot;, stdin);\n    read(n), read(m);\n    si = log(n) / log(2.0);\n    for (int i = 1; i &lt; n; ++i) &#123;\n        read(x), read(y), read(w);\n        add(x, y, w), add(y, x, w);\n    &#125;\n    bld(1, 1, n);\n    dep[1] = 1, DFS1(1), DFS2(1, -1);\n    Z(for (int i = 1; i &lt;= n; ++i)\n        printf(&quot;dfn[%lld] = %lld\\n&quot;, i, dfn[i]));\n    while (m--) &#123;\n        read(ty), read(x), read(y);\n        if (ty == 1) &#123;\n            read(k), read(b);\n            inst(x, y, k, b);\n        &#125;\n        else print(qry(x, y), &#39;\\n&#39;);\n    &#125;\n    return 0;\n&#125;\n&#125; // namespace XSC062\n#undef int</code></pre>\n</details>\n",
            "tags": [
                "æ ‘é“¾å‰–åˆ†",
                "æè¶…çº¿æ®µæ ‘"
            ]
        }
    ]
}