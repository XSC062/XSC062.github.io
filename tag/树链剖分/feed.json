{
    "version": "https://jsonfeed.org/version/1",
    "title": "null • All posts by \"树链剖分\" tag",
    "description": "",
    "home_page_url": "https://xsc062.netlify.app",
    "items": [
        {
            "id": "https://xsc062.netlify.app/20250510/",
            "url": "https://xsc062.netlify.app/20250510/",
            "title": "杂题",
            "date_published": "2025-05-10T02:18:21.000Z",
            "content_html": "<p>啊啊。小封条。</p>\n<span id=\"more\"></span>\n<hr />\n<h2 id=\"a---pass-to-next\">A - Pass to Next</h2>\n<p><a href=\"https://atcoder.jp/contests/arc124/tasks/arc124_e\" class=\"uri\">https://atcoder.jp/contests/arc124/tasks/arc124_e</a></p>\n<p>感觉其他一些题解讲得不是特别清楚，这里参考了 <a href=\"https://blog.csdn.net/weixin_43960287/article/details/119140590\">XJX 的文章</a>。</p>\n<p>要求的答案是 <span class=\"math inline\">\\(\\prod a&#39;_i\\)</span>，<mark>发现运算是乘法，比较怪；由此考虑转化为方案数，也就是假设每个人有 <span class=\"math inline\">\\(a&#39;_i\\)</span> 个互不相同的球，每个人在其中选出恰好一个的方案数</mark>。</p>\n<p>考虑 DP。发现每个人手上的球分为『自己的』和『左边的人传过来的』两种类型；<mark>显然第二种会有来自上一个人的限制，考虑把第二种在上一个人就完成求解</mark>。具体地，设 <span class=\"math inline\">\\(f_{i,0}\\)</span> 表示第 <span class=\"math inline\">\\(i\\)</span> 个人选取自己的球，但只记录 <span class=\"math inline\">\\(1\\sim i-1\\)</span> 的方案；<span class=\"math inline\">\\(f_{i,1}\\)</span> 表示第 <span class=\"math inline\">\\(i\\)</span> 个人选取第 <span class=\"math inline\">\\(i-1\\)</span> 个人的球，并记入答案的方案。<em>你可能需要注意到：最后一个被记入方案的球来自第 <span class=\"math inline\">\\(i-1\\)</span> 个人</em>。</p>\n<p>但这样会有个小问题。我们让所有人多往右边传一个球，那么在我们的这种分割方法看来是不一样的局面；但实际上它们是等价的。从每个人传出了多少个球（设为 <span class=\"math inline\">\\(x_i\\)</span>）的角度来看，对于 <span class=\"math inline\">\\(\\min\\{x_n\\}\\ne 0\\)</span>，只需要不断执行 <span class=\"math inline\">\\(\\forall\\, x_i\\gets x_i-1\\)</span> 就可以在局面不变的情况下使 <span class=\"math inline\">\\(\\min\\{x_n\\}\\ne 0\\)</span>。这是在说，可以让 <span class=\"math inline\">\\(\\min\\{x_n\\}\\ne 0\\)</span> 的方案和终局一一对应。</p>\n<p>发现可以容斥：钦定 <span class=\"math inline\">\\(x_i\\ge 1\\)</span>，也就是每个人必须往右传至少一个，相似地算一遍就能得到非法方案。</p>\n<p>考虑转移，令 <span class=\"math inline\">\\(x_i\\)</span> 可选最小值为 <span class=\"math inline\">\\(l\\)</span>，有：</p>\n<ul>\n<li><span class=\"math inline\">\\(f_{i+1,0}\\gets f_{i,0}\\)</span>：将第 <span class=\"math inline\">\\(i\\)</span> 个人未被记入的自己的球记入，球数可能为 <span class=\"math inline\">\\([0,a_i-l]\\)</span>。等差数列求和即可。</li>\n<li><span class=\"math inline\">\\(f_{i+1,0}\\gets f_{i,1}\\)</span>：没有球需要被记入，但是这种情况对应多种 <span class=\"math inline\">\\(x_i\\)</span>。具体地，<span class=\"math inline\">\\(x_i\\in [l,a_i]\\)</span>。共有 <span class=\"math inline\">\\(a_i-l+1\\)</span> 种方案。</li>\n<li><span class=\"math inline\">\\(f_{i+1,1}\\gets f_{i,0}\\)</span>：将第 <span class=\"math inline\">\\(i\\)</span> 个人的 <span class=\"math inline\">\\(a_i\\)</span> 个球分给 <span class=\"math inline\">\\(i\\)</span> 和 <span class=\"math inline\">\\(i+1\\)</span>。共有 <span class=\"math inline\">\\(x_i\\cdot (a_i-x_i)\\)</span> 种可能，也就是 <span class=\"math inline\">\\(\\left(a_i\\cdot \\sum_{x_i=l}^{a_i} x_i\\right)-\\left(\\sum_{x_i=l}^{a_i}{x_i}^2\\right)\\)</span> 种方案。</li>\n<li><span class=\"math inline\">\\(f_{i+1,1}\\gets f_{i,1}\\)</span>：将第 <span class=\"math inline\">\\(i+1\\)</span> 个人得到的第 <span class=\"math inline\">\\(i\\)</span> 个人的球记入，同第一条。</li>\n</ul>\n<p>破环为链，分别钦定第一个人是用自己的球还是上一个人的球来解决问题（必须对于两种可能性分开计算；否则就不知道答案应该取 <span class=\"math inline\">\\(f_{n,0}\\)</span> 还是 <span class=\"math inline\">\\(f_{n,1}\\)</span>）。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 998244353, inv2 = (mod + 1) &gt;&gt; 1, inv6 = 166374059;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;long long&gt; a(n);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i % n];\n    auto sum = [&amp;](long long r) &#123;\n        return r * (r + 1) % mod * inv2 % mod;\n    &#125;;\n    auto sum2 = [&amp;](long long r) &#123;\n        return r * (r + 1) % mod * (2 * r % mod + 1) % mod * inv6 % mod;\n    &#125;;\n    std::vector&lt;std::vector&lt;long long&gt; &gt; f0(n, std::vector&lt;long long&gt; (2)), f1(n, std::vector&lt;long long&gt; (2));\n    auto calc = [&amp;](long long l, std::vector&lt;std::vector&lt;long long&gt; &gt; &amp;f) &#123;\n        f[0][0] = 1ll;\n        for (int i = 0; i &lt; n; ++i) &#123;\n            int j = (i + 1) % n;\n            f[j][0] = f[i][0] * sum(a[i] - l) % mod;\n            (f[j][0] += f[i][1] * (a[i] - l + 1)) %= mod;\n            f[j][1] = f[i][0] * (a[i] * sum(a[i]) % mod - sum2(a[i])) % mod;\n            (f[j][1] += f[i][1] * sum(a[i]) % mod) %= mod;\n            // printf(&quot;0, l = %lld, f[%d]: %lld / %lld\\n&quot;, l, j, f[j][0], f[j][1]);\n        &#125;\n        auto res(f[0][0]);\n        f.assign(n, std::vector&lt;long long&gt; (2));\n        f[0][1] = 1ll;\n        for (int i = 0; i &lt; n; ++i) &#123;\n            int j = (i + 1) % n;\n            f[j][0] = f[i][0] * sum(a[i] - l) % mod;\n            (f[j][0] += f[i][1] * (a[i] - l + 1)) %= mod;\n            f[j][1] = f[i][0] * (a[i] * sum(a[i]) % mod - sum2(a[i])) % mod;\n            (f[j][1] += f[i][1] * sum(a[i]) % mod) %= mod;\n            // printf(&quot;1, l = %lld, f[%d]: %lld / %lld\\n&quot;, l, j, f[j][0], f[j][1]);\n        &#125;\n        return (res + f[0][1]) % mod;\n    &#125;;\n    std::cout &lt;&lt; (calc(0, f0) + mod - calc(1, f1)) % mod &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"b---绿宝石之岛\">B - 绿宝石之岛</h2>\n<p><a href=\"https://loj.ac/p/6406\" class=\"uri\">https://loj.ac/p/6406</a></p>\n<p>因为只关心最终状态，原题可以转化为：将 <span class=\"math inline\">\\(d\\)</span> 分成 <span class=\"math inline\">\\(n\\)</span> 个非负整数，前 <span class=\"math inline\">\\(r\\)</span> 大数之和的期望（当然你需要加上初始的 <span class=\"math inline\">\\(r\\)</span> 个）。</p>\n<p>关于非负整数拆分：设 <span class=\"math inline\">\\(f_{i,j}\\)</span> 表示将 <span class=\"math inline\">\\(i\\)</span> 分成 <span class=\"math inline\">\\(j\\)</span> 个 <strong>非负整数</strong> 的方案，钦定其中恰有 <span class=\"math inline\">\\(k\\)</span> 个 <strong>正整数</strong> 进行转移，给这 <span class=\"math inline\">\\(k\\)</span> 个数先分一个 <span class=\"math inline\">\\(1\\)</span>，则 <span class=\"math inline\">\\(f_{i,j}=\\sum\\limits_{k=0}^{\\min(i,j)} C_j^k\\cdot f_{i-k,k}\\)</span>。</p>\n<p>再设 <span class=\"math inline\">\\(g_{i,j}\\)</span> 表示将 <span class=\"math inline\">\\(i\\)</span> 分成 <span class=\"math inline\">\\(j\\)</span> 个非负整数的所有方案中、前 <span class=\"math inline\">\\(r\\)</span> 大的数之和。类似地，有 <span class=\"math inline\">\\(g_{i,j}=\\sum\\limits_{k=0}^{\\min(i,j)} C_j^k\\cdot (g_{i-k,k}+\\min(k,r)\\cdot f_{i-k,k})\\)</span>。其中，<span class=\"math inline\">\\(\\min(k,r)\\)</span> 的来源是，只有 <span class=\"math inline\">\\(k\\)</span> 个数有值，前 <span class=\"math inline\">\\(r\\)</span> 大的数一定在这 <span class=\"math inline\">\\(k\\)</span> 个数里面。</p>\n<p>答案为 <span class=\"math inline\">\\(\\dfrac {g_{d,n}}{f_{d,n}}+r\\)</span>，复杂度 <span class=\"math inline\">\\(O(n^3)\\)</span>。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, d, r;\n    std::cin &gt;&gt; n &gt;&gt; d &gt;&gt; r;\n    using arr = std::vector&lt;double&gt;;\n    std::vector&lt;arr&gt; f(d + 1, arr(n + 1)), g(d + 1, arr(n + 1)), C(n + 1, arr(n + 1));\n    for (int i = 0; i &lt;= n; ++i) &#123;\n        C[i][0] = 1.;\n        for (int j = 1; j &lt;= i; ++j)\n            C[i][j] = C[i - 1][j - 1] + C[i - 1][j];\n    &#125;\n    f[0].assign(n + 1, 1.);\n    for (int i = 1; i &lt;= d; ++i)\n        for (int j = 1; j &lt;= n; ++j) &#123;\n            for (int k = 1; k &lt;= i &amp;&amp; k &lt;= j; ++k) &#123;\n                f[i][j] += C[j][k] * f[i - k][k];\n                g[i][j] += C[j][k] * (g[i - k][k] + std::min(k, r) * f[i - k][k]);\n                // printf(&quot;  k = %d, %.0lf + %.0lf\\n&quot;, k, C[j][k] * g[i - k][k], std::min(k, r) * f[i - k][k]);\n            &#125;\n            // printf(&quot;f[%d][%d] = %.0lf, g[%d][%d] = %.0lf\\n&quot;, i, j, f[i][j], i, j, g[i][j]);\n        &#125;\n    std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(8) &lt;&lt; g[d][n] / f[d][n] + r &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"c---uddered-but-not-herd-g\">C - Uddered but not Herd G</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P7296\" class=\"uri\">https://www.luogu.com.cn/problem/P7296</a></p>\n<p>给每个字母分配一个标号 <span class=\"math inline\">\\(x\\)</span>，那么最小段数就是 <span class=\"math inline\">\\(\\sum \\left[x_i\\ge x_{i+1}\\right]\\)</span>。</p>\n<p>考虑状压完成映射操作，令 <span class=\"math inline\">\\(f_{s}\\)</span> 表示给标号 <span class=\"math inline\">\\(1\\sim |s|\\)</span> 分配字母后，占用字符集 <span class=\"math inline\">\\(s\\)</span> 的方案数，那么就能 <span class=\"math inline\">\\(O(1)\\)</span> 得到贡献——只需预处理出 <span class=\"math inline\">\\(f_{c, s}\\)</span> 表示分配到字母 <span class=\"math inline\">\\(c\\)</span> 时，已经先给 <span class=\"math inline\">\\(s\\)</span> 中字母分配了更小标号时的贡献。</p>\n<p>注意字符集大小只有 <span class=\"math inline\">\\(20\\)</span>，可以 <span class=\"math inline\">\\(O(|S|\\cdot 2^{|S|})\\)</span> 解决问题，<mark>注意到预处理的内容是类高维前缀最值的形式，可以递推降低复杂度</mark>。</p>\n<details>\n<pre data-line=\"26-28\" class=\"cpp language-cpp\"><code data-line=\"26-28\" class=\"cpp language-cpp\">#include &lt;bits/stdc++.h>\nconst int inf = 0x3f3f3f3f;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(\".in\", \"r\", stdin);\n    std::freopen(\".out\", \"w\", stdout);\n#endif\n    int n;\n    std::string t;\n    std::cin >> t, n = (int)t.length(), t = \"#\" + t;\n    std::vector&lt;int> a, tag(26, -1), s(n + 1);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        if (tag[t[i] - 'a'] == -1)\n            tag[t[i] - 'a'] = (int)a.size(), a.push_back(t[i] - 'a');\n        s[i] = tag[t[i] - 'a'];\n    &#125;\n    int m = (int)a.size(), siz = 1 &lt;&lt; m;\n    std::vector&lt;std::vector&lt;int> > cnt(m, std::vector&lt;int> (m));\n    for (int i = 1; i &lt; n; ++i)\n        ++cnt[s[i]][s[i + 1]];\n    std::vector&lt;std::vector&lt;int> > g(m, std::vector&lt;int> (siz));\n    for (int i = 0; i &lt; m; ++i)\n        for (int k = 0; k &lt; m; ++k) // 注意这里相当于是钦定从 k 处转移\n            for (int j = (1 &lt;&lt; k); j &lt; (2 &lt;&lt; k); ++j) // 枚举的是 k 位为 1 的所有数；这两层循环的复杂度为 O(siz)\n                g[i][j] = g[i][j ^ (1 &lt;&lt; k)] + cnt[i][k]; // 目的是此处的内存连续访问优化，把 ^ 看作 - 应该就能理解为什么第二维是连续的\n    std::vector&lt;int> f(siz, inf);\n    f[0] = 1;\n    for (int i = 1; i &lt; siz; ++i)\n        for (int j = 0; j &lt; m; ++j)\n            if ((i >> j) & 1)\n                f[i] = std::min(f[i], f[i ^ (1 &lt;&lt; j)] + g[j][i]);\n    std::cout &lt;&lt; f[siz - 1] &lt;&lt; '\\n';\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"d---min-max-subarrays-p\">D - Min Max Subarrays P</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P11845\" class=\"uri\">https://www.luogu.com.cn/problem/P11845</a></p>\n<p>先考虑 <span class=\"math inline\">\\(01\\)</span> 序列的答案：如果序列中存在相邻的 <span class=\"math inline\">\\(2\\)</span> 个 <span class=\"math inline\">\\(1\\)</span>，总能保证最后的一个是 <span class=\"math inline\">\\(1\\)</span>。</p>\n<p>如果序列中存在 <span class=\"math inline\">\\(\\ge 3\\)</span> 个 <span class=\"math inline\">\\(1\\)</span>，可以牺牲其中的一些使得 <span class=\"math inline\">\\(2\\)</span> 个 <span class=\"math inline\">\\(1\\)</span> 相邻。</p>\n<p>当序列中只有 <span class=\"math inline\">\\(2\\)</span> 个 <span class=\"math inline\">\\(1\\)</span> 时，只有因为剩下的 <span class=\"math inline\">\\(0\\)</span> 不太够，导致我们无法随意『上下其手』时不能将 <span class=\"math inline\">\\(2\\)</span> 个 <span class=\"math inline\">\\(1\\)</span> 挪到一起。</p>\n<p>令两个 <span class=\"math inline\">\\(1\\)</span> 为序列最大值与次大值，暴搜处理序列长度较小的情况，剩下的直接用奇偶性判断两个 <span class=\"math inline\">\\(1\\)</span> 取哪个。</p>\n<hr />\n<h2 id=\"a---mst-on-line\">A - MST on Line++</h2>\n<p><a href=\"https://atcoder.jp/contests/arc167/tasks/arc167_c\" class=\"uri\">https://atcoder.jp/contests/arc167/tasks/arc167_c</a></p>\n<p>相当于把 <span class=\"math inline\">\\(a\\)</span> 打乱然后处理原问题。考虑每个 <span class=\"math inline\">\\(a_i\\)</span> 的贡献次数。模拟 Kruskal 连边，从小到大把点 <span class=\"math inline\">\\(a_i\\)</span> 加入图，<span class=\"math inline\">\\(a_i\\)</span> 可以向 <span class=\"math inline\">\\(a_{[i-K,i+K]}\\)</span> 内所有连通块连边。</p>\n<p>连通块数量当且仅当 <span class=\"math inline\">\\([i-K,i)\\)</span> 内最靠右的点和 <span class=\"math inline\">\\((i, i+K]\\)</span> 内最靠左的点距离 <span class=\"math inline\">\\(&gt;K\\)</span> 时为 <span class=\"math inline\">\\(2\\)</span>，其余情况为 <span class=\"math inline\">\\(1\\)</span>。</p>\n<p>但要是从这个角度想这个题就不太好做了。正确的想法应该是<mark>拆分为『若 <span class=\"math inline\">\\([i-K,i)\\)</span> 中有点，贡献次数 <span class=\"math inline\">\\(+1\\)</span>』和『若 <span class=\"math inline\">\\((i,i+K]\\)</span> 中有点 <span class=\"math inline\">\\(j\\)</span> 满足 <span class=\"math inline\">\\([j-K,j)\\)</span> 中无点，贡献次数 <span class=\"math inline\">\\(+1\\)</span>』</mark>。对于第一个问题，贡献次数将前 <span class=\"math inline\">\\(i-1\\)</span> 大的数分配至少一个到 <span class=\"math inline\">\\([i-K,i)\\)</span> 中的方案数；对于第二个问题，枚举 <span class=\"math inline\">\\(j\\)</span>，贡献次数为将前 <span class=\"math inline\">\\(i-1\\)</span> 大的数分配到 <span class=\"math inline\">\\(j\\)</span> 和 <span class=\"math inline\">\\([1,j-K)\\cup (j, n]\\)</span> 中的方案数。</p>\n<details>\n<p>实现的时候千万注意循环变量枚举的是位置还是值！不然你会调得很痛苦。</p>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 998244353;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;03-max-01.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, k;\n    std::cin &gt;&gt; n &gt;&gt; k;\n    std::vector&lt;int&gt; a(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i];\n    std::sort(a.begin() + 1, a.end());\n    std::vector&lt;long long&gt; fac(n + 1), inv(n + 1);\n    fac[0] = inv[0] = 1ll;\n    for (int i = 1; i &lt;= n; ++i)\n        fac[i] = fac[i - 1] * i % mod;\n    auto qkp = [](long long x, int y) &#123;\n        auto res(1ll);\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    inv[n] = qkp(fac[n], mod - 2);\n    for (int i = n - 1; i; --i)\n        inv[i] = inv[i + 1] * (i + 1) % mod;\n    auto A = [&amp;](int n, int m) &#123;\n        if (n &lt; m)\n            return 0ll;\n        return fac[n] * inv[n - m] % mod;\n    &#125;;\n    auto C = [&amp;](int n, int m) &#123;\n        return A(n, m) * inv[m] % mod;\n    &#125;;\n    long long res = 0ll;\n    for (int i = 2; i &lt;= n; ++i) &#123;\n        for (int j = 1; j &lt;= n; ++j)\n            (res += a[i] * (fac[n - 1] + mod - A(n - 1 - (j - std::max(1, j - k)), i - 1) * fac[n - i] % mod) % mod) %= mod;\n        for (int j = 2; j &lt;= n; ++j)\n            (res += a[i] * C(i - 1, i - 2) % mod * C(j - std::max(1, j - k), 1) % mod * A(n - (j - std::max(1, j - k) + 1), i - 2) % mod * fac[n - i] % mod) %= mod;\n    &#125;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"b---existence-counting\">B - Existence Counting</h2>\n<p><a href=\"https://atcoder.jp/contests/arc174/tasks/arc174_e\" class=\"uri\">https://atcoder.jp/contests/arc174/tasks/arc174_e</a></p>\n<p>发现可以分类讨论。假设 <span class=\"math inline\">\\(a&#39;\\)</span> 中第一个异于 <span class=\"math inline\">\\(a\\)</span> 的位置为 <span class=\"math inline\">\\(i\\)</span>，<span class=\"math inline\">\\(x\\)</span> 在 <span class=\"math inline\">\\(a\\)</span> 中位置为 <span class=\"math inline\">\\(pos_x\\)</span>（不存在则 <span class=\"math inline\">\\(pos_x=k+1\\)</span>）。令 <span class=\"math inline\">\\(f_i\\)</span> 为若 <span class=\"math inline\">\\(1\\sim i-1\\)</span> 均相同，<span class=\"math inline\">\\(i\\)</span> 位置可选的选项数。则 <span class=\"math inline\">\\(x\\)</span> 出现的次数：</p>\n<table>\n<colgroup>\n<col style=\"width: 25%\" />\n<col style=\"width: 25%\" />\n<col style=\"width: 25%\" />\n<col style=\"width: 25%\" />\n</colgroup>\n<thead>\n<tr class=\"header\">\n<th style=\"text-align: center;\"></th>\n<th style=\"text-align: center;\"><span class=\"math inline\">\\(pos_x&lt;i\\)</span></th>\n<th style=\"text-align: center;\"><span class=\"math inline\">\\(pos_x=i\\)</span></th>\n<th style=\"text-align: center;\"><span class=\"math inline\">\\(pos_x&gt;i,i&lt;k\\)</span></th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td style=\"text-align: center;\"><span class=\"math inline\">\\(x\\le a_i\\)</span></td>\n<td style=\"text-align: center;\"><span class=\"math inline\">\\(1+f_i\\cdot A_{n-i}^{k-i}\\)</span></td>\n<td style=\"text-align: center;\"><span class=\"math inline\">\\(f_i\\cdot C_{k-i}^1\\cdot A_{n-i-1}^{k-i-1}\\)</span></td>\n<td style=\"text-align: center;\"><span class=\"math inline\">\\((f_i-1)\\cdot C_{k-i}^1\\cdot A_{n-i-1}^{k-i-1}+A_{n-i}^{k-i}\\)</span></td>\n</tr>\n<tr class=\"even\">\n<td style=\"text-align: center;\"><span class=\"math inline\">\\(x&gt;a_i\\)</span></td>\n<td style=\"text-align: center;\"><span class=\"math inline\">\\(f_i\\cdot A_{n-i}^{k-i}\\)</span></td>\n<td style=\"text-align: center;\"><span class=\"math inline\">\\(0\\)</span></td>\n<td style=\"text-align: center;\"><span class=\"math inline\">\\(f_i\\cdot C_{k-i}^1\\cdot A_{n-i-1}^{k-i-1}\\)</span></td>\n</tr>\n</tbody>\n</table>\n<p>故，对于任意 <span class=\"math inline\">\\(x\\)</span>，答案为：</p>\n<p><span class=\"math display\">\\[\n\\begin{aligned}\n&amp;1+\\left(\\sum_{i=pos_x+1}^k f_i\\cdot A_{n-i}^{k-i}\\right)\n+\\sum_{i=1}^{pos_x} (f_i-[x&lt; a_i])\\cdot C_{k-i}^1\\cdot A_{n-i-1}^{k-i-1}+[x&lt; a_i]\\cdot A_{n-i}^{k-i}\\\\\n=&amp;1+\\left(\\sum_{i=pos_x+1}^k f_i\\cdot A_{n-i}^{k-i}\\right)\n+\\left(\\sum_{i=1}^{pos_x} f_i\\cdot C_{k-i}^1\\cdot A_{n-i-1}^{k-i-1}\\right)+\\sum_{i=1,a_i&gt; x}^{pos_x}A_{n-i}^{k-i}-C_{k-i}^1\\cdot A_{n-i-1}^{k-i-1}\\\\\n\\end{aligned}\n\\]</span></p>\n<p>预处理出 <span class=\"math inline\">\\(f_i=\\sum\\limits_{j=i+1}^k [a_j&lt; a_i]\\)</span>（需要数据结构）、<span class=\"math inline\">\\(g_i=\\sum\\limits_{j=1}^i f_j\\cdot A_{n-j}^{k-j}\\)</span> 和 <span class=\"math inline\">\\(h_j=\\sum\\limits_{j=1}^i f_i\\cdot C_{k-i}^1\\cdot A_{n-i-1}^{k-i-1}\\)</span>，再用数据结构计算 <span class=\"math inline\">\\(\\sum\\limits_{i=1,a_i&gt;x}^{pos_x}C_{k-i}^1\\cdot A_{n-i-1}^{k-i-1} - A_{n-i}^{k-i}\\)</span> 即可。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 998244353;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, k;\n    std::cin &gt;&gt; n &gt;&gt; k;\n    std::vector&lt;int&gt; a(k + 1), p(n + 1, k + 1);\n    for (int i = 1; i &lt;= k; ++i)\n        std::cin &gt;&gt; a[i], p[a[i]] = i;\n    std::vector&lt;long long&gt; fac(n + 1), inv(n + 1);\n    &#123;\n        fac[0] = inv[0] = 1ll;\n        for (int i = 1; i &lt;= n; ++i)\n            fac[i] = fac[i - 1] * i % mod;\n        auto qkp = [](long long x, int y) &#123;\n            auto res(1ll);\n            for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n                if (y &amp; 1)\n                    (res *= x) %= mod;\n            return res;\n        &#125;;\n        inv[n] = qkp(fac[n], mod - 2);\n        for (int i = n - 1; i; --i)\n            inv[i] = inv[i + 1] * (i + 1) % mod;\n    &#125;\n    auto A = [&amp;](int n, int m) &#123;\n        if (n &lt; m || m &lt; 0)\n            return 0ll;\n        return fac[n] * inv[n - m] % mod;\n    &#125;;\n    std::vector&lt;long long&gt; f(k + 1), g(k + 1), h(k + 1);\n    std::vector&lt;long long&gt; bit(n + 1);\n    auto lowbit = [](int x) &#123;\n        return x &amp; -x;\n    &#125;;\n    auto add = [&amp;](int x, int v) &#123;\n        for (; x &lt;= n; x += lowbit(x))\n            (bit[x] += v) %= mod;\n        return;\n    &#125;;\n    auto ask = [&amp;](int x) &#123;\n        auto res(0ll);\n        for (; x; x -= lowbit(x))\n            (res += bit[x]) %= mod;\n        return res;\n    &#125;;\n    for (int i = 1; i &lt;= n; ++i)\n        if (p[i] == k + 1)\n            add(i, 1);\n    for (int i = k; i; --i)\n        f[i] = ask(a[i]), add(a[i], 1);\n    for (int i = 1; i &lt;= k; ++i) &#123;\n        g[i] = (g[i - 1] + f[i] * A(n - i, k - i)) % mod;\n        h[i] = (h[i - 1] + f[i] * (k - i) % mod * A(n - i - 1, k - i - 1)) % mod;\n        // printf(&quot;%d: f = %lld, g = %lld, h = %lld\\n&quot;, i, f[i], g[i], h[i]);\n    &#125;\n    std::vector&lt;long long&gt; res(n + 1);\n    bit.assign(n + 1, 0ll);\n    auto s(0ll);\n    for (int i = 1; i &lt;= k; ++i) &#123;\n        // printf(&quot;%d: %lld + %lld + %lld\\n&quot;, a[i], 1 + g[k] - g[i], h[i], s - ask(a[i]));\n        res[a[i]] = (1 + g[k] - g[i] + h[i] + (s - ask(a[i]))) % mod;\n        res[a[i]] = (res[a[i]] + mod) % mod;\n        (s += A(n - i, k - i) - (k - i) * A(n - i - 1, k - i - 1)) %= mod;\n        add(a[i], (A(n - i, k - i) - (k - i) * A(n - i - 1, k - i - 1)) % mod);\n    &#125;\n    for (int i = 1; i &lt;= n; ++i)\n        if (p[i] == k + 1) &#123;\n            res[i] = (h[k] + (s - ask(i))) % mod;\n            res[i] = (res[i] + mod) % mod;\n        &#125;\n    for (int x = 1; x &lt;= n; ++x)\n        std::cout &lt;&lt; res[x] &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"c---1-loop-bubble-sort\">C - 1 Loop Bubble Sort</h2>\n<p><a href=\"https://atcoder.jp/contests/arc187/tasks/arc187_c\" class=\"uri\">https://atcoder.jp/contests/arc187/tasks/arc187_c</a></p>\n<p>首先是被考烂了的：对序列进行一次冒泡排序，等价于将序列在前缀最大值处分段，并将其从段首移到段尾；且满足排序前为前缀最大值的元素，排序后仍为前缀最大值。</p>\n<p>考虑用 DP 解决问题。注意状态要从 <span class=\"math inline\">\\(P\\)</span> 的角度出发——假如 <span class=\"math inline\">\\(Q\\)</span> 中不存在 <span class=\"math inline\">\\(-1\\)</span>，发现也需要 DP。此时再设计有关 <span class=\"math inline\">\\(Q\\)</span> 的状态就很扯淡了，考虑令 <span class=\"math inline\">\\(f_{i,j}\\)</span> 表示 <span class=\"math inline\">\\(P\\)</span> 中直到第 <span class=\"math inline\">\\(i\\)</span> 位的前缀最大值为 <span class=\"math inline\">\\(j\\)</span> 的方案数。为什么把前缀最大值作为状态呢？因为它可以表示分段；同时限制段间数的取值。具体地，考虑转移：</p>\n<ol type=\"1\">\n<li>若令 <span class=\"math inline\">\\(P_i=j\\)</span>，则在 <span class=\"math inline\">\\(i\\)</span> 处分段。对应到 <span class=\"math inline\">\\(Q\\)</span> 中，<span class=\"math inline\">\\(i-1\\)</span> 位是上一个前缀最大值，那么这要求 <span class=\"math inline\">\\(Q_{i-1}&lt;j\\)</span>，且 <span class=\"math inline\">\\(Q_{i-1}\\)</span> 是一个前缀最大值。也即：当 <span class=\"math inline\">\\(Q_{i-1}\\ne -1\\)</span> 时，<span class=\"math inline\">\\(f_{i,j}\\gets f_{i-1, Q_{i-1}}\\)</span>；否则，<span class=\"math inline\">\\(f_{i,j}\\gets \\sum\\limits_{k&lt;j} f_{i-1,k}\\)</span>。其中，二式都要求转移来源为前缀最大值。</li>\n<li>若令 <span class=\"math inline\">\\(P_i&lt;j\\)</span>，则 <span class=\"math inline\">\\(i\\)</span> 在 <span class=\"math inline\">\\(Q\\)</span> 中恰好前移一位，即 <span class=\"math inline\">\\(Q_{i-1}=P_i&lt;j\\)</span>。则当 <span class=\"math inline\">\\(Q_{i-1}\\ne -1\\)</span> 时，该位确定，<span class=\"math inline\">\\(f_{i,j}\\gets f_{i-1,j}\\)</span>；否则，<span class=\"math inline\">\\(Q_{i-1}\\)</span> 可选的值为 <span class=\"math inline\">\\(&lt;j\\)</span> 的所有未选数（定值，可预处理）。</li>\n</ol>\n<p>关于初值，可以在 <span class=\"math inline\">\\(P\\)</span> 前加一个 <span class=\"math inline\">\\(0\\)</span> 作为排列的一部分（那么按照冒泡排序的规则 <span class=\"math inline\">\\(Q\\)</span> 的第一位也一定是 <span class=\"math inline\">\\(0\\)</span>）来处理就好了。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 998244353;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;int&gt; q(n + 1), t(n + 1), c(n + 1), pos(n + 1);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; q[i], c[i] = c[i - 1];\n        if (q[i] == -1)\n            ++c[i];\n        else\n            pos[q[i]] = i;\n    &#125;\n    for (int i = 1; i &lt; n; ++i) &#123;\n        // printf(&quot;t[%d] = %d\\n&quot;, i, t[i]);\n        if (!pos[i])\n            for (int j = i + 1; j &lt;= n; ++j)\n                ++t[j];\n    &#125;\n    std::vector&lt;std::vector&lt;long long&gt; &gt; f(n + 1, std::vector&lt;long long&gt; (n + 1)), s(n + 1, std::vector&lt;long long&gt; (n + 1));\n    f[0][0] = 1ll;\n    s[0].assign(n + 1, 1ll);\n    for (int i = 1; i &lt;= n; ++i)\n        for (int j = 1; j &lt;= n; ++j) &#123;\n            if (q[i - 1] == -1)\n                f[i][j] = (s[i - 1][j - 1] + f[i - 1][j] * std::max(0, 1 + t[j] - c[i - 1])) % mod;\n            else if (q[i - 1] &lt; j)\n                f[i][j] = (f[i - 1][q[i - 1]] + f[i - 1][j]) % mod;\n            s[i][j] = s[i][j - 1];\n            if (q[i] == j || !pos[j]) // 满足前缀最大值\n                (s[i][j] += f[i][j]) %= mod;\n            // printf(&quot;f[%d][%d] = %lld\\n&quot;, i, j, f[i][j]);\n        &#125;\n    std::cout &lt;&lt; f[n][n] &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"f---1.-intro\">(F - 1). Intro</h2>\n<blockquote>\n<p>给定一个大小为 <span class=\"math inline\">\\(n\\)</span> 的树，点有点权。给定 <span class=\"math inline\">\\(q\\)</span> 次操作，分为两种：</p>\n<ol type=\"1\">\n<li><code>1 x</code>：查询 <span class=\"math inline\">\\(x\\)</span> 的点权。</li>\n<li><code>2 x d v</code> 对于所有距 <span class=\"math inline\">\\(x\\)</span> 不超过 <span class=\"math inline\">\\(d\\)</span> 的点，将它们的权值加上 <span class=\"math inline\">\\(v\\)</span>。</li>\n</ol>\n<p><span class=\"math inline\">\\(n,q\\le 10^5,d\\le 20\\)</span>。</p>\n</blockquote>\n<p>由于 <span class=\"math inline\">\\(d\\)</span> 很小，我们可能需要枚举与 <span class=\"math inline\">\\(x\\)</span> 距离 <span class=\"math inline\">\\(0\\sim d\\)</span> 的点进行修改；那么对距离 <span class=\"math inline\">\\(x\\)</span> 为 <span class=\"math inline\">\\(i\\)</span> 的点的更改存储在 <span class=\"math inline\">\\(f_{x,i}\\)</span>，查询 <span class=\"math inline\">\\(v\\)</span> 时就可以从 <span class=\"math inline\">\\(\\sum\\limits_i f_{fa(v,i),i}\\)</span> 求得答案。</p>\n<p>考虑修改。记 <span class=\"math inline\">\\(S_{x,d}\\)</span> 为距 <span class=\"math inline\">\\(x\\)</span> 为 <span class=\"math inline\">\\(d\\)</span> 的点集。<span class=\"math inline\">\\(x\\)</span> 子树内是好处理的，但子树外的呢？发现 <span class=\"math inline\">\\(S_{fa,d-1}\\)</span> 中 <span class=\"math inline\">\\(x\\)</span> 子树外的点，就是 <span class=\"math inline\">\\(fa\\)</span> 子树下、<span class=\"math inline\">\\(x\\)</span> 子树外距离 <span class=\"math inline\">\\(x\\)</span> 为 <span class=\"math inline\">\\(d\\)</span> 的所有点。</p>\n<p>由于所有 <span class=\"math inline\">\\(S_{fa(x,i),d-i}\\)</span> 无交，这可能满足我们每个待操作点被不重不漏加一次的要求。考虑将所有 <span class=\"math inline\">\\(S_{fa(x,i),d-i}\\)</span> 标记出来：</p>\n<figure>\n<img src=\"1.png\" alt=\"粉色虚线框是待操作点集\" /><figcaption>粉色虚线框是待操作点集</figcaption>\n</figure>\n<p>然后我们可以一眼发现被叉的点和未被叉的待操作点是交错的！这意味着我们只需要再补充上所有 <span class=\"math inline\">\\(S_{fa(x,i),d-i-1}\\)</span> 即可（显然它们之间、它们和所有 <span class=\"math inline\">\\(S_{fa(x,i),d-i}\\)</span> 之间都不交）。</p>\n<figure>\n<img src=\"2.png\" alt=\"虚线叉为 S_{fa(x,i),d-i-1}\" /><figcaption>虚线叉为 <span class=\"math inline\">\\(S_{fa(x,i),d-i-1}\\)</span></figcaption>\n</figure>\n<p>此时就可以不重不漏。当然，也会存在一些细节：比如说 <span class=\"math inline\">\\(fa(x,i)\\)</span> 不存在之类。只需要在根节点 <span class=\"math inline\">\\(1\\)</span> 处将剩余的 <span class=\"math inline\">\\(S_{1,i\\to 0}\\)</span> 全部更新即可。</p>\n<p>故每次修改操作只需要修改 <span class=\"math inline\">\\(O(d)\\)</span> 坨点。时间复杂度 <span class=\"math inline\">\\(O(qd)\\)</span>。</p>\n<hr />\n<h2 id=\"f.-distance-to-the-path\">F. Distance to the Path</h2>\n<p><a href=\"https://codeforces.com/problemset/problem/1749/F\" class=\"uri\">https://codeforces.com/problemset/problem/1749/F</a></p>\n<p>本例中将单点修改替换为路径修改；考虑树剖解决问题。</p>\n<p>对于路径上的所有点 <span class=\"math inline\">\\(u\\)</span>，容易发现只需要修改所有的 <span class=\"math inline\">\\(S_{u,d}\\)</span> 就可以完成对『<strong>一部分路径内侧的点</strong>』的修改。这『一部分』，是因为不包括距离 LCA <span class=\"math inline\">\\(\\le d\\)</span> 的点。</p>\n<p>而『<strong>另一部分路径内侧的点</strong>（距 LCA <span class=\"math inline\">\\(\\le d\\)</span>：见上一行说明）』及『<strong>路径外侧的点</strong>（距 LCA <span class=\"math inline\">\\(\\le d\\)</span>：因为路径在 LCA 子树内，LCA 能够到最远的外侧点）』，等价于『<strong>距 LCA <span class=\"math inline\">\\(\\le d\\)</span> 的点</strong>』，只需要把 LCA 代入上例中方式修改即可。</p>\n<p>修改路径上所有点 <span class=\"math inline\">\\(u\\)</span> 的 <span class=\"math inline\">\\(S_{u,d}\\)</span> 时，可以对所有 <span class=\"math inline\">\\(f_{*,i}\\)</span> 建立数据结构，由于只需要区间修改、单点查询，使用差分树状数组即可。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt; \nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, m;\n    std::cin &gt;&gt; n;\n    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);\n    for (int i = 1, x, y; i &lt; n; ++i) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y;\n        g[x].push_back(y), g[y].push_back(x);\n    &#125;\n    std::vector&lt;int&gt; siz(n + 1), dep(n + 1), fa(n + 1), son(n + 1);\n    std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int faa) &#123;\n        siz[x] = 1;\n        for (auto i : g[x])\n            if (i != faa) &#123;\n                fa[i] = x, dep[i] = dep[x] + 1;\n                DFS(i, x);\n                siz[x] += siz[i];\n                if (siz[i] &gt; siz[son[x]])\n                    son[x] = i;\n            &#125;\n        return;\n    &#125;;\n    DFS(1, -1);\n    std::vector&lt;int&gt; dfn(n + 1), top(n + 1);\n    DFS = [&amp;](int x, int toop) &#123;\n        static int now = 0;\n        dfn[x] = ++now, top[x] = toop;\n        if (son[x])\n            DFS(son[x], toop);\n        for (auto i : g[x])\n            if (i != fa[x] &amp;&amp; i != son[x])\n                DFS(i, i);\n        return;\n    &#125;;\n    DFS(1, 1);\n    std::vector&lt;std::vector&lt;long long&gt; &gt; bit(21, std::vector&lt;long long&gt; (n + 1));\n    auto lowbit = [&amp;](int x) &#123;\n        return x &amp; -x;\n    &#125;;\n    auto add = [&amp;](auto &amp;bit, int x, int v) &#123;\n        for (; x &lt;= n; x += lowbit(x))\n            bit[x] += v;\n        return;\n    &#125;;\n    auto ask = [&amp;](auto &amp;bit, int x) &#123;\n        auto res(0ll);\n        for (; x; x -= lowbit(x))\n            res += bit[x];\n        return res;\n    &#125;;\n    std::cin &gt;&gt; m;\n    for (int op; m--; ) &#123;\n        std::cin &gt;&gt; op;\n        if (op == 1) &#123;\n            int x;\n            std::cin &gt;&gt; x;\n            auto res(0ll);\n            for (int i = 0; i &lt;= 20 &amp;&amp; x; ++i, x = fa[x])\n                res += ask(bit[i], dfn[x]);\n            std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n        &#125;\n        else &#123;\n            int x, y, v, d;\n            std::cin &gt;&gt; x &gt;&gt; y &gt;&gt; v &gt;&gt; d;\n            for (; top[x] != top[y]; x = fa[top[x]]) &#123;\n                if (dep[top[x]] &lt; dep[top[y]])\n                    std::swap(x, y);\n                add(bit[d], dfn[top[x]], v);\n                add(bit[d], dfn[x] + 1, -v);\n            &#125;\n            if (dep[x] &gt; dep[y])\n                std::swap(x, y);\n            add(bit[d], dfn[x] + 1, v), add(bit[d], dfn[y] + 1, -v);\n            for (x = x, y = d; ~y &amp;&amp; x; x = fa[x], --y) &#123;\n                add(bit[y], dfn[x], v), add(bit[y], dfn[x] + 1, -v);\n                if (y &amp;&amp; fa[x])\n                    add(bit[y - 1], dfn[x], v), add(bit[y - 1], dfn[x] + 1, -v);\n            &#125;\n            if (x == 0)\n                for (; ~y; --y)\n                    add(bit[y], dfn[1], v), add(bit[y], dfn[1] + 1, -v);\n        &#125;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"a---ina-of-the-mountain\">A - Ina of the Mountain</h2>\n<p><a href=\"https://codeforces.com/problemset/problem/1852/C\" class=\"uri\">https://codeforces.com/problemset/problem/1852/C</a></p>\n<p>考虑这么一个简化版的问题：</p>\n<blockquote>\n<p>给定 <span class=\"math inline\">\\(\\{a_n\\}\\)</span>，每次可以进行区间 <span class=\"math inline\">\\(-1\\)</span>，问操作多少次才能将所有元素变为 <span class=\"math inline\">\\(0\\)</span>。</p>\n</blockquote>\n<p>会想到差分；对原数组进行差分，一次操作相当于令 <span class=\"math inline\">\\(d_l\\gets d_l-1\\)</span> 而 <span class=\"math inline\">\\(d_{r+1}\\gets d_{r+1}+1\\)</span>，最后要让 <span class=\"math inline\">\\(\\forall \\,d_i=0\\)</span>。那么答案就是差分数组中正数之和嘛。</p>\n<p>回到原问题。原问题等价于把上述问题变为：</p>\n<blockquote>\n<p>给定 <span class=\"math inline\">\\(\\{a_n\\}\\)</span>，每次可以进行区间 <span class=\"math inline\">\\(-1\\)</span>，每个数的总操作次数对 <span class=\"math inline\">\\(k\\)</span> 取模，问操作多少次才能将所有元素变为 <span class=\"math inline\">\\(0\\)</span>。</p>\n</blockquote>\n<p>怎么套回到刚刚的问题上呢？还原被取模掉的操作即可。具体来说，提前在 <span class=\"math inline\">\\(d\\)</span> 上进行若干次操作（记为操作 1），形如令 <span class=\"math inline\">\\(d_i\\gets d_i+k\\)</span>，同时 <span class=\"math inline\">\\(d_{i+1}\\gets d_{i+1}-k\\)</span>。</p>\n<p>会发现相邻的操作 <span class=\"math inline\">\\(1\\)</span> 对一个数加加减减影响判断；发现可以合并一段连续的操作 1，表现在 <span class=\"math inline\">\\(a\\)</span> 上也就是区间 <span class=\"math inline\">\\(+k\\)</span>。此时可以发现，一个位置上只会剩下若干次 <span class=\"math inline\">\\(+k\\)</span> 或若干次 <span class=\"math inline\">\\(-k\\)</span> （否则可以把 <span class=\"math inline\">\\(+k\\)</span> 和 <span class=\"math inline\">\\(-k\\)</span> 代表的不同操作合并），就不会有互相影响一说了。这也是有的题解说可以提前在 <span class=\"math inline\">\\(a\\)</span> 上区间 <span class=\"math inline\">\\(+k\\)</span> 的原因。</p>\n<p>此时问题变为在 <span class=\"math inline\">\\(d\\)</span> 进行任意次前加 <span class=\"math inline\">\\(k\\)</span> 后减 <span class=\"math inline\">\\(k\\)</span> 的操作，使得 <span class=\"math inline\">\\(\\sum\\limits_{d_i&gt;0}d_i\\)</span> 最大化。那么显然如果要使代价更小，只可能在原本 <span class=\"math inline\">\\(&lt;0\\)</span> 的位置做加法、<span class=\"math inline\">\\(&gt;0\\)</span> 的位置做减法（其他情况会发现一定不优）。考虑两个数 <span class=\"math inline\">\\(d_l,d_r\\)</span>，可以感受到对于一个 <span class=\"math inline\">\\(r\\)</span>，选最小的 <span class=\"math inline\">\\(d_l\\)</span> 是最优的，但什么时候应该选呢？</p>\n<ul>\n<li><span class=\"math inline\">\\(d_l\\le -k,d_r\\ge k\\)</span>：当然可选，<span class=\"math inline\">\\(k\\)</span> 被完全利用，答案减少 <span class=\"math inline\">\\(k\\)</span>。</li>\n<li><p><span class=\"math inline\">\\(d_l&gt;-k,d_r\\ge k\\)</span>：此时 <span class=\"math inline\">\\(k\\)</span> 未被完全利用，但必须选：选择其他更大的数，<span class=\"math inline\">\\(k\\)</span> 的利用率只会更低；如果不选，答案也无法减少。</p>\n<p>Q：此时是否需要尝试找到一个 <span class=\"math inline\">\\(l&#39;&lt;l\\)</span> 与 <span class=\"math inline\">\\(l\\)</span> 做操作，使得 <span class=\"math inline\">\\(l\\)</span> 重新变为负数呢？</p>\nA：否。因为你可以将这两次操作合并，发现相当于是直接对 <span class=\"math inline\">\\((l&#39;,r)\\)</span> 做操作，是更劣的。</li>\n<li><span class=\"math inline\">\\(d_l\\le -k,d_r&lt;k\\)</span>：此时 <span class=\"math inline\">\\(k\\)</span> 未被完全利用，<span class=\"math inline\">\\(d_r\\)</span> 成为负数。这意味着 <span class=\"math inline\">\\(d_r\\)</span> 将会成为某个 <span class=\"math inline\">\\(r&#39;\\)</span> 的可选项。考察 <span class=\"math inline\">\\(d_{r&#39;}\\)</span> 可用的最小值。如果 <span class=\"math inline\">\\(d_r\\)</span> 在当前不应该作为右端点，它就一定会被 <span class=\"math inline\">\\(d_{r&#39;}\\)</span> 选择。具体的有点抽象，但是你可以理解为 <span class=\"math inline\">\\(d_r\\)</span> 选了 <span class=\"math inline\">\\(d_l\\)</span> 的贡献是被整合到 <span class=\"math inline\">\\(d_r\\)</span> 里的；如果 <span class=\"math inline\">\\(d_r\\)</span> 被选了就说明 <span class=\"math inline\">\\(d_{r&#39;}\\)</span> 选 <span class=\"math inline\">\\(d_l\\)</span> 会拥有更大的优势。</li>\n<li><p><span class=\"math inline\">\\(d_l&gt;-k,d_r&lt;k\\)</span>：和上面的情况相似；但这种情况下答案可能反而变得更大，因为没有后效性，所以至少要保证单步最优。此时不能选。</p>\n<p>说到单步最优，就会发现这里就是反悔贪心；单步最优一定是全局最优，但更靠前的局部最优可能被否定掉。而『否定』的方法表现为一次操作。</p></li>\n</ul>\n<p>综上，从前往后扫，优先队列实时维护负数最小值，对于每个正数，check 选最小值是否优于当前答案，有就选。如果正数被减为负，加入队列。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int T;\n    for (std::cin &gt;&gt; T; T--; ) &#123;\n        int n, k;\n        std::cin &gt;&gt; n &gt;&gt; k;\n        std::vector&lt;int&gt; a(n + 1), d(n + 1);\n        long long res(0ll);\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            std::cin &gt;&gt; a[i], a[i] %= k;\n            d[i] = a[i] - a[i - 1];\n            if (d[i] &gt; 0)\n                (res += d[i]);\n        &#125;\n        std::priority_queue&lt;int&gt; q;\n        for (int i = 1; i &lt;= n; ++i)\n            if (d[i] &lt; 0)\n                q.push(-d[i]);\n            else &#123;\n                for (; !q.empty() &amp;&amp; d[i] &gt; 0; ) &#123;\n                    int x = -q.top(), y = d[i];\n                    auto t(res - y);\n                    x += k, y -= k;\n                    if (x &gt; 0)\n                        t += x;\n                    if (y &gt; 0)\n                        t += y;\n                    if (t &gt;= res)\n                        break;\n                    q.pop();\n                    res = t, d[i] = y;\n                    if (d[i] &lt; 0)\n                        q.push(-d[i]);\n                &#125;\n            &#125;\n        std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"b---miriany-and-matchstick\">B - Miriany and Matchstick</h2>\n<p><a href=\"https://codeforces.com/problemset/problem/1852/D\" class=\"uri\">https://codeforces.com/problemset/problem/1852/D</a></p>\n<p>从构造的角度出发，看到『恰好为 <span class=\"math inline\">\\(k\\)</span>』，会想到找到上界和下界并证明中间每一个数都能取到。</p>\n<p>但似乎很容易证伪：例如对于 <code>AAAA</code>，下界为 <span class=\"math inline\">\\(0\\)</span>，上界为 <span class=\"math inline\">\\(4\\)</span>，但有且仅有 <span class=\"math inline\">\\(1\\)</span> 取不到。但该想法并未破产——可以感受到这样的位置很少。进一步地，你 <a href=\"https://www.luogu.com.cn/article/2mmg5rjd\">可以证明只有一个这样的位置</a>，也可以 <a href=\"https://www.luogu.com.cn/article/679cwjgl\">大胆猜想这样的位置一定出现在 <span class=\"math inline\">\\(l+1\\)</span>，<span class=\"math inline\">\\(r-1\\)</span></a>。总之现在我们的状态就减少了（或者说状态变成 DP 值了）。预处理出这个东西之后大力搜索找方案即可。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int T;\n    for (std::cin &gt;&gt; T; T--; ) &#123;\n        int n, k;\n        std::cin &gt;&gt; n &gt;&gt; k;\n        std::vector&lt;int&gt; a(n + 1);\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            char t;\n            std::cin &gt;&gt; t, a[i] = (t == &#39;A&#39;);\n            if (i &gt;= 2)\n                k -= (a[i] ^ a[i - 1]);\n        &#125;\n        std::vector&lt;std::array&lt;std::tuple&lt;int, int, int&gt;, 2&gt; &gt; f(n + 1);\n        f[n][0] = &#123; a[n], a[n], 0 &#125;, f[n][1] = &#123; !a[n], !a[n], 0 &#125;;\n        auto merge = [&amp;](int i, int l0, int r0, int p0, int l1, int r1, int p1) &#123;\n            if (l0 &gt; l1)\n                std::swap(l0, l1), std::swap(r0, r1), std::swap(p0, p1);\n            int l = l0, r = std::max(r0, r1), p = 0;\n            if (!p0 &amp;&amp; !p1) &#123;\n                if (r0 &lt; l1 - 1)\n                    assert(r0 == l1 - 2), p = r0 + 1;\n                else;\n            &#125;\n            else if (p0 &amp;&amp; p1) &#123;\n                if (p0 == p1)\n                    p = p0;\n                else &#123;\n                    int tag0 = (l1 &lt;= p0 &amp;&amp; p0 &lt;= r1), tag1 = (l0 &lt;= p1 &amp;&amp; p1 &lt;= r0);\n                    if (!tag0 &amp;&amp; !tag1);\n                    else if (!tag0)\n                        p = p0;\n                    else if (!tag1)\n                        p = p1;\n                    else;\n                &#125;\n            &#125;\n            else if (p0) &#123;\n                if (l1 &lt;= p0 &amp;&amp; p0 &lt;= r1);\n                else\n                    p = p0;\n            &#125;\n            else &#123;\n                if (l0 &lt;= p1 &amp;&amp; p1 &lt;= r0);\n                else\n                    p = p1;\n            &#125;\n            assert(p != l &amp;&amp; p != r &amp;&amp; l &lt;= r);\n            return std::make_tuple(l, r, p);\n        &#125;;\n        for (int i = n - 1; i; --i) &#123;\n            &#123;\n                auto [l0, r0, p0] = f[i + 1][0];\n                auto [l1, r1, p1] = f[i + 1][1];\n                if (a[i]) &#123;\n                    ++l0, ++r0, ++l1, ++r1;\n                    if (p0) ++p0;\n                    if (p1) ++p1;\n                &#125;\n                ++l1, ++r1;\n                if (p1) ++p1;\n                f[i][0] = merge(i, l0, r0, p0, l1, r1, p1);\n            &#125;\n            &#123;\n                auto [l0, r0, p0] = f[i + 1][0];\n                auto [l1, r1, p1] = f[i + 1][1];\n                if (!a[i]) &#123;\n                    ++l0, ++r0, ++l1, ++r1;\n                    if (p0) ++p0;\n                    if (p1) ++p1;\n                &#125;\n                ++l0, ++r0;\n                if (p0) ++p0;\n                f[i][1] = merge(i, l0, r0, p0, l1, r1, p1);\n            &#125;\n        &#125;\n        std::vector&lt;int&gt; res(n + 1);\n        std::function&lt;bool(int, int, int)&gt; DFS = [&amp;](int x, int cnt, int la) &#123;\n            if (x == n + 1)\n                return cnt == k;\n            auto [l0, r0, p0] = f[x][0];\n            auto [l1, r1, p1] = f[x][1];\n            if (cnt + (la == 1) + l0 &lt;= k &amp;&amp; cnt + (la == 1) + r0 &gt;= k &amp;&amp; (!p0 || cnt + (la == 1) + p0 != k) &amp;&amp; DFS(x + 1, cnt + (la == 1) + a[x], 0))\n                res[x] = 0;\n            else if (cnt + !la + l1 &lt;= k &amp;&amp; cnt + !la + r1 &gt;= k &amp;&amp; (!p1 || cnt + !la + p1 != k) &amp;&amp; DFS(x + 1, cnt + !la + !a[x], 1))\n                res[x] = 1;\n            else\n                return false;\n            return true;\n        &#125;;\n        if (DFS(1, 0, -1)) &#123;\n            std::cout &lt;&lt; &quot;YES\\n&quot;;\n            for (int i = 1; i &lt;= n; ++i)\n                std::cout &lt;&lt; (res[i] ? &#39;A&#39; : &#39;B&#39;);\n            std::cout &lt;&lt; &#39;\\n&#39;;\n        &#125;\n        else\n            std::cout &lt;&lt; &quot;NO\\n&quot;;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n",
            "tags": [
                "DP",
                "容斥原理",
                "树链剖分",
                "反悔贪心"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20241021-1/",
            "url": "https://xsc062.netlify.app/20241021-1/",
            "title": "长链剖分 学习笔记",
            "date_published": "2024-10-21T08:33:47.000Z",
            "content_html": "<p><em>半端な生命の関数を / 少々ここらでオーバーライド</em></p>\n<span id=\"more\"></span>\n<hr />\n<h2 id=\"内容-性质\">内容 &amp; 性质</h2>\n<p>把重链剖分选的 siz 最大的儿子换成高度最大的儿子就是长剖了。同样具有一些美妙的性质。</p>\n<ul>\n<li><p>任意点到根节点经过的链数最劣为 <span class=\"math inline\">\\(\\sqrt n\\)</span>。</p>\n<p>考虑构造一条经过了 <span class=\"math inline\">\\(\\sqrt n+1\\)</span> 条链的路径，发现构造不出来。得证。（？）</p>\n这点也决定了长剖和重剖走的不是一条赛道，更多的是处理一些和深度有关的场景下的问题。用法有点像 dsu on tree。</li>\n<li><p>任意点 <span class=\"math inline\">\\(x\\)</span> 的 <span class=\"math inline\">\\(k\\)</span> 级祖先 <span class=\"math inline\">\\(fa\\)</span> 所在链长 <span class=\"math inline\">\\(\\ge k\\)</span>。</p>\n<p>考虑反证。若 <span class=\"math inline\">\\(fa\\)</span> 所在链长度 <span class=\"math inline\">\\(&lt;k\\)</span>，则 <span class=\"math inline\">\\(fa\\to x\\)</span> 更优，矛盾。故原命题成立。</p></li>\n</ul>\n<hr />\n<h2 id=\"求-k-级祖先\">求 k 级祖先</h2>\n<p>长剖的一个典型应用是 <span class=\"math inline\">\\(O(n\\log n)-O(1)\\)</span> 求 <span class=\"math inline\">\\(k\\)</span> 级祖先。先考虑相对暴力的做法，可以 <span class=\"math inline\">\\(O(n\\sqrt n)\\)</span> 预处理每个点的 <span class=\"math inline\">\\(1\\sim \\sqrt n\\)</span> 级祖先然后块间块内随便跳一跳就是 <span class=\"math inline\">\\(O(\\sqrt n)\\)</span> 的单次查询了。</p>\n<p>把这个暴力结合「任意点 <span class=\"math inline\">\\(k\\)</span> 级祖先所在链长 <span class=\"math inline\">\\(\\ge k\\)</span>」的性质，令 <span class=\"math inline\">\\(r=\\dfrac k2\\)</span>，那么 <span class=\"math inline\">\\(x\\)</span> 的 <span class=\"math inline\">\\(r\\)</span> 级祖先所在链长 <span class=\"math inline\">\\(\\ge r\\)</span>。假设我们现在已经知道 <span class=\"math inline\">\\(r\\)</span> 级祖先 <span class=\"math inline\">\\(fa_r\\)</span>，预处理出链内点序列、链顶向上的链长个祖先（均摊 <span class=\"math inline\">\\(O(n)\\)</span>），就可以 <span class=\"math inline\">\\(O(1)\\)</span> 访问 <span class=\"math inline\">\\(fa_k\\)</span>。</p>\n<p>怎么找到 <span class=\"math inline\">\\(fa_r\\)</span> 呢？这看似是递归的问题，实际上发现 <span class=\"math inline\">\\(r\\)</span> 的取值只需 <span class=\"math inline\">\\(\\ge \\dfrac k2\\)</span>，对于 <span class=\"math inline\">\\(1\\sim n\\)</span> 的每一个 <span class=\"math inline\">\\(k\\)</span>，找到其最高二进制位 <span class=\"math inline\">\\(r\\)</span>（显然 <span class=\"math inline\">\\(r\\)</span> 的可能取值有 <span class=\"math inline\">\\(\\log n\\)</span> 种），对于每个点，预处理出其 <span class=\"math inline\">\\(\\log n\\)</span> 个不同的 <span class=\"math inline\">\\(r\\)</span> 级祖先。这个就是倍增了。</p>\n<details>\n<pre class=\"cpp\"><code>for (int i = 1, mx = 0; i &lt;= n; ++i) &#123;\n    if (i &gt;= (1 &lt;&lt; mx) * 2)\n        ++mx;\n    to[i] = mx;\n&#125;\nstd::vector&lt;std::array&lt;int, 21&gt; &gt; fa(n + 1);\nstd::vector&lt;int&gt; h(n + 1, 1), son(n + 1), dep(n + 1);\nh[0] = 0;\nstd::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;\n    for (auto i : g[x])\n        if (i != fa[x][0]) &#123;\n            fa[i][0] = x;\n            for (int j = 1; j &lt;= 20; ++j)\n                fa[i][j] = fa[fa[i][j - 1]][j - 1];\n            dep[i] = dep[x] + 1;\n            DFS(i);\n            if (h[i] &gt;= h[son[x]])\n                son[x] = i, h[x] = h[i] + 1;\n        &#125;\n    return;\n&#125;;\ndep[1] = 1, DFS(1);\nstd::vector&lt;int&gt; top(n + 1), id(n + 1);\nstd::vector&lt;std::vector&lt;int&gt; &gt; anc(n + 1), des(n + 1, std::vector&lt;int&gt; (1));\nstd::function&lt;void(int, int)&gt; DFS1 = [&amp;](int x, int toq) &#123;\n    top[x] = toq;\n    if (son[x])\n        DFS1(son[x], toq);\n    for (auto i : g[x])\n        if (i != fa[x][0] &amp;&amp; i != son[x])\n            DFS1(i, i);\n    des[toq].push_back(x);\n    id[x] = (int)des[toq].size() - 1;\n    if (x == toq) &#123;\n        anc[x].push_back(x);\n        for (int j = 1, now = x; j &lt;= id[x]; ++j, now = fa[now][0])\n            anc[x].push_back(fa[now][0]);\n    &#125;\n    return;\n&#125;;\nDFS1(1, 1);\nauto ask = [&amp;](int x, int k) &#123;\n    int x1 = x;\n    if (!k)\n        return x;\n    x = fa[x][to[k]];\n    if (dep[x] - dep[top[x]] &gt;= k - (1 &lt;&lt; to[k]))\n        return des[top[x]][id[x] + k - (1 &lt;&lt; to[k])];\n    return anc[top[x]][k - (1 &lt;&lt; to[k]) - (dep[x] - dep[top[x]])];\n&#125;;</code></pre>\n</details>\n<hr />\n<h2 id=\"优化-dp\">优化 DP</h2>\n<blockquote>\n<p>yly：管它这那的，只要是有关深度直接上长剖就是了。</p>\n</blockquote>\n<p>和 DSU on tree 类似，主要利用每条链只会被算一次实现 <span class=\"math inline\">\\(O(n)\\)</span> DP。具体地，尽可能地『继承』长链的信息，『短链』则暴力合并。</p>\n<p>值得注意的是，一般『深度』这一维信息会以『与 <span class=\"math inline\">\\(u\\)</span> 的距离』的形式，结合指针来维护（因为直接记录深度会更史）。</p>\n<p>具体地，用一个全局大数组容纳所有信息，为每个点分配相应的数组头指针。正常情况下需要用到的元素最多为 <span class=\"math inline\">\\(2n\\)</span>，但如果存在一些诡异的前移后移操作就另当别论了。</p>\n<hr />\n<h3 id=\"p5904-poi-2014-hot-hotels-加强版\">P5904 [POI 2014] HOT-Hotels 加强版</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P5904\" class=\"uri\">https://www.luogu.com.cn/problem/P5904</a></p>\n<p>首先 <del>不难</del> 得到 <span class=\"math inline\">\\(O(n^2)\\)</span> 做法：显然存在一个点到三个点距离相等。这个点既可能是它们的 LCA，也可能是其中一个点的子孙，另外两个点的 LCA。综上，<strong>在 LCA 处统计答案是可行的</strong>。</p>\n<p>令 <span class=\"math inline\">\\(f_{i,j}\\)</span> 表示 <span class=\"math inline\">\\(i\\)</span> 子树中距离 <span class=\"math inline\">\\(i\\)</span> 为 <span class=\"math inline\">\\(j\\)</span> 的点数；<span class=\"math inline\">\\(g_{i,j}\\)</span> 表示 <span class=\"math inline\">\\(i\\)</span> 子树中距离 <span class=\"math inline\">\\(i\\)</span> 为 <span class=\"math inline\">\\(j\\)</span>、或者距 LCA 为 <span class=\"math inline\">\\(d\\)</span> 且 LCA 距离 <span class=\"math inline\">\\(i\\)</span> 为 <span class=\"math inline\">\\(d-j\\)</span> 的点对数；随便做就可以了。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;std::vector&lt;int&gt; &gt; g1(n + 1);\n    for (int i = 1, x, y; i &lt; n; ++i) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y;\n        g1[x].push_back(y), g1[y].push_back(x);\n    &#125;\n    auto res(0ll);\n    std::vector&lt;int&gt; h(n + 1);\n    std::vector&lt;std::vector&lt;long long&gt; &gt; f(n + 1), g(n + 1);\n    std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int fa) &#123;\n        h[x] = 1;\n        for (auto i : g1[x])\n            if (i != fa) &#123;\n                DFS(i, x);\n                h[x] = std::max(h[x], h[i] + 1);\n            &#125;\n        f[x].resize(h[x] + 1), g[x].resize(h[x] + 1);\n        f[x][0] = 1ll;\n        for (auto i : g1[x])\n            if (i != fa) &#123;\n                for (int j = 0; j &lt;= h[i]; ++j) &#123;\n                    if (j &gt;= 1)\n                        res += g[x][j] * f[i][j - 1];\n                    if (j &gt;= 1 &amp;&amp; j + 1 &lt;= h[i])\n                        res += f[x][j] * g[i][j + 1];\n                    if (j &gt;= 1) &#123;\n                        g[x][j] += f[x][j] * f[i][j - 1];\n                        f[x][j] += f[i][j - 1];\n                    &#125;\n                    if (j + 1 &lt;= h[i])\n                        g[x][j] += g[i][j + 1];\n                &#125;\n                std::vector&lt;long long&gt;().swap(f[i]);\n                std::vector&lt;long long&gt;().swap(g[i]);\n            &#125;\n        res += g[x][0];\n        return;\n    &#125;;\n    DFS(1, -1);\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<p>然后对于每个 <span class=\"math inline\">\\(u\\)</span>，类似 DSU on tree，继承其长儿子的数据（整体前移 / 后移一位，使用指针实现），再把短儿子暴力合并上来。</p>\n<p>每次合并短儿子，数组长为短儿子链长；<span class=\"math inline\">\\(u\\)</span> 向上合并时，数组长为长儿子链长。故所有链被合并恰好一次，复杂度 <span class=\"math inline\">\\(O(n)\\)</span>。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;std::vector&lt;int&gt; &gt; g1(n + 1);\n    for (int i = 1, x, y; i &lt; n; ++i) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y;\n        g1[x].push_back(y), g1[y].push_back(x);\n    &#125;\n    std::vector&lt;int&gt; h(n + 1), son(n + 1);\n    std::vector&lt;long long&gt; df(5 * n + 1), dg(5 * n + 1);\n    std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int fa) &#123;\n        h[x] = 1;\n        for (auto i : g1[x])\n            if (i != fa) &#123;\n                DFS(i, x);\n                h[x] = std::max(h[x], h[i] + 1);\n                if (h[i] &gt; h[son[x]])\n                    son[x] = i;\n            &#125;\n        return;\n    &#125;;\n    DFS(1, -1);\n    auto pos(dg.begin() + 3 * n);\n    std::vector&lt;decltype(df.begin())&gt; f(n + 1), g(n + 1);\n    auto res(0ll);\n    DFS = [&amp;](int x, int fa) &#123;\n        f[x][0] = 1ll;\n        if (son[x]) &#123;\n            f[son[x]] = std::next(f[x]), g[son[x]] = std::prev(g[x]);\n            DFS(son[x], x);\n        &#125;\n        for (auto i : g1[x])\n            if (i != fa &amp;&amp; i != son[x]) &#123;\n                f[i] = std::next(f[x], h[x] + 1);\n                std::fill(f[i], f[i] + h[i] + 2, 0ll);\n                g[i] = std::next(pos, h[i]), pos = std::next(g[i], h[i]);\n                std::fill(std::prev(g[i]), g[i] + h[i] + 2, 0ll);\n                DFS(i, x);\n                for (int j = 0; j &lt;= h[i]; ++j) &#123;\n                    if (j &gt;= 1)\n                        res += g[x][j] * f[i][j - 1];\n                    if (j &gt;= 1 &amp;&amp; j + 1 &lt;= h[i])\n                        res += f[x][j] * g[i][j + 1];\n                    if (j &gt;= 1) &#123;\n                        g[x][j] += f[x][j] * f[i][j - 1];\n                        f[x][j] += f[i][j - 1];\n                    &#125;\n                    if (j + 1 &lt;= h[i])\n                        g[x][j] += g[i][j + 1];\n                &#125;\n            &#125;\n        res += g[x][0];\n        return;\n    &#125;;\n    f[1] = df.begin(), g[1] = dg.begin() + 2 * n;\n    DFS(1, -1);\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"cf1585g-poachers\">CF1585G Poachers</h3>\n<p><a href=\"https://codeforces.com/problemset/problem/1585/G\" class=\"uri\">https://codeforces.com/problemset/problem/1585/G</a></p>\n<p>公平博弈。我们现在要算每个根的 SG 值。设 <span class=\"math inline\">\\(f_{u,j}\\)</span> 表示在点 <span class=\"math inline\">\\(u\\)</span>，删了距离它为 <span class=\"math inline\">\\(j\\)</span> 这一层的 SG 值，那么有：</p>\n<p><span class=\"math display\">\\[\nf_{u,j}=\n\\begin{cases}\n\\text{mex}\\{f_{v,0}\\}&amp;j=0\\\\\n\\bigoplus f_{v,j-1}&amp;\\text{otherwise}\n\\end{cases}\n\\]</span></p>\n<p>然后发现有深度维。大力长剖。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int inf = 0x3f3f3f3f;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int T;\n    for (std::cin &gt;&gt; T; T--; ) &#123;\n        int n;\n        std::cin &gt;&gt; n;\n        std::vector&lt;int&gt; rt;\n        std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);\n        for (int i = 1, x; i &lt;= n; ++i) &#123;\n            std::cin &gt;&gt; x;\n            if (x)\n                g[x].push_back(i);\n            else\n                rt.push_back(i);\n        &#125;\n        std::vector&lt;int&gt; h(n + 1), son(n + 1), to(n + 1, inf);\n        std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;\n            h[x] = 1;\n            for (auto i : g[x]) &#123;\n                DFS(i);\n                h[x] = std::max(h[x], h[i] + 1);\n                to[x] = std::min(to[x], to[i] + 1);\n                if (h[i] &gt; h[son[x]])\n                    son[x] = i;\n            &#125;\n            to[x] = std::min(to[x], h[x]);\n            return;\n        &#125;;\n        for (auto i : rt)\n            DFS(i);\n        std::vector&lt;int&gt; _f(5 * n + 1), top(n + 1);\n        std::vector&lt;decltype(_f.begin())&gt; f(n + 1);\n        std::vector&lt;std::unordered_set&lt;int&gt; &gt; s(n + 1);\n        auto p(_f.begin());\n        DFS = [&amp;](int x) &#123;\n            if (son[x]) &#123;\n                f[son[x]] = std::next(f[x]);\n                top[son[x]] = top[x], DFS(son[x]);\n            &#125;\n            if ((int)g[x].size() == 1) &#123;\n                s[top[x]].insert(f[son[x]][0]);\n                for (int now = f[son[x]][0] + 1; ; ++now)\n                    if (!s[top[x]].count(now)) &#123;\n                        f[x][0] = now;\n                        break;\n                    &#125;\n                return;\n            &#125;\n            for (auto i : g[x])\n                if (i != son[x]) &#123;\n                    f[i] = p, p = std::next(p, h[i] + 1);\n                    top[i] = i, DFS(i);\n                    for (int j = 1; j &lt;= to[i] + 1; ++j)\n                        f[x][j] ^= f[i][j - 1];\n                &#125;\n            std::unordered_set&lt;int&gt;().swap(s[top[x]]);\n            for (int j = 1; j &lt;= to[x]; ++j)\n                s[top[x]].insert(f[x][j]);\n            for (int now = 0; ; ++now)\n                if (!s[top[x]].count(now)) &#123;\n                    f[x][0] = now;\n                    break;\n                &#125;\n            return;\n        &#125;;\n        int res = 0;\n        for (auto i : rt) &#123;\n            f[i] = p, p = std::next(p, h[i] + 1);\n            DFS(i), res ^= f[i][0];\n        &#125;\n        std::cout &lt;&lt; (res ? &quot;YES&quot; : &quot;NO&quot;) &lt;&lt; &#39;\\n&#39;;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n",
            "tags": [
                "树链剖分",
                "长链剖分"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/231230/",
            "url": "https://xsc062.netlify.app/231230/",
            "title": "解题报告 [SDOI2016] 游戏",
            "date_published": "2023-12-30T04:12:30.000Z",
            "content_html": "<p>可以看出来出题人很想出一道把李超和别的什么东西凑起来的题目，于是给了这么一个缝合怪。</p>\n<span id=\"more\"></span>\n<hr />\n<p><a href=\"https://www.luogu.com.cn/problem/P4069\" class=\"uri\">https://www.luogu.com.cn/problem/P4069</a></p>\n<p>符号有点混乱。比如箭头又可以表示路径又可以表示赋值，代入语境应该还是好理解的。</p>\n<hr />\n<p>看到 <span class=\"math inline\">\\(a\\times dis + b\\)</span> 就应激反应出来是李超了，看到 <span class=\"math inline\">\\(s\\to t\\)</span> 又瞬间反应过来是树剖，但是树剖的 DFN 和 <span class=\"math inline\">\\(dis\\)</span> 没有直接关联，赛时想不到怎么做就跑路了。</p>\n<p>实际上这个转化很板。因为这是条路径，我们还在树链上跳，每次跳过的一个链上的 DFN 是连续的，对应的 <span class=\"math inline\">\\(dis\\)</span> 也是连续的。</p>\n<p>估计是打 T4 的子树问题打傻了，没想到这个。</p>\n<p>所以我们就相当于是给一条重链上的某个连续区间加了一个斜率为 <span class=\"math inline\">\\(a\\)</span>，截距为 <span class=\"math inline\">\\(b\\)</span> 加上 <em>一坨东西</em> 的线段。用李超维护即可。</p>\n<hr />\n<p>感觉讲的不清不楚的，那就再讲讲。</p>\n<p>我们要让李超上任意一个点 <span class=\"math inline\">\\(u\\)</span> 代表的 <span class=\"math inline\">\\(x\\)</span> 是个定值。<em>一坨东西</em> 维护了这条线段相对于 <span class=\"math inline\">\\(s\\)</span> 的偏移量。令 <span class=\"math inline\">\\(r\\gets \\text{LCA of } s \\text { and } t\\)</span>，<span class=\"math inline\">\\(R\\)</span> 表示整棵树的根，<span class=\"math inline\">\\(d(u,v)\\gets \\text {distance between } u \\text { and } v\\)</span>。</p>\n<ol type=\"1\">\n<li><p>对于 <span class=\"math inline\">\\(s\\to r\\)</span> 上的每个点 <span class=\"math inline\">\\(u\\)</span>：</p>\n<p><span class=\"math display\">\\[\n\\begin{aligned}\nval_u&amp;=a\\times d(s, u)+b\\\\\n&amp;=a\\times[d(s,R)-d(u,R)]+b\\\\\n&amp;=-a\\times d(u,R)+[a\\times d(s,R)+b]\n\\end{aligned}\n\\]</span> <span class=\"math inline\">\\(a\\times d(s,R)+b\\)</span> 是和 <span class=\"math inline\">\\(u\\)</span> 无关的定值（这意味着可以在同一个询问的树剖时直接线段树），<span class=\"math inline\">\\(d(u,R)\\)</span> 是只和 <span class=\"math inline\">\\(u\\)</span> 相关的值（这意味着对于任意询问都成立）。令斜率为 <span class=\"math inline\">\\(-a\\)</span>，截距为 <span class=\"math inline\">\\(a\\times d(s,R)+b\\)</span>，李超上任意点 <span class=\"math inline\">\\(u\\)</span> 代表 <span class=\"math inline\">\\(x\\)</span> 为 <span class=\"math inline\">\\(d(x,R)\\)</span>，维护如此一条线段即可。</p></li>\n<li><p>对于 <span class=\"math inline\">\\(r\\to t\\)</span> 上的每个点 <span class=\"math inline\">\\(v\\)</span>： <span class=\"math display\">\\[\n\\begin{aligned}\nval_v&amp;=a\\times d(s,v)+b\\\\\n&amp;= a\\times [d(r,v)+d(s,r)]+b\\\\\n&amp;=a\\times [d(v,R)-d(r,R)+d(s,r)]+b\\\\\n&amp;=a\\times d(v,R)+[-a\\times d(r,R)+a\\times d(s,r)+b]\n\\end{aligned}\n\\]</span> <span class=\"math inline\">\\(-a\\times d(r,R)+a\\times d(s,r)+b\\)</span> 是和 <span class=\"math inline\">\\(v\\)</span> 无关，只和询问中固定的 <span class=\"math inline\">\\(s,r,a,b\\)</span> 有关的定值；<span class=\"math inline\">\\(d(v,R)\\)</span> 是只和 <span class=\"math inline\">\\(v\\)</span> 相关的值且和上一个 case 里的 <span class=\"math inline\">\\(d(u,R)\\)</span> 同构，也用李超这么维护即可。</p></li>\n</ol>\n<p>用李超维护把原问题转化为每次向若干重链上连续区间插入线段，求最低交点的问题。</p>\n<p>注意到区间查询，李超需要加一个 pushup。具体怎么去操作呢？在加线段的时候除编号外新增一个变量维护当前区间内最低交点；我们就 pushup 这个东西。然后查询的时候就是在散区间的时候和原来一样查，整区间就在散区间答案的基础上再和当前区间的整体最低交点比一个 min。</p>\n<details>\n<pre class=\"cpp\"><code>#define int long long\nnamespace XSC062 &#123;\nusing namespace fastIO;\nconst int maxk = 25;\nconst int maxn = 1e6 + 5;\nconst int maxm = 1e6 + 5;\nconst int inf = 123456789123456789;\n//#define DEBUG\n\n#ifdef DEBUG\n#define Z(x) x\n#else\n#define Z(x)\n#endif\n#define lt (p &lt;&lt; 1)\n#define rt (lt | 1)\nstruct __ &#123; int k, b; &#125;;\nstruct _ &#123; int l, r, u, d; &#125;;\nstruct ____ &#123;\n    int v, w;\n    ____() &#123;&#125;\n    ____(int v1, int w1) &#123;\n        v = v1, w = w1; \n    &#125;\n&#125;;\n__ a[maxm];\n_ t[maxn &lt;&lt; 2];\nint tot, si, now;\nint f[maxn][maxk];\nint dis[maxn], dep[maxn];\nint dfn[maxn], tab[maxn];\nstd::vector&lt;____&gt; g[maxn];\nint n, m, ty, x, y, w, k, b;\nint siz[maxn], top[maxn], son[maxn];\nint max(int x, int y) &#123;\n    return x &gt; y ? x : y;\n&#125;\nint min(int x, int y) &#123;\n    return x &lt; y ? x : y;\n&#125;\nvoid swap(int &amp;x, int &amp;y) &#123;\n    x ^= y ^= x ^= y;\n    return;\n&#125;\nvoid DFS1(int x) &#123;\n    siz[x] = 1;\n    for (auto i : g[x]) &#123;\n        if (i.v == f[x][0]) continue;\n        f[i.v][0] = x;\n        for (int j = 1; j &lt;= si; ++j)\n            f[i.v][j] = f[f[i.v][j - 1]][j - 1];\n        dep[i.v] = dep[x] + 1;\n        dis[i.v] = dis[x] + i.w;\n        DFS1(i.v);\n        if (siz[i.v] &gt; siz[son[x]])\n            son[x] = i.v;\n        siz[x] += siz[i.v];\n    &#125;\n    return;\n&#125;\nvoid DFS2(int x, int t) &#123;\n    top[x] = t;\n    dfn[x] = ++now, tab[now] = x;\n    if (son[x]) DFS2(son[x], t);\n    for (auto i : g[x]) &#123;\n        if (i.v == f[x][0] || i.v == son[x])\n            continue;\n        DFS2(i.v, i.v);\n    &#125;\n    return;\n&#125;\nvoid bld(int p, int l, int r) &#123;\n    t[p].l = l, t[p].r = r, t[p].d = inf;\n    if (l == r) return;\n    int mid = (l + r) &gt;&gt; 1;\n    bld(lt, l, mid), bld(rt, mid + 1, r);\n    return;\n&#125;\nint getv(int id, int x) &#123;\n    if (!id) return inf;\n    Z(printf(&quot;get (%lld, %lld) = %lld\\n&quot;,\n        id, x, dis[tab[x]] * a[id].k + a[id].b));\n    return dis[tab[x]] * a[id].k + a[id].b;\n&#125;\nvoid pushup(int p) &#123;\n    if (t[p].l == t[p].r) return;\n    t[p].d = min(t[p].d, min(t[lt].d, t[rt].d));\n    Z(printf(&quot;[%lld, %lld]: pushup to %lld\\n&quot;,\n        t[p].l, t[p].r, t[p].d));\n    return;\n&#125;\nvoid chg(int p, int id) &#123;\n    t[p].u = id;\n    Z(int tmp = t[p].d);\n    t[p].d = min(getv(id, t[p].l),\n                 getv(id, t[p].r));\n    Z(printf(&quot;[%lld, %lld]: %lld -&gt; %lld\\n&quot;,\n                t[p].l, t[p].r, tmp, t[p].d)); \n    return;\n&#125;\nvoid upd(int p, int id) &#123;\n    if (!t[p].u) &#123;\n        chg(p, id), pushup(p);\n        return;\n    &#125;\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    int v1 = getv(t[p].u, mid),\n        v2 = getv(id, mid);\n    if (v2 &lt; v1) swap(t[p].u, id);\n    v1 = getv(t[p].u, t[p].l);\n    v2 = getv(id, t[p].l);\n    if (v2 &lt; v1) upd(lt, id);\n    v1 = getv(t[p].u, t[p].r);\n    v2 = getv(id, t[p].r);\n    if (v2 &lt; v1) upd(rt, id);\n    chg(p, t[p].u);\n    pushup(p);\n    return;\n&#125;\nvoid add(int p, int l, int r, int id) &#123;\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r) &#123;\n        upd(p, id);\n        return;\n    &#125;\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (l &lt;= mid) add(lt, l, r, id);\n    if (r &gt; mid) add(rt, l, r, id);\n    pushup(p);\n    return;\n&#125;\nint ask(int p, int l, int r) &#123;\n    l = max(l, t[p].l);\n    r = min(r, t[p].r);\n    int res = min(getv(t[p].u, l),\n                  getv(t[p].u, r));\n    Z(printf(&quot;[%lld, %lld]: res = %lld\\n&quot;,\n        t[p].l, t[p].r, res));\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r)\n        return min(res, t[p].d);\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (l &lt;= mid) res = min(res, ask(lt, l, r));\n    if (r &gt; mid) res = min(res, ask(rt, l, r));\n    Z(printf(&quot;[%lld, %lld]: res = %lld\\n&quot;,\n        t[p].l, t[p].r, res));\n    return res;\n&#125;\nvoid add(int x, int y, int w) &#123;\n    g[x].push_back(____(y, w));\n    return;\n&#125;\nvoid ins(int l, int r, int k, int b) &#123;\n    a[++tot].k = k, a[tot].b = b;\n    add(1, l, r, tot);\n    return;\n&#125;\nint getLCA(int x, int y) &#123;\n    if (dep[x] &lt; dep[y]) swap(x, y);\n    for (int i = si; ~i; --i) &#123;\n        if (dep[f[x][i]] &gt;= dep[y])\n            x = f[x][i];\n    &#125;\n    if (x == y) return x;\n    for (int i = si; ~i; --i) &#123;\n        if (f[x][i] != f[y][i])\n            x = f[x][i], y = f[y][i];\n    &#125;\n    return f[x][0];\n&#125;\nvoid inst(int s, int t, int k, int b) &#123;\n    int r = getLCA(s, t), u = s;\n    while (top[u] != top[r]) &#123;\n        ins(dfn[top[u]], dfn[u],\n                    -k, k * dis[s] + b);\n        u = f[top[u]][0];\n    &#125;\n    ins(dfn[r], dfn[u], -k, k * dis[s] + b);\n    u = t;\n    int d = dis[s] - dis[r];\n    while (top[u] != top[r]) &#123;\n        ins(dfn[top[u]], dfn[u],\n                k, -k * dis[r] + k * d + b);\n        u = f[top[u]][0];\n    &#125;\n    ins(dfn[r], dfn[u],\n            k, -k * dis[r] + k * d + b);\n    return;\n&#125;\nint qry(int x, int y) &#123;\n    int res = inf;\n    while (top[x] != top[y]) &#123;\n        if (dep[top[x]] &lt; dep[top[y]])\n            swap(x, y);\n        Z(printf(&quot;ask %lld -&gt; %lld: %lld\\n&quot;,\n            x, top[x],\n            ask(1, dfn[top[x]], dfn[x])));\n        res = min(res,\n            ask(1, dfn[top[x]], dfn[x]));\n        x = f[top[x]][0];\n    &#125;\n    if (dep[x] &lt; dep[y]) swap(x, y);\n    Z(printf(&quot;ask %lld -&gt; %lld: %lld\\n&quot;,\n        x, y, ask(1, dfn[y], dfn[x])));\n    res = min(res, ask(1, dfn[y], dfn[x]));\n    return res;\n&#125;\nint main() &#123;\n//  freopen(&quot;game1.in&quot;, &quot;r&quot;, stdin);\n    read(n), read(m);\n    si = log(n) / log(2.0);\n    for (int i = 1; i &lt; n; ++i) &#123;\n        read(x), read(y), read(w);\n        add(x, y, w), add(y, x, w);\n    &#125;\n    bld(1, 1, n);\n    dep[1] = 1, DFS1(1), DFS2(1, -1);\n    Z(for (int i = 1; i &lt;= n; ++i)\n        printf(&quot;dfn[%lld] = %lld\\n&quot;, i, dfn[i]));\n    while (m--) &#123;\n        read(ty), read(x), read(y);\n        if (ty == 1) &#123;\n            read(k), read(b);\n            inst(x, y, k, b);\n        &#125;\n        else print(qry(x, y), &#39;\\n&#39;);\n    &#125;\n    return 0;\n&#125;\n&#125; // namespace XSC062\n#undef int</code></pre>\n</details>\n",
            "tags": [
                "树链剖分",
                "李超线段树"
            ]
        }
    ]
}