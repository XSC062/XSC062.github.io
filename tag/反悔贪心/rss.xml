<?xml version="1.0"?>
<rss version="2.0">
    <channel>
        <title> • Posts by &#34;反悔贪心&#34; tag</title>
        <link>https://xsc062.netlify.app</link>
        <description></description>
        <language>zh-CN</language>
        <pubDate>Mon, 07 Jul 2025 14:10:02 +0800</pubDate>
        <lastBuildDate>Mon, 07 Jul 2025 14:10:02 +0800</lastBuildDate>
        <category>并查集</category>
        <category>斜率优化</category>
        <category>悬线法</category>
        <category>哈希</category>
        <category>字典树</category>
        <category>DP</category>
        <category>单调队列</category>
        <category>分治</category>
        <category>二分图</category>
        <category>CRT / exCRT</category>
        <category>排列组合</category>
        <category>网络流</category>
        <category>费用流</category>
        <category>二分</category>
        <category>上下界网络流</category>
        <category>容斥原理</category>
        <category>线段树</category>
        <category>树状数组</category>
        <category>区间 DP</category>
        <category>构造</category>
        <category>Tarjan</category>
        <category>数据结构</category>
        <category>下饭</category>
        <category>LCA</category>
        <category>倍增</category>
        <category>鸽巢原理</category>
        <category>概率期望</category>
        <category>调和级数</category>
        <category>差分</category>
        <category>思维</category>
        <category>树形 DP</category>
        <category>最小生成树</category>
        <category>SAM</category>
        <category>状压</category>
        <category>分块</category>
        <category>可持久化</category>
        <category>笛卡尔树</category>
        <category>高维前缀和</category>
        <category>闲话</category>
        <category>欧拉回路</category>
        <category>树链剖分</category>
        <category>长链剖分</category>
        <category>KMP</category>
        <category>border</category>
        <category>字符串</category>
        <category>AC 自动机</category>
        <category>SA</category>
        <category>数学</category>
        <category>树上差分</category>
        <category>FWT</category>
        <category>堆</category>
        <category>树的重心</category>
        <category>二项式定理</category>
        <category>二项式反演</category>
        <category>贪心</category>
        <category>均摊</category>
        <category>计数</category>
        <category>优化建图</category>
        <category>反悔贪心</category>
        <category>调整法</category>
        <category>背包</category>
        <category>博弈论</category>
        <category>DP 优化</category>
        <category>虚树</category>
        <category>点分治</category>
        <category>WQS 二分</category>
        <category>闵可夫斯基和</category>
        <category>slope trick</category>
        <category>四边形不等式</category>
        <category>暴力</category>
        <category>状压 DP</category>
        <category>组合数学</category>
        <category>支配对</category>
        <category>DDP</category>
        <category>平衡树</category>
        <category>容斥</category>
        <category>猫树</category>
        <category>Kruskal 重构树</category>
        <category>李超线段树</category>
        <item>
            <guid isPermalink="true">https://xsc062.netlify.app/20250707/</guid>
            <title>DP 凸优化</title>
            <link>https://xsc062.netlify.app/20250707/</link>
            <category>DP</category>
            <category>反悔贪心</category>
            <category>DP 优化</category>
            <category>WQS 二分</category>
            <category>闵可夫斯基和</category>
            <category>slope trick</category>
            <pubDate>Mon, 07 Jul 2025 14:10:02 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;袜，这篇文章一下子创建了三个新 tag。&lt;/p&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;什么是凸函数&#34;&gt;什么是凸函数&lt;/h2&gt;
&lt;h3 id=&#34;定义&#34;&gt;定义&lt;/h3&gt;
&lt;p&gt;在信息学中研究的凸函数大抵是只在正整数域上有定义的，所以只能直接摒弃导函数的概念了。&lt;/p&gt;
&lt;p&gt;若斜率递增，换言之，差分数组递增，认为函数是凸的（好反直觉）。&lt;/p&gt;
&lt;p&gt;或者看看符号化的定义：若对于任意 &lt;span class=&#34;math inline&#34;&gt;\(\lambda\in[0,1]\)&lt;/span&gt;，函数 &lt;span class=&#34;math inline&#34;&gt;\(f(x)\)&lt;/span&gt; 均满足：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
f(\lambda x+(1-\lambda) y)\le \lambda f(x)+(1-\lambda) f(y).
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;或等价地：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
f(x)-f(x - 1)\le f(x + 1) - f(x)
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;那么认为 &lt;span class=&#34;math inline&#34;&gt;\(f\)&lt;/span&gt; 是凸函数。&lt;/p&gt;
&lt;p&gt;因为凹凸在性质上没区别，所以 &lt;strong&gt;下文施行暴政，将凹函数和凸函数统称为凸函数&lt;/strong&gt;。&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;判定&#34;&gt;判定&lt;/h3&gt;
&lt;p&gt;对于具体情境下的问题，怎么判断 DP 数组是否关于其某一维为凸函数？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;相信相信的力量（最常用）。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;对于分段问题，证明分出来的每一段满足四边形不等式。&lt;/p&gt;
&lt;em&gt;值得一提的是，数学上不认为满足四边形不等式能够推出函数为凸。但这是信息学.jpg&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;其由两个凸函数线性相加得到：&lt;/p&gt;
&lt;p&gt;对于 &lt;span class=&#34;math inline&#34;&gt;\(\forall\, \lambda,\mu\ge 0\)&lt;/span&gt; 和凸函数 &lt;span class=&#34;math inline&#34;&gt;\(f,g\)&lt;/span&gt;，若 &lt;span class=&#34;math inline&#34;&gt;\(h=\lambda f+\mu g\)&lt;/span&gt;，则 &lt;span class=&#34;math inline&#34;&gt;\(h\)&lt;/span&gt; 为凸函数。&lt;/p&gt;
此外，此时 &lt;span class=&#34;math inline&#34;&gt;\(h\)&lt;/span&gt; 的差分数组和 &lt;span class=&#34;math inline&#34;&gt;\(f,g\)&lt;/span&gt; 差分数组也满足上述关系。&lt;/li&gt;
&lt;li&gt;其是两个凸函数的 &lt;a href=&#34;#闵可夫斯基和&#34;&gt;闵可夫斯基和&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;其由两个凸函数线性 max 得到。&lt;/p&gt;
&lt;p&gt;对于两个凸函数的线性 min，一般不是凸函数，甚至可能是凹的。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;性质&#34;&gt;性质&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;最值为唯一极值。&lt;/li&gt;
&lt;li&gt;斜率 / 差分数组具有单调性。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在解题中主要用到的大概就是上面两条。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;wqs-二分&#34;&gt;WQS 二分&lt;/h2&gt;
&lt;h3 id=&#34;主要任务&#34;&gt;主要任务&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;例：把 &lt;span class=&#34;math inline&#34;&gt;\(a_{1\sim n}\)&lt;/span&gt; 分为恰好 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 段，每段的代价为 &lt;span class=&#34;math inline&#34;&gt;\(sum^2+c\)&lt;/span&gt;（&lt;span class=&#34;math inline&#34;&gt;\(c\)&lt;/span&gt; 为给定的常数），问最小代价。&lt;span class=&#34;math inline&#34;&gt;\(n\le 2\times 10^5,a_i\le 10^9\)&lt;/span&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果对段数没有要求，可以用斜优 &lt;span class=&#34;math inline&#34;&gt;\(O(n)\)&lt;/span&gt; 做。&lt;/p&gt;
&lt;p&gt;加上了 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 的限制，DP 变成二维的，令 &lt;span class=&#34;math inline&#34;&gt;\(f_{i,j}\)&lt;/span&gt; 表示在 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 处分第 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; 段，可以在第一维斜率优化，做到 &lt;span class=&#34;math inline&#34;&gt;\(O(nk)\)&lt;/span&gt;；亦或发现 &lt;span class=&#34;math inline&#34;&gt;\((i,j)\)&lt;/span&gt; 有决策单调性，然后四边形不等式优化到 &lt;span class=&#34;math inline&#34;&gt;\(O(n^2)\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;我们发现 &lt;span class=&#34;math inline&#34;&gt;\(f\)&lt;/span&gt; 关于 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; 这一维是凸的（而非上文的 &lt;span class=&#34;math inline&#34;&gt;\((i,j)\)&lt;/span&gt;），故将 &lt;span class=&#34;math inline&#34;&gt;\(f(n,j)\)&lt;/span&gt; 关于 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; 的函数提取出来（记为 &lt;span class=&#34;math inline&#34;&gt;\(f_n(j)\)&lt;/span&gt;）。发现只有最高点是可以一次斜优快速求出来的，故可以认为在当前复杂度限制下，整个函数除了最高点以外都是未知的（注意可以在 DP 时记录极值点的横坐标，即分了几段）。&lt;/p&gt;
&lt;p&gt;我们给每个 &lt;span class=&#34;math inline&#34;&gt;\(f_n(j)\)&lt;/span&gt; 加上 &lt;span class=&#34;math inline&#34;&gt;\(\alpha\cdot j\)&lt;/span&gt;（在本题中即将 &lt;span class=&#34;math inline&#34;&gt;\(c\gets c+k\)&lt;/span&gt;），勉强可以认为 &lt;span class=&#34;math inline&#34;&gt;\(\alpha\cdot j\)&lt;/span&gt; 是凸的，所以新函数 &lt;span class=&#34;math inline&#34;&gt;\(f&amp;#39;_n(j)\)&lt;/span&gt; 也是凸的。若 &lt;span class=&#34;math inline&#34;&gt;\(k&amp;gt;0\)&lt;/span&gt;，可以感受到极值点向左偏移，且随着 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 的增大，极值点不会右移；&lt;span class=&#34;math inline&#34;&gt;\(k&amp;lt;0\)&lt;/span&gt; 时同理。&lt;/p&gt;
&lt;p&gt;结合几何观点，在 &lt;span class=&#34;math inline&#34;&gt;\(f_n\)&lt;/span&gt; 上的极值点可以用斜率为 &lt;span class=&#34;math inline&#34;&gt;\(0\)&lt;/span&gt; 的直线切到；而加上 &lt;span class=&#34;math inline&#34;&gt;\(\alpha\cdot j\)&lt;/span&gt; 的过程，其实就是切线斜率减去 &lt;span class=&#34;math inline&#34;&gt;\(\alpha\)&lt;/span&gt; 的过程。相当于令切线斜率为 &lt;span class=&#34;math inline&#34;&gt;\(-\alpha\)&lt;/span&gt;，看看能切到哪里。&lt;/p&gt;
&lt;p&gt;故可以二分一个合适的 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt;，使得极值点的横坐标为 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt;。此时 &lt;span class=&#34;math inline&#34;&gt;\(f&amp;#39;_n(k)-\alpha\cdot k\)&lt;/span&gt; 即为待求。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;WQS 二分参与的问题一般以如下形式呈现：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定序列，将其恰好分为 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 段 / 恰好选 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 个，求最大 / 最小代价。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;题目要求最大 / 最小值一般能够反映函数的凹凸性，可以根据这一点来猜。&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;细节处理&#34;&gt;细节处理&lt;/h3&gt;
&lt;p&gt;考虑如下凸函数：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;1.png&#34; /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;显然对于『凸出来』的点（即图中除了 &lt;span class=&#34;math inline&#34;&gt;\(E,H\)&lt;/span&gt; 以外的点），能切到的直线斜率为一个范围；而位于直线上的点（途中 &lt;span class=&#34;math inline&#34;&gt;\(E,H\)&lt;/span&gt;），能切到的直线斜率更是定死了。所以这要求你的二分精度需要略高一点。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;对于 &lt;span class=&#34;math inline&#34;&gt;\(E\)&lt;/span&gt;（或 &lt;span class=&#34;math inline&#34;&gt;\(H\)&lt;/span&gt;），不能找到只过它一点的切线。根据 DP 的写法，记录的横坐标可能是最小的 &lt;span class=&#34;math inline&#34;&gt;\(D\)&lt;/span&gt;，也可能是最大的 &lt;span class=&#34;math inline&#34;&gt;\(F\)&lt;/span&gt;，此时你可以：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;同时记录最小和最大的横坐标，看看 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 在不在中间。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;题目要求最大代价时，记录最大横坐标，二分到一个极值点 &lt;span class=&#34;math inline&#34;&gt;\(k&amp;#39;\ge k\)&lt;/span&gt; 时，显然 &lt;span class=&#34;math inline&#34;&gt;\(\alpha&amp;#39;\ge \alpha\)&lt;/span&gt;，用 &lt;span class=&#34;math inline&#34;&gt;\(f&amp;#39;_n(k&amp;#39;)-\alpha&amp;#39;\cdot k\)&lt;/span&gt; 更新答案（是赋值而不是取最值）；求最小代价时同理。&lt;/p&gt;
&lt;p&gt;主要是需要记住斜率是 &lt;span class=&#34;math inline&#34;&gt;\(\alpha\)&lt;/span&gt; 的相反数，&lt;del&gt;实在搞不清对应关系可以都试一试&lt;/del&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;例种树&#34;&gt;例：种树&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P1484&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P1484&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;首先，函数是凸的——感性理解即可。&lt;/p&gt;
&lt;p&gt;接着，要求的是 &lt;span class=&#34;math inline&#34;&gt;\(\le k\)&lt;/span&gt; 时的最值。分为两种情况：&lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 是否右于原函数极值点。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;若 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 右于原函数极值点，则原函数极值点为答案。&lt;/li&gt;
&lt;li&gt;否则，&lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 为答案。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;好消息是整数域上一定有解（最后答案为整、倒推即可），所以不用打浮点数二分了。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int lim = 1e6;
const long long inf = 1e18;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#endif
    int n, k;
    std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; k;
    std::vector&amp;lt;long long&amp;gt; a(n + 1);
    for (int i = 1; i &amp;lt;= n; ++i)
        std::cin &amp;gt;&amp;gt; a[i];
    auto calc = [&amp;amp;](int c) &amp;#123;
        std::vector&amp;lt;std::pair&amp;lt;long long, int&amp;gt; &amp;gt; f(n + 1);
        auto mx = f.front();
        auto upd = [&amp;amp;](auto &amp;amp;x, auto y) &amp;#123;
            if (y.first &amp;gt; x.first || (y.first == x.first &amp;amp;&amp;amp; y.second &amp;lt; x.second))
                x = y;
            return;
        &amp;#125;;
        for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
            f[i].first = mx.first + a[i] + c;
            f[i].second = mx.second + 1;
            upd(mx, f[i - 1]);
        &amp;#125;
        upd(mx, f[n]);
        return mx;
    &amp;#125;;
    auto t(calc(0));
    if (t.second &amp;lt;= k) &amp;#123;
        std::cout &amp;lt;&amp;lt; t.first &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
        return 0;
    &amp;#125;
    auto res(-inf);
    for (int l = -lim, r = lim, mid; l &amp;lt;= r; ) &amp;#123;
        mid = (l + r) &amp;gt;&amp;gt; 1;
        auto t = calc(mid);
        if (t.second &amp;lt;= k)
            res = t.first - (long long)mid * k, l = mid + 1;
        else
            r = mid - 1;
    &amp;#125;
    std::cout &amp;lt;&amp;lt; res &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;例raper&#34;&gt;例：Raper&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P4694&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P4694&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;给所有光盘附一个奖励 &lt;span class=&#34;math inline&#34;&gt;\(mid\)&lt;/span&gt;，进行 WQS 二分。&lt;/p&gt;
&lt;p&gt;然后内层就和 &lt;a href=&#34;#例序列-sequence&#34;&gt;sequence&lt;/a&gt; 差得不是特别多，所以考虑反悔贪心。（？）&lt;/p&gt;
&lt;p&gt;把路过的 &lt;span class=&#34;math inline&#34;&gt;\(-a_j\)&lt;/span&gt; 丢到大根堆里，尝试和 &lt;span class=&#34;math inline&#34;&gt;\(b_i\)&lt;/span&gt; 配对。如果 &lt;span class=&#34;math inline&#34;&gt;\(mid-a_i-b_i\ge 0\)&lt;/span&gt; 那么暂时配对，顺便把 &lt;span class=&#34;math inline&#34;&gt;\(b_i-mid\)&lt;/span&gt; 丢进去用于反悔，若 &lt;span class=&#34;math inline&#34;&gt;\(b_{i&amp;#39;}\)&lt;/span&gt; 选中了 &lt;span class=&#34;math inline&#34;&gt;\(b_i-mid\)&lt;/span&gt; 说明反悔，将 &lt;span class=&#34;math inline&#34;&gt;\(a_j\)&lt;/span&gt; 与 &lt;span class=&#34;math inline&#34;&gt;\(b_{i&amp;#39;}\)&lt;/span&gt; 配对。&lt;/p&gt;
&lt;p&gt;贪心的时候需要记录已经配的对数，优先队列中需要对 &lt;span class=&#34;math inline&#34;&gt;\(-a_j\)&lt;/span&gt; 和 &lt;span class=&#34;math inline&#34;&gt;\(b_i-mid\)&lt;/span&gt; 打标记进行区分，匹配到前者时才增加成功对数。&lt;/p&gt;
&lt;p&gt;发现整数域上仍然必有解（答案为整，倒推），不用打浮点数二分 neiher.&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const long long inf = 2e9 + 5;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#endif
    int n, k;
    std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; k;
    std::vector&amp;lt;int&amp;gt; a(n + 1), b(n + 1);
    for (int i = 1; i &amp;lt;= n; ++i)
        std::cin &amp;gt;&amp;gt; a[i];
    for (int i = 1; i &amp;lt;= n; ++i)
        std::cin &amp;gt;&amp;gt; b[i];
    auto calc = [&amp;amp;](long long mid) &amp;#123;
        std::priority_queue&amp;lt;std::pair&amp;lt;long long, int&amp;gt; &amp;gt; q;
        int cnt = 0;
        auto res(0ll);
        for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
            q.emplace(-a[i], 1);
            auto [v, ty] = q.top();
            if (mid + v - b[i] &amp;gt;= 0) &amp;#123;
                q.pop(), cnt += ty;
                res += mid + v - b[i], q.emplace(b[i] - mid, 0);
            &amp;#125;
        &amp;#125;
        return std::make_pair(cnt, res);
    &amp;#125;;
    auto res(inf);
    for (long long l = 1ll, r = inf, mid; l &amp;lt;= r; ) &amp;#123;
        mid = (l + r) &amp;gt;&amp;gt; 1;
        auto t(calc(mid));
        if (t.first &amp;gt;= k)
            r = mid - 1, res = -(t.second - k * mid);
        else
            l = mid + 1;
    &amp;#125;
    std::cout &amp;lt;&amp;lt; res &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;区间分拆问题&#34;&gt;区间分拆问题&lt;/h3&gt;
&lt;p&gt;目标：尝试将 &lt;span class=&#34;math inline&#34;&gt;\(a_{1\sim n}\)&lt;/span&gt; 分割成恰好 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 段，定义 &lt;span class=&#34;math inline&#34;&gt;\(w(i,j)\)&lt;/span&gt; 为将 &lt;span class=&#34;math inline&#34;&gt;\([i,j]\)&lt;/span&gt; 作为一段的代价，求代价最值。其中 &lt;span class=&#34;math inline&#34;&gt;\(w(i,j)\)&lt;/span&gt; 满足四边形不等式。&lt;/p&gt;
&lt;p&gt;不妨设求最小代价。定义 &lt;span class=&#34;math inline&#34;&gt;\(f(i,j)\)&lt;/span&gt; 在 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 处分第 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; 段，那么有：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
f(i,j)=\min(f(i-1,p-1)+w(p,j)).
\]&lt;/span&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;有定理：若 &lt;span class=&#34;math inline&#34;&gt;\(w(i,j)\)&lt;/span&gt; 满足四边形不等式，那么有 &lt;span class=&#34;math inline&#34;&gt;\(f(i-1,j)\le f(i,j)\le f(i,j+1)\)&lt;/span&gt;，从 &lt;span class=&#34;math inline&#34;&gt;\(f\)&lt;/span&gt; 定义出发很好感性理解。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;那么可以从这一点出发，&lt;span class=&#34;math inline&#34;&gt;\(p\)&lt;/span&gt; 这一维就可以被摊掉，做到 &lt;span class=&#34;math inline&#34;&gt;\(O(n(n+m))\)&lt;/span&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;有定理：若 &lt;span class=&#34;math inline&#34;&gt;\(w(i,j)\)&lt;/span&gt; 满足四边形不等式，那么 &lt;span class=&#34;math inline&#34;&gt;\(f_i(j)\)&lt;/span&gt; 是凸函数。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;那很好了。直接冲刺 WQS 即可。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;闵可夫斯基和&#34;&gt;闵可夫斯基和&lt;/h2&gt;
&lt;p&gt;给定两个凸函数（当然是指 OI 中那种长得很直的函数），将它们的『边』拆下来过后，以某种方式拼在一起，使得最后得到一个新的凸函数。&lt;/p&gt;
&lt;p&gt;按每条『边』的斜率归并一下就可以得到，显然答案存在且唯一，这个过程被称为闵可夫斯基和。可以发现这是一种最值 - 加卷积。&lt;/p&gt;
&lt;p&gt;假设我们要求的 DP 数组是两个已知的子数组以类似的方法卷起来的，最后要求完整的 DP 数组（而非 WQS 中的单点值），就可以考虑闵可夫斯基和。&lt;/p&gt;
&lt;p&gt;发现这个结构是很适合归并的，使用归并要求状态中含有版本维、因变量维。&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;例its-mooin-time-p&#34;&gt;例：It&#39;s Mooin&#39; Time P&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P11459&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P11459&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;定义 &lt;span class=&#34;math inline&#34;&gt;\(w_i\)&lt;/span&gt; 为将 &lt;span class=&#34;math inline&#34;&gt;\([i,i+L)\)&lt;/span&gt; 改为 &lt;code&gt;MOO&lt;/code&gt; 的代价，问题转化为选取 &lt;span class=&#34;math inline&#34;&gt;\(1\sim \frac nL\)&lt;/span&gt; 个不重区间的最小代价和。&lt;/p&gt;
&lt;p&gt;尝试归并，每次将 &lt;span class=&#34;math inline&#34;&gt;\([l,mid]\)&lt;/span&gt; 和 &lt;span class=&#34;math inline&#34;&gt;\((mid, r]\)&lt;/span&gt; 卷起来。但是会有一点问题：如果恰好有区间卡在中间呢？&lt;/p&gt;
&lt;p&gt;可以令 &lt;span class=&#34;math inline&#34;&gt;\(f_{l,r,0/1/2,0/1/2}(i)\)&lt;/span&gt; 表示在 &lt;span class=&#34;math inline&#34;&gt;\([l,r]\)&lt;/span&gt; 内选了 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 个 &lt;code&gt;MOO&lt;/code&gt;，且两侧最远的被选点距离端点为 &lt;span class=&#34;math inline&#34;&gt;\(0/1/\ge 2\)&lt;/span&gt; 的 DP 值。然后可以进行相应的讨论、平移、闵可夫斯基和，最后将所有情况线性取 max 得到这一层的答案，容易发现得到的答案也是凸的。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const long long inf = 1e18;
int L;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#endif
    int n;
    std::cin &amp;gt;&amp;gt; L &amp;gt;&amp;gt; n;
    std::vector&amp;lt;int&amp;gt; a(n + 1);
    std::vector&amp;lt;char&amp;gt; t(n + 1);
    std::vector&amp;lt;long long&amp;gt; w(n + 1);
    for (int i = 1; i &amp;lt;= n; ++i)
        std::cin &amp;gt;&amp;gt; t[i];
    for (int i = 1; i &amp;lt;= n; ++i)
        std::cin &amp;gt;&amp;gt; a[i];
    for (int i = 1; i &amp;lt;= n - L + 1; ++i) &amp;#123;
        w[i] = a[i] * (t[i] != &amp;#39;M&amp;#39;);
        for (int j = i + 1; j &amp;lt; i + L; ++j)
            w[i] += a[j] * (t[j] != &amp;#39;O&amp;#39;);
        // printf(&amp;quot;[%d, %d]: %lld\n&amp;quot;, i, i + L - 1, w[i]);
    &amp;#125;
    if (L == 1) &amp;#123;
        std::sort(w.begin() + 1, w.end());
        auto s(0ll);
        for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
            s += w[i];
            std::cout &amp;lt;&amp;lt; s &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
        &amp;#125;
        return 0;
    &amp;#125;
    using arr = std::vector&amp;lt;long long&amp;gt;;
    using brr = std::vector&amp;lt;arr&amp;gt;;
    using crr = std::vector&amp;lt;brr&amp;gt;;
    struct node &amp;#123;
        crr f;
        node(int len): f(L, brr(L, arr(len, inf))) &amp;#123;
            for (int i = 0; i &amp;lt; L; ++i)
                for (int j = 0; j &amp;lt; L; ++j)
                    f[i][j][0] = 0ll;
            return;
        &amp;#125;
        brr&amp;amp; operator[] (int q) &amp;#123; return f[q]; &amp;#125;
    &amp;#125;;
    auto upd = [&amp;amp;](arr &amp;amp;x, arr y) &amp;#123;
        if (x.size() &amp;lt; y.size())
            x.resize(y.size(), inf);
        for (int i = 0; i &amp;lt; (int)y.size(); ++i)
            x[i] = std::min(x[i], y[i]);
        return;
    &amp;#125;;
    auto merge = [&amp;amp;](arr l, arr r) &amp;#123;
        arr out((int)(l.size() + r.size()) - 1), dl(l.size()), dr(r.size());
        for (int i = 1; i &amp;lt; (int)l.size(); ++i)
            dl[i] = l[i] - l[i - 1];
        for (int i = 1; i &amp;lt; (int)r.size(); ++i)
            dr[i] = r[i] - r[i - 1];
        std::merge(dl.begin() + 1, dl.end(), dr.begin() + 1, dr.end(), out.begin() + 1);
        out[0] = l[0] + r[0];
        std::partial_sum(out.begin(), out.end(), out.begin());
        return out;
    &amp;#125;;
    std::function&amp;lt;node(int, int)&amp;gt; calc = [&amp;amp;](int l, int r) &amp;#123;
        if (r - l + 1 &amp;lt; 2 * L) &amp;#123;
            node res(1);
            for (int ll = 0; ll &amp;lt; L; ++ll)
                for (int rr = 0; rr &amp;lt; L; ++rr)
                    if (l + ll &amp;lt;= r - rr - L + 1) &amp;#123;
                        res[ll][rr].resize(2, inf);
                        for (int i = l + ll; i &amp;lt;= r - rr - L + 1; ++i)
                            res[ll][rr][1] = std::min(res[ll][rr][1], w[i]);
                        // printf(&amp;quot;[%d, %d]: (%d, %d) = %lld\n&amp;quot;, l, r, ll, rr, res[ll][rr][1]);
                    &amp;#125;
            // for (int i = 0; i &amp;lt; L; ++i)
            //     if (l + i + L - 1 &amp;lt;= r) &amp;#123;
            //         printf(&amp;quot;[%d, %d]: (%d, %d) = %lld\n&amp;quot;, l, r, i, r - (l + i + L - 1), w[l + i]);
            //         res[i][r - (l + i + L - 1)].emplace_back(w[l + i]);
            //     &amp;#125;
            return res;
        &amp;#125;   
        int mid = (l + r) &amp;gt;&amp;gt; 1;
        node tl(calc(l, mid)), tr(calc(mid + 1, r)), res((r - l + 1) / L + 1);
        for (int ll = 0; ll &amp;lt; L; ++ll)
            for (int rr = 0; rr &amp;lt; L; ++rr)
                res[ll][rr] = merge(tl[ll][0], tr[0][rr]);
        for (int ll = 0; ll &amp;lt; L; ++ll)
            for (int rr = 0; rr &amp;lt; L; ++rr)
                for (int i = 1; i &amp;lt; L &amp;amp;&amp;amp; i &amp;lt; mid; ++i)
                    upd(res[ll][rr], merge(merge(tl[ll][i], tr[L - i][rr]), &amp;#123; 0, w[mid - i + 1] &amp;#125;));
        for (int ll = 0; ll &amp;lt; L; ++ll)
            for (int rr = L - 1; rr; --rr)
                upd(res[ll][rr - 1], res[ll][rr]);
        for (int rr = 0; rr &amp;lt; L; ++rr)
            for (int ll = L - 1; ll; --ll)
                upd(res[ll - 1][rr], res[ll][rr]);
        // for (int i = 0; i &amp;lt; L; ++i)
        //     for (int j = 0; j &amp;lt; L; ++j) &amp;#123;
        //         printf(&amp;quot;  (%d, %d): &amp;quot;, i, j);
        //         for (auto p : res[i][j])
        //             printf(&amp;quot;%lld &amp;quot;, p);
        //         puts(&amp;quot;&amp;quot;);
        //     &amp;#125;
        return res;
    &amp;#125;;
    auto res(calc(1, n));
    for (int i = 1; i &amp;lt;= n / L; ++i)
        std::cout &amp;lt;&amp;lt; res[0][0][i] &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;例假人&#34;&gt;例：假人&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;http://222.180.160.110:61235/problem/47728&#34; class=&#34;uri&#34;&gt;http://222.180.160.110:61235/problem/47728&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;令 &lt;span class=&#34;math inline&#34;&gt;\(f_{i,j}\)&lt;/span&gt; 表示前 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 组选完占了 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; 体积的最大价值。那么有 &lt;span class=&#34;math inline&#34;&gt;\(f_{i,j}=\max\{f_{i-1,k}+a_{i,j-k}\}\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;袜，这个东西好凸的样子！啊？居然不是凸的？&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;事实上，有结论：若干个体积为 &lt;span class=&#34;math inline&#34;&gt;\(0\sim 4\)&lt;/span&gt; 的物品做背包，可以凑出值域内任意 &lt;span class=&#34;math inline&#34;&gt;\(24\)&lt;/span&gt; 的倍数。所以先把体积全部 &lt;span class=&#34;math inline&#34;&gt;\(-1\)&lt;/span&gt;，然后就可以得到体积为 &lt;span class=&#34;math inline&#34;&gt;\(0\sim 4\)&lt;/span&gt; 的物品。然后会发现他们按照模 &lt;span class=&#34;math inline&#34;&gt;\(12\)&lt;/span&gt; 的余数分别是凸的。&lt;/p&gt;
&lt;p&gt;能感受到恶意了。然后就可以枚举体积，再闵可夫斯基和了。同样需要在状态中引入作为版本号的 &lt;span class=&#34;math inline&#34;&gt;\([l,r]\)&lt;/span&gt; 维，显然因变量是体积、版本号是组数。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const long long inf = 1e18;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;fake2.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#endif
    int n, m = 0;
    std::cin &amp;gt;&amp;gt; n;
    std::vector&amp;lt;int&amp;gt; siz(n + 1);
    std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; a(n + 1);
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        std::cin &amp;gt;&amp;gt; siz[i], m += siz[i];
        a[i].resize(siz[i] + 1);
        for (int j = 1; j &amp;lt;= siz[i]; ++j)
            std::cin &amp;gt;&amp;gt; a[i][j];
    &amp;#125;
    using arr = std::vector&amp;lt;long long&amp;gt;;
    struct node &amp;#123;
        std::vector&amp;lt;arr&amp;gt; f;
        node(): f(12) &amp;#123;&amp;#125;
        arr &amp;amp;operator[] (int q) &amp;#123;
            return f[q];
        &amp;#125;
    &amp;#125;;
    auto merge = [&amp;amp;](arr &amp;amp;p, arr &amp;amp;q) &amp;#123;
        arr res((int)(p.size() + q.size()) - 1), dp(p.size()), dq(q.size());
        std::adjacent_difference(p.begin(), p.end(), dp.begin());
        std::adjacent_difference(q.begin(), q.end(), dq.begin());
        std::merge(dp.begin() + 1, dp.end(), dq.begin() + 1, dq.end(), res.begin() + 1, std::greater&amp;lt;long long&amp;gt; ());
        res[0] = p[0] + q[0];
        std::partial_sum(res.begin(), res.end(), res.begin());
        return res;
    &amp;#125;;
    auto upd = [&amp;amp;](arr y, arr &amp;amp;x, int tag) &amp;#123;
        if (tag)
            y.insert(y.begin(), -inf);
        if (y.size() &amp;gt; x.size())
            x.resize(y.size(), -inf);
        for (int i = 0; i &amp;lt; (int)y.size(); ++i)
            x[i] = std::max(x[i], y[i]);
        return;
    &amp;#125;;
    std::function&amp;lt;node(int, int)&amp;gt; calc = [&amp;amp;](int l, int r) &amp;#123;
        if (l == r) &amp;#123;
            node res;
            for (int i = 1; i &amp;lt;= siz[l]; ++i)
                res[i - 1].push_back(a[l][i]);
            return res;
        &amp;#125;
        int mid = (l + r) &amp;gt;&amp;gt; 1;
        node tl(calc(l, mid)), tr(calc(mid + 1, r)), res;
        for (int p = 0; p &amp;lt; 12; ++p)
            for (int q = 0; q &amp;lt; 12; ++q)
                if (!tl[p].empty() &amp;amp;&amp;amp; !tr[q].empty())
                    upd(merge(tl[p], tr[q]), res[(p + q) % 12], p + q &amp;gt;= 12);
        return res;
    &amp;#125;;
    auto res(calc(1, n));
    for (int i = 0; i &amp;lt;= m - n; ++i)
        std::cout &amp;lt;&amp;lt; res[i % 12][i / 12] &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
    std::cout &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;slope-trick&#34;&gt;slope trick&lt;/h2&gt;
&lt;p&gt;对于一个 OI 中的凸函数，它是由一些斜率单调的线段拼接成的图形。&lt;/p&gt;
&lt;p&gt;在这个前提下，发现可以用整个函数的左 / 右端点值（截距）和 &lt;span class=&#34;math inline&#34;&gt;\((n-1)\)&lt;/span&gt; 个斜率 / 差分信息描述函数。而这有时比直接维护 &lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt; 个点值有着更优美的性质，唤其为 slope trick。&lt;/p&gt;
&lt;p&gt;例如，关于斜率序列，如果定义域不大，可以直接维护；如果它的变化次数不多，可以利用它的单调性质，用单调数据结构维护；如果它的值域很小，可以直接维护拐点。&lt;/p&gt;
&lt;p&gt;注意前两种方法一般关注横坐标对应的函数值，所以自变量一般是和操作次数一类有关的；而这里关注函数最值而弱化了具体横坐标，操作次数一般会作为待最优化的因变量，例如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;我想要将数列通过若干次单点修改使序列单调，但不关心序列最终形态，问最小操作次数。&lt;/li&gt;
&lt;li&gt;我想要让树上所有叶子到根的路径边权和相等，但不关心这个值是多少，问最小操作次数。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面依次解决上述问题。&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;例序列-sequence&#34;&gt;例：序列 sequence&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P4597&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P4597&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;暴力地，令 &lt;span class=&#34;math inline&#34;&gt;\(f_{i,j}\)&lt;/span&gt; 表示 &lt;span class=&#34;math inline&#34;&gt;\(a_i\)&lt;/span&gt; 最终被修改为 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt;，容易写出 DP 式子 &lt;span class=&#34;math inline&#34;&gt;\(f_{i,j}=\min\limits_{k\le j}\{f_{i-1,k}\}+|a_i-j|\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;然后就会发现它的定义域实在是太大了！那如果关注斜率的变化情况呢？&lt;/p&gt;
&lt;p&gt;令 &lt;span class=&#34;math inline&#34;&gt;\(f_{i-1}(k)\)&lt;/span&gt; 的极值点为 &lt;span class=&#34;math inline&#34;&gt;\(k_m\)&lt;/span&gt;，分类讨论拆绝对值和 min：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;当 &lt;span class=&#34;math inline&#34;&gt;\(j\le a_i\)&lt;/span&gt; 时，&lt;span class=&#34;math inline&#34;&gt;\(f_i(j)=\min\limits_{k\le j}\{f_{i-1}(k)\}+a_i - j\)&lt;/span&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当 &lt;span class=&#34;math inline&#34;&gt;\(j &amp;lt; k_m\)&lt;/span&gt; 时，&lt;span class=&#34;math inline&#34;&gt;\(f_i(j)=f_{i-1}(j)+a_i-j\)&lt;/span&gt;，斜率相对于 &lt;span class=&#34;math inline&#34;&gt;\(f_{i-1}(j)\)&lt;/span&gt; 整体减 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt;。&lt;del&gt;我就说导数没白学吧&lt;/del&gt;&lt;/li&gt;
&lt;li&gt;当 &lt;span class=&#34;math inline&#34;&gt;\(j \ge k_m\)&lt;/span&gt; 时，&lt;span class=&#34;math inline&#34;&gt;\(f_i(j)=f_{i-1}(k_m)+a_i-j\)&lt;/span&gt;，斜率为 &lt;span class=&#34;math inline&#34;&gt;\(-1\)&lt;/span&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;当 &lt;span class=&#34;math inline&#34;&gt;\(j &amp;gt; a_i\)&lt;/span&gt; 时，&lt;span class=&#34;math inline&#34;&gt;\(f_i(j)=\min\limits_{k\le j}\{f_{i-1}(k)\}+j-a_i\)&lt;/span&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当 &lt;span class=&#34;math inline&#34;&gt;\(j &amp;lt; k_m\)&lt;/span&gt; 时，&lt;span class=&#34;math inline&#34;&gt;\(f_i(j)=f_{i-1}(j)+j-a_i\)&lt;/span&gt;，斜率相对于 &lt;span class=&#34;math inline&#34;&gt;\(f_{i-1}(j)\)&lt;/span&gt; 整体加 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;当 &lt;span class=&#34;math inline&#34;&gt;\(j\ge k_m\)&lt;/span&gt; 时，&lt;span class=&#34;math inline&#34;&gt;\(f_i(j) = f_{i-1}(k_m)+j-a_i\)&lt;/span&gt;，斜率为 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果现在我们掏一个支持区间加斜率、区间推平斜率且维护区间函数最值点的数据结构，那就太逆天了。一个经典的解决方案是用堆维护线段斜率的差分（也就是差分的差分）。&lt;/p&gt;
&lt;p&gt;发现整体修改次数是 &lt;span class=&#34;math inline&#34;&gt;\(O(n)\)&lt;/span&gt; 的，且如果只看比 &lt;span class=&#34;math inline&#34;&gt;\(k_m\)&lt;/span&gt; 更左的 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt;（更靠右的已经与极值无关所以不用维护），那么就只需要维护区间减法。&lt;/p&gt;
&lt;p&gt;如果将一次区间前缀减法看作一次前缀右端点入队，显然左侧某点 &lt;span class=&#34;math inline&#34;&gt;\(a\)&lt;/span&gt; 的实际被减次数为 &lt;span class=&#34;math inline&#34;&gt;\(a\)&lt;/span&gt; 入队的次数 + 所有右于 &lt;span class=&#34;math inline&#34;&gt;\(a\)&lt;/span&gt; 点的元素的入队次数。用大根堆维护这些元素，就可以快速维护整个斜率序列。例如 &lt;code&gt;3 2 2 1&lt;/code&gt;，代表 &lt;span class=&#34;math inline&#34;&gt;\(3\)&lt;/span&gt; 处斜率为 &lt;span class=&#34;math inline&#34;&gt;\(-1\)&lt;/span&gt;，&lt;span class=&#34;math inline&#34;&gt;\(2\)&lt;/span&gt; 处斜率为 &lt;span class=&#34;math inline&#34;&gt;\(-3\)&lt;/span&gt;，&lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt; 处斜率为 &lt;span class=&#34;math inline&#34;&gt;\(-4\)&lt;/span&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;当 &lt;span class=&#34;math inline&#34;&gt;\(a_i\ge k_m\)&lt;/span&gt; 时（容易发现它会成为新的 &lt;span class=&#34;math inline&#34;&gt;\(k_m\)&lt;/span&gt;），直接把 &lt;span class=&#34;math inline&#34;&gt;\(a_i\)&lt;/span&gt; 加入大根堆，就可以把 &lt;span class=&#34;math inline&#34;&gt;\(\le a_i\)&lt;/span&gt; 的所有位置斜率减去 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt;。&lt;/p&gt;
什么你问在 &lt;span class=&#34;math inline&#34;&gt;\(k_m\)&lt;/span&gt; 和 &lt;span class=&#34;math inline&#34;&gt;\(a_i\)&lt;/span&gt; 之间的推平怎么办？由于唯一右于它们的拐点 &lt;span class=&#34;math inline&#34;&gt;\(a_i\)&lt;/span&gt; 入了一次队，所以中间的元素斜率自然是 &lt;span class=&#34;math inline&#34;&gt;\(-1\)&lt;/span&gt; 啊。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;当 &lt;span class=&#34;math inline&#34;&gt;\(a_i&amp;lt;k_m\)&lt;/span&gt; 时，我们需要：&lt;/p&gt;
&lt;ol type=&#34;1&#34;&gt;
&lt;li&gt;将 &lt;span class=&#34;math inline&#34;&gt;\(a_i\)&lt;/span&gt; 以左的位置斜率减去 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt;，直接将 &lt;span class=&#34;math inline&#34;&gt;\(a_i\)&lt;/span&gt; 入队即可。&lt;/li&gt;
&lt;li&gt;将 &lt;span class=&#34;math inline&#34;&gt;\(a_i\)&lt;/span&gt; 和 &lt;span class=&#34;math inline&#34;&gt;\(k_m\)&lt;/span&gt; 之间的位置斜率加上 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt;，把 &lt;span class=&#34;math inline&#34;&gt;\(k_m\)&lt;/span&gt; 弹出（太好了就在队首）再把 &lt;span class=&#34;math inline&#34;&gt;\(a_i\)&lt;/span&gt; 加入即可。由于 &lt;span class=&#34;math inline&#34;&gt;\(k_m\)&lt;/span&gt; 显然是一个拐点，所以删除 &lt;span class=&#34;math inline&#34;&gt;\(k_m\)&lt;/span&gt; 并非虚空索敌，但注意 &lt;span class=&#34;math inline&#34;&gt;\(k_m\)&lt;/span&gt; 可能会变化成其后继。&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其实就会发现还有一些有趣的小性质，比如 &lt;span class=&#34;math inline&#34;&gt;\(k_m\)&lt;/span&gt; 与队首等价（用于实现）；&lt;span class=&#34;math inline&#34;&gt;\(k_m\)&lt;/span&gt; 右侧斜率全部为 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt;，也是唯一可以取到的正斜率。&lt;/p&gt;
&lt;details&gt;
&lt;p&gt;袜写起来好简单。&lt;/p&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#endif
    int n;
    std::cin &amp;gt;&amp;gt; n;
    std::vector&amp;lt;int&amp;gt; a(n + 1);
    long long res = 0ll;
    std::priority_queue&amp;lt;int&amp;gt; q;
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        std::cin &amp;gt;&amp;gt; a[i];
        if (i == 1 || a[i] &amp;gt;= q.top())
            q.push(a[i]);
        else &amp;#123;
            res += q.top() - a[i];
            q.pop(), q.push(a[i]), q.push(a[i]);
        &amp;#125;
    &amp;#125;
    std::cout &amp;lt;&amp;lt; res &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;例烟花表演&#34;&gt;例：烟花表演&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P3642&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P3642&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;设 &lt;span class=&#34;math inline&#34;&gt;\(f_{u,d}\)&lt;/span&gt; 表示在 &lt;span class=&#34;math inline&#34;&gt;\(u\)&lt;/span&gt; 子树中所有叶子距根均为 &lt;span class=&#34;math inline&#34;&gt;\(d\)&lt;/span&gt; 的最小代价。那么有：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
f_{u,d}=\sum\limits_{(v, w)\in u}\min\limits_{0\le w&amp;#39;\le d}\{f_{v,d-w&amp;#39;}+|w-w&amp;#39;|\}.
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;可以归纳证明 &lt;span class=&#34;math inline&#34;&gt;\(f_{u,d}\)&lt;/span&gt; 为凸；和上一题相似地，考虑用 &lt;span class=&#34;math inline&#34;&gt;\(f_v\)&lt;/span&gt; 的堆得到 &lt;span class=&#34;math inline&#34;&gt;\(f_u\)&lt;/span&gt; 的堆。&lt;/p&gt;
&lt;p&gt;首先最外层是一个线性加，这其实就是把差分数组 / 斜率加起来，放到我们这个堆里面就是合并两个堆。虽然你可能和我一样不认识可并堆，但是你可以和我一样不会 pd_ds。&lt;/p&gt;
&lt;p&gt;再看内层，发现和上一题长得像但其实不一样，呜呜呜。发现 &lt;span class=&#34;math inline&#34;&gt;\(|w-w&amp;#39;|\)&lt;/span&gt; 是一个左右斜率分别为 &lt;span class=&#34;math inline&#34;&gt;\(-1,1\)&lt;/span&gt; 的分段函数，而左边类比可得斜率最大为 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;由闵可夫斯基和，内层函数斜率 &lt;span class=&#34;math inline&#34;&gt;\(&amp;lt;-1\)&lt;/span&gt; 的部分来自 &lt;span class=&#34;math inline&#34;&gt;\(f_{v,d-w&amp;#39;}\)&lt;/span&gt;；&lt;span class=&#34;math inline&#34;&gt;\(=-1\)&lt;/span&gt; 的部分来自 &lt;span class=&#34;math inline&#34;&gt;\(f_{v,d-w&amp;#39;}\)&lt;/span&gt; 和 &lt;span class=&#34;math inline&#34;&gt;\(|w-w&amp;#39;|\)&lt;/span&gt; 的左半边（感谢 &lt;span class=&#34;math inline&#34;&gt;\(w&amp;#39;\)&lt;/span&gt; 是有下确界的）；&lt;span class=&#34;math inline&#34;&gt;\(=0\)&lt;/span&gt; 的部分来自 &lt;span class=&#34;math inline&#34;&gt;\(f_{v,d-w&amp;#39;}\)&lt;/span&gt;；&lt;span class=&#34;math inline&#34;&gt;\(&amp;gt;0\)&lt;/span&gt; 的部分我们不关心。&lt;/p&gt;
&lt;p&gt;最终函数图像的变化：水平部分的左端点右移了 &lt;span class=&#34;math inline&#34;&gt;\(w\)&lt;/span&gt;。找到 &lt;span class=&#34;math inline&#34;&gt;\(f_{v,d}\)&lt;/span&gt; 中的水平线段和斜率为 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt; 的线段，令其在堆中的值 &lt;span class=&#34;math inline&#34;&gt;\(+w\)&lt;/span&gt; 就能达到平移的目的。&lt;/p&gt;
&lt;p&gt;但需要注意，此时仍然需要 &lt;strong&gt;保留内层函数中斜率为 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt; 的部分，但斜率 &lt;span class=&#34;math inline&#34;&gt;\(&amp;gt;1\)&lt;/span&gt; 的部分被删除&lt;/strong&gt;。原因如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;绝对值函数与内层函数定义域相同，作闵可夫斯基和后，斜率为 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt; 的右侧线段会将 &lt;span class=&#34;math inline&#34;&gt;\(f_{v,d-w&amp;#39;}\)&lt;/span&gt; 中原有的 &lt;span class=&#34;math inline&#34;&gt;\(&amp;gt;1\)&lt;/span&gt; 的部分『挤』出定义域，故可以将其直接删除。&lt;/li&gt;
&lt;li&gt;斜率为 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt; 的部分，虽然对内层函数中极值点无贡献，但在外层函数中极值点可能向右偏移，此时会对其产生影响，需要维护。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;容易发现由于 &lt;span class=&#34;math inline&#34;&gt;\(w&amp;#39;\)&lt;/span&gt; 的取值上限是 &lt;span class=&#34;math inline&#34;&gt;\(d\)&lt;/span&gt;，但 &lt;span class=&#34;math inline&#34;&gt;\(d\)&lt;/span&gt; 没有上界，所以每个内层函数的右侧都一定是一条斜率为 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt; 的射线；也就是说，每个外层函数一定有（儿子个数）个拐点（堆中元素），弹出这么多个就可以删除外层函数中斜率 &lt;span class=&#34;math inline&#34;&gt;\(&amp;gt;1\)&lt;/span&gt; 的线段，顺便找到斜率为 &lt;span class=&#34;math inline&#34;&gt;\(0\)&lt;/span&gt; 和 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt; 的线段。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
#include &amp;lt;ext/pb_ds/priority_queue.hpp&amp;gt;
const int inf= 0x3f3f3f3f;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#endif
    int n, m;
    std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m, n += m;
    std::vector&amp;lt;std::vector&amp;lt;std::pair&amp;lt;int, int&amp;gt; &amp;gt; &amp;gt; g(n + 1);
    auto res(0ll);
    for (int i = 2, fa, w; i &amp;lt;= n; ++i) &amp;#123;
        std::cin &amp;gt;&amp;gt; fa &amp;gt;&amp;gt; w, res += w;
        g[fa].emplace_back(i, w);
    &amp;#125;
    std::vector&amp;lt;__gnu_pbds::priority_queue&amp;lt;long long&amp;gt; &amp;gt; q(n + 1);
    std::function&amp;lt;void(int)&amp;gt; DFS = [&amp;amp;](int x) &amp;#123;
        if (g[x].empty())
            q[x].push(0), q[x].push(0);
        else
            for (auto [i, w] : g[x]) &amp;#123;
                DFS(i);
                for (int j = 1; j &amp;lt; (int)g[i].size(); ++j)
                    q[i].pop();
                long long t1 = q[i].top(), t0;
                q[i].pop(), t0 = q[i].top(), q[i].pop();
                q[i].push(t1 + w), q[i].push(t0 + w);
                q[x].join(q[i]);
            &amp;#125;
        // fprintf(stderr, &amp;quot;size(%d) = %d\n&amp;quot;, x, (int)q[x].size());
        return;
    &amp;#125;;
    DFS(1);
    for (int i = 1; i &amp;lt;= (int)g[1].size(); ++i)
        q[1].pop();
    for (; !q[1].empty(); q[1].pop())
        res -= q[1].top();
    std::cout &amp;lt;&amp;lt; res &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;例buy-low-sell-high&#34;&gt;例：Buy Low Sell High&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://codeforces.com/problemset/problem/865/D&#34; class=&#34;uri&#34;&gt;https://codeforces.com/problemset/problem/865/D&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;令 &lt;span class=&#34;math inline&#34;&gt;\(f_{i,j}\)&lt;/span&gt; 表示在第 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 天结束后持有 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; 支股票的最大收益。则 &lt;span class=&#34;math inline&#34;&gt;\(f_{i,j}=\max\{f_{i-1,j},f_{i-1,j-1}-a_i,f_{i-1,j+1}+a_i\}\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;（由于这里和 max 有关所以需要精细描述凹凸了）发现就是把三个（可能）经过平移的（可能）凹的函数做线性 max。虽然实际上的结论『函数在整点上是凹的』不算太显然，但是可以猜是凹的。&lt;/p&gt;
&lt;p&gt;线性 max 在 slope trick 中是不太能体现的，但我们发现这里是同一个凹函数向左上、右下平移同一个向量，希望得到新的凹函数不管是从差分角度还是图象，都能得到新函数由左上部分斜率 &lt;span class=&#34;math inline&#34;&gt;\(&amp;gt;-a_i\)&lt;/span&gt; 的线段、两段斜率 &lt;span class=&#34;math inline&#34;&gt;\(=-a_i\)&lt;/span&gt; 的线段、右下部分斜率 &lt;span class=&#34;math inline&#34;&gt;\(&amp;lt;-a_i\)&lt;/span&gt; 的线段组成。此外，由于向左上平移的函数有一处离开了定义域，还需将其剔除。&lt;/p&gt;
&lt;p&gt;值得注意的是，当 &lt;span class=&#34;math inline&#34;&gt;\(-a_i\)&lt;/span&gt; 比最小斜率还要小时会有变化，可以画图看一下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;2.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;发现定义域是相对小的（&lt;span class=&#34;math inline&#34;&gt;\(0\le j\le n\)&lt;/span&gt;），故用优先队列维护整个斜率序列就可以快速插入两个 &lt;span class=&#34;math inline&#34;&gt;\(k=-a_i\)&lt;/span&gt; 的线段。容易发现顶点在 &lt;span class=&#34;math inline&#34;&gt;\(j=0\)&lt;/span&gt; 处取得（从图象和定义都易知），最右侧是只买不卖的最劣方案，可以倒推。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#endif
    int n;
    std::cin &amp;gt;&amp;gt; n;
    std::vector&amp;lt;int&amp;gt; a(n + 1);
    auto res = 0ll;
    for (int i = 1; i &amp;lt;= n; ++i)
        std::cin &amp;gt;&amp;gt; a[i], res -= a[i];
    std::priority_queue&amp;lt;int&amp;gt; q;
    q.push(-a[1]);
    for (int i = 2; i &amp;lt;= n; ++i)
        if (a[i] &amp;lt; -q.top())
            q.push(-a[i]);
        else
            q.pop(), q.push(-a[i]), q.push(-a[i]);
    for (; !q.empty(); res -= q.top(), q.pop());
    std::cout &amp;lt;&amp;lt; res &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://xsc062.netlify.app/20250510/</guid>
            <title>杂题</title>
            <link>https://xsc062.netlify.app/20250510/</link>
            <category>DP</category>
            <category>容斥原理</category>
            <category>树链剖分</category>
            <category>反悔贪心</category>
            <pubDate>Sat, 10 May 2025 10:18:21 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;啊啊。小封条。&lt;/p&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;a---pass-to-next&#34;&gt;A - Pass to Next&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/arc124/tasks/arc124_e&#34; class=&#34;uri&#34;&gt;https://atcoder.jp/contests/arc124/tasks/arc124_e&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;感觉其他一些题解讲得不是特别清楚，这里参考了 &lt;a href=&#34;https://blog.csdn.net/weixin_43960287/article/details/119140590&#34;&gt;XJX 的文章&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;要求的答案是 &lt;span class=&#34;math inline&#34;&gt;\(\prod a&amp;#39;_i\)&lt;/span&gt;，&lt;mark&gt;发现运算是乘法，比较怪；由此考虑转化为方案数，也就是假设每个人有 &lt;span class=&#34;math inline&#34;&gt;\(a&amp;#39;_i\)&lt;/span&gt; 个互不相同的球，每个人在其中选出恰好一个的方案数&lt;/mark&gt;。&lt;/p&gt;
&lt;p&gt;考虑 DP。发现每个人手上的球分为『自己的』和『左边的人传过来的』两种类型；&lt;mark&gt;显然第二种会有来自上一个人的限制，考虑把第二种在上一个人就完成求解&lt;/mark&gt;。具体地，设 &lt;span class=&#34;math inline&#34;&gt;\(f_{i,0}\)&lt;/span&gt; 表示第 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 个人选取自己的球，但只记录 &lt;span class=&#34;math inline&#34;&gt;\(1\sim i-1\)&lt;/span&gt; 的方案；&lt;span class=&#34;math inline&#34;&gt;\(f_{i,1}\)&lt;/span&gt; 表示第 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 个人选取第 &lt;span class=&#34;math inline&#34;&gt;\(i-1\)&lt;/span&gt; 个人的球，并记入答案的方案。&lt;em&gt;你可能需要注意到：最后一个被记入方案的球来自第 &lt;span class=&#34;math inline&#34;&gt;\(i-1\)&lt;/span&gt; 个人&lt;/em&gt;。&lt;/p&gt;
&lt;p&gt;但这样会有个小问题。我们让所有人多往右边传一个球，那么在我们的这种分割方法看来是不一样的局面；但实际上它们是等价的。从每个人传出了多少个球（设为 &lt;span class=&#34;math inline&#34;&gt;\(x_i\)&lt;/span&gt;）的角度来看，对于 &lt;span class=&#34;math inline&#34;&gt;\(\min\{x_n\}\ne 0\)&lt;/span&gt;，只需要不断执行 &lt;span class=&#34;math inline&#34;&gt;\(\forall\, x_i\gets x_i-1\)&lt;/span&gt; 就可以在局面不变的情况下使 &lt;span class=&#34;math inline&#34;&gt;\(\min\{x_n\}\ne 0\)&lt;/span&gt;。这是在说，可以让 &lt;span class=&#34;math inline&#34;&gt;\(\min\{x_n\}\ne 0\)&lt;/span&gt; 的方案和终局一一对应。&lt;/p&gt;
&lt;p&gt;发现可以容斥：钦定 &lt;span class=&#34;math inline&#34;&gt;\(x_i\ge 1\)&lt;/span&gt;，也就是每个人必须往右传至少一个，相似地算一遍就能得到非法方案。&lt;/p&gt;
&lt;p&gt;考虑转移，令 &lt;span class=&#34;math inline&#34;&gt;\(x_i\)&lt;/span&gt; 可选最小值为 &lt;span class=&#34;math inline&#34;&gt;\(l\)&lt;/span&gt;，有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class=&#34;math inline&#34;&gt;\(f_{i+1,0}\gets f_{i,0}\)&lt;/span&gt;：将第 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 个人未被记入的自己的球记入，球数可能为 &lt;span class=&#34;math inline&#34;&gt;\([0,a_i-l]\)&lt;/span&gt;。等差数列求和即可。&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;math inline&#34;&gt;\(f_{i+1,0}\gets f_{i,1}\)&lt;/span&gt;：没有球需要被记入，但是这种情况对应多种 &lt;span class=&#34;math inline&#34;&gt;\(x_i\)&lt;/span&gt;。具体地，&lt;span class=&#34;math inline&#34;&gt;\(x_i\in [l,a_i]\)&lt;/span&gt;。共有 &lt;span class=&#34;math inline&#34;&gt;\(a_i-l+1\)&lt;/span&gt; 种方案。&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;math inline&#34;&gt;\(f_{i+1,1}\gets f_{i,0}\)&lt;/span&gt;：将第 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 个人的 &lt;span class=&#34;math inline&#34;&gt;\(a_i\)&lt;/span&gt; 个球分给 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 和 &lt;span class=&#34;math inline&#34;&gt;\(i+1\)&lt;/span&gt;。共有 &lt;span class=&#34;math inline&#34;&gt;\(x_i\cdot (a_i-x_i)\)&lt;/span&gt; 种可能，也就是 &lt;span class=&#34;math inline&#34;&gt;\(\left(a_i\cdot \sum_{x_i=l}^{a_i} x_i\right)-\left(\sum_{x_i=l}^{a_i}{x_i}^2\right)\)&lt;/span&gt; 种方案。&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;math inline&#34;&gt;\(f_{i+1,1}\gets f_{i,1}\)&lt;/span&gt;：将第 &lt;span class=&#34;math inline&#34;&gt;\(i+1\)&lt;/span&gt; 个人得到的第 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 个人的球记入，同第一条。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;破环为链，分别钦定第一个人是用自己的球还是上一个人的球来解决问题（必须对于两种可能性分开计算；否则就不知道答案应该取 &lt;span class=&#34;math inline&#34;&gt;\(f_{n,0}\)&lt;/span&gt; 还是 &lt;span class=&#34;math inline&#34;&gt;\(f_{n,1}\)&lt;/span&gt;）。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int mod = 998244353, inv2 = (mod + 1) &amp;gt;&amp;gt; 1, inv6 = 166374059;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#endif
    int n;
    std::cin &amp;gt;&amp;gt; n;
    std::vector&amp;lt;long long&amp;gt; a(n);
    for (int i = 1; i &amp;lt;= n; ++i)
        std::cin &amp;gt;&amp;gt; a[i % n];
    auto sum = [&amp;amp;](long long r) &amp;#123;
        return r * (r + 1) % mod * inv2 % mod;
    &amp;#125;;
    auto sum2 = [&amp;amp;](long long r) &amp;#123;
        return r * (r + 1) % mod * (2 * r % mod + 1) % mod * inv6 % mod;
    &amp;#125;;
    std::vector&amp;lt;std::vector&amp;lt;long long&amp;gt; &amp;gt; f0(n, std::vector&amp;lt;long long&amp;gt; (2)), f1(n, std::vector&amp;lt;long long&amp;gt; (2));
    auto calc = [&amp;amp;](long long l, std::vector&amp;lt;std::vector&amp;lt;long long&amp;gt; &amp;gt; &amp;amp;f) &amp;#123;
        f[0][0] = 1ll;
        for (int i = 0; i &amp;lt; n; ++i) &amp;#123;
            int j = (i + 1) % n;
            f[j][0] = f[i][0] * sum(a[i] - l) % mod;
            (f[j][0] += f[i][1] * (a[i] - l + 1)) %= mod;
            f[j][1] = f[i][0] * (a[i] * sum(a[i]) % mod - sum2(a[i])) % mod;
            (f[j][1] += f[i][1] * sum(a[i]) % mod) %= mod;
            // printf(&amp;quot;0, l = %lld, f[%d]: %lld / %lld\n&amp;quot;, l, j, f[j][0], f[j][1]);
        &amp;#125;
        auto res(f[0][0]);
        f.assign(n, std::vector&amp;lt;long long&amp;gt; (2));
        f[0][1] = 1ll;
        for (int i = 0; i &amp;lt; n; ++i) &amp;#123;
            int j = (i + 1) % n;
            f[j][0] = f[i][0] * sum(a[i] - l) % mod;
            (f[j][0] += f[i][1] * (a[i] - l + 1)) %= mod;
            f[j][1] = f[i][0] * (a[i] * sum(a[i]) % mod - sum2(a[i])) % mod;
            (f[j][1] += f[i][1] * sum(a[i]) % mod) %= mod;
            // printf(&amp;quot;1, l = %lld, f[%d]: %lld / %lld\n&amp;quot;, l, j, f[j][0], f[j][1]);
        &amp;#125;
        return (res + f[0][1]) % mod;
    &amp;#125;;
    std::cout &amp;lt;&amp;lt; (calc(0, f0) + mod - calc(1, f1)) % mod &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;b---绿宝石之岛&#34;&gt;B - 绿宝石之岛&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://loj.ac/p/6406&#34; class=&#34;uri&#34;&gt;https://loj.ac/p/6406&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;因为只关心最终状态，原题可以转化为：将 &lt;span class=&#34;math inline&#34;&gt;\(d\)&lt;/span&gt; 分成 &lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt; 个非负整数，前 &lt;span class=&#34;math inline&#34;&gt;\(r\)&lt;/span&gt; 大数之和的期望（当然你需要加上初始的 &lt;span class=&#34;math inline&#34;&gt;\(r\)&lt;/span&gt; 个）。&lt;/p&gt;
&lt;p&gt;关于非负整数拆分：设 &lt;span class=&#34;math inline&#34;&gt;\(f_{i,j}\)&lt;/span&gt; 表示将 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 分成 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; 个 &lt;strong&gt;非负整数&lt;/strong&gt; 的方案，钦定其中恰有 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 个 &lt;strong&gt;正整数&lt;/strong&gt; 进行转移，给这 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 个数先分一个 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt;，则 &lt;span class=&#34;math inline&#34;&gt;\(f_{i,j}=\sum\limits_{k=0}^{\min(i,j)} C_j^k\cdot f_{i-k,k}\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;再设 &lt;span class=&#34;math inline&#34;&gt;\(g_{i,j}\)&lt;/span&gt; 表示将 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 分成 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; 个非负整数的所有方案中、前 &lt;span class=&#34;math inline&#34;&gt;\(r\)&lt;/span&gt; 大的数之和。类似地，有 &lt;span class=&#34;math inline&#34;&gt;\(g_{i,j}=\sum\limits_{k=0}^{\min(i,j)} C_j^k\cdot (g_{i-k,k}+\min(k,r)\cdot f_{i-k,k})\)&lt;/span&gt;。其中，&lt;span class=&#34;math inline&#34;&gt;\(\min(k,r)\)&lt;/span&gt; 的来源是，只有 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 个数有值，前 &lt;span class=&#34;math inline&#34;&gt;\(r\)&lt;/span&gt; 大的数一定在这 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 个数里面。&lt;/p&gt;
&lt;p&gt;答案为 &lt;span class=&#34;math inline&#34;&gt;\(\dfrac {g_{d,n}}{f_{d,n}}+r\)&lt;/span&gt;，复杂度 &lt;span class=&#34;math inline&#34;&gt;\(O(n^3)\)&lt;/span&gt;。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#endif
    int n, d, r;
    std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; d &amp;gt;&amp;gt; r;
    using arr = std::vector&amp;lt;double&amp;gt;;
    std::vector&amp;lt;arr&amp;gt; f(d + 1, arr(n + 1)), g(d + 1, arr(n + 1)), C(n + 1, arr(n + 1));
    for (int i = 0; i &amp;lt;= n; ++i) &amp;#123;
        C[i][0] = 1.;
        for (int j = 1; j &amp;lt;= i; ++j)
            C[i][j] = C[i - 1][j - 1] + C[i - 1][j];
    &amp;#125;
    f[0].assign(n + 1, 1.);
    for (int i = 1; i &amp;lt;= d; ++i)
        for (int j = 1; j &amp;lt;= n; ++j) &amp;#123;
            for (int k = 1; k &amp;lt;= i &amp;amp;&amp;amp; k &amp;lt;= j; ++k) &amp;#123;
                f[i][j] += C[j][k] * f[i - k][k];
                g[i][j] += C[j][k] * (g[i - k][k] + std::min(k, r) * f[i - k][k]);
                // printf(&amp;quot;  k = %d, %.0lf + %.0lf\n&amp;quot;, k, C[j][k] * g[i - k][k], std::min(k, r) * f[i - k][k]);
            &amp;#125;
            // printf(&amp;quot;f[%d][%d] = %.0lf, g[%d][%d] = %.0lf\n&amp;quot;, i, j, f[i][j], i, j, g[i][j]);
        &amp;#125;
    std::cout &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(8) &amp;lt;&amp;lt; g[d][n] / f[d][n] + r &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;c---uddered-but-not-herd-g&#34;&gt;C - Uddered but not Herd G&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P7296&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P7296&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;给每个字母分配一个标号 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt;，那么最小段数就是 &lt;span class=&#34;math inline&#34;&gt;\(\sum \left[x_i\ge x_{i+1}\right]\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;考虑状压完成映射操作，令 &lt;span class=&#34;math inline&#34;&gt;\(f_{s}\)&lt;/span&gt; 表示给标号 &lt;span class=&#34;math inline&#34;&gt;\(1\sim |s|\)&lt;/span&gt; 分配字母后，占用字符集 &lt;span class=&#34;math inline&#34;&gt;\(s\)&lt;/span&gt; 的方案数，那么就能 &lt;span class=&#34;math inline&#34;&gt;\(O(1)\)&lt;/span&gt; 得到贡献——只需预处理出 &lt;span class=&#34;math inline&#34;&gt;\(f_{c, s}\)&lt;/span&gt; 表示分配到字母 &lt;span class=&#34;math inline&#34;&gt;\(c\)&lt;/span&gt; 时，已经先给 &lt;span class=&#34;math inline&#34;&gt;\(s\)&lt;/span&gt; 中字母分配了更小标号时的贡献。&lt;/p&gt;
&lt;p&gt;注意字符集大小只有 &lt;span class=&#34;math inline&#34;&gt;\(20\)&lt;/span&gt;，可以 &lt;span class=&#34;math inline&#34;&gt;\(O(|S|\cdot 2^{|S|})\)&lt;/span&gt; 解决问题，&lt;mark&gt;注意到预处理的内容是类高维前缀最值的形式，可以递推降低复杂度&lt;/mark&gt;。&lt;/p&gt;
&lt;details&gt;
&lt;pre data-line=&#34;26-28&#34; class=&#34;cpp language-cpp&#34;&gt;&lt;code data-line=&#34;26-28&#34; class=&#34;cpp language-cpp&#34;&gt;#include &amp;lt;bits/stdc++.h&gt;
const int inf = 0x3f3f3f3f;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&#34;.in&#34;, &#34;r&#34;, stdin);
    std::freopen(&#34;.out&#34;, &#34;w&#34;, stdout);
#endif
    int n;
    std::string t;
    std::cin &gt;&gt; t, n = (int)t.length(), t = &#34;#&#34; + t;
    std::vector&amp;lt;int&gt; a, tag(26, -1), s(n + 1);
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        if (tag[t[i] - &#39;a&#39;] == -1)
            tag[t[i] - &#39;a&#39;] = (int)a.size(), a.push_back(t[i] - &#39;a&#39;);
        s[i] = tag[t[i] - &#39;a&#39;];
    &amp;#125;
    int m = (int)a.size(), siz = 1 &amp;lt;&amp;lt; m;
    std::vector&amp;lt;std::vector&amp;lt;int&gt; &gt; cnt(m, std::vector&amp;lt;int&gt; (m));
    for (int i = 1; i &amp;lt; n; ++i)
        ++cnt[s[i]][s[i + 1]];
    std::vector&amp;lt;std::vector&amp;lt;int&gt; &gt; g(m, std::vector&amp;lt;int&gt; (siz));
    for (int i = 0; i &amp;lt; m; ++i)
        for (int k = 0; k &amp;lt; m; ++k) // 注意这里相当于是钦定从 k 处转移
            for (int j = (1 &amp;lt;&amp;lt; k); j &amp;lt; (2 &amp;lt;&amp;lt; k); ++j) // 枚举的是 k 位为 1 的所有数；这两层循环的复杂度为 O(siz)
                g[i][j] = g[i][j ^ (1 &amp;lt;&amp;lt; k)] + cnt[i][k]; // 目的是此处的内存连续访问优化，把 ^ 看作 - 应该就能理解为什么第二维是连续的
    std::vector&amp;lt;int&gt; f(siz, inf);
    f[0] = 1;
    for (int i = 1; i &amp;lt; siz; ++i)
        for (int j = 0; j &amp;lt; m; ++j)
            if ((i &gt;&gt; j) &amp; 1)
                f[i] = std::min(f[i], f[i ^ (1 &amp;lt;&amp;lt; j)] + g[j][i]);
    std::cout &amp;lt;&amp;lt; f[siz - 1] &amp;lt;&amp;lt; &#39;\n&#39;;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;d---min-max-subarrays-p&#34;&gt;D - Min Max Subarrays P&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P11845&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P11845&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;先考虑 &lt;span class=&#34;math inline&#34;&gt;\(01\)&lt;/span&gt; 序列的答案：如果序列中存在相邻的 &lt;span class=&#34;math inline&#34;&gt;\(2\)&lt;/span&gt; 个 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt;，总能保证最后的一个是 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;如果序列中存在 &lt;span class=&#34;math inline&#34;&gt;\(\ge 3\)&lt;/span&gt; 个 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt;，可以牺牲其中的一些使得 &lt;span class=&#34;math inline&#34;&gt;\(2\)&lt;/span&gt; 个 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt; 相邻。&lt;/p&gt;
&lt;p&gt;当序列中只有 &lt;span class=&#34;math inline&#34;&gt;\(2\)&lt;/span&gt; 个 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt; 时，只有因为剩下的 &lt;span class=&#34;math inline&#34;&gt;\(0\)&lt;/span&gt; 不太够，导致我们无法随意『上下其手』时不能将 &lt;span class=&#34;math inline&#34;&gt;\(2\)&lt;/span&gt; 个 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt; 挪到一起。&lt;/p&gt;
&lt;p&gt;令两个 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt; 为序列最大值与次大值，暴搜处理序列长度较小的情况，剩下的直接用奇偶性判断两个 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt; 取哪个。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;a---mst-on-line&#34;&gt;A - MST on Line++&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/arc167/tasks/arc167_c&#34; class=&#34;uri&#34;&gt;https://atcoder.jp/contests/arc167/tasks/arc167_c&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;相当于把 &lt;span class=&#34;math inline&#34;&gt;\(a\)&lt;/span&gt; 打乱然后处理原问题。考虑每个 &lt;span class=&#34;math inline&#34;&gt;\(a_i\)&lt;/span&gt; 的贡献次数。模拟 Kruskal 连边，从小到大把点 &lt;span class=&#34;math inline&#34;&gt;\(a_i\)&lt;/span&gt; 加入图，&lt;span class=&#34;math inline&#34;&gt;\(a_i\)&lt;/span&gt; 可以向 &lt;span class=&#34;math inline&#34;&gt;\(a_{[i-K,i+K]}\)&lt;/span&gt; 内所有连通块连边。&lt;/p&gt;
&lt;p&gt;连通块数量当且仅当 &lt;span class=&#34;math inline&#34;&gt;\([i-K,i)\)&lt;/span&gt; 内最靠右的点和 &lt;span class=&#34;math inline&#34;&gt;\((i, i+K]\)&lt;/span&gt; 内最靠左的点距离 &lt;span class=&#34;math inline&#34;&gt;\(&amp;gt;K\)&lt;/span&gt; 时为 &lt;span class=&#34;math inline&#34;&gt;\(2\)&lt;/span&gt;，其余情况为 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;但要是从这个角度想这个题就不太好做了。正确的想法应该是&lt;mark&gt;拆分为『若 &lt;span class=&#34;math inline&#34;&gt;\([i-K,i)\)&lt;/span&gt; 中有点，贡献次数 &lt;span class=&#34;math inline&#34;&gt;\(+1\)&lt;/span&gt;』和『若 &lt;span class=&#34;math inline&#34;&gt;\((i,i+K]\)&lt;/span&gt; 中有点 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; 满足 &lt;span class=&#34;math inline&#34;&gt;\([j-K,j)\)&lt;/span&gt; 中无点，贡献次数 &lt;span class=&#34;math inline&#34;&gt;\(+1\)&lt;/span&gt;』&lt;/mark&gt;。对于第一个问题，贡献次数将前 &lt;span class=&#34;math inline&#34;&gt;\(i-1\)&lt;/span&gt; 大的数分配至少一个到 &lt;span class=&#34;math inline&#34;&gt;\([i-K,i)\)&lt;/span&gt; 中的方案数；对于第二个问题，枚举 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt;，贡献次数为将前 &lt;span class=&#34;math inline&#34;&gt;\(i-1\)&lt;/span&gt; 大的数分配到 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; 和 &lt;span class=&#34;math inline&#34;&gt;\([1,j-K)\cup (j, n]\)&lt;/span&gt; 中的方案数。&lt;/p&gt;
&lt;details&gt;
&lt;p&gt;实现的时候千万注意循环变量枚举的是位置还是值！不然你会调得很痛苦。&lt;/p&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int mod = 998244353;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;03-max-01.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#endif
    int n, k;
    std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; k;
    std::vector&amp;lt;int&amp;gt; a(n + 1);
    for (int i = 1; i &amp;lt;= n; ++i)
        std::cin &amp;gt;&amp;gt; a[i];
    std::sort(a.begin() + 1, a.end());
    std::vector&amp;lt;long long&amp;gt; fac(n + 1), inv(n + 1);
    fac[0] = inv[0] = 1ll;
    for (int i = 1; i &amp;lt;= n; ++i)
        fac[i] = fac[i - 1] * i % mod;
    auto qkp = [](long long x, int y) &amp;#123;
        auto res(1ll);
        for (; y; (x *= x) %= mod, y &amp;gt;&amp;gt;= 1)
            if (y &amp;amp; 1)
                (res *= x) %= mod;
        return res;
    &amp;#125;;
    inv[n] = qkp(fac[n], mod - 2);
    for (int i = n - 1; i; --i)
        inv[i] = inv[i + 1] * (i + 1) % mod;
    auto A = [&amp;amp;](int n, int m) &amp;#123;
        if (n &amp;lt; m)
            return 0ll;
        return fac[n] * inv[n - m] % mod;
    &amp;#125;;
    auto C = [&amp;amp;](int n, int m) &amp;#123;
        return A(n, m) * inv[m] % mod;
    &amp;#125;;
    long long res = 0ll;
    for (int i = 2; i &amp;lt;= n; ++i) &amp;#123;
        for (int j = 1; j &amp;lt;= n; ++j)
            (res += a[i] * (fac[n - 1] + mod - A(n - 1 - (j - std::max(1, j - k)), i - 1) * fac[n - i] % mod) % mod) %= mod;
        for (int j = 2; j &amp;lt;= n; ++j)
            (res += a[i] * C(i - 1, i - 2) % mod * C(j - std::max(1, j - k), 1) % mod * A(n - (j - std::max(1, j - k) + 1), i - 2) % mod * fac[n - i] % mod) %= mod;
    &amp;#125;
    std::cout &amp;lt;&amp;lt; res &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;b---existence-counting&#34;&gt;B - Existence Counting&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/arc174/tasks/arc174_e&#34; class=&#34;uri&#34;&gt;https://atcoder.jp/contests/arc174/tasks/arc174_e&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;发现可以分类讨论。假设 &lt;span class=&#34;math inline&#34;&gt;\(a&amp;#39;\)&lt;/span&gt; 中第一个异于 &lt;span class=&#34;math inline&#34;&gt;\(a\)&lt;/span&gt; 的位置为 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt;，&lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 在 &lt;span class=&#34;math inline&#34;&gt;\(a\)&lt;/span&gt; 中位置为 &lt;span class=&#34;math inline&#34;&gt;\(pos_x\)&lt;/span&gt;（不存在则 &lt;span class=&#34;math inline&#34;&gt;\(pos_x=k+1\)&lt;/span&gt;）。令 &lt;span class=&#34;math inline&#34;&gt;\(f_i\)&lt;/span&gt; 为若 &lt;span class=&#34;math inline&#34;&gt;\(1\sim i-1\)&lt;/span&gt; 均相同，&lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 位置可选的选项数。则 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 出现的次数：&lt;/p&gt;
&lt;table&gt;
&lt;colgroup&gt;
&lt;col style=&#34;width: 25%&#34; /&gt;
&lt;col style=&#34;width: 25%&#34; /&gt;
&lt;col style=&#34;width: 25%&#34; /&gt;
&lt;col style=&#34;width: 25%&#34; /&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr class=&#34;header&#34;&gt;
&lt;th style=&#34;text-align: center;&#34;&gt;&lt;/th&gt;
&lt;th style=&#34;text-align: center;&#34;&gt;&lt;span class=&#34;math inline&#34;&gt;\(pos_x&amp;lt;i\)&lt;/span&gt;&lt;/th&gt;
&lt;th style=&#34;text-align: center;&#34;&gt;&lt;span class=&#34;math inline&#34;&gt;\(pos_x=i\)&lt;/span&gt;&lt;/th&gt;
&lt;th style=&#34;text-align: center;&#34;&gt;&lt;span class=&#34;math inline&#34;&gt;\(pos_x&amp;gt;i,i&amp;lt;k\)&lt;/span&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;&lt;span class=&#34;math inline&#34;&gt;\(x\le a_i\)&lt;/span&gt;&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;&lt;span class=&#34;math inline&#34;&gt;\(1+f_i\cdot A_{n-i}^{k-i}\)&lt;/span&gt;&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;&lt;span class=&#34;math inline&#34;&gt;\(f_i\cdot C_{k-i}^1\cdot A_{n-i-1}^{k-i-1}\)&lt;/span&gt;&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;&lt;span class=&#34;math inline&#34;&gt;\((f_i-1)\cdot C_{k-i}^1\cdot A_{n-i-1}^{k-i-1}+A_{n-i}^{k-i}\)&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;&lt;span class=&#34;math inline&#34;&gt;\(x&amp;gt;a_i\)&lt;/span&gt;&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;&lt;span class=&#34;math inline&#34;&gt;\(f_i\cdot A_{n-i}^{k-i}\)&lt;/span&gt;&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;&lt;span class=&#34;math inline&#34;&gt;\(0\)&lt;/span&gt;&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;&lt;span class=&#34;math inline&#34;&gt;\(f_i\cdot C_{k-i}^1\cdot A_{n-i-1}^{k-i-1}\)&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;故，对于任意 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt;，答案为：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
\begin{aligned}
&amp;amp;1+\left(\sum_{i=pos_x+1}^k f_i\cdot A_{n-i}^{k-i}\right)
+\sum_{i=1}^{pos_x} (f_i-[x&amp;lt; a_i])\cdot C_{k-i}^1\cdot A_{n-i-1}^{k-i-1}+[x&amp;lt; a_i]\cdot A_{n-i}^{k-i}\\
=&amp;amp;1+\left(\sum_{i=pos_x+1}^k f_i\cdot A_{n-i}^{k-i}\right)
+\left(\sum_{i=1}^{pos_x} f_i\cdot C_{k-i}^1\cdot A_{n-i-1}^{k-i-1}\right)+\sum_{i=1,a_i&amp;gt; x}^{pos_x}A_{n-i}^{k-i}-C_{k-i}^1\cdot A_{n-i-1}^{k-i-1}\\
\end{aligned}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;预处理出 &lt;span class=&#34;math inline&#34;&gt;\(f_i=\sum\limits_{j=i+1}^k [a_j&amp;lt; a_i]\)&lt;/span&gt;（需要数据结构）、&lt;span class=&#34;math inline&#34;&gt;\(g_i=\sum\limits_{j=1}^i f_j\cdot A_{n-j}^{k-j}\)&lt;/span&gt; 和 &lt;span class=&#34;math inline&#34;&gt;\(h_j=\sum\limits_{j=1}^i f_i\cdot C_{k-i}^1\cdot A_{n-i-1}^{k-i-1}\)&lt;/span&gt;，再用数据结构计算 &lt;span class=&#34;math inline&#34;&gt;\(\sum\limits_{i=1,a_i&amp;gt;x}^{pos_x}C_{k-i}^1\cdot A_{n-i-1}^{k-i-1} - A_{n-i}^{k-i}\)&lt;/span&gt; 即可。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int mod = 998244353;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#endif
    int n, k;
    std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; k;
    std::vector&amp;lt;int&amp;gt; a(k + 1), p(n + 1, k + 1);
    for (int i = 1; i &amp;lt;= k; ++i)
        std::cin &amp;gt;&amp;gt; a[i], p[a[i]] = i;
    std::vector&amp;lt;long long&amp;gt; fac(n + 1), inv(n + 1);
    &amp;#123;
        fac[0] = inv[0] = 1ll;
        for (int i = 1; i &amp;lt;= n; ++i)
            fac[i] = fac[i - 1] * i % mod;
        auto qkp = [](long long x, int y) &amp;#123;
            auto res(1ll);
            for (; y; (x *= x) %= mod, y &amp;gt;&amp;gt;= 1)
                if (y &amp;amp; 1)
                    (res *= x) %= mod;
            return res;
        &amp;#125;;
        inv[n] = qkp(fac[n], mod - 2);
        for (int i = n - 1; i; --i)
            inv[i] = inv[i + 1] * (i + 1) % mod;
    &amp;#125;
    auto A = [&amp;amp;](int n, int m) &amp;#123;
        if (n &amp;lt; m || m &amp;lt; 0)
            return 0ll;
        return fac[n] * inv[n - m] % mod;
    &amp;#125;;
    std::vector&amp;lt;long long&amp;gt; f(k + 1), g(k + 1), h(k + 1);
    std::vector&amp;lt;long long&amp;gt; bit(n + 1);
    auto lowbit = [](int x) &amp;#123;
        return x &amp;amp; -x;
    &amp;#125;;
    auto add = [&amp;amp;](int x, int v) &amp;#123;
        for (; x &amp;lt;= n; x += lowbit(x))
            (bit[x] += v) %= mod;
        return;
    &amp;#125;;
    auto ask = [&amp;amp;](int x) &amp;#123;
        auto res(0ll);
        for (; x; x -= lowbit(x))
            (res += bit[x]) %= mod;
        return res;
    &amp;#125;;
    for (int i = 1; i &amp;lt;= n; ++i)
        if (p[i] == k + 1)
            add(i, 1);
    for (int i = k; i; --i)
        f[i] = ask(a[i]), add(a[i], 1);
    for (int i = 1; i &amp;lt;= k; ++i) &amp;#123;
        g[i] = (g[i - 1] + f[i] * A(n - i, k - i)) % mod;
        h[i] = (h[i - 1] + f[i] * (k - i) % mod * A(n - i - 1, k - i - 1)) % mod;
        // printf(&amp;quot;%d: f = %lld, g = %lld, h = %lld\n&amp;quot;, i, f[i], g[i], h[i]);
    &amp;#125;
    std::vector&amp;lt;long long&amp;gt; res(n + 1);
    bit.assign(n + 1, 0ll);
    auto s(0ll);
    for (int i = 1; i &amp;lt;= k; ++i) &amp;#123;
        // printf(&amp;quot;%d: %lld + %lld + %lld\n&amp;quot;, a[i], 1 + g[k] - g[i], h[i], s - ask(a[i]));
        res[a[i]] = (1 + g[k] - g[i] + h[i] + (s - ask(a[i]))) % mod;
        res[a[i]] = (res[a[i]] + mod) % mod;
        (s += A(n - i, k - i) - (k - i) * A(n - i - 1, k - i - 1)) %= mod;
        add(a[i], (A(n - i, k - i) - (k - i) * A(n - i - 1, k - i - 1)) % mod);
    &amp;#125;
    for (int i = 1; i &amp;lt;= n; ++i)
        if (p[i] == k + 1) &amp;#123;
            res[i] = (h[k] + (s - ask(i))) % mod;
            res[i] = (res[i] + mod) % mod;
        &amp;#125;
    for (int x = 1; x &amp;lt;= n; ++x)
        std::cout &amp;lt;&amp;lt; res[x] &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;c---1-loop-bubble-sort&#34;&gt;C - 1 Loop Bubble Sort&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/arc187/tasks/arc187_c&#34; class=&#34;uri&#34;&gt;https://atcoder.jp/contests/arc187/tasks/arc187_c&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;首先是被考烂了的：对序列进行一次冒泡排序，等价于将序列在前缀最大值处分段，并将其从段首移到段尾；且满足排序前为前缀最大值的元素，排序后仍为前缀最大值。&lt;/p&gt;
&lt;p&gt;考虑用 DP 解决问题。注意状态要从 &lt;span class=&#34;math inline&#34;&gt;\(P\)&lt;/span&gt; 的角度出发——假如 &lt;span class=&#34;math inline&#34;&gt;\(Q\)&lt;/span&gt; 中不存在 &lt;span class=&#34;math inline&#34;&gt;\(-1\)&lt;/span&gt;，发现也需要 DP。此时再设计有关 &lt;span class=&#34;math inline&#34;&gt;\(Q\)&lt;/span&gt; 的状态就很扯淡了，考虑令 &lt;span class=&#34;math inline&#34;&gt;\(f_{i,j}\)&lt;/span&gt; 表示 &lt;span class=&#34;math inline&#34;&gt;\(P\)&lt;/span&gt; 中直到第 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 位的前缀最大值为 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; 的方案数。为什么把前缀最大值作为状态呢？因为它可以表示分段；同时限制段间数的取值。具体地，考虑转移：&lt;/p&gt;
&lt;ol type=&#34;1&#34;&gt;
&lt;li&gt;若令 &lt;span class=&#34;math inline&#34;&gt;\(P_i=j\)&lt;/span&gt;，则在 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 处分段。对应到 &lt;span class=&#34;math inline&#34;&gt;\(Q\)&lt;/span&gt; 中，&lt;span class=&#34;math inline&#34;&gt;\(i-1\)&lt;/span&gt; 位是上一个前缀最大值，那么这要求 &lt;span class=&#34;math inline&#34;&gt;\(Q_{i-1}&amp;lt;j\)&lt;/span&gt;，且 &lt;span class=&#34;math inline&#34;&gt;\(Q_{i-1}\)&lt;/span&gt; 是一个前缀最大值。也即：当 &lt;span class=&#34;math inline&#34;&gt;\(Q_{i-1}\ne -1\)&lt;/span&gt; 时，&lt;span class=&#34;math inline&#34;&gt;\(f_{i,j}\gets f_{i-1, Q_{i-1}}\)&lt;/span&gt;；否则，&lt;span class=&#34;math inline&#34;&gt;\(f_{i,j}\gets \sum\limits_{k&amp;lt;j} f_{i-1,k}\)&lt;/span&gt;。其中，二式都要求转移来源为前缀最大值。&lt;/li&gt;
&lt;li&gt;若令 &lt;span class=&#34;math inline&#34;&gt;\(P_i&amp;lt;j\)&lt;/span&gt;，则 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 在 &lt;span class=&#34;math inline&#34;&gt;\(Q\)&lt;/span&gt; 中恰好前移一位，即 &lt;span class=&#34;math inline&#34;&gt;\(Q_{i-1}=P_i&amp;lt;j\)&lt;/span&gt;。则当 &lt;span class=&#34;math inline&#34;&gt;\(Q_{i-1}\ne -1\)&lt;/span&gt; 时，该位确定，&lt;span class=&#34;math inline&#34;&gt;\(f_{i,j}\gets f_{i-1,j}\)&lt;/span&gt;；否则，&lt;span class=&#34;math inline&#34;&gt;\(Q_{i-1}\)&lt;/span&gt; 可选的值为 &lt;span class=&#34;math inline&#34;&gt;\(&amp;lt;j\)&lt;/span&gt; 的所有未选数（定值，可预处理）。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;关于初值，可以在 &lt;span class=&#34;math inline&#34;&gt;\(P\)&lt;/span&gt; 前加一个 &lt;span class=&#34;math inline&#34;&gt;\(0\)&lt;/span&gt; 作为排列的一部分（那么按照冒泡排序的规则 &lt;span class=&#34;math inline&#34;&gt;\(Q\)&lt;/span&gt; 的第一位也一定是 &lt;span class=&#34;math inline&#34;&gt;\(0\)&lt;/span&gt;）来处理就好了。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int mod = 998244353;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#endif
    int n;
    std::cin &amp;gt;&amp;gt; n;
    std::vector&amp;lt;int&amp;gt; q(n + 1), t(n + 1), c(n + 1), pos(n + 1);
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        std::cin &amp;gt;&amp;gt; q[i], c[i] = c[i - 1];
        if (q[i] == -1)
            ++c[i];
        else
            pos[q[i]] = i;
    &amp;#125;
    for (int i = 1; i &amp;lt; n; ++i) &amp;#123;
        // printf(&amp;quot;t[%d] = %d\n&amp;quot;, i, t[i]);
        if (!pos[i])
            for (int j = i + 1; j &amp;lt;= n; ++j)
                ++t[j];
    &amp;#125;
    std::vector&amp;lt;std::vector&amp;lt;long long&amp;gt; &amp;gt; f(n + 1, std::vector&amp;lt;long long&amp;gt; (n + 1)), s(n + 1, std::vector&amp;lt;long long&amp;gt; (n + 1));
    f[0][0] = 1ll;
    s[0].assign(n + 1, 1ll);
    for (int i = 1; i &amp;lt;= n; ++i)
        for (int j = 1; j &amp;lt;= n; ++j) &amp;#123;
            if (q[i - 1] == -1)
                f[i][j] = (s[i - 1][j - 1] + f[i - 1][j] * std::max(0, 1 + t[j] - c[i - 1])) % mod;
            else if (q[i - 1] &amp;lt; j)
                f[i][j] = (f[i - 1][q[i - 1]] + f[i - 1][j]) % mod;
            s[i][j] = s[i][j - 1];
            if (q[i] == j || !pos[j]) // 满足前缀最大值
                (s[i][j] += f[i][j]) %= mod;
            // printf(&amp;quot;f[%d][%d] = %lld\n&amp;quot;, i, j, f[i][j]);
        &amp;#125;
    std::cout &amp;lt;&amp;lt; f[n][n] &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;f---1.-intro&#34;&gt;(F - 1). Intro&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;给定一个大小为 &lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt; 的树，点有点权。给定 &lt;span class=&#34;math inline&#34;&gt;\(q\)&lt;/span&gt; 次操作，分为两种：&lt;/p&gt;
&lt;ol type=&#34;1&#34;&gt;
&lt;li&gt;&lt;code&gt;1 x&lt;/code&gt;：查询 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 的点权。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;2 x d v&lt;/code&gt; 对于所有距 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 不超过 &lt;span class=&#34;math inline&#34;&gt;\(d\)&lt;/span&gt; 的点，将它们的权值加上 &lt;span class=&#34;math inline&#34;&gt;\(v\)&lt;/span&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(n,q\le 10^5,d\le 20\)&lt;/span&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;由于 &lt;span class=&#34;math inline&#34;&gt;\(d\)&lt;/span&gt; 很小，我们可能需要枚举与 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 距离 &lt;span class=&#34;math inline&#34;&gt;\(0\sim d\)&lt;/span&gt; 的点进行修改；那么对距离 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 为 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 的点的更改存储在 &lt;span class=&#34;math inline&#34;&gt;\(f_{x,i}\)&lt;/span&gt;，查询 &lt;span class=&#34;math inline&#34;&gt;\(v\)&lt;/span&gt; 时就可以从 &lt;span class=&#34;math inline&#34;&gt;\(\sum\limits_i f_{fa(v,i),i}\)&lt;/span&gt; 求得答案。&lt;/p&gt;
&lt;p&gt;考虑修改。记 &lt;span class=&#34;math inline&#34;&gt;\(S_{x,d}\)&lt;/span&gt; 为距 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 为 &lt;span class=&#34;math inline&#34;&gt;\(d\)&lt;/span&gt; 的点集。&lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 子树内是好处理的，但子树外的呢？发现 &lt;span class=&#34;math inline&#34;&gt;\(S_{fa,d-1}\)&lt;/span&gt; 中 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 子树外的点，就是 &lt;span class=&#34;math inline&#34;&gt;\(fa\)&lt;/span&gt; 子树下、&lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 子树外距离 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 为 &lt;span class=&#34;math inline&#34;&gt;\(d\)&lt;/span&gt; 的所有点。&lt;/p&gt;
&lt;p&gt;由于所有 &lt;span class=&#34;math inline&#34;&gt;\(S_{fa(x,i),d-i}\)&lt;/span&gt; 无交，这可能满足我们每个待操作点被不重不漏加一次的要求。考虑将所有 &lt;span class=&#34;math inline&#34;&gt;\(S_{fa(x,i),d-i}\)&lt;/span&gt; 标记出来：&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&#34;1.png&#34; alt=&#34;粉色虚线框是待操作点集&#34; /&gt;&lt;figcaption&gt;粉色虚线框是待操作点集&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;然后我们可以一眼发现被叉的点和未被叉的待操作点是交错的！这意味着我们只需要再补充上所有 &lt;span class=&#34;math inline&#34;&gt;\(S_{fa(x,i),d-i-1}\)&lt;/span&gt; 即可（显然它们之间、它们和所有 &lt;span class=&#34;math inline&#34;&gt;\(S_{fa(x,i),d-i}\)&lt;/span&gt; 之间都不交）。&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&#34;2.png&#34; alt=&#34;虚线叉为 S_{fa(x,i),d-i-1}&#34; /&gt;&lt;figcaption&gt;虚线叉为 &lt;span class=&#34;math inline&#34;&gt;\(S_{fa(x,i),d-i-1}\)&lt;/span&gt;&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;此时就可以不重不漏。当然，也会存在一些细节：比如说 &lt;span class=&#34;math inline&#34;&gt;\(fa(x,i)\)&lt;/span&gt; 不存在之类。只需要在根节点 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt; 处将剩余的 &lt;span class=&#34;math inline&#34;&gt;\(S_{1,i\to 0}\)&lt;/span&gt; 全部更新即可。&lt;/p&gt;
&lt;p&gt;故每次修改操作只需要修改 &lt;span class=&#34;math inline&#34;&gt;\(O(d)\)&lt;/span&gt; 坨点。时间复杂度 &lt;span class=&#34;math inline&#34;&gt;\(O(qd)\)&lt;/span&gt;。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;f.-distance-to-the-path&#34;&gt;F. Distance to the Path&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://codeforces.com/problemset/problem/1749/F&#34; class=&#34;uri&#34;&gt;https://codeforces.com/problemset/problem/1749/F&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本例中将单点修改替换为路径修改；考虑树剖解决问题。&lt;/p&gt;
&lt;p&gt;对于路径上的所有点 &lt;span class=&#34;math inline&#34;&gt;\(u\)&lt;/span&gt;，容易发现只需要修改所有的 &lt;span class=&#34;math inline&#34;&gt;\(S_{u,d}\)&lt;/span&gt; 就可以完成对『&lt;strong&gt;一部分路径内侧的点&lt;/strong&gt;』的修改。这『一部分』，是因为不包括距离 LCA &lt;span class=&#34;math inline&#34;&gt;\(\le d\)&lt;/span&gt; 的点。&lt;/p&gt;
&lt;p&gt;而『&lt;strong&gt;另一部分路径内侧的点&lt;/strong&gt;（距 LCA &lt;span class=&#34;math inline&#34;&gt;\(\le d\)&lt;/span&gt;：见上一行说明）』及『&lt;strong&gt;路径外侧的点&lt;/strong&gt;（距 LCA &lt;span class=&#34;math inline&#34;&gt;\(\le d\)&lt;/span&gt;：因为路径在 LCA 子树内，LCA 能够到最远的外侧点）』，等价于『&lt;strong&gt;距 LCA &lt;span class=&#34;math inline&#34;&gt;\(\le d\)&lt;/span&gt; 的点&lt;/strong&gt;』，只需要把 LCA 代入上例中方式修改即可。&lt;/p&gt;
&lt;p&gt;修改路径上所有点 &lt;span class=&#34;math inline&#34;&gt;\(u\)&lt;/span&gt; 的 &lt;span class=&#34;math inline&#34;&gt;\(S_{u,d}\)&lt;/span&gt; 时，可以对所有 &lt;span class=&#34;math inline&#34;&gt;\(f_{*,i}\)&lt;/span&gt; 建立数据结构，由于只需要区间修改、单点查询，使用差分树状数组即可。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt; 
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#endif
    int n, m;
    std::cin &amp;gt;&amp;gt; n;
    std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; g(n + 1);
    for (int i = 1, x, y; i &amp;lt; n; ++i) &amp;#123;
        std::cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; y;
        g[x].push_back(y), g[y].push_back(x);
    &amp;#125;
    std::vector&amp;lt;int&amp;gt; siz(n + 1), dep(n + 1), fa(n + 1), son(n + 1);
    std::function&amp;lt;void(int, int)&amp;gt; DFS = [&amp;amp;](int x, int faa) &amp;#123;
        siz[x] = 1;
        for (auto i : g[x])
            if (i != faa) &amp;#123;
                fa[i] = x, dep[i] = dep[x] + 1;
                DFS(i, x);
                siz[x] += siz[i];
                if (siz[i] &amp;gt; siz[son[x]])
                    son[x] = i;
            &amp;#125;
        return;
    &amp;#125;;
    DFS(1, -1);
    std::vector&amp;lt;int&amp;gt; dfn(n + 1), top(n + 1);
    DFS = [&amp;amp;](int x, int toop) &amp;#123;
        static int now = 0;
        dfn[x] = ++now, top[x] = toop;
        if (son[x])
            DFS(son[x], toop);
        for (auto i : g[x])
            if (i != fa[x] &amp;amp;&amp;amp; i != son[x])
                DFS(i, i);
        return;
    &amp;#125;;
    DFS(1, 1);
    std::vector&amp;lt;std::vector&amp;lt;long long&amp;gt; &amp;gt; bit(21, std::vector&amp;lt;long long&amp;gt; (n + 1));
    auto lowbit = [&amp;amp;](int x) &amp;#123;
        return x &amp;amp; -x;
    &amp;#125;;
    auto add = [&amp;amp;](auto &amp;amp;bit, int x, int v) &amp;#123;
        for (; x &amp;lt;= n; x += lowbit(x))
            bit[x] += v;
        return;
    &amp;#125;;
    auto ask = [&amp;amp;](auto &amp;amp;bit, int x) &amp;#123;
        auto res(0ll);
        for (; x; x -= lowbit(x))
            res += bit[x];
        return res;
    &amp;#125;;
    std::cin &amp;gt;&amp;gt; m;
    for (int op; m--; ) &amp;#123;
        std::cin &amp;gt;&amp;gt; op;
        if (op == 1) &amp;#123;
            int x;
            std::cin &amp;gt;&amp;gt; x;
            auto res(0ll);
            for (int i = 0; i &amp;lt;= 20 &amp;amp;&amp;amp; x; ++i, x = fa[x])
                res += ask(bit[i], dfn[x]);
            std::cout &amp;lt;&amp;lt; res &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
        &amp;#125;
        else &amp;#123;
            int x, y, v, d;
            std::cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; y &amp;gt;&amp;gt; v &amp;gt;&amp;gt; d;
            for (; top[x] != top[y]; x = fa[top[x]]) &amp;#123;
                if (dep[top[x]] &amp;lt; dep[top[y]])
                    std::swap(x, y);
                add(bit[d], dfn[top[x]], v);
                add(bit[d], dfn[x] + 1, -v);
            &amp;#125;
            if (dep[x] &amp;gt; dep[y])
                std::swap(x, y);
            add(bit[d], dfn[x] + 1, v), add(bit[d], dfn[y] + 1, -v);
            for (x = x, y = d; ~y &amp;amp;&amp;amp; x; x = fa[x], --y) &amp;#123;
                add(bit[y], dfn[x], v), add(bit[y], dfn[x] + 1, -v);
                if (y &amp;amp;&amp;amp; fa[x])
                    add(bit[y - 1], dfn[x], v), add(bit[y - 1], dfn[x] + 1, -v);
            &amp;#125;
            if (x == 0)
                for (; ~y; --y)
                    add(bit[y], dfn[1], v), add(bit[y], dfn[1] + 1, -v);
        &amp;#125;
    &amp;#125;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;a---ina-of-the-mountain&#34;&gt;A - Ina of the Mountain&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://codeforces.com/problemset/problem/1852/C&#34; class=&#34;uri&#34;&gt;https://codeforces.com/problemset/problem/1852/C&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;考虑这么一个简化版的问题：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定 &lt;span class=&#34;math inline&#34;&gt;\(\{a_n\}\)&lt;/span&gt;，每次可以进行区间 &lt;span class=&#34;math inline&#34;&gt;\(-1\)&lt;/span&gt;，问操作多少次才能将所有元素变为 &lt;span class=&#34;math inline&#34;&gt;\(0\)&lt;/span&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;会想到差分；对原数组进行差分，一次操作相当于令 &lt;span class=&#34;math inline&#34;&gt;\(d_l\gets d_l-1\)&lt;/span&gt; 而 &lt;span class=&#34;math inline&#34;&gt;\(d_{r+1}\gets d_{r+1}+1\)&lt;/span&gt;，最后要让 &lt;span class=&#34;math inline&#34;&gt;\(\forall \,d_i=0\)&lt;/span&gt;。那么答案就是差分数组中正数之和嘛。&lt;/p&gt;
&lt;p&gt;回到原问题。原问题等价于把上述问题变为：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定 &lt;span class=&#34;math inline&#34;&gt;\(\{a_n\}\)&lt;/span&gt;，每次可以进行区间 &lt;span class=&#34;math inline&#34;&gt;\(-1\)&lt;/span&gt;，每个数的总操作次数对 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 取模，问操作多少次才能将所有元素变为 &lt;span class=&#34;math inline&#34;&gt;\(0\)&lt;/span&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;怎么套回到刚刚的问题上呢？还原被取模掉的操作即可。具体来说，提前在 &lt;span class=&#34;math inline&#34;&gt;\(d\)&lt;/span&gt; 上进行若干次操作（记为操作 1），形如令 &lt;span class=&#34;math inline&#34;&gt;\(d_i\gets d_i+k\)&lt;/span&gt;，同时 &lt;span class=&#34;math inline&#34;&gt;\(d_{i+1}\gets d_{i+1}-k\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;会发现相邻的操作 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt; 对一个数加加减减影响判断；发现可以合并一段连续的操作 1，表现在 &lt;span class=&#34;math inline&#34;&gt;\(a\)&lt;/span&gt; 上也就是区间 &lt;span class=&#34;math inline&#34;&gt;\(+k\)&lt;/span&gt;。此时可以发现，一个位置上只会剩下若干次 &lt;span class=&#34;math inline&#34;&gt;\(+k\)&lt;/span&gt; 或若干次 &lt;span class=&#34;math inline&#34;&gt;\(-k\)&lt;/span&gt; （否则可以把 &lt;span class=&#34;math inline&#34;&gt;\(+k\)&lt;/span&gt; 和 &lt;span class=&#34;math inline&#34;&gt;\(-k\)&lt;/span&gt; 代表的不同操作合并），就不会有互相影响一说了。这也是有的题解说可以提前在 &lt;span class=&#34;math inline&#34;&gt;\(a\)&lt;/span&gt; 上区间 &lt;span class=&#34;math inline&#34;&gt;\(+k\)&lt;/span&gt; 的原因。&lt;/p&gt;
&lt;p&gt;此时问题变为在 &lt;span class=&#34;math inline&#34;&gt;\(d\)&lt;/span&gt; 进行任意次前加 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 后减 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 的操作，使得 &lt;span class=&#34;math inline&#34;&gt;\(\sum\limits_{d_i&amp;gt;0}d_i\)&lt;/span&gt; 最大化。那么显然如果要使代价更小，只可能在原本 &lt;span class=&#34;math inline&#34;&gt;\(&amp;lt;0\)&lt;/span&gt; 的位置做加法、&lt;span class=&#34;math inline&#34;&gt;\(&amp;gt;0\)&lt;/span&gt; 的位置做减法（其他情况会发现一定不优）。考虑两个数 &lt;span class=&#34;math inline&#34;&gt;\(d_l,d_r\)&lt;/span&gt;，可以感受到对于一个 &lt;span class=&#34;math inline&#34;&gt;\(r\)&lt;/span&gt;，选最小的 &lt;span class=&#34;math inline&#34;&gt;\(d_l\)&lt;/span&gt; 是最优的，但什么时候应该选呢？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class=&#34;math inline&#34;&gt;\(d_l\le -k,d_r\ge k\)&lt;/span&gt;：当然可选，&lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 被完全利用，答案减少 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(d_l&amp;gt;-k,d_r\ge k\)&lt;/span&gt;：此时 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 未被完全利用，但必须选：选择其他更大的数，&lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 的利用率只会更低；如果不选，答案也无法减少。&lt;/p&gt;
&lt;p&gt;Q：此时是否需要尝试找到一个 &lt;span class=&#34;math inline&#34;&gt;\(l&amp;#39;&amp;lt;l\)&lt;/span&gt; 与 &lt;span class=&#34;math inline&#34;&gt;\(l\)&lt;/span&gt; 做操作，使得 &lt;span class=&#34;math inline&#34;&gt;\(l\)&lt;/span&gt; 重新变为负数呢？&lt;/p&gt;
A：否。因为你可以将这两次操作合并，发现相当于是直接对 &lt;span class=&#34;math inline&#34;&gt;\((l&amp;#39;,r)\)&lt;/span&gt; 做操作，是更劣的。&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;math inline&#34;&gt;\(d_l\le -k,d_r&amp;lt;k\)&lt;/span&gt;：此时 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 未被完全利用，&lt;span class=&#34;math inline&#34;&gt;\(d_r\)&lt;/span&gt; 成为负数。这意味着 &lt;span class=&#34;math inline&#34;&gt;\(d_r\)&lt;/span&gt; 将会成为某个 &lt;span class=&#34;math inline&#34;&gt;\(r&amp;#39;\)&lt;/span&gt; 的可选项。考察 &lt;span class=&#34;math inline&#34;&gt;\(d_{r&amp;#39;}\)&lt;/span&gt; 可用的最小值。如果 &lt;span class=&#34;math inline&#34;&gt;\(d_r\)&lt;/span&gt; 在当前不应该作为右端点，它就一定会被 &lt;span class=&#34;math inline&#34;&gt;\(d_{r&amp;#39;}\)&lt;/span&gt; 选择。具体的有点抽象，但是你可以理解为 &lt;span class=&#34;math inline&#34;&gt;\(d_r\)&lt;/span&gt; 选了 &lt;span class=&#34;math inline&#34;&gt;\(d_l\)&lt;/span&gt; 的贡献是被整合到 &lt;span class=&#34;math inline&#34;&gt;\(d_r\)&lt;/span&gt; 里的；如果 &lt;span class=&#34;math inline&#34;&gt;\(d_r\)&lt;/span&gt; 被选了就说明 &lt;span class=&#34;math inline&#34;&gt;\(d_{r&amp;#39;}\)&lt;/span&gt; 选 &lt;span class=&#34;math inline&#34;&gt;\(d_l\)&lt;/span&gt; 会拥有更大的优势。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(d_l&amp;gt;-k,d_r&amp;lt;k\)&lt;/span&gt;：和上面的情况相似；但这种情况下答案可能反而变得更大，因为没有后效性，所以至少要保证单步最优。此时不能选。&lt;/p&gt;
&lt;p&gt;说到单步最优，就会发现这里就是反悔贪心；单步最优一定是全局最优，但更靠前的局部最优可能被否定掉。而『否定』的方法表现为一次操作。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;综上，从前往后扫，优先队列实时维护负数最小值，对于每个正数，check 选最小值是否优于当前答案，有就选。如果正数被减为负，加入队列。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#endif
    int T;
    for (std::cin &amp;gt;&amp;gt; T; T--; ) &amp;#123;
        int n, k;
        std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; k;
        std::vector&amp;lt;int&amp;gt; a(n + 1), d(n + 1);
        long long res(0ll);
        for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
            std::cin &amp;gt;&amp;gt; a[i], a[i] %= k;
            d[i] = a[i] - a[i - 1];
            if (d[i] &amp;gt; 0)
                (res += d[i]);
        &amp;#125;
        std::priority_queue&amp;lt;int&amp;gt; q;
        for (int i = 1; i &amp;lt;= n; ++i)
            if (d[i] &amp;lt; 0)
                q.push(-d[i]);
            else &amp;#123;
                for (; !q.empty() &amp;amp;&amp;amp; d[i] &amp;gt; 0; ) &amp;#123;
                    int x = -q.top(), y = d[i];
                    auto t(res - y);
                    x += k, y -= k;
                    if (x &amp;gt; 0)
                        t += x;
                    if (y &amp;gt; 0)
                        t += y;
                    if (t &amp;gt;= res)
                        break;
                    q.pop();
                    res = t, d[i] = y;
                    if (d[i] &amp;lt; 0)
                        q.push(-d[i]);
                &amp;#125;
            &amp;#125;
        std::cout &amp;lt;&amp;lt; res &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    &amp;#125;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;b---miriany-and-matchstick&#34;&gt;B - Miriany and Matchstick&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://codeforces.com/problemset/problem/1852/D&#34; class=&#34;uri&#34;&gt;https://codeforces.com/problemset/problem/1852/D&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;从构造的角度出发，看到『恰好为 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt;』，会想到找到上界和下界并证明中间每一个数都能取到。&lt;/p&gt;
&lt;p&gt;但似乎很容易证伪：例如对于 &lt;code&gt;AAAA&lt;/code&gt;，下界为 &lt;span class=&#34;math inline&#34;&gt;\(0\)&lt;/span&gt;，上界为 &lt;span class=&#34;math inline&#34;&gt;\(4\)&lt;/span&gt;，但有且仅有 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt; 取不到。但该想法并未破产——可以感受到这样的位置很少。进一步地，你 &lt;a href=&#34;https://www.luogu.com.cn/article/2mmg5rjd&#34;&gt;可以证明只有一个这样的位置&lt;/a&gt;，也可以 &lt;a href=&#34;https://www.luogu.com.cn/article/679cwjgl&#34;&gt;大胆猜想这样的位置一定出现在 &lt;span class=&#34;math inline&#34;&gt;\(l+1\)&lt;/span&gt;，&lt;span class=&#34;math inline&#34;&gt;\(r-1\)&lt;/span&gt;&lt;/a&gt;。总之现在我们的状态就减少了（或者说状态变成 DP 值了）。预处理出这个东西之后大力搜索找方案即可。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#endif
    int T;
    for (std::cin &amp;gt;&amp;gt; T; T--; ) &amp;#123;
        int n, k;
        std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; k;
        std::vector&amp;lt;int&amp;gt; a(n + 1);
        for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
            char t;
            std::cin &amp;gt;&amp;gt; t, a[i] = (t == &amp;#39;A&amp;#39;);
            if (i &amp;gt;= 2)
                k -= (a[i] ^ a[i - 1]);
        &amp;#125;
        std::vector&amp;lt;std::array&amp;lt;std::tuple&amp;lt;int, int, int&amp;gt;, 2&amp;gt; &amp;gt; f(n + 1);
        f[n][0] = &amp;#123; a[n], a[n], 0 &amp;#125;, f[n][1] = &amp;#123; !a[n], !a[n], 0 &amp;#125;;
        auto merge = [&amp;amp;](int i, int l0, int r0, int p0, int l1, int r1, int p1) &amp;#123;
            if (l0 &amp;gt; l1)
                std::swap(l0, l1), std::swap(r0, r1), std::swap(p0, p1);
            int l = l0, r = std::max(r0, r1), p = 0;
            if (!p0 &amp;amp;&amp;amp; !p1) &amp;#123;
                if (r0 &amp;lt; l1 - 1)
                    assert(r0 == l1 - 2), p = r0 + 1;
                else;
            &amp;#125;
            else if (p0 &amp;amp;&amp;amp; p1) &amp;#123;
                if (p0 == p1)
                    p = p0;
                else &amp;#123;
                    int tag0 = (l1 &amp;lt;= p0 &amp;amp;&amp;amp; p0 &amp;lt;= r1), tag1 = (l0 &amp;lt;= p1 &amp;amp;&amp;amp; p1 &amp;lt;= r0);
                    if (!tag0 &amp;amp;&amp;amp; !tag1);
                    else if (!tag0)
                        p = p0;
                    else if (!tag1)
                        p = p1;
                    else;
                &amp;#125;
            &amp;#125;
            else if (p0) &amp;#123;
                if (l1 &amp;lt;= p0 &amp;amp;&amp;amp; p0 &amp;lt;= r1);
                else
                    p = p0;
            &amp;#125;
            else &amp;#123;
                if (l0 &amp;lt;= p1 &amp;amp;&amp;amp; p1 &amp;lt;= r0);
                else
                    p = p1;
            &amp;#125;
            assert(p != l &amp;amp;&amp;amp; p != r &amp;amp;&amp;amp; l &amp;lt;= r);
            return std::make_tuple(l, r, p);
        &amp;#125;;
        for (int i = n - 1; i; --i) &amp;#123;
            &amp;#123;
                auto [l0, r0, p0] = f[i + 1][0];
                auto [l1, r1, p1] = f[i + 1][1];
                if (a[i]) &amp;#123;
                    ++l0, ++r0, ++l1, ++r1;
                    if (p0) ++p0;
                    if (p1) ++p1;
                &amp;#125;
                ++l1, ++r1;
                if (p1) ++p1;
                f[i][0] = merge(i, l0, r0, p0, l1, r1, p1);
            &amp;#125;
            &amp;#123;
                auto [l0, r0, p0] = f[i + 1][0];
                auto [l1, r1, p1] = f[i + 1][1];
                if (!a[i]) &amp;#123;
                    ++l0, ++r0, ++l1, ++r1;
                    if (p0) ++p0;
                    if (p1) ++p1;
                &amp;#125;
                ++l0, ++r0;
                if (p0) ++p0;
                f[i][1] = merge(i, l0, r0, p0, l1, r1, p1);
            &amp;#125;
        &amp;#125;
        std::vector&amp;lt;int&amp;gt; res(n + 1);
        std::function&amp;lt;bool(int, int, int)&amp;gt; DFS = [&amp;amp;](int x, int cnt, int la) &amp;#123;
            if (x == n + 1)
                return cnt == k;
            auto [l0, r0, p0] = f[x][0];
            auto [l1, r1, p1] = f[x][1];
            if (cnt + (la == 1) + l0 &amp;lt;= k &amp;amp;&amp;amp; cnt + (la == 1) + r0 &amp;gt;= k &amp;amp;&amp;amp; (!p0 || cnt + (la == 1) + p0 != k) &amp;amp;&amp;amp; DFS(x + 1, cnt + (la == 1) + a[x], 0))
                res[x] = 0;
            else if (cnt + !la + l1 &amp;lt;= k &amp;amp;&amp;amp; cnt + !la + r1 &amp;gt;= k &amp;amp;&amp;amp; (!p1 || cnt + !la + p1 != k) &amp;amp;&amp;amp; DFS(x + 1, cnt + !la + !a[x], 1))
                res[x] = 1;
            else
                return false;
            return true;
        &amp;#125;;
        if (DFS(1, 0, -1)) &amp;#123;
            std::cout &amp;lt;&amp;lt; &amp;quot;YES\n&amp;quot;;
            for (int i = 1; i &amp;lt;= n; ++i)
                std::cout &amp;lt;&amp;lt; (res[i] ? &amp;#39;A&amp;#39; : &amp;#39;B&amp;#39;);
            std::cout &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
        &amp;#125;
        else
            std::cout &amp;lt;&amp;lt; &amp;quot;NO\n&amp;quot;;
    &amp;#125;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
 ]]></description>
        </item>
    </channel>
</rss>
