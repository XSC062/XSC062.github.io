<?xml version="1.0"?>
<rss version="2.0">
    <channel>
        <title> • Posts by &#34;上下界网络流&#34; tag</title>
        <link>https://xsc062.netlify.app</link>
        <description></description>
        <language>zh-CN</language>
        <pubDate>Sat, 29 Jul 2023 15:38:36 +0800</pubDate>
        <lastBuildDate>Sat, 29 Jul 2023 15:38:36 +0800</lastBuildDate>
        <category>并查集</category>
        <category>斜率优化</category>
        <category>悬线法</category>
        <category>哈希</category>
        <category>字典树</category>
        <category>DP</category>
        <category>单调队列</category>
        <category>分治</category>
        <category>二分图</category>
        <category>CRT / exCRT</category>
        <category>排列组合</category>
        <category>网络流</category>
        <category>费用流</category>
        <category>二分</category>
        <category>上下界网络流</category>
        <category>容斥原理</category>
        <category>线段树</category>
        <category>树状数组</category>
        <category>区间 DP</category>
        <category>构造</category>
        <category>数据结构</category>
        <category>Tarjan</category>
        <category>下饭</category>
        <category>LCA</category>
        <category>倍增</category>
        <category>鸽巢原理</category>
        <category>概率期望</category>
        <category>调和级数</category>
        <category>差分</category>
        <category>思维</category>
        <category>树形 DP</category>
        <category>最小生成树</category>
        <category>SAM</category>
        <category>状压</category>
        <category>分块</category>
        <category>可持久化</category>
        <category>笛卡尔树</category>
        <category>高维前缀和</category>
        <category>闲话</category>
        <category>欧拉回路</category>
        <category>树链剖分</category>
        <category>长链剖分</category>
        <category>KMP</category>
        <category>border</category>
        <category>字符串</category>
        <category>AC 自动机</category>
        <category>SA</category>
        <category>数学</category>
        <category>树上差分</category>
        <category>FWT</category>
        <category>堆</category>
        <category>树的重心</category>
        <category>二项式定理</category>
        <category>二项式反演</category>
        <category>贪心</category>
        <category>均摊</category>
        <category>计数</category>
        <category>优化建图</category>
        <category>反悔贪心</category>
        <category>调整法</category>
        <category>背包</category>
        <category>博弈论</category>
        <category>DP 优化</category>
        <category>虚树</category>
        <category>点分治</category>
        <category>WQS 二分</category>
        <category>闵可夫斯基和</category>
        <category>slope trick</category>
        <category>四边形不等式</category>
        <category>状压 DP</category>
        <category>组合数学</category>
        <category>支配对</category>
        <category>DDP</category>
        <category>容斥</category>
        <category>Kruskal 重构树</category>
        <category>高精度</category>
        <category>最短路</category>
        <category>李超线段树</category>
        <item>
            <guid isPermalink="true">https://xsc062.netlify.app/20230729/</guid>
            <title>矩阵</title>
            <link>https://xsc062.netlify.app/20230729/</link>
            <category>网络流</category>
            <category>二分</category>
            <category>上下界网络流</category>
            <pubDate>Sat, 29 Jul 2023 15:38:36 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;Solution to &lt;a href=&#34;http://222.180.160.110:61235/contest/3825/problem/7&#34;&gt;BZOJ2406 矩阵&lt;/a&gt;。&lt;/p&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;
&lt;hr /&gt;
&lt;blockquote&gt;
&lt;p&gt;赛时公告&lt;/p&gt;
&lt;p&gt;现在呢？：现在有弹窗了吗 「2023-07-19 16:45:07」&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;此时无声胜有声。&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;f.bzoj2406矩阵&#34;&gt;F.「BZOJ2406」矩阵&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;http://222.180.160.110:61235/contest/3825/problem/7&#34; class=&#34;uri&#34;&gt;http://222.180.160.110:61235/contest/3825/problem/7&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这是头一次见识到把矩阵和网络流结合在一起的题目。不过这种处理方式也是我们在学习二分图时的常客了：把行和列连边表示某一元素。&lt;/p&gt;
&lt;p&gt;我们发现 &lt;span class=&#34;math inline&#34;&gt;\(B_{i, j}\)&lt;/span&gt; 有给定的上下界，故我们考虑 &lt;strong&gt;上下界网络流&lt;/strong&gt;。那怎么去表示 &lt;span class=&#34;math inline&#34;&gt;\(B_{i, j}\)&lt;/span&gt; 呢？这就要联系到我们刚刚说过的连边方式：用边 &lt;span class=&#34;math inline&#34;&gt;\(i\to j\)&lt;/span&gt; 的流量来表示 &lt;span class=&#34;math inline&#34;&gt;\(B_{i, j}\)&lt;/span&gt;，有 &lt;span class=&#34;math inline&#34;&gt;\([L, R]\)&lt;/span&gt; 的上下界。&lt;/p&gt;
&lt;p&gt;可是我们除了 &lt;span class=&#34;math inline&#34;&gt;\([L,R]\)&lt;/span&gt; 的限制，还有最大值这个条件呀，怎么办呢？&lt;/p&gt;
&lt;p&gt;注意到题目要求最大的最小，自然想到二分答案。设答案为 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt;，则我们需要保证每行每列的答案都 &lt;span class=&#34;math inline&#34;&gt;\(\le x\)&lt;/span&gt;。每行每列，这刚好是我们的建点方式。这对点本身作出了要求，这套路我们熟，让大源点向行连边、列向大汇点连边就好。&lt;/p&gt;
&lt;p&gt;那么这些边的上下界怎么办呢？我们已知 &lt;span class=&#34;math inline&#34;&gt;\(|S_A-S_B|\le x\)&lt;/span&gt;，那么变形得：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
\begin{cases}
S_B\ge S_A-x &amp;amp;(S_B \le S_A) \\
S_B\le S_A+x &amp;amp;(S_B \ge S_A)
\end{cases}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;照理来说，两行的符号相反，我们现在已经得到了一个具有对称美的上下界：&lt;span class=&#34;math inline&#34;&gt;\(S_A-x\le S_B\le S_A+x\)&lt;/span&gt;，就应该速速连边了，可是我怎么看都觉得不舒坦：这个不等式可是带条件的，就这么直接拿来做上下界真的没问题吗？&lt;/p&gt;
&lt;p&gt;&lt;del&gt;答案是没问题，因为我看的题解是这么写的&lt;/del&gt; 本着探索求真精神，我们考虑尊重原不等式（因为原不等式的每一行刚好也有两个相反的符号），将这些边拆成两条，一条的上下界是 &lt;span class=&#34;math inline&#34;&gt;\([S_A-x, S_A]\)&lt;/span&gt;，另一条是 &lt;span class=&#34;math inline&#34;&gt;\([S_A,S_A+x]\)&lt;/span&gt;。6。我明白题解为什么这么写了，一个的下界就是另一个的上界，那直接合并不就行了，这个 naive trick 题解都不屑于写出来。&lt;/p&gt;
&lt;p&gt;然后跑个可行流就可以了。注意要保证边的下界为非负。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#define int long long
namespace XSC062 &amp;#123;
using namespace fastIO;
const int lim = 2e5;
const int maxn = 405;
const int inf = 1e18;
const int maxm = 3e5 + 5;
struct _ &amp;#123;
    int v, w, n;
    _() &amp;#123;&amp;#125;
    _(int v1, int w1, int n1) &amp;#123;
        v = v1, w = w1, n = n1;
    &amp;#125;
&amp;#125;;
_ u[maxm];
int gs, gt, tot;
int a[maxn][maxn];
int l, mid, r, res;
int h[maxn], dif[maxn];
int n, m, cnt, s, t, L, R;
int vis[maxn], now[maxn], dep[maxn];
int max(int x, int y) &amp;#123; return x &amp;gt; y ? x : y; &amp;#125;
int min(int x, int y) &amp;#123; return x &amp;lt; y ? x : y; &amp;#125;
bool BFS(int n) &amp;#123;
    std::fill(vis + 1, vis + n + 1, 0);
    std::fill(dep + 1, dep + n + 1, 0); 
    std::queue&amp;lt;int&amp;gt; q;
    dep[gs] = 1, vis[gs] = 1;
    q.push(gs), now[gs] = h[gs];
    while (!q.empty()) &amp;#123;
        int f = q.front(); q.pop();
        for (int i = h[f]; i; i = u[i].n) &amp;#123;
            int v = u[i].v, w = u[i].w;
            if (vis[v] == 1 || w == 0) continue;
            vis[v] = 1, now[v] = h[v];
            dep[v] = dep[f] + 1, q.push(v);
            if (v == gt) return 1;
        &amp;#125;
    &amp;#125;
    return 0;
&amp;#125;
int findP(int x, int flow = inf) &amp;#123;
    if (x == gt) return flow;
    int rest = flow, i;
    for (i = now[x]; rest &amp;amp;&amp;amp; i; i = u[i].n) &amp;#123;
        now[x] = i;
        int v = u[i].v, w = u[i].w;
        if (dep[v] != dep[x] + 1 || w == 0) continue;
        int t = findP(v, min(rest, w));
        if (t == 0) dep[v] = 0;
        rest -= t, u[i].w -= t, u[i ^ 1].w += t;
    &amp;#125;
    return flow - rest;
&amp;#125;
int Dinic(int n) &amp;#123;
    int res = 0;
    while (BFS(n)) &amp;#123;
        int t = findP(gs);
        while (t) res += t, t = findP(gs);
    &amp;#125;
    return res;
&amp;#125;
void add(int x, int y, int w) &amp;#123;
    u[++tot] = _(y, w, h[x]), h[x] = tot;
    return;
&amp;#125;
void add(int x, int y, int d, int u) &amp;#123;
    add(x, y, u - d), add(y, x, 0);
    dif[x] -= d, dif[y] += d;
    return;
&amp;#125;
void Init(void) &amp;#123;
    tot = 1, cnt = 0;
    memset(h, 0, sizeof (h));
    memset(dif, 0, sizeof (dif));
    return;
&amp;#125;
bool check(int x) &amp;#123;
    Init();
    s = n + m + 1, t = s + 1;
    add(t, s, inf), add(s, t, 0);
    gs = t + 1, gt = t + 2;
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        for (int j = 1; j &amp;lt;= m; ++j)
            add(i, j + n, L, R);
    &amp;#125;
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        int sum = 0;
        for (int j = 1; j &amp;lt;= m; ++j)
            sum += a[i][j];
        add(s, i, max(0, sum - x), sum + x);
    &amp;#125;
    for (int j = 1; j &amp;lt;= m; ++j) &amp;#123;
        int sum = 0;
        for (int i = 1; i &amp;lt;= n; ++i)
            sum += a[i][j];
        add(j + n, t, max(sum - x, 0), sum + x);
    &amp;#125;
    for (int i = 1; i &amp;lt;= t; ++i) &amp;#123;
        if (dif[i] &amp;lt; 0)
            add(i, gt, -dif[i]), add(gt, i, 0);
        else if (dif[i] &amp;gt; 0) &amp;#123;
            add(gs, i, dif[i]);
            add(i, gs, 0), cnt += dif[i];
        &amp;#125;
    &amp;#125;
    return (Dinic(gt) == cnt);
&amp;#125;
int main() &amp;#123;
    read(n), read(m);
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        for (int j = 1; j &amp;lt;= m; ++j)
            read(a[i][j]);
    &amp;#125;
    read(L), read(R);
    l = 0, r = lim, res = -1;
    while (l &amp;lt;= r) &amp;#123;
        mid = (l + r) &amp;gt;&amp;gt; 1;
        if (check(mid))
            res = mid, r = mid - 1;
        else l = mid + 1;
    &amp;#125;
    print(res);
    return 0;
&amp;#125;
&amp;#125; // namespace XSC062
#undef int&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;p&gt;你最好有要事相求.jpg&lt;/p&gt;
 ]]></description>
        </item>
    </channel>
</rss>
