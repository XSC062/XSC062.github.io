{
    "version": "https://jsonfeed.org/version/1",
    "title": "null • All posts by \"均摊\" tag",
    "description": "",
    "home_page_url": "https://xsc062.netlify.app",
    "items": [
        {
            "id": "https://xsc062.netlify.app/20250421/",
            "url": "https://xsc062.netlify.app/20250421/",
            "title": "杂题选谈",
            "date_published": "2025-04-21T06:42:31.000Z",
            "content_html": "<figure>\n<img src=\"/20250421/neko.png\" alt=\"猫\" style=\"width: 75px\">\n<figcaption>\n猫\n</figcaption>\n</figure>\n<span id=\"more\"></span>\n<hr />\n<h2 id=\"a---t-shirt\">A - T-shirt</h2>\n<p><a href=\"https://codeforces.com/problemset/problem/183/D\" class=\"uri\">https://codeforces.com/problemset/problem/183/D</a></p>\n<p>如果知道一个衣服序列，怎么算出期望呢？</p>\n<hr />\n<h2 id=\"b---two-melodies\">B - Two Melodies</h2>\n<p><a href=\"https://codeforces.com/problemset/problem/813/D\" class=\"uri\">https://codeforces.com/problemset/problem/813/D</a></p>\n<p>如果设 <span class=\"math inline\">\\(f_{i,j}\\)</span> 表示第一个以 <span class=\"math inline\">\\(i\\)</span> 结尾，第二个以 <span class=\"math inline\">\\(j\\)</span> 结尾的方案数，就会有一个弊端——假设现在有 <span class=\"math inline\">\\(i&gt;j\\)</span>，又假设有 <span class=\"math inline\">\\(j&lt;j&#39;&lt;i\\)</span>，那么就不可以直接把 <span class=\"math inline\">\\(f_{i,j}\\)</span> 转移到 <span class=\"math inline\">\\(f_{i,j&#39;}\\)</span>，因为 <span class=\"math inline\">\\(j&#39;\\)</span> 可能已经被第一个选过了。但如果从 <span class=\"math inline\">\\(i\\)</span> 转移就没有这样的问题（不管 <span class=\"math inline\">\\(i&#39;\\)</span> 是比 <span class=\"math inline\">\\(j\\)</span> 大还是比 <span class=\"math inline\">\\(j\\)</span> 小）。</p>\n<p>那就可以固定从较大的一维转移，也可以枚举所有情况。但是这样就会有一个问题，这是一个 <span class=\"math inline\">\\(n^3\\)</span> 的过程，而且对于不单调的内层 <span class=\"math inline\">\\(j\\)</span>，维护它的数值只能用带 <span class=\"math inline\">\\(\\log\\)</span> 的数据结构优化，似乎不太过得了；但 <span class=\"math inline\">\\(i\\)</span> 却可以前缀优化。</p>\n<p>其实，两个组是无序的，这意味着可以强制 <span class=\"math inline\">\\(i&gt;j\\)</span> 再从 <span class=\"math inline\">\\(i\\)</span> 转移；这个时候转移就和 <span class=\"math inline\">\\(j\\)</span> 没有太大的关系了，可以把 <span class=\"math inline\">\\(j\\)</span> 放到外层，对 <span class=\"math inline\">\\(i\\)</span> 前缀优化。可能需要注意边界的处理。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, res = 0;\n    std::cin &gt;&gt; n;\n    std::vector&lt;int&gt; a(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i];\n    std::vector&lt;std::vector&lt;int&gt; &gt; f(n + 1, std::vector&lt;int&gt; (n + 1));\n    for (int j = 0; j &lt; n; ++j) &#123;\n        std::vector&lt;int&gt; mx(100002), mmx(7);\n        for (int i = 1; i &lt; j; ++i) &#123;\n            mx[a[i]] = std::max(mx[a[i]], f[j][i]);\n            mmx[a[i] % 7] = std::max(mmx[a[i] % 7], f[j][i]);\n        &#125;\n        for (int i = j + 1; i &lt;= n; ++i) &#123;\n            f[i][j] = std::max(&#123; !!i + !!j, mx[a[i] - 1] + 1, mx[a[i] + 1] + 1, mmx[a[i] % 7] + 1, f[j][0] + 1 &#125;);\n            mx[a[i]] = std::max(mx[a[i]], f[i][j]);\n            mmx[a[i] % 7] = std::max(mmx[a[i] % 7], f[i][j]);\n            // printf(&quot;f[%d][%d] = %d\\n&quot;, i, j, f[i][j]);\n            res = std::max(res, f[i][j]);\n        &#125;\n    &#125;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"cf633f-the-chocolate-spree\">CF633F The Chocolate Spree</h2>\n<p><a href=\"https://codeforces.com/problemset/problem/633/F\" class=\"uri\">https://codeforces.com/problemset/problem/633/F</a></p>\n<p>树形 DP 求直径的时候，有一种方法是找到每个点下面的最大两条不交链。</p>\n<p>这里也可以有类似的求法。假设答案出现在子树 <span class=\"math inline\">\\(u\\)</span> 中（下面的 <span class=\"math inline\">\\(v_i\\)</span> 都是 <span class=\"math inline\">\\(u\\)</span> 的直接儿子），可以讨论 <span class=\"math inline\">\\(u\\)</span> 参与构成两条路径的情况：</p>\n<ol type=\"1\">\n<li>不参与构成任何一条路径，答案是 <span class=\"math inline\">\\(v_1,v_2\\)</span> 子树中的最长路径之和。</li>\n<li><p>参与构成其中一条：</p>\n<ol type=\"1\">\n<li>这一条与子树 <span class=\"math inline\">\\(v\\)</span> 完全相离，答案是 <span class=\"math inline\">\\(v\\)</span> 中最长路径，和 <span class=\"math inline\">\\(u\\)</span> 下面不经过 <span class=\"math inline\">\\(v\\)</span> 的最大两条不交链。</li>\n<li>这一条有一支来自 <span class=\"math inline\">\\(v\\)</span> 子树，但和 <span class=\"math inline\">\\(v\\)</span> 中最长路径没有重合的点。答案是 <span class=\"math inline\">\\(u\\)</span> 的点权、<span class=\"math inline\">\\(u\\)</span> 下面不经过 <span class=\"math inline\">\\(v\\)</span> 的最大链、<span class=\"math inline\">\\(v\\)</span> 中一条路径（不经过 <span class=\"math inline\">\\(v\\)</span>）和 <span class=\"math inline\">\\(v\\)</span> 下面一条链之和的最大值；</li>\n<li>这一条两支都来自 <span class=\"math inline\">\\(v\\)</span> 子树：有重合，不可能发生。</li>\n</ol></li>\n<li><p>参与构成其中两条，答案是 <span class=\"math inline\">\\(u\\)</span> 下面最长的四条链：路径重复经过 <span class=\"math inline\">\\(u\\)</span>，不可能发生。</p></li>\n</ol>\n<p><img src=\"2.png\" /></p>\n<p>可以记录 <span class=\"math inline\">\\(u\\)</span> 下方最大的四条不交链、<span class=\"math inline\">\\(u\\)</span> 中选取一条不经过 <span class=\"math inline\">\\(u\\)</span> 的路径和 <span class=\"math inline\">\\(u\\)</span> 下方一条链之和的最大值、<span class=\"math inline\">\\(u\\)</span> 中最长路径求解。</p>\n<details>\n<pre class=\"cpp language-cpp\" data-line=\"42-44\"><code class=\"cpp langauage-cpp\">#include &lt;bits/stdc++.h>\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(\".in\", \"r\", stdin);\n    std::freopen(\".out\", \"w\", stdout);\n#endif\n    int n;\n    std::cin >> n;\n    std::vector&lt;int> a(n + 1);\n    std::vector&lt;std::vector&lt;int> > g(n + 1);\n    for (int i = 1; i <= n; ++i)\n        std::cin >> a[i];\n    for (int i = 1, x, y; i < n; ++i) &#123;\n        std::cin >> x >> y;\n        g[x].push_back(y), g[y].push_back(x);\n    &#125;\n    auto res(0ll);\n    std::vector&lt;long long> s(n + 1), w(n + 1);\n    std::vector&lt;std::vector&lt;std::pair&lt;long long, int> > > f(n + 1, std::vector&lt;std::pair&lt;long long, int> > (4));\n    std::function&lt;void(int, int)> DFS = [&](int x, int fa) &#123;\n        f[x][0] = &#123; 0, x &#125;;\n        w[x] = s[x] = a[x];\n        for (auto i : g[x])\n            if (i != fa) &#123;\n                DFS(i, x);\n                &#123;\n                    if (f[i][0].first + a[i] > f[x][3].first)\n                        f[x][3].first = f[i][0].first + a[i], f[x][3].second = i;\n                    std::sort(f[x].begin(), f[x].end(), std::greater&lt;std::pair&lt;long long, int> > ());\n                &#125;\n                w[x] = std::max(w[x], w[i] + a[x]);\n            &#125;\n        auto mx(0ll);\n        for (auto i : g[x])\n            if (i != fa) &#123;\n                s[x] = std::max(&#123; s[x], s[i], f[x][0].first + f[x][1].first + a[x] &#125;);\n                w[x] = std::max(w[x], (f[x][0].second != i ? f[x][0] : f[x][1]).first + s[i] + a[x]);\n                res = std::max(&#123; res,\n                    mx + s[i], // 情况 1\n                    (f[x][0].second == i ? f[x][1].first + f[x][2].first : (f[x][1].second == i ? f[x][0].first + f[x][2].first : f[x][0].first + f[x][1].first)) + s[i] + a[x], // 情况 2.1\n                    (f[x][0].second == i ? f[x][1].first : f[x][0].first) + w[i] + a[x], // 情况 2.2\n                &#125;);\n                mx = std::max(mx, s[i]);\n            &#125;\n    //     printf(\"%d: res = %lld\\n  f: \\n\", a[x], res);\n    //     for (int i = 0; i < 4; ++i)\n    //         printf(\"    [%d] %lld\\n\", f[x][i].second, f[x][i].first);\n    //     printf(\"  s: %lld\\n  w: %lld\\n\", s[x], w[x]);\n    &#125;;\n    DFS(1, -1);\n    std::cout << res << '\\n';\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"c---巡逻\">C - 巡逻</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P3629\" class=\"uri\">https://www.luogu.com.cn/problem/P3629</a></p>\n<p>你可能需要注意：目的是遍历所有边而非所有点。</p>\n<p><span class=\"math inline\">\\(K=1\\)</span> 的时候，环上除了关键边的所有边经过次数会减 <span class=\"math inline\">\\(1\\)</span>。所以选树的直径就可以最优。</p>\n<p><span class=\"math inline\">\\(K=2\\)</span> 的时候，答案是 <span class=\"math inline\">\\(2\\times (m + 2)\\)</span> 减去两个边构成的环的 <em>并集减交集</em> 大小 <span class=\"math inline\">\\(L\\)</span>。环实际上是不存在的，<span class=\"math inline\">\\(L\\)</span> 其实是两条路径 <em>并集减交集</em> 再加上两条新边的值。</p>\n<p>两条路径有交的时候，可以等效成无交的情况：</p>\n<p><img src=\"1.png\" /></p>\n<p>就化归成上一个问题了。注意此时情况 3 可能发生；同时情况 2.2 可以选取经过 <span class=\"math inline\">\\(v\\)</span> 的路径。</p>\n<details>\n<pre class=\"cpp language-cpp\" data-line=\"55-56,64-67\"><code class=\"cpp langauage-cpp\">#include &lt;bits/stdc++.h>\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(\".in\", \"r\", stdin);\n    std::freopen(\".out\", \"w\", stdout);\n#endif\n    int n, k;\n    std::cin >> n >> k;\n    std::vector&lt;std::vector&lt;int> > g(n + 1);\n    for (int i = 1, x, y; i < n; ++i) &#123;\n        std::cin >> x >> y;\n        g[x].push_back(y), g[y].push_back(x);\n    &#125;\n    int res = 0;\n    if (k == 1) &#123;\n        std::vector&lt;std::vector&lt;std::pair&lt;int, int> > > f(n + 1, std::vector&lt;std::pair&lt;int, int> > (2));\n        std::function&lt;void(int, int)> DFS = [&](int x, int fa) &#123;\n            f[x][0] = &#123; 0, x &#125;;\n            for (auto i : g[x])\n                if (i != fa) &#123;\n                    DFS(i, x);\n                    &#123;\n                        if (f[i][0].first + 1 > f[x][1].first)\n                            f[x][1].first = f[i][0].first + 1, f[x][1].second = i;\n                        std::sort(f[x].begin(), f[x].end(), std::greater&lt;std::pair&lt;int, int> > ());\n                    &#125;\n                &#125;\n            res = std::max(res, f[x][0].first + f[x][1].first);\n        &#125;;\n        DFS(1, -1);\n        std::cout << 2 * n - res - 1 << '\\n';\n    &#125;\n    else &#123;\n        std::vector&lt;int> s(n + 1), w(n + 1);\n        std::vector&lt;std::vector&lt;std::pair&lt;int, int> > > f(n + 1, std::vector&lt;std::pair&lt;int, int> > (4));\n        std::function&lt;void(int, int)> DFS = [&](int x, int fa) &#123;\n            f[x][0] = &#123; 0, x &#125;;\n            for (auto i : g[x])\n                if (i != fa) &#123;\n                    DFS(i, x);\n                    &#123;\n                        if (f[i][0].first + 1 > f[x][3].first)\n                            f[x][3].first = f[i][0].first + 1, f[x][3].second = i;\n                        std::sort(f[x].begin(), f[x].end(), std::greater&lt;std::pair&lt;int, int> > ());\n                    &#125;\n                    w[x] = std::max(w[x], w[i] + 1);\n                &#125;\n            &#123;\n                int t = 0;\n                for (auto [v, id] : f[x])\n                    t += v;\n                res = std::max(res, t); // 情况 3\n                w[x] = std::max(w[x], t - f[x][3].first); // 路径可经过 u\n            &#125;\n            int mx = 0;\n            for (auto i : g[x])\n                if (i != fa) &#123;\n                    s[x] = std::max(&#123; s[x], s[i], f[x][0].first + f[x][1].first &#125;);\n                    w[x] = std::max(w[x], (f[x][0].second != i ? f[x][0] : f[x][1]).first + std::max(s[i], f[i][0].first + 1));\n                    res = std::max(&#123; res,\n                        mx + s[i], // 情况 1\n                        (f[x][0].second == i ? f[x][1].first + f[x][2].first : (f[x][1].second == i ? f[x][0].first + f[x][2].first : f[x][0].first + f[x][1].first)) + s[i], // 情况 2.1\n                        (f[x][0].second == i ? f[x][1].first : f[x][0].first) + w[i] + 1, // 情况 2.2\n                    &#125;);\n                    mx = std::max(mx, s[i]);\n                &#125;\n        &#125;;\n        DFS(1, -1);\n        std::cout << 2 * (n + 1) - res - 2 << '\\n';\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"d---瞬间传送-teleport\">D - 瞬间传送 / Teleport</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P11915\" class=\"uri\">https://www.luogu.com.cn/problem/P11915</a></p>\n<p>需要观察到一个很厉害的贪心策略：如果钦定所有点的距离不大于 <span class=\"math inline\">\\(r\\)</span>，且存在 <span class=\"math inline\">\\(d(i,j)&gt;r\\)</span>。<strong>假设</strong> 一种满足条件的新边是 <span class=\"math inline\">\\((u,v)\\)</span>（由于两者无序，不妨钦定 <span class=\"math inline\">\\(d(i,u)&lt;d(i,v)\\)</span>），可以进行讨论：</p>\n<ol type=\"1\">\n<li><p><span class=\"math inline\">\\(d(j,v)&lt;d(j,u)\\)</span>：</p>\n此时最优路径为 <span class=\"math inline\">\\(i\\to u\\to v\\to j\\)</span>，判断一下这种方案是否不大于 <span class=\"math inline\">\\(r\\)</span> 就可以了。</li>\n<li><p><span class=\"math inline\">\\(d(j,v)\\ge d(j, u)\\)</span>：</p>\n<p>此时不管是走 <span class=\"math inline\">\\(i\\to u\\to v\\to j\\)</span> 还是 <span class=\"math inline\">\\(i\\to v\\to u\\to j\\)</span> 都不如走已经存在的 <span class=\"math inline\">\\(i\\to u\\to j\\)</span> 这条路径，也就是说如果要走新边，代价是一定比原距离大，更是比 <span class=\"math inline\">\\(r\\)</span> 大的；也就是说，<span class=\"math inline\">\\((u,v)\\)</span> 不能解决 <span class=\"math inline\">\\((i,j)\\)</span> 之间的问题，假设就不成立了。</p></li>\n</ol>\n<p>综上，只需要判断 <span class=\"math inline\">\\(i\\to u\\to v\\to j\\le r\\)</span> 是否成立，就可以判断 <span class=\"math inline\">\\((u,v)\\)</span> 是否合法。从大到小枚举 <span class=\"math inline\">\\(r\\)</span>，同时维护当前依然合法的 <span class=\"math inline\">\\((u,v)\\)</span>（显然是有单调性的），对于不合法的 <span class=\"math inline\">\\((i,j)\\)</span>，枚举每个 <span class=\"math inline\">\\(i\\)</span>，维护 <span class=\"math inline\">\\(\\max\\{d(v,j)\\}\\)</span>，精细实现（主要是利用各种均摊）一下就能 <span class=\"math inline\">\\(O(n^3)\\)</span>。</p>\n<p>这里具体提一下需要摊的几个点：</p>\n<ol type=\"1\">\n<li>枚举到 <span class=\"math inline\">\\(r\\)</span> 的时候用所有 <span class=\"math inline\">\\(d(i,j)=r+1\\)</span> 把 <span class=\"math inline\">\\(v\\)</span> 在 <span class=\"math inline\">\\(i\\)</span> 处的最大 <span class=\"math inline\">\\(d(v,j)\\)</span> 更新，方便后面 <span class=\"math inline\">\\(O(n)\\)</span> 地 check。摊出来是 <span class=\"math inline\">\\(O(n^3)\\)</span> 的。</li>\n<li>枚举仍然处在合法队列里的 <span class=\"math inline\">\\((u,v)\\)</span>，如果 check 合法，就说明对于当前 <span class=\"math inline\">\\(r\\)</span> 至少存在一个合法解，就可以 <code>break</code> 了；否则，把 <span class=\"math inline\">\\((u,v)\\)</span> 弹出，继续 check 下一条边。这样每条边只会被弹出一次，而未弹出边的 check 次数最多是 <span class=\"math inline\">\\(O(n)\\)</span>；加上 <span class=\"math inline\">\\(O(n)\\)</span> 的 check，摊出来是 <span class=\"math inline\">\\(O(n^3)\\)</span> 的。</li>\n</ol>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int inf = 0x3f3f3f3f;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int T;\n    for (std::cin &gt;&gt; T; T--; ) &#123;\n        int n;\n        std::cin &gt;&gt; n;\n        std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1, std::vector&lt;int&gt; (n + 1, inf));\n        for (int i = 1; i &lt;= n; ++i)\n            for (int j = 1; j &lt;= n; ++j) &#123;\n                char t;\n                std::cin &gt;&gt; t;\n                if (t == &#39;1&#39; || i == j)\n                    g[i][j] = t - &#39;0&#39;;\n            &#125;\n        for (int k = 1; k &lt;= n; ++k)\n            for (int i = 1; i &lt;= n; ++i)\n                if (i != k)\n                    for (int j = 1; j &lt;= n; ++j)\n                        if (j != i &amp;&amp; j != k)\n                            g[i][j] = std::min(g[i][j], g[i][k] + g[k][j]);\n        std::queue&lt;std::pair&lt;int, int&gt; &gt; q;\n        std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; p(n + 1);\n        std::vector&lt;std::vector&lt;int&gt; &gt; mx(n + 1, std::vector&lt;int&gt; (n + 1));\n        for (int i = 1; i &lt; n; ++i)\n            for (int j = i + 1; j &lt;= n; ++j) &#123;\n                q.emplace(i, j);\n                p[g[i][j] - 1].emplace_back(i, j);\n            &#125;\n        auto check = [&amp;](int u, int v, int r) &#123;\n            for (int i = 1; i &lt;= n; ++i) &#123;\n                if (g[u][i] &gt; g[v][i])\n                    std::swap(u, v);\n                if (g[u][i] + mx[v][i] &gt; r)\n                    return false;\n            &#125;\n            return true;\n        &#125;;\n        for (int r = n; r &gt;= -1; --r) &#123;\n            for (auto [i, j] : p[r])\n                for (int v = 1; v &lt;= n; ++v) &#123;\n                    mx[v][i] = std::max(mx[v][i], g[v][j]);\n                    mx[v][j] = std::max(mx[v][j], g[v][i]);\n                &#125;\n            for (; !q.empty(); ) &#123;\n                auto [u, v] = q.front();\n                if (!check(u, v, r))\n                    q.pop();\n                else\n                    break;\n            &#125;\n            if (q.empty()) &#123;\n                std::cout &lt;&lt; r + 1 &lt;&lt; &#39;\\n&#39;;\n                break;\n            &#125;\n        &#125;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"e.-two-tanks\">E. Two Tanks</h2>\n<p><a href=\"https://codeforces.com/problemset/problem/1809/E\" class=\"uri\">https://codeforces.com/problemset/problem/1809/E</a></p>\n<p>果然还是不会简单 DP <img src=\"/em/ll.gif\" /></p>\n<p>可以观察到如果总水量相同，且某个时刻两种初始状态当前是相同状态，那么以后它们也会是相同状态。但光凭这个好像还是不太能做出来的样子 <img src=\"/em/kt.gif\" /></p>\n<p>这里大概算一个定式，对于类似这种两个元素总和不变的问题，可以把两个元素的容量画到数轴上，原点表示分界，当前水为一条定长线段，倒水就相当于左右平移这条线段：</p>\n<p><img src=\"3.png\" /></p>\n<p>需要意识到，<mark></mark></p>\n",
            "tags": [
                "DP",
                "贪心",
                "均摊"
            ]
        }
    ]
}