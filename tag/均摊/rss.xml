<?xml version="1.0"?>
<rss version="2.0">
    <channel>
        <title> • Posts by &#34;均摊&#34; tag</title>
        <link>https://xsc062.netlify.app</link>
        <description></description>
        <language>zh-CN</language>
        <pubDate>Mon, 21 Apr 2025 14:42:31 +0800</pubDate>
        <lastBuildDate>Mon, 21 Apr 2025 14:42:31 +0800</lastBuildDate>
        <category>悬线法</category>
        <category>斜率优化</category>
        <category>并查集</category>
        <category>哈希</category>
        <category>DP</category>
        <category>单调队列</category>
        <category>字典树</category>
        <category>二分图</category>
        <category>分治</category>
        <category>计数</category>
        <category>容斥</category>
        <category>CRT / exCRT</category>
        <category>排列组合</category>
        <category>网络流</category>
        <category>二分</category>
        <category>容斥原理</category>
        <category>线段树</category>
        <category>树状数组</category>
        <category>区间 DP</category>
        <category>数据结构</category>
        <category>构造</category>
        <category>Tarjan</category>
        <category>下饭</category>
        <category>李超线段树</category>
        <category>树链剖分</category>
        <category>LCA</category>
        <category>倍增</category>
        <category>鸽巢原理</category>
        <category>数学</category>
        <category>调和级数</category>
        <category>差分</category>
        <category>思维</category>
        <category>树形 DP</category>
        <category>最小生成树</category>
        <category>SAM</category>
        <category>状压</category>
        <category>分块</category>
        <category>可持久化</category>
        <category>笛卡尔树</category>
        <category>高维前缀和</category>
        <category>闲话</category>
        <category>欧拉回路</category>
        <category>长链剖分</category>
        <category>KMP</category>
        <category>border</category>
        <category>随机化</category>
        <category>字符串</category>
        <category>AC 自动机</category>
        <category>SA</category>
        <category>树上差分</category>
        <category>FWT</category>
        <category>堆</category>
        <category>树的重心</category>
        <category>贪心</category>
        <category>均摊</category>
        <category>反悔贪心</category>
        <category>优化建图</category>
        <category>调整法</category>
        <category>博弈论</category>
        <category>DP 优化</category>
        <category>虚树</category>
        <category>点分治</category>
        <category>四边形不等式</category>
        <category>背包</category>
        <category>支配对</category>
        <category>DDP</category>
        <category>CDQ 分治</category>
        <category>猫树</category>
        <category>DP 套 DP</category>
        <category>Kruskal 重构树</category>
        <category>高精度</category>
        <category>最短路</category>
        <category>树套树</category>
        <category>二项式反演</category>
        <category>搜索</category>
        <item>
            <guid isPermalink="true">https://xsc062.netlify.app/20250421/</guid>
            <title>杂题选谈</title>
            <link>https://xsc062.netlify.app/20250421/</link>
            <category>DP</category>
            <category>贪心</category>
            <category>均摊</category>
            <pubDate>Mon, 21 Apr 2025 14:42:31 +0800</pubDate>
            <description><![CDATA[ &lt;figure&gt;
&lt;img src=&#34;/20250421/neko.png&#34; alt=&#34;猫&#34; style=&#34;width: 75px&#34;&gt;
&lt;figcaption&gt;
猫
&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;a---t-shirt&#34;&gt;A - T-shirt&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://codeforces.com/problemset/problem/183/D&#34; class=&#34;uri&#34;&gt;https://codeforces.com/problemset/problem/183/D&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果知道一个衣服序列，怎么算出期望呢？&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;b---two-melodies&#34;&gt;B - Two Melodies&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://codeforces.com/problemset/problem/813/D&#34; class=&#34;uri&#34;&gt;https://codeforces.com/problemset/problem/813/D&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果设 &lt;span class=&#34;math inline&#34;&gt;\(f_{i,j}\)&lt;/span&gt; 表示第一个以 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 结尾，第二个以 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; 结尾的方案数，就会有一个弊端——假设现在有 &lt;span class=&#34;math inline&#34;&gt;\(i&amp;gt;j\)&lt;/span&gt;，又假设有 &lt;span class=&#34;math inline&#34;&gt;\(j&amp;lt;j&amp;#39;&amp;lt;i\)&lt;/span&gt;，那么就不可以直接把 &lt;span class=&#34;math inline&#34;&gt;\(f_{i,j}\)&lt;/span&gt; 转移到 &lt;span class=&#34;math inline&#34;&gt;\(f_{i,j&amp;#39;}\)&lt;/span&gt;，因为 &lt;span class=&#34;math inline&#34;&gt;\(j&amp;#39;\)&lt;/span&gt; 可能已经被第一个选过了。但如果从 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 转移就没有这样的问题（不管 &lt;span class=&#34;math inline&#34;&gt;\(i&amp;#39;\)&lt;/span&gt; 是比 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; 大还是比 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; 小）。&lt;/p&gt;
&lt;p&gt;那就可以固定从较大的一维转移，也可以枚举所有情况。但是这样就会有一个问题，这是一个 &lt;span class=&#34;math inline&#34;&gt;\(n^3\)&lt;/span&gt; 的过程，而且对于不单调的内层 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt;，维护它的数值只能用带 &lt;span class=&#34;math inline&#34;&gt;\(\log\)&lt;/span&gt; 的数据结构优化，似乎不太过得了；但 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 却可以前缀优化。&lt;/p&gt;
&lt;p&gt;其实，两个组是无序的，这意味着可以强制 &lt;span class=&#34;math inline&#34;&gt;\(i&amp;gt;j\)&lt;/span&gt; 再从 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 转移；这个时候转移就和 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; 没有太大的关系了，可以把 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; 放到外层，对 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 前缀优化。可能需要注意边界的处理。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#endif
    int n, res = 0;
    std::cin &amp;gt;&amp;gt; n;
    std::vector&amp;lt;int&amp;gt; a(n + 1);
    for (int i = 1; i &amp;lt;= n; ++i)
        std::cin &amp;gt;&amp;gt; a[i];
    std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; f(n + 1, std::vector&amp;lt;int&amp;gt; (n + 1));
    for (int j = 0; j &amp;lt; n; ++j) &amp;#123;
        std::vector&amp;lt;int&amp;gt; mx(100002), mmx(7);
        for (int i = 1; i &amp;lt; j; ++i) &amp;#123;
            mx[a[i]] = std::max(mx[a[i]], f[j][i]);
            mmx[a[i] % 7] = std::max(mmx[a[i] % 7], f[j][i]);
        &amp;#125;
        for (int i = j + 1; i &amp;lt;= n; ++i) &amp;#123;
            f[i][j] = std::max(&amp;#123; !!i + !!j, mx[a[i] - 1] + 1, mx[a[i] + 1] + 1, mmx[a[i] % 7] + 1, f[j][0] + 1 &amp;#125;);
            mx[a[i]] = std::max(mx[a[i]], f[i][j]);
            mmx[a[i] % 7] = std::max(mmx[a[i] % 7], f[i][j]);
            // printf(&amp;quot;f[%d][%d] = %d\n&amp;quot;, i, j, f[i][j]);
            res = std::max(res, f[i][j]);
        &amp;#125;
    &amp;#125;
    std::cout &amp;lt;&amp;lt; res &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;cf633f-the-chocolate-spree&#34;&gt;CF633F The Chocolate Spree&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://codeforces.com/problemset/problem/633/F&#34; class=&#34;uri&#34;&gt;https://codeforces.com/problemset/problem/633/F&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;树形 DP 求直径的时候，有一种方法是找到每个点下面的最大两条不交链。&lt;/p&gt;
&lt;p&gt;这里也可以有类似的求法。假设答案出现在子树 &lt;span class=&#34;math inline&#34;&gt;\(u\)&lt;/span&gt; 中（下面的 &lt;span class=&#34;math inline&#34;&gt;\(v_i\)&lt;/span&gt; 都是 &lt;span class=&#34;math inline&#34;&gt;\(u\)&lt;/span&gt; 的直接儿子），可以讨论 &lt;span class=&#34;math inline&#34;&gt;\(u\)&lt;/span&gt; 参与构成两条路径的情况：&lt;/p&gt;
&lt;ol type=&#34;1&#34;&gt;
&lt;li&gt;不参与构成任何一条路径，答案是 &lt;span class=&#34;math inline&#34;&gt;\(v_1,v_2\)&lt;/span&gt; 子树中的最长路径之和。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;参与构成其中一条：&lt;/p&gt;
&lt;ol type=&#34;1&#34;&gt;
&lt;li&gt;这一条与子树 &lt;span class=&#34;math inline&#34;&gt;\(v\)&lt;/span&gt; 完全相离，答案是 &lt;span class=&#34;math inline&#34;&gt;\(v\)&lt;/span&gt; 中最长路径，和 &lt;span class=&#34;math inline&#34;&gt;\(u\)&lt;/span&gt; 下面不经过 &lt;span class=&#34;math inline&#34;&gt;\(v\)&lt;/span&gt; 的最大两条不交链。&lt;/li&gt;
&lt;li&gt;这一条有一支来自 &lt;span class=&#34;math inline&#34;&gt;\(v\)&lt;/span&gt; 子树，但和 &lt;span class=&#34;math inline&#34;&gt;\(v\)&lt;/span&gt; 中最长路径没有重合的点。答案是 &lt;span class=&#34;math inline&#34;&gt;\(u\)&lt;/span&gt; 的点权、&lt;span class=&#34;math inline&#34;&gt;\(u\)&lt;/span&gt; 下面不经过 &lt;span class=&#34;math inline&#34;&gt;\(v\)&lt;/span&gt; 的最大链、&lt;span class=&#34;math inline&#34;&gt;\(v\)&lt;/span&gt; 中一条路径（不经过 &lt;span class=&#34;math inline&#34;&gt;\(v\)&lt;/span&gt;）和 &lt;span class=&#34;math inline&#34;&gt;\(v\)&lt;/span&gt; 下面一条链之和的最大值；&lt;/li&gt;
&lt;li&gt;这一条两支都来自 &lt;span class=&#34;math inline&#34;&gt;\(v\)&lt;/span&gt; 子树：有重合，不可能发生。&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;参与构成其中两条，答案是 &lt;span class=&#34;math inline&#34;&gt;\(u\)&lt;/span&gt; 下面最长的四条链：路径重复经过 &lt;span class=&#34;math inline&#34;&gt;\(u\)&lt;/span&gt;，不可能发生。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;2.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;可以记录 &lt;span class=&#34;math inline&#34;&gt;\(u\)&lt;/span&gt; 下方最大的四条不交链、&lt;span class=&#34;math inline&#34;&gt;\(u\)&lt;/span&gt; 中选取一条不经过 &lt;span class=&#34;math inline&#34;&gt;\(u\)&lt;/span&gt; 的路径和 &lt;span class=&#34;math inline&#34;&gt;\(u\)&lt;/span&gt; 下方一条链之和的最大值、&lt;span class=&#34;math inline&#34;&gt;\(u\)&lt;/span&gt; 中最长路径求解。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp language-cpp&#34; data-line=&#34;42-44&#34;&gt;&lt;code class=&#34;cpp langauage-cpp&#34;&gt;#include &amp;lt;bits/stdc++.h&gt;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&#34;.in&#34;, &#34;r&#34;, stdin);
    std::freopen(&#34;.out&#34;, &#34;w&#34;, stdout);
#endif
    int n;
    std::cin &gt;&gt; n;
    std::vector&amp;lt;int&gt; a(n + 1);
    std::vector&amp;lt;std::vector&amp;lt;int&gt; &gt; g(n + 1);
    for (int i = 1; i &lt;= n; ++i)
        std::cin &gt;&gt; a[i];
    for (int i = 1, x, y; i &lt; n; ++i) &amp;#123;
        std::cin &gt;&gt; x &gt;&gt; y;
        g[x].push_back(y), g[y].push_back(x);
    &amp;#125;
    auto res(0ll);
    std::vector&amp;lt;long long&gt; s(n + 1), w(n + 1);
    std::vector&amp;lt;std::vector&amp;lt;std::pair&amp;lt;long long, int&gt; &gt; &gt; f(n + 1, std::vector&amp;lt;std::pair&amp;lt;long long, int&gt; &gt; (4));
    std::function&amp;lt;void(int, int)&gt; DFS = [&amp;](int x, int fa) &amp;#123;
        f[x][0] = &amp;#123; 0, x &amp;#125;;
        w[x] = s[x] = a[x];
        for (auto i : g[x])
            if (i != fa) &amp;#123;
                DFS(i, x);
                &amp;#123;
                    if (f[i][0].first + a[i] &gt; f[x][3].first)
                        f[x][3].first = f[i][0].first + a[i], f[x][3].second = i;
                    std::sort(f[x].begin(), f[x].end(), std::greater&amp;lt;std::pair&amp;lt;long long, int&gt; &gt; ());
                &amp;#125;
                w[x] = std::max(w[x], w[i] + a[x]);
            &amp;#125;
        auto mx(0ll);
        for (auto i : g[x])
            if (i != fa) &amp;#123;
                s[x] = std::max(&amp;#123; s[x], s[i], f[x][0].first + f[x][1].first + a[x] &amp;#125;);
                w[x] = std::max(w[x], (f[x][0].second != i ? f[x][0] : f[x][1]).first + s[i] + a[x]);
                res = std::max(&amp;#123; res,
                    mx + s[i], // 情况 1
                    (f[x][0].second == i ? f[x][1].first + f[x][2].first : (f[x][1].second == i ? f[x][0].first + f[x][2].first : f[x][0].first + f[x][1].first)) + s[i] + a[x], // 情况 2.1
                    (f[x][0].second == i ? f[x][1].first : f[x][0].first) + w[i] + a[x], // 情况 2.2
                &amp;#125;);
                mx = std::max(mx, s[i]);
            &amp;#125;
    //     printf(&#34;%d: res = %lld\n  f: \n&#34;, a[x], res);
    //     for (int i = 0; i &lt; 4; ++i)
    //         printf(&#34;    [%d] %lld\n&#34;, f[x][i].second, f[x][i].first);
    //     printf(&#34;  s: %lld\n  w: %lld\n&#34;, s[x], w[x]);
    &amp;#125;;
    DFS(1, -1);
    std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;c---巡逻&#34;&gt;C - 巡逻&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P3629&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P3629&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;你可能需要注意：目的是遍历所有边而非所有点。&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(K=1\)&lt;/span&gt; 的时候，环上除了关键边的所有边经过次数会减 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt;。所以选树的直径就可以最优。&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(K=2\)&lt;/span&gt; 的时候，答案是 &lt;span class=&#34;math inline&#34;&gt;\(2\times (m + 2)\)&lt;/span&gt; 减去两个边构成的环的 &lt;em&gt;并集减交集&lt;/em&gt; 大小 &lt;span class=&#34;math inline&#34;&gt;\(L\)&lt;/span&gt;。环实际上是不存在的，&lt;span class=&#34;math inline&#34;&gt;\(L\)&lt;/span&gt; 其实是两条路径 &lt;em&gt;并集减交集&lt;/em&gt; 再加上两条新边的值。&lt;/p&gt;
&lt;p&gt;两条路径有交的时候，可以等效成无交的情况：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;1.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;就化归成上一个问题了。注意此时情况 3 可能发生；同时情况 2.2 可以选取经过 &lt;span class=&#34;math inline&#34;&gt;\(v\)&lt;/span&gt; 的路径。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp language-cpp&#34; data-line=&#34;55-56,64-67&#34;&gt;&lt;code class=&#34;cpp langauage-cpp&#34;&gt;#include &amp;lt;bits/stdc++.h&gt;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&#34;.in&#34;, &#34;r&#34;, stdin);
    std::freopen(&#34;.out&#34;, &#34;w&#34;, stdout);
#endif
    int n, k;
    std::cin &gt;&gt; n &gt;&gt; k;
    std::vector&amp;lt;std::vector&amp;lt;int&gt; &gt; g(n + 1);
    for (int i = 1, x, y; i &lt; n; ++i) &amp;#123;
        std::cin &gt;&gt; x &gt;&gt; y;
        g[x].push_back(y), g[y].push_back(x);
    &amp;#125;
    int res = 0;
    if (k == 1) &amp;#123;
        std::vector&amp;lt;std::vector&amp;lt;std::pair&amp;lt;int, int&gt; &gt; &gt; f(n + 1, std::vector&amp;lt;std::pair&amp;lt;int, int&gt; &gt; (2));
        std::function&amp;lt;void(int, int)&gt; DFS = [&amp;](int x, int fa) &amp;#123;
            f[x][0] = &amp;#123; 0, x &amp;#125;;
            for (auto i : g[x])
                if (i != fa) &amp;#123;
                    DFS(i, x);
                    &amp;#123;
                        if (f[i][0].first + 1 &gt; f[x][1].first)
                            f[x][1].first = f[i][0].first + 1, f[x][1].second = i;
                        std::sort(f[x].begin(), f[x].end(), std::greater&amp;lt;std::pair&amp;lt;int, int&gt; &gt; ());
                    &amp;#125;
                &amp;#125;
            res = std::max(res, f[x][0].first + f[x][1].first);
        &amp;#125;;
        DFS(1, -1);
        std::cout &lt;&lt; 2 * n - res - 1 &lt;&lt; &#39;\n&#39;;
    &amp;#125;
    else &amp;#123;
        std::vector&amp;lt;int&gt; s(n + 1), w(n + 1);
        std::vector&amp;lt;std::vector&amp;lt;std::pair&amp;lt;int, int&gt; &gt; &gt; f(n + 1, std::vector&amp;lt;std::pair&amp;lt;int, int&gt; &gt; (4));
        std::function&amp;lt;void(int, int)&gt; DFS = [&amp;](int x, int fa) &amp;#123;
            f[x][0] = &amp;#123; 0, x &amp;#125;;
            for (auto i : g[x])
                if (i != fa) &amp;#123;
                    DFS(i, x);
                    &amp;#123;
                        if (f[i][0].first + 1 &gt; f[x][3].first)
                            f[x][3].first = f[i][0].first + 1, f[x][3].second = i;
                        std::sort(f[x].begin(), f[x].end(), std::greater&amp;lt;std::pair&amp;lt;int, int&gt; &gt; ());
                    &amp;#125;
                    w[x] = std::max(w[x], w[i] + 1);
                &amp;#125;
            &amp;#123;
                int t = 0;
                for (auto [v, id] : f[x])
                    t += v;
                res = std::max(res, t); // 情况 3
                w[x] = std::max(w[x], t - f[x][3].first); // 路径可经过 u
            &amp;#125;
            int mx = 0;
            for (auto i : g[x])
                if (i != fa) &amp;#123;
                    s[x] = std::max(&amp;#123; s[x], s[i], f[x][0].first + f[x][1].first &amp;#125;);
                    w[x] = std::max(w[x], (f[x][0].second != i ? f[x][0] : f[x][1]).first + std::max(s[i], f[i][0].first + 1));
                    res = std::max(&amp;#123; res,
                        mx + s[i], // 情况 1
                        (f[x][0].second == i ? f[x][1].first + f[x][2].first : (f[x][1].second == i ? f[x][0].first + f[x][2].first : f[x][0].first + f[x][1].first)) + s[i], // 情况 2.1
                        (f[x][0].second == i ? f[x][1].first : f[x][0].first) + w[i] + 1, // 情况 2.2
                    &amp;#125;);
                    mx = std::max(mx, s[i]);
                &amp;#125;
        &amp;#125;;
        DFS(1, -1);
        std::cout &lt;&lt; 2 * (n + 1) - res - 2 &lt;&lt; &#39;\n&#39;;
    &amp;#125;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;d---瞬间传送-teleport&#34;&gt;D - 瞬间传送 / Teleport&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P11915&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P11915&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;需要观察到一个很厉害的贪心策略：如果钦定所有点的距离不大于 &lt;span class=&#34;math inline&#34;&gt;\(r\)&lt;/span&gt;，且存在 &lt;span class=&#34;math inline&#34;&gt;\(d(i,j)&amp;gt;r\)&lt;/span&gt;。&lt;strong&gt;假设&lt;/strong&gt; 一种满足条件的新边是 &lt;span class=&#34;math inline&#34;&gt;\((u,v)\)&lt;/span&gt;（由于两者无序，不妨钦定 &lt;span class=&#34;math inline&#34;&gt;\(d(i,u)&amp;lt;d(i,v)\)&lt;/span&gt;），可以进行讨论：&lt;/p&gt;
&lt;ol type=&#34;1&#34;&gt;
&lt;li&gt;&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(d(j,v)&amp;lt;d(j,u)\)&lt;/span&gt;：&lt;/p&gt;
此时最优路径为 &lt;span class=&#34;math inline&#34;&gt;\(i\to u\to v\to j\)&lt;/span&gt;，判断一下这种方案是否不大于 &lt;span class=&#34;math inline&#34;&gt;\(r\)&lt;/span&gt; 就可以了。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(d(j,v)\ge d(j, u)\)&lt;/span&gt;：&lt;/p&gt;
&lt;p&gt;此时不管是走 &lt;span class=&#34;math inline&#34;&gt;\(i\to u\to v\to j\)&lt;/span&gt; 还是 &lt;span class=&#34;math inline&#34;&gt;\(i\to v\to u\to j\)&lt;/span&gt; 都不如走已经存在的 &lt;span class=&#34;math inline&#34;&gt;\(i\to u\to j\)&lt;/span&gt; 这条路径，也就是说如果要走新边，代价是一定比原距离大，更是比 &lt;span class=&#34;math inline&#34;&gt;\(r\)&lt;/span&gt; 大的；也就是说，&lt;span class=&#34;math inline&#34;&gt;\((u,v)\)&lt;/span&gt; 不能解决 &lt;span class=&#34;math inline&#34;&gt;\((i,j)\)&lt;/span&gt; 之间的问题，假设就不成立了。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;综上，只需要判断 &lt;span class=&#34;math inline&#34;&gt;\(i\to u\to v\to j\le r\)&lt;/span&gt; 是否成立，就可以判断 &lt;span class=&#34;math inline&#34;&gt;\((u,v)\)&lt;/span&gt; 是否合法。从大到小枚举 &lt;span class=&#34;math inline&#34;&gt;\(r\)&lt;/span&gt;，同时维护当前依然合法的 &lt;span class=&#34;math inline&#34;&gt;\((u,v)\)&lt;/span&gt;（显然是有单调性的），对于不合法的 &lt;span class=&#34;math inline&#34;&gt;\((i,j)\)&lt;/span&gt;，枚举每个 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt;，维护 &lt;span class=&#34;math inline&#34;&gt;\(\max\{d(v,j)\}\)&lt;/span&gt;，精细实现（主要是利用各种均摊）一下就能 &lt;span class=&#34;math inline&#34;&gt;\(O(n^3)\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;这里具体提一下需要摊的几个点：&lt;/p&gt;
&lt;ol type=&#34;1&#34;&gt;
&lt;li&gt;枚举到 &lt;span class=&#34;math inline&#34;&gt;\(r\)&lt;/span&gt; 的时候用所有 &lt;span class=&#34;math inline&#34;&gt;\(d(i,j)=r+1\)&lt;/span&gt; 把 &lt;span class=&#34;math inline&#34;&gt;\(v\)&lt;/span&gt; 在 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 处的最大 &lt;span class=&#34;math inline&#34;&gt;\(d(v,j)\)&lt;/span&gt; 更新，方便后面 &lt;span class=&#34;math inline&#34;&gt;\(O(n)\)&lt;/span&gt; 地 check。摊出来是 &lt;span class=&#34;math inline&#34;&gt;\(O(n^3)\)&lt;/span&gt; 的。&lt;/li&gt;
&lt;li&gt;枚举仍然处在合法队列里的 &lt;span class=&#34;math inline&#34;&gt;\((u,v)\)&lt;/span&gt;，如果 check 合法，就说明对于当前 &lt;span class=&#34;math inline&#34;&gt;\(r\)&lt;/span&gt; 至少存在一个合法解，就可以 &lt;code&gt;break&lt;/code&gt; 了；否则，把 &lt;span class=&#34;math inline&#34;&gt;\((u,v)\)&lt;/span&gt; 弹出，继续 check 下一条边。这样每条边只会被弹出一次，而未弹出边的 check 次数最多是 &lt;span class=&#34;math inline&#34;&gt;\(O(n)\)&lt;/span&gt;；加上 &lt;span class=&#34;math inline&#34;&gt;\(O(n)\)&lt;/span&gt; 的 check，摊出来是 &lt;span class=&#34;math inline&#34;&gt;\(O(n^3)\)&lt;/span&gt; 的。&lt;/li&gt;
&lt;/ol&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int inf = 0x3f3f3f3f;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#endif
    int T;
    for (std::cin &amp;gt;&amp;gt; T; T--; ) &amp;#123;
        int n;
        std::cin &amp;gt;&amp;gt; n;
        std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; g(n + 1, std::vector&amp;lt;int&amp;gt; (n + 1, inf));
        for (int i = 1; i &amp;lt;= n; ++i)
            for (int j = 1; j &amp;lt;= n; ++j) &amp;#123;
                char t;
                std::cin &amp;gt;&amp;gt; t;
                if (t == &amp;#39;1&amp;#39; || i == j)
                    g[i][j] = t - &amp;#39;0&amp;#39;;
            &amp;#125;
        for (int k = 1; k &amp;lt;= n; ++k)
            for (int i = 1; i &amp;lt;= n; ++i)
                if (i != k)
                    for (int j = 1; j &amp;lt;= n; ++j)
                        if (j != i &amp;amp;&amp;amp; j != k)
                            g[i][j] = std::min(g[i][j], g[i][k] + g[k][j]);
        std::queue&amp;lt;std::pair&amp;lt;int, int&amp;gt; &amp;gt; q;
        std::vector&amp;lt;std::vector&amp;lt;std::pair&amp;lt;int, int&amp;gt; &amp;gt; &amp;gt; p(n + 1);
        std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; mx(n + 1, std::vector&amp;lt;int&amp;gt; (n + 1));
        for (int i = 1; i &amp;lt; n; ++i)
            for (int j = i + 1; j &amp;lt;= n; ++j) &amp;#123;
                q.emplace(i, j);
                p[g[i][j] - 1].emplace_back(i, j);
            &amp;#125;
        auto check = [&amp;amp;](int u, int v, int r) &amp;#123;
            for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
                if (g[u][i] &amp;gt; g[v][i])
                    std::swap(u, v);
                if (g[u][i] + mx[v][i] &amp;gt; r)
                    return false;
            &amp;#125;
            return true;
        &amp;#125;;
        for (int r = n; r &amp;gt;= -1; --r) &amp;#123;
            for (auto [i, j] : p[r])
                for (int v = 1; v &amp;lt;= n; ++v) &amp;#123;
                    mx[v][i] = std::max(mx[v][i], g[v][j]);
                    mx[v][j] = std::max(mx[v][j], g[v][i]);
                &amp;#125;
            for (; !q.empty(); ) &amp;#123;
                auto [u, v] = q.front();
                if (!check(u, v, r))
                    q.pop();
                else
                    break;
            &amp;#125;
            if (q.empty()) &amp;#123;
                std::cout &amp;lt;&amp;lt; r + 1 &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
                break;
            &amp;#125;
        &amp;#125;
    &amp;#125;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;e.-two-tanks&#34;&gt;E. Two Tanks&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://codeforces.com/problemset/problem/1809/E&#34; class=&#34;uri&#34;&gt;https://codeforces.com/problemset/problem/1809/E&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;果然还是不会简单 DP &lt;img src=&#34;/em/ll.gif&#34; /&gt;&lt;/p&gt;
&lt;p&gt;可以观察到如果总水量相同，且某个时刻两种初始状态当前是相同状态，那么以后它们也会是相同状态。但光凭这个好像还是不太能做出来的样子 &lt;img src=&#34;/em/kt.gif&#34; /&gt;&lt;/p&gt;
&lt;p&gt;这里大概算一个定式，对于类似这种两个元素总和不变的问题，可以把两个元素的容量画到数轴上，原点表示分界，当前水为一条定长线段，倒水就相当于左右平移这条线段：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;3.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;需要意识到，&lt;mark&gt;&lt;/mark&gt;&lt;/p&gt;
 ]]></description>
        </item>
    </channel>
</rss>
