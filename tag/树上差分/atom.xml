<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://xsc062.netlify.app</id>
    <title> • Posts by &#34;树上差分&#34; tag</title>
    <link href="https://xsc062.netlify.app" />
    <updated>2025-02-16T11:44:38.000Z</updated>
    <category term="并查集" />
    <category term="斜率优化" />
    <category term="悬线法" />
    <category term="哈希" />
    <category term="字典树" />
    <category term="DP" />
    <category term="单调队列" />
    <category term="分治" />
    <category term="二分图" />
    <category term="CRT / exCRT" />
    <category term="排列组合" />
    <category term="网络流" />
    <category term="费用流" />
    <category term="二分" />
    <category term="上下界网络流" />
    <category term="容斥原理" />
    <category term="线段树" />
    <category term="树状数组" />
    <category term="区间 DP" />
    <category term="构造" />
    <category term="Tarjan" />
    <category term="数据结构" />
    <category term="下饭" />
    <category term="LCA" />
    <category term="倍增" />
    <category term="鸽巢原理" />
    <category term="概率期望" />
    <category term="调和级数" />
    <category term="差分" />
    <category term="思维" />
    <category term="树形 DP" />
    <category term="最小生成树" />
    <category term="SAM" />
    <category term="状压" />
    <category term="分块" />
    <category term="可持久化" />
    <category term="笛卡尔树" />
    <category term="高维前缀和" />
    <category term="闲话" />
    <category term="欧拉回路" />
    <category term="树链剖分" />
    <category term="长链剖分" />
    <category term="KMP" />
    <category term="border" />
    <category term="字符串" />
    <category term="AC 自动机" />
    <category term="SA" />
    <category term="数学" />
    <category term="树上差分" />
    <category term="FWT" />
    <category term="堆" />
    <category term="树的重心" />
    <category term="二项式定理" />
    <category term="二项式反演" />
    <category term="贪心" />
    <category term="均摊" />
    <category term="计数" />
    <category term="优化建图" />
    <category term="反悔贪心" />
    <category term="调整法" />
    <category term="背包" />
    <category term="博弈论" />
    <category term="DP 优化" />
    <category term="虚树" />
    <category term="点分治" />
    <category term="WQS 二分" />
    <category term="闵可夫斯基和" />
    <category term="slope trick" />
    <category term="四边形不等式" />
    <category term="暴力" />
    <category term="状压 DP" />
    <category term="组合数学" />
    <category term="支配对" />
    <category term="DDP" />
    <category term="平衡树" />
    <category term="容斥" />
    <category term="猫树" />
    <category term="Kruskal 重构树" />
    <category term="李超线段树" />
    <entry>
        <id>https://xsc062.netlify.app/20250216/</id>
        <title>Public Round 15 前两题</title>
        <link rel="alternate" href="https://xsc062.netlify.app/20250216/"/>
        <content type="html">&lt;p&gt;&lt;a href=&#34;https://pjudge.ac/contest/1914&#34;&gt;PR #15&lt;/a&gt; 前两题题解。&lt;/p&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;最小表示法&#34;&gt;最小表示法&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://pjudge.ac/contest/1914/problem/21888&#34; class=&#34;uri&#34;&gt;https://pjudge.ac/contest/1914/problem/21888&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;首先不妨假设每个 &lt;span class=&#34;math inline&#34;&gt;\(f\)&lt;/span&gt; 在值域内等概率取值以简化问题。那么手玩一下可以轻松地得到规律：不妨将 &lt;span class=&#34;math inline&#34;&gt;\(\{s\}\)&lt;/span&gt; 循环右移一位的结果记为 &lt;span class=&#34;math inline&#34;&gt;\(\{t\}\)&lt;/span&gt;，那么 &lt;span class=&#34;math inline&#34;&gt;\(res=\sum\frac 1{\max(|s_i|,|t_i|)}\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;这看起来令人疑惑：对于不同的 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt;，&lt;span class=&#34;math inline&#34;&gt;\([f(s_i)=f(t_i)]\)&lt;/span&gt; 的期望似乎是彼此独立的，十分奇怪。这其实与表达式的来源有关，记 &lt;span class=&#34;math inline&#34;&gt;\(g(s_i, j)\)&lt;/span&gt; 表示 &lt;span class=&#34;math inline&#34;&gt;\(f(s_i)=j\)&lt;/span&gt; 的概率，那么上述等式可以转写为 &lt;span class=&#34;math inline&#34;&gt;\(res=\sum\limits_i\sum\limits_jg({s_i},j)\times g(t_i,j)\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;那么将最小表示法带来的偏差纳入考虑范围，我们发现 &lt;span class=&#34;math inline&#34;&gt;\(g(s,j)\)&lt;/span&gt; 对于不同的 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; 并不永远相等。具体地，当 &lt;span class=&#34;math inline&#34;&gt;\(s\)&lt;/span&gt; 具有循环节时，最小循环节的第一处结尾会享有更大的取得概率。&lt;/p&gt;
&lt;p&gt;枚举 &lt;span class=&#34;math inline&#34;&gt;\(s_i\)&lt;/span&gt; 的因数作为最小循环节长度的情况，显然，对于最小循环节为 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; 的情况（该情况出现的概率，容斥得到 &lt;span class=&#34;math inline&#34;&gt;\(p_j=26^j-\sum_{k\mid j}p_k\)&lt;/span&gt;），&lt;span class=&#34;math inline&#34;&gt;\(f(s_i)\)&lt;/span&gt; 的取值在 &lt;span class=&#34;math inline&#34;&gt;\(1\sim j\)&lt;/span&gt; 上等概率分布，差分即可统计每个值在不同循环节长度下被取到的概率和。&lt;/p&gt;
&lt;p&gt;用埃筛解决每个数的因数和 &lt;span class=&#34;math inline&#34;&gt;\(p\)&lt;/span&gt; 值，那么此时复杂度瓶颈在于 &lt;span class=&#34;math inline&#34;&gt;\(g(s_i, j)\)&lt;/span&gt; 和 &lt;span class=&#34;math inline&#34;&gt;\(\sum\limits_i\sum\limits_jg({s_i},j)\times g(t_i,j)\)&lt;/span&gt; 的求解。容易发现只有每个 &lt;span class=&#34;math inline&#34;&gt;\(g(s_i,j),j\mid |s_i|\)&lt;/span&gt; 的值是有效的（其他的和它们值都相同），考虑只求解和利用这些值，类 &lt;code&gt;std::merge&lt;/code&gt;（即归并排序）地求解答案。&lt;/p&gt;
&lt;p&gt;注意特判 &lt;span class=&#34;math inline&#34;&gt;\(n=1\)&lt;/span&gt;。会得到错误答案的原因是此时存在 &lt;span class=&#34;math inline&#34;&gt;\(s_i=t_i\)&lt;/span&gt;，不满足基本要求。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int lim = 1e5;
const int mod = 998244353;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#endif
    int n;
    std::cin &amp;gt;&amp;gt; n;
    if (n == 1) &amp;#123;
        std::cout &amp;lt;&amp;lt; 1 &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
        return 0;
    &amp;#125;
    auto qkp = [](long long x, int y) &amp;#123;
        long long res = 1ll;
        for (; y; y &amp;gt;&amp;gt;= 1, (x *= x) %= mod)
            if (y &amp;amp; 1)
                (res *= x) %= mod;
        return res;
    &amp;#125;;
    auto inv = [&amp;amp;](int x) &amp;#123;
        return qkp(x, mod - 2);
    &amp;#125;;
    std::vector&amp;lt;long long&amp;gt; f(lim + 1);
    std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; fac(lim + 1);
    for (int i = 1; i &amp;lt;= lim; ++i) &amp;#123;
        static long long now = 26;
        (f[i] += now) %= mod;
        fac[i].push_back(i);
        for (int j = 2 * i; j &amp;lt;= lim; j += i)
            (f[j] += mod - f[i]) %= mod, fac[j].push_back(i);
        (now *= 26) %= mod;
    &amp;#125;
    for (int i = 1; i &amp;lt;= lim; ++i)
        (f[i] *= inv(i)) %= mod;
    std::vector&amp;lt;int&amp;gt; a(n + 1);
    struct _ &amp;#123; int l, r; long long f; &amp;#125;;
    std::vector&amp;lt;std::vector&amp;lt;_&amp;gt; &amp;gt; g(lim + 1);
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        std::cin &amp;gt;&amp;gt; a[i];
        if (g[a[i]].empty()) &amp;#123;
            g[a[i]].resize(fac[a[i]].size());
            for (int j = 0; j &amp;lt; (int)fac[a[i]].size(); ++j) &amp;#123;
                g[a[i]][j].l = (j ? g[a[i]][j - 1].r + 1 : 1);
                g[a[i]][j].r = fac[a[i]][j];
                (g[a[i]][0].f += f[fac[a[i]][j]]) %= mod;
                if (j != (int)fac[a[i]].size() - 1)
                    (g[a[i]][j + 1].f += mod - f[fac[a[i]][j]]) %= mod;
            &amp;#125;
            for (int j = 1; j &amp;lt; (int)fac[a[i]].size(); ++j)
                (g[a[i]][j].f += g[a[i]][j - 1].f) %= mod;
            int getinv = inv(qkp(26, a[i]));
            for (int j = 0; j &amp;lt; (int)fac[a[i]].size(); ++j)
                (g[a[i]][j].f *= getinv) %= mod;
        &amp;#125;
    &amp;#125;
    std::vector&amp;lt;int&amp;gt; b(n + 1);
    std::rotate_copy(a.begin() + 1, --a.end(), a.end(), b.begin() + 1);
    long long res = 0ll;
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        for (int j = 0, k = 0, now = 0;
            j &amp;lt; (int)fac[a[i]].size() &amp;amp;&amp;amp; k &amp;lt; (int)fac[b[i]].size(); )
            if (g[a[i]][j].r &amp;lt; g[b[i]][k].r) &amp;#123;
                (res += g[a[i]][j].f * g[b[i]][k].f % mod
                    * (g[a[i]][j].r - now) % mod) %= mod;
                now = g[a[i]][j].r, ++j;
            &amp;#125;
            else if (g[a[i]][j].r == g[b[i]][k].r) &amp;#123;
                (res += g[a[i]][j].f * g[b[i]][k].f % mod
                    * (g[a[i]][j].r - now) % mod) %= mod;
                now = g[a[i]][j].r, ++j, ++k;
            &amp;#125;
            else &amp;#123;
                (res += g[a[i]][j].f * g[b[i]][k].f % mod
                    * (g[b[i]][k].r - now) % mod) %= mod;
                now = g[b[i]][k].r, ++k;
            &amp;#125;
    &amp;#125;
    std::cout &amp;lt;&amp;lt; res &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;二叉搜索树&#34;&gt;二叉搜索树&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://pjudge.ac/contest/1914/problem/21889&#34; class=&#34;uri&#34;&gt;https://pjudge.ac/contest/1914/problem/21889&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;当我们处理链的部分分时，很容易想到用差分解决问题。把更新 &lt;span class=&#34;math inline&#34;&gt;\([l, r]\)&lt;/span&gt; 看作在差分数组 &lt;span class=&#34;math inline&#34;&gt;\(l\)&lt;/span&gt; 处插入，在 &lt;span class=&#34;math inline&#34;&gt;\(r+1\)&lt;/span&gt; 处删除，离线下来再从左到右扫一遍操作，考虑如何解决查询问题。&lt;/p&gt;
&lt;p&gt;考虑如何获取 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 树上 &lt;span class=&#34;math inline&#34;&gt;\(t_0\)&lt;/span&gt; 时刻点 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 的所有祖先。根据前面的操作，我们可以获取 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 树上存在过的所有元素。&lt;/p&gt;
&lt;p&gt;对于比 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 大的元素，考虑祖先 &lt;span class=&#34;math inline&#34;&gt;\(p_a\)&lt;/span&gt; 和非祖先 &lt;span class=&#34;math inline&#34;&gt;\(p\)&lt;/span&gt; 有什么区别。根据 BST 的性质易得，对于最低的右侧祖先 &lt;span class=&#34;math inline&#34;&gt;\({p_a}_0\)&lt;/span&gt;，其是 &lt;span class=&#34;math inline&#34;&gt;\(\ge x\)&lt;/span&gt; 的最小的元素（当然其加入时刻 &lt;span class=&#34;math inline&#34;&gt;\(t_a&amp;lt;t_0\)&lt;/span&gt;）；那么同理可以找到 &lt;span class=&#34;math inline&#34;&gt;\({p_a}_0\)&lt;/span&gt; 右侧最低的祖先（其左侧的祖先显然也 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 左侧），该祖先满足 &lt;span class=&#34;math inline&#34;&gt;\(t&amp;lt;t_a\)&lt;/span&gt;。那么我们就从左右两边分别得到 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 的所有祖先。容易证明该过程对于不在树上的 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 也是正确的。&lt;/p&gt;
&lt;p&gt;具体地，我们需要一个数据结构，能够求出 &lt;span class=&#34;math inline&#34;&gt;\(\ge x\)&lt;/span&gt; 的元素中，以 &lt;span class=&#34;math inline&#34;&gt;\(t_0\)&lt;/span&gt; 为起点的前缀最小值序列的区间和。&lt;/p&gt;
&lt;p&gt;欸 ☝🤓 这是什么？&lt;a href=&#34;/20250217&#34;&gt;楼房重建&lt;/a&gt;！秒一下！&lt;/p&gt;
&lt;p&gt;进一步地，本题需要完成对于 &lt;span class=&#34;math inline&#34;&gt;\(t_0\)&lt;/span&gt; 为序列头的查询。再次利用性质，每次 &lt;span class=&#34;math inline&#34;&gt;\(O(\log V)\)&lt;/span&gt; 地合并答案。&lt;/p&gt;
&lt;p&gt;好的那么怎么把链搞到树上呢？把差分放到树上，写个线段树合并即可。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意由于这题细节太多了，所以你可能需要舍弃不必要的时空优化换取代码简洁度以方便调试。&lt;/strong&gt;&lt;/p&gt;
&lt;details&gt;
&lt;pre data-line=&#34;12&#34; class=&#34;cpp language-cpp&#34;&gt;&lt;code data-line=&#34;12&#34; class=&#34;cpp language-cpp&#34;&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int lim = 2e5;
const int maxn = 2e7 + 5;
const int inf = 0x3f3f3f3f;
struct &amp;#123;
    int l, r, rv;
    long long u;
&amp;#125; t[maxn];
std::vector&amp;lt;int&gt; tr;
#define lt t[p].l
#define rt t[p].r
int newnode(void) &amp;#123;         // 我知道你要说什么，但这属于「必要的」空间优化 😥
    static int tot = 0;
    if (tr.empty())
        return ++tot;
    auto p(tr.back());
    t[p].l = t[p].r = 0;
    tr.pop_back();
    return p;
&amp;#125;
long long askv(int p, int l, int r, int v) &amp;#123;
    if (l == r)
        return t[p].rv &lt; v ? t[p].u : 0;
    int mid = (l + r) &gt;&gt; 1;
    if (v &gt; t[lt].rv)
        return t[p].u - t[lt].u + askv(lt, l, mid, v);
    return askv(rt, mid + 1, r, v);
&amp;#125;
void pushup(int p, int l, int r) &amp;#123;
    t[p].rv = std::min(t[lt].rv, t[rt].rv);
    int mid = (l + r) &gt;&gt; 1;
    t[p].u = t[lt].u + askv(rt, mid + 1, r, t[lt].rv);
    return;
&amp;#125;
void upd(int &amp;p, int l, int r, int x, int v, int u) &amp;#123;
    if (!p)
        p = newnode();
    if (l == r) &amp;#123;
        t[p].rv = v, t[p].u = u;
        return;
    &amp;#125;
    int mid = (l + r) &gt;&gt; 1;
    if (x &lt;= mid)
        upd(lt, l, mid, x, v, u);
    else
        upd(rt, mid + 1, r, x, v, u);
    pushup(p, l, r);
    return;
&amp;#125;
void merge(int &amp;p, int q, int l, int r) &amp;#123;
    if (!p || !q) &amp;#123;
        p += q;
        return;
    &amp;#125;
    if (l == r) &amp;#123;
        t[p].rv = std::min(t[p].rv, t[q].rv);
        t[p].u = std::max(t[p].u, t[q].u);
        return;
    &amp;#125;
    int mid = (l + r) &gt;&gt; 1;
    merge(t[p].l, t[q].l, l, mid), merge(t[p].r, t[q].r, mid + 1, r);
    pushup(p, l, r), tr.push_back(q);
    return;
&amp;#125;
int qv = inf;
long long ask(int p, int l, int r, int ql, int qr) &amp;#123;
    if (ql &lt;= l &amp;&amp; r &lt;= qr) &amp;#123;
        auto s(askv(p, l, r, qv));
        qv = std::min(qv, t[p].rv);
        return s;
    &amp;#125;
    int mid = (l + r) &gt;&gt; 1;
    long long res = 0ll;
    if (ql &lt;= mid)
        res = ask(lt, l, mid, ql, qr);
    if (qr &gt; mid)
        res += ask(rt, mid + 1, r, ql, qr);
    return res;
&amp;#125;
#undef lt
#undef rt
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&#34;ex_problem4.in&#34;, &#34;r&#34;, stdin);
    std::freopen(&#34;.out&#34;, &#34;w&#34;, stdout);
#endif
    int n, m;
    std::cin &gt;&gt; n &gt;&gt; m;
    std::vector&amp;lt;std::vector&amp;lt;int&gt; &gt; g(n + 1);
    for (int i = 1, x, y; i &lt; n; ++i) &amp;#123;
        std::cin &gt;&gt; x &gt;&gt; y;
        g[x].push_back(y), g[y].push_back(x);
    &amp;#125;
    std::vector&amp;lt;int&gt; top(n + 1), fa(n + 1), siz(n + 1), son(n + 1), dep(n + 1);
    std::function&amp;lt;void(int, int)&gt; DFS = [&amp;](int x, int faa) &amp;#123;
        siz[x] = 1;
        for (auto i : g[x])
            if (i != faa) &amp;#123;
                fa[i] = x, dep[i] = dep[x] + 1;
                DFS(i, x), siz[x] += siz[i];
                if (siz[i] &gt; siz[son[x]])
                    son[x] = i;
            &amp;#125;
        return;
    &amp;#125;;
    DFS(1, -1);
    DFS = [&amp;](int x, int topp) &amp;#123;
        top[x] = topp;
        if (son[x])
            DFS(son[x], topp);
        for (auto i : g[x])
            if (i != fa[x] &amp;&amp; i != son[x])
                DFS(i, i);
        return;
    &amp;#125;;
    DFS(1, 1);
    auto getLCA = [&amp;](int x, int y) &amp;#123;
        for (; top[x] != top[y]; x = fa[top[x]])
            if (dep[top[y]] &gt; dep[top[x]])
                std::swap(x, y);
        return (dep[x] &lt; dep[y] ? x : y);
    &amp;#125;;
    std::vector&amp;lt;std::vector&amp;lt;int&gt; &gt; d(n + 1);
    std::vector&amp;lt;std::vector&amp;lt;std::pair&amp;lt;int, int&gt; &gt; &gt; u(n + 1);
    std::vector&amp;lt;std::vector&amp;lt;std::tuple&amp;lt;int, int, int&gt; &gt; &gt; q(n + 1);
    int cnt = 0;
    for (int i = 1; i &lt;= m; ++i) &amp;#123;
        int op;
        std::cin &gt;&gt; op;
        if (op == 0) &amp;#123;
            int x, v;
            std::cin &gt;&gt; x &gt;&gt; v;
            q[x].emplace_back(++cnt, i, v);
        &amp;#125; else &amp;#123;
            int x, y, v;
            std::cin &gt;&gt; x &gt;&gt; y &gt;&gt; v;
            int faa = getLCA(x, y);
            u[x].emplace_back(i, v), u[y].emplace_back(i, v);
            if (fa[faa])
                d[fa[faa]].emplace_back(v);
        &amp;#125;
    &amp;#125;
    std::vector&amp;lt;long long&gt; res(cnt + 1);
    std::vector&amp;lt;std::vector&amp;lt;int&gt; &gt; rt(2, std::vector&amp;lt;int&gt; (n + 1));
    t[0].rv = inf;
    DFS = [&amp;](int x, int fa) &amp;#123;
        for (auto i : g[x])
            if (i != fa) &amp;#123;
                DFS(i, x);
                merge(rt[0][x], rt[0][i], 1, lim);
                merge(rt[1][x], rt[1][i], 1, lim);
            &amp;#125;
        for (auto [t, v] : u[x]) &amp;#123;
            upd(rt[0][x], 1, lim, v, t, v);
            upd(rt[1][x], 1, lim, lim - v + 1, t, v);
        &amp;#125;
        for (auto v : d[x]) &amp;#123;
            upd(rt[0][x], 1, lim, v, inf, 0);
            upd(rt[1][x], 1, lim, lim - v + 1, inf, 0);
        &amp;#125;
        for (auto [id, t, v] : q[x]) &amp;#123;
            qv = t, res[id] = ask(rt[0][x], 1, lim, v, lim);
            qv = t, res[id] += ask(rt[1][x], 1, lim, lim - v + 1, lim);
            qv = t, res[id] -= ask(rt[0][x], 1, lim, v, v);
        &amp;#125;
    &amp;#125;;
    DFS(1, -1);
    for (int i = 1; i &lt;= cnt; ++i)
        std::cout &lt;&lt; res[i] &lt;&lt; &#39;\n&#39;;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
</content>
        <category term="线段树" />
        <category term="数学" />
        <category term="树上差分" />
        <updated>2025-02-16T11:44:38.000Z</updated>
    </entry>
</feed>
