<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://xsc062.netlify.app</id>
    <title> â€¢ Posts by &#34;æ ‘ä¸Šå·®åˆ†&#34; tag</title>
    <link href="https://xsc062.netlify.app" />
    <updated>2025-02-16T11:44:38.000Z</updated>
    <category term="æ‚¬çº¿æ³•" />
    <category term="æ–œç‡ä¼˜åŒ–" />
    <category term="å¹¶æŸ¥é›†" />
    <category term="å“ˆå¸Œ" />
    <category term="DP" />
    <category term="å•è°ƒé˜Ÿåˆ—" />
    <category term="å­—å…¸æ ‘" />
    <category term="äºŒåˆ†å›¾" />
    <category term="åˆ†æ²»" />
    <category term="è®¡æ•°" />
    <category term="å®¹æ–¥" />
    <category term="CRT / exCRT" />
    <category term="æ’åˆ—ç»„åˆ" />
    <category term="ç½‘ç»œæµ" />
    <category term="äºŒåˆ†" />
    <category term="å®¹æ–¥åŸç†" />
    <category term="çº¿æ®µæ ‘" />
    <category term="æ ‘çŠ¶æ•°ç»„" />
    <category term="åŒºé—´ DP" />
    <category term="æ•°æ®ç»“æ„" />
    <category term="æ„é€ " />
    <category term="Tarjan" />
    <category term="ä¸‹é¥­" />
    <category term="æè¶…çº¿æ®µæ ‘" />
    <category term="æ ‘é“¾å‰–åˆ†" />
    <category term="LCA" />
    <category term="å€å¢" />
    <category term="é¸½å·¢åŸç†" />
    <category term="æ•°å­¦" />
    <category term="è°ƒå’Œçº§æ•°" />
    <category term="å·®åˆ†" />
    <category term="æ€ç»´" />
    <category term="æ ‘å½¢ DP" />
    <category term="æœ€å°ç”Ÿæˆæ ‘" />
    <category term="SAM" />
    <category term="çŠ¶å‹" />
    <category term="åˆ†å—" />
    <category term="å¯æŒä¹…åŒ–" />
    <category term="ç¬›å¡å°”æ ‘" />
    <category term="é«˜ç»´å‰ç¼€å’Œ" />
    <category term="é—²è¯" />
    <category term="æ¬§æ‹‰å›è·¯" />
    <category term="é•¿é“¾å‰–åˆ†" />
    <category term="KMP" />
    <category term="border" />
    <category term="éšæœºåŒ–" />
    <category term="å­—ç¬¦ä¸²" />
    <category term="AC è‡ªåŠ¨æœº" />
    <category term="SA" />
    <category term="æ ‘ä¸Šå·®åˆ†" />
    <category term="FWT" />
    <category term="å †" />
    <category term="æ ‘çš„é‡å¿ƒ" />
    <category term="è´ªå¿ƒ" />
    <category term="å‡æ‘Š" />
    <category term="åæ‚”è´ªå¿ƒ" />
    <category term="ä¼˜åŒ–å»ºå›¾" />
    <category term="è°ƒæ•´æ³•" />
    <category term="åšå¼ˆè®º" />
    <category term="DP ä¼˜åŒ–" />
    <category term="è™šæ ‘" />
    <category term="ç‚¹åˆ†æ²»" />
    <category term="å››è¾¹å½¢ä¸ç­‰å¼" />
    <category term="èƒŒåŒ…" />
    <category term="æ”¯é…å¯¹" />
    <category term="DDP" />
    <category term="CDQ åˆ†æ²»" />
    <category term="çŒ«æ ‘" />
    <category term="DP å¥— DP" />
    <category term="Kruskal é‡æ„æ ‘" />
    <category term="é«˜ç²¾åº¦" />
    <category term="æœ€çŸ­è·¯" />
    <category term="æ ‘å¥—æ ‘" />
    <category term="äºŒé¡¹å¼åæ¼”" />
    <category term="æœç´¢" />
    <entry>
        <id>https://xsc062.netlify.app/20250216/</id>
        <title>æ‚é¢˜é€‰è°ˆï¼šPublic Round 15</title>
        <link rel="alternate" href="https://xsc062.netlify.app/20250216/"/>
        <content type="html">&lt;p&gt;&lt;a href=&#34;https://pjudge.ac/contest/1914&#34;&gt;PR #15&lt;/a&gt; å‰ä¸¤é¢˜é¢˜è§£ã€‚&lt;/p&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;æœ€å°è¡¨ç¤ºæ³•&#34;&gt;æœ€å°è¡¨ç¤ºæ³•&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://pjudge.ac/contest/1914/problem/21888&#34; class=&#34;uri&#34;&gt;https://pjudge.ac/contest/1914/problem/21888&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;é¦–å…ˆä¸å¦¨å‡è®¾æ¯ä¸ª &lt;span class=&#34;math inline&#34;&gt;\(f\)&lt;/span&gt; åœ¨å€¼åŸŸå†…ç­‰æ¦‚ç‡å–å€¼ä»¥ç®€åŒ–é—®é¢˜ã€‚é‚£ä¹ˆæ‰‹ç©ä¸€ä¸‹å¯ä»¥è½»æ¾åœ°å¾—åˆ°è§„å¾‹ï¼šä¸å¦¨å°† &lt;span class=&#34;math inline&#34;&gt;\(\{s\}\)&lt;/span&gt; å¾ªç¯å³ç§»ä¸€ä½çš„ç»“æœè®°ä¸º &lt;span class=&#34;math inline&#34;&gt;\(\{t\}\)&lt;/span&gt;ï¼Œé‚£ä¹ˆ &lt;span class=&#34;math inline&#34;&gt;\(res=\sum\frac 1{\max(|s_i|,|t_i|)}\)&lt;/span&gt;ã€‚&lt;/p&gt;
&lt;p&gt;è¿™çœ‹èµ·æ¥ä»¤äººç–‘æƒ‘ï¼šå¯¹äºä¸åŒçš„ &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt;ï¼Œ&lt;span class=&#34;math inline&#34;&gt;\([f(s_i)=f(t_i)]\)&lt;/span&gt; çš„æœŸæœ›ä¼¼ä¹æ˜¯å½¼æ­¤ç‹¬ç«‹çš„ï¼Œååˆ†å¥‡æ€ªã€‚è¿™å…¶å®ä¸è¡¨è¾¾å¼çš„æ¥æºæœ‰å…³ï¼Œè®° &lt;span class=&#34;math inline&#34;&gt;\(g(s_i, j)\)&lt;/span&gt; è¡¨ç¤º &lt;span class=&#34;math inline&#34;&gt;\(f(s_i)=j\)&lt;/span&gt; çš„æ¦‚ç‡ï¼Œé‚£ä¹ˆä¸Šè¿°ç­‰å¼å¯ä»¥è½¬å†™ä¸º &lt;span class=&#34;math inline&#34;&gt;\(res=\sum\limits_i\sum\limits_jg({s_i},j)\times g(t_i,j)\)&lt;/span&gt;ã€‚&lt;/p&gt;
&lt;p&gt;é‚£ä¹ˆå°†æœ€å°è¡¨ç¤ºæ³•å¸¦æ¥çš„åå·®çº³å…¥è€ƒè™‘èŒƒå›´ï¼Œæˆ‘ä»¬å‘ç° &lt;span class=&#34;math inline&#34;&gt;\(g(s,j)\)&lt;/span&gt; å¯¹äºä¸åŒçš„ &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; å¹¶ä¸æ°¸è¿œç›¸ç­‰ã€‚å…·ä½“åœ°ï¼Œå½“ &lt;span class=&#34;math inline&#34;&gt;\(s\)&lt;/span&gt; å…·æœ‰å¾ªç¯èŠ‚æ—¶ï¼Œæœ€å°å¾ªç¯èŠ‚çš„ç¬¬ä¸€å¤„ç»“å°¾ä¼šäº«æœ‰æ›´å¤§çš„å–å¾—æ¦‚ç‡ã€‚&lt;/p&gt;
&lt;p&gt;æšä¸¾ &lt;span class=&#34;math inline&#34;&gt;\(s_i\)&lt;/span&gt; çš„å› æ•°ä½œä¸ºæœ€å°å¾ªç¯èŠ‚é•¿åº¦çš„æƒ…å†µï¼Œæ˜¾ç„¶ï¼Œå¯¹äºæœ€å°å¾ªç¯èŠ‚ä¸º &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; çš„æƒ…å†µï¼ˆè¯¥æƒ…å†µå‡ºç°çš„æ¦‚ç‡ï¼Œå®¹æ–¥å¾—åˆ° &lt;span class=&#34;math inline&#34;&gt;\(p_j=26^j-\sum_{k\mid j}p_k\)&lt;/span&gt;ï¼‰ï¼Œ&lt;span class=&#34;math inline&#34;&gt;\(f(s_i)\)&lt;/span&gt; çš„å–å€¼åœ¨ &lt;span class=&#34;math inline&#34;&gt;\(1\sim j\)&lt;/span&gt; ä¸Šç­‰æ¦‚ç‡åˆ†å¸ƒï¼Œå·®åˆ†å³å¯ç»Ÿè®¡æ¯ä¸ªå€¼åœ¨ä¸åŒå¾ªç¯èŠ‚é•¿åº¦ä¸‹è¢«å–åˆ°çš„æ¦‚ç‡å’Œã€‚&lt;/p&gt;
&lt;p&gt;ç”¨åŸƒç­›è§£å†³æ¯ä¸ªæ•°çš„å› æ•°å’Œ &lt;span class=&#34;math inline&#34;&gt;\(p\)&lt;/span&gt; å€¼ï¼Œé‚£ä¹ˆæ­¤æ—¶å¤æ‚åº¦ç“¶é¢ˆåœ¨äº &lt;span class=&#34;math inline&#34;&gt;\(g(s_i, j)\)&lt;/span&gt; å’Œ &lt;span class=&#34;math inline&#34;&gt;\(\sum\limits_i\sum\limits_jg({s_i},j)\times g(t_i,j)\)&lt;/span&gt; çš„æ±‚è§£ã€‚å®¹æ˜“å‘ç°åªæœ‰æ¯ä¸ª &lt;span class=&#34;math inline&#34;&gt;\(g(s_i,j),j\mid |s_i|\)&lt;/span&gt; çš„å€¼æ˜¯æœ‰æ•ˆçš„ï¼ˆå…¶ä»–çš„å’Œå®ƒä»¬å€¼éƒ½ç›¸åŒï¼‰ï¼Œè€ƒè™‘åªæ±‚è§£å’Œåˆ©ç”¨è¿™äº›å€¼ï¼Œç±» &lt;code&gt;std::merge&lt;/code&gt;ï¼ˆå³å½’å¹¶æ’åºï¼‰åœ°æ±‚è§£ç­”æ¡ˆã€‚&lt;/p&gt;
&lt;p&gt;æ³¨æ„ç‰¹åˆ¤ &lt;span class=&#34;math inline&#34;&gt;\(n=1\)&lt;/span&gt;ã€‚ä¼šå¾—åˆ°é”™è¯¯ç­”æ¡ˆçš„åŸå› æ˜¯æ­¤æ—¶å­˜åœ¨ &lt;span class=&#34;math inline&#34;&gt;\(s_i=t_i\)&lt;/span&gt;ï¼Œä¸æ»¡è¶³åŸºæœ¬è¦æ±‚ã€‚&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int lim = 1e5;
const int mod = 998244353;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#endif
    int n;
    std::cin &amp;gt;&amp;gt; n;
    if (n == 1) &amp;#123;
        std::cout &amp;lt;&amp;lt; 1 &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
        return 0;
    &amp;#125;
    auto qkp = [](long long x, int y) &amp;#123;
        long long res = 1ll;
        for (; y; y &amp;gt;&amp;gt;= 1, (x *= x) %= mod)
            if (y &amp;amp; 1)
                (res *= x) %= mod;
        return res;
    &amp;#125;;
    auto inv = [&amp;amp;](int x) &amp;#123;
        return qkp(x, mod - 2);
    &amp;#125;;
    std::vector&amp;lt;long long&amp;gt; f(lim + 1);
    std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; fac(lim + 1);
    for (int i = 1; i &amp;lt;= lim; ++i) &amp;#123;
        static long long now = 26;
        (f[i] += now) %= mod;
        fac[i].push_back(i);
        for (int j = 2 * i; j &amp;lt;= lim; j += i)
            (f[j] += mod - f[i]) %= mod, fac[j].push_back(i);
        (now *= 26) %= mod;
    &amp;#125;
    for (int i = 1; i &amp;lt;= lim; ++i)
        (f[i] *= inv(i)) %= mod;
    std::vector&amp;lt;int&amp;gt; a(n + 1);
    struct _ &amp;#123; int l, r; long long f; &amp;#125;;
    std::vector&amp;lt;std::vector&amp;lt;_&amp;gt; &amp;gt; g(lim + 1);
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        std::cin &amp;gt;&amp;gt; a[i];
        if (g[a[i]].empty()) &amp;#123;
            g[a[i]].resize(fac[a[i]].size());
            for (int j = 0; j &amp;lt; (int)fac[a[i]].size(); ++j) &amp;#123;
                g[a[i]][j].l = (j ? g[a[i]][j - 1].r + 1 : 1);
                g[a[i]][j].r = fac[a[i]][j];
                (g[a[i]][0].f += f[fac[a[i]][j]]) %= mod;
                if (j != (int)fac[a[i]].size() - 1)
                    (g[a[i]][j + 1].f += mod - f[fac[a[i]][j]]) %= mod;
            &amp;#125;
            for (int j = 1; j &amp;lt; (int)fac[a[i]].size(); ++j)
                (g[a[i]][j].f += g[a[i]][j - 1].f) %= mod;
            int getinv = inv(qkp(26, a[i]));
            for (int j = 0; j &amp;lt; (int)fac[a[i]].size(); ++j)
                (g[a[i]][j].f *= getinv) %= mod;
        &amp;#125;
    &amp;#125;
    std::vector&amp;lt;int&amp;gt; b(n + 1);
    std::rotate_copy(a.begin() + 1, --a.end(), a.end(), b.begin() + 1);
    long long res = 0ll;
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        for (int j = 0, k = 0, now = 0;
            j &amp;lt; (int)fac[a[i]].size() &amp;amp;&amp;amp; k &amp;lt; (int)fac[b[i]].size(); )
            if (g[a[i]][j].r &amp;lt; g[b[i]][k].r) &amp;#123;
                (res += g[a[i]][j].f * g[b[i]][k].f % mod
                    * (g[a[i]][j].r - now) % mod) %= mod;
                now = g[a[i]][j].r, ++j;
            &amp;#125;
            else if (g[a[i]][j].r == g[b[i]][k].r) &amp;#123;
                (res += g[a[i]][j].f * g[b[i]][k].f % mod
                    * (g[a[i]][j].r - now) % mod) %= mod;
                now = g[a[i]][j].r, ++j, ++k;
            &amp;#125;
            else &amp;#123;
                (res += g[a[i]][j].f * g[b[i]][k].f % mod
                    * (g[b[i]][k].r - now) % mod) %= mod;
                now = g[b[i]][k].r, ++k;
            &amp;#125;
    &amp;#125;
    std::cout &amp;lt;&amp;lt; res &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;äºŒå‰æœç´¢æ ‘&#34;&gt;äºŒå‰æœç´¢æ ‘&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://pjudge.ac/contest/1914/problem/21889&#34; class=&#34;uri&#34;&gt;https://pjudge.ac/contest/1914/problem/21889&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;å½“æˆ‘ä»¬å¤„ç†é“¾çš„éƒ¨åˆ†åˆ†æ—¶ï¼Œå¾ˆå®¹æ˜“æƒ³åˆ°ç”¨å·®åˆ†è§£å†³é—®é¢˜ã€‚æŠŠæ›´æ–° &lt;span class=&#34;math inline&#34;&gt;\([l, r]\)&lt;/span&gt; çœ‹ä½œåœ¨å·®åˆ†æ•°ç»„ &lt;span class=&#34;math inline&#34;&gt;\(l\)&lt;/span&gt; å¤„æ’å…¥ï¼Œåœ¨ &lt;span class=&#34;math inline&#34;&gt;\(r+1\)&lt;/span&gt; å¤„åˆ é™¤ï¼Œç¦»çº¿ä¸‹æ¥å†ä»å·¦åˆ°å³æ‰«ä¸€éæ“ä½œï¼Œè€ƒè™‘å¦‚ä½•è§£å†³æŸ¥è¯¢é—®é¢˜ã€‚&lt;/p&gt;
&lt;p&gt;è€ƒè™‘å¦‚ä½•è·å– &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; æ ‘ä¸Š &lt;span class=&#34;math inline&#34;&gt;\(t_0\)&lt;/span&gt; æ—¶åˆ»ç‚¹ &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; çš„æ‰€æœ‰ç¥–å…ˆã€‚æ ¹æ®å‰é¢çš„æ“ä½œï¼Œæˆ‘ä»¬å¯ä»¥è·å– &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; æ ‘ä¸Šå­˜åœ¨è¿‡çš„æ‰€æœ‰å…ƒç´ ã€‚&lt;/p&gt;
&lt;p&gt;å¯¹äºæ¯” &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; å¤§çš„å…ƒç´ ï¼Œè€ƒè™‘ç¥–å…ˆ &lt;span class=&#34;math inline&#34;&gt;\(p_a\)&lt;/span&gt; å’Œéç¥–å…ˆ &lt;span class=&#34;math inline&#34;&gt;\(p\)&lt;/span&gt; æœ‰ä»€ä¹ˆåŒºåˆ«ã€‚æ ¹æ® BST çš„æ€§è´¨æ˜“å¾—ï¼Œå¯¹äºæœ€ä½çš„å³ä¾§ç¥–å…ˆ &lt;span class=&#34;math inline&#34;&gt;\({p_a}_0\)&lt;/span&gt;ï¼Œå…¶æ˜¯ &lt;span class=&#34;math inline&#34;&gt;\(\ge x\)&lt;/span&gt; çš„æœ€å°çš„å…ƒç´ ï¼ˆå½“ç„¶å…¶åŠ å…¥æ—¶åˆ» &lt;span class=&#34;math inline&#34;&gt;\(t_a&amp;lt;t_0\)&lt;/span&gt;ï¼‰ï¼›é‚£ä¹ˆåŒç†å¯ä»¥æ‰¾åˆ° &lt;span class=&#34;math inline&#34;&gt;\({p_a}_0\)&lt;/span&gt; å³ä¾§æœ€ä½çš„ç¥–å…ˆï¼ˆå…¶å·¦ä¾§çš„ç¥–å…ˆæ˜¾ç„¶ä¹Ÿ &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; å·¦ä¾§ï¼‰ï¼Œè¯¥ç¥–å…ˆæ»¡è¶³ &lt;span class=&#34;math inline&#34;&gt;\(t&amp;lt;t_a\)&lt;/span&gt;ã€‚é‚£ä¹ˆæˆ‘ä»¬å°±ä»å·¦å³ä¸¤è¾¹åˆ†åˆ«å¾—åˆ° &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; çš„æ‰€æœ‰ç¥–å…ˆã€‚å®¹æ˜“è¯æ˜è¯¥è¿‡ç¨‹å¯¹äºä¸åœ¨æ ‘ä¸Šçš„ &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; ä¹Ÿæ˜¯æ­£ç¡®çš„ã€‚&lt;/p&gt;
&lt;p&gt;å…·ä½“åœ°ï¼Œæˆ‘ä»¬éœ€è¦ä¸€ä¸ªæ•°æ®ç»“æ„ï¼Œèƒ½å¤Ÿæ±‚å‡º &lt;span class=&#34;math inline&#34;&gt;\(\ge x\)&lt;/span&gt; çš„å…ƒç´ ä¸­ï¼Œä»¥ &lt;span class=&#34;math inline&#34;&gt;\(t_0\)&lt;/span&gt; ä¸ºèµ·ç‚¹çš„å‰ç¼€æœ€å°å€¼åºåˆ—çš„åŒºé—´å’Œã€‚&lt;/p&gt;
&lt;p&gt;æ¬¸ â˜ğŸ¤“ è¿™æ˜¯ä»€ä¹ˆï¼Ÿ&lt;a href=&#34;/20250217&#34;&gt;æ¥¼æˆ¿é‡å»º&lt;/a&gt;ï¼ç§’ä¸€ä¸‹ï¼&lt;/p&gt;
&lt;p&gt;è¿›ä¸€æ­¥åœ°ï¼Œæœ¬é¢˜éœ€è¦å®Œæˆå¯¹äº &lt;span class=&#34;math inline&#34;&gt;\(t_0\)&lt;/span&gt; ä¸ºåºåˆ—å¤´çš„æŸ¥è¯¢ã€‚å†æ¬¡åˆ©ç”¨æ€§è´¨ï¼Œæ¯æ¬¡ &lt;span class=&#34;math inline&#34;&gt;\(O(\log V)\)&lt;/span&gt; åœ°åˆå¹¶ç­”æ¡ˆã€‚&lt;/p&gt;
&lt;p&gt;å¥½çš„é‚£ä¹ˆæ€ä¹ˆæŠŠé“¾æåˆ°æ ‘ä¸Šå‘¢ï¼ŸæŠŠå·®åˆ†æ”¾åˆ°æ ‘ä¸Šï¼Œå†™ä¸ªçº¿æ®µæ ‘åˆå¹¶å³å¯ã€‚&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;æ³¨æ„ç”±äºè¿™é¢˜ç»†èŠ‚å¤ªå¤šäº†ï¼Œæ‰€ä»¥ä½ å¯èƒ½éœ€è¦èˆå¼ƒä¸å¿…è¦çš„æ—¶ç©ºä¼˜åŒ–æ¢å–ä»£ç ç®€æ´åº¦ä»¥æ–¹ä¾¿è°ƒè¯•ã€‚&lt;/strong&gt;&lt;/p&gt;
&lt;details&gt;
&lt;pre data-line=&#34;12&#34; class=&#34;cpp language-cpp&#34;&gt;&lt;code data-line=&#34;12&#34; class=&#34;cpp language-cpp&#34;&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int lim = 2e5;
const int maxn = 2e7 + 5;
const int inf = 0x3f3f3f3f;
struct &amp;#123;
    int l, r, rv;
    long long u;
&amp;#125; t[maxn];
std::vector&amp;lt;int&gt; tr;
#define lt t[p].l
#define rt t[p].r
int newnode(void) &amp;#123;         // æˆ‘çŸ¥é“ä½ è¦è¯´ä»€ä¹ˆï¼Œä½†è¿™å±äºã€Œå¿…è¦çš„ã€ç©ºé—´ä¼˜åŒ– ğŸ˜¥
    static int tot = 0;
    if (tr.empty())
        return ++tot;
    auto p(tr.back());
    t[p].l = t[p].r = 0;
    tr.pop_back();
    return p;
&amp;#125;
long long askv(int p, int l, int r, int v) &amp;#123;
    if (l == r)
        return t[p].rv &lt; v ? t[p].u : 0;
    int mid = (l + r) &gt;&gt; 1;
    if (v &gt; t[lt].rv)
        return t[p].u - t[lt].u + askv(lt, l, mid, v);
    return askv(rt, mid + 1, r, v);
&amp;#125;
void pushup(int p, int l, int r) &amp;#123;
    t[p].rv = std::min(t[lt].rv, t[rt].rv);
    int mid = (l + r) &gt;&gt; 1;
    t[p].u = t[lt].u + askv(rt, mid + 1, r, t[lt].rv);
    return;
&amp;#125;
void upd(int &amp;p, int l, int r, int x, int v, int u) &amp;#123;
    if (!p)
        p = newnode();
    if (l == r) &amp;#123;
        t[p].rv = v, t[p].u = u;
        return;
    &amp;#125;
    int mid = (l + r) &gt;&gt; 1;
    if (x &lt;= mid)
        upd(lt, l, mid, x, v, u);
    else
        upd(rt, mid + 1, r, x, v, u);
    pushup(p, l, r);
    return;
&amp;#125;
void merge(int &amp;p, int q, int l, int r) &amp;#123;
    if (!p || !q) &amp;#123;
        p += q;
        return;
    &amp;#125;
    if (l == r) &amp;#123;
        t[p].rv = std::min(t[p].rv, t[q].rv);
        t[p].u = std::max(t[p].u, t[q].u);
        return;
    &amp;#125;
    int mid = (l + r) &gt;&gt; 1;
    merge(t[p].l, t[q].l, l, mid), merge(t[p].r, t[q].r, mid + 1, r);
    pushup(p, l, r), tr.push_back(q);
    return;
&amp;#125;
int qv = inf;
long long ask(int p, int l, int r, int ql, int qr) &amp;#123;
    if (ql &lt;= l &amp;&amp; r &lt;= qr) &amp;#123;
        auto s(askv(p, l, r, qv));
        qv = std::min(qv, t[p].rv);
        return s;
    &amp;#125;
    int mid = (l + r) &gt;&gt; 1;
    long long res = 0ll;
    if (ql &lt;= mid)
        res = ask(lt, l, mid, ql, qr);
    if (qr &gt; mid)
        res += ask(rt, mid + 1, r, ql, qr);
    return res;
&amp;#125;
#undef lt
#undef rt
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&#34;ex_problem4.in&#34;, &#34;r&#34;, stdin);
    std::freopen(&#34;.out&#34;, &#34;w&#34;, stdout);
#endif
    int n, m;
    std::cin &gt;&gt; n &gt;&gt; m;
    std::vector&amp;lt;std::vector&amp;lt;int&gt; &gt; g(n + 1);
    for (int i = 1, x, y; i &lt; n; ++i) &amp;#123;
        std::cin &gt;&gt; x &gt;&gt; y;
        g[x].push_back(y), g[y].push_back(x);
    &amp;#125;
    std::vector&amp;lt;int&gt; top(n + 1), fa(n + 1), siz(n + 1), son(n + 1), dep(n + 1);
    std::function&amp;lt;void(int, int)&gt; DFS = [&amp;](int x, int faa) &amp;#123;
        siz[x] = 1;
        for (auto i : g[x])
            if (i != faa) &amp;#123;
                fa[i] = x, dep[i] = dep[x] + 1;
                DFS(i, x), siz[x] += siz[i];
                if (siz[i] &gt; siz[son[x]])
                    son[x] = i;
            &amp;#125;
        return;
    &amp;#125;;
    DFS(1, -1);
    DFS = [&amp;](int x, int topp) &amp;#123;
        top[x] = topp;
        if (son[x])
            DFS(son[x], topp);
        for (auto i : g[x])
            if (i != fa[x] &amp;&amp; i != son[x])
                DFS(i, i);
        return;
    &amp;#125;;
    DFS(1, 1);
    auto getLCA = [&amp;](int x, int y) &amp;#123;
        for (; top[x] != top[y]; x = fa[top[x]])
            if (dep[top[y]] &gt; dep[top[x]])
                std::swap(x, y);
        return (dep[x] &lt; dep[y] ? x : y);
    &amp;#125;;
    std::vector&amp;lt;std::vector&amp;lt;int&gt; &gt; d(n + 1);
    std::vector&amp;lt;std::vector&amp;lt;std::pair&amp;lt;int, int&gt; &gt; &gt; u(n + 1);
    std::vector&amp;lt;std::vector&amp;lt;std::tuple&amp;lt;int, int, int&gt; &gt; &gt; q(n + 1);
    int cnt = 0;
    for (int i = 1; i &lt;= m; ++i) &amp;#123;
        int op;
        std::cin &gt;&gt; op;
        if (op == 0) &amp;#123;
            int x, v;
            std::cin &gt;&gt; x &gt;&gt; v;
            q[x].emplace_back(++cnt, i, v);
        &amp;#125; else &amp;#123;
            int x, y, v;
            std::cin &gt;&gt; x &gt;&gt; y &gt;&gt; v;
            int faa = getLCA(x, y);
            u[x].emplace_back(i, v), u[y].emplace_back(i, v);
            if (fa[faa])
                d[fa[faa]].emplace_back(v);
        &amp;#125;
    &amp;#125;
    std::vector&amp;lt;long long&gt; res(cnt + 1);
    std::vector&amp;lt;std::vector&amp;lt;int&gt; &gt; rt(2, std::vector&amp;lt;int&gt; (n + 1));
    t[0].rv = inf;
    DFS = [&amp;](int x, int fa) &amp;#123;
        for (auto i : g[x])
            if (i != fa) &amp;#123;
                DFS(i, x);
                merge(rt[0][x], rt[0][i], 1, lim);
                merge(rt[1][x], rt[1][i], 1, lim);
            &amp;#125;
        for (auto [t, v] : u[x]) &amp;#123;
            upd(rt[0][x], 1, lim, v, t, v);
            upd(rt[1][x], 1, lim, lim - v + 1, t, v);
        &amp;#125;
        for (auto v : d[x]) &amp;#123;
            upd(rt[0][x], 1, lim, v, inf, 0);
            upd(rt[1][x], 1, lim, lim - v + 1, inf, 0);
        &amp;#125;
        for (auto [id, t, v] : q[x]) &amp;#123;
            qv = t, res[id] = ask(rt[0][x], 1, lim, v, lim);
            qv = t, res[id] += ask(rt[1][x], 1, lim, lim - v + 1, lim);
            qv = t, res[id] -= ask(rt[0][x], 1, lim, v, v);
        &amp;#125;
    &amp;#125;;
    DFS(1, -1);
    for (int i = 1; i &lt;= cnt; ++i)
        std::cout &lt;&lt; res[i] &lt;&lt; &#39;\n&#39;;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
</content>
        <category term="çº¿æ®µæ ‘" />
        <category term="æ•°å­¦" />
        <category term="æ ‘ä¸Šå·®åˆ†" />
        <updated>2025-02-16T11:44:38.000Z</updated>
    </entry>
</feed>
