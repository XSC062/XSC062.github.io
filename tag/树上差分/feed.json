{
    "version": "https://jsonfeed.org/version/1",
    "title": "null • All posts by \"树上差分\" tag",
    "description": "",
    "home_page_url": "https://xsc062.netlify.app",
    "items": [
        {
            "id": "https://xsc062.netlify.app/20250216/",
            "url": "https://xsc062.netlify.app/20250216/",
            "title": "Public Round 15 前两题",
            "date_published": "2025-02-16T11:44:38.000Z",
            "content_html": "<p><a href=\"https://pjudge.ac/contest/1914\">PR #15</a> 前两题题解。</p>\n<span id=\"more\"></span>\n<hr />\n<h2 id=\"最小表示法\">最小表示法</h2>\n<p><a href=\"https://pjudge.ac/contest/1914/problem/21888\" class=\"uri\">https://pjudge.ac/contest/1914/problem/21888</a></p>\n<p>首先不妨假设每个 <span class=\"math inline\">\\(f\\)</span> 在值域内等概率取值以简化问题。那么手玩一下可以轻松地得到规律：不妨将 <span class=\"math inline\">\\(\\{s\\}\\)</span> 循环右移一位的结果记为 <span class=\"math inline\">\\(\\{t\\}\\)</span>，那么 <span class=\"math inline\">\\(res=\\sum\\frac 1{\\max(|s_i|,|t_i|)}\\)</span>。</p>\n<p>这看起来令人疑惑：对于不同的 <span class=\"math inline\">\\(i\\)</span>，<span class=\"math inline\">\\([f(s_i)=f(t_i)]\\)</span> 的期望似乎是彼此独立的，十分奇怪。这其实与表达式的来源有关，记 <span class=\"math inline\">\\(g(s_i, j)\\)</span> 表示 <span class=\"math inline\">\\(f(s_i)=j\\)</span> 的概率，那么上述等式可以转写为 <span class=\"math inline\">\\(res=\\sum\\limits_i\\sum\\limits_jg({s_i},j)\\times g(t_i,j)\\)</span>。</p>\n<p>那么将最小表示法带来的偏差纳入考虑范围，我们发现 <span class=\"math inline\">\\(g(s,j)\\)</span> 对于不同的 <span class=\"math inline\">\\(j\\)</span> 并不永远相等。具体地，当 <span class=\"math inline\">\\(s\\)</span> 具有循环节时，最小循环节的第一处结尾会享有更大的取得概率。</p>\n<p>枚举 <span class=\"math inline\">\\(s_i\\)</span> 的因数作为最小循环节长度的情况，显然，对于最小循环节为 <span class=\"math inline\">\\(j\\)</span> 的情况（该情况出现的概率，容斥得到 <span class=\"math inline\">\\(p_j=26^j-\\sum_{k\\mid j}p_k\\)</span>），<span class=\"math inline\">\\(f(s_i)\\)</span> 的取值在 <span class=\"math inline\">\\(1\\sim j\\)</span> 上等概率分布，差分即可统计每个值在不同循环节长度下被取到的概率和。</p>\n<p>用埃筛解决每个数的因数和 <span class=\"math inline\">\\(p\\)</span> 值，那么此时复杂度瓶颈在于 <span class=\"math inline\">\\(g(s_i, j)\\)</span> 和 <span class=\"math inline\">\\(\\sum\\limits_i\\sum\\limits_jg({s_i},j)\\times g(t_i,j)\\)</span> 的求解。容易发现只有每个 <span class=\"math inline\">\\(g(s_i,j),j\\mid |s_i|\\)</span> 的值是有效的（其他的和它们值都相同），考虑只求解和利用这些值，类 <code>std::merge</code>（即归并排序）地求解答案。</p>\n<p>注意特判 <span class=\"math inline\">\\(n=1\\)</span>。会得到错误答案的原因是此时存在 <span class=\"math inline\">\\(s_i=t_i\\)</span>，不满足基本要求。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int lim = 1e5;\nconst int mod = 998244353;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    if (n == 1) &#123;\n        std::cout &lt;&lt; 1 &lt;&lt; &#39;\\n&#39;;\n        return 0;\n    &#125;\n    auto qkp = [](long long x, int y) &#123;\n        long long res = 1ll;\n        for (; y; y &gt;&gt;= 1, (x *= x) %= mod)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    auto inv = [&amp;](int x) &#123;\n        return qkp(x, mod - 2);\n    &#125;;\n    std::vector&lt;long long&gt; f(lim + 1);\n    std::vector&lt;std::vector&lt;int&gt; &gt; fac(lim + 1);\n    for (int i = 1; i &lt;= lim; ++i) &#123;\n        static long long now = 26;\n        (f[i] += now) %= mod;\n        fac[i].push_back(i);\n        for (int j = 2 * i; j &lt;= lim; j += i)\n            (f[j] += mod - f[i]) %= mod, fac[j].push_back(i);\n        (now *= 26) %= mod;\n    &#125;\n    for (int i = 1; i &lt;= lim; ++i)\n        (f[i] *= inv(i)) %= mod;\n    std::vector&lt;int&gt; a(n + 1);\n    struct _ &#123; int l, r; long long f; &#125;;\n    std::vector&lt;std::vector&lt;_&gt; &gt; g(lim + 1);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; a[i];\n        if (g[a[i]].empty()) &#123;\n            g[a[i]].resize(fac[a[i]].size());\n            for (int j = 0; j &lt; (int)fac[a[i]].size(); ++j) &#123;\n                g[a[i]][j].l = (j ? g[a[i]][j - 1].r + 1 : 1);\n                g[a[i]][j].r = fac[a[i]][j];\n                (g[a[i]][0].f += f[fac[a[i]][j]]) %= mod;\n                if (j != (int)fac[a[i]].size() - 1)\n                    (g[a[i]][j + 1].f += mod - f[fac[a[i]][j]]) %= mod;\n            &#125;\n            for (int j = 1; j &lt; (int)fac[a[i]].size(); ++j)\n                (g[a[i]][j].f += g[a[i]][j - 1].f) %= mod;\n            int getinv = inv(qkp(26, a[i]));\n            for (int j = 0; j &lt; (int)fac[a[i]].size(); ++j)\n                (g[a[i]][j].f *= getinv) %= mod;\n        &#125;\n    &#125;\n    std::vector&lt;int&gt; b(n + 1);\n    std::rotate_copy(a.begin() + 1, --a.end(), a.end(), b.begin() + 1);\n    long long res = 0ll;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        for (int j = 0, k = 0, now = 0;\n            j &lt; (int)fac[a[i]].size() &amp;&amp; k &lt; (int)fac[b[i]].size(); )\n            if (g[a[i]][j].r &lt; g[b[i]][k].r) &#123;\n                (res += g[a[i]][j].f * g[b[i]][k].f % mod\n                    * (g[a[i]][j].r - now) % mod) %= mod;\n                now = g[a[i]][j].r, ++j;\n            &#125;\n            else if (g[a[i]][j].r == g[b[i]][k].r) &#123;\n                (res += g[a[i]][j].f * g[b[i]][k].f % mod\n                    * (g[a[i]][j].r - now) % mod) %= mod;\n                now = g[a[i]][j].r, ++j, ++k;\n            &#125;\n            else &#123;\n                (res += g[a[i]][j].f * g[b[i]][k].f % mod\n                    * (g[b[i]][k].r - now) % mod) %= mod;\n                now = g[b[i]][k].r, ++k;\n            &#125;\n    &#125;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"二叉搜索树\">二叉搜索树</h2>\n<p><a href=\"https://pjudge.ac/contest/1914/problem/21889\" class=\"uri\">https://pjudge.ac/contest/1914/problem/21889</a></p>\n<p>当我们处理链的部分分时，很容易想到用差分解决问题。把更新 <span class=\"math inline\">\\([l, r]\\)</span> 看作在差分数组 <span class=\"math inline\">\\(l\\)</span> 处插入，在 <span class=\"math inline\">\\(r+1\\)</span> 处删除，离线下来再从左到右扫一遍操作，考虑如何解决查询问题。</p>\n<p>考虑如何获取 <span class=\"math inline\">\\(i\\)</span> 树上 <span class=\"math inline\">\\(t_0\\)</span> 时刻点 <span class=\"math inline\">\\(x\\)</span> 的所有祖先。根据前面的操作，我们可以获取 <span class=\"math inline\">\\(i\\)</span> 树上存在过的所有元素。</p>\n<p>对于比 <span class=\"math inline\">\\(x\\)</span> 大的元素，考虑祖先 <span class=\"math inline\">\\(p_a\\)</span> 和非祖先 <span class=\"math inline\">\\(p\\)</span> 有什么区别。根据 BST 的性质易得，对于最低的右侧祖先 <span class=\"math inline\">\\({p_a}_0\\)</span>，其是 <span class=\"math inline\">\\(\\ge x\\)</span> 的最小的元素（当然其加入时刻 <span class=\"math inline\">\\(t_a&lt;t_0\\)</span>）；那么同理可以找到 <span class=\"math inline\">\\({p_a}_0\\)</span> 右侧最低的祖先（其左侧的祖先显然也 <span class=\"math inline\">\\(x\\)</span> 左侧），该祖先满足 <span class=\"math inline\">\\(t&lt;t_a\\)</span>。那么我们就从左右两边分别得到 <span class=\"math inline\">\\(x\\)</span> 的所有祖先。容易证明该过程对于不在树上的 <span class=\"math inline\">\\(x\\)</span> 也是正确的。</p>\n<p>具体地，我们需要一个数据结构，能够求出 <span class=\"math inline\">\\(\\ge x\\)</span> 的元素中，以 <span class=\"math inline\">\\(t_0\\)</span> 为起点的前缀最小值序列的区间和。</p>\n<p>欸 ☝🤓 这是什么？<a href=\"/20250217\">楼房重建</a>！秒一下！</p>\n<p>进一步地，本题需要完成对于 <span class=\"math inline\">\\(t_0\\)</span> 为序列头的查询。再次利用性质，每次 <span class=\"math inline\">\\(O(\\log V)\\)</span> 地合并答案。</p>\n<p>好的那么怎么把链搞到树上呢？把差分放到树上，写个线段树合并即可。</p>\n<p><strong>注意由于这题细节太多了，所以你可能需要舍弃不必要的时空优化换取代码简洁度以方便调试。</strong></p>\n<details>\n<pre data-line=\"12\" class=\"cpp language-cpp\"><code data-line=\"12\" class=\"cpp language-cpp\">#include &lt;bits/stdc++.h&gt;\nconst int lim = 2e5;\nconst int maxn = 2e7 + 5;\nconst int inf = 0x3f3f3f3f;\nstruct &#123;\n    int l, r, rv;\n    long long u;\n&#125; t[maxn];\nstd::vector&lt;int> tr;\n#define lt t[p].l\n#define rt t[p].r\nint newnode(void) &#123;         // 我知道你要说什么，但这属于「必要的」空间优化 😥\n    static int tot = 0;\n    if (tr.empty())\n        return ++tot;\n    auto p(tr.back());\n    t[p].l = t[p].r = 0;\n    tr.pop_back();\n    return p;\n&#125;\nlong long askv(int p, int l, int r, int v) &#123;\n    if (l == r)\n        return t[p].rv < v ? t[p].u : 0;\n    int mid = (l + r) >> 1;\n    if (v > t[lt].rv)\n        return t[p].u - t[lt].u + askv(lt, l, mid, v);\n    return askv(rt, mid + 1, r, v);\n&#125;\nvoid pushup(int p, int l, int r) &#123;\n    t[p].rv = std::min(t[lt].rv, t[rt].rv);\n    int mid = (l + r) >> 1;\n    t[p].u = t[lt].u + askv(rt, mid + 1, r, t[lt].rv);\n    return;\n&#125;\nvoid upd(int &p, int l, int r, int x, int v, int u) &#123;\n    if (!p)\n        p = newnode();\n    if (l == r) &#123;\n        t[p].rv = v, t[p].u = u;\n        return;\n    &#125;\n    int mid = (l + r) >> 1;\n    if (x <= mid)\n        upd(lt, l, mid, x, v, u);\n    else\n        upd(rt, mid + 1, r, x, v, u);\n    pushup(p, l, r);\n    return;\n&#125;\nvoid merge(int &p, int q, int l, int r) &#123;\n    if (!p || !q) &#123;\n        p += q;\n        return;\n    &#125;\n    if (l == r) &#123;\n        t[p].rv = std::min(t[p].rv, t[q].rv);\n        t[p].u = std::max(t[p].u, t[q].u);\n        return;\n    &#125;\n    int mid = (l + r) >> 1;\n    merge(t[p].l, t[q].l, l, mid), merge(t[p].r, t[q].r, mid + 1, r);\n    pushup(p, l, r), tr.push_back(q);\n    return;\n&#125;\nint qv = inf;\nlong long ask(int p, int l, int r, int ql, int qr) &#123;\n    if (ql <= l && r <= qr) &#123;\n        auto s(askv(p, l, r, qv));\n        qv = std::min(qv, t[p].rv);\n        return s;\n    &#125;\n    int mid = (l + r) >> 1;\n    long long res = 0ll;\n    if (ql <= mid)\n        res = ask(lt, l, mid, ql, qr);\n    if (qr > mid)\n        res += ask(rt, mid + 1, r, ql, qr);\n    return res;\n&#125;\n#undef lt\n#undef rt\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(\"ex_problem4.in\", \"r\", stdin);\n    std::freopen(\".out\", \"w\", stdout);\n#endif\n    int n, m;\n    std::cin >> n >> m;\n    std::vector&lt;std::vector&lt;int> > g(n + 1);\n    for (int i = 1, x, y; i < n; ++i) &#123;\n        std::cin >> x >> y;\n        g[x].push_back(y), g[y].push_back(x);\n    &#125;\n    std::vector&lt;int> top(n + 1), fa(n + 1), siz(n + 1), son(n + 1), dep(n + 1);\n    std::function&lt;void(int, int)> DFS = [&](int x, int faa) &#123;\n        siz[x] = 1;\n        for (auto i : g[x])\n            if (i != faa) &#123;\n                fa[i] = x, dep[i] = dep[x] + 1;\n                DFS(i, x), siz[x] += siz[i];\n                if (siz[i] > siz[son[x]])\n                    son[x] = i;\n            &#125;\n        return;\n    &#125;;\n    DFS(1, -1);\n    DFS = [&](int x, int topp) &#123;\n        top[x] = topp;\n        if (son[x])\n            DFS(son[x], topp);\n        for (auto i : g[x])\n            if (i != fa[x] && i != son[x])\n                DFS(i, i);\n        return;\n    &#125;;\n    DFS(1, 1);\n    auto getLCA = [&](int x, int y) &#123;\n        for (; top[x] != top[y]; x = fa[top[x]])\n            if (dep[top[y]] > dep[top[x]])\n                std::swap(x, y);\n        return (dep[x] < dep[y] ? x : y);\n    &#125;;\n    std::vector&lt;std::vector&lt;int> > d(n + 1);\n    std::vector&lt;std::vector&lt;std::pair&lt;int, int> > > u(n + 1);\n    std::vector&lt;std::vector&lt;std::tuple&lt;int, int, int> > > q(n + 1);\n    int cnt = 0;\n    for (int i = 1; i <= m; ++i) &#123;\n        int op;\n        std::cin >> op;\n        if (op == 0) &#123;\n            int x, v;\n            std::cin >> x >> v;\n            q[x].emplace_back(++cnt, i, v);\n        &#125; else &#123;\n            int x, y, v;\n            std::cin >> x >> y >> v;\n            int faa = getLCA(x, y);\n            u[x].emplace_back(i, v), u[y].emplace_back(i, v);\n            if (fa[faa])\n                d[fa[faa]].emplace_back(v);\n        &#125;\n    &#125;\n    std::vector&lt;long long> res(cnt + 1);\n    std::vector&lt;std::vector&lt;int> > rt(2, std::vector&lt;int> (n + 1));\n    t[0].rv = inf;\n    DFS = [&](int x, int fa) &#123;\n        for (auto i : g[x])\n            if (i != fa) &#123;\n                DFS(i, x);\n                merge(rt[0][x], rt[0][i], 1, lim);\n                merge(rt[1][x], rt[1][i], 1, lim);\n            &#125;\n        for (auto [t, v] : u[x]) &#123;\n            upd(rt[0][x], 1, lim, v, t, v);\n            upd(rt[1][x], 1, lim, lim - v + 1, t, v);\n        &#125;\n        for (auto v : d[x]) &#123;\n            upd(rt[0][x], 1, lim, v, inf, 0);\n            upd(rt[1][x], 1, lim, lim - v + 1, inf, 0);\n        &#125;\n        for (auto [id, t, v] : q[x]) &#123;\n            qv = t, res[id] = ask(rt[0][x], 1, lim, v, lim);\n            qv = t, res[id] += ask(rt[1][x], 1, lim, lim - v + 1, lim);\n            qv = t, res[id] -= ask(rt[0][x], 1, lim, v, v);\n        &#125;\n    &#125;;\n    DFS(1, -1);\n    for (int i = 1; i <= cnt; ++i)\n        std::cout << res[i] << '\\n';\n    return 0;\n&#125;</code></pre>\n</details>\n",
            "tags": [
                "线段树",
                "数学",
                "树上差分"
            ]
        }
    ]
}