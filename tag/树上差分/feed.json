{
    "version": "https://jsonfeed.org/version/1",
    "title": "null â€¢ All posts by \"æ ‘ä¸Šå·®åˆ†\" tag",
    "description": "",
    "home_page_url": "https://xsc062.netlify.app",
    "items": [
        {
            "id": "https://xsc062.netlify.app/20250216/",
            "url": "https://xsc062.netlify.app/20250216/",
            "title": "Public Round 15 å‰ä¸¤é¢˜",
            "date_published": "2025-02-16T11:44:38.000Z",
            "content_html": "<p><a href=\"https://pjudge.ac/contest/1914\">PR #15</a> å‰ä¸¤é¢˜é¢˜è§£ã€‚</p>\n<span id=\"more\"></span>\n<hr />\n<h2 id=\"æœ€å°è¡¨ç¤ºæ³•\">æœ€å°è¡¨ç¤ºæ³•</h2>\n<p><a href=\"https://pjudge.ac/contest/1914/problem/21888\" class=\"uri\">https://pjudge.ac/contest/1914/problem/21888</a></p>\n<p>é¦–å…ˆä¸å¦¨å‡è®¾æ¯ä¸ª <span class=\"math inline\">\\(f\\)</span> åœ¨å€¼åŸŸå†…ç­‰æ¦‚ç‡å–å€¼ä»¥ç®€åŒ–é—®é¢˜ã€‚é‚£ä¹ˆæ‰‹ç©ä¸€ä¸‹å¯ä»¥è½»æ¾åœ°å¾—åˆ°è§„å¾‹ï¼šä¸å¦¨å°† <span class=\"math inline\">\\(\\{s\\}\\)</span> å¾ªç¯å³ç§»ä¸€ä½çš„ç»“æœè®°ä¸º <span class=\"math inline\">\\(\\{t\\}\\)</span>ï¼Œé‚£ä¹ˆ <span class=\"math inline\">\\(res=\\sum\\frac 1{\\max(|s_i|,|t_i|)}\\)</span>ã€‚</p>\n<p>è¿™çœ‹èµ·æ¥ä»¤äººç–‘æƒ‘ï¼šå¯¹äºä¸åŒçš„ <span class=\"math inline\">\\(i\\)</span>ï¼Œ<span class=\"math inline\">\\([f(s_i)=f(t_i)]\\)</span> çš„æœŸæœ›ä¼¼ä¹æ˜¯å½¼æ­¤ç‹¬ç«‹çš„ï¼Œååˆ†å¥‡æ€ªã€‚è¿™å…¶å®ä¸è¡¨è¾¾å¼çš„æ¥æºæœ‰å…³ï¼Œè®° <span class=\"math inline\">\\(g(s_i, j)\\)</span> è¡¨ç¤º <span class=\"math inline\">\\(f(s_i)=j\\)</span> çš„æ¦‚ç‡ï¼Œé‚£ä¹ˆä¸Šè¿°ç­‰å¼å¯ä»¥è½¬å†™ä¸º <span class=\"math inline\">\\(res=\\sum\\limits_i\\sum\\limits_jg({s_i},j)\\times g(t_i,j)\\)</span>ã€‚</p>\n<p>é‚£ä¹ˆå°†æœ€å°è¡¨ç¤ºæ³•å¸¦æ¥çš„åå·®çº³å…¥è€ƒè™‘èŒƒå›´ï¼Œæˆ‘ä»¬å‘ç° <span class=\"math inline\">\\(g(s,j)\\)</span> å¯¹äºä¸åŒçš„ <span class=\"math inline\">\\(j\\)</span> å¹¶ä¸æ°¸è¿œç›¸ç­‰ã€‚å…·ä½“åœ°ï¼Œå½“ <span class=\"math inline\">\\(s\\)</span> å…·æœ‰å¾ªç¯èŠ‚æ—¶ï¼Œæœ€å°å¾ªç¯èŠ‚çš„ç¬¬ä¸€å¤„ç»“å°¾ä¼šäº«æœ‰æ›´å¤§çš„å–å¾—æ¦‚ç‡ã€‚</p>\n<p>æšä¸¾ <span class=\"math inline\">\\(s_i\\)</span> çš„å› æ•°ä½œä¸ºæœ€å°å¾ªç¯èŠ‚é•¿åº¦çš„æƒ…å†µï¼Œæ˜¾ç„¶ï¼Œå¯¹äºæœ€å°å¾ªç¯èŠ‚ä¸º <span class=\"math inline\">\\(j\\)</span> çš„æƒ…å†µï¼ˆè¯¥æƒ…å†µå‡ºç°çš„æ¦‚ç‡ï¼Œå®¹æ–¥å¾—åˆ° <span class=\"math inline\">\\(p_j=26^j-\\sum_{k\\mid j}p_k\\)</span>ï¼‰ï¼Œ<span class=\"math inline\">\\(f(s_i)\\)</span> çš„å–å€¼åœ¨ <span class=\"math inline\">\\(1\\sim j\\)</span> ä¸Šç­‰æ¦‚ç‡åˆ†å¸ƒï¼Œå·®åˆ†å³å¯ç»Ÿè®¡æ¯ä¸ªå€¼åœ¨ä¸åŒå¾ªç¯èŠ‚é•¿åº¦ä¸‹è¢«å–åˆ°çš„æ¦‚ç‡å’Œã€‚</p>\n<p>ç”¨åŸƒç­›è§£å†³æ¯ä¸ªæ•°çš„å› æ•°å’Œ <span class=\"math inline\">\\(p\\)</span> å€¼ï¼Œé‚£ä¹ˆæ­¤æ—¶å¤æ‚åº¦ç“¶é¢ˆåœ¨äº <span class=\"math inline\">\\(g(s_i, j)\\)</span> å’Œ <span class=\"math inline\">\\(\\sum\\limits_i\\sum\\limits_jg({s_i},j)\\times g(t_i,j)\\)</span> çš„æ±‚è§£ã€‚å®¹æ˜“å‘ç°åªæœ‰æ¯ä¸ª <span class=\"math inline\">\\(g(s_i,j),j\\mid |s_i|\\)</span> çš„å€¼æ˜¯æœ‰æ•ˆçš„ï¼ˆå…¶ä»–çš„å’Œå®ƒä»¬å€¼éƒ½ç›¸åŒï¼‰ï¼Œè€ƒè™‘åªæ±‚è§£å’Œåˆ©ç”¨è¿™äº›å€¼ï¼Œç±» <code>std::merge</code>ï¼ˆå³å½’å¹¶æ’åºï¼‰åœ°æ±‚è§£ç­”æ¡ˆã€‚</p>\n<p>æ³¨æ„ç‰¹åˆ¤ <span class=\"math inline\">\\(n=1\\)</span>ã€‚ä¼šå¾—åˆ°é”™è¯¯ç­”æ¡ˆçš„åŸå› æ˜¯æ­¤æ—¶å­˜åœ¨ <span class=\"math inline\">\\(s_i=t_i\\)</span>ï¼Œä¸æ»¡è¶³åŸºæœ¬è¦æ±‚ã€‚</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int lim = 1e5;\nconst int mod = 998244353;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    if (n == 1) &#123;\n        std::cout &lt;&lt; 1 &lt;&lt; &#39;\\n&#39;;\n        return 0;\n    &#125;\n    auto qkp = [](long long x, int y) &#123;\n        long long res = 1ll;\n        for (; y; y &gt;&gt;= 1, (x *= x) %= mod)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    auto inv = [&amp;](int x) &#123;\n        return qkp(x, mod - 2);\n    &#125;;\n    std::vector&lt;long long&gt; f(lim + 1);\n    std::vector&lt;std::vector&lt;int&gt; &gt; fac(lim + 1);\n    for (int i = 1; i &lt;= lim; ++i) &#123;\n        static long long now = 26;\n        (f[i] += now) %= mod;\n        fac[i].push_back(i);\n        for (int j = 2 * i; j &lt;= lim; j += i)\n            (f[j] += mod - f[i]) %= mod, fac[j].push_back(i);\n        (now *= 26) %= mod;\n    &#125;\n    for (int i = 1; i &lt;= lim; ++i)\n        (f[i] *= inv(i)) %= mod;\n    std::vector&lt;int&gt; a(n + 1);\n    struct _ &#123; int l, r; long long f; &#125;;\n    std::vector&lt;std::vector&lt;_&gt; &gt; g(lim + 1);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; a[i];\n        if (g[a[i]].empty()) &#123;\n            g[a[i]].resize(fac[a[i]].size());\n            for (int j = 0; j &lt; (int)fac[a[i]].size(); ++j) &#123;\n                g[a[i]][j].l = (j ? g[a[i]][j - 1].r + 1 : 1);\n                g[a[i]][j].r = fac[a[i]][j];\n                (g[a[i]][0].f += f[fac[a[i]][j]]) %= mod;\n                if (j != (int)fac[a[i]].size() - 1)\n                    (g[a[i]][j + 1].f += mod - f[fac[a[i]][j]]) %= mod;\n            &#125;\n            for (int j = 1; j &lt; (int)fac[a[i]].size(); ++j)\n                (g[a[i]][j].f += g[a[i]][j - 1].f) %= mod;\n            int getinv = inv(qkp(26, a[i]));\n            for (int j = 0; j &lt; (int)fac[a[i]].size(); ++j)\n                (g[a[i]][j].f *= getinv) %= mod;\n        &#125;\n    &#125;\n    std::vector&lt;int&gt; b(n + 1);\n    std::rotate_copy(a.begin() + 1, --a.end(), a.end(), b.begin() + 1);\n    long long res = 0ll;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        for (int j = 0, k = 0, now = 0;\n            j &lt; (int)fac[a[i]].size() &amp;&amp; k &lt; (int)fac[b[i]].size(); )\n            if (g[a[i]][j].r &lt; g[b[i]][k].r) &#123;\n                (res += g[a[i]][j].f * g[b[i]][k].f % mod\n                    * (g[a[i]][j].r - now) % mod) %= mod;\n                now = g[a[i]][j].r, ++j;\n            &#125;\n            else if (g[a[i]][j].r == g[b[i]][k].r) &#123;\n                (res += g[a[i]][j].f * g[b[i]][k].f % mod\n                    * (g[a[i]][j].r - now) % mod) %= mod;\n                now = g[a[i]][j].r, ++j, ++k;\n            &#125;\n            else &#123;\n                (res += g[a[i]][j].f * g[b[i]][k].f % mod\n                    * (g[b[i]][k].r - now) % mod) %= mod;\n                now = g[b[i]][k].r, ++k;\n            &#125;\n    &#125;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"äºŒå‰æœç´¢æ ‘\">äºŒå‰æœç´¢æ ‘</h2>\n<p><a href=\"https://pjudge.ac/contest/1914/problem/21889\" class=\"uri\">https://pjudge.ac/contest/1914/problem/21889</a></p>\n<p>å½“æˆ‘ä»¬å¤„ç†é“¾çš„éƒ¨åˆ†åˆ†æ—¶ï¼Œå¾ˆå®¹æ˜“æƒ³åˆ°ç”¨å·®åˆ†è§£å†³é—®é¢˜ã€‚æŠŠæ›´æ–° <span class=\"math inline\">\\([l, r]\\)</span> çœ‹ä½œåœ¨å·®åˆ†æ•°ç»„ <span class=\"math inline\">\\(l\\)</span> å¤„æ’å…¥ï¼Œåœ¨ <span class=\"math inline\">\\(r+1\\)</span> å¤„åˆ é™¤ï¼Œç¦»çº¿ä¸‹æ¥å†ä»å·¦åˆ°å³æ‰«ä¸€éæ“ä½œï¼Œè€ƒè™‘å¦‚ä½•è§£å†³æŸ¥è¯¢é—®é¢˜ã€‚</p>\n<p>è€ƒè™‘å¦‚ä½•è·å– <span class=\"math inline\">\\(i\\)</span> æ ‘ä¸Š <span class=\"math inline\">\\(t_0\\)</span> æ—¶åˆ»ç‚¹ <span class=\"math inline\">\\(x\\)</span> çš„æ‰€æœ‰ç¥–å…ˆã€‚æ ¹æ®å‰é¢çš„æ“ä½œï¼Œæˆ‘ä»¬å¯ä»¥è·å– <span class=\"math inline\">\\(i\\)</span> æ ‘ä¸Šå­˜åœ¨è¿‡çš„æ‰€æœ‰å…ƒç´ ã€‚</p>\n<p>å¯¹äºæ¯” <span class=\"math inline\">\\(x\\)</span> å¤§çš„å…ƒç´ ï¼Œè€ƒè™‘ç¥–å…ˆ <span class=\"math inline\">\\(p_a\\)</span> å’Œéç¥–å…ˆ <span class=\"math inline\">\\(p\\)</span> æœ‰ä»€ä¹ˆåŒºåˆ«ã€‚æ ¹æ® BST çš„æ€§è´¨æ˜“å¾—ï¼Œå¯¹äºæœ€ä½çš„å³ä¾§ç¥–å…ˆ <span class=\"math inline\">\\({p_a}_0\\)</span>ï¼Œå…¶æ˜¯ <span class=\"math inline\">\\(\\ge x\\)</span> çš„æœ€å°çš„å…ƒç´ ï¼ˆå½“ç„¶å…¶åŠ å…¥æ—¶åˆ» <span class=\"math inline\">\\(t_a&lt;t_0\\)</span>ï¼‰ï¼›é‚£ä¹ˆåŒç†å¯ä»¥æ‰¾åˆ° <span class=\"math inline\">\\({p_a}_0\\)</span> å³ä¾§æœ€ä½çš„ç¥–å…ˆï¼ˆå…¶å·¦ä¾§çš„ç¥–å…ˆæ˜¾ç„¶ä¹Ÿ <span class=\"math inline\">\\(x\\)</span> å·¦ä¾§ï¼‰ï¼Œè¯¥ç¥–å…ˆæ»¡è¶³ <span class=\"math inline\">\\(t&lt;t_a\\)</span>ã€‚é‚£ä¹ˆæˆ‘ä»¬å°±ä»å·¦å³ä¸¤è¾¹åˆ†åˆ«å¾—åˆ° <span class=\"math inline\">\\(x\\)</span> çš„æ‰€æœ‰ç¥–å…ˆã€‚å®¹æ˜“è¯æ˜è¯¥è¿‡ç¨‹å¯¹äºä¸åœ¨æ ‘ä¸Šçš„ <span class=\"math inline\">\\(x\\)</span> ä¹Ÿæ˜¯æ­£ç¡®çš„ã€‚</p>\n<p>å…·ä½“åœ°ï¼Œæˆ‘ä»¬éœ€è¦ä¸€ä¸ªæ•°æ®ç»“æ„ï¼Œèƒ½å¤Ÿæ±‚å‡º <span class=\"math inline\">\\(\\ge x\\)</span> çš„å…ƒç´ ä¸­ï¼Œä»¥ <span class=\"math inline\">\\(t_0\\)</span> ä¸ºèµ·ç‚¹çš„å‰ç¼€æœ€å°å€¼åºåˆ—çš„åŒºé—´å’Œã€‚</p>\n<p>æ¬¸ â˜ğŸ¤“ è¿™æ˜¯ä»€ä¹ˆï¼Ÿ<a href=\"/20250217\">æ¥¼æˆ¿é‡å»º</a>ï¼ç§’ä¸€ä¸‹ï¼</p>\n<p>è¿›ä¸€æ­¥åœ°ï¼Œæœ¬é¢˜éœ€è¦å®Œæˆå¯¹äº <span class=\"math inline\">\\(t_0\\)</span> ä¸ºåºåˆ—å¤´çš„æŸ¥è¯¢ã€‚å†æ¬¡åˆ©ç”¨æ€§è´¨ï¼Œæ¯æ¬¡ <span class=\"math inline\">\\(O(\\log V)\\)</span> åœ°åˆå¹¶ç­”æ¡ˆã€‚</p>\n<p>å¥½çš„é‚£ä¹ˆæ€ä¹ˆæŠŠé“¾æåˆ°æ ‘ä¸Šå‘¢ï¼ŸæŠŠå·®åˆ†æ”¾åˆ°æ ‘ä¸Šï¼Œå†™ä¸ªçº¿æ®µæ ‘åˆå¹¶å³å¯ã€‚</p>\n<p><strong>æ³¨æ„ç”±äºè¿™é¢˜ç»†èŠ‚å¤ªå¤šäº†ï¼Œæ‰€ä»¥ä½ å¯èƒ½éœ€è¦èˆå¼ƒä¸å¿…è¦çš„æ—¶ç©ºä¼˜åŒ–æ¢å–ä»£ç ç®€æ´åº¦ä»¥æ–¹ä¾¿è°ƒè¯•ã€‚</strong></p>\n<details>\n<pre data-line=\"12\" class=\"cpp language-cpp\"><code data-line=\"12\" class=\"cpp language-cpp\">#include &lt;bits/stdc++.h&gt;\nconst int lim = 2e5;\nconst int maxn = 2e7 + 5;\nconst int inf = 0x3f3f3f3f;\nstruct &#123;\n    int l, r, rv;\n    long long u;\n&#125; t[maxn];\nstd::vector&lt;int> tr;\n#define lt t[p].l\n#define rt t[p].r\nint newnode(void) &#123;         // æˆ‘çŸ¥é“ä½ è¦è¯´ä»€ä¹ˆï¼Œä½†è¿™å±äºã€Œå¿…è¦çš„ã€ç©ºé—´ä¼˜åŒ– ğŸ˜¥\n    static int tot = 0;\n    if (tr.empty())\n        return ++tot;\n    auto p(tr.back());\n    t[p].l = t[p].r = 0;\n    tr.pop_back();\n    return p;\n&#125;\nlong long askv(int p, int l, int r, int v) &#123;\n    if (l == r)\n        return t[p].rv < v ? t[p].u : 0;\n    int mid = (l + r) >> 1;\n    if (v > t[lt].rv)\n        return t[p].u - t[lt].u + askv(lt, l, mid, v);\n    return askv(rt, mid + 1, r, v);\n&#125;\nvoid pushup(int p, int l, int r) &#123;\n    t[p].rv = std::min(t[lt].rv, t[rt].rv);\n    int mid = (l + r) >> 1;\n    t[p].u = t[lt].u + askv(rt, mid + 1, r, t[lt].rv);\n    return;\n&#125;\nvoid upd(int &p, int l, int r, int x, int v, int u) &#123;\n    if (!p)\n        p = newnode();\n    if (l == r) &#123;\n        t[p].rv = v, t[p].u = u;\n        return;\n    &#125;\n    int mid = (l + r) >> 1;\n    if (x <= mid)\n        upd(lt, l, mid, x, v, u);\n    else\n        upd(rt, mid + 1, r, x, v, u);\n    pushup(p, l, r);\n    return;\n&#125;\nvoid merge(int &p, int q, int l, int r) &#123;\n    if (!p || !q) &#123;\n        p += q;\n        return;\n    &#125;\n    if (l == r) &#123;\n        t[p].rv = std::min(t[p].rv, t[q].rv);\n        t[p].u = std::max(t[p].u, t[q].u);\n        return;\n    &#125;\n    int mid = (l + r) >> 1;\n    merge(t[p].l, t[q].l, l, mid), merge(t[p].r, t[q].r, mid + 1, r);\n    pushup(p, l, r), tr.push_back(q);\n    return;\n&#125;\nint qv = inf;\nlong long ask(int p, int l, int r, int ql, int qr) &#123;\n    if (ql <= l && r <= qr) &#123;\n        auto s(askv(p, l, r, qv));\n        qv = std::min(qv, t[p].rv);\n        return s;\n    &#125;\n    int mid = (l + r) >> 1;\n    long long res = 0ll;\n    if (ql <= mid)\n        res = ask(lt, l, mid, ql, qr);\n    if (qr > mid)\n        res += ask(rt, mid + 1, r, ql, qr);\n    return res;\n&#125;\n#undef lt\n#undef rt\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(\"ex_problem4.in\", \"r\", stdin);\n    std::freopen(\".out\", \"w\", stdout);\n#endif\n    int n, m;\n    std::cin >> n >> m;\n    std::vector&lt;std::vector&lt;int> > g(n + 1);\n    for (int i = 1, x, y; i < n; ++i) &#123;\n        std::cin >> x >> y;\n        g[x].push_back(y), g[y].push_back(x);\n    &#125;\n    std::vector&lt;int> top(n + 1), fa(n + 1), siz(n + 1), son(n + 1), dep(n + 1);\n    std::function&lt;void(int, int)> DFS = [&](int x, int faa) &#123;\n        siz[x] = 1;\n        for (auto i : g[x])\n            if (i != faa) &#123;\n                fa[i] = x, dep[i] = dep[x] + 1;\n                DFS(i, x), siz[x] += siz[i];\n                if (siz[i] > siz[son[x]])\n                    son[x] = i;\n            &#125;\n        return;\n    &#125;;\n    DFS(1, -1);\n    DFS = [&](int x, int topp) &#123;\n        top[x] = topp;\n        if (son[x])\n            DFS(son[x], topp);\n        for (auto i : g[x])\n            if (i != fa[x] && i != son[x])\n                DFS(i, i);\n        return;\n    &#125;;\n    DFS(1, 1);\n    auto getLCA = [&](int x, int y) &#123;\n        for (; top[x] != top[y]; x = fa[top[x]])\n            if (dep[top[y]] > dep[top[x]])\n                std::swap(x, y);\n        return (dep[x] < dep[y] ? x : y);\n    &#125;;\n    std::vector&lt;std::vector&lt;int> > d(n + 1);\n    std::vector&lt;std::vector&lt;std::pair&lt;int, int> > > u(n + 1);\n    std::vector&lt;std::vector&lt;std::tuple&lt;int, int, int> > > q(n + 1);\n    int cnt = 0;\n    for (int i = 1; i <= m; ++i) &#123;\n        int op;\n        std::cin >> op;\n        if (op == 0) &#123;\n            int x, v;\n            std::cin >> x >> v;\n            q[x].emplace_back(++cnt, i, v);\n        &#125; else &#123;\n            int x, y, v;\n            std::cin >> x >> y >> v;\n            int faa = getLCA(x, y);\n            u[x].emplace_back(i, v), u[y].emplace_back(i, v);\n            if (fa[faa])\n                d[fa[faa]].emplace_back(v);\n        &#125;\n    &#125;\n    std::vector&lt;long long> res(cnt + 1);\n    std::vector&lt;std::vector&lt;int> > rt(2, std::vector&lt;int> (n + 1));\n    t[0].rv = inf;\n    DFS = [&](int x, int fa) &#123;\n        for (auto i : g[x])\n            if (i != fa) &#123;\n                DFS(i, x);\n                merge(rt[0][x], rt[0][i], 1, lim);\n                merge(rt[1][x], rt[1][i], 1, lim);\n            &#125;\n        for (auto [t, v] : u[x]) &#123;\n            upd(rt[0][x], 1, lim, v, t, v);\n            upd(rt[1][x], 1, lim, lim - v + 1, t, v);\n        &#125;\n        for (auto v : d[x]) &#123;\n            upd(rt[0][x], 1, lim, v, inf, 0);\n            upd(rt[1][x], 1, lim, lim - v + 1, inf, 0);\n        &#125;\n        for (auto [id, t, v] : q[x]) &#123;\n            qv = t, res[id] = ask(rt[0][x], 1, lim, v, lim);\n            qv = t, res[id] += ask(rt[1][x], 1, lim, lim - v + 1, lim);\n            qv = t, res[id] -= ask(rt[0][x], 1, lim, v, v);\n        &#125;\n    &#125;;\n    DFS(1, -1);\n    for (int i = 1; i <= cnt; ++i)\n        std::cout << res[i] << '\\n';\n    return 0;\n&#125;</code></pre>\n</details>\n",
            "tags": [
                "çº¿æ®µæ ‘",
                "æ•°å­¦",
                "æ ‘ä¸Šå·®åˆ†"
            ]
        }
    ]
}