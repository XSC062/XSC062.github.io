{
    "version": "https://jsonfeed.org/version/1",
    "title": "null • All posts by \"思维\" tag",
    "description": "",
    "home_page_url": "https://xsc062.netlify.app",
    "items": [
        {
            "id": "https://xsc062.netlify.app/20250717/",
            "url": "https://xsc062.netlify.app/20250717/",
            "title": "练习 树的各种性质 II",
            "date_published": "2025-07-17T13:09:13.000Z",
            "content_html": "<p>好像确实比斜优做着舒服。</p>\n<span id=\"more\"></span>\n<hr />\n<h2 id=\"a---perfect-matching-on-a-tree\">A - Perfect Matching on a Tree</h2>\n<p><a href=\"https://atcoder.jp/contests/abc362/tasks/abc362_f\" class=\"uri\">https://atcoder.jp/contests/abc362/tasks/abc362_f</a></p>\n<p>肯定直接猜以重心为根。</p>\n<p>至于咋求答案，（显然值是所有点的深度之和），这个我去年在场上被卡住了，还是太菜了。现在看来不是很牛的。</p>\n<p>随便乱胡一下，发现就是把若干条线段陈列到两个上下对齐、长度为 <span class=\"math inline\">\\(n\\div 2\\)</span> 的盒子里。容易想到哪边更空放哪边的贪心策略，当最后还剩一条线段的时候，两个盒子都会剩下一截。</p>\n<p>如果直接塞进去肯定是非法的，这个时候想到把下面的这一节放到下面盒子的开头，其他的依次后移即可。由于重心的每个儿子大小不超过盒子长度，所以移了之后肯定不重合。且容易发现只会换行一次。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);\n    for (int i = 1, x, y; i &lt; n; ++i) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y;\n        g[x].push_back(y), g[y].push_back(x);\n    &#125;\n    std::vector&lt;int&gt; siz(n + 1);\n    int rt = 0;\n    std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int fa) &#123;\n        siz[x] = 1;\n        bool flag = 1;\n        for (auto i : g[x])\n            if (i != fa) &#123;\n                DFS(i, x);\n                siz[x] += siz[i];\n                if (siz[i] &gt; n / 2)\n                    flag = 0;\n            &#125;\n        if (flag &amp;&amp; n - siz[x] &lt;= n / 2)\n            rt = x;\n        return;\n    &#125;;\n    DFS(1, -1);\n    std::vector&lt;std::vector&lt;int&gt; &gt; t(n + 1);\n    for (auto i : g[rt]) &#123;\n        DFS = [&amp;](int x, int fa) &#123;\n            t[i].push_back(x);\n            for (auto i : g[x])\n                if (i != fa)\n                    DFS(i, x);\n            return;\n        &#125;;\n        DFS(i, rt);\n    &#125;\n    std::deque&lt;int&gt; p1, p2;\n    int to = n / 2;\n    for (auto i : g[rt]) &#123;\n        auto &amp;q1 = (p1.size() &gt; p2.size() ? p2 : p1), &amp;q2 = (p1.size() &gt; p2.size() ? p1 : p2);\n        for (; !t[i].empty() &amp;&amp; (int)q1.size() &lt; to; q1.push_back(t[i].back()), t[i].pop_back());\n        for (; !t[i].empty() &amp;&amp; (int)q2.size() &lt; to; q2.push_front(t[i].back()), t[i].pop_back());\n    &#125;\n    if (n % 2 == 0)\n        (p1.size() &lt; p2.size() ? p1 : p2).push_back(rt);\n    for (; to--; ) &#123;\n        std::cout &lt;&lt; p1.back() &lt;&lt; &#39; &#39; &lt;&lt; p2.back() &lt;&lt; &#39;\\n&#39;;\n        p1.pop_back(), p2.pop_back();\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"b---miracle-tree\">B - Miracle Tree</h2>\n<p><a href=\"https://atcoder.jp/contests/arc117/tasks/arc117_d\" class=\"uri\">https://atcoder.jp/contests/arc117/tasks/arc117_d</a></p>\n<p>容易发现任取 <span class=\"math inline\">\\(a,b,c\\)</span> 三点，由于它们之间只有一条简单路径，可以视为一条线段，即退化的三角形。那么由三角形三边关系，任取两边之和都大于等于第三边。</p>\n<p>不妨令 <span class=\"math inline\">\\(E(a)&gt;E(b)&gt;E(c)\\)</span>，以 <span class=\"math inline\">\\(d(b,a)+d(b,c)\\ge d(a,c)\\)</span> 举例，有 <span class=\"math inline\">\\(E(a)-E(b)+E(b)-E(c)\\ge d(a,c)\\)</span> 成立；即，若 <span class=\"math inline\">\\((b,a)\\)</span> 和 <span class=\"math inline\">\\((b,c)\\)</span> 分别已经找到可行解，则 <span class=\"math inline\">\\((a,c)\\)</span> 合法。</p>\n<p>从而推断出，按点权将所有点从小到大排序后，只需让任意相邻两点合法，则全树合法。易发现答案是所有相邻两点 <span class=\"math inline\">\\(dis\\)</span> 之和；也即，从任意一点出发，经过全树所有点的路径和。这种问题我们很熟悉，由欧拉序可知是从 <span class=\"math inline\">\\(2(n-1)\\)</span> 个 <span class=\"math inline\">\\(w\\)</span> 中抠走一段路径长（终点到起点）。想要最小化答案就要最大化这段路径长，取直径即可。</p>\n<p>最后的答案序列按照欧拉序直接求即可（注意直径的端点要在序列两端），实现上应该可以有一些 <span class=\"math inline\">\\(O(n)\\)</span> 小巧思。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);\n    for (int i = 1, x, y; i &lt; n; ++i) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y;\n        g[x].push_back(y), g[y].push_back(x);\n    &#125;\n    std::vector&lt;int&gt; dep(n + 1);\n    std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int fa) &#123;\n        for (auto i : g[x])\n            if (i != fa) &#123;\n                dep[i] = dep[x] + 1;\n                DFS(i, x);\n            &#125;\n        return;\n    &#125;;\n    dep[1] = 1, DFS(1, -1);\n    int p = std::max_element(dep.begin() + 1, dep.end()) - dep.begin();\n    dep[p] = 1, DFS(p, -1);\n    int q = std::max_element(dep.begin() + 1, dep.end()) - dep.begin();\n    std::vector&lt;int&gt; tag(n + 1);\n    std::function&lt;bool(int, int)&gt; DFS1 = [&amp;](int x, int fa) &#123;\n        if (x == q) &#123;\n            tag[x] = 1;\n            return true;\n        &#125;\n        for (auto i : g[x])\n            if (i != fa &amp;&amp; DFS1(i, x)) &#123;\n                tag[x] = 1;\n                return true;\n            &#125;\n        return false;\n    &#125;;\n    DFS1(p, -1);\n    std::vector&lt;int&gt; res(n + 1);\n    DFS = [&amp;](int x, int fa) &#123;\n        static int now = 1;\n        int son = 0;\n        if (x != p)\n            res[x] = now;\n        for (auto i : g[x])\n            if (i != fa) &#123;\n                if (tag[i])\n                    son = i;\n                else\n                    ++now, DFS(i, x), ++now;\n            &#125;\n        if (son)\n            ++now, DFS(son, x); // 回不来了，故可以不加 ;-)\n        return;\n    &#125;;\n    res[p] = 1, DFS(p, -1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cout &lt;&lt; res[i] &lt;&lt; &#39; &#39;;\n    std::cout &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"c---树的计数\">C - 树的计数</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P1232\" class=\"uri\">https://www.luogu.com.cn/problem/P1232</a></p>\n<p>需要意识到 DFS 和 BFS 地位是不等价的：二者都有自己相应的性质，但 BFS 的深度性质更易于上手。</p>\n<p>不妨进行重标号，令 BFS 序为 <span class=\"math inline\">\\(1\\sim n\\)</span>。可以在 BFS 中不断进行『分层』得到点的深度信息。发现 <span class=\"math inline\">\\(1\\)</span> 后必须分割一次，除此之外没有 BFS 序本身带来的限制。考虑 DFS 序对深度带来的额外限制：</p>\n<ul>\n<li>对于 <span class=\"math inline\">\\(D_i\\)</span> 和 <span class=\"math inline\">\\(D_{i+1}\\)</span>，则 <span class=\"math inline\">\\(D_{i+1}\\)</span> 的插入位点位于 <span class=\"math inline\">\\(1\\sim D_i\\)</span> 的链上，则 <span class=\"math inline\">\\(dep_{D_{i+1}}\\le dep_{D_i}+1\\)</span>，即 BFS 序中，<span class=\"math inline\">\\([D_i,D_{i+1})\\)</span> 间有至多一个分段点。</li>\n<li>虽然题面没说，但是这里 BFS 和 DFS 遍历儿子的顺序是相同的；由于在 BFS 序中 <span class=\"math inline\">\\(i\\)</span> 先于 <span class=\"math inline\">\\(i+1\\)</span> 被遍历，（由于 <span class=\"math inline\">\\(dep_i\\le dep_{i+1}\\le dep_i+1\\)</span>），故而若 <span class=\"math inline\">\\(dep_i= dep_{i+1}\\)</span>，则 DFS 先遍历 <span class=\"math inline\">\\(i\\)</span>；反之，若 DFS 序中 <span class=\"math inline\">\\(i+1\\)</span> 早于 <span class=\"math inline\">\\(i\\)</span> 出现，BFS 序中 <span class=\"math inline\">\\(i\\)</span> 处必须分层。</li>\n</ul>\n<p>则得到若干条限制，形如某处必须断、某区间必须恰好断一次之类。发现比较难处理的是区间内没有要求『某个点必须断』的情况；<del>可以差分约束</del> 惊讶地发现，这种情况下有 <span class=\"math inline\">\\(D_{i+1}=D_i+1\\)</span>（可以考察第一个满足 <span class=\"math inline\">\\(D_i\\ne i\\)</span> 的点来思考）。这点其实是比较难论证的，所以我也没有想得很清楚；好在信息也不是很要求证明这一块就是了。</p>\n<p>用差分处理『恰好一次』的限制，标记某些点不能断。初始高度为 <span class=\"math inline\">\\(1\\)</span>；每次『必须分段』会带来 <span class=\"math inline\">\\(1\\)</span> 的高度；每次『可能分段』会带来 <span class=\"math inline\">\\(0.5\\)</span> 的高度。加起来就可以了。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;P1232_2.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;int&gt; d(n + 1), b(n + 1), p(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; d[i];\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; b[i], p[b[i]] = i;\n    for (int i = 1; i &lt;= n; ++i)\n        d[i] = p[d[i]];\n    for (int i = 1; i &lt;= n; ++i)\n        p[d[i]] = i;\n    int res = 4;\n    std::vector&lt;int&gt; tag(n + 1), forbid(n + 1);\n    for (int i = 2; i &lt; n; ++i)\n        if (p[i + 1] &lt; p[i])\n            tag[i] = 1;\n    std::partial_sum(tag.begin() + 1, tag.end(), tag.begin() + 1);\n    for (int i = 2; i &lt; n; ++i)\n        if (d[i + 1] &gt; d[i] &amp;&amp; tag[d[i + 1] - 1] - tag[d[i] - 1]) &#123;\n            // fprintf(stderr, &quot;forbid [%d, %d)\\n&quot;, d[i], d[i + 1]);\n            forbid[d[i]] += 1, forbid[d[i + 1]] -= 1;\n        &#125;\n    std::partial_sum(forbid.begin() + 1, forbid.end(), forbid.begin() + 1);\n    for (int i = 2; i &lt; n; ++i)\n        if (p[i] &gt; p[i + 1])\n            res += 2;\n        else if (!forbid[i] &amp;&amp; p[i + 1] == p[i] + 1)\n            res += 1;\n    std::cout &lt;&lt; res / 2;\n    if (res &amp; 1)\n        std::cout &lt;&lt; &quot;.500&quot;;\n    else\n        std::cout &lt;&lt; &quot;.000&quot;;\n    std::cout &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"d---alice-and-bob\">D - Alice and Bob</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P3971\" class=\"uri\">https://www.luogu.com.cn/problem/P3971</a></p>\n<p>一个很显然的想法是 BST；但是这个东西只能求可行解，求不了最优解。</p>\n<p>题解说观察到 <span class=\"math inline\">\\(i\\)</span> 的决策点一定是左侧最靠右的一个 <span class=\"math inline\">\\(a_j=a_i-1\\)</span>（可以假设 <span class=\"math inline\">\\(a_j&gt;a_i\\)</span> 然后反证）。如果把 <span class=\"math inline\">\\(j\\)</span> 向 <span class=\"math inline\">\\(i\\)</span> 连边可以建树；注意到共用一个父亲的点值是递减的。</p>\n<p>要往树上填值。容易想到一层一层填；可惜不最优（反例如下图）。</p>\n<figure>\n<img src=\"image.png\" alt=\"考察从 1 开始的最长下降子序列，发现按层倒序填不优。\" /><figcaption>考察从 1 开始的最长下降子序列，发现按层倒序填不优。</figcaption>\n</figure>\n<p>考虑『以 <span class=\"math inline\">\\(i\\)</span> 开头的最长下降子序列长度』在树上的内涵，发现：</p>\n<ol type=\"1\">\n<li>只能取 <span class=\"math inline\">\\(i\\)</span> 所在子树往右的部分；</li>\n<li>取了祖先就不能取儿子；儿子标号比祖先大；标号越大越能取；最优肯定取叶子。</li>\n</ol>\n<p><strong>想要尽量取满所有 <span class=\"math inline\">\\(i\\)</span> 子树右侧的所有比 <span class=\"math inline\">\\(i\\)</span> 标号大的叶子，就要让它们比 <span class=\"math inline\">\\(i\\)</span> 都小</strong>。这个问题是简单的；一种方法是按儿子标号从大到小，一边 DFS 一边赋值。暂时没想到不用还原序列、log 求答案的统计方法。</p>\n<figure>\n<img src=\"image-1.png\" alt=\"附：两种方式对比\" /><figcaption>附：两种方式对比</figcaption>\n</figure>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 1e5 + 5;\nstruct &#123; int l, r, u; &#125; t[maxn &lt;&lt; 2];\n#define lt (p &lt;&lt; 1)\n#define rt (lt | 1)\nvoid bld(int p, int l, int r) &#123;\n    t[p].l = l, t[p].r = r;\n    if (l == r)\n        return;\n    int mid = (l + r) &gt;&gt; 1;\n    bld(lt, l, mid), bld(rt, mid + 1, r);\n    return;\n&#125;\nvoid add(int p, int x, int v) &#123;\n    t[p].u = std::max(t[p].u, v);\n    if (t[p].l == t[p].r)\n        return;\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (x &lt;= mid)\n        add(lt, x, v);\n    else\n        add(rt, x, v);\n    return;\n&#125;\nint ask(int p, int l, int r) &#123;\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r)\n        return t[p].u;\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1, res = 0;\n    if (l &lt;= mid)\n        res = ask(lt, l, r);\n    if (r &gt; mid)\n        res = std::max(res, ask(rt, l, r));\n    return res;\n&#125;\n#undef lt\n#undef rt\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);\n    std::vector&lt;int&gt; a(n + 1), la(n + 1), deg(n + 1);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; a[i];\n        g[la[a[i] - 1]].push_back(i), ++deg[la[a[i] - 1]];\n        la[a[i]] = i;\n    &#125;\n    std::vector&lt;int&gt; u(n + 1), b(n + 1);\n    std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;\n        static int now = 0;\n        u[x] = now++;\n        std::reverse(g[x].begin(), g[x].end());\n        for (auto i : g[x])\n            DFS(i);\n        return;\n    &#125;;\n    DFS(0);\n    bld(1, 1, n);\n    for (int i = n; i; --i) &#123;\n        b[i] = ask(1, 1, u[i] - 1) + 1;\n        add(1, u[i], b[i]);\n    &#125;\n    // for (int i = 1; i &lt;= n; ++i)\n    //     std::cout &lt;&lt; b[i] &lt;&lt; &#39; &#39;;\n    // std::cout &lt;&lt; &#39;\\n&#39;;\n    std::cout &lt;&lt; std::accumulate(b.begin() + 1, b.end(), 0ll) &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"e---tree-factory\">E - Tree Factory</h2>\n<p><a href=\"https://codeforces.com/problemset/problem/1225/F\" class=\"uri\">https://codeforces.com/problemset/problem/1225/F</a></p>\n<p>首先把题意转化为『每次可以把一个子树下移，要求把一个树转化为一条链』。可以进行一些观察：</p>\n<ul>\n<li>一次移动能产生贡献当且仅当其让树高增加 <span class=\"math inline\">\\(1\\)</span>。</li>\n<li>如果每次移动都产生贡献，易发现答案下界为 <span class=\"math inline\">\\(n-\\sum mxd_i\\)</span>，可以取到。</li>\n</ul>\n<p>看到深度相关就要想到长剖 😅 bro 还没 ptsd</p>\n<p>取以根为 top 的长链，从底到顶依次完成『并到短链所在树上，把树拆成链』的操作。具体过程大概是一个 dfn 的感觉。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);\n    for (int i = 2, x; i &lt;= n; ++i)\n        std::cin &gt;&gt; x, g[x + 1].push_back(i);\n    std::vector&lt;int&gt; mxd(n + 1), son(n + 1), res, nex(n + 1);\n    std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;\n        mxd[x] = 1;\n        for (auto i : g[x]) &#123;\n            DFS(i);\n            if (mxd[i] + 1 &gt; mxd[x])\n                son[x] = i, mxd[x] = mxd[i] + 1;\n        &#125;\n        return;\n    &#125;;\n    DFS(1);\n    std::vector&lt;int&gt; p;\n    for (int i = 1; son[i]; i = son[i])\n        p.push_back(i);\n    std::function&lt;void(int, int)&gt; merge = [&amp;](int son, int x) &#123;\n        int la = son;\n        res.push_back(son);\n        for (auto i : g[x])\n            merge(la, i), la = i;\n        nex[x] = la;\n        return;\n    &#125;;\n    for (int i = (int)p.size() - 1; ~i; --i) &#123;\n        int la = son[p[i]];\n        for (auto j : g[p[i]])\n            if (j != son[p[i]])\n                merge(la, j), la = j;\n        nex[p[i]] = la;\n    &#125;\n    for (int i = 1; i; i = nex[i])\n        std::cout &lt;&lt; i - 1 &lt;&lt; &#39; &#39;;\n    std::cout &lt;&lt; &#39;\\n&#39; &lt;&lt; res.size() &lt;&lt; &#39;\\n&#39;;\n    std::reverse(res.begin(), res.end());\n    for (auto i : res)\n        std::cout &lt;&lt; i - 1 &lt;&lt; &#39; &#39;;\n    std::cout &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n",
            "tags": [
                "思维"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20250716/",
            "url": "https://xsc062.netlify.app/20250716/",
            "title": "练习 树的各种性质 I",
            "date_published": "2025-07-16T08:17:10.000Z",
            "content_html": "<p>这不比斜优做着爽。</p>\n<span id=\"more\"></span>\n<hr />\n<h2 id=\"a---tree\">A - Tr/ee</h2>\n<p><a href=\"https://atcoder.jp/contests/arc103/tasks/arc103_c\" class=\"uri\">https://atcoder.jp/contests/arc103/tasks/arc103_c</a></p>\n<p>可以发现，类似删边的问题，删出来的连通块当中，靠下的是一个完整的子树；就可以转化为子树问题了。</p>\n<p>容易想到枚举 <span class=\"math inline\">\\(i-1\\)</span> 时树的状态，尝试转化为 <span class=\"math inline\">\\(i\\)</span> 时的状态；进一步可以胡出来一堆方案（大概），这里我胡的是，初始设置一个单点，<span class=\"math inline\">\\(0\\to 1\\)</span> 啥也不干，<span class=\"math inline\">\\(0\\to 0\\)</span> 在当前根上再加一个叶子，<span class=\"math inline\">\\(1\\to 0\\)</span> 新建一个带叶子的根并令其成为当前根的父亲，<span class=\"math inline\">\\(1\\to 1\\)</span> 加一个父亲。</p>\n<p>然后特判一下 <span class=\"math inline\">\\(s_1=0\\)</span> 和 <span class=\"math inline\">\\(s_n=1\\)</span> 和 <span class=\"math inline\">\\(s_i\\ne s_{n-i}\\)</span> 的情况，发现其他时候都有解。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    std::string s;\n    std::cin &gt;&gt; s, n = (int)s.length();\n    s = &quot;#&quot; + s;\n    if (s[1] == &#39;0&#39; || s[n] == &#39;1&#39;) &#123;\n        std::cout &lt;&lt; -1 &lt;&lt; &#39;\\n&#39;;\n        return 0;\n    &#125;\n    for (int i = 1; i &lt; n; ++i)\n        if (s[i] != s[n - i]) &#123;\n            std::cout &lt;&lt; -1 &lt;&lt; &#39;\\n&#39;;\n            return 0;\n        &#125;\n    int tot = 1, rt = 1;\n    for (int i = 2; i &lt; n; ++i) &#123;\n        if (tot == i - 1) &#123;\n            if (s[i] == &#39;0&#39;) &#123;\n                std::cout &lt;&lt; rt &lt;&lt; &#39; &#39; &lt;&lt; ++tot &lt;&lt; &#39;\\n&#39;;\n                rt = tot;\n                std::cout &lt;&lt; rt &lt;&lt; &#39; &#39; &lt;&lt; ++tot &lt;&lt; &#39;\\n&#39;;\n            &#125;\n            else &#123;\n                std::cout &lt;&lt; rt &lt;&lt; &#39; &#39; &lt;&lt; ++tot &lt;&lt; &#39;\\n&#39;;\n                rt = tot;\n            &#125;\n        &#125;\n        else if (s[i] == &#39;0&#39;)\n            std::cout &lt;&lt; rt &lt;&lt; &#39; &#39; &lt;&lt; ++tot &lt;&lt; &#39;\\n&#39;;\n    &#125;\n    if (tot != n)\n        std::cout &lt;&lt; rt &lt;&lt; &#39; &#39; &lt;&lt; n &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"b---keep-perfectly-matched\">B - Keep Perfectly Matched</h2>\n<p><a href=\"https://atcoder.jp/contests/arc183/tasks/arc183_d\" class=\"uri\">https://atcoder.jp/contests/arc183/tasks/arc183_d</a></p>\n<p>发现这个『完美匹配』就是在树上给每个点找相邻点配对，看看能不能配上；继而发现由于点的总数为偶，一个点有且仅能有一个 siz 为奇的子树（不然非法），再发现对于任意一个点，删掉的点对要么来自其同一个子树；要么一个来自其奇子树，另一个来自其偶子树。</p>\n<p>发现要求最大化距离，又只能删叶子，所以需要最小化 LCA 深度；有没有办法让每次的 LCA 都是根呢？让重心成为根，并保证每次操作的两个点都不来自同一个儿子即可（显然这样是完全可能的）。</p>\n<p>接着写了一发发现过不了样例，原因是发现在偶子树中会出现『一个中途的节点本来有一个奇儿子，删去偶子树中的一个叶子后非法』的情况。显然这样的节点是一个偶儿子。确保每个偶儿子的奇儿子先被删掉就可以解决问题。</p>\n<p>对重心的每个儿子，提前规划其节点被删除的顺序即可。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);\n    for (int i = 1, x, y; i &lt; n; ++i) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y;\n        g[x].push_back(y), g[y].push_back(x);\n    &#125;\n    std::vector&lt;int&gt; siz(n + 1);\n    int rt = 0;\n    std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int fa) &#123;\n        siz[x] = 1;\n        bool flag = 1;\n        for (auto i : g[x])\n            if (i != fa) &#123;\n                DFS(i, x);\n                siz[x] += siz[i];\n                if (siz[i] &gt; n / 2)\n                    flag = 0;\n            &#125;\n        if (flag &amp;&amp; n - siz[x] &lt;= n / 2)\n            rt = x;\n        return;\n    &#125;;\n    DFS(1, -1);\n    std::vector&lt;std::vector&lt;int&gt; &gt; lf(n + 1);\n    int f1 = -1;\n    auto comp = [&amp;](int i, int j) &#123; return siz[i] &lt; siz[j]; &#125;;\n    std::priority_queue&lt;int, std::vector&lt;int&gt;, decltype(comp)&gt; f0(comp);\n    siz.assign(n + 1, 0);\n    for (auto t : g[rt]) &#123;\n        DFS = [&amp;](int x, int fa) &#123;\n            siz[x] = 1;\n            for (auto i : g[x])\n                if (i != fa) &#123;\n                    DFS(i, x);\n                    siz[x] += siz[i];\n                &#125;\n            return;\n        &#125;;\n        DFS(t, rt);\n        DFS = [&amp;](int x, int fa) &#123;\n            if (siz[x] % 2 == 0) &#123;\n                for (auto i : g[x])\n                    if (i != fa &amp;&amp; siz[x] % 2 == 1)\n                        DFS(i, x);\n                for (auto i : g[x])\n                    if (i != fa &amp;&amp; siz[x] % 2 == 0)\n                        DFS(i, x);\n            &#125;\n            else\n                for (auto i : g[x])\n                    if (i != fa)\n                        DFS(i, x);\n            lf[t].push_back(x);\n            return;\n        &#125;;\n        DFS(t, rt);\n        if (siz[t] &amp; 1)\n            assert(f1 == -1), f1 = t;\n        else\n            f0.push(t);\n        std::reverse(lf[t].begin(), lf[t].end());\n    &#125;\n    fprintf(stderr, &quot;rt = %d\\n&quot;, rt);\n    assert(~f1);\n    for (int _ = n / 2; _--; ) &#123;\n        assert(~f1);\n        if (!_ &amp;&amp; f0.empty()) &#123;\n            std::cout &lt;&lt; f1 &lt;&lt; &#39; &#39; &lt;&lt; rt &lt;&lt; &#39;\\n&#39;;\n            break;\n        &#125;\n        assert(!f0.empty());\n        int t = f0.top();\n        f0.pop();\n        assert(!lf[f1].empty());\n        assert(!lf[t].empty());\n        std::cout &lt;&lt; lf[f1].back() &lt;&lt; &#39; &#39; &lt;&lt; lf[t].back() &lt;&lt; &#39;\\n&#39;;\n        lf[f1].pop_back(), --siz[f1];\n        lf[t].pop_back(), --siz[t];\n        if (siz[f1])\n            f0.push(f1);\n        f1 = t;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"c---fiolki\">C - Fiolki</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P5578\" class=\"uri\">https://www.luogu.com.cn/problem/P5578</a></p>\n<p>难点在于判断每一步有哪些反应发生；显然一个反应只会在某一步发生。</p>\n<p>发现将倒水的操作视为连边 <span class=\"math inline\">\\(b_i\\to a_i\\)</span>，那么形成了森林，把每个反应丢到 LCA 处等待 check。</p>\n<p>发现在 LCA 之外，两种试剂不可能相遇；故最后遍历一遍反应序列，维护每种药水当前数量，在每个点处 check 即可。</p>\n<p>再发现如果每次加边都在父亲处 check 所有可能发生的反应，复杂度肯定是错的；故用倍增求出两个点在 LCA 下方的点作为『检查点』，当『检查点』被合并到其父亲时，就可以 check 一下检查点上面挂的所有询问。显然每个点上的询问只会被检查一次；复杂度线性。</p>\n<p>加上倍增 LCA 的复杂度，就可以 <span class=\"math inline\">\\(O(n\\log n)\\)</span> 地完成。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, m, k;\n    std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;\n    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);\n    std::vector&lt;int&gt; f(n + 1), deg(n + 1), now(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; now[i];\n    std::iota(f.begin() + 1, f.end(), 1);\n    std::function&lt;int(int)&gt; find = [&amp;](int x) &#123;\n        return x == f[x] ? x : f[x] = find(f[x]);\n    &#125;;\n    auto merge = [&amp;](int x, int y) &#123;\n        f[find(x)] = find(y);\n        return;\n    &#125;;\n    std::vector&lt;std::pair&lt;int, int&gt; &gt; a(m + 1);\n    for (int i = 1; i &lt;= m; ++i) &#123;\n        auto &amp;[x, y] = a[i];\n        std::cin &gt;&gt; x &gt;&gt; y, ++deg[x];\n        g[y].push_back(x), merge(x, y);\n    &#125;\n    std::vector&lt;int&gt; dep(n + 1);\n    std::vector&lt;std::vector&lt;int&gt; &gt; fa(n + 1, std::vector&lt;int&gt; (21));\n    for (int i = 1; i &lt;= n; ++i)\n        if (!deg[i]) &#123;\n            std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;\n                for (auto i : g[x]) &#123;\n                    fa[i][0] = x;\n                    for (int j = 1; j &lt;= 20; ++j)\n                        fa[i][j] = fa[fa[i][j - 1]][j - 1];\n                    dep[i] = dep[x] + 1, DFS(i);\n                &#125;\n                return;\n            &#125;;\n            dep[i] = 1, DFS(i);\n        &#125;\n    std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; t(n + 1);\n    for (int x, y; k--; ) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y;\n        if (find(x) == find(y)) &#123;\n            std::pair&lt;int, int&gt; p(x, y);\n            if (dep[x] != dep[y]) &#123;\n                if (dep[x] &lt; dep[y])\n                    std::swap(x, y);\n                for (int i = 20; ~i; --i)\n                    if (dep[fa[x][i]] &gt; dep[y])\n                        x = fa[x][i];\n                if (fa[x][0] == y) &#123;\n                    t[x].push_back(p);\n                    // printf(&quot;add (%d, %d) to %d\\n&quot;, p.first, p.second, x);\n                    continue;\n                &#125;\n                x = fa[x][0];\n            &#125;\n            for (int i = 20; ~i; --i)\n                if (fa[x][i] != fa[y][i])\n                    x = fa[x][i], y = fa[y][i];\n            t[x].push_back(p), t[y].push_back(p);\n        &#125;\n    &#125;\n    std::iota(f.begin() + 1, f.end(), 1);\n    auto res(0ll);\n    for (int i = 1; i &lt;= m; ++i) &#123;\n        auto [x, y] = a[i];\n        merge(x, y);\n        for (auto [p, q] : t[x])\n            if (find(p) == find(x) &amp;&amp; find(q) == find(x)) &#123;\n                int u = std::min(now[p], now[q]);\n                res += 2 * u, now[p] -= u, now[q] -= u;\n            &#125;\n    &#125;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125; </code></pre>\n</details>\n<hr />\n<h2 id=\"d---permutation-tree\">D - Permutation Tree</h2>\n<p><a href=\"https://atcoder.jp/contests/arc095/tasks/arc095_d\" class=\"uri\">https://atcoder.jp/contests/arc095/tasks/arc095_d</a></p>\n<p>随便画图，会发现，如果按层数从小到大标号，一个点的儿子只有最多一个不是叶子。一言以蔽之：毛毛虫。</p>\n<p>然后就可以判断可行性了（直径就是虫身）。接下来需要考虑最小化答案字典序的问题，发现对于一个点的儿子，必须是虫足在其左、虫身在其右且必须严格按照层数标号。</p>\n<p>字典序是个偏贪心的东西，所以可以开始瞎搞：发现虫足越多，标号更小的父亲就会越靠后，所以依次比较用两端开头的情况，如果到了虫身的某一段，哪种的儿子更少就选谁，然后直接按最小来标号即可。</p>\n<p>实际上由于只有两种方案，你也可以两边都试试（）</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);\n    for (int i = 1, x, y; i &lt; n; ++i) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y;\n        g[x].push_back(y), g[y].push_back(x);\n    &#125;\n    std::vector&lt;int&gt; dep(n + 1);\n    std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int fa) &#123;\n        for (auto i : g[x])\n            if (i != fa) &#123;\n                dep[i] = dep[x] + 1;\n                DFS(i, x);\n            &#125;\n        return;\n    &#125;;\n    dep[1] = 1, DFS(1, -1);\n    int p = std::max_element(dep.begin() + 1, dep.end()) - dep.begin();\n    bool flag = 0;\n    std::vector&lt;int&gt; node, cnt(n + 1), siz(n + 1);\n    DFS = [&amp;](int x, int fa) &#123;\n        siz[x] = 1;\n        for (auto i : g[x])\n            if (i != fa) &#123;\n                DFS(i, x);\n                siz[x] += siz[i], ++cnt[x];\n            &#125;\n        if (siz[x] &gt; 1) &#123;\n            node.push_back(0), --cnt[x];\n            for (auto i : g[x]) &#123;\n                if (i != fa &amp;&amp; siz[node.back()] &gt; 1 &amp;&amp; siz[i] &gt; 1)\n                    flag = 1;\n                if (i != fa &amp;&amp; siz[i] &gt; siz[node.back()])\n                    node.back() = i;\n            &#125;\n        &#125;\n        return;\n    &#125;;\n    DFS(p, -1), node.push_back(p);\n    if (flag) &#123;\n        std::cout &lt;&lt; -1 &lt;&lt; &#39;\\n&#39;;\n        return 0;\n    &#125;\n    for (int i = 0, j = (int)node.size() - 1; i &lt;= j; ++i, --j)\n        if (cnt[node[i]] &gt; cnt[node[j]]) &#123;\n            std::reverse(node.begin(), node.end());\n            break;\n        &#125;\n        else if (cnt[node[i]] &lt; cnt[node[j]])\n            break;\n    int now = 0;\n    for (auto i : node) &#123;\n        int rt = ++now;\n        for (; cnt[i]--; std::cout &lt;&lt; ++now &lt;&lt; &#39; &#39;);\n        std::cout &lt;&lt; rt &lt;&lt; &#39; &#39;;\n    &#125;\n    std::cout &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"e---isomorphism-freak\">E - Isomorphism Freak</h2>\n<p><a href=\"https://atcoder.jp/contests/agc024/tasks/agc024_d\" class=\"uri\">https://atcoder.jp/contests/agc024/tasks/agc024_d</a></p>\n<p><del>像在数有多少种化学环境的 H 是可以说的吗</del></p>\n<p>鉴于这个，高中化学选择性必修三，给我们打下的坚实基础，我们可以非常迅速地注意到答案就是半径长。</p>\n<p>然后最少叶子，发现一眼瞪不出来，糟糕！没关系，观察样例输出，发现这些答案的因数都挺多，故猜测是若干个数乘起来的；然后再发现是每层最大儿子数的乘积。</p>\n<p>枚举中间的边（仅当直径长度为偶时）、点（奇偶都行）作为对称轴 / 对称中心的情况取 min 即可（原因是要尽量取靠近中心的 <strong>点</strong>），注意边两端算两个儿子数。</p>\n<p><del>所以为啥 <span class=\"math inline\">\\(n\\)</span> 这么小</del></p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst long long inf = 1e18;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);\n    for (int i = 1, x, y; i &lt; n; ++i) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y;\n        g[x].push_back(y), g[y].push_back(x);\n    &#125;\n    std::vector&lt;int&gt; dep(n + 1);\n    std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int fa) &#123;\n        for (auto i : g[x])\n        if (i != fa) &#123;\n            dep[i] = dep[x] + 1;\n            DFS(i, x);\n        &#125;\n        return;\n    &#125;;\n    dep[1] = 1, DFS(1, -1);\n    int p = std::max_element(dep.begin() + 1, dep.end()) - dep.begin();\n    dep[p] = 1, DFS(p, -1);\n    int q = std::max_element(dep.begin() + 1, dep.end()) - dep.begin();\n    std::cout &lt;&lt; (dep[q] + 1) / 2 &lt;&lt; &#39; &#39;;\n    std::vector&lt;int&gt; node;\n    std::vector&lt;std::pair&lt;int, int&gt; &gt; edge;\n    if (dep[q] &amp; 1) &#123;\n        DFS = [&amp;](int x, int fa) &#123;\n            for (auto i : g[x])\n                if (i != fa)\n                    DFS(i, x);\n            if (dep[x] == (dep[q] + 1) / 2)\n                node.push_back(x), edge.emplace_back(x, fa);\n            if (dep[x] == (dep[q] + 1) / 2 + 1)\n                edge.emplace_back(x, fa);\n            return;\n        &#125;;\n        DFS(p, -1);\n    &#125;\n    else &#123;\n        std::function&lt;bool(int, int)&gt; DFS = [&amp;](int x, int fa) &#123;\n            if (x == q)\n                return true;\n            bool ret = false;\n            for (auto i : g[x])\n                if (i != fa)\n                    ret |= DFS(i, x);\n            if (ret &amp;&amp; dep[x] == dep[q] / 2 + 1)\n                edge.emplace_back(x, fa);\n            return ret;\n        &#125;;\n        DFS(p, -1);\n    &#125;\n    long long res = inf;\n    for (auto [x, y] : edge) &#123;\n        std::vector&lt;int&gt; cnt(n + 1);\n        std::function&lt;void(int, int, int)&gt; DFS = [&amp;](int x, int fa, int dep) &#123;\n            int son = 0;\n            for (auto i : g[x])\n                if (i != fa)\n                    ++son, DFS(i, x, dep + 1);\n            cnt[dep] = std::max(cnt[dep], son);\n            return;\n        &#125;;\n        DFS(x, y, 1), DFS(y, x, 1);\n        auto now(2ll);\n        for (int i = 1; i &lt;= n &amp;&amp; cnt[i]; ++i)\n            now *= cnt[i];\n        res = std::min(res, now);\n    &#125;\n    for (auto rt : node) &#123;\n        std::vector&lt;int&gt; cnt(n + 1);\n        std::function&lt;void(int, int, int)&gt; DFS = [&amp;](int x, int fa, int dep) &#123;\n            int son = 0;\n            for (auto i : g[x])\n                if (i != fa)\n                    ++son, DFS(i, x, dep + 1);\n            cnt[dep] = std::max(cnt[dep], son);\n            return;\n        &#125;;\n        DFS(rt, -1, 1);\n        auto now(1ll);\n        for (int i = 1; i &lt;= n &amp;&amp; cnt[i]; ++i)\n            now *= cnt[i];\n        res = std::min(res, now);\n    &#125;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n",
            "tags": [
                "思维"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20240131/",
            "url": "https://xsc062.netlify.app/20240131/",
            "title": "USACO2024JAN 三组连打",
            "date_published": "2024-01-31T02:30:29.000Z",
            "content_html": "<p>假的，只连打了两组。Ag 没时间了。日后再补吧。</p>\n<span id=\"more\"></span>\n<p><img src=\"https://pic.imgdb.cn/item/65b7b152871b83018ac5e7b7.gif\" /></p>\n<p>无意中存了题面，但代码大部分因为系统还原消失了，只有文字题解，将就着看吧。</p>\n<hr />\n<h3 id=\"cu-a.-majority-opinion\">Cu A. Majority Opinion</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P10131\" class=\"uri\">https://www.luogu.com.cn/problem/P10131</a></p>\n<p><em>省流：任意区间内，若某元素出现个数严格大于区间长度一半，则可将整个区间推平为该值。问最终可以使整个序列被推平为哪些值。</em></p>\n<p>注意到当任意长度 <span class=\"math inline\">\\(\\ge 2\\)</span> 的区间可以被推平为某种元素时，整个数列都可以被推平为该元素。故目标转化为对于某种元素判定是否存在一个可被其推平的区间。</p>\n<p>统计元素个数采用前缀和。令 <span class=\"math inline\">\\(s_i\\)</span> 表示 <span class=\"math inline\">\\(h_i\\)</span> 在前 <span class=\"math inline\">\\(i\\)</span> 项中出现的次数，假设有 <span class=\"math inline\">\\([j,i]\\)</span> 满足条件，贪心可知 <span class=\"math inline\">\\(h_i=h_j\\)</span>。</p>\n<p>那么由定义有 <span class=\"math inline\">\\(i-j+1&lt;2\\times (s_i-s_j+1)\\)</span>。典中典，直接移项分离变量。则有 <span class=\"math inline\">\\(i-2\\times s_i-1&lt;j-2\\times s_j\\)</span>。令 <span class=\"math inline\">\\(t_p\\gets p-2\\times s_p\\)</span>，对于每个 <span class=\"math inline\">\\(h\\)</span> 记录 <span class=\"math inline\">\\(t_j\\)</span> 最大值查看是否有 <span class=\"math inline\">\\(i,j\\)</span> 满足条件即可。</p>\n<h3 id=\"cu-b.-cannonball\">Cu B. Cannonball</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P10132\" class=\"uri\">https://www.luogu.com.cn/problem/P10132</a></p>\n<p><em>省流：有 <span class=\"math inline\">\\(N\\)</span> 个格子，从 <span class=\"math inline\">\\(s\\)</span> 格子开始以 <span class=\"math inline\">\\(1\\)</span> 为初始能量向右跳，跳一步的距离为能量大小。格子分两种，一种经过加一定能量并反向，另一种若当前能量大于一定值则可永久摧毁，问跳出范围或无限长时间后可摧毁格子个数。</em></p>\n<p>不难发现若忽略增加能量为 <span class=\"math inline\">\\(0\\)</span> 的跳板则每经过一个跳板可跳距离增加 <span class=\"math inline\">\\(1\\)</span>，最多增加到 <span class=\"math inline\">\\(n\\)</span>，否则会跳出去。</p>\n<p>注意到调和级数，故直接模拟跳的过程。唯一导致时间无限的情况是存在相邻的增加能量为 <span class=\"math inline\">\\(0\\)</span> 的跳板，但其实它具体是什么并不重要，反正我们跳的次数严格大于调和级数后就可以认为进入死循环，直接结束模拟即可。我这里嫌麻烦直接拿了 <span class=\"math inline\">\\(2\\times 10^8\\)</span> 作阈值。</p>\n<h3 id=\"cu-c.-balancing-bacteria\">Cu C. Balancing Bacteria</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P10133\" class=\"uri\">https://www.luogu.com.cn/problem/P10133</a></p>\n<p><em>省流：定义一次操作为选取一个整数 <span class=\"math inline\">\\(\\Delta\\le N\\)</span>，并从 <span class=\"math inline\">\\(N\\)</span> 到 <span class=\"math inline\">\\(1\\)</span>，令 <span class=\"math inline\">\\(a_i\\gets a_i+\\Delta\\)</span> 并令 <span class=\"math inline\">\\(\\Delta\\)</span> 向 <span class=\"math inline\">\\(0\\)</span> 靠近 <span class=\"math inline\">\\(1\\)</span>，<span class=\"math inline\">\\(\\Delta=0\\)</span> 时停止。问令所有 <span class=\"math inline\">\\(a_i=0\\)</span> 所需最少操作次数。</em></p>\n<p>挺有意思的思维题，首先需要进行一个思维转化。<span class=\"math inline\">\\(\\Delta\\le N\\)</span> 是一个利于解题的限制，这意味着我们想让任何一个 <span class=\"math inline\">\\(a_i\\)</span> 改变 <span class=\"math inline\">\\(1\\)</span> 而不影响到之前的值，从让 <span class=\"math inline\">\\(a_1\\gets 0\\)</span> 入手，进行一次操作后每个 <span class=\"math inline\">\\(a_i\\)</span> 分到的 <span class=\"math inline\">\\(\\Delta\\)</span> 应依次加 1 或依次减 1。则差分数组为 <span class=\"math inline\">\\(0\\)</span> 后跟着一截 <span class=\"math inline\">\\(1\\)</span> 是理想状态。中间每有一项不满足规律都会带来额外的操作次数。</p>\n<p>归纳为差分数组的差分数组绝对值之和即为答案。</p>\n<hr />\n<h3 id=\"ag-a.-cowmpetency\">Ag A. Cowmpetency</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P10134\" class=\"uri\">https://www.luogu.com.cn/problem/P10134</a></p>\n<p><em>省流：有若干条限制，每条形如 <span class=\"math inline\">\\(\\max\\limits_{i=1}^{a_h-1}\\{A_i\\}=\\max\\limits_{i=1}^{a_j}\\{A_i\\}\\)</span> 且 <span class=\"math inline\">\\(A_{a_h}&gt;\\max\\limits_{i=1}^{a_h-1}\\{A_i\\}\\)</span>，部分数已知，构造出符合条件且字典序最小的序列。</em></p>\n<p>是本场最难题吧，但也没啥卡的。画个线段图容易发现，若将 <span class=\"math inline\">\\([a,h)\\)</span> 视作一条线段，那么除非 <span class=\"math inline\">\\(h\\)</span> 相同，否则两条线段不能有交集。不然的话就无解。以及如果存在不满足条件的定值也显然无解。</p>\n<p>从前往后看每个 <span class=\"math inline\">\\(h\\)</span> 并尝试赋值，对于每个 <span class=\"math inline\">\\(1\\sim a\\)</span> 记录一个需要满足的最大值数值，按照此数值从后往前填空格。</p>\n<p>填完过后扫一遍看看是不是全部合法，可以证明若此时不合法则无解。</p>\n<h3 id=\"ag-b.-potion-farming\">Ag B. Potion Farming</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P10135\" class=\"uri\">https://www.luogu.com.cn/problem/P10135</a></p>\n<p><em>省流：一棵树，每个点上有若干个物品，对于每条从根到叶子的简单路径，可以选择路径上的一个物品，每个物品只能被选一次，问最多可选物品数。</em></p>\n<p>如果一个点引导的子树下所有叶子有没有分配到的，就可以把这个点的物品分配给该叶子。</p>\n<p>跑一个树形 DP 即可。</p>\n<details>\n<pre class=\"cpp\"><code>namespace XSC062 &#123;\nusing namespace fastIO;\nconst int maxn = 1e5 + 5;\nint n, x, y;\nint cnt[maxn];\nstd::vector&lt;int&gt; g[maxn];\nint a[maxn], f[maxn], p[maxn];\nint min(int x, int y) &#123;\n    return x &lt; y ? x : y;\n&#125;\nvoid DFS(int x, int fa) &#123;\n    if ((int)g[x].size() == 1)\n        cnt[x] = 1;\n    for (auto i : g[x]) &#123;\n        if (i == fa) continue;\n        DFS(i, x);\n        f[x] += f[i];\n        cnt[x] += cnt[i];\n    &#125;\n    if (f[x] &lt; cnt[x])\n        f[x] = min(f[x] + a[x], cnt[x]);\n    return;\n&#125;\nvoid add(int x, int y) &#123;\n    g[x].push_back(y);\n    return;\n&#125;\nint main() &#123;\n    read(n);\n    for (int i = 1; i &lt;= n; ++i) read(p[i]);\n    for (int i = 1; i &lt; n; ++i) &#123;\n        read(x), read(y);\n        add(x, y), add(y, x);\n    &#125;\n    int tot = 0;\n    for (int i = 2; i &lt;= n; ++i)\n        tot += ((int)g[i].size() == 1);\n    for (int i = 1; i &lt;= tot; ++i) ++a[p[i]];\n    DFS(1, -1);\n    print(f[1], &#39;\\n&#39;);\n    return 0;\n&#125;\n&#125; // namespace XSC062</code></pre>\n</details>\n<h3 id=\"ag-c.-cowlendar\">Ag C. Cowlendar</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P10136\" class=\"uri\">https://www.luogu.com.cn/problem/P10136</a></p>\n<p><em>省流：对于给定的序列 <span class=\"math inline\">\\(a\\)</span>，找出所有满足 <span class=\"math inline\">\\(a_i\\bmod L\\)</span> 的值的种类最多为 3 的 <span class=\"math inline\">\\(L\\)</span>。</em></p>\n<p>也是挺有意思的数学题了。若将 <span class=\"math inline\">\\(a_i\\)</span> 按照模 <span class=\"math inline\">\\(L\\)</span> 的情况分组，则对于任意一个 <span class=\"math inline\">\\(a_i\\)</span>，在 <span class=\"math inline\">\\((a_i,a_i+L)\\)</span> 中最多包含两个分别来自其余两组的数。</p>\n<p>对于去重后 <span class=\"math inline\">\\(n&gt;3\\)</span> 的情况，由鸽巢得必定有两个数可分为一组。故我们枚举可能的组间间隔，而可能的 <span class=\"math inline\">\\(L\\)</span> 就是这些间隔的因数。</p>\n<p>由上面我们推出一个合法组间间隔中最多间隔三个数，我们将所有 <span class=\"math inline\">\\(a_{i+3}-a_i\\)</span>、<span class=\"math inline\">\\(a_{i+2}-a_i\\)</span> 和 <span class=\"math inline\">\\(a_{i+1}-a_i\\)</span> 纳入考虑范围即可。对于所有可能的 <span class=\"math inline\">\\(L\\)</span>，直接 <span class=\"math inline\">\\(O(n)\\)</span> 跑一个 <code>check</code> 检查是否合法。</p>\n<p>因子个数照理来说是 <span class=\"math inline\">\\(\\sqrt{V}\\times n\\)</span> 级别的，但是实测 <span class=\"math inline\">\\(n\\)</span> 最多只有一百多。估计是因为 <span class=\"math inline\">\\(n\\)</span> 太大就很难构造出更多的合法解吧。</p>\n<details>\n<pre class=\"cpp\"><code>#define int long long\nnamespace XSC062 &#123;\nusing namespace fastIO;\nconst int maxn = 1e4 + 5;\nconst int maxm = 3e4 + 5;\nstd::set&lt;int&gt; u;\nint n, res, mn, tot;\nint a[maxn], b[maxm];\nbool check(int x) &#123;\n    int l1 = 0, l2 = 0, l3 = 0;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        if (l1 == 0) l1 = a[i];\n        else if (x &amp;&amp; (a[i] - l1) % x == 0) l1 = a[i];\n        else if (l2 == 0) l2 = a[i];\n        else if (x &amp;&amp; (a[i] - l2) % x == 0) l2 = a[i];\n        else if (l3 == 0) l3 = a[i];\n        else if (x &amp;&amp; (a[i] - l3) % x == 0) l3 = a[i];\n        else return 0;\n    &#125;\n    return 1;\n&#125;\nint main() &#123;\n    read(n);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        read(a[i]);\n        if (!mn || a[i] / 4 &lt; mn) mn = a[i] / 4;\n    &#125;\n    std::sort(a + 1, a + n + 1);\n    n = std::unique(a + 1, a + n + 1) - a - 1;\n    if (check(0)) &#123;\n        print(mn * (mn + 1) / 2, &#39;\\n&#39;);\n        return 0;\n    &#125;\n    for (int i = 2; i &lt;= n; ++i) &#123;\n        b[++tot] = a[i] - a[i - 1];\n        if (i &gt;= 3) b[++tot] = a[i] - a[i - 2];\n        if (i &gt;= 4) b[++tot] = a[i] - a[i - 3];\n    &#125;\n    std::sort(b + 1, b + tot + 1);\n    tot = std::unique(b + 1, b + tot + 1) - b - 1;\n    for (int i = 1; i &lt;= tot; ++i) &#123;\n        if (check(b[i])) &#123;\n            for (int j = 1; j * j &lt;= b[i]; ++j) &#123;\n                if (b[i] % j == 0)\n                    u.insert(j), u.insert(b[i] / j);\n            &#125;\n        &#125;\n    &#125;\n    for (auto i : u) &#123;\n        if (i &gt; mn) break;\n        res += i;\n    &#125;\n    print(res, &#39;\\n&#39;);\n    return 0;\n&#125;\n&#125; // namespace XSC062\n#undef int</code></pre>\n<p></deteails></p>\n",
            "tags": [
                "鸽巢原理",
                "调和级数",
                "差分",
                "思维",
                "树形 DP"
            ]
        }
    ]
}