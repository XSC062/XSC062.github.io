{
    "version": "https://jsonfeed.org/version/1",
    "title": "null • All posts by \"思维\" tag",
    "description": "",
    "home_page_url": "https://xsc062.netlify.app",
    "items": [
        {
            "id": "https://xsc062.netlify.app/20251023/",
            "url": "https://xsc062.netlify.app/20251023/",
            "title": "杂题选谈：图论思维题",
            "date_published": "2025-10-23T03:32:05.000Z",
            "content_html": "<p>人类智慧题</p>\n<span id=\"more\"></span>\n<hr />\n<h2 id=\"a---train-splitting\">A - Train Splitting</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/CF1776F\" class=\"uri\">https://www.luogu.com.cn/problem/CF1776F</a></p>\n<ul>\n<li><p>神秘构造题，猜 <span class=\"math inline\">\\(k=2\\)</span> 一定能构造</p></li>\n<li><p>考虑直接从图上抠一个点下来，与之相关的边全部染成 1，剩下的染成 2</p></li>\n<li><p>发现如果恰好选中了菊花的根就不行</p>\n<p>需要找到一个度数不为 <span class=\"math inline\">\\(n-1\\)</span> 的点。完全图的话，从菊花的根上抠一条当颜色 3 即可。</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int T;\n    for (std::cin &gt;&gt; T; T--; ) &#123;\n        int n, m;\n        std::cin &gt;&gt; n &gt;&gt; m;\n        std::vector&lt;int&gt; deg(n + 1);\n        std::vector&lt;std::pair&lt;int, int&gt; &gt; e(m + 1);\n        int pos = -1;\n        for (int i = 1; i &lt;= m; ++i) &#123;\n            std::cin &gt;&gt; e[i].first &gt;&gt; e[i].second;\n            ++deg[e[i].first], ++deg[e[i].second];\n        &#125;\n        for (int i = 1; i &lt;= n; ++i)\n            if (deg[i] != n - 1) &#123;\n                pos = i;\n                break;\n            &#125;\n        if (pos != -1) &#123;\n            std::cout &lt;&lt; 2 &lt;&lt; &#39;\\n&#39;;\n            for (int i = 1; i &lt;= m; ++i)\n                if (e[i].first == pos || e[i].second == pos)\n                    std::cout &lt;&lt; 1 &lt;&lt; &#39; &#39;;\n                else\n                    std::cout &lt;&lt; 2 &lt;&lt; &#39; &#39;;\n            std::cout &lt;&lt; &#39;\\n&#39;;\n        &#125;\n        else &#123;\n            std::cout &lt;&lt; 3 &lt;&lt; &#39;\\n&#39;;\n            pos = 1;\n            bool flag = true;\n            for (int i = 1; i &lt;= m; ++i)\n                if (e[i].first == pos || e[i].second == pos) &#123;\n                    if (flag)\n                        std::cout &lt;&lt; 3 &lt;&lt; &#39; &#39;, flag = false;\n                    else\n                        std::cout &lt;&lt; 1 &lt;&lt; &#39; &#39;;\n                &#125;\n                else\n                    std::cout &lt;&lt; 2 &lt;&lt; &#39; &#39;;\n        &#125;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"b---graph-partition\">B - Graph Partition</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/AT_agc039_b\" class=\"uri\">https://www.luogu.com.cn/problem/AT_agc039_b</a></p>\n<ul>\n<li>考虑二分图染色什么时候不行，即有奇环时</li>\n<li>考虑有多少种颜色时能染奇环，发现都不行，故二分图染色即可判定。</li>\n<li><p>真的只有绿吗？观察样例，猜测答案为图的直径。考虑构造：</p>\n<p>枚举每个点并钦定其为唯一一个 <span class=\"math inline\">\\(1\\)</span>，然后依次向下染色。显然最后构造出来的是合法的。最大为直径长度 + 1。</p>\n<p>也可以从差分约束的角度理解，但无甚必要。</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1), g1(n + 1, std::vector&lt;int&gt; (n + 1, 0x3f3f3f3f));\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        g1[i][i] = 0;\n        for (int j = 1; j &lt;= n; ++j) &#123;\n            char t;\n            std::cin &gt;&gt; t;\n            if (t == &#39;1&#39;)\n                g[i].push_back(j), g1[i][j] = 1;\n        &#125;\n    &#125;\n    std::vector&lt;int&gt; col(n + 1);\n    std::function&lt;bool(int, int)&gt; DFS = [&amp;](int x, int now) &#123;\n        col[x] = now;\n        for (auto i : g[x])\n            if (!col[i]) &#123;\n                if (!DFS(i, 3 - now))\n                    return false;\n            &#125;\n            else if (col[i] == now)\n                return false;\n        return true;\n    &#125;;\n    if (!DFS(1, 1))\n        std::cout &lt;&lt; -1 &lt;&lt; &#39;\\n&#39;;\n    else &#123;\n        for (int k = 1; k &lt;= n; ++k)\n            for (int i = 1; i &lt;= n; ++i)\n                for (int j = 1; j &lt;= n; ++j)\n                    g1[i][j] = std::min(g1[i][j], g1[i][k] + g1[k][j]);\n        int mx = 0;\n        for (int i = 1; i &lt;= n; ++i)\n            for (int j = 1; j &lt;= n; ++j)\n                mx = std::max(mx, g1[i][j] + 1);\n        std::cout &lt;&lt; mx &lt;&lt; &#39;\\n&#39;;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"c---strange-housing\">C - Strange Housing</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/CF1470D\" class=\"uri\">https://www.luogu.com.cn/problem/CF1470D</a></p>\n<ul>\n<li>第一反应是随便找一个生成树然后二分图染色，但是发现有当且仅当奇环时行为不太正确</li>\n<li>考虑打个补丁，抛弃二分图染色的想法，不断尝试染成黑色，如果染了下一个点会出现黑黑边，那就不染它，对得比较显然。</li>\n<li>当且仅当不连通时无解。</li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int T;\n    for (std::cin &gt;&gt; T; T--; ) &#123;\n        int n, m;\n        std::cin &gt;&gt; n &gt;&gt; m;\n        std::vector&lt;int&gt; f(n + 1);\n        std::iota(f.begin() + 1, f.end(), 1);\n        std::function&lt;int(int)&gt; find = [&amp;](int x) &#123;\n            return x == f[x] ? x : f[x] = find(f[x]);\n        &#125;;\n        std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1), g1(n + 1);\n        int cnt = 0;\n        for (int x, y; m--; ) &#123;\n            std::cin &gt;&gt; x &gt;&gt; y;\n            g1[x].push_back(y), g1[y].push_back(x);\n            if (find(x) != find(y)) &#123;\n                f[find(x)] = find(y);\n                ++cnt, g[x].push_back(y), g[y].push_back(x);\n            &#125;\n        &#125;\n        if (cnt != n - 1) &#123;\n            std::cout &lt;&lt; &quot;NO\\n&quot;;\n            continue;\n        &#125;\n        std::vector&lt;int&gt; col(n + 1);\n        std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int fa) &#123;\n            for (auto i : g[x])\n                if (i != fa) &#123;\n                    bool flag = true;\n                    for (auto j : g1[i])\n                        if (col[j] == 2) &#123;\n                            flag = false;\n                            break;\n                        &#125;\n                    if (flag)\n                        col[i] = 2;\n                    else\n                        col[i] = 1;\n                    DFS(i, x);\n                &#125;\n            return;\n        &#125;;\n        col[1] = 2, DFS(1, -1);\n        std::vector&lt;int&gt; res;\n        for (int i = 1; i &lt;= n; ++i)\n            if (col[i] == 2)\n                res.push_back(i);\n        std::cout &lt;&lt; &quot;YES\\n&quot; &lt;&lt; (int)res.size() &lt;&lt; &#39;\\n&#39;;\n        for (auto i : res)\n            std::cout &lt;&lt; i &lt;&lt; &#39; &#39;;\n        std::cout &lt;&lt; &#39;\\n&#39;;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"d---defender-of-childhood-dreams\">D - Defender of Childhood Dreams</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/CF1583F\" class=\"uri\">https://www.luogu.com.cn/problem/CF1583F</a></p>\n<ul>\n<li><p>考虑把每连续 <span class=\"math inline\">\\(k\\)</span> 个点分为一个一级组，每个一级组内全部连 <span class=\"math inline\">\\(1\\)</span> 边。显然组内边最长不超过 <span class=\"math inline\">\\(k-1\\)</span>。</p></li>\n<li><p>接着把每连续 <span class=\"math inline\">\\(k\\)</span> 个一级组分为一个二级组，二级组内空闲边全部涂成颜色 <span class=\"math inline\">\\(2\\)</span>。</p>\n<p>此时 <span class=\"math inline\">\\(a&lt;b\\)</span> 的条件就会派上用场：每个一级组的值域是没有交的，一级组之间的边都是同一个朝向。</p>\n<p>这样就保证由颜色为 <span class=\"math inline\">\\(2\\)</span> 的边构成的连链来自不同的一级组，长度最多为 <span class=\"math inline\">\\(k-1\\)</span>。</p></li>\n<li><p>依次类推，<span class=\"math inline\">\\(i\\)</span> 级组是大小为 <span class=\"math inline\">\\(k^i\\)</span> 的团，故 <span class=\"math inline\">\\(i\\)</span> 最大为 <span class=\"math inline\">\\(\\left\\lceil \\log_kn\\right\\rceil\\)</span>。</p></li>\n<li><p>按上述流程构造，即可 <span class=\"math inline\">\\(O(n^2)\\)</span> 完成。</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, k;\n    std::cin &gt;&gt; n &gt;&gt; k;\n    using arr = std::vector&lt;int&gt;;\n    using brr = std::vector&lt;arr&gt;;\n    brr pos;\n    for (int i = 1; i &lt;= n; ++i)\n        pos.push_back(&#123; i &#125;);\n    brr g(n + 1, arr(n + 1));\n    std::function&lt;void(brr&amp;, int)&gt; calc = [&amp;](brr &amp;pos, int now) &#123;\n        if ((int)pos.size() == 1) &#123;\n            std::cout &lt;&lt; now &lt;&lt; &#39;\\n&#39;;\n            for (int i = 1; i &lt;= n; ++i)\n                for (int j = i + 1; j &lt;= n; ++j)\n                    std::cout &lt;&lt; g[i][j] &lt;&lt; &#39; &#39;;\n            std::cout &lt;&lt; &#39;\\n&#39;;\n            return;\n        &#125;\n        brr p;\n        ++now;\n        for (int i = 0; i &lt; (int)pos.size(); i += k) &#123;\n            p.emplace_back();\n            for (int j = i; j &lt; i + k &amp;&amp; j &lt; (int)pos.size(); ++j) &#123;\n                for (auto a : p.back())\n                    for (auto b : pos[j])\n                        g[a][b] = now;\n                for (auto b : pos[j])\n                    p.back().push_back(b);\n            &#125;\n        &#125;\n        calc(p, now);\n        return;\n    &#125;;\n    calc(pos, 0);\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"e---edge-split\">E - Edge Split</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/CF1726D\" class=\"uri\">https://www.luogu.com.cn/problem/CF1726D</a></p>\n<ul>\n<li>题意有些许歧义，『红色连通块』其实是指删掉蓝边之后的连通块。考虑到 <span class=\"math inline\">\\(m\\le n+2\\)</span> 而不是更多，考虑直接分讨。</li>\n<li>考虑树的情况，对于任意颜色，删一条边就会带来 <span class=\"math inline\">\\(1\\)</span> 个连通块的代价，随便染色即可。</li>\n<li><p>考虑基环树的情况，发现如果环上有某个颜色，那么钦定这个颜色第一次删边删的是环边，就会发现第一次删边不会有代价，故强制环上有两种颜色即可。</p>\n<p>考虑 <span class=\"math inline\">\\(m=n+1\\)</span> 的情况，环可能有下面三种形态：</p>\n<p><img src=\"image.png\" /></p>\n<p>对于第一、二种，保证两个环上都有两种颜色即可，第三种乍一看有点复杂，其实还是一样的，保证两个环都有两种颜色即可，这样三个环显然都会有两种颜色。站在不饱和度的角度，第三个环其实是无意义的。</p></li>\n<li><p>由此类推 <span class=\"math inline\">\\(m=n+2\\)</span> 的情况，发现只需要在并查集连边时令树边为蓝，反祖边为红即可。发现这样会且仅会在第一组样例的情况出问题：</p>\n<figure>\n<img src=\"image-1.png\" alt=\"如果中间的三角形在最后输入就不能得到最优解\" /><figcaption>如果中间的三角形在最后输入就不能得到最优解</figcaption>\n</figure>\n<p>怎么处理这个问题呢，我们使用人类智慧，发现这种情况最后三条红边构成三角形，我们只要发现构造出来的解是这样的三角形，由于造成这一点的顺序很苛刻，故一直 <code>random_shuffle</code> 输入，继续构造直到合法即可。</p>\n<p>（？怎么最优解全是这么做的，我还以为只有我一个人会乱搞。）</p></li>\n<li><p>当不饱和度为 4 的时候就会出现这种结构：</p>\n<p><img src=\"image-2.png\" /></p>\n<p>此时按照刚刚的方法就一定构造不出合法解了。这或许也是 <span class=\"math inline\">\\(m\\le n+2\\)</span> 的原因。</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    std::mt19937 rand(0xabcdef);\n    int T;\n    for (std::cin &gt;&gt; T; T--; ) &#123;\n        int n, m;\n        std::cin &gt;&gt; n &gt;&gt; m;\n        std::vector&lt;int&gt; res(m + 1);\n        std::vector&lt;std::tuple&lt;int, int, int&gt; &gt; e(m + 1);\n        for (int i = 1, x, y; i &lt;= m; ++i) &#123;\n            std::cin &gt;&gt; x &gt;&gt; y;\n            e[i] = &#123; x, y, i &#125;;\n        &#125;\n        auto work = [&amp;](std::vector&lt;std::tuple&lt;int, int, int&gt; &gt; &amp;e) &#123;\n            std::vector&lt;int&gt; f(n + 1);\n            std::iota(f.begin() + 1, f.end(), 1);\n            std::function&lt;int(int)&gt; find = [&amp;](int x) &#123;\n                return x == f[x] ? x : f[x] = find(f[x]);\n            &#125;;\n            std::set&lt;int&gt; t;\n            for (int i = 1; i &lt;= m; ++i) &#123;\n                auto [x, y, id] = e[i];\n                if (find(x) == find(y)) &#123;\n                    t.insert(x), t.insert(y);\n                    res[id] = 1;\n                &#125;\n                else &#123;\n                    res[id] = 0;\n                    f[find(x)] = find(y);\n                &#125;\n            &#125;\n            return (int)t.size() != 3;\n        &#125;;\n        for (; !work(e); std::shuffle(e.begin() + 1, e.end(), rand));\n        for (int i = 1; i &lt;= m; ++i)\n            std::cout &lt;&lt; res[i];\n        std::cout &lt;&lt; &#39;\\n&#39;;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"f---fair-share\">F - Fair Share</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/CF1634E\" class=\"uri\">https://www.luogu.com.cn/problem/CF1634E</a></p>\n<p>原来 <span class=\"math inline\">\\(L=R\\)</span> 是说两个可重集相等 不是说和相等</p>\n<ul>\n<li><p>考虑把所有元素排得整齐一点：同一组的在同一行，同一值的在同一列（显然这就要求每列元素个数为偶）。这样要求就转化为：分组，并满足每行每组各占一半、每列每组各占一半。</p></li>\n<li><p>参考 <a href=\"https://vjudge.net/problem/OpenJ_POJ-C19A\">Ball</a>，用连边可以体现二选一的操作，发现其实二选一就是一选二分之一，故在行列中连边，按照 <span class=\"math inline\">\\((1,2)\\)</span>，<span class=\"math inline\">\\((3,4)\\)</span> 这样连边，就可以满足一选二分之一。</p>\n<p>因为元素可重，所以一行一列可能会有多个元素，这不太好；实际实现时，不妨记输入的第 <span class=\"math inline\">\\(i\\)</span> 个数组第 <span class=\"math inline\">\\(j\\)</span> 个元素为 <span class=\"math inline\">\\(a_{i,j}\\)</span>，实际上连的是 <span class=\"math inline\">\\((a_{i,j},a_{i,j\\oplus 1})\\)</span>；记值为 <span class=\"math inline\">\\(i\\)</span> 的第 <span class=\"math inline\">\\(j\\)</span> 个元素为 <span class=\"math inline\">\\(b_{i,j}\\)</span>，实际上连的是 <span class=\"math inline\">\\((b_{i,j},b_{i,j\\oplus 1})\\)</span>。</p></li>\n<li><p>还是参照 Ball 中二分图的观点，发现这个图很能二分图染色。如果这个解法是足够优的，我们当然希望不包含奇环。由于一个点在 <span class=\"math inline\">\\(a\\)</span> 中至多被连一条边，在 <span class=\"math inline\">\\(b\\)</span> 中也至多被连一条边，所以一条路径一定是 a b 交错的，由此证毕。</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, tot = 0, N = 0;\n    std::cin &gt;&gt; n;\n    std::unordered_map&lt;int, int&gt; tab;\n    std::vector&lt;std::vector&lt;int&gt; &gt; a(n + 1), b(1);\n    for (int i = 1, m; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; m;\n        for (int x; m--; ) &#123;\n            std::cin &gt;&gt; x, ++N;\n            if (!tab.count(x))\n                tab[x] = ++tot, b.emplace_back();\n            a[i].push_back(N);\n            b[tab[x]].push_back(N);\n        &#125;\n    &#125;\n    std::vector&lt;std::vector&lt;int&gt; &gt; g(N + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        for (int j = 0; j &lt; (int)a[i].size(); ++j)\n            g[a[i][j]].push_back(a[i][j ^ 1]);\n    for (int i = 1; i &lt;= tot; ++i) &#123;\n        if ((int)b[i].size() &amp; 1) &#123;\n            std::cout &lt;&lt; &quot;NO\\n&quot;;\n            return 0;\n        &#125;\n        for (int j = 0; j &lt; (int)b[i].size(); ++j)\n            g[b[i][j]].push_back(b[i][j ^ 1]);\n    &#125;\n    std::cout &lt;&lt; &quot;YES\\n&quot;;\n    std::vector&lt;int&gt; col(N + 1);\n    std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int now) &#123;\n        col[x] = now;\n        for (auto i : g[x])\n            if (!col[i])\n                DFS(i, 3 - now);\n            else\n                assert(col[i] != col[x]);\n        return;\n    &#125;;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        for (auto j : a[i]) &#123;\n            if (!col[j])\n                DFS(j, 1);\n            std::cout &lt;&lt; (col[j] == 1 ? &#39;L&#39; : &#39;R&#39;);\n        &#125;\n        std::cout &lt;&lt; &#39;\\n&#39;;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"g---lenient-vertex-cover\">G - Lenient Vertex Cover</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/CF1680F\" class=\"uri\">https://www.luogu.com.cn/problem/CF1680F</a></p>\n<ul>\n<li><p>对于边不被完全覆盖的限制把问题转换成了一个近似二分图染色的形态，一个朴素的做法是枚举这样的边并染色，但似乎没什么优化前途，考虑更加二分图的做法。</p></li>\n<li><p>从非法的角度考虑，相当于是问能不能抠掉 <span class=\"math inline\">\\(\\le 1\\)</span> 条边使图变为二分图。显然这条边（如果存在）在奇环上且是所有奇环的交。</p>\n<p><strong>从合法的角度考虑</strong>，因为不是真的删边，而是相当于把所在的所有环长度 <span class=\"math inline\">\\(-1\\)</span>，所以这条边不能被任何一个偶环包含。</p></li>\n<li><p>容易想到找生成树，标记偶环边并统计奇环。但显然没办法标记到所有偶环边，也没办法统计到所有奇环：</p>\n<p><img src=\"image-3.png\" /></p>\n<details>\n<p><summary>实际上这个做法可以证明是正确的，因为有一个前提：<strong>非树边总是可以和树边成环</strong>。</summary></p>\n<p>考虑两个疑点：</p>\n<ol type=\"1\">\n<li><p>无法标记到所有偶环：当且仅当存在偶环需要 <span class=\"math inline\">\\(\\ge 2\\)</span> 条非树边参与形成。需要证明这样的偶环上的树边不会被选中。</p>\n<p>单看这个环上的树边，形成 <span class=\"math inline\">\\(\\ge 2\\)</span> 个条分立的链。考虑它们在树上是怎么连通的：</p>\n<ul>\n<li><p>中间相隔奇数条树边。那么会被另一条非树边标记为偶环。</p></li>\n<li><p>中间相隔偶数条树边。那么这两条链一定不会被认定为可选的奇环边，因为一条非树边 + 这偶数条边会形成一个新的、与当前偶环分立的奇环。</p>\n<p><img src=\"image-4.png\" /></p></li>\n</ul></li>\n<li><p>无法判定到所有奇环：当且仅当存在奇环需要 <span class=\"math inline\">\\(\\ge 2\\)</span> 条非树边参与形成。需要证明被选中的边被包含在这样的奇环中。</p>\n<p>相似地，单看这个环上的树边，形成 <span class=\"math inline\">\\(\\ge 2\\)</span> 个条分立的链。考虑它们在树上是怎么连通的：</p>\n<ul>\n<li><p>中间相隔偶数条树边。上帝视角下共两个奇环，且公共边为这个奇环中除了另一条非树边以外的所有边。</p>\n<p>实际上的行为也是正确的，另一条非树边参与形成并标记一个偶环，当前非树边形成并标记一个奇环。</p></li>\n<li><p>中间相隔奇数条树边。那么会被另一条非树边标记为偶环，当前奇环中唯一可选的边为当前非树边。</p>\n<p>实际行为也是正确的。比较显然。</p></li>\n</ul>\n<p><img src=\"image-5.png\" /></p></li>\n</ol>\n</details>\n<p>故树上差分维护即可。</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int T;\n    for (std::cin &gt;&gt; T; T--; ) &#123;\n        int n, m;\n        std::cin &gt;&gt; n &gt;&gt; m;\n        std::vector&lt;std::pair&lt;int, int&gt; &gt; e;\n        std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1), g1(n + 1);\n        for (int i = 1, x, y; i &lt;= m; ++i) &#123;\n            std::cin &gt;&gt; x &gt;&gt; y;\n            e.emplace_back(x, y);\n            g1[x].push_back(y), g1[y].push_back(x);\n        &#125;\n        std::vector&lt;int&gt; col(n + 1);\n        std::function&lt;bool(int, int)&gt; DFS = [&amp;](int x, int now) &#123;\n            col[x] = now;\n            for (auto i : g1[x])\n                if (!col[i]) &#123;\n                    if (!DFS(i, 3 - now))\n                        return false;\n                &#125;\n                else if (col[i] == now)\n                    return false;\n            return true;\n        &#125;;\n        if (DFS(1, 1)) &#123;\n            std::cout &lt;&lt; &quot;YES\\n&quot;;\n            for (int i = 1; i &lt;= n; ++i)\n                std::cout &lt;&lt; col[i] - 1;\n            std::cout &lt;&lt; &#39;\\n&#39;;\n            continue;\n        &#125;\n        std::vector&lt;int&gt; f(n + 1);\n        std::iota(f.begin() + 1, f.end(), 1);\n        std::vector&lt;std::pair&lt;int, int&gt; &gt; r;\n        std::function&lt;int(int)&gt; find = [&amp;](int x) &#123; return x == f[x] ? x : f[x] = find(f[x]); &#125;;\n        for (auto [u, v] : e)\n            if (find(u) != find(v)) &#123;\n                f[find(u)] = find(v);\n                // printf(&quot;%d %d \\n&quot;, u, v);\n                g[u].push_back(v), g[v].push_back(u);\n            &#125;\n            else\n                r.emplace_back(u, v);\n        std::vector&lt;int&gt; dep(n + 1), son(n + 1), siz(n + 1), fa(n + 1);\n        std::function&lt;void(int)&gt; DFS1 = [&amp;](int x) &#123;\n            siz[x] = 1;\n            for (auto i : g[x])\n                if (i != fa[x]) &#123;\n                    dep[i] = dep[x] + 1;\n                    fa[i] = x, DFS1(i);\n                    siz[x] += siz[i];\n                    if (siz[i] &gt; siz[son[x]])\n                        son[x] = i;\n                &#125;\n            return;\n        &#125;;\n        dep[1] = 1, DFS1(1);\n        std::vector&lt;int&gt; top(n + 1);\n        DFS1 = [&amp;](int x) &#123;\n            if (son[x])\n                top[son[x]] = top[x], DFS1(son[x]);\n            for (auto i : g[x])\n                if (i != fa[x] &amp;&amp; i != son[x])\n                    top[i] = i, DFS1(i);\n            return;\n        &#125;;\n        top[1] = 1, DFS1(1);\n        auto askLCA = [&amp;](int x, int y) &#123;\n            for (; top[x] != top[y]; x = fa[top[x]])\n                if (dep[top[x]] &lt; dep[top[y]])\n                    std::swap(x, y);\n            return dep[x] &lt; dep[y] ? x : y;\n        &#125;;\n        int cnt = 0;\n        std::pair&lt;int, int&gt; res;\n        std::vector&lt;int&gt; tag(n + 1), s(n + 1);\n        for (auto [u, v] : r) &#123;\n            int fa = askLCA(u, v), dis = dep[u] + dep[v] - 2 * dep[fa];\n            if (dis &amp; 1)\n                ++tag[u], ++tag[v], tag[fa] -= 2;\n            else &#123;\n                res = &#123; 0, 0 &#125;;\n                ++cnt, ++s[u], ++s[v], s[fa] -= 2;\n                if (cnt == 1)\n                    res = &#123; u, v &#125;;\n            &#125;\n        &#125;\n        DFS1 = [&amp;](int x) &#123;\n            for (auto i : g[x])\n                if (i != fa[x]) &#123;\n                    DFS1(i);\n                    tag[x] += tag[i], s[x] += s[i];\n                &#125;\n            if (!tag[x] &amp;&amp; s[x] == cnt &amp;&amp; x != 1)\n                res = &#123; fa[x], x &#125;;\n            return;\n        &#125;;\n        DFS1(1);\n        // printf(&quot;# %d %d \\n&quot;, res.first, res.second);\n        if (res.first) &#123;\n            std::cout &lt;&lt; &quot;YES\\n&quot;;\n            std::fill(col.begin() + 1, col.end(), 0);\n            std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int now) &#123;\n                col[x] = now;\n                for (auto i : g1[x])\n                    if (!col[i])\n                        DFS(i, 3 - now);\n                return;\n            &#125;;\n            col[res.first] = col[res.second] = 2;\n            DFS(res.first, 2), DFS(res.second, 2);\n            for (int i = 1; i &lt;= n; ++i)\n                std::cout &lt;&lt; col[i] - 1;\n            std::cout &lt;&lt; &#39;\\n&#39;;\n        &#125;\n        else\n            std::cout &lt;&lt; &quot;NO\\n&quot;;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"h---four-coloring\">H - Four Coloring</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/AT_code_festival_2017_quala_d\" class=\"uri\">https://www.luogu.com.cn/problem/AT_code_festival_2017_quala_d</a></p>\n<ul>\n<li><p>参见<a href=\"/20231117/#杂项\">切比雪夫距离</a>，则问题转化为，任意点为中心的边长为 <span class=\"math inline\">\\(2d+1\\)</span> 的正方形的边不能和这个点同色</p></li>\n<li><p>直接按照 <span class=\"math inline\">\\(d\\times d\\)</span> 进行划分即可。注意负数除法会影响正确性，故平移到正数即可。</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, m, d;\n    std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; d;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        for (int j = n + 1; j &lt;= n + m; ++j) &#123;\n            int x = (i + j) / d, y = (j - i) / d;\n            if (x % 2 == 0 &amp;&amp; y % 2 == 0)\n                std::cout &lt;&lt; &#39;R&#39;;\n            else if (x % 2 == 0)\n                std::cout &lt;&lt; &#39;Y&#39;;\n            else if (y % 2 == 0)\n                std::cout &lt;&lt; &#39;G&#39;;\n            else\n                std::cout &lt;&lt; &#39;B&#39;;\n        &#125;\n        std::cout &lt;&lt; &#39;\\n&#39;;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"i---diverse-coloring\">I - Diverse Coloring</h2>\n<p><a href=\"https://vjudge.net/contest/759882#problem/I\" class=\"uri\">https://vjudge.net/contest/759882#problem/I</a></p>\n<ul>\n<li>可以很简单地猜到答案为 <span class=\"math inline\">\\(n\\bmod 2\\)</span>，且唯一的例外是样例中 <span class=\"math inline\">\\(n=4\\)</span> 的菊花；</li>\n<li><p>很难理解怎么想到构造方法的：从根节点开始 DFS，先向下递归处理儿子，如果儿子传上来未配对的点则与之配对，否则上传自己。</p>\n<p>这样做之后，除了根可能为孤岛之外，树会被分为若干个大小为 2 或 3 的连通块，此时的染色策略就很明显了。</p>\n<blockquote>\n<p>1 的连通块的存在价值是保证每个点在包含其的连通块内都能解决掉限制，大小 <span class=\"math inline\">\\(=3\\)</span> 的连通块是为了提供 <span class=\"math inline\">\\(1\\)</span> 或 <span class=\"math inline\">\\(-1\\)</span> 的代价用于调整。</p>\n</blockquote></li>\n<li><p>对于孤岛根，一个很好的性质是其儿子所在连通块一定是下面的两层，故大力讨论前三层形态（实际上是前五层）：</p>\n<details>\n<p><summary>神秘枚举</summary></p>\n<p><img src=\"image-6.png\" /></p>\n</details>\n<p>分讨即可。似乎并不用分这么多类，但是实现难度并不高。</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int T;\n    for (std::cin &gt;&gt; T; T--; ) &#123;\n        int n;\n        std::cin &gt;&gt; n;\n        std::vector&lt;int&gt; deg(n + 1);\n        std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);\n        for (int i = 2, fa; i &lt;= n; ++i) &#123;\n            std::cin &gt;&gt; fa;\n            ++deg[fa], ++deg[i];\n            g[fa].push_back(i);\n            if (i == 4 &amp;&amp; *std::max_element(deg.begin() + 1, deg.begin() + 5) == 3)\n                std::cout &lt;&lt; 2 &lt;&lt; &#39;\\n&#39;;\n            else\n                std::cout &lt;&lt; i % 2 &lt;&lt; &#39;\\n&#39;;\n        &#125;\n        std::vector&lt;int&gt; siz(n + 1);\n        std::vector&lt;std::pair&lt;int, int&gt; &gt; p2;\n        std::vector&lt;std::tuple&lt;int, int, int&gt; &gt; p3;\n        std::function&lt;int(int)&gt; DFS = [&amp;](int x) &#123;\n            std::vector&lt;int&gt; p;\n            p.push_back(x);\n            for (auto i : g[x])\n                if (DFS(i) == 1)\n                    p.push_back(i);\n            if ((int)p.size() == 2)\n                p2.emplace_back(p[0], p[1]);\n            else if ((int)p.size() == 3)\n                p3.emplace_back(p[0], p[1], p[2]);\n            siz[x] = (int)p.size();\n            return siz[x];\n        &#125;;\n        std::vector&lt;int&gt; col(n + 1);\n        auto work = [&amp;](int now) &#123;\n            for (auto [x, y] : p2)\n                if (!col[x] &amp;&amp; !col[y])\n                    col[x] = 1;\n            for (auto [x, y, z] : p3)\n                if (!col[x] &amp;&amp; !col[y] &amp;&amp; !col[z]) &#123;\n                    if (now &gt;= 0)\n                        col[x] = 1, --now;\n                    else\n                        col[y] = col[z] = 1, ++now;\n                &#125;\n            for (int i = 1; i &lt;= n; ++i)\n                std::cout &lt;&lt; (col[i] ? &#39;b&#39; : &#39;w&#39;);\n            std::cout &lt;&lt; &#39;\\n&#39;;\n            return;\n        &#125;;\n        DFS(1);\n        int now = 0;\n        if (siz[1] == 1) &#123;\n            if ((int)g[1].size() == 1) &#123;\n                int p2 = g[1][0];\n                if (siz[p2] == 2)\n                    col[p2] = 1, now = -1;\n                else if (n == 4)\n                    col[p2] = 1, now = -1;\n                else &#123;\n                    int p3 = g[g[p2][0]].empty() ? g[p2][1] : g[p2][0], p5 = g[p3][0];\n                    col[p2] = col[p3] = 1;\n                    if (siz[p5] == 2) &#123;\n                        int p6 = siz[g[p5][0]] == 1 ? g[p5][0] : g[p5][1];\n                        col[p6] = 1, now = 0;\n                    &#125;\n                    else &#123;\n                        int p6 = g[p5][0], p7 = g[p5][1];\n                        col[p6] = col[p7] = 1, now = 1;\n                    &#125;\n                &#125;\n            &#125;\n            else &#123;\n                int p2 = g[1][0], p3 = g[1][1];\n                if (siz[p2] &gt; siz[p3])\n                    std::swap(p2, p3);\n                if (siz[p2] == 2 &amp;&amp; siz[p3] == 2)\n                    col[p2] = col[p3] = 1, now = -1;\n                else if (siz[p2] == 2 &amp;&amp; siz[p3] == 3) &#123;\n                    int p4 = siz[g[p2][0]] == 1 ? g[p2][0] : g[p2][1];\n                    col[1] = col[p3] = col[p4] = 1, now = 0;\n                &#125;\n                else &#123;\n                    int p4 = g[p2][0], p5 = g[p2][1];\n                    col[1] = col[p3] = col[p4] = col[p5] = 1, now = 1;\n                &#125;\n            &#125;\n        &#125;\n        work(now);\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"j---graph-coloring\">J - Graph Coloring</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/CF662B\" class=\"uri\">https://www.luogu.com.cn/problem/CF662B</a></p>\n<ul>\n<li><p>首先需要意识到，翻奇数次 / 偶数次可以归到翻 / 不翻的范畴里。</p></li>\n<li><p>不妨枚举最后所有边颜色，那么就可以限定每条边的两端点翻转情况，发现这是并查集，但怎么求最小？难道要 2-SAT 吗？</p></li>\n<li><p>发现最终的并查集一定是两两对应的，对应每一对，取最小开销者即可。</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, m;\n    std::cin &gt;&gt; n &gt;&gt; m;\n    std::vector&lt;std::tuple&lt;int, int, int&gt; &gt; e;\n    for (int i = 1, x, y; i &lt;= m; ++i) &#123;\n        char t;\n        std::cin &gt;&gt; x &gt;&gt; y &gt;&gt; t;\n        e.emplace_back(x, y, t == &#39;R&#39;);\n    &#125;\n    std::vector&lt;int&gt; res1, res2;\n    auto calc = [&amp;](std::vector&lt;int&gt; &amp;res) &#123;\n        std::vector&lt;int&gt; f(2 * n + 1), siz(2 * n + 1);\n        std::iota(f.begin() + 1, f.end(), 1);\n        std::function&lt;int(int)&gt; find = [&amp;](int x) &#123;\n            return x == f[x] ? x : f[x] = find(f[x]);\n        &#125;;\n        auto merge = [&amp;](int x, int y) &#123;\n            f[find(x)] = find(y);\n            return;\n        &#125;;\n        for (auto [x, y, w] : e)\n            if (w)\n                merge(x, y), merge(x + n, y + n);\n            else\n                merge(x, y + n), merge(x + n, y);\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            ++siz[find(i)];\n            if (find(i) == find(n + i))\n                return false;\n        &#125;\n        std::vector&lt;int&gt; tag(2 * n + 1);\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            if (!tag[find(i)]) &#123;\n                tag[find(i)] = tag[find(i + n)] = 1;\n                if (siz[find(i)] &lt;= siz[find(i + n)])\n                    ++tag[find(i)];\n                else\n                    ++tag[find(i + n)];\n            &#125;\n            if (tag[find(i)] == 2)\n                res.push_back(i);\n        &#125;\n        return true;\n    &#125;;\n    auto flag1 = calc(res1);\n    for (auto &amp;[x, y, w] : e)\n        w ^= 1;\n    auto flag2 = calc(res2);\n    if (!flag1 &amp;&amp; !flag2)\n        std::cout &lt;&lt; -1 &lt;&lt; &#39;\\n&#39;;\n    else if (!flag2 || (flag1 &amp;&amp; res1.size() &lt; res2.size())) &#123;\n        std::cout &lt;&lt; (int)res1.size() &lt;&lt; &#39;\\n&#39;;\n        for (auto i : res1)\n            std::cout &lt;&lt; i &lt;&lt; &#39; &#39;;\n        std::cout &lt;&lt; &#39;\\n&#39;;\n    &#125;\n    else &#123;\n        std::cout &lt;&lt; (int)res2.size() &lt;&lt; &#39;\\n&#39;;\n        for (auto i : res2)\n            std::cout &lt;&lt; i &lt;&lt; &#39; &#39;;\n        std::cout &lt;&lt; &#39;\\n&#39;;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n",
            "tags": [
                "并查集",
                "二分图",
                "构造",
                "思维",
                "随机化"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20250717/",
            "url": "https://xsc062.netlify.app/20250717/",
            "title": "杂题选谈：树的各种性质 II",
            "date_published": "2025-07-17T13:09:13.000Z",
            "content_html": "<p>好像确实比斜优做着舒服。</p>\n<span id=\"more\"></span>\n<hr />\n<h2 id=\"a---perfect-matching-on-a-tree\">A - Perfect Matching on a Tree</h2>\n<p><a href=\"https://atcoder.jp/contests/abc362/tasks/abc362_f\" class=\"uri\">https://atcoder.jp/contests/abc362/tasks/abc362_f</a></p>\n<p>肯定直接猜以重心为根。</p>\n<p>至于咋求答案，（显然值是所有点的深度之和），这个我去年在场上被卡住了，还是太菜了。其实是摩尔投票板子。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);\n    for (int i = 1, x, y; i &lt; n; ++i) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y;\n        g[x].push_back(y), g[y].push_back(x);\n    &#125;\n    std::vector&lt;int&gt; siz(n + 1);\n    int rt = 0;\n    std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int fa) &#123;\n        siz[x] = 1;\n        bool flag = 1;\n        for (auto i : g[x])\n            if (i != fa) &#123;\n                DFS(i, x);\n                siz[x] += siz[i];\n                if (siz[i] &gt; n / 2)\n                    flag = 0;\n            &#125;\n        if (flag &amp;&amp; n - siz[x] &lt;= n / 2)\n            rt = x;\n        return;\n    &#125;;\n    DFS(1, -1);\n    std::vector&lt;std::vector&lt;int&gt; &gt; t(n + 1);\n    for (auto i : g[rt]) &#123;\n        DFS = [&amp;](int x, int fa) &#123;\n            t[i].push_back(x);\n            for (auto i : g[x])\n                if (i != fa)\n                    DFS(i, x);\n            return;\n        &#125;;\n        DFS(i, rt);\n    &#125;\n    std::deque&lt;int&gt; p1, p2;\n    int to = n / 2;\n    for (auto i : g[rt]) &#123;\n        auto &amp;q1 = (p1.size() &gt; p2.size() ? p2 : p1), &amp;q2 = (p1.size() &gt; p2.size() ? p1 : p2);\n        for (; !t[i].empty() &amp;&amp; (int)q1.size() &lt; to; q1.push_back(t[i].back()), t[i].pop_back());\n        for (; !t[i].empty() &amp;&amp; (int)q2.size() &lt; to; q2.push_front(t[i].back()), t[i].pop_back());\n    &#125;\n    if (n % 2 == 0)\n        (p1.size() &lt; p2.size() ? p1 : p2).push_back(rt);\n    for (; to--; ) &#123;\n        std::cout &lt;&lt; p1.back() &lt;&lt; &#39; &#39; &lt;&lt; p2.back() &lt;&lt; &#39;\\n&#39;;\n        p1.pop_back(), p2.pop_back();\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"b---miracle-tree\">B - Miracle Tree</h2>\n<p><a href=\"https://atcoder.jp/contests/arc117/tasks/arc117_d\" class=\"uri\">https://atcoder.jp/contests/arc117/tasks/arc117_d</a></p>\n<p>容易发现任取 <span class=\"math inline\">\\(a,b,c\\)</span> 三点，由于它们之间只有一条简单路径，可以视为一条线段，即退化的三角形。那么由三角形三边关系，任取两边之和都大于等于第三边。</p>\n<p>不妨令 <span class=\"math inline\">\\(E(a)&gt;E(b)&gt;E(c)\\)</span>，以 <span class=\"math inline\">\\(d(b,a)+d(b,c)\\ge d(a,c)\\)</span> 举例，有 <span class=\"math inline\">\\(E(a)-E(b)+E(b)-E(c)\\ge d(a,c)\\)</span> 成立；即，若 <span class=\"math inline\">\\((b,a)\\)</span> 和 <span class=\"math inline\">\\((b,c)\\)</span> 分别已经找到可行解，则 <span class=\"math inline\">\\((a,c)\\)</span> 合法。</p>\n<p>从而推断出，按点权将所有点从小到大排序后，只需让任意相邻两点合法，则全树合法。易发现答案是所有相邻两点 <span class=\"math inline\">\\(dis\\)</span> 之和；也即，从任意一点出发，经过全树所有点的路径和。这种问题我们很熟悉，由欧拉序可知是从 <span class=\"math inline\">\\(2(n-1)\\)</span> 个 <span class=\"math inline\">\\(w\\)</span> 中抠走一段路径长（终点到起点）。想要最小化答案就要最大化这段路径长，取直径即可。</p>\n<p>最后的答案序列按照欧拉序直接求即可（注意直径的端点要在序列两端），实现上应该可以有一些 <span class=\"math inline\">\\(O(n)\\)</span> 小巧思。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);\n    for (int i = 1, x, y; i &lt; n; ++i) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y;\n        g[x].push_back(y), g[y].push_back(x);\n    &#125;\n    std::vector&lt;int&gt; dep(n + 1);\n    std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int fa) &#123;\n        for (auto i : g[x])\n            if (i != fa) &#123;\n                dep[i] = dep[x] + 1;\n                DFS(i, x);\n            &#125;\n        return;\n    &#125;;\n    dep[1] = 1, DFS(1, -1);\n    int p = std::max_element(dep.begin() + 1, dep.end()) - dep.begin();\n    dep[p] = 1, DFS(p, -1);\n    int q = std::max_element(dep.begin() + 1, dep.end()) - dep.begin();\n    std::vector&lt;int&gt; tag(n + 1);\n    std::function&lt;bool(int, int)&gt; DFS1 = [&amp;](int x, int fa) &#123;\n        if (x == q) &#123;\n            tag[x] = 1;\n            return true;\n        &#125;\n        for (auto i : g[x])\n            if (i != fa &amp;&amp; DFS1(i, x)) &#123;\n                tag[x] = 1;\n                return true;\n            &#125;\n        return false;\n    &#125;;\n    DFS1(p, -1);\n    std::vector&lt;int&gt; res(n + 1);\n    DFS = [&amp;](int x, int fa) &#123;\n        static int now = 1;\n        int son = 0;\n        if (x != p)\n            res[x] = now;\n        for (auto i : g[x])\n            if (i != fa) &#123;\n                if (tag[i])\n                    son = i;\n                else\n                    ++now, DFS(i, x), ++now;\n            &#125;\n        if (son)\n            ++now, DFS(son, x); // 回不来了，故可以不加 ;-)\n        return;\n    &#125;;\n    res[p] = 1, DFS(p, -1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cout &lt;&lt; res[i] &lt;&lt; &#39; &#39;;\n    std::cout &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"c---树的计数\">C - 树的计数</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P1232\" class=\"uri\">https://www.luogu.com.cn/problem/P1232</a></p>\n<p>需要意识到 DFS 和 BFS 地位是不等价的：二者都有自己相应的性质，但 BFS 的深度性质更易于上手。</p>\n<p>不妨进行重标号，令 BFS 序为 <span class=\"math inline\">\\(1\\sim n\\)</span>。可以在 BFS 中不断进行『分层』得到点的深度信息。发现 <span class=\"math inline\">\\(1\\)</span> 后必须分割一次，除此之外没有 BFS 序本身带来的限制。考虑 DFS 序对深度带来的额外限制：</p>\n<ul>\n<li>对于 <span class=\"math inline\">\\(D_i\\)</span> 和 <span class=\"math inline\">\\(D_{i+1}\\)</span>，则 <span class=\"math inline\">\\(D_{i+1}\\)</span> 的插入位点位于 <span class=\"math inline\">\\(1\\sim D_i\\)</span> 的链上，则 <span class=\"math inline\">\\(dep_{D_{i+1}}\\le dep_{D_i}+1\\)</span>，即 BFS 序中，<span class=\"math inline\">\\([D_i,D_{i+1})\\)</span> 间有至多一个分段点。</li>\n<li>虽然题面没说，但是这里 BFS 和 DFS 遍历儿子的顺序是相同的；由于在 BFS 序中 <span class=\"math inline\">\\(i\\)</span> 先于 <span class=\"math inline\">\\(i+1\\)</span> 被遍历，（由于 <span class=\"math inline\">\\(dep_i\\le dep_{i+1}\\le dep_i+1\\)</span>），故而若 <span class=\"math inline\">\\(dep_i= dep_{i+1}\\)</span>，则 DFS 先遍历 <span class=\"math inline\">\\(i\\)</span>；反之，若 DFS 序中 <span class=\"math inline\">\\(i+1\\)</span> 早于 <span class=\"math inline\">\\(i\\)</span> 出现，BFS 序中 <span class=\"math inline\">\\(i\\)</span> 处必须分层。</li>\n</ul>\n<p>则得到若干条限制，形如某处必须断、某区间必须恰好断一次之类。发现比较难处理的是区间内没有要求『某个点必须断』的情况；<del>可以差分约束</del> 惊讶地发现，这种情况下有 <span class=\"math inline\">\\(D_{i+1}=D_i+1\\)</span>（可以考察第一个满足 <span class=\"math inline\">\\(D_i\\ne i\\)</span> 的点来思考）。这点其实是比较难论证的，所以我也没有想得很清楚；好在信息也不是很要求证明这一块就是了。</p>\n<p>用差分处理『恰好一次』的限制，标记某些点不能断。初始高度为 <span class=\"math inline\">\\(1\\)</span>；每次『必须分段』会带来 <span class=\"math inline\">\\(1\\)</span> 的高度；每次『可能分段』会带来 <span class=\"math inline\">\\(0.5\\)</span> 的高度。加起来就可以了。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;P1232_2.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;int&gt; d(n + 1), b(n + 1), p(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; d[i];\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; b[i], p[b[i]] = i;\n    for (int i = 1; i &lt;= n; ++i)\n        d[i] = p[d[i]];\n    for (int i = 1; i &lt;= n; ++i)\n        p[d[i]] = i;\n    int res = 4;\n    std::vector&lt;int&gt; tag(n + 1), forbid(n + 1);\n    for (int i = 2; i &lt; n; ++i)\n        if (p[i + 1] &lt; p[i])\n            tag[i] = 1;\n    std::partial_sum(tag.begin() + 1, tag.end(), tag.begin() + 1);\n    for (int i = 2; i &lt; n; ++i)\n        if (d[i + 1] &gt; d[i] &amp;&amp; tag[d[i + 1] - 1] - tag[d[i] - 1]) &#123;\n            // fprintf(stderr, &quot;forbid [%d, %d)\\n&quot;, d[i], d[i + 1]);\n            forbid[d[i]] += 1, forbid[d[i + 1]] -= 1;\n        &#125;\n    std::partial_sum(forbid.begin() + 1, forbid.end(), forbid.begin() + 1);\n    for (int i = 2; i &lt; n; ++i)\n        if (p[i] &gt; p[i + 1])\n            res += 2;\n        else if (!forbid[i] &amp;&amp; p[i + 1] == p[i] + 1)\n            res += 1;\n    std::cout &lt;&lt; res / 2;\n    if (res &amp; 1)\n        std::cout &lt;&lt; &quot;.500&quot;;\n    else\n        std::cout &lt;&lt; &quot;.000&quot;;\n    std::cout &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"d---alice-and-bob\">D - Alice and Bob</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P3971\" class=\"uri\">https://www.luogu.com.cn/problem/P3971</a></p>\n<p>一个很显然的想法是 BST；但是这个东西只能求可行解，求不了最优解。</p>\n<p>题解说观察到 <span class=\"math inline\">\\(i\\)</span> 的决策点一定是左侧最靠右的一个 <span class=\"math inline\">\\(a_j=a_i-1\\)</span>（可以假设 <span class=\"math inline\">\\(a_j&gt;a_i\\)</span> 然后反证）。如果把 <span class=\"math inline\">\\(j\\)</span> 向 <span class=\"math inline\">\\(i\\)</span> 连边可以建树；注意到共用一个父亲的点值是递减的。</p>\n<p>要往树上填值。容易想到一层一层填；可惜不最优（反例如下图）。</p>\n<figure>\n<img src=\"image.png\" alt=\"考察从 1 开始的最长下降子序列，发现按层倒序填不优。\" /><figcaption>考察从 1 开始的最长下降子序列，发现按层倒序填不优。</figcaption>\n</figure>\n<p>考虑『以 <span class=\"math inline\">\\(i\\)</span> 开头的最长下降子序列长度』在树上的内涵，发现：</p>\n<ol type=\"1\">\n<li>只能取 <span class=\"math inline\">\\(i\\)</span> 所在子树往右的部分；</li>\n<li>取了祖先就不能取儿子；儿子标号比祖先大；标号越大越能取；最优肯定取叶子。</li>\n</ol>\n<p><strong>想要尽量取满所有 <span class=\"math inline\">\\(i\\)</span> 子树右侧的所有比 <span class=\"math inline\">\\(i\\)</span> 标号大的叶子，就要让它们比 <span class=\"math inline\">\\(i\\)</span> 都小</strong>。这个问题是简单的；一种方法是按儿子标号从大到小，一边 DFS 一边赋值。暂时没想到不用还原序列、log 求答案的统计方法。</p>\n<figure>\n<img src=\"image-1.png\" alt=\"附：两种方式对比\" /><figcaption>附：两种方式对比</figcaption>\n</figure>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 1e5 + 5;\nstruct &#123; int l, r, u; &#125; t[maxn &lt;&lt; 2];\n#define lt (p &lt;&lt; 1)\n#define rt (lt | 1)\nvoid bld(int p, int l, int r) &#123;\n    t[p].l = l, t[p].r = r;\n    if (l == r)\n        return;\n    int mid = (l + r) &gt;&gt; 1;\n    bld(lt, l, mid), bld(rt, mid + 1, r);\n    return;\n&#125;\nvoid add(int p, int x, int v) &#123;\n    t[p].u = std::max(t[p].u, v);\n    if (t[p].l == t[p].r)\n        return;\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (x &lt;= mid)\n        add(lt, x, v);\n    else\n        add(rt, x, v);\n    return;\n&#125;\nint ask(int p, int l, int r) &#123;\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r)\n        return t[p].u;\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1, res = 0;\n    if (l &lt;= mid)\n        res = ask(lt, l, r);\n    if (r &gt; mid)\n        res = std::max(res, ask(rt, l, r));\n    return res;\n&#125;\n#undef lt\n#undef rt\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);\n    std::vector&lt;int&gt; a(n + 1), la(n + 1), deg(n + 1);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; a[i];\n        g[la[a[i] - 1]].push_back(i), ++deg[la[a[i] - 1]];\n        la[a[i]] = i;\n    &#125;\n    std::vector&lt;int&gt; u(n + 1), b(n + 1);\n    std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;\n        static int now = 0;\n        u[x] = now++;\n        std::reverse(g[x].begin(), g[x].end());\n        for (auto i : g[x])\n            DFS(i);\n        return;\n    &#125;;\n    DFS(0);\n    bld(1, 1, n);\n    for (int i = n; i; --i) &#123;\n        b[i] = ask(1, 1, u[i] - 1) + 1;\n        add(1, u[i], b[i]);\n    &#125;\n    // for (int i = 1; i &lt;= n; ++i)\n    //     std::cout &lt;&lt; b[i] &lt;&lt; &#39; &#39;;\n    // std::cout &lt;&lt; &#39;\\n&#39;;\n    std::cout &lt;&lt; std::accumulate(b.begin() + 1, b.end(), 0ll) &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"e---tree-factory\">E - Tree Factory</h2>\n<p><a href=\"https://codeforces.com/problemset/problem/1225/F\" class=\"uri\">https://codeforces.com/problemset/problem/1225/F</a></p>\n<p>首先把题意转化为『每次可以把一个子树下移，要求把一个树转化为一条链』。可以进行一些观察：</p>\n<ul>\n<li>一次移动能产生贡献当且仅当其让树高增加 <span class=\"math inline\">\\(1\\)</span>。</li>\n<li>如果每次移动都产生贡献，易发现答案下界为 <span class=\"math inline\">\\(n-\\sum mxd_i\\)</span>，可以取到。</li>\n</ul>\n<p>看到深度相关就要想到长剖 😅 bro 还没 ptsd</p>\n<p>取以根为 top 的长链，从底到顶依次完成『并到短链所在树上，把树拆成链』的操作。具体过程大概是一个 dfn 的感觉。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);\n    for (int i = 2, x; i &lt;= n; ++i)\n        std::cin &gt;&gt; x, g[x + 1].push_back(i);\n    std::vector&lt;int&gt; mxd(n + 1), son(n + 1), res, nex(n + 1);\n    std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;\n        mxd[x] = 1;\n        for (auto i : g[x]) &#123;\n            DFS(i);\n            if (mxd[i] + 1 &gt; mxd[x])\n                son[x] = i, mxd[x] = mxd[i] + 1;\n        &#125;\n        return;\n    &#125;;\n    DFS(1);\n    std::vector&lt;int&gt; p;\n    for (int i = 1; son[i]; i = son[i])\n        p.push_back(i);\n    std::function&lt;void(int, int)&gt; merge = [&amp;](int son, int x) &#123;\n        int la = son;\n        res.push_back(son);\n        for (auto i : g[x])\n            merge(la, i), la = i;\n        nex[x] = la;\n        return;\n    &#125;;\n    for (int i = (int)p.size() - 1; ~i; --i) &#123;\n        int la = son[p[i]];\n        for (auto j : g[p[i]])\n            if (j != son[p[i]])\n                merge(la, j), la = j;\n        nex[p[i]] = la;\n    &#125;\n    for (int i = 1; i; i = nex[i])\n        std::cout &lt;&lt; i - 1 &lt;&lt; &#39; &#39;;\n    std::cout &lt;&lt; &#39;\\n&#39; &lt;&lt; res.size() &lt;&lt; &#39;\\n&#39;;\n    std::reverse(res.begin(), res.end());\n    for (auto i : res)\n        std::cout &lt;&lt; i - 1 &lt;&lt; &#39; &#39;;\n    std::cout &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n",
            "tags": [
                "思维"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20250716/",
            "url": "https://xsc062.netlify.app/20250716/",
            "title": "杂题选谈：树的各种性质 I",
            "date_published": "2025-07-16T08:17:10.000Z",
            "content_html": "<p>这不比斜优做着爽。</p>\n<span id=\"more\"></span>\n<hr />\n<h2 id=\"a---tree\">A - Tr/ee</h2>\n<p><a href=\"https://atcoder.jp/contests/arc103/tasks/arc103_c\" class=\"uri\">https://atcoder.jp/contests/arc103/tasks/arc103_c</a></p>\n<p>可以发现，类似删边的问题，删出来的连通块当中，靠下的是一个完整的子树；就可以转化为子树问题了。</p>\n<p>容易想到枚举 <span class=\"math inline\">\\(i-1\\)</span> 时树的状态，尝试转化为 <span class=\"math inline\">\\(i\\)</span> 时的状态；进一步可以胡出来一堆方案（大概），这里我胡的是，初始设置一个单点，<span class=\"math inline\">\\(0\\to 1\\)</span> 啥也不干，<span class=\"math inline\">\\(0\\to 0\\)</span> 在当前根上再加一个叶子，<span class=\"math inline\">\\(1\\to 0\\)</span> 新建一个带叶子的根并令其成为当前根的父亲，<span class=\"math inline\">\\(1\\to 1\\)</span> 加一个父亲。</p>\n<p>然后特判一下 <span class=\"math inline\">\\(s_1=0\\)</span> 和 <span class=\"math inline\">\\(s_n=1\\)</span> 和 <span class=\"math inline\">\\(s_i\\ne s_{n-i}\\)</span> 的情况，发现其他时候都有解。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    std::string s;\n    std::cin &gt;&gt; s, n = (int)s.length();\n    s = &quot;#&quot; + s;\n    if (s[1] == &#39;0&#39; || s[n] == &#39;1&#39;) &#123;\n        std::cout &lt;&lt; -1 &lt;&lt; &#39;\\n&#39;;\n        return 0;\n    &#125;\n    for (int i = 1; i &lt; n; ++i)\n        if (s[i] != s[n - i]) &#123;\n            std::cout &lt;&lt; -1 &lt;&lt; &#39;\\n&#39;;\n            return 0;\n        &#125;\n    int tot = 1, rt = 1;\n    for (int i = 2; i &lt; n; ++i) &#123;\n        if (tot == i - 1) &#123;\n            if (s[i] == &#39;0&#39;) &#123;\n                std::cout &lt;&lt; rt &lt;&lt; &#39; &#39; &lt;&lt; ++tot &lt;&lt; &#39;\\n&#39;;\n                rt = tot;\n                std::cout &lt;&lt; rt &lt;&lt; &#39; &#39; &lt;&lt; ++tot &lt;&lt; &#39;\\n&#39;;\n            &#125;\n            else &#123;\n                std::cout &lt;&lt; rt &lt;&lt; &#39; &#39; &lt;&lt; ++tot &lt;&lt; &#39;\\n&#39;;\n                rt = tot;\n            &#125;\n        &#125;\n        else if (s[i] == &#39;0&#39;)\n            std::cout &lt;&lt; rt &lt;&lt; &#39; &#39; &lt;&lt; ++tot &lt;&lt; &#39;\\n&#39;;\n    &#125;\n    if (tot != n)\n        std::cout &lt;&lt; rt &lt;&lt; &#39; &#39; &lt;&lt; n &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"b---keep-perfectly-matched\">B - Keep Perfectly Matched</h2>\n<p><a href=\"https://atcoder.jp/contests/arc183/tasks/arc183_d\" class=\"uri\">https://atcoder.jp/contests/arc183/tasks/arc183_d</a></p>\n<p>发现这个『完美匹配』就是在树上给每个点找相邻点配对，看看能不能配上；继而发现由于点的总数为偶，一个点有且仅能有一个 siz 为奇的子树（不然非法），再发现对于任意一个点，删掉的点对要么来自其同一个子树；要么一个来自其奇子树，另一个来自其偶子树。</p>\n<p>发现要求最大化距离，又只能删叶子，所以需要最小化 LCA 深度；有没有办法让每次的 LCA 都是根呢？让重心成为根，并保证每次操作的两个点都不来自同一个儿子即可（显然这样是完全可能的）。</p>\n<p>接着写了一发发现过不了样例，原因是发现在偶子树中会出现『一个中途的节点本来有一个奇儿子，删去偶子树中的一个叶子后非法』的情况。显然这样的节点是一个偶儿子。确保每个偶儿子的奇儿子先被删掉就可以解决问题。</p>\n<p>对重心的每个儿子，提前规划其节点被删除的顺序即可。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);\n    for (int i = 1, x, y; i &lt; n; ++i) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y;\n        g[x].push_back(y), g[y].push_back(x);\n    &#125;\n    std::vector&lt;int&gt; siz(n + 1);\n    int rt = 0;\n    std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int fa) &#123;\n        siz[x] = 1;\n        bool flag = 1;\n        for (auto i : g[x])\n            if (i != fa) &#123;\n                DFS(i, x);\n                siz[x] += siz[i];\n                if (siz[i] &gt; n / 2)\n                    flag = 0;\n            &#125;\n        if (flag &amp;&amp; n - siz[x] &lt;= n / 2)\n            rt = x;\n        return;\n    &#125;;\n    DFS(1, -1);\n    std::vector&lt;std::vector&lt;int&gt; &gt; lf(n + 1);\n    int f1 = -1;\n    auto comp = [&amp;](int i, int j) &#123; return siz[i] &lt; siz[j]; &#125;;\n    std::priority_queue&lt;int, std::vector&lt;int&gt;, decltype(comp)&gt; f0(comp);\n    siz.assign(n + 1, 0);\n    for (auto t : g[rt]) &#123;\n        DFS = [&amp;](int x, int fa) &#123;\n            siz[x] = 1;\n            for (auto i : g[x])\n                if (i != fa) &#123;\n                    DFS(i, x);\n                    siz[x] += siz[i];\n                &#125;\n            return;\n        &#125;;\n        DFS(t, rt);\n        DFS = [&amp;](int x, int fa) &#123;\n            if (siz[x] % 2 == 0) &#123;\n                for (auto i : g[x])\n                    if (i != fa &amp;&amp; siz[x] % 2 == 1)\n                        DFS(i, x);\n                for (auto i : g[x])\n                    if (i != fa &amp;&amp; siz[x] % 2 == 0)\n                        DFS(i, x);\n            &#125;\n            else\n                for (auto i : g[x])\n                    if (i != fa)\n                        DFS(i, x);\n            lf[t].push_back(x);\n            return;\n        &#125;;\n        DFS(t, rt);\n        if (siz[t] &amp; 1)\n            assert(f1 == -1), f1 = t;\n        else\n            f0.push(t);\n        std::reverse(lf[t].begin(), lf[t].end());\n    &#125;\n    fprintf(stderr, &quot;rt = %d\\n&quot;, rt);\n    assert(~f1);\n    for (int _ = n / 2; _--; ) &#123;\n        assert(~f1);\n        if (!_ &amp;&amp; f0.empty()) &#123;\n            std::cout &lt;&lt; f1 &lt;&lt; &#39; &#39; &lt;&lt; rt &lt;&lt; &#39;\\n&#39;;\n            break;\n        &#125;\n        assert(!f0.empty());\n        int t = f0.top();\n        f0.pop();\n        assert(!lf[f1].empty());\n        assert(!lf[t].empty());\n        std::cout &lt;&lt; lf[f1].back() &lt;&lt; &#39; &#39; &lt;&lt; lf[t].back() &lt;&lt; &#39;\\n&#39;;\n        lf[f1].pop_back(), --siz[f1];\n        lf[t].pop_back(), --siz[t];\n        if (siz[f1])\n            f0.push(f1);\n        f1 = t;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"c---fiolki\">C - Fiolki</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P5578\" class=\"uri\">https://www.luogu.com.cn/problem/P5578</a></p>\n<p>难点在于判断每一步有哪些反应发生；显然一个反应只会在某一步发生。</p>\n<p>发现将倒水的操作视为连边 <span class=\"math inline\">\\(b_i\\to a_i\\)</span>，那么形成了森林，把每个反应丢到 LCA 处等待 check。</p>\n<p>发现在 LCA 之外，两种试剂不可能相遇；故最后遍历一遍反应序列，维护每种药水当前数量，在每个点处 check 即可。</p>\n<p>再发现如果每次加边都在父亲处 check 所有可能发生的反应，复杂度肯定是错的；故用倍增求出两个点在 LCA 下方的点作为『检查点』，当『检查点』被合并到其父亲时，就可以 check 一下检查点上面挂的所有询问。显然每个点上的询问只会被检查一次；复杂度线性。</p>\n<p>加上倍增 LCA 的复杂度，就可以 <span class=\"math inline\">\\(O(n\\log n)\\)</span> 地完成。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, m, k;\n    std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;\n    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);\n    std::vector&lt;int&gt; f(n + 1), deg(n + 1), now(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; now[i];\n    std::iota(f.begin() + 1, f.end(), 1);\n    std::function&lt;int(int)&gt; find = [&amp;](int x) &#123;\n        return x == f[x] ? x : f[x] = find(f[x]);\n    &#125;;\n    auto merge = [&amp;](int x, int y) &#123;\n        f[find(x)] = find(y);\n        return;\n    &#125;;\n    std::vector&lt;std::pair&lt;int, int&gt; &gt; a(m + 1);\n    for (int i = 1; i &lt;= m; ++i) &#123;\n        auto &amp;[x, y] = a[i];\n        std::cin &gt;&gt; x &gt;&gt; y, ++deg[x];\n        g[y].push_back(x), merge(x, y);\n    &#125;\n    std::vector&lt;int&gt; dep(n + 1);\n    std::vector&lt;std::vector&lt;int&gt; &gt; fa(n + 1, std::vector&lt;int&gt; (21));\n    for (int i = 1; i &lt;= n; ++i)\n        if (!deg[i]) &#123;\n            std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;\n                for (auto i : g[x]) &#123;\n                    fa[i][0] = x;\n                    for (int j = 1; j &lt;= 20; ++j)\n                        fa[i][j] = fa[fa[i][j - 1]][j - 1];\n                    dep[i] = dep[x] + 1, DFS(i);\n                &#125;\n                return;\n            &#125;;\n            dep[i] = 1, DFS(i);\n        &#125;\n    std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; t(n + 1);\n    for (int x, y; k--; ) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y;\n        if (find(x) == find(y)) &#123;\n            std::pair&lt;int, int&gt; p(x, y);\n            if (dep[x] != dep[y]) &#123;\n                if (dep[x] &lt; dep[y])\n                    std::swap(x, y);\n                for (int i = 20; ~i; --i)\n                    if (dep[fa[x][i]] &gt; dep[y])\n                        x = fa[x][i];\n                if (fa[x][0] == y) &#123;\n                    t[x].push_back(p);\n                    // printf(&quot;add (%d, %d) to %d\\n&quot;, p.first, p.second, x);\n                    continue;\n                &#125;\n                x = fa[x][0];\n            &#125;\n            for (int i = 20; ~i; --i)\n                if (fa[x][i] != fa[y][i])\n                    x = fa[x][i], y = fa[y][i];\n            t[x].push_back(p), t[y].push_back(p);\n        &#125;\n    &#125;\n    std::iota(f.begin() + 1, f.end(), 1);\n    auto res(0ll);\n    for (int i = 1; i &lt;= m; ++i) &#123;\n        auto [x, y] = a[i];\n        merge(x, y);\n        for (auto [p, q] : t[x])\n            if (find(p) == find(x) &amp;&amp; find(q) == find(x)) &#123;\n                int u = std::min(now[p], now[q]);\n                res += 2 * u, now[p] -= u, now[q] -= u;\n            &#125;\n    &#125;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125; </code></pre>\n</details>\n<hr />\n<h2 id=\"d---permutation-tree\">D - Permutation Tree</h2>\n<p><a href=\"https://atcoder.jp/contests/arc095/tasks/arc095_d\" class=\"uri\">https://atcoder.jp/contests/arc095/tasks/arc095_d</a></p>\n<p>随便画图，会发现，如果按层数从小到大标号，一个点的儿子只有最多一个不是叶子。一言以蔽之：毛毛虫。</p>\n<p>然后就可以判断可行性了（直径就是虫身）。接下来需要考虑最小化答案字典序的问题，发现对于一个点的儿子，必须是虫足在其左、虫身在其右且必须严格按照层数标号。</p>\n<p>字典序是个偏贪心的东西，所以可以开始瞎搞：发现虫足越多，标号更小的父亲就会越靠后，所以依次比较用两端开头的情况，如果到了虫身的某一段，哪种的儿子更少就选谁，然后直接按最小来标号即可。</p>\n<p>实际上由于只有两种方案，你也可以两边都试试（）</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);\n    for (int i = 1, x, y; i &lt; n; ++i) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y;\n        g[x].push_back(y), g[y].push_back(x);\n    &#125;\n    std::vector&lt;int&gt; dep(n + 1);\n    std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int fa) &#123;\n        for (auto i : g[x])\n            if (i != fa) &#123;\n                dep[i] = dep[x] + 1;\n                DFS(i, x);\n            &#125;\n        return;\n    &#125;;\n    dep[1] = 1, DFS(1, -1);\n    int p = std::max_element(dep.begin() + 1, dep.end()) - dep.begin();\n    bool flag = 0;\n    std::vector&lt;int&gt; node, cnt(n + 1), siz(n + 1);\n    DFS = [&amp;](int x, int fa) &#123;\n        siz[x] = 1;\n        for (auto i : g[x])\n            if (i != fa) &#123;\n                DFS(i, x);\n                siz[x] += siz[i], ++cnt[x];\n            &#125;\n        if (siz[x] &gt; 1) &#123;\n            node.push_back(0), --cnt[x];\n            for (auto i : g[x]) &#123;\n                if (i != fa &amp;&amp; siz[node.back()] &gt; 1 &amp;&amp; siz[i] &gt; 1)\n                    flag = 1;\n                if (i != fa &amp;&amp; siz[i] &gt; siz[node.back()])\n                    node.back() = i;\n            &#125;\n        &#125;\n        return;\n    &#125;;\n    DFS(p, -1), node.push_back(p);\n    if (flag) &#123;\n        std::cout &lt;&lt; -1 &lt;&lt; &#39;\\n&#39;;\n        return 0;\n    &#125;\n    for (int i = 0, j = (int)node.size() - 1; i &lt;= j; ++i, --j)\n        if (cnt[node[i]] &gt; cnt[node[j]]) &#123;\n            std::reverse(node.begin(), node.end());\n            break;\n        &#125;\n        else if (cnt[node[i]] &lt; cnt[node[j]])\n            break;\n    int now = 0;\n    for (auto i : node) &#123;\n        int rt = ++now;\n        for (; cnt[i]--; std::cout &lt;&lt; ++now &lt;&lt; &#39; &#39;);\n        std::cout &lt;&lt; rt &lt;&lt; &#39; &#39;;\n    &#125;\n    std::cout &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"e---isomorphism-freak\">E - Isomorphism Freak</h2>\n<p><a href=\"https://atcoder.jp/contests/agc024/tasks/agc024_d\" class=\"uri\">https://atcoder.jp/contests/agc024/tasks/agc024_d</a></p>\n<p><del>像在数有多少种化学环境的 H 是可以说的吗</del></p>\n<p>鉴于这个，高中化学选择性必修三，给我们打下的坚实基础，我们可以非常迅速地注意到答案就是半径长。</p>\n<p>然后最少叶子，发现一眼瞪不出来，糟糕！没关系，观察样例输出，发现这些答案的因数都挺多，故猜测是若干个数乘起来的；然后再发现是每层最大儿子数的乘积。</p>\n<p>枚举中间的边（仅当直径长度为偶时）、点（奇偶都行）作为对称轴 / 对称中心的情况取 min 即可（原因是要尽量取靠近中心的 <strong>点</strong>），注意边两端算两个儿子数。</p>\n<p><del>所以为啥 <span class=\"math inline\">\\(n\\)</span> 这么小</del></p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst long long inf = 1e18;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);\n    for (int i = 1, x, y; i &lt; n; ++i) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y;\n        g[x].push_back(y), g[y].push_back(x);\n    &#125;\n    std::vector&lt;int&gt; dep(n + 1);\n    std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int fa) &#123;\n        for (auto i : g[x])\n        if (i != fa) &#123;\n            dep[i] = dep[x] + 1;\n            DFS(i, x);\n        &#125;\n        return;\n    &#125;;\n    dep[1] = 1, DFS(1, -1);\n    int p = std::max_element(dep.begin() + 1, dep.end()) - dep.begin();\n    dep[p] = 1, DFS(p, -1);\n    int q = std::max_element(dep.begin() + 1, dep.end()) - dep.begin();\n    std::cout &lt;&lt; (dep[q] + 1) / 2 &lt;&lt; &#39; &#39;;\n    std::vector&lt;int&gt; node;\n    std::vector&lt;std::pair&lt;int, int&gt; &gt; edge;\n    if (dep[q] &amp; 1) &#123;\n        DFS = [&amp;](int x, int fa) &#123;\n            for (auto i : g[x])\n                if (i != fa)\n                    DFS(i, x);\n            if (dep[x] == (dep[q] + 1) / 2)\n                node.push_back(x), edge.emplace_back(x, fa);\n            if (dep[x] == (dep[q] + 1) / 2 + 1)\n                edge.emplace_back(x, fa);\n            return;\n        &#125;;\n        DFS(p, -1);\n    &#125;\n    else &#123;\n        std::function&lt;bool(int, int)&gt; DFS = [&amp;](int x, int fa) &#123;\n            if (x == q)\n                return true;\n            bool ret = false;\n            for (auto i : g[x])\n                if (i != fa)\n                    ret |= DFS(i, x);\n            if (ret &amp;&amp; dep[x] == dep[q] / 2 + 1)\n                edge.emplace_back(x, fa);\n            return ret;\n        &#125;;\n        DFS(p, -1);\n    &#125;\n    long long res = inf;\n    for (auto [x, y] : edge) &#123;\n        std::vector&lt;int&gt; cnt(n + 1);\n        std::function&lt;void(int, int, int)&gt; DFS = [&amp;](int x, int fa, int dep) &#123;\n            int son = 0;\n            for (auto i : g[x])\n                if (i != fa)\n                    ++son, DFS(i, x, dep + 1);\n            cnt[dep] = std::max(cnt[dep], son);\n            return;\n        &#125;;\n        DFS(x, y, 1), DFS(y, x, 1);\n        auto now(2ll);\n        for (int i = 1; i &lt;= n &amp;&amp; cnt[i]; ++i)\n            now *= cnt[i];\n        res = std::min(res, now);\n    &#125;\n    for (auto rt : node) &#123;\n        std::vector&lt;int&gt; cnt(n + 1);\n        std::function&lt;void(int, int, int)&gt; DFS = [&amp;](int x, int fa, int dep) &#123;\n            int son = 0;\n            for (auto i : g[x])\n                if (i != fa)\n                    ++son, DFS(i, x, dep + 1);\n            cnt[dep] = std::max(cnt[dep], son);\n            return;\n        &#125;;\n        DFS(rt, -1, 1);\n        auto now(1ll);\n        for (int i = 1; i &lt;= n &amp;&amp; cnt[i]; ++i)\n            now *= cnt[i];\n        res = std::min(res, now);\n    &#125;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n",
            "tags": [
                "思维"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20240131/",
            "url": "https://xsc062.netlify.app/20240131/",
            "title": "解题报告：USACO2024JAN",
            "date_published": "2024-01-31T02:30:29.000Z",
            "content_html": "<p>假的，只连打了两组。Ag 没时间了。日后再补吧。</p>\n<span id=\"more\"></span>\n<p><img src=\"https://pic.imgdb.cn/item/65b7b152871b83018ac5e7b7.gif\" /></p>\n<p>无意中存了题面，但代码大部分因为系统还原消失了，只有文字题解，将就着看吧。</p>\n<hr />\n<h3 id=\"cu-a.-majority-opinion\">Cu A. Majority Opinion</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P10131\" class=\"uri\">https://www.luogu.com.cn/problem/P10131</a></p>\n<p><em>省流：任意区间内，若某元素出现个数严格大于区间长度一半，则可将整个区间推平为该值。问最终可以使整个序列被推平为哪些值。</em></p>\n<p>注意到当任意长度 <span class=\"math inline\">\\(\\ge 2\\)</span> 的区间可以被推平为某种元素时，整个数列都可以被推平为该元素。故目标转化为对于某种元素判定是否存在一个可被其推平的区间。</p>\n<p>统计元素个数采用前缀和。令 <span class=\"math inline\">\\(s_i\\)</span> 表示 <span class=\"math inline\">\\(h_i\\)</span> 在前 <span class=\"math inline\">\\(i\\)</span> 项中出现的次数，假设有 <span class=\"math inline\">\\([j,i]\\)</span> 满足条件，贪心可知 <span class=\"math inline\">\\(h_i=h_j\\)</span>。</p>\n<p>那么由定义有 <span class=\"math inline\">\\(i-j+1&lt;2\\times (s_i-s_j+1)\\)</span>。典中典，直接移项分离变量。则有 <span class=\"math inline\">\\(i-2\\times s_i-1&lt;j-2\\times s_j\\)</span>。令 <span class=\"math inline\">\\(t_p\\gets p-2\\times s_p\\)</span>，对于每个 <span class=\"math inline\">\\(h\\)</span> 记录 <span class=\"math inline\">\\(t_j\\)</span> 最大值查看是否有 <span class=\"math inline\">\\(i,j\\)</span> 满足条件即可。</p>\n<h3 id=\"cu-b.-cannonball\">Cu B. Cannonball</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P10132\" class=\"uri\">https://www.luogu.com.cn/problem/P10132</a></p>\n<p><em>省流：有 <span class=\"math inline\">\\(N\\)</span> 个格子，从 <span class=\"math inline\">\\(s\\)</span> 格子开始以 <span class=\"math inline\">\\(1\\)</span> 为初始能量向右跳，跳一步的距离为能量大小。格子分两种，一种经过加一定能量并反向，另一种若当前能量大于一定值则可永久摧毁，问跳出范围或无限长时间后可摧毁格子个数。</em></p>\n<p>不难发现若忽略增加能量为 <span class=\"math inline\">\\(0\\)</span> 的跳板则每经过一个跳板可跳距离增加 <span class=\"math inline\">\\(1\\)</span>，最多增加到 <span class=\"math inline\">\\(n\\)</span>，否则会跳出去。</p>\n<p>注意到调和级数，故直接模拟跳的过程。唯一导致时间无限的情况是存在相邻的增加能量为 <span class=\"math inline\">\\(0\\)</span> 的跳板，但其实它具体是什么并不重要，反正我们跳的次数严格大于调和级数后就可以认为进入死循环，直接结束模拟即可。我这里嫌麻烦直接拿了 <span class=\"math inline\">\\(2\\times 10^8\\)</span> 作阈值。</p>\n<h3 id=\"cu-c.-balancing-bacteria\">Cu C. Balancing Bacteria</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P10133\" class=\"uri\">https://www.luogu.com.cn/problem/P10133</a></p>\n<p><em>省流：定义一次操作为选取一个整数 <span class=\"math inline\">\\(\\Delta\\le N\\)</span>，并从 <span class=\"math inline\">\\(N\\)</span> 到 <span class=\"math inline\">\\(1\\)</span>，令 <span class=\"math inline\">\\(a_i\\gets a_i+\\Delta\\)</span> 并令 <span class=\"math inline\">\\(\\Delta\\)</span> 向 <span class=\"math inline\">\\(0\\)</span> 靠近 <span class=\"math inline\">\\(1\\)</span>，<span class=\"math inline\">\\(\\Delta=0\\)</span> 时停止。问令所有 <span class=\"math inline\">\\(a_i=0\\)</span> 所需最少操作次数。</em></p>\n<p>挺有意思的思维题，首先需要进行一个思维转化。<span class=\"math inline\">\\(\\Delta\\le N\\)</span> 是一个利于解题的限制，这意味着我们想让任何一个 <span class=\"math inline\">\\(a_i\\)</span> 改变 <span class=\"math inline\">\\(1\\)</span> 而不影响到之前的值，从让 <span class=\"math inline\">\\(a_1\\gets 0\\)</span> 入手，进行一次操作后每个 <span class=\"math inline\">\\(a_i\\)</span> 分到的 <span class=\"math inline\">\\(\\Delta\\)</span> 应依次加 1 或依次减 1。则差分数组为 <span class=\"math inline\">\\(0\\)</span> 后跟着一截 <span class=\"math inline\">\\(1\\)</span> 是理想状态。中间每有一项不满足规律都会带来额外的操作次数。</p>\n<p>归纳为差分数组的差分数组绝对值之和即为答案。</p>\n<hr />\n<h3 id=\"ag-a.-cowmpetency\">Ag A. Cowmpetency</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P10134\" class=\"uri\">https://www.luogu.com.cn/problem/P10134</a></p>\n<p><em>省流：有若干条限制，每条形如 <span class=\"math inline\">\\(\\max\\limits_{i=1}^{a_h-1}\\{A_i\\}=\\max\\limits_{i=1}^{a_j}\\{A_i\\}\\)</span> 且 <span class=\"math inline\">\\(A_{a_h}&gt;\\max\\limits_{i=1}^{a_h-1}\\{A_i\\}\\)</span>，部分数已知，构造出符合条件且字典序最小的序列。</em></p>\n<p>是本场最难题吧，但也没啥卡的。画个线段图容易发现，若将 <span class=\"math inline\">\\([a,h)\\)</span> 视作一条线段，那么除非 <span class=\"math inline\">\\(h\\)</span> 相同，否则两条线段不能有交集。不然的话就无解。以及如果存在不满足条件的定值也显然无解。</p>\n<p>从前往后看每个 <span class=\"math inline\">\\(h\\)</span> 并尝试赋值，对于每个 <span class=\"math inline\">\\(1\\sim a\\)</span> 记录一个需要满足的最大值数值，按照此数值从后往前填空格。</p>\n<p>填完过后扫一遍看看是不是全部合法，可以证明若此时不合法则无解。</p>\n<h3 id=\"ag-b.-potion-farming\">Ag B. Potion Farming</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P10135\" class=\"uri\">https://www.luogu.com.cn/problem/P10135</a></p>\n<p><em>省流：一棵树，每个点上有若干个物品，对于每条从根到叶子的简单路径，可以选择路径上的一个物品，每个物品只能被选一次，问最多可选物品数。</em></p>\n<p>如果一个点引导的子树下所有叶子有没有分配到的，就可以把这个点的物品分配给该叶子。</p>\n<p>跑一个树形 DP 即可。</p>\n<details>\n<pre class=\"cpp\"><code>namespace XSC062 &#123;\nusing namespace fastIO;\nconst int maxn = 1e5 + 5;\nint n, x, y;\nint cnt[maxn];\nstd::vector&lt;int&gt; g[maxn];\nint a[maxn], f[maxn], p[maxn];\nint min(int x, int y) &#123;\n    return x &lt; y ? x : y;\n&#125;\nvoid DFS(int x, int fa) &#123;\n    if ((int)g[x].size() == 1)\n        cnt[x] = 1;\n    for (auto i : g[x]) &#123;\n        if (i == fa) continue;\n        DFS(i, x);\n        f[x] += f[i];\n        cnt[x] += cnt[i];\n    &#125;\n    if (f[x] &lt; cnt[x])\n        f[x] = min(f[x] + a[x], cnt[x]);\n    return;\n&#125;\nvoid add(int x, int y) &#123;\n    g[x].push_back(y);\n    return;\n&#125;\nint main() &#123;\n    read(n);\n    for (int i = 1; i &lt;= n; ++i) read(p[i]);\n    for (int i = 1; i &lt; n; ++i) &#123;\n        read(x), read(y);\n        add(x, y), add(y, x);\n    &#125;\n    int tot = 0;\n    for (int i = 2; i &lt;= n; ++i)\n        tot += ((int)g[i].size() == 1);\n    for (int i = 1; i &lt;= tot; ++i) ++a[p[i]];\n    DFS(1, -1);\n    print(f[1], &#39;\\n&#39;);\n    return 0;\n&#125;\n&#125; // namespace XSC062</code></pre>\n</details>\n<h3 id=\"ag-c.-cowlendar\">Ag C. Cowlendar</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P10136\" class=\"uri\">https://www.luogu.com.cn/problem/P10136</a></p>\n<p><em>省流：对于给定的序列 <span class=\"math inline\">\\(a\\)</span>，找出所有满足 <span class=\"math inline\">\\(a_i\\bmod L\\)</span> 的值的种类最多为 3 的 <span class=\"math inline\">\\(L\\)</span>。</em></p>\n<p>也是挺有意思的数学题了。若将 <span class=\"math inline\">\\(a_i\\)</span> 按照模 <span class=\"math inline\">\\(L\\)</span> 的情况分组，则对于任意一个 <span class=\"math inline\">\\(a_i\\)</span>，在 <span class=\"math inline\">\\((a_i,a_i+L)\\)</span> 中最多包含两个分别来自其余两组的数。</p>\n<p>对于去重后 <span class=\"math inline\">\\(n&gt;3\\)</span> 的情况，由鸽巢得必定有两个数可分为一组。故我们枚举可能的组间间隔，而可能的 <span class=\"math inline\">\\(L\\)</span> 就是这些间隔的因数。</p>\n<p>由上面我们推出一个合法组间间隔中最多间隔三个数，我们将所有 <span class=\"math inline\">\\(a_{i+3}-a_i\\)</span>、<span class=\"math inline\">\\(a_{i+2}-a_i\\)</span> 和 <span class=\"math inline\">\\(a_{i+1}-a_i\\)</span> 纳入考虑范围即可。对于所有可能的 <span class=\"math inline\">\\(L\\)</span>，直接 <span class=\"math inline\">\\(O(n)\\)</span> 跑一个 <code>check</code> 检查是否合法。</p>\n<p>因子个数照理来说是 <span class=\"math inline\">\\(\\sqrt{V}\\times n\\)</span> 级别的，但是实测 <span class=\"math inline\">\\(n\\)</span> 最多只有一百多。估计是因为 <span class=\"math inline\">\\(n\\)</span> 太大就很难构造出更多的合法解吧。</p>\n<details>\n<pre class=\"cpp\"><code>#define int long long\nnamespace XSC062 &#123;\nusing namespace fastIO;\nconst int maxn = 1e4 + 5;\nconst int maxm = 3e4 + 5;\nstd::set&lt;int&gt; u;\nint n, res, mn, tot;\nint a[maxn], b[maxm];\nbool check(int x) &#123;\n    int l1 = 0, l2 = 0, l3 = 0;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        if (l1 == 0) l1 = a[i];\n        else if (x &amp;&amp; (a[i] - l1) % x == 0) l1 = a[i];\n        else if (l2 == 0) l2 = a[i];\n        else if (x &amp;&amp; (a[i] - l2) % x == 0) l2 = a[i];\n        else if (l3 == 0) l3 = a[i];\n        else if (x &amp;&amp; (a[i] - l3) % x == 0) l3 = a[i];\n        else return 0;\n    &#125;\n    return 1;\n&#125;\nint main() &#123;\n    read(n);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        read(a[i]);\n        if (!mn || a[i] / 4 &lt; mn) mn = a[i] / 4;\n    &#125;\n    std::sort(a + 1, a + n + 1);\n    n = std::unique(a + 1, a + n + 1) - a - 1;\n    if (check(0)) &#123;\n        print(mn * (mn + 1) / 2, &#39;\\n&#39;);\n        return 0;\n    &#125;\n    for (int i = 2; i &lt;= n; ++i) &#123;\n        b[++tot] = a[i] - a[i - 1];\n        if (i &gt;= 3) b[++tot] = a[i] - a[i - 2];\n        if (i &gt;= 4) b[++tot] = a[i] - a[i - 3];\n    &#125;\n    std::sort(b + 1, b + tot + 1);\n    tot = std::unique(b + 1, b + tot + 1) - b - 1;\n    for (int i = 1; i &lt;= tot; ++i) &#123;\n        if (check(b[i])) &#123;\n            for (int j = 1; j * j &lt;= b[i]; ++j) &#123;\n                if (b[i] % j == 0)\n                    u.insert(j), u.insert(b[i] / j);\n            &#125;\n        &#125;\n    &#125;\n    for (auto i : u) &#123;\n        if (i &gt; mn) break;\n        res += i;\n    &#125;\n    print(res, &#39;\\n&#39;);\n    return 0;\n&#125;\n&#125; // namespace XSC062\n#undef int</code></pre>\n<p></deteails></p>\n",
            "tags": [
                "鸽巢原理",
                "调和级数",
                "差分",
                "思维",
                "树形 DP"
            ]
        }
    ]
}