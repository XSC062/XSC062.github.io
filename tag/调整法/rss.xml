<?xml version="1.0"?>
<rss version="2.0">
    <channel>
        <title> • Posts by &#34;调整法&#34; tag</title>
        <link>https://xsc062.netlify.app</link>
        <description></description>
        <language>zh-CN</language>
        <pubDate>Wed, 24 Sep 2025 14:27:15 +0800</pubDate>
        <lastBuildDate>Wed, 24 Sep 2025 14:27:15 +0800</lastBuildDate>
        <category>并查集</category>
        <category>斜率优化</category>
        <category>悬线法</category>
        <category>哈希</category>
        <category>字典树</category>
        <category>DP</category>
        <category>单调队列</category>
        <category>分治</category>
        <category>计数</category>
        <category>容斥</category>
        <category>二分图</category>
        <category>CRT / exCRT</category>
        <category>排列组合</category>
        <category>网络流</category>
        <category>二分</category>
        <category>容斥原理</category>
        <category>线段树</category>
        <category>树状数组</category>
        <category>区间 DP</category>
        <category>构造</category>
        <category>数据结构</category>
        <category>Tarjan</category>
        <category>下饭</category>
        <category>李超线段树</category>
        <category>树链剖分</category>
        <category>LCA</category>
        <category>倍增</category>
        <category>鸽巢原理</category>
        <category>数学</category>
        <category>调和级数</category>
        <category>差分</category>
        <category>思维</category>
        <category>树形 DP</category>
        <category>最小生成树</category>
        <category>状压</category>
        <category>高维前缀和</category>
        <category>SAM</category>
        <category>分块</category>
        <category>可持久化</category>
        <category>笛卡尔树</category>
        <category>闲话</category>
        <category>欧拉回路</category>
        <category>长链剖分</category>
        <category>KMP</category>
        <category>border</category>
        <category>随机化</category>
        <category>字符串</category>
        <category>AC 自动机</category>
        <category>SA</category>
        <category>树上差分</category>
        <category>FWT</category>
        <category>堆</category>
        <category>树的重心</category>
        <category>贪心</category>
        <category>均摊</category>
        <category>优化建图</category>
        <category>反悔贪心</category>
        <category>调整法</category>
        <category>背包</category>
        <category>博弈论</category>
        <category>DP 优化</category>
        <category>虚树</category>
        <category>点分治</category>
        <category>四边形不等式</category>
        <category>支配对</category>
        <category>DDP</category>
        <category>CDQ 分治</category>
        <category>猫树</category>
        <category>DP 套 DP</category>
        <category>Kruskal 重构树</category>
        <category>高精度</category>
        <category>最短路</category>
        <category>树套树</category>
        <category>二项式反演</category>
        <category>搜索</category>
        <item>
            <guid isPermalink="true">https://xsc062.netlify.app/20250924/</guid>
            <title>最短路练习</title>
            <link>https://xsc062.netlify.app/20250924/</link>
            <category>DP</category>
            <category>二分</category>
            <category>倍增</category>
            <category>调整法</category>
            <category>最短路</category>
            <pubDate>Wed, 24 Sep 2025 14:27:15 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;最短路为背景的题 + 做法是最短路的题&lt;/p&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;a---minimum-path&#34;&gt;A - Minimum Path&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/CF1473E&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/CF1473E&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;经典套路，发现可以把 max 和 min 换成任意路径中的边，然后 max 和 min 就会最小化这个式子&lt;/li&gt;
&lt;li&gt;故写一个 Dijkstra + DP，求这个式子的最小值即可&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, m;
    std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
    using arr = std::vector&amp;lt;long long&amp;gt;;
    using brr = std::vector&amp;lt;arr&amp;gt;;
    std::vector&amp;lt;std::vector&amp;lt;std::pair&amp;lt;int, int&amp;gt; &amp;gt; &amp;gt; g(n + 1);
    std::vector&amp;lt;brr&amp;gt; dis(2, brr(2, arr(n + 1, 1e18))), vis(2, brr(2, arr(n + 1)));
    for (int x, y, w; m--; ) &amp;#123;
        std::cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; y &amp;gt;&amp;gt; w;
        g[x].emplace_back(y, w);
        g[y].emplace_back(x, w);
    &amp;#125;
    dis[0][0][1] = 0;
    std::array&amp;lt;std::array&amp;lt;std::priority_queue&amp;lt;std::pair&amp;lt;long long, int&amp;gt; &amp;gt;, 2&amp;gt;, 2&amp;gt; q;
    q[0][0].emplace(0, 1);
    for (int i = 0; i &amp;lt; 2; ++i) &amp;#123;
        for (int j = 0; j &amp;lt; 2; ++j) &amp;#123;
            for (; !q[i][j].empty(); ) &amp;#123;
                int f = q[i][j].top().second;
                q[i][j].pop();
                if (vis[i][j][f])
                    continue;
                vis[i][j][f] = 1;
                for (auto k : g[f]) &amp;#123;
                    if (dis[i][j][k.first] &amp;gt; dis[i][j][f] + k.second) &amp;#123;
                        dis[i][j][k.first] = dis[i][j][f] + k.second;
                        q[i][j].emplace(-dis[i][j][k.first], k.first);
                    &amp;#125;
                    if (!i &amp;amp;&amp;amp; dis[1][j][k.first] &amp;gt; dis[i][j][f]) &amp;#123;
                        dis[1][j][k.first] = dis[i][j][f];
                        q[1][j].emplace(-dis[1][j][k.first], k.first);
                    &amp;#125;
                    if (!j &amp;amp;&amp;amp; dis[i][1][k.first] &amp;gt; dis[i][j][f] + 2 * k.second) &amp;#123;
                        dis[i][1][k.first] = dis[i][j][f] + 2 * k.second;
                        q[i][1].emplace(-dis[i][1][k.first], k.first);
                    &amp;#125;
                &amp;#125;
            &amp;#125;
        &amp;#125;
    &amp;#125;
    for (int i = 2; i &amp;lt;= n; ++i)
        std::cout &amp;lt;&amp;lt; std::min(&amp;#123; dis[0][0][i], dis[1][1][i] &amp;#125;) &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
    std::cout &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;b---train-delay&#34;&gt;B - Train Delay&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://vjudge.net/contest/750645#problem/B&#34; class=&#34;uri&#34;&gt;https://vjudge.net/contest/750645#problem/B&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;简化题目很重要的一个转化是&lt;strong&gt;由于 &lt;span class=&#34;math inline&#34;&gt;\(S\le T\)&lt;/span&gt; 带来的 &lt;span class=&#34;math inline&#34;&gt;\(S\)&lt;/span&gt; 和 &lt;span class=&#34;math inline&#34;&gt;\(T\)&lt;/span&gt; 地位平等，考虑把出发和到达分别看作一次事件处理。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;按照所有事件的发生时刻排序，有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于一次出发事件，可以得到在其之前该站点所有到达事件的 &lt;span class=&#34;math inline&#34;&gt;\(\max\{T&amp;#39;\}\)&lt;/span&gt;，用之更新 &lt;span class=&#34;math inline&#34;&gt;\(X\)&lt;/span&gt; 即可。&lt;/li&gt;
&lt;li&gt;对于一次到达事件，由于对应的 &lt;span class=&#34;math inline&#34;&gt;\(X\)&lt;/span&gt; 已经确定，更新该站点当前最大值即可。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, m;
    std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
    std::vector&amp;lt;int&amp;gt; d(m + 1);
    std::cin &amp;gt;&amp;gt; d[1];
    struct event &amp;#123;
        int t, op, id, x;
    &amp;#125;;
    std::vector&amp;lt;event&amp;gt; a;
    std::vector&amp;lt;int&amp;gt; mx(n + 1);
    for (int i = 1, x, y, s, t; i &amp;lt;= m; ++i) &amp;#123;
        std::cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; y &amp;gt;&amp;gt; s &amp;gt;&amp;gt; t;
        a.push_back(&amp;#123; s, 0, i, x &amp;#125;);
        a.push_back(&amp;#123; t, 1, i, y &amp;#125;);
    &amp;#125;
    std::sort(a.begin(), a.end(), [&amp;amp;](event &amp;amp;x, event &amp;amp;y) &amp;#123; return x.t == y.t ? x.op &amp;gt; y.op : x.t &amp;lt; y.t; &amp;#125;);
    for (auto [t, op, id, x] : a)
        if (op == 1)
            mx[x] = std::max(mx[x], t + d[id]);
        else if (id != 1)
            d[id] = std::max(mx[x] - t, 0);
    for (int i = 2; i &amp;lt;= m; ++i)
        std::cout &amp;lt;&amp;lt; d[i] &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
    std::cout &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;c---complete-the-graph&#34;&gt;C - Complete The Graph&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/CF715B&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/CF715B&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;神仙二分&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果初始把所有白边置为 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt;，那么会想到调整法构造&lt;/li&gt;
&lt;li&gt;但是不知道应该在哪些边上调整，确定调整多少似乎也没有什么简单的做法&lt;/li&gt;
&lt;li&gt;&lt;p&gt;故&lt;strong&gt;平均用力&lt;/strong&gt;，构造一个 边1 += 1，边2 += 1，边3 += 1, …, 边cnt0 += 1, 边1 += 1, 边2 += 1, … 的操作序列&lt;/p&gt;
容易&lt;strong&gt;发现每次操作最多让当前最短路长度增加 1&lt;/strong&gt;，而且有单调性&lt;/li&gt;
&lt;li&gt;&lt;p&gt;故二分答案即可&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const __int128 inf = 1e18;
const __int128 inff = 1e23;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, m, s, t, l, cnt = 0;
    std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m &amp;gt;&amp;gt; l &amp;gt;&amp;gt; s &amp;gt;&amp;gt; t, ++s, ++t;
    std::vector&amp;lt;std::tuple&amp;lt;int, int, long long&amp;gt; &amp;gt; u(m + 1);
    std::vector&amp;lt;std::vector&amp;lt;std::pair&amp;lt;int, long long&amp;gt; &amp;gt; &amp;gt; g(n + 1);
    for (int i = 1, x, y; i &amp;lt;= m; ++i) &amp;#123;
        long long w;
        std::cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; y &amp;gt;&amp;gt; w, ++x, ++y;
        if (w == 0)
            w = -(++cnt);
        g[x].emplace_back(y, w), g[y].emplace_back(x, w);
        u[i] = &amp;#123; x, y, w &amp;#125;;
    &amp;#125;
    std::vector&amp;lt;int&amp;gt; vis(n + 1);
    std::vector&amp;lt;__int128&amp;gt; dis(n + 1);
    std::vector&amp;lt;long long&amp;gt; k(cnt + 1);
    __int128 res = -1;
    auto check = [&amp;amp;](__int128 x) &amp;#123;
        for (int i = 1; i &amp;lt;= cnt; ++i)
            k[i] = x / cnt + (i &amp;lt;= x % cnt);
        std::fill(vis.begin() + 1, vis.end(), 0);
        std::fill(dis.begin() + 1, dis.end(), inf);
        std::priority_queue&amp;lt;std::pair&amp;lt;__int128, int&amp;gt; &amp;gt; q;
        dis[s] = 0, q.emplace(0, s);
        for (; !q.empty(); ) &amp;#123;
            int f = q.top().second;
            q.pop();
            if (vis[f])
                continue;
            vis[f] = 1;
            for (auto [v, w] : g[f]) &amp;#123;
                if (w &amp;lt; 0)
                    w = k[-w];
                if (dis[v] &amp;gt; dis[f] + w) &amp;#123;
                    dis[v] = dis[f] + w;
                    q.emplace(-dis[v], v);
                &amp;#125;
            &amp;#125;
        &amp;#125;
        return dis[t] &amp;lt;= l;
    &amp;#125;;
    for (__int128 l = cnt, r = cnt * inf, mid; l &amp;lt;= r; ) &amp;#123;
        mid = (l + r) &amp;gt;&amp;gt; 1;
        if (check(mid))
            res = mid, l = mid + 1;
        else
            r = mid - 1;
    &amp;#125;
    if (res == -1)
        std::cout &amp;lt;&amp;lt; &amp;quot;NO\n&amp;quot;;
    else &amp;#123;
        check(res);
        if (dis[t] != l)
            std::cout &amp;lt;&amp;lt; &amp;quot;NO\n&amp;quot;;
        else &amp;#123;
            std::cout &amp;lt;&amp;lt; &amp;quot;YES\n&amp;quot;;
            for (int i = 1; i &amp;lt;= m; ++i) &amp;#123;
                auto [x, y, w] = u[i];
                if (w &amp;lt; 0)
                    w = k[-w];
                std::cout &amp;lt;&amp;lt; x - 1 &amp;lt;&amp;lt; &amp;#39; &amp;#39; &amp;lt;&amp;lt; y - 1 &amp;lt;&amp;lt; &amp;#39; &amp;#39; &amp;lt;&amp;lt; w &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
            &amp;#125;
        &amp;#125;
    &amp;#125;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;a---重力球&#34;&gt;A - 重力球&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P7473&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P7473&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class=&#34;math inline&#34;&gt;\(m\)&lt;/span&gt; 相对很小，看看有没有什么基于 &lt;span class=&#34;math inline&#34;&gt;\(m\)&lt;/span&gt; 的做法&lt;/li&gt;
&lt;li&gt;每次球停下的位置一定是某个障碍物（或边界）上 / 下 / 左 / 右的格子，故可以在这 &lt;span class=&#34;math inline&#34;&gt;\(O(n + m)\)&lt;/span&gt; 个点上建图&lt;/li&gt;
&lt;li&gt;怎么同时维护两个球的信息呢，发现 &lt;span class=&#34;math inline&#34;&gt;\(m\)&lt;/span&gt; 还是很小，所以可以把两个球塞一起作为一个状态&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(m^2\)&lt;/span&gt; 次 Dij 还是太激进了 进一步思考发现可能的终点共 &lt;span class=&#34;math inline&#34;&gt;\(m\)&lt;/span&gt; 个 并且彼此不区分&lt;/p&gt;
&lt;p&gt;故以这 &lt;span class=&#34;math inline&#34;&gt;\(m\)&lt;/span&gt; 个终点跑多源最短路即可&lt;/p&gt;
&lt;p&gt;但 5e6 跑 Dij 还是太勉强了。&lt;strong&gt;发现边权为 1，为什么不 BFS 呢 😅&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;发现起点可能不在我们限定的点上，但可以人为选择一次重力方向，然后就回到刚刚的问题了&lt;/p&gt;
&lt;p&gt;或者离线也是一种方法&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;疑似常数太大，拼尽全力勉强卡过&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int LEN = (1 &amp;lt;&amp;lt; 20);
#ifdef ONLINE_JUDGE
inline int nec(void) &amp;#123;
    static char buf[LEN], *p = buf, *e = buf;
    if (p == e) &amp;#123;
        e = buf + fread(buf, 1, LEN, stdin);
        if (e == buf)
            return EOF;
        p = buf;
    &amp;#125;
    return *p++;
&amp;#125;
#else
#define nec getchar
#endif
inline bool read(int &amp;amp;x) &amp;#123;
    x = 0;
    bool f = 0;
    char ch = nec();
    while (ch &amp;lt; &amp;#39;0&amp;#39; || ch &amp;gt; &amp;#39;9&amp;#39;) &amp;#123;
        if (ch == EOF)
            return 0;
        if (ch == &amp;#39;-&amp;#39;)
            f = 1;
        ch = nec();
    &amp;#125;
    while (ch &amp;gt;= &amp;#39;0&amp;#39; &amp;amp;&amp;amp; ch &amp;lt;= &amp;#39;9&amp;#39;) &amp;#123;
        x = x * 10 + ch - &amp;#39;0&amp;#39;;
        ch = nec();
    &amp;#125;
    if (f)
        x = -x;
    return 1;
&amp;#125;
void print(int x) &amp;#123;
    if (x &amp;lt; 0) &amp;#123;
        putchar(&amp;#39;-&amp;#39;);
        x = -x;
    &amp;#125;
    if (x &amp;gt;= 10)
        print(x / 10);
    putchar(x % 10 + &amp;#39;0&amp;#39;);
    return;
&amp;#125;
void print(int x, char ch) &amp;#123;
    print(x);
    putchar(ch);
    return;
&amp;#125;
const int inf = 0x3f3f3f3f;
const int dir[][2] = &amp;#123;&amp;#123; -1, 0 &amp;#125;, &amp;#123; 1, 0 &amp;#125;, &amp;#123; 0, -1 &amp;#125;, &amp;#123; 0, 1 &amp;#125;&amp;#125;;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, m, q;
    read(n), read(m), read(q);
    std::vector&amp;lt;std::pair&amp;lt;int, int&amp;gt; &amp;gt; pos(m + 1);
    std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; a(n + 1, std::vector&amp;lt;int&amp;gt; (n + 1));
    for (int i = 1, x, y; i &amp;lt;= m; ++i) &amp;#123;
        read(x), read(y);
        pos[i] = &amp;#123; x, y &amp;#125;, a[x][y] = -1;
    &amp;#125;
    for (int i = 1; i &amp;lt;= n; ++i)
        pos.emplace_back(0, i), ++m;
    for (int i = 1; i &amp;lt;= n; ++i)
        pos.emplace_back(i, n + 1), ++m;
    for (int i = 1; i &amp;lt;= n; ++i)
        pos.emplace_back(n + 1, i), ++m;
    for (int i = 1; i &amp;lt;= n; ++i)
        pos.emplace_back(i, 0), ++m;
    int cnt = 0;
    std::vector&amp;lt;std::pair&amp;lt;int, int&amp;gt; &amp;gt; u(1);
    for (int i = 1; i &amp;lt;= m; ++i)
        for (auto [fx, fy] : dir) &amp;#123;
            int nx = pos[i].first + fx, ny = pos[i].second + fy;
            if (nx &amp;gt;= 1 &amp;amp;&amp;amp; nx &amp;lt;= n &amp;amp;&amp;amp; ny &amp;gt;= 1 &amp;amp;&amp;amp; ny &amp;lt;= n &amp;amp;&amp;amp; !a[nx][ny])
                a[nx][ny] = ++cnt, u.emplace_back(nx, ny);
        &amp;#125;
    std::vector&amp;lt;std::vector&amp;lt;std::array&amp;lt;int, 4&amp;gt; &amp;gt; &amp;gt; top(n + 1, std::vector&amp;lt;std::array&amp;lt;int, 4&amp;gt; &amp;gt; (n + 1));
    for (int j = 1; j &amp;lt;= n; ++j) &amp;#123;
        for (int i = 1; i &amp;lt;= n; ++i)
            if (a[i][j] != -1) &amp;#123;
                if (i == 1 || a[i - 1][j] == -1)
                    top[i][j][0] = a[i][j];
                else
                    top[i][j][0] = top[i - 1][j][0];
            &amp;#125;
        for (int i = n; i; --i)
            if (a[i][j] != -1) &amp;#123;
                if (i == n || a[i + 1][j] == -1)
                    top[i][j][1] = a[i][j];
                else
                    top[i][j][1] = top[i + 1][j][1];
            &amp;#125;
    &amp;#125;
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        for (int j = 1; j &amp;lt;= n; ++j)
            if (a[i][j] != -1) &amp;#123;
                if (j == 1 || a[i][j - 1] == -1)
                    top[i][j][2] = a[i][j];
                else
                    top[i][j][2] = top[i][j - 1][2];
            &amp;#125;
        for (int j = n; j; --j)
            if (a[i][j] != -1) &amp;#123;
                if (j == n || a[i][j + 1] == -1)
                    top[i][j][3] = a[i][j];
                else
                    top[i][j][3] = top[i][j + 1][3];
            &amp;#125;
    &amp;#125;
    const int N = cnt * cnt;
    std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; g(N + 1);
    auto encode = [&amp;amp;](int x, int y) &amp;#123;
        return (x - 1) * cnt + y;
    &amp;#125;;
    auto decode = [&amp;amp;](int id) &amp;#123;
        return std::make_pair((id - 1) / cnt + 1, (id - 1) % cnt + 1);
    &amp;#125;;
    for (int i = 1; i &amp;lt;= N; ++i)
        for (int j = 0; j &amp;lt; 4; ++j) &amp;#123;
            auto [a, b] = decode(i);
            g[encode(top[u[a].first][u[a].second][j], top[u[b].first][u[b].second][j])].emplace_back(i);
        &amp;#125;
    std::vector&amp;lt;int&amp;gt; dis(N + 1, inf), vis(N + 1);
    &amp;#123;
        std::queue&amp;lt;int&amp;gt; q;
        for (int i = 1; i &amp;lt;= cnt; ++i)
            dis[encode(i, i)] = 0, q.push(encode(i, i)), vis[encode(i, i)] = 1;
        for (; !q.empty(); ) &amp;#123;
            int x = q.front();
            q.pop();
            for (auto i : g[x])
                if (!vis[i])
                    dis[i] = dis[x] + 1, vis[i] = 1, q.push(i);
        &amp;#125;
    &amp;#125;
    for (int a, b, c, d; q--; ) &amp;#123;
        read(a), read(b), read(c), read(d);
        if (a == c &amp;amp;&amp;amp; b == d)
            print(0, &amp;#39;\n&amp;#39;);
        else &amp;#123;
            int res = inf;
            for (int j = 0; j &amp;lt; 4; ++j)
                res = std::min(res, dis[encode(top[a][b][j], top[c][d][j])] + 1);
            if (res == inf)
                print(-1, &amp;#39;\n&amp;#39;);
            else
                print(res, &amp;#39;\n&amp;#39;);
        &amp;#125;
    &amp;#125;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;b---矩阵游戏&#34;&gt;B - 矩阵游戏&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P7515&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P7515&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;把问题形式化一下，现在有 &lt;span class=&#34;math inline&#34;&gt;\(n\times m\)&lt;/span&gt; 个未知数和 &lt;span class=&#34;math inline&#34;&gt;\((n-1)\times (m-1)\)&lt;/span&gt; 个方程&lt;/p&gt;
&lt;p&gt;那么可以对边上一圈任意赋值，限制是左上角这 &lt;span class=&#34;math inline&#34;&gt;\((n-1)\times (m-1)\)&lt;/span&gt; 个未知数必须落在 &lt;span class=&#34;math inline&#34;&gt;\([0,10^6]\)&lt;/span&gt; 上&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;有一个很容易观察到的性质，对于一个 &lt;span class=&#34;math inline&#34;&gt;\(a\)&lt;/span&gt;，选取一个 &lt;span class=&#34;math inline&#34;&gt;\(v\)&lt;/span&gt;，并把棋盘黑白染色，那么把所有黑格 &lt;span class=&#34;math inline&#34;&gt;\(+=v\)&lt;/span&gt;，白格 &lt;span class=&#34;math inline&#34;&gt;\(-=v\)&lt;/span&gt;，对应的 &lt;span class=&#34;math inline&#34;&gt;\(b\)&lt;/span&gt; 是不会变的。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;这个操作是涉及全局的，太苛刻了&lt;/strong&gt;，有没有什么更 mild 的构造？&lt;/p&gt;
&lt;p&gt;发现只对一行 / 列黑白染色并操作也可以得到相同的结果。能感受到&lt;strong&gt;操作无法再简化了&lt;/strong&gt;。考虑用这个版本的操作&lt;strong&gt;调整&lt;/strong&gt;。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;故大力令周围一圈的临时解 &lt;span class=&#34;math inline&#34;&gt;\(a&amp;#39;\)&lt;/span&gt; 为 &lt;span class=&#34;math inline&#34;&gt;\(0\)&lt;/span&gt;，令每行、列的调整 delta 为 &lt;span class=&#34;math inline&#34;&gt;\(r_i,c_i\)&lt;/span&gt;，可以得到若干个关于 &lt;span class=&#34;math inline&#34;&gt;\(0\)&lt;/span&gt; 和 &lt;span class=&#34;math inline&#34;&gt;\(10^6\)&lt;/span&gt; 的约束。最后建出来一个完全二分图状物，跑差分约束即可，容易发现复杂度正确。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;实现技巧：规划一下 &lt;span class=&#34;math inline&#34;&gt;\(r\)&lt;/span&gt; 和 &lt;span class=&#34;math inline&#34;&gt;\(c\)&lt;/span&gt; 的染色方式，使得它们错开，可以把所有位置都写作 &lt;span class=&#34;math inline&#34;&gt;\(a&amp;#39;_{i,j}+c-r\)&lt;/span&gt; 或 &lt;span class=&#34;math inline&#34;&gt;\(a&amp;#39;_{i,j}+r-c\)&lt;/span&gt; 的形式，便于差分约束&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;c---tax&#34;&gt;C - Tax&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P6822&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P6822&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;容易想到分类讨论，如果钦定是入边贡献边权，那么出边边权不能大于入边边权；否则，出边贡献边权。&lt;/li&gt;
&lt;li&gt;考虑把每个点上的出边按边权从小到大排序，显然需要入边贡献的是一段前缀，需要出边贡献的是一段后缀，就可以做一个前后缀优化建图。&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const long long inf = 1e18;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, m;
    std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
    struct edge &amp;#123; int v, w, id, pi, si; &amp;#125;;
    std::vector&amp;lt;std::vector&amp;lt;edge&amp;gt; &amp;gt; g1(n + 2);
    std::vector&amp;lt;std::vector&amp;lt;std::pair&amp;lt;int, int&amp;gt; &amp;gt; &amp;gt; g(1);
    int cnt = 0;
    for (int x, y, w; m--; ) &amp;#123;
        std::cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; y &amp;gt;&amp;gt; w;
        g1[x].push_back(&amp;#123; y, w, ++cnt, 0, 0 &amp;#125;);
        g1[y].push_back(&amp;#123; x, w, ++cnt, 0, 0 &amp;#125;);
        g.emplace_back(), g.emplace_back();
    &amp;#125;
    int s = ++cnt, t = ++cnt;
    g1[0].push_back(&amp;#123; 1, 0, s, 0, 0 &amp;#125;), g1[n].push_back(&amp;#123; n + 1, 0, t, 0, 0 &amp;#125;);
    g.emplace_back(), g.emplace_back();
    for (int i = 0; i &amp;lt;= n + 1; ++i)
        if (!g1[i].empty()) &amp;#123;
            std::sort(g1[i].begin(), g1[i].end(), [&amp;amp;](edge &amp;amp;x, edge &amp;amp;y) &amp;#123; return x.w &amp;lt; y.w; &amp;#125;);
            for (int j = 0; j &amp;lt; (int)g1[i].size(); ++j) &amp;#123;
                g1[i][j].pi = ++cnt, g.emplace_back();
                if (j != 0)
                    g[cnt].emplace_back(cnt - 1, 0);
                g[cnt].emplace_back(g1[i][j].id, 0);
            &amp;#125;
            for (int j = (int)g1[i].size() - 1; ~j; --j) &amp;#123;
                g1[i][j].si = ++cnt, g.emplace_back();
                if (j != (int)g1[i].size() - 1)
                    g[cnt].emplace_back(cnt - 1, 0);
                g[cnt].emplace_back(g1[i][j].id, g1[i][j].w);
            &amp;#125;
        &amp;#125;
    for (int i = 0; i &amp;lt;= n + 1; ++i)
        for (auto &amp;amp;[v, w, id, pi, si] : g1[i]) &amp;#123;
            auto to = std::upper_bound(g1[v].begin(), g1[v].end(), w, [&amp;amp;](int x, edge &amp;amp;y) &amp;#123; return x &amp;lt; y.w; &amp;#125;);
            if (to != g1[v].end())
                g[id].emplace_back(to-&amp;gt;si, 0);
            if (to != g1[v].begin())
                g[id].emplace_back((--to)-&amp;gt;pi, w);
        &amp;#125;
    std::vector&amp;lt;int&amp;gt; vis(cnt + 1, 0);
    std::vector&amp;lt;long long&amp;gt; dis(cnt + 1, inf);
    std::priority_queue&amp;lt;std::pair&amp;lt;long long, int&amp;gt; &amp;gt; q;
    dis[s] = 0, q.emplace(0, s);
    for (; !q.empty(); ) &amp;#123;
        int f = q.top().second;
        q.pop();
        if (vis[f])
            continue;
        vis[f] = 1;
        for (auto [v, w] : g[f])
            if (dis[v] &amp;gt; dis[f] + w) &amp;#123;
                dis[v] = dis[f] + w;
                q.emplace(-dis[v], v);
            &amp;#125;
    &amp;#125;
    std::cout &amp;lt;&amp;lt; dis[t] &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;d---travelling-through-the-snow-queens-kingdom&#34;&gt;D - Travelling Through the Snow Queen’s Kingdom&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/CF685E&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/CF685E&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;目前见过的数据范围提示性极弱（误导性极强）的循环结构题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;[BZOJ3620] 似乎在梦中见过的样子&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/20240906/#字符合并&#34;&gt;字符合并&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/20250907/#e---subset-product-problem&#34;&gt;[ARC205E] Subset Product Problem&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;正赛因为有部分分，应该不会出现不敢写的问题&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;考虑离线询问，逆序加边；原文无边权；边的通行时刻只决定到达点的时刻。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;借鉴 &lt;a href=&#34;/20231113/#b.-商人&#34;&gt;merchant&lt;/a&gt; 中的思路，只需要更新当前边两侧点为起点的 DP 数组。&lt;/p&gt;
&lt;p&gt;需要注意边从某种意义上说是『有向』的。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int inf = 0x3f3f3f3f;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, m, q;
    std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m &amp;gt;&amp;gt; q;
    struct query &amp;#123; int r, s, t, id; &amp;#125;;
    std::vector&amp;lt;int&amp;gt; res(q + 1);
    std::vector&amp;lt;std::vector&amp;lt;query&amp;gt; &amp;gt; u(m + 1);
    std::vector&amp;lt;std::pair&amp;lt;int, int&amp;gt; &amp;gt; e(m + 1);
    for (int i = 1; i &amp;lt;= m; ++i)
        std::cin &amp;gt;&amp;gt; e[i].first &amp;gt;&amp;gt; e[i].second;
    for (int i = 1, l, r, s, t; i &amp;lt;= q; ++i) &amp;#123;
        std::cin &amp;gt;&amp;gt; l &amp;gt;&amp;gt; r &amp;gt;&amp;gt; s &amp;gt;&amp;gt; t;
        u[l].push_back(&amp;#123; r, s, t, i &amp;#125;);
    &amp;#125;
    std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; g(n + 1, std::vector&amp;lt;int&amp;gt; (n + 1, inf));
    for (int i = m; i; --i) &amp;#123;
        auto [x, y] = e[i];
        g[x][y] = g[y][x] = i;
        for (int j = 1; j &amp;lt;= n; ++j)
            g[x][j] = g[y][j] = std::min(g[x][j], g[y][j]);
        for (auto [r, s, t, id] : u[i])
            if (g[s][t] &amp;lt;= r)
                res[id] = 1;
    &amp;#125;
    for (int i = 1; i &amp;lt;= q; ++i)
        std::cout &amp;lt;&amp;lt; (res[i] ? &amp;quot;Yes&amp;quot; : &amp;quot;No&amp;quot;) &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;e---culture-code&#34;&gt;E - Culture Code&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/CF1197E&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/CF1197E&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;先按 &lt;span class=&#34;math inline&#34;&gt;\(out\)&lt;/span&gt; 排序，做一个前缀优化建图。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;容易发现除了最外层，每一个套娃都会提供 &lt;span class=&#34;math inline&#34;&gt;\(in_i-out_i\)&lt;/span&gt; 的代价，而最外层会提供 &lt;span class=&#34;math inline&#34;&gt;\(in_x\)&lt;/span&gt; 的代价。&lt;/p&gt;
&lt;del&gt;好在要求的是最长路，这样就可以 Dij 了&lt;/del&gt;，并不需要真正把图建出来，发现这个形式更序列，直接在序列上二分前缀 + DP 即可。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;求方案是容易的。最后统计 DP 值最大，&lt;strong&gt;且不能被其他套娃包含的元素&lt;/strong&gt;即可。&lt;/p&gt;
&lt;p&gt;Tip：在求解过程中并不用考虑当前元素和前缀 min 元素间能否加入其他套娃，因为保证 &lt;span class=&#34;math inline&#34;&gt;\(out&amp;gt;in\)&lt;/span&gt;，如果存在这样的套娃，其 DP 值会比前缀 min 更小，矛盾。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int mod = 1e9 + 7;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n;
    std::cin &amp;gt;&amp;gt; n;
    std::vector&amp;lt;std::pair&amp;lt;int, int&amp;gt; &amp;gt; a(n + 1);
    int mxi = 0;
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        std::cin &amp;gt;&amp;gt; a[i].first &amp;gt;&amp;gt; a[i].second;
        mxi = std::max(mxi, a[i].second);
    &amp;#125;
    std::sort(a.begin() + 1, a.end());
    std::vector&amp;lt;long long&amp;gt; g(n + 1), mxg(n + 1), f(n + 1), mx(n + 1);
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        int j = std::upper_bound(a.begin() + 1, a.begin() + i, std::make_pair(a[i].second, 0x3f3f3f3f)) - a.begin() - 1;
        if (j == 0)
            f[i] = a[i].second, g[i] = 1ll;
        else
            f[i] = mx[j] + a[i].second, g[i] = mxg[j];
        long long now = f[i] - a[i].first;
        if (now &amp;lt; mx[i - 1])
            mx[i] = now, mxg[i] = g[i];
        else if (now == mx[i - 1])
            mx[i] = now, mxg[i] = (mxg[i - 1] + g[i]) % mod;
        else
            mx[i] = mx[i - 1], mxg[i] = mxg[i - 1];
    &amp;#125;
    auto now = 0x3f3f3f3fll, res = 0ll;
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        if (a[i].first &amp;lt;= mxi)
            continue;
        if (f[i] &amp;lt; now)
            now = f[i], res = g[i];
        else if (f[i] == now)
            (res += g[i]) %= mod;
    &amp;#125;
    std::cout &amp;lt;&amp;lt; res &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;a---awesome-arrowland-adventure&#34;&gt;A - Awesome Arrowland Adventure&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P6233&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P6233&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;没什么好说的建图，注意只能顺时针转&lt;/li&gt;
&lt;li&gt;代码略&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;b---地铁线路&#34;&gt;B - 地铁线路&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P6096&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P6096&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;考虑做一个神秘拆点，把每个点附上线路和运行方向的信息（所以是单向的）&lt;/li&gt;
&lt;li&gt;认为路径代价是二元组，那么同条线路中的点通行代价为 &lt;span class=&#34;math inline&#34;&gt;\((0,-1)\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;换乘需要优化建图，每个点可以花 &lt;span class=&#34;math inline&#34;&gt;\((0,0)\)&lt;/span&gt; 的代价走到这个点的『换乘点』，再花 &lt;span class=&#34;math inline&#34;&gt;\((1,0)\)&lt;/span&gt; 的代价走到另一个分点&lt;/li&gt;
&lt;li&gt;&lt;p&gt;但 &lt;strong&gt;15 年的时候 SPFA 已经死了&lt;/strong&gt;，所以需要好好考虑怎么实现最短路。&lt;/p&gt;
&lt;p&gt;分两问是有提示性在的，可以想到 01 BFS 解决第一个关键字，比较对的想法是&lt;strong&gt;把所有最短路拿出来形成 DAG，在 DAG 上对第二关键字 DP&lt;/strong&gt;。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, m;
    std::cin &amp;gt;&amp;gt; m &amp;gt;&amp;gt; n;
    std::unordered_map&amp;lt;std::string, int&amp;gt; tab;
    std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; l(n + 1);
    std::vector&amp;lt;std::vector&amp;lt;std::tuple&amp;lt;int, int, int&amp;gt; &amp;gt; &amp;gt; g0(n + 1), g1(n + 1);
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        std::string s;
        std::cin &amp;gt;&amp;gt; s, tab[s] = i;
    &amp;#125;
    int tot = n;
    for (int i = 1, k; i &amp;lt;= m; ++i) &amp;#123;
        std::cin &amp;gt;&amp;gt; k;
        int lp = 0, lq = 0;
        for (std::string s; k--; ) &amp;#123;
            std::cin &amp;gt;&amp;gt; s;
            int p = ++tot, q = ++tot, id = tab[s];
            g0.emplace_back(), g0.emplace_back();
            g1.emplace_back(), g1.emplace_back();
            if (lp) &amp;#123;
                g0[p].emplace_back(lp, 0, 1), g0[lq].emplace_back(q, 0, 1);
                g1[lp].emplace_back(p, 0, 1), g1[q].emplace_back(lq, 0, 1);
            &amp;#125;
            g0[p].emplace_back(id, 0, 0), g0[id].emplace_back(p, 1, 0);
            g1[id].emplace_back(p, 0, 0), g1[p].emplace_back(id, 1, 0);
            g0[q].emplace_back(id, 0, 0), g0[id].emplace_back(q, 1, 0);
            g1[id].emplace_back(q, 0, 0), g1[q].emplace_back(id, 1, 0);
            l[id].push_back(p), l[id].push_back(q);
            lp = p, lq = q;
        &amp;#125;
    &amp;#125;
    int s, t;
    &amp;#123;
        std::string s1, s2;
        std::cin &amp;gt;&amp;gt; s1 &amp;gt;&amp;gt; s2;
        s = ++tot, t = tab[s2];
        g0.emplace_back(), g1.emplace_back();
        int p = tab[s1];
        for (auto i : l[p])
            g0[s].emplace_back(i, 1, 0), g1[i].emplace_back(s, 1, 0);
    &amp;#125;
    std::vector&amp;lt;int&amp;gt; dis0(tot + 1, 0x3f3f3f3f), dis1(tot + 1, 0x3f3f3f3f);
    auto BFS = [&amp;amp;](decltype(g0) &amp;amp;g, decltype(dis0) &amp;amp;dis, int s) &amp;#123;
        std::deque&amp;lt;int&amp;gt; q;
        std::vector&amp;lt;int&amp;gt; vis(tot + 1);
        q.push_back(s), dis[s] = 0;
        for (; !q.empty(); ) &amp;#123;
            int x = q.front();
            q.pop_front();
            if (vis[x])
                continue;
            vis[x] = 1;
            for (auto [v, w1, w2] : g[x])
                if (dis[x] + w1 &amp;lt; dis[v]) &amp;#123;
                    dis[v] = dis[x] + w1;
                    if (w1 == 0)
                        q.push_front(v);
                    else
                        q.push_back(v);
                &amp;#125;
        &amp;#125;
        return;
    &amp;#125;;
    BFS(g0, dis0, s), BFS(g1, dis1, t);
    std::cout &amp;lt;&amp;lt; dis0[t] &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    std::vector&amp;lt;int&amp;gt; deg(tot + 1);
    std::vector&amp;lt;std::vector&amp;lt;std::pair&amp;lt;int, int&amp;gt; &amp;gt; &amp;gt; g(tot + 1);
    for (int i = 1; i &amp;lt;= tot; ++i)
        for (auto [j, w1, w2] : g0[i])
            if (dis0[i] + dis1[j] + w1 == dis0[t])
                g[i].emplace_back(j, w2), ++deg[j];
    std::queue&amp;lt;int&amp;gt; q;
    for (int i = 1; i &amp;lt;= tot; ++i)
        if (!deg[i])
            q.push(i);
    std::vector&amp;lt;int&amp;gt; f(tot + 1);
    for (; !q.empty(); ) &amp;#123;
        int x = q.front();
        q.pop();
        for (auto [v, w] : g[x]) &amp;#123;
            f[v] = std::max(f[v], f[x] + w);
            if (!--deg[v])
                q.push(v);
        &amp;#125;
    &amp;#125;
    std::cout &amp;lt;&amp;lt; f[t] &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;c---droga-do-domu&#34;&gt;C - Droga do domu&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P9402&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P9402&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;还是做一个和上一题类似的优化建图&lt;/li&gt;
&lt;li&gt;此外就是一个普通的 Dij 上 DP 了。&lt;strong&gt;图没有环&lt;/strong&gt;，直接拓扑即可。&lt;/li&gt;
&lt;li&gt;可以滚动优化空间，但似乎并无必要。代码略。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;d---tickets-p&#34;&gt;D - Tickets P&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P7984&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P7984&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;没什么好说的线段树优化建图，难点在于如何同时获取 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt; 和 &lt;span class=&#34;math inline&#34;&gt;\(N\)&lt;/span&gt; 的信息&lt;/li&gt;
&lt;li&gt;&lt;p&gt;发现从某个点走到 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt; 和 &lt;span class=&#34;math inline&#34;&gt;\(N\)&lt;/span&gt;，有一种不劣的走法：&lt;/p&gt;
&lt;img src=&#34;image.png&#34; /&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;维护一下每个点单独走到 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt;，&lt;span class=&#34;math inline&#34;&gt;\(N\)&lt;/span&gt; 的最小代价和同时走到 &lt;span class=&#34;math inline&#34;&gt;\(1,N\)&lt;/span&gt; 的最小代价&lt;/p&gt;
看到一种更加对的写法是&lt;strong&gt;令 &lt;span class=&#34;math inline&#34;&gt;\(f_u\)&lt;/span&gt; 表示 &lt;span class=&#34;math inline&#34;&gt;\(v\)&lt;/span&gt; 的答案，那么可以用 &lt;span class=&#34;math inline&#34;&gt;\(f_v+w(u,v)\)&lt;/span&gt; 更新 &lt;span class=&#34;math inline&#34;&gt;\(f_u\)&lt;/span&gt;&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;那么可以从 &lt;span class=&#34;math inline&#34;&gt;\(1,N\)&lt;/span&gt; 出发做一个 Dij。代码略。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;e---监狱&#34;&gt;E - 监狱&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P9520&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P9520&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;注意要走简单路径，也就是说不存在绕路让道的可能性。容易推出：若输入合法，总能找到一种方式使得每个人受到的指令是连续给出的。&lt;/p&gt;
&lt;p&gt;P.S. 这个结论挪到图上就不成立了，很容易举出反例。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image-1.png&#34; /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;若一个人的起点 / 终点在另一个人的路径上，那么这两个人之间存在先后关系。建图后检查是否为 DAG 即可。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;但建图显然是比较困难的，容易构造出数据使得边数来到 &lt;span class=&#34;math inline&#34;&gt;\(n^2\)&lt;/span&gt; 级别。考虑优化建图。&lt;/p&gt;
&lt;p&gt;发现可以用一个树剖 / 倍增的结构来建图。&lt;/p&gt;
Tips：这一点同样是一个树上路径问题。参见 &lt;a href=&#34;/20231117/#树上问题&#34;&gt;树上问题，倍增和树剖的选择？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;这里的路径要求两端都是开的，这就导致倍增写着很困难（虽然树剖可能也是），不排除我写丑了&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int K = 19;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;01-02.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int T;
    for (std::cin &amp;gt;&amp;gt; T; T--; ) &amp;#123;
        int n, m;
        std::cin &amp;gt;&amp;gt; n;
        std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; g1(n + 1);
        std::vector&amp;lt;int&amp;gt; s(n + 1), t(n + 1);
        for (int i = 1, x, y; i &amp;lt; n; ++i) &amp;#123;
            std::cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; y;
            g1[x].push_back(y), g1[y].push_back(x);
        &amp;#125;
        std::cin &amp;gt;&amp;gt; m;
        std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; g(m + 1);
        std::vector&amp;lt;std::pair&amp;lt;int, int&amp;gt; &amp;gt; a(m + 1);
        for (int i = 1; i &amp;lt;= m; ++i) &amp;#123;
            std::cin &amp;gt;&amp;gt; a[i].first &amp;gt;&amp;gt; a[i].second;
            s[a[i].first] = i;
            t[a[i].second] = i;
        &amp;#125;
        int cnt = m;
        struct node &amp;#123; int fa, i0, i1; &amp;#125;;
        std::vector&amp;lt;std::array&amp;lt;node, K + 1&amp;gt; &amp;gt; p(n + 1);
        std::vector&amp;lt;int&amp;gt; i0(n + 1), i1(n + 1), dep(n + 1), deg(m + 1);
        auto init = [&amp;amp;](void) &amp;#123;
            g.emplace_back(), deg.emplace_back();
            return ++cnt;
        &amp;#125;;
        auto add = [&amp;amp;](int x, int y) &amp;#123;
            g[x].push_back(y), ++deg[y];
            return;
        &amp;#125;;
        for (int i = 1; i &amp;lt;= n; ++i)
            i0[i] = init(), i1[i] = init();
        std::function&amp;lt;void(int, int)&amp;gt; DFS = [&amp;amp;](int x, int fa) &amp;#123;
            if (s[x])
                add(s[x], i1[x]);
            if (t[x])
                add(i0[x], t[x]);
            for (auto i : g1[x])
                if (i != fa) &amp;#123;
                    dep[i] = dep[x] + 1;
                    p[i][0].fa = x;
                    p[i][0].i0 = init(), p[i][0].i1 = init();
                    add(p[i][0].i0, i0[i]), add(i1[i], p[i][0].i1);
                    for (int j = 1; j &amp;lt;= K; ++j) &amp;#123;
                        p[i][j].fa = p[p[i][j - 1].fa][j - 1].fa;
                        if (!p[i][j].fa)
                            break;
                        p[i][j].i0 = init(), p[i][j].i1 = init();
                        add(p[i][j].i0, p[i][j - 1].i0);
                        add(p[i][j].i0, p[p[i][j - 1].fa][j - 1].i0);
                        add(p[i][j - 1].i1, p[i][j].i1);
                        add(p[p[i][j - 1].fa][j - 1].i1, p[i][j].i1);
                    &amp;#125;
                    DFS(i, x);
                &amp;#125;
            return;
        &amp;#125;;
        dep[1] = 1, DFS(1, -1);
        for (int i = 1; i &amp;lt;= m; ++i) &amp;#123;
            auto [x, y] = a[i];
            if (x == y)
                continue;
            if (t[x])
                add(i, t[x]);
            if (s[y])
                add(s[y], i);
            if (dep[x] &amp;lt; dep[y])
                std::swap(x, y);
            x = p[x][0].fa;
            if (dep[x] &amp;gt;= dep[y]) &amp;#123;
                for (int j = K; ~j; --j)
                    if (dep[p[x][j].fa] &amp;gt;= dep[y]) &amp;#123;
                        add(i, p[x][j].i0), add(p[x][j].i1, i);
                        x = p[x][j].fa;
                    &amp;#125;
                if (x == y)
                    continue;
                add(i, p[x][0].i0), add(p[x][0].i1, i);
                x = p[x][0].fa;
            &amp;#125;
            y = p[y][0].fa;
            if (x != y) &amp;#123;
                for (int j = K; ~j; --j)
                    if (p[x][j].fa != p[y][j].fa) &amp;#123;
                        add(i, p[x][j].i0), add(i, p[y][j].i0);
                        add(p[x][j].i1, i), add(p[y][j].i1, i);
                        x = p[x][j].fa, y = p[y][j].fa;
                    &amp;#125;
                add(i, p[x][0].i0), add(i, p[y][0].i0);
                add(p[x][0].i1, i), add(p[y][0].i1, i);
                x = p[x][0].fa;
            &amp;#125;
            add(i, i0[x]), add(i1[x], i);
        &amp;#125;
        std::queue&amp;lt;int&amp;gt; q;
        for (int i = 1; i &amp;lt;= cnt; ++i)
            if (!deg[i])
                q.push(i);
        int tot = 0;
        for (; !q.empty(); ) &amp;#123;
            int x = q.front();
            q.pop(), ++tot;
            for (auto i : g[x])
                if (!--deg[i])
                    q.push(i);
        &amp;#125;
        std::cout &amp;lt;&amp;lt; (tot == cnt ? &amp;quot;Yes&amp;quot; : &amp;quot;No&amp;quot;) &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    &amp;#125;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://xsc062.netlify.app/20250518/</guid>
            <title>构造类问题的很少解题方法</title>
            <link>https://xsc062.netlify.app/20250518/</link>
            <category>构造</category>
            <category>调整法</category>
            <pubDate>Sun, 18 May 2025 14:43:30 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;病毒可能具有膜结构，但不存在生物膜系统。核糖体是唯一所有细胞均含有的细胞器，但病毒中无核糖体。&lt;/p&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;
&lt;p&gt;病毒的主要组成是 &lt;span class=&#34;math inline&#34;&gt;\(10\%\sim 20\%\)&lt;/span&gt; 的核酸，&lt;span class=&#34;math inline&#34;&gt;\(60\%\sim 70\%\)&lt;/span&gt; 的蛋白质外壳，&lt;span class=&#34;math inline&#34;&gt;\(&amp;lt;10\%\)&lt;/span&gt; 的结合水，可能具有逆转录酶、RNA 聚合酶。病毒的含水量（&lt;span class=&#34;math inline&#34;&gt;\(&amp;lt;10\%\)&lt;/span&gt;）远远小于细胞（&lt;span class=&#34;math inline&#34;&gt;\(70\%\)&lt;/span&gt;）。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;type-i调整法---1&#34;&gt;Type I：调整法 - 1&lt;/h2&gt;
&lt;p&gt;虽然话是这么说，感觉这就是平常正常的做题路径，『想做法』——『发现有锅』——『打补丁』。&lt;/p&gt;
&lt;p&gt;只是可能这是在提醒你在构造题中发现有锅不要急着换做法（？）&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;例题c---stations&#34;&gt;例题：C - Stations&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://qoj.ac/problem/1139&#34; class=&#34;uri&#34;&gt;https://qoj.ac/problem/1139&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;一个简单的想法是，当可用的编号范围很大时，可以记下每个点 &lt;span class=&#34;math inline&#34;&gt;\(u\)&lt;/span&gt; 的 &lt;span class=&#34;math inline&#34;&gt;\(DFN_u\)&lt;/span&gt; 和出栈序（记为 &lt;span class=&#34;math inline&#34;&gt;\(RFN_u\)&lt;/span&gt;），这样就能解决查询；但标号是 &lt;span class=&#34;math inline&#34;&gt;\(N^2\)&lt;/span&gt; 级别的。&lt;/p&gt;
&lt;p&gt;现在思考，我们为什么需要记录 &lt;span class=&#34;math inline&#34;&gt;\(RFN_u\)&lt;/span&gt; 呢？因为在询问时，需要判断 &lt;span class=&#34;math inline&#34;&gt;\(t\)&lt;/span&gt; 的位置：如果在 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 某一儿子的子树内，答案为该儿子；否则，答案为 &lt;span class=&#34;math inline&#34;&gt;\(fa\)&lt;/span&gt;。当 &lt;span class=&#34;math inline&#34;&gt;\(DFN_t\)&lt;/span&gt; 比 &lt;span class=&#34;math inline&#34;&gt;\(u\)&lt;/span&gt; 最靠后的儿子 &lt;span class=&#34;math inline&#34;&gt;\(v\)&lt;/span&gt; 的 &lt;span class=&#34;math inline&#34;&gt;\(DFN\)&lt;/span&gt; 还要大时，无法判断 &lt;span class=&#34;math inline&#34;&gt;\(t\)&lt;/span&gt; 在 &lt;span class=&#34;math inline&#34;&gt;\(v\)&lt;/span&gt; 内还是在 &lt;span class=&#34;math inline&#34;&gt;\(u\)&lt;/span&gt; 外。&lt;/p&gt;
&lt;p&gt;此处有一个解决方案（原谅我实在无法猜出是怎么想到的），将树按奇数层、偶数层分层，计数层记录 &lt;span class=&#34;math inline&#34;&gt;\(DFN\)&lt;/span&gt;，偶数层记录 &lt;span class=&#34;math inline&#34;&gt;\(RFN\)&lt;/span&gt;（具体地，奇数层在入栈时编号，偶数层在出栈时编号）；接下来进行判断（注意我们并不知道 &lt;span class=&#34;math inline&#34;&gt;\(u\)&lt;/span&gt; 所在层数的奇偶性）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;若不存在 &lt;span class=&#34;math inline&#34;&gt;\(id_i&amp;gt;id_u\)&lt;/span&gt;，说明 &lt;span class=&#34;math inline&#34;&gt;\(id_u\)&lt;/span&gt; 为 &lt;span class=&#34;math inline&#34;&gt;\(RFN_u\)&lt;/span&gt;；此时 可以判断 &lt;span class=&#34;math inline&#34;&gt;\(t\)&lt;/span&gt; 是否位于 &lt;span class=&#34;math inline&#34;&gt;\(u\)&lt;/span&gt; 内。&lt;/li&gt;
&lt;li&gt;否则，&lt;span class=&#34;math inline&#34;&gt;\(id_u\)&lt;/span&gt; 为 &lt;span class=&#34;math inline&#34;&gt;\(DFN_u\)&lt;/span&gt;。由于知道 &lt;span class=&#34;math inline&#34;&gt;\(RFN_v\)&lt;/span&gt;，可以判断 &lt;span class=&#34;math inline&#34;&gt;\(t\)&lt;/span&gt; 是否位于 &lt;span class=&#34;math inline&#34;&gt;\(v\)&lt;/span&gt; 内。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;容易证明其他一般情况也可以判断 &lt;span class=&#34;math inline&#34;&gt;\(t\)&lt;/span&gt; 的位置。复杂度 &lt;span class=&#34;math inline&#34;&gt;\(O(n^2)\)&lt;/span&gt;。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;quot;stations.h&amp;quot;
#include &amp;lt;bits/stdc++.h&amp;gt;
std::vector&amp;lt;int&amp;gt; label(int n, int k, std::vector&amp;lt;int&amp;gt; u, std::vector&amp;lt;int&amp;gt; v) &amp;#123;
    std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; g(n);
    for (int i = 0; i &amp;lt; n - 1; ++i)
        g[u[i]].push_back(v[i]), g[v[i]].push_back(u[i]);
    std::vector&amp;lt;int&amp;gt; id(n, -1);
    int now = 0;
    std::function&amp;lt;void(int, int, int)&amp;gt; DFS = [&amp;amp;](int x, int fa, int tag) &amp;#123;
        if (tag)
            id[x] = now++;
        for (auto i : g[x])
            if (i != fa)
                DFS(i, x, tag ^ 1);
        if (!tag)
            id[x] = now++;
        return;
    &amp;#125;;
    DFS(0, -1, 1);
    return id;
&amp;#125;
int find_next_station(int s, int t, std::vector&amp;lt;int&amp;gt; c) &amp;#123;
    if (c.back() &amp;lt; s) &amp;#123;
        int fa = c.front();
        if (t &amp;gt; s)
            return fa;
        for (int i = (int)c.size() - 1; ~i; --i)
            if (t &amp;gt;= c[i])
                return c[i];
        return fa;
    &amp;#125;
    else &amp;#123;
        int fa = c.back();
        if (t &amp;lt; s)
            return fa;
        for (int i = 0; i &amp;lt; (int)c.size() - 1; ++i)
            if (t &amp;lt;= c[i])
                return c[i];
        return fa;
    &amp;#125;
    // assert(0);
    return 114514;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;type-ii调整法---2&#34;&gt;Type II：调整法 - 2&lt;/h2&gt;
&lt;p&gt;题目要求构造『恰好为 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt;』，可以先不看这个限制，对于局面求出上界和下界，然后再看是不是上下界中全部（或大多数）都能取到，此时有两个路径：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;直接在某个上界 / 下界局面中通过若干步极小改动调整到恰好为 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt;；&lt;/li&gt;
&lt;li&gt;通过这一点优化 DP 状态（这样就可以大量压缩『可到达局面』这一信息）。见 &lt;a href=&#34;/20250510/#b---miriany-and-matchstick&#34;&gt;此&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;例题d---construct-the-binary-tree&#34;&gt;例题：D - Construct the Binary Tree&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://codeforces.com/problemset/problem/1311/E&#34; class=&#34;uri&#34;&gt;https://codeforces.com/problemset/problem/1311/E&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;首先从找上下界的角度出发，发现链为上界，完全二叉树为下界。&lt;/p&gt;
&lt;p&gt;那么只需先 check &lt;span class=&#34;math inline&#34;&gt;\(d\)&lt;/span&gt; 是否在该范围内；固定树最左侧的一条链，每次拿走右下角的一个叶子（这样就能&lt;strong&gt;维持完全二叉树性质&lt;/strong&gt;），如果可以插入到链底就 do so；否则由于这是个左边挂着单链的完全二叉树，可以证明你想取的任意深度都可以取到，暴力跳即可，且跳完后就构造完了。&lt;/p&gt;
&lt;p&gt;复杂度 &lt;span class=&#34;math inline&#34;&gt;\(O(n)\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(O(nd)\)&lt;/span&gt; 是每次取点时扫一遍完全二叉树找一个能让当前点深度 &lt;span class=&#34;math inline&#34;&gt;\(+1\)&lt;/span&gt; 的父节点。&lt;span class=&#34;math inline&#34;&gt;\(O(d)\)&lt;/span&gt; 的做法是慢慢把树变窄变高，一次还是只 &lt;span class=&#34;math inline&#34;&gt;\(+1\)&lt;/span&gt;，二者的弊端都在于没利用『上界为链』即链和完全二叉树的优美性质。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#endif
    int T;
    for (std::cin &amp;gt;&amp;gt; T; T--; ) &amp;#123;
        int n, d;
        std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; d;
        std::vector&amp;lt;int&amp;gt; tag(n + 1), dep(n + 1), cnt(n + 1), fa(n + 1);
        int L = 0, R = n * (n - 1) / 2;
        for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
            L += std::__lg(i), dep[i] = std::__lg(i);
            if (i * 2 &amp;lt;= n)
                ++cnt[i], fa[i * 2] = i;
            if (i * 2 + 1 &amp;lt;= n)
                ++cnt[i], fa[i * 2 + 1] = i;
        &amp;#125;
        if (L &amp;lt;= d &amp;amp;&amp;amp; d &amp;lt;= R) &amp;#123;
            std::cout &amp;lt;&amp;lt; &amp;quot;YES\n&amp;quot;;
            int t = 1;
            for (int i = 1; i &amp;lt;= n; i *= 2)
                tag[i] = 1, t = i;
            for (int i = n; i &amp;amp;&amp;amp; L != d; --i)
                if (!tag[i]) &amp;#123;
                    // printf(&amp;quot;i = %d\n&amp;quot;, i);
                    if (L + (dep[t] + 1) - dep[i] &amp;lt;= d) &amp;#123;
                        // printf(&amp;quot;L += %d - %d\n&amp;quot;, dep[t] + 1, dep[i]);
                        L += (dep[t] + 1) - dep[i];
                        --cnt[fa[i]], cnt[i] = 0, ++cnt[t];
                        dep[i] = dep[t] + 1, fa[i] = t;
                        t = i, tag[i] = 1;
                    &amp;#125;
                    else &amp;#123;
                        for (int j = 1; j &amp;lt;= n; ++j)
                            if (cnt[j] != 2 &amp;amp;&amp;amp; L + (dep[j] + 1) - dep[i] == d) &amp;#123;
                                fa[i] = j, L = d;
                                break;
                            &amp;#125;
                    &amp;#125;
                &amp;#125;
            for (int i = 2; i &amp;lt;= n; ++i)
                std::cout &amp;lt;&amp;lt; fa[i] &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
            std::cout &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
        &amp;#125;
        else &amp;#123;
            // printf(&amp;quot;[%d, %d]\n&amp;quot;, L, R);
            std::cout &amp;lt;&amp;lt; &amp;quot;NO\n&amp;quot;;
        &amp;#125;
    &amp;#125;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;type-iii增量法-规约法&#34;&gt;Type III：增量法 / 规约法&lt;/h2&gt;
&lt;p&gt;增量法：类似数归，发现可以方便地从 &lt;span class=&#34;math inline&#34;&gt;\(n-k\)&lt;/span&gt; 扩展到 &lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt;，考虑 &lt;span class=&#34;math inline&#34;&gt;\(n-k\)&lt;/span&gt; 给 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 带来的限制 / 性质，就可以类递推地做了。&lt;/p&gt;
&lt;p&gt;规约法：发现抠掉一个好处理的 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 之后可以转化为规模为 &lt;span class=&#34;math inline&#34;&gt;\(n-k\)&lt;/span&gt; 的子问题，考虑 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 给 &lt;span class=&#34;math inline&#34;&gt;\(n - k\)&lt;/span&gt; 带来的限制，也可以类递推地做。&lt;/p&gt;
&lt;p&gt;其实真差不多哈，并不能说是一正一反之类的，因为思维路径真没太差。&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;例题经典题&#34;&gt;例题：经典题&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;给定大小为 &lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt; 的竞赛图，&lt;span class=&#34;math inline&#34;&gt;\(O(n^2)\)&lt;/span&gt; 内求出一条哈密顿路径。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;竞赛图：给完全图的每条边定向。&lt;/li&gt;
&lt;li&gt;哈密顿路径：经过每个点恰好一次，对边无要求。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;假设已经知道规模为 &lt;span class=&#34;math inline&#34;&gt;\(n-1\)&lt;/span&gt; 的子问题的解法，塞一个新点进去，考察 &lt;span class=&#34;math inline&#34;&gt;\(P(n-1)\)&lt;/span&gt; 中的 &lt;span class=&#34;math inline&#34;&gt;\(\forall\, u\to v\)&lt;/span&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;若只存在 &lt;span class=&#34;math inline&#34;&gt;\(n\to u,n\to v\)&lt;/span&gt;：对于路径起点 &lt;span class=&#34;math inline&#34;&gt;\(s\)&lt;/span&gt; 也有 &lt;span class=&#34;math inline&#34;&gt;\(n\to s\)&lt;/span&gt;，把 &lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt; 添加到开头即可。&lt;/li&gt;
&lt;li&gt;若只存在 &lt;span class=&#34;math inline&#34;&gt;\(u\to n,v\to n\)&lt;/span&gt;：对于路径终点 &lt;span class=&#34;math inline&#34;&gt;\(t\)&lt;/span&gt; 也有 &lt;span class=&#34;math inline&#34;&gt;\(t\to n\)&lt;/span&gt;，把 &lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt; 添加到末尾即可。&lt;/li&gt;
&lt;li&gt;若只存在 &lt;span class=&#34;math inline&#34;&gt;\(n\to u,v\to n\)&lt;/span&gt;：对于路径起点 &lt;span class=&#34;math inline&#34;&gt;\(s\)&lt;/span&gt; 也有 &lt;span class=&#34;math inline&#34;&gt;\(n\to s\)&lt;/span&gt;，对于路径终点 &lt;span class=&#34;math inline&#34;&gt;\(t\)&lt;/span&gt; 也有 &lt;span class=&#34;math inline&#34;&gt;\(t\to n\)&lt;/span&gt;，爱加哪儿就加哪儿。&lt;/li&gt;
&lt;li&gt;否则：存在 &lt;span class=&#34;math inline&#34;&gt;\(u\to n,n\to v\)&lt;/span&gt;，皆大欢喜，将 &lt;span class=&#34;math inline&#34;&gt;\(u\to v\)&lt;/span&gt; 改为 &lt;span class=&#34;math inline&#34;&gt;\(u\to n\to v\)&lt;/span&gt; 即可。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;由此就可以解决问题。&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;例题e---travelling-salesperson&#34;&gt;例题：E - Travelling Salesperson&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P6644&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P6644&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;注意本题为无向边！&lt;/p&gt;
&lt;p&gt;相似地，对于 &lt;span class=&#34;math inline&#34;&gt;\(P(n-1)\)&lt;/span&gt;，假如存在 &lt;span class=&#34;math inline&#34;&gt;\(u\to v\)&lt;/span&gt;，欲加入 &lt;span class=&#34;math inline&#34;&gt;\(u\to n\to v\)&lt;/span&gt; 讨论以下几种情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;若 &lt;span class=&#34;math inline&#34;&gt;\(P(n - 1)\)&lt;/span&gt; 中只含有一种颜色的边：直接加入首 / 尾即可。&lt;/li&gt;
&lt;li&gt;若存在 &lt;span class=&#34;math inline&#34;&gt;\(\color{red}{\to} u\color{red}{\to}v\color{red}{\to}\)&lt;/span&gt;、&lt;span class=&#34;math inline&#34;&gt;\(u\color{red}{\to} n\)&lt;/span&gt; 和 &lt;span class=&#34;math inline&#34;&gt;\(n\color{red}{\to} v\)&lt;/span&gt;（蓝色同理）：直接加入，皆大欢喜。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;其余情况，就是 &lt;span class=&#34;math inline&#34;&gt;\(\color{red}{\to} u\color{blue}{\to} v\color{blue}{\to}\)&lt;/span&gt; 的情况了。容易发现除了 &lt;span class=&#34;math inline&#34;&gt;\(u\color{blue}{\to} n\land n\color{red}{\to} v\)&lt;/span&gt; 之外的情况都可以直接将边加入。故接下来讨论该特例。&lt;/p&gt;
&lt;p&gt;此时在 &lt;span class=&#34;math inline&#34;&gt;\((u,v)\)&lt;/span&gt; 处无法加入；尝试考虑相邻的点。由于在 &lt;span class=&#34;math inline&#34;&gt;\(u\color{blue}{\to} v\)&lt;/span&gt; 处切换颜色，易知 &lt;span class=&#34;math inline&#34;&gt;\(u\ne s\)&lt;/span&gt;，即 &lt;span class=&#34;math inline&#34;&gt;\(u\)&lt;/span&gt; 存在前驱（记为 &lt;span class=&#34;math inline&#34;&gt;\(p\)&lt;/span&gt;）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;若存在 &lt;span class=&#34;math inline&#34;&gt;\(p\color{blue}{\to} i\)&lt;/span&gt;：连接 &lt;span class=&#34;math inline&#34;&gt;\(p,i,u\)&lt;/span&gt;，最终局面为 &lt;span class=&#34;math inline&#34;&gt;\(\color{red}{\to} p\color{blue}{\to} i\color{blue}{\to} u\color{blue}{\to} v\color{blue}{\to}\)&lt;/span&gt;，即将变换处提前两位。&lt;/li&gt;
&lt;li&gt;否则：存在 &lt;span class=&#34;math inline&#34;&gt;\(p\color{red}{\to} i\)&lt;/span&gt;，仍然连接 &lt;span class=&#34;math inline&#34;&gt;\(p,i,u\)&lt;/span&gt;，最终局面为 &lt;span class=&#34;math inline&#34;&gt;\(\color{red}{\to} p\color{red}{\to} i\color{blue}{\to} u\color{blue}{\to} v\color{blue}{\to}\)&lt;/span&gt;，即将变换处提前一位。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;由此可解决问题。可以发现并不存在所谓无解的情况 &lt;img src=&#34;/em/ll.gif&#34; /&gt; —— 倒不如说可以对所有点套用最后一种情况（和第一种）——就能够 &lt;span class=&#34;math inline&#34;&gt;\(O(n^2)\)&lt;/span&gt; 解决原问题了。&lt;/p&gt;
&lt;details&gt;
&lt;p&gt;loj 上过了但洛谷过不了 &lt;img src=&#34;/em/kt.gif&#34; /&gt;&lt;/p&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#endif
    int n;
    std::cin &amp;gt;&amp;gt; n;
    if (n == 1) &amp;#123;
        std::cout &amp;lt;&amp;lt; &amp;quot;1\n1&amp;quot; &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
        return 0;
    &amp;#125;
    std::vector&amp;lt;std::vector&amp;lt;char&amp;gt; &amp;gt; g(n + 1, std::vector&amp;lt;char&amp;gt; (n + 1));
    for (int i = 2; i &amp;lt;= n; ++i)
        for (int j = 1; j &amp;lt; i; ++j)
            std::cin &amp;gt;&amp;gt; g[i][j], g[j][i] = g[i][j];
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        std::vector&amp;lt;int&amp;gt; tag(n + 1);
        std::list&amp;lt;int&amp;gt; p(&amp;#123; i, i == 1 ? 2 : 1 &amp;#125;);
        tag[p.front()] = tag[p.back()] = 1;
        bool flag = 1;
        char R = g[p.front()][p.back()], B = ((R == &amp;#39;R&amp;#39;) ? &amp;#39;B&amp;#39; : &amp;#39;R&amp;#39;);
        auto pos = --p.end();
        for (int j = 1; j &amp;lt;= n; ++j)
            if (!tag[j]) &amp;#123;
                if (flag &amp;amp;&amp;amp; g[j][p.back()] == R)
                    // printf(&amp;quot;%d: 30  &amp;quot;, j),
                    p.push_back(j), ++pos;
                else if (g[j][p.back()] == B)
                    // printf(&amp;quot;%d: 33  &amp;quot;, j),
                    p.push_back(j), flag = 0;
                else &amp;#123;
                    auto u = pos, v = std::next(pos);
                    if (g[*u][j] == R &amp;amp;&amp;amp; g[j][*v] == R) &amp;#123;
                        // printf(&amp;quot;%d: 38  &amp;quot;, j),
                        p.insert(v, j), ++++pos;
                        if (v == --p.end())
                            flag = 1;
                    &amp;#125;
                    else if (g[*u][j] == R &amp;amp;&amp;amp; g[j][*v] == B)
                        // printf(&amp;quot;%d: 41  &amp;quot;, j),
                        p.insert(v, j), ++pos;
                    else if (g[*u][j] == B &amp;amp;&amp;amp; g[j][*v] == B)
                        // printf(&amp;quot;%d: 44  &amp;quot;, j),
                        p.insert(v, j);
                    else &amp;#123;
                        auto pr(std::prev(u));
                        if (g[*pr][j] == B)
                            // printf(&amp;quot;%d: 49  &amp;quot;, j),
                            p.insert(u, j), ----pos;
                        else
                            // printf(&amp;quot;%d: 52  &amp;quot;, j),
                            p.insert(u, j), --pos;
                    &amp;#125;
                &amp;#125;
                // for (auto j : p)
                //     std::cout &amp;lt;&amp;lt; j &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
                // printf(&amp;quot; flag = %d\n&amp;quot;, flag);
            &amp;#125;
        std::cout &amp;lt;&amp;lt; n &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
        for (auto j : p)
            std::cout &amp;lt;&amp;lt; j &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
        std::cout &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    &amp;#125;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;f---sergeys-problem&#34;&gt;F - Sergey’s problem&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://codeforces.com/problemset/problem/1019/C&#34; class=&#34;uri&#34;&gt;https://codeforces.com/problemset/problem/1019/C&lt;/a&gt;&lt;/p&gt;
 ]]></description>
        </item>
    </channel>
</rss>
