<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://xsc062.netlify.app</id>
    <title> • Posts by &#34;调整法&#34; tag</title>
    <link href="https://xsc062.netlify.app" />
    <updated>2025-05-18T06:43:30.000Z</updated>
    <category term="并查集" />
    <category term="斜率优化" />
    <category term="悬线法" />
    <category term="哈希" />
    <category term="字典树" />
    <category term="DP" />
    <category term="单调队列" />
    <category term="分治" />
    <category term="二分图" />
    <category term="CRT / exCRT" />
    <category term="排列组合" />
    <category term="网络流" />
    <category term="费用流" />
    <category term="二分" />
    <category term="上下界网络流" />
    <category term="容斥原理" />
    <category term="线段树" />
    <category term="树状数组" />
    <category term="区间 DP" />
    <category term="构造" />
    <category term="Tarjan" />
    <category term="数据结构" />
    <category term="下饭" />
    <category term="LCA" />
    <category term="倍增" />
    <category term="鸽巢原理" />
    <category term="概率期望" />
    <category term="调和级数" />
    <category term="差分" />
    <category term="思维" />
    <category term="树形 DP" />
    <category term="最小生成树" />
    <category term="SAM" />
    <category term="状压" />
    <category term="分块" />
    <category term="可持久化" />
    <category term="笛卡尔树" />
    <category term="高维前缀和" />
    <category term="闲话" />
    <category term="欧拉回路" />
    <category term="树链剖分" />
    <category term="长链剖分" />
    <category term="KMP" />
    <category term="border" />
    <category term="字符串" />
    <category term="AC 自动机" />
    <category term="SA" />
    <category term="数学" />
    <category term="树上差分" />
    <category term="FWT" />
    <category term="堆" />
    <category term="树的重心" />
    <category term="二项式定理" />
    <category term="二项式反演" />
    <category term="贪心" />
    <category term="均摊" />
    <category term="计数" />
    <category term="优化建图" />
    <category term="反悔贪心" />
    <category term="调整法" />
    <category term="背包" />
    <category term="博弈论" />
    <category term="DP 优化" />
    <category term="虚树" />
    <category term="点分治" />
    <category term="WQS 二分" />
    <category term="闵可夫斯基和" />
    <category term="slope trick" />
    <category term="四边形不等式" />
    <category term="暴力" />
    <category term="状压 DP" />
    <category term="组合数学" />
    <category term="支配对" />
    <category term="DDP" />
    <category term="平衡树" />
    <category term="容斥" />
    <category term="猫树" />
    <category term="Kruskal 重构树" />
    <category term="李超线段树" />
    <entry>
        <id>https://xsc062.netlify.app/20250518/</id>
        <title>构造类问题的很少解题方法</title>
        <link rel="alternate" href="https://xsc062.netlify.app/20250518/"/>
        <content type="html">&lt;p&gt;病毒可能具有膜结构，但不存在生物膜系统。核糖体是唯一所有细胞均含有的细胞器，但病毒中无核糖体。&lt;/p&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;
&lt;p&gt;病毒的主要组成是 &lt;span class=&#34;math inline&#34;&gt;\(10\%\sim 20\%\)&lt;/span&gt; 的核酸，&lt;span class=&#34;math inline&#34;&gt;\(60\%\sim 70\%\)&lt;/span&gt; 的蛋白质外壳，&lt;span class=&#34;math inline&#34;&gt;\(&amp;lt;10\%\)&lt;/span&gt; 的结合水，可能具有逆转录酶、RNA 聚合酶。病毒的含水量（&lt;span class=&#34;math inline&#34;&gt;\(&amp;lt;10\%\)&lt;/span&gt;）远远小于细胞（&lt;span class=&#34;math inline&#34;&gt;\(70\%\)&lt;/span&gt;）。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;type-i调整法---1&#34;&gt;Type I：调整法 - 1&lt;/h2&gt;
&lt;p&gt;虽然话是这么说，感觉这就是平常正常的做题路径，『想做法』——『发现有锅』——『打补丁』。&lt;/p&gt;
&lt;p&gt;只是可能这是在提醒你在构造题中发现有锅不要急着换做法（？）&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;例题c---stations&#34;&gt;例题：C - Stations&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://qoj.ac/problem/1139&#34; class=&#34;uri&#34;&gt;https://qoj.ac/problem/1139&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;一个简单的想法是，当可用的编号范围很大时，可以记下每个点 &lt;span class=&#34;math inline&#34;&gt;\(u\)&lt;/span&gt; 的 &lt;span class=&#34;math inline&#34;&gt;\(DFN_u\)&lt;/span&gt; 和出栈序（记为 &lt;span class=&#34;math inline&#34;&gt;\(RFN_u\)&lt;/span&gt;），这样就能解决查询；但标号是 &lt;span class=&#34;math inline&#34;&gt;\(N^2\)&lt;/span&gt; 级别的。&lt;/p&gt;
&lt;p&gt;现在思考，我们为什么需要记录 &lt;span class=&#34;math inline&#34;&gt;\(RFN_u\)&lt;/span&gt; 呢？因为在询问时，需要判断 &lt;span class=&#34;math inline&#34;&gt;\(t\)&lt;/span&gt; 的位置：如果在 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 某一儿子的子树内，答案为该儿子；否则，答案为 &lt;span class=&#34;math inline&#34;&gt;\(fa\)&lt;/span&gt;。当 &lt;span class=&#34;math inline&#34;&gt;\(DFN_t\)&lt;/span&gt; 比 &lt;span class=&#34;math inline&#34;&gt;\(u\)&lt;/span&gt; 最靠后的儿子 &lt;span class=&#34;math inline&#34;&gt;\(v\)&lt;/span&gt; 的 &lt;span class=&#34;math inline&#34;&gt;\(DFN\)&lt;/span&gt; 还要大时，无法判断 &lt;span class=&#34;math inline&#34;&gt;\(t\)&lt;/span&gt; 在 &lt;span class=&#34;math inline&#34;&gt;\(v\)&lt;/span&gt; 内还是在 &lt;span class=&#34;math inline&#34;&gt;\(u\)&lt;/span&gt; 外。&lt;/p&gt;
&lt;p&gt;此处有一个解决方案（原谅我实在无法猜出是怎么想到的），将树按奇数层、偶数层分层，计数层记录 &lt;span class=&#34;math inline&#34;&gt;\(DFN\)&lt;/span&gt;，偶数层记录 &lt;span class=&#34;math inline&#34;&gt;\(RFN\)&lt;/span&gt;（具体地，奇数层在入栈时编号，偶数层在出栈时编号）；接下来进行判断（注意我们并不知道 &lt;span class=&#34;math inline&#34;&gt;\(u\)&lt;/span&gt; 所在层数的奇偶性）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;若不存在 &lt;span class=&#34;math inline&#34;&gt;\(id_i&amp;gt;id_u\)&lt;/span&gt;，说明 &lt;span class=&#34;math inline&#34;&gt;\(id_u\)&lt;/span&gt; 为 &lt;span class=&#34;math inline&#34;&gt;\(RFN_u\)&lt;/span&gt;；此时 可以判断 &lt;span class=&#34;math inline&#34;&gt;\(t\)&lt;/span&gt; 是否位于 &lt;span class=&#34;math inline&#34;&gt;\(u\)&lt;/span&gt; 内。&lt;/li&gt;
&lt;li&gt;否则，&lt;span class=&#34;math inline&#34;&gt;\(id_u\)&lt;/span&gt; 为 &lt;span class=&#34;math inline&#34;&gt;\(DFN_u\)&lt;/span&gt;。由于知道 &lt;span class=&#34;math inline&#34;&gt;\(RFN_v\)&lt;/span&gt;，可以判断 &lt;span class=&#34;math inline&#34;&gt;\(t\)&lt;/span&gt; 是否位于 &lt;span class=&#34;math inline&#34;&gt;\(v\)&lt;/span&gt; 内。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;容易证明其他一般情况也可以判断 &lt;span class=&#34;math inline&#34;&gt;\(t\)&lt;/span&gt; 的位置。复杂度 &lt;span class=&#34;math inline&#34;&gt;\(O(n^2)\)&lt;/span&gt;。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;quot;stations.h&amp;quot;
#include &amp;lt;bits/stdc++.h&amp;gt;
std::vector&amp;lt;int&amp;gt; label(int n, int k, std::vector&amp;lt;int&amp;gt; u, std::vector&amp;lt;int&amp;gt; v) &amp;#123;
    std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; g(n);
    for (int i = 0; i &amp;lt; n - 1; ++i)
        g[u[i]].push_back(v[i]), g[v[i]].push_back(u[i]);
    std::vector&amp;lt;int&amp;gt; id(n, -1);
    int now = 0;
    std::function&amp;lt;void(int, int, int)&amp;gt; DFS = [&amp;amp;](int x, int fa, int tag) &amp;#123;
        if (tag)
            id[x] = now++;
        for (auto i : g[x])
            if (i != fa)
                DFS(i, x, tag ^ 1);
        if (!tag)
            id[x] = now++;
        return;
    &amp;#125;;
    DFS(0, -1, 1);
    return id;
&amp;#125;
int find_next_station(int s, int t, std::vector&amp;lt;int&amp;gt; c) &amp;#123;
    if (c.back() &amp;lt; s) &amp;#123;
        int fa = c.front();
        if (t &amp;gt; s)
            return fa;
        for (int i = (int)c.size() - 1; ~i; --i)
            if (t &amp;gt;= c[i])
                return c[i];
        return fa;
    &amp;#125;
    else &amp;#123;
        int fa = c.back();
        if (t &amp;lt; s)
            return fa;
        for (int i = 0; i &amp;lt; (int)c.size() - 1; ++i)
            if (t &amp;lt;= c[i])
                return c[i];
        return fa;
    &amp;#125;
    // assert(0);
    return 114514;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;type-ii调整法---2&#34;&gt;Type II：调整法 - 2&lt;/h2&gt;
&lt;p&gt;题目要求构造『恰好为 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt;』，可以先不看这个限制，对于局面求出上界和下界，然后再看是不是上下界中全部（或大多数）都能取到，此时有两个路径：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;直接在某个上界 / 下界局面中通过若干步极小改动调整到恰好为 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt;；&lt;/li&gt;
&lt;li&gt;通过这一点优化 DP 状态（这样就可以大量压缩『可到达局面』这一信息）。见 &lt;a href=&#34;/20250510/#b---miriany-and-matchstick&#34;&gt;此&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;例题d---construct-the-binary-tree&#34;&gt;例题：D - Construct the Binary Tree&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://codeforces.com/problemset/problem/1311/E&#34; class=&#34;uri&#34;&gt;https://codeforces.com/problemset/problem/1311/E&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;首先从找上下界的角度出发，发现链为上界，完全二叉树为下界。&lt;/p&gt;
&lt;p&gt;那么只需先 check &lt;span class=&#34;math inline&#34;&gt;\(d\)&lt;/span&gt; 是否在该范围内；固定树最左侧的一条链，每次拿走右下角的一个叶子（这样就能&lt;strong&gt;维持完全二叉树性质&lt;/strong&gt;），如果可以插入到链底就 do so；否则由于这是个左边挂着单链的完全二叉树，可以证明你想取的任意深度都可以取到，暴力跳即可，且跳完后就构造完了。&lt;/p&gt;
&lt;p&gt;复杂度 &lt;span class=&#34;math inline&#34;&gt;\(O(n)\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(O(nd)\)&lt;/span&gt; 是每次取点时扫一遍完全二叉树找一个能让当前点深度 &lt;span class=&#34;math inline&#34;&gt;\(+1\)&lt;/span&gt; 的父节点。&lt;span class=&#34;math inline&#34;&gt;\(O(d)\)&lt;/span&gt; 的做法是慢慢把树变窄变高，一次还是只 &lt;span class=&#34;math inline&#34;&gt;\(+1\)&lt;/span&gt;，二者的弊端都在于没利用『上界为链』即链和完全二叉树的优美性质。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#endif
    int T;
    for (std::cin &amp;gt;&amp;gt; T; T--; ) &amp;#123;
        int n, d;
        std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; d;
        std::vector&amp;lt;int&amp;gt; tag(n + 1), dep(n + 1), cnt(n + 1), fa(n + 1);
        int L = 0, R = n * (n - 1) / 2;
        for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
            L += std::__lg(i), dep[i] = std::__lg(i);
            if (i * 2 &amp;lt;= n)
                ++cnt[i], fa[i * 2] = i;
            if (i * 2 + 1 &amp;lt;= n)
                ++cnt[i], fa[i * 2 + 1] = i;
        &amp;#125;
        if (L &amp;lt;= d &amp;amp;&amp;amp; d &amp;lt;= R) &amp;#123;
            std::cout &amp;lt;&amp;lt; &amp;quot;YES\n&amp;quot;;
            int t = 1;
            for (int i = 1; i &amp;lt;= n; i *= 2)
                tag[i] = 1, t = i;
            for (int i = n; i &amp;amp;&amp;amp; L != d; --i)
                if (!tag[i]) &amp;#123;
                    // printf(&amp;quot;i = %d\n&amp;quot;, i);
                    if (L + (dep[t] + 1) - dep[i] &amp;lt;= d) &amp;#123;
                        // printf(&amp;quot;L += %d - %d\n&amp;quot;, dep[t] + 1, dep[i]);
                        L += (dep[t] + 1) - dep[i];
                        --cnt[fa[i]], cnt[i] = 0, ++cnt[t];
                        dep[i] = dep[t] + 1, fa[i] = t;
                        t = i, tag[i] = 1;
                    &amp;#125;
                    else &amp;#123;
                        for (int j = 1; j &amp;lt;= n; ++j)
                            if (cnt[j] != 2 &amp;amp;&amp;amp; L + (dep[j] + 1) - dep[i] == d) &amp;#123;
                                fa[i] = j, L = d;
                                break;
                            &amp;#125;
                    &amp;#125;
                &amp;#125;
            for (int i = 2; i &amp;lt;= n; ++i)
                std::cout &amp;lt;&amp;lt; fa[i] &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
            std::cout &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
        &amp;#125;
        else &amp;#123;
            // printf(&amp;quot;[%d, %d]\n&amp;quot;, L, R);
            std::cout &amp;lt;&amp;lt; &amp;quot;NO\n&amp;quot;;
        &amp;#125;
    &amp;#125;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;type-iii增量法-规约法&#34;&gt;Type III：增量法 / 规约法&lt;/h2&gt;
&lt;p&gt;增量法：类似数归，发现可以方便地从 &lt;span class=&#34;math inline&#34;&gt;\(n-k\)&lt;/span&gt; 扩展到 &lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt;，考虑 &lt;span class=&#34;math inline&#34;&gt;\(n-k\)&lt;/span&gt; 给 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 带来的限制 / 性质，就可以类递推地做了。&lt;/p&gt;
&lt;p&gt;规约法：发现抠掉一个好处理的 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 之后可以转化为规模为 &lt;span class=&#34;math inline&#34;&gt;\(n-k\)&lt;/span&gt; 的子问题，考虑 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 给 &lt;span class=&#34;math inline&#34;&gt;\(n - k\)&lt;/span&gt; 带来的限制，也可以类递推地做。&lt;/p&gt;
&lt;p&gt;其实真差不多哈，并不能说是一正一反之类的，因为思维路径真没太差。&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;例题经典题&#34;&gt;例题：经典题&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;给定大小为 &lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt; 的竞赛图，&lt;span class=&#34;math inline&#34;&gt;\(O(n^2)\)&lt;/span&gt; 内求出一条哈密顿路径。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;竞赛图：给完全图的每条边定向。&lt;/li&gt;
&lt;li&gt;哈密顿路径：经过每个点恰好一次，对边无要求。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;假设已经知道规模为 &lt;span class=&#34;math inline&#34;&gt;\(n-1\)&lt;/span&gt; 的子问题的解法，塞一个新点进去，考察 &lt;span class=&#34;math inline&#34;&gt;\(P(n-1)\)&lt;/span&gt; 中的 &lt;span class=&#34;math inline&#34;&gt;\(\forall\, u\to v\)&lt;/span&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;若只存在 &lt;span class=&#34;math inline&#34;&gt;\(n\to u,n\to v\)&lt;/span&gt;：对于路径起点 &lt;span class=&#34;math inline&#34;&gt;\(s\)&lt;/span&gt; 也有 &lt;span class=&#34;math inline&#34;&gt;\(n\to s\)&lt;/span&gt;，把 &lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt; 添加到开头即可。&lt;/li&gt;
&lt;li&gt;若只存在 &lt;span class=&#34;math inline&#34;&gt;\(u\to n,v\to n\)&lt;/span&gt;：对于路径终点 &lt;span class=&#34;math inline&#34;&gt;\(t\)&lt;/span&gt; 也有 &lt;span class=&#34;math inline&#34;&gt;\(t\to n\)&lt;/span&gt;，把 &lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt; 添加到末尾即可。&lt;/li&gt;
&lt;li&gt;若只存在 &lt;span class=&#34;math inline&#34;&gt;\(n\to u,v\to n\)&lt;/span&gt;：对于路径起点 &lt;span class=&#34;math inline&#34;&gt;\(s\)&lt;/span&gt; 也有 &lt;span class=&#34;math inline&#34;&gt;\(n\to s\)&lt;/span&gt;，对于路径终点 &lt;span class=&#34;math inline&#34;&gt;\(t\)&lt;/span&gt; 也有 &lt;span class=&#34;math inline&#34;&gt;\(t\to n\)&lt;/span&gt;，爱加哪儿就加哪儿。&lt;/li&gt;
&lt;li&gt;否则：存在 &lt;span class=&#34;math inline&#34;&gt;\(u\to n,n\to v\)&lt;/span&gt;，皆大欢喜，将 &lt;span class=&#34;math inline&#34;&gt;\(u\to v\)&lt;/span&gt; 改为 &lt;span class=&#34;math inline&#34;&gt;\(u\to n\to v\)&lt;/span&gt; 即可。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;由此就可以解决问题。&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;例题e---travelling-salesperson&#34;&gt;例题：E - Travelling Salesperson&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P6644&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P6644&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;注意本题为无向边！&lt;/p&gt;
&lt;p&gt;相似地，对于 &lt;span class=&#34;math inline&#34;&gt;\(P(n-1)\)&lt;/span&gt;，假如存在 &lt;span class=&#34;math inline&#34;&gt;\(u\to v\)&lt;/span&gt;，欲加入 &lt;span class=&#34;math inline&#34;&gt;\(u\to n\to v\)&lt;/span&gt; 讨论以下几种情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;若 &lt;span class=&#34;math inline&#34;&gt;\(P(n - 1)\)&lt;/span&gt; 中只含有一种颜色的边：直接加入首 / 尾即可。&lt;/li&gt;
&lt;li&gt;若存在 &lt;span class=&#34;math inline&#34;&gt;\(\color{red}{\to} u\color{red}{\to}v\color{red}{\to}\)&lt;/span&gt;、&lt;span class=&#34;math inline&#34;&gt;\(u\color{red}{\to} n\)&lt;/span&gt; 和 &lt;span class=&#34;math inline&#34;&gt;\(n\color{red}{\to} v\)&lt;/span&gt;（蓝色同理）：直接加入，皆大欢喜。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;其余情况，就是 &lt;span class=&#34;math inline&#34;&gt;\(\color{red}{\to} u\color{blue}{\to} v\color{blue}{\to}\)&lt;/span&gt; 的情况了。容易发现除了 &lt;span class=&#34;math inline&#34;&gt;\(u\color{blue}{\to} n\land n\color{red}{\to} v\)&lt;/span&gt; 之外的情况都可以直接将边加入。故接下来讨论该特例。&lt;/p&gt;
&lt;p&gt;此时在 &lt;span class=&#34;math inline&#34;&gt;\((u,v)\)&lt;/span&gt; 处无法加入；尝试考虑相邻的点。由于在 &lt;span class=&#34;math inline&#34;&gt;\(u\color{blue}{\to} v\)&lt;/span&gt; 处切换颜色，易知 &lt;span class=&#34;math inline&#34;&gt;\(u\ne s\)&lt;/span&gt;，即 &lt;span class=&#34;math inline&#34;&gt;\(u\)&lt;/span&gt; 存在前驱（记为 &lt;span class=&#34;math inline&#34;&gt;\(p\)&lt;/span&gt;）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;若存在 &lt;span class=&#34;math inline&#34;&gt;\(p\color{blue}{\to} i\)&lt;/span&gt;：连接 &lt;span class=&#34;math inline&#34;&gt;\(p,i,u\)&lt;/span&gt;，最终局面为 &lt;span class=&#34;math inline&#34;&gt;\(\color{red}{\to} p\color{blue}{\to} i\color{blue}{\to} u\color{blue}{\to} v\color{blue}{\to}\)&lt;/span&gt;，即将变换处提前两位。&lt;/li&gt;
&lt;li&gt;否则：存在 &lt;span class=&#34;math inline&#34;&gt;\(p\color{red}{\to} i\)&lt;/span&gt;，仍然连接 &lt;span class=&#34;math inline&#34;&gt;\(p,i,u\)&lt;/span&gt;，最终局面为 &lt;span class=&#34;math inline&#34;&gt;\(\color{red}{\to} p\color{red}{\to} i\color{blue}{\to} u\color{blue}{\to} v\color{blue}{\to}\)&lt;/span&gt;，即将变换处提前一位。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;由此可解决问题。可以发现并不存在所谓无解的情况 &lt;img src=&#34;/em/ll.gif&#34; /&gt; —— 倒不如说可以对所有点套用最后一种情况（和第一种）——就能够 &lt;span class=&#34;math inline&#34;&gt;\(O(n^2)\)&lt;/span&gt; 解决原问题了。&lt;/p&gt;
&lt;details&gt;
&lt;p&gt;loj 上过了但洛谷过不了 &lt;img src=&#34;/em/kt.gif&#34; /&gt;&lt;/p&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#endif
    int n;
    std::cin &amp;gt;&amp;gt; n;
    if (n == 1) &amp;#123;
        std::cout &amp;lt;&amp;lt; &amp;quot;1\n1&amp;quot; &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
        return 0;
    &amp;#125;
    std::vector&amp;lt;std::vector&amp;lt;char&amp;gt; &amp;gt; g(n + 1, std::vector&amp;lt;char&amp;gt; (n + 1));
    for (int i = 2; i &amp;lt;= n; ++i)
        for (int j = 1; j &amp;lt; i; ++j)
            std::cin &amp;gt;&amp;gt; g[i][j], g[j][i] = g[i][j];
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        std::vector&amp;lt;int&amp;gt; tag(n + 1);
        std::list&amp;lt;int&amp;gt; p(&amp;#123; i, i == 1 ? 2 : 1 &amp;#125;);
        tag[p.front()] = tag[p.back()] = 1;
        bool flag = 1;
        char R = g[p.front()][p.back()], B = ((R == &amp;#39;R&amp;#39;) ? &amp;#39;B&amp;#39; : &amp;#39;R&amp;#39;);
        auto pos = --p.end();
        for (int j = 1; j &amp;lt;= n; ++j)
            if (!tag[j]) &amp;#123;
                if (flag &amp;amp;&amp;amp; g[j][p.back()] == R)
                    // printf(&amp;quot;%d: 30  &amp;quot;, j),
                    p.push_back(j), ++pos;
                else if (g[j][p.back()] == B)
                    // printf(&amp;quot;%d: 33  &amp;quot;, j),
                    p.push_back(j), flag = 0;
                else &amp;#123;
                    auto u = pos, v = std::next(pos);
                    if (g[*u][j] == R &amp;amp;&amp;amp; g[j][*v] == R) &amp;#123;
                        // printf(&amp;quot;%d: 38  &amp;quot;, j),
                        p.insert(v, j), ++++pos;
                        if (v == --p.end())
                            flag = 1;
                    &amp;#125;
                    else if (g[*u][j] == R &amp;amp;&amp;amp; g[j][*v] == B)
                        // printf(&amp;quot;%d: 41  &amp;quot;, j),
                        p.insert(v, j), ++pos;
                    else if (g[*u][j] == B &amp;amp;&amp;amp; g[j][*v] == B)
                        // printf(&amp;quot;%d: 44  &amp;quot;, j),
                        p.insert(v, j);
                    else &amp;#123;
                        auto pr(std::prev(u));
                        if (g[*pr][j] == B)
                            // printf(&amp;quot;%d: 49  &amp;quot;, j),
                            p.insert(u, j), ----pos;
                        else
                            // printf(&amp;quot;%d: 52  &amp;quot;, j),
                            p.insert(u, j), --pos;
                    &amp;#125;
                &amp;#125;
                // for (auto j : p)
                //     std::cout &amp;lt;&amp;lt; j &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
                // printf(&amp;quot; flag = %d\n&amp;quot;, flag);
            &amp;#125;
        std::cout &amp;lt;&amp;lt; n &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
        for (auto j : p)
            std::cout &amp;lt;&amp;lt; j &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
        std::cout &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    &amp;#125;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;f---sergeys-problem&#34;&gt;F - Sergey’s problem&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://codeforces.com/problemset/problem/1019/C&#34; class=&#34;uri&#34;&gt;https://codeforces.com/problemset/problem/1019/C&lt;/a&gt;&lt;/p&gt;
</content>
        <category term="构造" />
        <category term="调整法" />
        <updated>2025-05-18T06:43:30.000Z</updated>
    </entry>
</feed>
