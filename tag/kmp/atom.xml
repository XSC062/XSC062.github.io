<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://xsc062.netlify.app</id>
    <title> • Posts by &#34;kmp&#34; tag</title>
    <link href="https://xsc062.netlify.app" />
    <updated>2024-10-21T00:32:59.000Z</updated>
    <category term="并查集" />
    <category term="斜率优化" />
    <category term="悬线法" />
    <category term="哈希" />
    <category term="字典树" />
    <category term="DP" />
    <category term="单调队列" />
    <category term="分治" />
    <category term="二分图" />
    <category term="CRT / exCRT" />
    <category term="排列组合" />
    <category term="网络流" />
    <category term="费用流" />
    <category term="二分" />
    <category term="上下界网络流" />
    <category term="容斥原理" />
    <category term="线段树" />
    <category term="树状数组" />
    <category term="区间 DP" />
    <category term="构造" />
    <category term="Tarjan" />
    <category term="数据结构" />
    <category term="下饭" />
    <category term="LCA" />
    <category term="倍增" />
    <category term="鸽巢原理" />
    <category term="概率期望" />
    <category term="调和级数" />
    <category term="差分" />
    <category term="思维" />
    <category term="树形 DP" />
    <category term="最小生成树" />
    <category term="SAM" />
    <category term="状压" />
    <category term="分块" />
    <category term="可持久化" />
    <category term="笛卡尔树" />
    <category term="高维前缀和" />
    <category term="闲话" />
    <category term="欧拉回路" />
    <category term="树链剖分" />
    <category term="长链剖分" />
    <category term="KMP" />
    <category term="border" />
    <category term="字符串" />
    <category term="AC 自动机" />
    <category term="SA" />
    <category term="数学" />
    <category term="树上差分" />
    <category term="FWT" />
    <category term="堆" />
    <category term="树的重心" />
    <category term="二项式定理" />
    <category term="二项式反演" />
    <category term="贪心" />
    <category term="均摊" />
    <category term="计数" />
    <category term="优化建图" />
    <category term="反悔贪心" />
    <category term="调整法" />
    <category term="背包" />
    <category term="博弈论" />
    <category term="DP 优化" />
    <category term="虚树" />
    <category term="点分治" />
    <category term="WQS 二分" />
    <category term="闵可夫斯基和" />
    <category term="slope trick" />
    <category term="四边形不等式" />
    <category term="暴力" />
    <category term="状压 DP" />
    <category term="组合数学" />
    <category term="支配对" />
    <category term="DDP" />
    <category term="平衡树" />
    <category term="容斥" />
    <category term="猫树" />
    <category term="Kruskal 重构树" />
    <category term="李超线段树" />
    <entry>
        <id>https://xsc062.netlify.app/20241021/</id>
        <title>字符串</title>
        <link rel="alternate" href="https://xsc062.netlify.app/20241021/"/>
        <content type="html">&lt;p&gt;标题本来叫「哈希」，后来发现第二天的很多题虽然打了哈希的 tag 但是只有 KMP 做法，故忍痛改成「字符串」。&lt;/p&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;a.-two-permutations&#34;&gt;A. Two Permutations&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://222.180.160.110:61235/contest/5653/problem/1&#34; class=&#34;uri&#34;&gt;http://222.180.160.110:61235/contest/5653/problem/1&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;有个很重要的性质是 &lt;span class=&#34;math inline&#34;&gt;\(a\)&lt;/span&gt; 和 &lt;span class=&#34;math inline&#34;&gt;\(b\)&lt;/span&gt; 都是排列。然后我们就知道了 &lt;span class=&#34;math inline&#34;&gt;\(x\in [0,m-n]\)&lt;/span&gt;，且每个 &lt;span class=&#34;math inline&#34;&gt;\(a_i+x\)&lt;/span&gt; 在 &lt;span class=&#34;math inline&#34;&gt;\(b\)&lt;/span&gt; 中有元素与之唯一对应。&lt;mark&gt;于是问题可以转化成，&lt;span class=&#34;math inline&#34;&gt;\(b\)&lt;/span&gt; 中在 &lt;span class=&#34;math inline&#34;&gt;\([1+x,n+x]\)&lt;/span&gt; 范围中的元素按顺序哈希起来和 &lt;span class=&#34;math inline&#34;&gt;\(a\)&lt;/span&gt; 序列是否完全一致&lt;/mark&gt;。&lt;/p&gt;
&lt;p&gt;我们就有了一个想法：枚举这个 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt;，通过某种方法快速查询这个长度固定的值域区间按顺序哈希起来的值。&lt;mark&gt;然后就是典中典之线段树维护哈希，只需在枚举 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 时滑动窗口，剔除头部元素，新增尾部元素，查询全局哈希值即可&lt;/mark&gt;。&lt;/p&gt;
&lt;p&gt;还有一个小细节是关于实时维护全局加 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 后的 &lt;span class=&#34;math inline&#34;&gt;\(a\)&lt;/span&gt;。由于哈希用乘的肯定拆不开，只能用加哈希了。每次 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 加一的时候全局哈希值加上 &lt;span class=&#34;math inline&#34;&gt;\(\sum p_i\)&lt;/span&gt; 即可。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int p = 998244353;
const int mod = 1e9 + 7;
const int maxn = 2e5 + 5;
struct &amp;#123;
    int l, r, s;
    long long u;
&amp;#125; t[maxn &amp;lt;&amp;lt; 2];
long long base[maxn];
#define lt (p &amp;lt;&amp;lt; 1)
#define rt (lt | 1)
void pushup(int p) &amp;#123;
    t[p].u = (t[lt].u * base[t[rt].s] % mod + t[rt].u) % mod;
    return;
&amp;#125;
void bld(int p, int l, int r) &amp;#123;
    t[p].l = l, t[p].r = r;
    if (l == r)
        return;
    int mid = (l + r) &amp;gt;&amp;gt; 1;
    bld(lt, l, mid), bld(rt, mid + 1, r);
    return;
&amp;#125;
void add(int p, int x, int v) &amp;#123;
    t[p].s += (v &amp;gt;= 0 ? 1 : -1);
    if (t[p].l == t[p].r) &amp;#123;
        t[p].u += v;
        return;
    &amp;#125;
    int mid = (t[p].l + t[p].r) &amp;gt;&amp;gt; 1;
    if (x &amp;lt;= mid)
        add(lt, x, v);
    else
        add(rt, x, v);
    pushup(p);
    return;
&amp;#125;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#endif
    int n, m;
    std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
    std::vector&amp;lt;int&amp;gt; a(n + 1), b(m + 1), pos(m + 1);
    base[0] = 1;
    long long s = 1;
    for (int i = 1; i &amp;lt;= m; ++i) &amp;#123;
        base[i] = base[i - 1] * p % mod;
        if (i &amp;lt; n)
            (s += base[i]) %= mod;
    &amp;#125;
    long long now = 0;
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        std::cin &amp;gt;&amp;gt; a[i];
        now = (now * p % mod + a[i]) % mod;
    &amp;#125;
    for (int i = 1; i &amp;lt;= m; ++i)
        std::cin &amp;gt;&amp;gt; b[i], pos[b[i]] = i;
    int res = 0;
    bld(1, 1, m);
    for (int x = 0; x &amp;lt;= m - n; ++x) &amp;#123;
        for (static int l = 1; l &amp;lt; 1 + x; add(1, pos[l], -l), ++l);
            // printf(&amp;quot;add %d: %d\n&amp;quot;, pos[l], -l);
        for (static int r = 1; r &amp;lt;= n + x; add(1, pos[r], r), ++r);
            // printf(&amp;quot;add %d: %d\n&amp;quot;, pos[r], r);
        (res += (now == t[1].u));
        // printf(&amp;quot;x = %d, now = %lld, t[1].u = %lld\n&amp;quot;, x, now, t[1].u);
        (now += s) %= mod;
    &amp;#125;
    std::cout &amp;lt;&amp;lt; res &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;b.-k-substrings&#34;&gt;B. k-substrings&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://222.180.160.110:61235/contest/5653/problem/2&#34; class=&#34;uri&#34;&gt;http://222.180.160.110:61235/contest/5653/problem/2&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我们可以发现这 &lt;span class=&#34;math inline&#34;&gt;\(\left\lceil\dfrac n2\right\rceil\)&lt;/span&gt; 个串都有共同中点，而&lt;mark&gt;不管其位于元素还是元素间的空隙，两边的 border 都应关于其对称&lt;/mark&gt;。啥叫奇 border 呢，就是每个 border 都能取到元素上的中点，&lt;mark&gt;也就是说这俩中点是关于全串中点对称的&lt;/mark&gt;。&lt;/p&gt;
&lt;p&gt;我们枚举这 &lt;span class=&#34;math inline&#34;&gt;\(\left\lfloor\dfrac n2\right\rfloor\)&lt;/span&gt; 对可能的 border 中点，分别二分 border 长度。假设最后该对中点最长合法 border 为 &lt;span class=&#34;math inline&#34;&gt;\([l_1,r_1]\)&lt;/span&gt; 与 &lt;span class=&#34;math inline&#34;&gt;\([l_2,r_2]\)&lt;/span&gt;，用 &lt;span class=&#34;math inline&#34;&gt;\(r_1-l_1+1-2\times k\)&lt;/span&gt; 更新 &lt;span class=&#34;math inline&#34;&gt;\(l_1+k\)&lt;/span&gt; 处的答案即可。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int p = 131;
const int mod = 1e9 + 7;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#endif
    int n;
    std::cin &amp;gt;&amp;gt; n;
    std::vector&amp;lt;char&amp;gt; a(n + 1);
    std::vector&amp;lt;int&amp;gt; res(n + 1, -1);
    std::vector&amp;lt;long long&amp;gt; h(n + 1), base(n + 1);
    base[0] = 1;
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        std::cin &amp;gt;&amp;gt; a[i];
        h[i] = (h[i - 1] * p + a[i]) % mod;
        base[i] = base[i - 1] * p % mod;
    &amp;#125;
    auto geth = [&amp;amp;](int l, int r) &amp;#123;
        return (h[r] + mod - h[l - 1] * base[r - l + 1] % mod) % mod;
    &amp;#125;;
    for (int l = n / 2, r = (n + 1) / 2 + 1; r &amp;lt;= n; --l, ++r)
        if (a[l] == a[r]) &amp;#123;
            int t = 0;
            for (int ll = 1, rr = l, mid; ll &amp;lt;= rr; ) &amp;#123;
                mid = (ll + rr) &amp;gt;&amp;gt; 1;
                if (geth(l - mid + 1, l + mid - 1) == geth(r - mid + 1, r + mid - 1))
                    t = mid, ll = mid + 1;
                else
                    rr = mid - 1;
            &amp;#125;
            res[l - t + 1] = std::max(res[l - t + 1], 2 * t - 1);
        &amp;#125;
    for (int i = 1; i &amp;lt;= (n + 1) / 2; ++i) &amp;#123;
        res[i] = std::max(res[i - 1] - 2, res[i]);
        std::cout &amp;lt;&amp;lt; res[i] &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
    &amp;#125;
    std::cout &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;c.-kefa-and-watch&#34;&gt;C. Kefa and Watch&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://222.180.160.110:61235/contest/5653/problem/3&#34; class=&#34;uri&#34;&gt;http://222.180.160.110:61235/contest/5653/problem/3&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;一个挺常用的 trick 是，&lt;mark&gt;&lt;span class=&#34;math inline&#34;&gt;\(S_{l\sim r}\)&lt;/span&gt; 存在长度为 &lt;span class=&#34;math inline&#34;&gt;\(d\)&lt;/span&gt; 的循环节 &lt;span class=&#34;math inline&#34;&gt;\(\iff S_{l\sim (r-d)}=S_{(l+d+)\sim r}\)&lt;/span&gt;&lt;/mark&gt;。而题目要求为混循环节，刚好也可以用这个方法判定。线段树随便维护一下哈希就行。assign 操作就是将长度为 &lt;span class=&#34;math inline&#34;&gt;\(len\)&lt;/span&gt; 的区间哈希值更改为 &lt;span class=&#34;math inline&#34;&gt;\(t\times \sum_{i=0}^{len-1}p^i\)&lt;/span&gt;。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int p = 131;
const int mod = 1e9 + 7;
const int maxn = 1e5 + 5;
struct &amp;#123;
    int l, r, d;
    long long u;
&amp;#125; t[maxn &amp;lt;&amp;lt; 2];
int a[maxn];
long long base[maxn], s[maxn];
#define lt (p &amp;lt;&amp;lt; 1)
#define rt (lt | 1)
void pushup(int p) &amp;#123;
    t[p].u = (t[lt].u * base[t[rt].r - t[rt].l + 1] % mod + t[rt].u) % mod;
    return;
&amp;#125;
void pushdown(int p) &amp;#123;
    if (~t[p].d) &amp;#123;
        t[lt].d = t[rt].d = t[p].d;
        t[lt].u = t[p].d * s[t[lt].r - t[lt].l] % mod;
        t[rt].u = t[p].d * s[t[rt].r - t[rt].l] % mod;
        t[p].d = -1;
    &amp;#125;
    return;
&amp;#125;
void bld(int p, int l, int r) &amp;#123;
    t[p].l = l, t[p].r = r, t[p].d = -1;
    if (l == r) &amp;#123;
        t[p].u = a[l];
        return;
    &amp;#125;
    int mid = (l + r) &amp;gt;&amp;gt; 1;
    bld(lt, l, mid), bld(rt, mid + 1, r);
    pushup(p);
    return;
&amp;#125;
void ass(int p, int l, int r, int v) &amp;#123;
    if (l &amp;lt;= t[p].l &amp;amp;&amp;amp; t[p].r &amp;lt;= r) &amp;#123;
        t[p].d = v;
        t[p].u = v * s[t[p].r - t[p].l] % mod;
        return;
    &amp;#125;
    pushdown(p);
    int mid = (t[p].l + t[p].r) &amp;gt;&amp;gt; 1;
    if (l &amp;lt;= mid)
        ass(lt, l, r, v);
    if (r &amp;gt; mid)
        ass(rt, l, r, v);
    pushup(p);
    return;
&amp;#125;
long long ask(int p, int l, int r) &amp;#123;
    // printf(&amp;quot;p = %d, u = %lld, [%d, %d] of [%d, %d]\n&amp;quot;, p, t[p].u, t[p].l, t[p].r, l, r);
    if (l &amp;lt;= t[p].l &amp;amp;&amp;amp; t[p].r &amp;lt;= r)
        return t[p].u;
    pushdown(p);
    int mid = (t[p].l + t[p].r) &amp;gt;&amp;gt; 1;
    if (r &amp;lt;= mid)
        return ask(lt, l, r);
    if (l &amp;gt; mid)
        return ask(rt, l, r);
    return (ask(lt, l, r) * base[std::min(r, t[p].r) - mid] % mod + ask(rt, l, r)) % mod;
&amp;#125;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#endif
    int n, m, k;
    std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m &amp;gt;&amp;gt; k;
    base[0] = s[0] = 1;
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        char t;
        std::cin &amp;gt;&amp;gt; t;
        a[i] = t - &amp;#39;0&amp;#39;;
        base[i] = base[i - 1] * p % mod;
        s[i] = (s[i - 1] + base[i]) % mod;
    &amp;#125;
    bld(1, 1, n);
    for (int q = m + k; q--; ) &amp;#123;
        int op;
        std::cin &amp;gt;&amp;gt; op;
        if (op == 1) &amp;#123;
            int l, r, t;
            std::cin &amp;gt;&amp;gt; l &amp;gt;&amp;gt; r &amp;gt;&amp;gt; t;
            ass(1, l, r, t);
        &amp;#125;
        else &amp;#123;
            int l, r, d;
            std::cin &amp;gt;&amp;gt; l &amp;gt;&amp;gt; r &amp;gt;&amp;gt; d;
            // if (d != r - l + 1)
            //     printf(&amp;quot;%lld / %lld\n&amp;quot;, ask(1, l, r - d), ask(1, l + d, r));
            std::cout &amp;lt;&amp;lt; ((d == r - l + 1 || ask(1, l, r - d) == ask(1, l + d, r)) ? &amp;quot;YES&amp;quot; : &amp;quot;NO&amp;quot;) &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
        &amp;#125;
    &amp;#125;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;d.-misha-and-lcp-on-tree&#34;&gt;D. Misha and LCP on Tree&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://222.180.160.110:61235/contest/5653/problem/4&#34; class=&#34;uri&#34;&gt;http://222.180.160.110:61235/contest/5653/problem/4&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;一个很显然的做法是，我们二分一个长度，然后在 &lt;span class=&#34;math inline&#34;&gt;\(a\to fa\)&lt;/span&gt; 上正哈希，&lt;span class=&#34;math inline&#34;&gt;\(b\to fa\)&lt;/span&gt; 上反哈希，&lt;span class=&#34;math inline&#34;&gt;\(O(1)\)&lt;/span&gt; check。&lt;/p&gt;
&lt;p&gt;笑话：本来想用倍增求 &lt;span class=&#34;math inline&#34;&gt;\(a\to fa\)&lt;/span&gt; 和 &lt;span class=&#34;math inline&#34;&gt;\(b\to fa\)&lt;/span&gt; 的哈希（当然双 &lt;span class=&#34;math inline&#34;&gt;\(\log\)&lt;/span&gt; 肯定是会被卡飞的），后来发现&lt;mark&gt;哈希具有可减性，我们又只需求一条链上的哈希值，直接减掉就行&lt;/mark&gt;。&lt;/p&gt;
&lt;p&gt;还有一个点就是 &lt;span class=&#34;math inline&#34;&gt;\(O(1)\)&lt;/span&gt; 求 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 级祖先，有长剖预处理的做法。&lt;a href=&#34;/20241021-1&#34;&gt;具体做法&lt;/a&gt;。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int p = 131;
const int mod = 1e9 + 7;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#endif
    int n;
    std::cin &amp;gt;&amp;gt; n;
    std::vector&amp;lt;int&amp;gt; to(n + 1);
    std::vector&amp;lt;char&amp;gt; a(n + 1);
    std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; g(n + 1);
    std::vector&amp;lt;long long&amp;gt; base(n + 1), inv(n + 1);
    auto qkp = [](long long x, int y) &amp;#123;
        long long res = 1;
        for (; y; (x *= x) %= mod, y &amp;gt;&amp;gt;= 1)
            if (y &amp;amp; 1)
                (res *= x) %= mod;
        return res;
    &amp;#125;;
    base[0] = inv[0] = 1;
    for (int i = 1, mx = 0; i &amp;lt;= n; ++i) &amp;#123;
        std::cin &amp;gt;&amp;gt; a[i];
        base[i] = base[i - 1] * p % mod;
        inv[i] = qkp(base[i], mod - 2);
        if (i &amp;gt;= (1 &amp;lt;&amp;lt; mx) * 2)
            ++mx;
        to[i] = mx;
    &amp;#125;
    for (int i = 1, x, y; i &amp;lt; n; ++i) &amp;#123;
        std::cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; y;
        g[x].push_back(y), g[y].push_back(x);
    &amp;#125;
    std::vector&amp;lt;long long&amp;gt; h1(n + 1), h2(n + 1);
    std::vector&amp;lt;std::array&amp;lt;int, 21&amp;gt; &amp;gt; fa(n + 1);
    std::vector&amp;lt;int&amp;gt; h(n + 1, 1), son(n + 1), dep(n + 1);
    h[0] = 0;
    std::function&amp;lt;void(int)&amp;gt; DFS = [&amp;amp;](int x) &amp;#123;
        h1[x] = (h1[fa[x][0]] * p % mod + a[x]) % mod;
        h2[x] = (h2[fa[x][0]] + a[x] * base[dep[x] - 1]) % mod;
        for (auto i : g[x])
            if (i != fa[x][0]) &amp;#123;
                fa[i][0] = x;
                for (int j = 1; j &amp;lt;= 20; ++j)
                    fa[i][j] = fa[fa[i][j - 1]][j - 1];
                dep[i] = dep[x] + 1;
                DFS(i);
                if (h[i] &amp;gt;= h[son[x]])
                    son[x] = i, h[x] = h[i] + 1;
            &amp;#125;
        return;
    &amp;#125;;
    dep[1] = 1, DFS(1);
    std::vector&amp;lt;int&amp;gt; top(n + 1), id(n + 1);
    std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; anc(n + 1), des(n + 1, std::vector&amp;lt;int&amp;gt; (1));
    std::function&amp;lt;void(int, int)&amp;gt; DFS1 = [&amp;amp;](int x, int toq) &amp;#123;
        top[x] = toq;
        if (son[x])
            DFS1(son[x], toq);
        for (auto i : g[x])
            if (i != fa[x][0] &amp;amp;&amp;amp; i != son[x])
                DFS1(i, i);
        des[toq].push_back(x);
        id[x] = (int)des[toq].size() - 1;
        if (x == toq) &amp;#123;
            anc[x].push_back(x);
            for (int j = 1, now = x; j &amp;lt;= id[x]; ++j, now = fa[now][0])
                anc[x].push_back(fa[now][0]);
        &amp;#125;
        return;
    &amp;#125;;
    DFS1(1, 1);
    auto getLCA = [&amp;amp;](int x, int y) &amp;#123;
        if (dep[x] &amp;lt; dep[y])
            std::swap(x, y);
        for (int i = 20; ~i; --i)
            if (dep[fa[x][i]] &amp;gt;= dep[y])
                x = fa[x][i];
        if (x == y)
            return x;
        for (int i = 20; ~i; --i)
            if (fa[x][i] != fa[y][i])
                x = fa[x][i], y = fa[y][i];
        return fa[x][0];
    &amp;#125;;
    auto ask = [&amp;amp;](int x, int k) &amp;#123;
        assert(dep[x] - 1 &amp;gt;= k);
        int x1 = x;
        if (!k)
            return x;
        x = fa[x][to[k]];
        if (dep[x] - dep[top[x]] &amp;gt;= k - (1 &amp;lt;&amp;lt; to[k]))
            return des[top[x]][id[x] + k - (1 &amp;lt;&amp;lt; to[k])];
        return anc[top[x]][k - (1 &amp;lt;&amp;lt; to[k]) - (dep[x] - dep[top[x]])];
    &amp;#125;;
    auto dis = [&amp;amp;](int x, int y, int fa) &amp;#123;
        return dep[x] + dep[y] - 2 * dep[fa];
    &amp;#125;;
    auto gethash = [&amp;amp;](int x, int y, int f, int k) &amp;#123;
        if (!k)
            return 0ll;
        if (k &amp;lt;= dep[x] - dep[f] + 1) &amp;#123;
            f = ask(x, k - 1);
            return (h2[x] + mod - h2[fa[f][0]]) % mod * inv[dep[f] - 1] % mod;
        &amp;#125;
        long long h = (h2[x] + mod - h2[fa[f][0]]) % mod * inv[dep[f] - 1] % mod;
        k -= (dep[x] - dep[f] + 1);
        y = ask(y, (dep[y] - dep[f]) - k);
        h = (h * base[dep[y] - dep[f]] % mod + (h1[y] + mod - h1[f] * base[dep[y] - dep[f]] % mod) % mod) % mod;
        return h;
    &amp;#125;;
    int m;
    std::cin &amp;gt;&amp;gt; m;
    for (int x, y, a, b; m--; ) &amp;#123;
        std::cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; y &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b;
        int fa1 = getLCA(x, y), fa2 = getLCA(a, b), res = 0;
        for (int l = 0, r = std::min(dis(x, y, fa1), dis(a, b, fa2)) + 1, mid; l &amp;lt;= r; ) &amp;#123;
            mid = (l + r) &amp;gt;&amp;gt; 1;
            if (gethash(x, y, fa1, mid) == gethash(a, b, fa2, mid))
                res = mid, l = mid + 1;
            else
                r = mid - 1;
        &amp;#125;
        std::cout &amp;lt;&amp;lt; res &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    &amp;#125;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;a.-song-of-the-sirens&#34;&gt;A. Song of the Sirens&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://222.180.160.110:61235/contest/5658/problem/1&#34; class=&#34;uri&#34;&gt;http://222.180.160.110:61235/contest/5658/problem/1&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;笑话：是 &lt;span class=&#34;math inline&#34;&gt;\(s_it_is_i\)&lt;/span&gt; 而不是 &lt;span class=&#34;math inline&#34;&gt;\(s_its_i\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;我们发现 &lt;span class=&#34;math inline&#34;&gt;\(s_0\)&lt;/span&gt; 很短，所以直接枚举起始位置把 &lt;span class=&#34;math inline&#34;&gt;\(s_0\)&lt;/span&gt; 和匹配串大力匹配，把空位挖出来组成新的匹配串再考虑 &lt;span class=&#34;math inline&#34;&gt;\(t\)&lt;/span&gt; 的问题（因为所有 &lt;span class=&#34;math inline&#34;&gt;\(s_i\)&lt;/span&gt; 最开头都有一个完整的 &lt;span class=&#34;math inline&#34;&gt;\(s_0\)&lt;/span&gt;，所以可以随便选断点）。&lt;/p&gt;
&lt;p&gt;我们知道 &lt;span class=&#34;math inline&#34;&gt;\(t\)&lt;/span&gt; 的下标是一个自底向上从 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt; 到 &lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt; 的满二叉树的中序遍历，其中 &lt;mark&gt;&lt;span class=&#34;math inline&#34;&gt;\(t_1\)&lt;/span&gt; 间隔一位出现；于是我们仿照对 &lt;span class=&#34;math inline&#34;&gt;\(s\)&lt;/span&gt; 的处理方式，再把 &lt;span class=&#34;math inline&#34;&gt;\(t_1\)&lt;/span&gt; 挖掉。注意到此时 &lt;span class=&#34;math inline&#34;&gt;\(t_2\)&lt;/span&gt; 又成为二叉树最底层，间隔一位出现，这就变成了一个 &lt;span class=&#34;math inline&#34;&gt;\(\mathcal O(n\log n)\)&lt;/span&gt; 递归的问题&lt;/mark&gt;。&lt;/p&gt;
&lt;p&gt;至于答案，当 &lt;span class=&#34;math inline&#34;&gt;\(t\)&lt;/span&gt; 被删空时，假设删掉的最后一个元素为 &lt;span class=&#34;math inline&#34;&gt;\(t_p\)&lt;/span&gt;，&lt;span class=&#34;math inline&#34;&gt;\(t\)&lt;/span&gt; 的出现次数即为二叉树中 &lt;span class=&#34;math inline&#34;&gt;\(p\)&lt;/span&gt; 层点数，为 &lt;span class=&#34;math inline&#34;&gt;\(2^{k-p}\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;有一个细节，就是如果当前删到 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 了，&lt;span class=&#34;math inline&#34;&gt;\(t\)&lt;/span&gt; 的长度只剩 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt;，就会有一个很尴尬的问题——这个元素不一定就是 &lt;span class=&#34;math inline&#34;&gt;\(t_i\)&lt;/span&gt;，而应该是 &lt;span class=&#34;math inline&#34;&gt;\(\{j \mid j\ge i\land t_j=t_i\}\)&lt;/span&gt;。统计 &lt;span class=&#34;math inline&#34;&gt;\(t_{i\sim k}\)&lt;/span&gt; 中值为 &lt;span class=&#34;math inline&#34;&gt;\(t_i\)&lt;/span&gt; 的元素个数（前缀和），乘上对应的层数即可。这个可以用一点小技巧搞定，前缀和时忽略 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 乘上 &lt;span class=&#34;math inline&#34;&gt;\(k=n\)&lt;/span&gt; 时的系数，统计答案时乘上 &lt;span class=&#34;math inline&#34;&gt;\(2^{n-k}\)&lt;/span&gt; 即可。&lt;/p&gt;
&lt;p&gt;不是，那我缺的哈希这块谁来补啊？？？&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int mod = 1e9 + 7;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;sirens1.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#endif
    int n, q, m;
    std::string s;
    std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; q &amp;gt;&amp;gt; s;
    s = &amp;#39;\0&amp;#39; + s, m = (int)s.length() - 1;
    std::vector&amp;lt;char&amp;gt; t(n + 1);
    std::vector&amp;lt;long long&amp;gt; base(n + 1), inv(n + 1);
    std::vector&amp;lt;std::array&amp;lt;long long, 26&amp;gt; &amp;gt; a(n + 1);
    auto qkp = [](long long x, int y) &amp;#123;
        long long res = 1ll;
        for (; y; (x *= x) %= mod, y &amp;gt;&amp;gt;= 1)
            if (y &amp;amp; 1)
                (res *= x) %= mod;
        return res;
    &amp;#125;;
    base[0] = 1ll, inv[0] = 1ll, inv[1] = qkp(2, mod - 2);
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        std::cin &amp;gt;&amp;gt; t[i];
        base[i] = base[i - 1] * 2 % mod;
        if (i != 1)
            inv[i] = inv[i - 1] * inv[1] % mod;
    &amp;#125;
    for (int i = 1; i &amp;lt;= n; ++i)
        a[i] = a[i - 1], (a[i][t[i] - &amp;#39;a&amp;#39;] += base[n - i]) %= mod;
    for (int k; q--; ) &amp;#123;
        std::string p;
        std::cin &amp;gt;&amp;gt; k &amp;gt;&amp;gt; p;
        p = &amp;#39;\0&amp;#39; + p;
        long long res = 0;
        int l = (int)p.length() - 1;
        std::vector&amp;lt;char&amp;gt; u;
        std::function&amp;lt;void(int, std::vector&amp;lt;char&amp;gt; &amp;amp;)&amp;gt; calc = [&amp;amp;](int x, std::vector&amp;lt;char&amp;gt; &amp;amp;p) &amp;#123;
            int m = (int)p.size() - 1;
            if (m == 0) &amp;#123;
                // puts(&amp;quot;# 45&amp;quot;);
                // printf(&amp;quot;0, += %lld\n&amp;quot;, base[k - x + 1]);
                (res += base[k - x + 1]) %= mod;
                return;
            &amp;#125;
            if (x &amp;gt; k)
                return;
            if (m == 1) &amp;#123;
                // puts(&amp;quot;# 50&amp;quot;);
                // printf(&amp;quot;1, += %lld(%lld)\n&amp;quot;, (a[k][p[1] - &amp;#39;a&amp;#39;] + mod - a[x - 1][p[1] - &amp;#39;a&amp;#39;]) % mod * inv[n - k] % mod, inv[n - k] % mod);
                (res += (a[k][p[1] - &amp;#39;a&amp;#39;] + mod - a[x - 1][p[1] - &amp;#39;a&amp;#39;]) % mod * inv[n - k] % mod) %= mod;
                return;
            &amp;#125;
            bool flag0 = 1, flag1 = 1;
            std::vector&amp;lt;char&amp;gt; t0(1), t1(1);
            for (int i = 1; i &amp;lt;= m; ++i)
                if (!(i &amp;amp; 1)) &amp;#123;
                    if (flag0)
                        t0.push_back(p[i]);
                    flag1 &amp;amp;= (p[i] == t[x]);
                &amp;#125;
                else &amp;#123;
                    if (flag1)
                        t1.push_back(p[i]);
                    flag0 &amp;amp;= (p[i] == t[x]);
                &amp;#125;
            if (flag0)
                calc(x + 1, t0);
            if (flag1)
                calc(x + 1, t1);
            return;
        &amp;#125;;
        for (int i = 1; i &amp;lt;= m + 1; ++i) &amp;#123;
            std::vector&amp;lt;char&amp;gt;(1).swap(u);
            for (int j = i, now = 1; now &amp;lt;= l; ++now) &amp;#123;
                if (j == m + 1)
                    j = 1, u.push_back(p[now]);
                else if (p[now] != s[j])
                    goto nosol;
                else
                    ++j;
            &amp;#125;
            // printf(&amp;quot;u: &amp;quot;);
            // for (int i = 1; i &amp;lt; (int)u.size(); ++i)
            //     std::cout &amp;lt;&amp;lt; u[i];
            // puts(&amp;quot;&amp;quot;);
            calc(1, u);
        nosol: ;
        &amp;#125;
        std::cout &amp;lt;&amp;lt; res &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    &amp;#125;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;b.-prefix-of-suffixes&#34;&gt;B. Prefix of Suffixes&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://222.180.160.110:61235/contest/5658/problem/2&#34; class=&#34;uri&#34;&gt;http://222.180.160.110:61235/contest/5658/problem/2&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;还是太科幻了。哦哦 border 我的 border。&lt;/p&gt;
&lt;h3 id=&#34;法一&#34;&gt;法一&lt;/h3&gt;
&lt;p&gt;考虑每次增量，若加入 &lt;span class=&#34;math inline&#34;&gt;\(S_i\)&lt;/span&gt; 后有 &lt;span class=&#34;math inline&#34;&gt;\(z_j\)&lt;/span&gt; 的值增加 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt;，那么这对 &lt;span class=&#34;math inline&#34;&gt;\((i, j)\)&lt;/span&gt; 就会贡献 &lt;span class=&#34;math inline&#34;&gt;\(A_j\cdot B_i\)&lt;/span&gt; 的增量；&lt;mark&gt;反之，&lt;span class=&#34;math inline&#34;&gt;\(z_j\)&lt;/span&gt; 在以后也不会增加&lt;/mark&gt;。&lt;/p&gt;
&lt;p&gt;我们维护当前没有确定下来的所有 &lt;span class=&#34;math inline&#34;&gt;\(z_j\)&lt;/span&gt;，对于每个 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 暴力 check &lt;span class=&#34;math inline&#34;&gt;\(z_j\)&lt;/span&gt; 是否确定并更新答案，&lt;strong&gt;因为数据比较弱&lt;/strong&gt;，在 CF 神机上跑得飞快 &lt;img src=&#34;/em/dy.gif&#34; /&gt; 但是 QOJ 上死活过不了 &lt;img src=&#34;/em/ll.gif&#34; /&gt;&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#endif
    int n;
    long long res = 0, s = 0;
    std::cin &amp;gt;&amp;gt; n;
    std::vector&amp;lt;int&amp;gt; now;
    std::vector&amp;lt;int&amp;gt; a(n + 1), b(n + 1), t(n + 1);
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        std::cin &amp;gt;&amp;gt; t[i] &amp;gt;&amp;gt; a[i] &amp;gt;&amp;gt; b[i];
        t[i] = (res + t[i]) % n;
        if (t[i] == t[1])
            s += b[i], now.push_back(i);
        std::vector&amp;lt;int&amp;gt; g(std::move(now));
        for (auto j : g)
            if (t[i] == t[i - j + 1])
                now.push_back(j);
            else
                s -= b[j];
        res += a[i] * s;
        std::cout &amp;lt;&amp;lt; res &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    &amp;#125;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h3 id=&#34;法二&#34;&gt;法二&lt;/h3&gt;
&lt;p&gt;依然考虑增量。&lt;mark&gt;&lt;span class=&#34;math inline&#34;&gt;\(z_j\)&lt;/span&gt; 增加 &lt;span class=&#34;math inline&#34;&gt;\(\iff S_{j\to i}\)&lt;/span&gt; 为 &lt;span class=&#34;math inline&#34;&gt;\(S_{1\sim i}\)&lt;/span&gt; 的一个 border&lt;/mark&gt;。考虑对于每一个 &lt;span class=&#34;math inline&#34;&gt;\(S_i\)&lt;/span&gt;，border 的组成。&lt;/p&gt;
&lt;ol type=&#34;1&#34;&gt;
&lt;li&gt;若 &lt;span class=&#34;math inline&#34;&gt;\(S_1=S_i\)&lt;/span&gt;，那么将会新增一个长度为 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt; 的 border。&lt;/li&gt;
&lt;li&gt;对于在 &lt;span class=&#34;math inline&#34;&gt;\(i-1\)&lt;/span&gt; 处合法的 border &lt;span class=&#34;math inline&#34;&gt;\(S_{j\sim i-1}\)&lt;/span&gt;，若 &lt;span class=&#34;math inline&#34;&gt;\(S_i=S_{i-j+1}\)&lt;/span&gt;，则该 border 仍合法；否则非法。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我们的法一其实相当于是暴力 check 了所有合法 border 是否仍然合法，但这显然最坏是 &lt;span class=&#34;math inline&#34;&gt;\(O(n^2)\)&lt;/span&gt; 的。我们考虑从 border 角度优化一下。&lt;/p&gt;
&lt;p&gt;我们发现，比如说 &lt;span class=&#34;math inline&#34;&gt;\(\texttt{abababa + b}\)&lt;/span&gt;，我们会进行很多次不必要的 check，当然这个时候我们会本能大力跳 fail，但是这里有一个 &lt;a href=&#34;https://www.luogu.com/article/e08ebmz6&#34;&gt;border 的等差数列性质&lt;/a&gt;，若 &lt;span class=&#34;math inline&#34;&gt;\(x+1\)&lt;/span&gt; 与 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 能够匹配，那么与 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 同属一个等差数列的所有 &lt;span class=&#34;math inline&#34;&gt;\(x&amp;#39;+1\)&lt;/span&gt; 都应和 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 匹配。&lt;/p&gt;
&lt;p&gt;对于正在 check 的 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt;，如果 check 成功则跳到上一条链的链尾；否则跳到链头。总的复杂度是 &lt;span class=&#34;math inline&#34;&gt;\(O(n\log n)\)&lt;/span&gt; 的。找一下和每个 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 匹配不了的第一个链头，甚至可以因为某些我太菜了所以不知道的不明原因整到线性。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#endif
    int n;
    long long res = 0, s = 0;
    std::cin &amp;gt;&amp;gt; n;
    std::vector&amp;lt;int&amp;gt; a(n + 1), b(n + 1), t(n + 1), ne(n + 1), to(n + 1);
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        std::cin &amp;gt;&amp;gt; t[i] &amp;gt;&amp;gt; a[i] &amp;gt;&amp;gt; b[i];
        t[i] = (res + t[i]) % n;
        if (i == 1)
            s += b[i], res = (long long)a[i] * b[i];
        else &amp;#123;
            int j = ne[i - 1];
            for (; j &amp;amp;&amp;amp; t[j + 1] != t[i]; j = ne[j]);
            if (t[j + 1] == t[i])
                ++j;
            ne[i] = j;
            if (t[i] == t[1])
                s += b[i];
            to[i - 1] = (t[ne[i - 1] + 1] == t[i] ? to[ne[i - 1]] : ne[i - 1]);
            for (int j = i - 1; j; )
                if (t[j + 1] == t[i])
                    j = to[j];
                else
                    for (int at = to[j]; j != at; s -= b[i - j], j = ne[j]);
            res += a[i] * s;
        &amp;#125;
        std::cout &amp;lt;&amp;lt; res &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    &amp;#125;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;c.-matching&#34;&gt;C. Matching&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://222.180.160.110:61235/contest/5658/problem/3&#34; class=&#34;uri&#34;&gt;http://222.180.160.110:61235/contest/5658/problem/3&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我们发现，如果我们直接要 check 一段 &lt;span class=&#34;math inline&#34;&gt;\(a\)&lt;/span&gt; 和 &lt;span class=&#34;math inline&#34;&gt;\(p\)&lt;/span&gt;，感觉不太好整。&lt;/p&gt;
&lt;p&gt;然后考虑这么一个问题，假如我们通过神秘方法让我们每次 check 的 &lt;span class=&#34;math inline&#34;&gt;\(a\)&lt;/span&gt;&lt;/p&gt;
</content>
        <category term="哈希" />
        <category term="线段树" />
        <category term="KMP" />
        <category term="border" />
        <updated>2024-10-21T00:32:59.000Z</updated>
    </entry>
</feed>
