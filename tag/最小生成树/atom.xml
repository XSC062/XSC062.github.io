<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://xsc062.netlify.app</id>
    <title> • Posts by &#34;最小生成树&#34; tag</title>
    <link href="https://xsc062.netlify.app" />
    <updated>2024-02-06T01:57:49.000Z</updated>
    <category term="并查集" />
    <category term="斜率优化" />
    <category term="悬线法" />
    <category term="哈希" />
    <category term="字典树" />
    <category term="DP" />
    <category term="单调队列" />
    <category term="分治" />
    <category term="二分图" />
    <category term="CRT / exCRT" />
    <category term="排列组合" />
    <category term="网络流" />
    <category term="费用流" />
    <category term="二分" />
    <category term="上下界网络流" />
    <category term="容斥原理" />
    <category term="线段树" />
    <category term="树状数组" />
    <category term="区间 DP" />
    <category term="构造" />
    <category term="Tarjan" />
    <category term="数据结构" />
    <category term="下饭" />
    <category term="LCA" />
    <category term="倍增" />
    <category term="鸽巢原理" />
    <category term="概率期望" />
    <category term="调和级数" />
    <category term="差分" />
    <category term="思维" />
    <category term="树形 DP" />
    <category term="最小生成树" />
    <category term="SAM" />
    <category term="状压" />
    <category term="分块" />
    <category term="可持久化" />
    <category term="笛卡尔树" />
    <category term="高维前缀和" />
    <category term="闲话" />
    <category term="欧拉回路" />
    <category term="树链剖分" />
    <category term="长链剖分" />
    <category term="KMP" />
    <category term="border" />
    <category term="字符串" />
    <category term="AC 自动机" />
    <category term="SA" />
    <category term="数学" />
    <category term="树上差分" />
    <category term="FWT" />
    <category term="堆" />
    <category term="树的重心" />
    <category term="二项式定理" />
    <category term="二项式反演" />
    <category term="贪心" />
    <category term="均摊" />
    <category term="计数" />
    <category term="优化建图" />
    <category term="反悔贪心" />
    <category term="调整法" />
    <category term="背包" />
    <category term="博弈论" />
    <category term="DP 优化" />
    <category term="虚树" />
    <category term="点分治" />
    <category term="WQS 二分" />
    <category term="闵可夫斯基和" />
    <category term="slope trick" />
    <category term="四边形不等式" />
    <category term="暴力" />
    <category term="状压 DP" />
    <category term="组合数学" />
    <category term="支配对" />
    <category term="DDP" />
    <category term="平衡树" />
    <category term="容斥" />
    <category term="猫树" />
    <category term="Kruskal 重构树" />
    <category term="李超线段树" />
    <entry>
        <id>https://xsc062.netlify.app/20240206/</id>
        <title>曼哈顿最小距离生成树</title>
        <link rel="alternate" href="https://xsc062.netlify.app/20240206/"/>
        <content type="html">&lt;p&gt;如题。&lt;/p&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;e.-another-minimum-spanning-tree&#34;&gt;E. Another Minimum Spanning Tree&lt;/h3&gt;
&lt;p&gt;http://222.180.160.110:61235/contest/4940/problem/5&lt;/p&gt;
&lt;p&gt;曼哈顿最小距离生成树。给定 &lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt; 个已知坐标的点，两两之间可连权值为曼哈顿距离的边，需求最小生成树。&lt;/p&gt;
&lt;p&gt;有一引理：以任意一点为顶点的大小为 &lt;span class=&#34;math inline&#34;&gt;\(\dfrac \pi8\)&lt;/span&gt; 、且一条边与坐标轴重合的角覆盖的范围中，与该点曼哈顿距离最小的点才有可能与此点连边。&lt;/p&gt;
&lt;p&gt;概括说来便是以该点为原点建系，沿坐标轴米字划分。&lt;/p&gt;
&lt;details&gt;
&lt;p&gt;&lt;summary&gt;浅证&lt;/summary&gt;&lt;/p&gt;
&lt;p&gt;首先需认识到，若 &lt;span class=&#34;math inline&#34;&gt;\(w(x,y)&amp;lt;w(x,z)\)&lt;/span&gt; 且 &lt;span class=&#34;math inline&#34;&gt;\(w(y,z)&amp;lt;w(x,z)\)&lt;/span&gt;，则边 &lt;span class=&#34;math inline&#34;&gt;\(E(x,z)\)&lt;/span&gt; 不在最小生成树中。&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&#34;1.png&#34; alt=&#34;示意图&#34; /&gt;&lt;figcaption&gt;示意图&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;考虑有如上 &lt;span class=&#34;math inline&#34;&gt;\(A,B,C\)&lt;/span&gt; 三点。不妨设 &lt;span class=&#34;math inline&#34;&gt;\(d(A,B)\le d(A,C)\)&lt;/span&gt;。其中 &lt;span class=&#34;math inline&#34;&gt;\(d\)&lt;/span&gt; 为曼哈顿距离。&lt;/p&gt;
&lt;p&gt;由图易知 &lt;span class=&#34;math inline&#34;&gt;\(x_B,y_B,x_C,y_C&amp;gt;0\)&lt;/span&gt; 且 &lt;span class=&#34;math inline&#34;&gt;\(y_B-x_B,y_C-x_C&amp;gt;0\)&lt;/span&gt;。讨论 &lt;span class=&#34;math inline&#34;&gt;\(B\)&lt;/span&gt; 与 &lt;span class=&#34;math inline&#34;&gt;\(C\)&lt;/span&gt; 位置关系。下文的 &lt;span class=&#34;math inline&#34;&gt;\(x,y\)&lt;/span&gt; 均相对 &lt;span class=&#34;math inline&#34;&gt;\(A\)&lt;/span&gt; 而言。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(x_B&amp;gt;x_C\)&lt;/span&gt; 且 &lt;span class=&#34;math inline&#34;&gt;\(y_B&amp;gt;y_c\)&lt;/span&gt;：&lt;/p&gt;
此时 &lt;span class=&#34;math inline&#34;&gt;\(d(A,B)&amp;gt;d(B,C)\)&lt;/span&gt;，与题设不符，舍去。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(x_B&amp;gt;x_C\)&lt;/span&gt; 且 &lt;span class=&#34;math inline&#34;&gt;\(y_B&amp;lt;y_C\)&lt;/span&gt;：&lt;/p&gt;
&lt;p&gt;此时 &lt;span class=&#34;math inline&#34;&gt;\(d(A,B)=x_B+y_B,d(B,C)=x_B-x_C+y_C-y_B,d(A,C)=x_C+y_C\)&lt;/span&gt;。由作差法得 &lt;span class=&#34;math inline&#34;&gt;\(d(B,C)-d(A,C)=x_B-y_B-2\times x_C\)&lt;/span&gt;，由 &lt;span class=&#34;math inline&#34;&gt;\(x_B-y_B&amp;lt;0,x_C&amp;gt;0\)&lt;/span&gt;，&lt;span class=&#34;math inline&#34;&gt;\(d(B,C)&amp;lt;d(A,C)\)&lt;/span&gt;。&lt;/p&gt;
由于 &lt;span class=&#34;math inline&#34;&gt;\(d(A,B),d(B,C)&amp;lt;d(A,C)\)&lt;/span&gt;，故 &lt;span class=&#34;math inline&#34;&gt;\(A\)&lt;/span&gt; 一定不与 &lt;span class=&#34;math inline&#34;&gt;\(C\)&lt;/span&gt; 连边。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(x_B&amp;lt;x_C\)&lt;/span&gt; 且 &lt;span class=&#34;math inline&#34;&gt;\(y_B&amp;gt;y_C\)&lt;/span&gt;：&lt;/p&gt;
与上一种情况同理。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(x_B&amp;lt;x_C\)&lt;/span&gt; 且 &lt;span class=&#34;math inline&#34;&gt;\(y_B&amp;lt;y_C\)&lt;/span&gt;：&lt;/p&gt;
此时有 &lt;span class=&#34;math inline&#34;&gt;\(d(A,C)=d(A,B)+d(B,C)\)&lt;/span&gt;，则 &lt;span class=&#34;math inline&#34;&gt;\(A\)&lt;/span&gt; 一定不与 &lt;span class=&#34;math inline&#34;&gt;\(C\)&lt;/span&gt; 连边。&lt;/li&gt;
&lt;/ul&gt;
&lt;/details&gt;
&lt;p&gt;如此一来，边数便降低到了 &lt;span class=&#34;math inline&#34;&gt;\(O(n)\)&lt;/span&gt; 水平。&lt;/p&gt;
&lt;p&gt;此外，如何识别每个点周围每 &lt;span class=&#34;math inline&#34;&gt;\(\dfrac \pi8\)&lt;/span&gt; 的最近点便是问题所在。&lt;/p&gt;
&lt;p&gt;由于坐标可以变换，此处仅考虑顶点为 &lt;span class=&#34;math inline&#34;&gt;\(A\)&lt;/span&gt;，始边沿 &lt;span class=&#34;math inline&#34;&gt;\(y\)&lt;/span&gt; 轴正方向，终边沿 &lt;span class=&#34;math inline&#34;&gt;\(k=1\)&lt;/span&gt; 的区域。则对于区域内的点 &lt;span class=&#34;math inline&#34;&gt;\(B\)&lt;/span&gt;，易知 &lt;span class=&#34;math inline&#34;&gt;\(x_B\geqslant x_A,y_B-y_A\geqslant x_B-x_A\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;后一条规则分离变量则有 &lt;span class=&#34;math inline&#34;&gt;\(y_B-x_B\geqslant y_A-x_A\)&lt;/span&gt;，那么问题转化为二维偏序，其中待求为最小 &lt;span class=&#34;math inline&#34;&gt;\(x_B+y_B\)&lt;/span&gt;，可以用树状数组离散解决。&lt;/p&gt;
&lt;p&gt;&lt;del&gt;由于边是双向的，将问题在平面任意连续 &lt;span class=&#34;math inline&#34;&gt;\(\dfrac \pi 2\)&lt;/span&gt; 范围内进行四次坐标转化即可。&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;&lt;del&gt;其实并不一定要连续，只要该区域与其旋转一百八十度后的图形的并可以覆盖整个平面即可。这么看来是不是只能连续。&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;我们会发现旋转 &lt;span class=&#34;math inline&#34;&gt;\(\dfrac \pi 8\)&lt;/span&gt; 这个我们在整数域上做不到啊。所以我们考虑旋转 + 翻折，最后整出来差不多这个图形：&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&#34;2.png&#34; alt=&#34;示意图&#34; /&gt;&lt;figcaption&gt;示意图&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;然后由于我们发现这些点关于 &lt;span class=&#34;math inline&#34;&gt;\(A\)&lt;/span&gt; 的关系（是通过 &lt;span class=&#34;math inline&#34;&gt;\(A\)&lt;/span&gt; 翻折还是旋转得来的）并不中心对称啊，所以呢就要委屈一下写满八个方向了。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;namespace XSC062 &amp;#123;
using namespace fastIO;
const int maxn = 1e5 + 5;
struct _ &amp;#123;
    int x, y, id;
    bool operator&amp;lt; (const _ &amp;amp;q) const &amp;#123;
        return y - x &amp;gt; q.y - q.x;
    &amp;#125;
&amp;#125;;
struct __ &amp;#123;
    int x, y, w;
    __() &amp;#123;&amp;#125;
    __(int x1, int y1, int w1) &amp;#123;
        if (y1 &amp;lt; x1) x1 ^= y1 ^= x1 ^= y1;
        x = x1, y = y1, w = w1;
    &amp;#125;
    bool operator&amp;lt; (const __ &amp;amp;q) const &amp;#123;
        return w == q.w ? x &amp;lt; q.x : w &amp;lt; q.w;
    &amp;#125;
&amp;#125;;
int n;
int Bit[maxn]; 
std::vector&amp;lt;__&amp;gt; e;
_ a[maxn], b[maxn];
int ls[maxn], f[maxn];
int lowbit(int x) &amp;#123; return x &amp;amp; -x; &amp;#125;
void upd(int &amp;amp;i, int j) &amp;#123;
    if (!i || (j &amp;amp;&amp;amp; b[j].x + b[j].y &amp;lt;= b[i].x + b[i].y)) i = j;
    return;
&amp;#125;
void add(int x, int i) &amp;#123;
    for (; x &amp;lt;= n; x += lowbit(x)) upd(Bit[x], i);
    return;
&amp;#125;
int ask(int x) &amp;#123;
    int res = 0;
    for (; x; x -= lowbit(x)) upd(res, Bit[x]);
    return res;
&amp;#125; 
int find(int x) &amp;#123; return x == f[x] ? x : f[x] = find(f[x]); &amp;#125;
void merge(int x, int y) &amp;#123; f[find(x)] = find(y); return; &amp;#125;
int abs(int x) &amp;#123; return x &amp;gt;= 0 ? x : -x; &amp;#125;
void adde(int x, int y) &amp;#123;
    if (!x || !y) return;
    e.emplace_back(x, y, abs(a[x].x - a[y].x) + abs(a[x].y - a[y].y));
    return;
&amp;#125;
int main() &amp;#123;
    read(n);
    while (n) &amp;#123;
        e.clear();
        for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
            read(a[i].x), read(a[i].y), a[i].id = i;
            ls[i] = a[i].x, b[i] = a[i], f[i] = i;
        &amp;#125;
        memset(Bit, 0, sizeof (Bit));
        std::sort(b + 1, b + n + 1);
        std::sort(ls + 1, ls + n + 1);
        for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
            int x = std::lower_bound(ls + 1, ls + n + 1, b[i].x) - ls;
            x = n + 1 - x, adde(b[i].id, b[ask(x)].id), add(x, i);
        &amp;#125;
        memset(Bit, 0, sizeof (Bit));
        for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
            b[i].x = a[i].y, b[i].y = a[i].x;
            ls[i] = b[i].x, b[i].id = i;
        &amp;#125;
        std::sort(b + 1, b + n + 1);
        std::sort(ls + 1, ls + n + 1);
        for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
            int x = std::lower_bound(ls + 1, ls + n + 1, b[i].x) - ls;
            assert(x &amp;gt;= 1 &amp;amp;&amp;amp; x &amp;lt;= n);
            x = n + 1 - x, adde(b[i].id, b[ask(x)].id), add(x, i);
        &amp;#125;
        memset(Bit, 0, sizeof (Bit));
        for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
            b[i].x = -a[i].x, b[i].y = a[i].y;
            ls[i] = b[i].x, b[i].id = i;
        &amp;#125;
        std::sort(b + 1, b + n + 1);
        std::sort(ls + 1, ls + n + 1);
        for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
            int x = std::lower_bound(ls + 1, ls + n + 1, b[i].x) - ls;
            assert(x &amp;gt;= 1 &amp;amp;&amp;amp; x &amp;lt;= n);
            x = n + 1 - x, adde(b[i].id, b[ask(x)].id), add(x, i);
        &amp;#125;
        memset(Bit, 0, sizeof (Bit));
        for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
            b[i].x = -a[i].y, b[i].y = a[i].x;
            ls[i] = b[i].x, b[i].id = i;
        &amp;#125;
        std::sort(b + 1, b + n + 1);
        std::sort(ls + 1, ls + n + 1);
        for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
            int x = std::lower_bound(ls + 1, ls + n + 1, b[i].x) - ls;
            assert(x &amp;gt;= 1 &amp;amp;&amp;amp; x &amp;lt;= n);
            x = n + 1 - x, adde(b[i].id, b[ask(x)].id), add(x, i);
        &amp;#125;
        memset(Bit, 0, sizeof (Bit));
        for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
            b[i].x = -a[i].y, b[i].y = -a[i].x;
            ls[i] = b[i].x, b[i].id = i;
        &amp;#125;
        std::sort(b + 1, b + n + 1);
        std::sort(ls + 1, ls + n + 1);
        for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
            int x = std::lower_bound(ls + 1, ls + n + 1, b[i].x) - ls;
            assert(x &amp;gt;= 1 &amp;amp;&amp;amp; x &amp;lt;= n);
            x = n + 1 - x, adde(b[i].id, b[ask(x)].id), add(x, i);
        &amp;#125;
        memset(Bit, 0, sizeof (Bit));
        for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
            b[i].x = -a[i].x, b[i].y = -a[i].y;
            ls[i] = b[i].x, b[i].id = i;
        &amp;#125;
        std::sort(b + 1, b + n + 1);
        std::sort(ls + 1, ls + n + 1);
        for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
            int x = std::lower_bound(ls + 1, ls + n + 1, b[i].x) - ls;
            assert(x &amp;gt;= 1 &amp;amp;&amp;amp; x &amp;lt;= n);
            x = n + 1 - x, adde(b[i].id, b[ask(x)].id), add(x, i);
        &amp;#125;
        memset(Bit, 0, sizeof (Bit));
        for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
            b[i].x = a[i].x, b[i].y = -a[i].y;
            ls[i] = b[i].x, b[i].id = i;
        &amp;#125;
        std::sort(b + 1, b + n + 1);
        std::sort(ls + 1, ls + n + 1);
        for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
            int x = std::lower_bound(ls + 1, ls + n + 1, b[i].x) - ls;
            assert(x &amp;gt;= 1 &amp;amp;&amp;amp; x &amp;lt;= n);
            x = n + 1 - x, adde(b[i].id, b[ask(x)].id), add(x, i);
        &amp;#125;
        memset(Bit, 0, sizeof (Bit));
        for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
            b[i].x = a[i].y, b[i].y = -a[i].x;
            ls[i] = b[i].x, b[i].id = i;
        &amp;#125;
        std::sort(b + 1, b + n + 1);
        std::sort(ls + 1, ls + n + 1);
        for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
            int x = std::lower_bound(ls + 1, ls + n + 1, b[i].x) - ls;
            assert(x &amp;gt;= 1 &amp;amp;&amp;amp; x &amp;lt;= n);
            x = n + 1 - x, adde(b[i].id, b[ask(x)].id), add(x, i);
        &amp;#125;
        std::sort(e.begin(), e.end());
        int res = 0;
        for (auto i : e) &amp;#123;
            if (find(i.x) != find(i.y))
                res += i.w, merge(i.x, i.y);
        &amp;#125;
        static int TimeKeeper = 0;
        printf(&amp;quot;Case %d: Total Weight = %d\n&amp;quot;, ++TimeKeeper, res);
        read(n);
    &amp;#125;
    return 0;
&amp;#125;
&amp;#125; // namespace XSC062&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
</content>
        <category term="最小生成树" />
        <updated>2024-02-06T01:57:49.000Z</updated>
    </entry>
</feed>
