{
    "version": "https://jsonfeed.org/version/1",
    "title": "null • All posts by \"最小生成树\" tag",
    "description": "",
    "home_page_url": "https://xsc062.netlify.app",
    "items": [
        {
            "id": "https://xsc062.netlify.app/20240206/",
            "url": "https://xsc062.netlify.app/20240206/",
            "title": "曼哈顿最小距离生成树",
            "date_published": "2024-02-06T01:57:49.000Z",
            "content_html": "<p>如题。</p>\n<span id=\"more\"></span>\n<hr />\n<h3 id=\"e.-another-minimum-spanning-tree\">E. Another Minimum Spanning Tree</h3>\n<p>http://222.180.160.110:61235/contest/4940/problem/5</p>\n<p>曼哈顿最小距离生成树。给定 <span class=\"math inline\">\\(n\\)</span> 个已知坐标的点，两两之间可连权值为曼哈顿距离的边，需求最小生成树。</p>\n<p>有一引理：以任意一点为顶点的大小为 <span class=\"math inline\">\\(\\dfrac \\pi8\\)</span> 、且一条边与坐标轴重合的角覆盖的范围中，与该点曼哈顿距离最小的点才有可能与此点连边。</p>\n<p>概括说来便是以该点为原点建系，沿坐标轴米字划分。</p>\n<details>\n<p><summary>浅证</summary></p>\n<p>首先需认识到，若 <span class=\"math inline\">\\(w(x,y)&lt;w(x,z)\\)</span> 且 <span class=\"math inline\">\\(w(y,z)&lt;w(x,z)\\)</span>，则边 <span class=\"math inline\">\\(E(x,z)\\)</span> 不在最小生成树中。</p>\n<figure>\n<img src=\"1.png\" alt=\"示意图\" /><figcaption>示意图</figcaption>\n</figure>\n<p>考虑有如上 <span class=\"math inline\">\\(A,B,C\\)</span> 三点。不妨设 <span class=\"math inline\">\\(d(A,B)\\le d(A,C)\\)</span>。其中 <span class=\"math inline\">\\(d\\)</span> 为曼哈顿距离。</p>\n<p>由图易知 <span class=\"math inline\">\\(x_B,y_B,x_C,y_C&gt;0\\)</span> 且 <span class=\"math inline\">\\(y_B-x_B,y_C-x_C&gt;0\\)</span>。讨论 <span class=\"math inline\">\\(B\\)</span> 与 <span class=\"math inline\">\\(C\\)</span> 位置关系。下文的 <span class=\"math inline\">\\(x,y\\)</span> 均相对 <span class=\"math inline\">\\(A\\)</span> 而言。</p>\n<ul>\n<li><p><span class=\"math inline\">\\(x_B&gt;x_C\\)</span> 且 <span class=\"math inline\">\\(y_B&gt;y_c\\)</span>：</p>\n此时 <span class=\"math inline\">\\(d(A,B)&gt;d(B,C)\\)</span>，与题设不符，舍去。</li>\n<li><p><span class=\"math inline\">\\(x_B&gt;x_C\\)</span> 且 <span class=\"math inline\">\\(y_B&lt;y_C\\)</span>：</p>\n<p>此时 <span class=\"math inline\">\\(d(A,B)=x_B+y_B,d(B,C)=x_B-x_C+y_C-y_B,d(A,C)=x_C+y_C\\)</span>。由作差法得 <span class=\"math inline\">\\(d(B,C)-d(A,C)=x_B-y_B-2\\times x_C\\)</span>，由 <span class=\"math inline\">\\(x_B-y_B&lt;0,x_C&gt;0\\)</span>，<span class=\"math inline\">\\(d(B,C)&lt;d(A,C)\\)</span>。</p>\n由于 <span class=\"math inline\">\\(d(A,B),d(B,C)&lt;d(A,C)\\)</span>，故 <span class=\"math inline\">\\(A\\)</span> 一定不与 <span class=\"math inline\">\\(C\\)</span> 连边。</li>\n<li><p><span class=\"math inline\">\\(x_B&lt;x_C\\)</span> 且 <span class=\"math inline\">\\(y_B&gt;y_C\\)</span>：</p>\n与上一种情况同理。</li>\n<li><p><span class=\"math inline\">\\(x_B&lt;x_C\\)</span> 且 <span class=\"math inline\">\\(y_B&lt;y_C\\)</span>：</p>\n此时有 <span class=\"math inline\">\\(d(A,C)=d(A,B)+d(B,C)\\)</span>，则 <span class=\"math inline\">\\(A\\)</span> 一定不与 <span class=\"math inline\">\\(C\\)</span> 连边。</li>\n</ul>\n</details>\n<p>如此一来，边数便降低到了 <span class=\"math inline\">\\(O(n)\\)</span> 水平。</p>\n<p>此外，如何识别每个点周围每 <span class=\"math inline\">\\(\\dfrac \\pi8\\)</span> 的最近点便是问题所在。</p>\n<p>由于坐标可以变换，此处仅考虑顶点为 <span class=\"math inline\">\\(A\\)</span>，始边沿 <span class=\"math inline\">\\(y\\)</span> 轴正方向，终边沿 <span class=\"math inline\">\\(k=1\\)</span> 的区域。则对于区域内的点 <span class=\"math inline\">\\(B\\)</span>，易知 <span class=\"math inline\">\\(x_B\\geqslant x_A,y_B-y_A\\geqslant x_B-x_A\\)</span>。</p>\n<p>后一条规则分离变量则有 <span class=\"math inline\">\\(y_B-x_B\\geqslant y_A-x_A\\)</span>，那么问题转化为二维偏序，其中待求为最小 <span class=\"math inline\">\\(x_B+y_B\\)</span>，可以用树状数组离散解决。</p>\n<p><del>由于边是双向的，将问题在平面任意连续 <span class=\"math inline\">\\(\\dfrac \\pi 2\\)</span> 范围内进行四次坐标转化即可。</del></p>\n<p><del>其实并不一定要连续，只要该区域与其旋转一百八十度后的图形的并可以覆盖整个平面即可。这么看来是不是只能连续。</del></p>\n<p>我们会发现旋转 <span class=\"math inline\">\\(\\dfrac \\pi 8\\)</span> 这个我们在整数域上做不到啊。所以我们考虑旋转 + 翻折，最后整出来差不多这个图形：</p>\n<figure>\n<img src=\"2.png\" alt=\"示意图\" /><figcaption>示意图</figcaption>\n</figure>\n<p>然后由于我们发现这些点关于 <span class=\"math inline\">\\(A\\)</span> 的关系（是通过 <span class=\"math inline\">\\(A\\)</span> 翻折还是旋转得来的）并不中心对称啊，所以呢就要委屈一下写满八个方向了。</p>\n<details>\n<pre class=\"cpp\"><code>namespace XSC062 &#123;\nusing namespace fastIO;\nconst int maxn = 1e5 + 5;\nstruct _ &#123;\n    int x, y, id;\n    bool operator&lt; (const _ &amp;q) const &#123;\n        return y - x &gt; q.y - q.x;\n    &#125;\n&#125;;\nstruct __ &#123;\n    int x, y, w;\n    __() &#123;&#125;\n    __(int x1, int y1, int w1) &#123;\n        if (y1 &lt; x1) x1 ^= y1 ^= x1 ^= y1;\n        x = x1, y = y1, w = w1;\n    &#125;\n    bool operator&lt; (const __ &amp;q) const &#123;\n        return w == q.w ? x &lt; q.x : w &lt; q.w;\n    &#125;\n&#125;;\nint n;\nint Bit[maxn]; \nstd::vector&lt;__&gt; e;\n_ a[maxn], b[maxn];\nint ls[maxn], f[maxn];\nint lowbit(int x) &#123; return x &amp; -x; &#125;\nvoid upd(int &amp;i, int j) &#123;\n    if (!i || (j &amp;&amp; b[j].x + b[j].y &lt;= b[i].x + b[i].y)) i = j;\n    return;\n&#125;\nvoid add(int x, int i) &#123;\n    for (; x &lt;= n; x += lowbit(x)) upd(Bit[x], i);\n    return;\n&#125;\nint ask(int x) &#123;\n    int res = 0;\n    for (; x; x -= lowbit(x)) upd(res, Bit[x]);\n    return res;\n&#125; \nint find(int x) &#123; return x == f[x] ? x : f[x] = find(f[x]); &#125;\nvoid merge(int x, int y) &#123; f[find(x)] = find(y); return; &#125;\nint abs(int x) &#123; return x &gt;= 0 ? x : -x; &#125;\nvoid adde(int x, int y) &#123;\n    if (!x || !y) return;\n    e.emplace_back(x, y, abs(a[x].x - a[y].x) + abs(a[x].y - a[y].y));\n    return;\n&#125;\nint main() &#123;\n    read(n);\n    while (n) &#123;\n        e.clear();\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            read(a[i].x), read(a[i].y), a[i].id = i;\n            ls[i] = a[i].x, b[i] = a[i], f[i] = i;\n        &#125;\n        memset(Bit, 0, sizeof (Bit));\n        std::sort(b + 1, b + n + 1);\n        std::sort(ls + 1, ls + n + 1);\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            int x = std::lower_bound(ls + 1, ls + n + 1, b[i].x) - ls;\n            x = n + 1 - x, adde(b[i].id, b[ask(x)].id), add(x, i);\n        &#125;\n        memset(Bit, 0, sizeof (Bit));\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            b[i].x = a[i].y, b[i].y = a[i].x;\n            ls[i] = b[i].x, b[i].id = i;\n        &#125;\n        std::sort(b + 1, b + n + 1);\n        std::sort(ls + 1, ls + n + 1);\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            int x = std::lower_bound(ls + 1, ls + n + 1, b[i].x) - ls;\n            assert(x &gt;= 1 &amp;&amp; x &lt;= n);\n            x = n + 1 - x, adde(b[i].id, b[ask(x)].id), add(x, i);\n        &#125;\n        memset(Bit, 0, sizeof (Bit));\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            b[i].x = -a[i].x, b[i].y = a[i].y;\n            ls[i] = b[i].x, b[i].id = i;\n        &#125;\n        std::sort(b + 1, b + n + 1);\n        std::sort(ls + 1, ls + n + 1);\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            int x = std::lower_bound(ls + 1, ls + n + 1, b[i].x) - ls;\n            assert(x &gt;= 1 &amp;&amp; x &lt;= n);\n            x = n + 1 - x, adde(b[i].id, b[ask(x)].id), add(x, i);\n        &#125;\n        memset(Bit, 0, sizeof (Bit));\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            b[i].x = -a[i].y, b[i].y = a[i].x;\n            ls[i] = b[i].x, b[i].id = i;\n        &#125;\n        std::sort(b + 1, b + n + 1);\n        std::sort(ls + 1, ls + n + 1);\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            int x = std::lower_bound(ls + 1, ls + n + 1, b[i].x) - ls;\n            assert(x &gt;= 1 &amp;&amp; x &lt;= n);\n            x = n + 1 - x, adde(b[i].id, b[ask(x)].id), add(x, i);\n        &#125;\n        memset(Bit, 0, sizeof (Bit));\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            b[i].x = -a[i].y, b[i].y = -a[i].x;\n            ls[i] = b[i].x, b[i].id = i;\n        &#125;\n        std::sort(b + 1, b + n + 1);\n        std::sort(ls + 1, ls + n + 1);\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            int x = std::lower_bound(ls + 1, ls + n + 1, b[i].x) - ls;\n            assert(x &gt;= 1 &amp;&amp; x &lt;= n);\n            x = n + 1 - x, adde(b[i].id, b[ask(x)].id), add(x, i);\n        &#125;\n        memset(Bit, 0, sizeof (Bit));\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            b[i].x = -a[i].x, b[i].y = -a[i].y;\n            ls[i] = b[i].x, b[i].id = i;\n        &#125;\n        std::sort(b + 1, b + n + 1);\n        std::sort(ls + 1, ls + n + 1);\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            int x = std::lower_bound(ls + 1, ls + n + 1, b[i].x) - ls;\n            assert(x &gt;= 1 &amp;&amp; x &lt;= n);\n            x = n + 1 - x, adde(b[i].id, b[ask(x)].id), add(x, i);\n        &#125;\n        memset(Bit, 0, sizeof (Bit));\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            b[i].x = a[i].x, b[i].y = -a[i].y;\n            ls[i] = b[i].x, b[i].id = i;\n        &#125;\n        std::sort(b + 1, b + n + 1);\n        std::sort(ls + 1, ls + n + 1);\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            int x = std::lower_bound(ls + 1, ls + n + 1, b[i].x) - ls;\n            assert(x &gt;= 1 &amp;&amp; x &lt;= n);\n            x = n + 1 - x, adde(b[i].id, b[ask(x)].id), add(x, i);\n        &#125;\n        memset(Bit, 0, sizeof (Bit));\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            b[i].x = a[i].y, b[i].y = -a[i].x;\n            ls[i] = b[i].x, b[i].id = i;\n        &#125;\n        std::sort(b + 1, b + n + 1);\n        std::sort(ls + 1, ls + n + 1);\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            int x = std::lower_bound(ls + 1, ls + n + 1, b[i].x) - ls;\n            assert(x &gt;= 1 &amp;&amp; x &lt;= n);\n            x = n + 1 - x, adde(b[i].id, b[ask(x)].id), add(x, i);\n        &#125;\n        std::sort(e.begin(), e.end());\n        int res = 0;\n        for (auto i : e) &#123;\n            if (find(i.x) != find(i.y))\n                res += i.w, merge(i.x, i.y);\n        &#125;\n        static int TimeKeeper = 0;\n        printf(&quot;Case %d: Total Weight = %d\\n&quot;, ++TimeKeeper, res);\n        read(n);\n    &#125;\n    return 0;\n&#125;\n&#125; // namespace XSC062</code></pre>\n</details>\n",
            "tags": [
                "最小生成树"
            ]
        }
    ]
}