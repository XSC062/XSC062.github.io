{
    "version": "https://jsonfeed.org/version/1",
    "title": "null • All posts by \"最小生成树\" tag",
    "description": "",
    "home_page_url": "https://xsc062.netlify.app",
    "items": [
        {
            "id": "https://xsc062.netlify.app/20251020/",
            "url": "https://xsc062.netlify.app/20251020/",
            "title": "Spanning Tree Again",
            "date_published": "2025-10-20T09:10:11.000Z",
            "content_html": "<p>mst，怎么还有 mst related</p>\n<span id=\"more\"></span>\n<hr />\n<h2 id=\"a---st-spanning-tree\">A - st-Spanning Tree</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/CF723F\" class=\"uri\">https://www.luogu.com.cn/problem/CF723F</a></p>\n<ul>\n<li>看起来形似最小度限制生成树，但没有边权导致失去了凸性，wqs 二分不再可行。</li>\n<li>这也启示我们放弃 mst 算法，重新回到连通性看待本题。即尝试在不影响连通性的前提下，让 <span class=\"math inline\">\\(s,t\\)</span> 在原图上的度数减少到对应值。</li>\n<li><p>发现 <span class=\"math inline\">\\(s,t\\)</span> 的决策会相互影响：</p>\n<p><img src=\"image.png\" /></p>\n<p>好消息是有且仅有这两种情况会干扰决策。胡乱贪心即可。</p></li>\n<li><p>考虑忽略与 <span class=\"math inline\">\\(s,t\\)</span> 有关的边跑一遍 DFS，得到若干连通块，显然它们会分为只与 <span class=\"math inline\">\\(s,t\\)</span> 中一者有关 / 与二者都有关两类。</p>\n<ul>\n<li>连通块内部：建 DFS 树即可。</li>\n<li><strong>先</strong>处理对于只与 <span class=\"math inline\">\\(s,t\\)</span> 中的一个有关的连通块：将其与对应 <span class=\"math inline\">\\(s,t\\)</span> 相连。</li>\n<li><strong>再</strong>处理对于与二者都有关的连通块：若 <span class=\"math inline\">\\((s, t)\\)</span> 不连通，则先找一个把 <span class=\"math inline\">\\(s\\)</span> 和 <span class=\"math inline\">\\(t\\)</span> 连通起来；剩下的看看哪个能连就连哪个。</li>\n<li><strong>最后</strong>看看是否存在边 <span class=\"math inline\">\\((s, t)\\)</span> 且不存在上一种情况（也就是 <span class=\"math inline\">\\(s,t\\)</span> 不连通），如果满足就连起来。</li>\n</ul></li>\n<li><p>为什么是这个连边顺序呢，发现 <span class=\"math inline\">\\((s,t)\\)</span> 会用一条边消耗两次度数，故放在最后；其他两者先解决更严格的一者。故有。</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, m;\n    std::cin &gt;&gt; n &gt;&gt; m;\n    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1), ps(n + 1), pt(n + 1);\n    for (int x, y; m--; ) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y;\n        g[x].push_back(y), g[y].push_back(x);\n    &#125;\n    int s, t, ds, dt;\n    std::cin &gt;&gt; s &gt;&gt; t &gt;&gt; ds &gt;&gt; dt;\n    std::vector&lt;int&gt; col(n + 1);\n    std::vector&lt;std::pair&lt;int, int&gt; &gt; res;\n    int now = 0;\n    std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;\n        col[x] = now;\n        for (auto i : g[x])\n            if (i == s)\n                ps[now].push_back(x);\n            else if (i == t)\n                pt[now].push_back(x);\n            else if (!col[i])\n                res.emplace_back(x, i), DFS(i);\n        return;\n    &#125;;\n    for (int i = 1; i &lt;= n; ++i)\n        if (i != s &amp;&amp; i != t &amp;&amp; !col[i])\n            ++now, DFS(i);\n    for (int i = 1; i &lt;= now; ++i)\n        if (!ps[i].empty() &amp;&amp; !pt[i].empty());\n        else if (!ps[i].empty())\n            res.emplace_back(ps[i].back(), s), --ds;\n        else\n            res.emplace_back(pt[i].back(), t), --dt;\n    if (ds &lt;= 0 || dt &lt;= 0) &#123;\n        std::cout &lt;&lt; &quot;No&quot; &lt;&lt; &#39;\\n&#39;;\n        return 0;\n    &#125;\n    bool flag = false;\n    for (int i = 1; i &lt;= now; ++i)\n        if (!ps[i].empty() &amp;&amp; !pt[i].empty()) &#123;\n            if (flag == false) &#123;\n                res.emplace_back(ps[i].back(), s), --ds;\n                res.emplace_back(pt[i].back(), t), --dt;\n                flag = true;\n            &#125;\n            else if (ds)\n                res.emplace_back(ps[i].back(), s), --ds;\n            else if (dt)\n                res.emplace_back(pt[i].back(), t), --dt;\n            else &#123;\n                std::cout &lt;&lt; &quot;No&quot; &lt;&lt; &#39;\\n&#39;;\n                return 0;\n            &#125;\n        &#125;\n    if (flag == false)\n        for (auto i : g[s])\n            if (i == t) &#123;\n                res.emplace_back(s, t);\n                --ds, --dt, flag = true;\n            &#125;\n    if (flag == false) &#123;\n        std::cout &lt;&lt; &quot;No&quot; &lt;&lt; &#39;\\n&#39;;\n        return 0;\n    &#125;\n    assert((int)res.size() == n - 1);\n    std::cout &lt;&lt; &quot;Yes&quot; &lt;&lt; &#39;\\n&#39;;\n    for (auto [u, v] : res)\n        std::cout &lt;&lt; u &lt;&lt; &#39; &#39; &lt;&lt; v &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"b---0-1-mst\">B - 0-1 MST</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/CF1242B\" class=\"uri\">https://www.luogu.com.cn/problem/CF1242B</a></p>\n<ul>\n<li>发现实际上是在问删掉这 <span class=\"math inline\">\\(m\\)</span> 条边后还剩多少个连通块。</li>\n<li><p>容易发现删的边相对来说比较少，或者说在 <span class=\"math inline\">\\(10^5\\)</span> 这个限制下很难分成很多个很大的连通块。</p>\n<p>正解利用了鸽巢原理证明这个事情：相当于把 <span class=\"math inline\">\\(m\\)</span> 次删边分配给 <span class=\"math inline\">\\(n\\)</span> 个点，那么至少存在一个点，被删掉的边不超过 <span class=\"math inline\">\\(\\left\\lfloor \\frac mn\\right\\rfloor\\)</span> 条。那么这个点带领的菊花形成了一个大小至少为 <span class=\"math inline\">\\(n-\\left\\lfloor \\frac mn\\right\\rfloor\\)</span> 的连通子图。</p></li>\n<li>剩余的 <span class=\"math inline\">\\(\\left\\lfloor \\frac mn\\right\\rfloor\\)</span> 个点，目测不是很大，事实上又是神秘不等式：<span class=\"math inline\">\\(\\left\\lfloor \\frac mn\\right\\rfloor^2&lt;n\\times \\left\\lfloor \\frac mn\\right\\rfloor=m\\)</span>。可以暴力枚举点对查看是否有边。</li>\n<li><p>对于菊花上可能的其他连边，仍然神秘不等式，<span class=\"math inline\">\\(\\left\\lfloor \\frac mn\\right\\rfloor\\times (n-\\left\\lfloor \\frac mn\\right\\rfloor)=\\left\\lfloor \\frac mn\\right\\rfloor\\times n-\\left\\lfloor \\frac mn\\right\\rfloor^2&lt;\\left\\lfloor \\frac mn\\right\\rfloor\\times n=m\\)</span>，仍然暴力枚举即可。</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, m;\n    std::cin &gt;&gt; n &gt;&gt; m;\n    std::vector&lt;int&gt; f(n + 1);\n    std::iota(f.begin() + 1, f.end(), 1);\n    std::function&lt;int(int)&gt; find = [&amp;](int x) &#123;\n        return x == f[x] ? x : f[x] = find(f[x]);\n    &#125;;\n    auto merge = [&amp;](int x, int y) &#123;\n        if (find(x) == find(y))\n            return false;\n        f[find(x)] = find(y);\n        return true;\n    &#125;;\n    std::vector&lt;int&gt; deg(n + 1, n - 1);\n    std::set&lt;std::pair&lt;int, int&gt; &gt; t;\n    for (int u, v; m--; ) &#123;\n        std::cin &gt;&gt; u &gt;&gt; v;\n        t.emplace(std::min(u, v), std::max(u, v)), --deg[u], --deg[v];\n    &#125;\n    int u = std::max_element(deg.begin() + 1, deg.end()) - deg.begin();\n    std::vector&lt;int&gt; p1, p2;\n    for (int i = 1; i &lt;= n; ++i)\n        if (i == u || !t.count(&#123; std::min(u, i), std::max(u, i) &#125;))\n            p1.push_back(i), merge(u, i);\n        else\n            p2.push_back(i);\n    int cnt = 1 + (int)p2.size();\n    for (int i = 0; i &lt; (int)p2.size(); ++i) &#123;\n        for (int j = 0; j &lt; i; ++j)\n            if (!t.count(&#123; std::min(p2[i], p2[j]), std::max(p2[i], p2[j]) &#125;))\n                cnt -= merge(p2[i], p2[j]);\n        for (int j = 0; j &lt; (int)p1.size(); ++j)\n            if (!t.count(&#123; std::min(p2[i], p1[j]), std::max(p2[i], p1[j]) &#125;))\n                cnt -= merge(p2[i], p1[j]);\n    &#125;\n    std::cout &lt;&lt; cnt - 1 &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"c---magic-matrix\">C - Magic Matrix</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/CF632F\" class=\"uri\">https://www.luogu.com.cn/problem/CF632F</a></p>\n<ul>\n<li><p>神秘不等式。若边 <span class=\"math inline\">\\(A,B,C\\)</span> 组成三元环，显然有 <span class=\"math inline\">\\(A\\le \\max(A,B,C)\\)</span>。考虑 <span class=\"math inline\">\\(B\\)</span> 参与形成的另一个三元环 <span class=\"math inline\">\\(B,D,E\\)</span>，那么显然有 <span class=\"math inline\">\\(A\\le \\max(A,C,D,E)\\)</span>，（需要注意到此时仍是一个环，很容易证明），etc.</p></li>\n<li><p>更可视化地叙述，令 <span class=\"math inline\">\\((x,y)\\)</span> 为边 <span class=\"math inline\">\\(A\\)</span> 的两端，则 <span class=\"math inline\">\\(A\\)</span> 参与构成的所有简单环，<span class=\"math inline\">\\(A\\)</span> 不大于环上边权最大值。反过来，若存在一个路径最大值小于 <span class=\"math inline\">\\(A\\)</span> 则判定失败。故 Kruskal 乱 check 一下即可，复杂度 <span class=\"math inline\">\\(O(n^2\\log n)\\)</span>。</p>\n<p>谁家好人写 <span class=\"math inline\">\\(O(n^2\\log n^2)\\)</span> 的？咋看咋不对劲，好在发现问题，保住了高中生的名头。</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;std::vector&lt;int&gt; &gt; a(n + 1, std::vector&lt;int&gt; (n + 1));\n    auto nosol = [&amp;](void) &#123;\n        std::cout &lt;&lt; &quot;NOT MAGIC\\n&quot;;\n        exit(0);\n        return;\n    &#125;;\n    for (int i = 1; i &lt;= n; ++i)\n        for (int j = 1; j &lt;= n; ++j)\n            std::cin &gt;&gt; a[i][j];\n    std::vector&lt;int&gt; l(1);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        if (a[i][i] != 0)\n            nosol();\n        for (int j = 1; j &lt; i; ++j) &#123;\n            l.push_back(a[i][j]);\n            if (a[i][j] != a[j][i])\n                nosol();\n        &#125;\n    &#125;\n    std::sort(l.begin() + 1, l.end());\n    l.erase(std::unique(l.begin() + 1, l.end()), l.end());\n    int m = (int)l.size() - 1;\n    std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; e(m + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        for (int j = 1; j &lt; i; ++j) &#123;\n            a[i][j] = std::lower_bound(l.begin() + 1, l.end(), a[i][j]) - l.begin();\n            e[a[i][j]].emplace_back(i, j);\n        &#125;\n    std::vector&lt;int&gt; f(n + 1);\n    std::iota(f.begin() + 1, f.end(), 1);\n    std::function&lt;int(int)&gt; find = [&amp;](int x) &#123;\n        return x == f[x] ? x : f[x] = find(f[x]);\n    &#125;;\n    for (int i = 1; i &lt;= m; ++i) &#123;\n        for (auto [u, v] : e[i])\n            if (find(u) == find(v))\n                nosol();\n        for (auto [u, v] : e[i])\n            if (find(u) != find(v))\n                f[find(u)] = find(v);\n    &#125;\n    std::cout &lt;&lt; &quot;MAGIC\\n&quot;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"k---jumbled-trees\">K - Jumbled Trees</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/CF1773J\" class=\"uri\">https://www.luogu.com.cn/problem/CF1773J</a></p>\n",
            "tags": [
                "最小生成树"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20251013/",
            "url": "https://xsc062.netlify.app/20251013/",
            "title": "生成树 III",
            "date_published": "2025-10-13T02:35:14.000Z",
            "content_html": "<p>mst，以及 mst related</p>\n<span id=\"more\"></span>\n<hr />\n<h2 id=\"boruvka\">Boruvka</h2>\n<ul>\n<li>用途：<span class=\"math inline\">\\(O(m\\log n)\\)</span> 求 mst。</li>\n<li><p>过程：</p>\n<ul>\n<li>考虑和 Kruskal、Prim 类似的孤立点 <span class=\"math inline\">\\(\\to\\)</span> 加边 <span class=\"math inline\">\\(\\to\\)</span> 树。</li>\n<li>每一轮算法，对于当前的每个连通块，找到其连向其它连通块的边中最小的一条，并在这一轮后加入边集（用并查集维护连通块合并）。</li>\n<li>重复执行该算法，最终找到 mst。</li>\n</ul>\n<figure>\n<img src=\"mst-1.apng\" alt=\"图源 OI Wiki\">\n<figcaption>\n图源 OI Wiki\n</figcaption>\n</figure></li>\n<li>复杂度：每一轮中，每个连通块都会被合并一次，故一轮之后现存连通块数量最坏情况下变为原来的一半。也即共执行 <span class=\"math inline\">\\(\\log n\\)</span> 轮。复杂度 <span class=\"math inline\">\\(O(m\\log n)\\)</span>。</li>\n<li><p>优势：对于<strong>特殊边权</strong>的完全图 / 稠密图，边权并不由输入直接给定，而是由顶点计算得到，此时若可以依据性质直接找到连通块的最小边，则复杂度降低至 <span class=\"math inline\">\\(O(n\\log n)\\)</span> 之类非常优秀的级别（注意并查集的 log 和 Boruvka 本身的 log 是平行的）。</p>\n<p>『依据性质找到最小的边』的一个 Bonus：见 KDT + Boruvka 做法的 <a href=\"https://www.luogu.com.cn/problem/P6362\">平面欧几里得最小生成树</a>。</p></li>\n</ul>\n<hr />\n<h2 id=\"a---jumping-around\">A - Jumping Around</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/CF1550F\" class=\"uri\">https://www.luogu.com.cn/problem/CF1550F</a></p>\n<ul>\n<li>本题就是『特殊边权完全图』的体现。定义任意两个点之间的边权为两个点相互跳需要的最小的 <span class=\"math inline\">\\(k=||x_0-x_1|-d|\\)</span>，那么只需求瓶颈路。</li>\n<li><p>做 Boruvka 即可。考虑怎么求某个连通块的最小边，预处理出每个位置（包括空位）前 / 后第一个和自己颜色不同的非空位，每次 check <span class=\"math inline\">\\(i\\pm d\\)</span>：</p>\n<ul>\n<li>若该位置存在和当前位置不同颜色的点：连边。</li>\n<li>否则，若该位置和当前位置颜色相同：转到刚刚求出的前驱、后继，选更小者连边。</li>\n<li>否则该位为空。前驱、后继则转化为上面两种情况。</li>\n</ul></li>\n<li><p>和双指针做法不同，似乎并不支持离散化，只能做到 <span class=\"math inline\">\\(O(V\\log n)\\)</span>。</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int V = 1e6;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, q, s, d;\n    std::cin &gt;&gt; n &gt;&gt; q &gt;&gt; s &gt;&gt; d;\n    std::vector&lt;int&gt; a(n + 1), tab(V + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i], tab[a[i]] = i;\n    std::vector&lt;std::pair&lt;int, int&gt; &gt; to(n + 1);\n    std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; g(n + 1);\n    std::vector&lt;int&gt; u(V + 1), pre(V + 1), nex(V + 1), mn(n + 1), f(n + 1), pos;\n    std::iota(f.begin() + 1, f.end(), 1);\n    std::function&lt;int(int)&gt; find = [&amp;](int x) &#123;\n        return x == f[x] ? x : f[x] = find(f[x]);\n    &#125;;\n    for (int tot = n; tot != 1; ) &#123;\n        pos.clear();\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            if (f[i] == i) &#123;\n                mn[i] = 0x3f3f3f3f, to[i] = &#123; 0, 0 &#125;;\n                pos.push_back(i);\n            &#125;\n            u[a[i]] = find(i);\n            if (u[a[i - 1]] == u[a[i]])\n                pre[a[i]] = pre[a[i - 1]];\n            else\n                pre[a[i]] = a[i - 1];\n        &#125;\n        for (int i = 1; i &lt;= V; ++i)\n            if (!u[i])\n                pre[i] = u[i - 1] ? i - 1 : pre[i - 1];\n        nex[a[n]] = V + 1;\n        for (int i = n - 1; i; --i)\n            if (u[a[i + 1]] == u[a[i]])\n                nex[a[i]] = nex[a[i + 1]];\n            else\n                nex[a[i]] = a[i + 1];\n        nex[V] = V + 1;\n        for (int i = V - 1; i; --i)\n            if (!u[i])\n                nex[i] = u[i + 1] ? i + 1 : nex[i + 1];\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            int x = a[i], now = 0x3f3f3f3f, pos = 0;\n            auto upd = [&amp;](int x1) &#123;\n                if (std::abs(std::abs(x - x1) - d) &lt; now)\n                    now = std::abs(std::abs(x - x1) - d), pos = x1;\n                return;\n            &#125;;\n            auto trans = [&amp;](int x1) &#123;\n                if (pre[x1])\n                    upd(pre[x1]);\n                if (nex[x1] != V + 1)\n                    upd(nex[x1]);\n                return;\n            &#125;;\n            std::function&lt;void(int)&gt; work = [&amp;](int x1) &#123;\n                if (u[x1] &amp;&amp; u[x1] != u[x])\n                    upd(x1);\n                else if (u[x1])\n                    trans(x1);\n                else &#123;\n                    if (pre[x1])\n                        work(pre[x1]);\n                    if (nex[x1] != V + 1)\n                        work(nex[x1]);\n                &#125;\n                return;\n            &#125;;\n            work(std::max(1, x - d)), work(std::min(V, x + d));\n            if (now &lt; mn[u[x]])\n                mn[u[x]] = now, to[u[x]] = &#123; i, tab[pos] &#125;;\n        &#125;\n        for (auto i : pos) &#123;\n            int j = u[a[to[i].second]], x = to[i].first, y = to[i].second;\n            if (find(i) != find(j)) &#123;\n                --tot;\n                f[find(i)] = find(j);\n                g[x].emplace_back(y, mn[i]), g[y].emplace_back(x, mn[i]);\n            &#125;\n        &#125;\n    &#125;\n    std::vector&lt;int&gt; res(n + 1);\n    std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int fa) &#123;\n        for (auto [i, w] : g[x])\n            if (i != fa) &#123;\n                res[i] = std::max(res[x], w);\n                DFS(i, x);\n            &#125;\n        return;\n    &#125;;\n    DFS(s, -1);\n    for (int x, k; q--; ) &#123;\n        std::cin &gt;&gt; x &gt;&gt; k;\n        std::cout &lt;&lt; ((res[x] &lt;= k) ? &quot;Yes&quot; : &quot;No&quot;) &lt;&lt; &#39;\\n&#39;;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"b---parametric-mst\">B - Parametric MST</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/CF1656F\" class=\"uri\">https://www.luogu.com.cn/problem/CF1656F</a></p>\n<ul>\n<li>可以猜到能够把答案写出来，但是发现太抽象了以至于不太好模拟。</li>\n<li>首先需要猜到题目给的 <span class=\"math inline\">\\(w\\)</span> 是可以继续化的，注意到 <span class=\"math inline\">\\(a_i\\cdot a_j+t(a_i+a_j)\\)</span> 可以写成 <span class=\"math inline\">\\((a_j+t)\\cdot a_i+t\\cdot a_i\\)</span> 的一次函数形式，一个很重要的思路是放弃模拟 mst 转而<strong>从点出发贪心</strong></li>\n<li><p><span class=\"math inline\">\\(t\\)</span> 会影响的是斜率 <span class=\"math inline\">\\(a_j+t\\)</span>，所以<strong>应该根据 <span class=\"math inline\">\\(a_j+t\\)</span> 的正负情况选择贪心策略</strong>。</p>\n<p>当 <span class=\"math inline\">\\(a_j+t\\le 0\\)</span> 时，使 <span class=\"math inline\">\\(a_j\\)</span> 向 <span class=\"math inline\">\\(a_{\\max}\\)</span> 连边，否则向 <span class=\"math inline\">\\(a_{\\min}\\)</span> 连边。</p>\n<p>这其实是 Boruvka 第一轮的过程；此时只剩至多两个连通块，连边方式也就讨论一下 <span class=\"math inline\">\\(a_1+t\\)</span> 和 <span class=\"math inline\">\\(a_n+t\\)</span> 的正负，然后很显然了。</p></li>\n<li><p>当 <span class=\"math inline\">\\(t\\)</span> 足够小时，所有点都会连向 <span class=\"math inline\">\\(a_{\\max}\\)</span>；反之，当 <span class=\"math inline\">\\(t\\)</span> 足够大时，所有点都会连向 <span class=\"math inline\">\\(a_{\\min}\\)</span>。</p>\n<p>对于第一种情况，mst 的权为 <span class=\"math inline\">\\(a_{\\max}\\cdot (s - a_{\\max}) + t\\cdot ((n-1)\\cdot a_{\\max}+s-a_{\\max})\\)</span>；第二种情况，mst 的权为 <span class=\"math inline\">\\(a_{\\min}\\cdot (s - a_{\\min}) + t\\cdot ((n-1)\\cdot a_{\\min}+s-a_{\\min})\\)</span>，check <span class=\"math inline\">\\(t\\)</span> 的系数即可判 <code>INF</code>。</p></li>\n<li><p>通过上面一种情况，可以注意到 <span class=\"math inline\">\\(t\\in[-a_{\\max},-a_{\\min}]\\)</span>，进一步需要猜到 <span class=\"math inline\">\\(t\\)</span> 取某个 <span class=\"math inline\">\\(-a_i\\)</span>。由于连的边是很已知的，可以发现当 <span class=\"math inline\">\\(t\\)</span> 夹在两个连续的 <span class=\"math inline\">\\(-a\\)</span> 之间时，mst 的连边情况是不变的。</p>\n<p>显然此时 mst 的权是一个关于 <span class=\"math inline\">\\(t\\)</span> 的一次函数，故 check 两端点即可。排序即可快速 check。</p>\n<p>由于此时第二轮 Boruvka 要连的边一定是 <span class=\"math inline\">\\((a_1,a_n)\\)</span>，连上即可。</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int T;\n    for (std::cin &gt;&gt; T; T--; ) &#123;\n        int n;\n        std::cin &gt;&gt; n;\n        std::vector&lt;long long&gt; a(n + 1), s(n + 1);\n        for (int i = 1; i &lt;= n; ++i)\n            std::cin &gt;&gt; a[i];\n        std::sort(a.begin() + 1, a.end());\n        std::partial_sum(a.begin() + 1, a.end(), s.begin() + 1);\n        if ((n - 1) * a[n] + s[n - 1] &lt; 0ll || (n - 1) * a[1] + s[n] - a[1] &gt; 0ll)\n            std::cout &lt;&lt; &quot;INF\\n&quot;;\n        else &#123;\n            long long res = -1e18;\n            for (int i = 1; i &lt;= n; ++i) &#123;\n                auto t = -a[i], sl = s[i] - a[1], sr = s[n - 1] - s[i];\n                res = std::max(res, a[n] * sl + a[1] * sr + t * ((i - 1) * a[n] + (n - 1 - i) * a[1] + sl + sr) + a[1] * a[n] + t * (a[1] + a[n]));\n            &#125;\n            std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n        &#125;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"c---star-mst\">C - Star MST</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/CF1657E\" class=\"uri\">https://www.luogu.com.cn/problem/CF1657E</a></p>\n<ul>\n<li>模拟 Kruskal 的过程，在边权 <span class=\"math inline\">\\(w\\)</span> 处出现 <span class=\"math inline\">\\((1,x)\\)</span>，那么允许在 <span class=\"math inline\">\\(\\ge w\\)</span> 处出现其他与 <span class=\"math inline\">\\(x\\)</span> 相关的边。</li>\n<li>会有一个比较暴力的想法，设 <span class=\"math inline\">\\(f_{i,j,l}\\)</span> 表示已经分配完边权 <span class=\"math inline\">\\(i\\)</span>，共分配了 <span class=\"math inline\">\\(j\\)</span> 条与 <span class=\"math inline\">\\(1\\)</span> 相关的边，还剩下 <span class=\"math inline\">\\(l\\)</span> 条空闲边可以放，会有一个 <span class=\"math inline\">\\(O(k\\cdot n^4)\\)</span> 的转移。</li>\n<li><p>考虑优化。容易注意到没必要存 <span class=\"math inline\">\\(l\\)</span> 而是可以当场完成分配，但这样就导致 <span class=\"math inline\">\\(i\\)</span> 维的限制转化为『恰好』，需要额外枚举一轮。总之可以得到：</p>\n<p><span class=\"math display\">\\[\nf_{i,j}=\\sum_{d_i=1}^{i}\\sum_{d_j=1}^{j} C_{n-(j-d_j)}^{d_j}\\times f_{i-d_i,j-d_j}\\times (k-i+1)^{C_{d_j}^2+d_j\\times (j-d_j)}\n\\]</span></p>\n<p>此时复杂度为 <span class=\"math inline\">\\(O(k^2n^2\\log k)\\)</span>，依然不够看；注意到交换求和顺序可以前缀和优化，故：</p>\n<p><span class=\"math display\">\\[\nf_{j, i}=\\sum_{d_j=1}^{j} C_{n-(j-d_j)}^{d_j}\\times (k-i+1)^{C_{d_j}^2+d_j\\times (j-d_j)}\\times \\sum_{d_i=1}^{i}f_{j - d_j,i-d_i}\n\\]</span></p>\n<p>复杂度 <span class=\"math inline\">\\(O(kn^2\\log k)\\)</span>。<span class=\"math inline\">\\(\\log\\)</span> 来源于快速幂。当然可以考虑预处理优化掉 log，whatever.</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 998244353;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, k;\n    std::cin &gt;&gt; n &gt;&gt; k;\n    std::vector&lt;std::vector&lt;long long&gt; &gt; C(n + 1, std::vector&lt;long long&gt; (n + 1));\n    for (int i = 0; i &lt;= n; ++i) &#123;\n        C[i][0] = 1ll;\n        for (int j = 1; j &lt;= i; ++j)\n            C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % mod;\n    &#125;\n    auto qkp = [&amp;](long long x, int y) &#123;\n        auto res = 1ll;\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    std::vector&lt;std::vector&lt;long long&gt; &gt; s(n, std::vector&lt;long long&gt; (k + 1));\n    for (int i = 0; i &lt;= k; ++i)\n        s[0][i] = 1ll;\n    for (int j = 1; j &lt; n; ++j)\n        for (int i = 1; i &lt;= k; ++i) &#123;\n            for (int dj = 1; dj &lt;= j; ++dj) \n                s[j][i] += C[n - (j - dj) - 1][dj] * qkp(k - i + 1, (C[dj][2] + dj * (j - dj)) % mod) % mod * s[j - dj][i - 1] % mod;\n            (s[j][i] += s[j][i - 1]) %= mod;\n        &#125;\n    std::cout &lt;&lt; s[n - 1][k] &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"d---smooth-sailing-hard-version\">D - Smooth Sailing (Hard Version)</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/CF1920F2\" class=\"uri\">https://www.luogu.com.cn/problem/CF1920F2</a></p>\n<ul>\n<li><p>实在十分熟悉，之前在哪道 CF 题遇到过这个 trick，然而没什么回忆线索，遂放弃</p>\n<p>一个连通块被包围的充要条件：从连通块边缘任意一个点向任意方向发一条射线，<em>垂直</em>经过路径奇数次。</p>\n<p><em>垂直</em>：即切线不切换奇偶状态。</p>\n<p>这个东西其实来源于计算几何，但是我的数学水平只停留在听说过计算几何四个字的水平，故不深究了。</p>\n<p>这种网格图上的图论问题，可以往欧拉定理（<span class=\"math inline\">\\(v-e+f=2\\)</span>），计算几何考虑，</p></li>\n<li><p>怎么在保证这一点的前提下求 mst 呢？答案是丢到状态里。</p>\n<p>找一个最靠左的点往左边引一条射线并标记沿路经过的点。令 <span class=\"math inline\">\\((x, y, 0/1)\\)</span> 表示走到 <span class=\"math inline\">\\((x, y)\\)</span>，经过关键点偶数次 / 奇数次。边权啥的也没什么好说的，点权前移即可。</p></li>\n<li><p>询问的转化反而不太好想，其实就是问 <span class=\"math inline\">\\((x,y,0)\\)</span> 到 <span class=\"math inline\">\\((x,y,1)\\)</span> 的瓶颈路。</p>\n<p>巧得有些不太自然，然而并没找到合理的解释。</p></li>\n<li><p>询问建个 Kruskal 重构树找 LCA 即可，复杂度 <span class=\"math inline\">\\(O(nm\\log nm)\\)</span>。</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int dir[][2] = &#123;&#123; -1, 0 &#125;, &#123; 1, 0 &#125;, &#123; 0, -1 &#125;, &#123; 0, 1 &#125;&#125;;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, m, q;\n    std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;\n    int cnt = 2 * n * m;\n    std::vector&lt;int&gt; W(1);\n    std::vector&lt;std::vector&lt;int&gt; &gt; g(2 * n * m + 1);\n    auto fun = [&amp;](int i, int j, int k) &#123;\n        return k * n * m + (i - 1) * m + j;\n    &#125;;\n    &#123;\n        int px = 0, py = m + 1;\n        std::vector&lt;std::vector&lt;char&gt; &gt; a(n + 1, std::vector&lt;char&gt; (m + 1));\n        for (int i = 1; i &lt;= n; ++i)\n            for (int j = 1; j &lt;= m; ++j) &#123;\n                std::cin &gt;&gt; a[i][j];\n                if (a[i][j] == &#39;#&#39; &amp;&amp; j &lt; py)\n                    px = i, py = j;\n            &#125;\n        std::vector&lt;std::vector&lt;int&gt; &gt; w(n + 1, std::vector&lt;int&gt; (m + 1, 0x3f3f3f3f));\n        &#123;\n            std::queue&lt;std::pair&lt;int, int&gt; &gt; q;\n            for (int i = 1; i &lt;= n; ++i)\n                for (int j = 1; j &lt;= m; ++j)\n                    if (a[i][j] == &#39;v&#39;)\n                        q.emplace(i, j), w[i][j] = 0;\n            for (; !q.empty(); ) &#123;\n                auto [x, y] = q.front();\n                q.pop();\n                for (auto [fx, fy] : dir) &#123;\n                    int nx = x + fx, ny = y + fy;\n                    if (nx &gt;= 1 &amp;&amp; nx &lt;= n &amp;&amp; ny &gt;= 1 &amp;&amp; ny &lt;= m &amp;&amp; w[nx][ny] == 0x3f3f3f3f) &#123;\n                        w[nx][ny] = w[x][y] + 1;\n                        q.emplace(nx, ny);\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n        struct edge &#123; int u, v, w; &#125;;\n        std::vector&lt;edge&gt; e;\n        for (int i = 1; i &lt;= n; ++i)\n            for (int j = 1; j &lt;= m; ++j)\n                if (a[i][j] != &#39;#&#39;) &#123;\n                    if (j != m &amp;&amp; a[i][j + 1] != &#39;#&#39;) &#123;\n                        e.push_back(&#123; fun(i, j, 0), fun(i, j + 1, 0), std::min(w[i][j], w[i][j + 1]) &#125;);\n                        e.push_back(&#123; fun(i, j, 1), fun(i, j + 1, 1), std::min(w[i][j], w[i][j + 1]) &#125;);\n                    &#125;\n                    if (i != n &amp;&amp; a[i + 1][j] != &#39;#&#39;) &#123;\n                        if (i + 1 == px &amp;&amp; j &lt;= py) &#123;\n                            e.push_back(&#123; fun(i, j, 0), fun(i + 1, j, 1), std::min(w[i][j], w[i + 1][j]) &#125;);\n                            e.push_back(&#123; fun(i, j, 1), fun(i + 1, j, 0), std::min(w[i][j], w[i + 1][j]) &#125;);\n                        &#125;\n                        else &#123;\n                            e.push_back(&#123; fun(i, j, 0), fun(i + 1, j, 0), std::min(w[i][j], w[i + 1][j]) &#125;);\n                            e.push_back(&#123; fun(i, j, 1), fun(i + 1, j, 1), std::min(w[i][j], w[i + 1][j]) &#125;);\n                        &#125;\n                    &#125;\n                &#125;\n        std::sort(e.begin(), e.end(), [&amp;](edge &amp;x, edge &amp;y) &#123; return x.w &gt; y.w; &#125;);\n        std::vector&lt;int&gt; f(2 * n * m + 1);\n        std::iota(f.begin() + 1, f.end(), 1);\n        std::function&lt;int(int)&gt; find = [&amp;](int x) &#123;\n            return x == f[x] ? x : f[x] = find(f[x]);\n        &#125;;\n        for (auto [x, y, w] : e)\n            if (find(x) != find(y)) &#123;\n                f.push_back(++cnt);\n                W.push_back(w), g.emplace_back();\n                g[cnt].push_back(find(x)), g[cnt].push_back(find(y));\n                f[find(x)] = f[find(y)] = cnt;\n            &#125;\n    &#125;\n    std::vector&lt;int&gt; fa(cnt + 1), siz(cnt + 1), dep(cnt + 1), son(cnt + 1), top(cnt + 1);\n    std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;\n        siz[x] = 1;\n        for (auto i : g[x]) &#123;\n            dep[i] = dep[x] + 1;\n            DFS(i), fa[i] = x;\n            siz[x] += siz[i];\n            if (siz[i] &gt; siz[son[x]])\n                son[x] = i;\n        &#125;\n        return;\n    &#125;;\n    dep[1] = 1, DFS(cnt);\n    DFS = [&amp;](int x) &#123;\n        if (son[x])\n            top[son[x]] = top[x], DFS(son[x]);\n        for (auto i : g[x])\n            if (i != son[x])\n                top[i] = i, DFS(i);\n        return;\n    &#125;;\n    top[cnt] = cnt, DFS(cnt);\n    auto ask = [&amp;](int x, int y) &#123;\n        for (; top[x] != top[y]; x = fa[top[x]])\n            if (dep[top[x]] &lt; dep[top[y]])\n                std::swap(x, y);\n        return dep[x] &lt; dep[y] ? x : y;\n    &#125;;\n    for (int x, y; q--; ) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y;\n        std::cout &lt;&lt; W[ask(fun(x, y, 0), fun(x, y, 1)) - 2 * n * m] &lt;&lt; &#39;\\n&#39;;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"e---turtle-and-intersected-segments\">E - Turtle and Intersected Segments</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/CF1981E\" class=\"uri\">https://www.luogu.com.cn/problem/CF1981E</a></p>\n<ul>\n<li><p>考虑绝对值的几何意义，很容易发现有的边注定是无效的：</p>\n<figure>\n<img src=\"image.png\" alt=\"如图中三条线段形成一个环，权值如图，排除掉权值最大的边，发现只会连权值相邻的边\" /><figcaption>如图中三条线段形成一个环，权值如图，排除掉权值最大的边，发现只会连权值相邻的边</figcaption>\n</figure></li>\n<li>换句话说，对于数轴上的这个点，仅需把覆盖之的所有<em>线段序列</em>按 <span class=\"math inline\">\\(a\\)</span> 排序，连接相邻者即可。怎么更快地实现这个过程呢？</li>\n<li><p>发现只需要在这个<em>线段序列</em>变化的时候连新的边，故用 multiset 维护这个序列，扫一遍，在加入新线段时连接它和前驱后继即可（结合前文论述发现删除的时候不用管）。</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int T;\n    for (std::cin &gt;&gt; T; T--; ) &#123;\n        int n;\n        std::cin &gt;&gt; n;\n        struct node &#123; int l, r, v; &#125;;\n        struct edge &#123; int u, v, w; &#125;;\n        std::vector&lt;edge&gt; e;\n        std::vector&lt;node&gt; a(n + 1);\n        for (int i = 1; i &lt;= n; ++i)\n            std::cin &gt;&gt; a[i].l &gt;&gt; a[i].r &gt;&gt; a[i].v;\n        std::sort(a.begin() + 1, a.end(), [&amp;](node &amp;x, node &amp;y) &#123; return x.l &lt; y.l; &#125;);\n        std::set&lt;std::tuple&lt;int, int, int&gt; &gt; t;\n        std::set&lt;std::pair&lt;int, int&gt; &gt; now;\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            for (; !t.empty();) &#123;\n                auto [r, v, id] = *t.begin();\n                if (r &gt;= a[i].l)\n                    break;\n                now.erase(std::make_pair(v, id));\n                t.erase(t.begin());\n            &#125;\n            auto p = now.lower_bound(std::make_pair(a[i].v, i));\n            if (p != now.end())\n                e.push_back(&#123; i, p-&gt;second, p-&gt;first - a[i].v &#125;);\n            if (p != now.begin()) &#123;\n                --p;\n                e.push_back(&#123; i, p-&gt;second, a[i].v - p-&gt;first &#125;);\n            &#125;\n            t.emplace(a[i].r, a[i].v, i), now.emplace(a[i].v, i);\n        &#125;\n        std::sort(e.begin(), e.end(), [&amp;](edge &amp;x, edge &amp;y) &#123; return x.w &lt; y.w; &#125;);\n        auto res = 0ll;\n        std::vector&lt;int&gt; f(n + 1);\n        std::iota(f.begin() + 1, f.end(), 1);\n        std::function&lt;int(int)&gt; find = [&amp;](int x) &#123;\n            return x == f[x] ? x : f[x] = find(f[x]);\n        &#125;;\n        int cntm = 0;\n        for (auto [u, v, w] : e)\n            if (find(u) != find(v)) &#123;\n                f[find(u)] = find(v);\n                res += w, ++cntm;\n            &#125;\n        if (cntm == n - 1)\n            std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n        else\n            std::cout &lt;&lt; -1 &lt;&lt; &#39;\\n&#39;;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"f---digital-village-extreme-version\">F - Digital Village (Extreme Version)</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/CF2021E3\" class=\"uri\">https://www.luogu.com.cn/problem/CF2021E3</a></p>\n<ul>\n<li>为啥会想到 DP（。）前面不都是神秘建图题吗（。）</li>\n<li><p>会发现待求即为重构树上 LCA 的权值，但题设中的 Key 是设置了服务器的结点，二者不匹配。如果直接设 <span class=\"math inline\">\\(f_{x,j}\\)</span> 表示 <span class=\"math inline\">\\(x\\)</span> 子树内设了 <span class=\"math inline\">\\(j\\)</span> 个服务器，感觉不太可行。</p>\n<p>当然也可能是因为我没做过重构树上的 DP。Whatever.</p></li>\n<li><p>实际上需要结合重构树的性质考虑。发现一个子树内部不能消化，当且仅当</p></li>\n</ul>\n",
            "tags": [
                "最小生成树",
                "Kruskal 重构树",
                "Boruvka"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20251004/",
            "url": "https://xsc062.netlify.app/20251004/",
            "title": "生成树 II",
            "date_published": "2025-10-04T07:07:22.000Z",
            "content_html": "<p>为什么要定义最小瓶颈路？似乎并不是很有意义</p>\n<span id=\"more\"></span>\n<hr />\n<h2 id=\"a---水筒\">A - 水筒</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/AT_joisc2014_e\" class=\"uri\">https://www.luogu.com.cn/problem/AT_joisc2014_e</a></p>\n<ul>\n<li>即求重构树，考虑 BFS 建图</li>\n<li>代码略</li>\n</ul>\n<hr />\n<h2 id=\"b---difference-of-distance\">B - Difference of Distance</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/AT_abc301_h\" class=\"uri\">https://www.luogu.com.cn/problem/AT_abc301_h</a></p>\n<ul>\n<li>有一个很奇怪的想法，就是当存在多种 Kruskal 重构树时，最大边权最小值是不会变的</li>\n<li>也就是说如果拿掉了这条边，但仍然存在另一条边权相同的边可以『代替』自己时，最大边权最小值不变</li>\n<li>否则，从另一个角度想，就可以仍然选自己，那么答案就会增加 1。</li>\n<li><p>因此，只需要对于不在生成树上的每一条边，标记环上和自己相同的边即可。</p>\n<p>树上差分 + dsu on tree 即可，注意线段树合并是线性的，如果忘了这一点就会和我一样想出虚树 + 树剖的诡异双 log 做法</p></li>\n</ul>\n",
            "tags": [
                "最小生成树"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20250929/",
            "url": "https://xsc062.netlify.app/20250929/",
            "title": "生成树练习",
            "date_published": "2025-09-29T08:55:28.000Z",
            "content_html": "<p>zyz /bx /bx /bx</p>\n<span id=\"more\"></span>\n<p><a href=\"图论杂谈%20by%20Para.pdf\">图论杂谈 by Para.pdf</a></p>\n<hr />\n<h2 id=\"最小公倍树\">最小公倍树</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P8207\" class=\"uri\">https://www.luogu.com.cn/problem/P8207</a></p>\n<ul>\n<li>会想到从数论角度优化。需要想到<strong>最小化 lcm <span class=\"math inline\">\\(\\to\\)</span> 最大化 gcd。</strong></li>\n<li><p>枚举 gcd <span class=\"math inline\">\\(u\\)</span>，那么 <span class=\"math inline\">\\(u\\)</span> 的倍数在 <span class=\"math inline\">\\([L,R]\\)</span> 中呈现为 <span class=\"math inline\">\\(k\\cdot u,(k+1)\\cdot u,(k+2)\\cdot u,\\cdots\\)</span>。<strong>虽然这些数两两之间的 gcd 并不一定为 <span class=\"math inline\">\\(u\\)</span>，但我们在枚举时『钦定』<span class=\"math inline\">\\(u\\)</span> 就是 gcd，故贪心地将所有 <span class=\"math inline\">\\(k+i\\)</span> 和 <span class=\"math inline\">\\(k\\)</span> 连边。</strong></p>\n<p>这种钦定的思想是很重要但我不太容易想到的。许多关于『最优化』的转化都会用到这种钦定的想法。</p></li>\n<li><p>优化建图后跑 Kruskal 即可。</p></li>\n</ul>\n<details>\n<p>古老代码</p>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\n#define int long long\nnamespace fastIO &#123;\nconst int LEN = (1 &lt;&lt; 20);\n#ifdef ONLINE_JUDGE\ninline int nec(void) &#123;\n    static char buf[LEN], *p = buf, *e = buf;\n    if (p == e) &#123;\n        e = buf + fread(buf, 1, LEN, stdin);\n        if (e == buf) return EOF;\n        p = buf;\n    &#125;\n    return *p++;\n&#125;\n#else\n#define nec getchar\n#endif\ninline bool read(int &amp;x) &#123;\n    x = 0;\n    bool f = 0;\n    char ch = nec();\n    while (ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123;\n        if (ch == EOF) return 0;\n        if (ch == &#39;-&#39;) f = 1;\n        ch = nec();\n    &#125;\n    while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) &#123;\n        x = x * 10 + ch - &#39;0&#39;;\n        ch = nec();\n    &#125;\n    if (f) x = -x;\n    return 1;\n&#125;\nvoid print(int x) &#123;\n    if (x &lt; 0)\n        putchar(&#39;-&#39;), x = -x;\n    if (x &gt;= 10) print(x / 10);\n    putchar(x % 10 + &#39;0&#39;);\n    return;\n&#125;\nvoid print(int x, char ch) &#123;\n    print(x), putchar(ch);\n    return;\n&#125;\n&#125; // namespace fastIO\nnamespace XSC062 &#123;\nusing namespace fastIO;\nconst int maxn = 1e6 + 5;\nstruct _ &#123;\n    int x, y, w;\n    _() &#123;&#125;\n    _(int x1, int y1, int w1) &#123;\n        x = x1, y = y1, w = w1;\n    &#125;\n    bool operator&lt; (const _ &amp;q) const &#123;\n        return w &lt; q.w;\n    &#125;\n&#125;;\nint f[maxn];\nstd::vector&lt;_&gt; e;\nint n, res, l, r;\nint find(int x) &#123; return x == f[x] ? x : f[x] = find(f[x]); &#125;\nvoid merge(int x, int y) &#123; f[find(x)] = find(y); &#125;\nint gcd(int x, int y) &#123; return y ? gcd(y, x % y) : x; &#125;\nint lcm(int x, int y) &#123; return x / gcd(x, y) * y; &#125;\nint main() &#123;\n    read(l), read(r);\n    for (int i = 1; i &lt;= r; ++i) &#123;\n        f[i] = i;\n        int x = ((l + i - 1) / i) * i;\n        for(int y = x + i; y &lt;= r; y += i)\n            e.emplace_back(x, y, lcm(x, y));\n    &#125;\n    std::sort(e.begin(), e.end());\n    for (auto i : e) &#123;\n        if (find(i.x) != find(i.y))\n            merge(i.x, i.y), res += i.w;\n    &#125;\n    print(res, &#39;\\n&#39;);\n    return 0;\n&#125;\n&#125; // namespace XSC062\n#undef int\nint main() &#123;\n    XSC062::main();\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"色\">色</h2>\n<p><a href=\"http://222.180.160.110:61235/problem/46791\" class=\"uri\">http://222.180.160.110:61235/problem/46791</a></p>\n<ul>\n<li>容易发现相当于在问最短的边，满足两端颜色不同</li>\n<li><p>进一步地，<strong>『最短边』问题应该思考边是否一定在 mst 上</strong>，就可以借助树的结构。考虑证明：</p>\n<p>若 Kruskal 时，边两端的连通块内部都是同色的，且二者不同色，则这条边是最短的异色边。</p></li>\n<li><p>问题转化为问树上最短异色边。乍一看好像和图没什么区别，困境还是『一次修改影响边数太多』，或『无法简单判定边的类型转化』。</p>\n<p>树上问题经验不足。可以<strong>分为儿子和父亲维护</strong>，儿子<strong>整体维护</strong>每个颜色的个数，对父亲<strong>暴力修改</strong>即可。</p></li>\n<li>另一种做法是，忽略 mst 性质，对图上的<strong>边序列排序后分块</strong>。</li>\n<li>询问时枚举所有块，如果该块中存在异色边，则暴力枚举块中边然后 break。</li>\n<li><p>修改则是祖传哈希，给每条边、每个颜色赋一个随机系数并<strong>强行有向化，起点为加终点为减</strong></p>\n<p><strong>记录每个块中的系数和，最后总和为 0 则块不可选。</strong></p></li>\n</ul>\n<details>\n<p>古老代码</p>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nusing ull = unsigned long long;\nconst int maxk = 555;\nconst int maxn = 2e5 + 5;\nconst int maxm = 3e5 + 5;\nstruct _ &#123; int u, v, w; &#125;;\n_ g[maxm];\nint l[maxk], r[maxk], a[maxn];\null hash[maxm], w[maxk], to[maxn], val[maxk][maxn];\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    std::cout.tie(nullptr);\n#else\n    freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, m, q;\n    std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; q &gt;&gt; q;\n    std::mt19937_64 rnd(0xabcdef);\n    for (int i = 1; i &lt;= m; ++i) &#123;\n        std::cin &gt;&gt; g[i].u &gt;&gt; g[i].v &gt;&gt; g[i].w;\n        hash[i] = rnd();\n    &#125;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; a[i];\n        for (; !to[a[i]]; to[a[i]] = rnd());\n    &#125;\n    std::sort(g + 1, g + m + 1, [](_ x, _ y) &#123; return x.w &lt; y.w; &#125;);\n    int siz = sqrt(m), k = (m + siz - 1) / siz;\n    for (int i = 1; i &lt;= k; ++i) &#123;\n        l[i] = r[i - 1] + 1, r[i] = std::min(l[i] + siz - 1, m);\n        for (int j = l[i]; j &lt;= r[i]; ++j) &#123;\n            val[i][g[j].u] += hash[j];\n            val[i][g[j].v] -= hash[j];\n            w[i] += hash[j] * (to[a[g[j].u]] - to[a[g[j].v]]);\n        &#125;\n    &#125;\n    for (int x, y; q--; ) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y;\n        for (; !to[y]; to[y] = rnd());\n        for (int i = 1; i &lt;= k; ++i)\n            w[i] += val[i][x] * (to[y] - to[a[x]]);\n        a[x] = y;\n        for (int i = 1; i &lt;= k; ++i) &#123;\n            if (w[i]) &#123;\n                for (int j = l[i]; j &lt;= r[i]; ++j)\n                    if (a[g[j].u] != a[g[j].v]) &#123;\n                        std::cout &lt;&lt; g[j].w &lt;&lt; &#39;\\n&#39;;\n                        break;\n                    &#125;\n                break;\n            &#125;\n        &#125;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"dfs-trees\">DFS Trees</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/CF1707C\" class=\"uri\">https://www.luogu.com.cn/problem/CF1707C</a></p>\n<ul>\n<li><p>一个结论：若图中边权两两不同，则图的最小生成树唯一。</p>\n<details>\n<p><summary>借鉴次小生成树的思路证明…</summary></p>\n<p>对于两个 mst <span class=\"math inline\">\\(T_1,T_2\\)</span>，假设二者边集不同但权值相同，对于其对称差 <span class=\"math inline\">\\(S\\)</span>，设 <span class=\"math inline\">\\(e\\)</span> 是其中最小的边，且 <span class=\"math inline\">\\(e\\in T_1,e\\notin T_2\\)</span>。</p>\n<p>将 <span class=\"math inline\">\\(e\\)</span> 加入 <span class=\"math inline\">\\(T_2\\)</span>，则形成的环上存在 <span class=\"math inline\">\\(e&#39;\\)</span> 使得 <span class=\"math inline\">\\(e&#39;\\in T_2,e&#39;\\notin T_1\\)</span>，那么 <span class=\"math inline\">\\(e&#39;\\in S\\)</span>。删掉 <span class=\"math inline\">\\(e&#39;\\)</span> 并加入 <span class=\"math inline\">\\(e\\)</span>，得到 <span class=\"math inline\">\\(T_2&#39;\\)</span>。</p>\n<p>由于 <span class=\"math inline\">\\(e\\)</span> 是 <span class=\"math inline\">\\(S\\)</span> 中最小边，那么 <span class=\"math inline\">\\(e&lt;e&#39;\\)</span>。也即 <span class=\"math inline\">\\(T_2&#39;&lt;T_1\\)</span>，与前提矛盾。</p>\n</details>\n<p>知道了这一点，就很好从 DFS 树的方向下手了。考虑如何什么时候 DFS 树就是 mst。</p></li>\n<li><p>对于一条非 mst 树边 <span class=\"math inline\">\\((u,v,w)\\)</span>：</p>\n<ul>\n<li>由 DFS 树的性质，<strong>若其为横叉边，必被经过。</strong></li>\n<li>由 mst 的性质，<span class=\"math inline\">\\(w\\)</span> 一定比 <span class=\"math inline\">\\(u,v\\)</span> 简单路径上的所有边边权更大，也即，当可以走这条路径时，一定不走 <span class=\"math inline\">\\(w\\)</span>。</li>\n</ul>\n<p>结合起来，<span class=\"math inline\">\\(w\\)</span> 不被经过，当且仅当 <span class=\"math inline\">\\(u,v\\)</span> 间存在祖孙关系。对应子树即为合法根。实现时还是需要倍增来找到差分范围，较为难受。</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, m;\n    std::cin &gt;&gt; n &gt;&gt; m;\n    std::vector&lt;std::pair&lt;int, int&gt; &gt; e(m + 1);\n    for (int i = 1; i &lt;= m; ++i)\n        std::cin &gt;&gt; e[i].first &gt;&gt; e[i].second;\n    std::vector&lt;int&gt; f(n + 1);\n    std::iota(f.begin() + 1, f.end(), 1);\n    std::function&lt;int(int)&gt; find = [&amp;](int x) &#123;\n        return x == f[x] ? x : f[x] = find(f[x]);\n    &#125;;\n    auto merge = [&amp;](int x, int y) &#123;\n        f[find(x)] = find(y);\n        return;\n    &#125;;\n    std::vector&lt;std::pair&lt;int, int&gt; &gt; u;\n    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);\n    for (int i = 1; i &lt;= m; ++i) &#123;\n        auto &amp;[x, y] = e[i];\n        if (find(x) != find(y)) &#123;\n            g[x].push_back(y), g[y].push_back(x);\n            merge(x, y);\n        &#125;\n        else\n            u.push_back(e[i]);\n    &#125;\n    std::vector&lt;int&gt; dep(n + 1);\n    std::vector&lt;std::array&lt;int, 19&gt; &gt; fa(n + 1);\n    std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;\n        for (auto i : g[x])\n            if (i != fa[x][0]) &#123;\n                dep[i] = dep[x] + 1;\n                fa[i][0] = x;\n                for (int j = 1; j &lt; 19; ++j)\n                    fa[i][j] = fa[fa[i][j - 1]][j - 1];\n                DFS(i);\n            &#125;\n        return;\n    &#125;;\n    dep[1] = 1, DFS(1);\n    auto ask = [&amp;](int x, int y) &#123;\n        if (dep[x] &lt; dep[y])\n            std::swap(x, y);\n        for (int i = 18; ~i; --i)\n            if (dep[fa[x][i]] &gt;= dep[y])\n                x = fa[x][i];\n        if (x == y)\n            return x;\n        for (int i = 18; ~i; --i)\n            if (fa[x][i] != fa[y][i])\n                x = fa[x][i], y = fa[y][i];\n        return fa[x][0];\n    &#125;;\n    std::vector&lt;int&gt; diff(n + 1);\n    for (auto [x, y] : u) &#123;\n        ++diff[x], ++diff[y];\n        if (dep[x] &lt; dep[y])\n            std::swap(x, y);\n        if (ask(x, y) == y) &#123;\n            for (int i = 18; ~i; --i)\n                if (dep[fa[x][i]] &gt; dep[y])\n                    x = fa[x][i];\n            --diff[x];\n        &#125;\n    &#125;\n    std::vector&lt;int&gt; res(n + 1);\n    std::function&lt;void(int, int)&gt; DFS1 = [&amp;](int x, int s) &#123;\n        s += diff[x];\n        res[x] = (s == (int)u.size());\n        for (auto i : g[x])\n            if (i != fa[x][0])\n                DFS1(i, s);\n        return;\n    &#125;;\n    DFS1(1, 0);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cout &lt;&lt; res[i];\n    std::cout &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"minimum-spanning-tree-for-each-edge\">Minimum spanning tree for each edge</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/CF609E\" class=\"uri\">https://www.luogu.com.cn/problem/CF609E</a></p>\n<p>挺没意思的题…… 略了。</p>\n<p>考虑这个题的孪生版本：</p>\n<h2 id=\"minimum-spanning-tree\">Minimum Spanning Tree</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/AT_icpc2013spring_e\" class=\"uri\">https://www.luogu.com.cn/problem/AT_icpc2013spring_e</a></p>\n<p>用非树边更新环上每条树边的最小取代边即可。类似树上差分。代码略。</p>\n<hr />\n<h2 id=\"power-tree\">Power Tree</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/CF1120D\" class=\"uri\">https://www.luogu.com.cn/problem/CF1120D</a></p>\n<ul>\n<li>容易想到把原问题转化为叶子序列上的差分。那么对于任意一个初始差分序列，我们都需要把它通过这样的差分操作变为 <span class=\"math inline\">\\(1\\sim n\\)</span> 全 0，第 <span class=\"math inline\">\\(n+1\\)</span> 位为 <span class=\"math inline\">\\(-s\\)</span>。</li>\n<li>联想到<strong>差分和连有向边的转化</strong>，那么要求连一个 <span class=\"math inline\">\\(n+1\\)</span> 为唯一汇点的树出来。显然就是原图的 mst。</li>\n<li><p>考虑怎么求出可能被 mst 包含的边。对于每一条非树边，若环上存在边权相同的边，那么这条非树边也能成为树边。</p>\n<p>考虑一个孪生问题：怎么求出一定被 mst 包含的边？</p>\n<p><a href=\"https://www.luogu.com.cn/problem/CF160D\" class=\"uri\">https://www.luogu.com.cn/problem/CF160D</a></p>\n<p>树上差分 + 线段树合并即可，注意单次线段树合并只有线性，直接做 DSU on tree 的复杂度是单 log 的。</p></li>\n<li><p>关于具体实现，可以参考 <a href=\"https://oi-wiki.org/graph/mst/#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%9A%84%E5%94%AF%E4%B8%80%E6%80%A7\">最小生成树的唯一性 - OI Wiki</a>。</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\n#define int long long\nnamespace fastIO &#123;\nconst int LEN = (1 &lt;&lt; 20);\n#ifdef ONLINE_JUDGE\ninline int nec(void) &#123;\n    static char buf[LEN], *p = buf, *e = buf;\n    if (p == e) &#123;\n        e = buf + fread(buf, 1, LEN, stdin);\n        if (e == buf) return EOF;\n        p = buf;\n    &#125;\n    return *p++;\n&#125;\n#else\n#define nec getchar\n#endif\ninline bool read(int &amp;x) &#123;\n    x = 0;\n    bool f = 0;\n    char ch = nec();\n    while (ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123;\n        if (ch == EOF) return 0;\n        if (ch == &#39;-&#39;) f = 1;\n        ch = nec();\n    &#125;\n    while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) &#123;\n        x = x * 10 + ch - &#39;0&#39;;\n        ch = nec();\n    &#125;\n    if (f) x = -x;\n    return 1;\n&#125;\nvoid print(int x) &#123;\n    if (x &lt; 0)\n        putchar(&#39;-&#39;), x = -x;\n    if (x &gt;= 10) print(x / 10);\n    putchar(x % 10 + &#39;0&#39;);\n    return;\n&#125;\nvoid print(int x, char ch) &#123;\n    print(x), putchar(ch);\n    return;\n&#125;\n&#125; // namespace fastIO\nnamespace XSC062 &#123;\nusing namespace fastIO;\nconst int maxn = 2e5 + 5;\nstruct _ &#123;\n    int x, y, i;\n    _() &#123;&#125;\n    _(int x1, int y1, int i1) &#123;\n        x = x1, y = y1, i = i1;\n    &#125;\n    bool operator&lt; (const _ &amp;q) const;\n&#125;;\n_ t[maxn];\nint a[maxn], f[maxn];\nstd::vector&lt;int&gt; res;\nint n, now, x, y, sum; \nint beg[maxn], to[maxn];\nstd::vector&lt;int&gt; g[maxn];\nbool _::operator&lt; (const _ &amp;q) const &#123;\n    return a[i] &lt; a[q.i];\n&#125;\nint find(int x) &#123; return x == f[x] ? x : f[x] = find(f[x]); &#125;\nvoid merge(int x, int y) &#123;\n    f[find(x)] = find(y);\n    return;\n&#125;\nvoid DFS(int x, int fa) &#123;\n    if (~fa &amp;&amp; (int)g[x].size() == 1)\n        beg[x] = to[x] = ++now;\n    for (auto i : g[x]) &#123;\n        if (i == fa) continue;\n        DFS(i, x);\n        if (!beg[x]) beg[x] = beg[i];\n        to[x] = to[i];\n    &#125;\n    t[x] = _(beg[x], to[x] + 1, x);\n    return;\n&#125;\nvoid add(int x, int y) &#123;\n    g[x].push_back(y);\n    return;\n&#125;\nint main() &#123;\n    read(n);\n    for (int i = 1; i &lt;= n; ++i) read(a[i]);\n    for (int i = 1; i &lt;= n + 1; ++i) f[i] = i;\n    for (int i = 1; i &lt; n; ++i) &#123;\n        read(x), read(y);\n        add(x, y), add(y, x);\n    &#125;\n    DFS(1, -1);\n    std::sort(t + 1, t + n + 1);\n    for (int l = 1, r = 0; l &lt;= n; l = r + 1) &#123;\n        while (r &lt; n &amp;&amp; a[t[r + 1].i] == a[t[l].i]) ++r;\n        for (int i = l; i &lt;= r; ++i) &#123;\n            if (find(t[i].x) != find(t[i].y))\n                res.push_back(t[i].i);\n        &#125;\n        for (int i = l; i &lt;= r; ++i) &#123;\n            if (find(t[i].x) != find(t[i].y))\n                sum += a[t[i].i], merge(t[i].x, t[i].y);\n        &#125;\n    &#125;\n    std::sort(res.begin(), res.end());\n    print(sum, &#39; &#39;), print(res.size(), &#39;\\n&#39;);\n    for (auto i : res) print(i, &#39; &#39;);\n    putchar(&#39;\\n&#39;);\n    return 0;\n&#125;\n&#125; // namespace XSC062\n#undef int\nint main() &#123;\n    XSC062::main();\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"another-minimum-spanning-tree\">Another Minimum Spanning Tree</h2>\n<p><a href=\"http://222.180.160.110:61235/problem/29212\" class=\"uri\">http://222.180.160.110:61235/problem/29212</a></p>\n<p>goto <a href=\"/20240206/\">曼哈顿最小距离生成树</a>。</p>\n<hr />\n<h2 id=\"a---design-tutorial-inverse-the-problem\">A - Design Tutorial: Inverse the Problem</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/CF472D\" class=\"uri\">https://www.luogu.com.cn/problem/CF472D</a></p>\n<ul>\n<li>发现给出的完全图的最小生成树就是原树。check 一下是否合法即可。</li>\n<li>图较稠密，需要用 Prim。</li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; g(n + 1);\n    std::vector&lt;std::vector&lt;int&gt; &gt; g0(n + 1, std::vector&lt;int&gt; (n + 1));\n    for (int i = 1; i &lt;= n; ++i)\n        for (int j = 1; j &lt;= n; ++j)\n            std::cin &gt;&gt; g0[i][j];\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        if (g0[i][i] != 0) &#123;\n            std::cout &lt;&lt; &quot;NO\\n&quot;;\n            return 0;\n        &#125;\n        for (int j = 1; j &lt; i; ++j)\n            if (g0[i][j] != g0[j][i] || !g0[i][j]) &#123;\n                std::cout &lt;&lt; &quot;NO\\n&quot;;\n                return 0;\n            &#125;\n    &#125;\n    std::vector&lt;int&gt; pos(n + 1), tag(n + 1);\n    tag[1] = 1;\n    for (int _ = 1, s = 1; _ &lt; n; ++_) &#123;\n        for (int i = 1; i &lt;= n; ++i)\n            if (!tag[i] &amp;&amp; (!pos[i] || g0[s][i] &lt; g0[pos[i]][i]))\n                pos[i] = s;\n        s = 0;\n        int t = 0;\n        for (int i = 1; i &lt;= n; ++i)\n            if (!tag[i] &amp;&amp; pos[i] &amp;&amp; (!s || g0[pos[i]][i] &lt; g0[pos[s]][s]))\n                s = i, t = pos[i];\n        tag[s] = 1;\n        g[s].emplace_back(t, g0[s][t]), g[t].emplace_back(s, g0[s][t]);\n    &#125;\n    std::vector&lt;int&gt; tab(n + 1), dis(n + 1);\n    std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int fa) &#123;\n        static int now = 0;\n        tab[++now] = x;\n        int L = now, R = now;\n        for (auto [i, w] : g[x])\n            if (i != fa) &#123;\n                dis[i] = dis[x] + w;\n                DFS(i, x);\n                for (int p = L; p &lt;= R; ++p)\n                    for (int q = R + 1; q &lt;= now; ++q) &#123;\n                        if (g0[tab[p]][tab[q]] != dis[tab[p]] + dis[tab[q]] - 2 * dis[x]) &#123;\n                            std::cout &lt;&lt; &quot;NO\\n&quot;;\n                            exit(0); // extremely ugly\n                        &#125;\n                    &#125;\n                R = now;\n            &#125;\n        return;\n    &#125;;\n    DFS(1, -1);\n    std::cout &lt;&lt; &quot;YES\\n&quot;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"b---phoenix-and-earthquake\">B - Phoenix and Earthquake</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/CF1515F\" class=\"uri\">https://www.luogu.com.cn/problem/CF1515F</a></p>\n<ul>\n<li><p>会想到，有解的充要条件是的点权之和 <span class=\"math inline\">\\(\\ge (n-1)\\cdot x\\)</span>。证明方法很广泛，但规约的思想对破题是决定性的。</p>\n<ul>\n<li><p>对于 <span class=\"math inline\">\\(u\\ge x\\)</span>，将 <span class=\"math inline\">\\(u\\)</span> 和任意相邻点合并后缩点，规约为更小规模的问题。</p></li>\n<li><p>对于 <span class=\"math inline\">\\(u&lt;x\\)</span>，一次合并使点权和减少 <span class=\"math inline\">\\(u\\)</span>，点权需求减少 <span class=\"math inline\">\\(x\\)</span>，故子问题合法则该问题合法。</p></li>\n</ul></li>\n<li><p>条件是充要的，则可以任意合并，但这样不太好做，考虑借助规约的结构，若 <span class=\"math inline\">\\(u\\ge x\\)</span> 则直接合并，否则等到其他部分合并完后再合并这一条边。这是一个栈的结构。</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, m, k;\n    std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;\n    std::vector&lt;long long&gt; a(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i];\n    if (std::accumulate(a.begin() + 1, a.end(), 0ll) &lt; (long long)k * (n - 1)) &#123;\n        std::cout &lt;&lt; &quot;NO\\n&quot;;\n        return 0;\n    &#125;\n    std::cout &lt;&lt; &quot;YES\\n&quot;;\n    std::vector&lt;int&gt; f(n + 1);\n    std::iota(f.begin() + 1, f.end(), 1);\n    std::function&lt;int(int)&gt; find = [&amp;](int x) &#123;\n        return x == f[x] ? x : f[x] = find(f[x]);\n    &#125;;\n    auto merge = [&amp;](int x, int y) &#123;\n        f[find(x)] = find(y);\n        return;\n    &#125;;\n    std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; g(n + 1);\n    for (int i = 1, x, y; m--; ++i) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y;\n        if (find(x) != find(y)) &#123;\n            g[x].emplace_back(y, i);\n            g[y].emplace_back(x, i);\n            merge(x, y);\n        &#125;\n    &#125;\n    std::vector&lt;int&gt; t;\n    std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int fa) &#123;\n        for (auto [i, id] : g[x])\n            if (i != fa) &#123;\n                DFS(i, x);\n                if (a[i] &gt;= k) &#123;\n                    a[x] += a[i] - k;\n                    std::cout &lt;&lt; id &lt;&lt; &#39;\\n&#39;;\n                &#125;\n                else\n                    t.push_back(id);\n            &#125;\n        return;\n    &#125;;\n    DFS(1, -1);\n    for (; !t.empty(); t.pop_back())\n        std::cout &lt;&lt; t.back() &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"最小度限制生成树-easy-version\">最小度限制生成树 (Easy Version)</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P5633\" class=\"uri\">https://www.luogu.com.cn/problem/P5633</a></p>\n<blockquote>\n<p>要求：两只 log。</p>\n</blockquote>\n<p>wqs 二分即可。</p>\n<hr />\n<h2 id=\"最小度限制生成树-hard-version\">最小度限制生成树 (Hard Version)</h2>\n<blockquote>\n<p>要求：一只 log。</p>\n</blockquote>\n<p>注意到涉及的边是固定的，且偏移量相同，故对于『与 <span class=\"math inline\">\\(s\\)</span> 有关的边』和『与 <span class=\"math inline\">\\(s\\)</span> 无关的边』先分别排序作为预处理，二分内部仅需归并即可。</p>\n<hr />\n<h2 id=\"最小度限制生成树-extreme-version\">最小度限制生成树 (Extreme Version)</h2>\n<blockquote>\n<p>要求：</p>\n<ul>\n<li>一只 log；</li>\n<li>对于 <span class=\"math inline\">\\(k=1,2,\\cdots,n\\)</span>，分别输出答案。</li>\n</ul>\n</blockquote>\n<p>观看 <a href=\"https://www.luogu.com.cn/article/ym8ixzr8\" class=\"uri\">https://www.luogu.com.cn/article/ym8ixzr8</a>。</p>\n",
            "tags": [
                "最小生成树"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20240206/",
            "url": "https://xsc062.netlify.app/20240206/",
            "title": "曼哈顿最小距离生成树",
            "date_published": "2024-02-06T01:57:49.000Z",
            "content_html": "<p>如题。</p>\n<span id=\"more\"></span>\n<hr />\n<h3 id=\"e.-another-minimum-spanning-tree\">E. Another Minimum Spanning Tree</h3>\n<p><a href=\"http://222.180.160.110:61235/contest/4940/problem/5\" class=\"uri\">http://222.180.160.110:61235/contest/4940/problem/5</a></p>\n<p>曼哈顿最小距离生成树。给定 <span class=\"math inline\">\\(n\\)</span> 个已知坐标的点，两两之间可连权值为曼哈顿距离的边，需求最小生成树。</p>\n<p>有一引理：以任意一点为顶点的大小为 <span class=\"math inline\">\\(\\dfrac \\pi8\\)</span> 、且一条边与坐标轴重合的角覆盖的范围中，与该点曼哈顿距离最小的点才有可能与此点连边。</p>\n<p>概括说来便是以该点为原点建系，沿坐标轴米字划分。</p>\n<details>\n<p><summary>浅证</summary></p>\n<p>首先需认识到，若 <span class=\"math inline\">\\(w(x,y)&lt;w(x,z)\\)</span> 且 <span class=\"math inline\">\\(w(y,z)&lt;w(x,z)\\)</span>，则边 <span class=\"math inline\">\\(E(x,z)\\)</span> 不在最小生成树中。</p>\n<figure>\n<img src=\"1.png\" alt=\"示意图\" /><figcaption>示意图</figcaption>\n</figure>\n<p>考虑有如上 <span class=\"math inline\">\\(A,B,C\\)</span> 三点。不妨设 <span class=\"math inline\">\\(d(A,B)\\le d(A,C)\\)</span>。其中 <span class=\"math inline\">\\(d\\)</span> 为曼哈顿距离。</p>\n<p>由图易知 <span class=\"math inline\">\\(x_B,y_B,x_C,y_C&gt;0\\)</span> 且 <span class=\"math inline\">\\(y_B-x_B,y_C-x_C&gt;0\\)</span>。讨论 <span class=\"math inline\">\\(B\\)</span> 与 <span class=\"math inline\">\\(C\\)</span> 位置关系。下文的 <span class=\"math inline\">\\(x,y\\)</span> 均相对 <span class=\"math inline\">\\(A\\)</span> 而言。</p>\n<ul>\n<li><p><span class=\"math inline\">\\(x_B&gt;x_C\\)</span> 且 <span class=\"math inline\">\\(y_B&gt;y_c\\)</span>：</p>\n此时 <span class=\"math inline\">\\(d(A,B)&gt;d(B,C)\\)</span>，与题设不符，舍去。</li>\n<li><p><span class=\"math inline\">\\(x_B&gt;x_C\\)</span> 且 <span class=\"math inline\">\\(y_B&lt;y_C\\)</span>：</p>\n<p>此时 <span class=\"math inline\">\\(d(A,B)=x_B+y_B,d(B,C)=x_B-x_C+y_C-y_B,d(A,C)=x_C+y_C\\)</span>。由作差法得 <span class=\"math inline\">\\(d(B,C)-d(A,C)=x_B-y_B-2\\times x_C\\)</span>，由 <span class=\"math inline\">\\(x_B-y_B&lt;0,x_C&gt;0\\)</span>，<span class=\"math inline\">\\(d(B,C)&lt;d(A,C)\\)</span>。</p>\n由于 <span class=\"math inline\">\\(d(A,B),d(B,C)&lt;d(A,C)\\)</span>，故 <span class=\"math inline\">\\(A\\)</span> 一定不与 <span class=\"math inline\">\\(C\\)</span> 连边。</li>\n<li><p><span class=\"math inline\">\\(x_B&lt;x_C\\)</span> 且 <span class=\"math inline\">\\(y_B&gt;y_C\\)</span>：</p>\n与上一种情况同理。</li>\n<li><p><span class=\"math inline\">\\(x_B&lt;x_C\\)</span> 且 <span class=\"math inline\">\\(y_B&lt;y_C\\)</span>：</p>\n此时有 <span class=\"math inline\">\\(d(A,C)=d(A,B)+d(B,C)\\)</span>，则 <span class=\"math inline\">\\(A\\)</span> 一定不与 <span class=\"math inline\">\\(C\\)</span> 连边。</li>\n</ul>\n</details>\n<p>如此一来，边数便降低到了 <span class=\"math inline\">\\(O(n)\\)</span> 水平。</p>\n<p>此外，如何识别每个点周围每 <span class=\"math inline\">\\(\\dfrac \\pi8\\)</span> 的最近点便是问题所在。</p>\n<p>由于坐标可以变换，此处仅考虑顶点为 <span class=\"math inline\">\\(A\\)</span>，始边沿 <span class=\"math inline\">\\(y\\)</span> 轴正方向，终边沿 <span class=\"math inline\">\\(k=1\\)</span> 的区域。则对于区域内的点 <span class=\"math inline\">\\(B\\)</span>，易知 <span class=\"math inline\">\\(x_B\\geqslant x_A,y_B-y_A\\geqslant x_B-x_A\\)</span>。</p>\n<p>后一条规则分离变量则有 <span class=\"math inline\">\\(y_B-x_B\\geqslant y_A-x_A\\)</span>，那么问题转化为二维偏序，其中待求为最小 <span class=\"math inline\">\\(x_B+y_B\\)</span>，可以用树状数组离散解决。</p>\n<p><del>由于边是双向的，将问题在平面任意连续 <span class=\"math inline\">\\(\\dfrac \\pi 2\\)</span> 范围内进行四次坐标转化即可。</del></p>\n<p><del>其实并不一定要连续，只要该区域与其旋转一百八十度后的图形的并可以覆盖整个平面即可。这么看来是不是只能连续。</del></p>\n<p>我们会发现旋转 <span class=\"math inline\">\\(\\dfrac \\pi 8\\)</span> 这个我们在整数域上做不到啊。所以我们考虑旋转 + 翻折，最后整出来差不多这个图形：</p>\n<figure>\n<img src=\"2.png\" alt=\"示意图\" /><figcaption>示意图</figcaption>\n</figure>\n<p>然后由于我们发现这些点关于 <span class=\"math inline\">\\(A\\)</span> 的关系（是通过 <span class=\"math inline\">\\(A\\)</span> 翻折还是旋转得来的）并不中心对称啊，所以呢就要委屈一下写满八个方向了。</p>\n<details>\n<pre class=\"cpp\"><code>namespace XSC062 &#123;\nusing namespace fastIO;\nconst int maxn = 1e5 + 5;\nstruct _ &#123;\n    int x, y, id;\n    bool operator&lt; (const _ &amp;q) const &#123;\n        return y - x &gt; q.y - q.x;\n    &#125;\n&#125;;\nstruct __ &#123;\n    int x, y, w;\n    __() &#123;&#125;\n    __(int x1, int y1, int w1) &#123;\n        if (y1 &lt; x1) x1 ^= y1 ^= x1 ^= y1;\n        x = x1, y = y1, w = w1;\n    &#125;\n    bool operator&lt; (const __ &amp;q) const &#123;\n        return w == q.w ? x &lt; q.x : w &lt; q.w;\n    &#125;\n&#125;;\nint n;\nint Bit[maxn]; \nstd::vector&lt;__&gt; e;\n_ a[maxn], b[maxn];\nint ls[maxn], f[maxn];\nint lowbit(int x) &#123; return x &amp; -x; &#125;\nvoid upd(int &amp;i, int j) &#123;\n    if (!i || (j &amp;&amp; b[j].x + b[j].y &lt;= b[i].x + b[i].y)) i = j;\n    return;\n&#125;\nvoid add(int x, int i) &#123;\n    for (; x &lt;= n; x += lowbit(x)) upd(Bit[x], i);\n    return;\n&#125;\nint ask(int x) &#123;\n    int res = 0;\n    for (; x; x -= lowbit(x)) upd(res, Bit[x]);\n    return res;\n&#125; \nint find(int x) &#123; return x == f[x] ? x : f[x] = find(f[x]); &#125;\nvoid merge(int x, int y) &#123; f[find(x)] = find(y); return; &#125;\nint abs(int x) &#123; return x &gt;= 0 ? x : -x; &#125;\nvoid adde(int x, int y) &#123;\n    if (!x || !y) return;\n    e.emplace_back(x, y, abs(a[x].x - a[y].x) + abs(a[x].y - a[y].y));\n    return;\n&#125;\nint main() &#123;\n    read(n);\n    while (n) &#123;\n        e.clear();\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            read(a[i].x), read(a[i].y), a[i].id = i;\n            ls[i] = a[i].x, b[i] = a[i], f[i] = i;\n        &#125;\n        memset(Bit, 0, sizeof (Bit));\n        std::sort(b + 1, b + n + 1);\n        std::sort(ls + 1, ls + n + 1);\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            int x = std::lower_bound(ls + 1, ls + n + 1, b[i].x) - ls;\n            x = n + 1 - x, adde(b[i].id, b[ask(x)].id), add(x, i);\n        &#125;\n        memset(Bit, 0, sizeof (Bit));\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            b[i].x = a[i].y, b[i].y = a[i].x;\n            ls[i] = b[i].x, b[i].id = i;\n        &#125;\n        std::sort(b + 1, b + n + 1);\n        std::sort(ls + 1, ls + n + 1);\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            int x = std::lower_bound(ls + 1, ls + n + 1, b[i].x) - ls;\n            assert(x &gt;= 1 &amp;&amp; x &lt;= n);\n            x = n + 1 - x, adde(b[i].id, b[ask(x)].id), add(x, i);\n        &#125;\n        memset(Bit, 0, sizeof (Bit));\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            b[i].x = -a[i].x, b[i].y = a[i].y;\n            ls[i] = b[i].x, b[i].id = i;\n        &#125;\n        std::sort(b + 1, b + n + 1);\n        std::sort(ls + 1, ls + n + 1);\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            int x = std::lower_bound(ls + 1, ls + n + 1, b[i].x) - ls;\n            assert(x &gt;= 1 &amp;&amp; x &lt;= n);\n            x = n + 1 - x, adde(b[i].id, b[ask(x)].id), add(x, i);\n        &#125;\n        memset(Bit, 0, sizeof (Bit));\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            b[i].x = -a[i].y, b[i].y = a[i].x;\n            ls[i] = b[i].x, b[i].id = i;\n        &#125;\n        std::sort(b + 1, b + n + 1);\n        std::sort(ls + 1, ls + n + 1);\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            int x = std::lower_bound(ls + 1, ls + n + 1, b[i].x) - ls;\n            assert(x &gt;= 1 &amp;&amp; x &lt;= n);\n            x = n + 1 - x, adde(b[i].id, b[ask(x)].id), add(x, i);\n        &#125;\n        memset(Bit, 0, sizeof (Bit));\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            b[i].x = -a[i].y, b[i].y = -a[i].x;\n            ls[i] = b[i].x, b[i].id = i;\n        &#125;\n        std::sort(b + 1, b + n + 1);\n        std::sort(ls + 1, ls + n + 1);\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            int x = std::lower_bound(ls + 1, ls + n + 1, b[i].x) - ls;\n            assert(x &gt;= 1 &amp;&amp; x &lt;= n);\n            x = n + 1 - x, adde(b[i].id, b[ask(x)].id), add(x, i);\n        &#125;\n        memset(Bit, 0, sizeof (Bit));\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            b[i].x = -a[i].x, b[i].y = -a[i].y;\n            ls[i] = b[i].x, b[i].id = i;\n        &#125;\n        std::sort(b + 1, b + n + 1);\n        std::sort(ls + 1, ls + n + 1);\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            int x = std::lower_bound(ls + 1, ls + n + 1, b[i].x) - ls;\n            assert(x &gt;= 1 &amp;&amp; x &lt;= n);\n            x = n + 1 - x, adde(b[i].id, b[ask(x)].id), add(x, i);\n        &#125;\n        memset(Bit, 0, sizeof (Bit));\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            b[i].x = a[i].x, b[i].y = -a[i].y;\n            ls[i] = b[i].x, b[i].id = i;\n        &#125;\n        std::sort(b + 1, b + n + 1);\n        std::sort(ls + 1, ls + n + 1);\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            int x = std::lower_bound(ls + 1, ls + n + 1, b[i].x) - ls;\n            assert(x &gt;= 1 &amp;&amp; x &lt;= n);\n            x = n + 1 - x, adde(b[i].id, b[ask(x)].id), add(x, i);\n        &#125;\n        memset(Bit, 0, sizeof (Bit));\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            b[i].x = a[i].y, b[i].y = -a[i].x;\n            ls[i] = b[i].x, b[i].id = i;\n        &#125;\n        std::sort(b + 1, b + n + 1);\n        std::sort(ls + 1, ls + n + 1);\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            int x = std::lower_bound(ls + 1, ls + n + 1, b[i].x) - ls;\n            assert(x &gt;= 1 &amp;&amp; x &lt;= n);\n            x = n + 1 - x, adde(b[i].id, b[ask(x)].id), add(x, i);\n        &#125;\n        std::sort(e.begin(), e.end());\n        int res = 0;\n        for (auto i : e) &#123;\n            if (find(i.x) != find(i.y))\n                res += i.w, merge(i.x, i.y);\n        &#125;\n        static int TimeKeeper = 0;\n        printf(&quot;Case %d: Total Weight = %d\\n&quot;, ++TimeKeeper, res);\n        read(n);\n    &#125;\n    return 0;\n&#125;\n&#125; // namespace XSC062</code></pre>\n</details>\n",
            "tags": [
                "最小生成树"
            ]
        }
    ]
}