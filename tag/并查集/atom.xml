<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://xsc062.netlify.app</id>
    <title> • Posts by &#34;并查集&#34; tag</title>
    <link href="https://xsc062.netlify.app" />
    <updated>2022-08-07T23:56:40.000Z</updated>
    <category term="并查集" />
    <category term="斜率优化" />
    <category term="悬线法" />
    <category term="哈希" />
    <category term="字典树" />
    <category term="DP" />
    <category term="单调队列" />
    <category term="分治" />
    <category term="计数" />
    <category term="二分图" />
    <category term="CRT / exCRT" />
    <category term="排列组合" />
    <category term="网络流" />
    <category term="费用流" />
    <category term="二分" />
    <category term="上下界网络流" />
    <category term="容斥原理" />
    <category term="线段树" />
    <category term="树状数组" />
    <category term="区间 DP" />
    <category term="构造" />
    <category term="数据结构" />
    <category term="Tarjan" />
    <category term="下饭" />
    <category term="LCA" />
    <category term="倍增" />
    <category term="鸽巢原理" />
    <category term="概率期望" />
    <category term="调和级数" />
    <category term="差分" />
    <category term="思维" />
    <category term="树形 DP" />
    <category term="最小生成树" />
    <category term="SAM" />
    <category term="状压" />
    <category term="分块" />
    <category term="可持久化" />
    <category term="笛卡尔树" />
    <category term="高维前缀和" />
    <category term="闲话" />
    <category term="欧拉回路" />
    <category term="树链剖分" />
    <category term="长链剖分" />
    <category term="KMP" />
    <category term="border" />
    <category term="字符串" />
    <category term="AC 自动机" />
    <category term="SA" />
    <category term="数学" />
    <category term="树上差分" />
    <category term="FWT" />
    <category term="堆" />
    <category term="树的重心" />
    <category term="二项式定理" />
    <category term="二项式反演" />
    <category term="贪心" />
    <category term="均摊" />
    <category term="优化建图" />
    <category term="反悔贪心" />
    <category term="调整法" />
    <category term="背包" />
    <category term="博弈论" />
    <category term="DP 优化" />
    <category term="虚树" />
    <category term="点分治" />
    <category term="WQS 二分" />
    <category term="闵可夫斯基和" />
    <category term="slope trick" />
    <category term="四边形不等式" />
    <category term="状压 DP" />
    <category term="组合数学" />
    <category term="支配对" />
    <category term="DDP" />
    <category term="容斥" />
    <category term="Kruskal 重构树" />
    <category term="高精度" />
    <category term="最短路" />
    <category term="树套树" />
    <category term="Boruvka" />
    <category term="树链剖分 - 最小生成树" />
    <category term="李超线段树" />
    <entry>
        <id>https://xsc062.netlify.app/20220808/</id>
        <title>解题报告 One-Dimensional Battle Ships</title>
        <link rel="alternate" href="https://xsc062.netlify.app/20220808/"/>
        <content type="html">&lt;p&gt;老题解批量补档。&lt;/p&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/CF567D&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/CF567D&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;因为「某一时刻是否一定被击中过」具有单调性，考虑先提前发射所有炮弹，倒序枚举炮弹，不断「撤销」当前最后一发炮弹的发射，如果在「撤销」这发炮弹后，存在任意一种放下 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 艘完整的战舰的方案，说明在发射这一发炮弹之后绝对能够击中。&lt;/p&gt;
&lt;p&gt;如果发射所有炮弹后，依然存在一种放下 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 艘完整的战舰的方案，则无解。&lt;/p&gt;
&lt;p&gt;具体实现可以使用并查集维护连通块大小，每「撤销」一发炮弹的发射相当于合并三个连通块：炮弹的落点、落点的前一个元素（若不存在或已被炮弹摧毁则忽略）、落点的后一个元素（若不存在或已被炮弹摧毁则忽略）。&lt;/p&gt;
&lt;p&gt;设某连通块大小为 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt;，可容纳战舰数为 &lt;span class=&#34;math inline&#34;&gt;\(res\)&lt;/span&gt;，显然有 &lt;span class=&#34;math inline&#34;&gt;\(res = \lfloor (x + 1) \div (p + 1) \rfloor\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;记统计当前可容纳战舰的数量为 &lt;span class=&#34;math inline&#34;&gt;\(ans\)&lt;/span&gt;，在并查集合并时，&lt;span class=&#34;math inline&#34;&gt;\(ans\)&lt;/span&gt; 分别减去两个待合并连通块的可容纳战舰的数量，再加上新连通块可容纳战舰的数量。最靠后的 &lt;span class=&#34;math inline&#34;&gt;\(ans\ge k\)&lt;/span&gt; 的时刻即为所求。&lt;/p&gt;
&lt;p&gt;同时使用路径压缩和按秩合并，时空复杂度均为 &lt;span class=&#34;math inline&#34;&gt;\(\mathcal O(n)\)&lt;/span&gt;。优于 multiset 解法。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;namespace XSC062 &amp;#123;
using namespace fastIO;
const int maxn = 2e5 + 15;
bool vis[maxn];
int n, k, p, m, x, ans;
int a[maxn], f[maxn], siz[maxn];
inline void swap(int &amp;amp;x, int &amp;amp;y)&amp;#123;
    x ^= y ^= x ^= y;
    return 0;
&amp;#125;
inline int calc(int x) &amp;#123;
    return (x + 1) / (p + 1);
&amp;#125;
inline void Init(int n) &amp;#123;
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        f[i] = i;
        siz[i] = 1;
    &amp;#125;
    return;
&amp;#125;
int find(int x) &amp;#123;
    return x == f[x] ? x : f[x] = find(f[x]);
&amp;#125;
inline void merge(int x, int y) &amp;#123;
    int fx = find(x);
    int fy = find(y);
    if (fx == fy)
        return;
    ans -= calc(siz[fx]);
    ans -= calc(siz[fy]);
    if (siz[fy] &amp;gt; siz[fx])
        swap(fx, fy);
    ans += calc(siz[fy]);
    f[fx] = fy;
    return;
&amp;#125;
int main() &amp;#123;
    read(n);
    read(k);
    read(p);
    read(m);
    Init(n + 5);
    ans = (n - m) * (2 / (p + 1));
    for (int i = 1; i &amp;lt;= m; ++i) &amp;#123;
        read(a[i]);
        vis[a[i]] = 1;
    &amp;#125;
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        if (vis[i] || vis[i - 1])
            continue;
        merge(i, i - 1);
    &amp;#125; 
    if (ans &amp;gt;= k) &amp;#123;
        puts(&amp;quot;-1&amp;quot;);
        return 0;
    &amp;#125;
    for (int i = m; i; --i) &amp;#123;
        vis[a[i]] = 0;
        ans += 2 / (p + 1);
        if (a[i] - 1 &amp;amp;&amp;amp; !vis[a[i] - 1])
            merge(a[i], a[i] - 1);
        if (a[i] + 1 &amp;lt;= n &amp;amp;&amp;amp; !vis[a[i] + 1])
            merge(a[i], a[i] + 1);
        if (ans &amp;gt;= k) &amp;#123;
            printf(&amp;quot;%d&amp;quot;, i);
            return 0;
        &amp;#125;
    &amp;#125;
    puts(&amp;quot;-1&amp;quot;);
    return 0;
&amp;#125;
&amp;#125; // namespace XSC062
int main() &amp;#123;
    XSC062::main();
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
</content>
        <category term="并查集" />
        <updated>2022-08-07T23:56:40.000Z</updated>
    </entry>
</feed>
