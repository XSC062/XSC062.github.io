<?xml version="1.0"?>
<rss version="2.0">
    <channel>
        <title> • Posts by &#34;并查集&#34; tag</title>
        <link>https://xsc062.netlify.app</link>
        <description></description>
        <language>zh-CN</language>
        <pubDate>Mon, 08 Aug 2022 07:56:40 +0800</pubDate>
        <lastBuildDate>Mon, 08 Aug 2022 07:56:40 +0800</lastBuildDate>
        <category>并查集</category>
        <category>斜率优化</category>
        <category>悬线法</category>
        <category>哈希</category>
        <category>字典树</category>
        <category>DP</category>
        <category>单调队列</category>
        <category>分治</category>
        <category>二分图</category>
        <category>CRT / exCRT</category>
        <category>排列组合</category>
        <category>网络流</category>
        <category>费用流</category>
        <category>二分</category>
        <category>上下界网络流</category>
        <category>容斥原理</category>
        <category>线段树</category>
        <category>树状数组</category>
        <category>区间 DP</category>
        <category>构造</category>
        <category>Tarjan</category>
        <category>数据结构</category>
        <category>下饭</category>
        <category>LCA</category>
        <category>倍增</category>
        <category>鸽巢原理</category>
        <category>概率期望</category>
        <category>调和级数</category>
        <category>差分</category>
        <category>思维</category>
        <category>树形 DP</category>
        <category>最小生成树</category>
        <category>SAM</category>
        <category>状压</category>
        <category>分块</category>
        <category>可持久化</category>
        <category>笛卡尔树</category>
        <category>高维前缀和</category>
        <category>闲话</category>
        <category>欧拉回路</category>
        <category>树链剖分</category>
        <category>长链剖分</category>
        <category>KMP</category>
        <category>border</category>
        <category>字符串</category>
        <category>AC 自动机</category>
        <category>SA</category>
        <category>数学</category>
        <category>树上差分</category>
        <category>FWT</category>
        <category>堆</category>
        <category>树的重心</category>
        <category>二项式定理</category>
        <category>二项式反演</category>
        <category>贪心</category>
        <category>均摊</category>
        <category>计数</category>
        <category>优化建图</category>
        <category>反悔贪心</category>
        <category>调整法</category>
        <category>背包</category>
        <category>博弈论</category>
        <category>DP 优化</category>
        <category>虚树</category>
        <category>点分治</category>
        <category>WQS 二分</category>
        <category>闵可夫斯基和</category>
        <category>slope trick</category>
        <category>四边形不等式</category>
        <category>暴力</category>
        <category>状压 DP</category>
        <category>组合数学</category>
        <category>支配对</category>
        <category>DDP</category>
        <category>平衡树</category>
        <category>容斥</category>
        <category>猫树</category>
        <category>Kruskal 重构树</category>
        <category>李超线段树</category>
        <item>
            <guid isPermalink="true">https://xsc062.netlify.app/20220808/</guid>
            <title>解题报告 One-Dimensional Battle Ships</title>
            <link>https://xsc062.netlify.app/20220808/</link>
            <category>并查集</category>
            <pubDate>Mon, 08 Aug 2022 07:56:40 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;老题解批量补档。&lt;/p&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/CF567D&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/CF567D&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;因为「某一时刻是否一定被击中过」具有单调性，考虑先提前发射所有炮弹，倒序枚举炮弹，不断「撤销」当前最后一发炮弹的发射，如果在「撤销」这发炮弹后，存在任意一种放下 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 艘完整的战舰的方案，说明在发射这一发炮弹之后绝对能够击中。&lt;/p&gt;
&lt;p&gt;如果发射所有炮弹后，依然存在一种放下 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 艘完整的战舰的方案，则无解。&lt;/p&gt;
&lt;p&gt;具体实现可以使用并查集维护连通块大小，每「撤销」一发炮弹的发射相当于合并三个连通块：炮弹的落点、落点的前一个元素（若不存在或已被炮弹摧毁则忽略）、落点的后一个元素（若不存在或已被炮弹摧毁则忽略）。&lt;/p&gt;
&lt;p&gt;设某连通块大小为 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt;，可容纳战舰数为 &lt;span class=&#34;math inline&#34;&gt;\(res\)&lt;/span&gt;，显然有 &lt;span class=&#34;math inline&#34;&gt;\(res = \lfloor (x + 1) \div (p + 1) \rfloor\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;记统计当前可容纳战舰的数量为 &lt;span class=&#34;math inline&#34;&gt;\(ans\)&lt;/span&gt;，在并查集合并时，&lt;span class=&#34;math inline&#34;&gt;\(ans\)&lt;/span&gt; 分别减去两个待合并连通块的可容纳战舰的数量，再加上新连通块可容纳战舰的数量。最靠后的 &lt;span class=&#34;math inline&#34;&gt;\(ans\ge k\)&lt;/span&gt; 的时刻即为所求。&lt;/p&gt;
&lt;p&gt;同时使用路径压缩和按秩合并，时空复杂度均为 &lt;span class=&#34;math inline&#34;&gt;\(\mathcal O(n)\)&lt;/span&gt;。优于 multiset 解法。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;namespace XSC062 &amp;#123;
using namespace fastIO;
const int maxn = 2e5 + 15;
bool vis[maxn];
int n, k, p, m, x, ans;
int a[maxn], f[maxn], siz[maxn];
inline void swap(int &amp;amp;x, int &amp;amp;y)&amp;#123;
    x ^= y ^= x ^= y;
    return 0;
&amp;#125;
inline int calc(int x) &amp;#123;
    return (x + 1) / (p + 1);
&amp;#125;
inline void Init(int n) &amp;#123;
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        f[i] = i;
        siz[i] = 1;
    &amp;#125;
    return;
&amp;#125;
int find(int x) &amp;#123;
    return x == f[x] ? x : f[x] = find(f[x]);
&amp;#125;
inline void merge(int x, int y) &amp;#123;
    int fx = find(x);
    int fy = find(y);
    if (fx == fy)
        return;
    ans -= calc(siz[fx]);
    ans -= calc(siz[fy]);
    if (siz[fy] &amp;gt; siz[fx])
        swap(fx, fy);
    ans += calc(siz[fy]);
    f[fx] = fy;
    return;
&amp;#125;
int main() &amp;#123;
    read(n);
    read(k);
    read(p);
    read(m);
    Init(n + 5);
    ans = (n - m) * (2 / (p + 1));
    for (int i = 1; i &amp;lt;= m; ++i) &amp;#123;
        read(a[i]);
        vis[a[i]] = 1;
    &amp;#125;
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        if (vis[i] || vis[i - 1])
            continue;
        merge(i, i - 1);
    &amp;#125; 
    if (ans &amp;gt;= k) &amp;#123;
        puts(&amp;quot;-1&amp;quot;);
        return 0;
    &amp;#125;
    for (int i = m; i; --i) &amp;#123;
        vis[a[i]] = 0;
        ans += 2 / (p + 1);
        if (a[i] - 1 &amp;amp;&amp;amp; !vis[a[i] - 1])
            merge(a[i], a[i] - 1);
        if (a[i] + 1 &amp;lt;= n &amp;amp;&amp;amp; !vis[a[i] + 1])
            merge(a[i], a[i] + 1);
        if (ans &amp;gt;= k) &amp;#123;
            printf(&amp;quot;%d&amp;quot;, i);
            return 0;
        &amp;#125;
    &amp;#125;
    puts(&amp;quot;-1&amp;quot;);
    return 0;
&amp;#125;
&amp;#125; // namespace XSC062
int main() &amp;#123;
    XSC062::main();
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
 ]]></description>
        </item>
    </channel>
</rss>
