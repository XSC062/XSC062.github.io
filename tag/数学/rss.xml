<?xml version="1.0"?>
<rss version="2.0">
    <channel>
        <title> • Posts by &#34;数学&#34; tag</title>
        <link>https://xsc062.netlify.app</link>
        <description></description>
        <language>zh-CN</language>
        <pubDate>Sat, 19 Apr 2025 10:03:57 +0800</pubDate>
        <lastBuildDate>Sat, 19 Apr 2025 10:03:57 +0800</lastBuildDate>
        <category>悬线法</category>
        <category>斜率优化</category>
        <category>并查集</category>
        <category>哈希</category>
        <category>DP</category>
        <category>单调队列</category>
        <category>字典树</category>
        <category>二分图</category>
        <category>分治</category>
        <category>计数</category>
        <category>容斥</category>
        <category>CRT / exCRT</category>
        <category>排列组合</category>
        <category>网络流</category>
        <category>二分</category>
        <category>容斥原理</category>
        <category>线段树</category>
        <category>树状数组</category>
        <category>区间 DP</category>
        <category>数据结构</category>
        <category>构造</category>
        <category>Tarjan</category>
        <category>下饭</category>
        <category>李超线段树</category>
        <category>树链剖分</category>
        <category>LCA</category>
        <category>倍增</category>
        <category>鸽巢原理</category>
        <category>数学</category>
        <category>调和级数</category>
        <category>差分</category>
        <category>思维</category>
        <category>树形 DP</category>
        <category>最小生成树</category>
        <category>SAM</category>
        <category>状压</category>
        <category>分块</category>
        <category>可持久化</category>
        <category>笛卡尔树</category>
        <category>高维前缀和</category>
        <category>闲话</category>
        <category>欧拉回路</category>
        <category>长链剖分</category>
        <category>KMP</category>
        <category>border</category>
        <category>随机化</category>
        <category>字符串</category>
        <category>AC 自动机</category>
        <category>SA</category>
        <category>树上差分</category>
        <category>FWT</category>
        <category>堆</category>
        <category>树的重心</category>
        <category>贪心</category>
        <category>均摊</category>
        <category>反悔贪心</category>
        <category>优化建图</category>
        <category>调整法</category>
        <category>博弈论</category>
        <category>DP 优化</category>
        <category>虚树</category>
        <category>点分治</category>
        <category>四边形不等式</category>
        <category>背包</category>
        <category>支配对</category>
        <category>DDP</category>
        <category>CDQ 分治</category>
        <category>猫树</category>
        <category>DP 套 DP</category>
        <category>Kruskal 重构树</category>
        <category>高精度</category>
        <category>最短路</category>
        <category>树套树</category>
        <category>二项式反演</category>
        <category>搜索</category>
        <item>
            <guid isPermalink="true">https://xsc062.netlify.app/20250419/</guid>
            <title>杂题选谈：网格图路径计数</title>
            <link>https://xsc062.netlify.app/20250419/</link>
            <category>排列组合</category>
            <category>容斥原理</category>
            <category>数学</category>
            <pubDate>Sat, 19 Apr 2025 10:03:57 +0800</pubDate>
            <description><![CDATA[ &lt;figure&gt;
&lt;img src=&#34;/20250419/neko.jpeg&#34; alt=&#34;猫&#34; style=&#34;width: 75px&#34;&gt;
&lt;figcaption&gt;
猫
&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;点到点的方案数&#34;&gt;点到点的方案数&lt;/h2&gt;
&lt;p&gt;从 &lt;span class=&#34;math inline&#34;&gt;\((x_1,y_1)\)&lt;/span&gt; 只能向右、向下走到 &lt;span class=&#34;math inline&#34;&gt;\((x_2,y_2)\)&lt;/span&gt; 的方案数：&lt;span class=&#34;math inline&#34;&gt;\(C_{x_2-x_1+y_2-y_1}^{x_2-x_1}\)&lt;/span&gt;。就是说，因为必须向下走 &lt;span class=&#34;math inline&#34;&gt;\(x_2-x_1\)&lt;/span&gt; 步，又必须向右走 &lt;span class=&#34;math inline&#34;&gt;\(y_2-y_1\)&lt;/span&gt; 步；但顺序是可以任意打乱的。&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;a---gerald-and-giant-chess&#34;&gt;A - Gerald and Giant Chess&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://codeforces.com/problemset/problem/560/E&#34; class=&#34;uri&#34;&gt;https://codeforces.com/problemset/problem/560/E&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;把不能走的点按 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 为第一关键字，&lt;span class=&#34;math inline&#34;&gt;\(y\)&lt;/span&gt; 为第二关键字排序，就可以得到它们按大致拓扑序排列的结果。&lt;/p&gt;
&lt;p&gt;令 &lt;span class=&#34;math inline&#34;&gt;\(f_i\)&lt;/span&gt; 表示不经过 &lt;span class=&#34;math inline&#34;&gt;\(1\sim i-1\)&lt;/span&gt; 的非法点走到第 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 个非法点的方案数，就可以得到 &lt;span class=&#34;math inline&#34;&gt;\(f_i=C_{x_i+y_i,x_i}-\sum_{j=1}^{i-1} f_j\times C_{x_i-x_j+y_i-y_j}^{x_i-x_j}\)&lt;/span&gt;。可以发现后面减去的方案，因为碰到的第一个非法点不同，所以是两两不同的。&lt;/p&gt;
&lt;p&gt;让 &lt;span class=&#34;math inline&#34;&gt;\((h,w)\)&lt;/span&gt; 成为第 &lt;span class=&#34;math inline&#34;&gt;\((n+1)\)&lt;/span&gt; 个非法点，&lt;span class=&#34;math inline&#34;&gt;\(f_{n+1}\)&lt;/span&gt; 就是答案。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int mod = 1e9 + 7;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#endif
    int h, w, n;
    std::cin &amp;gt;&amp;gt; h &amp;gt;&amp;gt; w &amp;gt;&amp;gt; n, --h, --w;
    std::vector&amp;lt;std::pair&amp;lt;int, int&amp;gt; &amp;gt; a(n + 2);
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        std::cin &amp;gt;&amp;gt; a[i].first &amp;gt;&amp;gt; a[i].second;
        --a[i].first, --a[i].second;
    &amp;#125;
    a[n + 1] = &amp;#123; h, w &amp;#125;;
    std::sort(a.begin() + 1, a.end());
    std::vector&amp;lt;long long&amp;gt; fac(h + w + 1), inv(h + w + 1);
    fac[0] = inv[0] = 1ll;
    for (int i = 1; i &amp;lt;= h + w; ++i)
        fac[i] = fac[i - 1] * i % mod;
    auto qkp = [](long long x, int y) &amp;#123;
        auto res = 1ll;
        for (; y; (x *= x) %= mod, y &amp;gt;&amp;gt;= 1)
            if (y &amp;amp; 1)
                (res *= x) %= mod;
        return res;
    &amp;#125;;
    inv[h + w] = qkp(fac[h + w], mod - 2);
    for (int i = h + w - 1; i; --i)
        inv[i] = inv[i + 1] * (i + 1) % mod;
    auto C = [&amp;amp;](int n, int m) &amp;#123;
        return fac[n] * inv[n - m] % mod * inv[m] % mod;
    &amp;#125;;
    std::vector&amp;lt;long long&amp;gt; f(n + 2);
    for (int i = 1; i &amp;lt;= n + 1; ++i) &amp;#123;
        f[i] = C(a[i].first + a[i].second, a[i].first);
        for (int j = 1; j &amp;lt; i; ++j)
            if (a[j].second &amp;lt;= a[i].second)
                (f[i] += mod - f[j] * C(a[i].first - a[j].first + a[i].second - a[j].second, a[i].first - a[j].first) % mod) %= mod;
        // printf(&amp;quot;f[(%d, %d)] = %lld\n&amp;quot;, a[i].first, a[i].second, f[i]);
    &amp;#125;
    std::cout &amp;lt;&amp;lt; f[n + 1] &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;b---bbq-hard&#34;&gt;B - BBQ Hard&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/agc001/tasks/agc001_e&#34; class=&#34;uri&#34;&gt;https://atcoder.jp/contests/agc001/tasks/agc001_e&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;不仅仅可以在关键点上 DP，也可以在网格上直接 DP。&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(A_i+B_i+A_j+B_j\)&lt;/span&gt; 就是 &lt;span class=&#34;math inline&#34;&gt;\(A_i+B_i-(-A_j)-(-B_j)\)&lt;/span&gt;。把棋盘扩大到 &lt;span class=&#34;math inline&#34;&gt;\(-2000\to 2000\)&lt;/span&gt; 就可以了。&lt;/p&gt;
&lt;p&gt;设 &lt;span class=&#34;math inline&#34;&gt;\(f_{i,j}\)&lt;/span&gt; 表示可以到达 &lt;span class=&#34;math inline&#34;&gt;\((i,j)\)&lt;/span&gt; 的所有发出关键点 &lt;span class=&#34;math inline&#34;&gt;\((-A_j,-B_j)\)&lt;/span&gt; 带来的贡献，那么 &lt;span class=&#34;math inline&#34;&gt;\(f_{i,j}=f_{i-1,j}+f_{i,j-1}\)&lt;/span&gt;。枚举所有接收关键点 &lt;span class=&#34;math inline&#34;&gt;\((A_i,B_i)\)&lt;/span&gt;，&lt;span class=&#34;math inline&#34;&gt;\(\sum f_{A_i,B_i}\)&lt;/span&gt; 就是答案的两倍，再减去对角线，也就是 &lt;span class=&#34;math inline&#34;&gt;\(\sum (-A_i,B_i)\to (A_i,B_i)\)&lt;/span&gt; 后的值。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int N = 2000;
const int mod = 1e9 + 7;
const int inv2 = 500000004;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#endif
    int n;
    std::cin &amp;gt;&amp;gt; n;
    std::vector&amp;lt;long long&amp;gt; fac(4 * N + 1), inv(4 * N + 1);
    fac[0] = inv[0] = 1ll;
    for (int i = 1; i &amp;lt;= 4 * N; ++i)
        fac[i] = fac[i - 1] * i % mod;
    auto qkp = [](long long x, int y) &amp;#123;
        auto res(1ll);
        for (; y; (x *= x) %= mod, y &amp;gt;&amp;gt;= 1)
            if (y &amp;amp; 1)
                (res *= x) %= mod;
        return res;
    &amp;#125;;
    inv[4 * N] = qkp(fac[4 * N], mod - 2);
    for (int i = 4 * N - 1; i; --i)
        inv[i] = inv[i + 1] * (i + 1) % mod;
    std::vector&amp;lt;std::pair&amp;lt;int, int&amp;gt; &amp;gt; a(n + 1);
    std::vector&amp;lt;std::vector&amp;lt;long long&amp;gt; &amp;gt; f(2 * N + 1, std::vector&amp;lt;long long&amp;gt; (2 * N + 1));
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        std::cin &amp;gt;&amp;gt; a[i].first &amp;gt;&amp;gt; a[i].second;
        ++f[N - a[i].first][N - a[i].second];
    &amp;#125;
    for (int i = 0; i &amp;lt;= 2 * N; ++i)
        for (int j = 0; j &amp;lt;= 2 * N; ++j) &amp;#123;
            if (i &amp;gt;= 1)
                (f[i][j] += f[i - 1][j]) %= mod;
            if (j &amp;gt;= 1)
                (f[i][j] += f[i][j - 1]) %= mod;
            // printf(&amp;quot;f(%2d, %2d) = %lld\n&amp;quot;, i - N, j - N, f[i][j]);
        &amp;#125;
    long long res = 0ll;
    auto C = [&amp;amp;](int n, int m) &amp;#123;
        return fac[n] * inv[n - m] % mod * inv[m] % mod;
    &amp;#125;;
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        (res += f[a[i].first + N][a[i].second + N]) %= mod;
        (res += mod - C(a[i].first * 2 + a[i].second * 2, 2 * a[i].first)) %= mod;
    &amp;#125;
    std::cout &amp;lt;&amp;lt; res * inv2 % mod &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;c---iroha-and-a-grid&#34;&gt;C - Iroha and a Grid&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/arc058/tasks/arc058_b&#34; class=&#34;uri&#34;&gt;https://atcoder.jp/contests/arc058/tasks/arc058_b&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;先把绿色部分的答案计算出来：&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&#34;1.png&#34; alt=&#34;网格&#34; /&gt;&lt;figcaption&gt;网格&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;如果把绿色的每一个格子到终点的方案数求和，就会算重，因为上面的绿色点可以走到下面的绿色点。&lt;/p&gt;
&lt;p&gt;让绿色点第一步只能往右走到黄色点，用这样的方案为黄色点赋初值，再让黄色点自由走就可以得到答案了。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int mod = 1e9 + 7;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#endif
    int h, w, a, b;
    std::cin &amp;gt;&amp;gt; h &amp;gt;&amp;gt; w &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b;
    std::vector&amp;lt;long long&amp;gt; fac(h + w + 1), inv(h + w + 1);
    fac[0] = inv[0] = 1ll;
    for (int i = 1; i &amp;lt;= h + w; ++i)
        fac[i] = fac[i - 1] * i % mod;
    auto qkp = [](long long x, int y) &amp;#123;
        auto res(1ll);
        for (; y; (x *= x) %= mod, y &amp;gt;&amp;gt;= 1)
            if (y &amp;amp; 1)
                (res *= x) %= mod;
        return res;
    &amp;#125;;
    inv[h + w] = qkp(fac[h + w], mod - 2);
    for (int i = h + w - 1; i; --i)
        inv[i] = inv[i + 1] * (i + 1) % mod;
    auto C = [&amp;amp;](int n, int m) &amp;#123;
        return fac[n] * inv[n - m] % mod * inv[m] % mod;
    &amp;#125;;
    auto res = 0ll;
    for (int i = 1; i &amp;lt;= h - a; ++i) &amp;#123;
        // (i, B)
        auto f(C(i + b - 2, i - 1));
        // printf(&amp;quot;(%d, %d): %lld\n&amp;quot;, i, b, f);
        // (i, B + 1)
        (res += f * C(h - i + w - (b + 1), h - i) % mod) %= mod;
    &amp;#125;
    std::cout &amp;lt;&amp;lt; res &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;点到矩形的方案数&#34;&gt;点到矩形的方案数&lt;/h2&gt;
&lt;p&gt;从 &lt;span class=&#34;math inline&#34;&gt;\((x_0,y_0)\)&lt;/span&gt; 走到矩形 &lt;span class=&#34;math inline&#34;&gt;\((x_1,y_1,x_2,y_2)\)&lt;/span&gt; 的方案数：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
\sum\limits_{i\in [x_1,x_2],j\in [y_1,y_2]} G(x_0,y_0, i, j) = G(x_0,y_0,x_2 + 1,y_2 + 1)-G(x_0,y_0,x_2+1,y_1)-G(x_0,y_0,x_1,y_2+1)+G(x_0,y_0,x_1,y_1)
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;证明：&lt;span class=&#34;math inline&#34;&gt;\(G(x_0,y_0,x_2+1,y_2+1)=\sum\limits_i G(x_0,y_0,i,y_2)=\sum\limits_{i,j} G(x_0,y_0,i,j)\)&lt;/span&gt;，类似的，把后面几项展开，可以得到前缀和的结构。&lt;/p&gt;
&lt;p&gt;现在，矩形就可以被概括成 4 个点了。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;矩形到矩形的方案数&#34;&gt;矩形到矩形的方案数&lt;/h2&gt;
&lt;p&gt;枚举第一个矩形里的所有点，那么就可以得到关于第二个矩形里四个点的表达式。反过来把第一个矩形概括为 4 个点就可以快速求解了。&lt;/p&gt;
&lt;p&gt;具体一点，第一个矩形 &lt;span class=&#34;math inline&#34;&gt;\((x_1,y_1,x_2,y_2)\)&lt;/span&gt; 可以被概括为 &lt;span class=&#34;math inline&#34;&gt;\((x_1-1,y_1-1)\)&lt;/span&gt;，&lt;span class=&#34;math inline&#34;&gt;\((x_1-1,y_2)\)&lt;/span&gt;，&lt;span class=&#34;math inline&#34;&gt;\((x_2,y_1-1)\)&lt;/span&gt;，&lt;span class=&#34;math inline&#34;&gt;\((x_2,y_2)\)&lt;/span&gt;。注意方向颠倒导致符号发生变化。此时对 &lt;span class=&#34;math inline&#34;&gt;\(4\times 4=16\)&lt;/span&gt; 个 &lt;span class=&#34;math inline&#34;&gt;\(G\)&lt;/span&gt; 按对应的 &lt;span class=&#34;math inline&#34;&gt;\(-1/1\)&lt;/span&gt; 系数求和就能得到答案。&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;d---sightseeing-plan&#34;&gt;D - Sightseeing Plan&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/agc018/tasks/agc018_e&#34; class=&#34;uri&#34;&gt;https://atcoder.jp/contests/agc018/tasks/agc018_e&lt;/a&gt;&lt;/p&gt;
&lt;ol type=&#34;1&#34;&gt;
&lt;li&gt;恒等式：&lt;span class=&#34;math inline&#34;&gt;\(\sum\limits_{i\in [x_1,x_2]}G_(x_1,y_1,i,y_2-1)=G(x_1,y_1,x_2,y_2)\)&lt;/span&gt;，放在网格图上就是强制走到 &lt;span class=&#34;math inline&#34;&gt;\((i,y_2-1)\)&lt;/span&gt;，再强制向右走一步，然后向上走到 &lt;span class=&#34;math inline&#34;&gt;\((x_2,y_2)\)&lt;/span&gt;。和上一题类似的，可以发现不重不漏。&lt;/li&gt;
&lt;li&gt;三个矩形，&lt;span class=&#34;math inline&#34;&gt;\(M_1\)&lt;/span&gt; 经过 &lt;span class=&#34;math inline&#34;&gt;\(M_2\)&lt;/span&gt; 到达 &lt;span class=&#34;math inline&#34;&gt;\(M_3\)&lt;/span&gt; 的路径数量：经过 &lt;span class=&#34;math inline&#34;&gt;\(M_2\)&lt;/span&gt; 时，根据限制，只可能从下面或左边进入。枚举进入的点 &lt;span class=&#34;math inline&#34;&gt;\((x_0,y_0)\)&lt;/span&gt;（数量为 &lt;span class=&#34;math inline&#34;&gt;\(O(n)\)&lt;/span&gt;），再计算 &lt;span class=&#34;math inline&#34;&gt;\(G(x_0,y_0,M_3)\)&lt;/span&gt; 就能得到不重不漏的答案。&lt;/li&gt;
&lt;li&gt;原问题：要求 &lt;span class=&#34;math inline&#34;&gt;\(M_2\)&lt;/span&gt; 内部路径上点的贡献和，这个其实就是 &lt;span class=&#34;math inline&#34;&gt;\(M_2\)&lt;/span&gt; 内部路径长度。若从 &lt;span class=&#34;math inline&#34;&gt;\((x_1,y_1)\)&lt;/span&gt; 进入，再从 &lt;span class=&#34;math inline&#34;&gt;\((x_2,y_2)\)&lt;/span&gt; 离开，长度就是 &lt;span class=&#34;math inline&#34;&gt;\(x_2-x_1+y_2-y_1+1\)&lt;/span&gt;。拆成 &lt;span class=&#34;math inline&#34;&gt;\((x_2+y_2+1)\)&lt;/span&gt; 和 &lt;span class=&#34;math inline&#34;&gt;\(-(x_1+y_1)\)&lt;/span&gt; 后发现一次进入和一次离开的贡献是独立的。分别枚举进入点和离开点计算贡献就可以了。&lt;/li&gt;
&lt;/ol&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int N = 2e6;
const int mod = 1e9 + 7;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#endif
    int x1, x2, x3, x4, x5, x6, y1, y2, y3, y4, y5, y6;
    std::cin &amp;gt;&amp;gt; x1 &amp;gt;&amp;gt; x2 &amp;gt;&amp;gt; x3 &amp;gt;&amp;gt; x4 &amp;gt;&amp;gt; x5 &amp;gt;&amp;gt; x6;
    std::cin &amp;gt;&amp;gt; y1 &amp;gt;&amp;gt; y2 &amp;gt;&amp;gt; y3 &amp;gt;&amp;gt; y4 &amp;gt;&amp;gt; y5 &amp;gt;&amp;gt; y6;
    std::vector&amp;lt;long long&amp;gt; fac(N + 1), inv(N + 1);
    fac[0] = inv[0] = 1ll;
    for (int i = 1; i &amp;lt;= N; ++i)
        fac[i] = fac[i - 1] * i % mod;
    auto qkp = [](long long x, int y) &amp;#123;
        auto res(1ll);
        for (; y; (x *= x) %= mod, y &amp;gt;&amp;gt;= 1)
            if (y &amp;amp; 1)
                (res *= x) %= mod;
        return res;
    &amp;#125;;
    inv[N] = qkp(fac[N], mod - 2);
    for (int i = N - 1; i; --i)
        inv[i] = inv[i + 1] * (i + 1) % mod;
    auto C = [&amp;amp;](int n, int m) &amp;#123;
        return fac[n] * inv[n - m] % mod * inv[m] % mod;
    &amp;#125;;
    std::vector&amp;lt;std::tuple&amp;lt;int, int, int&amp;gt; &amp;gt; f(4), g(4);
    f[0] = &amp;#123; x1 - 1, y1 - 1, 1 &amp;#125;, f[1] = &amp;#123; x1 - 1, y2, mod - 1 &amp;#125;, f[2] = &amp;#123; x2, y1 - 1, mod - 1 &amp;#125;, f[3] = &amp;#123; x2, y2, 1 &amp;#125;;
    g[0] = &amp;#123; x5, y5, 1 &amp;#125;, g[1] = &amp;#123; x5, y6 + 1, mod - 1 &amp;#125;, g[2] = &amp;#123; x6 + 1, y5, mod - 1 &amp;#125;, g[3] = &amp;#123; x6 + 1, y6 + 1, 1 &amp;#125;; 
    auto G = [&amp;amp;](int x1, int y1, int x2, int y2) &amp;#123;
        auto a(std::abs(x1 - x2)), b(std::abs(y1 - y2));
        return C(a + b, a);
    &amp;#125;;
    auto res = 0ll;
    for (auto [x1, y1, k1] : f)
        for (auto [x2, y2, k2] : g) &amp;#123;
            auto t(0ll);
            for (int x = x3; x &amp;lt;= x4; ++x) &amp;#123;
                (t += G(x1, y1, x, y4) * G(x, y4 + 1, x2, y2) % mod * (x + y4 + 1) % mod) %= mod;
                (t += mod - G(x1, y1, x, y3 - 1) * G(x, y3, x2, y2) % mod * (x + y3) % mod) %= mod;
            &amp;#125;
            for (int y = y3; y &amp;lt;= y4; ++y) &amp;#123;
                (t += G(x1, y1, x4, y) * G(x4 + 1, y, x2, y2) % mod * (x4 + y + 1) % mod) %= mod;
                (t += mod - G(x1, y1, x3 - 1, y) * G(x3, y, x2, y2) % mod * (x3 + y) % mod) %= mod;
            &amp;#125;
            // printf(&amp;quot;(%d, %d, %d), (%d, %d, %d): %lld\n&amp;quot;, x1, y1, k1, x2, y2, k2, t * k1 % mod * k2 % mod);
            (res += t * k1 % mod * k2 % mod) %= mod;
        &amp;#125;
    std::cout &amp;lt;&amp;lt; res &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;不经过-yxc-的方案数&#34;&gt;不经过 &lt;span class=&#34;math inline&#34;&gt;\(y=x+c\)&lt;/span&gt; 的方案数&lt;/h2&gt;
&lt;p&gt;Catalan 数的一种推导方式是，在 &lt;span class=&#34;math inline&#34;&gt;\(n\times n\)&lt;/span&gt; 的网格上，要求不能越过 &lt;span class=&#34;math inline&#34;&gt;\(y=x\)&lt;/span&gt; 的方案数。可以用总方案数减去越过的方案数。&lt;/p&gt;
&lt;p&gt;怎么计算非法的方案呢？越过 &lt;span class=&#34;math inline&#34;&gt;\(y=x\)&lt;/span&gt; 的路径必定存在一个点经过 &lt;span class=&#34;math inline&#34;&gt;\(y=x+1\)&lt;/span&gt;，原问题转化为不能碰到 &lt;span class=&#34;math inline&#34;&gt;\(y=x+1\)&lt;/span&gt; 的方案数。&lt;/p&gt;
&lt;p&gt;把终点 &lt;span class=&#34;math inline&#34;&gt;\((n, n)\)&lt;/span&gt; 翻折到 &lt;span class=&#34;math inline&#34;&gt;\(y=x+1\)&lt;/span&gt; 上方，得到 &lt;span class=&#34;math inline&#34;&gt;\((n-1, n + 1)\)&lt;/span&gt;；对于任意到达 &lt;span class=&#34;math inline&#34;&gt;\((n-1,n+1)\)&lt;/span&gt; 的路径，一定会接触 &lt;span class=&#34;math inline&#34;&gt;\(y=x+1\)&lt;/span&gt; 至少一次；将第一次接触以后的路径翻折到 &lt;span class=&#34;math inline&#34;&gt;\(y=x+1\)&lt;/span&gt; 下方，则一定和原图中的非法路径一一对应。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;4.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;就可以得到 &lt;span class=&#34;math inline&#34;&gt;\(C_{2n}^n-C_{2n}^{n-1}\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;如果问题变得更加一般，求解到达 &lt;span class=&#34;math inline&#34;&gt;\((n, m)\)&lt;/span&gt; 不能碰到 &lt;span class=&#34;math inline&#34;&gt;\(y=x+c\)&lt;/span&gt; 的方案数，还是可以把 &lt;span class=&#34;math inline&#34;&gt;\((n,m)\)&lt;/span&gt; 翻折到 &lt;span class=&#34;math inline&#34;&gt;\((m-c,n+c)\)&lt;/span&gt;，答案是 &lt;span class=&#34;math inline&#34;&gt;\(C_{n+m}^n-C_{n+m}^{m-c}\)&lt;/span&gt;。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;不经过-yx-l-和-yxr-的方案数&#34;&gt;不经过 &lt;span class=&#34;math inline&#34;&gt;\(y=x-l\)&lt;/span&gt; 和 &lt;span class=&#34;math inline&#34;&gt;\(y=x+r\)&lt;/span&gt; 的方案数&lt;/h2&gt;
&lt;p&gt;现在有 &lt;span class=&#34;math inline&#34;&gt;\(y=x-l\)&lt;/span&gt; 和 &lt;span class=&#34;math inline&#34;&gt;\(y=x+r\)&lt;/span&gt; 两条线作为限制，现在的翻折意义就会有一点改变。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;5.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;比如图中的 &lt;span class=&#34;math inline&#34;&gt;\(A&amp;#39;\)&lt;/span&gt;，是 &lt;span class=&#34;math inline&#34;&gt;\(A\)&lt;/span&gt; 沿着 &lt;span class=&#34;math inline&#34;&gt;\(y=x-l\)&lt;/span&gt; 翻折一次后的结果。还是按照之前的方式来理解，那么走到 &lt;span class=&#34;math inline&#34;&gt;\(A&amp;#39;\)&lt;/span&gt; 的路径代表至少经过一次 &lt;span class=&#34;math inline&#34;&gt;\(y=x-l\)&lt;/span&gt; 的方案。&lt;span class=&#34;math inline&#34;&gt;\(A&amp;#39;&amp;#39;\)&lt;/span&gt; 是 &lt;span class=&#34;math inline&#34;&gt;\(A&amp;#39;\)&lt;/span&gt; 沿着 &lt;span class=&#34;math inline&#34;&gt;\(y=x+r\)&lt;/span&gt; 翻折一次之后得到的结果，走到 &lt;span class=&#34;math inline&#34;&gt;\(A&amp;#39;&amp;#39;\)&lt;/span&gt; 的路径就代表至少先碰到一次 &lt;span class=&#34;math inline&#34;&gt;\(y=x-l\)&lt;/span&gt;，再碰到一次 &lt;span class=&#34;math inline&#34;&gt;\(y=x+r\)&lt;/span&gt; 的方案数。&lt;/p&gt;
&lt;p&gt;如果把相邻多次碰到 &lt;span class=&#34;math inline&#34;&gt;\(y=x-l\)&lt;/span&gt; 或 &lt;span class=&#34;math inline&#34;&gt;\(y=x+r\)&lt;/span&gt; 合并为一次，最终的非法路径就是 &lt;code&gt;LRLRLR...&lt;/code&gt; 或者 &lt;code&gt;RLRLRL...&lt;/code&gt; 的形式。因为可以计算的是「至少」的形式，用容斥原理得到，答案是 &lt;span class=&#34;math inline&#34;&gt;\(f_{\varnothing}-(f_{\texttt L} + f_{\texttt R}) + (f_{\texttt {LR}} + f_{\texttt {RL}}) - \cdots\)&lt;/span&gt;。对应计算每个翻折对应终点和答案就可以了。最后的答案是 &lt;span class=&#34;math inline&#34;&gt;\(C_{n+m}^n-C_{n+m}^{n+l}-C_{n+m}^{n + r}+C_{n+m}^{n+l-r}+C_{n+m}^{n+r-l}-\cdots\)&lt;/span&gt;，可以简化成 &lt;span class=&#34;math inline&#34;&gt;\(\sum\limits_{k\in \mathbb{Z}} C_{n+m}^{n-k\cdot (r-l)}-C_{n+m}^{n-k\cdot (r-l)+r}\)&lt;/span&gt;。&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;e---骗我呢&#34;&gt;E - 骗我呢&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P3266&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P3266&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;每行内部递增，而且选项只有 &lt;span class=&#34;math inline&#34;&gt;\([0,m]\)&lt;/span&gt;，那么每行就会刚好在 &lt;span class=&#34;math inline&#34;&gt;\([0,m]\)&lt;/span&gt; 里面跳过一个数。&lt;/p&gt;
&lt;p&gt;如果第 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 行跳过的数是 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt;，那么画一画图就可以发现第 &lt;span class=&#34;math inline&#34;&gt;\(i+1\)&lt;/span&gt; 可能跳过的数是 &lt;span class=&#34;math inline&#34;&gt;\([j-1,m]\)&lt;/span&gt;；反过来，第 &lt;span class=&#34;math inline&#34;&gt;\(i-1\)&lt;/span&gt; 行可能跳过的数就是 &lt;span class=&#34;math inline&#34;&gt;\([0,j+1]\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;如果让 &lt;span class=&#34;math inline&#34;&gt;\(f_{i,j}\)&lt;/span&gt; 表示确定了第 &lt;span class=&#34;math inline&#34;&gt;\(1\to i\)&lt;/span&gt; 行，其中第 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 行跳过 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; 的方案数，就可以得到 &lt;span class=&#34;math inline&#34;&gt;\(f_{i,j}=\sum\limits_{k=0}^{j+1} f_{i-1,k}\)&lt;/span&gt;。前缀和得到 &lt;span class=&#34;math inline&#34;&gt;\(f_{i,j}=f_{i,j-1}+f_{i-1,j+1}\)&lt;/span&gt;。注意边界：&lt;span class=&#34;math inline&#34;&gt;\(f_{0,j}=1\)&lt;/span&gt;；&lt;span class=&#34;math inline&#34;&gt;\(f_{i,0}=f_{i-1,0}+f_{i-1,1}\)&lt;/span&gt;；&lt;span class=&#34;math inline&#34;&gt;\(f_{i,m}=f_{i,m-1}\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;为了得到答案，让 &lt;span class=&#34;math inline&#34;&gt;\(g_{i,j}\)&lt;/span&gt; 表示 &lt;span class=&#34;math inline&#34;&gt;\(i\times j\)&lt;/span&gt; 矩阵的方案数（这样就有机会通过手段优化了）：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
\begin{aligned}
g_{i,j}&amp;amp;=\sum_{k=0}^j f_{i,k}\\
&amp;amp;= f_{i-1,0}+f_{i-1,1}+\sum_{k=1}^j f_{i,k-1}+f_{i-1,k+1}\\
&amp;amp;= g_{i,j-1}+g_{i-1,j+1}
\end{aligned}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;边界情况呢， &lt;span class=&#34;math inline&#34;&gt;\(g_{i, 0} = f_{i,0} = f_{i-1, 0} + f_{i - 1, 1} = g_{i-1,1}\)&lt;/span&gt;；&lt;span class=&#34;math inline&#34;&gt;\(g_{i,m}=g_{i, m - 1} + f_{i,m}=g_{i-1,m}+g_{i,m-1}\)&lt;/span&gt;。 &lt;span class=&#34;math inline&#34;&gt;\(g_{i,m+1}=g_{i,m}\)&lt;/span&gt; 避免边界。&lt;/p&gt;
&lt;p&gt;那么在网格图上转移如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;2.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;考虑将这个图形拉正，令 &lt;span class=&#34;math inline&#34;&gt;\((i+i,j)\gets g_{i,j}\)&lt;/span&gt; 得到：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;3.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;问题就转化为，从 &lt;span class=&#34;math inline&#34;&gt;\((0, 0)\)&lt;/span&gt; 走到 &lt;span class=&#34;math inline&#34;&gt;\((m+n+1,n)\)&lt;/span&gt; 且不能触碰 &lt;span class=&#34;math inline&#34;&gt;\(y=x+1\)&lt;/span&gt; 和 &lt;span class=&#34;math inline&#34;&gt;\(y=x-m-2\)&lt;/span&gt; 两条直线的方案数。&lt;/p&gt;
&lt;details&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;不经过一般过原点直线的方案数&#34;&gt;不经过一般过原点直线的方案数&lt;/h2&gt;
&lt;ol type=&#34;1&#34;&gt;
&lt;li&gt;&lt;p&gt;类型一：&lt;span class=&#34;math inline&#34;&gt;\((0,0)\to (n,m)\)&lt;/span&gt;，不经过 &lt;span class=&#34;math inline&#34;&gt;\(y=\dfrac mnx\)&lt;/span&gt; 的方案，其中要求 &lt;span class=&#34;math inline&#34;&gt;\((m,n)=1\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;方案为 &lt;span class=&#34;math inline&#34;&gt;\(\dfrac {C_{n+m}^n}{n+m}\)&lt;/span&gt;。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://xsc062.netlify.app/20250216/</guid>
            <title>杂题选谈：Public Round 15</title>
            <link>https://xsc062.netlify.app/20250216/</link>
            <category>线段树</category>
            <category>数学</category>
            <category>树上差分</category>
            <pubDate>Sun, 16 Feb 2025 19:44:38 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;&lt;a href=&#34;https://pjudge.ac/contest/1914&#34;&gt;PR #15&lt;/a&gt; 前两题题解。&lt;/p&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;最小表示法&#34;&gt;最小表示法&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://pjudge.ac/contest/1914/problem/21888&#34; class=&#34;uri&#34;&gt;https://pjudge.ac/contest/1914/problem/21888&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;首先不妨假设每个 &lt;span class=&#34;math inline&#34;&gt;\(f\)&lt;/span&gt; 在值域内等概率取值以简化问题。那么手玩一下可以轻松地得到规律：不妨将 &lt;span class=&#34;math inline&#34;&gt;\(\{s\}\)&lt;/span&gt; 循环右移一位的结果记为 &lt;span class=&#34;math inline&#34;&gt;\(\{t\}\)&lt;/span&gt;，那么 &lt;span class=&#34;math inline&#34;&gt;\(res=\sum\frac 1{\max(|s_i|,|t_i|)}\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;这看起来令人疑惑：对于不同的 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt;，&lt;span class=&#34;math inline&#34;&gt;\([f(s_i)=f(t_i)]\)&lt;/span&gt; 的期望似乎是彼此独立的，十分奇怪。这其实与表达式的来源有关，记 &lt;span class=&#34;math inline&#34;&gt;\(g(s_i, j)\)&lt;/span&gt; 表示 &lt;span class=&#34;math inline&#34;&gt;\(f(s_i)=j\)&lt;/span&gt; 的概率，那么上述等式可以转写为 &lt;span class=&#34;math inline&#34;&gt;\(res=\sum\limits_i\sum\limits_jg({s_i},j)\times g(t_i,j)\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;那么将最小表示法带来的偏差纳入考虑范围，我们发现 &lt;span class=&#34;math inline&#34;&gt;\(g(s,j)\)&lt;/span&gt; 对于不同的 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; 并不永远相等。具体地，当 &lt;span class=&#34;math inline&#34;&gt;\(s\)&lt;/span&gt; 具有循环节时，最小循环节的第一处结尾会享有更大的取得概率。&lt;/p&gt;
&lt;p&gt;枚举 &lt;span class=&#34;math inline&#34;&gt;\(s_i\)&lt;/span&gt; 的因数作为最小循环节长度的情况，显然，对于最小循环节为 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; 的情况（该情况出现的概率，容斥得到 &lt;span class=&#34;math inline&#34;&gt;\(p_j=26^j-\sum_{k\mid j}p_k\)&lt;/span&gt;），&lt;span class=&#34;math inline&#34;&gt;\(f(s_i)\)&lt;/span&gt; 的取值在 &lt;span class=&#34;math inline&#34;&gt;\(1\sim j\)&lt;/span&gt; 上等概率分布，差分即可统计每个值在不同循环节长度下被取到的概率和。&lt;/p&gt;
&lt;p&gt;用埃筛解决每个数的因数和 &lt;span class=&#34;math inline&#34;&gt;\(p\)&lt;/span&gt; 值，那么此时复杂度瓶颈在于 &lt;span class=&#34;math inline&#34;&gt;\(g(s_i, j)\)&lt;/span&gt; 和 &lt;span class=&#34;math inline&#34;&gt;\(\sum\limits_i\sum\limits_jg({s_i},j)\times g(t_i,j)\)&lt;/span&gt; 的求解。容易发现只有每个 &lt;span class=&#34;math inline&#34;&gt;\(g(s_i,j),j\mid |s_i|\)&lt;/span&gt; 的值是有效的（其他的和它们值都相同），考虑只求解和利用这些值，类 &lt;code&gt;std::merge&lt;/code&gt;（即归并排序）地求解答案。&lt;/p&gt;
&lt;p&gt;注意特判 &lt;span class=&#34;math inline&#34;&gt;\(n=1\)&lt;/span&gt;。会得到错误答案的原因是此时存在 &lt;span class=&#34;math inline&#34;&gt;\(s_i=t_i\)&lt;/span&gt;，不满足基本要求。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int lim = 1e5;
const int mod = 998244353;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#endif
    int n;
    std::cin &amp;gt;&amp;gt; n;
    if (n == 1) &amp;#123;
        std::cout &amp;lt;&amp;lt; 1 &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
        return 0;
    &amp;#125;
    auto qkp = [](long long x, int y) &amp;#123;
        long long res = 1ll;
        for (; y; y &amp;gt;&amp;gt;= 1, (x *= x) %= mod)
            if (y &amp;amp; 1)
                (res *= x) %= mod;
        return res;
    &amp;#125;;
    auto inv = [&amp;amp;](int x) &amp;#123;
        return qkp(x, mod - 2);
    &amp;#125;;
    std::vector&amp;lt;long long&amp;gt; f(lim + 1);
    std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; fac(lim + 1);
    for (int i = 1; i &amp;lt;= lim; ++i) &amp;#123;
        static long long now = 26;
        (f[i] += now) %= mod;
        fac[i].push_back(i);
        for (int j = 2 * i; j &amp;lt;= lim; j += i)
            (f[j] += mod - f[i]) %= mod, fac[j].push_back(i);
        (now *= 26) %= mod;
    &amp;#125;
    for (int i = 1; i &amp;lt;= lim; ++i)
        (f[i] *= inv(i)) %= mod;
    std::vector&amp;lt;int&amp;gt; a(n + 1);
    struct _ &amp;#123; int l, r; long long f; &amp;#125;;
    std::vector&amp;lt;std::vector&amp;lt;_&amp;gt; &amp;gt; g(lim + 1);
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        std::cin &amp;gt;&amp;gt; a[i];
        if (g[a[i]].empty()) &amp;#123;
            g[a[i]].resize(fac[a[i]].size());
            for (int j = 0; j &amp;lt; (int)fac[a[i]].size(); ++j) &amp;#123;
                g[a[i]][j].l = (j ? g[a[i]][j - 1].r + 1 : 1);
                g[a[i]][j].r = fac[a[i]][j];
                (g[a[i]][0].f += f[fac[a[i]][j]]) %= mod;
                if (j != (int)fac[a[i]].size() - 1)
                    (g[a[i]][j + 1].f += mod - f[fac[a[i]][j]]) %= mod;
            &amp;#125;
            for (int j = 1; j &amp;lt; (int)fac[a[i]].size(); ++j)
                (g[a[i]][j].f += g[a[i]][j - 1].f) %= mod;
            int getinv = inv(qkp(26, a[i]));
            for (int j = 0; j &amp;lt; (int)fac[a[i]].size(); ++j)
                (g[a[i]][j].f *= getinv) %= mod;
        &amp;#125;
    &amp;#125;
    std::vector&amp;lt;int&amp;gt; b(n + 1);
    std::rotate_copy(a.begin() + 1, --a.end(), a.end(), b.begin() + 1);
    long long res = 0ll;
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        for (int j = 0, k = 0, now = 0;
            j &amp;lt; (int)fac[a[i]].size() &amp;amp;&amp;amp; k &amp;lt; (int)fac[b[i]].size(); )
            if (g[a[i]][j].r &amp;lt; g[b[i]][k].r) &amp;#123;
                (res += g[a[i]][j].f * g[b[i]][k].f % mod
                    * (g[a[i]][j].r - now) % mod) %= mod;
                now = g[a[i]][j].r, ++j;
            &amp;#125;
            else if (g[a[i]][j].r == g[b[i]][k].r) &amp;#123;
                (res += g[a[i]][j].f * g[b[i]][k].f % mod
                    * (g[a[i]][j].r - now) % mod) %= mod;
                now = g[a[i]][j].r, ++j, ++k;
            &amp;#125;
            else &amp;#123;
                (res += g[a[i]][j].f * g[b[i]][k].f % mod
                    * (g[b[i]][k].r - now) % mod) %= mod;
                now = g[b[i]][k].r, ++k;
            &amp;#125;
    &amp;#125;
    std::cout &amp;lt;&amp;lt; res &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;二叉搜索树&#34;&gt;二叉搜索树&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://pjudge.ac/contest/1914/problem/21889&#34; class=&#34;uri&#34;&gt;https://pjudge.ac/contest/1914/problem/21889&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;当我们处理链的部分分时，很容易想到用差分解决问题。把更新 &lt;span class=&#34;math inline&#34;&gt;\([l, r]\)&lt;/span&gt; 看作在差分数组 &lt;span class=&#34;math inline&#34;&gt;\(l\)&lt;/span&gt; 处插入，在 &lt;span class=&#34;math inline&#34;&gt;\(r+1\)&lt;/span&gt; 处删除，离线下来再从左到右扫一遍操作，考虑如何解决查询问题。&lt;/p&gt;
&lt;p&gt;考虑如何获取 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 树上 &lt;span class=&#34;math inline&#34;&gt;\(t_0\)&lt;/span&gt; 时刻点 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 的所有祖先。根据前面的操作，我们可以获取 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 树上存在过的所有元素。&lt;/p&gt;
&lt;p&gt;对于比 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 大的元素，考虑祖先 &lt;span class=&#34;math inline&#34;&gt;\(p_a\)&lt;/span&gt; 和非祖先 &lt;span class=&#34;math inline&#34;&gt;\(p\)&lt;/span&gt; 有什么区别。根据 BST 的性质易得，对于最低的右侧祖先 &lt;span class=&#34;math inline&#34;&gt;\({p_a}_0\)&lt;/span&gt;，其是 &lt;span class=&#34;math inline&#34;&gt;\(\ge x\)&lt;/span&gt; 的最小的元素（当然其加入时刻 &lt;span class=&#34;math inline&#34;&gt;\(t_a&amp;lt;t_0\)&lt;/span&gt;）；那么同理可以找到 &lt;span class=&#34;math inline&#34;&gt;\({p_a}_0\)&lt;/span&gt; 右侧最低的祖先（其左侧的祖先显然也 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 左侧），该祖先满足 &lt;span class=&#34;math inline&#34;&gt;\(t&amp;lt;t_a\)&lt;/span&gt;。那么我们就从左右两边分别得到 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 的所有祖先。容易证明该过程对于不在树上的 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 也是正确的。&lt;/p&gt;
&lt;p&gt;具体地，我们需要一个数据结构，能够求出 &lt;span class=&#34;math inline&#34;&gt;\(\ge x\)&lt;/span&gt; 的元素中，以 &lt;span class=&#34;math inline&#34;&gt;\(t_0\)&lt;/span&gt; 为起点的前缀最小值序列的区间和。&lt;/p&gt;
&lt;p&gt;欸 ☝🤓 这是什么？&lt;a href=&#34;/20250217&#34;&gt;楼房重建&lt;/a&gt;！秒一下！&lt;/p&gt;
&lt;p&gt;进一步地，本题需要完成对于 &lt;span class=&#34;math inline&#34;&gt;\(t_0\)&lt;/span&gt; 为序列头的查询。再次利用性质，每次 &lt;span class=&#34;math inline&#34;&gt;\(O(\log V)\)&lt;/span&gt; 地合并答案。&lt;/p&gt;
&lt;p&gt;好的那么怎么把链搞到树上呢？把差分放到树上，写个线段树合并即可。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意由于这题细节太多了，所以你可能需要舍弃不必要的时空优化换取代码简洁度以方便调试。&lt;/strong&gt;&lt;/p&gt;
&lt;details&gt;
&lt;pre data-line=&#34;12&#34; class=&#34;cpp language-cpp&#34;&gt;&lt;code data-line=&#34;12&#34; class=&#34;cpp language-cpp&#34;&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int lim = 2e5;
const int maxn = 2e7 + 5;
const int inf = 0x3f3f3f3f;
struct &amp;#123;
    int l, r, rv;
    long long u;
&amp;#125; t[maxn];
std::vector&amp;lt;int&gt; tr;
#define lt t[p].l
#define rt t[p].r
int newnode(void) &amp;#123;         // 我知道你要说什么，但这属于「必要的」空间优化 😥
    static int tot = 0;
    if (tr.empty())
        return ++tot;
    auto p(tr.back());
    t[p].l = t[p].r = 0;
    tr.pop_back();
    return p;
&amp;#125;
long long askv(int p, int l, int r, int v) &amp;#123;
    if (l == r)
        return t[p].rv &lt; v ? t[p].u : 0;
    int mid = (l + r) &gt;&gt; 1;
    if (v &gt; t[lt].rv)
        return t[p].u - t[lt].u + askv(lt, l, mid, v);
    return askv(rt, mid + 1, r, v);
&amp;#125;
void pushup(int p, int l, int r) &amp;#123;
    t[p].rv = std::min(t[lt].rv, t[rt].rv);
    int mid = (l + r) &gt;&gt; 1;
    t[p].u = t[lt].u + askv(rt, mid + 1, r, t[lt].rv);
    return;
&amp;#125;
void upd(int &amp;p, int l, int r, int x, int v, int u) &amp;#123;
    if (!p)
        p = newnode();
    if (l == r) &amp;#123;
        t[p].rv = v, t[p].u = u;
        return;
    &amp;#125;
    int mid = (l + r) &gt;&gt; 1;
    if (x &lt;= mid)
        upd(lt, l, mid, x, v, u);
    else
        upd(rt, mid + 1, r, x, v, u);
    pushup(p, l, r);
    return;
&amp;#125;
void merge(int &amp;p, int q, int l, int r) &amp;#123;
    if (!p || !q) &amp;#123;
        p += q;
        return;
    &amp;#125;
    if (l == r) &amp;#123;
        t[p].rv = std::min(t[p].rv, t[q].rv);
        t[p].u = std::max(t[p].u, t[q].u);
        return;
    &amp;#125;
    int mid = (l + r) &gt;&gt; 1;
    merge(t[p].l, t[q].l, l, mid), merge(t[p].r, t[q].r, mid + 1, r);
    pushup(p, l, r), tr.push_back(q);
    return;
&amp;#125;
int qv = inf;
long long ask(int p, int l, int r, int ql, int qr) &amp;#123;
    if (ql &lt;= l &amp;&amp; r &lt;= qr) &amp;#123;
        auto s(askv(p, l, r, qv));
        qv = std::min(qv, t[p].rv);
        return s;
    &amp;#125;
    int mid = (l + r) &gt;&gt; 1;
    long long res = 0ll;
    if (ql &lt;= mid)
        res = ask(lt, l, mid, ql, qr);
    if (qr &gt; mid)
        res += ask(rt, mid + 1, r, ql, qr);
    return res;
&amp;#125;
#undef lt
#undef rt
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&#34;ex_problem4.in&#34;, &#34;r&#34;, stdin);
    std::freopen(&#34;.out&#34;, &#34;w&#34;, stdout);
#endif
    int n, m;
    std::cin &gt;&gt; n &gt;&gt; m;
    std::vector&amp;lt;std::vector&amp;lt;int&gt; &gt; g(n + 1);
    for (int i = 1, x, y; i &lt; n; ++i) &amp;#123;
        std::cin &gt;&gt; x &gt;&gt; y;
        g[x].push_back(y), g[y].push_back(x);
    &amp;#125;
    std::vector&amp;lt;int&gt; top(n + 1), fa(n + 1), siz(n + 1), son(n + 1), dep(n + 1);
    std::function&amp;lt;void(int, int)&gt; DFS = [&amp;](int x, int faa) &amp;#123;
        siz[x] = 1;
        for (auto i : g[x])
            if (i != faa) &amp;#123;
                fa[i] = x, dep[i] = dep[x] + 1;
                DFS(i, x), siz[x] += siz[i];
                if (siz[i] &gt; siz[son[x]])
                    son[x] = i;
            &amp;#125;
        return;
    &amp;#125;;
    DFS(1, -1);
    DFS = [&amp;](int x, int topp) &amp;#123;
        top[x] = topp;
        if (son[x])
            DFS(son[x], topp);
        for (auto i : g[x])
            if (i != fa[x] &amp;&amp; i != son[x])
                DFS(i, i);
        return;
    &amp;#125;;
    DFS(1, 1);
    auto getLCA = [&amp;](int x, int y) &amp;#123;
        for (; top[x] != top[y]; x = fa[top[x]])
            if (dep[top[y]] &gt; dep[top[x]])
                std::swap(x, y);
        return (dep[x] &lt; dep[y] ? x : y);
    &amp;#125;;
    std::vector&amp;lt;std::vector&amp;lt;int&gt; &gt; d(n + 1);
    std::vector&amp;lt;std::vector&amp;lt;std::pair&amp;lt;int, int&gt; &gt; &gt; u(n + 1);
    std::vector&amp;lt;std::vector&amp;lt;std::tuple&amp;lt;int, int, int&gt; &gt; &gt; q(n + 1);
    int cnt = 0;
    for (int i = 1; i &lt;= m; ++i) &amp;#123;
        int op;
        std::cin &gt;&gt; op;
        if (op == 0) &amp;#123;
            int x, v;
            std::cin &gt;&gt; x &gt;&gt; v;
            q[x].emplace_back(++cnt, i, v);
        &amp;#125; else &amp;#123;
            int x, y, v;
            std::cin &gt;&gt; x &gt;&gt; y &gt;&gt; v;
            int faa = getLCA(x, y);
            u[x].emplace_back(i, v), u[y].emplace_back(i, v);
            if (fa[faa])
                d[fa[faa]].emplace_back(v);
        &amp;#125;
    &amp;#125;
    std::vector&amp;lt;long long&gt; res(cnt + 1);
    std::vector&amp;lt;std::vector&amp;lt;int&gt; &gt; rt(2, std::vector&amp;lt;int&gt; (n + 1));
    t[0].rv = inf;
    DFS = [&amp;](int x, int fa) &amp;#123;
        for (auto i : g[x])
            if (i != fa) &amp;#123;
                DFS(i, x);
                merge(rt[0][x], rt[0][i], 1, lim);
                merge(rt[1][x], rt[1][i], 1, lim);
            &amp;#125;
        for (auto [t, v] : u[x]) &amp;#123;
            upd(rt[0][x], 1, lim, v, t, v);
            upd(rt[1][x], 1, lim, lim - v + 1, t, v);
        &amp;#125;
        for (auto v : d[x]) &amp;#123;
            upd(rt[0][x], 1, lim, v, inf, 0);
            upd(rt[1][x], 1, lim, lim - v + 1, inf, 0);
        &amp;#125;
        for (auto [id, t, v] : q[x]) &amp;#123;
            qv = t, res[id] = ask(rt[0][x], 1, lim, v, lim);
            qv = t, res[id] += ask(rt[1][x], 1, lim, lim - v + 1, lim);
            qv = t, res[id] -= ask(rt[0][x], 1, lim, v, v);
        &amp;#125;
    &amp;#125;;
    DFS(1, -1);
    for (int i = 1; i &lt;= cnt; ++i)
        std::cout &lt;&lt; res[i] &lt;&lt; &#39;\n&#39;;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://xsc062.netlify.app/20240111/</guid>
            <title>解题报告：Game with Probability Problem</title>
            <link>https://xsc062.netlify.app/20240111/</link>
            <category>DP</category>
            <category>数学</category>
            <pubDate>Thu, 11 Jan 2024 11:25:19 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;&lt;a href=&#34;https://www.becoder.com.cn/contest/4665/problem/2&#34;&gt;SP4060 Game with Probability Problem&lt;/a&gt;。&lt;/p&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;
&lt;hr /&gt;
&lt;p&gt;设 &lt;span class=&#34;math inline&#34;&gt;\(f_i,g_i\)&lt;/span&gt; 分别表示还剩 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 个的时候轮到 Alice 和 Bob 时 &lt;strong&gt;Alice&lt;/strong&gt; 分别的胜率。&lt;/p&gt;
&lt;p&gt;概率经典倒推。那么显然有 &lt;span class=&#34;math inline&#34;&gt;\(f_0=0,g_0=1\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;然后就是一个分讨，讨论这个人想要正面还是反面。很显然，对于同样的剩余棋子数，两个人先手的情况对于这颗棋子的喜爱程度是一样的。也就是说，要么都想要，要么都不想要。&lt;/p&gt;
&lt;p&gt;什么时候想要呢？拿掉过后自己胜率更大，也就是 &lt;span class=&#34;math inline&#34;&gt;\(g_{i-1}&amp;gt;f_{i-1}\)&lt;/span&gt;。此时有：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
f_i=(1-p)\times g_i+p\times g_{i-1}\\
g_i=(1-q)\times f_i+q\times f_{i-1}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;发现是互相影响的，这个时候先不要着急怀疑自己推错了，因为我们这里有两个未知数，又刚好有两个方程，暴解一下就有：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
f_i=\dfrac {(1-p)\times q\times f_{i-1}+p\times g_{i-1}}{1-(1-p)(1-q)}\\
g_i=\dfrac {(1-q)\times p\times g_{i-1}+q\times f_{i-1}}{1-(1-p)(1-q)}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;然后 &lt;span class=&#34;math inline&#34;&gt;\(g_{i-1}&amp;lt;f_{i-1}\)&lt;/span&gt; 的情况也差不多，把拿的概率和不拿的概率换一下：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
f_i=p\times g_i+(1-p)\times g_{i-1}\\
g_i=q\times f_i+(1-q)\times f_{i-1}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;解方程组有：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
f_i=\dfrac {(1-q)\times p\times f_{i-1}+(1-p)\times g_{i-1}}{1-p\times q}\\
g_i=\dfrac {(1-p)\times q\times g_{i-1}+(1-q)\times f_{i-1}}{1-p\times q}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;然后就可以开始 DP 了。最后的答案就是 &lt;span class=&#34;math inline&#34;&gt;\(f_{\min(n,1000)}\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;还有个问题就是 &lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt; 特别大然后这个看起来也不太能矩乘，但是这个 DP 式有个好处是它的增长趋势是指数级的，所以我们 DP 到 &lt;span class=&#34;math inline&#34;&gt;\(1000\)&lt;/span&gt; 就可以了。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
namespace XSC062 &amp;#123;
const int maxn = 1e3 + 5;
using db = double;
db p, q;
int T, n;
db f[maxn], g[maxn];
int min(int x, int y) &amp;#123;
    return x &amp;lt; y ? x : y;
&amp;#125;
int main() &amp;#123;
    scanf(&amp;quot;%d&amp;quot;, &amp;amp;T);
    while (T--) &amp;#123;
        scanf(&amp;quot;%d %lf %lf&amp;quot;, &amp;amp;n, &amp;amp;p, &amp;amp;q);
        f[0] = .0, g[0] = 1.0;
        for (int i = 1; i &amp;lt;= n &amp;amp;&amp;amp; i &amp;lt;= 1000; ++i) &amp;#123;
            if (g[i - 1] &amp;gt; f[i - 1]) &amp;#123;
                f[i] = ((1 - p) * q * f[i - 1] + p * g[i - 1]) / (1 - (1 - p) * (1 - q));
                g[i] = ((1 - q) * p * g[i - 1] + q * f[i - 1]) / (1 - (1 - p) * (1 - q));
            &amp;#125;
            else &amp;#123;
                f[i] = ((1 - q) * p * f[i - 1] + (1 - p) * g[i - 1]) / (1 - p * q);
                g[i] = ((1 - p) * q * g[i - 1] + (1 - q) * f[i - 1]) / (1 - p * q);
            &amp;#125;
        &amp;#125;
        printf(&amp;quot;%.6lf\n&amp;quot;, f[min(n, 1000)]);
    &amp;#125;
    return 0;
&amp;#125;
&amp;#125; // namespace XSC062
int main() &amp;#123;
    XSC062::main();
    return 0;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
 ]]></description>
        </item>
    </channel>
</rss>
