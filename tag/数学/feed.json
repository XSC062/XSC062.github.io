{
    "version": "https://jsonfeed.org/version/1",
    "title": "null • All posts by \"数学\" tag",
    "description": "",
    "home_page_url": "https://xsc062.netlify.app",
    "items": [
        {
            "id": "https://xsc062.netlify.app/20250419/",
            "url": "https://xsc062.netlify.app/20250419/",
            "title": "网格图路径计数",
            "date_published": "2025-04-19T02:03:57.000Z",
            "content_html": "<figure>\n<img src=\"/20250419/neko.jpeg\" alt=\"猫\" style=\"width: 75px\">\n<figcaption>\n猫\n</figcaption>\n</figure>\n<span id=\"more\"></span>\n<hr />\n<h2 id=\"点到点的方案数\">点到点的方案数</h2>\n<p>从 <span class=\"math inline\">\\((x_1,y_1)\\)</span> 只能向右、向下走到 <span class=\"math inline\">\\((x_2,y_2)\\)</span> 的方案数：<span class=\"math inline\">\\(C_{x_2-x_1+y_2-y_1}^{x_2-x_1}\\)</span>。就是说，因为必须向下走 <span class=\"math inline\">\\(x_2-x_1\\)</span> 步，又必须向右走 <span class=\"math inline\">\\(y_2-y_1\\)</span> 步；但顺序是可以任意打乱的。</p>\n<hr />\n<h3 id=\"a---gerald-and-giant-chess\">A - Gerald and Giant Chess</h3>\n<p><a href=\"https://codeforces.com/problemset/problem/560/E\" class=\"uri\">https://codeforces.com/problemset/problem/560/E</a></p>\n<p>把不能走的点按 <span class=\"math inline\">\\(x\\)</span> 为第一关键字，<span class=\"math inline\">\\(y\\)</span> 为第二关键字排序，就可以得到它们按大致拓扑序排列的结果。</p>\n<p>令 <span class=\"math inline\">\\(f_i\\)</span> 表示不经过 <span class=\"math inline\">\\(1\\sim i-1\\)</span> 的非法点走到第 <span class=\"math inline\">\\(i\\)</span> 个非法点的方案数，就可以得到 <span class=\"math inline\">\\(f_i=C_{x_i+y_i,x_i}-\\sum_{j=1}^{i-1} f_j\\times C_{x_i-x_j+y_i-y_j}^{x_i-x_j}\\)</span>。可以发现后面减去的方案，因为碰到的第一个非法点不同，所以是两两不同的。</p>\n<p>让 <span class=\"math inline\">\\((h,w)\\)</span> 成为第 <span class=\"math inline\">\\((n+1)\\)</span> 个非法点，<span class=\"math inline\">\\(f_{n+1}\\)</span> 就是答案。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 1e9 + 7;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int h, w, n;\n    std::cin &gt;&gt; h &gt;&gt; w &gt;&gt; n, --h, --w;\n    std::vector&lt;std::pair&lt;int, int&gt; &gt; a(n + 2);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; a[i].first &gt;&gt; a[i].second;\n        --a[i].first, --a[i].second;\n    &#125;\n    a[n + 1] = &#123; h, w &#125;;\n    std::sort(a.begin() + 1, a.end());\n    std::vector&lt;long long&gt; fac(h + w + 1), inv(h + w + 1);\n    fac[0] = inv[0] = 1ll;\n    for (int i = 1; i &lt;= h + w; ++i)\n        fac[i] = fac[i - 1] * i % mod;\n    auto qkp = [](long long x, int y) &#123;\n        auto res = 1ll;\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    inv[h + w] = qkp(fac[h + w], mod - 2);\n    for (int i = h + w - 1; i; --i)\n        inv[i] = inv[i + 1] * (i + 1) % mod;\n    auto C = [&amp;](int n, int m) &#123;\n        return fac[n] * inv[n - m] % mod * inv[m] % mod;\n    &#125;;\n    std::vector&lt;long long&gt; f(n + 2);\n    for (int i = 1; i &lt;= n + 1; ++i) &#123;\n        f[i] = C(a[i].first + a[i].second, a[i].first);\n        for (int j = 1; j &lt; i; ++j)\n            if (a[j].second &lt;= a[i].second)\n                (f[i] += mod - f[j] * C(a[i].first - a[j].first + a[i].second - a[j].second, a[i].first - a[j].first) % mod) %= mod;\n        // printf(&quot;f[(%d, %d)] = %lld\\n&quot;, a[i].first, a[i].second, f[i]);\n    &#125;\n    std::cout &lt;&lt; f[n + 1] &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"b---bbq-hard\">B - BBQ Hard</h3>\n<p><a href=\"https://atcoder.jp/contests/agc001/tasks/agc001_e\" class=\"uri\">https://atcoder.jp/contests/agc001/tasks/agc001_e</a></p>\n<p>不仅仅可以在关键点上 DP，也可以在网格上直接 DP。</p>\n<p><span class=\"math inline\">\\(A_i+B_i+A_j+B_j\\)</span> 就是 <span class=\"math inline\">\\(A_i+B_i-(-A_j)-(-B_j)\\)</span>。把棋盘扩大到 <span class=\"math inline\">\\(-2000\\to 2000\\)</span> 就可以了。</p>\n<p>设 <span class=\"math inline\">\\(f_{i,j}\\)</span> 表示可以到达 <span class=\"math inline\">\\((i,j)\\)</span> 的所有发出关键点 <span class=\"math inline\">\\((-A_j,-B_j)\\)</span> 带来的贡献，那么 <span class=\"math inline\">\\(f_{i,j}=f_{i-1,j}+f_{i,j-1}\\)</span>。枚举所有接收关键点 <span class=\"math inline\">\\((A_i,B_i)\\)</span>，<span class=\"math inline\">\\(\\sum f_{A_i,B_i}\\)</span> 就是答案的两倍，再减去对角线，也就是 <span class=\"math inline\">\\(\\sum (-A_i,B_i)\\to (A_i,B_i)\\)</span> 后的值。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int N = 2000;\nconst int mod = 1e9 + 7;\nconst int inv2 = 500000004;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;long long&gt; fac(4 * N + 1), inv(4 * N + 1);\n    fac[0] = inv[0] = 1ll;\n    for (int i = 1; i &lt;= 4 * N; ++i)\n        fac[i] = fac[i - 1] * i % mod;\n    auto qkp = [](long long x, int y) &#123;\n        auto res(1ll);\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    inv[4 * N] = qkp(fac[4 * N], mod - 2);\n    for (int i = 4 * N - 1; i; --i)\n        inv[i] = inv[i + 1] * (i + 1) % mod;\n    std::vector&lt;std::pair&lt;int, int&gt; &gt; a(n + 1);\n    std::vector&lt;std::vector&lt;long long&gt; &gt; f(2 * N + 1, std::vector&lt;long long&gt; (2 * N + 1));\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; a[i].first &gt;&gt; a[i].second;\n        ++f[N - a[i].first][N - a[i].second];\n    &#125;\n    for (int i = 0; i &lt;= 2 * N; ++i)\n        for (int j = 0; j &lt;= 2 * N; ++j) &#123;\n            if (i &gt;= 1)\n                (f[i][j] += f[i - 1][j]) %= mod;\n            if (j &gt;= 1)\n                (f[i][j] += f[i][j - 1]) %= mod;\n            // printf(&quot;f(%2d, %2d) = %lld\\n&quot;, i - N, j - N, f[i][j]);\n        &#125;\n    long long res = 0ll;\n    auto C = [&amp;](int n, int m) &#123;\n        return fac[n] * inv[n - m] % mod * inv[m] % mod;\n    &#125;;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        (res += f[a[i].first + N][a[i].second + N]) %= mod;\n        (res += mod - C(a[i].first * 2 + a[i].second * 2, 2 * a[i].first)) %= mod;\n    &#125;\n    std::cout &lt;&lt; res * inv2 % mod &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"c---iroha-and-a-grid\">C - Iroha and a Grid</h3>\n<p><a href=\"https://atcoder.jp/contests/arc058/tasks/arc058_b\" class=\"uri\">https://atcoder.jp/contests/arc058/tasks/arc058_b</a></p>\n<p>先把绿色部分的答案计算出来：</p>\n<figure>\n<img src=\"1.png\" alt=\"网格\" /><figcaption>网格</figcaption>\n</figure>\n<p>如果把绿色的每一个格子到终点的方案数求和，就会算重，因为上面的绿色点可以走到下面的绿色点。</p>\n<p>让绿色点第一步只能往右走到黄色点，用这样的方案为黄色点赋初值，再让黄色点自由走就可以得到答案了。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 1e9 + 7;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int h, w, a, b;\n    std::cin &gt;&gt; h &gt;&gt; w &gt;&gt; a &gt;&gt; b;\n    std::vector&lt;long long&gt; fac(h + w + 1), inv(h + w + 1);\n    fac[0] = inv[0] = 1ll;\n    for (int i = 1; i &lt;= h + w; ++i)\n        fac[i] = fac[i - 1] * i % mod;\n    auto qkp = [](long long x, int y) &#123;\n        auto res(1ll);\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    inv[h + w] = qkp(fac[h + w], mod - 2);\n    for (int i = h + w - 1; i; --i)\n        inv[i] = inv[i + 1] * (i + 1) % mod;\n    auto C = [&amp;](int n, int m) &#123;\n        return fac[n] * inv[n - m] % mod * inv[m] % mod;\n    &#125;;\n    auto res = 0ll;\n    for (int i = 1; i &lt;= h - a; ++i) &#123;\n        // (i, B)\n        auto f(C(i + b - 2, i - 1));\n        // printf(&quot;(%d, %d): %lld\\n&quot;, i, b, f);\n        // (i, B + 1)\n        (res += f * C(h - i + w - (b + 1), h - i) % mod) %= mod;\n    &#125;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"点到矩形的方案数\">点到矩形的方案数</h2>\n<p>从 <span class=\"math inline\">\\((x_0,y_0)\\)</span> 走到矩形 <span class=\"math inline\">\\((x_1,y_1,x_2,y_2)\\)</span> 的方案数：</p>\n<p><span class=\"math display\">\\[\n\\sum\\limits_{i\\in [x_1,x_2],j\\in [y_1,y_2]} G(x_0,y_0, i, j) = G(x_0,y_0,x_2 + 1,y_2 + 1)-G(x_0,y_0,x_2+1,y_1)-G(x_0,y_0,x_1,y_2+1)+G(x_0,y_0,x_1,y_1)\n\\]</span></p>\n<p>证明：<span class=\"math inline\">\\(G(x_0,y_0,x_2+1,y_2+1)=\\sum\\limits_i G(x_0,y_0,i,y_2)=\\sum\\limits_{i,j} G(x_0,y_0,i,j)\\)</span>，类似的，把后面几项展开，可以得到前缀和的结构。</p>\n<p>现在，矩形就可以被概括成 4 个点了。</p>\n<hr />\n<h2 id=\"矩形到矩形的方案数\">矩形到矩形的方案数</h2>\n<p>枚举第一个矩形里的所有点，那么就可以得到关于第二个矩形里四个点的表达式。反过来把第一个矩形概括为 4 个点就可以快速求解了。</p>\n<p>具体一点，第一个矩形 <span class=\"math inline\">\\((x_1,y_1,x_2,y_2)\\)</span> 可以被概括为 <span class=\"math inline\">\\((x_1-1,y_1-1)\\)</span>，<span class=\"math inline\">\\((x_1-1,y_2)\\)</span>，<span class=\"math inline\">\\((x_2,y_1-1)\\)</span>，<span class=\"math inline\">\\((x_2,y_2)\\)</span>。注意方向颠倒导致符号发生变化。此时对 <span class=\"math inline\">\\(4\\times 4=16\\)</span> 个 <span class=\"math inline\">\\(G\\)</span> 按对应的 <span class=\"math inline\">\\(-1/1\\)</span> 系数求和就能得到答案。</p>\n<hr />\n<h3 id=\"d---sightseeing-plan\">D - Sightseeing Plan</h3>\n<p><a href=\"https://atcoder.jp/contests/agc018/tasks/agc018_e\" class=\"uri\">https://atcoder.jp/contests/agc018/tasks/agc018_e</a></p>\n<ol type=\"1\">\n<li>恒等式：<span class=\"math inline\">\\(\\sum\\limits_{i\\in [x_1,x_2]}G_(x_1,y_1,i,y_2-1)=G(x_1,y_1,x_2,y_2)\\)</span>，放在网格图上就是强制走到 <span class=\"math inline\">\\((i,y_2-1)\\)</span>，再强制向右走一步，然后向上走到 <span class=\"math inline\">\\((x_2,y_2)\\)</span>。和上一题类似的，可以发现不重不漏。</li>\n<li>三个矩形，<span class=\"math inline\">\\(M_1\\)</span> 经过 <span class=\"math inline\">\\(M_2\\)</span> 到达 <span class=\"math inline\">\\(M_3\\)</span> 的路径数量：经过 <span class=\"math inline\">\\(M_2\\)</span> 时，根据限制，只可能从下面或左边进入。枚举进入的点 <span class=\"math inline\">\\((x_0,y_0)\\)</span>（数量为 <span class=\"math inline\">\\(O(n)\\)</span>），再计算 <span class=\"math inline\">\\(G(x_0,y_0,M_3)\\)</span> 就能得到不重不漏的答案。</li>\n<li>原问题：要求 <span class=\"math inline\">\\(M_2\\)</span> 内部路径上点的贡献和，这个其实就是 <span class=\"math inline\">\\(M_2\\)</span> 内部路径长度。若从 <span class=\"math inline\">\\((x_1,y_1)\\)</span> 进入，再从 <span class=\"math inline\">\\((x_2,y_2)\\)</span> 离开，长度就是 <span class=\"math inline\">\\(x_2-x_1+y_2-y_1+1\\)</span>。拆成 <span class=\"math inline\">\\((x_2+y_2+1)\\)</span> 和 <span class=\"math inline\">\\(-(x_1+y_1)\\)</span> 后发现一次进入和一次离开的贡献是独立的。分别枚举进入点和离开点计算贡献就可以了。</li>\n</ol>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int N = 2e6;\nconst int mod = 1e9 + 7;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int x1, x2, x3, x4, x5, x6, y1, y2, y3, y4, y5, y6;\n    std::cin &gt;&gt; x1 &gt;&gt; x2 &gt;&gt; x3 &gt;&gt; x4 &gt;&gt; x5 &gt;&gt; x6;\n    std::cin &gt;&gt; y1 &gt;&gt; y2 &gt;&gt; y3 &gt;&gt; y4 &gt;&gt; y5 &gt;&gt; y6;\n    std::vector&lt;long long&gt; fac(N + 1), inv(N + 1);\n    fac[0] = inv[0] = 1ll;\n    for (int i = 1; i &lt;= N; ++i)\n        fac[i] = fac[i - 1] * i % mod;\n    auto qkp = [](long long x, int y) &#123;\n        auto res(1ll);\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    inv[N] = qkp(fac[N], mod - 2);\n    for (int i = N - 1; i; --i)\n        inv[i] = inv[i + 1] * (i + 1) % mod;\n    auto C = [&amp;](int n, int m) &#123;\n        return fac[n] * inv[n - m] % mod * inv[m] % mod;\n    &#125;;\n    std::vector&lt;std::tuple&lt;int, int, int&gt; &gt; f(4), g(4);\n    f[0] = &#123; x1 - 1, y1 - 1, 1 &#125;, f[1] = &#123; x1 - 1, y2, mod - 1 &#125;, f[2] = &#123; x2, y1 - 1, mod - 1 &#125;, f[3] = &#123; x2, y2, 1 &#125;;\n    g[0] = &#123; x5, y5, 1 &#125;, g[1] = &#123; x5, y6 + 1, mod - 1 &#125;, g[2] = &#123; x6 + 1, y5, mod - 1 &#125;, g[3] = &#123; x6 + 1, y6 + 1, 1 &#125;; \n    auto G = [&amp;](int x1, int y1, int x2, int y2) &#123;\n        auto a(std::abs(x1 - x2)), b(std::abs(y1 - y2));\n        return C(a + b, a);\n    &#125;;\n    auto res = 0ll;\n    for (auto [x1, y1, k1] : f)\n        for (auto [x2, y2, k2] : g) &#123;\n            auto t(0ll);\n            for (int x = x3; x &lt;= x4; ++x) &#123;\n                (t += G(x1, y1, x, y4) * G(x, y4 + 1, x2, y2) % mod * (x + y4 + 1) % mod) %= mod;\n                (t += mod - G(x1, y1, x, y3 - 1) * G(x, y3, x2, y2) % mod * (x + y3) % mod) %= mod;\n            &#125;\n            for (int y = y3; y &lt;= y4; ++y) &#123;\n                (t += G(x1, y1, x4, y) * G(x4 + 1, y, x2, y2) % mod * (x4 + y + 1) % mod) %= mod;\n                (t += mod - G(x1, y1, x3 - 1, y) * G(x3, y, x2, y2) % mod * (x3 + y) % mod) %= mod;\n            &#125;\n            // printf(&quot;(%d, %d, %d), (%d, %d, %d): %lld\\n&quot;, x1, y1, k1, x2, y2, k2, t * k1 % mod * k2 % mod);\n            (res += t * k1 % mod * k2 % mod) %= mod;\n        &#125;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"不经过-yxc-的方案数\">不经过 <span class=\"math inline\">\\(y=x+c\\)</span> 的方案数</h2>\n<p>Catalan 数的一种推导方式是，在 <span class=\"math inline\">\\(n\\times n\\)</span> 的网格上，要求不能越过 <span class=\"math inline\">\\(y=x\\)</span> 的方案数。可以用总方案数减去越过的方案数。</p>\n<p>怎么计算非法的方案呢？越过 <span class=\"math inline\">\\(y=x\\)</span> 的路径必定存在一个点经过 <span class=\"math inline\">\\(y=x+1\\)</span>，原问题转化为不能碰到 <span class=\"math inline\">\\(y=x+1\\)</span> 的方案数。</p>\n<p>把终点 <span class=\"math inline\">\\((n, n)\\)</span> 翻折到 <span class=\"math inline\">\\(y=x+1\\)</span> 上方，得到 <span class=\"math inline\">\\((n-1, n + 1)\\)</span>；对于任意到达 <span class=\"math inline\">\\((n-1,n+1)\\)</span> 的路径，一定会接触 <span class=\"math inline\">\\(y=x+1\\)</span> 至少一次；将第一次接触以后的路径翻折到 <span class=\"math inline\">\\(y=x+1\\)</span> 下方，则一定和原图中的非法路径一一对应。</p>\n<p><img src=\"4.png\" /></p>\n<p>就可以得到 <span class=\"math inline\">\\(C_{2n}^n-C_{2n}^{n-1}\\)</span>。</p>\n<p>如果问题变得更加一般，求解到达 <span class=\"math inline\">\\((n, m)\\)</span> 不能碰到 <span class=\"math inline\">\\(y=x+c\\)</span> 的方案数，还是可以把 <span class=\"math inline\">\\((n,m)\\)</span> 翻折到 <span class=\"math inline\">\\((m-c,n+c)\\)</span>，答案是 <span class=\"math inline\">\\(C_{n+m}^n-C_{n+m}^{m-c}\\)</span>。</p>\n<hr />\n<h2 id=\"不经过-yx-l-和-yxr-的方案数\">不经过 <span class=\"math inline\">\\(y=x-l\\)</span> 和 <span class=\"math inline\">\\(y=x+r\\)</span> 的方案数</h2>\n<p>现在有 <span class=\"math inline\">\\(y=x-l\\)</span> 和 <span class=\"math inline\">\\(y=x+r\\)</span> 两条线作为限制，现在的翻折意义就会有一点改变。</p>\n<p><img src=\"5.png\" /></p>\n<p>比如图中的 <span class=\"math inline\">\\(A&#39;\\)</span>，是 <span class=\"math inline\">\\(A\\)</span> 沿着 <span class=\"math inline\">\\(y=x-l\\)</span> 翻折一次后的结果。还是按照之前的方式来理解，那么走到 <span class=\"math inline\">\\(A&#39;\\)</span> 的路径代表至少经过一次 <span class=\"math inline\">\\(y=x-l\\)</span> 的方案。<span class=\"math inline\">\\(A&#39;&#39;\\)</span> 是 <span class=\"math inline\">\\(A&#39;\\)</span> 沿着 <span class=\"math inline\">\\(y=x+r\\)</span> 翻折一次之后得到的结果，走到 <span class=\"math inline\">\\(A&#39;&#39;\\)</span> 的路径就代表至少先碰到一次 <span class=\"math inline\">\\(y=x-l\\)</span>，再碰到一次 <span class=\"math inline\">\\(y=x+r\\)</span> 的方案数。</p>\n<p>如果把相邻多次碰到 <span class=\"math inline\">\\(y=x-l\\)</span> 或 <span class=\"math inline\">\\(y=x+r\\)</span> 合并为一次，最终的非法路径就是 <code>LRLRLR...</code> 或者 <code>RLRLRL...</code> 的形式。因为可以计算的是「至少」的形式，用容斥原理得到，答案是 <span class=\"math inline\">\\(f_{\\varnothing}-(f_{\\texttt L} + f_{\\texttt R}) + (f_{\\texttt {LR}} + f_{\\texttt {RL}}) - \\cdots\\)</span>。对应计算每个翻折对应终点和答案就可以了。最后的答案是 <span class=\"math inline\">\\(C_{n+m}^n-C_{n+m}^{n+l}-C_{n+m}^{n + r}+C_{n+m}^{n+l-r}+C_{n+m}^{n+r-l}-\\cdots\\)</span>，可以简化成 <span class=\"math inline\">\\(\\sum\\limits_{k\\in \\mathbb{Z}} C_{n+m}^{n-k\\cdot (r-l)}-C_{n+m}^{n-k\\cdot (r-l)+r}\\)</span>。</p>\n<hr />\n<h3 id=\"e---骗我呢\">E - 骗我呢</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P3266\" class=\"uri\">https://www.luogu.com.cn/problem/P3266</a></p>\n<p>每行内部递增，而且选项只有 <span class=\"math inline\">\\([0,m]\\)</span>，那么每行就会刚好在 <span class=\"math inline\">\\([0,m]\\)</span> 里面跳过一个数。</p>\n<p>如果第 <span class=\"math inline\">\\(i\\)</span> 行跳过的数是 <span class=\"math inline\">\\(j\\)</span>，那么画一画图就可以发现第 <span class=\"math inline\">\\(i+1\\)</span> 可能跳过的数是 <span class=\"math inline\">\\([j-1,m]\\)</span>；反过来，第 <span class=\"math inline\">\\(i-1\\)</span> 行可能跳过的数就是 <span class=\"math inline\">\\([0,j+1]\\)</span>。</p>\n<p>如果让 <span class=\"math inline\">\\(f_{i,j}\\)</span> 表示确定了第 <span class=\"math inline\">\\(1\\to i\\)</span> 行，其中第 <span class=\"math inline\">\\(i\\)</span> 行跳过 <span class=\"math inline\">\\(j\\)</span> 的方案数，就可以得到 <span class=\"math inline\">\\(f_{i,j}=\\sum\\limits_{k=0}^{j+1} f_{i-1,k}\\)</span>。前缀和得到 <span class=\"math inline\">\\(f_{i,j}=f_{i,j-1}+f_{i-1,j+1}\\)</span>。注意边界：<span class=\"math inline\">\\(f_{0,j}=1\\)</span>；<span class=\"math inline\">\\(f_{i,0}=f_{i-1,0}+f_{i-1,1}\\)</span>；<span class=\"math inline\">\\(f_{i,m}=f_{i,m-1}\\)</span>。</p>\n<p>为了得到答案，让 <span class=\"math inline\">\\(g_{i,j}\\)</span> 表示 <span class=\"math inline\">\\(i\\times j\\)</span> 矩阵的方案数（这样就有机会通过手段优化了）：</p>\n<p><span class=\"math display\">\\[\n\\begin{aligned}\ng_{i,j}&amp;=\\sum_{k=0}^j f_{i,k}\\\\\n&amp;= f_{i-1,0}+f_{i-1,1}+\\sum_{k=1}^j f_{i,k-1}+f_{i-1,k+1}\\\\\n&amp;= g_{i,j-1}+g_{i-1,j+1}\n\\end{aligned}\n\\]</span></p>\n<p>边界情况呢， <span class=\"math inline\">\\(g_{i, 0} = f_{i,0} = f_{i-1, 0} + f_{i - 1, 1} = g_{i-1,1}\\)</span>；<span class=\"math inline\">\\(g_{i,m}=g_{i, m - 1} + f_{i,m}=g_{i-1,m}+g_{i,m-1}\\)</span>。 <span class=\"math inline\">\\(g_{i,m+1}=g_{i,m}\\)</span> 避免边界。</p>\n<p>那么在网格图上转移如下：</p>\n<p><img src=\"2.png\" /></p>\n<p>考虑将这个图形拉正，令 <span class=\"math inline\">\\((i+i,j)\\gets g_{i,j}\\)</span> 得到：</p>\n<p><img src=\"3.png\" /></p>\n<p>问题就转化为，从 <span class=\"math inline\">\\((0, 0)\\)</span> 走到 <span class=\"math inline\">\\((m+n+1,n)\\)</span> 且不能触碰 <span class=\"math inline\">\\(y=x+1\\)</span> 和 <span class=\"math inline\">\\(y=x-m-2\\)</span> 两条直线的方案数。</p>\n<details>\n</details>\n<hr />\n<h2 id=\"不经过一般过原点直线的方案数\">不经过一般过原点直线的方案数</h2>\n<ol type=\"1\">\n<li><p>类型一：<span class=\"math inline\">\\((0,0)\\to (n,m)\\)</span>，不经过 <span class=\"math inline\">\\(y=\\dfrac mnx\\)</span> 的方案，其中要求 <span class=\"math inline\">\\((m,n)=1\\)</span>。</p>\n<p>方案为 <span class=\"math inline\">\\(\\dfrac {C_{n+m}^n}{n+m}\\)</span>。</p></li>\n</ol>\n",
            "tags": [
                "排列组合",
                "容斥原理",
                "数学"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20250407/",
            "url": "https://xsc062.netlify.app/20250407/",
            "title": "组合计数",
            "date_published": "2025-04-07T06:57:14.000Z",
            "content_html": "<p>毅毅：统计不是数学（断章取义 ed）。<del>故删掉了数学标签。</del> 其实并没有。</p>\n<span id=\"more\"></span>\n<hr />\n<h2 id=\"a.-二分图染色\">A. 二分图染色</h2>\n<p><a href=\"http://222.180.160.110:61235/contest/6181/problem/1\" class=\"uri\">http://222.180.160.110:61235/contest/6181/problem/1</a></p>\n<p>首先只看红色。显然一个左部点最多只能用红边连接一个右部点，反之同理。把左部点视为下标，其用红边相连的右部点视为值，则一个合法的方案为 <span class=\"math inline\">\\(n\\)</span> 的只保留一部分元素的排列。显然为 <span class=\"math inline\">\\(f(n)=\\sum\\limits_{i=0}^nC_n^i\\cdot A_n^i\\)</span>。</p>\n<p>再加上蓝色，<span class=\"math inline\">\\(f^2(n)\\)</span> 会给一条边涂两种颜色，故钦定有两种颜色的边数，容斥得到 <span class=\"math inline\">\\(\\sum\\limits_{i=0}^n(-1)^i\\cdot C_n^i\\cdot A_n^i\\cdot f^2(n-i)\\)</span>。发现 <span class=\"math inline\">\\(f\\)</span> 的计算可能需要优化一下。考虑已经知道 <span class=\"math inline\">\\(f(n-1)\\)</span>，此时对于新增的第 <span class=\"math inline\">\\(n\\)</span> 对点：</p>\n<ol type=\"1\">\n<li>任意连边（显然两个当中只能有一个点发出边），共有 <span class=\"math inline\">\\(2n-1\\)</span> 种方案，因为 <span class=\"math inline\">\\((n, n)\\)</span> 会被算重。</li>\n<li>不连，共 <span class=\"math inline\">\\(1\\)</span> 种方案。</li>\n<li>发现 1 中可能连到已经有连边的点上了，新边的目的地有 <span class=\"math inline\">\\(n-1\\)</span> 个选项，目的地原本连接的点也有 <span class=\"math inline\">\\(n-1\\)</span> 个选项，去掉两边共 <span class=\"math inline\">\\(4\\)</span> 个点，非法的即为 <span class=\"math inline\">\\((n-1)^2\\cdot f(n-2)\\)</span>。</li>\n</ol>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 1e9 + 7;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;long long&gt; f(n + 1), fac(n + 1), inv(n + 1);\n    f[0] = 1ll, f[1] = 2ll;\n    fac[0] = 1ll, fac[1] = 1ll, inv[0] = 1ll;\n    for (int i = 2; i &lt;= n; ++i) &#123;\n        fac[i] = fac[i - 1] * i % mod;\n        f[i] = (f[i - 1] * 2 * i % mod + mod - f[i - 2] * (i - 1) % mod * (i - 1) % mod) % mod;\n    &#125;\n    auto qkp = [](long long x, int y) &#123;\n        auto res = 1ll;\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    inv[n] = qkp(fac[n], mod - 2);\n    for (int i = n - 1; i; --i)\n        inv[i] = inv[i + 1] * (i + 1) % mod;\n    auto C = [&amp;](int n, int m) &#123;\n        return fac[n] * inv[n - m] % mod * inv[m] % mod;\n    &#125;;\n    auto A = [&amp;](int n, int m) &#123;\n        return fac[n] * inv[n - m] % mod;\n    &#125;;\n    long long res = 0ll;\n    for (int i = 0, k = 1; i &lt;= n; ++i, k = mod - k)\n        (res += k * C(n, i) % mod * A(n, i) % mod * f[n - i] % mod * f[n - i]) %= mod;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"b.-七选五\">B. 七选五</h2>\n<p><a href=\"http://222.180.160.110:61235/contest/6181/problem/2\" class=\"uri\">http://222.180.160.110:61235/contest/6181/problem/2</a></p>\n<p>首先 <span class=\"math inline\">\\(p\\)</span> 固定，钦定有 <span class=\"math inline\">\\(x\\)</span> 个数相等，有 <span class=\"math inline\">\\(C_k^x\\)</span> 个方案，剩下的就是从 <span class=\"math inline\">\\(n-x\\)</span> 个元素里选出 <span class=\"math inline\">\\(k-x\\)</span> 个来错排，考虑钦定相同的个数来容斥：</p>\n<p><span class=\"math display\">\\[\n\\sum_{i=0}^{k-x}(-1)^i\\cdot C_{k-x}^i\\cdot A_{n-x-i}^{k-x-i}\n\\]</span></p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 1e9 + 7;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, k, x;\n    std::cin &gt;&gt; n &gt;&gt; k &gt;&gt; x;\n    std::vector&lt;long long&gt; fac(n + 1), inv(n + 1);\n    fac[0] = 1ll, fac[1] = 1ll, inv[0] = 1ll;\n    for (int i = 2; i &lt;= n; ++i)\n        fac[i] = fac[i - 1] * i % mod;\n    auto qkp = [](long long x, int y) &#123;\n        auto res = 1ll;\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    inv[n] = qkp(fac[n], mod - 2);\n    for (int i = n - 1; i; --i)\n        inv[i] = inv[i + 1] * (i + 1) % mod;\n    auto C = [&amp;](int n, int m) &#123;\n        return fac[n] * inv[n - m] % mod * inv[m] % mod;\n    &#125;;\n    auto A = [&amp;](int n, int m) &#123;\n        return fac[n] * inv[n - m] % mod;\n    &#125;;\n    long long res = C(k, x), sum = 0ll;\n    for (int i = 0, p = 1; i &lt;= k - x; ++i, p = mod - p)\n        (sum += p * C(k - x, i) % mod * A(n - x - i, k - x - i) % mod) %= mod;\n    std::cout &lt;&lt; res * sum % mod &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"d.-硬币购物\">D. 硬币购物</h2>\n<p><a href=\"http://222.180.160.110:61235/contest/6181/problem/4\" class=\"uri\">http://222.180.160.110:61235/contest/6181/problem/4</a></p>\n<p>每次多重背包会超时，考虑用钦定每种硬币是否超额来容斥。令 <span class=\"math inline\">\\(f_s\\)</span> 表示凑出 <span class=\"math inline\">\\(s\\)</span> 的方案数（完全背包），那么 <span class=\"math inline\">\\(f_{s-c_1\\times (d_1 + 1)}\\)</span> 就表示钦定第 1 种硬币超额时凑出 <span class=\"math inline\">\\(s\\)</span> 的方案数，以此类推。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int c[4], T, m = 1e5;\n    std::vector&lt;long long&gt; f(m + 1);\n    f[0] = 1;\n    for (int i = 0; i &lt; 4; ++i) &#123;\n        std::cin &gt;&gt; c[i];\n        for (int j = c[i]; j &lt;= m; ++j)\n            f[j] += f[j - c[i]];\n    &#125;\n    std::cin &gt;&gt; T;\n    for (int d[4], m; T--; ) &#123;\n        for (int i = 0; i &lt; 4; ++i)\n            std::cin &gt;&gt; d[i];\n        std::cin &gt;&gt; m;\n        long long res = 0ll;\n        for (int i = 0; i &lt; (1 &lt;&lt; 4); ++i) &#123;\n            int s = m;\n            for (int j = 0; j &lt; 4; ++j)\n                if ((i &gt;&gt; j) &amp; 1)\n                    s -= (d[j] + 1) * c[j];\n            if (s &gt;= 0) &#123;\n                int k = (__builtin_popcount(i) &amp; 1) ? -1 : 1;\n                res += k * f[s];\n            &#125;\n        &#125;\n        std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"e.-distinct-multiples\">E. Distinct Multiples</h2>\n<p><a href=\"http://222.180.160.110:61235/contest/6181/problem/5\" class=\"uri\">http://222.180.160.110:61235/contest/6181/problem/5</a></p>\n<p>推式子题。题意转化为，给定 <span class=\"math inline\">\\(n\\)</span> 个位置可选的值集合，要求任意两个位置值不等，问方案数。</p>\n<p>如果把两个位置取等视作在团上选中边，那么有朴素做法钦定选边的集合 <span class=\"math inline\">\\(S\\)</span> 然后容斥，考虑它们构成的连通块 <span class=\"math inline\">\\(\\{s\\} \\subseteq S\\)</span>，有 <span class=\"math inline\">\\(res=\\sum\\limits_{S\\subseteq V}(-1)^{|S|}\\cdot \\prod\\limits_{s_i} \\left\\lfloor \\frac m{\\operatorname{lcm} s_i} \\right\\rfloor\\)</span>。</p>\n<p>有个很神奇的操作是把 <span class=\"math inline\">\\(S\\)</span> 丢掉，直接枚举 <span class=\"math inline\">\\(\\{s\\}\\)</span> 尝试子集 DP。有：<span class=\"math inline\">\\(res=\\sum\\limits_{\\{s\\}}\\prod\\limits_s f(s)\\cdot\\left\\lfloor \\frac m{\\operatorname{lcm} s} \\right\\rfloor\\)</span>。其中 <span class=\"math inline\">\\(f(s)\\)</span> 表示选取一个 <span class=\"math inline\">\\(s\\)</span> 的导出子图的容斥系数之和，其中次数为导出子图中边数。</p>\n<p>怎么把 <span class=\"math inline\">\\(f\\)</span> 算出来呢？容易发现其值只与 <span class=\"math inline\">\\(|s|\\)</span> 有关，考虑钦定与 <span class=\"math inline\">\\(1\\)</span> 连通的点数容斥，则有：</p>\n<p><span class=\"math display\">\\[\nf(n)=\\sum\\limits_{i=0}^{n - 1} (-1)^i \\times C_{n-1}^{i-1} \\times f(i) \\cdot \\sum_{j=0}^{m\\gets i\\times (i-1)\\div 2} (-1)^j\\cdot C_m^j\n\\]</span></p>\n<p>我们知道，二项式定理取 <span class=\"math inline\">\\(a=1, b = -1\\)</span> 有 <span class=\"math inline\">\\(0^m=[m=0]=\\sum_{j=0}^m(-1)^j\\cdot C_m^j\\)</span>，代入得：</p>\n<p><span class=\"math display\">\\[\n\\begin{aligned}\nf(n)&amp;=\\sum\\limits_{i=0}^{n - 1} (-1)^i \\times C_{n-1}^{n-i-1} \\times f(n-i)\\cdot [m=0\\iff i=1]\\\\\n&amp;=(1 - n)\\cdot f(n-1)\n\\end{aligned}\n\\]</span></p>\n<p>然后就能线性求出。再用一个子集 DP，为了保证顺序枚举最小的未被确定的点所在连通块进行转移。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 998244353;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, l;\n    long long m;\n    std::cin &gt;&gt; n &gt;&gt; m, l = 1 &lt;&lt; n;\n    std::vector&lt;long long&gt; d(n), f(n + 1), dp(l), g(l);\n    f[1] = 1ll;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; d[i - 1];\n        if (i &gt;= 2)\n            f[i] = (1 + mod - i) * f[i - 1] % mod;\n        // printf(&quot;f[%d] = %lld\\n&quot;, i, f[i]);\n    &#125;\n    for (int i = 0; i &lt; l; ++i) &#123;\n        long long now = 1ll;\n        for (int j = 0; j &lt; n; ++j)\n            if ((i &gt;&gt; j) &amp; 1) &#123;\n                if (now / std::__gcd(now, d[j]) &gt; m / d[j])\n                    goto nosol;\n                now = now / std::__gcd(now, d[j]) * d[j];\n            &#125;\n        g[i] = (m / now) % mod;\n        // printf(&quot;lcm = %lld, g[%d] = %lld\\n&quot;, now, i, g[i]);\n    nosol: ;\n    &#125;\n    dp[0] = 1ll;\n    auto lowbit = [](int x) &#123;\n        return x &amp; -x;\n    &#125;;\n    for (int i = 1; i &lt; l; ++i) &#123;\n        int to = std::__lg(lowbit(i));\n        for (int j = i; j; j = (j - 1) &amp; i)\n            if ((j &gt;&gt; to) &amp; 1)\n                (dp[i] += dp[i ^ j] * f[__builtin_popcount(j)] % mod * g[j] % mod) %= mod;\n    &#125;\n    std::cout &lt;&lt; dp[l - 1] &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"f.-permutation\">F. Permutation</h2>\n<p><a href=\"http://222.180.160.110:61235/contest/6181/problem/6\" class=\"uri\">http://222.180.160.110:61235/contest/6181/problem/6</a></p>\n<p>如果全是 <code>&lt;</code>，方案数为 <span class=\"math inline\">\\(1\\)</span>。</p>\n<p>现在把其中一些 <code>&lt;</code> 变成 <code>?</code>，比如 <code>&lt;&lt;??&lt;?&lt;&lt;&lt;&lt;</code> 的方案数，<del>太好了是多重集排列，我们没救了</del> 显然被 <code>&lt;</code> 连接起来的一段元素只有一种排列方式，所以可以视为多重集排列，方案数为 <span class=\"math inline\">\\(\\dfrac {11!}{3!\\times 2!\\times 5!}\\)</span>。</p>\n<p>似乎只需要枚举把 <code>&gt;</code> 变成 <code>&lt;</code> 或 <code>=</code> 的 <span class=\"math inline\">\\(2^k\\)</span> 种情况再计算就可以了，可惜 <span class=\"math inline\">\\(k\\)</span> 有点大。但我们发现它在一定程度上是没有后效性的，比如 <code>&lt;&lt;??&lt;</code> 和 <code>&lt;&lt;?&lt;&lt;</code>，前面的 <code>&lt;&lt;</code> 不会对后面的内容带来影响。</p>\n<p>故令 <span class=\"math inline\">\\(f_i\\)</span> 表示对于前 <span class=\"math inline\">\\(i\\)</span> 个元素的方案数，枚举最后一个被钦定为 <code>?</code> 的 <code>&gt;</code> <span class=\"math inline\">\\(j\\)</span>（即 <span class=\"math inline\">\\([j + 1, i-1]\\)</span> 间的 <code>&gt;</code> 都被替换为 <code>&lt;</code>），带上容斥系数，有 <span class=\"math inline\">\\(f_i=\\sum\\limits_{s_j=\\texttt{&#39;&gt;&#39;}}(-1)^{cnt_\\texttt{&#39;&gt;&#39;}[j + 1, i - 1]}\\times f_j\\times\\dfrac1{(i-j)!}\\)</span>。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 1e9 + 7;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;long long&gt; fac(n + 1), inv(n + 1);\n    fac[0] = 1ll, inv[0] = 1ll;\n    for (int i = 1; i &lt;= n; ++i)\n        fac[i] = fac[i - 1] * i % mod;\n    auto qkp = [](long long x, int y) &#123;\n        auto res = 1ll;\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    inv[n] = qkp(fac[n], mod - 2);\n    for (int i = n - 1; i; --i)\n        inv[i] = inv[i + 1] * (i + 1) % mod;\n    std::vector&lt;char&gt; s(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; s[i];\n    std::vector&lt;long long&gt; f(n + 1);\n    s[0] = &#39;&gt;&#39;, f[0] = 1ll;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        int cnt = 0;\n        for (int j = i - 1; ~j; --j)\n            if (s[j] == &#39;&gt;&#39;) &#123;\n                long long k = (cnt &amp; 1) ? mod - 1 : 1;\n                (k *= f[j]) %= mod, (k *= inv[i - j]) %= mod;\n                (f[i] += k) %= mod;\n                ++cnt;\n            &#125;\n        // printf(&quot;f[%d] = %lld\\n&quot;, i, f[i]);\n    &#125;\n    std::cout &lt;&lt; f[n] * fac[n] % mod &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<p><em>忳郁邑余侘傺兮，余独穷困乎此时也。</em></p>\n<hr />\n<h2 id=\"h.-k-perm-counting\">H. ~K Perm Counting</h2>\n<p><a href=\"http://222.180.160.110:61235/contest/6181/problem/8\" class=\"uri\">http://222.180.160.110:61235/contest/6181/problem/8</a></p>\n<p>考虑钦定令几个元素不满足条件进行容斥，即答案为 <span class=\"math inline\">\\(\\sum\\limits_{i=0}^n (-1)^i\\cdot f(i)\\)</span>。但我们发现 <span class=\"math inline\">\\([n-k,n+k]\\)</span> 都有两个不能选的值，直接取 <span class=\"math inline\">\\(f(i)=\\prod 2\\)</span> 肯定会选到相同值，一个自然（？）的想法是再容斥一遍，可惜手玩一下发现似乎容不动。考虑把玩意儿拍在棋盘上：</p>\n<figure>\n<img src=\"1.png\" alt=\"以 k=2 为例\" /><figcaption>以 <span class=\"math inline\">\\(k=2\\)</span> 为例</figcaption>\n</figure>\n<p>其中 <span class=\"math inline\">\\(\\times\\)</span> 是非法格子，边是非法格子间的不同选关系，同颜色的边隶属同一条链。容易发现如果棋盘继续扩大，这些链还会继续延长。</p>\n<p>会发现这些链互不干扰，就是说我选了这条链上的某个点和链外的点没有任何关系（显然）。把这些链首尾相连拼起来，要做的就是拼接处可以选相邻，其余位置不能选相邻，选出来 <span class=\"math inline\">\\(i\\)</span> 个的方案数。提前预处理出来整个序列，令 <span class=\"math inline\">\\(tag_j\\)</span> 表示 <span class=\"math inline\">\\(j\\)</span> 是否能和 <span class=\"math inline\">\\(j-1\\)</span> 同选，设 <span class=\"math inline\">\\(dp_{j,i,0/1}\\)</span> 表示 DP 到了 <span class=\"math inline\">\\(j\\)</span>，已经选了 <span class=\"math inline\">\\(i\\)</span> 个数，第 <span class=\"math inline\">\\(j\\)</span> 个元素（不）选的方案数，那么有：</p>\n<p><span class=\"math display\">\\[\ndp_{j,i,0} = dp_{j - 1, i, 0} + dp_{j-1, i, 1}\\\\\ndp_{j,i,1} = \\begin{cases}\ndp_{j-1, i - 1, 1} + dp_{j-1,i - 1,0}&amp;tag_j=1\n\\\\\ndp_{j-1,i,0}&amp;\\text{otherwise}\n\\end{cases}\n\\]</span></p>\n<p>大力 DP 即可。<span class=\"math inline\">\\(f(i)\\)</span> 即为 <span class=\"math inline\">\\((n-i)!\\times (dp_{m, i, 0} + dp_{m, i, 1})\\)</span>，其中 <span class=\"math inline\">\\(m\\)</span> 为总链长。</p>\n<details>\n<p>注意不滚动可能会 MLE <img src=\"/em/kt.gif\" /></p>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 924844033;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, k;\n    std::cin &gt;&gt; n &gt;&gt; k;\n    std::vector&lt;int&gt; tag(1);\n    std::vector&lt;long long&gt; fac(n + 1);\n    std::vector&lt;std::vector&lt;int&gt; &gt; vis(n + 1, std::vector&lt;int&gt; (n + 1));\n    auto calc = [&amp;](int i, int j, int s) &#123;\n        tag.push_back(1);\n        for (; ; s ^= 1) &#123;\n            // printf(&quot;(%d, %d) &quot;, i, j);\n            vis[i][j] = 1;\n            if (!s) &#123;\n                i = j + k;\n                if (i &lt;= n)\n                    tag.push_back(0);\n                else\n                    break;\n            &#125;\n            else &#123;\n                j = i + k;\n                if (j &lt;= n)\n                    tag.push_back(0);\n                else\n                    break;\n            &#125;\n        &#125;\n        // puts(&quot;&quot;);\n        return;\n    &#125;;\n    fac[0] = 1ll;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        fac[i] = fac[i - 1] * i % mod;\n        int j = i - k;\n        if (j &gt;= 1 &amp;&amp; !vis[i][j])\n            calc(i, j, 1);\n        j = i + k;\n        if (j &lt;= n &amp;&amp; !vis[i][j])\n            calc(i, j, 0);\n    &#125;\n    int m = (int)tag.size() - 1;\n    // printf(&quot;m = %d\\n&quot;, m);\n    std::vector&lt;std::vector&lt;std::vector&lt;long long&gt; &gt; &gt; dp(2, std::vector&lt;std::vector&lt;long long&gt; &gt; (n + 1, std::vector&lt;long long&gt; (2)));\n    dp[0][0][0] = 1ll;\n    for (int j = 1, now = 1; j &lt;= m; ++j, now ^= 1) &#123;\n        for (int i = 0; i &lt;= n &amp;&amp; i &lt;= j; ++i) &#123;\n            dp[now][i][0] = dp[!now][i][0];\n            dp[now][i][1] = 0ll;\n            if (i) &#123;\n                (dp[now][i][0] += dp[!now][i][1]) %= mod;\n                dp[now][i][1] = dp[!now][i - 1][0];\n                if (tag[j]) &#123;\n                    (dp[now][i][1] += dp[!now][i - 1][1]) %= mod;\n                    // assert(0);\n                &#125;\n            &#125;\n            // printf(&quot;dp[%d][%d] = %lld / %lld\\n&quot;, j, i, dp[j][i][0], dp[j][i][1]);\n        &#125;\n    &#125;\n    long long res = 0ll;\n    for (int i = 0, p = 1; i &lt;= n; ++i, p = mod - p)\n        (res += p * fac[n - i] % mod * (dp[m &amp; 1][i][0] + dp[m &amp; 1][i][1]) % mod) %= mod;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"a---positions-in-permutations\">A - Positions in Permutations</h2>\n<p><a href=\"https://codeforces.com/problemset/problem/285/E\" class=\"uri\">https://codeforces.com/problemset/problem/285/E</a></p>\n<p><del>（看向上一题）这照片是你吗？</del></p>\n<p>在上一题的基础上，令 <span class=\"math inline\">\\(k=1\\)</span>。但是有个小小的问题——所求的「至少」不为 <span class=\"math inline\">\\(0\\)</span>，无法简单容斥。具体地，如果一个排列一共有 <span class=\"math inline\">\\(p\\)</span> 个非法排列，那么它会被 <span class=\"math inline\">\\(f(i)\\)</span> 统计 <span class=\"math inline\">\\(C_p^i\\)</span> 次。令 <span class=\"math inline\">\\(g(p)\\)</span> 表示非法格子数恰好为 <span class=\"math inline\">\\(p\\)</span> 的排列的真实数量，则 <span class=\"math inline\">\\(f(i)=\\sum\\limits_{j=i}^n C_j^i\\cdot g(j)\\)</span>，二项式反演即可得到真实值 <span class=\"math inline\">\\(g(m)=\\sum\\limits_{j=m}^n (-1)^{j-m}\\cdot C_j^m\\cdot f(j)\\)</span>。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 1e9 + 7;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, k;\n    std::cin &gt;&gt; n &gt;&gt; k;\n    std::vector&lt;int&gt; tag(1);\n    std::vector&lt;long long&gt; fac(n + 1), inv(n + 1);\n    std::vector&lt;std::vector&lt;int&gt; &gt; vis(n + 1, std::vector&lt;int&gt; (n + 1));\n    auto calc = [&amp;](int i, int j, int s) &#123;\n        tag.push_back(1);\n        for (; i &lt;= n &amp;&amp; j &lt;= n; s ^= 1) &#123;\n            vis[i][j] = 1;\n            if (!s) &#123;\n                i = j + 1;\n                if (i &lt;= n)\n                    tag.push_back(0);\n            &#125;\n            else &#123;\n                j = i + 1;\n                if (j &lt;= n)\n                    tag.push_back(0);\n            &#125;\n        &#125;\n        return;\n    &#125;;\n    auto qkp = [&amp;](long long x, int y) &#123;\n        auto res = 1ll;\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    fac[0] = 1ll, inv[0] = 1ll;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        fac[i] = fac[i - 1] * i % mod;\n        int j = i - 1;\n        if (j &gt;= 1 &amp;&amp; !vis[i][j])\n            calc(i, j, 1);\n        j = i + 1;\n        if (j &lt;= n &amp;&amp; !vis[i][j])\n            calc(i, j, 0);\n    &#125;\n    inv[n] = qkp(fac[n], mod - 2);\n    for (int i = n - 1; i; --i)\n        inv[i] = inv[i + 1] * (i + 1) % mod;\n    int m = (int)tag.size() - 1;\n    std::vector&lt;std::vector&lt;std::vector&lt;long long&gt; &gt; &gt; dp(2, std::vector&lt;std::vector&lt;long long&gt; &gt; (n + 1, std::vector&lt;long long&gt; (2)));\n    dp[0][0][0] = 1ll;\n    for (int j = 1, now = 1; j &lt;= m; ++j, now ^= 1) &#123;\n        for (int i = 0; i &lt;= n &amp;&amp; i &lt;= j; ++i) &#123;\n            dp[now][i][0] = dp[!now][i][0];\n            dp[now][i][1] = 0ll;\n            if (i) &#123;\n                (dp[now][i][0] += dp[!now][i][1]) %= mod;\n                dp[now][i][1] = dp[!now][i - 1][0];\n                if (tag[j])\n                    (dp[now][i][1] += dp[!now][i - 1][1]) %= mod;\n            &#125;\n        &#125;\n    &#125;\n    auto C = [&amp;](int n, int m) &#123;\n        return fac[n] * inv[n - m] % mod * inv[m] % mod;\n    &#125;;\n    long long res = 0ll;\n    for (int i = k, p = 1; i &lt;= n; ++i, p = mod - p) &#123;\n        // printf(&quot;%d: %lld\\n&quot;, i, C(i, k) * fac[n - i] % mod * (dp[m &amp; 1][i][0] + dp[m &amp; 1][i][1]) % mod);\n        (res += p * C(i, k) % mod * fac[n - i] % mod * (dp[m &amp; 1][i][0] + dp[m &amp; 1][i][1]) % mod) %= mod;\n    &#125;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"d---all-pairs-similarity-p\">D - All Pairs Similarity P</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P11458\" class=\"uri\">https://www.luogu.com.cn/problem/P11458</a></p>\n<p>省流：求 <span class=\"math inline\">\\(\\forall\\,i,f_i=\\sum\\limits_{j=1}^n \\dfrac{|a_i\\cap a_j|}{|a_i\\cup a_j|}\\)</span>。</p>\n<p>首先分离常数，有：</p>\n<p><span class=\"math display\">\\[\n\\begin{aligned}\nf_i&amp;=\\sum\\limits_{j=1}^n \\dfrac{|a_i\\cap a_j|}{|a_i\\cup a_j|}\\\\\n&amp;=\\sum_{j=1}^n\\dfrac {|a_i|+|a_j|-|a_i\\cup a_j|}{|a_i\\cup a_j|}\\\\\n&amp;=\\sum_{j=1}^n \\dfrac {|a_i|+|a_j|}{|a_i\\cup a_j|}-1\n\\end{aligned}\n\\]</span></p>\n<p>尽量把分子变得更简：</p>\n<p><span class=\"math display\">\\[\n\\begin{aligned}\nf_i&amp;=\\sum_{j=1}^n \\dfrac {|a_i|+|a_j|}{|a_i\\cup a_j|}-1\\\\\n&amp;=|a_i|\\cdot\\left(\\sum_{j=1}^n\\dfrac 1{|a_i\\cup a_j|}\\right)-n+\\sum_{j=1}^n \\dfrac {|a_j|}{|a_i\\cup a_j|}\n\\end{aligned}\n\\]</span></p>\n<p>问题转化为求解 <span class=\"math inline\">\\(\\sum\\limits_{j=1}^n\\dfrac 1{|a_i\\cup a_j|}\\)</span> 和 <span class=\"math inline\">\\(\\sum\\limits_{j=1}^n\\dfrac {|a_j|}{|a_i\\cup a_j|}\\)</span>，以 <span class=\"math inline\">\\(*=\\sum\\limits_{j=1}^n\\dfrac 1{|a_i\\cup a_j|}\\)</span> 为例。令 <span class=\"math inline\">\\(b_i\\)</span> 为 <span class=\"math inline\">\\(a_i\\)</span> 补集，则：</p>\n<p><span class=\"math display\">\\[\n\\begin{aligned}\n*&amp;=\\sum\\limits_{j=1}^n\\dfrac 1{|a_i\\cup a_j|}\\\\\n&amp;=\\sum_{j=1}^n\\dfrac 1{k-|b_i\\cap b_j|}\n\\end{aligned}\n\\]</span></p>\n<p>为什么要做这个转换呢？相比起并集运算，交集运算有着优秀的性质：<span class=\"math inline\">\\(s\\subseteq(b_i\\cap b_j)\\iff s\\subseteq b_i\\land s\\subseteq b_j\\)</span>，<del>直接取或当然也有相似的性质，但是太烧脑了</del>。</p>\n<p>基于这个性质，我们有一个想法：对于所有 <span class=\"math inline\">\\(j\\)</span>，在 <span class=\"math inline\">\\(\\forall \\, s\\subseteq b_j\\)</span> 处放置 <span class=\"math inline\">\\(\\dfrac 1{k-|s|}\\)</span> 的贡献；对于 <span class=\"math inline\">\\(i\\)</span>，将 <span class=\"math inline\">\\(\\forall \\, s\\subseteq b_i\\)</span> 处的贡献求和。但是这样肯定会拿到很多我们不想要的贡献，例如 <span class=\"math inline\">\\(\\forall \\, s\\subset (b_i\\cap b_j)\\)</span>。</p>\n<p>考虑精细布置贡献——构造 <span class=\"math inline\">\\(g(|s|)\\)</span> 满足 <span class=\"math inline\">\\(\\sum\\limits_{j=1}^n\\sum\\limits_{s\\subseteq b_j}g(|s|)=*\\)</span>。</p>\n<p>这里可以二项式反演得到 <span class=\"math inline\">\\(g\\)</span>，具体地，令 <span class=\"math inline\">\\(F(|S|)=\\dfrac 1{k-|S|}=\\sum\\limits_{s\\subseteq S}g(|s|)=\\sum\\limits_{j=0}^{|S|} C_{|S|}^j g(j)\\)</span>，则 <span class=\"math inline\">\\(g(i)=\\sum\\limits_{j=0}^iC_i^j\\cdot \\dfrac {(-1)^{i-j}}{k-j}\\)</span>。</p>\n<p>再令 <span class=\"math inline\">\\(h(s)=\\sum\\limits_{b_j\\supseteq s}g(|s|)=g(|s|)\\cdot \\sum\\limits_{b_j\\supseteq s}1\\)</span>，那么 <span class=\"math inline\">\\(h\\)</span> 就是高维后缀和。我们正在做的事情就是求解 <span class=\"math inline\">\\(*=\\sum\\limits_{s\\subseteq b_i}h(s)\\)</span>，这就又是一个高维前缀和了。</p>\n<p>对于 <span class=\"math inline\">\\(\\sum\\limits_{j=1}^n\\dfrac {|a_j|}{|a_i\\cup a_j|}\\)</span> 呢，令 <span class=\"math inline\">\\(h(s)=\\sum\\limits_{b_j\\supseteq s}g(|s|)\\cdot {\\color{red}{|a_j|}} = g(|s|) \\cdot \\sum\\limits_{b_j\\supseteq s} \\color{red}{k - |b_j|}\\)</span>，改变高维后缀和求和对象即可。</p>\n<p>复杂度就是 <span class=\"math inline\">\\(O(n+k\\cdot 2^k)\\)</span>，其中 <span class=\"math inline\">\\(k\\cdot 2^k\\)</span> 来自整体高维前 / 后缀和，<span class=\"math inline\">\\(n\\cdot k\\)</span> 来自枚举 <span class=\"math inline\">\\(i\\)</span>。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 1e9 + 7;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, k, l;\n    std::cin &gt;&gt; n &gt;&gt; k, l = 1 &lt;&lt; k;\n    std::vector&lt;int&gt; a(n + 1), b(n + 1), cnt(l);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; a[i], b[i] = (l - 1) ^ a[i];\n        ++cnt[b[i]];\n    &#125;\n    std::vector&lt;long long&gt; g(k + 1), fac(k + 1);\n    auto qkp = [&amp;](long long x, int y = mod - 2) &#123;\n        auto res = 1ll;\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    auto C = [&amp;](int n, int m) &#123;\n        return fac[n] * qkp(fac[n - m]) % mod * qkp(fac[m]) % mod;\n    &#125;;\n    fac[0] = 1ll;\n    for (int i = 1; i &lt;= k; ++i)\n        fac[i] = fac[i - 1] * i % mod;\n    for (int i = 0; i &lt;= k; ++i) &#123;\n        for (int j = 0, p = (i &amp; 1) ? mod - 1 : 1; j &lt;= i; ++j, p = mod - p)\n            (g[i] += C(i, j) * p % mod * qkp(k - j) % mod) %= mod;\n        // printf(&quot;g[%d] = %lld\\n&quot;, i, g[i]);\n    &#125;\n    // for (int i = 0; i &lt;= k; ++i) &#123;\n    //     long long F = 0ll;\n    //     for (int j = 0; j &lt;= i; ++j)\n    //         (F += C(i, j) * g[j] % mod) %= mod;\n    //     printf(&quot;%d: %lld / %lld\\n&quot;, i, F, qkp(k - i));\n    // &#125;\n    std::vector&lt;long long&gt; h(l);\n    std::copy(cnt.begin(), cnt.end(), h.begin());\n    for (int i = 0; i &lt; k; ++i)\n        for (int j = l - 1; ~j; --j)\n            if (!((j &gt;&gt; i) &amp; 1))\n                (h[j] += h[j ^ (1 &lt;&lt; i)]) %= mod;\n    auto f1(h);\n    for (int i = 0; i &lt; l; ++i)\n        (f1[i] *= g[__builtin_popcount(i)]) %= mod;\n    for (int i = 0; i &lt; k; ++i)\n        for (int j = 0; j &lt; l; ++j)\n            if ((j &gt;&gt; i) &amp; 1)\n                (f1[j] += f1[j ^ (1 &lt;&lt; i)]) %= mod;\n    for (int i = 0; i &lt; l; ++i)\n        h[i] = cnt[i] * (k - __builtin_popcount(i));\n    for (int i = 0; i &lt; k; ++i)\n        for (int j = l - 1; ~j; --j)\n            if (!((j &gt;&gt; i) &amp; 1))\n                (h[j] += h[j ^ (1 &lt;&lt; i)]) %= mod;\n    auto f2(h);\n    for (int i = 0; i &lt; l; ++i)\n        (f2[i] *= g[__builtin_popcount(i)]) %= mod;\n    for (int i = 0; i &lt; k; ++i)\n        for (int j = 0; j &lt; l; ++j)\n            if ((j &gt;&gt; i) &amp; 1)\n                (f2[j] += f2[j ^ (1 &lt;&lt; i)]) %= mod;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        // fprintf(stderr, &quot;%d: %d * %lld - %d + %lld\\n&quot;, i, __builtin_popcount(a[i]), f1[b[i]], n, f2[b[i]]);\n        std::cout &lt;&lt; (__builtin_popcount(a[i]) * f1[b[i]] % mod + mod - n + f2[b[i]]) % mod &lt;&lt; &#39;\\n&#39;;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"e---prefix-xors\">E - Prefix XORs</h2>\n<p><a href=\"https://atcoder.jp/contests/arc137/tasks/arc137_d\" class=\"uri\">https://atcoder.jp/contests/arc137/tasks/arc137_d</a></p>\n<p>省流：做 <span class=\"math inline\">\\(k\\)</span> 次前缀和，<span class=\"math inline\">\\(k=1,2,\\cdots,m\\)</span>，分别询问：令 <span class=\"math inline\">\\(x_i\\gets a_i\\)</span> 对 <span class=\"math inline\">\\(s_n\\)</span> 的贡献次数，则 <span class=\"math inline\">\\(\\sum a_i\\cdot (x_i\\bmod 2)\\)</span>？</p>\n<p>对于 <span class=\"math inline\">\\(a_p\\)</span>，容易发现第一轮其对任意 <span class=\"math inline\">\\(s_q\\)</span> 有 <span class=\"math inline\">\\(1\\)</span> 次贡献，拉开来就是常数列；第二轮有 <span class=\"math inline\">\\((q-p+1)\\)</span> 次贡献，是公差为 <span class=\"math inline\">\\(1\\)</span> 的等差数列；第三轮是类三角形数——至此，肯定和组合数有关了。手玩可以发现第 <span class=\"math inline\">\\(k\\)</span> 轮 <span class=\"math inline\">\\(a_p\\)</span> 对 <span class=\"math inline\">\\(s_n\\)</span> 的贡献为 <span class=\"math inline\">\\(C_{n-p+(k-2)}^{n-p}\\)</span>，尽量令其中一个不动，得到 <span class=\"math inline\">\\(C_{n-p+(k-2)}^{k-1}\\)</span>。</p>\n<p>但是我们发现直接枚举每轮每个数会起飞，而且模数为 <span class=\"math inline\">\\(2\\)</span> 似乎只能 Lucas（再带个 <span class=\"math inline\">\\(\\log\\)</span>），怎么办呢？</p>\n<p>那就 Lucas 呗。由其观察容易发现 <span class=\"math inline\">\\(C_{n-p+(k-2)}^{k-2}\\bmod2=1\\)</span> 当且仅当 <span class=\"math inline\">\\((k-2)\\subseteq (n-p+k-2)\\iff (k-2)\\subseteq \\complement_U(n-p)\\)</span>，故问题转化为高维后缀和，<del>当然你也可以做一次 and-FWT</del>，那么 <span class=\"math inline\">\\(res_k=\\sum (C_{n-p+(k-2)}^{k-2}\\bmod 2)\\cdot a_p=S_{k-2}\\)</span>，其中 <span class=\"math inline\">\\(S\\)</span> 为高维后缀和，初值为 <span class=\"math inline\">\\(S_{\\complement_u(n-i)}\\gets a_i\\)</span>。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, m, l, k;\n    std::cin &gt;&gt; n &gt;&gt; m, k = std::__lg(n + m) + 1, l = 1 &lt;&lt; k;\n    std::vector&lt;int&gt; s(l);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; s[l - 1 - (n - i)];\n    for (int i = 0; i &lt; k; ++i)\n        for (int j = l - 1; ~j; --j)\n            if (!((j &gt;&gt; i) &amp; 1))\n                s[j] ^= s[j ^ (1 &lt;&lt; i)];\n    for (int i = 1; i &lt;= m; ++i)\n        std::cout &lt;&lt; s[i - 1] &lt;&lt; &#39; &#39;;\n    std::cout &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"b---the-top-scorer\">B - The Top Scorer</h2>\n<p><a href=\"https://codeforces.com/problemset/problem/1096/E\" class=\"uri\">https://codeforces.com/problemset/problem/1096/E</a></p>\n<p>鉴于每种方案等概率（翻译没说，但原题面有提到），考虑计算小明能够取胜的方案数，再对总方案数做除法。先枚举最高分 <span class=\"math inline\">\\(k\\ge r\\)</span>，再枚举包括小明在内恰有 <span class=\"math inline\">\\(c\\ge 1\\)</span> 个人 拿到 <span class=\"math inline\">\\(k\\)</span> 分。但剩下的人呢？显然是不能插板随机分配的，因为存在 <span class=\"math inline\">\\(&lt;k\\)</span> 的限制。</p>\n<p>考虑容斥，钦定剩下的 <span class=\"math inline\">\\(p-c\\)</span> 个人中拿到 <span class=\"math inline\">\\(\\ge k\\)</span> 分的人数后再可空地插板即可，则总方案数为：</p>\n<p><span class=\"math display\">\\[\n\\sum_{k=r}^s\\sum_{c=1}^p\\dfrac {C_{p - 1}^{c-1}}c\\cdot \\sum_{i=0}^{p-c}C_{p-c}^i\\cdot C_{s-k\\cdot (c+i)+(p-c-1)}^{p-c-1}\n\\]</span></p>\n<p>其中分母上的 <span class=\"math inline\">\\(c\\)</span> 来源于等概率分配给最高分，虽然不是整数，但也代表着「小明获胜可行方案数」。最后将答案除上总方案数 <span class=\"math inline\">\\(C_{s-r+p-1}^{p-1}\\)</span> 即可。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 998244353;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int p, s, r;\n    std::cin &gt;&gt; p &gt;&gt; s &gt;&gt; r;\n    std::vector&lt;long long&gt; fac(s + p), inv(s + p);\n    fac[0] = inv[0] = 1ll;\n    for (int i = 1; i &lt; s + p; ++i) &#123;\n        fac[i] = fac[i - 1] * i % mod;\n    &#125;\n    auto qkp = [&amp;](long long x, int y) &#123;\n        auto res = 1ll;\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    inv.back() = qkp(fac.back(), mod - 2);\n    for (int i = s + p - 2; i &gt; 0; --i)\n        inv[i] = inv[i + 1] * (i + 1) % mod;\n    auto C = [&amp;](int n, int m) &#123;\n        if (n == -1 &amp;&amp; m == -1)\n            return 1ll;\n        return fac[n] * inv[n - m] % mod * inv[m] % mod;\n    &#125;;\n    auto res(0ll);\n    for (int k = r; k &lt;= s; ++k)\n        for (int c = 1; c &lt;= p; ++c)\n            if ((p - c) * (k - 1) + c * k &gt;= s) &#123;\n                auto t(0ll);\n                for (int i = 0, now = 1; i &lt;= p - c &amp;&amp; k * (c + i) &lt;= s; ++i, now = mod - now)\n                    (t += now * C(p - c, i) % mod * C(s - k * (c + i) + (p - c - 1), p - c - 1) % mod) %= mod;\n                (res += C(p - 1, c - 1) * qkp(c, mod - 2) % mod * t % mod) %= mod;\n            &#125;\n    std::cout &lt;&lt; res * qkp(C(s - r + p - 1, p - 1), mod - 2) % mod &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"c---sky-full-of-stars\">C - Sky Full of Stars</h2>\n<p><a href=\"https://codeforces.com/problemset/problem/997/C\" class=\"uri\">https://codeforces.com/problemset/problem/997/C</a></p>\n<p>发现用 <span class=\"math inline\">\\(3^{n\\times n}\\)</span> 减去任意一行一列不同色的方案就是答案。</p>\n<p>考虑一元容斥，如令 <span class=\"math inline\">\\(f_i\\)</span> 表示至少 <span class=\"math inline\">\\(i\\)</span> 行 <span class=\"math inline\">\\(i\\)</span> 列同色的方案，但会发现 <span class=\"math inline\">\\(f_0\\)</span> 中包含 <span class=\"math inline\">\\(0\\)</span> 行 <span class=\"math inline\">\\(1\\)</span> 列同色等与预期不符的情况。受此启发考虑令 <span class=\"math inline\">\\(f_{i,j}\\)</span> 表示至少 <span class=\"math inline\">\\(i\\)</span> 行 <span class=\"math inline\">\\(j\\)</span> 列同色进行二元容斥。容易发现当 <span class=\"math inline\">\\(i\\times j\\ne 0\\)</span> 时，被选中的 <span class=\"math inline\">\\(i\\)</span> 行 <span class=\"math inline\">\\(j\\)</span> 列全部连通，应为同一种颜色；将它们挪到角落，可以发现未被选中的格子共有 <span class=\"math inline\">\\((n-i)\\times (n-j)\\)</span> 个。故有：</p>\n<p><span class=\"math display\">\\[\nf_{i,j}=\\begin{cases}\nC_n^j\\times 3^j\\times 3^{n\\times(n - j)}&amp;i=0\\\\\nC_n^i\\times 3^i\\times 3^{n\\times(n-i)}&amp;j=0\\\\\nC_n^i\\times C_n^j\\times 3\\times 3^{(n-i)\\times (n-j)}&amp;\\text{otherwise}\n\\end{cases}\n\\]</span></p>\n<p>令 <span class=\"math inline\">\\(g_{i,j}\\)</span> 表示恰好 <span class=\"math inline\">\\(i\\)</span> 行 <span class=\"math inline\">\\(j\\)</span> 列同色的方案数，那么答案为 <span class=\"math inline\">\\(3^{n\\times n}-g_{0,0}\\)</span>。二项式反演 / 容斥原理得 <span class=\"math inline\">\\(g_{0,0}=\\sum\\limits_{i=0}^n\\sum\\limits_{j=0}^n (-1)^{i+j}\\cdot f_{i,j}\\)</span>。很惊讶地发现这是 <span class=\"math inline\">\\(O(n^2)\\)</span> 的！考虑优化。把 <span class=\"math inline\">\\(f_{1\\to n,1\\to n}\\)</span> 合并同类项，得到：</p>\n<p><span class=\"math display\">\\[\n\\begin{aligned}\ng_{0, 0}\n&amp;=\\left[\\sum_{j=0}^n (-1)^j\\cdot f_{0,j}\\right]+\\sum_{i=1}^n (-1)^i\\cdot f_{i,0}+\\sum_{j=1}^n (-1)^{i+j}\\cdot C_n^i\\times C_n^j\\times 3^{(n-i)\\times (n-j)+1}\\\\\n&amp;=\\left[\\sum_{j=0}^n (-1)^j\\cdot f_{0,j}\\right]+\\sum_{i=1}^n (-1)^i\\cdot f_{i,0}+(-1)^i\\cdot C_n^i\\times 3^{n^2-n\\times i+1}\\times\\sum_{j=1}^n (-1)^j\\cdot C_n^j\\times 3^{j\\times(-n+i)}\\\\\n&amp;=\\left[\\sum_{j=0}^n (-1)^j\\cdot f_{0,j}\\right]+\\sum_{i=1}^n (-1)^i\\cdot f_{i,0}+(-1)^i\\cdot C_n^i\\times 3^{n^2-n\\times i+1}\\times\\left[\\left(\\sum_{j=0}^n (-1)^j\\cdot C_n^j\\times (3^{-n+i})^j\\right)-1\\right]\\\\\n&amp;=\\left[\\sum_{j=0}^n (-1)^j\\cdot f_{0,j}\\right]+\\sum_{i=1}^n (-1)^i\\cdot f_{i,0}+(-1)^i\\cdot C_n^i\\times 3^{n^2-n\\times i+1}\\times\\left[(-3^{-n+i}+1)^n-1\\right]\n\\end{aligned}\n\\]</span></p>\n<p>由此便可 <span class=\"math inline\">\\(O(n\\log n)\\)</span> 计算。担心超时可以把所有 <span class=\"math inline\">\\(3^{-n+i}\\)</span> 和 <span class=\"math inline\">\\(3^{n\\times i}\\)</span> 线性预处理出来，复杂度不会变就是了。</p>\n<p>这里解释一下最后一步的二项式定理，非常遗憾地发现 <span class=\"math inline\">\\(-1\\)</span> 和 <span class=\"math inline\">\\(3^{-n+i}\\)</span> 都是 <span class=\"math inline\">\\(j\\)</span> 次的，没办法把二者相加减做二项式定理；但由于次数相同，这提示我们可以把 <span class=\"math inline\">\\(-1\\)</span> 乘到 <span class=\"math inline\">\\(3^{-n+i}\\)</span> 里去，给每一项配上 <span class=\"math inline\">\\(1^{n-k}\\)</span> 就可以做 <span class=\"math inline\">\\(-3^{n-i}\\)</span>（注意不是 <span class=\"math inline\">\\((-3)^{n-i}\\)</span>） 和 <span class=\"math inline\">\\(1\\)</span> 的二项式定理。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 998244353;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    long long n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;long long&gt; fac(n + 1), inv(n + 1), invn(n + 1), invi(n + 1), powi(n + 1), pown(n + 1);\n    auto qkp = [&amp;](long long x, long long y) &#123;\n        auto res(1ll);\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    const long long pnn = qkp(3ll, n * n), pn = qkp(3ll, n);\n    fac[0] = inv[0] = invn[0] = invi[0] = powi[0] = pown[0] = 1ll;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        fac[i] = fac[i - 1] * i % mod;\n        powi[i] = powi[i - 1] * 3 % mod;\n        pown[i] = pown[i - 1] * pn % mod;\n    &#125;\n    inv[n] = qkp(fac[n], mod - 2);\n    invi[n] = qkp(powi[n], mod - 2);\n    invn[n] = qkp(pown[n], mod - 2);\n    for (int i = n - 1; i; --i) &#123;\n        inv[i] = inv[i + 1] * (i + 1) % mod;\n        invi[i] = invi[i + 1] * 3 % mod;\n        invn[i] = invn[i + 1] * pn % mod;\n    &#125;\n    auto C = [&amp;](int n, int m) &#123;\n        return fac[n] * inv[n - m] % mod * inv[m] % mod;\n    &#125;;\n    long long g = 0ll;\n    auto f = [&amp;](int i, int j) &#123; // make sure (!i || !j)\n        if (i == 0 &amp;&amp; j == 0)\n            return pnn;\n        else if (i == 0)\n            return C(n, j) * powi[j] % mod * pown[n - j] % mod;\n        return C(n, i) * powi[i] % mod * pown[n - i] % mod;\n    &#125;;\n    for (int j = 0, p = 1; j &lt;= n; ++j, p = mod - p)\n        (g += p * f(0, j)) %= mod;\n    for (int i = 1, p = mod - 1; i &lt;= n; ++i, p = mod - p)\n        (g += p * f(i, 0) % mod + p * C(n, i) % mod * pnn % mod * invn[i] % mod * 3 % mod * (qkp(mod - invi[n - i] + 1, n) + mod - 1) % mod) %= mod;\n    std::cout &lt;&lt; (pnn + mod - g) % mod &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"d---去-m-nom\">D - 去 M / NoM</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P11316\" class=\"uri\">https://www.luogu.com.cn/problem/P11316</a></p>\n<p>假设 <span class=\"math inline\">\\(f(i)\\)</span> 为至少有 <span class=\"math inline\">\\(i\\)</span> 对不合法元素的方案数，则容斥得到答案 <span class=\"math inline\">\\(\\sum\\limits_{i=0}^n (-1)^i\\cdot f(i)\\)</span>。考虑怎么计算 <span class=\"math inline\">\\(f(i)\\)</span>。</p>\n<p><mark><span class=\"math inline\">\\(M\\)</span> 整除 <span class=\"math inline\">\\(dis(x, y) \\iff (pos_x - pos_y)\\bmod M=0\\iff pos_x\\equiv pos_y\\pmod M\\)</span>。</mark></p>\n<p>考虑把关于 <span class=\"math inline\">\\(M\\)</span> 同余的位置放在一个组，也就是说需要让一对元素不能选同一组的位置。</p>\n<p>考虑容斥，令 <span class=\"math inline\">\\(f(i)\\)</span> 表示至少有 <span class=\"math inline\">\\(i\\)</span> 对点选到一组的方案数，考虑怎么计算。假设我们要在第 <span class=\"math inline\">\\(k\\)</span> 组（size 为 <span class=\"math inline\">\\(s_k\\)</span>）中选出 <span class=\"math inline\">\\(x\\)</span> 对位置，实际上只需要选择 <span class=\"math inline\">\\(2x\\)</span> 个位置然后任意分配给这 <span class=\"math inline\">\\(x\\)</span> 对数，即 <span class=\"math inline\">\\(A_{s_k}^{2x}\\)</span>。设 <span class=\"math inline\">\\(dp_{i, j}\\)</span> 表示 DP 到第 <span class=\"math inline\">\\(i\\)</span> 个组，已经选了 <span class=\"math inline\">\\(j\\)</span> 对，那么有 <span class=\"math inline\">\\(dp_{i,j}=\\sum\\limits_{k=0}^jC_{n-(j - k)}^{j-k}\\times dp_{i-1,j-k}\\times A_{s_i}^{2k}\\)</span>。乍一看好像是 <span class=\"math inline\">\\(O(n^3)\\)</span> 的，但是别忘了 <span class=\"math inline\">\\(\\sum s_i=2n\\)</span>，所以只有 <span class=\"math inline\">\\(O(n^2)\\)</span>。<span class=\"math inline\">\\(f(i)\\)</span> 即为 <span class=\"math inline\">\\(dp_{m,i}\\times (2n-2i)!\\)</span>。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 1e9 + 7;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, m;\n    std::cin &gt;&gt; n &gt;&gt; m;\n    std::vector&lt;int&gt; s(m + 1);\n    std::vector&lt;long long&gt; fac(2 * n + 1), inv(2 * n + 1);\n    fac[0] = inv[0] = 1ll;\n    for (int i = 1; i &lt;= 2 * n; ++i)\n        ++s[i % m + 1], fac[i] = fac[i - 1] * i % mod;\n    auto qkp = [](long long x, int y) &#123;\n        auto res = 1ll;\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    inv[2 * n] = qkp(fac[2 * n], mod - 2);\n    for (int i = 2 * n - 1; i; --i)\n        inv[i] = inv[i + 1] * (i + 1) % mod;\n    auto A = [&amp;](int n, int m) &#123;\n        return fac[n] * inv[n - m] % mod;\n    &#125;;\n    auto C = [&amp;](int n, int m) &#123;\n        return fac[n] * inv[n - m] % mod * inv[m] % mod;\n    &#125;;\n    std::vector&lt;std::vector&lt;long long&gt; &gt; dp(m + 1, std::vector&lt;long long&gt; (n + 1));\n    dp[0][0] = 1ll;\n    for (int i = 1; i &lt;= m; ++i)\n        for (int j = 0; j &lt;= n; ++j) &#123;\n            for (int k = 0; k &lt;= j &amp;&amp; 2 * k &lt;= s[i]; ++k)\n                (dp[i][j] += C(n - (j - k), k) * dp[i - 1][j - k] % mod * A(s[i], 2 * k) % mod) %= mod;\n            // printf(&quot;s = %d, dp[%d][%d] = %lld\\n&quot;, s[i], i, j, dp[i][j]);\n        &#125;\n    long long res = 0ll;\n    for (int i = 0, p = 1; i &lt;= n; ++i, p = mod - p)\n        (res += p * dp[m][i] % mod * fac[2 * n - 2 * i] % mod) %= mod;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"e---kdoi-11彩灯晚会\">E - 「KDOI-11」彩灯晚会</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P11292\" class=\"uri\">https://www.luogu.com.cn/problem/P11292</a></p>\n<p>考虑 <span class=\"math inline\">\\({cnt_i}^2\\)</span> 的含义，即在所有颜色为 <span class=\"math inline\">\\(i\\)</span>、长度为 <span class=\"math inline\">\\(l\\)</span> 的链中有放回地选两次的方案数。</p>\n<p>显然复杂度里是不能包含 <span class=\"math inline\">\\(k\\)</span> 的，所以放弃直接统计 <span class=\"math inline\">\\(cnt_i\\)</span> 的想法。显然每种颜色是等价的，考虑计算选择两条链可以给答案带来的贡献：答案的形式是个和式；对于两条同色链 <span class=\"math inline\">\\(p,q\\)</span>，假设颜色为 <span class=\"math inline\">\\(i\\)</span>，那么会对 <span class=\"math inline\">\\({cnt_i}^2\\)</span> 带来 <span class=\"math inline\">\\(k^{n-2l-|p\\cap q|}\\)</span> 的贡献，对总答案带来 <span class=\"math inline\">\\(k^{n-2l-|p\\cap q| + 1}\\)</span> 的贡献。</p>\n<p>然而如果要枚举计算 <span class=\"math inline\">\\(|p\\cap q|\\)</span> 就无法避免 <span class=\"math inline\">\\(O(n^5)\\)</span>，考虑更有潜力的方法：将问题转化为对于每个 <span class=\"math inline\">\\(x\\)</span>，求交集大小恰好为 <span class=\"math inline\">\\(x\\)</span> 的链对个数。然而「恰好」是不方便计算的——假如当前两链在 <span class=\"math inline\">\\(u\\)</span> 次重合，如果假设下一次在 <span class=\"math inline\">\\(v\\)</span> 次重合，就需要保证在 <span class=\"math inline\">\\(u,v\\)</span> 之间不能重合——这并不好操作。二项式反演将恰好转化为至少，则限制减弱。</p>\n<p>令 <span class=\"math inline\">\\(f_{u,c,l_1,l_2}\\)</span> 表示 <span class=\"math inline\">\\(p,q\\)</span> 当前在 <span class=\"math inline\">\\(u\\)</span> 处重合，视野内的 <span class=\"math inline\">\\(p,q\\)</span> 长度为 <span class=\"math inline\">\\(l_1,l_2\\)</span>，至少已经重合了 <span class=\"math inline\">\\(c\\)</span> 次的方案数。预处理出走到 <span class=\"math inline\">\\(u\\)</span> 步数为 <span class=\"math inline\">\\(l_1,l_2\\)</span> 的方案数为初始值。枚举可能的后续重合点 <span class=\"math inline\">\\(v\\)</span>（满足 <span class=\"math inline\">\\(v\\)</span> 的拓扑序 <span class=\"math inline\">\\(&gt;u\\)</span>）有 <span class=\"math inline\">\\(f_{v,c+1,l_1&#39;,l_2&#39;}\\gets f_{v,c+1,l_1&#39;,l_2&#39;} + f_{u,c,l_1,l_2}\\)</span>。预处理出 <span class=\"math inline\">\\(u\\to v\\)</span> 长度为 <span class=\"math inline\">\\(\\Delta\\)</span> 的方案数（这是 <span class=\"math inline\">\\(O(n^3l)\\)</span> 的）优化转移，在算出 <span class=\"math inline\">\\(nex_{u,l}\\)</span> 表示从 <span class=\"math inline\">\\(u\\)</span> 出发走 <span class=\"math inline\">\\(l\\)</span> 步的方案数处理答案，则 <span class=\"math inline\">\\(F(i)=\\sum_{u,l_1,l_2}f_{u,l_1,l_2}\\cdot nex_{u,l-l_1}\\cdot nex_{u,l-l_2}\\)</span>，枚举 <span class=\"math inline\">\\(u,c,l_1,l_2,v,l_1&#39;,l_2&#39;\\)</span>，就可以达到优秀的 <span class=\"math inline\">\\(O(n^2l^5+n^3l)\\)</span>！简直是令人震撼 <img src=\"/em/kt.gif\" /></p>\n<p>给出第一个优化：发现 <span class=\"math inline\">\\(l_1\\)</span> 和 <span class=\"math inline\">\\(l_2\\)</span> 的转移彼此不干扰，考虑建立一个临时数组 <span class=\"math inline\">\\(g\\)</span>，先从 <span class=\"math inline\">\\(f_u,c\\)</span> 转移 <span class=\"math inline\">\\(l_1\\)</span> 到 <span class=\"math inline\">\\(g\\)</span>，再从 <span class=\"math inline\">\\(g\\)</span> 转移 <span class=\"math inline\">\\(l_2\\)</span> 到 <span class=\"math inline\">\\(f_{v,c+1}\\)</span>，则复杂度降为 <span class=\"math inline\">\\(O(n^2l^4+n^3l)\\)</span>，仍不足以通过。</p>\n<p>DP 过程上的优化已经万策尽，考虑从式子本身消元减少 DP 维度入手。令 <span class=\"math inline\">\\(h(i)\\)</span> 表示交集大小恰好恰好为 <span class=\"math inline\">\\(i\\)</span> 的方案数，则此时答案式为 <span class=\"math inline\">\\(\\sum\\limits_{i=0}^l k^{n-2l+i+1}\\times h(i)\\)</span>。又 <span class=\"math inline\">\\(F(i)=\\sum\\limits_{j=i}^lC_j^i\\cdot h(j)\\)</span>，二项式反演得：</p>\n<p><span class=\"math display\">\\[\n\\begin{aligned}\nres&amp;=\\sum\\limits_{i=0}^lk^{n-2l+i+1}\\cdot \\sum_{j=i}^l(-1)^{j-i}\\cdot C_j^i\\cdot F(j)\\\\\n&amp;=k^{n-2l+1}\\cdot\\sum_{j=0}^l \\sum_{i=0}^j k^i\\cdot (-1)^{j-i}\\cdot C_j^i\\cdot F(j)\\\\\n&amp;=k^{n-2l+1}\\cdot \\sum_{j=0}^l (k-1)^j\\cdot F(j)\n\\end{aligned}\n\\]</span></p>\n<p><mark>注意这里利用了二项式反演的系数可以和交换求和顺序后的 <span class=\"math inline\">\\(i\\)</span> 次项（或 <span class=\"math inline\">\\(j-i\\)</span> 次项，参见 <a href=\"#c---sky-full-of-stars\">Sky Full of Stars 中最后一步的处理</a>）组成二项式定理的特点</mark>，以便基于式子结构尽可能消元。</p>\n<p>那么此时答案式已经和 <span class=\"math inline\">\\(c\\)</span> 无关，可以丢掉 <span class=\"math inline\">\\(c\\)</span> 这一维，和 <span class=\"math inline\">\\(c\\)</span> 有关的计算已经在转移时处理了。则 <span class=\"math inline\">\\(f_{v,l_1&#39;,l_2&#39;}=\\sum f_{u,l_1,l_2}\\times (k-1)\\)</span>，复杂度降为 <span class=\"math inline\">\\(O(n^2l^3+n^3l)\\)</span>。</p>\n<details>\n<p>记得还要算上 <span class=\"math inline\">\\(F(0)\\)</span>，即任选一条合法链的方案数平方。</p>\n<pre class=\"cpp\"><code>// 兄弟你好香\n// 兄弟你是依托打分，我踏马吃吃吃吃吃\n#include &lt;bits/stdc++.h&gt;\nconst int mod = 998244353;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;party3.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    using arr = std::vector&lt;long long&gt;;\n    using arrr = std::vector&lt;arr&gt;;\n    using arrrr = std::vector&lt;arrr&gt;;\n    int n, k, l, m;\n    std::cin &gt;&gt; n, std::cin &gt;&gt; n &gt;&gt; k &gt;&gt; l &gt;&gt; m;\n    std::vector&lt;int&gt; deg(n + 1), id;\n    std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; g(n + 1);\n    for (int x, y, c; m--; ) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y &gt;&gt; c;\n        ++deg[y], g[x].emplace_back(y, c);\n    &#125;\n    arrrr to(n + 1, arrr(n + 1, arr(l + 1)));\n    arrr pre(n + 1, arr(l + 1)), nex(n + 1, arr(l + 1));\n    &#123;\n        std::queue&lt;int&gt; q;\n        for (int i = 1; i &lt;= n; ++i)\n            if (!deg[i])\n                q.push(i);\n        for (int u; !q.empty(); ) &#123;\n            u = q.front(), q.pop();\n            to[u][u][0] = 1ll, id.push_back(u);\n            for (auto i : id)\n                for (int j = 0; j &lt;= l; ++j) &#123;\n                    (pre[u][j] += to[i][u][j]) %= mod;\n                    // printf(&quot;to[%d][%d][%d] = %lld\\n&quot;, i, u, j, to[i][u][j]);\n                &#125;\n            // for (int j = 0; j &lt;= l; ++j)\n            //     printf(&quot;pre[%d][%d] = %lld\\n&quot;, u, j, pre[u][j]);\n            for (auto [v, c] : g[u]) &#123;\n                for (auto i : id)\n                    for (int j = 1; j &lt;= l; ++j)\n                        (to[i][v][j] += to[i][u][j - 1] * c) %= mod;\n                if (!--deg[v])\n                    q.push(v);\n            &#125;\n        &#125;\n        for (int u = 1; u &lt;= n; ++u)\n            for (int v = 1; v &lt;= n; ++v)\n                for (int i = 0; i &lt;= l; ++i)\n                    (nex[u][i] += to[u][v][i]) %= mod;\n    &#125;\n    arrrr f(n + 1, arrr(l + 1, arr(l + 1)));\n    &#123;\n        for (int i = 1; i &lt;= n; ++i)\n            for (int l1 = 1; l1 &lt;= l; ++l1)\n                for (int l2 = 1; l2 &lt;= l; ++l2)\n                    f[i][l1][l2] = pre[i][l1 - 1] * pre[i][l2 - 1] % mod * (k - 1) % mod;\n        for (auto i = 0; i &lt; n; ++i) &#123;\n            int u = id[i];\n            // for (int l1 = 1; l1 &lt;= l; ++l1)\n            //     for (int l2 = 1; l2 &lt;= l; ++l2)\n            //         printf(&quot;f[%d][%d][%d] = %lld\\n&quot;, u, l1, l2, f[u][l1][l2]);\n            for (auto j = i + 1; j &lt; n; ++j) &#123;\n                arrr g(l + 1, arr(l + 1));\n                int v = id[j];\n                for (int l1 = 1; l1 &lt; l; ++l1)\n                    for (int _l1 = l1 + 1; _l1 &lt;= l; ++_l1) &#123;\n                        auto K = to[u][v][_l1 - l1];\n                        if (K)\n                            for (int l2 = 1; l2 &lt; l; ++l2)\n                                (g[_l1][l2] += f[u][l1][l2] * K) %= mod;\n                    &#125;\n                for (int _l1 = 2; _l1 &lt;= l; ++_l1)\n                    for (int l2 = 1; l2 &lt; l; ++l2)\n                        if (g[_l1][l2])\n                            for (int _l2 = l2 + 1; _l2 &lt;= l; ++_l2)\n                                (f[v][_l1][_l2] += g[_l1][l2] * to[u][v][_l2 - l2] % mod * (k - 1)) %= mod; \n            &#125;\n        &#125;\n    &#125;\n    auto qkp = [](long long x, int y) &#123;\n        auto res(1ll);\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    auto res(0ll);\n    for (int u = 1; u &lt;= n; ++u)\n        for (int v = 1; v &lt;= n; ++v)\n            (res += to[u][v][l - 1]) %= mod;\n    (res *= res) %= mod;\n    for (int u = 1; u &lt;= n; ++u)\n        for (int l1 = 1; l1 &lt;= l; ++l1)\n            for (int l2 = 1; l2 &lt;= l; ++l2)\n                (res += f[u][l1][l2] * nex[u][l - l1] % mod * nex[u][l - l2] % mod) %= mod;\n    res = res % mod * (qkp(k, n + 1) * qkp(qkp(k, 2 * l), mod - 2) % mod) % mod;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"g---小星星\">G - 小星星</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P3349\" class=\"uri\">https://www.luogu.com.cn/problem/P3349</a></p>\n<p>首先考虑比较暴力的做法，那么有 <span class=\"math inline\">\\(f_{i,j,S}\\)</span> 表示在 <span class=\"math inline\">\\(i\\)</span> 这个子树里面选了集合 <span class=\"math inline\">\\(S\\)</span>，且 <span class=\"math inline\">\\(i\\)</span> 的颜色为 <span class=\"math inline\">\\(j\\)</span> 的方案数，维数里之所以有 <span class=\"math inline\">\\(j\\)</span> 是为了满足连边限制。</p>\n<p>然后树上子集 DP，发现是 <span class=\"math inline\">\\(O(n^4\\cdot 2^n)\\)</span> 的，</p>\n<hr />\n<h2 id=\"cf785d-anton-and-school---2\">CF785D Anton and School - 2</h2>\n<p><a href=\"https://codeforces.com/problemset/problem/785/D\" class=\"uri\">https://codeforces.com/problemset/problem/785/D</a></p>\n<p>容易想到枚举每个 <code>(</code> 作为分界点的情况，那么钦定当前枚举的 <code>(</code> 是要选的。对于当前 <code>(</code>，若其左边（不含）的 <code>(</code> 有 <span class=\"math inline\">\\(n\\)</span> 个而右边的 <code>)</code> 有 <span class=\"math inline\">\\(m\\)</span> 个，枚举除了当前 <code>(</code> 还要选 <span class=\"math inline\">\\(i\\)</span> 个 <code>(</code>，那么答案为 <span class=\"math inline\">\\(\\sum_{i=0}C_n^{i-1}\\cdot C_m^i\\)</span>。</p>\n<p>发现这个形式可以范德蒙德卷积：<span class=\"math inline\">\\(\\sum_{i=0}C_n^{i-1}\\cdot C_m^i=\\sum_{i=0}C_n^{n-i+1}\\cdot C_m^i=C_{n+m}^{n+1}\\)</span>。</p>\n<p>关于怎么记忆范德蒙德卷积，发现上下相加，也可以从组合意义记忆：在 <span class=\"math inline\">\\(n\\)</span> 个球中选出 <span class=\"math inline\">\\(k-i\\)</span> 个球，再从 <span class=\"math inline\">\\(m\\)</span> 个球中选出 <span class=\"math inline\">\\(i\\)</span> 个球的总方案就是从 <span class=\"math inline\">\\(n+m\\)</span> 个球中直接选出 <span class=\"math inline\">\\(k\\)</span> 个球的方案。</p>\n<p>注意判断右侧没有 <code>)</code> 的时候贡献为 <span class=\"math inline\">\\(0\\)</span>。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 1e9 + 7;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    std::string s;\n    std::cin &gt;&gt; s;\n    int n = s.length();\n    s = &quot; &quot; + s;\n    std::vector&lt;int&gt; cnt1(n + 1), cnt2(n + 1);\n    std::vector&lt;long long&gt; fac(n + 1), inv(n + 1);\n    fac[0] = inv[0] = 1ll;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        fac[i] = fac[i - 1] * i % mod;\n        cnt1[i] = cnt1[i - 1] + (s[i] == &#39;(&#39;);\n    &#125;\n    auto qkp = [](long long x, int y) &#123;\n        auto res(1ll);\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    inv[n] = qkp(fac[n], mod - 2);\n    cnt2[n] = (s[n] == &#39;)&#39;);\n    for (int i = n - 1; i; --i) &#123;\n        cnt2[i] = cnt2[i + 1] + (s[i] == &#39;)&#39;);\n        inv[i] = inv[i + 1] * (i + 1) % mod;\n    &#125;\n    long long res = 0ll;\n    auto C = [&amp;](int n, int m) &#123;\n        if (n &lt; m)\n            return 0ll;\n        return fac[n] * inv[n - m] % mod * inv[m] % mod;\n    &#125;;\n    for (int i = 1; i &lt;= n; ++i)\n        if (s[i] == &#39;(&#39;)\n            (res += C(cnt1[i] + cnt2[i] - 1, cnt1[i])) %= mod;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"cf1332e-height-all-the-same\">CF1332E Height All the Same</h2>\n<p><a href=\"https://codeforces.com/problemset/problem/1332/E\" class=\"uri\">https://codeforces.com/problemset/problem/1332/E</a></p>\n<p>容易发现第一个操作是用来改变两个数奇偶性的；而第二个操作能在全图奇偶性相同的任何情况下达成要求。</p>\n<p>注意到如果我们想同时仅改变任意两个数的奇偶性，可以在棋盘上任找一条路径一路使用操作一。只要某种奇偶性的元素个数共有偶数个，就能通过若干次操作一把它们全部变成另一种奇偶性。</p>\n<p>令 <span class=\"math inline\">\\(K_1\\)</span> 为 <span class=\"math inline\">\\(L\\sim R\\)</span> 中奇数的个数，<span class=\"math inline\">\\(K_2\\)</span> 为偶数，那么有：</p>\n<p><span class=\"math display\">\\[\nres=\\sum_{i=0}^{nm} C_{nm}^i\\times {K_1}^i\\cdot {K_2}^{nm-i}\\cdot [i\\bmod 2=0]\n\\]</span></p>\n<p>我们发现这个东西和二项式定理简直像得不能再像了！但多了一个系数导致没办法省略枚举过程。如果进行变形呢？</p>\n<p><span class=\"math display\">\\[\nres=(K_1+K_2)^{nm}-\\sum_{i=0}^{nm} C_{nm}^i\\times {K_1}^i\\cdot {K_2}^{nm-i}\\cdot [i\\bmod 2=1]\n\\]</span></p>\n<p>似乎依然没有出路！但这里有个神奇的操作：</p>\n<p><span class=\"math display\">\\[\nres=(-K_1+K_2)^{nm}+\\sum_{i=0}^{nm} C_{nm}^i\\times {K_1}^i\\cdot {K_2}^i\\cdot [i\\bmod 2=1]\n\\]</span></p>\n<p>二式相加就可以<mark>消元</mark>，得到 <span class=\"math inline\">\\(2\\cdot res=(K_1+K_2)^{nm}+(K_1-K_2)^{nm}\\)</span>。<mark>这启示我们二项式定理中的符号和奇偶性的深切联系。</mark></p>\n<details>\n<p>如果你使用费马小定理对次数进行了处理，你可能需要注意次数可能为 <span class=\"math inline\">\\(\\text{mod} -1\\)</span> 的倍数。</p>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 998244353;\nconst int inv2 = 499122177;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    long long n, m, l, r, k1, k2;\n    std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; l &gt;&gt; r, k1 = (r - l + 1) / 2, k2 = (r - l + 1) - k1;\n    auto qkp = [](long long x, long long y) &#123;\n        auto res(1ll);\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    if (n * m % 2)\n        std::cout &lt;&lt; qkp(r - l + 1, n * m) &lt;&lt; &#39;\\n&#39;;\n    else\n        std::cout &lt;&lt; (qkp(r - l + 1, n * m) + qkp((k1 + mod - k2) % mod, n * m)) % mod * inv2 % mod &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"a---交错序列\">A - 交错序列</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P4456\" class=\"uri\">https://www.luogu.com.cn/problem/P4456</a></p>\n<figure>\n<img src=\"2.png\" alt=\"出题人疑似需要加强数学功底（？）\" /><figcaption>出题人疑似需要加强数学功底（？）</figcaption>\n</figure>\n<p>容易想到把答案用二项式定理拆开：</p>\n<p><span class=\"math display\">\\[\n\\begin{aligned}\nres&amp;=\\sum_y f_y\\cdot y^b\\cdot (n-y)^a\\\\\n&amp;=\\sum_y f_y\\cdot y^b\\cdot \\sum_{i=0}^a C_a^i\\cdot n^i\\cdot(-y)^{a-i}\\\\\n&amp;=\\sum_y\\sum_{i=0}^a f_y\\cdot C_a^i\\cdot n^i\\cdot(-1)^{a-i}\\cdot y^{a+b-i}\\\\\n&amp;=\\sum_{i=0}^a C_a^i\\cdot n^i\\cdot(-1)^{a-i}\\cdot \\sum_y f_y\\cdot y^{a+b-i}\\\\\n\\end{aligned}\n\\]</span></p>\n<p>然后发现后面那个 sigma 不太有办法求。一个比较优雅的方法是把 <span class=\"math inline\">\\(y^{a+b-i}\\)</span> 直接作为系数而非下标塞到 <span class=\"math inline\">\\(f\\)</span> 里去，即令 <span class=\"math inline\">\\(f_{i}\\)</span> 表示 <span class=\"math inline\">\\(\\forall \\,y\\)</span>，<span class=\"math inline\">\\(\\sum y^i\\)</span> 之和。</p>\n<p>具体地，令 <span class=\"math inline\">\\(dp_{n,i,0/1}\\)</span> 表示当前 DP 到第 <span class=\"math inline\">\\(n\\)</span> 位，要求幂次为 <span class=\"math inline\">\\(i\\)</span>，最后一位为 <span class=\"math inline\">\\(0/1\\)</span> 的答案。则显然有 <span class=\"math inline\">\\(dp_{n,i,0}=dp_{n-1,i,0}+dp_{n-1,i,1}\\)</span>。对于 <span class=\"math inline\">\\(dp_{n,i,1}\\)</span>，因为此时 <span class=\"math inline\">\\(\\forall\\, k,k\\gets k+1\\)</span>，则 <span class=\"math inline\">\\((k+1)^i=\\sum\\limits_{j=0}^i C_i^j \\cdot k^j\\)</span> 即 <span class=\"math inline\">\\(dp_{n,i,1}=\\sum\\limits_{j=0}^i C_i^j\\cdot dp_{n-1,j,0}\\)</span>。发现 <span class=\"math inline\">\\(i,j\\)</span> 的范围是 <span class=\"math inline\">\\(90\\)</span>，很恐怖的事情是这是可以矩阵的。</p>\n<details>\n<p>就像我们都知道的那样，矩阵在加完之后再取模就会快很多……</p>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint mod;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, a, b;\n    std::cin &gt;&gt; n &gt;&gt; a &gt;&gt; b &gt;&gt; mod;\n    std::vector&lt;std::vector&lt;long long&gt; &gt; C(a + b + 1, std::vector&lt;long long&gt;(a + b + 1));\n    for (int i = 0; i &lt;= a + b; ++i) &#123;\n        C[i][0] = 1ll;\n        for (int j = 1; j &lt;= i; ++j)\n            C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % mod;\n    &#125;\n    struct mat &#123;\n        int n, m;\n        std::vector&lt;std::vector&lt;long long&gt; &gt; a;\n        mat(int n, int m, bool flag = 0): n(n), m(m), a(n, std::vector&lt;long long&gt; (m)) &#123;\n            if (flag)\n                for (int i = 0; i &lt; n; ++i)\n                    a[i][i] = 1ll;\n            return;\n        &#125;\n        mat operator* (const mat &amp;q) const &#123;\n            mat res(n, q.m);\n            for (int i = 0; i &lt; n; ++i)\n                for (int k = 0; k &lt; q.m; ++k) &#123;\n                    for (int j = 0; j &lt; m; ++j)\n                        res.a[i][k] += a[i][j] * q.a[j][k];\n                    res.a[i][k] %= mod;\n                &#125;\n            return res;\n        &#125;\n        mat operator^ (int q) const &#123;\n            mat res(n, n, 1), x(*this);\n            for (; q; x = x * x, q &gt;&gt;= 1)\n                if (q &amp; 1)\n                    res = res * x;\n            return res;\n        &#125;\n    &#125; f(1, 2 * (a + b + 1)), op(2 * (a + b + 1), 2 * (a + b + 1));\n    auto fun = [&amp;](int i, int j) &#123;\n        return i + j * (a + b + 1);\n    &#125;;\n    f.a[0][fun(0, 0)] = 1ll;\n    for (int i = 0; i &lt;= a + b; ++i)\n        op.a[fun(i, 0)][fun(i, 0)] = op.a[fun(i, 1)][fun(i, 0)] = 1ll;\n    for (int i = 0; i &lt;= a + b; ++i)\n        for (int j = 0; j &lt;= i; ++j)\n            op.a[fun(j, 0)][fun(i, 1)] = C[i][j];\n    f = f * (op ^ n);\n    // for (int i = 0; i &lt;= n; ++i) &#123;\n    //     if (i)\n    //         f = f * op;\n    //     for (int j = 0; j &lt;= a + b; ++j)\n    //         printf(&quot;f[%d][%d] = %lld / %lld\\n&quot;, i, j, f.a[0][fun(j, 0)], f.a[0][fun(j, 1)]);\n    // &#125;\n    auto res = 0ll;\n    for (int i = 0; i &lt;= a; ++i) &#123;\n        static auto p(1ll), k((a % 2) ? mod - 1ll : 1ll);\n        (res += C[a][i] * p % mod * k % mod * (f.a[0][fun(a + b - i, 0)] + f.a[0][fun(a + b - i, 1)]) % mod) %= mod;\n        (p *= n) %= mod, k = mod - k;\n    &#125;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"b---different-subsets-for-all-tuples\">B - Different Subsets For All Tuples</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/CF660E\" class=\"uri\">https://www.luogu.com.cn/problem/CF660E</a></p>\n<p>首先你可能需要知道，如果已知一个序列，如何得到答案？</p>\n<p>令 <span class=\"math inline\">\\(f_i\\)</span> 表示在 <span class=\"math inline\">\\(i\\)</span> 处取一个子序列的末尾，枚举上一个元素 <span class=\"math inline\">\\(x\\)</span>，找到 <span class=\"math inline\">\\(i\\)</span> 之前最靠后的一个 <span class=\"math inline\">\\(a_j=x\\)</span>，那么有 <span class=\"math inline\">\\(f_i=\\sum f_j\\)</span>，换言之需要保证 <span class=\"math inline\">\\((j,i)\\)</span> 范围内没有 <span class=\"math inline\">\\(x\\)</span> 出现。</p>\n<p>此时序列未知，令 <span class=\"math inline\">\\(f_{i, x}\\)</span> 表示在 <span class=\"math inline\">\\(i\\)</span> 处取一个子序列末尾，且 <span class=\"math inline\">\\(i\\)</span> 的值为 <span class=\"math inline\">\\(x\\)</span>；按照贡献的视角来看待，每个可以和 <span class=\"math inline\">\\(i\\)</span> 组成新子序列的方案可以带来 <span class=\"math inline\">\\(m^{i-1}\\)</span> 的贡献（因为 <span class=\"math inline\">\\(a_i\\)</span> 已经固定为 <span class=\"math inline\">\\(x\\)</span>，其他位置可以任选），那么有 <span class=\"math inline\">\\(f_{i,x}=m^i\\times \\sum_{j&lt;i,y}f_{j,y}\\times (m-1)^{i-j-1}\\)</span>。</p>\n<p>然后就惊讶地发现式子和 <span class=\"math inline\">\\(x\\)</span> 这一维没有关系了。所以直接带上系数得到：</p>\n<p><span class=\"math display\">\\[\n\\begin{aligned}\nf_i&amp;=m^i\\times \\sum_{j&lt;i} f_j\\times (m-1)^{i-j-1}\\times m\\\\\n&amp;=m^i\\times (m-1)^{i-1}\\times m\\cdot \\sum_{j&lt;i} f_j\\times (m-1)^{-j}\n\\end{aligned}\n\\]</span></p>\n<p>前缀和优化一下就可以快速求了。最终的答案就是 <span class=\"math inline\">\\(res=m^n+\\sum f_i\\times (m-1)^{n-i}\\)</span>。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 1e9 + 7;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, m;\n    std::cin &gt;&gt; n &gt;&gt; m;\n    if (m == 1)\n        std::cout &lt;&lt; (n + 1) &lt;&lt; &#39;\\n&#39;;\n    else &#123;\n        std::vector&lt;long long&gt; f(n + 1), s(n + 1), pm1(n + 1);\n        pm1[0] = 1ll;\n        for (int i = 1; i &lt;= n; ++i)\n            pm1[i] = pm1[i - 1] * (m - 1) % mod;\n        auto qkp = [](long long x, int y) &#123;\n            auto res(1ll);\n            for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n                if (y &amp; 1)\n                    (res *= x) %= mod;\n            return res;\n        &#125;;\n        auto res(qkp(m, n));\n        const auto invm = qkp(m - 1, mod - 2);\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            static long long p(m), inv(invm);\n            f[i] = (p + pm1[i - 1] * m % mod * s[i - 1] % mod) % mod;\n            s[i] = (s[i - 1] + f[i] * inv % mod) % mod;\n            (res += f[i] * pm1[n - i] % mod) %= mod;\n            (p *= m) %= mod, (inv *= invm) %= mod;\n        &#125;\n        std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;; \n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"g---gardens\">G - Gardens</h2>\n<p><a href=\"https://atcoder.jp/contests/abc235/tasks/abc235_g\" class=\"uri\">https://atcoder.jp/contests/abc235/tasks/abc235_g</a></p>\n<p>如果没有『每个人必须有一个元素』这个限制，就可以随便做了。现在加上了这个限制，很容易想到用没得到的人来容斥。钦定至少有 <span class=\"math inline\">\\(i\\)</span> 个人没拿到，得到答案为 <span class=\"math inline\">\\(\\sum\\limits_{i=0}^n (-1)^i\\cdot C_n^i\\cdot \\left(\\sum\\limits_{j=0}^a C_i^j\\right)\\cdot \\left(\\sum\\limits_{j=0}^b C_i^j\\right)\\cdot \\left(\\sum\\limits_{j=0}^c C_i^j\\right)\\)</span>。</p>\n<p>怎么算 <span class=\"math inline\">\\(\\sum\\limits_{j=0}^a C_i^j\\)</span> 呢？当 <span class=\"math inline\">\\(a&gt; i\\)</span> 时，二项式是好求的；当 <span class=\"math inline\">\\(a\\le i\\)</span> 时呢？看到这个式子很容易带到杨辉三角里去，也就是求一行的前 <span class=\"math inline\">\\(a\\)</span> 个数。注意到可以用上一行的前 <span class=\"math inline\">\\(a\\)</span> 个数 <span class=\"math inline\">\\(O(1)\\)</span> 得到（假设第 <span class=\"math inline\">\\(j-1\\)</span> 行前 <span class=\"math inline\">\\(a\\)</span> 个数之和为 <span class=\"math inline\">\\(f_a(j-1)\\)</span>）：<span class=\"math inline\">\\(f_a(j)=f_a(j-1)\\times 2-C_{j-1,a}\\)</span>。<mark>你需要意识到，由于上一行也是答案中要求的，所以可以使用递推解决问题。<strong>在组合计数中，递推 / DP 无论是在化简式子还是求容斥 / 二项式反演里具体某一限制下的方案数都是很有用的，在需要优化复杂度时，可以从递推 / DP、恒等式、前缀和、预处理等方法入手考虑</strong></mark>。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 998244353;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, a, b, c;\n    std::cin &gt;&gt; n &gt;&gt; a &gt;&gt; b &gt;&gt; c;\n    std::vector&lt;long long&gt; fac(n + 1), inv(n + 1), fa(n + 1), fb(n + 1), fc(n + 1), pow2(n + 1);\n    fac[0] = inv[0] = pow2[0] = 1ll;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        fac[i] = fac[i - 1] * i % mod;\n        pow2[i] = pow2[i - 1] * 2 % mod;\n    &#125;\n    auto qkp = [&amp;](long long x, int y) &#123;\n        auto res(1ll);\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    inv[n] = qkp(fac[n], mod - 2);\n    for (int i = n - 1; i; --i)\n        inv[i] = inv[i + 1] * (i + 1) % mod;\n    auto C = [&amp;](int n, int m) &#123;\n        return fac[n] * inv[n - m] % mod * inv[m] % mod;\n    &#125;;\n    for (int i = 0; i &lt;= a; ++i)\n        (fa[a] += C(a, i)) %= mod;\n    for (int i = a + 1; i &lt;= n; ++i)\n        fa[i] = (2 * fa[i - 1] % mod + mod - C(i - 1, a)) % mod;\n    for (int i = 0; i &lt;= b; ++i)\n        (fb[b] += C(b, i)) %= mod;\n    for (int i = b + 1; i &lt;= n; ++i)\n        fb[i] = (2 * fb[i - 1] % mod + mod - C(i - 1, b)) % mod;\n    for (int i = 0; i &lt;= c; ++i)\n        (fc[c] += C(c, i)) %= mod;\n    for (int i = c + 1; i &lt;= n; ++i)\n        fc[i] = (2 * fc[i - 1] % mod + mod - C(i - 1, c)) % mod;\n    auto res(0ll);\n    for (int i = n, p = 1; ~i; --i, p = mod - p)\n        (res += p * C(n, i) % mod * (i &gt;= a ? fa[i] : pow2[i]) % mod * (i &gt;= b ? fb[i] : pow2[i]) % mod * (i &gt;= c ? fc[i] : pow2[i]) % mod) %= mod;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n",
            "tags": [
                "排列组合",
                "容斥原理",
                "数学",
                "二项式定理",
                "二项式反演"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20250216/",
            "url": "https://xsc062.netlify.app/20250216/",
            "title": "Public Round 15 前两题",
            "date_published": "2025-02-16T11:44:38.000Z",
            "content_html": "<p><a href=\"https://pjudge.ac/contest/1914\">PR #15</a> 前两题题解。</p>\n<span id=\"more\"></span>\n<hr />\n<h2 id=\"最小表示法\">最小表示法</h2>\n<p><a href=\"https://pjudge.ac/contest/1914/problem/21888\" class=\"uri\">https://pjudge.ac/contest/1914/problem/21888</a></p>\n<p>首先不妨假设每个 <span class=\"math inline\">\\(f\\)</span> 在值域内等概率取值以简化问题。那么手玩一下可以轻松地得到规律：不妨将 <span class=\"math inline\">\\(\\{s\\}\\)</span> 循环右移一位的结果记为 <span class=\"math inline\">\\(\\{t\\}\\)</span>，那么 <span class=\"math inline\">\\(res=\\sum\\frac 1{\\max(|s_i|,|t_i|)}\\)</span>。</p>\n<p>这看起来令人疑惑：对于不同的 <span class=\"math inline\">\\(i\\)</span>，<span class=\"math inline\">\\([f(s_i)=f(t_i)]\\)</span> 的期望似乎是彼此独立的，十分奇怪。这其实与表达式的来源有关，记 <span class=\"math inline\">\\(g(s_i, j)\\)</span> 表示 <span class=\"math inline\">\\(f(s_i)=j\\)</span> 的概率，那么上述等式可以转写为 <span class=\"math inline\">\\(res=\\sum\\limits_i\\sum\\limits_jg({s_i},j)\\times g(t_i,j)\\)</span>。</p>\n<p>那么将最小表示法带来的偏差纳入考虑范围，我们发现 <span class=\"math inline\">\\(g(s,j)\\)</span> 对于不同的 <span class=\"math inline\">\\(j\\)</span> 并不永远相等。具体地，当 <span class=\"math inline\">\\(s\\)</span> 具有循环节时，最小循环节的第一处结尾会享有更大的取得概率。</p>\n<p>枚举 <span class=\"math inline\">\\(s_i\\)</span> 的因数作为最小循环节长度的情况，显然，对于最小循环节为 <span class=\"math inline\">\\(j\\)</span> 的情况（该情况出现的概率，容斥得到 <span class=\"math inline\">\\(p_j=26^j-\\sum_{k\\mid j}p_k\\)</span>），<span class=\"math inline\">\\(f(s_i)\\)</span> 的取值在 <span class=\"math inline\">\\(1\\sim j\\)</span> 上等概率分布，差分即可统计每个值在不同循环节长度下被取到的概率和。</p>\n<p>用埃筛解决每个数的因数和 <span class=\"math inline\">\\(p\\)</span> 值，那么此时复杂度瓶颈在于 <span class=\"math inline\">\\(g(s_i, j)\\)</span> 和 <span class=\"math inline\">\\(\\sum\\limits_i\\sum\\limits_jg({s_i},j)\\times g(t_i,j)\\)</span> 的求解。容易发现只有每个 <span class=\"math inline\">\\(g(s_i,j),j\\mid |s_i|\\)</span> 的值是有效的（其他的和它们值都相同），考虑只求解和利用这些值，类 <code>std::merge</code>（即归并排序）地求解答案。</p>\n<p>注意特判 <span class=\"math inline\">\\(n=1\\)</span>。会得到错误答案的原因是此时存在 <span class=\"math inline\">\\(s_i=t_i\\)</span>，不满足基本要求。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int lim = 1e5;\nconst int mod = 998244353;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    if (n == 1) &#123;\n        std::cout &lt;&lt; 1 &lt;&lt; &#39;\\n&#39;;\n        return 0;\n    &#125;\n    auto qkp = [](long long x, int y) &#123;\n        long long res = 1ll;\n        for (; y; y &gt;&gt;= 1, (x *= x) %= mod)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    auto inv = [&amp;](int x) &#123;\n        return qkp(x, mod - 2);\n    &#125;;\n    std::vector&lt;long long&gt; f(lim + 1);\n    std::vector&lt;std::vector&lt;int&gt; &gt; fac(lim + 1);\n    for (int i = 1; i &lt;= lim; ++i) &#123;\n        static long long now = 26;\n        (f[i] += now) %= mod;\n        fac[i].push_back(i);\n        for (int j = 2 * i; j &lt;= lim; j += i)\n            (f[j] += mod - f[i]) %= mod, fac[j].push_back(i);\n        (now *= 26) %= mod;\n    &#125;\n    for (int i = 1; i &lt;= lim; ++i)\n        (f[i] *= inv(i)) %= mod;\n    std::vector&lt;int&gt; a(n + 1);\n    struct _ &#123; int l, r; long long f; &#125;;\n    std::vector&lt;std::vector&lt;_&gt; &gt; g(lim + 1);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; a[i];\n        if (g[a[i]].empty()) &#123;\n            g[a[i]].resize(fac[a[i]].size());\n            for (int j = 0; j &lt; (int)fac[a[i]].size(); ++j) &#123;\n                g[a[i]][j].l = (j ? g[a[i]][j - 1].r + 1 : 1);\n                g[a[i]][j].r = fac[a[i]][j];\n                (g[a[i]][0].f += f[fac[a[i]][j]]) %= mod;\n                if (j != (int)fac[a[i]].size() - 1)\n                    (g[a[i]][j + 1].f += mod - f[fac[a[i]][j]]) %= mod;\n            &#125;\n            for (int j = 1; j &lt; (int)fac[a[i]].size(); ++j)\n                (g[a[i]][j].f += g[a[i]][j - 1].f) %= mod;\n            int getinv = inv(qkp(26, a[i]));\n            for (int j = 0; j &lt; (int)fac[a[i]].size(); ++j)\n                (g[a[i]][j].f *= getinv) %= mod;\n        &#125;\n    &#125;\n    std::vector&lt;int&gt; b(n + 1);\n    std::rotate_copy(a.begin() + 1, --a.end(), a.end(), b.begin() + 1);\n    long long res = 0ll;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        for (int j = 0, k = 0, now = 0;\n            j &lt; (int)fac[a[i]].size() &amp;&amp; k &lt; (int)fac[b[i]].size(); )\n            if (g[a[i]][j].r &lt; g[b[i]][k].r) &#123;\n                (res += g[a[i]][j].f * g[b[i]][k].f % mod\n                    * (g[a[i]][j].r - now) % mod) %= mod;\n                now = g[a[i]][j].r, ++j;\n            &#125;\n            else if (g[a[i]][j].r == g[b[i]][k].r) &#123;\n                (res += g[a[i]][j].f * g[b[i]][k].f % mod\n                    * (g[a[i]][j].r - now) % mod) %= mod;\n                now = g[a[i]][j].r, ++j, ++k;\n            &#125;\n            else &#123;\n                (res += g[a[i]][j].f * g[b[i]][k].f % mod\n                    * (g[b[i]][k].r - now) % mod) %= mod;\n                now = g[b[i]][k].r, ++k;\n            &#125;\n    &#125;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"二叉搜索树\">二叉搜索树</h2>\n<p><a href=\"https://pjudge.ac/contest/1914/problem/21889\" class=\"uri\">https://pjudge.ac/contest/1914/problem/21889</a></p>\n<p>当我们处理链的部分分时，很容易想到用差分解决问题。把更新 <span class=\"math inline\">\\([l, r]\\)</span> 看作在差分数组 <span class=\"math inline\">\\(l\\)</span> 处插入，在 <span class=\"math inline\">\\(r+1\\)</span> 处删除，离线下来再从左到右扫一遍操作，考虑如何解决查询问题。</p>\n<p>考虑如何获取 <span class=\"math inline\">\\(i\\)</span> 树上 <span class=\"math inline\">\\(t_0\\)</span> 时刻点 <span class=\"math inline\">\\(x\\)</span> 的所有祖先。根据前面的操作，我们可以获取 <span class=\"math inline\">\\(i\\)</span> 树上存在过的所有元素。</p>\n<p>对于比 <span class=\"math inline\">\\(x\\)</span> 大的元素，考虑祖先 <span class=\"math inline\">\\(p_a\\)</span> 和非祖先 <span class=\"math inline\">\\(p\\)</span> 有什么区别。根据 BST 的性质易得，对于最低的右侧祖先 <span class=\"math inline\">\\({p_a}_0\\)</span>，其是 <span class=\"math inline\">\\(\\ge x\\)</span> 的最小的元素（当然其加入时刻 <span class=\"math inline\">\\(t_a&lt;t_0\\)</span>）；那么同理可以找到 <span class=\"math inline\">\\({p_a}_0\\)</span> 右侧最低的祖先（其左侧的祖先显然也 <span class=\"math inline\">\\(x\\)</span> 左侧），该祖先满足 <span class=\"math inline\">\\(t&lt;t_a\\)</span>。那么我们就从左右两边分别得到 <span class=\"math inline\">\\(x\\)</span> 的所有祖先。容易证明该过程对于不在树上的 <span class=\"math inline\">\\(x\\)</span> 也是正确的。</p>\n<p>具体地，我们需要一个数据结构，能够求出 <span class=\"math inline\">\\(\\ge x\\)</span> 的元素中，以 <span class=\"math inline\">\\(t_0\\)</span> 为起点的前缀最小值序列的区间和。</p>\n<p>欸 ☝🤓 这是什么？<a href=\"/20250217\">楼房重建</a>！秒一下！</p>\n<p>进一步地，本题需要完成对于 <span class=\"math inline\">\\(t_0\\)</span> 为序列头的查询。再次利用性质，每次 <span class=\"math inline\">\\(O(\\log V)\\)</span> 地合并答案。</p>\n<p>好的那么怎么把链搞到树上呢？把差分放到树上，写个线段树合并即可。</p>\n<p><strong>注意由于这题细节太多了，所以你可能需要舍弃不必要的时空优化换取代码简洁度以方便调试。</strong></p>\n<details>\n<pre data-line=\"12\" class=\"cpp language-cpp\"><code data-line=\"12\" class=\"cpp language-cpp\">#include &lt;bits/stdc++.h&gt;\nconst int lim = 2e5;\nconst int maxn = 2e7 + 5;\nconst int inf = 0x3f3f3f3f;\nstruct &#123;\n    int l, r, rv;\n    long long u;\n&#125; t[maxn];\nstd::vector&lt;int> tr;\n#define lt t[p].l\n#define rt t[p].r\nint newnode(void) &#123;         // 我知道你要说什么，但这属于「必要的」空间优化 😥\n    static int tot = 0;\n    if (tr.empty())\n        return ++tot;\n    auto p(tr.back());\n    t[p].l = t[p].r = 0;\n    tr.pop_back();\n    return p;\n&#125;\nlong long askv(int p, int l, int r, int v) &#123;\n    if (l == r)\n        return t[p].rv < v ? t[p].u : 0;\n    int mid = (l + r) >> 1;\n    if (v > t[lt].rv)\n        return t[p].u - t[lt].u + askv(lt, l, mid, v);\n    return askv(rt, mid + 1, r, v);\n&#125;\nvoid pushup(int p, int l, int r) &#123;\n    t[p].rv = std::min(t[lt].rv, t[rt].rv);\n    int mid = (l + r) >> 1;\n    t[p].u = t[lt].u + askv(rt, mid + 1, r, t[lt].rv);\n    return;\n&#125;\nvoid upd(int &p, int l, int r, int x, int v, int u) &#123;\n    if (!p)\n        p = newnode();\n    if (l == r) &#123;\n        t[p].rv = v, t[p].u = u;\n        return;\n    &#125;\n    int mid = (l + r) >> 1;\n    if (x <= mid)\n        upd(lt, l, mid, x, v, u);\n    else\n        upd(rt, mid + 1, r, x, v, u);\n    pushup(p, l, r);\n    return;\n&#125;\nvoid merge(int &p, int q, int l, int r) &#123;\n    if (!p || !q) &#123;\n        p += q;\n        return;\n    &#125;\n    if (l == r) &#123;\n        t[p].rv = std::min(t[p].rv, t[q].rv);\n        t[p].u = std::max(t[p].u, t[q].u);\n        return;\n    &#125;\n    int mid = (l + r) >> 1;\n    merge(t[p].l, t[q].l, l, mid), merge(t[p].r, t[q].r, mid + 1, r);\n    pushup(p, l, r), tr.push_back(q);\n    return;\n&#125;\nint qv = inf;\nlong long ask(int p, int l, int r, int ql, int qr) &#123;\n    if (ql <= l && r <= qr) &#123;\n        auto s(askv(p, l, r, qv));\n        qv = std::min(qv, t[p].rv);\n        return s;\n    &#125;\n    int mid = (l + r) >> 1;\n    long long res = 0ll;\n    if (ql <= mid)\n        res = ask(lt, l, mid, ql, qr);\n    if (qr > mid)\n        res += ask(rt, mid + 1, r, ql, qr);\n    return res;\n&#125;\n#undef lt\n#undef rt\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(\"ex_problem4.in\", \"r\", stdin);\n    std::freopen(\".out\", \"w\", stdout);\n#endif\n    int n, m;\n    std::cin >> n >> m;\n    std::vector&lt;std::vector&lt;int> > g(n + 1);\n    for (int i = 1, x, y; i < n; ++i) &#123;\n        std::cin >> x >> y;\n        g[x].push_back(y), g[y].push_back(x);\n    &#125;\n    std::vector&lt;int> top(n + 1), fa(n + 1), siz(n + 1), son(n + 1), dep(n + 1);\n    std::function&lt;void(int, int)> DFS = [&](int x, int faa) &#123;\n        siz[x] = 1;\n        for (auto i : g[x])\n            if (i != faa) &#123;\n                fa[i] = x, dep[i] = dep[x] + 1;\n                DFS(i, x), siz[x] += siz[i];\n                if (siz[i] > siz[son[x]])\n                    son[x] = i;\n            &#125;\n        return;\n    &#125;;\n    DFS(1, -1);\n    DFS = [&](int x, int topp) &#123;\n        top[x] = topp;\n        if (son[x])\n            DFS(son[x], topp);\n        for (auto i : g[x])\n            if (i != fa[x] && i != son[x])\n                DFS(i, i);\n        return;\n    &#125;;\n    DFS(1, 1);\n    auto getLCA = [&](int x, int y) &#123;\n        for (; top[x] != top[y]; x = fa[top[x]])\n            if (dep[top[y]] > dep[top[x]])\n                std::swap(x, y);\n        return (dep[x] < dep[y] ? x : y);\n    &#125;;\n    std::vector&lt;std::vector&lt;int> > d(n + 1);\n    std::vector&lt;std::vector&lt;std::pair&lt;int, int> > > u(n + 1);\n    std::vector&lt;std::vector&lt;std::tuple&lt;int, int, int> > > q(n + 1);\n    int cnt = 0;\n    for (int i = 1; i <= m; ++i) &#123;\n        int op;\n        std::cin >> op;\n        if (op == 0) &#123;\n            int x, v;\n            std::cin >> x >> v;\n            q[x].emplace_back(++cnt, i, v);\n        &#125; else &#123;\n            int x, y, v;\n            std::cin >> x >> y >> v;\n            int faa = getLCA(x, y);\n            u[x].emplace_back(i, v), u[y].emplace_back(i, v);\n            if (fa[faa])\n                d[fa[faa]].emplace_back(v);\n        &#125;\n    &#125;\n    std::vector&lt;long long> res(cnt + 1);\n    std::vector&lt;std::vector&lt;int> > rt(2, std::vector&lt;int> (n + 1));\n    t[0].rv = inf;\n    DFS = [&](int x, int fa) &#123;\n        for (auto i : g[x])\n            if (i != fa) &#123;\n                DFS(i, x);\n                merge(rt[0][x], rt[0][i], 1, lim);\n                merge(rt[1][x], rt[1][i], 1, lim);\n            &#125;\n        for (auto [t, v] : u[x]) &#123;\n            upd(rt[0][x], 1, lim, v, t, v);\n            upd(rt[1][x], 1, lim, lim - v + 1, t, v);\n        &#125;\n        for (auto v : d[x]) &#123;\n            upd(rt[0][x], 1, lim, v, inf, 0);\n            upd(rt[1][x], 1, lim, lim - v + 1, inf, 0);\n        &#125;\n        for (auto [id, t, v] : q[x]) &#123;\n            qv = t, res[id] = ask(rt[0][x], 1, lim, v, lim);\n            qv = t, res[id] += ask(rt[1][x], 1, lim, lim - v + 1, lim);\n            qv = t, res[id] -= ask(rt[0][x], 1, lim, v, v);\n        &#125;\n    &#125;;\n    DFS(1, -1);\n    for (int i = 1; i <= cnt; ++i)\n        std::cout << res[i] << '\\n';\n    return 0;\n&#125;</code></pre>\n</details>\n",
            "tags": [
                "线段树",
                "数学",
                "树上差分"
            ]
        }
    ]
}