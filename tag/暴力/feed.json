{
    "version": "https://jsonfeed.org/version/1",
    "title": "null • All posts by \"暴力\" tag",
    "description": "",
    "home_page_url": "https://xsc062.netlify.app",
    "items": [
        {
            "id": "https://xsc062.netlify.app/20250726/",
            "url": "https://xsc062.netlify.app/20250726/",
            "title": "解题报告 [GCJ 2018 #1B] Transmutation",
            "date_published": "2025-07-26T06:47:23.000Z",
            "content_html": "<p>对于『跑 <span class=\"math inline\">\\(n\\)</span> 遍』性质的利用。</p>\n<span id=\"more\"></span>\n<hr />\n<p><a href=\"https://www.luogu.com.cn/problem/P10805\" class=\"uri\">https://www.luogu.com.cn/problem/P10805</a></p>\n<p>容易注意到可以二分答案；但似乎没办法找到一种很好的方法在 <span class=\"math inline\">\\(O(n)\\)</span> 内完成一次 check。</p>\n<p>化用一下网络流中流量的概念；例如下面这个图，假如先从 <span class=\"math inline\">\\(0\\)</span> 开始跑，发现没办法很好地确定 <span class=\"math inline\">\\(8\\to 2\\)</span> 这条边的流量（原因：没办法确定 <span class=\"math inline\">\\(8\\)</span> 和 <span class=\"math inline\">\\(2\\)</span> 的搜索顺序）。</p>\n<p><img src=\"image.png\" /></p>\n<p>这个时候想到；如果是 <span class=\"math inline\">\\(2\\)</span> 先被搜到，自然很好；但如果是 <span class=\"math inline\">\\(8\\)</span> 先被搜到，可以忽略这条由它出发、且未确定的边，先由现在认为的流出量确定流入量。等搜到 <span class=\"math inline\">\\(2\\)</span> 的时候，再更新一下 <span class=\"math inline\">\\(8\\to 2\\)</span> 的流量。这样 <span class=\"math inline\">\\(8\\)</span> 的流入量就是错的；容易想到再搜一次来更新。</p>\n<p><strong>类比一下 SPFA，可以认为跑 <span class=\"math inline\">\\(n\\)</span> 遍就已经达到能更新的最终状态</strong>。此时 check 一下是否每个点都合法。</p>\n",
            "tags": [
                "二分",
                "暴力"
            ]
        }
    ]
}