{
    "version": "https://jsonfeed.org/version/1",
    "title": "null • All posts by \"欧拉回路\" tag",
    "description": "",
    "home_page_url": "https://xsc062.netlify.app",
    "items": [
        {
            "id": "https://xsc062.netlify.app/20241017/",
            "url": "https://xsc062.netlify.app/20241017/",
            "title": "模拟赛",
            "date_published": "2024-10-16T12:32:34.000Z",
            "content_html": "<p>好消息：会简单数学题 <img src=\"/em/dy.gif\" /></p>\n<p>更好的消息：忘取模了 <img src=\"/em/dy.gif\" /></p>\n<span id=\"more\"></span>\n<hr />\n<h3 id=\"a.-distorted\">A. distorted</h3>\n<p><a href=\"https://www.becoder.com.cn/contest/5611/problem/1\" class=\"uri\">https://www.becoder.com.cn/contest/5611/problem/1</a></p>\n<p>考虑最多需要多少个元素。最坏情况是选取四个角的元素，已经可以覆盖整个矩阵。进一步考虑感性反证发现无论如何都选不出来五个，故最多选择四个。</p>\n<p>我们发现，选取中间一个就可以覆盖整个矩阵。扩展一下，选择中间列就可以覆盖上 / 下半个矩阵，选择中间行就可以覆盖左 / 右半个矩阵。剩下的选择过后只能保证照顾到对应的 1/4 矩阵且一定不会完全覆盖其他的 1/4 矩阵。</p>\n<p>我们发现，中心元素地位高于中间行 / 列元素高于左上、左下、右上、右下元素。由此出发讨论选择元素的个数。</p>\n<ul>\n<li>1 个：选择中心元素。</li>\n<li>2 个：在中间行的左右两边各选一个 / 在中间列的上下两边各选一个。</li>\n<li>3 个：选一个中间行 / 列 + 两个其他元素，或两个中间行 / 列 + 一个其他元素。</li>\n<li>4 个：左上、左下、右上、右下各选一个。</li>\n</ul>\n<p>统计各个方向的最小值，选最小组合即可。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\n#define putchar\nconst long long inf = 0x3f3f3f3f;\nint main() &#123;\n    freopen(&quot;distorted.in&quot;, &quot;r&quot;, stdin);\n    freopen(&quot;distorted.out&quot;, &quot;w&quot;, stdout);\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n    int T;\n    for (std::cin &gt;&gt; T; T--; ) &#123;\n        int n;\n        std::cin &gt;&gt; n;\n        long long to = inf, u = inf, d = inf, l = inf, r = inf, q = inf, z = inf, p = inf, m = inf;\n        for (int i = 1; i &lt;= n; ++i)\n            for (int j = 1; j &lt;= n; ++j) &#123;\n                long long x;\n                std::cin &gt;&gt; x;\n                if (i * 2 - 1 == n &amp;&amp; j * 2 - 1 == n)\n                    to = x;\n                else if (i * 2 - 1 == n &amp;&amp; j * 2 - 1 &lt; n)\n                    l = std::min(l, x);\n                else if (i * 2 - 1 == n)\n                    r = std::min(r, x);\n                else if (i * 2 - 1 &lt; n &amp;&amp; j * 2 - 1 == n)\n                    u = std::min(u, x);\n                else if (j * 2 - 1 == n)\n                    d = std::min(d, x);\n                else if (i * 2 - 1 &lt; n &amp;&amp; j * 2 - 1 &lt; n)\n                    q = std::min(q, x);\n                else if (i * 2 - 1 &lt; n)\n                    p = std::min(p, x);\n                else if (j * 2 - 1 &lt; n)\n                    z = std::min(z, x);\n                else\n                    m = std::min(m, x);\n            &#125;\n        std::cout &lt;&lt; std::min(&#123; to, l + r, u + d, l + u + m, l + d + p, r + u + z, r + d + q, u + z + m, d + q + p, l + p + m, r + q + z, q + p + z + m &#125;) &lt;&lt; &#39;\\n&#39;;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"b.-fate\">B. fate</h3>\n<p><a href=\"https://www.becoder.com.cn/contest/5611/problem/2\" class=\"uri\">https://www.becoder.com.cn/contest/5611/problem/2</a></p>\n<p>诈骗题。对于前半段，考虑取差分数组 <span class=\"math inline\">\\(d\\)</span>，容易发现如果直接在差分数组上做减法，一定满足后面减得不比前面少。故只要满足差分数组每一项至少为 <span class=\"math inline\">\\(0\\)</span> 即可，答案为 <span class=\"math inline\">\\(\\prod {i\\le p} a_i - a_{i-1} + 1\\)</span>。</p>\n<p>对于后半段，我们考虑转化成和前半段相似的问题，将后半段翻转，同样取差分数组，则此时在该差分数组上满足后面减得不比前面少，同时需要满足差分数组每一项至多为 <span class=\"math inline\">\\(0\\)</span>，前面的所有项初始为负，操作为减，自然满足；但第 <span class=\"math inline\">\\(p\\)</span> 项在把前面减去的全部加上后不一定满足。故前面最多减去 <span class=\"math inline\">\\(d_p\\)</span>，随便在哪里减都无所谓，组合意义一下，就是无标号球放有标号盒子可空放可不放，插板得答案为 <span class=\"math inline\">\\(\\displaystyle {-d_p + n - p\\choose n - p}\\)</span>。</p>\n<p>前后乘起来即为答案。注意不要在最后一步乘起来的时候忘记取模，否则你会获得 76pts 的高分 <img src=\"/em/xk.gif\" /></p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 998244353;\nint main() &#123;\n    freopen(&quot;fate.in&quot;, &quot;r&quot;, stdin);\n    freopen(&quot;fate.out&quot;, &quot;w&quot;, stdout);\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n    int n, m;\n    std::cin &gt;&gt; n;\n    std::vector&lt;long long&gt; a(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i];\n    std::cin &gt;&gt; m;\n    long long res = 1;\n    for (int i = 1; i &lt; m; ++i) &#123;\n        auto x = a[i] - a[i - 1];\n        (res *= x + 1) %= mod;\n    &#125;\n    auto qkp = [](long long x, int y) &#123;\n        long long res = 1;\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    auto C = [&amp;](int n, int m) &#123;\n        long long res = 1ll;\n        for (int i = n; i &gt; n - m; --i)\n            (res *= i) %= mod;\n        for (int i = m; i; --i)\n            (res *= qkp(i, mod - 2)) %= mod;    \n        return res;\n    &#125;;\n    if (m != n)\n        (res *= C(a[m + 1] - a[m] + n - m, n - m)) %= mod;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"c.-abstruse\">C. abstruse</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P9731\" class=\"uri\">https://www.luogu.com.cn/problem/P9731</a></p>\n<p>注意到有挺高的一档 <span class=\"math inline\">\\(S=2\\)</span> 的分，考虑其启示意义。</p>\n<p>我们对于一对 <span class=\"math inline\">\\((a_i, b_i)\\)</span>，在 <span class=\"math inline\">\\(a_i\\)</span> 和 <span class=\"math inline\">\\(b_i\\)</span> 间连边，则原问题转化为给无向图的每条边选择方向，使对于每个 <span class=\"math inline\">\\(x\\)</span>，<span class=\"math inline\">\\(|in_x-out_x|\\le 1\\)</span>。</p>\n<p>我们知道对于一条欧拉回路，有对于任意 <span class=\"math inline\">\\(x\\)</span>，<span class=\"math inline\">\\(in_x=out_x\\)</span>。然后这个时候为了把问题转化成欧拉回路问题我们建一个虚点朝度数为奇的点连条边然后跑欧拉回路即可。</p>\n<p>至于 <span class=\"math inline\">\\(S=2^k\\)</span>，就是在明示分治。即对于任意 <span class=\"math inline\">\\(x\\)</span>，要求其在前后 <span class=\"math inline\">\\(2^{k-1}\\)</span> 次出现次数相差不超过 <span class=\"math inline\">\\(1\\)</span>。注意到非常幸福的有前后两个部分大小相等，又有一个天才的建图，<mark>即在每个点和自己所属的行连边，然后跑欧拉回路，出边表示选前半部分，入边表示选后半部分，这样就保证了一行中各有 <span class=\"math inline\">\\(2^{k-1}\\)</span> 个选前后半部分，也保证了每个点在前后半边出现的次数相差不超过 <span class=\"math inline\">\\(1\\)</span>。对于后面一个性质，分治最终可得到点在每一列出现次数相差不超过 <span class=\"math inline\">\\(1\\)</span></mark>。</p>\n<p>打个当前弧优化然后注意计算细节复杂度然后多卡几（十）遍就过了 <img src=\"/em/dy.gif\" /></p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nnamespace fastIO &#123;\nconst int LEN = (1 &lt;&lt; 20);\n#ifdef ONLINE_JUDGE\nint nec(void) &#123;\n    static char buf[LEN], *p = buf, *e = buf;\n    if (p == e) &#123;\n        e = buf + fread(buf, 1, LEN, stdin);\n        if (e == buf) return EOF;\n        p = buf;\n    &#125;\n    return *p++;\n&#125;\n#else\n#define nec getchar\n#endif\nbool read(int &amp;x) &#123;\n    x = 0;\n    bool f = 0;\n    char ch = nec();\n    while (ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123;\n        if (ch == EOF) return 0;\n        if (ch == &#39;-&#39;) f = 1;\n        ch = nec();\n    &#125;\n    while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) &#123;\n        x = x * 10 + ch - &#39;0&#39;;\n        ch = nec();\n    &#125;\n    if (f) x = -x;\n    return 1;\n&#125;\nvoid print(int x) &#123;\n    if (x &lt; 0)\n        putchar(&#39;-&#39;), x = -x;\n    if (x &gt;= 10) print(x / 10);\n    putchar(x % 10 + &#39;0&#39;);\n    return;\n&#125;\nvoid print(int x, char ch) &#123;\n    print(x), putchar(ch);\n    return;\n&#125;\n&#125; using namespace fastIO;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    std::cout.tie(nullptr);\n    freopen(&quot;abstruse.in&quot;, &quot;r&quot;, stdin);\n    freopen(&quot;abstruse.out&quot;, &quot;w&quot;, stdout);\n#else\n    freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, m, k;\n    read(n), read(m), read(k);\n    std::vector&lt;std::vector&lt;int&gt; &gt; a(n + 1, std::vector&lt;int&gt; (m + 1));\n    for (int i = 1; i &lt;= n; ++i)\n        for (int j = 1; j &lt;= m; ++j)\n            read(a[i][j]);\n    std::vector&lt;int&gt; to(k + n + 1), tag(n * m + n + k + 1);\n    std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; g(k + n + 1); \n    std::function&lt;void(int, int)&gt; calc = [&amp;](int l, int r) &#123;\n        if (l + 1 == r) &#123;\n            for (int i = 1; i &lt;= n; ++i) &#123;\n                g[a[i][l]].emplace_back(a[i][r], i);\n                g[a[i][r]].emplace_back(a[i][l], i);\n            &#125;\n            int cnt = n;\n            for (int i = 1; i &lt;= n; ++i) &#123;\n                if ((int)g[a[i][l]].size() &amp; 1)\n                    g[0].emplace_back(a[i][l], ++cnt), g[a[i][l]].emplace_back(0, cnt);\n                if ((int)g[a[i][r]].size() &amp; 1)\n                    g[0].emplace_back(a[i][r], ++cnt), g[a[i][r]].emplace_back(0, cnt);\n            &#125;\n            std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;\n                for (int i = to[x]; i &lt; (int)g[x].size(); i = to[x]) &#123;\n                    to[x] = i + 1;\n                    auto [v, id] = g[x][i];\n                    if (!tag[id]) &#123;\n                        tag[id] = 1;\n                        if (x &amp;&amp; v)\n                            a[id][l] = x, a[id][r] = v;\n                        DFS(v);\n                    &#125;\n                &#125;\n                return;\n            &#125;;\n            DFS(0);\n            for (int i = 1; i &lt;= n; ++i)\n                DFS(a[i][l]), DFS(a[i][r]);\n            to[0] = 0, g[0].clear();\n            for (int i = 1; i &lt;= n; ++i) &#123;\n                to[a[i][l]] = 0, g[a[i][l]].clear();\n                to[a[i][r]] = 0, g[a[i][r]].clear();\n            &#125;\n            std::fill(tag.begin() + 1, tag.begin() + cnt + 1, 0);\n            return;\n        &#125;\n        int mid = (l + r) &gt;&gt; 1, cnt = 0;\n        std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; g(k + n + 1);\n        for (int i = 1; i &lt;= n; ++i)\n            for (int j = l; j &lt;= r; ++j) &#123;\n                g[a[i][j]].emplace_back(i + k, ++cnt);\n                g[i + k].emplace_back(a[i][j], cnt);\n            &#125;\n        for (int i = 1; i &lt;= n; ++i)\n            for (int j = l; j &lt;= r; ++j)\n                if ((int)g[a[i][j]].size() &amp; 1)\n                    g[0].emplace_back(a[i][j], ++cnt), g[a[i][j]].emplace_back(0, cnt);\n        std::vector&lt;int&gt; L(n + 1, l - 1), R(n + 1, r + 1);\n        std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;\n            for (int i = to[x]; i &lt; (int)g[x].size(); i = to[x]) &#123;\n                to[x] = i + 1;\n                auto [v, id] = g[x][i];\n                if (!tag[id]) &#123;\n                    tag[id] = 1;\n                    if (x &amp;&amp; v) &#123;\n                        if (v &lt;= k)\n                            a[x - k][++L[x - k]] = v;\n                        else\n                            a[v - k][--R[v - k]] = x;\n                    &#125;\n                    DFS(v);\n                &#125;\n            &#125;\n            return;\n        &#125;;\n        DFS(0);\n        for (int i = 1; i &lt;= n; ++i)\n            DFS(i + k);\n        for (int i = 1; i &lt;= n; ++i)\n            for (int j = l; j &lt;= r; ++j)\n                DFS(a[i][j]);\n        to[0] = 0, g[0].clear();\n        for (int i = 1; i &lt;= n; ++i)\n            to[i + k] = 0, g[i + k].clear();\n        for (int i = 1; i &lt;= n; ++i)\n            for (int j = l; j &lt;= r; ++j)\n                to[a[i][j]] = 0, g[a[i][j]].clear();\n        std::fill(tag.begin() + 1, tag.begin() + cnt + 1, 0);\n        calc(l, mid), calc(mid + 1, r);\n        return;\n    &#125;;\n    calc(1, m);\n    for (int i = 1; i &lt;= n; ++i, putchar(&#39;\\n&#39;))\n        for (int j = 1; j &lt;= m; ++j)\n            print(a[i][j], &#39; &#39;);\n    return 0;\n&#125;</code></pre>\n</details>\n",
            "tags": [
                "分治",
                "欧拉回路"
            ]
        }
    ]
}