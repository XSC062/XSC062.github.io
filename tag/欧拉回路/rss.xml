<?xml version="1.0"?>
<rss version="2.0">
    <channel>
        <title> • Posts by &#34;欧拉回路&#34; tag</title>
        <link>https://xsc062.netlify.app</link>
        <description></description>
        <language>zh-CN</language>
        <pubDate>Wed, 16 Oct 2024 20:32:34 +0800</pubDate>
        <lastBuildDate>Wed, 16 Oct 2024 20:32:34 +0800</lastBuildDate>
        <category>并查集</category>
        <category>斜率优化</category>
        <category>悬线法</category>
        <category>哈希</category>
        <category>字典树</category>
        <category>DP</category>
        <category>单调队列</category>
        <category>分治</category>
        <category>计数</category>
        <category>容斥</category>
        <category>二分图</category>
        <category>CRT / exCRT</category>
        <category>排列组合</category>
        <category>网络流</category>
        <category>二分</category>
        <category>容斥原理</category>
        <category>线段树</category>
        <category>树状数组</category>
        <category>区间 DP</category>
        <category>构造</category>
        <category>数据结构</category>
        <category>Tarjan</category>
        <category>下饭</category>
        <category>李超线段树</category>
        <category>树链剖分</category>
        <category>LCA</category>
        <category>倍增</category>
        <category>鸽巢原理</category>
        <category>数学</category>
        <category>调和级数</category>
        <category>差分</category>
        <category>思维</category>
        <category>树形 DP</category>
        <category>最小生成树</category>
        <category>状压</category>
        <category>高维前缀和</category>
        <category>SAM</category>
        <category>分块</category>
        <category>可持久化</category>
        <category>笛卡尔树</category>
        <category>闲话</category>
        <category>欧拉回路</category>
        <category>长链剖分</category>
        <category>KMP</category>
        <category>border</category>
        <category>随机化</category>
        <category>字符串</category>
        <category>AC 自动机</category>
        <category>SA</category>
        <category>树上差分</category>
        <category>FWT</category>
        <category>堆</category>
        <category>树的重心</category>
        <category>贪心</category>
        <category>均摊</category>
        <category>优化建图</category>
        <category>反悔贪心</category>
        <category>调整法</category>
        <category>背包</category>
        <category>博弈论</category>
        <category>DP 优化</category>
        <category>虚树</category>
        <category>点分治</category>
        <category>四边形不等式</category>
        <category>支配对</category>
        <category>DDP</category>
        <category>CDQ 分治</category>
        <category>猫树</category>
        <category>DP 套 DP</category>
        <category>Kruskal 重构树</category>
        <category>高精度</category>
        <category>最短路</category>
        <category>树套树</category>
        <category>二项式反演</category>
        <category>搜索</category>
        <item>
            <guid isPermalink="true">https://xsc062.netlify.app/20241017/</guid>
            <title>模拟赛</title>
            <link>https://xsc062.netlify.app/20241017/</link>
            <category>分治</category>
            <category>欧拉回路</category>
            <pubDate>Wed, 16 Oct 2024 20:32:34 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;好消息：会简单数学题 &lt;img src=&#34;/em/dy.gif&#34; /&gt;&lt;/p&gt;
&lt;p&gt;更好的消息：忘取模了 &lt;img src=&#34;/em/dy.gif&#34; /&gt;&lt;/p&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;a.-distorted&#34;&gt;A. distorted&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.becoder.com.cn/contest/5611/problem/1&#34; class=&#34;uri&#34;&gt;https://www.becoder.com.cn/contest/5611/problem/1&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;考虑最多需要多少个元素。最坏情况是选取四个角的元素，已经可以覆盖整个矩阵。进一步考虑感性反证发现无论如何都选不出来五个，故最多选择四个。&lt;/p&gt;
&lt;p&gt;我们发现，选取中间一个就可以覆盖整个矩阵。扩展一下，选择中间列就可以覆盖上 / 下半个矩阵，选择中间行就可以覆盖左 / 右半个矩阵。剩下的选择过后只能保证照顾到对应的 1/4 矩阵且一定不会完全覆盖其他的 1/4 矩阵。&lt;/p&gt;
&lt;p&gt;我们发现，中心元素地位高于中间行 / 列元素高于左上、左下、右上、右下元素。由此出发讨论选择元素的个数。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1 个：选择中心元素。&lt;/li&gt;
&lt;li&gt;2 个：在中间行的左右两边各选一个 / 在中间列的上下两边各选一个。&lt;/li&gt;
&lt;li&gt;3 个：选一个中间行 / 列 + 两个其他元素，或两个中间行 / 列 + 一个其他元素。&lt;/li&gt;
&lt;li&gt;4 个：左上、左下、右上、右下各选一个。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;统计各个方向的最小值，选最小组合即可。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
#define putchar
const long long inf = 0x3f3f3f3f;
int main() &amp;#123;
    freopen(&amp;quot;distorted.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    freopen(&amp;quot;distorted.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
    int T;
    for (std::cin &amp;gt;&amp;gt; T; T--; ) &amp;#123;
        int n;
        std::cin &amp;gt;&amp;gt; n;
        long long to = inf, u = inf, d = inf, l = inf, r = inf, q = inf, z = inf, p = inf, m = inf;
        for (int i = 1; i &amp;lt;= n; ++i)
            for (int j = 1; j &amp;lt;= n; ++j) &amp;#123;
                long long x;
                std::cin &amp;gt;&amp;gt; x;
                if (i * 2 - 1 == n &amp;amp;&amp;amp; j * 2 - 1 == n)
                    to = x;
                else if (i * 2 - 1 == n &amp;amp;&amp;amp; j * 2 - 1 &amp;lt; n)
                    l = std::min(l, x);
                else if (i * 2 - 1 == n)
                    r = std::min(r, x);
                else if (i * 2 - 1 &amp;lt; n &amp;amp;&amp;amp; j * 2 - 1 == n)
                    u = std::min(u, x);
                else if (j * 2 - 1 == n)
                    d = std::min(d, x);
                else if (i * 2 - 1 &amp;lt; n &amp;amp;&amp;amp; j * 2 - 1 &amp;lt; n)
                    q = std::min(q, x);
                else if (i * 2 - 1 &amp;lt; n)
                    p = std::min(p, x);
                else if (j * 2 - 1 &amp;lt; n)
                    z = std::min(z, x);
                else
                    m = std::min(m, x);
            &amp;#125;
        std::cout &amp;lt;&amp;lt; std::min(&amp;#123; to, l + r, u + d, l + u + m, l + d + p, r + u + z, r + d + q, u + z + m, d + q + p, l + p + m, r + q + z, q + p + z + m &amp;#125;) &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    &amp;#125;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;b.-fate&#34;&gt;B. fate&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.becoder.com.cn/contest/5611/problem/2&#34; class=&#34;uri&#34;&gt;https://www.becoder.com.cn/contest/5611/problem/2&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;诈骗题。对于前半段，考虑取差分数组 &lt;span class=&#34;math inline&#34;&gt;\(d\)&lt;/span&gt;，容易发现如果直接在差分数组上做减法，一定满足后面减得不比前面少。故只要满足差分数组每一项至少为 &lt;span class=&#34;math inline&#34;&gt;\(0\)&lt;/span&gt; 即可，答案为 &lt;span class=&#34;math inline&#34;&gt;\(\prod {i\le p} a_i - a_{i-1} + 1\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;对于后半段，我们考虑转化成和前半段相似的问题，将后半段翻转，同样取差分数组，则此时在该差分数组上满足后面减得不比前面少，同时需要满足差分数组每一项至多为 &lt;span class=&#34;math inline&#34;&gt;\(0\)&lt;/span&gt;，前面的所有项初始为负，操作为减，自然满足；但第 &lt;span class=&#34;math inline&#34;&gt;\(p\)&lt;/span&gt; 项在把前面减去的全部加上后不一定满足。故前面最多减去 &lt;span class=&#34;math inline&#34;&gt;\(d_p\)&lt;/span&gt;，随便在哪里减都无所谓，组合意义一下，就是无标号球放有标号盒子可空放可不放，插板得答案为 &lt;span class=&#34;math inline&#34;&gt;\(\displaystyle {-d_p + n - p\choose n - p}\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;前后乘起来即为答案。注意不要在最后一步乘起来的时候忘记取模，否则你会获得 76pts 的高分 &lt;img src=&#34;/em/xk.gif&#34; /&gt;&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int mod = 998244353;
int main() &amp;#123;
    freopen(&amp;quot;fate.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    freopen(&amp;quot;fate.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
    int n, m;
    std::cin &amp;gt;&amp;gt; n;
    std::vector&amp;lt;long long&amp;gt; a(n + 1);
    for (int i = 1; i &amp;lt;= n; ++i)
        std::cin &amp;gt;&amp;gt; a[i];
    std::cin &amp;gt;&amp;gt; m;
    long long res = 1;
    for (int i = 1; i &amp;lt; m; ++i) &amp;#123;
        auto x = a[i] - a[i - 1];
        (res *= x + 1) %= mod;
    &amp;#125;
    auto qkp = [](long long x, int y) &amp;#123;
        long long res = 1;
        for (; y; (x *= x) %= mod, y &amp;gt;&amp;gt;= 1)
            if (y &amp;amp; 1)
                (res *= x) %= mod;
        return res;
    &amp;#125;;
    auto C = [&amp;amp;](int n, int m) &amp;#123;
        long long res = 1ll;
        for (int i = n; i &amp;gt; n - m; --i)
            (res *= i) %= mod;
        for (int i = m; i; --i)
            (res *= qkp(i, mod - 2)) %= mod;    
        return res;
    &amp;#125;;
    if (m != n)
        (res *= C(a[m + 1] - a[m] + n - m, n - m)) %= mod;
    std::cout &amp;lt;&amp;lt; res &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;c.-abstruse&#34;&gt;C. abstruse&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P9731&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P9731&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;注意到有挺高的一档 &lt;span class=&#34;math inline&#34;&gt;\(S=2\)&lt;/span&gt; 的分，考虑其启示意义。&lt;/p&gt;
&lt;p&gt;我们对于一对 &lt;span class=&#34;math inline&#34;&gt;\((a_i, b_i)\)&lt;/span&gt;，在 &lt;span class=&#34;math inline&#34;&gt;\(a_i\)&lt;/span&gt; 和 &lt;span class=&#34;math inline&#34;&gt;\(b_i\)&lt;/span&gt; 间连边，则原问题转化为给无向图的每条边选择方向，使对于每个 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt;，&lt;span class=&#34;math inline&#34;&gt;\(|in_x-out_x|\le 1\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;我们知道对于一条欧拉回路，有对于任意 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt;，&lt;span class=&#34;math inline&#34;&gt;\(in_x=out_x\)&lt;/span&gt;。然后这个时候为了把问题转化成欧拉回路问题我们建一个虚点朝度数为奇的点连条边然后跑欧拉回路即可。&lt;/p&gt;
&lt;p&gt;至于 &lt;span class=&#34;math inline&#34;&gt;\(S=2^k\)&lt;/span&gt;，就是在明示分治。即对于任意 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt;，要求其在前后 &lt;span class=&#34;math inline&#34;&gt;\(2^{k-1}\)&lt;/span&gt; 次出现次数相差不超过 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt;。注意到非常幸福的有前后两个部分大小相等，又有一个天才的建图，&lt;mark&gt;即在每个点和自己所属的行连边，然后跑欧拉回路，出边表示选前半部分，入边表示选后半部分，这样就保证了一行中各有 &lt;span class=&#34;math inline&#34;&gt;\(2^{k-1}\)&lt;/span&gt; 个选前后半部分，也保证了每个点在前后半边出现的次数相差不超过 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt;。对于后面一个性质，分治最终可得到点在每一列出现次数相差不超过 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt;&lt;/mark&gt;。&lt;/p&gt;
&lt;p&gt;打个当前弧优化然后注意计算细节复杂度然后多卡几（十）遍就过了 &lt;img src=&#34;/em/dy.gif&#34; /&gt;&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
namespace fastIO &amp;#123;
const int LEN = (1 &amp;lt;&amp;lt; 20);
#ifdef ONLINE_JUDGE
int nec(void) &amp;#123;
    static char buf[LEN], *p = buf, *e = buf;
    if (p == e) &amp;#123;
        e = buf + fread(buf, 1, LEN, stdin);
        if (e == buf) return EOF;
        p = buf;
    &amp;#125;
    return *p++;
&amp;#125;
#else
#define nec getchar
#endif
bool read(int &amp;amp;x) &amp;#123;
    x = 0;
    bool f = 0;
    char ch = nec();
    while (ch &amp;lt; &amp;#39;0&amp;#39; || ch &amp;gt; &amp;#39;9&amp;#39;) &amp;#123;
        if (ch == EOF) return 0;
        if (ch == &amp;#39;-&amp;#39;) f = 1;
        ch = nec();
    &amp;#125;
    while (ch &amp;gt;= &amp;#39;0&amp;#39; &amp;amp;&amp;amp; ch &amp;lt;= &amp;#39;9&amp;#39;) &amp;#123;
        x = x * 10 + ch - &amp;#39;0&amp;#39;;
        ch = nec();
    &amp;#125;
    if (f) x = -x;
    return 1;
&amp;#125;
void print(int x) &amp;#123;
    if (x &amp;lt; 0)
        putchar(&amp;#39;-&amp;#39;), x = -x;
    if (x &amp;gt;= 10) print(x / 10);
    putchar(x % 10 + &amp;#39;0&amp;#39;);
    return;
&amp;#125;
void print(int x, char ch) &amp;#123;
    print(x), putchar(ch);
    return;
&amp;#125;
&amp;#125; using namespace fastIO;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    std::cout.tie(nullptr);
    freopen(&amp;quot;abstruse.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    freopen(&amp;quot;abstruse.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#else
    freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#endif
    int n, m, k;
    read(n), read(m), read(k);
    std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; a(n + 1, std::vector&amp;lt;int&amp;gt; (m + 1));
    for (int i = 1; i &amp;lt;= n; ++i)
        for (int j = 1; j &amp;lt;= m; ++j)
            read(a[i][j]);
    std::vector&amp;lt;int&amp;gt; to(k + n + 1), tag(n * m + n + k + 1);
    std::vector&amp;lt;std::vector&amp;lt;std::pair&amp;lt;int, int&amp;gt; &amp;gt; &amp;gt; g(k + n + 1); 
    std::function&amp;lt;void(int, int)&amp;gt; calc = [&amp;amp;](int l, int r) &amp;#123;
        if (l + 1 == r) &amp;#123;
            for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
                g[a[i][l]].emplace_back(a[i][r], i);
                g[a[i][r]].emplace_back(a[i][l], i);
            &amp;#125;
            int cnt = n;
            for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
                if ((int)g[a[i][l]].size() &amp;amp; 1)
                    g[0].emplace_back(a[i][l], ++cnt), g[a[i][l]].emplace_back(0, cnt);
                if ((int)g[a[i][r]].size() &amp;amp; 1)
                    g[0].emplace_back(a[i][r], ++cnt), g[a[i][r]].emplace_back(0, cnt);
            &amp;#125;
            std::function&amp;lt;void(int)&amp;gt; DFS = [&amp;amp;](int x) &amp;#123;
                for (int i = to[x]; i &amp;lt; (int)g[x].size(); i = to[x]) &amp;#123;
                    to[x] = i + 1;
                    auto [v, id] = g[x][i];
                    if (!tag[id]) &amp;#123;
                        tag[id] = 1;
                        if (x &amp;amp;&amp;amp; v)
                            a[id][l] = x, a[id][r] = v;
                        DFS(v);
                    &amp;#125;
                &amp;#125;
                return;
            &amp;#125;;
            DFS(0);
            for (int i = 1; i &amp;lt;= n; ++i)
                DFS(a[i][l]), DFS(a[i][r]);
            to[0] = 0, g[0].clear();
            for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
                to[a[i][l]] = 0, g[a[i][l]].clear();
                to[a[i][r]] = 0, g[a[i][r]].clear();
            &amp;#125;
            std::fill(tag.begin() + 1, tag.begin() + cnt + 1, 0);
            return;
        &amp;#125;
        int mid = (l + r) &amp;gt;&amp;gt; 1, cnt = 0;
        std::vector&amp;lt;std::vector&amp;lt;std::pair&amp;lt;int, int&amp;gt; &amp;gt; &amp;gt; g(k + n + 1);
        for (int i = 1; i &amp;lt;= n; ++i)
            for (int j = l; j &amp;lt;= r; ++j) &amp;#123;
                g[a[i][j]].emplace_back(i + k, ++cnt);
                g[i + k].emplace_back(a[i][j], cnt);
            &amp;#125;
        for (int i = 1; i &amp;lt;= n; ++i)
            for (int j = l; j &amp;lt;= r; ++j)
                if ((int)g[a[i][j]].size() &amp;amp; 1)
                    g[0].emplace_back(a[i][j], ++cnt), g[a[i][j]].emplace_back(0, cnt);
        std::vector&amp;lt;int&amp;gt; L(n + 1, l - 1), R(n + 1, r + 1);
        std::function&amp;lt;void(int)&amp;gt; DFS = [&amp;amp;](int x) &amp;#123;
            for (int i = to[x]; i &amp;lt; (int)g[x].size(); i = to[x]) &amp;#123;
                to[x] = i + 1;
                auto [v, id] = g[x][i];
                if (!tag[id]) &amp;#123;
                    tag[id] = 1;
                    if (x &amp;amp;&amp;amp; v) &amp;#123;
                        if (v &amp;lt;= k)
                            a[x - k][++L[x - k]] = v;
                        else
                            a[v - k][--R[v - k]] = x;
                    &amp;#125;
                    DFS(v);
                &amp;#125;
            &amp;#125;
            return;
        &amp;#125;;
        DFS(0);
        for (int i = 1; i &amp;lt;= n; ++i)
            DFS(i + k);
        for (int i = 1; i &amp;lt;= n; ++i)
            for (int j = l; j &amp;lt;= r; ++j)
                DFS(a[i][j]);
        to[0] = 0, g[0].clear();
        for (int i = 1; i &amp;lt;= n; ++i)
            to[i + k] = 0, g[i + k].clear();
        for (int i = 1; i &amp;lt;= n; ++i)
            for (int j = l; j &amp;lt;= r; ++j)
                to[a[i][j]] = 0, g[a[i][j]].clear();
        std::fill(tag.begin() + 1, tag.begin() + cnt + 1, 0);
        calc(l, mid), calc(mid + 1, r);
        return;
    &amp;#125;;
    calc(1, m);
    for (int i = 1; i &amp;lt;= n; ++i, putchar(&amp;#39;\n&amp;#39;))
        for (int j = 1; j &amp;lt;= m; ++j)
            print(a[i][j], &amp;#39; &amp;#39;);
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
 ]]></description>
        </item>
    </channel>
</rss>
