<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://xsc062.netlify.app</id>
    <title> • Posts by &#34;欧拉回路&#34; tag</title>
    <link href="https://xsc062.netlify.app" />
    <updated>2024-10-16T12:32:34.000Z</updated>
    <category term="并查集" />
    <category term="斜率优化" />
    <category term="悬线法" />
    <category term="哈希" />
    <category term="字典树" />
    <category term="DP" />
    <category term="单调队列" />
    <category term="分治" />
    <category term="二分图" />
    <category term="CRT / exCRT" />
    <category term="排列组合" />
    <category term="网络流" />
    <category term="费用流" />
    <category term="二分" />
    <category term="上下界网络流" />
    <category term="容斥原理" />
    <category term="线段树" />
    <category term="树状数组" />
    <category term="区间 DP" />
    <category term="构造" />
    <category term="Tarjan" />
    <category term="数据结构" />
    <category term="下饭" />
    <category term="LCA" />
    <category term="倍增" />
    <category term="鸽巢原理" />
    <category term="概率期望" />
    <category term="调和级数" />
    <category term="差分" />
    <category term="思维" />
    <category term="树形 DP" />
    <category term="最小生成树" />
    <category term="SAM" />
    <category term="状压" />
    <category term="分块" />
    <category term="可持久化" />
    <category term="笛卡尔树" />
    <category term="高维前缀和" />
    <category term="闲话" />
    <category term="欧拉回路" />
    <category term="树链剖分" />
    <category term="长链剖分" />
    <category term="KMP" />
    <category term="border" />
    <category term="字符串" />
    <category term="AC 自动机" />
    <category term="SA" />
    <category term="数学" />
    <category term="树上差分" />
    <category term="FWT" />
    <category term="堆" />
    <category term="树的重心" />
    <category term="二项式定理" />
    <category term="二项式反演" />
    <category term="贪心" />
    <category term="均摊" />
    <category term="计数" />
    <category term="优化建图" />
    <category term="反悔贪心" />
    <category term="调整法" />
    <category term="背包" />
    <category term="博弈论" />
    <category term="DP 优化" />
    <category term="虚树" />
    <category term="点分治" />
    <category term="WQS 二分" />
    <category term="闵可夫斯基和" />
    <category term="slope trick" />
    <category term="四边形不等式" />
    <category term="暴力" />
    <category term="状压 DP" />
    <category term="组合数学" />
    <category term="支配对" />
    <category term="DDP" />
    <category term="平衡树" />
    <category term="容斥" />
    <category term="猫树" />
    <category term="Kruskal 重构树" />
    <category term="李超线段树" />
    <entry>
        <id>https://xsc062.netlify.app/20241017/</id>
        <title>模拟赛</title>
        <link rel="alternate" href="https://xsc062.netlify.app/20241017/"/>
        <content type="html">&lt;p&gt;好消息：会简单数学题 &lt;img src=&#34;/em/dy.gif&#34; /&gt;&lt;/p&gt;
&lt;p&gt;更好的消息：忘取模了 &lt;img src=&#34;/em/dy.gif&#34; /&gt;&lt;/p&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;a.-distorted&#34;&gt;A. distorted&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;http://222.180.160.110:61235/contest/5611/problem/1&#34; class=&#34;uri&#34;&gt;http://222.180.160.110:61235/contest/5611/problem/1&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;考虑最多需要多少个元素。最坏情况是选取四个角的元素，已经可以覆盖整个矩阵。进一步考虑感性反证发现无论如何都选不出来五个，故最多选择四个。&lt;/p&gt;
&lt;p&gt;我们发现，选取中间一个就可以覆盖整个矩阵。扩展一下，选择中间列就可以覆盖上 / 下半个矩阵，选择中间行就可以覆盖左 / 右半个矩阵。剩下的选择过后只能保证照顾到对应的 1/4 矩阵且一定不会完全覆盖其他的 1/4 矩阵。&lt;/p&gt;
&lt;p&gt;我们发现，中心元素地位高于中间行 / 列元素高于左上、左下、右上、右下元素。由此出发讨论选择元素的个数。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1 个：选择中心元素。&lt;/li&gt;
&lt;li&gt;2 个：在中间行的左右两边各选一个 / 在中间列的上下两边各选一个。&lt;/li&gt;
&lt;li&gt;3 个：选一个中间行 / 列 + 两个其他元素，或两个中间行 / 列 + 一个其他元素。&lt;/li&gt;
&lt;li&gt;4 个：左上、左下、右上、右下各选一个。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;统计各个方向的最小值，选最小组合即可。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
#define putchar
const long long inf = 0x3f3f3f3f;
int main() &amp;#123;
    freopen(&amp;quot;distorted.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    freopen(&amp;quot;distorted.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
    int T;
    for (std::cin &amp;gt;&amp;gt; T; T--; ) &amp;#123;
        int n;
        std::cin &amp;gt;&amp;gt; n;
        long long to = inf, u = inf, d = inf, l = inf, r = inf, q = inf, z = inf, p = inf, m = inf;
        for (int i = 1; i &amp;lt;= n; ++i)
            for (int j = 1; j &amp;lt;= n; ++j) &amp;#123;
                long long x;
                std::cin &amp;gt;&amp;gt; x;
                if (i * 2 - 1 == n &amp;amp;&amp;amp; j * 2 - 1 == n)
                    to = x;
                else if (i * 2 - 1 == n &amp;amp;&amp;amp; j * 2 - 1 &amp;lt; n)
                    l = std::min(l, x);
                else if (i * 2 - 1 == n)
                    r = std::min(r, x);
                else if (i * 2 - 1 &amp;lt; n &amp;amp;&amp;amp; j * 2 - 1 == n)
                    u = std::min(u, x);
                else if (j * 2 - 1 == n)
                    d = std::min(d, x);
                else if (i * 2 - 1 &amp;lt; n &amp;amp;&amp;amp; j * 2 - 1 &amp;lt; n)
                    q = std::min(q, x);
                else if (i * 2 - 1 &amp;lt; n)
                    p = std::min(p, x);
                else if (j * 2 - 1 &amp;lt; n)
                    z = std::min(z, x);
                else
                    m = std::min(m, x);
            &amp;#125;
        std::cout &amp;lt;&amp;lt; std::min(&amp;#123; to, l + r, u + d, l + u + m, l + d + p, r + u + z, r + d + q, u + z + m, d + q + p, l + p + m, r + q + z, q + p + z + m &amp;#125;) &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    &amp;#125;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;b.-fate&#34;&gt;B. fate&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;http://222.180.160.110:61235/contest/5611/problem/2&#34; class=&#34;uri&#34;&gt;http://222.180.160.110:61235/contest/5611/problem/2&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;诈骗题。对于前半段，考虑取差分数组 &lt;span class=&#34;math inline&#34;&gt;\(d\)&lt;/span&gt;，容易发现如果直接在差分数组上做减法，一定满足后面减得不比前面少。故只要满足差分数组每一项至少为 &lt;span class=&#34;math inline&#34;&gt;\(0\)&lt;/span&gt; 即可，答案为 &lt;span class=&#34;math inline&#34;&gt;\(\prod {i\le p} a_i - a_{i-1} + 1\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;对于后半段，我们考虑转化成和前半段相似的问题，将后半段翻转，同样取差分数组，则此时在该差分数组上满足后面减得不比前面少，同时需要满足差分数组每一项至多为 &lt;span class=&#34;math inline&#34;&gt;\(0\)&lt;/span&gt;，前面的所有项初始为负，操作为减，自然满足；但第 &lt;span class=&#34;math inline&#34;&gt;\(p\)&lt;/span&gt; 项在把前面减去的全部加上后不一定满足。故前面最多减去 &lt;span class=&#34;math inline&#34;&gt;\(d_p\)&lt;/span&gt;，随便在哪里减都无所谓，组合意义一下，就是无标号球放有标号盒子可空放可不放，插板得答案为 &lt;span class=&#34;math inline&#34;&gt;\(\displaystyle {-d_p + n - p\choose n - p}\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;前后乘起来即为答案。注意不要在最后一步乘起来的时候忘记取模，否则你会获得 76pts 的高分 &lt;img src=&#34;/em/xk.gif&#34; /&gt;&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int mod = 998244353;
int main() &amp;#123;
    freopen(&amp;quot;fate.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    freopen(&amp;quot;fate.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
    int n, m;
    std::cin &amp;gt;&amp;gt; n;
    std::vector&amp;lt;long long&amp;gt; a(n + 1);
    for (int i = 1; i &amp;lt;= n; ++i)
        std::cin &amp;gt;&amp;gt; a[i];
    std::cin &amp;gt;&amp;gt; m;
    long long res = 1;
    for (int i = 1; i &amp;lt; m; ++i) &amp;#123;
        auto x = a[i] - a[i - 1];
        (res *= x + 1) %= mod;
    &amp;#125;
    auto qkp = [](long long x, int y) &amp;#123;
        long long res = 1;
        for (; y; (x *= x) %= mod, y &amp;gt;&amp;gt;= 1)
            if (y &amp;amp; 1)
                (res *= x) %= mod;
        return res;
    &amp;#125;;
    auto C = [&amp;amp;](int n, int m) &amp;#123;
        long long res = 1ll;
        for (int i = n; i &amp;gt; n - m; --i)
            (res *= i) %= mod;
        for (int i = m; i; --i)
            (res *= qkp(i, mod - 2)) %= mod;    
        return res;
    &amp;#125;;
    if (m != n)
        (res *= C(a[m + 1] - a[m] + n - m, n - m)) %= mod;
    std::cout &amp;lt;&amp;lt; res &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;c.-abstruse&#34;&gt;C. abstruse&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P9731&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P9731&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;注意到有挺高的一档 &lt;span class=&#34;math inline&#34;&gt;\(S=2\)&lt;/span&gt; 的分，考虑其启示意义。&lt;/p&gt;
&lt;p&gt;我们对于一对 &lt;span class=&#34;math inline&#34;&gt;\((a_i, b_i)\)&lt;/span&gt;，在 &lt;span class=&#34;math inline&#34;&gt;\(a_i\)&lt;/span&gt; 和 &lt;span class=&#34;math inline&#34;&gt;\(b_i\)&lt;/span&gt; 间连边，则原问题转化为给无向图的每条边选择方向，使对于每个 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt;，&lt;span class=&#34;math inline&#34;&gt;\(|in_x-out_x|\le 1\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;我们知道对于一条欧拉回路，有对于任意 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt;，&lt;span class=&#34;math inline&#34;&gt;\(in_x=out_x\)&lt;/span&gt;。然后这个时候为了把问题转化成欧拉回路问题我们建一个虚点朝度数为奇的点连条边然后跑欧拉回路即可。&lt;/p&gt;
&lt;p&gt;至于 &lt;span class=&#34;math inline&#34;&gt;\(S=2^k\)&lt;/span&gt;，就是在明示分治。即对于任意 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt;，要求其在前后 &lt;span class=&#34;math inline&#34;&gt;\(2^{k-1}\)&lt;/span&gt; 次出现次数相差不超过 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt;。注意到非常幸福的有前后两个部分大小相等，又有一个天才的建图，&lt;mark&gt;即在每个点和自己所属的行连边，然后跑欧拉回路，出边表示选前半部分，入边表示选后半部分，这样就保证了一行中各有 &lt;span class=&#34;math inline&#34;&gt;\(2^{k-1}\)&lt;/span&gt; 个选前后半部分，也保证了每个点在前后半边出现的次数相差不超过 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt;。对于后面一个性质，分治最终可得到点在每一列出现次数相差不超过 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt;&lt;/mark&gt;。&lt;/p&gt;
&lt;p&gt;打个当前弧优化然后注意计算细节复杂度然后多卡几（十）遍就过了 &lt;img src=&#34;/em/dy.gif&#34; /&gt;&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
namespace fastIO &amp;#123;
const int LEN = (1 &amp;lt;&amp;lt; 20);
#ifdef ONLINE_JUDGE
int nec(void) &amp;#123;
    static char buf[LEN], *p = buf, *e = buf;
    if (p == e) &amp;#123;
        e = buf + fread(buf, 1, LEN, stdin);
        if (e == buf) return EOF;
        p = buf;
    &amp;#125;
    return *p++;
&amp;#125;
#else
#define nec getchar
#endif
bool read(int &amp;amp;x) &amp;#123;
    x = 0;
    bool f = 0;
    char ch = nec();
    while (ch &amp;lt; &amp;#39;0&amp;#39; || ch &amp;gt; &amp;#39;9&amp;#39;) &amp;#123;
        if (ch == EOF) return 0;
        if (ch == &amp;#39;-&amp;#39;) f = 1;
        ch = nec();
    &amp;#125;
    while (ch &amp;gt;= &amp;#39;0&amp;#39; &amp;amp;&amp;amp; ch &amp;lt;= &amp;#39;9&amp;#39;) &amp;#123;
        x = x * 10 + ch - &amp;#39;0&amp;#39;;
        ch = nec();
    &amp;#125;
    if (f) x = -x;
    return 1;
&amp;#125;
void print(int x) &amp;#123;
    if (x &amp;lt; 0)
        putchar(&amp;#39;-&amp;#39;), x = -x;
    if (x &amp;gt;= 10) print(x / 10);
    putchar(x % 10 + &amp;#39;0&amp;#39;);
    return;
&amp;#125;
void print(int x, char ch) &amp;#123;
    print(x), putchar(ch);
    return;
&amp;#125;
&amp;#125; using namespace fastIO;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    std::cout.tie(nullptr);
    freopen(&amp;quot;abstruse.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    freopen(&amp;quot;abstruse.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#else
    freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#endif
    int n, m, k;
    read(n), read(m), read(k);
    std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; a(n + 1, std::vector&amp;lt;int&amp;gt; (m + 1));
    for (int i = 1; i &amp;lt;= n; ++i)
        for (int j = 1; j &amp;lt;= m; ++j)
            read(a[i][j]);
    std::vector&amp;lt;int&amp;gt; to(k + n + 1), tag(n * m + n + k + 1);
    std::vector&amp;lt;std::vector&amp;lt;std::pair&amp;lt;int, int&amp;gt; &amp;gt; &amp;gt; g(k + n + 1); 
    std::function&amp;lt;void(int, int)&amp;gt; calc = [&amp;amp;](int l, int r) &amp;#123;
        if (l + 1 == r) &amp;#123;
            for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
                g[a[i][l]].emplace_back(a[i][r], i);
                g[a[i][r]].emplace_back(a[i][l], i);
            &amp;#125;
            int cnt = n;
            for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
                if ((int)g[a[i][l]].size() &amp;amp; 1)
                    g[0].emplace_back(a[i][l], ++cnt), g[a[i][l]].emplace_back(0, cnt);
                if ((int)g[a[i][r]].size() &amp;amp; 1)
                    g[0].emplace_back(a[i][r], ++cnt), g[a[i][r]].emplace_back(0, cnt);
            &amp;#125;
            std::function&amp;lt;void(int)&amp;gt; DFS = [&amp;amp;](int x) &amp;#123;
                for (int i = to[x]; i &amp;lt; (int)g[x].size(); i = to[x]) &amp;#123;
                    to[x] = i + 1;
                    auto [v, id] = g[x][i];
                    if (!tag[id]) &amp;#123;
                        tag[id] = 1;
                        if (x &amp;amp;&amp;amp; v)
                            a[id][l] = x, a[id][r] = v;
                        DFS(v);
                    &amp;#125;
                &amp;#125;
                return;
            &amp;#125;;
            DFS(0);
            for (int i = 1; i &amp;lt;= n; ++i)
                DFS(a[i][l]), DFS(a[i][r]);
            to[0] = 0, g[0].clear();
            for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
                to[a[i][l]] = 0, g[a[i][l]].clear();
                to[a[i][r]] = 0, g[a[i][r]].clear();
            &amp;#125;
            std::fill(tag.begin() + 1, tag.begin() + cnt + 1, 0);
            return;
        &amp;#125;
        int mid = (l + r) &amp;gt;&amp;gt; 1, cnt = 0;
        std::vector&amp;lt;std::vector&amp;lt;std::pair&amp;lt;int, int&amp;gt; &amp;gt; &amp;gt; g(k + n + 1);
        for (int i = 1; i &amp;lt;= n; ++i)
            for (int j = l; j &amp;lt;= r; ++j) &amp;#123;
                g[a[i][j]].emplace_back(i + k, ++cnt);
                g[i + k].emplace_back(a[i][j], cnt);
            &amp;#125;
        for (int i = 1; i &amp;lt;= n; ++i)
            for (int j = l; j &amp;lt;= r; ++j)
                if ((int)g[a[i][j]].size() &amp;amp; 1)
                    g[0].emplace_back(a[i][j], ++cnt), g[a[i][j]].emplace_back(0, cnt);
        std::vector&amp;lt;int&amp;gt; L(n + 1, l - 1), R(n + 1, r + 1);
        std::function&amp;lt;void(int)&amp;gt; DFS = [&amp;amp;](int x) &amp;#123;
            for (int i = to[x]; i &amp;lt; (int)g[x].size(); i = to[x]) &amp;#123;
                to[x] = i + 1;
                auto [v, id] = g[x][i];
                if (!tag[id]) &amp;#123;
                    tag[id] = 1;
                    if (x &amp;amp;&amp;amp; v) &amp;#123;
                        if (v &amp;lt;= k)
                            a[x - k][++L[x - k]] = v;
                        else
                            a[v - k][--R[v - k]] = x;
                    &amp;#125;
                    DFS(v);
                &amp;#125;
            &amp;#125;
            return;
        &amp;#125;;
        DFS(0);
        for (int i = 1; i &amp;lt;= n; ++i)
            DFS(i + k);
        for (int i = 1; i &amp;lt;= n; ++i)
            for (int j = l; j &amp;lt;= r; ++j)
                DFS(a[i][j]);
        to[0] = 0, g[0].clear();
        for (int i = 1; i &amp;lt;= n; ++i)
            to[i + k] = 0, g[i + k].clear();
        for (int i = 1; i &amp;lt;= n; ++i)
            for (int j = l; j &amp;lt;= r; ++j)
                to[a[i][j]] = 0, g[a[i][j]].clear();
        std::fill(tag.begin() + 1, tag.begin() + cnt + 1, 0);
        calc(l, mid), calc(mid + 1, r);
        return;
    &amp;#125;;
    calc(1, m);
    for (int i = 1; i &amp;lt;= n; ++i, putchar(&amp;#39;\n&amp;#39;))
        for (int j = 1; j &amp;lt;= m; ++j)
            print(a[i][j], &amp;#39; &amp;#39;);
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
</content>
        <category term="分治" />
        <category term="欧拉回路" />
        <updated>2024-10-16T12:32:34.000Z</updated>
    </entry>
</feed>
