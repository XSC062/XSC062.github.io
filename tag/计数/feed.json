{
    "version": "https://jsonfeed.org/version/1",
    "title": "null • All posts by \"计数\" tag",
    "description": "",
    "home_page_url": "https://xsc062.netlify.app",
    "items": [
        {
            "id": "https://xsc062.netlify.app/20250430/",
            "url": "https://xsc062.netlify.app/20250430/",
            "title": "连通图计数",
            "date_published": "2025-04-30T02:31:11.000Z",
            "content_html": "<figure>\n<img src=\"/20250430/neko.png\" alt=\"猫\" style=\"width: 75px\">\n<figcaption>\n猫\n</figcaption>\n</figure>\n<span id=\"more\"></span>\n<p>太可怕了！2025 年才过去 4 个月，正经文章的总数已经和 2024 年中正经文章的总数一样多了。</p>\n<hr />\n<h2 id=\"有标号无向图计数\">有标号无向图计数</h2>\n<p>问题模型大概如下：</p>\n<blockquote>\n<p>给定 <span class=\"math inline\">\\(N\\)</span> 个点，你可以在它们间任意连边，但存在限制：</p>\n<ul>\n<li>其中一个较好处理（如要求图必须是二分图）；</li>\n<li>另一个较难处理（如去重问题等）；</li>\n<li>最后，可能要求图连通。</li>\n</ul>\n</blockquote>\n<p>首先需要知道怎么处理这样的计数问题。以下皆建立在无重边、自环的基础上。</p>\n<ol type=\"1\">\n<li><p>先只考虑容易的限制，且不要求连通：</p>\n<p><em>注：如果发现 <strong>不连通</strong> 的时候没办法很方便地计算精确方案数（也就是说会算重），那么可以把 <strong>去重</strong> 作为较难的限制，这一步算重就不重要了</em>。</p>\n<p>该怎么求怎么求。例如，若该限制是二分图且可以算重，枚举左部点数及边，那么方案数就是 <span class=\"math inline\">\\(\\sum\\limits_{i=0}^n C_n^i\\cdot C_{i\\cdot (n-i)}^m\\)</span>。</p>\n这个时候需要注意到算重部分的意义是什么。比如此处，计算中一个连通块将左右部翻转后被视作不同的子图，但在全局看来对应的总图是同一个二分图。因此，对于拥有 <span class=\"math inline\">\\(k\\)</span> 个连通块的图，其被计算了 <span class=\"math inline\">\\(2^k\\)</span> 次。</li>\n<li><p>再加上必须连通的限制，仍只考虑容易的限制：</p>\n<p>如果不存在其他限制，那么就是 <a href=\"https://oeis.org/A001187\">A001187</a>。</p>\n<p>连通的方案就是任意的方案减去不连通的方案。</p>\n<ul>\n<li>任意的求法就是第一点；</li>\n<li>不连通的方案，枚举 <span class=\"math inline\">\\(1\\)</span> 所在子集，让其补集里面任意连边（第 1 点的子问题）且不和 <span class=\"math inline\">\\(1\\)</span> 所在子集相连。</li>\n</ul></li>\n<li><p>接着，对连通的情况应用较难处理的限制：</p>\n<p><em>因为连通会带来一些比较好的性质简化运算，所以选择在这一步加上较难的限制</em>。</p>\n例如，对于上文中二分图去重的例子，连通图中显然只有一个连通块，将连通图的方案 <span class=\"math inline\">\\(\\div 2\\)</span> 就可以得到答案。</li>\n<li><p>最后，如果题目要求任意图的方案，用第三步中的答案再次算出任意图的答案。</p>\n<p>相当于是把第 2 点中的过程反过来，枚举 <span class=\"math inline\">\\(1\\)</span> 所在子集，在其补集中任意连边（该问的子问题）且可以和 <span class=\"math inline\">\\(1\\)</span> 所在的子集连边。</p></li>\n</ol>\n<p>这样就可以解决问题。</p>\n<hr />\n<h3 id=\"a---many-good-tuple-problems\">A - Many Good Tuple Problems</h3>\n<p><a href=\"https://atcoder.jp/contests/abc327/tasks/abc327_g\" class=\"uri\">https://atcoder.jp/contests/abc327/tasks/abc327_g</a></p>\n<p>如果把一组 <span class=\"math inline\">\\((S_i,T_i)\\)</span> 看作一条边的话，原限制就可以转化为：在 <span class=\"math inline\">\\(N\\)</span> 个点中连 <span class=\"math inline\">\\(M\\)</span> 条可重边，形成二分图的方案数。边有序。</p>\n<p><del>你可以发现我偷懒把这道题拿去上面举例了</del>，由于边是可重的，而我们的模型要求无重边，但发现这个限制是独立于模型外的，也就是可以在最后枚举有多少条不同边，再用一点组合手段计算实际贡献。</p>\n<p>首先令 <span class=\"math inline\">\\(f_{0,n,m}\\)</span> 表示 <span class=\"math inline\">\\(n\\)</span> 个点、<span class=\"math inline\">\\(m\\)</span> 条边、<strong>不去重</strong>、<strong>连通性任意</strong> 的方案数，那么 <span class=\"math inline\">\\(f_{0,n,m}=\\sum_{i=0}^n C_n^i\\cdot C_{i\\cdot (n-i)}^m\\)</span>。</p>\n<p>令 <span class=\"math inline\">\\(f_{1,n,m}\\)</span> 表示 <strong>不去重</strong>、要求 <strong>连通</strong> 的方案，那么有 <span class=\"math inline\">\\(f_{1,n,m}=f_{0,n,m}-\\sum\\limits_{i,j} C_{n - 1}^{i-1}\\cdot f_{1,i,j}\\cdot f_{0,n-i,m-j}\\)</span>。</p>\n<p>令 <span class=\"math inline\">\\(f_{2,n,m}\\)</span> 表示 <strong>去重</strong>，要求 <strong>连通</strong> 的方案，那么有 <span class=\"math inline\">\\(f_{2,n,m}=\\dfrac {f_{1,n,m}}{2}\\)</span>。</p>\n<p>令 <span class=\"math inline\">\\(f_{3,n,m}\\)</span> 表示 <strong>去重</strong>，<strong>连通性任意</strong> 的方案数，那么有 <span class=\"math inline\">\\(f_{3,n,m}=\\sum\\limits_{i,j} C_{n-1}^{i-1} \\cdot f_{2,i,j} \\cdot f_{3,n-i,m-j}\\)</span>。</p>\n<p>最后的方案数为 <span class=\"math inline\">\\(\\sum\\limits_{j} f_{3,n,j}\\cdot F(m,j)\\)</span>。其中 <span class=\"math inline\">\\(F(m,j)\\)</span> 表示把 <span class=\"math inline\">\\(m\\)</span> 个有标号的球放在 <span class=\"math inline\">\\(j\\)</span> 个有标号的盒子里，不空放的方案数，可以容斥。最后注意边反向算两种，所以乘上 <span class=\"math inline\">\\(2^m\\)</span>。</p>\n<p>复杂度 <span class=\"math inline\">\\(O(n^6)\\)</span>。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 998244353;\nconst int inv2 = (mod + 1) &gt;&gt; 1;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, M, m;\n    std::cin &gt;&gt; n &gt;&gt; M, m = std::min(n * (n - 1) / 2, M);\n    std::vector&lt;std::vector&lt;long long&gt; &gt; C(n * n + 1, std::vector&lt;long long&gt; (n * n + 1));\n    for (int i = 0; i &lt;= n * n; ++i) &#123;\n        C[i][0] = 1ll;\n        for (int j = 1; j &lt;= i; ++j)\n            C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % mod;\n    &#125;\n    std::vector&lt;std::vector&lt;std::vector&lt;long long&gt; &gt; &gt; f(4, std::vector&lt;std::vector&lt;long long&gt; &gt; (n + 1, std::vector&lt;long long&gt; (m + 1)));\n    for (int i = 1; i &lt;= n; ++i)\n        for (int j = 0; j &lt;= m &amp;&amp; j &lt;= i * (i - 1) / 2; ++j)\n            for (int k = 0; k &lt;= i; ++k)\n                (f[0][i][j] += C[i][k] * C[k * (i - k)][j]) %= mod;\n    for (int i = 1; i &lt;= n; ++i)\n        for (int j = 0; j &lt;= m; ++j) &#123;\n            auto t(0ll);\n            for (int k = 1; k &lt;= i; ++k)\n                for (int l = 0; l &lt;= j; ++l)\n                    (t += C[i - 1][k - 1] * f[1][k][l] % mod * f[0][i - k][j - l]) %= mod;\n            f[1][i][j] = (f[0][i][j] + mod - t) % mod;\n            f[2][i][j] = f[1][i][j] * inv2 % mod;\n        &#125;\n    f[3][0][0] = 1ll;\n    for (int i = 1; i &lt;= n; ++i)\n        for (int j = 0; j &lt;= m; ++j)\n            for (int k = 1; k &lt;= i; ++k)\n                for (int l = 0; l &lt;= j; ++l)\n                    (f[3][i][j] += C[i - 1][k - 1] * f[2][k][l] % mod * f[3][i - k][j - l]) %= mod;\n    auto qkp = [](long long x, int y) &#123;\n        auto res(1ll);\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    std::vector&lt;long long&gt; F(m + 1);\n    for (int i = 1; i &lt;= m; ++i) &#123;\n        F[i] = qkp(i, M);\n        for (int j = 1, p = mod - 1; j &lt; m; ++j, p = mod - p)\n            (F[i] += p * C[i][j] % mod * qkp(i - j, M)) %= mod;\n    &#125;\n    auto res(0ll);\n    for (int j = 1; j &lt;= m; ++j)\n        (res += f[3][n][j] * F[j]) %= mod;\n    std::cout &lt;&lt; res * qkp(2, M) % mod &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"b---many-mst\">B - Many MST</h3>\n<p><a href=\"https://atcoder.jp/contests/abc386/tasks/abc386_g\" class=\"uri\">https://atcoder.jp/contests/abc386/tasks/abc386_g</a></p>\n<p>这里需要注意到 MST 和连通块的隐含联系。按照 Kruskal 的生成方式可以发现只需要在合并两个连通块时加上它们之间连边中最小的边权就可以得到 MST。</p>\n<p>因此容易想到在 DP 时对最小边权进行限制；枚举 <span class=\"math inline\">\\(k\\)</span>，让边权 <span class=\"math inline\">\\(\\le k\\)</span> 成为简单限制；让求解 MST 成为某种意义上的较难限制。</p>\n<p>令 <span class=\"math inline\">\\(f_{0,n,k}\\)</span> 表示 <span class=\"math inline\">\\(n\\)</span> 个点，边权 <span class=\"math inline\">\\(\\le k\\)</span>、<strong>对连通性没有要求</strong> 的方案数；相应地，<span class=\"math inline\">\\(f_{1,n,k}\\)</span> 表示 <strong>要求连通</strong> 的方案数，则：</p>\n<ul>\n<li><p><span class=\"math inline\">\\(f_{0,n,k}=\\sum\\limits_i C_{n-1}^{i-1}\\cdot f_{1,i,k-1} \\cdot f_{0,n-i,k}\\cdot (M-k+1)^{i\\times(n-i)}\\)</span>。</p>\n<p>注解：式子正确性建立在 <strong><span class=\"math inline\">\\(1\\)</span> 所在 的由权值 <span class=\"math inline\">\\(&lt;k\\)</span> 的边构成的最大连通块 大小为 <span class=\"math inline\">\\(i\\)</span></strong> 的基础之上，故两个连通块之间的边权只能 <span class=\"math inline\">\\(\\ge k\\)</span>。这也提醒我们，此处的 <strong>不连通</strong> 含义实际上是给这些边一个 <span class=\"math inline\">\\((M-k)\\)</span> 的系数。</p>\n那么这样你会注意到，<span class=\"math inline\">\\(f_0\\)</span> 的意义就与 <span class=\"math inline\">\\(k\\)</span> 无关了（那么显然值也与 <span class=\"math inline\">\\(k\\)</span> 无关），但是仍然保留 <span class=\"math inline\">\\(k\\)</span> 对思考有帮助，故留之。</li>\n<li><p><span class=\"math inline\">\\(f_{1,n,k}=f_{0, n, k} - \\sum\\limits_i C_{n - 1}^{i-1} \\cdot f_{1,i,k}\\cdot f_{0,n-i,k}\\times (M-k)^{i\\times (n - i)}\\)</span>。</p></li>\n</ul>\n<p>令 <span class=\"math inline\">\\(g_{0, n, k}\\)</span> 表示 <span class=\"math inline\">\\(n\\)</span> 个点、边权 <span class=\"math inline\">\\(\\le k\\)</span>、<strong>对连通性没有要求</strong> 的 MST 之和；相应地，<span class=\"math inline\">\\(g_{1,n,k}\\)</span> 表示对应条件下 <strong>要求连通</strong> 的 MST 之和。则：</p>\n<ul>\n<li><p><span class=\"math inline\">\\(g_{0,n,k}=\\sum\\limits_{i} C_{n-1}^{i-1}\\cdot (f_{1,i,k - 1}\\cdot g_{0,n-i,k}+g_{1,i,k - 1} \\cdot f_{0,n-i,k}+f_{1,i,k-1}\\cdot f_{0,n-i,k}\\cdot k)\\cdot (M-k+1)^{i\\times (n-i)}\\)</span>。</p>\n注解：类比 <span class=\"math inline\">\\(f_0\\)</span> 的计算方式得到 <span class=\"math inline\">\\(g_0\\)</span>。在 <span class=\"math inline\">\\(i\\times (n-i)\\)</span> 中任选一条作为 MST 上权值为 <span class=\"math inline\">\\(k\\)</span> 的边，故有 <span class=\"math inline\">\\(f_{1,i,k-1}\\cdot f_{0,n-i,k}\\cdot k\\)</span>。之所以必须要求有这么一条边是为了和 <span class=\"math inline\">\\(g_{k-1}\\)</span> 和 <span class=\"math inline\">\\(g_{k+1}\\)</span> 等区分。</li>\n<li><p><span class=\"math inline\">\\(g_{1,n,k}=g_{0,n,k}-\\sum\\limits_i C_{n-1}^{i-1}\\cdot (f_{1,i,k}\\cdot g_{0,n-i,k}+g_{1,i,k}\\cdot f_{0,n-i,k}+f_{1,i,k}\\cdot f_{0,n-i,k}\\cdot k)\\cdot (M-k)^{i\\times (n-i)}\\)</span>。</p></li>\n</ul>\n<p>复杂度 <span class=\"math inline\">\\(O(n^2\\cdot M)\\)</span>。要求预处理幂，不然会 T。以及可能需要把 <span class=\"math inline\">\\(f_0,f_1,g_0,g_1\\)</span> 放在同一个内层循环求，不然会卡常；<del>在此基础上使用内存连续访问优化似乎并不明显</del> <img src=\"/em/kt.gif\" /></p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 998244353;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int N, M;\n    std::cin &gt;&gt; N &gt;&gt; M;\n    using arr = std::vector&lt;long long&gt;;\n    using brr = std::vector&lt;arr&gt;;\n    using crr = std::vector&lt;brr&gt;;\n    crr f(2, brr(N + 1, arr(M + 1))), g(2, brr(N + 1, arr(M + 1)));\n    brr C(N + 1, arr(N + 1)), p(M + 1, arr(N * N + 1));\n    for (int i = 0; i &lt;= M; ++i) &#123;\n        p[i][0] = 1ll;\n        for (int j = 1; j &lt;= N * N; ++j)\n            p[i][j] = p[i][j - 1] * i % mod;\n    &#125;\n    for (int i = 0; i &lt;= N; ++i) &#123;\n        C[i][0] = 1ll;\n        for (int j = 1; j &lt;= i; ++j)\n            C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % mod;\n    &#125;\n    f[1][0][0] = f[1][1][0] = 1ll;\n    for (int n = 1; n &lt;= N; ++n)\n        for (int k = 1; k &lt;= M; ++k) &#123;\n            f[0][n][k] = f[1][n][k - 1];\n            for (int i = 1; i &lt; n; ++i) &#123;\n                (f[0][n][k] += C[n - 1][i - 1] * f[1][i][k - 1] % mod * f[0][n - i][k] % mod * p[M - k + 1][i * (n - i)]) %= mod;\n                (f[1][n][k] += mod - C[n - 1][i - 1] * f[1][i][k] % mod * f[0][n - i][k] % mod * p[M - k][i * (n - i)] % mod) %= mod;\n            &#125;\n            (f[1][n][k] += f[0][n][k]) %= mod;\n        &#125;\n    for (int n = 1; n &lt;= N; ++n)\n        for (int k = 1; k &lt;= M; ++k) &#123;\n            g[0][n][k] = g[1][n][k - 1];\n            for (int i = 1; i &lt; n; ++i) &#123;\n                (g[0][n][k] += (f[1][i][k - 1] * g[0][n - i][k] % mod + g[1][i][k - 1] * f[0][n - i][k] % mod + f[1][i][k - 1] * f[0][n - i][k] % mod * k) % mod * C[n - 1][i - 1] % mod * p[M - k + 1][i * (n - i)]) %= mod;\n                (g[1][n][k] += mod - (f[1][i][k] * g[0][n - i][k] % mod + g[1][i][k] * f[0][n - i][k] % mod + f[1][i][k] * f[0][n - i][k] % mod * k) % mod * C[n - 1][i - 1] % mod * p[M - k][i * (n - i)] % mod) %= mod;\n            &#125;\n            (g[1][n][k] += g[0][n][k]) %= mod;\n        &#125;\n    // for (int n = 1; n &lt;= N; ++n)\n    //     for (int k = 1; k &lt;= M; ++k) &#123;\n    //         printf(&quot;f[0][%d][%d] = %lld\\n&quot;, n, k, f[0][n][k]);\n    //         printf(&quot;f[1][%d][%d] = %lld\\n&quot;, n, k, f[1][n][k]);\n    //         printf(&quot;g[0][%d][%d] = %lld\\n&quot;, n, k, g[0][n][k]);\n    //         printf(&quot;g[1][%d][%d] = %lld\\n&quot;, n, k, g[1][n][k]);\n    //     &#125;\n    std::cout &lt;&lt; g[1][N][M] &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"有标号-dag-计数\">有标号 DAG 计数</h2>\n<blockquote>\n<p>给定 <span class=\"math inline\">\\(N\\)</span> 个点，你可以在它们间任意连边，要求最后图为 DAG，可能要求图弱连通。</p>\n</blockquote>\n<p>如果说无向图计数关键在于连通块，那么 DAG 在此基础上关键在于入度为 <span class=\"math inline\">\\(0\\)</span> 的点集。</p>\n<p>令 <span class=\"math inline\">\\(f(i)\\)</span> 表示 <span class=\"math inline\">\\(i\\)</span> 个点的 DAG 的答案；<span class=\"math inline\">\\(g_{0, i,j}\\)</span> 表示 <span class=\"math inline\">\\(i\\)</span> 个点的 DAG，其中 <span class=\"math inline\">\\(j\\)</span> 个入度为 <span class=\"math inline\">\\(0\\)</span> 的方案，不难想到容斥：令 <span class=\"math inline\">\\(g_{1,i,j}\\)</span> 表示至少 <span class=\"math inline\">\\(j\\)</span> 个的方案，那么：</p>\n<p><span class=\"math display\">\\[\ng_{1,i,j}=C_i^j\\times f(i-j)\\times 2^{j\\times (i-j)}\\\\\ng_{0,i,j}=\\sum_{k=j}^i (-1)^{k-j}\\cdot C_k^j\\cdot g_{1,i,j}\\\\\nf(i)=\\sum_{j=1}^i g_{0,i,j}\n\\]</span></p>\n<p>整理有：</p>\n<p><span class=\"math display\">\\[\n\\begin{aligned}\nf(i)\n&amp;=\\sum_{j=1}^i \\sum_{k=j}^i (-1)^{k-j}\\cdot C_k^j\\cdot g_{1,i,k}\\\\\n&amp;=\\sum_{k=1}^i (-1)^k\\cdot g_{1,i,k}\\cdot \\sum_{j=1}^k (-1)^j\\cdot C_k^j\\\\\n&amp;=\\sum_{k=1}^i (-1)^k\\cdot g_{1,i,k}\\cdot (0^k-1)\\\\\n&amp;=\\sum_{k=1}^i (-1)^{k+1}\\cdot C_i^k\\times f(i-k)\\times 2^{(i-k)}\n\\end{aligned}\n\\]</span></p>\n<p>即得递推式。如果要求连通仿照无向图连通的方法，用任意减去不连通即可。</p>\n<hr />\n<h3 id=\"c---amusement-park\">C - Amusement Park</h3>\n<p><a href=\"https://codeforces.com/problemset/problem/1193/A\" class=\"uri\">https://codeforces.com/problemset/problem/1193/A</a></p>\n<p>先考虑计算方案数。枚举 <span class=\"math inline\">\\(1\\)</span> 所在子集，那么有 <span class=\"math inline\">\\(f(S)=\\sum\\limits_{T\\in S} (-1)^{|T|+1}\\cdot f(S - T)\\)</span>。相较于一般的 DAG 计数，因为每条边取不取是固定的，所以没有了 <span class=\"math inline\">\\(2\\)</span> 的次幂的系数；同时因为直接枚举子集，所以没有了组合系数。</p>\n<p>注意此处 <span class=\"math inline\">\\(T\\)</span> 可构成一轮新的入度为 <span class=\"math inline\">\\(0\\)</span> 的点集当且仅当 <span class=\"math inline\">\\(T\\)</span> 之内没有连边，即 <span class=\"math inline\">\\(T\\)</span> 为独立集。</p>\n<p>算出方案数后如何算答案呢？发现对于一种合法的方案，把里面所有的边反向一定唯一对应另一种合法方案，两种方案取反边数相加为 <span class=\"math inline\">\\(m\\)</span>；那么给所有方案除以 <span class=\"math inline\">\\(2\\)</span>，再乘上 <span class=\"math inline\">\\(m\\)</span> 就能得到答案。</p>\n<p>复杂度 <span class=\"math inline\">\\(O(3^n)\\)</span>。需要提前把每个点集是否独立预处理下来。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 998244353, inv2 = (mod + 1) &gt;&gt; 1;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, m;\n    std::cin &gt;&gt; n &gt;&gt; m;\n    std::vector&lt;int&gt; g(n + 1);\n    for (int i = 1, x, y; i &lt;= m; ++i) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y;\n        g[x] |= (1 &lt;&lt; (y - 1));\n        g[y] |= (1 &lt;&lt; (x - 1));\n    &#125;\n    auto check = [&amp;](int s) &#123;\n        for (int i = 1; i &lt;= n; ++i)\n            if ((s &gt;&gt; (i - 1)) &amp; 1)\n                if (s &amp; g[i])\n                    return false;\n        return true;\n    &#125;;\n    int siz = 1 &lt;&lt; n;\n    std::vector&lt;int&gt; tag(siz);\n    for (int i = 0; i &lt; siz; ++i)\n        tag[i] = check(i);\n    std::vector&lt;long long&gt; f(siz);\n    f[0] = 1ll;\n    for (int i = 1; i &lt; siz; ++i)\n        for (int j = i; j; j = (j - 1) &amp; i)\n            if (tag[j])\n                (f[i] += ((__builtin_popcount(j) &amp; 1) ? 1 : mod - 1) * f[i ^ j]) %= mod;\n    std::cout &lt;&lt; f[siz - 1] * inv2 % mod * m % mod &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"d---balance-scale\">D - Balance Scale</h3>\n<p><a href=\"https://atcoder.jp/contests/abc306/tasks/abc306_h\" class=\"uri\">https://atcoder.jp/contests/abc306/tasks/abc306_h</a></p>\n<p>可以发现，如果将被 <code>=</code> 连起来的点缩起来，就可以转化成上一个问题。但枚举被缩的点集显然是不能通过的，这里介绍一种方法。</p>\n<p>不把缩点放在开头。在上一题中的 DP 式子 <span class=\"math inline\">\\(f(S)=\\sum\\limits_{T\\in S} (-1)^{|T|+1}\\cdot f(S - T)\\)</span> 中，考虑和我们最终的答案有什么差异：</p>\n<ol type=\"1\">\n<li>在现在的问题中，有的边是可以不选的！考虑这会给容斥带来怎样的影响。</li>\n</ol>\n<p>首先应该知道一件事情：你决定把一部分点缩到一起，当且仅当它们全部由 <code>=</code> 连接。要让一些边加入 DP，也就是让它们不是 <code>=</code>，当且仅当它们成为连通块的『割』——把连通块分成多个连通块。这种情况显然已经由另一条路径转移过了。也就是说，就用这个式子可以得到所有答案。 1. 另一个问题，在上一题中，我们可以轻易地判断 <span class=\"math inline\">\\(T\\)</span> 是否为独立集；但在本问中，不是独立集的点集也可能缩点成为独立集。</p>\n<p>发现有一种唯一方法，就是使 <span class=\"math inline\">\\(T\\)</span> 中位于同一连通块的点缩到一起；所以应该将 <span class=\"math inline\">\\(-1\\)</span> 的次数替换为 <span class=\"math inline\">\\(T\\)</span> 所在连通块个数 <span class=\"math inline\">\\(+1\\)</span>。</p>\n<p>注意这里说的连通块是 <span class=\"math inline\">\\(T\\)</span> 的导出子图中的连通块。</p>\n<p>这也启示我们不要把缩点和图的连通性等等关联得太死，需要把点等价的场景都可能用到缩点。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 998244353, inv2 = (mod + 1) &gt;&gt; 1;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, m;\n    std::cin &gt;&gt; n &gt;&gt; m;\n    std::vector&lt;int&gt; fa(n + 1);\n    std::function&lt;int(int)&gt; find = [&amp;](int x) &#123;\n        return fa[x] == x ? x : fa[x] = find(fa[x]);\n    &#125;;\n    auto merge = [&amp;](int x, int y) &#123;\n        fa[find(x)] = find(y);\n        return;\n    &#125;;\n    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);\n    for (int x, y; m--; ) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y;\n        g[x].push_back(y), g[y].push_back(x);\n    &#125;\n    int siz = 1 &lt;&lt; n;\n    std::vector&lt;int&gt; cnt(siz);\n    for (int i = 0; i &lt; siz; ++i) &#123;\n        std::iota(fa.begin(), fa.end(), 0);\n        std::vector&lt;int&gt; tag(n + 1);\n        for (int j = 1; j &lt;= n; ++j)\n            if ((i &gt;&gt; (j - 1)) &amp; 1)\n                for (auto k : g[j])\n                    if ((i &gt;&gt; (k - 1)) &amp; 1)\n                        merge(k, j);\n        for (int j = 1; j &lt;= n; ++j)\n            if ((i &gt;&gt; (j - 1)) &amp; 1)\n                cnt[i] += (fa[j] == j);\n    &#125;\n    std::vector&lt;long long&gt; f(siz);\n    f[0] = 1ll;\n    for (int i = 1; i &lt; siz; ++i)\n        for (int j = i; j; j = (j - 1) &amp; i)\n            if (cnt[j])\n                (f[i] += ((cnt[j] &amp; 1) ? 1 : mod - 1) * f[i ^ j]) %= mod;\n    std::cout &lt;&lt; f[siz - 1] &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"e---主旋律\">E - 主旋律</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P11714\" class=\"uri\">https://www.luogu.com.cn/problem/P11714</a></p>\n<p>即，给定一个有向图，问边集有多少个子集是强连通的。</p>\n<p>再次涉及到了连通性问题，但在这里需要结合 SCC 缩点来考虑。容易发现强连通即缩出来是一个点；故需要关注缩出来的点数。</p>\n<p>令 <span class=\"math inline\">\\(f(S)\\)</span> 表示 <span class=\"math inline\">\\(S\\)</span> 的导出子图内合法边子集的数量，<span class=\"math inline\">\\(g(S)\\)</span> 表示 <span class=\"math inline\">\\(S\\)</span> 的导出子图中非法边子集的数量；<span class=\"math inline\">\\(h(S,k)\\)</span> 表示 <span class=\"math inline\">\\(S\\)</span> 的导出子图中边的子集缩出来有 <span class=\"math inline\">\\(k\\)</span> 个点的数量， 令 <span class=\"math inline\">\\(E(S_1, S_2)\\)</span> 表示从 <span class=\"math inline\">\\(S_1\\)</span> 指向 <span class=\"math inline\">\\(S_2\\)</span> 的边数，则：</p>\n<p><span class=\"math display\">\\[\nf(S) = 2^{E(S,S)}-g(S)\\\\\ng(S)=\\sum_{T \\subseteq S}2^{E(T, S - T)}\\cdot 2^{E(T, T)}\\cdot \\sum_{k=1+[T=\\varnothing]} (-1)^{k+1}\\cdot h(S - T, k)\\\\\nh(S, k) = \\sum_{T\\subset S} f(T) \\cdot h(S - T, k-1)\n\\]</span></p>\n<p>注意为什么要用一个 <span class=\"math inline\">\\(h\\)</span> 来转移 <span class=\"math inline\">\\(g\\)</span> 呢？我们发现 <span class=\"math inline\">\\(-1\\)</span> 的次数和缩出来的点数是有关的，而光凭 <span class=\"math inline\">\\(g\\)</span> 无法表示点数信息，所以需要用 <span class=\"math inline\">\\(h\\)</span> 来搭个桥。</p>\n<p>直接 DP，复杂度 <span class=\"math inline\">\\(O(n\\cdot 3^n)\\)</span>。</p>\n",
            "tags": [
                "计数"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20230418/",
            "url": "https://xsc062.netlify.app/20230418/",
            "title": "解题报告 两双手",
            "date_published": "2023-04-18T08:48:22.000Z",
            "content_html": "<p>凳子充分地让我切身实地地体会到了平行四边形的不稳定性。做题的时候可以 360° 无死角地把下半身转来转去，有点意思。也有点容易摔（×</p>\n<span id=\"more\"></span>\n<hr />\n<h3 id=\"a.-两双手\">A. 两双手</h3>\n<p>http://222.180.160.110:1024/contest/3506/problem/1</p>\n<p>不难发现可以通过解二元一次方程组得到用几个 A 操作和 B 操作才能让横纵坐标分别改变一些特定的值。可惜我没能想到一个经典的容斥 DP 思想：</p>\n<p>定义起点为点 <span class=\"math inline\">\\(0\\)</span>。定义 <span class=\"math inline\">\\(C(x,y)\\)</span> 表示从 <span class=\"math inline\">\\(x\\)</span> 点走到 <span class=\"math inline\">\\(y\\)</span> 点的方案数（可经过特殊点）。对于特殊点 <span class=\"math inline\">\\(1\\sim n\\)</span>，顺序枚举，对于点 <span class=\"math inline\">\\(i\\)</span>，定义 <span class=\"math inline\">\\(f_i\\)</span> 表示从 <span class=\"math inline\">\\(0\\sim i\\)</span> 不经过任何除 <span class=\"math inline\">\\(i\\)</span> 以外的特殊点的方案数，则 <span class=\"math inline\">\\(f_i=C(0,i)-\\sum\\limits_{j=1}^{i-1}f_j\\times C(j,i)\\)</span>。其中 <span class=\"math inline\">\\(\\sum\\limits_{j=1}^{i-1}f_j\\times C(j,i)\\)</span> 就是从 <span class=\"math inline\">\\(0\\)</span> 到 <span class=\"math inline\">\\(i\\)</span>，除 <span class=\"math inline\">\\(i\\)</span> 以外经过至少 1 个特殊点的方案数。用总方案数减去不合法方案数，则得到合法方案数。</p>\n<p>一个细节。我们枚举时，可能会遇到只能从 <span class=\"math inline\">\\(i\\)</span> 到达 <span class=\"math inline\">\\(j\\)</span>，而不能从 <span class=\"math inline\">\\(j\\)</span> 到达 <span class=\"math inline\">\\(i\\)</span> 的情况。若恰好 <span class=\"math inline\">\\(j\\)</span> 在 <span class=\"math inline\">\\(i\\)</span> 前面，那么从 <span class=\"math inline\">\\(i\\)</span> 到 <span class=\"math inline\">\\(j\\)</span> 的路径就会被统计漏。这个时候怎么办呢？对于任意点 <span class=\"math inline\">\\(i\\)</span>，我们求得从 <span class=\"math inline\">\\(0\\to i\\)</span> 所需的步数，并以此为关键字从小到大排序，那么我们就能保证，任意一条合法路径都会被我们统计到。</p>\n<p>还是没那么难，有点套路。时间复杂度 <span class=\"math inline\">\\(\\mathcal O(n^2)\\)</span>。</p>\n<details>\n<pre class=\"cpp\"><code>namespace XSC062 &#123;\nusing namespace fastIO;\n#define mkp std::make_pair\nusing pii = std::pair&lt;int, int&gt;;\nconst int lim = 1e6;\nconst int maxn = 505;\nconst int mod = 1e9 + 7;\nconst int maxm = 1e6 + 5;\nstruct _ &#123; int x, y, w; &#125;;\nstd::set&lt;pii&gt; t;\n_ s[maxn], s1[maxn];\nint fac[maxm], f[maxn];\nint ex, ey, n1, n, ax, ay, bx, by;\ninline int gcd(int x, int y) &#123;\n    return y ? gcd(y, x % y) : x;\n&#125;\ninline int lcm(int x, int y) &#123;\n    return x / gcd(x, y) * y;\n&#125;\npii Solve(int a, int b, int c,\n                int d, int e, int f) &#123;\n    int N = 0, M = 0;\n    if (!a) &#123;\n        if (c % b)\n            return mkp(-1, -1);\n        M = c / b, f -= M * e;\n        if (f % d)\n            return mkp(-1, -1);\n        N = f / d;\n    &#125;\n    else if (!b) &#123;\n        if (c % a)\n            return mkp(-1, -1);\n        N = c / a, f -= N * d;\n        if (f % e)\n            return mkp(-1, -1);\n        M = f / e;\n    &#125;\n    else if (!d) &#123;\n        if (f % e)\n            return mkp(-1, -1);\n        M = f / e, f -= M * b;\n        if (c % a)\n            return mkp(-1, -1);\n        N = c / a;\n    &#125;\n    else if (!e) &#123;\n        if (f % d)\n            return mkp(-1, -1);\n        N = f / d, c -= N * a;\n        if (c % b)\n            return mkp(-1, -1);\n        M = c / b;\n    &#125;\n    else &#123;\n        int g = lcm(b, e);\n        a *= g / b, c *= g / b, b = g;\n        d *= g / e, f *= g / e, e = g;\n        if ((c - f) % (a - d))\n            return mkp(-1, -1);\n        N = (c - f) / (a - d), c -= N * a;\n        if (c % b)\n            return mkp(-1, -1);\n        M = c / b;\n    &#125;\n    return mkp(N, M);\n&#125;\ninline int qkp(int x, int y) &#123;\n    int res = 1;\n    while (y) &#123;\n        if (y &amp; 1)\n            (res *= x) %= mod;\n        (x *= x) %= mod;\n        y &gt;&gt;= 1;\n    &#125;\n    return res;\n&#125;\ninline int inv(int x) &#123;\n    return qkp(x, mod - 2);\n&#125;\ninline int A(int n, int m) &#123;\n    return (fac[n] * inv(fac[n - m])) % mod;\n&#125;\ninline int C(int n, int m) &#123;\n    return (A(n, m) * inv(A(m, m))) % mod;\n&#125;\ninline void Init(void) &#123;\n    fac[0] = 1;\n    for (int i = 1; i &lt;= lim; ++i)\n        fac[i] = (fac[i - 1] * i) % mod;\n    return;\n&#125;\nint main() &#123;\n    read(ex), read(ey), read(n1);\n    read(ax), read(ay), read(bx), read(by);\n    for (int i = 1; i &lt;= n1; ++i) &#123;\n        read(s1[i].x), read(s1[i].y);\n        pii t = Solve(ax, bx, s1[i].x,\n                        ay, by, s1[i].y);\n        s1[i].w = t.first + t.second;\n    &#125;\n    std::sort(s1 + 1, s1 + n1 + 1,\n        [&amp;](_ x, _ y) &#123; return x.w &lt; y.w; &#125;);\n    Init(), f[0] = 1, ++n1;\n    s1[n1].x = ex, s1[n1].y = ey;\n    for (int i = 1; i &lt;= n1; ++i) &#123;\n        pii t = Solve(ax, bx, s1[i].x,\n                        ay, by, s1[i].y);\n        if (t.first &lt; 0 || t.second &lt; 0) &#123;\n            if (i == n1) &#123;\n                puts(&quot;0&quot;);\n                return 0;\n            &#125;\n            continue;\n        &#125;\n        s[++n] = s1[i];\n    &#125;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        for (int j = 1; j &lt; i; ++j) &#123;\n            pii t = Solve(ax, bx, s[i].x\n                - s[j].x, ay, by, s[i].y\n                - s[j].y);\n            if (t.first &lt; 0 || t.second &lt; 0)\n                continue;\n            (f[i] += (f[j] * C(t.first +\n                    t.second, t.first)) %\n                    mod) %= mod;\n        &#125;\n        pii t = Solve(ax, bx, s[i].x,\n                    ay, by, s[i].y);\n        f[i] = (C(t.first + t.second,\n                t.first) + mod - f[i]) % mod;\n    &#125;\n    print(f[n]);\n    return 0;\n&#125;\n&#125; // namespace XSC062</code></pre>\n</details>\n",
            "tags": [
                "DP",
                "计数"
            ]
        }
    ]
}