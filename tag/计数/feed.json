{
    "version": "https://jsonfeed.org/version/1",
    "title": "null • All posts by \"计数\" tag",
    "description": "",
    "home_page_url": "https://xsc062.netlify.app",
    "items": [
        {
            "id": "https://xsc062.netlify.app/20251116/",
            "url": "https://xsc062.netlify.app/20251116/",
            "title": "杂题选谈 计数",
            "date_published": "2025-11-16T14:28:16.000Z",
            "content_html": "<p>上一篇杂题里，新的题目严重阻碍了老题目的生长。为了解除顶端抑制，一部分伸长区被移植到这里了。</p>\n<span id=\"more\"></span>\n<hr />\n<h2 id=\"a---range-set\">A - Range Set</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/AT_agc045_c\" class=\"uri\">https://www.luogu.com.cn/problem/AT_agc045_c</a></p>\n<ul>\n<li><p>首先考虑 <span class=\"math inline\">\\(A\\le B\\)</span> 的情况。覆盖类问题的一个想法是倒推回 <code>?</code>（<strong>这种方法的优点在于，操作总能和原始操作一一对应，形成和正向操作序列的双射，通过倒推得到的性质总是充要的</strong>）。</p>\n<p>则目标串为长度为 <span class=\"math inline\">\\(n\\)</span> 的 <code>0?</code> 串，起始串为待判定串，可进行的操作有：</p>\n<ol type=\"1\">\n<li><p>选择一个长度为 <span class=\"math inline\">\\(B\\)</span> 的 <code>1?</code> 串，全部变为 <code>?</code>；</p></li>\n<li><p>选择一个长度为 <span class=\"math inline\">\\(A\\)</span> 的 <code>0?</code> 串，全部变为 <code>?</code>。</p></li>\n</ol>\n<p>容易发现，只要在任意时刻进行了一次 1 操作，总能通过若干次 1 2 操作扩展到一个长为 <span class=\"math inline\">\\(n\\)</span> 的 <code>0?</code> 序列（而一次 1 操作都不做只有一种情况，虽然在后面 DP 会自然统计到这种情况）。故目标转化为找到能够进行<strong>第一次</strong>（又一个经典技巧）1 操作的局面。</p>\n<p>容易发现当且仅当能够通过若干次 2 操作，得到一个长度 <span class=\"math inline\">\\(\\ge B\\)</span> 的 <code>1?</code> 串，显然的等价转换是，存在一个长度 <span class=\"math inline\">\\(\\ge B\\)</span> 的子串，里面所有 <code>0</code> 的连续段长度均 <span class=\"math inline\">\\(\\ge A\\)</span>。现在就可以想办法统计了。</p></li>\n<li><p>接下来考虑 <span class=\"math inline\">\\(B&lt;A\\)</span> 的情况，容易发现，只要在任意时刻进行了一次 2 操作，总能通过若干次 1 2 操作扩展到一个长为 <span class=\"math inline\">\\(n\\)</span> 的 <code>0?</code> 序列。把上面得到所有合法串 flip 就可以得到这里的所有合法串，故并不需要分讨。</p></li>\n<li><p>令 <span class=\"math inline\">\\(f_{i,j,0/1}\\)</span> 表示 DP 到 <span class=\"math inline\">\\(i\\)</span>，有一段长度为 <span class=\"math inline\">\\(j\\)</span> 的合法后缀，第 <span class=\"math inline\">\\(i-1\\)</span> 位的值为 <span class=\"math inline\">\\(0/1\\)</span> 的方案数，则：</p>\n<p><span class=\"math display\">\\[\nf_{i,j,1}=\\sum_{k=1}^j f_{i-k,j-k,0}\\\\\nf_{i,j,0}=\\left(\\sum_{k=1}^{\\min(A-1,j-B)}f_{i-k,j-k,1}\\right)+\\left(\\sum_{k=A}^j f_{i-k,j-k,1}\\right)\\\\\nf_{i,0,0}=\\sum_{k=1}^{A-1}\\sum_{j=0}^{B-1} f_{i-k,j,1}\n\\]</span></p>\n<p>最后一种转移的优化是显然的；前两种转移中，<span class=\"math inline\">\\(i\\)</span> 和 <span class=\"math inline\">\\(j\\)</span> 的变化量是一致的，也可以前缀和优化。</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 1e9 + 7;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, a, b;\n    std::cin &gt;&gt; n &gt;&gt; a &gt;&gt; b;\n    if (a &gt; b)\n        std::swap(a, b);\n    using arr = std::vector&lt;long long&gt;;\n    using brr = std::vector&lt;arr&gt;;\n    using crr = std::vector&lt;brr&gt;;\n    brr sum(n + 1, arr(n + 1));\n    crr s(2, brr(n + 1, arr(n + 1)));\n    sum[0][0] = 1ll;\n    s[0][0][0] = s[1][0][0] = 1ll;\n    auto fun = [&amp;](int op, int i, int j, int l, int r) &#123;\n        if (l &gt; r)\n            return 0ll;\n        auto res = s[op][i - j][i - l];\n        if (i &gt; r)\n            res += mod - s[op][i - j][i - r - 1];\n        return res &lt; mod ? res : res - mod;\n    &#125;;\n    auto res = 0ll;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        for (int j = 1; j &lt;= n &amp;&amp; j &lt;= i; ++j) &#123;\n            auto f0 = fun(1, i, j, 1, std::min(a - 1, j - b)) + fun(1, i, j, a, j);\n            auto f1 = fun(0, i, j, 1, j);\n            if (f0 &gt;= mod)\n                f0 -= mod;\n            if ((s[0][i - j][i] = s[0][i - j][i - 1] + f0) &gt;= mod)\n                s[0][i - j][i] -= mod;\n            if ((s[1][i - j][i] = s[1][i - j][i - 1] + f1) &gt;= mod)\n                s[1][i - j][i] -= mod;\n            if (i == n &amp;&amp; j &gt;= b)\n                res += f0 + f1;\n            if ((sum[i][j] = sum[i][j - 1] + f1) &gt;= mod)\n                sum[i][j] -= mod;\n        &#125;\n        s[0][i][i] = 0ll;\n        for (int k = 1; k &lt; a &amp;&amp; k &lt;= i; ++k)\n            s[0][i][i] += sum[i - k][std::min(b - 1, i - k)];\n        s[0][i][i] %= mod;\n    &#125;\n    std::cout &lt;&lt; res % mod &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"b---popping-balls\">B - Popping Balls</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/AT_code_festival_2017_qualb_e\" class=\"uri\">https://www.luogu.com.cn/problem/AT_code_festival_2017_qualb_e</a></p>\n<ul>\n<li><p>容易发现好的出发点应该是尽可能多地统计局面。容易发现应该尽量让 <span class=\"math inline\">\\(s\\)</span> 和 <span class=\"math inline\">\\(t\\)</span> 取到蓝色的球。</p>\n<p>进一步发现，<strong>在第一次取蓝球时</strong>，<span class=\"math inline\">\\(t\\)</span> 应该在蓝球的队首处。直到取走了 <span class=\"math inline\">\\(B\\)</span> 个球，<span class=\"math inline\">\\(t\\)</span> 已经超出序列时，<span class=\"math inline\">\\(s\\)</span> 才可能发挥作用。</p></li>\n<li><p>相似地，在这之后<strong>第一次取蓝球时</strong>，<span class=\"math inline\">\\(s\\)</span> 应该在蓝球的队首处。</p>\n<p>很容易发现只需要统计两个点处分别取走了多少个蓝球（尽量让 <span class=\"math inline\">\\(t\\)</span> 取）就能统计。</p></li>\n<li><p>具体地，设 <span class=\"math inline\">\\(t\\)</span> 处取走了 <span class=\"math inline\">\\(c\\)</span> 个、<span class=\"math inline\">\\(s\\)</span> 处取走了 <span class=\"math inline\">\\(d\\)</span> 个，则这两个点处的方案数为：</p>\n<p><span class=\"math display\">\\[\n\\binom{B-1}{c-1}\\times \\binom{B-c-1}{d-1}\n\\]</span></p></li>\n<li><p>此外，总共 <span class=\"math inline\">\\(A-(B-c)-(B-c-d)\\)</span> 个红球，可以在 <span class=\"math inline\">\\(t\\)</span> 进入决策之前，<span class=\"math inline\">\\(s\\)</span> 进入决策之前，<span class=\"math inline\">\\(s\\)</span> 决策完后三个时刻给出去。插板得到 <span class=\"math inline\">\\(\\binom{A-(B-c)-(B-c-d)+2}2\\)</span> 种方案。</p>\n<p>此外，还要考虑 <span class=\"math inline\">\\(s\\)</span> 与 <span class=\"math inline\">\\(t\\)</span> 重合，共 <span class=\"math inline\">\\(A+1\\)</span> 种方案。</p></li>\n</ul>\n<!-- - 具体地，设 $t$ 第一次发挥作用的局面为 $c+B$，$s$ 第一次发挥作用的局面为 $(c-d)+(B-e)$。\n\n    - 两个状态过渡的方案数为 $\\large\\binom {B-1}{e-1}$（注意第一次必须选蓝）。\n\n    - 接下来，除开第一次选择，接下来的 $\\min(c-d,B-e-1)$ 次可以任意选取，方案数为 $2^{\\min(c-d,B-e-1)}$。\n\n    - 接下来的选择固定，方案数唯一。 -->\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 1e9 + 7;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int A, B;\n    std::cin &gt;&gt; A &gt;&gt; B;\n    using arr = std::vector&lt;long long&gt;;\n    using brr = std::vector&lt;arr&gt;;\n    brr C(A + B + 1, arr(A + B + 1));\n    C[0][0] = 1ll;\n    for (int i = 1; i &lt;= A + B; ++i) &#123;\n        C[i][0] = 1ll;\n        for (int j = 1; j &lt;= i; ++j)\n            C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % mod;\n    &#125;\n    auto res = A + 1;\n    for (int c = 1; c &lt; B; ++c)\n        for (int d = 1; c + d &lt;= B; ++d)\n            (res += C[B - 1][c - 1] * C[B - c - 1][d - 1] % mod * C[std::max(0, A - (B - c) - (B - c - d) + 2)][2] % mod) %= mod;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"c---minimum-bounding-box-2\">C - Minimum Bounding Box 2</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/AT_abc297_f\" class=\"uri\">https://www.luogu.com.cn/problem/AT_abc297_f</a></p>\n<ul>\n<li>枚举矩形长宽，二项式算方案数即可，非常简单。</li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 998244353;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, m, k;\n    std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;\n    using arr = std::vector&lt;long long&gt;;\n    using brr = std::vector&lt;arr&gt;;\n    arr fac(n * m + 1), inv(n * m + 1);\n    fac[0] = inv[0] = 1ll;\n    for (int i = 1; i &lt;= n * m; ++i)\n        fac[i] = fac[i - 1] * i % mod;\n    auto qkp = [&amp;](long long x, int y) &#123;\n        auto res = 1ll;\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    inv[n * m] = qkp(fac[n * m], mod - 2);\n    for (int i = n * m - 1; i; --i)\n        inv[i] = inv[i + 1] * (i + 1) % mod;\n    auto C = [&amp;](int n, int m) &#123;\n        if (n &lt; m)\n            return 0ll;\n        return fac[n] * inv[m] % mod * inv[n - m] % mod;\n    &#125;;\n    auto res = 0ll;\n    brr f(n + 1, arr(m + 1)), g(n + 1, arr(m + 1));\n    for (int i = 1; i &lt;= n; ++i)\n        for (int j = 1; j &lt;= m; ++j) &#123;\n            g[i][j] = C(i * j, k);\n            f[i][j] = g[i][j] - g[i - 1][j] * 2 - g[i][j - 1] * 2 + g[i - 1][j - 1] * 4;\n            if (i &gt;= 2)\n                f[i][j] += g[i - 2][j] - 2 * g[i - 2][j - 1];\n            if (j &gt;= 2)\n                f[i][j] += g[i][j - 2] - 2 * g[i - 1][j - 2];\n            if (i &gt;= 2 &amp;&amp; j &gt;= 2)\n                f[i][j] += g[i - 2][j - 2];\n            f[i][j] = (f[i][j] % mod + mod) % mod;\n            (res += i * j * f[i][j] % mod * (n - i + 1) % mod * (m - j + 1)) %= mod;\n            // printf(&quot;f[%d][%d] = %lld \\n&quot;, i, j, f[i][j]);\n        &#125;\n    std::cout &lt;&lt; res * qkp(C(n * m, k), mod - 2) % mod &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"d---colorful-candies-2\">D - Colorful Candies 2</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/AT_abc215_g\" class=\"uri\">https://www.luogu.com.cn/problem/AT_abc215_g</a></p>\n<p>啥啊。原来要拆贡献。</p>\n<ul>\n<li><p>观察到类根号的复杂度，考虑把出现次数相同的数放在一起计算，元素种类就只有 <span class=\"math inline\">\\(O(\\sqrt n)\\)</span> 个了。</p>\n<p>DP 不太能处理这样的多重结构，故需要考虑更线性的计算方式，这里进行了拆贡献。</p></li>\n<li><p>考虑一个出现了 <span class=\"math inline\">\\(c\\)</span> 次的数被选入的概率，为 <span class=\"math inline\">\\(1-\\dfrac {C_{n-c}^K}{C_{n}^K}\\)</span>。相加即可。</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 998244353;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::unordered_map&lt;int, int&gt; cnt;\n    for (int i = 1, x; i &lt;= n; ++i)\n        std::cin &gt;&gt; x, ++cnt[x];\n    std::vector&lt;int&gt; b;\n    for (auto [x, y] : cnt)\n        b.push_back(y);\n    std::sort(b.begin(), b.end());\n    std::vector&lt;std::pair&lt;int, int&gt; &gt; a;\n    std::vector&lt;long long&gt; fac(n + 1), inv(n + 1);\n    fac[0] = inv[0] = 1ll;\n    for (int i = 1; i &lt;= n; ++i)\n        fac[i] = fac[i - 1] * i % mod;\n    auto qkp = [&amp;](long long x, int y) &#123;\n        auto res = 1ll;\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    inv[n] = qkp(fac[n], mod - 2);\n    for (int i = n - 1; i; --i)\n        inv[i] = inv[i + 1] * (i + 1) % mod;\n    for (auto i : b)\n        if (a.empty() || i != a.back().first)\n            a.emplace_back(i, 1);\n        else\n            ++a.back().second;\n    auto C = [&amp;](int n, int m) &#123;\n        if (n &lt; m)\n            return 0ll;\n        return fac[n] * inv[m] % mod * inv[n - m] % mod;\n    &#125;;\n    for (int k = 1; k &lt;= n; ++k) &#123;\n        auto res = 0ll;\n        auto invC = qkp(C(n, k), mod - 2);\n        for (auto [c, m] : a)\n            res += m * (1ll + mod - C(n - c, k) * invC % mod);\n        std::cout &lt;&lt; res % mod &lt;&lt; &#39;\\n&#39;;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"a---catastrophic-roulette\">A - Catastrophic Roulette</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/AT_arc174_c\" class=\"uri\">https://www.luogu.com.cn/problem/AT_arc174_c</a></p>\n<hr />\n<h2 id=\"b---swap-permutation\">B - Swap Permutation</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/AT_arc176_d\" class=\"uri\">https://www.luogu.com.cn/problem/AT_arc176_d</a></p>\n<ul>\n<li><p>发现最后关心的位置比较少，只有 <span class=\"math inline\">\\(O(n)\\)</span> 个。同时发现一件事：假设 <span class=\"math inline\">\\(A_i=x,A_{i+1}=y\\)</span>，那么最后 <span class=\"math inline\">\\(A_i\\)</span> 和 <span class=\"math inline\">\\(A_{i+1}\\)</span> 的值的可能情况只有：</p>\n<p><span class=\"math inline\">\\((x,y)\\)</span>，<span class=\"math inline\">\\((x,?)\\)</span>，<span class=\"math inline\">\\((y,x)\\)</span>，<span class=\"math inline\">\\((y,?)\\)</span>，<span class=\"math inline\">\\((?,x)\\)</span>，<span class=\"math inline\">\\((?,y)\\)</span>，<span class=\"math inline\">\\((?,?)\\)</span></p>\n<p>这 7 种情况。且每种情况的期望是相对好算的。发现每种情况出现的概率可以用矩阵求解。</p></li>\n<li><p>发现矩阵有点大。题解区中的处理方法之一是经典的偏序 + 01，但为什么不能沿用原本的思路呢？</p>\n<p>进一步把 <span class=\"math inline\">\\(A,B\\)</span> 视作同一个数，这样状态数就减少到 3 种 <span class=\"math inline\">\\((0,0),(0,1)/(1,0),(1,1)\\)</span>，相应的期望也是好算的，且矩阵大小会减少很多。</p>\n<p><span class=\"math display\">\\[\nM=\\begin{bmatrix}\n\\dfrac {(n-2)(n-3)}2+1+2(n-4)&amp;2\\times 2&amp;0\\\\\nn-3&amp;2+(n-3)+\\dfrac {(n-2)(n-3)}2&amp;1\\\\\n0&amp;(n-2)\\times 2&amp;1+\\dfrac {(n-2)(n-3)}2\n\\end{bmatrix}\n\\]</span></p>\n<p>检查技巧：保证每一行的和均为 <span class=\"math inline\">\\(\\dfrac {n(n-1)}2\\)</span> 即可。</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 998244353, inv2 = (mod + 1) &gt;&gt; 1, N = 3;\nstruct mat &#123;\n    std::vector&lt;std::vector&lt;long long&gt; &gt; a;\n    mat(void): a(N, std::vector&lt;long long&gt; (N)) &#123;&#125;\n    std::vector&lt;long long&gt;&amp; operator[](const int q) &#123;\n        return a[q];\n    &#125;\n    mat operator* (mat &amp;q) const &#123;\n        mat res;\n        for (int i = 0; i &lt; N; ++i)\n            for (int k = 0; k &lt; N; ++k)\n                for (int j = 0; j &lt; N; ++j)\n                    if ((res[i][j] += a[i][k] * q[k][j] % mod) &gt;= mod)\n                        res[i][j] -= mod;\n        return res;\n    &#125;\n&#125;;\nstruct vec &#123;\n    std::vector&lt;long long&gt; a;\n    vec(void): a(N) &#123;&#125;\n    long long&amp; operator[](const int q) &#123;\n        return a[q];\n    &#125;\n    vec operator* (mat &amp;q) const &#123;\n        vec res;\n        for (int k = 0; k &lt; N; ++k)\n            for (int j = 0; j &lt; N; ++j)\n                if ((res[j] += a[k] * q[k][j] % mod) &gt;= mod)\n                    res[j] -= mod;\n        return res;\n    &#125;\n&#125;;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    long long n, m;\n    std::cin &gt;&gt; n &gt;&gt; m;\n    std::vector&lt;long long&gt; a(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i];\n    if (n == 2) &#123;\n        std::cout &lt;&lt; std::abs(a[1] - a[2]) &lt;&lt; &#39;\\n&#39;;\n        return 0;\n    &#125;\n    auto qkp = [&amp;](long long x, int y) &#123;\n        auto res = 1ll;\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    vec d;\n    d[2] = 1ll;\n    mat t;\n    t[0][0] = ((n - 2) * (n - 3) / 2 + 1 + 2 * (n - 4)) % mod;\n    t[0][1] = 2 * 2;\n    t[1][0] = n - 3;\n    t[1][1] = (2 + (n - 3) + (n - 2) * (n - 3) / 2) % mod;\n    t[1][2] = 1;\n    t[2][1] = (n - 2) * 2 % mod;\n    t[2][2] = (1 + (n - 2) * (n - 3) / 2) % mod;\n    for (int i = m; i; i &gt;&gt;= 1, t = t * t)\n        if (i &amp; 1)\n            d = d * t;\n    auto s = 0ll;\n    auto calc = [&amp;](long long l, long long r) &#123;\n        return (l + r) * (r - l + 1) / 2 % mod;\n    &#125;;\n    for (int i = 1; i &lt;= n; ++i)\n        s += (calc(i + 1, n) + mod - (long long)i * (n - (i + 1) + 1) % mod) % mod;\n    auto res = 0ll, invM = qkp((long long)(n - 2) * (n - 3) / 2 % mod, mod - 2), invN2 = qkp(n - 2, mod - 2);\n    for (int i = 1; i &lt; n; ++i) &#123;\n        auto k = (calc(a[i] + 1, n) - a[i] * (n - (a[i] + 1) + 1) % mod + a[i] * (a[i] - 1) % mod - calc(1, a[i] - 1) - std::abs(a[i] - a[i + 1]) + calc(a[i + 1] + 1, n) - a[i + 1] * (n - (a[i + 1] + 1) + 1) % mod + a[i + 1] * (a[i + 1] - 1) % mod - calc(1, a[i + 1] - 1) - std::abs(a[i] - a[i + 1])) % mod, t = (s - k - std::abs(a[i] - a[i + 1])) % mod;\n        res += t * invM % mod * d[0] % mod;\n        res += d[1] % mod * invN2 % mod * inv2 % mod % mod * k % mod;\n        res += std::abs(a[i] - a[i + 1]) * d[2] % mod;\n    &#125;\n    std::cout &lt;&lt; (res % mod + mod) % mod &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"c---random-walk-on-tree\">C - Random Walk on Tree</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/AT_arc185_d\" class=\"uri\">https://www.luogu.com.cn/problem/AT_arc185_d</a></p>\n<ul>\n<li>即一个根上挂了 <span class=\"math inline\">\\(n\\div m\\)</span> 条长为 <span class=\"math inline\">\\(m\\)</span> 的链。令 <span class=\"math inline\">\\(f_i\\)</span> 表示走到一条链底</li>\n</ul>\n",
            "tags": [
                "计数"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20251104/",
            "url": "https://xsc062.netlify.app/20251104/",
            "title": "杂题选谈",
            "date_published": "2025-11-04T07:01:11.000Z",
            "content_html": "<p>这么爱计数</p>\n<span id=\"more\"></span>\n<hr />\n<h2 id=\"a.-图-hdu4903-the-only-survival\">A. 图 / HDU4903 The only survival</h2>\n<p><a href=\"https://vjudge.net/problem/HDU-4903#author=DeepSeek_zh\" class=\"uri\">https://vjudge.net/problem/HDU-4903#author=DeepSeek_zh</a></p>\n<ul>\n<li><p>很容易想到基于按 dis 从小到大枚举的做法</p>\n<p>但是发现算方案就必须要知道每个点的具体 dis，就导致难以 DP，只能搜索，这样复杂度就不太好看。</p></li>\n<li><p>一个显然的观察：<strong>并不关心 <span class=\"math inline\">\\(1,n\\)</span> 以外点的标号</strong>，所以可以把 <span class=\"math inline\">\\(O(n^k)\\)</span> 的暴搜优化到 <span class=\"math inline\">\\(O(\\binom{n+k}k\\cdot (n+k))\\)</span>，然后做多重集排列即可。</p>\n<p>模数非质时的多重集排列：<a href=\"/20231117/#数学\">link</a></p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n    std::freopen(&quot;graph.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;graph.out&quot;, &quot;w&quot;, stdout);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, k, L, mod;\n    std::cin &gt;&gt; n &gt;&gt; k &gt;&gt; L &gt;&gt; mod;\n    if (L &lt; k) &#123;\n        std::cout &lt;&lt; 0 &lt;&lt; &#39;\\n&#39;;\n        return 0;\n    &#125;\n    std::vector&lt;std::vector&lt;long long&gt; &gt; C(n + 1, std::vector&lt;long long&gt; (n + 1));\n    C[0][0] = 1ll;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        C[i][0] = 1ll;\n        for (int j = 1; j &lt;= i; ++j)\n            C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % mod;\n    &#125;\n    std::vector&lt;int&gt; dis(n + 1), s;\n    int res = 0;\n    std::function&lt;void(int, int, long long)&gt; DFS = [&amp;](int x, int d, long long now) &#123;\n        if (x == n) &#123;\n            auto s0 = now, s1 = now;\n            for (int i = 1; i &lt; n; ++i)\n                if (dis[i] &gt;= k)\n                    (s0 *= L) %= mod, (s1 *= L) %= mod;\n                else if (L - (k - dis[i] - 1)) &#123;\n                    (s0 *= L - (k - dis[i] - 1)) %= mod;\n                    (s1 *= L - (k - dis[i] - 1) - 1) %= mod;\n                &#125;\n                else &#123;\n                    s0 = s1 = 0ll;\n                    break;\n                &#125;\n            dis[x] = k;\n            auto u = 1ll;\n            int cnt = n - 2;\n            for (auto i : s)\n                (u *= C[cnt][i]) %= mod, cnt -= i;\n            (res += u * (s0 + mod - s1) % mod) %= mod;\n            return;\n        &#125;\n        for (int i = d; i &lt;= k + 1; ++i) &#123;\n            auto s0 = now, s1 = now;\n            for (int j = 1; j &lt; x; ++j)\n                if (dis[j] &gt;= i)\n                    (s0 *= L) %= mod, (s1 *= L) %= mod;\n                else if (L - (i - dis[j] - 1)) &#123;\n                    (s0 *= L - (i - dis[j] - 1)) %= mod;\n                    (s1 *= L - (i - dis[j] - 1) - 1) %= mod;\n                &#125;\n                else &#123;\n                    s0 = s1 = 0ll;\n                    break;\n                &#125;\n            dis[x] = i;\n            if (dis[x] != dis[x - 1])\n                s.push_back(1);\n            else\n                ++s.back();\n            if (i == k + 1)\n                s1 = 0ll;\n            DFS(x + 1, i, (s0 + mod - s1) % mod);\n            if (dis[x] != dis[x - 1])\n                s.pop_back();\n            else\n                --s.back();\n        &#125;\n        return;\n    &#125;;\n    DFS(2, 1, 1);\n    std::cout &lt;&lt; res % mod &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"b.-路线-arc136e-non-coprime-dag\">B. 路线 / ARC136E Non-coprime DAG</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/AT_arc136_e\" class=\"uri\">https://www.luogu.com.cn/problem/AT_arc136_e</a></p>\n<ul>\n<li><p>做过 <a href=\"https://www.luogu.com.cn/problem/CF870F\">CF870F Paths</a> 可以很快反应过来：<span class=\"math inline\">\\(x\\)</span> 和 <span class=\"math inline\">\\(y\\)</span> 是否可以同时被选，取决于它们各自的最小质因子是否能在 <span class=\"math inline\">\\(x,y\\)</span> 之间交汇（或用 <span class=\"math inline\">\\(2\\)</span> 作跳板）。</p>\n<p>接着就发现由于 <span class=\"math inline\">\\(2\\)</span> 间隔出现，此时再分奇偶性就会显得非常合理。</p></li>\n<li><p>两个偶数总是不能同时被选；对于奇数 <span class=\"math inline\">\\(x\\)</span> 和偶数 <span class=\"math inline\">\\(y\\)</span>，要求 <span class=\"math inline\">\\(y\\in [x-f(x)+1,x+f(x)-1]\\)</span>。</p></li>\n<li><p>考察奇数的选取。容易发现，钦定用 <span class=\"math inline\">\\(2\\)</span> 作跳板，则两个奇数 <span class=\"math inline\">\\(x,y(x&lt;y)\\)</span> 能同时被选，当且仅当：</p>\n<ul>\n<li>记 <span class=\"math inline\">\\(f(i)\\)</span> 为 <span class=\"math inline\">\\(i\\)</span> 的最小质因子，则 <span class=\"math inline\">\\(x+f(x)&gt; y-f(y)\\)</span>。</li>\n</ul>\n<p>发现实际上可以认为 <span class=\"math inline\">\\(x\\)</span> 代表区间 <span class=\"math inline\">\\([x-f(x),x+f(x)-1]\\)</span>。那么两个点可以同时被选当且仅当它们代表的区间有交（这样就去掉了 <span class=\"math inline\">\\(x,y\\)</span> 之间的偏序条件）</p>\n<p>这样发现对『代表区间』的定义，在奇数视角和偶数视角下是冲突的，可以发现偶数视角的区间更紧；事实上，应该采用 <span class=\"math inline\">\\([x-f(x)+1,x+f(x)-1]\\)</span> 这个看似充分不必要的定义，因为端点总是奇数，导致 <span class=\"math inline\">\\(x+f(x)&gt; y-f(y)\\)</span> 和 <span class=\"math inline\">\\(x+f(x)-1&lt;y-f(y)+1\\)</span> 不能同时成立。</p></li>\n<li><p>进一步推广结论，容易发现多个奇数可以同时被选，当且仅当它们代表的区间有交。故可以枚举值域中的点，找加权覆盖次数最大值。</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;int&gt; fac(n + 1), l(n + 1), r(n + 1);\n    for (int i = 2; i &lt;= n; ++i) &#123;\n        if (!fac[i]) &#123;\n            fac[i] = i;\n            for (int j = 2 * i; j &lt;= n; j += i)\n                if (!fac[j])\n                   fac[j] = i;\n        &#125;\n        l[i] = std::max(1, i - fac[i] + 1);\n        r[i] = std::min(i + fac[i] - 1, n);\n    &#125;\n    std::vector&lt;int&gt; a(n + 1);\n    std::vector&lt;long long&gt; dif(n + 1);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; a[i];\n        if (i == 1 || i % 2 == 0)\n            continue;\n        dif[l[i]] += a[i];\n        if (r[i] != n)\n            dif[r[i] + 1] -= a[i];\n    &#125;\n    auto res = 0ll;\n    std::partial_sum(dif.begin(), dif.end(), dif.begin());\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        auto now = a[1] + dif[i];\n        if (i % 2 == 0)\n            now += a[i];\n        res = std::max(res, now);\n    &#125;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"a.-列车扫除\">A. 列车扫除</h2>\n<p><a href=\"https://www.becoder.com.cn/contest/6708/problem/1\" class=\"uri\">https://www.becoder.com.cn/contest/6708/problem/1</a></p>\n<blockquote>\n<p>绝对聪明的 A, B, C 在一起玩 Nim，有三堆石子 <span class=\"math inline\">\\(c_{1,2,3}\\)</span>，每次可以任选一堆拿走正整数个，不能拿的人扣一分，他的上一个人加一分。</p>\n<p>给定 <span class=\"math inline\">\\(q\\)</span> 次询问，形如：</p>\n<ul>\n<li>现在知道 <span class=\"math inline\">\\(\\forall \\, i=1,2,3,c_i\\in[l_i,r_i]\\)</span>。对于这 <span class=\"math inline\">\\(\\prod_{i=1,2,3}r_i-l_i+1\\)</span> 种可能的情况，对于每个人，求出分数之和。</li>\n</ul>\n<p><span class=\"math inline\">\\(q\\le 10^6,V=10^9\\)</span>。</p>\n</blockquote>\n<ul>\n<li><p>容易发现，胜，平，负三个状态会被分给三个人，且一共只有三种分配方式。</p></li>\n<li><p>当只剩一堆石头时，操作者胜；石头状态为 <span class=\"math inline\">\\((0,1,1)\\)</span> 时，操作者负。</p></li>\n</ul>\n<hr />\n<h2 id=\"b.-换来换去\">B. 换来换去</h2>\n<p><a href=\"https://www.becoder.com.cn/contest/6708/problem/2\" class=\"uri\">https://www.becoder.com.cn/contest/6708/problem/2</a></p>\n<blockquote>\n<p>对 <span class=\"math inline\">\\(n\\)</span> 个有标号的球任意分成任意组，组是无顺序的，且要求每组球个数 <span class=\"math inline\">\\(\\ge 2\\)</span>，求方案数，对质数取模。</p>\n<p><span class=\"math inline\">\\(n\\le 10^7\\)</span>。</p>\n</blockquote>\n<ul>\n<li><p>发现这是一个类斯特林数的问题，二项式反演得到答案式为：</p>\n<p><span class=\"math display\">\\[\n\\sum_{i=0}^n (-1)^{n-i}\\binom ni \\sum_{j=0}^i \\begin{Bmatrix} i\\\\ j\\end{Bmatrix}\n\\]</span></p>\n<p>用斯特林数通项展开：</p>\n<p><span class=\"math display\">\\[\n\\sum_{i=0}^n (-1)^{n-i}\\binom ni \\sum_{j=0}^i \\sum_{k=0}^j(-1)^{j-k}\\dfrac {k^i}{(j-k)!\\cdot k!}\n\\]</span></p>\n<p>很容易注意到一个二项式定理的结构，故交换求和顺序：</p>\n<p><span class=\"math display\">\\[\n\\sum_{j=0}^n \\sum_{k=0}^j \\dfrac {(-1)^{j-k}}{(j-k)!\\cdot k!}\\cdot \\sum_{i=j}^n \\binom ni (-1)^{n-i}k^i\n\\]</span></p>\n<p>发现一个很严重的问题在于 <span class=\"math inline\">\\(i\\)</span> 的起始范围是 <span class=\"math inline\">\\(j\\)</span> 而不是 <span class=\"math inline\">\\(0\\)</span>，但如果我们把一开始的式子改写成这样：</p>\n<p><span class=\"math display\">\\[\n\\sum_{i=0}^n (-1)^{n-i}\\binom ni \\sum_{j=0}^n \\begin{Bmatrix} i\\\\ j\\end{Bmatrix}\n\\]</span></p>\n<p>容易发现当 <span class=\"math inline\">\\(j&gt;i\\)</span> 时 <span class=\"math inline\">\\(\\begin{Bmatrix} i\\\\ j\\end{Bmatrix}=0\\)</span>，和原式的值相同，且斯特林数通项对于 <span class=\"math inline\">\\(j&gt;i\\)</span> 也是成立的，故原式等价于</p>\n<p><span class=\"math display\">\\[\n\\begin{aligned}\n&amp;\\sum_{j=0}^n \\sum_{k=0}^j \\dfrac {(-1)^{j-k}}{(j-k)!\\cdot k!}\\cdot \\sum_{i=0}^n \\binom ni (-1)^{n-i}k^i\\\\\n=&amp;\\sum_{j=0}^n \\sum_{k=0}^j \\dfrac {(-1)^{j-k}}{(j-k)!\\cdot k!}\\cdot (k-1)^n\\\\\n=&amp;\\sum_{k=0}^n \\dfrac {(k-1)^n}{k!}\\cdot \\sum_{j=0}^{n-k} \\dfrac {(-1)^j}{j!}\\\\\n\\end{aligned}\n\\]</span></p>\n<p>后者内部与 <span class=\"math inline\">\\(k\\)</span> 无关，是可前缀和计算的，只需要考虑在 <span class=\"math inline\">\\(O(1)\\)</span> 内求出 <span class=\"math inline\">\\((k-1)^n\\)</span> 的值，筛一下，对于质数（约 <span class=\"math inline\">\\(\\dfrac n{\\ln n}\\)</span> 个）快速幂，合数用积性函数之类即可。</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n    std::freopen(&quot;card.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;card.out&quot;, &quot;w&quot;, stdout);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int T;\n    for (std::cin &gt;&gt; T; T--; ) &#123;\n        int n, mod;\n        std::cin &gt;&gt; n &gt;&gt; mod;\n        std::vector&lt;int&gt; tag(n + 1), p, pw(n + 1);\n        auto qkp = [&amp;](long long x, int y) &#123;\n            auto res = 1ll;\n            for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n                if (y &amp; 1)\n                    (res *= x) %= mod;\n            return res;\n        &#125;;\n        pw[1] = 1ll;\n        for (int i = 2; i &lt;= n; ++i) &#123;\n            if (!tag[i]) &#123;\n                pw[i] = qkp(i, n);\n                p.push_back(i);\n            &#125;\n            for (auto j : p) &#123;\n                if (i &gt; n / j)\n                    break;\n                tag[i * j] = 1;\n                pw[i * j] = (long long)pw[i] * pw[j] % mod;\n                if (i % j == 0)\n                    break;\n            &#125;\n        &#125;\n        std::vector&lt;int&gt; inv(n + 1), s(n + 1);\n        inv[0] = 1ll;\n        for (int j = 1; j &lt;= n; ++j)\n            inv[j] = (long long)inv[j - 1] * j % mod;\n        inv[n] = qkp(inv[n], mod - 2);\n        for (int j = n - 1; j; --j)\n            inv[j] = (long long)inv[j + 1] * (j + 1) % mod;\n        s[0] = inv[0];\n        for (int j = 1; j &lt;= n; ++j) &#123;\n            if (j &amp; 1)\n                s[j] = s[j - 1] + mod - inv[j];\n            else\n                s[j] = s[j - 1] + inv[j];\n            if (s[j] &gt;= mod)\n                s[j] -= mod;\n        &#125;\n        auto res = (long long)s[n] * ((n &amp; 1) ? mod - 1 : 1);\n        for (int k = 1; k &lt;= n; ++k)\n            res += (long long)pw[k - 1] * inv[k] % mod * s[n - k] % mod;\n        std::cout &lt;&lt; res % mod &lt;&lt; &#39;\\n&#39;;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"c.-画家\">C. 画家</h2>\n<p><a href=\"https://www.becoder.com.cn/contest/6714/problem/3\" class=\"uri\">https://www.becoder.com.cn/contest/6714/problem/3</a></p>\n<ul>\n<li><p>ARC 特供删十字，故时光倒流，转化成在图上删相同颜色的十字 / 行 / 列。</p></li>\n<li><p>令 <span class=\"math inline\">\\(f_{i,j}\\)</span> 表示合法的 <span class=\"math inline\">\\(i\\)</span> 行 <span class=\"math inline\">\\(j\\)</span> 列地图。发现同颜色的删行 + 删列会和直接删十字算重，</p></li>\n</ul>\n<hr />\n<h2 id=\"b.-灯光秀-cf1545c-aquamoon-and-permutations\">B. 灯光秀 / CF1545C AquaMoon and Permutations</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/CF1545C\" class=\"uri\">https://www.luogu.com.cn/problem/CF1545C</a></p>\n<ul>\n<li><p>第一步需要想到，如果某一列的某个数，只有一个排列有，那么这个排列必须被选入拉丁方；</p>\n<p>用这个必选的排列，可以排除掉一些与之冲突、不能选入拉丁方的排列。</p></li>\n<li></li>\n</ul>\n<hr />\n<h2 id=\"a.-bot-的能量堆\">A. bot 的能量堆</h2>\n<p><a href=\"https://www.becoder.com.cn/contest/6731/problem/1\" class=\"uri\">https://www.becoder.com.cn/contest/6731/problem/1</a></p>\n<blockquote>\n<p>⚡<strong>超越一切震慑凡人</strong>⚡</p>\n<p>给定正整数 <span class=\"math inline\">\\(x,y\\)</span>，你可以执行下面三种操作：</p>\n<ol type=\"1\">\n<li>将 <span class=\"math inline\">\\(x,y\\)</span> 同时加 1；</li>\n<li>将 <span class=\"math inline\">\\(x,y\\)</span> 同时减一；</li>\n<li>对于 <span class=\"math inline\">\\(\\gcd(x,y)\\)</span> 的一个质因子 <span class=\"math inline\">\\(p\\)</span>，将 <span class=\"math inline\">\\(x,y\\)</span> 同时除以 <span class=\"math inline\">\\(p\\)</span>。</li>\n</ol>\n<p>问最少花费多少次操作使得 <span class=\"math inline\">\\(\\min(x,y)=1\\)</span>。多测。</p>\n<p><span class=\"math inline\">\\(T\\le 300,1\\le x,y\\le 10^9\\)</span>。</p>\n</blockquote>\n<ul>\n<li><p>不妨先考虑 <span class=\"math inline\">\\(x\\ne y\\)</span> 的情况，发现三种操作都不会使 <span class=\"math inline\">\\(x,y\\)</span> 的相对大小关系改变。故令 <span class=\"math inline\">\\(x&lt;y\\)</span>，考虑让 <span class=\"math inline\">\\(x\\)</span> 变为 1。</p></li>\n<li><p>记 <span class=\"math inline\">\\(d=y-x\\)</span>， 很容易注意到 <span class=\"math inline\">\\(d\\)</span> 的值不会在前两种操作中改变，由辗转相减，<span class=\"math inline\">\\(\\gcd(x,y)=\\gcd(d, x)\\)</span>，即操作三每次选取的 <span class=\"math inline\">\\(p\\)</span> 总是 <span class=\"math inline\">\\(d\\)</span> 的质因子，且总能通过若干次操作 1/2 让 <span class=\"math inline\">\\(p\\)</span> 能够执行。</p>\n<p>每次执行操作 3 后，<span class=\"math inline\">\\(d\\gets d\\div p\\)</span>，每次只需让 <span class=\"math inline\">\\(x\\)</span> 变为 <span class=\"math inline\">\\(\\lfloor \\frac xp\\rfloor\\)</span> 或 <span class=\"math inline\">\\(\\lceil \\frac xp\\rceil\\)</span>。</p>\n<p>直接记搜的话，容易发现状态总数是 V 因数总数。</p></li>\n<li><p>对于 <span class=\"math inline\">\\(x=y\\)</span> 的情况，答案至多为 <span class=\"math inline\">\\(x\\)</span> 的质因子数量。暴搜 + 剪枝非常可过。</p>\n<details>\n<p><summary>有一种神秘的处理方式…</summary></p>\n<pre class=\"cpp\"><code>if (x == y) &#123;\n    auto calc = [&amp;](int x) &#123;\n        int cnt = 0;\n        for (int i = 2; i * i &lt;= x; ++i)\n            for (; x % i == 0; ++cnt, x /= i);\n        return cnt + (x != 1);\n    &#125;;\n    int to = calc(x), res = to;\n    for (int i = std::max(x - to, 1); i &lt;= x + to; ++i)\n        res = std::min(res, calc(i) + std::abs(i - x));\n    std::cout &lt;&lt; x &lt;&lt; &#39;\\n&#39;;\n    continue;\n&#125;</code></pre>\n<p>容易发现这东西没什么道理，反例大概率存在但在小范围内确实难以构造。总之数据没卡到。</p>\n</details></li>\n</ul>\n<hr />\n<h2 id=\"b.-bot-的矩阵\">B. bot 的矩阵</h2>\n<p><a href=\"https://www.becoder.com.cn/contest/6731/problem/2\" class=\"uri\">https://www.becoder.com.cn/contest/6731/problem/2</a></p>\n<blockquote>\n<p><strong>⚡带来终结机械降神⚡</strong></p>\n<p>有一个 <span class=\"math inline\">\\(n\\times n\\)</span> 的二维数组，初始只知道 <span class=\"math inline\">\\(m\\)</span> 个位置的数 <span class=\"math inline\">\\(a_{x,y}\\)</span>，以及每行、每列的元素和 <span class=\"math inline\">\\(sx_{1\\cdots n},sy_{1\\cdots n}\\)</span>。</p>\n<p>构造出一个合法的解，每个数在 <span class=\"math inline\">\\([-2^63,2^63)\\)</span> 内。</p>\n<p><span class=\"math inline\">\\(n\\le 2000\\)</span>,<span class=\"math inline\">\\(a_{x,y},sx_i,sy_i\\in [-10^9,10^9]\\)</span>，<span class=\"math inline\">\\(m\\le n^2\\)</span>。</p>\n</blockquote>\n<ul>\n<li><p>听说很容易想到二分图，但实在反应不过来。但在乱填的时候发现，如果出现了『必填』的情况，是一个行列交错的链式反应，这样就很容易想到二分图了</p>\n<p>原理是同时影响行 <span class=\"math inline\">\\(i\\)</span> 列 <span class=\"math inline\">\\(j\\)</span> 的元素只有 <span class=\"math inline\">\\((i, j)\\)</span></p></li>\n<li><p>相当于给一个 <span class=\"math inline\">\\(2n\\)</span> 个点 <span class=\"math inline\">\\(n^2\\)</span> 条边的二分图，其中一些边权是已知的，那么不妨认为这些边被删除了</p>\n<p>同时也是一个 <span class=\"math inline\">\\(n^2\\)</span> 个元，<span class=\"math inline\">\\(2n-1\\)</span> 个方程的方程组（<span class=\"math inline\">\\(sx=sy\\)</span> 会消掉一条方程）；故很多元其实可以直接赋 <span class=\"math inline\">\\(0\\)</span>，只拿 <span class=\"math inline\">\\(2n-1\\)</span> 个元出来解方程。</p></li>\n<li><p>在挖掉已知边的二分图上任意找生成树（森林）就可以满足 <span class=\"math inline\">\\(2n-1\\)</span> 的限制，结合树上高斯消元，从叶子开始解方程即可。</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\n#define int long long\n#define nec getchar\nvoid read(int &amp;x) &#123;\n    x = 0;\n    char ch = nec();\n    bool flag = false;\n    for (; ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;; ch = nec())\n        if (ch == &#39;-&#39;)\n            flag = true;\n    for (; ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;; ch = nec())\n        x = x * 10 + ch - &#39;0&#39;;\n    if (flag)\n        x = -x;\n    return;\n&#125;\nsigned main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;matrix3.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int T;\n    for (read(T); T--; ) &#123;\n        int n, m;\n        read(n), read(m);\n        std::vector&lt;int&gt; sx(n + 1), sy(n + 1);\n        for (int i = 1; i &lt;= n; ++i)\n            read(sx[i]);\n        for (int i = 1; i &lt;= n; ++i)\n            read(sy[i]);\n        std::vector&lt;std::vector&lt;int&gt; &gt; vis(n + 1, std::vector&lt;int&gt; (n + 1));\n        std::vector&lt;std::vector&lt;long long&gt; &gt; a(n + 1, std::vector&lt;long long&gt; (n + 1));\n        std::vector&lt;int&gt; tx(n + 1), ty(n + 1);\n        auto work = [&amp;](int i, int j, int c) &#123;\n            vis[i][j] = 1;\n            ++tx[i], ++ty[j];\n            sx[i] -= c, sy[j] -= c, a[i][j] = c;\n            return;\n        &#125;;\n        for (int x, y, c; m--; ) &#123;\n            read(x), read(y), read(c);\n            work(x, y, c);\n        &#125;\n        if (std::accumulate(sx.begin() + 1, sx.end(), 0ll) != std::accumulate(sy.begin() + 1, sy.end(), 0ll)) &#123;\n            std::cout &lt;&lt; &quot;NoSolution!&quot; &lt;&lt; &#39;\\n&#39;;\n            continue;\n        &#125;\n        std::vector&lt;int&gt; fx(n + 1), fy(n + 1);\n        std::function&lt;bool(void)&gt; check = [&amp;](void) &#123;\n            for (int x = 1; x &lt;= n; ++x)\n                if (!fx[x]) &#123;\n                    if (tx[x] == n) &#123;\n                        if (sx[x] != 0)\n                            return false;\n                        fx[x] = 1;\n                        if (!check())\n                            return false;\n                    &#125;\n                    else if (tx[x] == n - 1) &#123;\n                        for (int y = 1; y &lt;= n; ++y)\n                            if (!vis[x][y]) &#123;\n                                work(x, y, sx[x]);\n                                fx[x] = 1;\n                                if (!check())\n                                    return false;\n                            &#125;\n                    &#125;\n                &#125;\n            for (int y = 1; y &lt;= n; ++y)\n                if (!fy[y]) &#123;\n                    if (ty[y] == n) &#123;\n                        if (sy[y] != 0)\n                            return false;\n                        fy[y] = 1;\n                        if (!check())\n                            return false;\n                    &#125;\n                    else if (ty[y] == n - 1) &#123;\n                        for (int x = 1; x &lt;= n; ++x)\n                            if (!vis[x][y]) &#123;\n                                work(x, y, sy[y]);\n                                fy[y] = 1;\n                                if (!check())\n                                    return false;\n                            &#125;\n                    &#125;\n                &#125;\n            return true;\n        &#125;;\n        if (!check()) &#123;\n            std::cout &lt;&lt; &quot;NoSolution!&quot; &lt;&lt; &#39;\\n&#39;;\n            continue;\n        &#125;\n        std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int op) &#123;\n            if (op == 0) &#123;\n                fx[x] = 1;\n                for (int i = 1; i &lt;= n; ++i)\n                    if (!vis[x][i] &amp;&amp; !fy[i]) &#123;\n                        DFS(i, 1);\n                        work(x, i, sy[i]);\n                    &#125;\n            &#125;\n            else &#123;\n                fy[x] = 1;\n                for (int i = 1; i &lt;= n; ++i)\n                    if (!vis[i][x] &amp;&amp; !fx[i]) &#123;\n                        DFS(i, 0);\n                        work(i, x, sx[i]);\n                    &#125;\n            &#125;\n            return;\n        &#125;;\n        for (int i = 1; i &lt;= n; ++i)\n            if (!fx[i])\n                DFS(i, 0);\n        for (int i = 1; i &lt;= n; ++i)\n            if (!fy[i])\n                DFS(i, 1);\n        std::cout &lt;&lt; &quot;Botany!&quot; &lt;&lt; &#39;\\n&#39;;\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            for (int j = 1; j &lt;= n; ++j)\n                std::cout &lt;&lt; a[i][j] &lt;&lt; &#39; &#39;;\n            std::cout &lt;&lt; &#39;\\n&#39;;\n        &#125;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"a.-数码串\">A. 数码串</h2>\n<p><a href=\"https://www.becoder.com.cn/contest/6736/problem/1\" class=\"uri\">https://www.becoder.com.cn/contest/6736/problem/1</a></p>\n<blockquote>\n<p>给定一个长度为 <span class=\"math inline\">\\(n\\)</span> 的数字串，现在需要给它分为若干段，问在所有 <span class=\"math inline\">\\(2^{n-1}\\)</span> 种分段方式中，有多少种满足：</p>\n<ul>\n<li>在任意相邻的两段中，有至少一段，其对应的十进制数是 <span class=\"math inline\">\\(D\\)</span> 的倍数。</li>\n</ul>\n<p>答案对 <span class=\"math inline\">\\(10^9+7\\)</span> 取模。</p>\n<p>多测，<span class=\"math inline\">\\(n\\le 2\\times 10^5,D\\le 10^6,T\\le 100\\)</span>。</p>\n<p><strong>部分分特殊性质</strong>：<span class=\"math inline\">\\(\\gcd(D,10)=1\\)</span>。</p>\n</blockquote>\n<ul>\n<li><p>发现若 <span class=\"math inline\">\\(a_{l\\cdots r}\\)</span> 是 <span class=\"math inline\">\\(D\\)</span> 的倍数，记 <span class=\"math inline\">\\(s_i=s_{i+1}+a_i\\times 10^{n-i}\\)</span>，那么 <span class=\"math inline\">\\(\\dfrac{s_l-s_{r+1}}{10^{n-r}}\\bmod D=0\\)</span></p>\n<p>题目要求，这个转移点和上个转移点，至少有一个满足该式。显然可以类 DP 地做。</p></li>\n<li><p>对于 <span class=\"math inline\">\\(D\\)</span> 与 <span class=\"math inline\">\\(10\\)</span> 互质的情况，原条件等价于 <span class=\"math inline\">\\(s_l\\equiv s_{r+1}\\pmod D\\)</span>，用一个桶记录 DP 值即可</p></li>\n<li><p>记 <span class=\"math inline\">\\(D=2^*\\times 5^?\\times m\\)</span>，发现 <span class=\"math inline\">\\(m\\)</span> 与 <span class=\"math inline\">\\(10\\)</span> 互质，或许可以套用上方的做法</p>\n<p><mark>由于 <span class=\"math inline\">\\(D\\le 10^6 &lt; 2^{20}\\)</span>，对于一个固定的 <span class=\"math inline\">\\(r\\)</span>，所有 <span class=\"math inline\">\\(l\\le r-20\\)</span> 项的 <span class=\"math inline\">\\(a_l\\)</span> 对 <span class=\"math inline\">\\(a_{l\\cdots r}\\bmod (2^*\\times 5^?)\\)</span> 的贡献总是 <span class=\"math inline\">\\(0\\)</span></mark>，故在只考虑 <span class=\"math inline\">\\(2^*\\times 5^?\\)</span> 时， <span class=\"math inline\">\\(l\\le r-20\\)</span> 的可选性和 <span class=\"math inline\">\\(l=r-20\\)</span> 的可选性相同。只需要对于 <span class=\"math inline\">\\(\\bmod m\\)</span> 沿用桶做法即可。</p>\n<p>对于 <span class=\"math inline\">\\(l\\ge r-20\\)</span>，暴力即可，复杂度 <span class=\"math inline\">\\(O(T(n+D))\\)</span>。</p></li>\n</ul>\n<details>\n<p>注意 <span class=\"math inline\">\\(s_l-s_{r+1}\\)</span> 里的 <span class=\"math inline\">\\(r+1\\)</span>，调成鸲了</p>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 1e9 + 7;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n    std::freopen(&quot;digit.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;digit.out&quot;, &quot;w&quot;, stdout);\n#else\n    std::freopen(&quot;./test/20251113/digit/ex_digit1.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int T;\n    std::vector&lt;std::array&lt;long long, 2&gt; &gt; c(1e6);\n    for (std::cin &gt;&gt; T; T--; ) &#123;\n        std::string a;\n        int d, n, m, p;\n        std::cin &gt;&gt; a &gt;&gt; d, n = (int)a.length();\n        a = &quot;#&quot; + a;\n        std::vector&lt;std::vector&lt;long long&gt; &gt; f(n + 1, std::vector&lt;long long&gt; (2));\n        f[0][0] = 1ll;\n        m = d;\n        for (; m % 2 == 0; m /= 2);\n        for (; m % 5 == 0; m /= 5);\n        p = d / m;\n        for (int i = 0; i &lt; m; ++i)\n            c[i][0] = c[i][1] = 0ll;\n        std::vector&lt;int&gt; s(n + 2);\n        for (int i = n, k = 1; i; --i, (k *= 10) %= m)\n            s[i] = (s[i + 1] + (a[i] - &#39;0&#39;) * k) % m;\n        auto s0 = 0ll;\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            int now = 0;\n            for (int j = i, k = 1; j &gt; i - 20 &amp;&amp; j; --j, (k *= 10) %= d) &#123;\n                (now += (a[j] - &#39;0&#39;) * k) %= d;\n                if (now == 0)\n                    (f[i][0] += f[j - 1][0] + f[j - 1][1]) %= mod;\n                else\n                    (f[i][1] += f[j - 1][0]) %= mod;\n            &#125;\n            if (i &gt; 20) &#123;\n                (c[s[i - 20]][0] += f[i - 21][0]) %= mod;\n                (c[s[i - 20]][1] += f[i - 21][1]) %= mod;\n                (s0 += f[i - 21][0]) %= mod;\n                int now = 0;\n                for (int j = i, k = 1; j &gt;= i - 20; --j, (k *= 10) %= p)\n                    (now += (a[j] - &#39;0&#39;) * k) %= p;\n                if (now == 0) &#123;\n                    (f[i][0] += c[s[i + 1]][0] + c[s[i + 1]][1]) %= mod;\n                    (f[i][1] += s0 + mod - c[s[i + 1]][0]) %= mod;\n                &#125;\n                else\n                    (f[i][1] += s0) %= mod;\n            &#125;\n        &#125;\n        std::cout &lt;&lt; (f[n][0] + f[n][1]) % mod &lt;&lt; &#39;\\n&#39;;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"b.-背包\">B. 背包</h2>\n<p><a href=\"https://www.becoder.com.cn/contest/6736/problem/2\" class=\"uri\">https://www.becoder.com.cn/contest/6736/problem/2</a></p>\n<blockquote>\n<p>给定 <span class=\"math inline\">\\(n\\)</span> 种物品，第 <span class=\"math inline\">\\(i(1\\le i\\le n)\\)</span> 种有无穷多个，体积均为 <span class=\"math inline\">\\(v_i\\)</span>、价值均为 <span class=\"math inline\">\\(w_i\\)</span>。给定 <span class=\"math inline\">\\(Q\\)</span> 次询问，形如：</p>\n<ul>\n<li><p>给定一个背包容积 <span class=\"math inline\">\\(m\\)</span>，回答两个问题：</p>\n<ol type=\"1\">\n<li><strong>有序地</strong>选取体积和<strong>恰好</strong>为 <span class=\"math inline\">\\(m\\)</span> 的物品，所能得到的最大价值。如果不存在这样的选取方式，回答 <span class=\"math inline\">\\(-1\\)</span>。</li>\n<li>在上一问的条件下，可能的方案数。两个方案不同，当且仅当选取的物品数不同，或选物序列的某个位置不同。对 <span class=\"math inline\">\\(1092515507\\)</span> 取模，不存在则回答 <span class=\"math inline\">\\(-1\\)</span>。</li>\n</ol></li>\n</ul>\n<p><span class=\"math inline\">\\(n,Q,v_i\\le 100, m,w_i\\le 10^9\\)</span>。</p>\n</blockquote>\n<p>mobai ddxrS</p>\n<ul>\n<li><p>Tip：由于选取是有序的，所以朴素的『枚举物品 + 枚举体积』的 DP 是不可行的，而需要『枚举体积 + 枚举物品』。</p></li>\n<li><p>很容易写出朴素的 DP：令二元组 <span class=\"math inline\">\\((a, b)_{m}\\)</span> 表示总体积 <span class=\"math inline\">\\(m\\)</span> 下的两问答案，则<strong>合并答案</strong>（定义为 <span class=\"math inline\">\\(+\\)</span> 运算）的过程可以写为：</p>\n<p><span class=\"math display\">\\[\n(a_1,b_1)_{m}+(a_2,b_2)_{m}=\\begin{cases}\n(a_1,b_1)_{m}&amp;a_1&gt;a_2\\\\\n(a_1,b_1+b_2)_{m}&amp;a_1=a_2\\\\\n(a_2, b_2)_{m}&amp;\\text{otherwise}\n\\end{cases}\n\\]</span></p></li>\n<li><p>相似地，<strong>状态转移</strong>（定义为 <span class=\"math inline\">\\(\\times\\)</span> 运算）可以写为：</p>\n<p><span class=\"math display\">\\[\n(a_1,b_1)_{m_1}\\times (a_2,b_2)_{m_2}=(a_1+a_2,b_1\\times b_2)_{m_1+m_2}\n\\]</span></p>\n<p>Tips：实际上是借鉴了矩阵乘法的含义进行定义，这样就可以尝试优化。</p></li>\n<li><p>这样就有 <span class=\"math inline\">\\((f,g)_i = \\sum\\limits_{j=1}^n (f,g)_{i-v_j}\\times (w_j,1)_{v_j}\\)</span>。</p></li>\n<li><p>感性理解：显然，在直接背包时，<span class=\"math inline\">\\(+\\)</span> 运算与 <span class=\"math inline\">\\(\\times\\)</span> 运算具有交换律，且 <span class=\"math inline\">\\(\\times\\)</span> 对 <span class=\"math inline\">\\(+\\)</span> 有分配律。</p>\n<p>那么此时广义矩乘具有结合律，可以优化。</p></li>\n<li><p>体积最大为 <span class=\"math inline\">\\(100\\)</span>，考虑开 <span class=\"math inline\">\\(100\\times 100\\)</span> 的矩阵（元素为二元组）维护 <span class=\"math inline\">\\((f,g)_{i-99}\\sim (f,g)_i\\)</span>。考虑直接快速幂，发现复杂度是非常糟糕的 <span class=\"math inline\">\\(O(qv^3\\log m)\\)</span>，非常糟糕。</p>\n<p>初始矩阵是 <span class=\"math inline\">\\(1\\times 100\\)</span> 的，这里的处理方式是预处理每一个 <span class=\"math inline\">\\(2^i\\)</span> 次幂（<span class=\"math inline\">\\(O(v^3\\log m)\\)</span>），每次询问时二进制拆分 <span class=\"math inline\">\\(m\\)</span>，线性地乘过去，就可以把矩阵乘法优化为矩阵乘向量，复杂度降至 <span class=\"math inline\">\\(O(qv^2\\log m)\\)</span>。</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconstexpr int N = 100;\nconst long long inf = 1e18;\nconst int mod = 1092515507;\nstruct node &#123;\n    long long f, g;\n    node(): f(-inf), g(0ll) &#123;&#125;\n    node(long long f1, long long g1): f(f1), g(g1) &#123;\n        if (g &gt;= mod)\n            g -= mod;\n        return;\n    &#125;\n    node operator* (const node &amp;q) const &#123;\n        return node(f + q.f, g * q.g % mod);\n    &#125;\n    node operator+ (const node &amp;q) const &#123;\n        if (f &gt; q.f)\n            return *this;\n        else if (f == q.f)\n            return node(f, g + q.g);\n        return q;\n    &#125;\n    node&amp; operator+= (const node &amp;q) &#123;\n        return *this = *this + q;\n    &#125;\n&#125;;\nstruct mat &#123;\n    std::vector&lt;std::vector&lt;node&gt; &gt; a;\n    mat(void): a(N, std::vector&lt;node&gt; (N)) &#123;&#125;\n    std::vector&lt;node&gt;&amp; operator[] (const int q) &#123;\n        return a[q];\n    &#125;\n    mat operator* (mat &amp;q) const &#123;\n        mat res;\n        for (int i = 0; i &lt; N; ++i)\n            for (int k = 0; k &lt; N; ++k)\n                for (int j = 0; j &lt; N; ++j) \n                    res[i][j] += a[i][k] * q[k][j];\n        return res;\n    &#125;\n&#125;;\nstruct vec &#123;\n    std::vector&lt;node&gt; a;\n    vec(void): a(N) &#123;&#125;\n    node&amp; operator[] (const int q) &#123;\n        return a[q];\n    &#125;\n    vec operator* (mat &amp;q) const &#123;\n        vec res;\n        for (int k = 0; k &lt; N; ++k)\n            for (int j = 0; j &lt; N; ++j)\n                res[j] += a[k] * q[k][j];\n        return res;\n    &#125;\n    vec&amp; operator*= (mat &amp;q) &#123;\n        return *this = *this * q;\n    &#125;\n&#125;;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n    std::freopen(&quot;pack.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;pack.out&quot;, &quot;w&quot;, stdout);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, q;\n    std::cin &gt;&gt; n &gt;&gt; q;\n    std::vector&lt;int&gt; v(n + 1), w(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; v[i];\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; w[i];\n    std::vector&lt;mat&gt; t(30);\n    for (int j = 0; j &lt; N - 1; ++j)\n        t[0][j + 1][j] += node(0ll, 1ll);\n    for (int i = 1; i &lt;= n; ++i)\n        t[0][N - v[i]][N - 1] += node(w[i], 1ll);\n    for (int i = 1; i &lt; 30; ++i)\n        t[i] = t[i - 1] * t[i - 1];\n    vec init;\n    init[N - 1] = node(0ll, 1ll);\n    for (int m; q--; ) &#123;\n        std::cin &gt;&gt; m;\n        auto res(init);\n        for (int i = 29; ~i; --i)\n            if ((m &gt;&gt; i) &amp; 1)\n                res *= t[i];\n        if (res[N - 1].f &lt;= 0)\n            std::cout &lt;&lt; -1 &lt;&lt; &#39; &#39; &lt;&lt; -1 &lt;&lt; &#39;\\n&#39;;\n        else\n            std::cout &lt;&lt; res[N - 1].f &lt;&lt; &#39; &#39; &lt;&lt; res[N - 1].g &lt;&lt; &#39;\\n&#39;;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"a.-关卡设计\">A. 关卡设计</h2>\n<p><a href=\"https://www.becoder.com.cn/contest/6742/problem/1\" class=\"uri\">https://www.becoder.com.cn/contest/6742/problem/1</a></p>\n<blockquote>\n<p>给定 <span class=\"math inline\">\\(n\\times m\\)</span> 的字符地图，其中 <code>S</code> 为起点（有且仅有一个），<code>R</code>，<code>B</code> 为红、蓝宝石（可能有多个），<code>x</code> 为障碍、<code>.</code> 为可通行地块。</p>\n<p>现在需要把尽可能多的 <code>.</code> 变为 <code>x</code>，使得一种原来可以由 <code>S</code> 出发收集到的宝石在修改后的地图中仍能被收集。输出最多可修改的 <code>.</code> 的数量。</p>\n<p><span class=\"math inline\">\\(n\\times m\\le 10^6\\)</span>。</p>\n</blockquote>\n<ul>\n<li><p>一种显然错误的做法：拆点 <span class=\"math inline\">\\((u,0/1/2/3)\\)</span> 分别表示走到 <span class=\"math inline\">\\(u\\)</span> 时的宝石收集状态，跑 01BFS。</p>\n<p>错误的原因：路径会重复走一些边，但它们不能被重复记入代价。</p></li>\n<li><p>结合『重复走一些边』的想法，发现路径一定有一个『分叉点』。枚举这样的分叉点，从 <code>S</code>、所有 <code>R</code>、所有 <code>B</code> 出发分别跑 01BFS。</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int dir[][2] = &#123; &#123; 0, -1 &#125;, &#123; 0, 1 &#125;, &#123; -1, 0 &#125;, &#123; 1, 0 &#125; &#125;;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n    std::freopen(&quot;design.out&quot;, &quot;w&quot;, stdout);\n    std::freopen(&quot;design.in&quot;, &quot;r&quot;, stdin);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int T;\n    for (std::cin &gt;&gt; T; T--; ) &#123;\n        int n, m,  cnt = 0;\n        std::cin &gt;&gt; n &gt;&gt; m;\n        std::vector&lt;std::vector&lt;char&gt; &gt; a(n + 1, std::vector&lt;char&gt; (m + 1));\n        for (int i = 1; i &lt;= n; ++i)\n            for (int j = 1; j &lt;= m; ++j) &#123;\n                std::cin &gt;&gt; a[i][j];\n                cnt += (a[i][j] == &#39;.&#39;);\n            &#125;\n        const int N = n * m;\n        auto id = [&amp;](int i, int j) &#123; return (i - 1) * m + j; &#125;;\n        std::vector&lt;std::vector&lt;int&gt; &gt; dis(3, std::vector&lt;int&gt; (N + 1, N + 1));\n        auto work = [&amp;](std::vector&lt;int&gt; &amp;dis, char S) &#123;\n            std::deque&lt;int&gt; q;\n            std::vector&lt;int&gt; vis(N + 1);\n            for (int i = 1; i &lt;= n; ++i)\n                for (int j = 1; j &lt;= m; ++j)\n                    if (a[i][j] == S) &#123;\n                        dis[id(i, j)] = 0;\n                        q.push_back(id(i, j));\n                    &#125;\n            for (; !q.empty(); ) &#123;\n                int x, y;\n                &#123;\n                    int t = q.front();\n                    q.pop_front();\n                    if (vis[t])\n                        continue;\n                    vis[t] = 1;\n                    x = (t - 1) / m + 1, y = t - (x - 1) * m;\n                &#125;\n                for (auto [fx, fy] : dir) &#123;\n                    int nx = x + fx, ny = y + fy;\n                    if (nx &gt;= 1 &amp;&amp; ny &gt;= 1 &amp;&amp; nx &lt;= n &amp;&amp; ny &lt;= m &amp;&amp; a[nx][ny] != &#39;x&#39;) &#123;\n                        if (a[nx][ny] != &#39;.&#39;) &#123;\n                            if (dis[id(nx, ny)] &gt; dis[id(x, y)]) &#123;\n                                dis[id(nx, ny)] = dis[id(x, y)];\n                                q.push_front(id(nx, ny));\n                            &#125;\n                        &#125;\n                        else if (dis[id(nx, ny)] &gt; dis[id(x, y)] + 1) &#123;\n                            dis[id(nx, ny)] = dis[id(x, y)] + 1;\n                            q.push_back(id(nx, ny));\n                        &#125;\n                    &#125;\n                &#125;\n            &#125;\n        &#125;;\n        work(dis[0], &#39;S&#39;), work(dis[1], &#39;R&#39;), work(dis[2], &#39;B&#39;);\n        int mn1 = N + 1, mn2 = N + 1;\n        for (int i = 1; i &lt;= n; ++i)\n            for (int j = 1; j &lt;= m; ++j) &#123;\n                mn1 = std::min(mn1, dis[0][id(i, j)] + std::min(dis[1][id(i, j)], dis[2][id(i, j)]) - (a[i][j] == &#39;.&#39;));\n                mn2 = std::min(mn2, dis[0][id(i, j)] + dis[1][id(i, j)] + dis[2][id(i, j)] - (a[i][j] == &#39;.&#39;) * 2);\n            &#125;\n        if (mn2 != N + 1)\n            std::cout &lt;&lt; cnt - mn2 &lt;&lt; &#39;\\n&#39;;\n        else if (mn1 != N + 1)\n            std::cout &lt;&lt; cnt - mn1 &lt;&lt; &#39;\\n&#39;;\n        else\n            std::cout &lt;&lt; cnt &lt;&lt; &#39;\\n&#39;;\n    &#125;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"c.-炼金术\">C. 炼金术</h2>\n<p><a href=\"https://www.becoder.com.cn/contest/6742/problem/3\" class=\"uri\">https://www.becoder.com.cn/contest/6742/problem/3</a></p>\n<blockquote>\n<p>给定 <span class=\"math inline\">\\(A_{1\\cdots n}\\)</span> 和 <span class=\"math inline\">\\(B_{1\\cdots n}\\)</span>，给定 <span class=\"math inline\">\\(m\\)</span> 次操作，形如：</p>\n<ul>\n<li><code>1 l r x</code>，将 <span class=\"math inline\">\\(A_{l\\cdots r}\\)</span> 赋为 <span class=\"math inline\">\\(x\\)</span>。</li>\n<li><code>2 l r</code>，询问 <span class=\"math inline\">\\(\\min\\limits_{i\\in [l, r]}\\left\\{ \\text{lcm}(A_i,B_i)+\\dfrac{\\text{lcm}(A_i,B_i)}{\\gcd(A_i,B_i)} \\right\\}\\)</span> 的值。</li>\n</ul>\n<p><span class=\"math inline\">\\(n,m\\le 5\\times 10^4,V=5\\times 10^4\\)</span>。</p>\n</blockquote>\n<ul>\n<li><p>待求没什么太好的性质，考虑更暴力的解决方式。</p>\n<p>容易想到分块做法，对于整块赋值，容易想到对于每个 <span class=\"math inline\">\\(x\\)</span> 预处理块内答案。如何快速做到这一点？</p>\n<p>一个想法是枚举 gcd 的值 <span class=\"math inline\">\\(p\\)</span>（显然只需枚举 <span class=\"math inline\">\\(x\\)</span> 的因子），计算 <span class=\"math inline\">\\(\\dfrac {b_j\\times x}p+\\dfrac {b_j\\times x}{p^2}\\)</span> 的最小值。</p>\n<p><em>Tip：枚举到的 <span class=\"math inline\">\\(p\\)</span> 可能不是 gcd，但能保证一定能找到答案。</em></p></li>\n<li><p>贪心地，只需对于块内 <span class=\"math inline\">\\(p\\)</span> 的最小倍数计算答案。这一点对于每个 <span class=\"math inline\">\\(b_i\\)</span> 枚举因数即能 <span class=\"math inline\">\\(O(n\\sqrt V)\\)</span> 地预处理（因为有重复元素所以不是 <span class=\"math inline\">\\(O(V\\log V)\\)</span>）、花费 <span class=\"math inline\">\\(O(V\\log n)\\)</span> 的空间存储。</p></li>\n<li><p>对于每个 <span class=\"math inline\">\\(x\\)</span>，复杂度不允许暴力枚举 <span class=\"math inline\">\\(x\\)</span> 的因子；发现 <span class=\"math inline\">\\(x\\)</span> 的因子是 <span class=\"math inline\">\\(x\\)</span> 与『对于所有 <span class=\"math inline\">\\(x\\)</span> 的质因子 <span class=\"math inline\">\\(m\\)</span>，<span class=\"math inline\">\\(\\dfrac xm\\)</span> 的因子』的并。</p>\n<p>考虑一个类 DP 的过程，则 <span class=\"math inline\">\\(f_x\\gets f_{x\\div m}\\times m\\)</span>，再计算 <span class=\"math inline\">\\(x\\)</span> 自身的答案即可。由于 <span class=\"math inline\">\\(\\omega(V)\\)</span> 平均为 <span class=\"math inline\">\\(\\log\\log V\\)</span>，此时预处理复杂度降低至 <span class=\"math inline\">\\(O(n\\sqrt V + V\\log V\\sqrt n)\\)</span>。</p></li>\n<li><p>用一点科技加速 gcd 即可。可选 <span class=\"math inline\">\\(O(1)\\)</span> gcd，或小范围打表 + 大范围暴力跳至小范围。</p></li>\n</ul>\n<details>\n<p>注意待求可能会爆 <code>unsigned int</code>，问就是挂分了。</p>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n    std::freopen(&quot;alchemy.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;alchemy.out&quot;, &quot;w&quot;, stdout);\n#else\n    std::freopen(&quot;./test/20251115/alchemy/alchemy4.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    const long long inf = 1e18;\n    const int M = 5000, N = 50000;\n    std::vector&lt;std::vector&lt;int&gt; &gt; g(M + 1, std::vector&lt;int&gt; (M + 1));\n    for (int i = 0; i &lt;= M; ++i) &#123;\n        for (int j = 0; j &lt; i; ++j)\n            g[i][j] = g[j][i];\n        g[i][i] = i;\n        for (int j = i + 1; j &lt;= M; ++j)\n            g[i][j] = std::__gcd(i, j);\n    &#125;\n    std::function&lt;int(int, int)&gt; gcd = [&amp;](int x, int y) &#123;\n        if (x &lt;= M &amp;&amp; y &lt;= M)\n            return g[x][y];\n        return y ? gcd(y, x % y) : x;\n    &#125;;\n    std::vector&lt;std::vector&lt;int&gt; &gt; fac(N + 1);\n    for (int i = 2; i &lt;= N; ++i)\n        if (fac[i].empty())\n            for (int j = i; j &lt;= N; j += i)\n                fac[j].push_back(i);\n    int n, m;\n    std::cin &gt;&gt; n &gt;&gt; m;\n    std::vector&lt;long long&gt; a(n + 1), b(n + 1), p(n + 1);\n    auto calc = [&amp;](long long x, long long y) &#123;\n        auto g = gcd(x, y);\n        return x * y / g + x * y / g / g;\n    &#125;;\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i];\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; b[i];\n        p[i] = calc(a[i], b[i]);\n    &#125;\n    int siz = sqrt(n), k = (n + siz - 1) / siz;\n    std::vector&lt;long long&gt; u(k + 1, inf);\n    std::vector&lt;int&gt; L(k + 1), R(k + 1), id(n + 1), d(k + 1, -1);\n    std::vector&lt;std::vector&lt;long long&gt; &gt; mn(k + 1, std::vector&lt;long long&gt; (N + 1, inf)), s(k + 1, std::vector&lt;long long&gt; (N + 1));\n    for (int i = 1; i &lt;= k; ++i) &#123;\n        L[i] = R[i - 1] + 1, R[i] = std::min(L[i] + siz - 1, n);\n        for (int j = L[i]; j &lt;= R[i]; ++j) &#123;\n            id[j] = i, u[i] = std::min(u[i], p[j]);\n            for (int k = 1; k * k &lt;= b[j]; ++k)\n                if (b[j] % k == 0) &#123;\n                    mn[i][k] = std::min(mn[i][k], b[j]);\n                    mn[i][b[j] / k] = std::min(mn[i][b[j] / k], b[j]);\n                &#125;\n        &#125;\n        s[i][1] = mn[i][1] * 2;\n        for (int j = 2; j &lt;= N; ++j) &#123;\n            s[i][j] = mn[i][j] + mn[i][j] / j;\n            for (auto k : fac[j])\n                s[i][j] = std::min(s[i][j], s[i][j / k] * k);\n        &#125;\n    &#125;\n    auto pushdown = [&amp;](int id) &#123;\n        if (d[id] != -1) &#123;\n            for (int i = L[id]; i &lt;= R[id]; ++i)\n                p[i] = calc(d[id], b[i]);\n            d[id] = -1;\n        &#125;\n        return;\n    &#125;;\n    auto ADD = [&amp;](int l, int r, int x) &#123;\n        int pl = id[l], pr = id[r];\n        pushdown(pl);\n        if (pl == pr) &#123;\n            for (int i = l; i &lt;= r; ++i)\n                p[i] = calc(x, b[i]);\n            u[pl] = *std::min_element(p.begin() + L[pl], p.begin() + R[pl] + 1);\n            return;\n        &#125;\n        pushdown(pr);\n        for (int i = l; i &lt;= R[pl]; ++i)\n            p[i] = calc(x, b[i]);\n        u[pl] = *std::min_element(p.begin() + L[pl], p.begin() + R[pl] + 1);\n        for (int i = L[pr]; i &lt;= r; ++i)\n            p[i] = calc(x, b[i]);\n        u[pr] = *std::min_element(p.begin() + L[pr], p.begin() + R[pr] + 1);\n        for (int i = pl + 1; i &lt; pr; ++i)\n            d[i] = x, u[i] = s[i][x];\n        return;\n    &#125;;\n    auto ASK = [&amp;](int l, int r) &#123;\n        int pl = id[l], pr = id[r];\n        pushdown(pl);\n        if (pl == pr)\n            return *std::min_element(p.begin() + l, p.begin() + r + 1);\n        pushdown(pr);\n        auto res = std::min(*std::min_element(p.begin() + l, p.begin() + R[pl] + 1), *std::min_element(p.begin() + L[pr], p.begin() + r + 1));\n        if (pl + 1 != pr)\n            res = std::min(res, *std::min_element(u.begin() + pl + 1, u.begin() + pr));\n        return res;\n    &#125;;\n    for (int op, l, r; m--; ) &#123;\n        std::cin &gt;&gt; op &gt;&gt; l &gt;&gt; r;\n        if (op == 1) &#123;\n            int x;\n            std::cin &gt;&gt; x, ADD(l, r, x);\n        &#125;\n        else\n            std::cout &lt;&lt; ASK(l, r) &lt;&lt; &#39;\\n&#39;;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n",
            "tags": [
                "二分图",
                "计数",
                "DP 套 DP",
                "搜索"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20251103/",
            "url": "https://xsc062.netlify.app/20251103/",
            "title": "杂题选谈：数数 & 容斥",
            "date_published": "2025-11-03T03:59:00.000Z",
            "content_html": "<p>数数，但是性质题</p>\n<span id=\"more\"></span>\n<hr />\n<h2 id=\"a---reversi-2\">A - Reversi 2</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/AT_arc189_a\" class=\"uri\">https://www.luogu.com.cn/problem/AT_arc189_a</a></p>\n<ul>\n<li><p>操作可以看成，任选一个点，找到两侧最近的颜色相异的点，进行推平。</p>\n<p>或，任选一个极长连续段，推平为其两端的颜色。</p></li>\n<li><p>很容易注意到最终序列被分为若干个极长连续段，彼此独立。对于起始序列，容易发现任意区间中的任意操作会减少 2 的不同段数量（故显然最终序列连续段长度应该为奇数，且两端颜色和目标颜色一致）。</p></li>\n<li><p>令 <span class=\"math inline\">\\(f_i\\)</span> 为长度为 <span class=\"math inline\">\\(i\\)</span> 的连续段被推平的方案数（<span class=\"math inline\">\\(i\\bmod2=1\\)</span>），那么有 <span class=\"math inline\">\\(f_i=(i - 2)\\times f_{i-2}\\)</span>。</p></li>\n<li><p>最终方案数应为所有极长段方案的多重集排列乘上它们各自独立方案数之积。</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 998244353;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::syns_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;int&gt; a(n + 1);\n    std::vector&lt;long long&gt; f(n + 1), fac(n + 1), inv(n + 1);\n    fac[0] = inv[0] = 1ll;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; a[i];\n        fac[i] = fac[i - 1] * i % mod;\n    &#125;\n    auto qkp = [&amp;](long long x, int y) &#123;\n        auto res = 1ll;\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    inv[n] = qkp(fac[n], mod - 2);\n    for (int i = n - 1; i; --i)\n        inv[i] = inv[i + 1] * (i + 1) % mod;\n    f[1] = 1;\n    for (int i = 3; i &lt;= n; i += 2)\n        f[i] = f[i - 2] * (i - 2) % mod;\n    auto res = 1ll;\n    int L = 1, cnt = 0;\n    for (int i = 1; i &lt;= n; ++i)\n        if (i == n || a[i + 1] != a[i]) &#123;\n            if (a[i] != i % 2 || (i - L + 1) % 2 == 0) &#123;\n                std::cout &lt;&lt; 0 &lt;&lt; &#39;\\n&#39;;\n                return 0;\n            &#125;\n            (res *= f[i - L + 1]) %= mod;\n            (res *= inv[(i - L) / 2]) %= mod;\n            cnt += (i - L) / 2;\n            L = i + 1;\n        &#125;\n    std::cout &lt;&lt; res * fac[cnt] % mod &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"b---cigar-box\">B - Cigar Box</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/AT_arc112_e\" class=\"uri\">https://www.luogu.com.cn/problem/AT_arc112_e</a></p>\n<ul>\n<li><p>发现一个数的状态只取决于，最后一次以它为主体的操作，及这次操作之后的所有操作</p></li>\n<li><p>进一步地发现，按最后一次操作分类，可以分为，向左（<code>L</code>）、向右（<code>R</code>）、没被操作过（<code>M</code>）三种类型。</p>\n<p>可以很显然地注意到，最终序列一定是 <code>LLLMMMRRR</code> 的形式，其中，仅要求 <code>M</code> 是递增的；现在需要计算有多少长度为 <span class=\"math inline\">\\(m\\)</span> 的操作序列对应所有的 <code>LMR</code> 序列（如果认为所有的 <code>M</code> 始终是不动的可能会更好理解）。</p></li>\n<li><p>发现同种类数间，『最后一次操作』的相对顺序是固定的。进一步会发现这其实是<a href=\"https://oi-wiki.org/math/combinatorics/stirling/\">第二类斯特林数</a>，最后答案为：</p></li>\n</ul>\n<p><span class=\"math display\">\\[\n\\sum_{L,R}\\binom{L+R}{L}\\cdot \\begin{Bmatrix}m\\\\ L+R\\end{Bmatrix}\\cdot 2^{m-L-R}\n\\]</span></p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 998244353;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::syns_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, m;\n    std::cin &gt;&gt; n &gt;&gt; m;\n    using arr = std::vector&lt;long long&gt;;\n    arr pw(m + 1), fac(m + 1), inv(m + 1);\n    std::vector&lt;arr&gt; f(m + 1, arr(m + 1));\n    std::vector&lt;int&gt; a(n + 1);\n    std::vector&lt;std::vector&lt;int&gt; &gt; ok(n + 1, std::vector&lt;int&gt; (n + 1));\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i];\n    for (int l = 1; l &lt;= n; ++l)\n        for (int r = l; r &lt;= n; ++r)\n            if (r == l || a[r] &gt; a[r - 1])\n                ok[l][r] = 1;\n            else\n                break;\n    f[1][1] = 1ll, pw[0] = fac[0] = inv[0] = 1ll;\n    for (int i = 2; i &lt;= m; ++i)\n        for (int j = 1; j &lt;= i; ++j)\n            f[i][j] = (f[i - 1][j - 1] + f[i - 1][j] * j) % mod;\n    for (int i = 1; i &lt;= m; ++i) &#123;\n        pw[i] = pw[i - 1] * 2 % mod;\n        fac[i] = fac[i - 1] * i % mod;\n    &#125;\n    auto qkp = [&amp;](long long x, int y) &#123;\n        auto res = 1ll;\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    inv[m] = qkp(fac[m], mod - 2);\n    for (int i = m - 1; i; --i)\n        inv[i] = inv[i + 1] * (i + 1) % mod;\n    auto C = [&amp;](int n, int m) &#123;\n        return fac[n] * inv[m] % mod * inv[n - m] % mod;\n    &#125;;\n    auto res = 0ll;\n    for (int L = 0; L &lt;= m &amp;&amp; L &lt;= n; ++L)\n        for (int R = 0; L + R &lt;= m &amp;&amp; L + R &lt;= n; ++R)\n            if (L + 1 &gt; n - R || ok[L + 1][n - R])\n                res += C(L + R, L) * f[m][L + R] % mod * pw[m - L - R] % mod;\n    std::cout &lt;&lt; res % mod &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"c---swap-characters\">C - Swap Characters</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/AT_arc168_c\" class=\"uri\">https://www.luogu.com.cn/problem/AT_arc168_c</a></p>\n<ul>\n<li><p>考虑值域为 <span class=\"math inline\">\\(0\\)</span> 和 <span class=\"math inline\">\\(1\\)</span> 的情况</p>\n<p>发现这个很唐 <del>好险，AI 差点比我先做出来了</del>，转化成枚举操作次数 <span class=\"math inline\">\\(i\\)</span>，答案是</p>\n<p><span class=\"math display\">\\[\n\\sum_{i\\le\\min(s_0,s_1)}\\binom{s_0}{i}\\cdot\\binom{s_1}{i}\n\\]</span></p></li>\n<li><p>根据这个可以得到启发，发现所谓任意交换可以转化为，每个字母的支出和收入相等，故考虑画个表：</p></li>\n</ul>\n<hr />\n<h2 id=\"a---leq-and-neq-non-equal-neighbours\">A - LEQ and NEQ / Non-equal Neighbours</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/AT_arc115_e\" class=\"uri\">https://www.luogu.com.cn/problem/AT_arc115_e</a> / <a href=\"https://www.luogu.com.cn/problem/CF1591F\" class=\"uri\">https://www.luogu.com.cn/problem/CF1591F</a> / <a href=\"https://www.luogu.com.cn/problem/CF1585F\" class=\"uri\">https://www.luogu.com.cn/problem/CF1585F</a></p>\n<ul>\n<li><p>容斥，钦定有 <span class=\"math inline\">\\(i\\)</span> 对相同元素，那么答案为 <span class=\"math inline\">\\(\\sum\\limits_{i=0}^{n-1} (-1)^{n-1-i} \\cdot g_i\\)</span>，其中 <span class=\"math inline\">\\(g_i\\)</span> 表示至少有 <span class=\"math inline\">\\(i\\)</span> 对相同元素的方案数。</p></li>\n<li><p>考虑 <span class=\"math inline\">\\(g_i\\)</span> 的计算，朴素的做法是二维 DP，令 <span class=\"math inline\">\\(f_{i, j}\\)</span> 表示 DP 到 <span class=\"math inline\">\\(i\\)</span>，已经有了至多 <span class=\"math inline\">\\(j\\)</span> 对不同元素的方案数（发现这样才更好 DP）。发现没啥好的 <span class=\"math inline\">\\(O(n^2)\\)</span> 转移，只能 <span class=\"math inline\">\\(O(n^3)\\)</span>：</p>\n<p><span class=\"math display\">\\[\nf_{i,j}=\\sum_{k&lt;i}f_{k, j-1}\\times \\min\\{A_{k+1\\cdots i}\\}\n\\]</span></p></li>\n<li><p>一个适用于容斥 DP 的 nb 优化：发现系数只取决于 <span class=\"math inline\">\\(j\\)</span> 维的奇偶性，发现转移也只关注奇偶性，故设 <span class=\"math inline\">\\(f_{i,0/1}\\)</span> 减少一维。</p>\n<p>同时，很显然存在一个单调栈优化的结构，这样就可以在 <span class=\"math inline\">\\(O(n)\\)</span> 内完成 DP。</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 998244353;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;int&gt; a(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i];\n    struct node &#123; int mn; long long c0, c1; &#125;;\n    std::stack&lt;node&gt; st;\n    std::vector&lt;std::array&lt;long long, 2&gt; &gt; f(n + 1);\n    f[0][0] = 1ll, f[0][1] = 0ll;\n    auto s0 = 0x3f3f3f3fll, s1 = 0ll;\n    st.push(&#123; 0x3f3f3f3f, 1ll, 0ll &#125;);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        auto p0 = 0ll, p1 = 0ll;\n        for (; !st.empty(); ) &#123;\n            auto [mn, c0, c1] = st.top();\n            if (mn &lt;= a[i])\n                break;\n            st.pop();\n            p0 += c0, p1 += c1;\n            (s0 += mod - c0 * (mn - a[i]) % mod) %= mod;\n            (s1 += mod - c1 * (mn - a[i]) % mod) %= mod;\n        &#125;\n        st.push(&#123; a[i], p0 % mod, p1 % mod &#125;);\n        f[i][0] = s1, f[i][1] = s0;\n        (s0 += f[i][0] * 0x3f3f3f3f % mod) %= mod;\n        (s1 += f[i][1] * 0x3f3f3f3f % mod) %= mod;\n        st.push(&#123; 0x3f3f3f3f, f[i][0], f[i][1] &#125;);\n    &#125;\n    std::cout &lt;&lt; (f[n][n &amp; 1] + mod - f[n][(n &amp; 1) ^ 1]) % mod &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"b---unbranched\">B - Unbranched</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/AT_abc180_f\" class=\"uri\">https://www.luogu.com.cn/problem/AT_abc180_f</a></p>\n<ul>\n<li><p>注意到只会有环和链两种情况。发现消耗的点数和边数是不同的，再加上题目有边数限制，令 <span class=\"math inline\">\\(f_{i,j}\\)</span> 表示消耗了 <span class=\"math inline\">\\(i\\)</span> 个点 <span class=\"math inline\">\\(j\\)</span> 条边时的方案数。</p></li>\n<li><p>转移是显然的：</p>\n<p>对于环的情况，答案为圆排列去掉翻折，即 <span class=\"math inline\">\\(\\dfrac {(k-1)!}2\\)</span>。特别地，二元环的圆排列不存在翻折，故答案为 <span class=\"math inline\">\\(1\\)</span>。</p>\n<p>对于链的情况，去掉翻折即可，答案为 <span class=\"math inline\">\\(\\dfrac {k!}2\\)</span>。</p></li>\n<li><p>去重，参考典型的图计数问题，钦定没被选的点中，标号最小的必须被选，所以会有 <span class=\"math inline\">\\(C(n-(i-k)-1,k-1)\\)</span> 的系数。</p></li>\n<li><p>显然对于最大值恰好为 <span class=\"math inline\">\\(L\\)</span> 的限制可以直接记一个 <code>bool</code> 量在状态里；尊重一下容斥的标题，用 <span class=\"math inline\">\\(L\\)</span> 的答案减去 <span class=\"math inline\">\\(L-1\\)</span> 的答案亦可。</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 1e9 + 7;\nconst int inv2 = (mod + 1) &gt;&gt; 1;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, m, L;\n    std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; L;\n    using arr = std::vector&lt;long long&gt;;\n    using brr = std::vector&lt;arr&gt;;\n    using crr = std::vector&lt;brr&gt;;\n    arr fac(n + 1);\n    brr C(n + 1, arr(n + 1));\n    fac[0] = 1ll, C[0][0] = 1ll;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        C[i][0] = 1ll;\n        fac[i] = fac[i - 1] * i % mod;\n        for (int j = 1; j &lt;= i; ++j)\n            C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % mod;\n    &#125;\n    crr f(n + 1, brr(m + 1, arr(2)));\n    f[0][0][0] = 1ll;\n    auto work = [&amp;](int i, int j, int k, int p1, int p2) &#123;\n        if (k == 1)\n            f[i][j][p2] += f[i - 1][j][p1];\n        else if (k == 2) &#123;\n            if (j &gt;= 2)\n                f[i][j][p2] += f[i - 2][j - 2][p1] * C[n - (i - k) - 1][k - 1] % mod; \n            if (j &gt;= 1)\n                f[i][j][p2] += f[i - 2][j - 1][p1] * C[n - (i - k) - 1][k - 1] % mod;\n        &#125;\n        else &#123;\n            if (j &gt;= k)\n                f[i][j][p2] += f[i - k][j - k][p1] * C[n - (i - k) - 1][k - 1] % mod * fac[k - 1] % mod * inv2 % mod;\n            if (j &gt;= k - 1)\n                f[i][j][p2] += f[i - k][j - k + 1][p1] * C[n - (i - k) - 1][k - 1] % mod * fac[k] % mod * inv2 % mod;\n        &#125;\n        return;\n    &#125;;\n    for (int i = 1; i &lt;= n; ++i)\n        for (int j = 0; j &lt;= m; ++j) &#123;\n            for (int k = 1; k &lt;= i &amp;&amp; k &lt;= L; ++k)\n                if (k == L)\n                    work(i, j, k, 0, 1), work(i, j, k, 1, 1);\n                else\n                    work(i, j, k, 0, 0), work(i, j, k, 1, 1);\n            f[i][j][0] %= mod, f[i][j][1] %= mod;\n        &#125;\n    std::cout &lt;&lt; f[n][m][1] &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"c---局部极小值\">C - 局部极小值</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P3160\" class=\"uri\">https://www.luogu.com.cn/problem/P3160</a></p>\n<ul>\n<li><p>重要性质：一个合法棋盘，<code>X</code> 的数量不会超过八个，故一个想法是只考虑 <code>X</code> 填的数，进而想到容斥</p></li>\n<li><p>钦定至少有某些位置是 <code>X</code> 进行容斥，结合上面的性质发现空棋盘上的合法超集共 1000 多个，故可做，考虑单步钦定状态下的答案。</p>\n<p>令 <span class=\"math inline\">\\(f_{i,S}\\)</span> 表示填了 <span class=\"math inline\">\\(j\\)</span> 个数，目前 <code>X</code> 集合已经填完了 <span class=\"math inline\">\\(S\\)</span> 内元素的方案数。</p></li>\n</ul>\n<hr />\n<h2 id=\"a---数列\">A - 数列</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P7961\" class=\"uri\">https://www.luogu.com.cn/problem/P7961</a></p>\n<ul>\n<li><p>发现比较合理的 DP 方式是，令 <span class=\"math inline\">\\(f_{i,j,k,l}\\)</span> 表示当前正在 DP <span class=\"math inline\">\\(i\\)</span> 这个值，已经填了 <span class=\"math inline\">\\(j\\)</span> 个数，<span class=\"math inline\">\\(2^i\\)</span> 的个数，加上『进位』上来的，一共有 <span class=\"math inline\">\\(k\\)</span> 个，<span class=\"math inline\">\\(2^0\\sim 2^i\\)</span> 总共有 <span class=\"math inline\">\\(l\\)</span> 个 1 的答案。那么有：</p>\n<p><span class=\"math display\">\\[\nf_{i+1,j+c,\\left\\lfloor\\frac k2\\right\\rfloor+c,l+\\left(\\left\\lfloor\\frac k2\\right\\rfloor+c\\right)\\bmod 2}\\gets f_{i,j,k,l}\\times {v_{i + 1}}^c\\times (c!)^{-1}\n\\]</span></p>\n<p>其中 <span class=\"math inline\">\\((c!)^{-1}\\)</span> 为多重集排列。最后乘上 <span class=\"math inline\">\\(n!\\)</span> 即可。</p></li>\n<li><p>最后若 <span class=\"math inline\">\\(l+\\text{ctz}\\left(\\left\\lfloor\\frac k2\\right\\rfloor\\right)\\le K\\)</span> 即可统计 <span class=\"math inline\">\\(f_{m,n,k,l}\\)</span> 的贡献。</p></li>\n<li><p>注意到 <span class=\"math inline\">\\(k\\)</span> 维始终不超过 <span class=\"math inline\">\\(n\\)</span>，故复杂度 <span class=\"math inline\">\\(O(mn^3K)\\)</span>，非常可过。</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 998244353;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, m, s;\n    std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; s;\n    using arr = std::vector&lt;long long&gt;;\n    using brr = std::vector&lt;arr&gt;;\n    brr v(m + 1, arr(n + 1));\n    for (int i = 0; i &lt;= m; ++i) &#123;\n        v[i][0] = 1ll;\n        std::cin &gt;&gt; v[i][1];\n        for (int j = 2; j &lt;= n; ++j)\n            v[i][j] = v[i][j - 1] * v[i][1] % mod;\n    &#125;\n    arr inv(n + 1);\n    inv[0] = 1ll;\n    auto fac = 1ll;\n    auto qkp = [&amp;](long long x, int y) &#123;\n        auto res = 1ll;\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        (fac *= i) %= mod;\n        inv[i] = qkp(fac, mod - 2);\n    &#125;\n    using crr = std::vector&lt;brr&gt;;\n    std::vector&lt;crr&gt; f(m + 1, crr(n + 1, brr(n + 1, arr(s + 1))));\n    for (int i = 0; i &lt;= n; ++i)\n        f[0][i][i][i &amp; 1] = v[0][i] * inv[i] % mod;\n    for (int i = 0; i &lt; m; ++i)\n      for (int j = 0; j &lt;= n; ++j)\n        for (int k = 0; k &lt;= n; ++k)\n          for (int l = 0; l &lt;= s; ++l) &#123;\n            f[i][j][k][l] %= mod;\n            for (int c = 0; j + c &lt;= n &amp;&amp; k / 2 + c &lt;= n &amp;&amp; l + (k / 2 + c) % 2 &lt;= s; ++c)\n                f[i + 1][j + c][k / 2 + c][l + (k / 2 + c) % 2] += f[i][j][k][l] * v[i + 1][c] % mod * inv[c] % mod;\n          &#125;\n    auto res = 0ll;\n    for (int k = 0; k &lt;= n; ++k)\n        for (int l = 0; l &lt;= s; ++l)\n            if (l + __builtin_popcount(k / 2) &lt;= s)\n                res += f[m][n][k][l] % mod;\n    std::cout &lt;&lt; res % mod * fac % mod &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"b---vasya-and-array\">B - Vasya and Array</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/CF1093F\" class=\"uri\">https://www.luogu.com.cn/problem/CF1093F</a></p>\n<ul>\n<li><p>发现正着做避免不了记录相同段长度，所以考虑反过来容斥。</p>\n<p>会发现这是一个类似于<a href=\"/20230418/\">两双手</a>的容斥结构。<del>两双手还在输出</del></p></li>\n<li><p>令 <span class=\"math inline\">\\(f_{i,j}\\)</span> 表示前 <span class=\"math inline\">\\(i\\)</span> 个均合法，且第 <span class=\"math inline\">\\(i\\)</span> 个元素为 <span class=\"math inline\">\\(j\\)</span> 的方案数，考虑什么时候会出现『前 <span class=\"math inline\">\\(i-1\\)</span> 个元素合法，到了第 <span class=\"math inline\">\\(i\\)</span> 个非法』的情况</p>\n<p>发现即当前 <span class=\"math inline\">\\(i\\)</span> 前面有 <span class=\"math inline\">\\(len-1\\)</span> 个相同元素，且第 <span class=\"math inline\">\\(i\\)</span> 个成为第 <span class=\"math inline\">\\(len\\)</span> 个相同元素的情况。</p></li>\n<li><p>显然有转移：</p>\n<p><span class=\"math display\">\\[\nf_{i,j}\\gets \\left(\\sum_l f_{i-1,l}\\right)-\\left(\\sum_{l\\ne j} f_{i-len,l}\\right)\\times [a_{i-len+1\\cdots i} = j\\text{ is available}]\n\\]</span></p>\n<p>记录一下 <span class=\"math inline\">\\(s_i=\\sum\\limits_{j}f_{i,j}\\)</span> 的值即可做到 <span class=\"math inline\">\\(O(nk)\\)</span>。</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 998244353;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, k, L;\n    std::cin &gt;&gt; n &gt;&gt; k &gt;&gt; L;\n    std::vector&lt;int&gt; a(n + 1);\n    std::vector&lt;std::vector&lt;int&gt; &gt; cnt(n + 1, std::vector&lt;int&gt; (k + 1));\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; a[i];\n        for (int j = 1; j &lt;= k; ++j)\n            cnt[i][j] = cnt[i - 1][j] + (a[i] == j);\n        cnt[i][0] = cnt[i - 1][0] + (a[i] == -1);\n    &#125;\n    using arr = std::vector&lt;long long&gt;;\n    using brr = std::vector&lt;arr&gt;;\n    arr s(n + 1);\n    brr f(n + 1, arr(k + 1));\n    s[0] = 1ll;\n    for (int i = 1; i &lt;= n; ++i)\n        for (int j = 1; j &lt;= k; ++j)\n            if (a[i] == -1 || a[i] == j) &#123;\n                f[i][j] = s[i - 1];\n                if (i &gt;= L &amp;&amp; (cnt[i][j] - cnt[i - L][j]) + (cnt[i][0] - cnt[i - L][0]) == L) &#123;\n                    f[i][j] += mod - (s[i - L] - f[i - L][j]);\n                    if (s[i - L] &lt; f[i - L][j])\n                        f[i][j] -= mod;\n                    if (f[i][j] &gt;= mod)\n                        f[i][j] -= mod;\n                &#125;\n                s[i] += f[i][j];\n                if (s[i] &gt;= mod)\n                    s[i] -= mod;\n            &#125;\n    std::cout &lt;&lt; s[n] &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"c---road-of-the-king\">C - Road of the King</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/AT_codefestival_2016_final_f\" class=\"uri\">https://www.luogu.com.cn/problem/AT_codefestival_2016_final_f</a></p>\n<ul>\n<li><p>发现最后的图是强连通的，当且仅当<strong>所有点都能走到 1</strong>。</p>\n<p>最开始转化成『所有点都能通过操作序列走到 1』，错麻了 /qd</p></li>\n<li><p>令 <span class=\"math inline\">\\(f_{i,j,k}\\)</span> 表示前 <span class=\"math inline\">\\(i\\)</span> 步，已经使得 <span class=\"math inline\">\\(j\\)</span> 个点能走到 1，当前已经访问过了 <span class=\"math inline\">\\(k\\)</span> 个不能走到 <span class=\"math inline\">\\(1\\)</span> 的点。</p>\n<p>如果再次访问 <span class=\"math inline\">\\(j\\)</span> 个点中的其中一个，那么这 <span class=\"math inline\">\\(k\\)</span> 个点就能走到 1。转移是容易的。</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 1e9 + 7;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, m;\n    std::cin &gt;&gt; n &gt;&gt; m;\n    using arr = std::vector&lt;long long&gt;;\n    using brr = std::vector&lt;arr&gt;;\n    std::vector&lt;brr&gt; f(m + 1, brr(n + 1, arr(n + 1)));\n    f[0][1][0] = 1ll;\n    for (int i = 0; i &lt; m; ++i)\n        for (int j = 1; j &lt;= n; ++j) &#123;\n            for (int k = 0; k + j &lt;= n &amp;&amp; k + j &lt;= i + 1; ++k) &#123;\n                f[i][j][k] %= mod;\n                f[i + 1][j][k] += f[i][j][k] * k % mod;\n                f[i + 1][j + k][0] += f[i][j][k] * j % mod;\n                if (j + k != n)\n                    f[i + 1][j][k + 1] += f[i][j][k] * (n - j - k) % mod;\n            &#125;\n        &#125;\n    std::cout &lt;&lt; f[m][n][0] % mod &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"d---チーム分け\">D - チーム分け</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/AT_mujin_pc_2018_f\" class=\"uri\">https://www.luogu.com.cn/problem/AT_mujin_pc_2018_f</a></p>\n<ul>\n<li><p>很容易得到一个 <span class=\"math inline\">\\(O(n^3)\\)</span> 的做法：给 <span class=\"math inline\">\\(a\\)</span> 排序，从大到小选每个组的『限制者』。</p>\n<p><span class=\"math inline\">\\(f_{i,j}\\)</span> 表示选到 <span class=\"math inline\">\\(i\\)</span>，还剩 <span class=\"math inline\">\\(j\\)</span> 个 <span class=\"math inline\">\\(\\ge a_i\\)</span> 的人没有分组，则：</p>\n<p><span class=\"math display\">\\[\nf_{i-1,j+1-k}\\gets f_{i,j}\\quad(1\\le k\\le a_i)\\\\\nf_{i-1,j+1}\\gets f_{i,j}\n\\]</span></p></li>\n<li><p>后面这个优化还是很难想的…… 主要是要注意到，可以不必在某个 <span class=\"math inline\">\\(a_i\\)</span> 处钦定其为『限制者』；而是在某个 <span class=\"math inline\">\\(i\\)</span> 处，给『未分组』的人分大小为 <span class=\"math inline\">\\(i\\)</span> 的组，而不关心具体谁是限制者，甚至不关心限制者的 <span class=\"math inline\">\\(a\\)</span> 值。</p>\n<p>记 <span class=\"math inline\">\\(c_i\\)</span> 表示 <span class=\"math inline\">\\(i\\)</span> 处有几个 <span class=\"math inline\">\\(a\\)</span>，做多重集组合。仍然记录未分组人数 <span class=\"math inline\">\\(j\\)</span>，那么一个固定的 <span class=\"math inline\">\\(j\\)</span> 能贡献的大小为 <span class=\"math inline\">\\(i\\)</span> 的组满足调和级数，枚举组数 <span class=\"math inline\">\\(k\\)</span>，有：</p>\n<p><span class=\"math display\">\\[\nf_{i-1,j+c_i-k\\cdot i}\\gets f_{i+1,j}\\times \\binom{j+c_i}{i\\cdot k}\\times \\frac{(i\\cdot k)!}{(i!)^k\\times k!}\\quad\\left(k\\le \\frac{j+c_i}i\\right)\n\\]</span></p>\n<p><strong>一定要注意分母里的 <span class=\"math inline\">\\(k!\\)</span> 的含义（消序）！组是无序的。</strong></p></li>\n<li><p>复杂度 <span class=\"math inline\">\\(O(n^2\\log n)\\)</span>。</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 998244353;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;int&gt; c(n + 1);\n    for (int i = 1, x; i &lt;= n; ++i)\n        std::cin &gt;&gt; x, ++c[x];\n    using arr = std::vector&lt;long long&gt;;\n    using brr = std::vector&lt;arr&gt;;\n    brr C(n + 1, arr(n + 1));\n    C[0][0] = 1ll;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        C[i][0] = 1ll;\n        for (int j = 1; j &lt;= i; ++j)\n            C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % mod;\n    &#125;\n    arr fac(n + 1);\n    fac[0] = 1ll;\n    for (int i = 1; i &lt;= n; ++i)\n        fac[i] = fac[i - 1] * i % mod;\n    auto qkp = [&amp;](long long x, int y) &#123;\n        auto res = 1ll;\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    brr pw(n + 1, arr(n + 1));\n    for (int i = 0; i &lt;= n; ++i) &#123;\n        pw[i][0] = 1ll, pw[i][1] = qkp(fac[i], mod - 2);\n        for (int j = 2; j &lt;= n; ++j)\n            pw[i][j] = pw[i][j - 1] * pw[i][1] % mod;\n    &#125;\n    brr f(n + 2, arr(n + 1));\n    f[n + 1][0] = 1ll;\n    for (int i = n; i; --i)\n        for (int j = 0; j + c[i] &lt;= n; ++j)\n            for (int k = 0, l = (j + c[i]) / i; k &lt;= l; ++k)\n                (f[i][j + c[i] - k * i] += f[i + 1][j] * C[j + c[i]][i * k] % mod * fac[i * k] % mod * pw[i][k] % mod * pw[k][1] % mod) %= mod;\n    std::cout &lt;&lt; f[1][0] &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"e---random-isolation\">E - Random Isolation</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/AT_arc165_e\" class=\"uri\">https://www.luogu.com.cn/problem/AT_arc165_e</a></p>\n<ul>\n<li><p>发现期望可以拆贡献，每个局面下，每个大小 <span class=\"math inline\">\\(&gt;K\\)</span> 的连通块恰好贡献 1 次操作次数。</p>\n<p>这里提一下，一开始有这样的想法：每个存在 <span class=\"math inline\">\\(&gt;K\\)</span> 连通块的局面都可以操作 1 次，所以一个局面有 1 的贡献；这是否和上面得到的结论矛盾？</p>\n<p>答案是，统计局面的方案数权值和连通块的方案数权值是不一样的，但总和是一样的。且局面没什么好的统计方法，故统计连通块。</p></li>\n<li><p>令 <span class=\"math inline\">\\(f_{x,i,j}\\)</span> 表示 <span class=\"math inline\">\\(x\\)</span> 为根，子树内选了大小为 <span class=\"math inline\">\\(i\\)</span> 的连通块，一共需要删除 <span class=\"math inline\">\\(j\\)</span> 个点。那么相当于要求这 <span class=\"math inline\">\\(j\\)</span> 个点的删除时间早于 <span class=\"math inline\">\\(i\\)</span> 内所有点。树上背包统计方案数，每个点处计算权值与贡献即可。</p></li>\n<li><p>最后算权值的时候，把操作序列看成后几项无效的排列，那么要求这 <span class=\"math inline\">\\(j\\)</span> 个点的操作序列需要在所有 <span class=\"math inline\">\\(i\\)</span> 个点的前面</p>\n<p>可以猜到一个答案：<span class=\"math inline\">\\(\\dfrac {i!\\times j!}{(i+j)!}\\)</span>。</p>\n<p>但仔细想来并站不住脚：每个连通块的后几项在实际操作序列里是不存在的，整个操作序列的长短甚至都是未知的，好像没什么道理。</p>\n<p>问了一圈没人说出来个靠谱的证明。算了。</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 998244353;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, k;\n    std::cin &gt;&gt; n &gt;&gt; k;\n    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);\n    for (int i = 1, x, y; i &lt; n; ++i) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y;\n        g[x].push_back(y), g[y].push_back(x);\n    &#125;\n    using arr = std::vector&lt;long long&gt;;\n    using brr = std::vector&lt;arr&gt;;\n    brr C(n + 1, arr(n + 1));\n    for (int i = 0; i &lt;= n; ++i) &#123;\n        C[i][0] = 1ll;\n        for (int j = 1; j &lt;= i; ++j)\n            C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % mod;\n    &#125;\n    auto qkp = [&amp;](long long x, int y) &#123;\n        auto res = 1ll;\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    arr fac(n + 1), inv(n + 1);\n    fac[0] = inv[0] = 1ll;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        fac[i] = fac[i - 1] * i % mod;\n        inv[i] = qkp(fac[i], mod - 2);\n    &#125;\n    std::vector&lt;int&gt; siz(n + 1);\n    brr h(n + 1, arr(n + 1));\n    std::vector&lt;brr&gt; f(n + 1, brr(n + 1, arr(n + 1)));\n    auto res = 0ll;\n    std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int fa) &#123;\n        f[x][1][(int)g[x].size()] = 1ll;\n        siz[x] = 1;\n        for (auto i : g[x])\n            if (i != fa) &#123;\n                DFS(i, x);\n                h = f[x];\n                for (int j = siz[x]; j; --j)\n                  for (int a = 0; a &lt; n; ++a)\n                    if (f[x][j][a + 1])\n                      for (int k = siz[i]; ~k; --k)\n                        for (int b = 0; a + b &lt; n; ++b)\n                          f[x][j + k][a + b] += h[j][a + 1] * f[i][k][b + 1] % mod;\n                siz[x] += siz[i];\n            &#125;\n        for (int i = 1; i &lt;= siz[x]; ++i)\n            for (int j = 0; j &lt;= n; ++j)\n                f[x][i][j] %= mod;\n        for (int i = k + 1; i &lt;= siz[x]; ++i)\n            for (int j = 0; i + j &lt;= n; ++j)\n                res += f[x][i][j] * fac[i] % mod * fac[j] % mod * inv[i + j] % mod;\n        res %= mod;\n        return;\n    &#125;;\n    DFS(1, -1);\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"a---染色问题\">A - 染色问题</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P6076\" class=\"uri\">https://www.luogu.com.cn/problem/P6076</a></p>\n<ul>\n<li><p>题述转化成：恰好 <span class=\"math inline\">\\(n\\)</span> 行，恰好 <span class=\"math inline\">\\(m\\)</span> 列，恰好 <span class=\"math inline\">\\(c\\)</span> 种颜色即可容斥</p></li>\n<li><p>将无色视为一个不参与容斥的颜色，容易写出答案式：</p>\n<p><span class=\"math display\">\\[\n\\sum_{i=0}^{n}\\sum_{j=0}^{m}\\sum_{k=0}^{c} (-1)^{i+j+k}\\times \\binom ni\\times \\binom mj\\times \\binom ck\\times (c-k+1)^{(n-i)(m-j)}\n\\]</span></p></li>\n<li><p>预处理幂次即可。复杂度 <span class=\"math inline\">\\(O(nmc)\\)</span>。</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 1e9 + 7;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, m, c;\n    std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; c;\n    std::vector&lt;long long&gt; fac(n * m + 1), inv(n * m + 1);\n    fac[0] = inv[0] = 1ll;\n    for (int i = 1; i &lt;= n * m; ++i)\n        fac[i] = fac[i - 1] * i % mod;\n    auto qkp = [&amp;](long long x, int y) &#123;\n        auto res = 1ll;\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    inv[n * m] = qkp(fac[n * m], mod - 2);\n    for (int i = n * m - 1; i; --i)\n        inv[i] = inv[i + 1] * (i + 1) % mod;\n    auto C = [&amp;](int n, int m) &#123;\n        if (n &lt; m || m &lt; 0)\n            return 0ll;\n        return fac[n] * inv[m] % mod * inv[n - m] % mod;\n    &#125;;\n    std::vector&lt;std::vector&lt;long long&gt; &gt; pw(c + 2, std::vector&lt;long long&gt; (n * m + 1));\n    for (int i = 1; i &lt;= c + 1; ++i) &#123;\n        pw[i][0] = 1ll;\n        for (int j = 1; j &lt;= n * m; ++j)\n            pw[i][j] = pw[i][j - 1] * i % mod;\n    &#125;\n    auto res = 0ll;\n    for (int i = 0; i &lt;= n; ++i)\n        for (int j = 0; j &lt;= m; ++j)\n            for (int k = 0; k &lt;= c; ++k) &#123;\n                int op = ((i + j + k) &amp; 1) ? mod - 1 : 1;\n                res += op * C(n, i) % mod * C(m, j) % mod * C(c, k) % mod * pw[c - k + 1][(n - i) * (m - j)] % mod;\n            &#125;\n    std::cout &lt;&lt; res % mod &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"b---painting-the-wall\">B - Painting The Wall</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/CF398B\" class=\"uri\">https://www.luogu.com.cn/problem/CF398B</a></p>\n<ul>\n<li><p>观察到初始被标记的行列之间等价，相似地，初始未被标记的行列之间等价。故可以粗暴地塞到状态里。</p></li>\n<li><p>参照 <a href=\"/20240111/\">Game with Probability Problem</a> 中解决自转移的思路，考虑解方程。</p>\n<p>设 <span class=\"math inline\">\\(f_{i,j}\\)</span> 表示剩余 <span class=\"math inline\">\\(i\\)</span> 行 <span class=\"math inline\">\\(j\\)</span> 列时的期望操作数，列出 DP 式：</p>\n<p><span class=\"math display\">\\[\nf_{i,j}\n\\]</span></p></li>\n</ul>\n",
            "tags": [
                "计数",
                "容斥",
                "二项式反演"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20250820/",
            "url": "https://xsc062.netlify.app/20250820/",
            "title": "杂题选谈",
            "date_published": "2025-08-20T12:26:44.000Z",
            "content_html": "<p>困难</p>\n<span id=\"more\"></span>\n<hr />\n<h3 id=\"b.-beauty拆贡献\">B. beauty（拆贡献）</h3>\n<p><a href=\"https://www.becoder.com.cn/contest/6513/problem/2\" class=\"uri\">https://www.becoder.com.cn/contest/6513/problem/2</a></p>\n<blockquote>\n<p>给定 <span class=\"math inline\">\\(n,V\\)</span>，求出对于所有长度为 <span class=\"math inline\">\\(n\\)</span>，值域为 <span class=\"math inline\">\\([1,V]\\)</span> 的序列 <span class=\"math inline\">\\(a_{1\\sim n}\\)</span>，<span class=\"math inline\">\\(\\sum_{i=1}^n |a_i-a_{n-i+1}|\\)</span> 的和。</p>\n<p><span class=\"math inline\">\\(n,V\\le 5000\\)</span>。</p>\n</blockquote>\n<ul>\n<li>容易想到算贡献，会有一个 <span class=\"math inline\">\\(O(n^2V)\\)</span> 的做法。但是想 <span class=\"math inline\">\\(O(nV)\\)</span> 做是很抽象的，和 <span class=\"math inline\">\\(O(n^2V)\\)</span> 的思路已经很不一样了</li>\n<li>经典 trick，<span class=\"math inline\">\\(a_{i+n/2}-a_i=\\sum\\limits_{x=0}^{+\\infty} [a_i\\le x&lt;a_{i+n/2}]\\)</span> 拆贡献 。故要算 <span class=\"math inline\">\\(a_{i}-a_{i+n/2}\\)</span>，只需要对于每个 <span class=\"math inline\">\\(x\\in[a_i,a_{i+n/2})\\)</span> 计算贡献。</li>\n<li>枚举 <span class=\"math inline\">\\(x\\in [1,V)\\)</span>，再枚举最大的 <span class=\"math inline\">\\(t\\)</span>，满足 <span class=\"math inline\">\\(a_t\\ge x\\)</span>。那么有 <span class=\"math inline\">\\(t\\)</span> 个 <span class=\"math inline\">\\(a_i\\le x\\)</span>，同时有 <span class=\"math inline\">\\(n-t\\)</span> 个 <span class=\"math inline\">\\(a_i&gt;x\\)</span>；满足 <span class=\"math inline\">\\(i\\le n/2\\)</span> 的 <span class=\"math inline\">\\(a_{i},a_{i+n/2}\\)</span> 对数应该是 <span class=\"math inline\">\\(\\min(t,n-t)\\)</span>。故对于一个确定的序列，<span class=\"math inline\">\\(x\\)</span> 共有 <span class=\"math inline\">\\(\\min(t,n-t)\\)</span> 的贡献。</li>\n<li>考虑计数满足 <span class=\"math inline\">\\(a_t\\le x\\)</span> 的 <span class=\"math inline\">\\(a\\)</span>，这要求第 <span class=\"math inline\">\\(t\\)</span> 大的数 <span class=\"math inline\">\\(\\le x\\)</span> 而第 <span class=\"math inline\">\\(t+1\\)</span> 大的数 <span class=\"math inline\">\\(&gt;x\\)</span>，也即在 <span class=\"math inline\">\\([1,x]\\)</span> 里找 <span class=\"math inline\">\\(t\\)</span> 个数再在 <span class=\"math inline\">\\((x,V]\\)</span> 里找 <span class=\"math inline\">\\(n-t\\)</span> 个数，注意还要再乘上这两种数拼起来的方案数。</li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 998244353;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n    std::freopen(&quot;beauty.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;beauty.out&quot;, &quot;w&quot;, stdout);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int T;\n    std::vector&lt;long long&gt; fac(5001), inv(5001);\n    std::vector&lt;std::vector&lt;long long&gt; &gt; pw(5001, std::vector&lt;long long&gt; (5001));\n    fac[0] = inv[0] = 1ll;\n    for (int i = 1; i &lt;= 5000; ++i) &#123;\n        fac[i] = fac[i - 1] * i % mod;\n        pw[i][0] = 1ll;\n        for (int j = 1; j &lt;= 5000; ++j)\n            pw[i][j] = pw[i][j - 1] * i % mod;\n    &#125;\n    auto qkp = [](long long x, int y) &#123;\n        auto res(1ll);\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    inv[5000] = qkp(fac[5000], mod - 2);\n    for (int i = 4999; i; --i)\n        inv[i] = inv[i + 1] * (i + 1) % mod;\n    auto C = [&amp;](int n, int m) &#123;\n        return fac[n] * inv[m] % mod * inv[n - m] % mod;\n    &#125;;\n    for (std::cin &gt;&gt; T; T--; ) &#123;\n        int n, V;\n        std::cin &gt;&gt; n &gt;&gt; V;\n        auto res(0ll);\n        for (int x = 1; x &lt; V; ++x)\n            for (int t = 1; t &lt; n; ++t) &#123;\n                int k = std::min(t, n - t);\n                (res += k * pw[x][t] % mod * pw[V - x][n - t] % mod * C(n, t) % mod) %= mod;\n            &#125;\n        std::cout &lt;&lt; res * 2 % mod &lt;&lt; &#39;\\n&#39;;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"c.-drink-bar容斥-偏序\">C. Drink Bar（容斥 + 偏序）</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/AT_snuke21_j\" class=\"uri\">https://www.luogu.com.cn/problem/AT_snuke21_j</a></p>\n<ul>\n<li>三个属性都是排列，可以推理出只要两个三元组中，作出贡献的元素不完全相同，两个三元组就不同。讨论作出贡献的元素数量。</li>\n<li>只有一个元素作出贡献，答案为 <span class=\"math inline\">\\(n\\)</span>。</li>\n<li>有两个元素作出贡献，任选的话答案为 <span class=\"math inline\">\\(C_n^2\\)</span>，要减去一个元素严格优于另一个元素的情况，三维偏序即可。</li>\n<li><p>有三个元素作出贡献，是个有点复杂的容斥，不妨设三元组为 <span class=\"math inline\">\\((i,j,k)\\)</span>，其中贡献次数最多的为 <span class=\"math inline\">\\(i\\)</span></p>\n<ol type=\"1\">\n<li><span class=\"math inline\">\\(i\\)</span> 贡献了 <span class=\"math inline\">\\(\\ge 1\\)</span> 次，方案数为 <span class=\"math inline\">\\(C_n^3\\)</span></li>\n<li><span class=\"math inline\">\\(i\\)</span> 贡献了 <span class=\"math inline\">\\(\\ge 2\\)</span> 次，枚举作出两次贡献的属性，以 <span class=\"math inline\">\\(a,b\\)</span> 为例，那么有 <span class=\"math inline\">\\(a_j,a_k&lt;a_i\\)</span>，以及 <span class=\"math inline\">\\(b_j,b_k&lt;b_i\\)</span>，二维偏序即可</li>\n<li><span class=\"math inline\">\\(i\\)</span> 贡献了 <span class=\"math inline\">\\(\\ge 3\\)</span> 次，依然是三维偏序，可以用『两个元素做出贡献』中 cdq 得到的值算出答案。记得乘 2，因为被多减了 2 次。</li>\n</ol></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    struct node &#123; int a, b, c, res; &#125;;\n    std::vector&lt;node&gt; a(n + 1);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; a[i].a &gt;&gt; a[i].b &gt;&gt; a[i].c;\n        a[i].res = 0;\n    &#125;\n    long long res = n;\n    res += (long long)n * (n - 1) / 2;\n    std::vector&lt;int&gt; bit(n + 1);\n    auto lowbit = [](int x) &#123;\n        return x &amp; -x;\n    &#125;;\n    auto add = [&amp;](int x, int v) &#123;\n        for (; x &lt;= n; x += lowbit(x))\n            bit[x] += v;\n        return;\n    &#125;;\n    auto ask = [&amp;](int x) &#123;\n        int res = 0;\n        for (; x; x -= lowbit(x))\n            res += bit[x];\n        return res;\n    &#125;;\n    std::function&lt;void(int, int)&gt; calc = [&amp;](int l, int r) &#123;\n        if (l == r)\n            return;\n        int mid = (l + r) &gt;&gt; 1;\n        calc(l, mid), calc(mid + 1, r);\n        int j = l;\n        for (int i = mid + 1; i &lt;= r; ++i) &#123;\n            for (; j &lt;= mid &amp;&amp; a[j].b &lt; a[i].b; ++j)\n                add(a[j].c, 1);\n            a[i].res += ask(a[i].c);\n        &#125;\n        for (int i = l; i &lt; j; ++i)\n            add(a[i].c, -1);\n        std::inplace_merge(a.begin() + l, a.begin() + mid + 1, a.begin() + r + 1, [&amp;](node x, node y) &#123; return x.b &lt; y.b; &#125;);\n        return;\n    &#125;;\n    std::sort(a.begin() + 1, a.end(), [&amp;](node x, node y) &#123; return x.a &lt; y.a; &#125;);\n    calc(1, n);\n    for (int i = 1; i &lt;= n; ++i)\n        res -= a[i].res;\n    res += (long long)n * (n - 1) * (n - 2) / 6;\n    for (int k = 0; k &lt; 3; ++k) &#123;\n        std::sort(a.begin() + 1, a.end(), [&amp;](node x, node y) &#123; return x.a &lt; y.a; &#125;);\n        std::fill(bit.begin() + 1, bit.end(), 0);\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            int t = ask(a[i].b);\n            res -= (long long)t * (t - 1) / 2;\n            add(a[i].b, 1);\n            std::tie(a[i].a, a[i].b, a[i].c) = std::make_tuple(a[i].b, a[i].c, a[i].a);\n        &#125;\n    &#125;\n    for (int i = 1; i &lt;= n; ++i)\n        res += (long long)a[i].res * (a[i].res - 1);\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"c.-星白-by-ttpandas笛卡尔树-dsu-on-tree\">C. 星白 by TTpandaS（笛卡尔树 + dsu on tree）</h3>\n<p><a href=\"/20250819/#星白-by-ttpandas笛卡尔树-dsu-on-tree\">link</a></p>\n<hr />\n<h3 id=\"c.-isn\">C. isn</h3>\n<p><a href=\"https://hydro.ac/p/bzoj-P4361\" class=\"uri\">https://hydro.ac/p/bzoj-P4361</a></p>\n<ul>\n<li><p>最后一个删去的一定是连接 <code>&gt;</code> 的数，可以 DP 还剩一个数没删时可能的序列。</p>\n令 <span class=\"math inline\">\\(f_{i,j,0/1}\\)</span> 表示最后一个元素为 <span class=\"math inline\">\\(i\\)</span>，序列长为 <span class=\"math inline\">\\(j\\)</span>，最后一个被删去的数（未）被确定的方案数。<strong>注意确定最后一个被删去的数要在转移过程中进行，而不是作为一个 DP 节点</strong>，很容易发现后者是错的。</li>\n<li><p>优化的思路就不一样了。因为要乘上 <span class=\"math inline\">\\((n-j)!\\)</span>，所以 <span class=\"math inline\">\\(j\\)</span> 的这一维是省不掉的</p>\n考虑不管最后一个被删掉的数，直接令 <span class=\"math inline\">\\(f_{i,j}\\)</span> 表示最后一个元素为 <span class=\"math inline\">\\(i\\)</span>，序列长为 <span class=\"math inline\">\\(j\\)</span> 的方案数。有 <span class=\"math inline\">\\(f_{i,j}=\\sum\\limits_{a_k\\le a_i}f_{k,j - 1}\\)</span>，可以 DS 优化。但这样会产生不合法的情况。</li>\n<li><p>考察什么样的序列合法，发现<strong>删去的最后一个数一定是非法的，也就是包含之的序列都是非法的；反之易得被合法序列包含的序列都非法</strong></p>\n<p>明白了这一点过后就会知道长度为 <span class=\"math inline\">\\(j\\)</span> 的合法序列系数都为 <span class=\"math inline\">\\((n-j)!\\)</span></p>\n<p>故容斥，令 <span class=\"math inline\">\\(g_i\\)</span> 表示序列长为 <span class=\"math inline\">\\(i\\)</span> 的方案数，<span class=\"math inline\">\\(h_i\\)</span> 表示序列长为 <span class=\"math inline\">\\(i\\)</span> 的合法方案数。从异或角度考虑，易得 <span class=\"math inline\">\\(h_i=g_i-\\sum\\limits_{j=i+1}h_j\\times (j-i)!\\times C_j^i\\)</span>。</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 1e9 + 7;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n    std::freopen(&quot;isn.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;isn.out&quot;, &quot;w&quot;, stdout);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;int&gt; a(n + 1), l(1);\n    std::vector&lt;long long&gt; fac(n + 1), inv(n + 1);\n    fac[0] = inv[0] = 1ll;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; a[i], l.push_back(a[i]);\n        fac[i] = fac[i - 1] * i % mod;\n    &#125;\n    auto qkp = [](long long x, int y) &#123;\n        auto res(1ll);\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    inv[n] = qkp(fac[n], mod - 2);\n    for (int i = n - 1; i; --i)\n        inv[i] = inv[i + 1] * (i + 1) % mod;\n    auto C = [&amp;](int n, int m) &#123;\n        return fac[n] * inv[m] % mod * inv[n - m] % mod;\n    &#125;;\n    std::sort(l.begin(), l.end());\n    l.erase(std::unique(l.begin(), l.end()), l.end());\n    for (int i = 0; i &lt;= n; ++i)\n        a[i] = std::lower_bound(l.begin(), l.end(), a[i]) - l.begin() + 1;\n    int m = (int)l.size();\n    std::vector&lt;std::vector&lt;long long&gt; &gt; bit(n + 1, std::vector&lt;long long&gt; (m + 1));\n    auto lowbit = [](int x) &#123;\n        return x &amp; -x;\n    &#125;;\n    auto add = [&amp;](int id, int x, long long v) &#123;\n        for (; x &lt;= m; x += lowbit(x))\n            (bit[id][x] += v) %= mod;\n        return;\n    &#125;;\n    auto ask = [&amp;](int id, int x) &#123;\n        auto res(0ll);\n        for (; x; x -= lowbit(x))\n            (res += bit[id][x]) %= mod;\n        return res;\n    &#125;;\n    std::vector&lt;long long&gt; g(n + 1), h(n + 1);\n    std::vector&lt;std::vector&lt;long long&gt; &gt; f(n + 1, std::vector&lt;long long&gt; (n + 1));\n    add(0, a[0], 1ll), f[0][0] = 1ll;\n    for (int i = 1; i &lt;= n; ++i)\n        for (int j = n; j; --j) &#123;\n            f[i][j] = ask(j - 1, a[i]);\n            add(j, a[i], f[i][j]);\n            (g[j] += f[i][j] * fac[n - j]) %= mod;\n        &#125;\n    auto res(0ll);\n    for (int i = n; i; --i) &#123;\n        h[i] = g[i];\n        for (int j = i + 1; j &lt;= n; ++j)\n            (h[i] += mod - h[j] * fac[j - i] % mod * C(j, i) % mod) %= mod;\n        (res += h[i]) %= mod;\n    &#125;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"d.-thepowers\">D. ThePowers</h3>\n<p>TopCoder - 12185，原题交不了故不放链接了</p>\n<p><a href=\"https://www.becoder.com.cn/contest/6522/problem/4\" class=\"uri\">https://www.becoder.com.cn/contest/6522/problem/4</a></p>\n<blockquote>\n<p>给定 <span class=\"math inline\">\\(A,B\\)</span>，对于所有 <span class=\"math inline\">\\(X\\le A,Y\\le B\\)</span>，求 <span class=\"math inline\">\\(X^Y\\)</span> 的可能取值数量。<span class=\"math inline\">\\(A,B\\le10^9\\)</span>。</p>\n</blockquote>\n<ul>\n<li>考虑什么时候算重。发现当且仅当 <span class=\"math inline\">\\(x^a=y^b\\)</span>，此时记 <span class=\"math inline\">\\(a&#39;=a\\div\\gcd(a,b),b&#39;=b\\div \\gcd(a,b)\\)</span>，那么 <span class=\"math inline\">\\(t=\\sqrt[a&#39;]x=\\sqrt[b&#39;]y\\)</span> 为整（写成质因数乘积是易证的），则 <span class=\"math inline\">\\(x=t^b,y=t^a\\)</span>，是同一个数的不同次幂</li>\n<li><p>故把 <span class=\"math inline\">\\(A\\)</span> 内所有数分组，记 <span class=\"math inline\">\\(S_x\\)</span> 表示所有 <span class=\"math inline\">\\(x\\)</span> 的次幂，其中 <span class=\"math inline\">\\(x\\)</span> 不是其他数的次幂</p>\n发现一个对于 <span class=\"math inline\">\\(&gt;\\sqrt A\\)</span> 的数 <span class=\"math inline\">\\(y\\)</span>，只有可能属于 <span class=\"math inline\">\\(S_y\\)</span>，或一个 <span class=\"math inline\">\\(x\\le \\sqrt A\\)</span> 的 <span class=\"math inline\">\\(S_x\\)</span>。每组最多有 <span class=\"math inline\">\\(30\\)</span> 个，故扫一遍 <span class=\"math inline\">\\(\\le\\sqrt A\\)</span> 的数即可完成分组。</li>\n<li><p>这样就只用考虑同组内的计数。即对于 <span class=\"math inline\">\\(x\\)</span> 和 <span class=\"math inline\">\\(p\\le |S_x|,y\\le B\\)</span>，<span class=\"math inline\">\\(x^{py}\\)</span> 有多少种取值，也即 <span class=\"math inline\">\\(py\\)</span> 有多少种取值</p>\n发现因为值域是连续的，对于一个 <span class=\"math inline\">\\(p\\)</span>，只要 <span class=\"math inline\">\\(pB\\)</span> 范围内某个数是 <span class=\"math inline\">\\(p\\)</span> 的倍数就可以取到，枚举 <span class=\"math inline\">\\([(p-1)B+1,pB]\\)</span>，对于每个 <span class=\"math inline\">\\(p\\)</span> 容斥，就需要计算 <span class=\"math inline\">\\(p\\sim |S_x|\\)</span> 的每个子集，复杂度会爆炸。</li>\n<li><p>对于 <span class=\"math inline\">\\(x,y\\in[p,|S_x|]\\)</span>，如果 <span class=\"math inline\">\\(y\\)</span> 是 <span class=\"math inline\">\\(x\\)</span> 的倍数，就可以 skip，只在剩下的元素里枚举子集，可以代码验证一下 <span class=\"math inline\">\\(30\\)</span> 以内最多剩下 <span class=\"math inline\">\\(15\\)</span> 个数，可以接受，注意子集信息类似高维前缀和地 <span class=\"math inline\">\\(O(1)\\)</span> 求就行了</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n    std::freopen(&quot;power.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;power.out&quot;, &quot;w&quot;, stdout);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    long long A, B, mx = 1ll;\n    std::cin &gt;&gt; A &gt;&gt; B;\n    if (A == 1) &#123;\n        std::cout &lt;&lt; 1 &lt;&lt; &#39;\\n&#39;;\n        return 0;\n    &#125;\n    int cnt = 1;\n    long long res = 1ll;\n    for (; (mx + 1) * (mx + 1) &lt;= A; ++mx);\n    std::vector&lt;int&gt; tag(mx + 1);\n    for (int i = 2; i &lt;= mx; ++i)\n        if (!tag[i]) &#123;\n            int siz = 1;\n            for (long long j = i; j &lt;= A; j *= i, ++siz)\n                if (j &lt;= mx)\n                    tag[j] = 1;\n            cnt += --siz;\n            for (int j = 1; j &lt;= siz; ++j) &#123;\n                std::vector&lt;int&gt; p(&#123; j &#125;);\n                for (int k = j + 1; k &lt;= siz; ++k) &#123;\n                    bool flag = 1;\n                    for (auto l : p)\n                        if (k % l == 0) &#123;\n                            flag = 0;\n                            break;\n                        &#125;\n                    if (flag)\n                        p.push_back(k);\n                &#125;\n                int m = (int)p.size(), s = 1 &lt;&lt; m;\n                std::vector&lt;long long&gt; mul(s);\n                mul[0] = 1ll;\n                auto lcm = [&amp;](long long x, long long y) &#123;\n                    return x / std::__gcd(x, y) * y;\n                &#125;;\n                for (int k = 1; k &lt; s; ++k) &#123;\n                    mul[k] = lcm(p[std::__lg(k ^ ((k - 1) &amp; k))], mul[(k - 1) &amp; k]);\n                    if (__builtin_popcount(k) &amp; 1)\n                        res += j * B / mul[k] - (j - 1) * B / mul[k];\n                    else\n                        res -= j * B / mul[k] - (j - 1) * B / mul[k];\n                &#125;\n            &#125;\n        &#125;\n    res += (A - cnt) * B;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<p>搜索做法本质上是一样的，就不赘述了</p>\n",
            "tags": [
                "DP",
                "计数",
                "CDQ 分治"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20250809/",
            "url": "https://xsc062.netlify.app/20250809/",
            "title": "杂题选谈",
            "date_published": "2025-08-09T04:33:17.000Z",
            "content_html": "<p>这段时间比赛的一些题 和 nKessi、duanyu 讲的题目。太偏计数、数学的基本上没办法做了。</p>\n<span id=\"more\"></span>\n<hr />\n<h2 id=\"a.-出关\">A. 出关</h2>\n<p><a href=\"https://www.becoder.com.cn/contest/6462/problem/1\" class=\"uri\">https://www.becoder.com.cn/contest/6462/problem/1</a></p>\n<blockquote>\n<p>给定 <span class=\"math inline\">\\(s\\)</span>，对于一个空串，任意利用下列三种操作，使其变为 <span class=\"math inline\">\\(s\\)</span>，求最小代价：</p>\n<ol type=\"1\">\n<li>在末尾添加字符 <span class=\"math inline\">\\(c\\)</span>，代价为 <span class=\"math inline\">\\(t_{0,c}\\)</span>；</li>\n<li>复制整个字符串并粘贴在末尾，代价为 <span class=\"math inline\">\\(t_1\\)</span>；</li>\n<li>删除末尾字符，代价为 <span class=\"math inline\">\\(t_2\\)</span>。</li>\n</ol>\n<p><span class=\"math inline\">\\(|s|\\le 10^6\\)</span>。</p>\n</blockquote>\n<p>可以预处理出对于每个 <span class=\"math inline\">\\(i\\)</span> 结尾，最多可以复制到哪个地方，发现要求 <span class=\"math inline\">\\(z_i=lcp(s_{1\\dots n},s_{i+1\\dots n})\\)</span>。那么一个 <span class=\"math inline\">\\(i\\)</span> 的最远转移点 <span class=\"math inline\">\\(r_i=i+z_{i+1}\\)</span>，用单调队列就能维护，会 exkmp 就能线性；</p>\n<p>否则可以二分 + 哈希多个 log，后面也有理由偷懒用优先队列了。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int p = 31;\nconst int mod = 998244353;\nint main() &#123;\n    std::freopen(&quot;laozi.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;laozi.out&quot;, &quot;w&quot;, stdout);\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n    std::string s;\n    std::cin &gt;&gt; s;\n    int n = (int)s.length(), t1, t2;\n    std::vector&lt;long long&gt; h(n + 1), base(n + 1);\n    std::vector&lt;int&gt; a(n + 1), t0(27), z(n + 1), r(n + 1);\n    base[0] = 1ll;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        a[i] = s[i - 1] - &#39;a&#39; + 1;\n        h[i] = (h[i - 1] * p + a[i]) % mod;\n        base[i] = base[i - 1] * p % mod;\n    &#125;\n    auto gethash = [&amp;](int l, int r) &#123;\n        return (h[r] - h[l - 1] * base[r - l + 1] % mod + mod) % mod;\n    &#125;;\n    for (int i = 1; i &lt;= n; ++i)\n        for (int l = 1, r = std::min(i - 1, n - i + 1), mid; l &lt;= r; ) &#123;\n            mid = (l + r) &gt;&gt; 1;\n            if (gethash(1, mid) == gethash(i, i + mid - 1))\n                z[i] = mid, l = mid + 1;\n            else\n                r = mid - 1;\n        &#125;\n    for (int i = 1; i &lt; n; ++i)\n        r[i] = i + std::min(i, z[i + 1]);\n    for (int i = 1; i &lt;= 26; ++i)\n        std::cin &gt;&gt; t0[i];\n    std::cin &gt;&gt; t1 &gt;&gt; t2;\n    std::vector&lt;long long&gt; f(n + 1);\n    std::priority_queue&lt;std::pair&lt;long long, int&gt; &gt; q;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        f[i] = f[i - 1] + t0[a[i]];\n        for (; !q.empty() &amp;&amp; r[q.top().second] &lt; i; q.pop());\n        if (!q.empty())\n            f[i] = std::min(f[i], t1 - q.top().first - (long long)t2 * i);\n        if (i != n)\n            q.emplace(-(f[i] + 2ll * t2 * i), i);\n    &#125;\n    std::cout &lt;&lt; f[n] &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"d.-非攻\">D. 非攻</h2>\n<p><a href=\"https://www.becoder.com.cn/contest/6462/problem/4\" class=\"uri\">https://www.becoder.com.cn/contest/6462/problem/4</a></p>\n<blockquote>\n<p>给定 <span class=\"math inline\">\\(n\\)</span>，对于一个 <span class=\"math inline\">\\(1\\sim n\\)</span> 的排列，使用最小的交换次数使得其单增。在该前提下，定义代价为每次交换的两个数之积。对于所有 <span class=\"math inline\">\\(n!\\)</span> 个排列，计算最小代价之和。</p>\n<p><span class=\"math inline\">\\(n\\le 10^7\\)</span>。</p>\n</blockquote>\n<p>转化成，把 <span class=\"math inline\">\\(1\\sim n\\)</span> 分成无标号的若干组，每组的代价是 最小值 <span class=\"math inline\">\\(\\times\\)</span> 其他元素的和，还有一个项链问题的系数，发现组间的符号是求和，考虑计算贡献。</p>\n<p>枚举 <span class=\"math inline\">\\(i,j\\)</span> 并钦定两个同属一个环，且 <span class=\"math inline\">\\(i\\)</span> 为最小值，枚举环大小 <span class=\"math inline\">\\(s+2\\)</span>，那么有：</p>\n<p><span class=\"math display\">\\[\n\\begin{aligned}\nres&amp;=\\sum_{i=1}^{n-1}\\sum_{j=i+1}^n i\\cdot j \\cdot \\sum_{s=0}^{n-i-1}\\binom{n-i-1}s \\cdot (s+1)!\\cdot (n-s-2)!\\\\\n&amp;=\\sum_{i=1}^{n-1}i\\cdot \\dfrac {(i+n+1)(n-i)}2 \\cdot \\sum_{s=0}^{n-i-1}\\binom{n-i-1}s\\cdot (s+1)!\\cdot (n-s-2)!\\\\\n&amp;=\\frac 12\\times\\sum_{i=1}^{n-1}i\\cdot (i+n+1)\\cdot (n-i)!\\cdot\\sum_{s=0}^{n-i-1}\\dfrac {(s + 1)\\cdot (n-s-2)!}{(n-i-1-s)!}\\\\\n\\end{aligned}\n\\]</span></p>\n<p>令 <span class=\"math inline\">\\(T=n-i-1\\)</span>，发现我们需要快速计算 <span class=\"math inline\">\\(f_T=\\sum\\limits_{i=0}^T \\dfrac{(i+1)\\cdot (n-i-2)!}{(T-i)!}\\)</span>。记 <span class=\"math inline\">\\(m=n-2\\)</span>，变形得 <span class=\"math inline\">\\(f_T=(m-T)!\\cdot \\sum\\limits_{i=0}^{T} (i+1) \\binom{m-i}{m-T}\\)</span>，发现似乎可以简化，令 <span class=\"math inline\">\\(k=m-T,t=T+1\\)</span>，则 <span class=\"math inline\">\\(f_T=\\sum\\limits_{i=1}^T i\\cdot \\binom {k+t-i}k\\)</span>。</p>\n<p>然后是经典的组合意义保平安环节，即从 <span class=\"math inline\">\\(k+t\\)</span> 个有标号小球中选择一条分界线，分界线左边选一个球、右边选 <span class=\"math inline\">\\(k\\)</span> 个球的方案数。发现分界线的存在很诡异，故用分界线后方的第一个球代替，在 <span class=\"math inline\">\\(t+1\\)</span> 处新建一个虚球，规定在前 <span class=\"math inline\">\\(t+1\\)</span> 个球中选两个球，并令后一个为分界线，且令前 <span class=\"math inline\">\\(t+1\\)</span> 个中的其他球为实球，就能建立双射。在分界线后再选 <span class=\"math inline\">\\(k\\)</span> 个球，容易发现直接在范围内选 <span class=\"math inline\">\\(k+2\\)</span> 个球就能满足条件，故 <span class=\"math inline\">\\(f_T=(n-T-2)!\\cdot \\binom{t+k+1}{k+2}\\)</span>。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 1e9 + 7;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n    std::freopen(&quot;mozi.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;mozi.out&quot;, &quot;w&quot;, stdout);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;long long&gt; fac(n + 1), inv(n + 1), f(n + 1);\n    fac[0] = inv[0] = 1ll;\n    for (int i = 1; i &lt;= n; ++i)\n        fac[i] = fac[i - 1] * i % mod;\n    auto qkp = [&amp;](long long x, int y) &#123;\n        auto res(1ll);\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    inv[n] = qkp(fac[n], mod - 2);\n    for (int i = n - 1; i; --i)\n        inv[i] = inv[i + 1] * (i + 1) % mod;\n    auto C = [&amp;](int n, int m) &#123;\n        return fac[n] * inv[n - m] % mod * inv[m] % mod;\n    &#125;;\n    int m = n - 2;\n    for (int T = 0; T &lt;= n - 2; ++T) &#123;\n        int k = m - T, t = T + 1;\n        f[T] = C(t + k + 1, k + 2) * fac[m - T] % mod;\n    &#125;\n    auto res = 0ll;\n    for (int i = 1; i &lt;= n - 1; ++i)\n        (res += (long long)i * (i + n + 1) % mod * fac[n - i] % mod * f[n - i - 1] % mod) %= mod;\n    std::cout &lt;&lt; res * inv[2] % mod &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"c---destruction-of-walls\">C - Destruction of Walls</h2>\n<p><a href=\"https://atcoder.jp/contests/arc203/tasks/arc203_c\" class=\"uri\">https://atcoder.jp/contests/arc203/tasks/arc203_c</a></p>\n<hr />\n<h2 id=\"d---insert-xor\">D - Insert XOR</h2>\n<p><a href=\"https://atcoder.jp/contests/arc203/tasks/arc203_d\" class=\"uri\">https://atcoder.jp/contests/arc203/tasks/arc203_d</a></p>\n<hr />\n<h2 id=\"a---记忆\">A - 记忆</h2>\n<p><a href=\"https://ac.nowcoder.com/acm/problem/274793\" class=\"uri\">https://ac.nowcoder.com/acm/problem/274793</a></p>\n<p>需要意识到问题是静态的，并且不能用线段树之类维护；故考虑离线下来，想办法在 LCA 处统计答案。</p>\n<p>这个时候发现需要合并子树状态、整体异或、整体 +1，很容易想到 Trie。把 <span class=\"math inline\">\\(u\\to\\)</span> LCA 的答案保存在 LCA 处，然后再用 DFS + 回溯统计 LCA <span class=\"math inline\">\\(\\to v\\)</span> 的答案。想了半天没想到把上下拆开来做也是神了 😅</p>\n<p>可能比较考验对字典树的理解？做个比喻，字典树的 id 就相当于对这个点上信息的『引用』。</p>\n<details>\n<p>字典树合并的时候可以考虑回收废弃点，不然可能有点卡。</p>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int X = 50;\nconst int maxn = 2e7 + 5;\nlong long d[maxn];\nint tot, T[maxn][2], f[maxn], fa[maxn];\n#define lc(p) T[p][0]\n#define rc(p) T[p][1]\nint find(int x) &#123; return x == f[x] ? x : f[x] = find(f[x]); &#125;\nint newnode(void) &#123;\n    int p = ++tot;\n    assert(p &lt; maxn);\n    d[p] = lc(p) = rc(p) = 0, f[p] = p;\n    return p;\n&#125;\nvoid pushdown(int p) &#123;\n    if (d[p]) &#123;\n        if (d[p] &amp; 1)\n            std::swap(lc(p), rc(p));\n        d[p] &gt;&gt;= 1;\n        if (lc(p))\n            d[lc(p)] ^= d[p];\n        if (rc(p))\n            d[rc(p)] ^= d[p];\n        d[p] = 0;\n    &#125;\n    return;\n&#125;\nint ins(int p, long long x) &#123;\n    for (int i = 0; i &lt; X; ++i) &#123;\n        pushdown(p);\n        if (!T[p][(x &gt;&gt; i) &amp; 1]) &#123;\n            T[p][(x &gt;&gt; i) &amp; 1] = newnode();\n            fa[T[p][(x &gt;&gt; i) &amp; 1]] = p;\n        &#125;\n        p = T[p][(x &gt;&gt; i) &amp; 1];\n    &#125;\n    return p;\n&#125;\nvoid merge(int &amp;p, int q) &#123;\n    if (!q)\n        return;\n    if (!p) &#123;\n        p = q;\n        return;\n    &#125;\n    pushdown(p), pushdown(q);\n    fa[lc(q)] = p, fa[rc(q)] = p;\n    merge(lc(p), lc(q)), merge(rc(p), rc(q));\n    assert(f[p] == p), assert(f[q] == q), f[q] = p;\n    return;\n&#125;\nlong long ask(int p) &#123;\n    std::vector&lt;int&gt; st;\n    for (int i = 0, j = p; i &lt; X; ++i)\n        st.push_back(fa[j]), j = fa[j];\n    for (int i = 0; i &lt; X; ++i)\n        pushdown(st.back()), st.pop_back();\n    long long x = 0;\n    for (int i = 0; i &lt; X; ++i) &#123;\n        x = x * 2 + (p == rc(fa[p]));\n        p = fa[p];\n    &#125;\n    return x;\n&#125;\nvoid add(int p) &#123;\n    for (int i = 0; p &amp;&amp; i &lt; X; ++i) &#123;\n        pushdown(p);\n        std::swap(lc(p), rc(p));\n        p = lc(p);\n    &#125;\n    return;\n&#125;\nvoid del(int p) &#123;\n    for (int i = 0; p &amp;&amp; i &lt; X; ++i) &#123;\n        pushdown(p);\n        std::swap(lc(p), rc(p));\n        p = rc(p);\n    &#125;\n    return;\n&#125;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, m;\n    std::cin &gt;&gt; n &gt;&gt; m;\n    std::vector&lt;int&gt; a(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i];\n    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);\n    for (int i = 1, x, y; i &lt; n; ++i) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y;\n        g[x].push_back(y), g[y].push_back(x);\n    &#125;\n    std::vector&lt;int&gt; siz(n + 1), son(n + 1), top(n + 1), fa(n + 1), dep(n + 1);\n    std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;\n        siz[x] = 1;\n        for (auto i : g[x])\n            if (i != fa[x]) &#123;\n                dep[i] = dep[x] + 1;\n                fa[i] = x, DFS(i);\n                siz[x] += siz[i];\n                if (siz[i] &gt; siz[son[x]])\n                    son[x] = i;\n            &#125;\n        return;\n    &#125;;\n    DFS(1);\n    DFS = [&amp;](int x) &#123;\n        if (son[x])\n            top[son[x]] = top[x], DFS(son[x]);\n        for (auto i : g[x])\n            if (i != son[x] &amp;&amp; i != fa[x])\n                top[i] = i, DFS(i);\n        return;\n    &#125;;\n    top[1] = 1, DFS(1);\n    auto askLCA = [&amp;](int x, int y) &#123;\n        for (; top[x] != top[y]; x = fa[top[x]])\n            if (dep[top[x]] &lt; dep[top[y]])\n                std::swap(x, y);\n        return dep[x] &lt; dep[y] ? x : y;\n    &#125;;\n    struct node &#123; long long x; int u, v; &#125;;\n    std::vector&lt;node&gt; q(m + 1);\n    std::vector&lt;int&gt; id(m + 1);\n    std::vector&lt;long long&gt; res(m + 1), ans(m + 1);\n    std::vector&lt;std::vector&lt;int&gt; &gt; up(n + 1), dn(n + 1), ed(n + 1);\n    for (int i = 1, x, u, v; i &lt;= m; ++i) &#123;\n        std::cin &gt;&gt; x &gt;&gt; u &gt;&gt; v;\n        q[i] = &#123; x, u, v &#125;;\n        up[u].push_back(i), dn[askLCA(u, v)].push_back(i), ed[v].push_back(i);\n    &#125;\n    std::vector&lt;int&gt; rt(n + 1);\n    DFS = [&amp;](int x) &#123;\n        rt[x] = newnode();\n        for (auto i : g[x])\n            if (i != fa[x]) &#123;\n                DFS(i);\n                merge(rt[x], rt[i]);\n            &#125;\n        add(rt[x]);\n        for (auto i : up[x])\n            id[i] = ins(rt[x], q[i].x);\n        d[rt[x]] ^= a[x];\n        for (auto i : dn[x])\n            res[i] = ask(find(id[i]));\n        return;\n    &#125;;\n    DFS(1);\n    tot = 0, rt[0] = newnode();\n    std::fill(id.begin() + 1, id.end(), 0);\n    DFS = [&amp;](int x) &#123;\n        d[rt[0]] ^= a[x];\n        for (auto i : dn[x])\n            id[i] = ins(rt[0], res[i]);\n        for (auto i : ed[x])\n            ans[i] = ask(id[i]);\n        add(rt[0]);\n        for (auto i : g[x])\n            if (i != fa[x])\n                DFS(i);\n        del(rt[0]);\n        d[rt[0]] ^= a[x];\n        return;\n    &#125;;\n    DFS(1);\n    for (int i = 1; i &lt;= m; ++i)\n        std::cout &lt;&lt; ans[i] &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"b---ビーバーの会合-2-meetings-2\">B - ビーバーの会合 2 (Meetings 2)</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/AT_joisc2021_j\" class=\"uri\">https://www.luogu.com.cn/problem/AT_joisc2021_j</a></p>\n<p>定义所求点为『局部重心』；类似树的重心，容易发现当关键点数量为奇时，只存在一个局部重心；否则，局部重心组成一条链。</p>\n<p>即对于每一个 <span class=\"math inline\">\\(i\\)</span>，需要找到一条最长链，使得其两端存在大小为 <span class=\"math inline\">\\(i\\)</span> 的子树（容易发现取后缀 max 即可得到真实答案）。使用点分治，精细实现容易做到 <span class=\"math inline\">\\(O(n\\log n)\\)</span>。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);\n    for (int i = 1, x, y; i &lt; n; ++i) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y;\n        g[x].push_back(y), g[y].push_back(x);\n    &#125;\n    std::vector&lt;int&gt; mx(n + 1), siz(n + 1), p, tag(n + 1), res(n + 1, 1);\n    std::function&lt;void(int, int)&gt; DFS1 = [&amp;](int x, int fa) &#123;\n        p.push_back(x);\n        siz[x] = 1, mx[x] = 0;\n        for (auto i : g[x])\n            if (!tag[i] &amp;&amp; i != fa) &#123;\n                DFS1(i, x);\n                siz[x] += siz[i];\n                mx[x] = std::max(mx[x], siz[i]);\n            &#125;\n        return;\n    &#125;;\n    auto findrt = [&amp;](int x) &#123;\n        p.clear(), DFS1(x, -1);\n        int n = (int)p.size();\n        for (auto i : p)\n            if (mx[i] &lt;= n / 2 &amp;&amp; n - siz[i] &lt;= n / 2)\n                return i;\n        assert(0);\n        return -1;\n    &#125;;\n    struct node &#123;\n        int u1, u2, id1, id2;\n        node(): u1(0), u2(0), id1(0), id2(0) &#123;&#125;\n        void upd(int u, int id) &#123;\n            if (id1 == id)\n                u1 = std::max(u1, u);\n            else if (u &gt;= u1)\n                u2 = u1, id2 = id1, u1 = u, id1 = id;\n            else if (u &gt;= u2)\n                u2 = u, id2 = id;\n            return;\n        &#125;\n    &#125;;\n    std::vector&lt;node&gt; s(n + 1);\n    std::function&lt;void(int, int, int, int)&gt; DFS2 = [&amp;](int x, int fa, int dep, int anc) &#123;\n        s[siz[x]].upd(dep, anc);\n        for (auto i : g[x])\n            if (!tag[i] &amp;&amp; i != fa)\n                DFS2(i, x, dep + 1, anc);\n        return;\n    &#125;;\n    std::function&lt;void(int, int, int, int)&gt; DFS3 = [&amp;](int x, int fa, int dep, int anc) &#123;\n        int v = ((s[siz[x]].id1 == anc) ? s[siz[x]].u2 : s[siz[x]].u1);\n        res[2 * siz[x]] = std::max(res[2 * siz[x]], dep + 1 + v);\n        for (auto i : g[x])\n            if (!tag[i] &amp;&amp; i != fa)\n                DFS3(i, x, dep + 1, anc);\n        return;\n    &#125;;\n    std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;\n        x = findrt(x), p.clear(), DFS1(x, -1);\n        // printf(&quot;rt = %d\\n&quot;, x);\n        for (auto i : g[x])\n            if (!tag[i])\n                DFS2(i, x, 1, i);\n        for (int i = siz[x] - 1; i; --i) &#123;\n            s[i].upd(s[i + 1].u1, s[i + 1].id1);\n            s[i].upd(s[i + 1].u2, s[i + 1].id2);\n        &#125;\n        for (auto i : g[x])\n            if (!tag[i])\n                DFS3(i, x, 1, i);\n        tag[x] = 1;\n        for (int i = 1; i &lt; siz[x]; ++i)\n            s[i] = node();\n        for (auto i : g[x])\n            if (!tag[i])\n                DFS(i);\n        return;\n    &#125;;\n    DFS(1);\n    for (int i = (n &gt;&gt; 1) * 2; i; --i)\n        if (i + 2 &lt;= n)\n            res[i] = std::max(res[i], res[i + 2]);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cout &lt;&lt; res[i] &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"c---the-closest-pair\">C - The Closest Pair</h2>\n<p><a href=\"https://ac.nowcoder.com/acm/problem/262593\" class=\"uri\">https://ac.nowcoder.com/acm/problem/262593</a></p>\n<p><strong>常规方法</strong>：考虑<strong>支配对</strong>，对于每个 <span class=\"math inline\">\\(a_i\\)</span>，找到所有合法的 <span class=\"math inline\">\\(a_j\\)</span>。容易想到枚举 <span class=\"math inline\">\\(a_i\\div a_j\\)</span> 来做；假设存在 <span class=\"math inline\">\\(a_k\\div a_i=a_j\\div a_i\\)</span> 且 <span class=\"math inline\">\\(k&gt;j\\)</span>。</p>\n<p>不妨设 <span class=\"math inline\">\\(a_j=K\\cdot a_i+p,a_k=K\\cdot a_i+q\\)</span>，<span class=\"math inline\">\\((a_i,a_j),(a_i,a_k)\\)</span> 均合法当且仅当下列条件全部成立：</p>\n<ul>\n<li><span class=\"math inline\">\\(a_j\\bmod a_i&gt;a_k\\bmod a_i\\)</span>； 则 <span class=\"math inline\">\\(a_j&gt;a_k\\)</span>。</li>\n<li><span class=\"math inline\">\\(a_j\\bmod a_k&gt;a_k\\bmod a_i\\)</span>；又 <span class=\"math inline\">\\(p-q\\ge a_j\\bmod a_k\\)</span>（<strong>太牛了这一步</strong>），即 <span class=\"math inline\">\\(p-q&gt;q\\iff p&gt;2q\\)</span>。</li>\n</ul>\n<p>证得只关心同一个 <span class=\"math inline\">\\(a_j\\div a_i\\)</span> 时的支配对数量为 <span class=\"math inline\">\\(\\log n\\)</span> 级别；总对数 <span class=\"math inline\">\\(O(n\\log n\\ln n)\\)</span>。离线下来扫描线就行了。</p>\n<details>\n<p>对着 单点修改 区间最值 想了 1h 的单 log 做法 😰 果然小脑掉线太可怕了，第二天早上重置大脑 1s 发现自己是斯波 😓</p>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int LEN = (1 &lt;&lt; 20);\nint nec(void) &#123;\n    static char buf[LEN], *p = buf, *e = buf;\n    if (p == e) &#123;\n        e = buf + fread(buf, 1, LEN, stdin);\n        if (e == buf) return EOF;\n        p = buf;\n    &#125;\n    return *p++;\n&#125;\nbool read(int &amp;x) &#123;\n    x = 0;\n    bool f = 0;\n    char ch = nec();\n    while (ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123;\n        if (ch == EOF) return 0;\n        if (ch == &#39;-&#39;) f = 1;\n        ch = nec();\n    &#125;\n    while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) &#123;\n        x = x * 10 + ch - &#39;0&#39;;\n        ch = nec();\n    &#125;\n    if (f) x = -x;\n    return 1;\n&#125;\nvoid print(int x) &#123;\n    if (x &lt; 0)\n        putchar(&#39;-&#39;), x = -x;\n    if (x &gt;= 10) print(x / 10);\n    putchar(x % 10 + &#39;0&#39;);\n    return;\n&#125;\nvoid print(int x, char ch) &#123;\n    print(x), putchar(ch);\n    return;\n&#125;\nconst int maxn = 4e6 + 5;\nstruct &#123; int l, r, u[2]; &#125; t[maxn];\n#define lt (t[p].l)\n#define rt (t[p].r)\nint tot[2];\nvoid add(int &amp;p, int l, int r, int x, int v, int i) &#123;\n    if (!p)\n        p = ++tot[i], t[p].u[0] = -1, t[p].u[1] = 0x3f3f3f3f;\n    if (i == 0)\n        t[p].u[0] = std::max(t[p].u[0], v);\n    else\n        t[p].u[1] = std::min(t[p].u[1], v);\n    if (l == r)\n        return;\n    int mid = (l + r) &gt;&gt; 1;\n    if (x &lt;= mid)\n        add(lt, l, mid, x, v, i);\n    else\n        add(rt, mid + 1, r, x, v, i);\n    return;\n&#125;\nint ask(int p, int l, int r, int ql, int qr, int i) &#123;\n    if (!p || (ql &lt;= l &amp;&amp; r &lt;= qr))\n        return t[p].u[i];\n    int mid = (l + r) &gt;&gt; 1;\n    if (qr &lt;= mid)\n        return ask(lt, l, mid, ql, qr, i);\n    if (ql &gt; mid)\n        return ask(rt, mid + 1, r, ql, qr, i);\n    if (i == 0)\n        return std::max(ask(lt, l, mid, ql, qr, 0), ask(rt, mid + 1, r, ql, qr, 0));\n    return std::min(ask(lt, l, mid, ql, qr, 1), ask(rt, mid + 1, r, ql, qr, 1));\n&#125;\n#undef lt\n#undef rt\nint main() &#123;\n#ifndef ONLINE_JUDGE\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    const int m = 1e6;\n    int rt[2] = &#123; 0 &#125;, n;\n    t[0].u[0] = -1, t[0].u[1] = 0x3f3f3f3f;\n    read(n);\n    std::vector&lt;int&gt; a(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        read(a[i]);\n    std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; t(n + 1);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        if (i != 1) &#123;\n            for (int K = a[i]; K &lt;= m; K += a[i]) &#123;\n                for (int mx = std::min(a[i] - 1, m - K); ; ) &#123;\n                    int k = ask(rt[0], 1, m, K, K + mx, 0);\n                    if (k == -1)\n                        break;\n                    t[i].emplace_back(k, a[k] - K);\n                    if (k == 1 || !(a[k] - K))\n                        break;\n                    mx = (a[k] - K - 1) / 2;\n                &#125;\n            &#125;\n        &#125;\n        add(rt[0], 1, m, a[i], i, 0);\n    &#125;\n    for (int i = n; i; --i) &#123;\n        if (i != n)\n            for (int K = a[i]; K &lt;= m; K += a[i])\n                for (int mx = std::min(a[i] - 1, m - K); ; ) &#123;\n                    int k = ask(rt[1], 1, m, K, K + mx, 1);\n                    if (k == 0x3f3f3f3f)\n                        break;\n                    t[k].emplace_back(i, a[k] - K);\n                    if (k == n || !(a[k] - K))\n                        break;\n                    mx = (a[k] - K - 1) / 2;\n                &#125;\n        add(rt[1], 1, m, a[i], i, 1);\n    &#125;\n    int q;\n    read(q);\n    std::vector&lt;int&gt; res(q + 1);\n    std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; u(n + 1);\n    for (int i = 1, l, r; i &lt;= q; ++i) &#123;\n        read(l), read(r);\n        if (l &gt; r)\n            std::swap(l, r);\n        u[r].emplace_back(l, i);\n    &#125;\n    std::vector&lt;int&gt; bit(n + 1, 0x3f3f3f3f);\n    auto lowbit = [&amp;](int x) &#123; return x &amp; -x; &#125;;\n    auto add = [&amp;](int x, int v) &#123;\n        for (; x &lt;= n; x += lowbit(x))\n            bit[x] = std::min(bit[x], v);\n        return;\n    &#125;;\n    auto ask = [&amp;](int x) &#123;\n        auto res = 0x3f3f3f3f;\n        for (; x; x -= lowbit(x))\n            res = std::min(res, bit[x]);\n        return res;\n    &#125;;\n    for (int r = 1; r &lt;= n; ++r) &#123;\n        for (auto [l, v] : t[r])\n            add(n - l + 1, v);\n        for (auto [l, i] : u[r])\n            res[i] = ask(n - l + 1);\n    &#125;\n    for (int i = 1; i &lt;= q; ++i)\n        print(res[i], &#39;\\n&#39;);\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<p>求支配对的过程也要带 log（线段树），再加上扫描线的 3log，总共是常数比较大的 3log（卡了一个上午的常也是有了）。所以接下来讲解另一种奇技淫巧。</p>\n<p><strong>暴力分治</strong>：注意到对于比较长（<span class=\"math inline\">\\(len&gt; B\\)</span>）的区间，答案比较小；故考虑分治。</p>\n<ul>\n<li>对于长询问（<span class=\"math inline\">\\(len&gt;B\\)</span>），从小到大枚举答案并 check；预处理某个范围（<span class=\"math inline\">\\(V\\)</span>）内的 <span class=\"math inline\">\\(res\\)</span> 出现的所有位置，平衡的时候还要算上调和级数和 bit。</li>\n<li>对于短询问（<span class=\"math inline\">\\(len\\le B\\)</span>），发现每次区间内暴力是 <span class=\"math inline\">\\(O(B^2q)\\)</span> 的；把询问离线下来，精细实现，利用询问的公共部分使得<strong>每一对数只被枚举一次</strong>就能达到 <span class=\"math inline\">\\(O(B^2 + Bq)\\)</span>。</li>\n</ul>\n<p>最优解取 <span class=\"math inline\">\\(B=333,V=483\\)</span>，不自己实现一遍了。</p>\n<hr />\n<h2 id=\"d---仙人掌\">D - 仙人掌</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P3687\" class=\"uri\">https://www.luogu.com.cn/problem/P3687</a></p>\n<p>把边双从图中删除、问题转化为树上<strong>边</strong>不交的链覆盖，使得<strong>所有链长 <span class=\"math inline\">\\(\\ge 2\\)</span></strong> 的方案数。发现由于<strong>边可以不被覆盖</strong>，常规 DP 会使得在父节点处合并时需要额外的数量维，参考树上背包，复杂度 <span class=\"math inline\">\\(O(n^2)\\)</span>。</p>\n<p>思考时会注意到两个限制可以抵消——如果认为长为 <span class=\"math inline\">\\(1\\)</span> 的链就是不被覆盖的边，覆盖所有树边，显然可以建立和合法解的双射。此时合并是非常方便的，注意到每个儿子的系数一定都参与『分步』，只需要求出『分类』的系数。这个可以预处理（和 <a href=\"/20250407/#a.-二分图染色\">二分图染色</a> 这个题有点像），令 <span class=\"math inline\">\\(f_i\\)</span> 表示一个点度数为 <span class=\"math inline\">\\(i\\)</span> 时的答案，参考错排的思路，则 <span class=\"math inline\">\\(i\\)</span> 可以不参与配对，也可以乱选一个点配对，如果选中了已配对的点就令其和 <span class=\"math inline\">\\(i-1\\)</span> 交换，可以建立和合法解的双射。则 <span class=\"math inline\">\\(f_i=f_{i-1}+(n-1)f_{i-2}\\)</span>。</p>\n<p>首先需要 check 原图是否为仙人掌，顺带回忆一下连通性的知识——在 DFS 树上差分，检查是否有边被覆盖两次即可。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 998244353;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int T;\n    for (std::cin &gt;&gt; T; T--; ) &#123;\n        int n, m;\n        std::cin &gt;&gt; n &gt;&gt; m;\n        std::vector&lt;std::vector&lt;int&gt; &gt; g1(n + 1);\n        for (int x, y; m--; ) &#123;\n            std::cin &gt;&gt; x &gt;&gt; y;\n            g1[x].push_back(y), g1[y].push_back(x);\n        &#125;\n        bool flag = 1;\n        int now = 0, cnt = 0;\n        std::vector&lt;int&gt; st, dfn(n + 1), low(n + 1), col(n + 1), diff(n + 1);\n        std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int fa) &#123;\n            st.push_back(x);\n            dfn[x] = low[x] = ++now;\n            for (auto i : g1[x])\n                if (!dfn[i]) &#123;\n                    // printf(&quot;x = %d, %d -&gt; %d\\n&quot;, x, x, i);\n                    DFS(i, x);\n                    diff[x] += diff[i];\n                    // printf(&quot;x = %d, diff[%d] += diff[%d]\\n&quot;, x, x, i);\n                    low[x] = std::min(low[x], low[i]);\n                &#125;\n                else if (i != fa &amp;&amp; dfn[i] &lt; dfn[x]) &#123;\n                    low[x] = std::min(low[x], dfn[i]);\n                    ++diff[x], --diff[i];\n                    // printf(&quot;x = %d, ++diff[%d], --diff[%d]\\n&quot;, x, x, i);\n                &#125;\n            if (diff[x] &gt;= 2)\n                flag = 0;\n            // printf(&quot;x = %d, diff[%d] = %d\\n&quot;, x, x, diff[x]);\n            if (low[x] == dfn[x]) &#123;\n                ++cnt;\n                for (int p = -1; p != x; ) &#123;\n                    p = st.back(), st.pop_back();\n                    col[p] = cnt;\n                &#125;\n            &#125;\n            return;\n        &#125;;\n        DFS(1, -1);\n        if (!flag) &#123;\n            std::cout &lt;&lt; 0 &lt;&lt; &#39;\\n&#39;;\n            continue;\n        &#125;\n        std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);\n        for (int i = 1; i &lt;= n; ++i)\n            for (auto j : g1[i])\n                if (col[i] != col[j])\n                    g[i].push_back(j);\n        std::vector&lt;long long&gt; f(n + 1), dp(n + 1);\n        dp[0] = 1ll, dp[1] = 1ll;\n        for (int i = 2; i &lt;= n; ++i)\n            dp[i] = (dp[i - 1] + (i - 1) * dp[i - 2]) % mod;\n        std::vector&lt;int&gt; tag(n + 1);\n        DFS = [&amp;](int x, int fa) &#123;\n            f[x] = 1ll, tag[x] = 1;\n            for (auto i : g[x])\n                if (i != fa) &#123;\n                    DFS(i, x);\n                    (f[x] *= f[i]) %= mod;\n                &#125;\n            (f[x] *= dp[(int)g[x].size()]) %= mod;\n            return;\n        &#125;;\n        auto res(1ll);\n        for (int i = 1; i &lt;= n; ++i)\n            if (!tag[i])\n                DFS(i, -1), (res *= f[i]) %= mod;\n        std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<p>E. Many Minimizations 是数学题，跳了。</p>\n<hr />\n<hr />\n<h2 id=\"无名题\">无名题</h2>\n<blockquote>\n<p>背景：给定 <span class=\"math inline\">\\(n,k\\)</span>，对于 <span class=\"math inline\">\\(\\forall\\, 1\\le i\\le n\\)</span>，令 <span class=\"math inline\">\\(a_i=i\\bmod k\\)</span>，问一共有多少个本质不同的子序列？对于 <span class=\"math inline\">\\(k=1,2,\\cdots,n\\)</span> 分别求出答案。</p>\n</blockquote>\n<hr />\n<h2 id=\"maimai\">maimai</h2>\n<p><a href=\"https://ac.nowcoder.com/acm/contest/66112/F\" class=\"uri\">https://ac.nowcoder.com/acm/contest/66112/F</a></p>\n",
            "tags": [
                "字典树",
                "计数",
                "字符串",
                "支配对"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20250430/",
            "url": "https://xsc062.netlify.app/20250430/",
            "title": "杂题选谈：连通图计数",
            "date_published": "2025-04-30T02:31:11.000Z",
            "content_html": "<figure>\n<img src=\"/20250430/neko.png\" alt=\"猫\" style=\"width: 75px\">\n<figcaption>\n猫\n</figcaption>\n</figure>\n<span id=\"more\"></span>\n<p>太可怕了！2025 年才过去 4 个月，正经文章的总数已经和 2024 年中正经文章的总数一样多了。</p>\n<hr />\n<h2 id=\"有标号无向图计数\">有标号无向图计数</h2>\n<p>问题模型大概如下：</p>\n<blockquote>\n<p>给定 <span class=\"math inline\">\\(N\\)</span> 个点，你可以在它们间任意连边，但存在限制：</p>\n<ul>\n<li>其中一个较好处理（如要求图必须是二分图）；</li>\n<li>另一个较难处理（如去重问题等）；</li>\n<li>最后，可能要求图连通。</li>\n</ul>\n</blockquote>\n<p>首先需要知道怎么处理这样的计数问题。以下皆建立在无重边、自环的基础上。</p>\n<ol type=\"1\">\n<li><p>先只考虑容易的限制，且不要求连通：</p>\n<p><em>注：如果发现 <strong>不连通</strong> 的时候没办法很方便地计算精确方案数（也就是说会算重），那么可以把 <strong>去重</strong> 作为较难的限制，这一步算重就不重要了</em>。</p>\n<p>该怎么求怎么求。例如，若该限制是二分图且可以算重，枚举左部点数及边，那么方案数就是 <span class=\"math inline\">\\(\\sum\\limits_{i=0}^n C_n^i\\cdot C_{i\\cdot (n-i)}^m\\)</span>。</p>\n这个时候需要注意到算重部分的意义是什么。比如此处，计算中一个连通块将左右部翻转后被视作不同的子图，但在全局看来对应的总图是同一个二分图。因此，对于拥有 <span class=\"math inline\">\\(k\\)</span> 个连通块的图，其被计算了 <span class=\"math inline\">\\(2^k\\)</span> 次。</li>\n<li><p>再加上必须连通的限制，仍只考虑容易的限制：</p>\n<p>如果不存在其他限制，那么就是 <a href=\"https://oeis.org/A001187\">A001187</a>。</p>\n<p>连通的方案就是任意的方案减去不连通的方案。</p>\n<ul>\n<li>任意的求法就是第一点；</li>\n<li>不连通的方案，枚举 <span class=\"math inline\">\\(1\\)</span> 所在子集，让其补集里面任意连边（第 1 点的子问题）且不和 <span class=\"math inline\">\\(1\\)</span> 所在子集相连。</li>\n</ul></li>\n<li><p>接着，对连通的情况应用较难处理的限制：</p>\n<p><em>因为连通会带来一些比较好的性质简化运算，所以选择在这一步加上较难的限制</em>。</p>\n例如，对于上文中二分图去重的例子，连通图中显然只有一个连通块，将连通图的方案 <span class=\"math inline\">\\(\\div 2\\)</span> 就可以得到答案。</li>\n<li><p>最后，如果题目要求任意图的方案，用第三步中的答案再次算出任意图的答案。</p>\n<p>相当于是把第 2 点中的过程反过来，枚举 <span class=\"math inline\">\\(1\\)</span> 所在子集，在其补集中任意连边（该问的子问题）且可以和 <span class=\"math inline\">\\(1\\)</span> 所在的子集连边。</p></li>\n</ol>\n<p>这样就可以解决问题。</p>\n<hr />\n<h3 id=\"a---many-good-tuple-problems\">A - Many Good Tuple Problems</h3>\n<p><a href=\"https://atcoder.jp/contests/abc327/tasks/abc327_g\" class=\"uri\">https://atcoder.jp/contests/abc327/tasks/abc327_g</a></p>\n<p>如果把一组 <span class=\"math inline\">\\((S_i,T_i)\\)</span> 看作一条边的话，原限制就可以转化为：在 <span class=\"math inline\">\\(N\\)</span> 个点中连 <span class=\"math inline\">\\(M\\)</span> 条可重边，形成二分图的方案数。边有序。</p>\n<p><del>你可以发现我偷懒把这道题拿去上面举例了</del>，由于边是可重的，而我们的模型要求无重边，但发现这个限制是独立于模型外的，也就是可以在最后枚举有多少条不同边，再用一点组合手段计算实际贡献。</p>\n<p>首先令 <span class=\"math inline\">\\(f_{0,n,m}\\)</span> 表示 <span class=\"math inline\">\\(n\\)</span> 个点、<span class=\"math inline\">\\(m\\)</span> 条边、<strong>不去重</strong>、<strong>连通性任意</strong> 的方案数，那么 <span class=\"math inline\">\\(f_{0,n,m}=\\sum_{i=0}^n C_n^i\\cdot C_{i\\cdot (n-i)}^m\\)</span>。</p>\n<p>令 <span class=\"math inline\">\\(f_{1,n,m}\\)</span> 表示 <strong>不去重</strong>、要求 <strong>连通</strong> 的方案，那么有 <span class=\"math inline\">\\(f_{1,n,m}=f_{0,n,m}-\\sum\\limits_{i,j} C_{n - 1}^{i-1}\\cdot f_{1,i,j}\\cdot f_{0,n-i,m-j}\\)</span>。</p>\n<p>令 <span class=\"math inline\">\\(f_{2,n,m}\\)</span> 表示 <strong>去重</strong>，要求 <strong>连通</strong> 的方案，那么有 <span class=\"math inline\">\\(f_{2,n,m}=\\dfrac {f_{1,n,m}}{2}\\)</span>。</p>\n<p>令 <span class=\"math inline\">\\(f_{3,n,m}\\)</span> 表示 <strong>去重</strong>，<strong>连通性任意</strong> 的方案数，那么有 <span class=\"math inline\">\\(f_{3,n,m}=\\sum\\limits_{i,j} C_{n-1}^{i-1} \\cdot f_{2,i,j} \\cdot f_{3,n-i,m-j}\\)</span>。</p>\n<p>最后的方案数为 <span class=\"math inline\">\\(\\sum\\limits_{j} f_{3,n,j}\\cdot F(m,j)\\)</span>。其中 <span class=\"math inline\">\\(F(m,j)\\)</span> 表示把 <span class=\"math inline\">\\(m\\)</span> 个有标号的球放在 <span class=\"math inline\">\\(j\\)</span> 个有标号的盒子里，不空放的方案数，可以容斥。最后注意边反向算两种，所以乘上 <span class=\"math inline\">\\(2^m\\)</span>。</p>\n<p>复杂度 <span class=\"math inline\">\\(O(n^6)\\)</span>。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 998244353;\nconst int inv2 = (mod + 1) &gt;&gt; 1;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, M, m;\n    std::cin &gt;&gt; n &gt;&gt; M, m = std::min(n * (n - 1) / 2, M);\n    std::vector&lt;std::vector&lt;long long&gt; &gt; C(n * n + 1, std::vector&lt;long long&gt; (n * n + 1));\n    for (int i = 0; i &lt;= n * n; ++i) &#123;\n        C[i][0] = 1ll;\n        for (int j = 1; j &lt;= i; ++j)\n            C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % mod;\n    &#125;\n    std::vector&lt;std::vector&lt;std::vector&lt;long long&gt; &gt; &gt; f(4, std::vector&lt;std::vector&lt;long long&gt; &gt; (n + 1, std::vector&lt;long long&gt; (m + 1)));\n    for (int i = 1; i &lt;= n; ++i)\n        for (int j = 0; j &lt;= m &amp;&amp; j &lt;= i * (i - 1) / 2; ++j)\n            for (int k = 0; k &lt;= i; ++k)\n                (f[0][i][j] += C[i][k] * C[k * (i - k)][j]) %= mod;\n    for (int i = 1; i &lt;= n; ++i)\n        for (int j = 0; j &lt;= m; ++j) &#123;\n            auto t(0ll);\n            for (int k = 1; k &lt;= i; ++k)\n                for (int l = 0; l &lt;= j; ++l)\n                    (t += C[i - 1][k - 1] * f[1][k][l] % mod * f[0][i - k][j - l]) %= mod;\n            f[1][i][j] = (f[0][i][j] + mod - t) % mod;\n            f[2][i][j] = f[1][i][j] * inv2 % mod;\n        &#125;\n    f[3][0][0] = 1ll;\n    for (int i = 1; i &lt;= n; ++i)\n        for (int j = 0; j &lt;= m; ++j)\n            for (int k = 1; k &lt;= i; ++k)\n                for (int l = 0; l &lt;= j; ++l)\n                    (f[3][i][j] += C[i - 1][k - 1] * f[2][k][l] % mod * f[3][i - k][j - l]) %= mod;\n    auto qkp = [](long long x, int y) &#123;\n        auto res(1ll);\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    std::vector&lt;long long&gt; F(m + 1);\n    for (int i = 1; i &lt;= m; ++i) &#123;\n        F[i] = qkp(i, M);\n        for (int j = 1, p = mod - 1; j &lt; m; ++j, p = mod - p)\n            (F[i] += p * C[i][j] % mod * qkp(i - j, M)) %= mod;\n    &#125;\n    auto res(0ll);\n    for (int j = 1; j &lt;= m; ++j)\n        (res += f[3][n][j] * F[j]) %= mod;\n    std::cout &lt;&lt; res * qkp(2, M) % mod &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"b---many-mst\">B - Many MST</h3>\n<p><a href=\"https://atcoder.jp/contests/abc386/tasks/abc386_g\" class=\"uri\">https://atcoder.jp/contests/abc386/tasks/abc386_g</a></p>\n<p>这里需要注意到 MST 和连通块的隐含联系。按照 Kruskal 的生成方式可以发现只需要在合并两个连通块时加上它们之间连边中最小的边权就可以得到 MST。</p>\n<p>因此容易想到在 DP 时对最小边权进行限制；枚举 <span class=\"math inline\">\\(k\\)</span>，让边权 <span class=\"math inline\">\\(\\le k\\)</span> 成为简单限制；让求解 MST 成为某种意义上的较难限制。</p>\n<p>令 <span class=\"math inline\">\\(f_{0,n,k}\\)</span> 表示 <span class=\"math inline\">\\(n\\)</span> 个点，边权 <span class=\"math inline\">\\(\\le k\\)</span>、<strong>对连通性没有要求</strong> 的方案数；相应地，<span class=\"math inline\">\\(f_{1,n,k}\\)</span> 表示 <strong>要求连通</strong> 的方案数，则：</p>\n<ul>\n<li><p><span class=\"math inline\">\\(f_{0,n,k}=\\sum\\limits_i C_{n-1}^{i-1}\\cdot f_{1,i,k-1} \\cdot f_{0,n-i,k}\\cdot (M-k+1)^{i\\times(n-i)}\\)</span>。</p>\n<p>注解：式子正确性建立在 <strong><span class=\"math inline\">\\(1\\)</span> 所在 的由权值 <span class=\"math inline\">\\(&lt;k\\)</span> 的边构成的最大连通块 大小为 <span class=\"math inline\">\\(i\\)</span></strong> 的基础之上，故两个连通块之间的边权只能 <span class=\"math inline\">\\(\\ge k\\)</span>。这也提醒我们，此处的 <strong>不连通</strong> 含义实际上是给这些边一个 <span class=\"math inline\">\\((M-k)\\)</span> 的系数。</p>\n那么这样你会注意到，<span class=\"math inline\">\\(f_0\\)</span> 的意义就与 <span class=\"math inline\">\\(k\\)</span> 无关了（那么显然值也与 <span class=\"math inline\">\\(k\\)</span> 无关），但是仍然保留 <span class=\"math inline\">\\(k\\)</span> 对思考有帮助，故留之。</li>\n<li><p><span class=\"math inline\">\\(f_{1,n,k}=f_{0, n, k} - \\sum\\limits_i C_{n - 1}^{i-1} \\cdot f_{1,i,k}\\cdot f_{0,n-i,k}\\times (M-k)^{i\\times (n - i)}\\)</span>。</p></li>\n</ul>\n<p>令 <span class=\"math inline\">\\(g_{0, n, k}\\)</span> 表示 <span class=\"math inline\">\\(n\\)</span> 个点、边权 <span class=\"math inline\">\\(\\le k\\)</span>、<strong>对连通性没有要求</strong> 的 MST 之和；相应地，<span class=\"math inline\">\\(g_{1,n,k}\\)</span> 表示对应条件下 <strong>要求连通</strong> 的 MST 之和。则：</p>\n<ul>\n<li><p><span class=\"math inline\">\\(g_{0,n,k}=\\sum\\limits_{i} C_{n-1}^{i-1}\\cdot (f_{1,i,k - 1}\\cdot g_{0,n-i,k}+g_{1,i,k - 1} \\cdot f_{0,n-i,k}+f_{1,i,k-1}\\cdot f_{0,n-i,k}\\cdot k)\\cdot (M-k+1)^{i\\times (n-i)}\\)</span>。</p>\n注解：类比 <span class=\"math inline\">\\(f_0\\)</span> 的计算方式得到 <span class=\"math inline\">\\(g_0\\)</span>。在 <span class=\"math inline\">\\(i\\times (n-i)\\)</span> 中任选一条作为 MST 上权值为 <span class=\"math inline\">\\(k\\)</span> 的边，故有 <span class=\"math inline\">\\(f_{1,i,k-1}\\cdot f_{0,n-i,k}\\cdot k\\)</span>。之所以必须要求有这么一条边是为了和 <span class=\"math inline\">\\(g_{k-1}\\)</span> 和 <span class=\"math inline\">\\(g_{k+1}\\)</span> 等区分。</li>\n<li><p><span class=\"math inline\">\\(g_{1,n,k}=g_{0,n,k}-\\sum\\limits_i C_{n-1}^{i-1}\\cdot (f_{1,i,k}\\cdot g_{0,n-i,k}+g_{1,i,k}\\cdot f_{0,n-i,k}+f_{1,i,k}\\cdot f_{0,n-i,k}\\cdot k)\\cdot (M-k)^{i\\times (n-i)}\\)</span>。</p></li>\n</ul>\n<p>复杂度 <span class=\"math inline\">\\(O(n^2\\cdot M)\\)</span>。要求预处理幂，不然会 T。以及可能需要把 <span class=\"math inline\">\\(f_0,f_1,g_0,g_1\\)</span> 放在同一个内层循环求，不然会卡常；<del>在此基础上使用内存连续访问优化似乎并不明显</del> <img src=\"/em/kt.gif\" /></p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 998244353;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int N, M;\n    std::cin &gt;&gt; N &gt;&gt; M;\n    using arr = std::vector&lt;long long&gt;;\n    using brr = std::vector&lt;arr&gt;;\n    using crr = std::vector&lt;brr&gt;;\n    crr f(2, brr(N + 1, arr(M + 1))), g(2, brr(N + 1, arr(M + 1)));\n    brr C(N + 1, arr(N + 1)), p(M + 1, arr(N * N + 1));\n    for (int i = 0; i &lt;= M; ++i) &#123;\n        p[i][0] = 1ll;\n        for (int j = 1; j &lt;= N * N; ++j)\n            p[i][j] = p[i][j - 1] * i % mod;\n    &#125;\n    for (int i = 0; i &lt;= N; ++i) &#123;\n        C[i][0] = 1ll;\n        for (int j = 1; j &lt;= i; ++j)\n            C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % mod;\n    &#125;\n    f[1][0][0] = f[1][1][0] = 1ll;\n    for (int n = 1; n &lt;= N; ++n)\n        for (int k = 1; k &lt;= M; ++k) &#123;\n            f[0][n][k] = f[1][n][k - 1];\n            for (int i = 1; i &lt; n; ++i) &#123;\n                (f[0][n][k] += C[n - 1][i - 1] * f[1][i][k - 1] % mod * f[0][n - i][k] % mod * p[M - k + 1][i * (n - i)]) %= mod;\n                (f[1][n][k] += mod - C[n - 1][i - 1] * f[1][i][k] % mod * f[0][n - i][k] % mod * p[M - k][i * (n - i)] % mod) %= mod;\n            &#125;\n            (f[1][n][k] += f[0][n][k]) %= mod;\n        &#125;\n    for (int n = 1; n &lt;= N; ++n)\n        for (int k = 1; k &lt;= M; ++k) &#123;\n            g[0][n][k] = g[1][n][k - 1];\n            for (int i = 1; i &lt; n; ++i) &#123;\n                (g[0][n][k] += (f[1][i][k - 1] * g[0][n - i][k] % mod + g[1][i][k - 1] * f[0][n - i][k] % mod + f[1][i][k - 1] * f[0][n - i][k] % mod * k) % mod * C[n - 1][i - 1] % mod * p[M - k + 1][i * (n - i)]) %= mod;\n                (g[1][n][k] += mod - (f[1][i][k] * g[0][n - i][k] % mod + g[1][i][k] * f[0][n - i][k] % mod + f[1][i][k] * f[0][n - i][k] % mod * k) % mod * C[n - 1][i - 1] % mod * p[M - k][i * (n - i)] % mod) %= mod;\n            &#125;\n            (g[1][n][k] += g[0][n][k]) %= mod;\n        &#125;\n    // for (int n = 1; n &lt;= N; ++n)\n    //     for (int k = 1; k &lt;= M; ++k) &#123;\n    //         printf(&quot;f[0][%d][%d] = %lld\\n&quot;, n, k, f[0][n][k]);\n    //         printf(&quot;f[1][%d][%d] = %lld\\n&quot;, n, k, f[1][n][k]);\n    //         printf(&quot;g[0][%d][%d] = %lld\\n&quot;, n, k, g[0][n][k]);\n    //         printf(&quot;g[1][%d][%d] = %lld\\n&quot;, n, k, g[1][n][k]);\n    //     &#125;\n    std::cout &lt;&lt; g[1][N][M] &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"有标号-dag-计数\">有标号 DAG 计数</h2>\n<blockquote>\n<p>给定 <span class=\"math inline\">\\(N\\)</span> 个点，你可以在它们间任意连边，要求最后图为 DAG，可能要求图弱连通。</p>\n</blockquote>\n<p>如果说无向图计数关键在于连通块，那么 DAG 在此基础上关键在于入度为 <span class=\"math inline\">\\(0\\)</span> 的点集。</p>\n<p>令 <span class=\"math inline\">\\(f(i)\\)</span> 表示 <span class=\"math inline\">\\(i\\)</span> 个点的 DAG 的答案；<span class=\"math inline\">\\(g_{0, i,j}\\)</span> 表示 <span class=\"math inline\">\\(i\\)</span> 个点的 DAG，其中 <span class=\"math inline\">\\(j\\)</span> 个入度为 <span class=\"math inline\">\\(0\\)</span> 的方案，不难想到容斥：令 <span class=\"math inline\">\\(g_{1,i,j}\\)</span> 表示至少 <span class=\"math inline\">\\(j\\)</span> 个的方案，那么：</p>\n<p><span class=\"math display\">\\[\ng_{1,i,j}=C_i^j\\times f(i-j)\\times 2^{j\\times (i-j)}\\\\\ng_{0,i,j}=\\sum_{k=j}^i (-1)^{k-j}\\cdot C_k^j\\cdot g_{1,i,j}\\\\\nf(i)=\\sum_{j=1}^i g_{0,i,j}\n\\]</span></p>\n<p>整理有：</p>\n<p><span class=\"math display\">\\[\n\\begin{aligned}\nf(i)\n&amp;=\\sum_{j=1}^i \\sum_{k=j}^i (-1)^{k-j}\\cdot C_k^j\\cdot g_{1,i,k}\\\\\n&amp;=\\sum_{k=1}^i (-1)^k\\cdot g_{1,i,k}\\cdot \\sum_{j=1}^k (-1)^j\\cdot C_k^j\\\\\n&amp;=\\sum_{k=1}^i (-1)^k\\cdot g_{1,i,k}\\cdot (0^k-1)\\\\\n&amp;=\\sum_{k=1}^i (-1)^{k+1}\\cdot C_i^k\\times f(i-k)\\times 2^{(i-k)}\n\\end{aligned}\n\\]</span></p>\n<p>即得递推式。如果要求连通仿照无向图连通的方法，用任意减去不连通即可。</p>\n<hr />\n<h3 id=\"c---amusement-park\">C - Amusement Park</h3>\n<p><a href=\"https://codeforces.com/problemset/problem/1193/A\" class=\"uri\">https://codeforces.com/problemset/problem/1193/A</a></p>\n<p>先考虑计算方案数。枚举 <span class=\"math inline\">\\(1\\)</span> 所在子集，那么有 <span class=\"math inline\">\\(f(S)=\\sum\\limits_{T\\in S} (-1)^{|T|+1}\\cdot f(S - T)\\)</span>。相较于一般的 DAG 计数，因为每条边取不取是固定的，所以没有了 <span class=\"math inline\">\\(2\\)</span> 的次幂的系数；同时因为直接枚举子集，所以没有了组合系数。</p>\n<p>注意此处 <span class=\"math inline\">\\(T\\)</span> 可构成一轮新的入度为 <span class=\"math inline\">\\(0\\)</span> 的点集当且仅当 <span class=\"math inline\">\\(T\\)</span> 之内没有连边，即 <span class=\"math inline\">\\(T\\)</span> 为独立集。</p>\n<p>算出方案数后如何算答案呢？发现对于一种合法的方案，把里面所有的边反向一定唯一对应另一种合法方案，两种方案取反边数相加为 <span class=\"math inline\">\\(m\\)</span>；那么给所有方案除以 <span class=\"math inline\">\\(2\\)</span>，再乘上 <span class=\"math inline\">\\(m\\)</span> 就能得到答案。</p>\n<p>复杂度 <span class=\"math inline\">\\(O(3^n)\\)</span>。需要提前把每个点集是否独立预处理下来。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 998244353, inv2 = (mod + 1) &gt;&gt; 1;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, m;\n    std::cin &gt;&gt; n &gt;&gt; m;\n    std::vector&lt;int&gt; g(n + 1);\n    for (int i = 1, x, y; i &lt;= m; ++i) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y;\n        g[x] |= (1 &lt;&lt; (y - 1));\n        g[y] |= (1 &lt;&lt; (x - 1));\n    &#125;\n    auto check = [&amp;](int s) &#123;\n        for (int i = 1; i &lt;= n; ++i)\n            if ((s &gt;&gt; (i - 1)) &amp; 1)\n                if (s &amp; g[i])\n                    return false;\n        return true;\n    &#125;;\n    int siz = 1 &lt;&lt; n;\n    std::vector&lt;int&gt; tag(siz);\n    for (int i = 0; i &lt; siz; ++i)\n        tag[i] = check(i);\n    std::vector&lt;long long&gt; f(siz);\n    f[0] = 1ll;\n    for (int i = 1; i &lt; siz; ++i)\n        for (int j = i; j; j = (j - 1) &amp; i)\n            if (tag[j])\n                (f[i] += ((__builtin_popcount(j) &amp; 1) ? 1 : mod - 1) * f[i ^ j]) %= mod;\n    std::cout &lt;&lt; f[siz - 1] * inv2 % mod * m % mod &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"d---balance-scale\">D - Balance Scale</h3>\n<p><a href=\"https://atcoder.jp/contests/abc306/tasks/abc306_h\" class=\"uri\">https://atcoder.jp/contests/abc306/tasks/abc306_h</a></p>\n<p>可以发现，如果将被 <code>=</code> 连起来的点缩起来，就可以转化成上一个问题。但枚举被缩的点集显然是不能通过的，这里介绍一种方法。</p>\n<p>不把缩点放在开头。在上一题中的 DP 式子 <span class=\"math inline\">\\(f(S)=\\sum\\limits_{T\\in S} (-1)^{|T|+1}\\cdot f(S - T)\\)</span> 中，考虑和我们最终的答案有什么差异：</p>\n<ol type=\"1\">\n<li>在现在的问题中，有的边是可以不选的！考虑这会给容斥带来怎样的影响。</li>\n</ol>\n<p>首先应该知道一件事情：你决定把一部分点缩到一起，当且仅当它们全部由 <code>=</code> 连接。要让一些边加入 DP，也就是让它们不是 <code>=</code>，当且仅当它们成为连通块的『割』——把连通块分成多个连通块。这种情况显然已经由另一条路径转移过了。也就是说，就用这个式子可以得到所有答案。 1. 另一个问题，在上一题中，我们可以轻易地判断 <span class=\"math inline\">\\(T\\)</span> 是否为独立集；但在本问中，不是独立集的点集也可能缩点成为独立集。</p>\n<p>发现有一种唯一方法，就是使 <span class=\"math inline\">\\(T\\)</span> 中位于同一连通块的点缩到一起；所以应该将 <span class=\"math inline\">\\(-1\\)</span> 的次数替换为 <span class=\"math inline\">\\(T\\)</span> 所在连通块个数 <span class=\"math inline\">\\(+1\\)</span>。</p>\n<p>注意这里说的连通块是 <span class=\"math inline\">\\(T\\)</span> 的导出子图中的连通块。</p>\n<p>这也启示我们不要把缩点和图的连通性等等关联得太死，需要把点等价的场景都可能用到缩点。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 998244353, inv2 = (mod + 1) &gt;&gt; 1;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, m;\n    std::cin &gt;&gt; n &gt;&gt; m;\n    std::vector&lt;int&gt; fa(n + 1);\n    std::function&lt;int(int)&gt; find = [&amp;](int x) &#123;\n        return fa[x] == x ? x : fa[x] = find(fa[x]);\n    &#125;;\n    auto merge = [&amp;](int x, int y) &#123;\n        fa[find(x)] = find(y);\n        return;\n    &#125;;\n    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);\n    for (int x, y; m--; ) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y;\n        g[x].push_back(y), g[y].push_back(x);\n    &#125;\n    int siz = 1 &lt;&lt; n;\n    std::vector&lt;int&gt; cnt(siz);\n    for (int i = 0; i &lt; siz; ++i) &#123;\n        std::iota(fa.begin(), fa.end(), 0);\n        std::vector&lt;int&gt; tag(n + 1);\n        for (int j = 1; j &lt;= n; ++j)\n            if ((i &gt;&gt; (j - 1)) &amp; 1)\n                for (auto k : g[j])\n                    if ((i &gt;&gt; (k - 1)) &amp; 1)\n                        merge(k, j);\n        for (int j = 1; j &lt;= n; ++j)\n            if ((i &gt;&gt; (j - 1)) &amp; 1)\n                cnt[i] += (fa[j] == j);\n    &#125;\n    std::vector&lt;long long&gt; f(siz);\n    f[0] = 1ll;\n    for (int i = 1; i &lt; siz; ++i)\n        for (int j = i; j; j = (j - 1) &amp; i)\n            if (cnt[j])\n                (f[i] += ((cnt[j] &amp; 1) ? 1 : mod - 1) * f[i ^ j]) %= mod;\n    std::cout &lt;&lt; f[siz - 1] &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"e---主旋律\">E - 主旋律</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P11714\" class=\"uri\">https://www.luogu.com.cn/problem/P11714</a></p>\n<p>即，给定一个有向图，问边集有多少个子集是强连通的。</p>\n<p>再次涉及到了连通性问题，但在这里需要结合 SCC 缩点来考虑。容易发现强连通即缩出来是一个点；故需要关注缩出来的点数。</p>\n<p>令 <span class=\"math inline\">\\(f(S)\\)</span> 表示 <span class=\"math inline\">\\(S\\)</span> 的导出子图内合法边子集的数量，<span class=\"math inline\">\\(g(S)\\)</span> 表示 <span class=\"math inline\">\\(S\\)</span> 的导出子图中非法边子集的数量；<span class=\"math inline\">\\(h(S,k)\\)</span> 表示 <span class=\"math inline\">\\(S\\)</span> 的导出子图中边的子集缩出来有 <span class=\"math inline\">\\(k\\)</span> 个点的数量， 令 <span class=\"math inline\">\\(E(S_1, S_2)\\)</span> 表示从 <span class=\"math inline\">\\(S_1\\)</span> 指向 <span class=\"math inline\">\\(S_2\\)</span> 的边数，则：</p>\n<p><span class=\"math display\">\\[\nf(S) = 2^{E(S,S)}-g(S)\\\\\ng(S)=\\sum_{T \\subseteq S}2^{E(T, S - T)}\\cdot 2^{E(T, T)}\\cdot \\sum_{k=1+[T=\\varnothing]} (-1)^{k+1}\\cdot h(S - T, k)\\\\\nh(S, k) = \\sum_{T\\subset S} f(T) \\cdot h(S - T, k-1)\n\\]</span></p>\n<p>注意为什么要用一个 <span class=\"math inline\">\\(h\\)</span> 来转移 <span class=\"math inline\">\\(g\\)</span> 呢？我们发现 <span class=\"math inline\">\\(-1\\)</span> 的次数和缩出来的点数是有关的，而光凭 <span class=\"math inline\">\\(g\\)</span> 无法表示点数信息，所以需要用 <span class=\"math inline\">\\(h\\)</span> 来搭个桥。</p>\n<p>直接 DP，复杂度 <span class=\"math inline\">\\(O(n\\cdot 3^n)\\)</span>。</p>\n",
            "tags": [
                "计数"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20250407/",
            "url": "https://xsc062.netlify.app/20250407/",
            "title": "杂题选谈：组合计数",
            "date_published": "2025-04-07T06:57:14.000Z",
            "content_html": "<p>毅毅：统计不是数学（断章取义 ed）。<del>故删掉了数学标签。</del> 其实并没有。</p>\n<span id=\"more\"></span>\n<hr />\n<h2 id=\"a.-二分图染色\">A. 二分图染色</h2>\n<p><a href=\"https://www.becoder.com.cn/contest/6181/problem/1\" class=\"uri\">https://www.becoder.com.cn/contest/6181/problem/1</a></p>\n<p>首先只看红色。显然一个左部点最多只能用红边连接一个右部点，反之同理。把左部点视为下标，其用红边相连的右部点视为值，则一个合法的方案为 <span class=\"math inline\">\\(n\\)</span> 的只保留一部分元素的排列。显然为 <span class=\"math inline\">\\(f(n)=\\sum\\limits_{i=0}^nC_n^i\\cdot A_n^i\\)</span>。</p>\n<p>再加上蓝色，<span class=\"math inline\">\\(f^2(n)\\)</span> 会给一条边涂两种颜色，故钦定有两种颜色的边数，容斥得到 <span class=\"math inline\">\\(\\sum\\limits_{i=0}^n(-1)^i\\cdot C_n^i\\cdot A_n^i\\cdot f^2(n-i)\\)</span>。发现 <span class=\"math inline\">\\(f\\)</span> 的计算可能需要优化一下。考虑已经知道 <span class=\"math inline\">\\(f(n-1)\\)</span>，此时对于新增的第 <span class=\"math inline\">\\(n\\)</span> 对点：</p>\n<ol type=\"1\">\n<li>任意连边（显然两个当中只能有一个点发出边），共有 <span class=\"math inline\">\\(2n-1\\)</span> 种方案，因为 <span class=\"math inline\">\\((n, n)\\)</span> 会被算重。</li>\n<li>不连，共 <span class=\"math inline\">\\(1\\)</span> 种方案。</li>\n<li>发现 1 中可能连到已经有连边的点上了，新边的目的地有 <span class=\"math inline\">\\(n-1\\)</span> 个选项，目的地原本连接的点也有 <span class=\"math inline\">\\(n-1\\)</span> 个选项，去掉两边共 <span class=\"math inline\">\\(4\\)</span> 个点，非法的即为 <span class=\"math inline\">\\((n-1)^2\\cdot f(n-2)\\)</span>。</li>\n</ol>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 1e9 + 7;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;long long&gt; f(n + 1), fac(n + 1), inv(n + 1);\n    f[0] = 1ll, f[1] = 2ll;\n    fac[0] = 1ll, fac[1] = 1ll, inv[0] = 1ll;\n    for (int i = 2; i &lt;= n; ++i) &#123;\n        fac[i] = fac[i - 1] * i % mod;\n        f[i] = (f[i - 1] * 2 * i % mod + mod - f[i - 2] * (i - 1) % mod * (i - 1) % mod) % mod;\n    &#125;\n    auto qkp = [](long long x, int y) &#123;\n        auto res = 1ll;\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    inv[n] = qkp(fac[n], mod - 2);\n    for (int i = n - 1; i; --i)\n        inv[i] = inv[i + 1] * (i + 1) % mod;\n    auto C = [&amp;](int n, int m) &#123;\n        return fac[n] * inv[n - m] % mod * inv[m] % mod;\n    &#125;;\n    auto A = [&amp;](int n, int m) &#123;\n        return fac[n] * inv[n - m] % mod;\n    &#125;;\n    long long res = 0ll;\n    for (int i = 0, k = 1; i &lt;= n; ++i, k = mod - k)\n        (res += k * C(n, i) % mod * A(n, i) % mod * f[n - i] % mod * f[n - i]) %= mod;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"b.-七选五\">B. 七选五</h2>\n<p><a href=\"https://www.becoder.com.cn/contest/6181/problem/2\" class=\"uri\">https://www.becoder.com.cn/contest/6181/problem/2</a></p>\n<p>首先 <span class=\"math inline\">\\(p\\)</span> 固定，钦定有 <span class=\"math inline\">\\(x\\)</span> 个数相等，有 <span class=\"math inline\">\\(C_k^x\\)</span> 个方案，剩下的就是从 <span class=\"math inline\">\\(n-x\\)</span> 个元素里选出 <span class=\"math inline\">\\(k-x\\)</span> 个来错排，考虑钦定相同的个数来容斥：</p>\n<p><span class=\"math display\">\\[\n\\sum_{i=0}^{k-x}(-1)^i\\cdot C_{k-x}^i\\cdot A_{n-x-i}^{k-x-i}\n\\]</span></p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 1e9 + 7;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, k, x;\n    std::cin &gt;&gt; n &gt;&gt; k &gt;&gt; x;\n    std::vector&lt;long long&gt; fac(n + 1), inv(n + 1);\n    fac[0] = 1ll, fac[1] = 1ll, inv[0] = 1ll;\n    for (int i = 2; i &lt;= n; ++i)\n        fac[i] = fac[i - 1] * i % mod;\n    auto qkp = [](long long x, int y) &#123;\n        auto res = 1ll;\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    inv[n] = qkp(fac[n], mod - 2);\n    for (int i = n - 1; i; --i)\n        inv[i] = inv[i + 1] * (i + 1) % mod;\n    auto C = [&amp;](int n, int m) &#123;\n        return fac[n] * inv[n - m] % mod * inv[m] % mod;\n    &#125;;\n    auto A = [&amp;](int n, int m) &#123;\n        return fac[n] * inv[n - m] % mod;\n    &#125;;\n    long long res = C(k, x), sum = 0ll;\n    for (int i = 0, p = 1; i &lt;= k - x; ++i, p = mod - p)\n        (sum += p * C(k - x, i) % mod * A(n - x - i, k - x - i) % mod) %= mod;\n    std::cout &lt;&lt; res * sum % mod &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"d.-硬币购物\">D. 硬币购物</h2>\n<p><a href=\"https://www.becoder.com.cn/contest/6181/problem/4\" class=\"uri\">https://www.becoder.com.cn/contest/6181/problem/4</a></p>\n<p>每次多重背包会超时，考虑用钦定每种硬币是否超额来容斥。令 <span class=\"math inline\">\\(f_s\\)</span> 表示凑出 <span class=\"math inline\">\\(s\\)</span> 的方案数（完全背包），那么 <span class=\"math inline\">\\(f_{s-c_1\\times (d_1 + 1)}\\)</span> 就表示钦定第 1 种硬币超额时凑出 <span class=\"math inline\">\\(s\\)</span> 的方案数，以此类推。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int c[4], T, m = 1e5;\n    std::vector&lt;long long&gt; f(m + 1);\n    f[0] = 1;\n    for (int i = 0; i &lt; 4; ++i) &#123;\n        std::cin &gt;&gt; c[i];\n        for (int j = c[i]; j &lt;= m; ++j)\n            f[j] += f[j - c[i]];\n    &#125;\n    std::cin &gt;&gt; T;\n    for (int d[4], m; T--; ) &#123;\n        for (int i = 0; i &lt; 4; ++i)\n            std::cin &gt;&gt; d[i];\n        std::cin &gt;&gt; m;\n        long long res = 0ll;\n        for (int i = 0; i &lt; (1 &lt;&lt; 4); ++i) &#123;\n            int s = m;\n            for (int j = 0; j &lt; 4; ++j)\n                if ((i &gt;&gt; j) &amp; 1)\n                    s -= (d[j] + 1) * c[j];\n            if (s &gt;= 0) &#123;\n                int k = (__builtin_popcount(i) &amp; 1) ? -1 : 1;\n                res += k * f[s];\n            &#125;\n        &#125;\n        std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"e.-distinct-multiples\">E. Distinct Multiples</h2>\n<p><a href=\"https://www.becoder.com.cn/contest/6181/problem/5\" class=\"uri\">https://www.becoder.com.cn/contest/6181/problem/5</a></p>\n<p>推式子题。题意转化为，给定 <span class=\"math inline\">\\(n\\)</span> 个位置可选的值集合，要求任意两个位置值不等，问方案数。</p>\n<p>如果把两个位置取等视作在团上选中边，那么有朴素做法钦定选边的集合 <span class=\"math inline\">\\(S\\)</span> 然后容斥，考虑它们构成的连通块 <span class=\"math inline\">\\(\\{s\\} \\subseteq S\\)</span>，有 <span class=\"math inline\">\\(res=\\sum\\limits_{S\\subseteq V}(-1)^{|S|}\\cdot \\prod\\limits_{s_i} \\left\\lfloor \\frac m{\\operatorname{lcm} s_i} \\right\\rfloor\\)</span>。</p>\n<p>有个很神奇的操作是把 <span class=\"math inline\">\\(S\\)</span> 丢掉，直接枚举 <span class=\"math inline\">\\(\\{s\\}\\)</span> 尝试子集 DP。有：<span class=\"math inline\">\\(res=\\sum\\limits_{\\{s\\}}\\prod\\limits_s f(s)\\cdot\\left\\lfloor \\frac m{\\operatorname{lcm} s} \\right\\rfloor\\)</span>。其中 <span class=\"math inline\">\\(f(s)\\)</span> 表示选取一个 <span class=\"math inline\">\\(s\\)</span> 的导出子图的容斥系数之和，其中次数为导出子图中边数。</p>\n<p>怎么把 <span class=\"math inline\">\\(f\\)</span> 算出来呢？容易发现其值只与 <span class=\"math inline\">\\(|s|\\)</span> 有关，考虑钦定与 <span class=\"math inline\">\\(1\\)</span> 连通的点数容斥，则有：</p>\n<p><span class=\"math display\">\\[\nf(n)=\\sum\\limits_{i=0}^{n - 1} (-1)^i \\times C_{n-1}^{i-1} \\times f(i) \\cdot \\sum_{j=0}^{m\\gets i\\times (i-1)\\div 2} (-1)^j\\cdot C_m^j\n\\]</span></p>\n<p>我们知道，二项式定理取 <span class=\"math inline\">\\(a=1, b = -1\\)</span> 有 <span class=\"math inline\">\\(0^m=[m=0]=\\sum_{j=0}^m(-1)^j\\cdot C_m^j\\)</span>，代入得：</p>\n<p><span class=\"math display\">\\[\n\\begin{aligned}\nf(n)&amp;=\\sum\\limits_{i=0}^{n - 1} (-1)^i \\times C_{n-1}^{n-i-1} \\times f(n-i)\\cdot [m=0\\iff i=1]\\\\\n&amp;=(1 - n)\\cdot f(n-1)\n\\end{aligned}\n\\]</span></p>\n<p>然后就能线性求出。再用一个子集 DP，为了保证顺序枚举最小的未被确定的点所在连通块进行转移。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 998244353;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, l;\n    long long m;\n    std::cin &gt;&gt; n &gt;&gt; m, l = 1 &lt;&lt; n;\n    std::vector&lt;long long&gt; d(n), f(n + 1), dp(l), g(l);\n    f[1] = 1ll;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; d[i - 1];\n        if (i &gt;= 2)\n            f[i] = (1 + mod - i) * f[i - 1] % mod;\n        // printf(&quot;f[%d] = %lld\\n&quot;, i, f[i]);\n    &#125;\n    for (int i = 0; i &lt; l; ++i) &#123;\n        long long now = 1ll;\n        for (int j = 0; j &lt; n; ++j)\n            if ((i &gt;&gt; j) &amp; 1) &#123;\n                if (now / std::__gcd(now, d[j]) &gt; m / d[j])\n                    goto nosol;\n                now = now / std::__gcd(now, d[j]) * d[j];\n            &#125;\n        g[i] = (m / now) % mod;\n        // printf(&quot;lcm = %lld, g[%d] = %lld\\n&quot;, now, i, g[i]);\n    nosol: ;\n    &#125;\n    dp[0] = 1ll;\n    auto lowbit = [](int x) &#123;\n        return x &amp; -x;\n    &#125;;\n    for (int i = 1; i &lt; l; ++i) &#123;\n        int to = std::__lg(lowbit(i));\n        for (int j = i; j; j = (j - 1) &amp; i)\n            if ((j &gt;&gt; to) &amp; 1)\n                (dp[i] += dp[i ^ j] * f[__builtin_popcount(j)] % mod * g[j] % mod) %= mod;\n    &#125;\n    std::cout &lt;&lt; dp[l - 1] &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"f.-permutation\">F. Permutation</h2>\n<p><a href=\"https://www.becoder.com.cn/contest/6181/problem/6\" class=\"uri\">https://www.becoder.com.cn/contest/6181/problem/6</a></p>\n<p>如果全是 <code>&lt;</code>，方案数为 <span class=\"math inline\">\\(1\\)</span>。</p>\n<p>现在把其中一些 <code>&lt;</code> 变成 <code>?</code>，比如 <code>&lt;&lt;??&lt;?&lt;&lt;&lt;&lt;</code> 的方案数，<del>太好了是多重集排列，我们没救了</del> 显然被 <code>&lt;</code> 连接起来的一段元素只有一种排列方式，所以可以视为多重集排列，方案数为 <span class=\"math inline\">\\(\\dfrac {11!}{3!\\times 2!\\times 5!}\\)</span>。</p>\n<p>似乎只需要枚举把 <code>&gt;</code> 变成 <code>&lt;</code> 或 <code>=</code> 的 <span class=\"math inline\">\\(2^k\\)</span> 种情况再计算就可以了，可惜 <span class=\"math inline\">\\(k\\)</span> 有点大。但我们发现它在一定程度上是没有后效性的，比如 <code>&lt;&lt;??&lt;</code> 和 <code>&lt;&lt;?&lt;&lt;</code>，前面的 <code>&lt;&lt;</code> 不会对后面的内容带来影响。</p>\n<p>故令 <span class=\"math inline\">\\(f_i\\)</span> 表示对于前 <span class=\"math inline\">\\(i\\)</span> 个元素的方案数，枚举最后一个被钦定为 <code>?</code> 的 <code>&gt;</code> <span class=\"math inline\">\\(j\\)</span>（即 <span class=\"math inline\">\\([j + 1, i-1]\\)</span> 间的 <code>&gt;</code> 都被替换为 <code>&lt;</code>），带上容斥系数，有 <span class=\"math inline\">\\(f_i=\\sum\\limits_{s_j=\\texttt{&#39;&gt;&#39;}}(-1)^{cnt_\\texttt{&#39;&gt;&#39;}[j + 1, i - 1]}\\times f_j\\times\\dfrac1{(i-j)!}\\)</span>。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 1e9 + 7;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;long long&gt; fac(n + 1), inv(n + 1);\n    fac[0] = 1ll, inv[0] = 1ll;\n    for (int i = 1; i &lt;= n; ++i)\n        fac[i] = fac[i - 1] * i % mod;\n    auto qkp = [](long long x, int y) &#123;\n        auto res = 1ll;\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    inv[n] = qkp(fac[n], mod - 2);\n    for (int i = n - 1; i; --i)\n        inv[i] = inv[i + 1] * (i + 1) % mod;\n    std::vector&lt;char&gt; s(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; s[i];\n    std::vector&lt;long long&gt; f(n + 1);\n    s[0] = &#39;&gt;&#39;, f[0] = 1ll;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        int cnt = 0;\n        for (int j = i - 1; ~j; --j)\n            if (s[j] == &#39;&gt;&#39;) &#123;\n                long long k = (cnt &amp; 1) ? mod - 1 : 1;\n                (k *= f[j]) %= mod, (k *= inv[i - j]) %= mod;\n                (f[i] += k) %= mod;\n                ++cnt;\n            &#125;\n        // printf(&quot;f[%d] = %lld\\n&quot;, i, f[i]);\n    &#125;\n    std::cout &lt;&lt; f[n] * fac[n] % mod &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<p><em>忳郁邑余侘傺兮，余独穷困乎此时也。</em></p>\n<hr />\n<h2 id=\"h.-k-perm-counting\">H. ~K Perm Counting</h2>\n<p><a href=\"https://www.becoder.com.cn/contest/6181/problem/8\" class=\"uri\">https://www.becoder.com.cn/contest/6181/problem/8</a></p>\n<p>考虑钦定令几个元素不满足条件进行容斥，即答案为 <span class=\"math inline\">\\(\\sum\\limits_{i=0}^n (-1)^i\\cdot f(i)\\)</span>。但我们发现 <span class=\"math inline\">\\([n-k,n+k]\\)</span> 都有两个不能选的值，直接取 <span class=\"math inline\">\\(f(i)=\\prod 2\\)</span> 肯定会选到相同值，一个自然（？）的想法是再容斥一遍，可惜手玩一下发现似乎容不动。考虑把玩意儿拍在棋盘上：</p>\n<figure>\n<img src=\"1.png\" alt=\"以 k=2 为例\" /><figcaption>以 <span class=\"math inline\">\\(k=2\\)</span> 为例</figcaption>\n</figure>\n<p>其中 <span class=\"math inline\">\\(\\times\\)</span> 是非法格子，边是非法格子间的不同选关系，同颜色的边隶属同一条链。容易发现如果棋盘继续扩大，这些链还会继续延长。</p>\n<p>会发现这些链互不干扰，就是说我选了这条链上的某个点和链外的点没有任何关系（显然）。把这些链首尾相连拼起来，要做的就是拼接处可以选相邻，其余位置不能选相邻，选出来 <span class=\"math inline\">\\(i\\)</span> 个的方案数。提前预处理出来整个序列，令 <span class=\"math inline\">\\(tag_j\\)</span> 表示 <span class=\"math inline\">\\(j\\)</span> 是否能和 <span class=\"math inline\">\\(j-1\\)</span> 同选，设 <span class=\"math inline\">\\(dp_{j,i,0/1}\\)</span> 表示 DP 到了 <span class=\"math inline\">\\(j\\)</span>，已经选了 <span class=\"math inline\">\\(i\\)</span> 个数，第 <span class=\"math inline\">\\(j\\)</span> 个元素（不）选的方案数，那么有：</p>\n<p><span class=\"math display\">\\[\ndp_{j,i,0} = dp_{j - 1, i, 0} + dp_{j-1, i, 1}\\\\\ndp_{j,i,1} = \\begin{cases}\ndp_{j-1, i - 1, 1} + dp_{j-1,i - 1,0}&amp;tag_j=1\n\\\\\ndp_{j-1,i,0}&amp;\\text{otherwise}\n\\end{cases}\n\\]</span></p>\n<p>大力 DP 即可。<span class=\"math inline\">\\(f(i)\\)</span> 即为 <span class=\"math inline\">\\((n-i)!\\times (dp_{m, i, 0} + dp_{m, i, 1})\\)</span>，其中 <span class=\"math inline\">\\(m\\)</span> 为总链长。</p>\n<details>\n<p>注意不滚动可能会 MLE <img src=\"/em/kt.gif\" /></p>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 924844033;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, k;\n    std::cin &gt;&gt; n &gt;&gt; k;\n    std::vector&lt;int&gt; tag(1);\n    std::vector&lt;long long&gt; fac(n + 1);\n    std::vector&lt;std::vector&lt;int&gt; &gt; vis(n + 1, std::vector&lt;int&gt; (n + 1));\n    auto calc = [&amp;](int i, int j, int s) &#123;\n        tag.push_back(1);\n        for (; ; s ^= 1) &#123;\n            // printf(&quot;(%d, %d) &quot;, i, j);\n            vis[i][j] = 1;\n            if (!s) &#123;\n                i = j + k;\n                if (i &lt;= n)\n                    tag.push_back(0);\n                else\n                    break;\n            &#125;\n            else &#123;\n                j = i + k;\n                if (j &lt;= n)\n                    tag.push_back(0);\n                else\n                    break;\n            &#125;\n        &#125;\n        // puts(&quot;&quot;);\n        return;\n    &#125;;\n    fac[0] = 1ll;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        fac[i] = fac[i - 1] * i % mod;\n        int j = i - k;\n        if (j &gt;= 1 &amp;&amp; !vis[i][j])\n            calc(i, j, 1);\n        j = i + k;\n        if (j &lt;= n &amp;&amp; !vis[i][j])\n            calc(i, j, 0);\n    &#125;\n    int m = (int)tag.size() - 1;\n    // printf(&quot;m = %d\\n&quot;, m);\n    std::vector&lt;std::vector&lt;std::vector&lt;long long&gt; &gt; &gt; dp(2, std::vector&lt;std::vector&lt;long long&gt; &gt; (n + 1, std::vector&lt;long long&gt; (2)));\n    dp[0][0][0] = 1ll;\n    for (int j = 1, now = 1; j &lt;= m; ++j, now ^= 1) &#123;\n        for (int i = 0; i &lt;= n &amp;&amp; i &lt;= j; ++i) &#123;\n            dp[now][i][0] = dp[!now][i][0];\n            dp[now][i][1] = 0ll;\n            if (i) &#123;\n                (dp[now][i][0] += dp[!now][i][1]) %= mod;\n                dp[now][i][1] = dp[!now][i - 1][0];\n                if (tag[j]) &#123;\n                    (dp[now][i][1] += dp[!now][i - 1][1]) %= mod;\n                    // assert(0);\n                &#125;\n            &#125;\n            // printf(&quot;dp[%d][%d] = %lld / %lld\\n&quot;, j, i, dp[j][i][0], dp[j][i][1]);\n        &#125;\n    &#125;\n    long long res = 0ll;\n    for (int i = 0, p = 1; i &lt;= n; ++i, p = mod - p)\n        (res += p * fac[n - i] % mod * (dp[m &amp; 1][i][0] + dp[m &amp; 1][i][1]) % mod) %= mod;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"a---positions-in-permutations\">A - Positions in Permutations</h2>\n<p><a href=\"https://codeforces.com/problemset/problem/285/E\" class=\"uri\">https://codeforces.com/problemset/problem/285/E</a></p>\n<p><del>（看向上一题）这照片是你吗？</del></p>\n<p>在上一题的基础上，令 <span class=\"math inline\">\\(k=1\\)</span>。但是有个小小的问题——所求的「至少」不为 <span class=\"math inline\">\\(0\\)</span>，无法简单容斥。具体地，如果一个排列一共有 <span class=\"math inline\">\\(p\\)</span> 个非法排列，那么它会被 <span class=\"math inline\">\\(f(i)\\)</span> 统计 <span class=\"math inline\">\\(C_p^i\\)</span> 次。令 <span class=\"math inline\">\\(g(p)\\)</span> 表示非法格子数恰好为 <span class=\"math inline\">\\(p\\)</span> 的排列的真实数量，则 <span class=\"math inline\">\\(f(i)=\\sum\\limits_{j=i}^n C_j^i\\cdot g(j)\\)</span>，二项式反演即可得到真实值 <span class=\"math inline\">\\(g(m)=\\sum\\limits_{j=m}^n (-1)^{j-m}\\cdot C_j^m\\cdot f(j)\\)</span>。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 1e9 + 7;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, k;\n    std::cin &gt;&gt; n &gt;&gt; k;\n    std::vector&lt;int&gt; tag(1);\n    std::vector&lt;long long&gt; fac(n + 1), inv(n + 1);\n    std::vector&lt;std::vector&lt;int&gt; &gt; vis(n + 1, std::vector&lt;int&gt; (n + 1));\n    auto calc = [&amp;](int i, int j, int s) &#123;\n        tag.push_back(1);\n        for (; i &lt;= n &amp;&amp; j &lt;= n; s ^= 1) &#123;\n            vis[i][j] = 1;\n            if (!s) &#123;\n                i = j + 1;\n                if (i &lt;= n)\n                    tag.push_back(0);\n            &#125;\n            else &#123;\n                j = i + 1;\n                if (j &lt;= n)\n                    tag.push_back(0);\n            &#125;\n        &#125;\n        return;\n    &#125;;\n    auto qkp = [&amp;](long long x, int y) &#123;\n        auto res = 1ll;\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    fac[0] = 1ll, inv[0] = 1ll;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        fac[i] = fac[i - 1] * i % mod;\n        int j = i - 1;\n        if (j &gt;= 1 &amp;&amp; !vis[i][j])\n            calc(i, j, 1);\n        j = i + 1;\n        if (j &lt;= n &amp;&amp; !vis[i][j])\n            calc(i, j, 0);\n    &#125;\n    inv[n] = qkp(fac[n], mod - 2);\n    for (int i = n - 1; i; --i)\n        inv[i] = inv[i + 1] * (i + 1) % mod;\n    int m = (int)tag.size() - 1;\n    std::vector&lt;std::vector&lt;std::vector&lt;long long&gt; &gt; &gt; dp(2, std::vector&lt;std::vector&lt;long long&gt; &gt; (n + 1, std::vector&lt;long long&gt; (2)));\n    dp[0][0][0] = 1ll;\n    for (int j = 1, now = 1; j &lt;= m; ++j, now ^= 1) &#123;\n        for (int i = 0; i &lt;= n &amp;&amp; i &lt;= j; ++i) &#123;\n            dp[now][i][0] = dp[!now][i][0];\n            dp[now][i][1] = 0ll;\n            if (i) &#123;\n                (dp[now][i][0] += dp[!now][i][1]) %= mod;\n                dp[now][i][1] = dp[!now][i - 1][0];\n                if (tag[j])\n                    (dp[now][i][1] += dp[!now][i - 1][1]) %= mod;\n            &#125;\n        &#125;\n    &#125;\n    auto C = [&amp;](int n, int m) &#123;\n        return fac[n] * inv[n - m] % mod * inv[m] % mod;\n    &#125;;\n    long long res = 0ll;\n    for (int i = k, p = 1; i &lt;= n; ++i, p = mod - p) &#123;\n        // printf(&quot;%d: %lld\\n&quot;, i, C(i, k) * fac[n - i] % mod * (dp[m &amp; 1][i][0] + dp[m &amp; 1][i][1]) % mod);\n        (res += p * C(i, k) % mod * fac[n - i] % mod * (dp[m &amp; 1][i][0] + dp[m &amp; 1][i][1]) % mod) %= mod;\n    &#125;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"d---all-pairs-similarity-p\">D - All Pairs Similarity P</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P11458\" class=\"uri\">https://www.luogu.com.cn/problem/P11458</a></p>\n<p>省流：求 <span class=\"math inline\">\\(\\forall\\,i,f_i=\\sum\\limits_{j=1}^n \\dfrac{|a_i\\cap a_j|}{|a_i\\cup a_j|}\\)</span>。</p>\n<p>首先分离常数，有：</p>\n<p><span class=\"math display\">\\[\n\\begin{aligned}\nf_i&amp;=\\sum\\limits_{j=1}^n \\dfrac{|a_i\\cap a_j|}{|a_i\\cup a_j|}\\\\\n&amp;=\\sum_{j=1}^n\\dfrac {|a_i|+|a_j|-|a_i\\cup a_j|}{|a_i\\cup a_j|}\\\\\n&amp;=\\sum_{j=1}^n \\dfrac {|a_i|+|a_j|}{|a_i\\cup a_j|}-1\n\\end{aligned}\n\\]</span></p>\n<p>尽量把分子变得更简：</p>\n<p><span class=\"math display\">\\[\n\\begin{aligned}\nf_i&amp;=\\sum_{j=1}^n \\dfrac {|a_i|+|a_j|}{|a_i\\cup a_j|}-1\\\\\n&amp;=|a_i|\\cdot\\left(\\sum_{j=1}^n\\dfrac 1{|a_i\\cup a_j|}\\right)-n+\\sum_{j=1}^n \\dfrac {|a_j|}{|a_i\\cup a_j|}\n\\end{aligned}\n\\]</span></p>\n<p>问题转化为求解 <span class=\"math inline\">\\(\\sum\\limits_{j=1}^n\\dfrac 1{|a_i\\cup a_j|}\\)</span> 和 <span class=\"math inline\">\\(\\sum\\limits_{j=1}^n\\dfrac {|a_j|}{|a_i\\cup a_j|}\\)</span>，以 <span class=\"math inline\">\\(*=\\sum\\limits_{j=1}^n\\dfrac 1{|a_i\\cup a_j|}\\)</span> 为例。令 <span class=\"math inline\">\\(b_i\\)</span> 为 <span class=\"math inline\">\\(a_i\\)</span> 补集，则：</p>\n<p><span class=\"math display\">\\[\n\\begin{aligned}\n*&amp;=\\sum\\limits_{j=1}^n\\dfrac 1{|a_i\\cup a_j|}\\\\\n&amp;=\\sum_{j=1}^n\\dfrac 1{k-|b_i\\cap b_j|}\n\\end{aligned}\n\\]</span></p>\n<p>为什么要做这个转换呢？相比起并集运算，交集运算有着优秀的性质：<span class=\"math inline\">\\(s\\subseteq(b_i\\cap b_j)\\iff s\\subseteq b_i\\land s\\subseteq b_j\\)</span>，<del>直接取或当然也有相似的性质，但是太烧脑了</del>。</p>\n<p>基于这个性质，我们有一个想法：对于所有 <span class=\"math inline\">\\(j\\)</span>，在 <span class=\"math inline\">\\(\\forall \\, s\\subseteq b_j\\)</span> 处放置 <span class=\"math inline\">\\(\\dfrac 1{k-|s|}\\)</span> 的贡献；对于 <span class=\"math inline\">\\(i\\)</span>，将 <span class=\"math inline\">\\(\\forall \\, s\\subseteq b_i\\)</span> 处的贡献求和。但是这样肯定会拿到很多我们不想要的贡献，例如 <span class=\"math inline\">\\(\\forall \\, s\\subset (b_i\\cap b_j)\\)</span>。</p>\n<p>考虑精细布置贡献——构造 <span class=\"math inline\">\\(g(|s|)\\)</span> 满足 <span class=\"math inline\">\\(\\sum\\limits_{j=1}^n\\sum\\limits_{s\\subseteq b_j}g(|s|)=*\\)</span>。</p>\n<p>这里可以二项式反演得到 <span class=\"math inline\">\\(g\\)</span>，具体地，令 <span class=\"math inline\">\\(F(|S|)=\\dfrac 1{k-|S|}=\\sum\\limits_{s\\subseteq S}g(|s|)=\\sum\\limits_{j=0}^{|S|} C_{|S|}^j g(j)\\)</span>，则 <span class=\"math inline\">\\(g(i)=\\sum\\limits_{j=0}^iC_i^j\\cdot \\dfrac {(-1)^{i-j}}{k-j}\\)</span>。</p>\n<p>再令 <span class=\"math inline\">\\(h(s)=\\sum\\limits_{b_j\\supseteq s}g(|s|)=g(|s|)\\cdot \\sum\\limits_{b_j\\supseteq s}1\\)</span>，那么 <span class=\"math inline\">\\(h\\)</span> 就是高维后缀和。我们正在做的事情就是求解 <span class=\"math inline\">\\(*=\\sum\\limits_{s\\subseteq b_i}h(s)\\)</span>，这就又是一个高维前缀和了。</p>\n<p>对于 <span class=\"math inline\">\\(\\sum\\limits_{j=1}^n\\dfrac {|a_j|}{|a_i\\cup a_j|}\\)</span> 呢，令 <span class=\"math inline\">\\(h(s)=\\sum\\limits_{b_j\\supseteq s}g(|s|)\\cdot {\\color{red}{|a_j|}} = g(|s|) \\cdot \\sum\\limits_{b_j\\supseteq s} \\color{red}{k - |b_j|}\\)</span>，改变高维后缀和求和对象即可。</p>\n<p>复杂度就是 <span class=\"math inline\">\\(O(n+k\\cdot 2^k)\\)</span>，其中 <span class=\"math inline\">\\(k\\cdot 2^k\\)</span> 来自整体高维前 / 后缀和，<span class=\"math inline\">\\(n\\cdot k\\)</span> 来自枚举 <span class=\"math inline\">\\(i\\)</span>。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 1e9 + 7;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, k, l;\n    std::cin &gt;&gt; n &gt;&gt; k, l = 1 &lt;&lt; k;\n    std::vector&lt;int&gt; a(n + 1), b(n + 1), cnt(l);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; a[i], b[i] = (l - 1) ^ a[i];\n        ++cnt[b[i]];\n    &#125;\n    std::vector&lt;long long&gt; g(k + 1), fac(k + 1);\n    auto qkp = [&amp;](long long x, int y = mod - 2) &#123;\n        auto res = 1ll;\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    auto C = [&amp;](int n, int m) &#123;\n        return fac[n] * qkp(fac[n - m]) % mod * qkp(fac[m]) % mod;\n    &#125;;\n    fac[0] = 1ll;\n    for (int i = 1; i &lt;= k; ++i)\n        fac[i] = fac[i - 1] * i % mod;\n    for (int i = 0; i &lt;= k; ++i) &#123;\n        for (int j = 0, p = (i &amp; 1) ? mod - 1 : 1; j &lt;= i; ++j, p = mod - p)\n            (g[i] += C(i, j) * p % mod * qkp(k - j) % mod) %= mod;\n        // printf(&quot;g[%d] = %lld\\n&quot;, i, g[i]);\n    &#125;\n    // for (int i = 0; i &lt;= k; ++i) &#123;\n    //     long long F = 0ll;\n    //     for (int j = 0; j &lt;= i; ++j)\n    //         (F += C(i, j) * g[j] % mod) %= mod;\n    //     printf(&quot;%d: %lld / %lld\\n&quot;, i, F, qkp(k - i));\n    // &#125;\n    std::vector&lt;long long&gt; h(l);\n    std::copy(cnt.begin(), cnt.end(), h.begin());\n    for (int i = 0; i &lt; k; ++i)\n        for (int j = l - 1; ~j; --j)\n            if (!((j &gt;&gt; i) &amp; 1))\n                (h[j] += h[j ^ (1 &lt;&lt; i)]) %= mod;\n    auto f1(h);\n    for (int i = 0; i &lt; l; ++i)\n        (f1[i] *= g[__builtin_popcount(i)]) %= mod;\n    for (int i = 0; i &lt; k; ++i)\n        for (int j = 0; j &lt; l; ++j)\n            if ((j &gt;&gt; i) &amp; 1)\n                (f1[j] += f1[j ^ (1 &lt;&lt; i)]) %= mod;\n    for (int i = 0; i &lt; l; ++i)\n        h[i] = cnt[i] * (k - __builtin_popcount(i));\n    for (int i = 0; i &lt; k; ++i)\n        for (int j = l - 1; ~j; --j)\n            if (!((j &gt;&gt; i) &amp; 1))\n                (h[j] += h[j ^ (1 &lt;&lt; i)]) %= mod;\n    auto f2(h);\n    for (int i = 0; i &lt; l; ++i)\n        (f2[i] *= g[__builtin_popcount(i)]) %= mod;\n    for (int i = 0; i &lt; k; ++i)\n        for (int j = 0; j &lt; l; ++j)\n            if ((j &gt;&gt; i) &amp; 1)\n                (f2[j] += f2[j ^ (1 &lt;&lt; i)]) %= mod;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        // fprintf(stderr, &quot;%d: %d * %lld - %d + %lld\\n&quot;, i, __builtin_popcount(a[i]), f1[b[i]], n, f2[b[i]]);\n        std::cout &lt;&lt; (__builtin_popcount(a[i]) * f1[b[i]] % mod + mod - n + f2[b[i]]) % mod &lt;&lt; &#39;\\n&#39;;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"e---prefix-xors\">E - Prefix XORs</h2>\n<p><a href=\"https://atcoder.jp/contests/arc137/tasks/arc137_d\" class=\"uri\">https://atcoder.jp/contests/arc137/tasks/arc137_d</a></p>\n<p>省流：做 <span class=\"math inline\">\\(k\\)</span> 次前缀和，<span class=\"math inline\">\\(k=1,2,\\cdots,m\\)</span>，分别询问：令 <span class=\"math inline\">\\(x_i\\gets a_i\\)</span> 对 <span class=\"math inline\">\\(s_n\\)</span> 的贡献次数，则 <span class=\"math inline\">\\(\\sum a_i\\cdot (x_i\\bmod 2)\\)</span>？</p>\n<p>对于 <span class=\"math inline\">\\(a_p\\)</span>，容易发现第一轮其对任意 <span class=\"math inline\">\\(s_q\\)</span> 有 <span class=\"math inline\">\\(1\\)</span> 次贡献，拉开来就是常数列；第二轮有 <span class=\"math inline\">\\((q-p+1)\\)</span> 次贡献，是公差为 <span class=\"math inline\">\\(1\\)</span> 的等差数列；第三轮是类三角形数——至此，肯定和组合数有关了。手玩可以发现第 <span class=\"math inline\">\\(k\\)</span> 轮 <span class=\"math inline\">\\(a_p\\)</span> 对 <span class=\"math inline\">\\(s_n\\)</span> 的贡献为 <span class=\"math inline\">\\(C_{n-p+(k-2)}^{n-p}\\)</span>，尽量令其中一个不动，得到 <span class=\"math inline\">\\(C_{n-p+(k-2)}^{k-1}\\)</span>。</p>\n<p>但是我们发现直接枚举每轮每个数会起飞，而且模数为 <span class=\"math inline\">\\(2\\)</span> 似乎只能 Lucas（再带个 <span class=\"math inline\">\\(\\log\\)</span>），怎么办呢？</p>\n<p>那就 Lucas 呗。由其观察容易发现 <span class=\"math inline\">\\(C_{n-p+(k-2)}^{k-2}\\bmod2=1\\)</span> 当且仅当 <span class=\"math inline\">\\((k-2)\\subseteq (n-p+k-2)\\iff (k-2)\\subseteq \\complement_U(n-p)\\)</span>，故问题转化为高维后缀和，<del>当然你也可以做一次 and-FWT</del>，那么 <span class=\"math inline\">\\(res_k=\\sum (C_{n-p+(k-2)}^{k-2}\\bmod 2)\\cdot a_p=S_{k-2}\\)</span>，其中 <span class=\"math inline\">\\(S\\)</span> 为高维后缀和，初值为 <span class=\"math inline\">\\(S_{\\complement_u(n-i)}\\gets a_i\\)</span>。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, m, l, k;\n    std::cin &gt;&gt; n &gt;&gt; m, k = std::__lg(n + m) + 1, l = 1 &lt;&lt; k;\n    std::vector&lt;int&gt; s(l);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; s[l - 1 - (n - i)];\n    for (int i = 0; i &lt; k; ++i)\n        for (int j = l - 1; ~j; --j)\n            if (!((j &gt;&gt; i) &amp; 1))\n                s[j] ^= s[j ^ (1 &lt;&lt; i)];\n    for (int i = 1; i &lt;= m; ++i)\n        std::cout &lt;&lt; s[i - 1] &lt;&lt; &#39; &#39;;\n    std::cout &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"b---the-top-scorer\">B - The Top Scorer</h2>\n<p><a href=\"https://codeforces.com/problemset/problem/1096/E\" class=\"uri\">https://codeforces.com/problemset/problem/1096/E</a></p>\n<p>鉴于每种方案等概率（翻译没说，但原题面有提到），考虑计算小明能够取胜的方案数，再对总方案数做除法。先枚举最高分 <span class=\"math inline\">\\(k\\ge r\\)</span>，再枚举包括小明在内恰有 <span class=\"math inline\">\\(c\\ge 1\\)</span> 个人 拿到 <span class=\"math inline\">\\(k\\)</span> 分。但剩下的人呢？显然是不能插板随机分配的，因为存在 <span class=\"math inline\">\\(&lt;k\\)</span> 的限制。</p>\n<p>考虑容斥，钦定剩下的 <span class=\"math inline\">\\(p-c\\)</span> 个人中拿到 <span class=\"math inline\">\\(\\ge k\\)</span> 分的人数后再可空地插板即可，则总方案数为：</p>\n<p><span class=\"math display\">\\[\n\\sum_{k=r}^s\\sum_{c=1}^p\\dfrac {C_{p - 1}^{c-1}}c\\cdot \\sum_{i=0}^{p-c}C_{p-c}^i\\cdot C_{s-k\\cdot (c+i)+(p-c-1)}^{p-c-1}\n\\]</span></p>\n<p>其中分母上的 <span class=\"math inline\">\\(c\\)</span> 来源于等概率分配给最高分，虽然不是整数，但也代表着「小明获胜可行方案数」。最后将答案除上总方案数 <span class=\"math inline\">\\(C_{s-r+p-1}^{p-1}\\)</span> 即可。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 998244353;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int p, s, r;\n    std::cin &gt;&gt; p &gt;&gt; s &gt;&gt; r;\n    std::vector&lt;long long&gt; fac(s + p), inv(s + p);\n    fac[0] = inv[0] = 1ll;\n    for (int i = 1; i &lt; s + p; ++i) &#123;\n        fac[i] = fac[i - 1] * i % mod;\n    &#125;\n    auto qkp = [&amp;](long long x, int y) &#123;\n        auto res = 1ll;\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    inv.back() = qkp(fac.back(), mod - 2);\n    for (int i = s + p - 2; i &gt; 0; --i)\n        inv[i] = inv[i + 1] * (i + 1) % mod;\n    auto C = [&amp;](int n, int m) &#123;\n        if (n == -1 &amp;&amp; m == -1)\n            return 1ll;\n        return fac[n] * inv[n - m] % mod * inv[m] % mod;\n    &#125;;\n    auto res(0ll);\n    for (int k = r; k &lt;= s; ++k)\n        for (int c = 1; c &lt;= p; ++c)\n            if ((p - c) * (k - 1) + c * k &gt;= s) &#123;\n                auto t(0ll);\n                for (int i = 0, now = 1; i &lt;= p - c &amp;&amp; k * (c + i) &lt;= s; ++i, now = mod - now)\n                    (t += now * C(p - c, i) % mod * C(s - k * (c + i) + (p - c - 1), p - c - 1) % mod) %= mod;\n                (res += C(p - 1, c - 1) * qkp(c, mod - 2) % mod * t % mod) %= mod;\n            &#125;\n    std::cout &lt;&lt; res * qkp(C(s - r + p - 1, p - 1), mod - 2) % mod &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"c---sky-full-of-stars\">C - Sky Full of Stars</h2>\n<p><a href=\"https://codeforces.com/problemset/problem/997/C\" class=\"uri\">https://codeforces.com/problemset/problem/997/C</a></p>\n<p>发现用 <span class=\"math inline\">\\(3^{n\\times n}\\)</span> 减去任意一行一列不同色的方案就是答案。</p>\n<p>考虑一元容斥，如令 <span class=\"math inline\">\\(f_i\\)</span> 表示至少 <span class=\"math inline\">\\(i\\)</span> 行 <span class=\"math inline\">\\(i\\)</span> 列同色的方案，但会发现 <span class=\"math inline\">\\(f_0\\)</span> 中包含 <span class=\"math inline\">\\(0\\)</span> 行 <span class=\"math inline\">\\(1\\)</span> 列同色等与预期不符的情况。受此启发考虑令 <span class=\"math inline\">\\(f_{i,j}\\)</span> 表示至少 <span class=\"math inline\">\\(i\\)</span> 行 <span class=\"math inline\">\\(j\\)</span> 列同色进行二元容斥。容易发现当 <span class=\"math inline\">\\(i\\times j\\ne 0\\)</span> 时，被选中的 <span class=\"math inline\">\\(i\\)</span> 行 <span class=\"math inline\">\\(j\\)</span> 列全部连通，应为同一种颜色；将它们挪到角落，可以发现未被选中的格子共有 <span class=\"math inline\">\\((n-i)\\times (n-j)\\)</span> 个。故有：</p>\n<p><span class=\"math display\">\\[\nf_{i,j}=\\begin{cases}\nC_n^j\\times 3^j\\times 3^{n\\times(n - j)}&amp;i=0\\\\\nC_n^i\\times 3^i\\times 3^{n\\times(n-i)}&amp;j=0\\\\\nC_n^i\\times C_n^j\\times 3\\times 3^{(n-i)\\times (n-j)}&amp;\\text{otherwise}\n\\end{cases}\n\\]</span></p>\n<p>令 <span class=\"math inline\">\\(g_{i,j}\\)</span> 表示恰好 <span class=\"math inline\">\\(i\\)</span> 行 <span class=\"math inline\">\\(j\\)</span> 列同色的方案数，那么答案为 <span class=\"math inline\">\\(3^{n\\times n}-g_{0,0}\\)</span>。二项式反演 / 容斥原理得 <span class=\"math inline\">\\(g_{0,0}=\\sum\\limits_{i=0}^n\\sum\\limits_{j=0}^n (-1)^{i+j}\\cdot f_{i,j}\\)</span>。很惊讶地发现这是 <span class=\"math inline\">\\(O(n^2)\\)</span> 的！考虑优化。把 <span class=\"math inline\">\\(f_{1\\to n,1\\to n}\\)</span> 合并同类项，得到：</p>\n<p><span class=\"math display\">\\[\n\\begin{aligned}\ng_{0, 0}\n&amp;=\\left[\\sum_{j=0}^n (-1)^j\\cdot f_{0,j}\\right]+\\sum_{i=1}^n (-1)^i\\cdot f_{i,0}+\\sum_{j=1}^n (-1)^{i+j}\\cdot C_n^i\\times C_n^j\\times 3^{(n-i)\\times (n-j)+1}\\\\\n&amp;=\\left[\\sum_{j=0}^n (-1)^j\\cdot f_{0,j}\\right]+\\sum_{i=1}^n (-1)^i\\cdot f_{i,0}+(-1)^i\\cdot C_n^i\\times 3^{n^2-n\\times i+1}\\times\\sum_{j=1}^n (-1)^j\\cdot C_n^j\\times 3^{j\\times(-n+i)}\\\\\n&amp;=\\left[\\sum_{j=0}^n (-1)^j\\cdot f_{0,j}\\right]+\\sum_{i=1}^n (-1)^i\\cdot f_{i,0}+(-1)^i\\cdot C_n^i\\times 3^{n^2-n\\times i+1}\\times\\left[\\left(\\sum_{j=0}^n (-1)^j\\cdot C_n^j\\times (3^{-n+i})^j\\right)-1\\right]\\\\\n&amp;=\\left[\\sum_{j=0}^n (-1)^j\\cdot f_{0,j}\\right]+\\sum_{i=1}^n (-1)^i\\cdot f_{i,0}+(-1)^i\\cdot C_n^i\\times 3^{n^2-n\\times i+1}\\times\\left[(-3^{-n+i}+1)^n-1\\right]\n\\end{aligned}\n\\]</span></p>\n<p>由此便可 <span class=\"math inline\">\\(O(n\\log n)\\)</span> 计算。担心超时可以把所有 <span class=\"math inline\">\\(3^{-n+i}\\)</span> 和 <span class=\"math inline\">\\(3^{n\\times i}\\)</span> 线性预处理出来，复杂度不会变就是了。</p>\n<p>这里解释一下最后一步的二项式定理，非常遗憾地发现 <span class=\"math inline\">\\(-1\\)</span> 和 <span class=\"math inline\">\\(3^{-n+i}\\)</span> 都是 <span class=\"math inline\">\\(j\\)</span> 次的，没办法把二者相加减做二项式定理；但由于次数相同，这提示我们可以把 <span class=\"math inline\">\\(-1\\)</span> 乘到 <span class=\"math inline\">\\(3^{-n+i}\\)</span> 里去，给每一项配上 <span class=\"math inline\">\\(1^{n-k}\\)</span> 就可以做 <span class=\"math inline\">\\(-3^{n-i}\\)</span>（注意不是 <span class=\"math inline\">\\((-3)^{n-i}\\)</span>） 和 <span class=\"math inline\">\\(1\\)</span> 的二项式定理。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 998244353;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    long long n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;long long&gt; fac(n + 1), inv(n + 1), invn(n + 1), invi(n + 1), powi(n + 1), pown(n + 1);\n    auto qkp = [&amp;](long long x, long long y) &#123;\n        auto res(1ll);\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    const long long pnn = qkp(3ll, n * n), pn = qkp(3ll, n);\n    fac[0] = inv[0] = invn[0] = invi[0] = powi[0] = pown[0] = 1ll;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        fac[i] = fac[i - 1] * i % mod;\n        powi[i] = powi[i - 1] * 3 % mod;\n        pown[i] = pown[i - 1] * pn % mod;\n    &#125;\n    inv[n] = qkp(fac[n], mod - 2);\n    invi[n] = qkp(powi[n], mod - 2);\n    invn[n] = qkp(pown[n], mod - 2);\n    for (int i = n - 1; i; --i) &#123;\n        inv[i] = inv[i + 1] * (i + 1) % mod;\n        invi[i] = invi[i + 1] * 3 % mod;\n        invn[i] = invn[i + 1] * pn % mod;\n    &#125;\n    auto C = [&amp;](int n, int m) &#123;\n        return fac[n] * inv[n - m] % mod * inv[m] % mod;\n    &#125;;\n    long long g = 0ll;\n    auto f = [&amp;](int i, int j) &#123; // make sure (!i || !j)\n        if (i == 0 &amp;&amp; j == 0)\n            return pnn;\n        else if (i == 0)\n            return C(n, j) * powi[j] % mod * pown[n - j] % mod;\n        return C(n, i) * powi[i] % mod * pown[n - i] % mod;\n    &#125;;\n    for (int j = 0, p = 1; j &lt;= n; ++j, p = mod - p)\n        (g += p * f(0, j)) %= mod;\n    for (int i = 1, p = mod - 1; i &lt;= n; ++i, p = mod - p)\n        (g += p * f(i, 0) % mod + p * C(n, i) % mod * pnn % mod * invn[i] % mod * 3 % mod * (qkp(mod - invi[n - i] + 1, n) + mod - 1) % mod) %= mod;\n    std::cout &lt;&lt; (pnn + mod - g) % mod &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"d---去-m-nom\">D - 去 M / NoM</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P11316\" class=\"uri\">https://www.luogu.com.cn/problem/P11316</a></p>\n<p>假设 <span class=\"math inline\">\\(f(i)\\)</span> 为至少有 <span class=\"math inline\">\\(i\\)</span> 对不合法元素的方案数，则容斥得到答案 <span class=\"math inline\">\\(\\sum\\limits_{i=0}^n (-1)^i\\cdot f(i)\\)</span>。考虑怎么计算 <span class=\"math inline\">\\(f(i)\\)</span>。</p>\n<p><mark><span class=\"math inline\">\\(M\\)</span> 整除 <span class=\"math inline\">\\(dis(x, y) \\iff (pos_x - pos_y)\\bmod M=0\\iff pos_x\\equiv pos_y\\pmod M\\)</span>。</mark></p>\n<p>考虑把关于 <span class=\"math inline\">\\(M\\)</span> 同余的位置放在一个组，也就是说需要让一对元素不能选同一组的位置。</p>\n<p>考虑容斥，令 <span class=\"math inline\">\\(f(i)\\)</span> 表示至少有 <span class=\"math inline\">\\(i\\)</span> 对点选到一组的方案数，考虑怎么计算。假设我们要在第 <span class=\"math inline\">\\(k\\)</span> 组（size 为 <span class=\"math inline\">\\(s_k\\)</span>）中选出 <span class=\"math inline\">\\(x\\)</span> 对位置，实际上只需要选择 <span class=\"math inline\">\\(2x\\)</span> 个位置然后任意分配给这 <span class=\"math inline\">\\(x\\)</span> 对数，即 <span class=\"math inline\">\\(A_{s_k}^{2x}\\)</span>。设 <span class=\"math inline\">\\(dp_{i, j}\\)</span> 表示 DP 到第 <span class=\"math inline\">\\(i\\)</span> 个组，已经选了 <span class=\"math inline\">\\(j\\)</span> 对，那么有 <span class=\"math inline\">\\(dp_{i,j}=\\sum\\limits_{k=0}^jC_{n-(j - k)}^{j-k}\\times dp_{i-1,j-k}\\times A_{s_i}^{2k}\\)</span>。乍一看好像是 <span class=\"math inline\">\\(O(n^3)\\)</span> 的，但是别忘了 <span class=\"math inline\">\\(\\sum s_i=2n\\)</span>，所以只有 <span class=\"math inline\">\\(O(n^2)\\)</span>。<span class=\"math inline\">\\(f(i)\\)</span> 即为 <span class=\"math inline\">\\(dp_{m,i}\\times (2n-2i)!\\)</span>。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 1e9 + 7;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, m;\n    std::cin &gt;&gt; n &gt;&gt; m;\n    std::vector&lt;int&gt; s(m + 1);\n    std::vector&lt;long long&gt; fac(2 * n + 1), inv(2 * n + 1);\n    fac[0] = inv[0] = 1ll;\n    for (int i = 1; i &lt;= 2 * n; ++i)\n        ++s[i % m + 1], fac[i] = fac[i - 1] * i % mod;\n    auto qkp = [](long long x, int y) &#123;\n        auto res = 1ll;\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    inv[2 * n] = qkp(fac[2 * n], mod - 2);\n    for (int i = 2 * n - 1; i; --i)\n        inv[i] = inv[i + 1] * (i + 1) % mod;\n    auto A = [&amp;](int n, int m) &#123;\n        return fac[n] * inv[n - m] % mod;\n    &#125;;\n    auto C = [&amp;](int n, int m) &#123;\n        return fac[n] * inv[n - m] % mod * inv[m] % mod;\n    &#125;;\n    std::vector&lt;std::vector&lt;long long&gt; &gt; dp(m + 1, std::vector&lt;long long&gt; (n + 1));\n    dp[0][0] = 1ll;\n    for (int i = 1; i &lt;= m; ++i)\n        for (int j = 0; j &lt;= n; ++j) &#123;\n            for (int k = 0; k &lt;= j &amp;&amp; 2 * k &lt;= s[i]; ++k)\n                (dp[i][j] += C(n - (j - k), k) * dp[i - 1][j - k] % mod * A(s[i], 2 * k) % mod) %= mod;\n            // printf(&quot;s = %d, dp[%d][%d] = %lld\\n&quot;, s[i], i, j, dp[i][j]);\n        &#125;\n    long long res = 0ll;\n    for (int i = 0, p = 1; i &lt;= n; ++i, p = mod - p)\n        (res += p * dp[m][i] % mod * fac[2 * n - 2 * i] % mod) %= mod;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"e---kdoi-11彩灯晚会\">E - 「KDOI-11」彩灯晚会</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P11292\" class=\"uri\">https://www.luogu.com.cn/problem/P11292</a></p>\n<p>考虑 <span class=\"math inline\">\\({cnt_i}^2\\)</span> 的含义，即在所有颜色为 <span class=\"math inline\">\\(i\\)</span>、长度为 <span class=\"math inline\">\\(l\\)</span> 的链中有放回地选两次的方案数。</p>\n<p>显然复杂度里是不能包含 <span class=\"math inline\">\\(k\\)</span> 的，所以放弃直接统计 <span class=\"math inline\">\\(cnt_i\\)</span> 的想法。显然每种颜色是等价的，考虑计算选择两条链可以给答案带来的贡献：答案的形式是个和式；对于两条同色链 <span class=\"math inline\">\\(p,q\\)</span>，假设颜色为 <span class=\"math inline\">\\(i\\)</span>，那么会对 <span class=\"math inline\">\\({cnt_i}^2\\)</span> 带来 <span class=\"math inline\">\\(k^{n-2l-|p\\cap q|}\\)</span> 的贡献，对总答案带来 <span class=\"math inline\">\\(k^{n-2l-|p\\cap q| + 1}\\)</span> 的贡献。</p>\n<p>然而如果要枚举计算 <span class=\"math inline\">\\(|p\\cap q|\\)</span> 就无法避免 <span class=\"math inline\">\\(O(n^5)\\)</span>，考虑更有潜力的方法：将问题转化为对于每个 <span class=\"math inline\">\\(x\\)</span>，求交集大小恰好为 <span class=\"math inline\">\\(x\\)</span> 的链对个数。然而「恰好」是不方便计算的——假如当前两链在 <span class=\"math inline\">\\(u\\)</span> 次重合，如果假设下一次在 <span class=\"math inline\">\\(v\\)</span> 次重合，就需要保证在 <span class=\"math inline\">\\(u,v\\)</span> 之间不能重合——这并不好操作。二项式反演将恰好转化为至少，则限制减弱。</p>\n<p>令 <span class=\"math inline\">\\(f_{u,c,l_1,l_2}\\)</span> 表示 <span class=\"math inline\">\\(p,q\\)</span> 当前在 <span class=\"math inline\">\\(u\\)</span> 处重合，视野内的 <span class=\"math inline\">\\(p,q\\)</span> 长度为 <span class=\"math inline\">\\(l_1,l_2\\)</span>，至少已经重合了 <span class=\"math inline\">\\(c\\)</span> 次的方案数。预处理出走到 <span class=\"math inline\">\\(u\\)</span> 步数为 <span class=\"math inline\">\\(l_1,l_2\\)</span> 的方案数为初始值。枚举可能的后续重合点 <span class=\"math inline\">\\(v\\)</span>（满足 <span class=\"math inline\">\\(v\\)</span> 的拓扑序 <span class=\"math inline\">\\(&gt;u\\)</span>）有 <span class=\"math inline\">\\(f_{v,c+1,l_1&#39;,l_2&#39;}\\gets f_{v,c+1,l_1&#39;,l_2&#39;} + f_{u,c,l_1,l_2}\\)</span>。预处理出 <span class=\"math inline\">\\(u\\to v\\)</span> 长度为 <span class=\"math inline\">\\(\\Delta\\)</span> 的方案数（这是 <span class=\"math inline\">\\(O(n^3l)\\)</span> 的）优化转移，在算出 <span class=\"math inline\">\\(nex_{u,l}\\)</span> 表示从 <span class=\"math inline\">\\(u\\)</span> 出发走 <span class=\"math inline\">\\(l\\)</span> 步的方案数处理答案，则 <span class=\"math inline\">\\(F(i)=\\sum_{u,l_1,l_2}f_{u,l_1,l_2}\\cdot nex_{u,l-l_1}\\cdot nex_{u,l-l_2}\\)</span>，枚举 <span class=\"math inline\">\\(u,c,l_1,l_2,v,l_1&#39;,l_2&#39;\\)</span>，就可以达到优秀的 <span class=\"math inline\">\\(O(n^2l^5+n^3l)\\)</span>！简直是令人震撼 <img src=\"/em/kt.gif\" /></p>\n<p>给出第一个优化：发现 <span class=\"math inline\">\\(l_1\\)</span> 和 <span class=\"math inline\">\\(l_2\\)</span> 的转移彼此不干扰，考虑建立一个临时数组 <span class=\"math inline\">\\(g\\)</span>，先从 <span class=\"math inline\">\\(f_u,c\\)</span> 转移 <span class=\"math inline\">\\(l_1\\)</span> 到 <span class=\"math inline\">\\(g\\)</span>，再从 <span class=\"math inline\">\\(g\\)</span> 转移 <span class=\"math inline\">\\(l_2\\)</span> 到 <span class=\"math inline\">\\(f_{v,c+1}\\)</span>，则复杂度降为 <span class=\"math inline\">\\(O(n^2l^4+n^3l)\\)</span>，仍不足以通过。</p>\n<p>DP 过程上的优化已经万策尽，考虑从式子本身消元减少 DP 维度入手。令 <span class=\"math inline\">\\(h(i)\\)</span> 表示交集大小恰好恰好为 <span class=\"math inline\">\\(i\\)</span> 的方案数，则此时答案式为 <span class=\"math inline\">\\(\\sum\\limits_{i=0}^l k^{n-2l+i+1}\\times h(i)\\)</span>。又 <span class=\"math inline\">\\(F(i)=\\sum\\limits_{j=i}^lC_j^i\\cdot h(j)\\)</span>，二项式反演得：</p>\n<p><span class=\"math display\">\\[\n\\begin{aligned}\nres&amp;=\\sum\\limits_{i=0}^lk^{n-2l+i+1}\\cdot \\sum_{j=i}^l(-1)^{j-i}\\cdot C_j^i\\cdot F(j)\\\\\n&amp;=k^{n-2l+1}\\cdot\\sum_{j=0}^l \\sum_{i=0}^j k^i\\cdot (-1)^{j-i}\\cdot C_j^i\\cdot F(j)\\\\\n&amp;=k^{n-2l+1}\\cdot \\sum_{j=0}^l (k-1)^j\\cdot F(j)\n\\end{aligned}\n\\]</span></p>\n<p><mark>注意这里利用了二项式反演的系数可以和交换求和顺序后的 <span class=\"math inline\">\\(i\\)</span> 次项（或 <span class=\"math inline\">\\(j-i\\)</span> 次项，参见 <a href=\"#c---sky-full-of-stars\">Sky Full of Stars 中最后一步的处理</a>）组成二项式定理的特点</mark>，以便基于式子结构尽可能消元。</p>\n<p>那么此时答案式已经和 <span class=\"math inline\">\\(c\\)</span> 无关，可以丢掉 <span class=\"math inline\">\\(c\\)</span> 这一维，和 <span class=\"math inline\">\\(c\\)</span> 有关的计算已经在转移时处理了。则 <span class=\"math inline\">\\(f_{v,l_1&#39;,l_2&#39;}=\\sum f_{u,l_1,l_2}\\times (k-1)\\)</span>，复杂度降为 <span class=\"math inline\">\\(O(n^2l^3+n^3l)\\)</span>。</p>\n<details>\n<p>记得还要算上 <span class=\"math inline\">\\(F(0)\\)</span>，即任选一条合法链的方案数平方。</p>\n<pre class=\"cpp\"><code>// 兄弟你好香\n// 兄弟你是依托打分，我踏马吃吃吃吃吃\n#include &lt;bits/stdc++.h&gt;\nconst int mod = 998244353;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;party3.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    using arr = std::vector&lt;long long&gt;;\n    using arrr = std::vector&lt;arr&gt;;\n    using arrrr = std::vector&lt;arrr&gt;;\n    int n, k, l, m;\n    std::cin &gt;&gt; n, std::cin &gt;&gt; n &gt;&gt; k &gt;&gt; l &gt;&gt; m;\n    std::vector&lt;int&gt; deg(n + 1), id;\n    std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; g(n + 1);\n    for (int x, y, c; m--; ) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y &gt;&gt; c;\n        ++deg[y], g[x].emplace_back(y, c);\n    &#125;\n    arrrr to(n + 1, arrr(n + 1, arr(l + 1)));\n    arrr pre(n + 1, arr(l + 1)), nex(n + 1, arr(l + 1));\n    &#123;\n        std::queue&lt;int&gt; q;\n        for (int i = 1; i &lt;= n; ++i)\n            if (!deg[i])\n                q.push(i);\n        for (int u; !q.empty(); ) &#123;\n            u = q.front(), q.pop();\n            to[u][u][0] = 1ll, id.push_back(u);\n            for (auto i : id)\n                for (int j = 0; j &lt;= l; ++j) &#123;\n                    (pre[u][j] += to[i][u][j]) %= mod;\n                    // printf(&quot;to[%d][%d][%d] = %lld\\n&quot;, i, u, j, to[i][u][j]);\n                &#125;\n            // for (int j = 0; j &lt;= l; ++j)\n            //     printf(&quot;pre[%d][%d] = %lld\\n&quot;, u, j, pre[u][j]);\n            for (auto [v, c] : g[u]) &#123;\n                for (auto i : id)\n                    for (int j = 1; j &lt;= l; ++j)\n                        (to[i][v][j] += to[i][u][j - 1] * c) %= mod;\n                if (!--deg[v])\n                    q.push(v);\n            &#125;\n        &#125;\n        for (int u = 1; u &lt;= n; ++u)\n            for (int v = 1; v &lt;= n; ++v)\n                for (int i = 0; i &lt;= l; ++i)\n                    (nex[u][i] += to[u][v][i]) %= mod;\n    &#125;\n    arrrr f(n + 1, arrr(l + 1, arr(l + 1)));\n    &#123;\n        for (int i = 1; i &lt;= n; ++i)\n            for (int l1 = 1; l1 &lt;= l; ++l1)\n                for (int l2 = 1; l2 &lt;= l; ++l2)\n                    f[i][l1][l2] = pre[i][l1 - 1] * pre[i][l2 - 1] % mod * (k - 1) % mod;\n        for (auto i = 0; i &lt; n; ++i) &#123;\n            int u = id[i];\n            // for (int l1 = 1; l1 &lt;= l; ++l1)\n            //     for (int l2 = 1; l2 &lt;= l; ++l2)\n            //         printf(&quot;f[%d][%d][%d] = %lld\\n&quot;, u, l1, l2, f[u][l1][l2]);\n            for (auto j = i + 1; j &lt; n; ++j) &#123;\n                arrr g(l + 1, arr(l + 1));\n                int v = id[j];\n                for (int l1 = 1; l1 &lt; l; ++l1)\n                    for (int _l1 = l1 + 1; _l1 &lt;= l; ++_l1) &#123;\n                        auto K = to[u][v][_l1 - l1];\n                        if (K)\n                            for (int l2 = 1; l2 &lt; l; ++l2)\n                                (g[_l1][l2] += f[u][l1][l2] * K) %= mod;\n                    &#125;\n                for (int _l1 = 2; _l1 &lt;= l; ++_l1)\n                    for (int l2 = 1; l2 &lt; l; ++l2)\n                        if (g[_l1][l2])\n                            for (int _l2 = l2 + 1; _l2 &lt;= l; ++_l2)\n                                (f[v][_l1][_l2] += g[_l1][l2] * to[u][v][_l2 - l2] % mod * (k - 1)) %= mod; \n            &#125;\n        &#125;\n    &#125;\n    auto qkp = [](long long x, int y) &#123;\n        auto res(1ll);\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    auto res(0ll);\n    for (int u = 1; u &lt;= n; ++u)\n        for (int v = 1; v &lt;= n; ++v)\n            (res += to[u][v][l - 1]) %= mod;\n    (res *= res) %= mod;\n    for (int u = 1; u &lt;= n; ++u)\n        for (int l1 = 1; l1 &lt;= l; ++l1)\n            for (int l2 = 1; l2 &lt;= l; ++l2)\n                (res += f[u][l1][l2] * nex[u][l - l1] % mod * nex[u][l - l2] % mod) %= mod;\n    res = res % mod * (qkp(k, n + 1) * qkp(qkp(k, 2 * l), mod - 2) % mod) % mod;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"g---小星星\">G - 小星星</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P3349\" class=\"uri\">https://www.luogu.com.cn/problem/P3349</a></p>\n<p>首先考虑比较暴力的做法，那么有 <span class=\"math inline\">\\(f_{i,j,S}\\)</span> 表示在 <span class=\"math inline\">\\(i\\)</span> 这个子树里面选了集合 <span class=\"math inline\">\\(S\\)</span>，且 <span class=\"math inline\">\\(i\\)</span> 的颜色为 <span class=\"math inline\">\\(j\\)</span> 的方案数，维数里之所以有 <span class=\"math inline\">\\(j\\)</span> 是为了满足连边限制。</p>\n<p>然后树上子集 DP，发现是 <span class=\"math inline\">\\(O(n^4\\cdot 2^n)\\)</span> 的，</p>\n<hr />\n<h2 id=\"cf785d-anton-and-school---2\">CF785D Anton and School - 2</h2>\n<p><a href=\"https://codeforces.com/problemset/problem/785/D\" class=\"uri\">https://codeforces.com/problemset/problem/785/D</a></p>\n<p>容易想到枚举每个 <code>(</code> 作为分界点的情况，那么钦定当前枚举的 <code>(</code> 是要选的。对于当前 <code>(</code>，若其左边（不含）的 <code>(</code> 有 <span class=\"math inline\">\\(n\\)</span> 个而右边的 <code>)</code> 有 <span class=\"math inline\">\\(m\\)</span> 个，枚举除了当前 <code>(</code> 还要选 <span class=\"math inline\">\\(i\\)</span> 个 <code>(</code>，那么答案为 <span class=\"math inline\">\\(\\sum_{i=0}C_n^{i-1}\\cdot C_m^i\\)</span>。</p>\n<p>发现这个形式可以范德蒙德卷积：<span class=\"math inline\">\\(\\sum_{i=0}C_n^{i-1}\\cdot C_m^i=\\sum_{i=0}C_n^{n-i+1}\\cdot C_m^i=C_{n+m}^{n+1}\\)</span>。</p>\n<p>关于怎么记忆范德蒙德卷积，发现上下相加，也可以从组合意义记忆：在 <span class=\"math inline\">\\(n\\)</span> 个球中选出 <span class=\"math inline\">\\(k-i\\)</span> 个球，再从 <span class=\"math inline\">\\(m\\)</span> 个球中选出 <span class=\"math inline\">\\(i\\)</span> 个球的总方案就是从 <span class=\"math inline\">\\(n+m\\)</span> 个球中直接选出 <span class=\"math inline\">\\(k\\)</span> 个球的方案。</p>\n<p>注意判断右侧没有 <code>)</code> 的时候贡献为 <span class=\"math inline\">\\(0\\)</span>。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 1e9 + 7;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    std::string s;\n    std::cin &gt;&gt; s;\n    int n = s.length();\n    s = &quot; &quot; + s;\n    std::vector&lt;int&gt; cnt1(n + 1), cnt2(n + 1);\n    std::vector&lt;long long&gt; fac(n + 1), inv(n + 1);\n    fac[0] = inv[0] = 1ll;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        fac[i] = fac[i - 1] * i % mod;\n        cnt1[i] = cnt1[i - 1] + (s[i] == &#39;(&#39;);\n    &#125;\n    auto qkp = [](long long x, int y) &#123;\n        auto res(1ll);\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    inv[n] = qkp(fac[n], mod - 2);\n    cnt2[n] = (s[n] == &#39;)&#39;);\n    for (int i = n - 1; i; --i) &#123;\n        cnt2[i] = cnt2[i + 1] + (s[i] == &#39;)&#39;);\n        inv[i] = inv[i + 1] * (i + 1) % mod;\n    &#125;\n    long long res = 0ll;\n    auto C = [&amp;](int n, int m) &#123;\n        if (n &lt; m)\n            return 0ll;\n        return fac[n] * inv[n - m] % mod * inv[m] % mod;\n    &#125;;\n    for (int i = 1; i &lt;= n; ++i)\n        if (s[i] == &#39;(&#39;)\n            (res += C(cnt1[i] + cnt2[i] - 1, cnt1[i])) %= mod;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"cf1332e-height-all-the-same\">CF1332E Height All the Same</h2>\n<p><a href=\"https://codeforces.com/problemset/problem/1332/E\" class=\"uri\">https://codeforces.com/problemset/problem/1332/E</a></p>\n<p>容易发现第一个操作是用来改变两个数奇偶性的；而第二个操作能在全图奇偶性相同的任何情况下达成要求。</p>\n<p>注意到如果我们想同时仅改变任意两个数的奇偶性，可以在棋盘上任找一条路径一路使用操作一。只要某种奇偶性的元素个数共有偶数个，就能通过若干次操作一把它们全部变成另一种奇偶性。</p>\n<p>令 <span class=\"math inline\">\\(K_1\\)</span> 为 <span class=\"math inline\">\\(L\\sim R\\)</span> 中奇数的个数，<span class=\"math inline\">\\(K_2\\)</span> 为偶数，那么有：</p>\n<p><span class=\"math display\">\\[\nres=\\sum_{i=0}^{nm} C_{nm}^i\\times {K_1}^i\\cdot {K_2}^{nm-i}\\cdot [i\\bmod 2=0]\n\\]</span></p>\n<p>我们发现这个东西和二项式定理简直像得不能再像了！但多了一个系数导致没办法省略枚举过程。如果进行变形呢？</p>\n<p><span class=\"math display\">\\[\nres=(K_1+K_2)^{nm}-\\sum_{i=0}^{nm} C_{nm}^i\\times {K_1}^i\\cdot {K_2}^{nm-i}\\cdot [i\\bmod 2=1]\n\\]</span></p>\n<p>似乎依然没有出路！但这里有个神奇的操作：</p>\n<p><span class=\"math display\">\\[\nres=(-K_1+K_2)^{nm}+\\sum_{i=0}^{nm} C_{nm}^i\\times {K_1}^i\\cdot {K_2}^i\\cdot [i\\bmod 2=1]\n\\]</span></p>\n<p>二式相加就可以<mark>消元</mark>，得到 <span class=\"math inline\">\\(2\\cdot res=(K_1+K_2)^{nm}+(K_1-K_2)^{nm}\\)</span>。<mark>这启示我们二项式定理中的符号和奇偶性的深切联系。</mark></p>\n<details>\n<p>如果你使用费马小定理对次数进行了处理，你可能需要注意次数可能为 <span class=\"math inline\">\\(\\text{mod} -1\\)</span> 的倍数。</p>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 998244353;\nconst int inv2 = 499122177;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    long long n, m, l, r, k1, k2;\n    std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; l &gt;&gt; r, k1 = (r - l + 1) / 2, k2 = (r - l + 1) - k1;\n    auto qkp = [](long long x, long long y) &#123;\n        auto res(1ll);\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    if (n * m % 2)\n        std::cout &lt;&lt; qkp(r - l + 1, n * m) &lt;&lt; &#39;\\n&#39;;\n    else\n        std::cout &lt;&lt; (qkp(r - l + 1, n * m) + qkp((k1 + mod - k2) % mod, n * m)) % mod * inv2 % mod &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"a---交错序列\">A - 交错序列</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P4456\" class=\"uri\">https://www.luogu.com.cn/problem/P4456</a></p>\n<figure>\n<img src=\"2.png\" alt=\"出题人疑似需要加强数学功底（？）\" /><figcaption>出题人疑似需要加强数学功底（？）</figcaption>\n</figure>\n<p>容易想到把答案用二项式定理拆开：</p>\n<p><span class=\"math display\">\\[\n\\begin{aligned}\nres&amp;=\\sum_y f_y\\cdot y^b\\cdot (n-y)^a\\\\\n&amp;=\\sum_y f_y\\cdot y^b\\cdot \\sum_{i=0}^a C_a^i\\cdot n^i\\cdot(-y)^{a-i}\\\\\n&amp;=\\sum_y\\sum_{i=0}^a f_y\\cdot C_a^i\\cdot n^i\\cdot(-1)^{a-i}\\cdot y^{a+b-i}\\\\\n&amp;=\\sum_{i=0}^a C_a^i\\cdot n^i\\cdot(-1)^{a-i}\\cdot \\sum_y f_y\\cdot y^{a+b-i}\\\\\n\\end{aligned}\n\\]</span></p>\n<p>然后发现后面那个 sigma 不太有办法求。一个比较优雅的方法是把 <span class=\"math inline\">\\(y^{a+b-i}\\)</span> 直接作为系数而非下标塞到 <span class=\"math inline\">\\(f\\)</span> 里去，即令 <span class=\"math inline\">\\(f_{i}\\)</span> 表示 <span class=\"math inline\">\\(\\forall \\,y\\)</span>，<span class=\"math inline\">\\(\\sum y^i\\)</span> 之和。</p>\n<p>具体地，令 <span class=\"math inline\">\\(dp_{n,i,0/1}\\)</span> 表示当前 DP 到第 <span class=\"math inline\">\\(n\\)</span> 位，要求幂次为 <span class=\"math inline\">\\(i\\)</span>，最后一位为 <span class=\"math inline\">\\(0/1\\)</span> 的答案。则显然有 <span class=\"math inline\">\\(dp_{n,i,0}=dp_{n-1,i,0}+dp_{n-1,i,1}\\)</span>。对于 <span class=\"math inline\">\\(dp_{n,i,1}\\)</span>，因为此时 <span class=\"math inline\">\\(\\forall\\, k,k\\gets k+1\\)</span>，则 <span class=\"math inline\">\\((k+1)^i=\\sum\\limits_{j=0}^i C_i^j \\cdot k^j\\)</span> 即 <span class=\"math inline\">\\(dp_{n,i,1}=\\sum\\limits_{j=0}^i C_i^j\\cdot dp_{n-1,j,0}\\)</span>。发现 <span class=\"math inline\">\\(i,j\\)</span> 的范围是 <span class=\"math inline\">\\(90\\)</span>，很恐怖的事情是这是可以矩阵的。</p>\n<details>\n<p>就像我们都知道的那样，矩阵在加完之后再取模就会快很多……</p>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint mod;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, a, b;\n    std::cin &gt;&gt; n &gt;&gt; a &gt;&gt; b &gt;&gt; mod;\n    std::vector&lt;std::vector&lt;long long&gt; &gt; C(a + b + 1, std::vector&lt;long long&gt;(a + b + 1));\n    for (int i = 0; i &lt;= a + b; ++i) &#123;\n        C[i][0] = 1ll;\n        for (int j = 1; j &lt;= i; ++j)\n            C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % mod;\n    &#125;\n    struct mat &#123;\n        int n, m;\n        std::vector&lt;std::vector&lt;long long&gt; &gt; a;\n        mat(int n, int m, bool flag = 0): n(n), m(m), a(n, std::vector&lt;long long&gt; (m)) &#123;\n            if (flag)\n                for (int i = 0; i &lt; n; ++i)\n                    a[i][i] = 1ll;\n            return;\n        &#125;\n        mat operator* (const mat &amp;q) const &#123;\n            mat res(n, q.m);\n            for (int i = 0; i &lt; n; ++i)\n                for (int k = 0; k &lt; q.m; ++k) &#123;\n                    for (int j = 0; j &lt; m; ++j)\n                        res.a[i][k] += a[i][j] * q.a[j][k];\n                    res.a[i][k] %= mod;\n                &#125;\n            return res;\n        &#125;\n        mat operator^ (int q) const &#123;\n            mat res(n, n, 1), x(*this);\n            for (; q; x = x * x, q &gt;&gt;= 1)\n                if (q &amp; 1)\n                    res = res * x;\n            return res;\n        &#125;\n    &#125; f(1, 2 * (a + b + 1)), op(2 * (a + b + 1), 2 * (a + b + 1));\n    auto fun = [&amp;](int i, int j) &#123;\n        return i + j * (a + b + 1);\n    &#125;;\n    f.a[0][fun(0, 0)] = 1ll;\n    for (int i = 0; i &lt;= a + b; ++i)\n        op.a[fun(i, 0)][fun(i, 0)] = op.a[fun(i, 1)][fun(i, 0)] = 1ll;\n    for (int i = 0; i &lt;= a + b; ++i)\n        for (int j = 0; j &lt;= i; ++j)\n            op.a[fun(j, 0)][fun(i, 1)] = C[i][j];\n    f = f * (op ^ n);\n    // for (int i = 0; i &lt;= n; ++i) &#123;\n    //     if (i)\n    //         f = f * op;\n    //     for (int j = 0; j &lt;= a + b; ++j)\n    //         printf(&quot;f[%d][%d] = %lld / %lld\\n&quot;, i, j, f.a[0][fun(j, 0)], f.a[0][fun(j, 1)]);\n    // &#125;\n    auto res = 0ll;\n    for (int i = 0; i &lt;= a; ++i) &#123;\n        static auto p(1ll), k((a % 2) ? mod - 1ll : 1ll);\n        (res += C[a][i] * p % mod * k % mod * (f.a[0][fun(a + b - i, 0)] + f.a[0][fun(a + b - i, 1)]) % mod) %= mod;\n        (p *= n) %= mod, k = mod - k;\n    &#125;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"b---different-subsets-for-all-tuples\">B - Different Subsets For All Tuples</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/CF660E\" class=\"uri\">https://www.luogu.com.cn/problem/CF660E</a></p>\n<p>首先你可能需要知道，如果已知一个序列，如何得到答案？</p>\n<p>令 <span class=\"math inline\">\\(f_i\\)</span> 表示在 <span class=\"math inline\">\\(i\\)</span> 处取一个子序列的末尾，枚举上一个元素 <span class=\"math inline\">\\(x\\)</span>，找到 <span class=\"math inline\">\\(i\\)</span> 之前最靠后的一个 <span class=\"math inline\">\\(a_j=x\\)</span>，那么有 <span class=\"math inline\">\\(f_i=\\sum f_j\\)</span>，换言之需要保证 <span class=\"math inline\">\\((j,i)\\)</span> 范围内没有 <span class=\"math inline\">\\(x\\)</span> 出现。</p>\n<p>此时序列未知，令 <span class=\"math inline\">\\(f_{i, x}\\)</span> 表示在 <span class=\"math inline\">\\(i\\)</span> 处取一个子序列末尾，且 <span class=\"math inline\">\\(i\\)</span> 的值为 <span class=\"math inline\">\\(x\\)</span>；按照贡献的视角来看待，每个可以和 <span class=\"math inline\">\\(i\\)</span> 组成新子序列的方案可以带来 <span class=\"math inline\">\\(m^{i-1}\\)</span> 的贡献（因为 <span class=\"math inline\">\\(a_i\\)</span> 已经固定为 <span class=\"math inline\">\\(x\\)</span>，其他位置可以任选），那么有 <span class=\"math inline\">\\(f_{i,x}=m^i\\times \\sum_{j&lt;i,y}f_{j,y}\\times (m-1)^{i-j-1}\\)</span>。</p>\n<p>然后就惊讶地发现式子和 <span class=\"math inline\">\\(x\\)</span> 这一维没有关系了。所以直接带上系数得到：</p>\n<p><span class=\"math display\">\\[\n\\begin{aligned}\nf_i&amp;=m^i\\times \\sum_{j&lt;i} f_j\\times (m-1)^{i-j-1}\\times m\\\\\n&amp;=m^i\\times (m-1)^{i-1}\\times m\\cdot \\sum_{j&lt;i} f_j\\times (m-1)^{-j}\n\\end{aligned}\n\\]</span></p>\n<p>前缀和优化一下就可以快速求了。最终的答案就是 <span class=\"math inline\">\\(res=m^n+\\sum f_i\\times (m-1)^{n-i}\\)</span>。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 1e9 + 7;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, m;\n    std::cin &gt;&gt; n &gt;&gt; m;\n    if (m == 1)\n        std::cout &lt;&lt; (n + 1) &lt;&lt; &#39;\\n&#39;;\n    else &#123;\n        std::vector&lt;long long&gt; f(n + 1), s(n + 1), pm1(n + 1);\n        pm1[0] = 1ll;\n        for (int i = 1; i &lt;= n; ++i)\n            pm1[i] = pm1[i - 1] * (m - 1) % mod;\n        auto qkp = [](long long x, int y) &#123;\n            auto res(1ll);\n            for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n                if (y &amp; 1)\n                    (res *= x) %= mod;\n            return res;\n        &#125;;\n        auto res(qkp(m, n));\n        const auto invm = qkp(m - 1, mod - 2);\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            static long long p(m), inv(invm);\n            f[i] = (p + pm1[i - 1] * m % mod * s[i - 1] % mod) % mod;\n            s[i] = (s[i - 1] + f[i] * inv % mod) % mod;\n            (res += f[i] * pm1[n - i] % mod) %= mod;\n            (p *= m) %= mod, (inv *= invm) %= mod;\n        &#125;\n        std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;; \n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"g---gardens\">G - Gardens</h2>\n<p><a href=\"https://atcoder.jp/contests/abc235/tasks/abc235_g\" class=\"uri\">https://atcoder.jp/contests/abc235/tasks/abc235_g</a></p>\n<p>如果没有『每个人必须有一个元素』这个限制，就可以随便做了。现在加上了这个限制，很容易想到用没得到的人来容斥。钦定至少有 <span class=\"math inline\">\\(i\\)</span> 个人没拿到，得到答案为 <span class=\"math inline\">\\(\\sum\\limits_{i=0}^n (-1)^i\\cdot C_n^i\\cdot \\left(\\sum\\limits_{j=0}^a C_i^j\\right)\\cdot \\left(\\sum\\limits_{j=0}^b C_i^j\\right)\\cdot \\left(\\sum\\limits_{j=0}^c C_i^j\\right)\\)</span>。</p>\n<p>怎么算 <span class=\"math inline\">\\(\\sum\\limits_{j=0}^a C_i^j\\)</span> 呢？当 <span class=\"math inline\">\\(a&gt; i\\)</span> 时，二项式是好求的；当 <span class=\"math inline\">\\(a\\le i\\)</span> 时呢？看到这个式子很容易带到杨辉三角里去，也就是求一行的前 <span class=\"math inline\">\\(a\\)</span> 个数。注意到可以用上一行的前 <span class=\"math inline\">\\(a\\)</span> 个数 <span class=\"math inline\">\\(O(1)\\)</span> 得到（假设第 <span class=\"math inline\">\\(j-1\\)</span> 行前 <span class=\"math inline\">\\(a\\)</span> 个数之和为 <span class=\"math inline\">\\(f_a(j-1)\\)</span>）：<span class=\"math inline\">\\(f_a(j)=f_a(j-1)\\times 2-C_{j-1,a}\\)</span>。<mark>你需要意识到，由于上一行也是答案中要求的，所以可以使用递推解决问题。<strong>在组合计数中，递推 / DP 无论是在化简式子还是求容斥 / 二项式反演里具体某一限制下的方案数都是很有用的，在需要优化复杂度时，可以从递推 / DP、恒等式、前缀和、预处理等方法入手考虑</strong></mark>。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 998244353;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, a, b, c;\n    std::cin &gt;&gt; n &gt;&gt; a &gt;&gt; b &gt;&gt; c;\n    std::vector&lt;long long&gt; fac(n + 1), inv(n + 1), fa(n + 1), fb(n + 1), fc(n + 1), pow2(n + 1);\n    fac[0] = inv[0] = pow2[0] = 1ll;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        fac[i] = fac[i - 1] * i % mod;\n        pow2[i] = pow2[i - 1] * 2 % mod;\n    &#125;\n    auto qkp = [&amp;](long long x, int y) &#123;\n        auto res(1ll);\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    inv[n] = qkp(fac[n], mod - 2);\n    for (int i = n - 1; i; --i)\n        inv[i] = inv[i + 1] * (i + 1) % mod;\n    auto C = [&amp;](int n, int m) &#123;\n        return fac[n] * inv[n - m] % mod * inv[m] % mod;\n    &#125;;\n    for (int i = 0; i &lt;= a; ++i)\n        (fa[a] += C(a, i)) %= mod;\n    for (int i = a + 1; i &lt;= n; ++i)\n        fa[i] = (2 * fa[i - 1] % mod + mod - C(i - 1, a)) % mod;\n    for (int i = 0; i &lt;= b; ++i)\n        (fb[b] += C(b, i)) %= mod;\n    for (int i = b + 1; i &lt;= n; ++i)\n        fb[i] = (2 * fb[i - 1] % mod + mod - C(i - 1, b)) % mod;\n    for (int i = 0; i &lt;= c; ++i)\n        (fc[c] += C(c, i)) %= mod;\n    for (int i = c + 1; i &lt;= n; ++i)\n        fc[i] = (2 * fc[i - 1] % mod + mod - C(i - 1, c)) % mod;\n    auto res(0ll);\n    for (int i = n, p = 1; ~i; --i, p = mod - p)\n        (res += p * C(n, i) % mod * (i &gt;= a ? fa[i] : pow2[i]) % mod * (i &gt;= b ? fb[i] : pow2[i]) % mod * (i &gt;= c ? fc[i] : pow2[i]) % mod) %= mod;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n",
            "tags": [
                "DP",
                "计数"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20230418/",
            "url": "https://xsc062.netlify.app/20230418/",
            "title": "解题报告：两双手",
            "date_published": "2023-04-18T08:48:22.000Z",
            "content_html": "<p>凳子充分地让我切身实地地体会到了平行四边形的不稳定性。做题的时候可以 360° 无死角地把下半身转来转去，有点意思。也有点容易摔（×</p>\n<span id=\"more\"></span>\n<hr />\n<h3 id=\"a.-两双手\">A. 两双手</h3>\n<p><a href=\"http://222.180.160.110:1024/contest/3506/problem/1\" class=\"uri\">http://222.180.160.110:1024/contest/3506/problem/1</a></p>\n<p>不难发现可以通过解二元一次方程组得到用几个 A 操作和 B 操作才能让横纵坐标分别改变一些特定的值。可惜我没能想到一个经典的容斥 DP 思想：</p>\n<p>定义起点为点 <span class=\"math inline\">\\(0\\)</span>。定义 <span class=\"math inline\">\\(C(x,y)\\)</span> 表示从 <span class=\"math inline\">\\(x\\)</span> 点走到 <span class=\"math inline\">\\(y\\)</span> 点的方案数（可经过特殊点）。对于特殊点 <span class=\"math inline\">\\(1\\sim n\\)</span>，顺序枚举，对于点 <span class=\"math inline\">\\(i\\)</span>，定义 <span class=\"math inline\">\\(f_i\\)</span> 表示从 <span class=\"math inline\">\\(0\\sim i\\)</span> 不经过任何除 <span class=\"math inline\">\\(i\\)</span> 以外的特殊点的方案数，则 <span class=\"math inline\">\\(f_i=C(0,i)-\\sum\\limits_{j=1}^{i-1}f_j\\times C(j,i)\\)</span>。其中 <span class=\"math inline\">\\(\\sum\\limits_{j=1}^{i-1}f_j\\times C(j,i)\\)</span> 就是从 <span class=\"math inline\">\\(0\\)</span> 到 <span class=\"math inline\">\\(i\\)</span>，除 <span class=\"math inline\">\\(i\\)</span> 以外经过至少 1 个特殊点的方案数。用总方案数减去不合法方案数，则得到合法方案数。</p>\n<p>一个细节。我们枚举时，可能会遇到只能从 <span class=\"math inline\">\\(i\\)</span> 到达 <span class=\"math inline\">\\(j\\)</span>，而不能从 <span class=\"math inline\">\\(j\\)</span> 到达 <span class=\"math inline\">\\(i\\)</span> 的情况。若恰好 <span class=\"math inline\">\\(j\\)</span> 在 <span class=\"math inline\">\\(i\\)</span> 前面，那么从 <span class=\"math inline\">\\(i\\)</span> 到 <span class=\"math inline\">\\(j\\)</span> 的路径就会被统计漏。这个时候怎么办呢？对于任意点 <span class=\"math inline\">\\(i\\)</span>，我们求得从 <span class=\"math inline\">\\(0\\to i\\)</span> 所需的步数，并以此为关键字从小到大排序，那么我们就能保证，任意一条合法路径都会被我们统计到。</p>\n<p>还是没那么难，有点套路。时间复杂度 <span class=\"math inline\">\\(O(n^2)\\)</span>。</p>\n<details>\n<pre class=\"cpp\"><code>namespace XSC062 &#123;\nusing namespace fastIO;\n#define mkp std::make_pair\nusing pii = std::pair&lt;int, int&gt;;\nconst int lim = 1e6;\nconst int maxn = 505;\nconst int mod = 1e9 + 7;\nconst int maxm = 1e6 + 5;\nstruct _ &#123; int x, y, w; &#125;;\nstd::set&lt;pii&gt; t;\n_ s[maxn], s1[maxn];\nint fac[maxm], f[maxn];\nint ex, ey, n1, n, ax, ay, bx, by;\ninline int gcd(int x, int y) &#123;\n    return y ? gcd(y, x % y) : x;\n&#125;\ninline int lcm(int x, int y) &#123;\n    return x / gcd(x, y) * y;\n&#125;\npii Solve(int a, int b, int c,\n                int d, int e, int f) &#123;\n    int N = 0, M = 0;\n    if (!a) &#123;\n        if (c % b)\n            return mkp(-1, -1);\n        M = c / b, f -= M * e;\n        if (f % d)\n            return mkp(-1, -1);\n        N = f / d;\n    &#125;\n    else if (!b) &#123;\n        if (c % a)\n            return mkp(-1, -1);\n        N = c / a, f -= N * d;\n        if (f % e)\n            return mkp(-1, -1);\n        M = f / e;\n    &#125;\n    else if (!d) &#123;\n        if (f % e)\n            return mkp(-1, -1);\n        M = f / e, f -= M * b;\n        if (c % a)\n            return mkp(-1, -1);\n        N = c / a;\n    &#125;\n    else if (!e) &#123;\n        if (f % d)\n            return mkp(-1, -1);\n        N = f / d, c -= N * a;\n        if (c % b)\n            return mkp(-1, -1);\n        M = c / b;\n    &#125;\n    else &#123;\n        int g = lcm(b, e);\n        a *= g / b, c *= g / b, b = g;\n        d *= g / e, f *= g / e, e = g;\n        if ((c - f) % (a - d))\n            return mkp(-1, -1);\n        N = (c - f) / (a - d), c -= N * a;\n        if (c % b)\n            return mkp(-1, -1);\n        M = c / b;\n    &#125;\n    return mkp(N, M);\n&#125;\ninline int qkp(int x, int y) &#123;\n    int res = 1;\n    while (y) &#123;\n        if (y &amp; 1)\n            (res *= x) %= mod;\n        (x *= x) %= mod;\n        y &gt;&gt;= 1;\n    &#125;\n    return res;\n&#125;\ninline int inv(int x) &#123;\n    return qkp(x, mod - 2);\n&#125;\ninline int A(int n, int m) &#123;\n    return (fac[n] * inv(fac[n - m])) % mod;\n&#125;\ninline int C(int n, int m) &#123;\n    return (A(n, m) * inv(A(m, m))) % mod;\n&#125;\ninline void Init(void) &#123;\n    fac[0] = 1;\n    for (int i = 1; i &lt;= lim; ++i)\n        fac[i] = (fac[i - 1] * i) % mod;\n    return;\n&#125;\nint main() &#123;\n    read(ex), read(ey), read(n1);\n    read(ax), read(ay), read(bx), read(by);\n    for (int i = 1; i &lt;= n1; ++i) &#123;\n        read(s1[i].x), read(s1[i].y);\n        pii t = Solve(ax, bx, s1[i].x,\n                        ay, by, s1[i].y);\n        s1[i].w = t.first + t.second;\n    &#125;\n    std::sort(s1 + 1, s1 + n1 + 1,\n        [&amp;](_ x, _ y) &#123; return x.w &lt; y.w; &#125;);\n    Init(), f[0] = 1, ++n1;\n    s1[n1].x = ex, s1[n1].y = ey;\n    for (int i = 1; i &lt;= n1; ++i) &#123;\n        pii t = Solve(ax, bx, s1[i].x,\n                        ay, by, s1[i].y);\n        if (t.first &lt; 0 || t.second &lt; 0) &#123;\n            if (i == n1) &#123;\n                puts(&quot;0&quot;);\n                return 0;\n            &#125;\n            continue;\n        &#125;\n        s[++n] = s1[i];\n    &#125;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        for (int j = 1; j &lt; i; ++j) &#123;\n            pii t = Solve(ax, bx, s[i].x\n                - s[j].x, ay, by, s[i].y\n                - s[j].y);\n            if (t.first &lt; 0 || t.second &lt; 0)\n                continue;\n            (f[i] += (f[j] * C(t.first +\n                    t.second, t.first)) %\n                    mod) %= mod;\n        &#125;\n        pii t = Solve(ax, bx, s[i].x,\n                    ay, by, s[i].y);\n        f[i] = (C(t.first + t.second,\n                t.first) + mod - f[i]) % mod;\n    &#125;\n    print(f[n]);\n    return 0;\n&#125;\n&#125; // namespace XSC062</code></pre>\n</details>\n",
            "tags": [
                "DP",
                "计数",
                "容斥"
            ]
        }
    ]
}