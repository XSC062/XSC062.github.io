<?xml version="1.0"?>
<rss version="2.0">
    <channel>
        <title> • Posts by &#34;boruvka&#34; tag</title>
        <link>https://xsc062.netlify.app</link>
        <description></description>
        <language>zh-CN</language>
        <pubDate>Mon, 13 Oct 2025 10:35:14 +0800</pubDate>
        <lastBuildDate>Mon, 13 Oct 2025 10:35:14 +0800</lastBuildDate>
        <category>并查集</category>
        <category>斜率优化</category>
        <category>悬线法</category>
        <category>哈希</category>
        <category>字典树</category>
        <category>DP</category>
        <category>单调队列</category>
        <category>分治</category>
        <category>计数</category>
        <category>二分图</category>
        <category>CRT / exCRT</category>
        <category>排列组合</category>
        <category>网络流</category>
        <category>费用流</category>
        <category>二分</category>
        <category>上下界网络流</category>
        <category>容斥原理</category>
        <category>线段树</category>
        <category>树状数组</category>
        <category>区间 DP</category>
        <category>构造</category>
        <category>数据结构</category>
        <category>Tarjan</category>
        <category>下饭</category>
        <category>LCA</category>
        <category>倍增</category>
        <category>鸽巢原理</category>
        <category>概率期望</category>
        <category>调和级数</category>
        <category>差分</category>
        <category>思维</category>
        <category>树形 DP</category>
        <category>最小生成树</category>
        <category>SAM</category>
        <category>状压</category>
        <category>分块</category>
        <category>可持久化</category>
        <category>笛卡尔树</category>
        <category>高维前缀和</category>
        <category>闲话</category>
        <category>欧拉回路</category>
        <category>树链剖分</category>
        <category>长链剖分</category>
        <category>KMP</category>
        <category>border</category>
        <category>字符串</category>
        <category>AC 自动机</category>
        <category>SA</category>
        <category>数学</category>
        <category>树上差分</category>
        <category>FWT</category>
        <category>堆</category>
        <category>树的重心</category>
        <category>二项式定理</category>
        <category>二项式反演</category>
        <category>贪心</category>
        <category>均摊</category>
        <category>优化建图</category>
        <category>反悔贪心</category>
        <category>调整法</category>
        <category>背包</category>
        <category>博弈论</category>
        <category>DP 优化</category>
        <category>虚树</category>
        <category>点分治</category>
        <category>WQS 二分</category>
        <category>闵可夫斯基和</category>
        <category>slope trick</category>
        <category>四边形不等式</category>
        <category>状压 DP</category>
        <category>组合数学</category>
        <category>支配对</category>
        <category>DDP</category>
        <category>容斥</category>
        <category>Kruskal 重构树</category>
        <category>高精度</category>
        <category>最短路</category>
        <category>树套树</category>
        <category>Boruvka</category>
        <category>树链剖分 - 最小生成树</category>
        <category>李超线段树</category>
        <item>
            <guid isPermalink="true">https://xsc062.netlify.app/20251013/</guid>
            <title>生成树 III</title>
            <link>https://xsc062.netlify.app/20251013/</link>
            <category>最小生成树</category>
            <category>Kruskal 重构树</category>
            <category>Boruvka</category>
            <pubDate>Mon, 13 Oct 2025 10:35:14 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;mst，以及 mst related&lt;/p&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;boruvka&#34;&gt;Boruvka&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;用途：&lt;span class=&#34;math inline&#34;&gt;\(O(m\log n)\)&lt;/span&gt; 求 mst。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;过程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;考虑和 Kruskal、Prim 类似的孤立点 &lt;span class=&#34;math inline&#34;&gt;\(\to\)&lt;/span&gt; 加边 &lt;span class=&#34;math inline&#34;&gt;\(\to\)&lt;/span&gt; 树。&lt;/li&gt;
&lt;li&gt;每一轮算法，对于当前的每个连通块，找到其连向其它连通块的边中最小的一条，并在这一轮后加入边集（用并查集维护连通块合并）。&lt;/li&gt;
&lt;li&gt;重复执行该算法，最终找到 mst。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure&gt;
&lt;img src=&#34;mst-1.apng&#34; alt=&#34;图源 OI Wiki&#34;&gt;
&lt;figcaption&gt;
图源 OI Wiki
&lt;/figcaption&gt;
&lt;/figure&gt;&lt;/li&gt;
&lt;li&gt;复杂度：每一轮中，每个连通块都会被合并一次，故一轮之后现存连通块数量最坏情况下变为原来的一半。也即共执行 &lt;span class=&#34;math inline&#34;&gt;\(\log n\)&lt;/span&gt; 轮。复杂度 &lt;span class=&#34;math inline&#34;&gt;\(O(m\log n)\)&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;优势：对于&lt;strong&gt;特殊边权&lt;/strong&gt;的完全图 / 稠密图，边权并不由输入直接给定，而是由顶点计算得到，此时若可以依据性质直接找到连通块的最小边，则复杂度降低至 &lt;span class=&#34;math inline&#34;&gt;\(O(n\log n)\)&lt;/span&gt; 之类非常优秀的级别（注意并查集的 log 和 Boruvka 本身的 log 是平行的）。&lt;/p&gt;
&lt;p&gt;『依据性质找到最小的边』的一个 Bonus：见 KDT + Boruvka 做法的 &lt;a href=&#34;https://www.luogu.com.cn/problem/P6362&#34;&gt;平面欧几里得最小生成树&lt;/a&gt;。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;a---jumping-around&#34;&gt;A - Jumping Around&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/CF1550F&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/CF1550F&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;本题就是『特殊边权完全图』的体现。定义任意两个点之间的边权为两个点相互跳需要的最小的 &lt;span class=&#34;math inline&#34;&gt;\(k=||x_0-x_1|-d|\)&lt;/span&gt;，那么只需求瓶颈路。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;做 Boruvka 即可。考虑怎么求某个连通块的最小边，预处理出每个位置（包括空位）前 / 后第一个和自己颜色不同的非空位，每次 check &lt;span class=&#34;math inline&#34;&gt;\(i\pm d\)&lt;/span&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;若该位置存在和当前位置不同颜色的点：连边。&lt;/li&gt;
&lt;li&gt;否则，若该位置和当前位置颜色相同：转到刚刚求出的前驱、后继，选更小者连边。&lt;/li&gt;
&lt;li&gt;否则该位为空。前驱、后继则转化为上面两种情况。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;和双指针做法不同，似乎并不支持离散化，只能做到 &lt;span class=&#34;math inline&#34;&gt;\(O(V\log n)\)&lt;/span&gt;。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int V = 1e6;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, q, s, d;
    std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; q &amp;gt;&amp;gt; s &amp;gt;&amp;gt; d;
    std::vector&amp;lt;int&amp;gt; a(n + 1), tab(V + 1);
    for (int i = 1; i &amp;lt;= n; ++i)
        std::cin &amp;gt;&amp;gt; a[i], tab[a[i]] = i;
    std::vector&amp;lt;std::pair&amp;lt;int, int&amp;gt; &amp;gt; to(n + 1);
    std::vector&amp;lt;std::vector&amp;lt;std::pair&amp;lt;int, int&amp;gt; &amp;gt; &amp;gt; g(n + 1);
    std::vector&amp;lt;int&amp;gt; u(V + 1), pre(V + 1), nex(V + 1), mn(n + 1), f(n + 1), pos;
    std::iota(f.begin() + 1, f.end(), 1);
    std::function&amp;lt;int(int)&amp;gt; find = [&amp;amp;](int x) &amp;#123;
        return x == f[x] ? x : f[x] = find(f[x]);
    &amp;#125;;
    for (int tot = n; tot != 1; ) &amp;#123;
        pos.clear();
        for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
            if (f[i] == i) &amp;#123;
                mn[i] = 0x3f3f3f3f, to[i] = &amp;#123; 0, 0 &amp;#125;;
                pos.push_back(i);
            &amp;#125;
            u[a[i]] = find(i);
            if (u[a[i - 1]] == u[a[i]])
                pre[a[i]] = pre[a[i - 1]];
            else
                pre[a[i]] = a[i - 1];
        &amp;#125;
        for (int i = 1; i &amp;lt;= V; ++i)
            if (!u[i])
                pre[i] = u[i - 1] ? i - 1 : pre[i - 1];
        nex[a[n]] = V + 1;
        for (int i = n - 1; i; --i)
            if (u[a[i + 1]] == u[a[i]])
                nex[a[i]] = nex[a[i + 1]];
            else
                nex[a[i]] = a[i + 1];
        nex[V] = V + 1;
        for (int i = V - 1; i; --i)
            if (!u[i])
                nex[i] = u[i + 1] ? i + 1 : nex[i + 1];
        for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
            int x = a[i], now = 0x3f3f3f3f, pos = 0;
            auto upd = [&amp;amp;](int x1) &amp;#123;
                if (std::abs(std::abs(x - x1) - d) &amp;lt; now)
                    now = std::abs(std::abs(x - x1) - d), pos = x1;
                return;
            &amp;#125;;
            auto trans = [&amp;amp;](int x1) &amp;#123;
                if (pre[x1])
                    upd(pre[x1]);
                if (nex[x1] != V + 1)
                    upd(nex[x1]);
                return;
            &amp;#125;;
            std::function&amp;lt;void(int)&amp;gt; work = [&amp;amp;](int x1) &amp;#123;
                if (u[x1] &amp;amp;&amp;amp; u[x1] != u[x])
                    upd(x1);
                else if (u[x1])
                    trans(x1);
                else &amp;#123;
                    if (pre[x1])
                        work(pre[x1]);
                    if (nex[x1] != V + 1)
                        work(nex[x1]);
                &amp;#125;
                return;
            &amp;#125;;
            work(std::max(1, x - d)), work(std::min(V, x + d));
            if (now &amp;lt; mn[u[x]])
                mn[u[x]] = now, to[u[x]] = &amp;#123; i, tab[pos] &amp;#125;;
        &amp;#125;
        for (auto i : pos) &amp;#123;
            int j = u[a[to[i].second]], x = to[i].first, y = to[i].second;
            if (find(i) != find(j)) &amp;#123;
                --tot;
                f[find(i)] = find(j);
                g[x].emplace_back(y, mn[i]), g[y].emplace_back(x, mn[i]);
            &amp;#125;
        &amp;#125;
    &amp;#125;
    std::vector&amp;lt;int&amp;gt; res(n + 1);
    std::function&amp;lt;void(int, int)&amp;gt; DFS = [&amp;amp;](int x, int fa) &amp;#123;
        for (auto [i, w] : g[x])
            if (i != fa) &amp;#123;
                res[i] = std::max(res[x], w);
                DFS(i, x);
            &amp;#125;
        return;
    &amp;#125;;
    DFS(s, -1);
    for (int x, k; q--; ) &amp;#123;
        std::cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; k;
        std::cout &amp;lt;&amp;lt; ((res[x] &amp;lt;= k) ? &amp;quot;Yes&amp;quot; : &amp;quot;No&amp;quot;) &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    &amp;#125;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;b---parametric-mst&#34;&gt;B - Parametric MST&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/CF1656F&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/CF1656F&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可以猜到能够把答案写出来，但是发现太抽象了以至于不太好模拟。&lt;/li&gt;
&lt;li&gt;首先需要猜到题目给的 &lt;span class=&#34;math inline&#34;&gt;\(w\)&lt;/span&gt; 是可以继续化的，注意到 &lt;span class=&#34;math inline&#34;&gt;\(a_i\cdot a_j+t(a_i+a_j)\)&lt;/span&gt; 可以写成 &lt;span class=&#34;math inline&#34;&gt;\((a_j+t)\cdot a_i+t\cdot a_i\)&lt;/span&gt; 的一次函数形式，一个很重要的思路是放弃模拟 mst 转而&lt;strong&gt;从点出发贪心&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(t\)&lt;/span&gt; 会影响的是斜率 &lt;span class=&#34;math inline&#34;&gt;\(a_j+t\)&lt;/span&gt;，所以&lt;strong&gt;应该根据 &lt;span class=&#34;math inline&#34;&gt;\(a_j+t\)&lt;/span&gt; 的正负情况选择贪心策略&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;当 &lt;span class=&#34;math inline&#34;&gt;\(a_j+t\le 0\)&lt;/span&gt; 时，使 &lt;span class=&#34;math inline&#34;&gt;\(a_j\)&lt;/span&gt; 向 &lt;span class=&#34;math inline&#34;&gt;\(a_{\max}\)&lt;/span&gt; 连边，否则向 &lt;span class=&#34;math inline&#34;&gt;\(a_{\min}\)&lt;/span&gt; 连边。&lt;/p&gt;
&lt;p&gt;这其实是 Boruvka 第一轮的过程；此时只剩至多两个连通块，连边方式也就讨论一下 &lt;span class=&#34;math inline&#34;&gt;\(a_1+t\)&lt;/span&gt; 和 &lt;span class=&#34;math inline&#34;&gt;\(a_n+t\)&lt;/span&gt; 的正负，然后很显然了。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;当 &lt;span class=&#34;math inline&#34;&gt;\(t\)&lt;/span&gt; 足够小时，所有点都会连向 &lt;span class=&#34;math inline&#34;&gt;\(a_{\max}\)&lt;/span&gt;；反之，当 &lt;span class=&#34;math inline&#34;&gt;\(t\)&lt;/span&gt; 足够大时，所有点都会连向 &lt;span class=&#34;math inline&#34;&gt;\(a_{\min}\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;对于第一种情况，mst 的权为 &lt;span class=&#34;math inline&#34;&gt;\(a_{\max}\cdot (s - a_{\max}) + t\cdot ((n-1)\cdot a_{\max}+s-a_{\max})\)&lt;/span&gt;；第二种情况，mst 的权为 &lt;span class=&#34;math inline&#34;&gt;\(a_{\min}\cdot (s - a_{\min}) + t\cdot ((n-1)\cdot a_{\min}+s-a_{\min})\)&lt;/span&gt;，check &lt;span class=&#34;math inline&#34;&gt;\(t\)&lt;/span&gt; 的系数即可判 &lt;code&gt;INF&lt;/code&gt;。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;通过上面一种情况，可以注意到 &lt;span class=&#34;math inline&#34;&gt;\(t\in[-a_{\max},-a_{\min}]\)&lt;/span&gt;，进一步需要猜到 &lt;span class=&#34;math inline&#34;&gt;\(t\)&lt;/span&gt; 取某个 &lt;span class=&#34;math inline&#34;&gt;\(-a_i\)&lt;/span&gt;。由于连的边是很已知的，可以发现当 &lt;span class=&#34;math inline&#34;&gt;\(t\)&lt;/span&gt; 夹在两个连续的 &lt;span class=&#34;math inline&#34;&gt;\(-a\)&lt;/span&gt; 之间时，mst 的连边情况是不变的。&lt;/p&gt;
&lt;p&gt;显然此时 mst 的权是一个关于 &lt;span class=&#34;math inline&#34;&gt;\(t\)&lt;/span&gt; 的一次函数，故 check 两端点即可。排序即可快速 check。&lt;/p&gt;
&lt;p&gt;由于此时第二轮 Boruvka 要连的边一定是 &lt;span class=&#34;math inline&#34;&gt;\((a_1,a_n)\)&lt;/span&gt;，连上即可。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int T;
    for (std::cin &amp;gt;&amp;gt; T; T--; ) &amp;#123;
        int n;
        std::cin &amp;gt;&amp;gt; n;
        std::vector&amp;lt;long long&amp;gt; a(n + 1), s(n + 1);
        for (int i = 1; i &amp;lt;= n; ++i)
            std::cin &amp;gt;&amp;gt; a[i];
        std::sort(a.begin() + 1, a.end());
        std::partial_sum(a.begin() + 1, a.end(), s.begin() + 1);
        if ((n - 1) * a[n] + s[n - 1] &amp;lt; 0ll || (n - 1) * a[1] + s[n] - a[1] &amp;gt; 0ll)
            std::cout &amp;lt;&amp;lt; &amp;quot;INF\n&amp;quot;;
        else &amp;#123;
            long long res = -1e18;
            for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
                auto t = -a[i], sl = s[i] - a[1], sr = s[n - 1] - s[i];
                res = std::max(res, a[n] * sl + a[1] * sr + t * ((i - 1) * a[n] + (n - 1 - i) * a[1] + sl + sr) + a[1] * a[n] + t * (a[1] + a[n]));
            &amp;#125;
            std::cout &amp;lt;&amp;lt; res &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
        &amp;#125;
    &amp;#125;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;c---star-mst&#34;&gt;C - Star MST&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/CF1657E&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/CF1657E&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;模拟 Kruskal 的过程，在边权 &lt;span class=&#34;math inline&#34;&gt;\(w\)&lt;/span&gt; 处出现 &lt;span class=&#34;math inline&#34;&gt;\((1,x)\)&lt;/span&gt;，那么允许在 &lt;span class=&#34;math inline&#34;&gt;\(\ge w\)&lt;/span&gt; 处出现其他与 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 相关的边。&lt;/li&gt;
&lt;li&gt;会有一个比较暴力的想法，设 &lt;span class=&#34;math inline&#34;&gt;\(f_{i,j,l}\)&lt;/span&gt; 表示已经分配完边权 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt;，共分配了 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; 条与 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt; 相关的边，还剩下 &lt;span class=&#34;math inline&#34;&gt;\(l\)&lt;/span&gt; 条空闲边可以放，会有一个 &lt;span class=&#34;math inline&#34;&gt;\(O(k\cdot n^4)\)&lt;/span&gt; 的转移。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;考虑优化。容易注意到没必要存 &lt;span class=&#34;math inline&#34;&gt;\(l\)&lt;/span&gt; 而是可以当场完成分配，但这样就导致 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 维的限制转化为『恰好』，需要额外枚举一轮。总之可以得到：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
f_{i,j}=\sum_{d_i=1}^{i}\sum_{d_j=1}^{j} C_{n-(j-d_j)}^{d_j}\times f_{i-d_i,j-d_j}\times (k-i+1)^{C_{d_j}^2+d_j\times (j-d_j)}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;此时复杂度为 &lt;span class=&#34;math inline&#34;&gt;\(O(k^2n^2\log k)\)&lt;/span&gt;，依然不够看；注意到交换求和顺序可以前缀和优化，故：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
f_{j, i}=\sum_{d_j=1}^{j} C_{n-(j-d_j)}^{d_j}\times (k-i+1)^{C_{d_j}^2+d_j\times (j-d_j)}\times \sum_{d_i=1}^{i}f_{j - d_j,i-d_i}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;复杂度 &lt;span class=&#34;math inline&#34;&gt;\(O(kn^2\log k)\)&lt;/span&gt;。&lt;span class=&#34;math inline&#34;&gt;\(\log\)&lt;/span&gt; 来源于快速幂。当然可以考虑预处理优化掉 log，whatever.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int mod = 998244353;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, k;
    std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; k;
    std::vector&amp;lt;std::vector&amp;lt;long long&amp;gt; &amp;gt; C(n + 1, std::vector&amp;lt;long long&amp;gt; (n + 1));
    for (int i = 0; i &amp;lt;= n; ++i) &amp;#123;
        C[i][0] = 1ll;
        for (int j = 1; j &amp;lt;= i; ++j)
            C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % mod;
    &amp;#125;
    auto qkp = [&amp;amp;](long long x, int y) &amp;#123;
        auto res = 1ll;
        for (; y; (x *= x) %= mod, y &amp;gt;&amp;gt;= 1)
            if (y &amp;amp; 1)
                (res *= x) %= mod;
        return res;
    &amp;#125;;
    std::vector&amp;lt;std::vector&amp;lt;long long&amp;gt; &amp;gt; s(n, std::vector&amp;lt;long long&amp;gt; (k + 1));
    for (int i = 0; i &amp;lt;= k; ++i)
        s[0][i] = 1ll;
    for (int j = 1; j &amp;lt; n; ++j)
        for (int i = 1; i &amp;lt;= k; ++i) &amp;#123;
            for (int dj = 1; dj &amp;lt;= j; ++dj) 
                s[j][i] += C[n - (j - dj) - 1][dj] * qkp(k - i + 1, (C[dj][2] + dj * (j - dj)) % mod) % mod * s[j - dj][i - 1] % mod;
            (s[j][i] += s[j][i - 1]) %= mod;
        &amp;#125;
    std::cout &amp;lt;&amp;lt; s[n - 1][k] &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;d---smooth-sailing-hard-version&#34;&gt;D - Smooth Sailing (Hard Version)&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/CF1920F2&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/CF1920F2&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;实在十分熟悉，之前在哪道 CF 题遇到过这个 trick，然而没什么回忆线索，遂放弃&lt;/p&gt;
&lt;p&gt;一个连通块被包围的充要条件：从连通块边缘任意一个点向任意方向发一条射线，&lt;em&gt;垂直&lt;/em&gt;经过路径奇数次。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;垂直&lt;/em&gt;：即切线不切换奇偶状态。&lt;/p&gt;
&lt;p&gt;这个东西其实来源于计算几何，但是我的数学水平只停留在听说过计算几何四个字的水平，故不深究了。&lt;/p&gt;
&lt;p&gt;这种网格图上的图论问题，可以往欧拉定理（&lt;span class=&#34;math inline&#34;&gt;\(v-e+f=2\)&lt;/span&gt;），计算几何考虑，&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;怎么在保证这一点的前提下求 mst 呢？答案是丢到状态里。&lt;/p&gt;
&lt;p&gt;找一个最靠左的点往左边引一条射线并标记沿路经过的点。令 &lt;span class=&#34;math inline&#34;&gt;\((x, y, 0/1)\)&lt;/span&gt; 表示走到 &lt;span class=&#34;math inline&#34;&gt;\((x, y)\)&lt;/span&gt;，经过关键点偶数次 / 奇数次。边权啥的也没什么好说的，点权前移即可。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;询问的转化反而不太好想，其实就是问 &lt;span class=&#34;math inline&#34;&gt;\((x,y,0)\)&lt;/span&gt; 到 &lt;span class=&#34;math inline&#34;&gt;\((x,y,1)\)&lt;/span&gt; 的瓶颈路。&lt;/p&gt;
&lt;p&gt;巧得有些不太自然，然而并没找到合理的解释。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;询问建个 Kruskal 重构树找 LCA 即可，复杂度 &lt;span class=&#34;math inline&#34;&gt;\(O(nm\log nm)\)&lt;/span&gt;。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int dir[][2] = &amp;#123;&amp;#123; -1, 0 &amp;#125;, &amp;#123; 1, 0 &amp;#125;, &amp;#123; 0, -1 &amp;#125;, &amp;#123; 0, 1 &amp;#125;&amp;#125;;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, m, q;
    std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m &amp;gt;&amp;gt; q;
    int cnt = 2 * n * m;
    std::vector&amp;lt;int&amp;gt; W(1);
    std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; g(2 * n * m + 1);
    auto fun = [&amp;amp;](int i, int j, int k) &amp;#123;
        return k * n * m + (i - 1) * m + j;
    &amp;#125;;
    &amp;#123;
        int px = 0, py = m + 1;
        std::vector&amp;lt;std::vector&amp;lt;char&amp;gt; &amp;gt; a(n + 1, std::vector&amp;lt;char&amp;gt; (m + 1));
        for (int i = 1; i &amp;lt;= n; ++i)
            for (int j = 1; j &amp;lt;= m; ++j) &amp;#123;
                std::cin &amp;gt;&amp;gt; a[i][j];
                if (a[i][j] == &amp;#39;#&amp;#39; &amp;amp;&amp;amp; j &amp;lt; py)
                    px = i, py = j;
            &amp;#125;
        std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; w(n + 1, std::vector&amp;lt;int&amp;gt; (m + 1, 0x3f3f3f3f));
        &amp;#123;
            std::queue&amp;lt;std::pair&amp;lt;int, int&amp;gt; &amp;gt; q;
            for (int i = 1; i &amp;lt;= n; ++i)
                for (int j = 1; j &amp;lt;= m; ++j)
                    if (a[i][j] == &amp;#39;v&amp;#39;)
                        q.emplace(i, j), w[i][j] = 0;
            for (; !q.empty(); ) &amp;#123;
                auto [x, y] = q.front();
                q.pop();
                for (auto [fx, fy] : dir) &amp;#123;
                    int nx = x + fx, ny = y + fy;
                    if (nx &amp;gt;= 1 &amp;amp;&amp;amp; nx &amp;lt;= n &amp;amp;&amp;amp; ny &amp;gt;= 1 &amp;amp;&amp;amp; ny &amp;lt;= m &amp;amp;&amp;amp; w[nx][ny] == 0x3f3f3f3f) &amp;#123;
                        w[nx][ny] = w[x][y] + 1;
                        q.emplace(nx, ny);
                    &amp;#125;
                &amp;#125;
            &amp;#125;
        &amp;#125;
        struct edge &amp;#123; int u, v, w; &amp;#125;;
        std::vector&amp;lt;edge&amp;gt; e;
        for (int i = 1; i &amp;lt;= n; ++i)
            for (int j = 1; j &amp;lt;= m; ++j)
                if (a[i][j] != &amp;#39;#&amp;#39;) &amp;#123;
                    if (j != m &amp;amp;&amp;amp; a[i][j + 1] != &amp;#39;#&amp;#39;) &amp;#123;
                        e.push_back(&amp;#123; fun(i, j, 0), fun(i, j + 1, 0), std::min(w[i][j], w[i][j + 1]) &amp;#125;);
                        e.push_back(&amp;#123; fun(i, j, 1), fun(i, j + 1, 1), std::min(w[i][j], w[i][j + 1]) &amp;#125;);
                    &amp;#125;
                    if (i != n &amp;amp;&amp;amp; a[i + 1][j] != &amp;#39;#&amp;#39;) &amp;#123;
                        if (i + 1 == px &amp;amp;&amp;amp; j &amp;lt;= py) &amp;#123;
                            e.push_back(&amp;#123; fun(i, j, 0), fun(i + 1, j, 1), std::min(w[i][j], w[i + 1][j]) &amp;#125;);
                            e.push_back(&amp;#123; fun(i, j, 1), fun(i + 1, j, 0), std::min(w[i][j], w[i + 1][j]) &amp;#125;);
                        &amp;#125;
                        else &amp;#123;
                            e.push_back(&amp;#123; fun(i, j, 0), fun(i + 1, j, 0), std::min(w[i][j], w[i + 1][j]) &amp;#125;);
                            e.push_back(&amp;#123; fun(i, j, 1), fun(i + 1, j, 1), std::min(w[i][j], w[i + 1][j]) &amp;#125;);
                        &amp;#125;
                    &amp;#125;
                &amp;#125;
        std::sort(e.begin(), e.end(), [&amp;amp;](edge &amp;amp;x, edge &amp;amp;y) &amp;#123; return x.w &amp;gt; y.w; &amp;#125;);
        std::vector&amp;lt;int&amp;gt; f(2 * n * m + 1);
        std::iota(f.begin() + 1, f.end(), 1);
        std::function&amp;lt;int(int)&amp;gt; find = [&amp;amp;](int x) &amp;#123;
            return x == f[x] ? x : f[x] = find(f[x]);
        &amp;#125;;
        for (auto [x, y, w] : e)
            if (find(x) != find(y)) &amp;#123;
                f.push_back(++cnt);
                W.push_back(w), g.emplace_back();
                g[cnt].push_back(find(x)), g[cnt].push_back(find(y));
                f[find(x)] = f[find(y)] = cnt;
            &amp;#125;
    &amp;#125;
    std::vector&amp;lt;int&amp;gt; fa(cnt + 1), siz(cnt + 1), dep(cnt + 1), son(cnt + 1), top(cnt + 1);
    std::function&amp;lt;void(int)&amp;gt; DFS = [&amp;amp;](int x) &amp;#123;
        siz[x] = 1;
        for (auto i : g[x]) &amp;#123;
            dep[i] = dep[x] + 1;
            DFS(i), fa[i] = x;
            siz[x] += siz[i];
            if (siz[i] &amp;gt; siz[son[x]])
                son[x] = i;
        &amp;#125;
        return;
    &amp;#125;;
    dep[1] = 1, DFS(cnt);
    DFS = [&amp;amp;](int x) &amp;#123;
        if (son[x])
            top[son[x]] = top[x], DFS(son[x]);
        for (auto i : g[x])
            if (i != son[x])
                top[i] = i, DFS(i);
        return;
    &amp;#125;;
    top[cnt] = cnt, DFS(cnt);
    auto ask = [&amp;amp;](int x, int y) &amp;#123;
        for (; top[x] != top[y]; x = fa[top[x]])
            if (dep[top[x]] &amp;lt; dep[top[y]])
                std::swap(x, y);
        return dep[x] &amp;lt; dep[y] ? x : y;
    &amp;#125;;
    for (int x, y; q--; ) &amp;#123;
        std::cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; y;
        std::cout &amp;lt;&amp;lt; W[ask(fun(x, y, 0), fun(x, y, 1)) - 2 * n * m] &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    &amp;#125;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;e---turtle-and-intersected-segments&#34;&gt;E - Turtle and Intersected Segments&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/CF1981E&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/CF1981E&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;考虑绝对值的几何意义，很容易发现有的边注定是无效的：&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&#34;image.png&#34; alt=&#34;如图中三条线段形成一个环，权值如图，排除掉权值最大的边，发现只会连权值相邻的边&#34; /&gt;&lt;figcaption&gt;如图中三条线段形成一个环，权值如图，排除掉权值最大的边，发现只会连权值相邻的边&lt;/figcaption&gt;
&lt;/figure&gt;&lt;/li&gt;
&lt;li&gt;换句话说，对于数轴上的这个点，仅需把覆盖之的所有&lt;em&gt;线段序列&lt;/em&gt;按 &lt;span class=&#34;math inline&#34;&gt;\(a\)&lt;/span&gt; 排序，连接相邻者即可。怎么更快地实现这个过程呢？&lt;/li&gt;
&lt;li&gt;&lt;p&gt;发现只需要在这个&lt;em&gt;线段序列&lt;/em&gt;变化的时候连新的边，故用 multiset 维护这个序列，扫一遍，在加入新线段时连接它和前驱后继即可（结合前文论述发现删除的时候不用管）。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int T;
    for (std::cin &amp;gt;&amp;gt; T; T--; ) &amp;#123;
        int n;
        std::cin &amp;gt;&amp;gt; n;
        struct node &amp;#123; int l, r, v; &amp;#125;;
        struct edge &amp;#123; int u, v, w; &amp;#125;;
        std::vector&amp;lt;edge&amp;gt; e;
        std::vector&amp;lt;node&amp;gt; a(n + 1);
        for (int i = 1; i &amp;lt;= n; ++i)
            std::cin &amp;gt;&amp;gt; a[i].l &amp;gt;&amp;gt; a[i].r &amp;gt;&amp;gt; a[i].v;
        std::sort(a.begin() + 1, a.end(), [&amp;amp;](node &amp;amp;x, node &amp;amp;y) &amp;#123; return x.l &amp;lt; y.l; &amp;#125;);
        std::set&amp;lt;std::tuple&amp;lt;int, int, int&amp;gt; &amp;gt; t;
        std::set&amp;lt;std::pair&amp;lt;int, int&amp;gt; &amp;gt; now;
        for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
            for (; !t.empty();) &amp;#123;
                auto [r, v, id] = *t.begin();
                if (r &amp;gt;= a[i].l)
                    break;
                now.erase(std::make_pair(v, id));
                t.erase(t.begin());
            &amp;#125;
            auto p = now.lower_bound(std::make_pair(a[i].v, i));
            if (p != now.end())
                e.push_back(&amp;#123; i, p-&amp;gt;second, p-&amp;gt;first - a[i].v &amp;#125;);
            if (p != now.begin()) &amp;#123;
                --p;
                e.push_back(&amp;#123; i, p-&amp;gt;second, a[i].v - p-&amp;gt;first &amp;#125;);
            &amp;#125;
            t.emplace(a[i].r, a[i].v, i), now.emplace(a[i].v, i);
        &amp;#125;
        std::sort(e.begin(), e.end(), [&amp;amp;](edge &amp;amp;x, edge &amp;amp;y) &amp;#123; return x.w &amp;lt; y.w; &amp;#125;);
        auto res = 0ll;
        std::vector&amp;lt;int&amp;gt; f(n + 1);
        std::iota(f.begin() + 1, f.end(), 1);
        std::function&amp;lt;int(int)&amp;gt; find = [&amp;amp;](int x) &amp;#123;
            return x == f[x] ? x : f[x] = find(f[x]);
        &amp;#125;;
        int cntm = 0;
        for (auto [u, v, w] : e)
            if (find(u) != find(v)) &amp;#123;
                f[find(u)] = find(v);
                res += w, ++cntm;
            &amp;#125;
        if (cntm == n - 1)
            std::cout &amp;lt;&amp;lt; res &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
        else
            std::cout &amp;lt;&amp;lt; -1 &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    &amp;#125;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;f---digital-village-extreme-version&#34;&gt;F - Digital Village (Extreme Version)&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/CF2021E3&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/CF2021E3&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;为啥会想到 DP（。）前面不都是神秘建图题吗（。）&lt;/li&gt;
&lt;li&gt;&lt;p&gt;会发现待求即为重构树上 LCA 的权值，但题设中的 Key 是设置了服务器的结点，二者不匹配。如果直接设 &lt;span class=&#34;math inline&#34;&gt;\(f_{x,j}\)&lt;/span&gt; 表示 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 子树内设了 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; 个服务器，感觉不太可行。&lt;/p&gt;
&lt;p&gt;当然也可能是因为我没做过重构树上的 DP。Whatever.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;实际上需要结合重构树的性质考虑。发现一个子树内部不能消化，当且仅当&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
 ]]></description>
        </item>
    </channel>
</rss>
