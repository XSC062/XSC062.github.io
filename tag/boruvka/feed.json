{
    "version": "https://jsonfeed.org/version/1",
    "title": "null • All posts by \"boruvka\" tag",
    "description": "",
    "home_page_url": "https://xsc062.netlify.app",
    "items": [
        {
            "id": "https://xsc062.netlify.app/20251013/",
            "url": "https://xsc062.netlify.app/20251013/",
            "title": "生成树 III",
            "date_published": "2025-10-13T02:35:14.000Z",
            "content_html": "<p>mst，以及 mst related</p>\n<span id=\"more\"></span>\n<hr />\n<h2 id=\"boruvka\">Boruvka</h2>\n<ul>\n<li>用途：<span class=\"math inline\">\\(O(m\\log n)\\)</span> 求 mst。</li>\n<li><p>过程：</p>\n<ul>\n<li>考虑和 Kruskal、Prim 类似的孤立点 <span class=\"math inline\">\\(\\to\\)</span> 加边 <span class=\"math inline\">\\(\\to\\)</span> 树。</li>\n<li>每一轮算法，对于当前的每个连通块，找到其连向其它连通块的边中最小的一条，并在这一轮后加入边集（用并查集维护连通块合并）。</li>\n<li>重复执行该算法，最终找到 mst。</li>\n</ul>\n<figure>\n<img src=\"mst-1.apng\" alt=\"图源 OI Wiki\">\n<figcaption>\n图源 OI Wiki\n</figcaption>\n</figure></li>\n<li>复杂度：每一轮中，每个连通块都会被合并一次，故一轮之后现存连通块数量最坏情况下变为原来的一半。也即共执行 <span class=\"math inline\">\\(\\log n\\)</span> 轮。复杂度 <span class=\"math inline\">\\(O(m\\log n)\\)</span>。</li>\n<li><p>优势：对于<strong>特殊边权</strong>的完全图 / 稠密图，边权并不由输入直接给定，而是由顶点计算得到，此时若可以依据性质直接找到连通块的最小边，则复杂度降低至 <span class=\"math inline\">\\(O(n\\log n)\\)</span> 之类非常优秀的级别（注意并查集的 log 和 Boruvka 本身的 log 是平行的）。</p>\n<p>『依据性质找到最小的边』的一个 Bonus：见 KDT + Boruvka 做法的 <a href=\"https://www.luogu.com.cn/problem/P6362\">平面欧几里得最小生成树</a>。</p></li>\n</ul>\n<hr />\n<h2 id=\"a---jumping-around\">A - Jumping Around</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/CF1550F\" class=\"uri\">https://www.luogu.com.cn/problem/CF1550F</a></p>\n<ul>\n<li>本题就是『特殊边权完全图』的体现。定义任意两个点之间的边权为两个点相互跳需要的最小的 <span class=\"math inline\">\\(k=||x_0-x_1|-d|\\)</span>，那么只需求瓶颈路。</li>\n<li><p>做 Boruvka 即可。考虑怎么求某个连通块的最小边，预处理出每个位置（包括空位）前 / 后第一个和自己颜色不同的非空位，每次 check <span class=\"math inline\">\\(i\\pm d\\)</span>：</p>\n<ul>\n<li>若该位置存在和当前位置不同颜色的点：连边。</li>\n<li>否则，若该位置和当前位置颜色相同：转到刚刚求出的前驱、后继，选更小者连边。</li>\n<li>否则该位为空。前驱、后继则转化为上面两种情况。</li>\n</ul></li>\n<li><p>和双指针做法不同，似乎并不支持离散化，只能做到 <span class=\"math inline\">\\(O(V\\log n)\\)</span>。</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int V = 1e6;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, q, s, d;\n    std::cin &gt;&gt; n &gt;&gt; q &gt;&gt; s &gt;&gt; d;\n    std::vector&lt;int&gt; a(n + 1), tab(V + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i], tab[a[i]] = i;\n    std::vector&lt;std::pair&lt;int, int&gt; &gt; to(n + 1);\n    std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; g(n + 1);\n    std::vector&lt;int&gt; u(V + 1), pre(V + 1), nex(V + 1), mn(n + 1), f(n + 1), pos;\n    std::iota(f.begin() + 1, f.end(), 1);\n    std::function&lt;int(int)&gt; find = [&amp;](int x) &#123;\n        return x == f[x] ? x : f[x] = find(f[x]);\n    &#125;;\n    for (int tot = n; tot != 1; ) &#123;\n        pos.clear();\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            if (f[i] == i) &#123;\n                mn[i] = 0x3f3f3f3f, to[i] = &#123; 0, 0 &#125;;\n                pos.push_back(i);\n            &#125;\n            u[a[i]] = find(i);\n            if (u[a[i - 1]] == u[a[i]])\n                pre[a[i]] = pre[a[i - 1]];\n            else\n                pre[a[i]] = a[i - 1];\n        &#125;\n        for (int i = 1; i &lt;= V; ++i)\n            if (!u[i])\n                pre[i] = u[i - 1] ? i - 1 : pre[i - 1];\n        nex[a[n]] = V + 1;\n        for (int i = n - 1; i; --i)\n            if (u[a[i + 1]] == u[a[i]])\n                nex[a[i]] = nex[a[i + 1]];\n            else\n                nex[a[i]] = a[i + 1];\n        nex[V] = V + 1;\n        for (int i = V - 1; i; --i)\n            if (!u[i])\n                nex[i] = u[i + 1] ? i + 1 : nex[i + 1];\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            int x = a[i], now = 0x3f3f3f3f, pos = 0;\n            auto upd = [&amp;](int x1) &#123;\n                if (std::abs(std::abs(x - x1) - d) &lt; now)\n                    now = std::abs(std::abs(x - x1) - d), pos = x1;\n                return;\n            &#125;;\n            auto trans = [&amp;](int x1) &#123;\n                if (pre[x1])\n                    upd(pre[x1]);\n                if (nex[x1] != V + 1)\n                    upd(nex[x1]);\n                return;\n            &#125;;\n            std::function&lt;void(int)&gt; work = [&amp;](int x1) &#123;\n                if (u[x1] &amp;&amp; u[x1] != u[x])\n                    upd(x1);\n                else if (u[x1])\n                    trans(x1);\n                else &#123;\n                    if (pre[x1])\n                        work(pre[x1]);\n                    if (nex[x1] != V + 1)\n                        work(nex[x1]);\n                &#125;\n                return;\n            &#125;;\n            work(std::max(1, x - d)), work(std::min(V, x + d));\n            if (now &lt; mn[u[x]])\n                mn[u[x]] = now, to[u[x]] = &#123; i, tab[pos] &#125;;\n        &#125;\n        for (auto i : pos) &#123;\n            int j = u[a[to[i].second]], x = to[i].first, y = to[i].second;\n            if (find(i) != find(j)) &#123;\n                --tot;\n                f[find(i)] = find(j);\n                g[x].emplace_back(y, mn[i]), g[y].emplace_back(x, mn[i]);\n            &#125;\n        &#125;\n    &#125;\n    std::vector&lt;int&gt; res(n + 1);\n    std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int fa) &#123;\n        for (auto [i, w] : g[x])\n            if (i != fa) &#123;\n                res[i] = std::max(res[x], w);\n                DFS(i, x);\n            &#125;\n        return;\n    &#125;;\n    DFS(s, -1);\n    for (int x, k; q--; ) &#123;\n        std::cin &gt;&gt; x &gt;&gt; k;\n        std::cout &lt;&lt; ((res[x] &lt;= k) ? &quot;Yes&quot; : &quot;No&quot;) &lt;&lt; &#39;\\n&#39;;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"b---parametric-mst\">B - Parametric MST</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/CF1656F\" class=\"uri\">https://www.luogu.com.cn/problem/CF1656F</a></p>\n<ul>\n<li>可以猜到能够把答案写出来，但是发现太抽象了以至于不太好模拟。</li>\n<li>首先需要猜到题目给的 <span class=\"math inline\">\\(w\\)</span> 是可以继续化的，注意到 <span class=\"math inline\">\\(a_i\\cdot a_j+t(a_i+a_j)\\)</span> 可以写成 <span class=\"math inline\">\\((a_j+t)\\cdot a_i+t\\cdot a_i\\)</span> 的一次函数形式，一个很重要的思路是放弃模拟 mst 转而<strong>从点出发贪心</strong></li>\n<li><p><span class=\"math inline\">\\(t\\)</span> 会影响的是斜率 <span class=\"math inline\">\\(a_j+t\\)</span>，所以<strong>应该根据 <span class=\"math inline\">\\(a_j+t\\)</span> 的正负情况选择贪心策略</strong>。</p>\n<p>当 <span class=\"math inline\">\\(a_j+t\\le 0\\)</span> 时，使 <span class=\"math inline\">\\(a_j\\)</span> 向 <span class=\"math inline\">\\(a_{\\max}\\)</span> 连边，否则向 <span class=\"math inline\">\\(a_{\\min}\\)</span> 连边。</p>\n<p>这其实是 Boruvka 第一轮的过程；此时只剩至多两个连通块，连边方式也就讨论一下 <span class=\"math inline\">\\(a_1+t\\)</span> 和 <span class=\"math inline\">\\(a_n+t\\)</span> 的正负，然后很显然了。</p></li>\n<li><p>当 <span class=\"math inline\">\\(t\\)</span> 足够小时，所有点都会连向 <span class=\"math inline\">\\(a_{\\max}\\)</span>；反之，当 <span class=\"math inline\">\\(t\\)</span> 足够大时，所有点都会连向 <span class=\"math inline\">\\(a_{\\min}\\)</span>。</p>\n<p>对于第一种情况，mst 的权为 <span class=\"math inline\">\\(a_{\\max}\\cdot (s - a_{\\max}) + t\\cdot ((n-1)\\cdot a_{\\max}+s-a_{\\max})\\)</span>；第二种情况，mst 的权为 <span class=\"math inline\">\\(a_{\\min}\\cdot (s - a_{\\min}) + t\\cdot ((n-1)\\cdot a_{\\min}+s-a_{\\min})\\)</span>，check <span class=\"math inline\">\\(t\\)</span> 的系数即可判 <code>INF</code>。</p></li>\n<li><p>通过上面一种情况，可以注意到 <span class=\"math inline\">\\(t\\in[-a_{\\max},-a_{\\min}]\\)</span>，进一步需要猜到 <span class=\"math inline\">\\(t\\)</span> 取某个 <span class=\"math inline\">\\(-a_i\\)</span>。由于连的边是很已知的，可以发现当 <span class=\"math inline\">\\(t\\)</span> 夹在两个连续的 <span class=\"math inline\">\\(-a\\)</span> 之间时，mst 的连边情况是不变的。</p>\n<p>显然此时 mst 的权是一个关于 <span class=\"math inline\">\\(t\\)</span> 的一次函数，故 check 两端点即可。排序即可快速 check。</p>\n<p>由于此时第二轮 Boruvka 要连的边一定是 <span class=\"math inline\">\\((a_1,a_n)\\)</span>，连上即可。</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int T;\n    for (std::cin &gt;&gt; T; T--; ) &#123;\n        int n;\n        std::cin &gt;&gt; n;\n        std::vector&lt;long long&gt; a(n + 1), s(n + 1);\n        for (int i = 1; i &lt;= n; ++i)\n            std::cin &gt;&gt; a[i];\n        std::sort(a.begin() + 1, a.end());\n        std::partial_sum(a.begin() + 1, a.end(), s.begin() + 1);\n        if ((n - 1) * a[n] + s[n - 1] &lt; 0ll || (n - 1) * a[1] + s[n] - a[1] &gt; 0ll)\n            std::cout &lt;&lt; &quot;INF\\n&quot;;\n        else &#123;\n            long long res = -1e18;\n            for (int i = 1; i &lt;= n; ++i) &#123;\n                auto t = -a[i], sl = s[i] - a[1], sr = s[n - 1] - s[i];\n                res = std::max(res, a[n] * sl + a[1] * sr + t * ((i - 1) * a[n] + (n - 1 - i) * a[1] + sl + sr) + a[1] * a[n] + t * (a[1] + a[n]));\n            &#125;\n            std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n        &#125;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"c---star-mst\">C - Star MST</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/CF1657E\" class=\"uri\">https://www.luogu.com.cn/problem/CF1657E</a></p>\n<ul>\n<li>模拟 Kruskal 的过程，在边权 <span class=\"math inline\">\\(w\\)</span> 处出现 <span class=\"math inline\">\\((1,x)\\)</span>，那么允许在 <span class=\"math inline\">\\(\\ge w\\)</span> 处出现其他与 <span class=\"math inline\">\\(x\\)</span> 相关的边。</li>\n<li>会有一个比较暴力的想法，设 <span class=\"math inline\">\\(f_{i,j,l}\\)</span> 表示已经分配完边权 <span class=\"math inline\">\\(i\\)</span>，共分配了 <span class=\"math inline\">\\(j\\)</span> 条与 <span class=\"math inline\">\\(1\\)</span> 相关的边，还剩下 <span class=\"math inline\">\\(l\\)</span> 条空闲边可以放，会有一个 <span class=\"math inline\">\\(O(k\\cdot n^4)\\)</span> 的转移。</li>\n<li><p>考虑优化。容易注意到没必要存 <span class=\"math inline\">\\(l\\)</span> 而是可以当场完成分配，但这样就导致 <span class=\"math inline\">\\(i\\)</span> 维的限制转化为『恰好』，需要额外枚举一轮。总之可以得到：</p>\n<p><span class=\"math display\">\\[\nf_{i,j}=\\sum_{d_i=1}^{i}\\sum_{d_j=1}^{j} C_{n-(j-d_j)}^{d_j}\\times f_{i-d_i,j-d_j}\\times (k-i+1)^{C_{d_j}^2+d_j\\times (j-d_j)}\n\\]</span></p>\n<p>此时复杂度为 <span class=\"math inline\">\\(O(k^2n^2\\log k)\\)</span>，依然不够看；注意到交换求和顺序可以前缀和优化，故：</p>\n<p><span class=\"math display\">\\[\nf_{j, i}=\\sum_{d_j=1}^{j} C_{n-(j-d_j)}^{d_j}\\times (k-i+1)^{C_{d_j}^2+d_j\\times (j-d_j)}\\times \\sum_{d_i=1}^{i}f_{j - d_j,i-d_i}\n\\]</span></p>\n<p>复杂度 <span class=\"math inline\">\\(O(kn^2\\log k)\\)</span>。<span class=\"math inline\">\\(\\log\\)</span> 来源于快速幂。当然可以考虑预处理优化掉 log，whatever.</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 998244353;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, k;\n    std::cin &gt;&gt; n &gt;&gt; k;\n    std::vector&lt;std::vector&lt;long long&gt; &gt; C(n + 1, std::vector&lt;long long&gt; (n + 1));\n    for (int i = 0; i &lt;= n; ++i) &#123;\n        C[i][0] = 1ll;\n        for (int j = 1; j &lt;= i; ++j)\n            C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % mod;\n    &#125;\n    auto qkp = [&amp;](long long x, int y) &#123;\n        auto res = 1ll;\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    std::vector&lt;std::vector&lt;long long&gt; &gt; s(n, std::vector&lt;long long&gt; (k + 1));\n    for (int i = 0; i &lt;= k; ++i)\n        s[0][i] = 1ll;\n    for (int j = 1; j &lt; n; ++j)\n        for (int i = 1; i &lt;= k; ++i) &#123;\n            for (int dj = 1; dj &lt;= j; ++dj) \n                s[j][i] += C[n - (j - dj) - 1][dj] * qkp(k - i + 1, (C[dj][2] + dj * (j - dj)) % mod) % mod * s[j - dj][i - 1] % mod;\n            (s[j][i] += s[j][i - 1]) %= mod;\n        &#125;\n    std::cout &lt;&lt; s[n - 1][k] &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"d---smooth-sailing-hard-version\">D - Smooth Sailing (Hard Version)</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/CF1920F2\" class=\"uri\">https://www.luogu.com.cn/problem/CF1920F2</a></p>\n<ul>\n<li><p>实在十分熟悉，之前在哪道 CF 题遇到过这个 trick，然而没什么回忆线索，遂放弃</p>\n<p>一个连通块被包围的充要条件：从连通块边缘任意一个点向任意方向发一条射线，<em>垂直</em>经过路径奇数次。</p>\n<p><em>垂直</em>：即切线不切换奇偶状态。</p>\n<p>这个东西其实来源于计算几何，但是我的数学水平只停留在听说过计算几何四个字的水平，故不深究了。</p>\n<p>这种网格图上的图论问题，可以往欧拉定理（<span class=\"math inline\">\\(v-e+f=2\\)</span>），计算几何考虑，</p></li>\n<li><p>怎么在保证这一点的前提下求 mst 呢？答案是丢到状态里。</p>\n<p>找一个最靠左的点往左边引一条射线并标记沿路经过的点。令 <span class=\"math inline\">\\((x, y, 0/1)\\)</span> 表示走到 <span class=\"math inline\">\\((x, y)\\)</span>，经过关键点偶数次 / 奇数次。边权啥的也没什么好说的，点权前移即可。</p></li>\n<li><p>询问的转化反而不太好想，其实就是问 <span class=\"math inline\">\\((x,y,0)\\)</span> 到 <span class=\"math inline\">\\((x,y,1)\\)</span> 的瓶颈路。</p>\n<p>巧得有些不太自然，然而并没找到合理的解释。</p></li>\n<li><p>询问建个 Kruskal 重构树找 LCA 即可，复杂度 <span class=\"math inline\">\\(O(nm\\log nm)\\)</span>。</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int dir[][2] = &#123;&#123; -1, 0 &#125;, &#123; 1, 0 &#125;, &#123; 0, -1 &#125;, &#123; 0, 1 &#125;&#125;;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, m, q;\n    std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;\n    int cnt = 2 * n * m;\n    std::vector&lt;int&gt; W(1);\n    std::vector&lt;std::vector&lt;int&gt; &gt; g(2 * n * m + 1);\n    auto fun = [&amp;](int i, int j, int k) &#123;\n        return k * n * m + (i - 1) * m + j;\n    &#125;;\n    &#123;\n        int px = 0, py = m + 1;\n        std::vector&lt;std::vector&lt;char&gt; &gt; a(n + 1, std::vector&lt;char&gt; (m + 1));\n        for (int i = 1; i &lt;= n; ++i)\n            for (int j = 1; j &lt;= m; ++j) &#123;\n                std::cin &gt;&gt; a[i][j];\n                if (a[i][j] == &#39;#&#39; &amp;&amp; j &lt; py)\n                    px = i, py = j;\n            &#125;\n        std::vector&lt;std::vector&lt;int&gt; &gt; w(n + 1, std::vector&lt;int&gt; (m + 1, 0x3f3f3f3f));\n        &#123;\n            std::queue&lt;std::pair&lt;int, int&gt; &gt; q;\n            for (int i = 1; i &lt;= n; ++i)\n                for (int j = 1; j &lt;= m; ++j)\n                    if (a[i][j] == &#39;v&#39;)\n                        q.emplace(i, j), w[i][j] = 0;\n            for (; !q.empty(); ) &#123;\n                auto [x, y] = q.front();\n                q.pop();\n                for (auto [fx, fy] : dir) &#123;\n                    int nx = x + fx, ny = y + fy;\n                    if (nx &gt;= 1 &amp;&amp; nx &lt;= n &amp;&amp; ny &gt;= 1 &amp;&amp; ny &lt;= m &amp;&amp; w[nx][ny] == 0x3f3f3f3f) &#123;\n                        w[nx][ny] = w[x][y] + 1;\n                        q.emplace(nx, ny);\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n        struct edge &#123; int u, v, w; &#125;;\n        std::vector&lt;edge&gt; e;\n        for (int i = 1; i &lt;= n; ++i)\n            for (int j = 1; j &lt;= m; ++j)\n                if (a[i][j] != &#39;#&#39;) &#123;\n                    if (j != m &amp;&amp; a[i][j + 1] != &#39;#&#39;) &#123;\n                        e.push_back(&#123; fun(i, j, 0), fun(i, j + 1, 0), std::min(w[i][j], w[i][j + 1]) &#125;);\n                        e.push_back(&#123; fun(i, j, 1), fun(i, j + 1, 1), std::min(w[i][j], w[i][j + 1]) &#125;);\n                    &#125;\n                    if (i != n &amp;&amp; a[i + 1][j] != &#39;#&#39;) &#123;\n                        if (i + 1 == px &amp;&amp; j &lt;= py) &#123;\n                            e.push_back(&#123; fun(i, j, 0), fun(i + 1, j, 1), std::min(w[i][j], w[i + 1][j]) &#125;);\n                            e.push_back(&#123; fun(i, j, 1), fun(i + 1, j, 0), std::min(w[i][j], w[i + 1][j]) &#125;);\n                        &#125;\n                        else &#123;\n                            e.push_back(&#123; fun(i, j, 0), fun(i + 1, j, 0), std::min(w[i][j], w[i + 1][j]) &#125;);\n                            e.push_back(&#123; fun(i, j, 1), fun(i + 1, j, 1), std::min(w[i][j], w[i + 1][j]) &#125;);\n                        &#125;\n                    &#125;\n                &#125;\n        std::sort(e.begin(), e.end(), [&amp;](edge &amp;x, edge &amp;y) &#123; return x.w &gt; y.w; &#125;);\n        std::vector&lt;int&gt; f(2 * n * m + 1);\n        std::iota(f.begin() + 1, f.end(), 1);\n        std::function&lt;int(int)&gt; find = [&amp;](int x) &#123;\n            return x == f[x] ? x : f[x] = find(f[x]);\n        &#125;;\n        for (auto [x, y, w] : e)\n            if (find(x) != find(y)) &#123;\n                f.push_back(++cnt);\n                W.push_back(w), g.emplace_back();\n                g[cnt].push_back(find(x)), g[cnt].push_back(find(y));\n                f[find(x)] = f[find(y)] = cnt;\n            &#125;\n    &#125;\n    std::vector&lt;int&gt; fa(cnt + 1), siz(cnt + 1), dep(cnt + 1), son(cnt + 1), top(cnt + 1);\n    std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;\n        siz[x] = 1;\n        for (auto i : g[x]) &#123;\n            dep[i] = dep[x] + 1;\n            DFS(i), fa[i] = x;\n            siz[x] += siz[i];\n            if (siz[i] &gt; siz[son[x]])\n                son[x] = i;\n        &#125;\n        return;\n    &#125;;\n    dep[1] = 1, DFS(cnt);\n    DFS = [&amp;](int x) &#123;\n        if (son[x])\n            top[son[x]] = top[x], DFS(son[x]);\n        for (auto i : g[x])\n            if (i != son[x])\n                top[i] = i, DFS(i);\n        return;\n    &#125;;\n    top[cnt] = cnt, DFS(cnt);\n    auto ask = [&amp;](int x, int y) &#123;\n        for (; top[x] != top[y]; x = fa[top[x]])\n            if (dep[top[x]] &lt; dep[top[y]])\n                std::swap(x, y);\n        return dep[x] &lt; dep[y] ? x : y;\n    &#125;;\n    for (int x, y; q--; ) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y;\n        std::cout &lt;&lt; W[ask(fun(x, y, 0), fun(x, y, 1)) - 2 * n * m] &lt;&lt; &#39;\\n&#39;;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"e---turtle-and-intersected-segments\">E - Turtle and Intersected Segments</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/CF1981E\" class=\"uri\">https://www.luogu.com.cn/problem/CF1981E</a></p>\n<ul>\n<li><p>考虑绝对值的几何意义，很容易发现有的边注定是无效的：</p>\n<figure>\n<img src=\"image.png\" alt=\"如图中三条线段形成一个环，权值如图，排除掉权值最大的边，发现只会连权值相邻的边\" /><figcaption>如图中三条线段形成一个环，权值如图，排除掉权值最大的边，发现只会连权值相邻的边</figcaption>\n</figure></li>\n<li>换句话说，对于数轴上的这个点，仅需把覆盖之的所有<em>线段序列</em>按 <span class=\"math inline\">\\(a\\)</span> 排序，连接相邻者即可。怎么更快地实现这个过程呢？</li>\n<li><p>发现只需要在这个<em>线段序列</em>变化的时候连新的边，故用 multiset 维护这个序列，扫一遍，在加入新线段时连接它和前驱后继即可（结合前文论述发现删除的时候不用管）。</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int T;\n    for (std::cin &gt;&gt; T; T--; ) &#123;\n        int n;\n        std::cin &gt;&gt; n;\n        struct node &#123; int l, r, v; &#125;;\n        struct edge &#123; int u, v, w; &#125;;\n        std::vector&lt;edge&gt; e;\n        std::vector&lt;node&gt; a(n + 1);\n        for (int i = 1; i &lt;= n; ++i)\n            std::cin &gt;&gt; a[i].l &gt;&gt; a[i].r &gt;&gt; a[i].v;\n        std::sort(a.begin() + 1, a.end(), [&amp;](node &amp;x, node &amp;y) &#123; return x.l &lt; y.l; &#125;);\n        std::set&lt;std::tuple&lt;int, int, int&gt; &gt; t;\n        std::set&lt;std::pair&lt;int, int&gt; &gt; now;\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            for (; !t.empty();) &#123;\n                auto [r, v, id] = *t.begin();\n                if (r &gt;= a[i].l)\n                    break;\n                now.erase(std::make_pair(v, id));\n                t.erase(t.begin());\n            &#125;\n            auto p = now.lower_bound(std::make_pair(a[i].v, i));\n            if (p != now.end())\n                e.push_back(&#123; i, p-&gt;second, p-&gt;first - a[i].v &#125;);\n            if (p != now.begin()) &#123;\n                --p;\n                e.push_back(&#123; i, p-&gt;second, a[i].v - p-&gt;first &#125;);\n            &#125;\n            t.emplace(a[i].r, a[i].v, i), now.emplace(a[i].v, i);\n        &#125;\n        std::sort(e.begin(), e.end(), [&amp;](edge &amp;x, edge &amp;y) &#123; return x.w &lt; y.w; &#125;);\n        auto res = 0ll;\n        std::vector&lt;int&gt; f(n + 1);\n        std::iota(f.begin() + 1, f.end(), 1);\n        std::function&lt;int(int)&gt; find = [&amp;](int x) &#123;\n            return x == f[x] ? x : f[x] = find(f[x]);\n        &#125;;\n        int cntm = 0;\n        for (auto [u, v, w] : e)\n            if (find(u) != find(v)) &#123;\n                f[find(u)] = find(v);\n                res += w, ++cntm;\n            &#125;\n        if (cntm == n - 1)\n            std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n        else\n            std::cout &lt;&lt; -1 &lt;&lt; &#39;\\n&#39;;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"f---digital-village-extreme-version\">F - Digital Village (Extreme Version)</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/CF2021E3\" class=\"uri\">https://www.luogu.com.cn/problem/CF2021E3</a></p>\n<ul>\n<li>为啥会想到 DP（。）前面不都是神秘建图题吗（。）</li>\n<li><p>会发现待求即为重构树上 LCA 的权值，但题设中的 Key 是设置了服务器的结点，二者不匹配。如果直接设 <span class=\"math inline\">\\(f_{x,j}\\)</span> 表示 <span class=\"math inline\">\\(x\\)</span> 子树内设了 <span class=\"math inline\">\\(j\\)</span> 个服务器，感觉不太可行。</p>\n<p>当然也可能是因为我没做过重构树上的 DP。Whatever.</p></li>\n<li><p>实际上需要结合重构树的性质考虑。发现一个子树内部不能消化，当且仅当</p></li>\n</ul>\n",
            "tags": [
                "最小生成树",
                "Kruskal 重构树",
                "Boruvka"
            ]
        }
    ]
}