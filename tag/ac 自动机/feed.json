{
    "version": "https://jsonfeed.org/version/1",
    "title": "null • All posts by \"ac 自动机\" tag",
    "description": "",
    "home_page_url": "https://xsc062.netlify.app",
    "items": [
        {
            "id": "https://xsc062.netlify.app/20250816/",
            "url": "https://xsc062.netlify.app/20250816/",
            "title": "近期杂题 II",
            "date_published": "2025-08-16T08:14:12.000Z",
            "content_html": "<p>和 Aug 9th 的杂题不太能合并，所以分开了</p>\n<span id=\"more\"></span>\n<hr />\n<h2 id=\"b.-gas-fire-extinguishers\">B. GAS-Fire Extinguishers</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P3479\" class=\"uri\">https://www.luogu.com.cn/problem/P3479</a></p>\n<p>显然可以贪心，不妨从下到上，记录当前遍历过的、空余出来的灭火器（其实算的是可以供给的房间数）和还未分配灭火器的房间，按距离为 <span class=\"math inline\">\\(0\\sim k\\)</span> 分组。</p>\n<p>不难发现如果在某个点 <span class=\"math inline\">\\(u\\)</span> 处存在距离为 <span class=\"math inline\">\\(k\\)</span> 的空闲灭火器，可以贪心地分配给 <span class=\"math inline\">\\(u\\)</span>；如果存在距离为 <span class=\"math inline\">\\(k\\)</span> 的未分配房间，也可以在 <span class=\"math inline\">\\(u\\)</span> 处放置灭火器并分配给这些房间。类似地，进行两两配对一定是不劣的。</p>\n<p>发现同子树内距离为 <span class=\"math inline\">\\(k-1\\)</span> 的点对留到 <span class=\"math inline\">\\(fa\\)</span> 再匹配是不行的，因为这时距离会变成 <span class=\"math inline\">\\(k+1\\)</span>，不能匹配上；可以感受到这样是更劣的。</p>\n<p>然后就可以做了，根节点特殊乱贪心一下就行了。记得开 long long。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\n#define int long long\nsigned main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, s, k, res = 0;\n    std::cin &gt;&gt; n &gt;&gt; s &gt;&gt; k;\n    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1), p(n + 1, std::vector&lt;int&gt; (k + 1)), q(n + 1, std::vector&lt;int&gt; (k + 1));\n    for (int i = 1, x, y; i &lt; n; ++i) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y;\n        g[x].push_back(y), g[y].push_back(x);\n    &#125;\n    std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int fa) &#123;\n        for (auto i : g[x])\n            if (i != fa)  &#123;\n                DFS(i, x);\n                for (int j = 0; j &lt; k; ++j)\n                    p[x][j + 1] += p[i][j], q[x][j + 1] += q[i][j];\n            &#125;\n        ++q[x][0];\n        if (x != 1) &#123;\n            int v = (q[x][k] + s - 1) / s;\n            p[x][0] = v * s, res += v;\n            for (int i = 0; i &lt;= k; ++i) &#123;\n                int v = std::min(p[x][i], q[x][k - i]);\n                p[x][i] -= v, q[x][k - i] -= v;\n            &#125;\n            for (int i = 0; i &lt; k; ++i) &#123;\n                int v = std::min(p[x][i], q[x][k - 1 - i]);\n                p[x][i] -= v, q[x][k - 1 - i] -= v;\n            &#125;\n        &#125;\n        else &#123;\n            // std::cerr &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n            int sum = 0ll, r = 0;\n            for (int i = k; ~i; --i) &#123;\n                sum += p[x][k - i];\n                // std::cerr &lt;&lt; sum &lt;&lt; &#39;\\n&#39;;\n                int v = std::min(sum, q[x][i]);\n                sum -= v, q[x][i] -= v;\n                r += q[x][i];\n            &#125;\n            res += (r + s - 1) / s;\n        &#125;\n        return;\n    &#125;;\n    DFS(1, -1);\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"c.-扫地机器人\">C. 扫地机器人</h2>\n<p><a href=\"http://222.180.160.110:61235/contest/6502/problem/3\" class=\"uri\">http://222.180.160.110:61235/contest/6502/problem/3</a></p>\n<blockquote>\n<p>题意：给定 <span class=\"math inline\">\\(n\\)</span> 堆货物，每堆货物有重量 <span class=\"math inline\">\\(v_i\\)</span> 和一个参数 <span class=\"math inline\">\\(a_i\\)</span>。有一个初始负载为 <span class=\"math inline\">\\(0\\)</span>、负载上限为 <span class=\"math inline\">\\(c\\)</span> 的机器人，从 <span class=\"math inline\">\\(1\\)</span> 到 <span class=\"math inline\">\\(n\\)</span> 遍历这些货物，对每一处货物执行以下操作，直到清空这堆货物：</p>\n<ul>\n<li>当前负载未满：可以选择进行装载直到达到负载上限，或货物清空。花费 <span class=\"math inline\">\\(a_i\\)</span> 的代价。</li>\n<li>不管当前负载满没满：可以选择清空当前负载，花费 <span class=\"math inline\">\\(b\\)</span> 的代价。</li>\n</ul>\n<p>每一处可以任意操作，要求遍历完之后机器人负载为 <span class=\"math inline\">\\(0\\)</span>，问最小代价。<span class=\"math inline\">\\(n\\le 2\\times 10^5,c\\le 10^9\\)</span>。</p>\n</blockquote>\n<p><em>题面是重构过的，原来的题面太有歧义了。绝大多数人没做出来就是因为没看懂题吧！</em></p>\n<p>考虑暴力，可以想到令 <span class=\"math inline\">\\(f_{i,j}\\)</span> 表示处理完 <span class=\"math inline\">\\(i\\)</span> 过后负载为 <span class=\"math inline\">\\(j\\)</span> 的最小代价（显然 <span class=\"math inline\">\\(f_{i,c}\\)</span> 和 <span class=\"math inline\">\\(f_{i,0}\\)</span> 是等效的，故舍弃前者）。记 <span class=\"math inline\">\\(k=\\left\\lceil\\dfrac {v_i}c\\right\\rceil,w=(v_i\\bmod c - 1)\\bmod c+1\\)</span>，那么有：</p>\n<p><span class=\"math display\">\\[\nf_{i,(j+v_i)\\bmod c}\\gets f_{i-1,j}+k\\cdot a_i+(k-1)\\cdot b +\n\\begin{cases}\nb&amp;j+w=c\\\\\na_i+b&amp;j+w&gt; c\\\\\n0&amp;\\text{otherwise}\n\\end{cases}\\\\\nf_{i,0}\\gets f_{i,j}+b\n\\]</span></p>\n<p>发现 <span class=\"math inline\">\\(f_{i-1}\\)</span> 和 <span class=\"math inline\">\\(f_i\\)</span> 之间是存在对应关系的，所以考虑直接继承（真实的 <span class=\"math inline\">\\(0\\)</span> 应该位于 <span class=\"math inline\">\\(-s_i\\)</span> 的位置），再做全局加、区间加，<span class=\"math inline\">\\(f_{i,0}\\)</span> 的转移是全局 min，线段树维护即可；每次只会新增一个状态，动态开点即可。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 5e6 + 5;\nconst __int128 inf = 1e18;\nstruct &#123;\n    int l, r;\n    __int128 u, d;\n&#125; t[maxn];\n#define lt t[p].l\n#define rt t[p].r\nint tot;\nvoid pushdown(int p) &#123;\n    if (t[p].d) &#123;\n        t[lt].d += t[p].d, t[lt].u += t[p].d;\n        t[rt].d += t[p].d, t[rt].u += t[p].d;\n        t[p].d = 0ll;\n    &#125;\n    return;\n&#125;\nvoid upd(int &amp;p, int l, int r, int x, __int128 v) &#123;\n    if (!p)\n        p = ++tot, t[p].u = v;\n    else\n        t[p].u = std::min(t[p].u, v);\n    if (l == r)\n        return;\n    pushdown(p);\n    int mid = (l + r) &gt;&gt; 1;\n    if (x &lt;= mid)\n        upd(lt, l, mid, x, v);\n    else\n        upd(rt, mid + 1, r, x, v);\n    return;\n&#125;\nvoid add(int p, int l, int r, int ql, int qr, __int128 v) &#123;\n    if (!p)\n        return;\n    if (ql &lt;= l &amp;&amp; r &lt;= qr) &#123;\n        t[p].d += v, t[p].u += v;\n        return;\n    &#125;\n    int mid = (l + r) &gt;&gt; 1;\n    pushdown(p);\n    if (ql &lt;= mid)\n        add(lt, l, mid, ql, qr, v);\n    if (qr &gt; mid)\n        add(rt, mid + 1, r, ql, qr, v);\n    t[p].u = std::min(t[lt].u, t[rt].u);\n    return;\n&#125;\n__int128 ask(int p, int l, int r, int x) &#123;\n    if (l == r)\n        return t[p].u;\n    int mid = (l + r) &gt;&gt; 1;\n    pushdown(p);\n    if (x &lt;= mid)\n        return ask(lt, l, mid, x);\n    return ask(rt, mid + 1, r, x);\n&#125;\n#undef lt\n#undef rt\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n    std::freopen(&quot;robot.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;robot.out&quot;, &quot;w&quot;, stdout);\n#else\n    std::freopen(&quot;ex_robot4.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    t[0].u = inf;\n    int n, b, c, p0 = 0, rt = 0;\n    std::cin &gt;&gt; n &gt;&gt; c &gt;&gt; b;\n    std::vector&lt;int&gt; a(n + 1), v(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i];\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; v[i];\n    upd(rt, 0, c - 1, 0, 0ll);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        __int128 k = (v[i] + c - 1) / c, w = (v[i] % c == 0 ? c : v[i] % c);\n        t[rt].d += k * a[i] + (k - 1) * b;\n        t[rt].u += k * a[i] + (k - 1) * b;\n        if (w &lt;= c)\n            add(rt, 0, c - 1, (c - w + p0) % c, (c - w + p0) % c, b);\n        if (w != 1) &#123;\n            int l = (c - w + p0 + 1) % c, r = (p0 + c - 1) % c;\n            if (l &lt;= r)\n                add(rt, 0, c - 1, l, r, a[i] + b);\n            else &#123;\n                add(rt, 0, c - 1, 0, r, a[i] + b);\n                add(rt, 0, c - 1, l, c - 1, a[i] + b);\n            &#125;\n        &#125;\n        p0 = (p0 + c - v[i] % c) % c;\n        upd(rt, 0, c - 1, p0, t[rt].u + b);\n    &#125;\n    std::cout &lt;&lt; (long long)ask(rt, 0, c - 1, p0) &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"d.-套娃\">D. 套娃</h2>\n<p><a href=\"http://222.180.160.110:61235/contest/6502/problem/4\" class=\"uri\">http://222.180.160.110:61235/contest/6502/problem/4</a></p>\n<blockquote>\n<p>题意：给定初始为全 <span class=\"math inline\">\\(0\\)</span> 的数组 <span class=\"math inline\">\\(a_{1\\sim n + 1}\\)</span> 和 <span class=\"math inline\">\\(n\\)</span> 次单点 +1 操作，每次操作后，求解：</p>\n<p>令 <span class=\"math inline\">\\(a\\)</span> 的前缀和数组为 <span class=\"math inline\">\\(s\\)</span>，找到一个最小的 <span class=\"math inline\">\\(k\\)</span>，使得对于每个 <span class=\"math inline\">\\(i\\)</span>，均有 <span class=\"math inline\">\\(k\\cdot i\\ge s_i\\)</span> 成立。</p>\n<p><span class=\"math inline\">\\(n\\le 10^6\\)</span>，时限 0.5s。</p>\n</blockquote>\n<details>\n<p><summary>趣事一则</summary></p>\n<p>考场上最后 10min 拿到题，憋了一个能拿到 96pts 的假做法：注意到前缀和是单增的，需要维护最大的 <span class=\"math inline\">\\(\\dfrac {s_i}i\\)</span>，由于后缀 +1 带来的影响很小，所以可以猜测在大多数情况下最大的 <span class=\"math inline\">\\(i\\)</span> 只会在原来的和修改的点之间变化。只用 10 行的核心代码就能拿到很多分。但是居然有这么多，可能出题人都没有想到真有人敢交这种做法吧。</p>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n    std::freopen(&quot;doll.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;doll.out&quot;, &quot;w&quot;, stdout);\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n    auto stime = std::chrono::steady_clock::now();\n    int n, res = 0;\n    std::cin &gt;&gt; n;\n    std::vector&lt;int&gt; bit(n + 2);\n    auto lowbit = [](int x) &#123;\n        return x &amp; -x;\n    &#125;;\n    auto add = [&amp;](int x) &#123;\n        for (; x &lt;= n + 1; x += lowbit(x))\n            ++bit[x];\n        return;\n    &#125;;\n    auto ask = [&amp;](int x) &#123;\n        int res = 0;\n        for (; x; x -= lowbit(x))\n            res += bit[x];\n        return res;\n    &#125;;\n    int p = 1;\n    for (int i = 1, x; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; x, add(++x);\n        long long s = ask(x), t = ask(p);\n        if (s * p == t * x ? x &gt; p : s * p &gt; t * x)\n            p = x;\n        else\n            s = t;\n        if (s &gt; p * res)\n            ++res;\n        std::cout &lt;&lt; res &lt;&lt; &#39; &#39;;\n    &#125;\n    std::cout &lt;&lt; &#39;\\n&#39;;\n    std::cerr &lt;&lt; std::chrono::duration&lt;double&gt;(std::chrono::steady_clock::now() - stime).count() &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<p>很容易写出暴力，观察样例就能发现每次修改后答案最多增加 <span class=\"math inline\">\\(1\\)</span>。记当前答案为 <span class=\"math inline\">\\(res\\)</span>，线段树维护 <span class=\"math inline\">\\(s_i-res\\cdot i\\)</span> 的最小值，若其为负则 res++，然后重构线段树（等差数列和 min 不兼容）。</p>\n<p>怎么又有不等式 😱</p>\n<p>目的是在本来合法的范围里找到新的不合法值。考虑合法范围：<span class=\"math inline\">\\(s_i-res\\cdot i\\ge 0\\)</span>，解一下得到 <span class=\"math inline\">\\(i\\le \\dfrac {s_i}{res}\\)</span>，放缩得到 <span class=\"math inline\">\\(i\\le\\dfrac {n}{res}\\)</span>，每次 <span class=\"math inline\">\\(res\\)</span> 变化时只重构 <span class=\"math inline\">\\(\\dfrac {n}{res}\\)</span> 以前的位置，重构的总长是 <span class=\"math inline\">\\(O(n\\ln n)\\)</span> 的。（线段树建树是线性的）</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 1e6 + 5;\nconst int inf = 0x3f3f3f3f;\nstruct &#123;\n    int l, r, u, d;\n&#125; t[maxn &lt;&lt; 2];\n#define lt (p &lt;&lt; 1)\n#define rt (lt | 1)\nvoid bld(int p, int l, int r) &#123;\n    t[p].u = t[p].l = l, t[p].r = r;\n    if (l == r)\n        return;\n    int mid = (l + r) &gt;&gt; 1;\n    bld(lt, l, mid), bld(rt, mid + 1, r);\n    return;\n&#125;\nvoid pushdown(int p) &#123;\n    if (t[p].d) &#123;\n        t[lt].d += t[p].d, t[rt].d += t[p].d;\n        t[lt].u -= t[p].d, t[rt].u -= t[p].d;\n        t[p].d = 0;\n    &#125;\n    return;\n&#125;\nvoid add(int p, int x) &#123;\n    if (x &lt;= t[p].l) &#123;\n        ++t[p].d, --t[p].u;\n        return;\n    &#125;\n    pushdown(p);\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (x &lt;= mid)\n        add(lt, x);\n    add(rt, x);\n    t[p].u = std::min(t[lt].u, t[rt].u);\n    // printf(&quot;[%d, %d]: %d, [%d, %d]: %d\\n&quot;, t[p].l, mid, t[lt].u, mid + 1, t[p].r, t[rt].u);\n    return;\n&#125;\nvoid rem(int p, int r) &#123;\n    if (t[p].l == t[p].r) &#123;\n        t[p].u += t[p].l;\n        return;\n    &#125;\n    pushdown(p);\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (r &lt;= mid)\n        rem(lt, r), t[rt].u = inf;\n    else\n        rem(lt, r), rem(rt, r);\n    t[p].u = std::min(t[lt].u, t[rt].u);\n    return;\n&#125;\n#undef lt\n#undef rt\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n    std::freopen(&quot;doll.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;doll.out&quot;, &quot;w&quot;, stdout);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    bld(1, 1, n + 1);\n    for (int i = 1, x, res = 1, now = n; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; x;\n        if (x &lt;= now)\n            add(1, ++x);\n        if (t[1].u &lt; 0) &#123;\n            std::cout &lt;&lt; ++res &lt;&lt; &#39; &#39;;\n            rem(1, now = n / res);\n        &#125;\n        else\n            std::cout &lt;&lt; res &lt;&lt; &#39; &#39;;\n        // puts(&quot;&quot;);\n    &#125;\n    std::cout &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"e---subarray-sum-divisibility\">E - Subarray Sum Divisibility</h2>\n<p><a href=\"https://atcoder.jp/contests/abc419/tasks/abc419_e\" class=\"uri\">https://atcoder.jp/contests/abc419/tasks/abc419_e</a></p>\n<p>模意义下的数列全等，可以对应原数组全等、差分全等、前缀和全等（都是模意义下的，还有其他的一些线性和非线性的变换也可以）</p>\n<p>本着修改的点尽量少的想法，如果题目给定单点修改就可以在原数组上做文章，给定区间修改可以考虑差分数组，前缀和对于一些区间查询有优势</p>\n<p>其他两种用得也很多，像这题只需要用原数组全等就可以做了</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int inf = 0x3f3f3f3f;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, m, l;\n    std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; l;\n    std::vector&lt;int&gt; a(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i];\n    std::vector&lt;std::vector&lt;int&gt; &gt; u(l + 1, std::vector&lt;int&gt; (m));\n    for (int i = 1; i &lt;= l; ++i)\n        for (int j = 0; j &lt; m; ++j)\n            for (int k = i; k &lt;= n; k += l)\n                u[i][j] += (j + m - a[k]) % m;\n    std::vector&lt;std::vector&lt;int&gt; &gt; f(l + 1, std::vector&lt;int&gt; (m, inf));\n    f[0][0] = 0;\n    for (int i = 1; i &lt;= l; ++i)\n        for (int j = 0; j &lt; m; ++j)\n            for (int k = 0; k &lt; m; ++k)\n                f[i][(j + k) % m] = std::min(f[i][(j + k) % m], f[i - 1][j] + u[i][k]);\n    std::cout &lt;&lt; f[l][0] &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;\n</code></pre>\n</details>\n<hr />\n<h2 id=\"f---all-included\">F - All Included</h2>\n<p><a href=\"https://atcoder.jp/contests/abc419/tasks/abc419_f\" class=\"uri\">https://atcoder.jp/contests/abc419/tasks/abc419_f</a></p>\n<p>原题意转化为在 AC 自动机上走 <span class=\"math inline\">\\(L\\)</span> 步，要求经过 <span class=\"math inline\">\\(n\\)</span> 个叶子的方案数。不太可做，转化成容斥（令字符串终点不可达）。在外层枚举步数暴力游走。</p>\n<p>要求恰好走 <span class=\"math inline\">\\(L\\)</span> 步，也可以用矩阵；但原图很稀疏，所以矩阵并没有优势。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 998244353;\nint tot = 1, T[805][26], fail[805];\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, l;\n    std::cin &gt;&gt; n &gt;&gt; l;\n    std::vector&lt;std::string&gt; a;\n    &#123;\n        std::vector&lt;std::string&gt; s(n + 1);\n        for (int i = 1; i &lt;= n; ++i)\n            std::cin &gt;&gt; s[i];\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            bool flag = 1;\n            for (int j = 1; j &lt;= n; ++j)\n                if (j != i)\n                    if (s[j].find(s[i]) != std::string::npos) &#123;\n                        flag = 0;\n                        break;\n                    &#125;\n            if (flag)\n                a.push_back(s[i]);\n        &#125;\n        n = (int)a.size();\n    &#125;\n    std::vector&lt;int&gt; pos(n);\n    for (int i = 0; i &lt; n; ++i) &#123;\n        int &amp;p = pos[i];\n        for (auto j : a[i]) &#123;\n            if (!T[p][j - &#39;a&#39;])\n                T[p][j - &#39;a&#39;] = tot++;\n            p = T[p][j - &#39;a&#39;];\n        &#125;\n    &#125;\n    &#123;\n        std::queue&lt;int&gt; q;\n        for (int i = 0; i &lt; 26; ++i)\n            if (T[0][i])\n                q.push(T[0][i]);\n        for (; !q.empty(); ) &#123;\n            int u = q.front();\n            q.pop();\n            for (int i = 0; i &lt; 26; ++i)\n                if (T[u][i]) &#123;\n                    int v = T[u][i];\n                    fail[v] = T[fail[u]][i];\n                    q.push(v);\n                &#125;\n                else\n                    T[u][i] = T[fail[u]][i];\n        &#125;\n    &#125;\n    auto res = 0ll;\n    int siz = 1 &lt;&lt; n;\n    for (int i = 0; i &lt; siz; ++i) &#123;\n        std::vector&lt;int&gt; tag(tot);\n        for (int j = 0; j &lt; n; ++j)\n            if ((i &gt;&gt; j) &amp; 1)\n                tag[pos[j]] = 1;\n        std::vector&lt;std::vector&lt;long long&gt; &gt; f(l + 1, std::vector&lt;long long&gt; (tot));\n        f[0][0] = 1ll;\n        for (int j = 0; j &lt; l; ++j)\n            for (int k = 0; k &lt; tot; ++k)\n                for (int a = 0; a &lt; 26; ++a) &#123;\n                    if (!tag[T[k][a]])\n                        (f[j + 1][T[k][a]] += f[j][k]) %= mod;\n                &#125;\n        int k = (__builtin_popcount(i) &amp; 1 ? mod - 1 : 1);\n        auto s = 0ll;\n        for (int j = 0; j &lt; tot; ++j)\n            if (!tag[j])\n                (s += f[l][j]) %= mod;\n        (res += k * s) %= mod;\n    &#125;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"g---count-simple-paths-2\">G - Count Simple Paths 2</h2>\n<p><a href=\"https://atcoder.jp/contests/abc419/tasks/abc419_g\" class=\"uri\">https://atcoder.jp/contests/abc419/tasks/abc419_g</a></p>\n<p>很新的性质。考虑『以 <span class=\"math inline\">\\(1\\)</span> 为起点的简单路径数』和反祖边数量的关系：选定一条反祖边必须被经过时（显然只有一种可能的经过方向），树的形态发生变化：</p>\n<p><img src=\"image.png\" /></p>\n<p>也就是说，一种反祖边的选取方案对应一种树，遍历其从 <span class=\"math inline\">\\(1\\)</span> 开始的简单路径复杂度为 <span class=\"math inline\">\\(O(n)\\)</span>。设反祖边数量为 <span class=\"math inline\">\\(k\\)</span>，那么合法的方案数不超过 <span class=\"math inline\">\\(2^k\\)</span>，暴力 DFS 的整个图复杂度为 <span class=\"math inline\">\\(O(2^k\\cdot n)\\)</span>。</p>\n<p>发现很多跟反祖边无关的遍历是不必要的（只有一种走法，可以设成边权），考虑对所有连接反祖边的点建立虚树，并把原树上的反祖边也移到虚树上，就能 <span class=\"math inline\">\\(O(2^k\\cdot k)\\)</span> 解决问题。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, m;\n    std::cin &gt;&gt; n &gt;&gt; m;\n    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1), g1(n + 1);\n    std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; g2(n + 1);\n    for (int x, y; m--; ) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y;\n        g[x].push_back(y), g[y].push_back(x);\n    &#125;\n    std::vector&lt;int&gt; tag(n + 1), vis(n + 1);\n    std::vector&lt;std::pair&lt;int, int&gt; &gt; be;\n    std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int fa) &#123;\n        static int now = 0;\n        tag[x] = 1, vis[x] = ++now;\n        for (auto i : g[x])\n            if (!tag[i]) &#123;\n                // fprintf(stderr, &quot;%d -&gt; %d\\n&quot;, x, i);\n                g1[x].push_back(i), DFS(i, x);\n            &#125;\n            else if (i != fa &amp;&amp; vis[i] &lt; vis[x])\n                be.emplace_back(i, x);\n        return;\n    &#125;;\n    DFS(1, -1);\n    &#123; // 求虚树\n        std::vector&lt;int&gt; dep(n + 1), fa(n + 1), top(n + 1), siz(n + 1), son(n + 1), dfn(n + 1), rfn(n + 1);\n        std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;\n            siz[x] = 1;\n            for (auto i : g1[x]) &#123;\n                dep[i] = dep[x] + 1;\n                fa[i] = x, DFS(i);\n                siz[x] += siz[i];\n                if (siz[i] &gt; siz[son[x]])\n                    son[x] = i;\n            &#125;\n            return;\n        &#125;;\n        DFS(1);\n        DFS = [&amp;](int x) &#123;\n            static int now = 0;\n            dfn[x] = ++now;\n            if (son[x])\n                top[son[x]] = top[x], DFS(son[x]);\n            for (auto i : g1[x])\n                if (i != son[x])\n                    top[i] = i, DFS(i);\n            rfn[x] = now;\n            // printf(&quot;%d: [%d, %d]\\n&quot;, x, dfn[x], rfn[x]);\n            return;\n        &#125;;\n        top[1] = 1, DFS(1);\n        auto getLCA = [&amp;](int x, int y) &#123;\n            for (; top[x] != top[y]; x = fa[top[x]])\n                if (dep[top[x]] &lt; dep[top[y]])\n                    std::swap(x, y);\n            return dep[x] &lt; dep[y] ? x : y;\n        &#125;;\n        tag.assign(n + 1, 0);\n        tag[1] = tag[n] = 1;\n        for (auto [u, v] : be)\n            tag[u] = 1, tag[v] = 1;\n        std::vector&lt;int&gt; p;\n        for (int i = 1; i &lt;= n; ++i)\n            if (tag[i])\n                p.push_back(i);\n        std::sort(p.begin(), p.end(), [&amp;](int i, int j) &#123; return dfn[i] &lt; dfn[j]; &#125;);\n        for (int i = 1; i &lt; (int)p.size(); ++i) &#123;\n            int fa = getLCA(p[i], p[i - 1]);\n            if (!tag[fa])\n                tag[fa] = 1;\n        &#125;\n        p.clear();\n        for (int i = 1; i &lt;= n; ++i)\n            if (tag[i])\n                p.push_back(i);\n        std::sort(p.begin(), p.end(), [&amp;](int i, int j) &#123; return dfn[i] &lt; dfn[j]; &#125;);\n        std::vector&lt;int&gt; st;\n        for (auto i : p) &#123;\n            if (st.empty())\n                st.push_back(i);\n            else &#123;\n                for (; rfn[st.back()] &lt; dfn[i]; st.pop_back());\n                g2[st.back()].emplace_back(i, dep[i] - dep[st.back()]);\n                g2[i].emplace_back(st.back(), dep[i] - dep[st.back()]);\n                // printf(&quot;add (%d, %d): %d\\n&quot;, st.back(), i, dep[i] - dep[st.back()]);\n                st.push_back(i);\n            &#125;\n        &#125;\n        for (auto [u, v] : be) &#123;\n            g2[u].emplace_back(v, 1), g2[v].emplace_back(u, 1);\n            // printf(&quot;# add(%d, %d): 1\\n&quot;, u, v);\n        &#125;\n    &#125;\n    tag.assign(n + 1, 0);\n    std::vector&lt;int&gt; res(n + 1);\n    DFS = [&amp;](int x, int s) &#123;\n        if (x == n)\n            ++res[s];\n        tag[x] = 1;\n        for (auto [i, w] : g2[x])\n            if (!tag[i])\n                DFS(i, s + w);\n        tag[x] = 0;\n        return;\n    &#125;;\n    DFS(1, 0);\n    for (int i = 1; i &lt; n; ++i)\n        std::cout &lt;&lt; res[i] &lt;&lt; &#39; &#39;;\n    std::cout &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n",
            "tags": [
                "线段树",
                "AC 自动机",
                "贪心",
                "DP 优化",
                "虚树"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20250120/",
            "url": "https://xsc062.netlify.app/20250120/",
            "title": "学习笔记：AC 自动机",
            "date_published": "2025-01-20T03:21:15.000Z",
            "content_html": "<p>耳机声音疑似有点小了，用心旷神怡的话来说大致会是「比果蝇↑嗡嗡声还小」。</p>\n<span id=\"more\"></span>\n<p>？卧槽耳机上居然可以调音量 <img src=\"/em/oh.gif\" /></p>\n<hr />\n<h2 id=\"前置知识\">前置知识</h2>\n<p>首先可能需要知道专有名词「自动机」的含义。</p>\n<p>大致可以简单理解为，一个 DAG，其中点表示状态，边表示转移。给进去一个字符串之类，就可以在 DAG 上游走，根据最后所处结点，可以得到字符串相关特征。</p>\n<p>这个定义让我们想到了 Trie。事实上，Trie 就是一种相当基础的自动机。</p>\n<hr />\n<p>接下来，让我们复习 KMP 相关概念。</p>\n<p>假想一个场景：你需要求得 <span class=\"math inline\">\\(T\\)</span> 在 <span class=\"math inline\">\\(S\\)</span> 中的出现次数。</p>\n<p>拥有一定题目经验的你，会使用 KMP 求出 <span class=\"math inline\">\\(T\\)</span> 的 <code>next</code> 数组，令 <span class=\"math inline\">\\(T\\)</span> 在 <span class=\"math inline\">\\(S\\)</span> 上进行匹配，失配或完全匹配时回到 <span class=\"math inline\">\\(T\\)</span> 在该处的 <code>next</code>，<span class=\"math inline\">\\(S\\)</span> 上的指针始终向右，<span class=\"math inline\">\\(T\\)</span> 上的指针如果向右，每次只能移动一位；如果向左，最左移到开头，均摊下来复杂度即为 <span class=\"math inline\">\\(O(|S| + |T|)\\)</span>。</p>\n<p>假如场景变得更复杂：给定 <span class=\"math inline\">\\(\\{T_m\\}\\)</span>，你需要求出每个 <span class=\"math inline\">\\(T_j\\)</span> 在 <span class=\"math inline\">\\(S\\)</span> 中的出现次数。</p>\n<p>那么如果我们对每个 <span class=\"math inline\">\\(T_j\\)</span> 进行一次 KMP，复杂度将会上升到 <span class=\"math inline\">\\(O(m|S|)\\)</span>，难以承受。有没有优化的方法呢？</p>\n<hr />\n<h2 id=\"ac-自动机的建立\">AC 自动机的建立</h2>\n<p>结合上面的知识，我们下意识想到，能不能将 <span class=\"math inline\">\\(\\{T_m\\}\\)</span> 建成一个树状结构，令 <span class=\"math inline\">\\(S\\)</span> 在其上进行 KMP 呢？</p>\n<p>将 <span class=\"math inline\">\\(\\{T_m\\}\\)</span> 全部加入 Trie，由于 <code>next</code> 只会由更深的点指向更浅的点，似乎从直觉上是有规则的。但随之而来的是一个问题：点 <span class=\"math inline\">\\(u\\)</span> 的 <code>next</code> 不一定在 <span class=\"math inline\">\\(\\text{root}\\to u\\)</span> 的链上（由于 Trie 的性质，可知指向的点是唯一的）。鉴于这一点不同，我们结合其「失配指针」的定义，将 <code>next</code> 在 Trie 上的同分异构体唤为 <code>fail</code>。</p>\n<p>考察 Trie 上该 <code>fail</code> 边的性质。现欲求解 <span class=\"math inline\">\\(u\\)</span> 的 <code>fail</code> 指向的 <span class=\"math inline\">\\(c\\)</span>，结合 KMP 中 <code>next</code> 的性质，假设 <span class=\"math inline\">\\(u\\)</span> 的父节点的 <code>fail</code> 边指向 <span class=\"math inline\">\\(v&#39;\\)</span>，那么 <span class=\"math inline\">\\(v\\)</span> 的值为：</p>\n<ul>\n<li><span class=\"math inline\">\\(v&#39;\\)</span> 上有边权相同的边，那么 <span class=\"math inline\">\\(v\\)</span> 就是该边指向的点。</li>\n<li>否则，前往 <span class=\"math inline\">\\(v&#39;\\)</span> 的 <code>fail</code>，重复以上判定。</li>\n</ul>\n<p>那么就完成了失配的处理。相应地，完全匹配时的跳转应如何处理？直接将 <code>fail</code> 的儿子全部接到 <span class=\"math inline\">\\(u\\)</span> 下面即可。如果 <span class=\"math inline\">\\(u\\)</span> 和 <code>fail</code> 具有同一个边权的边时，保留 <span class=\"math inline\">\\(u\\)</span> 的这条边 <span class=\"math inline\">\\(u\\to v\\)</span>，因为 <span class=\"math inline\">\\(v\\)</span> 的 <code>fail</code> 必定指向 <span class=\"math inline\">\\(u\\)</span> 的 <code>fail</code> 的对应儿子。</p>\n<p>两点结合，我们发现从实现上，可以直接令 <span class=\"math inline\">\\(v\\)</span> 的 <code>fail</code> 指向 <span class=\"math inline\">\\(u\\)</span> 的 <code>fail</code> 的对应儿子（那么时间复杂度显而易见是 <span class=\"math inline\">\\(O(26\\sum |T|)\\)</span> 的）。</p>\n<p>匹配时，对于每个点和其返回到根的 <code>fail</code> 链，全部标记。则一个模式串匹配的次数即为被打标记的次数。</p>\n<p>那么可以发现 AC 自动机的本质就是添加了 <code>fail</code> 边的 Trie。</p>\n<hr />\n<p>那么根据上述要求，我们需要按照深度顺序求得 <code>fail</code>，考虑 BFS。</p>\n<details>\n<p>哦哦好神奇复活之后记得啥是 KMP 但忘了啥是 C++ 了。甚至花了一点时间学习怎么创建一个函数？？？</p>\n<p>大家写 AC 自动机 Trie 根节点下标一定要设成 0 啊 <img src=\"/em/ll.gif\" /> 设成 1 被各种细节坑惨了 <img src=\"/em/ll.gif\" /></p>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 2e5 + 5;\nint T[maxn][26], tot, cnt[maxn], fail[maxn];\nint ins(std::string &amp;t) &#123;\n    int p = 0;\n    for (auto i : t) &#123;\n        if (!T[p][i - &#39;a&#39;])\n            T[p][i - &#39;a&#39;] = ++tot;\n        p = T[p][i - &#39;a&#39;];\n    &#125;\n    return p;\n&#125;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;int&gt; tail(n + 1);\n    std::vector&lt;std::string&gt; t(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; t[i], tail[i] = ins(t[i]);\n    &#123;\n        std::queue&lt;int&gt; q;\n        for (int i = 0; i &lt; 26; ++i)\n            if (T[0][i])\n                q.push(T[0][i]);\n        for (; !q.empty(); ) &#123;\n            int u = q.front();\n            q.pop();\n            for (int i = 0; i &lt; 26; ++i)\n                if (T[u][i]) &#123;\n                    int v = T[u][i];\n                    fail[v] = T[fail[u]][i];\n                    q.push(v);\n                &#125;\n                else\n                    T[u][i] = T[fail[u]][i];\n        &#125;\n    &#125;\n    std::string s;\n    std::cin &gt;&gt; s;\n    &#123;\n        int p = 0;\n        for (auto i : s) &#123;\n            p = T[p][i - &#39;a&#39;];\n            for (int fa = p; fa; fa = fail[fa])\n                ++cnt[fa];\n        &#125;\n    &#125;\n    for (int i = 1; i &lt;= n; ++i)\n        std::cout &lt;&lt; cnt[tail[i]] &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<p>肉眼可见该查询方式是极其低效的，故考虑优化跳 <code>fail</code> 打标记的过程。</p>\n<p>既然自动机结构不变，不如将跳 <code>fail</code> 的步骤放在最后统一进行。容易在发现 <code>fail</code> 树上进行拓扑排序转移即可。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 2e5 + 5;\nint T[maxn][26], tot, cnt[maxn], fail[maxn], deg[maxn];\nint ins(std::string &amp;t) &#123;\n    int p = 0;\n    for (auto i : t) &#123;\n        if (!T[p][i - &#39;a&#39;])\n            T[p][i - &#39;a&#39;] = ++tot;\n        p = T[p][i - &#39;a&#39;];\n    &#125;\n    return p;\n&#125;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;int&gt; tail(n + 1);\n    std::vector&lt;std::string&gt; t(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; t[i], tail[i] = ins(t[i]);\n    &#123;\n        std::queue&lt;int&gt; q;\n        for (int i = 0; i &lt; 26; ++i)\n            if (T[0][i])\n                q.push(T[0][i]);\n        for (; !q.empty(); ) &#123;\n            int u = q.front();\n            q.pop();\n            for (int i = 0; i &lt; 26; ++i)\n                if (T[u][i]) &#123;\n                    int v = T[u][i];\n                    fail[v] = T[fail[u]][i], ++deg[T[fail[u]][i]];\n                    q.push(v);\n                &#125;\n                else\n                    T[u][i] = T[fail[u]][i];\n        &#125;\n    &#125;\n    std::string s;\n    std::cin &gt;&gt; s;\n    &#123;\n        int p = 0;\n        for (auto i : s)\n            p = T[p][i - &#39;a&#39;], ++cnt[p];\n    &#125;\n    &#123;\n        std::queue&lt;int&gt; q;\n        for (int i = 1; i &lt;= tot; ++i)\n            if (!deg[i])\n                q.push(i);\n        for (; !q.empty(); ) &#123;\n            int u = q.front();\n            q.pop();\n            cnt[fail[u]] += cnt[u];\n            if (!--deg[fail[u]])\n                q.push(fail[u]);\n        &#125;\n    &#125;\n    for (int i = 1; i &lt;= n; ++i)\n        std::cout &lt;&lt; cnt[tail[i]] &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"ac-自动机的应用与识别\">AC 自动机的应用与识别</h2>\n<p>我们知道其最典型的特征是 <strong>多模式串</strong>、<strong>静态 / 离线</strong>。当碰到类似特点时，大概率就是 AC 自动机。</p>\n<p>其中，可以设置的难点有：</p>\n<ol type=\"1\">\n<li>字符串难点，和其他字符串题可设置的难点相同。</li>\n<li>fail 树维护，可能结合数据结构、拓扑排序、树形 DP 等考察。</li>\n<li>DP 的设计。</li>\n</ol>\n<hr />\n<h2 id=\"字符串难点设计\">字符串难点设计</h2>\n<h3 id=\"eg.-indie-album\">eg. Indie Album</h3>\n<p><a href=\"https://codeforces.com/problemset/problem/1207/G\" class=\"uri\">https://codeforces.com/problemset/problem/1207/G</a></p>\n<p>题目的「可持久化」试图误导我们用操作串建立自动机，但这样就会有一个比较严重的问题，我们没办法求 <span class=\"math inline\">\\(t\\)</span> 的出现次数。</p>\n<p>为了保证答案可求我们仍然在 <span class=\"math inline\">\\(t\\)</span> 上建立 ACAM。容易发现操作串以 Trie 形式给出，我们可以在遍历 Trie 时同时完成游走，通过回溯完成询问。</p>\n<p>假设当前 DFS 中，遍历到 Trie 树中的 <span class=\"math inline\">\\(x\\)</span> 点和自动机中的 <span class=\"math inline\">\\(u\\)</span> 状态，那么对于 <span class=\"math inline\">\\(x\\)</span> 点所对应的一个询问串 <span class=\"math inline\">\\(t\\)</span>，相当于询问经过的所有状态有多少个在 <span class=\"math inline\">\\(t\\)</span> 引导的 fail 树子树中。我们求出 fail 树的 dfn，用树状数组简单统计即可。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 4e5 + 5;\nstd::vector&lt;int&gt; g[maxn], q[maxn];\nint fail[maxn], T[maxn][26], tot, bit[maxn], to[maxn][26], cnt[maxn];\nint ins(std::string s) &#123;\n    int p = 0;\n    for (auto i : s) &#123;\n        if (!T[p][i - &#39;a&#39;])\n            T[p][i - &#39;a&#39;] = ++tot;\n        p = T[p][i - &#39;a&#39;];\n    &#125;\n    return p;\n&#125;\nint lowbit(int x) &#123;\n    return x &amp; -x;\n&#125;\nvoid add(int x, int v) &#123;\n    for (; x &lt;= tot + 1; x += lowbit(x))\n        bit[x] += v;\n    return;\n&#125;\nint ask(int x) &#123;\n    int res = 0;\n    for (; x; x -= lowbit(x))\n        res += bit[x];\n    return res;\n&#125;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, now = 0;\n    std::cin &gt;&gt; n;\n    std::vector&lt;int&gt; id(n + 1);\n    for (int i = 1, op; i &lt;= n; ++i) &#123;\n        char t;\n        std::cin &gt;&gt; op;\n        if (op == 1) &#123;\n            std::cin &gt;&gt; t;\n            if (!to[0][t - &#39;a&#39;])\n                to[0][t - &#39;a&#39;] = ++now;\n            ++cnt[to[0][t - &#39;a&#39;]], id[i] = to[0][t - &#39;a&#39;];\n        &#125;\n        else &#123;\n            int j; \n            std::cin &gt;&gt; j &gt;&gt; t;\n            if (!to[id[j]][t - &#39;a&#39;])\n                to[id[j]][t - &#39;a&#39;] = ++now;\n            ++cnt[to[id[j]][t - &#39;a&#39;]], id[i] = to[id[j]][t - &#39;a&#39;];\n        &#125;\n    &#125;\n    int m;\n    std::cin &gt;&gt; m;\n    std::vector&lt;int&gt; tail(m + 1), res(m + 1);\n    for (int i = 1, x; i &lt;= m; ++i) &#123;\n        std::string t;\n        std::cin &gt;&gt; x &gt;&gt; t, tail[i] = ins(t);\n        q[id[x]].push_back(i);\n    &#125;\n    &#123;\n        std::queue&lt;int&gt; q;\n        for (int i = 0; i &lt; 26; ++i)\n            if (T[0][i])\n                q.push(T[0][i]), g[0].push_back(T[0][i]);\n        for (; !q.empty(); ) &#123;\n            int u = q.front();\n            q.pop();\n            for (int i = 0; i &lt; 26; ++i)\n                if (T[u][i]) &#123;\n                    int v = T[u][i];\n                    fail[v] = T[fail[u]][i];\n                    q.push(v), g[fail[v]].push_back(v);\n                &#125;\n                else\n                    T[u][i] = T[fail[u]][i];\n        &#125;\n    &#125;\n    std::vector&lt;int&gt; dfn(tot + 1), rfn(tot + 1);\n    std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;\n        static int now = 0;\n        dfn[x] = ++now;\n        // printf(&quot;%d &quot;, x);\n        for (auto i : g[x])\n            DFS(i);\n        rfn[x] = now;\n        return;\n    &#125;;\n    DFS(0);\n    std::function&lt;void(int, int)&gt; DFS1 = [&amp;](int x, int u) &#123;\n        add(dfn[u], 1);\n        for (auto i : q[x])\n            res[i] += ask(rfn[tail[i]]) - ask(dfn[tail[i]] - 1);\n        for (int i = 0; i &lt; 26; ++i)\n            if (to[x][i])\n                DFS1(to[x][i], T[u][i]);\n        add(dfn[u], -1);\n        return;\n    &#125;;\n    DFS1(0, 0);\n    for (int i = 1; i &lt;= m; ++i)\n        std::cout &lt;&lt; res[i] &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"fail-树的维护\">fail 树的维护</h2>\n<h3 id=\"eg.-divljak\">eg. Divljak</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P5840\" class=\"uri\">https://www.luogu.com.cn/problem/P5840</a></p>\n<h4 id=\"法一把动态问题离线\">法一：把动态问题离线</h4>\n<p>问题相当于将模式串 <span class=\"math inline\">\\(T:\\{P\\}\\)</span> 动态化，但我们仍可以无脑离线下来解决问题。</p>\n<p>考虑原本的答案计算过程，即在经过的所有状态及其 fail 链上打标记。现在我们需要离线并区分标记的来源（并且标记类型为布尔值），下意识想到使用线段树维护。</p>\n<p>我们对每个状态建立动态开点线段树，最后拓扑排序时使用线段树合并处理信息。容易证明时间复杂度相较原来多了一个 <span class=\"math inline\">\\(\\log\\)</span>。</p>\n<p><del>理论可行，开始实践</del> 出题人似乎不是很喜欢线段树选手所以决定剥夺你的 Memory Limit。想要用这种做法通过本题可见 <a href=\"https://www.luogu.com.cn/article/jaxk3sno\" class=\"uri\">https://www.luogu.com.cn/article/jaxk3sno</a>。</p>\n<h4 id=\"法二转而处理静态问题\">法二：转而处理静态问题</h4>\n<p>注意到题目中的静态的 <span class=\"math inline\">\\(S_x\\)</span> 比起 <span class=\"math inline\">\\(T:\\{P\\}\\)</span> 更适合用来做模式串，我们在 <span class=\"math inline\">\\(S_x\\)</span> 上构建 AC 自动机，考虑在线解决问题。</p>\n<p>在每次 <code>1</code> 操作时，更新模式串信息。对于途径的所有状态 <span class=\"math inline\">\\(\\{u\\}\\)</span>，考虑更新其所在 fail 链上的信息。</p>\n<p>注意到我们需要修改整条 fail 链上的信息，询问则是询问单点。这个时候可以考虑使用树上差分。</p>\n<p>但是 here comes a problem，我们对于这一整个串只能在整个树上每个点上更新一次。怎么消去相同的影响呢？</p>\n<p>这里实现上我们将经过的点按 fail 树上 dfn 排序，并且对于序列中相邻的两点在其 LCA 上减去一次标记。为什么这是正确的呢？参考虚树，我们只需要让序列中相邻的两个点尽量近就可以保证重复的被删除完毕。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 2e6 + 5;\nint tot, bit[maxn], T[maxn][26], fail[maxn];\nint ins(std::string &amp;t) &#123;\n    int p = 0;\n    for (auto i : t) &#123;\n        if (!T[p][i - &#39;a&#39;])\n            T[p][i - &#39;a&#39;] = ++tot;\n        p = T[p][i - &#39;a&#39;];\n    &#125;\n    return p;\n&#125;\nint lowbit(int x) &#123;\n    return x &amp; -x;\n&#125;\nvoid add(int x, int v) &#123;\n    // printf(&quot;add (%d, %d)\\n&quot;, x, v);\n    for (; x &lt;= tot + 1; x += lowbit(x))\n        bit[x] += v;\n    return;\n&#125;\nint ask(int x) &#123;\n    int res = 0, to = x;\n    for (; x; x -= lowbit(x))\n        res += bit[x];\n    // printf(&quot;ask(%d) = %d\\n&quot;, to, res);\n    return res;\n&#125;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, q;\n    std::cin &gt;&gt; n;\n    std::vector&lt;int&gt; tail(n + 1);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::string t;\n        std::cin &gt;&gt; t, tail[i] = ins(t);\n    &#125;\n    std::vector&lt;std::vector&lt;int&gt; &gt; g(tot + 2);\n    &#123;\n        std::queue&lt;int&gt; q;\n        for (int i = 0; i &lt; 26; ++i)\n            if (T[0][i])\n                q.push(T[0][i]);\n        for (; !q.empty(); ) &#123;\n            int u = q.front();\n            q.pop();\n            for (int i = 0; i &lt; 26; ++i)\n                if (T[u][i]) &#123;\n                    int v = T[u][i];\n                    fail[v] = T[fail[u]][i];\n                    q.push(v);\n                &#125;\n                else\n                    T[u][i] = T[fail[u]][i];\n        &#125;\n        for (int i = 1; i &lt;= tot; ++i)\n            g[fail[i] + 1].push_back(i + 1);\n    &#125;\n    std::vector&lt;std::array&lt;int, 22&gt; &gt; f(tot + 2);\n    std::vector&lt;int&gt; dep(tot + 2), dfn(tot + 2), siz(tot + 2);\n    std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;\n        static int now = 0;\n        siz[x] = 1, dfn[x] = ++now;\n        // printf(&quot;%d\\n&quot;, x);\n        for (auto i : g[x]) &#123;\n            dep[i] = dep[x] + 1;\n            f[i][0] = x;\n            for (int j = 1; j &lt;= 21; ++j)\n                f[i][j] = f[f[i][j - 1]][j - 1];\n            DFS(i), siz[x] += siz[i];\n        &#125;\n        return;\n    &#125;;\n    dep[1] = 1, DFS(1);\n    auto askLCA = [&amp;](int x, int y) &#123;\n        if (x == y)\n            return x;\n        if (dep[x] &lt; dep[y])\n            std::swap(x, y);\n        for (int i = 21; ~i; --i)\n            if (dep[f[x][i]] &gt;= dep[y])\n                x = f[x][i];\n        if (x == y)\n            return x;\n        for (int i = 21; ~i; --i)\n            if (f[x][i] != f[y][i])\n                x = f[x][i], y = f[y][i];\n        return f[x][0];\n    &#125;;\n    std::cin &gt;&gt; q;\n    for (; q--; ) &#123;\n        int op;\n        std::cin &gt;&gt; op;\n        if (op == 1) &#123;\n            std::string s;\n            std::cin &gt;&gt; s;\n            int p = 0, len = (int)s.length();\n            std::vector&lt;int&gt; id(len + 1);\n            for (int i = 1; i &lt;= len; ++i)\n                p = T[p][s[i - 1] - &#39;a&#39;], id[i] = p + 1;\n            std::sort(id.begin() + 1, id.end(), [&amp;](int x, int y) &#123; return dfn[x] &lt; dfn[y]; &#125;);\n            // for (int i = 1; i &lt;= len; ++i)\n            //     printf(&quot;%d &quot;, id[i]);\n            // puts(&quot;&quot;);\n            for (int i = 1; i &lt;= len; ++i) &#123;\n                // printf(&quot;%d %d %d\\n&quot;, i, id[i], dfn[id[i]]);\n                // assert(0);\n                add(dfn[id[i]], 1);\n                if (i != 1)\n                    add(dfn[askLCA(id[i], id[i - 1])], -1);\n            &#125;\n        &#125;\n        else &#123;\n            int x;\n            std::cin &gt;&gt; x;\n            x = tail[x] + 1;\n            std::cout &lt;&lt; ask(dfn[x] + siz[x] - 1) - ask(dfn[x] - 1) &lt;&lt; &#39;\\n&#39;;\n        &#125;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"ac-自动机上的-dp\">AC 自动机上的 DP</h2>\n<p>鉴于 AC 自动机的优秀结构与性质，并不经常作为字符串匹配工具出现，其一个应用是作为 DP 的载体。</p>\n<h3 id=\"eg1.-l-语言\">eg1. L 语言</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P2292\" class=\"uri\">https://www.luogu.com.cn/problem/P2292</a></p>\n<p>我们想到要在自动机上匹配，但此时 <code>fail</code> 作为「断句」的唯一手段（断句的位置在链上当前点深度 - <code>fail</code> 深度处），不再仅当失配时才能经过。我们考虑朴素的 DP：在经过的每个状态考虑断句，那么这要求断句处是一个单词的结尾，那么此时 <code>fail</code> 最长匹配长度即可被更新。最后遍历所有单词的末结点，取最大答案。这里的 <code>fail</code> 其实是 <code>fail</code> 链上任意一点。</p>\n<p>考虑复杂度。容易发现对于每一个点我们跳了其整条 fail 链，那么复杂度就是最劣 <span class=\"math inline\">\\(n^2\\)</span> 的。考虑优化这个过程至 <span class=\"math inline\">\\(O(1)\\)</span>。</p>\n<p>题目里有一个很重要的条件还没有用到：单个单词长度 <span class=\"math inline\">\\(\\le 20\\)</span>，这让我们想到状态压缩。对于每一个状态，记录其断出来单词的可能长度。</p>\n<p>我们在 DAG 上游走的时候记录目前可以断的所有位置，如果其和当前可断出来的长度之交不为空，就可以将此处加入「可以断的所有位置」并更新答案。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 2e5 + 5;\nint T[maxn][26], tot, fail[maxn], len[maxn], dep[maxn], tag[maxn];\nint ins(std::string &amp;t) &#123;\n    int p = 0;\n    for (auto i : t) &#123;\n        if (!T[p][i - &#39;a&#39;])\n            T[p][i - &#39;a&#39;] = ++tot, dep[tot] = dep[p] + 1;\n        p = T[p][i - &#39;a&#39;];\n    &#125;\n    ++tag[p];\n    return p;\n&#125;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, m;\n    std::cin &gt;&gt; n &gt;&gt; m;\n    std::vector&lt;int&gt; tail(n + 1);\n    std::vector&lt;std::string&gt; t(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; t[i], tail[i] = ins(t[i]);\n    &#123;\n        std::queue&lt;int&gt; q;\n        for (int i = 0; i &lt; 26; ++i)\n            if (T[0][i])\n                q.push(T[0][i]);\n        for (; !q.empty(); ) &#123;\n            int u = q.front();\n            q.pop();\n            len[u] = len[fail[u]];\n            if (tag[u])\n                len[u] |= (1 &lt;&lt; dep[u]);\n            for (int i = 0; i &lt; 26; ++i)\n                if (T[u][i]) &#123;\n                    int v = T[u][i];\n                    fail[v] = T[fail[u]][i];\n                    q.push(v);\n                &#125;\n                else\n                    T[u][i] = T[fail[u]][i];\n        &#125;\n    &#125;\n    for (; m--; ) &#123;\n        std::string s;\n        std::cin &gt;&gt; s;\n        int p = 0, q = 1, res = 0;\n        for (int i = 0; i &lt; (int)s.length(); ++i) &#123;\n            p = T[p][s[i] - &#39;a&#39;], q &lt;&lt;= 1;\n            if (len[p] &amp; q)\n                q |= 1, res = i + 1;\n        &#125;\n        std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"eg2.-popcount-words\">eg2. Popcount Words</h3>\n<p><a href=\"https://codeforces.com/gym/103409/problem/H\" class=\"uri\">https://codeforces.com/gym/103409/problem/H</a></p>\n<p><del>咋上强度了啊。</del></p>\n<p>先把整个序列写出来，即 <span class=\"math inline\">\\(w=\\texttt{01101001100101}\\cdots\\)</span>，尝试进一步探究形式化的规律，可以得到：</p>\n<ol type=\"1\">\n<li><span class=\"math inline\">\\(w_{[0, 2^n), 0}=w_{[0, 2^{n-1}),0}+w_{[0, 2^n), 1}\\)</span>，其中 <span class=\"math inline\">\\(w_{[l, r], 0/1}\\)</span> 表示 <span class=\"math inline\">\\([l, r]\\)</span> 内，原串 / 取反的值。</li>\n<li>对于不以 <span class=\"math inline\">\\(0\\)</span> 开头的整段，可以从上述规则转化为 <span class=\"math inline\">\\(0\\)</span> 开头的整段。</li>\n</ol>\n<p>接着不难想到一种类似线段树的方式，将待求的 <span class=\"math inline\">\\(w_{[l, r], 0}\\)</span> 分到 <span class=\"math inline\">\\(O(\\log V)\\)</span> 个整段上，那么 <span class=\"math inline\">\\(S\\)</span> 就可以被 <span class=\"math inline\">\\(O(n\\log V)\\)</span> 个整段（也是 <span class=\"math inline\">\\(\\log V\\)</span> 个本质不同整段）描述。</p>\n<p>我们对 <span class=\"math inline\">\\({p_m}\\)</span> 建立 AC 自动机，需要知道这 <span class=\"math inline\">\\(\\log V\\)</span> 个整段在每个点上的出现次数。对于自动机上任意状态 <span class=\"math inline\">\\(u\\)</span>，设 <span class=\"math inline\">\\(to_{u, n, 0/1}\\)</span> 表示 <span class=\"math inline\">\\(u\\)</span> 经过 <span class=\"math inline\">\\(w_{[0, 2^n), 0/1}\\)</span> 后到达的点，则可倍增（嘶，这里是不是应该反过来叫分治啊）简单解决。</p>\n<p>那么接下来我们就可以用 <span class=\"math inline\">\\(to\\)</span> 来进行快速游走了。顺便打个 <span class=\"math inline\">\\(cnt\\)</span> 记录一下每个 <span class=\"math inline\">\\(u\\)</span> 作为不同整段的开头被经过的次数。然后做一个 DP，类似于线段树上 <code>pushdown</code> 的操作把所有整段下放到单点上的单个字符。</p>\n<p>有一说一用 DP 来处理这个东西还挺难想的。可能也是基于前面的倍增吧。最后拓扑排序就行了。</p>\n<details>\n<p>大家数组一定要用 C-style array 啊，<code>std::vector&lt;&gt;</code> 计算的是申请空间包 MLE 的 <img src=\"/em/ll.gif\" /></p>\n<p>大家大数组一定要内存连续访问优化啊，TLE <span class=\"math inline\">\\(\\to\\)</span> 100ms 泪目了 <img src=\"/em/ll.gif\" /></p>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 5e5 + 5;\nlong long sum[maxn], f[2][30][maxn];\nint cnt[2][30][maxn], to[2][30][maxn];\nint T[maxn][2], tot, fail[maxn], deg[maxn];\nint ins(std::string &amp;t) &#123;\n    int p = 0;\n    for (auto i : t) &#123;\n        if (!T[p][i - &#39;0&#39;])\n            T[p][i - &#39;0&#39;] = ++tot;\n        p = T[p][i - &#39;0&#39;];\n    &#125;\n    return p;\n&#125;\nvoid ask(std::vector&lt;std::pair&lt;int, int&gt; &gt; &amp;s, int ql, int qr, int l = 0, int r = (1 &lt;&lt; 30) - 1, int len = 30, int v = 0) &#123;\n    if (ql &lt;= l &amp;&amp; r &lt;= qr) &#123;\n        s.emplace_back(len, v);\n        return;\n    &#125;\n    int mid = l + (r - l) / 2;\n    if (ql &lt;= mid)\n        ask(s, ql, qr, l, mid, len - 1, v);\n    if (qr &gt; mid)\n        ask(s, ql, qr, mid + 1, r, len - 1, v ^ 1);\n    return;\n&#125;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, m;\n    std::cin &gt;&gt; n &gt;&gt; m;\n    std::vector&lt;std::pair&lt;int, int&gt; &gt; s;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        int l, r;\n        std::cin &gt;&gt; l &gt;&gt; r;\n        ask(s, l, r);\n    &#125;\n    std::vector&lt;int&gt; tail(m + 1);\n    for (int i = 1; i &lt;= m; ++i) &#123;\n        std::string t;\n        std::cin &gt;&gt; t;\n        tail[i] = ins(t);\n    &#125;\n    &#123;\n        std::queue&lt;int&gt; q;\n        for (int i = 0; i &lt; 2; ++i)\n            if (T[0][i])\n                q.push(T[0][i]);\n        for (; !q.empty(); ) &#123;\n            int u = q.front();\n            q.pop();\n            for (int i = 0; i &lt; 2; ++i)\n                if (T[u][i]) &#123;\n                    int v = T[u][i];\n                    fail[v] = T[fail[u]][i], ++deg[T[fail[u]][i]];\n                    q.push(v);\n                &#125;\n                else\n                    T[u][i] = T[fail[u]][i];\n        &#125;\n    &#125;\n    for (int i = 0; i &lt;= tot; ++i)\n        to[0][0][i] = T[i][0], to[1][0][i] = T[i][1];\n    for (int j = 1; j &lt; 30; ++j)\n        for (int i = 0; i &lt;= tot; ++i) &#123;\n            to[0][j][i] = to[1][j - 1][to[0][j - 1][i]];\n            to[1][j][i] = to[0][j - 1][to[1][j - 1][i]];\n        &#125;\n    &#123;\n        int p = 0;\n        for (auto [n, i] : s) &#123;\n            // printf(&quot;# %d %d\\n&quot;, n, i);\n            ++cnt[i][n][p], p = to[i][n][p];\n        &#125;\n    &#125;\n    for (int j = 29; ~j; --j)\n        for (int i = 0; i &lt;= tot; ++i) &#123;\n            if (j != 29) &#123;\n                f[0][j][i] += f[0][j + 1][i];\n                f[1][j][i] += f[1][j + 1][i];\n                f[0][j][to[1][j][i]] += f[1][j + 1][i];\n                f[1][j][to[0][j][i]] += f[0][j + 1][i];\n            &#125;\n            f[1][j][i] += cnt[1][j][i];\n            f[0][j][i] += cnt[0][j][i];\n        &#125;\n    for (int i = 0; i &lt;= tot; ++i) &#123;\n        sum[T[i][0]] += f[0][0][i], sum[T[i][1]] += f[1][0][i];\n        // printf(&quot;%d %d\\n&quot;, f[i][0][0], f[i][0][1]);\n    &#125;\n    &#123;\n        std::queue&lt;int&gt; q;\n        for (int i = 0; i &lt;= tot; ++i)\n            if (!deg[i])\n                q.push(i);\n        for (; !q.empty(); ) &#123;\n            int u = q.front();\n            q.pop();\n            sum[fail[u]] += sum[u];\n            if (!--deg[fail[u]])\n                q.push(fail[u]);\n        &#125;\n    &#125;\n    for (int i = 1; i &lt;= m; ++i)\n        std::cout &lt;&lt; sum[tail[i]] &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"eg3.-legen\">eg3. Legen…</h3>\n<p><a href=\"https://codeforces.com/problemset/problem/696/D\" class=\"uri\">https://codeforces.com/problemset/problem/696/D</a></p>\n<p>先在 fail 树上把每个状态的实际价值计算出来。我们发现匹配串是未知的，也就是我们需要主动决定游走路径。注意到 <span class=\"math inline\">\\(l=10^{14}\\)</span>，考虑矩阵。</p>\n<p>令 <span class=\"math inline\">\\(f_{u, i}\\)</span> 表示在 <span class=\"math inline\">\\(u\\)</span> 状态时已经走了 <span class=\"math inline\">\\(i\\)</span> 步，可以得到的最大价值。那么显然有：</p>\n<p><span class=\"math display\">\\[\nf_{v,i+1}=f_{u,i}+s_v.\n\\]</span></p>\n<p>其中 <span class=\"math inline\">\\(v\\)</span> 是自动机上 <span class=\"math inline\">\\(u\\)</span> 的任意出边。图的大小为 <span class=\"math inline\">\\(200\\)</span>，可以放到 <span class=\"math inline\">\\(+\\max\\)</span> 矩阵里加速转移。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 2e5 + 5;\nconst long long inf = 1e18;\nint fail[maxn], T[maxn][26], tot;\nint ins(std::string s) &#123;\n    int p = 0;\n    for (auto i : s) &#123;\n        if (!T[p][i - &#39;a&#39;])\n            T[p][i - &#39;a&#39;] = ++tot;\n        p = T[p][i - &#39;a&#39;];\n    &#125;\n    return p;\n&#125;\nstruct matrix &#123;\n    int n, m;\n    std::vector&lt;std::vector&lt;long long&gt; &gt; a;\n    matrix(int n1, int m1, long long v = -inf, bool op = 0): n(n1), m(m1), a(n + 1, std::vector&lt;long long&gt; (m + 1, v)) &#123;\n        if (op)\n            for (int i = 0; i &lt;= n; ++i)\n                a[i][i] = 0;\n        return;\n    &#125;\n    std::vector&lt;long long&gt; &amp;operator[] (int i) &#123;\n        return a[i];\n    &#125;\n    matrix operator* (matrix &amp;q) const &#123;\n        matrix res(n, q.m);\n        for (int k = 0; k &lt;= m; ++k)\n            for (int i = 0; i &lt;= n; ++i)\n                for (int j = 0; j &lt;= q.m; ++j)\n                    res[i][j] = std::max(res[i][j], a[i][k] + q[k][j]);\n        return res;\n    &#125;\n    matrix&amp; operator*= (matrix q) &#123;\n        return *this = *this * q;\n    &#125;\n    matrix operator^ (long long q) &#123;\n        matrix res(n, n, -inf, 1), x(*this);\n        for (; q; q &gt;&gt;= 1, x *= x)\n            if (q &amp; 1)\n                res *= x;\n        return res;\n    &#125;\n&#125;;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    long long m;\n    std::cin &gt;&gt; n &gt;&gt; m;\n    std::vector&lt;long long&gt; a(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i];\n    std::vector&lt;int&gt; tail(n + 1);\n    std::vector&lt;std::string&gt; t(n + 1);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; t[i];\n        tail[i] = ins(t[i]);\n    &#125;\n    std::vector&lt;long long&gt; s(tot + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        s[tail[i]] += a[i];\n    &#123;\n        std::queue&lt;int&gt; q;\n        for (int i = 0; i &lt; 26; ++i)\n            if (T[0][i])\n                q.push(T[0][i]); \n        for (; !q.empty(); ) &#123;\n            int u = q.front();\n            q.pop();\n            for (int i = 0; i &lt; 26; ++i)\n                if (T[u][i]) &#123;\n                    int v = T[u][i];\n                    fail[v] = T[fail[u]][i], s[v] += s[fail[v]];\n                    q.push(v);\n                &#125;\n                else\n                    T[u][i] = T[fail[u]][i];\n        &#125;\n    &#125;\n    matrix f(0, tot), op(tot, tot);\n    f[0][0] = 0;\n    for (int i = 0; i &lt;= tot; ++i)\n        for (int j = 0; j &lt; 26; ++j)\n            op[i][T[i][j]] = s[T[i][j]];\n    f *= (op * m);\n    std::cout &lt;&lt; *std::max_element(f[0].begin(), f[0].end()) &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;\n</code></pre>\n</details>\n<hr />\n<h3 id=\"eg4.-you-are-given-some-strings\">eg4. You Are Given Some Strings…</h3>\n<p>goto <a href=\"/20250121/#%E4%B8%80%E4%B8%AA%E6%A8%A1%E6%9D%BFcf1202e-you-are-given-some-strings...\">link</a>.</p>\n",
            "tags": [
                "DP",
                "字符串",
                "AC 自动机"
            ]
        }
    ]
}