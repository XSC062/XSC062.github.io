<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://xsc062.netlify.app</id>
    <title> â€¢ Posts by &#34;ddp&#34; tag</title>
    <link href="https://xsc062.netlify.app" />
    <updated>2025-08-14T09:08:21.000Z</updated>
    <category term="å¹¶æŸ¥é›†" />
    <category term="æ–œç‡ä¼˜åŒ–" />
    <category term="æ‚¬çº¿æ³•" />
    <category term="å“ˆå¸Œ" />
    <category term="å­—å…¸æ ‘" />
    <category term="DP" />
    <category term="å•è°ƒé˜Ÿåˆ—" />
    <category term="åˆ†æ²»" />
    <category term="äºŒåˆ†å›¾" />
    <category term="CRT / exCRT" />
    <category term="æ’åˆ—ç»„åˆ" />
    <category term="ç½‘ç»œæµ" />
    <category term="è´¹ç”¨æµ" />
    <category term="äºŒåˆ†" />
    <category term="ä¸Šä¸‹ç•Œç½‘ç»œæµ" />
    <category term="å®¹æ–¥åŸç†" />
    <category term="çº¿æ®µæ ‘" />
    <category term="æ ‘çŠ¶æ•°ç»„" />
    <category term="åŒºé—´ DP" />
    <category term="æ„é€ " />
    <category term="Tarjan" />
    <category term="æ•°æ®ç»“æ„" />
    <category term="ä¸‹é¥­" />
    <category term="LCA" />
    <category term="å€å¢" />
    <category term="é¸½å·¢åŸç†" />
    <category term="æ¦‚ç‡æœŸæœ›" />
    <category term="è°ƒå’Œçº§æ•°" />
    <category term="å·®åˆ†" />
    <category term="æ€ç»´" />
    <category term="æ ‘å½¢ DP" />
    <category term="æœ€å°ç”Ÿæˆæ ‘" />
    <category term="SAM" />
    <category term="çŠ¶å‹" />
    <category term="åˆ†å—" />
    <category term="å¯æŒä¹…åŒ–" />
    <category term="ç¬›å¡å°”æ ‘" />
    <category term="é«˜ç»´å‰ç¼€å’Œ" />
    <category term="é—²è¯" />
    <category term="æ¬§æ‹‰å›è·¯" />
    <category term="æ ‘é“¾å‰–åˆ†" />
    <category term="é•¿é“¾å‰–åˆ†" />
    <category term="KMP" />
    <category term="border" />
    <category term="å­—ç¬¦ä¸²" />
    <category term="AC è‡ªåŠ¨æœº" />
    <category term="SA" />
    <category term="æ•°å­¦" />
    <category term="æ ‘ä¸Šå·®åˆ†" />
    <category term="FWT" />
    <category term="å †" />
    <category term="æ ‘çš„é‡å¿ƒ" />
    <category term="äºŒé¡¹å¼å®šç†" />
    <category term="äºŒé¡¹å¼åæ¼”" />
    <category term="è´ªå¿ƒ" />
    <category term="å‡æ‘Š" />
    <category term="è®¡æ•°" />
    <category term="ä¼˜åŒ–å»ºå›¾" />
    <category term="åæ‚”è´ªå¿ƒ" />
    <category term="è°ƒæ•´æ³•" />
    <category term="èƒŒåŒ…" />
    <category term="åšå¼ˆè®º" />
    <category term="DP ä¼˜åŒ–" />
    <category term="è™šæ ‘" />
    <category term="ç‚¹åˆ†æ²»" />
    <category term="WQS äºŒåˆ†" />
    <category term="é—µå¯å¤«æ–¯åŸºå’Œ" />
    <category term="slope trick" />
    <category term="å››è¾¹å½¢ä¸ç­‰å¼" />
    <category term="æš´åŠ›" />
    <category term="çŠ¶å‹ DP" />
    <category term="ç»„åˆæ•°å­¦" />
    <category term="æ”¯é…å¯¹" />
    <category term="DDP" />
    <category term="å¹³è¡¡æ ‘" />
    <category term="å®¹æ–¥" />
    <category term="çŒ«æ ‘" />
    <category term="Kruskal é‡æ„æ ‘" />
    <category term="æè¶…çº¿æ®µæ ‘" />
    <entry>
        <id>https://xsc062.netlify.app/20250814/</id>
        <title>DDP ä¸ GBT ç»ƒä¹ </title>
        <link rel="alternate" href="https://xsc062.netlify.app/20250814/"/>
        <content type="html">&lt;p&gt;çº¿æ®µæ ‘æ˜¯å¯¹çš„ï¼ˆå­˜ç–‘ï¼‰&lt;/p&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;a---æ•°æ®ä¼ è¾“&#34;&gt;A - æ•°æ®ä¼ è¾“&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P8820&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P8820&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;æˆ‘åœ¨ä¸Šä¸€ç¯‡æ–‡ç« ä¸­æåˆ°äº† &lt;a href=&#34;/20250812/#æ ‘ä¸Šè·¯å¾„æŸ¥è¯¢&#34;&gt;DDP &amp;amp; è·¯å¾„æŸ¥è¯¢é—®é¢˜&lt;/a&gt;ï¼Œåœ¨è¿™ä¸ªé¢˜ä¸­å°±æœ‰ä½“ç°ã€‚&lt;/p&gt;
&lt;p&gt;è®¾ &lt;span class=&#34;math inline&#34;&gt;\(f_{u,0/1/2}\)&lt;/span&gt; è¡¨ç¤ºæ•°æ®ä¿å­˜åœ¨ &lt;span class=&#34;math inline&#34;&gt;\(u\)&lt;/span&gt; å¾€ä¸‹æ•° &lt;span class=&#34;math inline&#34;&gt;\(0/1/2\)&lt;/span&gt; ä¸ªç‚¹å¤„çš„æœ€å°ä»£ä»·ï¼Œæ‰‹ç©å®¹æ˜“å‘ç° &lt;span class=&#34;math inline&#34;&gt;\(k=3\)&lt;/span&gt; æ—¶&lt;strong&gt;æœ€ä¼˜è·¯å¾„å¯èƒ½ä¼šå¾€æŸä¸ª &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; æˆ– &lt;span class=&#34;math inline&#34;&gt;\(fa\)&lt;/span&gt; å¤„çš„æœ€å°ä»£ä»·å„¿å­å¤„ç»•ä¸€åœˆæ¥é¿å…è¿™ä¸ª &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; æˆ– &lt;span class=&#34;math inline&#34;&gt;\(fa\)&lt;/span&gt; çš„ä»£ä»·&lt;/strong&gt;ã€‚ä½†è¯¥å€¼æ˜¯å®šå€¼ï¼Œé—®é¢˜è¿˜æ˜¯çº¯è·¯å¾„é—®é¢˜ï¼Œå°±å¯ä»¥ DDP äº†ã€‚&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&#34;image.png&#34; alt=&#34;å…±ä¸¤ç§å¯èƒ½æ€§ï¼ˆä»»æ„ä¸€ä¸ªç®­å¤´é•¿åº¦ä¸ä¸º 3 æ—¶ç»•ä¸€åœˆä¸€å®šä¸æ¯”ç›´æ¥èµ°æ›´ä¼˜ï¼‰&#34; /&gt;&lt;figcaption&gt;å…±ä¸¤ç§å¯èƒ½æ€§ï¼ˆä»»æ„ä¸€ä¸ªç®­å¤´é•¿åº¦ä¸ä¸º &lt;span class=&#34;math inline&#34;&gt;\(3\)&lt;/span&gt; æ—¶ç»•ä¸€åœˆä¸€å®šä¸æ¯”ç›´æ¥èµ°æ›´ä¼˜ï¼‰&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
struct mat &amp;#123;
    long long a[3][3];
    long long* operator[] (const int q) &amp;#123;
        return a[q];
    &amp;#125;
    mat() &amp;#123;
        memset(a, 0x3f, sizeof (a));
        return;
    &amp;#125;
    mat(int flag) &amp;#123;
        memset(a, 0x3f, sizeof (a));
        a[0][0] = a[1][1] = a[2][2] = 0ll;
        return;
    &amp;#125;
    mat operator* (mat &amp;amp;q) const &amp;#123;
        mat res;
        for (int i = 0; i &amp;lt; 3; ++i)
            for (int k = 0; k &amp;lt; 3; ++k)
                for (int j = 0; j &amp;lt; 3; ++j)
                    res[i][k] = std::min(res[i][k], a[i][j] + q[j][k]);
        return res;
    &amp;#125;
    mat&amp;amp; operator*= (mat &amp;amp;q) &amp;#123;
        return *this = *this * q;
    &amp;#125;
&amp;#125;;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, q, k;
    std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; q &amp;gt;&amp;gt; k;
    std::vector&amp;lt;int&amp;gt; a(n + 1);
    for (int i = 1; i &amp;lt;= n; ++i)
        std::cin &amp;gt;&amp;gt; a[i];
    std::vector&amp;lt;int&amp;gt; mx(n + 1, 0x3f3f3f3f);
    std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; g1(n + 1);
    for (int i = 1, x, y; i &amp;lt; n; ++i) &amp;#123;
        std::cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; y;
        mx[x] = std::min(mx[x], a[y]);
        mx[y] = std::min(mx[y], a[x]);
        g1[x].push_back(y), g1[y].push_back(x);
    &amp;#125;
    std::vector&amp;lt;int&amp;gt; dep(n + 1);
    std::vector&amp;lt;std::array&amp;lt;int, 18&amp;gt; &amp;gt; f(n + 1);
    std::vector&amp;lt;std::array&amp;lt;mat, 18&amp;gt; &amp;gt; u(n + 1), d(n + 1);
    u[0][0] = d[0][0] = mat(1);
    std::function&amp;lt;void(int)&amp;gt; DFS = [&amp;amp;](int x) &amp;#123;
        for (auto i : g1[x])
            if (i != f[x][0]) &amp;#123;
                f[i][0] = x;
                &amp;#123;
                    mat s;
                    s[0][0] = a[x];
                    if (k &amp;gt;= 2) &amp;#123;
                        s[0][1] = 0;
                        s[1][0] = a[x];
                    &amp;#125;
                    if (k &amp;gt;= 3) &amp;#123;
                        s[1][2] = 0;
                        s[2][0] = a[x];
                        s[1][1] = mx[x];
                        s[2][2] = mx[i];
                    &amp;#125;
                    u[i][0] = s; 
                    s[0][0] = a[i];
                    if (k &amp;gt;= 2)
                        s[1][0] = a[i];
                    if (k &amp;gt;= 3) &amp;#123;
                        s[2][0] = a[i];
                        s[1][1] = mx[i];
                        s[2][2] = mx[x];
                    &amp;#125;
                    d[i][0] = s; 
                &amp;#125;
                for (int j = 1; j &amp;lt; 18; ++j) &amp;#123;
                    f[i][j] = f[f[i][j - 1]][j - 1];
                    u[i][j] = u[i][j - 1] * u[f[i][j - 1]][j - 1];
                    d[i][j] = d[f[i][j - 1]][j - 1] * d[i][j - 1];
                &amp;#125;
                dep[i] = dep[x] + 1;
                DFS(i);
            &amp;#125;
        return;
    &amp;#125;;
    dep[1] = 1, DFS(1);
    for (int x, y; q--; ) &amp;#123;
        std::cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; y;
        long long res = a[x];
        mat r1(1), r2(1);
        if (dep[x] &amp;gt; dep[y]) &amp;#123;
            for (int i = 17; ~i; --i)
                if (dep[f[x][i]] &amp;gt;= dep[y]) &amp;#123;
                    r1 = r1 * u[x][i];
                    x = f[x][i];
                &amp;#125;
        &amp;#125;
        else if (dep[y] &amp;gt; dep[x]) &amp;#123;
            for (int i = 17; ~i; --i)
                if (dep[f[y][i]] &amp;gt;= dep[x]) &amp;#123;
                    r2 = d[y][i] * r2;
                    y = f[y][i];
                &amp;#125;
        &amp;#125;
        if (x != y) &amp;#123;
            for (int i = 17; ~i; --i)
                if (f[x][i] != f[y][i]) &amp;#123;
                    r1 = r1 * u[x][i];
                    r2 = d[y][i] * r2;
                    x = f[x][i], y = f[y][i];
                &amp;#125;
            r1 = r1 * u[x][0], r2 = d[y][0] * r2;
        &amp;#125;
        std::cout &amp;lt;&amp;lt; res + (r1 * r2)[0][0] &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    &amp;#125;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;b---the-silk-road-with-robots&#34;&gt;B - The Silk Road â€¦ with Robots!&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://qoj.ac/problem/10410&#34; class=&#34;uri&#34;&gt;https://qoj.ac/problem/10410&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;é¢˜æ„ï¼šåˆå§‹æœ‰ä¸€ä¸ªé•¿ä¸º &lt;span class=&#34;math inline&#34;&gt;\(10^8\)&lt;/span&gt; çš„ç©ºæ•°è½´ï¼Œç»™å®š &lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt; æ¬¡æ“ä½œï¼Œæ¯æ¬¡æ“ä½œåœ¨æ•°è½´ä¸Šçš„ä¸€ä¸ªç©ºä½æ”¾ä¸€ä¸ª A ç±»ç‚¹æˆ– B ç±»ç‚¹ã€‚æ¯ä¸ª A ç±»ç‚¹æœ‰å…¶&lt;strong&gt;ä»·å€¼&lt;/strong&gt;ã€‚&lt;/p&gt;
&lt;p&gt;ä»»æ„åœ¨æ•°è½´ä¸Šç§»åŠ¨è¿™äº› B ç±»ç‚¹ï¼Œ&lt;strong&gt;æ€»ä»·å€¼&lt;/strong&gt;ä¸ºæ‰€æœ‰è¢«ç»è¿‡çš„ A ç±»ç‚¹çš„&lt;strong&gt;ä»·å€¼&lt;/strong&gt; - B ç±»ç‚¹ç§»åŠ¨æ€»è·¯ç¨‹ã€‚æ¯æ¬¡æ“ä½œåè¾“å‡ºæœ€å¤§&lt;strong&gt;æ€»ä»·å€¼&lt;/strong&gt;ï¼Œé‡å¤ç»è¿‡çš„ A ç±»ç‚¹åªè®¡ä¸€æ¬¡ã€‚&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(n\le 2\times 10^5\)&lt;/span&gt;ã€‚&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;è¿™ä¸ªé¢˜ç¡®å®å¯ä»¥å¸¦æ¥å¾ˆå¤šå¯å‘ï¼Œæˆ‘ä¸€å¼€å§‹ç›´æ¥è®¾ &lt;span class=&#34;math inline&#34;&gt;\(f_j\)&lt;/span&gt; ä¸ºçŠ¶æ€ï¼Œè¿™æ ·å¯¹äºæš´åŠ›æ˜¯å¯åšçš„ï¼Œä½†æ˜¯ä¼šå‡ºç°ä¸€äº›éœ€è¦è¢«åŒºé—´ä¿®æ”¹çš„ç³»æ•°ï¼Œæ¯”å¦‚&lt;strong&gt;å‰ç¼€å’Œ&lt;/strong&gt;ã€‚æœ€å¥½è®¾è®¡çŠ¶æ€ï¼Œè®©è½¬ç§»çš„æ—¶å€™åªéœ€è¦ç”¨åˆ°å¸¸æ•°ã€å·®åˆ†å€¼ç­‰ä¿®æ”¹æ¬¡æ•°å¾ˆå°‘çš„ç³»æ•°ã€‚&lt;/p&gt;
&lt;p&gt;è®¾ &lt;span class=&#34;math inline&#34;&gt;\(f_{i,0/1/2/3}\)&lt;/span&gt; åˆ†åˆ«è¡¨ç¤ºï¼š&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image-1.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;é‚£ä¹ˆå¯ä»¥å†™å‡ºè½¬ç§»å¼ï¼š&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
f_{i,0}=\max(mx+a_i+x_i,f_{i-1,0}+a_i)\\
f_{i,1}=\max(mx+a_i+2x_i,f_{i-1,1}+a_i)\\
f_{i,2}=f_{i-1,2}-(x_i-x_{i-1}) + a_i\\
f_{i,3}=f_{i-1,3}-2(x_i-x_{i-1})+a_i
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;å…¶ä¸­ &lt;span class=&#34;math inline&#34;&gt;\(mx\)&lt;/span&gt; ä¸º &lt;span class=&#34;math inline&#34;&gt;\(f_{i,2/3}\)&lt;/span&gt; çš„å‰ç¼€æœ€å¤§å€¼ã€‚åœ¨ B ç±»ç‚¹å¤„å¯ä»¥è®© &lt;span class=&#34;math inline&#34;&gt;\(f_{2/3}\)&lt;/span&gt; ç»§æ‰¿å¯¹åº”çš„ &lt;span class=&#34;math inline&#34;&gt;\(f_{0/1}\)&lt;/span&gt;ï¼Œæ–°å¼€ä¸€ç»´è®°å½• &lt;span class=&#34;math inline&#34;&gt;\(mx\)&lt;/span&gt; å°±å¯ä»¥ç»´æŠ¤çŸ©ä¹˜äº†ã€‚&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int lim = 1e8;
const int maxn = 5e6 + 5;
const long long inf = 1e12;
struct mat &amp;#123;
    long long a[5][5];
    mat() &amp;#123;&amp;#125;
    long long* operator[] (const int q) &amp;#123;
        return a[q];
    &amp;#125;
    mat operator* (mat &amp;amp;q) const &amp;#123;
        mat res;
        for (int i = 0; i &amp;lt; 5; ++i)
            for (int k = 0; k &amp;lt; 5; ++k) &amp;#123;
                auto u(-inf);
                for (int j = 0; j &amp;lt; 5; ++j)
                    u = std::max(u, a[i][j] + q[j][k]);
                res[i][k] = u;
            &amp;#125;
        return res;
    &amp;#125;
    mat&amp;amp; operator*= (mat &amp;amp;q) &amp;#123;
        return *this = *this * q;
    &amp;#125;
&amp;#125;;
struct &amp;#123; int l, r; mat u; &amp;#125; t[maxn];
#define lt t[p].l
#define rt t[p].r
void add(int &amp;amp;p, int l, int r, int x, mat &amp;amp;v) &amp;#123;
    static int tot = 0;
    if (!p)
        p = ++tot;
    if (l == r) &amp;#123;
        t[p].u = v;
        return;
    &amp;#125;
    int mid = (l + r) &amp;gt;&amp;gt; 1;
    if (x &amp;lt;= mid)
        add(lt, l, mid, x, v);
    else
        add(rt, mid + 1, r, x, v);
    t[p].u = t[lt].u * t[rt].u;
    return;
&amp;#125;
#undef lt
#undef rt
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    &amp;#123;
        mat &amp;amp;u = t[0].u;
        for (int i = 0; i &amp;lt; 5; ++i)
            for (int j = 0; j &amp;lt; 5; ++j)
                u[i][j] = -inf;
        u[0][0] = u[1][1] = u[2][2] = u[3][3] = u[4][4] = 0ll;
    &amp;#125;
    int m, rt = 0;
    std::cin &amp;gt;&amp;gt; m;
    std::vector&amp;lt;mat&amp;gt; a(m + 1);
    std::vector&amp;lt;int&amp;gt; ty(m + 1);
    std::set&amp;lt;std::pair&amp;lt;long long, int&amp;gt; &amp;gt; s;
    s.emplace(-inf, 0);
    for (int op, x, i = 1; i &amp;lt;= m; ++i) &amp;#123;
        std::cin &amp;gt;&amp;gt; op &amp;gt;&amp;gt; x;
        auto &amp;amp;u = a[i];
        for (int i = 0; i &amp;lt; 5; ++i)
            for (int j = 0; j &amp;lt; 5; ++j)
                u[i][j] = -inf;
        auto p = --s.lower_bound(std::make_pair(x, 0)), q = s.upper_bound(std::make_pair(x, 0));
        int v = 0;
        if (op == 2)
            std::cin &amp;gt;&amp;gt; v;
        u[0][0] = v, u[1][1] = v, u[4][0] = v + x, u[4][1] = v + 2 * x;
        if (op == 1) &amp;#123;
            ty[i] = 0;
            u[4][2] = u[4][1] - 2 * x;
            u[1][2] = u[1][1] - 2 * x;
            u[4][3] = u[4][0] - x;
            u[0][3] = u[0][0] - x;
        &amp;#125;
        else &amp;#123;
            ty[i] = 1;
            u[2][2] = v - (x - p-&amp;gt;first);
            u[3][3] = v - 2 * (x - p-&amp;gt;first);
        &amp;#125;
        u[4][4] = std::max(&amp;#123; 0ll, u[4][2], u[4][3] &amp;#125;);
        u[1][4] = u[1][2], u[0][4] = u[0][3], u[2][4] = u[2][2], u[3][4] = u[3][3];
        add(rt, 0, lim, x, u);
        if (q != s.end() &amp;amp;&amp;amp; ty[q-&amp;gt;second] == 1) &amp;#123;
            auto &amp;amp;u = a[q-&amp;gt;second];
            u[2][2] -= p-&amp;gt;first, u[2][2] += x;
            u[3][3] -= 2 * p-&amp;gt;first, u[3][3] += 2 * x;
            u[2][4] = u[2][2], u[3][4] = u[3][3];
            add(rt, 0, lim, q-&amp;gt;first, a[q-&amp;gt;second]);
        &amp;#125;
        s.emplace(x, i);
        std::cout &amp;lt;&amp;lt; t[1].u[4][4] &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
        // for (int i = 0; i &amp;lt; 5; ++i, puts(&amp;quot;&amp;quot;))
        //     for (int j = 0; j &amp;lt; 5; ++j)
        //         if (t[1].u[i][j] &amp;lt; -200)
        //             printf(&amp;quot;  x &amp;quot;);
        //         else
        //             printf(&amp;quot;%3lld &amp;quot;, t[1].u[i][j]);
        // puts(&amp;quot;=============&amp;quot;);
    &amp;#125;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;c---å¯†ç ç®±&#34;&gt;C - å¯†ç ç®±&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;/20250818/#c---%E5%AF%86%E7%A0%81%E7%AE%B1&#34;&gt;link&lt;/a&gt;;&lt;/p&gt;
</content>
        <category term="çº¿æ®µæ ‘" />
        <category term="DDP" />
        <updated>2025-08-14T09:08:21.000Z</updated>
    </entry>
    <entry>
        <id>https://xsc062.netlify.app/20250812/</id>
        <title>DDP ä¸å…¨å±€å¹³è¡¡äºŒå‰æ ‘</title>
        <link rel="alternate" href="https://xsc062.netlify.app/20250812/"/>
        <content type="html">&lt;p&gt;å…¶å®åŠ¨æ€ DP ä¸æ˜¯åŠ¨æ€æ ‘ DP çš„åŒä¹‰è¯&lt;/p&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;åŠ¨æ€-dp&#34;&gt;åŠ¨æ€ DP&lt;/h2&gt;
&lt;p&gt;å¯¹äºè½¬ç§»åªä¾èµ–å‰å‡ é¡¹çš„ DPï¼Œå¯ä»¥æ”¾è¿›çŸ©é˜µã€‚&lt;/p&gt;
&lt;p&gt;é»˜è®¤è½¬ç§»èŒƒå›´æ˜¯ &lt;span class=&#34;math inline&#34;&gt;\([1,n]\)&lt;/span&gt;ï¼›å¦‚æœæˆ‘ä»¬éœ€è¦æ”¹å˜æ±‚è§£èŒƒå›´ï¼Œå‘ç°å¦‚æœèƒ½è·å–è½¬ç§»çŸ©é˜µçš„ä¹˜ç§¯å°±å¾ˆå¿«äº†ã€‚è€ƒè™‘å­˜ä¸‹æ¥ã€‚&lt;/p&gt;
&lt;p&gt;å¦‚æœéœ€è¦å•ç‚¹ä¿®æ”¹ï¼Œç­‰ä»·äºä¿®æ”¹å…¶æ‰€åœ¨çŸ©é˜µï¼Œåˆ™æƒ³è¦å°½å¯èƒ½å°‘åœ°ä¿®æ”¹å­˜å‚¨çš„ç­”æ¡ˆï¼Œè€ƒè™‘ä½¿ç”¨çº¿æ®µæ ‘ä¼˜åŒ–è¯¥è¿‡ç¨‹ã€‚&lt;/p&gt;
&lt;h3 id=&#34;ä¾‹æµ·æŠ¥&#34;&gt;ä¾‹ï¼šæµ·æŠ¥&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P9790&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P9790&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;å®¹æ˜“åˆ—å‡ºæš´åŠ› DP å¼ï¼šä»¤ &lt;span class=&#34;math inline&#34;&gt;\(f_{i,j}\)&lt;/span&gt; è¡¨ç¤ºæšä¸¾åˆ° &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; æ—¶ï¼ŒåŒ…å« &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; åœ¨å†…å·²ç»æœ‰ &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; ä¸ªè¿ç»­çš„äººä¸¾èµ·æµ·æŠ¥ï¼Œæ˜“å¾—ï¼š&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
f_{i,0}=\max(f_{i-1,0},f_{i-1,1},f_{i-1,2},f_{i-1,3})\\
f_{i,j}=f_{i-1,j-1}+a_i \forall 1\le j\le 3
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;å‘ç°æ»¡è¶³ + / max &lt;strong&gt;çŸ©é˜µä¹˜æ³•&lt;/strong&gt; çš„å½¢å¼ï¼›æƒ³åˆ°ç”¨çº¿æ®µæ ‘ä¿å­˜æ¯æ®µåŒºé—´å¯¹åº”çŸ©é˜µï¼ˆå¯¹åº”æ€§è´¨ï¼šç»“åˆå¾‹ï¼‰ï¼Œæ¯æ¬¡ä¿®æ”¹ / æŸ¥è¯¢å°±èƒ½åœ¨ &lt;span class=&#34;math inline&#34;&gt;\(O(\log n)\)&lt;/span&gt; ä¹‹å†…å®Œæˆã€‚&lt;/p&gt;
&lt;p&gt;åŸé—®é¢˜æ˜¯ç¯å½¢çš„ï¼Œå¯ä»¥å†åŠ ä¸€ç»´ &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; è¡¨ç¤ºé’¦å®šé€‰äº†å‰ &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; ä¸ªä¸”ä¸é€‰ç¬¬ &lt;span class=&#34;math inline&#34;&gt;\(k+1\)&lt;/span&gt; ä¸ªæ—¶çš„ç­”æ¡ˆã€‚&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int maxn = 4e4 + 5;
const long long inf = 1e18;
struct mat &amp;#123;
    int n, m;
    long long a[4][4];
    mat() &amp;#123;&amp;#125;
    mat(int n1, int m1): n(n1), m(m1) &amp;#123;
        for (int i = 0; i &amp;lt; n; ++i)
            for (int j = 0; j &amp;lt; m; ++j)
                a[i][j] = -inf;
        return;
    &amp;#125;
    long long* operator[] (const int q) &amp;#123;
        return a[q];
    &amp;#125;
    mat operator* (mat &amp;amp;q) const &amp;#123;
        mat res(n, q.m);
        for (int i = 0; i &amp;lt; n; ++i)
            for (int k = 0; k &amp;lt; q.m; ++k)
                for (int j = 0; j &amp;lt; m; ++j)
                    res[i][k] = std::max(res[i][k], a[i][j] + q[j][k]);
        return res;
    &amp;#125;
    mat&amp;amp; operator*= (mat &amp;amp;q) &amp;#123;
        return *this = *this * q;
    &amp;#125;
&amp;#125;;
struct &amp;#123; int l, r; mat u[4]; &amp;#125; t[maxn &amp;lt;&amp;lt; 2];
int a[maxn];
#define lt (p &amp;lt;&amp;lt; 1)
#define rt (lt | 1)
#define c t[p].u[i]
void bld(int p, int l, int r) &amp;#123;
    t[p].l = l, t[p].r = r;
    if (l == r) &amp;#123;
        for (int i = 0; i &amp;lt;= 3; ++i) &amp;#123;
            c = mat(4, 4);
            if (l &amp;gt; i + 1) &amp;#123;
                c[0][0] = c[1][0] = c[2][0] = c[3][0] = 0;
                c[0][1] = c[1][2] = c[2][3] = a[l];
            &amp;#125;
            else if (l == i + 1)
                c[0][0] = c[1][0] = c[2][0] = c[3][0] = 0;
            else
                c[0][1] = c[1][2] = c[2][3] = a[l];
        &amp;#125;
        return;
    &amp;#125;
    int mid = (l + r) &amp;gt;&amp;gt; 1;
    bld(lt, l, mid), bld(rt, mid + 1, r);
    for (int i = 0; i &amp;lt;= 3; ++i)
        t[p].u[i] = t[lt].u[i] * t[rt].u[i];
    return;
&amp;#125;
void add(int p, int x, int v) &amp;#123;
    if (t[p].l == t[p].r) &amp;#123;
        for (int i = 0; i &amp;lt;= 3; ++i)
            if (t[p].l != i + 1) 
                c[0][1] = c[1][2] = c[2][3] = v;
        return;
    &amp;#125;
    int mid = (t[p].l + t[p].r) &amp;gt;&amp;gt; 1;
    if (x &amp;lt;= mid)
        add(lt, x, v);
    else
        add(rt, x, v);
    for (int i = 0; i &amp;lt;= 3; ++i)
        t[p].u[i] = t[lt].u[i] * t[rt].u[i];
    return;
&amp;#125;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n;
    std::cin &amp;gt;&amp;gt; n;
    for (int i = 1; i &amp;lt;= n; ++i)
        std::cin &amp;gt;&amp;gt; a[i];
    bld(1, 1, n);
    auto calc = [&amp;amp;](void) &amp;#123;
        mat f(1, 4);
        f[0][0] = 0;
        auto res = -inf;
        for (int i = 0; i &amp;lt;= 3; ++i) &amp;#123;
            auto r = (f * t[1].u[i]);
            for (int j = 0; j &amp;lt;= 3; ++j)
                if (i + j &amp;lt;= 3) &amp;#123;
                    res = std::max(res, r[0][j]);
                    // printf(&amp;quot;f[%d][%d] = %lld\n&amp;quot;, i, j, f[i][j]);
                &amp;#125;
        &amp;#125;
        return res;
    &amp;#125;;
    std::cout &amp;lt;&amp;lt; calc() &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    int q;
    std::cin &amp;gt;&amp;gt; q;
    for (int x, v; q--; ) &amp;#123;
        std::cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; v;
        add(1, x, v);
        std::cout &amp;lt;&amp;lt; calc() &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    &amp;#125;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;p&gt;å‘ç°çŸ©é˜µæœ¬èº«å’Œ &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; æ— å…³ï¼Œè¿˜å¯ä»¥å¯ä»¥å…±ç”¨ä¸€ä¸ªçº¿æ®µæ ‘ä¸Šçš„ä¿¡æ¯ï¼Œå°±å¯ä»¥åªå¼€ä¸€ä¸ªçº¿æ®µæ ‘äº†ã€‚&lt;/p&gt;
&lt;details&gt;
&lt;p&gt;æˆ‘å†™è¿™ä¸€ç‰ˆæœ¬çš„åŸå› æ˜¯ &lt;code&gt;maxn&lt;/code&gt; å¼€å¤§äº†å¯¼è‡´ MLEï¼Œå®é™…ä¸Šå››ä¸ªçº¿æ®µæ ‘æ˜¯æ²¡æœ‰ä»»ä½•ç©ºé—´å‹åŠ›çš„ ğŸ˜…&lt;/p&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int maxn = 4e5 + 5;
const long long inf = 1e18;
struct mat &amp;#123;
    int n, m;
    long long a[4][4];
    mat() &amp;#123;&amp;#125;
    mat(int n1, int m1): n(n1), m(m1) &amp;#123;
        for (int i = 0; i &amp;lt; n; ++i)
            for (int j = 0; j &amp;lt; m; ++j)
                a[i][j] = -inf;
        return;
    &amp;#125;
    long long* operator[] (const int q) &amp;#123;
        return a[q];
    &amp;#125;
    mat operator* (mat q) const &amp;#123;
        mat res(n, q.m);
        for (int i = 0; i &amp;lt; n; ++i)
            for (int k = 0; k &amp;lt; q.m; ++k)
                for (int j = 0; j &amp;lt; m; ++j)
                    res[i][k] = std::max(res[i][k], a[i][j] + q[j][k]);
        return res;
    &amp;#125;
    mat&amp;amp; operator*= (mat &amp;amp;q) &amp;#123;
        return *this = *this * q;
    &amp;#125;
&amp;#125;;
struct &amp;#123; int l, r; mat u; &amp;#125; t[maxn &amp;lt;&amp;lt; 2];
int a[maxn];
#define lt (p &amp;lt;&amp;lt; 1)
#define rt (lt | 1)
void bld(int p, int l, int r) &amp;#123;
    t[p].l = l, t[p].r = r;
    if (l == r) &amp;#123;
        t[p].u = mat(4, 4);
        t[p].u[0][0] = t[p].u[1][0] = t[p].u[2][0] = t[p].u[3][0] = 0;
        t[p].u[0][1] = t[p].u[1][2] = t[p].u[2][3] = a[l];
        return;
    &amp;#125;
    int mid = (l + r) &amp;gt;&amp;gt; 1;
    bld(lt, l, mid), bld(rt, mid + 1, r);
    t[p].u = t[lt].u * t[rt].u;
    return;
&amp;#125;
void add(int p, int x, int v) &amp;#123;
    if (t[p].l == t[p].r) &amp;#123;
        t[p].u[0][1] = t[p].u[1][2] = t[p].u[2][3] = v;
        return;
    &amp;#125;
    int mid = (t[p].l + t[p].r) &amp;gt;&amp;gt; 1;
    if (x &amp;lt;= mid)
        add(lt, x, v);
    else
        add(rt, x, v);
    t[p].u = t[lt].u * t[rt].u;
    return;
&amp;#125;
mat ask(int p, int l, int r) &amp;#123;
    if (l &amp;lt;= t[p].l &amp;amp;&amp;amp; t[p].r &amp;lt;= r)
        return t[p].u;
    int mid = (t[p].l + t[p].r) &amp;gt;&amp;gt; 1;
    if (r &amp;lt;= mid)
        return ask(lt, l, r);
    if (l &amp;gt; mid)
        return ask(rt, l, r);
    return ask(lt, l, r) * ask(rt, l, r);
&amp;#125;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n;
    std::cin &amp;gt;&amp;gt; n;
    for (int i = 1; i &amp;lt;= n; ++i)
        std::cin &amp;gt;&amp;gt; a[i];
    bld(1, 1, n);
    auto calc = [&amp;amp;](void) &amp;#123;
        mat f(1, 4);
        f[0][0] = 0, f[0][1] = f[0][2] = f[0][3] = -inf;
        auto r(f * ask(1, 2, n));
        auto res(*std::max_element(r[0], r[0] + 4));
        mat z(4, 4);
        z[0][0] = z[1][0] = z[2][0] = z[3][0] = 0ll;
        for (int i = 1; i &amp;lt;= 3; ++i) &amp;#123;
            mat op(4, 4);
            op[0][1] = op[1][2] = op[2][3] = a[i];
            f *= op;
            if (i + 2 &amp;lt;= n)
                r = f * z * ask(1, i + 2, n);
            else
                r = f * z;
            res = std::max(res, *std::max_element(r[0], r[0] + 4 - i));
        &amp;#125;
        return res;
    &amp;#125;;
    std::cout &amp;lt;&amp;lt; calc() &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    int q;
    std::cin &amp;gt;&amp;gt; q;
    for (int x, v; q--; ) &amp;#123;
        std::cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; v, a[x] = v;
        add(1, x, v);
        std::cout &amp;lt;&amp;lt; calc() &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    &amp;#125;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;ç»å…¸é¢˜gss3&#34;&gt;ç»å…¸é¢˜ï¼šGSS3&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/SP1716&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/SP1716&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;æ€ä¹ˆæ˜¯å­æ®µå’Œ ğŸ˜“&lt;/p&gt;
&lt;p&gt;åŒæ ·åˆ—å‡ºèƒ½å¤ŸçŸ©é˜µä¹˜æ³•çš„ DP å¼ï¼Œå‘ç°é™åˆ¶åœ¨äºè‡³å°‘è¦é€‰ä¸€ä¸ªæ•°ã€‚è®¾ &lt;span class=&#34;math inline&#34;&gt;\(f_{i}\)&lt;/span&gt; è¡¨ç¤ºé€‰äº† &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; çš„æœ€å¤§å€¼ï¼Œ&lt;span class=&#34;math inline&#34;&gt;\(g_i\)&lt;/span&gt; è¡¨ç¤ºå†å²æœ€å¤§å€¼ï¼Œåˆ™ï¼š&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
f_i=\max(f_{i-1}+a_i,0+a_i)\\
g_i=\max(g_{i-1}+0,f_{i-1}+a_i,0+a_i)
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;å®¹æ˜“å‘ç°æ˜¯ä¸€ä¸ª + / max çŸ©ä¹˜ï¼Œçº¿æ®µæ ‘ç»´æŠ¤å³å¯ã€‚&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int maxn = 4e5 + 5;
const long long inf = 1e18;
struct mat &amp;#123;
    int n, m;
    long long a[3][3];
    mat() &amp;#123;&amp;#125;
    mat(int n1, int m1): n(n1), m(m1) &amp;#123;
        for (int i = 0; i &amp;lt; n; ++i)
            for (int j = 0; j &amp;lt; m; ++j)
                a[i][j] = -inf;
        return;
    &amp;#125;
    long long* operator[] (const int q) &amp;#123;
        return a[q];
    &amp;#125;
    mat operator* (mat q) const &amp;#123;
        mat res(n, q.m);
        for (int i = 0; i &amp;lt; n; ++i)
            for (int k = 0; k &amp;lt; q.m; ++k)
                for (int j = 0; j &amp;lt; m; ++j)
                    res[i][k] = std::max(res[i][k], a[i][j] + q[j][k]);
        return res;
    &amp;#125;
    mat&amp;amp; operator*= (mat &amp;amp;q) &amp;#123;
        return *this = *this * q;
    &amp;#125;
&amp;#125;;
struct &amp;#123; int l, r; mat u; &amp;#125; t[maxn &amp;lt;&amp;lt; 2]; 
int a[maxn];
#define lt (p &amp;lt;&amp;lt; 1)
#define rt (lt | 1)
void bld(int p, int l, int r) &amp;#123;
    t[p].l = l, t[p].r = r;
    if (l == r) &amp;#123;
        t[p].u = mat(3, 3);
        t[p].u[0][0] = t[p].u[2][0] = a[l];
        t[p].u[0][1] = a[l], t[p].u[1][1] = 0ll, t[p].u[2][1] = a[l];
        t[p].u[2][2] = 0ll;
        return;
    &amp;#125;
    int mid = (l + r) &amp;gt;&amp;gt; 1;
    bld(lt, l, mid), bld(rt, mid + 1, r);
    t[p].u = t[lt].u * t[rt].u;
    return;
&amp;#125;
void add(int p, int x, int v) &amp;#123;
    if (t[p].l == t[p].r) &amp;#123;
        t[p].u[0][0] = t[p].u[2][0] = t[p].u[0][1] = t[p].u[2][1] = v;
        return;
    &amp;#125;
    int mid = (t[p].l + t[p].r) &amp;gt;&amp;gt; 1;
    if (x &amp;lt;= mid)
        add(lt, x, v);
    else
        add(rt, x, v);
    t[p].u = t[lt].u * t[rt].u;
    return;
&amp;#125;
mat ask(int p, int l, int r) &amp;#123;
    if (l &amp;lt;= t[p].l &amp;amp;&amp;amp; t[p].r &amp;lt;= r)
        return t[p].u;
    int mid = (t[p].l + t[p].r) &amp;gt;&amp;gt; 1;
    if (r &amp;lt;= mid)
        return ask(lt, l, r);
    if (l &amp;gt; mid)
        return ask(rt, l, r);
    return ask(lt, l, r) * ask(rt, l, r);
&amp;#125;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n;
    std::cin &amp;gt;&amp;gt; n;
    for (int i = 1; i &amp;lt;= n; ++i)
        std::cin &amp;gt;&amp;gt; a[i];
    bld(1, 1, n);
    auto calc = [&amp;amp;](int l, int r) &amp;#123;
        mat f(1, 3);
        f[0][2] = 0ll;
        auto res(f * ask(1, l, r));
        return res[0][1];
    &amp;#125;;
    int q;
    std::cin &amp;gt;&amp;gt; q;
    for (int op; q--; ) &amp;#123;
        std::cin &amp;gt;&amp;gt; op;
        if (op == 1) &amp;#123;
            int l, r;
            std::cin &amp;gt;&amp;gt; l &amp;gt;&amp;gt; r;
            std::cout &amp;lt;&amp;lt; calc(l, r) &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
        &amp;#125;
        else &amp;#123;
            int x, v;
            std::cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; v;
            a[x] = v, add(1, x, v);
        &amp;#125;
    &amp;#125;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;åŠ¨æ€æ ‘-dp&#34;&gt;åŠ¨æ€æ ‘ DP&lt;/h2&gt;
&lt;p&gt;æŠŠä¸Šè¿°è¿‡ç¨‹æ”¾åˆ°æ ‘ä¸Šï¼Œå¾ˆå®¹æ˜“æƒ³åˆ°æ ‘å‰– + çº¿æ®µæ ‘ã€‚&lt;/p&gt;
&lt;p&gt;ç”±äºè®¤ä¸ºçº¿æ®µæ ‘ä¸Šçš„çŸ©ä¹˜åªèƒ½è¿›è¡Œä»é‡å„¿å­åˆ°çˆ¶äº²çš„è½¬ç§»ï¼Œè½»å„¿å­çš„è½¬ç§»ä¼šè¢«åˆå¹¶ä¸ºä¸€ä¸ªæ–°å‡½æ•°ï¼ˆåŒæ—¶æ˜¯çŸ©é˜µçš„ç³»æ•°ï¼‰ï¼Œåœ¨è·³é‡é“¾çš„æ—¶å€™è¢«å•ç‹¬æ›´æ–°ã€‚&lt;/p&gt;
&lt;p&gt;ç”±äºä¸¤ä¸ªå‡½æ•°ç›¸äº’ä¾èµ–ï¼Œéœ€è¦æ€è€ƒæ¸…æ¥šæ›´æ–°çš„å…ˆåé¡ºåºã€‚&lt;/p&gt;
&lt;h3 id=&#34;æ¨¡æ¿åŠ¨æ€-dp&#34;&gt;ã€æ¨¡æ¿ã€‘åŠ¨æ€ DP&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P4719&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P4719&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ä»¤ &lt;span class=&#34;math inline&#34;&gt;\(f_{u,0/1}\)&lt;/span&gt; è¡¨ç¤ºåœ¨ &lt;span class=&#34;math inline&#34;&gt;\(u\)&lt;/span&gt; ä¸Šï¼Œé€‰ / ä¸é€‰ &lt;span class=&#34;math inline&#34;&gt;\(u\)&lt;/span&gt; çš„æœ€å¤§ä»·å€¼ã€‚å®¹æ˜“å¾—å‡ºè½¬ç§»ï¼š&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
f_{u,0}=\sum\max(f_{v,0},f_{v,1})\\
f_{u,1}=a_i+\sum f_{v,0}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;æŠŠè½¬ç§»çŸ©é˜µæ”¾åˆ°æ ‘å‰–ä¸Šåï¼Œè€ƒè™‘æ›´æ–°ï¼Œå‘ç°æ±‚å’Œè¿™ä¸€æ­¥å¾ˆå›°éš¾ã€‚è§£å†³æ–¹æ¡ˆæ˜¯&lt;strong&gt;ç›´æ¥å°†æ±‚å’Œç”¨å¦ä¸€ä¸ªå‡½æ•°ä»£æ›¿&lt;/strong&gt;ã€‚å®šä¹‰ &lt;span class=&#34;math inline&#34;&gt;\(g_{u,0}\)&lt;/span&gt; è¡¨ç¤ºå– &lt;span class=&#34;math inline&#34;&gt;\(u\)&lt;/span&gt;ã€ä¸å– &lt;span class=&#34;math inline&#34;&gt;\(u\)&lt;/span&gt; çš„æ‰€æœ‰è½»å„¿å­çš„ç­”æ¡ˆï¼Œ&lt;span class=&#34;math inline&#34;&gt;\(g_{u,1}\)&lt;/span&gt; ä¸å– &lt;span class=&#34;math inline&#34;&gt;\(u\)&lt;/span&gt;ï¼Œè½»å„¿å­å¯é€‰å¯ä¸é€‰çš„ç­”æ¡ˆã€‚&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(g\)&lt;/span&gt; æ˜¯å¯æ±‚çš„ï¼Œä¸”åªéœ€è¦åœ¨è·³é‡é“¾çš„æ—¶å€™æ›´æ–° &lt;span class=&#34;math inline&#34;&gt;\(g\)&lt;/span&gt;ã€‚å…·ä½“æ›´æ–°èµ·æ¥éå¸¸ç»ï¼Œå› ä¸º &lt;span class=&#34;math inline&#34;&gt;\(g\)&lt;/span&gt; å’Œ &lt;span class=&#34;math inline&#34;&gt;\(f\)&lt;/span&gt; æ˜¯ç›¸äº’ä¾èµ–çš„ï¼Œéœ€è¦åˆ†æ¸…æ¥šå…ˆåå…³ç³»ã€‚&lt;/p&gt;
&lt;p&gt;é¦–å…ˆ &lt;span class=&#34;math inline&#34;&gt;\(g_u\)&lt;/span&gt; å’Œ &lt;span class=&#34;math inline&#34;&gt;\(f_u\)&lt;/span&gt; éƒ½ä¼šè¢«æ›´æ–°ï¼›æ¥ç€ï¼Œé‡é“¾ä¸Šå…¶å®ƒçš„ &lt;span class=&#34;math inline&#34;&gt;\(g\)&lt;/span&gt; ä¸ä¼šè¢«å½±å“ï¼Œè€Œé“¾é¡¶çš„ &lt;span class=&#34;math inline&#34;&gt;\(f\)&lt;/span&gt; éœ€è¦è¢«æ–°çš„ &lt;span class=&#34;math inline&#34;&gt;\(g_u\)&lt;/span&gt; æ›´æ–°ï¼›ç”±æ­¤é“¾é¡¶çˆ¶äº²çš„ &lt;span class=&#34;math inline&#34;&gt;\(g\)&lt;/span&gt; è¢«æ›´æ–°ï¼›ä¾æ¬¡ç±»æ¨ã€‚æ³¨æ„åˆ°å¯¹äºä¸€ä¸ªé“¾é¡¶ï¼Œå…¶ &lt;span class=&#34;math inline&#34;&gt;\(f\)&lt;/span&gt; å€¼æ˜¯æ•´æ¡é‡é“¾çš„ä¹˜ç§¯ï¼Œæ•…éœ€è¦è®°å½•é“¾åº•ã€‚&lt;/p&gt;
&lt;p&gt;å¤æ‚åº¦ &lt;span class=&#34;math inline&#34;&gt;\(O(q\log ^2n)\)&lt;/span&gt;ã€‚æ³¨æ„å¾ˆé‡è¦çš„ä¸€ç‚¹æ˜¯çº¿æ®µæ ‘å†…ä¹˜æ³•åº”ä»å³å¾€å·¦ã€‚&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int maxn = 1e5 + 5;
const int inf = 0x3f3f3f3f;
struct mat &amp;#123;
    int n, m, a[2][2];
    mat() &amp;#123;&amp;#125;
    mat(int n1, int m1): n(n1), m(m1) &amp;#123;
        for (int i = 0; i &amp;lt; n; ++i)
            for (int j = 0; j &amp;lt; m; ++j)
                a[i][j] = -inf;
        return;
    &amp;#125;
    int* operator[] (const int q) &amp;#123;
        return a[q];
    &amp;#125;
    mat operator* (mat q) const &amp;#123;
        mat res(n, q.m);
        for (int i = 0; i &amp;lt; n; ++i)
            for (int k = 0; k &amp;lt; q.m; ++k)
                for (int j = 0; j &amp;lt; m; ++j)
                    res[i][k] = std::max(res[i][k], a[i][j] + q[j][k]);
        return res;
    &amp;#125;
    mat&amp;amp; operator*= (mat &amp;amp;q) &amp;#123;
        return *this = *this * q;
    &amp;#125;
&amp;#125;;
struct &amp;#123; int l, r; mat u; &amp;#125; t[maxn &amp;lt;&amp;lt; 2]; 
int g[maxn][2], tab[maxn];
#define lt (p &amp;lt;&amp;lt; 1)
#define rt (lt | 1)
void bld(int p, int l, int r) &amp;#123;
    t[p].l = l, t[p].r = r;
    if (l == r) &amp;#123;
        int u = tab[l];
        t[p].u = mat(2, 2);
        t[p].u[0][0] = t[p].u[1][0] = g[u][1];
        t[p].u[0][1] = g[u][0];
        return;
    &amp;#125;
    int mid = (l + r) &amp;gt;&amp;gt; 1;
    bld(lt, l, mid), bld(rt, mid + 1, r);
    t[p].u = t[rt].u * t[lt].u;
    return;
&amp;#125;
void add(int p, int x) &amp;#123;
    if (t[p].l == t[p].r) &amp;#123;
        int u = tab[x];
        t[p].u[0][0] = t[p].u[1][0] = g[u][1];
        t[p].u[0][1] = g[u][0];
        return;
    &amp;#125;
    int mid = (t[p].l + t[p].r) &amp;gt;&amp;gt; 1;
    if (x &amp;lt;= mid)
        add(lt, x);
    else
        add(rt, x);
    t[p].u = t[rt].u * t[lt].u;
    return;
&amp;#125;
mat ask(int p, int l, int r) &amp;#123;
    if (l &amp;lt;= t[p].l &amp;amp;&amp;amp; t[p].r &amp;lt;= r)
        return t[p].u;
    int mid = (t[p].l + t[p].r) &amp;gt;&amp;gt; 1;
    if (r &amp;lt;= mid)
        return ask(lt, l, r);
    if (l &amp;gt; mid)
        return ask(rt, l, r);
    return ask(rt, l, r) * ask(lt, l, r);
&amp;#125;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, q;
    std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; q;
    std::vector&amp;lt;int&amp;gt; a(n + 1);
    for (int i = 1; i &amp;lt;= n; ++i)
        std::cin &amp;gt;&amp;gt; a[i];
    std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; g1(n + 1);
    for (int i = 1, x, y; i &amp;lt; n; ++i) &amp;#123;
        std::cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; y;
        g1[x].push_back(y), g1[y].push_back(x);
    &amp;#125;
    std::vector&amp;lt;int&amp;gt; siz(n + 1), son(n + 1), fa(n + 1);
    std::function&amp;lt;void(int)&amp;gt; DFS = [&amp;amp;](int x) &amp;#123;
        siz[x] = 1;
        for (auto i : g1[x])
            if (i != fa[x]) &amp;#123;
                fa[i] = x, DFS(i);
                siz[x] += siz[i];
                if (siz[i] &amp;gt; siz[son[x]])
                    son[x] = i;
            &amp;#125;
        return;
    &amp;#125;;
    DFS(1);
    std::vector&amp;lt;std::array&amp;lt;int, 2&amp;gt; &amp;gt; f(n + 1);
    std::vector&amp;lt;int&amp;gt; top(n + 1), bot(n + 1), dfn(n + 1);
    DFS = [&amp;amp;](int x) &amp;#123;
        static int now = 0;
        dfn[x] = ++now, tab[now] = x;
        if (son[x]) &amp;#123;
            top[son[x]] = top[x], DFS(son[x]);
            bot[x] = bot[son[x]];
            g[x][0] = a[x];
            for (auto i : g1[x])
                if (i != son[x] &amp;amp;&amp;amp; i != fa[x]) &amp;#123;
                    top[i] = i, DFS(i);
                    g[x][0] += f[i][0];
                    g[x][1] += std::max(f[i][1], f[i][0]);
                &amp;#125;
            f[x][0] = g[x][1] + std::max(f[son[x]][0], f[son[x]][1]);
            f[x][1] = g[x][0] + f[son[x]][0];
        &amp;#125;
        else
            f[x][1] = g[x][0] = a[x], bot[x] = x;
        return;
    &amp;#125;;
    top[1] = 1, DFS(1);
    bld(1, 1, n);
    for (int x, v; q--; ) &amp;#123;
        std::cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; v;
        g[x][0] -= a[x], g[x][0] += v, a[x] = v;
        for (; top[x] != 1; ) &amp;#123;
            auto r = ask(1, dfn[top[x]], dfn[bot[x]]);
            f[top[x]][0] = r[0][0], f[top[x]][1] = r[0][1];
            g[fa[top[x]]][0] -= f[top[x]][0];
            g[fa[top[x]]][1] -= std::max(f[top[x]][0], f[top[x]][1]);
            add(1, dfn[x]);
            r = ask(1, dfn[top[x]], dfn[bot[x]]);
            f[top[x]][0] = r[0][0], f[top[x]][1] = r[0][1];
            g[fa[top[x]]][0] += f[top[x]][0];
            g[fa[top[x]]][1] += std::max(f[top[x]][0], f[top[x]][1]);
            x = fa[top[x]];
        &amp;#125;
        add(1, dfn[x]);
        auto r = ask(1, dfn[1], dfn[bot[1]]);
        f[1][0] = r[0][0], f[1][1] = r[0][1];
        std::cout &amp;lt;&amp;lt; std::max(f[1][0], f[1][1]) &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    &amp;#125;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;å…¨å±€å¹³è¡¡äºŒå‰æ ‘&#34;&gt;å…¨å±€å¹³è¡¡äºŒå‰æ ‘&lt;/h2&gt;
&lt;p&gt;å›é¡¾æ ‘å‰–ï¼ˆé‡å‰–ï¼‰ï¼ŒåŠŸèƒ½åœ¨äºè§£å†³è·¯å¾„é—®é¢˜ï¼Œå•æ¬¡æ“ä½œèƒ½å¤Ÿåœ¨ &lt;span class=&#34;math inline&#34;&gt;\(O(\log^2 n)\)&lt;/span&gt; çš„æ—¶é—´å†…å®Œæˆã€‚è¿™ä¸ªåŠŸèƒ½å¯ä»¥è¢«&lt;strong&gt;å…¨å±€å¹³è¡¡äºŒå‰æ ‘ï¼ˆGBTï¼‰&lt;/strong&gt;ä¸Šä½æ›¿ä»£ã€‚GBT èƒ½å¤Ÿåœ¨å•æ¬¡ &lt;span class=&#34;math inline&#34;&gt;\(O(\log n)\)&lt;/span&gt; çš„å¤æ‚åº¦å†…å®Œæˆé“¾æ“ä½œã€å­æ ‘æ“ä½œã€‚&lt;em&gt;&lt;a href=&#34;QTREEè§£æ³•çš„ä¸€äº›ç ”ç©¶.pdf&#34;&gt;Yang Zhe - SPOJ375 QTREE è§£æ³•çš„ä¸€äº›ç ”ç©¶&lt;/a&gt; ä¸­æ›´ä¸ºè¯¦ç»†ä¸¥è°¨åœ°å¯¹ GBT è¿›è¡Œäº†è¯´æ˜ï¼Œæˆ‘ä¼ äº†ä»½æ–‡ä»¶ä¸Šæ¥ã€‚&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;è€ƒè™‘æ ‘å‰–èƒ½è¢«å¡çš„åŸå› ï¼šæ¯æ¬¡çº¿æ®µæ ‘è¯¢é—®éƒ½ä¼šå¡æ»¡ &lt;span class=&#34;math inline&#34;&gt;\(O(\log n)\)&lt;/span&gt;ï¼Œæ‰¾ä¸€æ¡å¡å¾—æ»¡ &lt;span class=&#34;math inline&#34;&gt;\(O(\log n)\)&lt;/span&gt; æ¬¡è·³é‡é“¾æ¬¡æ•°çš„è·¯å¾„ä¸€ç›´è–…ï¼Œå°±å¯ä»¥å¡åˆ° &lt;span class=&#34;math inline&#34;&gt;\(O(\log^2 n)\)&lt;/span&gt;ã€‚&lt;/p&gt;
&lt;p&gt;åœ¨å®ç°çº¿æ®µæ ‘æ—¶å‘ç°ï¼Œå¯¹äº&lt;strong&gt;è·¯å¾„æ“ä½œ&lt;/strong&gt;å’Œ&lt;strong&gt;å•ç‚¹æ“ä½œ&lt;/strong&gt;ï¼Œæ ‘å‰–åªéœ€è¦ç»´æŠ¤åŒä¸€æ¡é‡é“¾çš„ä¿¡æ¯ï¼Œå»ºä¸€ä¸ªå¤§çº¿æ®µæ ‘ä¼šäº§ç”Ÿè®¸å¤šé‡é“¾é—´çš„æ— æ•ˆç»´æŠ¤ã€‚æ•…ä¸€ç§ç»å…¸çš„æ ‘å‰–å¡å¸¸æŠ€å·§æ˜¯å¯¹äºæ¯ä¸€æ¡é‡é“¾å»ºå‡ºçº¿æ®µæ ‘ã€‚&lt;/p&gt;
&lt;p&gt;åœ¨æœ¬æ–‡ä¸­å®šä¹‰&lt;strong&gt;å…¨å±€äºŒå‰æ ‘&lt;/strong&gt;ï¼šå°†å•ä¸ªçº¿æ®µæ ‘æŒ‰ç…§åœ¨åŸæ ‘ä¸Šé‡é“¾é¡¶çš„ç›¸å¯¹ç¥–å­™å…³ç³»è¿è¾¹å¾—åˆ°çš„æ¨¡å‹ã€‚è¿™é‡Œä¸ºäº†å’Œ&lt;strong&gt;å…¨å±€å¹³è¡¡äºŒå‰æ ‘&lt;/strong&gt;å½¢æˆç…§åº”è€Œå‘½åï¼Œå®é™…ä¸Šæ¨¡å‹å¹¶ä¸æ˜¯äºŒå‰æ ‘ã€‚å®¹æ˜“å‘ç°&lt;strong&gt;ä¿®æ”¹æŸä¸ªç‚¹èŠ±è´¹çš„æ“ä½œæ¬¡æ•°å’Œå…¶åœ¨å…¨å±€äºŒå‰æ ‘ä¸­çš„æ·±åº¦ç›¸åŒ&lt;/strong&gt;ã€‚&lt;/p&gt;
&lt;p&gt;è€ƒè™‘æœ¬æ–¹æ³•ç†è®ºä¸Šä»å¯å¡åˆ° &lt;span class=&#34;math inline&#34;&gt;\(O(\log^2 n)\)&lt;/span&gt; å•æ¬¡æ“ä½œçš„åŸå› ï¼Œè™½ç„¶å•ä¸ªçº¿æ®µæ ‘å¹³è¡¡ï¼Œä½†&lt;strong&gt;å…¨å±€äºŒå‰æ ‘&lt;/strong&gt;å¹¶ä¸å¹³è¡¡ï¼›èƒ½å¤Ÿæ„é€ æ•°æ®ä½¿å¾—æ ‘é«˜è¾¾åˆ° &lt;span class=&#34;math inline&#34;&gt;\(\log^2 n\)&lt;/span&gt;ã€‚è€ƒè™‘ä½¿å¾—å…¨å±€äºŒå‰æ ‘å¹³è¡¡ï¼Œå³è°ƒæ•´çº¿æ®µæ ‘ç»“æ„ä½¿å¾—ä»»ä½•ä¸€ä¸ªç‚¹åœ¨å…¨å±€äºŒå‰æ ‘ä¸Šçš„å·¦å³å„¿å­å¤§å°æœ€æ¥è¿‘ã€‚å‘ç°æ˜¯æ˜“åšçš„ï¼Œåªéœ€åœ¨å»ºçº¿æ®µæ ‘æ—¶ç§»åŠ¨å·¦å³å„¿å­åˆ†å‰²ç‚¹ä½¿å¾—ä¸¤è¾¹å­æ ‘å¤§å°å‡ä¸ºå…¨æ ‘çš„ä¸€åŠå³å¯ã€‚&lt;/p&gt;
&lt;p&gt;æ³•ä¸€ï¼šæ±‚å‡ºæ¯ä¸ªç‚¹çš„è½»å­æ ‘å¤§å° &lt;span class=&#34;math inline&#34;&gt;\(ls_u=1+\sum siz_v\)&lt;/span&gt;ï¼Œä½œä¸ºåŠ æƒåœ¨çº¿æ®µæ ‘ä¸Šæ‰¾ mid å°±èƒ½æ»¡è¶³å…¨å±€å¹³è¡¡ï¼›è¯æ˜å¯ä»¥è§ä¸Šé¢çš„è®ºæ–‡ã€‚è¿™é‡Œç”¨çº¿æ®µæ ‘ä»£æ›¿äº† BSTï¼Œå¸¸æ•°å¾ˆå¤§ã€‚&lt;/p&gt;
&lt;p&gt;æ³•äºŒï¼šç”¨ä¸€ä¸ª BST å®ç°ä¸Šè¿°åŠŸèƒ½ï¼Œéœ€è¦æ»¡è¶³ï¼šä»»æ„å­æ ‘çš„æ ¹ä¸ºå­æ ‘çš„å¸¦æƒ midï¼›BST çš„ä¸­åºéå†ä¸ºåŸé‡é“¾ã€‚æ˜¾ç„¶æœ‰ï¼šæ ‘é«˜ä¸º log çº§åˆ«ã€‚è¿™å°±å†³å®šäº†æ‰€æœ‰é—®é¢˜éƒ½å¯ä»¥é€šè¿‡æš´åŠ›çˆ¬å±±è§£å†³ã€‚&lt;/p&gt;
&lt;p&gt;GBT èƒ½å¤Ÿå¿«é€Ÿç»´æŠ¤&lt;strong&gt;æ™®é€šæ ‘å‰–æ“ä½œ&lt;/strong&gt;å’Œ &lt;strong&gt;DDP ä¿¡æ¯&lt;/strong&gt;ã€‚&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;ç»´æŠ¤-ddpæ¨¡æ¿åŠ¨æ€-dpåŠ å¼ºç‰ˆ&#34;&gt;ç»´æŠ¤ DDPï¼šã€æ¨¡æ¿ã€‘åŠ¨æ€ DPï¼ˆåŠ å¼ºç‰ˆï¼‰&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P4751&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P4751&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;å’ŒæœªåŠ å¼ºç‰ˆç±»ä¼¼ï¼ŒæŠŠæ‰€æœ‰çº¿æ®µæ ‘æ“ä½œæ›¿æ¢ä¸º BST å³å¯ã€‚å¦‚æœå†™å¾—ä¸‘å¯èƒ½éœ€è¦ä¸€äº›é¢å¤–çš„å¡å¸¸æŠ€å·§ã€‚&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int maxn = 1e6 + 5;
const int inf = 0x3f3f3f3f;
const int LEN = (1 &amp;lt;&amp;lt; 20);
int nec(void) &amp;#123;
    static char buf[LEN], *p = buf, *e = buf;
    if (p == e) &amp;#123;
        e = buf + fread(buf, 1, LEN, stdin);
        if (e == buf) return EOF;
        p = buf;
    &amp;#125;
    return *p++;
&amp;#125;
bool read(int &amp;amp;x) &amp;#123;
    x = 0;
    bool f = 0;
    char ch = nec();
    while (ch &amp;lt; &amp;#39;0&amp;#39; || ch &amp;gt; &amp;#39;9&amp;#39;) &amp;#123;
        if (ch == EOF) return 0;
        if (ch == &amp;#39;-&amp;#39;) f = 1;
        ch = nec();
    &amp;#125;
    while (ch &amp;gt;= &amp;#39;0&amp;#39; &amp;amp;&amp;amp; ch &amp;lt;= &amp;#39;9&amp;#39;) &amp;#123;
        x = x * 10 + ch - &amp;#39;0&amp;#39;;
        ch = nec();
    &amp;#125;
    if (f) x = -x;
    return 1;
&amp;#125;
void print(int x) &amp;#123;
    if (x &amp;lt; 0)
        putchar(&amp;#39;-&amp;#39;), x = -x;
    if (x &amp;gt;= 10) print(x / 10);
    putchar(x % 10 + &amp;#39;0&amp;#39;);
    return;
&amp;#125;
void print(int x, char ch) &amp;#123;
    print(x), putchar(ch);
    return;
&amp;#125;
struct mat &amp;#123;
    int a[2][2];
    int* operator[] (const int q) &amp;#123; 
        return a[q];
    &amp;#125;
    mat operator* (mat &amp;amp;q) const &amp;#123;
        mat res;
        res[0][0] = res[0][1] = res[1][0] = res[1][1] = -inf;
        for (int i = 0; i &amp;lt; 2; ++i)
            for (int k = 0; k &amp;lt; 2; ++k)
                for (int j = 0; j &amp;lt; 2; ++j)
                    res[i][k] = std::max(res[i][k], a[i][j] + q[j][k]);
        return res;
    &amp;#125;
    mat&amp;amp; operator*= (mat &amp;amp;q) &amp;#123;
        return *this = *this * q;
    &amp;#125;
&amp;#125;;
struct &amp;#123; int lc, rc, fa; mat u; &amp;#125; t[maxn]; 
int g[maxn][2], tab[maxn], ls[maxn];
mat p[maxn];
void pushup(int x) &amp;#123;
    t[x].u = t[t[x].rc].u * p[x] * t[t[x].lc].u;
    return;
&amp;#125;
void bld(int &amp;amp;x, int l, int r) &amp;#123;
    if (l &amp;gt; r)
        return;
    int s = 0, k = 0;
    for (int i = l; i &amp;lt;= r; ++i)
        s += ls[tab[i]];
    for (int i = l; i &amp;lt;= r; ++i, k += ls[tab[i]])
        if ((k + ls[tab[i]]) * 2 &amp;gt; s) &amp;#123;
            x = tab[i];
            bld(t[x].lc, l, i - 1), t[t[x].lc].fa = x;
            bld(t[x].rc, i + 1, r), t[t[x].rc].fa = x;
            pushup(x);
            break;
        &amp;#125;
    return;
&amp;#125;
#undef lt
#undef rt
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    t[0].u[0][0] = t[0].u[1][1] = 0, t[0].u[0][1] = t[0].u[1][0] = -inf;
    int n, q;
    read(n), read(q);
    std::vector&amp;lt;int&amp;gt; a(n + 1), rt(n + 1);
    for (int i = 1; i &amp;lt;= n; ++i)
        read(a[i]);
    std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; g1(n + 1);
    for (int i = 1, x, y; i &amp;lt; n; ++i) &amp;#123;
        read(x), read(y);
        g1[x].push_back(y), g1[y].push_back(x);
    &amp;#125;
    std::vector&amp;lt;int&amp;gt; son(n + 1), fa(n + 1), siz(n + 1);
    std::function&amp;lt;void(int)&amp;gt; DFS = [&amp;amp;](int x) &amp;#123;
        siz[x] = 1;
        for (auto i : g1[x])
            if (i != fa[x]) &amp;#123;
                fa[i] = x, DFS(i);
                siz[x] += siz[i];
                if (siz[i] &amp;gt; siz[son[x]])
                    son[x] = i;
            &amp;#125;
        return;
    &amp;#125;;
    DFS(1);
    std::vector&amp;lt;std::array&amp;lt;int, 2&amp;gt; &amp;gt; f(n + 1);
    std::vector&amp;lt;int&amp;gt; top(n + 1), bot(n + 1), dfn(n + 1);
    DFS = [&amp;amp;](int x) &amp;#123;
        static int now = 0;
        dfn[x] = ++now, tab[now] = x, ls[x] = 1;
        if (son[x]) &amp;#123;
            top[son[x]] = top[x], DFS(son[x]);
            bot[x] = bot[son[x]];
            g[x][0] = a[x];
            for (auto i : g1[x])
                if (i != son[x] &amp;amp;&amp;amp; i != fa[x]) &amp;#123;
                    top[i] = i, DFS(i), t[rt[i]].fa = x;
                    ls[x] += siz[i];
                    g[x][0] += f[i][0];
                    g[x][1] += std::max(f[i][1], f[i][0]);
                &amp;#125;
            f[x][0] = g[x][1] + std::max(f[son[x]][0], f[son[x]][1]);
            f[x][1] = g[x][0] + f[son[x]][0];
        &amp;#125;
        else
            f[x][1] = g[x][0] = a[x], bot[x] = x;
        p[x][0][0] = p[x][1][0] = g[x][1];
        p[x][0][1] = g[x][0], p[x][1][1] = -inf;
        if (x == top[x])
            bld(rt[x], dfn[x], dfn[bot[x]]);
        return;
    &amp;#125;;
    top[1] = 1, DFS(1);
    for (int x, v, la = 0; q--; ) &amp;#123;
        read(x), read(v), x ^= la;
        p[x][0][1] += v - a[x], a[x] = v;
        for (; x; ) &amp;#123;
            int fa = t[x].fa;
            if (fa &amp;amp;&amp;amp; x != t[fa].lc &amp;amp;&amp;amp; x != t[fa].rc) &amp;#123;
                int f0 = t[x].u[0][0], f1 = std::max(f0, t[x].u[0][1]);
                pushup(x);
                int F0 = t[x].u[0][0], F1 = std::max(F0, t[x].u[0][1]);
                p[fa][0][0] += F1 - f1, p[fa][1][0] += F1 - f1;
                p[fa][0][1] += F0 - f0;
            &amp;#125;
            else
                pushup(x);
            x = fa;
        &amp;#125;
        print(la = std::max(t[rt[1]].u[0][0], t[rt[1]].u[0][1]), &amp;#39;\n&amp;#39;);
    &amp;#125;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;p&gt;ä¹Ÿç»™å‡ºä¸€ä¸ªçº¿æ®µæ ‘ç‰ˆæœ¬çš„&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int maxn = 1e6 + 5;
const int inf = 0x3f3f3f3f;
const int LEN = (1 &amp;lt;&amp;lt; 20);
int nec(void) &amp;#123;
    static char buf[LEN], *p = buf, *e = buf;
    if (p == e) &amp;#123;
        e = buf + fread(buf, 1, LEN, stdin);
        if (e == buf) return EOF;
        p = buf;
    &amp;#125;
    return *p++;
&amp;#125;
bool read(int &amp;amp;x) &amp;#123;
    x = 0;
    bool f = 0;
    char ch = nec();
    while (ch &amp;lt; &amp;#39;0&amp;#39; || ch &amp;gt; &amp;#39;9&amp;#39;) &amp;#123;
        if (ch == EOF) return 0;
        if (ch == &amp;#39;-&amp;#39;) f = 1;
        ch = nec();
    &amp;#125;
    while (ch &amp;gt;= &amp;#39;0&amp;#39; &amp;amp;&amp;amp; ch &amp;lt;= &amp;#39;9&amp;#39;) &amp;#123;
        x = x * 10 + ch - &amp;#39;0&amp;#39;;
        ch = nec();
    &amp;#125;
    if (f) x = -x;
    return 1;
&amp;#125;
void print(int x) &amp;#123;
    if (x &amp;lt; 0)
        putchar(&amp;#39;-&amp;#39;), x = -x;
    if (x &amp;gt;= 10) print(x / 10);
    putchar(x % 10 + &amp;#39;0&amp;#39;);
    return;
&amp;#125;
void print(int x, char ch) &amp;#123;
    print(x), putchar(ch);
    return;
&amp;#125;
struct mat &amp;#123;
    int a[2][2];
    int* operator[] (const int q) &amp;#123;
        return a[q];
    &amp;#125;
    mat operator* (mat q) const &amp;#123;
        mat res;
        res[0][0] = res[0][1] = res[1][0] = res[1][1] = -inf;
        for (int i = 0; i &amp;lt; 2; ++i)
            for (int k = 0; k &amp;lt; 2; ++k)
                for (int j = 0; j &amp;lt; 2; ++j)
                    res[i][k] = std::max(res[i][k], a[i][j] + q[j][k]);
        return res;
    &amp;#125;
    mat&amp;amp; operator*= (mat &amp;amp;q) &amp;#123;
        return *this = *this * q;
    &amp;#125;
&amp;#125;;
struct &amp;#123; int lc, rc, l, r, mid; mat u; &amp;#125; t[maxn &amp;lt;&amp;lt; 2]; 
int g[maxn][2], tab[maxn], ls[maxn];
#define lt t[p].lc
#define rt t[p].rc
void bld(int &amp;amp;p, int l, int r) &amp;#123;
    static int tot = 0;
    p = ++tot, t[p].l = l, t[p].r = r;
    if (l == r) &amp;#123;
        int u = tab[l];
        t[p].u[0][0] = t[p].u[1][0] = g[u][1];
        t[p].u[0][1] = g[u][0], t[p].u[1][1] = -inf;
        return;
    &amp;#125;
    int s = 0, u = ls[tab[l]];
    for (int i = l; i &amp;lt;= r; ++i)
        s += ls[tab[i]];
    s &amp;gt;&amp;gt;= 1;
    t[p].mid = r - 1;
    for (int i = l + 1; i &amp;lt; r; ++i) &amp;#123;
        u += ls[tab[i]];
        if (u + ls[tab[i + 1]] &amp;gt; s) &amp;#123;
            t[p].mid = i;
            break;
        &amp;#125;
    &amp;#125;
    bld(lt, l, t[p].mid), bld(rt, t[p].mid + 1, r);
    t[p].u = t[rt].u * t[lt].u;
    return;
&amp;#125;
void add(int p, int x) &amp;#123;
    if (t[p].l == t[p].r) &amp;#123;
        int u = tab[x];
        t[p].u[0][0] = t[p].u[1][0] = g[u][1];
        t[p].u[0][1] = g[u][0];
        return;
    &amp;#125;
    if (x &amp;lt;= t[p].mid)
        add(lt, x);
    else
        add(rt, x);
    t[p].u = t[rt].u * t[lt].u;
    return;
&amp;#125;
mat ask(int p, int l, int r) &amp;#123;
    if (l &amp;lt;= t[p].l &amp;amp;&amp;amp; t[p].r &amp;lt;= r)
        return t[p].u;
    if (r &amp;lt;= t[p].mid)
        return ask(lt, l, r);
    if (l &amp;gt; t[p].mid)
        return ask(rt, l, r);
    return ask(rt, l, r) * ask(lt, l, r);
&amp;#125;
#undef lt
#undef rt
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, q;
    read(n), read(q);
    std::vector&amp;lt;int&amp;gt; a(n + 1), rt(n + 1);
    for (int i = 1; i &amp;lt;= n; ++i)
        read(a[i]);
    std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; g1(n + 1);
    for (int i = 1, x, y; i &amp;lt; n; ++i) &amp;#123;
        read(x), read(y);
        g1[x].push_back(y), g1[y].push_back(x);
    &amp;#125;
    std::vector&amp;lt;int&amp;gt; siz(n + 1), son(n + 1), fa(n + 1);
    std::function&amp;lt;void(int)&amp;gt; DFS = [&amp;amp;](int x) &amp;#123;
        siz[x] = 1;
        for (auto i : g1[x])
            if (i != fa[x]) &amp;#123;
                fa[i] = x, DFS(i);
                siz[x] += siz[i];
                if (siz[i] &amp;gt; siz[son[x]])
                    son[x] = i;
            &amp;#125;
        return;
    &amp;#125;;
    DFS(1);
    std::vector&amp;lt;std::array&amp;lt;int, 2&amp;gt; &amp;gt; f(n + 1);
    std::vector&amp;lt;int&amp;gt; top(n + 1), bot(n + 1), dfn(n + 1);
    DFS = [&amp;amp;](int x) &amp;#123;
        static int now = 0;
        dfn[x] = ++now, tab[now] = x;
        ls[x] = 1;
        if (son[x]) &amp;#123;
            top[son[x]] = top[x], DFS(son[x]);
            bot[x] = bot[son[x]];
            g[x][0] = a[x];
            for (auto i : g1[x])
                if (i != son[x] &amp;amp;&amp;amp; i != fa[x]) &amp;#123;
                    top[i] = i, DFS(i);
                    ls[x] += siz[i];
                    g[x][0] += f[i][0];
                    g[x][1] += std::max(f[i][1], f[i][0]);
                &amp;#125;
            f[x][0] = g[x][1] + std::max(f[son[x]][0], f[son[x]][1]);
            f[x][1] = g[x][0] + f[son[x]][0];
        &amp;#125;
        else
            f[x][1] = g[x][0] = a[x], bot[x] = x;
        if (x == top[x])
            bld(rt[x], dfn[x], dfn[bot[x]]);
        return;
    &amp;#125;;
    top[1] = 1, DFS(1);
    for (int x, v, la = 0; q--; ) &amp;#123;
        read(x), read(v), x ^= la;
        g[x][0] -= a[x], g[x][0] += v, a[x] = v;
        for (; top[x] != 1; ) &amp;#123;
            auto r = t[rt[top[x]]].u;
            f[top[x]][0] = r[0][0], f[top[x]][1] = r[0][1];
            g[fa[top[x]]][0] -= f[top[x]][0];
            g[fa[top[x]]][1] -= std::max(f[top[x]][0], f[top[x]][1]);
            add(rt[top[x]], dfn[x]);
            r = t[rt[top[x]]].u;
            f[top[x]][0] = r[0][0], f[top[x]][1] = r[0][1];
            g[fa[top[x]]][0] += f[top[x]][0];
            g[fa[top[x]]][1] += std::max(f[top[x]][0], f[top[x]][1]);
            x = fa[top[x]];
        &amp;#125;
        add(rt[1], dfn[x]);
        auto r =  t[rt[1]].u;
        f[1][0] = r[0][0], f[1][1] = r[0][1];
        std::cout &amp;lt;&amp;lt; (la = std::max(f[1][0], f[1][1])) &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    &amp;#125;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;æ ‘ä¸Šè·¯å¾„é—®é¢˜æŸ“è‰²&#34;&gt;æ ‘ä¸Šè·¯å¾„é—®é¢˜ï¼šæŸ“è‰²&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P2486&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P2486&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;GBT ä¸Šçš„&lt;strong&gt;è·¯å¾„é—®é¢˜&lt;/strong&gt;ã€‚&lt;/p&gt;
&lt;p&gt;BSTï¼šé¦–å…ˆæš´åŠ›çˆ¬å±±åˆ° LCAï¼Œç»Ÿè®¡ä¸€è·¯ä¸Šçš„ç­”æ¡ˆï¼›ç„¶åè·³åˆ°å½“å‰ BST çš„æ ¹ã€‚ç”±äºæœ¬é¢˜æœ‰æ ‡è®°ï¼Œæ‰€ä»¥éœ€è¦åœ¨è·³çš„åŒæ—¶æƒ³åŠæ³•æŠŠæ ‡è®°é—®é¢˜è§£å†³ä¸€ä¸‹ã€‚&lt;/p&gt;
&lt;p&gt;çº¿æ®µæ ‘ï¼šæŠŠæ ‘å‰–çš„çº¿æ®µæ ‘ç•¥æ”¹ä¸€ä¸‹å°±è¿‡äº†ã€‚ä»ä¸Šä¸€è¡Œæ¨¡æ£±ä¸¤å¯çš„æè¿°å°±å¯ä»¥çœ‹å‡ºæ¥ BST å®ç°èµ·æ¥ä¸å¤ªè½»æ¾ï¼›è¿˜æ˜¯çº¿æ®µæ ‘æ›´è½®æ¤…å•Šï¼&lt;/p&gt;
&lt;details&gt;
&lt;p&gt;è·‘å¾—æ²¡çº¯æ ‘å‰–å¿«ï¼Œå› ä¸ºæ•°æ®æ²¡æœ‰åˆ»æ„æ„é€ å¯¼è‡´æ ‘é«˜å¾ˆä½ï¼Œå†åŠ ä¸Šå¸¸æ•°çš„å½±å“å§ã€‚&lt;/p&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int maxn = 1e5 + 5;
const int LEN = (1 &amp;lt;&amp;lt; 20);
int nec(void) &amp;#123;
    static char buf[LEN], *p = buf, *e = buf;
    if (p == e) &amp;#123;
        e = buf + fread(buf, 1, LEN, stdin);
        if (e == buf) return EOF;
        p = buf;
    &amp;#125;
    return *p++;
&amp;#125;
bool read(int &amp;amp;x) &amp;#123;
    x = 0;
    bool f = 0;
    char ch = nec();
    while (ch &amp;lt; &amp;#39;0&amp;#39; || ch &amp;gt; &amp;#39;9&amp;#39;) &amp;#123;
        if (ch == EOF) return 0;
        if (ch == &amp;#39;-&amp;#39;) f = 1;
        ch = nec();
    &amp;#125;
    while (ch &amp;gt;= &amp;#39;0&amp;#39; &amp;amp;&amp;amp; ch &amp;lt;= &amp;#39;9&amp;#39;) &amp;#123;
        x = x * 10 + ch - &amp;#39;0&amp;#39;;
        ch = nec();
    &amp;#125;
    if (f) x = -x;
    return 1;
&amp;#125;
void read(char &amp;amp;x) &amp;#123;
    for (x = nec(); x != &amp;#39;C&amp;#39; &amp;amp;&amp;amp; x != &amp;#39;Q&amp;#39;; x = nec());
    return;
&amp;#125;
void print(int x) &amp;#123;
    if (x &amp;lt; 0)
        putchar(&amp;#39;-&amp;#39;), x = -x;
    if (x &amp;gt;= 10) print(x / 10);
    putchar(x % 10 + &amp;#39;0&amp;#39;);
    return;
&amp;#125;
void print(int x, char ch) &amp;#123;
    print(x), putchar(ch);
    return;
&amp;#125;
class node &amp;#123;
private:
    int lt, rt;
public:
    int l, r, mid, lc, rc, u, d;
    node(): u(-1) &amp;#123;&amp;#125;
    inline int&amp;amp; ls(void) &amp;#123; return lt; &amp;#125;
    inline int&amp;amp; rs(void) &amp;#123; return rt; &amp;#125;
    node&amp;amp; operator= (const node &amp;amp;q) &amp;#123;
        lc = q.lc, rc = q.rc, u = q.u;
        return *this;
    &amp;#125;
    node operator+ (const node &amp;amp;q) const &amp;#123;
        if (u == -1)
            return q;
        if (q.u == -1)
            return *this;
        node res;
        res.lc = lc, res.rc = q.rc, res.u = u + q.u - (rc == q.lc);
        return res;
    &amp;#125;
    inline void swap(void) &amp;#123;
        if (~u)
            lc ^= rc ^= lc ^= rc;
        return;
    &amp;#125;
&amp;#125; t[maxn &amp;lt;&amp;lt; 2]; 
int tab[maxn], ls[maxn], a[maxn];
#define lt t[p].ls()
#define rt t[p].rs()
void bld(int &amp;amp;p, int l, int r) &amp;#123;
    static int tot = 0;
    p = ++tot, t[p].l = l, t[p].r = r;
    if (l == r) &amp;#123;
        t[p].u = 1;
        t[p].lc = t[p].rc = a[tab[l]];
        return;
    &amp;#125;
    int s = 0, u = ls[tab[l]];
    for (int i = l; i &amp;lt;= r; ++i)
        s += ls[tab[i]];
    s &amp;gt;&amp;gt;= 1;
    t[p].mid = r - 1;
    for (int i = l + 1; i &amp;lt; r; ++i) &amp;#123;
        u += ls[tab[i]];
        if (u + ls[tab[i + 1]] &amp;gt; s) &amp;#123;
            t[p].mid = i;
            break;
        &amp;#125;
    &amp;#125;
    bld(lt, l, t[p].mid), bld(rt, t[p].mid + 1, r);
    t[p] = t[lt] + t[rt];
    return;
&amp;#125;
void pushdown(int p) &amp;#123;
    if (t[p].d) &amp;#123;
        t[lt].d = t[lt].lc = t[lt].rc = t[rt].d = t[rt].lc = t[rt].rc = t[p].d;
        t[lt].u = t[rt].u = 1;
        t[p].d = 0;
    &amp;#125;
    return;
&amp;#125;
void add(int p, int l, int r, int v) &amp;#123;
    if (l &amp;lt;= t[p].l &amp;amp;&amp;amp; t[p].r &amp;lt;= r) &amp;#123;
        t[p].u = 1;
        t[p].lc = t[p].rc = t[p].d = v;
        return;
    &amp;#125;
    pushdown(p);
    if (l &amp;lt;= t[p].mid)
        add(lt, l, r, v);
    if (r &amp;gt; t[p].mid)
        add(rt, l, r, v);
    t[p] = t[lt] + t[rt];
    return;
&amp;#125;
node ask(int p, int l, int r) &amp;#123;
    if (l &amp;lt;= t[p].l &amp;amp;&amp;amp; t[p].r &amp;lt;= r)
        return t[p];
    pushdown(p);
    if (r &amp;lt;= t[p].mid)
        return ask(lt, l, r);
    if (l &amp;gt; t[p].mid)
        return ask(rt, l, r);
    return ask(lt, l, r) + ask(rt, l, r);
&amp;#125;
#undef lt
#undef rt
int main() &amp;#123;
#ifdef ONLINE_JUDGE
#else
    std::freopen(&amp;quot;paint17.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, q;
    read(n), read(q);
    std::vector&amp;lt;int&amp;gt; rt(n + 1);
    for (int i = 1; i &amp;lt;= n; ++i)
        read(a[i]);
    std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; g(n + 1);
    for (int i = 1, x, y; i &amp;lt; n; ++i) &amp;#123;
        read(x), read(y);
        g[x].push_back(y), g[y].push_back(x);
    &amp;#125;
    std::vector&amp;lt;int&amp;gt; siz(n + 1), son(n + 1), fa(n + 1), dep(n + 1);
    std::function&amp;lt;void(int)&amp;gt; DFS = [&amp;amp;](int x) &amp;#123;
        siz[x] = 1;
        for (auto i : g[x])
            if (i != fa[x]) &amp;#123;
                dep[i] = dep[x] + 1;
                fa[i] = x, DFS(i);
                siz[x] += siz[i];
                if (siz[i] &amp;gt; siz[son[x]])
                    son[x] = i;
            &amp;#125;
        return;
    &amp;#125;;
    DFS(1);
    std::vector&amp;lt;std::array&amp;lt;int, 2&amp;gt; &amp;gt; f(n + 1);
    std::vector&amp;lt;int&amp;gt; top(n + 1), bot(n + 1), dfn(n + 1);
    DFS = [&amp;amp;](int x) &amp;#123;
        static int now = 0;
        dfn[x] = ++now, tab[now] = x, ls[x] = 1;
        if (son[x]) &amp;#123;
            top[son[x]] = top[x], DFS(son[x]);
            bot[x] = bot[son[x]];
        &amp;#125;
        else
            bot[x] = x;
        for (auto i : g[x])
            if (i != son[x] &amp;amp;&amp;amp; i != fa[x]) &amp;#123;
                top[i] = i;
                DFS(i);
                ls[x] += siz[i];
            &amp;#125;
        if (x == top[x])
            bld(rt[x], dfn[x], dfn[bot[x]]);
        return;
    &amp;#125;;
    top[1] = 1, DFS(1);
    for (char op; q--; ) &amp;#123;
        read(op);
        if (op == &amp;#39;C&amp;#39;) &amp;#123;
            int x, y, c;
            read(x), read(y), read(c);
            for (; top[x] != top[y]; x = fa[top[x]]) &amp;#123;
                if (dep[top[x]] &amp;lt; dep[top[y]])
                    std::swap(x, y);
                add(rt[top[x]], dfn[top[x]], dfn[x], c);
            &amp;#125;
            if (dep[x] &amp;gt; dep[y])
                std::swap(x, y);
            add(rt[top[x]], dfn[x], dfn[y], c);
        &amp;#125;
        else &amp;#123;
            int x, y;
            read(x), read(y);
            node res1, res2;
            for (; top[x] != top[y]; )
                if (dep[top[x]] &amp;lt; dep[top[y]]) &amp;#123;
                    res2 = ask(rt[top[y]], dfn[top[y]], dfn[y]) + res2;
                    y = fa[top[y]];
                &amp;#125;
                else &amp;#123;
                    res1 = ask(rt[top[x]], dfn[top[x]], dfn[x]) + res1;
                    x = fa[top[x]];
                &amp;#125;
            if (dep[x] &amp;gt; dep[y])
                res1 = ask(rt[top[y]], dfn[y], dfn[x]) + res1;
            else
                res2 = ask(rt[top[x]], dfn[x], dfn[y]) + res2;
            res1.swap();
            print((res1 + res2).u, &amp;#39;\n&amp;#39;);
        &amp;#125;
    &amp;#125;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;æ ‘ä¸Šè·¯å¾„æŸ¥è¯¢&#34;&gt;æ ‘ä¸Šè·¯å¾„æŸ¥è¯¢ï¼Ÿ&lt;/h3&gt;
&lt;p&gt;åšé¢˜çš„æ—¶å€™å¯ä»¥æ„Ÿå—åˆ°ï¼Œè·¯å¾„è¯¢é—®çš„å­˜åœ¨å¾ˆè¯¡å¼‚ï¼Œå› ä¸ºåªéœ€è¦ä¸€æ¡é“¾çš„æ“ä½œï¼Œæ›´åå‘é“¾ä¸Š DDP è€Œéæ ‘ä¸Šçš„ï¼›&lt;strong&gt;è½»å„¿å­çš„ä¿¡æ¯æ˜¯ä¸ç”¨ç»´æŠ¤çš„&lt;/strong&gt;ï¼Œå½¢å¼ä¸Šæ›´åƒæ ‘å‰–ï¼ˆDSï¼‰ï¼›å½“æˆé“¾ä¸Šçš„ DDP å°±å¯ä»¥è§£å†³äº†ã€‚&lt;/p&gt;
&lt;p&gt;å¯ä»¥ç”¨å€å¢ç»´æŠ¤ DDPï¼ˆä¸ç”¨è€ƒè™‘è½»é‡å„¿å­ï¼Œåªç”¨ç»´æŠ¤çˆ¶å­å…³ç³»ï¼Œè¿›ä¸€æ­¥å‘åºåˆ— DDP é è¿‘ï¼‰ï¼Œå°±ä¸ç”¨æ‰“ GBT äº†ï¼Œå¸¸æ•°ä¹Ÿä¼šå°ä¸€äº›ã€‚&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;ä¹ é¢˜&#34;&gt;ä¹ é¢˜&lt;/h2&gt;
&lt;p&gt;GBT å°±ç»Ÿä¸€ç”¨çº¿æ®µæ ‘äº†ã€‚DDP ä¹Ÿå°±å¯ä»¥é¡ºå¸¦ç”¨ GBT ä¼˜åŒ–äº†ã€‚&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;e---çŒ«æˆ–ç‹—-cats-or-dogs&#34;&gt;E - çŒ«æˆ–ç‹— / Cats or Dogs&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P9597&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P9597&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;è®¾ &lt;span class=&#34;math inline&#34;&gt;\(f_{u,0/1}\)&lt;/span&gt; è¡¨ç¤ºä»æ ¹ä¸Šé¢œè‰²ä¸º &lt;span class=&#34;math inline&#34;&gt;\(0/1\)&lt;/span&gt; æ—¶çš„æœ€å°æ–­è¾¹æ•°ï¼Œæ˜¾ç„¶æ— è‰²å¯ä»¥è§†ä½œä»»é€‰ä¸€ä¸ªé¢œè‰²ã€‚é‚£ä¹ˆæœ‰ï¼š&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
f_{u,a}=\sum\limits_v\min\limits_{b\in\{0,1\}}\{f_{v,b}+[a\ne b]\}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;ç›´æ¥æŠŠè½»å„¿å­çš„é¡¹æå‡ºæ¥ï¼Œè®° &lt;span class=&#34;math inline&#34;&gt;\(g_{u,0/1}\)&lt;/span&gt; è¡¨ç¤º &lt;span class=&#34;math inline&#34;&gt;\(f_{u,0/1}\)&lt;/span&gt; å¯¹åº”çš„è½»å„¿å­è´¡çŒ®å³å¯ã€‚&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int maxn = 1e5 + 5;
const int inf = 0x3f3f3f3f;
struct mat &amp;#123;
    int a[2][2];
    int* operator[] (const int q) &amp;#123; 
        return a[q];
    &amp;#125;
    mat operator* (mat &amp;amp;q) const &amp;#123;
        mat res;
        res[0][0] = res[0][1] = res[1][0] = res[1][1] = inf;
        for (int i = 0; i &amp;lt; 2; ++i)
            for (int k = 0; k &amp;lt; 2; ++k)
                for (int j = 0; j &amp;lt; 2; ++j)
                    res[i][k] = std::min(res[i][k], a[i][j] + q[j][k]);
        return res;
    &amp;#125;
    mat&amp;amp; operator*= (mat &amp;amp;q) &amp;#123;
        return *this = *this * q;
    &amp;#125;
&amp;#125; p[maxn];
struct &amp;#123; int lc, rc, l, r, mid; mat u; &amp;#125; t[maxn &amp;lt;&amp;lt; 2]; 
int ls[maxn], tab[maxn], g[maxn][2], rt[maxn], top[maxn], dfn[maxn], fa[maxn];
std::vector&amp;lt;int&amp;gt; a;
#define lt t[p].lc
#define rt t[p].rc
void bld(int &amp;amp;p, int l, int r) &amp;#123;
    static int tot = 0;
    p = ++tot, t[p].l = l, t[p].r = r;
    if (l == r) &amp;#123;
        t[p].u[0][1] = t[p].u[1][0] = 1;
        return;
    &amp;#125;
    int s = 0, u = ls[tab[l]];
    for (int i = l; i &amp;lt;= r; ++i)
        s += ls[tab[i]];
    s &amp;gt;&amp;gt;= 1;
    t[p].mid = r - 1;
    for (int i = l + 1; i &amp;lt; r; ++i) &amp;#123;
        u += ls[tab[i]];
        if (u + ls[tab[i + 1]] &amp;gt; s) &amp;#123;
            t[p].mid = i;
            break;
        &amp;#125;
    &amp;#125;
    bld(lt, l, t[p].mid), bld(rt, t[p].mid + 1, r);
    t[p].u = t[rt].u * t[lt].u;
    return;
&amp;#125;
void add(int p, int x) &amp;#123;
    if (t[p].l == t[p].r) &amp;#123;
        int u = tab[x], g0 = (a[u] == 1 ? inf : g[u][0]), g1 = (a[u] == 0 ? inf : g[u][1]);
        t[p].u[0][0] = g0, t[p].u[0][1] = g1 + 1;
        t[p].u[1][0] = g0 + 1, t[p].u[1][1] = g1;
        return;
    &amp;#125;
    if (x &amp;lt;= t[p].mid)
        add(lt, x);
    else
        add(rt, x);
    t[p].u = t[rt].u * t[lt].u;
    return;
&amp;#125;
#undef lt
#undef rt
void initialize(int n, std::vector&amp;lt;int&amp;gt; A, std::vector&amp;lt;int&amp;gt; B) &amp;#123;
    a.assign(n + 1, -1);
    std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; g1(n + 1);
    for (int i = 0; i &amp;lt; n - 1; ++i)
        g1[A[i]].push_back(B[i]), g1[B[i]].push_back(A[i]);
    std::vector&amp;lt;int&amp;gt; siz(n + 1), son(n + 1);
    std::function&amp;lt;void(int)&amp;gt; DFS = [&amp;amp;](int x) &amp;#123;
        siz[x] = 1;
        for (auto i : g1[x])
            if (i != fa[x]) &amp;#123;
                fa[i] = x, DFS(i);
                siz[x] += siz[i];
                if (siz[i] &amp;gt; siz[son[x]])
                    son[x] = i;
            &amp;#125;
        return;
    &amp;#125;;
    DFS(1);
    std::vector&amp;lt;int&amp;gt; bot(n + 1);
    DFS = [&amp;amp;](int x) &amp;#123;
        static int now = 0;
        dfn[x] = ++now, tab[now] = x, ls[x] = 1;
        if (son[x]) &amp;#123;
            top[son[x]] = top[x], DFS(son[x]);
            bot[x] = bot[son[x]];
            for (auto i : g1[x])
                if (i != son[x] &amp;amp;&amp;amp; i != fa[x]) &amp;#123;
                    top[i] = i, DFS(i);
                    ls[x] += siz[i];
                &amp;#125;
        &amp;#125;
        else
            bot[x] = x;
        if (x == top[x])
            bld(rt[x], dfn[x], dfn[bot[x]]);
        return;
    &amp;#125;;
    top[1] = 1, DFS(1);
    return;
&amp;#125;
int upd(int x) &amp;#123;
    for (; top[x] != 1; ) &amp;#123;
        int faa = fa[top[x]];
        auto &amp;amp;id = t[rt[top[x]]].u;
        int f0 = std::min(id[0][0], id[1][0]), f1 = std::min(id[0][1], id[1][1]);
        g[faa][0] -= std::min(f0, f1 + 1);
        g[faa][1] -= std::min(f0 + 1, f1);
        add(rt[top[x]], dfn[x]);
        f0 = std::min(id[0][0], id[1][0]), f1 = std::min(id[0][1], id[1][1]);
        // printf(&amp;quot;%d: f0 = %d, f1 = %d\n&amp;quot;, top[x], f0, f1);
        g[faa][0] += std::min(f0, f1 + 1);
        g[faa][1] += std::min(f0 + 1, f1);
        x = faa;
    &amp;#125;
    add(rt[1], dfn[x]);
    auto &amp;amp;id = t[rt[1]].u;
    int f0 = std::min(id[0][0], id[1][0]), f1 = std::min(id[0][1], id[1][1]);
    // printf(&amp;quot;%d: f0 = %d, f1 = %d\n&amp;quot;, 1, f0, f1);
    return std::min(f0, f1);
&amp;#125;
int cat(int x) &amp;#123;
    a[x] = 0;
    return upd(x);
&amp;#125;
int dog(int x) &amp;#123;
    a[x] = 1;
    return upd(x);
&amp;#125;
int neighbor(int x) &amp;#123;
    a[x] = -1;
    return upd(x);
&amp;#125;
#ifndef ONLINE_JUDGE
int main() &amp;#123;
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
    int n;
    std::cin &amp;gt;&amp;gt; n;
    std::vector&amp;lt;int&amp;gt; A(n - 1), B(n - 1);
    for (int i = 0; i &amp;lt; n - 1; ++i)
        std::cin &amp;gt;&amp;gt; A[i] &amp;gt;&amp;gt; B[i];
    initialize(n, A, B);
    int q;
    std::cin &amp;gt;&amp;gt; q;
    for (int op, x; q--; ) &amp;#123;
        std::cin &amp;gt;&amp;gt; op &amp;gt;&amp;gt; x;
        std::cout &amp;lt;&amp;lt; (op == 1 ? cat(x) : (op == 2 ? dog(x) : neighbor(x))) &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    &amp;#125;
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
    return 0;
&amp;#125;
#endif&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;f---hash-on-tree&#34;&gt;F - Hash on Tree&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/AT_abc351_g&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/AT_abc351_g&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;è®° &lt;span class=&#34;math inline&#34;&gt;\(g_x\)&lt;/span&gt; ä¸ºè½»å„¿å­çš„å“ˆå¸Œå€¼ä¹‹ç§¯ï¼Œåˆ™ &lt;span class=&#34;math inline&#34;&gt;\(f_u=A_u+f_{son}\cdot g_u\)&lt;/span&gt;ã€‚&lt;/p&gt;
&lt;p&gt;ç„¶åå¼€ä¸€ä¸ªå¸¸æ•°ç»´å³å¯ã€‚å¿«é€Ÿå¹‚çš„ log çœä¸æ‰ï¼Œæ‰€ä»¥æ˜¯åŒ log çš„ã€‚&lt;/p&gt;
&lt;p&gt;åˆå€¼å’Œä¿®æ”¹éƒ½æœ‰å¯èƒ½ä¸º &lt;span class=&#34;math inline&#34;&gt;\(0\)&lt;/span&gt;ï¼Œéœ€è¦ç»´æŠ¤å®é™…å“ˆå¸Œå€¼å’Œå»æ‰ &lt;span class=&#34;math inline&#34;&gt;\(0\)&lt;/span&gt; çš„å“ˆå¸Œå€¼ã€‚&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int maxn = 1e6 + 5;
const int LEN = (1 &amp;lt;&amp;lt; 20);
const int mod = 998244353;
int nec(void) &amp;#123;
    static char buf[LEN], *p = buf, *e = buf;
    if (p == e) &amp;#123;
        e = buf + fread(buf, 1, LEN, stdin);
        if (e == buf) return EOF;
        p = buf;
    &amp;#125;
    return *p++;
&amp;#125;
bool read(int &amp;amp;x) &amp;#123;
    x = 0;
    bool f = 0;
    char ch = nec();
    while (ch &amp;lt; &amp;#39;0&amp;#39; || ch &amp;gt; &amp;#39;9&amp;#39;) &amp;#123;
        if (ch == EOF) return 0;
        if (ch == &amp;#39;-&amp;#39;) f = 1;
        ch = nec();
    &amp;#125;
    while (ch &amp;gt;= &amp;#39;0&amp;#39; &amp;amp;&amp;amp; ch &amp;lt;= &amp;#39;9&amp;#39;) &amp;#123;
        x = x * 10 + ch - &amp;#39;0&amp;#39;;
        ch = nec();
    &amp;#125;
    if (f) x = -x;
    return 1;
&amp;#125;
void print(int x) &amp;#123;
    if (x &amp;lt; 0)
        putchar(&amp;#39;-&amp;#39;), x = -x;
    if (x &amp;gt;= 10) print(x / 10);
    putchar(x % 10 + &amp;#39;0&amp;#39;);
    return;
&amp;#125;
void print(int x, char ch) &amp;#123;
    print(x), putchar(ch);
    return;
&amp;#125;
struct mat &amp;#123;
    int n, m;
    long long a[2][2];
    long long* operator[] (const int q) &amp;#123;
        return a[q];
    &amp;#125;
    mat operator* (mat &amp;amp;q) const &amp;#123;
        mat res;
        res.n = n, res.m = q.m;
        res[0][0] = res[0][1] = res[1][0] = res[1][1] = 0ll;
        for (int i = 0; i &amp;lt; n; ++i)
            for (int k = 0; k &amp;lt; q.m; ++k) &amp;#123;
                for (int j = 0; j &amp;lt; m; ++j)
                    res[i][k] += a[i][j] * q[j][k];
                res[i][k] %= mod;
            &amp;#125;
        return res;
    &amp;#125;
    mat&amp;amp; operator*= (mat &amp;amp;q) &amp;#123;
        return *this = *this * q;
    &amp;#125;
&amp;#125;;
struct &amp;#123; int lc, rc, l, r, mid; mat u; &amp;#125; t[maxn &amp;lt;&amp;lt; 2]; 
long long g[maxn];
int tab[maxn], ls[maxn], a[maxn];
#define lt t[p].lc
#define rt t[p].rc
void bld(int &amp;amp;p, int l, int r) &amp;#123;
    static int tot = 0;
    p = ++tot, t[p].l = l, t[p].r = r;
    if (l == r) &amp;#123;
        int u = tab[l];
        t[p].u.n = t[p].u.m = 2;
        t[p].u[0][0] = g[u];
        t[p].u[0][1] = 0ll;
        t[p].u[1][0] = a[u];
        t[p].u[1][1] = 1ll;
        return;
    &amp;#125;
    int s = 0, u = ls[tab[l]];
    for (int i = l; i &amp;lt;= r; ++i)
        s += ls[tab[i]];
    s &amp;gt;&amp;gt;= 1;
    t[p].mid = r - 1;
    for (int i = l + 1; i &amp;lt; r; ++i) &amp;#123;
        u += ls[tab[i]];
        if (u + ls[tab[i + 1]] &amp;gt; s) &amp;#123;
            t[p].mid = i;
            break;
        &amp;#125;
    &amp;#125;
    bld(lt, l, t[p].mid), bld(rt, t[p].mid + 1, r);
    t[p].u = t[rt].u * t[lt].u;
    return;
&amp;#125;
void add(int p, int x) &amp;#123;
    if (t[p].l == t[p].r) &amp;#123;
        int u = tab[x];
        t[p].u[0][0] = g[u];
        t[p].u[1][0] = a[u];
        return;
    &amp;#125;
    if (x &amp;lt;= t[p].mid)
        add(lt, x);
    else
        add(rt, x);
    t[p].u = t[rt].u * t[lt].u;
    return;
&amp;#125;
#undef lt
#undef rt
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, q;
    read(n), read(q);
    std::vector&amp;lt;int&amp;gt; rt(n + 1);
    std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; g1(n + 1);
    for (int i = 2, x; i &amp;lt;= n; ++i) &amp;#123;
        read(x);
        g1[i].push_back(x), g1[x].push_back(i);
    &amp;#125;
    for (int i = 1; i &amp;lt;= n; ++i)
        read(a[i]);
    std::vector&amp;lt;int&amp;gt; siz(n + 1), son(n + 1), fa(n + 1);
    std::function&amp;lt;void(int)&amp;gt; DFS = [&amp;amp;](int x) &amp;#123;
        siz[x] = 1;
        for (auto i : g1[x])
            if (i != fa[x]) &amp;#123;
                fa[i] = x, DFS(i);
                siz[x] += siz[i];
                if (siz[i] &amp;gt; siz[son[x]])
                    son[x] = i;
            &amp;#125;
        return;
    &amp;#125;;
    DFS(1);
    std::vector&amp;lt;long long&amp;gt; f(n + 1);
    std::vector&amp;lt;int&amp;gt; top(n + 1), bot(n + 1), dfn(n + 1), la(n + 1), cnt(n + 1);
    DFS = [&amp;amp;](int x) &amp;#123;
        static int now = 0;
        dfn[x] = ++now, tab[now] = x, ls[x] = 1;
        if (son[x]) &amp;#123;
            top[son[x]] = top[x], DFS(son[x]);
            bot[x] = bot[son[x]];
            g[x] = 1ll;
            for (auto i : g1[x])
                if (i != son[x] &amp;amp;&amp;amp; i != fa[x]) &amp;#123;
                    top[i] = i, DFS(i);
                    ls[x] += siz[i];
                    if (f[i] == 0ll)
                        ++cnt[x];
                    else
                        (la[x] *= f[i]) %= mod;
                    (g[x] *= f[i]) %= mod;
                &amp;#125;
            f[x] = (a[x] + g[x] * f[son[x]]) % mod;
        &amp;#125;
        else
            f[x] = a[x], bot[x] = x;
        // printf(&amp;quot;f[%d] = %lld\n&amp;quot;, x, f[x]);
        if (x == top[x])
            bld(rt[x], dfn[x], dfn[bot[x]]);
        return;
    &amp;#125;;
    top[1] = 1, DFS(1);
    mat init;
    init.n = 1, init.m = 2;
    init[0][0] = 0ll, init[0][1] = 1ll;
    auto qkp = [&amp;amp;](long long x, int y) &amp;#123;
        auto res(1ll);
        for (; y; (x *= x) %= mod, y &amp;gt;&amp;gt;= 1)
            if (y &amp;amp; 1)
                (res *= x) %= mod;
        return res;
    &amp;#125;;
    auto inv = [&amp;amp;](int x) &amp;#123;
        return qkp(x, mod - 2);
    &amp;#125;;
    for (int x, v; q--; ) &amp;#123;
        read(x), read(v);
        a[x] = v;
        for (; top[x] != 1; ) &amp;#123;
            int faa = fa[top[x]];
            auto &amp;amp;id = t[rt[top[x]]].u;
            int f = (init * id)[0][0];
            if (f == 0) &amp;#123;
                if (--cnt[faa] == 0)
                    g[faa] = la[faa];
            &amp;#125;
            else &amp;#123;
                f = inv(f);
                (g[faa] *= f) %= mod;
                (la[faa] *= f) %= mod;
            &amp;#125;
            add(rt[top[x]], dfn[x]);
            f = (init * id)[0][0];
            if (f == 0) &amp;#123;
                if (cnt[faa]++ == 0)
                    la[faa] = g[faa];
                g[faa] = 0ll;
            &amp;#125;
            else &amp;#123;
                (g[faa] *= f) %= mod;
                (la[faa] *= f) %= mod;
            &amp;#125;
            x = faa;
        &amp;#125;
        add(rt[1], dfn[x]);
        auto &amp;amp;id = t[rt[1]].u;
        int f = (init * id)[0][0];
        std::cout &amp;lt;&amp;lt; f &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    &amp;#125;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;g---è€ƒè¯•-2&#34;&gt;G - è€ƒè¯• 2&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P10626&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P10626&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;è¿ç®—å‡æ˜¯çº¿æ€§çš„ï¼Œå®¹æ˜“æƒ³åˆ°ã€æŒ‰ä½ã€ç»´æŠ¤ï¼Œå³åªç»´æŠ¤æŸä¸ªç‰¹å®šç‚¹å€¼ã€‚å¦‚æœå°†è¯¢é—®ç¦»çº¿ä¸‹æ¥æ’åºï¼Œæ¯ä¸ªå‡½æ•°çš„ç‚¹å€¼åªä¼šå˜åŒ– &lt;span class=&#34;math inline&#34;&gt;\(O(1)\)&lt;/span&gt; æ¬¡ã€‚&lt;/p&gt;
&lt;p&gt;å»ºå‡ºç¬¦å·äºŒå‰æ ‘ï¼Œè¿›è¡Œ DDP å³å¯ã€‚å…·ä½“åœ°ï¼Œä»¤ &lt;span class=&#34;math inline&#34;&gt;\(f_u\)&lt;/span&gt; è¡¨ç¤ºåœ¨è¿ç®— &lt;span class=&#34;math inline&#34;&gt;\(u\)&lt;/span&gt; å¤„çš„ç­”æ¡ˆï¼Œè®¡ç®— &lt;span class=&#34;math inline&#34;&gt;\(g_u\)&lt;/span&gt; ä¸ºè½»å„¿å­çš„ç­”æ¡ˆï¼ŒæŒ‰ç…§ &lt;span class=&#34;math inline&#34;&gt;\(u\)&lt;/span&gt; å¤„çš„ç¬¦å·å†™çŸ©é˜µå³å¯ã€‚å¶å­ä¸æ˜¯ä¸€æ¬¡è¿ç®—ï¼Œåº”è¯¥ç›´æ¥å¡«å…¥ç‚¹å€¼ï¼ˆæ³¨æ„çº¿æ®µæ ‘ä¸Šçš„å¶å­ä¸ä¸€å®šæ˜¯åŸæ ‘ä¸Šçš„å¶å­ï¼‰ã€‚&lt;/p&gt;
&lt;p&gt;å»ºæ ‘å’ŒçŸ©é˜µæ›´æ–°æœ‰ç‚¹å²ï¼Œé€‚å½“å°è£…ä¸€ä¸‹æ„Ÿè§‰ä¼šå¥½ä¸€ç‚¹&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int maxn = 1e6 + 5;
const char mp[] = &amp;quot;x!&amp;amp;|^&amp;quot;;
const int LEN = (1 &amp;lt;&amp;lt; 20);
#define nec getchar
inline bool read(int &amp;amp;x) &amp;#123;
    x = 0;
    bool f = 0;
    char ch = nec();
    while (ch &amp;lt; &amp;#39;0&amp;#39; || ch &amp;gt; &amp;#39;9&amp;#39;) &amp;#123;
        if (ch == EOF) return 0;
        if (ch == &amp;#39;-&amp;#39;) f = 1;
        ch = nec();
    &amp;#125;
    while (ch &amp;gt;= &amp;#39;0&amp;#39; &amp;amp;&amp;amp; ch &amp;lt;= &amp;#39;9&amp;#39;) &amp;#123;
        x = x * 10 + ch - &amp;#39;0&amp;#39;;
        ch = nec();
    &amp;#125;
    if (f) x = -x;
    return 1;
&amp;#125;
void print(int x) &amp;#123;
    if (x &amp;lt; 0)
        putchar(&amp;#39;-&amp;#39;), x = -x;
    if (x &amp;gt;= 10) print(x / 10);
    putchar(x % 10 + &amp;#39;0&amp;#39;);
    return;
&amp;#125;
void print(int x, char ch) &amp;#123;
    print(x), putchar(ch);
    return;
&amp;#125;
struct mat &amp;#123;
    int n, m;
    int a[2][2];
    int* operator[] (const int q) &amp;#123;
        return a[q];
    &amp;#125;
    inline mat operator* (mat &amp;amp;q) const &amp;#123;
        mat res;
        res.n = n, res.m = q.m;
        res[0][0] = res[0][1] = res[1][0] = res[1][1] = 0ll;
        for (int i = 0; i &amp;lt; n; ++i)
            for (int k = 0; k &amp;lt; q.m; ++k)
                for (int j = 0; j &amp;lt; m; ++j)
                    res[i][k] += a[i][j] * q[j][k];
        return res;
    &amp;#125;
    mat&amp;amp; operator*= (mat &amp;amp;q) &amp;#123;
        return *this = *this * q;
    &amp;#125;
&amp;#125;;
struct &amp;#123; int lc, rc, l, r, mid; mat u; &amp;#125; t[maxn &amp;lt;&amp;lt; 2]; 
int g1[maxn][2];
int g[maxn], ty[maxn];
int tab[maxn], ls[maxn], lim[maxn];
#define lt t[p].lc
#define rt t[p].rc
void fillmat(mat &amp;amp;a, int op, int g) &amp;#123;
    if (op == 0) &amp;#123;
        a.n = 1, a.m = 2;
        a[0][!g] = 0, a[0][g] = 1;
        return;
    &amp;#125;
    a.n = 2, a.m = 2;
    switch (op) &amp;#123;
    case 1: // !
        a[0][0] = 0, a[0][1] = 1;
        a[1][0] = 1, a[1][1] = 0;
        break;
    case 2: // &amp;amp;
        a[0][0] = 1, a[0][1] = 0;
        a[1][0] = !g, a[1][1] = g;
        break;
    case 3: // |
        a[0][0] = !g, a[0][1] = g;
        a[1][0] = 0, a[1][1] = 1;
        break;
    case 4: // ^
        a[0][0] = !g, a[0][1] = g;
        a[1][0] = g, a[1][1] = !g;
        break;
    default:
        assert(0);
    &amp;#125;
    return;
&amp;#125;
void bld(int &amp;amp;p, int l, int r) &amp;#123;
    static int tot = 0;
    p = ++tot, t[p].l = l, t[p].r = r;
    if (l == r) &amp;#123;
        fillmat(t[p].u, ty[tab[l]], g[tab[l]]);
        return;
    &amp;#125;
    int s = 0, u = ls[tab[l]];
    for (int i = l; i &amp;lt;= r; ++i)
        s += ls[tab[i]];
    s &amp;gt;&amp;gt;= 1;
    t[p].mid = r - 1;
    for (int i = l + 1; i &amp;lt; r; ++i) &amp;#123;
        u += ls[tab[i]];
        if (u + ls[tab[i + 1]] &amp;gt; s) &amp;#123;
            t[p].mid = i;
            break;
        &amp;#125;
    &amp;#125;
    bld(lt, l, t[p].mid), bld(rt, t[p].mid + 1, r);
    t[p].u = t[rt].u * t[lt].u;
    return;
&amp;#125;
void add(int p, int x) &amp;#123;
    if (t[p].l == t[p].r) &amp;#123;
        fillmat(t[p].u, ty[tab[t[p].l]], g[tab[t[p].l]]);
        return;
    &amp;#125;
    if (x &amp;lt;= t[p].mid)
        add(lt, x);
    else
        add(rt, x);
    t[p].u = t[rt].u * t[lt].u;
    return;
&amp;#125;
#undef lt
#undef rt
int main() &amp;#123;
#ifndef ONLINE_JUDGE
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n = 0, q, p;
    read(q), read(q);
    &amp;#123;
        std::string s;
        std::cin &amp;gt;&amp;gt; s;
        std::stringstream in(s);
        std::stack&amp;lt;char&amp;gt; op;
        std::stack&amp;lt;int&amp;gt; id;
        auto trans = [&amp;amp;](char t) &amp;#123;
            switch (t) &amp;#123;
            case &amp;#39;!&amp;#39;:
                return 1;
            case &amp;#39;&amp;amp;&amp;#39;:
                return 2;
            case &amp;#39;|&amp;#39;:
                return 3;
            case &amp;#39;^&amp;#39;:
                return 4;
            &amp;#125;
            assert(0);
            return -1;
        &amp;#125;;
        auto calcNot = [&amp;amp;](void) &amp;#123;
            for (; !op.empty() &amp;amp;&amp;amp; op.top() == &amp;#39;!&amp;#39;; ) &amp;#123;
                ty[++n] = trans(op.top());
                g1[n][0] = id.top(), id.pop(), id.push(n);
                op.pop();
            &amp;#125;
            return;
        &amp;#125;;
        auto opt = [&amp;amp;](void) &amp;#123;
            ty[++n] = trans(op.top());
            g1[n][0] = id.top(), id.pop();
            g1[n][1] = id.top(), id.pop();
            id.push(n), op.pop();
            return;
        &amp;#125;;
        for (char t; in &amp;gt;&amp;gt; t; )
            if (t == &amp;#39;[&amp;#39;) &amp;#123;
                int x;
                in &amp;gt;&amp;gt; x, in &amp;gt;&amp;gt; t;
                lim[++n] = x - 1;
                id.push(n), calcNot();
            &amp;#125;
            else if (t == &amp;#39;(&amp;#39;)
                op.push(t);
            else if (t == &amp;#39;)&amp;#39;) &amp;#123;
                for (; op.top() != &amp;#39;(&amp;#39;; opt());
                op.pop(), calcNot();
            &amp;#125;
            else if (t == &amp;#39;&amp;amp;&amp;#39;)
                op.push(t);
            else if (t == &amp;#39;^&amp;#39;) &amp;#123;
                for (; !op.empty() &amp;amp;&amp;amp; op.top() == &amp;#39;&amp;amp;&amp;#39;; opt());
                op.push(t);
            &amp;#125;
            else if (t == &amp;#39;|&amp;#39;) &amp;#123;
                for (; !op.empty() &amp;amp;&amp;amp; (op.top() == &amp;#39;&amp;amp;&amp;#39; || op.top() == &amp;#39;^&amp;#39;); opt());
                op.push(t);
            &amp;#125;
            else &amp;#123;
                assert(t == &amp;#39;!&amp;#39;);
                op.push(t);
            &amp;#125;
        for (; !op.empty(); opt());
        p = id.top();
    &amp;#125;
    std::vector&amp;lt;int&amp;gt; rt(n + 1);
    std::vector&amp;lt;int&amp;gt; siz(n + 1), son(n + 1), fa(n + 1);
    std::function&amp;lt;void(int)&amp;gt; DFS = [&amp;amp;](int x) &amp;#123;
        siz[x] = 1;
        for (auto i : g1[x])
            if (i != 0) &amp;#123;
                fa[i] = x, DFS(i);
                siz[x] += siz[i];
                if (siz[i] &amp;gt; siz[son[x]])
                    son[x] = i;
            &amp;#125;
        return;
    &amp;#125;;
    DFS(p);
    std::vector&amp;lt;long long&amp;gt; f(n + 1);
    std::vector&amp;lt;int&amp;gt; top(n + 1), bot(n + 1), dfn(n + 1);
    DFS = [&amp;amp;](int x) &amp;#123;
        static int now = 0;
        dfn[x] = ++now, tab[now] = x, ls[x] = 1;
        if (son[x]) &amp;#123;
            top[son[x]] = top[x], DFS(son[x]);
            bot[x] = bot[son[x]];
            for (auto i : g1[x])
                if (i != son[x] &amp;amp;&amp;amp; i != 0) &amp;#123;
                    top[i] = i, DFS(i);
                    ls[x] += siz[i], g[x] = f[i];
                &amp;#125;
            switch (ty[x]) &amp;#123;
            case 1:
                f[x] = !f[son[x]];
                break;
            case 2:
                f[x] = g[x] &amp;amp; f[son[x]];
                break;
            case 3:
                f[x] = g[x] | f[son[x]];
                break;
            case 4:
                f[x] = g[x] ^ f[son[x]];
                break;
            default:
                assert(0);
                break;
            &amp;#125;
        &amp;#125;
        else
            assert(!ty[x]), f[x] = g[x] = 0, bot[x] = x;
        if (x == top[x])
            bld(rt[x], dfn[x], dfn[bot[x]]);
        return;
    &amp;#125;;
    top[p] = p, DFS(p);
    std::vector&amp;lt;int&amp;gt; a(q + 1), res(q + 1);
    for (int i = 1; i &amp;lt;= q; ++i)
        read(a[i]);
    std::vector&amp;lt;int&amp;gt; qid(q), nid;
    for (int i = 1; i &amp;lt;= n; ++i)
        if (ty[i] == 0)
            nid.push_back(i);
    std::iota(qid.begin(), qid.end(), 1);
    std::sort(qid.begin(), qid.end(), [&amp;amp;](int x, int y) &amp;#123; return a[x] &amp;lt; a[y]; &amp;#125;);
    std::sort(nid.begin(), nid.end(), [&amp;amp;](int x, int y) &amp;#123; return lim[x] &amp;gt; lim[y]; &amp;#125;);
    for (auto i : qid) &amp;#123;
        for (; !nid.empty() &amp;amp;&amp;amp; lim[nid.back()] &amp;lt; a[i]; ) &amp;#123;
            int x = nid.back();
            nid.pop_back();
            g[x] = 1;
            for (; top[x] != p; ) &amp;#123;
                add(rt[top[x]], dfn[x]);
                g[fa[top[x]]] = t[rt[top[x]]].u[0][1];
                x = fa[top[x]];
            &amp;#125;
            add(rt[p], dfn[x]);
        &amp;#125;
        res[i] = t[rt[p]].u[0][1];
    &amp;#125;
    for (int i = 1; i &amp;lt;= q; ++i)
        if (res[i])
            std::cout &amp;lt;&amp;lt; &amp;quot;True\n&amp;quot;;
        else
            std::cout &amp;lt;&amp;lt; &amp;quot;False\n&amp;quot;;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
</content>
        <category term="çº¿æ®µæ ‘" />
        <category term="DDP" />
        <updated>2025-08-12T00:16:52.000Z</updated>
    </entry>
</feed>
