{
    "version": "https://jsonfeed.org/version/1",
    "title": "null â€¢ All posts by \"ddp\" tag",
    "description": "",
    "home_page_url": "https://xsc062.netlify.app",
    "items": [
        {
            "id": "https://xsc062.netlify.app/20250814/",
            "url": "https://xsc062.netlify.app/20250814/",
            "title": "æ‚é¢˜é€‰è°ˆï¼šDDP ä¸ GBT",
            "date_published": "2025-08-14T09:08:21.000Z",
            "content_html": "<p>çº¿æ®µæ ‘æ˜¯å¯¹çš„ï¼ˆå­˜ç–‘ï¼‰</p>\n<span id=\"more\"></span>\n<hr />\n<h2 id=\"a---æ•°æ®ä¼ è¾“\">A - æ•°æ®ä¼ è¾“</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P8820\" class=\"uri\">https://www.luogu.com.cn/problem/P8820</a></p>\n<p>æˆ‘åœ¨ä¸Šä¸€ç¯‡æ–‡ç« ä¸­æåˆ°äº† <a href=\"/20250812/#æ ‘ä¸Šè·¯å¾„æŸ¥è¯¢\">DDP &amp; è·¯å¾„æŸ¥è¯¢é—®é¢˜</a>ï¼Œåœ¨è¿™ä¸ªé¢˜ä¸­å°±æœ‰ä½“ç°ã€‚</p>\n<p>è®¾ <span class=\"math inline\">\\(f_{u,0/1/2}\\)</span> è¡¨ç¤ºæ•°æ®ä¿å­˜åœ¨ <span class=\"math inline\">\\(u\\)</span> å¾€ä¸‹æ•° <span class=\"math inline\">\\(0/1/2\\)</span> ä¸ªç‚¹å¤„çš„æœ€å°ä»£ä»·ï¼Œæ‰‹ç©å®¹æ˜“å‘ç° <span class=\"math inline\">\\(k=3\\)</span> æ—¶<strong>æœ€ä¼˜è·¯å¾„å¯èƒ½ä¼šå¾€æŸä¸ª <span class=\"math inline\">\\(x\\)</span> æˆ– <span class=\"math inline\">\\(fa\\)</span> å¤„çš„æœ€å°ä»£ä»·å„¿å­å¤„ç»•ä¸€åœˆæ¥é¿å…è¿™ä¸ª <span class=\"math inline\">\\(x\\)</span> æˆ– <span class=\"math inline\">\\(fa\\)</span> çš„ä»£ä»·</strong>ã€‚ä½†è¯¥å€¼æ˜¯å®šå€¼ï¼Œé—®é¢˜è¿˜æ˜¯çº¯è·¯å¾„é—®é¢˜ï¼Œå°±å¯ä»¥ DDP äº†ã€‚</p>\n<figure>\n<img src=\"image.png\" alt=\"å…±ä¸¤ç§å¯èƒ½æ€§ï¼ˆä»»æ„ä¸€ä¸ªç®­å¤´é•¿åº¦ä¸ä¸º 3 æ—¶ç»•ä¸€åœˆä¸€å®šä¸æ¯”ç›´æ¥èµ°æ›´ä¼˜ï¼‰\" /><figcaption>å…±ä¸¤ç§å¯èƒ½æ€§ï¼ˆä»»æ„ä¸€ä¸ªç®­å¤´é•¿åº¦ä¸ä¸º <span class=\"math inline\">\\(3\\)</span> æ—¶ç»•ä¸€åœˆä¸€å®šä¸æ¯”ç›´æ¥èµ°æ›´ä¼˜ï¼‰</figcaption>\n</figure>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nstruct mat &#123;\n    long long a[3][3];\n    long long* operator[] (const int q) &#123;\n        return a[q];\n    &#125;\n    mat() &#123;\n        memset(a, 0x3f, sizeof (a));\n        return;\n    &#125;\n    mat(int flag) &#123;\n        memset(a, 0x3f, sizeof (a));\n        a[0][0] = a[1][1] = a[2][2] = 0ll;\n        return;\n    &#125;\n    mat operator* (mat &amp;q) const &#123;\n        mat res;\n        for (int i = 0; i &lt; 3; ++i)\n            for (int k = 0; k &lt; 3; ++k)\n                for (int j = 0; j &lt; 3; ++j)\n                    res[i][k] = std::min(res[i][k], a[i][j] + q[j][k]);\n        return res;\n    &#125;\n    mat&amp; operator*= (mat &amp;q) &#123;\n        return *this = *this * q;\n    &#125;\n&#125;;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, q, k;\n    std::cin &gt;&gt; n &gt;&gt; q &gt;&gt; k;\n    std::vector&lt;int&gt; a(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i];\n    std::vector&lt;int&gt; mx(n + 1, 0x3f3f3f3f);\n    std::vector&lt;std::vector&lt;int&gt; &gt; g1(n + 1);\n    for (int i = 1, x, y; i &lt; n; ++i) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y;\n        mx[x] = std::min(mx[x], a[y]);\n        mx[y] = std::min(mx[y], a[x]);\n        g1[x].push_back(y), g1[y].push_back(x);\n    &#125;\n    std::vector&lt;int&gt; dep(n + 1);\n    std::vector&lt;std::array&lt;int, 18&gt; &gt; f(n + 1);\n    std::vector&lt;std::array&lt;mat, 18&gt; &gt; u(n + 1), d(n + 1);\n    u[0][0] = d[0][0] = mat(1);\n    std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;\n        for (auto i : g1[x])\n            if (i != f[x][0]) &#123;\n                f[i][0] = x;\n                &#123;\n                    mat s;\n                    s[0][0] = a[x];\n                    if (k &gt;= 2) &#123;\n                        s[0][1] = 0;\n                        s[1][0] = a[x];\n                    &#125;\n                    if (k &gt;= 3) &#123;\n                        s[1][2] = 0;\n                        s[2][0] = a[x];\n                        s[1][1] = mx[x];\n                        s[2][2] = mx[i];\n                    &#125;\n                    u[i][0] = s; \n                    s[0][0] = a[i];\n                    if (k &gt;= 2)\n                        s[1][0] = a[i];\n                    if (k &gt;= 3) &#123;\n                        s[2][0] = a[i];\n                        s[1][1] = mx[i];\n                        s[2][2] = mx[x];\n                    &#125;\n                    d[i][0] = s; \n                &#125;\n                for (int j = 1; j &lt; 18; ++j) &#123;\n                    f[i][j] = f[f[i][j - 1]][j - 1];\n                    u[i][j] = u[i][j - 1] * u[f[i][j - 1]][j - 1];\n                    d[i][j] = d[f[i][j - 1]][j - 1] * d[i][j - 1];\n                &#125;\n                dep[i] = dep[x] + 1;\n                DFS(i);\n            &#125;\n        return;\n    &#125;;\n    dep[1] = 1, DFS(1);\n    for (int x, y; q--; ) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y;\n        long long res = a[x];\n        mat r1(1), r2(1);\n        if (dep[x] &gt; dep[y]) &#123;\n            for (int i = 17; ~i; --i)\n                if (dep[f[x][i]] &gt;= dep[y]) &#123;\n                    r1 = r1 * u[x][i];\n                    x = f[x][i];\n                &#125;\n        &#125;\n        else if (dep[y] &gt; dep[x]) &#123;\n            for (int i = 17; ~i; --i)\n                if (dep[f[y][i]] &gt;= dep[x]) &#123;\n                    r2 = d[y][i] * r2;\n                    y = f[y][i];\n                &#125;\n        &#125;\n        if (x != y) &#123;\n            for (int i = 17; ~i; --i)\n                if (f[x][i] != f[y][i]) &#123;\n                    r1 = r1 * u[x][i];\n                    r2 = d[y][i] * r2;\n                    x = f[x][i], y = f[y][i];\n                &#125;\n            r1 = r1 * u[x][0], r2 = d[y][0] * r2;\n        &#125;\n        std::cout &lt;&lt; res + (r1 * r2)[0][0] &lt;&lt; &#39;\\n&#39;;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"b---the-silk-road-with-robots\">B - The Silk Road â€¦ with Robots!</h2>\n<p><a href=\"https://qoj.ac/problem/10410\" class=\"uri\">https://qoj.ac/problem/10410</a></p>\n<blockquote>\n<p>é¢˜æ„ï¼šåˆå§‹æœ‰ä¸€ä¸ªé•¿ä¸º <span class=\"math inline\">\\(10^8\\)</span> çš„ç©ºæ•°è½´ï¼Œç»™å®š <span class=\"math inline\">\\(n\\)</span> æ¬¡æ“ä½œï¼Œæ¯æ¬¡æ“ä½œåœ¨æ•°è½´ä¸Šçš„ä¸€ä¸ªç©ºä½æ”¾ä¸€ä¸ª A ç±»ç‚¹æˆ– B ç±»ç‚¹ã€‚æ¯ä¸ª A ç±»ç‚¹æœ‰å…¶<strong>ä»·å€¼</strong>ã€‚</p>\n<p>ä»»æ„åœ¨æ•°è½´ä¸Šç§»åŠ¨è¿™äº› B ç±»ç‚¹ï¼Œ<strong>æ€»ä»·å€¼</strong>ä¸ºæ‰€æœ‰è¢«ç»è¿‡çš„ A ç±»ç‚¹çš„<strong>ä»·å€¼</strong> - B ç±»ç‚¹ç§»åŠ¨æ€»è·¯ç¨‹ã€‚æ¯æ¬¡æ“ä½œåè¾“å‡ºæœ€å¤§<strong>æ€»ä»·å€¼</strong>ï¼Œé‡å¤ç»è¿‡çš„ A ç±»ç‚¹åªè®¡ä¸€æ¬¡ã€‚</p>\n<p><span class=\"math inline\">\\(n\\le 2\\times 10^5\\)</span>ã€‚</p>\n</blockquote>\n<p>è¿™ä¸ªé¢˜ç¡®å®å¯ä»¥å¸¦æ¥å¾ˆå¤šå¯å‘ï¼Œæˆ‘ä¸€å¼€å§‹ç›´æ¥è®¾ <span class=\"math inline\">\\(f_j\\)</span> ä¸ºçŠ¶æ€ï¼Œè¿™æ ·å¯¹äºæš´åŠ›æ˜¯å¯åšçš„ï¼Œä½†æ˜¯ä¼šå‡ºç°ä¸€äº›éœ€è¦è¢«åŒºé—´ä¿®æ”¹çš„ç³»æ•°ï¼Œæ¯”å¦‚<strong>å‰ç¼€å’Œ</strong>ã€‚æœ€å¥½è®¾è®¡çŠ¶æ€ï¼Œè®©è½¬ç§»çš„æ—¶å€™åªéœ€è¦ç”¨åˆ°å¸¸æ•°ã€å·®åˆ†å€¼ç­‰ä¿®æ”¹æ¬¡æ•°å¾ˆå°‘çš„ç³»æ•°ã€‚</p>\n<p>è®¾ <span class=\"math inline\">\\(f_{i,0/1/2/3}\\)</span> åˆ†åˆ«è¡¨ç¤ºï¼š</p>\n<p><img src=\"image-1.png\" /></p>\n<p>é‚£ä¹ˆå¯ä»¥å†™å‡ºè½¬ç§»å¼ï¼š</p>\n<p><span class=\"math display\">\\[\nf_{i,0}=\\max(mx+a_i+x_i,f_{i-1,0}+a_i)\\\\\nf_{i,1}=\\max(mx+a_i+2x_i,f_{i-1,1}+a_i)\\\\\nf_{i,2}=f_{i-1,2}-(x_i-x_{i-1}) + a_i\\\\\nf_{i,3}=f_{i-1,3}-2(x_i-x_{i-1})+a_i\n\\]</span></p>\n<p>å…¶ä¸­ <span class=\"math inline\">\\(mx\\)</span> ä¸º <span class=\"math inline\">\\(f_{i,2/3}\\)</span> çš„å‰ç¼€æœ€å¤§å€¼ã€‚åœ¨ B ç±»ç‚¹å¤„å¯ä»¥è®© <span class=\"math inline\">\\(f_{2/3}\\)</span> ç»§æ‰¿å¯¹åº”çš„ <span class=\"math inline\">\\(f_{0/1}\\)</span>ï¼Œæ–°å¼€ä¸€ç»´è®°å½• <span class=\"math inline\">\\(mx\\)</span> å°±å¯ä»¥ç»´æŠ¤çŸ©ä¹˜äº†ã€‚</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int lim = 1e8;\nconst int maxn = 5e6 + 5;\nconst long long inf = 1e12;\nstruct mat &#123;\n    long long a[5][5];\n    mat() &#123;&#125;\n    long long* operator[] (const int q) &#123;\n        return a[q];\n    &#125;\n    mat operator* (mat &amp;q) const &#123;\n        mat res;\n        for (int i = 0; i &lt; 5; ++i)\n            for (int k = 0; k &lt; 5; ++k) &#123;\n                auto u(-inf);\n                for (int j = 0; j &lt; 5; ++j)\n                    u = std::max(u, a[i][j] + q[j][k]);\n                res[i][k] = u;\n            &#125;\n        return res;\n    &#125;\n    mat&amp; operator*= (mat &amp;q) &#123;\n        return *this = *this * q;\n    &#125;\n&#125;;\nstruct &#123; int l, r; mat u; &#125; t[maxn];\n#define lt t[p].l\n#define rt t[p].r\nvoid add(int &amp;p, int l, int r, int x, mat &amp;v) &#123;\n    static int tot = 0;\n    if (!p)\n        p = ++tot;\n    if (l == r) &#123;\n        t[p].u = v;\n        return;\n    &#125;\n    int mid = (l + r) &gt;&gt; 1;\n    if (x &lt;= mid)\n        add(lt, l, mid, x, v);\n    else\n        add(rt, mid + 1, r, x, v);\n    t[p].u = t[lt].u * t[rt].u;\n    return;\n&#125;\n#undef lt\n#undef rt\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    &#123;\n        mat &amp;u = t[0].u;\n        for (int i = 0; i &lt; 5; ++i)\n            for (int j = 0; j &lt; 5; ++j)\n                u[i][j] = -inf;\n        u[0][0] = u[1][1] = u[2][2] = u[3][3] = u[4][4] = 0ll;\n    &#125;\n    int m, rt = 0;\n    std::cin &gt;&gt; m;\n    std::vector&lt;mat&gt; a(m + 1);\n    std::vector&lt;int&gt; ty(m + 1);\n    std::set&lt;std::pair&lt;long long, int&gt; &gt; s;\n    s.emplace(-inf, 0);\n    for (int op, x, i = 1; i &lt;= m; ++i) &#123;\n        std::cin &gt;&gt; op &gt;&gt; x;\n        auto &amp;u = a[i];\n        for (int i = 0; i &lt; 5; ++i)\n            for (int j = 0; j &lt; 5; ++j)\n                u[i][j] = -inf;\n        auto p = --s.lower_bound(std::make_pair(x, 0)), q = s.upper_bound(std::make_pair(x, 0));\n        int v = 0;\n        if (op == 2)\n            std::cin &gt;&gt; v;\n        u[0][0] = v, u[1][1] = v, u[4][0] = v + x, u[4][1] = v + 2 * x;\n        if (op == 1) &#123;\n            ty[i] = 0;\n            u[4][2] = u[4][1] - 2 * x;\n            u[1][2] = u[1][1] - 2 * x;\n            u[4][3] = u[4][0] - x;\n            u[0][3] = u[0][0] - x;\n        &#125;\n        else &#123;\n            ty[i] = 1;\n            u[2][2] = v - (x - p-&gt;first);\n            u[3][3] = v - 2 * (x - p-&gt;first);\n        &#125;\n        u[4][4] = std::max(&#123; 0ll, u[4][2], u[4][3] &#125;);\n        u[1][4] = u[1][2], u[0][4] = u[0][3], u[2][4] = u[2][2], u[3][4] = u[3][3];\n        add(rt, 0, lim, x, u);\n        if (q != s.end() &amp;&amp; ty[q-&gt;second] == 1) &#123;\n            auto &amp;u = a[q-&gt;second];\n            u[2][2] -= p-&gt;first, u[2][2] += x;\n            u[3][3] -= 2 * p-&gt;first, u[3][3] += 2 * x;\n            u[2][4] = u[2][2], u[3][4] = u[3][3];\n            add(rt, 0, lim, q-&gt;first, a[q-&gt;second]);\n        &#125;\n        s.emplace(x, i);\n        std::cout &lt;&lt; t[1].u[4][4] &lt;&lt; &#39;\\n&#39;;\n        // for (int i = 0; i &lt; 5; ++i, puts(&quot;&quot;))\n        //     for (int j = 0; j &lt; 5; ++j)\n        //         if (t[1].u[i][j] &lt; -200)\n        //             printf(&quot;  x &quot;);\n        //         else\n        //             printf(&quot;%3lld &quot;, t[1].u[i][j]);\n        // puts(&quot;=============&quot;);\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"c---å¯†ç ç®±\">C - å¯†ç ç®±</h2>\n<p><a href=\"/20250818/#c---%E5%AF%86%E7%A0%81%E7%AE%B1\">link</a>;</p>\n",
            "tags": [
                "çº¿æ®µæ ‘",
                "DDP"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20250812/",
            "url": "https://xsc062.netlify.app/20250812/",
            "title": "å­¦ä¹ ç¬”è®°ï¼šDDP ä¸å…¨å±€å¹³è¡¡äºŒå‰æ ‘",
            "date_published": "2025-08-12T00:16:52.000Z",
            "content_html": "<p>å…¶å®åŠ¨æ€ DP ä¸æ˜¯åŠ¨æ€æ ‘ DP çš„åŒä¹‰è¯</p>\n<span id=\"more\"></span>\n<hr />\n<h2 id=\"åŠ¨æ€-dp\">åŠ¨æ€ DP</h2>\n<p>å¯¹äºè½¬ç§»åªä¾èµ–å‰å‡ é¡¹çš„ DPï¼Œå¯ä»¥æ”¾è¿›çŸ©é˜µã€‚</p>\n<p>é»˜è®¤è½¬ç§»èŒƒå›´æ˜¯ <span class=\"math inline\">\\([1,n]\\)</span>ï¼›å¦‚æœæˆ‘ä»¬éœ€è¦æ”¹å˜æ±‚è§£èŒƒå›´ï¼Œå‘ç°å¦‚æœèƒ½è·å–è½¬ç§»çŸ©é˜µçš„ä¹˜ç§¯å°±å¾ˆå¿«äº†ã€‚è€ƒè™‘å­˜ä¸‹æ¥ã€‚</p>\n<p>å¦‚æœéœ€è¦å•ç‚¹ä¿®æ”¹ï¼Œç­‰ä»·äºä¿®æ”¹å…¶æ‰€åœ¨çŸ©é˜µï¼Œåˆ™æƒ³è¦å°½å¯èƒ½å°‘åœ°ä¿®æ”¹å­˜å‚¨çš„ç­”æ¡ˆï¼Œè€ƒè™‘ä½¿ç”¨çº¿æ®µæ ‘ä¼˜åŒ–è¯¥è¿‡ç¨‹ã€‚</p>\n<h3 id=\"ä¾‹æµ·æŠ¥\">ä¾‹ï¼šæµ·æŠ¥</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P9790\" class=\"uri\">https://www.luogu.com.cn/problem/P9790</a></p>\n<p>å®¹æ˜“åˆ—å‡ºæš´åŠ› DP å¼ï¼šä»¤ <span class=\"math inline\">\\(f_{i,j}\\)</span> è¡¨ç¤ºæšä¸¾åˆ° <span class=\"math inline\">\\(i\\)</span> æ—¶ï¼ŒåŒ…å« <span class=\"math inline\">\\(i\\)</span> åœ¨å†…å·²ç»æœ‰ <span class=\"math inline\">\\(j\\)</span> ä¸ªè¿ç»­çš„äººä¸¾èµ·æµ·æŠ¥ï¼Œæ˜“å¾—ï¼š</p>\n<p><span class=\"math display\">\\[\nf_{i,0}=\\max(f_{i-1,0},f_{i-1,1},f_{i-1,2},f_{i-1,3})\\\\\nf_{i,j}=f_{i-1,j-1}+a_i \\forall 1\\le j\\le 3\n\\]</span></p>\n<p>å‘ç°æ»¡è¶³ + / max <strong>çŸ©é˜µä¹˜æ³•</strong> çš„å½¢å¼ï¼›æƒ³åˆ°ç”¨çº¿æ®µæ ‘ä¿å­˜æ¯æ®µåŒºé—´å¯¹åº”çŸ©é˜µï¼ˆå¯¹åº”æ€§è´¨ï¼šç»“åˆå¾‹ï¼‰ï¼Œæ¯æ¬¡ä¿®æ”¹ / æŸ¥è¯¢å°±èƒ½åœ¨ <span class=\"math inline\">\\(O(\\log n)\\)</span> ä¹‹å†…å®Œæˆã€‚</p>\n<p>åŸé—®é¢˜æ˜¯ç¯å½¢çš„ï¼Œå¯ä»¥å†åŠ ä¸€ç»´ <span class=\"math inline\">\\(k\\)</span> è¡¨ç¤ºé’¦å®šé€‰äº†å‰ <span class=\"math inline\">\\(k\\)</span> ä¸ªä¸”ä¸é€‰ç¬¬ <span class=\"math inline\">\\(k+1\\)</span> ä¸ªæ—¶çš„ç­”æ¡ˆã€‚</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 4e4 + 5;\nconst long long inf = 1e18;\nstruct mat &#123;\n    int n, m;\n    long long a[4][4];\n    mat() &#123;&#125;\n    mat(int n1, int m1): n(n1), m(m1) &#123;\n        for (int i = 0; i &lt; n; ++i)\n            for (int j = 0; j &lt; m; ++j)\n                a[i][j] = -inf;\n        return;\n    &#125;\n    long long* operator[] (const int q) &#123;\n        return a[q];\n    &#125;\n    mat operator* (mat &amp;q) const &#123;\n        mat res(n, q.m);\n        for (int i = 0; i &lt; n; ++i)\n            for (int k = 0; k &lt; q.m; ++k)\n                for (int j = 0; j &lt; m; ++j)\n                    res[i][k] = std::max(res[i][k], a[i][j] + q[j][k]);\n        return res;\n    &#125;\n    mat&amp; operator*= (mat &amp;q) &#123;\n        return *this = *this * q;\n    &#125;\n&#125;;\nstruct &#123; int l, r; mat u[4]; &#125; t[maxn &lt;&lt; 2];\nint a[maxn];\n#define lt (p &lt;&lt; 1)\n#define rt (lt | 1)\n#define c t[p].u[i]\nvoid bld(int p, int l, int r) &#123;\n    t[p].l = l, t[p].r = r;\n    if (l == r) &#123;\n        for (int i = 0; i &lt;= 3; ++i) &#123;\n            c = mat(4, 4);\n            if (l &gt; i + 1) &#123;\n                c[0][0] = c[1][0] = c[2][0] = c[3][0] = 0;\n                c[0][1] = c[1][2] = c[2][3] = a[l];\n            &#125;\n            else if (l == i + 1)\n                c[0][0] = c[1][0] = c[2][0] = c[3][0] = 0;\n            else\n                c[0][1] = c[1][2] = c[2][3] = a[l];\n        &#125;\n        return;\n    &#125;\n    int mid = (l + r) &gt;&gt; 1;\n    bld(lt, l, mid), bld(rt, mid + 1, r);\n    for (int i = 0; i &lt;= 3; ++i)\n        t[p].u[i] = t[lt].u[i] * t[rt].u[i];\n    return;\n&#125;\nvoid add(int p, int x, int v) &#123;\n    if (t[p].l == t[p].r) &#123;\n        for (int i = 0; i &lt;= 3; ++i)\n            if (t[p].l != i + 1) \n                c[0][1] = c[1][2] = c[2][3] = v;\n        return;\n    &#125;\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (x &lt;= mid)\n        add(lt, x, v);\n    else\n        add(rt, x, v);\n    for (int i = 0; i &lt;= 3; ++i)\n        t[p].u[i] = t[lt].u[i] * t[rt].u[i];\n    return;\n&#125;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i];\n    bld(1, 1, n);\n    auto calc = [&amp;](void) &#123;\n        mat f(1, 4);\n        f[0][0] = 0;\n        auto res = -inf;\n        for (int i = 0; i &lt;= 3; ++i) &#123;\n            auto r = (f * t[1].u[i]);\n            for (int j = 0; j &lt;= 3; ++j)\n                if (i + j &lt;= 3) &#123;\n                    res = std::max(res, r[0][j]);\n                    // printf(&quot;f[%d][%d] = %lld\\n&quot;, i, j, f[i][j]);\n                &#125;\n        &#125;\n        return res;\n    &#125;;\n    std::cout &lt;&lt; calc() &lt;&lt; &#39;\\n&#39;;\n    int q;\n    std::cin &gt;&gt; q;\n    for (int x, v; q--; ) &#123;\n        std::cin &gt;&gt; x &gt;&gt; v;\n        add(1, x, v);\n        std::cout &lt;&lt; calc() &lt;&lt; &#39;\\n&#39;;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<p>å‘ç°çŸ©é˜µæœ¬èº«å’Œ <span class=\"math inline\">\\(k\\)</span> æ— å…³ï¼Œè¿˜å¯ä»¥å¯ä»¥å…±ç”¨ä¸€ä¸ªçº¿æ®µæ ‘ä¸Šçš„ä¿¡æ¯ï¼Œå°±å¯ä»¥åªå¼€ä¸€ä¸ªçº¿æ®µæ ‘äº†ã€‚</p>\n<details>\n<p>æˆ‘å†™è¿™ä¸€ç‰ˆæœ¬çš„åŸå› æ˜¯ <code>maxn</code> å¼€å¤§äº†å¯¼è‡´ MLEï¼Œå®é™…ä¸Šå››ä¸ªçº¿æ®µæ ‘æ˜¯æ²¡æœ‰ä»»ä½•ç©ºé—´å‹åŠ›çš„ ğŸ˜…</p>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 4e5 + 5;\nconst long long inf = 1e18;\nstruct mat &#123;\n    int n, m;\n    long long a[4][4];\n    mat() &#123;&#125;\n    mat(int n1, int m1): n(n1), m(m1) &#123;\n        for (int i = 0; i &lt; n; ++i)\n            for (int j = 0; j &lt; m; ++j)\n                a[i][j] = -inf;\n        return;\n    &#125;\n    long long* operator[] (const int q) &#123;\n        return a[q];\n    &#125;\n    mat operator* (mat q) const &#123;\n        mat res(n, q.m);\n        for (int i = 0; i &lt; n; ++i)\n            for (int k = 0; k &lt; q.m; ++k)\n                for (int j = 0; j &lt; m; ++j)\n                    res[i][k] = std::max(res[i][k], a[i][j] + q[j][k]);\n        return res;\n    &#125;\n    mat&amp; operator*= (mat &amp;q) &#123;\n        return *this = *this * q;\n    &#125;\n&#125;;\nstruct &#123; int l, r; mat u; &#125; t[maxn &lt;&lt; 2];\nint a[maxn];\n#define lt (p &lt;&lt; 1)\n#define rt (lt | 1)\nvoid bld(int p, int l, int r) &#123;\n    t[p].l = l, t[p].r = r;\n    if (l == r) &#123;\n        t[p].u = mat(4, 4);\n        t[p].u[0][0] = t[p].u[1][0] = t[p].u[2][0] = t[p].u[3][0] = 0;\n        t[p].u[0][1] = t[p].u[1][2] = t[p].u[2][3] = a[l];\n        return;\n    &#125;\n    int mid = (l + r) &gt;&gt; 1;\n    bld(lt, l, mid), bld(rt, mid + 1, r);\n    t[p].u = t[lt].u * t[rt].u;\n    return;\n&#125;\nvoid add(int p, int x, int v) &#123;\n    if (t[p].l == t[p].r) &#123;\n        t[p].u[0][1] = t[p].u[1][2] = t[p].u[2][3] = v;\n        return;\n    &#125;\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (x &lt;= mid)\n        add(lt, x, v);\n    else\n        add(rt, x, v);\n    t[p].u = t[lt].u * t[rt].u;\n    return;\n&#125;\nmat ask(int p, int l, int r) &#123;\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r)\n        return t[p].u;\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (r &lt;= mid)\n        return ask(lt, l, r);\n    if (l &gt; mid)\n        return ask(rt, l, r);\n    return ask(lt, l, r) * ask(rt, l, r);\n&#125;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i];\n    bld(1, 1, n);\n    auto calc = [&amp;](void) &#123;\n        mat f(1, 4);\n        f[0][0] = 0, f[0][1] = f[0][2] = f[0][3] = -inf;\n        auto r(f * ask(1, 2, n));\n        auto res(*std::max_element(r[0], r[0] + 4));\n        mat z(4, 4);\n        z[0][0] = z[1][0] = z[2][0] = z[3][0] = 0ll;\n        for (int i = 1; i &lt;= 3; ++i) &#123;\n            mat op(4, 4);\n            op[0][1] = op[1][2] = op[2][3] = a[i];\n            f *= op;\n            if (i + 2 &lt;= n)\n                r = f * z * ask(1, i + 2, n);\n            else\n                r = f * z;\n            res = std::max(res, *std::max_element(r[0], r[0] + 4 - i));\n        &#125;\n        return res;\n    &#125;;\n    std::cout &lt;&lt; calc() &lt;&lt; &#39;\\n&#39;;\n    int q;\n    std::cin &gt;&gt; q;\n    for (int x, v; q--; ) &#123;\n        std::cin &gt;&gt; x &gt;&gt; v, a[x] = v;\n        add(1, x, v);\n        std::cout &lt;&lt; calc() &lt;&lt; &#39;\\n&#39;;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"ç»å…¸é¢˜gss3\">ç»å…¸é¢˜ï¼šGSS3</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/SP1716\" class=\"uri\">https://www.luogu.com.cn/problem/SP1716</a></p>\n<p>æ€ä¹ˆæ˜¯å­æ®µå’Œ ğŸ˜“</p>\n<p>åŒæ ·åˆ—å‡ºèƒ½å¤ŸçŸ©é˜µä¹˜æ³•çš„ DP å¼ï¼Œå‘ç°é™åˆ¶åœ¨äºè‡³å°‘è¦é€‰ä¸€ä¸ªæ•°ã€‚è®¾ <span class=\"math inline\">\\(f_{i}\\)</span> è¡¨ç¤ºé€‰äº† <span class=\"math inline\">\\(i\\)</span> çš„æœ€å¤§å€¼ï¼Œ<span class=\"math inline\">\\(g_i\\)</span> è¡¨ç¤ºå†å²æœ€å¤§å€¼ï¼Œåˆ™ï¼š</p>\n<p><span class=\"math display\">\\[\nf_i=\\max(f_{i-1}+a_i,0+a_i)\\\\\ng_i=\\max(g_{i-1}+0,f_{i-1}+a_i,0+a_i)\n\\]</span></p>\n<p>å®¹æ˜“å‘ç°æ˜¯ä¸€ä¸ª + / max çŸ©ä¹˜ï¼Œçº¿æ®µæ ‘ç»´æŠ¤å³å¯ã€‚</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 4e5 + 5;\nconst long long inf = 1e18;\nstruct mat &#123;\n    int n, m;\n    long long a[3][3];\n    mat() &#123;&#125;\n    mat(int n1, int m1): n(n1), m(m1) &#123;\n        for (int i = 0; i &lt; n; ++i)\n            for (int j = 0; j &lt; m; ++j)\n                a[i][j] = -inf;\n        return;\n    &#125;\n    long long* operator[] (const int q) &#123;\n        return a[q];\n    &#125;\n    mat operator* (mat q) const &#123;\n        mat res(n, q.m);\n        for (int i = 0; i &lt; n; ++i)\n            for (int k = 0; k &lt; q.m; ++k)\n                for (int j = 0; j &lt; m; ++j)\n                    res[i][k] = std::max(res[i][k], a[i][j] + q[j][k]);\n        return res;\n    &#125;\n    mat&amp; operator*= (mat &amp;q) &#123;\n        return *this = *this * q;\n    &#125;\n&#125;;\nstruct &#123; int l, r; mat u; &#125; t[maxn &lt;&lt; 2]; \nint a[maxn];\n#define lt (p &lt;&lt; 1)\n#define rt (lt | 1)\nvoid bld(int p, int l, int r) &#123;\n    t[p].l = l, t[p].r = r;\n    if (l == r) &#123;\n        t[p].u = mat(3, 3);\n        t[p].u[0][0] = t[p].u[2][0] = a[l];\n        t[p].u[0][1] = a[l], t[p].u[1][1] = 0ll, t[p].u[2][1] = a[l];\n        t[p].u[2][2] = 0ll;\n        return;\n    &#125;\n    int mid = (l + r) &gt;&gt; 1;\n    bld(lt, l, mid), bld(rt, mid + 1, r);\n    t[p].u = t[lt].u * t[rt].u;\n    return;\n&#125;\nvoid add(int p, int x, int v) &#123;\n    if (t[p].l == t[p].r) &#123;\n        t[p].u[0][0] = t[p].u[2][0] = t[p].u[0][1] = t[p].u[2][1] = v;\n        return;\n    &#125;\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (x &lt;= mid)\n        add(lt, x, v);\n    else\n        add(rt, x, v);\n    t[p].u = t[lt].u * t[rt].u;\n    return;\n&#125;\nmat ask(int p, int l, int r) &#123;\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r)\n        return t[p].u;\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (r &lt;= mid)\n        return ask(lt, l, r);\n    if (l &gt; mid)\n        return ask(rt, l, r);\n    return ask(lt, l, r) * ask(rt, l, r);\n&#125;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i];\n    bld(1, 1, n);\n    auto calc = [&amp;](int l, int r) &#123;\n        mat f(1, 3);\n        f[0][2] = 0ll;\n        auto res(f * ask(1, l, r));\n        return res[0][1];\n    &#125;;\n    int q;\n    std::cin &gt;&gt; q;\n    for (int op; q--; ) &#123;\n        std::cin &gt;&gt; op;\n        if (op == 1) &#123;\n            int l, r;\n            std::cin &gt;&gt; l &gt;&gt; r;\n            std::cout &lt;&lt; calc(l, r) &lt;&lt; &#39;\\n&#39;;\n        &#125;\n        else &#123;\n            int x, v;\n            std::cin &gt;&gt; x &gt;&gt; v;\n            a[x] = v, add(1, x, v);\n        &#125;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"åŠ¨æ€æ ‘-dp\">åŠ¨æ€æ ‘ DP</h2>\n<p>æŠŠä¸Šè¿°è¿‡ç¨‹æ”¾åˆ°æ ‘ä¸Šï¼Œå¾ˆå®¹æ˜“æƒ³åˆ°æ ‘å‰– + çº¿æ®µæ ‘ã€‚</p>\n<p>ç”±äºè®¤ä¸ºçº¿æ®µæ ‘ä¸Šçš„çŸ©ä¹˜åªèƒ½è¿›è¡Œä»é‡å„¿å­åˆ°çˆ¶äº²çš„è½¬ç§»ï¼Œè½»å„¿å­çš„è½¬ç§»ä¼šè¢«åˆå¹¶ä¸ºä¸€ä¸ªæ–°å‡½æ•°ï¼ˆåŒæ—¶æ˜¯çŸ©é˜µçš„ç³»æ•°ï¼‰ï¼Œåœ¨è·³é‡é“¾çš„æ—¶å€™è¢«å•ç‹¬æ›´æ–°ã€‚</p>\n<p>ç”±äºä¸¤ä¸ªå‡½æ•°ç›¸äº’ä¾èµ–ï¼Œéœ€è¦æ€è€ƒæ¸…æ¥šæ›´æ–°çš„å…ˆåé¡ºåºã€‚</p>\n<h3 id=\"æ¨¡æ¿åŠ¨æ€-dp\">ã€æ¨¡æ¿ã€‘åŠ¨æ€ DP</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P4719\" class=\"uri\">https://www.luogu.com.cn/problem/P4719</a></p>\n<p>ä»¤ <span class=\"math inline\">\\(f_{u,0/1}\\)</span> è¡¨ç¤ºåœ¨ <span class=\"math inline\">\\(u\\)</span> ä¸Šï¼Œé€‰ / ä¸é€‰ <span class=\"math inline\">\\(u\\)</span> çš„æœ€å¤§ä»·å€¼ã€‚å®¹æ˜“å¾—å‡ºè½¬ç§»ï¼š</p>\n<p><span class=\"math display\">\\[\nf_{u,0}=\\sum\\max(f_{v,0},f_{v,1})\\\\\nf_{u,1}=a_i+\\sum f_{v,0}\n\\]</span></p>\n<p>æŠŠè½¬ç§»çŸ©é˜µæ”¾åˆ°æ ‘å‰–ä¸Šåï¼Œè€ƒè™‘æ›´æ–°ï¼Œå‘ç°æ±‚å’Œè¿™ä¸€æ­¥å¾ˆå›°éš¾ã€‚è§£å†³æ–¹æ¡ˆæ˜¯<strong>ç›´æ¥å°†æ±‚å’Œç”¨å¦ä¸€ä¸ªå‡½æ•°ä»£æ›¿</strong>ã€‚å®šä¹‰ <span class=\"math inline\">\\(g_{u,0}\\)</span> è¡¨ç¤ºå– <span class=\"math inline\">\\(u\\)</span>ã€ä¸å– <span class=\"math inline\">\\(u\\)</span> çš„æ‰€æœ‰è½»å„¿å­çš„ç­”æ¡ˆï¼Œ<span class=\"math inline\">\\(g_{u,1}\\)</span> ä¸å– <span class=\"math inline\">\\(u\\)</span>ï¼Œè½»å„¿å­å¯é€‰å¯ä¸é€‰çš„ç­”æ¡ˆã€‚</p>\n<p><span class=\"math inline\">\\(g\\)</span> æ˜¯å¯æ±‚çš„ï¼Œä¸”åªéœ€è¦åœ¨è·³é‡é“¾çš„æ—¶å€™æ›´æ–° <span class=\"math inline\">\\(g\\)</span>ã€‚å…·ä½“æ›´æ–°èµ·æ¥éå¸¸ç»ï¼Œå› ä¸º <span class=\"math inline\">\\(g\\)</span> å’Œ <span class=\"math inline\">\\(f\\)</span> æ˜¯ç›¸äº’ä¾èµ–çš„ï¼Œéœ€è¦åˆ†æ¸…æ¥šå…ˆåå…³ç³»ã€‚</p>\n<p>é¦–å…ˆ <span class=\"math inline\">\\(g_u\\)</span> å’Œ <span class=\"math inline\">\\(f_u\\)</span> éƒ½ä¼šè¢«æ›´æ–°ï¼›æ¥ç€ï¼Œé‡é“¾ä¸Šå…¶å®ƒçš„ <span class=\"math inline\">\\(g\\)</span> ä¸ä¼šè¢«å½±å“ï¼Œè€Œé“¾é¡¶çš„ <span class=\"math inline\">\\(f\\)</span> éœ€è¦è¢«æ–°çš„ <span class=\"math inline\">\\(g_u\\)</span> æ›´æ–°ï¼›ç”±æ­¤é“¾é¡¶çˆ¶äº²çš„ <span class=\"math inline\">\\(g\\)</span> è¢«æ›´æ–°ï¼›ä¾æ¬¡ç±»æ¨ã€‚æ³¨æ„åˆ°å¯¹äºä¸€ä¸ªé“¾é¡¶ï¼Œå…¶ <span class=\"math inline\">\\(f\\)</span> å€¼æ˜¯æ•´æ¡é‡é“¾çš„ä¹˜ç§¯ï¼Œæ•…éœ€è¦è®°å½•é“¾åº•ã€‚</p>\n<p>å¤æ‚åº¦ <span class=\"math inline\">\\(O(q\\log ^2n)\\)</span>ã€‚æ³¨æ„å¾ˆé‡è¦çš„ä¸€ç‚¹æ˜¯çº¿æ®µæ ‘å†…ä¹˜æ³•åº”ä»å³å¾€å·¦ã€‚</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 1e5 + 5;\nconst int inf = 0x3f3f3f3f;\nstruct mat &#123;\n    int n, m, a[2][2];\n    mat() &#123;&#125;\n    mat(int n1, int m1): n(n1), m(m1) &#123;\n        for (int i = 0; i &lt; n; ++i)\n            for (int j = 0; j &lt; m; ++j)\n                a[i][j] = -inf;\n        return;\n    &#125;\n    int* operator[] (const int q) &#123;\n        return a[q];\n    &#125;\n    mat operator* (mat q) const &#123;\n        mat res(n, q.m);\n        for (int i = 0; i &lt; n; ++i)\n            for (int k = 0; k &lt; q.m; ++k)\n                for (int j = 0; j &lt; m; ++j)\n                    res[i][k] = std::max(res[i][k], a[i][j] + q[j][k]);\n        return res;\n    &#125;\n    mat&amp; operator*= (mat &amp;q) &#123;\n        return *this = *this * q;\n    &#125;\n&#125;;\nstruct &#123; int l, r; mat u; &#125; t[maxn &lt;&lt; 2]; \nint g[maxn][2], tab[maxn];\n#define lt (p &lt;&lt; 1)\n#define rt (lt | 1)\nvoid bld(int p, int l, int r) &#123;\n    t[p].l = l, t[p].r = r;\n    if (l == r) &#123;\n        int u = tab[l];\n        t[p].u = mat(2, 2);\n        t[p].u[0][0] = t[p].u[1][0] = g[u][1];\n        t[p].u[0][1] = g[u][0];\n        return;\n    &#125;\n    int mid = (l + r) &gt;&gt; 1;\n    bld(lt, l, mid), bld(rt, mid + 1, r);\n    t[p].u = t[rt].u * t[lt].u;\n    return;\n&#125;\nvoid add(int p, int x) &#123;\n    if (t[p].l == t[p].r) &#123;\n        int u = tab[x];\n        t[p].u[0][0] = t[p].u[1][0] = g[u][1];\n        t[p].u[0][1] = g[u][0];\n        return;\n    &#125;\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (x &lt;= mid)\n        add(lt, x);\n    else\n        add(rt, x);\n    t[p].u = t[rt].u * t[lt].u;\n    return;\n&#125;\nmat ask(int p, int l, int r) &#123;\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r)\n        return t[p].u;\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (r &lt;= mid)\n        return ask(lt, l, r);\n    if (l &gt; mid)\n        return ask(rt, l, r);\n    return ask(rt, l, r) * ask(lt, l, r);\n&#125;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, q;\n    std::cin &gt;&gt; n &gt;&gt; q;\n    std::vector&lt;int&gt; a(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i];\n    std::vector&lt;std::vector&lt;int&gt; &gt; g1(n + 1);\n    for (int i = 1, x, y; i &lt; n; ++i) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y;\n        g1[x].push_back(y), g1[y].push_back(x);\n    &#125;\n    std::vector&lt;int&gt; siz(n + 1), son(n + 1), fa(n + 1);\n    std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;\n        siz[x] = 1;\n        for (auto i : g1[x])\n            if (i != fa[x]) &#123;\n                fa[i] = x, DFS(i);\n                siz[x] += siz[i];\n                if (siz[i] &gt; siz[son[x]])\n                    son[x] = i;\n            &#125;\n        return;\n    &#125;;\n    DFS(1);\n    std::vector&lt;std::array&lt;int, 2&gt; &gt; f(n + 1);\n    std::vector&lt;int&gt; top(n + 1), bot(n + 1), dfn(n + 1);\n    DFS = [&amp;](int x) &#123;\n        static int now = 0;\n        dfn[x] = ++now, tab[now] = x;\n        if (son[x]) &#123;\n            top[son[x]] = top[x], DFS(son[x]);\n            bot[x] = bot[son[x]];\n            g[x][0] = a[x];\n            for (auto i : g1[x])\n                if (i != son[x] &amp;&amp; i != fa[x]) &#123;\n                    top[i] = i, DFS(i);\n                    g[x][0] += f[i][0];\n                    g[x][1] += std::max(f[i][1], f[i][0]);\n                &#125;\n            f[x][0] = g[x][1] + std::max(f[son[x]][0], f[son[x]][1]);\n            f[x][1] = g[x][0] + f[son[x]][0];\n        &#125;\n        else\n            f[x][1] = g[x][0] = a[x], bot[x] = x;\n        return;\n    &#125;;\n    top[1] = 1, DFS(1);\n    bld(1, 1, n);\n    for (int x, v; q--; ) &#123;\n        std::cin &gt;&gt; x &gt;&gt; v;\n        g[x][0] -= a[x], g[x][0] += v, a[x] = v;\n        for (; top[x] != 1; ) &#123;\n            auto r = ask(1, dfn[top[x]], dfn[bot[x]]);\n            f[top[x]][0] = r[0][0], f[top[x]][1] = r[0][1];\n            g[fa[top[x]]][0] -= f[top[x]][0];\n            g[fa[top[x]]][1] -= std::max(f[top[x]][0], f[top[x]][1]);\n            add(1, dfn[x]);\n            r = ask(1, dfn[top[x]], dfn[bot[x]]);\n            f[top[x]][0] = r[0][0], f[top[x]][1] = r[0][1];\n            g[fa[top[x]]][0] += f[top[x]][0];\n            g[fa[top[x]]][1] += std::max(f[top[x]][0], f[top[x]][1]);\n            x = fa[top[x]];\n        &#125;\n        add(1, dfn[x]);\n        auto r = ask(1, dfn[1], dfn[bot[1]]);\n        f[1][0] = r[0][0], f[1][1] = r[0][1];\n        std::cout &lt;&lt; std::max(f[1][0], f[1][1]) &lt;&lt; &#39;\\n&#39;;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"å…¨å±€å¹³è¡¡äºŒå‰æ ‘\">å…¨å±€å¹³è¡¡äºŒå‰æ ‘</h2>\n<p>å›é¡¾æ ‘å‰–ï¼ˆé‡å‰–ï¼‰ï¼ŒåŠŸèƒ½åœ¨äºè§£å†³è·¯å¾„é—®é¢˜ï¼Œå•æ¬¡æ“ä½œèƒ½å¤Ÿåœ¨ <span class=\"math inline\">\\(O(\\log^2 n)\\)</span> çš„æ—¶é—´å†…å®Œæˆã€‚è¿™ä¸ªåŠŸèƒ½å¯ä»¥è¢«<strong>å…¨å±€å¹³è¡¡äºŒå‰æ ‘ï¼ˆGBTï¼‰</strong>ä¸Šä½æ›¿ä»£ã€‚GBT èƒ½å¤Ÿåœ¨å•æ¬¡ <span class=\"math inline\">\\(O(\\log n)\\)</span> çš„å¤æ‚åº¦å†…å®Œæˆé“¾æ“ä½œã€å­æ ‘æ“ä½œã€‚<em><a href=\"QTREEè§£æ³•çš„ä¸€äº›ç ”ç©¶.pdf\">Yang Zhe - SPOJ375 QTREE è§£æ³•çš„ä¸€äº›ç ”ç©¶</a> ä¸­æ›´ä¸ºè¯¦ç»†ä¸¥è°¨åœ°å¯¹ GBT è¿›è¡Œäº†è¯´æ˜ï¼Œæˆ‘ä¼ äº†ä»½æ–‡ä»¶ä¸Šæ¥ã€‚</em></p>\n<p>è€ƒè™‘æ ‘å‰–èƒ½è¢«å¡çš„åŸå› ï¼šæ¯æ¬¡çº¿æ®µæ ‘è¯¢é—®éƒ½ä¼šå¡æ»¡ <span class=\"math inline\">\\(O(\\log n)\\)</span>ï¼Œæ‰¾ä¸€æ¡å¡å¾—æ»¡ <span class=\"math inline\">\\(O(\\log n)\\)</span> æ¬¡è·³é‡é“¾æ¬¡æ•°çš„è·¯å¾„ä¸€ç›´è–…ï¼Œå°±å¯ä»¥å¡åˆ° <span class=\"math inline\">\\(O(\\log^2 n)\\)</span>ã€‚</p>\n<p>åœ¨å®ç°çº¿æ®µæ ‘æ—¶å‘ç°ï¼Œå¯¹äº<strong>è·¯å¾„æ“ä½œ</strong>å’Œ<strong>å•ç‚¹æ“ä½œ</strong>ï¼Œæ ‘å‰–åªéœ€è¦ç»´æŠ¤åŒä¸€æ¡é‡é“¾çš„ä¿¡æ¯ï¼Œå»ºä¸€ä¸ªå¤§çº¿æ®µæ ‘ä¼šäº§ç”Ÿè®¸å¤šé‡é“¾é—´çš„æ— æ•ˆç»´æŠ¤ã€‚æ•…ä¸€ç§ç»å…¸çš„æ ‘å‰–å¡å¸¸æŠ€å·§æ˜¯å¯¹äºæ¯ä¸€æ¡é‡é“¾å»ºå‡ºçº¿æ®µæ ‘ã€‚</p>\n<p>åœ¨æœ¬æ–‡ä¸­å®šä¹‰<strong>å…¨å±€äºŒå‰æ ‘</strong>ï¼šå°†å•ä¸ªçº¿æ®µæ ‘æŒ‰ç…§åœ¨åŸæ ‘ä¸Šé‡é“¾é¡¶çš„ç›¸å¯¹ç¥–å­™å…³ç³»è¿è¾¹å¾—åˆ°çš„æ¨¡å‹ã€‚è¿™é‡Œä¸ºäº†å’Œ<strong>å…¨å±€å¹³è¡¡äºŒå‰æ ‘</strong>å½¢æˆç…§åº”è€Œå‘½åï¼Œå®é™…ä¸Šæ¨¡å‹å¹¶ä¸æ˜¯äºŒå‰æ ‘ã€‚å®¹æ˜“å‘ç°<strong>ä¿®æ”¹æŸä¸ªç‚¹èŠ±è´¹çš„æ“ä½œæ¬¡æ•°å’Œå…¶åœ¨å…¨å±€äºŒå‰æ ‘ä¸­çš„æ·±åº¦ç›¸åŒ</strong>ã€‚</p>\n<p>è€ƒè™‘æœ¬æ–¹æ³•ç†è®ºä¸Šä»å¯å¡åˆ° <span class=\"math inline\">\\(O(\\log^2 n)\\)</span> å•æ¬¡æ“ä½œçš„åŸå› ï¼Œè™½ç„¶å•ä¸ªçº¿æ®µæ ‘å¹³è¡¡ï¼Œä½†<strong>å…¨å±€äºŒå‰æ ‘</strong>å¹¶ä¸å¹³è¡¡ï¼›èƒ½å¤Ÿæ„é€ æ•°æ®ä½¿å¾—æ ‘é«˜è¾¾åˆ° <span class=\"math inline\">\\(\\log^2 n\\)</span>ã€‚è€ƒè™‘ä½¿å¾—å…¨å±€äºŒå‰æ ‘å¹³è¡¡ï¼Œå³è°ƒæ•´çº¿æ®µæ ‘ç»“æ„ä½¿å¾—ä»»ä½•ä¸€ä¸ªç‚¹åœ¨å…¨å±€äºŒå‰æ ‘ä¸Šçš„å·¦å³å„¿å­å¤§å°æœ€æ¥è¿‘ã€‚å‘ç°æ˜¯æ˜“åšçš„ï¼Œåªéœ€åœ¨å»ºçº¿æ®µæ ‘æ—¶ç§»åŠ¨å·¦å³å„¿å­åˆ†å‰²ç‚¹ä½¿å¾—ä¸¤è¾¹å­æ ‘å¤§å°å‡ä¸ºå…¨æ ‘çš„ä¸€åŠå³å¯ã€‚</p>\n<p>æ³•ä¸€ï¼šæ±‚å‡ºæ¯ä¸ªç‚¹çš„è½»å­æ ‘å¤§å° <span class=\"math inline\">\\(ls_u=1+\\sum siz_v\\)</span>ï¼Œä½œä¸ºåŠ æƒåœ¨çº¿æ®µæ ‘ä¸Šæ‰¾ mid å°±èƒ½æ»¡è¶³å…¨å±€å¹³è¡¡ï¼›è¯æ˜å¯ä»¥è§ä¸Šé¢çš„è®ºæ–‡ã€‚è¿™é‡Œç”¨çº¿æ®µæ ‘ä»£æ›¿äº† BSTï¼Œå¸¸æ•°å¾ˆå¤§ã€‚</p>\n<p>æ³•äºŒï¼šç”¨ä¸€ä¸ª BST å®ç°ä¸Šè¿°åŠŸèƒ½ï¼Œéœ€è¦æ»¡è¶³ï¼šä»»æ„å­æ ‘çš„æ ¹ä¸ºå­æ ‘çš„å¸¦æƒ midï¼›BST çš„ä¸­åºéå†ä¸ºåŸé‡é“¾ã€‚æ˜¾ç„¶æœ‰ï¼šæ ‘é«˜ä¸º log çº§åˆ«ã€‚è¿™å°±å†³å®šäº†æ‰€æœ‰é—®é¢˜éƒ½å¯ä»¥é€šè¿‡æš´åŠ›çˆ¬å±±è§£å†³ã€‚</p>\n<p>GBT èƒ½å¤Ÿå¿«é€Ÿç»´æŠ¤<strong>æ™®é€šæ ‘å‰–æ“ä½œ</strong>å’Œ <strong>DDP ä¿¡æ¯</strong>ã€‚</p>\n<hr />\n<h3 id=\"ç»´æŠ¤-ddpæ¨¡æ¿åŠ¨æ€-dpåŠ å¼ºç‰ˆ\">ç»´æŠ¤ DDPï¼šã€æ¨¡æ¿ã€‘åŠ¨æ€ DPï¼ˆåŠ å¼ºç‰ˆï¼‰</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P4751\" class=\"uri\">https://www.luogu.com.cn/problem/P4751</a></p>\n<p>å’ŒæœªåŠ å¼ºç‰ˆç±»ä¼¼ï¼ŒæŠŠæ‰€æœ‰çº¿æ®µæ ‘æ“ä½œæ›¿æ¢ä¸º BST å³å¯ã€‚å¦‚æœå†™å¾—ä¸‘å¯èƒ½éœ€è¦ä¸€äº›é¢å¤–çš„å¡å¸¸æŠ€å·§ã€‚</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 1e6 + 5;\nconst int inf = 0x3f3f3f3f;\nconst int LEN = (1 &lt;&lt; 20);\nint nec(void) &#123;\n    static char buf[LEN], *p = buf, *e = buf;\n    if (p == e) &#123;\n        e = buf + fread(buf, 1, LEN, stdin);\n        if (e == buf) return EOF;\n        p = buf;\n    &#125;\n    return *p++;\n&#125;\nbool read(int &amp;x) &#123;\n    x = 0;\n    bool f = 0;\n    char ch = nec();\n    while (ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123;\n        if (ch == EOF) return 0;\n        if (ch == &#39;-&#39;) f = 1;\n        ch = nec();\n    &#125;\n    while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) &#123;\n        x = x * 10 + ch - &#39;0&#39;;\n        ch = nec();\n    &#125;\n    if (f) x = -x;\n    return 1;\n&#125;\nvoid print(int x) &#123;\n    if (x &lt; 0)\n        putchar(&#39;-&#39;), x = -x;\n    if (x &gt;= 10) print(x / 10);\n    putchar(x % 10 + &#39;0&#39;);\n    return;\n&#125;\nvoid print(int x, char ch) &#123;\n    print(x), putchar(ch);\n    return;\n&#125;\nstruct mat &#123;\n    int a[2][2];\n    int* operator[] (const int q) &#123; \n        return a[q];\n    &#125;\n    mat operator* (mat &amp;q) const &#123;\n        mat res;\n        res[0][0] = res[0][1] = res[1][0] = res[1][1] = -inf;\n        for (int i = 0; i &lt; 2; ++i)\n            for (int k = 0; k &lt; 2; ++k)\n                for (int j = 0; j &lt; 2; ++j)\n                    res[i][k] = std::max(res[i][k], a[i][j] + q[j][k]);\n        return res;\n    &#125;\n    mat&amp; operator*= (mat &amp;q) &#123;\n        return *this = *this * q;\n    &#125;\n&#125;;\nstruct &#123; int lc, rc, fa; mat u; &#125; t[maxn]; \nint g[maxn][2], tab[maxn], ls[maxn];\nmat p[maxn];\nvoid pushup(int x) &#123;\n    t[x].u = t[t[x].rc].u * p[x] * t[t[x].lc].u;\n    return;\n&#125;\nvoid bld(int &amp;x, int l, int r) &#123;\n    if (l &gt; r)\n        return;\n    int s = 0, k = 0;\n    for (int i = l; i &lt;= r; ++i)\n        s += ls[tab[i]];\n    for (int i = l; i &lt;= r; ++i, k += ls[tab[i]])\n        if ((k + ls[tab[i]]) * 2 &gt; s) &#123;\n            x = tab[i];\n            bld(t[x].lc, l, i - 1), t[t[x].lc].fa = x;\n            bld(t[x].rc, i + 1, r), t[t[x].rc].fa = x;\n            pushup(x);\n            break;\n        &#125;\n    return;\n&#125;\n#undef lt\n#undef rt\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    t[0].u[0][0] = t[0].u[1][1] = 0, t[0].u[0][1] = t[0].u[1][0] = -inf;\n    int n, q;\n    read(n), read(q);\n    std::vector&lt;int&gt; a(n + 1), rt(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        read(a[i]);\n    std::vector&lt;std::vector&lt;int&gt; &gt; g1(n + 1);\n    for (int i = 1, x, y; i &lt; n; ++i) &#123;\n        read(x), read(y);\n        g1[x].push_back(y), g1[y].push_back(x);\n    &#125;\n    std::vector&lt;int&gt; son(n + 1), fa(n + 1), siz(n + 1);\n    std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;\n        siz[x] = 1;\n        for (auto i : g1[x])\n            if (i != fa[x]) &#123;\n                fa[i] = x, DFS(i);\n                siz[x] += siz[i];\n                if (siz[i] &gt; siz[son[x]])\n                    son[x] = i;\n            &#125;\n        return;\n    &#125;;\n    DFS(1);\n    std::vector&lt;std::array&lt;int, 2&gt; &gt; f(n + 1);\n    std::vector&lt;int&gt; top(n + 1), bot(n + 1), dfn(n + 1);\n    DFS = [&amp;](int x) &#123;\n        static int now = 0;\n        dfn[x] = ++now, tab[now] = x, ls[x] = 1;\n        if (son[x]) &#123;\n            top[son[x]] = top[x], DFS(son[x]);\n            bot[x] = bot[son[x]];\n            g[x][0] = a[x];\n            for (auto i : g1[x])\n                if (i != son[x] &amp;&amp; i != fa[x]) &#123;\n                    top[i] = i, DFS(i), t[rt[i]].fa = x;\n                    ls[x] += siz[i];\n                    g[x][0] += f[i][0];\n                    g[x][1] += std::max(f[i][1], f[i][0]);\n                &#125;\n            f[x][0] = g[x][1] + std::max(f[son[x]][0], f[son[x]][1]);\n            f[x][1] = g[x][0] + f[son[x]][0];\n        &#125;\n        else\n            f[x][1] = g[x][0] = a[x], bot[x] = x;\n        p[x][0][0] = p[x][1][0] = g[x][1];\n        p[x][0][1] = g[x][0], p[x][1][1] = -inf;\n        if (x == top[x])\n            bld(rt[x], dfn[x], dfn[bot[x]]);\n        return;\n    &#125;;\n    top[1] = 1, DFS(1);\n    for (int x, v, la = 0; q--; ) &#123;\n        read(x), read(v), x ^= la;\n        p[x][0][1] += v - a[x], a[x] = v;\n        for (; x; ) &#123;\n            int fa = t[x].fa;\n            if (fa &amp;&amp; x != t[fa].lc &amp;&amp; x != t[fa].rc) &#123;\n                int f0 = t[x].u[0][0], f1 = std::max(f0, t[x].u[0][1]);\n                pushup(x);\n                int F0 = t[x].u[0][0], F1 = std::max(F0, t[x].u[0][1]);\n                p[fa][0][0] += F1 - f1, p[fa][1][0] += F1 - f1;\n                p[fa][0][1] += F0 - f0;\n            &#125;\n            else\n                pushup(x);\n            x = fa;\n        &#125;\n        print(la = std::max(t[rt[1]].u[0][0], t[rt[1]].u[0][1]), &#39;\\n&#39;);\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<p>ä¹Ÿç»™å‡ºä¸€ä¸ªçº¿æ®µæ ‘ç‰ˆæœ¬çš„</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 1e6 + 5;\nconst int inf = 0x3f3f3f3f;\nconst int LEN = (1 &lt;&lt; 20);\nint nec(void) &#123;\n    static char buf[LEN], *p = buf, *e = buf;\n    if (p == e) &#123;\n        e = buf + fread(buf, 1, LEN, stdin);\n        if (e == buf) return EOF;\n        p = buf;\n    &#125;\n    return *p++;\n&#125;\nbool read(int &amp;x) &#123;\n    x = 0;\n    bool f = 0;\n    char ch = nec();\n    while (ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123;\n        if (ch == EOF) return 0;\n        if (ch == &#39;-&#39;) f = 1;\n        ch = nec();\n    &#125;\n    while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) &#123;\n        x = x * 10 + ch - &#39;0&#39;;\n        ch = nec();\n    &#125;\n    if (f) x = -x;\n    return 1;\n&#125;\nvoid print(int x) &#123;\n    if (x &lt; 0)\n        putchar(&#39;-&#39;), x = -x;\n    if (x &gt;= 10) print(x / 10);\n    putchar(x % 10 + &#39;0&#39;);\n    return;\n&#125;\nvoid print(int x, char ch) &#123;\n    print(x), putchar(ch);\n    return;\n&#125;\nstruct mat &#123;\n    int a[2][2];\n    int* operator[] (const int q) &#123;\n        return a[q];\n    &#125;\n    mat operator* (mat q) const &#123;\n        mat res;\n        res[0][0] = res[0][1] = res[1][0] = res[1][1] = -inf;\n        for (int i = 0; i &lt; 2; ++i)\n            for (int k = 0; k &lt; 2; ++k)\n                for (int j = 0; j &lt; 2; ++j)\n                    res[i][k] = std::max(res[i][k], a[i][j] + q[j][k]);\n        return res;\n    &#125;\n    mat&amp; operator*= (mat &amp;q) &#123;\n        return *this = *this * q;\n    &#125;\n&#125;;\nstruct &#123; int lc, rc, l, r, mid; mat u; &#125; t[maxn &lt;&lt; 2]; \nint g[maxn][2], tab[maxn], ls[maxn];\n#define lt t[p].lc\n#define rt t[p].rc\nvoid bld(int &amp;p, int l, int r) &#123;\n    static int tot = 0;\n    p = ++tot, t[p].l = l, t[p].r = r;\n    if (l == r) &#123;\n        int u = tab[l];\n        t[p].u[0][0] = t[p].u[1][0] = g[u][1];\n        t[p].u[0][1] = g[u][0], t[p].u[1][1] = -inf;\n        return;\n    &#125;\n    int s = 0, u = ls[tab[l]];\n    for (int i = l; i &lt;= r; ++i)\n        s += ls[tab[i]];\n    s &gt;&gt;= 1;\n    t[p].mid = r - 1;\n    for (int i = l + 1; i &lt; r; ++i) &#123;\n        u += ls[tab[i]];\n        if (u + ls[tab[i + 1]] &gt; s) &#123;\n            t[p].mid = i;\n            break;\n        &#125;\n    &#125;\n    bld(lt, l, t[p].mid), bld(rt, t[p].mid + 1, r);\n    t[p].u = t[rt].u * t[lt].u;\n    return;\n&#125;\nvoid add(int p, int x) &#123;\n    if (t[p].l == t[p].r) &#123;\n        int u = tab[x];\n        t[p].u[0][0] = t[p].u[1][0] = g[u][1];\n        t[p].u[0][1] = g[u][0];\n        return;\n    &#125;\n    if (x &lt;= t[p].mid)\n        add(lt, x);\n    else\n        add(rt, x);\n    t[p].u = t[rt].u * t[lt].u;\n    return;\n&#125;\nmat ask(int p, int l, int r) &#123;\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r)\n        return t[p].u;\n    if (r &lt;= t[p].mid)\n        return ask(lt, l, r);\n    if (l &gt; t[p].mid)\n        return ask(rt, l, r);\n    return ask(rt, l, r) * ask(lt, l, r);\n&#125;\n#undef lt\n#undef rt\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, q;\n    read(n), read(q);\n    std::vector&lt;int&gt; a(n + 1), rt(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        read(a[i]);\n    std::vector&lt;std::vector&lt;int&gt; &gt; g1(n + 1);\n    for (int i = 1, x, y; i &lt; n; ++i) &#123;\n        read(x), read(y);\n        g1[x].push_back(y), g1[y].push_back(x);\n    &#125;\n    std::vector&lt;int&gt; siz(n + 1), son(n + 1), fa(n + 1);\n    std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;\n        siz[x] = 1;\n        for (auto i : g1[x])\n            if (i != fa[x]) &#123;\n                fa[i] = x, DFS(i);\n                siz[x] += siz[i];\n                if (siz[i] &gt; siz[son[x]])\n                    son[x] = i;\n            &#125;\n        return;\n    &#125;;\n    DFS(1);\n    std::vector&lt;std::array&lt;int, 2&gt; &gt; f(n + 1);\n    std::vector&lt;int&gt; top(n + 1), bot(n + 1), dfn(n + 1);\n    DFS = [&amp;](int x) &#123;\n        static int now = 0;\n        dfn[x] = ++now, tab[now] = x;\n        ls[x] = 1;\n        if (son[x]) &#123;\n            top[son[x]] = top[x], DFS(son[x]);\n            bot[x] = bot[son[x]];\n            g[x][0] = a[x];\n            for (auto i : g1[x])\n                if (i != son[x] &amp;&amp; i != fa[x]) &#123;\n                    top[i] = i, DFS(i);\n                    ls[x] += siz[i];\n                    g[x][0] += f[i][0];\n                    g[x][1] += std::max(f[i][1], f[i][0]);\n                &#125;\n            f[x][0] = g[x][1] + std::max(f[son[x]][0], f[son[x]][1]);\n            f[x][1] = g[x][0] + f[son[x]][0];\n        &#125;\n        else\n            f[x][1] = g[x][0] = a[x], bot[x] = x;\n        if (x == top[x])\n            bld(rt[x], dfn[x], dfn[bot[x]]);\n        return;\n    &#125;;\n    top[1] = 1, DFS(1);\n    for (int x, v, la = 0; q--; ) &#123;\n        read(x), read(v), x ^= la;\n        g[x][0] -= a[x], g[x][0] += v, a[x] = v;\n        for (; top[x] != 1; ) &#123;\n            auto r = t[rt[top[x]]].u;\n            f[top[x]][0] = r[0][0], f[top[x]][1] = r[0][1];\n            g[fa[top[x]]][0] -= f[top[x]][0];\n            g[fa[top[x]]][1] -= std::max(f[top[x]][0], f[top[x]][1]);\n            add(rt[top[x]], dfn[x]);\n            r = t[rt[top[x]]].u;\n            f[top[x]][0] = r[0][0], f[top[x]][1] = r[0][1];\n            g[fa[top[x]]][0] += f[top[x]][0];\n            g[fa[top[x]]][1] += std::max(f[top[x]][0], f[top[x]][1]);\n            x = fa[top[x]];\n        &#125;\n        add(rt[1], dfn[x]);\n        auto r =  t[rt[1]].u;\n        f[1][0] = r[0][0], f[1][1] = r[0][1];\n        std::cout &lt;&lt; (la = std::max(f[1][0], f[1][1])) &lt;&lt; &#39;\\n&#39;;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"æ ‘ä¸Šè·¯å¾„é—®é¢˜æŸ“è‰²\">æ ‘ä¸Šè·¯å¾„é—®é¢˜ï¼šæŸ“è‰²</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P2486\" class=\"uri\">https://www.luogu.com.cn/problem/P2486</a></p>\n<p>GBT ä¸Šçš„<strong>è·¯å¾„é—®é¢˜</strong>ã€‚</p>\n<p>BSTï¼šé¦–å…ˆæš´åŠ›çˆ¬å±±åˆ° LCAï¼Œç»Ÿè®¡ä¸€è·¯ä¸Šçš„ç­”æ¡ˆï¼›ç„¶åè·³åˆ°å½“å‰ BST çš„æ ¹ã€‚ç”±äºæœ¬é¢˜æœ‰æ ‡è®°ï¼Œæ‰€ä»¥éœ€è¦åœ¨è·³çš„åŒæ—¶æƒ³åŠæ³•æŠŠæ ‡è®°é—®é¢˜è§£å†³ä¸€ä¸‹ã€‚</p>\n<p>çº¿æ®µæ ‘ï¼šæŠŠæ ‘å‰–çš„çº¿æ®µæ ‘ç•¥æ”¹ä¸€ä¸‹å°±è¿‡äº†ã€‚ä»ä¸Šä¸€è¡Œæ¨¡æ£±ä¸¤å¯çš„æè¿°å°±å¯ä»¥çœ‹å‡ºæ¥ BST å®ç°èµ·æ¥ä¸å¤ªè½»æ¾ï¼›è¿˜æ˜¯çº¿æ®µæ ‘æ›´è½®æ¤…å•Šï¼</p>\n<details>\n<p>è·‘å¾—æ²¡çº¯æ ‘å‰–å¿«ï¼Œå› ä¸ºæ•°æ®æ²¡æœ‰åˆ»æ„æ„é€ å¯¼è‡´æ ‘é«˜å¾ˆä½ï¼Œå†åŠ ä¸Šå¸¸æ•°çš„å½±å“å§ã€‚</p>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 1e5 + 5;\nconst int LEN = (1 &lt;&lt; 20);\nint nec(void) &#123;\n    static char buf[LEN], *p = buf, *e = buf;\n    if (p == e) &#123;\n        e = buf + fread(buf, 1, LEN, stdin);\n        if (e == buf) return EOF;\n        p = buf;\n    &#125;\n    return *p++;\n&#125;\nbool read(int &amp;x) &#123;\n    x = 0;\n    bool f = 0;\n    char ch = nec();\n    while (ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123;\n        if (ch == EOF) return 0;\n        if (ch == &#39;-&#39;) f = 1;\n        ch = nec();\n    &#125;\n    while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) &#123;\n        x = x * 10 + ch - &#39;0&#39;;\n        ch = nec();\n    &#125;\n    if (f) x = -x;\n    return 1;\n&#125;\nvoid read(char &amp;x) &#123;\n    for (x = nec(); x != &#39;C&#39; &amp;&amp; x != &#39;Q&#39;; x = nec());\n    return;\n&#125;\nvoid print(int x) &#123;\n    if (x &lt; 0)\n        putchar(&#39;-&#39;), x = -x;\n    if (x &gt;= 10) print(x / 10);\n    putchar(x % 10 + &#39;0&#39;);\n    return;\n&#125;\nvoid print(int x, char ch) &#123;\n    print(x), putchar(ch);\n    return;\n&#125;\nclass node &#123;\nprivate:\n    int lt, rt;\npublic:\n    int l, r, mid, lc, rc, u, d;\n    node(): u(-1) &#123;&#125;\n    inline int&amp; ls(void) &#123; return lt; &#125;\n    inline int&amp; rs(void) &#123; return rt; &#125;\n    node&amp; operator= (const node &amp;q) &#123;\n        lc = q.lc, rc = q.rc, u = q.u;\n        return *this;\n    &#125;\n    node operator+ (const node &amp;q) const &#123;\n        if (u == -1)\n            return q;\n        if (q.u == -1)\n            return *this;\n        node res;\n        res.lc = lc, res.rc = q.rc, res.u = u + q.u - (rc == q.lc);\n        return res;\n    &#125;\n    inline void swap(void) &#123;\n        if (~u)\n            lc ^= rc ^= lc ^= rc;\n        return;\n    &#125;\n&#125; t[maxn &lt;&lt; 2]; \nint tab[maxn], ls[maxn], a[maxn];\n#define lt t[p].ls()\n#define rt t[p].rs()\nvoid bld(int &amp;p, int l, int r) &#123;\n    static int tot = 0;\n    p = ++tot, t[p].l = l, t[p].r = r;\n    if (l == r) &#123;\n        t[p].u = 1;\n        t[p].lc = t[p].rc = a[tab[l]];\n        return;\n    &#125;\n    int s = 0, u = ls[tab[l]];\n    for (int i = l; i &lt;= r; ++i)\n        s += ls[tab[i]];\n    s &gt;&gt;= 1;\n    t[p].mid = r - 1;\n    for (int i = l + 1; i &lt; r; ++i) &#123;\n        u += ls[tab[i]];\n        if (u + ls[tab[i + 1]] &gt; s) &#123;\n            t[p].mid = i;\n            break;\n        &#125;\n    &#125;\n    bld(lt, l, t[p].mid), bld(rt, t[p].mid + 1, r);\n    t[p] = t[lt] + t[rt];\n    return;\n&#125;\nvoid pushdown(int p) &#123;\n    if (t[p].d) &#123;\n        t[lt].d = t[lt].lc = t[lt].rc = t[rt].d = t[rt].lc = t[rt].rc = t[p].d;\n        t[lt].u = t[rt].u = 1;\n        t[p].d = 0;\n    &#125;\n    return;\n&#125;\nvoid add(int p, int l, int r, int v) &#123;\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r) &#123;\n        t[p].u = 1;\n        t[p].lc = t[p].rc = t[p].d = v;\n        return;\n    &#125;\n    pushdown(p);\n    if (l &lt;= t[p].mid)\n        add(lt, l, r, v);\n    if (r &gt; t[p].mid)\n        add(rt, l, r, v);\n    t[p] = t[lt] + t[rt];\n    return;\n&#125;\nnode ask(int p, int l, int r) &#123;\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r)\n        return t[p];\n    pushdown(p);\n    if (r &lt;= t[p].mid)\n        return ask(lt, l, r);\n    if (l &gt; t[p].mid)\n        return ask(rt, l, r);\n    return ask(lt, l, r) + ask(rt, l, r);\n&#125;\n#undef lt\n#undef rt\nint main() &#123;\n#ifdef ONLINE_JUDGE\n#else\n    std::freopen(&quot;paint17.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, q;\n    read(n), read(q);\n    std::vector&lt;int&gt; rt(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        read(a[i]);\n    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);\n    for (int i = 1, x, y; i &lt; n; ++i) &#123;\n        read(x), read(y);\n        g[x].push_back(y), g[y].push_back(x);\n    &#125;\n    std::vector&lt;int&gt; siz(n + 1), son(n + 1), fa(n + 1), dep(n + 1);\n    std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;\n        siz[x] = 1;\n        for (auto i : g[x])\n            if (i != fa[x]) &#123;\n                dep[i] = dep[x] + 1;\n                fa[i] = x, DFS(i);\n                siz[x] += siz[i];\n                if (siz[i] &gt; siz[son[x]])\n                    son[x] = i;\n            &#125;\n        return;\n    &#125;;\n    DFS(1);\n    std::vector&lt;std::array&lt;int, 2&gt; &gt; f(n + 1);\n    std::vector&lt;int&gt; top(n + 1), bot(n + 1), dfn(n + 1);\n    DFS = [&amp;](int x) &#123;\n        static int now = 0;\n        dfn[x] = ++now, tab[now] = x, ls[x] = 1;\n        if (son[x]) &#123;\n            top[son[x]] = top[x], DFS(son[x]);\n            bot[x] = bot[son[x]];\n        &#125;\n        else\n            bot[x] = x;\n        for (auto i : g[x])\n            if (i != son[x] &amp;&amp; i != fa[x]) &#123;\n                top[i] = i;\n                DFS(i);\n                ls[x] += siz[i];\n            &#125;\n        if (x == top[x])\n            bld(rt[x], dfn[x], dfn[bot[x]]);\n        return;\n    &#125;;\n    top[1] = 1, DFS(1);\n    for (char op; q--; ) &#123;\n        read(op);\n        if (op == &#39;C&#39;) &#123;\n            int x, y, c;\n            read(x), read(y), read(c);\n            for (; top[x] != top[y]; x = fa[top[x]]) &#123;\n                if (dep[top[x]] &lt; dep[top[y]])\n                    std::swap(x, y);\n                add(rt[top[x]], dfn[top[x]], dfn[x], c);\n            &#125;\n            if (dep[x] &gt; dep[y])\n                std::swap(x, y);\n            add(rt[top[x]], dfn[x], dfn[y], c);\n        &#125;\n        else &#123;\n            int x, y;\n            read(x), read(y);\n            node res1, res2;\n            for (; top[x] != top[y]; )\n                if (dep[top[x]] &lt; dep[top[y]]) &#123;\n                    res2 = ask(rt[top[y]], dfn[top[y]], dfn[y]) + res2;\n                    y = fa[top[y]];\n                &#125;\n                else &#123;\n                    res1 = ask(rt[top[x]], dfn[top[x]], dfn[x]) + res1;\n                    x = fa[top[x]];\n                &#125;\n            if (dep[x] &gt; dep[y])\n                res1 = ask(rt[top[y]], dfn[y], dfn[x]) + res1;\n            else\n                res2 = ask(rt[top[x]], dfn[x], dfn[y]) + res2;\n            res1.swap();\n            print((res1 + res2).u, &#39;\\n&#39;);\n        &#125;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"æ ‘ä¸Šè·¯å¾„æŸ¥è¯¢\">æ ‘ä¸Šè·¯å¾„æŸ¥è¯¢ï¼Ÿ</h3>\n<p>åšé¢˜çš„æ—¶å€™å¯ä»¥æ„Ÿå—åˆ°ï¼Œè·¯å¾„è¯¢é—®çš„å­˜åœ¨å¾ˆè¯¡å¼‚ï¼Œå› ä¸ºåªéœ€è¦ä¸€æ¡é“¾çš„æ“ä½œï¼Œæ›´åå‘é“¾ä¸Š DDP è€Œéæ ‘ä¸Šçš„ï¼›<strong>è½»å„¿å­çš„ä¿¡æ¯æ˜¯ä¸ç”¨ç»´æŠ¤çš„</strong>ï¼Œå½¢å¼ä¸Šæ›´åƒæ ‘å‰–ï¼ˆDSï¼‰ï¼›å½“æˆé“¾ä¸Šçš„ DDP å°±å¯ä»¥è§£å†³äº†ã€‚</p>\n<p>å¯ä»¥ç”¨å€å¢ç»´æŠ¤ DDPï¼ˆä¸ç”¨è€ƒè™‘è½»é‡å„¿å­ï¼Œåªç”¨ç»´æŠ¤çˆ¶å­å…³ç³»ï¼Œè¿›ä¸€æ­¥å‘åºåˆ— DDP é è¿‘ï¼‰ï¼Œå°±ä¸ç”¨æ‰“ GBT äº†ï¼Œå¸¸æ•°ä¹Ÿä¼šå°ä¸€äº›ã€‚</p>\n<hr />\n<h2 id=\"ä¹ é¢˜\">ä¹ é¢˜</h2>\n<p>GBT å°±ç»Ÿä¸€ç”¨çº¿æ®µæ ‘äº†ã€‚DDP ä¹Ÿå°±å¯ä»¥é¡ºå¸¦ç”¨ GBT ä¼˜åŒ–äº†ã€‚</p>\n<hr />\n<h3 id=\"e---çŒ«æˆ–ç‹—-cats-or-dogs\">E - çŒ«æˆ–ç‹— / Cats or Dogs</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P9597\" class=\"uri\">https://www.luogu.com.cn/problem/P9597</a></p>\n<p>è®¾ <span class=\"math inline\">\\(f_{u,0/1}\\)</span> è¡¨ç¤ºä»æ ¹ä¸Šé¢œè‰²ä¸º <span class=\"math inline\">\\(0/1\\)</span> æ—¶çš„æœ€å°æ–­è¾¹æ•°ï¼Œæ˜¾ç„¶æ— è‰²å¯ä»¥è§†ä½œä»»é€‰ä¸€ä¸ªé¢œè‰²ã€‚é‚£ä¹ˆæœ‰ï¼š</p>\n<p><span class=\"math display\">\\[\nf_{u,a}=\\sum\\limits_v\\min\\limits_{b\\in\\{0,1\\}}\\{f_{v,b}+[a\\ne b]\\}\n\\]</span></p>\n<p>ç›´æ¥æŠŠè½»å„¿å­çš„é¡¹æå‡ºæ¥ï¼Œè®° <span class=\"math inline\">\\(g_{u,0/1}\\)</span> è¡¨ç¤º <span class=\"math inline\">\\(f_{u,0/1}\\)</span> å¯¹åº”çš„è½»å„¿å­è´¡çŒ®å³å¯ã€‚</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 1e5 + 5;\nconst int inf = 0x3f3f3f3f;\nstruct mat &#123;\n    int a[2][2];\n    int* operator[] (const int q) &#123; \n        return a[q];\n    &#125;\n    mat operator* (mat &amp;q) const &#123;\n        mat res;\n        res[0][0] = res[0][1] = res[1][0] = res[1][1] = inf;\n        for (int i = 0; i &lt; 2; ++i)\n            for (int k = 0; k &lt; 2; ++k)\n                for (int j = 0; j &lt; 2; ++j)\n                    res[i][k] = std::min(res[i][k], a[i][j] + q[j][k]);\n        return res;\n    &#125;\n    mat&amp; operator*= (mat &amp;q) &#123;\n        return *this = *this * q;\n    &#125;\n&#125; p[maxn];\nstruct &#123; int lc, rc, l, r, mid; mat u; &#125; t[maxn &lt;&lt; 2]; \nint ls[maxn], tab[maxn], g[maxn][2], rt[maxn], top[maxn], dfn[maxn], fa[maxn];\nstd::vector&lt;int&gt; a;\n#define lt t[p].lc\n#define rt t[p].rc\nvoid bld(int &amp;p, int l, int r) &#123;\n    static int tot = 0;\n    p = ++tot, t[p].l = l, t[p].r = r;\n    if (l == r) &#123;\n        t[p].u[0][1] = t[p].u[1][0] = 1;\n        return;\n    &#125;\n    int s = 0, u = ls[tab[l]];\n    for (int i = l; i &lt;= r; ++i)\n        s += ls[tab[i]];\n    s &gt;&gt;= 1;\n    t[p].mid = r - 1;\n    for (int i = l + 1; i &lt; r; ++i) &#123;\n        u += ls[tab[i]];\n        if (u + ls[tab[i + 1]] &gt; s) &#123;\n            t[p].mid = i;\n            break;\n        &#125;\n    &#125;\n    bld(lt, l, t[p].mid), bld(rt, t[p].mid + 1, r);\n    t[p].u = t[rt].u * t[lt].u;\n    return;\n&#125;\nvoid add(int p, int x) &#123;\n    if (t[p].l == t[p].r) &#123;\n        int u = tab[x], g0 = (a[u] == 1 ? inf : g[u][0]), g1 = (a[u] == 0 ? inf : g[u][1]);\n        t[p].u[0][0] = g0, t[p].u[0][1] = g1 + 1;\n        t[p].u[1][0] = g0 + 1, t[p].u[1][1] = g1;\n        return;\n    &#125;\n    if (x &lt;= t[p].mid)\n        add(lt, x);\n    else\n        add(rt, x);\n    t[p].u = t[rt].u * t[lt].u;\n    return;\n&#125;\n#undef lt\n#undef rt\nvoid initialize(int n, std::vector&lt;int&gt; A, std::vector&lt;int&gt; B) &#123;\n    a.assign(n + 1, -1);\n    std::vector&lt;std::vector&lt;int&gt; &gt; g1(n + 1);\n    for (int i = 0; i &lt; n - 1; ++i)\n        g1[A[i]].push_back(B[i]), g1[B[i]].push_back(A[i]);\n    std::vector&lt;int&gt; siz(n + 1), son(n + 1);\n    std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;\n        siz[x] = 1;\n        for (auto i : g1[x])\n            if (i != fa[x]) &#123;\n                fa[i] = x, DFS(i);\n                siz[x] += siz[i];\n                if (siz[i] &gt; siz[son[x]])\n                    son[x] = i;\n            &#125;\n        return;\n    &#125;;\n    DFS(1);\n    std::vector&lt;int&gt; bot(n + 1);\n    DFS = [&amp;](int x) &#123;\n        static int now = 0;\n        dfn[x] = ++now, tab[now] = x, ls[x] = 1;\n        if (son[x]) &#123;\n            top[son[x]] = top[x], DFS(son[x]);\n            bot[x] = bot[son[x]];\n            for (auto i : g1[x])\n                if (i != son[x] &amp;&amp; i != fa[x]) &#123;\n                    top[i] = i, DFS(i);\n                    ls[x] += siz[i];\n                &#125;\n        &#125;\n        else\n            bot[x] = x;\n        if (x == top[x])\n            bld(rt[x], dfn[x], dfn[bot[x]]);\n        return;\n    &#125;;\n    top[1] = 1, DFS(1);\n    return;\n&#125;\nint upd(int x) &#123;\n    for (; top[x] != 1; ) &#123;\n        int faa = fa[top[x]];\n        auto &amp;id = t[rt[top[x]]].u;\n        int f0 = std::min(id[0][0], id[1][0]), f1 = std::min(id[0][1], id[1][1]);\n        g[faa][0] -= std::min(f0, f1 + 1);\n        g[faa][1] -= std::min(f0 + 1, f1);\n        add(rt[top[x]], dfn[x]);\n        f0 = std::min(id[0][0], id[1][0]), f1 = std::min(id[0][1], id[1][1]);\n        // printf(&quot;%d: f0 = %d, f1 = %d\\n&quot;, top[x], f0, f1);\n        g[faa][0] += std::min(f0, f1 + 1);\n        g[faa][1] += std::min(f0 + 1, f1);\n        x = faa;\n    &#125;\n    add(rt[1], dfn[x]);\n    auto &amp;id = t[rt[1]].u;\n    int f0 = std::min(id[0][0], id[1][0]), f1 = std::min(id[0][1], id[1][1]);\n    // printf(&quot;%d: f0 = %d, f1 = %d\\n&quot;, 1, f0, f1);\n    return std::min(f0, f1);\n&#125;\nint cat(int x) &#123;\n    a[x] = 0;\n    return upd(x);\n&#125;\nint dog(int x) &#123;\n    a[x] = 1;\n    return upd(x);\n&#125;\nint neighbor(int x) &#123;\n    a[x] = -1;\n    return upd(x);\n&#125;\n#ifndef ONLINE_JUDGE\nint main() &#123;\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;int&gt; A(n - 1), B(n - 1);\n    for (int i = 0; i &lt; n - 1; ++i)\n        std::cin &gt;&gt; A[i] &gt;&gt; B[i];\n    initialize(n, A, B);\n    int q;\n    std::cin &gt;&gt; q;\n    for (int op, x; q--; ) &#123;\n        std::cin &gt;&gt; op &gt;&gt; x;\n        std::cout &lt;&lt; (op == 1 ? cat(x) : (op == 2 ? dog(x) : neighbor(x))) &lt;&lt; &#39;\\n&#39;;\n    &#125;\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n    return 0;\n&#125;\n#endif</code></pre>\n</details>\n<hr />\n<h3 id=\"f---hash-on-tree\">F - Hash on Tree</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/AT_abc351_g\" class=\"uri\">https://www.luogu.com.cn/problem/AT_abc351_g</a></p>\n<p>è®° <span class=\"math inline\">\\(g_x\\)</span> ä¸ºè½»å„¿å­çš„å“ˆå¸Œå€¼ä¹‹ç§¯ï¼Œåˆ™ <span class=\"math inline\">\\(f_u=A_u+f_{son}\\cdot g_u\\)</span>ã€‚</p>\n<p>ç„¶åå¼€ä¸€ä¸ªå¸¸æ•°ç»´å³å¯ã€‚å¿«é€Ÿå¹‚çš„ log çœä¸æ‰ï¼Œæ‰€ä»¥æ˜¯åŒ log çš„ã€‚</p>\n<p>åˆå€¼å’Œä¿®æ”¹éƒ½æœ‰å¯èƒ½ä¸º <span class=\"math inline\">\\(0\\)</span>ï¼Œéœ€è¦ç»´æŠ¤å®é™…å“ˆå¸Œå€¼å’Œå»æ‰ <span class=\"math inline\">\\(0\\)</span> çš„å“ˆå¸Œå€¼ã€‚</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 1e6 + 5;\nconst int LEN = (1 &lt;&lt; 20);\nconst int mod = 998244353;\nint nec(void) &#123;\n    static char buf[LEN], *p = buf, *e = buf;\n    if (p == e) &#123;\n        e = buf + fread(buf, 1, LEN, stdin);\n        if (e == buf) return EOF;\n        p = buf;\n    &#125;\n    return *p++;\n&#125;\nbool read(int &amp;x) &#123;\n    x = 0;\n    bool f = 0;\n    char ch = nec();\n    while (ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123;\n        if (ch == EOF) return 0;\n        if (ch == &#39;-&#39;) f = 1;\n        ch = nec();\n    &#125;\n    while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) &#123;\n        x = x * 10 + ch - &#39;0&#39;;\n        ch = nec();\n    &#125;\n    if (f) x = -x;\n    return 1;\n&#125;\nvoid print(int x) &#123;\n    if (x &lt; 0)\n        putchar(&#39;-&#39;), x = -x;\n    if (x &gt;= 10) print(x / 10);\n    putchar(x % 10 + &#39;0&#39;);\n    return;\n&#125;\nvoid print(int x, char ch) &#123;\n    print(x), putchar(ch);\n    return;\n&#125;\nstruct mat &#123;\n    int n, m;\n    long long a[2][2];\n    long long* operator[] (const int q) &#123;\n        return a[q];\n    &#125;\n    mat operator* (mat &amp;q) const &#123;\n        mat res;\n        res.n = n, res.m = q.m;\n        res[0][0] = res[0][1] = res[1][0] = res[1][1] = 0ll;\n        for (int i = 0; i &lt; n; ++i)\n            for (int k = 0; k &lt; q.m; ++k) &#123;\n                for (int j = 0; j &lt; m; ++j)\n                    res[i][k] += a[i][j] * q[j][k];\n                res[i][k] %= mod;\n            &#125;\n        return res;\n    &#125;\n    mat&amp; operator*= (mat &amp;q) &#123;\n        return *this = *this * q;\n    &#125;\n&#125;;\nstruct &#123; int lc, rc, l, r, mid; mat u; &#125; t[maxn &lt;&lt; 2]; \nlong long g[maxn];\nint tab[maxn], ls[maxn], a[maxn];\n#define lt t[p].lc\n#define rt t[p].rc\nvoid bld(int &amp;p, int l, int r) &#123;\n    static int tot = 0;\n    p = ++tot, t[p].l = l, t[p].r = r;\n    if (l == r) &#123;\n        int u = tab[l];\n        t[p].u.n = t[p].u.m = 2;\n        t[p].u[0][0] = g[u];\n        t[p].u[0][1] = 0ll;\n        t[p].u[1][0] = a[u];\n        t[p].u[1][1] = 1ll;\n        return;\n    &#125;\n    int s = 0, u = ls[tab[l]];\n    for (int i = l; i &lt;= r; ++i)\n        s += ls[tab[i]];\n    s &gt;&gt;= 1;\n    t[p].mid = r - 1;\n    for (int i = l + 1; i &lt; r; ++i) &#123;\n        u += ls[tab[i]];\n        if (u + ls[tab[i + 1]] &gt; s) &#123;\n            t[p].mid = i;\n            break;\n        &#125;\n    &#125;\n    bld(lt, l, t[p].mid), bld(rt, t[p].mid + 1, r);\n    t[p].u = t[rt].u * t[lt].u;\n    return;\n&#125;\nvoid add(int p, int x) &#123;\n    if (t[p].l == t[p].r) &#123;\n        int u = tab[x];\n        t[p].u[0][0] = g[u];\n        t[p].u[1][0] = a[u];\n        return;\n    &#125;\n    if (x &lt;= t[p].mid)\n        add(lt, x);\n    else\n        add(rt, x);\n    t[p].u = t[rt].u * t[lt].u;\n    return;\n&#125;\n#undef lt\n#undef rt\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, q;\n    read(n), read(q);\n    std::vector&lt;int&gt; rt(n + 1);\n    std::vector&lt;std::vector&lt;int&gt; &gt; g1(n + 1);\n    for (int i = 2, x; i &lt;= n; ++i) &#123;\n        read(x);\n        g1[i].push_back(x), g1[x].push_back(i);\n    &#125;\n    for (int i = 1; i &lt;= n; ++i)\n        read(a[i]);\n    std::vector&lt;int&gt; siz(n + 1), son(n + 1), fa(n + 1);\n    std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;\n        siz[x] = 1;\n        for (auto i : g1[x])\n            if (i != fa[x]) &#123;\n                fa[i] = x, DFS(i);\n                siz[x] += siz[i];\n                if (siz[i] &gt; siz[son[x]])\n                    son[x] = i;\n            &#125;\n        return;\n    &#125;;\n    DFS(1);\n    std::vector&lt;long long&gt; f(n + 1);\n    std::vector&lt;int&gt; top(n + 1), bot(n + 1), dfn(n + 1), la(n + 1), cnt(n + 1);\n    DFS = [&amp;](int x) &#123;\n        static int now = 0;\n        dfn[x] = ++now, tab[now] = x, ls[x] = 1;\n        if (son[x]) &#123;\n            top[son[x]] = top[x], DFS(son[x]);\n            bot[x] = bot[son[x]];\n            g[x] = 1ll;\n            for (auto i : g1[x])\n                if (i != son[x] &amp;&amp; i != fa[x]) &#123;\n                    top[i] = i, DFS(i);\n                    ls[x] += siz[i];\n                    if (f[i] == 0ll)\n                        ++cnt[x];\n                    else\n                        (la[x] *= f[i]) %= mod;\n                    (g[x] *= f[i]) %= mod;\n                &#125;\n            f[x] = (a[x] + g[x] * f[son[x]]) % mod;\n        &#125;\n        else\n            f[x] = a[x], bot[x] = x;\n        // printf(&quot;f[%d] = %lld\\n&quot;, x, f[x]);\n        if (x == top[x])\n            bld(rt[x], dfn[x], dfn[bot[x]]);\n        return;\n    &#125;;\n    top[1] = 1, DFS(1);\n    mat init;\n    init.n = 1, init.m = 2;\n    init[0][0] = 0ll, init[0][1] = 1ll;\n    auto qkp = [&amp;](long long x, int y) &#123;\n        auto res(1ll);\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    auto inv = [&amp;](int x) &#123;\n        return qkp(x, mod - 2);\n    &#125;;\n    for (int x, v; q--; ) &#123;\n        read(x), read(v);\n        a[x] = v;\n        for (; top[x] != 1; ) &#123;\n            int faa = fa[top[x]];\n            auto &amp;id = t[rt[top[x]]].u;\n            int f = (init * id)[0][0];\n            if (f == 0) &#123;\n                if (--cnt[faa] == 0)\n                    g[faa] = la[faa];\n            &#125;\n            else &#123;\n                f = inv(f);\n                (g[faa] *= f) %= mod;\n                (la[faa] *= f) %= mod;\n            &#125;\n            add(rt[top[x]], dfn[x]);\n            f = (init * id)[0][0];\n            if (f == 0) &#123;\n                if (cnt[faa]++ == 0)\n                    la[faa] = g[faa];\n                g[faa] = 0ll;\n            &#125;\n            else &#123;\n                (g[faa] *= f) %= mod;\n                (la[faa] *= f) %= mod;\n            &#125;\n            x = faa;\n        &#125;\n        add(rt[1], dfn[x]);\n        auto &amp;id = t[rt[1]].u;\n        int f = (init * id)[0][0];\n        std::cout &lt;&lt; f &lt;&lt; &#39;\\n&#39;;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"g---è€ƒè¯•-2\">G - è€ƒè¯• 2</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P10626\" class=\"uri\">https://www.luogu.com.cn/problem/P10626</a></p>\n<p>è¿ç®—å‡æ˜¯çº¿æ€§çš„ï¼Œå®¹æ˜“æƒ³åˆ°ã€æŒ‰ä½ã€ç»´æŠ¤ï¼Œå³åªç»´æŠ¤æŸä¸ªç‰¹å®šç‚¹å€¼ã€‚å¦‚æœå°†è¯¢é—®ç¦»çº¿ä¸‹æ¥æ’åºï¼Œæ¯ä¸ªå‡½æ•°çš„ç‚¹å€¼åªä¼šå˜åŒ– <span class=\"math inline\">\\(O(1)\\)</span> æ¬¡ã€‚</p>\n<p>å»ºå‡ºç¬¦å·äºŒå‰æ ‘ï¼Œè¿›è¡Œ DDP å³å¯ã€‚å…·ä½“åœ°ï¼Œä»¤ <span class=\"math inline\">\\(f_u\\)</span> è¡¨ç¤ºåœ¨è¿ç®— <span class=\"math inline\">\\(u\\)</span> å¤„çš„ç­”æ¡ˆï¼Œè®¡ç®— <span class=\"math inline\">\\(g_u\\)</span> ä¸ºè½»å„¿å­çš„ç­”æ¡ˆï¼ŒæŒ‰ç…§ <span class=\"math inline\">\\(u\\)</span> å¤„çš„ç¬¦å·å†™çŸ©é˜µå³å¯ã€‚å¶å­ä¸æ˜¯ä¸€æ¬¡è¿ç®—ï¼Œåº”è¯¥ç›´æ¥å¡«å…¥ç‚¹å€¼ï¼ˆæ³¨æ„çº¿æ®µæ ‘ä¸Šçš„å¶å­ä¸ä¸€å®šæ˜¯åŸæ ‘ä¸Šçš„å¶å­ï¼‰ã€‚</p>\n<p>å»ºæ ‘å’ŒçŸ©é˜µæ›´æ–°æœ‰ç‚¹å²ï¼Œé€‚å½“å°è£…ä¸€ä¸‹æ„Ÿè§‰ä¼šå¥½ä¸€ç‚¹</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 1e6 + 5;\nconst char mp[] = &quot;x!&amp;|^&quot;;\nconst int LEN = (1 &lt;&lt; 20);\n#define nec getchar\ninline bool read(int &amp;x) &#123;\n    x = 0;\n    bool f = 0;\n    char ch = nec();\n    while (ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123;\n        if (ch == EOF) return 0;\n        if (ch == &#39;-&#39;) f = 1;\n        ch = nec();\n    &#125;\n    while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) &#123;\n        x = x * 10 + ch - &#39;0&#39;;\n        ch = nec();\n    &#125;\n    if (f) x = -x;\n    return 1;\n&#125;\nvoid print(int x) &#123;\n    if (x &lt; 0)\n        putchar(&#39;-&#39;), x = -x;\n    if (x &gt;= 10) print(x / 10);\n    putchar(x % 10 + &#39;0&#39;);\n    return;\n&#125;\nvoid print(int x, char ch) &#123;\n    print(x), putchar(ch);\n    return;\n&#125;\nstruct mat &#123;\n    int n, m;\n    int a[2][2];\n    int* operator[] (const int q) &#123;\n        return a[q];\n    &#125;\n    inline mat operator* (mat &amp;q) const &#123;\n        mat res;\n        res.n = n, res.m = q.m;\n        res[0][0] = res[0][1] = res[1][0] = res[1][1] = 0ll;\n        for (int i = 0; i &lt; n; ++i)\n            for (int k = 0; k &lt; q.m; ++k)\n                for (int j = 0; j &lt; m; ++j)\n                    res[i][k] += a[i][j] * q[j][k];\n        return res;\n    &#125;\n    mat&amp; operator*= (mat &amp;q) &#123;\n        return *this = *this * q;\n    &#125;\n&#125;;\nstruct &#123; int lc, rc, l, r, mid; mat u; &#125; t[maxn &lt;&lt; 2]; \nint g1[maxn][2];\nint g[maxn], ty[maxn];\nint tab[maxn], ls[maxn], lim[maxn];\n#define lt t[p].lc\n#define rt t[p].rc\nvoid fillmat(mat &amp;a, int op, int g) &#123;\n    if (op == 0) &#123;\n        a.n = 1, a.m = 2;\n        a[0][!g] = 0, a[0][g] = 1;\n        return;\n    &#125;\n    a.n = 2, a.m = 2;\n    switch (op) &#123;\n    case 1: // !\n        a[0][0] = 0, a[0][1] = 1;\n        a[1][0] = 1, a[1][1] = 0;\n        break;\n    case 2: // &amp;\n        a[0][0] = 1, a[0][1] = 0;\n        a[1][0] = !g, a[1][1] = g;\n        break;\n    case 3: // |\n        a[0][0] = !g, a[0][1] = g;\n        a[1][0] = 0, a[1][1] = 1;\n        break;\n    case 4: // ^\n        a[0][0] = !g, a[0][1] = g;\n        a[1][0] = g, a[1][1] = !g;\n        break;\n    default:\n        assert(0);\n    &#125;\n    return;\n&#125;\nvoid bld(int &amp;p, int l, int r) &#123;\n    static int tot = 0;\n    p = ++tot, t[p].l = l, t[p].r = r;\n    if (l == r) &#123;\n        fillmat(t[p].u, ty[tab[l]], g[tab[l]]);\n        return;\n    &#125;\n    int s = 0, u = ls[tab[l]];\n    for (int i = l; i &lt;= r; ++i)\n        s += ls[tab[i]];\n    s &gt;&gt;= 1;\n    t[p].mid = r - 1;\n    for (int i = l + 1; i &lt; r; ++i) &#123;\n        u += ls[tab[i]];\n        if (u + ls[tab[i + 1]] &gt; s) &#123;\n            t[p].mid = i;\n            break;\n        &#125;\n    &#125;\n    bld(lt, l, t[p].mid), bld(rt, t[p].mid + 1, r);\n    t[p].u = t[rt].u * t[lt].u;\n    return;\n&#125;\nvoid add(int p, int x) &#123;\n    if (t[p].l == t[p].r) &#123;\n        fillmat(t[p].u, ty[tab[t[p].l]], g[tab[t[p].l]]);\n        return;\n    &#125;\n    if (x &lt;= t[p].mid)\n        add(lt, x);\n    else\n        add(rt, x);\n    t[p].u = t[rt].u * t[lt].u;\n    return;\n&#125;\n#undef lt\n#undef rt\nint main() &#123;\n#ifndef ONLINE_JUDGE\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n = 0, q, p;\n    read(q), read(q);\n    &#123;\n        std::string s;\n        std::cin &gt;&gt; s;\n        std::stringstream in(s);\n        std::stack&lt;char&gt; op;\n        std::stack&lt;int&gt; id;\n        auto trans = [&amp;](char t) &#123;\n            switch (t) &#123;\n            case &#39;!&#39;:\n                return 1;\n            case &#39;&amp;&#39;:\n                return 2;\n            case &#39;|&#39;:\n                return 3;\n            case &#39;^&#39;:\n                return 4;\n            &#125;\n            assert(0);\n            return -1;\n        &#125;;\n        auto calcNot = [&amp;](void) &#123;\n            for (; !op.empty() &amp;&amp; op.top() == &#39;!&#39;; ) &#123;\n                ty[++n] = trans(op.top());\n                g1[n][0] = id.top(), id.pop(), id.push(n);\n                op.pop();\n            &#125;\n            return;\n        &#125;;\n        auto opt = [&amp;](void) &#123;\n            ty[++n] = trans(op.top());\n            g1[n][0] = id.top(), id.pop();\n            g1[n][1] = id.top(), id.pop();\n            id.push(n), op.pop();\n            return;\n        &#125;;\n        for (char t; in &gt;&gt; t; )\n            if (t == &#39;[&#39;) &#123;\n                int x;\n                in &gt;&gt; x, in &gt;&gt; t;\n                lim[++n] = x - 1;\n                id.push(n), calcNot();\n            &#125;\n            else if (t == &#39;(&#39;)\n                op.push(t);\n            else if (t == &#39;)&#39;) &#123;\n                for (; op.top() != &#39;(&#39;; opt());\n                op.pop(), calcNot();\n            &#125;\n            else if (t == &#39;&amp;&#39;)\n                op.push(t);\n            else if (t == &#39;^&#39;) &#123;\n                for (; !op.empty() &amp;&amp; op.top() == &#39;&amp;&#39;; opt());\n                op.push(t);\n            &#125;\n            else if (t == &#39;|&#39;) &#123;\n                for (; !op.empty() &amp;&amp; (op.top() == &#39;&amp;&#39; || op.top() == &#39;^&#39;); opt());\n                op.push(t);\n            &#125;\n            else &#123;\n                assert(t == &#39;!&#39;);\n                op.push(t);\n            &#125;\n        for (; !op.empty(); opt());\n        p = id.top();\n    &#125;\n    std::vector&lt;int&gt; rt(n + 1);\n    std::vector&lt;int&gt; siz(n + 1), son(n + 1), fa(n + 1);\n    std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;\n        siz[x] = 1;\n        for (auto i : g1[x])\n            if (i != 0) &#123;\n                fa[i] = x, DFS(i);\n                siz[x] += siz[i];\n                if (siz[i] &gt; siz[son[x]])\n                    son[x] = i;\n            &#125;\n        return;\n    &#125;;\n    DFS(p);\n    std::vector&lt;long long&gt; f(n + 1);\n    std::vector&lt;int&gt; top(n + 1), bot(n + 1), dfn(n + 1);\n    DFS = [&amp;](int x) &#123;\n        static int now = 0;\n        dfn[x] = ++now, tab[now] = x, ls[x] = 1;\n        if (son[x]) &#123;\n            top[son[x]] = top[x], DFS(son[x]);\n            bot[x] = bot[son[x]];\n            for (auto i : g1[x])\n                if (i != son[x] &amp;&amp; i != 0) &#123;\n                    top[i] = i, DFS(i);\n                    ls[x] += siz[i], g[x] = f[i];\n                &#125;\n            switch (ty[x]) &#123;\n            case 1:\n                f[x] = !f[son[x]];\n                break;\n            case 2:\n                f[x] = g[x] &amp; f[son[x]];\n                break;\n            case 3:\n                f[x] = g[x] | f[son[x]];\n                break;\n            case 4:\n                f[x] = g[x] ^ f[son[x]];\n                break;\n            default:\n                assert(0);\n                break;\n            &#125;\n        &#125;\n        else\n            assert(!ty[x]), f[x] = g[x] = 0, bot[x] = x;\n        if (x == top[x])\n            bld(rt[x], dfn[x], dfn[bot[x]]);\n        return;\n    &#125;;\n    top[p] = p, DFS(p);\n    std::vector&lt;int&gt; a(q + 1), res(q + 1);\n    for (int i = 1; i &lt;= q; ++i)\n        read(a[i]);\n    std::vector&lt;int&gt; qid(q), nid;\n    for (int i = 1; i &lt;= n; ++i)\n        if (ty[i] == 0)\n            nid.push_back(i);\n    std::iota(qid.begin(), qid.end(), 1);\n    std::sort(qid.begin(), qid.end(), [&amp;](int x, int y) &#123; return a[x] &lt; a[y]; &#125;);\n    std::sort(nid.begin(), nid.end(), [&amp;](int x, int y) &#123; return lim[x] &gt; lim[y]; &#125;);\n    for (auto i : qid) &#123;\n        for (; !nid.empty() &amp;&amp; lim[nid.back()] &lt; a[i]; ) &#123;\n            int x = nid.back();\n            nid.pop_back();\n            g[x] = 1;\n            for (; top[x] != p; ) &#123;\n                add(rt[top[x]], dfn[x]);\n                g[fa[top[x]]] = t[rt[top[x]]].u[0][1];\n                x = fa[top[x]];\n            &#125;\n            add(rt[p], dfn[x]);\n        &#125;\n        res[i] = t[rt[p]].u[0][1];\n    &#125;\n    for (int i = 1; i &lt;= q; ++i)\n        if (res[i])\n            std::cout &lt;&lt; &quot;True\\n&quot;;\n        else\n            std::cout &lt;&lt; &quot;False\\n&quot;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n",
            "tags": [
                "çº¿æ®µæ ‘",
                "æ ‘é“¾å‰–åˆ†",
                "DDP"
            ]
        }
    ]
}