{
    "version": "https://jsonfeed.org/version/1",
    "title": "null • All posts by \"ddp\" tag",
    "description": "",
    "home_page_url": "https://xsc062.netlify.app",
    "items": [
        {
            "id": "https://xsc062.netlify.app/20250814/",
            "url": "https://xsc062.netlify.app/20250814/",
            "title": "DDP 与 GBT 练习",
            "date_published": "2025-08-14T09:08:21.000Z",
            "content_html": "<p>线段树是对的（存疑）</p>\n<span id=\"more\"></span>\n<hr />\n<h2 id=\"a---数据传输\">A - 数据传输</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P8820\" class=\"uri\">https://www.luogu.com.cn/problem/P8820</a></p>\n<p>我在上一篇文章中提到了 <a href=\"/20250812/#树上路径查询\">DDP &amp; 路径查询问题</a>，在这个题中就有体现。</p>\n<p>设 <span class=\"math inline\">\\(f_{u,0/1/2}\\)</span> 表示数据保存在 <span class=\"math inline\">\\(u\\)</span> 往下数 <span class=\"math inline\">\\(0/1/2\\)</span> 个点处的最小代价，手玩容易发现 <span class=\"math inline\">\\(k=3\\)</span> 时<strong>最优路径可能会往某个 <span class=\"math inline\">\\(x\\)</span> 或 <span class=\"math inline\">\\(fa\\)</span> 处的最小代价儿子处绕一圈来避免这个 <span class=\"math inline\">\\(x\\)</span> 或 <span class=\"math inline\">\\(fa\\)</span> 的代价</strong>。但该值是定值，问题还是纯路径问题，就可以 DDP 了。</p>\n<figure>\n<img src=\"image.png\" alt=\"共两种可能性（任意一个箭头长度不为 3 时绕一圈一定不比直接走更优）\" /><figcaption>共两种可能性（任意一个箭头长度不为 <span class=\"math inline\">\\(3\\)</span> 时绕一圈一定不比直接走更优）</figcaption>\n</figure>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nstruct mat &#123;\n    long long a[3][3];\n    long long* operator[] (const int q) &#123;\n        return a[q];\n    &#125;\n    mat() &#123;\n        memset(a, 0x3f, sizeof (a));\n        return;\n    &#125;\n    mat(int flag) &#123;\n        memset(a, 0x3f, sizeof (a));\n        a[0][0] = a[1][1] = a[2][2] = 0ll;\n        return;\n    &#125;\n    mat operator* (mat &amp;q) const &#123;\n        mat res;\n        for (int i = 0; i &lt; 3; ++i)\n            for (int k = 0; k &lt; 3; ++k)\n                for (int j = 0; j &lt; 3; ++j)\n                    res[i][k] = std::min(res[i][k], a[i][j] + q[j][k]);\n        return res;\n    &#125;\n    mat&amp; operator*= (mat &amp;q) &#123;\n        return *this = *this * q;\n    &#125;\n&#125;;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, q, k;\n    std::cin &gt;&gt; n &gt;&gt; q &gt;&gt; k;\n    std::vector&lt;int&gt; a(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i];\n    std::vector&lt;int&gt; mx(n + 1, 0x3f3f3f3f);\n    std::vector&lt;std::vector&lt;int&gt; &gt; g1(n + 1);\n    for (int i = 1, x, y; i &lt; n; ++i) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y;\n        mx[x] = std::min(mx[x], a[y]);\n        mx[y] = std::min(mx[y], a[x]);\n        g1[x].push_back(y), g1[y].push_back(x);\n    &#125;\n    std::vector&lt;int&gt; dep(n + 1);\n    std::vector&lt;std::array&lt;int, 18&gt; &gt; f(n + 1);\n    std::vector&lt;std::array&lt;mat, 18&gt; &gt; u(n + 1), d(n + 1);\n    u[0][0] = d[0][0] = mat(1);\n    std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;\n        for (auto i : g1[x])\n            if (i != f[x][0]) &#123;\n                f[i][0] = x;\n                &#123;\n                    mat s;\n                    s[0][0] = a[x];\n                    if (k &gt;= 2) &#123;\n                        s[0][1] = 0;\n                        s[1][0] = a[x];\n                    &#125;\n                    if (k &gt;= 3) &#123;\n                        s[1][2] = 0;\n                        s[2][0] = a[x];\n                        s[1][1] = mx[x];\n                        s[2][2] = mx[i];\n                    &#125;\n                    u[i][0] = s; \n                    s[0][0] = a[i];\n                    if (k &gt;= 2)\n                        s[1][0] = a[i];\n                    if (k &gt;= 3) &#123;\n                        s[2][0] = a[i];\n                        s[1][1] = mx[i];\n                        s[2][2] = mx[x];\n                    &#125;\n                    d[i][0] = s; \n                &#125;\n                for (int j = 1; j &lt; 18; ++j) &#123;\n                    f[i][j] = f[f[i][j - 1]][j - 1];\n                    u[i][j] = u[i][j - 1] * u[f[i][j - 1]][j - 1];\n                    d[i][j] = d[f[i][j - 1]][j - 1] * d[i][j - 1];\n                &#125;\n                dep[i] = dep[x] + 1;\n                DFS(i);\n            &#125;\n        return;\n    &#125;;\n    dep[1] = 1, DFS(1);\n    for (int x, y; q--; ) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y;\n        long long res = a[x];\n        mat r1(1), r2(1);\n        if (dep[x] &gt; dep[y]) &#123;\n            for (int i = 17; ~i; --i)\n                if (dep[f[x][i]] &gt;= dep[y]) &#123;\n                    r1 = r1 * u[x][i];\n                    x = f[x][i];\n                &#125;\n        &#125;\n        else if (dep[y] &gt; dep[x]) &#123;\n            for (int i = 17; ~i; --i)\n                if (dep[f[y][i]] &gt;= dep[x]) &#123;\n                    r2 = d[y][i] * r2;\n                    y = f[y][i];\n                &#125;\n        &#125;\n        if (x != y) &#123;\n            for (int i = 17; ~i; --i)\n                if (f[x][i] != f[y][i]) &#123;\n                    r1 = r1 * u[x][i];\n                    r2 = d[y][i] * r2;\n                    x = f[x][i], y = f[y][i];\n                &#125;\n            r1 = r1 * u[x][0], r2 = d[y][0] * r2;\n        &#125;\n        std::cout &lt;&lt; res + (r1 * r2)[0][0] &lt;&lt; &#39;\\n&#39;;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"b---the-silk-road-with-robots\">B - The Silk Road … with Robots!</h2>\n<p><a href=\"https://qoj.ac/problem/10410\" class=\"uri\">https://qoj.ac/problem/10410</a></p>\n<blockquote>\n<p>题意：初始有一个长为 <span class=\"math inline\">\\(10^8\\)</span> 的空数轴，给定 <span class=\"math inline\">\\(n\\)</span> 次操作，每次操作在数轴上的一个空位放一个 A 类点或 B 类点。每个 A 类点有其<strong>价值</strong>。</p>\n<p>任意在数轴上移动这些 B 类点，<strong>总价值</strong>为所有被经过的 A 类点的<strong>价值</strong> - B 类点移动总路程。每次操作后输出最大<strong>总价值</strong>，重复经过的 A 类点只计一次。</p>\n<p><span class=\"math inline\">\\(n\\le 2\\times 10^5\\)</span>。</p>\n</blockquote>\n<p>这个题确实可以带来很多启发，我一开始直接设 <span class=\"math inline\">\\(f_j\\)</span> 为状态，这样对于暴力是可做的，但是会出现一些需要被区间修改的系数，比如<strong>前缀和</strong>。最好设计状态，让转移的时候只需要用到常数、差分值等修改次数很少的系数。</p>\n<p>设 <span class=\"math inline\">\\(f_{i,0/1/2/3}\\)</span> 分别表示：</p>\n<p><img src=\"image-1.png\" /></p>\n<p>那么可以写出转移式：</p>\n<p><span class=\"math display\">\\[\nf_{i,0}=\\max(mx+a_i+x_i,f_{i-1,0}+a_i)\\\\\nf_{i,1}=\\max(mx+a_i+2x_i,f_{i-1,1}+a_i)\\\\\nf_{i,2}=f_{i-1,2}-(x_i-x_{i-1}) + a_i\\\\\nf_{i,3}=f_{i-1,3}-2(x_i-x_{i-1})+a_i\n\\]</span></p>\n<p>其中 <span class=\"math inline\">\\(mx\\)</span> 为 <span class=\"math inline\">\\(f_{i,2/3}\\)</span> 的前缀最大值。在 B 类点处可以让 <span class=\"math inline\">\\(f_{2/3}\\)</span> 继承对应的 <span class=\"math inline\">\\(f_{0/1}\\)</span>，新开一维记录 <span class=\"math inline\">\\(mx\\)</span> 就可以维护矩乘了。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int lim = 1e8;\nconst int maxn = 5e6 + 5;\nconst long long inf = 1e12;\nstruct mat &#123;\n    long long a[5][5];\n    mat() &#123;&#125;\n    long long* operator[] (const int q) &#123;\n        return a[q];\n    &#125;\n    mat operator* (mat &amp;q) const &#123;\n        mat res;\n        for (int i = 0; i &lt; 5; ++i)\n            for (int k = 0; k &lt; 5; ++k) &#123;\n                auto u(-inf);\n                for (int j = 0; j &lt; 5; ++j)\n                    u = std::max(u, a[i][j] + q[j][k]);\n                res[i][k] = u;\n            &#125;\n        return res;\n    &#125;\n    mat&amp; operator*= (mat &amp;q) &#123;\n        return *this = *this * q;\n    &#125;\n&#125;;\nstruct &#123; int l, r; mat u; &#125; t[maxn];\n#define lt t[p].l\n#define rt t[p].r\nvoid add(int &amp;p, int l, int r, int x, mat &amp;v) &#123;\n    static int tot = 0;\n    if (!p)\n        p = ++tot;\n    if (l == r) &#123;\n        t[p].u = v;\n        return;\n    &#125;\n    int mid = (l + r) &gt;&gt; 1;\n    if (x &lt;= mid)\n        add(lt, l, mid, x, v);\n    else\n        add(rt, mid + 1, r, x, v);\n    t[p].u = t[lt].u * t[rt].u;\n    return;\n&#125;\n#undef lt\n#undef rt\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    &#123;\n        mat &amp;u = t[0].u;\n        for (int i = 0; i &lt; 5; ++i)\n            for (int j = 0; j &lt; 5; ++j)\n                u[i][j] = -inf;\n        u[0][0] = u[1][1] = u[2][2] = u[3][3] = u[4][4] = 0ll;\n    &#125;\n    int m, rt = 0;\n    std::cin &gt;&gt; m;\n    std::vector&lt;mat&gt; a(m + 1);\n    std::vector&lt;int&gt; ty(m + 1);\n    std::set&lt;std::pair&lt;long long, int&gt; &gt; s;\n    s.emplace(-inf, 0);\n    for (int op, x, i = 1; i &lt;= m; ++i) &#123;\n        std::cin &gt;&gt; op &gt;&gt; x;\n        auto &amp;u = a[i];\n        for (int i = 0; i &lt; 5; ++i)\n            for (int j = 0; j &lt; 5; ++j)\n                u[i][j] = -inf;\n        auto p = --s.lower_bound(std::make_pair(x, 0)), q = s.upper_bound(std::make_pair(x, 0));\n        int v = 0;\n        if (op == 2)\n            std::cin &gt;&gt; v;\n        u[0][0] = v, u[1][1] = v, u[4][0] = v + x, u[4][1] = v + 2 * x;\n        if (op == 1) &#123;\n            ty[i] = 0;\n            u[4][2] = u[4][1] - 2 * x;\n            u[1][2] = u[1][1] - 2 * x;\n            u[4][3] = u[4][0] - x;\n            u[0][3] = u[0][0] - x;\n        &#125;\n        else &#123;\n            ty[i] = 1;\n            u[2][2] = v - (x - p-&gt;first);\n            u[3][3] = v - 2 * (x - p-&gt;first);\n        &#125;\n        u[4][4] = std::max(&#123; 0ll, u[4][2], u[4][3] &#125;);\n        u[1][4] = u[1][2], u[0][4] = u[0][3], u[2][4] = u[2][2], u[3][4] = u[3][3];\n        add(rt, 0, lim, x, u);\n        if (q != s.end() &amp;&amp; ty[q-&gt;second] == 1) &#123;\n            auto &amp;u = a[q-&gt;second];\n            u[2][2] -= p-&gt;first, u[2][2] += x;\n            u[3][3] -= 2 * p-&gt;first, u[3][3] += 2 * x;\n            u[2][4] = u[2][2], u[3][4] = u[3][3];\n            add(rt, 0, lim, q-&gt;first, a[q-&gt;second]);\n        &#125;\n        s.emplace(x, i);\n        std::cout &lt;&lt; t[1].u[4][4] &lt;&lt; &#39;\\n&#39;;\n        // for (int i = 0; i &lt; 5; ++i, puts(&quot;&quot;))\n        //     for (int j = 0; j &lt; 5; ++j)\n        //         if (t[1].u[i][j] &lt; -200)\n        //             printf(&quot;  x &quot;);\n        //         else\n        //             printf(&quot;%3lld &quot;, t[1].u[i][j]);\n        // puts(&quot;=============&quot;);\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"c---密码箱\">C - 密码箱</h2>\n<p><a href=\"/20250818/#c---%E5%AF%86%E7%A0%81%E7%AE%B1\">link</a>;</p>\n",
            "tags": [
                "线段树",
                "DDP"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20250812/",
            "url": "https://xsc062.netlify.app/20250812/",
            "title": "DDP 与全局平衡二叉树",
            "date_published": "2025-08-12T00:16:52.000Z",
            "content_html": "<p>其实动态 DP 不是动态树 DP 的同义词</p>\n<span id=\"more\"></span>\n<hr />\n<h2 id=\"动态-dp\">动态 DP</h2>\n<p>对于转移只依赖前几项的 DP，可以放进矩阵。</p>\n<p>默认转移范围是 <span class=\"math inline\">\\([1,n]\\)</span>；如果我们需要改变求解范围，发现如果能获取转移矩阵的乘积就很快了。考虑存下来。</p>\n<p>如果需要单点修改，等价于修改其所在矩阵，则想要尽可能少地修改存储的答案，考虑使用线段树优化该过程。</p>\n<h3 id=\"例海报\">例：海报</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P9790\" class=\"uri\">https://www.luogu.com.cn/problem/P9790</a></p>\n<p>容易列出暴力 DP 式：令 <span class=\"math inline\">\\(f_{i,j}\\)</span> 表示枚举到 <span class=\"math inline\">\\(i\\)</span> 时，包含 <span class=\"math inline\">\\(i\\)</span> 在内已经有 <span class=\"math inline\">\\(j\\)</span> 个连续的人举起海报，易得：</p>\n<p><span class=\"math display\">\\[\nf_{i,0}=\\max(f_{i-1,0},f_{i-1,1},f_{i-1,2},f_{i-1,3})\\\\\nf_{i,j}=f_{i-1,j-1}+a_i \\forall 1\\le j\\le 3\n\\]</span></p>\n<p>发现满足 + / max <strong>矩阵乘法</strong> 的形式；想到用线段树保存每段区间对应矩阵（对应性质：结合律），每次修改 / 查询就能在 <span class=\"math inline\">\\(O(\\log n)\\)</span> 之内完成。</p>\n<p>原问题是环形的，可以再加一维 <span class=\"math inline\">\\(k\\)</span> 表示钦定选了前 <span class=\"math inline\">\\(k\\)</span> 个且不选第 <span class=\"math inline\">\\(k+1\\)</span> 个时的答案。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 4e4 + 5;\nconst long long inf = 1e18;\nstruct mat &#123;\n    int n, m;\n    long long a[4][4];\n    mat() &#123;&#125;\n    mat(int n1, int m1): n(n1), m(m1) &#123;\n        for (int i = 0; i &lt; n; ++i)\n            for (int j = 0; j &lt; m; ++j)\n                a[i][j] = -inf;\n        return;\n    &#125;\n    long long* operator[] (const int q) &#123;\n        return a[q];\n    &#125;\n    mat operator* (mat &amp;q) const &#123;\n        mat res(n, q.m);\n        for (int i = 0; i &lt; n; ++i)\n            for (int k = 0; k &lt; q.m; ++k)\n                for (int j = 0; j &lt; m; ++j)\n                    res[i][k] = std::max(res[i][k], a[i][j] + q[j][k]);\n        return res;\n    &#125;\n    mat&amp; operator*= (mat &amp;q) &#123;\n        return *this = *this * q;\n    &#125;\n&#125;;\nstruct &#123; int l, r; mat u[4]; &#125; t[maxn &lt;&lt; 2];\nint a[maxn];\n#define lt (p &lt;&lt; 1)\n#define rt (lt | 1)\n#define c t[p].u[i]\nvoid bld(int p, int l, int r) &#123;\n    t[p].l = l, t[p].r = r;\n    if (l == r) &#123;\n        for (int i = 0; i &lt;= 3; ++i) &#123;\n            c = mat(4, 4);\n            if (l &gt; i + 1) &#123;\n                c[0][0] = c[1][0] = c[2][0] = c[3][0] = 0;\n                c[0][1] = c[1][2] = c[2][3] = a[l];\n            &#125;\n            else if (l == i + 1)\n                c[0][0] = c[1][0] = c[2][0] = c[3][0] = 0;\n            else\n                c[0][1] = c[1][2] = c[2][3] = a[l];\n        &#125;\n        return;\n    &#125;\n    int mid = (l + r) &gt;&gt; 1;\n    bld(lt, l, mid), bld(rt, mid + 1, r);\n    for (int i = 0; i &lt;= 3; ++i)\n        t[p].u[i] = t[lt].u[i] * t[rt].u[i];\n    return;\n&#125;\nvoid add(int p, int x, int v) &#123;\n    if (t[p].l == t[p].r) &#123;\n        for (int i = 0; i &lt;= 3; ++i)\n            if (t[p].l != i + 1) \n                c[0][1] = c[1][2] = c[2][3] = v;\n        return;\n    &#125;\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (x &lt;= mid)\n        add(lt, x, v);\n    else\n        add(rt, x, v);\n    for (int i = 0; i &lt;= 3; ++i)\n        t[p].u[i] = t[lt].u[i] * t[rt].u[i];\n    return;\n&#125;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i];\n    bld(1, 1, n);\n    auto calc = [&amp;](void) &#123;\n        mat f(1, 4);\n        f[0][0] = 0;\n        auto res = -inf;\n        for (int i = 0; i &lt;= 3; ++i) &#123;\n            auto r = (f * t[1].u[i]);\n            for (int j = 0; j &lt;= 3; ++j)\n                if (i + j &lt;= 3) &#123;\n                    res = std::max(res, r[0][j]);\n                    // printf(&quot;f[%d][%d] = %lld\\n&quot;, i, j, f[i][j]);\n                &#125;\n        &#125;\n        return res;\n    &#125;;\n    std::cout &lt;&lt; calc() &lt;&lt; &#39;\\n&#39;;\n    int q;\n    std::cin &gt;&gt; q;\n    for (int x, v; q--; ) &#123;\n        std::cin &gt;&gt; x &gt;&gt; v;\n        add(1, x, v);\n        std::cout &lt;&lt; calc() &lt;&lt; &#39;\\n&#39;;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<p>发现矩阵本身和 <span class=\"math inline\">\\(k\\)</span> 无关，还可以可以共用一个线段树上的信息，就可以只开一个线段树了。</p>\n<details>\n<p>我写这一版本的原因是 <code>maxn</code> 开大了导致 MLE，实际上四个线段树是没有任何空间压力的 😅</p>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 4e5 + 5;\nconst long long inf = 1e18;\nstruct mat &#123;\n    int n, m;\n    long long a[4][4];\n    mat() &#123;&#125;\n    mat(int n1, int m1): n(n1), m(m1) &#123;\n        for (int i = 0; i &lt; n; ++i)\n            for (int j = 0; j &lt; m; ++j)\n                a[i][j] = -inf;\n        return;\n    &#125;\n    long long* operator[] (const int q) &#123;\n        return a[q];\n    &#125;\n    mat operator* (mat q) const &#123;\n        mat res(n, q.m);\n        for (int i = 0; i &lt; n; ++i)\n            for (int k = 0; k &lt; q.m; ++k)\n                for (int j = 0; j &lt; m; ++j)\n                    res[i][k] = std::max(res[i][k], a[i][j] + q[j][k]);\n        return res;\n    &#125;\n    mat&amp; operator*= (mat &amp;q) &#123;\n        return *this = *this * q;\n    &#125;\n&#125;;\nstruct &#123; int l, r; mat u; &#125; t[maxn &lt;&lt; 2];\nint a[maxn];\n#define lt (p &lt;&lt; 1)\n#define rt (lt | 1)\nvoid bld(int p, int l, int r) &#123;\n    t[p].l = l, t[p].r = r;\n    if (l == r) &#123;\n        t[p].u = mat(4, 4);\n        t[p].u[0][0] = t[p].u[1][0] = t[p].u[2][0] = t[p].u[3][0] = 0;\n        t[p].u[0][1] = t[p].u[1][2] = t[p].u[2][3] = a[l];\n        return;\n    &#125;\n    int mid = (l + r) &gt;&gt; 1;\n    bld(lt, l, mid), bld(rt, mid + 1, r);\n    t[p].u = t[lt].u * t[rt].u;\n    return;\n&#125;\nvoid add(int p, int x, int v) &#123;\n    if (t[p].l == t[p].r) &#123;\n        t[p].u[0][1] = t[p].u[1][2] = t[p].u[2][3] = v;\n        return;\n    &#125;\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (x &lt;= mid)\n        add(lt, x, v);\n    else\n        add(rt, x, v);\n    t[p].u = t[lt].u * t[rt].u;\n    return;\n&#125;\nmat ask(int p, int l, int r) &#123;\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r)\n        return t[p].u;\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (r &lt;= mid)\n        return ask(lt, l, r);\n    if (l &gt; mid)\n        return ask(rt, l, r);\n    return ask(lt, l, r) * ask(rt, l, r);\n&#125;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i];\n    bld(1, 1, n);\n    auto calc = [&amp;](void) &#123;\n        mat f(1, 4);\n        f[0][0] = 0, f[0][1] = f[0][2] = f[0][3] = -inf;\n        auto r(f * ask(1, 2, n));\n        auto res(*std::max_element(r[0], r[0] + 4));\n        mat z(4, 4);\n        z[0][0] = z[1][0] = z[2][0] = z[3][0] = 0ll;\n        for (int i = 1; i &lt;= 3; ++i) &#123;\n            mat op(4, 4);\n            op[0][1] = op[1][2] = op[2][3] = a[i];\n            f *= op;\n            if (i + 2 &lt;= n)\n                r = f * z * ask(1, i + 2, n);\n            else\n                r = f * z;\n            res = std::max(res, *std::max_element(r[0], r[0] + 4 - i));\n        &#125;\n        return res;\n    &#125;;\n    std::cout &lt;&lt; calc() &lt;&lt; &#39;\\n&#39;;\n    int q;\n    std::cin &gt;&gt; q;\n    for (int x, v; q--; ) &#123;\n        std::cin &gt;&gt; x &gt;&gt; v, a[x] = v;\n        add(1, x, v);\n        std::cout &lt;&lt; calc() &lt;&lt; &#39;\\n&#39;;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"经典题gss3\">经典题：GSS3</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/SP1716\" class=\"uri\">https://www.luogu.com.cn/problem/SP1716</a></p>\n<p>怎么是子段和 😓</p>\n<p>同样列出能够矩阵乘法的 DP 式，发现限制在于至少要选一个数。设 <span class=\"math inline\">\\(f_{i}\\)</span> 表示选了 <span class=\"math inline\">\\(i\\)</span> 的最大值，<span class=\"math inline\">\\(g_i\\)</span> 表示历史最大值，则：</p>\n<p><span class=\"math display\">\\[\nf_i=\\max(f_{i-1}+a_i,0+a_i)\\\\\ng_i=\\max(g_{i-1}+0,f_{i-1}+a_i,0+a_i)\n\\]</span></p>\n<p>容易发现是一个 + / max 矩乘，线段树维护即可。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 4e5 + 5;\nconst long long inf = 1e18;\nstruct mat &#123;\n    int n, m;\n    long long a[3][3];\n    mat() &#123;&#125;\n    mat(int n1, int m1): n(n1), m(m1) &#123;\n        for (int i = 0; i &lt; n; ++i)\n            for (int j = 0; j &lt; m; ++j)\n                a[i][j] = -inf;\n        return;\n    &#125;\n    long long* operator[] (const int q) &#123;\n        return a[q];\n    &#125;\n    mat operator* (mat q) const &#123;\n        mat res(n, q.m);\n        for (int i = 0; i &lt; n; ++i)\n            for (int k = 0; k &lt; q.m; ++k)\n                for (int j = 0; j &lt; m; ++j)\n                    res[i][k] = std::max(res[i][k], a[i][j] + q[j][k]);\n        return res;\n    &#125;\n    mat&amp; operator*= (mat &amp;q) &#123;\n        return *this = *this * q;\n    &#125;\n&#125;;\nstruct &#123; int l, r; mat u; &#125; t[maxn &lt;&lt; 2]; \nint a[maxn];\n#define lt (p &lt;&lt; 1)\n#define rt (lt | 1)\nvoid bld(int p, int l, int r) &#123;\n    t[p].l = l, t[p].r = r;\n    if (l == r) &#123;\n        t[p].u = mat(3, 3);\n        t[p].u[0][0] = t[p].u[2][0] = a[l];\n        t[p].u[0][1] = a[l], t[p].u[1][1] = 0ll, t[p].u[2][1] = a[l];\n        t[p].u[2][2] = 0ll;\n        return;\n    &#125;\n    int mid = (l + r) &gt;&gt; 1;\n    bld(lt, l, mid), bld(rt, mid + 1, r);\n    t[p].u = t[lt].u * t[rt].u;\n    return;\n&#125;\nvoid add(int p, int x, int v) &#123;\n    if (t[p].l == t[p].r) &#123;\n        t[p].u[0][0] = t[p].u[2][0] = t[p].u[0][1] = t[p].u[2][1] = v;\n        return;\n    &#125;\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (x &lt;= mid)\n        add(lt, x, v);\n    else\n        add(rt, x, v);\n    t[p].u = t[lt].u * t[rt].u;\n    return;\n&#125;\nmat ask(int p, int l, int r) &#123;\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r)\n        return t[p].u;\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (r &lt;= mid)\n        return ask(lt, l, r);\n    if (l &gt; mid)\n        return ask(rt, l, r);\n    return ask(lt, l, r) * ask(rt, l, r);\n&#125;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i];\n    bld(1, 1, n);\n    auto calc = [&amp;](int l, int r) &#123;\n        mat f(1, 3);\n        f[0][2] = 0ll;\n        auto res(f * ask(1, l, r));\n        return res[0][1];\n    &#125;;\n    int q;\n    std::cin &gt;&gt; q;\n    for (int op; q--; ) &#123;\n        std::cin &gt;&gt; op;\n        if (op == 1) &#123;\n            int l, r;\n            std::cin &gt;&gt; l &gt;&gt; r;\n            std::cout &lt;&lt; calc(l, r) &lt;&lt; &#39;\\n&#39;;\n        &#125;\n        else &#123;\n            int x, v;\n            std::cin &gt;&gt; x &gt;&gt; v;\n            a[x] = v, add(1, x, v);\n        &#125;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"动态树-dp\">动态树 DP</h2>\n<p>把上述过程放到树上，很容易想到树剖 + 线段树。</p>\n<p>由于认为线段树上的矩乘只能进行从重儿子到父亲的转移，轻儿子的转移会被合并为一个新函数（同时是矩阵的系数），在跳重链的时候被单独更新。</p>\n<p>由于两个函数相互依赖，需要思考清楚更新的先后顺序。</p>\n<h3 id=\"模板动态-dp\">【模板】动态 DP</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P4719\" class=\"uri\">https://www.luogu.com.cn/problem/P4719</a></p>\n<p>令 <span class=\"math inline\">\\(f_{u,0/1}\\)</span> 表示在 <span class=\"math inline\">\\(u\\)</span> 上，选 / 不选 <span class=\"math inline\">\\(u\\)</span> 的最大价值。容易得出转移：</p>\n<p><span class=\"math display\">\\[\nf_{u,0}=\\sum\\max(f_{v,0},f_{v,1})\\\\\nf_{u,1}=a_i+\\sum f_{v,0}\n\\]</span></p>\n<p>把转移矩阵放到树剖上后，考虑更新，发现求和这一步很困难。解决方案是<strong>直接将求和用另一个函数代替</strong>。定义 <span class=\"math inline\">\\(g_{u,0}\\)</span> 表示取 <span class=\"math inline\">\\(u\\)</span>、不取 <span class=\"math inline\">\\(u\\)</span> 的所有轻儿子的答案，<span class=\"math inline\">\\(g_{u,1}\\)</span> 不取 <span class=\"math inline\">\\(u\\)</span>，轻儿子可选可不选的答案。</p>\n<p><span class=\"math inline\">\\(g\\)</span> 是可求的，且只需要在跳重链的时候更新 <span class=\"math inline\">\\(g\\)</span>。具体更新起来非常绞，因为 <span class=\"math inline\">\\(g\\)</span> 和 <span class=\"math inline\">\\(f\\)</span> 是相互依赖的，需要分清楚先后关系。</p>\n<p>首先 <span class=\"math inline\">\\(g_u\\)</span> 和 <span class=\"math inline\">\\(f_u\\)</span> 都会被更新；接着，重链上其它的 <span class=\"math inline\">\\(g\\)</span> 不会被影响，而链顶的 <span class=\"math inline\">\\(f\\)</span> 需要被新的 <span class=\"math inline\">\\(g_u\\)</span> 更新；由此链顶父亲的 <span class=\"math inline\">\\(g\\)</span> 被更新；依次类推。注意到对于一个链顶，其 <span class=\"math inline\">\\(f\\)</span> 值是整条重链的乘积，故需要记录链底。</p>\n<p>复杂度 <span class=\"math inline\">\\(O(q\\log ^2n)\\)</span>。注意很重要的一点是线段树内乘法应从右往左。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 1e5 + 5;\nconst int inf = 0x3f3f3f3f;\nstruct mat &#123;\n    int n, m, a[2][2];\n    mat() &#123;&#125;\n    mat(int n1, int m1): n(n1), m(m1) &#123;\n        for (int i = 0; i &lt; n; ++i)\n            for (int j = 0; j &lt; m; ++j)\n                a[i][j] = -inf;\n        return;\n    &#125;\n    int* operator[] (const int q) &#123;\n        return a[q];\n    &#125;\n    mat operator* (mat q) const &#123;\n        mat res(n, q.m);\n        for (int i = 0; i &lt; n; ++i)\n            for (int k = 0; k &lt; q.m; ++k)\n                for (int j = 0; j &lt; m; ++j)\n                    res[i][k] = std::max(res[i][k], a[i][j] + q[j][k]);\n        return res;\n    &#125;\n    mat&amp; operator*= (mat &amp;q) &#123;\n        return *this = *this * q;\n    &#125;\n&#125;;\nstruct &#123; int l, r; mat u; &#125; t[maxn &lt;&lt; 2]; \nint g[maxn][2], tab[maxn];\n#define lt (p &lt;&lt; 1)\n#define rt (lt | 1)\nvoid bld(int p, int l, int r) &#123;\n    t[p].l = l, t[p].r = r;\n    if (l == r) &#123;\n        int u = tab[l];\n        t[p].u = mat(2, 2);\n        t[p].u[0][0] = t[p].u[1][0] = g[u][1];\n        t[p].u[0][1] = g[u][0];\n        return;\n    &#125;\n    int mid = (l + r) &gt;&gt; 1;\n    bld(lt, l, mid), bld(rt, mid + 1, r);\n    t[p].u = t[rt].u * t[lt].u;\n    return;\n&#125;\nvoid add(int p, int x) &#123;\n    if (t[p].l == t[p].r) &#123;\n        int u = tab[x];\n        t[p].u[0][0] = t[p].u[1][0] = g[u][1];\n        t[p].u[0][1] = g[u][0];\n        return;\n    &#125;\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (x &lt;= mid)\n        add(lt, x);\n    else\n        add(rt, x);\n    t[p].u = t[rt].u * t[lt].u;\n    return;\n&#125;\nmat ask(int p, int l, int r) &#123;\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r)\n        return t[p].u;\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (r &lt;= mid)\n        return ask(lt, l, r);\n    if (l &gt; mid)\n        return ask(rt, l, r);\n    return ask(rt, l, r) * ask(lt, l, r);\n&#125;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, q;\n    std::cin &gt;&gt; n &gt;&gt; q;\n    std::vector&lt;int&gt; a(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i];\n    std::vector&lt;std::vector&lt;int&gt; &gt; g1(n + 1);\n    for (int i = 1, x, y; i &lt; n; ++i) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y;\n        g1[x].push_back(y), g1[y].push_back(x);\n    &#125;\n    std::vector&lt;int&gt; siz(n + 1), son(n + 1), fa(n + 1);\n    std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;\n        siz[x] = 1;\n        for (auto i : g1[x])\n            if (i != fa[x]) &#123;\n                fa[i] = x, DFS(i);\n                siz[x] += siz[i];\n                if (siz[i] &gt; siz[son[x]])\n                    son[x] = i;\n            &#125;\n        return;\n    &#125;;\n    DFS(1);\n    std::vector&lt;std::array&lt;int, 2&gt; &gt; f(n + 1);\n    std::vector&lt;int&gt; top(n + 1), bot(n + 1), dfn(n + 1);\n    DFS = [&amp;](int x) &#123;\n        static int now = 0;\n        dfn[x] = ++now, tab[now] = x;\n        if (son[x]) &#123;\n            top[son[x]] = top[x], DFS(son[x]);\n            bot[x] = bot[son[x]];\n            g[x][0] = a[x];\n            for (auto i : g1[x])\n                if (i != son[x] &amp;&amp; i != fa[x]) &#123;\n                    top[i] = i, DFS(i);\n                    g[x][0] += f[i][0];\n                    g[x][1] += std::max(f[i][1], f[i][0]);\n                &#125;\n            f[x][0] = g[x][1] + std::max(f[son[x]][0], f[son[x]][1]);\n            f[x][1] = g[x][0] + f[son[x]][0];\n        &#125;\n        else\n            f[x][1] = g[x][0] = a[x], bot[x] = x;\n        return;\n    &#125;;\n    top[1] = 1, DFS(1);\n    bld(1, 1, n);\n    for (int x, v; q--; ) &#123;\n        std::cin &gt;&gt; x &gt;&gt; v;\n        g[x][0] -= a[x], g[x][0] += v, a[x] = v;\n        for (; top[x] != 1; ) &#123;\n            auto r = ask(1, dfn[top[x]], dfn[bot[x]]);\n            f[top[x]][0] = r[0][0], f[top[x]][1] = r[0][1];\n            g[fa[top[x]]][0] -= f[top[x]][0];\n            g[fa[top[x]]][1] -= std::max(f[top[x]][0], f[top[x]][1]);\n            add(1, dfn[x]);\n            r = ask(1, dfn[top[x]], dfn[bot[x]]);\n            f[top[x]][0] = r[0][0], f[top[x]][1] = r[0][1];\n            g[fa[top[x]]][0] += f[top[x]][0];\n            g[fa[top[x]]][1] += std::max(f[top[x]][0], f[top[x]][1]);\n            x = fa[top[x]];\n        &#125;\n        add(1, dfn[x]);\n        auto r = ask(1, dfn[1], dfn[bot[1]]);\n        f[1][0] = r[0][0], f[1][1] = r[0][1];\n        std::cout &lt;&lt; std::max(f[1][0], f[1][1]) &lt;&lt; &#39;\\n&#39;;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"全局平衡二叉树\">全局平衡二叉树</h2>\n<p>回顾树剖（重剖），功能在于解决路径问题，单次操作能够在 <span class=\"math inline\">\\(O(\\log^2 n)\\)</span> 的时间内完成。这个功能可以被<strong>全局平衡二叉树（GBT）</strong>上位替代。GBT 能够在单次 <span class=\"math inline\">\\(O(\\log n)\\)</span> 的复杂度内完成链操作、子树操作。<em><a href=\"QTREE解法的一些研究.pdf\">Yang Zhe - SPOJ375 QTREE 解法的一些研究</a> 中更为详细严谨地对 GBT 进行了说明，我传了份文件上来。</em></p>\n<p>考虑树剖能被卡的原因：每次线段树询问都会卡满 <span class=\"math inline\">\\(O(\\log n)\\)</span>，找一条卡得满 <span class=\"math inline\">\\(O(\\log n)\\)</span> 次跳重链次数的路径一直薅，就可以卡到 <span class=\"math inline\">\\(O(\\log^2 n)\\)</span>。</p>\n<p>在实现线段树时发现，对于<strong>路径操作</strong>和<strong>单点操作</strong>，树剖只需要维护同一条重链的信息，建一个大线段树会产生许多重链间的无效维护。故一种经典的树剖卡常技巧是对于每一条重链建出线段树。</p>\n<p>在本文中定义<strong>全局二叉树</strong>：将单个线段树按照在原树上重链顶的相对祖孙关系连边得到的模型。这里为了和<strong>全局平衡二叉树</strong>形成照应而命名，实际上模型并不是二叉树。容易发现<strong>修改某个点花费的操作次数和其在全局二叉树中的深度相同</strong>。</p>\n<p>考虑本方法理论上仍可卡到 <span class=\"math inline\">\\(O(\\log^2 n)\\)</span> 单次操作的原因，虽然单个线段树平衡，但<strong>全局二叉树</strong>并不平衡；能够构造数据使得树高达到 <span class=\"math inline\">\\(\\log^2 n\\)</span>。考虑使得全局二叉树平衡，即调整线段树结构使得任何一个点在全局二叉树上的左右儿子大小最接近。发现是易做的，只需在建线段树时移动左右儿子分割点使得两边子树大小均为全树的一半即可。</p>\n<p>法一：求出每个点的轻子树大小 <span class=\"math inline\">\\(ls_u=1+\\sum siz_v\\)</span>，作为加权在线段树上找 mid 就能满足全局平衡；证明可以见上面的论文。这里用线段树代替了 BST，常数很大。</p>\n<p>法二：用一个 BST 实现上述功能，需要满足：任意子树的根为子树的带权 mid；BST 的中序遍历为原重链。显然有：树高为 log 级别。这就决定了所有问题都可以通过暴力爬山解决。</p>\n<p>GBT 能够快速维护<strong>普通树剖操作</strong>和 <strong>DDP 信息</strong>。</p>\n<hr />\n<h3 id=\"维护-ddp模板动态-dp加强版\">维护 DDP：【模板】动态 DP（加强版）</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P4751\" class=\"uri\">https://www.luogu.com.cn/problem/P4751</a></p>\n<p>和未加强版类似，把所有线段树操作替换为 BST 即可。如果写得丑可能需要一些额外的卡常技巧。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 1e6 + 5;\nconst int inf = 0x3f3f3f3f;\nconst int LEN = (1 &lt;&lt; 20);\nint nec(void) &#123;\n    static char buf[LEN], *p = buf, *e = buf;\n    if (p == e) &#123;\n        e = buf + fread(buf, 1, LEN, stdin);\n        if (e == buf) return EOF;\n        p = buf;\n    &#125;\n    return *p++;\n&#125;\nbool read(int &amp;x) &#123;\n    x = 0;\n    bool f = 0;\n    char ch = nec();\n    while (ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123;\n        if (ch == EOF) return 0;\n        if (ch == &#39;-&#39;) f = 1;\n        ch = nec();\n    &#125;\n    while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) &#123;\n        x = x * 10 + ch - &#39;0&#39;;\n        ch = nec();\n    &#125;\n    if (f) x = -x;\n    return 1;\n&#125;\nvoid print(int x) &#123;\n    if (x &lt; 0)\n        putchar(&#39;-&#39;), x = -x;\n    if (x &gt;= 10) print(x / 10);\n    putchar(x % 10 + &#39;0&#39;);\n    return;\n&#125;\nvoid print(int x, char ch) &#123;\n    print(x), putchar(ch);\n    return;\n&#125;\nstruct mat &#123;\n    int a[2][2];\n    int* operator[] (const int q) &#123; \n        return a[q];\n    &#125;\n    mat operator* (mat &amp;q) const &#123;\n        mat res;\n        res[0][0] = res[0][1] = res[1][0] = res[1][1] = -inf;\n        for (int i = 0; i &lt; 2; ++i)\n            for (int k = 0; k &lt; 2; ++k)\n                for (int j = 0; j &lt; 2; ++j)\n                    res[i][k] = std::max(res[i][k], a[i][j] + q[j][k]);\n        return res;\n    &#125;\n    mat&amp; operator*= (mat &amp;q) &#123;\n        return *this = *this * q;\n    &#125;\n&#125;;\nstruct &#123; int lc, rc, fa; mat u; &#125; t[maxn]; \nint g[maxn][2], tab[maxn], ls[maxn];\nmat p[maxn];\nvoid pushup(int x) &#123;\n    t[x].u = t[t[x].rc].u * p[x] * t[t[x].lc].u;\n    return;\n&#125;\nvoid bld(int &amp;x, int l, int r) &#123;\n    if (l &gt; r)\n        return;\n    int s = 0, k = 0;\n    for (int i = l; i &lt;= r; ++i)\n        s += ls[tab[i]];\n    for (int i = l; i &lt;= r; ++i, k += ls[tab[i]])\n        if ((k + ls[tab[i]]) * 2 &gt; s) &#123;\n            x = tab[i];\n            bld(t[x].lc, l, i - 1), t[t[x].lc].fa = x;\n            bld(t[x].rc, i + 1, r), t[t[x].rc].fa = x;\n            pushup(x);\n            break;\n        &#125;\n    return;\n&#125;\n#undef lt\n#undef rt\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    t[0].u[0][0] = t[0].u[1][1] = 0, t[0].u[0][1] = t[0].u[1][0] = -inf;\n    int n, q;\n    read(n), read(q);\n    std::vector&lt;int&gt; a(n + 1), rt(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        read(a[i]);\n    std::vector&lt;std::vector&lt;int&gt; &gt; g1(n + 1);\n    for (int i = 1, x, y; i &lt; n; ++i) &#123;\n        read(x), read(y);\n        g1[x].push_back(y), g1[y].push_back(x);\n    &#125;\n    std::vector&lt;int&gt; son(n + 1), fa(n + 1), siz(n + 1);\n    std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;\n        siz[x] = 1;\n        for (auto i : g1[x])\n            if (i != fa[x]) &#123;\n                fa[i] = x, DFS(i);\n                siz[x] += siz[i];\n                if (siz[i] &gt; siz[son[x]])\n                    son[x] = i;\n            &#125;\n        return;\n    &#125;;\n    DFS(1);\n    std::vector&lt;std::array&lt;int, 2&gt; &gt; f(n + 1);\n    std::vector&lt;int&gt; top(n + 1), bot(n + 1), dfn(n + 1);\n    DFS = [&amp;](int x) &#123;\n        static int now = 0;\n        dfn[x] = ++now, tab[now] = x, ls[x] = 1;\n        if (son[x]) &#123;\n            top[son[x]] = top[x], DFS(son[x]);\n            bot[x] = bot[son[x]];\n            g[x][0] = a[x];\n            for (auto i : g1[x])\n                if (i != son[x] &amp;&amp; i != fa[x]) &#123;\n                    top[i] = i, DFS(i), t[rt[i]].fa = x;\n                    ls[x] += siz[i];\n                    g[x][0] += f[i][0];\n                    g[x][1] += std::max(f[i][1], f[i][0]);\n                &#125;\n            f[x][0] = g[x][1] + std::max(f[son[x]][0], f[son[x]][1]);\n            f[x][1] = g[x][0] + f[son[x]][0];\n        &#125;\n        else\n            f[x][1] = g[x][0] = a[x], bot[x] = x;\n        p[x][0][0] = p[x][1][0] = g[x][1];\n        p[x][0][1] = g[x][0], p[x][1][1] = -inf;\n        if (x == top[x])\n            bld(rt[x], dfn[x], dfn[bot[x]]);\n        return;\n    &#125;;\n    top[1] = 1, DFS(1);\n    for (int x, v, la = 0; q--; ) &#123;\n        read(x), read(v), x ^= la;\n        p[x][0][1] += v - a[x], a[x] = v;\n        for (; x; ) &#123;\n            int fa = t[x].fa;\n            if (fa &amp;&amp; x != t[fa].lc &amp;&amp; x != t[fa].rc) &#123;\n                int f0 = t[x].u[0][0], f1 = std::max(f0, t[x].u[0][1]);\n                pushup(x);\n                int F0 = t[x].u[0][0], F1 = std::max(F0, t[x].u[0][1]);\n                p[fa][0][0] += F1 - f1, p[fa][1][0] += F1 - f1;\n                p[fa][0][1] += F0 - f0;\n            &#125;\n            else\n                pushup(x);\n            x = fa;\n        &#125;\n        print(la = std::max(t[rt[1]].u[0][0], t[rt[1]].u[0][1]), &#39;\\n&#39;);\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<p>也给出一个线段树版本的</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 1e6 + 5;\nconst int inf = 0x3f3f3f3f;\nconst int LEN = (1 &lt;&lt; 20);\nint nec(void) &#123;\n    static char buf[LEN], *p = buf, *e = buf;\n    if (p == e) &#123;\n        e = buf + fread(buf, 1, LEN, stdin);\n        if (e == buf) return EOF;\n        p = buf;\n    &#125;\n    return *p++;\n&#125;\nbool read(int &amp;x) &#123;\n    x = 0;\n    bool f = 0;\n    char ch = nec();\n    while (ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123;\n        if (ch == EOF) return 0;\n        if (ch == &#39;-&#39;) f = 1;\n        ch = nec();\n    &#125;\n    while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) &#123;\n        x = x * 10 + ch - &#39;0&#39;;\n        ch = nec();\n    &#125;\n    if (f) x = -x;\n    return 1;\n&#125;\nvoid print(int x) &#123;\n    if (x &lt; 0)\n        putchar(&#39;-&#39;), x = -x;\n    if (x &gt;= 10) print(x / 10);\n    putchar(x % 10 + &#39;0&#39;);\n    return;\n&#125;\nvoid print(int x, char ch) &#123;\n    print(x), putchar(ch);\n    return;\n&#125;\nstruct mat &#123;\n    int a[2][2];\n    int* operator[] (const int q) &#123;\n        return a[q];\n    &#125;\n    mat operator* (mat q) const &#123;\n        mat res;\n        res[0][0] = res[0][1] = res[1][0] = res[1][1] = -inf;\n        for (int i = 0; i &lt; 2; ++i)\n            for (int k = 0; k &lt; 2; ++k)\n                for (int j = 0; j &lt; 2; ++j)\n                    res[i][k] = std::max(res[i][k], a[i][j] + q[j][k]);\n        return res;\n    &#125;\n    mat&amp; operator*= (mat &amp;q) &#123;\n        return *this = *this * q;\n    &#125;\n&#125;;\nstruct &#123; int lc, rc, l, r, mid; mat u; &#125; t[maxn &lt;&lt; 2]; \nint g[maxn][2], tab[maxn], ls[maxn];\n#define lt t[p].lc\n#define rt t[p].rc\nvoid bld(int &amp;p, int l, int r) &#123;\n    static int tot = 0;\n    p = ++tot, t[p].l = l, t[p].r = r;\n    if (l == r) &#123;\n        int u = tab[l];\n        t[p].u[0][0] = t[p].u[1][0] = g[u][1];\n        t[p].u[0][1] = g[u][0], t[p].u[1][1] = -inf;\n        return;\n    &#125;\n    int s = 0, u = ls[tab[l]];\n    for (int i = l; i &lt;= r; ++i)\n        s += ls[tab[i]];\n    s &gt;&gt;= 1;\n    t[p].mid = r - 1;\n    for (int i = l + 1; i &lt; r; ++i) &#123;\n        u += ls[tab[i]];\n        if (u + ls[tab[i + 1]] &gt; s) &#123;\n            t[p].mid = i;\n            break;\n        &#125;\n    &#125;\n    bld(lt, l, t[p].mid), bld(rt, t[p].mid + 1, r);\n    t[p].u = t[rt].u * t[lt].u;\n    return;\n&#125;\nvoid add(int p, int x) &#123;\n    if (t[p].l == t[p].r) &#123;\n        int u = tab[x];\n        t[p].u[0][0] = t[p].u[1][0] = g[u][1];\n        t[p].u[0][1] = g[u][0];\n        return;\n    &#125;\n    if (x &lt;= t[p].mid)\n        add(lt, x);\n    else\n        add(rt, x);\n    t[p].u = t[rt].u * t[lt].u;\n    return;\n&#125;\nmat ask(int p, int l, int r) &#123;\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r)\n        return t[p].u;\n    if (r &lt;= t[p].mid)\n        return ask(lt, l, r);\n    if (l &gt; t[p].mid)\n        return ask(rt, l, r);\n    return ask(rt, l, r) * ask(lt, l, r);\n&#125;\n#undef lt\n#undef rt\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, q;\n    read(n), read(q);\n    std::vector&lt;int&gt; a(n + 1), rt(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        read(a[i]);\n    std::vector&lt;std::vector&lt;int&gt; &gt; g1(n + 1);\n    for (int i = 1, x, y; i &lt; n; ++i) &#123;\n        read(x), read(y);\n        g1[x].push_back(y), g1[y].push_back(x);\n    &#125;\n    std::vector&lt;int&gt; siz(n + 1), son(n + 1), fa(n + 1);\n    std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;\n        siz[x] = 1;\n        for (auto i : g1[x])\n            if (i != fa[x]) &#123;\n                fa[i] = x, DFS(i);\n                siz[x] += siz[i];\n                if (siz[i] &gt; siz[son[x]])\n                    son[x] = i;\n            &#125;\n        return;\n    &#125;;\n    DFS(1);\n    std::vector&lt;std::array&lt;int, 2&gt; &gt; f(n + 1);\n    std::vector&lt;int&gt; top(n + 1), bot(n + 1), dfn(n + 1);\n    DFS = [&amp;](int x) &#123;\n        static int now = 0;\n        dfn[x] = ++now, tab[now] = x;\n        ls[x] = 1;\n        if (son[x]) &#123;\n            top[son[x]] = top[x], DFS(son[x]);\n            bot[x] = bot[son[x]];\n            g[x][0] = a[x];\n            for (auto i : g1[x])\n                if (i != son[x] &amp;&amp; i != fa[x]) &#123;\n                    top[i] = i, DFS(i);\n                    ls[x] += siz[i];\n                    g[x][0] += f[i][0];\n                    g[x][1] += std::max(f[i][1], f[i][0]);\n                &#125;\n            f[x][0] = g[x][1] + std::max(f[son[x]][0], f[son[x]][1]);\n            f[x][1] = g[x][0] + f[son[x]][0];\n        &#125;\n        else\n            f[x][1] = g[x][0] = a[x], bot[x] = x;\n        if (x == top[x])\n            bld(rt[x], dfn[x], dfn[bot[x]]);\n        return;\n    &#125;;\n    top[1] = 1, DFS(1);\n    for (int x, v, la = 0; q--; ) &#123;\n        read(x), read(v), x ^= la;\n        g[x][0] -= a[x], g[x][0] += v, a[x] = v;\n        for (; top[x] != 1; ) &#123;\n            auto r = t[rt[top[x]]].u;\n            f[top[x]][0] = r[0][0], f[top[x]][1] = r[0][1];\n            g[fa[top[x]]][0] -= f[top[x]][0];\n            g[fa[top[x]]][1] -= std::max(f[top[x]][0], f[top[x]][1]);\n            add(rt[top[x]], dfn[x]);\n            r = t[rt[top[x]]].u;\n            f[top[x]][0] = r[0][0], f[top[x]][1] = r[0][1];\n            g[fa[top[x]]][0] += f[top[x]][0];\n            g[fa[top[x]]][1] += std::max(f[top[x]][0], f[top[x]][1]);\n            x = fa[top[x]];\n        &#125;\n        add(rt[1], dfn[x]);\n        auto r =  t[rt[1]].u;\n        f[1][0] = r[0][0], f[1][1] = r[0][1];\n        std::cout &lt;&lt; (la = std::max(f[1][0], f[1][1])) &lt;&lt; &#39;\\n&#39;;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"树上路径问题染色\">树上路径问题：染色</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P2486\" class=\"uri\">https://www.luogu.com.cn/problem/P2486</a></p>\n<p>GBT 上的<strong>路径问题</strong>。</p>\n<p>BST：首先暴力爬山到 LCA，统计一路上的答案；然后跳到当前 BST 的根。由于本题有标记，所以需要在跳的同时想办法把标记问题解决一下。</p>\n<p>线段树：把树剖的线段树略改一下就过了。从上一行模棱两可的描述就可以看出来 BST 实现起来不太轻松；还是线段树更轮椅啊！</p>\n<details>\n<p>跑得没纯树剖快，因为数据没有刻意构造导致树高很低，再加上常数的影响吧。</p>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 1e5 + 5;\nconst int LEN = (1 &lt;&lt; 20);\nint nec(void) &#123;\n    static char buf[LEN], *p = buf, *e = buf;\n    if (p == e) &#123;\n        e = buf + fread(buf, 1, LEN, stdin);\n        if (e == buf) return EOF;\n        p = buf;\n    &#125;\n    return *p++;\n&#125;\nbool read(int &amp;x) &#123;\n    x = 0;\n    bool f = 0;\n    char ch = nec();\n    while (ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123;\n        if (ch == EOF) return 0;\n        if (ch == &#39;-&#39;) f = 1;\n        ch = nec();\n    &#125;\n    while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) &#123;\n        x = x * 10 + ch - &#39;0&#39;;\n        ch = nec();\n    &#125;\n    if (f) x = -x;\n    return 1;\n&#125;\nvoid read(char &amp;x) &#123;\n    for (x = nec(); x != &#39;C&#39; &amp;&amp; x != &#39;Q&#39;; x = nec());\n    return;\n&#125;\nvoid print(int x) &#123;\n    if (x &lt; 0)\n        putchar(&#39;-&#39;), x = -x;\n    if (x &gt;= 10) print(x / 10);\n    putchar(x % 10 + &#39;0&#39;);\n    return;\n&#125;\nvoid print(int x, char ch) &#123;\n    print(x), putchar(ch);\n    return;\n&#125;\nclass node &#123;\nprivate:\n    int lt, rt;\npublic:\n    int l, r, mid, lc, rc, u, d;\n    node(): u(-1) &#123;&#125;\n    inline int&amp; ls(void) &#123; return lt; &#125;\n    inline int&amp; rs(void) &#123; return rt; &#125;\n    node&amp; operator= (const node &amp;q) &#123;\n        lc = q.lc, rc = q.rc, u = q.u;\n        return *this;\n    &#125;\n    node operator+ (const node &amp;q) const &#123;\n        if (u == -1)\n            return q;\n        if (q.u == -1)\n            return *this;\n        node res;\n        res.lc = lc, res.rc = q.rc, res.u = u + q.u - (rc == q.lc);\n        return res;\n    &#125;\n    inline void swap(void) &#123;\n        if (~u)\n            lc ^= rc ^= lc ^= rc;\n        return;\n    &#125;\n&#125; t[maxn &lt;&lt; 2]; \nint tab[maxn], ls[maxn], a[maxn];\n#define lt t[p].ls()\n#define rt t[p].rs()\nvoid bld(int &amp;p, int l, int r) &#123;\n    static int tot = 0;\n    p = ++tot, t[p].l = l, t[p].r = r;\n    if (l == r) &#123;\n        t[p].u = 1;\n        t[p].lc = t[p].rc = a[tab[l]];\n        return;\n    &#125;\n    int s = 0, u = ls[tab[l]];\n    for (int i = l; i &lt;= r; ++i)\n        s += ls[tab[i]];\n    s &gt;&gt;= 1;\n    t[p].mid = r - 1;\n    for (int i = l + 1; i &lt; r; ++i) &#123;\n        u += ls[tab[i]];\n        if (u + ls[tab[i + 1]] &gt; s) &#123;\n            t[p].mid = i;\n            break;\n        &#125;\n    &#125;\n    bld(lt, l, t[p].mid), bld(rt, t[p].mid + 1, r);\n    t[p] = t[lt] + t[rt];\n    return;\n&#125;\nvoid pushdown(int p) &#123;\n    if (t[p].d) &#123;\n        t[lt].d = t[lt].lc = t[lt].rc = t[rt].d = t[rt].lc = t[rt].rc = t[p].d;\n        t[lt].u = t[rt].u = 1;\n        t[p].d = 0;\n    &#125;\n    return;\n&#125;\nvoid add(int p, int l, int r, int v) &#123;\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r) &#123;\n        t[p].u = 1;\n        t[p].lc = t[p].rc = t[p].d = v;\n        return;\n    &#125;\n    pushdown(p);\n    if (l &lt;= t[p].mid)\n        add(lt, l, r, v);\n    if (r &gt; t[p].mid)\n        add(rt, l, r, v);\n    t[p] = t[lt] + t[rt];\n    return;\n&#125;\nnode ask(int p, int l, int r) &#123;\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r)\n        return t[p];\n    pushdown(p);\n    if (r &lt;= t[p].mid)\n        return ask(lt, l, r);\n    if (l &gt; t[p].mid)\n        return ask(rt, l, r);\n    return ask(lt, l, r) + ask(rt, l, r);\n&#125;\n#undef lt\n#undef rt\nint main() &#123;\n#ifdef ONLINE_JUDGE\n#else\n    std::freopen(&quot;paint17.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, q;\n    read(n), read(q);\n    std::vector&lt;int&gt; rt(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        read(a[i]);\n    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);\n    for (int i = 1, x, y; i &lt; n; ++i) &#123;\n        read(x), read(y);\n        g[x].push_back(y), g[y].push_back(x);\n    &#125;\n    std::vector&lt;int&gt; siz(n + 1), son(n + 1), fa(n + 1), dep(n + 1);\n    std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;\n        siz[x] = 1;\n        for (auto i : g[x])\n            if (i != fa[x]) &#123;\n                dep[i] = dep[x] + 1;\n                fa[i] = x, DFS(i);\n                siz[x] += siz[i];\n                if (siz[i] &gt; siz[son[x]])\n                    son[x] = i;\n            &#125;\n        return;\n    &#125;;\n    DFS(1);\n    std::vector&lt;std::array&lt;int, 2&gt; &gt; f(n + 1);\n    std::vector&lt;int&gt; top(n + 1), bot(n + 1), dfn(n + 1);\n    DFS = [&amp;](int x) &#123;\n        static int now = 0;\n        dfn[x] = ++now, tab[now] = x, ls[x] = 1;\n        if (son[x]) &#123;\n            top[son[x]] = top[x], DFS(son[x]);\n            bot[x] = bot[son[x]];\n        &#125;\n        else\n            bot[x] = x;\n        for (auto i : g[x])\n            if (i != son[x] &amp;&amp; i != fa[x]) &#123;\n                top[i] = i;\n                DFS(i);\n                ls[x] += siz[i];\n            &#125;\n        if (x == top[x])\n            bld(rt[x], dfn[x], dfn[bot[x]]);\n        return;\n    &#125;;\n    top[1] = 1, DFS(1);\n    for (char op; q--; ) &#123;\n        read(op);\n        if (op == &#39;C&#39;) &#123;\n            int x, y, c;\n            read(x), read(y), read(c);\n            for (; top[x] != top[y]; x = fa[top[x]]) &#123;\n                if (dep[top[x]] &lt; dep[top[y]])\n                    std::swap(x, y);\n                add(rt[top[x]], dfn[top[x]], dfn[x], c);\n            &#125;\n            if (dep[x] &gt; dep[y])\n                std::swap(x, y);\n            add(rt[top[x]], dfn[x], dfn[y], c);\n        &#125;\n        else &#123;\n            int x, y;\n            read(x), read(y);\n            node res1, res2;\n            for (; top[x] != top[y]; )\n                if (dep[top[x]] &lt; dep[top[y]]) &#123;\n                    res2 = ask(rt[top[y]], dfn[top[y]], dfn[y]) + res2;\n                    y = fa[top[y]];\n                &#125;\n                else &#123;\n                    res1 = ask(rt[top[x]], dfn[top[x]], dfn[x]) + res1;\n                    x = fa[top[x]];\n                &#125;\n            if (dep[x] &gt; dep[y])\n                res1 = ask(rt[top[y]], dfn[y], dfn[x]) + res1;\n            else\n                res2 = ask(rt[top[x]], dfn[x], dfn[y]) + res2;\n            res1.swap();\n            print((res1 + res2).u, &#39;\\n&#39;);\n        &#125;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"树上路径查询\">树上路径查询？</h3>\n<p>做题的时候可以感受到，路径询问的存在很诡异，因为只需要一条链的操作，更偏向链上 DDP 而非树上的；<strong>轻儿子的信息是不用维护的</strong>，形式上更像树剖（DS）；当成链上的 DDP 就可以解决了。</p>\n<p>可以用倍增维护 DDP（不用考虑轻重儿子，只用维护父子关系，进一步向序列 DDP 靠近），就不用打 GBT 了，常数也会小一些。</p>\n<hr />\n<h2 id=\"习题\">习题</h2>\n<p>GBT 就统一用线段树了。DDP 也就可以顺带用 GBT 优化了。</p>\n<hr />\n<h3 id=\"e---猫或狗-cats-or-dogs\">E - 猫或狗 / Cats or Dogs</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P9597\" class=\"uri\">https://www.luogu.com.cn/problem/P9597</a></p>\n<p>设 <span class=\"math inline\">\\(f_{u,0/1}\\)</span> 表示从根上颜色为 <span class=\"math inline\">\\(0/1\\)</span> 时的最小断边数，显然无色可以视作任选一个颜色。那么有：</p>\n<p><span class=\"math display\">\\[\nf_{u,a}=\\sum\\limits_v\\min\\limits_{b\\in\\{0,1\\}}\\{f_{v,b}+[a\\ne b]\\}\n\\]</span></p>\n<p>直接把轻儿子的项提出来，记 <span class=\"math inline\">\\(g_{u,0/1}\\)</span> 表示 <span class=\"math inline\">\\(f_{u,0/1}\\)</span> 对应的轻儿子贡献即可。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 1e5 + 5;\nconst int inf = 0x3f3f3f3f;\nstruct mat &#123;\n    int a[2][2];\n    int* operator[] (const int q) &#123; \n        return a[q];\n    &#125;\n    mat operator* (mat &amp;q) const &#123;\n        mat res;\n        res[0][0] = res[0][1] = res[1][0] = res[1][1] = inf;\n        for (int i = 0; i &lt; 2; ++i)\n            for (int k = 0; k &lt; 2; ++k)\n                for (int j = 0; j &lt; 2; ++j)\n                    res[i][k] = std::min(res[i][k], a[i][j] + q[j][k]);\n        return res;\n    &#125;\n    mat&amp; operator*= (mat &amp;q) &#123;\n        return *this = *this * q;\n    &#125;\n&#125; p[maxn];\nstruct &#123; int lc, rc, l, r, mid; mat u; &#125; t[maxn &lt;&lt; 2]; \nint ls[maxn], tab[maxn], g[maxn][2], rt[maxn], top[maxn], dfn[maxn], fa[maxn];\nstd::vector&lt;int&gt; a;\n#define lt t[p].lc\n#define rt t[p].rc\nvoid bld(int &amp;p, int l, int r) &#123;\n    static int tot = 0;\n    p = ++tot, t[p].l = l, t[p].r = r;\n    if (l == r) &#123;\n        t[p].u[0][1] = t[p].u[1][0] = 1;\n        return;\n    &#125;\n    int s = 0, u = ls[tab[l]];\n    for (int i = l; i &lt;= r; ++i)\n        s += ls[tab[i]];\n    s &gt;&gt;= 1;\n    t[p].mid = r - 1;\n    for (int i = l + 1; i &lt; r; ++i) &#123;\n        u += ls[tab[i]];\n        if (u + ls[tab[i + 1]] &gt; s) &#123;\n            t[p].mid = i;\n            break;\n        &#125;\n    &#125;\n    bld(lt, l, t[p].mid), bld(rt, t[p].mid + 1, r);\n    t[p].u = t[rt].u * t[lt].u;\n    return;\n&#125;\nvoid add(int p, int x) &#123;\n    if (t[p].l == t[p].r) &#123;\n        int u = tab[x], g0 = (a[u] == 1 ? inf : g[u][0]), g1 = (a[u] == 0 ? inf : g[u][1]);\n        t[p].u[0][0] = g0, t[p].u[0][1] = g1 + 1;\n        t[p].u[1][0] = g0 + 1, t[p].u[1][1] = g1;\n        return;\n    &#125;\n    if (x &lt;= t[p].mid)\n        add(lt, x);\n    else\n        add(rt, x);\n    t[p].u = t[rt].u * t[lt].u;\n    return;\n&#125;\n#undef lt\n#undef rt\nvoid initialize(int n, std::vector&lt;int&gt; A, std::vector&lt;int&gt; B) &#123;\n    a.assign(n + 1, -1);\n    std::vector&lt;std::vector&lt;int&gt; &gt; g1(n + 1);\n    for (int i = 0; i &lt; n - 1; ++i)\n        g1[A[i]].push_back(B[i]), g1[B[i]].push_back(A[i]);\n    std::vector&lt;int&gt; siz(n + 1), son(n + 1);\n    std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;\n        siz[x] = 1;\n        for (auto i : g1[x])\n            if (i != fa[x]) &#123;\n                fa[i] = x, DFS(i);\n                siz[x] += siz[i];\n                if (siz[i] &gt; siz[son[x]])\n                    son[x] = i;\n            &#125;\n        return;\n    &#125;;\n    DFS(1);\n    std::vector&lt;int&gt; bot(n + 1);\n    DFS = [&amp;](int x) &#123;\n        static int now = 0;\n        dfn[x] = ++now, tab[now] = x, ls[x] = 1;\n        if (son[x]) &#123;\n            top[son[x]] = top[x], DFS(son[x]);\n            bot[x] = bot[son[x]];\n            for (auto i : g1[x])\n                if (i != son[x] &amp;&amp; i != fa[x]) &#123;\n                    top[i] = i, DFS(i);\n                    ls[x] += siz[i];\n                &#125;\n        &#125;\n        else\n            bot[x] = x;\n        if (x == top[x])\n            bld(rt[x], dfn[x], dfn[bot[x]]);\n        return;\n    &#125;;\n    top[1] = 1, DFS(1);\n    return;\n&#125;\nint upd(int x) &#123;\n    for (; top[x] != 1; ) &#123;\n        int faa = fa[top[x]];\n        auto &amp;id = t[rt[top[x]]].u;\n        int f0 = std::min(id[0][0], id[1][0]), f1 = std::min(id[0][1], id[1][1]);\n        g[faa][0] -= std::min(f0, f1 + 1);\n        g[faa][1] -= std::min(f0 + 1, f1);\n        add(rt[top[x]], dfn[x]);\n        f0 = std::min(id[0][0], id[1][0]), f1 = std::min(id[0][1], id[1][1]);\n        // printf(&quot;%d: f0 = %d, f1 = %d\\n&quot;, top[x], f0, f1);\n        g[faa][0] += std::min(f0, f1 + 1);\n        g[faa][1] += std::min(f0 + 1, f1);\n        x = faa;\n    &#125;\n    add(rt[1], dfn[x]);\n    auto &amp;id = t[rt[1]].u;\n    int f0 = std::min(id[0][0], id[1][0]), f1 = std::min(id[0][1], id[1][1]);\n    // printf(&quot;%d: f0 = %d, f1 = %d\\n&quot;, 1, f0, f1);\n    return std::min(f0, f1);\n&#125;\nint cat(int x) &#123;\n    a[x] = 0;\n    return upd(x);\n&#125;\nint dog(int x) &#123;\n    a[x] = 1;\n    return upd(x);\n&#125;\nint neighbor(int x) &#123;\n    a[x] = -1;\n    return upd(x);\n&#125;\n#ifndef ONLINE_JUDGE\nint main() &#123;\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;int&gt; A(n - 1), B(n - 1);\n    for (int i = 0; i &lt; n - 1; ++i)\n        std::cin &gt;&gt; A[i] &gt;&gt; B[i];\n    initialize(n, A, B);\n    int q;\n    std::cin &gt;&gt; q;\n    for (int op, x; q--; ) &#123;\n        std::cin &gt;&gt; op &gt;&gt; x;\n        std::cout &lt;&lt; (op == 1 ? cat(x) : (op == 2 ? dog(x) : neighbor(x))) &lt;&lt; &#39;\\n&#39;;\n    &#125;\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n    return 0;\n&#125;\n#endif</code></pre>\n</details>\n<hr />\n<h3 id=\"f---hash-on-tree\">F - Hash on Tree</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/AT_abc351_g\" class=\"uri\">https://www.luogu.com.cn/problem/AT_abc351_g</a></p>\n<p>记 <span class=\"math inline\">\\(g_x\\)</span> 为轻儿子的哈希值之积，则 <span class=\"math inline\">\\(f_u=A_u+f_{son}\\cdot g_u\\)</span>。</p>\n<p>然后开一个常数维即可。快速幂的 log 省不掉，所以是双 log 的。</p>\n<p>初值和修改都有可能为 <span class=\"math inline\">\\(0\\)</span>，需要维护实际哈希值和去掉 <span class=\"math inline\">\\(0\\)</span> 的哈希值。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 1e6 + 5;\nconst int LEN = (1 &lt;&lt; 20);\nconst int mod = 998244353;\nint nec(void) &#123;\n    static char buf[LEN], *p = buf, *e = buf;\n    if (p == e) &#123;\n        e = buf + fread(buf, 1, LEN, stdin);\n        if (e == buf) return EOF;\n        p = buf;\n    &#125;\n    return *p++;\n&#125;\nbool read(int &amp;x) &#123;\n    x = 0;\n    bool f = 0;\n    char ch = nec();\n    while (ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123;\n        if (ch == EOF) return 0;\n        if (ch == &#39;-&#39;) f = 1;\n        ch = nec();\n    &#125;\n    while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) &#123;\n        x = x * 10 + ch - &#39;0&#39;;\n        ch = nec();\n    &#125;\n    if (f) x = -x;\n    return 1;\n&#125;\nvoid print(int x) &#123;\n    if (x &lt; 0)\n        putchar(&#39;-&#39;), x = -x;\n    if (x &gt;= 10) print(x / 10);\n    putchar(x % 10 + &#39;0&#39;);\n    return;\n&#125;\nvoid print(int x, char ch) &#123;\n    print(x), putchar(ch);\n    return;\n&#125;\nstruct mat &#123;\n    int n, m;\n    long long a[2][2];\n    long long* operator[] (const int q) &#123;\n        return a[q];\n    &#125;\n    mat operator* (mat &amp;q) const &#123;\n        mat res;\n        res.n = n, res.m = q.m;\n        res[0][0] = res[0][1] = res[1][0] = res[1][1] = 0ll;\n        for (int i = 0; i &lt; n; ++i)\n            for (int k = 0; k &lt; q.m; ++k) &#123;\n                for (int j = 0; j &lt; m; ++j)\n                    res[i][k] += a[i][j] * q[j][k];\n                res[i][k] %= mod;\n            &#125;\n        return res;\n    &#125;\n    mat&amp; operator*= (mat &amp;q) &#123;\n        return *this = *this * q;\n    &#125;\n&#125;;\nstruct &#123; int lc, rc, l, r, mid; mat u; &#125; t[maxn &lt;&lt; 2]; \nlong long g[maxn];\nint tab[maxn], ls[maxn], a[maxn];\n#define lt t[p].lc\n#define rt t[p].rc\nvoid bld(int &amp;p, int l, int r) &#123;\n    static int tot = 0;\n    p = ++tot, t[p].l = l, t[p].r = r;\n    if (l == r) &#123;\n        int u = tab[l];\n        t[p].u.n = t[p].u.m = 2;\n        t[p].u[0][0] = g[u];\n        t[p].u[0][1] = 0ll;\n        t[p].u[1][0] = a[u];\n        t[p].u[1][1] = 1ll;\n        return;\n    &#125;\n    int s = 0, u = ls[tab[l]];\n    for (int i = l; i &lt;= r; ++i)\n        s += ls[tab[i]];\n    s &gt;&gt;= 1;\n    t[p].mid = r - 1;\n    for (int i = l + 1; i &lt; r; ++i) &#123;\n        u += ls[tab[i]];\n        if (u + ls[tab[i + 1]] &gt; s) &#123;\n            t[p].mid = i;\n            break;\n        &#125;\n    &#125;\n    bld(lt, l, t[p].mid), bld(rt, t[p].mid + 1, r);\n    t[p].u = t[rt].u * t[lt].u;\n    return;\n&#125;\nvoid add(int p, int x) &#123;\n    if (t[p].l == t[p].r) &#123;\n        int u = tab[x];\n        t[p].u[0][0] = g[u];\n        t[p].u[1][0] = a[u];\n        return;\n    &#125;\n    if (x &lt;= t[p].mid)\n        add(lt, x);\n    else\n        add(rt, x);\n    t[p].u = t[rt].u * t[lt].u;\n    return;\n&#125;\n#undef lt\n#undef rt\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, q;\n    read(n), read(q);\n    std::vector&lt;int&gt; rt(n + 1);\n    std::vector&lt;std::vector&lt;int&gt; &gt; g1(n + 1);\n    for (int i = 2, x; i &lt;= n; ++i) &#123;\n        read(x);\n        g1[i].push_back(x), g1[x].push_back(i);\n    &#125;\n    for (int i = 1; i &lt;= n; ++i)\n        read(a[i]);\n    std::vector&lt;int&gt; siz(n + 1), son(n + 1), fa(n + 1);\n    std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;\n        siz[x] = 1;\n        for (auto i : g1[x])\n            if (i != fa[x]) &#123;\n                fa[i] = x, DFS(i);\n                siz[x] += siz[i];\n                if (siz[i] &gt; siz[son[x]])\n                    son[x] = i;\n            &#125;\n        return;\n    &#125;;\n    DFS(1);\n    std::vector&lt;long long&gt; f(n + 1);\n    std::vector&lt;int&gt; top(n + 1), bot(n + 1), dfn(n + 1), la(n + 1), cnt(n + 1);\n    DFS = [&amp;](int x) &#123;\n        static int now = 0;\n        dfn[x] = ++now, tab[now] = x, ls[x] = 1;\n        if (son[x]) &#123;\n            top[son[x]] = top[x], DFS(son[x]);\n            bot[x] = bot[son[x]];\n            g[x] = 1ll;\n            for (auto i : g1[x])\n                if (i != son[x] &amp;&amp; i != fa[x]) &#123;\n                    top[i] = i, DFS(i);\n                    ls[x] += siz[i];\n                    if (f[i] == 0ll)\n                        ++cnt[x];\n                    else\n                        (la[x] *= f[i]) %= mod;\n                    (g[x] *= f[i]) %= mod;\n                &#125;\n            f[x] = (a[x] + g[x] * f[son[x]]) % mod;\n        &#125;\n        else\n            f[x] = a[x], bot[x] = x;\n        // printf(&quot;f[%d] = %lld\\n&quot;, x, f[x]);\n        if (x == top[x])\n            bld(rt[x], dfn[x], dfn[bot[x]]);\n        return;\n    &#125;;\n    top[1] = 1, DFS(1);\n    mat init;\n    init.n = 1, init.m = 2;\n    init[0][0] = 0ll, init[0][1] = 1ll;\n    auto qkp = [&amp;](long long x, int y) &#123;\n        auto res(1ll);\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    auto inv = [&amp;](int x) &#123;\n        return qkp(x, mod - 2);\n    &#125;;\n    for (int x, v; q--; ) &#123;\n        read(x), read(v);\n        a[x] = v;\n        for (; top[x] != 1; ) &#123;\n            int faa = fa[top[x]];\n            auto &amp;id = t[rt[top[x]]].u;\n            int f = (init * id)[0][0];\n            if (f == 0) &#123;\n                if (--cnt[faa] == 0)\n                    g[faa] = la[faa];\n            &#125;\n            else &#123;\n                f = inv(f);\n                (g[faa] *= f) %= mod;\n                (la[faa] *= f) %= mod;\n            &#125;\n            add(rt[top[x]], dfn[x]);\n            f = (init * id)[0][0];\n            if (f == 0) &#123;\n                if (cnt[faa]++ == 0)\n                    la[faa] = g[faa];\n                g[faa] = 0ll;\n            &#125;\n            else &#123;\n                (g[faa] *= f) %= mod;\n                (la[faa] *= f) %= mod;\n            &#125;\n            x = faa;\n        &#125;\n        add(rt[1], dfn[x]);\n        auto &amp;id = t[rt[1]].u;\n        int f = (init * id)[0][0];\n        std::cout &lt;&lt; f &lt;&lt; &#39;\\n&#39;;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"g---考试-2\">G - 考试 2</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P10626\" class=\"uri\">https://www.luogu.com.cn/problem/P10626</a></p>\n<p>运算均是线性的，容易想到『按位』维护，即只维护某个特定点值。如果将询问离线下来排序，每个函数的点值只会变化 <span class=\"math inline\">\\(O(1)\\)</span> 次。</p>\n<p>建出符号二叉树，进行 DDP 即可。具体地，令 <span class=\"math inline\">\\(f_u\\)</span> 表示在运算 <span class=\"math inline\">\\(u\\)</span> 处的答案，计算 <span class=\"math inline\">\\(g_u\\)</span> 为轻儿子的答案，按照 <span class=\"math inline\">\\(u\\)</span> 处的符号写矩阵即可。叶子不是一次运算，应该直接填入点值（注意线段树上的叶子不一定是原树上的叶子）。</p>\n<p>建树和矩阵更新有点史，适当封装一下感觉会好一点</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 1e6 + 5;\nconst char mp[] = &quot;x!&amp;|^&quot;;\nconst int LEN = (1 &lt;&lt; 20);\n#define nec getchar\ninline bool read(int &amp;x) &#123;\n    x = 0;\n    bool f = 0;\n    char ch = nec();\n    while (ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123;\n        if (ch == EOF) return 0;\n        if (ch == &#39;-&#39;) f = 1;\n        ch = nec();\n    &#125;\n    while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) &#123;\n        x = x * 10 + ch - &#39;0&#39;;\n        ch = nec();\n    &#125;\n    if (f) x = -x;\n    return 1;\n&#125;\nvoid print(int x) &#123;\n    if (x &lt; 0)\n        putchar(&#39;-&#39;), x = -x;\n    if (x &gt;= 10) print(x / 10);\n    putchar(x % 10 + &#39;0&#39;);\n    return;\n&#125;\nvoid print(int x, char ch) &#123;\n    print(x), putchar(ch);\n    return;\n&#125;\nstruct mat &#123;\n    int n, m;\n    int a[2][2];\n    int* operator[] (const int q) &#123;\n        return a[q];\n    &#125;\n    inline mat operator* (mat &amp;q) const &#123;\n        mat res;\n        res.n = n, res.m = q.m;\n        res[0][0] = res[0][1] = res[1][0] = res[1][1] = 0ll;\n        for (int i = 0; i &lt; n; ++i)\n            for (int k = 0; k &lt; q.m; ++k)\n                for (int j = 0; j &lt; m; ++j)\n                    res[i][k] += a[i][j] * q[j][k];\n        return res;\n    &#125;\n    mat&amp; operator*= (mat &amp;q) &#123;\n        return *this = *this * q;\n    &#125;\n&#125;;\nstruct &#123; int lc, rc, l, r, mid; mat u; &#125; t[maxn &lt;&lt; 2]; \nint g1[maxn][2];\nint g[maxn], ty[maxn];\nint tab[maxn], ls[maxn], lim[maxn];\n#define lt t[p].lc\n#define rt t[p].rc\nvoid fillmat(mat &amp;a, int op, int g) &#123;\n    if (op == 0) &#123;\n        a.n = 1, a.m = 2;\n        a[0][!g] = 0, a[0][g] = 1;\n        return;\n    &#125;\n    a.n = 2, a.m = 2;\n    switch (op) &#123;\n    case 1: // !\n        a[0][0] = 0, a[0][1] = 1;\n        a[1][0] = 1, a[1][1] = 0;\n        break;\n    case 2: // &amp;\n        a[0][0] = 1, a[0][1] = 0;\n        a[1][0] = !g, a[1][1] = g;\n        break;\n    case 3: // |\n        a[0][0] = !g, a[0][1] = g;\n        a[1][0] = 0, a[1][1] = 1;\n        break;\n    case 4: // ^\n        a[0][0] = !g, a[0][1] = g;\n        a[1][0] = g, a[1][1] = !g;\n        break;\n    default:\n        assert(0);\n    &#125;\n    return;\n&#125;\nvoid bld(int &amp;p, int l, int r) &#123;\n    static int tot = 0;\n    p = ++tot, t[p].l = l, t[p].r = r;\n    if (l == r) &#123;\n        fillmat(t[p].u, ty[tab[l]], g[tab[l]]);\n        return;\n    &#125;\n    int s = 0, u = ls[tab[l]];\n    for (int i = l; i &lt;= r; ++i)\n        s += ls[tab[i]];\n    s &gt;&gt;= 1;\n    t[p].mid = r - 1;\n    for (int i = l + 1; i &lt; r; ++i) &#123;\n        u += ls[tab[i]];\n        if (u + ls[tab[i + 1]] &gt; s) &#123;\n            t[p].mid = i;\n            break;\n        &#125;\n    &#125;\n    bld(lt, l, t[p].mid), bld(rt, t[p].mid + 1, r);\n    t[p].u = t[rt].u * t[lt].u;\n    return;\n&#125;\nvoid add(int p, int x) &#123;\n    if (t[p].l == t[p].r) &#123;\n        fillmat(t[p].u, ty[tab[t[p].l]], g[tab[t[p].l]]);\n        return;\n    &#125;\n    if (x &lt;= t[p].mid)\n        add(lt, x);\n    else\n        add(rt, x);\n    t[p].u = t[rt].u * t[lt].u;\n    return;\n&#125;\n#undef lt\n#undef rt\nint main() &#123;\n#ifndef ONLINE_JUDGE\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n = 0, q, p;\n    read(q), read(q);\n    &#123;\n        std::string s;\n        std::cin &gt;&gt; s;\n        std::stringstream in(s);\n        std::stack&lt;char&gt; op;\n        std::stack&lt;int&gt; id;\n        auto trans = [&amp;](char t) &#123;\n            switch (t) &#123;\n            case &#39;!&#39;:\n                return 1;\n            case &#39;&amp;&#39;:\n                return 2;\n            case &#39;|&#39;:\n                return 3;\n            case &#39;^&#39;:\n                return 4;\n            &#125;\n            assert(0);\n            return -1;\n        &#125;;\n        auto calcNot = [&amp;](void) &#123;\n            for (; !op.empty() &amp;&amp; op.top() == &#39;!&#39;; ) &#123;\n                ty[++n] = trans(op.top());\n                g1[n][0] = id.top(), id.pop(), id.push(n);\n                op.pop();\n            &#125;\n            return;\n        &#125;;\n        auto opt = [&amp;](void) &#123;\n            ty[++n] = trans(op.top());\n            g1[n][0] = id.top(), id.pop();\n            g1[n][1] = id.top(), id.pop();\n            id.push(n), op.pop();\n            return;\n        &#125;;\n        for (char t; in &gt;&gt; t; )\n            if (t == &#39;[&#39;) &#123;\n                int x;\n                in &gt;&gt; x, in &gt;&gt; t;\n                lim[++n] = x - 1;\n                id.push(n), calcNot();\n            &#125;\n            else if (t == &#39;(&#39;)\n                op.push(t);\n            else if (t == &#39;)&#39;) &#123;\n                for (; op.top() != &#39;(&#39;; opt());\n                op.pop(), calcNot();\n            &#125;\n            else if (t == &#39;&amp;&#39;)\n                op.push(t);\n            else if (t == &#39;^&#39;) &#123;\n                for (; !op.empty() &amp;&amp; op.top() == &#39;&amp;&#39;; opt());\n                op.push(t);\n            &#125;\n            else if (t == &#39;|&#39;) &#123;\n                for (; !op.empty() &amp;&amp; (op.top() == &#39;&amp;&#39; || op.top() == &#39;^&#39;); opt());\n                op.push(t);\n            &#125;\n            else &#123;\n                assert(t == &#39;!&#39;);\n                op.push(t);\n            &#125;\n        for (; !op.empty(); opt());\n        p = id.top();\n    &#125;\n    std::vector&lt;int&gt; rt(n + 1);\n    std::vector&lt;int&gt; siz(n + 1), son(n + 1), fa(n + 1);\n    std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;\n        siz[x] = 1;\n        for (auto i : g1[x])\n            if (i != 0) &#123;\n                fa[i] = x, DFS(i);\n                siz[x] += siz[i];\n                if (siz[i] &gt; siz[son[x]])\n                    son[x] = i;\n            &#125;\n        return;\n    &#125;;\n    DFS(p);\n    std::vector&lt;long long&gt; f(n + 1);\n    std::vector&lt;int&gt; top(n + 1), bot(n + 1), dfn(n + 1);\n    DFS = [&amp;](int x) &#123;\n        static int now = 0;\n        dfn[x] = ++now, tab[now] = x, ls[x] = 1;\n        if (son[x]) &#123;\n            top[son[x]] = top[x], DFS(son[x]);\n            bot[x] = bot[son[x]];\n            for (auto i : g1[x])\n                if (i != son[x] &amp;&amp; i != 0) &#123;\n                    top[i] = i, DFS(i);\n                    ls[x] += siz[i], g[x] = f[i];\n                &#125;\n            switch (ty[x]) &#123;\n            case 1:\n                f[x] = !f[son[x]];\n                break;\n            case 2:\n                f[x] = g[x] &amp; f[son[x]];\n                break;\n            case 3:\n                f[x] = g[x] | f[son[x]];\n                break;\n            case 4:\n                f[x] = g[x] ^ f[son[x]];\n                break;\n            default:\n                assert(0);\n                break;\n            &#125;\n        &#125;\n        else\n            assert(!ty[x]), f[x] = g[x] = 0, bot[x] = x;\n        if (x == top[x])\n            bld(rt[x], dfn[x], dfn[bot[x]]);\n        return;\n    &#125;;\n    top[p] = p, DFS(p);\n    std::vector&lt;int&gt; a(q + 1), res(q + 1);\n    for (int i = 1; i &lt;= q; ++i)\n        read(a[i]);\n    std::vector&lt;int&gt; qid(q), nid;\n    for (int i = 1; i &lt;= n; ++i)\n        if (ty[i] == 0)\n            nid.push_back(i);\n    std::iota(qid.begin(), qid.end(), 1);\n    std::sort(qid.begin(), qid.end(), [&amp;](int x, int y) &#123; return a[x] &lt; a[y]; &#125;);\n    std::sort(nid.begin(), nid.end(), [&amp;](int x, int y) &#123; return lim[x] &gt; lim[y]; &#125;);\n    for (auto i : qid) &#123;\n        for (; !nid.empty() &amp;&amp; lim[nid.back()] &lt; a[i]; ) &#123;\n            int x = nid.back();\n            nid.pop_back();\n            g[x] = 1;\n            for (; top[x] != p; ) &#123;\n                add(rt[top[x]], dfn[x]);\n                g[fa[top[x]]] = t[rt[top[x]]].u[0][1];\n                x = fa[top[x]];\n            &#125;\n            add(rt[p], dfn[x]);\n        &#125;\n        res[i] = t[rt[p]].u[0][1];\n    &#125;\n    for (int i = 1; i &lt;= q; ++i)\n        if (res[i])\n            std::cout &lt;&lt; &quot;True\\n&quot;;\n        else\n            std::cout &lt;&lt; &quot;False\\n&quot;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n",
            "tags": [
                "线段树",
                "DDP"
            ]
        }
    ]
}