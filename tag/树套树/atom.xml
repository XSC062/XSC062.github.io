<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://xsc062.netlify.app</id>
    <title> • Posts by &#34;树套树&#34; tag</title>
    <link href="https://xsc062.netlify.app" />
    <updated>2025-10-07T08:29:52.000Z</updated>
    <category term="并查集" />
    <category term="斜率优化" />
    <category term="悬线法" />
    <category term="哈希" />
    <category term="字典树" />
    <category term="DP" />
    <category term="单调队列" />
    <category term="分治" />
    <category term="计数" />
    <category term="容斥" />
    <category term="二分图" />
    <category term="CRT / exCRT" />
    <category term="排列组合" />
    <category term="网络流" />
    <category term="二分" />
    <category term="容斥原理" />
    <category term="线段树" />
    <category term="树状数组" />
    <category term="区间 DP" />
    <category term="构造" />
    <category term="数据结构" />
    <category term="Tarjan" />
    <category term="下饭" />
    <category term="李超线段树" />
    <category term="树链剖分" />
    <category term="LCA" />
    <category term="倍增" />
    <category term="鸽巢原理" />
    <category term="数学" />
    <category term="调和级数" />
    <category term="差分" />
    <category term="思维" />
    <category term="树形 DP" />
    <category term="最小生成树" />
    <category term="状压" />
    <category term="高维前缀和" />
    <category term="SAM" />
    <category term="分块" />
    <category term="可持久化" />
    <category term="笛卡尔树" />
    <category term="闲话" />
    <category term="欧拉回路" />
    <category term="长链剖分" />
    <category term="KMP" />
    <category term="border" />
    <category term="随机化" />
    <category term="字符串" />
    <category term="AC 自动机" />
    <category term="SA" />
    <category term="树上差分" />
    <category term="FWT" />
    <category term="堆" />
    <category term="树的重心" />
    <category term="贪心" />
    <category term="均摊" />
    <category term="优化建图" />
    <category term="反悔贪心" />
    <category term="调整法" />
    <category term="背包" />
    <category term="博弈论" />
    <category term="DP 优化" />
    <category term="虚树" />
    <category term="点分治" />
    <category term="四边形不等式" />
    <category term="支配对" />
    <category term="DDP" />
    <category term="CDQ 分治" />
    <category term="猫树" />
    <category term="DP 套 DP" />
    <category term="Kruskal 重构树" />
    <category term="高精度" />
    <category term="最短路" />
    <category term="树套树" />
    <category term="二项式反演" />
    <category term="搜索" />
    <entry>
        <id>https://xsc062.netlify.app/20251007-1/</id>
        <title>学习笔记 树套树</title>
        <link rel="alternate" href="https://xsc062.netlify.app/20251007-1/"/>
        <content type="html">&lt;p&gt;第一次学树套树时，并没有什么特别的感觉，因为属于我的离线分治，我早已遇见&lt;/p&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;
&lt;p&gt;并非第一次学&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;线段树&#34;&gt;线段树&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;考虑线段树的本质，即给定序列，能够返回关键字在 &lt;span class=&#34;math inline&#34;&gt;\([l,r]\)&lt;/span&gt; 内的可加信息之和&lt;/li&gt;
&lt;li&gt;仅需要保证信息是&lt;strong&gt;可加&lt;/strong&gt;的（如众数，mex 等显然不在此列）&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;树状数组&#34;&gt;树状数组&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;给定序列，能够返回任意关键字处的前缀和 / 后缀和，需要保证信息是&lt;strong&gt;可加&lt;/strong&gt;的&lt;/li&gt;
&lt;li&gt;如果要求任意区间内关键字的信息之和，会用到差分，此时还需额外保证信息是&lt;strong&gt;可减&lt;/strong&gt;的（如 min / max 显然不在此列）&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;主席树-可持久化线段树&#34;&gt;主席树 / 可持久化线段树&lt;/h2&gt;
&lt;p&gt;之前有人在争论『主席树』是否等价于『可持久化线段树』，其实从当前 OI 环境的语境下我觉得是等价的&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;给定序列，存在关键字 A 和关键字 B，能够求出 &lt;span class=&#34;math inline&#34;&gt;\(([0, A&amp;#39;], [B_1, B_2])\)&lt;/span&gt; 这个矩形的信息和（这里的矩形可能是 DAG 状的）&lt;/p&gt;
&lt;p&gt;也就是说主席树本身存的是关于 A 的信息前缀和&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;要求 A 只能来源于先前的 A（即 A 具有&lt;strong&gt;单调性&lt;/strong&gt;），且底层信息的 delta 为 1&lt;/p&gt;
&lt;p&gt;需要发现这个条件是相当苛刻的，所以这里的 A 通常以时间 / 版本 / DAG 的形式出现&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果信息具有&lt;strong&gt;可减&lt;/strong&gt;性，对于 &lt;span class=&#34;math inline&#34;&gt;\(A_2\)&lt;/span&gt; 和其某个祖先 &lt;span class=&#34;math inline&#34;&gt;\(A_1\)&lt;/span&gt;，能够求出 &lt;span class=&#34;math inline&#34;&gt;\(([A_1,A_2],[B_1,B_2])\)&lt;/span&gt; 这个矩形的信息和。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;考虑为什么主席树不能解决三维偏序&lt;/li&gt;
&lt;li&gt;现在已经对关键字 C 排完序了，我们需要求出 &lt;span class=&#34;math inline&#34;&gt;\(([0, A], [0, B])\)&lt;/span&gt; 这个矩形的信息和&lt;/li&gt;
&lt;li&gt;发现 A 是不具备&lt;strong&gt;单调性&lt;/strong&gt;的，有没有什么 DS 能够不要求 A 的单调性呢？&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;树状数组套线段树&#34;&gt;树状数组套线段树&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;用 &lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt; 棵线段树维护 B 的偏序关系，用类主席树的方式来排列这些树&lt;/li&gt;
&lt;li&gt;&lt;p&gt;发现一次修改需要改一段后缀&lt;/p&gt;
&lt;p&gt;这一点我们前面说过了，主席树本身存储的是 A 维的前缀和。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;所以直接解决这个问题：维护信息的差分。这样就可以通过询问前缀得到原始信息&lt;/li&gt;
&lt;li&gt;&lt;p&gt;这个结构和树状数组是很吻合的，考虑在树状数组的每个点上维护动态开点线段树&lt;/p&gt;
&lt;p&gt;这样就可以只用修改 log 个线段树&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;考虑怎么询问&lt;/p&gt;
&lt;p&gt;我最初的想法是，做一个线段树合并，利用 DS 本身的树形结构可以有一个 dsu on tree 的复杂度（即 &lt;span class=&#34;math inline&#34;&gt;\(O(nq\log^2 n)\)&lt;/span&gt;），但显然这个太糖了&lt;/p&gt;
&lt;p&gt;正常的做法是，注意到每个点的权值线段树结构相同，所以在 log 个线段树上同时维护，当作包含长度 log 的数组的结构体即可&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;同树状数组，要求信息有&lt;strong&gt;可减性&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;但由于外层的 DS 本质上舍弃了主席树 DAG 的结构&lt;/p&gt;
&lt;p&gt;导致不能直接简单用于树上问题，而是需要在 &lt;strong&gt;DFS 序&lt;/strong&gt;上作文章&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;实际上常数很大，超过 &lt;span class=&#34;math inline&#34;&gt;\(10^5\)&lt;/span&gt; 就不太能跑得动了&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;dynamic-rankings-k大数查询&#34;&gt;Dynamic Rankings / K大数查询&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P2617&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P2617&lt;/a&gt; / &lt;a href=&#34;https://www.luogu.com.cn/problem/P3332&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P3332&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;全局第 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 大就是普通的权值线段树上二分，抑或平衡树，抑或 01-Trie（三者等价）&lt;/li&gt;
&lt;li&gt;这里的权值线段树上二分，其实是矩形第二维限制的变体&lt;/li&gt;
&lt;li&gt;发现这里只需要简单地维护元素个数，是具有可减性的。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;三维偏序陌上花开&#34;&gt;三维偏序（陌上花开）&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P3810&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P3810&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;树状数组套权值线段树即可&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;二逼平衡树&#34;&gt;二逼平衡树&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://loj.ac/p/106&#34; class=&#34;uri&#34;&gt;https://loj.ac/p/106&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;和 k 大数差不多，都是权值线段树那些东西&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;网络管理&#34;&gt;网络管理&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P4175&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P4175&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;维护带修树上简单路径第 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 大。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;做树上差分即可转化为序列第 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 大。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;买宝石&#34;&gt;买宝石&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.becoder.com.cn/contest/6620/problem/4&#34; class=&#34;uri&#34;&gt;https://www.becoder.com.cn/contest/6620/problem/4&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定根为 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt; 的树，每个点 &lt;span class=&#34;math inline&#34;&gt;\(u\)&lt;/span&gt; 上有 &lt;span class=&#34;math inline&#34;&gt;\(k_u\)&lt;/span&gt; 个价钱为 &lt;span class=&#34;math inline&#34;&gt;\(w_u\)&lt;/span&gt; 的物品，可以在时间 &lt;span class=&#34;math inline&#34;&gt;\(t_u\)&lt;/span&gt; 及之后获得&lt;/p&gt;
&lt;p&gt;给定 &lt;span class=&#34;math inline&#34;&gt;\(Q\)&lt;/span&gt; 次询问，从问 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 出发到根的路径上所有在时刻 &lt;span class=&#34;math inline&#34;&gt;\(T\)&lt;/span&gt; 可以获得的物品全部拿出来排成一列，拥有 &lt;span class=&#34;math inline&#34;&gt;\(K\)&lt;/span&gt; 金钱时，按照价值从小到大购买，买到的最后一个物品价值。&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(n\le 10^5\)&lt;/span&gt;，价钱：&lt;span class=&#34;math inline&#34;&gt;\(10^{15}\)&lt;/span&gt;，时间：&lt;span class=&#34;math inline&#34;&gt;\(10^5\)&lt;/span&gt;，个数：&lt;span class=&#34;math inline&#34;&gt;\(10^5\)&lt;/span&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;信息自带一个有序的时间偏序维 &lt;span class=&#34;math inline&#34;&gt;\(T\)&lt;/span&gt; 且原生有序，所以不能整体二分，必须处理 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 偏序维和 &lt;span class=&#34;math inline&#34;&gt;\(w\)&lt;/span&gt; 二分维。&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;总的来说，就是维护了两个关键字，或者说一个矩形&lt;/li&gt;
&lt;li&gt;根据在 A，B 维需要做的操作选择，以及需要维护的信息类型，选择相应的数据结构&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;关于整体二分&#34;&gt;关于整体二分&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;考虑动态区间第 K 大这一类的问题，特征是 A 维『求和』，B 维&lt;strong&gt;二分&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;此时可以把对 B 维的二分提到外层一起进行，反过来对 A 维应用数据结构&lt;/li&gt;
&lt;li&gt;考虑到树套树常数过大，所以在能用整体二分的时候不推荐用树套树&lt;/li&gt;
&lt;/ul&gt;
</content>
        <category term="树套树" />
        <updated>2025-10-07T08:29:52.000Z</updated>
    </entry>
</feed>
