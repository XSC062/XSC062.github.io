<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://xsc062.netlify.app</id>
    <title> • Posts by &#34;概率期望&#34; tag</title>
    <link href="https://xsc062.netlify.app" />
    <updated>2024-01-11T03:25:19.000Z</updated>
    <category term="并查集" />
    <category term="斜率优化" />
    <category term="悬线法" />
    <category term="哈希" />
    <category term="字典树" />
    <category term="DP" />
    <category term="单调队列" />
    <category term="分治" />
    <category term="二分图" />
    <category term="CRT / exCRT" />
    <category term="排列组合" />
    <category term="网络流" />
    <category term="费用流" />
    <category term="二分" />
    <category term="上下界网络流" />
    <category term="容斥原理" />
    <category term="线段树" />
    <category term="树状数组" />
    <category term="区间 DP" />
    <category term="构造" />
    <category term="数据结构" />
    <category term="Tarjan" />
    <category term="下饭" />
    <category term="LCA" />
    <category term="倍增" />
    <category term="鸽巢原理" />
    <category term="概率期望" />
    <category term="调和级数" />
    <category term="差分" />
    <category term="思维" />
    <category term="树形 DP" />
    <category term="最小生成树" />
    <category term="SAM" />
    <category term="状压" />
    <category term="分块" />
    <category term="可持久化" />
    <category term="笛卡尔树" />
    <category term="高维前缀和" />
    <category term="闲话" />
    <category term="欧拉回路" />
    <category term="树链剖分" />
    <category term="长链剖分" />
    <category term="KMP" />
    <category term="border" />
    <category term="字符串" />
    <category term="AC 自动机" />
    <category term="SA" />
    <category term="数学" />
    <category term="树上差分" />
    <category term="FWT" />
    <category term="堆" />
    <category term="树的重心" />
    <category term="二项式定理" />
    <category term="二项式反演" />
    <category term="贪心" />
    <category term="均摊" />
    <category term="计数" />
    <category term="优化建图" />
    <category term="反悔贪心" />
    <category term="调整法" />
    <category term="背包" />
    <category term="博弈论" />
    <category term="DP 优化" />
    <category term="虚树" />
    <category term="点分治" />
    <category term="WQS 二分" />
    <category term="闵可夫斯基和" />
    <category term="slope trick" />
    <category term="四边形不等式" />
    <category term="状压 DP" />
    <category term="组合数学" />
    <category term="支配对" />
    <category term="DDP" />
    <category term="容斥" />
    <category term="Kruskal 重构树" />
    <category term="高精度" />
    <category term="最短路" />
    <category term="李超线段树" />
    <entry>
        <id>https://xsc062.netlify.app/20240111/</id>
        <title>杂题别选谈了</title>
        <link rel="alternate" href="https://xsc062.netlify.app/20240111/"/>
        <content type="html">&lt;p&gt;Solution to &lt;a href=&#34;http://222.180.160.110:61235/contest/4665/problem/2&#34;&gt;SP4060 Game with Probability Problem&lt;/a&gt;。&lt;/p&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;
&lt;hr /&gt;
&lt;p&gt;设 &lt;span class=&#34;math inline&#34;&gt;\(f_i,g_i\)&lt;/span&gt; 分别表示还剩 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 个的时候轮到 Alice 和 Bob 时 &lt;strong&gt;Alice&lt;/strong&gt; 分别的胜率。&lt;/p&gt;
&lt;p&gt;概率经典倒推。那么显然有 &lt;span class=&#34;math inline&#34;&gt;\(f_0=0,g_0=1\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;然后就是一个分讨，讨论这个人想要正面还是反面。很显然，对于同样的剩余棋子数，两个人先手的情况对于这颗棋子的喜爱程度是一样的。也就是说，要么都想要，要么都不想要。&lt;/p&gt;
&lt;p&gt;什么时候想要呢？拿掉过后自己胜率更大，也就是 &lt;span class=&#34;math inline&#34;&gt;\(g_{i-1}&amp;gt;f_{i-1}\)&lt;/span&gt;。此时有：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
f_i=(1-p)\times g_i+p\times g_{i-1}\\
g_i=(1-q)\times f_i+q\times f_{i-1}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;发现是互相影响的，这个时候先不要着急怀疑自己推错了，因为我们这里有两个未知数，又刚好有两个方程，暴解一下就有：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
f_i=\dfrac {(1-p)\times q\times f_{i-1}+p\times g_{i-1}}{1-(1-p)(1-q)}\\
g_i=\dfrac {(1-q)\times p\times g_{i-1}+q\times f_{i-1}}{1-(1-p)(1-q)}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;然后 &lt;span class=&#34;math inline&#34;&gt;\(g_{i-1}&amp;lt;f_{i-1}\)&lt;/span&gt; 的情况也差不多，把拿的概率和不拿的概率换一下：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
f_i=p\times g_i+(1-p)\times g_{i-1}\\
g_i=q\times f_i+(1-q)\times f_{i-1}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;解方程组有：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
f_i=\dfrac {(1-q)\times p\times f_{i-1}+(1-p)\times g_{i-1}}{1-p\times q}\\
g_i=\dfrac {(1-p)\times q\times g_{i-1}+(1-q)\times f_{i-1}}{1-p\times q}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;然后就可以开始 DP 了。最后的答案就是 &lt;span class=&#34;math inline&#34;&gt;\(f_{\min(n,1000)}\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;还有个问题就是 &lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt; 特别大然后这个看起来也不太能矩乘，但是这个 DP 式有个好处是它的增长趋势是指数级的，所以我们 DP 到 &lt;span class=&#34;math inline&#34;&gt;\(1000\)&lt;/span&gt; 就可以了。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
namespace XSC062 &amp;#123;
const int maxn = 1e3 + 5;
using db = double;
db p, q;
int T, n;
db f[maxn], g[maxn];
int min(int x, int y) &amp;#123;
    return x &amp;lt; y ? x : y;
&amp;#125;
int main() &amp;#123;
    scanf(&amp;quot;%d&amp;quot;, &amp;amp;T);
    while (T--) &amp;#123;
        scanf(&amp;quot;%d %lf %lf&amp;quot;, &amp;amp;n, &amp;amp;p, &amp;amp;q);
        f[0] = .0, g[0] = 1.0;
        for (int i = 1; i &amp;lt;= n &amp;amp;&amp;amp; i &amp;lt;= 1000; ++i) &amp;#123;
            if (g[i - 1] &amp;gt; f[i - 1]) &amp;#123;
                f[i] = ((1 - p) * q * f[i - 1] + p * g[i - 1]) / (1 - (1 - p) * (1 - q));
                g[i] = ((1 - q) * p * g[i - 1] + q * f[i - 1]) / (1 - (1 - p) * (1 - q));
            &amp;#125;
            else &amp;#123;
                f[i] = ((1 - q) * p * f[i - 1] + (1 - p) * g[i - 1]) / (1 - p * q);
                g[i] = ((1 - p) * q * g[i - 1] + (1 - q) * f[i - 1]) / (1 - p * q);
            &amp;#125;
        &amp;#125;
        printf(&amp;quot;%.6lf\n&amp;quot;, f[min(n, 1000)]);
    &amp;#125;
    return 0;
&amp;#125;
&amp;#125; // namespace XSC062
int main() &amp;#123;
    XSC062::main();
    return 0;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
</content>
        <category term="DP" />
        <category term="概率期望" />
        <updated>2024-01-11T03:25:19.000Z</updated>
    </entry>
</feed>
