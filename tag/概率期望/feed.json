{
    "version": "https://jsonfeed.org/version/1",
    "title": "null • All posts by \"概率期望\" tag",
    "description": "",
    "home_page_url": "https://xsc062.netlify.app",
    "items": [
        {
            "id": "https://xsc062.netlify.app/20240111/",
            "url": "https://xsc062.netlify.app/20240111/",
            "title": "杂题别选谈了",
            "date_published": "2024-01-11T03:25:19.000Z",
            "content_html": "<p>Solution to <a href=\"http://222.180.160.110:61235/contest/4665/problem/2\">SP4060 Game with Probability Problem</a>。</p>\n<span id=\"more\"></span>\n<hr />\n<p>设 <span class=\"math inline\">\\(f_i,g_i\\)</span> 分别表示还剩 <span class=\"math inline\">\\(i\\)</span> 个的时候轮到 Alice 和 Bob 时 <strong>Alice</strong> 分别的胜率。</p>\n<p>概率经典倒推。那么显然有 <span class=\"math inline\">\\(f_0=0,g_0=1\\)</span>。</p>\n<p>然后就是一个分讨，讨论这个人想要正面还是反面。很显然，对于同样的剩余棋子数，两个人先手的情况对于这颗棋子的喜爱程度是一样的。也就是说，要么都想要，要么都不想要。</p>\n<p>什么时候想要呢？拿掉过后自己胜率更大，也就是 <span class=\"math inline\">\\(g_{i-1}&gt;f_{i-1}\\)</span>。此时有：</p>\n<p><span class=\"math display\">\\[\nf_i=(1-p)\\times g_i+p\\times g_{i-1}\\\\\ng_i=(1-q)\\times f_i+q\\times f_{i-1}\n\\]</span></p>\n<p>发现是互相影响的，这个时候先不要着急怀疑自己推错了，因为我们这里有两个未知数，又刚好有两个方程，暴解一下就有：</p>\n<p><span class=\"math display\">\\[\nf_i=\\dfrac {(1-p)\\times q\\times f_{i-1}+p\\times g_{i-1}}{1-(1-p)(1-q)}\\\\\ng_i=\\dfrac {(1-q)\\times p\\times g_{i-1}+q\\times f_{i-1}}{1-(1-p)(1-q)}\n\\]</span></p>\n<p>然后 <span class=\"math inline\">\\(g_{i-1}&lt;f_{i-1}\\)</span> 的情况也差不多，把拿的概率和不拿的概率换一下：</p>\n<p><span class=\"math display\">\\[\nf_i=p\\times g_i+(1-p)\\times g_{i-1}\\\\\ng_i=q\\times f_i+(1-q)\\times f_{i-1}\n\\]</span></p>\n<p>解方程组有：</p>\n<p><span class=\"math display\">\\[\nf_i=\\dfrac {(1-q)\\times p\\times f_{i-1}+(1-p)\\times g_{i-1}}{1-p\\times q}\\\\\ng_i=\\dfrac {(1-p)\\times q\\times g_{i-1}+(1-q)\\times f_{i-1}}{1-p\\times q}\n\\]</span></p>\n<p>然后就可以开始 DP 了。最后的答案就是 <span class=\"math inline\">\\(f_{\\min(n,1000)}\\)</span>。</p>\n<p>还有个问题就是 <span class=\"math inline\">\\(n\\)</span> 特别大然后这个看起来也不太能矩乘，但是这个 DP 式有个好处是它的增长趋势是指数级的，所以我们 DP 到 <span class=\"math inline\">\\(1000\\)</span> 就可以了。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nnamespace XSC062 &#123;\nconst int maxn = 1e3 + 5;\nusing db = double;\ndb p, q;\nint T, n;\ndb f[maxn], g[maxn];\nint min(int x, int y) &#123;\n    return x &lt; y ? x : y;\n&#125;\nint main() &#123;\n    scanf(&quot;%d&quot;, &amp;T);\n    while (T--) &#123;\n        scanf(&quot;%d %lf %lf&quot;, &amp;n, &amp;p, &amp;q);\n        f[0] = .0, g[0] = 1.0;\n        for (int i = 1; i &lt;= n &amp;&amp; i &lt;= 1000; ++i) &#123;\n            if (g[i - 1] &gt; f[i - 1]) &#123;\n                f[i] = ((1 - p) * q * f[i - 1] + p * g[i - 1]) / (1 - (1 - p) * (1 - q));\n                g[i] = ((1 - q) * p * g[i - 1] + q * f[i - 1]) / (1 - (1 - p) * (1 - q));\n            &#125;\n            else &#123;\n                f[i] = ((1 - q) * p * f[i - 1] + (1 - p) * g[i - 1]) / (1 - p * q);\n                g[i] = ((1 - p) * q * g[i - 1] + (1 - q) * f[i - 1]) / (1 - p * q);\n            &#125;\n        &#125;\n        printf(&quot;%.6lf\\n&quot;, f[min(n, 1000)]);\n    &#125;\n    return 0;\n&#125;\n&#125; // namespace XSC062\nint main() &#123;\n    XSC062::main();\n    return 0;\n&#125;\n</code></pre>\n</details>\n",
            "tags": [
                "DP",
                "概率期望"
            ]
        }
    ]
}