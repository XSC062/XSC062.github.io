<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://xsc062.netlify.app</id>
    <title> â€¢ Posts by &#34;è´¹ç”¨æµ&#34; tag</title>
    <link href="https://xsc062.netlify.app" />
    <updated>2023-07-20T09:57:23.000Z</updated>
    <category term="å¹¶æŸ¥é›†" />
    <category term="æ–œç‡ä¼˜åŒ–" />
    <category term="æ‚¬çº¿æ³•" />
    <category term="å“ˆå¸Œ" />
    <category term="å­—å…¸æ ‘" />
    <category term="DP" />
    <category term="å•è°ƒé˜Ÿåˆ—" />
    <category term="åˆ†æ²»" />
    <category term="äºŒåˆ†å›¾" />
    <category term="CRT / exCRT" />
    <category term="æ’åˆ—ç»„åˆ" />
    <category term="ç½‘ç»œæµ" />
    <category term="è´¹ç”¨æµ" />
    <category term="äºŒåˆ†" />
    <category term="ä¸Šä¸‹ç•Œç½‘ç»œæµ" />
    <category term="å®¹æ–¥åŸç†" />
    <category term="çº¿æ®µæ ‘" />
    <category term="æ ‘çŠ¶æ•°ç»„" />
    <category term="åŒºé—´ DP" />
    <category term="æ„é€ " />
    <category term="æ•°æ®ç»“æ„" />
    <category term="Tarjan" />
    <category term="ä¸‹é¥­" />
    <category term="LCA" />
    <category term="å€å¢" />
    <category term="é¸½å·¢åŸç†" />
    <category term="æ¦‚ç‡æœŸæœ›" />
    <category term="è°ƒå’Œçº§æ•°" />
    <category term="å·®åˆ†" />
    <category term="æ€ç»´" />
    <category term="æ ‘å½¢ DP" />
    <category term="æœ€å°ç”Ÿæˆæ ‘" />
    <category term="SAM" />
    <category term="çŠ¶å‹" />
    <category term="åˆ†å—" />
    <category term="å¯æŒä¹…åŒ–" />
    <category term="ç¬›å¡å°”æ ‘" />
    <category term="é«˜ç»´å‰ç¼€å’Œ" />
    <category term="é—²è¯" />
    <category term="æ¬§æ‹‰å›è·¯" />
    <category term="æ ‘é“¾å‰–åˆ†" />
    <category term="é•¿é“¾å‰–åˆ†" />
    <category term="KMP" />
    <category term="border" />
    <category term="å­—ç¬¦ä¸²" />
    <category term="AC è‡ªåŠ¨æœº" />
    <category term="SA" />
    <category term="æ•°å­¦" />
    <category term="æ ‘ä¸Šå·®åˆ†" />
    <category term="FWT" />
    <category term="å †" />
    <category term="æ ‘çš„é‡å¿ƒ" />
    <category term="äºŒé¡¹å¼å®šç†" />
    <category term="äºŒé¡¹å¼åæ¼”" />
    <category term="è´ªå¿ƒ" />
    <category term="å‡æ‘Š" />
    <category term="è®¡æ•°" />
    <category term="ä¼˜åŒ–å»ºå›¾" />
    <category term="åæ‚”è´ªå¿ƒ" />
    <category term="è°ƒæ•´æ³•" />
    <category term="èƒŒåŒ…" />
    <category term="åšå¼ˆè®º" />
    <category term="DP ä¼˜åŒ–" />
    <category term="è™šæ ‘" />
    <category term="ç‚¹åˆ†æ²»" />
    <category term="WQS äºŒåˆ†" />
    <category term="é—µå¯å¤«æ–¯åŸºå’Œ" />
    <category term="slope trick" />
    <category term="å››è¾¹å½¢ä¸ç­‰å¼" />
    <category term="çŠ¶å‹ DP" />
    <category term="ç»„åˆæ•°å­¦" />
    <category term="æ”¯é…å¯¹" />
    <category term="DDP" />
    <category term="å®¹æ–¥" />
    <category term="Kruskal é‡æ„æ ‘" />
    <category term="é«˜ç²¾åº¦" />
    <category term="æœ€çŸ­è·¯" />
    <category term="æè¶…çº¿æ®µæ ‘" />
    <entry>
        <id>https://xsc062.netlify.app/20230720/</id>
        <title>è´¹ç”¨æµç»ƒä¹ </title>
        <link rel="alternate" href="https://xsc062.netlify.app/20230720/"/>
        <content type="html">&lt;p&gt;&lt;a href=&#34;http://222.180.160.110:61235/contest/3820&#34;&gt;è´¹ç”¨æµå…¥é—¨ç»ƒä¹ &lt;/a&gt;ã€‚&lt;/p&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;a.-è®¢è´§&#34;&gt;A. è®¢è´§&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;http://222.180.160.110:61235/contest/3820/problem/1&#34; class=&#34;uri&#34;&gt;http://222.180.160.110:61235/contest/3820/problem/1&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;è¿™ä¸ªå¸¦ç»§æ‰¿å…³ç³»çš„æ¨¡å‹å¾ˆç†Ÿæ‚‰ï¼Œæƒ³åˆ°äº† &lt;a href=&#34;https://www.cnblogs.com/XSC062/p/17548925.html&#34;&gt;çŒª&lt;/a&gt; é‚£ä¸€é¢˜ã€‚æ‰€ä»¥æˆ‘ä»¬è¯•ç€ä»¿ç…§è¿™ä¸ªæ–¹å¼æ¥å»ºå›¾ã€‚&lt;/p&gt;
&lt;p&gt;é¢˜ç›®æåˆ°äº†å•ä½è´¹ç”¨ï¼Œè¿™ç®€ç›´å°±æ˜¯ç›´æ¥æŠŠè¾¹çš„è´¹ç”¨æ‹ä½ è„¸ä¸Šå˜²è®½ã€‚&lt;/p&gt;
&lt;p&gt;æˆ‘ä»¬æ‹‰ä¸€ä¸ªå¤§æºç‚¹ï¼Œæœæ¯ä¸ªæœˆè¿ä¸€æ¡å®¹é‡ä¸ºæ— ç©·å¤§ã€è´¹ç”¨ä¸ºå½“æœˆè´­ä¹°å•ä½è´¹ç”¨çš„è¾¹ï¼Œè¡¨ç¤ºæ¯ä¸ªæœˆçš„è´­ä¹°ã€‚&lt;/p&gt;
&lt;p&gt;æ‹‰ä¸€ä¸ªå¤§æ±‡ç‚¹ï¼Œæ¯ä¸ªæœˆæœå®ƒè¿ä¸€æ¡å®¹é‡ä¸ºå½“æœˆéœ€æ±‚é‡ã€è´¹ç”¨ä¸º &lt;span class=&#34;math inline&#34;&gt;\(0\)&lt;/span&gt; çš„è¾¹ï¼Œè¡¨ç¤ºæ¯ä¸ªæœˆçš„éœ€æ±‚ã€‚&lt;/p&gt;
&lt;p&gt;å†è®©æ¯ä¸ªæœˆæœä¸‹ä¸€ä¸ªæœˆè¿ä¸€æ¡å®¹é‡ä¸ºä»“åº“å®¹é‡ã€è´¹ç”¨ä¸ºè´®å­˜è´¹ç”¨çš„è¾¹ï¼Œè¡¨ç¤ºç»§æ‰¿ã€‚è·‘ä¸€ä¸ªæœ€å°è´¹ç”¨æœ€å¤§æµå³å¯ã€‚&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#define int long long
namespace XSC062 &amp;#123;
using namespace fastIO;
const int maxn = 405;
const int inf = 1e18;
const int maxm = 5e5 + 5;
struct _ &amp;#123;
    int v, c, w, n;
    _() &amp;#123;&amp;#125;
    _(int v1, int c1, int w1, int n1) &amp;#123;
        v = v1, c = c1, w = w1, n = n1;
    &amp;#125;
&amp;#125;;
_ u[maxm];
bool inq[maxn];
int n, m, S, x, res;
int gs, gt, tot = 1;
int h[maxn], dis[maxn];
int fl[maxn], pre[maxn];
int min(int x, int y) &amp;#123;
    return x &amp;lt; y ? x : y;
&amp;#125;
bool SPFA(int s, int n) &amp;#123;
    std::queue&amp;lt;int&amp;gt; q;
    std::fill(dis + 1, dis + n + 1, inf);
    q.push(s), dis[s] = 0, inq[s] = 1;
    pre[s] = inf, pre[gt] = 0, fl[s] = inf;
    while (!q.empty()) &amp;#123;
        int f = q.front();
        q.pop(), inq[f] = 0;
        for (int i = h[f]; i; i = u[i].n) &amp;#123;
            if (u[i].c == 0)
                continue;
            int v = u[i].v, w = u[i].w;
            if (dis[v] &amp;gt; dis[f] + w) &amp;#123;
                pre[v] = i ^ 1;
                dis[v] = dis[f] + w;
                fl[v] = min(fl[f], u[i].c);
                if (!inq[v])
                    inq[v] = 1, q.push(v);
            &amp;#125;
        &amp;#125;
    &amp;#125;
    return pre[gt];
&amp;#125;
void SSP(int s, int n) &amp;#123;
    int p, mn, d;
    while (SPFA(s, n)) &amp;#123;
        mn = fl[gt], d = 0;
        for (p = gt; p != s; p = u[pre[p]].v) &amp;#123;
            u[pre[p]].c += mn;
            u[pre[p] ^ 1].c -= mn;
            d += u[pre[p] ^ 1].w;
        &amp;#125;
        res += mn * d;
    &amp;#125;
    return;
&amp;#125;
void add(int x, int y, int c, int w) &amp;#123;
    u[++tot] = _(y, c, w, h[x]);
    h[x] = tot;
    return;
&amp;#125;
void addf(int x, int y, int c, int w) &amp;#123;
    add(x, y, c, w), add(y, x, 0, -w);
    return;
&amp;#125;
int main() &amp;#123;
    read(n), read(m), read(S);
    gs = n + 1, gt = gs + 1;
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        read(x);
        addf(i, gt, x, 0);
        if (i != n)
            addf(i, i + 1, S, m);
    &amp;#125;
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        read(x);
        addf(gs, i, inf, x);
    &amp;#125;    
    SSP(gs, gt);
    print(res, &amp;#39;\n&amp;#39;);
    return 0;
&amp;#125;
&amp;#125; // namespace XSC062
#undef int  &lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;b.-ç½‘ç»œæ‰©å®¹&#34;&gt;B. ç½‘ç»œæ‰©å®¹&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;http://222.180.160.110:61235/contest/3820/problem/2&#34; class=&#34;uri&#34;&gt;http://222.180.160.110:61235/contest/3820/problem/2&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;é‰´äºä¸€é“è´¹ç”¨æµä¸ä¼šæ— ç¼˜æ— æ•…å…ˆè®©ä½ æ±‚ä¸€éæœ€å¤§æµï¼Œæˆ‘ä»¬å…ˆæŒè§‚æœ›æ€åº¦ï¼Œæš‚ä¸”è®¤ä¸ºæœ€å¤§æµå¯¹é¢˜ç›®æœ‰æç¤ºä½œç”¨ &lt;del&gt;è€Œä¸æ˜¯è¯´è¿™é“é¢˜å°±æ˜¯ä¸ªç¼åˆæ€ª&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;å…¶å®çœ‹å®Œé¢˜æˆ‘ä»¬å°±æ‚Ÿäº†ï¼Œè¿™æ€ä¹ˆè¿™ä¹ˆåƒä¸Šä¸‹ç•Œç½‘ç»œæµé‚£ä¸ªå·®é‡ç½‘ç»œå‘€ï¼Œè¦ä¸æˆ‘ä»¬è¯•è¯•è¿™ä¹ˆå¹²ï¼Ÿ&lt;/p&gt;
&lt;p&gt;æˆ‘ä»¬å…ˆæ±‚å¾—æ™®é€šç½‘ç»œä¸­çš„æœ€å¤§æµï¼Œç„¶åæ¯æ¡è¾¹å‡å»æµé‡ï¼Œå°±æˆä¸ºäº†ä¸€ä¸ªã€Œå·®é‡ç½‘ç»œ Proã€ã€‚é‚£ä¹ˆæˆ‘ä»¬ç°åœ¨å°±è¦é€šè¿‡æ‰©å®¹è®©è¯¥ç½‘ç»œä¸­çš„æœ€å¤§æµå˜ä¸º &lt;span class=&#34;math inline&#34;&gt;\(K\)&lt;/span&gt;ã€‚å¯¹äºæ‰©å®¹çš„æ“ä½œï¼Œä¸éš¾æƒ³åˆ°æŠŠæ¯æ¡è¾¹çš„è¾¹æƒè®¾ä¸ºæ­£æ— ç©·ï¼Œç„¶åè´¹ç”¨è®¾ä¸ºæ‰©å®¹è´¹ç”¨ã€‚&lt;/p&gt;
&lt;p&gt;ç°åœ¨æœ‰äº†ä¸€ä¸ªé—®é¢˜ï¼šåŸå›¾ä¸­æœªç•™æ»¡çš„è¾¹ï¼Œåœ¨ç°åœ¨çš„æ–°ç½‘ç»œä¸­çš„æ®‹ä½™å®¹é‡åº”è¯¥å¦‚ä½•å¤„ç†å‘¢ï¼Ÿå¾ˆç®€å•ï¼Œæˆ‘ä»¬å°±æŠŠå®ƒå½“ä½œå·²ç»æ‰©è¿‡äº†è¿™ä¹ˆå¤šå®¹ï¼Œé€šè¿‡æ‹†è¾¹æ“ä½œæ‹†å‡ºæ¥ä¸€æ¡å®¹é‡ä¸ºåŸå›¾ä¸­æ®‹ä½™å®¹é‡ã€è´¹ç”¨ä¸º &lt;span class=&#34;math inline&#34;&gt;\(0\)&lt;/span&gt;ã€Œä¼šå‘˜é€šé“ã€ï¼Œé‚£ä¹ˆç®—æ³•å°±ä¼šä¼˜å…ˆé€‰æ‹©è¿™æ¡è¾¹ã€‚&lt;/p&gt;
&lt;p&gt;æ€ä¹ˆå»æ§åˆ¶æµé‡ä¸º &lt;span class=&#34;math inline&#34;&gt;\(K\)&lt;/span&gt;ï¼Ÿè”æƒ³åˆ°ä¹‹å‰çš„æ‹†è¾¹æ“ä½œï¼Œæˆ‘ä»¬è€ƒè™‘æ‹†ç‚¹ã€‚åœ¨ &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt; å’Œ &lt;span class=&#34;math inline&#34;&gt;\(N\)&lt;/span&gt; ä¸­ä»»é€‰ä¸€ä¸ªæ‹†å¼€ä½œä¸ºæ–°çš„æºç‚¹ / æ±‡ç‚¹ï¼Œæ–°ç‚¹å’Œæ—§ç‚¹ä¹‹é—´çš„å®¹é‡ä¸º &lt;span class=&#34;math inline&#34;&gt;\(K\)&lt;/span&gt;ã€è´¹ç”¨ä¸º &lt;span class=&#34;math inline&#34;&gt;\(0\)&lt;/span&gt; å³å¯ã€‚&lt;/p&gt;
&lt;p&gt;ç„¶åè·‘ä¸€ä¸ªæœ€å°è´¹ç”¨æœ€å¤§æµå°±è¡Œã€‚&lt;del&gt;è¯¥è¯´ä¸è¯´é¢˜ç›®çš„æ­£è§£æ€è·¯å¼•å¯¼åšå¾—è¿˜æŒºå¥½çš„&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;å…¶å®æ³¨æ„åˆ°åœ¨è·‘å®Œæœ€å¤§æµä¹‹åï¼Œæ‰€æœ‰æ­£å‘è¾¹çš„æ®‹ä½™å®¹é‡å·²ç»æ±‚å¾—ï¼Œåªè¦åœ¨è·‘æœ€å¤§æµæ—¶ä»¤æ‰€æœ‰è¾¹çš„è´¹ç”¨ä¸º &lt;span class=&#34;math inline&#34;&gt;\(0\)&lt;/span&gt;ï¼ˆæ¯•ç«Ÿæœ€å¤§æµä¸å…³å¿ƒè´¹ç”¨ï¼‰ï¼Œå°±å¯ä»¥æ²¿ç”¨åŸå›¾ï¼ŒåªåŠ æ–°è¾¹å†è·‘è´¹ç”¨æµã€‚&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#define int long long
namespace XSC062 &amp;#123;
using namespace fastIO;
const int inf = 1e18;
const int maxn = 1e3 + 5;
const int maxm = 5e5 + 5;
struct _ &amp;#123;
    int v, c, w, n;
    _() &amp;#123;&amp;#125;
    _(int v1, int c1, int w1, int n1) &amp;#123;
        v = v1, c = c1, w = w1, n = n1;
    &amp;#125;
&amp;#125;;
struct __ &amp;#123; int x, y, c, w; &amp;#125;;
_ u[maxm];
__ w[maxm];
bool inq[maxn];
int n, m, k, res;
int gs, gt, tot = 1;
int h[maxn], dis[maxn];
int fl[maxn], pre[maxn];
int vis[maxn], now[maxn], dep[maxn];
int min(int x, int y) &amp;#123;
    return x &amp;lt; y ? x : y;
&amp;#125;
bool BFS(int n) &amp;#123;
    std::fill(vis + 1, vis + n + 1, 0);
    std::fill(dep + 1, dep + n + 1, 0); 
    std::queue&amp;lt;int&amp;gt; q;
    dep[gs] = 1, vis[gs] = 1;
    q.push(gs), now[gs] = h[gs];
    while (!q.empty()) &amp;#123;
        int f = q.front();
        q.pop();
        for (int i = h[f]; i; i = u[i].n) &amp;#123;
            int v = u[i].v, w = u[i].c;
            if (vis[v] == 1 || w == 0)
                continue;
            vis[v] = 1, now[v] = h[v];
            dep[v] = dep[f] + 1, q.push(v);
            if (v == gt)
                return 1;
        &amp;#125;
    &amp;#125;
    return 0;
&amp;#125;
int findP(int x, int flow = inf) &amp;#123;
    if (x == gt)
        return flow;
    int rest = flow, i;
    for (i = now[x]; rest &amp;amp;&amp;amp; i; i = u[i].n) &amp;#123;
        int v = u[i].v, w = u[i].c;
        now[x] = i;
        if (dep[v] != dep[x] + 1 || w == 0)
            continue;
        int t = findP(v, min(rest, w));
        if (t == 0)
            dep[v] = 0;
        rest -= t;
        u[i].c -= t, u[i ^ 1].c += t;
    &amp;#125;
    return flow - rest;
&amp;#125;
int Dinic(int n) &amp;#123;
    int res = 0;
    while (BFS(n)) &amp;#123;
        int t = findP(gs);
        while (t) &amp;#123;
            res += t;
            t = findP(gs);
        &amp;#125;
    &amp;#125;
    return res;
&amp;#125;
bool SPFA(int s, int n) &amp;#123;
    std::queue&amp;lt;int&amp;gt; q;
    std::fill(dis + 1, dis + n + 1, inf);
    q.push(s), dis[s] = 0, inq[s] = 1;
    pre[s] = inf, pre[gt] = 0, fl[s] = inf;
    while (!q.empty()) &amp;#123;
        int f = q.front();
        q.pop(), inq[f] = 0;
        for (int i = h[f]; i; i = u[i].n) &amp;#123;
            if (u[i].c == 0)
                continue;
            int v = u[i].v, w = u[i].w;
            if (dis[v] &amp;gt; dis[f] + w) &amp;#123;
                pre[v] = i ^ 1;
                dis[v] = dis[f] + w;
                fl[v] = min(fl[f], u[i].c);
                if (!inq[v])
                    inq[v] = 1, q.push(v);
            &amp;#125;
        &amp;#125;
    &amp;#125;
    return pre[gt];
&amp;#125;
void SSP(int s, int n) &amp;#123;
    int p, mn, d;
    while (SPFA(s, n)) &amp;#123;
        mn = fl[gt], d = 0;
        for (p = gt; p != s; p = u[pre[p]].v) &amp;#123;
            u[pre[p]].c += mn;
            u[pre[p] ^ 1].c -= mn;
            d += u[pre[p] ^ 1].w;
        &amp;#125;
        res += mn * d;
    &amp;#125;
    return;
&amp;#125;
void add(int x, int y, int c, int w) &amp;#123;
    u[++tot] = _(y, c, w, h[x]);
    h[x] = tot;
    return;
&amp;#125;
void addf(int x, int y, int c, int w = 0) &amp;#123;
    add(x, y, c, w), add(y, x, 0, -w);
    return;
&amp;#125;
int main() &amp;#123;
    read(n), read(m), read(k);
    gs = 1, gt = n;
    for (int i = 1; i &amp;lt;= m; ++i) &amp;#123;
        read(w[i].x), read(w[i].y);
        read(w[i].c), read(w[i].w);
        addf(w[i].x, w[i].y, w[i].c);
    &amp;#125;
    print(Dinic(n), &amp;#39; &amp;#39;);
    gs = n + 1, addf(gs, 1, k, 0);
    for (int i = 1; i &amp;lt;= m; ++i)
        addf(w[i].x, w[i].y, inf, w[i].w);
    SSP(gs, gt);
    print(res, &amp;#39;\n&amp;#39;);
    return 0;
&amp;#125;
&amp;#125; // namespace XSC062
#undef int&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;c.-èˆªç­å®‰æ’&#34;&gt;C. èˆªç­å®‰æ’&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;http://222.180.160.110:61235/contest/3820/problem/3&#34; class=&#34;uri&#34;&gt;http://222.180.160.110:61235/contest/3820/problem/3&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;å¾ˆç®€å•ä¸€ä¸ªé“ç†ï¼Œæ—¶é—´çš„å…·ä½“å€¼å¯¹æˆ‘ä»¬æ¥è¯´å¹¶ä¸é‡è¦ã€‚èƒ½åˆ°å°±æ˜¯èƒ½åˆ°ï¼Œä¸èƒ½åˆ°å°±æ˜¯ä¸èƒ½åˆ°ã€‚&lt;/p&gt;
&lt;p&gt;è¾¹æƒçŸ©é˜µä¹Ÿå¹¶ä¸æ˜¯å…¨éƒ¨æœ‰ç”¨ï¼Œè¿™æ¡è¾¹å’Œä»»åŠ¡æœ‰å…³ç³»å—ï¼Ÿæ²¡æœ‰ï¼Œé‚£å°±å½“å®ƒæ˜¯ç©ºæ°”ã€‚&lt;/p&gt;
&lt;p&gt;é‚£ä»€ä¹ˆä¼šå¯¹æˆ‘ä»¬äº§ç”Ÿé™åˆ¶ï¼Ÿé£æœºæ•°é‡ã€‚æ•…å®¹é‡ç”±é£æœºæ•°é‡å†³å®šã€‚ä»€ä¹ˆæ˜¯æˆ‘ä»¬è¦æœ€å¤§åŒ–çš„å€¼ï¼Ÿæ”¶ç›Šï¼Œæ•…æˆ‘ä»¬çš„è´¹ç”¨æ˜¯æ”¯å‡ºã€‚&lt;/p&gt;
&lt;p&gt;å¦‚æœé£æœºèƒ½åœ¨ä¸€ä¸ªä»»åŠ¡ç»“æŸä¹‹åï¼Œåœ¨å¦ä¸€ä¸ªä»»åŠ¡å¼€å§‹ä¹‹å‰é£è¿‡å»ï¼Œé‚£å°±å°†ä¸¤ä¸ªä»»åŠ¡è¿è¾¹ï¼Œå®¹é‡ä¸º &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt;ï¼Œè´¹ç”¨ä¸ºä¸¤ç‚¹é—´èŠ±è´¹ã€‚ç‰¹åˆ«åœ°ï¼Œåº”å°†æœºåœºæ‹†ä¸ºå¤§æºç‚¹å’Œå¤§æ±‡ç‚¹ï¼Œå¹¶åœ¨äºŒè€…ä¸­ä»»é€‰å…¶ä¸€æ‹†ç‚¹ï¼ˆå’Œ T2 ç±»ä¼¼ï¼‰ï¼Œå¥½ä½œå‡º &lt;span class=&#34;math inline&#34;&gt;\(K\)&lt;/span&gt; çš„æµé‡é™åˆ¶ã€‚&lt;/p&gt;
&lt;p&gt;è¿˜æœ‰ä¸€ä¸ªå°ç»†èŠ‚ï¼Œå¯¹äºä¸€ä¸ªä»»åŠ¡çš„æµé‡æˆ‘ä»¬ä¹Ÿè¦åŠ ä»¥çº¦æŸï¼Œä¸ç„¶ç¢°åˆ°æµå…¥ &lt;span class=&#34;math inline&#34;&gt;\(2\)&lt;/span&gt; æµå‡º &lt;span class=&#34;math inline&#34;&gt;\(2\)&lt;/span&gt; è¿™ç§å¹³è¡¡ä½†ä¸åˆæ³•çš„æƒ…å†µå°±ä¸è¡Œäº†ï¼Œæ‰€ä»¥å¯¹äºä»»åŠ¡æˆ‘ä»¬ä¹Ÿè¦æŒ‰è€å¥—è·¯æ‹†ç‚¹ã€‚&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#define int long long
namespace XSC062 &amp;#123;
using namespace fastIO;
const int inf = 1e18;
const int maxn = 405;
const int maxm = 4e5 + 5;
struct _ &amp;#123;
    int v, c, w, n;
    _() &amp;#123;&amp;#125;
    _(int v1, int c1, int w1, int n1) &amp;#123;
        v = v1, c = c1, w = w1, n = n1;
    &amp;#125;
&amp;#125;;
struct __ &amp;#123;
    int x, y, l, r, c;
    bool operator&amp;lt; (const __ &amp;amp;q) const &amp;#123;
        return l &amp;lt; q.l;
    &amp;#125;
&amp;#125;;
_ u[maxm];
__ w[maxn];
bool inq[maxn];
int gs, gt, tot = 1;
int h[maxn], dis[maxn];
int fl[maxn], pre[maxn];
int n, m, k, T, res, fs, ft;
int t[maxn][maxn], f[maxn][maxn];
int min(int x, int y) &amp;#123;
    return x &amp;lt; y ? x : y;
&amp;#125;
bool SPFA(int s, int n) &amp;#123;
    std::queue&amp;lt;int&amp;gt; q;
    std::fill(dis + 1, dis + n + 1, inf);
    q.push(s), dis[s] = 0, inq[s] = 1;
    pre[s] = inf, pre[gt] = 0, fl[s] = inf;
    while (!q.empty()) &amp;#123;
        int f = q.front();
        q.pop(), inq[f] = 0;
        for (int i = h[f]; i; i = u[i].n) &amp;#123;
            if (u[i].c == 0)
                continue;
            int v = u[i].v, w = u[i].w;
            if (dis[v] &amp;gt; dis[f] + w) &amp;#123;
                pre[v] = i ^ 1;
                dis[v] = dis[f] + w;
                fl[v] = min(fl[f], u[i].c);
                if (!inq[v])
                    inq[v] = 1, q.push(v);
            &amp;#125;
        &amp;#125;
    &amp;#125;
    return pre[gt];
&amp;#125;
void SSP(int s, int n) &amp;#123;
    int p, mn, d;
    while (SPFA(s, n)) &amp;#123;
        mn = fl[gt], d = 0;
        for (p = gt; p != s; p = u[pre[p]].v) &amp;#123;
            u[pre[p]].c += mn;
            u[pre[p] ^ 1].c -= mn;
            d += u[pre[p] ^ 1].w;
        &amp;#125;
        res += mn * d;
    &amp;#125;
    return;
&amp;#125;
void add(int x, int y, int c, int w) &amp;#123;
    u[++tot] = _(y, c, w, h[x]);
    h[x] = tot;
    return;
&amp;#125;
void addf(int x, int y, int c, int w) &amp;#123;
    add(x, y, c, w), add(y, x, 0, -w);
    return;
&amp;#125;
int main() &amp;#123;
    read(n), read(m), read(k), read(T);
    fs = 2 * m + 1, ft = 2 * m + 2;
    gs = 2 * m + 3, gt = 2 * m + 4;
    addf(gs, fs, k, 0), addf(ft, gt, k, 0);
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        for (int j = 1; j &amp;lt;= n; ++j)
            read(t[i][j]);
    &amp;#125;
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        for (int j = 1; j &amp;lt;= n; ++j)
            read(f[i][j]);
    &amp;#125;
    for (int i = 1; i &amp;lt;= m; ++i) &amp;#123;
        read(w[i].x), read(w[i].y);
        read(w[i].l), read(w[i].r);
        read(w[i].c), ++w[i].x, ++w[i].y;
    &amp;#125;
    for (int i = 1; i &amp;lt;= m; ++i) &amp;#123;
        addf(i + m, i, 1, 0);
        if (t[1][w[i].x] &amp;lt;= w[i].l) &amp;#123;
            addf(fs, i + m, 1,
                f[1][w[i].x] - w[i].c);
        &amp;#125;
        if (w[i].r + t[w[i].y][1] &amp;lt;= T)
            addf(i, ft, 1, f[w[i].y][1]);
        for (int j = 1; j &amp;lt;= m; ++j) &amp;#123;
            if (i != j &amp;amp;&amp;amp; w[i].r +
                t[w[i].y][w[j].x] &amp;lt;= w[j].l) &amp;#123;
                addf(i, j + m, 1,
                    f[w[i].y][w[j].x] - w[j].c);
            &amp;#125;
        &amp;#125;
    &amp;#125;
    SSP(gs, gt);
    print(-res, &amp;#39;\n&amp;#39;);
    return 0;
&amp;#125;
&amp;#125; // namespace XSC062
#undef int&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;d.-ä¿®è½¦&#34;&gt;D. ä¿®è½¦&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;http://222.180.160.110:61235/contest/3820/problem/4&#34; class=&#34;uri&#34;&gt;http://222.180.160.110:61235/contest/3820/problem/4&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;é¡¾å®¢æ•°ä¸€å®šï¼Œæ‰€è°“å¹³å‡ç­‰å¾…æ—¶é—´ä¸è¿‡æ˜¯ä¸ªå¹Œå­ï¼Œåªéœ€è¦æ±‚å¾—æœ€å°ç­‰å¾…æ€»æ—¶é—´ã€‚&lt;/p&gt;
&lt;p&gt;æŠ€æœ¯äººå‘˜ä¸èƒ½åŒæ—¶ä¿®ä¸¤è¾†è½¦ï¼Œ&lt;span class=&#34;math inline&#34;&gt;\(M\)&lt;/span&gt; çš„èŒƒå›´åˆè¿™ä¹ˆå°ï¼Œä¸å¾€æ‹†ç‚¹æƒ³éƒ½éš¾ã€‚å¯é—®é¢˜æ¥äº†ï¼Œæ€ä¹ˆæ‹†å‘¢ï¼Ÿ&lt;/p&gt;
&lt;p&gt;æˆ‘ä¸€å¼€å§‹çš„æƒ³æ³•æ˜¯ï¼Œç”¨ç‚¹ &lt;span class=&#34;math inline&#34;&gt;\((i, j)\)&lt;/span&gt; è¡¨ç¤ºäºº &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; ä¿®è½¦ &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt;ï¼Œä½†æ˜¯è¿™æ ·å»ºå›¾æ€æ ·ä¹Ÿæ— æ³•è¾¾åˆ°ç›®çš„ã€‚&lt;/p&gt;
&lt;p&gt;äºæ˜¯æˆ‘æ·»åŠ äº†ä¸€ä¸ªç»´åº¦ &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt;ï¼Œç”¨ç‚¹ &lt;span class=&#34;math inline&#34;&gt;\((i, j, k)\)&lt;/span&gt; è¡¨ç¤ºäºº &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; ä¿®è½¦ &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt;ï¼Œå¹¶ä¸”è¿™æ˜¯ä»–ä¿®çš„å€’æ•°ç¬¬ &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; è¾†è½¦ï¼Œè¿™æ ·å»ºå›¾å°±è½»è€Œæ˜“ä¸¾äº†ã€‚ä½†æ¥ä¸‹æ¥å°±é¢ä¸´äº†ä¸€ä¸ªé—®é¢˜ï¼šè¿™æ•°æ®èŒƒå›´è·‘ä¸è¿‡ã€‚äºæ˜¯ä¹å®¡è§†æˆ‘ä»¬çš„ç‚¹ï¼Œå…¶å® &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; è¿™ä¸ªç»´åº¦æ˜¯å¯ä»¥è¢«åˆå¹¶çš„ï¼Œåªä¿ç•™ &lt;span class=&#34;math inline&#34;&gt;\((i, k)\)&lt;/span&gt;ï¼Œå› ä¸ºä¸å¯èƒ½å­˜åœ¨ä¸¤è¾†è½¦åŒæ—¶ä¸ºäºº &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; çš„å€’æ•°ç¬¬ &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; è¾†è½¦ã€‚&lt;/p&gt;
&lt;p&gt;æ•…å°†å¤§æºç‚¹å’Œæ¯è¾†è½¦è¿è¾¹ï¼Œå®¹é‡ä¸º &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt;ï¼Œè´¹ç”¨ä¸º &lt;span class=&#34;math inline&#34;&gt;\(0\)&lt;/span&gt;ï¼›å°†æ¯è¾†è½¦ &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; å’Œæ¯ä¸ª &lt;span class=&#34;math inline&#34;&gt;\((i, k)\)&lt;/span&gt; è¿è¾¹ï¼Œå®¹é‡ä¸º &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt;ï¼Œè´¹ç”¨ä¸º &lt;span class=&#34;math inline&#34;&gt;\(T_{i, j}\times k\)&lt;/span&gt;ã€‚&lt;/p&gt;
&lt;p&gt;è¿™é‡Œæœ‰ä¸€ç‚¹ç‚¹è´¹ç”¨æå‰è®¡ç®—çš„æ„æ€ï¼Œæ‰€ä»¥å°±ç›´æ¥å°†æ¯ä¸ª &lt;span class=&#34;math inline&#34;&gt;\((i, j)\)&lt;/span&gt; å’Œå¤§æ±‡ç‚¹è¿è¾¹ï¼Œå®¹é‡ä¸º &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt;ï¼Œè´¹ç”¨ä¸º &lt;span class=&#34;math inline&#34;&gt;\(0\)&lt;/span&gt;ã€‚&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#define int long long
namespace XSC062 &amp;#123;
using namespace fastIO;
const int inf = 1e18;
const int maxn = 1e4 + 5;
const int maxm = 1e6 + 5;
struct _ &amp;#123;
    int v, c, w, n;
    _() &amp;#123;&amp;#125;
    _(int v1, int c1, int w1, int n1) &amp;#123;
        v = v1, c = c1, w = w1, n = n1;
    &amp;#125;
&amp;#125;;
_ u[maxm];
bool inq[maxn];
int n, m, x, res;
int gs, gt, tot = 1;
int h[maxn], dis[maxn];
int fl[maxn], pre[maxn];
int fun(int i, int j) &amp;#123;
    return n + (i - 1) * n + j;
&amp;#125;
int min(int x, int y) &amp;#123;
    return x &amp;lt; y ? x : y;
&amp;#125;
bool SPFA(int s, int n) &amp;#123;
    std::queue&amp;lt;int&amp;gt; q;
    std::fill(dis + 1, dis + n + 1, inf);
    q.push(s), dis[s] = 0, inq[s] = 1;
    pre[s] = inf, pre[gt] = 0, fl[s] = inf;
    while (!q.empty()) &amp;#123;
        int f = q.front();
        q.pop(), inq[f] = 0;
        for (int i = h[f]; i; i = u[i].n) &amp;#123;
            if (u[i].c == 0)
                continue;
            int v = u[i].v, w = u[i].w;
            if (dis[v] &amp;gt; dis[f] + w) &amp;#123;
                pre[v] = i ^ 1;
                dis[v] = dis[f] + w;
                fl[v] = min(fl[f], u[i].c);
                if (!inq[v])
                    inq[v] = 1, q.push(v);
            &amp;#125;
        &amp;#125;
    &amp;#125;
    return pre[gt];
&amp;#125;
void SSP(int s, int n) &amp;#123;
    int p, mn, d;
    while (SPFA(s, n)) &amp;#123;
        mn = fl[gt], d = 0;
        for (p = gt; p != s; p = u[pre[p]].v) &amp;#123;
            u[pre[p]].c += mn;
            u[pre[p] ^ 1].c -= mn;
            d += u[pre[p] ^ 1].w;
        &amp;#125;
        res += mn * d;
    &amp;#125;
    return;
&amp;#125;
void add(int x, int y, int c, int w) &amp;#123;
    u[++tot] = _(y, c, w, h[x]);
    h[x] = tot;
    return;
&amp;#125;
void addf(int x, int y, int c, int w) &amp;#123;
    add(x, y, c, w), add(y, x, 0, -w);
    return;
&amp;#125;
int main() &amp;#123;
    read(m), read(n);
    gs = n * m + n + 1, gt = gs + 1;
    for (int i = 1; i &amp;lt;= n; ++i)
        addf(gs, i, 1, 0);
    for (int i = 1; i &amp;lt;= n * m; ++i)
        addf(i + n, gt, 1, 0);
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        for (int j = 1; j &amp;lt;= m; ++j) &amp;#123;
            read(x);
            for (int k = 1; k &amp;lt;= n; ++k) &amp;#123;
                addf(i, fun(j, k),
                            1, x * k);
            &amp;#125;
        &amp;#125;
    &amp;#125;
    SSP(gs, gt);
    printf(&amp;quot;%.2lf&amp;quot;, res * 1.0 / n);
    return 0;
&amp;#125;
&amp;#125; // namespace XSC062
#undef int&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;e.-è¿è¿çœ‹&#34;&gt;E. è¿è¿çœ‹&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;http://222.180.160.110:61235/contest/3820/problem/5&#34; class=&#34;uri&#34;&gt;http://222.180.160.110:61235/contest/3820/problem/5&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;æ ·ä¾‹å·²ç»å‘Šè¯‰äº†æˆ‘ä»¬äº‹å®ï¼šå°å¿ƒåˆ æ•°ï¼Œå› ä¸ºä¼šæœ‰æ•°åŒæ—¶å‡ºç°åœ¨å¤šç»„å‹¾è‚¡æ•°ä¸­ã€‚&lt;/p&gt;
&lt;p&gt;è¿˜æ˜¯ç†Ÿæ‚‰çš„å•ç‚¹ &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt; æµé‡é™åˆ¶ï¼Œæ•…æ‹†ç‚¹ä¸ºå…¥ç‚¹å’Œå‡ºç‚¹ï¼Œå…¥ç‚¹è¿å¤§æºç‚¹å®¹é‡ä¸º &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt; è´¹ç”¨ä¸º &lt;span class=&#34;math inline&#34;&gt;\(0\)&lt;/span&gt;ï¼Œå‡ºç‚¹è¿å¤§æ±‡ç‚¹å®¹é‡ä¸º &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt; è´¹ç”¨ä¸º &lt;span class=&#34;math inline&#34;&gt;\(0\)&lt;/span&gt;ï¼Œæ»¡è¶³æ¡ä»¶çš„ &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; å’Œ &lt;span class=&#34;math inline&#34;&gt;\(y\)&lt;/span&gt; æˆ‘ä»¬ä¸ºäº†ä¸æ•´ç»†èŠ‚å°±æš´åŠ›åœ°è¿åŒå‘è¾¹ç„¶åè·‘æœ€å¤§è´¹ç”¨æœ€å¤§æµã€‚&lt;/p&gt;
&lt;p&gt;ç”±äºåŒå‘è¾¹è¿™ä¸ªç¥å¿…æ“ä½œï¼Œæœ€åçš„æœ€å¤§æµå’Œæœ€å¤§è´¹ç”¨éƒ½ä¼šç¿»å€ï¼Œè¾“å‡ºçš„æ—¶å€™è¦å‡åŠã€‚&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#define int long long
namespace XSC062 &amp;#123;
using namespace fastIO;
const int inf = 1e18;
const int maxn = 2e3 + 5;
const int maxm = 4e5 + 5;
struct _ &amp;#123;
    int v, c, w, n;
    _() &amp;#123;&amp;#125;
    _(int v1, int c1, int w1, int n1) &amp;#123;
        v = v1, c = c1, w = w1, n = n1;
    &amp;#125;
&amp;#125;;
_ u[maxm];
bool inq[maxn];
int l, r, res, cnt;
bool f[maxn][maxn];
int gs, gt, tot = 1;
int h[maxn], dis[maxn];
int fl[maxn], pre[maxn];
int gcd(int x, int y) &amp;#123;
    return y ? gcd(y, x % y) : x;
&amp;#125;
int min(int x, int y) &amp;#123;
    return x &amp;lt; y ? x : y;
&amp;#125;
bool SPFA(int s, int n) &amp;#123;
    std::queue&amp;lt;int&amp;gt; q;
    std::fill(dis + 1, dis + n + 1, -inf);
    q.push(s), dis[s] = 0, inq[s] = 1;
    pre[s] = inf, pre[gt] = 0, fl[s] = inf;
    while (!q.empty()) &amp;#123;
        int f = q.front();
        q.pop(), inq[f] = 0;
        for (int i = h[f]; i; i = u[i].n) &amp;#123;
            if (u[i].c == 0)
                continue;
            int v = u[i].v, w = u[i].w;
            if (dis[v] &amp;lt; dis[f] + w) &amp;#123;
                pre[v] = i ^ 1;
                dis[v] = dis[f] + w;
                fl[v] = min(fl[f], u[i].c);
                if (!inq[v])
                    inq[v] = 1, q.push(v);
            &amp;#125;
        &amp;#125;
    &amp;#125;
    return pre[gt];
&amp;#125;
void SSP(int s, int n) &amp;#123;
    int p, mn, d;
    while (SPFA(s, n)) &amp;#123;
        mn = fl[gt], d = 0;
        for (p = gt; p != s; p = u[pre[p]].v) &amp;#123;
            u[pre[p]].c += mn;
            u[pre[p] ^ 1].c -= mn;
            d += u[pre[p] ^ 1].w;
        &amp;#125;
        res += mn * d, cnt += mn;
    &amp;#125;
    return;
&amp;#125;
void add(int x, int y, int c, int w) &amp;#123;
    u[++tot] = _(y, c, w, h[x]);
    h[x] = tot;
    return;
&amp;#125;
void addf(int x, int y, int c, int w) &amp;#123;
    if (f[x][y])
        return;
    f[x][y] = f[y][x] = 1;
    add(x, y, c, w), add(y, x, 0, -w);
    return;
&amp;#125;
bool check(int x, int y) &amp;#123;
    int z = sqrt(x * x - y * y);
    if (z * z + y * y == x * x)
        return (gcd(z, y) == 1);
    return 0;
&amp;#125;
int main() &amp;#123;
    read(l), read(r);
    gs = 2 * r + 1, gt = 2 * r + 2;
    for (int i = l; i &amp;lt;= r; ++i) &amp;#123;
        addf(gs, i, 1, 0);
        addf(i + r, gt, 1, 0);
        for (int j = l; j &amp;lt; i; ++j) &amp;#123;
            if (check(i, j)) &amp;#123;
                addf(j, i + r, 1, i + j);
                addf(i, j + r, 1, i + j);
            &amp;#125;
        &amp;#125;
    &amp;#125;
    SSP(gs, gt);
    print(cnt / 2, &amp;#39; &amp;#39;), print(res / 2, &amp;#39;\n&amp;#39;);
    return 0;
&amp;#125;
&amp;#125; // namespace XSC062
#undef int&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;p&gt;ä¾æˆ‘çœ‹ï¼Œé˜Ÿåå°±å«ã€Œæ›¾æ€»è¯´çš„éƒ½é˜Ÿã€å§ ğŸµ&lt;/p&gt;
</content>
        <category term="ç½‘ç»œæµ" />
        <category term="è´¹ç”¨æµ" />
        <updated>2023-07-20T09:57:23.000Z</updated>
    </entry>
    <entry>
        <id>https://xsc062.netlify.app/20230717/</id>
        <title>å­¦ä¹ å°ç»„</title>
        <link rel="alternate" href="https://xsc062.netlify.app/20230717/"/>
        <content type="html">&lt;p&gt;Solution to &lt;a href=&#34;https://codeforces.com/problemset/problem/756/D&#34;&gt;CF756D Bacterial Melee&lt;/a&gt;ã€‚&lt;/p&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;
&lt;hr /&gt;
&lt;p&gt;ç»™æˆ‘æ•´ä¸ä¼šäº†ã€‚æ€ä¹ˆå¤„ç†å¹³æ–¹ï¼Ÿæ€ä¹ˆæ§åˆ¶å‚ä¸æ€»å­¦ç”Ÿæœ€å¤šï¼Ÿå…¶ä¸­ä¸€å®šåˆæœ‰ä»€ä¹ˆæˆ‘ä¸çŸ¥é“çš„å¥‡æŠ€æ·«å·§ã€‚&lt;/p&gt;
&lt;p&gt;ä¸€åˆ‡å°½åœ¨è¿è¾¹ã€‚&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;å¤„ç†å­¦ç”Ÿä¸ç¤¾å›¢é—´çš„é€‰æ‹©å…³ç³»&lt;/p&gt;
&lt;p&gt;æŠŠå­¦ç”Ÿå‘ç¤¾å›¢è¿è¾¹ã€‚å­¦ç”Ÿåªèƒ½é€‰å–æŸç¤¾å›¢ä¸€æ¬¡ï¼Œæ•…å®¹é‡ä¸º &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt;ã€‚&lt;/p&gt;
&lt;p&gt;ä¸€ä¸ªå­¦ç”Ÿé€‰å–æŸä¸ªç¤¾å›¢å¹¶ä¸ä¼šç«‹å³å¯¹æœ€ç»ˆèŠ±è´¹å¸¦æ¥å¯è®¡ç®—çš„å½±å“ï¼Œå› ä¸ºæœ€ç»ˆèŠ±è´¹ç”±è¯¥ç¤¾å›¢å‚ä¸çš„ &lt;strong&gt;æ‰€æœ‰å­¦ç”Ÿå¹³æ–¹æ•°&lt;/strong&gt; å†³å®šã€‚&lt;/p&gt;
æ•…è¿™ä¸€æ­¥æˆ‘ä»¬å…ˆä¸æ…Œè®¡ç®—ç¤¾å›¢çš„ä»£ä»·ï¼Œåªç®—å‚ä¸ç¤¾å›¢æœ¬èº«éœ€è¦çš„æ‰‹ç»­è´¹ &lt;span class=&#34;math inline&#34;&gt;\(F_i\)&lt;/span&gt;ã€‚ä½†æ˜¯éœ€è¦æ³¨æ„åˆ°æ‰‹ç»­è´¹æ˜¯è´¢åŠ¡éƒ¨çš„æ”¶å…¥è€Œéæ”¯å‡ºï¼Œæ•…å®é™…è¾¹æƒä¸º &lt;span class=&#34;math inline&#34;&gt;\(-F_i\)&lt;/span&gt;ï¼Œè®¡ç®—ç­”æ¡ˆæ—¶è§†ä½œè´Ÿæ”¯å‡ºï¼ˆæ˜æ˜¾ä¸ä¼šå› æ­¤è€Œäº§ç”Ÿè´Ÿç¯ï¼Œå› æ­¤å¯ä»¥æ”¾å¿ƒåŠ è¾¹ï¼‰ã€‚&lt;/li&gt;
&lt;li&gt;&lt;p&gt;å¤„ç†å­¦ç”Ÿçš„é€‰æ‹©æ•°é‡ä¸Šé™&lt;/p&gt;
&lt;p&gt;å­¦ç”Ÿæœ€å¤šåªèƒ½é€‰æ‹© &lt;span class=&#34;math inline&#34;&gt;\(K\)&lt;/span&gt; ä¸ªç¤¾å›¢ï¼Œä¸ºä¿è¯è¿™ä¸€ç‚¹ï¼Œæˆ‘ä»¬å°†æºç‚¹å‘å­¦ç”Ÿè¿è¾¹ï¼Œå®¹é‡ä¸º &lt;span class=&#34;math inline&#34;&gt;\(K\)&lt;/span&gt;ã€‚&lt;/p&gt;
å¾ˆæ˜æ˜¾ï¼Œä»£ä»·ä¹Ÿä¸åœ¨æ­¤å¤„è®¡ç®—ï¼Œæ•…ä»¤è´¹ç”¨ä¸º &lt;span class=&#34;math inline&#34;&gt;\(0\)&lt;/span&gt;ã€‚&lt;/li&gt;
&lt;li&gt;&lt;p&gt;ä¿è¯ä»£ä»·æœ€å°&lt;/p&gt;
&lt;p&gt;ä¸€å¼€å§‹ï¼Œæˆ‘è®¤ä¸ºæœ€å°è´¹ç”¨æœ€å¤§æµä¸€å®šä¼šæ‰¾åˆ°æœ€å°è´¹ç”¨ï¼Œè¿™ä¸ªå¤„ç†æ˜¯æ— æ„ä¹‰çš„ï¼Œåæ¥è¢«æ‰“è„¸äº†ã€‚&lt;/p&gt;
&lt;p&gt;æˆ‘ä»¬è‹¥æ¬²åœ¨æ­¤å›¾ä¸­å¯»å¾—æœ€å°è´¹ç”¨æœ€å¤§æµï¼Œåˆ™ &lt;strong&gt;æµä¸€å®šæœ€å¤§&lt;/strong&gt;ã€‚&lt;/p&gt;
&lt;p&gt;è€Œå­¦ç”Ÿçš„æµå…¥å®¹é‡ä¸º &lt;span class=&#34;math inline&#34;&gt;\(K\)&lt;/span&gt;ï¼Œä¸ºäº†æ»¡æµï¼Œå­¦ç”Ÿä¸€å®šä¼šå°½å¯èƒ½å¤šåœ°é€‰æ‹©ç¤¾å›¢ï¼Œé‚£ä¹ˆè´¹ç”¨å°±ä¼šå™Œå™Œä¸Šæ¶¨ã€‚å›åˆ°ç›®æ ‡ï¼Œå³ä¿è¯å­¦ç”Ÿéƒ½é€‰å–è‡³å°‘ä¸€ä¸ªç¤¾å›¢æ—¶ï¼Œæ”¯å‡ºæœ€å°ã€‚&lt;/p&gt;
&lt;p&gt;é‚£æˆ‘ä»¬åªè¦ç»™æœºä¼šè®©å­¦ç”Ÿå¯ä»¥åªé€‰å–ä¸€ä¸ªç¤¾å›¢å°±å¥½äº†ï¼ˆå½“ç„¶ä¹Ÿå¯ä»¥æ˜¯ä¸¤ä¸ªã€ä¸‰ä¸ªâ€¦â€¦ï¼‰ã€‚&lt;/p&gt;
&lt;p&gt;æ•…è®©å­¦ç”Ÿå‘ç»ˆç‚¹è¿è¾¹ï¼Œå®¹é‡ä¸º &lt;span class=&#34;math inline&#34;&gt;\(K-1\)&lt;/span&gt;ï¼Œé‚£ä¹ˆå­¦ç”Ÿå¯ä»¥åœ¨é€‰å–äº†æ‰€æœ‰æ¯”è¾ƒèµšçš„ç¤¾å›¢åå°±ä¸å†é€‰äº†ï¼Œé€‰è¿™æ¡è¾¹è¾¾åˆ°æ»¡æµã€‚åŒæ ·å› ä¸ºè¯¥è¾¹æµé‡åªæœ‰ &lt;span class=&#34;math inline&#34;&gt;\(K-1\)&lt;/span&gt;ï¼Œå­¦ç”Ÿä¸ºäº†æ»¡æµå°±åªèƒ½å†é€‰è‡³å°‘ä¸€ä¸ªç¤¾å›¢ï¼Œæ»¡è¶³é¢˜æ„ã€‚&lt;/p&gt;
ä¸é€‰ç¤¾å›¢æ˜æ˜¾æ˜¯æ²¡æœ‰æ‰‹ç»­è´¹å’Œç¤¾å›¢æ”¯å‡ºçš„ï¼Œæ•…è´¹ç”¨ä¸º &lt;span class=&#34;math inline&#34;&gt;\(0\)&lt;/span&gt;ã€‚&lt;/li&gt;
&lt;li&gt;&lt;p&gt;å¤„ç†ç¤¾å›¢æœ¬èº«æ”¯å‡º&lt;/p&gt;
&lt;p&gt;é—®é¢˜åœ¨äºå¦‚ä½•å¤„ç† &lt;span class=&#34;math inline&#34;&gt;\(a\)&lt;/span&gt; è¿™ä¸ªå¹³æ–¹é¡¹ã€‚&lt;/p&gt;
&lt;p&gt;å¯¹äºå¹³æ–¹ï¼Œæˆ‘ä»¬å¯ä»¥è”æƒ³åˆ°è®¸å¤šæ•°å­¦çŸ¥è¯†ï¼Œè­¬å¦‚å®Œå…¨å¹³æ–¹ã€å¹³æ–¹å·®ç­‰ï¼Œè¿™é‡Œç”¨åˆ°äº†å¹³æ–¹å·®ã€‚&lt;/p&gt;
&lt;p&gt;å‡å¦‚åŸæ¥çš„ä»£ä»·æ˜¯ &lt;span class=&#34;math inline&#34;&gt;\(C_i\times x^2\)&lt;/span&gt;ï¼ŒåˆåŠ å…¥äº†ä¸€ä¸ªäººï¼Œé‚£ä¹ˆè´¹ç”¨ä¼šå˜æˆ &lt;span class=&#34;math inline&#34;&gt;\(C_i\times (x + 1)^2\)&lt;/span&gt;ã€‚ç”±å¹³æ–¹å·®å¾—ä¸¤è€…ä¹‹å·®ä¸º &lt;span class=&#34;math inline&#34;&gt;\(C_i\times (2\times x + 1)\)&lt;/span&gt;ã€‚å½“ &lt;span class=&#34;math inline&#34;&gt;\(x - 1\)&lt;/span&gt; å–ä¸ºä»»æ„æ­£æ•´æ•°æ—¶ï¼Œ&lt;span class=&#34;math inline&#34;&gt;\(2\times x + 1\)&lt;/span&gt; å³ä¸ºæ‰€æœ‰å¥‡æ•°ã€‚&lt;/p&gt;
&lt;p&gt;æ‰€ä»¥æˆ‘ä»¬å°†ç¤¾å›¢å‘æ±‡ç‚¹è¿è¾¹ï¼Œè¿å¾ˆå¤šæ¡è¾¹ï¼Œæ¯æ¡è¾¹è¡¨ç¤º &lt;strong&gt;æ–°å¢ä¸€ä¸ªå›¢å‘˜çš„ä»£ä»·&lt;/strong&gt;ï¼Œå®¹é‡ä¸º &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt; è¡¨ç¤ºä¸€ä¸ªæ–°å¢å›¢å‘˜ï¼Œè´¹ç”¨ä¸ºä» &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt; å¼€å§‹ï¼Œä¸€ç›´åˆ° &lt;span class=&#34;math inline&#34;&gt;\(2\times (N - 1) + 1\)&lt;/span&gt; çš„æ‰€æœ‰å¥‡æ•°ã€‚&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;é‚£ä¹ˆé—®é¢˜åˆ°è¿™é‡Œå°±ç®—å¤„ç†å®Œäº†ã€‚ç›´æ¥ä¸Šè´¹ç”¨æµå³å¯ã€‚&lt;/p&gt;
&lt;p&gt;ä¸çŸ¥é“æˆ‘çš„ä»£ç é­é‡äº†å“ªå®¶å®‡å®™å°„çº¿çš„ä¾µèš€ï¼ŒDinic æ­»æ´»è¿‡ä¸å»ï¼Œæ¢æˆ EK å°±è¿‡äº†ã€‚åŒå­¦ä»¬å¦‚æœå‘ç°è‡ªå·±çš„ Dinic è¿‡ä¸äº†ä¹Ÿå¯ä»¥è¯•è¯•æ¢ EKã€‚&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#define int long long
namespace XSC062 &amp;#123;
using namespace fastIO;
const int maxn = 405;
const int inf = 1e18;
const int maxm = 5e5 + 5;
struct _ &amp;#123;
    int v, c, w, n;
    _() &amp;#123;&amp;#125;
    _(int v1, int c1, int w1, int n1) &amp;#123;
        v = v1, c = c1, w = w1, n = n1;
    &amp;#125;
&amp;#125;;
_ u[maxm];
bool inq[maxn];
int n, m, k, x, res;
int gs, gt, tot = 1;
int c[maxn], f[maxn];
int h[maxn], dis[maxn];
int fl[maxn], pre[maxn];
int min(int x, int y) &amp;#123;
    return x &amp;lt; y ? x : y;
&amp;#125;
bool SPFA(int s, int n) &amp;#123;
    std::queue&amp;lt;int&amp;gt; q;
    std::fill(dis + 1, dis + n + 1, inf);
    q.push(s), dis[s] = 0, inq[s] = 1;
    pre[s] = inf, pre[gt] = 0, fl[s] = inf;
    while (!q.empty()) &amp;#123;
        int f = q.front();
        q.pop(), inq[f] = 0;
        for (int i = h[f]; i; i = u[i].n) &amp;#123;
            if (u[i].c == 0)
                continue;
            int v = u[i].v, w = u[i].w;
            if (dis[v] &amp;gt; dis[f] + w) &amp;#123;
                pre[v] = i ^ 1;
                dis[v] = dis[f] + w;
                fl[v] = min(fl[f], u[i].c);
                if (!inq[v])
                    inq[v] = 1, q.push(v);
            &amp;#125;
        &amp;#125;
    &amp;#125;
    return pre[gt];
&amp;#125;
void SSP(int s, int n) &amp;#123;
    int p, mn, d;
    while (SPFA(s, n)) &amp;#123;
        mn = fl[gt], d = 0;
        for (p = gt; p != s; p = u[pre[p]].v) &amp;#123;
            u[pre[p]].c += mn;
            u[pre[p] ^ 1].c -= mn;
            d += u[pre[p] ^ 1].w;
        &amp;#125;
        res += mn * d;
    &amp;#125;
    return;
&amp;#125;
void add(int x, int y, int c, int w) &amp;#123;
    u[++tot] = _(y, c, w, h[x]);
    h[x] = tot;
    return;
&amp;#125;
void readx(int &amp;amp;x) &amp;#123;
    char ch = nec();
    while (ch != &amp;#39;0&amp;#39; &amp;amp;&amp;amp; ch != &amp;#39;1&amp;#39;)
        ch = nec();
    x = ch - &amp;#39;0&amp;#39;;
    return;
&amp;#125;
int main() &amp;#123;
    read(n), read(m), read(k);
    gs = n + m + 1, gt = gs + 1;
    for (int i = 1; i &amp;lt;= m; ++i) &amp;#123;
        read(c[i]);
        for (int j = 0; j &amp;lt; n; ++j) &amp;#123;
            add(i + n, gt, 1,
                    (2 * j + 1) * c[i]);
            add(gt, i + n, 0,
                    -(2 * j + 1) * c[i]);
        &amp;#125;
    &amp;#125;
    for (int i = 1; i &amp;lt;= m; ++i)
        read(f[i]);
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        add(gs, i, k, 0);
        add(i, gs, 0, 0);
        add(i, gt, k - 1, 0);
        add(gt, i, 0, 0);
        for (int j = 1; j &amp;lt;= m; ++j) &amp;#123;
            readx(x);
            if (x == 1) &amp;#123;
                add(i, j + n, 1, -f[j]); // è´Ÿä»£ä»·
                add(j + n, i, 0, f[j]);
            &amp;#125;
        &amp;#125;
    &amp;#125;
    SSP(gs, gt);
    print(res, &amp;#39;\n&amp;#39;);
    return 0;
&amp;#125;
&amp;#125; // namespace XSC062
#undef int&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
</content>
        <category term="ç½‘ç»œæµ" />
        <category term="è´¹ç”¨æµ" />
        <updated>2023-07-17T07:52:02.000Z</updated>
    </entry>
</feed>
