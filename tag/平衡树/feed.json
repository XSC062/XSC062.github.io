{
    "version": "https://jsonfeed.org/version/1",
    "title": "null • All posts by \"平衡树\" tag",
    "description": "",
    "home_page_url": "https://xsc062.netlify.app",
    "items": [
        {
            "id": "https://xsc062.netlify.app/20250818/",
            "url": "https://xsc062.netlify.app/20250818/",
            "title": "学习笔记 平衡树",
            "date_published": "2025-08-18T00:18:48.000Z",
            "content_html": "<p>线段树 plus</p>\n<span id=\"more\"></span>\n<hr />\n<h2 id=\"概览\">概览</h2>\n<p>定义：BST，且对于任意点，其左右子树树高差不超过 <span class=\"math inline\">\\(1\\)</span>，这样所有 <span class=\"math inline\">\\(O(h)\\)</span> 复杂度的 BST 操作都能在 <span class=\"math inline\">\\(O(\\log n)\\)</span> 内解决。</p>\n<ul>\n<li><p>维护值：<code>__gnu_pbds::tree&lt;&gt;</code> / 权值线段树</p>\n<p>需要意识到线段树就是 leafy 的平衡树，且是静态的，不支持对树结构的操作；</p>\n这也是为什么树上的 GBT 总是可以用线段树代替 BST 做 DDP，因为树是静态的，重链也是静态的，不可能有结构变化的需求。但序列上的 DDP 不一定是静态的，比如 <a href=\"\">密码箱</a> 就只能用平衡树做。</li>\n<li><p>维护序列：fhq treap</p></li>\n</ul>\n<hr />\n<h3 id=\"例普通平衡树\">例：普通平衡树</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P3369\" class=\"uri\">https://www.luogu.com.cn/problem/P3369</a></p>\n<p>pbds / 权值线段树。</p>\n<hr />\n<h2 id=\"fhq-treap\">FHQ Treap</h2>\n<p>把 Treap 的旋转操作改成了好想好写的 split 和 merge，其余不变；额外带来了维护序列结构的功能。</p>\n<p>这里就只探讨维护序列了，维护的是对于序列结构上的操作（也可以维护值的操作，方式和线段树类似），这里的点值就和线段树维护的值一样，对于操作是没有影响的；点的 id 和对应的下标并没有关系；点的 rank（可以 <span class=\"math inline\">\\(O(1)\\)</span> 维护）才对应下标。</p>\n<ul>\n<li><p><code>split</code>：把树在某个值下标处分为两个 Treap。考虑怎么解决这种情况：</p>\n<p><img src=\"image.png\" /></p>\n自底向上递归处理，考虑到处理 <span class=\"math inline\">\\(4\\)</span> 的时候 <span class=\"math inline\">\\(4\\)</span> 接了完整的一个 BST，直接把 <span class=\"math inline\">\\(4\\)</span> 接到 <span class=\"math inline\">\\(3\\)</span> 的右儿子即可。显然是不会影响 priority 的。</li>\n<li><p><code>merge</code>：是为了配合 split 而产生的操作，将树 split 出去并操作后需要 merge 回来。难点在于需要考虑 priority。相似地，考虑这种情况：</p>\n<figure>\n<img src=\"image-2.png\" alt=\"蓝色数字是 priority\" /><figcaption>蓝色数字是 priority</figcaption>\n</figure>\n从最右边一条链向下走到可以插入的位置（显然是唯一的），将点插入，该处原本的子树和新点的左子树递归合并。</li>\n<li><p>结构操作（以区间 reverse 为例）：两次 split 得到操作区间的 Treap，打一个懒标记，再合并回去。</p>\n类似线段树，递归经过一个点时，如果存在 lazy，就可以交换左右儿子然后下传标记。</li>\n<li><p><span class=\"math inline\">\\(O(n)\\)</span> 建树：Treap 是笛卡尔树，然后就可以用悬线或者单调栈建树了。</p>\n<p>反过来可以得到在随机数据下笛卡尔树是平衡的，参考 <a href=\"https://www.luogu.com.cn/problem/P2611\">ZJOI2011 小蓝的好友</a>，利用了这个性质。</p></li>\n</ul>\n<hr />\n<h3 id=\"例文艺平衡树\">例：文艺平衡树</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P3391\" class=\"uri\">https://www.luogu.com.cn/problem/P3391</a></p>\n<p>区间 reverse 乍看会带来可以用线段树做的错觉</p>\n<p>实际上考虑一下 reverse 区间有交的情况，就会发现线段树确实做不了，只能真正地去实现 reverse 这个过程，就只有平衡树了能做了。</p>\n<details>\n<pre data-line=\"37\" class=\"cpp language-cpp\"><code data-line=\"37\" class=\"cpp language-cpp\">#include &lt;bits/stdc++.h>\nconst int maxn = 1e5 + 5;\nunsigned pr[maxn];\nint lc[maxn], rc[maxn], d[maxn], siz[maxn];\nvoid pushup(int p) &#123;\n    if (p)\n        siz[p] = siz[lc[p]] + 1 + siz[rc[p]];\n    return;\n&#125;\nvoid pushdown(int p) &#123;\n    if (p && d[p]) &#123;\n        std::swap(lc[p], rc[p]);\n        d[lc[p]] ^= 1, d[rc[p]] ^= 1;\n        d[p] = 0;\n    &#125;\n    return;\n&#125;\nvoid init(int p) &#123;\n    if (lc[p])\n        init(lc[p]);\n    if (rc[p])\n        init(rc[p]);\n    pushup(p);\n    return;\n&#125;\nint split(int &p, int rk) &#123;\n    if (!p)\n        return 0;\n    pushdown(p);\n    int q = 0;\n    if (siz[lc[p]] + 1 == rk)\n        q = rc[p], rc[p] = 0;\n    else if (rk <= siz[lc[p]])\n        q = p, p = lc[p], lc[q] = split(p, rk);\n    else\n        q = split(rc[p], rk - siz[lc[p]] - 1);\n    pushdown(q);  // 易错：这里要 pushdown\n    pushup(p), pushup(q);\n    return q;\n&#125;\nvoid merge(int &p, int q) &#123;\n    pushdown(p), pushdown(q);\n    if (!p || !q) &#123;\n        p += q;\n        return;\n    &#125;\n    if (pr[p] > pr[q])\n        merge(p, lc[q]), lc[q] = p, p = q;\n    else\n        merge(rc[p], q);\n    pushup(p);\n    return;\n&#125;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(\".in\", \"r\", stdin);\n    std::freopen(\".out\", \"w\", stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, m;\n    std::cin >> n >> m;\n    std::vector&lt;int> l(n + 1), r(n + 1);\n    std::mt19937 rand(time(nullptr));\n    for (int i = 1; i <= n; ++i) &#123;\n        pr[i] = rand();\n        for (l[i] = i; l[i] != 1 && pr[l[i] - 1] > pr[i]; l[i] = l[l[i] - 1]);\n        if (l[i] != 1)\n            rc[l[i] - 1] = i;\n    &#125;\n    for (int i = n; i; --i) &#123;\n        for (r[i] = i; r[i] != n && pr[r[i] + 1] > pr[i]; r[i] = r[r[i] + 1]);\n        if (r[i] != n)\n            lc[r[i] + 1] = i;\n    &#125;\n    std::function&lt;void(int)> print = [&](int p) &#123;\n        pushdown(p);\n        if (lc[p])\n            print(lc[p]);\n        std::cout << p << ' ';\n        if (rc[p])\n            print(rc[p]);\n        return;\n    &#125;;\n    int rt = std::min_element(pr + 1, pr + n + 1) - pr;\n    init(rt);\n    for (int l, r, i = 1; i <= m; ++i) &#123;\n        std::cin >> l >> r;\n        int rt1 = split(rt, l - 1), rt2 = split(rt1, r - l + 1);\n        d[rt1] ^= 1;\n        merge(rt1, rt2), merge(rt, rt1);\n    &#125;\n    print(rt), std::cout << '\\n';\n#ifndef ONLINE_JUDGE\n    std::cerr << std::fixed << std::setprecision(6) << std::chrono::duration&lt;double> (std::chrono::steady_clock::now() - stime).count() << \"s\\n\";\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"习题\">习题</h2>\n<p>有点难，难点不在平衡树</p>\n<p>平衡树反而是简单的，只需要发现序列和序列操作就可以了。</p>\n<hr />\n<h3 id=\"c---密码箱\">C - 密码箱</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P7739\" class=\"uri\">https://www.luogu.com.cn/problem/P7739</a></p>\n<p>经过思考后，发现比较合理的转化方式是<strong>跳过具体数值，直接用对应操作表示函数值</strong>。</p>\n<p>将数列转化为最终函数值，用矩阵很好操作（右乘）；考虑将操作转化为数值，利用结合律，容易发现只需要把操作对应的矩阵加在末端（前端）即可，这样就可以只用操作来表示函数值。</p>\n<p>要做的话最好只让矩阵维护最后一项，<code>W</code> 显然，<code>E</code> 的第二种亦显然（加两个矩阵），考虑乘起来方便维护，乘起来之后发现和 <code>E</code> 的第一种是等价的，平衡树维护四个矩阵即可。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 2e5 + 5;\nconst int mod = 998244353;\nusing ll = long long;\nstruct mat &#123;\n    ll a[2][2];\n    ll* operator[] (const int q) &#123;\n        return a[q];\n    &#125;\n    bool operator== (mat &amp;q) const &#123;\n        return a[0][0] == q[0][0] &amp;&amp; a[0][1] == q[0][1] &amp;&amp; a[1][0] == q[1][0] &amp;&amp; a[1][1] == q[1][1];\n    &#125;\n    mat operator* (mat &amp;q) const &#123;\n        mat res;\n        res[0][0] = (a[0][0] * q[0][0] + a[0][1] * q[1][0]) % mod;\n        res[0][1] = (a[0][0] * q[0][1] + a[0][1] * q[1][1]) % mod;\n        res[1][0] = (a[1][0] * q[0][0] + a[1][1] * q[1][0]) % mod;\n        res[1][1] = (a[1][0] * q[0][1] + a[1][1] * q[1][1]) % mod;\n        return res;\n    &#125;\n&#125; u[maxn][2], s[maxn][4], W, E, A, B, C;\nunsigned pr[maxn];\nint siz[maxn], d1[maxn], d2[maxn], lc[maxn], rc[maxn];\n#define lt lc[p]\n#define rt rc[p]\nvoid pushup(int p) &#123;\n    if (p) &#123;\n        siz[p] = siz[lc[p]] + 1 + siz[rc[p]];\n        s[p][0b00] = s[lc[p]][0b00] * u[p][0] * s[rc[p]][0b00];\n        s[p][0b01] = s[lc[p]][0b01] * u[p][1] * s[rc[p]][0b01];\n        s[p][0b10] = s[rc[p]][0b10] * u[p][0] * s[lc[p]][0b10];\n        s[p][0b11] = s[rc[p]][0b11] * u[p][1] * s[lc[p]][0b11];\n    &#125;\n    return;\n&#125;\nvoid pushdown(int p) &#123;\n    if (p &amp;&amp; d1[p]) &#123;\n        d1[lt] ^= 1, d1[rt] ^= 1;\n        std::swap(u[lt][0], u[lt][1]);\n        std::swap(s[lt][0b00], s[lt][0b01]);\n        std::swap(s[lt][0b10], s[lt][0b11]);\n        std::swap(u[rt][0], u[rt][1]);\n        std::swap(s[rt][0b00], s[rt][0b01]);\n        std::swap(s[rt][0b10], s[rt][0b11]);\n        d1[p] = 0;\n    &#125;\n    if (p &amp;&amp; d2[p]) &#123;\n        d2[lt] ^= 1, d2[rt] ^= 1;\n        std::swap(lc[lt], rc[lt]);\n        std::swap(s[lt][0b00], s[lt][0b10]);\n        std::swap(s[lt][0b01], s[lt][0b11]);\n        std::swap(lc[rt], rc[rt]);\n        std::swap(s[rt][0b00], s[rt][0b10]);\n        std::swap(s[rt][0b01], s[rt][0b11]);\n        d2[p] = 0;\n    &#125;\n    return;\n&#125;\nint split(int &amp;p, int rk) &#123;\n    if (!p)\n        return 0;\n    pushdown(p);\n    int q = 0;\n    if (siz[lc[p]] + 1 == rk)\n        q = rc[p], rc[p] = 0;\n    else if (rk &lt;= siz[lc[p]])\n        q = p, p = lc[p], lc[q] = split(p, rk);\n    else\n        q = split(rc[p], rk - siz[lc[p]] - 1);\n    pushdown(q);\n    pushup(p), pushup(q);\n    return q;\n&#125;\nvoid merge(int &amp;p, int q) &#123;\n    if (!p || !q) &#123;\n        p += q;\n        return;\n    &#125;\n    pushdown(p), pushdown(q);\n    if (pr[p] &gt; pr[q])\n        merge(p, lc[q]), lc[q] = p, p = q;\n    else\n        merge(rc[p], q);\n    pushup(p);\n    return;\n&#125;\nvoid init(int p) &#123;\n    if (lc[p])\n        init(lc[p]);\n    if (rc[p])\n        init(rc[p]);\n    pushup(p);\n    return;\n&#125;\n#undef lt\n#undef rt\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;code3.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    s[0][0][0][0] = s[0][0][1][1] = s[0][1][0][0] = s[0][1][1][1] = s[0][2][0][0] = s[0][2][1][1] = s[0][3][0][0] = s[0][3][1][1] = 1ll;\n    W[0][0] = W[0][1] = W[1][1] = 1ll;\n    E[0][1] = mod - 1ll, E[1][0] = 1ll, E[1][1] = 2ll;\n    A[0][1] = A[1][0] = 1ll, B[0][1] = B[1][0] = B[1][1] = 1ll;\n    int n, q, rt;\n    std::cin &gt;&gt; n &gt;&gt; q;\n    std::mt19937 rand(time(nullptr));\n    for (int i = 1; i &lt;= n + q; ++i)\n        pr[i] = rand();\n    std::vector&lt;char&gt; a(n + 1);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; a[i];\n        if (a[i] == &#39;W&#39;)\n            u[i][0] = W, u[i][1] = E;\n        else\n            u[i][0] = E, u[i][1] = W;\n    &#125;\n    &#123;\n        std::vector&lt;int&gt; l(n + 1), r(n + 1);\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            for (l[i] = i; l[i] != 1 &amp;&amp; pr[l[i] - 1] &gt; pr[i]; l[i] = l[l[i] - 1]);\n            if (l[i] != 1)\n                rc[l[i] - 1] = i;\n        &#125;\n        for (int i = n; i; --i) &#123;\n            for (r[i] = i; r[i] != n &amp;&amp; pr[r[i] + 1] &gt; pr[i]; r[i] = r[r[i] + 1]);\n            if (r[i] != n)\n                lc[r[i] + 1] = i;\n        &#125;\n        rt = std::min_element(pr + 1, pr + n + 1) - pr;\n        init(rt);\n    &#125;\n    auto print = [&amp;](int rt) &#123;\n        auto res = A * B * s[rt][0];\n        ll p = res[0][1], q = res[1][1];\n        std::cout &lt;&lt; q &lt;&lt; &#39; &#39;  &lt;&lt; p &lt;&lt; &#39;\\n&#39;;\n        return;\n    &#125;;\n    print(rt);\n    for (std::string op; q--; ) &#123;\n        std::cin &gt;&gt; op;\n        if (op == &quot;APPEND&quot;) &#123;\n            char t;\n            std::cin &gt;&gt; t, ++n;\n            if (t == &#39;W&#39;)\n                u[n][0] = W, u[n][1] = E;\n            else\n                u[n][0] = E, u[n][1] = W;\n            pushup(n), merge(rt, n);\n        &#125;\n        else if (op == &quot;FLIP&quot;) &#123;\n            int l, r;\n            std::cin &gt;&gt; l &gt;&gt; r;\n            int rt1 = split(rt, l - 1), rt2 = split(rt1, r - l + 1);\n            d1[rt1] ^= 1;\n            std::swap(u[rt1][0], u[rt1][1]);\n            std::swap(s[rt1][0b00], s[rt1][0b01]);\n            std::swap(s[rt1][0b10], s[rt1][0b11]);\n            merge(rt1, rt2), merge(rt, rt1);\n        &#125;\n        else &#123;\n            int l, r;\n            std::cin &gt;&gt; l &gt;&gt; r;\n            int rt1 = split(rt, l - 1), rt2 = split(rt1, r - l + 1);\n            d2[rt1] ^= 1;\n            std::swap(lc[rt1], rc[rt1]);\n            std::swap(s[rt1][0b00], s[rt1][0b10]);\n            std::swap(s[rt1][0b01], s[rt1][0b11]);\n            merge(rt1, rt2), merge(rt, rt1);\n        &#125;\n        print(rt);\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"a---bridge\">A - Bridge</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P9358\" class=\"uri\">https://www.luogu.com.cn/problem/P9358</a></p>\n<p>如果把桥视作元素，假设对于下面的情形：</p>\n<p><img src=\"image-1.png\" /></p>\n<p>容易发现如果 <span class=\"math inline\">\\(b\\)</span> 不存在，那么 <span class=\"math inline\">\\(y\\)</span> 和 <span class=\"math inline\">\\(x\\)</span> 的后继都是 <span class=\"math inline\">\\(a\\)</span>，但只保留 <span class=\"math inline\">\\(y\\to a\\)</span> 的路径是不劣的</p>\n<p>如果 <span class=\"math inline\">\\(b\\)</span> 存在，就要连 <span class=\"math inline\">\\(b\\)</span> 和 <span class=\"math inline\">\\(x\\)</span>，也就说每个点连到当前行和下一行中最近的后继点就可以了，每个点只对应两条边，最后会形成若干个链，看成序列就可以用平衡树维护。查询<strong>跳到树顶再跳到最右的儿子就可以了，复杂度 <span class=\"math inline\">\\(O(\\log n)\\)</span></strong>。连边则可以直接用 set 维护。</p>\n",
            "tags": [
                "平衡树"
            ]
        }
    ]
}