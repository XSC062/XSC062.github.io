<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://xsc062.netlify.app</id>
    <title> • Posts by &#34;博弈论&#34; tag</title>
    <link href="https://xsc062.netlify.app" />
    <updated>2025-05-24T06:29:44.000Z</updated>
    <category term="并查集" />
    <category term="斜率优化" />
    <category term="悬线法" />
    <category term="哈希" />
    <category term="字典树" />
    <category term="DP" />
    <category term="单调队列" />
    <category term="分治" />
    <category term="二分图" />
    <category term="CRT / exCRT" />
    <category term="排列组合" />
    <category term="网络流" />
    <category term="费用流" />
    <category term="二分" />
    <category term="上下界网络流" />
    <category term="容斥原理" />
    <category term="线段树" />
    <category term="树状数组" />
    <category term="区间 DP" />
    <category term="构造" />
    <category term="Tarjan" />
    <category term="数据结构" />
    <category term="下饭" />
    <category term="LCA" />
    <category term="倍增" />
    <category term="鸽巢原理" />
    <category term="概率期望" />
    <category term="调和级数" />
    <category term="差分" />
    <category term="思维" />
    <category term="树形 DP" />
    <category term="最小生成树" />
    <category term="SAM" />
    <category term="状压" />
    <category term="分块" />
    <category term="可持久化" />
    <category term="笛卡尔树" />
    <category term="高维前缀和" />
    <category term="闲话" />
    <category term="欧拉回路" />
    <category term="树链剖分" />
    <category term="长链剖分" />
    <category term="KMP" />
    <category term="border" />
    <category term="字符串" />
    <category term="AC 自动机" />
    <category term="SA" />
    <category term="数学" />
    <category term="树上差分" />
    <category term="FWT" />
    <category term="堆" />
    <category term="树的重心" />
    <category term="二项式定理" />
    <category term="二项式反演" />
    <category term="贪心" />
    <category term="均摊" />
    <category term="计数" />
    <category term="优化建图" />
    <category term="反悔贪心" />
    <category term="调整法" />
    <category term="背包" />
    <category term="博弈论" />
    <category term="DP 优化" />
    <category term="虚树" />
    <category term="点分治" />
    <category term="WQS 二分" />
    <category term="闵可夫斯基和" />
    <category term="slope trick" />
    <category term="四边形不等式" />
    <category term="暴力" />
    <category term="状压 DP" />
    <category term="组合数学" />
    <category term="支配对" />
    <category term="DDP" />
    <category term="平衡树" />
    <category term="容斥" />
    <category term="猫树" />
    <category term="Kruskal 重构树" />
    <category term="李超线段树" />
    <entry>
        <id>https://xsc062.netlify.app/20250524/</id>
        <title>周考</title>
        <link rel="alternate" href="https://xsc062.netlify.app/20250524/"/>
        <content type="html">&lt;p&gt;并非周考。&lt;/p&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;b---carousel-of-combinations&#34;&gt;B - Carousel of Combinations&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://codeforces.com/problemset/problem/1957/E&#34; class=&#34;uri&#34;&gt;https://codeforces.com/problemset/problem/1957/E&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(q\)&lt;/span&gt; 次询问，每次给定一个 &lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt;，求：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
\left(\sum\limits_{i=1}^n\sum\limits_{j=1}^i \dfrac {i!}{(i-j)!\cdot j!}\bmod j\right) \bmod 10^9+7
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(n,q\le 10^6\)&lt;/span&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;赛时打表 &lt;span class=&#34;math inline&#34;&gt;\(\dfrac {i!}{(i-j)!\cdot j!}\bmod j\)&lt;/span&gt; 易发现只有 &lt;span class=&#34;math inline&#34;&gt;\(j=4\)&lt;/span&gt; 或 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; 为质数的列上有值；且仅当 &lt;span class=&#34;math inline&#34;&gt;\(\left\lfloor \dfrac ij\right\rfloor\)&lt;/span&gt; 发生变化时，&lt;span class=&#34;math inline&#34;&gt;\((i,j)\)&lt;/span&gt; 的值不同。&lt;/p&gt;
&lt;p&gt;于是乎埃筛找每个 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; 的倍数，由于每个值会持续一段 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 上的区间，考虑维护差分数组。前缀和得到原数组，再前缀和就能得到答案。&lt;/p&gt;
&lt;details&gt;
&lt;p&gt;&lt;summary&gt;证明&lt;/summary&gt;&lt;/p&gt;
&lt;p&gt;考虑转化为组合数形式方便证明。当 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; 为质数时：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
\begin{aligned}
\dfrac {i!}{(i-j)!\cdot j!}\bmod j
&amp;amp;=C_i^j\cdot (j-1)!\bmod j\\
&amp;amp;=C_{i\bmod j}^{j\bmod j}\cdot C_{\lfloor \frac ij\rfloor}^{\frac jj}\cdot (j-1)!\bmod j\\
&amp;amp;=\left\lfloor \frac ij\right\rfloor\cdot (j-1)!\bmod j\\
&amp;amp;=\left\lfloor \frac ij\right\rfloor\cdot (j-1)\bmod j
\end{aligned}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;当 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; 为合数时：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
\dfrac {i!}{(i-j)!\cdot j!}\bmod j=\left\lfloor \frac ij\right\rfloor\cdot (j-1)!\bmod j
\]&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;当 &lt;span class=&#34;math inline&#34;&gt;\(j=p^2\)&lt;/span&gt;，其中 &lt;span class=&#34;math inline&#34;&gt;\(p\)&lt;/span&gt; 为质数时：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当 &lt;span class=&#34;math inline&#34;&gt;\(j\ne 4\)&lt;/span&gt; 时，&lt;span class=&#34;math inline&#34;&gt;\(\dfrac jp \ge 3\)&lt;/span&gt;，代表在 &lt;span class=&#34;math inline&#34;&gt;\(1\sim j-1\)&lt;/span&gt; 中至少出现了两个 &lt;span class=&#34;math inline&#34;&gt;\(p\)&lt;/span&gt; 的倍数，即 &lt;span class=&#34;math inline&#34;&gt;\((j-1)\bmod j = 0\)&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;否则，原式转化为 &lt;span class=&#34;math inline&#34;&gt;\(2\cdot \left\lfloor \frac i4\right\rfloor\bmod 4\)&lt;/span&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;否则：可以找到至少一组 &lt;span class=&#34;math inline&#34;&gt;\(j=i\cdot k\)&lt;/span&gt; 满足 &lt;span class=&#34;math inline&#34;&gt;\(i\ne k\)&lt;/span&gt;，则 &lt;span class=&#34;math inline&#34;&gt;\(i,k\)&lt;/span&gt; 出现在 &lt;span class=&#34;math inline&#34;&gt;\(1\sim j-1\)&lt;/span&gt; 中，即 &lt;span class=&#34;math inline&#34;&gt;\((j-1)\bmod j = 0\)&lt;/span&gt;。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;得到上述结论。&lt;/p&gt;
&lt;p&gt;Tips：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;卢卡斯定理：懒得写了。&lt;/li&gt;
&lt;li&gt;威尔逊定理：对于质数 &lt;span class=&#34;math inline&#34;&gt;\(p\)&lt;/span&gt;，&lt;span class=&#34;math inline&#34;&gt;\((p-1)!\equiv -1\pmod p\)&lt;/span&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;c---玻利维亚-bolivija&#34;&gt;C - 玻利维亚 / Bolivija&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P12401&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P12401&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定若干次区间的插入与删除操作，对于所有值域内未被覆盖极长段 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt;，令 &lt;span class=&#34;math inline&#34;&gt;\(len_i\)&lt;/span&gt; 为其长度；每次操作后询问 &lt;span class=&#34;math inline&#34;&gt;\(\sum \frac {len_i\cdot (len_i-1)}2+len_i\)&lt;/span&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;来一点新奇的思路。假如你和我一样，很不幸地不知道维护最小值这个 trick，怎么解决这道题？&lt;/p&gt;
&lt;p&gt;容易想到线段树维护节点内贡献和左侧、右侧极长未覆盖长度。加入区间是简单的：对于线段树上被完全覆盖的节点，更新其贡献为 &lt;span class=&#34;math inline&#34;&gt;\(0\)&lt;/span&gt;。依次 &lt;code&gt;pushup&lt;/code&gt; 即可。&lt;/p&gt;
&lt;p&gt;删除区间，对于被这段区间完全覆盖的节点，发现如果整体被覆盖次数减少 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt;，有可能出现新的、未被覆盖的点，如果暴力 check 左右儿子是否出现了这样的点并更新，复杂度就不太美观了。&lt;/p&gt;
&lt;p&gt;故而对于一个节点，&lt;strong&gt;将『完全覆盖它的区间』和『部分覆盖它的区间』分开考虑&lt;/strong&gt;，在维护该节点所有实时信息（记为 &lt;span class=&#34;math inline&#34;&gt;\(s\)&lt;/span&gt;）的同时，&lt;strong&gt;维护另一份只考虑了『部分覆盖它地区间』的信息（记为 &lt;span class=&#34;math inline&#34;&gt;\(s&amp;#39;\)&lt;/span&gt;）&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;如果一个『部分覆盖它的区间』被删除：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果存在『完全覆盖它的区间』：&lt;span class=&#34;math inline&#34;&gt;\(s\)&lt;/span&gt; 不变；向下修改儿子的 &lt;span class=&#34;math inline&#34;&gt;\(s\)&lt;/span&gt;，&lt;span class=&#34;math inline&#34;&gt;\(s&amp;#39;\)&lt;/span&gt; 需要从儿子的 &lt;span class=&#34;math inline&#34;&gt;\(s\)&lt;/span&gt; 更新。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果一个『完全覆盖它的区间』被删除：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果还存在其他『完全覆盖它的区间』：&lt;span class=&#34;math inline&#34;&gt;\(s,s&amp;#39;\)&lt;/span&gt; 都不变。&lt;/li&gt;
&lt;li&gt;如果不存在其他『完全覆盖它的区间』：用 &lt;span class=&#34;math inline&#34;&gt;\(s&amp;#39;\)&lt;/span&gt; 更新 &lt;span class=&#34;math inline&#34;&gt;\(s\)&lt;/span&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这样就能 &lt;span class=&#34;math inline&#34;&gt;\(O(q\log V)\)&lt;/span&gt; 解决上述问题。本方法较维护最小值的优势在于——似乎没有。想了许多种情况，它们大抵是等价的——且本方法更难写（哭）。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int maxn = 654205;
struct &amp;#123;
    int cnt;
    long long u, s;
    int l, r, lu, ru, ls, rs;
&amp;#125; t[maxn &amp;lt;&amp;lt; 2];
#define lt (p &amp;lt;&amp;lt; 1)
#define rt (lt | 1)
#define len(p) (t[p].r - t[p].l + 1)
void pushup(int p) &amp;#123;
    t[p].s = t[lt].u + t[rt].u + (long long)t[lt].ru * t[rt].lu;
    if (t[lt].lu == len(lt))
        t[p].ls = len(lt) + t[rt].lu;
    else
        t[p].ls = t[lt].lu;
    if (t[rt].ru == len(rt))
        t[p].rs = t[lt].ru + len(rt);
    else
        t[p].rs = t[rt].ru;
    if (!t[p].cnt)
        t[p].u = t[p].s, t[p].lu = t[p].ls, t[p].ru = t[p].rs;
    return;
&amp;#125;
void bld(int p, int l, int r) &amp;#123;
    t[p].l = l, t[p].r = r;
    if (l == r) &amp;#123;
        t[p].u = t[p].s = 1ll;
        t[p].lu = t[p].ru = t[p].ls = t[p].rs = 1;
        return;
    &amp;#125;
    int mid = (l + r) &amp;gt;&amp;gt; 1;
    bld(lt, l, mid), bld(rt, mid + 1, r);
    pushup(p);
    return;
&amp;#125;
void add(int p, int l, int r) &amp;#123;
    if (l &amp;lt;= t[p].l &amp;amp;&amp;amp; t[p].r &amp;lt;= r) &amp;#123;
        ++t[p].cnt, t[p].u = 0ll, t[p].lu = t[p].ru = 0;
        return;
    &amp;#125;
    int mid = (t[p].l + t[p].r) &amp;gt;&amp;gt; 1;
    if (l &amp;lt;= mid)
        add(lt, l, r);
    if (r &amp;gt; mid)
        add(rt, l, r);
    pushup(p);
    return;
&amp;#125;
void rem(int p, int l, int r) &amp;#123;
    if (l &amp;lt;= t[p].l &amp;amp;&amp;amp; t[p].r &amp;lt;= r) &amp;#123;
        if (!--t[p].cnt)
            t[p].u = t[p].s, t[p].lu = t[p].ls, t[p].ru = t[p].rs;
        return;
    &amp;#125;
    int mid = (t[p].l + t[p].r) &amp;gt;&amp;gt; 1;
    if (l &amp;lt;= mid)
        rem(lt, l, r);
    if (r &amp;gt; mid)
        rem(rt, l, r);
    pushup(p);
    return;
&amp;#125;
int main() &amp;#123;
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
    int n, q;
    std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; q;
    std::vector&amp;lt;int&amp;gt; a(n + 1);
    for (int i = 1; i &amp;lt;= n; ++i)
        std::cin &amp;gt;&amp;gt; a[i];
    int u = (n + 1) / 2;
    const int N = a[u];
    bld(1, 1, N);
    for (int i = 1; i &amp;lt; u; ++i)
        if (a[i] != a[n - i + 1])
            add(1, std::min(a[i], a[n - i + 1]) + 1, std::max(a[i], a[n - i + 1]));
    std::cout &amp;lt;&amp;lt; t[1].u &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    for (int i, v; q--; ) &amp;#123;
        std::cin &amp;gt;&amp;gt; i &amp;gt;&amp;gt; v;
        if (a[i] != a[n - i + 1])
            rem(1, std::min(a[i], a[n - i + 1]) + 1, std::max(a[i], a[n - i + 1]));
        a[i] = v;
        if (a[i] != a[n - i + 1])
            add(1, std::min(a[i], a[n - i + 1]) + 1, std::max(a[i], a[n - i + 1]));
        std::cout &amp;lt;&amp;lt; t[1].u &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    &amp;#125;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;d---移动金币&#34;&gt;D - 移动金币&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P5363&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P5363&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最后一个棋子的移动等价于丢掉最后一部分空格；中间棋子的移动等价于把左边间隔里的一段空格拿到右边的间隔里。发现原问题转化为『阶梯 Nim 博弈』。&lt;/p&gt;
&lt;details&gt;
&lt;p&gt;&lt;summary&gt;关于阶梯 Nim 博弈…&lt;/summary&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定 &lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt; 层石头，每次行动可以选择以下操作中的一种：&lt;/p&gt;
&lt;ol type=&#34;1&#34;&gt;
&lt;li&gt;选择 &lt;span class=&#34;math inline&#34;&gt;\(2\le i\le n\)&lt;/span&gt;，从第 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 层石头中拿走若干颗，全部放到第 &lt;span class=&#34;math inline&#34;&gt;\(i-1\)&lt;/span&gt; 层里。&lt;/li&gt;
&lt;li&gt;从第 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt; 层石头中拿走若干颗，全部丢弃。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;不能行动者输。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本问题可以等效为 Nim 游戏：&lt;/p&gt;
&lt;p&gt;对于第偶数层，若 Alice 选择从第 &lt;span class=&#34;math inline&#34;&gt;\(2i\)&lt;/span&gt; 层中移动 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 个石头到 &lt;span class=&#34;math inline&#34;&gt;\(2i-1\)&lt;/span&gt;，Bob 可以立即从 &lt;span class=&#34;math inline&#34;&gt;\(2i-1\)&lt;/span&gt; 层中将这 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 个石头移动到 &lt;span class=&#34;math inline&#34;&gt;\(2i-2\)&lt;/span&gt;（或丢弃）。&lt;/p&gt;
&lt;p&gt;也就是说，Alice 在偶数层中的操作不会对 Bob 带来任何限制。偶数层的石头可以被视作不存在；从奇数层移动到偶数层的石头可以被视为丢弃；进而，奇数堆中的移动等效为『丢弃』，将原问题中所有奇数堆抽离出来，等效成普通的 Nim 游戏。&lt;/p&gt;
&lt;/details&gt;
&lt;p&gt;问题转化成，将 &lt;span class=&#34;math inline&#34;&gt;\(n-m\)&lt;/span&gt; 个元素放到编号 &lt;span class=&#34;math inline&#34;&gt;\(0\sim m+1\)&lt;/span&gt; 的盒子里，满足奇数号盒子球个数异或和为 &lt;span class=&#34;math inline&#34;&gt;\(0\)&lt;/span&gt; 的方案数。小容斥一下，用总数减去异或和为 &lt;span class=&#34;math inline&#34;&gt;\(0\)&lt;/span&gt; 者。&lt;/p&gt;
</content>
        <category term="线段树" />
        <category term="博弈论" />
        <updated>2025-05-24T06:29:44.000Z</updated>
    </entry>
</feed>
