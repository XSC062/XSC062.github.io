<?xml version="1.0"?>
<rss version="2.0">
    <channel>
        <title> • Posts by &#34;博弈论&#34; tag</title>
        <link>https://xsc062.netlify.app</link>
        <description></description>
        <language>zh-CN</language>
        <pubDate>Sat, 24 May 2025 14:29:44 +0800</pubDate>
        <lastBuildDate>Sat, 24 May 2025 14:29:44 +0800</lastBuildDate>
        <category>悬线法</category>
        <category>斜率优化</category>
        <category>并查集</category>
        <category>哈希</category>
        <category>DP</category>
        <category>单调队列</category>
        <category>字典树</category>
        <category>二分图</category>
        <category>分治</category>
        <category>计数</category>
        <category>容斥</category>
        <category>CRT / exCRT</category>
        <category>排列组合</category>
        <category>网络流</category>
        <category>二分</category>
        <category>容斥原理</category>
        <category>线段树</category>
        <category>树状数组</category>
        <category>区间 DP</category>
        <category>数据结构</category>
        <category>构造</category>
        <category>Tarjan</category>
        <category>下饭</category>
        <category>李超线段树</category>
        <category>树链剖分</category>
        <category>LCA</category>
        <category>倍增</category>
        <category>鸽巢原理</category>
        <category>数学</category>
        <category>调和级数</category>
        <category>差分</category>
        <category>思维</category>
        <category>树形 DP</category>
        <category>最小生成树</category>
        <category>SAM</category>
        <category>状压</category>
        <category>分块</category>
        <category>可持久化</category>
        <category>笛卡尔树</category>
        <category>高维前缀和</category>
        <category>闲话</category>
        <category>欧拉回路</category>
        <category>长链剖分</category>
        <category>KMP</category>
        <category>border</category>
        <category>随机化</category>
        <category>字符串</category>
        <category>AC 自动机</category>
        <category>SA</category>
        <category>树上差分</category>
        <category>FWT</category>
        <category>堆</category>
        <category>树的重心</category>
        <category>贪心</category>
        <category>均摊</category>
        <category>反悔贪心</category>
        <category>优化建图</category>
        <category>调整法</category>
        <category>博弈论</category>
        <category>DP 优化</category>
        <category>虚树</category>
        <category>点分治</category>
        <category>四边形不等式</category>
        <category>背包</category>
        <category>支配对</category>
        <category>DDP</category>
        <category>CDQ 分治</category>
        <category>猫树</category>
        <category>DP 套 DP</category>
        <category>Kruskal 重构树</category>
        <category>高精度</category>
        <category>最短路</category>
        <category>树套树</category>
        <category>二项式反演</category>
        <category>搜索</category>
        <item>
            <guid isPermalink="true">https://xsc062.netlify.app/20250524/</guid>
            <title>杂题选谈：周考</title>
            <link>https://xsc062.netlify.app/20250524/</link>
            <category>线段树</category>
            <category>博弈论</category>
            <pubDate>Sat, 24 May 2025 14:29:44 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;并非周考。&lt;/p&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;b---carousel-of-combinations&#34;&gt;B - Carousel of Combinations&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://codeforces.com/problemset/problem/1957/E&#34; class=&#34;uri&#34;&gt;https://codeforces.com/problemset/problem/1957/E&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(q\)&lt;/span&gt; 次询问，每次给定一个 &lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt;，求：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
\left(\sum\limits_{i=1}^n\sum\limits_{j=1}^i \dfrac {i!}{(i-j)!\cdot j!}\bmod j\right) \bmod 10^9+7
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(n,q\le 10^6\)&lt;/span&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;赛时打表 &lt;span class=&#34;math inline&#34;&gt;\(\dfrac {i!}{(i-j)!\cdot j!}\bmod j\)&lt;/span&gt; 易发现只有 &lt;span class=&#34;math inline&#34;&gt;\(j=4\)&lt;/span&gt; 或 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; 为质数的列上有值；且仅当 &lt;span class=&#34;math inline&#34;&gt;\(\left\lfloor \dfrac ij\right\rfloor\)&lt;/span&gt; 发生变化时，&lt;span class=&#34;math inline&#34;&gt;\((i,j)\)&lt;/span&gt; 的值不同。&lt;/p&gt;
&lt;p&gt;于是乎埃筛找每个 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; 的倍数，由于每个值会持续一段 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 上的区间，考虑维护差分数组。前缀和得到原数组，再前缀和就能得到答案。&lt;/p&gt;
&lt;details&gt;
&lt;p&gt;&lt;summary&gt;证明&lt;/summary&gt;&lt;/p&gt;
&lt;p&gt;考虑转化为组合数形式方便证明。当 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; 为质数时：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
\begin{aligned}
\dfrac {i!}{(i-j)!\cdot j!}\bmod j
&amp;amp;=C_i^j\cdot (j-1)!\bmod j\\
&amp;amp;=C_{i\bmod j}^{j\bmod j}\cdot C_{\lfloor \frac ij\rfloor}^{\frac jj}\cdot (j-1)!\bmod j\\
&amp;amp;=\left\lfloor \frac ij\right\rfloor\cdot (j-1)!\bmod j\\
&amp;amp;=\left\lfloor \frac ij\right\rfloor\cdot (j-1)\bmod j
\end{aligned}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;当 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; 为合数时：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
\dfrac {i!}{(i-j)!\cdot j!}\bmod j=\left\lfloor \frac ij\right\rfloor\cdot (j-1)!\bmod j
\]&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;当 &lt;span class=&#34;math inline&#34;&gt;\(j=p^2\)&lt;/span&gt;，其中 &lt;span class=&#34;math inline&#34;&gt;\(p\)&lt;/span&gt; 为质数时：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当 &lt;span class=&#34;math inline&#34;&gt;\(j\ne 4\)&lt;/span&gt; 时，&lt;span class=&#34;math inline&#34;&gt;\(\dfrac jp \ge 3\)&lt;/span&gt;，代表在 &lt;span class=&#34;math inline&#34;&gt;\(1\sim j-1\)&lt;/span&gt; 中至少出现了两个 &lt;span class=&#34;math inline&#34;&gt;\(p\)&lt;/span&gt; 的倍数，即 &lt;span class=&#34;math inline&#34;&gt;\((j-1)\bmod j = 0\)&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;否则，原式转化为 &lt;span class=&#34;math inline&#34;&gt;\(2\cdot \left\lfloor \frac i4\right\rfloor\bmod 4\)&lt;/span&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;否则：可以找到至少一组 &lt;span class=&#34;math inline&#34;&gt;\(j=i\cdot k\)&lt;/span&gt; 满足 &lt;span class=&#34;math inline&#34;&gt;\(i\ne k\)&lt;/span&gt;，则 &lt;span class=&#34;math inline&#34;&gt;\(i,k\)&lt;/span&gt; 出现在 &lt;span class=&#34;math inline&#34;&gt;\(1\sim j-1\)&lt;/span&gt; 中，即 &lt;span class=&#34;math inline&#34;&gt;\((j-1)\bmod j = 0\)&lt;/span&gt;。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;得到上述结论。&lt;/p&gt;
&lt;p&gt;Tips：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;卢卡斯定理：懒得写了。&lt;/li&gt;
&lt;li&gt;威尔逊定理：对于质数 &lt;span class=&#34;math inline&#34;&gt;\(p\)&lt;/span&gt;，&lt;span class=&#34;math inline&#34;&gt;\((p-1)!\equiv -1\pmod p\)&lt;/span&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;c---玻利维亚-bolivija&#34;&gt;C - 玻利维亚 / Bolivija&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P12401&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P12401&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定若干次区间的插入与删除操作，对于所有值域内未被覆盖极长段 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt;，令 &lt;span class=&#34;math inline&#34;&gt;\(len_i\)&lt;/span&gt; 为其长度；每次操作后询问 &lt;span class=&#34;math inline&#34;&gt;\(\sum \frac {len_i\cdot (len_i-1)}2+len_i\)&lt;/span&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;来一点新奇的思路。假如你和我一样，很不幸地不知道维护最小值这个 trick，怎么解决这道题？&lt;/p&gt;
&lt;p&gt;容易想到线段树维护节点内贡献和左侧、右侧极长未覆盖长度。加入区间是简单的：对于线段树上被完全覆盖的节点，更新其贡献为 &lt;span class=&#34;math inline&#34;&gt;\(0\)&lt;/span&gt;。依次 &lt;code&gt;pushup&lt;/code&gt; 即可。&lt;/p&gt;
&lt;p&gt;删除区间，对于被这段区间完全覆盖的节点，发现如果整体被覆盖次数减少 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt;，有可能出现新的、未被覆盖的点，如果暴力 check 左右儿子是否出现了这样的点并更新，复杂度就不太美观了。&lt;/p&gt;
&lt;p&gt;故而对于一个节点，&lt;strong&gt;将『完全覆盖它的区间』和『部分覆盖它的区间』分开考虑&lt;/strong&gt;，在维护该节点所有实时信息（记为 &lt;span class=&#34;math inline&#34;&gt;\(s\)&lt;/span&gt;）的同时，&lt;strong&gt;维护另一份只考虑了『部分覆盖它地区间』的信息（记为 &lt;span class=&#34;math inline&#34;&gt;\(s&amp;#39;\)&lt;/span&gt;）&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;如果一个『部分覆盖它的区间』被删除：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果存在『完全覆盖它的区间』：&lt;span class=&#34;math inline&#34;&gt;\(s\)&lt;/span&gt; 不变；向下修改儿子的 &lt;span class=&#34;math inline&#34;&gt;\(s\)&lt;/span&gt;，&lt;span class=&#34;math inline&#34;&gt;\(s&amp;#39;\)&lt;/span&gt; 需要从儿子的 &lt;span class=&#34;math inline&#34;&gt;\(s\)&lt;/span&gt; 更新。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果一个『完全覆盖它的区间』被删除：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果还存在其他『完全覆盖它的区间』：&lt;span class=&#34;math inline&#34;&gt;\(s,s&amp;#39;\)&lt;/span&gt; 都不变。&lt;/li&gt;
&lt;li&gt;如果不存在其他『完全覆盖它的区间』：用 &lt;span class=&#34;math inline&#34;&gt;\(s&amp;#39;\)&lt;/span&gt; 更新 &lt;span class=&#34;math inline&#34;&gt;\(s\)&lt;/span&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这样就能 &lt;span class=&#34;math inline&#34;&gt;\(O(q\log V)\)&lt;/span&gt; 解决上述问题。本方法较维护最小值的优势在于——似乎没有。想了许多种情况，它们大抵是等价的——且本方法更难写（哭）。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int maxn = 654205;
struct &amp;#123;
    int cnt;
    long long u, s;
    int l, r, lu, ru, ls, rs;
&amp;#125; t[maxn &amp;lt;&amp;lt; 2];
#define lt (p &amp;lt;&amp;lt; 1)
#define rt (lt | 1)
#define len(p) (t[p].r - t[p].l + 1)
void pushup(int p) &amp;#123;
    t[p].s = t[lt].u + t[rt].u + (long long)t[lt].ru * t[rt].lu;
    if (t[lt].lu == len(lt))
        t[p].ls = len(lt) + t[rt].lu;
    else
        t[p].ls = t[lt].lu;
    if (t[rt].ru == len(rt))
        t[p].rs = t[lt].ru + len(rt);
    else
        t[p].rs = t[rt].ru;
    if (!t[p].cnt)
        t[p].u = t[p].s, t[p].lu = t[p].ls, t[p].ru = t[p].rs;
    return;
&amp;#125;
void bld(int p, int l, int r) &amp;#123;
    t[p].l = l, t[p].r = r;
    if (l == r) &amp;#123;
        t[p].u = t[p].s = 1ll;
        t[p].lu = t[p].ru = t[p].ls = t[p].rs = 1;
        return;
    &amp;#125;
    int mid = (l + r) &amp;gt;&amp;gt; 1;
    bld(lt, l, mid), bld(rt, mid + 1, r);
    pushup(p);
    return;
&amp;#125;
void add(int p, int l, int r) &amp;#123;
    if (l &amp;lt;= t[p].l &amp;amp;&amp;amp; t[p].r &amp;lt;= r) &amp;#123;
        ++t[p].cnt, t[p].u = 0ll, t[p].lu = t[p].ru = 0;
        return;
    &amp;#125;
    int mid = (t[p].l + t[p].r) &amp;gt;&amp;gt; 1;
    if (l &amp;lt;= mid)
        add(lt, l, r);
    if (r &amp;gt; mid)
        add(rt, l, r);
    pushup(p);
    return;
&amp;#125;
void rem(int p, int l, int r) &amp;#123;
    if (l &amp;lt;= t[p].l &amp;amp;&amp;amp; t[p].r &amp;lt;= r) &amp;#123;
        if (!--t[p].cnt)
            t[p].u = t[p].s, t[p].lu = t[p].ls, t[p].ru = t[p].rs;
        return;
    &amp;#125;
    int mid = (t[p].l + t[p].r) &amp;gt;&amp;gt; 1;
    if (l &amp;lt;= mid)
        rem(lt, l, r);
    if (r &amp;gt; mid)
        rem(rt, l, r);
    pushup(p);
    return;
&amp;#125;
int main() &amp;#123;
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
    int n, q;
    std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; q;
    std::vector&amp;lt;int&amp;gt; a(n + 1);
    for (int i = 1; i &amp;lt;= n; ++i)
        std::cin &amp;gt;&amp;gt; a[i];
    int u = (n + 1) / 2;
    const int N = a[u];
    bld(1, 1, N);
    for (int i = 1; i &amp;lt; u; ++i)
        if (a[i] != a[n - i + 1])
            add(1, std::min(a[i], a[n - i + 1]) + 1, std::max(a[i], a[n - i + 1]));
    std::cout &amp;lt;&amp;lt; t[1].u &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    for (int i, v; q--; ) &amp;#123;
        std::cin &amp;gt;&amp;gt; i &amp;gt;&amp;gt; v;
        if (a[i] != a[n - i + 1])
            rem(1, std::min(a[i], a[n - i + 1]) + 1, std::max(a[i], a[n - i + 1]));
        a[i] = v;
        if (a[i] != a[n - i + 1])
            add(1, std::min(a[i], a[n - i + 1]) + 1, std::max(a[i], a[n - i + 1]));
        std::cout &amp;lt;&amp;lt; t[1].u &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    &amp;#125;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;d---移动金币&#34;&gt;D - 移动金币&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P5363&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P5363&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最后一个棋子的移动等价于丢掉最后一部分空格；中间棋子的移动等价于把左边间隔里的一段空格拿到右边的间隔里。发现原问题转化为『阶梯 Nim 博弈』。&lt;/p&gt;
&lt;details&gt;
&lt;p&gt;&lt;summary&gt;关于阶梯 Nim 博弈…&lt;/summary&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定 &lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt; 层石头，每次行动可以选择以下操作中的一种：&lt;/p&gt;
&lt;ol type=&#34;1&#34;&gt;
&lt;li&gt;选择 &lt;span class=&#34;math inline&#34;&gt;\(2\le i\le n\)&lt;/span&gt;，从第 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 层石头中拿走若干颗，全部放到第 &lt;span class=&#34;math inline&#34;&gt;\(i-1\)&lt;/span&gt; 层里。&lt;/li&gt;
&lt;li&gt;从第 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt; 层石头中拿走若干颗，全部丢弃。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;不能行动者输。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本问题可以等效为 Nim 游戏：&lt;/p&gt;
&lt;p&gt;对于第偶数层，若 Alice 选择从第 &lt;span class=&#34;math inline&#34;&gt;\(2i\)&lt;/span&gt; 层中移动 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 个石头到 &lt;span class=&#34;math inline&#34;&gt;\(2i-1\)&lt;/span&gt;，Bob 可以立即从 &lt;span class=&#34;math inline&#34;&gt;\(2i-1\)&lt;/span&gt; 层中将这 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 个石头移动到 &lt;span class=&#34;math inline&#34;&gt;\(2i-2\)&lt;/span&gt;（或丢弃）。&lt;/p&gt;
&lt;p&gt;也就是说，Alice 在偶数层中的操作不会对 Bob 带来任何限制。偶数层的石头可以被视作不存在；从奇数层移动到偶数层的石头可以被视为丢弃；进而，奇数堆中的移动等效为『丢弃』，将原问题中所有奇数堆抽离出来，等效成普通的 Nim 游戏。&lt;/p&gt;
&lt;/details&gt;
&lt;p&gt;问题转化成，将 &lt;span class=&#34;math inline&#34;&gt;\(n-m\)&lt;/span&gt; 个元素放到编号 &lt;span class=&#34;math inline&#34;&gt;\(0\sim m+1\)&lt;/span&gt; 的盒子里，满足奇数号盒子球个数异或和为 &lt;span class=&#34;math inline&#34;&gt;\(0\)&lt;/span&gt; 的方案数。小容斥一下，用总数减去异或和为 &lt;span class=&#34;math inline&#34;&gt;\(0\)&lt;/span&gt; 者。&lt;/p&gt;
 ]]></description>
        </item>
    </channel>
</rss>
