{
    "version": "https://jsonfeed.org/version/1",
    "title": "null • All posts by \"博弈论\" tag",
    "description": "",
    "home_page_url": "https://xsc062.netlify.app",
    "items": [
        {
            "id": "https://xsc062.netlify.app/20250524/",
            "url": "https://xsc062.netlify.app/20250524/",
            "title": "周考",
            "date_published": "2025-05-24T06:29:44.000Z",
            "content_html": "<p>并非周考。</p>\n<span id=\"more\"></span>\n<hr />\n<h2 id=\"b---carousel-of-combinations\">B - Carousel of Combinations</h2>\n<p><a href=\"https://codeforces.com/problemset/problem/1957/E\" class=\"uri\">https://codeforces.com/problemset/problem/1957/E</a></p>\n<blockquote>\n<p><span class=\"math inline\">\\(q\\)</span> 次询问，每次给定一个 <span class=\"math inline\">\\(n\\)</span>，求：</p>\n<p><span class=\"math display\">\\[\n\\left(\\sum\\limits_{i=1}^n\\sum\\limits_{j=1}^i \\dfrac {i!}{(i-j)!\\cdot j!}\\bmod j\\right) \\bmod 10^9+7\n\\]</span></p>\n<p><span class=\"math inline\">\\(n,q\\le 10^6\\)</span>。</p>\n</blockquote>\n<p>赛时打表 <span class=\"math inline\">\\(\\dfrac {i!}{(i-j)!\\cdot j!}\\bmod j\\)</span> 易发现只有 <span class=\"math inline\">\\(j=4\\)</span> 或 <span class=\"math inline\">\\(j\\)</span> 为质数的列上有值；且仅当 <span class=\"math inline\">\\(\\left\\lfloor \\dfrac ij\\right\\rfloor\\)</span> 发生变化时，<span class=\"math inline\">\\((i,j)\\)</span> 的值不同。</p>\n<p>于是乎埃筛找每个 <span class=\"math inline\">\\(j\\)</span> 的倍数，由于每个值会持续一段 <span class=\"math inline\">\\(i\\)</span> 上的区间，考虑维护差分数组。前缀和得到原数组，再前缀和就能得到答案。</p>\n<details>\n<p><summary>证明</summary></p>\n<p>考虑转化为组合数形式方便证明。当 <span class=\"math inline\">\\(j\\)</span> 为质数时：</p>\n<p><span class=\"math display\">\\[\n\\begin{aligned}\n\\dfrac {i!}{(i-j)!\\cdot j!}\\bmod j\n&amp;=C_i^j\\cdot (j-1)!\\bmod j\\\\\n&amp;=C_{i\\bmod j}^{j\\bmod j}\\cdot C_{\\lfloor \\frac ij\\rfloor}^{\\frac jj}\\cdot (j-1)!\\bmod j\\\\\n&amp;=\\left\\lfloor \\frac ij\\right\\rfloor\\cdot (j-1)!\\bmod j\\\\\n&amp;=\\left\\lfloor \\frac ij\\right\\rfloor\\cdot (j-1)\\bmod j\n\\end{aligned}\n\\]</span></p>\n<p>当 <span class=\"math inline\">\\(j\\)</span> 为合数时：</p>\n<p><span class=\"math display\">\\[\n\\dfrac {i!}{(i-j)!\\cdot j!}\\bmod j=\\left\\lfloor \\frac ij\\right\\rfloor\\cdot (j-1)!\\bmod j\n\\]</span></p>\n<ul>\n<li><p>当 <span class=\"math inline\">\\(j=p^2\\)</span>，其中 <span class=\"math inline\">\\(p\\)</span> 为质数时：</p>\n<ul>\n<li>当 <span class=\"math inline\">\\(j\\ne 4\\)</span> 时，<span class=\"math inline\">\\(\\dfrac jp \\ge 3\\)</span>，代表在 <span class=\"math inline\">\\(1\\sim j-1\\)</span> 中至少出现了两个 <span class=\"math inline\">\\(p\\)</span> 的倍数，即 <span class=\"math inline\">\\((j-1)\\bmod j = 0\\)</span>。</li>\n<li>否则，原式转化为 <span class=\"math inline\">\\(2\\cdot \\left\\lfloor \\frac i4\\right\\rfloor\\bmod 4\\)</span>。</li>\n</ul></li>\n<li><p>否则：可以找到至少一组 <span class=\"math inline\">\\(j=i\\cdot k\\)</span> 满足 <span class=\"math inline\">\\(i\\ne k\\)</span>，则 <span class=\"math inline\">\\(i,k\\)</span> 出现在 <span class=\"math inline\">\\(1\\sim j-1\\)</span> 中，即 <span class=\"math inline\">\\((j-1)\\bmod j = 0\\)</span>。</p></li>\n</ul>\n<p>得到上述结论。</p>\n<p>Tips：</p>\n<ul>\n<li>卢卡斯定理：懒得写了。</li>\n<li>威尔逊定理：对于质数 <span class=\"math inline\">\\(p\\)</span>，<span class=\"math inline\">\\((p-1)!\\equiv -1\\pmod p\\)</span>。</li>\n</ul>\n</details>\n<hr />\n<h2 id=\"c---玻利维亚-bolivija\">C - 玻利维亚 / Bolivija</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P12401\" class=\"uri\">https://www.luogu.com.cn/problem/P12401</a></p>\n<blockquote>\n<p>给定若干次区间的插入与删除操作，对于所有值域内未被覆盖极长段 <span class=\"math inline\">\\(i\\)</span>，令 <span class=\"math inline\">\\(len_i\\)</span> 为其长度；每次操作后询问 <span class=\"math inline\">\\(\\sum \\frac {len_i\\cdot (len_i-1)}2+len_i\\)</span>。</p>\n</blockquote>\n<p>来一点新奇的思路。假如你和我一样，很不幸地不知道维护最小值这个 trick，怎么解决这道题？</p>\n<p>容易想到线段树维护节点内贡献和左侧、右侧极长未覆盖长度。加入区间是简单的：对于线段树上被完全覆盖的节点，更新其贡献为 <span class=\"math inline\">\\(0\\)</span>。依次 <code>pushup</code> 即可。</p>\n<p>删除区间，对于被这段区间完全覆盖的节点，发现如果整体被覆盖次数减少 <span class=\"math inline\">\\(1\\)</span>，有可能出现新的、未被覆盖的点，如果暴力 check 左右儿子是否出现了这样的点并更新，复杂度就不太美观了。</p>\n<p>故而对于一个节点，<strong>将『完全覆盖它的区间』和『部分覆盖它的区间』分开考虑</strong>，在维护该节点所有实时信息（记为 <span class=\"math inline\">\\(s\\)</span>）的同时，<strong>维护另一份只考虑了『部分覆盖它地区间』的信息（记为 <span class=\"math inline\">\\(s&#39;\\)</span>）</strong>：</p>\n<ul>\n<li><p>如果一个『部分覆盖它的区间』被删除：</p>\n<ul>\n<li>如果存在『完全覆盖它的区间』：<span class=\"math inline\">\\(s\\)</span> 不变；向下修改儿子的 <span class=\"math inline\">\\(s\\)</span>，<span class=\"math inline\">\\(s&#39;\\)</span> 需要从儿子的 <span class=\"math inline\">\\(s\\)</span> 更新。</li>\n</ul></li>\n<li><p>如果一个『完全覆盖它的区间』被删除：</p>\n<ul>\n<li>如果还存在其他『完全覆盖它的区间』：<span class=\"math inline\">\\(s,s&#39;\\)</span> 都不变。</li>\n<li>如果不存在其他『完全覆盖它的区间』：用 <span class=\"math inline\">\\(s&#39;\\)</span> 更新 <span class=\"math inline\">\\(s\\)</span>。</li>\n</ul></li>\n</ul>\n<p>这样就能 <span class=\"math inline\">\\(O(q\\log V)\\)</span> 解决上述问题。本方法较维护最小值的优势在于——似乎没有。想了许多种情况，它们大抵是等价的——且本方法更难写（哭）。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 654205;\nstruct &#123;\n    int cnt;\n    long long u, s;\n    int l, r, lu, ru, ls, rs;\n&#125; t[maxn &lt;&lt; 2];\n#define lt (p &lt;&lt; 1)\n#define rt (lt | 1)\n#define len(p) (t[p].r - t[p].l + 1)\nvoid pushup(int p) &#123;\n    t[p].s = t[lt].u + t[rt].u + (long long)t[lt].ru * t[rt].lu;\n    if (t[lt].lu == len(lt))\n        t[p].ls = len(lt) + t[rt].lu;\n    else\n        t[p].ls = t[lt].lu;\n    if (t[rt].ru == len(rt))\n        t[p].rs = t[lt].ru + len(rt);\n    else\n        t[p].rs = t[rt].ru;\n    if (!t[p].cnt)\n        t[p].u = t[p].s, t[p].lu = t[p].ls, t[p].ru = t[p].rs;\n    return;\n&#125;\nvoid bld(int p, int l, int r) &#123;\n    t[p].l = l, t[p].r = r;\n    if (l == r) &#123;\n        t[p].u = t[p].s = 1ll;\n        t[p].lu = t[p].ru = t[p].ls = t[p].rs = 1;\n        return;\n    &#125;\n    int mid = (l + r) &gt;&gt; 1;\n    bld(lt, l, mid), bld(rt, mid + 1, r);\n    pushup(p);\n    return;\n&#125;\nvoid add(int p, int l, int r) &#123;\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r) &#123;\n        ++t[p].cnt, t[p].u = 0ll, t[p].lu = t[p].ru = 0;\n        return;\n    &#125;\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (l &lt;= mid)\n        add(lt, l, r);\n    if (r &gt; mid)\n        add(rt, l, r);\n    pushup(p);\n    return;\n&#125;\nvoid rem(int p, int l, int r) &#123;\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r) &#123;\n        if (!--t[p].cnt)\n            t[p].u = t[p].s, t[p].lu = t[p].ls, t[p].ru = t[p].rs;\n        return;\n    &#125;\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (l &lt;= mid)\n        rem(lt, l, r);\n    if (r &gt; mid)\n        rem(rt, l, r);\n    pushup(p);\n    return;\n&#125;\nint main() &#123;\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n    int n, q;\n    std::cin &gt;&gt; n &gt;&gt; q;\n    std::vector&lt;int&gt; a(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i];\n    int u = (n + 1) / 2;\n    const int N = a[u];\n    bld(1, 1, N);\n    for (int i = 1; i &lt; u; ++i)\n        if (a[i] != a[n - i + 1])\n            add(1, std::min(a[i], a[n - i + 1]) + 1, std::max(a[i], a[n - i + 1]));\n    std::cout &lt;&lt; t[1].u &lt;&lt; &#39;\\n&#39;;\n    for (int i, v; q--; ) &#123;\n        std::cin &gt;&gt; i &gt;&gt; v;\n        if (a[i] != a[n - i + 1])\n            rem(1, std::min(a[i], a[n - i + 1]) + 1, std::max(a[i], a[n - i + 1]));\n        a[i] = v;\n        if (a[i] != a[n - i + 1])\n            add(1, std::min(a[i], a[n - i + 1]) + 1, std::max(a[i], a[n - i + 1]));\n        std::cout &lt;&lt; t[1].u &lt;&lt; &#39;\\n&#39;;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"d---移动金币\">D - 移动金币</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P5363\" class=\"uri\">https://www.luogu.com.cn/problem/P5363</a></p>\n<p>最后一个棋子的移动等价于丢掉最后一部分空格；中间棋子的移动等价于把左边间隔里的一段空格拿到右边的间隔里。发现原问题转化为『阶梯 Nim 博弈』。</p>\n<details>\n<p><summary>关于阶梯 Nim 博弈…</summary></p>\n<blockquote>\n<p>给定 <span class=\"math inline\">\\(n\\)</span> 层石头，每次行动可以选择以下操作中的一种：</p>\n<ol type=\"1\">\n<li>选择 <span class=\"math inline\">\\(2\\le i\\le n\\)</span>，从第 <span class=\"math inline\">\\(i\\)</span> 层石头中拿走若干颗，全部放到第 <span class=\"math inline\">\\(i-1\\)</span> 层里。</li>\n<li>从第 <span class=\"math inline\">\\(1\\)</span> 层石头中拿走若干颗，全部丢弃。</li>\n</ol>\n<p>不能行动者输。</p>\n</blockquote>\n<p>本问题可以等效为 Nim 游戏：</p>\n<p>对于第偶数层，若 Alice 选择从第 <span class=\"math inline\">\\(2i\\)</span> 层中移动 <span class=\"math inline\">\\(x\\)</span> 个石头到 <span class=\"math inline\">\\(2i-1\\)</span>，Bob 可以立即从 <span class=\"math inline\">\\(2i-1\\)</span> 层中将这 <span class=\"math inline\">\\(x\\)</span> 个石头移动到 <span class=\"math inline\">\\(2i-2\\)</span>（或丢弃）。</p>\n<p>也就是说，Alice 在偶数层中的操作不会对 Bob 带来任何限制。偶数层的石头可以被视作不存在；从奇数层移动到偶数层的石头可以被视为丢弃；进而，奇数堆中的移动等效为『丢弃』，将原问题中所有奇数堆抽离出来，等效成普通的 Nim 游戏。</p>\n</details>\n<p>问题转化成，将 <span class=\"math inline\">\\(n-m\\)</span> 个元素放到编号 <span class=\"math inline\">\\(0\\sim m+1\\)</span> 的盒子里，满足奇数号盒子球个数异或和为 <span class=\"math inline\">\\(0\\)</span> 的方案数。小容斥一下，用总数减去异或和为 <span class=\"math inline\">\\(0\\)</span> 者。</p>\n",
            "tags": [
                "线段树",
                "博弈论"
            ]
        }
    ]
}