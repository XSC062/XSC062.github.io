<?xml version="1.0"?>
<rss version="2.0">
    <channel>
        <title> • Posts by &#34;高精度&#34; tag</title>
        <link>https://xsc062.netlify.app</link>
        <description></description>
        <language>zh-CN</language>
        <pubDate>Sat, 06 Sep 2025 15:02:56 +0800</pubDate>
        <lastBuildDate>Sat, 06 Sep 2025 15:02:56 +0800</lastBuildDate>
        <category>并查集</category>
        <category>斜率优化</category>
        <category>悬线法</category>
        <category>哈希</category>
        <category>字典树</category>
        <category>DP</category>
        <category>单调队列</category>
        <category>分治</category>
        <category>计数</category>
        <category>二分图</category>
        <category>CRT / exCRT</category>
        <category>排列组合</category>
        <category>网络流</category>
        <category>费用流</category>
        <category>二分</category>
        <category>上下界网络流</category>
        <category>容斥原理</category>
        <category>线段树</category>
        <category>树状数组</category>
        <category>区间 DP</category>
        <category>构造</category>
        <category>数据结构</category>
        <category>Tarjan</category>
        <category>下饭</category>
        <category>LCA</category>
        <category>倍增</category>
        <category>鸽巢原理</category>
        <category>概率期望</category>
        <category>调和级数</category>
        <category>差分</category>
        <category>思维</category>
        <category>树形 DP</category>
        <category>最小生成树</category>
        <category>SAM</category>
        <category>状压</category>
        <category>分块</category>
        <category>可持久化</category>
        <category>笛卡尔树</category>
        <category>高维前缀和</category>
        <category>闲话</category>
        <category>欧拉回路</category>
        <category>树链剖分</category>
        <category>长链剖分</category>
        <category>KMP</category>
        <category>border</category>
        <category>字符串</category>
        <category>AC 自动机</category>
        <category>SA</category>
        <category>数学</category>
        <category>树上差分</category>
        <category>FWT</category>
        <category>堆</category>
        <category>树的重心</category>
        <category>二项式定理</category>
        <category>二项式反演</category>
        <category>贪心</category>
        <category>均摊</category>
        <category>优化建图</category>
        <category>反悔贪心</category>
        <category>调整法</category>
        <category>背包</category>
        <category>博弈论</category>
        <category>DP 优化</category>
        <category>虚树</category>
        <category>点分治</category>
        <category>WQS 二分</category>
        <category>闵可夫斯基和</category>
        <category>slope trick</category>
        <category>四边形不等式</category>
        <category>状压 DP</category>
        <category>组合数学</category>
        <category>支配对</category>
        <category>DDP</category>
        <category>容斥</category>
        <category>Kruskal 重构树</category>
        <category>高精度</category>
        <category>最短路</category>
        <category>树套树</category>
        <category>Boruvka</category>
        <category>树链剖分 - 最小生成树</category>
        <category>李超线段树</category>
        <item>
            <guid isPermalink="true">https://xsc062.netlify.app/20250906/</guid>
            <title>学习笔记：压位高精</title>
            <link>https://xsc062.netlify.app/20250906/</link>
            <category>高精度</category>
            <pubDate>Sat, 06 Sep 2025 15:02:56 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;把 ddxrS 吓到了，发出惊世疑问：『为什么高二机房正在激烈地讨论怎么写高精度？』&lt;/p&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;
&lt;hr /&gt;
&lt;p&gt;考虑 10-base 高精度，单次运算复杂度为 &lt;span class=&#34;math inline&#34;&gt;\(O(\log_{10}V)\)&lt;/span&gt;。使用 10-base 的主要原因是 &lt;code&gt;std::to_string&lt;/code&gt; 很方便、输出也很简单。&lt;/p&gt;
&lt;p&gt;但效率太低。实际上，一般打高精度都是 1e4-base，或更激进地，1e9-base。&lt;/p&gt;
&lt;p&gt;注意高精乘低精是 &lt;span class=&#34;math inline&#34;&gt;\(O(len)\)&lt;/span&gt; 而非 &lt;span class=&#34;math inline&#34;&gt;\(O(len^2)\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;需要考虑输出。由于用的是 10-power 作为 base，所以只需要把每四位直接输出即可。注意除首位外需要补前导 0 直到四位。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;struct BI &amp;#123;
    std::vector&amp;lt;int&amp;gt; s;
    BI() &amp;#123;&amp;#125;
    BI(int x) &amp;#123;
        for (; x; s.push_back(x % 10000), x /= 10000);
        return;
    &amp;#125;
    BI&amp;amp; operator= (int q) &amp;#123;
        return *this = (BI)q;
    &amp;#125;
    bool operator&amp;gt; (const BI &amp;amp;q) &amp;#123;
        if (s.size() != q.s.size())
            return s.size() &amp;gt; q.s.size();
        for (int i = (int)s.size() - 1; ~i; --i)
            if (s[i] != q.s[i])
                return s[i] &amp;gt; q.s[i];
        return 0;
    &amp;#125;
    BI operator* (int q) const &amp;#123;
        int lx = s.size();
        std::vector&amp;lt;long long&amp;gt; res(lx + 3);
        for (int i = 0; i &amp;lt; lx; ++i)
            res[i] = (long long)s[i] * q;
        BI p;
        for (int j = 0; j &amp;lt; lx + 2; ++j)
            res[j + 1] += res[j] / 10000, res[j] %= 10000;
        int len = lx + 2;
        for (; ~len &amp;amp;&amp;amp; !res[len]; --len);
        for (int j = 0; j &amp;lt;= len; ++j)
            p.s.push_back(res[j]);
        return p;
    &amp;#125;
    void out(void) &amp;#123;
        for (int i = (int)s.size() - 1; ~i; --i) &amp;#123;
            auto p = std::to_string(s[i]);
            if (i != (int)s.size() - 1)
                for (; (int)p.size() &amp;lt; 4; p = &amp;quot;0&amp;quot; + p);
            std::cout &amp;lt;&amp;lt; p;
        &amp;#125;
        std::cout &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
        return;
    &amp;#125;
&amp;#125;;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
 ]]></description>
        </item>
    </channel>
</rss>
