{
    "version": "https://jsonfeed.org/version/1",
    "title": "null • All posts by \"悬线法\" tag",
    "description": "",
    "home_page_url": "https://xsc062.netlify.app",
    "items": [
        {
            "id": "https://xsc062.netlify.app/20231004/",
            "url": "https://xsc062.netlify.app/20231004/",
            "title": "情景剧",
            "date_published": "2023-10-04T08:42:00.000Z",
            "content_html": "<p>Solution to <a href=\"http://222.180.160.110:61235/contest/4273/problem/1\">情景剧</a>。</p>\n<span id=\"more\"></span>\n<hr />\n<h3 id=\"a.-情景剧\">A. 情景剧</h3>\n<p><a href=\"http://222.180.160.110:61235/contest/4273/problem/1\" class=\"uri\">http://222.180.160.110:61235/contest/4273/problem/1</a></p>\n<blockquote>\n<p>给定序列，求任取一段区间，区间最大值、区间最小值、区间长度之积的最大值。</p>\n<p><span class=\"math inline\">\\(N\\le 2\\times 10^6\\)</span>，值域为 <span class=\"math inline\">\\(10^9\\)</span>。</p>\n</blockquote>\n<p>对于 <span class=\"math inline\">\\(a_i\\)</span>，假设它是 <span class=\"math inline\">\\([X_i, Y_i]\\)</span> 内的最大值，且 <span class=\"math inline\">\\([X_i, Y_i]\\)</span> 是该条件下的极大区间；</p>\n<p>相似地，对于 <span class=\"math inline\">\\(a_j\\)</span>，假设它是 <span class=\"math inline\">\\([P_j, Q_j]\\)</span> 内的最小值，且 <span class=\"math inline\">\\([P_j, Q_j]\\)</span> 是该条件下的极大区间；</p>\n<p>则对于 <span class=\"math inline\">\\(a_i\\)</span> 作为区间内最大值，<span class=\"math inline\">\\(a_j\\)</span> 作为区间内最小值的情况，满足该条件的区间为 <span class=\"math inline\">\\([\\max(X_i, P_j), \\min(Y_i, Q_j)]\\)</span>，答案为 <span class=\"math inline\">\\(k=a_i \\times a_j \\times [\\min(Y_i, Q_j) - \\max(X_i, P_j) + 1]\\)</span>。我们的目标就是最大化 <span class=\"math inline\">\\(k\\)</span>。</p>\n<p>两个不固定的值，并且不能拆给斜优做，所以考虑将其中一个变得「固定」。</p>\n<p>观察数组，我们发现，对于数组中的最大值 <span class=\"math inline\">\\(a_m\\)</span>，有 <span class=\"math inline\">\\(X_m = 1,Y_m=n\\)</span>。那么此时选取 <span class=\"math inline\">\\(a_m\\)</span> 作为区间最大值，选取任意数 <span class=\"math inline\">\\(a_j\\)</span> 作为最小值。这样做可以保证由 <span class=\"math inline\">\\(i\\)</span> 带来的影响都是最优的，只用枚举 <span class=\"math inline\">\\(j\\)</span> 并求解即可。此时的答案就是 <span class=\"math inline\">\\(a_m\\times a_j\\times (Q_j-P_j + 1)\\)</span>。</p>\n<p>我们上述条件成立的前提是 <span class=\"math inline\">\\(i\\)</span> 在 <span class=\"math inline\">\\([P_j, Q_j]\\)</span> 内且 <span class=\"math inline\">\\(j\\)</span> 在 <span class=\"math inline\">\\([X_i, Y_i]\\)</span> 内。当 <span class=\"math inline\">\\(i\\)</span> 取 <span class=\"math inline\">\\(m\\)</span> 时后者显然成立，但很容易构造出来情况让前者不成立。比如说 <code>15 1 5</code>，当 <span class=\"math inline\">\\(j=3\\)</span> 时就会得到错误的答案。</p>\n<p>受刚才的思考启发，取 <span class=\"math inline\">\\([P_j, Q_j]\\)</span> 内的最大值作为 <span class=\"math inline\">\\(i\\)</span>。此时有 <span class=\"math inline\">\\(X_i\\le P_j\\le Q_j \\le Y_j\\)</span>，答案为区间内最优。</p>\n<p>接下来需要求解 <span class=\"math inline\">\\(P_j\\)</span> 和 <span class=\"math inline\">\\(Q_j\\)</span>。观察数据范围，应该是 <span class=\"math inline\">\\(O(n)\\)</span> 做法。不难想到单调栈，可惜我不会，所以采用同样是 <span class=\"math inline\">\\(O(n)\\)</span> 的悬线法（<a href=\"/20220927\">我的博客：有关悬线法的介绍</a>）。</p>\n<p>那么怎么求 <span class=\"math inline\">\\([P_j,Q_j]\\)</span> 内的最大值呢？当遇到这种求解区间与左右端点一致，并且待求满足可加性的情况时，我们可以在悬线的时候一起求解。当悬线跨越一个区间时，我们直接用这个已求解区间的最大值更新当前求的最大值。</p>\n<p>左右分别求最大值（注意要用两个数组分别记录，防止错误更新），最后取两者较大作为最终区间内最大值即可。</p>\n<p>最终时间复杂度 <span class=\"math inline\">\\(O(n)\\)</span>。</p>\n<details>\n<p><summary>🌼 鲜花</summary></p>\n<p>不知道为什么听别人说很卡，不卡啊，我一个点 250ms。</p>\n<p>啊什么你们打的 <span class=\"math inline\">\\(O(n\\log n)\\)</span>？因为单调栈信息断层不能维护区间内最大值？菜。那我必须把这篇发出来嘲讽你们了。兔子说要是不打 <code>fread</code> Lemon 上就会起飞，我说我打了，我还疑惑 <span class=\"math inline\">\\(O(n)\\)</span> 跑 <code>2e6</code> 普通快读怎么会寄呢。一问，啊，带 <span class=\"math inline\">\\(\\log\\)</span>，菜。</p>\n<p>啊什么谭委员带 <span class=\"math inline\">\\(\\log\\)</span> 一个点只要 500ms？那也比我慢，菜。</p>\n</details>\n<p>说起来这是我头一次用悬线解决不在矩阵上，还要维护信息的题，之前并没有细想过单调栈和悬线可维护的信息差异，这次算是误打误撞做对了。</p>\n<p>注意到数据范围，应该要开 <code>__int128</code> 吧。</p>\n<details>\n<pre class=\"cpp\"><code>#define int __int128\nnamespace XSC062 &#123;\nusing namespace fastIO;\nconst int maxn = 2e6 + 5;\nint a[maxn];\nint n, mx, res;\nint l[maxn], r[maxn];\nint mxl[maxn], mxr[maxn];\nint max(int x, int y) &#123; return x &gt; y ? x : y; &#125;\nint main() &#123;\n    read(n), l[0] = 1;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        read(a[i]), l[i] = i;\n        mxl[i] = mxr[i] = a[i];\n        while (l[i] &gt; 1 &amp;&amp; a[l[i] - 1] &gt;= a[i]) &#123;\n            mxl[i] = max(mxl[i], mxl[l[i] - 1]);\n            l[i] = l[l[i] - 1];\n        &#125;\n    &#125;\n    r[n + 1] = n;\n    for (int i = n; i; --i) &#123;\n        r[i] = i;\n        while (r[i] &lt; n &amp;&amp; a[r[i] + 1] &gt;= a[i]) &#123;\n            mxr[i] = max(mxr[i], mxr[r[i] + 1]);\n            r[i] = r[r[i] + 1];\n        &#125;\n        res = max(res, max(mxl[i], mxr[i]) * a[i] * (r[i] - l[i] + 1));\n    &#125;\n    print(res, &#39;\\n&#39;);\n    return 0;\n&#125;\n&#125; // namespace XSC062\n#undef int</code></pre>\n</details>\n<hr />\n<p><em>upd on 240704</em></p>\n<p>我们在 <a href=\"/20220927\">这篇博客</a> 中提到了悬线的本质是笛卡尔树，而本题就是其链上爬山维护数据的一个优秀体现，也是因为这一点，应该更加深切地认识到悬线包含式的访问顺序使之维护的数据类型应和倍增 / 树状数组等类似。</p>\n<p>所以说到可维护数据的复杂程度，笛卡尔树严格大于悬线严格大于单调栈好吧 <img src=\"/em/dy.gif\" /></p>\n<p>虽然现在全世界都知道我是悬线魔怔人了 <img src=\"/em/dy.gif\" /></p>\n",
            "tags": [
                "悬线法"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20220927/",
            "url": "https://xsc062.netlify.app/20220927/",
            "title": "悬线法",
            "date_published": "2022-09-27T02:53:00.000Z",
            "content_html": "<p>有一段时间看见单调栈就抑郁，所以做题的时候就东贺贺，西贺贺，最终了解到了世界上还有一种很神奇的方法叫悬线法。</p>\n<span id=\"more\"></span>\n<p>本文中的「单调栈」均指依赖于顺序维护信息的工具，单纯利用单调性质作为数据结构独立存在的单调栈不在本篇文章 <strong>批判</strong> 范围之内。</p>\n<hr />\n<h2 id=\"引入土豪聪要请客\">引入：土豪聪要请客</h2>\n<p><a href=\"http://222.180.160.110:61235/contest/2870/problem/4\" class=\"uri\">http://222.180.160.110:61235/contest/2870/problem/4</a></p>\n<p>题意简述：给定一个 <span class=\"math inline\">\\(n\\times m\\)</span> 的矩阵，其中有一部分地方有障碍。在整个地图上找到周长最大的、不包含障碍的矩形。</p>\n<p>输入一个由 <code>.</code>（空地）和 <code>X</code>（障碍）组成的矩阵，输出最大矩形周长减 <span class=\"math inline\">\\(1\\)</span>。</p>\n<details>\n<p><summary>一些鲜花</summary></p>\n<p>看到题后即可想到悬线法，但是中午太困了处于游离状态一直掉线，所以干瞪着电脑屏幕打瞌睡。</p>\n<p><del>于是这篇文章从 220927 被拖到了 230916，哈哈真神奇</del> 现在是 231004 了，我才动笔。</p>\n</details>\n<hr />\n<p>首先预处理出 <span class=\"math inline\">\\(s_{i, j}\\)</span>，表示从 <span class=\"math inline\">\\((i,\\,j)\\)</span> 向上，共有多少个连续的 <code>.</code>。</p>\n<pre class=\"cpp\"><code>for (int i = 1; i &lt;= n; ++i) &#123;\n    for (int j = 1; j &lt;= m; ++j)\n        s[i][j] = (a[i][j] == &#39;.&#39; ? s[i - 1][j] + 1 : 0);\n&#125;</code></pre>\n<p>悬线法的名字很形象，拎着一根细线的头，让它自然下垂。</p>\n<p>为了方便思考和实现，我们这样想象：一个地图，我们手里拿着一根硬棒朝上举，然后固定我们手只能在一行上运动，用它左右「刷」沿途的矩形。</p>\n<p>具象地说，选定一行 <span class=\"math inline\">\\(i\\)</span>，枚举每一个 <span class=\"math inline\">\\(j\\)</span>，寻找以第 <span class=\"math inline\">\\(i\\)</span> 行为底，包含 <span class=\"math inline\">\\((i,\\,j)\\)</span>，高为 <span class=\"math inline\">\\(s_{i,\\,j}\\)</span> 的最宽矩形。</p>\n<p>也就是从 <span class=\"math inline\">\\((i, j)\\)</span> 出发，往左右分别找到最远的一个位置 <span class=\"math inline\">\\(L_j, R_j\\)</span>，满足 <span class=\"math inline\">\\(s_{i, L_j \\sim R_j} \\ge s_{i, j}\\)</span>。那么悬线法最抽象的部分就讲完了，接下来是最神奇的部分。</p>\n<p>在第 <span class=\"math inline\">\\(i\\)</span> 行内，从每个 <span class=\"math inline\">\\((i, j)\\)</span> 开始找到 <span class=\"math inline\">\\(L_j, R_j\\)</span>，如果暴力那么明显是个 <span class=\"math inline\">\\(O(m^2)\\)</span> 的时间。</p>\n<p>但是我们考虑这么一件事情。假设 <span class=\"math inline\">\\(L_{i-1}\\)</span> 已经求出。</p>\n<p>令 <span class=\"math inline\">\\(k = j-1\\)</span>，<span class=\"math inline\">\\(L_j\\)</span> 初值赋为 <span class=\"math inline\">\\(j\\)</span>（左端点至少是自己）。</p>\n<ol type=\"1\">\n<li>当 <span class=\"math inline\">\\(L_j=1\\)</span> 时 即刻停止算法，因为 <span class=\"math inline\">\\(1\\)</span> 是可达的最左位置，不能再往左了。</li>\n<li>当 <span class=\"math inline\">\\(a_k &gt; a_j\\)</span> 时 <span class=\"math inline\">\\(a_k\\)</span> 就像一堵墙，堵住了我们要继续往左刷的硬棒，故不改变 <span class=\"math inline\">\\(L_j\\)</span> 并停止算法。</li>\n<li>否则，由于 <span class=\"math inline\">\\(a_{L_k\\sim k}\\ge a_k\\ge a_j\\)</span>，从 <span class=\"math inline\">\\(j\\)</span> 开始往左刷至少都能够到 <span class=\"math inline\">\\(L_k\\)</span>。此时我们令 <span class=\"math inline\">\\(k=L_k-1\\)</span>，回到第一步。</li>\n</ol>\n<p>我们就可以求解到正确的 <span class=\"math inline\">\\(L_j\\)</span> 的。求解 <span class=\"math inline\">\\(R_j\\)</span> 的流程和上述大致相同，不再赘述。</p>\n<hr />\n<p>那么是一个非常神奇的事情。悬线法的时间复杂度怎么证明呢？</p>\n<p>我们思考。假设 <span class=\"math inline\">\\(a_{j-1}&gt;a_j\\)</span>，算法会即刻停止；否则，当前定位直接跳到 <span class=\"math inline\">\\(L_{j-1}\\)</span> 之前，也就是说，为了求解 <span class=\"math inline\">\\(L_{j-1}\\)</span> 而遍历过的位置，求解 <span class=\"math inline\">\\(L_j\\)</span> 时都不会再遍历第二遍。</p>\n<p>没有值会被遍历第二遍，所以是 <span class=\"math inline\">\\(O(m)\\)</span> 的。</p>\n<hr />\n<p>按照上述流程，算法总体时间复杂度 <span class=\"math inline\">\\(O(n\\times m)\\)</span>，和单调栈完全一致。</p>\n<details>\n<pre class=\"cpp\"><code>namespace XSC062 &#123;\nusing namespace fastIO;\nconst int maxn = 2e3 + 5;\nint n, m, ans;\nchar a[maxn][maxn];\nint s[maxn][maxn], l[maxn][maxn], r[maxn][maxn];\nint max(int x, int y) &#123;\n    return x &gt; y ? x : y;\n&#125;\nint main() &#123;\n    read(n);\n    read(m);\n    for (int i = 1; i &lt;= n; ++i)\n        scanf(&quot;%s&quot;, a[i] + 1);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        for (int j = 1; j &lt;= m; ++j)\n            s[i][j] = (a[i][j] == &#39;.&#39; ? s[i - 1][j] + 1 : 0);\n    &#125;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        for (int j = 1; j &lt;= m; ++j) &#123;\n            l[i][j] = j;\n            while (l[i][j] &gt; 1 &amp;&amp; s[i][j] &lt;= s[i][l[i][j] - 1])\n                l[i][j] = l[i][l[i][j] - 1];\n        &#125;\n    &#125;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        for (int j = m; j; --j) &#123;\n            r[i][j] = j;\n            while (r[i][j] &lt; m &amp;&amp; s[i][j] &lt;= s[i][r[i][j] + 1])\n                r[i][j] = r[i][r[i][j] + 1];\n        &#125;\n    &#125;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        for (int j = 1; j &lt;= m; ++j) &#123;\n            if (!s[i][j])\n                continue;\n            ans = max(ans, (s[i][j] +\n                      (r[i][j] - l[i][j] + 1)) * 2);\n        &#125;\n    &#125;\n    printf(&quot;%d&quot;, ans - 1);\n    return 0;\n&#125;\n&#125; // namespace XSC062</code></pre>\n</details>\n<hr />\n<p>上述处理 <span class=\"math inline\">\\(s\\)</span> 数组的「竖向压缩」技巧是处理矩阵类悬线法题目的常用技巧，这里使用另一道题来举例子。</p>\n<h3 id=\"例玉蟾宫-city-game-城市游戏\">例：玉蟾宫 / City Game / 城市游戏</h3>\n<p><a href=\"http://222.180.160.110:61235/contest/1655/problem/2\" class=\"uri\">http://222.180.160.110:61235/contest/1655/problem/2</a></p>\n<p>这道题和上一道非常相似，只需改变求答案的式子即可。</p>\n<details>\n<pre class=\"cpp\"><code>namespace XSC062 &#123;\nusing namespace fastIO;\nconst int maxn = 1e3 + 5; \nchar t;\nint n, m, ans;\nint s[maxn][maxn];\nint l[maxn][maxn], r[maxn][maxn];\nint max(int x, int y) &#123;\n    return x &gt; y ? x : y;\n&#125;\nint main() &#123;\n    scanf(&quot;%d %d&quot;, &amp;n, &amp;m);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        for (int j = 1; j &lt;= m; ++j) &#123;\n            scanf(&quot;%1s&quot;, &amp;t);\n            if (t == &#39;F&#39;)\n                s[i][j] = s[i - 1][j] + 1;\n            l[i][j] = j;\n            while (l[i][j] &gt; 1 &amp;&amp; s[i][j]\n                        &lt;= s[i][l[i][j] - 1])\n                l[i][j] = l[i][l[i][j] - 1];\n        &#125;\n    &#125;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        r[i][m + 1] = m + 1;\n        for (int j = m; j; --j) &#123;\n            r[i][j] = j;\n            while (r[i][j] &lt; m &amp;&amp; s[i][j]\n                         &lt;= s[i][r[i][j] + 1])\n                r[i][j] = r[i][r[i][j] + 1];\n            ans = max(ans, s[i][j] *\n                        (r[i][j] - l[i][j] + 1));\n        &#125;\n    &#125;\n    print(ans * 3, &#39;\\n&#39;);\n    return 0;\n&#125;\n&#125; // namespace XSC062</code></pre>\n</details>\n<hr />\n<h2 id=\"悬线法能维护的数据特点\">悬线法能维护的数据特点</h2>\n<p>值得注意的是，悬线法仅指求解最远左右端点的技巧。</p>\n<p>同时可以维护过程中的其它信息，例如 <a href=\"/20231004\">情景剧</a> 一题。链接中有详细叙述，此处略。</p>\n<p>根据本题带来的启发，我们认识到悬线可在求解过程中维护的内容更多。</p>\n<p><del>不像你单调栈随随便便删这删那信息全部断层什么都维护不了</del></p>\n<hr />\n<h2 id=\"进一步地悬线法与单调栈\">进一步地，悬线法与单调栈？</h2>\n<p>和 <span class=\"citation\" data-cites=\"Rosmist\">@Rosmist</span> 辩经的时候，Rosmist 激情爆典：「悬线不就是可持久化单调栈吗？」</p>\n<p>很有道理。容易发现单调栈在每一个 <span class=\"math inline\">\\(i\\)</span> 时刻的栈内元素就是从 <span class=\"math inline\">\\(i\\)</span> 开始往起始方向跳，经过的所有元素。由于悬线存储的数据是不会更改的，倒推回去我们可以知道，悬线存储了每个时刻的单调栈信息并有多个点共享前驱 / 后继，其实就是一种另类的可持久化单调栈，并且复杂度与单调栈本体相同。</p>\n<hr />\n<h2 id=\"与笛卡尔树的关联\">与笛卡尔树的关联</h2>\n<p><em>upd on 240704</em>，学习了笛卡尔树。现在介绍悬线与笛卡尔树的关系。</p>\n<p>容易发现元素 <span class=\"math inline\">\\(i\\)</span> 的 <span class=\"math inline\">\\(l_i,r_i\\)</span> 二值就是其在笛卡尔树上对应的区间。</p>\n<p>更抽象的一点是悬线法中跳一跳的操作在笛卡尔树中的对应内涵。以小根堆为背景、在 <span class=\"math inline\">\\(l\\)</span> 上向左跳为例，注意到该操作相当于从左到右向笛卡尔树中新增节点。</p>\n<p>这也进一步验证了悬线法复杂度的正确性：我们都知道，在新加入节点时，若从树中提取出由根节点和其一直向右走直到节点不存在右儿子构成的链，则该点被添加到链中某一点的右儿子，该点原本的右子树（完整包含了链的剩余部分）成为新建节点的左子树。</p>\n<p>而悬线实现的就是从链的最低点暴力爬山，直到找到合法点；而根据上面的结论，被枚举过的链上较低点不会作为新节点的右边的子孙，自然也不会再次被枚举到。</p>\n<p>故而每个点最多被枚举到一次，得证。</p>\n<p>进一步的，可以开发出悬线法 <span class=\"math inline\">\\(O(n)\\)</span> 建笛卡尔树的方法：</p>\n<p>每次求解完 <span class=\"math inline\">\\(l_i\\)</span> 后，令 <span class=\"math inline\">\\(rc_{l_i-1}=i\\)</span> 即可（当然 <span class=\"math inline\">\\(rc_{l_i-1}\\)</span> 是会被多次更新的，这也是不直接用邻接表 / 前向星连边的原因），<span class=\"math inline\">\\(r_i\\)</span> 与 <span class=\"math inline\">\\(lc\\)</span> 同理。</p>\n<pre class=\"cpp\"><code>for (int i = 1; i &lt;= n; ++i) &#123;\n    l[i] = i;\n    while (l[i] != 1 &amp;&amp; a[l[i] - 1] &gt; a[i])\n        l[i] = l[l[i] - 1];\n    rc[l[i] - 1] = i;\n&#125;\nfor (int i = n; i; --i) &#123;\n    r[i] = i;\n    while (r[i] != n &amp;&amp; a[r[i] + 1] &gt; a[i])\n        r[i] = r[r[i] + 1];\n    lc[r[i] + 1] = i;\n&#125;</code></pre>\n<p>其中，根节点即为 <code>rc[0]</code> 或 <code>lc[n + 1]</code>。</p>\n<hr />\n<p>进一步从笛卡尔树出发，探究悬线法能够循环内维护的数据特点。</p>\n<p>为何是循环内维护？因为循环外维护就只能从左右的直接儿子进行更新，那和笛卡尔树就没有区别了。</p>\n<p>但其实结果是没什么可探究的，因为其经过的节点——自己左子树下最右端链——实在不具有什么特殊性，它们所对应的区间——从 <span class=\"math inline\">\\([l_i, i - 1]\\)</span> 到 <span class=\"math inline\">\\([i - 1, i - 1]\\)</span> 也看不出什么值得研究的，更何况可以被笛卡尔树更具象地代替；如果你要从前缀最值的角度出发，那就没意思了，完全等价于单调栈。</p>\n<p>所以我们认为这次悬线法的开发最终以失败告终，<del>不然它早被别人开发了</del>，我在此能给出的意见是，可以用悬线法完成矩形题目等不需要笛卡尔树树形结构的问题，至于其他，甚至包括上面提到的 <a href=\"/20231004\">情景剧</a> 一题，都可以直接上笛卡尔树。</p>\n<p>但笛卡尔树的建树我还是肯定会用悬线的！毕竟照应开头，我不会单调栈 <img src=\"/em/dy.gif\" alt=\"得意\" /></p>\n",
            "tags": [
                "悬线法"
            ]
        }
    ]
}