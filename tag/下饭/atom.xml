<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://xsc062.netlify.app</id>
    <title> • Posts by &#34;下饭&#34; tag</title>
    <link href="https://xsc062.netlify.app" />
    <updated>2024-10-27T00:48:02.000Z</updated>
    <category term="并查集" />
    <category term="斜率优化" />
    <category term="悬线法" />
    <category term="哈希" />
    <category term="字典树" />
    <category term="DP" />
    <category term="单调队列" />
    <category term="分治" />
    <category term="二分图" />
    <category term="CRT / exCRT" />
    <category term="排列组合" />
    <category term="网络流" />
    <category term="费用流" />
    <category term="二分" />
    <category term="上下界网络流" />
    <category term="容斥原理" />
    <category term="线段树" />
    <category term="树状数组" />
    <category term="区间 DP" />
    <category term="构造" />
    <category term="Tarjan" />
    <category term="数据结构" />
    <category term="下饭" />
    <category term="LCA" />
    <category term="倍增" />
    <category term="鸽巢原理" />
    <category term="概率期望" />
    <category term="调和级数" />
    <category term="差分" />
    <category term="思维" />
    <category term="树形 DP" />
    <category term="最小生成树" />
    <category term="SAM" />
    <category term="状压" />
    <category term="分块" />
    <category term="可持久化" />
    <category term="笛卡尔树" />
    <category term="高维前缀和" />
    <category term="闲话" />
    <category term="欧拉回路" />
    <category term="树链剖分" />
    <category term="长链剖分" />
    <category term="KMP" />
    <category term="border" />
    <category term="字符串" />
    <category term="AC 自动机" />
    <category term="SA" />
    <category term="数学" />
    <category term="树上差分" />
    <category term="FWT" />
    <category term="堆" />
    <category term="树的重心" />
    <category term="二项式定理" />
    <category term="二项式反演" />
    <category term="贪心" />
    <category term="均摊" />
    <category term="计数" />
    <category term="优化建图" />
    <category term="反悔贪心" />
    <category term="调整法" />
    <category term="背包" />
    <category term="博弈论" />
    <category term="DP 优化" />
    <category term="虚树" />
    <category term="点分治" />
    <category term="WQS 二分" />
    <category term="闵可夫斯基和" />
    <category term="slope trick" />
    <category term="四边形不等式" />
    <category term="暴力" />
    <category term="状压 DP" />
    <category term="组合数学" />
    <category term="支配对" />
    <category term="DDP" />
    <category term="平衡树" />
    <category term="容斥" />
    <category term="猫树" />
    <category term="Kruskal 重构树" />
    <category term="李超线段树" />
    <entry>
        <id>https://xsc062.netlify.app/20241027/</id>
        <title>CSP-S</title>
        <link rel="alternate" href="https://xsc062.netlify.app/20241027/"/>
        <content type="html">&lt;p&gt;弟娃年方十一。方出考场之时，余问弟娃曰：「T1 用时几何？」。弟娃对曰：「及过大样例，已半炷香矣。」余大恸，为余 T1 大样例既过，已两柱香有余。古谚有云：「若有一人年少于吾亦强于吾，吾为之单调队列也。」吾弟娃年少于吾，殊难易之；今吾弟娃已四倍而强于吾，吾盍为单调队列哉！&lt;/p&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;
&lt;hr /&gt;
&lt;p&gt;忆往昔昔（初二），1=。忆往昔昔昔（初一），1=。忆往昔（初三），135pts 喜提 2=。&lt;/p&gt;
&lt;p&gt;看今朝，300pts 应该有 1=。哇恭喜恭喜，2= 到 1=，一年来你有很大进步呢！&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;a.-duel&#34;&gt;A. duel&lt;/h2&gt;
&lt;p&gt;非常遗憾地，被橙题&lt;mark&gt;硬控 1h+&lt;/mark&gt;。问就是上场之后先花了 59min 下载 &lt;em&gt;大脑.tar.gz&lt;/em&gt;，然后 1s 知道做法，59s 实现。&lt;/p&gt;
&lt;p&gt;其实我们是注意到了众数的那个奇妙结论的，但是因为太奇怪并且担心是因为大样例太水所以没敢写，不服来战。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;b.-detect&#34;&gt;B. detect&lt;/h2&gt;
&lt;p&gt;我们在求解出区间后被精度问题&lt;mark&gt;硬控 1h+&lt;/mark&gt;。在按照右端点排序后超厉害地使用 &lt;strong&gt;线段树优化 DP&lt;/strong&gt; 解决了初一简单线性贪心问题。哈哈哈。&lt;/p&gt;
&lt;p&gt;笑话：被精度问题控的 1h 里有 40min 扑在因为调精度而打出来的 &lt;em&gt;死循环&lt;/em&gt; 上 &lt;img src=&#34;/em/kx.gif&#34; /&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;c.-color&#34;&gt;C. color&lt;/h2&gt;
&lt;p&gt;在 5min 解决费用提前计算式子后删除了 node_modules &amp;gt; 大脑，稍加思考得出了「大抵是不存在不带 &lt;span class=&#34;math inline&#34;&gt;\(\log\)&lt;/span&gt; 的全局修改、单点修改、单点查询的数据结构的」的结论，超厉害地使用 &lt;strong&gt;线段树优化 DP&lt;/strong&gt;，并且被全局修改懒标记没传给树根&lt;mark&gt;硬控 1h+&lt;/mark&gt;。&lt;/p&gt;
&lt;p&gt;不过因为知道 1e6 的数据给线段树确实挺奇怪的，所以大力卡常，赛时代码跑民间数据跑得挺快。也就是线性所有点加起来 500ms，我一个点就要跑 500ms 的水平 &lt;img src=&#34;/em/kx.gif&#34; /&gt; 虽然肯定 T 是不可能 T 的。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;d.-arena&#34;&gt;D. arena&lt;/h2&gt;
&lt;p&gt;坏消息：前三题均被硬控 1h+，T4 连暴力都打不完了，甚而至于，输入都打不完喜提零蛋。&lt;/p&gt;
&lt;p&gt;好消息：看开点，至少 T4 不会被&lt;mark&gt;硬控 1h+&lt;/mark&gt; &lt;img src=&#34;/em/kx.gif&#34; /&gt;&lt;/p&gt;
&lt;p&gt;这道题有个好写的做法，先胡一胡，等会儿开一篇具体写一写。&lt;/p&gt;
&lt;p&gt;还原到每场比赛胜出者能力值（线性），还需要注意到一个单调性：若在加入一个人后某场比赛的胜者就不可能成为全局胜者（相当于知道其祖先中某个元素的具体胜者，且该胜者不是自己），那么加入更多的人也不行。故记录这个人（假设对于比赛 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 为 &lt;span class=&#34;math inline&#34;&gt;\(id_x\)&lt;/span&gt;），那么知道了所有叶子的 &lt;span class=&#34;math inline&#34;&gt;\(id\)&lt;/span&gt; 就可以随便乱搞了。至于求 &lt;span class=&#34;math inline&#34;&gt;\(id\)&lt;/span&gt; 的过程，直接把 &lt;span class=&#34;math inline&#34;&gt;\(1\sim n\)&lt;/span&gt; 的人加入二叉树，如果某个点被确定了胜者，就往败者子树打一个标记，完了过后遍历整个树下传标记即可。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;小知识：在 2024 CSP-S2 中，99% 的人打了 0 个 &lt;strong&gt;线段树优化 DP&lt;/strong&gt;，而你打了 2 个 &lt;strong&gt;线段树优化 DP&lt;/strong&gt; &lt;img src=&#34;/em/kx.gif&#34; /&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;可怜捏。100 + 100 + 100 + 0 = 300。由于 T4 输入没写完是没机会浮动了。拜拜 WC。&lt;/p&gt;
&lt;p&gt;草草草，wc 都拜拜了我今年是不是直接原地 afo 了啊。不要啊不要啊。&lt;/p&gt;
</content>
        <category term="下饭" />
        <updated>2024-10-27T00:48:02.000Z</updated>
    </entry>
    <entry>
        <id>https://xsc062.netlify.app/20231117/</id>
        <title>TRICKS</title>
        <link rel="alternate" href="https://xsc062.netlify.app/20231117/"/>
        <content type="html">&lt;p&gt;想着写点什么东西，就是说，不会被归入知识点（upd：并非不会），却又感觉很常用（upd：并非常用）的东西。&lt;/p&gt;
&lt;p&gt;哦我懂了，通常来说我们管这个叫 trick。&lt;/p&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;ds&#34;&gt;DS&lt;/h2&gt;
&lt;details&gt;
&lt;p&gt;&lt;summary&gt;&lt;strong&gt;容易记错的操作复杂度：&lt;/strong&gt;&lt;/summary&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;线段树合并、线段树建树&lt;/strong&gt;：&lt;span class=&#34;math inline&#34;&gt;\(O(n)\)&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;FHQ Treap 建树：视作笛卡尔树，&lt;span class=&#34;math inline&#34;&gt;\(O(n)\)&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;动态开店线段树单次访问至多增加 &lt;span class=&#34;math inline&#34;&gt;\(4\log\)&lt;/span&gt; 个点，e.g. &lt;span class=&#34;math inline&#34;&gt;\([2,n-1]\)&lt;/span&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/details&gt;
&lt;details&gt;
&lt;p&gt;&lt;summary&gt;&lt;strong&gt;随机序列的笛卡尔树：&lt;/strong&gt;&lt;/summary&gt;&lt;/p&gt;
&lt;p&gt;是 Treap。&lt;/p&gt;
&lt;/details&gt;
&lt;details&gt;
&lt;p&gt;&lt;summary&gt;&lt;strong&gt;有『合并』功能的 DS：&lt;/strong&gt;&lt;/summary&gt;&lt;/p&gt;
&lt;p&gt;并查集，线段树，&lt;strong&gt;字典树&lt;/strong&gt;，笛卡尔树，BST。&lt;/p&gt;
&lt;/details&gt;
&lt;details&gt;
&lt;p&gt;&lt;summary&gt;&lt;strong&gt;复杂度依赖『均摊』的 DS：&lt;/strong&gt;&lt;/summary&gt;&lt;/p&gt;
&lt;p&gt;并查集，线段树 / 字典树合并。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;不强制在线&lt;/strong&gt; &lt;strong&gt;复杂度不依赖均摊&lt;/strong&gt; 的可持久化数据结构 &lt;span class=&#34;math inline&#34;&gt;\(\to\)&lt;/span&gt; DAG 上直接模拟。&lt;/p&gt;
&lt;/details&gt;
&lt;details&gt;
&lt;p&gt;&lt;summary&gt;&lt;strong&gt;部分可持久化：&lt;/strong&gt;&lt;/summary&gt;&lt;/p&gt;
&lt;p&gt;只要求『在最新版本上修改』和『查询所有版本』的可持久化数组可以在 &lt;code&gt;vector&lt;/code&gt; 上二分，又唤部分可持久化。&lt;/p&gt;
&lt;/details&gt;
&lt;details&gt;
&lt;p&gt;&lt;summary&gt;&lt;strong&gt;字典树维护二进制操作：&lt;/strong&gt;&lt;/summary&gt;&lt;/p&gt;
&lt;p&gt;字典树的节点 id 可视作对信息的引用，也即，如果在初次插入时记录了某个元素对应的 id，相当于获取了元素的引用。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单点修改：拿出来，修改，塞进去，单次修改 &lt;span class=&#34;math inline&#34;&gt;\(O(\log V)\)&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;全局 &lt;code&gt;xor&lt;/code&gt;：打懒标记，单次修改 &lt;span class=&#34;math inline&#34;&gt;\(O(1)\)&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;全局 +1 / -1：字典树上信息必须从低位到高位存储。现场处理，（发现只会递归一条链），单次修改 &lt;span class=&#34;math inline&#34;&gt;\(O(\log V)\)&lt;/span&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/details&gt;
&lt;details&gt;
&lt;p&gt;&lt;summary&gt;&lt;strong&gt;线段树可维护的经典信息：&lt;/strong&gt;&lt;/summary&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;操作：插入 / 删除区间，询问：值域内未被覆盖的点的信息：&lt;/p&gt;
&lt;p&gt;线段树维护节点内被覆盖次数最小值和最小值信息；当最小值为 &lt;span class=&#34;math inline&#34;&gt;\(0\)&lt;/span&gt; 时，将信息纳入统计。&lt;/p&gt;
扩：维护值域内恰好被区间覆盖 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 次的点的信息：线段树维护节点内前 &lt;span class=&#34;math inline&#34;&gt;\(k+1\)&lt;/span&gt; 小值的信息，则 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 一定出现在前 &lt;span class=&#34;math inline&#34;&gt;\(k+1\)&lt;/span&gt; 小值中。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;线段树维护函数：如果对于任意区间，都能定义一个定义域为该区间的函数，可以线段树维护该函数。维护的总点数是 &lt;span class=&#34;math inline&#34;&gt;\(n\log n\)&lt;/span&gt; 的。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;数学&#34;&gt;数学&lt;/h2&gt;
&lt;!-- &lt;details&gt;&lt;summary&gt; --&gt;
&lt;details&gt;
&lt;p&gt;&lt;summary&gt;&lt;strong&gt;常见数据对应的数列：&lt;/strong&gt;&lt;/summary&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class=&#34;math inline&#34;&gt;\(\{1,1,2,3,5,8,\cdots\}\)&lt;/span&gt; 是斐波那契；矩阵可以优化；生成函数可以找通项；&lt;span class=&#34;math inline&#34;&gt;\(f_i=\sum\limits_{i=0}^nC_n-i^i\)&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;math inline&#34;&gt;\(\{1, 1, 2, 5, 14\cdots\}\)&lt;/span&gt; 是 Catalan，走网格不能穿过对角线 / 构造二叉树方案数 / 一群人买电影票。&lt;a href=&#34;/20250419/#不经过-yxc-的方案数&#34;&gt;有组合求法 &lt;span class=&#34;math inline&#34;&gt;\({2n\choose n} - {2n \choose n - 1}\)&lt;/span&gt;&lt;/a&gt;；生成函数还是可以找通项；&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;math inline&#34;&gt;\(\{3, 7, 6, 15, 25, 10, 31, 90, 65, 15, 63, 301, 350, 140, 21, 127, 966,\cdots\}\)&lt;/span&gt;，中间插着一堆 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt;，是展开了的第二类斯特林数三角形，把 &lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt; 个不同球，不空放，放到 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 个相同盒子的方案数，有递推式 &lt;span class=&#34;math inline&#34;&gt;\(S(n,k)=S(n-1,k-1)+k\cdot S(n-1,k)\)&lt;/span&gt; 和二项式反演出来的通项 &lt;span class=&#34;math inline&#34;&gt;\(S(n,m)=\sum\limits_{i=0}^m\dfrac {(-1)^{m-i}\cdot i^n}{i!\cdot (m-i)!}\)&lt;/span&gt;。多项式可以 &lt;span class=&#34;math inline&#34;&gt;\(n\log\)&lt;/span&gt; 算同一行 / 列，方法不太一样。&lt;/li&gt;
&lt;/ul&gt;
&lt;/details&gt;
&lt;details&gt;
&lt;p&gt;&lt;summary&gt;&lt;strong&gt;&lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt; 被取模后的组合数：&lt;/strong&gt;&lt;/summary&gt;&lt;/p&gt;
&lt;p&gt;将原式展开，&lt;span class=&#34;math inline&#34;&gt;\(\binom nm=\frac 1{m!} \prod\limits_{i=0}^{m-1} (n-i)\)&lt;/span&gt;，容易发现 &lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt; 取模是没有影响的，如果模数很小则可以预处理模数范围内的阶乘，如果 &lt;span class=&#34;math inline&#34;&gt;\(m\)&lt;/span&gt; 很小则可以每次 &lt;span class=&#34;math inline&#34;&gt;\(O(m)\)&lt;/span&gt; 现算。&lt;/p&gt;
&lt;p&gt;同理可以发现 &lt;span class=&#34;math inline&#34;&gt;\(m\)&lt;/span&gt; 是不能直接取模的，如果需要给 &lt;span class=&#34;math inline&#34;&gt;\(m\)&lt;/span&gt; 取模就只能用 Lucas。&lt;/p&gt;
&lt;/details&gt;
&lt;details&gt;
&lt;p&gt;&lt;summary&gt;&lt;strong&gt;&lt;span class=&#34;math inline&#34;&gt;\(O(V\log V)\)&lt;/span&gt; 求数的因数：&lt;/strong&gt;&lt;/summary&gt;&lt;/p&gt;
&lt;p&gt;假设 &lt;span class=&#34;math inline&#34;&gt;\(n=V=5\times 10^6\)&lt;/span&gt;，那么对于每个数暴力分解就是 &lt;span class=&#34;math inline&#34;&gt;\(O(n\sqrt V)\)&lt;/span&gt; 的，无法通过。&lt;/p&gt;
&lt;p&gt;埃筛预处理，存储每个数的所有因数就可以 &lt;span class=&#34;math inline&#34;&gt;\(O(V\log V)\)&lt;/span&gt; 求了。&lt;/p&gt;
&lt;/details&gt;
&lt;details&gt;
&lt;p&gt;&lt;summary&gt;&lt;strong&gt;求线段穿过直线系的次数：&lt;/strong&gt;&lt;/summary&gt;&lt;/p&gt;
&lt;p&gt;求线段 &lt;span class=&#34;math inline&#34;&gt;\((x_1,y_1,x_2,y_2)\)&lt;/span&gt; 穿过直线系 &lt;span class=&#34;math inline&#34;&gt;\(x+y=k\cdots m(k\in \mathbb{N}^*)\)&lt;/span&gt; 的次数算出线段中 &lt;span class=&#34;math inline&#34;&gt;\(x+y\)&lt;/span&gt; 的取值范围也即 &lt;span class=&#34;math inline&#34;&gt;\([x_1+y_1,x_2+y_2]\)&lt;/span&gt;（斜率为负就不同了，但可以证明都是单调的），求出 &lt;span class=&#34;math inline&#34;&gt;\(k\cdot m\)&lt;/span&gt; 在里面的出现次数就可以了。&lt;del&gt;有的人高中数学欠的债要到竞赛来还&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;goto &lt;a href=&#34;https://codeforces.com/contest/2098/problem/E&#34;&gt;CF2098E&lt;/a&gt;。&lt;/p&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;图论&#34;&gt;图论&lt;/h2&gt;
&lt;details&gt;
&lt;p&gt;&lt;summary&gt;&lt;span class=&#34;math inline&#34;&gt;\(m-n\)&lt;/span&gt; 很小带来的隐含条件&lt;/summary&gt;&lt;/p&gt;
&lt;p&gt;DFS 树的反祖边很少，可以基于这一点想一些比较暴力的做法。&lt;/p&gt;
&lt;p&gt;goto &lt;a href=&#34;http://localhost:4000/20250816/#g---count-simple-paths-2&#34;&gt;solu to &lt;em&gt;Count Simple Paths 2&lt;/em&gt;&lt;/a&gt;。&lt;/p&gt;
&lt;/details&gt;
&lt;h3 id=&#34;经典建模&#34;&gt;经典建模&lt;/h3&gt;
&lt;details&gt;
&lt;p&gt;&lt;summary&gt;&lt;strong&gt;左部点度数为 &lt;span class=&#34;math inline&#34;&gt;\(2\)&lt;/span&gt; 的二分图匹配：&lt;/strong&gt;&lt;/summary&gt;&lt;/p&gt;
&lt;p&gt;一系列元素，每个元素有不超过两种可选值，要求最终每个元素值不同，求方案数。&lt;/p&gt;
&lt;p&gt;对所有可选值建图。如果只有一个可选值，看作两种可选值相同，连自环；否则把两个可选值连边。此时一个元素对应一条边，即对于每条边选一个端点，满足每个端点被选最多一次。&lt;/p&gt;
&lt;p&gt;对于所有连通块：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;若 &lt;span class=&#34;math inline&#34;&gt;\(n&amp;gt;m+1\)&lt;/span&gt;： 没有这种可能性（不连通）。&lt;/li&gt;
&lt;li&gt;若 &lt;span class=&#34;math inline&#34;&gt;\(n=m+1\)&lt;/span&gt;，即该连通块为树，任选一个点不选都能唯一构成一组解，方案数为 &lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;若 &lt;span class=&#34;math inline&#34;&gt;\(n=m\)&lt;/span&gt;，即形成基环树：&lt;/p&gt;
&lt;p&gt;由于环上点只能且必须被环上边选，树上边的选法唯一。主要讨论环边选法。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;若环为自环，答案为 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt;；&lt;/li&gt;
&lt;li&gt;否则枚举环上所有边是统一选顺 / 逆时针方向的端点，答案为 &lt;span class=&#34;math inline&#34;&gt;\(2\)&lt;/span&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;若 &lt;span class=&#34;math inline&#34;&gt;\(n&amp;lt;m\)&lt;/span&gt;：&lt;/p&gt;
&lt;p&gt;点不够用，答案为 &lt;span class=&#34;math inline&#34;&gt;\(0\)&lt;/span&gt;。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最后把所有连通块的答案相乘就可以得到总答案。&lt;/p&gt;
&lt;p&gt;goto &lt;a href=&#34;https://vjudge.net/problem/OpenJ_POJ-C19A&#34;&gt;Ball&lt;/a&gt;, &lt;a href=&#34;https://codeforces.com/contest/2097/problem/B&#34;&gt;Baggage Claim&lt;/a&gt;, &lt;a href=&#34;https://atcoder.jp/contests/tkppc6-2/tasks/tkppc6_2_g&#34;&gt;Must be Distinct!&lt;/a&gt;。&lt;/p&gt;
&lt;/details&gt;
&lt;details&gt;
&lt;p&gt;&lt;summary&gt;&lt;strong&gt;凸多边形三角剖分转化为树上问题&lt;/strong&gt;：&lt;/summary&gt;&lt;/p&gt;
&lt;p&gt;结论：若把三角形视作 &lt;span class=&#34;math inline&#34;&gt;\(n-2\)&lt;/span&gt; 个点，在有公共边的三角形之间连边可以得到树。&lt;/p&gt;
&lt;p&gt;证明：有 &lt;span class=&#34;math inline&#34;&gt;\(n-3\)&lt;/span&gt; 条边，显然每条边都被两个三角形共用；至于为什么是 &lt;span class=&#34;math inline&#34;&gt;\(n-2\)&lt;/span&gt; 个三角形请移步计几。&lt;/p&gt;
&lt;p&gt;生成方法：易发现肯定存在 &lt;span class=&#34;math inline&#34;&gt;\(\ge 2\)&lt;/span&gt; 个顶点不被任何对角线经过（其属于一个叶子三角形），其度数为 &lt;span class=&#34;math inline&#34;&gt;\(2\)&lt;/span&gt;；用类似拓扑排序的方式，不断切下叶子三角形并寻找新的叶子三角形，就可以找到所有点。注意到对角线就是树边，记录每条对角线两侧的三角形，连边即可。&lt;/p&gt;
&lt;p&gt;goto &lt;a href=&#34;/20250612/#b---distance-on-triangulation&#34;&gt;solu to &lt;em&gt;Distance on Triangulation&lt;/em&gt;&lt;/a&gt;。&lt;/p&gt;
&lt;/details&gt;
&lt;h3 id=&#34;优化建图&#34;&gt;优化建图&lt;/h3&gt;
&lt;details&gt;
&lt;p&gt;&lt;summary&gt;&lt;strong&gt;前缀和优化建图：&lt;/strong&gt;&lt;/summary&gt;&lt;/p&gt;
&lt;p&gt;要求每条边都指向某个前缀区间；与线段树优化建图相比的优势是虚点、边数均为 &lt;span class=&#34;math inline&#34;&gt;\(O(n)\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;Goto &lt;a href=&#34;/20250505/&#34;&gt;solu to &lt;em&gt;喝醉的兔子&lt;/em&gt;&lt;/a&gt;。&lt;/p&gt;
&lt;/details&gt;
&lt;h3 id=&#34;图上-dp&#34;&gt;图上 DP&lt;/h3&gt;
&lt;details&gt;
&lt;p&gt;&lt;summary&gt;&lt;strong&gt;有环图的 DP 顺序：&lt;/strong&gt;&lt;/summary&gt;&lt;/p&gt;
&lt;p&gt;有环图上的 DP，通常来说可以根据状态转移方程的形式找到环上的「根源」，即不由任何环上节点转移得到。&lt;/p&gt;
&lt;p&gt;无视根源在环上的前驱边就可以用类拓扑的方式转移。&lt;/p&gt;
&lt;p&gt;Goto &lt;a href=&#34;/20231113/#b.-商人&#34;&gt;solu to 商人&lt;/a&gt;。&lt;/p&gt;
&lt;/details&gt;
&lt;h3 id=&#34;树的直径图的直径&#34;&gt;树的直径，图的直径&lt;/h3&gt;
&lt;details&gt;
&lt;p&gt;&lt;summary&gt;&lt;strong&gt;半径与中点的定义：&lt;/strong&gt;&lt;/summary&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;半径&lt;/strong&gt;：图 / 树的半径（&lt;strong&gt;数值上为 &lt;span class=&#34;math inline&#34;&gt;\(\min\limits_x\{\max\limits_y dis(x, y)\}\)&lt;/span&gt;&lt;/strong&gt;）的一端一定在直径上，且在直径中间。如果不带权的话就是直径长度的一半 &lt;del&gt;不然为啥叫半径&lt;/del&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;中点&lt;/strong&gt;：半径在直径上的端点，有一个（直径为奇）或两个（直径为偶），均满足到所有点的距离不超过半径。&lt;/li&gt;
&lt;/ul&gt;
&lt;/details&gt;
&lt;details&gt;
&lt;p&gt;&lt;summary&gt;&lt;strong&gt;直径的性质：&lt;/strong&gt;&lt;/summary&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;图的直径的性质&lt;/strong&gt;：&lt;/p&gt;
&lt;ol type=&#34;1&#34;&gt;
&lt;li&gt;不能用两次 BFS 求，原因：图不满足『距离任意点最远的点都是直径的一个端点』这条贪心性质。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;设图的直径为 &lt;span class=&#34;math inline&#34;&gt;\(d\)&lt;/span&gt;，对于任意点 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt;，其和其他点最短路的最大值 &lt;span class=&#34;math inline&#34;&gt;\(s\)&lt;/span&gt; 满足：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
\left\lceil \dfrac d2\right\rceil \le s\le d
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;等价形式：&lt;span class=&#34;math inline&#34;&gt;\(d\in[s, 2s]\)&lt;/span&gt;。&lt;/p&gt;
证明：上界显然；对于下界，取图中心 &lt;span class=&#34;math inline&#34;&gt;\(m\)&lt;/span&gt;，对任意 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 找到距其最远的点 &lt;span class=&#34;math inline&#34;&gt;\(y\)&lt;/span&gt;。由松弛，显然有 &lt;span class=&#34;math inline&#34;&gt;\(d(x,y)\le d(x,m)+d(y,m)\)&lt;/span&gt;。又 &lt;span class=&#34;math inline&#34;&gt;\(d(x,m),d(y,m)\le r\)&lt;/span&gt;，故 &lt;span class=&#34;math inline&#34;&gt;\(d(x,y)\le 2r\)&lt;/span&gt;，也即 &lt;span class=&#34;math inline&#34;&gt;\(d\ge d(x,y)\)&lt;/span&gt;。&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;树的直径的性质&lt;/strong&gt;：&lt;/p&gt;
&lt;ol type=&#34;1&#34;&gt;
&lt;li&gt;树的所有直径交于树的所有中点（参考半径，如果长度为偶数就是两个点）；&lt;/li&gt;
&lt;li&gt;向树中加一个叶子，最多改变直径的一个端点。&lt;/li&gt;
&lt;li&gt;距离任意点最远的点都是直径的一个端点。&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/details&gt;
&lt;details&gt;
&lt;p&gt;&lt;summary&gt;&lt;strong&gt;半径的性质 / 离树上某点最远的点：&lt;/strong&gt;&lt;/summary&gt;&lt;/p&gt;
&lt;p&gt;将中心边（若有两条任选一条）提出来，让两侧的点作为根；&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;对于一个点 &lt;span class=&#34;math inline&#34;&gt;\(u\)&lt;/span&gt;，离它最远的点一定在另一棵树中最深的位置。&lt;/p&gt;
&lt;/details&gt;
&lt;details&gt;
&lt;p&gt;&lt;summary&gt;&lt;strong&gt;动态维护树的直径：&lt;/strong&gt;&lt;/summary&gt;&lt;/p&gt;
&lt;p&gt;如果知道一个连通块内的直径是 &lt;span class=&#34;math inline&#34;&gt;\(x\to y\)&lt;/span&gt;，另一个是 &lt;span class=&#34;math inline&#34;&gt;\(a\to b\)&lt;/span&gt;，那么两个合并起来的直径一定是 &lt;span class=&#34;math inline&#34;&gt;\(\{x,y,a,b\}\)&lt;/span&gt; 里的 &lt;span class=&#34;math inline&#34;&gt;\(C_4^2\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;线段树维护一段连续&lt;strong&gt;欧拉序&lt;/strong&gt;内（不用 DFS 序是为了保证联通）的直径和两个端点，就能解决动态加点一类问题。&lt;/p&gt;
&lt;/details&gt;
&lt;h3 id=&#34;树上问题&#34;&gt;树上问题&lt;/h3&gt;
&lt;details&gt;
&lt;p&gt;&lt;summary&gt;&lt;strong&gt;树上路径问题的解决思路：&lt;/strong&gt;&lt;/summary&gt;&lt;/p&gt;
&lt;ol type=&#34;1&#34;&gt;
&lt;li&gt;&lt;p&gt;静态问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;不要求方向且能预处理：树上差分。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;要求方向且能预处理：倍增、树剖（多一个 log 但跑不满；综合来看慢一些）。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;离线、要求方向且不能预处理：&lt;/p&gt;
&lt;p&gt;把询问挂在 &lt;span class=&#34;math inline&#34;&gt;\(u\)&lt;/span&gt; 和 LCA 上，第一遍 DFS 把 &lt;span class=&#34;math inline&#34;&gt;\(u\to\)&lt;/span&gt; LCA 的答案计算出来（需要可合并信息），第二遍 DFS 利用回溯把 LCA &lt;span class=&#34;math inline&#34;&gt;\(\to v\)&lt;/span&gt; 的答案计算出来。&lt;/p&gt;
goto &lt;a href=&#34;/20250809/#a---记忆&#34;&gt;solu to &lt;em&gt;记忆&lt;/em&gt;&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;动态问题：树剖。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;dp&#34;&gt;DP&lt;/h2&gt;
&lt;details&gt;
&lt;p&gt;&lt;summary&gt;&lt;strong&gt;轮廓线 DP / 逐格状压 DP：&lt;/strong&gt;&lt;/summary&gt;&lt;/p&gt;
&lt;p&gt;对于棋盘上的状压 DP，如果某格内容的限制只来自相邻的格子（这是大部分棋盘问题能够满足的），可以考虑轮廓线 DP。&lt;/p&gt;
&lt;p&gt;具体来说，按照通常的从上到下、从左到右 DP 的思路，对于某一格，发现影响到它的只有左侧和上方的状态；这时我们通常会保存上一行所有状态，但发现左上侧格子及以前的状态是无用的，反而左边的状态是有用的。故记录每一列最靠下的已确定状态，就可以完成 DP。&lt;/p&gt;
&lt;p&gt;goto &lt;a href=&#34;/20250805/#d---count-grid-3-coloring&#34;&gt;solu to &lt;em&gt;Count Grid 3-coloring&lt;/em&gt;&lt;/a&gt;，&lt;a href=&#34;/20250805/#f---123-set&#34;&gt;solu to &lt;em&gt;123 Set&lt;/em&gt;&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;对于 &lt;span class=&#34;math inline&#34;&gt;\(2\times 1\)&lt;/span&gt; 骨牌放置问题，可以设『上半片』为 &lt;code&gt;1&lt;/code&gt;，其余为 &lt;code&gt;0&lt;/code&gt;，对于横向骨牌逐二格确定。这样就能发现，轮廓线 DP 并不一定只有在左侧有限制的时候才能用，因为&lt;strong&gt;记录左侧状态也是在完成状态的转移&lt;/strong&gt;。&lt;/p&gt;
&lt;/details&gt;
&lt;details&gt;
&lt;p&gt;&lt;summary&gt;&lt;strong&gt;『贡献』的思想：&lt;/strong&gt;&lt;/summary&gt;&lt;/p&gt;
&lt;p&gt;用乘法分配率将式子拆开，即『分类』，这时可能会发现『分步』这一步比原来更好做。&lt;/p&gt;
&lt;p&gt;更具象地，对于『分步』中的某一步，将『类别』的全集划分为若干个子集，发现除此之外的部分可能可以更方便地计算。如果能找到这样一种简单的均裂或异裂的方式，使得每一『类』的『单步』价值能够确定，就能考虑用『贡献』计算。&lt;/p&gt;
&lt;p&gt;特别地，对于一个子集，如果其他步骤对它的价值没有影响，其贡献往往会表现为幂次形式。&lt;/p&gt;
&lt;p&gt;Goto &lt;a href=&#34;/20250803/#b---one-to-one&#34;&gt;solu to &lt;em&gt;One to One&lt;/em&gt;&lt;/a&gt;，&lt;a href=&#34;/20250407/#e---kdoi-11彩灯晚会&#34;&gt;solu to &lt;em&gt;彩灯晚会&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/details&gt;
&lt;details&gt;
&lt;p&gt;&lt;summary&gt;&lt;strong&gt;想要筛选出特定一『类』的状态 / 不同『分类』对应不同『分步』时的处理方法：&lt;/strong&gt;&lt;/summary&gt;&lt;/p&gt;
&lt;p&gt;如果类别比较少，将类别放到维度里（例：如果存在二进制运算则可以拆位，则类别为 0/1 两类），分别处理。&lt;/p&gt;
&lt;p&gt;看起来很显然，但确实是很多状态设计的难点。&lt;/p&gt;
&lt;/details&gt;
&lt;details&gt;
&lt;p&gt;&lt;summary&gt;&lt;strong&gt;多重集的组合数&lt;/strong&gt;&lt;/summary&gt;&lt;/p&gt;
&lt;p&gt;主要要求能够认识到正在应用该模型。&lt;/p&gt;
&lt;p&gt;当 &lt;span class=&#34;math inline&#34;&gt;\(n,m\)&lt;/span&gt; 很小而 &lt;span class=&#34;math inline&#34;&gt;\(c_i\)&lt;/span&gt; 很大时：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;朴素地，设 &lt;span class=&#34;math inline&#34;&gt;\(f_{i,j}\)&lt;/span&gt; 表示在 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 处填了 &lt;span class=&#34;math inline&#34;&gt;\(\le j\)&lt;/span&gt; 的数（可以意识到需要前缀和），如果只关注当前位是不能做的，考虑枚举填了多少个 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt;，可以得到 &lt;span class=&#34;math inline&#34;&gt;\(f_{i,j}=\sum_k f_{i-k,j-1}\)&lt;/span&gt;。注意 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 可以取到 &lt;span class=&#34;math inline&#34;&gt;\(0\)&lt;/span&gt;，从数值上来看恰好是对的。&lt;/p&gt;
如果认为一个多重集中的元素是有差异的，还可以乘上 &lt;span class=&#34;math inline&#34;&gt;\(\binom {c_j}k\)&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;如果保证 &lt;span class=&#34;math inline&#34;&gt;\(n\le c_i\)&lt;/span&gt;，且题目没有其他限制时，发现原问题等价于 &lt;span class=&#34;math inline&#34;&gt;\(x_1+x_2+\cdots +x_m=n\)&lt;/span&gt; 的非负整数解数目，插板法解决。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在上一种方式的基础上，如果没有了 &lt;span class=&#34;math inline&#34;&gt;\(n\le c_i\)&lt;/span&gt; 的限制，易发现容斥也是可行的。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/details&gt;
&lt;details&gt;
&lt;p&gt;&lt;summary&gt;&lt;strong&gt;与字典序有关的状态设计：&lt;/strong&gt;&lt;/summary&gt;&lt;/p&gt;
&lt;p&gt;要求字典序大于 / 小于给定值的方案数，考虑使用 &lt;span class=&#34;math inline&#34;&gt;\(f_i\)&lt;/span&gt; 表示 &lt;span class=&#34;math inline&#34;&gt;\(1\sim i\)&lt;/span&gt; 全部和给定值相同，&lt;span class=&#34;math inline&#34;&gt;\(i+1\)&lt;/span&gt; 大于 / 小于给定值，后面无限制的情况总数。&lt;/p&gt;
&lt;p&gt;Goto &lt;a href=&#34;http://222.180.160.110:61235/contest/5423/problem/2&#34;&gt;冒泡排序&lt;/a&gt;。&lt;/p&gt;
&lt;/details&gt;
&lt;ul&gt;
&lt;li&gt;计数 DP 和容斥的选择。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;（容斥）碰到了「起点状态到终点状态，中间不能经过一些非法状态的方案数」，可以用 &lt;span class=&#34;math inline&#34;&gt;\(f_i\)&lt;/span&gt; 表示从起点，不经过 &lt;span class=&#34;math inline&#34;&gt;\(1\sim i-1\)&lt;/span&gt; 的非法状态，到达非法状态 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 的方案数，最后将终点状态也视为一个非法状态并 DP 即可。&lt;/p&gt;
Goto &lt;a href=&#34;/20231113/#a---gerald-and-giant-chess&#34;&gt;solu to &lt;em&gt;Gerald and Giant Chess&lt;/em&gt;&lt;/a&gt;，&lt;a href=&#34;https://www.cnblogs.com/XSC062/p/17330225.html&#34;&gt;solu to &lt;em&gt;两双手&lt;/em&gt;&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;求方案数，如果用通常的「考虑满足条件的情况并转移」，就必须能够简单地对条件进行判定。&lt;/p&gt;
&lt;p&gt;如果这一点做不到，可以考虑从最简单或最极限情况出发充要且不重地 &lt;strong&gt;构造&lt;/strong&gt; 出一般情况，并计算相应的方案数。&lt;/p&gt;
goto &lt;a href=&#34;/20230716/&#34;&gt;solu to &lt;em&gt;染色&lt;/em&gt;&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果有转移会有后效性不妨考虑是否有前效性然后逆序 DP。&lt;/p&gt;
&lt;p&gt;例如求字典序最小的答案：只知道最后一个字符不能推断出谁的字典序最小。但如果知道最开头一个字符，并保证从后往前填表的每一步都走的最小就能够确定。&lt;/p&gt;
goto &lt;a href=&#34;/20230716-1/&#34;&gt;solu to &lt;em&gt;匹配数&lt;/em&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;p id=&#34;1&#34;&gt;
状态拆分技巧。比如状态 ABC 不一定要从状态 A、状态 B、状态 C 分别 &lt;span class=&#34;math inline&#34;&gt;\(O(m)\)&lt;/span&gt; 的转移，而可以从 A 和 BC 以 &lt;span class=&#34;math inline&#34;&gt;\(O(1)\)&lt;/span&gt; 完成转移。
&lt;/p&gt;
&lt;p&gt;Goto &lt;a href=&#34;/20231003/#f.-单词&#34;&gt;solu to &lt;em&gt;单词&lt;/em&gt;&lt;/a&gt;。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;关于背包&#34;&gt;关于背包&lt;/h3&gt;
&lt;details&gt;
&lt;p&gt;&lt;summary&gt;&lt;strong&gt;子序列问题转化为背包问题：&lt;/strong&gt;&lt;/summary&gt;&lt;/p&gt;
&lt;p&gt;子序列问题（不仅是 + &amp;amp; min，也可以是 xor、加 &amp;amp; 模等）可以转化为背包问题；对一个区间做背包，可以把区间划分成若干段，每段做背包，再依次 &lt;span class=&#34;math inline&#34;&gt;\(O(v^2)\)&lt;/span&gt; 地合并。&lt;/p&gt;
&lt;p&gt;『划分』的一个典型场景是找『分割线』，然后向左向右分别做背包——这么做的优点是，对于任意穿这条分割线的区间，你都能 &lt;span class=&#34;math inline&#34;&gt;\(O(v^2)\)&lt;/span&gt; 得到所有的背包信息。甚至，如果你只需要求某个特定体积下的答案，只需要 &lt;span class=&#34;math inline&#34;&gt;\(O(v)\)&lt;/span&gt; 枚举。&lt;/p&gt;
&lt;p&gt;upd：可以猫树&lt;/p&gt;
&lt;p&gt;goto &lt;a href=&#34;https://loj.ac/p/6515&#34;&gt;贪玩蓝月&lt;/a&gt;。&lt;/p&gt;
&lt;/details&gt;
&lt;details&gt;
&lt;p&gt;&lt;summary&gt;&lt;strong&gt;离线背包结合分治：&lt;/strong&gt;&lt;/summary&gt;&lt;/p&gt;
&lt;p&gt;背包可以看作一种 +/min 卷积：在体积维上做加法、在代价维上做 min。当然其他操作如体积维上的 xor、加模；代价维上的方案数都差不多。&lt;/p&gt;
&lt;p&gt;因此，多次区间询问（离线）的背包可以结合分治——原因是从每个 &lt;span class=&#34;math inline&#34;&gt;\(l\)&lt;/span&gt; 开始做一次背包是不现实的，而我们发现分割线是可以共用的——分割线代表的背包信息也是可以共用的。&lt;/p&gt;
&lt;p&gt;所以需要找到一种『找分割线』和『一条分割线求解的范围』的方法，使得规定复杂度内能够最大化利用『公共信息』。分治的（类线段树的）结构就是一种极好的方式，在一层分治内解决所有在 &lt;span class=&#34;math inline&#34;&gt;\([l,r]\)&lt;/span&gt; 范围内，且跨越 &lt;span class=&#34;math inline&#34;&gt;\(mid\)&lt;/span&gt; 的询问，这样就能从 &lt;span class=&#34;math inline&#34;&gt;\(mid\)&lt;/span&gt; 出发，向左到 &lt;span class=&#34;math inline&#34;&gt;\(l\)&lt;/span&gt;，向右到 &lt;span class=&#34;math inline&#34;&gt;\(r\)&lt;/span&gt; 求解背包。&lt;/p&gt;
&lt;p&gt;goto &lt;a href=&#34;/20250520/#cf2043f-nim&#34;&gt;solu to CF2043F&lt;/a&gt;。&lt;/p&gt;
&lt;/details&gt;
&lt;details&gt;
&lt;p&gt;&lt;summary&gt;&lt;strong&gt;树上背包序列化：&lt;/strong&gt;&lt;/summary&gt;&lt;/p&gt;
&lt;p&gt;注意到对于任何类型的背包，树结构复杂度不优于序列结构。仅有物品体积为 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt; 的 01 背包可以用技巧优化到相同复杂度。&lt;/p&gt;
&lt;p&gt;利用 DFS 序进行填表，若不选某个点，相当于不选其引导的一整个子树 DFS 序区间。其余和序列背包一致。&lt;/p&gt;
&lt;p&gt;Goto &lt;a href=&#34;/20250612/#c---shopping&#34;&gt;solu to &lt;em&gt;Shopping&lt;/em&gt;&lt;/a&gt;。&lt;/p&gt;
&lt;/details&gt;
&lt;details&gt;
&lt;p&gt;&lt;summary&gt;&lt;strong&gt;随机序列的背包：&lt;/strong&gt;&lt;/summary&gt;&lt;/p&gt;
&lt;p&gt;有结论：一个长度为 &lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt; 的 &lt;span class=&#34;math inline&#34;&gt;\(1/-1\)&lt;/span&gt; 随机序列的前缀和离 &lt;span class=&#34;math inline&#34;&gt;\(0\)&lt;/span&gt; 的距离期望不超过 &lt;span class=&#34;math inline&#34;&gt;\(\sqrt n\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;拓展一下，在保证值域内分布均匀的整数域内背包，在 &lt;code&gt;random_shuffle&lt;/code&gt; 后实际最大状态不太会超过 &lt;span class=&#34;math inline&#34;&gt;\(\sqrt V\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;因为结论很松，所以运气比较好的时候甚至不会超过 &lt;span class=&#34;math inline&#34;&gt;\(\log V\)&lt;/span&gt;。&lt;/p&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;哈希&#34;&gt;哈希&lt;/h2&gt;
&lt;details&gt;
&lt;p&gt;&lt;summary&gt;&lt;strong&gt;哈希中全等条件的应用 / 哈希与前缀信息的关联：&lt;/strong&gt;&lt;/summary&gt;&lt;/p&gt;
&lt;p&gt;有的区间问题的判定条件可以转化为部分前缀信息的全等。&lt;/p&gt;
&lt;p&gt;例：要求区间内每个数出现次数为 &lt;span class=&#34;math inline&#34;&gt;\(3\)&lt;/span&gt; 的倍数，转化为：令 &lt;span class=&#34;math inline&#34;&gt;\(cnt_{i,j}\)&lt;/span&gt; 表示前 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 个数中 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; 出现次数 &lt;span class=&#34;math inline&#34;&gt;\(\bmod3\)&lt;/span&gt; 的值，则要求左右端点该值全等。&lt;/p&gt;
&lt;p&gt;Goto &lt;a href=&#34;https://www.luogu.com.cn/article/5reynyzi&#34;&gt;Three Occurrences&lt;/a&gt;。&lt;/p&gt;
&lt;/details&gt;
&lt;details&gt;
&lt;p&gt;&lt;summary&gt;&lt;strong&gt;xor hash：&lt;/strong&gt;&lt;/summary&gt;&lt;/p&gt;
&lt;p&gt;使用于异或判断次数奇偶性 / 元素存在性的哈希。&lt;/p&gt;
&lt;p&gt;区间里每个值出现次数都是偶数的必要条件是区间异或起来为 &lt;span class=&#34;math inline&#34;&gt;\(0\)&lt;/span&gt;。该结论不充分：&lt;span class=&#34;math inline&#34;&gt;\(1\oplus 2\oplus 3=0\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;把每个数都哈希成一个随机大数（比如 ull），冲突的概率就会变成 &lt;span class=&#34;math inline&#34;&gt;\(2^{-64}\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;Goto &lt;a href=&#34;https://www.luogu.com.cn/article/ugg047a7&#34;&gt;NOI2024 D1T1&lt;/a&gt;，&lt;a href=&#34;/20221010/&#34;&gt;solu to &lt;em&gt;博弈&lt;/em&gt;&lt;/a&gt;。&lt;/p&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;二分&#34;&gt;二分&lt;/h2&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;关于最值&#34;&gt;关于最值&lt;/h2&gt;
&lt;h3 id=&#34;关于冒泡排序&#34;&gt;关于冒泡排序&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;『冒泡排序有一种被出烂但是每次碰到我都不会的美感。』——wosile&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;这个人我不认识，但是我觉得这句话说得太好了！&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;一轮冒泡排序做的事情：将序列按前缀最大值为段首划分为若干段，并把其移到段末。&lt;/p&gt;
goto &lt;a href=&#34;/20250510/#c---1-loop-bubble-sort&#34;&gt;1 Loop Bubble Sort&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;前缀最大值在一轮冒泡排序后仍是前缀最大值。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;p&gt;&lt;summary&gt;求某下标在序列所有的 LIS 中出现次数：&lt;/summary&gt;&lt;/p&gt;
&lt;p&gt;分别统计以其结尾和开头的 LIS 长度与次数，如果加起来是序列 LIS 的长度，那么次数相乘就是答案。&lt;/p&gt;
&lt;/details&gt;
&lt;h2 id=&#34;杂项&#34;&gt;杂项&lt;/h2&gt;
&lt;details&gt;
&lt;p&gt;&lt;summary&gt;&lt;strong&gt;常用低复杂度库函数 / 比手写复杂度更低的库函数：&lt;/strong&gt;&lt;/summary&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;__builtin_clz&lt;/code&gt; / &lt;code&gt;__builtin_ctz&lt;/code&gt;：统计二进制开头 / 末尾 &lt;span class=&#34;math inline&#34;&gt;\(0\)&lt;/span&gt; 的个数，通常是硬件指令，硬件不支持则会采用掩码 &lt;span class=&#34;math inline&#34;&gt;\(O(1)\)&lt;/span&gt; 得到结果。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;__builtin_popcount&lt;/code&gt;：同上。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;sqrt&lt;/code&gt;：争议很大，但事实是对于所有数据最多迭代 &lt;span class=&#34;math inline&#34;&gt;\(6\)&lt;/span&gt; 次，实际表现接近单次浮点乘法操作，故为 &lt;span class=&#34;math inline&#34;&gt;\(O(1)\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;此处值得说明的是，&lt;code&gt;&amp;lt;cmath&amp;gt;&lt;/code&gt; 中的对数函数同样为常数复杂度，但被观测到实际表现时常数较大，跑 1e6 次就已经很危险了。&lt;/p&gt;
如果需要对 &lt;span class=&#34;math inline&#34;&gt;\(2\)&lt;/span&gt; 取对数，使用 &lt;code&gt;std::__lg&lt;/code&gt; 代替（其实现为 &lt;code&gt;31 - __builtin_clz(x)&lt;/code&gt;）。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;std::nth_element&lt;/code&gt;：可以 &lt;span class=&#34;math inline&#34;&gt;\(O(n)\)&lt;/span&gt; 找到第 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 大元素（放在第 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 位），并将原数组部分重排，使得前 &lt;span class=&#34;math inline&#34;&gt;\(k-1\)&lt;/span&gt; 为均比第 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 位小，后 &lt;span class=&#34;math inline&#34;&gt;\(n-k\)&lt;/span&gt; 位均比第 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 位大。&lt;/p&gt;
&lt;p&gt;所以实际功能其实是 &lt;span class=&#34;math inline&#34;&gt;\(O(n)\)&lt;/span&gt; 找到前 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 大元素。因为平常提到 rank 都喜欢用 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 来叙述，所以函数名经常被误记为 &lt;code&gt;kth&lt;/code&gt;。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/details&gt;
&lt;details&gt;
&lt;p&gt;&lt;summary&gt;&lt;strong&gt;随机序列跳悬线 / 悬线结合分块：&lt;/strong&gt;&lt;/summary&gt;&lt;/p&gt;
&lt;p&gt;随机序列的笛卡尔树深度为 &lt;span class=&#34;math inline&#34;&gt;\(\log\)&lt;/span&gt;；令块长为 &lt;span class=&#34;math inline&#34;&gt;\(B=\sqrt {\log n}\)&lt;/span&gt;，维护每个点跳 &lt;span class=&#34;math inline&#34;&gt;\(B\)&lt;/span&gt; 步的答案；那么就能 &lt;span class=&#34;math inline&#34;&gt;\(O(\sqrt {\log n})\)&lt;/span&gt; 跳悬线。&lt;/p&gt;
&lt;/details&gt;
&lt;details&gt;
&lt;p&gt;&lt;summary&gt;&lt;strong&gt;多组元素两两配对，要求同一组间不成对：&lt;/strong&gt;&lt;/summary&gt;&lt;/p&gt;
&lt;p&gt;设元素总数为 &lt;span class=&#34;math inline&#34;&gt;\(2n\)&lt;/span&gt;，则有解当且仅当最大的一组元素数不超过 &lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;若需要输出一种方案，可以看作有两个长为 &lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt;、上下并行放置的盒子，现欲用若干元素充满盒子，使得上下对应位置元素不同组。一种简单的构造方式是，把上下两个盒子拼在一起，按任意顺序把所有组连续放入，然后从拼接处断开，上下对应即为一对，容易发现上下元素一定不同组。&lt;/p&gt;
&lt;/details&gt;
&lt;details&gt;
&lt;p&gt;&lt;summary&gt;&lt;strong&gt;撤销思想：&lt;/strong&gt;&lt;/summary&gt;&lt;/p&gt;
&lt;p&gt;当题目给出『按一定的操作序列，将整块逐步分解为小段，问至晚哪一步后满足条件（需要单调性）』，可以考虑从最后的局面开始考虑，逐步『合并』，并 check 最早合并到哪一步时满足条件。&lt;/p&gt;
&lt;p&gt;Goto &lt;a href=&#34;/20220808/&#34;&gt;solu to &lt;em&gt;CF567D&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/details&gt;
&lt;details&gt;
&lt;p&gt;&lt;summary&gt;&lt;strong&gt;双栈模拟双端队列：&lt;/strong&gt;&lt;/summary&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;用两个栈模拟队列或双端队列。支持两头删除、插入。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一个维护前面的插入、删除；一个维护后面的插入、删除。插入是简单的；删除在大部分情况下是简单的；如果某个栈删空了，将另一个栈的一半挪过来暴力重构即可。均摊复杂度线性。&lt;/p&gt;
&lt;p&gt;复杂度证明：设两栈长度分别为 &lt;span class=&#34;math inline&#34;&gt;\(L_1,L_2\)&lt;/span&gt;，定义势能 &lt;span class=&#34;math inline&#34;&gt;\(E=|L_1-L_2|\)&lt;/span&gt;。每次插入 / 简单删除带来 &lt;span class=&#34;math inline&#34;&gt;\(\pm 1\)&lt;/span&gt; 的势能变化；一次重构消耗 &lt;span class=&#34;math inline&#34;&gt;\(E\)&lt;/span&gt; 的势能，将势能重置为 &lt;span class=&#34;math inline&#34;&gt;\(E\le 1\)&lt;/span&gt;。显然就有均摊线性复杂度了。&lt;/p&gt;
&lt;p&gt;适用场景：类队列 / 双端队列场景，但若固定一个端点就可以向左向右分别简单维护的；如背包等。&lt;/p&gt;
&lt;p&gt;goto &lt;a href=&#34;/20250520/#贪玩蓝月&#34;&gt;solu to &lt;em&gt;贪玩蓝月&lt;/em&gt;&lt;/a&gt;。&lt;/p&gt;
&lt;/details&gt;
&lt;details&gt;
&lt;p&gt;&lt;summary&gt;&lt;strong&gt;线段树维护括号序列：&lt;/strong&gt;&lt;/summary&gt;&lt;/p&gt;
&lt;p&gt;每个节点维护左边&lt;/p&gt;
&lt;/details&gt;
&lt;details&gt;
&lt;p&gt;&lt;summary&gt;&lt;strong&gt;贪心选取括号序列：&lt;/strong&gt;&lt;/summary&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定 &lt;span class=&#34;math inline&#34;&gt;\(a_1\sim a_{2N}\)&lt;/span&gt;，选取一个合法的长度为 &lt;span class=&#34;math inline&#34;&gt;\(2N\)&lt;/span&gt; 的括号序列，记权值为所有 &lt;span class=&#34;math inline&#34;&gt;\((\)&lt;/span&gt; 所在位置的 &lt;span class=&#34;math inline&#34;&gt;\(a\)&lt;/span&gt; 值之和，最大化权值。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(a_1\)&lt;/span&gt; 显然为 &lt;code&gt;(&lt;/code&gt;，&lt;span class=&#34;math inline&#34;&gt;\(a_{2N}\)&lt;/span&gt; 显然为 &lt;code&gt;)&lt;/code&gt;；&lt;/p&gt;
&lt;p&gt;对于 &lt;span class=&#34;math inline&#34;&gt;\(a_2\sim a_{2N-1}\)&lt;/span&gt;，从前往后扫，每次把两个连续元素放在一起考虑，进行如下操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;把这两个连续元素放到『可用来作 &lt;code&gt;(&lt;/code&gt;』的队列里。&lt;/li&gt;
&lt;li&gt;贪心地从队列里挑选 &lt;span class=&#34;math inline&#34;&gt;\(a\)&lt;/span&gt; 最大的元素，令其为 &lt;code&gt;(&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;正确性证明&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;即证：可构造出来的序列 &lt;span class=&#34;math inline&#34;&gt;\(\iff\)&lt;/span&gt; 合法的序列；构造出来的序列最优。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;必要性：&lt;/p&gt;
&lt;p&gt;我们知道，括号序列合法 &lt;span class=&#34;math inline&#34;&gt;\(\iff\)&lt;/span&gt; 对于任意 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt;，&lt;span class=&#34;math inline&#34;&gt;\(1\sim i\)&lt;/span&gt; 中的 &lt;code&gt;)&lt;/code&gt; 的数量不超过 &lt;code&gt;(&lt;/code&gt;。&lt;/p&gt;
对于任意 &lt;span class=&#34;math inline&#34;&gt;\(i=2k+1\)&lt;/span&gt;，前 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 个元素中存在至少 &lt;span class=&#34;math inline&#34;&gt;\(k+1\)&lt;/span&gt; 个 &lt;code&gt;(&lt;/code&gt;。&lt;strong&gt;且如果任意一步少选，序列不合法&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;充分性：&lt;/p&gt;
&lt;p&gt;也即在我们可以任意选择从队列中挑选哪个元素的情况下，证明任意目标序列都可以被这么构造。&lt;/p&gt;
每次选择目标序列最靠前的未被选的 &lt;code&gt;(&lt;/code&gt; 并将其选中。如果有一步不存在这样的位置怎么办？由『必要性』中粗体字得不合法。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;最优性：&lt;/p&gt;
&lt;p&gt;首先需要知道每个元素是否被选择是相对独立的。如果两个数都可被选，那么它们的选中状态是互不影响的（除非这是最后一个位置了，但显然这不是我们关注的重点）。&lt;/p&gt;
&lt;p&gt;假设一个 &lt;span class=&#34;math inline&#34;&gt;\(a_i\)&lt;/span&gt; 位于最优解序列，但我们没有选择它：说明选中了一个比 &lt;span class=&#34;math inline&#34;&gt;\(a_i\)&lt;/span&gt; 更大的元素，可以构造出更优的序列。由此反证。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;goto &lt;a href=&#34;/20250520/#abc407e-most-valuable-parentheses&#34;&gt;solu to &lt;em&gt;abc407E&lt;/em&gt;&lt;/a&gt;。&lt;/p&gt;
&lt;/details&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 个「二者至少选其一」形式的限制，要求选的尽可能少，使用 &lt;span class=&#34;math inline&#34;&gt;\(2^k\)&lt;/span&gt; 枚举后取并集代替 &lt;span class=&#34;math inline&#34;&gt;\(3^k\)&lt;/span&gt; 枚举。&lt;/li&gt;
&lt;/ul&gt;
</content>
        <category term="下饭" />
        <updated>2023-11-17T06:31:23.000Z</updated>
    </entry>
</feed>
