{
    "version": "https://jsonfeed.org/version/1",
    "title": "null • All posts by \"dp 优化\" tag",
    "description": "",
    "home_page_url": "https://xsc062.netlify.app",
    "items": [
        {
            "id": "https://xsc062.netlify.app/20251019/",
            "url": "https://xsc062.netlify.app/20251019/",
            "title": "杂题",
            "date_published": "2025-10-19T06:17:38.000Z",
            "content_html": "<p>模拟赛 and so on</p>\n<span id=\"more\"></span>\n<hr />\n<h2 id=\"cf1923f-shrink-reverse\">CF1923F Shrink-Reverse</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/CF1923F\" class=\"uri\">https://www.luogu.com.cn/problem/CF1923F</a></p>\n<p>需要想到贪心策略，但正确的策略并没有<strong>那么</strong>显然。</p>\n<ul>\n<li><p>观察样例可以大胆猜测，<code>SHRINK_REVERSE</code> 只会用最多一次。尝试理解这一点：</p>\n<ul>\n<li>只考虑 <code>SHRINK</code>，那么发现只有最后一次 <code>SHRINK</code> 是有效的。</li>\n<li>只考虑 <code>REVERSE</code>，那么只需要将两次 <code>REVERSE</code> 中间的 <code>SWAP</code> 进行翻转，并删除这两次 <code>REVERSE</code>，就可以达到相同的作用。</li>\n</ul>\n<p>综上，只需要保留最后一次 <code>SHRINK_REVERSE</code>，剩下的可以通过翻转对应的 <code>SWAP</code> 操作达到相同的效果，节省操作次数。且显然这次 <code>SHRINK_REVERSE</code> 应该放在操作序列的末尾。</p></li>\n<li><p>因此，只需要讨论不 <code>SHRINK_REVERSE</code>、在最后 <code>SHRINK_REVERSE</code> 两种情况。</p>\n<p>对于不 <code>SHRINK_REVERSE</code> 的情况，直接贪心即可。</p></li>\n<li><p>对于最后再 <code>SHRINK_REVERSE</code> 的情况，不妨先 <code>REVERSE</code>，考虑找到 <code>SHRINK</code> 后对应的原始字符串上的区间。</p>\n<p>也即考虑找到一个最短的子串，使得能够通过 <span class=\"math inline\">\\(k-1\\)</span> 次 <code>SWAP</code> 把子串外的 <span class=\"math inline\">\\(1\\)</span> 全部换到子串内。</p></li>\n<li><p>问题具有一定的单调性，故可以双指针对于每个 <span class=\"math inline\">\\(l\\)</span> 找到最小的 <span class=\"math inline\">\\(r\\)</span>。接下来仍然可以贪心最小化答案。</p>\n<p>很容易说明区间长最短的才能竞争最优：要么 <span class=\"math inline\">\\(l\\)</span> 初始为 <span class=\"math inline\">\\(1\\)</span>，要么区间长就是 <span class=\"math inline\">\\(1\\)</span> 总数；</p>\n<p>很容易说明相同长度的参与竞争的区间，字典序最小的最优。</p></li>\n<li><p>故接下来需要比较这 <span class=\"math inline\">\\(O(n)\\)</span> 个长度相同的答案区间的字典序。SA 即可。</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 1e9 + 7;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, k;\n    std::string s, res1, res2;\n    std::cin &gt;&gt; n &gt;&gt; k &gt;&gt; s, s = &#39;#&#39; + s;\n    res1 = s;\n    for (int i = 1, j = n, l = 1; l &lt;= k &amp;&amp; i &lt; j; ++i, --j, ++l) &#123;\n        for (; i &lt; j &amp;&amp; res1[i] != &#39;1&#39;; ++i);\n        for (; i &lt; j &amp;&amp; res1[j] != &#39;0&#39;; --j);\n        if (i &lt; j)\n            std::swap(res1[i], res1[j]);\n    &#125;\n    for (int i = 1; i &lt;= n; ++i)\n        if (res1[i] == &#39;1&#39;) &#123;\n            res1 = &#39;#&#39; + res1.substr(i, n - i + 1);\n            break;\n        &#125;\n    std::reverse(s.begin() + 1, s.end());\n    std::vector&lt;int&gt; pos;\n    const int s1 = std::count(s.begin() + 1, s.end(), &#39;1&#39;);\n    int len = n;\n    for (int l = 1, r = 0, c1 = 0, c0 = 0; l &lt;= n; ++l) &#123;\n        for (; r &lt; n &amp;&amp; (c0 &lt; s1 - c1 || s1 - c1 &gt; k - 1); )\n            if (s[++r] == &#39;1&#39;) ++c1;\n            else ++c0;\n        if (c0 &gt;= s1 - c1 &amp;&amp; s1 - c1 &lt;= k - 1) &#123;\n            if (r - l + 1 &lt; len)\n                len = r - l + 1, pos.clear();\n            if (r - l + 1 == len)\n                pos.push_back(l);\n        &#125;\n        if (s[l] == &#39;1&#39;) --c1;\n        else --c0;\n    &#125;\n    std::vector&lt;int&gt; sa(n + 1), rk(2 * n + 1);\n    &#123;\n        int m = 128;\n        std::vector&lt;int&gt; c(std::max(n, m) + 1), id, la(2 * n + 1);\n        std::copy(s.begin() + 1, s.end(), rk.begin() + 1);\n        for (int i = 1; i &lt;= n; ++i)\n            ++c[rk[i]];\n        std::partial_sum(c.begin() + 1, c.begin() + m + 1, c.begin() + 1);\n        for (int i = n; i; --i)\n            sa[c[rk[i]]--] = i;\n        for (int w = 1, p; ; w &lt;&lt;= 1, m = p) &#123;\n            id.clear(), id.push_back(-1);\n            for (int i = n - w + 1; i &lt;= n; ++i)\n                id.push_back(i);\n            for (int i = 1; i &lt;= n; ++i)\n                if (sa[i] &gt; w)\n                    id.push_back(sa[i] - w);\n            std::fill(c.begin() + 1, c.begin() + m + 1, 0);\n            for (int i = 1; i &lt;= n; ++i)\n                ++c[rk[i]];\n            std::partial_sum(c.begin() + 1, c.begin() + m + 1, c.begin() + 1);\n            for (int i = n; i; --i)\n                sa[c[rk[id[i]]]--] = id[i];\n            p = 0;\n            std::copy(rk.begin() + 1, rk.end(), la.begin() + 1);\n            for (int i = 1; i &lt;= n; ++i)\n                if (i != 1 &amp;&amp; la[sa[i]] == la[sa[i - 1]] &amp;&amp; la[sa[i] + w] == la[sa[i - 1] + w])\n                    rk[sa[i]] = p;\n                else\n                    rk[sa[i]] = ++p;\n            if (p == n)\n                break;\n        &#125;\n    &#125;\n    int id = 0;\n    for (auto i : pos)\n        if (id == 0 || rk[i] &lt; rk[id])\n            id = i;\n    if (id == 0)\n        assert(len == n), id = 1;\n    res2 = &#39;#&#39; + s.substr(id, len);\n    int tot = s1 - std::count(res2.begin() + 1, res2.end(), &#39;1&#39;);\n    for (int i = len; tot--; --i) &#123;\n        for (; res2[i] != &#39;0&#39;; --i);\n        res2[i] = &#39;1&#39;;\n    &#125;\n    if (res1.length() == res2.length())\n        s = std::min(res1, res2);\n    else if (res1.length() &lt; res2.length())\n        s = res1;\n    else\n        s = res2;\n    auto res = 0ll;\n    for (int i = 1; i &lt; (int)s.size(); ++i)\n        res = (res * 2 + s[i] - &#39;0&#39;) % mod;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"cf1859f-teleportation-in-byteland\">CF1859F Teleportation in Byteland</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/CF1859F\" class=\"uri\">https://www.luogu.com.cn/problem/CF1859F</a></p>\n<ul>\n<li><p>题设让树自然呈现一个分层图的结构。贪心地，最优的路径一定为 <span class=\"math inline\">\\(a_i\\to u\\)</span>，（在 <span class=\"math inline\">\\(u\\)</span> 学习若干次），<span class=\"math inline\">\\(u\\to b_i\\)</span>。</p>\n<p>枚举一个学习次数 <span class=\"math inline\">\\(k\\)</span>（显然 <span class=\"math inline\">\\(k\\)</span> 不会超过 <span class=\"math inline\">\\(\\left\\lceil\\log_2n\\right\\rceil\\)</span>），并令 <span class=\"math inline\">\\(d_k(u,v)\\)</span> 表示在学习 <span class=\"math inline\">\\(k\\)</span> 次后的分层图上 <span class=\"math inline\">\\(u\\)</span> 与 <span class=\"math inline\">\\(v\\)</span> 的距离。最后的答案可以表示为 <span class=\"math inline\">\\(\\min\\limits_{u,k}\\{d_0(a_i,u)+d_k(u,b_i)+k\\cdot T\\}\\)</span>。</p></li>\n<li><p>现在希望能够快速地找到，对于一个固定的 <span class=\"math inline\">\\(k\\)</span>，使答案最小的 <span class=\"math inline\">\\(u\\)</span>。询问与路径相关，所以期望一种能和路径挂钩的答案表示方法（似乎是经典 trick）。容易想到链 <span class=\"math inline\">\\((a_i,b_i)\\)</span> 上离 <span class=\"math inline\">\\(u\\)</span> 最近的点 <span class=\"math inline\">\\(v\\)</span>，答案可以改写成：</p>\n<p><span class=\"math display\">\\[\n\\min\\limits_{u,v}\\{d_0(a_i,v)+d_k(v,b_i)+d_0(v,u)+d_k(u,v)\\}+k\\cdot T\n\\]</span></p>\n<p>其中，<span class=\"math inline\">\\(d_0(v,u)+d_k(u,v)\\)</span> 与具体的 <span class=\"math inline\">\\(a,b\\)</span> 无关，可以用一次多源 Dij 预处理出每个 <span class=\"math inline\">\\(v\\)</span> 的答案（记为 <span class=\"math inline\">\\(s_k(v)\\)</span>）（需要注意到 <span class=\"math inline\">\\(d_0(v,u)\\)</span> 和 <span class=\"math inline\">\\(d_k(u,v)\\)</span> 可能不同时取最小，可以用 <span class=\"math inline\">\\(w_0+w_k\\)</span> 作边权）；<span class=\"math inline\">\\(d_0(a_i,v)+d_k(v,b_i)\\)</span> 则可以通过讨论 LCA 直接用深度表示，求出最值。</p></li>\n<li><p>记 <span class=\"math inline\">\\(fa=\\text{LCA}(a_i,b_i)\\)</span>，当 <span class=\"math inline\">\\(v\\)</span> 在 <span class=\"math inline\">\\(fa\\to a_i\\)</span> 上时，答案为：</p>\n<p><span class=\"math display\">\\[\n(dep_k(v)+s_k(v)-dep_0(v))+(dep_k(b_i)-2dep_k(fa)+dep_0(a_i)+k\\cdot T)\n\\]</span></p>\n<p>当 <span class=\"math inline\">\\(v\\)</span> 在 <span class=\"math inline\">\\(fa\\to b_i\\)</span> 上时，答案为：</p>\n<p><span class=\"math display\">\\[\n(dep_0(v)+s_k(v)-dep_k(v))+(dep_0(a_i)-2dep_0(fa)+dep_k(b_i)+k\\cdot T)\n\\]</span></p>\n<p>维护链上 <span class=\"math inline\">\\(dep_k(v)+s_k(v)-dep_0(v)\\)</span> 和 <span class=\"math inline\">\\(dep_0(v)+s_k(v)-dep_k(v)\\)</span> 的最小值即可。</p></li>\n<li>由于是完全静态的树上路径问题，可以用倍增完成。注意考虑学 <span class=\"math inline\">\\(0\\)</span> 次的情况。复杂度 <span class=\"math inline\">\\(O(n\\log^2 n)\\)</span>。</li>\n<li><p>咦你怎么 MLE 了？只需要把所有询问离线下来，每个 <span class=\"math inline\">\\(k\\)</span> 就可以共用数组了。</p>\n<p>看到 Limury 的做法是树剖 + st 表，薄纱所有人。Rosmist 树剖 + bit 三只 log 也薄纱倍增做法，我怎么会做这样的梦。</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 1e5 + 5;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int T;\n    for (std::cin &gt;&gt; T; T--; ) &#123;\n        int n, t;\n        std::cin &gt;&gt; n &gt;&gt; t;\n        std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; g(n + 1);\n        for (int i = 1, x, y, w; i &lt; n; ++i) &#123;\n            std::cin &gt;&gt; x &gt;&gt; y &gt;&gt; w;\n            g[x].emplace_back(y, w), g[y].emplace_back(x, w);\n        &#125;\n        std::vector&lt;int&gt; tag(n + 1);\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            char t;\n            std::cin &gt;&gt; t, tag[i] = t - &#39;0&#39;;\n        &#125;\n        auto fun = [&amp;](int w, int k) &#123;\n            return (w + (1 &lt;&lt; k) - 1) &gt;&gt; k;\n        &#125;;\n        std::vector&lt;long long&gt; s(n + 1);\n        std::vector&lt;int&gt; dep(n + 1), vis(n + 1);\n        std::vector&lt;std::array&lt;int, 17&gt; &gt; fa(n + 1);\n        std::vector&lt;std::array&lt;long long, 17&gt; &gt; f1(n + 1), f2(n + 1);\n        std::vector&lt;std::vector&lt;long long&gt; &gt; dis(2, std::vector&lt;long long&gt; (n + 1));\n        std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;\n            for (auto [i, w] : g[x])\n                if (i != fa[x][0]) &#123;\n                    dep[i] = dep[x] + 1;\n                    dis[0][i] = dis[0][x] + w;\n                    fa[i][0] = x;\n                    for (int j = 1; j &lt; 17; ++j)\n                        fa[i][j] = fa[fa[i][j - 1]][j - 1];\n                    DFS(i);\n                &#125;\n            return;\n        &#125;;\n        dep[1] = 1, DFS(1);\n        auto getLCA = [&amp;](int x, int y) &#123;\n            if (dep[x] &lt; dep[y])\n                std::swap(x, y);\n            for (int i = 16; ~i; --i)\n                if (dep[fa[x][i]] &gt;= dep[y])\n                    x = fa[x][i];\n            if (x == y)\n                return x;\n            for (int i = 16; ~i; --i)\n                if (fa[x][i] != fa[y][i])\n                    x = fa[x][i], y = fa[y][i];\n            return fa[x][0];\n        &#125;;\n        int m;\n        std::cin &gt;&gt; m;\n        std::vector&lt;long long&gt; res(m + 1);\n        std::vector&lt;std::pair&lt;int, int&gt; &gt; q(m + 1);\n        for (int i = 1, u, v; i &lt;= m; ++i) &#123;\n            std::cin &gt;&gt; u &gt;&gt; v;\n            res[i] = dis[0][u] + dis[0][v] - 2 * dis[0][getLCA(u, v)];;\n            q[i] = &#123; u, v &#125;;\n        &#125;\n        for (int j = 0; j &lt; 17; ++j)\n            f1[0][j] = f2[0][j] = 1e18;\n        for (int k = 1; k &lt;= 20; ++k) &#123;\n            &#123;\n                std::priority_queue&lt;std::pair&lt;long long, int&gt; &gt; q;\n                for (int i = 1; i &lt;= n; ++i) &#123;\n                    vis[i] = 0;\n                    if (tag[i])\n                        s[i] = 0ll, q.emplace(0ll, i);\n                    else\n                        s[i] = 1e18;\n                &#125;\n                for (; !q.empty(); ) &#123;\n                    int x = q.top().second;\n                    q.pop();\n                    if (vis[x])\n                        continue;\n                    vis[x] = 1;\n                    for (auto [v, w] : g[x])\n                        if (s[v] &gt; s[x] + fun(w, k) + w) &#123;\n                            s[v] = s[x] + fun(w, k) + w;\n                            q.emplace(-s[v], v);\n                        &#125;\n                &#125;\n            &#125;\n            DFS = [&amp;](int x) &#123;\n                for (auto [i, w] : g[x])\n                    if (i != fa[x][0]) &#123;\n                        dis[1][i] = dis[1][x] + fun(w, k);\n                        f1[i][0] = dis[1][i] + s[i] - dis[0][i];\n                        f2[i][0] = dis[0][i] + s[i] - dis[1][i];\n                        for (int j = 1; j &lt; 17; ++j) &#123;\n                            f1[i][j] = std::min(f1[i][j - 1], f1[fa[i][j - 1]][j - 1]);\n                            f2[i][j] = std::min(f2[i][j - 1], f2[fa[i][j - 1]][j - 1]);\n                        &#125;\n                        DFS(i);\n                    &#125;\n                return;\n            &#125;;\n            DFS(1);\n            for (int i = 1; i &lt;= m; ++i) &#123;\n                auto [u, v] = q[i];\n                int x = u, y = v;\n                long long s1 = 1e18, s2 = 1e18;\n                if (dep[x] &gt; dep[y]) &#123;\n                    for (int i = 16; ~i; --i)\n                        if (dep[fa[x][i]] &gt;= dep[y]) &#123;\n                            s1 = std::min(s1, f1[x][i]);\n                            x = fa[x][i];\n                        &#125;\n                &#125;\n                else &#123;\n                    for (int i = 16; ~i; --i)\n                        if (dep[fa[y][i]] &gt;= dep[x]) &#123;\n                            s2 = std::min(s2, f2[y][i]);\n                            y = fa[y][i];\n                        &#125;\n                &#125;\n                if (x != y) &#123;\n                    for (int i = 16; ~i; --i)\n                        if (fa[x][i] != fa[y][i]) &#123;\n                            s1 = std::min(s1, f1[x][i]);\n                            s2 = std::min(s2, f2[y][i]);\n                            x = fa[x][i], y = fa[y][i];\n                        &#125;\n                    s1 = std::min(s1, f1[x][0]);\n                    s2 = std::min(s2, f2[y][0]);\n                    x = fa[x][0];\n                &#125;\n                s1 = std::min(s1, dis[1][x] + s[x] - dis[0][x]);\n                s2 = std::min(s2, dis[0][x] + s[x] - dis[1][x]);\n                res[i] = std::min(res[i], k * t + dis[0][u] + dis[1][v] + std::min(s1 - 2 * dis[1][x], s2 - 2 * dis[0][x]));\n            &#125;\n        &#125;\n        for (int i = 1; i &lt;= m; ++i)\n            std::cout &lt;&lt; res[i] &lt;&lt; &#39;\\n&#39;;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"cf1556g-gates-to-another-world\">CF1556G Gates to Another World</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/CF1556G\" class=\"uri\">https://www.luogu.com.cn/problem/CF1556G</a></p>\n<ul>\n<li><p>快速做出来需要一定运气，需要把点顺序排布而不是像题目一样画晶胞（。）手玩一下 <span class=\"math inline\">\\(n=4\\)</span> 时的情况：</p>\n<p><img src=\"image.png\" /></p>\n<p>看到两个相邻点间连的边就应激想到线段树了，事实上把不同层的边提起来发现就是线段树的结构。</p>\n<details>\n<p><summary>为什么这个图这么大（没啥用故折起来了）</summary></p>\n<p>tip：实际上那些相邻 / 相反的尖尖是重合的，为了好看一点故错开。</p>\n<p><img src=\"image-1.png\" /></p>\n</details>\n<p>发现形成一个<strong>相邻子树对位连边</strong>的结构。这里线段树其实只有底层点是有意义的，其他点只起结构辅助作用。</p>\n<p>实际上，对于两个有连边的点，它们『LCA』的高度是被 flip 的位。</p></li>\n<li><p>很容易注意到一个线段树子树内的底层点是连通的，这一点也很容易递归地证明。</p>\n<p>考虑动态开点线段树优化建图，对于动态开点出来的叶子（注意不是底层点），容易发现在题目限制下每个叶子内部都没有点被删除，是连通的（那么此时不妨认为叶子就代表了这个连通块）。</p>\n<p>故将某个点进行连边时，并不要求找到对位的那个点（不一定存在），和走到头的叶子连边就可以达到相同的连通效果。这样就把底层点之间的连边转化为了<strong>叶子间</strong>的连边。</p></li>\n<li><p>不妨先时光倒流 + 预处理出每个叶子最后（最早）存在的时间戳，考虑暴力连出来这些叶子间的边（对于每个点，将对位的叶子连边）并计算出边最后（最早）存在的时间戳。</p>\n<p>发现暴力对位连边这个操作，是形似线段树合并但比线段树合并更劣的东西。咋分析复杂度。</p>\n<p>边是双向的，考虑更深的叶子的贡献。那么其枚举 lca + flip 对应位（不存在则取路径上的叶子），一共会有 <span class=\"math inline\">\\(O(n)\\)</span> 次连边。共有 <span class=\"math inline\">\\(O(nm)\\)</span> 个叶子，摊下来暴力连边复杂度为 <span class=\"math inline\">\\(O(n^2m)\\)</span>。</p></li>\n</ul>\n<details>\n<p>空间很卡…… 不要把离线的加边数组开成 <code>long long</code> 了。</p>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 32e5 + 5;\nusing ll = long long;\nstruct &#123; int l, r, d; &#125; t[maxn];\nint tot;\n#define lt t[p].l\n#define rt t[p].r\n#define leaf(p) (!t[p].l &amp;&amp; !t[p].r)\nint newnode(void) &#123;\n    ++tot, t[tot].l = t[tot].r = t[tot].d = 0;\n    return tot;\n&#125;\nvoid pushdown(int p) &#123;\n    if (t[p].d) &#123;\n        if (!lt)\n            lt = newnode();\n        if (!rt)\n            rt = newnode();\n        t[lt].d = t[rt].d = t[p].d;\n        t[p].d = 0;\n    &#125;\n    return;\n&#125;\nvoid upd(int &amp;p, ll l, ll r, ll ql, ll qr, int v) &#123;\n    if (!p)\n        p = newnode();\n    if (ql &lt;= l &amp;&amp; r &lt;= qr) &#123;\n        t[p].d = v;\n        return;\n    &#125;\n    pushdown(p);\n    auto mid = (l + r) &gt;&gt; 1;\n    if (ql &lt;= mid)\n        upd(lt, l, mid, ql, qr, v);\n    if (qr &gt; mid)\n        upd(rt, mid + 1, r, ql, qr, v);\n    return;\n&#125;\nint ask(int p, ll l, ll r, ll x) &#123;\n    if (leaf(p))\n        return p;\n    ll mid = (l + r) &gt;&gt; 1;\n    if (x &lt;= mid)\n        return ask(lt, l, mid, x);\n    return ask(rt, mid + 1, r, x);\n&#125;\n#undef lt\n#undef rt\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, m, rt = newnode();\n    std::cin &gt;&gt; n &gt;&gt; m;\n    t[rt].d = m + 1;\n    const auto N = (1ll &lt;&lt; n) - 1;\n    struct query &#123; int op; ll s, t; &#125;;\n    std::vector&lt;query&gt; q(m + 1);\n    for (int i = 1; i &lt;= m; ++i) &#123;\n        std::string op;\n        std::cin &gt;&gt; op;\n        q[i].op = (op == &quot;ask&quot;) + 1;\n        std::cin &gt;&gt; q[i].s &gt;&gt; q[i].t;\n        if (q[i].op == 1)\n            upd(rt, 0ll, N, q[i].s, q[i].t, i);\n    &#125;\n    std::vector&lt;int&gt; f(tot + 1);\n    std::iota(f.begin() + 1, f.end(), 1);\n    std::function&lt;int(int)&gt; find = [&amp;](int x) &#123;\n        return x == f[x] ? x : f[x] = find(f[x]);\n    &#125;;\n    auto merge = [&amp;](int x, int y) &#123;\n        f[find(x)] = find(y);\n        return;\n    &#125;;\n    std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; u(m + 2);\n    std::function&lt;void(int, int)&gt; link = [&amp;](int p, int q) &#123;\n        if (leaf(p) &amp;&amp; leaf(q)) &#123;\n            u[std::min(t[p].d, t[q].d)].emplace_back(p, q);\n            return;\n        &#125;\n        else if (leaf(p))\n            link(p, t[q].l), link(p, t[q].r);\n        else if (leaf(q))\n            link(t[p].l, q), link(t[p].r, q);\n        else\n            link(t[p].l, t[q].l), link(t[p].r, t[q].r);\n        return;\n    &#125;;\n    for (int i = 1; i &lt;= tot; ++i)\n        if (t[i].l &amp;&amp; t[i].r)\n            link(t[i].l, t[i].r);\n    for (auto [p, q] : u[m + 1])\n        merge(p, q);\n    std::vector&lt;int&gt; res;\n    for (int i = m; i; --i)\n        if (q[i].op == 2)\n            res.push_back(find(ask(rt, 0, N, q[i].s)) == find(ask(rt, 0, N, q[i].t)));\n        else\n            for (auto [p, q] : u[i])\n                merge(p, q);\n    for (; !res.empty(); res.pop_back())\n        std::cout &lt;&lt; res.back() &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"c.-小-z-爱优化\">C. 小 Z 爱优化</h2>\n<p><a href=\"https://www.becoder.com.cn/contest/6662/problem/3\" class=\"uri\">https://www.becoder.com.cn/contest/6662/problem/3</a></p>\n<blockquote>\n<p>给定 <span class=\"math inline\">\\(a_{1\\sim n}\\)</span>，将其分为若干连续段，满足每段长度为 <span class=\"math inline\">\\(1\\)</span> 或 <span class=\"math inline\">\\(2\\)</span>，定义一段的权值为元素之和，最小化段权值的极差并输出之。</p>\n<p><span class=\"math inline\">\\(n\\le 2\\times 10^5,V=10^9\\)</span>。</p>\n</blockquote>\n<ul>\n<li><p>令 <span class=\"math inline\">\\(f_{i,j}\\)</span> 表示这一段以 <span class=\"math inline\">\\(i\\)</span> 结尾，最小值为 <span class=\"math inline\">\\(j\\)</span> 时的最大值。把最小值当状态是自然的想法，实际似乎差不多（。）得到（<strong>不重要</strong>）：</p>\n<p><span class=\"math display\">\\[\nf_{i,a_i}\\gets f_{i-1,j},j\\ge a_i\\\\\nf_{i,a_i+a_{i-1}}\\gets f_{i-2,j},j\\ge a_i+a_{i-1}\\\\\nf_{i,j}\\gets \\max(f_{i-1,j},a_i) ,j\\le a_i\\\\\nf_{i,j}\\gets \\max(f_{i-2,j},a_i+a_{i-1}) ,j\\le a_i\n\\]</span></p></li>\n<li><p>这个状态很矩阵，可以考虑下标分奇偶性继承，用线段树优化，矩阵作为元素；然而同时涉及两个维度，尤其是第一维的变化，实在是答辩啊！</p>\n<details>\n<p><summary>By the way，广义矩乘的结合律？</summary></p>\n<p>对于一个 <span class=\"math inline\">\\(\\oplus-\\otimes\\)</span> 矩阵（内层为 <span class=\"math inline\">\\(\\otimes\\)</span>，外层为 <span class=\"math inline\">\\(\\oplus\\)</span>），其有结合律当且仅当同时满足：</p>\n<ol type=\"1\">\n<li><span class=\"math inline\">\\(\\oplus\\)</span> 有交换律；</li>\n<li><span class=\"math inline\">\\(\\otimes\\)</span> 有结合律；</li>\n<li><span class=\"math inline\">\\(\\otimes\\)</span> 对 <span class=\"math inline\">\\(\\oplus\\)</span> 有分配律。</li>\n</ol>\n<figure>\n<img src=\"image-2.png\" alt=\"来自 qkhm 关于广义矩阵乘法常见误区的一点纠正\" /><figcaption>来自 qkhm <a href=\"https://www.cnblogs.com/qkhm/p/19055513/ddp\">关于广义矩阵乘法常见误区的一点纠正</a></figcaption>\n</figure>\n</details>\n<p>发现第二维其实不会怎么变，或者说第二维其实起的是一个<strong>限制</strong>性的作用，可以考虑把第二维放到外层循环，相当于枚举<strong>限制</strong>。我们知道上面的做法可以很快地优化，所以拿出去了之后大概也能做。</p></li>\n<li><p>若限制当前最小值不能小于 <span class=\"math inline\">\\(j\\)</span>，那么有：</p>\n<p><span class=\"math display\">\\[\nf_i\\gets \\max(f_{i-1},a_i),a_j\\ge j\\\\\nf_i\\gets \\max(f_{i-2},a_i+a_{i-1}),a_i+a_{i-1}\\ge j\n\\]</span></p>\n<p>发现这就很显然是一个 DDP 的形式了，每次 <span class=\"math inline\">\\(j\\)</span> 改变时，只需要改动对应位置的矩阵（即是否能进行转移），总修改次数是 <span class=\"math inline\">\\(O(n)\\)</span> 的。</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 2e5 + 5;\nconst int inf = 0x7fffffff;\nusing mat = std::array&lt;std::array&lt;int, 2&gt;, 2&gt;;\nint m[maxn][2][2];\nvoid mul(mat &amp;res, mat &amp;p, mat &amp;q) &#123;\n    res[0][0] = std::min(std::max(p[0][0], q[0][0]), std::max(p[0][1], q[1][0]));\n    res[0][1] = std::min(std::max(p[0][0], q[0][1]), std::max(p[0][1], q[1][1]));\n    res[1][0] = std::min(std::max(p[1][0], q[0][0]), std::max(p[1][1], q[1][0]));\n    res[1][1] = std::min(std::max(p[1][0], q[0][1]), std::max(p[1][1], q[1][1]));\n    return;\n&#125;\nstruct &#123;\n    int l, r;\n    mat u;\n&#125; t[maxn &lt;&lt; 2];\n#define lt (p &lt;&lt; 1)\n#define rt (lt | 1)\nvoid bld(int p, int l, int r) &#123;\n    t[p].l = l, t[p].r = r;\n    if (l == r) &#123;\n        t[p].u[0][0] = m[l][0][0];\n        t[p].u[0][1] = m[l][0][1];\n        t[p].u[1][0] = m[l][1][0];\n        t[p].u[1][1] = m[l][1][1];\n        return;\n    &#125;\n    int mid = (l + r) &gt;&gt; 1;\n    bld(lt, l, mid), bld(rt, mid + 1, r);\n    mul(t[p].u, t[lt].u, t[rt].u);\n    return;\n&#125;\nvoid upd(int p, int x) &#123;\n    if (t[p].l == t[p].r) &#123;\n        t[p].u[0][1] = m[x][0][1];\n        t[p].u[1][1] = m[x][1][1];\n        return;\n    &#125;\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (x &lt;= mid)\n        upd(lt, x);\n    else\n        upd(rt, x);\n    mul(t[p].u, t[lt].u, t[rt].u);\n    return;\n&#125;\n#undef lt\n#undef rt\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n    std::freopen(&quot;opti.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;opti.out&quot;, &quot;w&quot;, stdout);\n#else\n    std::freopen(&quot;./test/20251021/opti/1.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    auto stime = std::chrono::steady_clock::now();\n#endif\n    int T;\n    for (std::cin &gt;&gt; T; T--; ) &#123;\n        int n;\n        std::cin &gt;&gt; n;\n        std::vector&lt;int&gt; a(n + 1), b(n + 1), l(1);\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            std::cin &gt;&gt; a[i];\n            l.push_back(a[i]);\n            if (i &gt; 1)\n                b[i] = a[i] + a[i - 1], l.push_back(b[i]);\n        &#125;\n        std::sort(l.begin() + 1, l.end());\n        l.erase(std::unique(l.begin() + 1, l.end()), l.end());\n        int m = (int)l.size() - 1;\n        std::vector&lt;std::vector&lt;int&gt; &gt; ida(m + 1), idb(m + 1);\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            a[i] = std::lower_bound(l.begin() + 1, l.end(), a[i]) - l.begin();\n            ::m[i][1][1] = a[i], ida[a[i]].push_back(i);\n            if (i &gt; 1) &#123;\n                b[i] = std::lower_bound(l.begin() + 1, l.end(), b[i]) - l.begin();\n                ::m[i][0][1] = b[i], idb[b[i]].push_back(i);\n            &#125;\n            else\n                ::m[i][0][1] = inf;\n            ::m[i][0][0] = inf, ::m[i][1][0] = 0;\n        &#125;\n        bld(1, 1, n);\n        auto res = inf;\n        for (int i = 1; i &lt;= m; ++i) &#123;\n            if (std::min(t[1].u[0][1], t[1].u[1][1]) != inf)\n                res = std::min(res, l[std::min(t[1].u[0][1], t[1].u[1][1])] - l[i]);\n            for (auto j : ida[i])\n                ::m[j][1][1] = inf, upd(1, j);\n            for (auto j : idb[i])\n                ::m[j][0][1] = inf, upd(1, j);\n        &#125;\n        std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt;(std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s \\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"d.-小-z-爱考试\">D. 小 Z 爱考试</h2>\n<p><a href=\"https://www.becoder.com.cn/contest/6662/problem/4\" class=\"uri\">https://www.becoder.com.cn/contest/6662/problem/4</a></p>\n<blockquote>\n<p>给定一个大小为 <span class=\"math inline\">\\(n\\)</span> 的内向基环树森林，每个点 <span class=\"math inline\">\\(u\\)</span> 上附有点权 <span class=\"math inline\">\\(a_u\\)</span>、收益 <span class=\"math inline\">\\(w_u\\)</span> 和一个进程，内容为：</p>\n<ul>\n<li>若 <span class=\"math inline\">\\(u\\)</span> 指向的结点 <span class=\"math inline\">\\(fa\\)</span> 满足 <span class=\"math inline\">\\(a_{fa}&gt;a_u\\)</span>，则令 <span class=\"math inline\">\\(a_u\\gets a_u+w_u\\)</span>。</li>\n</ul>\n<p>给定 <span class=\"math inline\">\\(m\\)</span> 次操作，形如：</p>\n<ul>\n<li>单点修改 <span class=\"math inline\">\\(a_u,w_u\\)</span>。</li>\n<li>给定一个 <span class=\"math inline\">\\(u\\)</span>，输出：在 <span class=\"math inline\">\\(n!\\)</span> 种进程的执行序列中，<span class=\"math inline\">\\(a_u\\)</span> 最终值的期望。</li>\n</ul>\n<p><span class=\"math inline\">\\(n,m\\le 2\\times 10^5\\)</span>。<strong>保证每个点的入度 <span class=\"math inline\">\\(\\le 3\\)</span></strong>。</p>\n</blockquote>\n<ul>\n<li><p>可以感受到操作的『后效性』是非常弱的，进一步感受到点可以粗暴地分为三种类型：</p>\n<ol type=\"1\">\n<li><span class=\"math inline\">\\(a_{fa}&gt;a_x\\)</span> 的；</li>\n<li><span class=\"math inline\">\\(a_{fa}+w_{fa} \\le a_x\\)</span> 的；</li>\n<li><span class=\"math inline\">\\(a_{fa}\\le a_x&lt;a_{fa} + w_{fa}\\)</span> 的；</li>\n</ol>\n<p>点的类型是无依赖，可直接求的。显然，若 <span class=\"math inline\">\\(u\\)</span> 最终想取到 <span class=\"math inline\">\\(a_u+w_u\\)</span>，相当于走一条 <span class=\"math inline\">\\(u\\)</span> 开头，经过若干 3 类点，在 1 类点结尾的路径（这显然是确定的），假设路径包含 <span class=\"math inline\">\\(len\\)</span> 个点，答案为 <span class=\"math inline\">\\(\\dfrac {(n-len)!\\cdot C_{n}^{len}}{n!}=\\dfrac 1{len!}\\)</span>。</p>\n<p>换句话说，<span class=\"math inline\">\\(u\\)</span> 取不到 <span class=\"math inline\">\\(a_u+w_u\\)</span>，当且仅当路径上在出现 1 类点前出现了 2 类点或 3 类点的环（基环）。</p></li>\n<li><p>考虑静态的情况，先处理所有基环：若只存在 3 类点，则标记全部非法；否则，任选一个 1 类点或者 2 类点开头，就可以 DP 出环上的 <span class=\"math inline\">\\(len\\)</span>。</p>\n<p>对于所有树，直接大力 DP 即可。</p></li>\n<li><p>接着考虑带修的情况，修改相当于改变点及其后继的状态（原来入度限制是拿来做这个的）。</p>\n<p>发现没啥办法很好地做这个类 DDP 的问题。考虑到一场比赛不应该出现两道 DDP，故如果灵感迸发可能会想到干脆放弃预处理的想法，上重链，线段树维护区间 1 类点或 2 类点深度 max，即可做到两只 log。</p>\n<p>如果发现树上没有这样的点，在环上也可以类似地找到第一个 1 类点或 2 类点。</p></li>\n</ul>\n<details>\n<p>感觉写复杂了，瞻仰了一下别人的代码又感觉流程上没什么区别</p>\n<p>喜提最长代码，喜提最优解</p>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 1e9 + 7;\nconst int maxn = 6e5 + 5;\nstruct &#123;\n    int l, r, lc, rc, u1, u2;\n&#125; t[maxn &lt;&lt; 2];\n#define lt t[p].lc\n#define rt t[p].rc\nint tot;\nint ty[maxn], dep[maxn];\nvoid bld(int &amp;p, int l, int r) &#123;\n    p = ++tot;\n    t[p].l = l, t[p].r = r;\n    if (l == r) &#123;\n        t[p].u1 = t[p].u2 = 0;\n        if (ty[l] == 1)\n            t[p].u1 = dep[l];\n        else if (ty[l] == 2)\n            t[p].u2 = dep[l];\n        return;\n    &#125;\n    int mid = (l + r) &gt;&gt; 1;\n    bld(lt, l, mid), bld(rt, mid + 1, r);\n    t[p].u1 = std::max(t[lt].u1, t[rt].u1);\n    t[p].u2 = std::max(t[lt].u2, t[rt].u2);\n    return;\n&#125;\nvoid upd(int p, int x) &#123;\n    if (t[p].l == t[p].r) &#123;\n        t[p].u1 = t[p].u2 = 0;\n        if (ty[x] == 1)\n            t[p].u1 = dep[x];\n        else if (ty[x] == 2)\n            t[p].u2 = dep[x];\n        return;\n    &#125;\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (x &lt;= mid)\n        upd(lt, x);\n    else\n        upd(rt, x);\n    t[p].u1 = std::max(t[lt].u1, t[rt].u1);\n    t[p].u2 = std::max(t[lt].u2, t[rt].u2);\n    return;\n&#125;\nstd::pair&lt;int, int&gt; ask(int p, int l, int r) &#123;\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r)\n        return std::make_pair(t[p].u1, t[p].u2);\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    std::pair&lt;int, int&gt; res(0, 0);\n    if (l &lt;= mid)\n        res = ask(lt, l, r);\n    if (r &gt; mid) &#123;\n        auto s(ask(rt, l, r));\n        res.first = std::max(res.first, s.first);\n        res.second = std::max(res.second, s.second);\n    &#125;\n    return res;\n&#125;\n#undef lt\n#undef rt\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n    std::freopen(&quot;exam.out&quot;, &quot;w&quot;, stdout);\n    std::freopen(&quot;exam.in&quot;, &quot;r&quot;, stdin);\n#else\n    std::freopen(&quot;./test/20251021/exam/3.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int T;\n    for (std::cin &gt;&gt; T; T--; ) &#123;\n        int n, m;\n        std::cin &gt;&gt; n &gt;&gt; m;\n        std::vector&lt;int&gt; f(n + 1);\n        std::iota(f.begin() + 1, f.end(), 1);\n        std::function&lt;int(int)&gt; find = [&amp;](int x) &#123;\n            return x == f[x] ? x : f[x] = find(f[x]);\n        &#125;;\n        auto merge = [&amp;](int x, int y) &#123;\n            f[find(x)] = find(y);\n            return;\n        &#125;;\n        std::vector&lt;long long&gt; fac(n + 1), inv(n + 1);\n        fac[0] = inv[0] = 1ll;\n        for (int i = 1; i &lt;= n; ++i)\n            fac[i] = fac[i - 1] * i % mod;\n        auto qkp = [&amp;](long long x, int y) &#123;\n            auto res = 1ll;\n            for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n                if (y &amp; 1)\n                    (res *= x) %= mod;\n            return res;\n        &#125;;\n        inv[n] = qkp(fac[n], mod - 2);\n        for (int i = n - 1; i; --i)\n            inv[i] = inv[i + 1] * (i + 1) % mod;\n        std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);\n        std::vector&lt;int&gt; a(n + 1), w(n + 1), to(n + 1), col(2 * n + 1);\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            std::cin &gt;&gt; a[i] &gt;&gt; to[i] &gt;&gt; w[i];\n            merge(i, to[i]);\n            g[to[i]].push_back(i);\n        &#125;\n        int now = 0, tot = n;\n        std::vector&lt;int&gt; tab(n + 1), tad(n + 1), vis(n + 1), L(2 * n + 1), R(2 * n + 1);\n        auto getty = [&amp;](int x) &#123;\n            if (a[to[x]] &gt; a[x])\n                return 1;\n            if (a[to[x]] + w[to[x]] &lt;= a[x])\n                return 2;\n            return 3;\n        &#125;;\n        for (int i = 1; i &lt;= n; ++i)\n            if (f[i] == i) &#123;\n                std::vector&lt;int&gt; vis(n + 1), t(1);\n                std::stack&lt;int&gt; st;\n                for (int x = i; ; ) &#123;\n                    st.push(x);\n                    if (!vis[to[x]])\n                        vis[to[x]] = 1, x = to[x];\n                    else &#123;\n                        for (;;) &#123;\n                            t.push_back(st.top());\n                            if (st.top() == to[x])\n                                break;\n                            st.pop();\n                        &#125;\n                        break;\n                    &#125;\n                &#125;\n                int k = (int)t.size() - 1;\n                std::reverse(t.begin() + 1, t.end());\n                t.resize(2 * k + 1);\n                L[++tot] = now + 1;\n                for (int i = 1; i &lt;= k; ++i) &#123;\n                    tab[t[i]] = ++now;\n                    col[t[i]] = tot;\n                    ::dep[tab[t[i]]] = 2 * k - i + 1;\n                    ::ty[tab[t[i]]] = getty(t[i]);\n                &#125;\n                for (int i = k + 1; i &lt;= 2 * k; ++i) &#123;\n                    t[i] = t[i - k];\n                    tad[t[i]] = ++now;\n                    ::dep[tad[t[i]]] = 2 * k - i + 1;\n                    ::ty[tad[t[i]]] = getty(t[i]);\n                &#125;\n                R[tot] = now;\n            &#125;\n        std::vector&lt;int&gt; fa(n + 1), siz(n + 1), son(n + 1), dep(n + 1);\n        std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;\n            siz[x] = 1;\n            for (auto i : g[x])\n                if (!tab[i]) &#123;\n                    dep[i] = dep[x] + 1;\n                    fa[i] = x, DFS(i);\n                    siz[x] += siz[i];\n                    if (siz[i] &gt; siz[son[x]])\n                        son[x] = i;\n                &#125;\n            return;\n        &#125;;\n        for (int i = 1; i &lt;= n; ++i)\n            if (tab[i])\n                dep[i] = 1, DFS(i);\n        std::vector&lt;int&gt; rt(2 * n + 1), dfn(n + 1), top(n + 1), bot(n + 1);\n        DFS = [&amp;](int x) &#123;\n            dfn[x] = ++now;\n            ty[dfn[x]] = getty(x);\n            ::dep[dfn[x]] = dep[x];\n            bot[top[x]] = x;\n            if (son[x])\n                top[son[x]] = top[x], DFS(son[x]);\n            for (auto i : g[x])\n                if (i != son[x] &amp;&amp; !tab[i])\n                    top[i] = i, DFS(i);\n            if (x == top[x])\n                bld(rt[x], dfn[x], dfn[bot[x]]);\n            return;\n        &#125;;\n        for (int i = 1; i &lt;= n; ++i)\n            if (tab[i])\n                top[i] = i, DFS(i);\n        for (int i = n + 1; i &lt;= tot; ++i)\n            bld(rt[i], L[i], R[i]);\n        auto work = [&amp;](int x) &#123;\n            ty[dfn[x]] = getty(x);\n            upd(rt[top[x]], dfn[x]);\n            if (tab[x]) &#123;\n                ty[tab[x]] = ty[tad[x]] = getty(x);\n                upd(rt[col[x]], tab[x]), upd(rt[col[x]], tad[x]);\n            &#125;\n            return;\n        &#125;;\n        for (int op; m--; ) &#123;\n            std::cin &gt;&gt; op;\n            if (op == 1) &#123;\n                int x;\n                std::cin &gt;&gt; x, std::cin &gt;&gt; a[x];\n                work(x);\n                for (auto i : g[x])\n                    work(i);\n            &#125;\n            else if (op == 2) &#123;\n                int x;\n                std::cin &gt;&gt; x, std::cin &gt;&gt; w[x];\n                work(x);\n                for (auto i : g[x])\n                    work(i);\n            &#125;\n            else &#123;\n                int x;\n                std::cin &gt;&gt; x;\n                auto calc = [&amp;](int x) &#123;\n                    int len = 0, toq = 0;\n                    for (; x; x = fa[top[x]]) &#123;\n                        auto [u1, u2] = ask(rt[top[x]], dfn[top[x]], dfn[x]);\n                        if (u1 &gt; u2)\n                            return len + dep[x] - u1 + 1;\n                        if (u2 &gt; u1)\n                            return -1;\n                        len += dep[x] - dep[fa[top[x]]], toq = top[x];\n                    &#125;\n                    auto [u1, u2] = ask(rt[col[toq]], tab[toq], R[col[toq]]);\n                    if (u1 &gt; u2)\n                        return len + ::dep[tab[toq]] - u1;\n                    return -1;\n                &#125;;\n                auto t(calc(x));\n                if (t == -1)\n                    std::cout &lt;&lt; a[x] &lt;&lt; &#39;\\n&#39;;\n                else &#123;\n                    // std::cout &lt;&lt; &quot;len = &quot; &lt;&lt; t &lt;&lt; &#39;\\n&#39;;\n                    std::cout &lt;&lt; ((a[x] + w[x]) * inv[t] % mod + (1ll + mod - inv[t]) % mod * a[x] % mod) % mod &lt;&lt; &#39;\\n&#39;;\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"b.-炒鱿鱼\">B. 炒鱿鱼</h2>\n<p><a href=\"https://www.becoder.com.cn/contest/6666/problem/2\" class=\"uri\">https://www.becoder.com.cn/contest/6666/problem/2</a></p>\n<blockquote>\n<p>现在有一个栈。在接下来的 <span class=\"math inline\">\\(n\\)</span> 个时刻，每个时刻会发生一次事件，形如：</p>\n<ul>\n<li>删除栈顶的 <span class=\"math inline\">\\(a_i\\)</span> 个元素，然后向栈顶加入 <span class=\"math inline\">\\(b_i\\)</span> 个元素。</li>\n</ul>\n<p>现在每个时刻都让一个人去执行事件，需要满足每个元素，加入它的和删除它的不能是同一个人。问最少需要多少个人才能实现这一点。输出方案。有 SPJ。</p>\n<p><span class=\"math inline\">\\(n\\le 10^5,V=10^9\\)</span>。</p>\n</blockquote>\n<ul>\n<li>可以猜到答案只会为 1 2 3，尝试从图染色的角度考虑这个问题（<strong>怎么想到这一点？</strong>）。</li>\n<li>一个元素在哪个时刻被加入 / 删除是固定的，故如果两天有冲突，可以考虑直接连边。考虑模拟，能够线性地求出来所有冲突关系，故边数是 <span class=\"math inline\">\\(O(n)\\)</span> 的。</li>\n<li><p>由于这个栈的结构，发现不存在交错的边，或者说不同时存在 <span class=\"math inline\">\\((x_1,y_1)\\)</span> 和 <span class=\"math inline\">\\((x_2,y_2)\\)</span>，使得 <span class=\"math inline\">\\(x_1&lt;x_2&lt;y_1&lt;y_2\\)</span>。考虑构造解：</p>\n<p>首先对于 <span class=\"math inline\">\\(1,n\\)</span> 任意涂色，忽略 <span class=\"math inline\">\\((1,n)\\)</span> 这条边（如果有），显然可以找到一个 <span class=\"math inline\">\\(mid\\)</span> 使得没有边跨过之，给其赋一个合法的颜色，接着就可以分治构造。</p>\n<p>感觉这种构造不算太显然，只能算是能想到（实际上并没有）。</p>\n<p>具体分治，由于性质比较好，直接取左端点对应范围内最远的边即可。</p></li>\n<li><p>需要注意上述构造方案能保证可以构造出 <span class=\"math inline\">\\(k=3\\)</span> 的解，但不能保证是最优的（即不能保证 <span class=\"math inline\">\\(k=1\\)</span> 或 <span class=\"math inline\">\\(k=2\\)</span> 也能构造出对应的解），故需要特判没有边 + 二分图两种情况。</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n    std::freopen(&quot;fire.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;fire.out&quot;, &quot;w&quot;, stdout);\n#else\n    // std::freopen(&quot;./test/20251022/fire/fire2.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;std::pair&lt;int, int&gt; &gt; a(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i].first &gt;&gt; a[i].second;\n    bool flag = true;\n    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1), g1(n + 1);\n    std::stack&lt;std::pair&lt;int, int&gt; &gt; st;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        for (int j = 0; j &lt; a[i].first; ) &#123;\n            g[st.top().second].push_back(i);\n            g1[st.top().second].push_back(i);\n            g1[i].push_back(st.top().second);\n            flag = false;\n            int to = std::min(st.top().first, a[i].first - j);\n            j += to, st.top().first -= to;\n            if (st.top().first == 0)\n                st.pop();\n        &#125;\n        if (a[i].second)\n            st.emplace(a[i].second, i);\n    &#125;\n    if (flag == true) &#123;\n        std::cout &lt;&lt; 1 &lt;&lt; &#39;\\n&#39;;\n        for (int i = 1; i &lt;= n; ++i)\n            std::cout &lt;&lt; 1 &lt;&lt; &#39; &#39;;\n        std::cout &lt;&lt; &#39;\\n&#39;;\n        return 0;\n    &#125;\n    std::vector&lt;int&gt; col(n + 1);\n    std::function&lt;bool(int, int)&gt; DFS = [&amp;](int x, int now) &#123;\n        col[x] = now;\n        for (auto i : g1[x])\n            if (!col[i]) &#123;\n                if (!DFS(i, 3 - now))\n                    return false;\n            &#125;\n            else if (col[i] == now)\n                return false;\n        return true;\n    &#125;;\n    for (int i = 1; i &lt;= n; ++i)\n        if (!col[i] &amp;&amp; !DFS(i, 1))\n            goto nosol;\n    std::cout &lt;&lt; 2 &lt;&lt; &#39;\\n&#39;;\n    for (int i = 1; i &lt;= n; ++i)\n        std::cout &lt;&lt; col[i] &lt;&lt; &#39; &#39;;\n    std::cout &lt;&lt; &#39;\\n&#39;;\n    return 0;\nnosol: ;\n    col[1] = 1, col[n] = 2;\n    std::function&lt;void(int, int)&gt; calc = [&amp;](int l, int r) &#123;\n        if (r - l + 1 &lt;= 2)\n            return;\n        if (!g[l].empty() &amp;&amp; g[l].back() == r)\n            g[l].pop_back();\n        int pos = g[l].empty() ? l + 1 : g[l].back();\n        col[pos] = 6 - col[l] - col[r];\n        calc(l, pos), calc(pos, r);\n        return;\n    &#125;;\n    calc(1, n);\n    std::cout &lt;&lt; 3 &lt;&lt; &#39;\\n&#39;;\n    for (int i = 1; i &lt;= n; ++i)\n        std::cout &lt;&lt; col[i] &lt;&lt; &#39; &#39;;\n    std::cout &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"c.-适格者\">C. 适格者</h2>\n<p><a href=\"https://www.becoder.com.cn/contest/6666/problem/3\" class=\"uri\">https://www.becoder.com.cn/contest/6666/problem/3</a></p>\n<blockquote>\n<p>给定长度为 <span class=\"math inline\">\\(2^n\\)</span> 的数组 <span class=\"math inline\">\\(a_{0,\\cdots,2^n-1}\\)</span>，维护 <span class=\"math inline\">\\(q\\)</span> 次操作：</p>\n<ul>\n<li>修改：单点加；</li>\n<li>修改：高维前缀加；</li>\n<li>修改：高维后缀加；</li>\n<li>询问：高维前缀和，对 <span class=\"math inline\">\\(998244353\\)</span> 取模；</li>\n</ul>\n<p><span class=\"math inline\">\\(n\\le 20,q\\le 10^5\\)</span>。</p>\n</blockquote>\n<ul>\n<li>单点加 + 高维前缀和会反应出 <a href=\"/20250907/#e---subset-product-problem\">ARC205E</a> 的 trick</li>\n<li><p>考虑怎么做后缀加，会反应过来和 <a href=\"/20251010/#区间修改区间查询\">bit 的区间修改</a> 有一致性，修改相当于单点修改差分数组。考虑类似的推导：</p>\n<p><span class=\"math display\">\\[\n\\begin{aligned}\n\\sum_{s\\subseteq S}a_s&amp;=\\sum_{s\\subseteq S} \\sum_{i\\subseteq s} d_i\\\\\n&amp;=\\sum_{i\\subseteq S} 2^{|S|-|i|}\\times d_i\n\\end{aligned}\n\\]</span></p>\n<p>故维护 <span class=\"math inline\">\\(2^{-|i|}\\cdot d_i\\)</span> 即可（原来取模是拿来搞这个的）。类似地可以推导前缀加：</p>\n<p><span class=\"math display\">\\[\n\\begin{aligned}\n\\sum_{s\\subseteq S}a_s&amp;=\\sum_{s\\subseteq S} \\sum_{i\\supseteq s} d_i\\\\\n&amp;=\\sum_{i\\subseteq S} 2^{|S \\text{ bitand } i|}\\times d_i\n\\end{aligned}\n\\]</span></p>\n<p>发现这个 bitand 不太好搞，不过 bitand 是对位的，所以依然可以套在分块上</p>\n<p>同时，因为问的是前缀和，所以单点的 <span class=\"math inline\">\\(S\\text{ bitand } i\\)</span> 其实就是 <span class=\"math inline\">\\(i\\)</span>。这里有点囿于 fmt 的思维定势了，实际上可以直接认为 <span class=\"math inline\">\\(f_{s_1, s_2}\\)</span> 维护的是这个点处的答案，每次更新对 <span class=\"math inline\">\\(f_{s_1,*}\\)</span> 的贡献即可。</p></li>\n</ul>\n<details>\n<p>不知为何很慢</p>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 998244353;\nconst int inv2 = (mod + 1) &gt;&gt; 1;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n    std::freopen(&quot;gene.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;gene.out&quot;, &quot;w&quot;, stdout);\n#else\n    // std::freopen(&quot;./test/20251022/gene/gene5.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, q;\n    std::cin &gt;&gt; n &gt;&gt; q;\n    const int N1 = n / 2, N2 = n - N1, lim = 1 &lt;&lt; N2;\n    std::vector&lt;long long&gt; inv(n + 1);\n    inv[0]= 1ll;\n    for (int i = 1; i &lt;= n; ++i)\n        inv[i] = inv[i - 1] * inv2 % mod;\n    std::vector&lt;std::vector&lt;long long&gt; &gt; s(1 &lt;&lt; N1, std::vector&lt;long long&gt; (lim));\n    auto s1(s), s2(s);\n    for (int op, x; q--; ) &#123;\n        std::cin &gt;&gt; op &gt;&gt; x;\n        int X1 = x &gt;&gt; N2, X2 = x &amp; (lim - 1);\n        if (op == 0) &#123;\n            auto res = 0ll, res1 = 0ll, res2 = 0ll;\n            for (int i = 0; i &lt; (1 &lt;&lt; N1); ++i)\n                res2 += (1 &lt;&lt; __builtin_popcount(i &amp; X1)) * s2[i][X2] % mod;\n            for (int i = X1; ; i = X1 &amp; (i - 1)) &#123;\n                res += s[i][X2];\n                res1 += s1[i][X2] * (1 &lt;&lt; __builtin_popcount(x)) % mod;\n                if (i == 0)\n                    break;\n            &#125;\n            std::cout &lt;&lt; (res + res1 + res2) % mod &lt;&lt; &#39;\\n&#39;;\n        &#125;\n        else if (op == 1) &#123;\n            int v;\n            std::cin &gt;&gt; v;\n            int X3 = (lim - 1) ^ X2;\n            for (int i = X3; ; i = X3 &amp; (i - 1)) &#123;\n                (s[X1][(lim - 1) ^ i] += v) %= mod;\n                if (i == 0)\n                    break;\n            &#125;\n        &#125;\n        else if (op == 2) &#123;\n            long long v;\n            std::cin &gt;&gt; v, (v *= inv[__builtin_popcount(x)]) %= mod;\n            int X3 = (lim - 1) ^ X2;\n            for (int i = X3; ; i = X3 &amp; (i - 1)) &#123;\n                (s1[X1][(lim - 1) ^ i] += v) %= mod;\n                if (i == 0)\n                    break;\n            &#125;\n        &#125;\n        else &#123;\n            long long v;\n            std::cin &gt;&gt; v;\n            for (int i = 0; i &lt; lim; ++i)\n                (s2[X1][i] += v * (1 &lt;&lt; __builtin_popcount(i &amp; X2))) %= mod;\n        &#125;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"cf1784c-monsters-hard-version\">CF1784C Monsters (hard version)</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/CF1784C\" class=\"uri\">https://www.luogu.com.cn/problem/CF1784C</a></p>\n<ul>\n<li><p>通过若干次 1 操作，把数列的值域变成包含 1 且连续的，然后执行 2 操作，一定不劣</p></li>\n<li><p>考虑怎么快速维护这个东西，发现只关心初始序列和目标序列（从计算代价的式子可以看出来），故考虑这样一个构造最终序列的方式：</p>\n<ul>\n<li>从前到后遍历值域上的每个空位，找到第一个大于之的元素，并放过来，重复执行直到上述步骤不能执行为止。</li>\n</ul>\n<p>直接考虑一次加点带来的影响似乎非常复杂，但如果时光倒流，发现有贪心策略，直接把最后一次操作挪到这个新的空位即可。</p></li>\n<li><p>电波题！用 set 维护即可。</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int T;\n    for (std::cin &gt;&gt; T; T--; ) &#123;\n        int n;\n        std::cin &gt;&gt; n;\n        std::set&lt;std::pair&lt;int, int&gt; &gt; t;\n        std::vector&lt;long long&gt; res(n + 1);\n        std::vector&lt;int&gt; a(n + 1), to(n + 1), at(n + 1);\n        for (int i = 1; i &lt;= n; ++i)\n            std::cin &gt;&gt; a[i], t.emplace(a[i], i);\n        int now;\n        for (now = 1; ; ++now) &#123;\n            auto p(t.lower_bound(&#123; now, 0 &#125;));\n            if (p == t.end())\n                break;\n            at[now] = p-&gt;second;\n            to[p-&gt;second] = now;\n            res[n] += p-&gt;first - now;\n            t.erase(p);\n        &#125;\n        --now;\n        for (int i = n - 1; i; --i) &#123;\n            res[i] = res[i + 1];\n            if (to[i + 1]) &#123;\n                res[i] -= a[i + 1] - to[i + 1];\n                auto p = t.lower_bound(&#123; to[i + 1], 0 &#125;);\n                if (p != t.end()) &#123;\n                    at[to[i + 1]] = p-&gt;second;\n                    to[p-&gt;second] = to[i + 1];\n                    res[i] += a[p-&gt;second] - to[i + 1];\n                    t.erase(p);\n                &#125;\n                else &#123;\n                    res[i] -= a[at[now]] - to[at[now]];\n                    res[i] += a[at[now]] - to[i + 1];\n                    to[at[now]] = to[i + 1];\n                    at[to[i + 1]] = at[now];\n                    --now;\n                &#125;\n            &#125;\n            else\n                t.erase(&#123; a[i + 1], i + 1 &#125;);\n        &#125;\n        for (int i = 1; i &lt;= n; ++i)\n            std::cout &lt;&lt; res[i] &lt;&lt; &#39; &#39;;\n        std::cout &lt;&lt; &#39;\\n&#39;;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"cf891c-envy\">CF891C Envy</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/CF891C\" class=\"uri\">https://www.luogu.com.cn/problem/CF891C</a></p>\n<p>mobai ddxrS</p>\n<ul>\n<li><p>经典结论：在做完权值 <span class=\"math inline\">\\(&lt;w\\)</span> 的 Kruskal 后，权值 <span class=\"math inline\">\\(=w\\)</span> 的边以任意顺序加入 Kruskal 后，并查集连通性完全一致。</p></li>\n<li><p>Another 经典结论：一条权值为 <span class=\"math inline\">\\(w\\)</span> 的边可以属于 mst，当且仅当在做完权值 <span class=\"math inline\">\\(&lt;w\\)</span> 的 Kruskal 后，这条边加入不形成环。</p></li>\n<li><p>重要事实：把并查集的 <code>merge</code> 操作打乱，连通性不变。</p></li>\n<li><p>结合起来得到这个神秘做法：按照边权做 Kruskal 检验每条边是否可以加入 mst，如果可以则记录合并的两个根，作为<strong>新边</strong>（不带权）。</p>\n<p><mark>重要事实：对于 <span class=\"math inline\">\\(n-1\\)</span> 条<strong>新边</strong>，要么有环，要么形成 mst。</mark></p>\n<p>推广：对于任意条<strong>新边</strong>，要么有环，要么可以通过某种选取其他<strong>新边</strong>的方式形成 mst。</p>\n<p>故 check 给定边的<strong>新边</strong>是否成环即可。算是一个 trick 吗？</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    const int M = 5e5;\n    int n, m;\n    std::cin &gt;&gt; n &gt;&gt; m;\n    std::vector&lt;std::pair&lt;int, int&gt; &gt; ne(m + 1);\n    std::vector&lt;std::vector&lt;std::tuple&lt;int, int, int&gt; &gt; &gt; e(M + 1); \n    for (int i = 1, x, y, w; i &lt;= m; ++i) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y &gt;&gt; w;\n        e[w].emplace_back(x, y, i);\n    &#125;\n    std::vector&lt;int&gt; f(n + 1);\n    std::iota(f.begin() + 1, f.end(), 1);\n    std::function&lt;int(int)&gt; find = [&amp;](int x) &#123;\n        return x == f[x] ? x : f[x] = find(f[x]);\n    &#125;;\n    for (int i = 1; i &lt;= M; ++i) &#123;\n        for (auto [u, v, id] : e[i])\n            ne[id] = &#123; find(u), find(v) &#125;;\n        for (auto [u, v, id] : e[i])\n            f[find(u)] = find(v);\n    &#125;\n    std::iota(f.begin() + 1, f.end(), 1);\n    int q;\n    for (std::cin &gt;&gt; q; q--; ) &#123;\n        int k;\n        std::cin &gt;&gt; k;\n        std::vector&lt;int&gt; pos;\n        bool flag = true;\n        for (int id; k--; ) &#123;\n            std::cin &gt;&gt; id;\n            if (find(ne[id].first) == find(ne[id].second))\n                flag = false;\n            f[find(ne[id].first)] = find(ne[id].second);\n            pos.push_back(ne[id].first);\n            pos.push_back(ne[id].second);\n        &#125;\n        std::cout &lt;&lt; (flag ? &quot;YES&quot; : &quot;NO&quot;) &lt;&lt; &#39;\\n&#39;;\n        for (auto i : pos)\n            f[i] = i;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"c.-山月记\">C. 山月记</h2>\n<p><a href=\"https://www.becoder.com.cn/problem/52034\" class=\"uri\">https://www.becoder.com.cn/problem/52034</a></p>\n<blockquote>\n<p>给定一棵大小为 <span class=\"math inline\">\\(n\\)</span> 的带权无根树 <span class=\"math inline\">\\(T\\)</span>，再给定 <span class=\"math inline\">\\(m\\)</span> 条额外的边，和 <span class=\"math inline\">\\(T\\)</span> 一起形成一个图 <span class=\"math inline\">\\(G\\)</span>。</p>\n<p>定义一个点 <span class=\"math inline\">\\(u\\)</span> 是好的，当且仅当对于<strong>每一个</strong> <span class=\"math inline\">\\(1\\le v\\le n\\)</span>，<strong><span class=\"math inline\">\\(T\\)</span> 上的</strong>简单路径 <span class=\"math inline\">\\((u,v)\\)</span> 都可以被 <span class=\"math inline\">\\(G\\)</span> 的某个 MST <strong>完整</strong>包含。</p>\n<p>输出任意一个好的点。无解输出 <span class=\"math inline\">\\(0\\)</span>。有 SPJ。</p>\n<p><span class=\"math inline\">\\(n,m\\le 10^5\\)</span>，<span class=\"math inline\">\\(w\\le 10^9\\)</span>。</p>\n</blockquote>\n<ul>\n<li><p>参考上一题，朴素做法是 <span class=\"math inline\">\\(O(n^2)\\)</span> 枚举某个 <span class=\"math inline\">\\(x\\)</span> 开头的路径，然后 <span class=\"math inline\">\\(O(len)\\)</span> 地 check；</p>\n<p>注意到这个结构能很好地和 DFS + 回溯结合，用可撤销并查集维护即可在 <span class=\"math inline\">\\(O(n\\log n)\\)</span> 内完成对一个 <span class=\"math inline\">\\(x\\)</span> 所有路径的 check。</p></li>\n<li><p>发现：如果一条路径 <span class=\"math inline\">\\((u,v)\\)</span> 是非法的，进一步所有完整包含 <span class=\"math inline\">\\((u,v)\\)</span> 的路径都是非法的。</p>\n<p><strong>从路径反映到点上</strong>，会发现 <span class=\"math inline\">\\((u,v)\\)</span> 两侧的点都是非法的。下意识考虑不在 <span class=\"math inline\">\\((u,v)\\)</span> 两侧，但在 <span class=\"math inline\">\\((u,v)\\)</span> 之外的点，发现它们仍然有可能合法，只要满足如下情况：</p>\n<p><img src=\"image-3.png\" /></p></li>\n<li><p>也就是说，对于 <span class=\"math inline\">\\(x\\)</span>，如果它出发的所有路径都合法，那么 <span class=\"math inline\">\\(x\\)</span> 自己就是答案；</p>\n<p>如果存在 <span class=\"math inline\">\\(\\ge 2\\)</span> 条非法路径，那么无解；</p>\n<p>否则，存在恰好一条边，在非法边所在的子树中递归求解，发现这很点分治，故可以 <span class=\"math inline\">\\(O(n\\log^2 n)\\)</span> 解决。log 分别来自点分治和撤销并查集。</p></li>\n<li><p>注：这里唐唐的，check 写成点分树子树内 check 了。点分治在这里只起保证递归层数的作用。</p></li>\n</ul>\n<details>\n<p>怎么跑得这么快？推测因为写的是按秩合并。</p>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;./test/20251024/beast/beast1.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int T;\n    for (std::cin &gt;&gt; T; T--; ) &#123;\n        int n, m;\n        std::cin &gt;&gt; n &gt;&gt; m;\n        std::vector&lt;int&gt; l(1);\n        std::vector&lt;std::pair&lt;int, int&gt; &gt; ne(m + 1);\n        std::vector&lt;std::tuple&lt;int, int, int&gt; &gt; se(m + 1);\n        std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; g(n + 1);\n        std::vector&lt;std::vector&lt;std::tuple&lt;int, int, int&gt; &gt; &gt; e(m + 1); \n        for (int i = 1, x, y, w; i &lt;= m; ++i) &#123;\n            std::cin &gt;&gt; x &gt;&gt; y &gt;&gt; w;\n            se[i] = &#123; x, y, w &#125;, l.push_back(w);\n            if (i &lt; n)\n                g[x].emplace_back(y, i), g[y].emplace_back(x, i);\n        &#125;\n        std::sort(l.begin() + 1, l.end());\n        l.erase(std::unique(l.begin() + 1, l.end()), l.end());\n        for (int i = 1; i &lt;= m; ++i) &#123;\n            auto [x, y, w] = se[i];\n            w = std::lower_bound(l.begin() + 1, l.end(), w) - l.begin();\n            e[w].emplace_back(x, y, i);\n        &#125;\n        std::vector&lt;int&gt; f(n + 1);\n        std::iota(f.begin() + 1, f.end(), 1);\n        std::function&lt;int(int)&gt; find = [&amp;](int x) &#123;\n            return x == f[x] ? x : f[x] = find(f[x]);\n        &#125;;\n        for (int i = 1; i &lt;= m; ++i) &#123;\n            for (auto [u, v, id] : e[i])\n                ne[id] = &#123; find(u), find(v) &#125;;\n            for (auto [u, v, id] : e[i])\n                f[find(u)] = find(v);\n        &#125;\n        std::vector&lt;int&gt; tag(n + 1), p, siz(n + 1), mx(n + 1);\n        std::function&lt;void(int, int)&gt; DFS1 = [&amp;](int x, int fa) &#123;\n            p.push_back(x);\n            siz[x] = 1, mx[x] = 0;\n            for (auto [i, id] : g[x])\n                if (i != fa &amp;&amp; !tag[i]) &#123;\n                    DFS1(i, x);\n                    siz[x] += siz[i];\n                    mx[x] = std::max(mx[x], siz[i]);\n                &#125;\n            return;\n        &#125;;\n        auto findrt = [&amp;](int x) &#123;\n            p.clear(), DFS1(x, -1);\n            int n = (int)p.size();\n            for (auto i : p)\n                if (mx[i] &lt;= n / 2 &amp;&amp; n - siz[i] &lt;= n / 2)\n                    return i;\n            assert(0);\n            return -1;\n        &#125;;\n        std::vector&lt;int&gt; rank(n + 1);\n        std::stack&lt;std::tuple&lt;int, int, int&gt; &gt; st;\n        find = [&amp;](int x) &#123;\n            return x == f[x] ? x : find(f[x]);\n        &#125;;\n        auto merge = [&amp;](int x, int y) &#123;\n            x = find(x), y = find(y);\n            if (x == y)\n                return true;\n            if (rank[x] &lt;= rank[y])\n                st.emplace(x, y, rank[y]), f[x] = y;\n            else \n                st.emplace(y, x, rank[x]), f[y] = x;\n            if (rank[x] == rank[y])\n                ++rank[y];\n            return false;\n        &#125;;\n        auto undo = [&amp;](void) &#123;\n            assert(!st.empty());\n            auto [x, y, ry] = st.top();\n            st.pop();\n            f[x] = x, rank[y] = ry;\n            return;\n        &#125;;\n        std::function&lt;bool(int, int)&gt; DFS2 = [&amp;](int x, int fa) &#123;\n            for (auto [i, id] : g[x])\n                if (i != fa &amp;&amp; (merge(ne[id].first, ne[id].second) || DFS2(i, x))) &#123;\n                    undo();\n                    return true;\n                &#125;\n            undo();\n            return false;\n        &#125;;\n        std::function&lt;bool(int)&gt; DFS = [&amp;](int x) &#123;\n            x = findrt(x);\n            int to = 0;\n            for (auto [i, id] : g[x])\n                if (merge(ne[id].first, ne[id].second) || DFS2(i, x)) &#123;\n                    if (!to) to = i;\n                    else &#123;\n                        std::cout &lt;&lt; 0 &lt;&lt; &#39;\\n&#39;;\n                        return true;\n                    &#125;\n                &#125;\n            assert(st.empty());\n            tag[x] = 1;\n            if (to) &#123;\n                if (tag[to]) &#123;\n                    std::cout &lt;&lt; 0 &lt;&lt; &#39;\\n&#39;;\n                    return true;\n                &#125;\n                return DFS(to);\n            &#125;\n            std::cout &lt;&lt; x &lt;&lt; &#39;\\n&#39;;\n            return true;\n        &#125;;\n        std::iota(f.begin() + 1, f.end(), 1);\n        assert(DFS(1));\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"b.-电报-a.-神灵庙-cf2068d-morse-code\">B. 电报 / A. 神灵庙 / CF2068D Morse Code</h2>\n<p><a href=\"https://www.becoder.com.cn/contest/6676/problem/2\" class=\"uri\">https://www.becoder.com.cn/contest/6676/problem/2</a> / <a href=\"https://www.becoder.com.cn/contest/5527/problem/1\" class=\"uri\">https://www.becoder.com.cn/contest/5527/problem/1</a> / <a href=\"https://www.luogu.com.cn/problem/CF2068D\" class=\"uri\">https://www.luogu.com.cn/problem/CF2068D</a></p>\n<blockquote>\n<p>一个无限大的完全二叉树，根节点权值为 <span class=\"math inline\">\\(0\\)</span>，一个点的左儿子权值是这个点的权值 <span class=\"math inline\">\\(+1\\)</span>，右儿子为 <span class=\"math inline\">\\(+2\\)</span>。</p>\n<p>给定 <span class=\"math inline\">\\(c_1,\\cdots, c_n\\)</span>，挑选 <span class=\"math inline\">\\(n\\)</span> 个互不为祖孙的点，最终代价为点权 <span class=\"math inline\">\\(\\times\\)</span> 对应的 <span class=\"math inline\">\\(c\\)</span> 之和。</p>\n</blockquote>\n<ul>\n<li><p>一个基本的观察：权值对应相邻两种值的结点数总是构成类似斐波那契的结构。显然应该把权值和点权逆大小对应。</p>\n<p>朴素 DP：令 <span class=\"math inline\">\\(f_{i,j,a,b}\\)</span> 表示当前枚举到权值 <span class=\"math inline\">\\(i\\)</span>，已经选了 <span class=\"math inline\">\\(j\\)</span> 个点，<span class=\"math inline\">\\(i-1\\)</span>、<span class=\"math inline\">\\(i\\)</span> 分别剩余 <span class=\"math inline\">\\(a,b\\)</span> 个点的最小代价，可以得到 <span class=\"math inline\">\\(n^5\\)</span> 的惊人转移。</p></li>\n<li><p>经典 trick：最后一层循环的枚举是无必要的，可以一个一个转移（类似完全背包）。这样就少了一个 <span class=\"math inline\">\\(n\\)</span>。如果观察到最深取到 1.5 log（斐波那契）能砍成 <span class=\"math inline\">\\(O(n^3\\log n)\\)</span>。</p></li>\n<li><p>接着，发现可以费用提前计算（这里我觉得更像是算贡献），少枚举一个 <span class=\"math inline\">\\(i\\)</span>，这样就是 <span class=\"math inline\">\\(O(n^3)\\)</span> 的了。</p>\n<p>发现没什么实现的头绪。目前有：</p>\n<p><span class=\"math display\">\\[\nf_{j,a,b}\\to f_{j+1,a,b-1}\\\\\nf_{j,a,b}+suf_{j+1}\\to f_{j,b,a+b}\n\\]</span></p>\n<p>以前没有注意到过，其实<strong>枚举顺序是由转移方程决定的</strong>：</p>\n<ul>\n<li>第一种转移中，<span class=\"math inline\">\\(j\\)</span> 是递增的，<span class=\"math inline\">\\(a\\)</span> 水平，<span class=\"math inline\">\\(b\\)</span> 递减；</li>\n<li>第二种转移中，<span class=\"math inline\">\\(j\\)</span> 水平，<span class=\"math inline\">\\(a\\)</span> 无法确定，<span class=\"math inline\">\\(b\\)</span> 不递减；</li>\n</ul>\n<p>可以想到一个转移顺序：正序枚举 <span class=\"math inline\">\\(j\\)</span>，正序枚举 <span class=\"math inline\">\\(b\\)</span>；正序枚举 <span class=\"math inline\">\\(a\\)</span>。</p>\n<p>此时第二种会有点问题，<span class=\"math inline\">\\(j\\)</span> 水平且 <span class=\"math inline\">\\(b\\)</span> 水平时，若 <span class=\"math inline\">\\(a\\)</span> 变小怎么办？发现这要求 <span class=\"math inline\">\\(b&lt;a\\)</span>，则 <span class=\"math inline\">\\(a+b&gt;b\\)</span> 恒成立，<span class=\"math inline\">\\(b\\)</span> 一定不水平。挺牛的这个。</p></li>\n<li><p>卡空间了，滚动一下即可。复杂度 <span class=\"math inline\">\\(O(n^3)\\)</span>。绅士写了神秘玄学<a href=\"https://www.becoder.com.cn/submission/3177578\">做法</a>，瞻仰无果。</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n    std::freopen(&quot;telegram.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;telegram.out&quot;, &quot;w&quot;, stdout);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;int&gt; c(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; c[i];\n    std::sort(c.begin() + 1, c.end(), std::greater&lt;int&gt; ());\n    std::partial_sum(c.rbegin(), c.rend(), c.rbegin());\n    using arr = std::vector&lt;int&gt;;\n    using brr = std::vector&lt;arr&gt;;\n    using crr = std::vector&lt;brr&gt;;\n    crr f(2, brr(n + 1, arr(n + 1))), tag(2, brr(n + 1, arr(n + 1, -1)));\n    f[0][1][1] = c[1], tag[0][1][1] = 0;\n    auto upd = [&amp;](int i, int &amp;t, int &amp;x, int y) &#123;\n        if (t == i)\n            x = std::min(x, y);\n        else\n            x = y, t = i;\n        return;\n    &#125;;\n    for (int j = 0, k = 0; j &lt; n; ++j, k ^= 1) &#123;\n        for (int b = 0; b &lt;= n; ++b)\n            for (int a = 0; a &lt;= n; ++a)\n                if (tag[k][b][a] == j) &#123;\n                    if (b)\n                        upd(j + 1, tag[k ^ 1][b - 1][a], f[k ^ 1][b - 1][a], f[k][b][a]);\n                    if (a + b &lt;= n)\n                        upd(j, tag[k][a + b][b], f[k][a + b][b], f[k][b][a] + c[j + 1]);\n                &#125;\n    &#125;\n    auto res = 0x3f3f3f3f;\n    for (int b = 0; b &lt;= n; ++b)\n        for (int a = 0; a &lt;= n; ++a)\n            if (tag[n &amp; 1][b][a] == n)\n                res = std::min(res, f[n &amp; 1][b][a]);\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"coi-2019-tenis\">[COI 2019] TENIS</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P11340\" class=\"uri\">https://www.luogu.com.cn/problem/P11340</a></p>\n<ul>\n<li><p>观察一：<span class=\"math inline\">\\(x\\)</span> 能获胜，当且仅当存在一个 <span class=\"math inline\">\\(y\\)</span>，使得 <span class=\"math inline\">\\(x\\)</span> 能战胜 <span class=\"math inline\">\\(y\\)</span>，且 <span class=\"math inline\">\\(y\\)</span> 能在剩下 <span class=\"math inline\">\\(n-1\\)</span> 个人中获胜。</p>\n<p>发现这是一个递归，或者说链式的关系。</p></li>\n<li><p>观察二：不妨把三个数组视为三条链，那么发现任意一个链首在任意局面总是能获胜。如果一个人能战胜链首，显然这个人能获胜。反过来，若不能通过任何方式战胜链首，显然无法获胜。</p>\n<p>然后就变成连通性问题了。但很容易猜到带删边连通性没什么优化的前途。</p>\n<p><em>只有加边的带修连通性问题：<a href=\"https://www.luogu.com.cn/article/taefjy3d\">整体二分</a></em>。</p></li>\n<li><p>观察三：链首不能被 <span class=\"math inline\">\\(x\\)</span> 战胜，当且仅当存在一个 <span class=\"math inline\">\\(i\\)</span>，三条链的前 <span class=\"math inline\">\\(i\\)</span> 个元素集相同，且 <span class=\"math inline\">\\(x\\)</span> 位于最小的 <span class=\"math inline\">\\(i\\)</span> 之后。</p>\n<p>这个看起来和 <a href=\"https://www.luogu.com.cn/problem/CF526F\">Puuding Monsters</a> / <a href=\"https://www.luogu.com.cn/problem/CF997E\">Good Subsegments</a> 比较像，实际上思路上也有共通之处：<strong>如果合法区间的值域是连续的，可以把条件转化为 min / max 问题。</strong></p>\n<p>考虑先使其<strong>询问区间内值域连续</strong>以套用这样的方法。可以对链 1 重标号为 <span class=\"math inline\">\\(1\\cdots n\\)</span>，维护链 2、3 的答案；也可以维护三个 rank 上的答案。法一实现起来有很多不必要的令人讨厌的地方，故写法二。</p></li>\n<li><p>相当于求一个最小的 <span class=\"math inline\">\\(i\\)</span> 使得链 1、2、3 在 <span class=\"math inline\">\\(i\\)</span> 之前的所有元素 rank 都不能比 <span class=\"math inline\">\\(i\\)</span> 大。主体为 <span class=\"math inline\">\\(i\\)</span> 时，（因为最小这个限制，和依次改动会带来很大的偏移），所以不太好维护；</p>\n<p>但是正确的维护方式很难想到！令 <span class=\"math inline\">\\(f_i,g_i\\)</span> 分别表示链 2、3 的每个 <span class=\"math inline\">\\(1\\le j\\le n\\)</span>，满足 <span class=\"math inline\">\\(\\min(r_{1/2/3,j})\\)</span>、<span class=\"math inline\">\\(\\max(r_{1/2/3,j})= i\\)</span> 的 <span class=\"math inline\">\\(j\\)</span> 的数量。如果二者在 <span class=\"math inline\">\\(i\\)</span> 处的前缀和相等，那么 <span class=\"math inline\">\\(i\\)</span> 就是合法的。</p>\n<blockquote>\n<p>Fractures（新角色）：这是个很常见的 trick。</p>\n<p>Fractures：这个和 Pudding Monsters 哪里像了。是你唐。</p>\n</blockquote>\n<p>维护 <span class=\"math inline\">\\(f_i-g_i\\)</span> 的前缀和；线段树维护区间修改和全局 min 即可。</p></li>\n</ul>\n<details>\n<p>莫名很慢。和 TTpandaS 相比多了一次建树（但不应该有这么大的影响才对）。</p>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 1e5 + 5;\nstruct &#123; int l, r, mn, at, d; &#125; t[maxn &lt;&lt; 2];\n#define lt (p &lt;&lt; 1)\n#define rt (lt | 1)\nvoid pushup(int p) &#123;\n    t[p].mn = std::min(t[lt].mn, t[rt].mn);\n    if (t[lt].mn == t[p].mn)\n        t[p].at = t[lt].at;\n    else\n        t[p].at = t[rt].at;\n    return;\n&#125;\nvoid pushdown(int p) &#123;\n    if (t[p].d) &#123;\n        t[lt].d += t[p].d, t[lt].mn += t[p].d;\n        t[rt].d += t[p].d, t[rt].mn += t[p].d;\n        t[p].d = 0;\n    &#125;\n    return;\n&#125;\nvoid bld(int p, int l, int r) &#123;\n    t[p].l = l, t[p].r = r;\n    if (l == r) &#123;\n        t[p].at = l;\n        return;\n    &#125;\n    int mid = (l + r) &gt;&gt; 1;\n    bld(lt, l, mid), bld(rt, mid + 1, r);\n    pushup(p);\n    return;\n&#125;\nvoid add(int p, int l, int r, int v) &#123;\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r) &#123;\n        t[p].d += v, t[p].mn += v;\n        return;\n    &#125;\n    pushdown(p);\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (l &lt;= mid)\n        add(lt, l, r, v);\n    if (r &gt; mid)\n        add(rt, l, r, v);\n    pushup(p);\n    return;\n&#125;\n#undef lt\n#undef rt\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n    std::freopen(&quot;match.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;match.out&quot;, &quot;w&quot;, stdout);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, q;\n    std::cin &gt;&gt; n &gt;&gt; q;\n    std::vector&lt;std::vector&lt;int&gt; &gt; p(3, std::vector&lt;int&gt; (n + 1));\n    for (int k = 0; k &lt; 3; ++k)\n        for (int i = 1, x; i &lt;= n; ++i)\n            std::cin &gt;&gt; x, p[k][x] = i;\n    bld(1, 1, n);\n    auto upd = [&amp;](int i, int k) &#123;\n        add(1, std::min(&#123; p[0][i], p[1][i], p[2][i] &#125;), n, k);\n        add(1, std::max(&#123; p[0][i], p[1][i], p[2][i] &#125;), n, -k);\n        return;\n    &#125;;\n    for (int i = 1; i &lt;= n; ++i)\n        upd(i, 1);\n    int now = t[1].at;\n    // printf(&quot;now = %d \\n&quot;, now);\n    for (int op; q--; ) &#123;\n        std::cin &gt;&gt; op;\n        if (op == 1) &#123;\n            int x;\n            std::cin &gt;&gt; x;\n            std::cout &lt;&lt; (std::min(&#123; p[0][x], p[1][x], p[2][x] &#125;) &lt;= now ? &quot;Yes&quot; : &quot;No&quot;) &lt;&lt; &#39;\\n&#39;;\n        &#125;\n        else &#123;\n            int k, i, j;\n            std::cin &gt;&gt; k &gt;&gt; i &gt;&gt; j, --k;\n            upd(i, -1), upd(j, -1);\n            std::swap(p[k][i], p[k][j]);\n            upd(i, 1), upd(j, 1);\n            now = t[1].at;\n            // printf(&quot;now = %d \\n&quot;, now);\n        &#125;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n",
            "tags": [
                "线段树",
                "最小生成树",
                "贪心",
                "优化建图",
                "DP 优化",
                "点分治"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20250816/",
            "url": "https://xsc062.netlify.app/20250816/",
            "title": "近期杂题 II",
            "date_published": "2025-08-16T08:14:12.000Z",
            "content_html": "<p>和 Aug 9th 的杂题不太能合并，所以分开了</p>\n<span id=\"more\"></span>\n<hr />\n<h2 id=\"b.-gas-fire-extinguishers\">B. GAS-Fire Extinguishers</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P3479\" class=\"uri\">https://www.luogu.com.cn/problem/P3479</a></p>\n<p>显然可以贪心，不妨从下到上，记录当前遍历过的、空余出来的灭火器（其实算的是可以供给的房间数）和还未分配灭火器的房间，按距离为 <span class=\"math inline\">\\(0\\sim k\\)</span> 分组。</p>\n<p>不难发现如果在某个点 <span class=\"math inline\">\\(u\\)</span> 处存在距离为 <span class=\"math inline\">\\(k\\)</span> 的空闲灭火器，可以贪心地分配给 <span class=\"math inline\">\\(u\\)</span>；如果存在距离为 <span class=\"math inline\">\\(k\\)</span> 的未分配房间，也可以在 <span class=\"math inline\">\\(u\\)</span> 处放置灭火器并分配给这些房间。类似地，进行两两配对一定是不劣的。</p>\n<p>发现同子树内距离为 <span class=\"math inline\">\\(k-1\\)</span> 的点对留到 <span class=\"math inline\">\\(fa\\)</span> 再匹配是不行的，因为这时距离会变成 <span class=\"math inline\">\\(k+1\\)</span>，不能匹配上；可以感受到这样是更劣的。</p>\n<p>然后就可以做了，根节点特殊乱贪心一下就行了。记得开 long long。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\n#define int long long\nsigned main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, s, k, res = 0;\n    std::cin &gt;&gt; n &gt;&gt; s &gt;&gt; k;\n    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1), p(n + 1, std::vector&lt;int&gt; (k + 1)), q(n + 1, std::vector&lt;int&gt; (k + 1));\n    for (int i = 1, x, y; i &lt; n; ++i) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y;\n        g[x].push_back(y), g[y].push_back(x);\n    &#125;\n    std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int fa) &#123;\n        for (auto i : g[x])\n            if (i != fa)  &#123;\n                DFS(i, x);\n                for (int j = 0; j &lt; k; ++j)\n                    p[x][j + 1] += p[i][j], q[x][j + 1] += q[i][j];\n            &#125;\n        ++q[x][0];\n        if (x != 1) &#123;\n            int v = (q[x][k] + s - 1) / s;\n            p[x][0] = v * s, res += v;\n            for (int i = 0; i &lt;= k; ++i) &#123;\n                int v = std::min(p[x][i], q[x][k - i]);\n                p[x][i] -= v, q[x][k - i] -= v;\n            &#125;\n            for (int i = 0; i &lt; k; ++i) &#123;\n                int v = std::min(p[x][i], q[x][k - 1 - i]);\n                p[x][i] -= v, q[x][k - 1 - i] -= v;\n            &#125;\n        &#125;\n        else &#123;\n            // std::cerr &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n            int sum = 0ll, r = 0;\n            for (int i = k; ~i; --i) &#123;\n                sum += p[x][k - i];\n                // std::cerr &lt;&lt; sum &lt;&lt; &#39;\\n&#39;;\n                int v = std::min(sum, q[x][i]);\n                sum -= v, q[x][i] -= v;\n                r += q[x][i];\n            &#125;\n            res += (r + s - 1) / s;\n        &#125;\n        return;\n    &#125;;\n    DFS(1, -1);\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"c.-扫地机器人\">C. 扫地机器人</h2>\n<p><a href=\"https://www.becoder.com.cn/contest/6502/problem/3\" class=\"uri\">https://www.becoder.com.cn/contest/6502/problem/3</a></p>\n<blockquote>\n<p>题意：给定 <span class=\"math inline\">\\(n\\)</span> 堆货物，每堆货物有重量 <span class=\"math inline\">\\(v_i\\)</span> 和一个参数 <span class=\"math inline\">\\(a_i\\)</span>。有一个初始负载为 <span class=\"math inline\">\\(0\\)</span>、负载上限为 <span class=\"math inline\">\\(c\\)</span> 的机器人，从 <span class=\"math inline\">\\(1\\)</span> 到 <span class=\"math inline\">\\(n\\)</span> 遍历这些货物，对每一处货物执行以下操作，直到清空这堆货物：</p>\n<ul>\n<li>当前负载未满：可以选择进行装载直到达到负载上限，或货物清空。花费 <span class=\"math inline\">\\(a_i\\)</span> 的代价。</li>\n<li>不管当前负载满没满：可以选择清空当前负载，花费 <span class=\"math inline\">\\(b\\)</span> 的代价。</li>\n</ul>\n<p>每一处可以任意操作，要求遍历完之后机器人负载为 <span class=\"math inline\">\\(0\\)</span>，问最小代价。<span class=\"math inline\">\\(n\\le 2\\times 10^5,c\\le 10^9\\)</span>。</p>\n</blockquote>\n<p><em>题面是重构过的，原来的题面太有歧义了。绝大多数人没做出来就是因为没看懂题吧！</em></p>\n<p>考虑暴力，可以想到令 <span class=\"math inline\">\\(f_{i,j}\\)</span> 表示处理完 <span class=\"math inline\">\\(i\\)</span> 过后负载为 <span class=\"math inline\">\\(j\\)</span> 的最小代价（显然 <span class=\"math inline\">\\(f_{i,c}\\)</span> 和 <span class=\"math inline\">\\(f_{i,0}\\)</span> 是等效的，故舍弃前者）。记 <span class=\"math inline\">\\(k=\\left\\lceil\\dfrac {v_i}c\\right\\rceil,w=(v_i\\bmod c - 1)\\bmod c+1\\)</span>，那么有：</p>\n<p><span class=\"math display\">\\[\nf_{i,(j+v_i)\\bmod c}\\gets f_{i-1,j}+k\\cdot a_i+(k-1)\\cdot b +\n\\begin{cases}\nb&amp;j+w=c\\\\\na_i+b&amp;j+w&gt; c\\\\\n0&amp;\\text{otherwise}\n\\end{cases}\\\\\nf_{i,0}\\gets f_{i,j}+b\n\\]</span></p>\n<p>发现 <span class=\"math inline\">\\(f_{i-1}\\)</span> 和 <span class=\"math inline\">\\(f_i\\)</span> 之间是存在对应关系的，所以考虑直接继承（真实的 <span class=\"math inline\">\\(0\\)</span> 应该位于 <span class=\"math inline\">\\(-s_i\\)</span> 的位置），再做全局加、区间加，<span class=\"math inline\">\\(f_{i,0}\\)</span> 的转移是全局 min，线段树维护即可；每次只会新增一个状态，动态开点即可。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 5e6 + 5;\nconst __int128 inf = 1e18;\nstruct &#123;\n    int l, r;\n    __int128 u, d;\n&#125; t[maxn];\n#define lt t[p].l\n#define rt t[p].r\nint tot;\nvoid pushdown(int p) &#123;\n    if (t[p].d) &#123;\n        t[lt].d += t[p].d, t[lt].u += t[p].d;\n        t[rt].d += t[p].d, t[rt].u += t[p].d;\n        t[p].d = 0ll;\n    &#125;\n    return;\n&#125;\nvoid upd(int &amp;p, int l, int r, int x, __int128 v) &#123;\n    if (!p)\n        p = ++tot, t[p].u = v;\n    else\n        t[p].u = std::min(t[p].u, v);\n    if (l == r)\n        return;\n    pushdown(p);\n    int mid = (l + r) &gt;&gt; 1;\n    if (x &lt;= mid)\n        upd(lt, l, mid, x, v);\n    else\n        upd(rt, mid + 1, r, x, v);\n    return;\n&#125;\nvoid add(int p, int l, int r, int ql, int qr, __int128 v) &#123;\n    if (!p)\n        return;\n    if (ql &lt;= l &amp;&amp; r &lt;= qr) &#123;\n        t[p].d += v, t[p].u += v;\n        return;\n    &#125;\n    int mid = (l + r) &gt;&gt; 1;\n    pushdown(p);\n    if (ql &lt;= mid)\n        add(lt, l, mid, ql, qr, v);\n    if (qr &gt; mid)\n        add(rt, mid + 1, r, ql, qr, v);\n    t[p].u = std::min(t[lt].u, t[rt].u);\n    return;\n&#125;\n__int128 ask(int p, int l, int r, int x) &#123;\n    if (l == r)\n        return t[p].u;\n    int mid = (l + r) &gt;&gt; 1;\n    pushdown(p);\n    if (x &lt;= mid)\n        return ask(lt, l, mid, x);\n    return ask(rt, mid + 1, r, x);\n&#125;\n#undef lt\n#undef rt\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n    std::freopen(&quot;robot.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;robot.out&quot;, &quot;w&quot;, stdout);\n#else\n    std::freopen(&quot;ex_robot4.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    t[0].u = inf;\n    int n, b, c, p0 = 0, rt = 0;\n    std::cin &gt;&gt; n &gt;&gt; c &gt;&gt; b;\n    std::vector&lt;int&gt; a(n + 1), v(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i];\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; v[i];\n    upd(rt, 0, c - 1, 0, 0ll);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        __int128 k = (v[i] + c - 1) / c, w = (v[i] % c == 0 ? c : v[i] % c);\n        t[rt].d += k * a[i] + (k - 1) * b;\n        t[rt].u += k * a[i] + (k - 1) * b;\n        if (w &lt;= c)\n            add(rt, 0, c - 1, (c - w + p0) % c, (c - w + p0) % c, b);\n        if (w != 1) &#123;\n            int l = (c - w + p0 + 1) % c, r = (p0 + c - 1) % c;\n            if (l &lt;= r)\n                add(rt, 0, c - 1, l, r, a[i] + b);\n            else &#123;\n                add(rt, 0, c - 1, 0, r, a[i] + b);\n                add(rt, 0, c - 1, l, c - 1, a[i] + b);\n            &#125;\n        &#125;\n        p0 = (p0 + c - v[i] % c) % c;\n        upd(rt, 0, c - 1, p0, t[rt].u + b);\n    &#125;\n    std::cout &lt;&lt; (long long)ask(rt, 0, c - 1, p0) &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"d.-套娃\">D. 套娃</h2>\n<p><a href=\"https://www.becoder.com.cn/contest/6502/problem/4\" class=\"uri\">https://www.becoder.com.cn/contest/6502/problem/4</a></p>\n<blockquote>\n<p>题意：给定初始为全 <span class=\"math inline\">\\(0\\)</span> 的数组 <span class=\"math inline\">\\(a_{1\\sim n + 1}\\)</span> 和 <span class=\"math inline\">\\(n\\)</span> 次单点 +1 操作，每次操作后，求解：</p>\n<p>令 <span class=\"math inline\">\\(a\\)</span> 的前缀和数组为 <span class=\"math inline\">\\(s\\)</span>，找到一个最小的 <span class=\"math inline\">\\(k\\)</span>，使得对于每个 <span class=\"math inline\">\\(i\\)</span>，均有 <span class=\"math inline\">\\(k\\cdot i\\ge s_i\\)</span> 成立。</p>\n<p><span class=\"math inline\">\\(n\\le 10^6\\)</span>，时限 0.5s。</p>\n</blockquote>\n<details>\n<p><summary>趣事一则</summary></p>\n<p>考场上最后 10min 拿到题，憋了一个能拿到 96pts 的假做法：注意到前缀和是单增的，需要维护最大的 <span class=\"math inline\">\\(\\dfrac {s_i}i\\)</span>，由于后缀 +1 带来的影响很小，所以可以猜测在大多数情况下最大的 <span class=\"math inline\">\\(i\\)</span> 只会在原来的和修改的点之间变化。只用 10 行的核心代码就能拿到很多分。但是居然有这么多，可能出题人都没有想到真有人敢交这种做法吧。</p>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n    std::freopen(&quot;doll.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;doll.out&quot;, &quot;w&quot;, stdout);\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n    auto stime = std::chrono::steady_clock::now();\n    int n, res = 0;\n    std::cin &gt;&gt; n;\n    std::vector&lt;int&gt; bit(n + 2);\n    auto lowbit = [](int x) &#123;\n        return x &amp; -x;\n    &#125;;\n    auto add = [&amp;](int x) &#123;\n        for (; x &lt;= n + 1; x += lowbit(x))\n            ++bit[x];\n        return;\n    &#125;;\n    auto ask = [&amp;](int x) &#123;\n        int res = 0;\n        for (; x; x -= lowbit(x))\n            res += bit[x];\n        return res;\n    &#125;;\n    int p = 1;\n    for (int i = 1, x; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; x, add(++x);\n        long long s = ask(x), t = ask(p);\n        if (s * p == t * x ? x &gt; p : s * p &gt; t * x)\n            p = x;\n        else\n            s = t;\n        if (s &gt; p * res)\n            ++res;\n        std::cout &lt;&lt; res &lt;&lt; &#39; &#39;;\n    &#125;\n    std::cout &lt;&lt; &#39;\\n&#39;;\n    std::cerr &lt;&lt; std::chrono::duration&lt;double&gt;(std::chrono::steady_clock::now() - stime).count() &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<p>很容易写出暴力，观察样例就能发现每次修改后答案最多增加 <span class=\"math inline\">\\(1\\)</span>。记当前答案为 <span class=\"math inline\">\\(res\\)</span>，线段树维护 <span class=\"math inline\">\\(s_i-res\\cdot i\\)</span> 的最小值，若其为负则 res++，然后重构线段树（等差数列和 min 不兼容）。</p>\n<p>怎么又有不等式 😱</p>\n<p>目的是在本来合法的范围里找到新的不合法值。考虑合法范围：<span class=\"math inline\">\\(s_i-res\\cdot i\\ge 0\\)</span>，解一下得到 <span class=\"math inline\">\\(i\\le \\dfrac {s_i}{res}\\)</span>，放缩得到 <span class=\"math inline\">\\(i\\le\\dfrac {n}{res}\\)</span>，每次 <span class=\"math inline\">\\(res\\)</span> 变化时只重构 <span class=\"math inline\">\\(\\dfrac {n}{res}\\)</span> 以前的位置，重构的总长是 <span class=\"math inline\">\\(O(n\\ln n)\\)</span> 的。（线段树建树是线性的）</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 1e6 + 5;\nconst int inf = 0x3f3f3f3f;\nstruct &#123;\n    int l, r, u, d;\n&#125; t[maxn &lt;&lt; 2];\n#define lt (p &lt;&lt; 1)\n#define rt (lt | 1)\nvoid bld(int p, int l, int r) &#123;\n    t[p].u = t[p].l = l, t[p].r = r;\n    if (l == r)\n        return;\n    int mid = (l + r) &gt;&gt; 1;\n    bld(lt, l, mid), bld(rt, mid + 1, r);\n    return;\n&#125;\nvoid pushdown(int p) &#123;\n    if (t[p].d) &#123;\n        t[lt].d += t[p].d, t[rt].d += t[p].d;\n        t[lt].u -= t[p].d, t[rt].u -= t[p].d;\n        t[p].d = 0;\n    &#125;\n    return;\n&#125;\nvoid add(int p, int x) &#123;\n    if (x &lt;= t[p].l) &#123;\n        ++t[p].d, --t[p].u;\n        return;\n    &#125;\n    pushdown(p);\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (x &lt;= mid)\n        add(lt, x);\n    add(rt, x);\n    t[p].u = std::min(t[lt].u, t[rt].u);\n    // printf(&quot;[%d, %d]: %d, [%d, %d]: %d\\n&quot;, t[p].l, mid, t[lt].u, mid + 1, t[p].r, t[rt].u);\n    return;\n&#125;\nvoid rem(int p, int r) &#123;\n    if (t[p].l == t[p].r) &#123;\n        t[p].u += t[p].l;\n        return;\n    &#125;\n    pushdown(p);\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (r &lt;= mid)\n        rem(lt, r), t[rt].u = inf;\n    else\n        rem(lt, r), rem(rt, r);\n    t[p].u = std::min(t[lt].u, t[rt].u);\n    return;\n&#125;\n#undef lt\n#undef rt\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n    std::freopen(&quot;doll.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;doll.out&quot;, &quot;w&quot;, stdout);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    bld(1, 1, n + 1);\n    for (int i = 1, x, res = 1, now = n; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; x;\n        if (x &lt;= now)\n            add(1, ++x);\n        if (t[1].u &lt; 0) &#123;\n            std::cout &lt;&lt; ++res &lt;&lt; &#39; &#39;;\n            rem(1, now = n / res);\n        &#125;\n        else\n            std::cout &lt;&lt; res &lt;&lt; &#39; &#39;;\n        // puts(&quot;&quot;);\n    &#125;\n    std::cout &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"e---subarray-sum-divisibility\">E - Subarray Sum Divisibility</h2>\n<p><a href=\"https://atcoder.jp/contests/abc419/tasks/abc419_e\" class=\"uri\">https://atcoder.jp/contests/abc419/tasks/abc419_e</a></p>\n<p>模意义下的数列全等，可以对应原数组全等、差分全等、前缀和全等（都是模意义下的，还有其他的一些线性和非线性的变换也可以）</p>\n<p>本着修改的点尽量少的想法，如果题目给定单点修改就可以在原数组上做文章，给定区间修改可以考虑差分数组，前缀和对于一些区间查询有优势</p>\n<p>其他两种用得也很多，像这题只需要用原数组全等就可以做了</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int inf = 0x3f3f3f3f;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, m, l;\n    std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; l;\n    std::vector&lt;int&gt; a(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i];\n    std::vector&lt;std::vector&lt;int&gt; &gt; u(l + 1, std::vector&lt;int&gt; (m));\n    for (int i = 1; i &lt;= l; ++i)\n        for (int j = 0; j &lt; m; ++j)\n            for (int k = i; k &lt;= n; k += l)\n                u[i][j] += (j + m - a[k]) % m;\n    std::vector&lt;std::vector&lt;int&gt; &gt; f(l + 1, std::vector&lt;int&gt; (m, inf));\n    f[0][0] = 0;\n    for (int i = 1; i &lt;= l; ++i)\n        for (int j = 0; j &lt; m; ++j)\n            for (int k = 0; k &lt; m; ++k)\n                f[i][(j + k) % m] = std::min(f[i][(j + k) % m], f[i - 1][j] + u[i][k]);\n    std::cout &lt;&lt; f[l][0] &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;\n</code></pre>\n</details>\n<hr />\n<h2 id=\"f---all-included\">F - All Included</h2>\n<p><a href=\"https://atcoder.jp/contests/abc419/tasks/abc419_f\" class=\"uri\">https://atcoder.jp/contests/abc419/tasks/abc419_f</a></p>\n<p>原题意转化为在 AC 自动机上走 <span class=\"math inline\">\\(L\\)</span> 步，要求经过 <span class=\"math inline\">\\(n\\)</span> 个叶子的方案数。不太可做，转化成容斥（令字符串终点不可达）。在外层枚举步数暴力游走。</p>\n<p>要求恰好走 <span class=\"math inline\">\\(L\\)</span> 步，也可以用矩阵；但原图很稀疏，所以矩阵并没有优势。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 998244353;\nint tot = 1, T[805][26], fail[805];\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, l;\n    std::cin &gt;&gt; n &gt;&gt; l;\n    std::vector&lt;std::string&gt; a;\n    &#123;\n        std::vector&lt;std::string&gt; s(n + 1);\n        for (int i = 1; i &lt;= n; ++i)\n            std::cin &gt;&gt; s[i];\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            bool flag = 1;\n            for (int j = 1; j &lt;= n; ++j)\n                if (j != i)\n                    if (s[j].find(s[i]) != std::string::npos) &#123;\n                        flag = 0;\n                        break;\n                    &#125;\n            if (flag)\n                a.push_back(s[i]);\n        &#125;\n        n = (int)a.size();\n    &#125;\n    std::vector&lt;int&gt; pos(n);\n    for (int i = 0; i &lt; n; ++i) &#123;\n        int &amp;p = pos[i];\n        for (auto j : a[i]) &#123;\n            if (!T[p][j - &#39;a&#39;])\n                T[p][j - &#39;a&#39;] = tot++;\n            p = T[p][j - &#39;a&#39;];\n        &#125;\n    &#125;\n    &#123;\n        std::queue&lt;int&gt; q;\n        for (int i = 0; i &lt; 26; ++i)\n            if (T[0][i])\n                q.push(T[0][i]);\n        for (; !q.empty(); ) &#123;\n            int u = q.front();\n            q.pop();\n            for (int i = 0; i &lt; 26; ++i)\n                if (T[u][i]) &#123;\n                    int v = T[u][i];\n                    fail[v] = T[fail[u]][i];\n                    q.push(v);\n                &#125;\n                else\n                    T[u][i] = T[fail[u]][i];\n        &#125;\n    &#125;\n    auto res = 0ll;\n    int siz = 1 &lt;&lt; n;\n    for (int i = 0; i &lt; siz; ++i) &#123;\n        std::vector&lt;int&gt; tag(tot);\n        for (int j = 0; j &lt; n; ++j)\n            if ((i &gt;&gt; j) &amp; 1)\n                tag[pos[j]] = 1;\n        std::vector&lt;std::vector&lt;long long&gt; &gt; f(l + 1, std::vector&lt;long long&gt; (tot));\n        f[0][0] = 1ll;\n        for (int j = 0; j &lt; l; ++j)\n            for (int k = 0; k &lt; tot; ++k)\n                for (int a = 0; a &lt; 26; ++a) &#123;\n                    if (!tag[T[k][a]])\n                        (f[j + 1][T[k][a]] += f[j][k]) %= mod;\n                &#125;\n        int k = (__builtin_popcount(i) &amp; 1 ? mod - 1 : 1);\n        auto s = 0ll;\n        for (int j = 0; j &lt; tot; ++j)\n            if (!tag[j])\n                (s += f[l][j]) %= mod;\n        (res += k * s) %= mod;\n    &#125;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"g---count-simple-paths-2\">G - Count Simple Paths 2</h2>\n<p><a href=\"https://atcoder.jp/contests/abc419/tasks/abc419_g\" class=\"uri\">https://atcoder.jp/contests/abc419/tasks/abc419_g</a></p>\n<p>很新的性质。考虑『以 <span class=\"math inline\">\\(1\\)</span> 为起点的简单路径数』和反祖边数量的关系：选定一条反祖边必须被经过时（显然只有一种可能的经过方向），树的形态发生变化：</p>\n<p><img src=\"image.png\" /></p>\n<p>也就是说，一种反祖边的选取方案对应一种树，遍历其从 <span class=\"math inline\">\\(1\\)</span> 开始的简单路径复杂度为 <span class=\"math inline\">\\(O(n)\\)</span>。设反祖边数量为 <span class=\"math inline\">\\(k\\)</span>，那么合法的方案数不超过 <span class=\"math inline\">\\(2^k\\)</span>，暴力 DFS 的整个图复杂度为 <span class=\"math inline\">\\(O(2^k\\cdot n)\\)</span>。</p>\n<p>发现很多跟反祖边无关的遍历是不必要的（只有一种走法，可以设成边权），考虑对所有连接反祖边的点建立虚树，并把原树上的反祖边也移到虚树上，就能 <span class=\"math inline\">\\(O(2^k\\cdot k)\\)</span> 解决问题。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, m;\n    std::cin &gt;&gt; n &gt;&gt; m;\n    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1), g1(n + 1);\n    std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; g2(n + 1);\n    for (int x, y; m--; ) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y;\n        g[x].push_back(y), g[y].push_back(x);\n    &#125;\n    std::vector&lt;int&gt; tag(n + 1), vis(n + 1);\n    std::vector&lt;std::pair&lt;int, int&gt; &gt; be;\n    std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int fa) &#123;\n        static int now = 0;\n        tag[x] = 1, vis[x] = ++now;\n        for (auto i : g[x])\n            if (!tag[i]) &#123;\n                // fprintf(stderr, &quot;%d -&gt; %d\\n&quot;, x, i);\n                g1[x].push_back(i), DFS(i, x);\n            &#125;\n            else if (i != fa &amp;&amp; vis[i] &lt; vis[x])\n                be.emplace_back(i, x);\n        return;\n    &#125;;\n    DFS(1, -1);\n    &#123; // 求虚树\n        std::vector&lt;int&gt; dep(n + 1), fa(n + 1), top(n + 1), siz(n + 1), son(n + 1), dfn(n + 1), rfn(n + 1);\n        std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;\n            siz[x] = 1;\n            for (auto i : g1[x]) &#123;\n                dep[i] = dep[x] + 1;\n                fa[i] = x, DFS(i);\n                siz[x] += siz[i];\n                if (siz[i] &gt; siz[son[x]])\n                    son[x] = i;\n            &#125;\n            return;\n        &#125;;\n        DFS(1);\n        DFS = [&amp;](int x) &#123;\n            static int now = 0;\n            dfn[x] = ++now;\n            if (son[x])\n                top[son[x]] = top[x], DFS(son[x]);\n            for (auto i : g1[x])\n                if (i != son[x])\n                    top[i] = i, DFS(i);\n            rfn[x] = now;\n            // printf(&quot;%d: [%d, %d]\\n&quot;, x, dfn[x], rfn[x]);\n            return;\n        &#125;;\n        top[1] = 1, DFS(1);\n        auto getLCA = [&amp;](int x, int y) &#123;\n            for (; top[x] != top[y]; x = fa[top[x]])\n                if (dep[top[x]] &lt; dep[top[y]])\n                    std::swap(x, y);\n            return dep[x] &lt; dep[y] ? x : y;\n        &#125;;\n        tag.assign(n + 1, 0);\n        tag[1] = tag[n] = 1;\n        for (auto [u, v] : be)\n            tag[u] = 1, tag[v] = 1;\n        std::vector&lt;int&gt; p;\n        for (int i = 1; i &lt;= n; ++i)\n            if (tag[i])\n                p.push_back(i);\n        std::sort(p.begin(), p.end(), [&amp;](int i, int j) &#123; return dfn[i] &lt; dfn[j]; &#125;);\n        for (int i = 1; i &lt; (int)p.size(); ++i) &#123;\n            int fa = getLCA(p[i], p[i - 1]);\n            if (!tag[fa])\n                tag[fa] = 1;\n        &#125;\n        p.clear();\n        for (int i = 1; i &lt;= n; ++i)\n            if (tag[i])\n                p.push_back(i);\n        std::sort(p.begin(), p.end(), [&amp;](int i, int j) &#123; return dfn[i] &lt; dfn[j]; &#125;);\n        std::vector&lt;int&gt; st;\n        for (auto i : p) &#123;\n            if (st.empty())\n                st.push_back(i);\n            else &#123;\n                for (; rfn[st.back()] &lt; dfn[i]; st.pop_back());\n                g2[st.back()].emplace_back(i, dep[i] - dep[st.back()]);\n                g2[i].emplace_back(st.back(), dep[i] - dep[st.back()]);\n                // printf(&quot;add (%d, %d): %d\\n&quot;, st.back(), i, dep[i] - dep[st.back()]);\n                st.push_back(i);\n            &#125;\n        &#125;\n        for (auto [u, v] : be) &#123;\n            g2[u].emplace_back(v, 1), g2[v].emplace_back(u, 1);\n            // printf(&quot;# add(%d, %d): 1\\n&quot;, u, v);\n        &#125;\n    &#125;\n    tag.assign(n + 1, 0);\n    std::vector&lt;int&gt; res(n + 1);\n    DFS = [&amp;](int x, int s) &#123;\n        if (x == n)\n            ++res[s];\n        tag[x] = 1;\n        for (auto [i, w] : g2[x])\n            if (!tag[i])\n                DFS(i, s + w);\n        tag[x] = 0;\n        return;\n    &#125;;\n    DFS(1, 0);\n    for (int i = 1; i &lt; n; ++i)\n        std::cout &lt;&lt; res[i] &lt;&lt; &#39; &#39;;\n    std::cout &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n",
            "tags": [
                "线段树",
                "AC 自动机",
                "贪心",
                "DP 优化",
                "虚树"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20250709/",
            "url": "https://xsc062.netlify.app/20250709/",
            "title": "练习 - DP 凸优化",
            "date_published": "2025-07-09T13:59:41.000Z",
            "content_html": "<p>Stewart’s theorem：在线段 <span class=\"math inline\">\\(AB\\)</span> 上取一点 <span class=\"math inline\">\\(M\\)</span>，使得 <span class=\"math inline\">\\(\\vec{AB}=\\lambda \\vec{AM}\\)</span>。在 <span class=\"math inline\">\\(AB\\)</span> 上方任取一点 <span class=\"math inline\">\\(P\\)</span>，则有 <span class=\"math inline\">\\(PM^2=(1-\\lambda) PA^2+\\lambda PB^2-\\lambda(1-\\lambda) AB^2\\)</span>。</p>\n<span id=\"more\"></span>\n<hr />\n<h2 id=\"d.-akvizna\">D. Akvizna</h2>\n<p><a href=\"https://www.becoder.com.cn/contest/6393/problem/4\" class=\"uri\">https://www.becoder.com.cn/contest/6393/problem/4</a></p>\n<p>其实到这里应该发现了，WQS 的奖励都以一次项系数出现，原因也很显然，奖励的对象是一次项系数嘛。此外，WQS 内层 DP 数组的维度都应和操作次数无关，而 DP 值应为最大收益。这个也很显然。</p>\n<p>令一轮比赛的惩罚是 <span class=\"math inline\">\\(mid\\)</span> 然后二分。令 <span class=\"math inline\">\\(f_{j}\\)</span> 表示剩余人数为 <span class=\"math inline\">\\(j\\)</span> 时的最大收益，那么有 <span class=\"math inline\">\\(f_{j}=\\max\\limits_{k\\ge j}\\left\\{f_k+\\frac {k-j}k\\right\\}-mid\\)</span>。最后在 <span class=\"math inline\">\\(f_0\\)</span> 处找答案即可。</p>\n<p>然后就发现一个很可怕的问题，内层 DP 咋写。发现把 <span class=\"math inline\">\\(\\frac {k-j}k\\)</span> 改写成 <span class=\"math inline\">\\(1-\\frac jk\\)</span> 后出现交叉项，考虑斜优。令 <span class=\"math inline\">\\(a&lt;b\\)</span>，那么 <span class=\"math inline\">\\(a\\)</span> 优于 <span class=\"math inline\">\\(b\\)</span> 当且仅当 <span class=\"math inline\">\\(\\dfrac {f_a-f_b}{\\frac 1a - \\frac 1b} &gt; j\\)</span>。维护单减的斜率即可。</p>\n<details>\n<p>笑话：二分 50 次不够，需要 60 次。</p>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, k;\n    std::cin &gt;&gt; n &gt;&gt; k;\n    double l = 0., r = 1e5, mid;\n    auto calc = [&amp;](double mid) &#123;\n        std::vector&lt;double&gt; f(n + 1, -1e18);\n        f[n] = 0.;\n        int h = 1, t = 0;\n        std::vector&lt;int&gt; q(n + 1), p(n + 1);\n        q[++t] = n;\n        // printf(&quot;mid = %.3lf: \\n&quot;, mid);\n        for (int i = n - 1; ~i; --i) &#123;\n            for (; h &lt; t &amp;&amp; (f[q[h + 1]] - f[q[h]]) / (1. / q[h + 1] - 1. / q[h]) &gt;= i; ++h);\n            f[i] = f[q[h]] + 1. - i * 1.0 / q[h] - mid, p[i] = p[q[h]] + 1;\n            // printf(&quot;  %d: f = %.3lf, p = %d, q[h] = %d(%.3lf / %d)\\n&quot;, i, f[i], p[i], q[h], f[q[h]], p[q[h]]);\n            if (i) &#123;\n                for (; h &lt; t &amp;&amp; (f[i] - f[q[t]]) / (1. / i - 1. / q[t]) &gt;= (f[q[t]] - f[q[t - 1]]) / (1. / q[t] - 1. / q[t - 1]); --t);\n                q[++t] = i;\n            &#125;\n        &#125;\n        // printf(&quot;res = %.3lf\\n&quot;, f[0] + p[0] * mid);\n        return std::make_pair(f[0], p[0]);\n    &#125;;\n    // calc(0.);\n    // return 0;\n    double res(0.);\n    for (int i = 1; i &lt;= 60; ++i) &#123;\n        mid = (l + r) / 2.;\n        auto t(calc(mid));\n        if (t.second &gt;= k)\n            l = mid, res = t.first + k * mid;\n        else\n            r = mid;\n    &#125;\n    std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(8) &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"e.-poborcy-podatkowi\">E. Poborcy podatkowi</h2>\n<p><a href=\"https://www.becoder.com.cn/contest/6393/problem/5\" class=\"uri\">https://www.becoder.com.cn/contest/6393/problem/5</a></p>\n<p>首先令 <span class=\"math inline\">\\(f_{u,l}(i),l=0,1,2,3\\)</span> 表示在 <span class=\"math inline\">\\(u\\)</span> 上挂了长度为 <span class=\"math inline\">\\(l\\)</span> 的半条链，共有 <span class=\"math inline\">\\(i\\)</span> 条整链的最大收益。</p>\n<p>可以观察到是凸的。那么不难发现需要闵可夫斯基和，考虑 <span class=\"math inline\">\\(u\\)</span> 位置上的合并。<strong>首先需要注意到儿子上长度为 <span class=\"math inline\">\\(l\\)</span> 的链到父亲上会变成 <span class=\"math inline\">\\(l+1\\)</span></strong>。显然每条可以不选；如果选了 <span class=\"math inline\">\\(cnt_a\\)</span> 条长度为 <span class=\"math inline\">\\(a\\)</span> 的半链，那么合并出来的结果是 <span class=\"math inline\">\\(cnt_1-cnt_3\\)</span> 条长度为 <span class=\"math inline\">\\(1\\)</span> 或 <span class=\"math inline\">\\(3\\)</span> 的链、<span class=\"math inline\">\\(cnt_2\\bmod 2\\)</span> 条长度为 <span class=\"math inline\">\\(2\\)</span> 的链，并且要求两者不同时出现。发现这个东西基本上处理不了。</p>\n<p>接着注意到这个形式有点像背包。但怎么处理 <span class=\"math inline\">\\(cnt_1\\)</span> 和 <span class=\"math inline\">\\(cnt_3\\)</span> 配对的这个要求呢？有个非常精妙的在物品体积上做文章的方法：</p>\n<p>首先注意到我们最后的查询的答案肯定要求把所有儿子用完。那么不妨设体积之和为儿子总数 <span class=\"math inline\">\\(tot\\)</span>。接着，对 <span class=\"math inline\">\\(cnt_0\\)</span>（同时也是 <span class=\"math inline\">\\(cnt_4\\)</span>）没有限制，直接令其体积为 <span class=\"math inline\">\\(1\\)</span>。<span class=\"math inline\">\\(cnt_2\\)</span> 单独处理（等会儿会说），为了不对现在的问题产生影响也令其体积为 <span class=\"math inline\">\\(1\\)</span>。对于 <span class=\"math inline\">\\(cnt_1\\)</span> 和 <span class=\"math inline\">\\(cnt_3\\)</span>，显然两者平均体积需要为 <span class=\"math inline\">\\(1\\)</span>；你可以令 <span class=\"math inline\">\\(cnt_3\\)</span> 体积为 <span class=\"math inline\">\\(2\\)</span>，令 <span class=\"math inline\">\\(cnt_1\\)</span> 体积为 <span class=\"math inline\">\\(0\\)</span>。</p>\n<p>接下来就有个很好的性质：<span class=\"math inline\">\\(cnt_1\\)</span> 必须和 <span class=\"math inline\">\\(cnt_3\\)</span> 配对才能让平均体积为 <span class=\"math inline\">\\(1\\)</span>。在 <span class=\"math inline\">\\(tot\\)</span> 处查找的答案，由 <span class=\"math inline\">\\(x\\)</span> 个体积不为 <span class=\"math inline\">\\(0\\)</span> 的物品和 <span class=\"math inline\">\\(tot-x\\)</span> 个体积为 <span class=\"math inline\">\\(0\\)</span> 的物品（<span class=\"math inline\">\\(cnt_1\\)</span>）组成，原因是背包会贪心地在所有『剩余』的分组中选择体积为 <span class=\"math inline\">\\(0\\)</span> 的一项。再计算一下 <span class=\"math inline\">\\(cnt_3\\)</span>，发现显然为 <span class=\"math inline\">\\(tot-x\\)</span>。符合目的。</p>\n<p>在 <span class=\"math inline\">\\(dp_{tot}\\)</span> 处查找可以找到 <span class=\"math inline\">\\(cnt_1=cnt_3\\)</span> 时的答案；同理，在 <span class=\"math inline\">\\(dp_{tot-1},dp_{tot1+1}\\)</span> 处可以查找到 <span class=\"math inline\">\\(cnt_1=cnt_3\\pm 1\\)</span> 的答案。</p>\n<p>接下来再考虑 <span class=\"math inline\">\\(cnt_2\\)</span>，解决『<span class=\"math inline\">\\(cnt\\bmod2=1\\)</span> 和 <span class=\"math inline\">\\(cnt_1\\ne cnt_3\\)</span> 不能同时成立』的限制。那太好了，直接多开一维记录 <span class=\"math inline\">\\(cnt_2\\bmod 2\\)</span> 即可。</p>\n<p>啊啊太妙了。像利用体积为 <span class=\"math inline\">\\(-1,1\\)</span> 的随机数据背包期望最大体积不超过 <span class=\"math inline\">\\(\\sqrt V\\)</span> 的那个方法，显然就没有办法利用凸性了。所以这或许是闵可夫斯基和做法的唯一解？</p>\n<p>需要知道，如果设 <span class=\"math inline\">\\(cnt_1\\)</span> 为 <span class=\"math inline\">\\(2\\)</span> 而 <span class=\"math inline\">\\(cnt_3\\)</span> 为 <span class=\"math inline\">\\(0\\)</span>，始终会出一些问题。这个我和 yly 讨论了一下没啥结果。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst long long inf = 1e12;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;1.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; g(n + 1);\n    for (int i = 1, x, y, w; i &lt; n; ++i) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y &gt;&gt; w;\n        g[x].emplace_back(y, w), g[y].emplace_back(x, w);\n    &#125;\n    using arr = std::vector&lt;long long&gt;;\n    std::vector&lt;arr&gt; f(n + 1, arr(4));\n    struct node &#123;\n        std::vector&lt;arr&gt; f;\n        node(): f(2) &#123;&#125;\n        node(std::vector&lt;arr&gt; f1): f(f1) &#123;&#125;\n        arr&amp; operator[](int q) &#123;\n            return f[q];\n        &#125;\n    &#125;;\n    auto getmax = [&amp;](arr p, arr q) &#123;\n        arr res(p);\n        if (q.size() &gt; p.size())\n            res.resize(q.size());\n        for (int i = 0; i &lt; (int)q.size(); ++i)\n            res[i] = std::max(res[i], q[i]);\n        return res;\n    &#125;;\n    auto merge = [&amp;](arr &amp;p, arr &amp;q) &#123;\n        arr res(p.size() + q.size() - 1), dp(p.size()), dq(q.size());\n        std::adjacent_difference(p.begin(), p.end(), dp.begin());\n        std::adjacent_difference(q.begin(), q.end(), dq.begin());\n        std::merge(dp.begin() + 1, dp.end(), dq.begin() + 1, dq.end(), res.begin() + 1, std::greater&lt;long long&gt; ());\n        res[0] = p[0] + q[0];\n        std::partial_sum(res.begin(), res.end(), res.begin());\n        return res;\n    &#125;; \n    std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int fa) &#123;\n        if ((int)g[x].size() == 1 &amp;&amp; x != 1) &#123;\n            f[x][1] = f[x][2] = f[x][3] = -inf;\n            return;\n        &#125;\n        int tot = (int)g[x].size() - (x != 1);\n        std::vector&lt;arr&gt; w1(1), w2(1);\n        for (auto [i, w] : g[x])\n            if (i != fa) &#123;\n                DFS(i, x);\n                w1.push_back(&#123; f[i][0] + w, std::max(f[i][0], f[i][3] + w), f[i][2] + w &#125;);\n                w2.push_back(&#123; -inf, f[i][1] + w &#125;);\n            &#125;\n        auto fun = [&amp;](arr &amp;p, arr &amp;q) &#123;\n            arr res(p.size() + q.size() - 1, -inf);\n            for (int ip = 0; ip &lt; 2; ++ip)\n                for (int iq = 0; iq &lt; 2; ++iq) &#123;\n                    arr tp, tq;\n                    for (int i = ip; i &lt; (int)p.size(); i += 2)\n                        tp.push_back(p[i]);\n                    for (int i = iq; i &lt; (int)q.size(); i += 2)\n                        tq.push_back(q[i]);\n                    auto t = merge(tp, tq);\n                    for (int i = 0; i &lt; (int)t.size(); ++i)\n                        if (i * 2 + ip + iq &lt; (int)res.size())\n                            res[i * 2 + ip + iq] = std::max(res[i * 2 + ip + iq], t[i]);\n                &#125;\n            return res;\n        &#125;; \n        std::function&lt;node(int, int)&gt; calc = [&amp;](int l, int r) &#123;\n            if (l == r)\n                return node(&#123; w1[l], w2[l] &#125;);\n            int mid = (l + r) &gt;&gt; 1;\n            node t1(calc(l, mid)), t2(calc(mid + 1, r));\n            return node(&#123; getmax(fun(t1[0], t2[0]), fun(t1[1], t2[1])),\n                          getmax(fun(t1[0], t2[1]), fun(t1[1], t2[0])) &#125;);\n        &#125;;\n        auto t(calc(1, tot));\n        f[x][0] = t[0][tot], f[x][1] = t[0][tot - 1], f[x][2] = t[1][tot], f[x][3] = t[0][tot + 1];\n        return;\n    &#125;;\n    DFS(1, -1);\n    std::cout &lt;&lt; f[1][0] &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n",
            "tags": [
                "DP",
                "DP 优化"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20250707-1/",
            "url": "https://xsc062.netlify.app/20250707-1/",
            "title": "决策单调性",
            "date_published": "2025-07-07T13:23:01.000Z",
            "content_html": "<p>等和线：在线段 <span class=\"math inline\">\\(AB\\)</span> 上取一点 <span class=\"math inline\">\\(M\\)</span>，使得 <span class=\"math inline\">\\(\\vec{AB}=\\lambda \\vec{AM}\\)</span>。在 <span class=\"math inline\">\\(AB\\)</span> 上方任取一点 <span class=\"math inline\">\\(P\\)</span>，则有 <span class=\"math inline\">\\(\\vec{PM}=(1-\\lambda) \\vec{PA}+\\lambda \\vec{PB}\\)</span>。</p>\n<span id=\"more\"></span>\n<hr />\n<h2 id=\"什么是-xdyd-dp\">什么是 xD/yD DP</h2>\n<p>即 DP 数组共有 <span class=\"math inline\">\\(x\\)</span> 维，一次转移复杂度为 <span class=\"math inline\">\\(O(n^y)\\)</span>。</p>\n<p><del>为什么要给一句话单开一个标题</del></p>\n<p>下面设通式 <span class=\"math inline\">\\(f_i=\\max\\left\\{f_j+w(i,j)\\right\\}\\)</span>。</p>\n<hr />\n<h2 id=\"单调队列优化-dp\">单调队列优化 DP</h2>\n<p><span class=\"math inline\">\\(w(i,j)\\)</span> 仅包含 <span class=\"math inline\">\\(i,j\\)</span> 的最高一次项。</p>\n<ul>\n<li>如果要求 <span class=\"math inline\">\\(j\\in [1,i]\\)</span>，前缀最小值即可。</li>\n<li>若 <span class=\"math inline\">\\(j\\)</span> 的取值范围在到处乱动，可以写 DS =_=</li>\n<li><p>若 <span class=\"math inline\">\\(j\\)</span> 的取值范围 <span class=\"math inline\">\\([l,r]\\)</span> 随着 <span class=\"math inline\">\\(i\\)</span> 增大而 <span class=\"math inline\">\\(l,r\\)</span> 都不减小，那么可以使用单调队列。</p>\n<p>顺带一提，和这种的单调队列用法相似的『单调栈』主要在斜优里出现。</p></li>\n</ul>\n<p>具体过程被 grizzly bear 吃掉了 <img src=\"/em/eat.gif\" /></p>\n<h3 id=\"例单调队列优化多重背包\">例：单调队列优化多重背包</h3>\n<p>朴素的多重背包式子是 <span class=\"math inline\">\\(f_{i,j}=\\max\\left\\{f_{i-1,j-k\\times v_i}+k\\times w_i\\right\\}\\)</span>，因为 <span class=\"math inline\">\\(i\\)</span> 和整个式子无关，所以是关于 <span class=\"math inline\">\\(j\\)</span> 的 1D/1D。</p>\n<p>为了套用单调队列，需要把查询的项变成连续的。发现 <span class=\"math inline\">\\(j-k\\times v_i\\)</span> 和 <span class=\"math inline\">\\(j\\)</span> 关于 <span class=\"math inline\">\\(v_i\\)</span> 同余；且随着 <span class=\"math inline\">\\(k\\)</span> 的增大，查询的位置不断移动 <span class=\"math inline\">\\(v_i\\)</span>。那么不妨把所有 <span class=\"math inline\">\\(j\\)</span> 按照模 <span class=\"math inline\">\\(v_i\\)</span> 的余数分开做。具体地，不妨设 <span class=\"math inline\">\\(j=a\\times v_i+b\\)</span>，将 <span class=\"math inline\">\\(j-k\\times v_i\\)</span> 替换为余数写法，那么有：</p>\n<p><span class=\"math display\">\\[\n\\begin{aligned}\nf_{i,j}&amp;=\\max\\{f_{i-1,x\\times v_i+b}+(a-x)\\times v_i\\}\\\\\n&amp;=\\max\\{f_{i-1,x\\times v_i+b}-x\\times v_i\\}+a\\times v_i\n\\end{aligned}\n\\]</span></p>\n<p>限制 <span class=\"math inline\">\\((a-x)\\)</span> 的取值不超过物品数，在不同模数下按 <span class=\"math inline\">\\(x\\)</span> 从小到大将 <span class=\"math inline\">\\(j\\)</span> 这一维进行单调队列优化即可。容易发现会不重不漏枚举所有体积；复杂度 <span class=\"math inline\">\\(O(nV)\\)</span>。</p>\n<hr />\n<h2 id=\"斜率优化-dp\">斜率优化 DP</h2>\n<p>若 <span class=\"math inline\">\\(w(i,j)\\)</span> 种含有 <span class=\"math inline\">\\(i,j\\)</span> 的交叉项，可以考虑斜优。</p>\n<p>具体过程，（如果你愿意），可以看这篇 <a href=\"/20210214/\">四年半前的博客</a>。</p>\n<p>关于符号等问题，分享一下我的做法：</p>\n<ul>\n<li><p>单调队列维护：适用于符号和右侧斜率要求单调性相反的情况。</p>\n<ul>\n<li>首先，讨论队头维护。不妨假设 <span class=\"math inline\">\\(a\\)</span> 为队头第二个元素，<span class=\"math inline\">\\(b\\)</span> 为队头第一个元素。</li>\n<li>如果队头 <span class=\"math inline\">\\(b\\)</span> 需要被弹出，说明 <span class=\"math inline\">\\(a\\)</span> 优于 <span class=\"math inline\">\\(b\\)</span>；假设式子要求 max，则用 <span class=\"math inline\">\\(a\\)</span> 转移得到的答案 &gt; 用 <span class=\"math inline\">\\(b\\)</span> 转移得到的答案。</li>\n<li>化式子，注意 <span class=\"math inline\">\\(a&gt;b\\)</span>；且负数乘除要变号。</li>\n<li><p>最后得到的式子中间的不等号就决定了需要维护的斜率单调情况。以此决定队尾维护方式即可。</p>\n<strong>注意这个式子的不等号体现的是弹出条件；保留条件和其相反</strong> <img src=\"/em/ll.gif\" /></li>\n</ul></li>\n<li><p>单调栈维护：适用于符号和右侧斜率要求单调性相同的情况；需要清楚，维护合法性、维护单调和取答案都在栈顶进行。</p>\n<ul>\n<li>首先，都知道要用单调栈了，说明斜优形式已经被化出来了；以此维护合法性即可。</li>\n<li>维护一个从底到顶，『优』得越来越小的斜率序列。找到从更优到更劣的临界点，更新答案。</li>\n</ul></li>\n</ul>\n<p>啊，果然高中文化学科是非常有用的。算是明白为什么我小学 / 初中基本没弄懂过斜优，而旁边的大佬已经在乱杀了 <img src=\"/em/hsh.gif\" /></p>\n<hr />\n<p>现在假设正在维护一个上凸包，可以进行一些思考：</p>\n<ul>\n<li><p>如果查询区间不单增？</p>\n搞不了啊这个。废了。</li>\n<li><p>查询的斜率不单增？</p>\n写个二分 + 单调栈。参见 <a href=\"https://www.luogu.com.cn/problem/P5785\">任务安排</a>、<a href=\"#例traka\">TRAKA</a>。</li>\n<li><p>加入斜率的位置不单增？</p>\n<p>李超 / CDQ / 平衡树。</p></li>\n</ul>\n<hr />\n<h2 id=\"四边形不等式优化-dp\">四边形不等式优化 DP</h2>\n<h3 id=\"关于四边形不等式\">关于四边形不等式</h3>\n<p>对于代价矩阵 <span class=\"math inline\">\\(w\\)</span> 和定义域内 <span class=\"math inline\">\\(\\forall\\,a\\le b\\le c\\le d\\)</span>，若 <span class=\"math inline\">\\(w(a,d)+w(b,c)\\ge w(a,c)+w(b,d)\\)</span>，认为 <span class=\"math inline\">\\(w\\)</span> 满足四边形不等式。简记为重叠大于交叉。</p>\n<p>命名来源是四边形对角线之和大于对边之和；将恒大于改为恒小于也能得到相似的性质。</p>\n<p>就会发现单调队列优化和斜优其实是四边形不等式的特化，导致它们可以少一个 log。</p>\n<hr />\n<h3 id=\"性质\">性质</h3>\n<p>用于证明：</p>\n<ul>\n<li>对于任意 <span class=\"math inline\">\\(c\\le l\\le r\\)</span>，若 <span class=\"math inline\">\\(w(l-c,r+c) + w(l,r)\\le w(l-c,r)+ w(l,r+c)\\)</span>，则 <span class=\"math inline\">\\(w\\)</span> 满足四边形不等式。</li>\n</ul>\n<p>用于题目：</p>\n<ul>\n<li><strong>性质一</strong>：若 <span class=\"math inline\">\\(f_i\\)</span> 满足四边形不等式（或其反式），那么最优决策点 <span class=\"math inline\">\\(p_i\\)</span> 与 <span class=\"math inline\">\\(i\\)</span> 有单调关系。</li>\n<li><strong>性质二</strong>：当 <span class=\"math inline\">\\(i\\)</span> 变化时，每个 <span class=\"math inline\">\\(j\\)</span> 带来贡献的相对大小 rank 不变。亦作：若 <span class=\"math inline\">\\(j_1\\)</span> 相对于 <span class=\"math inline\">\\(j_2\\)</span> 对 <span class=\"math inline\">\\(i\\)</span> 更优，对于任意 <span class=\"math inline\">\\(i&#39;\\)</span>，<span class=\"math inline\">\\(j_1\\)</span> 相对于 <span class=\"math inline\">\\(j_2\\)</span> 对 <span class=\"math inline\">\\(i&#39;\\)</span> 更优。</li>\n</ul>\n<hr />\n<h3 id=\"在优化-dp-之前\">在优化 DP 之前</h3>\n<ul>\n<li><p>首先我必须要提一嘴。由于我第一次接触『四边形不等式』是在四年前，看到『石子合并的 <span class=\"math inline\">\\(n^2\\)</span> 做法』时。然而，这一题的 DP 本身有一个特殊性质，即贡献是一个以决策点为极值的凸函数；这直接导致我误以为这是四边形不等式本身带来的性质，导致我在理解上浪费了很多时间。<strong>四边形不等式带来的性质，只有上述两条！</strong></p>\n当然这也告诉我们，如果你发现『贡献是一个以决策点为极值的凸函数』，你就可以用类似石子合并中的线性转移完成问题。</li>\n<li><p>『满足四边形不等式』并不能等价于『决策单调性』。决策单调性并不具备性质二。</p>\n<p>也就是说，如果只满足决策单调性，只有最优决策点是单调的，但贡献函数随着 <span class=\"math inline\">\\(i\\)</span> 的变化，其形状会有很大的变动。</p></li>\n</ul>\n<hr />\n<h3 id=\"优化-dp分治\">优化 DP：分治</h3>\n<p>主要适用于 <span class=\"math inline\">\\(f_{i}=g_j+w(j,i)\\)</span> 的场景，其中 <span class=\"math inline\">\\(g\\)</span> 是与 <span class=\"math inline\">\\(f\\)</span> 无关的函数。</p>\n<p>对于分治范围 <span class=\"math inline\">\\([l,r]\\)</span> 和其决策点范围 <span class=\"math inline\">\\([L_p,R_p]\\)</span>，首先把暴力 <span class=\"math inline\">\\(mid\\)</span> 的决策点 <span class=\"math inline\">\\(p_{mid}\\)</span> 找出来。</p>\n<p>接着对于 <span class=\"math inline\">\\([l,mid)\\)</span> 和 <span class=\"math inline\">\\((mid,R]\\)</span>，分别在 <span class=\"math inline\">\\([L_p,p_{mid}]\\)</span> 和 <span class=\"math inline\">\\([p_{mid},R_p]\\)</span> 里找决策点（注意两边都是闭的）。递归地做。</p>\n<p>这时候你肯定就会怀疑了，主播主播，虽然你的区间每次在减半，但决策点范围并不是均分的，还会被共用，复杂度真的对吗？</p>\n<p>对的兄弟，对的。观察搜索树，你会发现虽然 <span class=\"math inline\">\\(p_{mid}\\)</span> 会被给两个儿子共用，但是在任何一层中，被重复经过的点只会出现在两个区间的交界处。也就是说每整层大概遍历 <span class=\"math inline\">\\(2n\\)</span> 次。是不是很对了。</p>\n<hr />\n<h4 id=\"例yet-another-minimization-problem\">例：Yet Another Minimization Problem</h4>\n<p><a href=\"https://codeforces.com/problemset/problem/868/F\" class=\"uri\">https://codeforces.com/problemset/problem/868/F</a></p>\n<details>\n<p><summary>我的天哪！是罕见的四级标题！</summary></p>\n<p>笑点解析：这个人因为懒得写 CSS 所以只写了经常用的 h2 和 h3 的样式，现在迫不得已用 h4 被倒逼去写了 h4 的 CSS。</p>\n</details>\n<p>发现 <span class=\"math inline\">\\(k\\le 20\\)</span>，所以可以不用写 WQS 二分。令 <span class=\"math inline\">\\(f_{i,j}\\)</span> 表示第 <span class=\"math inline\">\\(i\\)</span> 段分在 <span class=\"math inline\">\\(j\\)</span> 处的代价，那么有 <span class=\"math inline\">\\(f_{i,j}=\\min\\{f_{i-1,l}+w(l+1,j)\\}\\)</span>，分治解决。</p>\n<p>接着发现问题：<span class=\"math inline\">\\(w(l+1,j)\\)</span> 并不能很快地求出来；然后注意到这个代价的形式很莫队（其实在看到这个题的时候就会有莫队的想法），考虑使用莫队移动端点的方式解决问题。由于分治中查询的区间两端单增，每层的总移动次数是 <span class=\"math inline\">\\(O(n)\\)</span> 的，总复杂度就是 <span class=\"math inline\">\\(O(nk\\log n)\\)</span> 的。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst long long inf = 1e12;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, k;\n    std::cin &gt;&gt; n &gt;&gt; k;\n    std::vector&lt;int&gt; a(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i];\n    std::vector&lt;long long&gt; cnt(n + 1);\n    std::vector&lt;std::vector&lt;int&gt; &gt; p(k + 1, std::vector&lt;int&gt; (n + 1));\n    std::vector&lt;std::vector&lt;long long&gt; &gt; f(k + 1, std::vector&lt;long long&gt; (n + 1, inf));\n    auto w = [&amp;](int l, int r) &#123;\n        static int L = 1, R = 0;\n        static long long res = 0ll;\n        for (; L &gt; l; --L, res -= cnt[a[L]] * (cnt[a[L]] - 1) / 2, ++cnt[a[L]], res += cnt[a[L]] * (cnt[a[L]] - 1) / 2);\n        for (; R &gt; r; res -= cnt[a[R]] * (cnt[a[R]] - 1) / 2, --cnt[a[R]], res += cnt[a[R]] * (cnt[a[R]] - 1) / 2, --R);\n        for (; R &lt; r; ++R, res -= cnt[a[R]] * (cnt[a[R]] - 1) / 2, ++cnt[a[R]], res += cnt[a[R]] * (cnt[a[R]] - 1) / 2);\n        for (; L &lt; l; res -= cnt[a[L]] * (cnt[a[L]] - 1) / 2, --cnt[a[L]], res += cnt[a[L]] * (cnt[a[L]] - 1) / 2, ++L);\n        return res;\n    &#125;;\n    f[0][0] = 0ll;\n    for (int t = 1; t &lt;= k; ++t) &#123;\n        std::function&lt;void(int, int, int, int)&gt; calc = [&amp;](int l, int r, int lp, int rp) &#123;\n            if (l &gt; r)\n                return;\n            if (l == r) &#123;\n                for (int i = lp; i &lt;= rp &amp;&amp; i &lt; l; ++i)\n                    if (f[t - 1][i] + w(i + 1, l) &lt; f[t][l])\n                        f[t][l] = f[t - 1][i] + w(i + 1, l), p[t][l] = i;\n                return;\n            &#125;\n            int mid = (l + r) &gt;&gt; 1;\n            for (int i = lp; i &lt;= rp &amp;&amp; i &lt; mid; ++i)\n                if (f[t - 1][i] + w(i + 1, mid) &lt; f[t][mid])\n                    f[t][mid] = f[t - 1][i] + w(i + 1, mid), p[t][mid] = i;\n            calc(l, mid - 1, lp, p[t][mid]), calc(mid + 1, r, p[t][mid], rp);\n            return;\n        &#125;;\n        calc(1, n, 0, n - 1);\n    &#125;\n    std::cout &lt;&lt; f[k][n] &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"优化-dp单调数据结构\">优化 DP：单调数据结构</h3>\n<p>有的时候会出现 <span class=\"math inline\">\\(f_{i}=f_{j}+w(j,i)\\)</span> 的结构，也就是 <span class=\"math inline\">\\(f\\)</span> 的取值与自己有关。</p>\n<p>这种情况我们通常选择填表法，求出 <span class=\"math inline\">\\(f_i\\)</span> 后找到 <span class=\"math inline\">\\(i\\)</span> 是哪些点的最优决策（那么显然这些点是一段连续区间）。用 <span class=\"math inline\">\\((i,l_i,r_i)\\)</span> 这个三元组表示当前算出来的 <span class=\"math inline\">\\(i\\)</span> 管辖的范围。</p>\n<p>这是什么意思呢？结合性质二，每当我们手上拿到一个新的 <span class=\"math inline\">\\(i\\)</span>，那么推出来其管辖范围右端点就会是 <span class=\"math inline\">\\(n\\)</span>。接着想办法找到左端点，同样利用性质二，二分出最靠左的一个 <span class=\"math inline\">\\(j\\)</span>，满足之前算出来的决策点没有 <span class=\"math inline\">\\(i\\)</span> 优，那么 <span class=\"math inline\">\\([j,n]\\)</span> 就是当前条件下 <span class=\"math inline\">\\(i\\)</span> 的管辖范围。</p>\n<p>在队列里加入当前版本的整个三元组序列就可以方便地完成这个过程。为寻找当前元素的答案，需要将队头上，管辖范围完全早于当前元素的弹出去。由于维护的过程和单调队列很像，所以也有人直接把这里的队列叫单调队列。</p>\n<p>视题目不同，也可能用到单调栈，也有可能不用二分（例如满足前两种特化的情况）。goto <a href=\"/20250715/#a---yakiniku-restaurants\">Yakiniku Restaurants</a>。</p>\n<hr />\n<h4 id=\"例诗人小g\">例：诗人小G</h4>\n<p><a href=\"https://www.luogu.com.cn/problem/P1912\" class=\"uri\">https://www.luogu.com.cn/problem/P1912</a></p>\n<p><del>我觉得给出字符串内容的唯一价值是让出题人欣赏白日依山尽</del></p>\n<p>令 <span class=\"math inline\">\\(f_{j}\\)</span> 为某一行分在第 <span class=\"math inline\">\\(j\\)</span> 句处的代价，那么有 <span class=\"math inline\">\\(f_{j}=\\min\\limits_{k&lt;j}\\left\\{f_{k}+|(s_j-s_k+j-k-1)-L|^P\\right\\}\\)</span>。</p>\n<p>那么就可以考虑单调队列 + 二分了。需要注意无穷大之间的大小比较，我写这个写红温了，直接用指数项相对大小来代替了，似乎可以过。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst long long inf = 1000000000000000001ll;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;P1912_2.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int T;\n    for (std::cin &gt;&gt; T; T--; ) &#123;\n        int n, l, p;\n        std::cin &gt;&gt; n &gt;&gt; l &gt;&gt; p;\n        long long to;\n        switch (p) &#123; // 会有精度问题\n        case 1:\n            to = 1e18;\n            break;\n        case 2:\n            to = 1e9;\n            break;\n        case 3:\n            to = 1e6;\n            break;\n        case 4:\n            to = 31622;\n            break;\n        case 5:\n            to = 3981;\n            break;\n        case 6:\n            to = 1e3;\n            break;\n        case 7:\n            to = 372;\n            break;\n        case 8:\n            to = 177;\n            break;\n        case 9:\n            to = 100;\n            break;\n        default:\n            to = 63;\n            break;\n        &#125;\n        std::vector&lt;int&gt; s(n + 1);\n        std::vector&lt;std::string&gt; a(n + 1);\n        for (int i = 1; i &lt;= n; ++i)\n            std::cin &gt;&gt; a[i], s[i] = (int)a[i].length();\n        std::partial_sum(s.begin() + 1, s.end(), s.begin() + 1);\n        struct node &#123; int i, l, r; &#125;;\n        std::vector&lt;node&gt; q(n + 1);\n        int h = 0, t = -1;\n        q[++t] = &#123; 0, 1, n &#125;;\n        auto qkp = [&amp;](long long x, int y) &#123;\n            if (x &gt; to)\n                return inf;\n            auto res(1ll);\n            for (; y--; res *= x);\n            return res;\n        &#125;;\n        std::vector&lt;int&gt; pre(n + 1);\n        std::vector&lt;long long&gt; f(n + 1);\n        auto calc = [&amp;](int k, int j) &#123;\n            return std::min(inf, f[k] + qkp(std::abs(s[j] - s[k] + j - k - 1 - l), p));\n        &#125;;\n        auto less = [&amp;](int k1, int j1, int k2, int j2) &#123;\n            auto t1(calc(k1, j1)), t2(calc(k2, j2));\n            if (t1 == inf &amp;&amp; t2 == inf)\n                return std::abs(s[j1] - s[k1] + j1 - k1 - 1 - l) &lt; std::abs(s[j2] - s[k2] + j2 - k2 - 1 - l);\n            return t1 &lt; t2;\n        &#125;;\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            for (; h &lt;= t &amp;&amp; q[h].r &lt; i; ++h);\n            f[i] = calc(q[h].i, i), pre[i] = q[h].i;\n            for (; h &lt;= t &amp;&amp; q[t].l &gt; i &amp;&amp; less(i, q[t].l, q[t].i, q[t].l); --t)\n                q[t - 1].r = q[t].r;\n            for (int l = std::max(q[t].l, i + 1), r = q[t].r, mid; l &lt;= r; ) &#123;\n                mid = (l + r) &gt;&gt; 1;\n                if (less(i, mid, q[t].i, mid))\n                    r = q[t].r = mid - 1, q[t + 1] = &#123; i, mid, n &#125;;\n                else\n                    l = mid + 1;\n            &#125;\n            if (q[t + 1].i == i)\n                ++t;\n        &#125;\n        if (f[n] &gt;= inf)\n            std::cout &lt;&lt; &quot;Too hard to arrange&quot; &lt;&lt; &#39;\\n&#39;;\n        else &#123;\n            std::cout &lt;&lt; f[n] &lt;&lt; &#39;\\n&#39;;\n            std::function&lt;void(int)&gt; print = [&amp;](int x) &#123;\n                if (x == 0)\n                    return;\n                print(pre[x]);\n                for (int i = pre[x] + 1; i &lt;= x; ++i) &#123;\n                    std::cout &lt;&lt; a[i];\n                    if (i != x)\n                        std::cout &lt;&lt; &#39; &#39;;\n                &#125;\n                std::cout &lt;&lt; &#39;\\n&#39;;\n                return;\n            &#125;;\n            print(n);\n        &#125;\n        std::cout &lt;&lt; &quot;--------------------&quot;;\n        if (T)\n            std::cout &lt;&lt; &#39;\\n&#39;;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n<p>需要注意，本题也可以再加一个『恰好分 <span class=\"math inline\">\\(k\\)</span> 段』的限制，直接在外层套一个 WQS 二分就好了，参见 <a href=\"https://www.luogu.com.cn/problem/P6246\">邮局 加强版 加强版</a>。</p>\n<h3 id=\"d1d-dp-优化\">2D/1D DP 优化</h3>\n<p>若存在 <span class=\"math inline\">\\(f(i,j)=\\min\\limits_{k&lt;j} f(i-1,k)+w(k+1,j)\\)</span>，且 <span class=\"math inline\">\\(w\\)</span> 满足四边形不等式：</p>\n<ul>\n<li><p>设 <span class=\"math inline\">\\(p(i,j)\\)</span> 为最优决策点，那么有 <span class=\"math inline\">\\(p(i,j)\\le p(i,j+1)\\le p(i+1,j+1)\\)</span>，亦作 <span class=\"math inline\">\\(p(i,j-1)\\le p(i,j)\\le p(i+1,j)\\)</span>。</p>\n<p>此时可以 <span class=\"math inline\">\\(O(nm)\\)</span> 解决问题：</p>\n<p><img src=\"image.png\" /></p></li>\n<li><p>若 <span class=\"math inline\">\\(i\\)</span> 固定，<span class=\"math inline\">\\(f_i(j)\\)</span> 为凸函数。（例：邮局 加强版 加强版）</p>\n<p>goto <a href=\"/20250707/\">DP 凸优化</a>。</p></li>\n</ul>\n",
            "tags": [
                "DP",
                "DP 优化"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20250707/",
            "url": "https://xsc062.netlify.app/20250707/",
            "title": "DP 凸优化",
            "date_published": "2025-07-07T06:10:02.000Z",
            "content_html": "<p>袜，这篇文章一下子创建了三个新 tag。</p>\n<span id=\"more\"></span>\n<hr />\n<h2 id=\"什么是凸函数\">什么是凸函数</h2>\n<h3 id=\"定义\">定义</h3>\n<p>在信息学中研究的凸函数大抵是只在正整数域上有定义的，所以只能直接摒弃导函数的概念了。</p>\n<p>若斜率递增，换言之，差分数组递增，认为函数是凸的（好反直觉）。</p>\n<p>或者看看符号化的定义：若对于任意 <span class=\"math inline\">\\(\\lambda\\in[0,1]\\)</span>，函数 <span class=\"math inline\">\\(f(x)\\)</span> 均满足：</p>\n<p><span class=\"math display\">\\[\nf(\\lambda x+(1-\\lambda) y)\\le \\lambda f(x)+(1-\\lambda) f(y).\n\\]</span></p>\n<p>或等价地：</p>\n<p><span class=\"math display\">\\[\nf(x)-f(x - 1)\\le f(x + 1) - f(x)\n\\]</span></p>\n<p>那么认为 <span class=\"math inline\">\\(f\\)</span> 是凸函数。</p>\n<p>因为凹凸在性质上没区别，所以 <strong>下文施行暴政，将凹函数和凸函数统称为凸函数</strong>。</p>\n<hr />\n<h3 id=\"判定\">判定</h3>\n<p>对于具体情境下的问题，怎么判断 DP 数组是否关于其某一维为凸函数？</p>\n<ul>\n<li>相信相信的力量（最常用）。</li>\n<li><p>对于分段问题，证明分出来的每一段满足四边形不等式。</p>\n<em>值得一提的是，数学上不认为满足四边形不等式能够推出函数为凸。但这是信息学.jpg</em></li>\n<li><p>其由两个凸函数线性相加得到：</p>\n<p>对于 <span class=\"math inline\">\\(\\forall\\, \\lambda,\\mu\\ge 0\\)</span> 和凸函数 <span class=\"math inline\">\\(f,g\\)</span>，若 <span class=\"math inline\">\\(h=\\lambda f+\\mu g\\)</span>，则 <span class=\"math inline\">\\(h\\)</span> 为凸函数。</p>\n此外，此时 <span class=\"math inline\">\\(h\\)</span> 的差分数组和 <span class=\"math inline\">\\(f,g\\)</span> 差分数组也满足上述关系。</li>\n<li>其是两个凸函数的 <a href=\"#闵可夫斯基和\">闵可夫斯基和</a>。</li>\n<li><p>其由两个凸函数线性 max 得到。</p>\n<p>对于两个凸函数的线性 min，一般不是凸函数，甚至可能是凹的。</p></li>\n</ul>\n<hr />\n<h3 id=\"性质\">性质</h3>\n<ul>\n<li>最值为唯一极值。</li>\n<li>斜率 / 差分数组具有单调性。</li>\n</ul>\n<p>在解题中主要用到的大概就是上面两条。</p>\n<hr />\n<h2 id=\"wqs-二分\">WQS 二分</h2>\n<h3 id=\"主要任务\">主要任务</h3>\n<blockquote>\n<p>例：把 <span class=\"math inline\">\\(a_{1\\sim n}\\)</span> 分为恰好 <span class=\"math inline\">\\(k\\)</span> 段，每段的代价为 <span class=\"math inline\">\\(sum^2+c\\)</span>（<span class=\"math inline\">\\(c\\)</span> 为给定的常数），问最小代价。<span class=\"math inline\">\\(n\\le 2\\times 10^5,a_i\\le 10^9\\)</span>。</p>\n</blockquote>\n<p>如果对段数没有要求，可以用斜优 <span class=\"math inline\">\\(O(n)\\)</span> 做。</p>\n<p>加上了 <span class=\"math inline\">\\(k\\)</span> 的限制，DP 变成二维的，令 <span class=\"math inline\">\\(f_{i,j}\\)</span> 表示在 <span class=\"math inline\">\\(i\\)</span> 处分第 <span class=\"math inline\">\\(j\\)</span> 段，可以在第一维斜率优化，做到 <span class=\"math inline\">\\(O(nk)\\)</span>；亦或发现 <span class=\"math inline\">\\((i,j)\\)</span> 有决策单调性，然后四边形不等式优化到 <span class=\"math inline\">\\(O(n^2)\\)</span>。</p>\n<p>我们发现 <span class=\"math inline\">\\(f\\)</span> 关于 <span class=\"math inline\">\\(j\\)</span> 这一维是凸的（而非上文的 <span class=\"math inline\">\\((i,j)\\)</span>），故将 <span class=\"math inline\">\\(f(n,j)\\)</span> 关于 <span class=\"math inline\">\\(j\\)</span> 的函数提取出来（记为 <span class=\"math inline\">\\(f_n(j)\\)</span>）。发现只有最高点是可以一次斜优快速求出来的，故可以认为在当前复杂度限制下，整个函数除了最高点以外都是未知的（注意可以在 DP 时记录极值点的横坐标，即分了几段）。</p>\n<p>我们给每个 <span class=\"math inline\">\\(f_n(j)\\)</span> 加上 <span class=\"math inline\">\\(\\alpha\\cdot j\\)</span>（在本题中即将 <span class=\"math inline\">\\(c\\gets c+k\\)</span>），勉强可以认为 <span class=\"math inline\">\\(\\alpha\\cdot j\\)</span> 是凸的，所以新函数 <span class=\"math inline\">\\(f&#39;_n(j)\\)</span> 也是凸的。若 <span class=\"math inline\">\\(k&gt;0\\)</span>，可以感受到极值点向左偏移，且随着 <span class=\"math inline\">\\(k\\)</span> 的增大，极值点不会右移；<span class=\"math inline\">\\(k&lt;0\\)</span> 时同理。</p>\n<p>结合几何观点，在 <span class=\"math inline\">\\(f_n\\)</span> 上的极值点可以用斜率为 <span class=\"math inline\">\\(0\\)</span> 的直线切到；而加上 <span class=\"math inline\">\\(\\alpha\\cdot j\\)</span> 的过程，其实就是切线斜率减去 <span class=\"math inline\">\\(\\alpha\\)</span> 的过程。相当于令切线斜率为 <span class=\"math inline\">\\(-\\alpha\\)</span>，看看能切到哪里。</p>\n<p>故可以二分一个合适的 <span class=\"math inline\">\\(k\\)</span>，使得极值点的横坐标为 <span class=\"math inline\">\\(k\\)</span>。此时 <span class=\"math inline\">\\(f&#39;_n(k)-\\alpha\\cdot k\\)</span> 即为待求。</p>\n<hr />\n<p>WQS 二分参与的问题一般以如下形式呈现：</p>\n<blockquote>\n<p>给定序列，将其恰好分为 <span class=\"math inline\">\\(k\\)</span> 段 / 恰好选 <span class=\"math inline\">\\(k\\)</span> 个，求最大 / 最小代价。</p>\n</blockquote>\n<p>题目要求最大 / 最小值一般能够反映函数的凹凸性，可以根据这一点来猜。</p>\n<hr />\n<h3 id=\"细节处理\">细节处理</h3>\n<p>考虑如下凸函数：</p>\n<p><img src=\"1.png\" /></p>\n<ul>\n<li>显然对于『凸出来』的点（即图中除了 <span class=\"math inline\">\\(E,H\\)</span> 以外的点），能切到的直线斜率为一个范围；而位于直线上的点（途中 <span class=\"math inline\">\\(E,H\\)</span>），能切到的直线斜率更是定死了。所以这要求你的二分精度需要略高一点。</li>\n<li><p>对于 <span class=\"math inline\">\\(E\\)</span>（或 <span class=\"math inline\">\\(H\\)</span>），不能找到只过它一点的切线。根据 DP 的写法，记录的横坐标可能是最小的 <span class=\"math inline\">\\(D\\)</span>，也可能是最大的 <span class=\"math inline\">\\(F\\)</span>，此时你可以：</p>\n<ul>\n<li>同时记录最小和最大的横坐标，看看 <span class=\"math inline\">\\(k\\)</span> 在不在中间。</li>\n<li><p>题目要求最大代价时，记录最大横坐标，二分到一个极值点 <span class=\"math inline\">\\(k&#39;\\ge k\\)</span> 时，显然 <span class=\"math inline\">\\(\\alpha&#39;\\ge \\alpha\\)</span>，用 <span class=\"math inline\">\\(f&#39;_n(k&#39;)-\\alpha&#39;\\cdot k\\)</span> 更新答案（是赋值而不是取最值）；求最小代价时同理。</p>\n<p>主要是需要记住斜率是 <span class=\"math inline\">\\(\\alpha\\)</span> 的相反数，<del>实在搞不清对应关系可以都试一试</del></p></li>\n</ul></li>\n</ul>\n<hr />\n<h3 id=\"例种树\">例：种树</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P1484\" class=\"uri\">https://www.luogu.com.cn/problem/P1484</a></p>\n<p>首先，函数是凸的——感性理解即可。</p>\n<p>接着，要求的是 <span class=\"math inline\">\\(\\le k\\)</span> 时的最值。分为两种情况：<span class=\"math inline\">\\(k\\)</span> 是否右于原函数极值点。</p>\n<ul>\n<li>若 <span class=\"math inline\">\\(k\\)</span> 右于原函数极值点，则原函数极值点为答案。</li>\n<li>否则，<span class=\"math inline\">\\(k\\)</span> 为答案。</li>\n</ul>\n<p>好消息是整数域上一定有解（最后答案为整、倒推即可），所以不用打浮点数二分了。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int lim = 1e6;\nconst long long inf = 1e18;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, k;\n    std::cin &gt;&gt; n &gt;&gt; k;\n    std::vector&lt;long long&gt; a(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i];\n    auto calc = [&amp;](int c) &#123;\n        std::vector&lt;std::pair&lt;long long, int&gt; &gt; f(n + 1);\n        auto mx = f.front();\n        auto upd = [&amp;](auto &amp;x, auto y) &#123;\n            if (y.first &gt; x.first || (y.first == x.first &amp;&amp; y.second &lt; x.second))\n                x = y;\n            return;\n        &#125;;\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            f[i].first = mx.first + a[i] + c;\n            f[i].second = mx.second + 1;\n            upd(mx, f[i - 1]);\n        &#125;\n        upd(mx, f[n]);\n        return mx;\n    &#125;;\n    auto t(calc(0));\n    if (t.second &lt;= k) &#123;\n        std::cout &lt;&lt; t.first &lt;&lt; &#39;\\n&#39;;\n        return 0;\n    &#125;\n    auto res(-inf);\n    for (int l = -lim, r = lim, mid; l &lt;= r; ) &#123;\n        mid = (l + r) &gt;&gt; 1;\n        auto t = calc(mid);\n        if (t.second &lt;= k)\n            res = t.first - (long long)mid * k, l = mid + 1;\n        else\n            r = mid - 1;\n    &#125;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"例raper\">例：Raper</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P4694\" class=\"uri\">https://www.luogu.com.cn/problem/P4694</a></p>\n<p>给所有光盘附一个奖励 <span class=\"math inline\">\\(mid\\)</span>，进行 WQS 二分。</p>\n<p>然后内层就和 <a href=\"#例序列-sequence\">sequence</a> 差得不是特别多，所以考虑反悔贪心。（？）</p>\n<p>把路过的 <span class=\"math inline\">\\(-a_j\\)</span> 丢到大根堆里，尝试和 <span class=\"math inline\">\\(b_i\\)</span> 配对。如果 <span class=\"math inline\">\\(mid-a_i-b_i\\ge 0\\)</span> 那么暂时配对，顺便把 <span class=\"math inline\">\\(b_i-mid\\)</span> 丢进去用于反悔，若 <span class=\"math inline\">\\(b_{i&#39;}\\)</span> 选中了 <span class=\"math inline\">\\(b_i-mid\\)</span> 说明反悔，将 <span class=\"math inline\">\\(a_j\\)</span> 与 <span class=\"math inline\">\\(b_{i&#39;}\\)</span> 配对。</p>\n<p>贪心的时候需要记录已经配的对数，优先队列中需要对 <span class=\"math inline\">\\(-a_j\\)</span> 和 <span class=\"math inline\">\\(b_i-mid\\)</span> 打标记进行区分，匹配到前者时才增加成功对数。</p>\n<p>发现整数域上仍然必有解（答案为整，倒推），不用打浮点数二分 neiher.</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst long long inf = 2e9 + 5;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, k;\n    std::cin &gt;&gt; n &gt;&gt; k;\n    std::vector&lt;int&gt; a(n + 1), b(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i];\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; b[i];\n    auto calc = [&amp;](long long mid) &#123;\n        std::priority_queue&lt;std::pair&lt;long long, int&gt; &gt; q;\n        int cnt = 0;\n        auto res(0ll);\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            q.emplace(-a[i], 1);\n            auto [v, ty] = q.top();\n            if (mid + v - b[i] &gt;= 0) &#123;\n                q.pop(), cnt += ty;\n                res += mid + v - b[i], q.emplace(b[i] - mid, 0);\n            &#125;\n        &#125;\n        return std::make_pair(cnt, res);\n    &#125;;\n    auto res(inf);\n    for (long long l = 1ll, r = inf, mid; l &lt;= r; ) &#123;\n        mid = (l + r) &gt;&gt; 1;\n        auto t(calc(mid));\n        if (t.first &gt;= k)\n            r = mid - 1, res = -(t.second - k * mid);\n        else\n            l = mid + 1;\n    &#125;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"区间分拆问题\">区间分拆问题</h3>\n<p>目标：尝试将 <span class=\"math inline\">\\(a_{1\\sim n}\\)</span> 分割成恰好 <span class=\"math inline\">\\(k\\)</span> 段，定义 <span class=\"math inline\">\\(w(i,j)\\)</span> 为将 <span class=\"math inline\">\\([i,j]\\)</span> 作为一段的代价，求代价最值。其中 <span class=\"math inline\">\\(w(i,j)\\)</span> 满足四边形不等式。</p>\n<p>不妨设求最小代价。定义 <span class=\"math inline\">\\(f(i,j)\\)</span> 在 <span class=\"math inline\">\\(i\\)</span> 处分第 <span class=\"math inline\">\\(j\\)</span> 段，那么有：</p>\n<p><span class=\"math display\">\\[\nf(i,j)=\\min(f(i-1,p-1)+w(p,j)).\n\\]</span></p>\n<blockquote>\n<p>有定理：若 <span class=\"math inline\">\\(w(i,j)\\)</span> 满足四边形不等式，那么有 <span class=\"math inline\">\\(f(i-1,j)\\le f(i,j)\\le f(i,j+1)\\)</span>，从 <span class=\"math inline\">\\(f\\)</span> 定义出发很好感性理解。</p>\n</blockquote>\n<p>那么可以从这一点出发，<span class=\"math inline\">\\(p\\)</span> 这一维就可以被摊掉，做到 <span class=\"math inline\">\\(O(n(n+m))\\)</span>。</p>\n<blockquote>\n<p>有定理：若 <span class=\"math inline\">\\(w(i,j)\\)</span> 满足四边形不等式，那么 <span class=\"math inline\">\\(f_i(j)\\)</span> 是凸函数。</p>\n</blockquote>\n<p>那很好了。直接冲刺 WQS 即可。</p>\n<hr />\n<h2 id=\"闵可夫斯基和\">闵可夫斯基和</h2>\n<p>给定两个凸函数（当然是指 OI 中那种长得很直的函数），将它们的『边』拆下来过后，以某种方式拼在一起，使得最后得到一个新的凸函数。</p>\n<p>按每条『边』的斜率归并一下就可以得到，显然答案存在且唯一，这个过程被称为闵可夫斯基和。可以发现这是一种最值 - 加卷积。</p>\n<p>假设我们要求的 DP 数组是两个已知的子数组以类似的方法卷起来的，最后要求完整的 DP 数组（而非 WQS 中的单点值），就可以考虑闵可夫斯基和。</p>\n<p>发现这个结构是很适合归并的，使用归并要求状态中含有版本维、因变量维。</p>\n<hr />\n<h3 id=\"例its-mooin-time-p\">例：It's Mooin' Time P</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P11459\" class=\"uri\">https://www.luogu.com.cn/problem/P11459</a></p>\n<p>定义 <span class=\"math inline\">\\(w_i\\)</span> 为将 <span class=\"math inline\">\\([i,i+L)\\)</span> 改为 <code>MOO</code> 的代价，问题转化为选取 <span class=\"math inline\">\\(1\\sim \\frac nL\\)</span> 个不重区间的最小代价和。</p>\n<p>尝试归并，每次将 <span class=\"math inline\">\\([l,mid]\\)</span> 和 <span class=\"math inline\">\\((mid, r]\\)</span> 卷起来。但是会有一点问题：如果恰好有区间卡在中间呢？</p>\n<p>可以令 <span class=\"math inline\">\\(f_{l,r,0/1/2,0/1/2}(i)\\)</span> 表示在 <span class=\"math inline\">\\([l,r]\\)</span> 内选了 <span class=\"math inline\">\\(i\\)</span> 个 <code>MOO</code>，且两侧最远的被选点距离端点为 <span class=\"math inline\">\\(0/1/\\ge 2\\)</span> 的 DP 值。然后可以进行相应的讨论、平移、闵可夫斯基和，最后将所有情况线性取 max 得到这一层的答案，容易发现得到的答案也是凸的。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst long long inf = 1e18;\nint L;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    std::cin &gt;&gt; L &gt;&gt; n;\n    std::vector&lt;int&gt; a(n + 1);\n    std::vector&lt;char&gt; t(n + 1);\n    std::vector&lt;long long&gt; w(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; t[i];\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i];\n    for (int i = 1; i &lt;= n - L + 1; ++i) &#123;\n        w[i] = a[i] * (t[i] != &#39;M&#39;);\n        for (int j = i + 1; j &lt; i + L; ++j)\n            w[i] += a[j] * (t[j] != &#39;O&#39;);\n        // printf(&quot;[%d, %d]: %lld\\n&quot;, i, i + L - 1, w[i]);\n    &#125;\n    if (L == 1) &#123;\n        std::sort(w.begin() + 1, w.end());\n        auto s(0ll);\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            s += w[i];\n            std::cout &lt;&lt; s &lt;&lt; &#39;\\n&#39;;\n        &#125;\n        return 0;\n    &#125;\n    using arr = std::vector&lt;long long&gt;;\n    using brr = std::vector&lt;arr&gt;;\n    using crr = std::vector&lt;brr&gt;;\n    struct node &#123;\n        crr f;\n        node(int len): f(L, brr(L, arr(len, inf))) &#123;\n            for (int i = 0; i &lt; L; ++i)\n                for (int j = 0; j &lt; L; ++j)\n                    f[i][j][0] = 0ll;\n            return;\n        &#125;\n        brr&amp; operator[] (int q) &#123; return f[q]; &#125;\n    &#125;;\n    auto upd = [&amp;](arr &amp;x, arr y) &#123;\n        if (x.size() &lt; y.size())\n            x.resize(y.size(), inf);\n        for (int i = 0; i &lt; (int)y.size(); ++i)\n            x[i] = std::min(x[i], y[i]);\n        return;\n    &#125;;\n    auto merge = [&amp;](arr l, arr r) &#123;\n        arr out((int)(l.size() + r.size()) - 1), dl(l.size()), dr(r.size());\n        for (int i = 1; i &lt; (int)l.size(); ++i)\n            dl[i] = l[i] - l[i - 1];\n        for (int i = 1; i &lt; (int)r.size(); ++i)\n            dr[i] = r[i] - r[i - 1];\n        std::merge(dl.begin() + 1, dl.end(), dr.begin() + 1, dr.end(), out.begin() + 1);\n        out[0] = l[0] + r[0];\n        std::partial_sum(out.begin(), out.end(), out.begin());\n        return out;\n    &#125;;\n    std::function&lt;node(int, int)&gt; calc = [&amp;](int l, int r) &#123;\n        if (r - l + 1 &lt; 2 * L) &#123;\n            node res(1);\n            for (int ll = 0; ll &lt; L; ++ll)\n                for (int rr = 0; rr &lt; L; ++rr)\n                    if (l + ll &lt;= r - rr - L + 1) &#123;\n                        res[ll][rr].resize(2, inf);\n                        for (int i = l + ll; i &lt;= r - rr - L + 1; ++i)\n                            res[ll][rr][1] = std::min(res[ll][rr][1], w[i]);\n                        // printf(&quot;[%d, %d]: (%d, %d) = %lld\\n&quot;, l, r, ll, rr, res[ll][rr][1]);\n                    &#125;\n            // for (int i = 0; i &lt; L; ++i)\n            //     if (l + i + L - 1 &lt;= r) &#123;\n            //         printf(&quot;[%d, %d]: (%d, %d) = %lld\\n&quot;, l, r, i, r - (l + i + L - 1), w[l + i]);\n            //         res[i][r - (l + i + L - 1)].emplace_back(w[l + i]);\n            //     &#125;\n            return res;\n        &#125;   \n        int mid = (l + r) &gt;&gt; 1;\n        node tl(calc(l, mid)), tr(calc(mid + 1, r)), res((r - l + 1) / L + 1);\n        for (int ll = 0; ll &lt; L; ++ll)\n            for (int rr = 0; rr &lt; L; ++rr)\n                res[ll][rr] = merge(tl[ll][0], tr[0][rr]);\n        for (int ll = 0; ll &lt; L; ++ll)\n            for (int rr = 0; rr &lt; L; ++rr)\n                for (int i = 1; i &lt; L &amp;&amp; i &lt; mid; ++i)\n                    upd(res[ll][rr], merge(merge(tl[ll][i], tr[L - i][rr]), &#123; 0, w[mid - i + 1] &#125;));\n        for (int ll = 0; ll &lt; L; ++ll)\n            for (int rr = L - 1; rr; --rr)\n                upd(res[ll][rr - 1], res[ll][rr]);\n        for (int rr = 0; rr &lt; L; ++rr)\n            for (int ll = L - 1; ll; --ll)\n                upd(res[ll - 1][rr], res[ll][rr]);\n        // for (int i = 0; i &lt; L; ++i)\n        //     for (int j = 0; j &lt; L; ++j) &#123;\n        //         printf(&quot;  (%d, %d): &quot;, i, j);\n        //         for (auto p : res[i][j])\n        //             printf(&quot;%lld &quot;, p);\n        //         puts(&quot;&quot;);\n        //     &#125;\n        return res;\n    &#125;;\n    auto res(calc(1, n));\n    for (int i = 1; i &lt;= n / L; ++i)\n        std::cout &lt;&lt; res[0][0][i] &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"例假人\">例：假人</h3>\n<p><a href=\"https://www.becoder.com.cn/problem/47728\" class=\"uri\">https://www.becoder.com.cn/problem/47728</a></p>\n<p>令 <span class=\"math inline\">\\(f_{i,j}\\)</span> 表示前 <span class=\"math inline\">\\(i\\)</span> 组选完占了 <span class=\"math inline\">\\(j\\)</span> 体积的最大价值。那么有 <span class=\"math inline\">\\(f_{i,j}=\\max\\{f_{i-1,k}+a_{i,j-k}\\}\\)</span>。</p>\n<p><em>袜，这个东西好凸的样子！啊？居然不是凸的？</em></p>\n<p>事实上，有结论：若干个体积为 <span class=\"math inline\">\\(0\\sim 4\\)</span> 的物品做背包，可以凑出值域内任意 <span class=\"math inline\">\\(24\\)</span> 的倍数。所以先把体积全部 <span class=\"math inline\">\\(-1\\)</span>，然后就可以得到体积为 <span class=\"math inline\">\\(0\\sim 4\\)</span> 的物品。然后会发现他们按照模 <span class=\"math inline\">\\(12\\)</span> 的余数分别是凸的。</p>\n<p>能感受到恶意了。然后就可以枚举体积，再闵可夫斯基和了。同样需要在状态中引入作为版本号的 <span class=\"math inline\">\\([l,r]\\)</span> 维，显然因变量是体积、版本号是组数。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst long long inf = 1e18;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;fake2.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, m = 0;\n    std::cin &gt;&gt; n;\n    std::vector&lt;int&gt; siz(n + 1);\n    std::vector&lt;std::vector&lt;int&gt; &gt; a(n + 1);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; siz[i], m += siz[i];\n        a[i].resize(siz[i] + 1);\n        for (int j = 1; j &lt;= siz[i]; ++j)\n            std::cin &gt;&gt; a[i][j];\n    &#125;\n    using arr = std::vector&lt;long long&gt;;\n    struct node &#123;\n        std::vector&lt;arr&gt; f;\n        node(): f(12) &#123;&#125;\n        arr &amp;operator[] (int q) &#123;\n            return f[q];\n        &#125;\n    &#125;;\n    auto merge = [&amp;](arr &amp;p, arr &amp;q) &#123;\n        arr res((int)(p.size() + q.size()) - 1), dp(p.size()), dq(q.size());\n        std::adjacent_difference(p.begin(), p.end(), dp.begin());\n        std::adjacent_difference(q.begin(), q.end(), dq.begin());\n        std::merge(dp.begin() + 1, dp.end(), dq.begin() + 1, dq.end(), res.begin() + 1, std::greater&lt;long long&gt; ());\n        res[0] = p[0] + q[0];\n        std::partial_sum(res.begin(), res.end(), res.begin());\n        return res;\n    &#125;;\n    auto upd = [&amp;](arr y, arr &amp;x, int tag) &#123;\n        if (tag)\n            y.insert(y.begin(), -inf);\n        if (y.size() &gt; x.size())\n            x.resize(y.size(), -inf);\n        for (int i = 0; i &lt; (int)y.size(); ++i)\n            x[i] = std::max(x[i], y[i]);\n        return;\n    &#125;;\n    std::function&lt;node(int, int)&gt; calc = [&amp;](int l, int r) &#123;\n        if (l == r) &#123;\n            node res;\n            for (int i = 1; i &lt;= siz[l]; ++i)\n                res[i - 1].push_back(a[l][i]);\n            return res;\n        &#125;\n        int mid = (l + r) &gt;&gt; 1;\n        node tl(calc(l, mid)), tr(calc(mid + 1, r)), res;\n        for (int p = 0; p &lt; 12; ++p)\n            for (int q = 0; q &lt; 12; ++q)\n                if (!tl[p].empty() &amp;&amp; !tr[q].empty())\n                    upd(merge(tl[p], tr[q]), res[(p + q) % 12], p + q &gt;= 12);\n        return res;\n    &#125;;\n    auto res(calc(1, n));\n    for (int i = 0; i &lt;= m - n; ++i)\n        std::cout &lt;&lt; res[i % 12][i / 12] &lt;&lt; &#39; &#39;;\n    std::cout &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"slope-trick\">slope trick</h2>\n<p>对于一个 OI 中的凸函数，它是由一些斜率单调的线段拼接成的图形。</p>\n<p>在这个前提下，发现可以用整个函数的左 / 右端点值（截距）和 <span class=\"math inline\">\\((n-1)\\)</span> 个斜率 / 差分信息描述函数。而这有时比直接维护 <span class=\"math inline\">\\(n\\)</span> 个点值有着更优美的性质，唤其为 slope trick。</p>\n<p>例如，关于斜率序列，如果定义域不大，可以直接维护；如果它的变化次数不多，可以利用它的单调性质，用单调数据结构维护；如果它的值域很小，可以直接维护拐点。</p>\n<p>注意前两种方法一般关注横坐标对应的函数值，所以自变量一般是和操作次数一类有关的；而这里关注函数最值而弱化了具体横坐标，操作次数一般会作为待最优化的因变量，例如：</p>\n<ul>\n<li>我想要将数列通过若干次单点修改使序列单调，但不关心序列最终形态，问最小操作次数。</li>\n<li>我想要让树上所有叶子到根的路径边权和相等，但不关心这个值是多少，问最小操作次数。</li>\n</ul>\n<p>下面依次解决上述问题。</p>\n<hr />\n<h3 id=\"例序列-sequence\">例：序列 sequence</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P4597\" class=\"uri\">https://www.luogu.com.cn/problem/P4597</a></p>\n<p>暴力地，令 <span class=\"math inline\">\\(f_{i,j}\\)</span> 表示 <span class=\"math inline\">\\(a_i\\)</span> 最终被修改为 <span class=\"math inline\">\\(j\\)</span>，容易写出 DP 式子 <span class=\"math inline\">\\(f_{i,j}=\\min\\limits_{k\\le j}\\{f_{i-1,k}\\}+|a_i-j|\\)</span>。</p>\n<p>然后就会发现它的定义域实在是太大了！那如果关注斜率的变化情况呢？</p>\n<p>令 <span class=\"math inline\">\\(f_{i-1}(k)\\)</span> 的极值点为 <span class=\"math inline\">\\(k_m\\)</span>，分类讨论拆绝对值和 min：</p>\n<ul>\n<li><p>当 <span class=\"math inline\">\\(j\\le a_i\\)</span> 时，<span class=\"math inline\">\\(f_i(j)=\\min\\limits_{k\\le j}\\{f_{i-1}(k)\\}+a_i - j\\)</span>。</p>\n<ul>\n<li>当 <span class=\"math inline\">\\(j &lt; k_m\\)</span> 时，<span class=\"math inline\">\\(f_i(j)=f_{i-1}(j)+a_i-j\\)</span>，斜率相对于 <span class=\"math inline\">\\(f_{i-1}(j)\\)</span> 整体减 <span class=\"math inline\">\\(1\\)</span>。<del>我就说导数没白学吧</del></li>\n<li>当 <span class=\"math inline\">\\(j \\ge k_m\\)</span> 时，<span class=\"math inline\">\\(f_i(j)=f_{i-1}(k_m)+a_i-j\\)</span>，斜率为 <span class=\"math inline\">\\(-1\\)</span>。</li>\n</ul></li>\n<li><p>当 <span class=\"math inline\">\\(j &gt; a_i\\)</span> 时，<span class=\"math inline\">\\(f_i(j)=\\min\\limits_{k\\le j}\\{f_{i-1}(k)\\}+j-a_i\\)</span>。</p>\n<ul>\n<li>当 <span class=\"math inline\">\\(j &lt; k_m\\)</span> 时，<span class=\"math inline\">\\(f_i(j)=f_{i-1}(j)+j-a_i\\)</span>，斜率相对于 <span class=\"math inline\">\\(f_{i-1}(j)\\)</span> 整体加 <span class=\"math inline\">\\(1\\)</span>。</li>\n<li>当 <span class=\"math inline\">\\(j\\ge k_m\\)</span> 时，<span class=\"math inline\">\\(f_i(j) = f_{i-1}(k_m)+j-a_i\\)</span>，斜率为 <span class=\"math inline\">\\(1\\)</span>。</li>\n</ul></li>\n</ul>\n<p>如果现在我们掏一个支持区间加斜率、区间推平斜率且维护区间函数最值点的数据结构，那就太逆天了。一个经典的解决方案是用堆维护线段斜率的差分（也就是差分的差分）。</p>\n<p>发现整体修改次数是 <span class=\"math inline\">\\(O(n)\\)</span> 的，且如果只看比 <span class=\"math inline\">\\(k_m\\)</span> 更左的 <span class=\"math inline\">\\(j\\)</span>（更靠右的已经与极值无关所以不用维护），那么就只需要维护区间减法。</p>\n<p>如果将一次区间前缀减法看作一次前缀右端点入队，显然左侧某点 <span class=\"math inline\">\\(a\\)</span> 的实际被减次数为 <span class=\"math inline\">\\(a\\)</span> 入队的次数 + 所有右于 <span class=\"math inline\">\\(a\\)</span> 点的元素的入队次数。用大根堆维护这些元素，就可以快速维护整个斜率序列。例如 <code>3 2 2 1</code>，代表 <span class=\"math inline\">\\(3\\)</span> 处斜率为 <span class=\"math inline\">\\(-1\\)</span>，<span class=\"math inline\">\\(2\\)</span> 处斜率为 <span class=\"math inline\">\\(-3\\)</span>，<span class=\"math inline\">\\(1\\)</span> 处斜率为 <span class=\"math inline\">\\(-4\\)</span>。</p>\n<ul>\n<li><p>当 <span class=\"math inline\">\\(a_i\\ge k_m\\)</span> 时（容易发现它会成为新的 <span class=\"math inline\">\\(k_m\\)</span>），直接把 <span class=\"math inline\">\\(a_i\\)</span> 加入大根堆，就可以把 <span class=\"math inline\">\\(\\le a_i\\)</span> 的所有位置斜率减去 <span class=\"math inline\">\\(1\\)</span>。</p>\n什么你问在 <span class=\"math inline\">\\(k_m\\)</span> 和 <span class=\"math inline\">\\(a_i\\)</span> 之间的推平怎么办？由于唯一右于它们的拐点 <span class=\"math inline\">\\(a_i\\)</span> 入了一次队，所以中间的元素斜率自然是 <span class=\"math inline\">\\(-1\\)</span> 啊。</li>\n<li><p>当 <span class=\"math inline\">\\(a_i&lt;k_m\\)</span> 时，我们需要：</p>\n<ol type=\"1\">\n<li>将 <span class=\"math inline\">\\(a_i\\)</span> 以左的位置斜率减去 <span class=\"math inline\">\\(1\\)</span>，直接将 <span class=\"math inline\">\\(a_i\\)</span> 入队即可。</li>\n<li>将 <span class=\"math inline\">\\(a_i\\)</span> 和 <span class=\"math inline\">\\(k_m\\)</span> 之间的位置斜率加上 <span class=\"math inline\">\\(1\\)</span>，把 <span class=\"math inline\">\\(k_m\\)</span> 弹出（太好了就在队首）再把 <span class=\"math inline\">\\(a_i\\)</span> 加入即可。由于 <span class=\"math inline\">\\(k_m\\)</span> 显然是一个拐点，所以删除 <span class=\"math inline\">\\(k_m\\)</span> 并非虚空索敌，但注意 <span class=\"math inline\">\\(k_m\\)</span> 可能会变化成其后继。</li>\n</ol></li>\n</ul>\n<p>其实就会发现还有一些有趣的小性质，比如 <span class=\"math inline\">\\(k_m\\)</span> 与队首等价（用于实现）；<span class=\"math inline\">\\(k_m\\)</span> 右侧斜率全部为 <span class=\"math inline\">\\(1\\)</span>，也是唯一可以取到的正斜率。</p>\n<details>\n<p>袜写起来好简单。</p>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;int&gt; a(n + 1);\n    long long res = 0ll;\n    std::priority_queue&lt;int&gt; q;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; a[i];\n        if (i == 1 || a[i] &gt;= q.top())\n            q.push(a[i]);\n        else &#123;\n            res += q.top() - a[i];\n            q.pop(), q.push(a[i]), q.push(a[i]);\n        &#125;\n    &#125;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"例烟花表演\">例：烟花表演</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P3642\" class=\"uri\">https://www.luogu.com.cn/problem/P3642</a></p>\n<p>设 <span class=\"math inline\">\\(f_{u,d}\\)</span> 表示在 <span class=\"math inline\">\\(u\\)</span> 子树中所有叶子距根均为 <span class=\"math inline\">\\(d\\)</span> 的最小代价。那么有：</p>\n<p><span class=\"math display\">\\[\nf_{u,d}=\\sum\\limits_{(v, w)\\in u}\\min\\limits_{0\\le w&#39;\\le d}\\{f_{v,d-w&#39;}+|w-w&#39;|\\}.\n\\]</span></p>\n<p>可以归纳证明 <span class=\"math inline\">\\(f_{u,d}\\)</span> 为凸；和上一题相似地，考虑用 <span class=\"math inline\">\\(f_v\\)</span> 的堆得到 <span class=\"math inline\">\\(f_u\\)</span> 的堆。</p>\n<p>首先最外层是一个线性加，这其实就是把差分数组 / 斜率加起来，放到我们这个堆里面就是合并两个堆。虽然你可能和我一样不认识可并堆，但是你可以和我一样不会 pd_ds。</p>\n<p>再看内层，发现和上一题长得像但其实不一样，呜呜呜。发现 <span class=\"math inline\">\\(|w-w&#39;|\\)</span> 是一个左右斜率分别为 <span class=\"math inline\">\\(-1,1\\)</span> 的分段函数，而左边类比可得斜率最大为 <span class=\"math inline\">\\(1\\)</span>。</p>\n<p>由闵可夫斯基和，内层函数斜率 <span class=\"math inline\">\\(&lt;-1\\)</span> 的部分来自 <span class=\"math inline\">\\(f_{v,d-w&#39;}\\)</span>；<span class=\"math inline\">\\(=-1\\)</span> 的部分来自 <span class=\"math inline\">\\(f_{v,d-w&#39;}\\)</span> 和 <span class=\"math inline\">\\(|w-w&#39;|\\)</span> 的左半边（感谢 <span class=\"math inline\">\\(w&#39;\\)</span> 是有下确界的）；<span class=\"math inline\">\\(=0\\)</span> 的部分来自 <span class=\"math inline\">\\(f_{v,d-w&#39;}\\)</span>；<span class=\"math inline\">\\(&gt;0\\)</span> 的部分我们不关心。</p>\n<p>最终函数图像的变化：水平部分的左端点右移了 <span class=\"math inline\">\\(w\\)</span>。找到 <span class=\"math inline\">\\(f_{v,d}\\)</span> 中的水平线段和斜率为 <span class=\"math inline\">\\(1\\)</span> 的线段，令其在堆中的值 <span class=\"math inline\">\\(+w\\)</span> 就能达到平移的目的。</p>\n<p>但需要注意，此时仍然需要 <strong>保留内层函数中斜率为 <span class=\"math inline\">\\(1\\)</span> 的部分，但斜率 <span class=\"math inline\">\\(&gt;1\\)</span> 的部分被删除</strong>。原因如下：</p>\n<ul>\n<li>绝对值函数与内层函数定义域相同，作闵可夫斯基和后，斜率为 <span class=\"math inline\">\\(1\\)</span> 的右侧线段会将 <span class=\"math inline\">\\(f_{v,d-w&#39;}\\)</span> 中原有的 <span class=\"math inline\">\\(&gt;1\\)</span> 的部分『挤』出定义域，故可以将其直接删除。</li>\n<li>斜率为 <span class=\"math inline\">\\(1\\)</span> 的部分，虽然对内层函数中极值点无贡献，但在外层函数中极值点可能向右偏移，此时会对其产生影响，需要维护。</li>\n</ul>\n<p>容易发现由于 <span class=\"math inline\">\\(w&#39;\\)</span> 的取值上限是 <span class=\"math inline\">\\(d\\)</span>，但 <span class=\"math inline\">\\(d\\)</span> 没有上界，所以每个内层函数的右侧都一定是一条斜率为 <span class=\"math inline\">\\(1\\)</span> 的射线；也就是说，每个外层函数一定有（儿子个数）个拐点（堆中元素），弹出这么多个就可以删除外层函数中斜率 <span class=\"math inline\">\\(&gt;1\\)</span> 的线段，顺便找到斜率为 <span class=\"math inline\">\\(0\\)</span> 和 <span class=\"math inline\">\\(1\\)</span> 的线段。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\n#include &lt;ext/pb_ds/priority_queue.hpp&gt;\nconst int inf= 0x3f3f3f3f;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, m;\n    std::cin &gt;&gt; n &gt;&gt; m, n += m;\n    std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; g(n + 1);\n    auto res(0ll);\n    for (int i = 2, fa, w; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; fa &gt;&gt; w, res += w;\n        g[fa].emplace_back(i, w);\n    &#125;\n    std::vector&lt;__gnu_pbds::priority_queue&lt;long long&gt; &gt; q(n + 1);\n    std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;\n        if (g[x].empty())\n            q[x].push(0), q[x].push(0);\n        else\n            for (auto [i, w] : g[x]) &#123;\n                DFS(i);\n                for (int j = 1; j &lt; (int)g[i].size(); ++j)\n                    q[i].pop();\n                long long t1 = q[i].top(), t0;\n                q[i].pop(), t0 = q[i].top(), q[i].pop();\n                q[i].push(t1 + w), q[i].push(t0 + w);\n                q[x].join(q[i]);\n            &#125;\n        // fprintf(stderr, &quot;size(%d) = %d\\n&quot;, x, (int)q[x].size());\n        return;\n    &#125;;\n    DFS(1);\n    for (int i = 1; i &lt;= (int)g[1].size(); ++i)\n        q[1].pop();\n    for (; !q[1].empty(); q[1].pop())\n        res -= q[1].top();\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"例buy-low-sell-high\">例：Buy Low Sell High</h3>\n<p><a href=\"https://codeforces.com/problemset/problem/865/D\" class=\"uri\">https://codeforces.com/problemset/problem/865/D</a></p>\n<p>令 <span class=\"math inline\">\\(f_{i,j}\\)</span> 表示在第 <span class=\"math inline\">\\(i\\)</span> 天结束后持有 <span class=\"math inline\">\\(j\\)</span> 支股票的最大收益。则 <span class=\"math inline\">\\(f_{i,j}=\\max\\{f_{i-1,j},f_{i-1,j-1}-a_i,f_{i-1,j+1}+a_i\\}\\)</span>。</p>\n<p>（由于这里和 max 有关所以需要精细描述凹凸了）发现就是把三个（可能）经过平移的（可能）凹的函数做线性 max。虽然实际上的结论『函数在整点上是凹的』不算太显然，但是可以猜是凹的。</p>\n<p>线性 max 在 slope trick 中是不太能体现的，但我们发现这里是同一个凹函数向左上、右下平移同一个向量，希望得到新的凹函数不管是从差分角度还是图象，都能得到新函数由左上部分斜率 <span class=\"math inline\">\\(&gt;-a_i\\)</span> 的线段、两段斜率 <span class=\"math inline\">\\(=-a_i\\)</span> 的线段、右下部分斜率 <span class=\"math inline\">\\(&lt;-a_i\\)</span> 的线段组成。此外，由于向左上平移的函数有一处离开了定义域，还需将其剔除。</p>\n<p>值得注意的是，当 <span class=\"math inline\">\\(-a_i\\)</span> 比最小斜率还要小时会有变化，可以画图看一下。</p>\n<p><img src=\"2.png\" /></p>\n<p>发现定义域是相对小的（<span class=\"math inline\">\\(0\\le j\\le n\\)</span>），故用优先队列维护整个斜率序列就可以快速插入两个 <span class=\"math inline\">\\(k=-a_i\\)</span> 的线段。容易发现顶点在 <span class=\"math inline\">\\(j=0\\)</span> 处取得（从图象和定义都易知），最右侧是只买不卖的最劣方案，可以倒推。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;int&gt; a(n + 1);\n    auto res = 0ll;\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i], res -= a[i];\n    std::priority_queue&lt;int&gt; q;\n    q.push(-a[1]);\n    for (int i = 2; i &lt;= n; ++i)\n        if (a[i] &lt; -q.top())\n            q.push(-a[i]);\n        else\n            q.pop(), q.push(-a[i]), q.push(-a[i]);\n    for (; !q.empty(); res -= q.top(), q.pop());\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n",
            "tags": [
                "DP",
                "反悔贪心",
                "DP 优化"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20250526/",
            "url": "https://xsc062.netlify.app/20250526/",
            "title": "多维 DP",
            "date_published": "2025-05-26T07:05:53.000Z",
            "content_html": "<p>上楼听到有人在哼 <em>Climbing on the Trees</em>，上来听到隔壁班在放 <em>Burn the House Down</em>，果然春天是 AJR 的季节（）</p>\n<span id=\"more\"></span>\n<hr />\n<p>主要是多维 DP 特有的优化！</p>\n<h2 id=\"分步转移\">分步转移</h2>\n<p>如果状态的若干维之间只存在很弱的联系，可以分步转移每一维。</p>\n<p>假设有二维状态转移 <span class=\"math inline\">\\((a,b)\\to (a&#39;,b&#39;)\\)</span>，『很弱的联系』举例：</p>\n<ol type=\"1\">\n<li>DP 值中包含 <span class=\"math inline\">\\(w(a&#39;,b&#39;)\\)</span>，但不包含诸如 <span class=\"math inline\">\\(w(a&#39;,b),w(a,b&#39;)\\)</span> 之类。也即该值的求解不依赖于上一个状态、不依赖于转移。</li>\n<li>对于 <span class=\"math inline\">\\((a&#39;,b&#39;)\\)</span> 的取值有限制，比如 <span class=\"math inline\">\\((114,514)\\)</span> 不能取到之类。显然这也不依赖于上一个状态、不依赖于转移。</li>\n<li>符号限制（如转移间为 <span class=\"math inline\">\\(+\\)</span>，状态间为 <span class=\"math inline\">\\(\\times\\)</span> 之类），在计数中常出现。</li>\n<li>一个变动的时候另一个必须也一起动。</li>\n</ol>\n<p>注意！有的时候一个状态也可以拆成两个状态，然后分步转移。</p>\n<hr />\n<h3 id=\"例题经典题\">例题：经典题</h3>\n<blockquote>\n<p>给定 <span class=\"math inline\">\\(w_{N\\times M}\\)</span>，求 <span class=\"math inline\">\\((A,B)_{1\\sim K}\\)</span>，最大化 <span class=\"math inline\">\\(\\sum\\limits_{i=1}^K w_{A_i,B_i}+w_{A_{i-1},A_i}+w_{B_{i-1},B_i}\\)</span> 的值。</p>\n</blockquote>\n<p>发现如果设 <span class=\"math inline\">\\(f_{i,a,b}\\)</span> 表示 <span class=\"math inline\">\\((A,B)_i=(a,b)\\)</span> 的话，转移就会达到可观的 <span class=\"math inline\">\\(O(N\\times M)\\)</span>；但发现里面的 <span class=\"math inline\">\\(A\\)</span> 和 <span class=\"math inline\">\\(B\\)</span> 其实没什么有机联系；唯一的联系 <span class=\"math inline\">\\(w_{A_i,B_i}\\)</span>（上面『很弱的联系』中的第一、四种情况）。因此分布转移：</p>\n<p><span class=\"math display\">\\[\nf&#39;_{a&#39;,b}\\gets \\max\\limits_a f_{a,b}+w_{a&#39;,a}\\\\\nf_{a&#39;,b&#39;}\\gets \\max\\limits_b f&#39;_{a&#39;, b} + w_{b,b&#39;}+w_{a&#39;,b&#39;}\n\\]</span></p>\n<p>由此便优化转移复杂度到 <span class=\"math inline\">\\(O(N+M)\\)</span>。</p>\n<hr />\n<h3 id=\"例题彩灯晚会\">例题：彩灯晚会</h3>\n<p>goto <a href=\"/20250407/#e---kdoi-11彩灯晚会\">link</a>。</p>\n<p>Tips：发现 <span class=\"math inline\">\\(l_1,l_2\\)</span> 之间也没啥有机联系（上面『很弱的联系』中的第三、四种情况），故分步转移。</p>\n<hr />\n<h3 id=\"例题序列妙妙值\">例题：序列妙妙值</h3>\n<p><a href=\"https://uoj.ac/problem/549\" class=\"uri\">https://uoj.ac/problem/549</a></p>\n<p>朴素地，设 <span class=\"math inline\">\\(f_{i,j}\\)</span> 表示在第 <span class=\"math inline\">\\(i\\)</span> 个处分第 <span class=\"math inline\">\\(j\\)</span> 段的最大价值，显然有 <span class=\"math inline\">\\(O(k\\times n^2)\\)</span>，且并没有优化的空间。</p>\n<p>考虑利用 <span class=\"math inline\">\\(a_i\\)</span> 很小这一条件，发现上一条无法优化是因为要获取 <span class=\"math inline\">\\(sum_{i}\\)</span> 的值；那么把 <span class=\"math inline\">\\(sum_i\\)</span> 塞到状态里。设 <span class=\"math inline\">\\(f_{s&#39;,j}\\)</span> 表示 <span class=\"math inline\">\\(sum=s&#39;\\)</span> 时，分了 <span class=\"math inline\">\\(j\\)</span> 段的最大价值。同样可以 <span class=\"math inline\">\\(O(k\\cdot n^2)\\)</span>。</p>\n<p>接下来有两个理解这个优化的角度：</p>\n<ol type=\"1\">\n<li><p>从平衡角度，原问题等价于 <span class=\"math inline\">\\(O(1)\\)</span> 更新 <span class=\"math inline\">\\((s,j)\\)</span> 处的最大值，<span class=\"math inline\">\\(O(v)\\)</span> 查找 <span class=\"math inline\">\\(j-1\\)</span> 处的最大值；把 <span class=\"math inline\">\\(s\\)</span> 拆成前 <span class=\"math inline\">\\(8\\)</span> 位、后 <span class=\"math inline\">\\(8\\)</span> 位两个 part，当更新</p>\n<p>对于修改：相当于固定前 <span class=\"math inline\">\\(8\\)</span> 位 <span class=\"math inline\">\\(s\\)</span>，枚举后 <span class=\"math inline\">\\(8\\)</span> 位 <span class=\"math inline\">\\(x\\)</span>，并更新 <span class=\"math inline\">\\((s,x)\\)</span>。</p>\n对于查询：相当于固定后 <span class=\"math inline\">\\(8\\)</span> 位 <span class=\"math inline\">\\(x\\)</span>，枚举前 <span class=\"math inline\">\\(8\\)</span> 位 <span class=\"math inline\">\\(s\\)</span>，并查询 <span class=\"math inline\">\\((s,x)\\)</span>。</li>\n<li><p>从分步转移角度，由于『现时刻』的贡献是按位的，二进制状态的前 <span class=\"math inline\">\\(8\\)</span> 位和后 <span class=\"math inline\">\\(8\\)</span> 位没啥有机联系，故直接拆开，先转移前 <span class=\"math inline\">\\(8\\)</span> 位，再转移后 <span class=\"math inline\">\\(8\\)</span> 位。</p></li>\n</ol>\n<p>这样就被优化为 <span class=\"math inline\">\\(O(k\\cdot n\\times \\sqrt v)\\)</span>。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxv = 1 &lt;&lt; 8;\nconst int inf = 0x3f3f3f3f;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, k;\n    std::cin &gt;&gt; n &gt;&gt; k;\n    using arr = std::vector&lt;int&gt;;\n    using brr = std::vector&lt;arr&gt;;\n    using crr = std::vector&lt;brr&gt;;\n    arr s(n + 1), tag0(maxv), d0;\n    crr f(maxv, brr(maxv, arr(k + 1, inf))), g(maxv, brr(maxv, arr(k + 1, inf)));\n    f[0][0][0] = 0;\n    for (int j = 0; j &lt; maxv; ++j)\n        g[0][j][1] = j;\n    tag0[0] = 1, d0.push_back(0);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; s[i], s[i] ^= s[i - 1];\n        int p0 = s[i] &gt;&gt; 8, p1 = s[i] &amp; ((1 &lt;&lt; 8) - 1);\n        for (int j = k; j; --j) &#123;\n            for (auto a : d0)\n                f[p0][p1][j] = std::min(f[p0][p1][j], g[a][p1][j] + ((a ^ p0) &lt;&lt; 8));\n            // printf(&quot;f[%d][%d][%d] = %d\\n&quot;, p0, p1, j, f[p0][p1][j]);\n            if (j != k)\n                for (int a = 0; a &lt; maxv; ++a)\n                    g[p0][a][j + 1] = std::min(g[p0][a][j + 1], f[p0][p1][j] + (a ^ p1));\n        &#125;\n        if (i &gt;= k)\n            std::cout &lt;&lt; f[p0][p1][k] &lt;&lt; &#39; &#39;;\n        if (!tag0[p0])\n            tag0[p0] = 1, d0.push_back(p0);\n    &#125;\n    std::cout &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"割裂\">割裂</h2>\n<p>如果状态的若干维之间连无机联系都没了，可以直接把 DP 数组拆开，各自转移各自的。</p>\n<p>最后答案的拼接，可能是枚举、直接拼、用一个转移另一个之类。</p>\n<hr />\n<h3 id=\"例题经典题-1\">例题：经典题</h3>\n<blockquote>\n<p>给定 <span class=\"math inline\">\\(w_{N\\times M}\\)</span>，求 <span class=\"math inline\">\\((A,B)_{1\\sim K}\\)</span>，最大化 <span class=\"math inline\">\\(\\sum\\limits_{i=1}^K w_{A_{i-1},A_i}+w_{B_{i-1},B_i}\\)</span> 的值。</p>\n</blockquote>\n<p>先 DP 出来 <span class=\"math inline\">\\(A\\)</span>，再 DP 出来 <span class=\"math inline\">\\(B\\)</span>，直接相加即可。</p>\n<hr />\n<h3 id=\"例题mnogomet\">例题：MNOGOMET</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P7648\" class=\"uri\">https://www.luogu.com.cn/problem/P7648</a></p>\n<p>想到设 <span class=\"math inline\">\\(f_{t,i,a,b}\\)</span> 表示『过去了 <span class=\"math inline\">\\(t\\)</span> 秒，且球在球员 <span class=\"math inline\">\\(i\\)</span> 手上，且两个队伍得分分别为 <span class=\"math inline\">\\(a,b\\)</span>』的概率。那么枚举球上一次在谁手上，有美观的 <span class=\"math inline\">\\(O(T\\cdot N^2R^2)\\)</span>。</p>\n<p>发现比分变动时（上半个时刻完成射门并传球）球一定在某个队的 <span class=\"math inline\">\\(1\\)</span> 号手上；<span class=\"math inline\">\\(i\\)</span> 这一维和 <span class=\"math inline\">\\(a,b\\)</span> 也没有相互的干扰；故可以将 <span class=\"math inline\">\\(i\\)</span> 提取出来（作为对比，射门和夺球、传球都会影响 <span class=\"math inline\">\\(t\\)</span>，所以分裂出来的状态中必须包含 <span class=\"math inline\">\\(t\\)</span>）。具体地：</p>\n<ol type=\"1\">\n<li><p>令 <span class=\"math inline\">\\(g_{t,0/1,i}\\)</span> 表示『一开始球在哪个球队的 <span class=\"math inline\">\\(1\\)</span> 号，花费 <span class=\"math inline\">\\(t\\)</span> 秒，且没人射门，且球在球员 <span class=\"math inline\">\\(i\\)</span> 手上』的概率。发现可以 <span class=\"math inline\">\\(O(T\\times N^2)\\)</span> 计算。</p>\n<p>当然这里就是条件概率了。其中『一开始球在哪个球队的 <span class=\"math inline\">\\(1\\)</span> 号』就是条件。</p>\n再预处理可以得到 <span class=\"math inline\">\\(G_{t,0/1,0/1,0/1}\\)</span> 表示『一开始球在哪个球队的 <span class=\"math inline\">\\(1\\)</span> 号，花费 <span class=\"math inline\">\\(t\\)</span> 秒，哪个球队射门，（没）射进』的概率。</li>\n<li><p>令 <span class=\"math inline\">\\(f_{t,0/1,a,b}\\)</span> 表示『过去了 <span class=\"math inline\">\\(t\\)</span> 秒，球在哪个队的 <span class=\"math inline\">\\(1\\)</span> 号，且得分为 <span class=\"math inline\">\\(a,b\\)</span>』的概率。枚举距离上一次射门的时间，可以 <span class=\"math inline\">\\(O(T^2\\times R^2)\\)</span> 完成转移。</p></li>\n</ol>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, r, T;\n    std::cin &gt;&gt; n &gt;&gt; r &gt;&gt; T;\n    using arr = std::vector&lt;double&gt;;\n    using brr = std::vector&lt;arr&gt;;\n    using crr = std::vector&lt;brr&gt;;\n    brr p(2 * n + 1, arr(2)), pp(2 * n + 1, arr(2 * n + 1));\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; p[i][1], p[i][0] = 1. - p[i][1];\n        int ss, sd;\n        std::cin &gt;&gt; ss &gt;&gt; sd;\n        double P = 1. / (ss + sd + 1);\n        p[i][0] *= P, p[i][1] *= P;\n        for (int x; ss--; pp[i][x] = P)\n            std::cin &gt;&gt; x;\n        for (int x; sd--; pp[i][x + n] = P)\n            std::cin &gt;&gt; x;\n    &#125;\n    for (int i = n + 1; i &lt;= 2 * n; ++i) &#123;\n        std::cin &gt;&gt; p[i][1], p[i][0] = 1. - p[i][1];\n        int ss, sd;\n        std::cin &gt;&gt; ss &gt;&gt; sd;\n        double P = 1. / (ss + sd + 1);\n        p[i][0] *= P, p[i][1] *= P;\n        for (int x; ss--; pp[i][x + n] = P)\n            std::cin &gt;&gt; x;\n        for (int x; sd--; pp[i][x] = P)\n            std::cin &gt;&gt; x;\n    &#125;\n    brr s(T + 1, arr(2));\n    crr g(T + 1, brr(2, arr(2 * n + 1)));\n    std::vector&lt;crr&gt; G(T + 1, crr(2, brr(2, arr(2)))), f(T + 1, crr(2, brr(r + 1, arr(r + 1))));\n    g[0][0][1] = g[0][1][n + 1] = 1.;\n    for (int t = 1; t &lt;= T; ++t) &#123;\n        for (int f1 = 0; f1 &lt;= 1; ++f1)\n            for (int i = 1; i &lt;= 2 * n; ++i) &#123;\n                G[t][f1][i &gt; n][0] += g[t - 1][f1][i] * p[i][0];\n                G[t][f1][i &gt; n][1] += g[t - 1][f1][i] * p[i][1];\n                for (int j = 1; j &lt;= 2 * n; ++j)\n                    if (j != i)\n                        g[t][f1][i] += pp[j][i] * g[t - 1][f1][j];\n                // printf(&quot;spend %ds, start from %d, now at %d: %.10lf\\n&quot;, t, 1 + f1 * n, i, g[t][f1][i]);\n                s[t][f1] += g[t][f1][i];\n            &#125;\n    &#125;\n    // puts(&quot;------------------------------------&quot;);\n    // for (int t = 1; t &lt;= T; ++t) &#123;\n    //     for (int f1 = 0; f1 &lt;= 1; ++f1)\n    //         for (int f2 = 0; f2 &lt;= 1; ++f2)\n    //             for (int f3 = 0; f3 &lt;= 1; ++f3)\n    //                 printf(&quot;spend %ds, start from %d, %d shoots, STATUS: %d, P = %.10lf\\n&quot;, t, 1 + f1 * n, 1 + f2, f3, G[t][f1][f2][f3]);\n    // &#125;\n    // puts(&quot;------------------------------------&quot;);\n    f[0][0][0][0] = 1.;\n    for (int t = 0; t &lt; T; ++t)\n        for (int f1 = 0; f1 &lt;= 1; ++f1)\n            for (int a = 0; a &lt; r; ++a)\n                for (int b = 0; b &lt; r; ++b) &#123;\n                    for (int t1 = 1; t + t1 &lt;= T; ++t1) &#123;\n                        f[t + t1][0][a][b] += f[t][f1][a][b] * G[t1][f1][1][0];\n                        f[t + t1][0][a][b + 1] += f[t][f1][a][b] * G[t1][f1][1][1];\n                        f[t + t1][1][a][b] += f[t][f1][a][b] * G[t1][f1][0][0];\n                        f[t + t1][1][a + 1][b] += f[t][f1][a][b] * G[t1][f1][0][1];\n                        if (t + t1 == T)\n                            f[T][0][a][b] += f[t][f1][a][b] * s[t1][f1];\n                    &#125;\n                &#125;\n    // for (int t = 0; t &lt;= T; ++t)\n    //     for (int f1 = 0; f1 &lt;= 1; ++f1)\n    //         for (int a = 0; a &lt;= r; ++a)\n    //             for (int b = 0; b &lt;= r; ++b)\n    //                 if (f[t][f1][a][b] &gt; 1e-10)\n    //                     printf(&quot;%ds later, %d shoots, %d : %d, P = %.10lf\\n&quot;, t, 1 + !f1 * n, a, b, f[t][f1][a][b]);\n    std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(10);\n    for (int a = 0; a &lt;= r; ++a) &#123;\n        for (int b = 0; b &lt;= r; ++b) &#123;\n            if (a == r &amp;&amp; b == r)\n                continue;\n            double res(0.);\n            if (a == r)\n                for (int t = r; t &lt;= T; ++t)\n                    res += f[t][1][r][b];\n            else if (b == r)\n                for (int t = r; t &lt;= T; ++t)\n                    res += f[t][0][a][r];\n            else\n                res = f[T][0][a][b] + f[T][1][a][b];\n            std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n        &#125;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n",
            "tags": [
                "DP",
                "DP 优化"
            ]
        }
    ]
}