<?xml version="1.0"?>
<rss version="2.0">
    <channel>
        <title> • Posts by &#34;支配对&#34; tag</title>
        <link>https://xsc062.netlify.app</link>
        <description></description>
        <language>zh-CN</language>
        <pubDate>Sat, 30 Aug 2025 11:47:08 +0800</pubDate>
        <lastBuildDate>Sat, 30 Aug 2025 11:47:08 +0800</lastBuildDate>
        <category>并查集</category>
        <category>斜率优化</category>
        <category>悬线法</category>
        <category>哈希</category>
        <category>字典树</category>
        <category>DP</category>
        <category>单调队列</category>
        <category>分治</category>
        <category>二分图</category>
        <category>CRT / exCRT</category>
        <category>排列组合</category>
        <category>网络流</category>
        <category>费用流</category>
        <category>二分</category>
        <category>上下界网络流</category>
        <category>容斥原理</category>
        <category>线段树</category>
        <category>树状数组</category>
        <category>区间 DP</category>
        <category>构造</category>
        <category>Tarjan</category>
        <category>数据结构</category>
        <category>下饭</category>
        <category>LCA</category>
        <category>倍增</category>
        <category>鸽巢原理</category>
        <category>概率期望</category>
        <category>调和级数</category>
        <category>差分</category>
        <category>思维</category>
        <category>树形 DP</category>
        <category>最小生成树</category>
        <category>SAM</category>
        <category>状压</category>
        <category>分块</category>
        <category>可持久化</category>
        <category>笛卡尔树</category>
        <category>高维前缀和</category>
        <category>闲话</category>
        <category>欧拉回路</category>
        <category>树链剖分</category>
        <category>长链剖分</category>
        <category>KMP</category>
        <category>border</category>
        <category>字符串</category>
        <category>AC 自动机</category>
        <category>SA</category>
        <category>数学</category>
        <category>树上差分</category>
        <category>FWT</category>
        <category>堆</category>
        <category>树的重心</category>
        <category>二项式定理</category>
        <category>二项式反演</category>
        <category>贪心</category>
        <category>均摊</category>
        <category>计数</category>
        <category>优化建图</category>
        <category>反悔贪心</category>
        <category>调整法</category>
        <category>背包</category>
        <category>博弈论</category>
        <category>DP 优化</category>
        <category>虚树</category>
        <category>点分治</category>
        <category>WQS 二分</category>
        <category>闵可夫斯基和</category>
        <category>slope trick</category>
        <category>四边形不等式</category>
        <category>暴力</category>
        <category>状压 DP</category>
        <category>组合数学</category>
        <category>支配对</category>
        <category>DDP</category>
        <category>平衡树</category>
        <category>容斥</category>
        <category>猫树</category>
        <category>Kruskal 重构树</category>
        <category>李超线段树</category>
        <item>
            <guid isPermalink="true">https://xsc062.netlify.app/20250830/</guid>
            <title>学习笔记 支配对</title>
            <link>https://xsc062.netlify.app/20250830/</link>
            <category>支配对</category>
            <pubDate>Sat, 30 Aug 2025 11:47:08 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;一种贪心思想，很符合直觉，又有点像乱搞&lt;/p&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;考虑一类点对统计问题，形如给定 &lt;span class=&#34;math inline&#34;&gt;\([l,r]\)&lt;/span&gt;，对于 &lt;span class=&#34;math inline&#34;&gt;\([l\le x\le y\le r]\)&lt;/span&gt;，你需要寻找满足某个限制的 &lt;span class=&#34;math inline&#34;&gt;\((x,y)\)&lt;/span&gt; 数量，或者是所有 &lt;span class=&#34;math inline&#34;&gt;\((x,y)\)&lt;/span&gt; 的最大权值&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果存在 &lt;span class=&#34;math inline&#34;&gt;\([x_1,y_1]\subset [x_2,y_2]\)&lt;/span&gt; 且 &lt;span class=&#34;math inline&#34;&gt;\([x_1,y_1]\)&lt;/span&gt; 满足限制 / 贡献更大，就可以只保留 &lt;span class=&#34;math inline&#34;&gt;\([x_1,y_1]\)&lt;/span&gt;&lt;/p&gt;
因为统计了 &lt;span class=&#34;math inline&#34;&gt;\([x_2,y_2]\)&lt;/span&gt; 就必须要统计 &lt;span class=&#34;math inline&#34;&gt;\([x_1,y_1]\)&lt;/span&gt;，反之则不一定成立。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;题目会给出一些性质使得最终保留下来的 &lt;span class=&#34;math inline&#34;&gt;\([x_1,y_1]\)&lt;/span&gt; 的数量不多&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;树上支配对-第一类支配对&#34;&gt;树上支配对 / 第一类支配对&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;这类问题的特征很明显，多次询问，给定一个编号区间，统计树上点对相关信息。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;会想到点分治、dsu on tree 这两个工具，其中点分治处理距离问题更方便，dsu on tree 更常用来处理 LCA 问题&lt;/p&gt;
固定当前的根之后，钦定支配对来自两个不同子树（注意根自身参与形成支配对的情况），那么共有 &lt;span class=&#34;math inline&#34;&gt;\(O(n\log n)\)&lt;/span&gt; 对支配对&lt;/li&gt;
&lt;li&gt;&lt;p&gt;先用这两种方法在树上找到支配对，就可以把询问离线下来做扫描线之类的了&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本质是利用 LCA 的树上性质，以及点分、dsu on tree 只用统计 &lt;span class=&#34;math inline&#34;&gt;\(O(n\log n)\)&lt;/span&gt; 个单侧点，同时对于每个单侧点只存在 &lt;span class=&#34;math inline&#34;&gt;\(O(1)\)&lt;/span&gt; 个相应的前驱、后继点达到 LCA 找到 &lt;span class=&#34;math inline&#34;&gt;\(O(n\log n)\)&lt;/span&gt; 个支配对&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;d---rldcot&#34;&gt;D - rldcot&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P7880&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P7880&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;若存在 &lt;span class=&#34;math inline&#34;&gt;\((x_1,y_1)\)&lt;/span&gt; 和 &lt;span class=&#34;math inline&#34;&gt;\((x_2,y_2)\)&lt;/span&gt; 拥有相同的 LCA，那么认为 &lt;span class=&#34;math inline&#34;&gt;\((x_1,y_1)\)&lt;/span&gt; 支配了 &lt;span class=&#34;math inline&#34;&gt;\((x_2,y_2)\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;树有根，故需要 dsu on tree&lt;/li&gt;
&lt;li&gt;用一个 set 处理前驱、后继的查询，然后就是正常的 dsu on tree 了&lt;/li&gt;
&lt;li&gt;离线下来扫描线，树状数组实时维护每个颜色（离散化一下）最靠右的区间即可&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    using ll = long long;
    int n, m;
    std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
    std::vector&amp;lt;std::vector&amp;lt;std::pair&amp;lt;int, int&amp;gt; &amp;gt; &amp;gt; g(n + 1);
    for (int i = 1, x, y, w; i &amp;lt; n; ++i) &amp;#123;
        std::cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; y &amp;gt;&amp;gt; w;
        g[x].emplace_back(y, w);
        g[y].emplace_back(x, w);
    &amp;#125;
    int tot = 0;
    std::vector&amp;lt;ll&amp;gt; dep(n + 1);
    std::unordered_map&amp;lt;ll, int&amp;gt; tab;
    std::vector&amp;lt;int&amp;gt; siz(n + 1), son(n + 1), col(n + 1);
    std::function&amp;lt;void(int, int)&amp;gt; DFS = [&amp;amp;](int x, int fa) &amp;#123;
        siz[x] = 1;
        if (!tab.count(dep[x]))
            tab[dep[x]] = ++tot;
        col[x] = tab[dep[x]];
        for (auto [i, w] : g[x])
            if (i != fa) &amp;#123;
                dep[i] = dep[x] + w;
                DFS(i, x);
                siz[x] += siz[i];
                if (siz[i] &amp;gt; siz[son[x]])
                    son[x] = i;
            &amp;#125;
        return;
    &amp;#125;;
    DFS(1, -1);
    std::vector&amp;lt;std::vector&amp;lt;std::pair&amp;lt;int, int&amp;gt; &amp;gt; &amp;gt; u(n + 1);
    std::function&amp;lt;void(int, int, int, std::set&amp;lt;int&amp;gt; &amp;amp;)&amp;gt; DFS2 = [&amp;amp;](int col, int x, int fa, std::set&amp;lt;int&amp;gt; &amp;amp;t) &amp;#123;
        auto p = t.lower_bound(x);
        if (col == -1)
            t.insert(x);
        else &amp;#123;
            if (p != t.begin())
                u[x].emplace_back(*std::prev(p), col );
            if (p != t.end())
                u[*p].emplace_back(x, col);
        &amp;#125;
        for (auto [i, w] : g[x])
            if (i != fa)
                DFS2(col, i, x, t);
        return;
    &amp;#125;;
    std::function&amp;lt;void(int, int, std::set&amp;lt;int&amp;gt; &amp;amp;)&amp;gt; DFS1 = [&amp;amp;](int x, int fa, std::set&amp;lt;int&amp;gt; &amp;amp;t) &amp;#123;
        if (son[x])
            DFS1(son[x], x, t);
        for (auto [i, w] : g[x])
            if (i != fa &amp;amp;&amp;amp; i != son[x]) &amp;#123;
                std::set&amp;lt;int&amp;gt; nt;
                DFS1(i, x, nt);
            &amp;#125;
        t.insert(x);
        u[x].emplace_back(x, col[x]);
        for (auto [i, w] : g[x])
            if (i != fa &amp;amp;&amp;amp; i != son[x])
                DFS2(col[x], i, x, t), DFS2(-1, i, x, t);
        return;
    &amp;#125;;
    &amp;#123;
        std::set&amp;lt;int&amp;gt; t;
        DFS1(1, -1, t);
    &amp;#125;
    std::vector&amp;lt;int&amp;gt; res(m + 1);
    std::vector&amp;lt;std::vector&amp;lt;std::pair&amp;lt;int, int&amp;gt; &amp;gt; &amp;gt; t(n + 1);
    for (int i = 1, l, r; i &amp;lt;= m; ++i) &amp;#123;
        std::cin &amp;gt;&amp;gt; l &amp;gt;&amp;gt; r;
        t[r].emplace_back(l, i);
    &amp;#125;
    std::vector&amp;lt;int&amp;gt; bit(n + 1), la(tot + 1);
    auto lowbit = [](int x) &amp;#123;
        return x &amp;amp; -x;
    &amp;#125;;
    auto add = [&amp;amp;](int x, int v) &amp;#123;
        for (; x &amp;lt;= n; x += lowbit(x))
            bit[x] += v;
        return;
    &amp;#125;;
    auto ask = [&amp;amp;](int x) &amp;#123;
        int res = 0;
        for (; x; x -= lowbit(x))
            res += bit[x];
        return res;
    &amp;#125;;
    for (int r = 1; r &amp;lt;= n; ++r) &amp;#123;
        for (auto [l, c] : u[r])
            if (l &amp;gt; la[c]) &amp;#123;
                if (la[c])
                    add(la[c], -1);
                add(l, 1), la[c] = l;
            &amp;#125;
        for (auto [l, id] : t[r])
            res[id] = ask(r) - ask(l - 1);
    &amp;#125;
    for (int i = 1; i &amp;lt;= m; ++i)
        std::cout &amp;lt;&amp;lt; res[i] &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;e---铃原露露&#34;&gt;E - 铃原露露&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P8528&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P8528&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;考虑一下支配关系在哪里，固定一个 LCA &lt;span class=&#34;math inline&#34;&gt;\(z\)&lt;/span&gt;，讨论 &lt;span class=&#34;math inline&#34;&gt;\(a_z\)&lt;/span&gt; 与 &lt;span class=&#34;math inline&#34;&gt;\(a_x,a_y\)&lt;/span&gt; 的大小关系给 &lt;span class=&#34;math inline&#34;&gt;\([1,a_x]\)&lt;/span&gt; 间的 &lt;span class=&#34;math inline&#34;&gt;\(l\)&lt;/span&gt; 带来的限制：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class=&#34;math inline&#34;&gt;\(a_z\in[a_x,a_y]\)&lt;/span&gt;，&lt;span class=&#34;math inline&#34;&gt;\((x,y)\)&lt;/span&gt; 总是合法，无限制。&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;math inline&#34;&gt;\(a_z&amp;lt;a_x\)&lt;/span&gt;，对于 &lt;span class=&#34;math inline&#34;&gt;\(r\ge a_y\)&lt;/span&gt;，当 &lt;span class=&#34;math inline&#34;&gt;\(l\in(a_z,a_x]\)&lt;/span&gt; 时，&lt;span class=&#34;math inline&#34;&gt;\((x,y)\)&lt;/span&gt; 非法。&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;math inline&#34;&gt;\(a_z&amp;gt;a_y\)&lt;/span&gt;，当 &lt;span class=&#34;math inline&#34;&gt;\(r\in[a_y,a_z)\)&lt;/span&gt; 时，&lt;span class=&#34;math inline&#34;&gt;\((x,y)\)&lt;/span&gt; 总是非法。此时所有 &lt;span class=&#34;math inline&#34;&gt;\(l\in[1,a_x]\)&lt;/span&gt; 不可选。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;发现固定 &lt;span class=&#34;math inline&#34;&gt;\(a_z,a_x\)&lt;/span&gt;，那么当 &lt;span class=&#34;math inline&#34;&gt;\(a_y\)&lt;/span&gt; 越靠近 &lt;span class=&#34;math inline&#34;&gt;\(a_x\)&lt;/span&gt; 时给出的限制越紧，反之亦然，就可以得到这样的支配关系&lt;/li&gt;
&lt;li&gt;容易发现当 &lt;span class=&#34;math inline&#34;&gt;\(a_z\notin [a_x,a_y]\)&lt;/span&gt; 时，&lt;span class=&#34;math inline&#34;&gt;\((x,y)\)&lt;/span&gt; 不合法；故只需要在 dsu on tree 上找到 &lt;span class=&#34;math inline&#34;&gt;\(a_x\)&lt;/span&gt; 的前驱、后继并统计支配对即可&lt;/li&gt;
&lt;li&gt;&lt;p&gt;考虑询问，发现需要维护区间加、区间历史 0 个数，后者是经典 trick，是好做的。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;历史标记的下传需要格外注意一下，应该只保证标记期间存在 0 的区间拥有懒标记；具体地，&lt;strong&gt;只应将其下传到和当前区间最小值相同的子区间&lt;/strong&gt;（具体可以看代码），容易证明是对的。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int maxn = 2e5 + 5;
struct node &amp;#123;
    long long s;
    int l, r, u, c, d, d1;
    node operator+ (const node q) const &amp;#123;
        node res;
        res.s = s + q.s;
        res.l = l, res.r = q.r;
        res.u = std::min(u, q.u);
        res.d = res.d1 = res.c = 0;
        if (u == res.u)
            res.c = c;
        if (q.u == res.u)
            res.c += q.c;
        return res;
    &amp;#125;
&amp;#125; t[maxn &amp;lt;&amp;lt; 2];
#define lt (p &amp;lt;&amp;lt; 1)
#define rt (lt | 1)
void bld(int p, int l, int r) &amp;#123;
    t[p].c = r - l + 1;
    t[p].l = l, t[p].r = r;
    if (l == r)
        return;
    int mid = (l + r) &amp;gt;&amp;gt; 1;
    bld(lt, l, mid), bld(rt, mid + 1, r);
    return;
&amp;#125;
void pushdown(int p) &amp;#123;
    if (t[p].d) &amp;#123;
        t[lt].d += t[p].d, t[lt].u += t[p].d;
        t[rt].d += t[p].d, t[rt].u += t[p].d;
        t[p].d = 0;
    &amp;#125;
    if (t[p].d1) &amp;#123;
        if (t[lt].u == t[p].u) &amp;#123;
            t[lt].s += (long long)t[lt].c * t[p].d1;
            t[lt].d1 += t[p].d1;
        &amp;#125;
        if (t[rt].u == t[p].u) &amp;#123;
            t[rt].s += (long long)t[rt].c * t[p].d1;
            t[rt].d1 += t[p].d1;
        &amp;#125;
        t[p].d1 = 0;
    &amp;#125;
    return;
&amp;#125;
void add(int p, int l, int r, int v) &amp;#123;
    if (l &amp;lt;= t[p].l &amp;amp;&amp;amp; t[p].r &amp;lt;= r) &amp;#123;
        t[p].d += v, t[p].u += v;
        return;
    &amp;#125;
    pushdown(p);
    int mid = (t[p].l + t[p].r) &amp;gt;&amp;gt; 1;
    if (l &amp;lt;= mid)
        add(lt, l, r, v);
    if (r &amp;gt; mid)
        add(rt, l, r, v);
    t[p] = t[lt] + t[rt];
    return;
&amp;#125;
void upd(int p, int l, int r) &amp;#123;
    if (l &amp;lt;= t[p].l &amp;amp;&amp;amp; t[p].r &amp;lt;= r) &amp;#123;
        if (!t[p].u)
            t[p].s += t[p].c, ++t[p].d1;
        return;
    &amp;#125;
    pushdown(p);
    int mid = (t[p].l + t[p].r) &amp;gt;&amp;gt; 1;
    if (l &amp;lt;= mid)
        upd(lt, l, r);
    if (r &amp;gt; mid)
        upd(rt, l, r);
    t[p] = t[lt] + t[rt];
    return;
&amp;#125;
long long ask(int p, int l, int r) &amp;#123;
    if (l &amp;lt;= t[p].l &amp;amp;&amp;amp; t[p].r &amp;lt;= r)
        return t[p].s;
    pushdown(p);
    auto res(0ll);
    int mid = (t[p].l + t[p].r) &amp;gt;&amp;gt; 1;
    if (l &amp;lt;= mid)
        res = ask(lt, l, r);
    if (r &amp;gt; mid)
        res += ask(rt, l, r);
    return res;
&amp;#125;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, m;
    std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
    std::vector&amp;lt;int&amp;gt; a(n + 1);
    for (int i = 1; i &amp;lt;= n; ++i)
        std::cin &amp;gt;&amp;gt; a[i];
    std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; g(n + 1); 
    for (int i = 2, x; i &amp;lt;= n; ++i)
        std::cin &amp;gt;&amp;gt; x, g[x].push_back(i);
    std::vector&amp;lt;int&amp;gt; siz(n + 1), son(n + 1);
    std::function&amp;lt;void(int)&amp;gt; DFS = [&amp;amp;](int x) &amp;#123;
        siz[x] = 1;
        for (auto i : g[x]) &amp;#123;
            DFS(i);
            siz[x] += siz[i];
            if (siz[i] &amp;gt; siz[son[x]])
                son[x] = i;
        &amp;#125;
        return;
    &amp;#125;;
    DFS(1);
    std::vector&amp;lt;std::vector&amp;lt;std::pair&amp;lt;int, int&amp;gt; &amp;gt; &amp;gt; u1(n + 1), u2(n + 1);
    std::function&amp;lt;void(int, int, std::set&amp;lt;int&amp;gt; &amp;amp;)&amp;gt; DFS2 = [&amp;amp;](int col, int x, std::set&amp;lt;int&amp;gt; &amp;amp;t) &amp;#123;
        auto p = t.lower_bound(a[x]);
        if (col == -1)
            t.insert(a[x]);
        else &amp;#123;
            if (p != t.begin()) &amp;#123;
                int y = *std::prev(p);
                if (col &amp;lt; y)
                    u1[a[x]].emplace_back(col + 1, y);
                else if (col &amp;gt; a[x]) &amp;#123;
                    u1[a[x]].emplace_back(1, y);
                    u2[col].emplace_back(1, y);
                &amp;#125;
            &amp;#125;
            if (p != t.end()) &amp;#123;
                int y = *p;
                if (col &amp;lt; a[x])
                    u1[y].emplace_back(col + 1, a[x]);
                else if (col &amp;gt; y) &amp;#123;
                    u1[y].emplace_back(1, a[x]);
                    u2[col].emplace_back(1, a[x]);
                &amp;#125;
            &amp;#125;
        &amp;#125;
        for (auto i : g[x])
            DFS2(col, i, t);
        return;
    &amp;#125;;
    std::function&amp;lt;void(int, std::set&amp;lt;int&amp;gt; &amp;amp;)&amp;gt; DFS1 = [&amp;amp;](int x, std::set&amp;lt;int&amp;gt; &amp;amp;t) &amp;#123;
        if (son[x])
            DFS1(son[x], t);
        for (auto i : g[x])
            if (i != son[x]) &amp;#123;
                std::set&amp;lt;int&amp;gt; nt;
                DFS1(i, nt);
            &amp;#125;
        t.insert(a[x]);
        for (auto i : g[x])
            if (i != son[x])
                DFS2(a[x], i, t), DFS2(-1, i, t);
        return;
    &amp;#125;;
    &amp;#123;
        std::set&amp;lt;int&amp;gt; t;
        DFS1(1, t);
    &amp;#125;
    std::vector&amp;lt;long long&amp;gt; res(m + 1);
    std::vector&amp;lt;std::vector&amp;lt;std::pair&amp;lt;int, int&amp;gt; &amp;gt; &amp;gt; t(n + 1);
    for (int i = 1, l, r; i &amp;lt;= m; ++i) &amp;#123;
        std::cin &amp;gt;&amp;gt; l &amp;gt;&amp;gt; r;
        t[r].emplace_back(l, i);
    &amp;#125;
    bld(1, 1, n);
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        for (auto [l, r] : u1[i])
            add(1, l, r, 1);
        for (auto [l, r] : u2[i])
            add(1, l, r, -1);
        upd(1, 1, i);
        for (auto [l, id] : t[i])
            res[id] = ask(1, l, i);
    &amp;#125;
    for (int i = 1; i &amp;lt;= m; ++i)
        std::cout &amp;lt;&amp;lt; res[i] &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://xsc062.netlify.app/20250809/</guid>
            <title>近期杂题</title>
            <link>https://xsc062.netlify.app/20250809/</link>
            <category>字典树</category>
            <category>字符串</category>
            <category>组合数学</category>
            <category>支配对</category>
            <pubDate>Sat, 09 Aug 2025 12:33:17 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;这段时间比赛的一些题 和 nKessi、duanyu 讲的题目。太偏计数、数学的基本上没办法做了。&lt;/p&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;a.-出关&#34;&gt;A. 出关&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://222.180.160.110:61235/contest/6462/problem/1&#34; class=&#34;uri&#34;&gt;http://222.180.160.110:61235/contest/6462/problem/1&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定 &lt;span class=&#34;math inline&#34;&gt;\(s\)&lt;/span&gt;，对于一个空串，任意利用下列三种操作，使其变为 &lt;span class=&#34;math inline&#34;&gt;\(s\)&lt;/span&gt;，求最小代价：&lt;/p&gt;
&lt;ol type=&#34;1&#34;&gt;
&lt;li&gt;在末尾添加字符 &lt;span class=&#34;math inline&#34;&gt;\(c\)&lt;/span&gt;，代价为 &lt;span class=&#34;math inline&#34;&gt;\(t_{0,c}\)&lt;/span&gt;；&lt;/li&gt;
&lt;li&gt;复制整个字符串并粘贴在末尾，代价为 &lt;span class=&#34;math inline&#34;&gt;\(t_1\)&lt;/span&gt;；&lt;/li&gt;
&lt;li&gt;删除末尾字符，代价为 &lt;span class=&#34;math inline&#34;&gt;\(t_2\)&lt;/span&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(|s|\le 10^6\)&lt;/span&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可以预处理出对于每个 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 结尾，最多可以复制到哪个地方，发现要求 &lt;span class=&#34;math inline&#34;&gt;\(z_i=lcp(s_{1\dots n},s_{i+1\dots n})\)&lt;/span&gt;。那么一个 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 的最远转移点 &lt;span class=&#34;math inline&#34;&gt;\(r_i=i+z_{i+1}\)&lt;/span&gt;，用单调队列就能维护，会 exkmp 就能线性；&lt;/p&gt;
&lt;p&gt;否则可以二分 + 哈希多个 log，后面也有理由偷懒用优先队列了。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int p = 31;
const int mod = 998244353;
int main() &amp;#123;
    std::freopen(&amp;quot;laozi.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;laozi.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
    std::string s;
    std::cin &amp;gt;&amp;gt; s;
    int n = (int)s.length(), t1, t2;
    std::vector&amp;lt;long long&amp;gt; h(n + 1), base(n + 1);
    std::vector&amp;lt;int&amp;gt; a(n + 1), t0(27), z(n + 1), r(n + 1);
    base[0] = 1ll;
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        a[i] = s[i - 1] - &amp;#39;a&amp;#39; + 1;
        h[i] = (h[i - 1] * p + a[i]) % mod;
        base[i] = base[i - 1] * p % mod;
    &amp;#125;
    auto gethash = [&amp;amp;](int l, int r) &amp;#123;
        return (h[r] - h[l - 1] * base[r - l + 1] % mod + mod) % mod;
    &amp;#125;;
    for (int i = 1; i &amp;lt;= n; ++i)
        for (int l = 1, r = std::min(i - 1, n - i + 1), mid; l &amp;lt;= r; ) &amp;#123;
            mid = (l + r) &amp;gt;&amp;gt; 1;
            if (gethash(1, mid) == gethash(i, i + mid - 1))
                z[i] = mid, l = mid + 1;
            else
                r = mid - 1;
        &amp;#125;
    for (int i = 1; i &amp;lt; n; ++i)
        r[i] = i + std::min(i, z[i + 1]);
    for (int i = 1; i &amp;lt;= 26; ++i)
        std::cin &amp;gt;&amp;gt; t0[i];
    std::cin &amp;gt;&amp;gt; t1 &amp;gt;&amp;gt; t2;
    std::vector&amp;lt;long long&amp;gt; f(n + 1);
    std::priority_queue&amp;lt;std::pair&amp;lt;long long, int&amp;gt; &amp;gt; q;
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        f[i] = f[i - 1] + t0[a[i]];
        for (; !q.empty() &amp;amp;&amp;amp; r[q.top().second] &amp;lt; i; q.pop());
        if (!q.empty())
            f[i] = std::min(f[i], t1 - q.top().first - (long long)t2 * i);
        if (i != n)
            q.emplace(-(f[i] + 2ll * t2 * i), i);
    &amp;#125;
    std::cout &amp;lt;&amp;lt; f[n] &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;d.-非攻&#34;&gt;D. 非攻&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://222.180.160.110:61235/contest/6462/problem/4&#34; class=&#34;uri&#34;&gt;http://222.180.160.110:61235/contest/6462/problem/4&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定 &lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt;，对于一个 &lt;span class=&#34;math inline&#34;&gt;\(1\sim n\)&lt;/span&gt; 的排列，使用最小的交换次数使得其单增。在该前提下，定义代价为每次交换的两个数之积。对于所有 &lt;span class=&#34;math inline&#34;&gt;\(n!\)&lt;/span&gt; 个排列，计算最小代价之和。&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(n\le 10^7\)&lt;/span&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;转化成，把 &lt;span class=&#34;math inline&#34;&gt;\(1\sim n\)&lt;/span&gt; 分成无标号的若干组，每组的代价是 最小值 &lt;span class=&#34;math inline&#34;&gt;\(\times\)&lt;/span&gt; 其他元素的和，还有一个项链问题的系数，发现组间的符号是求和，考虑计算贡献。&lt;/p&gt;
&lt;p&gt;枚举 &lt;span class=&#34;math inline&#34;&gt;\(i,j\)&lt;/span&gt; 并钦定两个同属一个环，且 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 为最小值，枚举环大小 &lt;span class=&#34;math inline&#34;&gt;\(s+2\)&lt;/span&gt;，那么有：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
\begin{aligned}
res&amp;amp;=\sum_{i=1}^{n-1}\sum_{j=i+1}^n i\cdot j \cdot \sum_{s=0}^{n-i-1}\binom{n-i-1}s \cdot (s+1)!\cdot (n-s-2)!\\
&amp;amp;=\sum_{i=1}^{n-1}i\cdot \dfrac {(i+n+1)(n-i)}2 \cdot \sum_{s=0}^{n-i-1}\binom{n-i-1}s\cdot (s+1)!\cdot (n-s-2)!\\
&amp;amp;=\frac 12\times\sum_{i=1}^{n-1}i\cdot (i+n+1)\cdot (n-i)!\cdot\sum_{s=0}^{n-i-1}\dfrac {(s + 1)\cdot (n-s-2)!}{(n-i-1-s)!}\\
\end{aligned}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;令 &lt;span class=&#34;math inline&#34;&gt;\(T=n-i-1\)&lt;/span&gt;，发现我们需要快速计算 &lt;span class=&#34;math inline&#34;&gt;\(f_T=\sum\limits_{i=0}^T \dfrac{(i+1)\cdot (n-i-2)!}{(T-i)!}\)&lt;/span&gt;。记 &lt;span class=&#34;math inline&#34;&gt;\(m=n-2\)&lt;/span&gt;，变形得 &lt;span class=&#34;math inline&#34;&gt;\(f_T=(m-T)!\cdot \sum\limits_{i=0}^{T} (i+1) \binom{m-i}{m-T}\)&lt;/span&gt;，发现似乎可以简化，令 &lt;span class=&#34;math inline&#34;&gt;\(k=m-T,t=T+1\)&lt;/span&gt;，则 &lt;span class=&#34;math inline&#34;&gt;\(f_T=\sum\limits_{i=1}^T i\cdot \binom {k+t-i}k\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;然后是经典的组合意义保平安环节，即从 &lt;span class=&#34;math inline&#34;&gt;\(k+t\)&lt;/span&gt; 个有标号小球中选择一条分界线，分界线左边选一个球、右边选 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 个球的方案数。发现分界线的存在很诡异，故用分界线后方的第一个球代替，在 &lt;span class=&#34;math inline&#34;&gt;\(t+1\)&lt;/span&gt; 处新建一个虚球，规定在前 &lt;span class=&#34;math inline&#34;&gt;\(t+1\)&lt;/span&gt; 个球中选两个球，并令后一个为分界线，且令前 &lt;span class=&#34;math inline&#34;&gt;\(t+1\)&lt;/span&gt; 个中的其他球为实球，就能建立双射。在分界线后再选 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 个球，容易发现直接在范围内选 &lt;span class=&#34;math inline&#34;&gt;\(k+2\)&lt;/span&gt; 个球就能满足条件，故 &lt;span class=&#34;math inline&#34;&gt;\(f_T=(n-T-2)!\cdot \binom{t+k+1}{k+2}\)&lt;/span&gt;。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int mod = 1e9 + 7;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
    std::freopen(&amp;quot;mozi.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;mozi.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#endif
    int n;
    std::cin &amp;gt;&amp;gt; n;
    std::vector&amp;lt;long long&amp;gt; fac(n + 1), inv(n + 1), f(n + 1);
    fac[0] = inv[0] = 1ll;
    for (int i = 1; i &amp;lt;= n; ++i)
        fac[i] = fac[i - 1] * i % mod;
    auto qkp = [&amp;amp;](long long x, int y) &amp;#123;
        auto res(1ll);
        for (; y; (x *= x) %= mod, y &amp;gt;&amp;gt;= 1)
            if (y &amp;amp; 1)
                (res *= x) %= mod;
        return res;
    &amp;#125;;
    inv[n] = qkp(fac[n], mod - 2);
    for (int i = n - 1; i; --i)
        inv[i] = inv[i + 1] * (i + 1) % mod;
    auto C = [&amp;amp;](int n, int m) &amp;#123;
        return fac[n] * inv[n - m] % mod * inv[m] % mod;
    &amp;#125;;
    int m = n - 2;
    for (int T = 0; T &amp;lt;= n - 2; ++T) &amp;#123;
        int k = m - T, t = T + 1;
        f[T] = C(t + k + 1, k + 2) * fac[m - T] % mod;
    &amp;#125;
    auto res = 0ll;
    for (int i = 1; i &amp;lt;= n - 1; ++i)
        (res += (long long)i * (i + n + 1) % mod * fac[n - i] % mod * f[n - i - 1] % mod) %= mod;
    std::cout &amp;lt;&amp;lt; res * inv[2] % mod &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;c---destruction-of-walls&#34;&gt;C - Destruction of Walls&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/arc203/tasks/arc203_c&#34; class=&#34;uri&#34;&gt;https://atcoder.jp/contests/arc203/tasks/arc203_c&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;d---insert-xor&#34;&gt;D - Insert XOR&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/arc203/tasks/arc203_d&#34; class=&#34;uri&#34;&gt;https://atcoder.jp/contests/arc203/tasks/arc203_d&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;a---记忆&#34;&gt;A - 记忆&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://ac.nowcoder.com/acm/problem/274793&#34; class=&#34;uri&#34;&gt;https://ac.nowcoder.com/acm/problem/274793&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;需要意识到问题是静态的，并且不能用线段树之类维护；故考虑离线下来，想办法在 LCA 处统计答案。&lt;/p&gt;
&lt;p&gt;这个时候发现需要合并子树状态、整体异或、整体 +1，很容易想到 Trie。把 &lt;span class=&#34;math inline&#34;&gt;\(u\to\)&lt;/span&gt; LCA 的答案保存在 LCA 处，然后再用 DFS + 回溯统计 LCA &lt;span class=&#34;math inline&#34;&gt;\(\to v\)&lt;/span&gt; 的答案。想了半天没想到把上下拆开来做也是神了 😅&lt;/p&gt;
&lt;p&gt;可能比较考验对字典树的理解？做个比喻，字典树的 id 就相当于对这个点上信息的『引用』。&lt;/p&gt;
&lt;details&gt;
&lt;p&gt;字典树合并的时候可以考虑回收废弃点，不然可能有点卡。&lt;/p&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int X = 50;
const int maxn = 2e7 + 5;
long long d[maxn];
int tot, T[maxn][2], f[maxn], fa[maxn];
#define lc(p) T[p][0]
#define rc(p) T[p][1]
int find(int x) &amp;#123; return x == f[x] ? x : f[x] = find(f[x]); &amp;#125;
int newnode(void) &amp;#123;
    int p = ++tot;
    assert(p &amp;lt; maxn);
    d[p] = lc(p) = rc(p) = 0, f[p] = p;
    return p;
&amp;#125;
void pushdown(int p) &amp;#123;
    if (d[p]) &amp;#123;
        if (d[p] &amp;amp; 1)
            std::swap(lc(p), rc(p));
        d[p] &amp;gt;&amp;gt;= 1;
        if (lc(p))
            d[lc(p)] ^= d[p];
        if (rc(p))
            d[rc(p)] ^= d[p];
        d[p] = 0;
    &amp;#125;
    return;
&amp;#125;
int ins(int p, long long x) &amp;#123;
    for (int i = 0; i &amp;lt; X; ++i) &amp;#123;
        pushdown(p);
        if (!T[p][(x &amp;gt;&amp;gt; i) &amp;amp; 1]) &amp;#123;
            T[p][(x &amp;gt;&amp;gt; i) &amp;amp; 1] = newnode();
            fa[T[p][(x &amp;gt;&amp;gt; i) &amp;amp; 1]] = p;
        &amp;#125;
        p = T[p][(x &amp;gt;&amp;gt; i) &amp;amp; 1];
    &amp;#125;
    return p;
&amp;#125;
void merge(int &amp;amp;p, int q) &amp;#123;
    if (!q)
        return;
    if (!p) &amp;#123;
        p = q;
        return;
    &amp;#125;
    pushdown(p), pushdown(q);
    fa[lc(q)] = p, fa[rc(q)] = p;
    merge(lc(p), lc(q)), merge(rc(p), rc(q));
    assert(f[p] == p), assert(f[q] == q), f[q] = p;
    return;
&amp;#125;
long long ask(int p) &amp;#123;
    std::vector&amp;lt;int&amp;gt; st;
    for (int i = 0, j = p; i &amp;lt; X; ++i)
        st.push_back(fa[j]), j = fa[j];
    for (int i = 0; i &amp;lt; X; ++i)
        pushdown(st.back()), st.pop_back();
    long long x = 0;
    for (int i = 0; i &amp;lt; X; ++i) &amp;#123;
        x = x * 2 + (p == rc(fa[p]));
        p = fa[p];
    &amp;#125;
    return x;
&amp;#125;
void add(int p) &amp;#123;
    for (int i = 0; p &amp;amp;&amp;amp; i &amp;lt; X; ++i) &amp;#123;
        pushdown(p);
        std::swap(lc(p), rc(p));
        p = lc(p);
    &amp;#125;
    return;
&amp;#125;
void del(int p) &amp;#123;
    for (int i = 0; p &amp;amp;&amp;amp; i &amp;lt; X; ++i) &amp;#123;
        pushdown(p);
        std::swap(lc(p), rc(p));
        p = rc(p);
    &amp;#125;
    return;
&amp;#125;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#endif
    int n, m;
    std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
    std::vector&amp;lt;int&amp;gt; a(n + 1);
    for (int i = 1; i &amp;lt;= n; ++i)
        std::cin &amp;gt;&amp;gt; a[i];
    std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; g(n + 1);
    for (int i = 1, x, y; i &amp;lt; n; ++i) &amp;#123;
        std::cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; y;
        g[x].push_back(y), g[y].push_back(x);
    &amp;#125;
    std::vector&amp;lt;int&amp;gt; siz(n + 1), son(n + 1), top(n + 1), fa(n + 1), dep(n + 1);
    std::function&amp;lt;void(int)&amp;gt; DFS = [&amp;amp;](int x) &amp;#123;
        siz[x] = 1;
        for (auto i : g[x])
            if (i != fa[x]) &amp;#123;
                dep[i] = dep[x] + 1;
                fa[i] = x, DFS(i);
                siz[x] += siz[i];
                if (siz[i] &amp;gt; siz[son[x]])
                    son[x] = i;
            &amp;#125;
        return;
    &amp;#125;;
    DFS(1);
    DFS = [&amp;amp;](int x) &amp;#123;
        if (son[x])
            top[son[x]] = top[x], DFS(son[x]);
        for (auto i : g[x])
            if (i != son[x] &amp;amp;&amp;amp; i != fa[x])
                top[i] = i, DFS(i);
        return;
    &amp;#125;;
    top[1] = 1, DFS(1);
    auto askLCA = [&amp;amp;](int x, int y) &amp;#123;
        for (; top[x] != top[y]; x = fa[top[x]])
            if (dep[top[x]] &amp;lt; dep[top[y]])
                std::swap(x, y);
        return dep[x] &amp;lt; dep[y] ? x : y;
    &amp;#125;;
    struct node &amp;#123; long long x; int u, v; &amp;#125;;
    std::vector&amp;lt;node&amp;gt; q(m + 1);
    std::vector&amp;lt;int&amp;gt; id(m + 1);
    std::vector&amp;lt;long long&amp;gt; res(m + 1), ans(m + 1);
    std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; up(n + 1), dn(n + 1), ed(n + 1);
    for (int i = 1, x, u, v; i &amp;lt;= m; ++i) &amp;#123;
        std::cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; u &amp;gt;&amp;gt; v;
        q[i] = &amp;#123; x, u, v &amp;#125;;
        up[u].push_back(i), dn[askLCA(u, v)].push_back(i), ed[v].push_back(i);
    &amp;#125;
    std::vector&amp;lt;int&amp;gt; rt(n + 1);
    DFS = [&amp;amp;](int x) &amp;#123;
        rt[x] = newnode();
        for (auto i : g[x])
            if (i != fa[x]) &amp;#123;
                DFS(i);
                merge(rt[x], rt[i]);
            &amp;#125;
        add(rt[x]);
        for (auto i : up[x])
            id[i] = ins(rt[x], q[i].x);
        d[rt[x]] ^= a[x];
        for (auto i : dn[x])
            res[i] = ask(find(id[i]));
        return;
    &amp;#125;;
    DFS(1);
    tot = 0, rt[0] = newnode();
    std::fill(id.begin() + 1, id.end(), 0);
    DFS = [&amp;amp;](int x) &amp;#123;
        d[rt[0]] ^= a[x];
        for (auto i : dn[x])
            id[i] = ins(rt[0], res[i]);
        for (auto i : ed[x])
            ans[i] = ask(id[i]);
        add(rt[0]);
        for (auto i : g[x])
            if (i != fa[x])
                DFS(i);
        del(rt[0]);
        d[rt[0]] ^= a[x];
        return;
    &amp;#125;;
    DFS(1);
    for (int i = 1; i &amp;lt;= m; ++i)
        std::cout &amp;lt;&amp;lt; ans[i] &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;b---ビーバーの会合-2-meetings-2&#34;&gt;B - ビーバーの会合 2 (Meetings 2)&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/AT_joisc2021_j&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/AT_joisc2021_j&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;定义所求点为『局部重心』；类似树的重心，容易发现当关键点数量为奇时，只存在一个局部重心；否则，局部重心组成一条链。&lt;/p&gt;
&lt;p&gt;即对于每一个 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt;，需要找到一条最长链，使得其两端存在大小为 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 的子树（容易发现取后缀 max 即可得到真实答案）。使用点分治，精细实现容易做到 &lt;span class=&#34;math inline&#34;&gt;\(O(n\log n)\)&lt;/span&gt;。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#endif
    int n;
    std::cin &amp;gt;&amp;gt; n;
    std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; g(n + 1);
    for (int i = 1, x, y; i &amp;lt; n; ++i) &amp;#123;
        std::cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; y;
        g[x].push_back(y), g[y].push_back(x);
    &amp;#125;
    std::vector&amp;lt;int&amp;gt; mx(n + 1), siz(n + 1), p, tag(n + 1), res(n + 1, 1);
    std::function&amp;lt;void(int, int)&amp;gt; DFS1 = [&amp;amp;](int x, int fa) &amp;#123;
        p.push_back(x);
        siz[x] = 1, mx[x] = 0;
        for (auto i : g[x])
            if (!tag[i] &amp;amp;&amp;amp; i != fa) &amp;#123;
                DFS1(i, x);
                siz[x] += siz[i];
                mx[x] = std::max(mx[x], siz[i]);
            &amp;#125;
        return;
    &amp;#125;;
    auto findrt = [&amp;amp;](int x) &amp;#123;
        p.clear(), DFS1(x, -1);
        int n = (int)p.size();
        for (auto i : p)
            if (mx[i] &amp;lt;= n / 2 &amp;amp;&amp;amp; n - siz[i] &amp;lt;= n / 2)
                return i;
        assert(0);
        return -1;
    &amp;#125;;
    struct node &amp;#123;
        int u1, u2, id1, id2;
        node(): u1(0), u2(0), id1(0), id2(0) &amp;#123;&amp;#125;
        void upd(int u, int id) &amp;#123;
            if (id1 == id)
                u1 = std::max(u1, u);
            else if (u &amp;gt;= u1)
                u2 = u1, id2 = id1, u1 = u, id1 = id;
            else if (u &amp;gt;= u2)
                u2 = u, id2 = id;
            return;
        &amp;#125;
    &amp;#125;;
    std::vector&amp;lt;node&amp;gt; s(n + 1);
    std::function&amp;lt;void(int, int, int, int)&amp;gt; DFS2 = [&amp;amp;](int x, int fa, int dep, int anc) &amp;#123;
        s[siz[x]].upd(dep, anc);
        for (auto i : g[x])
            if (!tag[i] &amp;amp;&amp;amp; i != fa)
                DFS2(i, x, dep + 1, anc);
        return;
    &amp;#125;;
    std::function&amp;lt;void(int, int, int, int)&amp;gt; DFS3 = [&amp;amp;](int x, int fa, int dep, int anc) &amp;#123;
        int v = ((s[siz[x]].id1 == anc) ? s[siz[x]].u2 : s[siz[x]].u1);
        res[2 * siz[x]] = std::max(res[2 * siz[x]], dep + 1 + v);
        for (auto i : g[x])
            if (!tag[i] &amp;amp;&amp;amp; i != fa)
                DFS3(i, x, dep + 1, anc);
        return;
    &amp;#125;;
    std::function&amp;lt;void(int)&amp;gt; DFS = [&amp;amp;](int x) &amp;#123;
        x = findrt(x), p.clear(), DFS1(x, -1);
        // printf(&amp;quot;rt = %d\n&amp;quot;, x);
        for (auto i : g[x])
            if (!tag[i])
                DFS2(i, x, 1, i);
        for (int i = siz[x] - 1; i; --i) &amp;#123;
            s[i].upd(s[i + 1].u1, s[i + 1].id1);
            s[i].upd(s[i + 1].u2, s[i + 1].id2);
        &amp;#125;
        for (auto i : g[x])
            if (!tag[i])
                DFS3(i, x, 1, i);
        tag[x] = 1;
        for (int i = 1; i &amp;lt; siz[x]; ++i)
            s[i] = node();
        for (auto i : g[x])
            if (!tag[i])
                DFS(i);
        return;
    &amp;#125;;
    DFS(1);
    for (int i = (n &amp;gt;&amp;gt; 1) * 2; i; --i)
        if (i + 2 &amp;lt;= n)
            res[i] = std::max(res[i], res[i + 2]);
    for (int i = 1; i &amp;lt;= n; ++i)
        std::cout &amp;lt;&amp;lt; res[i] &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;c---the-closest-pair&#34;&gt;C - The Closest Pair&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://ac.nowcoder.com/acm/problem/262593&#34; class=&#34;uri&#34;&gt;https://ac.nowcoder.com/acm/problem/262593&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;常规方法&lt;/strong&gt;：考虑&lt;strong&gt;支配对&lt;/strong&gt;，对于每个 &lt;span class=&#34;math inline&#34;&gt;\(a_i\)&lt;/span&gt;，找到所有合法的 &lt;span class=&#34;math inline&#34;&gt;\(a_j\)&lt;/span&gt;。容易想到枚举 &lt;span class=&#34;math inline&#34;&gt;\(a_i\div a_j\)&lt;/span&gt; 来做；假设存在 &lt;span class=&#34;math inline&#34;&gt;\(a_k\div a_i=a_j\div a_i\)&lt;/span&gt; 且 &lt;span class=&#34;math inline&#34;&gt;\(k&amp;gt;j\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;不妨设 &lt;span class=&#34;math inline&#34;&gt;\(a_j=K\cdot a_i+p,a_k=K\cdot a_i+q\)&lt;/span&gt;，&lt;span class=&#34;math inline&#34;&gt;\((a_i,a_j),(a_i,a_k)\)&lt;/span&gt; 均合法当且仅当下列条件全部成立：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class=&#34;math inline&#34;&gt;\(a_j\bmod a_i&amp;gt;a_k\bmod a_i\)&lt;/span&gt;； 则 &lt;span class=&#34;math inline&#34;&gt;\(a_j&amp;gt;a_k\)&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;math inline&#34;&gt;\(a_j\bmod a_k&amp;gt;a_k\bmod a_i\)&lt;/span&gt;；又 &lt;span class=&#34;math inline&#34;&gt;\(p-q\ge a_j\bmod a_k\)&lt;/span&gt;（&lt;strong&gt;太牛了这一步&lt;/strong&gt;），即 &lt;span class=&#34;math inline&#34;&gt;\(p-q&amp;gt;q\iff p&amp;gt;2q\)&lt;/span&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;证得只关心同一个 &lt;span class=&#34;math inline&#34;&gt;\(a_j\div a_i\)&lt;/span&gt; 时的支配对数量为 &lt;span class=&#34;math inline&#34;&gt;\(\log n\)&lt;/span&gt; 级别；总对数 &lt;span class=&#34;math inline&#34;&gt;\(O(n\log n\ln n)\)&lt;/span&gt;。离线下来扫描线就行了。&lt;/p&gt;
&lt;details&gt;
&lt;p&gt;对着 单点修改 区间最值 想了 1h 的单 log 做法 😰 果然小脑掉线太可怕了，第二天早上重置大脑 1s 发现自己是斯波 😓&lt;/p&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int LEN = (1 &amp;lt;&amp;lt; 20);
int nec(void) &amp;#123;
    static char buf[LEN], *p = buf, *e = buf;
    if (p == e) &amp;#123;
        e = buf + fread(buf, 1, LEN, stdin);
        if (e == buf) return EOF;
        p = buf;
    &amp;#125;
    return *p++;
&amp;#125;
bool read(int &amp;amp;x) &amp;#123;
    x = 0;
    bool f = 0;
    char ch = nec();
    while (ch &amp;lt; &amp;#39;0&amp;#39; || ch &amp;gt; &amp;#39;9&amp;#39;) &amp;#123;
        if (ch == EOF) return 0;
        if (ch == &amp;#39;-&amp;#39;) f = 1;
        ch = nec();
    &amp;#125;
    while (ch &amp;gt;= &amp;#39;0&amp;#39; &amp;amp;&amp;amp; ch &amp;lt;= &amp;#39;9&amp;#39;) &amp;#123;
        x = x * 10 + ch - &amp;#39;0&amp;#39;;
        ch = nec();
    &amp;#125;
    if (f) x = -x;
    return 1;
&amp;#125;
void print(int x) &amp;#123;
    if (x &amp;lt; 0)
        putchar(&amp;#39;-&amp;#39;), x = -x;
    if (x &amp;gt;= 10) print(x / 10);
    putchar(x % 10 + &amp;#39;0&amp;#39;);
    return;
&amp;#125;
void print(int x, char ch) &amp;#123;
    print(x), putchar(ch);
    return;
&amp;#125;
const int maxn = 4e6 + 5;
struct &amp;#123; int l, r, u[2]; &amp;#125; t[maxn];
#define lt (t[p].l)
#define rt (t[p].r)
int tot[2];
void add(int &amp;amp;p, int l, int r, int x, int v, int i) &amp;#123;
    if (!p)
        p = ++tot[i], t[p].u[0] = -1, t[p].u[1] = 0x3f3f3f3f;
    if (i == 0)
        t[p].u[0] = std::max(t[p].u[0], v);
    else
        t[p].u[1] = std::min(t[p].u[1], v);
    if (l == r)
        return;
    int mid = (l + r) &amp;gt;&amp;gt; 1;
    if (x &amp;lt;= mid)
        add(lt, l, mid, x, v, i);
    else
        add(rt, mid + 1, r, x, v, i);
    return;
&amp;#125;
int ask(int p, int l, int r, int ql, int qr, int i) &amp;#123;
    if (!p || (ql &amp;lt;= l &amp;amp;&amp;amp; r &amp;lt;= qr))
        return t[p].u[i];
    int mid = (l + r) &amp;gt;&amp;gt; 1;
    if (qr &amp;lt;= mid)
        return ask(lt, l, mid, ql, qr, i);
    if (ql &amp;gt; mid)
        return ask(rt, mid + 1, r, ql, qr, i);
    if (i == 0)
        return std::max(ask(lt, l, mid, ql, qr, 0), ask(rt, mid + 1, r, ql, qr, 0));
    return std::min(ask(lt, l, mid, ql, qr, 1), ask(rt, mid + 1, r, ql, qr, 1));
&amp;#125;
#undef lt
#undef rt
int main() &amp;#123;
#ifndef ONLINE_JUDGE
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    const int m = 1e6;
    int rt[2] = &amp;#123; 0 &amp;#125;, n;
    t[0].u[0] = -1, t[0].u[1] = 0x3f3f3f3f;
    read(n);
    std::vector&amp;lt;int&amp;gt; a(n + 1);
    for (int i = 1; i &amp;lt;= n; ++i)
        read(a[i]);
    std::vector&amp;lt;std::vector&amp;lt;std::pair&amp;lt;int, int&amp;gt; &amp;gt; &amp;gt; t(n + 1);
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        if (i != 1) &amp;#123;
            for (int K = a[i]; K &amp;lt;= m; K += a[i]) &amp;#123;
                for (int mx = std::min(a[i] - 1, m - K); ; ) &amp;#123;
                    int k = ask(rt[0], 1, m, K, K + mx, 0);
                    if (k == -1)
                        break;
                    t[i].emplace_back(k, a[k] - K);
                    if (k == 1 || !(a[k] - K))
                        break;
                    mx = (a[k] - K - 1) / 2;
                &amp;#125;
            &amp;#125;
        &amp;#125;
        add(rt[0], 1, m, a[i], i, 0);
    &amp;#125;
    for (int i = n; i; --i) &amp;#123;
        if (i != n)
            for (int K = a[i]; K &amp;lt;= m; K += a[i])
                for (int mx = std::min(a[i] - 1, m - K); ; ) &amp;#123;
                    int k = ask(rt[1], 1, m, K, K + mx, 1);
                    if (k == 0x3f3f3f3f)
                        break;
                    t[k].emplace_back(i, a[k] - K);
                    if (k == n || !(a[k] - K))
                        break;
                    mx = (a[k] - K - 1) / 2;
                &amp;#125;
        add(rt[1], 1, m, a[i], i, 1);
    &amp;#125;
    int q;
    read(q);
    std::vector&amp;lt;int&amp;gt; res(q + 1);
    std::vector&amp;lt;std::vector&amp;lt;std::pair&amp;lt;int, int&amp;gt; &amp;gt; &amp;gt; u(n + 1);
    for (int i = 1, l, r; i &amp;lt;= q; ++i) &amp;#123;
        read(l), read(r);
        if (l &amp;gt; r)
            std::swap(l, r);
        u[r].emplace_back(l, i);
    &amp;#125;
    std::vector&amp;lt;int&amp;gt; bit(n + 1, 0x3f3f3f3f);
    auto lowbit = [&amp;amp;](int x) &amp;#123; return x &amp;amp; -x; &amp;#125;;
    auto add = [&amp;amp;](int x, int v) &amp;#123;
        for (; x &amp;lt;= n; x += lowbit(x))
            bit[x] = std::min(bit[x], v);
        return;
    &amp;#125;;
    auto ask = [&amp;amp;](int x) &amp;#123;
        auto res = 0x3f3f3f3f;
        for (; x; x -= lowbit(x))
            res = std::min(res, bit[x]);
        return res;
    &amp;#125;;
    for (int r = 1; r &amp;lt;= n; ++r) &amp;#123;
        for (auto [l, v] : t[r])
            add(n - l + 1, v);
        for (auto [l, i] : u[r])
            res[i] = ask(n - l + 1);
    &amp;#125;
    for (int i = 1; i &amp;lt;= q; ++i)
        print(res[i], &amp;#39;\n&amp;#39;);
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;p&gt;求支配对的过程也要带 log（线段树），再加上扫描线的 3log，总共是常数比较大的 3log（卡了一个上午的常也是有了）。所以接下来讲解另一种奇技淫巧。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;暴力分治&lt;/strong&gt;：注意到对于比较长（&lt;span class=&#34;math inline&#34;&gt;\(len&amp;gt; B\)&lt;/span&gt;）的区间，答案比较小；故考虑分治。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于长询问（&lt;span class=&#34;math inline&#34;&gt;\(len&amp;gt;B\)&lt;/span&gt;），从小到大枚举答案并 check；预处理某个范围（&lt;span class=&#34;math inline&#34;&gt;\(V\)&lt;/span&gt;）内的 &lt;span class=&#34;math inline&#34;&gt;\(res\)&lt;/span&gt; 出现的所有位置，平衡的时候还要算上调和级数和 bit。&lt;/li&gt;
&lt;li&gt;对于短询问（&lt;span class=&#34;math inline&#34;&gt;\(len\le B\)&lt;/span&gt;），发现每次区间内暴力是 &lt;span class=&#34;math inline&#34;&gt;\(O(B^2q)\)&lt;/span&gt; 的；把询问离线下来，精细实现，利用询问的公共部分使得&lt;strong&gt;每一对数只被枚举一次&lt;/strong&gt;就能达到 &lt;span class=&#34;math inline&#34;&gt;\(O(B^2 + Bq)\)&lt;/span&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最优解取 &lt;span class=&#34;math inline&#34;&gt;\(B=333,V=483\)&lt;/span&gt;，不自己实现一遍了。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;d---仙人掌&#34;&gt;D - 仙人掌&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P3687&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P3687&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;把边双从图中删除、问题转化为树上&lt;strong&gt;边&lt;/strong&gt;不交的链覆盖，使得&lt;strong&gt;所有链长 &lt;span class=&#34;math inline&#34;&gt;\(\ge 2\)&lt;/span&gt;&lt;/strong&gt; 的方案数。发现由于&lt;strong&gt;边可以不被覆盖&lt;/strong&gt;，常规 DP 会使得在父节点处合并时需要额外的数量维，参考树上背包，复杂度 &lt;span class=&#34;math inline&#34;&gt;\(O(n^2)\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;思考时会注意到两个限制可以抵消——如果认为长为 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt; 的链就是不被覆盖的边，覆盖所有树边，显然可以建立和合法解的双射。此时合并是非常方便的，注意到每个儿子的系数一定都参与『分步』，只需要求出『分类』的系数。这个可以预处理（和 &lt;a href=&#34;/20250407/#a.-二分图染色&#34;&gt;二分图染色&lt;/a&gt; 这个题有点像），令 &lt;span class=&#34;math inline&#34;&gt;\(f_i\)&lt;/span&gt; 表示一个点度数为 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 时的答案，参考错排的思路，则 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 可以不参与配对，也可以乱选一个点配对，如果选中了已配对的点就令其和 &lt;span class=&#34;math inline&#34;&gt;\(i-1\)&lt;/span&gt; 交换，可以建立和合法解的双射。则 &lt;span class=&#34;math inline&#34;&gt;\(f_i=f_{i-1}+(n-1)f_{i-2}\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;首先需要 check 原图是否为仙人掌，顺带回忆一下连通性的知识——在 DFS 树上差分，检查是否有边被覆盖两次即可。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int mod = 998244353;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int T;
    for (std::cin &amp;gt;&amp;gt; T; T--; ) &amp;#123;
        int n, m;
        std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
        std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; g1(n + 1);
        for (int x, y; m--; ) &amp;#123;
            std::cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; y;
            g1[x].push_back(y), g1[y].push_back(x);
        &amp;#125;
        bool flag = 1;
        int now = 0, cnt = 0;
        std::vector&amp;lt;int&amp;gt; st, dfn(n + 1), low(n + 1), col(n + 1), diff(n + 1);
        std::function&amp;lt;void(int, int)&amp;gt; DFS = [&amp;amp;](int x, int fa) &amp;#123;
            st.push_back(x);
            dfn[x] = low[x] = ++now;
            for (auto i : g1[x])
                if (!dfn[i]) &amp;#123;
                    // printf(&amp;quot;x = %d, %d -&amp;gt; %d\n&amp;quot;, x, x, i);
                    DFS(i, x);
                    diff[x] += diff[i];
                    // printf(&amp;quot;x = %d, diff[%d] += diff[%d]\n&amp;quot;, x, x, i);
                    low[x] = std::min(low[x], low[i]);
                &amp;#125;
                else if (i != fa &amp;amp;&amp;amp; dfn[i] &amp;lt; dfn[x]) &amp;#123;
                    low[x] = std::min(low[x], dfn[i]);
                    ++diff[x], --diff[i];
                    // printf(&amp;quot;x = %d, ++diff[%d], --diff[%d]\n&amp;quot;, x, x, i);
                &amp;#125;
            if (diff[x] &amp;gt;= 2)
                flag = 0;
            // printf(&amp;quot;x = %d, diff[%d] = %d\n&amp;quot;, x, x, diff[x]);
            if (low[x] == dfn[x]) &amp;#123;
                ++cnt;
                for (int p = -1; p != x; ) &amp;#123;
                    p = st.back(), st.pop_back();
                    col[p] = cnt;
                &amp;#125;
            &amp;#125;
            return;
        &amp;#125;;
        DFS(1, -1);
        if (!flag) &amp;#123;
            std::cout &amp;lt;&amp;lt; 0 &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
            continue;
        &amp;#125;
        std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; g(n + 1);
        for (int i = 1; i &amp;lt;= n; ++i)
            for (auto j : g1[i])
                if (col[i] != col[j])
                    g[i].push_back(j);
        std::vector&amp;lt;long long&amp;gt; f(n + 1), dp(n + 1);
        dp[0] = 1ll, dp[1] = 1ll;
        for (int i = 2; i &amp;lt;= n; ++i)
            dp[i] = (dp[i - 1] + (i - 1) * dp[i - 2]) % mod;
        std::vector&amp;lt;int&amp;gt; tag(n + 1);
        DFS = [&amp;amp;](int x, int fa) &amp;#123;
            f[x] = 1ll, tag[x] = 1;
            for (auto i : g[x])
                if (i != fa) &amp;#123;
                    DFS(i, x);
                    (f[x] *= f[i]) %= mod;
                &amp;#125;
            (f[x] *= dp[(int)g[x].size()]) %= mod;
            return;
        &amp;#125;;
        auto res(1ll);
        for (int i = 1; i &amp;lt;= n; ++i)
            if (!tag[i])
                DFS(i, -1), (res *= f[i]) %= mod;
        std::cout &amp;lt;&amp;lt; res &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    &amp;#125;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;p&gt;E. Many Minimizations 是数学题，跳了。&lt;/p&gt;
&lt;hr /&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;无名题&#34;&gt;无名题&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;背景：给定 &lt;span class=&#34;math inline&#34;&gt;\(n,k\)&lt;/span&gt;，对于 &lt;span class=&#34;math inline&#34;&gt;\(\forall\, 1\le i\le n\)&lt;/span&gt;，令 &lt;span class=&#34;math inline&#34;&gt;\(a_i=i\bmod k\)&lt;/span&gt;，问一共有多少个本质不同的子序列？对于 &lt;span class=&#34;math inline&#34;&gt;\(k=1,2,\cdots,n\)&lt;/span&gt; 分别求出答案。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;maimai&#34;&gt;maimai&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://ac.nowcoder.com/acm/contest/66112/F&#34; class=&#34;uri&#34;&gt;https://ac.nowcoder.com/acm/contest/66112/F&lt;/a&gt;&lt;/p&gt;
 ]]></description>
        </item>
    </channel>
</rss>
