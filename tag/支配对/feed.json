{
    "version": "https://jsonfeed.org/version/1",
    "title": "null • All posts by \"支配对\" tag",
    "description": "",
    "home_page_url": "https://xsc062.netlify.app",
    "items": [
        {
            "id": "https://xsc062.netlify.app/20250830/",
            "url": "https://xsc062.netlify.app/20250830/",
            "title": "学习笔记 支配对",
            "date_published": "2025-08-30T03:47:08.000Z",
            "content_html": "<p>一种贪心思想，很符合直觉，又有点像乱搞</p>\n<span id=\"more\"></span>\n<hr />\n<ul>\n<li>考虑一类点对统计问题，形如给定 <span class=\"math inline\">\\([l,r]\\)</span>，对于 <span class=\"math inline\">\\([l\\le x\\le y\\le r]\\)</span>，你需要寻找满足某个限制的 <span class=\"math inline\">\\((x,y)\\)</span> 数量，或者是所有 <span class=\"math inline\">\\((x,y)\\)</span> 的最大权值</li>\n<li><p>如果存在 <span class=\"math inline\">\\([x_1,y_1]\\subset [x_2,y_2]\\)</span> 且 <span class=\"math inline\">\\([x_1,y_1]\\)</span> 满足限制 / 贡献更大，就可以只保留 <span class=\"math inline\">\\([x_1,y_1]\\)</span></p>\n因为统计了 <span class=\"math inline\">\\([x_2,y_2]\\)</span> 就必须要统计 <span class=\"math inline\">\\([x_1,y_1]\\)</span>，反之则不一定成立。</li>\n<li><p>题目会给出一些性质使得最终保留下来的 <span class=\"math inline\">\\([x_1,y_1]\\)</span> 的数量不多</p></li>\n</ul>\n<hr />\n<h2 id=\"树上支配对-第一类支配对\">树上支配对 / 第一类支配对</h2>\n<ul>\n<li>这类问题的特征很明显，多次询问，给定一个编号区间，统计树上点对相关信息。</li>\n<li><p>会想到点分治、dsu on tree 这两个工具，其中点分治处理距离问题更方便，dsu on tree 更常用来处理 LCA 问题</p>\n固定当前的根之后，钦定支配对来自两个不同子树（注意根自身参与形成支配对的情况），那么共有 <span class=\"math inline\">\\(O(n\\log n)\\)</span> 对支配对</li>\n<li><p>先用这两种方法在树上找到支配对，就可以把询问离线下来做扫描线之类的了</p></li>\n</ul>\n<p>本质是利用 LCA 的树上性质，以及点分、dsu on tree 只用统计 <span class=\"math inline\">\\(O(n\\log n)\\)</span> 个单侧点，同时对于每个单侧点只存在 <span class=\"math inline\">\\(O(1)\\)</span> 个相应的前驱、后继点达到 LCA 找到 <span class=\"math inline\">\\(O(n\\log n)\\)</span> 个支配对</p>\n<hr />\n<h3 id=\"d---rldcot\">D - rldcot</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P7880\" class=\"uri\">https://www.luogu.com.cn/problem/P7880</a></p>\n<ul>\n<li>若存在 <span class=\"math inline\">\\((x_1,y_1)\\)</span> 和 <span class=\"math inline\">\\((x_2,y_2)\\)</span> 拥有相同的 LCA，那么认为 <span class=\"math inline\">\\((x_1,y_1)\\)</span> 支配了 <span class=\"math inline\">\\((x_2,y_2)\\)</span></li>\n<li>树有根，故需要 dsu on tree</li>\n<li>用一个 set 处理前驱、后继的查询，然后就是正常的 dsu on tree 了</li>\n<li>离线下来扫描线，树状数组实时维护每个颜色（离散化一下）最靠右的区间即可</li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    using ll = long long;\n    int n, m;\n    std::cin &gt;&gt; n &gt;&gt; m;\n    std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; g(n + 1);\n    for (int i = 1, x, y, w; i &lt; n; ++i) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y &gt;&gt; w;\n        g[x].emplace_back(y, w);\n        g[y].emplace_back(x, w);\n    &#125;\n    int tot = 0;\n    std::vector&lt;ll&gt; dep(n + 1);\n    std::unordered_map&lt;ll, int&gt; tab;\n    std::vector&lt;int&gt; siz(n + 1), son(n + 1), col(n + 1);\n    std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int fa) &#123;\n        siz[x] = 1;\n        if (!tab.count(dep[x]))\n            tab[dep[x]] = ++tot;\n        col[x] = tab[dep[x]];\n        for (auto [i, w] : g[x])\n            if (i != fa) &#123;\n                dep[i] = dep[x] + w;\n                DFS(i, x);\n                siz[x] += siz[i];\n                if (siz[i] &gt; siz[son[x]])\n                    son[x] = i;\n            &#125;\n        return;\n    &#125;;\n    DFS(1, -1);\n    std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; u(n + 1);\n    std::function&lt;void(int, int, int, std::set&lt;int&gt; &amp;)&gt; DFS2 = [&amp;](int col, int x, int fa, std::set&lt;int&gt; &amp;t) &#123;\n        auto p = t.lower_bound(x);\n        if (col == -1)\n            t.insert(x);\n        else &#123;\n            if (p != t.begin())\n                u[x].emplace_back(*std::prev(p), col );\n            if (p != t.end())\n                u[*p].emplace_back(x, col);\n        &#125;\n        for (auto [i, w] : g[x])\n            if (i != fa)\n                DFS2(col, i, x, t);\n        return;\n    &#125;;\n    std::function&lt;void(int, int, std::set&lt;int&gt; &amp;)&gt; DFS1 = [&amp;](int x, int fa, std::set&lt;int&gt; &amp;t) &#123;\n        if (son[x])\n            DFS1(son[x], x, t);\n        for (auto [i, w] : g[x])\n            if (i != fa &amp;&amp; i != son[x]) &#123;\n                std::set&lt;int&gt; nt;\n                DFS1(i, x, nt);\n            &#125;\n        t.insert(x);\n        u[x].emplace_back(x, col[x]);\n        for (auto [i, w] : g[x])\n            if (i != fa &amp;&amp; i != son[x])\n                DFS2(col[x], i, x, t), DFS2(-1, i, x, t);\n        return;\n    &#125;;\n    &#123;\n        std::set&lt;int&gt; t;\n        DFS1(1, -1, t);\n    &#125;\n    std::vector&lt;int&gt; res(m + 1);\n    std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; t(n + 1);\n    for (int i = 1, l, r; i &lt;= m; ++i) &#123;\n        std::cin &gt;&gt; l &gt;&gt; r;\n        t[r].emplace_back(l, i);\n    &#125;\n    std::vector&lt;int&gt; bit(n + 1), la(tot + 1);\n    auto lowbit = [](int x) &#123;\n        return x &amp; -x;\n    &#125;;\n    auto add = [&amp;](int x, int v) &#123;\n        for (; x &lt;= n; x += lowbit(x))\n            bit[x] += v;\n        return;\n    &#125;;\n    auto ask = [&amp;](int x) &#123;\n        int res = 0;\n        for (; x; x -= lowbit(x))\n            res += bit[x];\n        return res;\n    &#125;;\n    for (int r = 1; r &lt;= n; ++r) &#123;\n        for (auto [l, c] : u[r])\n            if (l &gt; la[c]) &#123;\n                if (la[c])\n                    add(la[c], -1);\n                add(l, 1), la[c] = l;\n            &#125;\n        for (auto [l, id] : t[r])\n            res[id] = ask(r) - ask(l - 1);\n    &#125;\n    for (int i = 1; i &lt;= m; ++i)\n        std::cout &lt;&lt; res[i] &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"e---铃原露露\">E - 铃原露露</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P8528\" class=\"uri\">https://www.luogu.com.cn/problem/P8528</a></p>\n<ul>\n<li><p>考虑一下支配关系在哪里，固定一个 LCA <span class=\"math inline\">\\(z\\)</span>，讨论 <span class=\"math inline\">\\(a_z\\)</span> 与 <span class=\"math inline\">\\(a_x,a_y\\)</span> 的大小关系给 <span class=\"math inline\">\\([1,a_x]\\)</span> 间的 <span class=\"math inline\">\\(l\\)</span> 带来的限制：</p>\n<ul>\n<li><span class=\"math inline\">\\(a_z\\in[a_x,a_y]\\)</span>，<span class=\"math inline\">\\((x,y)\\)</span> 总是合法，无限制。</li>\n<li><span class=\"math inline\">\\(a_z&lt;a_x\\)</span>，对于 <span class=\"math inline\">\\(r\\ge a_y\\)</span>，当 <span class=\"math inline\">\\(l\\in(a_z,a_x]\\)</span> 时，<span class=\"math inline\">\\((x,y)\\)</span> 非法。</li>\n<li><span class=\"math inline\">\\(a_z&gt;a_y\\)</span>，当 <span class=\"math inline\">\\(r\\in[a_y,a_z)\\)</span> 时，<span class=\"math inline\">\\((x,y)\\)</span> 总是非法。此时所有 <span class=\"math inline\">\\(l\\in[1,a_x]\\)</span> 不可选。</li>\n</ul></li>\n<li>发现固定 <span class=\"math inline\">\\(a_z,a_x\\)</span>，那么当 <span class=\"math inline\">\\(a_y\\)</span> 越靠近 <span class=\"math inline\">\\(a_x\\)</span> 时给出的限制越紧，反之亦然，就可以得到这样的支配关系</li>\n<li>容易发现当 <span class=\"math inline\">\\(a_z\\notin [a_x,a_y]\\)</span> 时，<span class=\"math inline\">\\((x,y)\\)</span> 不合法；故只需要在 dsu on tree 上找到 <span class=\"math inline\">\\(a_x\\)</span> 的前驱、后继并统计支配对即可</li>\n<li><p>考虑询问，发现需要维护区间加、区间历史 0 个数，后者是经典 trick，是好做的。</p></li>\n</ul>\n<p>历史标记的下传需要格外注意一下，应该只保证标记期间存在 0 的区间拥有懒标记；具体地，<strong>只应将其下传到和当前区间最小值相同的子区间</strong>（具体可以看代码），容易证明是对的。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 2e5 + 5;\nstruct node &#123;\n    long long s;\n    int l, r, u, c, d, d1;\n    node operator+ (const node q) const &#123;\n        node res;\n        res.s = s + q.s;\n        res.l = l, res.r = q.r;\n        res.u = std::min(u, q.u);\n        res.d = res.d1 = res.c = 0;\n        if (u == res.u)\n            res.c = c;\n        if (q.u == res.u)\n            res.c += q.c;\n        return res;\n    &#125;\n&#125; t[maxn &lt;&lt; 2];\n#define lt (p &lt;&lt; 1)\n#define rt (lt | 1)\nvoid bld(int p, int l, int r) &#123;\n    t[p].c = r - l + 1;\n    t[p].l = l, t[p].r = r;\n    if (l == r)\n        return;\n    int mid = (l + r) &gt;&gt; 1;\n    bld(lt, l, mid), bld(rt, mid + 1, r);\n    return;\n&#125;\nvoid pushdown(int p) &#123;\n    if (t[p].d) &#123;\n        t[lt].d += t[p].d, t[lt].u += t[p].d;\n        t[rt].d += t[p].d, t[rt].u += t[p].d;\n        t[p].d = 0;\n    &#125;\n    if (t[p].d1) &#123;\n        if (t[lt].u == t[p].u) &#123;\n            t[lt].s += (long long)t[lt].c * t[p].d1;\n            t[lt].d1 += t[p].d1;\n        &#125;\n        if (t[rt].u == t[p].u) &#123;\n            t[rt].s += (long long)t[rt].c * t[p].d1;\n            t[rt].d1 += t[p].d1;\n        &#125;\n        t[p].d1 = 0;\n    &#125;\n    return;\n&#125;\nvoid add(int p, int l, int r, int v) &#123;\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r) &#123;\n        t[p].d += v, t[p].u += v;\n        return;\n    &#125;\n    pushdown(p);\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (l &lt;= mid)\n        add(lt, l, r, v);\n    if (r &gt; mid)\n        add(rt, l, r, v);\n    t[p] = t[lt] + t[rt];\n    return;\n&#125;\nvoid upd(int p, int l, int r) &#123;\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r) &#123;\n        if (!t[p].u)\n            t[p].s += t[p].c, ++t[p].d1;\n        return;\n    &#125;\n    pushdown(p);\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (l &lt;= mid)\n        upd(lt, l, r);\n    if (r &gt; mid)\n        upd(rt, l, r);\n    t[p] = t[lt] + t[rt];\n    return;\n&#125;\nlong long ask(int p, int l, int r) &#123;\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r)\n        return t[p].s;\n    pushdown(p);\n    auto res(0ll);\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (l &lt;= mid)\n        res = ask(lt, l, r);\n    if (r &gt; mid)\n        res += ask(rt, l, r);\n    return res;\n&#125;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, m;\n    std::cin &gt;&gt; n &gt;&gt; m;\n    std::vector&lt;int&gt; a(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i];\n    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1); \n    for (int i = 2, x; i &lt;= n; ++i)\n        std::cin &gt;&gt; x, g[x].push_back(i);\n    std::vector&lt;int&gt; siz(n + 1), son(n + 1);\n    std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;\n        siz[x] = 1;\n        for (auto i : g[x]) &#123;\n            DFS(i);\n            siz[x] += siz[i];\n            if (siz[i] &gt; siz[son[x]])\n                son[x] = i;\n        &#125;\n        return;\n    &#125;;\n    DFS(1);\n    std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; u1(n + 1), u2(n + 1);\n    std::function&lt;void(int, int, std::set&lt;int&gt; &amp;)&gt; DFS2 = [&amp;](int col, int x, std::set&lt;int&gt; &amp;t) &#123;\n        auto p = t.lower_bound(a[x]);\n        if (col == -1)\n            t.insert(a[x]);\n        else &#123;\n            if (p != t.begin()) &#123;\n                int y = *std::prev(p);\n                if (col &lt; y)\n                    u1[a[x]].emplace_back(col + 1, y);\n                else if (col &gt; a[x]) &#123;\n                    u1[a[x]].emplace_back(1, y);\n                    u2[col].emplace_back(1, y);\n                &#125;\n            &#125;\n            if (p != t.end()) &#123;\n                int y = *p;\n                if (col &lt; a[x])\n                    u1[y].emplace_back(col + 1, a[x]);\n                else if (col &gt; y) &#123;\n                    u1[y].emplace_back(1, a[x]);\n                    u2[col].emplace_back(1, a[x]);\n                &#125;\n            &#125;\n        &#125;\n        for (auto i : g[x])\n            DFS2(col, i, t);\n        return;\n    &#125;;\n    std::function&lt;void(int, std::set&lt;int&gt; &amp;)&gt; DFS1 = [&amp;](int x, std::set&lt;int&gt; &amp;t) &#123;\n        if (son[x])\n            DFS1(son[x], t);\n        for (auto i : g[x])\n            if (i != son[x]) &#123;\n                std::set&lt;int&gt; nt;\n                DFS1(i, nt);\n            &#125;\n        t.insert(a[x]);\n        for (auto i : g[x])\n            if (i != son[x])\n                DFS2(a[x], i, t), DFS2(-1, i, t);\n        return;\n    &#125;;\n    &#123;\n        std::set&lt;int&gt; t;\n        DFS1(1, t);\n    &#125;\n    std::vector&lt;long long&gt; res(m + 1);\n    std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; t(n + 1);\n    for (int i = 1, l, r; i &lt;= m; ++i) &#123;\n        std::cin &gt;&gt; l &gt;&gt; r;\n        t[r].emplace_back(l, i);\n    &#125;\n    bld(1, 1, n);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        for (auto [l, r] : u1[i])\n            add(1, l, r, 1);\n        for (auto [l, r] : u2[i])\n            add(1, l, r, -1);\n        upd(1, 1, i);\n        for (auto [l, id] : t[i])\n            res[id] = ask(1, l, i);\n    &#125;\n    for (int i = 1; i &lt;= m; ++i)\n        std::cout &lt;&lt; res[i] &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n",
            "tags": [
                "支配对"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20250809/",
            "url": "https://xsc062.netlify.app/20250809/",
            "title": "近期杂题",
            "date_published": "2025-08-09T04:33:17.000Z",
            "content_html": "<p>这段时间比赛的一些题 和 nKessi、duanyu 讲的题目。太偏计数、数学的基本上没办法做了。</p>\n<span id=\"more\"></span>\n<hr />\n<h2 id=\"a.-出关\">A. 出关</h2>\n<p><a href=\"http://222.180.160.110:61235/contest/6462/problem/1\" class=\"uri\">http://222.180.160.110:61235/contest/6462/problem/1</a></p>\n<blockquote>\n<p>给定 <span class=\"math inline\">\\(s\\)</span>，对于一个空串，任意利用下列三种操作，使其变为 <span class=\"math inline\">\\(s\\)</span>，求最小代价：</p>\n<ol type=\"1\">\n<li>在末尾添加字符 <span class=\"math inline\">\\(c\\)</span>，代价为 <span class=\"math inline\">\\(t_{0,c}\\)</span>；</li>\n<li>复制整个字符串并粘贴在末尾，代价为 <span class=\"math inline\">\\(t_1\\)</span>；</li>\n<li>删除末尾字符，代价为 <span class=\"math inline\">\\(t_2\\)</span>。</li>\n</ol>\n<p><span class=\"math inline\">\\(|s|\\le 10^6\\)</span>。</p>\n</blockquote>\n<p>可以预处理出对于每个 <span class=\"math inline\">\\(i\\)</span> 结尾，最多可以复制到哪个地方，发现要求 <span class=\"math inline\">\\(z_i=lcp(s_{1\\dots n},s_{i+1\\dots n})\\)</span>。那么一个 <span class=\"math inline\">\\(i\\)</span> 的最远转移点 <span class=\"math inline\">\\(r_i=i+z_{i+1}\\)</span>，用单调队列就能维护，会 exkmp 就能线性；</p>\n<p>否则可以二分 + 哈希多个 log，后面也有理由偷懒用优先队列了。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int p = 31;\nconst int mod = 998244353;\nint main() &#123;\n    std::freopen(&quot;laozi.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;laozi.out&quot;, &quot;w&quot;, stdout);\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n    std::string s;\n    std::cin &gt;&gt; s;\n    int n = (int)s.length(), t1, t2;\n    std::vector&lt;long long&gt; h(n + 1), base(n + 1);\n    std::vector&lt;int&gt; a(n + 1), t0(27), z(n + 1), r(n + 1);\n    base[0] = 1ll;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        a[i] = s[i - 1] - &#39;a&#39; + 1;\n        h[i] = (h[i - 1] * p + a[i]) % mod;\n        base[i] = base[i - 1] * p % mod;\n    &#125;\n    auto gethash = [&amp;](int l, int r) &#123;\n        return (h[r] - h[l - 1] * base[r - l + 1] % mod + mod) % mod;\n    &#125;;\n    for (int i = 1; i &lt;= n; ++i)\n        for (int l = 1, r = std::min(i - 1, n - i + 1), mid; l &lt;= r; ) &#123;\n            mid = (l + r) &gt;&gt; 1;\n            if (gethash(1, mid) == gethash(i, i + mid - 1))\n                z[i] = mid, l = mid + 1;\n            else\n                r = mid - 1;\n        &#125;\n    for (int i = 1; i &lt; n; ++i)\n        r[i] = i + std::min(i, z[i + 1]);\n    for (int i = 1; i &lt;= 26; ++i)\n        std::cin &gt;&gt; t0[i];\n    std::cin &gt;&gt; t1 &gt;&gt; t2;\n    std::vector&lt;long long&gt; f(n + 1);\n    std::priority_queue&lt;std::pair&lt;long long, int&gt; &gt; q;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        f[i] = f[i - 1] + t0[a[i]];\n        for (; !q.empty() &amp;&amp; r[q.top().second] &lt; i; q.pop());\n        if (!q.empty())\n            f[i] = std::min(f[i], t1 - q.top().first - (long long)t2 * i);\n        if (i != n)\n            q.emplace(-(f[i] + 2ll * t2 * i), i);\n    &#125;\n    std::cout &lt;&lt; f[n] &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"d.-非攻\">D. 非攻</h2>\n<p><a href=\"http://222.180.160.110:61235/contest/6462/problem/4\" class=\"uri\">http://222.180.160.110:61235/contest/6462/problem/4</a></p>\n<blockquote>\n<p>给定 <span class=\"math inline\">\\(n\\)</span>，对于一个 <span class=\"math inline\">\\(1\\sim n\\)</span> 的排列，使用最小的交换次数使得其单增。在该前提下，定义代价为每次交换的两个数之积。对于所有 <span class=\"math inline\">\\(n!\\)</span> 个排列，计算最小代价之和。</p>\n<p><span class=\"math inline\">\\(n\\le 10^7\\)</span>。</p>\n</blockquote>\n<p>转化成，把 <span class=\"math inline\">\\(1\\sim n\\)</span> 分成无标号的若干组，每组的代价是 最小值 <span class=\"math inline\">\\(\\times\\)</span> 其他元素的和，还有一个项链问题的系数，发现组间的符号是求和，考虑计算贡献。</p>\n<p>枚举 <span class=\"math inline\">\\(i,j\\)</span> 并钦定两个同属一个环，且 <span class=\"math inline\">\\(i\\)</span> 为最小值，枚举环大小 <span class=\"math inline\">\\(s+2\\)</span>，那么有：</p>\n<p><span class=\"math display\">\\[\n\\begin{aligned}\nres&amp;=\\sum_{i=1}^{n-1}\\sum_{j=i+1}^n i\\cdot j \\cdot \\sum_{s=0}^{n-i-1}\\binom{n-i-1}s \\cdot (s+1)!\\cdot (n-s-2)!\\\\\n&amp;=\\sum_{i=1}^{n-1}i\\cdot \\dfrac {(i+n+1)(n-i)}2 \\cdot \\sum_{s=0}^{n-i-1}\\binom{n-i-1}s\\cdot (s+1)!\\cdot (n-s-2)!\\\\\n&amp;=\\frac 12\\times\\sum_{i=1}^{n-1}i\\cdot (i+n+1)\\cdot (n-i)!\\cdot\\sum_{s=0}^{n-i-1}\\dfrac {(s + 1)\\cdot (n-s-2)!}{(n-i-1-s)!}\\\\\n\\end{aligned}\n\\]</span></p>\n<p>令 <span class=\"math inline\">\\(T=n-i-1\\)</span>，发现我们需要快速计算 <span class=\"math inline\">\\(f_T=\\sum\\limits_{i=0}^T \\dfrac{(i+1)\\cdot (n-i-2)!}{(T-i)!}\\)</span>。记 <span class=\"math inline\">\\(m=n-2\\)</span>，变形得 <span class=\"math inline\">\\(f_T=(m-T)!\\cdot \\sum\\limits_{i=0}^{T} (i+1) \\binom{m-i}{m-T}\\)</span>，发现似乎可以简化，令 <span class=\"math inline\">\\(k=m-T,t=T+1\\)</span>，则 <span class=\"math inline\">\\(f_T=\\sum\\limits_{i=1}^T i\\cdot \\binom {k+t-i}k\\)</span>。</p>\n<p>然后是经典的组合意义保平安环节，即从 <span class=\"math inline\">\\(k+t\\)</span> 个有标号小球中选择一条分界线，分界线左边选一个球、右边选 <span class=\"math inline\">\\(k\\)</span> 个球的方案数。发现分界线的存在很诡异，故用分界线后方的第一个球代替，在 <span class=\"math inline\">\\(t+1\\)</span> 处新建一个虚球，规定在前 <span class=\"math inline\">\\(t+1\\)</span> 个球中选两个球，并令后一个为分界线，且令前 <span class=\"math inline\">\\(t+1\\)</span> 个中的其他球为实球，就能建立双射。在分界线后再选 <span class=\"math inline\">\\(k\\)</span> 个球，容易发现直接在范围内选 <span class=\"math inline\">\\(k+2\\)</span> 个球就能满足条件，故 <span class=\"math inline\">\\(f_T=(n-T-2)!\\cdot \\binom{t+k+1}{k+2}\\)</span>。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 1e9 + 7;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n    std::freopen(&quot;mozi.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;mozi.out&quot;, &quot;w&quot;, stdout);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;long long&gt; fac(n + 1), inv(n + 1), f(n + 1);\n    fac[0] = inv[0] = 1ll;\n    for (int i = 1; i &lt;= n; ++i)\n        fac[i] = fac[i - 1] * i % mod;\n    auto qkp = [&amp;](long long x, int y) &#123;\n        auto res(1ll);\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    inv[n] = qkp(fac[n], mod - 2);\n    for (int i = n - 1; i; --i)\n        inv[i] = inv[i + 1] * (i + 1) % mod;\n    auto C = [&amp;](int n, int m) &#123;\n        return fac[n] * inv[n - m] % mod * inv[m] % mod;\n    &#125;;\n    int m = n - 2;\n    for (int T = 0; T &lt;= n - 2; ++T) &#123;\n        int k = m - T, t = T + 1;\n        f[T] = C(t + k + 1, k + 2) * fac[m - T] % mod;\n    &#125;\n    auto res = 0ll;\n    for (int i = 1; i &lt;= n - 1; ++i)\n        (res += (long long)i * (i + n + 1) % mod * fac[n - i] % mod * f[n - i - 1] % mod) %= mod;\n    std::cout &lt;&lt; res * inv[2] % mod &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"c---destruction-of-walls\">C - Destruction of Walls</h2>\n<p><a href=\"https://atcoder.jp/contests/arc203/tasks/arc203_c\" class=\"uri\">https://atcoder.jp/contests/arc203/tasks/arc203_c</a></p>\n<hr />\n<h2 id=\"d---insert-xor\">D - Insert XOR</h2>\n<p><a href=\"https://atcoder.jp/contests/arc203/tasks/arc203_d\" class=\"uri\">https://atcoder.jp/contests/arc203/tasks/arc203_d</a></p>\n<hr />\n<h2 id=\"a---记忆\">A - 记忆</h2>\n<p><a href=\"https://ac.nowcoder.com/acm/problem/274793\" class=\"uri\">https://ac.nowcoder.com/acm/problem/274793</a></p>\n<p>需要意识到问题是静态的，并且不能用线段树之类维护；故考虑离线下来，想办法在 LCA 处统计答案。</p>\n<p>这个时候发现需要合并子树状态、整体异或、整体 +1，很容易想到 Trie。把 <span class=\"math inline\">\\(u\\to\\)</span> LCA 的答案保存在 LCA 处，然后再用 DFS + 回溯统计 LCA <span class=\"math inline\">\\(\\to v\\)</span> 的答案。想了半天没想到把上下拆开来做也是神了 😅</p>\n<p>可能比较考验对字典树的理解？做个比喻，字典树的 id 就相当于对这个点上信息的『引用』。</p>\n<details>\n<p>字典树合并的时候可以考虑回收废弃点，不然可能有点卡。</p>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int X = 50;\nconst int maxn = 2e7 + 5;\nlong long d[maxn];\nint tot, T[maxn][2], f[maxn], fa[maxn];\n#define lc(p) T[p][0]\n#define rc(p) T[p][1]\nint find(int x) &#123; return x == f[x] ? x : f[x] = find(f[x]); &#125;\nint newnode(void) &#123;\n    int p = ++tot;\n    assert(p &lt; maxn);\n    d[p] = lc(p) = rc(p) = 0, f[p] = p;\n    return p;\n&#125;\nvoid pushdown(int p) &#123;\n    if (d[p]) &#123;\n        if (d[p] &amp; 1)\n            std::swap(lc(p), rc(p));\n        d[p] &gt;&gt;= 1;\n        if (lc(p))\n            d[lc(p)] ^= d[p];\n        if (rc(p))\n            d[rc(p)] ^= d[p];\n        d[p] = 0;\n    &#125;\n    return;\n&#125;\nint ins(int p, long long x) &#123;\n    for (int i = 0; i &lt; X; ++i) &#123;\n        pushdown(p);\n        if (!T[p][(x &gt;&gt; i) &amp; 1]) &#123;\n            T[p][(x &gt;&gt; i) &amp; 1] = newnode();\n            fa[T[p][(x &gt;&gt; i) &amp; 1]] = p;\n        &#125;\n        p = T[p][(x &gt;&gt; i) &amp; 1];\n    &#125;\n    return p;\n&#125;\nvoid merge(int &amp;p, int q) &#123;\n    if (!q)\n        return;\n    if (!p) &#123;\n        p = q;\n        return;\n    &#125;\n    pushdown(p), pushdown(q);\n    fa[lc(q)] = p, fa[rc(q)] = p;\n    merge(lc(p), lc(q)), merge(rc(p), rc(q));\n    assert(f[p] == p), assert(f[q] == q), f[q] = p;\n    return;\n&#125;\nlong long ask(int p) &#123;\n    std::vector&lt;int&gt; st;\n    for (int i = 0, j = p; i &lt; X; ++i)\n        st.push_back(fa[j]), j = fa[j];\n    for (int i = 0; i &lt; X; ++i)\n        pushdown(st.back()), st.pop_back();\n    long long x = 0;\n    for (int i = 0; i &lt; X; ++i) &#123;\n        x = x * 2 + (p == rc(fa[p]));\n        p = fa[p];\n    &#125;\n    return x;\n&#125;\nvoid add(int p) &#123;\n    for (int i = 0; p &amp;&amp; i &lt; X; ++i) &#123;\n        pushdown(p);\n        std::swap(lc(p), rc(p));\n        p = lc(p);\n    &#125;\n    return;\n&#125;\nvoid del(int p) &#123;\n    for (int i = 0; p &amp;&amp; i &lt; X; ++i) &#123;\n        pushdown(p);\n        std::swap(lc(p), rc(p));\n        p = rc(p);\n    &#125;\n    return;\n&#125;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, m;\n    std::cin &gt;&gt; n &gt;&gt; m;\n    std::vector&lt;int&gt; a(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i];\n    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);\n    for (int i = 1, x, y; i &lt; n; ++i) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y;\n        g[x].push_back(y), g[y].push_back(x);\n    &#125;\n    std::vector&lt;int&gt; siz(n + 1), son(n + 1), top(n + 1), fa(n + 1), dep(n + 1);\n    std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;\n        siz[x] = 1;\n        for (auto i : g[x])\n            if (i != fa[x]) &#123;\n                dep[i] = dep[x] + 1;\n                fa[i] = x, DFS(i);\n                siz[x] += siz[i];\n                if (siz[i] &gt; siz[son[x]])\n                    son[x] = i;\n            &#125;\n        return;\n    &#125;;\n    DFS(1);\n    DFS = [&amp;](int x) &#123;\n        if (son[x])\n            top[son[x]] = top[x], DFS(son[x]);\n        for (auto i : g[x])\n            if (i != son[x] &amp;&amp; i != fa[x])\n                top[i] = i, DFS(i);\n        return;\n    &#125;;\n    top[1] = 1, DFS(1);\n    auto askLCA = [&amp;](int x, int y) &#123;\n        for (; top[x] != top[y]; x = fa[top[x]])\n            if (dep[top[x]] &lt; dep[top[y]])\n                std::swap(x, y);\n        return dep[x] &lt; dep[y] ? x : y;\n    &#125;;\n    struct node &#123; long long x; int u, v; &#125;;\n    std::vector&lt;node&gt; q(m + 1);\n    std::vector&lt;int&gt; id(m + 1);\n    std::vector&lt;long long&gt; res(m + 1), ans(m + 1);\n    std::vector&lt;std::vector&lt;int&gt; &gt; up(n + 1), dn(n + 1), ed(n + 1);\n    for (int i = 1, x, u, v; i &lt;= m; ++i) &#123;\n        std::cin &gt;&gt; x &gt;&gt; u &gt;&gt; v;\n        q[i] = &#123; x, u, v &#125;;\n        up[u].push_back(i), dn[askLCA(u, v)].push_back(i), ed[v].push_back(i);\n    &#125;\n    std::vector&lt;int&gt; rt(n + 1);\n    DFS = [&amp;](int x) &#123;\n        rt[x] = newnode();\n        for (auto i : g[x])\n            if (i != fa[x]) &#123;\n                DFS(i);\n                merge(rt[x], rt[i]);\n            &#125;\n        add(rt[x]);\n        for (auto i : up[x])\n            id[i] = ins(rt[x], q[i].x);\n        d[rt[x]] ^= a[x];\n        for (auto i : dn[x])\n            res[i] = ask(find(id[i]));\n        return;\n    &#125;;\n    DFS(1);\n    tot = 0, rt[0] = newnode();\n    std::fill(id.begin() + 1, id.end(), 0);\n    DFS = [&amp;](int x) &#123;\n        d[rt[0]] ^= a[x];\n        for (auto i : dn[x])\n            id[i] = ins(rt[0], res[i]);\n        for (auto i : ed[x])\n            ans[i] = ask(id[i]);\n        add(rt[0]);\n        for (auto i : g[x])\n            if (i != fa[x])\n                DFS(i);\n        del(rt[0]);\n        d[rt[0]] ^= a[x];\n        return;\n    &#125;;\n    DFS(1);\n    for (int i = 1; i &lt;= m; ++i)\n        std::cout &lt;&lt; ans[i] &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"b---ビーバーの会合-2-meetings-2\">B - ビーバーの会合 2 (Meetings 2)</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/AT_joisc2021_j\" class=\"uri\">https://www.luogu.com.cn/problem/AT_joisc2021_j</a></p>\n<p>定义所求点为『局部重心』；类似树的重心，容易发现当关键点数量为奇时，只存在一个局部重心；否则，局部重心组成一条链。</p>\n<p>即对于每一个 <span class=\"math inline\">\\(i\\)</span>，需要找到一条最长链，使得其两端存在大小为 <span class=\"math inline\">\\(i\\)</span> 的子树（容易发现取后缀 max 即可得到真实答案）。使用点分治，精细实现容易做到 <span class=\"math inline\">\\(O(n\\log n)\\)</span>。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);\n    for (int i = 1, x, y; i &lt; n; ++i) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y;\n        g[x].push_back(y), g[y].push_back(x);\n    &#125;\n    std::vector&lt;int&gt; mx(n + 1), siz(n + 1), p, tag(n + 1), res(n + 1, 1);\n    std::function&lt;void(int, int)&gt; DFS1 = [&amp;](int x, int fa) &#123;\n        p.push_back(x);\n        siz[x] = 1, mx[x] = 0;\n        for (auto i : g[x])\n            if (!tag[i] &amp;&amp; i != fa) &#123;\n                DFS1(i, x);\n                siz[x] += siz[i];\n                mx[x] = std::max(mx[x], siz[i]);\n            &#125;\n        return;\n    &#125;;\n    auto findrt = [&amp;](int x) &#123;\n        p.clear(), DFS1(x, -1);\n        int n = (int)p.size();\n        for (auto i : p)\n            if (mx[i] &lt;= n / 2 &amp;&amp; n - siz[i] &lt;= n / 2)\n                return i;\n        assert(0);\n        return -1;\n    &#125;;\n    struct node &#123;\n        int u1, u2, id1, id2;\n        node(): u1(0), u2(0), id1(0), id2(0) &#123;&#125;\n        void upd(int u, int id) &#123;\n            if (id1 == id)\n                u1 = std::max(u1, u);\n            else if (u &gt;= u1)\n                u2 = u1, id2 = id1, u1 = u, id1 = id;\n            else if (u &gt;= u2)\n                u2 = u, id2 = id;\n            return;\n        &#125;\n    &#125;;\n    std::vector&lt;node&gt; s(n + 1);\n    std::function&lt;void(int, int, int, int)&gt; DFS2 = [&amp;](int x, int fa, int dep, int anc) &#123;\n        s[siz[x]].upd(dep, anc);\n        for (auto i : g[x])\n            if (!tag[i] &amp;&amp; i != fa)\n                DFS2(i, x, dep + 1, anc);\n        return;\n    &#125;;\n    std::function&lt;void(int, int, int, int)&gt; DFS3 = [&amp;](int x, int fa, int dep, int anc) &#123;\n        int v = ((s[siz[x]].id1 == anc) ? s[siz[x]].u2 : s[siz[x]].u1);\n        res[2 * siz[x]] = std::max(res[2 * siz[x]], dep + 1 + v);\n        for (auto i : g[x])\n            if (!tag[i] &amp;&amp; i != fa)\n                DFS3(i, x, dep + 1, anc);\n        return;\n    &#125;;\n    std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;\n        x = findrt(x), p.clear(), DFS1(x, -1);\n        // printf(&quot;rt = %d\\n&quot;, x);\n        for (auto i : g[x])\n            if (!tag[i])\n                DFS2(i, x, 1, i);\n        for (int i = siz[x] - 1; i; --i) &#123;\n            s[i].upd(s[i + 1].u1, s[i + 1].id1);\n            s[i].upd(s[i + 1].u2, s[i + 1].id2);\n        &#125;\n        for (auto i : g[x])\n            if (!tag[i])\n                DFS3(i, x, 1, i);\n        tag[x] = 1;\n        for (int i = 1; i &lt; siz[x]; ++i)\n            s[i] = node();\n        for (auto i : g[x])\n            if (!tag[i])\n                DFS(i);\n        return;\n    &#125;;\n    DFS(1);\n    for (int i = (n &gt;&gt; 1) * 2; i; --i)\n        if (i + 2 &lt;= n)\n            res[i] = std::max(res[i], res[i + 2]);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cout &lt;&lt; res[i] &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"c---the-closest-pair\">C - The Closest Pair</h2>\n<p><a href=\"https://ac.nowcoder.com/acm/problem/262593\" class=\"uri\">https://ac.nowcoder.com/acm/problem/262593</a></p>\n<p><strong>常规方法</strong>：考虑<strong>支配对</strong>，对于每个 <span class=\"math inline\">\\(a_i\\)</span>，找到所有合法的 <span class=\"math inline\">\\(a_j\\)</span>。容易想到枚举 <span class=\"math inline\">\\(a_i\\div a_j\\)</span> 来做；假设存在 <span class=\"math inline\">\\(a_k\\div a_i=a_j\\div a_i\\)</span> 且 <span class=\"math inline\">\\(k&gt;j\\)</span>。</p>\n<p>不妨设 <span class=\"math inline\">\\(a_j=K\\cdot a_i+p,a_k=K\\cdot a_i+q\\)</span>，<span class=\"math inline\">\\((a_i,a_j),(a_i,a_k)\\)</span> 均合法当且仅当下列条件全部成立：</p>\n<ul>\n<li><span class=\"math inline\">\\(a_j\\bmod a_i&gt;a_k\\bmod a_i\\)</span>； 则 <span class=\"math inline\">\\(a_j&gt;a_k\\)</span>。</li>\n<li><span class=\"math inline\">\\(a_j\\bmod a_k&gt;a_k\\bmod a_i\\)</span>；又 <span class=\"math inline\">\\(p-q\\ge a_j\\bmod a_k\\)</span>（<strong>太牛了这一步</strong>），即 <span class=\"math inline\">\\(p-q&gt;q\\iff p&gt;2q\\)</span>。</li>\n</ul>\n<p>证得只关心同一个 <span class=\"math inline\">\\(a_j\\div a_i\\)</span> 时的支配对数量为 <span class=\"math inline\">\\(\\log n\\)</span> 级别；总对数 <span class=\"math inline\">\\(O(n\\log n\\ln n)\\)</span>。离线下来扫描线就行了。</p>\n<details>\n<p>对着 单点修改 区间最值 想了 1h 的单 log 做法 😰 果然小脑掉线太可怕了，第二天早上重置大脑 1s 发现自己是斯波 😓</p>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int LEN = (1 &lt;&lt; 20);\nint nec(void) &#123;\n    static char buf[LEN], *p = buf, *e = buf;\n    if (p == e) &#123;\n        e = buf + fread(buf, 1, LEN, stdin);\n        if (e == buf) return EOF;\n        p = buf;\n    &#125;\n    return *p++;\n&#125;\nbool read(int &amp;x) &#123;\n    x = 0;\n    bool f = 0;\n    char ch = nec();\n    while (ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123;\n        if (ch == EOF) return 0;\n        if (ch == &#39;-&#39;) f = 1;\n        ch = nec();\n    &#125;\n    while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) &#123;\n        x = x * 10 + ch - &#39;0&#39;;\n        ch = nec();\n    &#125;\n    if (f) x = -x;\n    return 1;\n&#125;\nvoid print(int x) &#123;\n    if (x &lt; 0)\n        putchar(&#39;-&#39;), x = -x;\n    if (x &gt;= 10) print(x / 10);\n    putchar(x % 10 + &#39;0&#39;);\n    return;\n&#125;\nvoid print(int x, char ch) &#123;\n    print(x), putchar(ch);\n    return;\n&#125;\nconst int maxn = 4e6 + 5;\nstruct &#123; int l, r, u[2]; &#125; t[maxn];\n#define lt (t[p].l)\n#define rt (t[p].r)\nint tot[2];\nvoid add(int &amp;p, int l, int r, int x, int v, int i) &#123;\n    if (!p)\n        p = ++tot[i], t[p].u[0] = -1, t[p].u[1] = 0x3f3f3f3f;\n    if (i == 0)\n        t[p].u[0] = std::max(t[p].u[0], v);\n    else\n        t[p].u[1] = std::min(t[p].u[1], v);\n    if (l == r)\n        return;\n    int mid = (l + r) &gt;&gt; 1;\n    if (x &lt;= mid)\n        add(lt, l, mid, x, v, i);\n    else\n        add(rt, mid + 1, r, x, v, i);\n    return;\n&#125;\nint ask(int p, int l, int r, int ql, int qr, int i) &#123;\n    if (!p || (ql &lt;= l &amp;&amp; r &lt;= qr))\n        return t[p].u[i];\n    int mid = (l + r) &gt;&gt; 1;\n    if (qr &lt;= mid)\n        return ask(lt, l, mid, ql, qr, i);\n    if (ql &gt; mid)\n        return ask(rt, mid + 1, r, ql, qr, i);\n    if (i == 0)\n        return std::max(ask(lt, l, mid, ql, qr, 0), ask(rt, mid + 1, r, ql, qr, 0));\n    return std::min(ask(lt, l, mid, ql, qr, 1), ask(rt, mid + 1, r, ql, qr, 1));\n&#125;\n#undef lt\n#undef rt\nint main() &#123;\n#ifndef ONLINE_JUDGE\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    const int m = 1e6;\n    int rt[2] = &#123; 0 &#125;, n;\n    t[0].u[0] = -1, t[0].u[1] = 0x3f3f3f3f;\n    read(n);\n    std::vector&lt;int&gt; a(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        read(a[i]);\n    std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; t(n + 1);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        if (i != 1) &#123;\n            for (int K = a[i]; K &lt;= m; K += a[i]) &#123;\n                for (int mx = std::min(a[i] - 1, m - K); ; ) &#123;\n                    int k = ask(rt[0], 1, m, K, K + mx, 0);\n                    if (k == -1)\n                        break;\n                    t[i].emplace_back(k, a[k] - K);\n                    if (k == 1 || !(a[k] - K))\n                        break;\n                    mx = (a[k] - K - 1) / 2;\n                &#125;\n            &#125;\n        &#125;\n        add(rt[0], 1, m, a[i], i, 0);\n    &#125;\n    for (int i = n; i; --i) &#123;\n        if (i != n)\n            for (int K = a[i]; K &lt;= m; K += a[i])\n                for (int mx = std::min(a[i] - 1, m - K); ; ) &#123;\n                    int k = ask(rt[1], 1, m, K, K + mx, 1);\n                    if (k == 0x3f3f3f3f)\n                        break;\n                    t[k].emplace_back(i, a[k] - K);\n                    if (k == n || !(a[k] - K))\n                        break;\n                    mx = (a[k] - K - 1) / 2;\n                &#125;\n        add(rt[1], 1, m, a[i], i, 1);\n    &#125;\n    int q;\n    read(q);\n    std::vector&lt;int&gt; res(q + 1);\n    std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; u(n + 1);\n    for (int i = 1, l, r; i &lt;= q; ++i) &#123;\n        read(l), read(r);\n        if (l &gt; r)\n            std::swap(l, r);\n        u[r].emplace_back(l, i);\n    &#125;\n    std::vector&lt;int&gt; bit(n + 1, 0x3f3f3f3f);\n    auto lowbit = [&amp;](int x) &#123; return x &amp; -x; &#125;;\n    auto add = [&amp;](int x, int v) &#123;\n        for (; x &lt;= n; x += lowbit(x))\n            bit[x] = std::min(bit[x], v);\n        return;\n    &#125;;\n    auto ask = [&amp;](int x) &#123;\n        auto res = 0x3f3f3f3f;\n        for (; x; x -= lowbit(x))\n            res = std::min(res, bit[x]);\n        return res;\n    &#125;;\n    for (int r = 1; r &lt;= n; ++r) &#123;\n        for (auto [l, v] : t[r])\n            add(n - l + 1, v);\n        for (auto [l, i] : u[r])\n            res[i] = ask(n - l + 1);\n    &#125;\n    for (int i = 1; i &lt;= q; ++i)\n        print(res[i], &#39;\\n&#39;);\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<p>求支配对的过程也要带 log（线段树），再加上扫描线的 3log，总共是常数比较大的 3log（卡了一个上午的常也是有了）。所以接下来讲解另一种奇技淫巧。</p>\n<p><strong>暴力分治</strong>：注意到对于比较长（<span class=\"math inline\">\\(len&gt; B\\)</span>）的区间，答案比较小；故考虑分治。</p>\n<ul>\n<li>对于长询问（<span class=\"math inline\">\\(len&gt;B\\)</span>），从小到大枚举答案并 check；预处理某个范围（<span class=\"math inline\">\\(V\\)</span>）内的 <span class=\"math inline\">\\(res\\)</span> 出现的所有位置，平衡的时候还要算上调和级数和 bit。</li>\n<li>对于短询问（<span class=\"math inline\">\\(len\\le B\\)</span>），发现每次区间内暴力是 <span class=\"math inline\">\\(O(B^2q)\\)</span> 的；把询问离线下来，精细实现，利用询问的公共部分使得<strong>每一对数只被枚举一次</strong>就能达到 <span class=\"math inline\">\\(O(B^2 + Bq)\\)</span>。</li>\n</ul>\n<p>最优解取 <span class=\"math inline\">\\(B=333,V=483\\)</span>，不自己实现一遍了。</p>\n<hr />\n<h2 id=\"d---仙人掌\">D - 仙人掌</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P3687\" class=\"uri\">https://www.luogu.com.cn/problem/P3687</a></p>\n<p>把边双从图中删除、问题转化为树上<strong>边</strong>不交的链覆盖，使得<strong>所有链长 <span class=\"math inline\">\\(\\ge 2\\)</span></strong> 的方案数。发现由于<strong>边可以不被覆盖</strong>，常规 DP 会使得在父节点处合并时需要额外的数量维，参考树上背包，复杂度 <span class=\"math inline\">\\(O(n^2)\\)</span>。</p>\n<p>思考时会注意到两个限制可以抵消——如果认为长为 <span class=\"math inline\">\\(1\\)</span> 的链就是不被覆盖的边，覆盖所有树边，显然可以建立和合法解的双射。此时合并是非常方便的，注意到每个儿子的系数一定都参与『分步』，只需要求出『分类』的系数。这个可以预处理（和 <a href=\"/20250407/#a.-二分图染色\">二分图染色</a> 这个题有点像），令 <span class=\"math inline\">\\(f_i\\)</span> 表示一个点度数为 <span class=\"math inline\">\\(i\\)</span> 时的答案，参考错排的思路，则 <span class=\"math inline\">\\(i\\)</span> 可以不参与配对，也可以乱选一个点配对，如果选中了已配对的点就令其和 <span class=\"math inline\">\\(i-1\\)</span> 交换，可以建立和合法解的双射。则 <span class=\"math inline\">\\(f_i=f_{i-1}+(n-1)f_{i-2}\\)</span>。</p>\n<p>首先需要 check 原图是否为仙人掌，顺带回忆一下连通性的知识——在 DFS 树上差分，检查是否有边被覆盖两次即可。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 998244353;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int T;\n    for (std::cin &gt;&gt; T; T--; ) &#123;\n        int n, m;\n        std::cin &gt;&gt; n &gt;&gt; m;\n        std::vector&lt;std::vector&lt;int&gt; &gt; g1(n + 1);\n        for (int x, y; m--; ) &#123;\n            std::cin &gt;&gt; x &gt;&gt; y;\n            g1[x].push_back(y), g1[y].push_back(x);\n        &#125;\n        bool flag = 1;\n        int now = 0, cnt = 0;\n        std::vector&lt;int&gt; st, dfn(n + 1), low(n + 1), col(n + 1), diff(n + 1);\n        std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int fa) &#123;\n            st.push_back(x);\n            dfn[x] = low[x] = ++now;\n            for (auto i : g1[x])\n                if (!dfn[i]) &#123;\n                    // printf(&quot;x = %d, %d -&gt; %d\\n&quot;, x, x, i);\n                    DFS(i, x);\n                    diff[x] += diff[i];\n                    // printf(&quot;x = %d, diff[%d] += diff[%d]\\n&quot;, x, x, i);\n                    low[x] = std::min(low[x], low[i]);\n                &#125;\n                else if (i != fa &amp;&amp; dfn[i] &lt; dfn[x]) &#123;\n                    low[x] = std::min(low[x], dfn[i]);\n                    ++diff[x], --diff[i];\n                    // printf(&quot;x = %d, ++diff[%d], --diff[%d]\\n&quot;, x, x, i);\n                &#125;\n            if (diff[x] &gt;= 2)\n                flag = 0;\n            // printf(&quot;x = %d, diff[%d] = %d\\n&quot;, x, x, diff[x]);\n            if (low[x] == dfn[x]) &#123;\n                ++cnt;\n                for (int p = -1; p != x; ) &#123;\n                    p = st.back(), st.pop_back();\n                    col[p] = cnt;\n                &#125;\n            &#125;\n            return;\n        &#125;;\n        DFS(1, -1);\n        if (!flag) &#123;\n            std::cout &lt;&lt; 0 &lt;&lt; &#39;\\n&#39;;\n            continue;\n        &#125;\n        std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);\n        for (int i = 1; i &lt;= n; ++i)\n            for (auto j : g1[i])\n                if (col[i] != col[j])\n                    g[i].push_back(j);\n        std::vector&lt;long long&gt; f(n + 1), dp(n + 1);\n        dp[0] = 1ll, dp[1] = 1ll;\n        for (int i = 2; i &lt;= n; ++i)\n            dp[i] = (dp[i - 1] + (i - 1) * dp[i - 2]) % mod;\n        std::vector&lt;int&gt; tag(n + 1);\n        DFS = [&amp;](int x, int fa) &#123;\n            f[x] = 1ll, tag[x] = 1;\n            for (auto i : g[x])\n                if (i != fa) &#123;\n                    DFS(i, x);\n                    (f[x] *= f[i]) %= mod;\n                &#125;\n            (f[x] *= dp[(int)g[x].size()]) %= mod;\n            return;\n        &#125;;\n        auto res(1ll);\n        for (int i = 1; i &lt;= n; ++i)\n            if (!tag[i])\n                DFS(i, -1), (res *= f[i]) %= mod;\n        std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<p>E. Many Minimizations 是数学题，跳了。</p>\n<hr />\n<hr />\n<h2 id=\"无名题\">无名题</h2>\n<blockquote>\n<p>背景：给定 <span class=\"math inline\">\\(n,k\\)</span>，对于 <span class=\"math inline\">\\(\\forall\\, 1\\le i\\le n\\)</span>，令 <span class=\"math inline\">\\(a_i=i\\bmod k\\)</span>，问一共有多少个本质不同的子序列？对于 <span class=\"math inline\">\\(k=1,2,\\cdots,n\\)</span> 分别求出答案。</p>\n</blockquote>\n<hr />\n<h2 id=\"maimai\">maimai</h2>\n<p><a href=\"https://ac.nowcoder.com/acm/contest/66112/F\" class=\"uri\">https://ac.nowcoder.com/acm/contest/66112/F</a></p>\n",
            "tags": [
                "字典树",
                "字符串",
                "组合数学",
                "支配对"
            ]
        }
    ]
}