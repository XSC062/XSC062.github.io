{
    "version": "https://jsonfeed.org/version/1",
    "title": "null â€¢ All posts by \"æ”¯é…å¯¹\" tag",
    "description": "",
    "home_page_url": "https://xsc062.netlify.app",
    "items": [
        {
            "id": "https://xsc062.netlify.app/20250830/",
            "url": "https://xsc062.netlify.app/20250830/",
            "title": "å­¦ä¹ ç¬”è®° æ”¯é…å¯¹",
            "date_published": "2025-08-30T03:47:08.000Z",
            "content_html": "<p>ä¸€ç§è´ªå¿ƒæ€æƒ³ï¼Œå¾ˆç¬¦åˆç›´è§‰ï¼Œåˆæœ‰ç‚¹åƒä¹±æ</p>\n<span id=\"more\"></span>\n<hr />\n<ul>\n<li>è€ƒè™‘ä¸€ç±»ç‚¹å¯¹ç»Ÿè®¡é—®é¢˜ï¼Œå½¢å¦‚ç»™å®š <span class=\"math inline\">\\([l,r]\\)</span>ï¼Œå¯¹äº <span class=\"math inline\">\\([l\\le x\\le y\\le r]\\)</span>ï¼Œä½ éœ€è¦å¯»æ‰¾æ»¡è¶³æŸä¸ªé™åˆ¶çš„ <span class=\"math inline\">\\((x,y)\\)</span> æ•°é‡ï¼Œæˆ–è€…æ˜¯æ‰€æœ‰ <span class=\"math inline\">\\((x,y)\\)</span> çš„æœ€å¤§æƒå€¼</li>\n<li><p>å¦‚æœå­˜åœ¨ <span class=\"math inline\">\\([x_1,y_1]\\subset [x_2,y_2]\\)</span> ä¸” <span class=\"math inline\">\\([x_1,y_1]\\)</span> æ»¡è¶³é™åˆ¶ / è´¡çŒ®æ›´å¤§ï¼Œå°±å¯ä»¥åªä¿ç•™ <span class=\"math inline\">\\([x_1,y_1]\\)</span></p>\nå› ä¸ºç»Ÿè®¡äº† <span class=\"math inline\">\\([x_2,y_2]\\)</span> å°±å¿…é¡»è¦ç»Ÿè®¡ <span class=\"math inline\">\\([x_1,y_1]\\)</span>ï¼Œåä¹‹åˆ™ä¸ä¸€å®šæˆç«‹ã€‚</li>\n<li><p>é¢˜ç›®ä¼šç»™å‡ºä¸€äº›æ€§è´¨ä½¿å¾—æœ€ç»ˆä¿ç•™ä¸‹æ¥çš„ <span class=\"math inline\">\\([x_1,y_1]\\)</span> çš„æ•°é‡ä¸å¤š</p></li>\n</ul>\n<hr />\n<h2 id=\"æ ‘ä¸Šæ”¯é…å¯¹-ç¬¬ä¸€ç±»æ”¯é…å¯¹\">æ ‘ä¸Šæ”¯é…å¯¹ / ç¬¬ä¸€ç±»æ”¯é…å¯¹</h2>\n<ul>\n<li>è¿™ç±»é—®é¢˜çš„ç‰¹å¾å¾ˆæ˜æ˜¾ï¼Œå¤šæ¬¡è¯¢é—®ï¼Œç»™å®šä¸€ä¸ªç¼–å·åŒºé—´ï¼Œç»Ÿè®¡æ ‘ä¸Šç‚¹å¯¹ç›¸å…³ä¿¡æ¯ã€‚</li>\n<li><p>ä¼šæƒ³åˆ°ç‚¹åˆ†æ²»ã€dsu on tree è¿™ä¸¤ä¸ªå·¥å…·ï¼Œå…¶ä¸­ç‚¹åˆ†æ²»å¤„ç†è·ç¦»é—®é¢˜æ›´æ–¹ä¾¿ï¼Œdsu on tree æ›´å¸¸ç”¨æ¥å¤„ç† LCA é—®é¢˜</p>\nå›ºå®šå½“å‰çš„æ ¹ä¹‹åï¼Œé’¦å®šæ”¯é…å¯¹æ¥è‡ªä¸¤ä¸ªä¸åŒå­æ ‘ï¼ˆæ³¨æ„æ ¹è‡ªèº«å‚ä¸å½¢æˆæ”¯é…å¯¹çš„æƒ…å†µï¼‰ï¼Œé‚£ä¹ˆå…±æœ‰ <span class=\"math inline\">\\(O(n\\log n)\\)</span> å¯¹æ”¯é…å¯¹</li>\n<li><p>å…ˆç”¨è¿™ä¸¤ç§æ–¹æ³•åœ¨æ ‘ä¸Šæ‰¾åˆ°æ”¯é…å¯¹ï¼Œå°±å¯ä»¥æŠŠè¯¢é—®ç¦»çº¿ä¸‹æ¥åšæ‰«æçº¿ä¹‹ç±»çš„äº†</p></li>\n</ul>\n<p>æœ¬è´¨æ˜¯åˆ©ç”¨ LCA çš„æ ‘ä¸Šæ€§è´¨ï¼Œä»¥åŠç‚¹åˆ†ã€dsu on tree åªç”¨ç»Ÿè®¡ <span class=\"math inline\">\\(O(n\\log n)\\)</span> ä¸ªå•ä¾§ç‚¹ï¼ŒåŒæ—¶å¯¹äºæ¯ä¸ªå•ä¾§ç‚¹åªå­˜åœ¨ <span class=\"math inline\">\\(O(1)\\)</span> ä¸ªç›¸åº”çš„å‰é©±ã€åç»§ç‚¹è¾¾åˆ° LCA æ‰¾åˆ° <span class=\"math inline\">\\(O(n\\log n)\\)</span> ä¸ªæ”¯é…å¯¹</p>\n<hr />\n<h3 id=\"d---rldcot\">D - rldcot</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P7880\" class=\"uri\">https://www.luogu.com.cn/problem/P7880</a></p>\n<ul>\n<li>è‹¥å­˜åœ¨ <span class=\"math inline\">\\((x_1,y_1)\\)</span> å’Œ <span class=\"math inline\">\\((x_2,y_2)\\)</span> æ‹¥æœ‰ç›¸åŒçš„ LCAï¼Œé‚£ä¹ˆè®¤ä¸º <span class=\"math inline\">\\((x_1,y_1)\\)</span> æ”¯é…äº† <span class=\"math inline\">\\((x_2,y_2)\\)</span></li>\n<li>æ ‘æœ‰æ ¹ï¼Œæ•…éœ€è¦ dsu on tree</li>\n<li>ç”¨ä¸€ä¸ª set å¤„ç†å‰é©±ã€åç»§çš„æŸ¥è¯¢ï¼Œç„¶åå°±æ˜¯æ­£å¸¸çš„ dsu on tree äº†</li>\n<li>ç¦»çº¿ä¸‹æ¥æ‰«æçº¿ï¼Œæ ‘çŠ¶æ•°ç»„å®æ—¶ç»´æŠ¤æ¯ä¸ªé¢œè‰²ï¼ˆç¦»æ•£åŒ–ä¸€ä¸‹ï¼‰æœ€é å³çš„åŒºé—´å³å¯</li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    using ll = long long;\n    int n, m;\n    std::cin &gt;&gt; n &gt;&gt; m;\n    std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; g(n + 1);\n    for (int i = 1, x, y, w; i &lt; n; ++i) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y &gt;&gt; w;\n        g[x].emplace_back(y, w);\n        g[y].emplace_back(x, w);\n    &#125;\n    int tot = 0;\n    std::vector&lt;ll&gt; dep(n + 1);\n    std::unordered_map&lt;ll, int&gt; tab;\n    std::vector&lt;int&gt; siz(n + 1), son(n + 1), col(n + 1);\n    std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int fa) &#123;\n        siz[x] = 1;\n        if (!tab.count(dep[x]))\n            tab[dep[x]] = ++tot;\n        col[x] = tab[dep[x]];\n        for (auto [i, w] : g[x])\n            if (i != fa) &#123;\n                dep[i] = dep[x] + w;\n                DFS(i, x);\n                siz[x] += siz[i];\n                if (siz[i] &gt; siz[son[x]])\n                    son[x] = i;\n            &#125;\n        return;\n    &#125;;\n    DFS(1, -1);\n    std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; u(n + 1);\n    std::function&lt;void(int, int, int, std::set&lt;int&gt; &amp;)&gt; DFS2 = [&amp;](int col, int x, int fa, std::set&lt;int&gt; &amp;t) &#123;\n        auto p = t.lower_bound(x);\n        if (col == -1)\n            t.insert(x);\n        else &#123;\n            if (p != t.begin())\n                u[x].emplace_back(*std::prev(p), col );\n            if (p != t.end())\n                u[*p].emplace_back(x, col);\n        &#125;\n        for (auto [i, w] : g[x])\n            if (i != fa)\n                DFS2(col, i, x, t);\n        return;\n    &#125;;\n    std::function&lt;void(int, int, std::set&lt;int&gt; &amp;)&gt; DFS1 = [&amp;](int x, int fa, std::set&lt;int&gt; &amp;t) &#123;\n        if (son[x])\n            DFS1(son[x], x, t);\n        for (auto [i, w] : g[x])\n            if (i != fa &amp;&amp; i != son[x]) &#123;\n                std::set&lt;int&gt; nt;\n                DFS1(i, x, nt);\n            &#125;\n        t.insert(x);\n        u[x].emplace_back(x, col[x]);\n        for (auto [i, w] : g[x])\n            if (i != fa &amp;&amp; i != son[x])\n                DFS2(col[x], i, x, t), DFS2(-1, i, x, t);\n        return;\n    &#125;;\n    &#123;\n        std::set&lt;int&gt; t;\n        DFS1(1, -1, t);\n    &#125;\n    std::vector&lt;int&gt; res(m + 1);\n    std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; t(n + 1);\n    for (int i = 1, l, r; i &lt;= m; ++i) &#123;\n        std::cin &gt;&gt; l &gt;&gt; r;\n        t[r].emplace_back(l, i);\n    &#125;\n    std::vector&lt;int&gt; bit(n + 1), la(tot + 1);\n    auto lowbit = [](int x) &#123;\n        return x &amp; -x;\n    &#125;;\n    auto add = [&amp;](int x, int v) &#123;\n        for (; x &lt;= n; x += lowbit(x))\n            bit[x] += v;\n        return;\n    &#125;;\n    auto ask = [&amp;](int x) &#123;\n        int res = 0;\n        for (; x; x -= lowbit(x))\n            res += bit[x];\n        return res;\n    &#125;;\n    for (int r = 1; r &lt;= n; ++r) &#123;\n        for (auto [l, c] : u[r])\n            if (l &gt; la[c]) &#123;\n                if (la[c])\n                    add(la[c], -1);\n                add(l, 1), la[c] = l;\n            &#125;\n        for (auto [l, id] : t[r])\n            res[id] = ask(r) - ask(l - 1);\n    &#125;\n    for (int i = 1; i &lt;= m; ++i)\n        std::cout &lt;&lt; res[i] &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"e---é“ƒåŸéœ²éœ²\">E - é“ƒåŸéœ²éœ²</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P8528\" class=\"uri\">https://www.luogu.com.cn/problem/P8528</a></p>\n<ul>\n<li><p>è€ƒè™‘ä¸€ä¸‹æ”¯é…å…³ç³»åœ¨å“ªé‡Œï¼Œå›ºå®šä¸€ä¸ª LCA <span class=\"math inline\">\\(z\\)</span>ï¼Œè®¨è®º <span class=\"math inline\">\\(a_z\\)</span> ä¸ <span class=\"math inline\">\\(a_x,a_y\\)</span> çš„å¤§å°å…³ç³»ç»™ <span class=\"math inline\">\\([1,a_x]\\)</span> é—´çš„ <span class=\"math inline\">\\(l\\)</span> å¸¦æ¥çš„é™åˆ¶ï¼š</p>\n<ul>\n<li><span class=\"math inline\">\\(a_z\\in[a_x,a_y]\\)</span>ï¼Œ<span class=\"math inline\">\\((x,y)\\)</span> æ€»æ˜¯åˆæ³•ï¼Œæ— é™åˆ¶ã€‚</li>\n<li><span class=\"math inline\">\\(a_z&lt;a_x\\)</span>ï¼Œå¯¹äº <span class=\"math inline\">\\(r\\ge a_y\\)</span>ï¼Œå½“ <span class=\"math inline\">\\(l\\in(a_z,a_x]\\)</span> æ—¶ï¼Œ<span class=\"math inline\">\\((x,y)\\)</span> éæ³•ã€‚</li>\n<li><span class=\"math inline\">\\(a_z&gt;a_y\\)</span>ï¼Œå½“ <span class=\"math inline\">\\(r\\in[a_y,a_z)\\)</span> æ—¶ï¼Œ<span class=\"math inline\">\\((x,y)\\)</span> æ€»æ˜¯éæ³•ã€‚æ­¤æ—¶æ‰€æœ‰ <span class=\"math inline\">\\(l\\in[1,a_x]\\)</span> ä¸å¯é€‰ã€‚</li>\n</ul></li>\n<li>å‘ç°å›ºå®š <span class=\"math inline\">\\(a_z,a_x\\)</span>ï¼Œé‚£ä¹ˆå½“ <span class=\"math inline\">\\(a_y\\)</span> è¶Šé è¿‘ <span class=\"math inline\">\\(a_x\\)</span> æ—¶ç»™å‡ºçš„é™åˆ¶è¶Šç´§ï¼Œåä¹‹äº¦ç„¶ï¼Œå°±å¯ä»¥å¾—åˆ°è¿™æ ·çš„æ”¯é…å…³ç³»</li>\n<li>å®¹æ˜“å‘ç°å½“ <span class=\"math inline\">\\(a_z\\notin [a_x,a_y]\\)</span> æ—¶ï¼Œ<span class=\"math inline\">\\((x,y)\\)</span> ä¸åˆæ³•ï¼›æ•…åªéœ€è¦åœ¨ dsu on tree ä¸Šæ‰¾åˆ° <span class=\"math inline\">\\(a_x\\)</span> çš„å‰é©±ã€åç»§å¹¶ç»Ÿè®¡æ”¯é…å¯¹å³å¯</li>\n<li><p>è€ƒè™‘è¯¢é—®ï¼Œå‘ç°éœ€è¦ç»´æŠ¤åŒºé—´åŠ ã€åŒºé—´å†å² 0 ä¸ªæ•°ï¼Œåè€…æ˜¯ç»å…¸ trickï¼Œæ˜¯å¥½åšçš„ã€‚</p></li>\n</ul>\n<p>å†å²æ ‡è®°çš„ä¸‹ä¼ éœ€è¦æ ¼å¤–æ³¨æ„ä¸€ä¸‹ï¼Œåº”è¯¥åªä¿è¯æ ‡è®°æœŸé—´å­˜åœ¨ 0 çš„åŒºé—´æ‹¥æœ‰æ‡’æ ‡è®°ï¼›å…·ä½“åœ°ï¼Œ<strong>åªåº”å°†å…¶ä¸‹ä¼ åˆ°å’Œå½“å‰åŒºé—´æœ€å°å€¼ç›¸åŒçš„å­åŒºé—´</strong>ï¼ˆå…·ä½“å¯ä»¥çœ‹ä»£ç ï¼‰ï¼Œå®¹æ˜“è¯æ˜æ˜¯å¯¹çš„ã€‚</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 2e5 + 5;\nstruct node &#123;\n    long long s;\n    int l, r, u, c, d, d1;\n    node operator+ (const node q) const &#123;\n        node res;\n        res.s = s + q.s;\n        res.l = l, res.r = q.r;\n        res.u = std::min(u, q.u);\n        res.d = res.d1 = res.c = 0;\n        if (u == res.u)\n            res.c = c;\n        if (q.u == res.u)\n            res.c += q.c;\n        return res;\n    &#125;\n&#125; t[maxn &lt;&lt; 2];\n#define lt (p &lt;&lt; 1)\n#define rt (lt | 1)\nvoid bld(int p, int l, int r) &#123;\n    t[p].c = r - l + 1;\n    t[p].l = l, t[p].r = r;\n    if (l == r)\n        return;\n    int mid = (l + r) &gt;&gt; 1;\n    bld(lt, l, mid), bld(rt, mid + 1, r);\n    return;\n&#125;\nvoid pushdown(int p) &#123;\n    if (t[p].d) &#123;\n        t[lt].d += t[p].d, t[lt].u += t[p].d;\n        t[rt].d += t[p].d, t[rt].u += t[p].d;\n        t[p].d = 0;\n    &#125;\n    if (t[p].d1) &#123;\n        if (t[lt].u == t[p].u) &#123;\n            t[lt].s += (long long)t[lt].c * t[p].d1;\n            t[lt].d1 += t[p].d1;\n        &#125;\n        if (t[rt].u == t[p].u) &#123;\n            t[rt].s += (long long)t[rt].c * t[p].d1;\n            t[rt].d1 += t[p].d1;\n        &#125;\n        t[p].d1 = 0;\n    &#125;\n    return;\n&#125;\nvoid add(int p, int l, int r, int v) &#123;\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r) &#123;\n        t[p].d += v, t[p].u += v;\n        return;\n    &#125;\n    pushdown(p);\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (l &lt;= mid)\n        add(lt, l, r, v);\n    if (r &gt; mid)\n        add(rt, l, r, v);\n    t[p] = t[lt] + t[rt];\n    return;\n&#125;\nvoid upd(int p, int l, int r) &#123;\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r) &#123;\n        if (!t[p].u)\n            t[p].s += t[p].c, ++t[p].d1;\n        return;\n    &#125;\n    pushdown(p);\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (l &lt;= mid)\n        upd(lt, l, r);\n    if (r &gt; mid)\n        upd(rt, l, r);\n    t[p] = t[lt] + t[rt];\n    return;\n&#125;\nlong long ask(int p, int l, int r) &#123;\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r)\n        return t[p].s;\n    pushdown(p);\n    auto res(0ll);\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (l &lt;= mid)\n        res = ask(lt, l, r);\n    if (r &gt; mid)\n        res += ask(rt, l, r);\n    return res;\n&#125;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, m;\n    std::cin &gt;&gt; n &gt;&gt; m;\n    std::vector&lt;int&gt; a(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i];\n    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1); \n    for (int i = 2, x; i &lt;= n; ++i)\n        std::cin &gt;&gt; x, g[x].push_back(i);\n    std::vector&lt;int&gt; siz(n + 1), son(n + 1);\n    std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;\n        siz[x] = 1;\n        for (auto i : g[x]) &#123;\n            DFS(i);\n            siz[x] += siz[i];\n            if (siz[i] &gt; siz[son[x]])\n                son[x] = i;\n        &#125;\n        return;\n    &#125;;\n    DFS(1);\n    std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; u1(n + 1), u2(n + 1);\n    std::function&lt;void(int, int, std::set&lt;int&gt; &amp;)&gt; DFS2 = [&amp;](int col, int x, std::set&lt;int&gt; &amp;t) &#123;\n        auto p = t.lower_bound(a[x]);\n        if (col == -1)\n            t.insert(a[x]);\n        else &#123;\n            if (p != t.begin()) &#123;\n                int y = *std::prev(p);\n                if (col &lt; y)\n                    u1[a[x]].emplace_back(col + 1, y);\n                else if (col &gt; a[x]) &#123;\n                    u1[a[x]].emplace_back(1, y);\n                    u2[col].emplace_back(1, y);\n                &#125;\n            &#125;\n            if (p != t.end()) &#123;\n                int y = *p;\n                if (col &lt; a[x])\n                    u1[y].emplace_back(col + 1, a[x]);\n                else if (col &gt; y) &#123;\n                    u1[y].emplace_back(1, a[x]);\n                    u2[col].emplace_back(1, a[x]);\n                &#125;\n            &#125;\n        &#125;\n        for (auto i : g[x])\n            DFS2(col, i, t);\n        return;\n    &#125;;\n    std::function&lt;void(int, std::set&lt;int&gt; &amp;)&gt; DFS1 = [&amp;](int x, std::set&lt;int&gt; &amp;t) &#123;\n        if (son[x])\n            DFS1(son[x], t);\n        for (auto i : g[x])\n            if (i != son[x]) &#123;\n                std::set&lt;int&gt; nt;\n                DFS1(i, nt);\n            &#125;\n        t.insert(a[x]);\n        for (auto i : g[x])\n            if (i != son[x])\n                DFS2(a[x], i, t), DFS2(-1, i, t);\n        return;\n    &#125;;\n    &#123;\n        std::set&lt;int&gt; t;\n        DFS1(1, t);\n    &#125;\n    std::vector&lt;long long&gt; res(m + 1);\n    std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; t(n + 1);\n    for (int i = 1, l, r; i &lt;= m; ++i) &#123;\n        std::cin &gt;&gt; l &gt;&gt; r;\n        t[r].emplace_back(l, i);\n    &#125;\n    bld(1, 1, n);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        for (auto [l, r] : u1[i])\n            add(1, l, r, 1);\n        for (auto [l, r] : u2[i])\n            add(1, l, r, -1);\n        upd(1, 1, i);\n        for (auto [l, id] : t[i])\n            res[id] = ask(1, l, i);\n    &#125;\n    for (int i = 1; i &lt;= m; ++i)\n        std::cout &lt;&lt; res[i] &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n",
            "tags": [
                "æ”¯é…å¯¹"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20250809/",
            "url": "https://xsc062.netlify.app/20250809/",
            "title": "è¿‘æœŸæ‚é¢˜",
            "date_published": "2025-08-09T04:33:17.000Z",
            "content_html": "<p>è¿™æ®µæ—¶é—´æ¯”èµ›çš„ä¸€äº›é¢˜ å’Œ nKessiã€duanyu è®²çš„é¢˜ç›®ã€‚å¤ªåè®¡æ•°ã€æ•°å­¦çš„åŸºæœ¬ä¸Šæ²¡åŠæ³•åšäº†ã€‚</p>\n<span id=\"more\"></span>\n<hr />\n<h2 id=\"a.-å‡ºå…³\">A. å‡ºå…³</h2>\n<p><a href=\"http://222.180.160.110:61235/contest/6462/problem/1\" class=\"uri\">http://222.180.160.110:61235/contest/6462/problem/1</a></p>\n<blockquote>\n<p>ç»™å®š <span class=\"math inline\">\\(s\\)</span>ï¼Œå¯¹äºä¸€ä¸ªç©ºä¸²ï¼Œä»»æ„åˆ©ç”¨ä¸‹åˆ—ä¸‰ç§æ“ä½œï¼Œä½¿å…¶å˜ä¸º <span class=\"math inline\">\\(s\\)</span>ï¼Œæ±‚æœ€å°ä»£ä»·ï¼š</p>\n<ol type=\"1\">\n<li>åœ¨æœ«å°¾æ·»åŠ å­—ç¬¦ <span class=\"math inline\">\\(c\\)</span>ï¼Œä»£ä»·ä¸º <span class=\"math inline\">\\(t_{0,c}\\)</span>ï¼›</li>\n<li>å¤åˆ¶æ•´ä¸ªå­—ç¬¦ä¸²å¹¶ç²˜è´´åœ¨æœ«å°¾ï¼Œä»£ä»·ä¸º <span class=\"math inline\">\\(t_1\\)</span>ï¼›</li>\n<li>åˆ é™¤æœ«å°¾å­—ç¬¦ï¼Œä»£ä»·ä¸º <span class=\"math inline\">\\(t_2\\)</span>ã€‚</li>\n</ol>\n<p><span class=\"math inline\">\\(|s|\\le 10^6\\)</span>ã€‚</p>\n</blockquote>\n<p>å¯ä»¥é¢„å¤„ç†å‡ºå¯¹äºæ¯ä¸ª <span class=\"math inline\">\\(i\\)</span> ç»“å°¾ï¼Œæœ€å¤šå¯ä»¥å¤åˆ¶åˆ°å“ªä¸ªåœ°æ–¹ï¼Œå‘ç°è¦æ±‚ <span class=\"math inline\">\\(z_i=lcp(s_{1\\dots n},s_{i+1\\dots n})\\)</span>ã€‚é‚£ä¹ˆä¸€ä¸ª <span class=\"math inline\">\\(i\\)</span> çš„æœ€è¿œè½¬ç§»ç‚¹ <span class=\"math inline\">\\(r_i=i+z_{i+1}\\)</span>ï¼Œç”¨å•è°ƒé˜Ÿåˆ—å°±èƒ½ç»´æŠ¤ï¼Œä¼š exkmp å°±èƒ½çº¿æ€§ï¼›</p>\n<p>å¦åˆ™å¯ä»¥äºŒåˆ† + å“ˆå¸Œå¤šä¸ª logï¼Œåé¢ä¹Ÿæœ‰ç†ç”±å·æ‡’ç”¨ä¼˜å…ˆé˜Ÿåˆ—äº†ã€‚</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int p = 31;\nconst int mod = 998244353;\nint main() &#123;\n    std::freopen(&quot;laozi.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;laozi.out&quot;, &quot;w&quot;, stdout);\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n    std::string s;\n    std::cin &gt;&gt; s;\n    int n = (int)s.length(), t1, t2;\n    std::vector&lt;long long&gt; h(n + 1), base(n + 1);\n    std::vector&lt;int&gt; a(n + 1), t0(27), z(n + 1), r(n + 1);\n    base[0] = 1ll;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        a[i] = s[i - 1] - &#39;a&#39; + 1;\n        h[i] = (h[i - 1] * p + a[i]) % mod;\n        base[i] = base[i - 1] * p % mod;\n    &#125;\n    auto gethash = [&amp;](int l, int r) &#123;\n        return (h[r] - h[l - 1] * base[r - l + 1] % mod + mod) % mod;\n    &#125;;\n    for (int i = 1; i &lt;= n; ++i)\n        for (int l = 1, r = std::min(i - 1, n - i + 1), mid; l &lt;= r; ) &#123;\n            mid = (l + r) &gt;&gt; 1;\n            if (gethash(1, mid) == gethash(i, i + mid - 1))\n                z[i] = mid, l = mid + 1;\n            else\n                r = mid - 1;\n        &#125;\n    for (int i = 1; i &lt; n; ++i)\n        r[i] = i + std::min(i, z[i + 1]);\n    for (int i = 1; i &lt;= 26; ++i)\n        std::cin &gt;&gt; t0[i];\n    std::cin &gt;&gt; t1 &gt;&gt; t2;\n    std::vector&lt;long long&gt; f(n + 1);\n    std::priority_queue&lt;std::pair&lt;long long, int&gt; &gt; q;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        f[i] = f[i - 1] + t0[a[i]];\n        for (; !q.empty() &amp;&amp; r[q.top().second] &lt; i; q.pop());\n        if (!q.empty())\n            f[i] = std::min(f[i], t1 - q.top().first - (long long)t2 * i);\n        if (i != n)\n            q.emplace(-(f[i] + 2ll * t2 * i), i);\n    &#125;\n    std::cout &lt;&lt; f[n] &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"d.-éæ”»\">D. éæ”»</h2>\n<p><a href=\"http://222.180.160.110:61235/contest/6462/problem/4\" class=\"uri\">http://222.180.160.110:61235/contest/6462/problem/4</a></p>\n<blockquote>\n<p>ç»™å®š <span class=\"math inline\">\\(n\\)</span>ï¼Œå¯¹äºä¸€ä¸ª <span class=\"math inline\">\\(1\\sim n\\)</span> çš„æ’åˆ—ï¼Œä½¿ç”¨æœ€å°çš„äº¤æ¢æ¬¡æ•°ä½¿å¾—å…¶å•å¢ã€‚åœ¨è¯¥å‰æä¸‹ï¼Œå®šä¹‰ä»£ä»·ä¸ºæ¯æ¬¡äº¤æ¢çš„ä¸¤ä¸ªæ•°ä¹‹ç§¯ã€‚å¯¹äºæ‰€æœ‰ <span class=\"math inline\">\\(n!\\)</span> ä¸ªæ’åˆ—ï¼Œè®¡ç®—æœ€å°ä»£ä»·ä¹‹å’Œã€‚</p>\n<p><span class=\"math inline\">\\(n\\le 10^7\\)</span>ã€‚</p>\n</blockquote>\n<p>è½¬åŒ–æˆï¼ŒæŠŠ <span class=\"math inline\">\\(1\\sim n\\)</span> åˆ†æˆæ— æ ‡å·çš„è‹¥å¹²ç»„ï¼Œæ¯ç»„çš„ä»£ä»·æ˜¯ æœ€å°å€¼ <span class=\"math inline\">\\(\\times\\)</span> å…¶ä»–å…ƒç´ çš„å’Œï¼Œè¿˜æœ‰ä¸€ä¸ªé¡¹é“¾é—®é¢˜çš„ç³»æ•°ï¼Œå‘ç°ç»„é—´çš„ç¬¦å·æ˜¯æ±‚å’Œï¼Œè€ƒè™‘è®¡ç®—è´¡çŒ®ã€‚</p>\n<p>æšä¸¾ <span class=\"math inline\">\\(i,j\\)</span> å¹¶é’¦å®šä¸¤ä¸ªåŒå±ä¸€ä¸ªç¯ï¼Œä¸” <span class=\"math inline\">\\(i\\)</span> ä¸ºæœ€å°å€¼ï¼Œæšä¸¾ç¯å¤§å° <span class=\"math inline\">\\(s+2\\)</span>ï¼Œé‚£ä¹ˆæœ‰ï¼š</p>\n<p><span class=\"math display\">\\[\n\\begin{aligned}\nres&amp;=\\sum_{i=1}^{n-1}\\sum_{j=i+1}^n i\\cdot j \\cdot \\sum_{s=0}^{n-i-1}\\binom{n-i-1}s \\cdot (s+1)!\\cdot (n-s-2)!\\\\\n&amp;=\\sum_{i=1}^{n-1}i\\cdot \\dfrac {(i+n+1)(n-i)}2 \\cdot \\sum_{s=0}^{n-i-1}\\binom{n-i-1}s\\cdot (s+1)!\\cdot (n-s-2)!\\\\\n&amp;=\\frac 12\\times\\sum_{i=1}^{n-1}i\\cdot (i+n+1)\\cdot (n-i)!\\cdot\\sum_{s=0}^{n-i-1}\\dfrac {(s + 1)\\cdot (n-s-2)!}{(n-i-1-s)!}\\\\\n\\end{aligned}\n\\]</span></p>\n<p>ä»¤ <span class=\"math inline\">\\(T=n-i-1\\)</span>ï¼Œå‘ç°æˆ‘ä»¬éœ€è¦å¿«é€Ÿè®¡ç®— <span class=\"math inline\">\\(f_T=\\sum\\limits_{i=0}^T \\dfrac{(i+1)\\cdot (n-i-2)!}{(T-i)!}\\)</span>ã€‚è®° <span class=\"math inline\">\\(m=n-2\\)</span>ï¼Œå˜å½¢å¾— <span class=\"math inline\">\\(f_T=(m-T)!\\cdot \\sum\\limits_{i=0}^{T} (i+1) \\binom{m-i}{m-T}\\)</span>ï¼Œå‘ç°ä¼¼ä¹å¯ä»¥ç®€åŒ–ï¼Œä»¤ <span class=\"math inline\">\\(k=m-T,t=T+1\\)</span>ï¼Œåˆ™ <span class=\"math inline\">\\(f_T=\\sum\\limits_{i=1}^T i\\cdot \\binom {k+t-i}k\\)</span>ã€‚</p>\n<p>ç„¶åæ˜¯ç»å…¸çš„ç»„åˆæ„ä¹‰ä¿å¹³å®‰ç¯èŠ‚ï¼Œå³ä» <span class=\"math inline\">\\(k+t\\)</span> ä¸ªæœ‰æ ‡å·å°çƒä¸­é€‰æ‹©ä¸€æ¡åˆ†ç•Œçº¿ï¼Œåˆ†ç•Œçº¿å·¦è¾¹é€‰ä¸€ä¸ªçƒã€å³è¾¹é€‰ <span class=\"math inline\">\\(k\\)</span> ä¸ªçƒçš„æ–¹æ¡ˆæ•°ã€‚å‘ç°åˆ†ç•Œçº¿çš„å­˜åœ¨å¾ˆè¯¡å¼‚ï¼Œæ•…ç”¨åˆ†ç•Œçº¿åæ–¹çš„ç¬¬ä¸€ä¸ªçƒä»£æ›¿ï¼Œåœ¨ <span class=\"math inline\">\\(t+1\\)</span> å¤„æ–°å»ºä¸€ä¸ªè™šçƒï¼Œè§„å®šåœ¨å‰ <span class=\"math inline\">\\(t+1\\)</span> ä¸ªçƒä¸­é€‰ä¸¤ä¸ªçƒï¼Œå¹¶ä»¤åä¸€ä¸ªä¸ºåˆ†ç•Œçº¿ï¼Œä¸”ä»¤å‰ <span class=\"math inline\">\\(t+1\\)</span> ä¸ªä¸­çš„å…¶ä»–çƒä¸ºå®çƒï¼Œå°±èƒ½å»ºç«‹åŒå°„ã€‚åœ¨åˆ†ç•Œçº¿åå†é€‰ <span class=\"math inline\">\\(k\\)</span> ä¸ªçƒï¼Œå®¹æ˜“å‘ç°ç›´æ¥åœ¨èŒƒå›´å†…é€‰ <span class=\"math inline\">\\(k+2\\)</span> ä¸ªçƒå°±èƒ½æ»¡è¶³æ¡ä»¶ï¼Œæ•… <span class=\"math inline\">\\(f_T=(n-T-2)!\\cdot \\binom{t+k+1}{k+2}\\)</span>ã€‚</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 1e9 + 7;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n    std::freopen(&quot;mozi.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;mozi.out&quot;, &quot;w&quot;, stdout);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;long long&gt; fac(n + 1), inv(n + 1), f(n + 1);\n    fac[0] = inv[0] = 1ll;\n    for (int i = 1; i &lt;= n; ++i)\n        fac[i] = fac[i - 1] * i % mod;\n    auto qkp = [&amp;](long long x, int y) &#123;\n        auto res(1ll);\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    inv[n] = qkp(fac[n], mod - 2);\n    for (int i = n - 1; i; --i)\n        inv[i] = inv[i + 1] * (i + 1) % mod;\n    auto C = [&amp;](int n, int m) &#123;\n        return fac[n] * inv[n - m] % mod * inv[m] % mod;\n    &#125;;\n    int m = n - 2;\n    for (int T = 0; T &lt;= n - 2; ++T) &#123;\n        int k = m - T, t = T + 1;\n        f[T] = C(t + k + 1, k + 2) * fac[m - T] % mod;\n    &#125;\n    auto res = 0ll;\n    for (int i = 1; i &lt;= n - 1; ++i)\n        (res += (long long)i * (i + n + 1) % mod * fac[n - i] % mod * f[n - i - 1] % mod) %= mod;\n    std::cout &lt;&lt; res * inv[2] % mod &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"c---destruction-of-walls\">C - Destruction of Walls</h2>\n<p><a href=\"https://atcoder.jp/contests/arc203/tasks/arc203_c\" class=\"uri\">https://atcoder.jp/contests/arc203/tasks/arc203_c</a></p>\n<hr />\n<h2 id=\"d---insert-xor\">D - Insert XOR</h2>\n<p><a href=\"https://atcoder.jp/contests/arc203/tasks/arc203_d\" class=\"uri\">https://atcoder.jp/contests/arc203/tasks/arc203_d</a></p>\n<hr />\n<h2 id=\"a---è®°å¿†\">A - è®°å¿†</h2>\n<p><a href=\"https://ac.nowcoder.com/acm/problem/274793\" class=\"uri\">https://ac.nowcoder.com/acm/problem/274793</a></p>\n<p>éœ€è¦æ„è¯†åˆ°é—®é¢˜æ˜¯é™æ€çš„ï¼Œå¹¶ä¸”ä¸èƒ½ç”¨çº¿æ®µæ ‘ä¹‹ç±»ç»´æŠ¤ï¼›æ•…è€ƒè™‘ç¦»çº¿ä¸‹æ¥ï¼Œæƒ³åŠæ³•åœ¨ LCA å¤„ç»Ÿè®¡ç­”æ¡ˆã€‚</p>\n<p>è¿™ä¸ªæ—¶å€™å‘ç°éœ€è¦åˆå¹¶å­æ ‘çŠ¶æ€ã€æ•´ä½“å¼‚æˆ–ã€æ•´ä½“ +1ï¼Œå¾ˆå®¹æ˜“æƒ³åˆ° Trieã€‚æŠŠ <span class=\"math inline\">\\(u\\to\\)</span> LCA çš„ç­”æ¡ˆä¿å­˜åœ¨ LCA å¤„ï¼Œç„¶åå†ç”¨ DFS + å›æº¯ç»Ÿè®¡ LCA <span class=\"math inline\">\\(\\to v\\)</span> çš„ç­”æ¡ˆã€‚æƒ³äº†åŠå¤©æ²¡æƒ³åˆ°æŠŠä¸Šä¸‹æ‹†å¼€æ¥åšä¹Ÿæ˜¯ç¥äº† ğŸ˜…</p>\n<p>å¯èƒ½æ¯”è¾ƒè€ƒéªŒå¯¹å­—å…¸æ ‘çš„ç†è§£ï¼Ÿåšä¸ªæ¯”å–»ï¼Œå­—å…¸æ ‘çš„ id å°±ç›¸å½“äºå¯¹è¿™ä¸ªç‚¹ä¸Šä¿¡æ¯çš„ã€å¼•ç”¨ã€ã€‚</p>\n<details>\n<p>å­—å…¸æ ‘åˆå¹¶çš„æ—¶å€™å¯ä»¥è€ƒè™‘å›æ”¶åºŸå¼ƒç‚¹ï¼Œä¸ç„¶å¯èƒ½æœ‰ç‚¹å¡ã€‚</p>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int X = 50;\nconst int maxn = 2e7 + 5;\nlong long d[maxn];\nint tot, T[maxn][2], f[maxn], fa[maxn];\n#define lc(p) T[p][0]\n#define rc(p) T[p][1]\nint find(int x) &#123; return x == f[x] ? x : f[x] = find(f[x]); &#125;\nint newnode(void) &#123;\n    int p = ++tot;\n    assert(p &lt; maxn);\n    d[p] = lc(p) = rc(p) = 0, f[p] = p;\n    return p;\n&#125;\nvoid pushdown(int p) &#123;\n    if (d[p]) &#123;\n        if (d[p] &amp; 1)\n            std::swap(lc(p), rc(p));\n        d[p] &gt;&gt;= 1;\n        if (lc(p))\n            d[lc(p)] ^= d[p];\n        if (rc(p))\n            d[rc(p)] ^= d[p];\n        d[p] = 0;\n    &#125;\n    return;\n&#125;\nint ins(int p, long long x) &#123;\n    for (int i = 0; i &lt; X; ++i) &#123;\n        pushdown(p);\n        if (!T[p][(x &gt;&gt; i) &amp; 1]) &#123;\n            T[p][(x &gt;&gt; i) &amp; 1] = newnode();\n            fa[T[p][(x &gt;&gt; i) &amp; 1]] = p;\n        &#125;\n        p = T[p][(x &gt;&gt; i) &amp; 1];\n    &#125;\n    return p;\n&#125;\nvoid merge(int &amp;p, int q) &#123;\n    if (!q)\n        return;\n    if (!p) &#123;\n        p = q;\n        return;\n    &#125;\n    pushdown(p), pushdown(q);\n    fa[lc(q)] = p, fa[rc(q)] = p;\n    merge(lc(p), lc(q)), merge(rc(p), rc(q));\n    assert(f[p] == p), assert(f[q] == q), f[q] = p;\n    return;\n&#125;\nlong long ask(int p) &#123;\n    std::vector&lt;int&gt; st;\n    for (int i = 0, j = p; i &lt; X; ++i)\n        st.push_back(fa[j]), j = fa[j];\n    for (int i = 0; i &lt; X; ++i)\n        pushdown(st.back()), st.pop_back();\n    long long x = 0;\n    for (int i = 0; i &lt; X; ++i) &#123;\n        x = x * 2 + (p == rc(fa[p]));\n        p = fa[p];\n    &#125;\n    return x;\n&#125;\nvoid add(int p) &#123;\n    for (int i = 0; p &amp;&amp; i &lt; X; ++i) &#123;\n        pushdown(p);\n        std::swap(lc(p), rc(p));\n        p = lc(p);\n    &#125;\n    return;\n&#125;\nvoid del(int p) &#123;\n    for (int i = 0; p &amp;&amp; i &lt; X; ++i) &#123;\n        pushdown(p);\n        std::swap(lc(p), rc(p));\n        p = rc(p);\n    &#125;\n    return;\n&#125;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, m;\n    std::cin &gt;&gt; n &gt;&gt; m;\n    std::vector&lt;int&gt; a(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i];\n    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);\n    for (int i = 1, x, y; i &lt; n; ++i) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y;\n        g[x].push_back(y), g[y].push_back(x);\n    &#125;\n    std::vector&lt;int&gt; siz(n + 1), son(n + 1), top(n + 1), fa(n + 1), dep(n + 1);\n    std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;\n        siz[x] = 1;\n        for (auto i : g[x])\n            if (i != fa[x]) &#123;\n                dep[i] = dep[x] + 1;\n                fa[i] = x, DFS(i);\n                siz[x] += siz[i];\n                if (siz[i] &gt; siz[son[x]])\n                    son[x] = i;\n            &#125;\n        return;\n    &#125;;\n    DFS(1);\n    DFS = [&amp;](int x) &#123;\n        if (son[x])\n            top[son[x]] = top[x], DFS(son[x]);\n        for (auto i : g[x])\n            if (i != son[x] &amp;&amp; i != fa[x])\n                top[i] = i, DFS(i);\n        return;\n    &#125;;\n    top[1] = 1, DFS(1);\n    auto askLCA = [&amp;](int x, int y) &#123;\n        for (; top[x] != top[y]; x = fa[top[x]])\n            if (dep[top[x]] &lt; dep[top[y]])\n                std::swap(x, y);\n        return dep[x] &lt; dep[y] ? x : y;\n    &#125;;\n    struct node &#123; long long x; int u, v; &#125;;\n    std::vector&lt;node&gt; q(m + 1);\n    std::vector&lt;int&gt; id(m + 1);\n    std::vector&lt;long long&gt; res(m + 1), ans(m + 1);\n    std::vector&lt;std::vector&lt;int&gt; &gt; up(n + 1), dn(n + 1), ed(n + 1);\n    for (int i = 1, x, u, v; i &lt;= m; ++i) &#123;\n        std::cin &gt;&gt; x &gt;&gt; u &gt;&gt; v;\n        q[i] = &#123; x, u, v &#125;;\n        up[u].push_back(i), dn[askLCA(u, v)].push_back(i), ed[v].push_back(i);\n    &#125;\n    std::vector&lt;int&gt; rt(n + 1);\n    DFS = [&amp;](int x) &#123;\n        rt[x] = newnode();\n        for (auto i : g[x])\n            if (i != fa[x]) &#123;\n                DFS(i);\n                merge(rt[x], rt[i]);\n            &#125;\n        add(rt[x]);\n        for (auto i : up[x])\n            id[i] = ins(rt[x], q[i].x);\n        d[rt[x]] ^= a[x];\n        for (auto i : dn[x])\n            res[i] = ask(find(id[i]));\n        return;\n    &#125;;\n    DFS(1);\n    tot = 0, rt[0] = newnode();\n    std::fill(id.begin() + 1, id.end(), 0);\n    DFS = [&amp;](int x) &#123;\n        d[rt[0]] ^= a[x];\n        for (auto i : dn[x])\n            id[i] = ins(rt[0], res[i]);\n        for (auto i : ed[x])\n            ans[i] = ask(id[i]);\n        add(rt[0]);\n        for (auto i : g[x])\n            if (i != fa[x])\n                DFS(i);\n        del(rt[0]);\n        d[rt[0]] ^= a[x];\n        return;\n    &#125;;\n    DFS(1);\n    for (int i = 1; i &lt;= m; ++i)\n        std::cout &lt;&lt; ans[i] &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"b---ãƒ“ãƒ¼ãƒãƒ¼ã®ä¼šåˆ-2-meetings-2\">B - ãƒ“ãƒ¼ãƒãƒ¼ã®ä¼šåˆ 2 (Meetings 2)</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/AT_joisc2021_j\" class=\"uri\">https://www.luogu.com.cn/problem/AT_joisc2021_j</a></p>\n<p>å®šä¹‰æ‰€æ±‚ç‚¹ä¸ºã€å±€éƒ¨é‡å¿ƒã€ï¼›ç±»ä¼¼æ ‘çš„é‡å¿ƒï¼Œå®¹æ˜“å‘ç°å½“å…³é”®ç‚¹æ•°é‡ä¸ºå¥‡æ—¶ï¼Œåªå­˜åœ¨ä¸€ä¸ªå±€éƒ¨é‡å¿ƒï¼›å¦åˆ™ï¼Œå±€éƒ¨é‡å¿ƒç»„æˆä¸€æ¡é“¾ã€‚</p>\n<p>å³å¯¹äºæ¯ä¸€ä¸ª <span class=\"math inline\">\\(i\\)</span>ï¼Œéœ€è¦æ‰¾åˆ°ä¸€æ¡æœ€é•¿é“¾ï¼Œä½¿å¾—å…¶ä¸¤ç«¯å­˜åœ¨å¤§å°ä¸º <span class=\"math inline\">\\(i\\)</span> çš„å­æ ‘ï¼ˆå®¹æ˜“å‘ç°å–åç¼€ max å³å¯å¾—åˆ°çœŸå®ç­”æ¡ˆï¼‰ã€‚ä½¿ç”¨ç‚¹åˆ†æ²»ï¼Œç²¾ç»†å®ç°å®¹æ˜“åšåˆ° <span class=\"math inline\">\\(O(n\\log n)\\)</span>ã€‚</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);\n    for (int i = 1, x, y; i &lt; n; ++i) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y;\n        g[x].push_back(y), g[y].push_back(x);\n    &#125;\n    std::vector&lt;int&gt; mx(n + 1), siz(n + 1), p, tag(n + 1), res(n + 1, 1);\n    std::function&lt;void(int, int)&gt; DFS1 = [&amp;](int x, int fa) &#123;\n        p.push_back(x);\n        siz[x] = 1, mx[x] = 0;\n        for (auto i : g[x])\n            if (!tag[i] &amp;&amp; i != fa) &#123;\n                DFS1(i, x);\n                siz[x] += siz[i];\n                mx[x] = std::max(mx[x], siz[i]);\n            &#125;\n        return;\n    &#125;;\n    auto findrt = [&amp;](int x) &#123;\n        p.clear(), DFS1(x, -1);\n        int n = (int)p.size();\n        for (auto i : p)\n            if (mx[i] &lt;= n / 2 &amp;&amp; n - siz[i] &lt;= n / 2)\n                return i;\n        assert(0);\n        return -1;\n    &#125;;\n    struct node &#123;\n        int u1, u2, id1, id2;\n        node(): u1(0), u2(0), id1(0), id2(0) &#123;&#125;\n        void upd(int u, int id) &#123;\n            if (id1 == id)\n                u1 = std::max(u1, u);\n            else if (u &gt;= u1)\n                u2 = u1, id2 = id1, u1 = u, id1 = id;\n            else if (u &gt;= u2)\n                u2 = u, id2 = id;\n            return;\n        &#125;\n    &#125;;\n    std::vector&lt;node&gt; s(n + 1);\n    std::function&lt;void(int, int, int, int)&gt; DFS2 = [&amp;](int x, int fa, int dep, int anc) &#123;\n        s[siz[x]].upd(dep, anc);\n        for (auto i : g[x])\n            if (!tag[i] &amp;&amp; i != fa)\n                DFS2(i, x, dep + 1, anc);\n        return;\n    &#125;;\n    std::function&lt;void(int, int, int, int)&gt; DFS3 = [&amp;](int x, int fa, int dep, int anc) &#123;\n        int v = ((s[siz[x]].id1 == anc) ? s[siz[x]].u2 : s[siz[x]].u1);\n        res[2 * siz[x]] = std::max(res[2 * siz[x]], dep + 1 + v);\n        for (auto i : g[x])\n            if (!tag[i] &amp;&amp; i != fa)\n                DFS3(i, x, dep + 1, anc);\n        return;\n    &#125;;\n    std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;\n        x = findrt(x), p.clear(), DFS1(x, -1);\n        // printf(&quot;rt = %d\\n&quot;, x);\n        for (auto i : g[x])\n            if (!tag[i])\n                DFS2(i, x, 1, i);\n        for (int i = siz[x] - 1; i; --i) &#123;\n            s[i].upd(s[i + 1].u1, s[i + 1].id1);\n            s[i].upd(s[i + 1].u2, s[i + 1].id2);\n        &#125;\n        for (auto i : g[x])\n            if (!tag[i])\n                DFS3(i, x, 1, i);\n        tag[x] = 1;\n        for (int i = 1; i &lt; siz[x]; ++i)\n            s[i] = node();\n        for (auto i : g[x])\n            if (!tag[i])\n                DFS(i);\n        return;\n    &#125;;\n    DFS(1);\n    for (int i = (n &gt;&gt; 1) * 2; i; --i)\n        if (i + 2 &lt;= n)\n            res[i] = std::max(res[i], res[i + 2]);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cout &lt;&lt; res[i] &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"c---the-closest-pair\">C - The Closest Pair</h2>\n<p><a href=\"https://ac.nowcoder.com/acm/problem/262593\" class=\"uri\">https://ac.nowcoder.com/acm/problem/262593</a></p>\n<p><strong>å¸¸è§„æ–¹æ³•</strong>ï¼šè€ƒè™‘<strong>æ”¯é…å¯¹</strong>ï¼Œå¯¹äºæ¯ä¸ª <span class=\"math inline\">\\(a_i\\)</span>ï¼Œæ‰¾åˆ°æ‰€æœ‰åˆæ³•çš„ <span class=\"math inline\">\\(a_j\\)</span>ã€‚å®¹æ˜“æƒ³åˆ°æšä¸¾ <span class=\"math inline\">\\(a_i\\div a_j\\)</span> æ¥åšï¼›å‡è®¾å­˜åœ¨ <span class=\"math inline\">\\(a_k\\div a_i=a_j\\div a_i\\)</span> ä¸” <span class=\"math inline\">\\(k&gt;j\\)</span>ã€‚</p>\n<p>ä¸å¦¨è®¾ <span class=\"math inline\">\\(a_j=K\\cdot a_i+p,a_k=K\\cdot a_i+q\\)</span>ï¼Œ<span class=\"math inline\">\\((a_i,a_j),(a_i,a_k)\\)</span> å‡åˆæ³•å½“ä¸”ä»…å½“ä¸‹åˆ—æ¡ä»¶å…¨éƒ¨æˆç«‹ï¼š</p>\n<ul>\n<li><span class=\"math inline\">\\(a_j\\bmod a_i&gt;a_k\\bmod a_i\\)</span>ï¼› åˆ™ <span class=\"math inline\">\\(a_j&gt;a_k\\)</span>ã€‚</li>\n<li><span class=\"math inline\">\\(a_j\\bmod a_k&gt;a_k\\bmod a_i\\)</span>ï¼›åˆ <span class=\"math inline\">\\(p-q\\ge a_j\\bmod a_k\\)</span>ï¼ˆ<strong>å¤ªç‰›äº†è¿™ä¸€æ­¥</strong>ï¼‰ï¼Œå³ <span class=\"math inline\">\\(p-q&gt;q\\iff p&gt;2q\\)</span>ã€‚</li>\n</ul>\n<p>è¯å¾—åªå…³å¿ƒåŒä¸€ä¸ª <span class=\"math inline\">\\(a_j\\div a_i\\)</span> æ—¶çš„æ”¯é…å¯¹æ•°é‡ä¸º <span class=\"math inline\">\\(\\log n\\)</span> çº§åˆ«ï¼›æ€»å¯¹æ•° <span class=\"math inline\">\\(O(n\\log n\\ln n)\\)</span>ã€‚ç¦»çº¿ä¸‹æ¥æ‰«æçº¿å°±è¡Œäº†ã€‚</p>\n<details>\n<p>å¯¹ç€ å•ç‚¹ä¿®æ”¹ åŒºé—´æœ€å€¼ æƒ³äº† 1h çš„å• log åšæ³• ğŸ˜° æœç„¶å°è„‘æ‰çº¿å¤ªå¯æ€•äº†ï¼Œç¬¬äºŒå¤©æ—©ä¸Šé‡ç½®å¤§è„‘ 1s å‘ç°è‡ªå·±æ˜¯æ–¯æ³¢ ğŸ˜“</p>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int LEN = (1 &lt;&lt; 20);\nint nec(void) &#123;\n    static char buf[LEN], *p = buf, *e = buf;\n    if (p == e) &#123;\n        e = buf + fread(buf, 1, LEN, stdin);\n        if (e == buf) return EOF;\n        p = buf;\n    &#125;\n    return *p++;\n&#125;\nbool read(int &amp;x) &#123;\n    x = 0;\n    bool f = 0;\n    char ch = nec();\n    while (ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123;\n        if (ch == EOF) return 0;\n        if (ch == &#39;-&#39;) f = 1;\n        ch = nec();\n    &#125;\n    while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) &#123;\n        x = x * 10 + ch - &#39;0&#39;;\n        ch = nec();\n    &#125;\n    if (f) x = -x;\n    return 1;\n&#125;\nvoid print(int x) &#123;\n    if (x &lt; 0)\n        putchar(&#39;-&#39;), x = -x;\n    if (x &gt;= 10) print(x / 10);\n    putchar(x % 10 + &#39;0&#39;);\n    return;\n&#125;\nvoid print(int x, char ch) &#123;\n    print(x), putchar(ch);\n    return;\n&#125;\nconst int maxn = 4e6 + 5;\nstruct &#123; int l, r, u[2]; &#125; t[maxn];\n#define lt (t[p].l)\n#define rt (t[p].r)\nint tot[2];\nvoid add(int &amp;p, int l, int r, int x, int v, int i) &#123;\n    if (!p)\n        p = ++tot[i], t[p].u[0] = -1, t[p].u[1] = 0x3f3f3f3f;\n    if (i == 0)\n        t[p].u[0] = std::max(t[p].u[0], v);\n    else\n        t[p].u[1] = std::min(t[p].u[1], v);\n    if (l == r)\n        return;\n    int mid = (l + r) &gt;&gt; 1;\n    if (x &lt;= mid)\n        add(lt, l, mid, x, v, i);\n    else\n        add(rt, mid + 1, r, x, v, i);\n    return;\n&#125;\nint ask(int p, int l, int r, int ql, int qr, int i) &#123;\n    if (!p || (ql &lt;= l &amp;&amp; r &lt;= qr))\n        return t[p].u[i];\n    int mid = (l + r) &gt;&gt; 1;\n    if (qr &lt;= mid)\n        return ask(lt, l, mid, ql, qr, i);\n    if (ql &gt; mid)\n        return ask(rt, mid + 1, r, ql, qr, i);\n    if (i == 0)\n        return std::max(ask(lt, l, mid, ql, qr, 0), ask(rt, mid + 1, r, ql, qr, 0));\n    return std::min(ask(lt, l, mid, ql, qr, 1), ask(rt, mid + 1, r, ql, qr, 1));\n&#125;\n#undef lt\n#undef rt\nint main() &#123;\n#ifndef ONLINE_JUDGE\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    const int m = 1e6;\n    int rt[2] = &#123; 0 &#125;, n;\n    t[0].u[0] = -1, t[0].u[1] = 0x3f3f3f3f;\n    read(n);\n    std::vector&lt;int&gt; a(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        read(a[i]);\n    std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; t(n + 1);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        if (i != 1) &#123;\n            for (int K = a[i]; K &lt;= m; K += a[i]) &#123;\n                for (int mx = std::min(a[i] - 1, m - K); ; ) &#123;\n                    int k = ask(rt[0], 1, m, K, K + mx, 0);\n                    if (k == -1)\n                        break;\n                    t[i].emplace_back(k, a[k] - K);\n                    if (k == 1 || !(a[k] - K))\n                        break;\n                    mx = (a[k] - K - 1) / 2;\n                &#125;\n            &#125;\n        &#125;\n        add(rt[0], 1, m, a[i], i, 0);\n    &#125;\n    for (int i = n; i; --i) &#123;\n        if (i != n)\n            for (int K = a[i]; K &lt;= m; K += a[i])\n                for (int mx = std::min(a[i] - 1, m - K); ; ) &#123;\n                    int k = ask(rt[1], 1, m, K, K + mx, 1);\n                    if (k == 0x3f3f3f3f)\n                        break;\n                    t[k].emplace_back(i, a[k] - K);\n                    if (k == n || !(a[k] - K))\n                        break;\n                    mx = (a[k] - K - 1) / 2;\n                &#125;\n        add(rt[1], 1, m, a[i], i, 1);\n    &#125;\n    int q;\n    read(q);\n    std::vector&lt;int&gt; res(q + 1);\n    std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; u(n + 1);\n    for (int i = 1, l, r; i &lt;= q; ++i) &#123;\n        read(l), read(r);\n        if (l &gt; r)\n            std::swap(l, r);\n        u[r].emplace_back(l, i);\n    &#125;\n    std::vector&lt;int&gt; bit(n + 1, 0x3f3f3f3f);\n    auto lowbit = [&amp;](int x) &#123; return x &amp; -x; &#125;;\n    auto add = [&amp;](int x, int v) &#123;\n        for (; x &lt;= n; x += lowbit(x))\n            bit[x] = std::min(bit[x], v);\n        return;\n    &#125;;\n    auto ask = [&amp;](int x) &#123;\n        auto res = 0x3f3f3f3f;\n        for (; x; x -= lowbit(x))\n            res = std::min(res, bit[x]);\n        return res;\n    &#125;;\n    for (int r = 1; r &lt;= n; ++r) &#123;\n        for (auto [l, v] : t[r])\n            add(n - l + 1, v);\n        for (auto [l, i] : u[r])\n            res[i] = ask(n - l + 1);\n    &#125;\n    for (int i = 1; i &lt;= q; ++i)\n        print(res[i], &#39;\\n&#39;);\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<p>æ±‚æ”¯é…å¯¹çš„è¿‡ç¨‹ä¹Ÿè¦å¸¦ logï¼ˆçº¿æ®µæ ‘ï¼‰ï¼Œå†åŠ ä¸Šæ‰«æçº¿çš„ 3logï¼Œæ€»å…±æ˜¯å¸¸æ•°æ¯”è¾ƒå¤§çš„ 3logï¼ˆå¡äº†ä¸€ä¸ªä¸Šåˆçš„å¸¸ä¹Ÿæ˜¯æœ‰äº†ï¼‰ã€‚æ‰€ä»¥æ¥ä¸‹æ¥è®²è§£å¦ä¸€ç§å¥‡æŠ€æ·«å·§ã€‚</p>\n<p><strong>æš´åŠ›åˆ†æ²»</strong>ï¼šæ³¨æ„åˆ°å¯¹äºæ¯”è¾ƒé•¿ï¼ˆ<span class=\"math inline\">\\(len&gt; B\\)</span>ï¼‰çš„åŒºé—´ï¼Œç­”æ¡ˆæ¯”è¾ƒå°ï¼›æ•…è€ƒè™‘åˆ†æ²»ã€‚</p>\n<ul>\n<li>å¯¹äºé•¿è¯¢é—®ï¼ˆ<span class=\"math inline\">\\(len&gt;B\\)</span>ï¼‰ï¼Œä»å°åˆ°å¤§æšä¸¾ç­”æ¡ˆå¹¶ checkï¼›é¢„å¤„ç†æŸä¸ªèŒƒå›´ï¼ˆ<span class=\"math inline\">\\(V\\)</span>ï¼‰å†…çš„ <span class=\"math inline\">\\(res\\)</span> å‡ºç°çš„æ‰€æœ‰ä½ç½®ï¼Œå¹³è¡¡çš„æ—¶å€™è¿˜è¦ç®—ä¸Šè°ƒå’Œçº§æ•°å’Œ bitã€‚</li>\n<li>å¯¹äºçŸ­è¯¢é—®ï¼ˆ<span class=\"math inline\">\\(len\\le B\\)</span>ï¼‰ï¼Œå‘ç°æ¯æ¬¡åŒºé—´å†…æš´åŠ›æ˜¯ <span class=\"math inline\">\\(O(B^2q)\\)</span> çš„ï¼›æŠŠè¯¢é—®ç¦»çº¿ä¸‹æ¥ï¼Œç²¾ç»†å®ç°ï¼Œåˆ©ç”¨è¯¢é—®çš„å…¬å…±éƒ¨åˆ†ä½¿å¾—<strong>æ¯ä¸€å¯¹æ•°åªè¢«æšä¸¾ä¸€æ¬¡</strong>å°±èƒ½è¾¾åˆ° <span class=\"math inline\">\\(O(B^2 + Bq)\\)</span>ã€‚</li>\n</ul>\n<p>æœ€ä¼˜è§£å– <span class=\"math inline\">\\(B=333,V=483\\)</span>ï¼Œä¸è‡ªå·±å®ç°ä¸€éäº†ã€‚</p>\n<hr />\n<h2 id=\"d---ä»™äººæŒ\">D - ä»™äººæŒ</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P3687\" class=\"uri\">https://www.luogu.com.cn/problem/P3687</a></p>\n<p>æŠŠè¾¹åŒä»å›¾ä¸­åˆ é™¤ã€é—®é¢˜è½¬åŒ–ä¸ºæ ‘ä¸Š<strong>è¾¹</strong>ä¸äº¤çš„é“¾è¦†ç›–ï¼Œä½¿å¾—<strong>æ‰€æœ‰é“¾é•¿ <span class=\"math inline\">\\(\\ge 2\\)</span></strong> çš„æ–¹æ¡ˆæ•°ã€‚å‘ç°ç”±äº<strong>è¾¹å¯ä»¥ä¸è¢«è¦†ç›–</strong>ï¼Œå¸¸è§„ DP ä¼šä½¿å¾—åœ¨çˆ¶èŠ‚ç‚¹å¤„åˆå¹¶æ—¶éœ€è¦é¢å¤–çš„æ•°é‡ç»´ï¼Œå‚è€ƒæ ‘ä¸ŠèƒŒåŒ…ï¼Œå¤æ‚åº¦ <span class=\"math inline\">\\(O(n^2)\\)</span>ã€‚</p>\n<p>æ€è€ƒæ—¶ä¼šæ³¨æ„åˆ°ä¸¤ä¸ªé™åˆ¶å¯ä»¥æŠµæ¶ˆâ€”â€”å¦‚æœè®¤ä¸ºé•¿ä¸º <span class=\"math inline\">\\(1\\)</span> çš„é“¾å°±æ˜¯ä¸è¢«è¦†ç›–çš„è¾¹ï¼Œè¦†ç›–æ‰€æœ‰æ ‘è¾¹ï¼Œæ˜¾ç„¶å¯ä»¥å»ºç«‹å’Œåˆæ³•è§£çš„åŒå°„ã€‚æ­¤æ—¶åˆå¹¶æ˜¯éå¸¸æ–¹ä¾¿çš„ï¼Œæ³¨æ„åˆ°æ¯ä¸ªå„¿å­çš„ç³»æ•°ä¸€å®šéƒ½å‚ä¸ã€åˆ†æ­¥ã€ï¼Œåªéœ€è¦æ±‚å‡ºã€åˆ†ç±»ã€çš„ç³»æ•°ã€‚è¿™ä¸ªå¯ä»¥é¢„å¤„ç†ï¼ˆå’Œ <a href=\"/20250407/#a.-äºŒåˆ†å›¾æŸ“è‰²\">äºŒåˆ†å›¾æŸ“è‰²</a> è¿™ä¸ªé¢˜æœ‰ç‚¹åƒï¼‰ï¼Œä»¤ <span class=\"math inline\">\\(f_i\\)</span> è¡¨ç¤ºä¸€ä¸ªç‚¹åº¦æ•°ä¸º <span class=\"math inline\">\\(i\\)</span> æ—¶çš„ç­”æ¡ˆï¼Œå‚è€ƒé”™æ’çš„æ€è·¯ï¼Œåˆ™ <span class=\"math inline\">\\(i\\)</span> å¯ä»¥ä¸å‚ä¸é…å¯¹ï¼Œä¹Ÿå¯ä»¥ä¹±é€‰ä¸€ä¸ªç‚¹é…å¯¹ï¼Œå¦‚æœé€‰ä¸­äº†å·²é…å¯¹çš„ç‚¹å°±ä»¤å…¶å’Œ <span class=\"math inline\">\\(i-1\\)</span> äº¤æ¢ï¼Œå¯ä»¥å»ºç«‹å’Œåˆæ³•è§£çš„åŒå°„ã€‚åˆ™ <span class=\"math inline\">\\(f_i=f_{i-1}+(n-1)f_{i-2}\\)</span>ã€‚</p>\n<p>é¦–å…ˆéœ€è¦ check åŸå›¾æ˜¯å¦ä¸ºä»™äººæŒï¼Œé¡ºå¸¦å›å¿†ä¸€ä¸‹è¿é€šæ€§çš„çŸ¥è¯†â€”â€”åœ¨ DFS æ ‘ä¸Šå·®åˆ†ï¼Œæ£€æŸ¥æ˜¯å¦æœ‰è¾¹è¢«è¦†ç›–ä¸¤æ¬¡å³å¯ã€‚</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 998244353;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int T;\n    for (std::cin &gt;&gt; T; T--; ) &#123;\n        int n, m;\n        std::cin &gt;&gt; n &gt;&gt; m;\n        std::vector&lt;std::vector&lt;int&gt; &gt; g1(n + 1);\n        for (int x, y; m--; ) &#123;\n            std::cin &gt;&gt; x &gt;&gt; y;\n            g1[x].push_back(y), g1[y].push_back(x);\n        &#125;\n        bool flag = 1;\n        int now = 0, cnt = 0;\n        std::vector&lt;int&gt; st, dfn(n + 1), low(n + 1), col(n + 1), diff(n + 1);\n        std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int fa) &#123;\n            st.push_back(x);\n            dfn[x] = low[x] = ++now;\n            for (auto i : g1[x])\n                if (!dfn[i]) &#123;\n                    // printf(&quot;x = %d, %d -&gt; %d\\n&quot;, x, x, i);\n                    DFS(i, x);\n                    diff[x] += diff[i];\n                    // printf(&quot;x = %d, diff[%d] += diff[%d]\\n&quot;, x, x, i);\n                    low[x] = std::min(low[x], low[i]);\n                &#125;\n                else if (i != fa &amp;&amp; dfn[i] &lt; dfn[x]) &#123;\n                    low[x] = std::min(low[x], dfn[i]);\n                    ++diff[x], --diff[i];\n                    // printf(&quot;x = %d, ++diff[%d], --diff[%d]\\n&quot;, x, x, i);\n                &#125;\n            if (diff[x] &gt;= 2)\n                flag = 0;\n            // printf(&quot;x = %d, diff[%d] = %d\\n&quot;, x, x, diff[x]);\n            if (low[x] == dfn[x]) &#123;\n                ++cnt;\n                for (int p = -1; p != x; ) &#123;\n                    p = st.back(), st.pop_back();\n                    col[p] = cnt;\n                &#125;\n            &#125;\n            return;\n        &#125;;\n        DFS(1, -1);\n        if (!flag) &#123;\n            std::cout &lt;&lt; 0 &lt;&lt; &#39;\\n&#39;;\n            continue;\n        &#125;\n        std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);\n        for (int i = 1; i &lt;= n; ++i)\n            for (auto j : g1[i])\n                if (col[i] != col[j])\n                    g[i].push_back(j);\n        std::vector&lt;long long&gt; f(n + 1), dp(n + 1);\n        dp[0] = 1ll, dp[1] = 1ll;\n        for (int i = 2; i &lt;= n; ++i)\n            dp[i] = (dp[i - 1] + (i - 1) * dp[i - 2]) % mod;\n        std::vector&lt;int&gt; tag(n + 1);\n        DFS = [&amp;](int x, int fa) &#123;\n            f[x] = 1ll, tag[x] = 1;\n            for (auto i : g[x])\n                if (i != fa) &#123;\n                    DFS(i, x);\n                    (f[x] *= f[i]) %= mod;\n                &#125;\n            (f[x] *= dp[(int)g[x].size()]) %= mod;\n            return;\n        &#125;;\n        auto res(1ll);\n        for (int i = 1; i &lt;= n; ++i)\n            if (!tag[i])\n                DFS(i, -1), (res *= f[i]) %= mod;\n        std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<p>E. Many Minimizations æ˜¯æ•°å­¦é¢˜ï¼Œè·³äº†ã€‚</p>\n<hr />\n<hr />\n<h2 id=\"æ— åé¢˜\">æ— åé¢˜</h2>\n<blockquote>\n<p>èƒŒæ™¯ï¼šç»™å®š <span class=\"math inline\">\\(n,k\\)</span>ï¼Œå¯¹äº <span class=\"math inline\">\\(\\forall\\, 1\\le i\\le n\\)</span>ï¼Œä»¤ <span class=\"math inline\">\\(a_i=i\\bmod k\\)</span>ï¼Œé—®ä¸€å…±æœ‰å¤šå°‘ä¸ªæœ¬è´¨ä¸åŒçš„å­åºåˆ—ï¼Ÿå¯¹äº <span class=\"math inline\">\\(k=1,2,\\cdots,n\\)</span> åˆ†åˆ«æ±‚å‡ºç­”æ¡ˆã€‚</p>\n</blockquote>\n<hr />\n<h2 id=\"maimai\">maimai</h2>\n<p><a href=\"https://ac.nowcoder.com/acm/contest/66112/F\" class=\"uri\">https://ac.nowcoder.com/acm/contest/66112/F</a></p>\n",
            "tags": [
                "å­—å…¸æ ‘",
                "å­—ç¬¦ä¸²",
                "ç»„åˆæ•°å­¦",
                "æ”¯é…å¯¹"
            ]
        }
    ]
}