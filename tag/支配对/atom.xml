<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://xsc062.netlify.app</id>
    <title> â€¢ Posts by &#34;æ”¯é…å¯¹&#34; tag</title>
    <link href="https://xsc062.netlify.app" />
    <updated>2025-08-09T04:33:17.000Z</updated>
    <category term="å¹¶æŸ¥é›†" />
    <category term="æ–œç‡ä¼˜åŒ–" />
    <category term="æ‚¬çº¿æ³•" />
    <category term="å“ˆå¸Œ" />
    <category term="å­—å…¸æ ‘" />
    <category term="DP" />
    <category term="å•è°ƒé˜Ÿåˆ—" />
    <category term="åˆ†æ²»" />
    <category term="è®¡æ•°" />
    <category term="å®¹æ–¥" />
    <category term="äºŒåˆ†å›¾" />
    <category term="CRT / exCRT" />
    <category term="æ’åˆ—ç»„åˆ" />
    <category term="ç½‘ç»œæµ" />
    <category term="äºŒåˆ†" />
    <category term="å®¹æ–¥åŸç†" />
    <category term="çº¿æ®µæ ‘" />
    <category term="æ ‘çŠ¶æ•°ç»„" />
    <category term="åŒºé—´ DP" />
    <category term="æ„é€ " />
    <category term="æ•°æ®ç»“æ„" />
    <category term="Tarjan" />
    <category term="ä¸‹é¥­" />
    <category term="æè¶…çº¿æ®µæ ‘" />
    <category term="æ ‘é“¾å‰–åˆ†" />
    <category term="LCA" />
    <category term="å€å¢" />
    <category term="é¸½å·¢åŸç†" />
    <category term="æ•°å­¦" />
    <category term="è°ƒå’Œçº§æ•°" />
    <category term="å·®åˆ†" />
    <category term="æ€ç»´" />
    <category term="æ ‘å½¢ DP" />
    <category term="æœ€å°ç”Ÿæˆæ ‘" />
    <category term="çŠ¶å‹" />
    <category term="é«˜ç»´å‰ç¼€å’Œ" />
    <category term="SAM" />
    <category term="åˆ†å—" />
    <category term="å¯æŒä¹…åŒ–" />
    <category term="ç¬›å¡å°”æ ‘" />
    <category term="é—²è¯" />
    <category term="æ¬§æ‹‰å›è·¯" />
    <category term="é•¿é“¾å‰–åˆ†" />
    <category term="KMP" />
    <category term="border" />
    <category term="éšæœºåŒ–" />
    <category term="å­—ç¬¦ä¸²" />
    <category term="AC è‡ªåŠ¨æœº" />
    <category term="SA" />
    <category term="æ ‘ä¸Šå·®åˆ†" />
    <category term="FWT" />
    <category term="å †" />
    <category term="æ ‘çš„é‡å¿ƒ" />
    <category term="è´ªå¿ƒ" />
    <category term="å‡æ‘Š" />
    <category term="ä¼˜åŒ–å»ºå›¾" />
    <category term="åæ‚”è´ªå¿ƒ" />
    <category term="è°ƒæ•´æ³•" />
    <category term="èƒŒåŒ…" />
    <category term="åšå¼ˆè®º" />
    <category term="DP ä¼˜åŒ–" />
    <category term="è™šæ ‘" />
    <category term="ç‚¹åˆ†æ²»" />
    <category term="å››è¾¹å½¢ä¸ç­‰å¼" />
    <category term="æ”¯é…å¯¹" />
    <category term="DDP" />
    <category term="CDQ åˆ†æ²»" />
    <category term="çŒ«æ ‘" />
    <category term="DP å¥— DP" />
    <category term="Kruskal é‡æ„æ ‘" />
    <category term="é«˜ç²¾åº¦" />
    <category term="æœ€çŸ­è·¯" />
    <category term="æ ‘å¥—æ ‘" />
    <category term="äºŒé¡¹å¼åæ¼”" />
    <category term="æœç´¢" />
    <entry>
        <id>https://xsc062.netlify.app/20250809/</id>
        <title>è¿‘æœŸæ‚é¢˜</title>
        <link rel="alternate" href="https://xsc062.netlify.app/20250809/"/>
        <content type="html">&lt;p&gt;è¿™æ®µæ—¶é—´æ¯”èµ›çš„ä¸€äº›é¢˜ å’Œ nKessiã€duanyu è®²çš„é¢˜ç›®ã€‚å¤ªåè®¡æ•°ã€æ•°å­¦çš„åŸºæœ¬ä¸Šæ²¡åŠæ³•åšäº†ã€‚&lt;/p&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;a.-å‡ºå…³&#34;&gt;A. å‡ºå…³&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.becoder.com.cn/contest/6462/problem/1&#34; class=&#34;uri&#34;&gt;https://www.becoder.com.cn/contest/6462/problem/1&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;ç»™å®š &lt;span class=&#34;math inline&#34;&gt;\(s\)&lt;/span&gt;ï¼Œå¯¹äºä¸€ä¸ªç©ºä¸²ï¼Œä»»æ„åˆ©ç”¨ä¸‹åˆ—ä¸‰ç§æ“ä½œï¼Œä½¿å…¶å˜ä¸º &lt;span class=&#34;math inline&#34;&gt;\(s\)&lt;/span&gt;ï¼Œæ±‚æœ€å°ä»£ä»·ï¼š&lt;/p&gt;
&lt;ol type=&#34;1&#34;&gt;
&lt;li&gt;åœ¨æœ«å°¾æ·»åŠ å­—ç¬¦ &lt;span class=&#34;math inline&#34;&gt;\(c\)&lt;/span&gt;ï¼Œä»£ä»·ä¸º &lt;span class=&#34;math inline&#34;&gt;\(t_{0,c}\)&lt;/span&gt;ï¼›&lt;/li&gt;
&lt;li&gt;å¤åˆ¶æ•´ä¸ªå­—ç¬¦ä¸²å¹¶ç²˜è´´åœ¨æœ«å°¾ï¼Œä»£ä»·ä¸º &lt;span class=&#34;math inline&#34;&gt;\(t_1\)&lt;/span&gt;ï¼›&lt;/li&gt;
&lt;li&gt;åˆ é™¤æœ«å°¾å­—ç¬¦ï¼Œä»£ä»·ä¸º &lt;span class=&#34;math inline&#34;&gt;\(t_2\)&lt;/span&gt;ã€‚&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(|s|\le 10^6\)&lt;/span&gt;ã€‚&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;å¯ä»¥é¢„å¤„ç†å‡ºå¯¹äºæ¯ä¸ª &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; ç»“å°¾ï¼Œæœ€å¤šå¯ä»¥å¤åˆ¶åˆ°å“ªä¸ªåœ°æ–¹ï¼Œå‘ç°è¦æ±‚ &lt;span class=&#34;math inline&#34;&gt;\(z_i=lcp(s_{1\dots n},s_{i+1\dots n})\)&lt;/span&gt;ã€‚é‚£ä¹ˆä¸€ä¸ª &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; çš„æœ€è¿œè½¬ç§»ç‚¹ &lt;span class=&#34;math inline&#34;&gt;\(r_i=i+z_{i+1}\)&lt;/span&gt;ï¼Œç”¨å•è°ƒé˜Ÿåˆ—å°±èƒ½ç»´æŠ¤ï¼Œä¼š exkmp å°±èƒ½çº¿æ€§ï¼›&lt;/p&gt;
&lt;p&gt;å¦åˆ™å¯ä»¥äºŒåˆ† + å“ˆå¸Œå¤šä¸ª logï¼Œåé¢ä¹Ÿæœ‰ç†ç”±å·æ‡’ç”¨ä¼˜å…ˆé˜Ÿåˆ—äº†ã€‚&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int p = 31;
const int mod = 998244353;
int main() &amp;#123;
    std::freopen(&amp;quot;laozi.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;laozi.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
    std::string s;
    std::cin &amp;gt;&amp;gt; s;
    int n = (int)s.length(), t1, t2;
    std::vector&amp;lt;long long&amp;gt; h(n + 1), base(n + 1);
    std::vector&amp;lt;int&amp;gt; a(n + 1), t0(27), z(n + 1), r(n + 1);
    base[0] = 1ll;
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        a[i] = s[i - 1] - &amp;#39;a&amp;#39; + 1;
        h[i] = (h[i - 1] * p + a[i]) % mod;
        base[i] = base[i - 1] * p % mod;
    &amp;#125;
    auto gethash = [&amp;amp;](int l, int r) &amp;#123;
        return (h[r] - h[l - 1] * base[r - l + 1] % mod + mod) % mod;
    &amp;#125;;
    for (int i = 1; i &amp;lt;= n; ++i)
        for (int l = 1, r = std::min(i - 1, n - i + 1), mid; l &amp;lt;= r; ) &amp;#123;
            mid = (l + r) &amp;gt;&amp;gt; 1;
            if (gethash(1, mid) == gethash(i, i + mid - 1))
                z[i] = mid, l = mid + 1;
            else
                r = mid - 1;
        &amp;#125;
    for (int i = 1; i &amp;lt; n; ++i)
        r[i] = i + std::min(i, z[i + 1]);
    for (int i = 1; i &amp;lt;= 26; ++i)
        std::cin &amp;gt;&amp;gt; t0[i];
    std::cin &amp;gt;&amp;gt; t1 &amp;gt;&amp;gt; t2;
    std::vector&amp;lt;long long&amp;gt; f(n + 1);
    std::priority_queue&amp;lt;std::pair&amp;lt;long long, int&amp;gt; &amp;gt; q;
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        f[i] = f[i - 1] + t0[a[i]];
        for (; !q.empty() &amp;amp;&amp;amp; r[q.top().second] &amp;lt; i; q.pop());
        if (!q.empty())
            f[i] = std::min(f[i], t1 - q.top().first - (long long)t2 * i);
        if (i != n)
            q.emplace(-(f[i] + 2ll * t2 * i), i);
    &amp;#125;
    std::cout &amp;lt;&amp;lt; f[n] &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;d.-éæ”»&#34;&gt;D. éæ”»&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.becoder.com.cn/contest/6462/problem/4&#34; class=&#34;uri&#34;&gt;https://www.becoder.com.cn/contest/6462/problem/4&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;ç»™å®š &lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt;ï¼Œå¯¹äºä¸€ä¸ª &lt;span class=&#34;math inline&#34;&gt;\(1\sim n\)&lt;/span&gt; çš„æ’åˆ—ï¼Œä½¿ç”¨æœ€å°çš„äº¤æ¢æ¬¡æ•°ä½¿å¾—å…¶å•å¢ã€‚åœ¨è¯¥å‰æä¸‹ï¼Œå®šä¹‰ä»£ä»·ä¸ºæ¯æ¬¡äº¤æ¢çš„ä¸¤ä¸ªæ•°ä¹‹ç§¯ã€‚å¯¹äºæ‰€æœ‰ &lt;span class=&#34;math inline&#34;&gt;\(n!\)&lt;/span&gt; ä¸ªæ’åˆ—ï¼Œè®¡ç®—æœ€å°ä»£ä»·ä¹‹å’Œã€‚&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(n\le 10^7\)&lt;/span&gt;ã€‚&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;è½¬åŒ–æˆï¼ŒæŠŠ &lt;span class=&#34;math inline&#34;&gt;\(1\sim n\)&lt;/span&gt; åˆ†æˆæ— æ ‡å·çš„è‹¥å¹²ç»„ï¼Œæ¯ç»„çš„ä»£ä»·æ˜¯ æœ€å°å€¼ &lt;span class=&#34;math inline&#34;&gt;\(\times\)&lt;/span&gt; å…¶ä»–å…ƒç´ çš„å’Œï¼Œè¿˜æœ‰ä¸€ä¸ªé¡¹é“¾é—®é¢˜çš„ç³»æ•°ï¼Œå‘ç°ç»„é—´çš„ç¬¦å·æ˜¯æ±‚å’Œï¼Œè€ƒè™‘è®¡ç®—è´¡çŒ®ã€‚&lt;/p&gt;
&lt;p&gt;æšä¸¾ &lt;span class=&#34;math inline&#34;&gt;\(i,j\)&lt;/span&gt; å¹¶é’¦å®šä¸¤ä¸ªåŒå±ä¸€ä¸ªç¯ï¼Œä¸” &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; ä¸ºæœ€å°å€¼ï¼Œæšä¸¾ç¯å¤§å° &lt;span class=&#34;math inline&#34;&gt;\(s+2\)&lt;/span&gt;ï¼Œé‚£ä¹ˆæœ‰ï¼š&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
\begin{aligned}
res&amp;amp;=\sum_{i=1}^{n-1}\sum_{j=i+1}^n i\cdot j \cdot \sum_{s=0}^{n-i-1}\binom{n-i-1}s \cdot (s+1)!\cdot (n-s-2)!\\
&amp;amp;=\sum_{i=1}^{n-1}i\cdot \dfrac {(i+n+1)(n-i)}2 \cdot \sum_{s=0}^{n-i-1}\binom{n-i-1}s\cdot (s+1)!\cdot (n-s-2)!\\
&amp;amp;=\frac 12\times\sum_{i=1}^{n-1}i\cdot (i+n+1)\cdot (n-i)!\cdot\sum_{s=0}^{n-i-1}\dfrac {(s + 1)\cdot (n-s-2)!}{(n-i-1-s)!}\\
\end{aligned}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;ä»¤ &lt;span class=&#34;math inline&#34;&gt;\(T=n-i-1\)&lt;/span&gt;ï¼Œå‘ç°æˆ‘ä»¬éœ€è¦å¿«é€Ÿè®¡ç®— &lt;span class=&#34;math inline&#34;&gt;\(f_T=\sum\limits_{i=0}^T \dfrac{(i+1)\cdot (n-i-2)!}{(T-i)!}\)&lt;/span&gt;ã€‚è®° &lt;span class=&#34;math inline&#34;&gt;\(m=n-2\)&lt;/span&gt;ï¼Œå˜å½¢å¾— &lt;span class=&#34;math inline&#34;&gt;\(f_T=(m-T)!\cdot \sum\limits_{i=0}^{T} (i+1) \binom{m-i}{m-T}\)&lt;/span&gt;ï¼Œå‘ç°ä¼¼ä¹å¯ä»¥ç®€åŒ–ï¼Œä»¤ &lt;span class=&#34;math inline&#34;&gt;\(k=m-T,t=T+1\)&lt;/span&gt;ï¼Œåˆ™ &lt;span class=&#34;math inline&#34;&gt;\(f_T=\sum\limits_{i=1}^T i\cdot \binom {k+t-i}k\)&lt;/span&gt;ã€‚&lt;/p&gt;
&lt;p&gt;ç„¶åæ˜¯ç»å…¸çš„ç»„åˆæ„ä¹‰ä¿å¹³å®‰ç¯èŠ‚ï¼Œå³ä» &lt;span class=&#34;math inline&#34;&gt;\(k+t\)&lt;/span&gt; ä¸ªæœ‰æ ‡å·å°çƒä¸­é€‰æ‹©ä¸€æ¡åˆ†ç•Œçº¿ï¼Œåˆ†ç•Œçº¿å·¦è¾¹é€‰ä¸€ä¸ªçƒã€å³è¾¹é€‰ &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; ä¸ªçƒçš„æ–¹æ¡ˆæ•°ã€‚å‘ç°åˆ†ç•Œçº¿çš„å­˜åœ¨å¾ˆè¯¡å¼‚ï¼Œæ•…ç”¨åˆ†ç•Œçº¿åæ–¹çš„ç¬¬ä¸€ä¸ªçƒä»£æ›¿ï¼Œåœ¨ &lt;span class=&#34;math inline&#34;&gt;\(t+1\)&lt;/span&gt; å¤„æ–°å»ºä¸€ä¸ªè™šçƒï¼Œè§„å®šåœ¨å‰ &lt;span class=&#34;math inline&#34;&gt;\(t+1\)&lt;/span&gt; ä¸ªçƒä¸­é€‰ä¸¤ä¸ªçƒï¼Œå¹¶ä»¤åä¸€ä¸ªä¸ºåˆ†ç•Œçº¿ï¼Œä¸”ä»¤å‰ &lt;span class=&#34;math inline&#34;&gt;\(t+1\)&lt;/span&gt; ä¸ªä¸­çš„å…¶ä»–çƒä¸ºå®çƒï¼Œå°±èƒ½å»ºç«‹åŒå°„ã€‚åœ¨åˆ†ç•Œçº¿åå†é€‰ &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; ä¸ªçƒï¼Œå®¹æ˜“å‘ç°ç›´æ¥åœ¨èŒƒå›´å†…é€‰ &lt;span class=&#34;math inline&#34;&gt;\(k+2\)&lt;/span&gt; ä¸ªçƒå°±èƒ½æ»¡è¶³æ¡ä»¶ï¼Œæ•… &lt;span class=&#34;math inline&#34;&gt;\(f_T=(n-T-2)!\cdot \binom{t+k+1}{k+2}\)&lt;/span&gt;ã€‚&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int mod = 1e9 + 7;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
    std::freopen(&amp;quot;mozi.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;mozi.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#endif
    int n;
    std::cin &amp;gt;&amp;gt; n;
    std::vector&amp;lt;long long&amp;gt; fac(n + 1), inv(n + 1), f(n + 1);
    fac[0] = inv[0] = 1ll;
    for (int i = 1; i &amp;lt;= n; ++i)
        fac[i] = fac[i - 1] * i % mod;
    auto qkp = [&amp;amp;](long long x, int y) &amp;#123;
        auto res(1ll);
        for (; y; (x *= x) %= mod, y &amp;gt;&amp;gt;= 1)
            if (y &amp;amp; 1)
                (res *= x) %= mod;
        return res;
    &amp;#125;;
    inv[n] = qkp(fac[n], mod - 2);
    for (int i = n - 1; i; --i)
        inv[i] = inv[i + 1] * (i + 1) % mod;
    auto C = [&amp;amp;](int n, int m) &amp;#123;
        return fac[n] * inv[n - m] % mod * inv[m] % mod;
    &amp;#125;;
    int m = n - 2;
    for (int T = 0; T &amp;lt;= n - 2; ++T) &amp;#123;
        int k = m - T, t = T + 1;
        f[T] = C(t + k + 1, k + 2) * fac[m - T] % mod;
    &amp;#125;
    auto res = 0ll;
    for (int i = 1; i &amp;lt;= n - 1; ++i)
        (res += (long long)i * (i + n + 1) % mod * fac[n - i] % mod * f[n - i - 1] % mod) %= mod;
    std::cout &amp;lt;&amp;lt; res * inv[2] % mod &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;c---destruction-of-walls&#34;&gt;C - Destruction of Walls&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/arc203/tasks/arc203_c&#34; class=&#34;uri&#34;&gt;https://atcoder.jp/contests/arc203/tasks/arc203_c&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;d---insert-xor&#34;&gt;D - Insert XOR&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/arc203/tasks/arc203_d&#34; class=&#34;uri&#34;&gt;https://atcoder.jp/contests/arc203/tasks/arc203_d&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;a---è®°å¿†&#34;&gt;A - è®°å¿†&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://ac.nowcoder.com/acm/problem/274793&#34; class=&#34;uri&#34;&gt;https://ac.nowcoder.com/acm/problem/274793&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;éœ€è¦æ„è¯†åˆ°é—®é¢˜æ˜¯é™æ€çš„ï¼Œå¹¶ä¸”ä¸èƒ½ç”¨çº¿æ®µæ ‘ä¹‹ç±»ç»´æŠ¤ï¼›æ•…è€ƒè™‘ç¦»çº¿ä¸‹æ¥ï¼Œæƒ³åŠæ³•åœ¨ LCA å¤„ç»Ÿè®¡ç­”æ¡ˆã€‚&lt;/p&gt;
&lt;p&gt;è¿™ä¸ªæ—¶å€™å‘ç°éœ€è¦åˆå¹¶å­æ ‘çŠ¶æ€ã€æ•´ä½“å¼‚æˆ–ã€æ•´ä½“ +1ï¼Œå¾ˆå®¹æ˜“æƒ³åˆ° Trieã€‚æŠŠ &lt;span class=&#34;math inline&#34;&gt;\(u\to\)&lt;/span&gt; LCA çš„ç­”æ¡ˆä¿å­˜åœ¨ LCA å¤„ï¼Œç„¶åå†ç”¨ DFS + å›æº¯ç»Ÿè®¡ LCA &lt;span class=&#34;math inline&#34;&gt;\(\to v\)&lt;/span&gt; çš„ç­”æ¡ˆã€‚æƒ³äº†åŠå¤©æ²¡æƒ³åˆ°æŠŠä¸Šä¸‹æ‹†å¼€æ¥åšä¹Ÿæ˜¯ç¥äº† ğŸ˜…&lt;/p&gt;
&lt;p&gt;å¯èƒ½æ¯”è¾ƒè€ƒéªŒå¯¹å­—å…¸æ ‘çš„ç†è§£ï¼Ÿåšä¸ªæ¯”å–»ï¼Œå­—å…¸æ ‘çš„ id å°±ç›¸å½“äºå¯¹è¿™ä¸ªç‚¹ä¸Šä¿¡æ¯çš„ã€å¼•ç”¨ã€ã€‚&lt;/p&gt;
&lt;details&gt;
&lt;p&gt;å­—å…¸æ ‘åˆå¹¶çš„æ—¶å€™å¯ä»¥è€ƒè™‘å›æ”¶åºŸå¼ƒç‚¹ï¼Œä¸ç„¶å¯èƒ½æœ‰ç‚¹å¡ã€‚&lt;/p&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int X = 50;
const int maxn = 2e7 + 5;
long long d[maxn];
int tot, T[maxn][2], f[maxn], fa[maxn];
#define lc(p) T[p][0]
#define rc(p) T[p][1]
int find(int x) &amp;#123; return x == f[x] ? x : f[x] = find(f[x]); &amp;#125;
int newnode(void) &amp;#123;
    int p = ++tot;
    assert(p &amp;lt; maxn);
    d[p] = lc(p) = rc(p) = 0, f[p] = p;
    return p;
&amp;#125;
void pushdown(int p) &amp;#123;
    if (d[p]) &amp;#123;
        if (d[p] &amp;amp; 1)
            std::swap(lc(p), rc(p));
        d[p] &amp;gt;&amp;gt;= 1;
        if (lc(p))
            d[lc(p)] ^= d[p];
        if (rc(p))
            d[rc(p)] ^= d[p];
        d[p] = 0;
    &amp;#125;
    return;
&amp;#125;
int ins(int p, long long x) &amp;#123;
    for (int i = 0; i &amp;lt; X; ++i) &amp;#123;
        pushdown(p);
        if (!T[p][(x &amp;gt;&amp;gt; i) &amp;amp; 1]) &amp;#123;
            T[p][(x &amp;gt;&amp;gt; i) &amp;amp; 1] = newnode();
            fa[T[p][(x &amp;gt;&amp;gt; i) &amp;amp; 1]] = p;
        &amp;#125;
        p = T[p][(x &amp;gt;&amp;gt; i) &amp;amp; 1];
    &amp;#125;
    return p;
&amp;#125;
void merge(int &amp;amp;p, int q) &amp;#123;
    if (!q)
        return;
    if (!p) &amp;#123;
        p = q;
        return;
    &amp;#125;
    pushdown(p), pushdown(q);
    fa[lc(q)] = p, fa[rc(q)] = p;
    merge(lc(p), lc(q)), merge(rc(p), rc(q));
    assert(f[p] == p), assert(f[q] == q), f[q] = p;
    return;
&amp;#125;
long long ask(int p) &amp;#123;
    std::vector&amp;lt;int&amp;gt; st;
    for (int i = 0, j = p; i &amp;lt; X; ++i)
        st.push_back(fa[j]), j = fa[j];
    for (int i = 0; i &amp;lt; X; ++i)
        pushdown(st.back()), st.pop_back();
    long long x = 0;
    for (int i = 0; i &amp;lt; X; ++i) &amp;#123;
        x = x * 2 + (p == rc(fa[p]));
        p = fa[p];
    &amp;#125;
    return x;
&amp;#125;
void add(int p) &amp;#123;
    for (int i = 0; p &amp;amp;&amp;amp; i &amp;lt; X; ++i) &amp;#123;
        pushdown(p);
        std::swap(lc(p), rc(p));
        p = lc(p);
    &amp;#125;
    return;
&amp;#125;
void del(int p) &amp;#123;
    for (int i = 0; p &amp;amp;&amp;amp; i &amp;lt; X; ++i) &amp;#123;
        pushdown(p);
        std::swap(lc(p), rc(p));
        p = rc(p);
    &amp;#125;
    return;
&amp;#125;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#endif
    int n, m;
    std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
    std::vector&amp;lt;int&amp;gt; a(n + 1);
    for (int i = 1; i &amp;lt;= n; ++i)
        std::cin &amp;gt;&amp;gt; a[i];
    std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; g(n + 1);
    for (int i = 1, x, y; i &amp;lt; n; ++i) &amp;#123;
        std::cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; y;
        g[x].push_back(y), g[y].push_back(x);
    &amp;#125;
    std::vector&amp;lt;int&amp;gt; siz(n + 1), son(n + 1), top(n + 1), fa(n + 1), dep(n + 1);
    std::function&amp;lt;void(int)&amp;gt; DFS = [&amp;amp;](int x) &amp;#123;
        siz[x] = 1;
        for (auto i : g[x])
            if (i != fa[x]) &amp;#123;
                dep[i] = dep[x] + 1;
                fa[i] = x, DFS(i);
                siz[x] += siz[i];
                if (siz[i] &amp;gt; siz[son[x]])
                    son[x] = i;
            &amp;#125;
        return;
    &amp;#125;;
    DFS(1);
    DFS = [&amp;amp;](int x) &amp;#123;
        if (son[x])
            top[son[x]] = top[x], DFS(son[x]);
        for (auto i : g[x])
            if (i != son[x] &amp;amp;&amp;amp; i != fa[x])
                top[i] = i, DFS(i);
        return;
    &amp;#125;;
    top[1] = 1, DFS(1);
    auto askLCA = [&amp;amp;](int x, int y) &amp;#123;
        for (; top[x] != top[y]; x = fa[top[x]])
            if (dep[top[x]] &amp;lt; dep[top[y]])
                std::swap(x, y);
        return dep[x] &amp;lt; dep[y] ? x : y;
    &amp;#125;;
    struct node &amp;#123; long long x; int u, v; &amp;#125;;
    std::vector&amp;lt;node&amp;gt; q(m + 1);
    std::vector&amp;lt;int&amp;gt; id(m + 1);
    std::vector&amp;lt;long long&amp;gt; res(m + 1), ans(m + 1);
    std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; up(n + 1), dn(n + 1), ed(n + 1);
    for (int i = 1, x, u, v; i &amp;lt;= m; ++i) &amp;#123;
        std::cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; u &amp;gt;&amp;gt; v;
        q[i] = &amp;#123; x, u, v &amp;#125;;
        up[u].push_back(i), dn[askLCA(u, v)].push_back(i), ed[v].push_back(i);
    &amp;#125;
    std::vector&amp;lt;int&amp;gt; rt(n + 1);
    DFS = [&amp;amp;](int x) &amp;#123;
        rt[x] = newnode();
        for (auto i : g[x])
            if (i != fa[x]) &amp;#123;
                DFS(i);
                merge(rt[x], rt[i]);
            &amp;#125;
        add(rt[x]);
        for (auto i : up[x])
            id[i] = ins(rt[x], q[i].x);
        d[rt[x]] ^= a[x];
        for (auto i : dn[x])
            res[i] = ask(find(id[i]));
        return;
    &amp;#125;;
    DFS(1);
    tot = 0, rt[0] = newnode();
    std::fill(id.begin() + 1, id.end(), 0);
    DFS = [&amp;amp;](int x) &amp;#123;
        d[rt[0]] ^= a[x];
        for (auto i : dn[x])
            id[i] = ins(rt[0], res[i]);
        for (auto i : ed[x])
            ans[i] = ask(id[i]);
        add(rt[0]);
        for (auto i : g[x])
            if (i != fa[x])
                DFS(i);
        del(rt[0]);
        d[rt[0]] ^= a[x];
        return;
    &amp;#125;;
    DFS(1);
    for (int i = 1; i &amp;lt;= m; ++i)
        std::cout &amp;lt;&amp;lt; ans[i] &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;b---ãƒ“ãƒ¼ãƒãƒ¼ã®ä¼šåˆ-2-meetings-2&#34;&gt;B - ãƒ“ãƒ¼ãƒãƒ¼ã®ä¼šåˆ 2 (Meetings 2)&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/AT_joisc2021_j&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/AT_joisc2021_j&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;å®šä¹‰æ‰€æ±‚ç‚¹ä¸ºã€å±€éƒ¨é‡å¿ƒã€ï¼›ç±»ä¼¼æ ‘çš„é‡å¿ƒï¼Œå®¹æ˜“å‘ç°å½“å…³é”®ç‚¹æ•°é‡ä¸ºå¥‡æ—¶ï¼Œåªå­˜åœ¨ä¸€ä¸ªå±€éƒ¨é‡å¿ƒï¼›å¦åˆ™ï¼Œå±€éƒ¨é‡å¿ƒç»„æˆä¸€æ¡é“¾ã€‚&lt;/p&gt;
&lt;p&gt;å³å¯¹äºæ¯ä¸€ä¸ª &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt;ï¼Œéœ€è¦æ‰¾åˆ°ä¸€æ¡æœ€é•¿é“¾ï¼Œä½¿å¾—å…¶ä¸¤ç«¯å­˜åœ¨å¤§å°ä¸º &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; çš„å­æ ‘ï¼ˆå®¹æ˜“å‘ç°å–åç¼€ max å³å¯å¾—åˆ°çœŸå®ç­”æ¡ˆï¼‰ã€‚ä½¿ç”¨ç‚¹åˆ†æ²»ï¼Œç²¾ç»†å®ç°å®¹æ˜“åšåˆ° &lt;span class=&#34;math inline&#34;&gt;\(O(n\log n)\)&lt;/span&gt;ã€‚&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#endif
    int n;
    std::cin &amp;gt;&amp;gt; n;
    std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; g(n + 1);
    for (int i = 1, x, y; i &amp;lt; n; ++i) &amp;#123;
        std::cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; y;
        g[x].push_back(y), g[y].push_back(x);
    &amp;#125;
    std::vector&amp;lt;int&amp;gt; mx(n + 1), siz(n + 1), p, tag(n + 1), res(n + 1, 1);
    std::function&amp;lt;void(int, int)&amp;gt; DFS1 = [&amp;amp;](int x, int fa) &amp;#123;
        p.push_back(x);
        siz[x] = 1, mx[x] = 0;
        for (auto i : g[x])
            if (!tag[i] &amp;amp;&amp;amp; i != fa) &amp;#123;
                DFS1(i, x);
                siz[x] += siz[i];
                mx[x] = std::max(mx[x], siz[i]);
            &amp;#125;
        return;
    &amp;#125;;
    auto findrt = [&amp;amp;](int x) &amp;#123;
        p.clear(), DFS1(x, -1);
        int n = (int)p.size();
        for (auto i : p)
            if (mx[i] &amp;lt;= n / 2 &amp;amp;&amp;amp; n - siz[i] &amp;lt;= n / 2)
                return i;
        assert(0);
        return -1;
    &amp;#125;;
    struct node &amp;#123;
        int u1, u2, id1, id2;
        node(): u1(0), u2(0), id1(0), id2(0) &amp;#123;&amp;#125;
        void upd(int u, int id) &amp;#123;
            if (id1 == id)
                u1 = std::max(u1, u);
            else if (u &amp;gt;= u1)
                u2 = u1, id2 = id1, u1 = u, id1 = id;
            else if (u &amp;gt;= u2)
                u2 = u, id2 = id;
            return;
        &amp;#125;
    &amp;#125;;
    std::vector&amp;lt;node&amp;gt; s(n + 1);
    std::function&amp;lt;void(int, int, int, int)&amp;gt; DFS2 = [&amp;amp;](int x, int fa, int dep, int anc) &amp;#123;
        s[siz[x]].upd(dep, anc);
        for (auto i : g[x])
            if (!tag[i] &amp;amp;&amp;amp; i != fa)
                DFS2(i, x, dep + 1, anc);
        return;
    &amp;#125;;
    std::function&amp;lt;void(int, int, int, int)&amp;gt; DFS3 = [&amp;amp;](int x, int fa, int dep, int anc) &amp;#123;
        int v = ((s[siz[x]].id1 == anc) ? s[siz[x]].u2 : s[siz[x]].u1);
        res[2 * siz[x]] = std::max(res[2 * siz[x]], dep + 1 + v);
        for (auto i : g[x])
            if (!tag[i] &amp;amp;&amp;amp; i != fa)
                DFS3(i, x, dep + 1, anc);
        return;
    &amp;#125;;
    std::function&amp;lt;void(int)&amp;gt; DFS = [&amp;amp;](int x) &amp;#123;
        x = findrt(x), p.clear(), DFS1(x, -1);
        // printf(&amp;quot;rt = %d\n&amp;quot;, x);
        for (auto i : g[x])
            if (!tag[i])
                DFS2(i, x, 1, i);
        for (int i = siz[x] - 1; i; --i) &amp;#123;
            s[i].upd(s[i + 1].u1, s[i + 1].id1);
            s[i].upd(s[i + 1].u2, s[i + 1].id2);
        &amp;#125;
        for (auto i : g[x])
            if (!tag[i])
                DFS3(i, x, 1, i);
        tag[x] = 1;
        for (int i = 1; i &amp;lt; siz[x]; ++i)
            s[i] = node();
        for (auto i : g[x])
            if (!tag[i])
                DFS(i);
        return;
    &amp;#125;;
    DFS(1);
    for (int i = (n &amp;gt;&amp;gt; 1) * 2; i; --i)
        if (i + 2 &amp;lt;= n)
            res[i] = std::max(res[i], res[i + 2]);
    for (int i = 1; i &amp;lt;= n; ++i)
        std::cout &amp;lt;&amp;lt; res[i] &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;c---the-closest-pair&#34;&gt;C - The Closest Pair&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://ac.nowcoder.com/acm/problem/262593&#34; class=&#34;uri&#34;&gt;https://ac.nowcoder.com/acm/problem/262593&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;å¸¸è§„æ–¹æ³•&lt;/strong&gt;ï¼šè€ƒè™‘&lt;strong&gt;æ”¯é…å¯¹&lt;/strong&gt;ï¼Œå¯¹äºæ¯ä¸ª &lt;span class=&#34;math inline&#34;&gt;\(a_i\)&lt;/span&gt;ï¼Œæ‰¾åˆ°æ‰€æœ‰åˆæ³•çš„ &lt;span class=&#34;math inline&#34;&gt;\(a_j\)&lt;/span&gt;ã€‚å®¹æ˜“æƒ³åˆ°æšä¸¾ &lt;span class=&#34;math inline&#34;&gt;\(a_i\div a_j\)&lt;/span&gt; æ¥åšï¼›å‡è®¾å­˜åœ¨ &lt;span class=&#34;math inline&#34;&gt;\(a_k\div a_i=a_j\div a_i\)&lt;/span&gt; ä¸” &lt;span class=&#34;math inline&#34;&gt;\(k&amp;gt;j\)&lt;/span&gt;ã€‚&lt;/p&gt;
&lt;p&gt;ä¸å¦¨è®¾ &lt;span class=&#34;math inline&#34;&gt;\(a_j=K\cdot a_i+p,a_k=K\cdot a_i+q\)&lt;/span&gt;ï¼Œ&lt;span class=&#34;math inline&#34;&gt;\((a_i,a_j),(a_i,a_k)\)&lt;/span&gt; å‡åˆæ³•å½“ä¸”ä»…å½“ä¸‹åˆ—æ¡ä»¶å…¨éƒ¨æˆç«‹ï¼š&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class=&#34;math inline&#34;&gt;\(a_j\bmod a_i&amp;gt;a_k\bmod a_i\)&lt;/span&gt;ï¼› åˆ™ &lt;span class=&#34;math inline&#34;&gt;\(a_j&amp;gt;a_k\)&lt;/span&gt;ã€‚&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;math inline&#34;&gt;\(a_j\bmod a_k&amp;gt;a_k\bmod a_i\)&lt;/span&gt;ï¼›åˆ &lt;span class=&#34;math inline&#34;&gt;\(p-q\ge a_j\bmod a_k\)&lt;/span&gt;ï¼ˆ&lt;strong&gt;å¤ªç‰›äº†è¿™ä¸€æ­¥&lt;/strong&gt;ï¼‰ï¼Œå³ &lt;span class=&#34;math inline&#34;&gt;\(p-q&amp;gt;q\iff p&amp;gt;2q\)&lt;/span&gt;ã€‚&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;è¯å¾—åªå…³å¿ƒåŒä¸€ä¸ª &lt;span class=&#34;math inline&#34;&gt;\(a_j\div a_i\)&lt;/span&gt; æ—¶çš„æ”¯é…å¯¹æ•°é‡ä¸º &lt;span class=&#34;math inline&#34;&gt;\(\log n\)&lt;/span&gt; çº§åˆ«ï¼›æ€»å¯¹æ•° &lt;span class=&#34;math inline&#34;&gt;\(O(n\log n\ln n)\)&lt;/span&gt;ã€‚ç¦»çº¿ä¸‹æ¥æ‰«æçº¿å°±è¡Œäº†ã€‚&lt;/p&gt;
&lt;details&gt;
&lt;p&gt;å¯¹ç€ å•ç‚¹ä¿®æ”¹ åŒºé—´æœ€å€¼ æƒ³äº† 1h çš„å• log åšæ³• ğŸ˜° æœç„¶å°è„‘æ‰çº¿å¤ªå¯æ€•äº†ï¼Œç¬¬äºŒå¤©æ—©ä¸Šé‡ç½®å¤§è„‘ 1s å‘ç°è‡ªå·±æ˜¯æ–¯æ³¢ ğŸ˜“&lt;/p&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int LEN = (1 &amp;lt;&amp;lt; 20);
int nec(void) &amp;#123;
    static char buf[LEN], *p = buf, *e = buf;
    if (p == e) &amp;#123;
        e = buf + fread(buf, 1, LEN, stdin);
        if (e == buf) return EOF;
        p = buf;
    &amp;#125;
    return *p++;
&amp;#125;
bool read(int &amp;amp;x) &amp;#123;
    x = 0;
    bool f = 0;
    char ch = nec();
    while (ch &amp;lt; &amp;#39;0&amp;#39; || ch &amp;gt; &amp;#39;9&amp;#39;) &amp;#123;
        if (ch == EOF) return 0;
        if (ch == &amp;#39;-&amp;#39;) f = 1;
        ch = nec();
    &amp;#125;
    while (ch &amp;gt;= &amp;#39;0&amp;#39; &amp;amp;&amp;amp; ch &amp;lt;= &amp;#39;9&amp;#39;) &amp;#123;
        x = x * 10 + ch - &amp;#39;0&amp;#39;;
        ch = nec();
    &amp;#125;
    if (f) x = -x;
    return 1;
&amp;#125;
void print(int x) &amp;#123;
    if (x &amp;lt; 0)
        putchar(&amp;#39;-&amp;#39;), x = -x;
    if (x &amp;gt;= 10) print(x / 10);
    putchar(x % 10 + &amp;#39;0&amp;#39;);
    return;
&amp;#125;
void print(int x, char ch) &amp;#123;
    print(x), putchar(ch);
    return;
&amp;#125;
const int maxn = 4e6 + 5;
struct &amp;#123; int l, r, u[2]; &amp;#125; t[maxn];
#define lt (t[p].l)
#define rt (t[p].r)
int tot[2];
void add(int &amp;amp;p, int l, int r, int x, int v, int i) &amp;#123;
    if (!p)
        p = ++tot[i], t[p].u[0] = -1, t[p].u[1] = 0x3f3f3f3f;
    if (i == 0)
        t[p].u[0] = std::max(t[p].u[0], v);
    else
        t[p].u[1] = std::min(t[p].u[1], v);
    if (l == r)
        return;
    int mid = (l + r) &amp;gt;&amp;gt; 1;
    if (x &amp;lt;= mid)
        add(lt, l, mid, x, v, i);
    else
        add(rt, mid + 1, r, x, v, i);
    return;
&amp;#125;
int ask(int p, int l, int r, int ql, int qr, int i) &amp;#123;
    if (!p || (ql &amp;lt;= l &amp;amp;&amp;amp; r &amp;lt;= qr))
        return t[p].u[i];
    int mid = (l + r) &amp;gt;&amp;gt; 1;
    if (qr &amp;lt;= mid)
        return ask(lt, l, mid, ql, qr, i);
    if (ql &amp;gt; mid)
        return ask(rt, mid + 1, r, ql, qr, i);
    if (i == 0)
        return std::max(ask(lt, l, mid, ql, qr, 0), ask(rt, mid + 1, r, ql, qr, 0));
    return std::min(ask(lt, l, mid, ql, qr, 1), ask(rt, mid + 1, r, ql, qr, 1));
&amp;#125;
#undef lt
#undef rt
int main() &amp;#123;
#ifndef ONLINE_JUDGE
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    const int m = 1e6;
    int rt[2] = &amp;#123; 0 &amp;#125;, n;
    t[0].u[0] = -1, t[0].u[1] = 0x3f3f3f3f;
    read(n);
    std::vector&amp;lt;int&amp;gt; a(n + 1);
    for (int i = 1; i &amp;lt;= n; ++i)
        read(a[i]);
    std::vector&amp;lt;std::vector&amp;lt;std::pair&amp;lt;int, int&amp;gt; &amp;gt; &amp;gt; t(n + 1);
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        if (i != 1) &amp;#123;
            for (int K = a[i]; K &amp;lt;= m; K += a[i]) &amp;#123;
                for (int mx = std::min(a[i] - 1, m - K); ; ) &amp;#123;
                    int k = ask(rt[0], 1, m, K, K + mx, 0);
                    if (k == -1)
                        break;
                    t[i].emplace_back(k, a[k] - K);
                    if (k == 1 || !(a[k] - K))
                        break;
                    mx = (a[k] - K - 1) / 2;
                &amp;#125;
            &amp;#125;
        &amp;#125;
        add(rt[0], 1, m, a[i], i, 0);
    &amp;#125;
    for (int i = n; i; --i) &amp;#123;
        if (i != n)
            for (int K = a[i]; K &amp;lt;= m; K += a[i])
                for (int mx = std::min(a[i] - 1, m - K); ; ) &amp;#123;
                    int k = ask(rt[1], 1, m, K, K + mx, 1);
                    if (k == 0x3f3f3f3f)
                        break;
                    t[k].emplace_back(i, a[k] - K);
                    if (k == n || !(a[k] - K))
                        break;
                    mx = (a[k] - K - 1) / 2;
                &amp;#125;
        add(rt[1], 1, m, a[i], i, 1);
    &amp;#125;
    int q;
    read(q);
    std::vector&amp;lt;int&amp;gt; res(q + 1);
    std::vector&amp;lt;std::vector&amp;lt;std::pair&amp;lt;int, int&amp;gt; &amp;gt; &amp;gt; u(n + 1);
    for (int i = 1, l, r; i &amp;lt;= q; ++i) &amp;#123;
        read(l), read(r);
        if (l &amp;gt; r)
            std::swap(l, r);
        u[r].emplace_back(l, i);
    &amp;#125;
    std::vector&amp;lt;int&amp;gt; bit(n + 1, 0x3f3f3f3f);
    auto lowbit = [&amp;amp;](int x) &amp;#123; return x &amp;amp; -x; &amp;#125;;
    auto add = [&amp;amp;](int x, int v) &amp;#123;
        for (; x &amp;lt;= n; x += lowbit(x))
            bit[x] = std::min(bit[x], v);
        return;
    &amp;#125;;
    auto ask = [&amp;amp;](int x) &amp;#123;
        auto res = 0x3f3f3f3f;
        for (; x; x -= lowbit(x))
            res = std::min(res, bit[x]);
        return res;
    &amp;#125;;
    for (int r = 1; r &amp;lt;= n; ++r) &amp;#123;
        for (auto [l, v] : t[r])
            add(n - l + 1, v);
        for (auto [l, i] : u[r])
            res[i] = ask(n - l + 1);
    &amp;#125;
    for (int i = 1; i &amp;lt;= q; ++i)
        print(res[i], &amp;#39;\n&amp;#39;);
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;p&gt;æ±‚æ”¯é…å¯¹çš„è¿‡ç¨‹ä¹Ÿè¦å¸¦ logï¼ˆçº¿æ®µæ ‘ï¼‰ï¼Œå†åŠ ä¸Šæ‰«æçº¿çš„ 3logï¼Œæ€»å…±æ˜¯å¸¸æ•°æ¯”è¾ƒå¤§çš„ 3logï¼ˆå¡äº†ä¸€ä¸ªä¸Šåˆçš„å¸¸ä¹Ÿæ˜¯æœ‰äº†ï¼‰ã€‚æ‰€ä»¥æ¥ä¸‹æ¥è®²è§£å¦ä¸€ç§å¥‡æŠ€æ·«å·§ã€‚&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;æš´åŠ›åˆ†æ²»&lt;/strong&gt;ï¼šæ³¨æ„åˆ°å¯¹äºæ¯”è¾ƒé•¿ï¼ˆ&lt;span class=&#34;math inline&#34;&gt;\(len&amp;gt; B\)&lt;/span&gt;ï¼‰çš„åŒºé—´ï¼Œç­”æ¡ˆæ¯”è¾ƒå°ï¼›æ•…è€ƒè™‘åˆ†æ²»ã€‚&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;å¯¹äºé•¿è¯¢é—®ï¼ˆ&lt;span class=&#34;math inline&#34;&gt;\(len&amp;gt;B\)&lt;/span&gt;ï¼‰ï¼Œä»å°åˆ°å¤§æšä¸¾ç­”æ¡ˆå¹¶ checkï¼›é¢„å¤„ç†æŸä¸ªèŒƒå›´ï¼ˆ&lt;span class=&#34;math inline&#34;&gt;\(V\)&lt;/span&gt;ï¼‰å†…çš„ &lt;span class=&#34;math inline&#34;&gt;\(res\)&lt;/span&gt; å‡ºç°çš„æ‰€æœ‰ä½ç½®ï¼Œå¹³è¡¡çš„æ—¶å€™è¿˜è¦ç®—ä¸Šè°ƒå’Œçº§æ•°å’Œ bitã€‚&lt;/li&gt;
&lt;li&gt;å¯¹äºçŸ­è¯¢é—®ï¼ˆ&lt;span class=&#34;math inline&#34;&gt;\(len\le B\)&lt;/span&gt;ï¼‰ï¼Œå‘ç°æ¯æ¬¡åŒºé—´å†…æš´åŠ›æ˜¯ &lt;span class=&#34;math inline&#34;&gt;\(O(B^2q)\)&lt;/span&gt; çš„ï¼›æŠŠè¯¢é—®ç¦»çº¿ä¸‹æ¥ï¼Œç²¾ç»†å®ç°ï¼Œåˆ©ç”¨è¯¢é—®çš„å…¬å…±éƒ¨åˆ†ä½¿å¾—&lt;strong&gt;æ¯ä¸€å¯¹æ•°åªè¢«æšä¸¾ä¸€æ¬¡&lt;/strong&gt;å°±èƒ½è¾¾åˆ° &lt;span class=&#34;math inline&#34;&gt;\(O(B^2 + Bq)\)&lt;/span&gt;ã€‚&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;æœ€ä¼˜è§£å– &lt;span class=&#34;math inline&#34;&gt;\(B=333,V=483\)&lt;/span&gt;ï¼Œä¸è‡ªå·±å®ç°ä¸€éäº†ã€‚&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;d---ä»™äººæŒ&#34;&gt;D - ä»™äººæŒ&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P3687&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P3687&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;æŠŠè¾¹åŒä»å›¾ä¸­åˆ é™¤ã€é—®é¢˜è½¬åŒ–ä¸ºæ ‘ä¸Š&lt;strong&gt;è¾¹&lt;/strong&gt;ä¸äº¤çš„é“¾è¦†ç›–ï¼Œä½¿å¾—&lt;strong&gt;æ‰€æœ‰é“¾é•¿ &lt;span class=&#34;math inline&#34;&gt;\(\ge 2\)&lt;/span&gt;&lt;/strong&gt; çš„æ–¹æ¡ˆæ•°ã€‚å‘ç°ç”±äº&lt;strong&gt;è¾¹å¯ä»¥ä¸è¢«è¦†ç›–&lt;/strong&gt;ï¼Œå¸¸è§„ DP ä¼šä½¿å¾—åœ¨çˆ¶èŠ‚ç‚¹å¤„åˆå¹¶æ—¶éœ€è¦é¢å¤–çš„æ•°é‡ç»´ï¼Œå‚è€ƒæ ‘ä¸ŠèƒŒåŒ…ï¼Œå¤æ‚åº¦ &lt;span class=&#34;math inline&#34;&gt;\(O(n^2)\)&lt;/span&gt;ã€‚&lt;/p&gt;
&lt;p&gt;æ€è€ƒæ—¶ä¼šæ³¨æ„åˆ°ä¸¤ä¸ªé™åˆ¶å¯ä»¥æŠµæ¶ˆâ€”â€”å¦‚æœè®¤ä¸ºé•¿ä¸º &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt; çš„é“¾å°±æ˜¯ä¸è¢«è¦†ç›–çš„è¾¹ï¼Œè¦†ç›–æ‰€æœ‰æ ‘è¾¹ï¼Œæ˜¾ç„¶å¯ä»¥å»ºç«‹å’Œåˆæ³•è§£çš„åŒå°„ã€‚æ­¤æ—¶åˆå¹¶æ˜¯éå¸¸æ–¹ä¾¿çš„ï¼Œæ³¨æ„åˆ°æ¯ä¸ªå„¿å­çš„ç³»æ•°ä¸€å®šéƒ½å‚ä¸ã€åˆ†æ­¥ã€ï¼Œåªéœ€è¦æ±‚å‡ºã€åˆ†ç±»ã€çš„ç³»æ•°ã€‚è¿™ä¸ªå¯ä»¥é¢„å¤„ç†ï¼ˆå’Œ &lt;a href=&#34;/20250407/#a.-äºŒåˆ†å›¾æŸ“è‰²&#34;&gt;äºŒåˆ†å›¾æŸ“è‰²&lt;/a&gt; è¿™ä¸ªé¢˜æœ‰ç‚¹åƒï¼‰ï¼Œä»¤ &lt;span class=&#34;math inline&#34;&gt;\(f_i\)&lt;/span&gt; è¡¨ç¤ºä¸€ä¸ªç‚¹åº¦æ•°ä¸º &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; æ—¶çš„ç­”æ¡ˆï¼Œå‚è€ƒé”™æ’çš„æ€è·¯ï¼Œåˆ™ &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; å¯ä»¥ä¸å‚ä¸é…å¯¹ï¼Œä¹Ÿå¯ä»¥ä¹±é€‰ä¸€ä¸ªç‚¹é…å¯¹ï¼Œå¦‚æœé€‰ä¸­äº†å·²é…å¯¹çš„ç‚¹å°±ä»¤å…¶å’Œ &lt;span class=&#34;math inline&#34;&gt;\(i-1\)&lt;/span&gt; äº¤æ¢ï¼Œå¯ä»¥å»ºç«‹å’Œåˆæ³•è§£çš„åŒå°„ã€‚åˆ™ &lt;span class=&#34;math inline&#34;&gt;\(f_i=f_{i-1}+(n-1)f_{i-2}\)&lt;/span&gt;ã€‚&lt;/p&gt;
&lt;p&gt;é¦–å…ˆéœ€è¦ check åŸå›¾æ˜¯å¦ä¸ºä»™äººæŒï¼Œé¡ºå¸¦å›å¿†ä¸€ä¸‹è¿é€šæ€§çš„çŸ¥è¯†â€”â€”åœ¨ DFS æ ‘ä¸Šå·®åˆ†ï¼Œæ£€æŸ¥æ˜¯å¦æœ‰è¾¹è¢«è¦†ç›–ä¸¤æ¬¡å³å¯ã€‚&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int mod = 998244353;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int T;
    for (std::cin &amp;gt;&amp;gt; T; T--; ) &amp;#123;
        int n, m;
        std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
        std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; g1(n + 1);
        for (int x, y; m--; ) &amp;#123;
            std::cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; y;
            g1[x].push_back(y), g1[y].push_back(x);
        &amp;#125;
        bool flag = 1;
        int now = 0, cnt = 0;
        std::vector&amp;lt;int&amp;gt; st, dfn(n + 1), low(n + 1), col(n + 1), diff(n + 1);
        std::function&amp;lt;void(int, int)&amp;gt; DFS = [&amp;amp;](int x, int fa) &amp;#123;
            st.push_back(x);
            dfn[x] = low[x] = ++now;
            for (auto i : g1[x])
                if (!dfn[i]) &amp;#123;
                    // printf(&amp;quot;x = %d, %d -&amp;gt; %d\n&amp;quot;, x, x, i);
                    DFS(i, x);
                    diff[x] += diff[i];
                    // printf(&amp;quot;x = %d, diff[%d] += diff[%d]\n&amp;quot;, x, x, i);
                    low[x] = std::min(low[x], low[i]);
                &amp;#125;
                else if (i != fa &amp;amp;&amp;amp; dfn[i] &amp;lt; dfn[x]) &amp;#123;
                    low[x] = std::min(low[x], dfn[i]);
                    ++diff[x], --diff[i];
                    // printf(&amp;quot;x = %d, ++diff[%d], --diff[%d]\n&amp;quot;, x, x, i);
                &amp;#125;
            if (diff[x] &amp;gt;= 2)
                flag = 0;
            // printf(&amp;quot;x = %d, diff[%d] = %d\n&amp;quot;, x, x, diff[x]);
            if (low[x] == dfn[x]) &amp;#123;
                ++cnt;
                for (int p = -1; p != x; ) &amp;#123;
                    p = st.back(), st.pop_back();
                    col[p] = cnt;
                &amp;#125;
            &amp;#125;
            return;
        &amp;#125;;
        DFS(1, -1);
        if (!flag) &amp;#123;
            std::cout &amp;lt;&amp;lt; 0 &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
            continue;
        &amp;#125;
        std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; g(n + 1);
        for (int i = 1; i &amp;lt;= n; ++i)
            for (auto j : g1[i])
                if (col[i] != col[j])
                    g[i].push_back(j);
        std::vector&amp;lt;long long&amp;gt; f(n + 1), dp(n + 1);
        dp[0] = 1ll, dp[1] = 1ll;
        for (int i = 2; i &amp;lt;= n; ++i)
            dp[i] = (dp[i - 1] + (i - 1) * dp[i - 2]) % mod;
        std::vector&amp;lt;int&amp;gt; tag(n + 1);
        DFS = [&amp;amp;](int x, int fa) &amp;#123;
            f[x] = 1ll, tag[x] = 1;
            for (auto i : g[x])
                if (i != fa) &amp;#123;
                    DFS(i, x);
                    (f[x] *= f[i]) %= mod;
                &amp;#125;
            (f[x] *= dp[(int)g[x].size()]) %= mod;
            return;
        &amp;#125;;
        auto res(1ll);
        for (int i = 1; i &amp;lt;= n; ++i)
            if (!tag[i])
                DFS(i, -1), (res *= f[i]) %= mod;
        std::cout &amp;lt;&amp;lt; res &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    &amp;#125;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;p&gt;E. Many Minimizations æ˜¯æ•°å­¦é¢˜ï¼Œè·³äº†ã€‚&lt;/p&gt;
&lt;hr /&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;æ— åé¢˜&#34;&gt;æ— åé¢˜&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;èƒŒæ™¯ï¼šç»™å®š &lt;span class=&#34;math inline&#34;&gt;\(n,k\)&lt;/span&gt;ï¼Œå¯¹äº &lt;span class=&#34;math inline&#34;&gt;\(\forall\, 1\le i\le n\)&lt;/span&gt;ï¼Œä»¤ &lt;span class=&#34;math inline&#34;&gt;\(a_i=i\bmod k\)&lt;/span&gt;ï¼Œé—®ä¸€å…±æœ‰å¤šå°‘ä¸ªæœ¬è´¨ä¸åŒçš„å­åºåˆ—ï¼Ÿå¯¹äº &lt;span class=&#34;math inline&#34;&gt;\(k=1,2,\cdots,n\)&lt;/span&gt; åˆ†åˆ«æ±‚å‡ºç­”æ¡ˆã€‚&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;maimai&#34;&gt;maimai&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://ac.nowcoder.com/acm/contest/66112/F&#34; class=&#34;uri&#34;&gt;https://ac.nowcoder.com/acm/contest/66112/F&lt;/a&gt;&lt;/p&gt;
</content>
        <category term="å­—å…¸æ ‘" />
        <category term="è®¡æ•°" />
        <category term="å­—ç¬¦ä¸²" />
        <category term="æ”¯é…å¯¹" />
        <updated>2025-08-09T04:33:17.000Z</updated>
    </entry>
</feed>
