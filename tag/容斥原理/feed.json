{
    "version": "https://jsonfeed.org/version/1",
    "title": "null • All posts by \"容斥原理\" tag",
    "description": "",
    "home_page_url": "https://xsc062.netlify.app",
    "items": [
        {
            "id": "https://xsc062.netlify.app/20250510/",
            "url": "https://xsc062.netlify.app/20250510/",
            "title": "杂题",
            "date_published": "2025-05-10T02:18:21.000Z",
            "content_html": "<p>啊啊。小封条。</p>\n<span id=\"more\"></span>\n<hr />\n<h2 id=\"a---pass-to-next\">A - Pass to Next</h2>\n<p><a href=\"https://atcoder.jp/contests/arc124/tasks/arc124_e\" class=\"uri\">https://atcoder.jp/contests/arc124/tasks/arc124_e</a></p>\n<p>感觉其他一些题解讲得不是特别清楚，这里参考了 <a href=\"https://blog.csdn.net/weixin_43960287/article/details/119140590\">XJX 的文章</a>。</p>\n<p>要求的答案是 <span class=\"math inline\">\\(\\prod a&#39;_i\\)</span>，<mark>发现运算是乘法，比较怪；由此考虑转化为方案数，也就是假设每个人有 <span class=\"math inline\">\\(a&#39;_i\\)</span> 个互不相同的球，每个人在其中选出恰好一个的方案数</mark>。</p>\n<p>考虑 DP。发现每个人手上的球分为『自己的』和『左边的人传过来的』两种类型；<mark>显然第二种会有来自上一个人的限制，考虑把第二种在上一个人就完成求解</mark>。具体地，设 <span class=\"math inline\">\\(f_{i,0}\\)</span> 表示第 <span class=\"math inline\">\\(i\\)</span> 个人选取自己的球，但只记录 <span class=\"math inline\">\\(1\\sim i-1\\)</span> 的方案；<span class=\"math inline\">\\(f_{i,1}\\)</span> 表示第 <span class=\"math inline\">\\(i\\)</span> 个人选取第 <span class=\"math inline\">\\(i-1\\)</span> 个人的球，并记入答案的方案。<em>你可能需要注意到：最后一个被记入方案的球来自第 <span class=\"math inline\">\\(i-1\\)</span> 个人</em>。</p>\n<p>但这样会有个小问题。我们让所有人多往右边传一个球，那么在我们的这种分割方法看来是不一样的局面；但实际上它们是等价的。从每个人传出了多少个球（设为 <span class=\"math inline\">\\(x_i\\)</span>）的角度来看，对于 <span class=\"math inline\">\\(\\min\\{x_n\\}\\ne 0\\)</span>，只需要不断执行 <span class=\"math inline\">\\(\\forall\\, x_i\\gets x_i-1\\)</span> 就可以在局面不变的情况下使 <span class=\"math inline\">\\(\\min\\{x_n\\}\\ne 0\\)</span>。这是在说，可以让 <span class=\"math inline\">\\(\\min\\{x_n\\}\\ne 0\\)</span> 的方案和终局一一对应。</p>\n<p>发现可以容斥：钦定 <span class=\"math inline\">\\(x_i\\ge 1\\)</span>，也就是每个人必须往右传至少一个，相似地算一遍就能得到非法方案。</p>\n<p>考虑转移，令 <span class=\"math inline\">\\(x_i\\)</span> 可选最小值为 <span class=\"math inline\">\\(l\\)</span>，有：</p>\n<ul>\n<li><span class=\"math inline\">\\(f_{i+1,0}\\gets f_{i,0}\\)</span>：将第 <span class=\"math inline\">\\(i\\)</span> 个人未被记入的自己的球记入，球数可能为 <span class=\"math inline\">\\([0,a_i-l]\\)</span>。等差数列求和即可。</li>\n<li><span class=\"math inline\">\\(f_{i+1,0}\\gets f_{i,1}\\)</span>：没有球需要被记入，但是这种情况对应多种 <span class=\"math inline\">\\(x_i\\)</span>。具体地，<span class=\"math inline\">\\(x_i\\in [l,a_i]\\)</span>。共有 <span class=\"math inline\">\\(a_i-l+1\\)</span> 种方案。</li>\n<li><span class=\"math inline\">\\(f_{i+1,1}\\gets f_{i,0}\\)</span>：将第 <span class=\"math inline\">\\(i\\)</span> 个人的 <span class=\"math inline\">\\(a_i\\)</span> 个球分给 <span class=\"math inline\">\\(i\\)</span> 和 <span class=\"math inline\">\\(i+1\\)</span>。共有 <span class=\"math inline\">\\(x_i\\cdot (a_i-x_i)\\)</span> 种可能，也就是 <span class=\"math inline\">\\(\\left(a_i\\cdot \\sum_{x_i=l}^{a_i} x_i\\right)-\\left(\\sum_{x_i=l}^{a_i}{x_i}^2\\right)\\)</span> 种方案。</li>\n<li><span class=\"math inline\">\\(f_{i+1,1}\\gets f_{i,1}\\)</span>：将第 <span class=\"math inline\">\\(i+1\\)</span> 个人得到的第 <span class=\"math inline\">\\(i\\)</span> 个人的球记入，同第一条。</li>\n</ul>\n<p>破环为链，分别钦定第一个人是用自己的球还是上一个人的球来解决问题（必须对于两种可能性分开计算；否则就不知道答案应该取 <span class=\"math inline\">\\(f_{n,0}\\)</span> 还是 <span class=\"math inline\">\\(f_{n,1}\\)</span>）。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 998244353, inv2 = (mod + 1) &gt;&gt; 1, inv6 = 166374059;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;long long&gt; a(n);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i % n];\n    auto sum = [&amp;](long long r) &#123;\n        return r * (r + 1) % mod * inv2 % mod;\n    &#125;;\n    auto sum2 = [&amp;](long long r) &#123;\n        return r * (r + 1) % mod * (2 * r % mod + 1) % mod * inv6 % mod;\n    &#125;;\n    std::vector&lt;std::vector&lt;long long&gt; &gt; f0(n, std::vector&lt;long long&gt; (2)), f1(n, std::vector&lt;long long&gt; (2));\n    auto calc = [&amp;](long long l, std::vector&lt;std::vector&lt;long long&gt; &gt; &amp;f) &#123;\n        f[0][0] = 1ll;\n        for (int i = 0; i &lt; n; ++i) &#123;\n            int j = (i + 1) % n;\n            f[j][0] = f[i][0] * sum(a[i] - l) % mod;\n            (f[j][0] += f[i][1] * (a[i] - l + 1)) %= mod;\n            f[j][1] = f[i][0] * (a[i] * sum(a[i]) % mod - sum2(a[i])) % mod;\n            (f[j][1] += f[i][1] * sum(a[i]) % mod) %= mod;\n            // printf(&quot;0, l = %lld, f[%d]: %lld / %lld\\n&quot;, l, j, f[j][0], f[j][1]);\n        &#125;\n        auto res(f[0][0]);\n        f.assign(n, std::vector&lt;long long&gt; (2));\n        f[0][1] = 1ll;\n        for (int i = 0; i &lt; n; ++i) &#123;\n            int j = (i + 1) % n;\n            f[j][0] = f[i][0] * sum(a[i] - l) % mod;\n            (f[j][0] += f[i][1] * (a[i] - l + 1)) %= mod;\n            f[j][1] = f[i][0] * (a[i] * sum(a[i]) % mod - sum2(a[i])) % mod;\n            (f[j][1] += f[i][1] * sum(a[i]) % mod) %= mod;\n            // printf(&quot;1, l = %lld, f[%d]: %lld / %lld\\n&quot;, l, j, f[j][0], f[j][1]);\n        &#125;\n        return (res + f[0][1]) % mod;\n    &#125;;\n    std::cout &lt;&lt; (calc(0, f0) + mod - calc(1, f1)) % mod &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"b---绿宝石之岛\">B - 绿宝石之岛</h2>\n<p><a href=\"https://loj.ac/p/6406\" class=\"uri\">https://loj.ac/p/6406</a></p>\n<p>因为只关心最终状态，原题可以转化为：将 <span class=\"math inline\">\\(d\\)</span> 分成 <span class=\"math inline\">\\(n\\)</span> 个非负整数，前 <span class=\"math inline\">\\(r\\)</span> 大数之和的期望（当然你需要加上初始的 <span class=\"math inline\">\\(r\\)</span> 个）。</p>\n<p>关于非负整数拆分：设 <span class=\"math inline\">\\(f_{i,j}\\)</span> 表示将 <span class=\"math inline\">\\(i\\)</span> 分成 <span class=\"math inline\">\\(j\\)</span> 个 <strong>非负整数</strong> 的方案，钦定其中恰有 <span class=\"math inline\">\\(k\\)</span> 个 <strong>正整数</strong> 进行转移，给这 <span class=\"math inline\">\\(k\\)</span> 个数先分一个 <span class=\"math inline\">\\(1\\)</span>，则 <span class=\"math inline\">\\(f_{i,j}=\\sum\\limits_{k=0}^{\\min(i,j)} C_j^k\\cdot f_{i-k,k}\\)</span>。</p>\n<p>再设 <span class=\"math inline\">\\(g_{i,j}\\)</span> 表示将 <span class=\"math inline\">\\(i\\)</span> 分成 <span class=\"math inline\">\\(j\\)</span> 个非负整数的所有方案中、前 <span class=\"math inline\">\\(r\\)</span> 大的数之和。类似地，有 <span class=\"math inline\">\\(g_{i,j}=\\sum\\limits_{k=0}^{\\min(i,j)} C_j^k\\cdot (g_{i-k,k}+\\min(k,r)\\cdot f_{i-k,k})\\)</span>。其中，<span class=\"math inline\">\\(\\min(k,r)\\)</span> 的来源是，只有 <span class=\"math inline\">\\(k\\)</span> 个数有值，前 <span class=\"math inline\">\\(r\\)</span> 大的数一定在这 <span class=\"math inline\">\\(k\\)</span> 个数里面。</p>\n<p>答案为 <span class=\"math inline\">\\(\\dfrac {g_{d,n}}{f_{d,n}}+r\\)</span>，复杂度 <span class=\"math inline\">\\(O(n^3)\\)</span>。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, d, r;\n    std::cin &gt;&gt; n &gt;&gt; d &gt;&gt; r;\n    using arr = std::vector&lt;double&gt;;\n    std::vector&lt;arr&gt; f(d + 1, arr(n + 1)), g(d + 1, arr(n + 1)), C(n + 1, arr(n + 1));\n    for (int i = 0; i &lt;= n; ++i) &#123;\n        C[i][0] = 1.;\n        for (int j = 1; j &lt;= i; ++j)\n            C[i][j] = C[i - 1][j - 1] + C[i - 1][j];\n    &#125;\n    f[0].assign(n + 1, 1.);\n    for (int i = 1; i &lt;= d; ++i)\n        for (int j = 1; j &lt;= n; ++j) &#123;\n            for (int k = 1; k &lt;= i &amp;&amp; k &lt;= j; ++k) &#123;\n                f[i][j] += C[j][k] * f[i - k][k];\n                g[i][j] += C[j][k] * (g[i - k][k] + std::min(k, r) * f[i - k][k]);\n                // printf(&quot;  k = %d, %.0lf + %.0lf\\n&quot;, k, C[j][k] * g[i - k][k], std::min(k, r) * f[i - k][k]);\n            &#125;\n            // printf(&quot;f[%d][%d] = %.0lf, g[%d][%d] = %.0lf\\n&quot;, i, j, f[i][j], i, j, g[i][j]);\n        &#125;\n    std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(8) &lt;&lt; g[d][n] / f[d][n] + r &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"c---uddered-but-not-herd-g\">C - Uddered but not Herd G</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P7296\" class=\"uri\">https://www.luogu.com.cn/problem/P7296</a></p>\n<p>给每个字母分配一个标号 <span class=\"math inline\">\\(x\\)</span>，那么最小段数就是 <span class=\"math inline\">\\(\\sum \\left[x_i\\ge x_{i+1}\\right]\\)</span>。</p>\n<p>考虑状压完成映射操作，令 <span class=\"math inline\">\\(f_{s}\\)</span> 表示给标号 <span class=\"math inline\">\\(1\\sim |s|\\)</span> 分配字母后，占用字符集 <span class=\"math inline\">\\(s\\)</span> 的方案数，那么就能 <span class=\"math inline\">\\(O(1)\\)</span> 得到贡献——只需预处理出 <span class=\"math inline\">\\(f_{c, s}\\)</span> 表示分配到字母 <span class=\"math inline\">\\(c\\)</span> 时，已经先给 <span class=\"math inline\">\\(s\\)</span> 中字母分配了更小标号时的贡献。</p>\n<p>注意字符集大小只有 <span class=\"math inline\">\\(20\\)</span>，可以 <span class=\"math inline\">\\(O(|S|\\cdot 2^{|S|})\\)</span> 解决问题，<mark>注意到预处理的内容是类高维前缀最值的形式，可以递推降低复杂度</mark>。</p>\n<details>\n<pre data-line=\"26-28\" class=\"cpp language-cpp\"><code data-line=\"26-28\" class=\"cpp language-cpp\">#include &lt;bits/stdc++.h>\nconst int inf = 0x3f3f3f3f;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(\".in\", \"r\", stdin);\n    std::freopen(\".out\", \"w\", stdout);\n#endif\n    int n;\n    std::string t;\n    std::cin >> t, n = (int)t.length(), t = \"#\" + t;\n    std::vector&lt;int> a, tag(26, -1), s(n + 1);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        if (tag[t[i] - 'a'] == -1)\n            tag[t[i] - 'a'] = (int)a.size(), a.push_back(t[i] - 'a');\n        s[i] = tag[t[i] - 'a'];\n    &#125;\n    int m = (int)a.size(), siz = 1 &lt;&lt; m;\n    std::vector&lt;std::vector&lt;int> > cnt(m, std::vector&lt;int> (m));\n    for (int i = 1; i &lt; n; ++i)\n        ++cnt[s[i]][s[i + 1]];\n    std::vector&lt;std::vector&lt;int> > g(m, std::vector&lt;int> (siz));\n    for (int i = 0; i &lt; m; ++i)\n        for (int k = 0; k &lt; m; ++k) // 注意这里相当于是钦定从 k 处转移\n            for (int j = (1 &lt;&lt; k); j &lt; (2 &lt;&lt; k); ++j) // 枚举的是 k 位为 1 的所有数；这两层循环的复杂度为 O(siz)\n                g[i][j] = g[i][j ^ (1 &lt;&lt; k)] + cnt[i][k]; // 目的是此处的内存连续访问优化，把 ^ 看作 - 应该就能理解为什么第二维是连续的\n    std::vector&lt;int> f(siz, inf);\n    f[0] = 1;\n    for (int i = 1; i &lt; siz; ++i)\n        for (int j = 0; j &lt; m; ++j)\n            if ((i >> j) & 1)\n                f[i] = std::min(f[i], f[i ^ (1 &lt;&lt; j)] + g[j][i]);\n    std::cout &lt;&lt; f[siz - 1] &lt;&lt; '\\n';\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"d---min-max-subarrays-p\">D - Min Max Subarrays P</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P11845\" class=\"uri\">https://www.luogu.com.cn/problem/P11845</a></p>\n<p>先考虑 <span class=\"math inline\">\\(01\\)</span> 序列的答案：如果序列中存在相邻的 <span class=\"math inline\">\\(2\\)</span> 个 <span class=\"math inline\">\\(1\\)</span>，总能保证最后的一个是 <span class=\"math inline\">\\(1\\)</span>。</p>\n<p>如果序列中存在 <span class=\"math inline\">\\(\\ge 3\\)</span> 个 <span class=\"math inline\">\\(1\\)</span>，可以牺牲其中的一些使得 <span class=\"math inline\">\\(2\\)</span> 个 <span class=\"math inline\">\\(1\\)</span> 相邻。</p>\n<p>当序列中只有 <span class=\"math inline\">\\(2\\)</span> 个 <span class=\"math inline\">\\(1\\)</span> 时，只有因为剩下的 <span class=\"math inline\">\\(0\\)</span> 不太够，导致我们无法随意『上下其手』时不能将 <span class=\"math inline\">\\(2\\)</span> 个 <span class=\"math inline\">\\(1\\)</span> 挪到一起。</p>\n<p>令两个 <span class=\"math inline\">\\(1\\)</span> 为序列最大值与次大值，暴搜处理序列长度较小的情况，剩下的直接用奇偶性判断两个 <span class=\"math inline\">\\(1\\)</span> 取哪个。</p>\n<hr />\n<h2 id=\"a---mst-on-line\">A - MST on Line++</h2>\n<p><a href=\"https://atcoder.jp/contests/arc167/tasks/arc167_c\" class=\"uri\">https://atcoder.jp/contests/arc167/tasks/arc167_c</a></p>\n<p>相当于把 <span class=\"math inline\">\\(a\\)</span> 打乱然后处理原问题。考虑每个 <span class=\"math inline\">\\(a_i\\)</span> 的贡献次数。模拟 Kruskal 连边，从小到大把点 <span class=\"math inline\">\\(a_i\\)</span> 加入图，<span class=\"math inline\">\\(a_i\\)</span> 可以向 <span class=\"math inline\">\\(a_{[i-K,i+K]}\\)</span> 内所有连通块连边。</p>\n<p>连通块数量当且仅当 <span class=\"math inline\">\\([i-K,i)\\)</span> 内最靠右的点和 <span class=\"math inline\">\\((i, i+K]\\)</span> 内最靠左的点距离 <span class=\"math inline\">\\(&gt;K\\)</span> 时为 <span class=\"math inline\">\\(2\\)</span>，其余情况为 <span class=\"math inline\">\\(1\\)</span>。</p>\n<p>但要是从这个角度想这个题就不太好做了。正确的想法应该是<mark>拆分为『若 <span class=\"math inline\">\\([i-K,i)\\)</span> 中有点，贡献次数 <span class=\"math inline\">\\(+1\\)</span>』和『若 <span class=\"math inline\">\\((i,i+K]\\)</span> 中有点 <span class=\"math inline\">\\(j\\)</span> 满足 <span class=\"math inline\">\\([j-K,j)\\)</span> 中无点，贡献次数 <span class=\"math inline\">\\(+1\\)</span>』</mark>。对于第一个问题，贡献次数将前 <span class=\"math inline\">\\(i-1\\)</span> 大的数分配至少一个到 <span class=\"math inline\">\\([i-K,i)\\)</span> 中的方案数；对于第二个问题，枚举 <span class=\"math inline\">\\(j\\)</span>，贡献次数为将前 <span class=\"math inline\">\\(i-1\\)</span> 大的数分配到 <span class=\"math inline\">\\(j\\)</span> 和 <span class=\"math inline\">\\([1,j-K)\\cup (j, n]\\)</span> 中的方案数。</p>\n<details>\n<p>实现的时候千万注意循环变量枚举的是位置还是值！不然你会调得很痛苦。</p>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 998244353;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;03-max-01.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, k;\n    std::cin &gt;&gt; n &gt;&gt; k;\n    std::vector&lt;int&gt; a(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i];\n    std::sort(a.begin() + 1, a.end());\n    std::vector&lt;long long&gt; fac(n + 1), inv(n + 1);\n    fac[0] = inv[0] = 1ll;\n    for (int i = 1; i &lt;= n; ++i)\n        fac[i] = fac[i - 1] * i % mod;\n    auto qkp = [](long long x, int y) &#123;\n        auto res(1ll);\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    inv[n] = qkp(fac[n], mod - 2);\n    for (int i = n - 1; i; --i)\n        inv[i] = inv[i + 1] * (i + 1) % mod;\n    auto A = [&amp;](int n, int m) &#123;\n        if (n &lt; m)\n            return 0ll;\n        return fac[n] * inv[n - m] % mod;\n    &#125;;\n    auto C = [&amp;](int n, int m) &#123;\n        return A(n, m) * inv[m] % mod;\n    &#125;;\n    long long res = 0ll;\n    for (int i = 2; i &lt;= n; ++i) &#123;\n        for (int j = 1; j &lt;= n; ++j)\n            (res += a[i] * (fac[n - 1] + mod - A(n - 1 - (j - std::max(1, j - k)), i - 1) * fac[n - i] % mod) % mod) %= mod;\n        for (int j = 2; j &lt;= n; ++j)\n            (res += a[i] * C(i - 1, i - 2) % mod * C(j - std::max(1, j - k), 1) % mod * A(n - (j - std::max(1, j - k) + 1), i - 2) % mod * fac[n - i] % mod) %= mod;\n    &#125;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"b---existence-counting\">B - Existence Counting</h2>\n<p><a href=\"https://atcoder.jp/contests/arc174/tasks/arc174_e\" class=\"uri\">https://atcoder.jp/contests/arc174/tasks/arc174_e</a></p>\n<p>发现可以分类讨论。假设 <span class=\"math inline\">\\(a&#39;\\)</span> 中第一个异于 <span class=\"math inline\">\\(a\\)</span> 的位置为 <span class=\"math inline\">\\(i\\)</span>，<span class=\"math inline\">\\(x\\)</span> 在 <span class=\"math inline\">\\(a\\)</span> 中位置为 <span class=\"math inline\">\\(pos_x\\)</span>（不存在则 <span class=\"math inline\">\\(pos_x=k+1\\)</span>）。令 <span class=\"math inline\">\\(f_i\\)</span> 为若 <span class=\"math inline\">\\(1\\sim i-1\\)</span> 均相同，<span class=\"math inline\">\\(i\\)</span> 位置可选的选项数。则 <span class=\"math inline\">\\(x\\)</span> 出现的次数：</p>\n<table>\n<colgroup>\n<col style=\"width: 25%\" />\n<col style=\"width: 25%\" />\n<col style=\"width: 25%\" />\n<col style=\"width: 25%\" />\n</colgroup>\n<thead>\n<tr class=\"header\">\n<th style=\"text-align: center;\"></th>\n<th style=\"text-align: center;\"><span class=\"math inline\">\\(pos_x&lt;i\\)</span></th>\n<th style=\"text-align: center;\"><span class=\"math inline\">\\(pos_x=i\\)</span></th>\n<th style=\"text-align: center;\"><span class=\"math inline\">\\(pos_x&gt;i,i&lt;k\\)</span></th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td style=\"text-align: center;\"><span class=\"math inline\">\\(x\\le a_i\\)</span></td>\n<td style=\"text-align: center;\"><span class=\"math inline\">\\(1+f_i\\cdot A_{n-i}^{k-i}\\)</span></td>\n<td style=\"text-align: center;\"><span class=\"math inline\">\\(f_i\\cdot C_{k-i}^1\\cdot A_{n-i-1}^{k-i-1}\\)</span></td>\n<td style=\"text-align: center;\"><span class=\"math inline\">\\((f_i-1)\\cdot C_{k-i}^1\\cdot A_{n-i-1}^{k-i-1}+A_{n-i}^{k-i}\\)</span></td>\n</tr>\n<tr class=\"even\">\n<td style=\"text-align: center;\"><span class=\"math inline\">\\(x&gt;a_i\\)</span></td>\n<td style=\"text-align: center;\"><span class=\"math inline\">\\(f_i\\cdot A_{n-i}^{k-i}\\)</span></td>\n<td style=\"text-align: center;\"><span class=\"math inline\">\\(0\\)</span></td>\n<td style=\"text-align: center;\"><span class=\"math inline\">\\(f_i\\cdot C_{k-i}^1\\cdot A_{n-i-1}^{k-i-1}\\)</span></td>\n</tr>\n</tbody>\n</table>\n<p>故，对于任意 <span class=\"math inline\">\\(x\\)</span>，答案为：</p>\n<p><span class=\"math display\">\\[\n\\begin{aligned}\n&amp;1+\\left(\\sum_{i=pos_x+1}^k f_i\\cdot A_{n-i}^{k-i}\\right)\n+\\sum_{i=1}^{pos_x} (f_i-[x&lt; a_i])\\cdot C_{k-i}^1\\cdot A_{n-i-1}^{k-i-1}+[x&lt; a_i]\\cdot A_{n-i}^{k-i}\\\\\n=&amp;1+\\left(\\sum_{i=pos_x+1}^k f_i\\cdot A_{n-i}^{k-i}\\right)\n+\\left(\\sum_{i=1}^{pos_x} f_i\\cdot C_{k-i}^1\\cdot A_{n-i-1}^{k-i-1}\\right)+\\sum_{i=1,a_i&gt; x}^{pos_x}A_{n-i}^{k-i}-C_{k-i}^1\\cdot A_{n-i-1}^{k-i-1}\\\\\n\\end{aligned}\n\\]</span></p>\n<p>预处理出 <span class=\"math inline\">\\(f_i=\\sum\\limits_{j=i+1}^k [a_j&lt; a_i]\\)</span>（需要数据结构）、<span class=\"math inline\">\\(g_i=\\sum\\limits_{j=1}^i f_j\\cdot A_{n-j}^{k-j}\\)</span> 和 <span class=\"math inline\">\\(h_j=\\sum\\limits_{j=1}^i f_i\\cdot C_{k-i}^1\\cdot A_{n-i-1}^{k-i-1}\\)</span>，再用数据结构计算 <span class=\"math inline\">\\(\\sum\\limits_{i=1,a_i&gt;x}^{pos_x}C_{k-i}^1\\cdot A_{n-i-1}^{k-i-1} - A_{n-i}^{k-i}\\)</span> 即可。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 998244353;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, k;\n    std::cin &gt;&gt; n &gt;&gt; k;\n    std::vector&lt;int&gt; a(k + 1), p(n + 1, k + 1);\n    for (int i = 1; i &lt;= k; ++i)\n        std::cin &gt;&gt; a[i], p[a[i]] = i;\n    std::vector&lt;long long&gt; fac(n + 1), inv(n + 1);\n    &#123;\n        fac[0] = inv[0] = 1ll;\n        for (int i = 1; i &lt;= n; ++i)\n            fac[i] = fac[i - 1] * i % mod;\n        auto qkp = [](long long x, int y) &#123;\n            auto res(1ll);\n            for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n                if (y &amp; 1)\n                    (res *= x) %= mod;\n            return res;\n        &#125;;\n        inv[n] = qkp(fac[n], mod - 2);\n        for (int i = n - 1; i; --i)\n            inv[i] = inv[i + 1] * (i + 1) % mod;\n    &#125;\n    auto A = [&amp;](int n, int m) &#123;\n        if (n &lt; m || m &lt; 0)\n            return 0ll;\n        return fac[n] * inv[n - m] % mod;\n    &#125;;\n    std::vector&lt;long long&gt; f(k + 1), g(k + 1), h(k + 1);\n    std::vector&lt;long long&gt; bit(n + 1);\n    auto lowbit = [](int x) &#123;\n        return x &amp; -x;\n    &#125;;\n    auto add = [&amp;](int x, int v) &#123;\n        for (; x &lt;= n; x += lowbit(x))\n            (bit[x] += v) %= mod;\n        return;\n    &#125;;\n    auto ask = [&amp;](int x) &#123;\n        auto res(0ll);\n        for (; x; x -= lowbit(x))\n            (res += bit[x]) %= mod;\n        return res;\n    &#125;;\n    for (int i = 1; i &lt;= n; ++i)\n        if (p[i] == k + 1)\n            add(i, 1);\n    for (int i = k; i; --i)\n        f[i] = ask(a[i]), add(a[i], 1);\n    for (int i = 1; i &lt;= k; ++i) &#123;\n        g[i] = (g[i - 1] + f[i] * A(n - i, k - i)) % mod;\n        h[i] = (h[i - 1] + f[i] * (k - i) % mod * A(n - i - 1, k - i - 1)) % mod;\n        // printf(&quot;%d: f = %lld, g = %lld, h = %lld\\n&quot;, i, f[i], g[i], h[i]);\n    &#125;\n    std::vector&lt;long long&gt; res(n + 1);\n    bit.assign(n + 1, 0ll);\n    auto s(0ll);\n    for (int i = 1; i &lt;= k; ++i) &#123;\n        // printf(&quot;%d: %lld + %lld + %lld\\n&quot;, a[i], 1 + g[k] - g[i], h[i], s - ask(a[i]));\n        res[a[i]] = (1 + g[k] - g[i] + h[i] + (s - ask(a[i]))) % mod;\n        res[a[i]] = (res[a[i]] + mod) % mod;\n        (s += A(n - i, k - i) - (k - i) * A(n - i - 1, k - i - 1)) %= mod;\n        add(a[i], (A(n - i, k - i) - (k - i) * A(n - i - 1, k - i - 1)) % mod);\n    &#125;\n    for (int i = 1; i &lt;= n; ++i)\n        if (p[i] == k + 1) &#123;\n            res[i] = (h[k] + (s - ask(i))) % mod;\n            res[i] = (res[i] + mod) % mod;\n        &#125;\n    for (int x = 1; x &lt;= n; ++x)\n        std::cout &lt;&lt; res[x] &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"c---1-loop-bubble-sort\">C - 1 Loop Bubble Sort</h2>\n<p><a href=\"https://atcoder.jp/contests/arc187/tasks/arc187_c\" class=\"uri\">https://atcoder.jp/contests/arc187/tasks/arc187_c</a></p>\n<p>首先是被考烂了的：对序列进行一次冒泡排序，等价于将序列在前缀最大值处分段，并将其从段首移到段尾；且满足排序前为前缀最大值的元素，排序后仍为前缀最大值。</p>\n<p>考虑用 DP 解决问题。注意状态要从 <span class=\"math inline\">\\(P\\)</span> 的角度出发——假如 <span class=\"math inline\">\\(Q\\)</span> 中不存在 <span class=\"math inline\">\\(-1\\)</span>，发现也需要 DP。此时再设计有关 <span class=\"math inline\">\\(Q\\)</span> 的状态就很扯淡了，考虑令 <span class=\"math inline\">\\(f_{i,j}\\)</span> 表示 <span class=\"math inline\">\\(P\\)</span> 中直到第 <span class=\"math inline\">\\(i\\)</span> 位的前缀最大值为 <span class=\"math inline\">\\(j\\)</span> 的方案数。为什么把前缀最大值作为状态呢？因为它可以表示分段；同时限制段间数的取值。具体地，考虑转移：</p>\n<ol type=\"1\">\n<li>若令 <span class=\"math inline\">\\(P_i=j\\)</span>，则在 <span class=\"math inline\">\\(i\\)</span> 处分段。对应到 <span class=\"math inline\">\\(Q\\)</span> 中，<span class=\"math inline\">\\(i-1\\)</span> 位是上一个前缀最大值，那么这要求 <span class=\"math inline\">\\(Q_{i-1}&lt;j\\)</span>，且 <span class=\"math inline\">\\(Q_{i-1}\\)</span> 是一个前缀最大值。也即：当 <span class=\"math inline\">\\(Q_{i-1}\\ne -1\\)</span> 时，<span class=\"math inline\">\\(f_{i,j}\\gets f_{i-1, Q_{i-1}}\\)</span>；否则，<span class=\"math inline\">\\(f_{i,j}\\gets \\sum\\limits_{k&lt;j} f_{i-1,k}\\)</span>。其中，二式都要求转移来源为前缀最大值。</li>\n<li>若令 <span class=\"math inline\">\\(P_i&lt;j\\)</span>，则 <span class=\"math inline\">\\(i\\)</span> 在 <span class=\"math inline\">\\(Q\\)</span> 中恰好前移一位，即 <span class=\"math inline\">\\(Q_{i-1}=P_i&lt;j\\)</span>。则当 <span class=\"math inline\">\\(Q_{i-1}\\ne -1\\)</span> 时，该位确定，<span class=\"math inline\">\\(f_{i,j}\\gets f_{i-1,j}\\)</span>；否则，<span class=\"math inline\">\\(Q_{i-1}\\)</span> 可选的值为 <span class=\"math inline\">\\(&lt;j\\)</span> 的所有未选数（定值，可预处理）。</li>\n</ol>\n<p>关于初值，可以在 <span class=\"math inline\">\\(P\\)</span> 前加一个 <span class=\"math inline\">\\(0\\)</span> 作为排列的一部分（那么按照冒泡排序的规则 <span class=\"math inline\">\\(Q\\)</span> 的第一位也一定是 <span class=\"math inline\">\\(0\\)</span>）来处理就好了。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 998244353;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;int&gt; q(n + 1), t(n + 1), c(n + 1), pos(n + 1);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; q[i], c[i] = c[i - 1];\n        if (q[i] == -1)\n            ++c[i];\n        else\n            pos[q[i]] = i;\n    &#125;\n    for (int i = 1; i &lt; n; ++i) &#123;\n        // printf(&quot;t[%d] = %d\\n&quot;, i, t[i]);\n        if (!pos[i])\n            for (int j = i + 1; j &lt;= n; ++j)\n                ++t[j];\n    &#125;\n    std::vector&lt;std::vector&lt;long long&gt; &gt; f(n + 1, std::vector&lt;long long&gt; (n + 1)), s(n + 1, std::vector&lt;long long&gt; (n + 1));\n    f[0][0] = 1ll;\n    s[0].assign(n + 1, 1ll);\n    for (int i = 1; i &lt;= n; ++i)\n        for (int j = 1; j &lt;= n; ++j) &#123;\n            if (q[i - 1] == -1)\n                f[i][j] = (s[i - 1][j - 1] + f[i - 1][j] * std::max(0, 1 + t[j] - c[i - 1])) % mod;\n            else if (q[i - 1] &lt; j)\n                f[i][j] = (f[i - 1][q[i - 1]] + f[i - 1][j]) % mod;\n            s[i][j] = s[i][j - 1];\n            if (q[i] == j || !pos[j]) // 满足前缀最大值\n                (s[i][j] += f[i][j]) %= mod;\n            // printf(&quot;f[%d][%d] = %lld\\n&quot;, i, j, f[i][j]);\n        &#125;\n    std::cout &lt;&lt; f[n][n] &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"f---1.-intro\">(F - 1). Intro</h2>\n<blockquote>\n<p>给定一个大小为 <span class=\"math inline\">\\(n\\)</span> 的树，点有点权。给定 <span class=\"math inline\">\\(q\\)</span> 次操作，分为两种：</p>\n<ol type=\"1\">\n<li><code>1 x</code>：查询 <span class=\"math inline\">\\(x\\)</span> 的点权。</li>\n<li><code>2 x d v</code> 对于所有距 <span class=\"math inline\">\\(x\\)</span> 不超过 <span class=\"math inline\">\\(d\\)</span> 的点，将它们的权值加上 <span class=\"math inline\">\\(v\\)</span>。</li>\n</ol>\n<p><span class=\"math inline\">\\(n,q\\le 10^5,d\\le 20\\)</span>。</p>\n</blockquote>\n<p>由于 <span class=\"math inline\">\\(d\\)</span> 很小，我们可能需要枚举与 <span class=\"math inline\">\\(x\\)</span> 距离 <span class=\"math inline\">\\(0\\sim d\\)</span> 的点进行修改；那么对距离 <span class=\"math inline\">\\(x\\)</span> 为 <span class=\"math inline\">\\(i\\)</span> 的点的更改存储在 <span class=\"math inline\">\\(f_{x,i}\\)</span>，查询 <span class=\"math inline\">\\(v\\)</span> 时就可以从 <span class=\"math inline\">\\(\\sum\\limits_i f_{fa(v,i),i}\\)</span> 求得答案。</p>\n<p>考虑修改。记 <span class=\"math inline\">\\(S_{x,d}\\)</span> 为距 <span class=\"math inline\">\\(x\\)</span> 为 <span class=\"math inline\">\\(d\\)</span> 的点集。<span class=\"math inline\">\\(x\\)</span> 子树内是好处理的，但子树外的呢？发现 <span class=\"math inline\">\\(S_{fa,d-1}\\)</span> 中 <span class=\"math inline\">\\(x\\)</span> 子树外的点，就是 <span class=\"math inline\">\\(fa\\)</span> 子树下、<span class=\"math inline\">\\(x\\)</span> 子树外距离 <span class=\"math inline\">\\(x\\)</span> 为 <span class=\"math inline\">\\(d\\)</span> 的所有点。</p>\n<p>由于所有 <span class=\"math inline\">\\(S_{fa(x,i),d-i}\\)</span> 无交，这可能满足我们每个待操作点被不重不漏加一次的要求。考虑将所有 <span class=\"math inline\">\\(S_{fa(x,i),d-i}\\)</span> 标记出来：</p>\n<figure>\n<img src=\"1.png\" alt=\"粉色虚线框是待操作点集\" /><figcaption>粉色虚线框是待操作点集</figcaption>\n</figure>\n<p>然后我们可以一眼发现被叉的点和未被叉的待操作点是交错的！这意味着我们只需要再补充上所有 <span class=\"math inline\">\\(S_{fa(x,i),d-i-1}\\)</span> 即可（显然它们之间、它们和所有 <span class=\"math inline\">\\(S_{fa(x,i),d-i}\\)</span> 之间都不交）。</p>\n<figure>\n<img src=\"2.png\" alt=\"虚线叉为 S_{fa(x,i),d-i-1}\" /><figcaption>虚线叉为 <span class=\"math inline\">\\(S_{fa(x,i),d-i-1}\\)</span></figcaption>\n</figure>\n<p>此时就可以不重不漏。当然，也会存在一些细节：比如说 <span class=\"math inline\">\\(fa(x,i)\\)</span> 不存在之类。只需要在根节点 <span class=\"math inline\">\\(1\\)</span> 处将剩余的 <span class=\"math inline\">\\(S_{1,i\\to 0}\\)</span> 全部更新即可。</p>\n<p>故每次修改操作只需要修改 <span class=\"math inline\">\\(O(d)\\)</span> 坨点。时间复杂度 <span class=\"math inline\">\\(O(qd)\\)</span>。</p>\n<hr />\n<h2 id=\"f.-distance-to-the-path\">F. Distance to the Path</h2>\n<p><a href=\"https://codeforces.com/problemset/problem/1749/F\" class=\"uri\">https://codeforces.com/problemset/problem/1749/F</a></p>\n<p>本例中将单点修改替换为路径修改；考虑树剖解决问题。</p>\n<p>对于路径上的所有点 <span class=\"math inline\">\\(u\\)</span>，容易发现只需要修改所有的 <span class=\"math inline\">\\(S_{u,d}\\)</span> 就可以完成对『<strong>一部分路径内侧的点</strong>』的修改。这『一部分』，是因为不包括距离 LCA <span class=\"math inline\">\\(\\le d\\)</span> 的点。</p>\n<p>而『<strong>另一部分路径内侧的点</strong>（距 LCA <span class=\"math inline\">\\(\\le d\\)</span>：见上一行说明）』及『<strong>路径外侧的点</strong>（距 LCA <span class=\"math inline\">\\(\\le d\\)</span>：因为路径在 LCA 子树内，LCA 能够到最远的外侧点）』，等价于『<strong>距 LCA <span class=\"math inline\">\\(\\le d\\)</span> 的点</strong>』，只需要把 LCA 代入上例中方式修改即可。</p>\n<p>修改路径上所有点 <span class=\"math inline\">\\(u\\)</span> 的 <span class=\"math inline\">\\(S_{u,d}\\)</span> 时，可以对所有 <span class=\"math inline\">\\(f_{*,i}\\)</span> 建立数据结构，由于只需要区间修改、单点查询，使用差分树状数组即可。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt; \nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, m;\n    std::cin &gt;&gt; n;\n    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);\n    for (int i = 1, x, y; i &lt; n; ++i) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y;\n        g[x].push_back(y), g[y].push_back(x);\n    &#125;\n    std::vector&lt;int&gt; siz(n + 1), dep(n + 1), fa(n + 1), son(n + 1);\n    std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int faa) &#123;\n        siz[x] = 1;\n        for (auto i : g[x])\n            if (i != faa) &#123;\n                fa[i] = x, dep[i] = dep[x] + 1;\n                DFS(i, x);\n                siz[x] += siz[i];\n                if (siz[i] &gt; siz[son[x]])\n                    son[x] = i;\n            &#125;\n        return;\n    &#125;;\n    DFS(1, -1);\n    std::vector&lt;int&gt; dfn(n + 1), top(n + 1);\n    DFS = [&amp;](int x, int toop) &#123;\n        static int now = 0;\n        dfn[x] = ++now, top[x] = toop;\n        if (son[x])\n            DFS(son[x], toop);\n        for (auto i : g[x])\n            if (i != fa[x] &amp;&amp; i != son[x])\n                DFS(i, i);\n        return;\n    &#125;;\n    DFS(1, 1);\n    std::vector&lt;std::vector&lt;long long&gt; &gt; bit(21, std::vector&lt;long long&gt; (n + 1));\n    auto lowbit = [&amp;](int x) &#123;\n        return x &amp; -x;\n    &#125;;\n    auto add = [&amp;](auto &amp;bit, int x, int v) &#123;\n        for (; x &lt;= n; x += lowbit(x))\n            bit[x] += v;\n        return;\n    &#125;;\n    auto ask = [&amp;](auto &amp;bit, int x) &#123;\n        auto res(0ll);\n        for (; x; x -= lowbit(x))\n            res += bit[x];\n        return res;\n    &#125;;\n    std::cin &gt;&gt; m;\n    for (int op; m--; ) &#123;\n        std::cin &gt;&gt; op;\n        if (op == 1) &#123;\n            int x;\n            std::cin &gt;&gt; x;\n            auto res(0ll);\n            for (int i = 0; i &lt;= 20 &amp;&amp; x; ++i, x = fa[x])\n                res += ask(bit[i], dfn[x]);\n            std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n        &#125;\n        else &#123;\n            int x, y, v, d;\n            std::cin &gt;&gt; x &gt;&gt; y &gt;&gt; v &gt;&gt; d;\n            for (; top[x] != top[y]; x = fa[top[x]]) &#123;\n                if (dep[top[x]] &lt; dep[top[y]])\n                    std::swap(x, y);\n                add(bit[d], dfn[top[x]], v);\n                add(bit[d], dfn[x] + 1, -v);\n            &#125;\n            if (dep[x] &gt; dep[y])\n                std::swap(x, y);\n            add(bit[d], dfn[x] + 1, v), add(bit[d], dfn[y] + 1, -v);\n            for (x = x, y = d; ~y &amp;&amp; x; x = fa[x], --y) &#123;\n                add(bit[y], dfn[x], v), add(bit[y], dfn[x] + 1, -v);\n                if (y &amp;&amp; fa[x])\n                    add(bit[y - 1], dfn[x], v), add(bit[y - 1], dfn[x] + 1, -v);\n            &#125;\n            if (x == 0)\n                for (; ~y; --y)\n                    add(bit[y], dfn[1], v), add(bit[y], dfn[1] + 1, -v);\n        &#125;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"a---ina-of-the-mountain\">A - Ina of the Mountain</h2>\n<p><a href=\"https://codeforces.com/problemset/problem/1852/C\" class=\"uri\">https://codeforces.com/problemset/problem/1852/C</a></p>\n<p>考虑这么一个简化版的问题：</p>\n<blockquote>\n<p>给定 <span class=\"math inline\">\\(\\{a_n\\}\\)</span>，每次可以进行区间 <span class=\"math inline\">\\(-1\\)</span>，问操作多少次才能将所有元素变为 <span class=\"math inline\">\\(0\\)</span>。</p>\n</blockquote>\n<p>会想到差分；对原数组进行差分，一次操作相当于令 <span class=\"math inline\">\\(d_l\\gets d_l-1\\)</span> 而 <span class=\"math inline\">\\(d_{r+1}\\gets d_{r+1}+1\\)</span>，最后要让 <span class=\"math inline\">\\(\\forall \\,d_i=0\\)</span>。那么答案就是差分数组中正数之和嘛。</p>\n<p>回到原问题。原问题等价于把上述问题变为：</p>\n<blockquote>\n<p>给定 <span class=\"math inline\">\\(\\{a_n\\}\\)</span>，每次可以进行区间 <span class=\"math inline\">\\(-1\\)</span>，每个数的总操作次数对 <span class=\"math inline\">\\(k\\)</span> 取模，问操作多少次才能将所有元素变为 <span class=\"math inline\">\\(0\\)</span>。</p>\n</blockquote>\n<p>怎么套回到刚刚的问题上呢？还原被取模掉的操作即可。具体来说，提前在 <span class=\"math inline\">\\(d\\)</span> 上进行若干次操作（记为操作 1），形如令 <span class=\"math inline\">\\(d_i\\gets d_i+k\\)</span>，同时 <span class=\"math inline\">\\(d_{i+1}\\gets d_{i+1}-k\\)</span>。</p>\n<p>会发现相邻的操作 <span class=\"math inline\">\\(1\\)</span> 对一个数加加减减影响判断；发现可以合并一段连续的操作 1，表现在 <span class=\"math inline\">\\(a\\)</span> 上也就是区间 <span class=\"math inline\">\\(+k\\)</span>。此时可以发现，一个位置上只会剩下若干次 <span class=\"math inline\">\\(+k\\)</span> 或若干次 <span class=\"math inline\">\\(-k\\)</span> （否则可以把 <span class=\"math inline\">\\(+k\\)</span> 和 <span class=\"math inline\">\\(-k\\)</span> 代表的不同操作合并），就不会有互相影响一说了。这也是有的题解说可以提前在 <span class=\"math inline\">\\(a\\)</span> 上区间 <span class=\"math inline\">\\(+k\\)</span> 的原因。</p>\n<p>此时问题变为在 <span class=\"math inline\">\\(d\\)</span> 进行任意次前加 <span class=\"math inline\">\\(k\\)</span> 后减 <span class=\"math inline\">\\(k\\)</span> 的操作，使得 <span class=\"math inline\">\\(\\sum\\limits_{d_i&gt;0}d_i\\)</span> 最大化。那么显然如果要使代价更小，只可能在原本 <span class=\"math inline\">\\(&lt;0\\)</span> 的位置做加法、<span class=\"math inline\">\\(&gt;0\\)</span> 的位置做减法（其他情况会发现一定不优）。考虑两个数 <span class=\"math inline\">\\(d_l,d_r\\)</span>，可以感受到对于一个 <span class=\"math inline\">\\(r\\)</span>，选最小的 <span class=\"math inline\">\\(d_l\\)</span> 是最优的，但什么时候应该选呢？</p>\n<ul>\n<li><span class=\"math inline\">\\(d_l\\le -k,d_r\\ge k\\)</span>：当然可选，<span class=\"math inline\">\\(k\\)</span> 被完全利用，答案减少 <span class=\"math inline\">\\(k\\)</span>。</li>\n<li><p><span class=\"math inline\">\\(d_l&gt;-k,d_r\\ge k\\)</span>：此时 <span class=\"math inline\">\\(k\\)</span> 未被完全利用，但必须选：选择其他更大的数，<span class=\"math inline\">\\(k\\)</span> 的利用率只会更低；如果不选，答案也无法减少。</p>\n<p>Q：此时是否需要尝试找到一个 <span class=\"math inline\">\\(l&#39;&lt;l\\)</span> 与 <span class=\"math inline\">\\(l\\)</span> 做操作，使得 <span class=\"math inline\">\\(l\\)</span> 重新变为负数呢？</p>\nA：否。因为你可以将这两次操作合并，发现相当于是直接对 <span class=\"math inline\">\\((l&#39;,r)\\)</span> 做操作，是更劣的。</li>\n<li><span class=\"math inline\">\\(d_l\\le -k,d_r&lt;k\\)</span>：此时 <span class=\"math inline\">\\(k\\)</span> 未被完全利用，<span class=\"math inline\">\\(d_r\\)</span> 成为负数。这意味着 <span class=\"math inline\">\\(d_r\\)</span> 将会成为某个 <span class=\"math inline\">\\(r&#39;\\)</span> 的可选项。考察 <span class=\"math inline\">\\(d_{r&#39;}\\)</span> 可用的最小值。如果 <span class=\"math inline\">\\(d_r\\)</span> 在当前不应该作为右端点，它就一定会被 <span class=\"math inline\">\\(d_{r&#39;}\\)</span> 选择。具体的有点抽象，但是你可以理解为 <span class=\"math inline\">\\(d_r\\)</span> 选了 <span class=\"math inline\">\\(d_l\\)</span> 的贡献是被整合到 <span class=\"math inline\">\\(d_r\\)</span> 里的；如果 <span class=\"math inline\">\\(d_r\\)</span> 被选了就说明 <span class=\"math inline\">\\(d_{r&#39;}\\)</span> 选 <span class=\"math inline\">\\(d_l\\)</span> 会拥有更大的优势。</li>\n<li><p><span class=\"math inline\">\\(d_l&gt;-k,d_r&lt;k\\)</span>：和上面的情况相似；但这种情况下答案可能反而变得更大，因为没有后效性，所以至少要保证单步最优。此时不能选。</p>\n<p>说到单步最优，就会发现这里就是反悔贪心；单步最优一定是全局最优，但更靠前的局部最优可能被否定掉。而『否定』的方法表现为一次操作。</p></li>\n</ul>\n<p>综上，从前往后扫，优先队列实时维护负数最小值，对于每个正数，check 选最小值是否优于当前答案，有就选。如果正数被减为负，加入队列。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int T;\n    for (std::cin &gt;&gt; T; T--; ) &#123;\n        int n, k;\n        std::cin &gt;&gt; n &gt;&gt; k;\n        std::vector&lt;int&gt; a(n + 1), d(n + 1);\n        long long res(0ll);\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            std::cin &gt;&gt; a[i], a[i] %= k;\n            d[i] = a[i] - a[i - 1];\n            if (d[i] &gt; 0)\n                (res += d[i]);\n        &#125;\n        std::priority_queue&lt;int&gt; q;\n        for (int i = 1; i &lt;= n; ++i)\n            if (d[i] &lt; 0)\n                q.push(-d[i]);\n            else &#123;\n                for (; !q.empty() &amp;&amp; d[i] &gt; 0; ) &#123;\n                    int x = -q.top(), y = d[i];\n                    auto t(res - y);\n                    x += k, y -= k;\n                    if (x &gt; 0)\n                        t += x;\n                    if (y &gt; 0)\n                        t += y;\n                    if (t &gt;= res)\n                        break;\n                    q.pop();\n                    res = t, d[i] = y;\n                    if (d[i] &lt; 0)\n                        q.push(-d[i]);\n                &#125;\n            &#125;\n        std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"b---miriany-and-matchstick\">B - Miriany and Matchstick</h2>\n<p><a href=\"https://codeforces.com/problemset/problem/1852/D\" class=\"uri\">https://codeforces.com/problemset/problem/1852/D</a></p>\n<p>从构造的角度出发，看到『恰好为 <span class=\"math inline\">\\(k\\)</span>』，会想到找到上界和下界并证明中间每一个数都能取到。</p>\n<p>但似乎很容易证伪：例如对于 <code>AAAA</code>，下界为 <span class=\"math inline\">\\(0\\)</span>，上界为 <span class=\"math inline\">\\(4\\)</span>，但有且仅有 <span class=\"math inline\">\\(1\\)</span> 取不到。但该想法并未破产——可以感受到这样的位置很少。进一步地，你 <a href=\"https://www.luogu.com.cn/article/2mmg5rjd\">可以证明只有一个这样的位置</a>，也可以 <a href=\"https://www.luogu.com.cn/article/679cwjgl\">大胆猜想这样的位置一定出现在 <span class=\"math inline\">\\(l+1\\)</span>，<span class=\"math inline\">\\(r-1\\)</span></a>。总之现在我们的状态就减少了（或者说状态变成 DP 值了）。预处理出这个东西之后大力搜索找方案即可。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int T;\n    for (std::cin &gt;&gt; T; T--; ) &#123;\n        int n, k;\n        std::cin &gt;&gt; n &gt;&gt; k;\n        std::vector&lt;int&gt; a(n + 1);\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            char t;\n            std::cin &gt;&gt; t, a[i] = (t == &#39;A&#39;);\n            if (i &gt;= 2)\n                k -= (a[i] ^ a[i - 1]);\n        &#125;\n        std::vector&lt;std::array&lt;std::tuple&lt;int, int, int&gt;, 2&gt; &gt; f(n + 1);\n        f[n][0] = &#123; a[n], a[n], 0 &#125;, f[n][1] = &#123; !a[n], !a[n], 0 &#125;;\n        auto merge = [&amp;](int i, int l0, int r0, int p0, int l1, int r1, int p1) &#123;\n            if (l0 &gt; l1)\n                std::swap(l0, l1), std::swap(r0, r1), std::swap(p0, p1);\n            int l = l0, r = std::max(r0, r1), p = 0;\n            if (!p0 &amp;&amp; !p1) &#123;\n                if (r0 &lt; l1 - 1)\n                    assert(r0 == l1 - 2), p = r0 + 1;\n                else;\n            &#125;\n            else if (p0 &amp;&amp; p1) &#123;\n                if (p0 == p1)\n                    p = p0;\n                else &#123;\n                    int tag0 = (l1 &lt;= p0 &amp;&amp; p0 &lt;= r1), tag1 = (l0 &lt;= p1 &amp;&amp; p1 &lt;= r0);\n                    if (!tag0 &amp;&amp; !tag1);\n                    else if (!tag0)\n                        p = p0;\n                    else if (!tag1)\n                        p = p1;\n                    else;\n                &#125;\n            &#125;\n            else if (p0) &#123;\n                if (l1 &lt;= p0 &amp;&amp; p0 &lt;= r1);\n                else\n                    p = p0;\n            &#125;\n            else &#123;\n                if (l0 &lt;= p1 &amp;&amp; p1 &lt;= r0);\n                else\n                    p = p1;\n            &#125;\n            assert(p != l &amp;&amp; p != r &amp;&amp; l &lt;= r);\n            return std::make_tuple(l, r, p);\n        &#125;;\n        for (int i = n - 1; i; --i) &#123;\n            &#123;\n                auto [l0, r0, p0] = f[i + 1][0];\n                auto [l1, r1, p1] = f[i + 1][1];\n                if (a[i]) &#123;\n                    ++l0, ++r0, ++l1, ++r1;\n                    if (p0) ++p0;\n                    if (p1) ++p1;\n                &#125;\n                ++l1, ++r1;\n                if (p1) ++p1;\n                f[i][0] = merge(i, l0, r0, p0, l1, r1, p1);\n            &#125;\n            &#123;\n                auto [l0, r0, p0] = f[i + 1][0];\n                auto [l1, r1, p1] = f[i + 1][1];\n                if (!a[i]) &#123;\n                    ++l0, ++r0, ++l1, ++r1;\n                    if (p0) ++p0;\n                    if (p1) ++p1;\n                &#125;\n                ++l0, ++r0;\n                if (p0) ++p0;\n                f[i][1] = merge(i, l0, r0, p0, l1, r1, p1);\n            &#125;\n        &#125;\n        std::vector&lt;int&gt; res(n + 1);\n        std::function&lt;bool(int, int, int)&gt; DFS = [&amp;](int x, int cnt, int la) &#123;\n            if (x == n + 1)\n                return cnt == k;\n            auto [l0, r0, p0] = f[x][0];\n            auto [l1, r1, p1] = f[x][1];\n            if (cnt + (la == 1) + l0 &lt;= k &amp;&amp; cnt + (la == 1) + r0 &gt;= k &amp;&amp; (!p0 || cnt + (la == 1) + p0 != k) &amp;&amp; DFS(x + 1, cnt + (la == 1) + a[x], 0))\n                res[x] = 0;\n            else if (cnt + !la + l1 &lt;= k &amp;&amp; cnt + !la + r1 &gt;= k &amp;&amp; (!p1 || cnt + !la + p1 != k) &amp;&amp; DFS(x + 1, cnt + !la + !a[x], 1))\n                res[x] = 1;\n            else\n                return false;\n            return true;\n        &#125;;\n        if (DFS(1, 0, -1)) &#123;\n            std::cout &lt;&lt; &quot;YES\\n&quot;;\n            for (int i = 1; i &lt;= n; ++i)\n                std::cout &lt;&lt; (res[i] ? &#39;A&#39; : &#39;B&#39;);\n            std::cout &lt;&lt; &#39;\\n&#39;;\n        &#125;\n        else\n            std::cout &lt;&lt; &quot;NO\\n&quot;;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n",
            "tags": [
                "DP",
                "容斥原理",
                "树链剖分",
                "反悔贪心"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20250419/",
            "url": "https://xsc062.netlify.app/20250419/",
            "title": "网格图路径计数",
            "date_published": "2025-04-19T02:03:57.000Z",
            "content_html": "<figure>\n<img src=\"/20250419/neko.jpeg\" alt=\"猫\" style=\"width: 75px\">\n<figcaption>\n猫\n</figcaption>\n</figure>\n<span id=\"more\"></span>\n<hr />\n<h2 id=\"点到点的方案数\">点到点的方案数</h2>\n<p>从 <span class=\"math inline\">\\((x_1,y_1)\\)</span> 只能向右、向下走到 <span class=\"math inline\">\\((x_2,y_2)\\)</span> 的方案数：<span class=\"math inline\">\\(C_{x_2-x_1+y_2-y_1}^{x_2-x_1}\\)</span>。就是说，因为必须向下走 <span class=\"math inline\">\\(x_2-x_1\\)</span> 步，又必须向右走 <span class=\"math inline\">\\(y_2-y_1\\)</span> 步；但顺序是可以任意打乱的。</p>\n<hr />\n<h3 id=\"a---gerald-and-giant-chess\">A - Gerald and Giant Chess</h3>\n<p><a href=\"https://codeforces.com/problemset/problem/560/E\" class=\"uri\">https://codeforces.com/problemset/problem/560/E</a></p>\n<p>把不能走的点按 <span class=\"math inline\">\\(x\\)</span> 为第一关键字，<span class=\"math inline\">\\(y\\)</span> 为第二关键字排序，就可以得到它们按大致拓扑序排列的结果。</p>\n<p>令 <span class=\"math inline\">\\(f_i\\)</span> 表示不经过 <span class=\"math inline\">\\(1\\sim i-1\\)</span> 的非法点走到第 <span class=\"math inline\">\\(i\\)</span> 个非法点的方案数，就可以得到 <span class=\"math inline\">\\(f_i=C_{x_i+y_i,x_i}-\\sum_{j=1}^{i-1} f_j\\times C_{x_i-x_j+y_i-y_j}^{x_i-x_j}\\)</span>。可以发现后面减去的方案，因为碰到的第一个非法点不同，所以是两两不同的。</p>\n<p>让 <span class=\"math inline\">\\((h,w)\\)</span> 成为第 <span class=\"math inline\">\\((n+1)\\)</span> 个非法点，<span class=\"math inline\">\\(f_{n+1}\\)</span> 就是答案。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 1e9 + 7;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int h, w, n;\n    std::cin &gt;&gt; h &gt;&gt; w &gt;&gt; n, --h, --w;\n    std::vector&lt;std::pair&lt;int, int&gt; &gt; a(n + 2);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; a[i].first &gt;&gt; a[i].second;\n        --a[i].first, --a[i].second;\n    &#125;\n    a[n + 1] = &#123; h, w &#125;;\n    std::sort(a.begin() + 1, a.end());\n    std::vector&lt;long long&gt; fac(h + w + 1), inv(h + w + 1);\n    fac[0] = inv[0] = 1ll;\n    for (int i = 1; i &lt;= h + w; ++i)\n        fac[i] = fac[i - 1] * i % mod;\n    auto qkp = [](long long x, int y) &#123;\n        auto res = 1ll;\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    inv[h + w] = qkp(fac[h + w], mod - 2);\n    for (int i = h + w - 1; i; --i)\n        inv[i] = inv[i + 1] * (i + 1) % mod;\n    auto C = [&amp;](int n, int m) &#123;\n        return fac[n] * inv[n - m] % mod * inv[m] % mod;\n    &#125;;\n    std::vector&lt;long long&gt; f(n + 2);\n    for (int i = 1; i &lt;= n + 1; ++i) &#123;\n        f[i] = C(a[i].first + a[i].second, a[i].first);\n        for (int j = 1; j &lt; i; ++j)\n            if (a[j].second &lt;= a[i].second)\n                (f[i] += mod - f[j] * C(a[i].first - a[j].first + a[i].second - a[j].second, a[i].first - a[j].first) % mod) %= mod;\n        // printf(&quot;f[(%d, %d)] = %lld\\n&quot;, a[i].first, a[i].second, f[i]);\n    &#125;\n    std::cout &lt;&lt; f[n + 1] &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"b---bbq-hard\">B - BBQ Hard</h3>\n<p><a href=\"https://atcoder.jp/contests/agc001/tasks/agc001_e\" class=\"uri\">https://atcoder.jp/contests/agc001/tasks/agc001_e</a></p>\n<p>不仅仅可以在关键点上 DP，也可以在网格上直接 DP。</p>\n<p><span class=\"math inline\">\\(A_i+B_i+A_j+B_j\\)</span> 就是 <span class=\"math inline\">\\(A_i+B_i-(-A_j)-(-B_j)\\)</span>。把棋盘扩大到 <span class=\"math inline\">\\(-2000\\to 2000\\)</span> 就可以了。</p>\n<p>设 <span class=\"math inline\">\\(f_{i,j}\\)</span> 表示可以到达 <span class=\"math inline\">\\((i,j)\\)</span> 的所有发出关键点 <span class=\"math inline\">\\((-A_j,-B_j)\\)</span> 带来的贡献，那么 <span class=\"math inline\">\\(f_{i,j}=f_{i-1,j}+f_{i,j-1}\\)</span>。枚举所有接收关键点 <span class=\"math inline\">\\((A_i,B_i)\\)</span>，<span class=\"math inline\">\\(\\sum f_{A_i,B_i}\\)</span> 就是答案的两倍，再减去对角线，也就是 <span class=\"math inline\">\\(\\sum (-A_i,B_i)\\to (A_i,B_i)\\)</span> 后的值。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int N = 2000;\nconst int mod = 1e9 + 7;\nconst int inv2 = 500000004;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;long long&gt; fac(4 * N + 1), inv(4 * N + 1);\n    fac[0] = inv[0] = 1ll;\n    for (int i = 1; i &lt;= 4 * N; ++i)\n        fac[i] = fac[i - 1] * i % mod;\n    auto qkp = [](long long x, int y) &#123;\n        auto res(1ll);\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    inv[4 * N] = qkp(fac[4 * N], mod - 2);\n    for (int i = 4 * N - 1; i; --i)\n        inv[i] = inv[i + 1] * (i + 1) % mod;\n    std::vector&lt;std::pair&lt;int, int&gt; &gt; a(n + 1);\n    std::vector&lt;std::vector&lt;long long&gt; &gt; f(2 * N + 1, std::vector&lt;long long&gt; (2 * N + 1));\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; a[i].first &gt;&gt; a[i].second;\n        ++f[N - a[i].first][N - a[i].second];\n    &#125;\n    for (int i = 0; i &lt;= 2 * N; ++i)\n        for (int j = 0; j &lt;= 2 * N; ++j) &#123;\n            if (i &gt;= 1)\n                (f[i][j] += f[i - 1][j]) %= mod;\n            if (j &gt;= 1)\n                (f[i][j] += f[i][j - 1]) %= mod;\n            // printf(&quot;f(%2d, %2d) = %lld\\n&quot;, i - N, j - N, f[i][j]);\n        &#125;\n    long long res = 0ll;\n    auto C = [&amp;](int n, int m) &#123;\n        return fac[n] * inv[n - m] % mod * inv[m] % mod;\n    &#125;;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        (res += f[a[i].first + N][a[i].second + N]) %= mod;\n        (res += mod - C(a[i].first * 2 + a[i].second * 2, 2 * a[i].first)) %= mod;\n    &#125;\n    std::cout &lt;&lt; res * inv2 % mod &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"c---iroha-and-a-grid\">C - Iroha and a Grid</h3>\n<p><a href=\"https://atcoder.jp/contests/arc058/tasks/arc058_b\" class=\"uri\">https://atcoder.jp/contests/arc058/tasks/arc058_b</a></p>\n<p>先把绿色部分的答案计算出来：</p>\n<figure>\n<img src=\"1.png\" alt=\"网格\" /><figcaption>网格</figcaption>\n</figure>\n<p>如果把绿色的每一个格子到终点的方案数求和，就会算重，因为上面的绿色点可以走到下面的绿色点。</p>\n<p>让绿色点第一步只能往右走到黄色点，用这样的方案为黄色点赋初值，再让黄色点自由走就可以得到答案了。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 1e9 + 7;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int h, w, a, b;\n    std::cin &gt;&gt; h &gt;&gt; w &gt;&gt; a &gt;&gt; b;\n    std::vector&lt;long long&gt; fac(h + w + 1), inv(h + w + 1);\n    fac[0] = inv[0] = 1ll;\n    for (int i = 1; i &lt;= h + w; ++i)\n        fac[i] = fac[i - 1] * i % mod;\n    auto qkp = [](long long x, int y) &#123;\n        auto res(1ll);\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    inv[h + w] = qkp(fac[h + w], mod - 2);\n    for (int i = h + w - 1; i; --i)\n        inv[i] = inv[i + 1] * (i + 1) % mod;\n    auto C = [&amp;](int n, int m) &#123;\n        return fac[n] * inv[n - m] % mod * inv[m] % mod;\n    &#125;;\n    auto res = 0ll;\n    for (int i = 1; i &lt;= h - a; ++i) &#123;\n        // (i, B)\n        auto f(C(i + b - 2, i - 1));\n        // printf(&quot;(%d, %d): %lld\\n&quot;, i, b, f);\n        // (i, B + 1)\n        (res += f * C(h - i + w - (b + 1), h - i) % mod) %= mod;\n    &#125;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"点到矩形的方案数\">点到矩形的方案数</h2>\n<p>从 <span class=\"math inline\">\\((x_0,y_0)\\)</span> 走到矩形 <span class=\"math inline\">\\((x_1,y_1,x_2,y_2)\\)</span> 的方案数：</p>\n<p><span class=\"math display\">\\[\n\\sum\\limits_{i\\in [x_1,x_2],j\\in [y_1,y_2]} G(x_0,y_0, i, j) = G(x_0,y_0,x_2 + 1,y_2 + 1)-G(x_0,y_0,x_2+1,y_1)-G(x_0,y_0,x_1,y_2+1)+G(x_0,y_0,x_1,y_1)\n\\]</span></p>\n<p>证明：<span class=\"math inline\">\\(G(x_0,y_0,x_2+1,y_2+1)=\\sum\\limits_i G(x_0,y_0,i,y_2)=\\sum\\limits_{i,j} G(x_0,y_0,i,j)\\)</span>，类似的，把后面几项展开，可以得到前缀和的结构。</p>\n<p>现在，矩形就可以被概括成 4 个点了。</p>\n<hr />\n<h2 id=\"矩形到矩形的方案数\">矩形到矩形的方案数</h2>\n<p>枚举第一个矩形里的所有点，那么就可以得到关于第二个矩形里四个点的表达式。反过来把第一个矩形概括为 4 个点就可以快速求解了。</p>\n<p>具体一点，第一个矩形 <span class=\"math inline\">\\((x_1,y_1,x_2,y_2)\\)</span> 可以被概括为 <span class=\"math inline\">\\((x_1-1,y_1-1)\\)</span>，<span class=\"math inline\">\\((x_1-1,y_2)\\)</span>，<span class=\"math inline\">\\((x_2,y_1-1)\\)</span>，<span class=\"math inline\">\\((x_2,y_2)\\)</span>。注意方向颠倒导致符号发生变化。此时对 <span class=\"math inline\">\\(4\\times 4=16\\)</span> 个 <span class=\"math inline\">\\(G\\)</span> 按对应的 <span class=\"math inline\">\\(-1/1\\)</span> 系数求和就能得到答案。</p>\n<hr />\n<h3 id=\"d---sightseeing-plan\">D - Sightseeing Plan</h3>\n<p><a href=\"https://atcoder.jp/contests/agc018/tasks/agc018_e\" class=\"uri\">https://atcoder.jp/contests/agc018/tasks/agc018_e</a></p>\n<ol type=\"1\">\n<li>恒等式：<span class=\"math inline\">\\(\\sum\\limits_{i\\in [x_1,x_2]}G_(x_1,y_1,i,y_2-1)=G(x_1,y_1,x_2,y_2)\\)</span>，放在网格图上就是强制走到 <span class=\"math inline\">\\((i,y_2-1)\\)</span>，再强制向右走一步，然后向上走到 <span class=\"math inline\">\\((x_2,y_2)\\)</span>。和上一题类似的，可以发现不重不漏。</li>\n<li>三个矩形，<span class=\"math inline\">\\(M_1\\)</span> 经过 <span class=\"math inline\">\\(M_2\\)</span> 到达 <span class=\"math inline\">\\(M_3\\)</span> 的路径数量：经过 <span class=\"math inline\">\\(M_2\\)</span> 时，根据限制，只可能从下面或左边进入。枚举进入的点 <span class=\"math inline\">\\((x_0,y_0)\\)</span>（数量为 <span class=\"math inline\">\\(O(n)\\)</span>），再计算 <span class=\"math inline\">\\(G(x_0,y_0,M_3)\\)</span> 就能得到不重不漏的答案。</li>\n<li>原问题：要求 <span class=\"math inline\">\\(M_2\\)</span> 内部路径上点的贡献和，这个其实就是 <span class=\"math inline\">\\(M_2\\)</span> 内部路径长度。若从 <span class=\"math inline\">\\((x_1,y_1)\\)</span> 进入，再从 <span class=\"math inline\">\\((x_2,y_2)\\)</span> 离开，长度就是 <span class=\"math inline\">\\(x_2-x_1+y_2-y_1+1\\)</span>。拆成 <span class=\"math inline\">\\((x_2+y_2+1)\\)</span> 和 <span class=\"math inline\">\\(-(x_1+y_1)\\)</span> 后发现一次进入和一次离开的贡献是独立的。分别枚举进入点和离开点计算贡献就可以了。</li>\n</ol>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int N = 2e6;\nconst int mod = 1e9 + 7;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int x1, x2, x3, x4, x5, x6, y1, y2, y3, y4, y5, y6;\n    std::cin &gt;&gt; x1 &gt;&gt; x2 &gt;&gt; x3 &gt;&gt; x4 &gt;&gt; x5 &gt;&gt; x6;\n    std::cin &gt;&gt; y1 &gt;&gt; y2 &gt;&gt; y3 &gt;&gt; y4 &gt;&gt; y5 &gt;&gt; y6;\n    std::vector&lt;long long&gt; fac(N + 1), inv(N + 1);\n    fac[0] = inv[0] = 1ll;\n    for (int i = 1; i &lt;= N; ++i)\n        fac[i] = fac[i - 1] * i % mod;\n    auto qkp = [](long long x, int y) &#123;\n        auto res(1ll);\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    inv[N] = qkp(fac[N], mod - 2);\n    for (int i = N - 1; i; --i)\n        inv[i] = inv[i + 1] * (i + 1) % mod;\n    auto C = [&amp;](int n, int m) &#123;\n        return fac[n] * inv[n - m] % mod * inv[m] % mod;\n    &#125;;\n    std::vector&lt;std::tuple&lt;int, int, int&gt; &gt; f(4), g(4);\n    f[0] = &#123; x1 - 1, y1 - 1, 1 &#125;, f[1] = &#123; x1 - 1, y2, mod - 1 &#125;, f[2] = &#123; x2, y1 - 1, mod - 1 &#125;, f[3] = &#123; x2, y2, 1 &#125;;\n    g[0] = &#123; x5, y5, 1 &#125;, g[1] = &#123; x5, y6 + 1, mod - 1 &#125;, g[2] = &#123; x6 + 1, y5, mod - 1 &#125;, g[3] = &#123; x6 + 1, y6 + 1, 1 &#125;; \n    auto G = [&amp;](int x1, int y1, int x2, int y2) &#123;\n        auto a(std::abs(x1 - x2)), b(std::abs(y1 - y2));\n        return C(a + b, a);\n    &#125;;\n    auto res = 0ll;\n    for (auto [x1, y1, k1] : f)\n        for (auto [x2, y2, k2] : g) &#123;\n            auto t(0ll);\n            for (int x = x3; x &lt;= x4; ++x) &#123;\n                (t += G(x1, y1, x, y4) * G(x, y4 + 1, x2, y2) % mod * (x + y4 + 1) % mod) %= mod;\n                (t += mod - G(x1, y1, x, y3 - 1) * G(x, y3, x2, y2) % mod * (x + y3) % mod) %= mod;\n            &#125;\n            for (int y = y3; y &lt;= y4; ++y) &#123;\n                (t += G(x1, y1, x4, y) * G(x4 + 1, y, x2, y2) % mod * (x4 + y + 1) % mod) %= mod;\n                (t += mod - G(x1, y1, x3 - 1, y) * G(x3, y, x2, y2) % mod * (x3 + y) % mod) %= mod;\n            &#125;\n            // printf(&quot;(%d, %d, %d), (%d, %d, %d): %lld\\n&quot;, x1, y1, k1, x2, y2, k2, t * k1 % mod * k2 % mod);\n            (res += t * k1 % mod * k2 % mod) %= mod;\n        &#125;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"不经过-yxc-的方案数\">不经过 <span class=\"math inline\">\\(y=x+c\\)</span> 的方案数</h2>\n<p>Catalan 数的一种推导方式是，在 <span class=\"math inline\">\\(n\\times n\\)</span> 的网格上，要求不能越过 <span class=\"math inline\">\\(y=x\\)</span> 的方案数。可以用总方案数减去越过的方案数。</p>\n<p>怎么计算非法的方案呢？越过 <span class=\"math inline\">\\(y=x\\)</span> 的路径必定存在一个点经过 <span class=\"math inline\">\\(y=x+1\\)</span>，原问题转化为不能碰到 <span class=\"math inline\">\\(y=x+1\\)</span> 的方案数。</p>\n<p>把终点 <span class=\"math inline\">\\((n, n)\\)</span> 翻折到 <span class=\"math inline\">\\(y=x+1\\)</span> 上方，得到 <span class=\"math inline\">\\((n-1, n + 1)\\)</span>；对于任意到达 <span class=\"math inline\">\\((n-1,n+1)\\)</span> 的路径，一定会接触 <span class=\"math inline\">\\(y=x+1\\)</span> 至少一次；将第一次接触以后的路径翻折到 <span class=\"math inline\">\\(y=x+1\\)</span> 下方，则一定和原图中的非法路径一一对应。</p>\n<p><img src=\"4.png\" /></p>\n<p>就可以得到 <span class=\"math inline\">\\(C_{2n}^n-C_{2n}^{n-1}\\)</span>。</p>\n<p>如果问题变得更加一般，求解到达 <span class=\"math inline\">\\((n, m)\\)</span> 不能碰到 <span class=\"math inline\">\\(y=x+c\\)</span> 的方案数，还是可以把 <span class=\"math inline\">\\((n,m)\\)</span> 翻折到 <span class=\"math inline\">\\((m-c,n+c)\\)</span>，答案是 <span class=\"math inline\">\\(C_{n+m}^n-C_{n+m}^{m-c}\\)</span>。</p>\n<hr />\n<h2 id=\"不经过-yx-l-和-yxr-的方案数\">不经过 <span class=\"math inline\">\\(y=x-l\\)</span> 和 <span class=\"math inline\">\\(y=x+r\\)</span> 的方案数</h2>\n<p>现在有 <span class=\"math inline\">\\(y=x-l\\)</span> 和 <span class=\"math inline\">\\(y=x+r\\)</span> 两条线作为限制，现在的翻折意义就会有一点改变。</p>\n<p><img src=\"5.png\" /></p>\n<p>比如图中的 <span class=\"math inline\">\\(A&#39;\\)</span>，是 <span class=\"math inline\">\\(A\\)</span> 沿着 <span class=\"math inline\">\\(y=x-l\\)</span> 翻折一次后的结果。还是按照之前的方式来理解，那么走到 <span class=\"math inline\">\\(A&#39;\\)</span> 的路径代表至少经过一次 <span class=\"math inline\">\\(y=x-l\\)</span> 的方案。<span class=\"math inline\">\\(A&#39;&#39;\\)</span> 是 <span class=\"math inline\">\\(A&#39;\\)</span> 沿着 <span class=\"math inline\">\\(y=x+r\\)</span> 翻折一次之后得到的结果，走到 <span class=\"math inline\">\\(A&#39;&#39;\\)</span> 的路径就代表至少先碰到一次 <span class=\"math inline\">\\(y=x-l\\)</span>，再碰到一次 <span class=\"math inline\">\\(y=x+r\\)</span> 的方案数。</p>\n<p>如果把相邻多次碰到 <span class=\"math inline\">\\(y=x-l\\)</span> 或 <span class=\"math inline\">\\(y=x+r\\)</span> 合并为一次，最终的非法路径就是 <code>LRLRLR...</code> 或者 <code>RLRLRL...</code> 的形式。因为可以计算的是「至少」的形式，用容斥原理得到，答案是 <span class=\"math inline\">\\(f_{\\varnothing}-(f_{\\texttt L} + f_{\\texttt R}) + (f_{\\texttt {LR}} + f_{\\texttt {RL}}) - \\cdots\\)</span>。对应计算每个翻折对应终点和答案就可以了。最后的答案是 <span class=\"math inline\">\\(C_{n+m}^n-C_{n+m}^{n+l}-C_{n+m}^{n + r}+C_{n+m}^{n+l-r}+C_{n+m}^{n+r-l}-\\cdots\\)</span>，可以简化成 <span class=\"math inline\">\\(\\sum\\limits_{k\\in \\mathbb{Z}} C_{n+m}^{n-k\\cdot (r-l)}-C_{n+m}^{n-k\\cdot (r-l)+r}\\)</span>。</p>\n<hr />\n<h3 id=\"e---骗我呢\">E - 骗我呢</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P3266\" class=\"uri\">https://www.luogu.com.cn/problem/P3266</a></p>\n<p>每行内部递增，而且选项只有 <span class=\"math inline\">\\([0,m]\\)</span>，那么每行就会刚好在 <span class=\"math inline\">\\([0,m]\\)</span> 里面跳过一个数。</p>\n<p>如果第 <span class=\"math inline\">\\(i\\)</span> 行跳过的数是 <span class=\"math inline\">\\(j\\)</span>，那么画一画图就可以发现第 <span class=\"math inline\">\\(i+1\\)</span> 可能跳过的数是 <span class=\"math inline\">\\([j-1,m]\\)</span>；反过来，第 <span class=\"math inline\">\\(i-1\\)</span> 行可能跳过的数就是 <span class=\"math inline\">\\([0,j+1]\\)</span>。</p>\n<p>如果让 <span class=\"math inline\">\\(f_{i,j}\\)</span> 表示确定了第 <span class=\"math inline\">\\(1\\to i\\)</span> 行，其中第 <span class=\"math inline\">\\(i\\)</span> 行跳过 <span class=\"math inline\">\\(j\\)</span> 的方案数，就可以得到 <span class=\"math inline\">\\(f_{i,j}=\\sum\\limits_{k=0}^{j+1} f_{i-1,k}\\)</span>。前缀和得到 <span class=\"math inline\">\\(f_{i,j}=f_{i,j-1}+f_{i-1,j+1}\\)</span>。注意边界：<span class=\"math inline\">\\(f_{0,j}=1\\)</span>；<span class=\"math inline\">\\(f_{i,0}=f_{i-1,0}+f_{i-1,1}\\)</span>；<span class=\"math inline\">\\(f_{i,m}=f_{i,m-1}\\)</span>。</p>\n<p>为了得到答案，让 <span class=\"math inline\">\\(g_{i,j}\\)</span> 表示 <span class=\"math inline\">\\(i\\times j\\)</span> 矩阵的方案数（这样就有机会通过手段优化了）：</p>\n<p><span class=\"math display\">\\[\n\\begin{aligned}\ng_{i,j}&amp;=\\sum_{k=0}^j f_{i,k}\\\\\n&amp;= f_{i-1,0}+f_{i-1,1}+\\sum_{k=1}^j f_{i,k-1}+f_{i-1,k+1}\\\\\n&amp;= g_{i,j-1}+g_{i-1,j+1}\n\\end{aligned}\n\\]</span></p>\n<p>边界情况呢， <span class=\"math inline\">\\(g_{i, 0} = f_{i,0} = f_{i-1, 0} + f_{i - 1, 1} = g_{i-1,1}\\)</span>；<span class=\"math inline\">\\(g_{i,m}=g_{i, m - 1} + f_{i,m}=g_{i-1,m}+g_{i,m-1}\\)</span>。 <span class=\"math inline\">\\(g_{i,m+1}=g_{i,m}\\)</span> 避免边界。</p>\n<p>那么在网格图上转移如下：</p>\n<p><img src=\"2.png\" /></p>\n<p>考虑将这个图形拉正，令 <span class=\"math inline\">\\((i+i,j)\\gets g_{i,j}\\)</span> 得到：</p>\n<p><img src=\"3.png\" /></p>\n<p>问题就转化为，从 <span class=\"math inline\">\\((0, 0)\\)</span> 走到 <span class=\"math inline\">\\((m+n+1,n)\\)</span> 且不能触碰 <span class=\"math inline\">\\(y=x+1\\)</span> 和 <span class=\"math inline\">\\(y=x-m-2\\)</span> 两条直线的方案数。</p>\n<details>\n</details>\n<hr />\n<h2 id=\"不经过一般过原点直线的方案数\">不经过一般过原点直线的方案数</h2>\n<ol type=\"1\">\n<li><p>类型一：<span class=\"math inline\">\\((0,0)\\to (n,m)\\)</span>，不经过 <span class=\"math inline\">\\(y=\\dfrac mnx\\)</span> 的方案，其中要求 <span class=\"math inline\">\\((m,n)=1\\)</span>。</p>\n<p>方案为 <span class=\"math inline\">\\(\\dfrac {C_{n+m}^n}{n+m}\\)</span>。</p></li>\n</ol>\n",
            "tags": [
                "排列组合",
                "容斥原理",
                "数学"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20250407/",
            "url": "https://xsc062.netlify.app/20250407/",
            "title": "组合计数",
            "date_published": "2025-04-07T06:57:14.000Z",
            "content_html": "<p>毅毅：统计不是数学（断章取义 ed）。<del>故删掉了数学标签。</del> 其实并没有。</p>\n<span id=\"more\"></span>\n<hr />\n<h2 id=\"a.-二分图染色\">A. 二分图染色</h2>\n<p><a href=\"http://222.180.160.110:61235/contest/6181/problem/1\" class=\"uri\">http://222.180.160.110:61235/contest/6181/problem/1</a></p>\n<p>首先只看红色。显然一个左部点最多只能用红边连接一个右部点，反之同理。把左部点视为下标，其用红边相连的右部点视为值，则一个合法的方案为 <span class=\"math inline\">\\(n\\)</span> 的只保留一部分元素的排列。显然为 <span class=\"math inline\">\\(f(n)=\\sum\\limits_{i=0}^nC_n^i\\cdot A_n^i\\)</span>。</p>\n<p>再加上蓝色，<span class=\"math inline\">\\(f^2(n)\\)</span> 会给一条边涂两种颜色，故钦定有两种颜色的边数，容斥得到 <span class=\"math inline\">\\(\\sum\\limits_{i=0}^n(-1)^i\\cdot C_n^i\\cdot A_n^i\\cdot f^2(n-i)\\)</span>。发现 <span class=\"math inline\">\\(f\\)</span> 的计算可能需要优化一下。考虑已经知道 <span class=\"math inline\">\\(f(n-1)\\)</span>，此时对于新增的第 <span class=\"math inline\">\\(n\\)</span> 对点：</p>\n<ol type=\"1\">\n<li>任意连边（显然两个当中只能有一个点发出边），共有 <span class=\"math inline\">\\(2n-1\\)</span> 种方案，因为 <span class=\"math inline\">\\((n, n)\\)</span> 会被算重。</li>\n<li>不连，共 <span class=\"math inline\">\\(1\\)</span> 种方案。</li>\n<li>发现 1 中可能连到已经有连边的点上了，新边的目的地有 <span class=\"math inline\">\\(n-1\\)</span> 个选项，目的地原本连接的点也有 <span class=\"math inline\">\\(n-1\\)</span> 个选项，去掉两边共 <span class=\"math inline\">\\(4\\)</span> 个点，非法的即为 <span class=\"math inline\">\\((n-1)^2\\cdot f(n-2)\\)</span>。</li>\n</ol>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 1e9 + 7;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;long long&gt; f(n + 1), fac(n + 1), inv(n + 1);\n    f[0] = 1ll, f[1] = 2ll;\n    fac[0] = 1ll, fac[1] = 1ll, inv[0] = 1ll;\n    for (int i = 2; i &lt;= n; ++i) &#123;\n        fac[i] = fac[i - 1] * i % mod;\n        f[i] = (f[i - 1] * 2 * i % mod + mod - f[i - 2] * (i - 1) % mod * (i - 1) % mod) % mod;\n    &#125;\n    auto qkp = [](long long x, int y) &#123;\n        auto res = 1ll;\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    inv[n] = qkp(fac[n], mod - 2);\n    for (int i = n - 1; i; --i)\n        inv[i] = inv[i + 1] * (i + 1) % mod;\n    auto C = [&amp;](int n, int m) &#123;\n        return fac[n] * inv[n - m] % mod * inv[m] % mod;\n    &#125;;\n    auto A = [&amp;](int n, int m) &#123;\n        return fac[n] * inv[n - m] % mod;\n    &#125;;\n    long long res = 0ll;\n    for (int i = 0, k = 1; i &lt;= n; ++i, k = mod - k)\n        (res += k * C(n, i) % mod * A(n, i) % mod * f[n - i] % mod * f[n - i]) %= mod;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"b.-七选五\">B. 七选五</h2>\n<p><a href=\"http://222.180.160.110:61235/contest/6181/problem/2\" class=\"uri\">http://222.180.160.110:61235/contest/6181/problem/2</a></p>\n<p>首先 <span class=\"math inline\">\\(p\\)</span> 固定，钦定有 <span class=\"math inline\">\\(x\\)</span> 个数相等，有 <span class=\"math inline\">\\(C_k^x\\)</span> 个方案，剩下的就是从 <span class=\"math inline\">\\(n-x\\)</span> 个元素里选出 <span class=\"math inline\">\\(k-x\\)</span> 个来错排，考虑钦定相同的个数来容斥：</p>\n<p><span class=\"math display\">\\[\n\\sum_{i=0}^{k-x}(-1)^i\\cdot C_{k-x}^i\\cdot A_{n-x-i}^{k-x-i}\n\\]</span></p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 1e9 + 7;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, k, x;\n    std::cin &gt;&gt; n &gt;&gt; k &gt;&gt; x;\n    std::vector&lt;long long&gt; fac(n + 1), inv(n + 1);\n    fac[0] = 1ll, fac[1] = 1ll, inv[0] = 1ll;\n    for (int i = 2; i &lt;= n; ++i)\n        fac[i] = fac[i - 1] * i % mod;\n    auto qkp = [](long long x, int y) &#123;\n        auto res = 1ll;\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    inv[n] = qkp(fac[n], mod - 2);\n    for (int i = n - 1; i; --i)\n        inv[i] = inv[i + 1] * (i + 1) % mod;\n    auto C = [&amp;](int n, int m) &#123;\n        return fac[n] * inv[n - m] % mod * inv[m] % mod;\n    &#125;;\n    auto A = [&amp;](int n, int m) &#123;\n        return fac[n] * inv[n - m] % mod;\n    &#125;;\n    long long res = C(k, x), sum = 0ll;\n    for (int i = 0, p = 1; i &lt;= k - x; ++i, p = mod - p)\n        (sum += p * C(k - x, i) % mod * A(n - x - i, k - x - i) % mod) %= mod;\n    std::cout &lt;&lt; res * sum % mod &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"d.-硬币购物\">D. 硬币购物</h2>\n<p><a href=\"http://222.180.160.110:61235/contest/6181/problem/4\" class=\"uri\">http://222.180.160.110:61235/contest/6181/problem/4</a></p>\n<p>每次多重背包会超时，考虑用钦定每种硬币是否超额来容斥。令 <span class=\"math inline\">\\(f_s\\)</span> 表示凑出 <span class=\"math inline\">\\(s\\)</span> 的方案数（完全背包），那么 <span class=\"math inline\">\\(f_{s-c_1\\times (d_1 + 1)}\\)</span> 就表示钦定第 1 种硬币超额时凑出 <span class=\"math inline\">\\(s\\)</span> 的方案数，以此类推。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int c[4], T, m = 1e5;\n    std::vector&lt;long long&gt; f(m + 1);\n    f[0] = 1;\n    for (int i = 0; i &lt; 4; ++i) &#123;\n        std::cin &gt;&gt; c[i];\n        for (int j = c[i]; j &lt;= m; ++j)\n            f[j] += f[j - c[i]];\n    &#125;\n    std::cin &gt;&gt; T;\n    for (int d[4], m; T--; ) &#123;\n        for (int i = 0; i &lt; 4; ++i)\n            std::cin &gt;&gt; d[i];\n        std::cin &gt;&gt; m;\n        long long res = 0ll;\n        for (int i = 0; i &lt; (1 &lt;&lt; 4); ++i) &#123;\n            int s = m;\n            for (int j = 0; j &lt; 4; ++j)\n                if ((i &gt;&gt; j) &amp; 1)\n                    s -= (d[j] + 1) * c[j];\n            if (s &gt;= 0) &#123;\n                int k = (__builtin_popcount(i) &amp; 1) ? -1 : 1;\n                res += k * f[s];\n            &#125;\n        &#125;\n        std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"e.-distinct-multiples\">E. Distinct Multiples</h2>\n<p><a href=\"http://222.180.160.110:61235/contest/6181/problem/5\" class=\"uri\">http://222.180.160.110:61235/contest/6181/problem/5</a></p>\n<p>推式子题。题意转化为，给定 <span class=\"math inline\">\\(n\\)</span> 个位置可选的值集合，要求任意两个位置值不等，问方案数。</p>\n<p>如果把两个位置取等视作在团上选中边，那么有朴素做法钦定选边的集合 <span class=\"math inline\">\\(S\\)</span> 然后容斥，考虑它们构成的连通块 <span class=\"math inline\">\\(\\{s\\} \\subseteq S\\)</span>，有 <span class=\"math inline\">\\(res=\\sum\\limits_{S\\subseteq V}(-1)^{|S|}\\cdot \\prod\\limits_{s_i} \\left\\lfloor \\frac m{\\operatorname{lcm} s_i} \\right\\rfloor\\)</span>。</p>\n<p>有个很神奇的操作是把 <span class=\"math inline\">\\(S\\)</span> 丢掉，直接枚举 <span class=\"math inline\">\\(\\{s\\}\\)</span> 尝试子集 DP。有：<span class=\"math inline\">\\(res=\\sum\\limits_{\\{s\\}}\\prod\\limits_s f(s)\\cdot\\left\\lfloor \\frac m{\\operatorname{lcm} s} \\right\\rfloor\\)</span>。其中 <span class=\"math inline\">\\(f(s)\\)</span> 表示选取一个 <span class=\"math inline\">\\(s\\)</span> 的导出子图的容斥系数之和，其中次数为导出子图中边数。</p>\n<p>怎么把 <span class=\"math inline\">\\(f\\)</span> 算出来呢？容易发现其值只与 <span class=\"math inline\">\\(|s|\\)</span> 有关，考虑钦定与 <span class=\"math inline\">\\(1\\)</span> 连通的点数容斥，则有：</p>\n<p><span class=\"math display\">\\[\nf(n)=\\sum\\limits_{i=0}^{n - 1} (-1)^i \\times C_{n-1}^{i-1} \\times f(i) \\cdot \\sum_{j=0}^{m\\gets i\\times (i-1)\\div 2} (-1)^j\\cdot C_m^j\n\\]</span></p>\n<p>我们知道，二项式定理取 <span class=\"math inline\">\\(a=1, b = -1\\)</span> 有 <span class=\"math inline\">\\(0^m=[m=0]=\\sum_{j=0}^m(-1)^j\\cdot C_m^j\\)</span>，代入得：</p>\n<p><span class=\"math display\">\\[\n\\begin{aligned}\nf(n)&amp;=\\sum\\limits_{i=0}^{n - 1} (-1)^i \\times C_{n-1}^{n-i-1} \\times f(n-i)\\cdot [m=0\\iff i=1]\\\\\n&amp;=(1 - n)\\cdot f(n-1)\n\\end{aligned}\n\\]</span></p>\n<p>然后就能线性求出。再用一个子集 DP，为了保证顺序枚举最小的未被确定的点所在连通块进行转移。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 998244353;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, l;\n    long long m;\n    std::cin &gt;&gt; n &gt;&gt; m, l = 1 &lt;&lt; n;\n    std::vector&lt;long long&gt; d(n), f(n + 1), dp(l), g(l);\n    f[1] = 1ll;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; d[i - 1];\n        if (i &gt;= 2)\n            f[i] = (1 + mod - i) * f[i - 1] % mod;\n        // printf(&quot;f[%d] = %lld\\n&quot;, i, f[i]);\n    &#125;\n    for (int i = 0; i &lt; l; ++i) &#123;\n        long long now = 1ll;\n        for (int j = 0; j &lt; n; ++j)\n            if ((i &gt;&gt; j) &amp; 1) &#123;\n                if (now / std::__gcd(now, d[j]) &gt; m / d[j])\n                    goto nosol;\n                now = now / std::__gcd(now, d[j]) * d[j];\n            &#125;\n        g[i] = (m / now) % mod;\n        // printf(&quot;lcm = %lld, g[%d] = %lld\\n&quot;, now, i, g[i]);\n    nosol: ;\n    &#125;\n    dp[0] = 1ll;\n    auto lowbit = [](int x) &#123;\n        return x &amp; -x;\n    &#125;;\n    for (int i = 1; i &lt; l; ++i) &#123;\n        int to = std::__lg(lowbit(i));\n        for (int j = i; j; j = (j - 1) &amp; i)\n            if ((j &gt;&gt; to) &amp; 1)\n                (dp[i] += dp[i ^ j] * f[__builtin_popcount(j)] % mod * g[j] % mod) %= mod;\n    &#125;\n    std::cout &lt;&lt; dp[l - 1] &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"f.-permutation\">F. Permutation</h2>\n<p><a href=\"http://222.180.160.110:61235/contest/6181/problem/6\" class=\"uri\">http://222.180.160.110:61235/contest/6181/problem/6</a></p>\n<p>如果全是 <code>&lt;</code>，方案数为 <span class=\"math inline\">\\(1\\)</span>。</p>\n<p>现在把其中一些 <code>&lt;</code> 变成 <code>?</code>，比如 <code>&lt;&lt;??&lt;?&lt;&lt;&lt;&lt;</code> 的方案数，<del>太好了是多重集排列，我们没救了</del> 显然被 <code>&lt;</code> 连接起来的一段元素只有一种排列方式，所以可以视为多重集排列，方案数为 <span class=\"math inline\">\\(\\dfrac {11!}{3!\\times 2!\\times 5!}\\)</span>。</p>\n<p>似乎只需要枚举把 <code>&gt;</code> 变成 <code>&lt;</code> 或 <code>=</code> 的 <span class=\"math inline\">\\(2^k\\)</span> 种情况再计算就可以了，可惜 <span class=\"math inline\">\\(k\\)</span> 有点大。但我们发现它在一定程度上是没有后效性的，比如 <code>&lt;&lt;??&lt;</code> 和 <code>&lt;&lt;?&lt;&lt;</code>，前面的 <code>&lt;&lt;</code> 不会对后面的内容带来影响。</p>\n<p>故令 <span class=\"math inline\">\\(f_i\\)</span> 表示对于前 <span class=\"math inline\">\\(i\\)</span> 个元素的方案数，枚举最后一个被钦定为 <code>?</code> 的 <code>&gt;</code> <span class=\"math inline\">\\(j\\)</span>（即 <span class=\"math inline\">\\([j + 1, i-1]\\)</span> 间的 <code>&gt;</code> 都被替换为 <code>&lt;</code>），带上容斥系数，有 <span class=\"math inline\">\\(f_i=\\sum\\limits_{s_j=\\texttt{&#39;&gt;&#39;}}(-1)^{cnt_\\texttt{&#39;&gt;&#39;}[j + 1, i - 1]}\\times f_j\\times\\dfrac1{(i-j)!}\\)</span>。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 1e9 + 7;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;long long&gt; fac(n + 1), inv(n + 1);\n    fac[0] = 1ll, inv[0] = 1ll;\n    for (int i = 1; i &lt;= n; ++i)\n        fac[i] = fac[i - 1] * i % mod;\n    auto qkp = [](long long x, int y) &#123;\n        auto res = 1ll;\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    inv[n] = qkp(fac[n], mod - 2);\n    for (int i = n - 1; i; --i)\n        inv[i] = inv[i + 1] * (i + 1) % mod;\n    std::vector&lt;char&gt; s(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; s[i];\n    std::vector&lt;long long&gt; f(n + 1);\n    s[0] = &#39;&gt;&#39;, f[0] = 1ll;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        int cnt = 0;\n        for (int j = i - 1; ~j; --j)\n            if (s[j] == &#39;&gt;&#39;) &#123;\n                long long k = (cnt &amp; 1) ? mod - 1 : 1;\n                (k *= f[j]) %= mod, (k *= inv[i - j]) %= mod;\n                (f[i] += k) %= mod;\n                ++cnt;\n            &#125;\n        // printf(&quot;f[%d] = %lld\\n&quot;, i, f[i]);\n    &#125;\n    std::cout &lt;&lt; f[n] * fac[n] % mod &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<p><em>忳郁邑余侘傺兮，余独穷困乎此时也。</em></p>\n<hr />\n<h2 id=\"h.-k-perm-counting\">H. ~K Perm Counting</h2>\n<p><a href=\"http://222.180.160.110:61235/contest/6181/problem/8\" class=\"uri\">http://222.180.160.110:61235/contest/6181/problem/8</a></p>\n<p>考虑钦定令几个元素不满足条件进行容斥，即答案为 <span class=\"math inline\">\\(\\sum\\limits_{i=0}^n (-1)^i\\cdot f(i)\\)</span>。但我们发现 <span class=\"math inline\">\\([n-k,n+k]\\)</span> 都有两个不能选的值，直接取 <span class=\"math inline\">\\(f(i)=\\prod 2\\)</span> 肯定会选到相同值，一个自然（？）的想法是再容斥一遍，可惜手玩一下发现似乎容不动。考虑把玩意儿拍在棋盘上：</p>\n<figure>\n<img src=\"1.png\" alt=\"以 k=2 为例\" /><figcaption>以 <span class=\"math inline\">\\(k=2\\)</span> 为例</figcaption>\n</figure>\n<p>其中 <span class=\"math inline\">\\(\\times\\)</span> 是非法格子，边是非法格子间的不同选关系，同颜色的边隶属同一条链。容易发现如果棋盘继续扩大，这些链还会继续延长。</p>\n<p>会发现这些链互不干扰，就是说我选了这条链上的某个点和链外的点没有任何关系（显然）。把这些链首尾相连拼起来，要做的就是拼接处可以选相邻，其余位置不能选相邻，选出来 <span class=\"math inline\">\\(i\\)</span> 个的方案数。提前预处理出来整个序列，令 <span class=\"math inline\">\\(tag_j\\)</span> 表示 <span class=\"math inline\">\\(j\\)</span> 是否能和 <span class=\"math inline\">\\(j-1\\)</span> 同选，设 <span class=\"math inline\">\\(dp_{j,i,0/1}\\)</span> 表示 DP 到了 <span class=\"math inline\">\\(j\\)</span>，已经选了 <span class=\"math inline\">\\(i\\)</span> 个数，第 <span class=\"math inline\">\\(j\\)</span> 个元素（不）选的方案数，那么有：</p>\n<p><span class=\"math display\">\\[\ndp_{j,i,0} = dp_{j - 1, i, 0} + dp_{j-1, i, 1}\\\\\ndp_{j,i,1} = \\begin{cases}\ndp_{j-1, i - 1, 1} + dp_{j-1,i - 1,0}&amp;tag_j=1\n\\\\\ndp_{j-1,i,0}&amp;\\text{otherwise}\n\\end{cases}\n\\]</span></p>\n<p>大力 DP 即可。<span class=\"math inline\">\\(f(i)\\)</span> 即为 <span class=\"math inline\">\\((n-i)!\\times (dp_{m, i, 0} + dp_{m, i, 1})\\)</span>，其中 <span class=\"math inline\">\\(m\\)</span> 为总链长。</p>\n<details>\n<p>注意不滚动可能会 MLE <img src=\"/em/kt.gif\" /></p>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 924844033;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, k;\n    std::cin &gt;&gt; n &gt;&gt; k;\n    std::vector&lt;int&gt; tag(1);\n    std::vector&lt;long long&gt; fac(n + 1);\n    std::vector&lt;std::vector&lt;int&gt; &gt; vis(n + 1, std::vector&lt;int&gt; (n + 1));\n    auto calc = [&amp;](int i, int j, int s) &#123;\n        tag.push_back(1);\n        for (; ; s ^= 1) &#123;\n            // printf(&quot;(%d, %d) &quot;, i, j);\n            vis[i][j] = 1;\n            if (!s) &#123;\n                i = j + k;\n                if (i &lt;= n)\n                    tag.push_back(0);\n                else\n                    break;\n            &#125;\n            else &#123;\n                j = i + k;\n                if (j &lt;= n)\n                    tag.push_back(0);\n                else\n                    break;\n            &#125;\n        &#125;\n        // puts(&quot;&quot;);\n        return;\n    &#125;;\n    fac[0] = 1ll;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        fac[i] = fac[i - 1] * i % mod;\n        int j = i - k;\n        if (j &gt;= 1 &amp;&amp; !vis[i][j])\n            calc(i, j, 1);\n        j = i + k;\n        if (j &lt;= n &amp;&amp; !vis[i][j])\n            calc(i, j, 0);\n    &#125;\n    int m = (int)tag.size() - 1;\n    // printf(&quot;m = %d\\n&quot;, m);\n    std::vector&lt;std::vector&lt;std::vector&lt;long long&gt; &gt; &gt; dp(2, std::vector&lt;std::vector&lt;long long&gt; &gt; (n + 1, std::vector&lt;long long&gt; (2)));\n    dp[0][0][0] = 1ll;\n    for (int j = 1, now = 1; j &lt;= m; ++j, now ^= 1) &#123;\n        for (int i = 0; i &lt;= n &amp;&amp; i &lt;= j; ++i) &#123;\n            dp[now][i][0] = dp[!now][i][0];\n            dp[now][i][1] = 0ll;\n            if (i) &#123;\n                (dp[now][i][0] += dp[!now][i][1]) %= mod;\n                dp[now][i][1] = dp[!now][i - 1][0];\n                if (tag[j]) &#123;\n                    (dp[now][i][1] += dp[!now][i - 1][1]) %= mod;\n                    // assert(0);\n                &#125;\n            &#125;\n            // printf(&quot;dp[%d][%d] = %lld / %lld\\n&quot;, j, i, dp[j][i][0], dp[j][i][1]);\n        &#125;\n    &#125;\n    long long res = 0ll;\n    for (int i = 0, p = 1; i &lt;= n; ++i, p = mod - p)\n        (res += p * fac[n - i] % mod * (dp[m &amp; 1][i][0] + dp[m &amp; 1][i][1]) % mod) %= mod;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"a---positions-in-permutations\">A - Positions in Permutations</h2>\n<p><a href=\"https://codeforces.com/problemset/problem/285/E\" class=\"uri\">https://codeforces.com/problemset/problem/285/E</a></p>\n<p><del>（看向上一题）这照片是你吗？</del></p>\n<p>在上一题的基础上，令 <span class=\"math inline\">\\(k=1\\)</span>。但是有个小小的问题——所求的「至少」不为 <span class=\"math inline\">\\(0\\)</span>，无法简单容斥。具体地，如果一个排列一共有 <span class=\"math inline\">\\(p\\)</span> 个非法排列，那么它会被 <span class=\"math inline\">\\(f(i)\\)</span> 统计 <span class=\"math inline\">\\(C_p^i\\)</span> 次。令 <span class=\"math inline\">\\(g(p)\\)</span> 表示非法格子数恰好为 <span class=\"math inline\">\\(p\\)</span> 的排列的真实数量，则 <span class=\"math inline\">\\(f(i)=\\sum\\limits_{j=i}^n C_j^i\\cdot g(j)\\)</span>，二项式反演即可得到真实值 <span class=\"math inline\">\\(g(m)=\\sum\\limits_{j=m}^n (-1)^{j-m}\\cdot C_j^m\\cdot f(j)\\)</span>。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 1e9 + 7;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, k;\n    std::cin &gt;&gt; n &gt;&gt; k;\n    std::vector&lt;int&gt; tag(1);\n    std::vector&lt;long long&gt; fac(n + 1), inv(n + 1);\n    std::vector&lt;std::vector&lt;int&gt; &gt; vis(n + 1, std::vector&lt;int&gt; (n + 1));\n    auto calc = [&amp;](int i, int j, int s) &#123;\n        tag.push_back(1);\n        for (; i &lt;= n &amp;&amp; j &lt;= n; s ^= 1) &#123;\n            vis[i][j] = 1;\n            if (!s) &#123;\n                i = j + 1;\n                if (i &lt;= n)\n                    tag.push_back(0);\n            &#125;\n            else &#123;\n                j = i + 1;\n                if (j &lt;= n)\n                    tag.push_back(0);\n            &#125;\n        &#125;\n        return;\n    &#125;;\n    auto qkp = [&amp;](long long x, int y) &#123;\n        auto res = 1ll;\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    fac[0] = 1ll, inv[0] = 1ll;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        fac[i] = fac[i - 1] * i % mod;\n        int j = i - 1;\n        if (j &gt;= 1 &amp;&amp; !vis[i][j])\n            calc(i, j, 1);\n        j = i + 1;\n        if (j &lt;= n &amp;&amp; !vis[i][j])\n            calc(i, j, 0);\n    &#125;\n    inv[n] = qkp(fac[n], mod - 2);\n    for (int i = n - 1; i; --i)\n        inv[i] = inv[i + 1] * (i + 1) % mod;\n    int m = (int)tag.size() - 1;\n    std::vector&lt;std::vector&lt;std::vector&lt;long long&gt; &gt; &gt; dp(2, std::vector&lt;std::vector&lt;long long&gt; &gt; (n + 1, std::vector&lt;long long&gt; (2)));\n    dp[0][0][0] = 1ll;\n    for (int j = 1, now = 1; j &lt;= m; ++j, now ^= 1) &#123;\n        for (int i = 0; i &lt;= n &amp;&amp; i &lt;= j; ++i) &#123;\n            dp[now][i][0] = dp[!now][i][0];\n            dp[now][i][1] = 0ll;\n            if (i) &#123;\n                (dp[now][i][0] += dp[!now][i][1]) %= mod;\n                dp[now][i][1] = dp[!now][i - 1][0];\n                if (tag[j])\n                    (dp[now][i][1] += dp[!now][i - 1][1]) %= mod;\n            &#125;\n        &#125;\n    &#125;\n    auto C = [&amp;](int n, int m) &#123;\n        return fac[n] * inv[n - m] % mod * inv[m] % mod;\n    &#125;;\n    long long res = 0ll;\n    for (int i = k, p = 1; i &lt;= n; ++i, p = mod - p) &#123;\n        // printf(&quot;%d: %lld\\n&quot;, i, C(i, k) * fac[n - i] % mod * (dp[m &amp; 1][i][0] + dp[m &amp; 1][i][1]) % mod);\n        (res += p * C(i, k) % mod * fac[n - i] % mod * (dp[m &amp; 1][i][0] + dp[m &amp; 1][i][1]) % mod) %= mod;\n    &#125;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"d---all-pairs-similarity-p\">D - All Pairs Similarity P</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P11458\" class=\"uri\">https://www.luogu.com.cn/problem/P11458</a></p>\n<p>省流：求 <span class=\"math inline\">\\(\\forall\\,i,f_i=\\sum\\limits_{j=1}^n \\dfrac{|a_i\\cap a_j|}{|a_i\\cup a_j|}\\)</span>。</p>\n<p>首先分离常数，有：</p>\n<p><span class=\"math display\">\\[\n\\begin{aligned}\nf_i&amp;=\\sum\\limits_{j=1}^n \\dfrac{|a_i\\cap a_j|}{|a_i\\cup a_j|}\\\\\n&amp;=\\sum_{j=1}^n\\dfrac {|a_i|+|a_j|-|a_i\\cup a_j|}{|a_i\\cup a_j|}\\\\\n&amp;=\\sum_{j=1}^n \\dfrac {|a_i|+|a_j|}{|a_i\\cup a_j|}-1\n\\end{aligned}\n\\]</span></p>\n<p>尽量把分子变得更简：</p>\n<p><span class=\"math display\">\\[\n\\begin{aligned}\nf_i&amp;=\\sum_{j=1}^n \\dfrac {|a_i|+|a_j|}{|a_i\\cup a_j|}-1\\\\\n&amp;=|a_i|\\cdot\\left(\\sum_{j=1}^n\\dfrac 1{|a_i\\cup a_j|}\\right)-n+\\sum_{j=1}^n \\dfrac {|a_j|}{|a_i\\cup a_j|}\n\\end{aligned}\n\\]</span></p>\n<p>问题转化为求解 <span class=\"math inline\">\\(\\sum\\limits_{j=1}^n\\dfrac 1{|a_i\\cup a_j|}\\)</span> 和 <span class=\"math inline\">\\(\\sum\\limits_{j=1}^n\\dfrac {|a_j|}{|a_i\\cup a_j|}\\)</span>，以 <span class=\"math inline\">\\(*=\\sum\\limits_{j=1}^n\\dfrac 1{|a_i\\cup a_j|}\\)</span> 为例。令 <span class=\"math inline\">\\(b_i\\)</span> 为 <span class=\"math inline\">\\(a_i\\)</span> 补集，则：</p>\n<p><span class=\"math display\">\\[\n\\begin{aligned}\n*&amp;=\\sum\\limits_{j=1}^n\\dfrac 1{|a_i\\cup a_j|}\\\\\n&amp;=\\sum_{j=1}^n\\dfrac 1{k-|b_i\\cap b_j|}\n\\end{aligned}\n\\]</span></p>\n<p>为什么要做这个转换呢？相比起并集运算，交集运算有着优秀的性质：<span class=\"math inline\">\\(s\\subseteq(b_i\\cap b_j)\\iff s\\subseteq b_i\\land s\\subseteq b_j\\)</span>，<del>直接取或当然也有相似的性质，但是太烧脑了</del>。</p>\n<p>基于这个性质，我们有一个想法：对于所有 <span class=\"math inline\">\\(j\\)</span>，在 <span class=\"math inline\">\\(\\forall \\, s\\subseteq b_j\\)</span> 处放置 <span class=\"math inline\">\\(\\dfrac 1{k-|s|}\\)</span> 的贡献；对于 <span class=\"math inline\">\\(i\\)</span>，将 <span class=\"math inline\">\\(\\forall \\, s\\subseteq b_i\\)</span> 处的贡献求和。但是这样肯定会拿到很多我们不想要的贡献，例如 <span class=\"math inline\">\\(\\forall \\, s\\subset (b_i\\cap b_j)\\)</span>。</p>\n<p>考虑精细布置贡献——构造 <span class=\"math inline\">\\(g(|s|)\\)</span> 满足 <span class=\"math inline\">\\(\\sum\\limits_{j=1}^n\\sum\\limits_{s\\subseteq b_j}g(|s|)=*\\)</span>。</p>\n<p>这里可以二项式反演得到 <span class=\"math inline\">\\(g\\)</span>，具体地，令 <span class=\"math inline\">\\(F(|S|)=\\dfrac 1{k-|S|}=\\sum\\limits_{s\\subseteq S}g(|s|)=\\sum\\limits_{j=0}^{|S|} C_{|S|}^j g(j)\\)</span>，则 <span class=\"math inline\">\\(g(i)=\\sum\\limits_{j=0}^iC_i^j\\cdot \\dfrac {(-1)^{i-j}}{k-j}\\)</span>。</p>\n<p>再令 <span class=\"math inline\">\\(h(s)=\\sum\\limits_{b_j\\supseteq s}g(|s|)=g(|s|)\\cdot \\sum\\limits_{b_j\\supseteq s}1\\)</span>，那么 <span class=\"math inline\">\\(h\\)</span> 就是高维后缀和。我们正在做的事情就是求解 <span class=\"math inline\">\\(*=\\sum\\limits_{s\\subseteq b_i}h(s)\\)</span>，这就又是一个高维前缀和了。</p>\n<p>对于 <span class=\"math inline\">\\(\\sum\\limits_{j=1}^n\\dfrac {|a_j|}{|a_i\\cup a_j|}\\)</span> 呢，令 <span class=\"math inline\">\\(h(s)=\\sum\\limits_{b_j\\supseteq s}g(|s|)\\cdot {\\color{red}{|a_j|}} = g(|s|) \\cdot \\sum\\limits_{b_j\\supseteq s} \\color{red}{k - |b_j|}\\)</span>，改变高维后缀和求和对象即可。</p>\n<p>复杂度就是 <span class=\"math inline\">\\(O(n+k\\cdot 2^k)\\)</span>，其中 <span class=\"math inline\">\\(k\\cdot 2^k\\)</span> 来自整体高维前 / 后缀和，<span class=\"math inline\">\\(n\\cdot k\\)</span> 来自枚举 <span class=\"math inline\">\\(i\\)</span>。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 1e9 + 7;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, k, l;\n    std::cin &gt;&gt; n &gt;&gt; k, l = 1 &lt;&lt; k;\n    std::vector&lt;int&gt; a(n + 1), b(n + 1), cnt(l);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; a[i], b[i] = (l - 1) ^ a[i];\n        ++cnt[b[i]];\n    &#125;\n    std::vector&lt;long long&gt; g(k + 1), fac(k + 1);\n    auto qkp = [&amp;](long long x, int y = mod - 2) &#123;\n        auto res = 1ll;\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    auto C = [&amp;](int n, int m) &#123;\n        return fac[n] * qkp(fac[n - m]) % mod * qkp(fac[m]) % mod;\n    &#125;;\n    fac[0] = 1ll;\n    for (int i = 1; i &lt;= k; ++i)\n        fac[i] = fac[i - 1] * i % mod;\n    for (int i = 0; i &lt;= k; ++i) &#123;\n        for (int j = 0, p = (i &amp; 1) ? mod - 1 : 1; j &lt;= i; ++j, p = mod - p)\n            (g[i] += C(i, j) * p % mod * qkp(k - j) % mod) %= mod;\n        // printf(&quot;g[%d] = %lld\\n&quot;, i, g[i]);\n    &#125;\n    // for (int i = 0; i &lt;= k; ++i) &#123;\n    //     long long F = 0ll;\n    //     for (int j = 0; j &lt;= i; ++j)\n    //         (F += C(i, j) * g[j] % mod) %= mod;\n    //     printf(&quot;%d: %lld / %lld\\n&quot;, i, F, qkp(k - i));\n    // &#125;\n    std::vector&lt;long long&gt; h(l);\n    std::copy(cnt.begin(), cnt.end(), h.begin());\n    for (int i = 0; i &lt; k; ++i)\n        for (int j = l - 1; ~j; --j)\n            if (!((j &gt;&gt; i) &amp; 1))\n                (h[j] += h[j ^ (1 &lt;&lt; i)]) %= mod;\n    auto f1(h);\n    for (int i = 0; i &lt; l; ++i)\n        (f1[i] *= g[__builtin_popcount(i)]) %= mod;\n    for (int i = 0; i &lt; k; ++i)\n        for (int j = 0; j &lt; l; ++j)\n            if ((j &gt;&gt; i) &amp; 1)\n                (f1[j] += f1[j ^ (1 &lt;&lt; i)]) %= mod;\n    for (int i = 0; i &lt; l; ++i)\n        h[i] = cnt[i] * (k - __builtin_popcount(i));\n    for (int i = 0; i &lt; k; ++i)\n        for (int j = l - 1; ~j; --j)\n            if (!((j &gt;&gt; i) &amp; 1))\n                (h[j] += h[j ^ (1 &lt;&lt; i)]) %= mod;\n    auto f2(h);\n    for (int i = 0; i &lt; l; ++i)\n        (f2[i] *= g[__builtin_popcount(i)]) %= mod;\n    for (int i = 0; i &lt; k; ++i)\n        for (int j = 0; j &lt; l; ++j)\n            if ((j &gt;&gt; i) &amp; 1)\n                (f2[j] += f2[j ^ (1 &lt;&lt; i)]) %= mod;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        // fprintf(stderr, &quot;%d: %d * %lld - %d + %lld\\n&quot;, i, __builtin_popcount(a[i]), f1[b[i]], n, f2[b[i]]);\n        std::cout &lt;&lt; (__builtin_popcount(a[i]) * f1[b[i]] % mod + mod - n + f2[b[i]]) % mod &lt;&lt; &#39;\\n&#39;;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"e---prefix-xors\">E - Prefix XORs</h2>\n<p><a href=\"https://atcoder.jp/contests/arc137/tasks/arc137_d\" class=\"uri\">https://atcoder.jp/contests/arc137/tasks/arc137_d</a></p>\n<p>省流：做 <span class=\"math inline\">\\(k\\)</span> 次前缀和，<span class=\"math inline\">\\(k=1,2,\\cdots,m\\)</span>，分别询问：令 <span class=\"math inline\">\\(x_i\\gets a_i\\)</span> 对 <span class=\"math inline\">\\(s_n\\)</span> 的贡献次数，则 <span class=\"math inline\">\\(\\sum a_i\\cdot (x_i\\bmod 2)\\)</span>？</p>\n<p>对于 <span class=\"math inline\">\\(a_p\\)</span>，容易发现第一轮其对任意 <span class=\"math inline\">\\(s_q\\)</span> 有 <span class=\"math inline\">\\(1\\)</span> 次贡献，拉开来就是常数列；第二轮有 <span class=\"math inline\">\\((q-p+1)\\)</span> 次贡献，是公差为 <span class=\"math inline\">\\(1\\)</span> 的等差数列；第三轮是类三角形数——至此，肯定和组合数有关了。手玩可以发现第 <span class=\"math inline\">\\(k\\)</span> 轮 <span class=\"math inline\">\\(a_p\\)</span> 对 <span class=\"math inline\">\\(s_n\\)</span> 的贡献为 <span class=\"math inline\">\\(C_{n-p+(k-2)}^{n-p}\\)</span>，尽量令其中一个不动，得到 <span class=\"math inline\">\\(C_{n-p+(k-2)}^{k-1}\\)</span>。</p>\n<p>但是我们发现直接枚举每轮每个数会起飞，而且模数为 <span class=\"math inline\">\\(2\\)</span> 似乎只能 Lucas（再带个 <span class=\"math inline\">\\(\\log\\)</span>），怎么办呢？</p>\n<p>那就 Lucas 呗。由其观察容易发现 <span class=\"math inline\">\\(C_{n-p+(k-2)}^{k-2}\\bmod2=1\\)</span> 当且仅当 <span class=\"math inline\">\\((k-2)\\subseteq (n-p+k-2)\\iff (k-2)\\subseteq \\complement_U(n-p)\\)</span>，故问题转化为高维后缀和，<del>当然你也可以做一次 and-FWT</del>，那么 <span class=\"math inline\">\\(res_k=\\sum (C_{n-p+(k-2)}^{k-2}\\bmod 2)\\cdot a_p=S_{k-2}\\)</span>，其中 <span class=\"math inline\">\\(S\\)</span> 为高维后缀和，初值为 <span class=\"math inline\">\\(S_{\\complement_u(n-i)}\\gets a_i\\)</span>。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, m, l, k;\n    std::cin &gt;&gt; n &gt;&gt; m, k = std::__lg(n + m) + 1, l = 1 &lt;&lt; k;\n    std::vector&lt;int&gt; s(l);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; s[l - 1 - (n - i)];\n    for (int i = 0; i &lt; k; ++i)\n        for (int j = l - 1; ~j; --j)\n            if (!((j &gt;&gt; i) &amp; 1))\n                s[j] ^= s[j ^ (1 &lt;&lt; i)];\n    for (int i = 1; i &lt;= m; ++i)\n        std::cout &lt;&lt; s[i - 1] &lt;&lt; &#39; &#39;;\n    std::cout &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"b---the-top-scorer\">B - The Top Scorer</h2>\n<p><a href=\"https://codeforces.com/problemset/problem/1096/E\" class=\"uri\">https://codeforces.com/problemset/problem/1096/E</a></p>\n<p>鉴于每种方案等概率（翻译没说，但原题面有提到），考虑计算小明能够取胜的方案数，再对总方案数做除法。先枚举最高分 <span class=\"math inline\">\\(k\\ge r\\)</span>，再枚举包括小明在内恰有 <span class=\"math inline\">\\(c\\ge 1\\)</span> 个人 拿到 <span class=\"math inline\">\\(k\\)</span> 分。但剩下的人呢？显然是不能插板随机分配的，因为存在 <span class=\"math inline\">\\(&lt;k\\)</span> 的限制。</p>\n<p>考虑容斥，钦定剩下的 <span class=\"math inline\">\\(p-c\\)</span> 个人中拿到 <span class=\"math inline\">\\(\\ge k\\)</span> 分的人数后再可空地插板即可，则总方案数为：</p>\n<p><span class=\"math display\">\\[\n\\sum_{k=r}^s\\sum_{c=1}^p\\dfrac {C_{p - 1}^{c-1}}c\\cdot \\sum_{i=0}^{p-c}C_{p-c}^i\\cdot C_{s-k\\cdot (c+i)+(p-c-1)}^{p-c-1}\n\\]</span></p>\n<p>其中分母上的 <span class=\"math inline\">\\(c\\)</span> 来源于等概率分配给最高分，虽然不是整数，但也代表着「小明获胜可行方案数」。最后将答案除上总方案数 <span class=\"math inline\">\\(C_{s-r+p-1}^{p-1}\\)</span> 即可。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 998244353;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int p, s, r;\n    std::cin &gt;&gt; p &gt;&gt; s &gt;&gt; r;\n    std::vector&lt;long long&gt; fac(s + p), inv(s + p);\n    fac[0] = inv[0] = 1ll;\n    for (int i = 1; i &lt; s + p; ++i) &#123;\n        fac[i] = fac[i - 1] * i % mod;\n    &#125;\n    auto qkp = [&amp;](long long x, int y) &#123;\n        auto res = 1ll;\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    inv.back() = qkp(fac.back(), mod - 2);\n    for (int i = s + p - 2; i &gt; 0; --i)\n        inv[i] = inv[i + 1] * (i + 1) % mod;\n    auto C = [&amp;](int n, int m) &#123;\n        if (n == -1 &amp;&amp; m == -1)\n            return 1ll;\n        return fac[n] * inv[n - m] % mod * inv[m] % mod;\n    &#125;;\n    auto res(0ll);\n    for (int k = r; k &lt;= s; ++k)\n        for (int c = 1; c &lt;= p; ++c)\n            if ((p - c) * (k - 1) + c * k &gt;= s) &#123;\n                auto t(0ll);\n                for (int i = 0, now = 1; i &lt;= p - c &amp;&amp; k * (c + i) &lt;= s; ++i, now = mod - now)\n                    (t += now * C(p - c, i) % mod * C(s - k * (c + i) + (p - c - 1), p - c - 1) % mod) %= mod;\n                (res += C(p - 1, c - 1) * qkp(c, mod - 2) % mod * t % mod) %= mod;\n            &#125;\n    std::cout &lt;&lt; res * qkp(C(s - r + p - 1, p - 1), mod - 2) % mod &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"c---sky-full-of-stars\">C - Sky Full of Stars</h2>\n<p><a href=\"https://codeforces.com/problemset/problem/997/C\" class=\"uri\">https://codeforces.com/problemset/problem/997/C</a></p>\n<p>发现用 <span class=\"math inline\">\\(3^{n\\times n}\\)</span> 减去任意一行一列不同色的方案就是答案。</p>\n<p>考虑一元容斥，如令 <span class=\"math inline\">\\(f_i\\)</span> 表示至少 <span class=\"math inline\">\\(i\\)</span> 行 <span class=\"math inline\">\\(i\\)</span> 列同色的方案，但会发现 <span class=\"math inline\">\\(f_0\\)</span> 中包含 <span class=\"math inline\">\\(0\\)</span> 行 <span class=\"math inline\">\\(1\\)</span> 列同色等与预期不符的情况。受此启发考虑令 <span class=\"math inline\">\\(f_{i,j}\\)</span> 表示至少 <span class=\"math inline\">\\(i\\)</span> 行 <span class=\"math inline\">\\(j\\)</span> 列同色进行二元容斥。容易发现当 <span class=\"math inline\">\\(i\\times j\\ne 0\\)</span> 时，被选中的 <span class=\"math inline\">\\(i\\)</span> 行 <span class=\"math inline\">\\(j\\)</span> 列全部连通，应为同一种颜色；将它们挪到角落，可以发现未被选中的格子共有 <span class=\"math inline\">\\((n-i)\\times (n-j)\\)</span> 个。故有：</p>\n<p><span class=\"math display\">\\[\nf_{i,j}=\\begin{cases}\nC_n^j\\times 3^j\\times 3^{n\\times(n - j)}&amp;i=0\\\\\nC_n^i\\times 3^i\\times 3^{n\\times(n-i)}&amp;j=0\\\\\nC_n^i\\times C_n^j\\times 3\\times 3^{(n-i)\\times (n-j)}&amp;\\text{otherwise}\n\\end{cases}\n\\]</span></p>\n<p>令 <span class=\"math inline\">\\(g_{i,j}\\)</span> 表示恰好 <span class=\"math inline\">\\(i\\)</span> 行 <span class=\"math inline\">\\(j\\)</span> 列同色的方案数，那么答案为 <span class=\"math inline\">\\(3^{n\\times n}-g_{0,0}\\)</span>。二项式反演 / 容斥原理得 <span class=\"math inline\">\\(g_{0,0}=\\sum\\limits_{i=0}^n\\sum\\limits_{j=0}^n (-1)^{i+j}\\cdot f_{i,j}\\)</span>。很惊讶地发现这是 <span class=\"math inline\">\\(O(n^2)\\)</span> 的！考虑优化。把 <span class=\"math inline\">\\(f_{1\\to n,1\\to n}\\)</span> 合并同类项，得到：</p>\n<p><span class=\"math display\">\\[\n\\begin{aligned}\ng_{0, 0}\n&amp;=\\left[\\sum_{j=0}^n (-1)^j\\cdot f_{0,j}\\right]+\\sum_{i=1}^n (-1)^i\\cdot f_{i,0}+\\sum_{j=1}^n (-1)^{i+j}\\cdot C_n^i\\times C_n^j\\times 3^{(n-i)\\times (n-j)+1}\\\\\n&amp;=\\left[\\sum_{j=0}^n (-1)^j\\cdot f_{0,j}\\right]+\\sum_{i=1}^n (-1)^i\\cdot f_{i,0}+(-1)^i\\cdot C_n^i\\times 3^{n^2-n\\times i+1}\\times\\sum_{j=1}^n (-1)^j\\cdot C_n^j\\times 3^{j\\times(-n+i)}\\\\\n&amp;=\\left[\\sum_{j=0}^n (-1)^j\\cdot f_{0,j}\\right]+\\sum_{i=1}^n (-1)^i\\cdot f_{i,0}+(-1)^i\\cdot C_n^i\\times 3^{n^2-n\\times i+1}\\times\\left[\\left(\\sum_{j=0}^n (-1)^j\\cdot C_n^j\\times (3^{-n+i})^j\\right)-1\\right]\\\\\n&amp;=\\left[\\sum_{j=0}^n (-1)^j\\cdot f_{0,j}\\right]+\\sum_{i=1}^n (-1)^i\\cdot f_{i,0}+(-1)^i\\cdot C_n^i\\times 3^{n^2-n\\times i+1}\\times\\left[(-3^{-n+i}+1)^n-1\\right]\n\\end{aligned}\n\\]</span></p>\n<p>由此便可 <span class=\"math inline\">\\(O(n\\log n)\\)</span> 计算。担心超时可以把所有 <span class=\"math inline\">\\(3^{-n+i}\\)</span> 和 <span class=\"math inline\">\\(3^{n\\times i}\\)</span> 线性预处理出来，复杂度不会变就是了。</p>\n<p>这里解释一下最后一步的二项式定理，非常遗憾地发现 <span class=\"math inline\">\\(-1\\)</span> 和 <span class=\"math inline\">\\(3^{-n+i}\\)</span> 都是 <span class=\"math inline\">\\(j\\)</span> 次的，没办法把二者相加减做二项式定理；但由于次数相同，这提示我们可以把 <span class=\"math inline\">\\(-1\\)</span> 乘到 <span class=\"math inline\">\\(3^{-n+i}\\)</span> 里去，给每一项配上 <span class=\"math inline\">\\(1^{n-k}\\)</span> 就可以做 <span class=\"math inline\">\\(-3^{n-i}\\)</span>（注意不是 <span class=\"math inline\">\\((-3)^{n-i}\\)</span>） 和 <span class=\"math inline\">\\(1\\)</span> 的二项式定理。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 998244353;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    long long n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;long long&gt; fac(n + 1), inv(n + 1), invn(n + 1), invi(n + 1), powi(n + 1), pown(n + 1);\n    auto qkp = [&amp;](long long x, long long y) &#123;\n        auto res(1ll);\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    const long long pnn = qkp(3ll, n * n), pn = qkp(3ll, n);\n    fac[0] = inv[0] = invn[0] = invi[0] = powi[0] = pown[0] = 1ll;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        fac[i] = fac[i - 1] * i % mod;\n        powi[i] = powi[i - 1] * 3 % mod;\n        pown[i] = pown[i - 1] * pn % mod;\n    &#125;\n    inv[n] = qkp(fac[n], mod - 2);\n    invi[n] = qkp(powi[n], mod - 2);\n    invn[n] = qkp(pown[n], mod - 2);\n    for (int i = n - 1; i; --i) &#123;\n        inv[i] = inv[i + 1] * (i + 1) % mod;\n        invi[i] = invi[i + 1] * 3 % mod;\n        invn[i] = invn[i + 1] * pn % mod;\n    &#125;\n    auto C = [&amp;](int n, int m) &#123;\n        return fac[n] * inv[n - m] % mod * inv[m] % mod;\n    &#125;;\n    long long g = 0ll;\n    auto f = [&amp;](int i, int j) &#123; // make sure (!i || !j)\n        if (i == 0 &amp;&amp; j == 0)\n            return pnn;\n        else if (i == 0)\n            return C(n, j) * powi[j] % mod * pown[n - j] % mod;\n        return C(n, i) * powi[i] % mod * pown[n - i] % mod;\n    &#125;;\n    for (int j = 0, p = 1; j &lt;= n; ++j, p = mod - p)\n        (g += p * f(0, j)) %= mod;\n    for (int i = 1, p = mod - 1; i &lt;= n; ++i, p = mod - p)\n        (g += p * f(i, 0) % mod + p * C(n, i) % mod * pnn % mod * invn[i] % mod * 3 % mod * (qkp(mod - invi[n - i] + 1, n) + mod - 1) % mod) %= mod;\n    std::cout &lt;&lt; (pnn + mod - g) % mod &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"d---去-m-nom\">D - 去 M / NoM</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P11316\" class=\"uri\">https://www.luogu.com.cn/problem/P11316</a></p>\n<p>假设 <span class=\"math inline\">\\(f(i)\\)</span> 为至少有 <span class=\"math inline\">\\(i\\)</span> 对不合法元素的方案数，则容斥得到答案 <span class=\"math inline\">\\(\\sum\\limits_{i=0}^n (-1)^i\\cdot f(i)\\)</span>。考虑怎么计算 <span class=\"math inline\">\\(f(i)\\)</span>。</p>\n<p><mark><span class=\"math inline\">\\(M\\)</span> 整除 <span class=\"math inline\">\\(dis(x, y) \\iff (pos_x - pos_y)\\bmod M=0\\iff pos_x\\equiv pos_y\\pmod M\\)</span>。</mark></p>\n<p>考虑把关于 <span class=\"math inline\">\\(M\\)</span> 同余的位置放在一个组，也就是说需要让一对元素不能选同一组的位置。</p>\n<p>考虑容斥，令 <span class=\"math inline\">\\(f(i)\\)</span> 表示至少有 <span class=\"math inline\">\\(i\\)</span> 对点选到一组的方案数，考虑怎么计算。假设我们要在第 <span class=\"math inline\">\\(k\\)</span> 组（size 为 <span class=\"math inline\">\\(s_k\\)</span>）中选出 <span class=\"math inline\">\\(x\\)</span> 对位置，实际上只需要选择 <span class=\"math inline\">\\(2x\\)</span> 个位置然后任意分配给这 <span class=\"math inline\">\\(x\\)</span> 对数，即 <span class=\"math inline\">\\(A_{s_k}^{2x}\\)</span>。设 <span class=\"math inline\">\\(dp_{i, j}\\)</span> 表示 DP 到第 <span class=\"math inline\">\\(i\\)</span> 个组，已经选了 <span class=\"math inline\">\\(j\\)</span> 对，那么有 <span class=\"math inline\">\\(dp_{i,j}=\\sum\\limits_{k=0}^jC_{n-(j - k)}^{j-k}\\times dp_{i-1,j-k}\\times A_{s_i}^{2k}\\)</span>。乍一看好像是 <span class=\"math inline\">\\(O(n^3)\\)</span> 的，但是别忘了 <span class=\"math inline\">\\(\\sum s_i=2n\\)</span>，所以只有 <span class=\"math inline\">\\(O(n^2)\\)</span>。<span class=\"math inline\">\\(f(i)\\)</span> 即为 <span class=\"math inline\">\\(dp_{m,i}\\times (2n-2i)!\\)</span>。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 1e9 + 7;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, m;\n    std::cin &gt;&gt; n &gt;&gt; m;\n    std::vector&lt;int&gt; s(m + 1);\n    std::vector&lt;long long&gt; fac(2 * n + 1), inv(2 * n + 1);\n    fac[0] = inv[0] = 1ll;\n    for (int i = 1; i &lt;= 2 * n; ++i)\n        ++s[i % m + 1], fac[i] = fac[i - 1] * i % mod;\n    auto qkp = [](long long x, int y) &#123;\n        auto res = 1ll;\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    inv[2 * n] = qkp(fac[2 * n], mod - 2);\n    for (int i = 2 * n - 1; i; --i)\n        inv[i] = inv[i + 1] * (i + 1) % mod;\n    auto A = [&amp;](int n, int m) &#123;\n        return fac[n] * inv[n - m] % mod;\n    &#125;;\n    auto C = [&amp;](int n, int m) &#123;\n        return fac[n] * inv[n - m] % mod * inv[m] % mod;\n    &#125;;\n    std::vector&lt;std::vector&lt;long long&gt; &gt; dp(m + 1, std::vector&lt;long long&gt; (n + 1));\n    dp[0][0] = 1ll;\n    for (int i = 1; i &lt;= m; ++i)\n        for (int j = 0; j &lt;= n; ++j) &#123;\n            for (int k = 0; k &lt;= j &amp;&amp; 2 * k &lt;= s[i]; ++k)\n                (dp[i][j] += C(n - (j - k), k) * dp[i - 1][j - k] % mod * A(s[i], 2 * k) % mod) %= mod;\n            // printf(&quot;s = %d, dp[%d][%d] = %lld\\n&quot;, s[i], i, j, dp[i][j]);\n        &#125;\n    long long res = 0ll;\n    for (int i = 0, p = 1; i &lt;= n; ++i, p = mod - p)\n        (res += p * dp[m][i] % mod * fac[2 * n - 2 * i] % mod) %= mod;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"e---kdoi-11彩灯晚会\">E - 「KDOI-11」彩灯晚会</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P11292\" class=\"uri\">https://www.luogu.com.cn/problem/P11292</a></p>\n<p>考虑 <span class=\"math inline\">\\({cnt_i}^2\\)</span> 的含义，即在所有颜色为 <span class=\"math inline\">\\(i\\)</span>、长度为 <span class=\"math inline\">\\(l\\)</span> 的链中有放回地选两次的方案数。</p>\n<p>显然复杂度里是不能包含 <span class=\"math inline\">\\(k\\)</span> 的，所以放弃直接统计 <span class=\"math inline\">\\(cnt_i\\)</span> 的想法。显然每种颜色是等价的，考虑计算选择两条链可以给答案带来的贡献：答案的形式是个和式；对于两条同色链 <span class=\"math inline\">\\(p,q\\)</span>，假设颜色为 <span class=\"math inline\">\\(i\\)</span>，那么会对 <span class=\"math inline\">\\({cnt_i}^2\\)</span> 带来 <span class=\"math inline\">\\(k^{n-2l-|p\\cap q|}\\)</span> 的贡献，对总答案带来 <span class=\"math inline\">\\(k^{n-2l-|p\\cap q| + 1}\\)</span> 的贡献。</p>\n<p>然而如果要枚举计算 <span class=\"math inline\">\\(|p\\cap q|\\)</span> 就无法避免 <span class=\"math inline\">\\(O(n^5)\\)</span>，考虑更有潜力的方法：将问题转化为对于每个 <span class=\"math inline\">\\(x\\)</span>，求交集大小恰好为 <span class=\"math inline\">\\(x\\)</span> 的链对个数。然而「恰好」是不方便计算的——假如当前两链在 <span class=\"math inline\">\\(u\\)</span> 次重合，如果假设下一次在 <span class=\"math inline\">\\(v\\)</span> 次重合，就需要保证在 <span class=\"math inline\">\\(u,v\\)</span> 之间不能重合——这并不好操作。二项式反演将恰好转化为至少，则限制减弱。</p>\n<p>令 <span class=\"math inline\">\\(f_{u,c,l_1,l_2}\\)</span> 表示 <span class=\"math inline\">\\(p,q\\)</span> 当前在 <span class=\"math inline\">\\(u\\)</span> 处重合，视野内的 <span class=\"math inline\">\\(p,q\\)</span> 长度为 <span class=\"math inline\">\\(l_1,l_2\\)</span>，至少已经重合了 <span class=\"math inline\">\\(c\\)</span> 次的方案数。预处理出走到 <span class=\"math inline\">\\(u\\)</span> 步数为 <span class=\"math inline\">\\(l_1,l_2\\)</span> 的方案数为初始值。枚举可能的后续重合点 <span class=\"math inline\">\\(v\\)</span>（满足 <span class=\"math inline\">\\(v\\)</span> 的拓扑序 <span class=\"math inline\">\\(&gt;u\\)</span>）有 <span class=\"math inline\">\\(f_{v,c+1,l_1&#39;,l_2&#39;}\\gets f_{v,c+1,l_1&#39;,l_2&#39;} + f_{u,c,l_1,l_2}\\)</span>。预处理出 <span class=\"math inline\">\\(u\\to v\\)</span> 长度为 <span class=\"math inline\">\\(\\Delta\\)</span> 的方案数（这是 <span class=\"math inline\">\\(O(n^3l)\\)</span> 的）优化转移，在算出 <span class=\"math inline\">\\(nex_{u,l}\\)</span> 表示从 <span class=\"math inline\">\\(u\\)</span> 出发走 <span class=\"math inline\">\\(l\\)</span> 步的方案数处理答案，则 <span class=\"math inline\">\\(F(i)=\\sum_{u,l_1,l_2}f_{u,l_1,l_2}\\cdot nex_{u,l-l_1}\\cdot nex_{u,l-l_2}\\)</span>，枚举 <span class=\"math inline\">\\(u,c,l_1,l_2,v,l_1&#39;,l_2&#39;\\)</span>，就可以达到优秀的 <span class=\"math inline\">\\(O(n^2l^5+n^3l)\\)</span>！简直是令人震撼 <img src=\"/em/kt.gif\" /></p>\n<p>给出第一个优化：发现 <span class=\"math inline\">\\(l_1\\)</span> 和 <span class=\"math inline\">\\(l_2\\)</span> 的转移彼此不干扰，考虑建立一个临时数组 <span class=\"math inline\">\\(g\\)</span>，先从 <span class=\"math inline\">\\(f_u,c\\)</span> 转移 <span class=\"math inline\">\\(l_1\\)</span> 到 <span class=\"math inline\">\\(g\\)</span>，再从 <span class=\"math inline\">\\(g\\)</span> 转移 <span class=\"math inline\">\\(l_2\\)</span> 到 <span class=\"math inline\">\\(f_{v,c+1}\\)</span>，则复杂度降为 <span class=\"math inline\">\\(O(n^2l^4+n^3l)\\)</span>，仍不足以通过。</p>\n<p>DP 过程上的优化已经万策尽，考虑从式子本身消元减少 DP 维度入手。令 <span class=\"math inline\">\\(h(i)\\)</span> 表示交集大小恰好恰好为 <span class=\"math inline\">\\(i\\)</span> 的方案数，则此时答案式为 <span class=\"math inline\">\\(\\sum\\limits_{i=0}^l k^{n-2l+i+1}\\times h(i)\\)</span>。又 <span class=\"math inline\">\\(F(i)=\\sum\\limits_{j=i}^lC_j^i\\cdot h(j)\\)</span>，二项式反演得：</p>\n<p><span class=\"math display\">\\[\n\\begin{aligned}\nres&amp;=\\sum\\limits_{i=0}^lk^{n-2l+i+1}\\cdot \\sum_{j=i}^l(-1)^{j-i}\\cdot C_j^i\\cdot F(j)\\\\\n&amp;=k^{n-2l+1}\\cdot\\sum_{j=0}^l \\sum_{i=0}^j k^i\\cdot (-1)^{j-i}\\cdot C_j^i\\cdot F(j)\\\\\n&amp;=k^{n-2l+1}\\cdot \\sum_{j=0}^l (k-1)^j\\cdot F(j)\n\\end{aligned}\n\\]</span></p>\n<p><mark>注意这里利用了二项式反演的系数可以和交换求和顺序后的 <span class=\"math inline\">\\(i\\)</span> 次项（或 <span class=\"math inline\">\\(j-i\\)</span> 次项，参见 <a href=\"#c---sky-full-of-stars\">Sky Full of Stars 中最后一步的处理</a>）组成二项式定理的特点</mark>，以便基于式子结构尽可能消元。</p>\n<p>那么此时答案式已经和 <span class=\"math inline\">\\(c\\)</span> 无关，可以丢掉 <span class=\"math inline\">\\(c\\)</span> 这一维，和 <span class=\"math inline\">\\(c\\)</span> 有关的计算已经在转移时处理了。则 <span class=\"math inline\">\\(f_{v,l_1&#39;,l_2&#39;}=\\sum f_{u,l_1,l_2}\\times (k-1)\\)</span>，复杂度降为 <span class=\"math inline\">\\(O(n^2l^3+n^3l)\\)</span>。</p>\n<details>\n<p>记得还要算上 <span class=\"math inline\">\\(F(0)\\)</span>，即任选一条合法链的方案数平方。</p>\n<pre class=\"cpp\"><code>// 兄弟你好香\n// 兄弟你是依托打分，我踏马吃吃吃吃吃\n#include &lt;bits/stdc++.h&gt;\nconst int mod = 998244353;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;party3.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    using arr = std::vector&lt;long long&gt;;\n    using arrr = std::vector&lt;arr&gt;;\n    using arrrr = std::vector&lt;arrr&gt;;\n    int n, k, l, m;\n    std::cin &gt;&gt; n, std::cin &gt;&gt; n &gt;&gt; k &gt;&gt; l &gt;&gt; m;\n    std::vector&lt;int&gt; deg(n + 1), id;\n    std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; g(n + 1);\n    for (int x, y, c; m--; ) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y &gt;&gt; c;\n        ++deg[y], g[x].emplace_back(y, c);\n    &#125;\n    arrrr to(n + 1, arrr(n + 1, arr(l + 1)));\n    arrr pre(n + 1, arr(l + 1)), nex(n + 1, arr(l + 1));\n    &#123;\n        std::queue&lt;int&gt; q;\n        for (int i = 1; i &lt;= n; ++i)\n            if (!deg[i])\n                q.push(i);\n        for (int u; !q.empty(); ) &#123;\n            u = q.front(), q.pop();\n            to[u][u][0] = 1ll, id.push_back(u);\n            for (auto i : id)\n                for (int j = 0; j &lt;= l; ++j) &#123;\n                    (pre[u][j] += to[i][u][j]) %= mod;\n                    // printf(&quot;to[%d][%d][%d] = %lld\\n&quot;, i, u, j, to[i][u][j]);\n                &#125;\n            // for (int j = 0; j &lt;= l; ++j)\n            //     printf(&quot;pre[%d][%d] = %lld\\n&quot;, u, j, pre[u][j]);\n            for (auto [v, c] : g[u]) &#123;\n                for (auto i : id)\n                    for (int j = 1; j &lt;= l; ++j)\n                        (to[i][v][j] += to[i][u][j - 1] * c) %= mod;\n                if (!--deg[v])\n                    q.push(v);\n            &#125;\n        &#125;\n        for (int u = 1; u &lt;= n; ++u)\n            for (int v = 1; v &lt;= n; ++v)\n                for (int i = 0; i &lt;= l; ++i)\n                    (nex[u][i] += to[u][v][i]) %= mod;\n    &#125;\n    arrrr f(n + 1, arrr(l + 1, arr(l + 1)));\n    &#123;\n        for (int i = 1; i &lt;= n; ++i)\n            for (int l1 = 1; l1 &lt;= l; ++l1)\n                for (int l2 = 1; l2 &lt;= l; ++l2)\n                    f[i][l1][l2] = pre[i][l1 - 1] * pre[i][l2 - 1] % mod * (k - 1) % mod;\n        for (auto i = 0; i &lt; n; ++i) &#123;\n            int u = id[i];\n            // for (int l1 = 1; l1 &lt;= l; ++l1)\n            //     for (int l2 = 1; l2 &lt;= l; ++l2)\n            //         printf(&quot;f[%d][%d][%d] = %lld\\n&quot;, u, l1, l2, f[u][l1][l2]);\n            for (auto j = i + 1; j &lt; n; ++j) &#123;\n                arrr g(l + 1, arr(l + 1));\n                int v = id[j];\n                for (int l1 = 1; l1 &lt; l; ++l1)\n                    for (int _l1 = l1 + 1; _l1 &lt;= l; ++_l1) &#123;\n                        auto K = to[u][v][_l1 - l1];\n                        if (K)\n                            for (int l2 = 1; l2 &lt; l; ++l2)\n                                (g[_l1][l2] += f[u][l1][l2] * K) %= mod;\n                    &#125;\n                for (int _l1 = 2; _l1 &lt;= l; ++_l1)\n                    for (int l2 = 1; l2 &lt; l; ++l2)\n                        if (g[_l1][l2])\n                            for (int _l2 = l2 + 1; _l2 &lt;= l; ++_l2)\n                                (f[v][_l1][_l2] += g[_l1][l2] * to[u][v][_l2 - l2] % mod * (k - 1)) %= mod; \n            &#125;\n        &#125;\n    &#125;\n    auto qkp = [](long long x, int y) &#123;\n        auto res(1ll);\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    auto res(0ll);\n    for (int u = 1; u &lt;= n; ++u)\n        for (int v = 1; v &lt;= n; ++v)\n            (res += to[u][v][l - 1]) %= mod;\n    (res *= res) %= mod;\n    for (int u = 1; u &lt;= n; ++u)\n        for (int l1 = 1; l1 &lt;= l; ++l1)\n            for (int l2 = 1; l2 &lt;= l; ++l2)\n                (res += f[u][l1][l2] * nex[u][l - l1] % mod * nex[u][l - l2] % mod) %= mod;\n    res = res % mod * (qkp(k, n + 1) * qkp(qkp(k, 2 * l), mod - 2) % mod) % mod;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"g---小星星\">G - 小星星</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P3349\" class=\"uri\">https://www.luogu.com.cn/problem/P3349</a></p>\n<p>首先考虑比较暴力的做法，那么有 <span class=\"math inline\">\\(f_{i,j,S}\\)</span> 表示在 <span class=\"math inline\">\\(i\\)</span> 这个子树里面选了集合 <span class=\"math inline\">\\(S\\)</span>，且 <span class=\"math inline\">\\(i\\)</span> 的颜色为 <span class=\"math inline\">\\(j\\)</span> 的方案数，维数里之所以有 <span class=\"math inline\">\\(j\\)</span> 是为了满足连边限制。</p>\n<p>然后树上子集 DP，发现是 <span class=\"math inline\">\\(O(n^4\\cdot 2^n)\\)</span> 的，</p>\n<hr />\n<h2 id=\"cf785d-anton-and-school---2\">CF785D Anton and School - 2</h2>\n<p><a href=\"https://codeforces.com/problemset/problem/785/D\" class=\"uri\">https://codeforces.com/problemset/problem/785/D</a></p>\n<p>容易想到枚举每个 <code>(</code> 作为分界点的情况，那么钦定当前枚举的 <code>(</code> 是要选的。对于当前 <code>(</code>，若其左边（不含）的 <code>(</code> 有 <span class=\"math inline\">\\(n\\)</span> 个而右边的 <code>)</code> 有 <span class=\"math inline\">\\(m\\)</span> 个，枚举除了当前 <code>(</code> 还要选 <span class=\"math inline\">\\(i\\)</span> 个 <code>(</code>，那么答案为 <span class=\"math inline\">\\(\\sum_{i=0}C_n^{i-1}\\cdot C_m^i\\)</span>。</p>\n<p>发现这个形式可以范德蒙德卷积：<span class=\"math inline\">\\(\\sum_{i=0}C_n^{i-1}\\cdot C_m^i=\\sum_{i=0}C_n^{n-i+1}\\cdot C_m^i=C_{n+m}^{n+1}\\)</span>。</p>\n<p>关于怎么记忆范德蒙德卷积，发现上下相加，也可以从组合意义记忆：在 <span class=\"math inline\">\\(n\\)</span> 个球中选出 <span class=\"math inline\">\\(k-i\\)</span> 个球，再从 <span class=\"math inline\">\\(m\\)</span> 个球中选出 <span class=\"math inline\">\\(i\\)</span> 个球的总方案就是从 <span class=\"math inline\">\\(n+m\\)</span> 个球中直接选出 <span class=\"math inline\">\\(k\\)</span> 个球的方案。</p>\n<p>注意判断右侧没有 <code>)</code> 的时候贡献为 <span class=\"math inline\">\\(0\\)</span>。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 1e9 + 7;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    std::string s;\n    std::cin &gt;&gt; s;\n    int n = s.length();\n    s = &quot; &quot; + s;\n    std::vector&lt;int&gt; cnt1(n + 1), cnt2(n + 1);\n    std::vector&lt;long long&gt; fac(n + 1), inv(n + 1);\n    fac[0] = inv[0] = 1ll;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        fac[i] = fac[i - 1] * i % mod;\n        cnt1[i] = cnt1[i - 1] + (s[i] == &#39;(&#39;);\n    &#125;\n    auto qkp = [](long long x, int y) &#123;\n        auto res(1ll);\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    inv[n] = qkp(fac[n], mod - 2);\n    cnt2[n] = (s[n] == &#39;)&#39;);\n    for (int i = n - 1; i; --i) &#123;\n        cnt2[i] = cnt2[i + 1] + (s[i] == &#39;)&#39;);\n        inv[i] = inv[i + 1] * (i + 1) % mod;\n    &#125;\n    long long res = 0ll;\n    auto C = [&amp;](int n, int m) &#123;\n        if (n &lt; m)\n            return 0ll;\n        return fac[n] * inv[n - m] % mod * inv[m] % mod;\n    &#125;;\n    for (int i = 1; i &lt;= n; ++i)\n        if (s[i] == &#39;(&#39;)\n            (res += C(cnt1[i] + cnt2[i] - 1, cnt1[i])) %= mod;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"cf1332e-height-all-the-same\">CF1332E Height All the Same</h2>\n<p><a href=\"https://codeforces.com/problemset/problem/1332/E\" class=\"uri\">https://codeforces.com/problemset/problem/1332/E</a></p>\n<p>容易发现第一个操作是用来改变两个数奇偶性的；而第二个操作能在全图奇偶性相同的任何情况下达成要求。</p>\n<p>注意到如果我们想同时仅改变任意两个数的奇偶性，可以在棋盘上任找一条路径一路使用操作一。只要某种奇偶性的元素个数共有偶数个，就能通过若干次操作一把它们全部变成另一种奇偶性。</p>\n<p>令 <span class=\"math inline\">\\(K_1\\)</span> 为 <span class=\"math inline\">\\(L\\sim R\\)</span> 中奇数的个数，<span class=\"math inline\">\\(K_2\\)</span> 为偶数，那么有：</p>\n<p><span class=\"math display\">\\[\nres=\\sum_{i=0}^{nm} C_{nm}^i\\times {K_1}^i\\cdot {K_2}^{nm-i}\\cdot [i\\bmod 2=0]\n\\]</span></p>\n<p>我们发现这个东西和二项式定理简直像得不能再像了！但多了一个系数导致没办法省略枚举过程。如果进行变形呢？</p>\n<p><span class=\"math display\">\\[\nres=(K_1+K_2)^{nm}-\\sum_{i=0}^{nm} C_{nm}^i\\times {K_1}^i\\cdot {K_2}^{nm-i}\\cdot [i\\bmod 2=1]\n\\]</span></p>\n<p>似乎依然没有出路！但这里有个神奇的操作：</p>\n<p><span class=\"math display\">\\[\nres=(-K_1+K_2)^{nm}+\\sum_{i=0}^{nm} C_{nm}^i\\times {K_1}^i\\cdot {K_2}^i\\cdot [i\\bmod 2=1]\n\\]</span></p>\n<p>二式相加就可以<mark>消元</mark>，得到 <span class=\"math inline\">\\(2\\cdot res=(K_1+K_2)^{nm}+(K_1-K_2)^{nm}\\)</span>。<mark>这启示我们二项式定理中的符号和奇偶性的深切联系。</mark></p>\n<details>\n<p>如果你使用费马小定理对次数进行了处理，你可能需要注意次数可能为 <span class=\"math inline\">\\(\\text{mod} -1\\)</span> 的倍数。</p>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 998244353;\nconst int inv2 = 499122177;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    long long n, m, l, r, k1, k2;\n    std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; l &gt;&gt; r, k1 = (r - l + 1) / 2, k2 = (r - l + 1) - k1;\n    auto qkp = [](long long x, long long y) &#123;\n        auto res(1ll);\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    if (n * m % 2)\n        std::cout &lt;&lt; qkp(r - l + 1, n * m) &lt;&lt; &#39;\\n&#39;;\n    else\n        std::cout &lt;&lt; (qkp(r - l + 1, n * m) + qkp((k1 + mod - k2) % mod, n * m)) % mod * inv2 % mod &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"a---交错序列\">A - 交错序列</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P4456\" class=\"uri\">https://www.luogu.com.cn/problem/P4456</a></p>\n<figure>\n<img src=\"2.png\" alt=\"出题人疑似需要加强数学功底（？）\" /><figcaption>出题人疑似需要加强数学功底（？）</figcaption>\n</figure>\n<p>容易想到把答案用二项式定理拆开：</p>\n<p><span class=\"math display\">\\[\n\\begin{aligned}\nres&amp;=\\sum_y f_y\\cdot y^b\\cdot (n-y)^a\\\\\n&amp;=\\sum_y f_y\\cdot y^b\\cdot \\sum_{i=0}^a C_a^i\\cdot n^i\\cdot(-y)^{a-i}\\\\\n&amp;=\\sum_y\\sum_{i=0}^a f_y\\cdot C_a^i\\cdot n^i\\cdot(-1)^{a-i}\\cdot y^{a+b-i}\\\\\n&amp;=\\sum_{i=0}^a C_a^i\\cdot n^i\\cdot(-1)^{a-i}\\cdot \\sum_y f_y\\cdot y^{a+b-i}\\\\\n\\end{aligned}\n\\]</span></p>\n<p>然后发现后面那个 sigma 不太有办法求。一个比较优雅的方法是把 <span class=\"math inline\">\\(y^{a+b-i}\\)</span> 直接作为系数而非下标塞到 <span class=\"math inline\">\\(f\\)</span> 里去，即令 <span class=\"math inline\">\\(f_{i}\\)</span> 表示 <span class=\"math inline\">\\(\\forall \\,y\\)</span>，<span class=\"math inline\">\\(\\sum y^i\\)</span> 之和。</p>\n<p>具体地，令 <span class=\"math inline\">\\(dp_{n,i,0/1}\\)</span> 表示当前 DP 到第 <span class=\"math inline\">\\(n\\)</span> 位，要求幂次为 <span class=\"math inline\">\\(i\\)</span>，最后一位为 <span class=\"math inline\">\\(0/1\\)</span> 的答案。则显然有 <span class=\"math inline\">\\(dp_{n,i,0}=dp_{n-1,i,0}+dp_{n-1,i,1}\\)</span>。对于 <span class=\"math inline\">\\(dp_{n,i,1}\\)</span>，因为此时 <span class=\"math inline\">\\(\\forall\\, k,k\\gets k+1\\)</span>，则 <span class=\"math inline\">\\((k+1)^i=\\sum\\limits_{j=0}^i C_i^j \\cdot k^j\\)</span> 即 <span class=\"math inline\">\\(dp_{n,i,1}=\\sum\\limits_{j=0}^i C_i^j\\cdot dp_{n-1,j,0}\\)</span>。发现 <span class=\"math inline\">\\(i,j\\)</span> 的范围是 <span class=\"math inline\">\\(90\\)</span>，很恐怖的事情是这是可以矩阵的。</p>\n<details>\n<p>就像我们都知道的那样，矩阵在加完之后再取模就会快很多……</p>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint mod;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, a, b;\n    std::cin &gt;&gt; n &gt;&gt; a &gt;&gt; b &gt;&gt; mod;\n    std::vector&lt;std::vector&lt;long long&gt; &gt; C(a + b + 1, std::vector&lt;long long&gt;(a + b + 1));\n    for (int i = 0; i &lt;= a + b; ++i) &#123;\n        C[i][0] = 1ll;\n        for (int j = 1; j &lt;= i; ++j)\n            C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % mod;\n    &#125;\n    struct mat &#123;\n        int n, m;\n        std::vector&lt;std::vector&lt;long long&gt; &gt; a;\n        mat(int n, int m, bool flag = 0): n(n), m(m), a(n, std::vector&lt;long long&gt; (m)) &#123;\n            if (flag)\n                for (int i = 0; i &lt; n; ++i)\n                    a[i][i] = 1ll;\n            return;\n        &#125;\n        mat operator* (const mat &amp;q) const &#123;\n            mat res(n, q.m);\n            for (int i = 0; i &lt; n; ++i)\n                for (int k = 0; k &lt; q.m; ++k) &#123;\n                    for (int j = 0; j &lt; m; ++j)\n                        res.a[i][k] += a[i][j] * q.a[j][k];\n                    res.a[i][k] %= mod;\n                &#125;\n            return res;\n        &#125;\n        mat operator^ (int q) const &#123;\n            mat res(n, n, 1), x(*this);\n            for (; q; x = x * x, q &gt;&gt;= 1)\n                if (q &amp; 1)\n                    res = res * x;\n            return res;\n        &#125;\n    &#125; f(1, 2 * (a + b + 1)), op(2 * (a + b + 1), 2 * (a + b + 1));\n    auto fun = [&amp;](int i, int j) &#123;\n        return i + j * (a + b + 1);\n    &#125;;\n    f.a[0][fun(0, 0)] = 1ll;\n    for (int i = 0; i &lt;= a + b; ++i)\n        op.a[fun(i, 0)][fun(i, 0)] = op.a[fun(i, 1)][fun(i, 0)] = 1ll;\n    for (int i = 0; i &lt;= a + b; ++i)\n        for (int j = 0; j &lt;= i; ++j)\n            op.a[fun(j, 0)][fun(i, 1)] = C[i][j];\n    f = f * (op ^ n);\n    // for (int i = 0; i &lt;= n; ++i) &#123;\n    //     if (i)\n    //         f = f * op;\n    //     for (int j = 0; j &lt;= a + b; ++j)\n    //         printf(&quot;f[%d][%d] = %lld / %lld\\n&quot;, i, j, f.a[0][fun(j, 0)], f.a[0][fun(j, 1)]);\n    // &#125;\n    auto res = 0ll;\n    for (int i = 0; i &lt;= a; ++i) &#123;\n        static auto p(1ll), k((a % 2) ? mod - 1ll : 1ll);\n        (res += C[a][i] * p % mod * k % mod * (f.a[0][fun(a + b - i, 0)] + f.a[0][fun(a + b - i, 1)]) % mod) %= mod;\n        (p *= n) %= mod, k = mod - k;\n    &#125;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"b---different-subsets-for-all-tuples\">B - Different Subsets For All Tuples</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/CF660E\" class=\"uri\">https://www.luogu.com.cn/problem/CF660E</a></p>\n<p>首先你可能需要知道，如果已知一个序列，如何得到答案？</p>\n<p>令 <span class=\"math inline\">\\(f_i\\)</span> 表示在 <span class=\"math inline\">\\(i\\)</span> 处取一个子序列的末尾，枚举上一个元素 <span class=\"math inline\">\\(x\\)</span>，找到 <span class=\"math inline\">\\(i\\)</span> 之前最靠后的一个 <span class=\"math inline\">\\(a_j=x\\)</span>，那么有 <span class=\"math inline\">\\(f_i=\\sum f_j\\)</span>，换言之需要保证 <span class=\"math inline\">\\((j,i)\\)</span> 范围内没有 <span class=\"math inline\">\\(x\\)</span> 出现。</p>\n<p>此时序列未知，令 <span class=\"math inline\">\\(f_{i, x}\\)</span> 表示在 <span class=\"math inline\">\\(i\\)</span> 处取一个子序列末尾，且 <span class=\"math inline\">\\(i\\)</span> 的值为 <span class=\"math inline\">\\(x\\)</span>；按照贡献的视角来看待，每个可以和 <span class=\"math inline\">\\(i\\)</span> 组成新子序列的方案可以带来 <span class=\"math inline\">\\(m^{i-1}\\)</span> 的贡献（因为 <span class=\"math inline\">\\(a_i\\)</span> 已经固定为 <span class=\"math inline\">\\(x\\)</span>，其他位置可以任选），那么有 <span class=\"math inline\">\\(f_{i,x}=m^i\\times \\sum_{j&lt;i,y}f_{j,y}\\times (m-1)^{i-j-1}\\)</span>。</p>\n<p>然后就惊讶地发现式子和 <span class=\"math inline\">\\(x\\)</span> 这一维没有关系了。所以直接带上系数得到：</p>\n<p><span class=\"math display\">\\[\n\\begin{aligned}\nf_i&amp;=m^i\\times \\sum_{j&lt;i} f_j\\times (m-1)^{i-j-1}\\times m\\\\\n&amp;=m^i\\times (m-1)^{i-1}\\times m\\cdot \\sum_{j&lt;i} f_j\\times (m-1)^{-j}\n\\end{aligned}\n\\]</span></p>\n<p>前缀和优化一下就可以快速求了。最终的答案就是 <span class=\"math inline\">\\(res=m^n+\\sum f_i\\times (m-1)^{n-i}\\)</span>。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 1e9 + 7;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, m;\n    std::cin &gt;&gt; n &gt;&gt; m;\n    if (m == 1)\n        std::cout &lt;&lt; (n + 1) &lt;&lt; &#39;\\n&#39;;\n    else &#123;\n        std::vector&lt;long long&gt; f(n + 1), s(n + 1), pm1(n + 1);\n        pm1[0] = 1ll;\n        for (int i = 1; i &lt;= n; ++i)\n            pm1[i] = pm1[i - 1] * (m - 1) % mod;\n        auto qkp = [](long long x, int y) &#123;\n            auto res(1ll);\n            for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n                if (y &amp; 1)\n                    (res *= x) %= mod;\n            return res;\n        &#125;;\n        auto res(qkp(m, n));\n        const auto invm = qkp(m - 1, mod - 2);\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            static long long p(m), inv(invm);\n            f[i] = (p + pm1[i - 1] * m % mod * s[i - 1] % mod) % mod;\n            s[i] = (s[i - 1] + f[i] * inv % mod) % mod;\n            (res += f[i] * pm1[n - i] % mod) %= mod;\n            (p *= m) %= mod, (inv *= invm) %= mod;\n        &#125;\n        std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;; \n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"g---gardens\">G - Gardens</h2>\n<p><a href=\"https://atcoder.jp/contests/abc235/tasks/abc235_g\" class=\"uri\">https://atcoder.jp/contests/abc235/tasks/abc235_g</a></p>\n<p>如果没有『每个人必须有一个元素』这个限制，就可以随便做了。现在加上了这个限制，很容易想到用没得到的人来容斥。钦定至少有 <span class=\"math inline\">\\(i\\)</span> 个人没拿到，得到答案为 <span class=\"math inline\">\\(\\sum\\limits_{i=0}^n (-1)^i\\cdot C_n^i\\cdot \\left(\\sum\\limits_{j=0}^a C_i^j\\right)\\cdot \\left(\\sum\\limits_{j=0}^b C_i^j\\right)\\cdot \\left(\\sum\\limits_{j=0}^c C_i^j\\right)\\)</span>。</p>\n<p>怎么算 <span class=\"math inline\">\\(\\sum\\limits_{j=0}^a C_i^j\\)</span> 呢？当 <span class=\"math inline\">\\(a&gt; i\\)</span> 时，二项式是好求的；当 <span class=\"math inline\">\\(a\\le i\\)</span> 时呢？看到这个式子很容易带到杨辉三角里去，也就是求一行的前 <span class=\"math inline\">\\(a\\)</span> 个数。注意到可以用上一行的前 <span class=\"math inline\">\\(a\\)</span> 个数 <span class=\"math inline\">\\(O(1)\\)</span> 得到（假设第 <span class=\"math inline\">\\(j-1\\)</span> 行前 <span class=\"math inline\">\\(a\\)</span> 个数之和为 <span class=\"math inline\">\\(f_a(j-1)\\)</span>）：<span class=\"math inline\">\\(f_a(j)=f_a(j-1)\\times 2-C_{j-1,a}\\)</span>。<mark>你需要意识到，由于上一行也是答案中要求的，所以可以使用递推解决问题。<strong>在组合计数中，递推 / DP 无论是在化简式子还是求容斥 / 二项式反演里具体某一限制下的方案数都是很有用的，在需要优化复杂度时，可以从递推 / DP、恒等式、前缀和、预处理等方法入手考虑</strong></mark>。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 998244353;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, a, b, c;\n    std::cin &gt;&gt; n &gt;&gt; a &gt;&gt; b &gt;&gt; c;\n    std::vector&lt;long long&gt; fac(n + 1), inv(n + 1), fa(n + 1), fb(n + 1), fc(n + 1), pow2(n + 1);\n    fac[0] = inv[0] = pow2[0] = 1ll;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        fac[i] = fac[i - 1] * i % mod;\n        pow2[i] = pow2[i - 1] * 2 % mod;\n    &#125;\n    auto qkp = [&amp;](long long x, int y) &#123;\n        auto res(1ll);\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    inv[n] = qkp(fac[n], mod - 2);\n    for (int i = n - 1; i; --i)\n        inv[i] = inv[i + 1] * (i + 1) % mod;\n    auto C = [&amp;](int n, int m) &#123;\n        return fac[n] * inv[n - m] % mod * inv[m] % mod;\n    &#125;;\n    for (int i = 0; i &lt;= a; ++i)\n        (fa[a] += C(a, i)) %= mod;\n    for (int i = a + 1; i &lt;= n; ++i)\n        fa[i] = (2 * fa[i - 1] % mod + mod - C(i - 1, a)) % mod;\n    for (int i = 0; i &lt;= b; ++i)\n        (fb[b] += C(b, i)) %= mod;\n    for (int i = b + 1; i &lt;= n; ++i)\n        fb[i] = (2 * fb[i - 1] % mod + mod - C(i - 1, b)) % mod;\n    for (int i = 0; i &lt;= c; ++i)\n        (fc[c] += C(c, i)) %= mod;\n    for (int i = c + 1; i &lt;= n; ++i)\n        fc[i] = (2 * fc[i - 1] % mod + mod - C(i - 1, c)) % mod;\n    auto res(0ll);\n    for (int i = n, p = 1; ~i; --i, p = mod - p)\n        (res += p * C(n, i) % mod * (i &gt;= a ? fa[i] : pow2[i]) % mod * (i &gt;= b ? fb[i] : pow2[i]) % mod * (i &gt;= c ? fc[i] : pow2[i]) % mod) %= mod;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n",
            "tags": [
                "排列组合",
                "容斥原理",
                "数学",
                "二项式定理",
                "二项式反演"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20230813/",
            "url": "https://xsc062.netlify.app/20230813/",
            "title": "pn、pm 和 plmm",
            "date_published": "2023-08-13T08:46:13.000Z",
            "content_html": "<p>Sotution to <a href=\"https://codeforces.com/problemset/problem/258/C\">CF258C Little Elephant and LCM</a>。</p>\n<span id=\"more\"></span>\n<hr />\n<p>0#：那么这个 pn 可以等于什么？它只能等于 pm。（露出看到 plmm 一般的猥琐坏笑）</p>\n<hr />\n<p>方便起见，下面 <span class=\"math inline\">\\(b_{\\text{lcm}}\\)</span> 的意思就是 <span class=\"math inline\">\\(\\text{lcm}\\{b_1,b_2,\\cdots,b_n\\}\\)</span>，<span class=\"math inline\">\\(\\max\\)</span> 什么的也同理。</p>\n<p>首先我们都能反应过来，如果 <span class=\"math inline\">\\(b_{\\text{lcm}}=b_{\\max}\\)</span>，那么 <span class=\"math inline\">\\(b\\)</span> 中的最大值就得是 <span class=\"math inline\">\\(b_{\\text {lcm}}\\)</span>，而其他元素都得是 <span class=\"math inline\">\\(b_{\\max}\\)</span> 的因数。</p>\n<p>既然涉及到求 <span class=\"math inline\">\\(b_{\\max}\\)</span> 的因数，那我们势必避免不了枚举 <span class=\"math inline\">\\(b_{\\max}\\)</span>。我一开始陷入了一个 trick：我并不知道 <span class=\"math inline\">\\(b_{\\max}\\)</span> 应该处于哪一个位置。但其实这不重要，它对我们最后的方案没有影响，有影响的是「有多少个位置可以取到当前枚举的 <span class=\"math inline\">\\(b_{\\max}\\)</span>」。</p>\n<p>对于当前枚举的 <span class=\"math inline\">\\(b_{\\max}\\)</span>（假设为 <span class=\"math inline\">\\(k\\)</span>），我们找到它的所有因数 <span class=\"math inline\">\\(p_1\\sim p_m\\)</span>，按从小到大的顺序排列。对于一个 <span class=\"math inline\">\\(a_i\\)</span>，当且仅当 <span class=\"math inline\">\\(a_i\\ge p_j\\)</span> 时，<span class=\"math inline\">\\(a_i\\)</span> 可以选择 <span class=\"math inline\">\\(p_j\\)</span>。那么我们找到 <span class=\"math inline\">\\(a_i\\)</span> 可以选到的最大的 <span class=\"math inline\">\\(p_j\\)</span>，此时 <span class=\"math inline\">\\(a_i\\)</span> 的选择就是 <span class=\"math inline\">\\(p_1\\sim p_j\\)</span>，共 <span class=\"math inline\">\\(j\\)</span> 种。</p>\n<p>那么我们在外面已经有一层枚举 <span class=\"math inline\">\\(k\\)</span> 的循环的前提下，再遍历 <span class=\"math inline\">\\(a\\)</span> 数组无疑是会起飞的，我们考虑倒过来，遍历 <span class=\"math inline\">\\(p\\)</span>，对于每个 <span class=\"math inline\">\\(p_j\\)</span>，找到它是多少个 <span class=\"math inline\">\\(a_i\\)</span> 的最大选择（假设为 <span class=\"math inline\">\\(x_j\\)</span>），那么对于 <span class=\"math inline\">\\(p_j\\)</span>，它贡献的答案就是 <span class=\"math inline\">\\(j^{x_j}\\)</span>。</p>\n<p><span class=\"math inline\">\\(x_j\\)</span> 的计算也不难，我们用两个二分找到满足 <span class=\"math inline\">\\(p_j\\le a_i &lt; p_j + 1\\)</span> 的 <span class=\"math inline\">\\(a_i\\)</span> 数量就可以了。那么总方案数就是 <span class=\"math inline\">\\(\\prod j^{x_j}\\)</span>。</p>\n<p>但是别忘了还有 <span class=\"math inline\">\\(k\\)</span> 为 <span class=\"math inline\">\\(b_{\\max}\\)</span> 的限制。找到 <span class=\"math inline\">\\(x_m\\)</span>，怎么去满足至少有一个 <span class=\"math inline\">\\(a_i=k\\)</span> 呢？一个微型容斥，用总方案数减去一个 <span class=\"math inline\">\\(k\\)</span> 都没有的方案数。那么就规定了每个可以取到 <span class=\"math inline\">\\(k\\)</span> 的数都必须不取 <span class=\"math inline\">\\(k\\)</span>，本来有 <span class=\"math inline\">\\(m\\)</span> 种选择，现在只剩下 <span class=\"math inline\">\\(m−1\\)</span> 种，所以答案就是 <span class=\"math inline\">\\((m−1)^{x_m}\\)</span>，容斥后为 <span class=\"math inline\">\\(m^{x_m}−(m−1)^{x_m}\\)</span>。</p>\n<p>对于 <span class=\"math inline\">\\(b_{\\max}=k\\)</span>，最终结果为 <span class=\"math inline\">\\((\\prod\\limits_{j=1}^{m−1}j^{x_j})\\times (m^{x_m}−(m−1)^{x_m})\\)</span>。加法原理把所有 <span class=\"math inline\">\\(k\\)</span> 的情况加起来即可。</p>\n<p>对于时间复杂度，枚举 <span class=\"math inline\">\\(k\\)</span> 是 <span class=\"math inline\">\\(O(V)\\)</span> 的，找因数是 <span class=\"math inline\">\\(O(\\sqrt V)\\)</span> 的，枚举 <span class=\"math inline\">\\(p_j\\)</span> 是 <span class=\"math inline\">\\(\\log V\\)</span> 的，二分是 <span class=\"math inline\">\\(\\log n\\)</span> 的。所以最终时间复杂度为 <span class=\"math inline\">\\(O(V\\times \\max\\{\\sqrt V,\\log V\\times \\log n\\})\\)</span>。</p>\n<details>\n<pre class=\"cpp\"><code>#define int long long\nnamespace XSC062 &#123;\nusing namespace fastIO;\nconst int mod = 1e9 + 7;\nconst int maxn = 1e5 + 5;\nint a[maxn];\nint n, mx, ans, res;\nint qkp(int x, int y) &#123;\n    int res = 1;\n    while (y) &#123;\n        if (y &amp; 1) (res *= x) %= mod;\n        (x *= x) %= mod, y &gt;&gt;= 1;\n    &#125;\n    return res;\n&#125;\nint max(int x, int y) &#123; return x &gt; y ? x : y; &#125;\nint main() &#123;\n    read(n);\n    for (int i = 1; i &lt;= n; ++i) \n        read(a[i]), mx = max(mx, a[i]);\n    std::sort(a + 1, a + n + 1);\n    for (int k = 1; k &lt;= mx; ++k) &#123;\n        res = 1;\n        std::vector&lt;int&gt; p;\n        p.push_back(-1); // 占位符，方便下标对齐 \n        for (int i = 1; i * i &lt;= k; ++i) &#123;\n            if (k % i == 0) &#123;\n                p.push_back(i);\n                if (i * i != k) p.push_back(k / i);\n            &#125;\n        &#125;\n        std::sort(p.begin() + 1, p.end());\n        // 先算前 m - 1 个 \n        int m = p.size() - 1;\n        for (int j = 1; j &lt;= m - 1; ++j) &#123;\n            int l, r, x;\n            l = std::lower_bound(a + 1, a + n + 1, p[j]) - a;\n            r = std::lower_bound(a + 1, a + n + 1, p[j + 1]) - a - 1;\n            x = r - l + 1, (res *= qkp(j, x)) %= mod;\n        &#125;\n        int l, r, x;\n        l = std::lower_bound(a + 1, a + n + 1, p[m]) - a;\n        r = n, x = r - l + 1;\n        (res *= (qkp(m, x) - qkp(m - 1, x))) %= mod;\n        (ans += res) %= mod;\n    &#125;\n    print((ans + mod) % mod, &#39;\\n&#39;);\n    return 0;\n&#125;\n&#125; // namespace XSC062\n#undef int</code></pre>\n</details>\n",
            "tags": [
                "二分",
                "容斥原理"
            ]
        }
    ]
}