<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://xsc062.netlify.app</id>
    <title> • Posts by &#34;容斥原理&#34; tag</title>
    <link href="https://xsc062.netlify.app" />
    <updated>2025-05-10T02:18:21.000Z</updated>
    <category term="并查集" />
    <category term="斜率优化" />
    <category term="悬线法" />
    <category term="哈希" />
    <category term="字典树" />
    <category term="DP" />
    <category term="单调队列" />
    <category term="分治" />
    <category term="二分图" />
    <category term="CRT / exCRT" />
    <category term="排列组合" />
    <category term="网络流" />
    <category term="费用流" />
    <category term="二分" />
    <category term="上下界网络流" />
    <category term="容斥原理" />
    <category term="线段树" />
    <category term="树状数组" />
    <category term="区间 DP" />
    <category term="构造" />
    <category term="Tarjan" />
    <category term="数据结构" />
    <category term="下饭" />
    <category term="LCA" />
    <category term="倍增" />
    <category term="鸽巢原理" />
    <category term="概率期望" />
    <category term="调和级数" />
    <category term="差分" />
    <category term="思维" />
    <category term="树形 DP" />
    <category term="最小生成树" />
    <category term="SAM" />
    <category term="状压" />
    <category term="分块" />
    <category term="可持久化" />
    <category term="笛卡尔树" />
    <category term="高维前缀和" />
    <category term="闲话" />
    <category term="欧拉回路" />
    <category term="树链剖分" />
    <category term="长链剖分" />
    <category term="KMP" />
    <category term="border" />
    <category term="字符串" />
    <category term="AC 自动机" />
    <category term="SA" />
    <category term="数学" />
    <category term="树上差分" />
    <category term="FWT" />
    <category term="堆" />
    <category term="树的重心" />
    <category term="二项式定理" />
    <category term="二项式反演" />
    <category term="贪心" />
    <category term="均摊" />
    <category term="计数" />
    <category term="优化建图" />
    <category term="反悔贪心" />
    <category term="调整法" />
    <category term="背包" />
    <category term="博弈论" />
    <category term="DP 优化" />
    <category term="虚树" />
    <category term="点分治" />
    <category term="WQS 二分" />
    <category term="闵可夫斯基和" />
    <category term="slope trick" />
    <category term="四边形不等式" />
    <category term="暴力" />
    <category term="状压 DP" />
    <category term="组合数学" />
    <category term="支配对" />
    <category term="DDP" />
    <category term="平衡树" />
    <category term="容斥" />
    <category term="猫树" />
    <category term="Kruskal 重构树" />
    <category term="李超线段树" />
    <entry>
        <id>https://xsc062.netlify.app/20250510/</id>
        <title>杂题</title>
        <link rel="alternate" href="https://xsc062.netlify.app/20250510/"/>
        <content type="html">&lt;p&gt;啊啊。小封条。&lt;/p&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;a---pass-to-next&#34;&gt;A - Pass to Next&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/arc124/tasks/arc124_e&#34; class=&#34;uri&#34;&gt;https://atcoder.jp/contests/arc124/tasks/arc124_e&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;感觉其他一些题解讲得不是特别清楚，这里参考了 &lt;a href=&#34;https://blog.csdn.net/weixin_43960287/article/details/119140590&#34;&gt;XJX 的文章&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;要求的答案是 &lt;span class=&#34;math inline&#34;&gt;\(\prod a&amp;#39;_i\)&lt;/span&gt;，&lt;mark&gt;发现运算是乘法，比较怪；由此考虑转化为方案数，也就是假设每个人有 &lt;span class=&#34;math inline&#34;&gt;\(a&amp;#39;_i\)&lt;/span&gt; 个互不相同的球，每个人在其中选出恰好一个的方案数&lt;/mark&gt;。&lt;/p&gt;
&lt;p&gt;考虑 DP。发现每个人手上的球分为『自己的』和『左边的人传过来的』两种类型；&lt;mark&gt;显然第二种会有来自上一个人的限制，考虑把第二种在上一个人就完成求解&lt;/mark&gt;。具体地，设 &lt;span class=&#34;math inline&#34;&gt;\(f_{i,0}\)&lt;/span&gt; 表示第 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 个人选取自己的球，但只记录 &lt;span class=&#34;math inline&#34;&gt;\(1\sim i-1\)&lt;/span&gt; 的方案；&lt;span class=&#34;math inline&#34;&gt;\(f_{i,1}\)&lt;/span&gt; 表示第 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 个人选取第 &lt;span class=&#34;math inline&#34;&gt;\(i-1\)&lt;/span&gt; 个人的球，并记入答案的方案。&lt;em&gt;你可能需要注意到：最后一个被记入方案的球来自第 &lt;span class=&#34;math inline&#34;&gt;\(i-1\)&lt;/span&gt; 个人&lt;/em&gt;。&lt;/p&gt;
&lt;p&gt;但这样会有个小问题。我们让所有人多往右边传一个球，那么在我们的这种分割方法看来是不一样的局面；但实际上它们是等价的。从每个人传出了多少个球（设为 &lt;span class=&#34;math inline&#34;&gt;\(x_i\)&lt;/span&gt;）的角度来看，对于 &lt;span class=&#34;math inline&#34;&gt;\(\min\{x_n\}\ne 0\)&lt;/span&gt;，只需要不断执行 &lt;span class=&#34;math inline&#34;&gt;\(\forall\, x_i\gets x_i-1\)&lt;/span&gt; 就可以在局面不变的情况下使 &lt;span class=&#34;math inline&#34;&gt;\(\min\{x_n\}\ne 0\)&lt;/span&gt;。这是在说，可以让 &lt;span class=&#34;math inline&#34;&gt;\(\min\{x_n\}\ne 0\)&lt;/span&gt; 的方案和终局一一对应。&lt;/p&gt;
&lt;p&gt;发现可以容斥：钦定 &lt;span class=&#34;math inline&#34;&gt;\(x_i\ge 1\)&lt;/span&gt;，也就是每个人必须往右传至少一个，相似地算一遍就能得到非法方案。&lt;/p&gt;
&lt;p&gt;考虑转移，令 &lt;span class=&#34;math inline&#34;&gt;\(x_i\)&lt;/span&gt; 可选最小值为 &lt;span class=&#34;math inline&#34;&gt;\(l\)&lt;/span&gt;，有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class=&#34;math inline&#34;&gt;\(f_{i+1,0}\gets f_{i,0}\)&lt;/span&gt;：将第 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 个人未被记入的自己的球记入，球数可能为 &lt;span class=&#34;math inline&#34;&gt;\([0,a_i-l]\)&lt;/span&gt;。等差数列求和即可。&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;math inline&#34;&gt;\(f_{i+1,0}\gets f_{i,1}\)&lt;/span&gt;：没有球需要被记入，但是这种情况对应多种 &lt;span class=&#34;math inline&#34;&gt;\(x_i\)&lt;/span&gt;。具体地，&lt;span class=&#34;math inline&#34;&gt;\(x_i\in [l,a_i]\)&lt;/span&gt;。共有 &lt;span class=&#34;math inline&#34;&gt;\(a_i-l+1\)&lt;/span&gt; 种方案。&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;math inline&#34;&gt;\(f_{i+1,1}\gets f_{i,0}\)&lt;/span&gt;：将第 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 个人的 &lt;span class=&#34;math inline&#34;&gt;\(a_i\)&lt;/span&gt; 个球分给 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 和 &lt;span class=&#34;math inline&#34;&gt;\(i+1\)&lt;/span&gt;。共有 &lt;span class=&#34;math inline&#34;&gt;\(x_i\cdot (a_i-x_i)\)&lt;/span&gt; 种可能，也就是 &lt;span class=&#34;math inline&#34;&gt;\(\left(a_i\cdot \sum_{x_i=l}^{a_i} x_i\right)-\left(\sum_{x_i=l}^{a_i}{x_i}^2\right)\)&lt;/span&gt; 种方案。&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;math inline&#34;&gt;\(f_{i+1,1}\gets f_{i,1}\)&lt;/span&gt;：将第 &lt;span class=&#34;math inline&#34;&gt;\(i+1\)&lt;/span&gt; 个人得到的第 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 个人的球记入，同第一条。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;破环为链，分别钦定第一个人是用自己的球还是上一个人的球来解决问题（必须对于两种可能性分开计算；否则就不知道答案应该取 &lt;span class=&#34;math inline&#34;&gt;\(f_{n,0}\)&lt;/span&gt; 还是 &lt;span class=&#34;math inline&#34;&gt;\(f_{n,1}\)&lt;/span&gt;）。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int mod = 998244353, inv2 = (mod + 1) &amp;gt;&amp;gt; 1, inv6 = 166374059;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#endif
    int n;
    std::cin &amp;gt;&amp;gt; n;
    std::vector&amp;lt;long long&amp;gt; a(n);
    for (int i = 1; i &amp;lt;= n; ++i)
        std::cin &amp;gt;&amp;gt; a[i % n];
    auto sum = [&amp;amp;](long long r) &amp;#123;
        return r * (r + 1) % mod * inv2 % mod;
    &amp;#125;;
    auto sum2 = [&amp;amp;](long long r) &amp;#123;
        return r * (r + 1) % mod * (2 * r % mod + 1) % mod * inv6 % mod;
    &amp;#125;;
    std::vector&amp;lt;std::vector&amp;lt;long long&amp;gt; &amp;gt; f0(n, std::vector&amp;lt;long long&amp;gt; (2)), f1(n, std::vector&amp;lt;long long&amp;gt; (2));
    auto calc = [&amp;amp;](long long l, std::vector&amp;lt;std::vector&amp;lt;long long&amp;gt; &amp;gt; &amp;amp;f) &amp;#123;
        f[0][0] = 1ll;
        for (int i = 0; i &amp;lt; n; ++i) &amp;#123;
            int j = (i + 1) % n;
            f[j][0] = f[i][0] * sum(a[i] - l) % mod;
            (f[j][0] += f[i][1] * (a[i] - l + 1)) %= mod;
            f[j][1] = f[i][0] * (a[i] * sum(a[i]) % mod - sum2(a[i])) % mod;
            (f[j][1] += f[i][1] * sum(a[i]) % mod) %= mod;
            // printf(&amp;quot;0, l = %lld, f[%d]: %lld / %lld\n&amp;quot;, l, j, f[j][0], f[j][1]);
        &amp;#125;
        auto res(f[0][0]);
        f.assign(n, std::vector&amp;lt;long long&amp;gt; (2));
        f[0][1] = 1ll;
        for (int i = 0; i &amp;lt; n; ++i) &amp;#123;
            int j = (i + 1) % n;
            f[j][0] = f[i][0] * sum(a[i] - l) % mod;
            (f[j][0] += f[i][1] * (a[i] - l + 1)) %= mod;
            f[j][1] = f[i][0] * (a[i] * sum(a[i]) % mod - sum2(a[i])) % mod;
            (f[j][1] += f[i][1] * sum(a[i]) % mod) %= mod;
            // printf(&amp;quot;1, l = %lld, f[%d]: %lld / %lld\n&amp;quot;, l, j, f[j][0], f[j][1]);
        &amp;#125;
        return (res + f[0][1]) % mod;
    &amp;#125;;
    std::cout &amp;lt;&amp;lt; (calc(0, f0) + mod - calc(1, f1)) % mod &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;b---绿宝石之岛&#34;&gt;B - 绿宝石之岛&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://loj.ac/p/6406&#34; class=&#34;uri&#34;&gt;https://loj.ac/p/6406&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;因为只关心最终状态，原题可以转化为：将 &lt;span class=&#34;math inline&#34;&gt;\(d\)&lt;/span&gt; 分成 &lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt; 个非负整数，前 &lt;span class=&#34;math inline&#34;&gt;\(r\)&lt;/span&gt; 大数之和的期望（当然你需要加上初始的 &lt;span class=&#34;math inline&#34;&gt;\(r\)&lt;/span&gt; 个）。&lt;/p&gt;
&lt;p&gt;关于非负整数拆分：设 &lt;span class=&#34;math inline&#34;&gt;\(f_{i,j}\)&lt;/span&gt; 表示将 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 分成 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; 个 &lt;strong&gt;非负整数&lt;/strong&gt; 的方案，钦定其中恰有 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 个 &lt;strong&gt;正整数&lt;/strong&gt; 进行转移，给这 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 个数先分一个 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt;，则 &lt;span class=&#34;math inline&#34;&gt;\(f_{i,j}=\sum\limits_{k=0}^{\min(i,j)} C_j^k\cdot f_{i-k,k}\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;再设 &lt;span class=&#34;math inline&#34;&gt;\(g_{i,j}\)&lt;/span&gt; 表示将 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 分成 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; 个非负整数的所有方案中、前 &lt;span class=&#34;math inline&#34;&gt;\(r\)&lt;/span&gt; 大的数之和。类似地，有 &lt;span class=&#34;math inline&#34;&gt;\(g_{i,j}=\sum\limits_{k=0}^{\min(i,j)} C_j^k\cdot (g_{i-k,k}+\min(k,r)\cdot f_{i-k,k})\)&lt;/span&gt;。其中，&lt;span class=&#34;math inline&#34;&gt;\(\min(k,r)\)&lt;/span&gt; 的来源是，只有 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 个数有值，前 &lt;span class=&#34;math inline&#34;&gt;\(r\)&lt;/span&gt; 大的数一定在这 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 个数里面。&lt;/p&gt;
&lt;p&gt;答案为 &lt;span class=&#34;math inline&#34;&gt;\(\dfrac {g_{d,n}}{f_{d,n}}+r\)&lt;/span&gt;，复杂度 &lt;span class=&#34;math inline&#34;&gt;\(O(n^3)\)&lt;/span&gt;。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#endif
    int n, d, r;
    std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; d &amp;gt;&amp;gt; r;
    using arr = std::vector&amp;lt;double&amp;gt;;
    std::vector&amp;lt;arr&amp;gt; f(d + 1, arr(n + 1)), g(d + 1, arr(n + 1)), C(n + 1, arr(n + 1));
    for (int i = 0; i &amp;lt;= n; ++i) &amp;#123;
        C[i][0] = 1.;
        for (int j = 1; j &amp;lt;= i; ++j)
            C[i][j] = C[i - 1][j - 1] + C[i - 1][j];
    &amp;#125;
    f[0].assign(n + 1, 1.);
    for (int i = 1; i &amp;lt;= d; ++i)
        for (int j = 1; j &amp;lt;= n; ++j) &amp;#123;
            for (int k = 1; k &amp;lt;= i &amp;amp;&amp;amp; k &amp;lt;= j; ++k) &amp;#123;
                f[i][j] += C[j][k] * f[i - k][k];
                g[i][j] += C[j][k] * (g[i - k][k] + std::min(k, r) * f[i - k][k]);
                // printf(&amp;quot;  k = %d, %.0lf + %.0lf\n&amp;quot;, k, C[j][k] * g[i - k][k], std::min(k, r) * f[i - k][k]);
            &amp;#125;
            // printf(&amp;quot;f[%d][%d] = %.0lf, g[%d][%d] = %.0lf\n&amp;quot;, i, j, f[i][j], i, j, g[i][j]);
        &amp;#125;
    std::cout &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(8) &amp;lt;&amp;lt; g[d][n] / f[d][n] + r &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;c---uddered-but-not-herd-g&#34;&gt;C - Uddered but not Herd G&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P7296&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P7296&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;给每个字母分配一个标号 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt;，那么最小段数就是 &lt;span class=&#34;math inline&#34;&gt;\(\sum \left[x_i\ge x_{i+1}\right]\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;考虑状压完成映射操作，令 &lt;span class=&#34;math inline&#34;&gt;\(f_{s}\)&lt;/span&gt; 表示给标号 &lt;span class=&#34;math inline&#34;&gt;\(1\sim |s|\)&lt;/span&gt; 分配字母后，占用字符集 &lt;span class=&#34;math inline&#34;&gt;\(s\)&lt;/span&gt; 的方案数，那么就能 &lt;span class=&#34;math inline&#34;&gt;\(O(1)\)&lt;/span&gt; 得到贡献——只需预处理出 &lt;span class=&#34;math inline&#34;&gt;\(f_{c, s}\)&lt;/span&gt; 表示分配到字母 &lt;span class=&#34;math inline&#34;&gt;\(c\)&lt;/span&gt; 时，已经先给 &lt;span class=&#34;math inline&#34;&gt;\(s\)&lt;/span&gt; 中字母分配了更小标号时的贡献。&lt;/p&gt;
&lt;p&gt;注意字符集大小只有 &lt;span class=&#34;math inline&#34;&gt;\(20\)&lt;/span&gt;，可以 &lt;span class=&#34;math inline&#34;&gt;\(O(|S|\cdot 2^{|S|})\)&lt;/span&gt; 解决问题，&lt;mark&gt;注意到预处理的内容是类高维前缀最值的形式，可以递推降低复杂度&lt;/mark&gt;。&lt;/p&gt;
&lt;details&gt;
&lt;pre data-line=&#34;26-28&#34; class=&#34;cpp language-cpp&#34;&gt;&lt;code data-line=&#34;26-28&#34; class=&#34;cpp language-cpp&#34;&gt;#include &amp;lt;bits/stdc++.h&gt;
const int inf = 0x3f3f3f3f;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&#34;.in&#34;, &#34;r&#34;, stdin);
    std::freopen(&#34;.out&#34;, &#34;w&#34;, stdout);
#endif
    int n;
    std::string t;
    std::cin &gt;&gt; t, n = (int)t.length(), t = &#34;#&#34; + t;
    std::vector&amp;lt;int&gt; a, tag(26, -1), s(n + 1);
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        if (tag[t[i] - &#39;a&#39;] == -1)
            tag[t[i] - &#39;a&#39;] = (int)a.size(), a.push_back(t[i] - &#39;a&#39;);
        s[i] = tag[t[i] - &#39;a&#39;];
    &amp;#125;
    int m = (int)a.size(), siz = 1 &amp;lt;&amp;lt; m;
    std::vector&amp;lt;std::vector&amp;lt;int&gt; &gt; cnt(m, std::vector&amp;lt;int&gt; (m));
    for (int i = 1; i &amp;lt; n; ++i)
        ++cnt[s[i]][s[i + 1]];
    std::vector&amp;lt;std::vector&amp;lt;int&gt; &gt; g(m, std::vector&amp;lt;int&gt; (siz));
    for (int i = 0; i &amp;lt; m; ++i)
        for (int k = 0; k &amp;lt; m; ++k) // 注意这里相当于是钦定从 k 处转移
            for (int j = (1 &amp;lt;&amp;lt; k); j &amp;lt; (2 &amp;lt;&amp;lt; k); ++j) // 枚举的是 k 位为 1 的所有数；这两层循环的复杂度为 O(siz)
                g[i][j] = g[i][j ^ (1 &amp;lt;&amp;lt; k)] + cnt[i][k]; // 目的是此处的内存连续访问优化，把 ^ 看作 - 应该就能理解为什么第二维是连续的
    std::vector&amp;lt;int&gt; f(siz, inf);
    f[0] = 1;
    for (int i = 1; i &amp;lt; siz; ++i)
        for (int j = 0; j &amp;lt; m; ++j)
            if ((i &gt;&gt; j) &amp; 1)
                f[i] = std::min(f[i], f[i ^ (1 &amp;lt;&amp;lt; j)] + g[j][i]);
    std::cout &amp;lt;&amp;lt; f[siz - 1] &amp;lt;&amp;lt; &#39;\n&#39;;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;d---min-max-subarrays-p&#34;&gt;D - Min Max Subarrays P&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P11845&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P11845&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;先考虑 &lt;span class=&#34;math inline&#34;&gt;\(01\)&lt;/span&gt; 序列的答案：如果序列中存在相邻的 &lt;span class=&#34;math inline&#34;&gt;\(2\)&lt;/span&gt; 个 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt;，总能保证最后的一个是 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;如果序列中存在 &lt;span class=&#34;math inline&#34;&gt;\(\ge 3\)&lt;/span&gt; 个 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt;，可以牺牲其中的一些使得 &lt;span class=&#34;math inline&#34;&gt;\(2\)&lt;/span&gt; 个 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt; 相邻。&lt;/p&gt;
&lt;p&gt;当序列中只有 &lt;span class=&#34;math inline&#34;&gt;\(2\)&lt;/span&gt; 个 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt; 时，只有因为剩下的 &lt;span class=&#34;math inline&#34;&gt;\(0\)&lt;/span&gt; 不太够，导致我们无法随意『上下其手』时不能将 &lt;span class=&#34;math inline&#34;&gt;\(2\)&lt;/span&gt; 个 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt; 挪到一起。&lt;/p&gt;
&lt;p&gt;令两个 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt; 为序列最大值与次大值，暴搜处理序列长度较小的情况，剩下的直接用奇偶性判断两个 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt; 取哪个。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;a---mst-on-line&#34;&gt;A - MST on Line++&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/arc167/tasks/arc167_c&#34; class=&#34;uri&#34;&gt;https://atcoder.jp/contests/arc167/tasks/arc167_c&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;相当于把 &lt;span class=&#34;math inline&#34;&gt;\(a\)&lt;/span&gt; 打乱然后处理原问题。考虑每个 &lt;span class=&#34;math inline&#34;&gt;\(a_i\)&lt;/span&gt; 的贡献次数。模拟 Kruskal 连边，从小到大把点 &lt;span class=&#34;math inline&#34;&gt;\(a_i\)&lt;/span&gt; 加入图，&lt;span class=&#34;math inline&#34;&gt;\(a_i\)&lt;/span&gt; 可以向 &lt;span class=&#34;math inline&#34;&gt;\(a_{[i-K,i+K]}\)&lt;/span&gt; 内所有连通块连边。&lt;/p&gt;
&lt;p&gt;连通块数量当且仅当 &lt;span class=&#34;math inline&#34;&gt;\([i-K,i)\)&lt;/span&gt; 内最靠右的点和 &lt;span class=&#34;math inline&#34;&gt;\((i, i+K]\)&lt;/span&gt; 内最靠左的点距离 &lt;span class=&#34;math inline&#34;&gt;\(&amp;gt;K\)&lt;/span&gt; 时为 &lt;span class=&#34;math inline&#34;&gt;\(2\)&lt;/span&gt;，其余情况为 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;但要是从这个角度想这个题就不太好做了。正确的想法应该是&lt;mark&gt;拆分为『若 &lt;span class=&#34;math inline&#34;&gt;\([i-K,i)\)&lt;/span&gt; 中有点，贡献次数 &lt;span class=&#34;math inline&#34;&gt;\(+1\)&lt;/span&gt;』和『若 &lt;span class=&#34;math inline&#34;&gt;\((i,i+K]\)&lt;/span&gt; 中有点 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; 满足 &lt;span class=&#34;math inline&#34;&gt;\([j-K,j)\)&lt;/span&gt; 中无点，贡献次数 &lt;span class=&#34;math inline&#34;&gt;\(+1\)&lt;/span&gt;』&lt;/mark&gt;。对于第一个问题，贡献次数将前 &lt;span class=&#34;math inline&#34;&gt;\(i-1\)&lt;/span&gt; 大的数分配至少一个到 &lt;span class=&#34;math inline&#34;&gt;\([i-K,i)\)&lt;/span&gt; 中的方案数；对于第二个问题，枚举 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt;，贡献次数为将前 &lt;span class=&#34;math inline&#34;&gt;\(i-1\)&lt;/span&gt; 大的数分配到 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; 和 &lt;span class=&#34;math inline&#34;&gt;\([1,j-K)\cup (j, n]\)&lt;/span&gt; 中的方案数。&lt;/p&gt;
&lt;details&gt;
&lt;p&gt;实现的时候千万注意循环变量枚举的是位置还是值！不然你会调得很痛苦。&lt;/p&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int mod = 998244353;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;03-max-01.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#endif
    int n, k;
    std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; k;
    std::vector&amp;lt;int&amp;gt; a(n + 1);
    for (int i = 1; i &amp;lt;= n; ++i)
        std::cin &amp;gt;&amp;gt; a[i];
    std::sort(a.begin() + 1, a.end());
    std::vector&amp;lt;long long&amp;gt; fac(n + 1), inv(n + 1);
    fac[0] = inv[0] = 1ll;
    for (int i = 1; i &amp;lt;= n; ++i)
        fac[i] = fac[i - 1] * i % mod;
    auto qkp = [](long long x, int y) &amp;#123;
        auto res(1ll);
        for (; y; (x *= x) %= mod, y &amp;gt;&amp;gt;= 1)
            if (y &amp;amp; 1)
                (res *= x) %= mod;
        return res;
    &amp;#125;;
    inv[n] = qkp(fac[n], mod - 2);
    for (int i = n - 1; i; --i)
        inv[i] = inv[i + 1] * (i + 1) % mod;
    auto A = [&amp;amp;](int n, int m) &amp;#123;
        if (n &amp;lt; m)
            return 0ll;
        return fac[n] * inv[n - m] % mod;
    &amp;#125;;
    auto C = [&amp;amp;](int n, int m) &amp;#123;
        return A(n, m) * inv[m] % mod;
    &amp;#125;;
    long long res = 0ll;
    for (int i = 2; i &amp;lt;= n; ++i) &amp;#123;
        for (int j = 1; j &amp;lt;= n; ++j)
            (res += a[i] * (fac[n - 1] + mod - A(n - 1 - (j - std::max(1, j - k)), i - 1) * fac[n - i] % mod) % mod) %= mod;
        for (int j = 2; j &amp;lt;= n; ++j)
            (res += a[i] * C(i - 1, i - 2) % mod * C(j - std::max(1, j - k), 1) % mod * A(n - (j - std::max(1, j - k) + 1), i - 2) % mod * fac[n - i] % mod) %= mod;
    &amp;#125;
    std::cout &amp;lt;&amp;lt; res &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;b---existence-counting&#34;&gt;B - Existence Counting&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/arc174/tasks/arc174_e&#34; class=&#34;uri&#34;&gt;https://atcoder.jp/contests/arc174/tasks/arc174_e&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;发现可以分类讨论。假设 &lt;span class=&#34;math inline&#34;&gt;\(a&amp;#39;\)&lt;/span&gt; 中第一个异于 &lt;span class=&#34;math inline&#34;&gt;\(a\)&lt;/span&gt; 的位置为 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt;，&lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 在 &lt;span class=&#34;math inline&#34;&gt;\(a\)&lt;/span&gt; 中位置为 &lt;span class=&#34;math inline&#34;&gt;\(pos_x\)&lt;/span&gt;（不存在则 &lt;span class=&#34;math inline&#34;&gt;\(pos_x=k+1\)&lt;/span&gt;）。令 &lt;span class=&#34;math inline&#34;&gt;\(f_i\)&lt;/span&gt; 为若 &lt;span class=&#34;math inline&#34;&gt;\(1\sim i-1\)&lt;/span&gt; 均相同，&lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 位置可选的选项数。则 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 出现的次数：&lt;/p&gt;
&lt;table&gt;
&lt;colgroup&gt;
&lt;col style=&#34;width: 25%&#34; /&gt;
&lt;col style=&#34;width: 25%&#34; /&gt;
&lt;col style=&#34;width: 25%&#34; /&gt;
&lt;col style=&#34;width: 25%&#34; /&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr class=&#34;header&#34;&gt;
&lt;th style=&#34;text-align: center;&#34;&gt;&lt;/th&gt;
&lt;th style=&#34;text-align: center;&#34;&gt;&lt;span class=&#34;math inline&#34;&gt;\(pos_x&amp;lt;i\)&lt;/span&gt;&lt;/th&gt;
&lt;th style=&#34;text-align: center;&#34;&gt;&lt;span class=&#34;math inline&#34;&gt;\(pos_x=i\)&lt;/span&gt;&lt;/th&gt;
&lt;th style=&#34;text-align: center;&#34;&gt;&lt;span class=&#34;math inline&#34;&gt;\(pos_x&amp;gt;i,i&amp;lt;k\)&lt;/span&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;&lt;span class=&#34;math inline&#34;&gt;\(x\le a_i\)&lt;/span&gt;&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;&lt;span class=&#34;math inline&#34;&gt;\(1+f_i\cdot A_{n-i}^{k-i}\)&lt;/span&gt;&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;&lt;span class=&#34;math inline&#34;&gt;\(f_i\cdot C_{k-i}^1\cdot A_{n-i-1}^{k-i-1}\)&lt;/span&gt;&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;&lt;span class=&#34;math inline&#34;&gt;\((f_i-1)\cdot C_{k-i}^1\cdot A_{n-i-1}^{k-i-1}+A_{n-i}^{k-i}\)&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;&lt;span class=&#34;math inline&#34;&gt;\(x&amp;gt;a_i\)&lt;/span&gt;&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;&lt;span class=&#34;math inline&#34;&gt;\(f_i\cdot A_{n-i}^{k-i}\)&lt;/span&gt;&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;&lt;span class=&#34;math inline&#34;&gt;\(0\)&lt;/span&gt;&lt;/td&gt;
&lt;td style=&#34;text-align: center;&#34;&gt;&lt;span class=&#34;math inline&#34;&gt;\(f_i\cdot C_{k-i}^1\cdot A_{n-i-1}^{k-i-1}\)&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;故，对于任意 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt;，答案为：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
\begin{aligned}
&amp;amp;1+\left(\sum_{i=pos_x+1}^k f_i\cdot A_{n-i}^{k-i}\right)
+\sum_{i=1}^{pos_x} (f_i-[x&amp;lt; a_i])\cdot C_{k-i}^1\cdot A_{n-i-1}^{k-i-1}+[x&amp;lt; a_i]\cdot A_{n-i}^{k-i}\\
=&amp;amp;1+\left(\sum_{i=pos_x+1}^k f_i\cdot A_{n-i}^{k-i}\right)
+\left(\sum_{i=1}^{pos_x} f_i\cdot C_{k-i}^1\cdot A_{n-i-1}^{k-i-1}\right)+\sum_{i=1,a_i&amp;gt; x}^{pos_x}A_{n-i}^{k-i}-C_{k-i}^1\cdot A_{n-i-1}^{k-i-1}\\
\end{aligned}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;预处理出 &lt;span class=&#34;math inline&#34;&gt;\(f_i=\sum\limits_{j=i+1}^k [a_j&amp;lt; a_i]\)&lt;/span&gt;（需要数据结构）、&lt;span class=&#34;math inline&#34;&gt;\(g_i=\sum\limits_{j=1}^i f_j\cdot A_{n-j}^{k-j}\)&lt;/span&gt; 和 &lt;span class=&#34;math inline&#34;&gt;\(h_j=\sum\limits_{j=1}^i f_i\cdot C_{k-i}^1\cdot A_{n-i-1}^{k-i-1}\)&lt;/span&gt;，再用数据结构计算 &lt;span class=&#34;math inline&#34;&gt;\(\sum\limits_{i=1,a_i&amp;gt;x}^{pos_x}C_{k-i}^1\cdot A_{n-i-1}^{k-i-1} - A_{n-i}^{k-i}\)&lt;/span&gt; 即可。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int mod = 998244353;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#endif
    int n, k;
    std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; k;
    std::vector&amp;lt;int&amp;gt; a(k + 1), p(n + 1, k + 1);
    for (int i = 1; i &amp;lt;= k; ++i)
        std::cin &amp;gt;&amp;gt; a[i], p[a[i]] = i;
    std::vector&amp;lt;long long&amp;gt; fac(n + 1), inv(n + 1);
    &amp;#123;
        fac[0] = inv[0] = 1ll;
        for (int i = 1; i &amp;lt;= n; ++i)
            fac[i] = fac[i - 1] * i % mod;
        auto qkp = [](long long x, int y) &amp;#123;
            auto res(1ll);
            for (; y; (x *= x) %= mod, y &amp;gt;&amp;gt;= 1)
                if (y &amp;amp; 1)
                    (res *= x) %= mod;
            return res;
        &amp;#125;;
        inv[n] = qkp(fac[n], mod - 2);
        for (int i = n - 1; i; --i)
            inv[i] = inv[i + 1] * (i + 1) % mod;
    &amp;#125;
    auto A = [&amp;amp;](int n, int m) &amp;#123;
        if (n &amp;lt; m || m &amp;lt; 0)
            return 0ll;
        return fac[n] * inv[n - m] % mod;
    &amp;#125;;
    std::vector&amp;lt;long long&amp;gt; f(k + 1), g(k + 1), h(k + 1);
    std::vector&amp;lt;long long&amp;gt; bit(n + 1);
    auto lowbit = [](int x) &amp;#123;
        return x &amp;amp; -x;
    &amp;#125;;
    auto add = [&amp;amp;](int x, int v) &amp;#123;
        for (; x &amp;lt;= n; x += lowbit(x))
            (bit[x] += v) %= mod;
        return;
    &amp;#125;;
    auto ask = [&amp;amp;](int x) &amp;#123;
        auto res(0ll);
        for (; x; x -= lowbit(x))
            (res += bit[x]) %= mod;
        return res;
    &amp;#125;;
    for (int i = 1; i &amp;lt;= n; ++i)
        if (p[i] == k + 1)
            add(i, 1);
    for (int i = k; i; --i)
        f[i] = ask(a[i]), add(a[i], 1);
    for (int i = 1; i &amp;lt;= k; ++i) &amp;#123;
        g[i] = (g[i - 1] + f[i] * A(n - i, k - i)) % mod;
        h[i] = (h[i - 1] + f[i] * (k - i) % mod * A(n - i - 1, k - i - 1)) % mod;
        // printf(&amp;quot;%d: f = %lld, g = %lld, h = %lld\n&amp;quot;, i, f[i], g[i], h[i]);
    &amp;#125;
    std::vector&amp;lt;long long&amp;gt; res(n + 1);
    bit.assign(n + 1, 0ll);
    auto s(0ll);
    for (int i = 1; i &amp;lt;= k; ++i) &amp;#123;
        // printf(&amp;quot;%d: %lld + %lld + %lld\n&amp;quot;, a[i], 1 + g[k] - g[i], h[i], s - ask(a[i]));
        res[a[i]] = (1 + g[k] - g[i] + h[i] + (s - ask(a[i]))) % mod;
        res[a[i]] = (res[a[i]] + mod) % mod;
        (s += A(n - i, k - i) - (k - i) * A(n - i - 1, k - i - 1)) %= mod;
        add(a[i], (A(n - i, k - i) - (k - i) * A(n - i - 1, k - i - 1)) % mod);
    &amp;#125;
    for (int i = 1; i &amp;lt;= n; ++i)
        if (p[i] == k + 1) &amp;#123;
            res[i] = (h[k] + (s - ask(i))) % mod;
            res[i] = (res[i] + mod) % mod;
        &amp;#125;
    for (int x = 1; x &amp;lt;= n; ++x)
        std::cout &amp;lt;&amp;lt; res[x] &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;c---1-loop-bubble-sort&#34;&gt;C - 1 Loop Bubble Sort&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/arc187/tasks/arc187_c&#34; class=&#34;uri&#34;&gt;https://atcoder.jp/contests/arc187/tasks/arc187_c&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;首先是被考烂了的：对序列进行一次冒泡排序，等价于将序列在前缀最大值处分段，并将其从段首移到段尾；且满足排序前为前缀最大值的元素，排序后仍为前缀最大值。&lt;/p&gt;
&lt;p&gt;考虑用 DP 解决问题。注意状态要从 &lt;span class=&#34;math inline&#34;&gt;\(P\)&lt;/span&gt; 的角度出发——假如 &lt;span class=&#34;math inline&#34;&gt;\(Q\)&lt;/span&gt; 中不存在 &lt;span class=&#34;math inline&#34;&gt;\(-1\)&lt;/span&gt;，发现也需要 DP。此时再设计有关 &lt;span class=&#34;math inline&#34;&gt;\(Q\)&lt;/span&gt; 的状态就很扯淡了，考虑令 &lt;span class=&#34;math inline&#34;&gt;\(f_{i,j}\)&lt;/span&gt; 表示 &lt;span class=&#34;math inline&#34;&gt;\(P\)&lt;/span&gt; 中直到第 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 位的前缀最大值为 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; 的方案数。为什么把前缀最大值作为状态呢？因为它可以表示分段；同时限制段间数的取值。具体地，考虑转移：&lt;/p&gt;
&lt;ol type=&#34;1&#34;&gt;
&lt;li&gt;若令 &lt;span class=&#34;math inline&#34;&gt;\(P_i=j\)&lt;/span&gt;，则在 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 处分段。对应到 &lt;span class=&#34;math inline&#34;&gt;\(Q\)&lt;/span&gt; 中，&lt;span class=&#34;math inline&#34;&gt;\(i-1\)&lt;/span&gt; 位是上一个前缀最大值，那么这要求 &lt;span class=&#34;math inline&#34;&gt;\(Q_{i-1}&amp;lt;j\)&lt;/span&gt;，且 &lt;span class=&#34;math inline&#34;&gt;\(Q_{i-1}\)&lt;/span&gt; 是一个前缀最大值。也即：当 &lt;span class=&#34;math inline&#34;&gt;\(Q_{i-1}\ne -1\)&lt;/span&gt; 时，&lt;span class=&#34;math inline&#34;&gt;\(f_{i,j}\gets f_{i-1, Q_{i-1}}\)&lt;/span&gt;；否则，&lt;span class=&#34;math inline&#34;&gt;\(f_{i,j}\gets \sum\limits_{k&amp;lt;j} f_{i-1,k}\)&lt;/span&gt;。其中，二式都要求转移来源为前缀最大值。&lt;/li&gt;
&lt;li&gt;若令 &lt;span class=&#34;math inline&#34;&gt;\(P_i&amp;lt;j\)&lt;/span&gt;，则 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 在 &lt;span class=&#34;math inline&#34;&gt;\(Q\)&lt;/span&gt; 中恰好前移一位，即 &lt;span class=&#34;math inline&#34;&gt;\(Q_{i-1}=P_i&amp;lt;j\)&lt;/span&gt;。则当 &lt;span class=&#34;math inline&#34;&gt;\(Q_{i-1}\ne -1\)&lt;/span&gt; 时，该位确定，&lt;span class=&#34;math inline&#34;&gt;\(f_{i,j}\gets f_{i-1,j}\)&lt;/span&gt;；否则，&lt;span class=&#34;math inline&#34;&gt;\(Q_{i-1}\)&lt;/span&gt; 可选的值为 &lt;span class=&#34;math inline&#34;&gt;\(&amp;lt;j\)&lt;/span&gt; 的所有未选数（定值，可预处理）。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;关于初值，可以在 &lt;span class=&#34;math inline&#34;&gt;\(P\)&lt;/span&gt; 前加一个 &lt;span class=&#34;math inline&#34;&gt;\(0\)&lt;/span&gt; 作为排列的一部分（那么按照冒泡排序的规则 &lt;span class=&#34;math inline&#34;&gt;\(Q\)&lt;/span&gt; 的第一位也一定是 &lt;span class=&#34;math inline&#34;&gt;\(0\)&lt;/span&gt;）来处理就好了。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int mod = 998244353;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#endif
    int n;
    std::cin &amp;gt;&amp;gt; n;
    std::vector&amp;lt;int&amp;gt; q(n + 1), t(n + 1), c(n + 1), pos(n + 1);
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        std::cin &amp;gt;&amp;gt; q[i], c[i] = c[i - 1];
        if (q[i] == -1)
            ++c[i];
        else
            pos[q[i]] = i;
    &amp;#125;
    for (int i = 1; i &amp;lt; n; ++i) &amp;#123;
        // printf(&amp;quot;t[%d] = %d\n&amp;quot;, i, t[i]);
        if (!pos[i])
            for (int j = i + 1; j &amp;lt;= n; ++j)
                ++t[j];
    &amp;#125;
    std::vector&amp;lt;std::vector&amp;lt;long long&amp;gt; &amp;gt; f(n + 1, std::vector&amp;lt;long long&amp;gt; (n + 1)), s(n + 1, std::vector&amp;lt;long long&amp;gt; (n + 1));
    f[0][0] = 1ll;
    s[0].assign(n + 1, 1ll);
    for (int i = 1; i &amp;lt;= n; ++i)
        for (int j = 1; j &amp;lt;= n; ++j) &amp;#123;
            if (q[i - 1] == -1)
                f[i][j] = (s[i - 1][j - 1] + f[i - 1][j] * std::max(0, 1 + t[j] - c[i - 1])) % mod;
            else if (q[i - 1] &amp;lt; j)
                f[i][j] = (f[i - 1][q[i - 1]] + f[i - 1][j]) % mod;
            s[i][j] = s[i][j - 1];
            if (q[i] == j || !pos[j]) // 满足前缀最大值
                (s[i][j] += f[i][j]) %= mod;
            // printf(&amp;quot;f[%d][%d] = %lld\n&amp;quot;, i, j, f[i][j]);
        &amp;#125;
    std::cout &amp;lt;&amp;lt; f[n][n] &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;f---1.-intro&#34;&gt;(F - 1). Intro&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;给定一个大小为 &lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt; 的树，点有点权。给定 &lt;span class=&#34;math inline&#34;&gt;\(q\)&lt;/span&gt; 次操作，分为两种：&lt;/p&gt;
&lt;ol type=&#34;1&#34;&gt;
&lt;li&gt;&lt;code&gt;1 x&lt;/code&gt;：查询 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 的点权。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;2 x d v&lt;/code&gt; 对于所有距 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 不超过 &lt;span class=&#34;math inline&#34;&gt;\(d\)&lt;/span&gt; 的点，将它们的权值加上 &lt;span class=&#34;math inline&#34;&gt;\(v\)&lt;/span&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(n,q\le 10^5,d\le 20\)&lt;/span&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;由于 &lt;span class=&#34;math inline&#34;&gt;\(d\)&lt;/span&gt; 很小，我们可能需要枚举与 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 距离 &lt;span class=&#34;math inline&#34;&gt;\(0\sim d\)&lt;/span&gt; 的点进行修改；那么对距离 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 为 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 的点的更改存储在 &lt;span class=&#34;math inline&#34;&gt;\(f_{x,i}\)&lt;/span&gt;，查询 &lt;span class=&#34;math inline&#34;&gt;\(v\)&lt;/span&gt; 时就可以从 &lt;span class=&#34;math inline&#34;&gt;\(\sum\limits_i f_{fa(v,i),i}\)&lt;/span&gt; 求得答案。&lt;/p&gt;
&lt;p&gt;考虑修改。记 &lt;span class=&#34;math inline&#34;&gt;\(S_{x,d}\)&lt;/span&gt; 为距 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 为 &lt;span class=&#34;math inline&#34;&gt;\(d\)&lt;/span&gt; 的点集。&lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 子树内是好处理的，但子树外的呢？发现 &lt;span class=&#34;math inline&#34;&gt;\(S_{fa,d-1}\)&lt;/span&gt; 中 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 子树外的点，就是 &lt;span class=&#34;math inline&#34;&gt;\(fa\)&lt;/span&gt; 子树下、&lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 子树外距离 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 为 &lt;span class=&#34;math inline&#34;&gt;\(d\)&lt;/span&gt; 的所有点。&lt;/p&gt;
&lt;p&gt;由于所有 &lt;span class=&#34;math inline&#34;&gt;\(S_{fa(x,i),d-i}\)&lt;/span&gt; 无交，这可能满足我们每个待操作点被不重不漏加一次的要求。考虑将所有 &lt;span class=&#34;math inline&#34;&gt;\(S_{fa(x,i),d-i}\)&lt;/span&gt; 标记出来：&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&#34;1.png&#34; alt=&#34;粉色虚线框是待操作点集&#34; /&gt;&lt;figcaption&gt;粉色虚线框是待操作点集&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;然后我们可以一眼发现被叉的点和未被叉的待操作点是交错的！这意味着我们只需要再补充上所有 &lt;span class=&#34;math inline&#34;&gt;\(S_{fa(x,i),d-i-1}\)&lt;/span&gt; 即可（显然它们之间、它们和所有 &lt;span class=&#34;math inline&#34;&gt;\(S_{fa(x,i),d-i}\)&lt;/span&gt; 之间都不交）。&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&#34;2.png&#34; alt=&#34;虚线叉为 S_{fa(x,i),d-i-1}&#34; /&gt;&lt;figcaption&gt;虚线叉为 &lt;span class=&#34;math inline&#34;&gt;\(S_{fa(x,i),d-i-1}\)&lt;/span&gt;&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;此时就可以不重不漏。当然，也会存在一些细节：比如说 &lt;span class=&#34;math inline&#34;&gt;\(fa(x,i)\)&lt;/span&gt; 不存在之类。只需要在根节点 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt; 处将剩余的 &lt;span class=&#34;math inline&#34;&gt;\(S_{1,i\to 0}\)&lt;/span&gt; 全部更新即可。&lt;/p&gt;
&lt;p&gt;故每次修改操作只需要修改 &lt;span class=&#34;math inline&#34;&gt;\(O(d)\)&lt;/span&gt; 坨点。时间复杂度 &lt;span class=&#34;math inline&#34;&gt;\(O(qd)\)&lt;/span&gt;。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;f.-distance-to-the-path&#34;&gt;F. Distance to the Path&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://codeforces.com/problemset/problem/1749/F&#34; class=&#34;uri&#34;&gt;https://codeforces.com/problemset/problem/1749/F&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本例中将单点修改替换为路径修改；考虑树剖解决问题。&lt;/p&gt;
&lt;p&gt;对于路径上的所有点 &lt;span class=&#34;math inline&#34;&gt;\(u\)&lt;/span&gt;，容易发现只需要修改所有的 &lt;span class=&#34;math inline&#34;&gt;\(S_{u,d}\)&lt;/span&gt; 就可以完成对『&lt;strong&gt;一部分路径内侧的点&lt;/strong&gt;』的修改。这『一部分』，是因为不包括距离 LCA &lt;span class=&#34;math inline&#34;&gt;\(\le d\)&lt;/span&gt; 的点。&lt;/p&gt;
&lt;p&gt;而『&lt;strong&gt;另一部分路径内侧的点&lt;/strong&gt;（距 LCA &lt;span class=&#34;math inline&#34;&gt;\(\le d\)&lt;/span&gt;：见上一行说明）』及『&lt;strong&gt;路径外侧的点&lt;/strong&gt;（距 LCA &lt;span class=&#34;math inline&#34;&gt;\(\le d\)&lt;/span&gt;：因为路径在 LCA 子树内，LCA 能够到最远的外侧点）』，等价于『&lt;strong&gt;距 LCA &lt;span class=&#34;math inline&#34;&gt;\(\le d\)&lt;/span&gt; 的点&lt;/strong&gt;』，只需要把 LCA 代入上例中方式修改即可。&lt;/p&gt;
&lt;p&gt;修改路径上所有点 &lt;span class=&#34;math inline&#34;&gt;\(u\)&lt;/span&gt; 的 &lt;span class=&#34;math inline&#34;&gt;\(S_{u,d}\)&lt;/span&gt; 时，可以对所有 &lt;span class=&#34;math inline&#34;&gt;\(f_{*,i}\)&lt;/span&gt; 建立数据结构，由于只需要区间修改、单点查询，使用差分树状数组即可。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt; 
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#endif
    int n, m;
    std::cin &amp;gt;&amp;gt; n;
    std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; g(n + 1);
    for (int i = 1, x, y; i &amp;lt; n; ++i) &amp;#123;
        std::cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; y;
        g[x].push_back(y), g[y].push_back(x);
    &amp;#125;
    std::vector&amp;lt;int&amp;gt; siz(n + 1), dep(n + 1), fa(n + 1), son(n + 1);
    std::function&amp;lt;void(int, int)&amp;gt; DFS = [&amp;amp;](int x, int faa) &amp;#123;
        siz[x] = 1;
        for (auto i : g[x])
            if (i != faa) &amp;#123;
                fa[i] = x, dep[i] = dep[x] + 1;
                DFS(i, x);
                siz[x] += siz[i];
                if (siz[i] &amp;gt; siz[son[x]])
                    son[x] = i;
            &amp;#125;
        return;
    &amp;#125;;
    DFS(1, -1);
    std::vector&amp;lt;int&amp;gt; dfn(n + 1), top(n + 1);
    DFS = [&amp;amp;](int x, int toop) &amp;#123;
        static int now = 0;
        dfn[x] = ++now, top[x] = toop;
        if (son[x])
            DFS(son[x], toop);
        for (auto i : g[x])
            if (i != fa[x] &amp;amp;&amp;amp; i != son[x])
                DFS(i, i);
        return;
    &amp;#125;;
    DFS(1, 1);
    std::vector&amp;lt;std::vector&amp;lt;long long&amp;gt; &amp;gt; bit(21, std::vector&amp;lt;long long&amp;gt; (n + 1));
    auto lowbit = [&amp;amp;](int x) &amp;#123;
        return x &amp;amp; -x;
    &amp;#125;;
    auto add = [&amp;amp;](auto &amp;amp;bit, int x, int v) &amp;#123;
        for (; x &amp;lt;= n; x += lowbit(x))
            bit[x] += v;
        return;
    &amp;#125;;
    auto ask = [&amp;amp;](auto &amp;amp;bit, int x) &amp;#123;
        auto res(0ll);
        for (; x; x -= lowbit(x))
            res += bit[x];
        return res;
    &amp;#125;;
    std::cin &amp;gt;&amp;gt; m;
    for (int op; m--; ) &amp;#123;
        std::cin &amp;gt;&amp;gt; op;
        if (op == 1) &amp;#123;
            int x;
            std::cin &amp;gt;&amp;gt; x;
            auto res(0ll);
            for (int i = 0; i &amp;lt;= 20 &amp;amp;&amp;amp; x; ++i, x = fa[x])
                res += ask(bit[i], dfn[x]);
            std::cout &amp;lt;&amp;lt; res &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
        &amp;#125;
        else &amp;#123;
            int x, y, v, d;
            std::cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; y &amp;gt;&amp;gt; v &amp;gt;&amp;gt; d;
            for (; top[x] != top[y]; x = fa[top[x]]) &amp;#123;
                if (dep[top[x]] &amp;lt; dep[top[y]])
                    std::swap(x, y);
                add(bit[d], dfn[top[x]], v);
                add(bit[d], dfn[x] + 1, -v);
            &amp;#125;
            if (dep[x] &amp;gt; dep[y])
                std::swap(x, y);
            add(bit[d], dfn[x] + 1, v), add(bit[d], dfn[y] + 1, -v);
            for (x = x, y = d; ~y &amp;amp;&amp;amp; x; x = fa[x], --y) &amp;#123;
                add(bit[y], dfn[x], v), add(bit[y], dfn[x] + 1, -v);
                if (y &amp;amp;&amp;amp; fa[x])
                    add(bit[y - 1], dfn[x], v), add(bit[y - 1], dfn[x] + 1, -v);
            &amp;#125;
            if (x == 0)
                for (; ~y; --y)
                    add(bit[y], dfn[1], v), add(bit[y], dfn[1] + 1, -v);
        &amp;#125;
    &amp;#125;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;a---ina-of-the-mountain&#34;&gt;A - Ina of the Mountain&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://codeforces.com/problemset/problem/1852/C&#34; class=&#34;uri&#34;&gt;https://codeforces.com/problemset/problem/1852/C&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;考虑这么一个简化版的问题：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定 &lt;span class=&#34;math inline&#34;&gt;\(\{a_n\}\)&lt;/span&gt;，每次可以进行区间 &lt;span class=&#34;math inline&#34;&gt;\(-1\)&lt;/span&gt;，问操作多少次才能将所有元素变为 &lt;span class=&#34;math inline&#34;&gt;\(0\)&lt;/span&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;会想到差分；对原数组进行差分，一次操作相当于令 &lt;span class=&#34;math inline&#34;&gt;\(d_l\gets d_l-1\)&lt;/span&gt; 而 &lt;span class=&#34;math inline&#34;&gt;\(d_{r+1}\gets d_{r+1}+1\)&lt;/span&gt;，最后要让 &lt;span class=&#34;math inline&#34;&gt;\(\forall \,d_i=0\)&lt;/span&gt;。那么答案就是差分数组中正数之和嘛。&lt;/p&gt;
&lt;p&gt;回到原问题。原问题等价于把上述问题变为：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定 &lt;span class=&#34;math inline&#34;&gt;\(\{a_n\}\)&lt;/span&gt;，每次可以进行区间 &lt;span class=&#34;math inline&#34;&gt;\(-1\)&lt;/span&gt;，每个数的总操作次数对 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 取模，问操作多少次才能将所有元素变为 &lt;span class=&#34;math inline&#34;&gt;\(0\)&lt;/span&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;怎么套回到刚刚的问题上呢？还原被取模掉的操作即可。具体来说，提前在 &lt;span class=&#34;math inline&#34;&gt;\(d\)&lt;/span&gt; 上进行若干次操作（记为操作 1），形如令 &lt;span class=&#34;math inline&#34;&gt;\(d_i\gets d_i+k\)&lt;/span&gt;，同时 &lt;span class=&#34;math inline&#34;&gt;\(d_{i+1}\gets d_{i+1}-k\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;会发现相邻的操作 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt; 对一个数加加减减影响判断；发现可以合并一段连续的操作 1，表现在 &lt;span class=&#34;math inline&#34;&gt;\(a\)&lt;/span&gt; 上也就是区间 &lt;span class=&#34;math inline&#34;&gt;\(+k\)&lt;/span&gt;。此时可以发现，一个位置上只会剩下若干次 &lt;span class=&#34;math inline&#34;&gt;\(+k\)&lt;/span&gt; 或若干次 &lt;span class=&#34;math inline&#34;&gt;\(-k\)&lt;/span&gt; （否则可以把 &lt;span class=&#34;math inline&#34;&gt;\(+k\)&lt;/span&gt; 和 &lt;span class=&#34;math inline&#34;&gt;\(-k\)&lt;/span&gt; 代表的不同操作合并），就不会有互相影响一说了。这也是有的题解说可以提前在 &lt;span class=&#34;math inline&#34;&gt;\(a\)&lt;/span&gt; 上区间 &lt;span class=&#34;math inline&#34;&gt;\(+k\)&lt;/span&gt; 的原因。&lt;/p&gt;
&lt;p&gt;此时问题变为在 &lt;span class=&#34;math inline&#34;&gt;\(d\)&lt;/span&gt; 进行任意次前加 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 后减 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 的操作，使得 &lt;span class=&#34;math inline&#34;&gt;\(\sum\limits_{d_i&amp;gt;0}d_i\)&lt;/span&gt; 最大化。那么显然如果要使代价更小，只可能在原本 &lt;span class=&#34;math inline&#34;&gt;\(&amp;lt;0\)&lt;/span&gt; 的位置做加法、&lt;span class=&#34;math inline&#34;&gt;\(&amp;gt;0\)&lt;/span&gt; 的位置做减法（其他情况会发现一定不优）。考虑两个数 &lt;span class=&#34;math inline&#34;&gt;\(d_l,d_r\)&lt;/span&gt;，可以感受到对于一个 &lt;span class=&#34;math inline&#34;&gt;\(r\)&lt;/span&gt;，选最小的 &lt;span class=&#34;math inline&#34;&gt;\(d_l\)&lt;/span&gt; 是最优的，但什么时候应该选呢？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class=&#34;math inline&#34;&gt;\(d_l\le -k,d_r\ge k\)&lt;/span&gt;：当然可选，&lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 被完全利用，答案减少 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(d_l&amp;gt;-k,d_r\ge k\)&lt;/span&gt;：此时 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 未被完全利用，但必须选：选择其他更大的数，&lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 的利用率只会更低；如果不选，答案也无法减少。&lt;/p&gt;
&lt;p&gt;Q：此时是否需要尝试找到一个 &lt;span class=&#34;math inline&#34;&gt;\(l&amp;#39;&amp;lt;l\)&lt;/span&gt; 与 &lt;span class=&#34;math inline&#34;&gt;\(l\)&lt;/span&gt; 做操作，使得 &lt;span class=&#34;math inline&#34;&gt;\(l\)&lt;/span&gt; 重新变为负数呢？&lt;/p&gt;
A：否。因为你可以将这两次操作合并，发现相当于是直接对 &lt;span class=&#34;math inline&#34;&gt;\((l&amp;#39;,r)\)&lt;/span&gt; 做操作，是更劣的。&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;math inline&#34;&gt;\(d_l\le -k,d_r&amp;lt;k\)&lt;/span&gt;：此时 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 未被完全利用，&lt;span class=&#34;math inline&#34;&gt;\(d_r\)&lt;/span&gt; 成为负数。这意味着 &lt;span class=&#34;math inline&#34;&gt;\(d_r\)&lt;/span&gt; 将会成为某个 &lt;span class=&#34;math inline&#34;&gt;\(r&amp;#39;\)&lt;/span&gt; 的可选项。考察 &lt;span class=&#34;math inline&#34;&gt;\(d_{r&amp;#39;}\)&lt;/span&gt; 可用的最小值。如果 &lt;span class=&#34;math inline&#34;&gt;\(d_r\)&lt;/span&gt; 在当前不应该作为右端点，它就一定会被 &lt;span class=&#34;math inline&#34;&gt;\(d_{r&amp;#39;}\)&lt;/span&gt; 选择。具体的有点抽象，但是你可以理解为 &lt;span class=&#34;math inline&#34;&gt;\(d_r\)&lt;/span&gt; 选了 &lt;span class=&#34;math inline&#34;&gt;\(d_l\)&lt;/span&gt; 的贡献是被整合到 &lt;span class=&#34;math inline&#34;&gt;\(d_r\)&lt;/span&gt; 里的；如果 &lt;span class=&#34;math inline&#34;&gt;\(d_r\)&lt;/span&gt; 被选了就说明 &lt;span class=&#34;math inline&#34;&gt;\(d_{r&amp;#39;}\)&lt;/span&gt; 选 &lt;span class=&#34;math inline&#34;&gt;\(d_l\)&lt;/span&gt; 会拥有更大的优势。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(d_l&amp;gt;-k,d_r&amp;lt;k\)&lt;/span&gt;：和上面的情况相似；但这种情况下答案可能反而变得更大，因为没有后效性，所以至少要保证单步最优。此时不能选。&lt;/p&gt;
&lt;p&gt;说到单步最优，就会发现这里就是反悔贪心；单步最优一定是全局最优，但更靠前的局部最优可能被否定掉。而『否定』的方法表现为一次操作。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;综上，从前往后扫，优先队列实时维护负数最小值，对于每个正数，check 选最小值是否优于当前答案，有就选。如果正数被减为负，加入队列。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#endif
    int T;
    for (std::cin &amp;gt;&amp;gt; T; T--; ) &amp;#123;
        int n, k;
        std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; k;
        std::vector&amp;lt;int&amp;gt; a(n + 1), d(n + 1);
        long long res(0ll);
        for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
            std::cin &amp;gt;&amp;gt; a[i], a[i] %= k;
            d[i] = a[i] - a[i - 1];
            if (d[i] &amp;gt; 0)
                (res += d[i]);
        &amp;#125;
        std::priority_queue&amp;lt;int&amp;gt; q;
        for (int i = 1; i &amp;lt;= n; ++i)
            if (d[i] &amp;lt; 0)
                q.push(-d[i]);
            else &amp;#123;
                for (; !q.empty() &amp;amp;&amp;amp; d[i] &amp;gt; 0; ) &amp;#123;
                    int x = -q.top(), y = d[i];
                    auto t(res - y);
                    x += k, y -= k;
                    if (x &amp;gt; 0)
                        t += x;
                    if (y &amp;gt; 0)
                        t += y;
                    if (t &amp;gt;= res)
                        break;
                    q.pop();
                    res = t, d[i] = y;
                    if (d[i] &amp;lt; 0)
                        q.push(-d[i]);
                &amp;#125;
            &amp;#125;
        std::cout &amp;lt;&amp;lt; res &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    &amp;#125;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;b---miriany-and-matchstick&#34;&gt;B - Miriany and Matchstick&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://codeforces.com/problemset/problem/1852/D&#34; class=&#34;uri&#34;&gt;https://codeforces.com/problemset/problem/1852/D&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;从构造的角度出发，看到『恰好为 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt;』，会想到找到上界和下界并证明中间每一个数都能取到。&lt;/p&gt;
&lt;p&gt;但似乎很容易证伪：例如对于 &lt;code&gt;AAAA&lt;/code&gt;，下界为 &lt;span class=&#34;math inline&#34;&gt;\(0\)&lt;/span&gt;，上界为 &lt;span class=&#34;math inline&#34;&gt;\(4\)&lt;/span&gt;，但有且仅有 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt; 取不到。但该想法并未破产——可以感受到这样的位置很少。进一步地，你 &lt;a href=&#34;https://www.luogu.com.cn/article/2mmg5rjd&#34;&gt;可以证明只有一个这样的位置&lt;/a&gt;，也可以 &lt;a href=&#34;https://www.luogu.com.cn/article/679cwjgl&#34;&gt;大胆猜想这样的位置一定出现在 &lt;span class=&#34;math inline&#34;&gt;\(l+1\)&lt;/span&gt;，&lt;span class=&#34;math inline&#34;&gt;\(r-1\)&lt;/span&gt;&lt;/a&gt;。总之现在我们的状态就减少了（或者说状态变成 DP 值了）。预处理出这个东西之后大力搜索找方案即可。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#endif
    int T;
    for (std::cin &amp;gt;&amp;gt; T; T--; ) &amp;#123;
        int n, k;
        std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; k;
        std::vector&amp;lt;int&amp;gt; a(n + 1);
        for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
            char t;
            std::cin &amp;gt;&amp;gt; t, a[i] = (t == &amp;#39;A&amp;#39;);
            if (i &amp;gt;= 2)
                k -= (a[i] ^ a[i - 1]);
        &amp;#125;
        std::vector&amp;lt;std::array&amp;lt;std::tuple&amp;lt;int, int, int&amp;gt;, 2&amp;gt; &amp;gt; f(n + 1);
        f[n][0] = &amp;#123; a[n], a[n], 0 &amp;#125;, f[n][1] = &amp;#123; !a[n], !a[n], 0 &amp;#125;;
        auto merge = [&amp;amp;](int i, int l0, int r0, int p0, int l1, int r1, int p1) &amp;#123;
            if (l0 &amp;gt; l1)
                std::swap(l0, l1), std::swap(r0, r1), std::swap(p0, p1);
            int l = l0, r = std::max(r0, r1), p = 0;
            if (!p0 &amp;amp;&amp;amp; !p1) &amp;#123;
                if (r0 &amp;lt; l1 - 1)
                    assert(r0 == l1 - 2), p = r0 + 1;
                else;
            &amp;#125;
            else if (p0 &amp;amp;&amp;amp; p1) &amp;#123;
                if (p0 == p1)
                    p = p0;
                else &amp;#123;
                    int tag0 = (l1 &amp;lt;= p0 &amp;amp;&amp;amp; p0 &amp;lt;= r1), tag1 = (l0 &amp;lt;= p1 &amp;amp;&amp;amp; p1 &amp;lt;= r0);
                    if (!tag0 &amp;amp;&amp;amp; !tag1);
                    else if (!tag0)
                        p = p0;
                    else if (!tag1)
                        p = p1;
                    else;
                &amp;#125;
            &amp;#125;
            else if (p0) &amp;#123;
                if (l1 &amp;lt;= p0 &amp;amp;&amp;amp; p0 &amp;lt;= r1);
                else
                    p = p0;
            &amp;#125;
            else &amp;#123;
                if (l0 &amp;lt;= p1 &amp;amp;&amp;amp; p1 &amp;lt;= r0);
                else
                    p = p1;
            &amp;#125;
            assert(p != l &amp;amp;&amp;amp; p != r &amp;amp;&amp;amp; l &amp;lt;= r);
            return std::make_tuple(l, r, p);
        &amp;#125;;
        for (int i = n - 1; i; --i) &amp;#123;
            &amp;#123;
                auto [l0, r0, p0] = f[i + 1][0];
                auto [l1, r1, p1] = f[i + 1][1];
                if (a[i]) &amp;#123;
                    ++l0, ++r0, ++l1, ++r1;
                    if (p0) ++p0;
                    if (p1) ++p1;
                &amp;#125;
                ++l1, ++r1;
                if (p1) ++p1;
                f[i][0] = merge(i, l0, r0, p0, l1, r1, p1);
            &amp;#125;
            &amp;#123;
                auto [l0, r0, p0] = f[i + 1][0];
                auto [l1, r1, p1] = f[i + 1][1];
                if (!a[i]) &amp;#123;
                    ++l0, ++r0, ++l1, ++r1;
                    if (p0) ++p0;
                    if (p1) ++p1;
                &amp;#125;
                ++l0, ++r0;
                if (p0) ++p0;
                f[i][1] = merge(i, l0, r0, p0, l1, r1, p1);
            &amp;#125;
        &amp;#125;
        std::vector&amp;lt;int&amp;gt; res(n + 1);
        std::function&amp;lt;bool(int, int, int)&amp;gt; DFS = [&amp;amp;](int x, int cnt, int la) &amp;#123;
            if (x == n + 1)
                return cnt == k;
            auto [l0, r0, p0] = f[x][0];
            auto [l1, r1, p1] = f[x][1];
            if (cnt + (la == 1) + l0 &amp;lt;= k &amp;amp;&amp;amp; cnt + (la == 1) + r0 &amp;gt;= k &amp;amp;&amp;amp; (!p0 || cnt + (la == 1) + p0 != k) &amp;amp;&amp;amp; DFS(x + 1, cnt + (la == 1) + a[x], 0))
                res[x] = 0;
            else if (cnt + !la + l1 &amp;lt;= k &amp;amp;&amp;amp; cnt + !la + r1 &amp;gt;= k &amp;amp;&amp;amp; (!p1 || cnt + !la + p1 != k) &amp;amp;&amp;amp; DFS(x + 1, cnt + !la + !a[x], 1))
                res[x] = 1;
            else
                return false;
            return true;
        &amp;#125;;
        if (DFS(1, 0, -1)) &amp;#123;
            std::cout &amp;lt;&amp;lt; &amp;quot;YES\n&amp;quot;;
            for (int i = 1; i &amp;lt;= n; ++i)
                std::cout &amp;lt;&amp;lt; (res[i] ? &amp;#39;A&amp;#39; : &amp;#39;B&amp;#39;);
            std::cout &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
        &amp;#125;
        else
            std::cout &amp;lt;&amp;lt; &amp;quot;NO\n&amp;quot;;
    &amp;#125;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
</content>
        <category term="DP" />
        <category term="容斥原理" />
        <category term="树链剖分" />
        <category term="反悔贪心" />
        <updated>2025-05-10T02:18:21.000Z</updated>
    </entry>
    <entry>
        <id>https://xsc062.netlify.app/20250419/</id>
        <title>网格图路径计数</title>
        <link rel="alternate" href="https://xsc062.netlify.app/20250419/"/>
        <content type="html">&lt;figure&gt;
&lt;img src=&#34;/20250419/neko.jpeg&#34; alt=&#34;猫&#34; style=&#34;width: 75px&#34;&gt;
&lt;figcaption&gt;
猫
&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;点到点的方案数&#34;&gt;点到点的方案数&lt;/h2&gt;
&lt;p&gt;从 &lt;span class=&#34;math inline&#34;&gt;\((x_1,y_1)\)&lt;/span&gt; 只能向右、向下走到 &lt;span class=&#34;math inline&#34;&gt;\((x_2,y_2)\)&lt;/span&gt; 的方案数：&lt;span class=&#34;math inline&#34;&gt;\(C_{x_2-x_1+y_2-y_1}^{x_2-x_1}\)&lt;/span&gt;。就是说，因为必须向下走 &lt;span class=&#34;math inline&#34;&gt;\(x_2-x_1\)&lt;/span&gt; 步，又必须向右走 &lt;span class=&#34;math inline&#34;&gt;\(y_2-y_1\)&lt;/span&gt; 步；但顺序是可以任意打乱的。&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;a---gerald-and-giant-chess&#34;&gt;A - Gerald and Giant Chess&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://codeforces.com/problemset/problem/560/E&#34; class=&#34;uri&#34;&gt;https://codeforces.com/problemset/problem/560/E&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;把不能走的点按 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 为第一关键字，&lt;span class=&#34;math inline&#34;&gt;\(y\)&lt;/span&gt; 为第二关键字排序，就可以得到它们按大致拓扑序排列的结果。&lt;/p&gt;
&lt;p&gt;令 &lt;span class=&#34;math inline&#34;&gt;\(f_i\)&lt;/span&gt; 表示不经过 &lt;span class=&#34;math inline&#34;&gt;\(1\sim i-1\)&lt;/span&gt; 的非法点走到第 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 个非法点的方案数，就可以得到 &lt;span class=&#34;math inline&#34;&gt;\(f_i=C_{x_i+y_i,x_i}-\sum_{j=1}^{i-1} f_j\times C_{x_i-x_j+y_i-y_j}^{x_i-x_j}\)&lt;/span&gt;。可以发现后面减去的方案，因为碰到的第一个非法点不同，所以是两两不同的。&lt;/p&gt;
&lt;p&gt;让 &lt;span class=&#34;math inline&#34;&gt;\((h,w)\)&lt;/span&gt; 成为第 &lt;span class=&#34;math inline&#34;&gt;\((n+1)\)&lt;/span&gt; 个非法点，&lt;span class=&#34;math inline&#34;&gt;\(f_{n+1}\)&lt;/span&gt; 就是答案。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int mod = 1e9 + 7;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#endif
    int h, w, n;
    std::cin &amp;gt;&amp;gt; h &amp;gt;&amp;gt; w &amp;gt;&amp;gt; n, --h, --w;
    std::vector&amp;lt;std::pair&amp;lt;int, int&amp;gt; &amp;gt; a(n + 2);
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        std::cin &amp;gt;&amp;gt; a[i].first &amp;gt;&amp;gt; a[i].second;
        --a[i].first, --a[i].second;
    &amp;#125;
    a[n + 1] = &amp;#123; h, w &amp;#125;;
    std::sort(a.begin() + 1, a.end());
    std::vector&amp;lt;long long&amp;gt; fac(h + w + 1), inv(h + w + 1);
    fac[0] = inv[0] = 1ll;
    for (int i = 1; i &amp;lt;= h + w; ++i)
        fac[i] = fac[i - 1] * i % mod;
    auto qkp = [](long long x, int y) &amp;#123;
        auto res = 1ll;
        for (; y; (x *= x) %= mod, y &amp;gt;&amp;gt;= 1)
            if (y &amp;amp; 1)
                (res *= x) %= mod;
        return res;
    &amp;#125;;
    inv[h + w] = qkp(fac[h + w], mod - 2);
    for (int i = h + w - 1; i; --i)
        inv[i] = inv[i + 1] * (i + 1) % mod;
    auto C = [&amp;amp;](int n, int m) &amp;#123;
        return fac[n] * inv[n - m] % mod * inv[m] % mod;
    &amp;#125;;
    std::vector&amp;lt;long long&amp;gt; f(n + 2);
    for (int i = 1; i &amp;lt;= n + 1; ++i) &amp;#123;
        f[i] = C(a[i].first + a[i].second, a[i].first);
        for (int j = 1; j &amp;lt; i; ++j)
            if (a[j].second &amp;lt;= a[i].second)
                (f[i] += mod - f[j] * C(a[i].first - a[j].first + a[i].second - a[j].second, a[i].first - a[j].first) % mod) %= mod;
        // printf(&amp;quot;f[(%d, %d)] = %lld\n&amp;quot;, a[i].first, a[i].second, f[i]);
    &amp;#125;
    std::cout &amp;lt;&amp;lt; f[n + 1] &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;b---bbq-hard&#34;&gt;B - BBQ Hard&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/agc001/tasks/agc001_e&#34; class=&#34;uri&#34;&gt;https://atcoder.jp/contests/agc001/tasks/agc001_e&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;不仅仅可以在关键点上 DP，也可以在网格上直接 DP。&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(A_i+B_i+A_j+B_j\)&lt;/span&gt; 就是 &lt;span class=&#34;math inline&#34;&gt;\(A_i+B_i-(-A_j)-(-B_j)\)&lt;/span&gt;。把棋盘扩大到 &lt;span class=&#34;math inline&#34;&gt;\(-2000\to 2000\)&lt;/span&gt; 就可以了。&lt;/p&gt;
&lt;p&gt;设 &lt;span class=&#34;math inline&#34;&gt;\(f_{i,j}\)&lt;/span&gt; 表示可以到达 &lt;span class=&#34;math inline&#34;&gt;\((i,j)\)&lt;/span&gt; 的所有发出关键点 &lt;span class=&#34;math inline&#34;&gt;\((-A_j,-B_j)\)&lt;/span&gt; 带来的贡献，那么 &lt;span class=&#34;math inline&#34;&gt;\(f_{i,j}=f_{i-1,j}+f_{i,j-1}\)&lt;/span&gt;。枚举所有接收关键点 &lt;span class=&#34;math inline&#34;&gt;\((A_i,B_i)\)&lt;/span&gt;，&lt;span class=&#34;math inline&#34;&gt;\(\sum f_{A_i,B_i}\)&lt;/span&gt; 就是答案的两倍，再减去对角线，也就是 &lt;span class=&#34;math inline&#34;&gt;\(\sum (-A_i,B_i)\to (A_i,B_i)\)&lt;/span&gt; 后的值。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int N = 2000;
const int mod = 1e9 + 7;
const int inv2 = 500000004;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#endif
    int n;
    std::cin &amp;gt;&amp;gt; n;
    std::vector&amp;lt;long long&amp;gt; fac(4 * N + 1), inv(4 * N + 1);
    fac[0] = inv[0] = 1ll;
    for (int i = 1; i &amp;lt;= 4 * N; ++i)
        fac[i] = fac[i - 1] * i % mod;
    auto qkp = [](long long x, int y) &amp;#123;
        auto res(1ll);
        for (; y; (x *= x) %= mod, y &amp;gt;&amp;gt;= 1)
            if (y &amp;amp; 1)
                (res *= x) %= mod;
        return res;
    &amp;#125;;
    inv[4 * N] = qkp(fac[4 * N], mod - 2);
    for (int i = 4 * N - 1; i; --i)
        inv[i] = inv[i + 1] * (i + 1) % mod;
    std::vector&amp;lt;std::pair&amp;lt;int, int&amp;gt; &amp;gt; a(n + 1);
    std::vector&amp;lt;std::vector&amp;lt;long long&amp;gt; &amp;gt; f(2 * N + 1, std::vector&amp;lt;long long&amp;gt; (2 * N + 1));
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        std::cin &amp;gt;&amp;gt; a[i].first &amp;gt;&amp;gt; a[i].second;
        ++f[N - a[i].first][N - a[i].second];
    &amp;#125;
    for (int i = 0; i &amp;lt;= 2 * N; ++i)
        for (int j = 0; j &amp;lt;= 2 * N; ++j) &amp;#123;
            if (i &amp;gt;= 1)
                (f[i][j] += f[i - 1][j]) %= mod;
            if (j &amp;gt;= 1)
                (f[i][j] += f[i][j - 1]) %= mod;
            // printf(&amp;quot;f(%2d, %2d) = %lld\n&amp;quot;, i - N, j - N, f[i][j]);
        &amp;#125;
    long long res = 0ll;
    auto C = [&amp;amp;](int n, int m) &amp;#123;
        return fac[n] * inv[n - m] % mod * inv[m] % mod;
    &amp;#125;;
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        (res += f[a[i].first + N][a[i].second + N]) %= mod;
        (res += mod - C(a[i].first * 2 + a[i].second * 2, 2 * a[i].first)) %= mod;
    &amp;#125;
    std::cout &amp;lt;&amp;lt; res * inv2 % mod &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;c---iroha-and-a-grid&#34;&gt;C - Iroha and a Grid&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/arc058/tasks/arc058_b&#34; class=&#34;uri&#34;&gt;https://atcoder.jp/contests/arc058/tasks/arc058_b&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;先把绿色部分的答案计算出来：&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&#34;1.png&#34; alt=&#34;网格&#34; /&gt;&lt;figcaption&gt;网格&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;如果把绿色的每一个格子到终点的方案数求和，就会算重，因为上面的绿色点可以走到下面的绿色点。&lt;/p&gt;
&lt;p&gt;让绿色点第一步只能往右走到黄色点，用这样的方案为黄色点赋初值，再让黄色点自由走就可以得到答案了。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int mod = 1e9 + 7;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#endif
    int h, w, a, b;
    std::cin &amp;gt;&amp;gt; h &amp;gt;&amp;gt; w &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b;
    std::vector&amp;lt;long long&amp;gt; fac(h + w + 1), inv(h + w + 1);
    fac[0] = inv[0] = 1ll;
    for (int i = 1; i &amp;lt;= h + w; ++i)
        fac[i] = fac[i - 1] * i % mod;
    auto qkp = [](long long x, int y) &amp;#123;
        auto res(1ll);
        for (; y; (x *= x) %= mod, y &amp;gt;&amp;gt;= 1)
            if (y &amp;amp; 1)
                (res *= x) %= mod;
        return res;
    &amp;#125;;
    inv[h + w] = qkp(fac[h + w], mod - 2);
    for (int i = h + w - 1; i; --i)
        inv[i] = inv[i + 1] * (i + 1) % mod;
    auto C = [&amp;amp;](int n, int m) &amp;#123;
        return fac[n] * inv[n - m] % mod * inv[m] % mod;
    &amp;#125;;
    auto res = 0ll;
    for (int i = 1; i &amp;lt;= h - a; ++i) &amp;#123;
        // (i, B)
        auto f(C(i + b - 2, i - 1));
        // printf(&amp;quot;(%d, %d): %lld\n&amp;quot;, i, b, f);
        // (i, B + 1)
        (res += f * C(h - i + w - (b + 1), h - i) % mod) %= mod;
    &amp;#125;
    std::cout &amp;lt;&amp;lt; res &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;点到矩形的方案数&#34;&gt;点到矩形的方案数&lt;/h2&gt;
&lt;p&gt;从 &lt;span class=&#34;math inline&#34;&gt;\((x_0,y_0)\)&lt;/span&gt; 走到矩形 &lt;span class=&#34;math inline&#34;&gt;\((x_1,y_1,x_2,y_2)\)&lt;/span&gt; 的方案数：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
\sum\limits_{i\in [x_1,x_2],j\in [y_1,y_2]} G(x_0,y_0, i, j) = G(x_0,y_0,x_2 + 1,y_2 + 1)-G(x_0,y_0,x_2+1,y_1)-G(x_0,y_0,x_1,y_2+1)+G(x_0,y_0,x_1,y_1)
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;证明：&lt;span class=&#34;math inline&#34;&gt;\(G(x_0,y_0,x_2+1,y_2+1)=\sum\limits_i G(x_0,y_0,i,y_2)=\sum\limits_{i,j} G(x_0,y_0,i,j)\)&lt;/span&gt;，类似的，把后面几项展开，可以得到前缀和的结构。&lt;/p&gt;
&lt;p&gt;现在，矩形就可以被概括成 4 个点了。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;矩形到矩形的方案数&#34;&gt;矩形到矩形的方案数&lt;/h2&gt;
&lt;p&gt;枚举第一个矩形里的所有点，那么就可以得到关于第二个矩形里四个点的表达式。反过来把第一个矩形概括为 4 个点就可以快速求解了。&lt;/p&gt;
&lt;p&gt;具体一点，第一个矩形 &lt;span class=&#34;math inline&#34;&gt;\((x_1,y_1,x_2,y_2)\)&lt;/span&gt; 可以被概括为 &lt;span class=&#34;math inline&#34;&gt;\((x_1-1,y_1-1)\)&lt;/span&gt;，&lt;span class=&#34;math inline&#34;&gt;\((x_1-1,y_2)\)&lt;/span&gt;，&lt;span class=&#34;math inline&#34;&gt;\((x_2,y_1-1)\)&lt;/span&gt;，&lt;span class=&#34;math inline&#34;&gt;\((x_2,y_2)\)&lt;/span&gt;。注意方向颠倒导致符号发生变化。此时对 &lt;span class=&#34;math inline&#34;&gt;\(4\times 4=16\)&lt;/span&gt; 个 &lt;span class=&#34;math inline&#34;&gt;\(G\)&lt;/span&gt; 按对应的 &lt;span class=&#34;math inline&#34;&gt;\(-1/1\)&lt;/span&gt; 系数求和就能得到答案。&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;d---sightseeing-plan&#34;&gt;D - Sightseeing Plan&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/agc018/tasks/agc018_e&#34; class=&#34;uri&#34;&gt;https://atcoder.jp/contests/agc018/tasks/agc018_e&lt;/a&gt;&lt;/p&gt;
&lt;ol type=&#34;1&#34;&gt;
&lt;li&gt;恒等式：&lt;span class=&#34;math inline&#34;&gt;\(\sum\limits_{i\in [x_1,x_2]}G_(x_1,y_1,i,y_2-1)=G(x_1,y_1,x_2,y_2)\)&lt;/span&gt;，放在网格图上就是强制走到 &lt;span class=&#34;math inline&#34;&gt;\((i,y_2-1)\)&lt;/span&gt;，再强制向右走一步，然后向上走到 &lt;span class=&#34;math inline&#34;&gt;\((x_2,y_2)\)&lt;/span&gt;。和上一题类似的，可以发现不重不漏。&lt;/li&gt;
&lt;li&gt;三个矩形，&lt;span class=&#34;math inline&#34;&gt;\(M_1\)&lt;/span&gt; 经过 &lt;span class=&#34;math inline&#34;&gt;\(M_2\)&lt;/span&gt; 到达 &lt;span class=&#34;math inline&#34;&gt;\(M_3\)&lt;/span&gt; 的路径数量：经过 &lt;span class=&#34;math inline&#34;&gt;\(M_2\)&lt;/span&gt; 时，根据限制，只可能从下面或左边进入。枚举进入的点 &lt;span class=&#34;math inline&#34;&gt;\((x_0,y_0)\)&lt;/span&gt;（数量为 &lt;span class=&#34;math inline&#34;&gt;\(O(n)\)&lt;/span&gt;），再计算 &lt;span class=&#34;math inline&#34;&gt;\(G(x_0,y_0,M_3)\)&lt;/span&gt; 就能得到不重不漏的答案。&lt;/li&gt;
&lt;li&gt;原问题：要求 &lt;span class=&#34;math inline&#34;&gt;\(M_2\)&lt;/span&gt; 内部路径上点的贡献和，这个其实就是 &lt;span class=&#34;math inline&#34;&gt;\(M_2\)&lt;/span&gt; 内部路径长度。若从 &lt;span class=&#34;math inline&#34;&gt;\((x_1,y_1)\)&lt;/span&gt; 进入，再从 &lt;span class=&#34;math inline&#34;&gt;\((x_2,y_2)\)&lt;/span&gt; 离开，长度就是 &lt;span class=&#34;math inline&#34;&gt;\(x_2-x_1+y_2-y_1+1\)&lt;/span&gt;。拆成 &lt;span class=&#34;math inline&#34;&gt;\((x_2+y_2+1)\)&lt;/span&gt; 和 &lt;span class=&#34;math inline&#34;&gt;\(-(x_1+y_1)\)&lt;/span&gt; 后发现一次进入和一次离开的贡献是独立的。分别枚举进入点和离开点计算贡献就可以了。&lt;/li&gt;
&lt;/ol&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int N = 2e6;
const int mod = 1e9 + 7;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#endif
    int x1, x2, x3, x4, x5, x6, y1, y2, y3, y4, y5, y6;
    std::cin &amp;gt;&amp;gt; x1 &amp;gt;&amp;gt; x2 &amp;gt;&amp;gt; x3 &amp;gt;&amp;gt; x4 &amp;gt;&amp;gt; x5 &amp;gt;&amp;gt; x6;
    std::cin &amp;gt;&amp;gt; y1 &amp;gt;&amp;gt; y2 &amp;gt;&amp;gt; y3 &amp;gt;&amp;gt; y4 &amp;gt;&amp;gt; y5 &amp;gt;&amp;gt; y6;
    std::vector&amp;lt;long long&amp;gt; fac(N + 1), inv(N + 1);
    fac[0] = inv[0] = 1ll;
    for (int i = 1; i &amp;lt;= N; ++i)
        fac[i] = fac[i - 1] * i % mod;
    auto qkp = [](long long x, int y) &amp;#123;
        auto res(1ll);
        for (; y; (x *= x) %= mod, y &amp;gt;&amp;gt;= 1)
            if (y &amp;amp; 1)
                (res *= x) %= mod;
        return res;
    &amp;#125;;
    inv[N] = qkp(fac[N], mod - 2);
    for (int i = N - 1; i; --i)
        inv[i] = inv[i + 1] * (i + 1) % mod;
    auto C = [&amp;amp;](int n, int m) &amp;#123;
        return fac[n] * inv[n - m] % mod * inv[m] % mod;
    &amp;#125;;
    std::vector&amp;lt;std::tuple&amp;lt;int, int, int&amp;gt; &amp;gt; f(4), g(4);
    f[0] = &amp;#123; x1 - 1, y1 - 1, 1 &amp;#125;, f[1] = &amp;#123; x1 - 1, y2, mod - 1 &amp;#125;, f[2] = &amp;#123; x2, y1 - 1, mod - 1 &amp;#125;, f[3] = &amp;#123; x2, y2, 1 &amp;#125;;
    g[0] = &amp;#123; x5, y5, 1 &amp;#125;, g[1] = &amp;#123; x5, y6 + 1, mod - 1 &amp;#125;, g[2] = &amp;#123; x6 + 1, y5, mod - 1 &amp;#125;, g[3] = &amp;#123; x6 + 1, y6 + 1, 1 &amp;#125;; 
    auto G = [&amp;amp;](int x1, int y1, int x2, int y2) &amp;#123;
        auto a(std::abs(x1 - x2)), b(std::abs(y1 - y2));
        return C(a + b, a);
    &amp;#125;;
    auto res = 0ll;
    for (auto [x1, y1, k1] : f)
        for (auto [x2, y2, k2] : g) &amp;#123;
            auto t(0ll);
            for (int x = x3; x &amp;lt;= x4; ++x) &amp;#123;
                (t += G(x1, y1, x, y4) * G(x, y4 + 1, x2, y2) % mod * (x + y4 + 1) % mod) %= mod;
                (t += mod - G(x1, y1, x, y3 - 1) * G(x, y3, x2, y2) % mod * (x + y3) % mod) %= mod;
            &amp;#125;
            for (int y = y3; y &amp;lt;= y4; ++y) &amp;#123;
                (t += G(x1, y1, x4, y) * G(x4 + 1, y, x2, y2) % mod * (x4 + y + 1) % mod) %= mod;
                (t += mod - G(x1, y1, x3 - 1, y) * G(x3, y, x2, y2) % mod * (x3 + y) % mod) %= mod;
            &amp;#125;
            // printf(&amp;quot;(%d, %d, %d), (%d, %d, %d): %lld\n&amp;quot;, x1, y1, k1, x2, y2, k2, t * k1 % mod * k2 % mod);
            (res += t * k1 % mod * k2 % mod) %= mod;
        &amp;#125;
    std::cout &amp;lt;&amp;lt; res &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;不经过-yxc-的方案数&#34;&gt;不经过 &lt;span class=&#34;math inline&#34;&gt;\(y=x+c\)&lt;/span&gt; 的方案数&lt;/h2&gt;
&lt;p&gt;Catalan 数的一种推导方式是，在 &lt;span class=&#34;math inline&#34;&gt;\(n\times n\)&lt;/span&gt; 的网格上，要求不能越过 &lt;span class=&#34;math inline&#34;&gt;\(y=x\)&lt;/span&gt; 的方案数。可以用总方案数减去越过的方案数。&lt;/p&gt;
&lt;p&gt;怎么计算非法的方案呢？越过 &lt;span class=&#34;math inline&#34;&gt;\(y=x\)&lt;/span&gt; 的路径必定存在一个点经过 &lt;span class=&#34;math inline&#34;&gt;\(y=x+1\)&lt;/span&gt;，原问题转化为不能碰到 &lt;span class=&#34;math inline&#34;&gt;\(y=x+1\)&lt;/span&gt; 的方案数。&lt;/p&gt;
&lt;p&gt;把终点 &lt;span class=&#34;math inline&#34;&gt;\((n, n)\)&lt;/span&gt; 翻折到 &lt;span class=&#34;math inline&#34;&gt;\(y=x+1\)&lt;/span&gt; 上方，得到 &lt;span class=&#34;math inline&#34;&gt;\((n-1, n + 1)\)&lt;/span&gt;；对于任意到达 &lt;span class=&#34;math inline&#34;&gt;\((n-1,n+1)\)&lt;/span&gt; 的路径，一定会接触 &lt;span class=&#34;math inline&#34;&gt;\(y=x+1\)&lt;/span&gt; 至少一次；将第一次接触以后的路径翻折到 &lt;span class=&#34;math inline&#34;&gt;\(y=x+1\)&lt;/span&gt; 下方，则一定和原图中的非法路径一一对应。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;4.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;就可以得到 &lt;span class=&#34;math inline&#34;&gt;\(C_{2n}^n-C_{2n}^{n-1}\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;如果问题变得更加一般，求解到达 &lt;span class=&#34;math inline&#34;&gt;\((n, m)\)&lt;/span&gt; 不能碰到 &lt;span class=&#34;math inline&#34;&gt;\(y=x+c\)&lt;/span&gt; 的方案数，还是可以把 &lt;span class=&#34;math inline&#34;&gt;\((n,m)\)&lt;/span&gt; 翻折到 &lt;span class=&#34;math inline&#34;&gt;\((m-c,n+c)\)&lt;/span&gt;，答案是 &lt;span class=&#34;math inline&#34;&gt;\(C_{n+m}^n-C_{n+m}^{m-c}\)&lt;/span&gt;。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;不经过-yx-l-和-yxr-的方案数&#34;&gt;不经过 &lt;span class=&#34;math inline&#34;&gt;\(y=x-l\)&lt;/span&gt; 和 &lt;span class=&#34;math inline&#34;&gt;\(y=x+r\)&lt;/span&gt; 的方案数&lt;/h2&gt;
&lt;p&gt;现在有 &lt;span class=&#34;math inline&#34;&gt;\(y=x-l\)&lt;/span&gt; 和 &lt;span class=&#34;math inline&#34;&gt;\(y=x+r\)&lt;/span&gt; 两条线作为限制，现在的翻折意义就会有一点改变。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;5.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;比如图中的 &lt;span class=&#34;math inline&#34;&gt;\(A&amp;#39;\)&lt;/span&gt;，是 &lt;span class=&#34;math inline&#34;&gt;\(A\)&lt;/span&gt; 沿着 &lt;span class=&#34;math inline&#34;&gt;\(y=x-l\)&lt;/span&gt; 翻折一次后的结果。还是按照之前的方式来理解，那么走到 &lt;span class=&#34;math inline&#34;&gt;\(A&amp;#39;\)&lt;/span&gt; 的路径代表至少经过一次 &lt;span class=&#34;math inline&#34;&gt;\(y=x-l\)&lt;/span&gt; 的方案。&lt;span class=&#34;math inline&#34;&gt;\(A&amp;#39;&amp;#39;\)&lt;/span&gt; 是 &lt;span class=&#34;math inline&#34;&gt;\(A&amp;#39;\)&lt;/span&gt; 沿着 &lt;span class=&#34;math inline&#34;&gt;\(y=x+r\)&lt;/span&gt; 翻折一次之后得到的结果，走到 &lt;span class=&#34;math inline&#34;&gt;\(A&amp;#39;&amp;#39;\)&lt;/span&gt; 的路径就代表至少先碰到一次 &lt;span class=&#34;math inline&#34;&gt;\(y=x-l\)&lt;/span&gt;，再碰到一次 &lt;span class=&#34;math inline&#34;&gt;\(y=x+r\)&lt;/span&gt; 的方案数。&lt;/p&gt;
&lt;p&gt;如果把相邻多次碰到 &lt;span class=&#34;math inline&#34;&gt;\(y=x-l\)&lt;/span&gt; 或 &lt;span class=&#34;math inline&#34;&gt;\(y=x+r\)&lt;/span&gt; 合并为一次，最终的非法路径就是 &lt;code&gt;LRLRLR...&lt;/code&gt; 或者 &lt;code&gt;RLRLRL...&lt;/code&gt; 的形式。因为可以计算的是「至少」的形式，用容斥原理得到，答案是 &lt;span class=&#34;math inline&#34;&gt;\(f_{\varnothing}-(f_{\texttt L} + f_{\texttt R}) + (f_{\texttt {LR}} + f_{\texttt {RL}}) - \cdots\)&lt;/span&gt;。对应计算每个翻折对应终点和答案就可以了。最后的答案是 &lt;span class=&#34;math inline&#34;&gt;\(C_{n+m}^n-C_{n+m}^{n+l}-C_{n+m}^{n + r}+C_{n+m}^{n+l-r}+C_{n+m}^{n+r-l}-\cdots\)&lt;/span&gt;，可以简化成 &lt;span class=&#34;math inline&#34;&gt;\(\sum\limits_{k\in \mathbb{Z}} C_{n+m}^{n-k\cdot (r-l)}-C_{n+m}^{n-k\cdot (r-l)+r}\)&lt;/span&gt;。&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;e---骗我呢&#34;&gt;E - 骗我呢&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P3266&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P3266&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;每行内部递增，而且选项只有 &lt;span class=&#34;math inline&#34;&gt;\([0,m]\)&lt;/span&gt;，那么每行就会刚好在 &lt;span class=&#34;math inline&#34;&gt;\([0,m]\)&lt;/span&gt; 里面跳过一个数。&lt;/p&gt;
&lt;p&gt;如果第 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 行跳过的数是 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt;，那么画一画图就可以发现第 &lt;span class=&#34;math inline&#34;&gt;\(i+1\)&lt;/span&gt; 可能跳过的数是 &lt;span class=&#34;math inline&#34;&gt;\([j-1,m]\)&lt;/span&gt;；反过来，第 &lt;span class=&#34;math inline&#34;&gt;\(i-1\)&lt;/span&gt; 行可能跳过的数就是 &lt;span class=&#34;math inline&#34;&gt;\([0,j+1]\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;如果让 &lt;span class=&#34;math inline&#34;&gt;\(f_{i,j}\)&lt;/span&gt; 表示确定了第 &lt;span class=&#34;math inline&#34;&gt;\(1\to i\)&lt;/span&gt; 行，其中第 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 行跳过 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; 的方案数，就可以得到 &lt;span class=&#34;math inline&#34;&gt;\(f_{i,j}=\sum\limits_{k=0}^{j+1} f_{i-1,k}\)&lt;/span&gt;。前缀和得到 &lt;span class=&#34;math inline&#34;&gt;\(f_{i,j}=f_{i,j-1}+f_{i-1,j+1}\)&lt;/span&gt;。注意边界：&lt;span class=&#34;math inline&#34;&gt;\(f_{0,j}=1\)&lt;/span&gt;；&lt;span class=&#34;math inline&#34;&gt;\(f_{i,0}=f_{i-1,0}+f_{i-1,1}\)&lt;/span&gt;；&lt;span class=&#34;math inline&#34;&gt;\(f_{i,m}=f_{i,m-1}\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;为了得到答案，让 &lt;span class=&#34;math inline&#34;&gt;\(g_{i,j}\)&lt;/span&gt; 表示 &lt;span class=&#34;math inline&#34;&gt;\(i\times j\)&lt;/span&gt; 矩阵的方案数（这样就有机会通过手段优化了）：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
\begin{aligned}
g_{i,j}&amp;amp;=\sum_{k=0}^j f_{i,k}\\
&amp;amp;= f_{i-1,0}+f_{i-1,1}+\sum_{k=1}^j f_{i,k-1}+f_{i-1,k+1}\\
&amp;amp;= g_{i,j-1}+g_{i-1,j+1}
\end{aligned}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;边界情况呢， &lt;span class=&#34;math inline&#34;&gt;\(g_{i, 0} = f_{i,0} = f_{i-1, 0} + f_{i - 1, 1} = g_{i-1,1}\)&lt;/span&gt;；&lt;span class=&#34;math inline&#34;&gt;\(g_{i,m}=g_{i, m - 1} + f_{i,m}=g_{i-1,m}+g_{i,m-1}\)&lt;/span&gt;。 &lt;span class=&#34;math inline&#34;&gt;\(g_{i,m+1}=g_{i,m}\)&lt;/span&gt; 避免边界。&lt;/p&gt;
&lt;p&gt;那么在网格图上转移如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;2.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;考虑将这个图形拉正，令 &lt;span class=&#34;math inline&#34;&gt;\((i+i,j)\gets g_{i,j}\)&lt;/span&gt; 得到：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;3.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;问题就转化为，从 &lt;span class=&#34;math inline&#34;&gt;\((0, 0)\)&lt;/span&gt; 走到 &lt;span class=&#34;math inline&#34;&gt;\((m+n+1,n)\)&lt;/span&gt; 且不能触碰 &lt;span class=&#34;math inline&#34;&gt;\(y=x+1\)&lt;/span&gt; 和 &lt;span class=&#34;math inline&#34;&gt;\(y=x-m-2\)&lt;/span&gt; 两条直线的方案数。&lt;/p&gt;
&lt;details&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;不经过一般过原点直线的方案数&#34;&gt;不经过一般过原点直线的方案数&lt;/h2&gt;
&lt;ol type=&#34;1&#34;&gt;
&lt;li&gt;&lt;p&gt;类型一：&lt;span class=&#34;math inline&#34;&gt;\((0,0)\to (n,m)\)&lt;/span&gt;，不经过 &lt;span class=&#34;math inline&#34;&gt;\(y=\dfrac mnx\)&lt;/span&gt; 的方案，其中要求 &lt;span class=&#34;math inline&#34;&gt;\((m,n)=1\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;方案为 &lt;span class=&#34;math inline&#34;&gt;\(\dfrac {C_{n+m}^n}{n+m}\)&lt;/span&gt;。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</content>
        <category term="排列组合" />
        <category term="容斥原理" />
        <category term="数学" />
        <updated>2025-04-19T02:03:57.000Z</updated>
    </entry>
    <entry>
        <id>https://xsc062.netlify.app/20250407/</id>
        <title>组合计数</title>
        <link rel="alternate" href="https://xsc062.netlify.app/20250407/"/>
        <content type="html">&lt;p&gt;毅毅：统计不是数学（断章取义 ed）。&lt;del&gt;故删掉了数学标签。&lt;/del&gt; 其实并没有。&lt;/p&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;a.-二分图染色&#34;&gt;A. 二分图染色&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://222.180.160.110:61235/contest/6181/problem/1&#34; class=&#34;uri&#34;&gt;http://222.180.160.110:61235/contest/6181/problem/1&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;首先只看红色。显然一个左部点最多只能用红边连接一个右部点，反之同理。把左部点视为下标，其用红边相连的右部点视为值，则一个合法的方案为 &lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt; 的只保留一部分元素的排列。显然为 &lt;span class=&#34;math inline&#34;&gt;\(f(n)=\sum\limits_{i=0}^nC_n^i\cdot A_n^i\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;再加上蓝色，&lt;span class=&#34;math inline&#34;&gt;\(f^2(n)\)&lt;/span&gt; 会给一条边涂两种颜色，故钦定有两种颜色的边数，容斥得到 &lt;span class=&#34;math inline&#34;&gt;\(\sum\limits_{i=0}^n(-1)^i\cdot C_n^i\cdot A_n^i\cdot f^2(n-i)\)&lt;/span&gt;。发现 &lt;span class=&#34;math inline&#34;&gt;\(f\)&lt;/span&gt; 的计算可能需要优化一下。考虑已经知道 &lt;span class=&#34;math inline&#34;&gt;\(f(n-1)\)&lt;/span&gt;，此时对于新增的第 &lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt; 对点：&lt;/p&gt;
&lt;ol type=&#34;1&#34;&gt;
&lt;li&gt;任意连边（显然两个当中只能有一个点发出边），共有 &lt;span class=&#34;math inline&#34;&gt;\(2n-1\)&lt;/span&gt; 种方案，因为 &lt;span class=&#34;math inline&#34;&gt;\((n, n)\)&lt;/span&gt; 会被算重。&lt;/li&gt;
&lt;li&gt;不连，共 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt; 种方案。&lt;/li&gt;
&lt;li&gt;发现 1 中可能连到已经有连边的点上了，新边的目的地有 &lt;span class=&#34;math inline&#34;&gt;\(n-1\)&lt;/span&gt; 个选项，目的地原本连接的点也有 &lt;span class=&#34;math inline&#34;&gt;\(n-1\)&lt;/span&gt; 个选项，去掉两边共 &lt;span class=&#34;math inline&#34;&gt;\(4\)&lt;/span&gt; 个点，非法的即为 &lt;span class=&#34;math inline&#34;&gt;\((n-1)^2\cdot f(n-2)\)&lt;/span&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int mod = 1e9 + 7;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#endif
    int n;
    std::cin &amp;gt;&amp;gt; n;
    std::vector&amp;lt;long long&amp;gt; f(n + 1), fac(n + 1), inv(n + 1);
    f[0] = 1ll, f[1] = 2ll;
    fac[0] = 1ll, fac[1] = 1ll, inv[0] = 1ll;
    for (int i = 2; i &amp;lt;= n; ++i) &amp;#123;
        fac[i] = fac[i - 1] * i % mod;
        f[i] = (f[i - 1] * 2 * i % mod + mod - f[i - 2] * (i - 1) % mod * (i - 1) % mod) % mod;
    &amp;#125;
    auto qkp = [](long long x, int y) &amp;#123;
        auto res = 1ll;
        for (; y; (x *= x) %= mod, y &amp;gt;&amp;gt;= 1)
            if (y &amp;amp; 1)
                (res *= x) %= mod;
        return res;
    &amp;#125;;
    inv[n] = qkp(fac[n], mod - 2);
    for (int i = n - 1; i; --i)
        inv[i] = inv[i + 1] * (i + 1) % mod;
    auto C = [&amp;amp;](int n, int m) &amp;#123;
        return fac[n] * inv[n - m] % mod * inv[m] % mod;
    &amp;#125;;
    auto A = [&amp;amp;](int n, int m) &amp;#123;
        return fac[n] * inv[n - m] % mod;
    &amp;#125;;
    long long res = 0ll;
    for (int i = 0, k = 1; i &amp;lt;= n; ++i, k = mod - k)
        (res += k * C(n, i) % mod * A(n, i) % mod * f[n - i] % mod * f[n - i]) %= mod;
    std::cout &amp;lt;&amp;lt; res &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;b.-七选五&#34;&gt;B. 七选五&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://222.180.160.110:61235/contest/6181/problem/2&#34; class=&#34;uri&#34;&gt;http://222.180.160.110:61235/contest/6181/problem/2&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;首先 &lt;span class=&#34;math inline&#34;&gt;\(p\)&lt;/span&gt; 固定，钦定有 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 个数相等，有 &lt;span class=&#34;math inline&#34;&gt;\(C_k^x\)&lt;/span&gt; 个方案，剩下的就是从 &lt;span class=&#34;math inline&#34;&gt;\(n-x\)&lt;/span&gt; 个元素里选出 &lt;span class=&#34;math inline&#34;&gt;\(k-x\)&lt;/span&gt; 个来错排，考虑钦定相同的个数来容斥：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
\sum_{i=0}^{k-x}(-1)^i\cdot C_{k-x}^i\cdot A_{n-x-i}^{k-x-i}
\]&lt;/span&gt;&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int mod = 1e9 + 7;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#endif
    int n, k, x;
    std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; k &amp;gt;&amp;gt; x;
    std::vector&amp;lt;long long&amp;gt; fac(n + 1), inv(n + 1);
    fac[0] = 1ll, fac[1] = 1ll, inv[0] = 1ll;
    for (int i = 2; i &amp;lt;= n; ++i)
        fac[i] = fac[i - 1] * i % mod;
    auto qkp = [](long long x, int y) &amp;#123;
        auto res = 1ll;
        for (; y; (x *= x) %= mod, y &amp;gt;&amp;gt;= 1)
            if (y &amp;amp; 1)
                (res *= x) %= mod;
        return res;
    &amp;#125;;
    inv[n] = qkp(fac[n], mod - 2);
    for (int i = n - 1; i; --i)
        inv[i] = inv[i + 1] * (i + 1) % mod;
    auto C = [&amp;amp;](int n, int m) &amp;#123;
        return fac[n] * inv[n - m] % mod * inv[m] % mod;
    &amp;#125;;
    auto A = [&amp;amp;](int n, int m) &amp;#123;
        return fac[n] * inv[n - m] % mod;
    &amp;#125;;
    long long res = C(k, x), sum = 0ll;
    for (int i = 0, p = 1; i &amp;lt;= k - x; ++i, p = mod - p)
        (sum += p * C(k - x, i) % mod * A(n - x - i, k - x - i) % mod) %= mod;
    std::cout &amp;lt;&amp;lt; res * sum % mod &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;d.-硬币购物&#34;&gt;D. 硬币购物&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://222.180.160.110:61235/contest/6181/problem/4&#34; class=&#34;uri&#34;&gt;http://222.180.160.110:61235/contest/6181/problem/4&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;每次多重背包会超时，考虑用钦定每种硬币是否超额来容斥。令 &lt;span class=&#34;math inline&#34;&gt;\(f_s\)&lt;/span&gt; 表示凑出 &lt;span class=&#34;math inline&#34;&gt;\(s\)&lt;/span&gt; 的方案数（完全背包），那么 &lt;span class=&#34;math inline&#34;&gt;\(f_{s-c_1\times (d_1 + 1)}\)&lt;/span&gt; 就表示钦定第 1 种硬币超额时凑出 &lt;span class=&#34;math inline&#34;&gt;\(s\)&lt;/span&gt; 的方案数，以此类推。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#endif
    int c[4], T, m = 1e5;
    std::vector&amp;lt;long long&amp;gt; f(m + 1);
    f[0] = 1;
    for (int i = 0; i &amp;lt; 4; ++i) &amp;#123;
        std::cin &amp;gt;&amp;gt; c[i];
        for (int j = c[i]; j &amp;lt;= m; ++j)
            f[j] += f[j - c[i]];
    &amp;#125;
    std::cin &amp;gt;&amp;gt; T;
    for (int d[4], m; T--; ) &amp;#123;
        for (int i = 0; i &amp;lt; 4; ++i)
            std::cin &amp;gt;&amp;gt; d[i];
        std::cin &amp;gt;&amp;gt; m;
        long long res = 0ll;
        for (int i = 0; i &amp;lt; (1 &amp;lt;&amp;lt; 4); ++i) &amp;#123;
            int s = m;
            for (int j = 0; j &amp;lt; 4; ++j)
                if ((i &amp;gt;&amp;gt; j) &amp;amp; 1)
                    s -= (d[j] + 1) * c[j];
            if (s &amp;gt;= 0) &amp;#123;
                int k = (__builtin_popcount(i) &amp;amp; 1) ? -1 : 1;
                res += k * f[s];
            &amp;#125;
        &amp;#125;
        std::cout &amp;lt;&amp;lt; res &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    &amp;#125;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;e.-distinct-multiples&#34;&gt;E. Distinct Multiples&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://222.180.160.110:61235/contest/6181/problem/5&#34; class=&#34;uri&#34;&gt;http://222.180.160.110:61235/contest/6181/problem/5&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;推式子题。题意转化为，给定 &lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt; 个位置可选的值集合，要求任意两个位置值不等，问方案数。&lt;/p&gt;
&lt;p&gt;如果把两个位置取等视作在团上选中边，那么有朴素做法钦定选边的集合 &lt;span class=&#34;math inline&#34;&gt;\(S\)&lt;/span&gt; 然后容斥，考虑它们构成的连通块 &lt;span class=&#34;math inline&#34;&gt;\(\{s\} \subseteq S\)&lt;/span&gt;，有 &lt;span class=&#34;math inline&#34;&gt;\(res=\sum\limits_{S\subseteq V}(-1)^{|S|}\cdot \prod\limits_{s_i} \left\lfloor \frac m{\operatorname{lcm} s_i} \right\rfloor\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;有个很神奇的操作是把 &lt;span class=&#34;math inline&#34;&gt;\(S\)&lt;/span&gt; 丢掉，直接枚举 &lt;span class=&#34;math inline&#34;&gt;\(\{s\}\)&lt;/span&gt; 尝试子集 DP。有：&lt;span class=&#34;math inline&#34;&gt;\(res=\sum\limits_{\{s\}}\prod\limits_s f(s)\cdot\left\lfloor \frac m{\operatorname{lcm} s} \right\rfloor\)&lt;/span&gt;。其中 &lt;span class=&#34;math inline&#34;&gt;\(f(s)\)&lt;/span&gt; 表示选取一个 &lt;span class=&#34;math inline&#34;&gt;\(s\)&lt;/span&gt; 的导出子图的容斥系数之和，其中次数为导出子图中边数。&lt;/p&gt;
&lt;p&gt;怎么把 &lt;span class=&#34;math inline&#34;&gt;\(f\)&lt;/span&gt; 算出来呢？容易发现其值只与 &lt;span class=&#34;math inline&#34;&gt;\(|s|\)&lt;/span&gt; 有关，考虑钦定与 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt; 连通的点数容斥，则有：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
f(n)=\sum\limits_{i=0}^{n - 1} (-1)^i \times C_{n-1}^{i-1} \times f(i) \cdot \sum_{j=0}^{m\gets i\times (i-1)\div 2} (-1)^j\cdot C_m^j
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;我们知道，二项式定理取 &lt;span class=&#34;math inline&#34;&gt;\(a=1, b = -1\)&lt;/span&gt; 有 &lt;span class=&#34;math inline&#34;&gt;\(0^m=[m=0]=\sum_{j=0}^m(-1)^j\cdot C_m^j\)&lt;/span&gt;，代入得：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
\begin{aligned}
f(n)&amp;amp;=\sum\limits_{i=0}^{n - 1} (-1)^i \times C_{n-1}^{n-i-1} \times f(n-i)\cdot [m=0\iff i=1]\\
&amp;amp;=(1 - n)\cdot f(n-1)
\end{aligned}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;然后就能线性求出。再用一个子集 DP，为了保证顺序枚举最小的未被确定的点所在连通块进行转移。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int mod = 998244353;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#endif
    int n, l;
    long long m;
    std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m, l = 1 &amp;lt;&amp;lt; n;
    std::vector&amp;lt;long long&amp;gt; d(n), f(n + 1), dp(l), g(l);
    f[1] = 1ll;
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        std::cin &amp;gt;&amp;gt; d[i - 1];
        if (i &amp;gt;= 2)
            f[i] = (1 + mod - i) * f[i - 1] % mod;
        // printf(&amp;quot;f[%d] = %lld\n&amp;quot;, i, f[i]);
    &amp;#125;
    for (int i = 0; i &amp;lt; l; ++i) &amp;#123;
        long long now = 1ll;
        for (int j = 0; j &amp;lt; n; ++j)
            if ((i &amp;gt;&amp;gt; j) &amp;amp; 1) &amp;#123;
                if (now / std::__gcd(now, d[j]) &amp;gt; m / d[j])
                    goto nosol;
                now = now / std::__gcd(now, d[j]) * d[j];
            &amp;#125;
        g[i] = (m / now) % mod;
        // printf(&amp;quot;lcm = %lld, g[%d] = %lld\n&amp;quot;, now, i, g[i]);
    nosol: ;
    &amp;#125;
    dp[0] = 1ll;
    auto lowbit = [](int x) &amp;#123;
        return x &amp;amp; -x;
    &amp;#125;;
    for (int i = 1; i &amp;lt; l; ++i) &amp;#123;
        int to = std::__lg(lowbit(i));
        for (int j = i; j; j = (j - 1) &amp;amp; i)
            if ((j &amp;gt;&amp;gt; to) &amp;amp; 1)
                (dp[i] += dp[i ^ j] * f[__builtin_popcount(j)] % mod * g[j] % mod) %= mod;
    &amp;#125;
    std::cout &amp;lt;&amp;lt; dp[l - 1] &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;f.-permutation&#34;&gt;F. Permutation&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://222.180.160.110:61235/contest/6181/problem/6&#34; class=&#34;uri&#34;&gt;http://222.180.160.110:61235/contest/6181/problem/6&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果全是 &lt;code&gt;&amp;lt;&lt;/code&gt;，方案数为 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;现在把其中一些 &lt;code&gt;&amp;lt;&lt;/code&gt; 变成 &lt;code&gt;?&lt;/code&gt;，比如 &lt;code&gt;&amp;lt;&amp;lt;??&amp;lt;?&amp;lt;&amp;lt;&amp;lt;&amp;lt;&lt;/code&gt; 的方案数，&lt;del&gt;太好了是多重集排列，我们没救了&lt;/del&gt; 显然被 &lt;code&gt;&amp;lt;&lt;/code&gt; 连接起来的一段元素只有一种排列方式，所以可以视为多重集排列，方案数为 &lt;span class=&#34;math inline&#34;&gt;\(\dfrac {11!}{3!\times 2!\times 5!}\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;似乎只需要枚举把 &lt;code&gt;&amp;gt;&lt;/code&gt; 变成 &lt;code&gt;&amp;lt;&lt;/code&gt; 或 &lt;code&gt;=&lt;/code&gt; 的 &lt;span class=&#34;math inline&#34;&gt;\(2^k\)&lt;/span&gt; 种情况再计算就可以了，可惜 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 有点大。但我们发现它在一定程度上是没有后效性的，比如 &lt;code&gt;&amp;lt;&amp;lt;??&amp;lt;&lt;/code&gt; 和 &lt;code&gt;&amp;lt;&amp;lt;?&amp;lt;&amp;lt;&lt;/code&gt;，前面的 &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; 不会对后面的内容带来影响。&lt;/p&gt;
&lt;p&gt;故令 &lt;span class=&#34;math inline&#34;&gt;\(f_i\)&lt;/span&gt; 表示对于前 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 个元素的方案数，枚举最后一个被钦定为 &lt;code&gt;?&lt;/code&gt; 的 &lt;code&gt;&amp;gt;&lt;/code&gt; &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt;（即 &lt;span class=&#34;math inline&#34;&gt;\([j + 1, i-1]\)&lt;/span&gt; 间的 &lt;code&gt;&amp;gt;&lt;/code&gt; 都被替换为 &lt;code&gt;&amp;lt;&lt;/code&gt;），带上容斥系数，有 &lt;span class=&#34;math inline&#34;&gt;\(f_i=\sum\limits_{s_j=\texttt{&amp;#39;&amp;gt;&amp;#39;}}(-1)^{cnt_\texttt{&amp;#39;&amp;gt;&amp;#39;}[j + 1, i - 1]}\times f_j\times\dfrac1{(i-j)!}\)&lt;/span&gt;。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int mod = 1e9 + 7;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#endif
    int n;
    std::cin &amp;gt;&amp;gt; n;
    std::vector&amp;lt;long long&amp;gt; fac(n + 1), inv(n + 1);
    fac[0] = 1ll, inv[0] = 1ll;
    for (int i = 1; i &amp;lt;= n; ++i)
        fac[i] = fac[i - 1] * i % mod;
    auto qkp = [](long long x, int y) &amp;#123;
        auto res = 1ll;
        for (; y; (x *= x) %= mod, y &amp;gt;&amp;gt;= 1)
            if (y &amp;amp; 1)
                (res *= x) %= mod;
        return res;
    &amp;#125;;
    inv[n] = qkp(fac[n], mod - 2);
    for (int i = n - 1; i; --i)
        inv[i] = inv[i + 1] * (i + 1) % mod;
    std::vector&amp;lt;char&amp;gt; s(n + 1);
    for (int i = 1; i &amp;lt;= n; ++i)
        std::cin &amp;gt;&amp;gt; s[i];
    std::vector&amp;lt;long long&amp;gt; f(n + 1);
    s[0] = &amp;#39;&amp;gt;&amp;#39;, f[0] = 1ll;
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        int cnt = 0;
        for (int j = i - 1; ~j; --j)
            if (s[j] == &amp;#39;&amp;gt;&amp;#39;) &amp;#123;
                long long k = (cnt &amp;amp; 1) ? mod - 1 : 1;
                (k *= f[j]) %= mod, (k *= inv[i - j]) %= mod;
                (f[i] += k) %= mod;
                ++cnt;
            &amp;#125;
        // printf(&amp;quot;f[%d] = %lld\n&amp;quot;, i, f[i]);
    &amp;#125;
    std::cout &amp;lt;&amp;lt; f[n] * fac[n] % mod &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;em&gt;忳郁邑余侘傺兮，余独穷困乎此时也。&lt;/em&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;h.-k-perm-counting&#34;&gt;H. ~K Perm Counting&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://222.180.160.110:61235/contest/6181/problem/8&#34; class=&#34;uri&#34;&gt;http://222.180.160.110:61235/contest/6181/problem/8&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;考虑钦定令几个元素不满足条件进行容斥，即答案为 &lt;span class=&#34;math inline&#34;&gt;\(\sum\limits_{i=0}^n (-1)^i\cdot f(i)\)&lt;/span&gt;。但我们发现 &lt;span class=&#34;math inline&#34;&gt;\([n-k,n+k]\)&lt;/span&gt; 都有两个不能选的值，直接取 &lt;span class=&#34;math inline&#34;&gt;\(f(i)=\prod 2\)&lt;/span&gt; 肯定会选到相同值，一个自然（？）的想法是再容斥一遍，可惜手玩一下发现似乎容不动。考虑把玩意儿拍在棋盘上：&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&#34;1.png&#34; alt=&#34;以 k=2 为例&#34; /&gt;&lt;figcaption&gt;以 &lt;span class=&#34;math inline&#34;&gt;\(k=2\)&lt;/span&gt; 为例&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;其中 &lt;span class=&#34;math inline&#34;&gt;\(\times\)&lt;/span&gt; 是非法格子，边是非法格子间的不同选关系，同颜色的边隶属同一条链。容易发现如果棋盘继续扩大，这些链还会继续延长。&lt;/p&gt;
&lt;p&gt;会发现这些链互不干扰，就是说我选了这条链上的某个点和链外的点没有任何关系（显然）。把这些链首尾相连拼起来，要做的就是拼接处可以选相邻，其余位置不能选相邻，选出来 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 个的方案数。提前预处理出来整个序列，令 &lt;span class=&#34;math inline&#34;&gt;\(tag_j\)&lt;/span&gt; 表示 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; 是否能和 &lt;span class=&#34;math inline&#34;&gt;\(j-1\)&lt;/span&gt; 同选，设 &lt;span class=&#34;math inline&#34;&gt;\(dp_{j,i,0/1}\)&lt;/span&gt; 表示 DP 到了 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt;，已经选了 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 个数，第 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; 个元素（不）选的方案数，那么有：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
dp_{j,i,0} = dp_{j - 1, i, 0} + dp_{j-1, i, 1}\\
dp_{j,i,1} = \begin{cases}
dp_{j-1, i - 1, 1} + dp_{j-1,i - 1,0}&amp;amp;tag_j=1
\\
dp_{j-1,i,0}&amp;amp;\text{otherwise}
\end{cases}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;大力 DP 即可。&lt;span class=&#34;math inline&#34;&gt;\(f(i)\)&lt;/span&gt; 即为 &lt;span class=&#34;math inline&#34;&gt;\((n-i)!\times (dp_{m, i, 0} + dp_{m, i, 1})\)&lt;/span&gt;，其中 &lt;span class=&#34;math inline&#34;&gt;\(m\)&lt;/span&gt; 为总链长。&lt;/p&gt;
&lt;details&gt;
&lt;p&gt;注意不滚动可能会 MLE &lt;img src=&#34;/em/kt.gif&#34; /&gt;&lt;/p&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int mod = 924844033;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#endif
    int n, k;
    std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; k;
    std::vector&amp;lt;int&amp;gt; tag(1);
    std::vector&amp;lt;long long&amp;gt; fac(n + 1);
    std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; vis(n + 1, std::vector&amp;lt;int&amp;gt; (n + 1));
    auto calc = [&amp;amp;](int i, int j, int s) &amp;#123;
        tag.push_back(1);
        for (; ; s ^= 1) &amp;#123;
            // printf(&amp;quot;(%d, %d) &amp;quot;, i, j);
            vis[i][j] = 1;
            if (!s) &amp;#123;
                i = j + k;
                if (i &amp;lt;= n)
                    tag.push_back(0);
                else
                    break;
            &amp;#125;
            else &amp;#123;
                j = i + k;
                if (j &amp;lt;= n)
                    tag.push_back(0);
                else
                    break;
            &amp;#125;
        &amp;#125;
        // puts(&amp;quot;&amp;quot;);
        return;
    &amp;#125;;
    fac[0] = 1ll;
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        fac[i] = fac[i - 1] * i % mod;
        int j = i - k;
        if (j &amp;gt;= 1 &amp;amp;&amp;amp; !vis[i][j])
            calc(i, j, 1);
        j = i + k;
        if (j &amp;lt;= n &amp;amp;&amp;amp; !vis[i][j])
            calc(i, j, 0);
    &amp;#125;
    int m = (int)tag.size() - 1;
    // printf(&amp;quot;m = %d\n&amp;quot;, m);
    std::vector&amp;lt;std::vector&amp;lt;std::vector&amp;lt;long long&amp;gt; &amp;gt; &amp;gt; dp(2, std::vector&amp;lt;std::vector&amp;lt;long long&amp;gt; &amp;gt; (n + 1, std::vector&amp;lt;long long&amp;gt; (2)));
    dp[0][0][0] = 1ll;
    for (int j = 1, now = 1; j &amp;lt;= m; ++j, now ^= 1) &amp;#123;
        for (int i = 0; i &amp;lt;= n &amp;amp;&amp;amp; i &amp;lt;= j; ++i) &amp;#123;
            dp[now][i][0] = dp[!now][i][0];
            dp[now][i][1] = 0ll;
            if (i) &amp;#123;
                (dp[now][i][0] += dp[!now][i][1]) %= mod;
                dp[now][i][1] = dp[!now][i - 1][0];
                if (tag[j]) &amp;#123;
                    (dp[now][i][1] += dp[!now][i - 1][1]) %= mod;
                    // assert(0);
                &amp;#125;
            &amp;#125;
            // printf(&amp;quot;dp[%d][%d] = %lld / %lld\n&amp;quot;, j, i, dp[j][i][0], dp[j][i][1]);
        &amp;#125;
    &amp;#125;
    long long res = 0ll;
    for (int i = 0, p = 1; i &amp;lt;= n; ++i, p = mod - p)
        (res += p * fac[n - i] % mod * (dp[m &amp;amp; 1][i][0] + dp[m &amp;amp; 1][i][1]) % mod) %= mod;
    std::cout &amp;lt;&amp;lt; res &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;a---positions-in-permutations&#34;&gt;A - Positions in Permutations&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://codeforces.com/problemset/problem/285/E&#34; class=&#34;uri&#34;&gt;https://codeforces.com/problemset/problem/285/E&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;del&gt;（看向上一题）这照片是你吗？&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;在上一题的基础上，令 &lt;span class=&#34;math inline&#34;&gt;\(k=1\)&lt;/span&gt;。但是有个小小的问题——所求的「至少」不为 &lt;span class=&#34;math inline&#34;&gt;\(0\)&lt;/span&gt;，无法简单容斥。具体地，如果一个排列一共有 &lt;span class=&#34;math inline&#34;&gt;\(p\)&lt;/span&gt; 个非法排列，那么它会被 &lt;span class=&#34;math inline&#34;&gt;\(f(i)\)&lt;/span&gt; 统计 &lt;span class=&#34;math inline&#34;&gt;\(C_p^i\)&lt;/span&gt; 次。令 &lt;span class=&#34;math inline&#34;&gt;\(g(p)\)&lt;/span&gt; 表示非法格子数恰好为 &lt;span class=&#34;math inline&#34;&gt;\(p\)&lt;/span&gt; 的排列的真实数量，则 &lt;span class=&#34;math inline&#34;&gt;\(f(i)=\sum\limits_{j=i}^n C_j^i\cdot g(j)\)&lt;/span&gt;，二项式反演即可得到真实值 &lt;span class=&#34;math inline&#34;&gt;\(g(m)=\sum\limits_{j=m}^n (-1)^{j-m}\cdot C_j^m\cdot f(j)\)&lt;/span&gt;。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int mod = 1e9 + 7;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#endif
    int n, k;
    std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; k;
    std::vector&amp;lt;int&amp;gt; tag(1);
    std::vector&amp;lt;long long&amp;gt; fac(n + 1), inv(n + 1);
    std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; vis(n + 1, std::vector&amp;lt;int&amp;gt; (n + 1));
    auto calc = [&amp;amp;](int i, int j, int s) &amp;#123;
        tag.push_back(1);
        for (; i &amp;lt;= n &amp;amp;&amp;amp; j &amp;lt;= n; s ^= 1) &amp;#123;
            vis[i][j] = 1;
            if (!s) &amp;#123;
                i = j + 1;
                if (i &amp;lt;= n)
                    tag.push_back(0);
            &amp;#125;
            else &amp;#123;
                j = i + 1;
                if (j &amp;lt;= n)
                    tag.push_back(0);
            &amp;#125;
        &amp;#125;
        return;
    &amp;#125;;
    auto qkp = [&amp;amp;](long long x, int y) &amp;#123;
        auto res = 1ll;
        for (; y; (x *= x) %= mod, y &amp;gt;&amp;gt;= 1)
            if (y &amp;amp; 1)
                (res *= x) %= mod;
        return res;
    &amp;#125;;
    fac[0] = 1ll, inv[0] = 1ll;
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        fac[i] = fac[i - 1] * i % mod;
        int j = i - 1;
        if (j &amp;gt;= 1 &amp;amp;&amp;amp; !vis[i][j])
            calc(i, j, 1);
        j = i + 1;
        if (j &amp;lt;= n &amp;amp;&amp;amp; !vis[i][j])
            calc(i, j, 0);
    &amp;#125;
    inv[n] = qkp(fac[n], mod - 2);
    for (int i = n - 1; i; --i)
        inv[i] = inv[i + 1] * (i + 1) % mod;
    int m = (int)tag.size() - 1;
    std::vector&amp;lt;std::vector&amp;lt;std::vector&amp;lt;long long&amp;gt; &amp;gt; &amp;gt; dp(2, std::vector&amp;lt;std::vector&amp;lt;long long&amp;gt; &amp;gt; (n + 1, std::vector&amp;lt;long long&amp;gt; (2)));
    dp[0][0][0] = 1ll;
    for (int j = 1, now = 1; j &amp;lt;= m; ++j, now ^= 1) &amp;#123;
        for (int i = 0; i &amp;lt;= n &amp;amp;&amp;amp; i &amp;lt;= j; ++i) &amp;#123;
            dp[now][i][0] = dp[!now][i][0];
            dp[now][i][1] = 0ll;
            if (i) &amp;#123;
                (dp[now][i][0] += dp[!now][i][1]) %= mod;
                dp[now][i][1] = dp[!now][i - 1][0];
                if (tag[j])
                    (dp[now][i][1] += dp[!now][i - 1][1]) %= mod;
            &amp;#125;
        &amp;#125;
    &amp;#125;
    auto C = [&amp;amp;](int n, int m) &amp;#123;
        return fac[n] * inv[n - m] % mod * inv[m] % mod;
    &amp;#125;;
    long long res = 0ll;
    for (int i = k, p = 1; i &amp;lt;= n; ++i, p = mod - p) &amp;#123;
        // printf(&amp;quot;%d: %lld\n&amp;quot;, i, C(i, k) * fac[n - i] % mod * (dp[m &amp;amp; 1][i][0] + dp[m &amp;amp; 1][i][1]) % mod);
        (res += p * C(i, k) % mod * fac[n - i] % mod * (dp[m &amp;amp; 1][i][0] + dp[m &amp;amp; 1][i][1]) % mod) %= mod;
    &amp;#125;
    std::cout &amp;lt;&amp;lt; res &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;d---all-pairs-similarity-p&#34;&gt;D - All Pairs Similarity P&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P11458&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P11458&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;省流：求 &lt;span class=&#34;math inline&#34;&gt;\(\forall\,i,f_i=\sum\limits_{j=1}^n \dfrac{|a_i\cap a_j|}{|a_i\cup a_j|}\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;首先分离常数，有：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
\begin{aligned}
f_i&amp;amp;=\sum\limits_{j=1}^n \dfrac{|a_i\cap a_j|}{|a_i\cup a_j|}\\
&amp;amp;=\sum_{j=1}^n\dfrac {|a_i|+|a_j|-|a_i\cup a_j|}{|a_i\cup a_j|}\\
&amp;amp;=\sum_{j=1}^n \dfrac {|a_i|+|a_j|}{|a_i\cup a_j|}-1
\end{aligned}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;尽量把分子变得更简：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
\begin{aligned}
f_i&amp;amp;=\sum_{j=1}^n \dfrac {|a_i|+|a_j|}{|a_i\cup a_j|}-1\\
&amp;amp;=|a_i|\cdot\left(\sum_{j=1}^n\dfrac 1{|a_i\cup a_j|}\right)-n+\sum_{j=1}^n \dfrac {|a_j|}{|a_i\cup a_j|}
\end{aligned}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;问题转化为求解 &lt;span class=&#34;math inline&#34;&gt;\(\sum\limits_{j=1}^n\dfrac 1{|a_i\cup a_j|}\)&lt;/span&gt; 和 &lt;span class=&#34;math inline&#34;&gt;\(\sum\limits_{j=1}^n\dfrac {|a_j|}{|a_i\cup a_j|}\)&lt;/span&gt;，以 &lt;span class=&#34;math inline&#34;&gt;\(*=\sum\limits_{j=1}^n\dfrac 1{|a_i\cup a_j|}\)&lt;/span&gt; 为例。令 &lt;span class=&#34;math inline&#34;&gt;\(b_i\)&lt;/span&gt; 为 &lt;span class=&#34;math inline&#34;&gt;\(a_i\)&lt;/span&gt; 补集，则：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
\begin{aligned}
*&amp;amp;=\sum\limits_{j=1}^n\dfrac 1{|a_i\cup a_j|}\\
&amp;amp;=\sum_{j=1}^n\dfrac 1{k-|b_i\cap b_j|}
\end{aligned}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;为什么要做这个转换呢？相比起并集运算，交集运算有着优秀的性质：&lt;span class=&#34;math inline&#34;&gt;\(s\subseteq(b_i\cap b_j)\iff s\subseteq b_i\land s\subseteq b_j\)&lt;/span&gt;，&lt;del&gt;直接取或当然也有相似的性质，但是太烧脑了&lt;/del&gt;。&lt;/p&gt;
&lt;p&gt;基于这个性质，我们有一个想法：对于所有 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt;，在 &lt;span class=&#34;math inline&#34;&gt;\(\forall \, s\subseteq b_j\)&lt;/span&gt; 处放置 &lt;span class=&#34;math inline&#34;&gt;\(\dfrac 1{k-|s|}\)&lt;/span&gt; 的贡献；对于 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt;，将 &lt;span class=&#34;math inline&#34;&gt;\(\forall \, s\subseteq b_i\)&lt;/span&gt; 处的贡献求和。但是这样肯定会拿到很多我们不想要的贡献，例如 &lt;span class=&#34;math inline&#34;&gt;\(\forall \, s\subset (b_i\cap b_j)\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;考虑精细布置贡献——构造 &lt;span class=&#34;math inline&#34;&gt;\(g(|s|)\)&lt;/span&gt; 满足 &lt;span class=&#34;math inline&#34;&gt;\(\sum\limits_{j=1}^n\sum\limits_{s\subseteq b_j}g(|s|)=*\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;这里可以二项式反演得到 &lt;span class=&#34;math inline&#34;&gt;\(g\)&lt;/span&gt;，具体地，令 &lt;span class=&#34;math inline&#34;&gt;\(F(|S|)=\dfrac 1{k-|S|}=\sum\limits_{s\subseteq S}g(|s|)=\sum\limits_{j=0}^{|S|} C_{|S|}^j g(j)\)&lt;/span&gt;，则 &lt;span class=&#34;math inline&#34;&gt;\(g(i)=\sum\limits_{j=0}^iC_i^j\cdot \dfrac {(-1)^{i-j}}{k-j}\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;再令 &lt;span class=&#34;math inline&#34;&gt;\(h(s)=\sum\limits_{b_j\supseteq s}g(|s|)=g(|s|)\cdot \sum\limits_{b_j\supseteq s}1\)&lt;/span&gt;，那么 &lt;span class=&#34;math inline&#34;&gt;\(h\)&lt;/span&gt; 就是高维后缀和。我们正在做的事情就是求解 &lt;span class=&#34;math inline&#34;&gt;\(*=\sum\limits_{s\subseteq b_i}h(s)\)&lt;/span&gt;，这就又是一个高维前缀和了。&lt;/p&gt;
&lt;p&gt;对于 &lt;span class=&#34;math inline&#34;&gt;\(\sum\limits_{j=1}^n\dfrac {|a_j|}{|a_i\cup a_j|}\)&lt;/span&gt; 呢，令 &lt;span class=&#34;math inline&#34;&gt;\(h(s)=\sum\limits_{b_j\supseteq s}g(|s|)\cdot {\color{red}{|a_j|}} = g(|s|) \cdot \sum\limits_{b_j\supseteq s} \color{red}{k - |b_j|}\)&lt;/span&gt;，改变高维后缀和求和对象即可。&lt;/p&gt;
&lt;p&gt;复杂度就是 &lt;span class=&#34;math inline&#34;&gt;\(O(n+k\cdot 2^k)\)&lt;/span&gt;，其中 &lt;span class=&#34;math inline&#34;&gt;\(k\cdot 2^k\)&lt;/span&gt; 来自整体高维前 / 后缀和，&lt;span class=&#34;math inline&#34;&gt;\(n\cdot k\)&lt;/span&gt; 来自枚举 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt;。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int mod = 1e9 + 7;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#endif
    int n, k, l;
    std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; k, l = 1 &amp;lt;&amp;lt; k;
    std::vector&amp;lt;int&amp;gt; a(n + 1), b(n + 1), cnt(l);
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        std::cin &amp;gt;&amp;gt; a[i], b[i] = (l - 1) ^ a[i];
        ++cnt[b[i]];
    &amp;#125;
    std::vector&amp;lt;long long&amp;gt; g(k + 1), fac(k + 1);
    auto qkp = [&amp;amp;](long long x, int y = mod - 2) &amp;#123;
        auto res = 1ll;
        for (; y; (x *= x) %= mod, y &amp;gt;&amp;gt;= 1)
            if (y &amp;amp; 1)
                (res *= x) %= mod;
        return res;
    &amp;#125;;
    auto C = [&amp;amp;](int n, int m) &amp;#123;
        return fac[n] * qkp(fac[n - m]) % mod * qkp(fac[m]) % mod;
    &amp;#125;;
    fac[0] = 1ll;
    for (int i = 1; i &amp;lt;= k; ++i)
        fac[i] = fac[i - 1] * i % mod;
    for (int i = 0; i &amp;lt;= k; ++i) &amp;#123;
        for (int j = 0, p = (i &amp;amp; 1) ? mod - 1 : 1; j &amp;lt;= i; ++j, p = mod - p)
            (g[i] += C(i, j) * p % mod * qkp(k - j) % mod) %= mod;
        // printf(&amp;quot;g[%d] = %lld\n&amp;quot;, i, g[i]);
    &amp;#125;
    // for (int i = 0; i &amp;lt;= k; ++i) &amp;#123;
    //     long long F = 0ll;
    //     for (int j = 0; j &amp;lt;= i; ++j)
    //         (F += C(i, j) * g[j] % mod) %= mod;
    //     printf(&amp;quot;%d: %lld / %lld\n&amp;quot;, i, F, qkp(k - i));
    // &amp;#125;
    std::vector&amp;lt;long long&amp;gt; h(l);
    std::copy(cnt.begin(), cnt.end(), h.begin());
    for (int i = 0; i &amp;lt; k; ++i)
        for (int j = l - 1; ~j; --j)
            if (!((j &amp;gt;&amp;gt; i) &amp;amp; 1))
                (h[j] += h[j ^ (1 &amp;lt;&amp;lt; i)]) %= mod;
    auto f1(h);
    for (int i = 0; i &amp;lt; l; ++i)
        (f1[i] *= g[__builtin_popcount(i)]) %= mod;
    for (int i = 0; i &amp;lt; k; ++i)
        for (int j = 0; j &amp;lt; l; ++j)
            if ((j &amp;gt;&amp;gt; i) &amp;amp; 1)
                (f1[j] += f1[j ^ (1 &amp;lt;&amp;lt; i)]) %= mod;
    for (int i = 0; i &amp;lt; l; ++i)
        h[i] = cnt[i] * (k - __builtin_popcount(i));
    for (int i = 0; i &amp;lt; k; ++i)
        for (int j = l - 1; ~j; --j)
            if (!((j &amp;gt;&amp;gt; i) &amp;amp; 1))
                (h[j] += h[j ^ (1 &amp;lt;&amp;lt; i)]) %= mod;
    auto f2(h);
    for (int i = 0; i &amp;lt; l; ++i)
        (f2[i] *= g[__builtin_popcount(i)]) %= mod;
    for (int i = 0; i &amp;lt; k; ++i)
        for (int j = 0; j &amp;lt; l; ++j)
            if ((j &amp;gt;&amp;gt; i) &amp;amp; 1)
                (f2[j] += f2[j ^ (1 &amp;lt;&amp;lt; i)]) %= mod;
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        // fprintf(stderr, &amp;quot;%d: %d * %lld - %d + %lld\n&amp;quot;, i, __builtin_popcount(a[i]), f1[b[i]], n, f2[b[i]]);
        std::cout &amp;lt;&amp;lt; (__builtin_popcount(a[i]) * f1[b[i]] % mod + mod - n + f2[b[i]]) % mod &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    &amp;#125;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;e---prefix-xors&#34;&gt;E - Prefix XORs&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/arc137/tasks/arc137_d&#34; class=&#34;uri&#34;&gt;https://atcoder.jp/contests/arc137/tasks/arc137_d&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;省流：做 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 次前缀和，&lt;span class=&#34;math inline&#34;&gt;\(k=1,2,\cdots,m\)&lt;/span&gt;，分别询问：令 &lt;span class=&#34;math inline&#34;&gt;\(x_i\gets a_i\)&lt;/span&gt; 对 &lt;span class=&#34;math inline&#34;&gt;\(s_n\)&lt;/span&gt; 的贡献次数，则 &lt;span class=&#34;math inline&#34;&gt;\(\sum a_i\cdot (x_i\bmod 2)\)&lt;/span&gt;？&lt;/p&gt;
&lt;p&gt;对于 &lt;span class=&#34;math inline&#34;&gt;\(a_p\)&lt;/span&gt;，容易发现第一轮其对任意 &lt;span class=&#34;math inline&#34;&gt;\(s_q\)&lt;/span&gt; 有 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt; 次贡献，拉开来就是常数列；第二轮有 &lt;span class=&#34;math inline&#34;&gt;\((q-p+1)\)&lt;/span&gt; 次贡献，是公差为 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt; 的等差数列；第三轮是类三角形数——至此，肯定和组合数有关了。手玩可以发现第 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 轮 &lt;span class=&#34;math inline&#34;&gt;\(a_p\)&lt;/span&gt; 对 &lt;span class=&#34;math inline&#34;&gt;\(s_n\)&lt;/span&gt; 的贡献为 &lt;span class=&#34;math inline&#34;&gt;\(C_{n-p+(k-2)}^{n-p}\)&lt;/span&gt;，尽量令其中一个不动，得到 &lt;span class=&#34;math inline&#34;&gt;\(C_{n-p+(k-2)}^{k-1}\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;但是我们发现直接枚举每轮每个数会起飞，而且模数为 &lt;span class=&#34;math inline&#34;&gt;\(2\)&lt;/span&gt; 似乎只能 Lucas（再带个 &lt;span class=&#34;math inline&#34;&gt;\(\log\)&lt;/span&gt;），怎么办呢？&lt;/p&gt;
&lt;p&gt;那就 Lucas 呗。由其观察容易发现 &lt;span class=&#34;math inline&#34;&gt;\(C_{n-p+(k-2)}^{k-2}\bmod2=1\)&lt;/span&gt; 当且仅当 &lt;span class=&#34;math inline&#34;&gt;\((k-2)\subseteq (n-p+k-2)\iff (k-2)\subseteq \complement_U(n-p)\)&lt;/span&gt;，故问题转化为高维后缀和，&lt;del&gt;当然你也可以做一次 and-FWT&lt;/del&gt;，那么 &lt;span class=&#34;math inline&#34;&gt;\(res_k=\sum (C_{n-p+(k-2)}^{k-2}\bmod 2)\cdot a_p=S_{k-2}\)&lt;/span&gt;，其中 &lt;span class=&#34;math inline&#34;&gt;\(S\)&lt;/span&gt; 为高维后缀和，初值为 &lt;span class=&#34;math inline&#34;&gt;\(S_{\complement_u(n-i)}\gets a_i\)&lt;/span&gt;。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#endif
    int n, m, l, k;
    std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m, k = std::__lg(n + m) + 1, l = 1 &amp;lt;&amp;lt; k;
    std::vector&amp;lt;int&amp;gt; s(l);
    for (int i = 1; i &amp;lt;= n; ++i)
        std::cin &amp;gt;&amp;gt; s[l - 1 - (n - i)];
    for (int i = 0; i &amp;lt; k; ++i)
        for (int j = l - 1; ~j; --j)
            if (!((j &amp;gt;&amp;gt; i) &amp;amp; 1))
                s[j] ^= s[j ^ (1 &amp;lt;&amp;lt; i)];
    for (int i = 1; i &amp;lt;= m; ++i)
        std::cout &amp;lt;&amp;lt; s[i - 1] &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
    std::cout &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;b---the-top-scorer&#34;&gt;B - The Top Scorer&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://codeforces.com/problemset/problem/1096/E&#34; class=&#34;uri&#34;&gt;https://codeforces.com/problemset/problem/1096/E&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;鉴于每种方案等概率（翻译没说，但原题面有提到），考虑计算小明能够取胜的方案数，再对总方案数做除法。先枚举最高分 &lt;span class=&#34;math inline&#34;&gt;\(k\ge r\)&lt;/span&gt;，再枚举包括小明在内恰有 &lt;span class=&#34;math inline&#34;&gt;\(c\ge 1\)&lt;/span&gt; 个人 拿到 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 分。但剩下的人呢？显然是不能插板随机分配的，因为存在 &lt;span class=&#34;math inline&#34;&gt;\(&amp;lt;k\)&lt;/span&gt; 的限制。&lt;/p&gt;
&lt;p&gt;考虑容斥，钦定剩下的 &lt;span class=&#34;math inline&#34;&gt;\(p-c\)&lt;/span&gt; 个人中拿到 &lt;span class=&#34;math inline&#34;&gt;\(\ge k\)&lt;/span&gt; 分的人数后再可空地插板即可，则总方案数为：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
\sum_{k=r}^s\sum_{c=1}^p\dfrac {C_{p - 1}^{c-1}}c\cdot \sum_{i=0}^{p-c}C_{p-c}^i\cdot C_{s-k\cdot (c+i)+(p-c-1)}^{p-c-1}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其中分母上的 &lt;span class=&#34;math inline&#34;&gt;\(c\)&lt;/span&gt; 来源于等概率分配给最高分，虽然不是整数，但也代表着「小明获胜可行方案数」。最后将答案除上总方案数 &lt;span class=&#34;math inline&#34;&gt;\(C_{s-r+p-1}^{p-1}\)&lt;/span&gt; 即可。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int mod = 998244353;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#endif
    int p, s, r;
    std::cin &amp;gt;&amp;gt; p &amp;gt;&amp;gt; s &amp;gt;&amp;gt; r;
    std::vector&amp;lt;long long&amp;gt; fac(s + p), inv(s + p);
    fac[0] = inv[0] = 1ll;
    for (int i = 1; i &amp;lt; s + p; ++i) &amp;#123;
        fac[i] = fac[i - 1] * i % mod;
    &amp;#125;
    auto qkp = [&amp;amp;](long long x, int y) &amp;#123;
        auto res = 1ll;
        for (; y; (x *= x) %= mod, y &amp;gt;&amp;gt;= 1)
            if (y &amp;amp; 1)
                (res *= x) %= mod;
        return res;
    &amp;#125;;
    inv.back() = qkp(fac.back(), mod - 2);
    for (int i = s + p - 2; i &amp;gt; 0; --i)
        inv[i] = inv[i + 1] * (i + 1) % mod;
    auto C = [&amp;amp;](int n, int m) &amp;#123;
        if (n == -1 &amp;amp;&amp;amp; m == -1)
            return 1ll;
        return fac[n] * inv[n - m] % mod * inv[m] % mod;
    &amp;#125;;
    auto res(0ll);
    for (int k = r; k &amp;lt;= s; ++k)
        for (int c = 1; c &amp;lt;= p; ++c)
            if ((p - c) * (k - 1) + c * k &amp;gt;= s) &amp;#123;
                auto t(0ll);
                for (int i = 0, now = 1; i &amp;lt;= p - c &amp;amp;&amp;amp; k * (c + i) &amp;lt;= s; ++i, now = mod - now)
                    (t += now * C(p - c, i) % mod * C(s - k * (c + i) + (p - c - 1), p - c - 1) % mod) %= mod;
                (res += C(p - 1, c - 1) * qkp(c, mod - 2) % mod * t % mod) %= mod;
            &amp;#125;
    std::cout &amp;lt;&amp;lt; res * qkp(C(s - r + p - 1, p - 1), mod - 2) % mod &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;c---sky-full-of-stars&#34;&gt;C - Sky Full of Stars&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://codeforces.com/problemset/problem/997/C&#34; class=&#34;uri&#34;&gt;https://codeforces.com/problemset/problem/997/C&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;发现用 &lt;span class=&#34;math inline&#34;&gt;\(3^{n\times n}\)&lt;/span&gt; 减去任意一行一列不同色的方案就是答案。&lt;/p&gt;
&lt;p&gt;考虑一元容斥，如令 &lt;span class=&#34;math inline&#34;&gt;\(f_i\)&lt;/span&gt; 表示至少 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 行 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 列同色的方案，但会发现 &lt;span class=&#34;math inline&#34;&gt;\(f_0\)&lt;/span&gt; 中包含 &lt;span class=&#34;math inline&#34;&gt;\(0\)&lt;/span&gt; 行 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt; 列同色等与预期不符的情况。受此启发考虑令 &lt;span class=&#34;math inline&#34;&gt;\(f_{i,j}\)&lt;/span&gt; 表示至少 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 行 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; 列同色进行二元容斥。容易发现当 &lt;span class=&#34;math inline&#34;&gt;\(i\times j\ne 0\)&lt;/span&gt; 时，被选中的 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 行 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; 列全部连通，应为同一种颜色；将它们挪到角落，可以发现未被选中的格子共有 &lt;span class=&#34;math inline&#34;&gt;\((n-i)\times (n-j)\)&lt;/span&gt; 个。故有：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
f_{i,j}=\begin{cases}
C_n^j\times 3^j\times 3^{n\times(n - j)}&amp;amp;i=0\\
C_n^i\times 3^i\times 3^{n\times(n-i)}&amp;amp;j=0\\
C_n^i\times C_n^j\times 3\times 3^{(n-i)\times (n-j)}&amp;amp;\text{otherwise}
\end{cases}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;令 &lt;span class=&#34;math inline&#34;&gt;\(g_{i,j}\)&lt;/span&gt; 表示恰好 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 行 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; 列同色的方案数，那么答案为 &lt;span class=&#34;math inline&#34;&gt;\(3^{n\times n}-g_{0,0}\)&lt;/span&gt;。二项式反演 / 容斥原理得 &lt;span class=&#34;math inline&#34;&gt;\(g_{0,0}=\sum\limits_{i=0}^n\sum\limits_{j=0}^n (-1)^{i+j}\cdot f_{i,j}\)&lt;/span&gt;。很惊讶地发现这是 &lt;span class=&#34;math inline&#34;&gt;\(O(n^2)\)&lt;/span&gt; 的！考虑优化。把 &lt;span class=&#34;math inline&#34;&gt;\(f_{1\to n,1\to n}\)&lt;/span&gt; 合并同类项，得到：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
\begin{aligned}
g_{0, 0}
&amp;amp;=\left[\sum_{j=0}^n (-1)^j\cdot f_{0,j}\right]+\sum_{i=1}^n (-1)^i\cdot f_{i,0}+\sum_{j=1}^n (-1)^{i+j}\cdot C_n^i\times C_n^j\times 3^{(n-i)\times (n-j)+1}\\
&amp;amp;=\left[\sum_{j=0}^n (-1)^j\cdot f_{0,j}\right]+\sum_{i=1}^n (-1)^i\cdot f_{i,0}+(-1)^i\cdot C_n^i\times 3^{n^2-n\times i+1}\times\sum_{j=1}^n (-1)^j\cdot C_n^j\times 3^{j\times(-n+i)}\\
&amp;amp;=\left[\sum_{j=0}^n (-1)^j\cdot f_{0,j}\right]+\sum_{i=1}^n (-1)^i\cdot f_{i,0}+(-1)^i\cdot C_n^i\times 3^{n^2-n\times i+1}\times\left[\left(\sum_{j=0}^n (-1)^j\cdot C_n^j\times (3^{-n+i})^j\right)-1\right]\\
&amp;amp;=\left[\sum_{j=0}^n (-1)^j\cdot f_{0,j}\right]+\sum_{i=1}^n (-1)^i\cdot f_{i,0}+(-1)^i\cdot C_n^i\times 3^{n^2-n\times i+1}\times\left[(-3^{-n+i}+1)^n-1\right]
\end{aligned}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;由此便可 &lt;span class=&#34;math inline&#34;&gt;\(O(n\log n)\)&lt;/span&gt; 计算。担心超时可以把所有 &lt;span class=&#34;math inline&#34;&gt;\(3^{-n+i}\)&lt;/span&gt; 和 &lt;span class=&#34;math inline&#34;&gt;\(3^{n\times i}\)&lt;/span&gt; 线性预处理出来，复杂度不会变就是了。&lt;/p&gt;
&lt;p&gt;这里解释一下最后一步的二项式定理，非常遗憾地发现 &lt;span class=&#34;math inline&#34;&gt;\(-1\)&lt;/span&gt; 和 &lt;span class=&#34;math inline&#34;&gt;\(3^{-n+i}\)&lt;/span&gt; 都是 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; 次的，没办法把二者相加减做二项式定理；但由于次数相同，这提示我们可以把 &lt;span class=&#34;math inline&#34;&gt;\(-1\)&lt;/span&gt; 乘到 &lt;span class=&#34;math inline&#34;&gt;\(3^{-n+i}\)&lt;/span&gt; 里去，给每一项配上 &lt;span class=&#34;math inline&#34;&gt;\(1^{n-k}\)&lt;/span&gt; 就可以做 &lt;span class=&#34;math inline&#34;&gt;\(-3^{n-i}\)&lt;/span&gt;（注意不是 &lt;span class=&#34;math inline&#34;&gt;\((-3)^{n-i}\)&lt;/span&gt;） 和 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt; 的二项式定理。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int mod = 998244353;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#endif
    long long n;
    std::cin &amp;gt;&amp;gt; n;
    std::vector&amp;lt;long long&amp;gt; fac(n + 1), inv(n + 1), invn(n + 1), invi(n + 1), powi(n + 1), pown(n + 1);
    auto qkp = [&amp;amp;](long long x, long long y) &amp;#123;
        auto res(1ll);
        for (; y; (x *= x) %= mod, y &amp;gt;&amp;gt;= 1)
            if (y &amp;amp; 1)
                (res *= x) %= mod;
        return res;
    &amp;#125;;
    const long long pnn = qkp(3ll, n * n), pn = qkp(3ll, n);
    fac[0] = inv[0] = invn[0] = invi[0] = powi[0] = pown[0] = 1ll;
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        fac[i] = fac[i - 1] * i % mod;
        powi[i] = powi[i - 1] * 3 % mod;
        pown[i] = pown[i - 1] * pn % mod;
    &amp;#125;
    inv[n] = qkp(fac[n], mod - 2);
    invi[n] = qkp(powi[n], mod - 2);
    invn[n] = qkp(pown[n], mod - 2);
    for (int i = n - 1; i; --i) &amp;#123;
        inv[i] = inv[i + 1] * (i + 1) % mod;
        invi[i] = invi[i + 1] * 3 % mod;
        invn[i] = invn[i + 1] * pn % mod;
    &amp;#125;
    auto C = [&amp;amp;](int n, int m) &amp;#123;
        return fac[n] * inv[n - m] % mod * inv[m] % mod;
    &amp;#125;;
    long long g = 0ll;
    auto f = [&amp;amp;](int i, int j) &amp;#123; // make sure (!i || !j)
        if (i == 0 &amp;amp;&amp;amp; j == 0)
            return pnn;
        else if (i == 0)
            return C(n, j) * powi[j] % mod * pown[n - j] % mod;
        return C(n, i) * powi[i] % mod * pown[n - i] % mod;
    &amp;#125;;
    for (int j = 0, p = 1; j &amp;lt;= n; ++j, p = mod - p)
        (g += p * f(0, j)) %= mod;
    for (int i = 1, p = mod - 1; i &amp;lt;= n; ++i, p = mod - p)
        (g += p * f(i, 0) % mod + p * C(n, i) % mod * pnn % mod * invn[i] % mod * 3 % mod * (qkp(mod - invi[n - i] + 1, n) + mod - 1) % mod) %= mod;
    std::cout &amp;lt;&amp;lt; (pnn + mod - g) % mod &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;d---去-m-nom&#34;&gt;D - 去 M / NoM&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P11316&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P11316&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;假设 &lt;span class=&#34;math inline&#34;&gt;\(f(i)\)&lt;/span&gt; 为至少有 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 对不合法元素的方案数，则容斥得到答案 &lt;span class=&#34;math inline&#34;&gt;\(\sum\limits_{i=0}^n (-1)^i\cdot f(i)\)&lt;/span&gt;。考虑怎么计算 &lt;span class=&#34;math inline&#34;&gt;\(f(i)\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;&lt;mark&gt;&lt;span class=&#34;math inline&#34;&gt;\(M\)&lt;/span&gt; 整除 &lt;span class=&#34;math inline&#34;&gt;\(dis(x, y) \iff (pos_x - pos_y)\bmod M=0\iff pos_x\equiv pos_y\pmod M\)&lt;/span&gt;。&lt;/mark&gt;&lt;/p&gt;
&lt;p&gt;考虑把关于 &lt;span class=&#34;math inline&#34;&gt;\(M\)&lt;/span&gt; 同余的位置放在一个组，也就是说需要让一对元素不能选同一组的位置。&lt;/p&gt;
&lt;p&gt;考虑容斥，令 &lt;span class=&#34;math inline&#34;&gt;\(f(i)\)&lt;/span&gt; 表示至少有 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 对点选到一组的方案数，考虑怎么计算。假设我们要在第 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 组（size 为 &lt;span class=&#34;math inline&#34;&gt;\(s_k\)&lt;/span&gt;）中选出 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 对位置，实际上只需要选择 &lt;span class=&#34;math inline&#34;&gt;\(2x\)&lt;/span&gt; 个位置然后任意分配给这 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 对数，即 &lt;span class=&#34;math inline&#34;&gt;\(A_{s_k}^{2x}\)&lt;/span&gt;。设 &lt;span class=&#34;math inline&#34;&gt;\(dp_{i, j}\)&lt;/span&gt; 表示 DP 到第 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 个组，已经选了 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; 对，那么有 &lt;span class=&#34;math inline&#34;&gt;\(dp_{i,j}=\sum\limits_{k=0}^jC_{n-(j - k)}^{j-k}\times dp_{i-1,j-k}\times A_{s_i}^{2k}\)&lt;/span&gt;。乍一看好像是 &lt;span class=&#34;math inline&#34;&gt;\(O(n^3)\)&lt;/span&gt; 的，但是别忘了 &lt;span class=&#34;math inline&#34;&gt;\(\sum s_i=2n\)&lt;/span&gt;，所以只有 &lt;span class=&#34;math inline&#34;&gt;\(O(n^2)\)&lt;/span&gt;。&lt;span class=&#34;math inline&#34;&gt;\(f(i)\)&lt;/span&gt; 即为 &lt;span class=&#34;math inline&#34;&gt;\(dp_{m,i}\times (2n-2i)!\)&lt;/span&gt;。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int mod = 1e9 + 7;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#endif
    int n, m;
    std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
    std::vector&amp;lt;int&amp;gt; s(m + 1);
    std::vector&amp;lt;long long&amp;gt; fac(2 * n + 1), inv(2 * n + 1);
    fac[0] = inv[0] = 1ll;
    for (int i = 1; i &amp;lt;= 2 * n; ++i)
        ++s[i % m + 1], fac[i] = fac[i - 1] * i % mod;
    auto qkp = [](long long x, int y) &amp;#123;
        auto res = 1ll;
        for (; y; (x *= x) %= mod, y &amp;gt;&amp;gt;= 1)
            if (y &amp;amp; 1)
                (res *= x) %= mod;
        return res;
    &amp;#125;;
    inv[2 * n] = qkp(fac[2 * n], mod - 2);
    for (int i = 2 * n - 1; i; --i)
        inv[i] = inv[i + 1] * (i + 1) % mod;
    auto A = [&amp;amp;](int n, int m) &amp;#123;
        return fac[n] * inv[n - m] % mod;
    &amp;#125;;
    auto C = [&amp;amp;](int n, int m) &amp;#123;
        return fac[n] * inv[n - m] % mod * inv[m] % mod;
    &amp;#125;;
    std::vector&amp;lt;std::vector&amp;lt;long long&amp;gt; &amp;gt; dp(m + 1, std::vector&amp;lt;long long&amp;gt; (n + 1));
    dp[0][0] = 1ll;
    for (int i = 1; i &amp;lt;= m; ++i)
        for (int j = 0; j &amp;lt;= n; ++j) &amp;#123;
            for (int k = 0; k &amp;lt;= j &amp;amp;&amp;amp; 2 * k &amp;lt;= s[i]; ++k)
                (dp[i][j] += C(n - (j - k), k) * dp[i - 1][j - k] % mod * A(s[i], 2 * k) % mod) %= mod;
            // printf(&amp;quot;s = %d, dp[%d][%d] = %lld\n&amp;quot;, s[i], i, j, dp[i][j]);
        &amp;#125;
    long long res = 0ll;
    for (int i = 0, p = 1; i &amp;lt;= n; ++i, p = mod - p)
        (res += p * dp[m][i] % mod * fac[2 * n - 2 * i] % mod) %= mod;
    std::cout &amp;lt;&amp;lt; res &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;e---kdoi-11彩灯晚会&#34;&gt;E - 「KDOI-11」彩灯晚会&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P11292&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P11292&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;考虑 &lt;span class=&#34;math inline&#34;&gt;\({cnt_i}^2\)&lt;/span&gt; 的含义，即在所有颜色为 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt;、长度为 &lt;span class=&#34;math inline&#34;&gt;\(l\)&lt;/span&gt; 的链中有放回地选两次的方案数。&lt;/p&gt;
&lt;p&gt;显然复杂度里是不能包含 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 的，所以放弃直接统计 &lt;span class=&#34;math inline&#34;&gt;\(cnt_i\)&lt;/span&gt; 的想法。显然每种颜色是等价的，考虑计算选择两条链可以给答案带来的贡献：答案的形式是个和式；对于两条同色链 &lt;span class=&#34;math inline&#34;&gt;\(p,q\)&lt;/span&gt;，假设颜色为 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt;，那么会对 &lt;span class=&#34;math inline&#34;&gt;\({cnt_i}^2\)&lt;/span&gt; 带来 &lt;span class=&#34;math inline&#34;&gt;\(k^{n-2l-|p\cap q|}\)&lt;/span&gt; 的贡献，对总答案带来 &lt;span class=&#34;math inline&#34;&gt;\(k^{n-2l-|p\cap q| + 1}\)&lt;/span&gt; 的贡献。&lt;/p&gt;
&lt;p&gt;然而如果要枚举计算 &lt;span class=&#34;math inline&#34;&gt;\(|p\cap q|\)&lt;/span&gt; 就无法避免 &lt;span class=&#34;math inline&#34;&gt;\(O(n^5)\)&lt;/span&gt;，考虑更有潜力的方法：将问题转化为对于每个 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt;，求交集大小恰好为 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 的链对个数。然而「恰好」是不方便计算的——假如当前两链在 &lt;span class=&#34;math inline&#34;&gt;\(u\)&lt;/span&gt; 次重合，如果假设下一次在 &lt;span class=&#34;math inline&#34;&gt;\(v\)&lt;/span&gt; 次重合，就需要保证在 &lt;span class=&#34;math inline&#34;&gt;\(u,v\)&lt;/span&gt; 之间不能重合——这并不好操作。二项式反演将恰好转化为至少，则限制减弱。&lt;/p&gt;
&lt;p&gt;令 &lt;span class=&#34;math inline&#34;&gt;\(f_{u,c,l_1,l_2}\)&lt;/span&gt; 表示 &lt;span class=&#34;math inline&#34;&gt;\(p,q\)&lt;/span&gt; 当前在 &lt;span class=&#34;math inline&#34;&gt;\(u\)&lt;/span&gt; 处重合，视野内的 &lt;span class=&#34;math inline&#34;&gt;\(p,q\)&lt;/span&gt; 长度为 &lt;span class=&#34;math inline&#34;&gt;\(l_1,l_2\)&lt;/span&gt;，至少已经重合了 &lt;span class=&#34;math inline&#34;&gt;\(c\)&lt;/span&gt; 次的方案数。预处理出走到 &lt;span class=&#34;math inline&#34;&gt;\(u\)&lt;/span&gt; 步数为 &lt;span class=&#34;math inline&#34;&gt;\(l_1,l_2\)&lt;/span&gt; 的方案数为初始值。枚举可能的后续重合点 &lt;span class=&#34;math inline&#34;&gt;\(v\)&lt;/span&gt;（满足 &lt;span class=&#34;math inline&#34;&gt;\(v\)&lt;/span&gt; 的拓扑序 &lt;span class=&#34;math inline&#34;&gt;\(&amp;gt;u\)&lt;/span&gt;）有 &lt;span class=&#34;math inline&#34;&gt;\(f_{v,c+1,l_1&amp;#39;,l_2&amp;#39;}\gets f_{v,c+1,l_1&amp;#39;,l_2&amp;#39;} + f_{u,c,l_1,l_2}\)&lt;/span&gt;。预处理出 &lt;span class=&#34;math inline&#34;&gt;\(u\to v\)&lt;/span&gt; 长度为 &lt;span class=&#34;math inline&#34;&gt;\(\Delta\)&lt;/span&gt; 的方案数（这是 &lt;span class=&#34;math inline&#34;&gt;\(O(n^3l)\)&lt;/span&gt; 的）优化转移，在算出 &lt;span class=&#34;math inline&#34;&gt;\(nex_{u,l}\)&lt;/span&gt; 表示从 &lt;span class=&#34;math inline&#34;&gt;\(u\)&lt;/span&gt; 出发走 &lt;span class=&#34;math inline&#34;&gt;\(l\)&lt;/span&gt; 步的方案数处理答案，则 &lt;span class=&#34;math inline&#34;&gt;\(F(i)=\sum_{u,l_1,l_2}f_{u,l_1,l_2}\cdot nex_{u,l-l_1}\cdot nex_{u,l-l_2}\)&lt;/span&gt;，枚举 &lt;span class=&#34;math inline&#34;&gt;\(u,c,l_1,l_2,v,l_1&amp;#39;,l_2&amp;#39;\)&lt;/span&gt;，就可以达到优秀的 &lt;span class=&#34;math inline&#34;&gt;\(O(n^2l^5+n^3l)\)&lt;/span&gt;！简直是令人震撼 &lt;img src=&#34;/em/kt.gif&#34; /&gt;&lt;/p&gt;
&lt;p&gt;给出第一个优化：发现 &lt;span class=&#34;math inline&#34;&gt;\(l_1\)&lt;/span&gt; 和 &lt;span class=&#34;math inline&#34;&gt;\(l_2\)&lt;/span&gt; 的转移彼此不干扰，考虑建立一个临时数组 &lt;span class=&#34;math inline&#34;&gt;\(g\)&lt;/span&gt;，先从 &lt;span class=&#34;math inline&#34;&gt;\(f_u,c\)&lt;/span&gt; 转移 &lt;span class=&#34;math inline&#34;&gt;\(l_1\)&lt;/span&gt; 到 &lt;span class=&#34;math inline&#34;&gt;\(g\)&lt;/span&gt;，再从 &lt;span class=&#34;math inline&#34;&gt;\(g\)&lt;/span&gt; 转移 &lt;span class=&#34;math inline&#34;&gt;\(l_2\)&lt;/span&gt; 到 &lt;span class=&#34;math inline&#34;&gt;\(f_{v,c+1}\)&lt;/span&gt;，则复杂度降为 &lt;span class=&#34;math inline&#34;&gt;\(O(n^2l^4+n^3l)\)&lt;/span&gt;，仍不足以通过。&lt;/p&gt;
&lt;p&gt;DP 过程上的优化已经万策尽，考虑从式子本身消元减少 DP 维度入手。令 &lt;span class=&#34;math inline&#34;&gt;\(h(i)\)&lt;/span&gt; 表示交集大小恰好恰好为 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 的方案数，则此时答案式为 &lt;span class=&#34;math inline&#34;&gt;\(\sum\limits_{i=0}^l k^{n-2l+i+1}\times h(i)\)&lt;/span&gt;。又 &lt;span class=&#34;math inline&#34;&gt;\(F(i)=\sum\limits_{j=i}^lC_j^i\cdot h(j)\)&lt;/span&gt;，二项式反演得：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
\begin{aligned}
res&amp;amp;=\sum\limits_{i=0}^lk^{n-2l+i+1}\cdot \sum_{j=i}^l(-1)^{j-i}\cdot C_j^i\cdot F(j)\\
&amp;amp;=k^{n-2l+1}\cdot\sum_{j=0}^l \sum_{i=0}^j k^i\cdot (-1)^{j-i}\cdot C_j^i\cdot F(j)\\
&amp;amp;=k^{n-2l+1}\cdot \sum_{j=0}^l (k-1)^j\cdot F(j)
\end{aligned}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;mark&gt;注意这里利用了二项式反演的系数可以和交换求和顺序后的 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 次项（或 &lt;span class=&#34;math inline&#34;&gt;\(j-i\)&lt;/span&gt; 次项，参见 &lt;a href=&#34;#c---sky-full-of-stars&#34;&gt;Sky Full of Stars 中最后一步的处理&lt;/a&gt;）组成二项式定理的特点&lt;/mark&gt;，以便基于式子结构尽可能消元。&lt;/p&gt;
&lt;p&gt;那么此时答案式已经和 &lt;span class=&#34;math inline&#34;&gt;\(c\)&lt;/span&gt; 无关，可以丢掉 &lt;span class=&#34;math inline&#34;&gt;\(c\)&lt;/span&gt; 这一维，和 &lt;span class=&#34;math inline&#34;&gt;\(c\)&lt;/span&gt; 有关的计算已经在转移时处理了。则 &lt;span class=&#34;math inline&#34;&gt;\(f_{v,l_1&amp;#39;,l_2&amp;#39;}=\sum f_{u,l_1,l_2}\times (k-1)\)&lt;/span&gt;，复杂度降为 &lt;span class=&#34;math inline&#34;&gt;\(O(n^2l^3+n^3l)\)&lt;/span&gt;。&lt;/p&gt;
&lt;details&gt;
&lt;p&gt;记得还要算上 &lt;span class=&#34;math inline&#34;&gt;\(F(0)\)&lt;/span&gt;，即任选一条合法链的方案数平方。&lt;/p&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;// 兄弟你好香
// 兄弟你是依托打分，我踏马吃吃吃吃吃
#include &amp;lt;bits/stdc++.h&amp;gt;
const int mod = 998244353;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;party3.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#endif
    using arr = std::vector&amp;lt;long long&amp;gt;;
    using arrr = std::vector&amp;lt;arr&amp;gt;;
    using arrrr = std::vector&amp;lt;arrr&amp;gt;;
    int n, k, l, m;
    std::cin &amp;gt;&amp;gt; n, std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; k &amp;gt;&amp;gt; l &amp;gt;&amp;gt; m;
    std::vector&amp;lt;int&amp;gt; deg(n + 1), id;
    std::vector&amp;lt;std::vector&amp;lt;std::pair&amp;lt;int, int&amp;gt; &amp;gt; &amp;gt; g(n + 1);
    for (int x, y, c; m--; ) &amp;#123;
        std::cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; y &amp;gt;&amp;gt; c;
        ++deg[y], g[x].emplace_back(y, c);
    &amp;#125;
    arrrr to(n + 1, arrr(n + 1, arr(l + 1)));
    arrr pre(n + 1, arr(l + 1)), nex(n + 1, arr(l + 1));
    &amp;#123;
        std::queue&amp;lt;int&amp;gt; q;
        for (int i = 1; i &amp;lt;= n; ++i)
            if (!deg[i])
                q.push(i);
        for (int u; !q.empty(); ) &amp;#123;
            u = q.front(), q.pop();
            to[u][u][0] = 1ll, id.push_back(u);
            for (auto i : id)
                for (int j = 0; j &amp;lt;= l; ++j) &amp;#123;
                    (pre[u][j] += to[i][u][j]) %= mod;
                    // printf(&amp;quot;to[%d][%d][%d] = %lld\n&amp;quot;, i, u, j, to[i][u][j]);
                &amp;#125;
            // for (int j = 0; j &amp;lt;= l; ++j)
            //     printf(&amp;quot;pre[%d][%d] = %lld\n&amp;quot;, u, j, pre[u][j]);
            for (auto [v, c] : g[u]) &amp;#123;
                for (auto i : id)
                    for (int j = 1; j &amp;lt;= l; ++j)
                        (to[i][v][j] += to[i][u][j - 1] * c) %= mod;
                if (!--deg[v])
                    q.push(v);
            &amp;#125;
        &amp;#125;
        for (int u = 1; u &amp;lt;= n; ++u)
            for (int v = 1; v &amp;lt;= n; ++v)
                for (int i = 0; i &amp;lt;= l; ++i)
                    (nex[u][i] += to[u][v][i]) %= mod;
    &amp;#125;
    arrrr f(n + 1, arrr(l + 1, arr(l + 1)));
    &amp;#123;
        for (int i = 1; i &amp;lt;= n; ++i)
            for (int l1 = 1; l1 &amp;lt;= l; ++l1)
                for (int l2 = 1; l2 &amp;lt;= l; ++l2)
                    f[i][l1][l2] = pre[i][l1 - 1] * pre[i][l2 - 1] % mod * (k - 1) % mod;
        for (auto i = 0; i &amp;lt; n; ++i) &amp;#123;
            int u = id[i];
            // for (int l1 = 1; l1 &amp;lt;= l; ++l1)
            //     for (int l2 = 1; l2 &amp;lt;= l; ++l2)
            //         printf(&amp;quot;f[%d][%d][%d] = %lld\n&amp;quot;, u, l1, l2, f[u][l1][l2]);
            for (auto j = i + 1; j &amp;lt; n; ++j) &amp;#123;
                arrr g(l + 1, arr(l + 1));
                int v = id[j];
                for (int l1 = 1; l1 &amp;lt; l; ++l1)
                    for (int _l1 = l1 + 1; _l1 &amp;lt;= l; ++_l1) &amp;#123;
                        auto K = to[u][v][_l1 - l1];
                        if (K)
                            for (int l2 = 1; l2 &amp;lt; l; ++l2)
                                (g[_l1][l2] += f[u][l1][l2] * K) %= mod;
                    &amp;#125;
                for (int _l1 = 2; _l1 &amp;lt;= l; ++_l1)
                    for (int l2 = 1; l2 &amp;lt; l; ++l2)
                        if (g[_l1][l2])
                            for (int _l2 = l2 + 1; _l2 &amp;lt;= l; ++_l2)
                                (f[v][_l1][_l2] += g[_l1][l2] * to[u][v][_l2 - l2] % mod * (k - 1)) %= mod; 
            &amp;#125;
        &amp;#125;
    &amp;#125;
    auto qkp = [](long long x, int y) &amp;#123;
        auto res(1ll);
        for (; y; (x *= x) %= mod, y &amp;gt;&amp;gt;= 1)
            if (y &amp;amp; 1)
                (res *= x) %= mod;
        return res;
    &amp;#125;;
    auto res(0ll);
    for (int u = 1; u &amp;lt;= n; ++u)
        for (int v = 1; v &amp;lt;= n; ++v)
            (res += to[u][v][l - 1]) %= mod;
    (res *= res) %= mod;
    for (int u = 1; u &amp;lt;= n; ++u)
        for (int l1 = 1; l1 &amp;lt;= l; ++l1)
            for (int l2 = 1; l2 &amp;lt;= l; ++l2)
                (res += f[u][l1][l2] * nex[u][l - l1] % mod * nex[u][l - l2] % mod) %= mod;
    res = res % mod * (qkp(k, n + 1) * qkp(qkp(k, 2 * l), mod - 2) % mod) % mod;
    std::cout &amp;lt;&amp;lt; res &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;g---小星星&#34;&gt;G - 小星星&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P3349&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P3349&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;首先考虑比较暴力的做法，那么有 &lt;span class=&#34;math inline&#34;&gt;\(f_{i,j,S}\)&lt;/span&gt; 表示在 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 这个子树里面选了集合 &lt;span class=&#34;math inline&#34;&gt;\(S\)&lt;/span&gt;，且 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 的颜色为 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; 的方案数，维数里之所以有 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; 是为了满足连边限制。&lt;/p&gt;
&lt;p&gt;然后树上子集 DP，发现是 &lt;span class=&#34;math inline&#34;&gt;\(O(n^4\cdot 2^n)\)&lt;/span&gt; 的，&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;cf785d-anton-and-school---2&#34;&gt;CF785D Anton and School - 2&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://codeforces.com/problemset/problem/785/D&#34; class=&#34;uri&#34;&gt;https://codeforces.com/problemset/problem/785/D&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;容易想到枚举每个 &lt;code&gt;(&lt;/code&gt; 作为分界点的情况，那么钦定当前枚举的 &lt;code&gt;(&lt;/code&gt; 是要选的。对于当前 &lt;code&gt;(&lt;/code&gt;，若其左边（不含）的 &lt;code&gt;(&lt;/code&gt; 有 &lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt; 个而右边的 &lt;code&gt;)&lt;/code&gt; 有 &lt;span class=&#34;math inline&#34;&gt;\(m\)&lt;/span&gt; 个，枚举除了当前 &lt;code&gt;(&lt;/code&gt; 还要选 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 个 &lt;code&gt;(&lt;/code&gt;，那么答案为 &lt;span class=&#34;math inline&#34;&gt;\(\sum_{i=0}C_n^{i-1}\cdot C_m^i\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;发现这个形式可以范德蒙德卷积：&lt;span class=&#34;math inline&#34;&gt;\(\sum_{i=0}C_n^{i-1}\cdot C_m^i=\sum_{i=0}C_n^{n-i+1}\cdot C_m^i=C_{n+m}^{n+1}\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;关于怎么记忆范德蒙德卷积，发现上下相加，也可以从组合意义记忆：在 &lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt; 个球中选出 &lt;span class=&#34;math inline&#34;&gt;\(k-i\)&lt;/span&gt; 个球，再从 &lt;span class=&#34;math inline&#34;&gt;\(m\)&lt;/span&gt; 个球中选出 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 个球的总方案就是从 &lt;span class=&#34;math inline&#34;&gt;\(n+m\)&lt;/span&gt; 个球中直接选出 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 个球的方案。&lt;/p&gt;
&lt;p&gt;注意判断右侧没有 &lt;code&gt;)&lt;/code&gt; 的时候贡献为 &lt;span class=&#34;math inline&#34;&gt;\(0\)&lt;/span&gt;。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int mod = 1e9 + 7;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#endif
    std::string s;
    std::cin &amp;gt;&amp;gt; s;
    int n = s.length();
    s = &amp;quot; &amp;quot; + s;
    std::vector&amp;lt;int&amp;gt; cnt1(n + 1), cnt2(n + 1);
    std::vector&amp;lt;long long&amp;gt; fac(n + 1), inv(n + 1);
    fac[0] = inv[0] = 1ll;
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        fac[i] = fac[i - 1] * i % mod;
        cnt1[i] = cnt1[i - 1] + (s[i] == &amp;#39;(&amp;#39;);
    &amp;#125;
    auto qkp = [](long long x, int y) &amp;#123;
        auto res(1ll);
        for (; y; (x *= x) %= mod, y &amp;gt;&amp;gt;= 1)
            if (y &amp;amp; 1)
                (res *= x) %= mod;
        return res;
    &amp;#125;;
    inv[n] = qkp(fac[n], mod - 2);
    cnt2[n] = (s[n] == &amp;#39;)&amp;#39;);
    for (int i = n - 1; i; --i) &amp;#123;
        cnt2[i] = cnt2[i + 1] + (s[i] == &amp;#39;)&amp;#39;);
        inv[i] = inv[i + 1] * (i + 1) % mod;
    &amp;#125;
    long long res = 0ll;
    auto C = [&amp;amp;](int n, int m) &amp;#123;
        if (n &amp;lt; m)
            return 0ll;
        return fac[n] * inv[n - m] % mod * inv[m] % mod;
    &amp;#125;;
    for (int i = 1; i &amp;lt;= n; ++i)
        if (s[i] == &amp;#39;(&amp;#39;)
            (res += C(cnt1[i] + cnt2[i] - 1, cnt1[i])) %= mod;
    std::cout &amp;lt;&amp;lt; res &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;cf1332e-height-all-the-same&#34;&gt;CF1332E Height All the Same&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://codeforces.com/problemset/problem/1332/E&#34; class=&#34;uri&#34;&gt;https://codeforces.com/problemset/problem/1332/E&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;容易发现第一个操作是用来改变两个数奇偶性的；而第二个操作能在全图奇偶性相同的任何情况下达成要求。&lt;/p&gt;
&lt;p&gt;注意到如果我们想同时仅改变任意两个数的奇偶性，可以在棋盘上任找一条路径一路使用操作一。只要某种奇偶性的元素个数共有偶数个，就能通过若干次操作一把它们全部变成另一种奇偶性。&lt;/p&gt;
&lt;p&gt;令 &lt;span class=&#34;math inline&#34;&gt;\(K_1\)&lt;/span&gt; 为 &lt;span class=&#34;math inline&#34;&gt;\(L\sim R\)&lt;/span&gt; 中奇数的个数，&lt;span class=&#34;math inline&#34;&gt;\(K_2\)&lt;/span&gt; 为偶数，那么有：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
res=\sum_{i=0}^{nm} C_{nm}^i\times {K_1}^i\cdot {K_2}^{nm-i}\cdot [i\bmod 2=0]
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;我们发现这个东西和二项式定理简直像得不能再像了！但多了一个系数导致没办法省略枚举过程。如果进行变形呢？&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
res=(K_1+K_2)^{nm}-\sum_{i=0}^{nm} C_{nm}^i\times {K_1}^i\cdot {K_2}^{nm-i}\cdot [i\bmod 2=1]
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;似乎依然没有出路！但这里有个神奇的操作：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
res=(-K_1+K_2)^{nm}+\sum_{i=0}^{nm} C_{nm}^i\times {K_1}^i\cdot {K_2}^i\cdot [i\bmod 2=1]
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;二式相加就可以&lt;mark&gt;消元&lt;/mark&gt;，得到 &lt;span class=&#34;math inline&#34;&gt;\(2\cdot res=(K_1+K_2)^{nm}+(K_1-K_2)^{nm}\)&lt;/span&gt;。&lt;mark&gt;这启示我们二项式定理中的符号和奇偶性的深切联系。&lt;/mark&gt;&lt;/p&gt;
&lt;details&gt;
&lt;p&gt;如果你使用费马小定理对次数进行了处理，你可能需要注意次数可能为 &lt;span class=&#34;math inline&#34;&gt;\(\text{mod} -1\)&lt;/span&gt; 的倍数。&lt;/p&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int mod = 998244353;
const int inv2 = 499122177;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#endif
    long long n, m, l, r, k1, k2;
    std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m &amp;gt;&amp;gt; l &amp;gt;&amp;gt; r, k1 = (r - l + 1) / 2, k2 = (r - l + 1) - k1;
    auto qkp = [](long long x, long long y) &amp;#123;
        auto res(1ll);
        for (; y; (x *= x) %= mod, y &amp;gt;&amp;gt;= 1)
            if (y &amp;amp; 1)
                (res *= x) %= mod;
        return res;
    &amp;#125;;
    if (n * m % 2)
        std::cout &amp;lt;&amp;lt; qkp(r - l + 1, n * m) &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    else
        std::cout &amp;lt;&amp;lt; (qkp(r - l + 1, n * m) + qkp((k1 + mod - k2) % mod, n * m)) % mod * inv2 % mod &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;a---交错序列&#34;&gt;A - 交错序列&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P4456&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P4456&lt;/a&gt;&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&#34;2.png&#34; alt=&#34;出题人疑似需要加强数学功底（？）&#34; /&gt;&lt;figcaption&gt;出题人疑似需要加强数学功底（？）&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;容易想到把答案用二项式定理拆开：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
\begin{aligned}
res&amp;amp;=\sum_y f_y\cdot y^b\cdot (n-y)^a\\
&amp;amp;=\sum_y f_y\cdot y^b\cdot \sum_{i=0}^a C_a^i\cdot n^i\cdot(-y)^{a-i}\\
&amp;amp;=\sum_y\sum_{i=0}^a f_y\cdot C_a^i\cdot n^i\cdot(-1)^{a-i}\cdot y^{a+b-i}\\
&amp;amp;=\sum_{i=0}^a C_a^i\cdot n^i\cdot(-1)^{a-i}\cdot \sum_y f_y\cdot y^{a+b-i}\\
\end{aligned}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;然后发现后面那个 sigma 不太有办法求。一个比较优雅的方法是把 &lt;span class=&#34;math inline&#34;&gt;\(y^{a+b-i}\)&lt;/span&gt; 直接作为系数而非下标塞到 &lt;span class=&#34;math inline&#34;&gt;\(f\)&lt;/span&gt; 里去，即令 &lt;span class=&#34;math inline&#34;&gt;\(f_{i}\)&lt;/span&gt; 表示 &lt;span class=&#34;math inline&#34;&gt;\(\forall \,y\)&lt;/span&gt;，&lt;span class=&#34;math inline&#34;&gt;\(\sum y^i\)&lt;/span&gt; 之和。&lt;/p&gt;
&lt;p&gt;具体地，令 &lt;span class=&#34;math inline&#34;&gt;\(dp_{n,i,0/1}\)&lt;/span&gt; 表示当前 DP 到第 &lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt; 位，要求幂次为 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt;，最后一位为 &lt;span class=&#34;math inline&#34;&gt;\(0/1\)&lt;/span&gt; 的答案。则显然有 &lt;span class=&#34;math inline&#34;&gt;\(dp_{n,i,0}=dp_{n-1,i,0}+dp_{n-1,i,1}\)&lt;/span&gt;。对于 &lt;span class=&#34;math inline&#34;&gt;\(dp_{n,i,1}\)&lt;/span&gt;，因为此时 &lt;span class=&#34;math inline&#34;&gt;\(\forall\, k,k\gets k+1\)&lt;/span&gt;，则 &lt;span class=&#34;math inline&#34;&gt;\((k+1)^i=\sum\limits_{j=0}^i C_i^j \cdot k^j\)&lt;/span&gt; 即 &lt;span class=&#34;math inline&#34;&gt;\(dp_{n,i,1}=\sum\limits_{j=0}^i C_i^j\cdot dp_{n-1,j,0}\)&lt;/span&gt;。发现 &lt;span class=&#34;math inline&#34;&gt;\(i,j\)&lt;/span&gt; 的范围是 &lt;span class=&#34;math inline&#34;&gt;\(90\)&lt;/span&gt;，很恐怖的事情是这是可以矩阵的。&lt;/p&gt;
&lt;details&gt;
&lt;p&gt;就像我们都知道的那样，矩阵在加完之后再取模就会快很多……&lt;/p&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
int mod;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#endif
    int n, a, b;
    std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b &amp;gt;&amp;gt; mod;
    std::vector&amp;lt;std::vector&amp;lt;long long&amp;gt; &amp;gt; C(a + b + 1, std::vector&amp;lt;long long&amp;gt;(a + b + 1));
    for (int i = 0; i &amp;lt;= a + b; ++i) &amp;#123;
        C[i][0] = 1ll;
        for (int j = 1; j &amp;lt;= i; ++j)
            C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % mod;
    &amp;#125;
    struct mat &amp;#123;
        int n, m;
        std::vector&amp;lt;std::vector&amp;lt;long long&amp;gt; &amp;gt; a;
        mat(int n, int m, bool flag = 0): n(n), m(m), a(n, std::vector&amp;lt;long long&amp;gt; (m)) &amp;#123;
            if (flag)
                for (int i = 0; i &amp;lt; n; ++i)
                    a[i][i] = 1ll;
            return;
        &amp;#125;
        mat operator* (const mat &amp;amp;q) const &amp;#123;
            mat res(n, q.m);
            for (int i = 0; i &amp;lt; n; ++i)
                for (int k = 0; k &amp;lt; q.m; ++k) &amp;#123;
                    for (int j = 0; j &amp;lt; m; ++j)
                        res.a[i][k] += a[i][j] * q.a[j][k];
                    res.a[i][k] %= mod;
                &amp;#125;
            return res;
        &amp;#125;
        mat operator^ (int q) const &amp;#123;
            mat res(n, n, 1), x(*this);
            for (; q; x = x * x, q &amp;gt;&amp;gt;= 1)
                if (q &amp;amp; 1)
                    res = res * x;
            return res;
        &amp;#125;
    &amp;#125; f(1, 2 * (a + b + 1)), op(2 * (a + b + 1), 2 * (a + b + 1));
    auto fun = [&amp;amp;](int i, int j) &amp;#123;
        return i + j * (a + b + 1);
    &amp;#125;;
    f.a[0][fun(0, 0)] = 1ll;
    for (int i = 0; i &amp;lt;= a + b; ++i)
        op.a[fun(i, 0)][fun(i, 0)] = op.a[fun(i, 1)][fun(i, 0)] = 1ll;
    for (int i = 0; i &amp;lt;= a + b; ++i)
        for (int j = 0; j &amp;lt;= i; ++j)
            op.a[fun(j, 0)][fun(i, 1)] = C[i][j];
    f = f * (op ^ n);
    // for (int i = 0; i &amp;lt;= n; ++i) &amp;#123;
    //     if (i)
    //         f = f * op;
    //     for (int j = 0; j &amp;lt;= a + b; ++j)
    //         printf(&amp;quot;f[%d][%d] = %lld / %lld\n&amp;quot;, i, j, f.a[0][fun(j, 0)], f.a[0][fun(j, 1)]);
    // &amp;#125;
    auto res = 0ll;
    for (int i = 0; i &amp;lt;= a; ++i) &amp;#123;
        static auto p(1ll), k((a % 2) ? mod - 1ll : 1ll);
        (res += C[a][i] * p % mod * k % mod * (f.a[0][fun(a + b - i, 0)] + f.a[0][fun(a + b - i, 1)]) % mod) %= mod;
        (p *= n) %= mod, k = mod - k;
    &amp;#125;
    std::cout &amp;lt;&amp;lt; res &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;b---different-subsets-for-all-tuples&#34;&gt;B - Different Subsets For All Tuples&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/CF660E&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/CF660E&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;首先你可能需要知道，如果已知一个序列，如何得到答案？&lt;/p&gt;
&lt;p&gt;令 &lt;span class=&#34;math inline&#34;&gt;\(f_i\)&lt;/span&gt; 表示在 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 处取一个子序列的末尾，枚举上一个元素 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt;，找到 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 之前最靠后的一个 &lt;span class=&#34;math inline&#34;&gt;\(a_j=x\)&lt;/span&gt;，那么有 &lt;span class=&#34;math inline&#34;&gt;\(f_i=\sum f_j\)&lt;/span&gt;，换言之需要保证 &lt;span class=&#34;math inline&#34;&gt;\((j,i)\)&lt;/span&gt; 范围内没有 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 出现。&lt;/p&gt;
&lt;p&gt;此时序列未知，令 &lt;span class=&#34;math inline&#34;&gt;\(f_{i, x}\)&lt;/span&gt; 表示在 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 处取一个子序列末尾，且 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 的值为 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt;；按照贡献的视角来看待，每个可以和 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 组成新子序列的方案可以带来 &lt;span class=&#34;math inline&#34;&gt;\(m^{i-1}\)&lt;/span&gt; 的贡献（因为 &lt;span class=&#34;math inline&#34;&gt;\(a_i\)&lt;/span&gt; 已经固定为 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt;，其他位置可以任选），那么有 &lt;span class=&#34;math inline&#34;&gt;\(f_{i,x}=m^i\times \sum_{j&amp;lt;i,y}f_{j,y}\times (m-1)^{i-j-1}\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;然后就惊讶地发现式子和 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 这一维没有关系了。所以直接带上系数得到：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
\begin{aligned}
f_i&amp;amp;=m^i\times \sum_{j&amp;lt;i} f_j\times (m-1)^{i-j-1}\times m\\
&amp;amp;=m^i\times (m-1)^{i-1}\times m\cdot \sum_{j&amp;lt;i} f_j\times (m-1)^{-j}
\end{aligned}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;前缀和优化一下就可以快速求了。最终的答案就是 &lt;span class=&#34;math inline&#34;&gt;\(res=m^n+\sum f_i\times (m-1)^{n-i}\)&lt;/span&gt;。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int mod = 1e9 + 7;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#endif
    int n, m;
    std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
    if (m == 1)
        std::cout &amp;lt;&amp;lt; (n + 1) &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    else &amp;#123;
        std::vector&amp;lt;long long&amp;gt; f(n + 1), s(n + 1), pm1(n + 1);
        pm1[0] = 1ll;
        for (int i = 1; i &amp;lt;= n; ++i)
            pm1[i] = pm1[i - 1] * (m - 1) % mod;
        auto qkp = [](long long x, int y) &amp;#123;
            auto res(1ll);
            for (; y; (x *= x) %= mod, y &amp;gt;&amp;gt;= 1)
                if (y &amp;amp; 1)
                    (res *= x) %= mod;
            return res;
        &amp;#125;;
        auto res(qkp(m, n));
        const auto invm = qkp(m - 1, mod - 2);
        for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
            static long long p(m), inv(invm);
            f[i] = (p + pm1[i - 1] * m % mod * s[i - 1] % mod) % mod;
            s[i] = (s[i - 1] + f[i] * inv % mod) % mod;
            (res += f[i] * pm1[n - i] % mod) %= mod;
            (p *= m) %= mod, (inv *= invm) %= mod;
        &amp;#125;
        std::cout &amp;lt;&amp;lt; res &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;; 
    &amp;#125;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;g---gardens&#34;&gt;G - Gardens&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/abc235/tasks/abc235_g&#34; class=&#34;uri&#34;&gt;https://atcoder.jp/contests/abc235/tasks/abc235_g&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果没有『每个人必须有一个元素』这个限制，就可以随便做了。现在加上了这个限制，很容易想到用没得到的人来容斥。钦定至少有 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 个人没拿到，得到答案为 &lt;span class=&#34;math inline&#34;&gt;\(\sum\limits_{i=0}^n (-1)^i\cdot C_n^i\cdot \left(\sum\limits_{j=0}^a C_i^j\right)\cdot \left(\sum\limits_{j=0}^b C_i^j\right)\cdot \left(\sum\limits_{j=0}^c C_i^j\right)\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;怎么算 &lt;span class=&#34;math inline&#34;&gt;\(\sum\limits_{j=0}^a C_i^j\)&lt;/span&gt; 呢？当 &lt;span class=&#34;math inline&#34;&gt;\(a&amp;gt; i\)&lt;/span&gt; 时，二项式是好求的；当 &lt;span class=&#34;math inline&#34;&gt;\(a\le i\)&lt;/span&gt; 时呢？看到这个式子很容易带到杨辉三角里去，也就是求一行的前 &lt;span class=&#34;math inline&#34;&gt;\(a\)&lt;/span&gt; 个数。注意到可以用上一行的前 &lt;span class=&#34;math inline&#34;&gt;\(a\)&lt;/span&gt; 个数 &lt;span class=&#34;math inline&#34;&gt;\(O(1)\)&lt;/span&gt; 得到（假设第 &lt;span class=&#34;math inline&#34;&gt;\(j-1\)&lt;/span&gt; 行前 &lt;span class=&#34;math inline&#34;&gt;\(a\)&lt;/span&gt; 个数之和为 &lt;span class=&#34;math inline&#34;&gt;\(f_a(j-1)\)&lt;/span&gt;）：&lt;span class=&#34;math inline&#34;&gt;\(f_a(j)=f_a(j-1)\times 2-C_{j-1,a}\)&lt;/span&gt;。&lt;mark&gt;你需要意识到，由于上一行也是答案中要求的，所以可以使用递推解决问题。&lt;strong&gt;在组合计数中，递推 / DP 无论是在化简式子还是求容斥 / 二项式反演里具体某一限制下的方案数都是很有用的，在需要优化复杂度时，可以从递推 / DP、恒等式、前缀和、预处理等方法入手考虑&lt;/strong&gt;&lt;/mark&gt;。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int mod = 998244353;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#endif
    int n, a, b, c;
    std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b &amp;gt;&amp;gt; c;
    std::vector&amp;lt;long long&amp;gt; fac(n + 1), inv(n + 1), fa(n + 1), fb(n + 1), fc(n + 1), pow2(n + 1);
    fac[0] = inv[0] = pow2[0] = 1ll;
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        fac[i] = fac[i - 1] * i % mod;
        pow2[i] = pow2[i - 1] * 2 % mod;
    &amp;#125;
    auto qkp = [&amp;amp;](long long x, int y) &amp;#123;
        auto res(1ll);
        for (; y; (x *= x) %= mod, y &amp;gt;&amp;gt;= 1)
            if (y &amp;amp; 1)
                (res *= x) %= mod;
        return res;
    &amp;#125;;
    inv[n] = qkp(fac[n], mod - 2);
    for (int i = n - 1; i; --i)
        inv[i] = inv[i + 1] * (i + 1) % mod;
    auto C = [&amp;amp;](int n, int m) &amp;#123;
        return fac[n] * inv[n - m] % mod * inv[m] % mod;
    &amp;#125;;
    for (int i = 0; i &amp;lt;= a; ++i)
        (fa[a] += C(a, i)) %= mod;
    for (int i = a + 1; i &amp;lt;= n; ++i)
        fa[i] = (2 * fa[i - 1] % mod + mod - C(i - 1, a)) % mod;
    for (int i = 0; i &amp;lt;= b; ++i)
        (fb[b] += C(b, i)) %= mod;
    for (int i = b + 1; i &amp;lt;= n; ++i)
        fb[i] = (2 * fb[i - 1] % mod + mod - C(i - 1, b)) % mod;
    for (int i = 0; i &amp;lt;= c; ++i)
        (fc[c] += C(c, i)) %= mod;
    for (int i = c + 1; i &amp;lt;= n; ++i)
        fc[i] = (2 * fc[i - 1] % mod + mod - C(i - 1, c)) % mod;
    auto res(0ll);
    for (int i = n, p = 1; ~i; --i, p = mod - p)
        (res += p * C(n, i) % mod * (i &amp;gt;= a ? fa[i] : pow2[i]) % mod * (i &amp;gt;= b ? fb[i] : pow2[i]) % mod * (i &amp;gt;= c ? fc[i] : pow2[i]) % mod) %= mod;
    std::cout &amp;lt;&amp;lt; res &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
</content>
        <category term="排列组合" />
        <category term="容斥原理" />
        <category term="数学" />
        <category term="二项式定理" />
        <category term="二项式反演" />
        <updated>2025-04-07T06:57:14.000Z</updated>
    </entry>
    <entry>
        <id>https://xsc062.netlify.app/20230813/</id>
        <title>pn、pm 和 plmm</title>
        <link rel="alternate" href="https://xsc062.netlify.app/20230813/"/>
        <content type="html">&lt;p&gt;Sotution to &lt;a href=&#34;https://codeforces.com/problemset/problem/258/C&#34;&gt;CF258C Little Elephant and LCM&lt;/a&gt;。&lt;/p&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;
&lt;hr /&gt;
&lt;p&gt;0#：那么这个 pn 可以等于什么？它只能等于 pm。（露出看到 plmm 一般的猥琐坏笑）&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;方便起见，下面 &lt;span class=&#34;math inline&#34;&gt;\(b_{\text{lcm}}\)&lt;/span&gt; 的意思就是 &lt;span class=&#34;math inline&#34;&gt;\(\text{lcm}\{b_1,b_2,\cdots,b_n\}\)&lt;/span&gt;，&lt;span class=&#34;math inline&#34;&gt;\(\max\)&lt;/span&gt; 什么的也同理。&lt;/p&gt;
&lt;p&gt;首先我们都能反应过来，如果 &lt;span class=&#34;math inline&#34;&gt;\(b_{\text{lcm}}=b_{\max}\)&lt;/span&gt;，那么 &lt;span class=&#34;math inline&#34;&gt;\(b\)&lt;/span&gt; 中的最大值就得是 &lt;span class=&#34;math inline&#34;&gt;\(b_{\text {lcm}}\)&lt;/span&gt;，而其他元素都得是 &lt;span class=&#34;math inline&#34;&gt;\(b_{\max}\)&lt;/span&gt; 的因数。&lt;/p&gt;
&lt;p&gt;既然涉及到求 &lt;span class=&#34;math inline&#34;&gt;\(b_{\max}\)&lt;/span&gt; 的因数，那我们势必避免不了枚举 &lt;span class=&#34;math inline&#34;&gt;\(b_{\max}\)&lt;/span&gt;。我一开始陷入了一个 trick：我并不知道 &lt;span class=&#34;math inline&#34;&gt;\(b_{\max}\)&lt;/span&gt; 应该处于哪一个位置。但其实这不重要，它对我们最后的方案没有影响，有影响的是「有多少个位置可以取到当前枚举的 &lt;span class=&#34;math inline&#34;&gt;\(b_{\max}\)&lt;/span&gt;」。&lt;/p&gt;
&lt;p&gt;对于当前枚举的 &lt;span class=&#34;math inline&#34;&gt;\(b_{\max}\)&lt;/span&gt;（假设为 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt;），我们找到它的所有因数 &lt;span class=&#34;math inline&#34;&gt;\(p_1\sim p_m\)&lt;/span&gt;，按从小到大的顺序排列。对于一个 &lt;span class=&#34;math inline&#34;&gt;\(a_i\)&lt;/span&gt;，当且仅当 &lt;span class=&#34;math inline&#34;&gt;\(a_i\ge p_j\)&lt;/span&gt; 时，&lt;span class=&#34;math inline&#34;&gt;\(a_i\)&lt;/span&gt; 可以选择 &lt;span class=&#34;math inline&#34;&gt;\(p_j\)&lt;/span&gt;。那么我们找到 &lt;span class=&#34;math inline&#34;&gt;\(a_i\)&lt;/span&gt; 可以选到的最大的 &lt;span class=&#34;math inline&#34;&gt;\(p_j\)&lt;/span&gt;，此时 &lt;span class=&#34;math inline&#34;&gt;\(a_i\)&lt;/span&gt; 的选择就是 &lt;span class=&#34;math inline&#34;&gt;\(p_1\sim p_j\)&lt;/span&gt;，共 &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; 种。&lt;/p&gt;
&lt;p&gt;那么我们在外面已经有一层枚举 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 的循环的前提下，再遍历 &lt;span class=&#34;math inline&#34;&gt;\(a\)&lt;/span&gt; 数组无疑是会起飞的，我们考虑倒过来，遍历 &lt;span class=&#34;math inline&#34;&gt;\(p\)&lt;/span&gt;，对于每个 &lt;span class=&#34;math inline&#34;&gt;\(p_j\)&lt;/span&gt;，找到它是多少个 &lt;span class=&#34;math inline&#34;&gt;\(a_i\)&lt;/span&gt; 的最大选择（假设为 &lt;span class=&#34;math inline&#34;&gt;\(x_j\)&lt;/span&gt;），那么对于 &lt;span class=&#34;math inline&#34;&gt;\(p_j\)&lt;/span&gt;，它贡献的答案就是 &lt;span class=&#34;math inline&#34;&gt;\(j^{x_j}\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(x_j\)&lt;/span&gt; 的计算也不难，我们用两个二分找到满足 &lt;span class=&#34;math inline&#34;&gt;\(p_j\le a_i &amp;lt; p_j + 1\)&lt;/span&gt; 的 &lt;span class=&#34;math inline&#34;&gt;\(a_i\)&lt;/span&gt; 数量就可以了。那么总方案数就是 &lt;span class=&#34;math inline&#34;&gt;\(\prod j^{x_j}\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;但是别忘了还有 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 为 &lt;span class=&#34;math inline&#34;&gt;\(b_{\max}\)&lt;/span&gt; 的限制。找到 &lt;span class=&#34;math inline&#34;&gt;\(x_m\)&lt;/span&gt;，怎么去满足至少有一个 &lt;span class=&#34;math inline&#34;&gt;\(a_i=k\)&lt;/span&gt; 呢？一个微型容斥，用总方案数减去一个 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 都没有的方案数。那么就规定了每个可以取到 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 的数都必须不取 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt;，本来有 &lt;span class=&#34;math inline&#34;&gt;\(m\)&lt;/span&gt; 种选择，现在只剩下 &lt;span class=&#34;math inline&#34;&gt;\(m−1\)&lt;/span&gt; 种，所以答案就是 &lt;span class=&#34;math inline&#34;&gt;\((m−1)^{x_m}\)&lt;/span&gt;，容斥后为 &lt;span class=&#34;math inline&#34;&gt;\(m^{x_m}−(m−1)^{x_m}\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;对于 &lt;span class=&#34;math inline&#34;&gt;\(b_{\max}=k\)&lt;/span&gt;，最终结果为 &lt;span class=&#34;math inline&#34;&gt;\((\prod\limits_{j=1}^{m−1}j^{x_j})\times (m^{x_m}−(m−1)^{x_m})\)&lt;/span&gt;。加法原理把所有 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 的情况加起来即可。&lt;/p&gt;
&lt;p&gt;对于时间复杂度，枚举 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 是 &lt;span class=&#34;math inline&#34;&gt;\(O(V)\)&lt;/span&gt; 的，找因数是 &lt;span class=&#34;math inline&#34;&gt;\(O(\sqrt V)\)&lt;/span&gt; 的，枚举 &lt;span class=&#34;math inline&#34;&gt;\(p_j\)&lt;/span&gt; 是 &lt;span class=&#34;math inline&#34;&gt;\(\log V\)&lt;/span&gt; 的，二分是 &lt;span class=&#34;math inline&#34;&gt;\(\log n\)&lt;/span&gt; 的。所以最终时间复杂度为 &lt;span class=&#34;math inline&#34;&gt;\(O(V\times \max\{\sqrt V,\log V\times \log n\})\)&lt;/span&gt;。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#define int long long
namespace XSC062 &amp;#123;
using namespace fastIO;
const int mod = 1e9 + 7;
const int maxn = 1e5 + 5;
int a[maxn];
int n, mx, ans, res;
int qkp(int x, int y) &amp;#123;
    int res = 1;
    while (y) &amp;#123;
        if (y &amp;amp; 1) (res *= x) %= mod;
        (x *= x) %= mod, y &amp;gt;&amp;gt;= 1;
    &amp;#125;
    return res;
&amp;#125;
int max(int x, int y) &amp;#123; return x &amp;gt; y ? x : y; &amp;#125;
int main() &amp;#123;
    read(n);
    for (int i = 1; i &amp;lt;= n; ++i) 
        read(a[i]), mx = max(mx, a[i]);
    std::sort(a + 1, a + n + 1);
    for (int k = 1; k &amp;lt;= mx; ++k) &amp;#123;
        res = 1;
        std::vector&amp;lt;int&amp;gt; p;
        p.push_back(-1); // 占位符，方便下标对齐 
        for (int i = 1; i * i &amp;lt;= k; ++i) &amp;#123;
            if (k % i == 0) &amp;#123;
                p.push_back(i);
                if (i * i != k) p.push_back(k / i);
            &amp;#125;
        &amp;#125;
        std::sort(p.begin() + 1, p.end());
        // 先算前 m - 1 个 
        int m = p.size() - 1;
        for (int j = 1; j &amp;lt;= m - 1; ++j) &amp;#123;
            int l, r, x;
            l = std::lower_bound(a + 1, a + n + 1, p[j]) - a;
            r = std::lower_bound(a + 1, a + n + 1, p[j + 1]) - a - 1;
            x = r - l + 1, (res *= qkp(j, x)) %= mod;
        &amp;#125;
        int l, r, x;
        l = std::lower_bound(a + 1, a + n + 1, p[m]) - a;
        r = n, x = r - l + 1;
        (res *= (qkp(m, x) - qkp(m - 1, x))) %= mod;
        (ans += res) %= mod;
    &amp;#125;
    print((ans + mod) % mod, &amp;#39;\n&amp;#39;);
    return 0;
&amp;#125;
&amp;#125; // namespace XSC062
#undef int&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
</content>
        <category term="二分" />
        <category term="容斥原理" />
        <updated>2023-08-13T08:46:13.000Z</updated>
    </entry>
</feed>
