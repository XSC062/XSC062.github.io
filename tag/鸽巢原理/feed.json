{
    "version": "https://jsonfeed.org/version/1",
    "title": "null • All posts by \"鸽巢原理\" tag",
    "description": "",
    "home_page_url": "https://xsc062.netlify.app",
    "items": [
        {
            "id": "https://xsc062.netlify.app/20240131/",
            "url": "https://xsc062.netlify.app/20240131/",
            "title": "USACO2024JAN 三组连打",
            "date_published": "2024-01-31T02:30:29.000Z",
            "content_html": "<p>假的，只连打了两组。Ag 没时间了。日后再补吧。</p>\n<span id=\"more\"></span>\n<p><img src=\"https://pic.imgdb.cn/item/65b7b152871b83018ac5e7b7.gif\" /></p>\n<p>无意中存了题面，但代码大部分因为系统还原消失了，只有文字题解，将就着看吧。</p>\n<hr />\n<h3 id=\"cu-a.-majority-opinion\">Cu A. Majority Opinion</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P10131\" class=\"uri\">https://www.luogu.com.cn/problem/P10131</a></p>\n<p><em>省流：任意区间内，若某元素出现个数严格大于区间长度一半，则可将整个区间推平为该值。问最终可以使整个序列被推平为哪些值。</em></p>\n<p>注意到当任意长度 <span class=\"math inline\">\\(\\ge 2\\)</span> 的区间可以被推平为某种元素时，整个数列都可以被推平为该元素。故目标转化为对于某种元素判定是否存在一个可被其推平的区间。</p>\n<p>统计元素个数采用前缀和。令 <span class=\"math inline\">\\(s_i\\)</span> 表示 <span class=\"math inline\">\\(h_i\\)</span> 在前 <span class=\"math inline\">\\(i\\)</span> 项中出现的次数，假设有 <span class=\"math inline\">\\([j,i]\\)</span> 满足条件，贪心可知 <span class=\"math inline\">\\(h_i=h_j\\)</span>。</p>\n<p>那么由定义有 <span class=\"math inline\">\\(i-j+1&lt;2\\times (s_i-s_j+1)\\)</span>。典中典，直接移项分离变量。则有 <span class=\"math inline\">\\(i-2\\times s_i-1&lt;j-2\\times s_j\\)</span>。令 <span class=\"math inline\">\\(t_p\\gets p-2\\times s_p\\)</span>，对于每个 <span class=\"math inline\">\\(h\\)</span> 记录 <span class=\"math inline\">\\(t_j\\)</span> 最大值查看是否有 <span class=\"math inline\">\\(i,j\\)</span> 满足条件即可。</p>\n<h3 id=\"cu-b.-cannonball\">Cu B. Cannonball</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P10132\" class=\"uri\">https://www.luogu.com.cn/problem/P10132</a></p>\n<p><em>省流：有 <span class=\"math inline\">\\(N\\)</span> 个格子，从 <span class=\"math inline\">\\(s\\)</span> 格子开始以 <span class=\"math inline\">\\(1\\)</span> 为初始能量向右跳，跳一步的距离为能量大小。格子分两种，一种经过加一定能量并反向，另一种若当前能量大于一定值则可永久摧毁，问跳出范围或无限长时间后可摧毁格子个数。</em></p>\n<p>不难发现若忽略增加能量为 <span class=\"math inline\">\\(0\\)</span> 的跳板则每经过一个跳板可跳距离增加 <span class=\"math inline\">\\(1\\)</span>，最多增加到 <span class=\"math inline\">\\(n\\)</span>，否则会跳出去。</p>\n<p>注意到调和级数，故直接模拟跳的过程。唯一导致时间无限的情况是存在相邻的增加能量为 <span class=\"math inline\">\\(0\\)</span> 的跳板，但其实它具体是什么并不重要，反正我们跳的次数严格大于调和级数后就可以认为进入死循环，直接结束模拟即可。我这里嫌麻烦直接拿了 <span class=\"math inline\">\\(2\\times 10^8\\)</span> 作阈值。</p>\n<h3 id=\"cu-c.-balancing-bacteria\">Cu C. Balancing Bacteria</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P10133\" class=\"uri\">https://www.luogu.com.cn/problem/P10133</a></p>\n<p><em>省流：定义一次操作为选取一个整数 <span class=\"math inline\">\\(\\Delta\\le N\\)</span>，并从 <span class=\"math inline\">\\(N\\)</span> 到 <span class=\"math inline\">\\(1\\)</span>，令 <span class=\"math inline\">\\(a_i\\gets a_i+\\Delta\\)</span> 并令 <span class=\"math inline\">\\(\\Delta\\)</span> 向 <span class=\"math inline\">\\(0\\)</span> 靠近 <span class=\"math inline\">\\(1\\)</span>，<span class=\"math inline\">\\(\\Delta=0\\)</span> 时停止。问令所有 <span class=\"math inline\">\\(a_i=0\\)</span> 所需最少操作次数。</em></p>\n<p>挺有意思的思维题，首先需要进行一个思维转化。<span class=\"math inline\">\\(\\Delta\\le N\\)</span> 是一个利于解题的限制，这意味着我们想让任何一个 <span class=\"math inline\">\\(a_i\\)</span> 改变 <span class=\"math inline\">\\(1\\)</span> 而不影响到之前的值，从让 <span class=\"math inline\">\\(a_1\\gets 0\\)</span> 入手，进行一次操作后每个 <span class=\"math inline\">\\(a_i\\)</span> 分到的 <span class=\"math inline\">\\(\\Delta\\)</span> 应依次加 1 或依次减 1。则差分数组为 <span class=\"math inline\">\\(0\\)</span> 后跟着一截 <span class=\"math inline\">\\(1\\)</span> 是理想状态。中间每有一项不满足规律都会带来额外的操作次数。</p>\n<p>归纳为差分数组的差分数组绝对值之和即为答案。</p>\n<hr />\n<h3 id=\"ag-a.-cowmpetency\">Ag A. Cowmpetency</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P10134\" class=\"uri\">https://www.luogu.com.cn/problem/P10134</a></p>\n<p><em>省流：有若干条限制，每条形如 <span class=\"math inline\">\\(\\max\\limits_{i=1}^{a_h-1}\\{A_i\\}=\\max\\limits_{i=1}^{a_j}\\{A_i\\}\\)</span> 且 <span class=\"math inline\">\\(A_{a_h}&gt;\\max\\limits_{i=1}^{a_h-1}\\{A_i\\}\\)</span>，部分数已知，构造出符合条件且字典序最小的序列。</em></p>\n<p>是本场最难题吧，但也没啥卡的。画个线段图容易发现，若将 <span class=\"math inline\">\\([a,h)\\)</span> 视作一条线段，那么除非 <span class=\"math inline\">\\(h\\)</span> 相同，否则两条线段不能有交集。不然的话就无解。以及如果存在不满足条件的定值也显然无解。</p>\n<p>从前往后看每个 <span class=\"math inline\">\\(h\\)</span> 并尝试赋值，对于每个 <span class=\"math inline\">\\(1\\sim a\\)</span> 记录一个需要满足的最大值数值，按照此数值从后往前填空格。</p>\n<p>填完过后扫一遍看看是不是全部合法，可以证明若此时不合法则无解。</p>\n<h3 id=\"ag-b.-potion-farming\">Ag B. Potion Farming</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P10135\" class=\"uri\">https://www.luogu.com.cn/problem/P10135</a></p>\n<p><em>省流：一棵树，每个点上有若干个物品，对于每条从根到叶子的简单路径，可以选择路径上的一个物品，每个物品只能被选一次，问最多可选物品数。</em></p>\n<p>如果一个点引导的子树下所有叶子有没有分配到的，就可以把这个点的物品分配给该叶子。</p>\n<p>跑一个树形 DP 即可。</p>\n<details>\n<pre class=\"cpp\"><code>namespace XSC062 &#123;\nusing namespace fastIO;\nconst int maxn = 1e5 + 5;\nint n, x, y;\nint cnt[maxn];\nstd::vector&lt;int&gt; g[maxn];\nint a[maxn], f[maxn], p[maxn];\nint min(int x, int y) &#123;\n    return x &lt; y ? x : y;\n&#125;\nvoid DFS(int x, int fa) &#123;\n    if ((int)g[x].size() == 1)\n        cnt[x] = 1;\n    for (auto i : g[x]) &#123;\n        if (i == fa) continue;\n        DFS(i, x);\n        f[x] += f[i];\n        cnt[x] += cnt[i];\n    &#125;\n    if (f[x] &lt; cnt[x])\n        f[x] = min(f[x] + a[x], cnt[x]);\n    return;\n&#125;\nvoid add(int x, int y) &#123;\n    g[x].push_back(y);\n    return;\n&#125;\nint main() &#123;\n    read(n);\n    for (int i = 1; i &lt;= n; ++i) read(p[i]);\n    for (int i = 1; i &lt; n; ++i) &#123;\n        read(x), read(y);\n        add(x, y), add(y, x);\n    &#125;\n    int tot = 0;\n    for (int i = 2; i &lt;= n; ++i)\n        tot += ((int)g[i].size() == 1);\n    for (int i = 1; i &lt;= tot; ++i) ++a[p[i]];\n    DFS(1, -1);\n    print(f[1], &#39;\\n&#39;);\n    return 0;\n&#125;\n&#125; // namespace XSC062</code></pre>\n</details>\n<h3 id=\"ag-c.-cowlendar\">Ag C. Cowlendar</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P10136\" class=\"uri\">https://www.luogu.com.cn/problem/P10136</a></p>\n<p><em>省流：对于给定的序列 <span class=\"math inline\">\\(a\\)</span>，找出所有满足 <span class=\"math inline\">\\(a_i\\bmod L\\)</span> 的值的种类最多为 3 的 <span class=\"math inline\">\\(L\\)</span>。</em></p>\n<p>也是挺有意思的数学题了。若将 <span class=\"math inline\">\\(a_i\\)</span> 按照模 <span class=\"math inline\">\\(L\\)</span> 的情况分组，则对于任意一个 <span class=\"math inline\">\\(a_i\\)</span>，在 <span class=\"math inline\">\\((a_i,a_i+L)\\)</span> 中最多包含两个分别来自其余两组的数。</p>\n<p>对于去重后 <span class=\"math inline\">\\(n&gt;3\\)</span> 的情况，由鸽巢得必定有两个数可分为一组。故我们枚举可能的组间间隔，而可能的 <span class=\"math inline\">\\(L\\)</span> 就是这些间隔的因数。</p>\n<p>由上面我们推出一个合法组间间隔中最多间隔三个数，我们将所有 <span class=\"math inline\">\\(a_{i+3}-a_i\\)</span>、<span class=\"math inline\">\\(a_{i+2}-a_i\\)</span> 和 <span class=\"math inline\">\\(a_{i+1}-a_i\\)</span> 纳入考虑范围即可。对于所有可能的 <span class=\"math inline\">\\(L\\)</span>，直接 <span class=\"math inline\">\\(O(n)\\)</span> 跑一个 <code>check</code> 检查是否合法。</p>\n<p>因子个数照理来说是 <span class=\"math inline\">\\(\\sqrt{V}\\times n\\)</span> 级别的，但是实测 <span class=\"math inline\">\\(n\\)</span> 最多只有一百多。估计是因为 <span class=\"math inline\">\\(n\\)</span> 太大就很难构造出更多的合法解吧。</p>\n<details>\n<pre class=\"cpp\"><code>#define int long long\nnamespace XSC062 &#123;\nusing namespace fastIO;\nconst int maxn = 1e4 + 5;\nconst int maxm = 3e4 + 5;\nstd::set&lt;int&gt; u;\nint n, res, mn, tot;\nint a[maxn], b[maxm];\nbool check(int x) &#123;\n    int l1 = 0, l2 = 0, l3 = 0;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        if (l1 == 0) l1 = a[i];\n        else if (x &amp;&amp; (a[i] - l1) % x == 0) l1 = a[i];\n        else if (l2 == 0) l2 = a[i];\n        else if (x &amp;&amp; (a[i] - l2) % x == 0) l2 = a[i];\n        else if (l3 == 0) l3 = a[i];\n        else if (x &amp;&amp; (a[i] - l3) % x == 0) l3 = a[i];\n        else return 0;\n    &#125;\n    return 1;\n&#125;\nint main() &#123;\n    read(n);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        read(a[i]);\n        if (!mn || a[i] / 4 &lt; mn) mn = a[i] / 4;\n    &#125;\n    std::sort(a + 1, a + n + 1);\n    n = std::unique(a + 1, a + n + 1) - a - 1;\n    if (check(0)) &#123;\n        print(mn * (mn + 1) / 2, &#39;\\n&#39;);\n        return 0;\n    &#125;\n    for (int i = 2; i &lt;= n; ++i) &#123;\n        b[++tot] = a[i] - a[i - 1];\n        if (i &gt;= 3) b[++tot] = a[i] - a[i - 2];\n        if (i &gt;= 4) b[++tot] = a[i] - a[i - 3];\n    &#125;\n    std::sort(b + 1, b + tot + 1);\n    tot = std::unique(b + 1, b + tot + 1) - b - 1;\n    for (int i = 1; i &lt;= tot; ++i) &#123;\n        if (check(b[i])) &#123;\n            for (int j = 1; j * j &lt;= b[i]; ++j) &#123;\n                if (b[i] % j == 0)\n                    u.insert(j), u.insert(b[i] / j);\n            &#125;\n        &#125;\n    &#125;\n    for (auto i : u) &#123;\n        if (i &gt; mn) break;\n        res += i;\n    &#125;\n    print(res, &#39;\\n&#39;);\n    return 0;\n&#125;\n&#125; // namespace XSC062\n#undef int</code></pre>\n<p></deteails></p>\n",
            "tags": [
                "鸽巢原理",
                "调和级数",
                "差分",
                "思维",
                "树形 DP"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20240106/",
            "url": "https://xsc062.netlify.app/20240106/",
            "title": "杂题全谈",
            "date_published": "2024-01-06T03:27:39.000Z",
            "content_html": "<p>想不到好标题了。</p>\n<span id=\"more\"></span>\n<p>有句话怎么说来着，罗马不是一天建成的，是一天天建成的。</p>\n<p>还有什么，Do in Rome as the Romans’ do，还有一句，All roads leads to Rome。</p>\n<hr />\n<h3 id=\"a.-连续的零-zero\">A. 连续的零 zero</h3>\n<p><a href=\"http://222.180.160.110:61235/contest/4647/problem/1\" class=\"uri\">http://222.180.160.110:61235/contest/4647/problem/1</a></p>\n<p>做个前缀和，看看任意一个长度为 <span class=\"math inline\">\\(k\\)</span> 的区间中有几个 <span class=\"math inline\">\\(1\\)</span>。复杂度 <span class=\"math inline\">\\(O(n)\\)</span>。</p>\n<details>\n<pre class=\"cpp\"><code>namespace XSC062 &#123;\nusing namespace fastIO;\nconst int maxn = 5e5 + 5;\nconst int inf = 0x3f3f3f3f;\nint n, m, res = inf;\nint a[maxn], s[maxn];\nint min(int x, int y) &#123;\n    return x &lt; y ? x : y;\n&#125;\nint main() &#123;\n    scanf(&quot;%d %d&quot;, &amp;n, &amp;m);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        scanf(&quot;%1d&quot;, &amp;a[i]);\n        s[i] = s[i - 1] + a[i];\n        if (i &gt;= m)\n            res = min(res, s[i] - s[i - m]);\n    &#125;\n    print(res, &#39;\\n&#39;);\n    return 0;\n&#125;\n&#125; // namespace XSC062</code></pre>\n</details>\n<hr />\n<h3 id=\"b.-反回文串-anti\">B. 反回文串 anti</h3>\n<p><a href=\"http://222.180.160.110:61235/contest/4647/problem/2\" class=\"uri\">http://222.180.160.110:61235/contest/4647/problem/2</a></p>\n<p>当 <span class=\"math inline\">\\(n\\)</span> 为奇时，中间的元素一定和自己相等，故无解。</p>\n<p>当数量最多的一个字符个数超过 <span class=\"math inline\">\\(\\dfrac n2\\)</span> 时，由鸽巢得无解。</p>\n<p>剩下的情况一定有解。</p>\n<details>\n<p><summary>证明</summary></p>\n<p>可以找到一种合法的构造方式。我们列出一个列数为 <span class=\"math inline\">\\(2\\)</span>，行数为 <span class=\"math inline\">\\(\\dfrac n2\\)</span> 的表格，将所有相同字母排列在一起，按照从左到右，从上到下的方式将字母填入表格，最后将第 <span class=\"math inline\">\\(i\\)</span> 行第一列的字母填入 <span class=\"math inline\">\\(a_i\\)</span>，第 <span class=\"math inline\">\\(i\\)</span> 行第二列的字母填入 <span class=\"math inline\">\\(a_{n-i+1}\\)</span>，即可完成构造。</p>\n<p>一种字母只在第一列或第二列出现当然合法，如果从第一列持续到第二列，因为任意字母出现次数不超过 <span class=\"math inline\">\\(\\dfrac n2\\)</span> 次，所以同一行的两列不会出现同一种字母。</p>\n<p>这叫什么，有字证明。</p>\n<p><del>感觉可以拿去出一道类似于「找到字符串字典序最小的反回文串」之类的小水题</del></p>\n</details>\n<p>然后现在我们知道有解了，怎么找到最优解呢。</p>\n<p>比如有一组 <span class=\"math inline\">\\((a_i,a_{n-i+1})=(\\texttt a, \\texttt a)\\)</span>，还有一组 <span class=\"math inline\">\\((a_j, a_{n-j+1})=(\\texttt b, \\texttt b)\\)</span>，那我们直接把 <span class=\"math inline\">\\(a_i\\)</span> 和 <span class=\"math inline\">\\(a_j\\)</span> 交换，皆大欢喜。</p>\n<p>这就说明我们需要把值不相等的非法 <span class=\"math inline\">\\(a_i\\)</span> 与 <span class=\"math inline\">\\(a_j\\)</span> 配对。</p>\n<p>然后我们就可以沿用证明中的构造方式，分组配对，一定最优，每组代价为 <span class=\"math inline\">\\(1\\)</span>。</p>\n<p>同一行两个值 <span class=\"math inline\">\\(v\\)</span> 相等，因为已经最优了，所以不能再在非法串中寻找答案。应该找合法对中某个值交换，每组代价为 <span class=\"math inline\">\\(2\\)</span>。具体和谁交换我们不用担心，只要找到一组 <span class=\"math inline\">\\((a_i,a_{n-i+1})\\)</span> 满足 <span class=\"math inline\">\\(a_i\\ne v\\)</span> 且 <span class=\"math inline\">\\(a_{n-i+1}\\ne v\\)</span> 就可以了，然后我们又知道 <span class=\"math inline\">\\(v\\)</span> 的个数 <span class=\"math inline\">\\(\\ne \\dfrac n2\\)</span>，假设 <span class=\"math inline\">\\(\\dfrac n2\\)</span> 对中每队都有至少一个 <span class=\"math inline\">\\(v\\)</span>，由于当前这一对有两个相同的 <span class=\"math inline\">\\(v\\)</span>，那么 <span class=\"math inline\">\\(v\\)</span> 的个数就会大于 <span class=\"math inline\">\\(\\dfrac n2\\)</span>，矛盾了，所以一定能找到。</p>\n<p>对于非法总对数是奇数的情况，我们要钦定一个非法对强制让其和合法对交换，贪心一下取非法对数量最多的 <span class=\"math inline\">\\(v\\)</span> 的某一对最优。</p>\n<details>\n<pre class=\"cpp\"><code>namespace XSC062 &#123;\nusing namespace fastIO;\nconst int maxm = 35;\nconst int maxn = 2e5 + 5;\nchar s[maxn];\nint cnt[maxm], p[maxn];\nint T, n, tot, res, now;\nint main() &#123;\n    scanf(&quot;%d&quot;, &amp;T);\n    while (T--) &#123;\n        tot = 0;\n        scanf(&quot;%d %s&quot;, &amp;n, s + 1);\n        if (n &amp; 1) &#123;\n            puts(&quot;-1&quot;);\n            continue;\n        &#125;\n        memset(cnt, 0, sizeof (cnt));\n        for (int i = 1; i &lt;= n; ++i)\n            ++cnt[s[i] - &#39;a&#39; + 1];\n        for (int i = 1; i &lt;= 26; ++i) &#123;\n            if (cnt[i] * 2 &gt; n) &#123;\n                puts(&quot;-1&quot;);\n                goto noSol;\n            &#125;\n        &#125;\n        memset(cnt, 0, sizeof (cnt));\n        for (int i = 1; i * 2 &lt;= n; ++i) &#123;\n            if (s[i] == s[n - i + 1])\n                ++cnt[s[i] - &#39;a&#39; + 1], ++tot;\n        &#125;\n        std::sort(cnt + 1, cnt + 27,\n                    std::greater&lt;int&gt;());\n        res = now = 0;\n        if (tot &amp; 1) &#123;\n            res = 1, --cnt[1];\n            std::sort(cnt + 1, cnt + 27,\n                        std::greater&lt;int&gt;());\n        &#125;\n        for (int i = 1; i &lt;= 26; ++i) &#123;\n            while (cnt[i]--) &#123;\n                if (++now &gt; tot / 2) &#123;\n                    if (i == p[now - tot / 2])\n                        res += 2;\n                    else ++res;\n                &#125;\n                else p[now] = i;\n            &#125;\n        &#125;\n        print(res, &#39;\\n&#39;);\n        noSol: ;\n    &#125;\n    return 0;\n&#125;\n&#125; // namespace XSC062</code></pre>\n</details>\n<hr />\n<h3 id=\"c.-除与减-divsub\">C. 除与减 divsub</h3>\n<p><a href=\"http://222.180.160.110:61235/contest/4647/problem/3\" class=\"uri\">http://222.180.160.110:61235/contest/4647/problem/3</a></p>\n<p>小数学，还好。</p>\n<p>假设 <span class=\"math inline\">\\(n=d\\times k^p\\)</span>，其中 <span class=\"math inline\">\\(k\\nmid d\\)</span>，那么我们分两种情况讨论。</p>\n<ol type=\"1\">\n<li><p><span class=\"math inline\">\\(p=0\\)</span>，即 <span class=\"math inline\">\\(k\\nmid n\\)</span>，那么 <span class=\"math inline\">\\(n\\bmod k=1\\)</span>，即 <span class=\"math inline\">\\(k\\mid (n-1)\\)</span>。</p>\n这个时候问 <span class=\"math inline\">\\(k\\)</span> 的个数就相当于是在问 <span class=\"math inline\">\\(n-1\\)</span> 除 <span class=\"math inline\">\\(1\\)</span> 以外的因子个数。假设 <span class=\"math inline\">\\(n-1={x_1}^{p_1}{x_2}^{p_2}\\cdots {x_m}^{p_m}\\)</span>，那么答案为 <span class=\"math inline\">\\((\\prod p_i+1)-1\\)</span>，减去的是 <span class=\"math inline\">\\(1\\)</span>。</li>\n<li><p><span class=\"math inline\">\\(p\\ne 0\\)</span>，<span class=\"math inline\">\\(k\\mid n\\)</span>。</p>\n<p>这个时候好像并没有什么好的转化。好消息是 <span class=\"math inline\">\\(n\\)</span> 的范围是 <span class=\"math inline\">\\(10^{12}\\)</span>，根号枚举因数复杂度跑得过。所以我们就可以暴力判定 <span class=\"math inline\">\\(n\\)</span> 的所有因数是否满足条件。</p></li>\n</ol>\n<p>时间复杂度，<span class=\"math inline\">\\(O(\\sqrt n\\times \\log n)\\)</span>，枚举因数是根号，算次数（也就是算 <span class=\"math inline\">\\(d\\)</span>）是 <span class=\"math inline\">\\(\\log\\)</span>。</p>\n<details>\n<pre class=\"cpp\"><code>#define int long long\nnamespace XSC062 &#123;\nusing namespace fastIO;\nint n, m, res, cnt;\nint main() &#123;\n    read(n), m = n;\n    for (int i = 2; i * i &lt;= n; ++i) &#123;\n        if (n % i == 0) &#123;\n            m = n;\n            while (m % i == 0) m /= i;\n            if (m % i == 1) ++res;\n            if (i * i != n) &#123;\n                m = n;\n                while (m % (n / i) == 0)\n                    m /= (n / i);\n                if (m % (n / i) == 1) ++res;\n            &#125;\n        &#125;\n    &#125;\n    m = n - 1, cnt = 1;\n    for (int i = 2; i * i &lt;= m; ++i) &#123;\n        if (m % i == 0) &#123;\n            int now = 0;\n            while (m % i == 0)\n                ++now, m /= i;\n            cnt *= now + 1;\n        &#125;\n    &#125;\n    if (m != 1) cnt *= 2;\n    print(res + cnt, &#39;\\n&#39;);\n    return 0;\n&#125;\n&#125; // namespace XSC062\n#undef int</code></pre>\n</details>\n<hr />\n<h3 id=\"d.-图书管理员-librarian\">D. 图书管理员 librarian</h3>\n<p><a href=\"http://222.180.160.110:61235/contest/4647/problem/4\" class=\"uri\">http://222.180.160.110:61235/contest/4647/problem/4</a></p>\n<p>[SDOI2008] 郁闷的小 J。</p>\n<p>关于这个，我们发现自己不会考场现冲主席树。哎，打 CDQ 又怕写挂。</p>\n<p>我们发现这道题的修改都是单点的，询问也只关于某一种颜色，不同的颜色之间没有影响。</p>\n<p>于是我们可以把操作离线下来，初始视作将某颜色在某位置增加，修改视作将某颜色在某位置删除，将另一颜色在该位置增加，将所有操作按颜色离散化分类然后 <code>vector</code> 下来，对于所有颜色从前到后树状数组做一遍操作就能 <span class=\"math inline\">\\(O(n\\log n+q\\log n)\\)</span> 解决。</p>\n<p>树状数组清空是肯定不能 <code>memset</code> 的，复杂度不对。那么怎么办呢？把所有操作撤回去就可以了。</p>\n<p>顺带一提我是洛谷上最优解。</p>\n<details>\n<pre class=\"cpp\"><code>namespace XSC062 &#123;\nusing namespace fastIO;\nconst int maxn = 2e5 + 5;\nstruct __ &#123;\n    int ty, l, r, v;\n    __() &#123;&#125;\n    __(int t1, int l1, int r1, int v1 = 0) &#123;\n        if (t1 == 0)\n            ty = 0, l = l1, v = r1;\n        else ty = 1, l = l1, r = r1, v = v1;\n    &#125;\n&#125;;\nchar ty;\nstd::map&lt;int, int&gt; tab;\nstd::vector&lt;__&gt; q[maxn];\nint n, m, tot, x, y, v, id;\nint Bit[maxn], a[maxn], res[maxn];\nint lowbit(int x) &#123; return x &amp; -x; &#125;\nvoid add(int x, int v) &#123;\n    for (; x &lt;= n; x += lowbit(x))\n        Bit[x] += v;\n    return;\n&#125;\nint ask(int x) &#123;\n    int res = 0;\n    for (; x; x -= lowbit(x)) res += Bit[x];\n    return res;\n&#125;\nint main() &#123;\n    read(n), read(m);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        read(a[i]);\n        if (!tab.count(a[i]))\n            tab[a[i]] = ++tot;\n        a[i] = tab[a[i]];\n        q[a[i]].emplace_back(0, i, 1);\n    &#125;\n    while (m--) &#123;\n        scanf(&quot;%1s&quot;, &amp;ty);\n        if (ty == &#39;C&#39;) &#123;\n            read(x), read(y);\n            if (!tab.count(y))\n                tab[y] = ++tot;\n            y = tab[y];\n            q[a[x]].emplace_back(0, x, -1);\n            q[a[x] = y].emplace_back(0, x, 1);\n        &#125;\n        else &#123;\n            ++id;\n            read(x), read(y), read(v);\n            if (!tab.count(v)) continue;\n            v = tab[v];\n            q[v].emplace_back(1, x, y, id);\n        &#125;\n    &#125;\n    for (int i = 1; i &lt;= tot; ++i) &#123;\n        for (auto &amp;j : q[i]) &#123;\n            if (j.ty == 0) add(j.l, j.v);\n            else &#123;\n                res[j.v] =\n                    ask(j.r) - ask(j.l - 1);\n            &#125;\n        &#125;\n        for (auto &amp;j : q[i])\n            if (j.ty == 0) add(j.l, -j.v);\n    &#125;\n    for (int i = 1; i &lt;= id; ++i)\n        print(res[i], &#39;\\n&#39;);\n    return 0;\n&#125;\n&#125; // namespace XSC062</code></pre>\n</details>\n<hr />\n<p>E 会单独开一篇。</p>\n<hr />\n<h3 id=\"f.-树-tree\">F. 树 tree</h3>\n<p><a href=\"http://222.180.160.110:61235/contest/4647/problem/6\" class=\"uri\">http://222.180.160.110:61235/contest/4647/problem/6</a></p>\n<p>CF916E。</p>\n<p>大分讨给我整不会了，更给我整不会的是下来过后发现这只是个小分讨。</p>\n<p>更新子树和子树查询我们都会。换根 DP 我们也都写过，都知道换根并不会对子树结构产生大的影响。所以应当是能根据已知信息推测出子树在原树上对应的点集的。</p>\n<p>记 <span class=\"math inline\">\\(r\\)</span> 为当前树根，<span class=\"math inline\">\\(\\text {LCA}(x,y)\\)</span> 为 <span class=\"math inline\">\\(x,y\\)</span> 在 <span class=\"math inline\">\\(1\\)</span> 为根时的 LCA，<span class=\"math inline\">\\(\\text {LCA}&#39;(x,y)\\)</span> 表示 <span class=\"math inline\">\\(x,y\\)</span> 在 <span class=\"math inline\">\\(r\\)</span> 为根时的 LCA。</p>\n<p>那么对于 <span class=\"math inline\">\\(\\text {LCA}&#39;(x,y)\\)</span>，肯定是要讨论 <span class=\"math inline\">\\(x,y\\)</span> 和 <span class=\"math inline\">\\(r\\)</span> 的位置关系的。</p>\n<ol type=\"1\">\n<li><span class=\"math inline\">\\(\\text {LCA}(x,y)\\)</span> 是 <span class=\"math inline\">\\(r\\)</span> 的子孙。此时 <span class=\"math inline\">\\(\\text {LCA}&#39;(x,y) = \\text {LCA}(x,y)\\)</span>。</li>\n<li><span class=\"math inline\">\\(\\text {LCA}(x,y)\\)</span> 是 <span class=\"math inline\">\\(r\\)</span> 的祖先。那么说明至少有一个点不是 <span class=\"math inline\">\\(r\\)</span> 的子孙。此时 <span class=\"math inline\">\\(\\text {LCA}(x,y)&#39;\\)</span> 的值为 <span class=\"math inline\">\\(r\\)</span> 为另一个点的 LCA。</li>\n</ol>\n<p>整理可得 <span class=\"math inline\">\\(\\text {LCA}&#39;(x,y)\\)</span> 是 <span class=\"math inline\">\\(\\text {LCA}(x,y)\\)</span>、<span class=\"math inline\">\\(\\text {LCA}(x,r)\\)</span> 和 <span class=\"math inline\">\\(\\text {LCA}(y,r)\\)</span> 中的深度最大者。</p>\n<p>对于以 <span class=\"math inline\">\\(r\\)</span> 为根时的子树 <span class=\"math inline\">\\(x\\)</span>：</p>\n<ol type=\"1\">\n<li><span class=\"math inline\">\\(x=r\\)</span>，此时子树为整棵树。</li>\n<li><span class=\"math inline\">\\(\\text {LCA}(x,r)\\ne x\\)</span>，即 <span class=\"math inline\">\\(r\\)</span> 不为 <span class=\"math inline\">\\(x\\)</span> 的子孙，此时子树就是以 <span class=\"math inline\">\\(1\\)</span> 为根是的子树 <span class=\"math inline\">\\(x\\)</span>。</li>\n<li><span class=\"math inline\">\\(\\text {LCA}(x,y)=x\\)</span>，即 <span class=\"math inline\">\\(r\\)</span> 为 <span class=\"math inline\">\\(x\\)</span> 的子孙，此时子树是整棵树除开 <span class=\"math inline\">\\(x\\)</span> 包含 <span class=\"math inline\">\\(r\\)</span> 的儿子及其子孙。修改和查询的时候容斥一下就好。这个时候的子树倍增跳一下就能找到。</li>\n</ol>\n<p>然后就是常规线段树维护了。时间复杂度 <span class=\"math inline\">\\(O(n\\log n)\\)</span>。</p>\n<details>\n<pre class=\"cpp\"><code>namespace XSC062 &#123;\nusing namespace fastIO;\nconst int maxm = 35;\nconst int maxn = 1e5 + 5;\n#define lt (p &lt;&lt; 1)\n#define rt (lt | 1)\nstruct _ &#123; int l, r, u, d; &#125;;\n_ t[maxn &lt;&lt; 2];\nint f[maxn][maxm];\nstd::vector&lt;int&gt; g[maxn];\nint a[maxn], dfn[maxn], rfn[maxn];\nint n, q, r, ty, x, y, v, si, now;\nint top[maxn], dep[maxn], tab[maxn];\nvoid swap(int &amp;x, int &amp;y) &#123;\n    x ^= y ^= x ^= y;\n    return;\n&#125;\nvoid DFS(int x) &#123;\n    dep[x] = dep[f[x][0]] + 1;\n    dfn[x] = ++now, tab[now] = x;\n    for (auto i : g[x]) &#123;\n        if (i == f[x][0]) continue;\n        f[i][0] = x;\n        for (int j = 1; j &lt;= si; ++j)\n            f[i][j] = f[f[i][j - 1]][j - 1];\n        DFS(i);\n    &#125;\n    rfn[x] = now;\n    return;\n&#125;\nvoid pushup(int p) &#123;\n    t[p].u = t[lt].u + t[rt].u;\n    return;\n&#125;\nvoid pushdown(int p) &#123;\n    if (t[p].d) &#123;\n        t[lt].d += t[p].d;\n        t[rt].d += t[p].d;\n        t[lt].u += t[p].d *\n                (t[lt].r - t[lt].l + 1);\n        t[rt].u += t[p].d *\n                (t[rt].r - t[rt].l + 1);\n        t[p].d = 0;\n    &#125;\n    return;\n&#125;\nvoid bld(int p, int l, int r) &#123;\n    t[p].l = l, t[p].r = r;\n    if (l == r) &#123;\n        t[p].u = a[tab[l]];\n        return;\n    &#125;\n    int mid = (l + r) &gt;&gt; 1;\n    bld(lt, l, mid), bld(rt, mid + 1, r);\n    pushup(p);\n    return;\n&#125;\nvoid add(int p, int x, int v) &#123;\n    t[p].u += v;\n    if (t[p].l == t[p].r) return;\n    pushdown(p);\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (x &lt;= mid) add(lt, x, v);\n    else add(rt, x, v);\n    return;\n&#125;\nvoid add(int p, int l, int r, int v) &#123;\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r) &#123;\n        t[p].d += v;\n        t[p].u += (t[p].r - t[p].l + 1) * v;\n        return;\n    &#125;\n    pushdown(p);\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (l &lt;= mid) add(lt, l, r, v);\n    if (r &gt; mid) add(rt, l, r, v);\n    pushup(p);\n    return;\n&#125;\nint ask(int p, int l, int r) &#123;\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r)\n        return t[p].u;\n    pushdown(p);\n    int res = 0,\n        mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (l &lt;= mid) res = ask(lt, l, r);\n    if (r &gt; mid) res += ask(rt, l, r);\n    return res;\n&#125;\nint LCA(int x, int y) &#123;\n    if (dep[x] &lt; dep[y]) swap(x, y);\n    for (int i = si; ~i; --i) &#123;\n        if (dep[f[x][i]] &gt;= dep[y])\n            x = f[x][i];\n    &#125;\n    if (x == y) return x;\n    for (int i = si; ~i; --i) &#123;\n        if (f[x][i] != f[y][i])\n            x = f[x][i], y = f[y][i];\n    &#125;\n    return f[x][0];\n&#125;\nvoid Add(int x, int v) &#123;\n    int rlca = LCA(r, x);\n    if (x == r) add(1, 1, n, v);\n    else if (rlca != x)\n        add(1, dfn[x], rfn[x], v);\n    else &#123;\n        add(1, 1, n, v);\n        int p = r;\n        for (int i = si; ~i; --i) &#123;\n            if (dep[f[p][i]] &gt;= dep[x] + 1)\n                p = f[p][i];\n        &#125;\n        add(1, dfn[p], rfn[p], -v);\n    &#125;\n    return;\n&#125;\nvoid tAdd(int x, int y, int v) &#123;\n    int llca = LCA(r, x), rlca = LCA(r, y),\n        ulca = LCA(x, y);\n    if (dep[llca] &gt;= dep[rlca] &amp;&amp;\n        dep[llca] &gt;= dep[ulca]) Add(llca, v);\n    else if (dep[rlca] &gt;= dep[llca] &amp;&amp;\n        dep[rlca] &gt;= dep[ulca]) Add(rlca, v);\n    else Add(ulca, v);\n    return;\n&#125;\nint tAsk(int x) &#123;\n    int rlca = LCA(r, x);\n    if (x == r) return t[1].u;\n    if (rlca != x)\n        return ask(1, dfn[x], rfn[x]);\n    int p = r;\n    for (int i = si; ~i; --i) &#123;\n        if (dep[f[p][i]] &gt;= dep[x] + 1)\n            p = f[p][i];\n    &#125;\n    return t[1].u - ask(1, dfn[p], rfn[p]);\n&#125;\nvoid add(int x, int y) &#123;\n    g[x].push_back(y);\n    return;\n&#125;\nint main() &#123;\n    read(n), read(q), r = 1;\n    si = log(n) / log(2.0);\n    for (int i = 1; i &lt;= n; ++i) read(a[i]);\n    for (int i = 1; i &lt; n; ++i) &#123;\n        read(x), read(y);\n        add(x, y), add(y, x);\n    &#125;\n    dep[0] = 1, DFS(1), dep[0] = 0;\n    bld(1, 1, n);\n    while (q--) &#123;\n        read(ty);\n        if (ty == 1) read(r);\n        else if (ty == 2) &#123;\n            read(x), read(y), read(v);\n            tAdd(x, y, v);\n        &#125;\n        else &#123;\n            read(x);\n            print(tAsk(x), &#39;\\n&#39;);\n        &#125;\n    &#125;\n    return 0;\n&#125;\n&#125; // namespace XSC062\n#undef int</code></pre>\n</details>\n",
            "tags": [
                "线段树",
                "树状数组",
                "LCA",
                "倍增",
                "鸽巢原理"
            ]
        }
    ]
}