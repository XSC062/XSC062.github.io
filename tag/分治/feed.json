{
    "version": "https://jsonfeed.org/version/1",
    "title": "null • All posts by \"分治\" tag",
    "description": "",
    "home_page_url": "https://xsc062.netlify.app",
    "items": [
        {
            "id": "https://xsc062.netlify.app/20250520/",
            "url": "https://xsc062.netlify.app/20250520/",
            "title": "杂题",
            "date_published": "2025-05-20T14:22:43.000Z",
            "content_html": "<p>manual 是 anual 的 m 词形式（胡言乱语）</p>\n<p>Everyone is potential. （每个人都是蛋白质。）</p>\n<span id=\"more\"></span>\n<hr />\n<h2 id=\"cf2043e-matrix-transformation\">CF2043E Matrix Transformation</h2>\n<p><a href=\"https://codeforces.com/problemset/problem/2043/E\" class=\"uri\">https://codeforces.com/problemset/problem/2043/E</a></p>\n<blockquote>\n<p>给定 <span class=\"math inline\">\\(n\\times m\\)</span> 的 <span class=\"math inline\">\\(01\\)</span> 矩阵 <span class=\"math inline\">\\(A,B\\)</span>，可任意将 <span class=\"math inline\">\\(A\\)</span> 的一行置为 <span class=\"math inline\">\\(0\\)</span> 或一列置为 <span class=\"math inline\">\\(1\\)</span>，问是否能将 <span class=\"math inline\">\\(A\\)</span> 变成 <span class=\"math inline\">\\(B\\)</span>。</p>\n</blockquote>\n<p>发现如果 <span class=\"math inline\">\\(B\\)</span> 的某一行是 <span class=\"math inline\">\\(0\\)</span>，那么不管 <span class=\"math inline\">\\(A\\)</span> 这一行是什么东西都可以通过一次操作让这一行满足条件（当然，要求这步操作最后进行）。列也是相似的。</p>\n<p>那么就有一个撤销的思路，从 <span class=\"math inline\">\\(B\\)</span> 中不断删除全 <span class=\"math inline\">\\(0\\)</span> 行或全 <span class=\"math inline\">\\(1\\)</span> 列，不能删了就对比二者剩下的部分是否全等（因为此时任何操作都是非法的）。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int T;\n    for (std::cin &gt;&gt; T; T--; ) &#123;\n        int n, m;\n        std::cin &gt;&gt; n &gt;&gt; m;\n        using arr = std::vector&lt;int&gt;;\n        using brr = std::vector&lt;arr&gt;;\n        using crr = std::vector&lt;brr&gt;;\n        brr cn(31, arr(n + 1)), cm(31, arr(m + 1));\n        crr a(31, brr(n + 1, arr(m + 1))), b(31, brr(n + 1, arr(m + 1)));\n        for (int i = 1; i &lt;= n; ++i)\n            for (int j = 1, x; j &lt;= m; ++j) &#123;\n                std::cin &gt;&gt; x;\n                for (int k = 0; k &lt; 31; ++k)\n                    a[k][i][j] = (x &gt;&gt; k) &amp; 1;\n            &#125;\n        for (int i = 1; i &lt;= n; ++i)\n            for (int j = 1, x; j &lt;= m; ++j) &#123;\n                std::cin &gt;&gt; x;\n                for (int k = 0; k &lt; 31; ++k) &#123;\n                    b[k][i][j] = (x &gt;&gt; k) &amp; 1;\n                    cn[k][i] += b[k][i][j];\n                    cm[k][j] += !b[k][i][j];\n                &#125;\n            &#125;\n        for (int k = 0; k &lt; 31; ++k) &#123;\n            std::queue&lt;int&gt; qn, qm;\n            std::vector&lt;int&gt; tn(n + 1, 1), tm(m + 1, 1);\n            for (int i = 1; i &lt;= n; ++i)\n                if (!cn[k][i])\n                    tn[i] = 0, qn.push(i);\n            for (int j = 1; j &lt;= m; ++j)\n                if (!cm[k][j])\n                    tm[j] = 0, qm.push(j);\n            for (; !qn.empty() || !qm.empty(); ) &#123;\n                if (!qn.empty()) &#123;\n                    int i = qn.front();\n                    // printf(&quot;delete line %d\\n&quot;, i);\n                    qn.pop();\n                    for (int j = 1; j &lt;= m; ++j)\n                        if (!b[k][i][j] &amp;&amp; !--cm[k][j])\n                            tm[j] = 0, qm.push(j);\n                &#125;\n                else &#123;\n                    int j = qm.front();\n                    // printf(&quot;delete column %d\\n&quot;, j);\n                    qm.pop();\n                    for (int i = 1; i &lt;= n; ++i)\n                        if (b[k][i][j] &amp;&amp; !--cn[k][i])\n                            tn[i] = 0, qn.push(i);\n                &#125;\n            &#125;\n            for (int i = 1; i &lt;= n; ++i)\n                if (tn[i])\n                    for (int j = 1; j &lt;= m; ++j)\n                        if (tm[j] &amp;&amp; a[k][i][j] != b[k][i][j]) &#123;\n                            // printf(&quot;k = %d: (%d, %d)\\n&quot;, k, i, j);\n                            goto nosol;\n                        &#125;\n        &#125;\n        std::cout &lt;&lt; &quot;Yes\\n&quot;;\n        continue;\n    nosol :\n        std::cout &lt;&lt; &quot;No\\n&quot;;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"cf2043f-nim\">CF2043F Nim</h2>\n<p><a href=\"https://codeforces.com/contest/2043/problem/F\" class=\"uri\">https://codeforces.com/contest/2043/problem/F</a></p>\n<blockquote>\n<p>给定 <span class=\"math inline\">\\(m\\)</span> 次询问，每次问从 <span class=\"math inline\">\\(a_l\\sim a_r\\)</span> 选非空子序列使得异或和为 <span class=\"math inline\">\\(0\\)</span>，问子序列最小长度、该前提下的方案数。</p>\n</blockquote>\n<p>发现子序列问题可以等价为背包；背包可以合并（即把整区间拆成若干段后，两两信息可以合并）；<a href=\"/20231117/#关于背包\">背包可以放在分治上</a>；</p>\n<p>由此，把询问离线下来放在 <span class=\"math inline\">\\(a_{1\\sim n}\\)</span> 的分治上，每次只处理在 <span class=\"math inline\">\\([l,r]\\)</span> 间且跨越 <span class=\"math inline\">\\(mid\\)</span> 的询问就可以得到答案。复杂度 <span class=\"math inline\">\\(O(n\\cdot v^2\\log n)\\)</span>。</p>\n<details>\n<p>不要用方案数是否为 <span class=\"math inline\">\\(0\\)</span> 来判断是否无解！因为方案数可能是 <span class=\"math inline\">\\(998244353\\)</span> 的倍数……</p>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int siz = 63;\nconst int mod = 998244353;\nconst int inf = 0x3f3f3f3f;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, m;\n    std::cin &gt;&gt; n &gt;&gt; m;\n    std::vector&lt;int&gt; a(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i];\n    struct _ &#123; int l, r, id; &#125;;\n    std::vector&lt;_&gt; q(m + 1);\n    std::vector&lt;std::pair&lt;int, long long&gt; &gt; res(m + 1, &#123; inf, 0ll &#125;);\n    for (int i = 1; i &lt;= m; ++i) &#123;\n        std::cin &gt;&gt; q[i].l &gt;&gt; q[i].r;\n        q[i].id = i;\n    &#125;\n    std::function&lt;void(int, int, std::vector&lt;_&gt; &amp;q)&gt; calc = [&amp;](int l, int r, std::vector&lt;_&gt; &amp;q) &#123;\n        if (l == r) &#123;\n            for (auto [l, r, id] : q)\n                if (a[l] == 0)\n                    res[id] = &#123; 0, 1ll &#125;;\n            return;\n        &#125;\n        int mid = (l + r) &gt;&gt; 1;\n        std::vector&lt;_&gt; ql, qr, qm;\n        for (; !q.empty(); q.pop_back()) &#123;\n            if (q.back().r &lt;= mid)\n                ql.push_back(std::move(q.back()));\n            else if (q.back().l &gt; mid)\n                qr.push_back(std::move(q.back()));\n            else\n                qm.push_back(std::move(q.back()));\n        &#125;\n        calc(l, mid, ql), calc(mid + 1, r, qr);\n        std::vector&lt;std::vector&lt;int&gt; &gt; f(r - l + 1, std::vector&lt;int&gt; (siz + 1, inf));\n        std::vector&lt;std::vector&lt;long long&gt; &gt; g(r - l + 1, std::vector&lt;long long&gt; (siz + 1));\n        f[mid - l][a[mid]] = 1ll, g[mid - l][a[mid]] = 1ll;\n        for (int i = mid - l - 1; ~i; --i) &#123;\n            int k = a[i + l];\n            f[i] = f[i + 1], g[i] = g[i + 1];\n            if (f[i][k] == 1)\n                (++g[i][k]) %= mod;\n            else\n                f[i][k] = 1, g[i][k] = 1ll;\n            for (int j = 0, k = a[i + l]; j &lt;= siz; ++j)\n                if (f[i + 1][j ^ k] + 1 &lt; f[i][j])\n                    f[i][j] = f[i + 1][j ^ k] + 1, g[i][j] = g[i + 1][j ^ k];\n                else if (f[i + 1][j ^ k] + 1 == f[i][j])\n                    (g[i][j] += g[i + 1][j ^ k]) %= mod;\n        &#125;\n        f[mid - l + 1][a[mid + 1]] = 1ll, g[mid - l + 1][a[mid + 1]] = 1ll;\n        for (int i = mid - l + 2; i &lt;= r - l; ++i) &#123;\n            int k = a[i + l];\n            f[i] = f[i - 1], g[i] = g[i - 1];\n            if (f[i][k] == 1)\n                (++g[i][k]) %= mod;\n            else\n                f[i][k] = 1, g[i][k] = 1ll;\n            for (int j = 0; j &lt;= siz; ++j)\n                if (f[i - 1][j ^ k] + 1 &lt; f[i][j])\n                    f[i][j] = f[i - 1][j ^ k] + 1, g[i][j] = g[i - 1][j ^ k];\n                else if (f[i - 1][j ^ k] + 1 == f[i][j])\n                    (g[i][j] += g[i - 1][j ^ k]) %= mod;\n        &#125;\n        for (auto [ql, qr, id] : qm) &#123;\n            // printf(&quot;at [%d, %d], mid = %d: ASK [%d, %d]: \\n&quot;, l, r, mid, ql, qr);\n            ql -= l, qr -= l;\n            if (f[ql][0] &lt; inf)\n                res[id].first = f[ql][0], res[id].second = g[ql][0];\n            if (f[qr][0] &lt; res[id].first)\n                res[id].first = f[qr][0], res[id].second = g[qr][0];\n            else if (f[qr][0] == res[id].first)\n                (res[id].second += g[qr][0]) %= mod;\n            for (int i = 1; i &lt;= siz; ++i) &#123;\n                // printf(&quot;  %d[%d]: %d(%lld)  |  %d[%d]: %d(%lld)\\n&quot;, ql + l, i, f[ql][i], g[ql][i], qr + l, i, f[qr][i], g[qr][i]);\n                if (f[ql][i] + f[qr][i] &lt; res[id].first)\n                    res[id].first = f[ql][i] + f[qr][i], res[id].second = g[ql][i] * g[qr][i] % mod;\n                else if (f[ql][i] + f[qr][i] == res[id].first)\n                    (res[id].second += g[ql][i] * g[qr][i]) %= mod;\n            &#125;\n            if (res[id].first &lt; inf)\n                res[id].first = (qr - ql + 1) - res[id].first;\n        &#125;\n        return;\n    &#125;;\n    calc(1, n, q);\n    for (int i = 1; i &lt;= m; ++i)\n        if (res[i].first &lt; inf)\n            std::cout &lt;&lt; res[i].first &lt;&lt; &#39; &#39; &lt;&lt; res[i].second &lt;&lt; &#39;\\n&#39;;\n        else\n            std::cout &lt;&lt; -1 &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"贪玩蓝月\">贪玩蓝月</h2>\n<p><a href=\"https://loj.ac/p/6515\" class=\"uri\">https://loj.ac/p/6515</a></p>\n<p><em>差不多的题：<a href=\"https://atcoder.jp/contests/jag2018summer-day2/tasks/jag2018summer_day2_d\" class=\"uri\">https://atcoder.jp/contests/jag2018summer-day2/tasks/jag2018summer_day2_d</a>，注意加入是按体积单增的</em></p>\n<p>发现断点确定时可以背包 <span class=\"math inline\">\\(O(p)\\)</span> 维护插入删除；使用 <a href=\"/20231117/#双栈模拟双端队列\">双栈模拟双端队列</a> 就可以均摊 <span class=\"math inline\">\\(O(pm)\\)</span> 实现插入删除。</p>\n<p>对于询问，当然可以 <span class=\"math inline\">\\(O(p^2)\\)</span> 枚举最值再枚举方案（即枚举一端的贡献）；但复杂度不太美观。考虑倒过来，先 <span class=\"math inline\">\\(O(v)\\)</span> 枚举一端贡献，再枚举『能凑出 <span class=\"math inline\">\\([l,r]\\)</span> 中的值』的另一端的贡献。这样就发现我们是在求区间最大值；每次询问时构建 ST 表预处理另一端的区间最大值即可。</p>\n<p>复杂度 <span class=\"math inline\">\\(O(mq\\log q)\\)</span>。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst long long inf = 1e18;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int m, mod;\n    std::cin &gt;&gt; m &gt;&gt; m &gt;&gt; mod;\n    std::array&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt;, 2&gt; T;\n    std::array&lt;std::vector&lt;std::vector&lt;long long&gt; &gt;, 2&gt; F;\n    F[0].emplace_back(mod, -inf), F[1].emplace_back(mod, -inf);\n    F[0][0][0] = 0ll, F[1][0][0] = 0ll;\n    for (; m--; ) &#123;\n        std::string op;\n        std::cin &gt;&gt; op;\n        if (op[0] == &#39;I&#39;) &#123;\n            int v, w;\n            std::cin &gt;&gt; v &gt;&gt; w, v %= mod;\n            auto &amp;t = T[op[1] == &#39;G&#39;];\n            auto &amp;f = F[op[1] == &#39;G&#39;];\n            t.emplace_back(v, w);\n            f.emplace_back(f.back());\n            for (int i = (int)f.size() - 1, j = 0; j &lt; mod; ++j)\n                if (f[i - 1][(j + mod - v) % mod] + w &gt; f[i][j])\n                    f[i][j] = f[i - 1][(j + mod - v) % mod] + w;\n        &#125;\n        else if (op[0] == &#39;D&#39;) &#123;\n            auto &amp;t0 = T[op[1] == &#39;G&#39;], &amp;t1 = T[op[1] == &#39;F&#39;];\n            auto &amp;f0 = F[op[1] == &#39;G&#39;], &amp;f1 = F[op[1] == &#39;F&#39;];\n            if (t0.empty()) &#123;\n                t1.erase(t1.begin());\n                int to = t1.size() / 2;\n                std::vector&lt;std::pair&lt;int, int&gt; &gt; (t1.begin(), t1.begin() + to).swap(t0);\n                std::reverse(t0.begin(), t0.end());\n                std::vector&lt;std::pair&lt;int, int&gt; &gt; (t1.begin() + to, t1.end()).swap(t1);\n                f0.resize(1), f1.resize(1);\n                for (auto [v, w] : t0) &#123;\n                    f0.emplace_back(f0.back());\n                    for (int i = (int)f0.size() - 1, j = 0; j &lt; mod; ++j)\n                        if (f0[i - 1][(j + mod - v) % mod] + w &gt; f0[i][j])\n                            f0[i][j] = f0[i - 1][(j + mod - v) % mod] + w;\n                &#125;\n                for (auto [v, w] : t1) &#123;\n                    f1.emplace_back(f1.back());\n                    for (int i = (int)f1.size() - 1, j = 0; j &lt; mod; ++j)\n                        if (f1[i - 1][(j + mod - v) % mod] + w &gt; f1[i][j])\n                            f1[i][j] = f1[i - 1][(j + mod - v) % mod] + w;\n                &#125;\n            &#125;\n            else\n                t0.pop_back(), f0.pop_back();\n        &#125;\n        else &#123;\n            int l, r;\n            std::cin &gt;&gt; l &gt;&gt; r;\n            auto res(-inf);\n            std::vector&lt;std::vector&lt;long long&gt; &gt; st(std::__lg(mod) + 1, std::vector&lt;long long&gt; (mod + 1));\n            st[0] = F[1].back();\n            for (int j = 1; (1 &lt;&lt; j) &lt;= mod; ++j)\n                for (int i = 0; i + (1 &lt;&lt; j) - 1 &lt; mod; ++i)\n                    st[j][i] = std::max(st[j - 1][i], st[j - 1][i + (1 &lt;&lt; (j - 1))]);\n            auto ask = [&amp;](int l, int r) &#123;\n                int k = std::__lg(r - l + 1);\n                return std::max(st[k][l], st[k][r - (1 &lt;&lt; k) + 1]);\n            &#125;;\n            for (int j = 0; j &lt; mod; ++j)\n                if (j &lt;= l)\n                    res = std::max(res, F[0].back()[j] + ask(l - j, r - j));\n                else if (l &lt; j &amp;&amp; j &lt;= r)\n                    res = std::max(&#123; res, F[0].back()[j] + ask(0, r - j), F[0].back()[j] + ask(l + mod - j, mod - 1) &#125;);\n                else\n                    res = std::max(res, F[0].back()[j] + ask(l + mod - j, r + mod - j));\n            std::cout &lt;&lt; std::max(-1ll, res) &lt;&lt; &#39;\\n&#39;;\n        &#125;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"apio2025-转杆\">APIO2025 转杆</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P12543\" class=\"uri\">https://www.luogu.com.cn/problem/P12543</a></p>\n<p><del>总有一天我要让全天下的数学题 DP 题字符串题图论题模拟题数据结构题思维题全部消失</del></p>\n<p>不要把它转化成序列问题来考虑！这对观察到结论没有好处！</p>\n<p>考虑 <span class=\"math inline\">\\(n=2\\)</span> 的情况，当且仅当垂直时最优。<span class=\"math inline\">\\(n=3\\)</span> 时，随便固定其中一条线，发现剩下两条线如果夹角固定，则代价固定；当夹角取 <span class=\"math inline\">\\(90^{\\circ}\\)</span> 时最优。</p>\n<p>于是猜是不是任意一对都要垂直。考虑数归，当前 <span class=\"math inline\">\\(2n\\)</span> 对 <del>不知道怎么摆的，反正就是</del> 最优时：</p>\n<ul>\n<li>考虑加入第 <span class=\"math inline\">\\(2n+1\\)</span> 条；参照 <span class=\"math inline\">\\(n=3\\)</span> 的情形，把前 <span class=\"math inline\">\\(2n\\)</span> 条任意两两配对，则第 <span class=\"math inline\">\\(2n+1\\)</span> 的位置对代价没有任何影响。</li>\n<li>考虑加入第 <span class=\"math inline\">\\(2n+2\\)</span> 条；相似地，它的位置对前 <span class=\"math inline\">\\(2n\\)</span> 条没有任何影响；故需要最大化它和第 <span class=\"math inline\">\\(2n+1\\)</span> 条的贡献。取垂直即可。</li>\n</ul>\n<p>因此得到任意一对都要垂直。具体怎么调整呢？首先下意识排序；配对方式即将 <span class=\"math inline\">\\(i\\)</span> 与 <span class=\"math inline\">\\(\\dfrac i+\\lfloor \\frac n2\\rfloor\\)</span> 配对；因为能感受到这样影响的线段最少。严谨的证明好像没看到。</p>\n<details>\n<pre class=\"cpp\"><code>#include&lt;bits/stdc++.h&gt;\nvoid energy(int, std::vector&lt;int&gt;);\nvoid rotate(std::vector&lt;int&gt;, int);\nvoid energy(int n, std::vector&lt;int&gt; a) &#123;\n    std::vector&lt;int&gt; id(n);\n    std::iota(id.begin(), id.end(), 0);\n    std::sort(id.begin(), id.end(), [&amp;](int x, int y) &#123; return a[x] &lt; a[y]; &#125;);\n    for (int i = 0, j = n / 2; i &lt; n / 2; ++i, ++j)\n        rotate(&#123; id[j] &#125;, (a[id[i]] + 75000 - a[id[j]]) % 50000);\n    return;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"abc407e-most-valuable-parentheses\">ABC407E Most Valuable Parentheses</h2>\n<p><a href=\"https://atcoder.jp/contests/abc407/tasks/abc407_e\" class=\"uri\">https://atcoder.jp/contests/abc407/tasks/abc407_e</a></p>\n<p>这里有一个很典（可惜我不知道）的 trick：<a href=\"/20231117/#贪心选取括号序列\">贪心构造最优括号序列</a>。</p>\n<p>用优先队列维护，贪心选即可。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int T;\n    for (std::cin &gt;&gt; T; T--; ) &#123;\n        int n;\n        std::cin &gt;&gt; n;\n        std::vector&lt;int&gt; a(2 * n + 1);\n        for (int i = 1; i &lt;= 2 * n; ++i)\n            std::cin &gt;&gt; a[i];\n        long long res = a[1];\n        std::priority_queue&lt;int&gt; q;\n        for (int i = 2; i &lt; 2 * n; i += 2) &#123;\n            q.push(a[i]), q.push(a[i + 1]);\n            res += q.top(), q.pop();\n        &#125;\n        std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n",
            "tags": [
                "分治",
                "背包"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20241017/",
            "url": "https://xsc062.netlify.app/20241017/",
            "title": "模拟赛",
            "date_published": "2024-10-16T12:32:34.000Z",
            "content_html": "<p>好消息：会简单数学题 <img src=\"/em/dy.gif\" /></p>\n<p>更好的消息：忘取模了 <img src=\"/em/dy.gif\" /></p>\n<span id=\"more\"></span>\n<hr />\n<h3 id=\"a.-distorted\">A. distorted</h3>\n<p><a href=\"http://222.180.160.110:61235/contest/5611/problem/1\" class=\"uri\">http://222.180.160.110:61235/contest/5611/problem/1</a></p>\n<p>考虑最多需要多少个元素。最坏情况是选取四个角的元素，已经可以覆盖整个矩阵。进一步考虑感性反证发现无论如何都选不出来五个，故最多选择四个。</p>\n<p>我们发现，选取中间一个就可以覆盖整个矩阵。扩展一下，选择中间列就可以覆盖上 / 下半个矩阵，选择中间行就可以覆盖左 / 右半个矩阵。剩下的选择过后只能保证照顾到对应的 1/4 矩阵且一定不会完全覆盖其他的 1/4 矩阵。</p>\n<p>我们发现，中心元素地位高于中间行 / 列元素高于左上、左下、右上、右下元素。由此出发讨论选择元素的个数。</p>\n<ul>\n<li>1 个：选择中心元素。</li>\n<li>2 个：在中间行的左右两边各选一个 / 在中间列的上下两边各选一个。</li>\n<li>3 个：选一个中间行 / 列 + 两个其他元素，或两个中间行 / 列 + 一个其他元素。</li>\n<li>4 个：左上、左下、右上、右下各选一个。</li>\n</ul>\n<p>统计各个方向的最小值，选最小组合即可。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\n#define putchar\nconst long long inf = 0x3f3f3f3f;\nint main() &#123;\n    freopen(&quot;distorted.in&quot;, &quot;r&quot;, stdin);\n    freopen(&quot;distorted.out&quot;, &quot;w&quot;, stdout);\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n    int T;\n    for (std::cin &gt;&gt; T; T--; ) &#123;\n        int n;\n        std::cin &gt;&gt; n;\n        long long to = inf, u = inf, d = inf, l = inf, r = inf, q = inf, z = inf, p = inf, m = inf;\n        for (int i = 1; i &lt;= n; ++i)\n            for (int j = 1; j &lt;= n; ++j) &#123;\n                long long x;\n                std::cin &gt;&gt; x;\n                if (i * 2 - 1 == n &amp;&amp; j * 2 - 1 == n)\n                    to = x;\n                else if (i * 2 - 1 == n &amp;&amp; j * 2 - 1 &lt; n)\n                    l = std::min(l, x);\n                else if (i * 2 - 1 == n)\n                    r = std::min(r, x);\n                else if (i * 2 - 1 &lt; n &amp;&amp; j * 2 - 1 == n)\n                    u = std::min(u, x);\n                else if (j * 2 - 1 == n)\n                    d = std::min(d, x);\n                else if (i * 2 - 1 &lt; n &amp;&amp; j * 2 - 1 &lt; n)\n                    q = std::min(q, x);\n                else if (i * 2 - 1 &lt; n)\n                    p = std::min(p, x);\n                else if (j * 2 - 1 &lt; n)\n                    z = std::min(z, x);\n                else\n                    m = std::min(m, x);\n            &#125;\n        std::cout &lt;&lt; std::min(&#123; to, l + r, u + d, l + u + m, l + d + p, r + u + z, r + d + q, u + z + m, d + q + p, l + p + m, r + q + z, q + p + z + m &#125;) &lt;&lt; &#39;\\n&#39;;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"b.-fate\">B. fate</h3>\n<p><a href=\"http://222.180.160.110:61235/contest/5611/problem/2\" class=\"uri\">http://222.180.160.110:61235/contest/5611/problem/2</a></p>\n<p>诈骗题。对于前半段，考虑取差分数组 <span class=\"math inline\">\\(d\\)</span>，容易发现如果直接在差分数组上做减法，一定满足后面减得不比前面少。故只要满足差分数组每一项至少为 <span class=\"math inline\">\\(0\\)</span> 即可，答案为 <span class=\"math inline\">\\(\\prod {i\\le p} a_i - a_{i-1} + 1\\)</span>。</p>\n<p>对于后半段，我们考虑转化成和前半段相似的问题，将后半段翻转，同样取差分数组，则此时在该差分数组上满足后面减得不比前面少，同时需要满足差分数组每一项至多为 <span class=\"math inline\">\\(0\\)</span>，前面的所有项初始为负，操作为减，自然满足；但第 <span class=\"math inline\">\\(p\\)</span> 项在把前面减去的全部加上后不一定满足。故前面最多减去 <span class=\"math inline\">\\(d_p\\)</span>，随便在哪里减都无所谓，组合意义一下，就是无标号球放有标号盒子可空放可不放，插板得答案为 <span class=\"math inline\">\\(\\displaystyle {-d_p + n - p\\choose n - p}\\)</span>。</p>\n<p>前后乘起来即为答案。注意不要在最后一步乘起来的时候忘记取模，否则你会获得 76pts 的高分 <img src=\"/em/xk.gif\" /></p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 998244353;\nint main() &#123;\n    freopen(&quot;fate.in&quot;, &quot;r&quot;, stdin);\n    freopen(&quot;fate.out&quot;, &quot;w&quot;, stdout);\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n    int n, m;\n    std::cin &gt;&gt; n;\n    std::vector&lt;long long&gt; a(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i];\n    std::cin &gt;&gt; m;\n    long long res = 1;\n    for (int i = 1; i &lt; m; ++i) &#123;\n        auto x = a[i] - a[i - 1];\n        (res *= x + 1) %= mod;\n    &#125;\n    auto qkp = [](long long x, int y) &#123;\n        long long res = 1;\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    auto C = [&amp;](int n, int m) &#123;\n        long long res = 1ll;\n        for (int i = n; i &gt; n - m; --i)\n            (res *= i) %= mod;\n        for (int i = m; i; --i)\n            (res *= qkp(i, mod - 2)) %= mod;    \n        return res;\n    &#125;;\n    if (m != n)\n        (res *= C(a[m + 1] - a[m] + n - m, n - m)) %= mod;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"c.-abstruse\">C. abstruse</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P9731\" class=\"uri\">https://www.luogu.com.cn/problem/P9731</a></p>\n<p>注意到有挺高的一档 <span class=\"math inline\">\\(S=2\\)</span> 的分，考虑其启示意义。</p>\n<p>我们对于一对 <span class=\"math inline\">\\((a_i, b_i)\\)</span>，在 <span class=\"math inline\">\\(a_i\\)</span> 和 <span class=\"math inline\">\\(b_i\\)</span> 间连边，则原问题转化为给无向图的每条边选择方向，使对于每个 <span class=\"math inline\">\\(x\\)</span>，<span class=\"math inline\">\\(|in_x-out_x|\\le 1\\)</span>。</p>\n<p>我们知道对于一条欧拉回路，有对于任意 <span class=\"math inline\">\\(x\\)</span>，<span class=\"math inline\">\\(in_x=out_x\\)</span>。然后这个时候为了把问题转化成欧拉回路问题我们建一个虚点朝度数为奇的点连条边然后跑欧拉回路即可。</p>\n<p>至于 <span class=\"math inline\">\\(S=2^k\\)</span>，就是在明示分治。即对于任意 <span class=\"math inline\">\\(x\\)</span>，要求其在前后 <span class=\"math inline\">\\(2^{k-1}\\)</span> 次出现次数相差不超过 <span class=\"math inline\">\\(1\\)</span>。注意到非常幸福的有前后两个部分大小相等，又有一个天才的建图，<mark>即在每个点和自己所属的行连边，然后跑欧拉回路，出边表示选前半部分，入边表示选后半部分，这样就保证了一行中各有 <span class=\"math inline\">\\(2^{k-1}\\)</span> 个选前后半部分，也保证了每个点在前后半边出现的次数相差不超过 <span class=\"math inline\">\\(1\\)</span>。对于后面一个性质，分治最终可得到点在每一列出现次数相差不超过 <span class=\"math inline\">\\(1\\)</span></mark>。</p>\n<p>打个当前弧优化然后注意计算细节复杂度然后多卡几（十）遍就过了 <img src=\"/em/dy.gif\" /></p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nnamespace fastIO &#123;\nconst int LEN = (1 &lt;&lt; 20);\n#ifdef ONLINE_JUDGE\nint nec(void) &#123;\n    static char buf[LEN], *p = buf, *e = buf;\n    if (p == e) &#123;\n        e = buf + fread(buf, 1, LEN, stdin);\n        if (e == buf) return EOF;\n        p = buf;\n    &#125;\n    return *p++;\n&#125;\n#else\n#define nec getchar\n#endif\nbool read(int &amp;x) &#123;\n    x = 0;\n    bool f = 0;\n    char ch = nec();\n    while (ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123;\n        if (ch == EOF) return 0;\n        if (ch == &#39;-&#39;) f = 1;\n        ch = nec();\n    &#125;\n    while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) &#123;\n        x = x * 10 + ch - &#39;0&#39;;\n        ch = nec();\n    &#125;\n    if (f) x = -x;\n    return 1;\n&#125;\nvoid print(int x) &#123;\n    if (x &lt; 0)\n        putchar(&#39;-&#39;), x = -x;\n    if (x &gt;= 10) print(x / 10);\n    putchar(x % 10 + &#39;0&#39;);\n    return;\n&#125;\nvoid print(int x, char ch) &#123;\n    print(x), putchar(ch);\n    return;\n&#125;\n&#125; using namespace fastIO;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    std::cout.tie(nullptr);\n    freopen(&quot;abstruse.in&quot;, &quot;r&quot;, stdin);\n    freopen(&quot;abstruse.out&quot;, &quot;w&quot;, stdout);\n#else\n    freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, m, k;\n    read(n), read(m), read(k);\n    std::vector&lt;std::vector&lt;int&gt; &gt; a(n + 1, std::vector&lt;int&gt; (m + 1));\n    for (int i = 1; i &lt;= n; ++i)\n        for (int j = 1; j &lt;= m; ++j)\n            read(a[i][j]);\n    std::vector&lt;int&gt; to(k + n + 1), tag(n * m + n + k + 1);\n    std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; g(k + n + 1); \n    std::function&lt;void(int, int)&gt; calc = [&amp;](int l, int r) &#123;\n        if (l + 1 == r) &#123;\n            for (int i = 1; i &lt;= n; ++i) &#123;\n                g[a[i][l]].emplace_back(a[i][r], i);\n                g[a[i][r]].emplace_back(a[i][l], i);\n            &#125;\n            int cnt = n;\n            for (int i = 1; i &lt;= n; ++i) &#123;\n                if ((int)g[a[i][l]].size() &amp; 1)\n                    g[0].emplace_back(a[i][l], ++cnt), g[a[i][l]].emplace_back(0, cnt);\n                if ((int)g[a[i][r]].size() &amp; 1)\n                    g[0].emplace_back(a[i][r], ++cnt), g[a[i][r]].emplace_back(0, cnt);\n            &#125;\n            std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;\n                for (int i = to[x]; i &lt; (int)g[x].size(); i = to[x]) &#123;\n                    to[x] = i + 1;\n                    auto [v, id] = g[x][i];\n                    if (!tag[id]) &#123;\n                        tag[id] = 1;\n                        if (x &amp;&amp; v)\n                            a[id][l] = x, a[id][r] = v;\n                        DFS(v);\n                    &#125;\n                &#125;\n                return;\n            &#125;;\n            DFS(0);\n            for (int i = 1; i &lt;= n; ++i)\n                DFS(a[i][l]), DFS(a[i][r]);\n            to[0] = 0, g[0].clear();\n            for (int i = 1; i &lt;= n; ++i) &#123;\n                to[a[i][l]] = 0, g[a[i][l]].clear();\n                to[a[i][r]] = 0, g[a[i][r]].clear();\n            &#125;\n            std::fill(tag.begin() + 1, tag.begin() + cnt + 1, 0);\n            return;\n        &#125;\n        int mid = (l + r) &gt;&gt; 1, cnt = 0;\n        std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; g(k + n + 1);\n        for (int i = 1; i &lt;= n; ++i)\n            for (int j = l; j &lt;= r; ++j) &#123;\n                g[a[i][j]].emplace_back(i + k, ++cnt);\n                g[i + k].emplace_back(a[i][j], cnt);\n            &#125;\n        for (int i = 1; i &lt;= n; ++i)\n            for (int j = l; j &lt;= r; ++j)\n                if ((int)g[a[i][j]].size() &amp; 1)\n                    g[0].emplace_back(a[i][j], ++cnt), g[a[i][j]].emplace_back(0, cnt);\n        std::vector&lt;int&gt; L(n + 1, l - 1), R(n + 1, r + 1);\n        std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;\n            for (int i = to[x]; i &lt; (int)g[x].size(); i = to[x]) &#123;\n                to[x] = i + 1;\n                auto [v, id] = g[x][i];\n                if (!tag[id]) &#123;\n                    tag[id] = 1;\n                    if (x &amp;&amp; v) &#123;\n                        if (v &lt;= k)\n                            a[x - k][++L[x - k]] = v;\n                        else\n                            a[v - k][--R[v - k]] = x;\n                    &#125;\n                    DFS(v);\n                &#125;\n            &#125;\n            return;\n        &#125;;\n        DFS(0);\n        for (int i = 1; i &lt;= n; ++i)\n            DFS(i + k);\n        for (int i = 1; i &lt;= n; ++i)\n            for (int j = l; j &lt;= r; ++j)\n                DFS(a[i][j]);\n        to[0] = 0, g[0].clear();\n        for (int i = 1; i &lt;= n; ++i)\n            to[i + k] = 0, g[i + k].clear();\n        for (int i = 1; i &lt;= n; ++i)\n            for (int j = l; j &lt;= r; ++j)\n                to[a[i][j]] = 0, g[a[i][j]].clear();\n        std::fill(tag.begin() + 1, tag.begin() + cnt + 1, 0);\n        calc(l, mid), calc(mid + 1, r);\n        return;\n    &#125;;\n    calc(1, m);\n    for (int i = 1; i &lt;= n; ++i, putchar(&#39;\\n&#39;))\n        for (int j = 1; j &lt;= m; ++j)\n            print(a[i][j], &#39; &#39;);\n    return 0;\n&#125;</code></pre>\n</details>\n",
            "tags": [
                "分治",
                "欧拉回路"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20230314/",
            "url": "https://xsc062.netlify.app/20230314/",
            "title": "分治",
            "date_published": "2023-03-13T18:33:31.000Z",
            "content_html": "<p>听说是 <a href=\"http://222.180.160.110:61235/contest/3416\">分治场</a>，想起了自己根本没学过分治（甚至从来不知道归并排序的原理 orz）就去听 CDQ 然后一头雾水的惨痛经历，不禁 PTSD 了。</p>\n<span id=\"more\"></span>\n<hr />\n<h3 id=\"a.-老板的又一道题\">A. 老板的又一道题</h3>\n<p><a href=\"http://222.180.160.110:61235/contest/3416/problem/1\" class=\"uri\">http://222.180.160.110:61235/contest/3416/problem/1</a></p>\n<p>这是什么，有序表的最小和，切一下（所以和分治有什么关系啊）。</p>\n<p>首先对数组进行排序（我忘了 orz），然后在优先队列中填入 <span class=\"math inline\">\\(A_{1\\sim n} + B_1\\)</span>。假设当前最小值为 <span class=\"math inline\">\\(A_i + B_j\\)</span>，则输出，弹出并填入 <span class=\"math inline\">\\(A_i + B_{j + 1}\\)</span>。因为 <span class=\"math inline\">\\(B\\)</span> 是单调的，所以我们填入的数（起码在输出时）是单调的。</p>\n<details>\n<pre class=\"cpp\"><code>namespace XSC062 &#123;\nusing namespace fastIO;\nconst int maxn = 1e5 + 5;\nstruct _ &#123;\n    int u, i;\n    _() &#123;&#125;\n    _(int u1, int i1) &#123;\n        u = u1, i = i1;\n    &#125;\n    bool operator&lt; (const _ q) const &#123;\n        return u &gt; q.u;\n    &#125;\n&#125;;\nint n, cnt;\nint a[maxn], b[maxn];\nstd::priority_queue&lt;_&gt; q;\nint main() &#123;\n    read(n);\n    for (int i = 1; i &lt;= n; ++i)\n        read(a[i]);\n    for (int i = 1; i &lt;= n; ++i)\n        read(b[i]);\n    std::sort(a + 1, a + n + 1);\n    std::sort(b + 1, b + n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        q.push(_(a[i] + b[1], 1));\n    while (!q.empty()) &#123;\n        _ f = q.top();\n        q.pop();\n        print(f.u, &#39; &#39;);\n        if (++cnt == n)\n            break;\n        _ t = f;\n        t.u -= b[f.i];\n        t.u += b[++t.i];\n        q.push(t);\n    &#125;\n    return 0;\n&#125;\n&#125; // namespace XSC062</code></pre>\n</details>\n<hr />\n<h3 id=\"b.-魔法石的诱惑\">B. 魔法石的诱惑</h3>\n<p><a href=\"http://222.180.160.110:61235/contest/3416/problem/2\" class=\"uri\">http://222.180.160.110:61235/contest/3416/problem/2</a></p>\n<p>这，这不是二分答案？到底和分治有什么关系啊。</p>\n<p>嘶，<span class=\"math inline\">\\(Q\\)</span> 是 <span class=\"math inline\">\\(10^8\\)</span>，算一算 <span class=\"math inline\">\\(n\\)</span> 的范围。不难发现 <span class=\"math inline\">\\(Q=\\sum\\limits_{i&gt;1} \\lfloor \\dfrac n{5^i} \\rfloor\\)</span>，当 <span class=\"math inline\">\\(n=5\\times 10^8\\)</span> 时，<span class=\"math inline\">\\(\\dfrac n5\\)</span> 就已经是 <span class=\"math inline\">\\(10^8\\)</span> 了，所以我们二分的左右边界应为 <span class=\"math inline\">\\([0,5\\times 10^8]\\)</span>。</p>\n<p>然后 <code>check</code> 的话我们就暴力除 <span class=\"math inline\">\\(5\\)</span> 计算答案（就像小奥一样），一次 <code>check</code> 的时间复杂度是 <span class=\"math inline\">\\(\\log_5\\)</span> 的，不会有问题。</p>\n<details>\n<pre class=\"cpp\"><code>namespace XSC062 &#123;\nusing namespace fastIO;\nint q, l, mid, r = 5e18, res;\nint check(int x) &#123;\n    int res = 0;\n    while (x / 5)\n        res += (x /= 5);\n    return res;\n&#125;\nint main() &#123;\n    read(q);\n    while (l &lt;= r) &#123;\n        int mid = (l + r) &gt;&gt; 1;\n        if (check(mid) &gt;= q) &#123;\n            res = mid;\n            r = mid - 1;\n        &#125;\n        else l = mid + 1;\n    &#125;\n    if (check(res) == q)\n        print(res);\n    else puts(&quot;No solution&quot;);\n    return 0;\n&#125;\n&#125; // namespace XSC062</code></pre>\n</details>\n<hr />\n<h3 id=\"c.-神族文字\">C. 神族文字</h3>\n<p><a href=\"http://222.180.160.110:61235/contest/3416/problem/3\" class=\"uri\">http://222.180.160.110:61235/contest/3416/problem/3</a></p>\n<p>我不理解？这到底和分治有什么关系？GM 不会是纯看标签拉题吧？标签又是哪个聪明打的？</p>\n<p>总而言之，言而总之，我们打一个 <code>map</code>。</p>\n<details>\n<pre class=\"cpp\"><code>namespace XSC062 &#123;\nusing namespace fastIO;\nusing str = std::string;\nstr s1, s2, sl;\nstd::map&lt;str, str&gt; t;\nint main() &#123;\n    for (;;) &#123;\n        std::getline(std::cin, sl);\n        std::stringstream s(sl);\n        if (s &gt;&gt; s1) &#123;\n            s &gt;&gt; s2;\n            t[s2] = s1;\n        &#125;\n        else break;\n    &#125;\n    while (std::cin &gt;&gt; s1) &#123;\n        if (t.count(s1))\n            std::cout &lt;&lt; t[s1] &lt;&lt; &#39;\\n&#39;;\n        else puts(&quot;eh&quot;);\n    &#125;\n    return 0;\n&#125;\n&#125; // namespace XSC062</code></pre>\n</details>\n<hr />\n<h3 id=\"d.-逃亡\">D. 逃亡</h3>\n<p><a href=\"http://222.180.160.110:61235/contest/3416/problem/4\" class=\"uri\">http://222.180.160.110:61235/contest/3416/problem/4</a></p>\n<p>首先注意到车车是自动驾驶的，就是说一个人下车过后车会自动往另一个人的方向跑。</p>\n<p>明显反复交接的话车会多跑很多路程，所以我们只交接一次。</p>\n<p>所以难点只是用未知数把最终速度表示出来（想起了物理实验题）。</p>\n<p>假设距离为 <span class=\"math inline\">\\(S\\)</span>，车速为 <span class=\"math inline\">\\(v_1\\)</span>，人速为 <span class=\"math inline\">\\(v_2\\)</span>，第一个人一直坐车坐到 <span class=\"math inline\">\\(x\\)</span> 路程，则最终时间为 <span class=\"math inline\">\\(\\max\\left\\{ \\dfrac x{v_1} + \\dfrac {S - x}{v_2}, \\dfrac x{v_1}+\\dfrac {x - \\dfrac x{v_1}\\times v_2}{v_1 + v_2} + \\dfrac {S-\\dfrac x{v_1}\\times v_2 - \\dfrac {x - \\dfrac x{v_1}\\times v_2}{v_1 + v_2} \\times v_2}{v_1}\\right\\}\\)</span>。</p>\n<p>有一个很明显的点，就是 <span class=\"math inline\">\\(x\\)</span> 越大，第一个人用时就越短，第二个人用时就越多。这个时候我们就可以二分 <span class=\"math inline\">\\(x\\)</span>，尽量使第一个人和第二个人用时接近（用时是一个关于 <span class=\"math inline\">\\(x\\)</span> 的分段函数，我们寻找其拐点），最终相同用时即为答案。</p>\n<details>\n<p>因为从来不是很喜欢浮点数二分，采用了先整数二分再框范围取精确答案的方法。</p>\n<p>所以怎么又是二分？说好的分治场呢？</p>\n<pre class=\"cpp\"><code>namespace XSC062 &#123;\nusing namespace fastIO;\nusing db = double;\nconst db eps = 1e-2;\ndb res, ans = 1e18;\nint s, v1, v2, l, mid, r;\ndb min(db x, db y) &#123;\n    return x &lt; y ? x : y; \n&#125;\ndb max(db x, db y) &#123;\n    return x &gt; y ? x : y;\n&#125;\nbool check(int x) &#123;\n    db t1 = x * 1.0 / v1;\n    db r1 = t1 + (s - x) * 1.0 / v2;\n    db t2 = (x - t1 * v2) / (v1 + v2);\n    db r2 = t1 + t2 + (s - t1 * v2 - t2 * v2) / v1;\n    return r1 &lt;= r2;\n&#125;\nint main() &#123;\n    read(s), read(v2), read(v1);\n    l = 0, r = s;\n    while (l &lt;= r) &#123;\n        mid = (l + r) &gt;&gt; 1;\n        if (check(mid)) &#123;\n            res = (db)mid;\n            r = mid - 1;\n        &#125;\n        else l = mid + 1;\n    &#125;\n    for (db i = res - 2; i &lt;= res + 2; i += eps) &#123;\n        db t1 = i * 1.0 / v1;\n        db r1 = t1 + (s - i) * 1.0 / v2;\n        db t2 = (i - t1 * v2) / (v1 + v2);\n        db r2 = t1 + t2 +\n                (s - t1 * v2 - t2 * v2) / v1;\n        ans = min(ans, max(r1, r2));\n    &#125;\n    printf(&quot;%.2lf&quot;, ans);\n    return 0;\n&#125;\n&#125; // namespace XSC062</code></pre>\n</details>\n<hr />\n<h3 id=\"e.-剔除多余括号\">E. 剔除多余括号</h3>\n<p><a href=\"http://222.180.160.110:61235/contest/3416/problem/5\" class=\"uri\">http://222.180.160.110:61235/contest/3416/problem/5</a></p>\n<p><em>为了套取数据理解题意，我用 python 交了一个 <code>print(input())</code>，结果总司令在上，得到了 33pts 的高分…</em></p>\n<p>什么叫多余括号呢？括号前后的符号优先级小于等于括号中的符号，并且若括号内存在括号与括号前同级，则括号前不为 <code>-</code> 或 <code>/</code>。</p>\n<p>这样就可以了。我们将问题划分为若干个子问题，对每个括号内的内容进行相同方式的处理：对比括号内优先级最高的符号和括号前后符号的优先级，处理括号内的内容时若遇到括号，则递归地进行相似的处理。</p>\n<details>\n<p>其实这个充其量只能算是模拟…… 跟分治并不是很有关系，和 CSP-J 2022 T3 有点像。</p>\n<pre class=\"cpp\"><code>namespace XSC062 &#123;\nusing namespace fastIO;\nconst int maxn = 260;\nint n;\nchar s[maxn];\nbool vis[maxn];\nint max(int x, int y) &#123;\n    return x &gt; y ? x : y;\n&#125;\nint Deal(int l, int r) &#123;\n    int res = 1;\n    for (int i = l; i &lt;= r; ++i) &#123;\n        if (s[i] == &#39;+&#39; || s[i] == &#39;-&#39;)\n            res = max(res, 1);\n        else if (s[i] == &#39;*&#39; || s[i] == &#39;/&#39;)\n            res = 2;\n        else if (s[i] == &#39;(&#39;) &#123;\n            int cnt = 1, j;\n            for (j = i + 1; j &lt;= r; ++j) &#123;\n                if (s[j] == &#39;(&#39;)\n                    ++cnt;\n                else if (s[j] == &#39;)&#39;)\n                    --cnt;\n                if (cnt == 0)\n                    break;\n            &#125;\n            cnt = Deal(i + 1, j - 1);\n            int t = 1;\n            int p1 = i - 1, p2 = j + 1;\n            while (s[p1] == &#39;(&#39; || s[p1] == &#39;)&#39;)\n                --p1;\n            while (s[p2] == &#39;(&#39; || s[p2] == &#39;)&#39;)\n                ++p2;\n            if (s[p1] == &#39;+&#39; || s[p1] == &#39;-&#39;)\n                t = max(t, 1);\n            else t = max(t, 2);\n            if (s[p2] == &#39;+&#39; || s[p2] == &#39;-&#39;)\n                t = max(t, 1);\n            else t = max(t, 2);\n            if (t &lt; cnt)\n                vis[i] = vis[j] = 1;\n            else if (t == cnt) &#123;\n                if (s[p1] != &#39;-&#39; &amp;&amp; s[p1] != &#39;/&#39;)\n                    vis[i] = vis[j] = 1;\n            &#125;\n            i = j;\n        &#125;\n    &#125;\n    return res;\n&#125;\nint main() &#123;\n    s[1] = &#39;+&#39;;\n    scanf(&quot;%s&quot;, s + 2);\n    n = strlen(s + 1) + 1;\n    s[n] = &#39;+&#39;;\n    Deal(1, n);\n    for (int i = 2; i &lt; n; ++i) &#123;\n        if (!vis[i])\n            putchar(s[i]);\n    &#125;\n    return 0;\n&#125;\n&#125; // namespace XSC062</code></pre>\n</details>\n<hr />\n<h3 id=\"f.-最接近点对问题\">F. 最接近点对问题</h3>\n<p><a href=\"http://222.180.160.110:61235/contest/3416/problem/6\" class=\"uri\">http://222.180.160.110:61235/contest/3416/problem/6</a></p>\n<p>分治典中典。</p>\n<p>我们将点按照横坐标排序，对点 <span class=\"math inline\">\\(1\\sim n\\)</span> 进行分治。</p>\n<p>将求解区间包含的点分为两部分，假设左边部分和右边部分已经分别求解出了最近点对（出口即为求解区间仅包含两点，直接求出距离），考虑合并状态。则情况无非有三种：</p>\n<ol type=\"1\">\n<li>答案为左边部分的答案</li>\n<li>答案为右边部分的答案</li>\n<li>答案为左、右各选取一点</li>\n</ol>\n<p>前两者是已知量，则我们求解出第三种情况，选择最小值即可。</p>\n<p>第三种情况有个很妙的处理方式：我们设前两种情况的答案较小者为 <span class=\"math inline\">\\(d\\)</span>，设求解区间最靠中间的点为 <span class=\"math inline\">\\(m\\)</span>。</p>\n<ul>\n<li><p>若 <span class=\"math inline\">\\(m\\)</span> 为左边部分的点</p>\n<p>则由于我们对半二分，<span class=\"math inline\">\\(m\\)</span> 一定是左边部分最靠右的点。</p>\n<ul>\n<li><p>对于其余左边部分的节点：</p>\n若它们与 <span class=\"math inline\">\\(m\\)</span> 的横向距离已经大于等于 <span class=\"math inline\">\\(d\\)</span>，则它们与右边部分的点的横向距离会更大。连横向距离都已经大于等于当前最优解了，无需考虑纵向距离，筛除这部分点。</li>\n<li><p>对于右边部分的节点：</p>\n<p>若它们与 <span class=\"math inline\">\\(m\\)</span> 的横向距离已经大于等于 <span class=\"math inline\">\\(d\\)</span>，则它们与更左边的其他左边部分节点的横向距离会更大，故筛除这部分点。</p></li>\n</ul></li>\n<li><p>若 <span class=\"math inline\">\\(m\\)</span> 为右边部分的点</p>\n<p>同理。</p></li>\n</ul>\n<p>综上，我们只用考虑求解区间内与 <span class=\"math inline\">\\(m\\)</span> 的横向距离小于 <span class=\"math inline\">\\(d\\)</span> 的点。</p>\n<p>在筛选出这些点后，我们如何进行进一步的处理呢？答案是，<strong>枚举</strong>。</p>\n<p>我们枚举每一对点，计算它们间的距离。若比答案小，则更新答案。</p>\n<p>那这复杂度也太神奇了。所以我们给出一个同样神奇的优化：按纵坐标递增对筛选出的点排序。当二重循环筛选时，若当前第一层循环 <span class=\"math inline\">\\(i\\)</span> 与第二层循环 <span class=\"math inline\">\\(j\\)</span> 的纵向距离大于等于了当前最小答案，就可以将第二层循环 <code>break</code> 了。因为纵坐标单调，继续枚举距离会继续增加，离答案更远。</p>\n<p>那看起来复杂度还是很神奇，理论上来说应该是 <span class=\"math inline\">\\(O(n^2\\log n)\\)</span> 的呀？</p>\n<p>考虑第一层循环 <span class=\"math inline\">\\(i\\)</span>。对于点 <span class=\"math inline\">\\(i\\)</span>，有哪些 <span class=\"math inline\">\\(j\\)</span> 可以满足它的要求，从而被枚举到呢？</p>\n<ul>\n<li>由于点对无序，所以 <span class=\"math inline\">\\(j\\)</span> 从 <span class=\"math inline\">\\(i+1\\)</span> 开始枚举，所以 <span class=\"math inline\">\\(y_j&gt;y_i\\)</span>。</li>\n<li>由于筛选条件，<span class=\"math inline\">\\(|x_i-x_m|&lt; d\\)</span> 且 <span class=\"math inline\">\\(|x_j-x_m|&lt; d\\)</span>。</li>\n<li>由于 <code>break</code> 条件，<span class=\"math inline\">\\(y_j-y_i&lt; d\\)</span>。</li>\n</ul>\n<p>合并一下就是，<span class=\"math inline\">\\(|x_i-x_j|\\le 2\\times d\\)</span>，且 <span class=\"math inline\">\\(0\\le y_j - y_i \\le d\\)</span>。那么我们可以画出一个底为 <span class=\"math inline\">\\(2\\times d\\)</span>，高为 <span class=\"math inline\">\\(d\\)</span> 的矩形，且它的中轴线为 <span class=\"math inline\">\\(x=x_m\\)</span>，中轴线左右两边均为 <span class=\"math inline\">\\(d\\times d\\)</span> 的正方形。</p>\n<p>若任意两个点同在左边部分或同在右边部分，那么这一对点的贡献已经在分治时计算完成了，所以一定不会比 <span class=\"math inline\">\\(d\\)</span> 小。</p>\n<p>有一个很妙的结论：满足条件的 <span class=\"math inline\">\\(j\\)</span> 在矩形的左半边和右半边最多只有三个。</p>\n<p>为什么？同一部分中，任意两个 <span class=\"math inline\">\\(j\\)</span> 的距离至少为 <span class=\"math inline\">\\(d\\)</span>。那么四个 <span class=\"math inline\">\\(j\\)</span>，距离都为 <span class=\"math inline\">\\(d\\)</span>，那么正好就是整个左半边的正方形。别忘了一点，<span class=\"math inline\">\\(j\\)</span> 需满足的三个条件都是严格小于，所以不能碰到整个矩形的边界，所以一个部分中最多只能存在三个 <span class=\"math inline\">\\(j\\)</span>。</p>\n<p>那么实际上看似 <span class=\"math inline\">\\(n^2\\)</span> 的枚举，在多个优化下就变成了 <span class=\"math inline\">\\(O(n)\\)</span>。再加上对筛选出的点纵坐标排序的时间，总体时间复杂度为 <span class=\"math inline\">\\(O(n\\log^2 n)\\)</span>。</p>\n<details>\n<pre class=\"cpp\"><code>namespace XSC062 &#123;\nusing db = double;\nconst db inf = 1e18;\nconst int maxn = 6e4 + 5;\nstruct _ &#123; db x, y; &#125;;\nint n;\n_ a[maxn];\ndb dis(db x1, db y1, db x2, db y2) &#123;\n    return sqrt((x1 - x2) * (x1 - x2) +\n                (y1 - y2) * (y1 - y2));\n&#125;\ndb min(db x, db y) &#123;\n    return x &lt; y ? x : y;\n&#125;\ndb abs(db x) &#123;\n    return x &gt;= 0 ? x : -x;\n&#125;\ndb Solu(int l, int r) &#123;\n    if (l == r)\n        return inf;\n    if (l + 1 == r)\n        return dis(a[l].x, a[l].y, a[r].x, a[r].y);\n    int mid = (l + r) &gt;&gt; 1;\n    db d = min(Solu(l, mid), Solu(mid + 1, r));\n    std::vector&lt;_&gt; t;\n    for (int i = l; i &lt;= r; ++i) &#123;\n        if (abs(a[i].x - a[mid].x) &lt; d)\n            t.push_back(a[i]);\n    &#125;\n    std::sort(t.begin(), t.end(),\n        [&amp;](_ x, _ y) &#123; return x.y &lt; y.y; &#125;);\n    for (int i = 0; i &lt; (int)t.size(); ++i) &#123;\n        for (int j = i + 1; j &lt; (int)t.size(); ++j) &#123;\n            if (t[j].y - t[i].y &gt;= d)\n                break;\n            d = min(d, dis(t[i].x, t[i].y,\n                                t[j].x, t[j].y));\n        &#125;\n    &#125;\n    return d;\n&#125;\nint main() &#123;\n    scanf(&quot;%d&quot;, &amp;n);\n    for (int i = 1; i &lt;= n; ++i)\n        scanf(&quot;%lf %lf&quot;, &amp;a[i].x, &amp;a[i].y);\n    std::sort(a + 1, a + n + 1,\n        [&amp;](_ x, _ y) &#123; return x.x &lt; y.x; &#125;);\n    printf(&quot;%.2lf\\n&quot;, Solu(1, n) / 2);\n    return 0;\n&#125;\n&#125; // namespace XSC062</code></pre>\n</details>\n<p>考虑一个问题。代码的时间复杂度有两个 <span class=\"math inline\">\\(\\log\\)</span>，这是极不好的（will be fixed）。</p>\n<hr />\n<h3 id=\"g.-残缺棋盘问题\">G. 残缺棋盘问题</h3>\n<p><a href=\"http://222.180.160.110:61235/contest/3416/problem/7\" class=\"uri\">http://222.180.160.110:61235/contest/3416/problem/7</a></p>\n<p>首先考虑一个有趣的问题：<span class=\"math inline\">\\(4^n-1\\)</span> 一定被 <span class=\"math inline\">\\(3\\)</span> 整除吗？</p>\n<p>一个简单的方法是使用数学归纳法进行证明，其思想也会在这道题中体现。</p>\n<p>不过还有另一个方法：<span class=\"math inline\">\\(4^n-1=(3+1)^n-1\\)</span>，使用二项式定理则有：</p>\n<p><span class=\"math display\">\\[\n(3+1)^n-1=\\sum_{i=0}^n {n\\choose i} \\times 3^{n-i}\\times 1^i - 1\n\\]</span></p>\n<p>不难发现除 <span class=\"math inline\">\\(i=n\\)</span> 时，前面每一项都有因子 <span class=\"math inline\">\\(3\\)</span>，而当 <span class=\"math inline\">\\(i=n\\)</span> 时，<span class=\"math inline\">\\({n\\choose n}\\times 3^0\\times 1^n=1\\)</span>，与后面的 <span class=\"math inline\">\\(-1\\)</span> 抵消，故得证。</p>\n<hr />\n<p>考虑将棋盘划分为若干个 <span class=\"math inline\">\\(2\\times 2\\)</span> 的 1 级区域。对于缺口所在的 1 级区域，我们使用一个刚好贴合的三格板将其补齐成为一个完整的 1 级区域。</p>\n<p>我们称包含四个完整的 <span class=\"math inline\">\\(2\\times 2\\)</span> 的 1 级区域的 <span class=\"math inline\">\\(4\\times 4\\)</span> 的区域为 2 级区域，对于包含了我们刚刚补齐的 1 级区域的 2 级区域，我们将最中间的四个格子视为一个 1 级区域并填充，接下来剩余的 3 个完整 1 级区域为各自失去一个能填充的格子，我们选取对应的三格板填充即可。</p>\n<p>对于一个 <span class=\"math inline\">\\(8\\times 8\\)</span> 的 3 级区域，若其包含我们填充完毕的 2 级区域，我们将最中间 <span class=\"math inline\">\\(2\\times 2\\)</span> 的格子视为一个 1 级区域并填充。接下来，剩余的 3 个完整的 2 级区域成为缺失 1 个格子的 2 级区域，按之前的方法填充即可。</p>\n<p>以此类推即可递归地填充完成整个棋盘。但现在又来了一个问题：这道题没有 SPJ。根据样例可知，填充规则是由外到内，中、左上、左下、右上、右下，我们按照此顺序进行分治递归即可。</p>\n<details>\n<pre class=\"cpp\"><code>namespace XSC062 &#123;\nusing namespace fastIO;\nconst int maxn = 105;\nint n, x, y, cnt;\nint t[maxn][maxn];\nvoid getColor(int c, int r, int l, int x, int y) &#123;\n    if (l == 2) &#123;\n        ++cnt;\n        for (int i = c; i &lt;= c + 1; ++i) &#123;\n            for (int j = r; j &lt;= r + 1; ++j) &#123;\n                if (i != x || j != y)\n                    t[i][j] = cnt;\n            &#125;\n        &#125;\n        return;\n    &#125;\n    l /= 2;\n    if (x - c &lt; l) &#123;\n        if (y - r &lt; l) &#123;\n            getColor(c + l - 1, r + l - 1,\n                        2, c + l - 1, r + l - 1);\n            getColor(c, r, l, x, y);\n            getColor(c + l, r, l, c + l, r + l - 1);\n            getColor(c, r + l, l, c + l - 1, r + l);\n            getColor(c + l, r + l, l, c + l, r + l);\n        &#125;\n        else &#123;\n            getColor(c + l - 1, r + l - 1,\n                        2, c + l - 1, r + l);\n            getColor(c, r, l, c + l - 1, r + l - 1);\n            getColor(c + l, r, l, c + l, r + l - 1);\n            getColor(c, r + l, l, x, y);\n            getColor(c + l, r + l, l, c + l, r + l);\n        &#125;\n    &#125;\n    else &#123;\n        if (y - r &lt; l) &#123;\n            getColor(c + l - 1, r + l - 1,\n                            2, c + l, r + l - 1);\n            getColor(c, r, l, c + l - 1, r + l - 1);\n            getColor(c + l, r, l, x, y);\n            getColor(c, r + l, l, c + l - 1, r + l);\n            getColor(c + l, r + l, l, c + l, r + l);\n        &#125;\n        else &#123;\n            getColor(c + l - 1, r + l - 1,\n                            2, c + l, r + l);\n            getColor(c, r, l, c + l - 1, r + l - 1);\n            getColor(c + l, r, l, c + l, r + l - 1);\n            getColor(c, r + l, l, c + l - 1, r + l);\n            getColor(c + l, r + l, l, x, y);\n        &#125;\n    &#125;\n    return;\n&#125;\nint main() &#123;\n    read(n), read(x), read(y);\n    getColor(1, 1, n, x, y);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        for (int j = 1; j &lt;= n; ++j)\n            print(t[i][j], &#39; &#39;);\n        putchar(&#39;\\n&#39;);\n    &#125;\n    return 0;\n&#125;\n&#125; // namespace XSC062</code></pre>\n</details>\n<hr />\n<h3 id=\"h.-tricky-function\">H. Tricky Function</h3>\n<p><a href=\"http://222.180.160.110:61235/contest/3416/problem/8\" class=\"uri\">http://222.180.160.110:61235/contest/3416/problem/8</a></p>\n<p>GM 提示了这道题就是平面最近点对。豁然开朗。</p>\n<p>不妨将 <span class=\"math inline\">\\(i\\)</span> 视作 <span class=\"math inline\">\\(x_i\\)</span>，将 <span class=\"math inline\">\\(\\sum_{k=1}^i a_k\\)</span> 视作 <span class=\"math inline\">\\(y_i\\)</span>，则直接求解平面最近点对即可。</p>\n",
            "tags": [
                "分治"
            ]
        }
    ]
}