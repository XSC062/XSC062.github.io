{
    "version": "https://jsonfeed.org/version/1",
    "title": "null • All posts by \"分治\" tag",
    "description": "",
    "home_page_url": "https://xsc062.netlify.app",
    "items": [
        {
            "id": "https://xsc062.netlify.app/20251028/",
            "url": "https://xsc062.netlify.app/20251028/",
            "title": "杂题",
            "date_published": "2025-10-28T09:06:42.000Z",
            "content_html": "<p>模拟赛的密度正在威胁其他文章的生存环境。</p>\n<span id=\"more\"></span>\n<hr />\n<h2 id=\"a.-排序\">A. 排序</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P14352\" class=\"uri\">https://www.luogu.com.cn/problem/P14352</a></p>\n<blockquote>\n<p>对于一个长度为 <span class=\"math inline\">\\(n\\)</span> 的排列 <span class=\"math inline\">\\(p\\)</span>，定义一轮冒泡：</p>\n<pre class=\"python\"><code>for i in range(1, n):\n    if p[i] &gt; p[i + 1]:\n        swap(p[i], p[i + 1])</code></pre>\n<p>给定 <span class=\"math inline\">\\(n,k\\)</span>，问在所有长度为 <span class=\"math inline\">\\(n\\)</span> 的排列中，可以在 <span class=\"math inline\">\\(k\\)</span> 轮冒泡后单增的排列数量。对 <span class=\"math inline\">\\(998244353\\)</span> 取模。</p>\n<p><span class=\"math inline\">\\(n\\le 10^{18},k\\le 2\\times 10^7\\)</span>。</p>\n</blockquote>\n<ul>\n<li><p>反序表。令 <span class=\"math inline\">\\(a_i\\)</span> 表示 <span class=\"math inline\">\\(i\\)</span> 结尾的逆序对数，那么限制相当于说 <span class=\"math inline\">\\(\\max\\{a\\}\\le k\\)</span>。</p></li>\n<li><p>也即限制一个元素之前大于之的元素数不超过 <span class=\"math inline\">\\(k\\)</span>，可以直接计数。想象把 <span class=\"math inline\">\\(1\\sim n\\)</span> 依次填入排列的过程：</p>\n<ul>\n<li><p>对于 <span class=\"math inline\">\\(1\\sim n-k\\)</span>，只能填在剩余空位的左 <span class=\"math inline\">\\(k+1\\)</span> 个（因为填完它后，剩下的空位都比它大）；</p></li>\n<li><p>对于 <span class=\"math inline\">\\(n-k+1\\sim n\\)</span>，可以填在剩余任意一个空位。</p></li>\n</ul>\n<p>故答案为 <span class=\"math inline\">\\((k+1)^{n-k}\\cdot k!\\)</span>。</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 998244353;\nint main() &#123;\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n    std::freopen(&quot;sorting.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;sorting.out&quot;, &quot;w&quot;, stdout);\n    auto stime = std::chrono::steady_clock::now();\n    long long n;\n    int k;\n    std::cin &gt;&gt; n &gt;&gt; k, k = std::min((long long)k, n);\n    auto qkp = [&amp;](long long x, int y) &#123;\n        auto res = 1ll;\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    auto res = qkp(k + 1, (n - k) % (mod - 1));\n    for (int i = 1; i &lt;= k; ++i)\n        (res *= i) %= mod;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt;(std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s \\n&quot;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"b.-重排\">B. 重排</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P14353\" class=\"uri\">https://www.luogu.com.cn/problem/P14353</a></p>\n<blockquote>\n<p>给定一个初始为空的数组 <span class=\"math inline\">\\(a\\)</span>，再给出 <span class=\"math inline\">\\(n\\)</span> 次加数操作，每次加数后输出：</p>\n<p>任意排列 <span class=\"math inline\">\\(a\\)</span>，得到的 <span class=\"math inline\">\\(\\sum\\limits_{i=2}^n |a_{i+1}-a_{i}|\\)</span> 的最大值。</p>\n<p><span class=\"math inline\">\\(n\\le 3\\times 10^6\\)</span>。</p>\n</blockquote>\n<ul>\n<li><p>显然从小到大排列，答案是后 <span class=\"math inline\">\\(\\left\\lfloor \\dfrac n2\\right\\rfloor\\)</span> 个数的和减去前 <span class=\"math inline\">\\(\\left\\lfloor \\dfrac n2\\right\\rfloor\\)</span> 的和的差的二倍，再减去位于中间 2 / 3 个数中，相邻两个差的最小值。</p>\n<p>这家伙在说什么呢.jpg</p></li>\n<li><p>用大根堆 + 小根堆维护即可，因为 pbds 过不去</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n    std::freopen(&quot;rearrange.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;rearrange.out&quot;, &quot;w&quot;, stdout);\n    auto stime = std::chrono::steady_clock::now();\n    int n, T;\n    std::cin &gt;&gt; n &gt;&gt; T;\n    auto res = 0ll, la = 0ll, sL = 0ll, sR = 0ll;\n    std::priority_queue&lt;int&gt; L;\n    std::priority_queue&lt;int, std::vector&lt;int&gt;, std::greater&lt;int&gt; &gt; R;\n    for (int i = 1, mid = 0; i &lt;= n; ++i) &#123;\n        long long x;\n        std::cin &gt;&gt; x;\n        int b =  T ? x ^ la : x;\n        if (i == 1)\n            mid = b, la = 0ll;\n        else if (i &amp; 1) &#123;\n            if (b &lt; L.top()) &#123;\n                mid = L.top(), sL -= mid;\n                L.pop();\n                sL += b, L.push(b);\n            &#125;\n            else if (b &gt; R.top()) &#123;\n                mid = R.top(), sR -= mid;\n                R.pop();\n                sR += b, R.push(b);\n            &#125;\n            else\n                mid = b;\n            la = 2 * (sR - sL) - std::min(R.top() - mid, mid - L.top());\n        &#125;\n        else &#123;\n            if (b &lt;= mid) &#123;\n                sL += b, sR += mid;\n                L.push(b), R.push(mid);\n            &#125;\n            else &#123;\n                sL += mid, sR += b;\n                L.push(mid), R.push(b);\n            &#125;\n            la = 2 * (sR - sL) - (R.top() - L.top());\n        &#125;\n        res ^= la;\n    &#125;\n    printf(&quot;%lld\\n&quot;, res);\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt;(std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s \\n&quot;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"c.-整式比较-qoj10506.-waga\">C. 整式比较 / qoj#10506. Waga</h2>\n<p><a href=\"https://www.becoder.com.cn/contest/6685/problem/3\" class=\"uri\">https://www.becoder.com.cn/contest/6685/problem/3</a> / <a href=\"https://qoj.ac/problem/10506\" class=\"uri\">https://qoj.ac/problem/10506</a></p>\n<blockquote>\n<p>给定 <span class=\"math inline\">\\(a_{1\\cdots n}\\)</span>，和一个称，如下操作称为一次『称重』：</p>\n<ul>\n<li>选中 <span class=\"math inline\">\\(a\\)</span> 的一个子集，输入给称。记它们的和为 <span class=\"math inline\">\\(s\\)</span>，那么称会返回 <span class=\"math inline\">\\(\\min(k,\\left\\lfloor \\dfrac sc \\right\\rfloor)\\)</span>，其中，<span class=\"math inline\">\\(c\\)</span> 为给定常数。</li>\n</ul>\n<p>现在对于每个无序对 <span class=\"math inline\">\\((i,j)\\)</span>（<span class=\"math inline\">\\(i\\ne j\\)</span>），你需要判断：</p>\n<ul>\n<li>在已知 <span class=\"math inline\">\\(a\\)</span> 中除 <span class=\"math inline\">\\(a_i,a_j\\)</span> 外所有元素值，且 <span class=\"math inline\">\\(a_i,a_j\\)</span> 数值未知的前提下，是否可以通过若干次称重确定 <span class=\"math inline\">\\(a_i,a_j\\)</span> 的大小关系。</li>\n</ul>\n<p><span class=\"math inline\">\\(n,c\\le 8000,k\\le 10^5,1\\le a_i&lt; kc\\)</span>。</p>\n</blockquote>\n<ul>\n<li><p>显然，<span class=\"math inline\">\\(a_i\\)</span> 和 <span class=\"math inline\">\\(a_j\\)</span> 能区分，当且仅当 <span class=\"math inline\">\\(\\left\\lfloor\\dfrac {a_i}c\\right\\rfloor\\ne \\left\\lfloor\\dfrac {a_j}c\\right\\rfloor\\)</span>，或者存在一个其他元素的子集 <span class=\"math inline\">\\(s\\)</span>，使得 <span class=\"math inline\">\\(\\left\\lfloor\\dfrac {a_i+s}c\\right\\rfloor\\ne \\left\\lfloor\\dfrac {a_j + s}c\\right\\rfloor\\)</span>。</p>\n<p>反过来，如果 <span class=\"math inline\">\\(a_i\\)</span> 和 <span class=\"math inline\">\\(a_j\\)</span> 不能区分，一个前提是 <span class=\"math inline\">\\(\\left\\lfloor\\dfrac {a_i}c\\right\\rfloor =\\left\\lfloor\\dfrac {a_j}c\\right\\rfloor\\)</span>。</p></li>\n<li><p>下意识猜要排序，排序后打表发现使 <span class=\"math inline\">\\(i\\)</span> 不合法的 <span class=\"math inline\">\\(j\\)</span> 总是连续的。</p>\n<details>\n<p><summary>证明</summary></p>\n<ol type=\"1\">\n<li><p>需要证：对于 <span class=\"math inline\">\\(x&lt;y&lt;z\\)</span>，若 <span class=\"math inline\">\\(x,y\\)</span> 不可区分，且 <span class=\"math inline\">\\(y,z\\)</span> 不可区分，那么 <span class=\"math inline\">\\(x,z\\)</span> 不可区分。</p>\n<p>记 <span class=\"math inline\">\\(\\left\\lfloor\\dfrac {x}c\\right\\rfloor=\\left\\lfloor\\dfrac {y}c\\right\\rfloor=\\left\\lfloor\\dfrac {z}c\\right\\rfloor=w\\)</span>，不存在 <span class=\"math inline\">\\(s\\le c\\cdot (k-w)\\)</span>，使得 <span class=\"math inline\">\\(y\\)</span> 可以进位但 <span class=\"math inline\">\\(x\\)</span> 不可，也不存在这样的 <span class=\"math inline\">\\(s\\)</span> 使得 <span class=\"math inline\">\\(z\\)</span> 可以进位但 <span class=\"math inline\">\\(y\\)</span> 不可。</p>\n<p>合并不等式容易得到不存在这样的 <span class=\"math inline\">\\(x\\)</span> 使得 <span class=\"math inline\">\\(z\\)</span> 可以进位但 <span class=\"math inline\">\\(x\\)</span> 不可。</p></li>\n<li><p>需要证：对于 <span class=\"math inline\">\\(x&lt;y&lt;z\\)</span>，若 <span class=\"math inline\">\\(x,y\\)</span> 可区分或 <span class=\"math inline\">\\(y,z\\)</span> 可区分，则 <span class=\"math inline\">\\(x,z\\)</span> 可区分。</p>\n<p>调整法易得。</p></li>\n</ol>\n</details></li>\n<li><p>故发现只需要讨论相邻两个元素是否可区分。需要知道所有可能的子集和用于 check，可以用分治预处理『只有某相邻两个元素不选』时的前后缀背包数组（到达某个余数时需要的最小整倍数），就可以 <span class=\"math inline\">\\(O(nc\\log n)\\)</span> 解决问题。</p>\n<p>考虑在做什么：删点在 <span class=\"math inline\">\\([l,mid]\\)</span>，那么 <span class=\"math inline\">\\([mid+1,r]\\)</span> 的 DP 数组不会受到影响；删点在 <span class=\"math inline\">\\([mid + 1, r]\\)</span>，那么 <span class=\"math inline\">\\([l,mid]\\)</span> 的 DP 数组不会受到影响。背包的物品是无顺序的，所以有正确性。</p>\n<p>也就是说大部分信息是可继承的。<em>为什么题解管这个叫 CDQ？是因为普通分治总会被叫 CDQ 吗？</em></p>\n<p>做一个类似 01 背包滚动数组的东西，维护每个点前 / 后可以凑出来的背包值，在最后下传到单点时统计答案即可。</p></li>\n</ul>\n<details>\n<p>相邻两个的处理略显烧脑，但意外地简洁。</p>\n<p><code>&gt;=</code> 不要写成除，不然会慢成唐诗</p>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 8e3 + 5;\nchar nec(void) &#123;\n    static char buf[1 &lt;&lt; 20], *p = buf, *e = buf;\n    if (p == e) &#123;\n        e = buf + fread(buf, 1, 1 &lt;&lt; 20, stdin);\n        p = buf;\n    &#125;\n    return *p++;\n&#125;\nint read(void) &#123;\n    auto x = 0ll;\n    char t = nec();\n    for (; t &lt; &#39;0&#39; || t &gt; &#39;9&#39;; t = nec());\n    for (; t &gt;= &#39;0&#39; &amp;&amp; t &lt;= &#39;9&#39;; t = nec())\n        x = x * 10 + t - &#39;0&#39;;\n    return x;\n&#125;\nint ok[maxn], m, k;\nstd::pair&lt;int, int&gt; a[maxn];\nvoid calc(int l, int r, const std::vector&lt;int&gt; f) &#123;\n    if (l &gt; r)\n        return;\n    if (l == r) &#123;\n        if (a[l].first == a[l + 1].first)\n            ok[l] = 1;\n        else if (a[l].first / m == a[l + 1].first / m)\n            ok[l] = (*std::min_element(f.begin() + m - a[l + 1].first % m, f.begin() + m - a[l].first % m) + a[l].first / m &gt;= k);\n        return;\n    &#125;\n    int mid = (l + r) &gt;&gt; 1;\n    auto g = f;\n    for (int i = mid + 2; i &lt;= r + 1; ++i) &#123;\n        auto h = g;\n        for (int j = 0, k; j &lt; m; ++j) &#123;\n            k = (j + m - a[i].first % m) % m;\n            h[j] = std::min(h[j], g[k] + a[i].first / m + (k + a[i].first % m &gt;= m));\n        &#125;\n        h.swap(g);\n    &#125;\n    calc(l, mid, g);\n    g = f;\n    for (int i = l; i &lt;= mid; ++i) &#123;\n        auto h = g;\n        for (int j = 0, k; j &lt; m; ++j) &#123;\n            k = (j + m - a[i].first % m) % m;\n            h[j] = std::min(h[j], g[k] + a[i].first / m + (k + a[i].first % m &gt;= m));\n        &#125;\n        h.swap(g);\n    &#125;\n    calc(mid + 1, r, g);\n    return;\n&#125;;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n    std::freopen(&quot;intcmp.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;intcmp.out&quot;, &quot;w&quot;, stdout);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n = read();\n    m = read(), k = read();\n    for (int i = 1; i &lt;= n; ++i)\n        a[i].first = read(), a[i].second = i;\n    std::sort(a + 1, a + n + 1);\n    std::vector&lt;int&gt; f(m, 0x3f3f3f3f);\n    f[0] = 0;\n    calc(1, n - 1, f);\n    std::vector&lt;int&gt; resL(n + 1), resR(n + 1);\n    int now = 0;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        resR[a[i].second] = i - 1 - now;\n        if (i != n &amp;&amp; ok[i])\n            ++now;\n        else\n            now = 0;\n    &#125;\n    now = 0;\n    for (int i = n; i; --i) &#123;\n        resL[a[i].second] = n - i - now;\n        if (ok[i - 1])\n            ++now;\n        else\n            now = 0;\n    &#125;\n    for (int i = 1; i &lt;= n; ++i)\n        printf(&quot;%d %d \\n&quot;, resL[i], resR[i]);\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"b.-字符串转换\">B. 字符串转换</h2>\n<p><a href=\"https://www.becoder.com.cn/problem/52055\" class=\"uri\">https://www.becoder.com.cn/problem/52055</a></p>\n<blockquote>\n<p>给定等长 01 串 <span class=\"math inline\">\\(S,T\\)</span>，维护 <span class=\"math inline\">\\(Q\\)</span> 次操作：</p>\n<ul>\n<li>修改：Flip <span class=\"math inline\">\\(S\\)</span> 的某个字符。</li>\n<li>修改：Flip <span class=\"math inline\">\\(T\\)</span> 的某个字符。</li>\n</ul>\n<p>每次操作后，问 <span class=\"math inline\">\\(S\\)</span> 能否通过若干次下列操作变为 <span class=\"math inline\">\\(T\\)</span>：</p>\n<ul>\n<li>选择 <span class=\"math inline\">\\(S\\)</span> 中的一个 <code>00</code>，变为 <code>10</code>。</li>\n<li>选择 <span class=\"math inline\">\\(S\\)</span> 中的一个 <code>11</code>，变为 <code>01</code>。</li>\n</ul>\n<p><span class=\"math inline\">\\(|S|,Q\\le 3\\times 10^5\\)</span>。</p>\n</blockquote>\n<ul>\n<li><p>连续 00 / 11 操作，考虑奇数位取反。取反之后发现原操作等价于 <span class=\"math inline\">\\(a_i\\gets a_{i+1}\\)</span>。</p></li>\n<li><p>这个操作只会使连续段的数量减少，故要求每一个后缀，<span class=\"math inline\">\\(S\\)</span> 的连续段个数不少于 <span class=\"math inline\">\\(T\\)</span> 的连续段个数，而且二者结尾相同。</p>\n<p>线段树维护即可。</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 3e5 + 5;\nstruct &#123; int l, r, mn, d; &#125; t[maxn &lt;&lt; 2];\n#define lt (p &lt;&lt; 1)\n#define rt (lt | 1)\nvoid bld(int p, int l, int r) &#123;\n    t[p].l = l, t[p].r = r;\n    t[p].mn = t[p].d = 0;\n    if (l == r)\n        return;\n    int mid = (l + r) &gt;&gt; 1;\n    bld(lt, l, mid), bld(rt, mid + 1, r);\n    return;\n&#125;\nvoid pushdown(int p) &#123;\n    if (t[p].d) &#123;\n        t[lt].mn += t[p].d, t[lt].d += t[p].d;\n        t[rt].mn += t[p].d, t[rt].d += t[p].d;\n        t[p].d = 0;\n    &#125;\n    return;\n&#125;\nvoid add(int p, int l, int r, int v) &#123;\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r) &#123;\n        t[p].mn += v, t[p].d += v;\n        return;\n    &#125;\n    pushdown(p);\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (l &lt;= mid)\n        add(lt, l, r, v);\n    if (r &gt; mid)\n        add(rt, l, r, v);\n    t[p].mn = std::min(t[lt].mn, t[rt].mn);\n    return;\n&#125;\n#undef lt\n#undef rt\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n    std::freopen(&quot;string.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;string.out&quot;, &quot;w&quot;, stdout);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int T;\n    for (std::cin &gt;&gt; T; T--; ) &#123;\n        int n, q;\n        std::cin &gt;&gt; n &gt;&gt; q;\n        std::vector&lt;int&gt; a(n + 1), b(n + 1);\n        bld(1, 1, n);\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            char t;\n            std::cin &gt;&gt; t, a[i] = (t == &#39;B&#39;);\n            if (i &amp; 1)\n                a[i] ^= 1;\n        &#125;\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            char t;\n            std::cin &gt;&gt; t, b[i] = (t == &#39;B&#39;);\n            if (i &amp; 1)\n                b[i] ^= 1;\n        &#125;\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            int v = 0;\n            v += (i == n || a[i] != a[i + 1]);\n            v -= (i == n || b[i] != b[i + 1]);\n            if (v)\n                add(1, 1, i, v);\n        &#125;\n        for (char op; q--; ) &#123;\n            int i;\n            std::cin &gt;&gt; op &gt;&gt; i;\n            if (op == &#39;X&#39;) &#123;\n                int v = 0, v1 = 0;\n                v -= (i == n || a[i] != a[i + 1]);\n                v1 -= (i != 1 &amp;&amp; a[i] != a[i - 1]);\n                a[i] ^= 1;\n                v += (i == n || a[i] != a[i + 1]);\n                v1 += (i != 1 &amp;&amp; a[i] != a[i - 1]);\n                if (v)\n                    add(1, 1, i, v);\n                if (v1)\n                    add(1, 1, i - 1, v1);\n            &#125;\n            else &#123;\n                int v = 0, v1 = 0;\n                v += (i == n || b[i] != b[i + 1]);\n                v1 += (i != 1 &amp;&amp; b[i] != b[i - 1]);\n                b[i] ^= 1;\n                v -= (i == n || b[i] != b[i + 1]);\n                v1 -= (i != 1 &amp;&amp; b[i] != b[i - 1]);\n                if (v)\n                    add(1, 1, i, v);\n                if (v1)\n                    add(1, 1, i - 1, v1);\n            &#125;\n            std::cout &lt;&lt; ((a[n] == b[n] &amp;&amp; t[1].mn &gt;= 0) ? &quot;YES&quot; : &quot;NO&quot;) &lt;&lt; &#39;\\n&#39;;\n        &#125;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"c.-监控\">C. 监控</h2>\n<p><a href=\"https://www.becoder.com.cn/problem/52057\" class=\"uri\">https://www.becoder.com.cn/problem/52057</a></p>\n<blockquote>\n<p>给定 <span class=\"math inline\">\\(n\\)</span> 个怪，每个怪有 <span class=\"math inline\">\\(B_i\\)</span> 滴血，也就是说每个怪能被打 <span class=\"math inline\">\\(\\le B_i\\)</span> 次。</p>\n<p>要求每个怪必须被打 <span class=\"math inline\">\\(\\ge A_i\\)</span> 次，并认为被打恰好 <span class=\"math inline\">\\(A_i\\)</span> 次时这个怪是好的。</p>\n<p>对于每个 <span class=\"math inline\">\\(1\\le x\\le \\sum B_i\\)</span>，求：在攻击次数只能为 <span class=\"math inline\">\\(x\\)</span> 的倍数的前提下，不好的怪的最小值。你只需要输出答案的和。</p>\n<p><span class=\"math inline\">\\(N\\le 10^5,1\\le A_i&lt; B_i\\le 10^5\\)</span>。</p>\n</blockquote>\n<ul>\n<li><p>记 <span class=\"math inline\">\\(c_i=B_i-A_i\\)</span>，把 <span class=\"math inline\">\\(c_i\\)</span> 降序排列，记 <span class=\"math inline\">\\(s=\\sum A_i\\)</span>，那么一个 <span class=\"math inline\">\\(x\\)</span> 的答案为：</p>\n<p><span class=\"math display\">\\[\n\\min\\left\\{i\\mid{\\left\\lceil \\frac{s}x \\right\\rceil\\cdot x - s\\ge c_i}\\right\\}\n\\]</span></p></li>\n<li><p>容易想到整除分块，枚举 <span class=\"math inline\">\\(\\left\\lceil \\dfrac{s}x \\right\\rceil\\)</span> 的值 <span class=\"math inline\">\\(k\\)</span>，那么相当于想要找到 <span class=\"math inline\">\\([L_i,R_i]\\)</span> 中的每个 <span class=\"math inline\">\\(x\\)</span>，<span class=\"math inline\">\\(x\\cdot k-s\\)</span> 会落在哪个 <span class=\"math inline\">\\(c\\)</span> 的管辖范围里。</p>\n<p>不妨记 <span class=\"math inline\">\\(c_i\\)</span> 的管辖范围为 <span class=\"math inline\">\\([cL_i,cR_i]\\)</span>，那么转化为 <span class=\"math inline\">\\(x\\cdot k-s\\in [cL_i,cR_i]\\)</span>，枚举 <span class=\"math inline\">\\(c\\)</span> 解不等式即可。</p></li>\n<li><p>但发现一个严重的问题：外层整除分块复杂度是 <span class=\"math inline\">\\(\\sqrt(s)\\)</span> 的，最劣 <span class=\"math inline\">\\(10^5\\)</span> 级别，很坏了。</p>\n<p>发现枚举商数劣的原因是使 <span class=\"math inline\">\\(\\left\\lceil \\dfrac{s}x \\right\\rceil\\)</span> 很大的 <span class=\"math inline\">\\(x\\)</span> 并不多，却占用了很多枚举次数</p>\n<p>如果做经典的整除分块同样会发现到后期块内元素远远少于 <span class=\"math inline\">\\(n\\)</span>，却要花费 <span class=\"math inline\">\\(n\\)</span> 次操作来处理它们。所以对于这部分数我们直接朴素二分。</p></li>\n<li><p>取阈值为 1500 即可。</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int B = 1500;\nconst long long inf = 1e18;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;long long&gt; c(n + 1);\n    auto sa = 0ll, sb = 0ll;\n    for (int i = 1, a, b; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; a &gt;&gt; b;\n        sa += a, sb += b, c[i] = b - a;\n    &#125;\n    std::sort(c.begin() + 1, c.end(), std::greater&lt;int&gt; ());\n    std::partial_sum(c.begin() + 1, c.end(), c.begin() + 1);\n    auto L = sb + 1;\n    std::stack&lt;std::pair&lt;long long, int&gt; &gt; st;\n    for (int k = 1; k &lt;= 1500; ++k) &#123;\n        auto l = (sa + k - 1) / k, r = L - 1;\n        if (l &gt; r)\n            continue;\n        L = l;\n        st.emplace(r, n + 1);\n        for (int i = n; ~i; --i)\n            st.emplace(std::min(r, (c[i] + sa) / k), i);\n    &#125;\n    for (int i = L - 1; i; --i)\n        st.emplace(i, std::lower_bound(c.begin(), c.end(), ((sa + i - 1) / i) * i - sa) - c.begin());\n    auto res = 0ll;\n    for (auto l = 1ll; !st.empty(); ) &#123;\n        auto [r, v] = st.top();\n        st.pop();\n        if (l &gt; r)\n            continue;\n        if (v == n + 1)\n            v = 0;\n        res += (r - l + 1) * v;\n        l = r + 1;\n    &#125;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"g---range-set-modifying-query\">G - Range Set Modifying Query</h2>\n<p><a href=\"https://atcoder.jp/contests/abc430/tasks/abc430_g\" class=\"uri\">https://atcoder.jp/contests/abc430/tasks/abc430_g</a></p>\n<ul>\n<li><p>发现开 60 个线段树非常合理</p></li>\n<li><p>接着发现是 beats 板子题。看似需要三只 log，其实只有两只。</p></li>\n<li><p>参见 abc426，最近 abc 都喜欢 beats 板子题吗？</p></li>\n</ul>\n",
            "tags": [
                "分治",
                "分块",
                "背包"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20250520/",
            "url": "https://xsc062.netlify.app/20250520/",
            "title": "杂题",
            "date_published": "2025-05-20T14:22:43.000Z",
            "content_html": "<p>manual 是 anual 的 m 词形式（胡言乱语）</p>\n<p>Everyone is potential. （每个人都是蛋白质。）</p>\n<span id=\"more\"></span>\n<hr />\n<h2 id=\"cf2043e-matrix-transformation\">CF2043E Matrix Transformation</h2>\n<p><a href=\"https://codeforces.com/problemset/problem/2043/E\" class=\"uri\">https://codeforces.com/problemset/problem/2043/E</a></p>\n<blockquote>\n<p>给定 <span class=\"math inline\">\\(n\\times m\\)</span> 的 <span class=\"math inline\">\\(01\\)</span> 矩阵 <span class=\"math inline\">\\(A,B\\)</span>，可任意将 <span class=\"math inline\">\\(A\\)</span> 的一行置为 <span class=\"math inline\">\\(0\\)</span> 或一列置为 <span class=\"math inline\">\\(1\\)</span>，问是否能将 <span class=\"math inline\">\\(A\\)</span> 变成 <span class=\"math inline\">\\(B\\)</span>。</p>\n</blockquote>\n<p>发现如果 <span class=\"math inline\">\\(B\\)</span> 的某一行是 <span class=\"math inline\">\\(0\\)</span>，那么不管 <span class=\"math inline\">\\(A\\)</span> 这一行是什么东西都可以通过一次操作让这一行满足条件（当然，要求这步操作最后进行）。列也是相似的。</p>\n<p>那么就有一个撤销的思路，从 <span class=\"math inline\">\\(B\\)</span> 中不断删除全 <span class=\"math inline\">\\(0\\)</span> 行或全 <span class=\"math inline\">\\(1\\)</span> 列，不能删了就对比二者剩下的部分是否全等（因为此时任何操作都是非法的）。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int T;\n    for (std::cin &gt;&gt; T; T--; ) &#123;\n        int n, m;\n        std::cin &gt;&gt; n &gt;&gt; m;\n        using arr = std::vector&lt;int&gt;;\n        using brr = std::vector&lt;arr&gt;;\n        using crr = std::vector&lt;brr&gt;;\n        brr cn(31, arr(n + 1)), cm(31, arr(m + 1));\n        crr a(31, brr(n + 1, arr(m + 1))), b(31, brr(n + 1, arr(m + 1)));\n        for (int i = 1; i &lt;= n; ++i)\n            for (int j = 1, x; j &lt;= m; ++j) &#123;\n                std::cin &gt;&gt; x;\n                for (int k = 0; k &lt; 31; ++k)\n                    a[k][i][j] = (x &gt;&gt; k) &amp; 1;\n            &#125;\n        for (int i = 1; i &lt;= n; ++i)\n            for (int j = 1, x; j &lt;= m; ++j) &#123;\n                std::cin &gt;&gt; x;\n                for (int k = 0; k &lt; 31; ++k) &#123;\n                    b[k][i][j] = (x &gt;&gt; k) &amp; 1;\n                    cn[k][i] += b[k][i][j];\n                    cm[k][j] += !b[k][i][j];\n                &#125;\n            &#125;\n        for (int k = 0; k &lt; 31; ++k) &#123;\n            std::queue&lt;int&gt; qn, qm;\n            std::vector&lt;int&gt; tn(n + 1, 1), tm(m + 1, 1);\n            for (int i = 1; i &lt;= n; ++i)\n                if (!cn[k][i])\n                    tn[i] = 0, qn.push(i);\n            for (int j = 1; j &lt;= m; ++j)\n                if (!cm[k][j])\n                    tm[j] = 0, qm.push(j);\n            for (; !qn.empty() || !qm.empty(); ) &#123;\n                if (!qn.empty()) &#123;\n                    int i = qn.front();\n                    // printf(&quot;delete line %d\\n&quot;, i);\n                    qn.pop();\n                    for (int j = 1; j &lt;= m; ++j)\n                        if (!b[k][i][j] &amp;&amp; !--cm[k][j])\n                            tm[j] = 0, qm.push(j);\n                &#125;\n                else &#123;\n                    int j = qm.front();\n                    // printf(&quot;delete column %d\\n&quot;, j);\n                    qm.pop();\n                    for (int i = 1; i &lt;= n; ++i)\n                        if (b[k][i][j] &amp;&amp; !--cn[k][i])\n                            tn[i] = 0, qn.push(i);\n                &#125;\n            &#125;\n            for (int i = 1; i &lt;= n; ++i)\n                if (tn[i])\n                    for (int j = 1; j &lt;= m; ++j)\n                        if (tm[j] &amp;&amp; a[k][i][j] != b[k][i][j]) &#123;\n                            // printf(&quot;k = %d: (%d, %d)\\n&quot;, k, i, j);\n                            goto nosol;\n                        &#125;\n        &#125;\n        std::cout &lt;&lt; &quot;Yes\\n&quot;;\n        continue;\n    nosol :\n        std::cout &lt;&lt; &quot;No\\n&quot;;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"cf2043f-nim\">CF2043F Nim</h2>\n<p><a href=\"https://codeforces.com/contest/2043/problem/F\" class=\"uri\">https://codeforces.com/contest/2043/problem/F</a></p>\n<blockquote>\n<p>给定 <span class=\"math inline\">\\(m\\)</span> 次询问，每次问从 <span class=\"math inline\">\\(a_l\\sim a_r\\)</span> 选非空子序列使得异或和为 <span class=\"math inline\">\\(0\\)</span>，问子序列最小长度、该前提下的方案数。</p>\n</blockquote>\n<p>发现子序列问题可以等价为背包；背包可以合并（即把整区间拆成若干段后，两两信息可以合并）；<a href=\"/20231117/#关于背包\">背包可以放在分治上</a>；</p>\n<p>由此，把询问离线下来放在 <span class=\"math inline\">\\(a_{1\\sim n}\\)</span> 的分治上，每次只处理在 <span class=\"math inline\">\\([l,r]\\)</span> 间且跨越 <span class=\"math inline\">\\(mid\\)</span> 的询问就可以得到答案。复杂度 <span class=\"math inline\">\\(O(n\\cdot v^2\\log n)\\)</span>。</p>\n<details>\n<p>不要用方案数是否为 <span class=\"math inline\">\\(0\\)</span> 来判断是否无解！因为方案数可能是 <span class=\"math inline\">\\(998244353\\)</span> 的倍数……</p>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int siz = 63;\nconst int mod = 998244353;\nconst int inf = 0x3f3f3f3f;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, m;\n    std::cin &gt;&gt; n &gt;&gt; m;\n    std::vector&lt;int&gt; a(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i];\n    struct _ &#123; int l, r, id; &#125;;\n    std::vector&lt;_&gt; q(m + 1);\n    std::vector&lt;std::pair&lt;int, long long&gt; &gt; res(m + 1, &#123; inf, 0ll &#125;);\n    for (int i = 1; i &lt;= m; ++i) &#123;\n        std::cin &gt;&gt; q[i].l &gt;&gt; q[i].r;\n        q[i].id = i;\n    &#125;\n    std::function&lt;void(int, int, std::vector&lt;_&gt; &amp;q)&gt; calc = [&amp;](int l, int r, std::vector&lt;_&gt; &amp;q) &#123;\n        if (l == r) &#123;\n            for (auto [l, r, id] : q)\n                if (a[l] == 0)\n                    res[id] = &#123; 0, 1ll &#125;;\n            return;\n        &#125;\n        int mid = (l + r) &gt;&gt; 1;\n        std::vector&lt;_&gt; ql, qr, qm;\n        for (; !q.empty(); q.pop_back()) &#123;\n            if (q.back().r &lt;= mid)\n                ql.push_back(std::move(q.back()));\n            else if (q.back().l &gt; mid)\n                qr.push_back(std::move(q.back()));\n            else\n                qm.push_back(std::move(q.back()));\n        &#125;\n        calc(l, mid, ql), calc(mid + 1, r, qr);\n        std::vector&lt;std::vector&lt;int&gt; &gt; f(r - l + 1, std::vector&lt;int&gt; (siz + 1, inf));\n        std::vector&lt;std::vector&lt;long long&gt; &gt; g(r - l + 1, std::vector&lt;long long&gt; (siz + 1));\n        f[mid - l][a[mid]] = 1ll, g[mid - l][a[mid]] = 1ll;\n        for (int i = mid - l - 1; ~i; --i) &#123;\n            int k = a[i + l];\n            f[i] = f[i + 1], g[i] = g[i + 1];\n            if (f[i][k] == 1)\n                (++g[i][k]) %= mod;\n            else\n                f[i][k] = 1, g[i][k] = 1ll;\n            for (int j = 0, k = a[i + l]; j &lt;= siz; ++j)\n                if (f[i + 1][j ^ k] + 1 &lt; f[i][j])\n                    f[i][j] = f[i + 1][j ^ k] + 1, g[i][j] = g[i + 1][j ^ k];\n                else if (f[i + 1][j ^ k] + 1 == f[i][j])\n                    (g[i][j] += g[i + 1][j ^ k]) %= mod;\n        &#125;\n        f[mid - l + 1][a[mid + 1]] = 1ll, g[mid - l + 1][a[mid + 1]] = 1ll;\n        for (int i = mid - l + 2; i &lt;= r - l; ++i) &#123;\n            int k = a[i + l];\n            f[i] = f[i - 1], g[i] = g[i - 1];\n            if (f[i][k] == 1)\n                (++g[i][k]) %= mod;\n            else\n                f[i][k] = 1, g[i][k] = 1ll;\n            for (int j = 0; j &lt;= siz; ++j)\n                if (f[i - 1][j ^ k] + 1 &lt; f[i][j])\n                    f[i][j] = f[i - 1][j ^ k] + 1, g[i][j] = g[i - 1][j ^ k];\n                else if (f[i - 1][j ^ k] + 1 == f[i][j])\n                    (g[i][j] += g[i - 1][j ^ k]) %= mod;\n        &#125;\n        for (auto [ql, qr, id] : qm) &#123;\n            // printf(&quot;at [%d, %d], mid = %d: ASK [%d, %d]: \\n&quot;, l, r, mid, ql, qr);\n            ql -= l, qr -= l;\n            if (f[ql][0] &lt; inf)\n                res[id].first = f[ql][0], res[id].second = g[ql][0];\n            if (f[qr][0] &lt; res[id].first)\n                res[id].first = f[qr][0], res[id].second = g[qr][0];\n            else if (f[qr][0] == res[id].first)\n                (res[id].second += g[qr][0]) %= mod;\n            for (int i = 1; i &lt;= siz; ++i) &#123;\n                // printf(&quot;  %d[%d]: %d(%lld)  |  %d[%d]: %d(%lld)\\n&quot;, ql + l, i, f[ql][i], g[ql][i], qr + l, i, f[qr][i], g[qr][i]);\n                if (f[ql][i] + f[qr][i] &lt; res[id].first)\n                    res[id].first = f[ql][i] + f[qr][i], res[id].second = g[ql][i] * g[qr][i] % mod;\n                else if (f[ql][i] + f[qr][i] == res[id].first)\n                    (res[id].second += g[ql][i] * g[qr][i]) %= mod;\n            &#125;\n            if (res[id].first &lt; inf)\n                res[id].first = (qr - ql + 1) - res[id].first;\n        &#125;\n        return;\n    &#125;;\n    calc(1, n, q);\n    for (int i = 1; i &lt;= m; ++i)\n        if (res[i].first &lt; inf)\n            std::cout &lt;&lt; res[i].first &lt;&lt; &#39; &#39; &lt;&lt; res[i].second &lt;&lt; &#39;\\n&#39;;\n        else\n            std::cout &lt;&lt; -1 &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"贪玩蓝月\">贪玩蓝月</h2>\n<p><a href=\"https://loj.ac/p/6515\" class=\"uri\">https://loj.ac/p/6515</a></p>\n<p><em>差不多的题：<a href=\"https://atcoder.jp/contests/jag2018summer-day2/tasks/jag2018summer_day2_d\" class=\"uri\">https://atcoder.jp/contests/jag2018summer-day2/tasks/jag2018summer_day2_d</a>，注意加入是按体积单增的</em></p>\n<p>发现断点确定时可以背包 <span class=\"math inline\">\\(O(p)\\)</span> 维护插入删除；使用 <a href=\"/20231117/#双栈模拟双端队列\">双栈模拟双端队列</a> 就可以均摊 <span class=\"math inline\">\\(O(pm)\\)</span> 实现插入删除。</p>\n<p>对于询问，当然可以 <span class=\"math inline\">\\(O(p^2)\\)</span> 枚举最值再枚举方案（即枚举一端的贡献）；但复杂度不太美观。考虑倒过来，先 <span class=\"math inline\">\\(O(v)\\)</span> 枚举一端贡献，再枚举『能凑出 <span class=\"math inline\">\\([l,r]\\)</span> 中的值』的另一端的贡献。这样就发现我们是在求区间最大值；每次询问时构建 ST 表预处理另一端的区间最大值即可。</p>\n<p>复杂度 <span class=\"math inline\">\\(O(mq\\log q)\\)</span>。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst long long inf = 1e18;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int m, mod;\n    std::cin &gt;&gt; m &gt;&gt; m &gt;&gt; mod;\n    std::array&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt;, 2&gt; T;\n    std::array&lt;std::vector&lt;std::vector&lt;long long&gt; &gt;, 2&gt; F;\n    F[0].emplace_back(mod, -inf), F[1].emplace_back(mod, -inf);\n    F[0][0][0] = 0ll, F[1][0][0] = 0ll;\n    for (; m--; ) &#123;\n        std::string op;\n        std::cin &gt;&gt; op;\n        if (op[0] == &#39;I&#39;) &#123;\n            int v, w;\n            std::cin &gt;&gt; v &gt;&gt; w, v %= mod;\n            auto &amp;t = T[op[1] == &#39;G&#39;];\n            auto &amp;f = F[op[1] == &#39;G&#39;];\n            t.emplace_back(v, w);\n            f.emplace_back(f.back());\n            for (int i = (int)f.size() - 1, j = 0; j &lt; mod; ++j)\n                if (f[i - 1][(j + mod - v) % mod] + w &gt; f[i][j])\n                    f[i][j] = f[i - 1][(j + mod - v) % mod] + w;\n        &#125;\n        else if (op[0] == &#39;D&#39;) &#123;\n            auto &amp;t0 = T[op[1] == &#39;G&#39;], &amp;t1 = T[op[1] == &#39;F&#39;];\n            auto &amp;f0 = F[op[1] == &#39;G&#39;], &amp;f1 = F[op[1] == &#39;F&#39;];\n            if (t0.empty()) &#123;\n                t1.erase(t1.begin());\n                int to = t1.size() / 2;\n                std::vector&lt;std::pair&lt;int, int&gt; &gt; (t1.begin(), t1.begin() + to).swap(t0);\n                std::reverse(t0.begin(), t0.end());\n                std::vector&lt;std::pair&lt;int, int&gt; &gt; (t1.begin() + to, t1.end()).swap(t1);\n                f0.resize(1), f1.resize(1);\n                for (auto [v, w] : t0) &#123;\n                    f0.emplace_back(f0.back());\n                    for (int i = (int)f0.size() - 1, j = 0; j &lt; mod; ++j)\n                        if (f0[i - 1][(j + mod - v) % mod] + w &gt; f0[i][j])\n                            f0[i][j] = f0[i - 1][(j + mod - v) % mod] + w;\n                &#125;\n                for (auto [v, w] : t1) &#123;\n                    f1.emplace_back(f1.back());\n                    for (int i = (int)f1.size() - 1, j = 0; j &lt; mod; ++j)\n                        if (f1[i - 1][(j + mod - v) % mod] + w &gt; f1[i][j])\n                            f1[i][j] = f1[i - 1][(j + mod - v) % mod] + w;\n                &#125;\n            &#125;\n            else\n                t0.pop_back(), f0.pop_back();\n        &#125;\n        else &#123;\n            int l, r;\n            std::cin &gt;&gt; l &gt;&gt; r;\n            auto res(-inf);\n            std::vector&lt;std::vector&lt;long long&gt; &gt; st(std::__lg(mod) + 1, std::vector&lt;long long&gt; (mod + 1));\n            st[0] = F[1].back();\n            for (int j = 1; (1 &lt;&lt; j) &lt;= mod; ++j)\n                for (int i = 0; i + (1 &lt;&lt; j) - 1 &lt; mod; ++i)\n                    st[j][i] = std::max(st[j - 1][i], st[j - 1][i + (1 &lt;&lt; (j - 1))]);\n            auto ask = [&amp;](int l, int r) &#123;\n                int k = std::__lg(r - l + 1);\n                return std::max(st[k][l], st[k][r - (1 &lt;&lt; k) + 1]);\n            &#125;;\n            for (int j = 0; j &lt; mod; ++j)\n                if (j &lt;= l)\n                    res = std::max(res, F[0].back()[j] + ask(l - j, r - j));\n                else if (l &lt; j &amp;&amp; j &lt;= r)\n                    res = std::max(&#123; res, F[0].back()[j] + ask(0, r - j), F[0].back()[j] + ask(l + mod - j, mod - 1) &#125;);\n                else\n                    res = std::max(res, F[0].back()[j] + ask(l + mod - j, r + mod - j));\n            std::cout &lt;&lt; std::max(-1ll, res) &lt;&lt; &#39;\\n&#39;;\n        &#125;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"apio2025-转杆\">APIO2025 转杆</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P12543\" class=\"uri\">https://www.luogu.com.cn/problem/P12543</a></p>\n<p><del>总有一天我要让全天下的数学题 DP 题字符串题图论题模拟题数据结构题思维题全部消失</del></p>\n<p>不要把它转化成序列问题来考虑！这对观察到结论没有好处！</p>\n<p>考虑 <span class=\"math inline\">\\(n=2\\)</span> 的情况，当且仅当垂直时最优。<span class=\"math inline\">\\(n=3\\)</span> 时，随便固定其中一条线，发现剩下两条线如果夹角固定，则代价固定；当夹角取 <span class=\"math inline\">\\(90^{\\circ}\\)</span> 时最优。</p>\n<p>于是猜是不是任意一对都要垂直。考虑数归，当前 <span class=\"math inline\">\\(2n\\)</span> 对 <del>不知道怎么摆的，反正就是</del> 最优时：</p>\n<ul>\n<li>考虑加入第 <span class=\"math inline\">\\(2n+1\\)</span> 条；参照 <span class=\"math inline\">\\(n=3\\)</span> 的情形，把前 <span class=\"math inline\">\\(2n\\)</span> 条任意两两配对，则第 <span class=\"math inline\">\\(2n+1\\)</span> 的位置对代价没有任何影响。</li>\n<li>考虑加入第 <span class=\"math inline\">\\(2n+2\\)</span> 条；相似地，它的位置对前 <span class=\"math inline\">\\(2n\\)</span> 条没有任何影响；故需要最大化它和第 <span class=\"math inline\">\\(2n+1\\)</span> 条的贡献。取垂直即可。</li>\n</ul>\n<p>因此得到任意一对都要垂直。具体怎么调整呢？首先下意识排序；配对方式即将 <span class=\"math inline\">\\(i\\)</span> 与 <span class=\"math inline\">\\(\\dfrac i+\\lfloor \\frac n2\\rfloor\\)</span> 配对；因为能感受到这样影响的线段最少。严谨的证明好像没看到。</p>\n<details>\n<pre class=\"cpp\"><code>#include&lt;bits/stdc++.h&gt;\nvoid energy(int, std::vector&lt;int&gt;);\nvoid rotate(std::vector&lt;int&gt;, int);\nvoid energy(int n, std::vector&lt;int&gt; a) &#123;\n    std::vector&lt;int&gt; id(n);\n    std::iota(id.begin(), id.end(), 0);\n    std::sort(id.begin(), id.end(), [&amp;](int x, int y) &#123; return a[x] &lt; a[y]; &#125;);\n    for (int i = 0, j = n / 2; i &lt; n / 2; ++i, ++j)\n        rotate(&#123; id[j] &#125;, (a[id[i]] + 75000 - a[id[j]]) % 50000);\n    return;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"abc407e-most-valuable-parentheses\">ABC407E Most Valuable Parentheses</h2>\n<p><a href=\"https://atcoder.jp/contests/abc407/tasks/abc407_e\" class=\"uri\">https://atcoder.jp/contests/abc407/tasks/abc407_e</a></p>\n<p>这里有一个很典（可惜我不知道）的 trick：<a href=\"/20231117/#贪心选取括号序列\">贪心构造最优括号序列</a>。</p>\n<p>用优先队列维护，贪心选即可。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int T;\n    for (std::cin &gt;&gt; T; T--; ) &#123;\n        int n;\n        std::cin &gt;&gt; n;\n        std::vector&lt;int&gt; a(2 * n + 1);\n        for (int i = 1; i &lt;= 2 * n; ++i)\n            std::cin &gt;&gt; a[i];\n        long long res = a[1];\n        std::priority_queue&lt;int&gt; q;\n        for (int i = 2; i &lt; 2 * n; i += 2) &#123;\n            q.push(a[i]), q.push(a[i + 1]);\n            res += q.top(), q.pop();\n        &#125;\n        std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n",
            "tags": [
                "分治",
                "背包"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20241017/",
            "url": "https://xsc062.netlify.app/20241017/",
            "title": "模拟赛",
            "date_published": "2024-10-16T12:32:34.000Z",
            "content_html": "<p>好消息：会简单数学题 <img src=\"/em/dy.gif\" /></p>\n<p>更好的消息：忘取模了 <img src=\"/em/dy.gif\" /></p>\n<span id=\"more\"></span>\n<hr />\n<h3 id=\"a.-distorted\">A. distorted</h3>\n<p><a href=\"https://www.becoder.com.cn/contest/5611/problem/1\" class=\"uri\">https://www.becoder.com.cn/contest/5611/problem/1</a></p>\n<p>考虑最多需要多少个元素。最坏情况是选取四个角的元素，已经可以覆盖整个矩阵。进一步考虑感性反证发现无论如何都选不出来五个，故最多选择四个。</p>\n<p>我们发现，选取中间一个就可以覆盖整个矩阵。扩展一下，选择中间列就可以覆盖上 / 下半个矩阵，选择中间行就可以覆盖左 / 右半个矩阵。剩下的选择过后只能保证照顾到对应的 1/4 矩阵且一定不会完全覆盖其他的 1/4 矩阵。</p>\n<p>我们发现，中心元素地位高于中间行 / 列元素高于左上、左下、右上、右下元素。由此出发讨论选择元素的个数。</p>\n<ul>\n<li>1 个：选择中心元素。</li>\n<li>2 个：在中间行的左右两边各选一个 / 在中间列的上下两边各选一个。</li>\n<li>3 个：选一个中间行 / 列 + 两个其他元素，或两个中间行 / 列 + 一个其他元素。</li>\n<li>4 个：左上、左下、右上、右下各选一个。</li>\n</ul>\n<p>统计各个方向的最小值，选最小组合即可。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\n#define putchar\nconst long long inf = 0x3f3f3f3f;\nint main() &#123;\n    freopen(&quot;distorted.in&quot;, &quot;r&quot;, stdin);\n    freopen(&quot;distorted.out&quot;, &quot;w&quot;, stdout);\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n    int T;\n    for (std::cin &gt;&gt; T; T--; ) &#123;\n        int n;\n        std::cin &gt;&gt; n;\n        long long to = inf, u = inf, d = inf, l = inf, r = inf, q = inf, z = inf, p = inf, m = inf;\n        for (int i = 1; i &lt;= n; ++i)\n            for (int j = 1; j &lt;= n; ++j) &#123;\n                long long x;\n                std::cin &gt;&gt; x;\n                if (i * 2 - 1 == n &amp;&amp; j * 2 - 1 == n)\n                    to = x;\n                else if (i * 2 - 1 == n &amp;&amp; j * 2 - 1 &lt; n)\n                    l = std::min(l, x);\n                else if (i * 2 - 1 == n)\n                    r = std::min(r, x);\n                else if (i * 2 - 1 &lt; n &amp;&amp; j * 2 - 1 == n)\n                    u = std::min(u, x);\n                else if (j * 2 - 1 == n)\n                    d = std::min(d, x);\n                else if (i * 2 - 1 &lt; n &amp;&amp; j * 2 - 1 &lt; n)\n                    q = std::min(q, x);\n                else if (i * 2 - 1 &lt; n)\n                    p = std::min(p, x);\n                else if (j * 2 - 1 &lt; n)\n                    z = std::min(z, x);\n                else\n                    m = std::min(m, x);\n            &#125;\n        std::cout &lt;&lt; std::min(&#123; to, l + r, u + d, l + u + m, l + d + p, r + u + z, r + d + q, u + z + m, d + q + p, l + p + m, r + q + z, q + p + z + m &#125;) &lt;&lt; &#39;\\n&#39;;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"b.-fate\">B. fate</h3>\n<p><a href=\"https://www.becoder.com.cn/contest/5611/problem/2\" class=\"uri\">https://www.becoder.com.cn/contest/5611/problem/2</a></p>\n<p>诈骗题。对于前半段，考虑取差分数组 <span class=\"math inline\">\\(d\\)</span>，容易发现如果直接在差分数组上做减法，一定满足后面减得不比前面少。故只要满足差分数组每一项至少为 <span class=\"math inline\">\\(0\\)</span> 即可，答案为 <span class=\"math inline\">\\(\\prod {i\\le p} a_i - a_{i-1} + 1\\)</span>。</p>\n<p>对于后半段，我们考虑转化成和前半段相似的问题，将后半段翻转，同样取差分数组，则此时在该差分数组上满足后面减得不比前面少，同时需要满足差分数组每一项至多为 <span class=\"math inline\">\\(0\\)</span>，前面的所有项初始为负，操作为减，自然满足；但第 <span class=\"math inline\">\\(p\\)</span> 项在把前面减去的全部加上后不一定满足。故前面最多减去 <span class=\"math inline\">\\(d_p\\)</span>，随便在哪里减都无所谓，组合意义一下，就是无标号球放有标号盒子可空放可不放，插板得答案为 <span class=\"math inline\">\\(\\displaystyle {-d_p + n - p\\choose n - p}\\)</span>。</p>\n<p>前后乘起来即为答案。注意不要在最后一步乘起来的时候忘记取模，否则你会获得 76pts 的高分 <img src=\"/em/xk.gif\" /></p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 998244353;\nint main() &#123;\n    freopen(&quot;fate.in&quot;, &quot;r&quot;, stdin);\n    freopen(&quot;fate.out&quot;, &quot;w&quot;, stdout);\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n    int n, m;\n    std::cin &gt;&gt; n;\n    std::vector&lt;long long&gt; a(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i];\n    std::cin &gt;&gt; m;\n    long long res = 1;\n    for (int i = 1; i &lt; m; ++i) &#123;\n        auto x = a[i] - a[i - 1];\n        (res *= x + 1) %= mod;\n    &#125;\n    auto qkp = [](long long x, int y) &#123;\n        long long res = 1;\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    auto C = [&amp;](int n, int m) &#123;\n        long long res = 1ll;\n        for (int i = n; i &gt; n - m; --i)\n            (res *= i) %= mod;\n        for (int i = m; i; --i)\n            (res *= qkp(i, mod - 2)) %= mod;    \n        return res;\n    &#125;;\n    if (m != n)\n        (res *= C(a[m + 1] - a[m] + n - m, n - m)) %= mod;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"c.-abstruse\">C. abstruse</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P9731\" class=\"uri\">https://www.luogu.com.cn/problem/P9731</a></p>\n<p>注意到有挺高的一档 <span class=\"math inline\">\\(S=2\\)</span> 的分，考虑其启示意义。</p>\n<p>我们对于一对 <span class=\"math inline\">\\((a_i, b_i)\\)</span>，在 <span class=\"math inline\">\\(a_i\\)</span> 和 <span class=\"math inline\">\\(b_i\\)</span> 间连边，则原问题转化为给无向图的每条边选择方向，使对于每个 <span class=\"math inline\">\\(x\\)</span>，<span class=\"math inline\">\\(|in_x-out_x|\\le 1\\)</span>。</p>\n<p>我们知道对于一条欧拉回路，有对于任意 <span class=\"math inline\">\\(x\\)</span>，<span class=\"math inline\">\\(in_x=out_x\\)</span>。然后这个时候为了把问题转化成欧拉回路问题我们建一个虚点朝度数为奇的点连条边然后跑欧拉回路即可。</p>\n<p>至于 <span class=\"math inline\">\\(S=2^k\\)</span>，就是在明示分治。即对于任意 <span class=\"math inline\">\\(x\\)</span>，要求其在前后 <span class=\"math inline\">\\(2^{k-1}\\)</span> 次出现次数相差不超过 <span class=\"math inline\">\\(1\\)</span>。注意到非常幸福的有前后两个部分大小相等，又有一个天才的建图，<mark>即在每个点和自己所属的行连边，然后跑欧拉回路，出边表示选前半部分，入边表示选后半部分，这样就保证了一行中各有 <span class=\"math inline\">\\(2^{k-1}\\)</span> 个选前后半部分，也保证了每个点在前后半边出现的次数相差不超过 <span class=\"math inline\">\\(1\\)</span>。对于后面一个性质，分治最终可得到点在每一列出现次数相差不超过 <span class=\"math inline\">\\(1\\)</span></mark>。</p>\n<p>打个当前弧优化然后注意计算细节复杂度然后多卡几（十）遍就过了 <img src=\"/em/dy.gif\" /></p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nnamespace fastIO &#123;\nconst int LEN = (1 &lt;&lt; 20);\n#ifdef ONLINE_JUDGE\nint nec(void) &#123;\n    static char buf[LEN], *p = buf, *e = buf;\n    if (p == e) &#123;\n        e = buf + fread(buf, 1, LEN, stdin);\n        if (e == buf) return EOF;\n        p = buf;\n    &#125;\n    return *p++;\n&#125;\n#else\n#define nec getchar\n#endif\nbool read(int &amp;x) &#123;\n    x = 0;\n    bool f = 0;\n    char ch = nec();\n    while (ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123;\n        if (ch == EOF) return 0;\n        if (ch == &#39;-&#39;) f = 1;\n        ch = nec();\n    &#125;\n    while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) &#123;\n        x = x * 10 + ch - &#39;0&#39;;\n        ch = nec();\n    &#125;\n    if (f) x = -x;\n    return 1;\n&#125;\nvoid print(int x) &#123;\n    if (x &lt; 0)\n        putchar(&#39;-&#39;), x = -x;\n    if (x &gt;= 10) print(x / 10);\n    putchar(x % 10 + &#39;0&#39;);\n    return;\n&#125;\nvoid print(int x, char ch) &#123;\n    print(x), putchar(ch);\n    return;\n&#125;\n&#125; using namespace fastIO;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    std::cout.tie(nullptr);\n    freopen(&quot;abstruse.in&quot;, &quot;r&quot;, stdin);\n    freopen(&quot;abstruse.out&quot;, &quot;w&quot;, stdout);\n#else\n    freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, m, k;\n    read(n), read(m), read(k);\n    std::vector&lt;std::vector&lt;int&gt; &gt; a(n + 1, std::vector&lt;int&gt; (m + 1));\n    for (int i = 1; i &lt;= n; ++i)\n        for (int j = 1; j &lt;= m; ++j)\n            read(a[i][j]);\n    std::vector&lt;int&gt; to(k + n + 1), tag(n * m + n + k + 1);\n    std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; g(k + n + 1); \n    std::function&lt;void(int, int)&gt; calc = [&amp;](int l, int r) &#123;\n        if (l + 1 == r) &#123;\n            for (int i = 1; i &lt;= n; ++i) &#123;\n                g[a[i][l]].emplace_back(a[i][r], i);\n                g[a[i][r]].emplace_back(a[i][l], i);\n            &#125;\n            int cnt = n;\n            for (int i = 1; i &lt;= n; ++i) &#123;\n                if ((int)g[a[i][l]].size() &amp; 1)\n                    g[0].emplace_back(a[i][l], ++cnt), g[a[i][l]].emplace_back(0, cnt);\n                if ((int)g[a[i][r]].size() &amp; 1)\n                    g[0].emplace_back(a[i][r], ++cnt), g[a[i][r]].emplace_back(0, cnt);\n            &#125;\n            std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;\n                for (int i = to[x]; i &lt; (int)g[x].size(); i = to[x]) &#123;\n                    to[x] = i + 1;\n                    auto [v, id] = g[x][i];\n                    if (!tag[id]) &#123;\n                        tag[id] = 1;\n                        if (x &amp;&amp; v)\n                            a[id][l] = x, a[id][r] = v;\n                        DFS(v);\n                    &#125;\n                &#125;\n                return;\n            &#125;;\n            DFS(0);\n            for (int i = 1; i &lt;= n; ++i)\n                DFS(a[i][l]), DFS(a[i][r]);\n            to[0] = 0, g[0].clear();\n            for (int i = 1; i &lt;= n; ++i) &#123;\n                to[a[i][l]] = 0, g[a[i][l]].clear();\n                to[a[i][r]] = 0, g[a[i][r]].clear();\n            &#125;\n            std::fill(tag.begin() + 1, tag.begin() + cnt + 1, 0);\n            return;\n        &#125;\n        int mid = (l + r) &gt;&gt; 1, cnt = 0;\n        std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; g(k + n + 1);\n        for (int i = 1; i &lt;= n; ++i)\n            for (int j = l; j &lt;= r; ++j) &#123;\n                g[a[i][j]].emplace_back(i + k, ++cnt);\n                g[i + k].emplace_back(a[i][j], cnt);\n            &#125;\n        for (int i = 1; i &lt;= n; ++i)\n            for (int j = l; j &lt;= r; ++j)\n                if ((int)g[a[i][j]].size() &amp; 1)\n                    g[0].emplace_back(a[i][j], ++cnt), g[a[i][j]].emplace_back(0, cnt);\n        std::vector&lt;int&gt; L(n + 1, l - 1), R(n + 1, r + 1);\n        std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;\n            for (int i = to[x]; i &lt; (int)g[x].size(); i = to[x]) &#123;\n                to[x] = i + 1;\n                auto [v, id] = g[x][i];\n                if (!tag[id]) &#123;\n                    tag[id] = 1;\n                    if (x &amp;&amp; v) &#123;\n                        if (v &lt;= k)\n                            a[x - k][++L[x - k]] = v;\n                        else\n                            a[v - k][--R[v - k]] = x;\n                    &#125;\n                    DFS(v);\n                &#125;\n            &#125;\n            return;\n        &#125;;\n        DFS(0);\n        for (int i = 1; i &lt;= n; ++i)\n            DFS(i + k);\n        for (int i = 1; i &lt;= n; ++i)\n            for (int j = l; j &lt;= r; ++j)\n                DFS(a[i][j]);\n        to[0] = 0, g[0].clear();\n        for (int i = 1; i &lt;= n; ++i)\n            to[i + k] = 0, g[i + k].clear();\n        for (int i = 1; i &lt;= n; ++i)\n            for (int j = l; j &lt;= r; ++j)\n                to[a[i][j]] = 0, g[a[i][j]].clear();\n        std::fill(tag.begin() + 1, tag.begin() + cnt + 1, 0);\n        calc(l, mid), calc(mid + 1, r);\n        return;\n    &#125;;\n    calc(1, m);\n    for (int i = 1; i &lt;= n; ++i, putchar(&#39;\\n&#39;))\n        for (int j = 1; j &lt;= m; ++j)\n            print(a[i][j], &#39; &#39;);\n    return 0;\n&#125;</code></pre>\n</details>\n",
            "tags": [
                "分治",
                "欧拉回路"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20230314/",
            "url": "https://xsc062.netlify.app/20230314/",
            "title": "分治",
            "date_published": "2023-03-13T18:33:31.000Z",
            "content_html": "<p>听说是 <a href=\"https://www.becoder.com.cn/contest/3416\">分治场</a>，想起了自己根本没学过分治（甚至从来不知道归并排序的原理 orz）就去听 CDQ 然后一头雾水的惨痛经历，不禁 PTSD 了。</p>\n<span id=\"more\"></span>\n<hr />\n<h3 id=\"a.-老板的又一道题\">A. 老板的又一道题</h3>\n<p><a href=\"https://www.becoder.com.cn/contest/3416/problem/1\" class=\"uri\">https://www.becoder.com.cn/contest/3416/problem/1</a></p>\n<p>这是什么，有序表的最小和，切一下（所以和分治有什么关系啊）。</p>\n<p>首先对数组进行排序（我忘了 orz），然后在优先队列中填入 <span class=\"math inline\">\\(A_{1\\sim n} + B_1\\)</span>。假设当前最小值为 <span class=\"math inline\">\\(A_i + B_j\\)</span>，则输出，弹出并填入 <span class=\"math inline\">\\(A_i + B_{j + 1}\\)</span>。因为 <span class=\"math inline\">\\(B\\)</span> 是单调的，所以我们填入的数（起码在输出时）是单调的。</p>\n<details>\n<pre class=\"cpp\"><code>namespace XSC062 &#123;\nusing namespace fastIO;\nconst int maxn = 1e5 + 5;\nstruct _ &#123;\n    int u, i;\n    _() &#123;&#125;\n    _(int u1, int i1) &#123;\n        u = u1, i = i1;\n    &#125;\n    bool operator&lt; (const _ q) const &#123;\n        return u &gt; q.u;\n    &#125;\n&#125;;\nint n, cnt;\nint a[maxn], b[maxn];\nstd::priority_queue&lt;_&gt; q;\nint main() &#123;\n    read(n);\n    for (int i = 1; i &lt;= n; ++i)\n        read(a[i]);\n    for (int i = 1; i &lt;= n; ++i)\n        read(b[i]);\n    std::sort(a + 1, a + n + 1);\n    std::sort(b + 1, b + n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        q.push(_(a[i] + b[1], 1));\n    while (!q.empty()) &#123;\n        _ f = q.top();\n        q.pop();\n        print(f.u, &#39; &#39;);\n        if (++cnt == n)\n            break;\n        _ t = f;\n        t.u -= b[f.i];\n        t.u += b[++t.i];\n        q.push(t);\n    &#125;\n    return 0;\n&#125;\n&#125; // namespace XSC062</code></pre>\n</details>\n<hr />\n<h3 id=\"b.-魔法石的诱惑\">B. 魔法石的诱惑</h3>\n<p><a href=\"https://www.becoder.com.cn/contest/3416/problem/2\" class=\"uri\">https://www.becoder.com.cn/contest/3416/problem/2</a></p>\n<p>这，这不是二分答案？到底和分治有什么关系啊。</p>\n<p>嘶，<span class=\"math inline\">\\(Q\\)</span> 是 <span class=\"math inline\">\\(10^8\\)</span>，算一算 <span class=\"math inline\">\\(n\\)</span> 的范围。不难发现 <span class=\"math inline\">\\(Q=\\sum\\limits_{i&gt;1} \\lfloor \\dfrac n{5^i} \\rfloor\\)</span>，当 <span class=\"math inline\">\\(n=5\\times 10^8\\)</span> 时，<span class=\"math inline\">\\(\\dfrac n5\\)</span> 就已经是 <span class=\"math inline\">\\(10^8\\)</span> 了，所以我们二分的左右边界应为 <span class=\"math inline\">\\([0,5\\times 10^8]\\)</span>。</p>\n<p>然后 <code>check</code> 的话我们就暴力除 <span class=\"math inline\">\\(5\\)</span> 计算答案（就像小奥一样），一次 <code>check</code> 的时间复杂度是 <span class=\"math inline\">\\(\\log\\)</span> 的，不会有问题。</p>\n<details>\n<pre class=\"cpp\"><code>namespace XSC062 &#123;\nusing namespace fastIO;\nint q, l, mid, r = 5e18, res;\nint check(int x) &#123;\n    int res = 0;\n    while (x / 5)\n        res += (x /= 5);\n    return res;\n&#125;\nint main() &#123;\n    read(q);\n    while (l &lt;= r) &#123;\n        int mid = (l + r) &gt;&gt; 1;\n        if (check(mid) &gt;= q) &#123;\n            res = mid;\n            r = mid - 1;\n        &#125;\n        else l = mid + 1;\n    &#125;\n    if (check(res) == q)\n        print(res);\n    else puts(&quot;No solution&quot;);\n    return 0;\n&#125;\n&#125; // namespace XSC062</code></pre>\n</details>\n<hr />\n<h3 id=\"c.-神族文字\">C. 神族文字</h3>\n<p><a href=\"https://www.becoder.com.cn/contest/3416/problem/3\" class=\"uri\">https://www.becoder.com.cn/contest/3416/problem/3</a></p>\n<p>我不理解？这到底和分治有什么关系？GM 不会是纯看标签拉题吧？标签又是哪个聪明打的？</p>\n<p>总而言之，言而总之，我们打一个 <code>map</code>。</p>\n<details>\n<pre class=\"cpp\"><code>namespace XSC062 &#123;\nusing namespace fastIO;\nusing str = std::string;\nstr s1, s2, sl;\nstd::map&lt;str, str&gt; t;\nint main() &#123;\n    for (;;) &#123;\n        std::getline(std::cin, sl);\n        std::stringstream s(sl);\n        if (s &gt;&gt; s1) &#123;\n            s &gt;&gt; s2;\n            t[s2] = s1;\n        &#125;\n        else break;\n    &#125;\n    while (std::cin &gt;&gt; s1) &#123;\n        if (t.count(s1))\n            std::cout &lt;&lt; t[s1] &lt;&lt; &#39;\\n&#39;;\n        else puts(&quot;eh&quot;);\n    &#125;\n    return 0;\n&#125;\n&#125; // namespace XSC062</code></pre>\n</details>\n<hr />\n<h3 id=\"d.-逃亡\">D. 逃亡</h3>\n<p><a href=\"https://www.becoder.com.cn/contest/3416/problem/4\" class=\"uri\">https://www.becoder.com.cn/contest/3416/problem/4</a></p>\n<p>首先注意到车车是自动驾驶的，就是说一个人下车过后车会自动往另一个人的方向跑。</p>\n<p>明显反复交接的话车会多跑很多路程，所以我们只交接一次。</p>\n<p>所以难点只是用未知数把最终速度表示出来（想起了物理实验题）。</p>\n<p>假设距离为 <span class=\"math inline\">\\(S\\)</span>，车速为 <span class=\"math inline\">\\(v_1\\)</span>，人速为 <span class=\"math inline\">\\(v_2\\)</span>，第一个人一直坐车坐到 <span class=\"math inline\">\\(x\\)</span> 路程，则最终时间为 <span class=\"math inline\">\\(\\max\\left\\{ \\dfrac x{v_1} + \\dfrac {S - x}{v_2}, \\dfrac x{v_1}+\\dfrac {x - \\dfrac x{v_1}\\times v_2}{v_1 + v_2} + \\dfrac {S-\\dfrac x{v_1}\\times v_2 - \\dfrac {x - \\dfrac x{v_1}\\times v_2}{v_1 + v_2} \\times v_2}{v_1}\\right\\}\\)</span>。</p>\n<p>有一个很明显的点，就是 <span class=\"math inline\">\\(x\\)</span> 越大，第一个人用时就越短，第二个人用时就越多。这个时候我们就可以二分 <span class=\"math inline\">\\(x\\)</span>，尽量使第一个人和第二个人用时接近（用时是一个关于 <span class=\"math inline\">\\(x\\)</span> 的分段函数，我们寻找其拐点），最终相同用时即为答案。</p>\n<details>\n<p>因为从来不是很喜欢浮点数二分，采用了先整数二分再框范围取精确答案的方法。</p>\n<p>所以怎么又是二分？说好的分治场呢？</p>\n<pre class=\"cpp\"><code>namespace XSC062 &#123;\nusing namespace fastIO;\nusing db = double;\nconst db eps = 1e-2;\ndb res, ans = 1e18;\nint s, v1, v2, l, mid, r;\ndb min(db x, db y) &#123;\n    return x &lt; y ? x : y; \n&#125;\ndb max(db x, db y) &#123;\n    return x &gt; y ? x : y;\n&#125;\nbool check(int x) &#123;\n    db t1 = x * 1.0 / v1;\n    db r1 = t1 + (s - x) * 1.0 / v2;\n    db t2 = (x - t1 * v2) / (v1 + v2);\n    db r2 = t1 + t2 + (s - t1 * v2 - t2 * v2) / v1;\n    return r1 &lt;= r2;\n&#125;\nint main() &#123;\n    read(s), read(v2), read(v1);\n    l = 0, r = s;\n    while (l &lt;= r) &#123;\n        mid = (l + r) &gt;&gt; 1;\n        if (check(mid)) &#123;\n            res = (db)mid;\n            r = mid - 1;\n        &#125;\n        else l = mid + 1;\n    &#125;\n    for (db i = res - 2; i &lt;= res + 2; i += eps) &#123;\n        db t1 = i * 1.0 / v1;\n        db r1 = t1 + (s - i) * 1.0 / v2;\n        db t2 = (i - t1 * v2) / (v1 + v2);\n        db r2 = t1 + t2 +\n                (s - t1 * v2 - t2 * v2) / v1;\n        ans = min(ans, max(r1, r2));\n    &#125;\n    printf(&quot;%.2lf&quot;, ans);\n    return 0;\n&#125;\n&#125; // namespace XSC062</code></pre>\n</details>\n<hr />\n<h3 id=\"e.-剔除多余括号\">E. 剔除多余括号</h3>\n<p><a href=\"https://www.becoder.com.cn/contest/3416/problem/5\" class=\"uri\">https://www.becoder.com.cn/contest/3416/problem/5</a></p>\n<p><em>为了套取数据理解题意，我用 python 交了一个 <code>print(input())</code>，结果总司令在上，得到了 33pts 的高分…</em></p>\n<p>什么叫多余括号呢？括号前后的符号优先级小于等于括号中的符号，并且若括号内存在括号与括号前同级，则括号前不为 <code>-</code> 或 <code>/</code>。</p>\n<p>这样就可以了。我们将问题划分为若干个子问题，对每个括号内的内容进行相同方式的处理：对比括号内优先级最高的符号和括号前后符号的优先级，处理括号内的内容时若遇到括号，则递归地进行相似的处理。</p>\n<details>\n<p>其实这个充其量只能算是模拟…… 跟分治并不是很有关系，和 CSP-J 2022 T3 有点像。</p>\n<pre class=\"cpp\"><code>namespace XSC062 &#123;\nusing namespace fastIO;\nconst int maxn = 260;\nint n;\nchar s[maxn];\nbool vis[maxn];\nint max(int x, int y) &#123;\n    return x &gt; y ? x : y;\n&#125;\nint Deal(int l, int r) &#123;\n    int res = 1;\n    for (int i = l; i &lt;= r; ++i) &#123;\n        if (s[i] == &#39;+&#39; || s[i] == &#39;-&#39;)\n            res = max(res, 1);\n        else if (s[i] == &#39;*&#39; || s[i] == &#39;/&#39;)\n            res = 2;\n        else if (s[i] == &#39;(&#39;) &#123;\n            int cnt = 1, j;\n            for (j = i + 1; j &lt;= r; ++j) &#123;\n                if (s[j] == &#39;(&#39;)\n                    ++cnt;\n                else if (s[j] == &#39;)&#39;)\n                    --cnt;\n                if (cnt == 0)\n                    break;\n            &#125;\n            cnt = Deal(i + 1, j - 1);\n            int t = 1;\n            int p1 = i - 1, p2 = j + 1;\n            while (s[p1] == &#39;(&#39; || s[p1] == &#39;)&#39;)\n                --p1;\n            while (s[p2] == &#39;(&#39; || s[p2] == &#39;)&#39;)\n                ++p2;\n            if (s[p1] == &#39;+&#39; || s[p1] == &#39;-&#39;)\n                t = max(t, 1);\n            else t = max(t, 2);\n            if (s[p2] == &#39;+&#39; || s[p2] == &#39;-&#39;)\n                t = max(t, 1);\n            else t = max(t, 2);\n            if (t &lt; cnt)\n                vis[i] = vis[j] = 1;\n            else if (t == cnt) &#123;\n                if (s[p1] != &#39;-&#39; &amp;&amp; s[p1] != &#39;/&#39;)\n                    vis[i] = vis[j] = 1;\n            &#125;\n            i = j;\n        &#125;\n    &#125;\n    return res;\n&#125;\nint main() &#123;\n    s[1] = &#39;+&#39;;\n    scanf(&quot;%s&quot;, s + 2);\n    n = strlen(s + 1) + 1;\n    s[n] = &#39;+&#39;;\n    Deal(1, n);\n    for (int i = 2; i &lt; n; ++i) &#123;\n        if (!vis[i])\n            putchar(s[i]);\n    &#125;\n    return 0;\n&#125;\n&#125; // namespace XSC062</code></pre>\n</details>\n<hr />\n<h3 id=\"f.-最接近点对问题\">F. 最接近点对问题</h3>\n<p><a href=\"https://www.becoder.com.cn/contest/3416/problem/6\" class=\"uri\">https://www.becoder.com.cn/contest/3416/problem/6</a></p>\n<p>分治典中典。</p>\n<p>我们将点按照横坐标排序，对点 <span class=\"math inline\">\\(1\\sim n\\)</span> 进行分治。</p>\n<p>将求解区间包含的点分为两部分，假设左边部分和右边部分已经分别求解出了最近点对（出口即为求解区间仅包含两点，直接求出距离），考虑合并状态。则情况无非有三种：</p>\n<ol type=\"1\">\n<li>答案为左边部分的答案</li>\n<li>答案为右边部分的答案</li>\n<li>答案为左、右各选取一点</li>\n</ol>\n<p>前两者是已知量，则我们求解出第三种情况，选择最小值即可。</p>\n<p>第三种情况有个很妙的处理方式：我们设前两种情况的答案较小者为 <span class=\"math inline\">\\(d\\)</span>，设求解区间最靠中间的点为 <span class=\"math inline\">\\(m\\)</span>。</p>\n<ul>\n<li><p>若 <span class=\"math inline\">\\(m\\)</span> 为左边部分的点</p>\n<p>则由于我们对半二分，<span class=\"math inline\">\\(m\\)</span> 一定是左边部分最靠右的点。</p>\n<ul>\n<li><p>对于其余左边部分的节点：</p>\n若它们与 <span class=\"math inline\">\\(m\\)</span> 的横向距离已经大于等于 <span class=\"math inline\">\\(d\\)</span>，则它们与右边部分的点的横向距离会更大。连横向距离都已经大于等于当前最优解了，无需考虑纵向距离，筛除这部分点。</li>\n<li><p>对于右边部分的节点：</p>\n<p>若它们与 <span class=\"math inline\">\\(m\\)</span> 的横向距离已经大于等于 <span class=\"math inline\">\\(d\\)</span>，则它们与更左边的其他左边部分节点的横向距离会更大，故筛除这部分点。</p></li>\n</ul></li>\n<li><p>若 <span class=\"math inline\">\\(m\\)</span> 为右边部分的点</p>\n<p>同理。</p></li>\n</ul>\n<p>综上，我们只用考虑求解区间内与 <span class=\"math inline\">\\(m\\)</span> 的横向距离小于 <span class=\"math inline\">\\(d\\)</span> 的点。</p>\n<p>在筛选出这些点后，我们如何进行进一步的处理呢？答案是，<strong>枚举</strong>。</p>\n<p>我们枚举每一对点，计算它们间的距离。若比答案小，则更新答案。</p>\n<p>那这复杂度也太神奇了。所以我们给出一个同样神奇的优化：按纵坐标递增对筛选出的点排序。当二重循环筛选时，若当前第一层循环 <span class=\"math inline\">\\(i\\)</span> 与第二层循环 <span class=\"math inline\">\\(j\\)</span> 的纵向距离大于等于了当前最小答案，就可以将第二层循环 <code>break</code> 了。因为纵坐标单调，继续枚举距离会继续增加，离答案更远。</p>\n<p>那看起来复杂度还是很神奇，理论上来说应该是 <span class=\"math inline\">\\(O(n^2\\log n)\\)</span> 的呀？</p>\n<p>考虑第一层循环 <span class=\"math inline\">\\(i\\)</span>。对于点 <span class=\"math inline\">\\(i\\)</span>，有哪些 <span class=\"math inline\">\\(j\\)</span> 可以满足它的要求，从而被枚举到呢？</p>\n<ul>\n<li>由于点对无序，所以 <span class=\"math inline\">\\(j\\)</span> 从 <span class=\"math inline\">\\(i+1\\)</span> 开始枚举，所以 <span class=\"math inline\">\\(y_j&gt;y_i\\)</span>。</li>\n<li>由于筛选条件，<span class=\"math inline\">\\(|x_i-x_m|&lt; d\\)</span> 且 <span class=\"math inline\">\\(|x_j-x_m|&lt; d\\)</span>。</li>\n<li>由于 <code>break</code> 条件，<span class=\"math inline\">\\(y_j-y_i&lt; d\\)</span>。</li>\n</ul>\n<p>合并一下就是，<span class=\"math inline\">\\(|x_i-x_j|\\le 2\\times d\\)</span>，且 <span class=\"math inline\">\\(0\\le y_j - y_i \\le d\\)</span>。那么我们可以画出一个底为 <span class=\"math inline\">\\(2\\times d\\)</span>，高为 <span class=\"math inline\">\\(d\\)</span> 的矩形，且它的中轴线为 <span class=\"math inline\">\\(x=x_m\\)</span>，中轴线左右两边均为 <span class=\"math inline\">\\(d\\times d\\)</span> 的正方形。</p>\n<p>若任意两个点同在左边部分或同在右边部分，那么这一对点的贡献已经在分治时计算完成了，所以一定不会比 <span class=\"math inline\">\\(d\\)</span> 小。</p>\n<p>有一个很妙的结论：满足条件的 <span class=\"math inline\">\\(j\\)</span> 在矩形的左半边和右半边最多只有三个。</p>\n<p>为什么？同一部分中，任意两个 <span class=\"math inline\">\\(j\\)</span> 的距离至少为 <span class=\"math inline\">\\(d\\)</span>。那么四个 <span class=\"math inline\">\\(j\\)</span>，距离都为 <span class=\"math inline\">\\(d\\)</span>，那么正好就是整个左半边的正方形。别忘了一点，<span class=\"math inline\">\\(j\\)</span> 需满足的三个条件都是严格小于，所以不能碰到整个矩形的边界，所以一个部分中最多只能存在三个 <span class=\"math inline\">\\(j\\)</span>。</p>\n<p>那么实际上看似 <span class=\"math inline\">\\(n^2\\)</span> 的枚举，在多个优化下就变成了 <span class=\"math inline\">\\(O(n)\\)</span>。再加上对筛选出的点纵坐标排序的时间，总体时间复杂度为 <span class=\"math inline\">\\(O(n\\log^2 n)\\)</span>。</p>\n<details>\n<pre class=\"cpp\"><code>namespace XSC062 &#123;\nusing db = double;\nconst db inf = 1e18;\nconst int maxn = 6e4 + 5;\nstruct _ &#123; db x, y; &#125;;\nint n;\n_ a[maxn];\ndb dis(db x1, db y1, db x2, db y2) &#123;\n    return sqrt((x1 - x2) * (x1 - x2) +\n                (y1 - y2) * (y1 - y2));\n&#125;\ndb min(db x, db y) &#123;\n    return x &lt; y ? x : y;\n&#125;\ndb abs(db x) &#123;\n    return x &gt;= 0 ? x : -x;\n&#125;\ndb Solu(int l, int r) &#123;\n    if (l == r)\n        return inf;\n    if (l + 1 == r)\n        return dis(a[l].x, a[l].y, a[r].x, a[r].y);\n    int mid = (l + r) &gt;&gt; 1;\n    db d = min(Solu(l, mid), Solu(mid + 1, r));\n    std::vector&lt;_&gt; t;\n    for (int i = l; i &lt;= r; ++i) &#123;\n        if (abs(a[i].x - a[mid].x) &lt; d)\n            t.push_back(a[i]);\n    &#125;\n    std::sort(t.begin(), t.end(),\n        [&amp;](_ x, _ y) &#123; return x.y &lt; y.y; &#125;);\n    for (int i = 0; i &lt; (int)t.size(); ++i) &#123;\n        for (int j = i + 1; j &lt; (int)t.size(); ++j) &#123;\n            if (t[j].y - t[i].y &gt;= d)\n                break;\n            d = min(d, dis(t[i].x, t[i].y,\n                                t[j].x, t[j].y));\n        &#125;\n    &#125;\n    return d;\n&#125;\nint main() &#123;\n    scanf(&quot;%d&quot;, &amp;n);\n    for (int i = 1; i &lt;= n; ++i)\n        scanf(&quot;%lf %lf&quot;, &amp;a[i].x, &amp;a[i].y);\n    std::sort(a + 1, a + n + 1,\n        [&amp;](_ x, _ y) &#123; return x.x &lt; y.x; &#125;);\n    printf(&quot;%.2lf\\n&quot;, Solu(1, n) / 2);\n    return 0;\n&#125;\n&#125; // namespace XSC062</code></pre>\n</details>\n<p>考虑一个问题。代码的时间复杂度有两个 <span class=\"math inline\">\\(\\log\\)</span>，这是极不好的（will be fixed）。</p>\n<hr />\n<h3 id=\"g.-残缺棋盘问题\">G. 残缺棋盘问题</h3>\n<p><a href=\"https://www.becoder.com.cn/contest/3416/problem/7\" class=\"uri\">https://www.becoder.com.cn/contest/3416/problem/7</a></p>\n<p>首先考虑一个有趣的问题：<span class=\"math inline\">\\(4^n-1\\)</span> 一定被 <span class=\"math inline\">\\(3\\)</span> 整除吗？</p>\n<p>一个简单的方法是使用数学归纳法进行证明，其思想也会在这道题中体现。</p>\n<p>不过还有另一个方法：<span class=\"math inline\">\\(4^n-1=(3+1)^n-1\\)</span>，使用二项式定理则有：</p>\n<p><span class=\"math display\">\\[\n(3+1)^n-1=\\sum_{i=0}^n {n\\choose i} \\times 3^{n-i}\\times 1^i - 1\n\\]</span></p>\n<p>不难发现除 <span class=\"math inline\">\\(i=n\\)</span> 时，前面每一项都有因子 <span class=\"math inline\">\\(3\\)</span>，而当 <span class=\"math inline\">\\(i=n\\)</span> 时，<span class=\"math inline\">\\({n\\choose n}\\times 3^0\\times 1^n=1\\)</span>，与后面的 <span class=\"math inline\">\\(-1\\)</span> 抵消，故得证。</p>\n<hr />\n<p>考虑将棋盘划分为若干个 <span class=\"math inline\">\\(2\\times 2\\)</span> 的 1 级区域。对于缺口所在的 1 级区域，我们使用一个刚好贴合的三格板将其补齐成为一个完整的 1 级区域。</p>\n<p>我们称包含四个完整的 <span class=\"math inline\">\\(2\\times 2\\)</span> 的 1 级区域的 <span class=\"math inline\">\\(4\\times 4\\)</span> 的区域为 2 级区域，对于包含了我们刚刚补齐的 1 级区域的 2 级区域，我们将最中间的四个格子视为一个 1 级区域并填充，接下来剩余的 3 个完整 1 级区域为各自失去一个能填充的格子，我们选取对应的三格板填充即可。</p>\n<p>对于一个 <span class=\"math inline\">\\(8\\times 8\\)</span> 的 3 级区域，若其包含我们填充完毕的 2 级区域，我们将最中间 <span class=\"math inline\">\\(2\\times 2\\)</span> 的格子视为一个 1 级区域并填充。接下来，剩余的 3 个完整的 2 级区域成为缺失 1 个格子的 2 级区域，按之前的方法填充即可。</p>\n<p>以此类推即可递归地填充完成整个棋盘。但现在又来了一个问题：这道题没有 SPJ。根据样例可知，填充规则是由外到内，中、左上、左下、右上、右下，我们按照此顺序进行分治递归即可。</p>\n<details>\n<pre class=\"cpp\"><code>namespace XSC062 &#123;\nusing namespace fastIO;\nconst int maxn = 105;\nint n, x, y, cnt;\nint t[maxn][maxn];\nvoid getColor(int c, int r, int l, int x, int y) &#123;\n    if (l == 2) &#123;\n        ++cnt;\n        for (int i = c; i &lt;= c + 1; ++i) &#123;\n            for (int j = r; j &lt;= r + 1; ++j) &#123;\n                if (i != x || j != y)\n                    t[i][j] = cnt;\n            &#125;\n        &#125;\n        return;\n    &#125;\n    l /= 2;\n    if (x - c &lt; l) &#123;\n        if (y - r &lt; l) &#123;\n            getColor(c + l - 1, r + l - 1,\n                        2, c + l - 1, r + l - 1);\n            getColor(c, r, l, x, y);\n            getColor(c + l, r, l, c + l, r + l - 1);\n            getColor(c, r + l, l, c + l - 1, r + l);\n            getColor(c + l, r + l, l, c + l, r + l);\n        &#125;\n        else &#123;\n            getColor(c + l - 1, r + l - 1,\n                        2, c + l - 1, r + l);\n            getColor(c, r, l, c + l - 1, r + l - 1);\n            getColor(c + l, r, l, c + l, r + l - 1);\n            getColor(c, r + l, l, x, y);\n            getColor(c + l, r + l, l, c + l, r + l);\n        &#125;\n    &#125;\n    else &#123;\n        if (y - r &lt; l) &#123;\n            getColor(c + l - 1, r + l - 1,\n                            2, c + l, r + l - 1);\n            getColor(c, r, l, c + l - 1, r + l - 1);\n            getColor(c + l, r, l, x, y);\n            getColor(c, r + l, l, c + l - 1, r + l);\n            getColor(c + l, r + l, l, c + l, r + l);\n        &#125;\n        else &#123;\n            getColor(c + l - 1, r + l - 1,\n                            2, c + l, r + l);\n            getColor(c, r, l, c + l - 1, r + l - 1);\n            getColor(c + l, r, l, c + l, r + l - 1);\n            getColor(c, r + l, l, c + l - 1, r + l);\n            getColor(c + l, r + l, l, x, y);\n        &#125;\n    &#125;\n    return;\n&#125;\nint main() &#123;\n    read(n), read(x), read(y);\n    getColor(1, 1, n, x, y);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        for (int j = 1; j &lt;= n; ++j)\n            print(t[i][j], &#39; &#39;);\n        putchar(&#39;\\n&#39;);\n    &#125;\n    return 0;\n&#125;\n&#125; // namespace XSC062</code></pre>\n</details>\n<hr />\n<h3 id=\"h.-tricky-function\">H. Tricky Function</h3>\n<p><a href=\"https://www.becoder.com.cn/contest/3416/problem/8\" class=\"uri\">https://www.becoder.com.cn/contest/3416/problem/8</a></p>\n<p>GM 提示了这道题就是平面最近点对。豁然开朗。</p>\n<p>不妨将 <span class=\"math inline\">\\(i\\)</span> 视作 <span class=\"math inline\">\\(x_i\\)</span>，将 <span class=\"math inline\">\\(\\sum_{k=1}^i a_k\\)</span> 视作 <span class=\"math inline\">\\(y_i\\)</span>，则直接求解平面最近点对即可。</p>\n",
            "tags": [
                "分治"
            ]
        }
    ]
}