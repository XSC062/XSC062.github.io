{
    "version": "https://jsonfeed.org/version/1",
    "title": "null • All posts by \"闵可夫斯基和\" tag",
    "description": "",
    "home_page_url": "https://xsc062.netlify.app",
    "items": [
        {
            "id": "https://xsc062.netlify.app/20250707/",
            "url": "https://xsc062.netlify.app/20250707/",
            "title": "DP 凸优化",
            "date_published": "2025-07-07T06:10:02.000Z",
            "content_html": "<p>袜，这篇文章一下子创建了三个新 tag。</p>\n<span id=\"more\"></span>\n<hr />\n<h2 id=\"什么是凸函数\">什么是凸函数</h2>\n<h3 id=\"定义\">定义</h3>\n<p>在信息学中研究的凸函数大抵是只在正整数域上有定义的，所以只能直接摒弃导函数的概念了。</p>\n<p>若斜率递增，换言之，差分数组递增，认为函数是凸的（好反直觉）。</p>\n<p>或者看看符号化的定义：若对于任意 <span class=\"math inline\">\\(\\lambda\\in[0,1]\\)</span>，函数 <span class=\"math inline\">\\(f(x)\\)</span> 均满足：</p>\n<p><span class=\"math display\">\\[\nf(\\lambda x+(1-\\lambda) y)\\le \\lambda f(x)+(1-\\lambda) f(y).\n\\]</span></p>\n<p>或等价地：</p>\n<p><span class=\"math display\">\\[\nf(x)-f(x - 1)\\le f(x + 1) - f(x)\n\\]</span></p>\n<p>那么认为 <span class=\"math inline\">\\(f\\)</span> 是凸函数。</p>\n<p>因为凹凸在性质上没区别，所以 <strong>下文施行暴政，将凹函数和凸函数统称为凸函数</strong>。</p>\n<hr />\n<h3 id=\"判定\">判定</h3>\n<p>对于具体情境下的问题，怎么判断 DP 数组是否关于其某一维为凸函数？</p>\n<ul>\n<li>相信相信的力量（最常用）。</li>\n<li><p>对于分段问题，证明分出来的每一段满足四边形不等式。</p>\n<em>值得一提的是，数学上不认为满足四边形不等式能够推出函数为凸。但这是信息学.jpg</em></li>\n<li><p>其由两个凸函数线性相加得到：</p>\n<p>对于 <span class=\"math inline\">\\(\\forall\\, \\lambda,\\mu\\ge 0\\)</span> 和凸函数 <span class=\"math inline\">\\(f,g\\)</span>，若 <span class=\"math inline\">\\(h=\\lambda f+\\mu g\\)</span>，则 <span class=\"math inline\">\\(h\\)</span> 为凸函数。</p>\n此外，此时 <span class=\"math inline\">\\(h\\)</span> 的差分数组和 <span class=\"math inline\">\\(f,g\\)</span> 差分数组也满足上述关系。</li>\n<li>其是两个凸函数的 <a href=\"#闵可夫斯基和\">闵可夫斯基和</a>。</li>\n<li><p>其由两个凸函数线性 max 得到。</p>\n<p>对于两个凸函数的线性 min，一般不是凸函数，甚至可能是凹的。</p></li>\n</ul>\n<hr />\n<h3 id=\"性质\">性质</h3>\n<ul>\n<li>最值为唯一极值。</li>\n<li>斜率 / 差分数组具有单调性。</li>\n</ul>\n<p>在解题中主要用到的大概就是上面两条。</p>\n<hr />\n<h2 id=\"wqs-二分\">WQS 二分</h2>\n<h3 id=\"主要任务\">主要任务</h3>\n<blockquote>\n<p>例：把 <span class=\"math inline\">\\(a_{1\\sim n}\\)</span> 分为恰好 <span class=\"math inline\">\\(k\\)</span> 段，每段的代价为 <span class=\"math inline\">\\(sum^2+c\\)</span>（<span class=\"math inline\">\\(c\\)</span> 为给定的常数），问最小代价。<span class=\"math inline\">\\(n\\le 2\\times 10^5,a_i\\le 10^9\\)</span>。</p>\n</blockquote>\n<p>如果对段数没有要求，可以用斜优 <span class=\"math inline\">\\(O(n)\\)</span> 做。</p>\n<p>加上了 <span class=\"math inline\">\\(k\\)</span> 的限制，DP 变成二维的，令 <span class=\"math inline\">\\(f_{i,j}\\)</span> 表示在 <span class=\"math inline\">\\(i\\)</span> 处分第 <span class=\"math inline\">\\(j\\)</span> 段，可以在第一维斜率优化，做到 <span class=\"math inline\">\\(O(nk)\\)</span>；亦或发现 <span class=\"math inline\">\\((i,j)\\)</span> 有决策单调性，然后四边形不等式优化到 <span class=\"math inline\">\\(O(n^2)\\)</span>。</p>\n<p>我们发现 <span class=\"math inline\">\\(f\\)</span> 关于 <span class=\"math inline\">\\(j\\)</span> 这一维是凸的（而非上文的 <span class=\"math inline\">\\((i,j)\\)</span>），故将 <span class=\"math inline\">\\(f(n,j)\\)</span> 关于 <span class=\"math inline\">\\(j\\)</span> 的函数提取出来（记为 <span class=\"math inline\">\\(f_n(j)\\)</span>）。发现只有最高点是可以一次斜优快速求出来的，故可以认为在当前复杂度限制下，整个函数除了最高点以外都是未知的（注意可以在 DP 时记录极值点的横坐标，即分了几段）。</p>\n<p>我们给每个 <span class=\"math inline\">\\(f_n(j)\\)</span> 加上 <span class=\"math inline\">\\(\\alpha\\cdot j\\)</span>（在本题中即将 <span class=\"math inline\">\\(c\\gets c+k\\)</span>），勉强可以认为 <span class=\"math inline\">\\(\\alpha\\cdot j\\)</span> 是凸的，所以新函数 <span class=\"math inline\">\\(f&#39;_n(j)\\)</span> 也是凸的。若 <span class=\"math inline\">\\(k&gt;0\\)</span>，可以感受到极值点向左偏移，且随着 <span class=\"math inline\">\\(k\\)</span> 的增大，极值点不会右移；<span class=\"math inline\">\\(k&lt;0\\)</span> 时同理。</p>\n<p>结合几何观点，在 <span class=\"math inline\">\\(f_n\\)</span> 上的极值点可以用斜率为 <span class=\"math inline\">\\(0\\)</span> 的直线切到；而加上 <span class=\"math inline\">\\(\\alpha\\cdot j\\)</span> 的过程，其实就是切线斜率减去 <span class=\"math inline\">\\(\\alpha\\)</span> 的过程。相当于令切线斜率为 <span class=\"math inline\">\\(-\\alpha\\)</span>，看看能切到哪里。</p>\n<p>故可以二分一个合适的 <span class=\"math inline\">\\(k\\)</span>，使得极值点的横坐标为 <span class=\"math inline\">\\(k\\)</span>。此时 <span class=\"math inline\">\\(f&#39;_n(k)-\\alpha\\cdot k\\)</span> 即为待求。</p>\n<hr />\n<p>WQS 二分参与的问题一般以如下形式呈现：</p>\n<blockquote>\n<p>给定序列，将其恰好分为 <span class=\"math inline\">\\(k\\)</span> 段 / 恰好选 <span class=\"math inline\">\\(k\\)</span> 个，求最大 / 最小代价。</p>\n</blockquote>\n<p>题目要求最大 / 最小值一般能够反映函数的凹凸性，可以根据这一点来猜。</p>\n<hr />\n<h3 id=\"细节处理\">细节处理</h3>\n<p>考虑如下凸函数：</p>\n<p><img src=\"1.png\" /></p>\n<ul>\n<li>显然对于『凸出来』的点（即图中除了 <span class=\"math inline\">\\(E,H\\)</span> 以外的点），能切到的直线斜率为一个范围；而位于直线上的点（途中 <span class=\"math inline\">\\(E,H\\)</span>），能切到的直线斜率更是定死了。所以这要求你的二分精度需要略高一点。</li>\n<li><p>对于 <span class=\"math inline\">\\(E\\)</span>（或 <span class=\"math inline\">\\(H\\)</span>），不能找到只过它一点的切线。根据 DP 的写法，记录的横坐标可能是最小的 <span class=\"math inline\">\\(D\\)</span>，也可能是最大的 <span class=\"math inline\">\\(F\\)</span>，此时你可以：</p>\n<ul>\n<li>同时记录最小和最大的横坐标，看看 <span class=\"math inline\">\\(k\\)</span> 在不在中间。</li>\n<li><p>题目要求最大代价时，记录最大横坐标，二分到一个极值点 <span class=\"math inline\">\\(k&#39;\\ge k\\)</span> 时，显然 <span class=\"math inline\">\\(\\alpha&#39;\\ge \\alpha\\)</span>，用 <span class=\"math inline\">\\(f&#39;_n(k&#39;)-\\alpha&#39;\\cdot k\\)</span> 更新答案（是赋值而不是取最值）；求最小代价时同理。</p>\n<p>主要是需要记住斜率是 <span class=\"math inline\">\\(\\alpha\\)</span> 的相反数，<del>实在搞不清对应关系可以都试一试</del></p></li>\n</ul></li>\n</ul>\n<hr />\n<h3 id=\"例种树\">例：种树</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P1484\" class=\"uri\">https://www.luogu.com.cn/problem/P1484</a></p>\n<p>首先，函数是凸的——感性理解即可。</p>\n<p>接着，要求的是 <span class=\"math inline\">\\(\\le k\\)</span> 时的最值。分为两种情况：<span class=\"math inline\">\\(k\\)</span> 是否右于原函数极值点。</p>\n<ul>\n<li>若 <span class=\"math inline\">\\(k\\)</span> 右于原函数极值点，则原函数极值点为答案。</li>\n<li>否则，<span class=\"math inline\">\\(k\\)</span> 为答案。</li>\n</ul>\n<p>好消息是整数域上一定有解（最后答案为整、倒推即可），所以不用打浮点数二分了。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int lim = 1e6;\nconst long long inf = 1e18;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, k;\n    std::cin &gt;&gt; n &gt;&gt; k;\n    std::vector&lt;long long&gt; a(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i];\n    auto calc = [&amp;](int c) &#123;\n        std::vector&lt;std::pair&lt;long long, int&gt; &gt; f(n + 1);\n        auto mx = f.front();\n        auto upd = [&amp;](auto &amp;x, auto y) &#123;\n            if (y.first &gt; x.first || (y.first == x.first &amp;&amp; y.second &lt; x.second))\n                x = y;\n            return;\n        &#125;;\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            f[i].first = mx.first + a[i] + c;\n            f[i].second = mx.second + 1;\n            upd(mx, f[i - 1]);\n        &#125;\n        upd(mx, f[n]);\n        return mx;\n    &#125;;\n    auto t(calc(0));\n    if (t.second &lt;= k) &#123;\n        std::cout &lt;&lt; t.first &lt;&lt; &#39;\\n&#39;;\n        return 0;\n    &#125;\n    auto res(-inf);\n    for (int l = -lim, r = lim, mid; l &lt;= r; ) &#123;\n        mid = (l + r) &gt;&gt; 1;\n        auto t = calc(mid);\n        if (t.second &lt;= k)\n            res = t.first - (long long)mid * k, l = mid + 1;\n        else\n            r = mid - 1;\n    &#125;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"例raper\">例：Raper</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P4694\" class=\"uri\">https://www.luogu.com.cn/problem/P4694</a></p>\n<p>给所有光盘附一个奖励 <span class=\"math inline\">\\(mid\\)</span>，进行 WQS 二分。</p>\n<p>然后内层就和 <a href=\"#例序列-sequence\">sequence</a> 差得不是特别多，所以考虑反悔贪心。（？）</p>\n<p>把路过的 <span class=\"math inline\">\\(-a_j\\)</span> 丢到大根堆里，尝试和 <span class=\"math inline\">\\(b_i\\)</span> 配对。如果 <span class=\"math inline\">\\(mid-a_i-b_i\\ge 0\\)</span> 那么暂时配对，顺便把 <span class=\"math inline\">\\(b_i-mid\\)</span> 丢进去用于反悔，若 <span class=\"math inline\">\\(b_{i&#39;}\\)</span> 选中了 <span class=\"math inline\">\\(b_i-mid\\)</span> 说明反悔，将 <span class=\"math inline\">\\(a_j\\)</span> 与 <span class=\"math inline\">\\(b_{i&#39;}\\)</span> 配对。</p>\n<p>贪心的时候需要记录已经配的对数，优先队列中需要对 <span class=\"math inline\">\\(-a_j\\)</span> 和 <span class=\"math inline\">\\(b_i-mid\\)</span> 打标记进行区分，匹配到前者时才增加成功对数。</p>\n<p>发现整数域上仍然必有解（答案为整，倒推），不用打浮点数二分 neiher.</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst long long inf = 2e9 + 5;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, k;\n    std::cin &gt;&gt; n &gt;&gt; k;\n    std::vector&lt;int&gt; a(n + 1), b(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i];\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; b[i];\n    auto calc = [&amp;](long long mid) &#123;\n        std::priority_queue&lt;std::pair&lt;long long, int&gt; &gt; q;\n        int cnt = 0;\n        auto res(0ll);\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            q.emplace(-a[i], 1);\n            auto [v, ty] = q.top();\n            if (mid + v - b[i] &gt;= 0) &#123;\n                q.pop(), cnt += ty;\n                res += mid + v - b[i], q.emplace(b[i] - mid, 0);\n            &#125;\n        &#125;\n        return std::make_pair(cnt, res);\n    &#125;;\n    auto res(inf);\n    for (long long l = 1ll, r = inf, mid; l &lt;= r; ) &#123;\n        mid = (l + r) &gt;&gt; 1;\n        auto t(calc(mid));\n        if (t.first &gt;= k)\n            r = mid - 1, res = -(t.second - k * mid);\n        else\n            l = mid + 1;\n    &#125;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"区间分拆问题\">区间分拆问题</h3>\n<p>目标：尝试将 <span class=\"math inline\">\\(a_{1\\sim n}\\)</span> 分割成恰好 <span class=\"math inline\">\\(k\\)</span> 段，定义 <span class=\"math inline\">\\(w(i,j)\\)</span> 为将 <span class=\"math inline\">\\([i,j]\\)</span> 作为一段的代价，求代价最值。其中 <span class=\"math inline\">\\(w(i,j)\\)</span> 满足四边形不等式。</p>\n<p>不妨设求最小代价。定义 <span class=\"math inline\">\\(f(i,j)\\)</span> 在 <span class=\"math inline\">\\(i\\)</span> 处分第 <span class=\"math inline\">\\(j\\)</span> 段，那么有：</p>\n<p><span class=\"math display\">\\[\nf(i,j)=\\min(f(i-1,p-1)+w(p,j)).\n\\]</span></p>\n<blockquote>\n<p>有定理：若 <span class=\"math inline\">\\(w(i,j)\\)</span> 满足四边形不等式，那么有 <span class=\"math inline\">\\(f(i-1,j)\\le f(i,j)\\le f(i,j+1)\\)</span>，从 <span class=\"math inline\">\\(f\\)</span> 定义出发很好感性理解。</p>\n</blockquote>\n<p>那么可以从这一点出发，<span class=\"math inline\">\\(p\\)</span> 这一维就可以被摊掉，做到 <span class=\"math inline\">\\(O(n(n+m))\\)</span>。</p>\n<blockquote>\n<p>有定理：若 <span class=\"math inline\">\\(w(i,j)\\)</span> 满足四边形不等式，那么 <span class=\"math inline\">\\(f_i(j)\\)</span> 是凸函数。</p>\n</blockquote>\n<p>那很好了。直接冲刺 WQS 即可。</p>\n<hr />\n<h2 id=\"闵可夫斯基和\">闵可夫斯基和</h2>\n<p>给定两个凸函数（当然是指 OI 中那种长得很直的函数），将它们的『边』拆下来过后，以某种方式拼在一起，使得最后得到一个新的凸函数。</p>\n<p>按每条『边』的斜率归并一下就可以得到，显然答案存在且唯一，这个过程被称为闵可夫斯基和。可以发现这是一种最值 - 加卷积。</p>\n<p>假设我们要求的 DP 数组是两个已知的子数组以类似的方法卷起来的，最后要求完整的 DP 数组（而非 WQS 中的单点值），就可以考虑闵可夫斯基和。</p>\n<p>发现这个结构是很适合归并的，使用归并要求状态中含有版本维、因变量维。</p>\n<hr />\n<h3 id=\"例its-mooin-time-p\">例：It's Mooin' Time P</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P11459\" class=\"uri\">https://www.luogu.com.cn/problem/P11459</a></p>\n<p>定义 <span class=\"math inline\">\\(w_i\\)</span> 为将 <span class=\"math inline\">\\([i,i+L)\\)</span> 改为 <code>MOO</code> 的代价，问题转化为选取 <span class=\"math inline\">\\(1\\sim \\frac nL\\)</span> 个不重区间的最小代价和。</p>\n<p>尝试归并，每次将 <span class=\"math inline\">\\([l,mid]\\)</span> 和 <span class=\"math inline\">\\((mid, r]\\)</span> 卷起来。但是会有一点问题：如果恰好有区间卡在中间呢？</p>\n<p>可以令 <span class=\"math inline\">\\(f_{l,r,0/1/2,0/1/2}(i)\\)</span> 表示在 <span class=\"math inline\">\\([l,r]\\)</span> 内选了 <span class=\"math inline\">\\(i\\)</span> 个 <code>MOO</code>，且两侧最远的被选点距离端点为 <span class=\"math inline\">\\(0/1/\\ge 2\\)</span> 的 DP 值。然后可以进行相应的讨论、平移、闵可夫斯基和，最后将所有情况线性取 max 得到这一层的答案，容易发现得到的答案也是凸的。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst long long inf = 1e18;\nint L;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    std::cin &gt;&gt; L &gt;&gt; n;\n    std::vector&lt;int&gt; a(n + 1);\n    std::vector&lt;char&gt; t(n + 1);\n    std::vector&lt;long long&gt; w(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; t[i];\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i];\n    for (int i = 1; i &lt;= n - L + 1; ++i) &#123;\n        w[i] = a[i] * (t[i] != &#39;M&#39;);\n        for (int j = i + 1; j &lt; i + L; ++j)\n            w[i] += a[j] * (t[j] != &#39;O&#39;);\n        // printf(&quot;[%d, %d]: %lld\\n&quot;, i, i + L - 1, w[i]);\n    &#125;\n    if (L == 1) &#123;\n        std::sort(w.begin() + 1, w.end());\n        auto s(0ll);\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            s += w[i];\n            std::cout &lt;&lt; s &lt;&lt; &#39;\\n&#39;;\n        &#125;\n        return 0;\n    &#125;\n    using arr = std::vector&lt;long long&gt;;\n    using brr = std::vector&lt;arr&gt;;\n    using crr = std::vector&lt;brr&gt;;\n    struct node &#123;\n        crr f;\n        node(int len): f(L, brr(L, arr(len, inf))) &#123;\n            for (int i = 0; i &lt; L; ++i)\n                for (int j = 0; j &lt; L; ++j)\n                    f[i][j][0] = 0ll;\n            return;\n        &#125;\n        brr&amp; operator[] (int q) &#123; return f[q]; &#125;\n    &#125;;\n    auto upd = [&amp;](arr &amp;x, arr y) &#123;\n        if (x.size() &lt; y.size())\n            x.resize(y.size(), inf);\n        for (int i = 0; i &lt; (int)y.size(); ++i)\n            x[i] = std::min(x[i], y[i]);\n        return;\n    &#125;;\n    auto merge = [&amp;](arr l, arr r) &#123;\n        arr out((int)(l.size() + r.size()) - 1), dl(l.size()), dr(r.size());\n        for (int i = 1; i &lt; (int)l.size(); ++i)\n            dl[i] = l[i] - l[i - 1];\n        for (int i = 1; i &lt; (int)r.size(); ++i)\n            dr[i] = r[i] - r[i - 1];\n        std::merge(dl.begin() + 1, dl.end(), dr.begin() + 1, dr.end(), out.begin() + 1);\n        out[0] = l[0] + r[0];\n        std::partial_sum(out.begin(), out.end(), out.begin());\n        return out;\n    &#125;;\n    std::function&lt;node(int, int)&gt; calc = [&amp;](int l, int r) &#123;\n        if (r - l + 1 &lt; 2 * L) &#123;\n            node res(1);\n            for (int ll = 0; ll &lt; L; ++ll)\n                for (int rr = 0; rr &lt; L; ++rr)\n                    if (l + ll &lt;= r - rr - L + 1) &#123;\n                        res[ll][rr].resize(2, inf);\n                        for (int i = l + ll; i &lt;= r - rr - L + 1; ++i)\n                            res[ll][rr][1] = std::min(res[ll][rr][1], w[i]);\n                        // printf(&quot;[%d, %d]: (%d, %d) = %lld\\n&quot;, l, r, ll, rr, res[ll][rr][1]);\n                    &#125;\n            // for (int i = 0; i &lt; L; ++i)\n            //     if (l + i + L - 1 &lt;= r) &#123;\n            //         printf(&quot;[%d, %d]: (%d, %d) = %lld\\n&quot;, l, r, i, r - (l + i + L - 1), w[l + i]);\n            //         res[i][r - (l + i + L - 1)].emplace_back(w[l + i]);\n            //     &#125;\n            return res;\n        &#125;   \n        int mid = (l + r) &gt;&gt; 1;\n        node tl(calc(l, mid)), tr(calc(mid + 1, r)), res((r - l + 1) / L + 1);\n        for (int ll = 0; ll &lt; L; ++ll)\n            for (int rr = 0; rr &lt; L; ++rr)\n                res[ll][rr] = merge(tl[ll][0], tr[0][rr]);\n        for (int ll = 0; ll &lt; L; ++ll)\n            for (int rr = 0; rr &lt; L; ++rr)\n                for (int i = 1; i &lt; L &amp;&amp; i &lt; mid; ++i)\n                    upd(res[ll][rr], merge(merge(tl[ll][i], tr[L - i][rr]), &#123; 0, w[mid - i + 1] &#125;));\n        for (int ll = 0; ll &lt; L; ++ll)\n            for (int rr = L - 1; rr; --rr)\n                upd(res[ll][rr - 1], res[ll][rr]);\n        for (int rr = 0; rr &lt; L; ++rr)\n            for (int ll = L - 1; ll; --ll)\n                upd(res[ll - 1][rr], res[ll][rr]);\n        // for (int i = 0; i &lt; L; ++i)\n        //     for (int j = 0; j &lt; L; ++j) &#123;\n        //         printf(&quot;  (%d, %d): &quot;, i, j);\n        //         for (auto p : res[i][j])\n        //             printf(&quot;%lld &quot;, p);\n        //         puts(&quot;&quot;);\n        //     &#125;\n        return res;\n    &#125;;\n    auto res(calc(1, n));\n    for (int i = 1; i &lt;= n / L; ++i)\n        std::cout &lt;&lt; res[0][0][i] &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"例假人\">例：假人</h3>\n<p><a href=\"http://222.180.160.110:61235/problem/47728\" class=\"uri\">http://222.180.160.110:61235/problem/47728</a></p>\n<p>令 <span class=\"math inline\">\\(f_{i,j}\\)</span> 表示前 <span class=\"math inline\">\\(i\\)</span> 组选完占了 <span class=\"math inline\">\\(j\\)</span> 体积的最大价值。那么有 <span class=\"math inline\">\\(f_{i,j}=\\max\\{f_{i-1,k}+a_{i,j-k}\\}\\)</span>。</p>\n<p><em>袜，这个东西好凸的样子！啊？居然不是凸的？</em></p>\n<p>事实上，有结论：若干个体积为 <span class=\"math inline\">\\(0\\sim 4\\)</span> 的物品做背包，可以凑出值域内任意 <span class=\"math inline\">\\(24\\)</span> 的倍数。所以先把体积全部 <span class=\"math inline\">\\(-1\\)</span>，然后就可以得到体积为 <span class=\"math inline\">\\(0\\sim 4\\)</span> 的物品。然后会发现他们按照模 <span class=\"math inline\">\\(12\\)</span> 的余数分别是凸的。</p>\n<p>能感受到恶意了。然后就可以枚举体积，再闵可夫斯基和了。同样需要在状态中引入作为版本号的 <span class=\"math inline\">\\([l,r]\\)</span> 维，显然因变量是体积、版本号是组数。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst long long inf = 1e18;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;fake2.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, m = 0;\n    std::cin &gt;&gt; n;\n    std::vector&lt;int&gt; siz(n + 1);\n    std::vector&lt;std::vector&lt;int&gt; &gt; a(n + 1);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; siz[i], m += siz[i];\n        a[i].resize(siz[i] + 1);\n        for (int j = 1; j &lt;= siz[i]; ++j)\n            std::cin &gt;&gt; a[i][j];\n    &#125;\n    using arr = std::vector&lt;long long&gt;;\n    struct node &#123;\n        std::vector&lt;arr&gt; f;\n        node(): f(12) &#123;&#125;\n        arr &amp;operator[] (int q) &#123;\n            return f[q];\n        &#125;\n    &#125;;\n    auto merge = [&amp;](arr &amp;p, arr &amp;q) &#123;\n        arr res((int)(p.size() + q.size()) - 1), dp(p.size()), dq(q.size());\n        std::adjacent_difference(p.begin(), p.end(), dp.begin());\n        std::adjacent_difference(q.begin(), q.end(), dq.begin());\n        std::merge(dp.begin() + 1, dp.end(), dq.begin() + 1, dq.end(), res.begin() + 1, std::greater&lt;long long&gt; ());\n        res[0] = p[0] + q[0];\n        std::partial_sum(res.begin(), res.end(), res.begin());\n        return res;\n    &#125;;\n    auto upd = [&amp;](arr y, arr &amp;x, int tag) &#123;\n        if (tag)\n            y.insert(y.begin(), -inf);\n        if (y.size() &gt; x.size())\n            x.resize(y.size(), -inf);\n        for (int i = 0; i &lt; (int)y.size(); ++i)\n            x[i] = std::max(x[i], y[i]);\n        return;\n    &#125;;\n    std::function&lt;node(int, int)&gt; calc = [&amp;](int l, int r) &#123;\n        if (l == r) &#123;\n            node res;\n            for (int i = 1; i &lt;= siz[l]; ++i)\n                res[i - 1].push_back(a[l][i]);\n            return res;\n        &#125;\n        int mid = (l + r) &gt;&gt; 1;\n        node tl(calc(l, mid)), tr(calc(mid + 1, r)), res;\n        for (int p = 0; p &lt; 12; ++p)\n            for (int q = 0; q &lt; 12; ++q)\n                if (!tl[p].empty() &amp;&amp; !tr[q].empty())\n                    upd(merge(tl[p], tr[q]), res[(p + q) % 12], p + q &gt;= 12);\n        return res;\n    &#125;;\n    auto res(calc(1, n));\n    for (int i = 0; i &lt;= m - n; ++i)\n        std::cout &lt;&lt; res[i % 12][i / 12] &lt;&lt; &#39; &#39;;\n    std::cout &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"slope-trick\">slope trick</h2>\n<p>对于一个 OI 中的凸函数，它是由一些斜率单调的线段拼接成的图形。</p>\n<p>在这个前提下，发现可以用整个函数的左 / 右端点值（截距）和 <span class=\"math inline\">\\((n-1)\\)</span> 个斜率 / 差分信息描述函数。而这有时比直接维护 <span class=\"math inline\">\\(n\\)</span> 个点值有着更优美的性质，唤其为 slope trick。</p>\n<p>例如，关于斜率序列，如果定义域不大，可以直接维护；如果它的变化次数不多，可以利用它的单调性质，用单调数据结构维护；如果它的值域很小，可以直接维护拐点。</p>\n<p>注意前两种方法一般关注横坐标对应的函数值，所以自变量一般是和操作次数一类有关的；而这里关注函数最值而弱化了具体横坐标，操作次数一般会作为待最优化的因变量，例如：</p>\n<ul>\n<li>我想要将数列通过若干次单点修改使序列单调，但不关心序列最终形态，问最小操作次数。</li>\n<li>我想要让树上所有叶子到根的路径边权和相等，但不关心这个值是多少，问最小操作次数。</li>\n</ul>\n<p>下面依次解决上述问题。</p>\n<hr />\n<h3 id=\"例序列-sequence\">例：序列 sequence</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P4597\" class=\"uri\">https://www.luogu.com.cn/problem/P4597</a></p>\n<p>暴力地，令 <span class=\"math inline\">\\(f_{i,j}\\)</span> 表示 <span class=\"math inline\">\\(a_i\\)</span> 最终被修改为 <span class=\"math inline\">\\(j\\)</span>，容易写出 DP 式子 <span class=\"math inline\">\\(f_{i,j}=\\min\\limits_{k\\le j}\\{f_{i-1,k}\\}+|a_i-j|\\)</span>。</p>\n<p>然后就会发现它的定义域实在是太大了！那如果关注斜率的变化情况呢？</p>\n<p>令 <span class=\"math inline\">\\(f_{i-1}(k)\\)</span> 的极值点为 <span class=\"math inline\">\\(k_m\\)</span>，分类讨论拆绝对值和 min：</p>\n<ul>\n<li><p>当 <span class=\"math inline\">\\(j\\le a_i\\)</span> 时，<span class=\"math inline\">\\(f_i(j)=\\min\\limits_{k\\le j}\\{f_{i-1}(k)\\}+a_i - j\\)</span>。</p>\n<ul>\n<li>当 <span class=\"math inline\">\\(j &lt; k_m\\)</span> 时，<span class=\"math inline\">\\(f_i(j)=f_{i-1}(j)+a_i-j\\)</span>，斜率相对于 <span class=\"math inline\">\\(f_{i-1}(j)\\)</span> 整体减 <span class=\"math inline\">\\(1\\)</span>。<del>我就说导数没白学吧</del></li>\n<li>当 <span class=\"math inline\">\\(j \\ge k_m\\)</span> 时，<span class=\"math inline\">\\(f_i(j)=f_{i-1}(k_m)+a_i-j\\)</span>，斜率为 <span class=\"math inline\">\\(-1\\)</span>。</li>\n</ul></li>\n<li><p>当 <span class=\"math inline\">\\(j &gt; a_i\\)</span> 时，<span class=\"math inline\">\\(f_i(j)=\\min\\limits_{k\\le j}\\{f_{i-1}(k)\\}+j-a_i\\)</span>。</p>\n<ul>\n<li>当 <span class=\"math inline\">\\(j &lt; k_m\\)</span> 时，<span class=\"math inline\">\\(f_i(j)=f_{i-1}(j)+j-a_i\\)</span>，斜率相对于 <span class=\"math inline\">\\(f_{i-1}(j)\\)</span> 整体加 <span class=\"math inline\">\\(1\\)</span>。</li>\n<li>当 <span class=\"math inline\">\\(j\\ge k_m\\)</span> 时，<span class=\"math inline\">\\(f_i(j) = f_{i-1}(k_m)+j-a_i\\)</span>，斜率为 <span class=\"math inline\">\\(1\\)</span>。</li>\n</ul></li>\n</ul>\n<p>如果现在我们掏一个支持区间加斜率、区间推平斜率且维护区间函数最值点的数据结构，那就太逆天了。一个经典的解决方案是用堆维护线段斜率的差分（也就是差分的差分）。</p>\n<p>发现整体修改次数是 <span class=\"math inline\">\\(O(n)\\)</span> 的，且如果只看比 <span class=\"math inline\">\\(k_m\\)</span> 更左的 <span class=\"math inline\">\\(j\\)</span>（更靠右的已经与极值无关所以不用维护），那么就只需要维护区间减法。</p>\n<p>如果将一次区间前缀减法看作一次前缀右端点入队，显然左侧某点 <span class=\"math inline\">\\(a\\)</span> 的实际被减次数为 <span class=\"math inline\">\\(a\\)</span> 入队的次数 + 所有右于 <span class=\"math inline\">\\(a\\)</span> 点的元素的入队次数。用大根堆维护这些元素，就可以快速维护整个斜率序列。例如 <code>3 2 2 1</code>，代表 <span class=\"math inline\">\\(3\\)</span> 处斜率为 <span class=\"math inline\">\\(-1\\)</span>，<span class=\"math inline\">\\(2\\)</span> 处斜率为 <span class=\"math inline\">\\(-3\\)</span>，<span class=\"math inline\">\\(1\\)</span> 处斜率为 <span class=\"math inline\">\\(-4\\)</span>。</p>\n<ul>\n<li><p>当 <span class=\"math inline\">\\(a_i\\ge k_m\\)</span> 时（容易发现它会成为新的 <span class=\"math inline\">\\(k_m\\)</span>），直接把 <span class=\"math inline\">\\(a_i\\)</span> 加入大根堆，就可以把 <span class=\"math inline\">\\(\\le a_i\\)</span> 的所有位置斜率减去 <span class=\"math inline\">\\(1\\)</span>。</p>\n什么你问在 <span class=\"math inline\">\\(k_m\\)</span> 和 <span class=\"math inline\">\\(a_i\\)</span> 之间的推平怎么办？由于唯一右于它们的拐点 <span class=\"math inline\">\\(a_i\\)</span> 入了一次队，所以中间的元素斜率自然是 <span class=\"math inline\">\\(-1\\)</span> 啊。</li>\n<li><p>当 <span class=\"math inline\">\\(a_i&lt;k_m\\)</span> 时，我们需要：</p>\n<ol type=\"1\">\n<li>将 <span class=\"math inline\">\\(a_i\\)</span> 以左的位置斜率减去 <span class=\"math inline\">\\(1\\)</span>，直接将 <span class=\"math inline\">\\(a_i\\)</span> 入队即可。</li>\n<li>将 <span class=\"math inline\">\\(a_i\\)</span> 和 <span class=\"math inline\">\\(k_m\\)</span> 之间的位置斜率加上 <span class=\"math inline\">\\(1\\)</span>，把 <span class=\"math inline\">\\(k_m\\)</span> 弹出（太好了就在队首）再把 <span class=\"math inline\">\\(a_i\\)</span> 加入即可。由于 <span class=\"math inline\">\\(k_m\\)</span> 显然是一个拐点，所以删除 <span class=\"math inline\">\\(k_m\\)</span> 并非虚空索敌，但注意 <span class=\"math inline\">\\(k_m\\)</span> 可能会变化成其后继。</li>\n</ol></li>\n</ul>\n<p>其实就会发现还有一些有趣的小性质，比如 <span class=\"math inline\">\\(k_m\\)</span> 与队首等价（用于实现）；<span class=\"math inline\">\\(k_m\\)</span> 右侧斜率全部为 <span class=\"math inline\">\\(1\\)</span>，也是唯一可以取到的正斜率。</p>\n<details>\n<p>袜写起来好简单。</p>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;int&gt; a(n + 1);\n    long long res = 0ll;\n    std::priority_queue&lt;int&gt; q;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; a[i];\n        if (i == 1 || a[i] &gt;= q.top())\n            q.push(a[i]);\n        else &#123;\n            res += q.top() - a[i];\n            q.pop(), q.push(a[i]), q.push(a[i]);\n        &#125;\n    &#125;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"例烟花表演\">例：烟花表演</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P3642\" class=\"uri\">https://www.luogu.com.cn/problem/P3642</a></p>\n<p>设 <span class=\"math inline\">\\(f_{u,d}\\)</span> 表示在 <span class=\"math inline\">\\(u\\)</span> 子树中所有叶子距根均为 <span class=\"math inline\">\\(d\\)</span> 的最小代价。那么有：</p>\n<p><span class=\"math display\">\\[\nf_{u,d}=\\sum\\limits_{(v, w)\\in u}\\min\\limits_{0\\le w&#39;\\le d}\\{f_{v,d-w&#39;}+|w-w&#39;|\\}.\n\\]</span></p>\n<p>可以归纳证明 <span class=\"math inline\">\\(f_{u,d}\\)</span> 为凸；和上一题相似地，考虑用 <span class=\"math inline\">\\(f_v\\)</span> 的堆得到 <span class=\"math inline\">\\(f_u\\)</span> 的堆。</p>\n<p>首先最外层是一个线性加，这其实就是把差分数组 / 斜率加起来，放到我们这个堆里面就是合并两个堆。虽然你可能和我一样不认识可并堆，但是你可以和我一样不会 pd_ds。</p>\n<p>再看内层，发现和上一题长得像但其实不一样，呜呜呜。发现 <span class=\"math inline\">\\(|w-w&#39;|\\)</span> 是一个左右斜率分别为 <span class=\"math inline\">\\(-1,1\\)</span> 的分段函数，而左边类比可得斜率最大为 <span class=\"math inline\">\\(1\\)</span>。</p>\n<p>由闵可夫斯基和，内层函数斜率 <span class=\"math inline\">\\(&lt;-1\\)</span> 的部分来自 <span class=\"math inline\">\\(f_{v,d-w&#39;}\\)</span>；<span class=\"math inline\">\\(=-1\\)</span> 的部分来自 <span class=\"math inline\">\\(f_{v,d-w&#39;}\\)</span> 和 <span class=\"math inline\">\\(|w-w&#39;|\\)</span> 的左半边（感谢 <span class=\"math inline\">\\(w&#39;\\)</span> 是有下确界的）；<span class=\"math inline\">\\(=0\\)</span> 的部分来自 <span class=\"math inline\">\\(f_{v,d-w&#39;}\\)</span>；<span class=\"math inline\">\\(&gt;0\\)</span> 的部分我们不关心。</p>\n<p>最终函数图像的变化：水平部分的左端点右移了 <span class=\"math inline\">\\(w\\)</span>。找到 <span class=\"math inline\">\\(f_{v,d}\\)</span> 中的水平线段和斜率为 <span class=\"math inline\">\\(1\\)</span> 的线段，令其在堆中的值 <span class=\"math inline\">\\(+w\\)</span> 就能达到平移的目的。</p>\n<p>但需要注意，此时仍然需要 <strong>保留内层函数中斜率为 <span class=\"math inline\">\\(1\\)</span> 的部分，但斜率 <span class=\"math inline\">\\(&gt;1\\)</span> 的部分被删除</strong>。原因如下：</p>\n<ul>\n<li>绝对值函数与内层函数定义域相同，作闵可夫斯基和后，斜率为 <span class=\"math inline\">\\(1\\)</span> 的右侧线段会将 <span class=\"math inline\">\\(f_{v,d-w&#39;}\\)</span> 中原有的 <span class=\"math inline\">\\(&gt;1\\)</span> 的部分『挤』出定义域，故可以将其直接删除。</li>\n<li>斜率为 <span class=\"math inline\">\\(1\\)</span> 的部分，虽然对内层函数中极值点无贡献，但在外层函数中极值点可能向右偏移，此时会对其产生影响，需要维护。</li>\n</ul>\n<p>容易发现由于 <span class=\"math inline\">\\(w&#39;\\)</span> 的取值上限是 <span class=\"math inline\">\\(d\\)</span>，但 <span class=\"math inline\">\\(d\\)</span> 没有上界，所以每个内层函数的右侧都一定是一条斜率为 <span class=\"math inline\">\\(1\\)</span> 的射线；也就是说，每个外层函数一定有（儿子个数）个拐点（堆中元素），弹出这么多个就可以删除外层函数中斜率 <span class=\"math inline\">\\(&gt;1\\)</span> 的线段，顺便找到斜率为 <span class=\"math inline\">\\(0\\)</span> 和 <span class=\"math inline\">\\(1\\)</span> 的线段。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\n#include &lt;ext/pb_ds/priority_queue.hpp&gt;\nconst int inf= 0x3f3f3f3f;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, m;\n    std::cin &gt;&gt; n &gt;&gt; m, n += m;\n    std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; g(n + 1);\n    auto res(0ll);\n    for (int i = 2, fa, w; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; fa &gt;&gt; w, res += w;\n        g[fa].emplace_back(i, w);\n    &#125;\n    std::vector&lt;__gnu_pbds::priority_queue&lt;long long&gt; &gt; q(n + 1);\n    std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;\n        if (g[x].empty())\n            q[x].push(0), q[x].push(0);\n        else\n            for (auto [i, w] : g[x]) &#123;\n                DFS(i);\n                for (int j = 1; j &lt; (int)g[i].size(); ++j)\n                    q[i].pop();\n                long long t1 = q[i].top(), t0;\n                q[i].pop(), t0 = q[i].top(), q[i].pop();\n                q[i].push(t1 + w), q[i].push(t0 + w);\n                q[x].join(q[i]);\n            &#125;\n        // fprintf(stderr, &quot;size(%d) = %d\\n&quot;, x, (int)q[x].size());\n        return;\n    &#125;;\n    DFS(1);\n    for (int i = 1; i &lt;= (int)g[1].size(); ++i)\n        q[1].pop();\n    for (; !q[1].empty(); q[1].pop())\n        res -= q[1].top();\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"例buy-low-sell-high\">例：Buy Low Sell High</h3>\n<p><a href=\"https://codeforces.com/problemset/problem/865/D\" class=\"uri\">https://codeforces.com/problemset/problem/865/D</a></p>\n<p>令 <span class=\"math inline\">\\(f_{i,j}\\)</span> 表示在第 <span class=\"math inline\">\\(i\\)</span> 天结束后持有 <span class=\"math inline\">\\(j\\)</span> 支股票的最大收益。则 <span class=\"math inline\">\\(f_{i,j}=\\max\\{f_{i-1,j},f_{i-1,j-1}-a_i,f_{i-1,j+1}+a_i\\}\\)</span>。</p>\n<p>（由于这里和 max 有关所以需要精细描述凹凸了）发现就是把三个（可能）经过平移的（可能）凹的函数做线性 max。虽然实际上的结论『函数在整点上是凹的』不算太显然，但是可以猜是凹的。</p>\n<p>线性 max 在 slope trick 中是不太能体现的，但我们发现这里是同一个凹函数向左上、右下平移同一个向量，希望得到新的凹函数不管是从差分角度还是图象，都能得到新函数由左上部分斜率 <span class=\"math inline\">\\(&gt;-a_i\\)</span> 的线段、两段斜率 <span class=\"math inline\">\\(=-a_i\\)</span> 的线段、右下部分斜率 <span class=\"math inline\">\\(&lt;-a_i\\)</span> 的线段组成。此外，由于向左上平移的函数有一处离开了定义域，还需将其剔除。</p>\n<p>值得注意的是，当 <span class=\"math inline\">\\(-a_i\\)</span> 比最小斜率还要小时会有变化，可以画图看一下。</p>\n<p><img src=\"2.png\" /></p>\n<p>发现定义域是相对小的（<span class=\"math inline\">\\(0\\le j\\le n\\)</span>），故用优先队列维护整个斜率序列就可以快速插入两个 <span class=\"math inline\">\\(k=-a_i\\)</span> 的线段。容易发现顶点在 <span class=\"math inline\">\\(j=0\\)</span> 处取得（从图象和定义都易知），最右侧是只买不卖的最劣方案，可以倒推。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;int&gt; a(n + 1);\n    auto res = 0ll;\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i], res -= a[i];\n    std::priority_queue&lt;int&gt; q;\n    q.push(-a[1]);\n    for (int i = 2; i &lt;= n; ++i)\n        if (a[i] &lt; -q.top())\n            q.push(-a[i]);\n        else\n            q.pop(), q.push(-a[i]), q.push(-a[i]);\n    for (; !q.empty(); res -= q.top(), q.pop());\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n",
            "tags": [
                "DP",
                "反悔贪心",
                "DP 优化",
                "WQS 二分",
                "闵可夫斯基和",
                "slope trick"
            ]
        }
    ]
}