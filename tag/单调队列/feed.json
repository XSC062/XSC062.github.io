{
    "version": "https://jsonfeed.org/version/1",
    "title": "null • All posts by \"单调队列\" tag",
    "description": "",
    "home_page_url": "https://xsc062.netlify.app",
    "items": [
        {
            "id": "https://xsc062.netlify.app/20230111/",
            "url": "https://xsc062.netlify.app/20230111/",
            "title": "瑰丽华尔兹",
            "date_published": "2023-01-10T18:21:35.000Z",
            "content_html": "<p>Solution to<a href=\"http://222.180.160.110:61235/problem/8965\">「NOI2005」瑰丽华尔兹</a>。</p>\n<span id=\"more\"></span>\n<hr />\n<p>单调队列优化 DP。</p>\n<p>不难发现，题意可转化为：</p>\n<p>从 <span class=\"math inline\">\\((x,y)\\)</span> 出发，按顺序向 <span class=\"math inline\">\\(d_i\\)</span> 方向移动 <span class=\"math inline\">\\([0,t_i−s_i+1]\\)</span> 距离，问最大移动距离。</p>\n<p>为了方便描述，我们把一次「向 <span class=\"math inline\">\\(d_i\\)</span> 方向移动 <span class=\"math inline\">\\([0,t_i−s_i+1]\\)</span> 距离」的操作称为「一步」。</p>\n<p>设计状态。不难发现位置信息必须出现在 DP 的维度中（因为当前位置会影响下一步滑动的距离），而其他信息均不会对下一步滑动产生影响。</p>\n<p>故可令 <span class=\"math inline\">\\(f_{i,j}\\)</span> 表示完成当前次滑动后，从起点滑动到 <span class=\"math inline\">\\((i,j)\\)</span> 可得到的最大滑动距离。</p>\n<p>以方向上为例，可列 DP 式：</p>\n<p><span class=\"math display\">\\[\nf_{i,j}=\\max_{i&lt;k≤i+(ti−si+1)}\\{f_{k,j}+k−i\\}\n\\]</span></p>\n<p>此时可枚举每一列的所有状态，使用单调队列优化。</p>\n<p>但实际操作中会出现问题。因为单调队列从下向上更新状态时，<span class=\"math inline\">\\(f_{k,j}\\)</span> 会比 <span class=\"math inline\">\\(f_{i,j}\\)</span> 先更新（参考 01 背包倒序枚举容量），导致每一「步」会重复被走很多次。但单调队列的特性限制了我们只能从下向上枚举，此时可新开一个数组记录 <span class=\"math inline\">\\(f\\)</span> 当次被更新之前的值。</p>\n<p>障碍物如何处理呢？我们知道，如果 <span class=\"math inline\">\\((i,j)\\)</span> 下面某一位置有障碍物，那么障碍物下面所有的 <span class=\"math inline\">\\((k,j)\\)</span> 都不能用于更新 <span class=\"math inline\">\\(f_{i,j}\\)</span>（因为被挡住了滑不上来）。所以我们在从下往上枚举时，遇到障碍物就清空单调队列即可。</p>\n<p>下、左、右方向的处理方式类似。</p>\n<p>只需顺序执行操作，根据当前操作方向对应处理即可。</p>\n<details>\n<pre class=\"cpp\"><code>namespace XSC062 &#123;\nusing namespace fastIO;\nconst int maxn = 205;\nconst int inf = 1e18;\nint q[maxn];\nchar a[maxn][maxn];\nint f[maxn][maxn], d[maxn][maxn];\nint n, m, x, y, k, u, h, t, res;\nint max(int x, int y) &#123;\n    return x &gt; y ? x : y;\n&#125;\nint main() &#123;\n    memset(f, -0x3f, sizeof (f));\n    read(n), read(m);\n    read(x), read(y), read(k);\n    f[x][y] = 0;\n    for (int i = 1; i &lt;= n; ++i)\n        scanf(&quot;%s&quot;, a[i] + 1);\n    while (k--) &#123;\n        read(x), read(y), read(u);\n        y = y - x + 1;\n        if (u == 1) &#123;\n            for (int j = 1; j &lt;= m; ++j) &#123;\n                h = 1, t = 0;\n                for (int i = n; i; --i) &#123;\n                    if (a[i][j] == &#39;x&#39;) &#123;\n                        h = 1, t = 0;\n                        continue;\n                    &#125;\n                    while (h &lt;= t &amp;&amp; q[h] - i &gt; y)\n                        ++h;\n                    d[i][j] = f[i][j];\n                    if (h &lt;= t) &#123;\n                        f[i][j] = max(f[i][j],\n                                    d[q[h]][j] + q[h] - i);\n                    &#125;\n                    while (h &lt;= t &amp;&amp; d[i][j] + i\n                                    &gt;= d[q[t]][j] + q[t])\n                        --t;\n                    q[++t] = i;\n                &#125;\n            &#125;\n        &#125;\n        else if (u == 2) &#123;\n            for (int j = 1; j &lt;= m; ++j) &#123;\n                h = 1, t = 0;\n                for (int i = 1; i &lt;= n; ++i) &#123;\n                    if (a[i][j] == &#39;x&#39;) &#123;\n                        h = 1, t = 0;\n                        continue;\n                    &#125;\n                    while (h &lt;= t &amp;&amp; i - q[h] &gt; y)\n                        ++h;\n                    d[i][j] = f[i][j];\n                    if (h &lt;= t) &#123;\n                        f[i][j] = max(f[i][j],\n                                    d[q[h]][j] + i - q[h]);\n                    &#125;\n                    while (h &lt;= t &amp;&amp; d[i][j] - i\n                                &gt;= d[q[t]][j] - q[t])\n                        --t;\n                    q[++t] = i;\n                &#125;\n            &#125;\n        &#125;\n        else if (u == 3) &#123;\n            for (int i = 1; i &lt;= n; ++i) &#123;\n                h = 1, t = 0;\n                for (int j = m; j; --j) &#123;\n                    if (a[i][j] == &#39;x&#39;) &#123;\n                        h = 1, t = 0;\n                        continue;\n                    &#125;\n                    while (h &lt;= t &amp;&amp; q[h] - j &gt; y)\n                        ++h;\n                    d[i][j] = f[i][j];\n                    if (h &lt;= t) &#123;\n                        f[i][j] = max(f[i][j],\n                                    d[i][q[h]] + q[h] - j);\n                    &#125;\n                    while (h &lt;= t &amp;&amp; d[i][j] + j\n                                &gt;= d[i][q[t]] + q[t])\n                        --t;\n                    q[++t] = j;\n                &#125;\n            &#125;\n        &#125;\n        else &#123;\n            for (int i = 1; i &lt;= n; ++i) &#123;\n                h = 1, t = 0;\n                for (int j = 1; j &lt;= m; ++j) &#123;\n                    if (a[i][j] == &#39;x&#39;) &#123;\n                        h = 1, t = 0;\n                        continue;\n                    &#125;\n                    while (h &lt;= t &amp;&amp; j - q[h] &gt; y)\n                        ++h;\n                    d[i][j] = f[i][j];\n                    if (h &lt;= t) &#123;\n                        f[i][j] = max(f[i][j],\n                                    d[i][q[h]] + j - q[h]);\n                    &#125;\n                    while (h &lt;= t &amp;&amp; d[i][j] - j\n                                &gt;= d[i][q[t]] - q[t])\n                        --t;\n                    q[++t] = j;\n                &#125;\n            &#125;\n        &#125;\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            for (int j = 1; j &lt;= m; ++j)\n                res = max(res, f[i][j]);\n        &#125;\n    &#125;\n    print(res);\n    return 0;\n&#125;\n&#125; // namespace XSC062</code></pre>\n</details>\n",
            "tags": [
                "DP",
                "单调队列"
            ]
        }
    ]
}