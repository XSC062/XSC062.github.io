{
    "version": "https://jsonfeed.org/version/1",
    "title": "null • All posts by \"crt / excrt\" tag",
    "description": "",
    "home_page_url": "https://xsc062.netlify.app",
    "items": [
        {
            "id": "https://xsc062.netlify.app/20230527/",
            "url": "https://xsc062.netlify.app/20230527/",
            "title": "中国剩余定理",
            "date_published": "2023-05-27T09:12:13.000Z",
            "content_html": "<p>upd on 04/27/25：发现该文没写完 <img src=\"/em/qd.gif\" /></p>\n<span id=\"more\"></span>\n<hr />\n<h2 id=\"中国剩余定理\">中国剩余定理</h2>\n<p>给定下列关于 <span class=\"math inline\">\\(x\\)</span> 的一元同余方程组：</p>\n<p><span class=\"math display\">\\[\n\\begin {cases}\nx \\equiv a_1 \\pmod {m_1}  \\\\\nx \\equiv a_2 \\pmod {m_2}  \\\\\n\\quad \\quad \\vdots \\\\\nx \\equiv a_k \\pmod {m_k}\n\\end {cases}\n\\]</span> 其中对于 <span class=\"math inline\">\\(\\forall \\, 1\\le i, j\\le k\\, (i\\ne j)\\)</span>，满足 <span class=\"math inline\">\\(m_i \\, \\bot\\, m_j\\)</span>。下面是求解该方程组的具体方法：</p>\n<p>令 <span class=\"math inline\">\\(M = \\prod \\limits _{i = 1} ^ k m_i, \\, M_i=\\dfrac M {m_i}\\)</span>，则 <span class=\"math inline\">\\(x = \\sum \\limits _{i = 1} ^k a_i\\times M_i\\times M_i ^{-1} \\pmod M\\)</span>。</p>\n<p>其中，<span class=\"math inline\">\\(M_i^{-1}\\)</span> 是 <span class=\"math inline\">\\(M_i\\)</span> 在模 <span class=\"math inline\">\\(m_i\\)</span> 意义下的逆元（所以 <span class=\"math inline\">\\(M_i\\times M_i^{-1}\\)</span> 的值并不是视觉上的 <span class=\"math inline\">\\(1\\)</span>）。</p>\n<p>正确性证明：对于 <span class=\"math inline\">\\(\\forall \\, i\\in \\{1, 2, \\cdots, k\\}\\)</span>，有 <span class=\"math inline\">\\(M_i\\mid M\\)</span>；对于 <span class=\"math inline\">\\(\\forall \\, j\\in \\{1, 2, \\cdots, k\\}\\)</span> 且 <span class=\"math inline\">\\(j\\ne i\\)</span>，有 <span class=\"math inline\">\\(m_i\\mid \\dfrac M{m_j}\\)</span> 即 <span class=\"math inline\">\\(m_i\\mid M_j\\)</span>，即 <span class=\"math inline\">\\(M_j\\equiv 0\\pmod {m_i}\\)</span>。</p>\n<p>又 <span class=\"math inline\">\\(m_i\\mid M\\)</span> 那么就有 <span class=\"math inline\">\\(x\\equiv a_i\\cdot M_i\\cdot {M_i}^{-1}\\equiv a_i\\pmod {n_i}\\)</span>。</p>\n<p>时间复杂度 <span class=\"math inline\">\\(\\mathcal O(n\\log n)\\)</span>。注意求解逆元时要用到 exgcd。</p>\n<details>\n<pre class=\"cpp\"><code>int CRT(int k, int *a, int *m) &#123;\n    int M = 1, x = 0;\n    static int M1[maxn], Mi[maxn]; \n    for (int i = 1; i &lt;= k; ++i)\n        M *= m[i];\n    for (int i = 1; i &lt;= k; ++i) &#123;\n        M1[i] = M / m[i];\n        Mi[i] = getinv(M1[i], m[i]);\n        (x += a[i] * M1[i] * Mi[i]) %= M;\n    &#125;\n    return x;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"扩展中国剩余定理\">扩展中国剩余定理</h2>\n<p>设有如下同余方程组：</p>\n<p><span class=\"math display\">\\[\n\\begin {cases}\nx \\equiv a_1 \\pmod {m_1} \\\\\nx \\equiv a_2 \\pmod {m_2}\n\\end {cases}\n\\]</span></p>\n<p>不保证 <span class=\"math inline\">\\(m_1 \\, \\bot \\, m_2\\)</span>。</p>\n<p>设 <span class=\"math inline\">\\(x = m_1 \\times p_1 + a_1 = m_2 \\times p_2 + a_2\\)</span>，其中 <span class=\"math inline\">\\(p_i \\in \\mathbb Z\\)</span>，则有 <span class=\"math inline\">\\(p_1 \\times m_1 - p_2 \\times m_2 = a_2 - a_1\\)</span>。</p>\n<p><span class=\"math inline\">\\(p_1\\)</span> 的值可以用 exgcd 求解，则原方程的解满足 <span class=\"math inline\">\\(x \\equiv m_1\\times p_1 + a_1 \\pmod {M}\\)</span>，其中 <span class=\"math inline\">\\(M=\\operatorname{lcm}(m_1, m_2)\\)</span>。</p>\n<p>这样我们就得到了一个新的同余方程。对于 <span class=\"math inline\">\\(k&gt;2\\)</span> 的情况，我们不断合并两个同余方程即可得到最终同余方程。</p>\n<p>此时根据题目要求（一般求最小值即 <span class=\"math inline\">\\(m_k\\times p_k + a_k\\)</span>）求解答案即可。</p>\n<p>时间复杂度 <span class=\"math inline\">\\(\\mathcal O(n\\log n)\\)</span>，其中 <span class=\"math inline\">\\(\\log\\)</span> 来自 exgcd。</p>\n<details>\n<pre class=\"cpp\"><code>int calc(int m1, int a1, int m2, int a2) &#123;\n    int p1, p2;\n    if (a2 - a1 &lt; 0)\n        swap(a1, a2), swap(m1, m2);\n    int g = exgcd(m1, p1, m2, p2);\n    if ((a2 - a1) % g)\n        return -1;\n    p1 *= (a2 - a1) / g, m2 /= g;\n    p1 = (p1 % m2 + m2) % m2;\n    return p1 * m1 + a1;\n&#125;\nint exCRT(int k, int *a, int *m) &#123;\n    for (int i = 2; i &lt;= k; ++i) &#123;\n        a[i] = calc(m[i - 1],\n                a[i - 1], m[i], a[i]);\n        if (a[i] == -1)\n            return -1;\n        m[i] = lcm(m[i - 1], m[i]);\n    &#125;\n    return a[k] % m[k];\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"d.-strange-way-to-express-integers\">D. Strange Way to Express Integers</h3>\n<p><a href=\"http://222.180.160.110:1024/contest/3642/problem/4\" class=\"uri\">http://222.180.160.110:1024/contest/3642/problem/4</a></p>\n<p>板。但是要开 <code>__int128</code>。不知道为什么智力只用开 <code>long long</code> 就能跑过，我和揭哥就不行。</p>\n<details>\n<pre class=\"cpp\"><code>#define int __int128\nnamespace XSC062 &#123;\nusing namespace fastIO;\nconst int maxn = 1e5 + 5;\nint n;\nint a[maxn], m[maxn];\nint gcd(int x, int y) &#123;\n    return y ? gcd(y, x % y) : x;\n&#125;\ninline int lcm(int x, int y) &#123;\n    return x / gcd(x, y) * y;\n&#125;\ninline void swap(int &amp;x, int &amp;y) &#123;\n    x ^= y ^= x ^= y;\n    return;\n&#125;\nint exgcd(int a, int &amp;x, int b, int &amp;y) &#123;\n    if (b == 0) &#123;\n        x = 1, y = 0;\n        return a;\n    &#125;\n    int u = exgcd(b, x, a % b, y);\n    int t = x;\n    x = y, y = t - (a / b) * y;\n    return u;\n&#125;\ninline int calc(int m1, int a1,\n                    int m2, int a2) &#123;\n    int p1, p2;\n    if (a2 - a1 &lt; 0)\n        swap(a1, a2), swap(m1, m2);\n    int g = exgcd(m1, p1, m2, p2);\n    if ((a2 - a1) % g)\n        return -1;\n    p1 *= (a2 - a1) / g, m2 /= g;\n    p1 = (p1 % m2 + m2) % m2;\n    return p1 * m1 + a1;\n&#125;\ninline int exCRT(int k, int *a, int *m) &#123;\n    for (int i = 2; i &lt;= k; ++i) &#123;\n        a[i] = calc(m[i - 1],\n                a[i - 1], m[i], a[i]);\n        if (a[i] == -1)\n            return -1;\n        m[i] = lcm(m[i - 1], m[i]);\n    &#125;\n    return a[k] % m[k];\n&#125;\nint main() &#123;\n    while (read(n)) &#123;\n        for (int i = 1; i &lt;= n; ++i)\n            read(m[i]), read(a[i]);\n        print(exCRT(n, a, m), &#39;\\n&#39;);\n    &#125;\n    return 0;\n&#125;\n&#125; // namespace XSC062\n#undef int</code></pre>\n</details>\n",
            "tags": [
                "CRT / exCRT"
            ]
        }
    ]
}