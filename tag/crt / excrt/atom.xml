<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://xsc062.netlify.app</id>
    <title> • Posts by &#34;crt / excrt&#34; tag</title>
    <link href="https://xsc062.netlify.app" />
    <updated>2023-05-27T09:12:13.000Z</updated>
    <category term="并查集" />
    <category term="斜率优化" />
    <category term="悬线法" />
    <category term="哈希" />
    <category term="字典树" />
    <category term="DP" />
    <category term="单调队列" />
    <category term="分治" />
    <category term="二分图" />
    <category term="CRT / exCRT" />
    <category term="排列组合" />
    <category term="网络流" />
    <category term="费用流" />
    <category term="二分" />
    <category term="上下界网络流" />
    <category term="容斥原理" />
    <category term="线段树" />
    <category term="树状数组" />
    <category term="区间 DP" />
    <category term="构造" />
    <category term="Tarjan" />
    <category term="数据结构" />
    <category term="下饭" />
    <category term="LCA" />
    <category term="倍增" />
    <category term="鸽巢原理" />
    <category term="概率期望" />
    <category term="调和级数" />
    <category term="差分" />
    <category term="思维" />
    <category term="树形 DP" />
    <category term="最小生成树" />
    <category term="SAM" />
    <category term="状压" />
    <category term="分块" />
    <category term="可持久化" />
    <category term="笛卡尔树" />
    <category term="高维前缀和" />
    <category term="闲话" />
    <category term="欧拉回路" />
    <category term="树链剖分" />
    <category term="长链剖分" />
    <category term="KMP" />
    <category term="border" />
    <category term="字符串" />
    <category term="AC 自动机" />
    <category term="SA" />
    <category term="数学" />
    <category term="树上差分" />
    <category term="FWT" />
    <category term="堆" />
    <category term="树的重心" />
    <category term="二项式定理" />
    <category term="二项式反演" />
    <category term="贪心" />
    <category term="均摊" />
    <category term="计数" />
    <category term="优化建图" />
    <category term="反悔贪心" />
    <category term="调整法" />
    <category term="背包" />
    <category term="博弈论" />
    <category term="DP 优化" />
    <category term="虚树" />
    <category term="点分治" />
    <category term="WQS 二分" />
    <category term="闵可夫斯基和" />
    <category term="slope trick" />
    <category term="四边形不等式" />
    <category term="暴力" />
    <category term="状压 DP" />
    <category term="组合数学" />
    <category term="支配对" />
    <category term="DDP" />
    <category term="平衡树" />
    <category term="容斥" />
    <category term="猫树" />
    <category term="Kruskal 重构树" />
    <category term="李超线段树" />
    <entry>
        <id>https://xsc062.netlify.app/20230527/</id>
        <title>中国剩余定理</title>
        <link rel="alternate" href="https://xsc062.netlify.app/20230527/"/>
        <content type="html">&lt;p&gt;upd on 04/27/25：发现该文没写完 &lt;img src=&#34;/em/qd.gif&#34; /&gt;&lt;/p&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;中国剩余定理&#34;&gt;中国剩余定理&lt;/h2&gt;
&lt;p&gt;给定下列关于 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 的一元同余方程组：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
\begin {cases}
x \equiv a_1 \pmod {m_1}  \\
x \equiv a_2 \pmod {m_2}  \\
\quad \quad \vdots \\
x \equiv a_k \pmod {m_k}
\end {cases}
\]&lt;/span&gt; 其中对于 &lt;span class=&#34;math inline&#34;&gt;\(\forall \, 1\le i, j\le k\, (i\ne j)\)&lt;/span&gt;，满足 &lt;span class=&#34;math inline&#34;&gt;\(m_i \, \bot\, m_j\)&lt;/span&gt;。下面是求解该方程组的具体方法：&lt;/p&gt;
&lt;p&gt;令 &lt;span class=&#34;math inline&#34;&gt;\(M = \prod \limits _{i = 1} ^ k m_i, \, M_i=\dfrac M {m_i}\)&lt;/span&gt;，则 &lt;span class=&#34;math inline&#34;&gt;\(x = \sum \limits _{i = 1} ^k a_i\times M_i\times M_i ^{-1} \pmod M\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;其中，&lt;span class=&#34;math inline&#34;&gt;\(M_i^{-1}\)&lt;/span&gt; 是 &lt;span class=&#34;math inline&#34;&gt;\(M_i\)&lt;/span&gt; 在模 &lt;span class=&#34;math inline&#34;&gt;\(m_i\)&lt;/span&gt; 意义下的逆元（所以 &lt;span class=&#34;math inline&#34;&gt;\(M_i\times M_i^{-1}\)&lt;/span&gt; 的值并不是视觉上的 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt;）。&lt;/p&gt;
&lt;p&gt;正确性证明：对于 &lt;span class=&#34;math inline&#34;&gt;\(\forall \, i\in \{1, 2, \cdots, k\}\)&lt;/span&gt;，有 &lt;span class=&#34;math inline&#34;&gt;\(M_i\mid M\)&lt;/span&gt;；对于 &lt;span class=&#34;math inline&#34;&gt;\(\forall \, j\in \{1, 2, \cdots, k\}\)&lt;/span&gt; 且 &lt;span class=&#34;math inline&#34;&gt;\(j\ne i\)&lt;/span&gt;，有 &lt;span class=&#34;math inline&#34;&gt;\(m_i\mid \dfrac M{m_j}\)&lt;/span&gt; 即 &lt;span class=&#34;math inline&#34;&gt;\(m_i\mid M_j\)&lt;/span&gt;，即 &lt;span class=&#34;math inline&#34;&gt;\(M_j\equiv 0\pmod {m_i}\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;又 &lt;span class=&#34;math inline&#34;&gt;\(m_i\mid M\)&lt;/span&gt; 那么就有 &lt;span class=&#34;math inline&#34;&gt;\(x\equiv a_i\cdot M_i\cdot {M_i}^{-1}\equiv a_i\pmod {n_i}\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;时间复杂度 &lt;span class=&#34;math inline&#34;&gt;\(\mathcal O(n\log n)\)&lt;/span&gt;。注意求解逆元时要用到 exgcd。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;int CRT(int k, int *a, int *m) &amp;#123;
    int M = 1, x = 0;
    static int M1[maxn], Mi[maxn]; 
    for (int i = 1; i &amp;lt;= k; ++i)
        M *= m[i];
    for (int i = 1; i &amp;lt;= k; ++i) &amp;#123;
        M1[i] = M / m[i];
        Mi[i] = getinv(M1[i], m[i]);
        (x += a[i] * M1[i] * Mi[i]) %= M;
    &amp;#125;
    return x;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;扩展中国剩余定理&#34;&gt;扩展中国剩余定理&lt;/h2&gt;
&lt;p&gt;设有如下同余方程组：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
\begin {cases}
x \equiv a_1 \pmod {m_1} \\
x \equiv a_2 \pmod {m_2}
\end {cases}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;不保证 &lt;span class=&#34;math inline&#34;&gt;\(m_1 \, \bot \, m_2\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;设 &lt;span class=&#34;math inline&#34;&gt;\(x = m_1 \times p_1 + a_1 = m_2 \times p_2 + a_2\)&lt;/span&gt;，其中 &lt;span class=&#34;math inline&#34;&gt;\(p_i \in \mathbb Z\)&lt;/span&gt;，则有 &lt;span class=&#34;math inline&#34;&gt;\(p_1 \times m_1 - p_2 \times m_2 = a_2 - a_1\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(p_1\)&lt;/span&gt; 的值可以用 exgcd 求解，则原方程的解满足 &lt;span class=&#34;math inline&#34;&gt;\(x \equiv m_1\times p_1 + a_1 \pmod {M}\)&lt;/span&gt;，其中 &lt;span class=&#34;math inline&#34;&gt;\(M=\operatorname{lcm}(m_1, m_2)\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;这样我们就得到了一个新的同余方程。对于 &lt;span class=&#34;math inline&#34;&gt;\(k&amp;gt;2\)&lt;/span&gt; 的情况，我们不断合并两个同余方程即可得到最终同余方程。&lt;/p&gt;
&lt;p&gt;此时根据题目要求（一般求最小值即 &lt;span class=&#34;math inline&#34;&gt;\(m_k\times p_k + a_k\)&lt;/span&gt;）求解答案即可。&lt;/p&gt;
&lt;p&gt;时间复杂度 &lt;span class=&#34;math inline&#34;&gt;\(\mathcal O(n\log n)\)&lt;/span&gt;，其中 &lt;span class=&#34;math inline&#34;&gt;\(\log\)&lt;/span&gt; 来自 exgcd。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;int calc(int m1, int a1, int m2, int a2) &amp;#123;
    int p1, p2;
    if (a2 - a1 &amp;lt; 0)
        swap(a1, a2), swap(m1, m2);
    int g = exgcd(m1, p1, m2, p2);
    if ((a2 - a1) % g)
        return -1;
    p1 *= (a2 - a1) / g, m2 /= g;
    p1 = (p1 % m2 + m2) % m2;
    return p1 * m1 + a1;
&amp;#125;
int exCRT(int k, int *a, int *m) &amp;#123;
    for (int i = 2; i &amp;lt;= k; ++i) &amp;#123;
        a[i] = calc(m[i - 1],
                a[i - 1], m[i], a[i]);
        if (a[i] == -1)
            return -1;
        m[i] = lcm(m[i - 1], m[i]);
    &amp;#125;
    return a[k] % m[k];
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;d.-strange-way-to-express-integers&#34;&gt;D. Strange Way to Express Integers&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;http://222.180.160.110:1024/contest/3642/problem/4&#34; class=&#34;uri&#34;&gt;http://222.180.160.110:1024/contest/3642/problem/4&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;板。但是要开 &lt;code&gt;__int128&lt;/code&gt;。不知道为什么智力只用开 &lt;code&gt;long long&lt;/code&gt; 就能跑过，我和揭哥就不行。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#define int __int128
namespace XSC062 &amp;#123;
using namespace fastIO;
const int maxn = 1e5 + 5;
int n;
int a[maxn], m[maxn];
int gcd(int x, int y) &amp;#123;
    return y ? gcd(y, x % y) : x;
&amp;#125;
inline int lcm(int x, int y) &amp;#123;
    return x / gcd(x, y) * y;
&amp;#125;
inline void swap(int &amp;amp;x, int &amp;amp;y) &amp;#123;
    x ^= y ^= x ^= y;
    return;
&amp;#125;
int exgcd(int a, int &amp;amp;x, int b, int &amp;amp;y) &amp;#123;
    if (b == 0) &amp;#123;
        x = 1, y = 0;
        return a;
    &amp;#125;
    int u = exgcd(b, x, a % b, y);
    int t = x;
    x = y, y = t - (a / b) * y;
    return u;
&amp;#125;
inline int calc(int m1, int a1,
                    int m2, int a2) &amp;#123;
    int p1, p2;
    if (a2 - a1 &amp;lt; 0)
        swap(a1, a2), swap(m1, m2);
    int g = exgcd(m1, p1, m2, p2);
    if ((a2 - a1) % g)
        return -1;
    p1 *= (a2 - a1) / g, m2 /= g;
    p1 = (p1 % m2 + m2) % m2;
    return p1 * m1 + a1;
&amp;#125;
inline int exCRT(int k, int *a, int *m) &amp;#123;
    for (int i = 2; i &amp;lt;= k; ++i) &amp;#123;
        a[i] = calc(m[i - 1],
                a[i - 1], m[i], a[i]);
        if (a[i] == -1)
            return -1;
        m[i] = lcm(m[i - 1], m[i]);
    &amp;#125;
    return a[k] % m[k];
&amp;#125;
int main() &amp;#123;
    while (read(n)) &amp;#123;
        for (int i = 1; i &amp;lt;= n; ++i)
            read(m[i]), read(a[i]);
        print(exCRT(n, a, m), &amp;#39;\n&amp;#39;);
    &amp;#125;
    return 0;
&amp;#125;
&amp;#125; // namespace XSC062
#undef int&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
</content>
        <category term="CRT / exCRT" />
        <updated>2023-05-27T09:12:13.000Z</updated>
    </entry>
</feed>
