<?xml version="1.0"?>
<rss version="2.0">
    <channel>
        <title> • Posts by &#34;crt / excrt&#34; tag</title>
        <link>https://xsc062.netlify.app</link>
        <description></description>
        <language>zh-CN</language>
        <pubDate>Sat, 27 May 2023 17:12:13 +0800</pubDate>
        <lastBuildDate>Sat, 27 May 2023 17:12:13 +0800</lastBuildDate>
        <category>并查集</category>
        <category>斜率优化</category>
        <category>悬线法</category>
        <category>哈希</category>
        <category>字典树</category>
        <category>DP</category>
        <category>单调队列</category>
        <category>分治</category>
        <category>二分图</category>
        <category>CRT / exCRT</category>
        <category>排列组合</category>
        <category>网络流</category>
        <category>费用流</category>
        <category>二分</category>
        <category>上下界网络流</category>
        <category>容斥原理</category>
        <category>线段树</category>
        <category>树状数组</category>
        <category>区间 DP</category>
        <category>构造</category>
        <category>Tarjan</category>
        <category>数据结构</category>
        <category>下饭</category>
        <category>LCA</category>
        <category>倍增</category>
        <category>鸽巢原理</category>
        <category>概率期望</category>
        <category>调和级数</category>
        <category>差分</category>
        <category>思维</category>
        <category>树形 DP</category>
        <category>最小生成树</category>
        <category>SAM</category>
        <category>状压</category>
        <category>分块</category>
        <category>可持久化</category>
        <category>笛卡尔树</category>
        <category>高维前缀和</category>
        <category>闲话</category>
        <category>欧拉回路</category>
        <category>树链剖分</category>
        <category>长链剖分</category>
        <category>KMP</category>
        <category>border</category>
        <category>字符串</category>
        <category>AC 自动机</category>
        <category>SA</category>
        <category>数学</category>
        <category>树上差分</category>
        <category>FWT</category>
        <category>堆</category>
        <category>树的重心</category>
        <category>二项式定理</category>
        <category>二项式反演</category>
        <category>贪心</category>
        <category>均摊</category>
        <category>计数</category>
        <category>优化建图</category>
        <category>反悔贪心</category>
        <category>调整法</category>
        <category>背包</category>
        <category>博弈论</category>
        <category>DP 优化</category>
        <category>虚树</category>
        <category>点分治</category>
        <category>WQS 二分</category>
        <category>闵可夫斯基和</category>
        <category>slope trick</category>
        <category>四边形不等式</category>
        <category>暴力</category>
        <category>状压 DP</category>
        <category>组合数学</category>
        <category>支配对</category>
        <category>DDP</category>
        <category>平衡树</category>
        <category>容斥</category>
        <category>猫树</category>
        <category>Kruskal 重构树</category>
        <category>李超线段树</category>
        <item>
            <guid isPermalink="true">https://xsc062.netlify.app/20230527/</guid>
            <title>中国剩余定理</title>
            <link>https://xsc062.netlify.app/20230527/</link>
            <category>CRT / exCRT</category>
            <pubDate>Sat, 27 May 2023 17:12:13 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;upd on 04/27/25：发现该文没写完 &lt;img src=&#34;/em/qd.gif&#34; /&gt;&lt;/p&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;中国剩余定理&#34;&gt;中国剩余定理&lt;/h2&gt;
&lt;p&gt;给定下列关于 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 的一元同余方程组：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
\begin {cases}
x \equiv a_1 \pmod {m_1}  \\
x \equiv a_2 \pmod {m_2}  \\
\quad \quad \vdots \\
x \equiv a_k \pmod {m_k}
\end {cases}
\]&lt;/span&gt; 其中对于 &lt;span class=&#34;math inline&#34;&gt;\(\forall \, 1\le i, j\le k\, (i\ne j)\)&lt;/span&gt;，满足 &lt;span class=&#34;math inline&#34;&gt;\(m_i \, \bot\, m_j\)&lt;/span&gt;。下面是求解该方程组的具体方法：&lt;/p&gt;
&lt;p&gt;令 &lt;span class=&#34;math inline&#34;&gt;\(M = \prod \limits _{i = 1} ^ k m_i, \, M_i=\dfrac M {m_i}\)&lt;/span&gt;，则 &lt;span class=&#34;math inline&#34;&gt;\(x = \sum \limits _{i = 1} ^k a_i\times M_i\times M_i ^{-1} \pmod M\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;其中，&lt;span class=&#34;math inline&#34;&gt;\(M_i^{-1}\)&lt;/span&gt; 是 &lt;span class=&#34;math inline&#34;&gt;\(M_i\)&lt;/span&gt; 在模 &lt;span class=&#34;math inline&#34;&gt;\(m_i\)&lt;/span&gt; 意义下的逆元（所以 &lt;span class=&#34;math inline&#34;&gt;\(M_i\times M_i^{-1}\)&lt;/span&gt; 的值并不是视觉上的 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt;）。&lt;/p&gt;
&lt;p&gt;正确性证明：对于 &lt;span class=&#34;math inline&#34;&gt;\(\forall \, i\in \{1, 2, \cdots, k\}\)&lt;/span&gt;，有 &lt;span class=&#34;math inline&#34;&gt;\(M_i\mid M\)&lt;/span&gt;；对于 &lt;span class=&#34;math inline&#34;&gt;\(\forall \, j\in \{1, 2, \cdots, k\}\)&lt;/span&gt; 且 &lt;span class=&#34;math inline&#34;&gt;\(j\ne i\)&lt;/span&gt;，有 &lt;span class=&#34;math inline&#34;&gt;\(m_i\mid \dfrac M{m_j}\)&lt;/span&gt; 即 &lt;span class=&#34;math inline&#34;&gt;\(m_i\mid M_j\)&lt;/span&gt;，即 &lt;span class=&#34;math inline&#34;&gt;\(M_j\equiv 0\pmod {m_i}\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;又 &lt;span class=&#34;math inline&#34;&gt;\(m_i\mid M\)&lt;/span&gt; 那么就有 &lt;span class=&#34;math inline&#34;&gt;\(x\equiv a_i\cdot M_i\cdot {M_i}^{-1}\equiv a_i\pmod {n_i}\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;时间复杂度 &lt;span class=&#34;math inline&#34;&gt;\(\mathcal O(n\log n)\)&lt;/span&gt;。注意求解逆元时要用到 exgcd。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;int CRT(int k, int *a, int *m) &amp;#123;
    int M = 1, x = 0;
    static int M1[maxn], Mi[maxn]; 
    for (int i = 1; i &amp;lt;= k; ++i)
        M *= m[i];
    for (int i = 1; i &amp;lt;= k; ++i) &amp;#123;
        M1[i] = M / m[i];
        Mi[i] = getinv(M1[i], m[i]);
        (x += a[i] * M1[i] * Mi[i]) %= M;
    &amp;#125;
    return x;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;扩展中国剩余定理&#34;&gt;扩展中国剩余定理&lt;/h2&gt;
&lt;p&gt;设有如下同余方程组：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
\begin {cases}
x \equiv a_1 \pmod {m_1} \\
x \equiv a_2 \pmod {m_2}
\end {cases}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;不保证 &lt;span class=&#34;math inline&#34;&gt;\(m_1 \, \bot \, m_2\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;设 &lt;span class=&#34;math inline&#34;&gt;\(x = m_1 \times p_1 + a_1 = m_2 \times p_2 + a_2\)&lt;/span&gt;，其中 &lt;span class=&#34;math inline&#34;&gt;\(p_i \in \mathbb Z\)&lt;/span&gt;，则有 &lt;span class=&#34;math inline&#34;&gt;\(p_1 \times m_1 - p_2 \times m_2 = a_2 - a_1\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(p_1\)&lt;/span&gt; 的值可以用 exgcd 求解，则原方程的解满足 &lt;span class=&#34;math inline&#34;&gt;\(x \equiv m_1\times p_1 + a_1 \pmod {M}\)&lt;/span&gt;，其中 &lt;span class=&#34;math inline&#34;&gt;\(M=\operatorname{lcm}(m_1, m_2)\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;这样我们就得到了一个新的同余方程。对于 &lt;span class=&#34;math inline&#34;&gt;\(k&amp;gt;2\)&lt;/span&gt; 的情况，我们不断合并两个同余方程即可得到最终同余方程。&lt;/p&gt;
&lt;p&gt;此时根据题目要求（一般求最小值即 &lt;span class=&#34;math inline&#34;&gt;\(m_k\times p_k + a_k\)&lt;/span&gt;）求解答案即可。&lt;/p&gt;
&lt;p&gt;时间复杂度 &lt;span class=&#34;math inline&#34;&gt;\(\mathcal O(n\log n)\)&lt;/span&gt;，其中 &lt;span class=&#34;math inline&#34;&gt;\(\log\)&lt;/span&gt; 来自 exgcd。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;int calc(int m1, int a1, int m2, int a2) &amp;#123;
    int p1, p2;
    if (a2 - a1 &amp;lt; 0)
        swap(a1, a2), swap(m1, m2);
    int g = exgcd(m1, p1, m2, p2);
    if ((a2 - a1) % g)
        return -1;
    p1 *= (a2 - a1) / g, m2 /= g;
    p1 = (p1 % m2 + m2) % m2;
    return p1 * m1 + a1;
&amp;#125;
int exCRT(int k, int *a, int *m) &amp;#123;
    for (int i = 2; i &amp;lt;= k; ++i) &amp;#123;
        a[i] = calc(m[i - 1],
                a[i - 1], m[i], a[i]);
        if (a[i] == -1)
            return -1;
        m[i] = lcm(m[i - 1], m[i]);
    &amp;#125;
    return a[k] % m[k];
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;d.-strange-way-to-express-integers&#34;&gt;D. Strange Way to Express Integers&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;http://222.180.160.110:1024/contest/3642/problem/4&#34; class=&#34;uri&#34;&gt;http://222.180.160.110:1024/contest/3642/problem/4&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;板。但是要开 &lt;code&gt;__int128&lt;/code&gt;。不知道为什么智力只用开 &lt;code&gt;long long&lt;/code&gt; 就能跑过，我和揭哥就不行。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#define int __int128
namespace XSC062 &amp;#123;
using namespace fastIO;
const int maxn = 1e5 + 5;
int n;
int a[maxn], m[maxn];
int gcd(int x, int y) &amp;#123;
    return y ? gcd(y, x % y) : x;
&amp;#125;
inline int lcm(int x, int y) &amp;#123;
    return x / gcd(x, y) * y;
&amp;#125;
inline void swap(int &amp;amp;x, int &amp;amp;y) &amp;#123;
    x ^= y ^= x ^= y;
    return;
&amp;#125;
int exgcd(int a, int &amp;amp;x, int b, int &amp;amp;y) &amp;#123;
    if (b == 0) &amp;#123;
        x = 1, y = 0;
        return a;
    &amp;#125;
    int u = exgcd(b, x, a % b, y);
    int t = x;
    x = y, y = t - (a / b) * y;
    return u;
&amp;#125;
inline int calc(int m1, int a1,
                    int m2, int a2) &amp;#123;
    int p1, p2;
    if (a2 - a1 &amp;lt; 0)
        swap(a1, a2), swap(m1, m2);
    int g = exgcd(m1, p1, m2, p2);
    if ((a2 - a1) % g)
        return -1;
    p1 *= (a2 - a1) / g, m2 /= g;
    p1 = (p1 % m2 + m2) % m2;
    return p1 * m1 + a1;
&amp;#125;
inline int exCRT(int k, int *a, int *m) &amp;#123;
    for (int i = 2; i &amp;lt;= k; ++i) &amp;#123;
        a[i] = calc(m[i - 1],
                a[i - 1], m[i], a[i]);
        if (a[i] == -1)
            return -1;
        m[i] = lcm(m[i - 1], m[i]);
    &amp;#125;
    return a[k] % m[k];
&amp;#125;
int main() &amp;#123;
    while (read(n)) &amp;#123;
        for (int i = 1; i &amp;lt;= n; ++i)
            read(m[i]), read(a[i]);
        print(exCRT(n, a, m), &amp;#39;\n&amp;#39;);
    &amp;#125;
    return 0;
&amp;#125;
&amp;#125; // namespace XSC062
#undef int&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
 ]]></description>
        </item>
    </channel>
</rss>
