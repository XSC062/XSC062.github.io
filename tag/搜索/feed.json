{
    "version": "https://jsonfeed.org/version/1",
    "title": "null • All posts by \"搜索\" tag",
    "description": "",
    "home_page_url": "https://xsc062.netlify.app",
    "items": [
        {
            "id": "https://xsc062.netlify.app/20251104/",
            "url": "https://xsc062.netlify.app/20251104/",
            "title": "杂题选谈",
            "date_published": "2025-11-04T07:01:11.000Z",
            "content_html": "<p>这么爱计数</p>\n<span id=\"more\"></span>\n<hr />\n<h2 id=\"a.-图-hdu4903-the-only-survival\">A. 图 / HDU4903 The only survival</h2>\n<p><a href=\"https://vjudge.net/problem/HDU-4903#author=DeepSeek_zh\" class=\"uri\">https://vjudge.net/problem/HDU-4903#author=DeepSeek_zh</a></p>\n<ul>\n<li><p>很容易想到基于按 dis 从小到大枚举的做法</p>\n<p>但是发现算方案就必须要知道每个点的具体 dis，就导致难以 DP，只能搜索，这样复杂度就不太好看。</p></li>\n<li><p>一个显然的观察：<strong>并不关心 <span class=\"math inline\">\\(1,n\\)</span> 以外点的标号</strong>，所以可以把 <span class=\"math inline\">\\(O(n^k)\\)</span> 的暴搜优化到 <span class=\"math inline\">\\(O(\\binom{n+k}k\\cdot (n+k))\\)</span>，然后做多重集排列即可。</p>\n<p>模数非质时的多重集排列：<a href=\"/20231117/#数学\">link</a></p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n    std::freopen(&quot;graph.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;graph.out&quot;, &quot;w&quot;, stdout);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, k, L, mod;\n    std::cin &gt;&gt; n &gt;&gt; k &gt;&gt; L &gt;&gt; mod;\n    if (L &lt; k) &#123;\n        std::cout &lt;&lt; 0 &lt;&lt; &#39;\\n&#39;;\n        return 0;\n    &#125;\n    std::vector&lt;std::vector&lt;long long&gt; &gt; C(n + 1, std::vector&lt;long long&gt; (n + 1));\n    C[0][0] = 1ll;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        C[i][0] = 1ll;\n        for (int j = 1; j &lt;= i; ++j)\n            C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % mod;\n    &#125;\n    std::vector&lt;int&gt; dis(n + 1), s;\n    int res = 0;\n    std::function&lt;void(int, int, long long)&gt; DFS = [&amp;](int x, int d, long long now) &#123;\n        if (x == n) &#123;\n            auto s0 = now, s1 = now;\n            for (int i = 1; i &lt; n; ++i)\n                if (dis[i] &gt;= k)\n                    (s0 *= L) %= mod, (s1 *= L) %= mod;\n                else if (L - (k - dis[i] - 1)) &#123;\n                    (s0 *= L - (k - dis[i] - 1)) %= mod;\n                    (s1 *= L - (k - dis[i] - 1) - 1) %= mod;\n                &#125;\n                else &#123;\n                    s0 = s1 = 0ll;\n                    break;\n                &#125;\n            dis[x] = k;\n            auto u = 1ll;\n            int cnt = n - 2;\n            for (auto i : s)\n                (u *= C[cnt][i]) %= mod, cnt -= i;\n            (res += u * (s0 + mod - s1) % mod) %= mod;\n            return;\n        &#125;\n        for (int i = d; i &lt;= k + 1; ++i) &#123;\n            auto s0 = now, s1 = now;\n            for (int j = 1; j &lt; x; ++j)\n                if (dis[j] &gt;= i)\n                    (s0 *= L) %= mod, (s1 *= L) %= mod;\n                else if (L - (i - dis[j] - 1)) &#123;\n                    (s0 *= L - (i - dis[j] - 1)) %= mod;\n                    (s1 *= L - (i - dis[j] - 1) - 1) %= mod;\n                &#125;\n                else &#123;\n                    s0 = s1 = 0ll;\n                    break;\n                &#125;\n            dis[x] = i;\n            if (dis[x] != dis[x - 1])\n                s.push_back(1);\n            else\n                ++s.back();\n            if (i == k + 1)\n                s1 = 0ll;\n            DFS(x + 1, i, (s0 + mod - s1) % mod);\n            if (dis[x] != dis[x - 1])\n                s.pop_back();\n            else\n                --s.back();\n        &#125;\n        return;\n    &#125;;\n    DFS(2, 1, 1);\n    std::cout &lt;&lt; res % mod &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"b.-路线-arc136e-non-coprime-dag\">B. 路线 / ARC136E Non-coprime DAG</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/AT_arc136_e\" class=\"uri\">https://www.luogu.com.cn/problem/AT_arc136_e</a></p>\n<ul>\n<li><p>做过 <a href=\"https://www.luogu.com.cn/problem/CF870F\">CF870F Paths</a> 可以很快反应过来：<span class=\"math inline\">\\(x\\)</span> 和 <span class=\"math inline\">\\(y\\)</span> 是否可以同时被选，取决于它们各自的最小质因子是否能在 <span class=\"math inline\">\\(x,y\\)</span> 之间交汇（或用 <span class=\"math inline\">\\(2\\)</span> 作跳板）。</p>\n<p>接着就发现由于 <span class=\"math inline\">\\(2\\)</span> 间隔出现，此时再分奇偶性就会显得非常合理。</p></li>\n<li><p>两个偶数总是不能同时被选；对于奇数 <span class=\"math inline\">\\(x\\)</span> 和偶数 <span class=\"math inline\">\\(y\\)</span>，要求 <span class=\"math inline\">\\(y\\in [x-f(x)+1,x+f(x)-1]\\)</span>。</p></li>\n<li><p>考察奇数的选取。容易发现，钦定用 <span class=\"math inline\">\\(2\\)</span> 作跳板，则两个奇数 <span class=\"math inline\">\\(x,y(x&lt;y)\\)</span> 能同时被选，当且仅当：</p>\n<ul>\n<li>记 <span class=\"math inline\">\\(f(i)\\)</span> 为 <span class=\"math inline\">\\(i\\)</span> 的最小质因子，则 <span class=\"math inline\">\\(x+f(x)&gt; y-f(y)\\)</span>。</li>\n</ul>\n<p>发现实际上可以认为 <span class=\"math inline\">\\(x\\)</span> 代表区间 <span class=\"math inline\">\\([x-f(x),x+f(x)-1]\\)</span>。那么两个点可以同时被选当且仅当它们代表的区间有交（这样就去掉了 <span class=\"math inline\">\\(x,y\\)</span> 之间的偏序条件）</p>\n<p>这样发现对『代表区间』的定义，在奇数视角和偶数视角下是冲突的，可以发现偶数视角的区间更紧；事实上，应该采用 <span class=\"math inline\">\\([x-f(x)+1,x+f(x)-1]\\)</span> 这个看似充分不必要的定义，因为端点总是奇数，导致 <span class=\"math inline\">\\(x+f(x)&gt; y-f(y)\\)</span> 和 <span class=\"math inline\">\\(x+f(x)-1&lt;y-f(y)+1\\)</span> 不能同时成立。</p></li>\n<li><p>进一步推广结论，容易发现多个奇数可以同时被选，当且仅当它们代表的区间有交。故可以枚举值域中的点，找加权覆盖次数最大值。</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;int&gt; fac(n + 1), l(n + 1), r(n + 1);\n    for (int i = 2; i &lt;= n; ++i) &#123;\n        if (!fac[i]) &#123;\n            fac[i] = i;\n            for (int j = 2 * i; j &lt;= n; j += i)\n                if (!fac[j])\n                   fac[j] = i;\n        &#125;\n        l[i] = std::max(1, i - fac[i] + 1);\n        r[i] = std::min(i + fac[i] - 1, n);\n    &#125;\n    std::vector&lt;int&gt; a(n + 1);\n    std::vector&lt;long long&gt; dif(n + 1);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; a[i];\n        if (i == 1 || i % 2 == 0)\n            continue;\n        dif[l[i]] += a[i];\n        if (r[i] != n)\n            dif[r[i] + 1] -= a[i];\n    &#125;\n    auto res = 0ll;\n    std::partial_sum(dif.begin(), dif.end(), dif.begin());\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        auto now = a[1] + dif[i];\n        if (i % 2 == 0)\n            now += a[i];\n        res = std::max(res, now);\n    &#125;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"a.-列车扫除\">A. 列车扫除</h2>\n<p><a href=\"https://www.becoder.com.cn/contest/6708/problem/1\" class=\"uri\">https://www.becoder.com.cn/contest/6708/problem/1</a></p>\n<blockquote>\n<p>绝对聪明的 A, B, C 在一起玩 Nim，有三堆石子 <span class=\"math inline\">\\(c_{1,2,3}\\)</span>，每次可以任选一堆拿走正整数个，不能拿的人扣一分，他的上一个人加一分。</p>\n<p>给定 <span class=\"math inline\">\\(q\\)</span> 次询问，形如：</p>\n<ul>\n<li>现在知道 <span class=\"math inline\">\\(\\forall \\, i=1,2,3,c_i\\in[l_i,r_i]\\)</span>。对于这 <span class=\"math inline\">\\(\\prod_{i=1,2,3}r_i-l_i+1\\)</span> 种可能的情况，对于每个人，求出分数之和。</li>\n</ul>\n<p><span class=\"math inline\">\\(q\\le 10^6,V=10^9\\)</span>。</p>\n</blockquote>\n<ul>\n<li><p>容易发现，胜，平，负三个状态会被分给三个人，且一共只有三种分配方式。</p></li>\n<li><p>当只剩一堆石头时，操作者胜；石头状态为 <span class=\"math inline\">\\((0,1,1)\\)</span> 时，操作者负。</p></li>\n</ul>\n<hr />\n<h2 id=\"b.-换来换去\">B. 换来换去</h2>\n<p><a href=\"https://www.becoder.com.cn/contest/6708/problem/2\" class=\"uri\">https://www.becoder.com.cn/contest/6708/problem/2</a></p>\n<blockquote>\n<p>对 <span class=\"math inline\">\\(n\\)</span> 个有标号的球任意分成任意组，组是无顺序的，且要求每组球个数 <span class=\"math inline\">\\(\\ge 2\\)</span>，求方案数，对质数取模。</p>\n<p><span class=\"math inline\">\\(n\\le 10^7\\)</span>。</p>\n</blockquote>\n<ul>\n<li><p>发现这是一个类斯特林数的问题，二项式反演得到答案式为：</p>\n<p><span class=\"math display\">\\[\n\\sum_{i=0}^n (-1)^{n-i}\\binom ni \\sum_{j=0}^i \\begin{Bmatrix} i\\\\ j\\end{Bmatrix}\n\\]</span></p>\n<p>用斯特林数通项展开：</p>\n<p><span class=\"math display\">\\[\n\\sum_{i=0}^n (-1)^{n-i}\\binom ni \\sum_{j=0}^i \\sum_{k=0}^j(-1)^{j-k}\\dfrac {k^i}{(j-k)!\\cdot k!}\n\\]</span></p>\n<p>很容易注意到一个二项式定理的结构，故交换求和顺序：</p>\n<p><span class=\"math display\">\\[\n\\sum_{j=0}^n \\sum_{k=0}^j \\dfrac {(-1)^{j-k}}{(j-k)!\\cdot k!}\\cdot \\sum_{i=j}^n \\binom ni (-1)^{n-i}k^i\n\\]</span></p>\n<p>发现一个很严重的问题在于 <span class=\"math inline\">\\(i\\)</span> 的起始范围是 <span class=\"math inline\">\\(j\\)</span> 而不是 <span class=\"math inline\">\\(0\\)</span>，但如果我们把一开始的式子改写成这样：</p>\n<p><span class=\"math display\">\\[\n\\sum_{i=0}^n (-1)^{n-i}\\binom ni \\sum_{j=0}^n \\begin{Bmatrix} i\\\\ j\\end{Bmatrix}\n\\]</span></p>\n<p>容易发现当 <span class=\"math inline\">\\(j&gt;i\\)</span> 时 <span class=\"math inline\">\\(\\begin{Bmatrix} i\\\\ j\\end{Bmatrix}=0\\)</span>，和原式的值相同，且斯特林数通项对于 <span class=\"math inline\">\\(j&gt;i\\)</span> 也是成立的，故原式等价于</p>\n<p><span class=\"math display\">\\[\n\\begin{aligned}\n&amp;\\sum_{j=0}^n \\sum_{k=0}^j \\dfrac {(-1)^{j-k}}{(j-k)!\\cdot k!}\\cdot \\sum_{i=0}^n \\binom ni (-1)^{n-i}k^i\\\\\n=&amp;\\sum_{j=0}^n \\sum_{k=0}^j \\dfrac {(-1)^{j-k}}{(j-k)!\\cdot k!}\\cdot (k-1)^n\\\\\n=&amp;\\sum_{k=0}^n \\dfrac {(k-1)^n}{k!}\\cdot \\sum_{j=0}^{n-k} \\dfrac {(-1)^j}{j!}\\\\\n\\end{aligned}\n\\]</span></p>\n<p>后者内部与 <span class=\"math inline\">\\(k\\)</span> 无关，是可前缀和计算的，只需要考虑在 <span class=\"math inline\">\\(O(1)\\)</span> 内求出 <span class=\"math inline\">\\((k-1)^n\\)</span> 的值，筛一下，对于质数（约 <span class=\"math inline\">\\(\\dfrac n{\\ln n}\\)</span> 个）快速幂，合数用积性函数之类即可。</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n    std::freopen(&quot;card.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;card.out&quot;, &quot;w&quot;, stdout);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int T;\n    for (std::cin &gt;&gt; T; T--; ) &#123;\n        int n, mod;\n        std::cin &gt;&gt; n &gt;&gt; mod;\n        std::vector&lt;int&gt; tag(n + 1), p, pw(n + 1);\n        auto qkp = [&amp;](long long x, int y) &#123;\n            auto res = 1ll;\n            for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n                if (y &amp; 1)\n                    (res *= x) %= mod;\n            return res;\n        &#125;;\n        pw[1] = 1ll;\n        for (int i = 2; i &lt;= n; ++i) &#123;\n            if (!tag[i]) &#123;\n                pw[i] = qkp(i, n);\n                p.push_back(i);\n            &#125;\n            for (auto j : p) &#123;\n                if (i &gt; n / j)\n                    break;\n                tag[i * j] = 1;\n                pw[i * j] = (long long)pw[i] * pw[j] % mod;\n                if (i % j == 0)\n                    break;\n            &#125;\n        &#125;\n        std::vector&lt;int&gt; inv(n + 1), s(n + 1);\n        inv[0] = 1ll;\n        for (int j = 1; j &lt;= n; ++j)\n            inv[j] = (long long)inv[j - 1] * j % mod;\n        inv[n] = qkp(inv[n], mod - 2);\n        for (int j = n - 1; j; --j)\n            inv[j] = (long long)inv[j + 1] * (j + 1) % mod;\n        s[0] = inv[0];\n        for (int j = 1; j &lt;= n; ++j) &#123;\n            if (j &amp; 1)\n                s[j] = s[j - 1] + mod - inv[j];\n            else\n                s[j] = s[j - 1] + inv[j];\n            if (s[j] &gt;= mod)\n                s[j] -= mod;\n        &#125;\n        auto res = (long long)s[n] * ((n &amp; 1) ? mod - 1 : 1);\n        for (int k = 1; k &lt;= n; ++k)\n            res += (long long)pw[k - 1] * inv[k] % mod * s[n - k] % mod;\n        std::cout &lt;&lt; res % mod &lt;&lt; &#39;\\n&#39;;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"c.-画家\">C. 画家</h2>\n<p><a href=\"https://www.becoder.com.cn/contest/6714/problem/3\" class=\"uri\">https://www.becoder.com.cn/contest/6714/problem/3</a></p>\n<ul>\n<li><p>ARC 特供删十字，故时光倒流，转化成在图上删相同颜色的十字 / 行 / 列。</p></li>\n<li><p>令 <span class=\"math inline\">\\(f_{i,j}\\)</span> 表示合法的 <span class=\"math inline\">\\(i\\)</span> 行 <span class=\"math inline\">\\(j\\)</span> 列地图。发现同颜色的删行 + 删列会和直接删十字算重，</p></li>\n</ul>\n<hr />\n<h2 id=\"b.-灯光秀-cf1545c-aquamoon-and-permutations\">B. 灯光秀 / CF1545C AquaMoon and Permutations</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/CF1545C\" class=\"uri\">https://www.luogu.com.cn/problem/CF1545C</a></p>\n<ul>\n<li><p>第一步需要想到，如果某一列的某个数，只有一个排列有，那么这个排列必须被选入拉丁方；</p>\n<p>用这个必选的排列，可以排除掉一些与之冲突、不能选入拉丁方的排列。</p></li>\n<li></li>\n</ul>\n<hr />\n<h2 id=\"a.-bot-的能量堆\">A. bot 的能量堆</h2>\n<p><a href=\"https://www.becoder.com.cn/contest/6731/problem/1\" class=\"uri\">https://www.becoder.com.cn/contest/6731/problem/1</a></p>\n<blockquote>\n<p>⚡<strong>超越一切震慑凡人</strong>⚡</p>\n<p>给定正整数 <span class=\"math inline\">\\(x,y\\)</span>，你可以执行下面三种操作：</p>\n<ol type=\"1\">\n<li>将 <span class=\"math inline\">\\(x,y\\)</span> 同时加 1；</li>\n<li>将 <span class=\"math inline\">\\(x,y\\)</span> 同时减一；</li>\n<li>对于 <span class=\"math inline\">\\(\\gcd(x,y)\\)</span> 的一个质因子 <span class=\"math inline\">\\(p\\)</span>，将 <span class=\"math inline\">\\(x,y\\)</span> 同时除以 <span class=\"math inline\">\\(p\\)</span>。</li>\n</ol>\n<p>问最少花费多少次操作使得 <span class=\"math inline\">\\(\\min(x,y)=1\\)</span>。多测。</p>\n<p><span class=\"math inline\">\\(T\\le 300,1\\le x,y\\le 10^9\\)</span>。</p>\n</blockquote>\n<ul>\n<li><p>不妨先考虑 <span class=\"math inline\">\\(x\\ne y\\)</span> 的情况，发现三种操作都不会使 <span class=\"math inline\">\\(x,y\\)</span> 的相对大小关系改变。故令 <span class=\"math inline\">\\(x&lt;y\\)</span>，考虑让 <span class=\"math inline\">\\(x\\)</span> 变为 1。</p></li>\n<li><p>记 <span class=\"math inline\">\\(d=y-x\\)</span>， 很容易注意到 <span class=\"math inline\">\\(d\\)</span> 的值不会在前两种操作中改变，由辗转相减，<span class=\"math inline\">\\(\\gcd(x,y)=\\gcd(d, x)\\)</span>，即操作三每次选取的 <span class=\"math inline\">\\(p\\)</span> 总是 <span class=\"math inline\">\\(d\\)</span> 的质因子，且总能通过若干次操作 1/2 让 <span class=\"math inline\">\\(p\\)</span> 能够执行。</p>\n<p>每次执行操作 3 后，<span class=\"math inline\">\\(d\\gets d\\div p\\)</span>，每次只需让 <span class=\"math inline\">\\(x\\)</span> 变为 <span class=\"math inline\">\\(\\lfloor \\frac xp\\rfloor\\)</span> 或 <span class=\"math inline\">\\(\\lceil \\frac xp\\rceil\\)</span>。</p>\n<p>直接记搜的话，容易发现状态总数是 V 因数总数。</p></li>\n<li><p>对于 <span class=\"math inline\">\\(x=y\\)</span> 的情况，答案至多为 <span class=\"math inline\">\\(x\\)</span> 的质因子数量。暴搜 + 剪枝非常可过。</p>\n<details>\n<p><summary>有一种神秘的处理方式…</summary></p>\n<pre class=\"cpp\"><code>if (x == y) &#123;\n    auto calc = [&amp;](int x) &#123;\n        int cnt = 0;\n        for (int i = 2; i * i &lt;= x; ++i)\n            for (; x % i == 0; ++cnt, x /= i);\n        return cnt + (x != 1);\n    &#125;;\n    int to = calc(x), res = to;\n    for (int i = std::max(x - to, 1); i &lt;= x + to; ++i)\n        res = std::min(res, calc(i) + std::abs(i - x));\n    std::cout &lt;&lt; x &lt;&lt; &#39;\\n&#39;;\n    continue;\n&#125;</code></pre>\n<p>容易发现这东西没什么道理，反例大概率存在但在小范围内确实难以构造。总之数据没卡到。</p>\n</details></li>\n</ul>\n<hr />\n<h2 id=\"b.-bot-的矩阵\">B. bot 的矩阵</h2>\n<p><a href=\"https://www.becoder.com.cn/contest/6731/problem/2\" class=\"uri\">https://www.becoder.com.cn/contest/6731/problem/2</a></p>\n<blockquote>\n<p><strong>⚡带来终结机械降神⚡</strong></p>\n<p>有一个 <span class=\"math inline\">\\(n\\times n\\)</span> 的二维数组，初始只知道 <span class=\"math inline\">\\(m\\)</span> 个位置的数 <span class=\"math inline\">\\(a_{x,y}\\)</span>，以及每行、每列的元素和 <span class=\"math inline\">\\(sx_{1\\cdots n},sy_{1\\cdots n}\\)</span>。</p>\n<p>构造出一个合法的解，每个数在 <span class=\"math inline\">\\([-2^63,2^63)\\)</span> 内。</p>\n<p><span class=\"math inline\">\\(n\\le 2000\\)</span>,<span class=\"math inline\">\\(a_{x,y},sx_i,sy_i\\in [-10^9,10^9]\\)</span>，<span class=\"math inline\">\\(m\\le n^2\\)</span>。</p>\n</blockquote>\n<ul>\n<li><p>听说很容易想到二分图，但实在反应不过来。但在乱填的时候发现，如果出现了『必填』的情况，是一个行列交错的链式反应，这样就很容易想到二分图了</p>\n<p>原理是同时影响行 <span class=\"math inline\">\\(i\\)</span> 列 <span class=\"math inline\">\\(j\\)</span> 的元素只有 <span class=\"math inline\">\\((i, j)\\)</span></p></li>\n<li><p>相当于给一个 <span class=\"math inline\">\\(2n\\)</span> 个点 <span class=\"math inline\">\\(n^2\\)</span> 条边的二分图，其中一些边权是已知的，那么不妨认为这些边被删除了</p>\n<p>同时也是一个 <span class=\"math inline\">\\(n^2\\)</span> 个元，<span class=\"math inline\">\\(2n-1\\)</span> 个方程的方程组（<span class=\"math inline\">\\(sx=sy\\)</span> 会消掉一条方程）；故很多元其实可以直接赋 <span class=\"math inline\">\\(0\\)</span>，只拿 <span class=\"math inline\">\\(2n-1\\)</span> 个元出来解方程。</p></li>\n<li><p>在挖掉已知边的二分图上任意找生成树（森林）就可以满足 <span class=\"math inline\">\\(2n-1\\)</span> 的限制，结合树上高斯消元，从叶子开始解方程即可。</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\n#define int long long\n#define nec getchar\nvoid read(int &amp;x) &#123;\n    x = 0;\n    char ch = nec();\n    bool flag = false;\n    for (; ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;; ch = nec())\n        if (ch == &#39;-&#39;)\n            flag = true;\n    for (; ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;; ch = nec())\n        x = x * 10 + ch - &#39;0&#39;;\n    if (flag)\n        x = -x;\n    return;\n&#125;\nsigned main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;matrix3.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int T;\n    for (read(T); T--; ) &#123;\n        int n, m;\n        read(n), read(m);\n        std::vector&lt;int&gt; sx(n + 1), sy(n + 1);\n        for (int i = 1; i &lt;= n; ++i)\n            read(sx[i]);\n        for (int i = 1; i &lt;= n; ++i)\n            read(sy[i]);\n        std::vector&lt;std::vector&lt;int&gt; &gt; vis(n + 1, std::vector&lt;int&gt; (n + 1));\n        std::vector&lt;std::vector&lt;long long&gt; &gt; a(n + 1, std::vector&lt;long long&gt; (n + 1));\n        std::vector&lt;int&gt; tx(n + 1), ty(n + 1);\n        auto work = [&amp;](int i, int j, int c) &#123;\n            vis[i][j] = 1;\n            ++tx[i], ++ty[j];\n            sx[i] -= c, sy[j] -= c, a[i][j] = c;\n            return;\n        &#125;;\n        for (int x, y, c; m--; ) &#123;\n            read(x), read(y), read(c);\n            work(x, y, c);\n        &#125;\n        if (std::accumulate(sx.begin() + 1, sx.end(), 0ll) != std::accumulate(sy.begin() + 1, sy.end(), 0ll)) &#123;\n            std::cout &lt;&lt; &quot;NoSolution!&quot; &lt;&lt; &#39;\\n&#39;;\n            continue;\n        &#125;\n        std::vector&lt;int&gt; fx(n + 1), fy(n + 1);\n        std::function&lt;bool(void)&gt; check = [&amp;](void) &#123;\n            for (int x = 1; x &lt;= n; ++x)\n                if (!fx[x]) &#123;\n                    if (tx[x] == n) &#123;\n                        if (sx[x] != 0)\n                            return false;\n                        fx[x] = 1;\n                        if (!check())\n                            return false;\n                    &#125;\n                    else if (tx[x] == n - 1) &#123;\n                        for (int y = 1; y &lt;= n; ++y)\n                            if (!vis[x][y]) &#123;\n                                work(x, y, sx[x]);\n                                fx[x] = 1;\n                                if (!check())\n                                    return false;\n                            &#125;\n                    &#125;\n                &#125;\n            for (int y = 1; y &lt;= n; ++y)\n                if (!fy[y]) &#123;\n                    if (ty[y] == n) &#123;\n                        if (sy[y] != 0)\n                            return false;\n                        fy[y] = 1;\n                        if (!check())\n                            return false;\n                    &#125;\n                    else if (ty[y] == n - 1) &#123;\n                        for (int x = 1; x &lt;= n; ++x)\n                            if (!vis[x][y]) &#123;\n                                work(x, y, sy[y]);\n                                fy[y] = 1;\n                                if (!check())\n                                    return false;\n                            &#125;\n                    &#125;\n                &#125;\n            return true;\n        &#125;;\n        if (!check()) &#123;\n            std::cout &lt;&lt; &quot;NoSolution!&quot; &lt;&lt; &#39;\\n&#39;;\n            continue;\n        &#125;\n        std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int op) &#123;\n            if (op == 0) &#123;\n                fx[x] = 1;\n                for (int i = 1; i &lt;= n; ++i)\n                    if (!vis[x][i] &amp;&amp; !fy[i]) &#123;\n                        DFS(i, 1);\n                        work(x, i, sy[i]);\n                    &#125;\n            &#125;\n            else &#123;\n                fy[x] = 1;\n                for (int i = 1; i &lt;= n; ++i)\n                    if (!vis[i][x] &amp;&amp; !fx[i]) &#123;\n                        DFS(i, 0);\n                        work(i, x, sx[i]);\n                    &#125;\n            &#125;\n            return;\n        &#125;;\n        for (int i = 1; i &lt;= n; ++i)\n            if (!fx[i])\n                DFS(i, 0);\n        for (int i = 1; i &lt;= n; ++i)\n            if (!fy[i])\n                DFS(i, 1);\n        std::cout &lt;&lt; &quot;Botany!&quot; &lt;&lt; &#39;\\n&#39;;\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            for (int j = 1; j &lt;= n; ++j)\n                std::cout &lt;&lt; a[i][j] &lt;&lt; &#39; &#39;;\n            std::cout &lt;&lt; &#39;\\n&#39;;\n        &#125;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"a.-数码串\">A. 数码串</h2>\n<p><a href=\"https://www.becoder.com.cn/contest/6736/problem/1\" class=\"uri\">https://www.becoder.com.cn/contest/6736/problem/1</a></p>\n<blockquote>\n<p>给定一个长度为 <span class=\"math inline\">\\(n\\)</span> 的数字串，现在需要给它分为若干段，问在所有 <span class=\"math inline\">\\(2^{n-1}\\)</span> 种分段方式中，有多少种满足：</p>\n<ul>\n<li>在任意相邻的两段中，有至少一段，其对应的十进制数是 <span class=\"math inline\">\\(D\\)</span> 的倍数。</li>\n</ul>\n<p>答案对 <span class=\"math inline\">\\(10^9+7\\)</span> 取模。</p>\n<p>多测，<span class=\"math inline\">\\(n\\le 2\\times 10^5,D\\le 10^6,T\\le 100\\)</span>。</p>\n<p><strong>部分分特殊性质</strong>：<span class=\"math inline\">\\(\\gcd(D,10)=1\\)</span>。</p>\n</blockquote>\n<ul>\n<li><p>发现若 <span class=\"math inline\">\\(a_{l\\cdots r}\\)</span> 是 <span class=\"math inline\">\\(D\\)</span> 的倍数，记 <span class=\"math inline\">\\(s_i=s_{i+1}+a_i\\times 10^{n-i}\\)</span>，那么 <span class=\"math inline\">\\(\\dfrac{s_l-s_{r+1}}{10^{n-r}}\\bmod D=0\\)</span></p>\n<p>题目要求，这个转移点和上个转移点，至少有一个满足该式。显然可以类 DP 地做。</p></li>\n<li><p>对于 <span class=\"math inline\">\\(D\\)</span> 与 <span class=\"math inline\">\\(10\\)</span> 互质的情况，原条件等价于 <span class=\"math inline\">\\(s_l\\equiv s_{r+1}\\pmod D\\)</span>，用一个桶记录 DP 值即可</p></li>\n<li><p>记 <span class=\"math inline\">\\(D=2^*\\times 5^?\\times m\\)</span>，发现 <span class=\"math inline\">\\(m\\)</span> 与 <span class=\"math inline\">\\(10\\)</span> 互质，或许可以套用上方的做法</p>\n<p><mark>由于 <span class=\"math inline\">\\(D\\le 10^6 &lt; 2^{20}\\)</span>，对于一个固定的 <span class=\"math inline\">\\(r\\)</span>，所有 <span class=\"math inline\">\\(l\\le r-20\\)</span> 项的 <span class=\"math inline\">\\(a_l\\)</span> 对 <span class=\"math inline\">\\(a_{l\\cdots r}\\bmod (2^*\\times 5^?)\\)</span> 的贡献总是 <span class=\"math inline\">\\(0\\)</span></mark>，故在只考虑 <span class=\"math inline\">\\(2^*\\times 5^?\\)</span> 时， <span class=\"math inline\">\\(l\\le r-20\\)</span> 的可选性和 <span class=\"math inline\">\\(l=r-20\\)</span> 的可选性相同。只需要对于 <span class=\"math inline\">\\(\\bmod m\\)</span> 沿用桶做法即可。</p>\n<p>对于 <span class=\"math inline\">\\(l\\ge r-20\\)</span>，暴力即可，复杂度 <span class=\"math inline\">\\(O(T(n+D))\\)</span>。</p></li>\n</ul>\n<details>\n<p>注意 <span class=\"math inline\">\\(s_l-s_{r+1}\\)</span> 里的 <span class=\"math inline\">\\(r+1\\)</span>，调成鸲了</p>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 1e9 + 7;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n    std::freopen(&quot;digit.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;digit.out&quot;, &quot;w&quot;, stdout);\n#else\n    std::freopen(&quot;./test/20251113/digit/ex_digit1.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int T;\n    std::vector&lt;std::array&lt;long long, 2&gt; &gt; c(1e6);\n    for (std::cin &gt;&gt; T; T--; ) &#123;\n        std::string a;\n        int d, n, m, p;\n        std::cin &gt;&gt; a &gt;&gt; d, n = (int)a.length();\n        a = &quot;#&quot; + a;\n        std::vector&lt;std::vector&lt;long long&gt; &gt; f(n + 1, std::vector&lt;long long&gt; (2));\n        f[0][0] = 1ll;\n        m = d;\n        for (; m % 2 == 0; m /= 2);\n        for (; m % 5 == 0; m /= 5);\n        p = d / m;\n        for (int i = 0; i &lt; m; ++i)\n            c[i][0] = c[i][1] = 0ll;\n        std::vector&lt;int&gt; s(n + 2);\n        for (int i = n, k = 1; i; --i, (k *= 10) %= m)\n            s[i] = (s[i + 1] + (a[i] - &#39;0&#39;) * k) % m;\n        auto s0 = 0ll;\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            int now = 0;\n            for (int j = i, k = 1; j &gt; i - 20 &amp;&amp; j; --j, (k *= 10) %= d) &#123;\n                (now += (a[j] - &#39;0&#39;) * k) %= d;\n                if (now == 0)\n                    (f[i][0] += f[j - 1][0] + f[j - 1][1]) %= mod;\n                else\n                    (f[i][1] += f[j - 1][0]) %= mod;\n            &#125;\n            if (i &gt; 20) &#123;\n                (c[s[i - 20]][0] += f[i - 21][0]) %= mod;\n                (c[s[i - 20]][1] += f[i - 21][1]) %= mod;\n                (s0 += f[i - 21][0]) %= mod;\n                int now = 0;\n                for (int j = i, k = 1; j &gt;= i - 20; --j, (k *= 10) %= p)\n                    (now += (a[j] - &#39;0&#39;) * k) %= p;\n                if (now == 0) &#123;\n                    (f[i][0] += c[s[i + 1]][0] + c[s[i + 1]][1]) %= mod;\n                    (f[i][1] += s0 + mod - c[s[i + 1]][0]) %= mod;\n                &#125;\n                else\n                    (f[i][1] += s0) %= mod;\n            &#125;\n        &#125;\n        std::cout &lt;&lt; (f[n][0] + f[n][1]) % mod &lt;&lt; &#39;\\n&#39;;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"b.-背包\">B. 背包</h2>\n<p><a href=\"https://www.becoder.com.cn/contest/6736/problem/2\" class=\"uri\">https://www.becoder.com.cn/contest/6736/problem/2</a></p>\n<blockquote>\n<p>给定 <span class=\"math inline\">\\(n\\)</span> 种物品，第 <span class=\"math inline\">\\(i(1\\le i\\le n)\\)</span> 种有无穷多个，体积均为 <span class=\"math inline\">\\(v_i\\)</span>、价值均为 <span class=\"math inline\">\\(w_i\\)</span>。给定 <span class=\"math inline\">\\(Q\\)</span> 次询问，形如：</p>\n<ul>\n<li><p>给定一个背包容积 <span class=\"math inline\">\\(m\\)</span>，回答两个问题：</p>\n<ol type=\"1\">\n<li><strong>有序地</strong>选取体积和<strong>恰好</strong>为 <span class=\"math inline\">\\(m\\)</span> 的物品，所能得到的最大价值。如果不存在这样的选取方式，回答 <span class=\"math inline\">\\(-1\\)</span>。</li>\n<li>在上一问的条件下，可能的方案数。两个方案不同，当且仅当选取的物品数不同，或选物序列的某个位置不同。对 <span class=\"math inline\">\\(1092515507\\)</span> 取模，不存在则回答 <span class=\"math inline\">\\(-1\\)</span>。</li>\n</ol></li>\n</ul>\n<p><span class=\"math inline\">\\(n,Q,v_i\\le 100, m,w_i\\le 10^9\\)</span>。</p>\n</blockquote>\n<p>mobai ddxrS</p>\n<ul>\n<li><p>Tip：由于选取是有序的，所以朴素的『枚举物品 + 枚举体积』的 DP 是不可行的，而需要『枚举体积 + 枚举物品』。</p></li>\n<li><p>很容易写出朴素的 DP：令二元组 <span class=\"math inline\">\\((a, b)_{m}\\)</span> 表示总体积 <span class=\"math inline\">\\(m\\)</span> 下的两问答案，则<strong>合并答案</strong>（定义为 <span class=\"math inline\">\\(+\\)</span> 运算）的过程可以写为：</p>\n<p><span class=\"math display\">\\[\n(a_1,b_1)_{m}+(a_2,b_2)_{m}=\\begin{cases}\n(a_1,b_1)_{m}&amp;a_1&gt;a_2\\\\\n(a_1,b_1+b_2)_{m}&amp;a_1=a_2\\\\\n(a_2, b_2)_{m}&amp;\\text{otherwise}\n\\end{cases}\n\\]</span></p></li>\n<li><p>相似地，<strong>状态转移</strong>（定义为 <span class=\"math inline\">\\(\\times\\)</span> 运算）可以写为：</p>\n<p><span class=\"math display\">\\[\n(a_1,b_1)_{m_1}\\times (a_2,b_2)_{m_2}=(a_1+a_2,b_1\\times b_2)_{m_1+m_2}\n\\]</span></p>\n<p>Tips：实际上是借鉴了矩阵乘法的含义进行定义，这样就可以尝试优化。</p></li>\n<li><p>这样就有 <span class=\"math inline\">\\((f,g)_i = \\sum\\limits_{j=1}^n (f,g)_{i-v_j}\\times (w_j,1)_{v_j}\\)</span>。</p></li>\n<li><p>感性理解：显然，在直接背包时，<span class=\"math inline\">\\(+\\)</span> 运算与 <span class=\"math inline\">\\(\\times\\)</span> 运算具有交换律，且 <span class=\"math inline\">\\(\\times\\)</span> 对 <span class=\"math inline\">\\(+\\)</span> 有分配律。</p>\n<p>那么此时广义矩乘具有结合律，可以优化。</p></li>\n<li><p>体积最大为 <span class=\"math inline\">\\(100\\)</span>，考虑开 <span class=\"math inline\">\\(100\\times 100\\)</span> 的矩阵（元素为二元组）维护 <span class=\"math inline\">\\((f,g)_{i-99}\\sim (f,g)_i\\)</span>。考虑直接快速幂，发现复杂度是非常糟糕的 <span class=\"math inline\">\\(O(qv^3\\log m)\\)</span>，非常糟糕。</p>\n<p>初始矩阵是 <span class=\"math inline\">\\(1\\times 100\\)</span> 的，这里的处理方式是预处理每一个 <span class=\"math inline\">\\(2^i\\)</span> 次幂（<span class=\"math inline\">\\(O(v^3\\log m)\\)</span>），每次询问时二进制拆分 <span class=\"math inline\">\\(m\\)</span>，线性地乘过去，就可以把矩阵乘法优化为矩阵乘向量，复杂度降至 <span class=\"math inline\">\\(O(qv^2\\log m)\\)</span>。</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconstexpr int N = 100;\nconst long long inf = 1e18;\nconst int mod = 1092515507;\nstruct node &#123;\n    long long f, g;\n    node(): f(-inf), g(0ll) &#123;&#125;\n    node(long long f1, long long g1): f(f1), g(g1) &#123;\n        if (g &gt;= mod)\n            g -= mod;\n        return;\n    &#125;\n    node operator* (const node &amp;q) const &#123;\n        return node(f + q.f, g * q.g % mod);\n    &#125;\n    node operator+ (const node &amp;q) const &#123;\n        if (f &gt; q.f)\n            return *this;\n        else if (f == q.f)\n            return node(f, g + q.g);\n        return q;\n    &#125;\n    node&amp; operator+= (const node &amp;q) &#123;\n        return *this = *this + q;\n    &#125;\n&#125;;\nstruct mat &#123;\n    std::vector&lt;std::vector&lt;node&gt; &gt; a;\n    mat(void): a(N, std::vector&lt;node&gt; (N)) &#123;&#125;\n    std::vector&lt;node&gt;&amp; operator[] (const int q) &#123;\n        return a[q];\n    &#125;\n    mat operator* (mat &amp;q) const &#123;\n        mat res;\n        for (int i = 0; i &lt; N; ++i)\n            for (int k = 0; k &lt; N; ++k)\n                for (int j = 0; j &lt; N; ++j) \n                    res[i][j] += a[i][k] * q[k][j];\n        return res;\n    &#125;\n&#125;;\nstruct vec &#123;\n    std::vector&lt;node&gt; a;\n    vec(void): a(N) &#123;&#125;\n    node&amp; operator[] (const int q) &#123;\n        return a[q];\n    &#125;\n    vec operator* (mat &amp;q) const &#123;\n        vec res;\n        for (int k = 0; k &lt; N; ++k)\n            for (int j = 0; j &lt; N; ++j)\n                res[j] += a[k] * q[k][j];\n        return res;\n    &#125;\n    vec&amp; operator*= (mat &amp;q) &#123;\n        return *this = *this * q;\n    &#125;\n&#125;;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n    std::freopen(&quot;pack.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;pack.out&quot;, &quot;w&quot;, stdout);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, q;\n    std::cin &gt;&gt; n &gt;&gt; q;\n    std::vector&lt;int&gt; v(n + 1), w(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; v[i];\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; w[i];\n    std::vector&lt;mat&gt; t(30);\n    for (int j = 0; j &lt; N - 1; ++j)\n        t[0][j + 1][j] += node(0ll, 1ll);\n    for (int i = 1; i &lt;= n; ++i)\n        t[0][N - v[i]][N - 1] += node(w[i], 1ll);\n    for (int i = 1; i &lt; 30; ++i)\n        t[i] = t[i - 1] * t[i - 1];\n    vec init;\n    init[N - 1] = node(0ll, 1ll);\n    for (int m; q--; ) &#123;\n        std::cin &gt;&gt; m;\n        auto res(init);\n        for (int i = 29; ~i; --i)\n            if ((m &gt;&gt; i) &amp; 1)\n                res *= t[i];\n        if (res[N - 1].f &lt;= 0)\n            std::cout &lt;&lt; -1 &lt;&lt; &#39; &#39; &lt;&lt; -1 &lt;&lt; &#39;\\n&#39;;\n        else\n            std::cout &lt;&lt; res[N - 1].f &lt;&lt; &#39; &#39; &lt;&lt; res[N - 1].g &lt;&lt; &#39;\\n&#39;;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"a.-关卡设计\">A. 关卡设计</h2>\n<p><a href=\"https://www.becoder.com.cn/contest/6742/problem/1\" class=\"uri\">https://www.becoder.com.cn/contest/6742/problem/1</a></p>\n<blockquote>\n<p>给定 <span class=\"math inline\">\\(n\\times m\\)</span> 的字符地图，其中 <code>S</code> 为起点（有且仅有一个），<code>R</code>，<code>B</code> 为红、蓝宝石（可能有多个），<code>x</code> 为障碍、<code>.</code> 为可通行地块。</p>\n<p>现在需要把尽可能多的 <code>.</code> 变为 <code>x</code>，使得一种原来可以由 <code>S</code> 出发收集到的宝石在修改后的地图中仍能被收集。输出最多可修改的 <code>.</code> 的数量。</p>\n<p><span class=\"math inline\">\\(n\\times m\\le 10^6\\)</span>。</p>\n</blockquote>\n<ul>\n<li><p>一种显然错误的做法：拆点 <span class=\"math inline\">\\((u,0/1/2/3)\\)</span> 分别表示走到 <span class=\"math inline\">\\(u\\)</span> 时的宝石收集状态，跑 01BFS。</p>\n<p>错误的原因：路径会重复走一些边，但它们不能被重复记入代价。</p></li>\n<li><p>结合『重复走一些边』的想法，发现路径一定有一个『分叉点』。枚举这样的分叉点，从 <code>S</code>、所有 <code>R</code>、所有 <code>B</code> 出发分别跑 01BFS。</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int dir[][2] = &#123; &#123; 0, -1 &#125;, &#123; 0, 1 &#125;, &#123; -1, 0 &#125;, &#123; 1, 0 &#125; &#125;;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n    std::freopen(&quot;design.out&quot;, &quot;w&quot;, stdout);\n    std::freopen(&quot;design.in&quot;, &quot;r&quot;, stdin);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int T;\n    for (std::cin &gt;&gt; T; T--; ) &#123;\n        int n, m,  cnt = 0;\n        std::cin &gt;&gt; n &gt;&gt; m;\n        std::vector&lt;std::vector&lt;char&gt; &gt; a(n + 1, std::vector&lt;char&gt; (m + 1));\n        for (int i = 1; i &lt;= n; ++i)\n            for (int j = 1; j &lt;= m; ++j) &#123;\n                std::cin &gt;&gt; a[i][j];\n                cnt += (a[i][j] == &#39;.&#39;);\n            &#125;\n        const int N = n * m;\n        auto id = [&amp;](int i, int j) &#123; return (i - 1) * m + j; &#125;;\n        std::vector&lt;std::vector&lt;int&gt; &gt; dis(3, std::vector&lt;int&gt; (N + 1, N + 1));\n        auto work = [&amp;](std::vector&lt;int&gt; &amp;dis, char S) &#123;\n            std::deque&lt;int&gt; q;\n            std::vector&lt;int&gt; vis(N + 1);\n            for (int i = 1; i &lt;= n; ++i)\n                for (int j = 1; j &lt;= m; ++j)\n                    if (a[i][j] == S) &#123;\n                        dis[id(i, j)] = 0;\n                        q.push_back(id(i, j));\n                    &#125;\n            for (; !q.empty(); ) &#123;\n                int x, y;\n                &#123;\n                    int t = q.front();\n                    q.pop_front();\n                    if (vis[t])\n                        continue;\n                    vis[t] = 1;\n                    x = (t - 1) / m + 1, y = t - (x - 1) * m;\n                &#125;\n                for (auto [fx, fy] : dir) &#123;\n                    int nx = x + fx, ny = y + fy;\n                    if (nx &gt;= 1 &amp;&amp; ny &gt;= 1 &amp;&amp; nx &lt;= n &amp;&amp; ny &lt;= m &amp;&amp; a[nx][ny] != &#39;x&#39;) &#123;\n                        if (a[nx][ny] != &#39;.&#39;) &#123;\n                            if (dis[id(nx, ny)] &gt; dis[id(x, y)]) &#123;\n                                dis[id(nx, ny)] = dis[id(x, y)];\n                                q.push_front(id(nx, ny));\n                            &#125;\n                        &#125;\n                        else if (dis[id(nx, ny)] &gt; dis[id(x, y)] + 1) &#123;\n                            dis[id(nx, ny)] = dis[id(x, y)] + 1;\n                            q.push_back(id(nx, ny));\n                        &#125;\n                    &#125;\n                &#125;\n            &#125;\n        &#125;;\n        work(dis[0], &#39;S&#39;), work(dis[1], &#39;R&#39;), work(dis[2], &#39;B&#39;);\n        int mn1 = N + 1, mn2 = N + 1;\n        for (int i = 1; i &lt;= n; ++i)\n            for (int j = 1; j &lt;= m; ++j) &#123;\n                mn1 = std::min(mn1, dis[0][id(i, j)] + std::min(dis[1][id(i, j)], dis[2][id(i, j)]) - (a[i][j] == &#39;.&#39;));\n                mn2 = std::min(mn2, dis[0][id(i, j)] + dis[1][id(i, j)] + dis[2][id(i, j)] - (a[i][j] == &#39;.&#39;) * 2);\n            &#125;\n        if (mn2 != N + 1)\n            std::cout &lt;&lt; cnt - mn2 &lt;&lt; &#39;\\n&#39;;\n        else if (mn1 != N + 1)\n            std::cout &lt;&lt; cnt - mn1 &lt;&lt; &#39;\\n&#39;;\n        else\n            std::cout &lt;&lt; cnt &lt;&lt; &#39;\\n&#39;;\n    &#125;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"c.-炼金术\">C. 炼金术</h2>\n<p><a href=\"https://www.becoder.com.cn/contest/6742/problem/3\" class=\"uri\">https://www.becoder.com.cn/contest/6742/problem/3</a></p>\n<blockquote>\n<p>给定 <span class=\"math inline\">\\(A_{1\\cdots n}\\)</span> 和 <span class=\"math inline\">\\(B_{1\\cdots n}\\)</span>，给定 <span class=\"math inline\">\\(m\\)</span> 次操作，形如：</p>\n<ul>\n<li><code>1 l r x</code>，将 <span class=\"math inline\">\\(A_{l\\cdots r}\\)</span> 赋为 <span class=\"math inline\">\\(x\\)</span>。</li>\n<li><code>2 l r</code>，询问 <span class=\"math inline\">\\(\\min\\limits_{i\\in [l, r]}\\left\\{ \\text{lcm}(A_i,B_i)+\\dfrac{\\text{lcm}(A_i,B_i)}{\\gcd(A_i,B_i)} \\right\\}\\)</span> 的值。</li>\n</ul>\n<p><span class=\"math inline\">\\(n,m\\le 5\\times 10^4,V=5\\times 10^4\\)</span>。</p>\n</blockquote>\n<ul>\n<li><p>待求没什么太好的性质，考虑更暴力的解决方式。</p>\n<p>容易想到分块做法，对于整块赋值，容易想到对于每个 <span class=\"math inline\">\\(x\\)</span> 预处理块内答案。如何快速做到这一点？</p>\n<p>一个想法是枚举 gcd 的值 <span class=\"math inline\">\\(p\\)</span>（显然只需枚举 <span class=\"math inline\">\\(x\\)</span> 的因子），计算 <span class=\"math inline\">\\(\\dfrac {b_j\\times x}p+\\dfrac {b_j\\times x}{p^2}\\)</span> 的最小值。</p>\n<p><em>Tip：枚举到的 <span class=\"math inline\">\\(p\\)</span> 可能不是 gcd，但能保证一定能找到答案。</em></p></li>\n<li><p>贪心地，只需对于块内 <span class=\"math inline\">\\(p\\)</span> 的最小倍数计算答案。这一点对于每个 <span class=\"math inline\">\\(b_i\\)</span> 枚举因数即能 <span class=\"math inline\">\\(O(n\\sqrt V)\\)</span> 地预处理（因为有重复元素所以不是 <span class=\"math inline\">\\(O(V\\log V)\\)</span>）、花费 <span class=\"math inline\">\\(O(V\\log n)\\)</span> 的空间存储。</p></li>\n<li><p>对于每个 <span class=\"math inline\">\\(x\\)</span>，复杂度不允许暴力枚举 <span class=\"math inline\">\\(x\\)</span> 的因子；发现 <span class=\"math inline\">\\(x\\)</span> 的因子是 <span class=\"math inline\">\\(x\\)</span> 与『对于所有 <span class=\"math inline\">\\(x\\)</span> 的质因子 <span class=\"math inline\">\\(m\\)</span>，<span class=\"math inline\">\\(\\dfrac xm\\)</span> 的因子』的并。</p>\n<p>考虑一个类 DP 的过程，则 <span class=\"math inline\">\\(f_x\\gets f_{x\\div m}\\times m\\)</span>，再计算 <span class=\"math inline\">\\(x\\)</span> 自身的答案即可。由于 <span class=\"math inline\">\\(\\omega(V)\\)</span> 平均为 <span class=\"math inline\">\\(\\log\\log V\\)</span>，此时预处理复杂度降低至 <span class=\"math inline\">\\(O(n\\sqrt V + V\\log V\\sqrt n)\\)</span>。</p></li>\n<li><p>用一点科技加速 gcd 即可。可选 <span class=\"math inline\">\\(O(1)\\)</span> gcd，或小范围打表 + 大范围暴力跳至小范围。</p></li>\n</ul>\n<details>\n<p>注意待求可能会爆 <code>unsigned int</code>，问就是挂分了。</p>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n    std::freopen(&quot;alchemy.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;alchemy.out&quot;, &quot;w&quot;, stdout);\n#else\n    std::freopen(&quot;./test/20251115/alchemy/alchemy4.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    const long long inf = 1e18;\n    const int M = 5000, N = 50000;\n    std::vector&lt;std::vector&lt;int&gt; &gt; g(M + 1, std::vector&lt;int&gt; (M + 1));\n    for (int i = 0; i &lt;= M; ++i) &#123;\n        for (int j = 0; j &lt; i; ++j)\n            g[i][j] = g[j][i];\n        g[i][i] = i;\n        for (int j = i + 1; j &lt;= M; ++j)\n            g[i][j] = std::__gcd(i, j);\n    &#125;\n    std::function&lt;int(int, int)&gt; gcd = [&amp;](int x, int y) &#123;\n        if (x &lt;= M &amp;&amp; y &lt;= M)\n            return g[x][y];\n        return y ? gcd(y, x % y) : x;\n    &#125;;\n    std::vector&lt;std::vector&lt;int&gt; &gt; fac(N + 1);\n    for (int i = 2; i &lt;= N; ++i)\n        if (fac[i].empty())\n            for (int j = i; j &lt;= N; j += i)\n                fac[j].push_back(i);\n    int n, m;\n    std::cin &gt;&gt; n &gt;&gt; m;\n    std::vector&lt;long long&gt; a(n + 1), b(n + 1), p(n + 1);\n    auto calc = [&amp;](long long x, long long y) &#123;\n        auto g = gcd(x, y);\n        return x * y / g + x * y / g / g;\n    &#125;;\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i];\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; b[i];\n        p[i] = calc(a[i], b[i]);\n    &#125;\n    int siz = sqrt(n), k = (n + siz - 1) / siz;\n    std::vector&lt;long long&gt; u(k + 1, inf);\n    std::vector&lt;int&gt; L(k + 1), R(k + 1), id(n + 1), d(k + 1, -1);\n    std::vector&lt;std::vector&lt;long long&gt; &gt; mn(k + 1, std::vector&lt;long long&gt; (N + 1, inf)), s(k + 1, std::vector&lt;long long&gt; (N + 1));\n    for (int i = 1; i &lt;= k; ++i) &#123;\n        L[i] = R[i - 1] + 1, R[i] = std::min(L[i] + siz - 1, n);\n        for (int j = L[i]; j &lt;= R[i]; ++j) &#123;\n            id[j] = i, u[i] = std::min(u[i], p[j]);\n            for (int k = 1; k * k &lt;= b[j]; ++k)\n                if (b[j] % k == 0) &#123;\n                    mn[i][k] = std::min(mn[i][k], b[j]);\n                    mn[i][b[j] / k] = std::min(mn[i][b[j] / k], b[j]);\n                &#125;\n        &#125;\n        s[i][1] = mn[i][1] * 2;\n        for (int j = 2; j &lt;= N; ++j) &#123;\n            s[i][j] = mn[i][j] + mn[i][j] / j;\n            for (auto k : fac[j])\n                s[i][j] = std::min(s[i][j], s[i][j / k] * k);\n        &#125;\n    &#125;\n    auto pushdown = [&amp;](int id) &#123;\n        if (d[id] != -1) &#123;\n            for (int i = L[id]; i &lt;= R[id]; ++i)\n                p[i] = calc(d[id], b[i]);\n            d[id] = -1;\n        &#125;\n        return;\n    &#125;;\n    auto ADD = [&amp;](int l, int r, int x) &#123;\n        int pl = id[l], pr = id[r];\n        pushdown(pl);\n        if (pl == pr) &#123;\n            for (int i = l; i &lt;= r; ++i)\n                p[i] = calc(x, b[i]);\n            u[pl] = *std::min_element(p.begin() + L[pl], p.begin() + R[pl] + 1);\n            return;\n        &#125;\n        pushdown(pr);\n        for (int i = l; i &lt;= R[pl]; ++i)\n            p[i] = calc(x, b[i]);\n        u[pl] = *std::min_element(p.begin() + L[pl], p.begin() + R[pl] + 1);\n        for (int i = L[pr]; i &lt;= r; ++i)\n            p[i] = calc(x, b[i]);\n        u[pr] = *std::min_element(p.begin() + L[pr], p.begin() + R[pr] + 1);\n        for (int i = pl + 1; i &lt; pr; ++i)\n            d[i] = x, u[i] = s[i][x];\n        return;\n    &#125;;\n    auto ASK = [&amp;](int l, int r) &#123;\n        int pl = id[l], pr = id[r];\n        pushdown(pl);\n        if (pl == pr)\n            return *std::min_element(p.begin() + l, p.begin() + r + 1);\n        pushdown(pr);\n        auto res = std::min(*std::min_element(p.begin() + l, p.begin() + R[pl] + 1), *std::min_element(p.begin() + L[pr], p.begin() + r + 1));\n        if (pl + 1 != pr)\n            res = std::min(res, *std::min_element(u.begin() + pl + 1, u.begin() + pr));\n        return res;\n    &#125;;\n    for (int op, l, r; m--; ) &#123;\n        std::cin &gt;&gt; op &gt;&gt; l &gt;&gt; r;\n        if (op == 1) &#123;\n            int x;\n            std::cin &gt;&gt; x, ADD(l, r, x);\n        &#125;\n        else\n            std::cout &lt;&lt; ASK(l, r) &lt;&lt; &#39;\\n&#39;;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n",
            "tags": [
                "二分图",
                "计数",
                "DP 套 DP",
                "搜索"
            ]
        }
    ]
}