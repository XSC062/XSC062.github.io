{
    "version": "https://jsonfeed.org/version/1",
    "title": "null • All posts by \"背包\" tag",
    "description": "",
    "home_page_url": "https://xsc062.netlify.app",
    "items": [
        {
            "id": "https://xsc062.netlify.app/20250723/",
            "url": "https://xsc062.netlify.app/20250723/",
            "title": "vp 记录 edu 181",
            "date_published": "2025-07-23T07:06:07.000Z",
            "content_html": "<p>tzl 太强了！真挚的膜拜</p>\n<span id=\"more\"></span>\n<p>lhy 太强了！真挚的膜拜</p>\n<hr />\n<h2 id=\"e.-sets-of-complementary-sums\">E. Sets of Complementary Sums</h2>\n<p><a href=\"https://codeforces.com/contest/2125/problem/E\" class=\"uri\">https://codeforces.com/contest/2125/problem/E</a></p>\n<p>分拆数、其实是个不牛的东西，但是写假了 😅</p>\n<p>令集合元素升序排列为 <span class=\"math inline\">\\(b_{1\\sim n}\\)</span>。显然有结论 <span class=\"math inline\">\\(\\sum b\\geqslant (n-1)(b_n+1)\\)</span>，化一下就有 <span class=\"math inline\">\\(b_n\\geqslant \\left(\\sum\\limits_{i=1}^{n-1} b_n-b_i\\right)+(n-1)\\)</span>。发现 RSH 取值对 LSH 无影响（从取等开始，RSH 不变，若 <span class=\"math inline\">\\(b_n\\gets b_n+1\\)</span>，只需将每个 <span class=\"math inline\">\\(b_i\\gets b_i+1\\)</span> 即可构造出一组解），故只用考虑 RSH 的每种取值下的方案。</p>\n<p>然后就可以做 <a href=\"/20250807/\">分拆数</a> 了。发现会 MLE，滚动即可。每次暴力 assign 会很慢，可以用一点巧思清空滚动数组。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 998244353;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int T;\n    for (std::cin &gt;&gt; T; T--; ) &#123;\n        long long n, m;\n        std::cin &gt;&gt; n &gt;&gt; m;\n        if (n * (n - 1) / 2 &gt; m) &#123;\n            std::cout &lt;&lt; 0 &lt;&lt; &#39;\\n&#39;;\n            continue;\n        &#125;\n        if (n == 1) &#123;\n            std::cout &lt;&lt; m &lt;&lt; &#39;\\n&#39;;\n            continue;\n        &#125;\n        --n;\n        std::vector&lt;std::vector&lt;long long&gt; &gt; f(2, std::vector &lt;long long&gt; (m + 1));\n        f[0][0] = 1ll;\n        for (int j = 1, at = 1; j &lt;= n; ++j, at ^= 1)\n            for (int i = 0; i &lt;= m; ++i) &#123;\n                if (i &lt; j)\n                    f[at][i] = 0;\n                else\n                    f[at][i] = (f[at ^ 1][i - j] + f[at][i - j]) % mod;\n            &#125;\n        auto res(0ll);\n        for (int i = 1; i &lt;= m - n; ++i)\n            (res += f[n &amp; 1][i] * (m - (i + n) + 1)) %= mod;\n        std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"vp-记录\">vp 记录</h2>\n<h3 id=\"a\">A</h3>\n<p>1:43 切。打 <code>std::</code> 还是太费时间了。</p>\n<h3 id=\"b\">B</h3>\n<p>5:46 切，看完题没想到 gcd，输出的时候想到了。莼菜。</p>\n<h3 id=\"c\">C</h3>\n<p>11:23 切，原因是容斥符号乱写。</p>\n<h3 id=\"d\">D</h3>\n<p>24:21 切，中间重构了一次并且前缀和的部分考虑得有点问题。绅士（38:35）问我为啥做这么快。</p>\n<h3 id=\"e.0\">E.0</h3>\n<p>看了一眼感觉不太可做。quack 说 F 板板，故跳。</p>\n<h3 id=\"f\">F</h3>\n<p>01:13:41 草完。奇怪的 WQS 二分板板。吃了一发罚时，原因是没人合法的时候要输出 <span class=\"math inline\">\\(0\\)</span>。但和 maimai 的 30 发比起来还是相形见绌。绅士考虑了这个，但是没判目标 <span class=\"math inline\">\\(&lt;\\)</span> 当前的情况遗憾 4 题离场。</p>\n<p>场下看了 Diagnostics，发现其实第二发有个地方是 RE 了的（长度不足 <span class=\"math inline\">\\(6\\)</span> 我的 <code>*std::max_element</code> 会飞起来），但是不知道为啥就是 A 了。</p>\n<h3 id=\"e.1\">E.1</h3>\n<p>猜到结论之后止步于此。试着打了分拆数然后（实际上是）写挂了，怀疑自己结论出错直到 5 题招笑离场 😅</p>\n<h3 id=\"b.1\">B.1</h3>\n<p>哈哈 B 的 gcd 没开 <code>long long</code> 被 hack 了，rk55 to 6000+</p>\n",
            "tags": [
                "差分",
                "背包"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20250520/",
            "url": "https://xsc062.netlify.app/20250520/",
            "title": "杂题",
            "date_published": "2025-05-20T14:22:43.000Z",
            "content_html": "<p>manual 是 anual 的 m 词形式（胡言乱语）</p>\n<p>Everyone is potential. （每个人都是蛋白质。）</p>\n<span id=\"more\"></span>\n<hr />\n<h2 id=\"cf2043e-matrix-transformation\">CF2043E Matrix Transformation</h2>\n<p><a href=\"https://codeforces.com/problemset/problem/2043/E\" class=\"uri\">https://codeforces.com/problemset/problem/2043/E</a></p>\n<blockquote>\n<p>给定 <span class=\"math inline\">\\(n\\times m\\)</span> 的 <span class=\"math inline\">\\(01\\)</span> 矩阵 <span class=\"math inline\">\\(A,B\\)</span>，可任意将 <span class=\"math inline\">\\(A\\)</span> 的一行置为 <span class=\"math inline\">\\(0\\)</span> 或一列置为 <span class=\"math inline\">\\(1\\)</span>，问是否能将 <span class=\"math inline\">\\(A\\)</span> 变成 <span class=\"math inline\">\\(B\\)</span>。</p>\n</blockquote>\n<p>发现如果 <span class=\"math inline\">\\(B\\)</span> 的某一行是 <span class=\"math inline\">\\(0\\)</span>，那么不管 <span class=\"math inline\">\\(A\\)</span> 这一行是什么东西都可以通过一次操作让这一行满足条件（当然，要求这步操作最后进行）。列也是相似的。</p>\n<p>那么就有一个撤销的思路，从 <span class=\"math inline\">\\(B\\)</span> 中不断删除全 <span class=\"math inline\">\\(0\\)</span> 行或全 <span class=\"math inline\">\\(1\\)</span> 列，不能删了就对比二者剩下的部分是否全等（因为此时任何操作都是非法的）。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int T;\n    for (std::cin &gt;&gt; T; T--; ) &#123;\n        int n, m;\n        std::cin &gt;&gt; n &gt;&gt; m;\n        using arr = std::vector&lt;int&gt;;\n        using brr = std::vector&lt;arr&gt;;\n        using crr = std::vector&lt;brr&gt;;\n        brr cn(31, arr(n + 1)), cm(31, arr(m + 1));\n        crr a(31, brr(n + 1, arr(m + 1))), b(31, brr(n + 1, arr(m + 1)));\n        for (int i = 1; i &lt;= n; ++i)\n            for (int j = 1, x; j &lt;= m; ++j) &#123;\n                std::cin &gt;&gt; x;\n                for (int k = 0; k &lt; 31; ++k)\n                    a[k][i][j] = (x &gt;&gt; k) &amp; 1;\n            &#125;\n        for (int i = 1; i &lt;= n; ++i)\n            for (int j = 1, x; j &lt;= m; ++j) &#123;\n                std::cin &gt;&gt; x;\n                for (int k = 0; k &lt; 31; ++k) &#123;\n                    b[k][i][j] = (x &gt;&gt; k) &amp; 1;\n                    cn[k][i] += b[k][i][j];\n                    cm[k][j] += !b[k][i][j];\n                &#125;\n            &#125;\n        for (int k = 0; k &lt; 31; ++k) &#123;\n            std::queue&lt;int&gt; qn, qm;\n            std::vector&lt;int&gt; tn(n + 1, 1), tm(m + 1, 1);\n            for (int i = 1; i &lt;= n; ++i)\n                if (!cn[k][i])\n                    tn[i] = 0, qn.push(i);\n            for (int j = 1; j &lt;= m; ++j)\n                if (!cm[k][j])\n                    tm[j] = 0, qm.push(j);\n            for (; !qn.empty() || !qm.empty(); ) &#123;\n                if (!qn.empty()) &#123;\n                    int i = qn.front();\n                    // printf(&quot;delete line %d\\n&quot;, i);\n                    qn.pop();\n                    for (int j = 1; j &lt;= m; ++j)\n                        if (!b[k][i][j] &amp;&amp; !--cm[k][j])\n                            tm[j] = 0, qm.push(j);\n                &#125;\n                else &#123;\n                    int j = qm.front();\n                    // printf(&quot;delete column %d\\n&quot;, j);\n                    qm.pop();\n                    for (int i = 1; i &lt;= n; ++i)\n                        if (b[k][i][j] &amp;&amp; !--cn[k][i])\n                            tn[i] = 0, qn.push(i);\n                &#125;\n            &#125;\n            for (int i = 1; i &lt;= n; ++i)\n                if (tn[i])\n                    for (int j = 1; j &lt;= m; ++j)\n                        if (tm[j] &amp;&amp; a[k][i][j] != b[k][i][j]) &#123;\n                            // printf(&quot;k = %d: (%d, %d)\\n&quot;, k, i, j);\n                            goto nosol;\n                        &#125;\n        &#125;\n        std::cout &lt;&lt; &quot;Yes\\n&quot;;\n        continue;\n    nosol :\n        std::cout &lt;&lt; &quot;No\\n&quot;;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"cf2043f-nim\">CF2043F Nim</h2>\n<p><a href=\"https://codeforces.com/contest/2043/problem/F\" class=\"uri\">https://codeforces.com/contest/2043/problem/F</a></p>\n<blockquote>\n<p>给定 <span class=\"math inline\">\\(m\\)</span> 次询问，每次问从 <span class=\"math inline\">\\(a_l\\sim a_r\\)</span> 选非空子序列使得异或和为 <span class=\"math inline\">\\(0\\)</span>，问子序列最小长度、该前提下的方案数。</p>\n</blockquote>\n<p>发现子序列问题可以等价为背包；背包可以合并（即把整区间拆成若干段后，两两信息可以合并）；<a href=\"/20231117/#关于背包\">背包可以放在分治上</a>；</p>\n<p>由此，把询问离线下来放在 <span class=\"math inline\">\\(a_{1\\sim n}\\)</span> 的分治上，每次只处理在 <span class=\"math inline\">\\([l,r]\\)</span> 间且跨越 <span class=\"math inline\">\\(mid\\)</span> 的询问就可以得到答案。复杂度 <span class=\"math inline\">\\(O(n\\cdot v^2\\log n)\\)</span>。</p>\n<details>\n<p>不要用方案数是否为 <span class=\"math inline\">\\(0\\)</span> 来判断是否无解！因为方案数可能是 <span class=\"math inline\">\\(998244353\\)</span> 的倍数……</p>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int siz = 63;\nconst int mod = 998244353;\nconst int inf = 0x3f3f3f3f;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, m;\n    std::cin &gt;&gt; n &gt;&gt; m;\n    std::vector&lt;int&gt; a(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i];\n    struct _ &#123; int l, r, id; &#125;;\n    std::vector&lt;_&gt; q(m + 1);\n    std::vector&lt;std::pair&lt;int, long long&gt; &gt; res(m + 1, &#123; inf, 0ll &#125;);\n    for (int i = 1; i &lt;= m; ++i) &#123;\n        std::cin &gt;&gt; q[i].l &gt;&gt; q[i].r;\n        q[i].id = i;\n    &#125;\n    std::function&lt;void(int, int, std::vector&lt;_&gt; &amp;q)&gt; calc = [&amp;](int l, int r, std::vector&lt;_&gt; &amp;q) &#123;\n        if (l == r) &#123;\n            for (auto [l, r, id] : q)\n                if (a[l] == 0)\n                    res[id] = &#123; 0, 1ll &#125;;\n            return;\n        &#125;\n        int mid = (l + r) &gt;&gt; 1;\n        std::vector&lt;_&gt; ql, qr, qm;\n        for (; !q.empty(); q.pop_back()) &#123;\n            if (q.back().r &lt;= mid)\n                ql.push_back(std::move(q.back()));\n            else if (q.back().l &gt; mid)\n                qr.push_back(std::move(q.back()));\n            else\n                qm.push_back(std::move(q.back()));\n        &#125;\n        calc(l, mid, ql), calc(mid + 1, r, qr);\n        std::vector&lt;std::vector&lt;int&gt; &gt; f(r - l + 1, std::vector&lt;int&gt; (siz + 1, inf));\n        std::vector&lt;std::vector&lt;long long&gt; &gt; g(r - l + 1, std::vector&lt;long long&gt; (siz + 1));\n        f[mid - l][a[mid]] = 1ll, g[mid - l][a[mid]] = 1ll;\n        for (int i = mid - l - 1; ~i; --i) &#123;\n            int k = a[i + l];\n            f[i] = f[i + 1], g[i] = g[i + 1];\n            if (f[i][k] == 1)\n                (++g[i][k]) %= mod;\n            else\n                f[i][k] = 1, g[i][k] = 1ll;\n            for (int j = 0, k = a[i + l]; j &lt;= siz; ++j)\n                if (f[i + 1][j ^ k] + 1 &lt; f[i][j])\n                    f[i][j] = f[i + 1][j ^ k] + 1, g[i][j] = g[i + 1][j ^ k];\n                else if (f[i + 1][j ^ k] + 1 == f[i][j])\n                    (g[i][j] += g[i + 1][j ^ k]) %= mod;\n        &#125;\n        f[mid - l + 1][a[mid + 1]] = 1ll, g[mid - l + 1][a[mid + 1]] = 1ll;\n        for (int i = mid - l + 2; i &lt;= r - l; ++i) &#123;\n            int k = a[i + l];\n            f[i] = f[i - 1], g[i] = g[i - 1];\n            if (f[i][k] == 1)\n                (++g[i][k]) %= mod;\n            else\n                f[i][k] = 1, g[i][k] = 1ll;\n            for (int j = 0; j &lt;= siz; ++j)\n                if (f[i - 1][j ^ k] + 1 &lt; f[i][j])\n                    f[i][j] = f[i - 1][j ^ k] + 1, g[i][j] = g[i - 1][j ^ k];\n                else if (f[i - 1][j ^ k] + 1 == f[i][j])\n                    (g[i][j] += g[i - 1][j ^ k]) %= mod;\n        &#125;\n        for (auto [ql, qr, id] : qm) &#123;\n            // printf(&quot;at [%d, %d], mid = %d: ASK [%d, %d]: \\n&quot;, l, r, mid, ql, qr);\n            ql -= l, qr -= l;\n            if (f[ql][0] &lt; inf)\n                res[id].first = f[ql][0], res[id].second = g[ql][0];\n            if (f[qr][0] &lt; res[id].first)\n                res[id].first = f[qr][0], res[id].second = g[qr][0];\n            else if (f[qr][0] == res[id].first)\n                (res[id].second += g[qr][0]) %= mod;\n            for (int i = 1; i &lt;= siz; ++i) &#123;\n                // printf(&quot;  %d[%d]: %d(%lld)  |  %d[%d]: %d(%lld)\\n&quot;, ql + l, i, f[ql][i], g[ql][i], qr + l, i, f[qr][i], g[qr][i]);\n                if (f[ql][i] + f[qr][i] &lt; res[id].first)\n                    res[id].first = f[ql][i] + f[qr][i], res[id].second = g[ql][i] * g[qr][i] % mod;\n                else if (f[ql][i] + f[qr][i] == res[id].first)\n                    (res[id].second += g[ql][i] * g[qr][i]) %= mod;\n            &#125;\n            if (res[id].first &lt; inf)\n                res[id].first = (qr - ql + 1) - res[id].first;\n        &#125;\n        return;\n    &#125;;\n    calc(1, n, q);\n    for (int i = 1; i &lt;= m; ++i)\n        if (res[i].first &lt; inf)\n            std::cout &lt;&lt; res[i].first &lt;&lt; &#39; &#39; &lt;&lt; res[i].second &lt;&lt; &#39;\\n&#39;;\n        else\n            std::cout &lt;&lt; -1 &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"贪玩蓝月\">贪玩蓝月</h2>\n<p><a href=\"https://loj.ac/p/6515\" class=\"uri\">https://loj.ac/p/6515</a></p>\n<p><em>差不多的题：<a href=\"https://atcoder.jp/contests/jag2018summer-day2/tasks/jag2018summer_day2_d\" class=\"uri\">https://atcoder.jp/contests/jag2018summer-day2/tasks/jag2018summer_day2_d</a>，注意加入是按体积单增的</em></p>\n<p>发现断点确定时可以背包 <span class=\"math inline\">\\(O(p)\\)</span> 维护插入删除；使用 <a href=\"/20231117/#双栈模拟双端队列\">双栈模拟双端队列</a> 就可以均摊 <span class=\"math inline\">\\(O(pm)\\)</span> 实现插入删除。</p>\n<p>对于询问，当然可以 <span class=\"math inline\">\\(O(p^2)\\)</span> 枚举最值再枚举方案（即枚举一端的贡献）；但复杂度不太美观。考虑倒过来，先 <span class=\"math inline\">\\(O(v)\\)</span> 枚举一端贡献，再枚举『能凑出 <span class=\"math inline\">\\([l,r]\\)</span> 中的值』的另一端的贡献。这样就发现我们是在求区间最大值；每次询问时构建 ST 表预处理另一端的区间最大值即可。</p>\n<p>复杂度 <span class=\"math inline\">\\(O(mq\\log q)\\)</span>。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst long long inf = 1e18;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int m, mod;\n    std::cin &gt;&gt; m &gt;&gt; m &gt;&gt; mod;\n    std::array&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt;, 2&gt; T;\n    std::array&lt;std::vector&lt;std::vector&lt;long long&gt; &gt;, 2&gt; F;\n    F[0].emplace_back(mod, -inf), F[1].emplace_back(mod, -inf);\n    F[0][0][0] = 0ll, F[1][0][0] = 0ll;\n    for (; m--; ) &#123;\n        std::string op;\n        std::cin &gt;&gt; op;\n        if (op[0] == &#39;I&#39;) &#123;\n            int v, w;\n            std::cin &gt;&gt; v &gt;&gt; w, v %= mod;\n            auto &amp;t = T[op[1] == &#39;G&#39;];\n            auto &amp;f = F[op[1] == &#39;G&#39;];\n            t.emplace_back(v, w);\n            f.emplace_back(f.back());\n            for (int i = (int)f.size() - 1, j = 0; j &lt; mod; ++j)\n                if (f[i - 1][(j + mod - v) % mod] + w &gt; f[i][j])\n                    f[i][j] = f[i - 1][(j + mod - v) % mod] + w;\n        &#125;\n        else if (op[0] == &#39;D&#39;) &#123;\n            auto &amp;t0 = T[op[1] == &#39;G&#39;], &amp;t1 = T[op[1] == &#39;F&#39;];\n            auto &amp;f0 = F[op[1] == &#39;G&#39;], &amp;f1 = F[op[1] == &#39;F&#39;];\n            if (t0.empty()) &#123;\n                t1.erase(t1.begin());\n                int to = t1.size() / 2;\n                std::vector&lt;std::pair&lt;int, int&gt; &gt; (t1.begin(), t1.begin() + to).swap(t0);\n                std::reverse(t0.begin(), t0.end());\n                std::vector&lt;std::pair&lt;int, int&gt; &gt; (t1.begin() + to, t1.end()).swap(t1);\n                f0.resize(1), f1.resize(1);\n                for (auto [v, w] : t0) &#123;\n                    f0.emplace_back(f0.back());\n                    for (int i = (int)f0.size() - 1, j = 0; j &lt; mod; ++j)\n                        if (f0[i - 1][(j + mod - v) % mod] + w &gt; f0[i][j])\n                            f0[i][j] = f0[i - 1][(j + mod - v) % mod] + w;\n                &#125;\n                for (auto [v, w] : t1) &#123;\n                    f1.emplace_back(f1.back());\n                    for (int i = (int)f1.size() - 1, j = 0; j &lt; mod; ++j)\n                        if (f1[i - 1][(j + mod - v) % mod] + w &gt; f1[i][j])\n                            f1[i][j] = f1[i - 1][(j + mod - v) % mod] + w;\n                &#125;\n            &#125;\n            else\n                t0.pop_back(), f0.pop_back();\n        &#125;\n        else &#123;\n            int l, r;\n            std::cin &gt;&gt; l &gt;&gt; r;\n            auto res(-inf);\n            std::vector&lt;std::vector&lt;long long&gt; &gt; st(std::__lg(mod) + 1, std::vector&lt;long long&gt; (mod + 1));\n            st[0] = F[1].back();\n            for (int j = 1; (1 &lt;&lt; j) &lt;= mod; ++j)\n                for (int i = 0; i + (1 &lt;&lt; j) - 1 &lt; mod; ++i)\n                    st[j][i] = std::max(st[j - 1][i], st[j - 1][i + (1 &lt;&lt; (j - 1))]);\n            auto ask = [&amp;](int l, int r) &#123;\n                int k = std::__lg(r - l + 1);\n                return std::max(st[k][l], st[k][r - (1 &lt;&lt; k) + 1]);\n            &#125;;\n            for (int j = 0; j &lt; mod; ++j)\n                if (j &lt;= l)\n                    res = std::max(res, F[0].back()[j] + ask(l - j, r - j));\n                else if (l &lt; j &amp;&amp; j &lt;= r)\n                    res = std::max(&#123; res, F[0].back()[j] + ask(0, r - j), F[0].back()[j] + ask(l + mod - j, mod - 1) &#125;);\n                else\n                    res = std::max(res, F[0].back()[j] + ask(l + mod - j, r + mod - j));\n            std::cout &lt;&lt; std::max(-1ll, res) &lt;&lt; &#39;\\n&#39;;\n        &#125;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"apio2025-转杆\">APIO2025 转杆</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P12543\" class=\"uri\">https://www.luogu.com.cn/problem/P12543</a></p>\n<p><del>总有一天我要让全天下的数学题 DP 题字符串题图论题模拟题数据结构题思维题全部消失</del></p>\n<p>不要把它转化成序列问题来考虑！这对观察到结论没有好处！</p>\n<p>考虑 <span class=\"math inline\">\\(n=2\\)</span> 的情况，当且仅当垂直时最优。<span class=\"math inline\">\\(n=3\\)</span> 时，随便固定其中一条线，发现剩下两条线如果夹角固定，则代价固定；当夹角取 <span class=\"math inline\">\\(90^{\\circ}\\)</span> 时最优。</p>\n<p>于是猜是不是任意一对都要垂直。考虑数归，当前 <span class=\"math inline\">\\(2n\\)</span> 对 <del>不知道怎么摆的，反正就是</del> 最优时：</p>\n<ul>\n<li>考虑加入第 <span class=\"math inline\">\\(2n+1\\)</span> 条；参照 <span class=\"math inline\">\\(n=3\\)</span> 的情形，把前 <span class=\"math inline\">\\(2n\\)</span> 条任意两两配对，则第 <span class=\"math inline\">\\(2n+1\\)</span> 的位置对代价没有任何影响。</li>\n<li>考虑加入第 <span class=\"math inline\">\\(2n+2\\)</span> 条；相似地，它的位置对前 <span class=\"math inline\">\\(2n\\)</span> 条没有任何影响；故需要最大化它和第 <span class=\"math inline\">\\(2n+1\\)</span> 条的贡献。取垂直即可。</li>\n</ul>\n<p>因此得到任意一对都要垂直。具体怎么调整呢？首先下意识排序；配对方式即将 <span class=\"math inline\">\\(i\\)</span> 与 <span class=\"math inline\">\\(\\dfrac i+\\lfloor \\frac n2\\rfloor\\)</span> 配对；因为能感受到这样影响的线段最少。严谨的证明好像没看到。</p>\n<details>\n<pre class=\"cpp\"><code>#include&lt;bits/stdc++.h&gt;\nvoid energy(int, std::vector&lt;int&gt;);\nvoid rotate(std::vector&lt;int&gt;, int);\nvoid energy(int n, std::vector&lt;int&gt; a) &#123;\n    std::vector&lt;int&gt; id(n);\n    std::iota(id.begin(), id.end(), 0);\n    std::sort(id.begin(), id.end(), [&amp;](int x, int y) &#123; return a[x] &lt; a[y]; &#125;);\n    for (int i = 0, j = n / 2; i &lt; n / 2; ++i, ++j)\n        rotate(&#123; id[j] &#125;, (a[id[i]] + 75000 - a[id[j]]) % 50000);\n    return;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"abc407e-most-valuable-parentheses\">ABC407E Most Valuable Parentheses</h2>\n<p><a href=\"https://atcoder.jp/contests/abc407/tasks/abc407_e\" class=\"uri\">https://atcoder.jp/contests/abc407/tasks/abc407_e</a></p>\n<p>这里有一个很典（可惜我不知道）的 trick：<a href=\"/20231117/#贪心选取括号序列\">贪心构造最优括号序列</a>。</p>\n<p>用优先队列维护，贪心选即可。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int T;\n    for (std::cin &gt;&gt; T; T--; ) &#123;\n        int n;\n        std::cin &gt;&gt; n;\n        std::vector&lt;int&gt; a(2 * n + 1);\n        for (int i = 1; i &lt;= 2 * n; ++i)\n            std::cin &gt;&gt; a[i];\n        long long res = a[1];\n        std::priority_queue&lt;int&gt; q;\n        for (int i = 2; i &lt; 2 * n; i += 2) &#123;\n            q.push(a[i]), q.push(a[i + 1]);\n            res += q.top(), q.pop();\n        &#125;\n        std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n",
            "tags": [
                "分治",
                "背包"
            ]
        }
    ]
}