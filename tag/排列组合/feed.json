{
    "version": "https://jsonfeed.org/version/1",
    "title": "null • All posts by \"排列组合\" tag",
    "description": "",
    "home_page_url": "https://xsc062.netlify.app",
    "items": [
        {
            "id": "https://xsc062.netlify.app/20250419/",
            "url": "https://xsc062.netlify.app/20250419/",
            "title": "杂题选谈：网格图路径计数",
            "date_published": "2025-04-19T02:03:57.000Z",
            "content_html": "<figure>\n<img src=\"/20250419/neko.jpeg\" alt=\"猫\" style=\"width: 75px\">\n<figcaption>\n猫\n</figcaption>\n</figure>\n<span id=\"more\"></span>\n<hr />\n<h2 id=\"点到点的方案数\">点到点的方案数</h2>\n<p>从 <span class=\"math inline\">\\((x_1,y_1)\\)</span> 只能向右、向下走到 <span class=\"math inline\">\\((x_2,y_2)\\)</span> 的方案数：<span class=\"math inline\">\\(C_{x_2-x_1+y_2-y_1}^{x_2-x_1}\\)</span>。就是说，因为必须向下走 <span class=\"math inline\">\\(x_2-x_1\\)</span> 步，又必须向右走 <span class=\"math inline\">\\(y_2-y_1\\)</span> 步；但顺序是可以任意打乱的。</p>\n<hr />\n<h3 id=\"a---gerald-and-giant-chess\">A - Gerald and Giant Chess</h3>\n<p><a href=\"https://codeforces.com/problemset/problem/560/E\" class=\"uri\">https://codeforces.com/problemset/problem/560/E</a></p>\n<p>把不能走的点按 <span class=\"math inline\">\\(x\\)</span> 为第一关键字，<span class=\"math inline\">\\(y\\)</span> 为第二关键字排序，就可以得到它们按大致拓扑序排列的结果。</p>\n<p>令 <span class=\"math inline\">\\(f_i\\)</span> 表示不经过 <span class=\"math inline\">\\(1\\sim i-1\\)</span> 的非法点走到第 <span class=\"math inline\">\\(i\\)</span> 个非法点的方案数，就可以得到 <span class=\"math inline\">\\(f_i=C_{x_i+y_i,x_i}-\\sum_{j=1}^{i-1} f_j\\times C_{x_i-x_j+y_i-y_j}^{x_i-x_j}\\)</span>。可以发现后面减去的方案，因为碰到的第一个非法点不同，所以是两两不同的。</p>\n<p>让 <span class=\"math inline\">\\((h,w)\\)</span> 成为第 <span class=\"math inline\">\\((n+1)\\)</span> 个非法点，<span class=\"math inline\">\\(f_{n+1}\\)</span> 就是答案。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 1e9 + 7;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int h, w, n;\n    std::cin &gt;&gt; h &gt;&gt; w &gt;&gt; n, --h, --w;\n    std::vector&lt;std::pair&lt;int, int&gt; &gt; a(n + 2);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; a[i].first &gt;&gt; a[i].second;\n        --a[i].first, --a[i].second;\n    &#125;\n    a[n + 1] = &#123; h, w &#125;;\n    std::sort(a.begin() + 1, a.end());\n    std::vector&lt;long long&gt; fac(h + w + 1), inv(h + w + 1);\n    fac[0] = inv[0] = 1ll;\n    for (int i = 1; i &lt;= h + w; ++i)\n        fac[i] = fac[i - 1] * i % mod;\n    auto qkp = [](long long x, int y) &#123;\n        auto res = 1ll;\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    inv[h + w] = qkp(fac[h + w], mod - 2);\n    for (int i = h + w - 1; i; --i)\n        inv[i] = inv[i + 1] * (i + 1) % mod;\n    auto C = [&amp;](int n, int m) &#123;\n        return fac[n] * inv[n - m] % mod * inv[m] % mod;\n    &#125;;\n    std::vector&lt;long long&gt; f(n + 2);\n    for (int i = 1; i &lt;= n + 1; ++i) &#123;\n        f[i] = C(a[i].first + a[i].second, a[i].first);\n        for (int j = 1; j &lt; i; ++j)\n            if (a[j].second &lt;= a[i].second)\n                (f[i] += mod - f[j] * C(a[i].first - a[j].first + a[i].second - a[j].second, a[i].first - a[j].first) % mod) %= mod;\n        // printf(&quot;f[(%d, %d)] = %lld\\n&quot;, a[i].first, a[i].second, f[i]);\n    &#125;\n    std::cout &lt;&lt; f[n + 1] &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"b---bbq-hard\">B - BBQ Hard</h3>\n<p><a href=\"https://atcoder.jp/contests/agc001/tasks/agc001_e\" class=\"uri\">https://atcoder.jp/contests/agc001/tasks/agc001_e</a></p>\n<p>不仅仅可以在关键点上 DP，也可以在网格上直接 DP。</p>\n<p><span class=\"math inline\">\\(A_i+B_i+A_j+B_j\\)</span> 就是 <span class=\"math inline\">\\(A_i+B_i-(-A_j)-(-B_j)\\)</span>。把棋盘扩大到 <span class=\"math inline\">\\(-2000\\to 2000\\)</span> 就可以了。</p>\n<p>设 <span class=\"math inline\">\\(f_{i,j}\\)</span> 表示可以到达 <span class=\"math inline\">\\((i,j)\\)</span> 的所有发出关键点 <span class=\"math inline\">\\((-A_j,-B_j)\\)</span> 带来的贡献，那么 <span class=\"math inline\">\\(f_{i,j}=f_{i-1,j}+f_{i,j-1}\\)</span>。枚举所有接收关键点 <span class=\"math inline\">\\((A_i,B_i)\\)</span>，<span class=\"math inline\">\\(\\sum f_{A_i,B_i}\\)</span> 就是答案的两倍，再减去对角线，也就是 <span class=\"math inline\">\\(\\sum (-A_i,B_i)\\to (A_i,B_i)\\)</span> 后的值。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int N = 2000;\nconst int mod = 1e9 + 7;\nconst int inv2 = 500000004;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;long long&gt; fac(4 * N + 1), inv(4 * N + 1);\n    fac[0] = inv[0] = 1ll;\n    for (int i = 1; i &lt;= 4 * N; ++i)\n        fac[i] = fac[i - 1] * i % mod;\n    auto qkp = [](long long x, int y) &#123;\n        auto res(1ll);\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    inv[4 * N] = qkp(fac[4 * N], mod - 2);\n    for (int i = 4 * N - 1; i; --i)\n        inv[i] = inv[i + 1] * (i + 1) % mod;\n    std::vector&lt;std::pair&lt;int, int&gt; &gt; a(n + 1);\n    std::vector&lt;std::vector&lt;long long&gt; &gt; f(2 * N + 1, std::vector&lt;long long&gt; (2 * N + 1));\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; a[i].first &gt;&gt; a[i].second;\n        ++f[N - a[i].first][N - a[i].second];\n    &#125;\n    for (int i = 0; i &lt;= 2 * N; ++i)\n        for (int j = 0; j &lt;= 2 * N; ++j) &#123;\n            if (i &gt;= 1)\n                (f[i][j] += f[i - 1][j]) %= mod;\n            if (j &gt;= 1)\n                (f[i][j] += f[i][j - 1]) %= mod;\n            // printf(&quot;f(%2d, %2d) = %lld\\n&quot;, i - N, j - N, f[i][j]);\n        &#125;\n    long long res = 0ll;\n    auto C = [&amp;](int n, int m) &#123;\n        return fac[n] * inv[n - m] % mod * inv[m] % mod;\n    &#125;;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        (res += f[a[i].first + N][a[i].second + N]) %= mod;\n        (res += mod - C(a[i].first * 2 + a[i].second * 2, 2 * a[i].first)) %= mod;\n    &#125;\n    std::cout &lt;&lt; res * inv2 % mod &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"c---iroha-and-a-grid\">C - Iroha and a Grid</h3>\n<p><a href=\"https://atcoder.jp/contests/arc058/tasks/arc058_b\" class=\"uri\">https://atcoder.jp/contests/arc058/tasks/arc058_b</a></p>\n<p>先把绿色部分的答案计算出来：</p>\n<figure>\n<img src=\"1.png\" alt=\"网格\" /><figcaption>网格</figcaption>\n</figure>\n<p>如果把绿色的每一个格子到终点的方案数求和，就会算重，因为上面的绿色点可以走到下面的绿色点。</p>\n<p>让绿色点第一步只能往右走到黄色点，用这样的方案为黄色点赋初值，再让黄色点自由走就可以得到答案了。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 1e9 + 7;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int h, w, a, b;\n    std::cin &gt;&gt; h &gt;&gt; w &gt;&gt; a &gt;&gt; b;\n    std::vector&lt;long long&gt; fac(h + w + 1), inv(h + w + 1);\n    fac[0] = inv[0] = 1ll;\n    for (int i = 1; i &lt;= h + w; ++i)\n        fac[i] = fac[i - 1] * i % mod;\n    auto qkp = [](long long x, int y) &#123;\n        auto res(1ll);\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    inv[h + w] = qkp(fac[h + w], mod - 2);\n    for (int i = h + w - 1; i; --i)\n        inv[i] = inv[i + 1] * (i + 1) % mod;\n    auto C = [&amp;](int n, int m) &#123;\n        return fac[n] * inv[n - m] % mod * inv[m] % mod;\n    &#125;;\n    auto res = 0ll;\n    for (int i = 1; i &lt;= h - a; ++i) &#123;\n        // (i, B)\n        auto f(C(i + b - 2, i - 1));\n        // printf(&quot;(%d, %d): %lld\\n&quot;, i, b, f);\n        // (i, B + 1)\n        (res += f * C(h - i + w - (b + 1), h - i) % mod) %= mod;\n    &#125;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"点到矩形的方案数\">点到矩形的方案数</h2>\n<p>从 <span class=\"math inline\">\\((x_0,y_0)\\)</span> 走到矩形 <span class=\"math inline\">\\((x_1,y_1,x_2,y_2)\\)</span> 的方案数：</p>\n<p><span class=\"math display\">\\[\n\\sum\\limits_{i\\in [x_1,x_2],j\\in [y_1,y_2]} G(x_0,y_0, i, j) = G(x_0,y_0,x_2 + 1,y_2 + 1)-G(x_0,y_0,x_2+1,y_1)-G(x_0,y_0,x_1,y_2+1)+G(x_0,y_0,x_1,y_1)\n\\]</span></p>\n<p>证明：<span class=\"math inline\">\\(G(x_0,y_0,x_2+1,y_2+1)=\\sum\\limits_i G(x_0,y_0,i,y_2)=\\sum\\limits_{i,j} G(x_0,y_0,i,j)\\)</span>，类似的，把后面几项展开，可以得到前缀和的结构。</p>\n<p>现在，矩形就可以被概括成 4 个点了。</p>\n<hr />\n<h2 id=\"矩形到矩形的方案数\">矩形到矩形的方案数</h2>\n<p>枚举第一个矩形里的所有点，那么就可以得到关于第二个矩形里四个点的表达式。反过来把第一个矩形概括为 4 个点就可以快速求解了。</p>\n<p>具体一点，第一个矩形 <span class=\"math inline\">\\((x_1,y_1,x_2,y_2)\\)</span> 可以被概括为 <span class=\"math inline\">\\((x_1-1,y_1-1)\\)</span>，<span class=\"math inline\">\\((x_1-1,y_2)\\)</span>，<span class=\"math inline\">\\((x_2,y_1-1)\\)</span>，<span class=\"math inline\">\\((x_2,y_2)\\)</span>。注意方向颠倒导致符号发生变化。此时对 <span class=\"math inline\">\\(4\\times 4=16\\)</span> 个 <span class=\"math inline\">\\(G\\)</span> 按对应的 <span class=\"math inline\">\\(-1/1\\)</span> 系数求和就能得到答案。</p>\n<hr />\n<h3 id=\"d---sightseeing-plan\">D - Sightseeing Plan</h3>\n<p><a href=\"https://atcoder.jp/contests/agc018/tasks/agc018_e\" class=\"uri\">https://atcoder.jp/contests/agc018/tasks/agc018_e</a></p>\n<ol type=\"1\">\n<li>恒等式：<span class=\"math inline\">\\(\\sum\\limits_{i\\in [x_1,x_2]}G_(x_1,y_1,i,y_2-1)=G(x_1,y_1,x_2,y_2)\\)</span>，放在网格图上就是强制走到 <span class=\"math inline\">\\((i,y_2-1)\\)</span>，再强制向右走一步，然后向上走到 <span class=\"math inline\">\\((x_2,y_2)\\)</span>。和上一题类似的，可以发现不重不漏。</li>\n<li>三个矩形，<span class=\"math inline\">\\(M_1\\)</span> 经过 <span class=\"math inline\">\\(M_2\\)</span> 到达 <span class=\"math inline\">\\(M_3\\)</span> 的路径数量：经过 <span class=\"math inline\">\\(M_2\\)</span> 时，根据限制，只可能从下面或左边进入。枚举进入的点 <span class=\"math inline\">\\((x_0,y_0)\\)</span>（数量为 <span class=\"math inline\">\\(O(n)\\)</span>），再计算 <span class=\"math inline\">\\(G(x_0,y_0,M_3)\\)</span> 就能得到不重不漏的答案。</li>\n<li>原问题：要求 <span class=\"math inline\">\\(M_2\\)</span> 内部路径上点的贡献和，这个其实就是 <span class=\"math inline\">\\(M_2\\)</span> 内部路径长度。若从 <span class=\"math inline\">\\((x_1,y_1)\\)</span> 进入，再从 <span class=\"math inline\">\\((x_2,y_2)\\)</span> 离开，长度就是 <span class=\"math inline\">\\(x_2-x_1+y_2-y_1+1\\)</span>。拆成 <span class=\"math inline\">\\((x_2+y_2+1)\\)</span> 和 <span class=\"math inline\">\\(-(x_1+y_1)\\)</span> 后发现一次进入和一次离开的贡献是独立的。分别枚举进入点和离开点计算贡献就可以了。</li>\n</ol>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int N = 2e6;\nconst int mod = 1e9 + 7;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int x1, x2, x3, x4, x5, x6, y1, y2, y3, y4, y5, y6;\n    std::cin &gt;&gt; x1 &gt;&gt; x2 &gt;&gt; x3 &gt;&gt; x4 &gt;&gt; x5 &gt;&gt; x6;\n    std::cin &gt;&gt; y1 &gt;&gt; y2 &gt;&gt; y3 &gt;&gt; y4 &gt;&gt; y5 &gt;&gt; y6;\n    std::vector&lt;long long&gt; fac(N + 1), inv(N + 1);\n    fac[0] = inv[0] = 1ll;\n    for (int i = 1; i &lt;= N; ++i)\n        fac[i] = fac[i - 1] * i % mod;\n    auto qkp = [](long long x, int y) &#123;\n        auto res(1ll);\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    inv[N] = qkp(fac[N], mod - 2);\n    for (int i = N - 1; i; --i)\n        inv[i] = inv[i + 1] * (i + 1) % mod;\n    auto C = [&amp;](int n, int m) &#123;\n        return fac[n] * inv[n - m] % mod * inv[m] % mod;\n    &#125;;\n    std::vector&lt;std::tuple&lt;int, int, int&gt; &gt; f(4), g(4);\n    f[0] = &#123; x1 - 1, y1 - 1, 1 &#125;, f[1] = &#123; x1 - 1, y2, mod - 1 &#125;, f[2] = &#123; x2, y1 - 1, mod - 1 &#125;, f[3] = &#123; x2, y2, 1 &#125;;\n    g[0] = &#123; x5, y5, 1 &#125;, g[1] = &#123; x5, y6 + 1, mod - 1 &#125;, g[2] = &#123; x6 + 1, y5, mod - 1 &#125;, g[3] = &#123; x6 + 1, y6 + 1, 1 &#125;; \n    auto G = [&amp;](int x1, int y1, int x2, int y2) &#123;\n        auto a(std::abs(x1 - x2)), b(std::abs(y1 - y2));\n        return C(a + b, a);\n    &#125;;\n    auto res = 0ll;\n    for (auto [x1, y1, k1] : f)\n        for (auto [x2, y2, k2] : g) &#123;\n            auto t(0ll);\n            for (int x = x3; x &lt;= x4; ++x) &#123;\n                (t += G(x1, y1, x, y4) * G(x, y4 + 1, x2, y2) % mod * (x + y4 + 1) % mod) %= mod;\n                (t += mod - G(x1, y1, x, y3 - 1) * G(x, y3, x2, y2) % mod * (x + y3) % mod) %= mod;\n            &#125;\n            for (int y = y3; y &lt;= y4; ++y) &#123;\n                (t += G(x1, y1, x4, y) * G(x4 + 1, y, x2, y2) % mod * (x4 + y + 1) % mod) %= mod;\n                (t += mod - G(x1, y1, x3 - 1, y) * G(x3, y, x2, y2) % mod * (x3 + y) % mod) %= mod;\n            &#125;\n            // printf(&quot;(%d, %d, %d), (%d, %d, %d): %lld\\n&quot;, x1, y1, k1, x2, y2, k2, t * k1 % mod * k2 % mod);\n            (res += t * k1 % mod * k2 % mod) %= mod;\n        &#125;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"不经过-yxc-的方案数\">不经过 <span class=\"math inline\">\\(y=x+c\\)</span> 的方案数</h2>\n<p>Catalan 数的一种推导方式是，在 <span class=\"math inline\">\\(n\\times n\\)</span> 的网格上，要求不能越过 <span class=\"math inline\">\\(y=x\\)</span> 的方案数。可以用总方案数减去越过的方案数。</p>\n<p>怎么计算非法的方案呢？越过 <span class=\"math inline\">\\(y=x\\)</span> 的路径必定存在一个点经过 <span class=\"math inline\">\\(y=x+1\\)</span>，原问题转化为不能碰到 <span class=\"math inline\">\\(y=x+1\\)</span> 的方案数。</p>\n<p>把终点 <span class=\"math inline\">\\((n, n)\\)</span> 翻折到 <span class=\"math inline\">\\(y=x+1\\)</span> 上方，得到 <span class=\"math inline\">\\((n-1, n + 1)\\)</span>；对于任意到达 <span class=\"math inline\">\\((n-1,n+1)\\)</span> 的路径，一定会接触 <span class=\"math inline\">\\(y=x+1\\)</span> 至少一次；将第一次接触以后的路径翻折到 <span class=\"math inline\">\\(y=x+1\\)</span> 下方，则一定和原图中的非法路径一一对应。</p>\n<p><img src=\"4.png\" /></p>\n<p>就可以得到 <span class=\"math inline\">\\(C_{2n}^n-C_{2n}^{n-1}\\)</span>。</p>\n<p>如果问题变得更加一般，求解到达 <span class=\"math inline\">\\((n, m)\\)</span> 不能碰到 <span class=\"math inline\">\\(y=x+c\\)</span> 的方案数，还是可以把 <span class=\"math inline\">\\((n,m)\\)</span> 翻折到 <span class=\"math inline\">\\((m-c,n+c)\\)</span>，答案是 <span class=\"math inline\">\\(C_{n+m}^n-C_{n+m}^{m-c}\\)</span>。</p>\n<hr />\n<h2 id=\"不经过-yx-l-和-yxr-的方案数\">不经过 <span class=\"math inline\">\\(y=x-l\\)</span> 和 <span class=\"math inline\">\\(y=x+r\\)</span> 的方案数</h2>\n<p>现在有 <span class=\"math inline\">\\(y=x-l\\)</span> 和 <span class=\"math inline\">\\(y=x+r\\)</span> 两条线作为限制，现在的翻折意义就会有一点改变。</p>\n<p><img src=\"5.png\" /></p>\n<p>比如图中的 <span class=\"math inline\">\\(A&#39;\\)</span>，是 <span class=\"math inline\">\\(A\\)</span> 沿着 <span class=\"math inline\">\\(y=x-l\\)</span> 翻折一次后的结果。还是按照之前的方式来理解，那么走到 <span class=\"math inline\">\\(A&#39;\\)</span> 的路径代表至少经过一次 <span class=\"math inline\">\\(y=x-l\\)</span> 的方案。<span class=\"math inline\">\\(A&#39;&#39;\\)</span> 是 <span class=\"math inline\">\\(A&#39;\\)</span> 沿着 <span class=\"math inline\">\\(y=x+r\\)</span> 翻折一次之后得到的结果，走到 <span class=\"math inline\">\\(A&#39;&#39;\\)</span> 的路径就代表至少先碰到一次 <span class=\"math inline\">\\(y=x-l\\)</span>，再碰到一次 <span class=\"math inline\">\\(y=x+r\\)</span> 的方案数。</p>\n<p>如果把相邻多次碰到 <span class=\"math inline\">\\(y=x-l\\)</span> 或 <span class=\"math inline\">\\(y=x+r\\)</span> 合并为一次，最终的非法路径就是 <code>LRLRLR...</code> 或者 <code>RLRLRL...</code> 的形式。因为可以计算的是「至少」的形式，用容斥原理得到，答案是 <span class=\"math inline\">\\(f_{\\varnothing}-(f_{\\texttt L} + f_{\\texttt R}) + (f_{\\texttt {LR}} + f_{\\texttt {RL}}) - \\cdots\\)</span>。对应计算每个翻折对应终点和答案就可以了。最后的答案是 <span class=\"math inline\">\\(C_{n+m}^n-C_{n+m}^{n+l}-C_{n+m}^{n + r}+C_{n+m}^{n+l-r}+C_{n+m}^{n+r-l}-\\cdots\\)</span>，可以简化成 <span class=\"math inline\">\\(\\sum\\limits_{k\\in \\mathbb{Z}} C_{n+m}^{n-k\\cdot (r-l)}-C_{n+m}^{n-k\\cdot (r-l)+r}\\)</span>。</p>\n<hr />\n<h3 id=\"e---骗我呢\">E - 骗我呢</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P3266\" class=\"uri\">https://www.luogu.com.cn/problem/P3266</a></p>\n<p>每行内部递增，而且选项只有 <span class=\"math inline\">\\([0,m]\\)</span>，那么每行就会刚好在 <span class=\"math inline\">\\([0,m]\\)</span> 里面跳过一个数。</p>\n<p>如果第 <span class=\"math inline\">\\(i\\)</span> 行跳过的数是 <span class=\"math inline\">\\(j\\)</span>，那么画一画图就可以发现第 <span class=\"math inline\">\\(i+1\\)</span> 可能跳过的数是 <span class=\"math inline\">\\([j-1,m]\\)</span>；反过来，第 <span class=\"math inline\">\\(i-1\\)</span> 行可能跳过的数就是 <span class=\"math inline\">\\([0,j+1]\\)</span>。</p>\n<p>如果让 <span class=\"math inline\">\\(f_{i,j}\\)</span> 表示确定了第 <span class=\"math inline\">\\(1\\to i\\)</span> 行，其中第 <span class=\"math inline\">\\(i\\)</span> 行跳过 <span class=\"math inline\">\\(j\\)</span> 的方案数，就可以得到 <span class=\"math inline\">\\(f_{i,j}=\\sum\\limits_{k=0}^{j+1} f_{i-1,k}\\)</span>。前缀和得到 <span class=\"math inline\">\\(f_{i,j}=f_{i,j-1}+f_{i-1,j+1}\\)</span>。注意边界：<span class=\"math inline\">\\(f_{0,j}=1\\)</span>；<span class=\"math inline\">\\(f_{i,0}=f_{i-1,0}+f_{i-1,1}\\)</span>；<span class=\"math inline\">\\(f_{i,m}=f_{i,m-1}\\)</span>。</p>\n<p>为了得到答案，让 <span class=\"math inline\">\\(g_{i,j}\\)</span> 表示 <span class=\"math inline\">\\(i\\times j\\)</span> 矩阵的方案数（这样就有机会通过手段优化了）：</p>\n<p><span class=\"math display\">\\[\n\\begin{aligned}\ng_{i,j}&amp;=\\sum_{k=0}^j f_{i,k}\\\\\n&amp;= f_{i-1,0}+f_{i-1,1}+\\sum_{k=1}^j f_{i,k-1}+f_{i-1,k+1}\\\\\n&amp;= g_{i,j-1}+g_{i-1,j+1}\n\\end{aligned}\n\\]</span></p>\n<p>边界情况呢， <span class=\"math inline\">\\(g_{i, 0} = f_{i,0} = f_{i-1, 0} + f_{i - 1, 1} = g_{i-1,1}\\)</span>；<span class=\"math inline\">\\(g_{i,m}=g_{i, m - 1} + f_{i,m}=g_{i-1,m}+g_{i,m-1}\\)</span>。 <span class=\"math inline\">\\(g_{i,m+1}=g_{i,m}\\)</span> 避免边界。</p>\n<p>那么在网格图上转移如下：</p>\n<p><img src=\"2.png\" /></p>\n<p>考虑将这个图形拉正，令 <span class=\"math inline\">\\((i+i,j)\\gets g_{i,j}\\)</span> 得到：</p>\n<p><img src=\"3.png\" /></p>\n<p>问题就转化为，从 <span class=\"math inline\">\\((0, 0)\\)</span> 走到 <span class=\"math inline\">\\((m+n+1,n)\\)</span> 且不能触碰 <span class=\"math inline\">\\(y=x+1\\)</span> 和 <span class=\"math inline\">\\(y=x-m-2\\)</span> 两条直线的方案数。</p>\n<details>\n</details>\n<hr />\n<h2 id=\"不经过一般过原点直线的方案数\">不经过一般过原点直线的方案数</h2>\n<ol type=\"1\">\n<li><p>类型一：<span class=\"math inline\">\\((0,0)\\to (n,m)\\)</span>，不经过 <span class=\"math inline\">\\(y=\\dfrac mnx\\)</span> 的方案，其中要求 <span class=\"math inline\">\\((m,n)=1\\)</span>。</p>\n<p>方案为 <span class=\"math inline\">\\(\\dfrac {C_{n+m}^n}{n+m}\\)</span>。</p></li>\n</ol>\n",
            "tags": [
                "排列组合",
                "容斥原理",
                "数学"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20230716/",
            "url": "https://xsc062.netlify.app/20230716/",
            "title": "解题报告：染色",
            "date_published": "2023-07-16T14:09:39.000Z",
            "content_html": "<p>老题解批量补档。</p>\n<span id=\"more\"></span>\n<hr />\n<p><a href=\"https://www.becoder.com.cn/contest/3887/problem/3\" class=\"uri\">https://www.becoder.com.cn/contest/3887/problem/3</a></p>\n<blockquote>\n<p>有 <span class=\"math inline\">\\(N\\)</span> 个格子排成一排，你需要用至多 <span class=\"math inline\">\\(M\\)</span> 种颜色给这些格子染色，每个格子恰好染成某一种颜色，不需要每种颜色都用上。求有多少种染色方案满足相邻的同色格子不超过 <span class=\"math inline\">\\(K\\)</span> 对。</p>\n</blockquote>\n<p>不妨将一对相邻同色格子称为同色对，将一串连续的相同颜色称作一段，那么最极端的情况下会有 <span class=\"math inline\">\\(N\\)</span> 段（即不存在同色对）。</p>\n<p>构造一段长度为 <span class=\"math inline\">\\(L\\)</span> 的 <span class=\"math inline\">\\(L\\)</span> 段序列（即不存在同色对）。此时将任意一段长度增加 1，则出现一对同色对。接下来，不论是选取长度为 2 的那一段，还是选取剩下的长度为 1 的段，将其长度增加 1，都会且仅会增加 1 对同色对。</p>\n<p>以此类推，进行 <span class=\"math inline\">\\(K\\)</span> 次「选取一段并将其长度增加 1」的操作，可得到刚好 <span class=\"math inline\">\\(K\\)</span> 个同色对，此时序列长度为 <span class=\"math inline\">\\(L + K\\)</span>，而 <strong>段数没有变化</strong>，仍是一开始的 <span class=\"math inline\">\\(L\\)</span>。 所以反过来，如果在长度为 <span class=\"math inline\">\\(N\\)</span> 的序列中存在 <span class=\"math inline\">\\(K\\)</span> 个同色对，那么段数为 <span class=\"math inline\">\\(N-K\\)</span>。<del>很难想象题解用「所以」两个字直接略过了上述推导过程</del></p>\n<p>由此，我们只要考虑分别将序列任意分为非空的 <span class=\"math inline\">\\(N-K\\sim N\\)</span> 段，就可以解决问题，隔板法可得将 <span class=\"math inline\">\\(N\\)</span> 分为 <span class=\"math inline\">\\(T\\)</span> 段的方案数为 <span class=\"math inline\">\\(C_{N-1}^{T-1}\\)</span>。在此基础上考虑染色，由乘法原理，将 <span class=\"math inline\">\\(T\\)</span> 段染色的方案为 <span class=\"math inline\">\\((m - 1)^{T - 1}\\times M\\)</span>。</p>\n<p>取 <span class=\"math inline\">\\(T=N-K\\sim N\\)</span> 并求和问题即解决。</p>\n<details>\n<pre class=\"cpp\"><code>namespace XSC062 &#123;\nusing namespace fastIO;\nconst int maxn = 2e5 + 15;\nconst int mod = 998244353;\nint fac[maxn];\nint n, m, k, res;\ninline int qkp(int x, int y) &#123;\n    int res = 1;\n    while (y) &#123;\n        if (y &amp; 1)\n            (res *= x) %= mod;\n        (x *= x) %= mod;\n        y &gt;&gt;= 1;\n    &#125;\n    return res;\n&#125;\ninline int inv(int x) &#123;\n    return qkp(x, mod - 2);\n&#125;\ninline int A(int n, int m) &#123;\n    return (fac[n] * inv(fac[n - m])) % mod;\n&#125;\ninline int C(int n, int m) &#123;\n    return (A(n, m) * inv(A(m, m))) % mod;\n&#125;\nint main() &#123;\n    read(n), read(m), read(k);\n    fac[0] = 1;\n    for (int i = 1; i &lt;= n + 5; ++i)\n        fac[i] = (fac[i - 1] * i) % mod;\n    for (int i = n - k; i &lt;= n; ++i) &#123;\n        (res += ((C(n - 1, i - 1) *\n                qkp(m - 1, i - 1)) % mod\n                * m) % mod) %= mod;\n    &#125;\n    print(res, &#39;\\n&#39;);\n    return 0;\n&#125;\n&#125; // namespace XSC062\n#undef int</code></pre>\n</details>\n",
            "tags": [
                "排列组合"
            ]
        }
    ]
}