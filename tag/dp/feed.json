{
    "version": "https://jsonfeed.org/version/1",
    "title": "null • All posts by \"dp\" tag",
    "description": "",
    "home_page_url": "https://xsc062.netlify.app",
    "items": [
        {
            "id": "https://xsc062.netlify.app/20250820/",
            "url": "https://xsc062.netlify.app/20250820/",
            "title": "杂题",
            "date_published": "2025-08-20T12:26:44.000Z",
            "content_html": "<p>困难</p>\n<span id=\"more\"></span>\n<hr />\n<h3 id=\"b.-beauty拆贡献\">B. beauty（拆贡献）</h3>\n<p><a href=\"http://222.180.160.110:61235/contest/6513/problem/2\" class=\"uri\">http://222.180.160.110:61235/contest/6513/problem/2</a></p>\n<blockquote>\n<p>给定 <span class=\"math inline\">\\(n,V\\)</span>，求出对于所有长度为 <span class=\"math inline\">\\(n\\)</span>，值域为 <span class=\"math inline\">\\([1,V]\\)</span> 的序列 <span class=\"math inline\">\\(a_{1\\sim n}\\)</span>，<span class=\"math inline\">\\(\\sum_{i=1}^n |a_i-a_{n-i+1}|\\)</span> 的和。</p>\n<p><span class=\"math inline\">\\(n,V\\le 5000\\)</span>。</p>\n</blockquote>\n<ul>\n<li>容易想到算贡献，会有一个 <span class=\"math inline\">\\(O(n^2V)\\)</span> 的做法。但是想 <span class=\"math inline\">\\(O(nV)\\)</span> 做是很抽象的，和 <span class=\"math inline\">\\(O(n^2V)\\)</span> 的思路已经很不一样了</li>\n<li>经典 trick，<span class=\"math inline\">\\(a_{i+n/2}-a_i=\\sum\\limits_{x=0}^{+\\infty} [a_i\\le x&lt;a_{i+n/2}]\\)</span> 拆贡献 。故要算 <span class=\"math inline\">\\(a_{i}-a_{i+n/2}\\)</span>，只需要对于每个 <span class=\"math inline\">\\(x\\in[a_i,a_{i+n/2})\\)</span> 计算贡献。</li>\n<li>枚举 <span class=\"math inline\">\\(x\\in [1,V)\\)</span>，再枚举最大的 <span class=\"math inline\">\\(t\\)</span>，满足 <span class=\"math inline\">\\(a_t\\ge x\\)</span>。那么有 <span class=\"math inline\">\\(t\\)</span> 个 <span class=\"math inline\">\\(a_i\\le x\\)</span>，同时有 <span class=\"math inline\">\\(n-t\\)</span> 个 <span class=\"math inline\">\\(a_i&gt;x\\)</span>；满足 <span class=\"math inline\">\\(i\\le n/2\\)</span> 的 <span class=\"math inline\">\\(a_{i},a_{i+n/2}\\)</span> 对数应该是 <span class=\"math inline\">\\(\\min(t,n-t)\\)</span>。故对于一个确定的序列，<span class=\"math inline\">\\(x\\)</span> 共有 <span class=\"math inline\">\\(\\min(t,n-t)\\)</span> 的贡献。</li>\n<li>考虑计数满足 <span class=\"math inline\">\\(a_t\\le x\\)</span> 的 <span class=\"math inline\">\\(a\\)</span>，这要求第 <span class=\"math inline\">\\(t\\)</span> 大的数 <span class=\"math inline\">\\(\\le x\\)</span> 而第 <span class=\"math inline\">\\(t+1\\)</span> 大的数 <span class=\"math inline\">\\(&gt;x\\)</span>，也即在 <span class=\"math inline\">\\([1,x]\\)</span> 里找 <span class=\"math inline\">\\(t\\)</span> 个数再在 <span class=\"math inline\">\\((x,V]\\)</span> 里找 <span class=\"math inline\">\\(n-t\\)</span> 个数，注意还要再乘上这两种数拼起来的方案数。</li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 998244353;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n    std::freopen(&quot;beauty.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;beauty.out&quot;, &quot;w&quot;, stdout);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int T;\n    std::vector&lt;long long&gt; fac(5001), inv(5001);\n    std::vector&lt;std::vector&lt;long long&gt; &gt; pw(5001, std::vector&lt;long long&gt; (5001));\n    fac[0] = inv[0] = 1ll;\n    for (int i = 1; i &lt;= 5000; ++i) &#123;\n        fac[i] = fac[i - 1] * i % mod;\n        pw[i][0] = 1ll;\n        for (int j = 1; j &lt;= 5000; ++j)\n            pw[i][j] = pw[i][j - 1] * i % mod;\n    &#125;\n    auto qkp = [](long long x, int y) &#123;\n        auto res(1ll);\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    inv[5000] = qkp(fac[5000], mod - 2);\n    for (int i = 4999; i; --i)\n        inv[i] = inv[i + 1] * (i + 1) % mod;\n    auto C = [&amp;](int n, int m) &#123;\n        return fac[n] * inv[m] % mod * inv[n - m] % mod;\n    &#125;;\n    for (std::cin &gt;&gt; T; T--; ) &#123;\n        int n, V;\n        std::cin &gt;&gt; n &gt;&gt; V;\n        auto res(0ll);\n        for (int x = 1; x &lt; V; ++x)\n            for (int t = 1; t &lt; n; ++t) &#123;\n                int k = std::min(t, n - t);\n                (res += k * pw[x][t] % mod * pw[V - x][n - t] % mod * C(n, t) % mod) %= mod;\n            &#125;\n        std::cout &lt;&lt; res * 2 % mod &lt;&lt; &#39;\\n&#39;;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"c.-drink-bar容斥-偏序\">C. Drink Bar（容斥 + 偏序）</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/AT_snuke21_j\" class=\"uri\">https://www.luogu.com.cn/problem/AT_snuke21_j</a></p>\n<ul>\n<li>三个属性都是排列，可以推理出只要两个三元组中，作出贡献的元素不完全相同，两个三元组就不同。讨论作出贡献的元素数量。</li>\n<li>只有一个元素作出贡献，答案为 <span class=\"math inline\">\\(n\\)</span>。</li>\n<li>有两个元素作出贡献，任选的话答案为 <span class=\"math inline\">\\(C_n^2\\)</span>，要减去一个元素严格优于另一个元素的情况，三维偏序即可。</li>\n<li><p>有三个元素作出贡献，是个有点复杂的容斥，不妨设三元组为 <span class=\"math inline\">\\((i,j,k)\\)</span>，其中贡献次数最多的为 <span class=\"math inline\">\\(i\\)</span></p>\n<ol type=\"1\">\n<li><span class=\"math inline\">\\(i\\)</span> 贡献了 <span class=\"math inline\">\\(\\ge 1\\)</span> 次，方案数为 <span class=\"math inline\">\\(C_n^3\\)</span></li>\n<li><span class=\"math inline\">\\(i\\)</span> 贡献了 <span class=\"math inline\">\\(\\ge 2\\)</span> 次，枚举作出两次贡献的属性，以 <span class=\"math inline\">\\(a,b\\)</span> 为例，那么有 <span class=\"math inline\">\\(a_j,a_k&lt;a_i\\)</span>，以及 <span class=\"math inline\">\\(b_j,b_k&lt;b_i\\)</span>，二维偏序即可</li>\n<li><span class=\"math inline\">\\(i\\)</span> 贡献了 <span class=\"math inline\">\\(\\ge 3\\)</span> 次，依然是三维偏序，可以用『两个元素做出贡献』中 cdq 得到的值算出答案。记得乘 2，因为被多减了 2 次。</li>\n</ol></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    struct node &#123; int a, b, c, res; &#125;;\n    std::vector&lt;node&gt; a(n + 1);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; a[i].a &gt;&gt; a[i].b &gt;&gt; a[i].c;\n        a[i].res = 0;\n    &#125;\n    long long res = n;\n    res += (long long)n * (n - 1) / 2;\n    std::vector&lt;int&gt; bit(n + 1);\n    auto lowbit = [](int x) &#123;\n        return x &amp; -x;\n    &#125;;\n    auto add = [&amp;](int x, int v) &#123;\n        for (; x &lt;= n; x += lowbit(x))\n            bit[x] += v;\n        return;\n    &#125;;\n    auto ask = [&amp;](int x) &#123;\n        int res = 0;\n        for (; x; x -= lowbit(x))\n            res += bit[x];\n        return res;\n    &#125;;\n    std::function&lt;void(int, int)&gt; calc = [&amp;](int l, int r) &#123;\n        if (l == r)\n            return;\n        int mid = (l + r) &gt;&gt; 1;\n        calc(l, mid), calc(mid + 1, r);\n        int j = l;\n        for (int i = mid + 1; i &lt;= r; ++i) &#123;\n            for (; j &lt;= mid &amp;&amp; a[j].b &lt; a[i].b; ++j)\n                add(a[j].c, 1);\n            a[i].res += ask(a[i].c);\n        &#125;\n        for (int i = l; i &lt; j; ++i)\n            add(a[i].c, -1);\n        std::inplace_merge(a.begin() + l, a.begin() + mid + 1, a.begin() + r + 1, [&amp;](node x, node y) &#123; return x.b &lt; y.b; &#125;);\n        return;\n    &#125;;\n    std::sort(a.begin() + 1, a.end(), [&amp;](node x, node y) &#123; return x.a &lt; y.a; &#125;);\n    calc(1, n);\n    for (int i = 1; i &lt;= n; ++i)\n        res -= a[i].res;\n    res += (long long)n * (n - 1) * (n - 2) / 6;\n    for (int k = 0; k &lt; 3; ++k) &#123;\n        std::sort(a.begin() + 1, a.end(), [&amp;](node x, node y) &#123; return x.a &lt; y.a; &#125;);\n        std::fill(bit.begin() + 1, bit.end(), 0);\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            int t = ask(a[i].b);\n            res -= (long long)t * (t - 1) / 2;\n            add(a[i].b, 1);\n            std::tie(a[i].a, a[i].b, a[i].c) = std::make_tuple(a[i].b, a[i].c, a[i].a);\n        &#125;\n    &#125;\n    for (int i = 1; i &lt;= n; ++i)\n        res += (long long)a[i].res * (a[i].res - 1);\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"c.-星白-by-ttpandas笛卡尔树-dsu-on-tree\">C. 星白 by TTpandaS（笛卡尔树 + dsu on tree）</h3>\n<p><a href=\"/20250819/#星白-by-ttpandas笛卡尔树-dsu-on-tree\">link</a></p>\n<hr />\n<h3 id=\"c.-isn\">C. isn</h3>\n<p><a href=\"https://hydro.ac/p/bzoj-P4361\" class=\"uri\">https://hydro.ac/p/bzoj-P4361</a></p>\n<ul>\n<li><p>最后一个删去的一定是连接 <code>&gt;</code> 的数，可以 DP 还剩一个数没删时可能的序列。</p>\n令 <span class=\"math inline\">\\(f_{i,j,0/1}\\)</span> 表示最后一个元素为 <span class=\"math inline\">\\(i\\)</span>，序列长为 <span class=\"math inline\">\\(j\\)</span>，最后一个被删去的数（未）被确定的方案数。<strong>注意确定最后一个被删去的数要在转移过程中进行，而不是作为一个 DP 节点</strong>，很容易发现后者是错的。</li>\n<li><p>优化的思路就不一样了。因为要乘上 <span class=\"math inline\">\\((n-j)!\\)</span>，所以 <span class=\"math inline\">\\(j\\)</span> 的这一维是省不掉的</p>\n考虑不管最后一个被删掉的数，直接令 <span class=\"math inline\">\\(f_{i,j}\\)</span> 表示最后一个元素为 <span class=\"math inline\">\\(i\\)</span>，序列长为 <span class=\"math inline\">\\(j\\)</span> 的方案数。有 <span class=\"math inline\">\\(f_{i,j}=\\sum\\limits_{a_k\\le a_i}f_{k,j - 1}\\)</span>，可以 DS 优化。但这样会产生不合法的情况。</li>\n<li><p>考察什么样的序列合法，发现<strong>删去的最后一个数一定是非法的，也就是包含之的序列都是非法的；反之易得被合法序列包含的序列都非法</strong></p>\n<p>明白了这一点过后就会知道长度为 <span class=\"math inline\">\\(j\\)</span> 的合法序列系数都为 <span class=\"math inline\">\\((n-j)!\\)</span></p>\n<p>故容斥，令 <span class=\"math inline\">\\(g_i\\)</span> 表示序列长为 <span class=\"math inline\">\\(i\\)</span> 的方案数，<span class=\"math inline\">\\(h_i\\)</span> 表示序列长为 <span class=\"math inline\">\\(i\\)</span> 的合法方案数。从异或角度考虑，易得 <span class=\"math inline\">\\(h_i=g_i-\\sum\\limits_{j=i+1}h_j\\times (j-i)!\\times C_j^i\\)</span>。</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 1e9 + 7;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n    std::freopen(&quot;isn.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;isn.out&quot;, &quot;w&quot;, stdout);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;int&gt; a(n + 1), l(1);\n    std::vector&lt;long long&gt; fac(n + 1), inv(n + 1);\n    fac[0] = inv[0] = 1ll;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; a[i], l.push_back(a[i]);\n        fac[i] = fac[i - 1] * i % mod;\n    &#125;\n    auto qkp = [](long long x, int y) &#123;\n        auto res(1ll);\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    inv[n] = qkp(fac[n], mod - 2);\n    for (int i = n - 1; i; --i)\n        inv[i] = inv[i + 1] * (i + 1) % mod;\n    auto C = [&amp;](int n, int m) &#123;\n        return fac[n] * inv[m] % mod * inv[n - m] % mod;\n    &#125;;\n    std::sort(l.begin(), l.end());\n    l.erase(std::unique(l.begin(), l.end()), l.end());\n    for (int i = 0; i &lt;= n; ++i)\n        a[i] = std::lower_bound(l.begin(), l.end(), a[i]) - l.begin() + 1;\n    int m = (int)l.size();\n    std::vector&lt;std::vector&lt;long long&gt; &gt; bit(n + 1, std::vector&lt;long long&gt; (m + 1));\n    auto lowbit = [](int x) &#123;\n        return x &amp; -x;\n    &#125;;\n    auto add = [&amp;](int id, int x, long long v) &#123;\n        for (; x &lt;= m; x += lowbit(x))\n            (bit[id][x] += v) %= mod;\n        return;\n    &#125;;\n    auto ask = [&amp;](int id, int x) &#123;\n        auto res(0ll);\n        for (; x; x -= lowbit(x))\n            (res += bit[id][x]) %= mod;\n        return res;\n    &#125;;\n    std::vector&lt;long long&gt; g(n + 1), h(n + 1);\n    std::vector&lt;std::vector&lt;long long&gt; &gt; f(n + 1, std::vector&lt;long long&gt; (n + 1));\n    add(0, a[0], 1ll), f[0][0] = 1ll;\n    for (int i = 1; i &lt;= n; ++i)\n        for (int j = n; j; --j) &#123;\n            f[i][j] = ask(j - 1, a[i]);\n            add(j, a[i], f[i][j]);\n            (g[j] += f[i][j] * fac[n - j]) %= mod;\n        &#125;\n    auto res(0ll);\n    for (int i = n; i; --i) &#123;\n        h[i] = g[i];\n        for (int j = i + 1; j &lt;= n; ++j)\n            (h[i] += mod - h[j] * fac[j - i] % mod * C(j, i) % mod) %= mod;\n        (res += h[i]) %= mod;\n    &#125;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"d.-thepowers\">D. ThePowers</h3>\n<p>TopCoder - 12185，原题交不了故不放链接了</p>\n<p><a href=\"http://222.180.160.110:61235/contest/6522/problem/4\" class=\"uri\">http://222.180.160.110:61235/contest/6522/problem/4</a></p>\n<blockquote>\n<p>给定 <span class=\"math inline\">\\(A,B\\)</span>，对于所有 <span class=\"math inline\">\\(X\\le A,Y\\le B\\)</span>，求 <span class=\"math inline\">\\(X^Y\\)</span> 的可能取值数量。<span class=\"math inline\">\\(A,B\\le10^9\\)</span>。</p>\n</blockquote>\n<ul>\n<li>考虑什么时候算重。发现当且仅当 <span class=\"math inline\">\\(x^a=y^b\\)</span>，此时记 <span class=\"math inline\">\\(a&#39;=a\\div\\gcd(a,b),b&#39;=b\\div \\gcd(a,b)\\)</span>，那么 <span class=\"math inline\">\\(t=\\sqrt[a&#39;]x=\\sqrt[b&#39;]y\\)</span> 为整（写成质因数乘积是易证的），则 <span class=\"math inline\">\\(x=t^b,y=t^a\\)</span>，是同一个数的不同次幂</li>\n<li><p>故把 <span class=\"math inline\">\\(A\\)</span> 内所有数分组，记 <span class=\"math inline\">\\(S_x\\)</span> 表示所有 <span class=\"math inline\">\\(x\\)</span> 的次幂，其中 <span class=\"math inline\">\\(x\\)</span> 不是其他数的次幂</p>\n发现一个对于 <span class=\"math inline\">\\(&gt;\\sqrt A\\)</span> 的数 <span class=\"math inline\">\\(y\\)</span>，只有可能属于 <span class=\"math inline\">\\(S_y\\)</span>，或一个 <span class=\"math inline\">\\(x\\le \\sqrt A\\)</span> 的 <span class=\"math inline\">\\(S_x\\)</span>。每组最多有 <span class=\"math inline\">\\(30\\)</span> 个，故扫一遍 <span class=\"math inline\">\\(\\le\\sqrt A\\)</span> 的数即可完成分组。</li>\n<li><p>这样就只用考虑同组内的计数。即对于 <span class=\"math inline\">\\(x\\)</span> 和 <span class=\"math inline\">\\(p\\le |S_x|,y\\le B\\)</span>，<span class=\"math inline\">\\(x^{py}\\)</span> 有多少种取值，也即 <span class=\"math inline\">\\(py\\)</span> 有多少种取值</p>\n发现因为值域是连续的，对于一个 <span class=\"math inline\">\\(p\\)</span>，只要 <span class=\"math inline\">\\(pB\\)</span> 范围内某个数是 <span class=\"math inline\">\\(p\\)</span> 的倍数就可以取到，枚举 <span class=\"math inline\">\\([(p-1)B+1,pB]\\)</span>，对于每个 <span class=\"math inline\">\\(p\\)</span> 容斥，就需要计算 <span class=\"math inline\">\\(p\\sim |S_x|\\)</span> 的每个子集，复杂度会爆炸。</li>\n<li><p>对于 <span class=\"math inline\">\\(x,y\\in[p,|S_x|]\\)</span>，如果 <span class=\"math inline\">\\(y\\)</span> 是 <span class=\"math inline\">\\(x\\)</span> 的倍数，就可以 skip，只在剩下的元素里枚举子集，可以代码验证一下 <span class=\"math inline\">\\(30\\)</span> 以内最多剩下 <span class=\"math inline\">\\(15\\)</span> 个数，可以接受，注意子集信息类似高维前缀和地 <span class=\"math inline\">\\(O(1)\\)</span> 求就行了</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n    std::freopen(&quot;power.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;power.out&quot;, &quot;w&quot;, stdout);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    long long A, B, mx = 1ll;\n    std::cin &gt;&gt; A &gt;&gt; B;\n    if (A == 1) &#123;\n        std::cout &lt;&lt; 1 &lt;&lt; &#39;\\n&#39;;\n        return 0;\n    &#125;\n    int cnt = 1;\n    long long res = 1ll;\n    for (; (mx + 1) * (mx + 1) &lt;= A; ++mx);\n    std::vector&lt;int&gt; tag(mx + 1);\n    for (int i = 2; i &lt;= mx; ++i)\n        if (!tag[i]) &#123;\n            int siz = 1;\n            for (long long j = i; j &lt;= A; j *= i, ++siz)\n                if (j &lt;= mx)\n                    tag[j] = 1;\n            cnt += --siz;\n            for (int j = 1; j &lt;= siz; ++j) &#123;\n                std::vector&lt;int&gt; p(&#123; j &#125;);\n                for (int k = j + 1; k &lt;= siz; ++k) &#123;\n                    bool flag = 1;\n                    for (auto l : p)\n                        if (k % l == 0) &#123;\n                            flag = 0;\n                            break;\n                        &#125;\n                    if (flag)\n                        p.push_back(k);\n                &#125;\n                int m = (int)p.size(), s = 1 &lt;&lt; m;\n                std::vector&lt;long long&gt; mul(s);\n                mul[0] = 1ll;\n                auto lcm = [&amp;](long long x, long long y) &#123;\n                    return x / std::__gcd(x, y) * y;\n                &#125;;\n                for (int k = 1; k &lt; s; ++k) &#123;\n                    mul[k] = lcm(p[std::__lg(k ^ ((k - 1) &amp; k))], mul[(k - 1) &amp; k]);\n                    if (__builtin_popcount(k) &amp; 1)\n                        res += j * B / mul[k] - (j - 1) * B / mul[k];\n                    else\n                        res -= j * B / mul[k] - (j - 1) * B / mul[k];\n                &#125;\n            &#125;\n        &#125;\n    res += (A - cnt) * B;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<p>搜索做法本质上是一样的，就不赘述了</p>\n",
            "tags": [
                "DP",
                "容斥"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20250807/",
            "url": "https://xsc062.netlify.app/20250807/",
            "title": "学习笔记：分拆数与 Ferrers 图",
            "date_published": "2025-08-07T08:20:45.000Z",
            "content_html": "<p>需要知道概念和求法，有一定的用处</p>\n<span id=\"more\"></span>\n<hr />\n<h2 id=\"分拆数与互异分拆数\">分拆数与互异分拆数</h2>\n<p>要求：给定一个正整数 <span class=\"math inline\">\\(n\\)</span>，要求将其划分为 <span class=\"math inline\">\\(m\\)</span> 个可重 / 不可重的正整数，问本质不同的方案数。（显然 <span class=\"math inline\">\\(m\\)</span> 与 <span class=\"math inline\">\\(\\sqrt n\\)</span> 同阶。）</p>\n<p>不妨令划分结果单调不降，则有两种 DP 路径：</p>\n<ul>\n<li><p>法一：令 <span class=\"math inline\">\\(f_{i,j}\\)</span> 表示把 <span class=\"math inline\">\\(i\\)</span> 分成 <span class=\"math inline\">\\(j\\)</span> 个正整数的方案数。</p>\n<ul>\n<li>不可重：考虑将这 <span class=\"math inline\">\\(j\\)</span> 个数减去 <span class=\"math inline\">\\(1\\)</span>。最多一个元素由 <span class=\"math inline\">\\(1\\)</span> 变为 <span class=\"math inline\">\\(0\\)</span>，组数减少 <span class=\"math inline\">\\(1\\)</span>；其他时候还是 <span class=\"math inline\">\\(j\\)</span> 组。故云 <span class=\"math inline\">\\(f_{i,j}=f_{i-j,j-1}+f_{i-j,j}\\)</span>。</li>\n<li>可重：如果存在 <span class=\"math inline\">\\(1\\)</span>，可以删除之然后转移；否则仍整体减 <span class=\"math inline\">\\(1\\)</span> 转移。故曰 <span class=\"math inline\">\\(f_{i,j}=f_{i-1,j-1}+f_{i-j,j}\\)</span>。</li>\n</ul>\n该转移方法唯一性很显然。<strong>注意到第二维只和 <span class=\"math inline\">\\(j,j-1\\)</span> 有关；可以交换前后两维顺序然后滚动。</strong></li>\n<li><p>法二：令 <span class=\"math inline\">\\(n=\\sum a_i\\)</span>，建立 <span class=\"math inline\">\\(a\\)</span> 的差分数组 <span class=\"math inline\">\\(d\\)</span>，则有 <span class=\"math inline\">\\(n=\\sum\\limits_{i=1}^m \\sum\\limits_{j=1}^i c_j=\\sum\\limits_{i=1}^m (n-i+1)\\times a_i\\)</span>。发现 <span class=\"math inline\">\\(a_i\\)</span> 每增大 <span class=\"math inline\">\\(1\\)</span>，答案会增大 <span class=\"math inline\">\\(n-i+1\\)</span>。故转化为『第 <span class=\"math inline\">\\(i\\)</span> 个物品重量为 <span class=\"math inline\">\\(n-i+1\\)</span>』的完全背包。</p>\n<ul>\n<li>不可重：要求每个物品至少选一次。</li>\n<li>可重：无限制。</li>\n</ul>\n<p>该方法唯一性更显然。</p></li>\n</ul>\n<p>复杂度均为 <span class=\"math inline\">\\(O(nm)\\)</span>，即 <span class=\"math inline\">\\(O(V\\sqrt V)\\)</span>。</p>\n<h3 id=\"例sets-of-complementary-sums\">例：Sets of Complementary Sums</h3>\n<p><a href=\"/20250723/#e.-sets-of-complementary-sums\">link</a></p>\n<h2 id=\"ferrers-图\">Ferrers 图</h2>\n<p>将 <span class=\"math inline\">\\(k\\)</span> 个分拆出来的数用横向柱状图表示并单调不增排列，得到 Ferrers 图。</p>\n<figure>\n<img src=\"image-1.png\" alt=\"例：12=5+4+2+1 的 Ferrers 图（图源 OI Wiki）\" /><figcaption>例：<span class=\"math inline\">\\(12=5+4+2+1\\)</span> 的 Ferrers 图（图源 OI Wiki）</figcaption>\n</figure>\n<p>将图像斜向翻折得到一组共轭解，原图中的 <span class=\"math inline\">\\(k\\)</span> 即为共轭解中的元素最值。故亦可限定分拆结果的最值为 <span class=\"math inline\">\\(k\\)</span>，则结果仍为 <span class=\"math inline\">\\(f_{n,k}\\)</span>。同时适用于分拆数与互异分拆数。</p>\n<p>顺带提一嘴杨表：把点替换成 <span class=\"math inline\">\\(1\\sim n\\)</span>，并使得一个点同时大于左侧和上方的值。</p>\n<p>似乎就不是很有用了。计数题可能会考。</p>\n",
            "tags": [
                "DP"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20250805/",
            "url": "https://xsc062.netlify.app/20250805/",
            "title": "状压 DP",
            "date_published": "2025-08-05T06:33:55.000Z",
            "content_html": "<p>没补完（1/3），动作还是太慢了</p>\n<span id=\"more\"></span>\n<hr />\n<h2 id=\"a---只不过是长的领带-2-just-long-neckties-2\">A - 只不过是长的领带 2 / Just Long Neckties 2</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P11665\" class=\"uri\">https://www.luogu.com.cn/problem/P11665</a></p>\n<p>需要观察到，任意时刻 <span class=\"math inline\">\\(B\\)</span> 中不存在重复元素。把 <span class=\"math inline\">\\(B\\)</span> 压出来，令 <span class=\"math inline\">\\(f_{i,S}\\)</span> 表示选了 <span class=\"math inline\">\\(i\\)</span>，当前 <span class=\"math inline\">\\(B\\)</span> 为 <span class=\"math inline\">\\(S\\)</span> 是否可行，能够 <span class=\"math inline\">\\(O(n\\cdot 2^V)\\)</span>。对于某个 <span class=\"math inline\">\\(S\\)</span>，只关心它最远能到达哪个 <span class=\"math inline\">\\(i\\)</span>，故令 <span class=\"math inline\">\\(f_S\\)</span> 记录之。对于每一个 <span class=\"math inline\">\\(S\\)</span>，都可以找到 <span class=\"math inline\">\\(f_S\\)</span> 后第一对 <span class=\"math inline\">\\(a_i,a_{i+1}\\notin S\\)</span>，用其刷表。</p>\n<p>发现『找 <span class=\"math inline\">\\(f_S\\)</span> 后第一对非法元素』是很慢的，考虑优化；对于每个 <span class=\"math inline\">\\(i\\)</span> 维护 <span class=\"math inline\">\\(p\\)</span> 在其后第一次出现的位置 <span class=\"math inline\">\\(x\\)</span>，对于每个 <span class=\"math inline\">\\(a_x=p\\)</span> 维护 <span class=\"math inline\">\\(x\\)</span> 后方 <span class=\"math inline\">\\(a_y=p,a_{y+1}=q\\)</span> 第一次出现的位置，相当于<strong>先找 <span class=\"math inline\">\\(p\\)</span> 再找 <span class=\"math inline\">\\((p,q)\\)</span></strong>，就可以做到 <span class=\"math inline\">\\(O(V^2\\cdot 2^V+n\\cdot V)\\)</span>。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;int&gt; a(n + 1);\n    int V = 0;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; a[i];\n        V = std::max(V, a[i]--);\n    &#125;\n    std::vector&lt;std::vector&lt;int&gt; &gt; tx(n + 1, std::vector&lt;int&gt; (V)), ty(n + 1, std::vector&lt;int&gt; (V));\n    std::vector&lt;int&gt; lp(V);\n    std::vector&lt;std::vector&lt;int&gt; &gt; lpq(V, std::vector&lt;int&gt; (V));\n    for (int i = n; ~i; --i) &#123;\n        if (i &amp;&amp; i != n)\n            lpq[a[i]][a[i + 1]] = i;\n        for (int j = 0; j &lt; V; ++j) &#123;\n            tx[i][j] = lp[j];\n            if (i != n)\n                ty[i][j] = lpq[a[i]][j];\n        &#125;\n        if (i != 0)\n            lp[a[i]] = i;\n    &#125;\n    int siz = 1 &lt;&lt; V, res = 21;\n    std::vector&lt;int&gt; f(siz);\n    for (int i = 0; i &lt; siz; ++i) &#123;\n        std::vector&lt;int&gt; p0, p1;\n        for (int j = 0; j &lt; V; ++j)\n            if ((i &gt;&gt; j) &amp; 1)\n                p1.push_back(j);\n            else\n                p0.push_back(j);\n        int j = n;\n        for (auto p : p0)\n            if (tx[f[i]][p])\n                for (auto q : p0)\n                    if (ty[tx[f[i]][p]][q])\n                        j = std::min(j, ty[tx[f[i]][p]][q]);\n        if (j != n) &#123;\n            f[i ^ (1 &lt;&lt; a[j])] = std::max(f[i ^ (1 &lt;&lt; a[j])], j);\n            f[i ^ (1 &lt;&lt; a[j + 1])] = std::max(f[i ^ (1 &lt;&lt; a[j + 1])], j + 1);\n            for (auto k : p1) &#123;\n                f[i ^ (1 &lt;&lt; k) ^ (1 &lt;&lt; a[j])] = std::max(f[i ^ (1 &lt;&lt; k) ^ (1 &lt;&lt; a[j])], j);\n                f[i ^ (1 &lt;&lt; k) ^ (1 &lt;&lt; a[j + 1])] = std::max(f[i ^ (1 &lt;&lt; k) ^ (1 &lt;&lt; a[j + 1])], j + 1);\n            &#125;\n        &#125;\n        else\n            res = std::min(res, __builtin_popcount(i));\n    &#125;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"b---cut-and-reorder\">B - Cut and Reorder</h2>\n<p><a href=\"https://atcoder.jp/contests/abc328/tasks/abc328_g\" class=\"uri\">https://atcoder.jp/contests/abc328/tasks/abc328_g</a></p>\n<p>不妨先重排再修改，令 <span class=\"math inline\">\\(f_{i,S}\\)</span> 表示已经重排好新序列的前 <span class=\"math inline\">\\(i\\)</span> 个元素，对应原序列状态 <span class=\"math inline\">\\(S\\)</span> 的最小代价。枚举新区间容易转移。可以发现枚举 <span class=\"math inline\">\\(i,S\\)</span> 的实际复杂度为 <span class=\"math inline\">\\(O(2^n)\\)</span>（空间也可以这么优化），预处理之后总时间复杂度 <span class=\"math inline\">\\(O(n^2\\cdot 2^n)\\)</span>，跑不满，可以通过。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst long long inf = 1e18;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    long long c;\n    std::cin &gt;&gt; n &gt;&gt; c;\n    std::vector&lt;long long&gt; a(n), b(n);\n    for (int i = 0; i &lt; n; ++i)\n        std::cin &gt;&gt; a[i];\n    for (int i = 0; i &lt; n; ++i)\n        std::cin &gt;&gt; b[i];\n    using arr = std::vector&lt;long long&gt;;\n    using brr = std::vector&lt;arr&gt;;\n    using crr = std::vector&lt;brr&gt;;\n    brr p(n, arr(n));\n    crr g(n, brr(n, arr(n)));\n    for (int l = 0; l &lt; n; ++l)\n        for (int r = l; r &lt; n; ++r) &#123;\n            for (int k = l; k &lt;= r; ++k)\n                p[l][r] ^= (1 &lt;&lt; k);\n            for (int R = r - l; R &lt; n; ++R)\n                for (int L = R, j = r; j &gt;= l; --L, --j)\n                    g[l][r][R] += std::abs(b[L] - a[j]);\n        &#125;\n    int siz = 1 &lt;&lt; n;\n    std::vector&lt;long long&gt; f(siz, inf);\n    f[0] = 0ll;\n    for (int j = 1; j &lt; siz; ++j) &#123;\n        int i = __builtin_popcount(j) - 1;\n        for (int r = 0; r &lt; n; ++r)\n            for (int l = r; ~l &amp;&amp; ((j &gt;&gt; l) &amp; 1); --l)\n                f[j] = std::min(f[j], f[j ^ p[l][r]] + g[l][r][i] + c);\n    &#125;\n    std::cout &lt;&lt; f[siz - 1] - c &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"c---electric-circuit\">C - Electric Circuit</h2>\n<p><a href=\"https://atcoder.jp/contests/abc321/tasks/abc321_g\" class=\"uri\">https://atcoder.jp/contests/abc321/tasks/abc321_g</a></p>\n<p>很像<a href=\"/20250430/#有标号无向图计数\">无向图容斥</a>？令 <span class=\"math inline\">\\(f_S\\)</span> 表示让 <span class=\"math inline\">\\(S\\)</span> 内部完成配对，可以不连通的方案数，那么当且仅当 <span class=\"math inline\">\\(S\\)</span> 内部点出、入度之和相等（记为 <span class=\"math inline\">\\(cnt\\)</span>）时，<span class=\"math inline\">\\(f_S\\)</span> 有值 <span class=\"math inline\">\\(cnt!\\)</span>。相似地，设 <span class=\"math inline\">\\(g_S\\)</span> 表示让 <span class=\"math inline\">\\(S\\)</span> 完成配对，成为一个连通块的方案数，得到 <span class=\"math inline\">\\(g_S=f_S-\\sum\\limits_{v\\in S} f_{S\\oplus v}\\cdot g_v\\)</span>。让 <span class=\"math inline\">\\(v\\)</span> 必须包含 <span class=\"math inline\">\\(S\\)</span> 中编号最小的点就可以去重。</p>\n<p>从贡献的角度出发，<span class=\"math inline\">\\(S\\)</span> 带来的贡献就是 <span class=\"math inline\">\\(g_S\\cdot f_{U\\oplus S}\\)</span>，其中 <span class=\"math inline\">\\(U\\)</span> 是全集。最后除以 <span class=\"math inline\">\\(M!\\)</span> 求出期望。</p>\n<p>复杂度 <span class=\"math inline\">\\(O(3^n)\\)</span>。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 998244353;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, m;\n    std::cin &gt;&gt; n &gt;&gt; m;\n    std::vector&lt;int&gt; ci(n), co(n);\n    for (int i = 1, x; i &lt;= m; ++i)\n        std::cin &gt;&gt; x, ++ci[x - 1];\n    for (int i = 1, x; i &lt;= m; ++i)\n        std::cin &gt;&gt; x, ++co[x - 1];\n    std::vector&lt;long long&gt; fac(m + 1);\n    fac[0] = 1ll;\n    for (int i = 1; i &lt;= m; ++i)\n        fac[i] = fac[i - 1] * i % mod;\n    auto qkp = [&amp;](long long x, int y) &#123;\n        auto res(1ll);\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    int siz = 1 &lt;&lt; n;\n    std::vector&lt;long long&gt; f(siz), g(siz);\n    for (int i = 1; i &lt; siz; ++i) &#123;\n        int si = 0, so = 0;\n        for (int j = 0; j &lt; n; ++j)\n            if ((i &gt;&gt; j) &amp; 1)\n                si += ci[j], so += co[j];\n        if (si == so)\n            f[i] = fac[si];\n    &#125;\n    auto res(0ll);\n    for (int i = 1; i &lt; siz; ++i) &#123;\n        g[i] = f[i];\n        int mn = 0;\n        for (int j = 0; j &lt; n; ++j)\n            if ((i &gt;&gt; j) &amp; 1) &#123;\n                mn = j;\n                break;\n            &#125;\n        int s = i ^ (1 &lt;&lt; mn);\n        (g[i] += mod - g[1 &lt;&lt; mn] * f[s] % mod) %= mod;\n        for (int j = (s - 1) &amp; s; j; j = (j - 1) &amp; s)\n            (g[i] += mod - g[j ^ (1 &lt;&lt; mn)] * f[s ^ j] % mod) %= mod;\n        if (i != siz - 1)\n            (res += g[i] * f[(siz - 1) ^ i]) %= mod;\n        else\n            (res += g[i]) %= mod;\n    &#125;\n    std::cout &lt;&lt; res * qkp(fac[m], mod - 2) % mod &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"d---count-grid-3-coloring\">D - Count Grid 3-coloring</h2>\n<p><a href=\"https://atcoder.jp/contests/abc379/tasks/abc379_g\" class=\"uri\">https://atcoder.jp/contests/abc379/tasks/abc379_g</a></p>\n<p>轮廓线 DP。把每一列已经确定的最靠下的元素压起来，每行逐个确定即可。</p>\n<p>发现有效状态中只能容许最多一对相邻相同元素，这样复杂度就能降下来了。注意特判 <span class=\"math inline\">\\(1\\times 1\\)</span> 的情况。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 998244353;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, m;\n    std::cin &gt;&gt; n &gt;&gt; m;\n    std::array&lt;int, 15&gt; p;\n    p[0] = 1;\n    for (int i = 1; i &lt; 15; ++i)\n        p[i] = p[i - 1] * 3;\n    std::vector&lt;std::vector&lt;int&gt; &gt; a;\n    if (n &gt;= m) &#123;\n        a.assign(n + 1, std::vector&lt;int&gt; (m + 1));\n        for (int i = 1; i &lt;= n; ++i) \n            for (int j = 1; j &lt;= m; ++j) &#123;\n                char t;\n                std::cin &gt;&gt; t, a[i][j] = (t == &#39;?&#39; ? -1 : t - &#39;1&#39;);\n            &#125;\n    &#125;\n    else &#123;\n        std::swap(n, m);\n        a.assign(n + 1, std::vector&lt;int&gt; (m + 1));\n        for (int i = 1; i &lt;= m; ++i)\n            for (int j = 1; j &lt;= n; ++j) &#123;\n                char t;\n                std::cin &gt;&gt; t, a[j][i] = (t == &#39;?&#39; ? -1 : t - &#39;1&#39;);\n            &#125;\n    &#125;\n    int siz = p[m];\n    using arr = std::vector&lt;long long&gt;;\n    using brr = std::vector&lt;arr&gt;;\n    using crr = std::vector&lt;brr&gt;;\n    std::vector&lt;int&gt; s, tab(siz, -1);\n    auto getv_1 = [&amp;](int j, int i) &#123;\n        return (j / p[i - 1]) % 3;\n    &#125;;\n    auto getv = [&amp;](int j, int i) &#123;\n        return (s[j] / p[i - 1]) % 3;\n    &#125;;\n    auto chg = [&amp;](int j, int i, int v) &#123;\n        return tab[s[j] - p[i - 1] * getv(j, i) + p[i - 1] * v];\n    &#125;;\n    auto out = [&amp;](int i) &#123;\n        std::string s;\n        for (int j = 1; j &lt;= m; ++j)\n            s += &#39;1&#39; + getv_1(i, j);\n        return s.c_str();\n    &#125;;\n    for (int i = 0; i &lt; siz; ++i) &#123;\n        s.push_back(i);\n        int cnt = 0;\n        for (int j = 2; j &lt;= m; ++j)\n            if (getv_1(i, j - 1) == getv_1(i, j) &amp;&amp; ++cnt &gt;= 2) &#123;\n                s.pop_back();\n                break;\n            &#125;\n    &#125;\n    for (int i = 0; i &lt; (int)s.size(); ++i)\n        tab[s[i]] = i;\n    siz = (int)s.size();\n    if (n == 1) &#123;\n        std::cout &lt;&lt; (a[1][1] == -1 ? 3 : 1) &lt;&lt; &#39;\\n&#39;;\n        return 0;\n    &#125;\n    crr f(n + 1, brr(m + 1, arr(siz)));\n    for (int i = 0; i &lt; siz; ++i)\n        if ([&amp;](int i, int s) &#123;\n            for (int j = 1; j &lt;= m; ++j) &#123;\n                if (a[i][j] != -1 &amp;&amp; a[i][j] != getv(s, j))\n                    return false;\n                if (j != 1 &amp;&amp; getv(s, j) == getv(s, j - 1))\n                    return false;\n            &#125;\n            return true;\n        &#125; (1, i)) &#123;\n            for (int p = 0; p &lt; 3; ++p)\n                if ((a[2][1] == -1 || a[2][1] == p) &amp;&amp; getv(i, 1) != p &amp;&amp; ~chg(i, 1, p))\n                    (++f[2][1][chg(i, 1, p)]) %= mod;\n        &#125;\n    for (int i = 2; i &lt;= n; ++i) &#123;\n        for (int k = 1; k &lt; m; ++k)\n            for (int j = 0; j &lt; siz; ++j)\n                if (f[i][k][j]) &#123;\n                    // printf(&quot;f[%d][%d][%s] = %lld\\n&quot;, i, k, out(s[j]), f[i][k][j]);\n                    for (int p = 0; p &lt; 3; ++p)\n                        if ((a[i][k + 1] == -1 || a[i][k + 1] == p) &amp;&amp; getv(j, k) != p &amp;&amp; getv(j, k + 1) != p &amp;&amp; ~chg(j, k + 1, p))\n                            (f[i][k + 1][chg(j, k + 1, p)] += f[i][k][j]) %= mod;\n                &#125;\n        for (int j = 0; j &lt; siz; ++j)\n            if (i != n &amp;&amp; f[i][m][j])\n                for (int p = 0; p &lt; 3; ++p)\n                    if ((a[i + 1][1] == -1 || a[i + 1][1] == p) &amp;&amp; getv(j, 1) != p &amp;&amp; ~chg(j, 1, p))\n                        (f[i + 1][1][chg(j, 1, p)] += f[i][m][j]) %= mod;\n    &#125;\n    auto res = 0ll;\n    for (int i = 0; i &lt; siz; ++i)\n        (res += f[n][m][i]) %= mod;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"e---pure-straight\">E - Pure Straight</h2>\n<p><a href=\"https://atcoder.jp/contests/arc126/tasks/arc126_d\" class=\"uri\">https://atcoder.jp/contests/arc126/tasks/arc126_d</a></p>\n<p>手玩发现只要最终序列确定，那么移动的顺序不影响答案。故考虑确定目标位置和移动序列。考虑绝对值的几何意义，不妨令目标子序列中元素集中到被选中位置的中间元素，此时的代价可以计算。用点二进制技巧和库函数可以 <span class=\"math inline\">\\(O(1)\\)</span> 算代价。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, k;\n    std::cin &gt;&gt; n &gt;&gt; k;\n    int siz = 1 &lt;&lt; k;\n    std::vector&lt;int&gt; a(n + 1), f(siz, 0x3f3f3f3f);\n    auto out = [&amp;](int j) &#123;\n        std::string s;\n        for (int i = 0; i &lt; k; ++i)\n            s += (&#39;0&#39; + ((j &gt;&gt; i) &amp; 1));\n        return s.c_str();\n    &#125;;\n    f[0] = 0;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; a[i], --a[i];\n        for (int j = siz - 1; j &gt;= 0; --j) &#123;\n            if (!((j &gt;&gt; a[i]) &amp; 1))\n                f[j | (1 &lt;&lt; a[i])] = std::min(f[j | (1 &lt;&lt; a[i])], f[j] + __builtin_popcount(j &amp; (~((1 &lt;&lt; a[i]) - 1))));\n            f[j] += std::min(__builtin_popcount(j), k - __builtin_popcount(j));\n        &#125;\n    &#125;\n    std::cout &lt;&lt; f[siz - 1] &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"f---123-set\">F - 123 Set</h2>\n<p><a href=\"https://atcoder.jp/contests/arc184/tasks/arc184_b\" class=\"uri\">https://atcoder.jp/contests/arc184/tasks/arc184_b</a></p>\n<p>做过 <a href=\"https://www.luogu.com.cn/problem/P3226\">集合选数</a>（这个 trick 见过很多次了，应该不只这一道，但我想不起来了）很容易想到画一个表格或者 DAG 出来，其实都能做</p>\n<p>对于表格左上角和 DAG 的源点，肯定是一个 <span class=\"math inline\">\\(x\\)</span>，其不是 <span class=\"math inline\">\\(2\\)</span> 或 <span class=\"math inline\">\\(3\\)</span> 的倍数。如果画表，横乘 3 竖乘 2，观察一下是包含了 <span class=\"math inline\">\\(1\\sim n\\)</span> 恰好一次的很多个杨表（没什么用，提一嘴而已），考虑转化目标，发现是用一个不可旋转的倒 L 形骨牌可叠放地铺满异形表格，可以考虑轮廓线 DP</p>\n<p>具体地，用 1 来表示拐角处，0 表示其他，叠放的时候 1 的优先级比 0 高，然后就可以做了。以 3 为行，悲观估计单个表格大概有 <span class=\"math inline\">\\(31\\times 2^{19}\\)</span> 个状态，运算次数差不多 <span class=\"math inline\">\\(31\\times 19\\times 2^{19}\\)</span>；再发现长得一模一样的表格肯定方案数是一样的，如果把任意一个表格全部除以 <span class=\"math inline\">\\(x\\)</span>，就会得到 <span class=\"math inline\">\\(n=10^9\\div x\\)</span> 时 <span class=\"math inline\">\\(1\\)</span> 为左上角的杨表，就是说长相只和 <span class=\"math inline\">\\(10^9\\div x\\)</span> 的值有关，可以整除分块 😱 可预计的跑得非常不满，实践下来是可以过的（但是很慢）</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    auto calc = [&amp;](int r) &#123;\n        return r - r / 2 - r / 3 + r / 6;\n    &#125;;\n    auto dp = [&amp;](int lim) &#123;\n        if (lim == 1) &#123;\n            // printf(&quot;lim = 1, ret 1&quot;);\n            return 1;\n        &#125;\n        int n = 1, m = 1;\n        for (int k = 1; k * 2 &lt;= lim; ++n, k *= 2);\n        for (int k = 1; k * 3 &lt;= lim; ++m, k *= 3);\n        int siz = 1 &lt;&lt; m;\n        std::vector&lt;std::vector&lt;std::vector&lt;int&gt; &gt; &gt; f(2, std::vector&lt;std::vector&lt;int&gt; &gt; (2, std::vector&lt;int&gt; (siz))), p(n + 1, std::vector&lt;std::vector&lt;int&gt; &gt; (m));\n        std::vector&lt;std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; &gt; t(2, std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; (2, std::vector&lt;std::pair&lt;int, int&gt; &gt; (siz))); // sb\n        auto upd = [&amp;](int i, int k, int j, int v) &#123;\n            if (t[i &amp; 1][k &amp; 1][j] != std::make_pair(i, k)) &#123;\n                p[i][k].push_back(j);\n                t[i &amp; 1][k &amp; 1][j] = &#123; i, k &#125;, f[i &amp; 1][k &amp; 1][j] = v;\n            &#125;\n            else\n                f[i &amp; 1][k &amp; 1][j] = std::min(f[i &amp; 1][k &amp; 1][j], v);\n            return;\n        &#125;;\n        auto chg = [&amp;](int i, int j, int v) &#123;\n            return i ^ (((i &gt;&gt; j) &amp; 1) &lt;&lt; j) ^ (v &lt;&lt; j);\n        &#125;;\n        for (int i = 0; i &lt; siz; ++i) &#123;\n            bool flag = 0;\n            for (int j = 0; j &lt; m; ++j)\n                if (((i &gt;&gt; j) &amp; 1) || (j &amp;&amp; ((i &gt;&gt; (j - 1)) &amp; 1)));\n                else &#123;\n                    flag = 1;\n                    break;\n                &#125;\n            if (!flag)\n                upd(1, m - 1, i, __builtin_popcount(i));\n        &#125;\n        for (int i = 2; i &lt;= n; i++) &#123;\n            int m1 = 1;\n            for (int x = (1 &lt;&lt; (i - 1)); x * 3ll &lt;= lim; ++m1, x *= 3);\n            int siz1 = 1 &lt;&lt; m1;\n            for (auto j : p[i - 1][m - 1]) &#123;\n                if (j &amp; 1)\n                    upd(i, 0, chg(j &amp; (siz1 - 1), 0, 0), f[(i - 1) &amp; 1][(m - 1) &amp; 1][j]);\n                upd(i, 0, chg(j &amp; (siz1 - 1), 0, 1), f[(i - 1) &amp; 1][(m - 1) &amp; 1][j] + 1);\n            &#125;\n            m = m1, siz = siz1;\n            for (int k = 0; k &lt; m - 1; ++k)\n                for (auto j : p[i][k]) &#123;\n                    if (((j &gt;&gt; k) &amp; 1) || ((j &gt;&gt; (k + 1)) &amp; 1))\n                        upd(i, k + 1, chg(j, k + 1, 0), f[i &amp; 1][k &amp; 1][j]);\n                    upd(i, k + 1, chg(j, k + 1, 1), f[i &amp; 1][k &amp; 1][j] + 1);\n                &#125;\n        &#125;\n        int res = 0x3f3f3f3f;\n        for (auto i : p[n][m - 1])\n            res = std::min(res, f[n &amp; 1][(m - 1) &amp; 1][i]);\n        return res;\n    &#125;;\n    int res = 0;\n    for (int l = 1, r; l &lt;= n; l = r + 1) &#123;\n        r = n / (n / l);\n        if (calc(r) - calc(l - 1))\n            res += (calc(r) - calc(l - 1)) * dp(n / l);\n    &#125;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n",
            "tags": [
                "DP",
                "状压 DP"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20250803/",
            "url": "https://xsc062.netlify.app/20250803/",
            "title": "树 DP",
            "date_published": "2025-08-03T03:44:54.000Z",
            "content_html": "<p>树上的 DP 以及 和树有关的 DP</p>\n<span id=\"more\"></span>\n<hr />\n<h2 id=\"a---svjetlo\">A - Svjetlo</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P7163\" class=\"uri\">https://www.luogu.com.cn/problem/P7163</a></p>\n<p>很容易想到一种状态设计，即令 <span class=\"math inline\">\\(f_{x,0/1/2}\\)</span> 分别表示有 <span class=\"math inline\">\\(0/1/2\\)</span> 个端点在子树内部的情况；然后就开始思考，如何满足对于开关状态的要求？</p>\n<p>还是想少了。如果再加一维，从『状态为开或关』思考就会轻松很多，令 <span class=\"math inline\">\\(f_{x,0/1/2,0/1}\\)</span> 表示有 <span class=\"math inline\">\\(0/1/2\\)</span> 个端点再子树外部，且子树内操作完后 <span class=\"math inline\">\\(x\\)</span> 为关 / 开的最少步数。然后分类讨论转移方式即可。</p>\n<p>一个比较方便的讨论方式是，先确定某种情况下，访问 <span class=\"math inline\">\\(u\\)</span> 与 <span class=\"math inline\">\\(v\\)</span> 的次数，然后就可以得到它们原本的状态。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, rt = -1;\n    std::cin &gt;&gt; n;\n    std::vector&lt;int&gt; a(n + 1);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        char t;\n        std::cin &gt;&gt; t;\n        a[i] = t - &#39;0&#39;;\n        if (!a[i])\n            rt = i;\n    &#125;\n    if (rt == -1) &#123;\n        std::cout &lt;&lt; 0 &lt;&lt; &#39;\\n&#39;;\n        return 0;\n    &#125;\n    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);\n    for (int i = 1, x, y; i &lt; n; ++i) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y;\n        g[x].push_back(y), g[y].push_back(x);\n    &#125;\n    std::vector&lt;int&gt; tag(n + 1);\n    std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int fa) &#123;\n        tag[x] = a[x];\n        for (auto i : g[x])\n            if (i != fa)\n                DFS(i, x), tag[x] &amp;= tag[i];\n        return;\n    &#125;;\n    DFS(rt, -1);\n    std::vector&lt;std::vector&lt;std::vector&lt;int&gt; &gt; &gt; f(n + 1, std::vector&lt;std::vector&lt;int&gt; &gt; (3, std::vector&lt;int&gt; (2, 0x3f3f3f3f)));\n    DFS = [&amp;](int x, int fa) &#123;\n        f[x][0][a[x]] = 0;\n        for (auto i : g[x])\n            if (i != fa &amp;&amp; !tag[i]) &#123;\n                DFS(i, x);\n                auto g = f[x];\n                f[x][0][0] = std::min(g[0][0] + f[i][0][1] + 4, g[0][1] + f[i][0][0] + 2);\n                f[x][0][1] = std::min(g[0][1] + f[i][0][1] + 4, g[0][0] + f[i][0][0] + 2);\n                f[x][1][0] = std::min(&#123; g[1][0] + f[i][0][1] + 4, g[1][1] + f[i][0][0] + 2, g[0][0] + f[i][1][0] + 3, g[0][1] + f[i][1][1] + 1 &#125;);\n                f[x][1][1] = std::min(&#123; g[1][1] + f[i][0][1] + 4, g[1][0] + f[i][0][0] + 2, g[0][1] + f[i][1][0] + 3, g[0][0] + f[i][1][1] + 1 &#125;);\n                f[x][2][0] = std::min(&#123; g[2][0] + f[i][0][1] + 4, g[2][1] + f[i][0][0] + 2, g[1][0] + f[i][1][1], g[1][1] + f[i][1][0] + 2, g[0][0] + f[i][2][1] + 4, g[0][1] + f[i][2][0] + 2 &#125;);\n                f[x][2][1] = std::min(&#123; g[2][1] + f[i][0][1] + 4, g[2][0] + f[i][0][0] + 2, g[1][1] + f[i][1][1], g[1][0] + f[i][1][0] + 2, g[0][1] + f[i][2][1] + 4, g[0][0] + f[i][2][0] + 2 &#125;);\n            &#125;\n        f[x][1][0] = std::min(f[x][1][0], f[x][0][1] + 1);\n        f[x][1][1] = std::min(f[x][1][1], f[x][0][0] + 1);\n        f[x][2][0] = std::min(f[x][2][0], f[x][1][0]);\n        f[x][2][1] = std::min(f[x][2][1], f[x][1][1]);\n        // for (int i = 0; i &lt; 3; ++i)\n        //     for (int j = 0; j &lt; 2; ++j)\n        //         printf(&quot;f[%d][%d][%d] = %d\\n&quot;, x, i, j, f[x][i][j]);\n        return;\n    &#125;;\n    DFS(rt, -1);\n    std::cout &lt;&lt; f[rt][2][1] &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"b---one-to-one\">B - One to One</h2>\n<p><a href=\"https://atcoder.jp/contests/arc140/tasks/arc140_d\" class=\"uri\">https://atcoder.jp/contests/arc140/tasks/arc140_d</a></p>\n<p>观察原图上连通块，发现要么是没有未确定边的基环树，要么是有恰好一条未确定边的树。缩点，任意为未确定边赋值，考察最后得到的连通块，发现要么是以『基环树点』为根的树，要么是不包含『基环树点』的（内向）基环树。</p>\n<p>这里要用到贡献的思想。考虑将全局划分为若干个部分，保证每部分的单步价值是可确定的。将第一步，即对树和基环树的讨论拆开，对于树，其数量确定；对于基环树，发现环的数量即为基环树的数量，进一步将所有步中的『环』这一类分开，统计成环的方案数就可以得到基环树的贡献。具体地，令 <span class=\"math inline\">\\(f_{i,j}\\)</span> 为在前 <span class=\"math inline\">\\(i\\)</span> 个点中选择 <span class=\"math inline\">\\(j\\)</span> 个成一个环的方案数，则有：</p>\n<p><span class=\"math display\">\\[\nf_{i,j}=f_{i-1,j}+f_{i-1,j-1}\\times siz_i\n\\]</span></p>\n<p>最后计算每个环的贡献即可。注意还要算上环内部的排列（注意循环位移）。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 998244353;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;int&gt; a(n + 1), tag(n + 1), s(n + 1, 1), fa(n + 1), siz(n + 1);\n    std::iota(fa.begin() + 1, fa.end(), 1);\n    std::function&lt;int(int)&gt; find = [&amp;](int x) &#123;\n        return x == fa[x] ? x : fa[x] = find(fa[x]);\n    &#125;;\n    auto merge = [&amp;](int x, int y) &#123;\n        x = find(x), y = find(y);\n        if (x != y) &#123;\n            tag[y] += tag[x];\n            s[y] += s[x];\n            fa[x] = y;\n        &#125;\n        return;\n    &#125;;\n    for (int i = 1; i &lt;= n; ++i)  &#123;\n        std::cin &gt;&gt; a[i], fa[i] = i;\n        if (a[i] == -1)\n            tag[i] = 1;\n        else\n            merge(i, a[i]);\n    &#125;\n    int cnt1 = 0, cnt2 = 0;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        cnt1 += (fa[i] == i &amp;&amp; !tag[i]);\n        if (fa[i] == i &amp;&amp; tag[i])\n            siz[++cnt2] = s[i];\n    &#125;\n    auto qkp = [&amp;](long long x, int y) &#123;\n        auto res(1ll);\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    auto res(cnt1 * qkp(n, cnt2) % mod);\n    std::vector&lt;std::vector&lt;long long&gt; &gt; f(cnt2 + 1, std::vector&lt;long long&gt; (cnt2 + 1));\n    f[0][0] = 1ll;\n    for (int i = 1; i &lt;= cnt2; ++i) &#123;\n        // printf(&quot;i = %d, siz = %d: \\n&quot;, i, siz[i]);\n        for (int j = 0; j &lt;= i; ++j) &#123;\n            f[i][j] = f[i - 1][j];\n            if (j != 0)\n                (f[i][j] += f[i - 1][j - 1] * siz[i]) %= mod;\n            // printf(&quot;  f[%d][%d] = %lld\\n&quot;, i, j, f[i][j]);\n        &#125;\n    &#125;\n    for (int i = 1; i &lt;= cnt2; ++i) &#123;\n        static auto fac(1ll);\n        (res += f[cnt2][i] * fac % mod * qkp(n, cnt2 - i) % mod) %= mod;\n        (fac *= i) %= mod;\n    &#125;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"c---diameter-cuts\">C - Diameter Cuts</h2>\n<p><a href=\"https://codeforces.com/problemset/problem/1499/F\" class=\"uri\">https://codeforces.com/problemset/problem/1499/F</a></p>\n<p>令 <span class=\"math inline\">\\(f_{x,i}\\)</span> 表示 <span class=\"math inline\">\\(x\\)</span> 上的最长链长为 <span class=\"math inline\">\\(i\\)</span> 的方案数，就可以用一个类似背包的过程求答案了。发现这个背包满足可以被优化的形式，故能在 <span class=\"math inline\">\\(O(nk)\\)</span> 内解决问题。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 998244353;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, k;\n    std::cin &gt;&gt; n &gt;&gt; k, ++k;\n    if (k == 0) &#123;\n        std::cout &lt;&lt; 1 &lt;&lt; &#39;\\n&#39;;\n        return 0;\n    &#125;\n    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);\n    for (int i = 1, x, y; i &lt; n; ++i) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y;\n        g[x].push_back(y), g[y].push_back(x);\n    &#125;\n    std::vector&lt;int&gt; h(n + 1);\n    std::vector&lt;std::vector&lt;long long&gt; &gt; f(n + 1, std::vector&lt;long long&gt; (k + 1));\n    std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int fa) &#123;\n        f[x][1] = 1ll, h[x] = 1;\n        for (auto i : g[x])\n            if (i != fa) &#123;\n                DFS(i, x);\n                std::vector&lt;long long&gt; g(k + 1);\n                g.swap(f[x]);\n                for (int j = std::min(h[x], k); j; --j)\n                    for (int l = std::min(h[i], k - j); ~l; --l)\n                        (f[x][std::max(j, l + 1)] += g[j] * f[i][l] % mod) %= mod;\n                h[x] = std::max(h[x], h[i] + 1);\n            &#125;\n        for (int i = 1; i &lt;= h[x] &amp;&amp; i &lt;= k; ++i)\n            (f[x][0] += f[x][i]) %= mod;\n        // for (int i = 0; i &lt;= h[x] &amp;&amp; i &lt;= k; ++i)\n        //     printf(&quot;f[%d][%d] = %lld\\n&quot;, x, i, f[x][i]);\n        return;\n    &#125;;\n    DFS(1, -1);\n    auto res(0ll);\n    for (int i = 1; i &lt;= k; ++i)\n        (res += f[1][i]) %= mod;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"d---leaf-partition\">D - Leaf Partition</h2>\n<p><a href=\"https://codeforces.com/problemset/problem/1146/F\" class=\"uri\">https://codeforces.com/problemset/problem/1146/F</a></p>\n<p>假设已经完成分组，欲判定这种方式是否合法，容易想到对每一组叶子建立虚树，则该分组方式合法，当且仅当没有一个点被多个虚树占用。也即，我们需要在总的虚树上选出一些点，让它们可以覆盖所有叶子。</p>\n<p>虚树上 DP，容易发现当且仅当存在 <span class=\"math inline\">\\(\\ge 2\\)</span> 个儿子想要分进同一个虚树时，<span class=\"math inline\">\\(i\\)</span> 会被选到。故令 <span class=\"math inline\">\\(f_{i, 0/1/2}\\)</span> 表示当前有 <span class=\"math inline\">\\(0/1/\\ge 2\\)</span> 个儿子想要选择 <span class=\"math inline\">\\(i\\)</span> 时的方案数，DP 即可。</p>\n<p>在实现的过程中就会发现根本不需要求虚树，原树上 DP 就可以了。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 998244353;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;int&gt; fa(n + 1);\n    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);\n    for (int i = 2; i &lt;= n; ++i)\n        std::cin &gt;&gt; fa[i], g[fa[i]].push_back(i);\n    std::vector&lt;std::array&lt;long long, 3&gt; &gt; f(n + 1);\n    std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;\n        if (g[x].empty())\n            f[x][2] = 1ll;\n        else\n            f[x][0] = 1ll;\n        for (auto i : g[x]) &#123;\n            DFS(i);\n            auto F0 = (f[i][0] + f[i][2]) % mod, F1 = (f[i][1] + f[i][2]) % mod;\n            f[x][2] = (f[x][2] * F0 % mod + f[x][2] * F1 % mod + f[x][1] * F1 % mod) % mod;\n            f[x][1] = (f[x][1] * F0 % mod + f[x][0] * F1 % mod) % mod;\n            (f[x][0] *= F0) %= mod;\n        &#125;\n        // printf(&quot;%d: %lld / %lld / %lld\\n&quot;, x, f[x][0], f[x][1], f[x][2]);\n        return;\n    &#125;;\n    DFS(1);\n    std::cout &lt;&lt; (f[1][0] + f[1][2]) % mod &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"e---uniformly-branched-trees\">E - Uniformly Branched Trees</h2>\n<p><a href=\"https://codeforces.com/problemset/problem/724/F\" class=\"uri\">https://codeforces.com/problemset/problem/724/F</a></p>\n<p>感觉是很常见的套路，但是我不会 😱</p>\n<p>在手玩样例的时候可以感性认知到，每个树会被每种点作为根的情况统计一次。且如果固定以某种（化学环境）的点为根，可以通过按 siz 从小到大排列唯一求解出该树。</p>\n<p>发现以重心为根（即钦定根为重心）可以带来很多优美的性质。因为 siz 是好确定的，且是儿子的排序依据，所以选重心便于统计，同时满足每种树最多被统计两次（当且仅当有两个重心）。</p>\n<p>发现这就变成了多重集的组合数，设 <span class=\"math inline\">\\(f_{i,j,k}\\)</span> 表示已经花费 <span class=\"math inline\">\\(i\\)</span> 个点组成一个子树，子树的根节点当前已经确认了 <span class=\"math inline\">\\(j\\)</span> 个儿子，最靠右的一个 siz <span class=\"math inline\">\\(\\le k\\)</span> 的方案数。得到 <span class=\"math inline\">\\(f_{i,j,k}=\\sum_{x=0} f_{i-x\\cdot k,j-x,k-1}\\cdot \\binom{f_{k,d-1,k}+x-1}{x}\\)</span>（相当于将 <span class=\"math inline\">\\(x\\)</span> 个无标号的位置 / 球分配给 <span class=\"math inline\">\\(f_{k,d-1,k}\\)</span> 个有标号的选项 / 盒子，插板即可）。</p>\n<p>若 <span class=\"math inline\">\\(n\\)</span> 为奇数，则可直接输出 <span class=\"math inline\">\\(f_{n,d,\\lfloor\\frac n2\\rfloor}\\)</span>；若 <span class=\"math inline\">\\(n\\)</span> 为偶数，则可能存在两个重心，即需要统计拥有两个重心，且以两个重心分别为根时长相不同的树种类。这种情况下显然存在一条边，左右两边 siz 相同且长相不同。故数量为 <span class=\"math inline\">\\(\\binom{f_{\\lfloor \\frac n2\\rfloor, d-1,\\lfloor \\frac n2\\rfloor}}{2}\\)</span>，容斥掉即可。</p>\n<p>需要特判 <span class=\"math inline\">\\(n\\le2\\)</span> 的情况。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, d, mod;\n    std::cin &gt;&gt; n &gt;&gt; d &gt;&gt; mod;\n    if (n &lt;= 2) &#123;\n        std::cout &lt;&lt; 1 &lt;&lt; &#39;\\n&#39;;\n        return 0;\n    &#125;\n    using arr = std::vector&lt;long long&gt;;\n    using brr = std::vector&lt;arr&gt;;\n    using crr = std::vector&lt;brr&gt;;\n    auto qkp = [&amp;](long long x, int y) &#123;\n        auto res(1ll);\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    arr inv(d + 1);\n    inv[0] = inv[1] = 1ll;\n    auto fac = 1ll;\n    for (int i = 2; i &lt;= d; ++i) &#123;\n        (fac *= i) %= mod;\n        inv[i] = qkp(fac, mod - 2);\n    &#125;\n    auto C = [&amp;](long long n, int m) &#123;\n        if (m == 0)\n            return 1ll;\n        if (m &gt; n)\n            return 0ll;\n        auto res(1ll);\n        for (auto i = 0; i &lt; m; ++i)\n            (res *= n - i) %= mod;\n        return res * inv[m] % mod;\n    &#125;;\n    crr f(n + 1, brr(d + 1, arr(n / 2 + 1)));\n    f[1][0][0] = 1ll;\n    for (int i = 1; i &lt;= n; ++i)\n        for (int j = 0; j &lt;= d &amp;&amp; 1 + j &lt;= i; ++j) &#123;\n            for (int x = 0; x &lt;= j &amp;&amp; x &lt;= i; ++x)\n                f[i][j][1] += f[i - x][j - x][0];\n            f[i][j][1] %= mod;\n            for (int k = 2; k &lt;= n / 2; ++k) &#123;\n                // bool flag = (i == 10 &amp;&amp; j == 3 &amp;&amp; k == 3);\n                for (int x = 0; x &lt;= j &amp;&amp; x * k &lt;= i; ++x) &#123;\n                    f[i][j][k] += f[i - x * k][j - x][k - 1] * C(f[k][d - 1][k - 1] + x - 1, x);\n                    // if (flag)\n                    //     printf(&quot;x = %d, f[%d][%d][%d](%lld) * C(%lld, %d)(%lld)\\n&quot;, x, i - x * k, j - x, k - 1, f[i - x * k][j - x][k - 1], f[k][d - 1][k - 1] + x - 1, x, C(f[k][d - 1][k - 1] + x - 1, x));\n                &#125;\n                f[i][j][k] %= mod;\n            &#125;\n        &#125;\n    // for (int i = 1; i &lt;= n; ++i)\n    //     for (int j = 0; j &lt;= d &amp;&amp; j &lt;= i - 1; ++j, puts(&quot;&quot;))\n    //         for (int k = 0; k &lt;= n / 2; ++k) &#123;\n    //             printf(&quot;f[%d][%d][%d] = %lld\\n&quot;, i, j, k, f[i][j][k]);\n    //         &#125;\n    if (n &amp; 1)\n        std::cout &lt;&lt; f[n][d][n / 2] &lt;&lt; &#39;\\n&#39;;\n    else &#123;\n        auto res(f[n][d][n / 2]);\n        res = (res + mod - C(f[n / 2][d - 1][n / 2 - 1], 2)) % mod;\n        std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"a---dominant-indices\">A - Dominant Indices</h2>\n<p><a href=\"https://codeforces.com/problemset/problem/1009/F\" class=\"uri\">https://codeforces.com/problemset/problem/1009/F</a></p>\n<p>长剖板子；难点在于可能要复习一下长剖怎么写。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);\n    for (int i = 1, x, y; i &lt; n; ++i) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y;\n        g[x].push_back(y), g[y].push_back(x);\n    &#125;\n    std::vector&lt;int&gt; h(n + 1), son(n + 1);\n    std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int fa) &#123;\n        h[x] = 1;\n        for (auto i : g[x])\n            if (i != fa) &#123;\n                DFS(i, x);\n                h[x] = std::max(h[x], h[i] + 1);\n                if (h[i] &gt; h[son[x]])\n                    son[x] = i;\n            &#125;\n        return;\n    &#125;;\n    DFS(1, -1);\n    std::vector&lt;int&gt; _f(2 * n + 1), res(n + 1);\n    auto pos(_f.begin());\n    std::vector&lt;decltype(pos)&gt; f(n + 1);\n    DFS = [&amp;](int x, int fa) &#123;\n        ++f[x][0];\n        if (!son[x]) &#123;\n            res[x] = 0;\n            return;\n        &#125;\n        f[son[x]] = std::next(f[x]);\n        DFS(son[x], x);\n        int mx = -std::max(std::make_pair(f[x][res[son[x]] + 1], -(res[son[x]] + 1)), std::make_pair(1, 0)).second;\n        for (auto i : g[x])\n            if (i != fa &amp;&amp; i != son[x]) &#123;\n                f[i] = pos, pos = std::next(pos, h[i] + 1);\n                DFS(i, x);\n                for (int j = 0; j &lt;= h[i]; ++j) &#123;\n                    f[x][j + 1] += f[i][j];\n                    if (j + 1 != mx &amp;&amp; std::make_pair(f[x][j + 1], -(j + 1)) &gt; std::make_pair(f[x][mx], -mx))\n                        mx = j + 1;\n                &#125;\n            &#125;\n        // printf(&quot;%d: &quot;, x);\n        // for (int i = 0; i &lt;= h[x]; ++i)\n        //     printf(&quot;%d &quot;, f[x][i]);\n        // puts(&quot;&quot;);\n        res[x] = mx;\n        return;\n    &#125;;\n    f[1] = pos, pos = std::next(pos, h[1]);\n    DFS(1, -1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cout &lt;&lt; res[i] &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"b---树上异或\">B - 树上异或</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P9745\" class=\"uri\">https://www.luogu.com.cn/problem/P9745</a></p>\n<p>和 <a href=\"#a---svjetlo\">Svjetlo</a> 很像，把连通块的异或和放到状态里，拆位后令 <span class=\"math inline\">\\(f_{i,j,0/1}\\)</span> 表示点 <span class=\"math inline\">\\(i\\)</span> 所在的连通块在第 <span class=\"math inline\">\\(j\\)</span> 位异或和为 <span class=\"math inline\">\\(0/1\\)</span> 的权值（<strong>不计 <span class=\"math inline\">\\(i\\)</span> 所在连通块</strong>），转移即可。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 998244353;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;long long&gt; a(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i];\n    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);\n    for (int i = 2, x; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; x;\n        g[x].push_back(i), g[i].push_back(x);\n    &#125;\n    std::vector&lt;long long&gt; dp(n + 1);\n    std::vector&lt;std::array&lt;std::array&lt;long long, 2&gt;, 60&gt; &gt; f(n + 1);\n    std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int fa) &#123;\n        for (int i = 0; i &lt; 60; ++i)\n            f[x][i][(a[x] &gt;&gt; i) &amp; 1] = 1ll;\n        for (auto i : g[x])\n            if (i != fa) &#123;\n                DFS(i, x);\n                for (int j = 0; j &lt; 60; ++j) &#123;\n                    auto f1 = f[x][j];\n                    f[x][j][0] = (f1[0] * dp[i] % mod + f1[0] * f[i][j][0] % mod + f1[1] * f[i][j][1] % mod) % mod;\n                    f[x][j][1] = (f1[1] * dp[i] % mod + f1[0] * f[i][j][1] % mod + f1[1] * f[i][j][0] % mod) % mod;\n                &#125;\n            &#125;\n        for (int i = 0; i &lt; 60; ++i)\n            dp[x] += (1ll &lt;&lt; i) % mod * f[x][i][1] % mod;\n        dp[x] %= mod;\n        return;\n    &#125;;\n    DFS(1, -1);\n    std::cout &lt;&lt; dp[1] &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"c---一个网的路\">C - 一个网的路</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P8595\" class=\"uri\">https://www.luogu.com.cn/problem/P8595</a></p>\n<p>首先需要意识到，树和链的边数是一样的，炸掉了多少条边，在之后就会花多少代价补回来。故炸一个点的代价为度数 +1。对于一个点 <span class=\"math inline\">\\(u\\)</span>，分为四种可能性：</p>\n<ul>\n<li>被炸了，单独作为一个连通块。</li>\n<li>没被炸，儿子全部被炸了。</li>\n<li>没被炸，有 1 个儿子没被炸。</li>\n<li>没被炸，有 2 个儿子没被炸。</li>\n</ul>\n<p>分别用 <span class=\"math inline\">\\(f_{u,0/1/2/3}\\)</span> 代表上面四种可能性，转移即可。</p>\n<p>贺了个 fread，擦边跑过了。这个不是 <span class=\"math inline\">\\(O(n)\\)</span> 的吗？</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int LEN = (1 &lt;&lt; 20);\n#ifdef ONLINE_JUDGE\nint nec(void) &#123;\n    static char buf[LEN], *p = buf, *e = buf;\n    if (p == e) &#123;\n        e = buf + fread(buf, 1, LEN, stdin);\n        if (e == buf) return EOF;\n        p = buf;\n    &#125;\n    return *p++;\n&#125;\n#else\n#define nec getchar\n\n#endif\nbool read(int &amp;x) &#123;\n    x = 0;\n    bool f = 0;\n    char ch = nec();\n    while (ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123;\n        if (ch == EOF) return 0;\n        if (ch == &#39;-&#39;) f = 1;\n        ch = nec();\n    &#125;\n    while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) &#123;\n        x = x * 10 + ch - &#39;0&#39;;\n        ch = nec();\n    &#125;\n    if (f) x = -x;\n    return 1;\n&#125;\nvoid print(int x) &#123;\n    if (x &lt; 0)\n        putchar(&#39;-&#39;), x = -x;\n    if (x &gt;= 10) print(x / 10);\n    putchar(x % 10 + &#39;0&#39;);\n    return;\n&#125;\nvoid print(int x, char ch) &#123;\n    print(x), putchar(ch);\n    return;\n&#125;\nint main() &#123;\n    int n, m;\n    read(n), read(m);\n    int res = (n - 1) - m;\n    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);\n    for (int x, y; m--; ) &#123;\n        read(x), read(y);\n        g[x].push_back(y), g[y].push_back(x);\n    &#125;\n    std::vector&lt;int&gt; tag(n + 1);\n    std::vector&lt;std::array&lt;int, 4&gt; &gt; f(n + 1);\n    std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int fa) &#123;\n        tag[x] = 1;\n        f[x][0] = (fa != -1) + 1;\n        f[x][2] = f[x][3] = 0x3f3f3f3f;\n        for (auto i : g[x])\n            if (i != fa) &#123;\n                DFS(i, x);\n                f[x][3] = std::min(f[x][3] + f[i][0], f[x][2] + std::min(f[i][1], f[i][2]));\n                f[x][2] = std::min(f[x][2] + f[i][0], f[x][1] + std::min(f[i][1], f[i][2]));\n                f[x][1] += f[i][0];\n                f[x][0] += std::min(&#123; f[i][0] - 1, f[i][1], f[i][2], f[i][3] &#125;) + 1;\n            &#125;\n        return;\n    &#125;;\n    for (int i = 1; i &lt;= n; ++i)\n        if (!tag[i]) &#123;\n            DFS(i, -1);\n            res += *std::min_element(f[i].begin(), f[i].end());\n        &#125;\n    print(res, &#39;\\n&#39;);\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"d---随机树\">D - 随机树</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P3830\" class=\"uri\">https://www.luogu.com.cn/problem/P3830</a></p>\n<p>对于第一问，令 <span class=\"math inline\">\\(f_x\\)</span> 表示共有 <span class=\"math inline\">\\(x\\)</span> 个叶子时的期望深度，两个新叶子的期望深度为 <span class=\"math inline\">\\(f_{x-1}+1\\)</span>，delta 为 <span class=\"math inline\">\\(f_{x-1}+2\\)</span>，故有 <span class=\"math inline\">\\(f_x=\\dfrac {(x-1)f_{x-1}+f_{x-1}+2}x\\)</span>，递推即可。</p>\n<p>对于第二问，令 <span class=\"math inline\">\\(f_{x,k}\\)</span> 表示有 <span class=\"math inline\">\\(x\\)</span> 个叶子，深度 <span class=\"math inline\">\\(\\ge k\\)</span> 的概率（一种理解是从整数概率公式的角度出发）。则考虑枚举左、右叶子数，对于左侧叶子数为 <span class=\"math inline\">\\(i\\)</span> 的情况，<strong>为了去重，只选择深度为 <span class=\"math inline\">\\(k-1\\)</span> 的叶子展开</strong>。只考虑某种组合的出现概率，为 <span class=\"math inline\">\\(f_{i,k-1}+f_{x-i,k-1}-f_{i,k-1}\\cdot f_{x-i,k-1}\\)</span>。数归可以证明，对于任意 <span class=\"math inline\">\\(i\\)</span>，深度为 <span class=\"math inline\">\\(k-1\\)</span> 的叶子被选中的概率均为 <span class=\"math inline\">\\(\\dfrac 1{x-1}\\)</span>。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int q, n;\n    std::cin &gt;&gt; q &gt;&gt; n;\n    std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(6);\n    if (q == 1) &#123;\n        std::vector&lt;double&gt; f(n + 1);\n        for (int i = 2; i &lt;= n; ++i)\n            f[i] = (f[i - 1] * (i - 1) + f[i - 1] + 2.) / i;\n        std::cout &lt;&lt; f[n] &lt;&lt; &#39;\\n&#39;;\n    &#125;\n    else &#123;\n        std::vector&lt;std::vector&lt;double&gt; &gt; f(n + 1, std::vector&lt;double&gt; (n + 1));\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            f[i][0] = 1.;\n            for (int j = 1; j &lt; i; ++j) &#123;\n                auto s(0.);\n                for (int k = 1; k &lt; i; ++k)\n                    s += f[k][j - 1] + f[i - k][j - 1] - f[k][j - 1] * f[i - k][j - 1];\n                f[i][j] = s / (i - 1);\n            &#125;\n        &#125;\n        auto res(0.);\n        for (int i = 1; i &lt; n; ++i)\n            res += f[n][i];\n        std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"e---complete-compress\">E - Complete Compress</h2>\n<p><a href=\"https://atcoder.jp/contests/agc034/tasks/agc034_e\" class=\"uri\">https://atcoder.jp/contests/agc034/tasks/agc034_e</a></p>\n<p>对于链，发现可以枚举最后聚集的点，答案与配对方式无关，check 是否能配对即可。</p>\n<p>如果不是链，则相比链，还可以选择同一子树中不存在祖孙关系的两个点，将它们都向 LCA 移一步。</p>\n<p>故而，可以在链的做法上打一个补丁，观察到先『内部消化』，再在子树间配对一定不劣，且答案仍然和配对方式无关。故令 <span class=\"math inline\">\\(f_x\\)</span> 表示点 <span class=\"math inline\">\\(x\\)</span> 内最多消掉多少对，就可以 check 了。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst long long inf = 1e18;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;line_02.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;int&gt; a(n + 1);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        char t;\n        std::cin &gt;&gt; t;\n        a[i] = t - &#39;0&#39;;\n    &#125;\n    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);\n    for (int i = 1, x, y; i &lt; n; ++i) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y;\n        g[x].push_back(y), g[y].push_back(x);\n    &#125;\n    auto res(inf);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::vector&lt;int&gt; s(n + 1);\n        std::vector&lt;long long&gt; f(n + 1), cnt(n + 1);\n        std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int fa) &#123;\n            s[x] = a[x];\n            int son = 0;\n            auto sum(0ll);\n            for (auto i : g[x])\n                if (i != fa) &#123;\n                    DFS(i, x), s[x] += s[i];\n                    sum += cnt[i];\n                    if (cnt[i] &gt; cnt[son])\n                        son = i;\n                &#125;\n            if (son) &#123;\n                if (cnt[son] * 2 &lt;= sum)\n                    f[x] = sum / 2;\n                else\n                    f[x] = sum - cnt[son] + std::min(f[son], (cnt[son] - (sum - cnt[son])) / 2);\n            &#125;\n            cnt[x] = sum;\n            if (x != i)\n                cnt[x] += s[x];\n            return;\n        &#125;;\n        DFS(i, -1);\n        if (cnt[i] % 2 == 0 &amp;&amp; f[i] == cnt[i] / 2)\n            res = std::min(res, cnt[i] / 2);\n    &#125;\n    if (res == inf)\n        std::cout &lt;&lt; -1 &lt;&lt; &#39;\\n&#39;;\n    else\n        std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n",
            "tags": [
                "DP",
                "树形 DP",
                "长链剖分"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20250720/",
            "url": "https://xsc062.netlify.app/20250720/",
            "title": "【通知】区间最值不满足四边形不等式",
            "date_published": "2025-07-20T11:30:21.000Z",
            "content_html": "<p>花费两天，特此通告。</p>\n<span id=\"more\"></span>\n<p>以上。</p>\n",
            "tags": [
                "DP",
                "DP 优化"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20250715/",
            "url": "https://xsc062.netlify.app/20250715/",
            "title": "练习 决策单调性",
            "date_published": "2025-07-15T06:13:24.000Z",
            "content_html": "<p>『心静自然凉』大抵是因为情绪平和时副交感神经兴奋，体温略有降低导致的。吗？</p>\n<span id=\"more\"></span>\n<p>其实是因为心脏停跳后血液循环终止、代谢中断，导致产热低于散热（？）</p>\n<hr />\n<h2 id=\"a---征途\">A - 征途</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P4072\" class=\"uri\">https://www.luogu.com.cn/problem/P4072</a></p>\n<p>用完全平方公式展开得到 <span class=\"math inline\">\\(m^2\\sigma^2=m\\left(\\sum {x_i}^2\\right)-S^2\\)</span>，其中 <span class=\"math inline\">\\(S\\)</span> 为求和。</p>\n<p>所以目标是最小化 <span class=\"math inline\">\\(\\sum {x_i}^2\\)</span> 这个东西。令 <span class=\"math inline\">\\(f_{i,j}\\)</span> 表示第 <span class=\"math inline\">\\(i\\)</span> 天走到 <span class=\"math inline\">\\(j\\)</span>，得到：</p>\n<p><span class=\"math display\">\\[\n\\begin{aligned}\nf_{i,j}&amp;=\\min\\{f_{i-1,k}+(s_j-s_k)^2\\}\\\\\n&amp;=\\min\\{f_{i-1,k}-2\\times s_j\\times s_k+{s_k}^2\\}+{s_j}^2\n\\end{aligned}\n\\]</span></p>\n<p>最后得到的斜率式子是 <span class=\"math inline\">\\(\\dfrac {f_{i - 1, a}-f_{i - 1, b}+{s_a}^2-{s_b}^2}{2(s_a-s_b)}&lt;s_j\\)</span>，由于 <span class=\"math inline\">\\(s_j\\)</span> 单增，<del>单调队列维护递减斜率即可</del> <strong>更正：是递增斜率。原因是 <span class=\"math inline\">\\(&lt;\\)</span> 是弹出条件，而非保留条件……</strong></p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst long long inf = 1e9;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, m;\n    std::cin &gt;&gt; n &gt;&gt; m;\n    std::vector&lt;int&gt; a(n + 1);\n    std::vector&lt;long long&gt; s(n + 1);\n    auto sum(0ll);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; a[i];\n        s[i] = s[i - 1] + a[i];\n        sum += a[i];\n    &#125;\n    std::vector&lt;std::vector&lt;long long&gt; &gt; f(m + 1, std::vector&lt;long long&gt; (n + 1, inf));\n    f[0][0] = 0ll;\n    for (int i = 1; i &lt;= m; ++i) &#123;\n        auto f1 = [&amp;](int a, int b) &#123;\n            return f[i - 1][a] - f[i - 1][b] + s[a] * s[a] - s[b] * s[b];\n        &#125;;\n        auto f2 = [&amp;](int a, int b) &#123;\n            return 2 * (s[a] - s[b]);\n        &#125;;\n        std::vector&lt;int&gt; q(n + 1);\n        int h = 0, t = -1;\n        q[++t] = i - 1;\n        for (int j = i; j &lt;= n; ++j) &#123;\n            for (; h &lt; t &amp;&amp; f1(q[h + 1], q[h]) &lt; s[j] * f2(q[h + 1], q[h]); ++h);\n            f[i][j] = f[i - 1][q[h]] + (s[j] - s[q[h]]) * (s[j] - s[q[h]]);\n            for (; h &lt; t &amp;&amp; f1(j, q[t]) * f2(q[t], q[t - 1]) &lt; f1(q[t], q[t - 1]) * f2(j, q[t]); --t);\n            q[++t] = j;\n        &#125;\n    &#125;\n    std::cout &lt;&lt; m * f[m][n] - sum * sum &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"b---刷野-iii\">B - 刷野 III</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P10074\" class=\"uri\">https://www.luogu.com.cn/problem/P10074</a></p>\n<p>发现最坏情况就是每次『试探』都不中的情况，再试探中最坏的那一个。为啥呢，相当于我们每次攻击的一定是未知元素中血最多的一个。既然已经试探出了比阈值大的所有元素，那么下一个攻击的就一定是阈值本身，如果这次跳过它，它就会成为下一次试探失败的元素。这显然不如一开始就直接用新阈值试探。</p>\n<p>从大到小排序。令 <span class=\"math inline\">\\(f_{j, i}\\)</span> 表示只确定了前 <span class=\"math inline\">\\(i\\)</span> 大的数，已经杀了 <span class=\"math inline\">\\(j\\)</span> 个人的最坏情况最小代价。那么显然这一次的阈值是 <span class=\"math inline\">\\(a_i\\)</span>。随便选出上一次的阈值 <span class=\"math inline\">\\(a_k\\)</span>，那么中间这一段待确定的元素数量为 <span class=\"math inline\">\\(i-k\\)</span>。那么有：</p>\n<p><span class=\"math display\">\\[\n\\begin{aligned}\nf_{j, i}&amp;=\\min\\limits_{k&lt;i}\\{f_{j-1,k}+(i-k)\\times a_i\\}\\\\\n&amp;=\\min\\limits_{k&lt;i}\\{f_{j-1,k}-k\\times a_i\\}+i\\times a_i\n\\end{aligned}\n\\]</span></p>\n<p>经过验证，虽然这个式子和题解长得不一样，但是是对的 <del>因为我 n^3 暴力 A 了</del></p>\n<p>推出斜优形式 <span class=\"math inline\">\\(\\dfrac {f_{j-1,A}-f_{j-1,B}}{A-B}&lt;a_i\\)</span>，但我的朋友，<span class=\"math inline\">\\(a_i\\)</span> 是递减的。所以用单调栈维护递增斜率即可。<del>或者你也可以学习 grisses 打一个单调队列上二分</del></p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst long long inf = 1e12;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;P10074_4.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, m;\n    std::cin &gt;&gt; n &gt;&gt; m;\n    std::vector&lt;long long&gt; a(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i];\n    std::sort(a.begin() + 1, a.end(), std::greater&lt;long long&gt; ());\n    std::vector&lt;std::vector&lt;long long&gt; &gt; f(m + 1, std::vector&lt;long long&gt; (n + 1, inf));\n    f[0][0] = 0ll;\n    for (int j = 1; j &lt;= m; ++j) &#123;\n        std::vector&lt;int&gt; q(n + 1);\n        int t = -1;\n        q[++t] = j - 1;\n        auto f1 = [&amp;](int A, int B) &#123;\n            return f[j - 1][A] - f[j - 1][B];\n        &#125;;\n        auto f2 =[&amp;](int A, int B) &#123;\n            return A - B;\n        &#125;;\n        for (int i = j; i &lt;= n; ++i) &#123;\n            for (; t &gt;= 1 &amp;&amp; f1(q[t], q[t - 1]) &gt; a[i] * f2(q[t], q[t - 1]); --t);\n            f[j][i] = f[j - 1][q[t]] + (i - q[t]) * a[i];\n            for (; t &gt;= 1 &amp;&amp; f1(i, q[t]) * f2(q[t], q[t - 1]) &lt; f1(q[t], q[t - 1]) * f2(i, q[t]); --t);\n            q[++t] = i;\n        &#125;\n    &#125;\n    auto res(inf);\n    for (int i = m; i &lt;= n; ++i)\n        res = std::min(res, f[m][i]);\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"c---traka\">C - TRAKA</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P7747\" class=\"uri\">https://www.luogu.com.cn/problem/P7747</a></p>\n<p>稍微手玩一下就可以发现，假如第 <span class=\"math inline\">\\(j\\)</span> 个人在第 <span class=\"math inline\">\\(i\\)</span> 次的工作时间为 <span class=\"math inline\">\\([L_{j,i},R_{j,i}]\\)</span>，第 <span class=\"math inline\">\\(i-1\\)</span> 次为 <span class=\"math inline\">\\([L_{j,i-1},R_{j,i-1}]\\)</span>，那么要求 <span class=\"math inline\">\\(L_{j,i}\\ge R_{j,i-1}\\)</span>。</p>\n<p>令 <span class=\"math inline\">\\(s_j\\)</span> 为 <span class=\"math inline\">\\(t\\)</span> 的前缀和。假设第 <span class=\"math inline\">\\(i-1\\)</span> 次加工于 <span class=\"math inline\">\\(x_{i-1}\\)</span> 开始，那么我们可以把上式转写为 <span class=\"math inline\">\\(x_{i}+s_{j-1}\\times f_{i}\\ge x_{i-1}+s_j\\times f_{i-1}\\)</span>。也即 <span class=\"math inline\">\\(x_i-x_{i-1}\\ge s_j\\times f_{i-1}-s_{j-1}\\times f_i\\)</span>。</p>\n<p>显然需要找到一个 <span class=\"math inline\">\\(j\\)</span> 使得 RSH 取得最大值；现在就可以考虑斜率优化了。由于所有项都和 <span class=\"math inline\">\\(i\\)</span> 有关，想到两边同除 <span class=\"math inline\">\\(f_{i}\\)</span> 消掉一个 <span class=\"math inline\">\\(i\\)</span> 有关的系数，最后化出来的斜优形式是 <span class=\"math inline\">\\(\\dfrac {s_A-s_B}{s_{A-1}-s_{B-1}}&gt;\\dfrac {f_{i-1}}{f_i}\\)</span>。由于 RSH 不单调，把所有 <span class=\"math inline\">\\(j\\)</span> 塞到队列里维护递减斜率，打二分即可。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, m;\n    std::cin &gt;&gt; n &gt;&gt; m;\n    std::vector&lt;long long&gt; a(n + 1), w(m + 1), s(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i], s[i] = s[i - 1] + a[i];\n    for (int i = 1; i &lt;= m; ++i)\n        std::cin &gt;&gt; w[i];\n    std::vector&lt;long long&gt; f(m + 1);\n    std::vector&lt;int&gt; q(n + 1);\n    int h = 0, t = -1;\n    q[++t] = 1;\n    for (int i = 2; i &lt;= n; ++i) &#123;\n        for (; h &lt; t &amp;&amp; (s[i] - s[q[t]]) * (s[q[t] - 1] - s[q[t - 1] - 1]) &gt; (s[q[t]] - s[q[t - 1]]) * (s[i - 1] - s[q[t] - 1]); --t);\n        q[++t] = i;\n    &#125;\n    for (int i = 2; i &lt;= m; ++i) &#123;\n        int to = q[h];\n        for (int l = h + 1, r = t, mid; l &lt;= r; ) &#123;\n            mid = (l + r) &gt;&gt; 1;\n            if ((s[q[mid]] - s[q[mid - 1]]) * w[i - 1] &gt; w[i] * (s[q[mid] - 1] - s[q[mid - 1] - 1]))\n                to = q[mid], l = mid + 1;\n            else\n                r = mid - 1;\n        &#125;\n        f[i] = f[i - 1] + s[to] * w[i - 1] - s[to - 1] * w[i];\n    &#125;\n    std::cout &lt;&lt; f[m] + w[m] * s[n] &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"d---柠檬\">D - 柠檬</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P5504\" class=\"uri\">https://www.luogu.com.cn/problem/P5504</a></p>\n<ul>\n<li>观察零：原问题『从两端取』可以转化为分段问题，故从其中一端考虑即可。</li>\n<li>观察一：若有一段连续的 <span class=\"math inline\">\\(x\\)</span>，完整的比拆开的更优。</li>\n<li>观察二：如果一段 <span class=\"math inline\">\\(x\\)</span> 中夹杂了一些其他元素，那么在哪里分段是说不准的。</li>\n<li>观察三：如果选取的区间是 <span class=\"math inline\">\\([1,r]\\)</span>，那么贪心地想，<span class=\"math inline\">\\(a_r\\)</span> 一定是关键值，不然取 <span class=\"math inline\">\\(a_r\\)</span> 就浪费了。</li>\n<li>观察四：如果选取的区间是 <span class=\"math inline\">\\([l,r]\\)</span>，那么由观察四，<span class=\"math inline\">\\(a_l=a_r\\)</span>，且该值为关键值。</li>\n</ul>\n<p>结合这几个观察，令 <span class=\"math inline\">\\(c_i\\)</span> 表示 <span class=\"math inline\">\\(a_i\\)</span> 在 <span class=\"math inline\">\\([1,i]\\)</span> 中出现次数，<span class=\"math inline\">\\(f_i\\)</span> 表示这一段以 <span class=\"math inline\">\\(i\\)</span> 结尾的最大价值：</p>\n<p><span class=\"math display\">\\[\n\\begin{aligned}\nf_i&amp;=\\max\\limits_{j&lt;i,a_{j+1}=a_i}\\{f_j+a_i\\times (c_i-c_{j + 1} + 1)^2\\}\\\\\n&amp;=\\max\\limits_{j&lt;i,a_{j+1}=a_i}\\{f_j+a_{j+1}\\times {c_{j+1}}^2-2\\times c_i\\times a_{j+1}\\times c_{j+1}-2\\times c_{j+1}\\times a_{j+1}\\}+a_i\\times(c_i-1)^2\n\\end{aligned}\n\\]</span></p>\n<p>（怎么这么大一堆。）最后可以化出 <span class=\"math inline\">\\(\\dfrac {f_A-f_B+a_{A+1}\\cdot c_{A+1}\\cdot (c_{A+1}-2)-a_{B+1}\\cdot c_{B+1}\\cdot (c_{B+1}-2)}{2(c_{A+1} - c_{B+1})}&gt;c_i\\times a_i\\)</span>。发现对于每一种 <span class=\"math inline\">\\(a_i\\)</span>，<span class=\"math inline\">\\(c_i\\times a_i\\)</span> 是单增的。单调栈维护即可。</p>\n<p><em>这其实提醒我们关于代换的问题——显然，当与 <span class=\"math inline\">\\(i\\)</span> 的项、与 <span class=\"math inline\">\\(j\\)</span> 有关的项之间存在代换关系时，应该尽量往 <span class=\"math inline\">\\(j\\)</span> 的方向靠。</em></p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;7.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;long long&gt; a(n + 1), c(n + 1), la(10001);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; a[i];\n        c[i] = c[la[a[i]]] + 1, la[a[i]] = i;\n    &#125;\n    std::vector&lt;long long&gt; f(n + 1);\n    std::vector&lt;int&gt; _t(10001, -1);\n    std::vector&lt;std::vector&lt;int&gt; &gt; _q(10001);\n    auto f1 = [&amp;](int A, int B) &#123;\n        return f[A] - f[B] + a[A + 1] * c[A + 1] * (c[A + 1] - 2) - a[B + 1] * c[B + 1] * (c[B + 1] - 2);\n    &#125;;\n    auto f2 = [&amp;](int A, int B) &#123;\n        return 2 * (c[A + 1] - c[B + 1]);\n    &#125;;\n    ++_t[a[1]], _q[a[1]].push_back(0);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        &#123;\n            auto &amp;t = _t[a[i]];\n            auto &amp;q = _q[a[i]];\n            for (; t &gt;= 1 &amp;&amp; f1(q[t], q[t - 1]) &lt; c[i] * a[i] * f2(q[t], q[t - 1]); --t);\n            f[i] = f[q[t]] + a[i] * (c[i] - c[q[t] + 1] + 1) * (c[i] - c[q[t] + 1] + 1);\n        &#125;\n        if (i &lt; n) &#123;\n            auto &amp;t = _t[a[i + 1]];\n            auto &amp;q = _q[a[i + 1]];\n            for (; t &gt;= 1 &amp;&amp; f1(i, q[t]) * f2(q[t], q[t - 1]) &gt; f1(q[t], q[t - 1]) * f2(i, q[t]); --t);\n            q.resize(++t + 1), q[t] = i;\n        &#125;\n    &#125;\n    std::cout &lt;&lt; f[n] &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"e---knapsack-with-diminishing-values\">E - Knapsack with Diminishing Values</h2>\n<p><a href=\"https://atcoder.jp/contests/abc373/tasks/abc373_f\" class=\"uri\">https://atcoder.jp/contests/abc373/tasks/abc373_f</a></p>\n<p>发现和 <a href=\"/20250707-1/#例单调队列优化多重背包\">单调队列优化多重背包</a> 有异曲同工之妙。</p>\n<p>不妨令 <span class=\"math inline\">\\(v_i\\)</span> 表示体积，<span class=\"math inline\">\\(w_i\\)</span> 表示价值。对于每一个 <span class=\"math inline\">\\(i\\)</span>，把所有体积按模 <span class=\"math inline\">\\(v_i\\)</span> 的余数分类，设为 <span class=\"math inline\">\\(j\\cdot v_i+x\\)</span>。对于 <span class=\"math inline\">\\(k\\cdot v_i+x\\)</span>，有：</p>\n<p><span class=\"math display\">\\[\n\\begin{aligned}\nf_{i,j\\cdot v_i+x}&amp;=\\max\\limits_{k&lt;j}\\{f_{i-1,k\\cdot v_i+x}+(j-k)\\cdot w_i-(j-k)^2\\}\\\\\n&amp;=\\max\\limits_{k&lt;j}\\{f_{i-1,k\\cdot v_i+x}-k\\cdot w_i-k^2+2\\times j\\times k\\}-j^2+j\\cdot w_i\n\\end{aligned}\n\\]</span></p>\n<p>则得到 <span class=\"math inline\">\\(\\dfrac {f_{i-1,A\\cdot v_i+x}-f_{i-1,B\\cdot v_i+x}+(B-A)\\cdot w_i - A^2+B^2}{2(B-A)}&lt;j\\)</span>。注意分母为负。总之单调队列维护递增斜率即可。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, m;\n    std::cin &gt;&gt; n &gt;&gt; m;\n    std::vector&lt;long long&gt; v(n + 1), w(n + 1);\n    std::vector&lt;std::vector&lt;long long&gt; &gt; f(n + 1, std::vector&lt;long long&gt; (m + 1));\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; v[i] &gt;&gt; w[i];\n        for (int x = 0; x &lt; v[i]; ++x) &#123;\n            int h = 0, t = -1;\n            std::vector&lt;int&gt; q;\n            auto f1 = [&amp;](int A, int B) &#123;\n                return f[i - 1][A * v[i] + x] - f[i - 1][B * v[i] + x] + (B - A) * w[i] - A * A + B * B;\n            &#125;;\n            auto f2 = [&amp;](int A, int B) &#123;\n                return 2 * (B - A);\n            &#125;;\n            for (int j = 0, J = x; J &lt;= m; ++j, J += v[i]) &#123;\n                for (; h &lt; t &amp;&amp; f1(q[h + 1], q[h]) &gt; j * f2(q[h + 1], q[h]); ++h);\n                f[i][J] = f[i - 1][J];\n                if (h &lt;= t)\n                    f[i][J] = std::max(f[i][J], f[i - 1][q[h] * v[i] + x] + (j - q[h]) * w[i] - (j - q[h]) * (j - q[h]));\n                for (; h &lt; t &amp;&amp; f1(j, q[t]) * f2(q[t], q[t - 1]) &lt; f1(q[t], q[t - 1]) * f2(j, q[t]); --t);\n                q.resize(++t + 1), q[t] = j;\n            &#125;\n        &#125;\n    &#125;\n    std::cout &lt;&lt; f[n][m] &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"f---managing-telephone-poles\">F - Managing Telephone Poles</h2>\n<p><a href=\"https://codeforces.com/problemset/problem/1575/M\" class=\"uri\">https://codeforces.com/problemset/problem/1575/M</a></p>\n<p>？观察到性质然后被自己忽略了。非常值得批评。</p>\n<p>不难写出类似斜率优化的式子 <span class=\"math inline\">\\(S(i,j)=\\min\\{ {x_k}^2-2\\times i\\times x_k+{y_k}^2-2\\times j \\times y_k\\}+i^2+j^2\\)</span>。</p>\n<p>会下意识尝试固定 <span class=\"math inline\">\\(i\\)</span>，就可以 <span class=\"math inline\">\\(O(n^2m)\\)</span> 完成任务，似乎不太行。顺着这个想法会观察到，固定 <span class=\"math inline\">\\(i\\)</span> 之后，每一列的 poles 中只有和第 <span class=\"math inline\">\\(i\\)</span> 行最近的才会有贡献。</p>\n<p>这个是好做的，且这样的相邻点数量是 <span class=\"math inline\">\\(O(m)\\)</span> 的；于是将 <span class=\"math inline\">\\(i\\)</span> 视为常数进行变形，若将所有 poles 按 <span class=\"math inline\">\\(y\\)</span> 从小到大排序就能得到斜率形式 <span class=\"math inline\">\\(\\dfrac { {x_A}^2-{x_B}^2+{y_A}^2-{y_B}^2-2\\times i\\times(x_A-x_B)}{2(y_A-y_B)}&lt;j\\)</span>。维护递增斜率就能 <span class=\"math inline\">\\(O(n^2)\\)</span> 完成问题。</p>\n<p>那么找相邻点这一步大可以摆烂写二分。所以总共是 <span class=\"math inline\">\\(O(nm\\log m)\\)</span> 的。</p>\n<p>不要像我一样把两边最近的都加进队列，不然你会有分母为 <span class=\"math inline\">\\(0\\)</span> 的斜率 <img src=\"/em/hsh.gif\" /></p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, m;\n    std::cin &gt;&gt; n &gt;&gt; m, ++n, ++m;\n    std::vector&lt;std::vector&lt;int&gt; &gt; tag(n + 1, std::vector&lt;int&gt; (m + 1));\n    std::vector&lt;std::vector&lt;int&gt; &gt; g(m + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        for (int j = 1; j &lt;= m; ++j) &#123;\n            char t;\n            std::cin &gt;&gt; t;\n            if (t == &#39;1&#39;)\n                g[j].push_back(i), tag[i][j] = 1;\n        &#125;\n    struct node &#123; long long x, y; &#125;;\n    auto res(0ll);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::vector&lt;node&gt; p;\n        for (int j = 1; j &lt;= m; ++j) &#123;\n            int to = std::lower_bound(g[j].begin(), g[j].end(), i) - g[j].begin();\n            if (to &lt; (int)g[j].size()) &#123;\n                p.push_back(&#123; g[j][to], j &#125;);\n                if (g[j][to] != i &amp;&amp; to != 0 &amp;&amp; g[j][to] - i &gt; i - g[j][to - 1])\n                    p.back() = &#123; g[j][to - 1], j &#125;;\n            &#125;\n            else if (to != 0)\n                p.push_back(&#123; g[j][to - 1], j &#125;);\n        &#125;\n        std::vector&lt;int&gt; q(m + 1);\n        int h = 0, t = -1;\n        auto f1 = [&amp;](node A, node B) &#123;\n            return A.x * A.x - B.x * B.x + A.y * A.y - B.y * B.y - 2 * i * (A.x - B.x);\n        &#125;;\n        auto f2 = [&amp;](node A, node B) &#123;\n            return 2 * (A.y - B.y);\n        &#125;;\n        for (int j = 0; j &lt; (int)p.size(); ++j) &#123;\n            for (; h &lt; t &amp;&amp; f1(p[j], p[q[t]]) * f2(p[q[t]], p[q[t - 1]]) &lt; f1(p[q[t]], p[q[t - 1]]) * f2(p[j], p[q[t]]); --t);\n            q[++t] = j;\n        &#125;\n        for (int j = 1; j &lt;= m; ++j) &#123;  \n            for (; h &lt; t &amp;&amp; f1(p[q[h + 1]], p[q[h]]) &lt; j * f2(p[q[h + 1]], p[q[h]]); ++h);\n            res += (p[q[h]].x - i) * (p[q[h]].x - i) + (p[q[h]].y - j) * (p[q[h]].y - j);\n        &#125;\n    &#125;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"g---partition-game\">G - Partition Game</h2>\n<p><a href=\"https://codeforces.com/problemset/problem/1527/E\" class=\"uri\">https://codeforces.com/problemset/problem/1527/E</a></p>\n<p>发现不太斜优，终于给我浸泡了两天斜优内容的大脑加了勺新的底物。</p>\n<p>令 <span class=\"math inline\">\\(f_{i,j}\\)</span> 表示第 <span class=\"math inline\">\\(i\\)</span> 段以 <span class=\"math inline\">\\(j\\)</span> 结尾的最小代价；对 <span class=\"math inline\">\\(w\\)</span> 套用四边形不等式变式 <span class=\"math inline\">\\(w(l-1,r+1)+w(l,r)\\ge w(l-1,r)+w(l,r+1)\\)</span> 发现成立（其中大多数时候能取等；部分特殊情况取到大于号）。</p>\n<p>那么发现可以用分治优化。发现 <span class=\"math inline\">\\(w\\)</span> 不那么能快速求；还是套用 <a href=\"/20250707-1/#例yet-another-minimization-problem\">Yet Another Minimization Problem</a> 中的方法，用类似莫队的方式求解。</p>\n<p>发现这个莫队套路也很熟悉了，直接用双端队列维护即可。复杂度 <span class=\"math inline\">\\(O(nk\\log n)\\)</span>，看着不太安全。但注意到我们在 20 个月前的提交中使用了 <span class=\"math inline\">\\(O(nk\\log n)\\)</span> 的线段树，所以能过的兄弟。</p>\n<details>\n<p>鉴于 deque 的时空常数都大得吓人，所以我用静态 vector 模拟 deque 了。</p>\n<p>跑得比我之前线段树的一半还快，兄弟。</p>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int inf = 1e18;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, m;\n    std::cin &gt;&gt; n &gt;&gt; m;\n    std::vector&lt;std::vector&lt;int&gt; &gt; pos(n + 1);\n    std::vector&lt;int&gt; a(n + 1), _h(n + 1), _t(n + 1, -1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i], pos[a[i]].push_back(i);\n    std::vector&lt;std::vector&lt;long long&gt; &gt; f(m + 1, std::vector&lt;long long&gt; (n + 1, inf));\n    f[0][0] = 0ll;\n    auto w = [&amp;](int ql, int qr) &#123;\n        static int l = 1, r = 0;\n        static auto res(0ll);\n        for (; l &gt; ql; ) &#123;\n            --l;\n            auto &amp;h = _h[a[l]], &amp;t = _t[a[l]];\n            auto &amp;q = pos[a[l]];\n            if (h &lt;= t)\n                res -= q[t] - q[h];\n            res += q[t] - q[--h];\n        &#125;\n        for (; r &gt; qr; ) &#123;\n            auto &amp;h = _h[a[r]], &amp;t = _t[a[r]];\n            auto &amp;q = pos[a[r]];\n            res -= q[t--] - q[h];\n            if (h &lt;= t)\n                res += q[t] - q[h];\n            --r;\n        &#125;\n        for (; r &lt; qr; ) &#123;\n            ++r;\n            auto &amp;h = _h[a[r]], &amp;t = _t[a[r]];\n            auto &amp;q = pos[a[r]];\n            if (h &lt;= t)\n                res -= q[t] - q[h];\n            res += q[++t] - q[h];\n        &#125;\n        for (; l &lt; ql; ) &#123;\n            auto &amp;h = _h[a[l]], &amp;t = _t[a[l]];\n            auto &amp;q = pos[a[l]];\n            res -= q[t] - q[h++];\n            if (h &lt;= t)\n                res += q[t] - q[h];\n            ++l;\n        &#125;\n        return res;\n    &#125;;\n    for (int t = 1; t &lt;= m; ++t) &#123;\n        std::function&lt;void(int, int, int, int)&gt; calc = [&amp;](int l, int r, int lp, int rp) &#123;\n            if (l &gt; r)\n                return;\n            if (l == r) &#123;\n                for (int i = lp; i &lt;= rp &amp;&amp; i &lt; l; ++i)\n                    f[t][l] = std::min(f[t][l], f[t - 1][i] + w(i + 1, l));\n                return;\n            &#125;\n            int mid = (l + r) &gt;&gt; 1, p = -1;\n            for (int i = lp; i &lt;= rp &amp;&amp; i &lt; mid; ++i)\n                if (f[t - 1][i] + w(i + 1, mid) &lt; f[t][mid])\n                    f[t][mid] = f[t - 1][i] + w(i + 1, mid), p = i;\n            calc(l, mid - 1, lp, p), calc(mid + 1, r, p, rp);\n            return;\n        &#125;;\n        calc(t, n, t - 1, n - 1);\n    &#125;\n    std::cout &lt;&lt; f[m][n] &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"h---battle-lemmings\">H - Battle Lemmings</h2>\n<p><a href=\"https://codeforces.com/problemset/problem/1420/E\" class=\"uri\">https://codeforces.com/problemset/problem/1420/E</a></p>\n<p>容易发现 <span class=\"math inline\">\\(0\\)</span> 的数目不变，答案就是 <span class=\"math inline\">\\(0\\)</span> 的对数 - 连续 <span class=\"math inline\">\\(0\\)</span> 的对数。</p>\n<p>然后有一个我们很熟悉的 trick，随便找一个目标序列，那么花费的操作次数就是每个对应的 <span class=\"math inline\">\\(1\\)</span> 的位置差。令 <span class=\"math inline\">\\(f_{i,j,k}\\)</span> 表示用了 <span class=\"math inline\">\\(i\\)</span> 次操作、<span class=\"math inline\">\\(j\\)</span> 个 <span class=\"math inline\">\\(1\\)</span>、最后一个 <span class=\"math inline\">\\(1\\)</span> 在 <span class=\"math inline\">\\(k\\)</span> 的最小连续 <span class=\"math inline\">\\(0\\)</span> 对数。那么有：</p>\n<p><span class=\"math display\">\\[\n\\begin{aligned}\nf_{i,j,k}&amp;=\\min\\limits_{p&lt;k}\\left\\{f_{i-|k-pos_j|,j-1,p}+\\dfrac {(k-p-1)(k-p-2)}2\\right\\}\\\\\n&amp;=\\min\\left\\{f_{i-|k-pos_j|,j-1,p}-k\\cdot p+\\dfrac {p(p + 2)}2\\right\\}+\\dfrac {k^2-3k+2}2\n\\end{aligned}\n\\]</span></p>\n<p>发现这个式子是 <span class=\"math inline\">\\(O(n^5)\\)</span> 的，而且看起来很斜优，化为斜率形式 <span class=\"math inline\">\\(\\dfrac{2\\times f_A-2\\times f_B+A(A+2)-B(B+2)}{2(A-B)}&lt;k\\)</span>。维护递增斜率就可以 <span class=\"math inline\">\\(O(n^4)\\)</span> 做了。</p>\n<p>Tip：当时写着写着愣住了，比如这个 <span class=\"math inline\">\\(i-|k-pos_j|\\)</span> 不是一直在动吗。解决方案？同时维护很多个队列即可。</p>\n<details>\n<p>注意还要把最后一个 <span class=\"math inline\">\\(1\\)</span> 之后连续 <span class=\"math inline\">\\(0\\)</span> 的代价算上。</p>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst long long inf = 1e9;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;int&gt; a(n + 1);\n    std::vector&lt;long long&gt; pos(1);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; a[i];\n        if (a[i] == 1)\n            pos.push_back(i);\n    &#125;\n    int m = n * (n - 1) / 2;\n    std::vector&lt;std::vector&lt;std::vector&lt;long long&gt; &gt; &gt; f(pos.size(), std::vector&lt;std::vector&lt;long long&gt; &gt; (m + 1, std::vector&lt;long long&gt; (n + 1, inf)));\n    f[0][0][0] = 0ll;\n    for (int j = 1; j &lt; (int)pos.size(); ++j) &#123;\n        std::vector&lt;std::vector&lt;int&gt; &gt; _q(m + 1, std::vector&lt;int&gt; (n + 1));\n        std::vector&lt;int&gt; _h(m + 1), _t(m + 1, -1);\n        for (int k = 0; k &lt;= n; ++k)\n            for (int i = m; i &gt;= 0; --i) &#123;\n                if (i &gt;= std::abs(k - pos[j])) &#123;\n                    auto f1 = [&amp;](long long A, long long B) &#123;\n                        return 2 * f[j - 1][i - std::abs(k - pos[j])][A] - 2 * f[j - 1][i - std::abs(k - pos[j])][B] + A * (A + 2) - B * (B + 2);\n                    &#125;;\n                    auto f2 = [&amp;](long long A, long long B) &#123;\n                        return 2 * (A - B);\n                    &#125;;\n                    auto &amp;h = _h[i - std::abs(k - pos[j])], &amp;t = _t[i - std::abs(k - pos[j])];\n                    auto &amp;q = _q[i - std::abs(k - pos[j])];\n                    for (; h &lt; t &amp;&amp; f1(q[h + 1], q[h]) &lt; k * f2(q[h + 1], q[h]); ++h) &#123;&#125;\n                    if (h &lt;= t)\n                        f[j][i][k] = std::min(inf, f[j - 1][i - std::abs(k - pos[j])][q[h]] + (k - q[h] - 1) * (k - q[h] - 2) / 2);\n                &#125;\n                auto f1 = [&amp;](long long A, long long B) &#123;\n                    return 2 * f[j - 1][i][A] - 2 * f[j - 1][i][B] + A * (A + 2) - B * (B + 2);\n                &#125;;\n                auto f2 = [&amp;](long long A, long long B) &#123;\n                    return 2 * (A - B);\n                &#125;;\n                auto &amp;h = _h[i], &amp;t = _t[i];\n                auto &amp;q = _q[i];\n                for (; h &lt; t &amp;&amp; f1(k, q[t]) * f2(q[t], q[t - 1]) &lt; f1(q[t], q[t - 1]) * f2(k, q[t]); --t);\n                q[++t] = k;\n            &#125;\n    &#125;\n    auto res(-inf);\n    int cnt = n - (int)pos.size() + 1;\n    cnt = cnt * (cnt - 1) / 2;\n    for (int i = 0; i &lt;= m; ++i) &#123;\n        for (int k = 0; k &lt;= n; ++k)\n            res = std::max(res, cnt - f.back()[i][k] - (n - k) * (n - k - 1) / 2);\n        std::cout &lt;&lt; res &lt;&lt; &#39; &#39;;\n    &#125;\n    std::cout &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"a---yakiniku-restaurants\">A - Yakiniku Restaurants</h2>\n<p><a href=\"https://atcoder.jp/contests/arc067/tasks/arc067_d\" class=\"uri\">https://atcoder.jp/contests/arc067/tasks/arc067_d</a></p>\n<p>发现固定左右端点后，收益是可以贪心算的；下意识想到只固定左端点，那么右端点应该就可以用单调队列之类的搞一搞。</p>\n<p>先提前把所有东西塞到队列里。左端点一开始在最右边；往左边动一下之后，就可以更新每种菜的队列；发现在所有元素中作决策点的不总是队头；这个地方用 <strong>单调递减的单调栈</strong> 是极好的。这里的单调栈其实就类似 <a href=\"/20250707-1/#优化-dp单调数据结构\">四边形不等式中的单调数据结构</a> 了。</p>\n<p>维护单调栈中每个决策点的影响区间；显然每个右端点的答案变化量相同；用个类似于差分的东西记录一下就好了。</p>\n<p>复杂度 <span class=\"math inline\">\\(O(n^2)\\)</span>。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst long long inf = 1e18;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, m;\n    std::cin &gt;&gt; n &gt;&gt; m;\n    std::vector&lt;long long&gt; s(n + 1), f(n + 1);\n    for (int i = 2; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; s[i], s[i] += s[i - 1];\n        f[i] = -s[i];\n    &#125;\n    std::vector&lt;std::vector&lt;int&gt; &gt; a(n + 1, std::vector&lt;int&gt; (m + 1));\n    for (int i = 1; i &lt;= n; ++i)\n        for (int j = 1; j &lt;= m; ++j)\n            std::cin &gt;&gt; a[i][j];\n    struct node &#123; int j, l, r; &#125;;\n    std::vector&lt;std::stack&lt;node&gt; &gt; _q(m + 1);\n    auto res(-inf);\n    for (int l = n; l; --l) &#123;\n        std::vector&lt;long long&gt; d(n + 1);\n        auto add = [&amp;](int l, int r, long long v) &#123;\n            d[l] += v;\n            if (r != n)\n                d[r + 1] -= v;\n            return;\n        &#125;;\n        for (int j = 1; j &lt;= m; ++j) &#123;\n            auto &amp;q = _q[j];\n            node now = &#123; j, l, l &#125;;\n            add(l, l, a[l][j]);\n            for (; !q.empty() &amp;&amp; a[l][j] &gt;= a[q.top().l][q.top().j]; q.pop()) &#123;\n                now.r = q.top().r;\n                add(q.top().l, q.top().r, a[l][j] - a[q.top().l][q.top().j]);\n            &#125;\n            q.push(now);\n        &#125;\n        std::partial_sum(d.begin() + 1, d.end(), d.begin() + 1);\n        for (int r = l; r &lt;= n; ++r) &#123;\n            f[r] += d[r];\n            res = std::max(res, f[r] + s[l]);\n        &#125;\n    &#125;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"b---jellyfish-and-miku\">B - Jellyfish and Miku</h2>\n<p><a href=\"https://codeforces.com/problemset/problem/1874/D\" class=\"uri\">https://codeforces.com/problemset/problem/1874/D</a></p>\n<p>唉数列。唉概统。在数学讲义上折磨了我一遍之后还要到这儿来折磨我。</p>\n<p>假设已经知道了 <span class=\"math inline\">\\(a\\)</span>，考虑求期望步数。设 <span class=\"math inline\">\\(E_i\\)</span> 为从 <span class=\"math inline\">\\(i\\)</span> 出发走到 <span class=\"math inline\">\\(n\\)</span> 的期望步数。那么有：</p>\n<p><span class=\"math display\">\\[\nE_i=\\begin{cases}\nE_1+1&amp;i=0\\\\\n0&amp;i=n\\\\\nE_i=(E_{i-1}+1)\\cdot \\dfrac {a_i}{a_{i+1}+a_i}+(E_{i+1}+1)\\cdot \\dfrac {a_{i+1}}{a_{i+1}+a_{i}}&amp;\\text{otherwise}\n\\end{cases}\n\\]</span></p>\n<p>（提示：从『<span class=\"math inline\">\\(i\\)</span> 下一步会走哪个方向』考虑。）</p>\n<p>接下来就可以利用你的高中数学知识进行一个 <span class=\"math inline\">\\(f_0\\)</span> 的求，（一堆过程），得到 <span class=\"math inline\">\\(E_0=n+2\\times \\sum\\limits_{i=1}^n\\dfrac {\\sum_{j\\le i}a_j}{a_i}\\)</span>，然后想要最小化这个东西。</p>\n<p>不妨令 <span class=\"math inline\">\\(f_{i,j}\\)</span> 表示到 <span class=\"math inline\">\\(i\\)</span> 时已经分配走了 <span class=\"math inline\">\\(j\\)</span> 体积，<span class=\"math inline\">\\(\\sum_{k=1}^i \\dfrac {\\sum_{l\\le k}a_l}{a_k}\\)</span> 的最小值，有 <span class=\"math inline\">\\(f_{i,j}=\\min\\limits_{k&lt;j}\\left\\{f_{i-1,k}+\\dfrac {k}{j - k}\\right\\}\\)</span>。发现它大抵是满足四边形不等式的，按照 <a href=\"/20250707-1/#d1d-dp-优化\">2D/1D DP 优化的结论</a>，代入 <span class=\"math inline\">\\(p_{i,j-1}&lt;p_{i,j}&lt;p_{i+1,j}\\)</span> 可以 <span class=\"math inline\">\\(O(nm)\\)</span> 解决问题。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, m;\n    std::cin &gt;&gt; n &gt;&gt; m;\n    std::vector&lt;std::vector&lt;int&gt; &gt; p(n + 1, std::vector&lt;int&gt; (m + 1));\n    std::vector&lt;std::vector&lt;long double&gt; &gt; f(n + 1, std::vector&lt;long double&gt; (m + 1, 1e18));\n    f[0][0] = 0ll;\n    for (int j = 1; j &lt;= m; ++j)\n        for (int i = std::min(j, n); i; --i) &#123;\n            int to = ((i == std::min(j, n)) ? j : std::min(p[i + 1][j], j));\n            for (int k = p[i][j - 1]; k &lt;= to; ++k)\n                if (f[i - 1][k] + k * 1. / (j - k) &lt; f[i][j])\n                    f[i][j] = f[i - 1][k] + k * 1. / (j - k), p[i][j] = k;\n            // printf(&quot;f[%d][%d] = %Lf, p = %d\\n&quot;, i, j, f[i][j], p[i][j]);\n        &#125;\n    std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(10) &lt;&lt; n + 2 * f[n][m] &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"cut-the-sequence\">Cut the Sequence</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P10977\" class=\"uri\">https://www.luogu.com.cn/problem/P10977</a></p>\n<h1 id=\"通知区间最值-不满足-四边形不等式\"><mark>通知：区间最值 不满足 四边形不等式。</mark></h1>\n<p>其实在猜的时候是举了反例的，但是大脑萎缩了推着推着忘记符号了 😅</p>\n<p>看到 <span class=\"math inline\">\\(f_i=\\min\\limits_{g(i)\\le j&lt;i}\\{f_j+\\max\\{a_{j+1\\sim i}\\}\\}\\)</span> 这个 <span class=\"math inline\">\\(j\\)</span> 的范围其实是有点单调队列优化的感觉的，但这个最大值传统的单调队列不是很可做。可以注意到最大值这一项有点 <strong>单调队列</strong> 后缀最大值的感觉（实际上就是）；一个很自然的想法是利用这个最大值影响的区间，维护 <span class=\"math inline\">\\(f\\)</span> 的线段树来暴力做。</p>\n<p>另一个比较牛的做法是发现同一个下标的 <span class=\"math inline\">\\(f\\)</span> 和 <span class=\"math inline\">\\(a\\)</span> 的关系。首先需要注意到 <span class=\"math inline\">\\(f\\)</span> 单调不降；对于同一个 <span class=\"math inline\">\\(a\\)</span>，能取到的 <span class=\"math inline\">\\(f\\)</span> 就是最靠前的；维护一个 <span class=\"math inline\">\\(a\\)</span> 的单减队列，那么共用同一个 <span class=\"math inline\">\\(a\\)</span> 的就是相邻两个下标之间的部分，其最优决策在能取到的最前端取得；需要注意到队列里的贡献并不单调，需要用一个 multiset 来存储所有贡献并查找、更新。</p>\n<p>需要注意单调队列里某个元素 <span class=\"math inline\">\\(f_{q_i}\\)</span> 结合的其实是 <span class=\"math inline\">\\(a_{q_{i+1}}\\)</span>。还需要注意队头的维护，可能需要一些小巧思。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;1.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, m;\n    std::cin &gt;&gt; n &gt;&gt; m;\n    std::vector&lt;int&gt; a(n + 1);\n    std::vector&lt;long long&gt; s(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i], s[i] = s[i - 1] + a[i];\n    int h = 0, t = -1;\n    std::multiset&lt;long long&gt; st;\n    std::vector&lt;long long&gt; f(n + 1);\n    std::vector&lt;std::pair&lt;int, int&gt; &gt; q(n + 1);\n    q[++t] = &#123; 0, 0 &#125;, a[0] = 0x3f3f3f3f;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        for (; s[i] - s[q[h].second] &gt; m; ) &#123;\n            st.erase(st.find(f[q[h].second] + a[q[h + 1].first]));\n            if (++q[h].second &gt;= q[h + 1].first)\n                a[q[++h].first] = 0x3f3f3f3f;\n            else\n                st.insert(f[q[h].second] + a[q[h + 1].first]);\n        &#125;\n        for (; h &lt; t &amp;&amp; a[q[t].first] &lt;= a[i]; --t)\n            st.erase(st.find(f[q[t - 1].second] + a[q[t].first]));\n        st.insert(f[q[t].second] + a[i]), q[++t] = &#123; i, i &#125;;\n        f[i] = *st.begin();\n    &#125;\n    std::cout &lt;&lt; f[n] &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n",
            "tags": [
                "斜率优化",
                "DP",
                "四边形不等式"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20250709/",
            "url": "https://xsc062.netlify.app/20250709/",
            "title": "练习 - DP 凸优化",
            "date_published": "2025-07-09T13:59:41.000Z",
            "content_html": "<p>Stewart’s theorem：在线段 <span class=\"math inline\">\\(AB\\)</span> 上取一点 <span class=\"math inline\">\\(M\\)</span>，使得 <span class=\"math inline\">\\(\\vec{AB}=\\lambda \\vec{AM}\\)</span>。在 <span class=\"math inline\">\\(AB\\)</span> 上方任取一点 <span class=\"math inline\">\\(P\\)</span>，则有 <span class=\"math inline\">\\(PM^2=(1-\\lambda) PA^2+\\lambda PB^2-\\lambda(1-\\lambda) AB^2\\)</span>。</p>\n<span id=\"more\"></span>\n<hr />\n<h2 id=\"d.-akvizna\">D. Akvizna</h2>\n<p><a href=\"http://222.180.160.110:61235/contest/6393/problem/4\" class=\"uri\">http://222.180.160.110:61235/contest/6393/problem/4</a></p>\n<p>其实到这里应该发现了，WQS 的奖励都以一次项系数出现，原因也很显然，奖励的对象是一次项系数嘛。此外，WQS 内层 DP 数组的维度都应和操作次数无关，而 DP 值应为最大收益。这个也很显然。</p>\n<p>令一轮比赛的惩罚是 <span class=\"math inline\">\\(mid\\)</span> 然后二分。令 <span class=\"math inline\">\\(f_{j}\\)</span> 表示剩余人数为 <span class=\"math inline\">\\(j\\)</span> 时的最大收益，那么有 <span class=\"math inline\">\\(f_{j}=\\max\\limits_{k\\ge j}\\left\\{f_k+\\frac {k-j}k\\right\\}-mid\\)</span>。最后在 <span class=\"math inline\">\\(f_0\\)</span> 处找答案即可。</p>\n<p>然后就发现一个很可怕的问题，内层 DP 咋写。发现把 <span class=\"math inline\">\\(\\frac {k-j}k\\)</span> 改写成 <span class=\"math inline\">\\(1-\\frac jk\\)</span> 后出现交叉项，考虑斜优。令 <span class=\"math inline\">\\(a&lt;b\\)</span>，那么 <span class=\"math inline\">\\(a\\)</span> 优于 <span class=\"math inline\">\\(b\\)</span> 当且仅当 <span class=\"math inline\">\\(\\dfrac {f_a-f_b}{\\frac 1a - \\frac 1b} &gt; j\\)</span>。维护单减的斜率即可。</p>\n<details>\n<p>笑话：二分 50 次不够，需要 60 次。</p>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, k;\n    std::cin &gt;&gt; n &gt;&gt; k;\n    double l = 0., r = 1e5, mid;\n    auto calc = [&amp;](double mid) &#123;\n        std::vector&lt;double&gt; f(n + 1, -1e18);\n        f[n] = 0.;\n        int h = 1, t = 0;\n        std::vector&lt;int&gt; q(n + 1), p(n + 1);\n        q[++t] = n;\n        // printf(&quot;mid = %.3lf: \\n&quot;, mid);\n        for (int i = n - 1; ~i; --i) &#123;\n            for (; h &lt; t &amp;&amp; (f[q[h + 1]] - f[q[h]]) / (1. / q[h + 1] - 1. / q[h]) &gt;= i; ++h);\n            f[i] = f[q[h]] + 1. - i * 1.0 / q[h] - mid, p[i] = p[q[h]] + 1;\n            // printf(&quot;  %d: f = %.3lf, p = %d, q[h] = %d(%.3lf / %d)\\n&quot;, i, f[i], p[i], q[h], f[q[h]], p[q[h]]);\n            if (i) &#123;\n                for (; h &lt; t &amp;&amp; (f[i] - f[q[t]]) / (1. / i - 1. / q[t]) &gt;= (f[q[t]] - f[q[t - 1]]) / (1. / q[t] - 1. / q[t - 1]); --t);\n                q[++t] = i;\n            &#125;\n        &#125;\n        // printf(&quot;res = %.3lf\\n&quot;, f[0] + p[0] * mid);\n        return std::make_pair(f[0], p[0]);\n    &#125;;\n    // calc(0.);\n    // return 0;\n    double res(0.);\n    for (int i = 1; i &lt;= 60; ++i) &#123;\n        mid = (l + r) / 2.;\n        auto t(calc(mid));\n        if (t.second &gt;= k)\n            l = mid, res = t.first + k * mid;\n        else\n            r = mid;\n    &#125;\n    std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(8) &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"e.-poborcy-podatkowi\">E. Poborcy podatkowi</h2>\n<p><a href=\"http://222.180.160.110:61235/contest/6393/problem/5\" class=\"uri\">http://222.180.160.110:61235/contest/6393/problem/5</a></p>\n<p>首先令 <span class=\"math inline\">\\(f_{u,l}(i),l=0,1,2,3\\)</span> 表示在 <span class=\"math inline\">\\(u\\)</span> 上挂了长度为 <span class=\"math inline\">\\(l\\)</span> 的半条链，共有 <span class=\"math inline\">\\(i\\)</span> 条整链的最大收益。</p>\n<p>可以观察到是凸的。那么不难发现需要闵可夫斯基和，考虑 <span class=\"math inline\">\\(u\\)</span> 位置上的合并。<strong>首先需要注意到儿子上长度为 <span class=\"math inline\">\\(l\\)</span> 的链到父亲上会变成 <span class=\"math inline\">\\(l+1\\)</span></strong>。显然每条可以不选；如果选了 <span class=\"math inline\">\\(cnt_a\\)</span> 条长度为 <span class=\"math inline\">\\(a\\)</span> 的半链，那么合并出来的结果是 <span class=\"math inline\">\\(cnt_1-cnt_3\\)</span> 条长度为 <span class=\"math inline\">\\(1\\)</span> 或 <span class=\"math inline\">\\(3\\)</span> 的链、<span class=\"math inline\">\\(cnt_2\\bmod 2\\)</span> 条长度为 <span class=\"math inline\">\\(2\\)</span> 的链，并且要求两者不同时出现。发现这个东西基本上处理不了。</p>\n<p>接着注意到这个形式有点像背包。但怎么处理 <span class=\"math inline\">\\(cnt_1\\)</span> 和 <span class=\"math inline\">\\(cnt_3\\)</span> 配对的这个要求呢？有个非常精妙的在物品体积上做文章的方法：</p>\n<p>首先注意到我们最后的查询的答案肯定要求把所有儿子用完。那么不妨设体积之和为儿子总数 <span class=\"math inline\">\\(tot\\)</span>。接着，对 <span class=\"math inline\">\\(cnt_0\\)</span>（同时也是 <span class=\"math inline\">\\(cnt_4\\)</span>）没有限制，直接令其体积为 <span class=\"math inline\">\\(1\\)</span>。<span class=\"math inline\">\\(cnt_2\\)</span> 单独处理（等会儿会说），为了不对现在的问题产生影响也令其体积为 <span class=\"math inline\">\\(1\\)</span>。对于 <span class=\"math inline\">\\(cnt_1\\)</span> 和 <span class=\"math inline\">\\(cnt_3\\)</span>，显然两者平均体积需要为 <span class=\"math inline\">\\(1\\)</span>；你可以令 <span class=\"math inline\">\\(cnt_3\\)</span> 体积为 <span class=\"math inline\">\\(2\\)</span>，令 <span class=\"math inline\">\\(cnt_1\\)</span> 体积为 <span class=\"math inline\">\\(0\\)</span>。</p>\n<p>接下来就有个很好的性质：<span class=\"math inline\">\\(cnt_1\\)</span> 必须和 <span class=\"math inline\">\\(cnt_3\\)</span> 配对才能让平均体积为 <span class=\"math inline\">\\(1\\)</span>。在 <span class=\"math inline\">\\(tot\\)</span> 处查找的答案，由 <span class=\"math inline\">\\(x\\)</span> 个体积不为 <span class=\"math inline\">\\(0\\)</span> 的物品和 <span class=\"math inline\">\\(tot-x\\)</span> 个体积为 <span class=\"math inline\">\\(0\\)</span> 的物品（<span class=\"math inline\">\\(cnt_1\\)</span>）组成，原因是背包会贪心地在所有『剩余』的分组中选择体积为 <span class=\"math inline\">\\(0\\)</span> 的一项。再计算一下 <span class=\"math inline\">\\(cnt_3\\)</span>，发现显然为 <span class=\"math inline\">\\(tot-x\\)</span>。符合目的。</p>\n<p>在 <span class=\"math inline\">\\(dp_{tot}\\)</span> 处查找可以找到 <span class=\"math inline\">\\(cnt_1=cnt_3\\)</span> 时的答案；同理，在 <span class=\"math inline\">\\(dp_{tot-1},dp_{tot1+1}\\)</span> 处可以查找到 <span class=\"math inline\">\\(cnt_1=cnt_3\\pm 1\\)</span> 的答案。</p>\n<p>接下来再考虑 <span class=\"math inline\">\\(cnt_2\\)</span>，解决『<span class=\"math inline\">\\(cnt\\bmod2=1\\)</span> 和 <span class=\"math inline\">\\(cnt_1\\ne cnt_3\\)</span> 不能同时成立』的限制。那太好了，直接多开一维记录 <span class=\"math inline\">\\(cnt_2\\bmod 2\\)</span> 即可。</p>\n<p>啊啊太妙了。像利用体积为 <span class=\"math inline\">\\(-1,1\\)</span> 的随机数据背包期望最大体积不超过 <span class=\"math inline\">\\(\\sqrt V\\)</span> 的那个方法，显然就没有办法利用凸性了。所以这或许是闵可夫斯基和做法的唯一解？</p>\n<p>需要知道，如果设 <span class=\"math inline\">\\(cnt_1\\)</span> 为 <span class=\"math inline\">\\(2\\)</span> 而 <span class=\"math inline\">\\(cnt_3\\)</span> 为 <span class=\"math inline\">\\(0\\)</span>，始终会出一些问题。这个我和 yly 讨论了一下没啥结果。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst long long inf = 1e12;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;1.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; g(n + 1);\n    for (int i = 1, x, y, w; i &lt; n; ++i) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y &gt;&gt; w;\n        g[x].emplace_back(y, w), g[y].emplace_back(x, w);\n    &#125;\n    using arr = std::vector&lt;long long&gt;;\n    std::vector&lt;arr&gt; f(n + 1, arr(4));\n    struct node &#123;\n        std::vector&lt;arr&gt; f;\n        node(): f(2) &#123;&#125;\n        node(std::vector&lt;arr&gt; f1): f(f1) &#123;&#125;\n        arr&amp; operator[](int q) &#123;\n            return f[q];\n        &#125;\n    &#125;;\n    auto getmax = [&amp;](arr p, arr q) &#123;\n        arr res(p);\n        if (q.size() &gt; p.size())\n            res.resize(q.size());\n        for (int i = 0; i &lt; (int)q.size(); ++i)\n            res[i] = std::max(res[i], q[i]);\n        return res;\n    &#125;;\n    auto merge = [&amp;](arr &amp;p, arr &amp;q) &#123;\n        arr res(p.size() + q.size() - 1), dp(p.size()), dq(q.size());\n        std::adjacent_difference(p.begin(), p.end(), dp.begin());\n        std::adjacent_difference(q.begin(), q.end(), dq.begin());\n        std::merge(dp.begin() + 1, dp.end(), dq.begin() + 1, dq.end(), res.begin() + 1, std::greater&lt;long long&gt; ());\n        res[0] = p[0] + q[0];\n        std::partial_sum(res.begin(), res.end(), res.begin());\n        return res;\n    &#125;; \n    std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int fa) &#123;\n        if ((int)g[x].size() == 1 &amp;&amp; x != 1) &#123;\n            f[x][1] = f[x][2] = f[x][3] = -inf;\n            return;\n        &#125;\n        int tot = (int)g[x].size() - (x != 1);\n        std::vector&lt;arr&gt; w1(1), w2(1);\n        for (auto [i, w] : g[x])\n            if (i != fa) &#123;\n                DFS(i, x);\n                w1.push_back(&#123; f[i][0] + w, std::max(f[i][0], f[i][3] + w), f[i][2] + w &#125;);\n                w2.push_back(&#123; -inf, f[i][1] + w &#125;);\n            &#125;\n        auto fun = [&amp;](arr &amp;p, arr &amp;q) &#123;\n            arr res(p.size() + q.size() - 1, -inf);\n            for (int ip = 0; ip &lt; 2; ++ip)\n                for (int iq = 0; iq &lt; 2; ++iq) &#123;\n                    arr tp, tq;\n                    for (int i = ip; i &lt; (int)p.size(); i += 2)\n                        tp.push_back(p[i]);\n                    for (int i = iq; i &lt; (int)q.size(); i += 2)\n                        tq.push_back(q[i]);\n                    auto t = merge(tp, tq);\n                    for (int i = 0; i &lt; (int)t.size(); ++i)\n                        if (i * 2 + ip + iq &lt; (int)res.size())\n                            res[i * 2 + ip + iq] = std::max(res[i * 2 + ip + iq], t[i]);\n                &#125;\n            return res;\n        &#125;; \n        std::function&lt;node(int, int)&gt; calc = [&amp;](int l, int r) &#123;\n            if (l == r)\n                return node(&#123; w1[l], w2[l] &#125;);\n            int mid = (l + r) &gt;&gt; 1;\n            node t1(calc(l, mid)), t2(calc(mid + 1, r));\n            return node(&#123; getmax(fun(t1[0], t2[0]), fun(t1[1], t2[1])),\n                          getmax(fun(t1[0], t2[1]), fun(t1[1], t2[0])) &#125;);\n        &#125;;\n        auto t(calc(1, tot));\n        f[x][0] = t[0][tot], f[x][1] = t[0][tot - 1], f[x][2] = t[1][tot], f[x][3] = t[0][tot + 1];\n        return;\n    &#125;;\n    DFS(1, -1);\n    std::cout &lt;&lt; f[1][0] &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n",
            "tags": [
                "DP",
                "DP 优化"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20250707-1/",
            "url": "https://xsc062.netlify.app/20250707-1/",
            "title": "决策单调性",
            "date_published": "2025-07-07T13:23:01.000Z",
            "content_html": "<p>等和线：在线段 <span class=\"math inline\">\\(AB\\)</span> 上取一点 <span class=\"math inline\">\\(M\\)</span>，使得 <span class=\"math inline\">\\(\\vec{AB}=\\lambda \\vec{AM}\\)</span>。在 <span class=\"math inline\">\\(AB\\)</span> 上方任取一点 <span class=\"math inline\">\\(P\\)</span>，则有 <span class=\"math inline\">\\(\\vec{PM}=(1-\\lambda) \\vec{PA}+\\lambda \\vec{PB}\\)</span>。</p>\n<span id=\"more\"></span>\n<hr />\n<h2 id=\"什么是-xdyd-dp\">什么是 xD/yD DP</h2>\n<p>即 DP 数组共有 <span class=\"math inline\">\\(x\\)</span> 维，一次转移复杂度为 <span class=\"math inline\">\\(O(n^y)\\)</span>。</p>\n<p><del>为什么要给一句话单开一个标题</del></p>\n<p>下面设通式 <span class=\"math inline\">\\(f_i=\\max\\left\\{f_j+w(i,j)\\right\\}\\)</span>。</p>\n<hr />\n<h2 id=\"单调队列优化-dp\">单调队列优化 DP</h2>\n<p><span class=\"math inline\">\\(w(i,j)\\)</span> 仅包含 <span class=\"math inline\">\\(i,j\\)</span> 的最高一次项。</p>\n<ul>\n<li>如果要求 <span class=\"math inline\">\\(j\\in [1,i]\\)</span>，前缀最小值即可。</li>\n<li>若 <span class=\"math inline\">\\(j\\)</span> 的取值范围在到处乱动，可以写 DS =_=</li>\n<li><p>若 <span class=\"math inline\">\\(j\\)</span> 的取值范围 <span class=\"math inline\">\\([l,r]\\)</span> 随着 <span class=\"math inline\">\\(i\\)</span> 增大而 <span class=\"math inline\">\\(l,r\\)</span> 都不减小，那么可以使用单调队列。</p>\n<p>顺带一提，和这种的单调队列用法相似的『单调栈』主要在斜优里出现。</p></li>\n</ul>\n<p>具体过程被 grizzly bear 吃掉了 <img src=\"/em/eat.gif\" /></p>\n<h3 id=\"例单调队列优化多重背包\">例：单调队列优化多重背包</h3>\n<p>朴素的多重背包式子是 <span class=\"math inline\">\\(f_{i,j}=\\max\\left\\{f_{i-1,j-k\\times v_i}+k\\times w_i\\right\\}\\)</span>，因为 <span class=\"math inline\">\\(i\\)</span> 和整个式子无关，所以是关于 <span class=\"math inline\">\\(j\\)</span> 的 1D/1D。</p>\n<p>为了套用单调队列，需要把查询的项变成连续的。发现 <span class=\"math inline\">\\(j-k\\times v_i\\)</span> 和 <span class=\"math inline\">\\(j\\)</span> 关于 <span class=\"math inline\">\\(v_i\\)</span> 同余；且随着 <span class=\"math inline\">\\(k\\)</span> 的增大，查询的位置不断移动 <span class=\"math inline\">\\(v_i\\)</span>。那么不妨把所有 <span class=\"math inline\">\\(j\\)</span> 按照模 <span class=\"math inline\">\\(v_i\\)</span> 的余数分开做。具体地，不妨设 <span class=\"math inline\">\\(j=a\\times v_i+b\\)</span>，将 <span class=\"math inline\">\\(j-k\\times v_i\\)</span> 替换为余数写法，那么有：</p>\n<p><span class=\"math display\">\\[\n\\begin{aligned}\nf_{i,j}&amp;=\\max\\{f_{i-1,x\\times v_i+b}+(a-x)\\times v_i\\}\\\\\n&amp;=\\max\\{f_{i-1,x\\times v_i+b}-x\\times v_i\\}+a\\times v_i\n\\end{aligned}\n\\]</span></p>\n<p>限制 <span class=\"math inline\">\\((a-x)\\)</span> 的取值不超过物品数，在不同模数下按 <span class=\"math inline\">\\(x\\)</span> 从小到大将 <span class=\"math inline\">\\(j\\)</span> 这一维进行单调队列优化即可。容易发现会不重不漏枚举所有体积；复杂度 <span class=\"math inline\">\\(O(nV)\\)</span>。</p>\n<hr />\n<h2 id=\"斜率优化-dp\">斜率优化 DP</h2>\n<p>若 <span class=\"math inline\">\\(w(i,j)\\)</span> 种含有 <span class=\"math inline\">\\(i,j\\)</span> 的交叉项，可以考虑斜优。</p>\n<p>具体过程，（如果你愿意），可以看这篇 <a href=\"/20210214/\">四年半前的博客</a>。</p>\n<p>关于符号等问题，分享一下我的做法：</p>\n<ul>\n<li><p>单调队列维护：适用于符号和右侧斜率要求单调性相反的情况。</p>\n<ul>\n<li>首先，讨论队头维护。不妨假设 <span class=\"math inline\">\\(a\\)</span> 为队头第二个元素，<span class=\"math inline\">\\(b\\)</span> 为队头第一个元素。</li>\n<li>如果队头 <span class=\"math inline\">\\(b\\)</span> 需要被弹出，说明 <span class=\"math inline\">\\(a\\)</span> 优于 <span class=\"math inline\">\\(b\\)</span>；假设式子要求 max，则用 <span class=\"math inline\">\\(a\\)</span> 转移得到的答案 &gt; 用 <span class=\"math inline\">\\(b\\)</span> 转移得到的答案。</li>\n<li>化式子，注意 <span class=\"math inline\">\\(a&gt;b\\)</span>；且负数乘除要变号。</li>\n<li><p>最后得到的式子中间的不等号就决定了需要维护的斜率单调情况。以此决定队尾维护方式即可。</p>\n<strong>注意这个式子的不等号体现的是弹出条件；保留条件和其相反</strong> <img src=\"/em/ll.gif\" /></li>\n</ul></li>\n<li><p>单调栈维护：适用于符号和右侧斜率要求单调性相同的情况；需要清楚，维护合法性、维护单调和取答案都在栈顶进行。</p>\n<ul>\n<li>首先，都知道要用单调栈了，说明斜优形式已经被化出来了；以此维护合法性即可。</li>\n<li>维护一个从底到顶，『优』得越来越小的斜率序列。找到从更优到更劣的临界点，更新答案。</li>\n</ul></li>\n</ul>\n<p>啊，果然高中文化学科是非常有用的。算是明白为什么我小学 / 初中基本没弄懂过斜优，而旁边的大佬已经在乱杀了 <img src=\"/em/hsh.gif\" /></p>\n<hr />\n<p>现在假设正在维护一个上凸包，可以进行一些思考：</p>\n<ul>\n<li><p>如果查询区间不单增？</p>\n搞不了啊这个。废了。</li>\n<li><p>查询的斜率不单增？</p>\n写个二分 + 单调栈。参见 <a href=\"https://www.luogu.com.cn/problem/P5785\">任务安排</a>、<a href=\"#例traka\">TRAKA</a>。</li>\n<li><p>加入斜率的位置不单增？</p>\n<p>李超 / CDQ / 平衡树。</p></li>\n</ul>\n<hr />\n<h2 id=\"四边形不等式优化-dp\">四边形不等式优化 DP</h2>\n<h3 id=\"关于四边形不等式\">关于四边形不等式</h3>\n<p>对于代价矩阵 <span class=\"math inline\">\\(w\\)</span> 和定义域内 <span class=\"math inline\">\\(\\forall\\,a\\le b\\le c\\le d\\)</span>，若 <span class=\"math inline\">\\(w(a,d)+w(b,c)\\ge w(a,c)+w(b,d)\\)</span>，认为 <span class=\"math inline\">\\(w\\)</span> 满足四边形不等式。简记为重叠大于交叉。</p>\n<p>命名来源是四边形对角线之和大于对边之和；将恒大于改为恒小于也能得到相似的性质。</p>\n<p>就会发现单调队列优化和斜优其实是四边形不等式的特化，导致它们可以少一个 log。</p>\n<hr />\n<h3 id=\"性质\">性质</h3>\n<p>用于证明：</p>\n<ul>\n<li>对于任意 <span class=\"math inline\">\\(c\\le l\\le r\\)</span>，若 <span class=\"math inline\">\\(w(l-c,r+c) + w(l,r)\\le w(l-c,r)+ w(l,r+c)\\)</span>，则 <span class=\"math inline\">\\(w\\)</span> 满足四边形不等式。</li>\n</ul>\n<p>用于题目：</p>\n<ul>\n<li><strong>性质一</strong>：若 <span class=\"math inline\">\\(f_i\\)</span> 满足四边形不等式（或其反式），那么最优决策点 <span class=\"math inline\">\\(p_i\\)</span> 与 <span class=\"math inline\">\\(i\\)</span> 有单调关系。</li>\n<li><strong>性质二</strong>：当 <span class=\"math inline\">\\(i\\)</span> 变化时，每个 <span class=\"math inline\">\\(j\\)</span> 带来贡献的相对大小 rank 不变。亦作：若 <span class=\"math inline\">\\(j_1\\)</span> 相对于 <span class=\"math inline\">\\(j_2\\)</span> 对 <span class=\"math inline\">\\(i\\)</span> 更优，对于任意 <span class=\"math inline\">\\(i&#39;\\)</span>，<span class=\"math inline\">\\(j_1\\)</span> 相对于 <span class=\"math inline\">\\(j_2\\)</span> 对 <span class=\"math inline\">\\(i&#39;\\)</span> 更优。</li>\n</ul>\n<hr />\n<h3 id=\"在优化-dp-之前\">在优化 DP 之前</h3>\n<ul>\n<li><p>首先我必须要提一嘴。由于我第一次接触『四边形不等式』是在四年前，看到『石子合并的 <span class=\"math inline\">\\(n^2\\)</span> 做法』时。然而，这一题的 DP 本身有一个特殊性质，即贡献是一个以决策点为极值的凸函数；这直接导致我误以为这是四边形不等式本身带来的性质，导致我在理解上浪费了很多时间。<strong>四边形不等式带来的性质，只有上述两条！</strong></p>\n当然这也告诉我们，如果你发现『贡献是一个以决策点为极值的凸函数』，你就可以用类似石子合并中的线性转移完成问题。</li>\n<li><p>『满足四边形不等式』并不能等价于『决策单调性』。决策单调性并不具备性质二。</p>\n<p>也就是说，如果只满足决策单调性，只有最优决策点是单调的，但贡献函数随着 <span class=\"math inline\">\\(i\\)</span> 的变化，其形状会有很大的变动。</p></li>\n</ul>\n<hr />\n<h3 id=\"优化-dp分治\">优化 DP：分治</h3>\n<p>主要适用于 <span class=\"math inline\">\\(f_{i}=g_j+w(j,i)\\)</span> 的场景，其中 <span class=\"math inline\">\\(g\\)</span> 是与 <span class=\"math inline\">\\(f\\)</span> 无关的函数。</p>\n<p>对于分治范围 <span class=\"math inline\">\\([l,r]\\)</span> 和其决策点范围 <span class=\"math inline\">\\([L_p,R_p]\\)</span>，首先把暴力 <span class=\"math inline\">\\(mid\\)</span> 的决策点 <span class=\"math inline\">\\(p_{mid}\\)</span> 找出来。</p>\n<p>接着对于 <span class=\"math inline\">\\([l,mid)\\)</span> 和 <span class=\"math inline\">\\((mid,R]\\)</span>，分别在 <span class=\"math inline\">\\([L_p,p_{mid}]\\)</span> 和 <span class=\"math inline\">\\([p_{mid},R_p]\\)</span> 里找决策点（注意两边都是闭的）。递归地做。</p>\n<p>这时候你肯定就会怀疑了，主播主播，虽然你的区间每次在减半，但决策点范围并不是均分的，还会被共用，复杂度真的对吗？</p>\n<p>对的兄弟，对的。观察搜索树，你会发现虽然 <span class=\"math inline\">\\(p_{mid}\\)</span> 会被给两个儿子共用，但是在任何一层中，被重复经过的点只会出现在两个区间的交界处。也就是说每整层大概遍历 <span class=\"math inline\">\\(2n\\)</span> 次。是不是很对了。</p>\n<hr />\n<h4 id=\"例yet-another-minimization-problem\">例：Yet Another Minimization Problem</h4>\n<p><a href=\"https://codeforces.com/problemset/problem/868/F\" class=\"uri\">https://codeforces.com/problemset/problem/868/F</a></p>\n<details>\n<p><summary>我的天哪！是罕见的四级标题！</summary></p>\n<p>笑点解析：这个人因为懒得写 CSS 所以只写了经常用的 h2 和 h3 的样式，现在迫不得已用 h4 被倒逼去写了 h4 的 CSS。</p>\n</details>\n<p>发现 <span class=\"math inline\">\\(k\\le 20\\)</span>，所以可以不用写 WQS 二分。令 <span class=\"math inline\">\\(f_{i,j}\\)</span> 表示第 <span class=\"math inline\">\\(i\\)</span> 段分在 <span class=\"math inline\">\\(j\\)</span> 处的代价，那么有 <span class=\"math inline\">\\(f_{i,j}=\\min\\{f_{i-1,l}+w(l+1,j)\\}\\)</span>，分治解决。</p>\n<p>接着发现问题：<span class=\"math inline\">\\(w(l+1,j)\\)</span> 并不能很快地求出来；然后注意到这个代价的形式很莫队（其实在看到这个题的时候就会有莫队的想法），考虑使用莫队移动端点的方式解决问题。由于分治中查询的区间两端单增，每层的总移动次数是 <span class=\"math inline\">\\(O(n)\\)</span> 的，总复杂度就是 <span class=\"math inline\">\\(O(nk\\log n)\\)</span> 的。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst long long inf = 1e12;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, k;\n    std::cin &gt;&gt; n &gt;&gt; k;\n    std::vector&lt;int&gt; a(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i];\n    std::vector&lt;long long&gt; cnt(n + 1);\n    std::vector&lt;std::vector&lt;int&gt; &gt; p(k + 1, std::vector&lt;int&gt; (n + 1));\n    std::vector&lt;std::vector&lt;long long&gt; &gt; f(k + 1, std::vector&lt;long long&gt; (n + 1, inf));\n    auto w = [&amp;](int l, int r) &#123;\n        static int L = 1, R = 0;\n        static long long res = 0ll;\n        for (; L &gt; l; --L, res -= cnt[a[L]] * (cnt[a[L]] - 1) / 2, ++cnt[a[L]], res += cnt[a[L]] * (cnt[a[L]] - 1) / 2);\n        for (; R &gt; r; res -= cnt[a[R]] * (cnt[a[R]] - 1) / 2, --cnt[a[R]], res += cnt[a[R]] * (cnt[a[R]] - 1) / 2, --R);\n        for (; R &lt; r; ++R, res -= cnt[a[R]] * (cnt[a[R]] - 1) / 2, ++cnt[a[R]], res += cnt[a[R]] * (cnt[a[R]] - 1) / 2);\n        for (; L &lt; l; res -= cnt[a[L]] * (cnt[a[L]] - 1) / 2, --cnt[a[L]], res += cnt[a[L]] * (cnt[a[L]] - 1) / 2, ++L);\n        return res;\n    &#125;;\n    f[0][0] = 0ll;\n    for (int t = 1; t &lt;= k; ++t) &#123;\n        std::function&lt;void(int, int, int, int)&gt; calc = [&amp;](int l, int r, int lp, int rp) &#123;\n            if (l &gt; r)\n                return;\n            if (l == r) &#123;\n                for (int i = lp; i &lt;= rp &amp;&amp; i &lt; l; ++i)\n                    if (f[t - 1][i] + w(i + 1, l) &lt; f[t][l])\n                        f[t][l] = f[t - 1][i] + w(i + 1, l), p[t][l] = i;\n                return;\n            &#125;\n            int mid = (l + r) &gt;&gt; 1;\n            for (int i = lp; i &lt;= rp &amp;&amp; i &lt; mid; ++i)\n                if (f[t - 1][i] + w(i + 1, mid) &lt; f[t][mid])\n                    f[t][mid] = f[t - 1][i] + w(i + 1, mid), p[t][mid] = i;\n            calc(l, mid - 1, lp, p[t][mid]), calc(mid + 1, r, p[t][mid], rp);\n            return;\n        &#125;;\n        calc(1, n, 0, n - 1);\n    &#125;\n    std::cout &lt;&lt; f[k][n] &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"优化-dp单调数据结构\">优化 DP：单调数据结构</h3>\n<p>有的时候会出现 <span class=\"math inline\">\\(f_{i}=f_{j}+w(j,i)\\)</span> 的结构，也就是 <span class=\"math inline\">\\(f\\)</span> 的取值与自己有关。</p>\n<p>这种情况我们通常选择填表法，求出 <span class=\"math inline\">\\(f_i\\)</span> 后找到 <span class=\"math inline\">\\(i\\)</span> 是哪些点的最优决策（那么显然这些点是一段连续区间）。用 <span class=\"math inline\">\\((i,l_i,r_i)\\)</span> 这个三元组表示当前算出来的 <span class=\"math inline\">\\(i\\)</span> 管辖的范围。</p>\n<p>这是什么意思呢？结合性质二，每当我们手上拿到一个新的 <span class=\"math inline\">\\(i\\)</span>，那么推出来其管辖范围右端点就会是 <span class=\"math inline\">\\(n\\)</span>。接着想办法找到左端点，同样利用性质二，二分出最靠左的一个 <span class=\"math inline\">\\(j\\)</span>，满足之前算出来的决策点没有 <span class=\"math inline\">\\(i\\)</span> 优，那么 <span class=\"math inline\">\\([j,n]\\)</span> 就是当前条件下 <span class=\"math inline\">\\(i\\)</span> 的管辖范围。</p>\n<p>在队列里加入当前版本的整个三元组序列就可以方便地完成这个过程。为寻找当前元素的答案，需要将队头上，管辖范围完全早于当前元素的弹出去。由于维护的过程和单调队列很像，所以也有人直接把这里的队列叫单调队列。</p>\n<p>视题目不同，也可能用到单调栈，也有可能不用二分（例如满足前两种特化的情况）。goto <a href=\"/20250715/#a---yakiniku-restaurants\">Yakiniku Restaurants</a>。</p>\n<hr />\n<h4 id=\"例诗人小g\">例：诗人小G</h4>\n<p><a href=\"https://www.luogu.com.cn/problem/P1912\" class=\"uri\">https://www.luogu.com.cn/problem/P1912</a></p>\n<p><del>我觉得给出字符串内容的唯一价值是让出题人欣赏白日依山尽</del></p>\n<p>令 <span class=\"math inline\">\\(f_{j}\\)</span> 为某一行分在第 <span class=\"math inline\">\\(j\\)</span> 句处的代价，那么有 <span class=\"math inline\">\\(f_{j}=\\min\\limits_{k&lt;j}\\left\\{f_{k}+|(s_j-s_k+j-k-1)-L|^P\\right\\}\\)</span>。</p>\n<p>那么就可以考虑单调队列 + 二分了。需要注意无穷大之间的大小比较，我写这个写红温了，直接用指数项相对大小来代替了，似乎可以过。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst long long inf = 1000000000000000001ll;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;P1912_2.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int T;\n    for (std::cin &gt;&gt; T; T--; ) &#123;\n        int n, l, p;\n        std::cin &gt;&gt; n &gt;&gt; l &gt;&gt; p;\n        long long to;\n        switch (p) &#123; // 会有精度问题\n        case 1:\n            to = 1e18;\n            break;\n        case 2:\n            to = 1e9;\n            break;\n        case 3:\n            to = 1e6;\n            break;\n        case 4:\n            to = 31622;\n            break;\n        case 5:\n            to = 3981;\n            break;\n        case 6:\n            to = 1e3;\n            break;\n        case 7:\n            to = 372;\n            break;\n        case 8:\n            to = 177;\n            break;\n        case 9:\n            to = 100;\n            break;\n        default:\n            to = 63;\n            break;\n        &#125;\n        std::vector&lt;int&gt; s(n + 1);\n        std::vector&lt;std::string&gt; a(n + 1);\n        for (int i = 1; i &lt;= n; ++i)\n            std::cin &gt;&gt; a[i], s[i] = (int)a[i].length();\n        std::partial_sum(s.begin() + 1, s.end(), s.begin() + 1);\n        struct node &#123; int i, l, r; &#125;;\n        std::vector&lt;node&gt; q(n + 1);\n        int h = 0, t = -1;\n        q[++t] = &#123; 0, 1, n &#125;;\n        auto qkp = [&amp;](long long x, int y) &#123;\n            if (x &gt; to)\n                return inf;\n            auto res(1ll);\n            for (; y--; res *= x);\n            return res;\n        &#125;;\n        std::vector&lt;int&gt; pre(n + 1);\n        std::vector&lt;long long&gt; f(n + 1);\n        auto calc = [&amp;](int k, int j) &#123;\n            return std::min(inf, f[k] + qkp(std::abs(s[j] - s[k] + j - k - 1 - l), p));\n        &#125;;\n        auto less = [&amp;](int k1, int j1, int k2, int j2) &#123;\n            auto t1(calc(k1, j1)), t2(calc(k2, j2));\n            if (t1 == inf &amp;&amp; t2 == inf)\n                return std::abs(s[j1] - s[k1] + j1 - k1 - 1 - l) &lt; std::abs(s[j2] - s[k2] + j2 - k2 - 1 - l);\n            return t1 &lt; t2;\n        &#125;;\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            for (; h &lt;= t &amp;&amp; q[h].r &lt; i; ++h);\n            f[i] = calc(q[h].i, i), pre[i] = q[h].i;\n            for (; h &lt;= t &amp;&amp; q[t].l &gt; i &amp;&amp; less(i, q[t].l, q[t].i, q[t].l); --t)\n                q[t - 1].r = q[t].r;\n            for (int l = std::max(q[t].l, i + 1), r = q[t].r, mid; l &lt;= r; ) &#123;\n                mid = (l + r) &gt;&gt; 1;\n                if (less(i, mid, q[t].i, mid))\n                    r = q[t].r = mid - 1, q[t + 1] = &#123; i, mid, n &#125;;\n                else\n                    l = mid + 1;\n            &#125;\n            if (q[t + 1].i == i)\n                ++t;\n        &#125;\n        if (f[n] &gt;= inf)\n            std::cout &lt;&lt; &quot;Too hard to arrange&quot; &lt;&lt; &#39;\\n&#39;;\n        else &#123;\n            std::cout &lt;&lt; f[n] &lt;&lt; &#39;\\n&#39;;\n            std::function&lt;void(int)&gt; print = [&amp;](int x) &#123;\n                if (x == 0)\n                    return;\n                print(pre[x]);\n                for (int i = pre[x] + 1; i &lt;= x; ++i) &#123;\n                    std::cout &lt;&lt; a[i];\n                    if (i != x)\n                        std::cout &lt;&lt; &#39; &#39;;\n                &#125;\n                std::cout &lt;&lt; &#39;\\n&#39;;\n                return;\n            &#125;;\n            print(n);\n        &#125;\n        std::cout &lt;&lt; &quot;--------------------&quot;;\n        if (T)\n            std::cout &lt;&lt; &#39;\\n&#39;;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n<p>需要注意，本题也可以再加一个『恰好分 <span class=\"math inline\">\\(k\\)</span> 段』的限制，直接在外层套一个 WQS 二分就好了，参见 <a href=\"https://www.luogu.com.cn/problem/P6246\">邮局 加强版 加强版</a>。</p>\n<h3 id=\"d1d-dp-优化\">2D/1D DP 优化</h3>\n<p>若存在 <span class=\"math inline\">\\(f(i,j)=\\min\\limits_{k&lt;j} f(i-1,k)+w(k+1,j)\\)</span>，且 <span class=\"math inline\">\\(w\\)</span> 满足四边形不等式：</p>\n<ul>\n<li><p>设 <span class=\"math inline\">\\(p(i,j)\\)</span> 为最优决策点，那么有 <span class=\"math inline\">\\(p(i,j)\\le p(i,j+1)\\le p(i+1,j+1)\\)</span>，亦作 <span class=\"math inline\">\\(p(i,j-1)\\le p(i,j)\\le p(i+1,j)\\)</span>。</p>\n<p>此时可以 <span class=\"math inline\">\\(O(nm)\\)</span> 解决问题：</p>\n<p><img src=\"image.png\" /></p></li>\n<li><p>若 <span class=\"math inline\">\\(i\\)</span> 固定，<span class=\"math inline\">\\(f_i(j)\\)</span> 为凸函数。（例：邮局 加强版 加强版）</p>\n<p>goto <a href=\"/20250707/\">DP 凸优化</a>。</p></li>\n</ul>\n",
            "tags": [
                "DP",
                "DP 优化"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20250707/",
            "url": "https://xsc062.netlify.app/20250707/",
            "title": "DP 凸优化",
            "date_published": "2025-07-07T06:10:02.000Z",
            "content_html": "<p>袜，这篇文章一下子创建了三个新 tag。</p>\n<span id=\"more\"></span>\n<hr />\n<h2 id=\"什么是凸函数\">什么是凸函数</h2>\n<h3 id=\"定义\">定义</h3>\n<p>在信息学中研究的凸函数大抵是只在正整数域上有定义的，所以只能直接摒弃导函数的概念了。</p>\n<p>若斜率递增，换言之，差分数组递增，认为函数是凸的（好反直觉）。</p>\n<p>或者看看符号化的定义：若对于任意 <span class=\"math inline\">\\(\\lambda\\in[0,1]\\)</span>，函数 <span class=\"math inline\">\\(f(x)\\)</span> 均满足：</p>\n<p><span class=\"math display\">\\[\nf(\\lambda x+(1-\\lambda) y)\\le \\lambda f(x)+(1-\\lambda) f(y).\n\\]</span></p>\n<p>或等价地：</p>\n<p><span class=\"math display\">\\[\nf(x)-f(x - 1)\\le f(x + 1) - f(x)\n\\]</span></p>\n<p>那么认为 <span class=\"math inline\">\\(f\\)</span> 是凸函数。</p>\n<p>因为凹凸在性质上没区别，所以 <strong>下文施行暴政，将凹函数和凸函数统称为凸函数</strong>。</p>\n<hr />\n<h3 id=\"判定\">判定</h3>\n<p>对于具体情境下的问题，怎么判断 DP 数组是否关于其某一维为凸函数？</p>\n<ul>\n<li>相信相信的力量（最常用）。</li>\n<li><p>对于分段问题，证明分出来的每一段满足四边形不等式。</p>\n<em>值得一提的是，数学上不认为满足四边形不等式能够推出函数为凸。但这是信息学.jpg</em></li>\n<li><p>其由两个凸函数线性相加得到：</p>\n<p>对于 <span class=\"math inline\">\\(\\forall\\, \\lambda,\\mu\\ge 0\\)</span> 和凸函数 <span class=\"math inline\">\\(f,g\\)</span>，若 <span class=\"math inline\">\\(h=\\lambda f+\\mu g\\)</span>，则 <span class=\"math inline\">\\(h\\)</span> 为凸函数。</p>\n此外，此时 <span class=\"math inline\">\\(h\\)</span> 的差分数组和 <span class=\"math inline\">\\(f,g\\)</span> 差分数组也满足上述关系。</li>\n<li>其是两个凸函数的 <a href=\"#闵可夫斯基和\">闵可夫斯基和</a>。</li>\n<li><p>其由两个凸函数线性 max 得到。</p>\n<p>对于两个凸函数的线性 min，一般不是凸函数，甚至可能是凹的。</p></li>\n</ul>\n<hr />\n<h3 id=\"性质\">性质</h3>\n<ul>\n<li>最值为唯一极值。</li>\n<li>斜率 / 差分数组具有单调性。</li>\n</ul>\n<p>在解题中主要用到的大概就是上面两条。</p>\n<hr />\n<h2 id=\"wqs-二分\">WQS 二分</h2>\n<h3 id=\"主要任务\">主要任务</h3>\n<blockquote>\n<p>例：把 <span class=\"math inline\">\\(a_{1\\sim n}\\)</span> 分为恰好 <span class=\"math inline\">\\(k\\)</span> 段，每段的代价为 <span class=\"math inline\">\\(sum^2+c\\)</span>（<span class=\"math inline\">\\(c\\)</span> 为给定的常数），问最小代价。<span class=\"math inline\">\\(n\\le 2\\times 10^5,a_i\\le 10^9\\)</span>。</p>\n</blockquote>\n<p>如果对段数没有要求，可以用斜优 <span class=\"math inline\">\\(O(n)\\)</span> 做。</p>\n<p>加上了 <span class=\"math inline\">\\(k\\)</span> 的限制，DP 变成二维的，令 <span class=\"math inline\">\\(f_{i,j}\\)</span> 表示在 <span class=\"math inline\">\\(i\\)</span> 处分第 <span class=\"math inline\">\\(j\\)</span> 段，可以在第一维斜率优化，做到 <span class=\"math inline\">\\(O(nk)\\)</span>；亦或发现 <span class=\"math inline\">\\((i,j)\\)</span> 有决策单调性，然后四边形不等式优化到 <span class=\"math inline\">\\(O(n^2)\\)</span>。</p>\n<p>我们发现 <span class=\"math inline\">\\(f\\)</span> 关于 <span class=\"math inline\">\\(j\\)</span> 这一维是凸的（而非上文的 <span class=\"math inline\">\\((i,j)\\)</span>），故将 <span class=\"math inline\">\\(f(n,j)\\)</span> 关于 <span class=\"math inline\">\\(j\\)</span> 的函数提取出来（记为 <span class=\"math inline\">\\(f_n(j)\\)</span>）。发现只有最高点是可以一次斜优快速求出来的，故可以认为在当前复杂度限制下，整个函数除了最高点以外都是未知的（注意可以在 DP 时记录极值点的横坐标，即分了几段）。</p>\n<p>我们给每个 <span class=\"math inline\">\\(f_n(j)\\)</span> 加上 <span class=\"math inline\">\\(\\alpha\\cdot j\\)</span>（在本题中即将 <span class=\"math inline\">\\(c\\gets c+k\\)</span>），勉强可以认为 <span class=\"math inline\">\\(\\alpha\\cdot j\\)</span> 是凸的，所以新函数 <span class=\"math inline\">\\(f&#39;_n(j)\\)</span> 也是凸的。若 <span class=\"math inline\">\\(k&gt;0\\)</span>，可以感受到极值点向左偏移，且随着 <span class=\"math inline\">\\(k\\)</span> 的增大，极值点不会右移；<span class=\"math inline\">\\(k&lt;0\\)</span> 时同理。</p>\n<p>结合几何观点，在 <span class=\"math inline\">\\(f_n\\)</span> 上的极值点可以用斜率为 <span class=\"math inline\">\\(0\\)</span> 的直线切到；而加上 <span class=\"math inline\">\\(\\alpha\\cdot j\\)</span> 的过程，其实就是切线斜率减去 <span class=\"math inline\">\\(\\alpha\\)</span> 的过程。相当于令切线斜率为 <span class=\"math inline\">\\(-\\alpha\\)</span>，看看能切到哪里。</p>\n<p>故可以二分一个合适的 <span class=\"math inline\">\\(k\\)</span>，使得极值点的横坐标为 <span class=\"math inline\">\\(k\\)</span>。此时 <span class=\"math inline\">\\(f&#39;_n(k)-\\alpha\\cdot k\\)</span> 即为待求。</p>\n<hr />\n<p>WQS 二分参与的问题一般以如下形式呈现：</p>\n<blockquote>\n<p>给定序列，将其恰好分为 <span class=\"math inline\">\\(k\\)</span> 段 / 恰好选 <span class=\"math inline\">\\(k\\)</span> 个，求最大 / 最小代价。</p>\n</blockquote>\n<p>题目要求最大 / 最小值一般能够反映函数的凹凸性，可以根据这一点来猜。</p>\n<hr />\n<h3 id=\"细节处理\">细节处理</h3>\n<p>考虑如下凸函数：</p>\n<p><img src=\"1.png\" /></p>\n<ul>\n<li>显然对于『凸出来』的点（即图中除了 <span class=\"math inline\">\\(E,H\\)</span> 以外的点），能切到的直线斜率为一个范围；而位于直线上的点（途中 <span class=\"math inline\">\\(E,H\\)</span>），能切到的直线斜率更是定死了。所以这要求你的二分精度需要略高一点。</li>\n<li><p>对于 <span class=\"math inline\">\\(E\\)</span>（或 <span class=\"math inline\">\\(H\\)</span>），不能找到只过它一点的切线。根据 DP 的写法，记录的横坐标可能是最小的 <span class=\"math inline\">\\(D\\)</span>，也可能是最大的 <span class=\"math inline\">\\(F\\)</span>，此时你可以：</p>\n<ul>\n<li>同时记录最小和最大的横坐标，看看 <span class=\"math inline\">\\(k\\)</span> 在不在中间。</li>\n<li><p>题目要求最大代价时，记录最大横坐标，二分到一个极值点 <span class=\"math inline\">\\(k&#39;\\ge k\\)</span> 时，显然 <span class=\"math inline\">\\(\\alpha&#39;\\ge \\alpha\\)</span>，用 <span class=\"math inline\">\\(f&#39;_n(k&#39;)-\\alpha&#39;\\cdot k\\)</span> 更新答案（是赋值而不是取最值）；求最小代价时同理。</p>\n<p>主要是需要记住斜率是 <span class=\"math inline\">\\(\\alpha\\)</span> 的相反数，<del>实在搞不清对应关系可以都试一试</del></p></li>\n</ul></li>\n</ul>\n<hr />\n<h3 id=\"例种树\">例：种树</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P1484\" class=\"uri\">https://www.luogu.com.cn/problem/P1484</a></p>\n<p>首先，函数是凸的——感性理解即可。</p>\n<p>接着，要求的是 <span class=\"math inline\">\\(\\le k\\)</span> 时的最值。分为两种情况：<span class=\"math inline\">\\(k\\)</span> 是否右于原函数极值点。</p>\n<ul>\n<li>若 <span class=\"math inline\">\\(k\\)</span> 右于原函数极值点，则原函数极值点为答案。</li>\n<li>否则，<span class=\"math inline\">\\(k\\)</span> 为答案。</li>\n</ul>\n<p>好消息是整数域上一定有解（最后答案为整、倒推即可），所以不用打浮点数二分了。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int lim = 1e6;\nconst long long inf = 1e18;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, k;\n    std::cin &gt;&gt; n &gt;&gt; k;\n    std::vector&lt;long long&gt; a(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i];\n    auto calc = [&amp;](int c) &#123;\n        std::vector&lt;std::pair&lt;long long, int&gt; &gt; f(n + 1);\n        auto mx = f.front();\n        auto upd = [&amp;](auto &amp;x, auto y) &#123;\n            if (y.first &gt; x.first || (y.first == x.first &amp;&amp; y.second &lt; x.second))\n                x = y;\n            return;\n        &#125;;\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            f[i].first = mx.first + a[i] + c;\n            f[i].second = mx.second + 1;\n            upd(mx, f[i - 1]);\n        &#125;\n        upd(mx, f[n]);\n        return mx;\n    &#125;;\n    auto t(calc(0));\n    if (t.second &lt;= k) &#123;\n        std::cout &lt;&lt; t.first &lt;&lt; &#39;\\n&#39;;\n        return 0;\n    &#125;\n    auto res(-inf);\n    for (int l = -lim, r = lim, mid; l &lt;= r; ) &#123;\n        mid = (l + r) &gt;&gt; 1;\n        auto t = calc(mid);\n        if (t.second &lt;= k)\n            res = t.first - (long long)mid * k, l = mid + 1;\n        else\n            r = mid - 1;\n    &#125;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"例raper\">例：Raper</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P4694\" class=\"uri\">https://www.luogu.com.cn/problem/P4694</a></p>\n<p>给所有光盘附一个奖励 <span class=\"math inline\">\\(mid\\)</span>，进行 WQS 二分。</p>\n<p>然后内层就和 <a href=\"#例序列-sequence\">sequence</a> 差得不是特别多，所以考虑反悔贪心。（？）</p>\n<p>把路过的 <span class=\"math inline\">\\(-a_j\\)</span> 丢到大根堆里，尝试和 <span class=\"math inline\">\\(b_i\\)</span> 配对。如果 <span class=\"math inline\">\\(mid-a_i-b_i\\ge 0\\)</span> 那么暂时配对，顺便把 <span class=\"math inline\">\\(b_i-mid\\)</span> 丢进去用于反悔，若 <span class=\"math inline\">\\(b_{i&#39;}\\)</span> 选中了 <span class=\"math inline\">\\(b_i-mid\\)</span> 说明反悔，将 <span class=\"math inline\">\\(a_j\\)</span> 与 <span class=\"math inline\">\\(b_{i&#39;}\\)</span> 配对。</p>\n<p>贪心的时候需要记录已经配的对数，优先队列中需要对 <span class=\"math inline\">\\(-a_j\\)</span> 和 <span class=\"math inline\">\\(b_i-mid\\)</span> 打标记进行区分，匹配到前者时才增加成功对数。</p>\n<p>发现整数域上仍然必有解（答案为整，倒推），不用打浮点数二分 neiher.</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst long long inf = 2e9 + 5;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, k;\n    std::cin &gt;&gt; n &gt;&gt; k;\n    std::vector&lt;int&gt; a(n + 1), b(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i];\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; b[i];\n    auto calc = [&amp;](long long mid) &#123;\n        std::priority_queue&lt;std::pair&lt;long long, int&gt; &gt; q;\n        int cnt = 0;\n        auto res(0ll);\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            q.emplace(-a[i], 1);\n            auto [v, ty] = q.top();\n            if (mid + v - b[i] &gt;= 0) &#123;\n                q.pop(), cnt += ty;\n                res += mid + v - b[i], q.emplace(b[i] - mid, 0);\n            &#125;\n        &#125;\n        return std::make_pair(cnt, res);\n    &#125;;\n    auto res(inf);\n    for (long long l = 1ll, r = inf, mid; l &lt;= r; ) &#123;\n        mid = (l + r) &gt;&gt; 1;\n        auto t(calc(mid));\n        if (t.first &gt;= k)\n            r = mid - 1, res = -(t.second - k * mid);\n        else\n            l = mid + 1;\n    &#125;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"区间分拆问题\">区间分拆问题</h3>\n<p>目标：尝试将 <span class=\"math inline\">\\(a_{1\\sim n}\\)</span> 分割成恰好 <span class=\"math inline\">\\(k\\)</span> 段，定义 <span class=\"math inline\">\\(w(i,j)\\)</span> 为将 <span class=\"math inline\">\\([i,j]\\)</span> 作为一段的代价，求代价最值。其中 <span class=\"math inline\">\\(w(i,j)\\)</span> 满足四边形不等式。</p>\n<p>不妨设求最小代价。定义 <span class=\"math inline\">\\(f(i,j)\\)</span> 在 <span class=\"math inline\">\\(i\\)</span> 处分第 <span class=\"math inline\">\\(j\\)</span> 段，那么有：</p>\n<p><span class=\"math display\">\\[\nf(i,j)=\\min(f(i-1,p-1)+w(p,j)).\n\\]</span></p>\n<blockquote>\n<p>有定理：若 <span class=\"math inline\">\\(w(i,j)\\)</span> 满足四边形不等式，那么有 <span class=\"math inline\">\\(f(i-1,j)\\le f(i,j)\\le f(i,j+1)\\)</span>，从 <span class=\"math inline\">\\(f\\)</span> 定义出发很好感性理解。</p>\n</blockquote>\n<p>那么可以从这一点出发，<span class=\"math inline\">\\(p\\)</span> 这一维就可以被摊掉，做到 <span class=\"math inline\">\\(O(n(n+m))\\)</span>。</p>\n<blockquote>\n<p>有定理：若 <span class=\"math inline\">\\(w(i,j)\\)</span> 满足四边形不等式，那么 <span class=\"math inline\">\\(f_i(j)\\)</span> 是凸函数。</p>\n</blockquote>\n<p>那很好了。直接冲刺 WQS 即可。</p>\n<hr />\n<h2 id=\"闵可夫斯基和\">闵可夫斯基和</h2>\n<p>给定两个凸函数（当然是指 OI 中那种长得很直的函数），将它们的『边』拆下来过后，以某种方式拼在一起，使得最后得到一个新的凸函数。</p>\n<p>按每条『边』的斜率归并一下就可以得到，显然答案存在且唯一，这个过程被称为闵可夫斯基和。可以发现这是一种最值 - 加卷积。</p>\n<p>假设我们要求的 DP 数组是两个已知的子数组以类似的方法卷起来的，最后要求完整的 DP 数组（而非 WQS 中的单点值），就可以考虑闵可夫斯基和。</p>\n<p>发现这个结构是很适合归并的，使用归并要求状态中含有版本维、因变量维。</p>\n<hr />\n<h3 id=\"例its-mooin-time-p\">例：It's Mooin' Time P</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P11459\" class=\"uri\">https://www.luogu.com.cn/problem/P11459</a></p>\n<p>定义 <span class=\"math inline\">\\(w_i\\)</span> 为将 <span class=\"math inline\">\\([i,i+L)\\)</span> 改为 <code>MOO</code> 的代价，问题转化为选取 <span class=\"math inline\">\\(1\\sim \\frac nL\\)</span> 个不重区间的最小代价和。</p>\n<p>尝试归并，每次将 <span class=\"math inline\">\\([l,mid]\\)</span> 和 <span class=\"math inline\">\\((mid, r]\\)</span> 卷起来。但是会有一点问题：如果恰好有区间卡在中间呢？</p>\n<p>可以令 <span class=\"math inline\">\\(f_{l,r,0/1/2,0/1/2}(i)\\)</span> 表示在 <span class=\"math inline\">\\([l,r]\\)</span> 内选了 <span class=\"math inline\">\\(i\\)</span> 个 <code>MOO</code>，且两侧最远的被选点距离端点为 <span class=\"math inline\">\\(0/1/\\ge 2\\)</span> 的 DP 值。然后可以进行相应的讨论、平移、闵可夫斯基和，最后将所有情况线性取 max 得到这一层的答案，容易发现得到的答案也是凸的。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst long long inf = 1e18;\nint L;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    std::cin &gt;&gt; L &gt;&gt; n;\n    std::vector&lt;int&gt; a(n + 1);\n    std::vector&lt;char&gt; t(n + 1);\n    std::vector&lt;long long&gt; w(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; t[i];\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i];\n    for (int i = 1; i &lt;= n - L + 1; ++i) &#123;\n        w[i] = a[i] * (t[i] != &#39;M&#39;);\n        for (int j = i + 1; j &lt; i + L; ++j)\n            w[i] += a[j] * (t[j] != &#39;O&#39;);\n        // printf(&quot;[%d, %d]: %lld\\n&quot;, i, i + L - 1, w[i]);\n    &#125;\n    if (L == 1) &#123;\n        std::sort(w.begin() + 1, w.end());\n        auto s(0ll);\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            s += w[i];\n            std::cout &lt;&lt; s &lt;&lt; &#39;\\n&#39;;\n        &#125;\n        return 0;\n    &#125;\n    using arr = std::vector&lt;long long&gt;;\n    using brr = std::vector&lt;arr&gt;;\n    using crr = std::vector&lt;brr&gt;;\n    struct node &#123;\n        crr f;\n        node(int len): f(L, brr(L, arr(len, inf))) &#123;\n            for (int i = 0; i &lt; L; ++i)\n                for (int j = 0; j &lt; L; ++j)\n                    f[i][j][0] = 0ll;\n            return;\n        &#125;\n        brr&amp; operator[] (int q) &#123; return f[q]; &#125;\n    &#125;;\n    auto upd = [&amp;](arr &amp;x, arr y) &#123;\n        if (x.size() &lt; y.size())\n            x.resize(y.size(), inf);\n        for (int i = 0; i &lt; (int)y.size(); ++i)\n            x[i] = std::min(x[i], y[i]);\n        return;\n    &#125;;\n    auto merge = [&amp;](arr l, arr r) &#123;\n        arr out((int)(l.size() + r.size()) - 1), dl(l.size()), dr(r.size());\n        for (int i = 1; i &lt; (int)l.size(); ++i)\n            dl[i] = l[i] - l[i - 1];\n        for (int i = 1; i &lt; (int)r.size(); ++i)\n            dr[i] = r[i] - r[i - 1];\n        std::merge(dl.begin() + 1, dl.end(), dr.begin() + 1, dr.end(), out.begin() + 1);\n        out[0] = l[0] + r[0];\n        std::partial_sum(out.begin(), out.end(), out.begin());\n        return out;\n    &#125;;\n    std::function&lt;node(int, int)&gt; calc = [&amp;](int l, int r) &#123;\n        if (r - l + 1 &lt; 2 * L) &#123;\n            node res(1);\n            for (int ll = 0; ll &lt; L; ++ll)\n                for (int rr = 0; rr &lt; L; ++rr)\n                    if (l + ll &lt;= r - rr - L + 1) &#123;\n                        res[ll][rr].resize(2, inf);\n                        for (int i = l + ll; i &lt;= r - rr - L + 1; ++i)\n                            res[ll][rr][1] = std::min(res[ll][rr][1], w[i]);\n                        // printf(&quot;[%d, %d]: (%d, %d) = %lld\\n&quot;, l, r, ll, rr, res[ll][rr][1]);\n                    &#125;\n            // for (int i = 0; i &lt; L; ++i)\n            //     if (l + i + L - 1 &lt;= r) &#123;\n            //         printf(&quot;[%d, %d]: (%d, %d) = %lld\\n&quot;, l, r, i, r - (l + i + L - 1), w[l + i]);\n            //         res[i][r - (l + i + L - 1)].emplace_back(w[l + i]);\n            //     &#125;\n            return res;\n        &#125;   \n        int mid = (l + r) &gt;&gt; 1;\n        node tl(calc(l, mid)), tr(calc(mid + 1, r)), res((r - l + 1) / L + 1);\n        for (int ll = 0; ll &lt; L; ++ll)\n            for (int rr = 0; rr &lt; L; ++rr)\n                res[ll][rr] = merge(tl[ll][0], tr[0][rr]);\n        for (int ll = 0; ll &lt; L; ++ll)\n            for (int rr = 0; rr &lt; L; ++rr)\n                for (int i = 1; i &lt; L &amp;&amp; i &lt; mid; ++i)\n                    upd(res[ll][rr], merge(merge(tl[ll][i], tr[L - i][rr]), &#123; 0, w[mid - i + 1] &#125;));\n        for (int ll = 0; ll &lt; L; ++ll)\n            for (int rr = L - 1; rr; --rr)\n                upd(res[ll][rr - 1], res[ll][rr]);\n        for (int rr = 0; rr &lt; L; ++rr)\n            for (int ll = L - 1; ll; --ll)\n                upd(res[ll - 1][rr], res[ll][rr]);\n        // for (int i = 0; i &lt; L; ++i)\n        //     for (int j = 0; j &lt; L; ++j) &#123;\n        //         printf(&quot;  (%d, %d): &quot;, i, j);\n        //         for (auto p : res[i][j])\n        //             printf(&quot;%lld &quot;, p);\n        //         puts(&quot;&quot;);\n        //     &#125;\n        return res;\n    &#125;;\n    auto res(calc(1, n));\n    for (int i = 1; i &lt;= n / L; ++i)\n        std::cout &lt;&lt; res[0][0][i] &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"例假人\">例：假人</h3>\n<p><a href=\"http://222.180.160.110:61235/problem/47728\" class=\"uri\">http://222.180.160.110:61235/problem/47728</a></p>\n<p>令 <span class=\"math inline\">\\(f_{i,j}\\)</span> 表示前 <span class=\"math inline\">\\(i\\)</span> 组选完占了 <span class=\"math inline\">\\(j\\)</span> 体积的最大价值。那么有 <span class=\"math inline\">\\(f_{i,j}=\\max\\{f_{i-1,k}+a_{i,j-k}\\}\\)</span>。</p>\n<p><em>袜，这个东西好凸的样子！啊？居然不是凸的？</em></p>\n<p>事实上，有结论：若干个体积为 <span class=\"math inline\">\\(0\\sim 4\\)</span> 的物品做背包，可以凑出值域内任意 <span class=\"math inline\">\\(24\\)</span> 的倍数。所以先把体积全部 <span class=\"math inline\">\\(-1\\)</span>，然后就可以得到体积为 <span class=\"math inline\">\\(0\\sim 4\\)</span> 的物品。然后会发现他们按照模 <span class=\"math inline\">\\(12\\)</span> 的余数分别是凸的。</p>\n<p>能感受到恶意了。然后就可以枚举体积，再闵可夫斯基和了。同样需要在状态中引入作为版本号的 <span class=\"math inline\">\\([l,r]\\)</span> 维，显然因变量是体积、版本号是组数。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst long long inf = 1e18;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;fake2.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, m = 0;\n    std::cin &gt;&gt; n;\n    std::vector&lt;int&gt; siz(n + 1);\n    std::vector&lt;std::vector&lt;int&gt; &gt; a(n + 1);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; siz[i], m += siz[i];\n        a[i].resize(siz[i] + 1);\n        for (int j = 1; j &lt;= siz[i]; ++j)\n            std::cin &gt;&gt; a[i][j];\n    &#125;\n    using arr = std::vector&lt;long long&gt;;\n    struct node &#123;\n        std::vector&lt;arr&gt; f;\n        node(): f(12) &#123;&#125;\n        arr &amp;operator[] (int q) &#123;\n            return f[q];\n        &#125;\n    &#125;;\n    auto merge = [&amp;](arr &amp;p, arr &amp;q) &#123;\n        arr res((int)(p.size() + q.size()) - 1), dp(p.size()), dq(q.size());\n        std::adjacent_difference(p.begin(), p.end(), dp.begin());\n        std::adjacent_difference(q.begin(), q.end(), dq.begin());\n        std::merge(dp.begin() + 1, dp.end(), dq.begin() + 1, dq.end(), res.begin() + 1, std::greater&lt;long long&gt; ());\n        res[0] = p[0] + q[0];\n        std::partial_sum(res.begin(), res.end(), res.begin());\n        return res;\n    &#125;;\n    auto upd = [&amp;](arr y, arr &amp;x, int tag) &#123;\n        if (tag)\n            y.insert(y.begin(), -inf);\n        if (y.size() &gt; x.size())\n            x.resize(y.size(), -inf);\n        for (int i = 0; i &lt; (int)y.size(); ++i)\n            x[i] = std::max(x[i], y[i]);\n        return;\n    &#125;;\n    std::function&lt;node(int, int)&gt; calc = [&amp;](int l, int r) &#123;\n        if (l == r) &#123;\n            node res;\n            for (int i = 1; i &lt;= siz[l]; ++i)\n                res[i - 1].push_back(a[l][i]);\n            return res;\n        &#125;\n        int mid = (l + r) &gt;&gt; 1;\n        node tl(calc(l, mid)), tr(calc(mid + 1, r)), res;\n        for (int p = 0; p &lt; 12; ++p)\n            for (int q = 0; q &lt; 12; ++q)\n                if (!tl[p].empty() &amp;&amp; !tr[q].empty())\n                    upd(merge(tl[p], tr[q]), res[(p + q) % 12], p + q &gt;= 12);\n        return res;\n    &#125;;\n    auto res(calc(1, n));\n    for (int i = 0; i &lt;= m - n; ++i)\n        std::cout &lt;&lt; res[i % 12][i / 12] &lt;&lt; &#39; &#39;;\n    std::cout &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"slope-trick\">slope trick</h2>\n<p>对于一个 OI 中的凸函数，它是由一些斜率单调的线段拼接成的图形。</p>\n<p>在这个前提下，发现可以用整个函数的左 / 右端点值（截距）和 <span class=\"math inline\">\\((n-1)\\)</span> 个斜率 / 差分信息描述函数。而这有时比直接维护 <span class=\"math inline\">\\(n\\)</span> 个点值有着更优美的性质，唤其为 slope trick。</p>\n<p>例如，关于斜率序列，如果定义域不大，可以直接维护；如果它的变化次数不多，可以利用它的单调性质，用单调数据结构维护；如果它的值域很小，可以直接维护拐点。</p>\n<p>注意前两种方法一般关注横坐标对应的函数值，所以自变量一般是和操作次数一类有关的；而这里关注函数最值而弱化了具体横坐标，操作次数一般会作为待最优化的因变量，例如：</p>\n<ul>\n<li>我想要将数列通过若干次单点修改使序列单调，但不关心序列最终形态，问最小操作次数。</li>\n<li>我想要让树上所有叶子到根的路径边权和相等，但不关心这个值是多少，问最小操作次数。</li>\n</ul>\n<p>下面依次解决上述问题。</p>\n<hr />\n<h3 id=\"例序列-sequence\">例：序列 sequence</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P4597\" class=\"uri\">https://www.luogu.com.cn/problem/P4597</a></p>\n<p>暴力地，令 <span class=\"math inline\">\\(f_{i,j}\\)</span> 表示 <span class=\"math inline\">\\(a_i\\)</span> 最终被修改为 <span class=\"math inline\">\\(j\\)</span>，容易写出 DP 式子 <span class=\"math inline\">\\(f_{i,j}=\\min\\limits_{k\\le j}\\{f_{i-1,k}\\}+|a_i-j|\\)</span>。</p>\n<p>然后就会发现它的定义域实在是太大了！那如果关注斜率的变化情况呢？</p>\n<p>令 <span class=\"math inline\">\\(f_{i-1}(k)\\)</span> 的极值点为 <span class=\"math inline\">\\(k_m\\)</span>，分类讨论拆绝对值和 min：</p>\n<ul>\n<li><p>当 <span class=\"math inline\">\\(j\\le a_i\\)</span> 时，<span class=\"math inline\">\\(f_i(j)=\\min\\limits_{k\\le j}\\{f_{i-1}(k)\\}+a_i - j\\)</span>。</p>\n<ul>\n<li>当 <span class=\"math inline\">\\(j &lt; k_m\\)</span> 时，<span class=\"math inline\">\\(f_i(j)=f_{i-1}(j)+a_i-j\\)</span>，斜率相对于 <span class=\"math inline\">\\(f_{i-1}(j)\\)</span> 整体减 <span class=\"math inline\">\\(1\\)</span>。<del>我就说导数没白学吧</del></li>\n<li>当 <span class=\"math inline\">\\(j \\ge k_m\\)</span> 时，<span class=\"math inline\">\\(f_i(j)=f_{i-1}(k_m)+a_i-j\\)</span>，斜率为 <span class=\"math inline\">\\(-1\\)</span>。</li>\n</ul></li>\n<li><p>当 <span class=\"math inline\">\\(j &gt; a_i\\)</span> 时，<span class=\"math inline\">\\(f_i(j)=\\min\\limits_{k\\le j}\\{f_{i-1}(k)\\}+j-a_i\\)</span>。</p>\n<ul>\n<li>当 <span class=\"math inline\">\\(j &lt; k_m\\)</span> 时，<span class=\"math inline\">\\(f_i(j)=f_{i-1}(j)+j-a_i\\)</span>，斜率相对于 <span class=\"math inline\">\\(f_{i-1}(j)\\)</span> 整体加 <span class=\"math inline\">\\(1\\)</span>。</li>\n<li>当 <span class=\"math inline\">\\(j\\ge k_m\\)</span> 时，<span class=\"math inline\">\\(f_i(j) = f_{i-1}(k_m)+j-a_i\\)</span>，斜率为 <span class=\"math inline\">\\(1\\)</span>。</li>\n</ul></li>\n</ul>\n<p>如果现在我们掏一个支持区间加斜率、区间推平斜率且维护区间函数最值点的数据结构，那就太逆天了。一个经典的解决方案是用堆维护线段斜率的差分（也就是差分的差分）。</p>\n<p>发现整体修改次数是 <span class=\"math inline\">\\(O(n)\\)</span> 的，且如果只看比 <span class=\"math inline\">\\(k_m\\)</span> 更左的 <span class=\"math inline\">\\(j\\)</span>（更靠右的已经与极值无关所以不用维护），那么就只需要维护区间减法。</p>\n<p>如果将一次区间前缀减法看作一次前缀右端点入队，显然左侧某点 <span class=\"math inline\">\\(a\\)</span> 的实际被减次数为 <span class=\"math inline\">\\(a\\)</span> 入队的次数 + 所有右于 <span class=\"math inline\">\\(a\\)</span> 点的元素的入队次数。用大根堆维护这些元素，就可以快速维护整个斜率序列。例如 <code>3 2 2 1</code>，代表 <span class=\"math inline\">\\(3\\)</span> 处斜率为 <span class=\"math inline\">\\(-1\\)</span>，<span class=\"math inline\">\\(2\\)</span> 处斜率为 <span class=\"math inline\">\\(-3\\)</span>，<span class=\"math inline\">\\(1\\)</span> 处斜率为 <span class=\"math inline\">\\(-4\\)</span>。</p>\n<ul>\n<li><p>当 <span class=\"math inline\">\\(a_i\\ge k_m\\)</span> 时（容易发现它会成为新的 <span class=\"math inline\">\\(k_m\\)</span>），直接把 <span class=\"math inline\">\\(a_i\\)</span> 加入大根堆，就可以把 <span class=\"math inline\">\\(\\le a_i\\)</span> 的所有位置斜率减去 <span class=\"math inline\">\\(1\\)</span>。</p>\n什么你问在 <span class=\"math inline\">\\(k_m\\)</span> 和 <span class=\"math inline\">\\(a_i\\)</span> 之间的推平怎么办？由于唯一右于它们的拐点 <span class=\"math inline\">\\(a_i\\)</span> 入了一次队，所以中间的元素斜率自然是 <span class=\"math inline\">\\(-1\\)</span> 啊。</li>\n<li><p>当 <span class=\"math inline\">\\(a_i&lt;k_m\\)</span> 时，我们需要：</p>\n<ol type=\"1\">\n<li>将 <span class=\"math inline\">\\(a_i\\)</span> 以左的位置斜率减去 <span class=\"math inline\">\\(1\\)</span>，直接将 <span class=\"math inline\">\\(a_i\\)</span> 入队即可。</li>\n<li>将 <span class=\"math inline\">\\(a_i\\)</span> 和 <span class=\"math inline\">\\(k_m\\)</span> 之间的位置斜率加上 <span class=\"math inline\">\\(1\\)</span>，把 <span class=\"math inline\">\\(k_m\\)</span> 弹出（太好了就在队首）再把 <span class=\"math inline\">\\(a_i\\)</span> 加入即可。由于 <span class=\"math inline\">\\(k_m\\)</span> 显然是一个拐点，所以删除 <span class=\"math inline\">\\(k_m\\)</span> 并非虚空索敌，但注意 <span class=\"math inline\">\\(k_m\\)</span> 可能会变化成其后继。</li>\n</ol></li>\n</ul>\n<p>其实就会发现还有一些有趣的小性质，比如 <span class=\"math inline\">\\(k_m\\)</span> 与队首等价（用于实现）；<span class=\"math inline\">\\(k_m\\)</span> 右侧斜率全部为 <span class=\"math inline\">\\(1\\)</span>，也是唯一可以取到的正斜率。</p>\n<details>\n<p>袜写起来好简单。</p>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;int&gt; a(n + 1);\n    long long res = 0ll;\n    std::priority_queue&lt;int&gt; q;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; a[i];\n        if (i == 1 || a[i] &gt;= q.top())\n            q.push(a[i]);\n        else &#123;\n            res += q.top() - a[i];\n            q.pop(), q.push(a[i]), q.push(a[i]);\n        &#125;\n    &#125;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"例烟花表演\">例：烟花表演</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P3642\" class=\"uri\">https://www.luogu.com.cn/problem/P3642</a></p>\n<p>设 <span class=\"math inline\">\\(f_{u,d}\\)</span> 表示在 <span class=\"math inline\">\\(u\\)</span> 子树中所有叶子距根均为 <span class=\"math inline\">\\(d\\)</span> 的最小代价。那么有：</p>\n<p><span class=\"math display\">\\[\nf_{u,d}=\\sum\\limits_{(v, w)\\in u}\\min\\limits_{0\\le w&#39;\\le d}\\{f_{v,d-w&#39;}+|w-w&#39;|\\}.\n\\]</span></p>\n<p>可以归纳证明 <span class=\"math inline\">\\(f_{u,d}\\)</span> 为凸；和上一题相似地，考虑用 <span class=\"math inline\">\\(f_v\\)</span> 的堆得到 <span class=\"math inline\">\\(f_u\\)</span> 的堆。</p>\n<p>首先最外层是一个线性加，这其实就是把差分数组 / 斜率加起来，放到我们这个堆里面就是合并两个堆。虽然你可能和我一样不认识可并堆，但是你可以和我一样不会 pd_ds。</p>\n<p>再看内层，发现和上一题长得像但其实不一样，呜呜呜。发现 <span class=\"math inline\">\\(|w-w&#39;|\\)</span> 是一个左右斜率分别为 <span class=\"math inline\">\\(-1,1\\)</span> 的分段函数，而左边类比可得斜率最大为 <span class=\"math inline\">\\(1\\)</span>。</p>\n<p>由闵可夫斯基和，内层函数斜率 <span class=\"math inline\">\\(&lt;-1\\)</span> 的部分来自 <span class=\"math inline\">\\(f_{v,d-w&#39;}\\)</span>；<span class=\"math inline\">\\(=-1\\)</span> 的部分来自 <span class=\"math inline\">\\(f_{v,d-w&#39;}\\)</span> 和 <span class=\"math inline\">\\(|w-w&#39;|\\)</span> 的左半边（感谢 <span class=\"math inline\">\\(w&#39;\\)</span> 是有下确界的）；<span class=\"math inline\">\\(=0\\)</span> 的部分来自 <span class=\"math inline\">\\(f_{v,d-w&#39;}\\)</span>；<span class=\"math inline\">\\(&gt;0\\)</span> 的部分我们不关心。</p>\n<p>最终函数图像的变化：水平部分的左端点右移了 <span class=\"math inline\">\\(w\\)</span>。找到 <span class=\"math inline\">\\(f_{v,d}\\)</span> 中的水平线段和斜率为 <span class=\"math inline\">\\(1\\)</span> 的线段，令其在堆中的值 <span class=\"math inline\">\\(+w\\)</span> 就能达到平移的目的。</p>\n<p>但需要注意，此时仍然需要 <strong>保留内层函数中斜率为 <span class=\"math inline\">\\(1\\)</span> 的部分，但斜率 <span class=\"math inline\">\\(&gt;1\\)</span> 的部分被删除</strong>。原因如下：</p>\n<ul>\n<li>绝对值函数与内层函数定义域相同，作闵可夫斯基和后，斜率为 <span class=\"math inline\">\\(1\\)</span> 的右侧线段会将 <span class=\"math inline\">\\(f_{v,d-w&#39;}\\)</span> 中原有的 <span class=\"math inline\">\\(&gt;1\\)</span> 的部分『挤』出定义域，故可以将其直接删除。</li>\n<li>斜率为 <span class=\"math inline\">\\(1\\)</span> 的部分，虽然对内层函数中极值点无贡献，但在外层函数中极值点可能向右偏移，此时会对其产生影响，需要维护。</li>\n</ul>\n<p>容易发现由于 <span class=\"math inline\">\\(w&#39;\\)</span> 的取值上限是 <span class=\"math inline\">\\(d\\)</span>，但 <span class=\"math inline\">\\(d\\)</span> 没有上界，所以每个内层函数的右侧都一定是一条斜率为 <span class=\"math inline\">\\(1\\)</span> 的射线；也就是说，每个外层函数一定有（儿子个数）个拐点（堆中元素），弹出这么多个就可以删除外层函数中斜率 <span class=\"math inline\">\\(&gt;1\\)</span> 的线段，顺便找到斜率为 <span class=\"math inline\">\\(0\\)</span> 和 <span class=\"math inline\">\\(1\\)</span> 的线段。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\n#include &lt;ext/pb_ds/priority_queue.hpp&gt;\nconst int inf= 0x3f3f3f3f;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, m;\n    std::cin &gt;&gt; n &gt;&gt; m, n += m;\n    std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; g(n + 1);\n    auto res(0ll);\n    for (int i = 2, fa, w; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; fa &gt;&gt; w, res += w;\n        g[fa].emplace_back(i, w);\n    &#125;\n    std::vector&lt;__gnu_pbds::priority_queue&lt;long long&gt; &gt; q(n + 1);\n    std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;\n        if (g[x].empty())\n            q[x].push(0), q[x].push(0);\n        else\n            for (auto [i, w] : g[x]) &#123;\n                DFS(i);\n                for (int j = 1; j &lt; (int)g[i].size(); ++j)\n                    q[i].pop();\n                long long t1 = q[i].top(), t0;\n                q[i].pop(), t0 = q[i].top(), q[i].pop();\n                q[i].push(t1 + w), q[i].push(t0 + w);\n                q[x].join(q[i]);\n            &#125;\n        // fprintf(stderr, &quot;size(%d) = %d\\n&quot;, x, (int)q[x].size());\n        return;\n    &#125;;\n    DFS(1);\n    for (int i = 1; i &lt;= (int)g[1].size(); ++i)\n        q[1].pop();\n    for (; !q[1].empty(); q[1].pop())\n        res -= q[1].top();\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"例buy-low-sell-high\">例：Buy Low Sell High</h3>\n<p><a href=\"https://codeforces.com/problemset/problem/865/D\" class=\"uri\">https://codeforces.com/problemset/problem/865/D</a></p>\n<p>令 <span class=\"math inline\">\\(f_{i,j}\\)</span> 表示在第 <span class=\"math inline\">\\(i\\)</span> 天结束后持有 <span class=\"math inline\">\\(j\\)</span> 支股票的最大收益。则 <span class=\"math inline\">\\(f_{i,j}=\\max\\{f_{i-1,j},f_{i-1,j-1}-a_i,f_{i-1,j+1}+a_i\\}\\)</span>。</p>\n<p>（由于这里和 max 有关所以需要精细描述凹凸了）发现就是把三个（可能）经过平移的（可能）凹的函数做线性 max。虽然实际上的结论『函数在整点上是凹的』不算太显然，但是可以猜是凹的。</p>\n<p>线性 max 在 slope trick 中是不太能体现的，但我们发现这里是同一个凹函数向左上、右下平移同一个向量，希望得到新的凹函数不管是从差分角度还是图象，都能得到新函数由左上部分斜率 <span class=\"math inline\">\\(&gt;-a_i\\)</span> 的线段、两段斜率 <span class=\"math inline\">\\(=-a_i\\)</span> 的线段、右下部分斜率 <span class=\"math inline\">\\(&lt;-a_i\\)</span> 的线段组成。此外，由于向左上平移的函数有一处离开了定义域，还需将其剔除。</p>\n<p>值得注意的是，当 <span class=\"math inline\">\\(-a_i\\)</span> 比最小斜率还要小时会有变化，可以画图看一下。</p>\n<p><img src=\"2.png\" /></p>\n<p>发现定义域是相对小的（<span class=\"math inline\">\\(0\\le j\\le n\\)</span>），故用优先队列维护整个斜率序列就可以快速插入两个 <span class=\"math inline\">\\(k=-a_i\\)</span> 的线段。容易发现顶点在 <span class=\"math inline\">\\(j=0\\)</span> 处取得（从图象和定义都易知），最右侧是只买不卖的最劣方案，可以倒推。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;int&gt; a(n + 1);\n    auto res = 0ll;\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i], res -= a[i];\n    std::priority_queue&lt;int&gt; q;\n    q.push(-a[1]);\n    for (int i = 2; i &lt;= n; ++i)\n        if (a[i] &lt; -q.top())\n            q.push(-a[i]);\n        else\n            q.pop(), q.push(-a[i]), q.push(-a[i]);\n    for (; !q.empty(); res -= q.top(), q.pop());\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n",
            "tags": [
                "DP",
                "反悔贪心",
                "DP 优化",
                "WQS 二分",
                "闵可夫斯基和",
                "slope trick"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20250526/",
            "url": "https://xsc062.netlify.app/20250526/",
            "title": "多维 DP",
            "date_published": "2025-05-26T07:05:53.000Z",
            "content_html": "<p>上楼听到有人在哼 <em>Climbing on the Trees</em>，上来听到隔壁班在放 <em>Burn the House Down</em>，果然春天是 AJR 的季节（）</p>\n<span id=\"more\"></span>\n<hr />\n<p>主要是多维 DP 特有的优化！</p>\n<h2 id=\"分步转移\">分步转移</h2>\n<p>如果状态的若干维之间只存在很弱的联系，可以分步转移每一维。</p>\n<p>假设有二维状态转移 <span class=\"math inline\">\\((a,b)\\to (a&#39;,b&#39;)\\)</span>，『很弱的联系』举例：</p>\n<ol type=\"1\">\n<li>DP 值中包含 <span class=\"math inline\">\\(w(a&#39;,b&#39;)\\)</span>，但不包含诸如 <span class=\"math inline\">\\(w(a&#39;,b),w(a,b&#39;)\\)</span> 之类。也即该值的求解不依赖于上一个状态、不依赖于转移。</li>\n<li>对于 <span class=\"math inline\">\\((a&#39;,b&#39;)\\)</span> 的取值有限制，比如 <span class=\"math inline\">\\((114,514)\\)</span> 不能取到之类。显然这也不依赖于上一个状态、不依赖于转移。</li>\n<li>符号限制（如转移间为 <span class=\"math inline\">\\(+\\)</span>，状态间为 <span class=\"math inline\">\\(\\times\\)</span> 之类），在计数中常出现。</li>\n<li>一个变动的时候另一个必须也一起动。</li>\n</ol>\n<p>注意！有的时候一个状态也可以拆成两个状态，然后分步转移。</p>\n<hr />\n<h3 id=\"例题经典题\">例题：经典题</h3>\n<blockquote>\n<p>给定 <span class=\"math inline\">\\(w_{N\\times M}\\)</span>，求 <span class=\"math inline\">\\((A,B)_{1\\sim K}\\)</span>，最大化 <span class=\"math inline\">\\(\\sum\\limits_{i=1}^K w_{A_i,B_i}+w_{A_{i-1},A_i}+w_{B_{i-1},B_i}\\)</span> 的值。</p>\n</blockquote>\n<p>发现如果设 <span class=\"math inline\">\\(f_{i,a,b}\\)</span> 表示 <span class=\"math inline\">\\((A,B)_i=(a,b)\\)</span> 的话，转移就会达到可观的 <span class=\"math inline\">\\(O(N\\times M)\\)</span>；但发现里面的 <span class=\"math inline\">\\(A\\)</span> 和 <span class=\"math inline\">\\(B\\)</span> 其实没什么有机联系；唯一的联系 <span class=\"math inline\">\\(w_{A_i,B_i}\\)</span>（上面『很弱的联系』中的第一、四种情况）。因此分布转移：</p>\n<p><span class=\"math display\">\\[\nf&#39;_{a&#39;,b}\\gets \\max\\limits_a f_{a,b}+w_{a&#39;,a}\\\\\nf_{a&#39;,b&#39;}\\gets \\max\\limits_b f&#39;_{a&#39;, b} + w_{b,b&#39;}+w_{a&#39;,b&#39;}\n\\]</span></p>\n<p>由此便优化转移复杂度到 <span class=\"math inline\">\\(O(N+M)\\)</span>。</p>\n<hr />\n<h3 id=\"例题彩灯晚会\">例题：彩灯晚会</h3>\n<p>goto <a href=\"/20250407/#e---kdoi-11彩灯晚会\">link</a>。</p>\n<p>Tips：发现 <span class=\"math inline\">\\(l_1,l_2\\)</span> 之间也没啥有机联系（上面『很弱的联系』中的第三、四种情况），故分步转移。</p>\n<hr />\n<h3 id=\"例题序列妙妙值\">例题：序列妙妙值</h3>\n<p><a href=\"https://uoj.ac/problem/549\" class=\"uri\">https://uoj.ac/problem/549</a></p>\n<p>朴素地，设 <span class=\"math inline\">\\(f_{i,j}\\)</span> 表示在第 <span class=\"math inline\">\\(i\\)</span> 个处分第 <span class=\"math inline\">\\(j\\)</span> 段的最大价值，显然有 <span class=\"math inline\">\\(O(k\\times n^2)\\)</span>，且并没有优化的空间。</p>\n<p>考虑利用 <span class=\"math inline\">\\(a_i\\)</span> 很小这一条件，发现上一条无法优化是因为要获取 <span class=\"math inline\">\\(sum_{i}\\)</span> 的值；那么把 <span class=\"math inline\">\\(sum_i\\)</span> 塞到状态里。设 <span class=\"math inline\">\\(f_{s&#39;,j}\\)</span> 表示 <span class=\"math inline\">\\(sum=s&#39;\\)</span> 时，分了 <span class=\"math inline\">\\(j\\)</span> 段的最大价值。同样可以 <span class=\"math inline\">\\(O(k\\cdot n^2)\\)</span>。</p>\n<p>接下来有两个理解这个优化的角度：</p>\n<ol type=\"1\">\n<li><p>从平衡角度，原问题等价于 <span class=\"math inline\">\\(O(1)\\)</span> 更新 <span class=\"math inline\">\\((s,j)\\)</span> 处的最大值，<span class=\"math inline\">\\(O(v)\\)</span> 查找 <span class=\"math inline\">\\(j-1\\)</span> 处的最大值；把 <span class=\"math inline\">\\(s\\)</span> 拆成前 <span class=\"math inline\">\\(8\\)</span> 位、后 <span class=\"math inline\">\\(8\\)</span> 位两个 part，当更新</p>\n<p>对于修改：相当于固定前 <span class=\"math inline\">\\(8\\)</span> 位 <span class=\"math inline\">\\(s\\)</span>，枚举后 <span class=\"math inline\">\\(8\\)</span> 位 <span class=\"math inline\">\\(x\\)</span>，并更新 <span class=\"math inline\">\\((s,x)\\)</span>。</p>\n对于查询：相当于固定后 <span class=\"math inline\">\\(8\\)</span> 位 <span class=\"math inline\">\\(x\\)</span>，枚举前 <span class=\"math inline\">\\(8\\)</span> 位 <span class=\"math inline\">\\(s\\)</span>，并查询 <span class=\"math inline\">\\((s,x)\\)</span>。</li>\n<li><p>从分步转移角度，由于『现时刻』的贡献是按位的，二进制状态的前 <span class=\"math inline\">\\(8\\)</span> 位和后 <span class=\"math inline\">\\(8\\)</span> 位没啥有机联系，故直接拆开，先转移前 <span class=\"math inline\">\\(8\\)</span> 位，再转移后 <span class=\"math inline\">\\(8\\)</span> 位。</p></li>\n</ol>\n<p>这样就被优化为 <span class=\"math inline\">\\(O(k\\cdot n\\times \\sqrt v)\\)</span>。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxv = 1 &lt;&lt; 8;\nconst int inf = 0x3f3f3f3f;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, k;\n    std::cin &gt;&gt; n &gt;&gt; k;\n    using arr = std::vector&lt;int&gt;;\n    using brr = std::vector&lt;arr&gt;;\n    using crr = std::vector&lt;brr&gt;;\n    arr s(n + 1), tag0(maxv), d0;\n    crr f(maxv, brr(maxv, arr(k + 1, inf))), g(maxv, brr(maxv, arr(k + 1, inf)));\n    f[0][0][0] = 0;\n    for (int j = 0; j &lt; maxv; ++j)\n        g[0][j][1] = j;\n    tag0[0] = 1, d0.push_back(0);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; s[i], s[i] ^= s[i - 1];\n        int p0 = s[i] &gt;&gt; 8, p1 = s[i] &amp; ((1 &lt;&lt; 8) - 1);\n        for (int j = k; j; --j) &#123;\n            for (auto a : d0)\n                f[p0][p1][j] = std::min(f[p0][p1][j], g[a][p1][j] + ((a ^ p0) &lt;&lt; 8));\n            // printf(&quot;f[%d][%d][%d] = %d\\n&quot;, p0, p1, j, f[p0][p1][j]);\n            if (j != k)\n                for (int a = 0; a &lt; maxv; ++a)\n                    g[p0][a][j + 1] = std::min(g[p0][a][j + 1], f[p0][p1][j] + (a ^ p1));\n        &#125;\n        if (i &gt;= k)\n            std::cout &lt;&lt; f[p0][p1][k] &lt;&lt; &#39; &#39;;\n        if (!tag0[p0])\n            tag0[p0] = 1, d0.push_back(p0);\n    &#125;\n    std::cout &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"割裂\">割裂</h2>\n<p>如果状态的若干维之间连无机联系都没了，可以直接把 DP 数组拆开，各自转移各自的。</p>\n<p>最后答案的拼接，可能是枚举、直接拼、用一个转移另一个之类。</p>\n<hr />\n<h3 id=\"例题经典题-1\">例题：经典题</h3>\n<blockquote>\n<p>给定 <span class=\"math inline\">\\(w_{N\\times M}\\)</span>，求 <span class=\"math inline\">\\((A,B)_{1\\sim K}\\)</span>，最大化 <span class=\"math inline\">\\(\\sum\\limits_{i=1}^K w_{A_{i-1},A_i}+w_{B_{i-1},B_i}\\)</span> 的值。</p>\n</blockquote>\n<p>先 DP 出来 <span class=\"math inline\">\\(A\\)</span>，再 DP 出来 <span class=\"math inline\">\\(B\\)</span>，直接相加即可。</p>\n<hr />\n<h3 id=\"例题mnogomet\">例题：MNOGOMET</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P7648\" class=\"uri\">https://www.luogu.com.cn/problem/P7648</a></p>\n<p>想到设 <span class=\"math inline\">\\(f_{t,i,a,b}\\)</span> 表示『过去了 <span class=\"math inline\">\\(t\\)</span> 秒，且球在球员 <span class=\"math inline\">\\(i\\)</span> 手上，且两个队伍得分分别为 <span class=\"math inline\">\\(a,b\\)</span>』的概率。那么枚举球上一次在谁手上，有美观的 <span class=\"math inline\">\\(O(T\\cdot N^2R^2)\\)</span>。</p>\n<p>发现比分变动时（上半个时刻完成射门并传球）球一定在某个队的 <span class=\"math inline\">\\(1\\)</span> 号手上；<span class=\"math inline\">\\(i\\)</span> 这一维和 <span class=\"math inline\">\\(a,b\\)</span> 也没有相互的干扰；故可以将 <span class=\"math inline\">\\(i\\)</span> 提取出来（作为对比，射门和夺球、传球都会影响 <span class=\"math inline\">\\(t\\)</span>，所以分裂出来的状态中必须包含 <span class=\"math inline\">\\(t\\)</span>）。具体地：</p>\n<ol type=\"1\">\n<li><p>令 <span class=\"math inline\">\\(g_{t,0/1,i}\\)</span> 表示『一开始球在哪个球队的 <span class=\"math inline\">\\(1\\)</span> 号，花费 <span class=\"math inline\">\\(t\\)</span> 秒，且没人射门，且球在球员 <span class=\"math inline\">\\(i\\)</span> 手上』的概率。发现可以 <span class=\"math inline\">\\(O(T\\times N^2)\\)</span> 计算。</p>\n<p>当然这里就是条件概率了。其中『一开始球在哪个球队的 <span class=\"math inline\">\\(1\\)</span> 号』就是条件。</p>\n再预处理可以得到 <span class=\"math inline\">\\(G_{t,0/1,0/1,0/1}\\)</span> 表示『一开始球在哪个球队的 <span class=\"math inline\">\\(1\\)</span> 号，花费 <span class=\"math inline\">\\(t\\)</span> 秒，哪个球队射门，（没）射进』的概率。</li>\n<li><p>令 <span class=\"math inline\">\\(f_{t,0/1,a,b}\\)</span> 表示『过去了 <span class=\"math inline\">\\(t\\)</span> 秒，球在哪个队的 <span class=\"math inline\">\\(1\\)</span> 号，且得分为 <span class=\"math inline\">\\(a,b\\)</span>』的概率。枚举距离上一次射门的时间，可以 <span class=\"math inline\">\\(O(T^2\\times R^2)\\)</span> 完成转移。</p></li>\n</ol>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, r, T;\n    std::cin &gt;&gt; n &gt;&gt; r &gt;&gt; T;\n    using arr = std::vector&lt;double&gt;;\n    using brr = std::vector&lt;arr&gt;;\n    using crr = std::vector&lt;brr&gt;;\n    brr p(2 * n + 1, arr(2)), pp(2 * n + 1, arr(2 * n + 1));\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; p[i][1], p[i][0] = 1. - p[i][1];\n        int ss, sd;\n        std::cin &gt;&gt; ss &gt;&gt; sd;\n        double P = 1. / (ss + sd + 1);\n        p[i][0] *= P, p[i][1] *= P;\n        for (int x; ss--; pp[i][x] = P)\n            std::cin &gt;&gt; x;\n        for (int x; sd--; pp[i][x + n] = P)\n            std::cin &gt;&gt; x;\n    &#125;\n    for (int i = n + 1; i &lt;= 2 * n; ++i) &#123;\n        std::cin &gt;&gt; p[i][1], p[i][0] = 1. - p[i][1];\n        int ss, sd;\n        std::cin &gt;&gt; ss &gt;&gt; sd;\n        double P = 1. / (ss + sd + 1);\n        p[i][0] *= P, p[i][1] *= P;\n        for (int x; ss--; pp[i][x + n] = P)\n            std::cin &gt;&gt; x;\n        for (int x; sd--; pp[i][x] = P)\n            std::cin &gt;&gt; x;\n    &#125;\n    brr s(T + 1, arr(2));\n    crr g(T + 1, brr(2, arr(2 * n + 1)));\n    std::vector&lt;crr&gt; G(T + 1, crr(2, brr(2, arr(2)))), f(T + 1, crr(2, brr(r + 1, arr(r + 1))));\n    g[0][0][1] = g[0][1][n + 1] = 1.;\n    for (int t = 1; t &lt;= T; ++t) &#123;\n        for (int f1 = 0; f1 &lt;= 1; ++f1)\n            for (int i = 1; i &lt;= 2 * n; ++i) &#123;\n                G[t][f1][i &gt; n][0] += g[t - 1][f1][i] * p[i][0];\n                G[t][f1][i &gt; n][1] += g[t - 1][f1][i] * p[i][1];\n                for (int j = 1; j &lt;= 2 * n; ++j)\n                    if (j != i)\n                        g[t][f1][i] += pp[j][i] * g[t - 1][f1][j];\n                // printf(&quot;spend %ds, start from %d, now at %d: %.10lf\\n&quot;, t, 1 + f1 * n, i, g[t][f1][i]);\n                s[t][f1] += g[t][f1][i];\n            &#125;\n    &#125;\n    // puts(&quot;------------------------------------&quot;);\n    // for (int t = 1; t &lt;= T; ++t) &#123;\n    //     for (int f1 = 0; f1 &lt;= 1; ++f1)\n    //         for (int f2 = 0; f2 &lt;= 1; ++f2)\n    //             for (int f3 = 0; f3 &lt;= 1; ++f3)\n    //                 printf(&quot;spend %ds, start from %d, %d shoots, STATUS: %d, P = %.10lf\\n&quot;, t, 1 + f1 * n, 1 + f2, f3, G[t][f1][f2][f3]);\n    // &#125;\n    // puts(&quot;------------------------------------&quot;);\n    f[0][0][0][0] = 1.;\n    for (int t = 0; t &lt; T; ++t)\n        for (int f1 = 0; f1 &lt;= 1; ++f1)\n            for (int a = 0; a &lt; r; ++a)\n                for (int b = 0; b &lt; r; ++b) &#123;\n                    for (int t1 = 1; t + t1 &lt;= T; ++t1) &#123;\n                        f[t + t1][0][a][b] += f[t][f1][a][b] * G[t1][f1][1][0];\n                        f[t + t1][0][a][b + 1] += f[t][f1][a][b] * G[t1][f1][1][1];\n                        f[t + t1][1][a][b] += f[t][f1][a][b] * G[t1][f1][0][0];\n                        f[t + t1][1][a + 1][b] += f[t][f1][a][b] * G[t1][f1][0][1];\n                        if (t + t1 == T)\n                            f[T][0][a][b] += f[t][f1][a][b] * s[t1][f1];\n                    &#125;\n                &#125;\n    // for (int t = 0; t &lt;= T; ++t)\n    //     for (int f1 = 0; f1 &lt;= 1; ++f1)\n    //         for (int a = 0; a &lt;= r; ++a)\n    //             for (int b = 0; b &lt;= r; ++b)\n    //                 if (f[t][f1][a][b] &gt; 1e-10)\n    //                     printf(&quot;%ds later, %d shoots, %d : %d, P = %.10lf\\n&quot;, t, 1 + !f1 * n, a, b, f[t][f1][a][b]);\n    std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(10);\n    for (int a = 0; a &lt;= r; ++a) &#123;\n        for (int b = 0; b &lt;= r; ++b) &#123;\n            if (a == r &amp;&amp; b == r)\n                continue;\n            double res(0.);\n            if (a == r)\n                for (int t = r; t &lt;= T; ++t)\n                    res += f[t][1][r][b];\n            else if (b == r)\n                for (int t = r; t &lt;= T; ++t)\n                    res += f[t][0][a][r];\n            else\n                res = f[T][0][a][b] + f[T][1][a][b];\n            std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n        &#125;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n",
            "tags": [
                "DP",
                "DP 优化"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20250510/",
            "url": "https://xsc062.netlify.app/20250510/",
            "title": "杂题",
            "date_published": "2025-05-10T02:18:21.000Z",
            "content_html": "<p>啊啊。小封条。</p>\n<span id=\"more\"></span>\n<hr />\n<h2 id=\"a---pass-to-next\">A - Pass to Next</h2>\n<p><a href=\"https://atcoder.jp/contests/arc124/tasks/arc124_e\" class=\"uri\">https://atcoder.jp/contests/arc124/tasks/arc124_e</a></p>\n<p>感觉其他一些题解讲得不是特别清楚，这里参考了 <a href=\"https://blog.csdn.net/weixin_43960287/article/details/119140590\">XJX 的文章</a>。</p>\n<p>要求的答案是 <span class=\"math inline\">\\(\\prod a&#39;_i\\)</span>，<mark>发现运算是乘法，比较怪；由此考虑转化为方案数，也就是假设每个人有 <span class=\"math inline\">\\(a&#39;_i\\)</span> 个互不相同的球，每个人在其中选出恰好一个的方案数</mark>。</p>\n<p>考虑 DP。发现每个人手上的球分为『自己的』和『左边的人传过来的』两种类型；<mark>显然第二种会有来自上一个人的限制，考虑把第二种在上一个人就完成求解</mark>。具体地，设 <span class=\"math inline\">\\(f_{i,0}\\)</span> 表示第 <span class=\"math inline\">\\(i\\)</span> 个人选取自己的球，但只记录 <span class=\"math inline\">\\(1\\sim i-1\\)</span> 的方案；<span class=\"math inline\">\\(f_{i,1}\\)</span> 表示第 <span class=\"math inline\">\\(i\\)</span> 个人选取第 <span class=\"math inline\">\\(i-1\\)</span> 个人的球，并记入答案的方案。<em>你可能需要注意到：最后一个被记入方案的球来自第 <span class=\"math inline\">\\(i-1\\)</span> 个人</em>。</p>\n<p>但这样会有个小问题。我们让所有人多往右边传一个球，那么在我们的这种分割方法看来是不一样的局面；但实际上它们是等价的。从每个人传出了多少个球（设为 <span class=\"math inline\">\\(x_i\\)</span>）的角度来看，对于 <span class=\"math inline\">\\(\\min\\{x_n\\}\\ne 0\\)</span>，只需要不断执行 <span class=\"math inline\">\\(\\forall\\, x_i\\gets x_i-1\\)</span> 就可以在局面不变的情况下使 <span class=\"math inline\">\\(\\min\\{x_n\\}\\ne 0\\)</span>。这是在说，可以让 <span class=\"math inline\">\\(\\min\\{x_n\\}\\ne 0\\)</span> 的方案和终局一一对应。</p>\n<p>发现可以容斥：钦定 <span class=\"math inline\">\\(x_i\\ge 1\\)</span>，也就是每个人必须往右传至少一个，相似地算一遍就能得到非法方案。</p>\n<p>考虑转移，令 <span class=\"math inline\">\\(x_i\\)</span> 可选最小值为 <span class=\"math inline\">\\(l\\)</span>，有：</p>\n<ul>\n<li><span class=\"math inline\">\\(f_{i+1,0}\\gets f_{i,0}\\)</span>：将第 <span class=\"math inline\">\\(i\\)</span> 个人未被记入的自己的球记入，球数可能为 <span class=\"math inline\">\\([0,a_i-l]\\)</span>。等差数列求和即可。</li>\n<li><span class=\"math inline\">\\(f_{i+1,0}\\gets f_{i,1}\\)</span>：没有球需要被记入，但是这种情况对应多种 <span class=\"math inline\">\\(x_i\\)</span>。具体地，<span class=\"math inline\">\\(x_i\\in [l,a_i]\\)</span>。共有 <span class=\"math inline\">\\(a_i-l+1\\)</span> 种方案。</li>\n<li><span class=\"math inline\">\\(f_{i+1,1}\\gets f_{i,0}\\)</span>：将第 <span class=\"math inline\">\\(i\\)</span> 个人的 <span class=\"math inline\">\\(a_i\\)</span> 个球分给 <span class=\"math inline\">\\(i\\)</span> 和 <span class=\"math inline\">\\(i+1\\)</span>。共有 <span class=\"math inline\">\\(x_i\\cdot (a_i-x_i)\\)</span> 种可能，也就是 <span class=\"math inline\">\\(\\left(a_i\\cdot \\sum_{x_i=l}^{a_i} x_i\\right)-\\left(\\sum_{x_i=l}^{a_i}{x_i}^2\\right)\\)</span> 种方案。</li>\n<li><span class=\"math inline\">\\(f_{i+1,1}\\gets f_{i,1}\\)</span>：将第 <span class=\"math inline\">\\(i+1\\)</span> 个人得到的第 <span class=\"math inline\">\\(i\\)</span> 个人的球记入，同第一条。</li>\n</ul>\n<p>破环为链，分别钦定第一个人是用自己的球还是上一个人的球来解决问题（必须对于两种可能性分开计算；否则就不知道答案应该取 <span class=\"math inline\">\\(f_{n,0}\\)</span> 还是 <span class=\"math inline\">\\(f_{n,1}\\)</span>）。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 998244353, inv2 = (mod + 1) &gt;&gt; 1, inv6 = 166374059;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;long long&gt; a(n);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i % n];\n    auto sum = [&amp;](long long r) &#123;\n        return r * (r + 1) % mod * inv2 % mod;\n    &#125;;\n    auto sum2 = [&amp;](long long r) &#123;\n        return r * (r + 1) % mod * (2 * r % mod + 1) % mod * inv6 % mod;\n    &#125;;\n    std::vector&lt;std::vector&lt;long long&gt; &gt; f0(n, std::vector&lt;long long&gt; (2)), f1(n, std::vector&lt;long long&gt; (2));\n    auto calc = [&amp;](long long l, std::vector&lt;std::vector&lt;long long&gt; &gt; &amp;f) &#123;\n        f[0][0] = 1ll;\n        for (int i = 0; i &lt; n; ++i) &#123;\n            int j = (i + 1) % n;\n            f[j][0] = f[i][0] * sum(a[i] - l) % mod;\n            (f[j][0] += f[i][1] * (a[i] - l + 1)) %= mod;\n            f[j][1] = f[i][0] * (a[i] * sum(a[i]) % mod - sum2(a[i])) % mod;\n            (f[j][1] += f[i][1] * sum(a[i]) % mod) %= mod;\n            // printf(&quot;0, l = %lld, f[%d]: %lld / %lld\\n&quot;, l, j, f[j][0], f[j][1]);\n        &#125;\n        auto res(f[0][0]);\n        f.assign(n, std::vector&lt;long long&gt; (2));\n        f[0][1] = 1ll;\n        for (int i = 0; i &lt; n; ++i) &#123;\n            int j = (i + 1) % n;\n            f[j][0] = f[i][0] * sum(a[i] - l) % mod;\n            (f[j][0] += f[i][1] * (a[i] - l + 1)) %= mod;\n            f[j][1] = f[i][0] * (a[i] * sum(a[i]) % mod - sum2(a[i])) % mod;\n            (f[j][1] += f[i][1] * sum(a[i]) % mod) %= mod;\n            // printf(&quot;1, l = %lld, f[%d]: %lld / %lld\\n&quot;, l, j, f[j][0], f[j][1]);\n        &#125;\n        return (res + f[0][1]) % mod;\n    &#125;;\n    std::cout &lt;&lt; (calc(0, f0) + mod - calc(1, f1)) % mod &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"b---绿宝石之岛\">B - 绿宝石之岛</h2>\n<p><a href=\"https://loj.ac/p/6406\" class=\"uri\">https://loj.ac/p/6406</a></p>\n<p>因为只关心最终状态，原题可以转化为：将 <span class=\"math inline\">\\(d\\)</span> 分成 <span class=\"math inline\">\\(n\\)</span> 个非负整数，前 <span class=\"math inline\">\\(r\\)</span> 大数之和的期望（当然你需要加上初始的 <span class=\"math inline\">\\(r\\)</span> 个）。</p>\n<p>关于非负整数拆分：设 <span class=\"math inline\">\\(f_{i,j}\\)</span> 表示将 <span class=\"math inline\">\\(i\\)</span> 分成 <span class=\"math inline\">\\(j\\)</span> 个 <strong>非负整数</strong> 的方案，钦定其中恰有 <span class=\"math inline\">\\(k\\)</span> 个 <strong>正整数</strong> 进行转移，给这 <span class=\"math inline\">\\(k\\)</span> 个数先分一个 <span class=\"math inline\">\\(1\\)</span>，则 <span class=\"math inline\">\\(f_{i,j}=\\sum\\limits_{k=0}^{\\min(i,j)} C_j^k\\cdot f_{i-k,k}\\)</span>。</p>\n<p>再设 <span class=\"math inline\">\\(g_{i,j}\\)</span> 表示将 <span class=\"math inline\">\\(i\\)</span> 分成 <span class=\"math inline\">\\(j\\)</span> 个非负整数的所有方案中、前 <span class=\"math inline\">\\(r\\)</span> 大的数之和。类似地，有 <span class=\"math inline\">\\(g_{i,j}=\\sum\\limits_{k=0}^{\\min(i,j)} C_j^k\\cdot (g_{i-k,k}+\\min(k,r)\\cdot f_{i-k,k})\\)</span>。其中，<span class=\"math inline\">\\(\\min(k,r)\\)</span> 的来源是，只有 <span class=\"math inline\">\\(k\\)</span> 个数有值，前 <span class=\"math inline\">\\(r\\)</span> 大的数一定在这 <span class=\"math inline\">\\(k\\)</span> 个数里面。</p>\n<p>答案为 <span class=\"math inline\">\\(\\dfrac {g_{d,n}}{f_{d,n}}+r\\)</span>，复杂度 <span class=\"math inline\">\\(O(n^3)\\)</span>。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, d, r;\n    std::cin &gt;&gt; n &gt;&gt; d &gt;&gt; r;\n    using arr = std::vector&lt;double&gt;;\n    std::vector&lt;arr&gt; f(d + 1, arr(n + 1)), g(d + 1, arr(n + 1)), C(n + 1, arr(n + 1));\n    for (int i = 0; i &lt;= n; ++i) &#123;\n        C[i][0] = 1.;\n        for (int j = 1; j &lt;= i; ++j)\n            C[i][j] = C[i - 1][j - 1] + C[i - 1][j];\n    &#125;\n    f[0].assign(n + 1, 1.);\n    for (int i = 1; i &lt;= d; ++i)\n        for (int j = 1; j &lt;= n; ++j) &#123;\n            for (int k = 1; k &lt;= i &amp;&amp; k &lt;= j; ++k) &#123;\n                f[i][j] += C[j][k] * f[i - k][k];\n                g[i][j] += C[j][k] * (g[i - k][k] + std::min(k, r) * f[i - k][k]);\n                // printf(&quot;  k = %d, %.0lf + %.0lf\\n&quot;, k, C[j][k] * g[i - k][k], std::min(k, r) * f[i - k][k]);\n            &#125;\n            // printf(&quot;f[%d][%d] = %.0lf, g[%d][%d] = %.0lf\\n&quot;, i, j, f[i][j], i, j, g[i][j]);\n        &#125;\n    std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(8) &lt;&lt; g[d][n] / f[d][n] + r &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"c---uddered-but-not-herd-g\">C - Uddered but not Herd G</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P7296\" class=\"uri\">https://www.luogu.com.cn/problem/P7296</a></p>\n<p>给每个字母分配一个标号 <span class=\"math inline\">\\(x\\)</span>，那么最小段数就是 <span class=\"math inline\">\\(\\sum \\left[x_i\\ge x_{i+1}\\right]\\)</span>。</p>\n<p>考虑状压完成映射操作，令 <span class=\"math inline\">\\(f_{s}\\)</span> 表示给标号 <span class=\"math inline\">\\(1\\sim |s|\\)</span> 分配字母后，占用字符集 <span class=\"math inline\">\\(s\\)</span> 的方案数，那么就能 <span class=\"math inline\">\\(O(1)\\)</span> 得到贡献——只需预处理出 <span class=\"math inline\">\\(f_{c, s}\\)</span> 表示分配到字母 <span class=\"math inline\">\\(c\\)</span> 时，已经先给 <span class=\"math inline\">\\(s\\)</span> 中字母分配了更小标号时的贡献。</p>\n<p>注意字符集大小只有 <span class=\"math inline\">\\(20\\)</span>，可以 <span class=\"math inline\">\\(O(|S|\\cdot 2^{|S|})\\)</span> 解决问题，<mark>注意到预处理的内容是类高维前缀最值的形式，可以递推降低复杂度</mark>。</p>\n<details>\n<pre data-line=\"26-28\" class=\"cpp language-cpp\"><code data-line=\"26-28\" class=\"cpp language-cpp\">#include &lt;bits/stdc++.h>\nconst int inf = 0x3f3f3f3f;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(\".in\", \"r\", stdin);\n    std::freopen(\".out\", \"w\", stdout);\n#endif\n    int n;\n    std::string t;\n    std::cin >> t, n = (int)t.length(), t = \"#\" + t;\n    std::vector&lt;int> a, tag(26, -1), s(n + 1);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        if (tag[t[i] - 'a'] == -1)\n            tag[t[i] - 'a'] = (int)a.size(), a.push_back(t[i] - 'a');\n        s[i] = tag[t[i] - 'a'];\n    &#125;\n    int m = (int)a.size(), siz = 1 &lt;&lt; m;\n    std::vector&lt;std::vector&lt;int> > cnt(m, std::vector&lt;int> (m));\n    for (int i = 1; i &lt; n; ++i)\n        ++cnt[s[i]][s[i + 1]];\n    std::vector&lt;std::vector&lt;int> > g(m, std::vector&lt;int> (siz));\n    for (int i = 0; i &lt; m; ++i)\n        for (int k = 0; k &lt; m; ++k) // 注意这里相当于是钦定从 k 处转移\n            for (int j = (1 &lt;&lt; k); j &lt; (2 &lt;&lt; k); ++j) // 枚举的是 k 位为 1 的所有数；这两层循环的复杂度为 O(siz)\n                g[i][j] = g[i][j ^ (1 &lt;&lt; k)] + cnt[i][k]; // 目的是此处的内存连续访问优化，把 ^ 看作 - 应该就能理解为什么第二维是连续的\n    std::vector&lt;int> f(siz, inf);\n    f[0] = 1;\n    for (int i = 1; i &lt; siz; ++i)\n        for (int j = 0; j &lt; m; ++j)\n            if ((i >> j) & 1)\n                f[i] = std::min(f[i], f[i ^ (1 &lt;&lt; j)] + g[j][i]);\n    std::cout &lt;&lt; f[siz - 1] &lt;&lt; '\\n';\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"d---min-max-subarrays-p\">D - Min Max Subarrays P</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P11845\" class=\"uri\">https://www.luogu.com.cn/problem/P11845</a></p>\n<p>先考虑 <span class=\"math inline\">\\(01\\)</span> 序列的答案：如果序列中存在相邻的 <span class=\"math inline\">\\(2\\)</span> 个 <span class=\"math inline\">\\(1\\)</span>，总能保证最后的一个是 <span class=\"math inline\">\\(1\\)</span>。</p>\n<p>如果序列中存在 <span class=\"math inline\">\\(\\ge 3\\)</span> 个 <span class=\"math inline\">\\(1\\)</span>，可以牺牲其中的一些使得 <span class=\"math inline\">\\(2\\)</span> 个 <span class=\"math inline\">\\(1\\)</span> 相邻。</p>\n<p>当序列中只有 <span class=\"math inline\">\\(2\\)</span> 个 <span class=\"math inline\">\\(1\\)</span> 时，只有因为剩下的 <span class=\"math inline\">\\(0\\)</span> 不太够，导致我们无法随意『上下其手』时不能将 <span class=\"math inline\">\\(2\\)</span> 个 <span class=\"math inline\">\\(1\\)</span> 挪到一起。</p>\n<p>令两个 <span class=\"math inline\">\\(1\\)</span> 为序列最大值与次大值，暴搜处理序列长度较小的情况，剩下的直接用奇偶性判断两个 <span class=\"math inline\">\\(1\\)</span> 取哪个。</p>\n<hr />\n<h2 id=\"a---mst-on-line\">A - MST on Line++</h2>\n<p><a href=\"https://atcoder.jp/contests/arc167/tasks/arc167_c\" class=\"uri\">https://atcoder.jp/contests/arc167/tasks/arc167_c</a></p>\n<p>相当于把 <span class=\"math inline\">\\(a\\)</span> 打乱然后处理原问题。考虑每个 <span class=\"math inline\">\\(a_i\\)</span> 的贡献次数。模拟 Kruskal 连边，从小到大把点 <span class=\"math inline\">\\(a_i\\)</span> 加入图，<span class=\"math inline\">\\(a_i\\)</span> 可以向 <span class=\"math inline\">\\(a_{[i-K,i+K]}\\)</span> 内所有连通块连边。</p>\n<p>连通块数量当且仅当 <span class=\"math inline\">\\([i-K,i)\\)</span> 内最靠右的点和 <span class=\"math inline\">\\((i, i+K]\\)</span> 内最靠左的点距离 <span class=\"math inline\">\\(&gt;K\\)</span> 时为 <span class=\"math inline\">\\(2\\)</span>，其余情况为 <span class=\"math inline\">\\(1\\)</span>。</p>\n<p>但要是从这个角度想这个题就不太好做了。正确的想法应该是<mark>拆分为『若 <span class=\"math inline\">\\([i-K,i)\\)</span> 中有点，贡献次数 <span class=\"math inline\">\\(+1\\)</span>』和『若 <span class=\"math inline\">\\((i,i+K]\\)</span> 中有点 <span class=\"math inline\">\\(j\\)</span> 满足 <span class=\"math inline\">\\([j-K,j)\\)</span> 中无点，贡献次数 <span class=\"math inline\">\\(+1\\)</span>』</mark>。对于第一个问题，贡献次数将前 <span class=\"math inline\">\\(i-1\\)</span> 大的数分配至少一个到 <span class=\"math inline\">\\([i-K,i)\\)</span> 中的方案数；对于第二个问题，枚举 <span class=\"math inline\">\\(j\\)</span>，贡献次数为将前 <span class=\"math inline\">\\(i-1\\)</span> 大的数分配到 <span class=\"math inline\">\\(j\\)</span> 和 <span class=\"math inline\">\\([1,j-K)\\cup (j, n]\\)</span> 中的方案数。</p>\n<details>\n<p>实现的时候千万注意循环变量枚举的是位置还是值！不然你会调得很痛苦。</p>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 998244353;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;03-max-01.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, k;\n    std::cin &gt;&gt; n &gt;&gt; k;\n    std::vector&lt;int&gt; a(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i];\n    std::sort(a.begin() + 1, a.end());\n    std::vector&lt;long long&gt; fac(n + 1), inv(n + 1);\n    fac[0] = inv[0] = 1ll;\n    for (int i = 1; i &lt;= n; ++i)\n        fac[i] = fac[i - 1] * i % mod;\n    auto qkp = [](long long x, int y) &#123;\n        auto res(1ll);\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    inv[n] = qkp(fac[n], mod - 2);\n    for (int i = n - 1; i; --i)\n        inv[i] = inv[i + 1] * (i + 1) % mod;\n    auto A = [&amp;](int n, int m) &#123;\n        if (n &lt; m)\n            return 0ll;\n        return fac[n] * inv[n - m] % mod;\n    &#125;;\n    auto C = [&amp;](int n, int m) &#123;\n        return A(n, m) * inv[m] % mod;\n    &#125;;\n    long long res = 0ll;\n    for (int i = 2; i &lt;= n; ++i) &#123;\n        for (int j = 1; j &lt;= n; ++j)\n            (res += a[i] * (fac[n - 1] + mod - A(n - 1 - (j - std::max(1, j - k)), i - 1) * fac[n - i] % mod) % mod) %= mod;\n        for (int j = 2; j &lt;= n; ++j)\n            (res += a[i] * C(i - 1, i - 2) % mod * C(j - std::max(1, j - k), 1) % mod * A(n - (j - std::max(1, j - k) + 1), i - 2) % mod * fac[n - i] % mod) %= mod;\n    &#125;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"b---existence-counting\">B - Existence Counting</h2>\n<p><a href=\"https://atcoder.jp/contests/arc174/tasks/arc174_e\" class=\"uri\">https://atcoder.jp/contests/arc174/tasks/arc174_e</a></p>\n<p>发现可以分类讨论。假设 <span class=\"math inline\">\\(a&#39;\\)</span> 中第一个异于 <span class=\"math inline\">\\(a\\)</span> 的位置为 <span class=\"math inline\">\\(i\\)</span>，<span class=\"math inline\">\\(x\\)</span> 在 <span class=\"math inline\">\\(a\\)</span> 中位置为 <span class=\"math inline\">\\(pos_x\\)</span>（不存在则 <span class=\"math inline\">\\(pos_x=k+1\\)</span>）。令 <span class=\"math inline\">\\(f_i\\)</span> 为若 <span class=\"math inline\">\\(1\\sim i-1\\)</span> 均相同，<span class=\"math inline\">\\(i\\)</span> 位置可选的选项数。则 <span class=\"math inline\">\\(x\\)</span> 出现的次数：</p>\n<table>\n<colgroup>\n<col style=\"width: 25%\" />\n<col style=\"width: 25%\" />\n<col style=\"width: 25%\" />\n<col style=\"width: 25%\" />\n</colgroup>\n<thead>\n<tr class=\"header\">\n<th style=\"text-align: center;\"></th>\n<th style=\"text-align: center;\"><span class=\"math inline\">\\(pos_x&lt;i\\)</span></th>\n<th style=\"text-align: center;\"><span class=\"math inline\">\\(pos_x=i\\)</span></th>\n<th style=\"text-align: center;\"><span class=\"math inline\">\\(pos_x&gt;i,i&lt;k\\)</span></th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td style=\"text-align: center;\"><span class=\"math inline\">\\(x\\le a_i\\)</span></td>\n<td style=\"text-align: center;\"><span class=\"math inline\">\\(1+f_i\\cdot A_{n-i}^{k-i}\\)</span></td>\n<td style=\"text-align: center;\"><span class=\"math inline\">\\(f_i\\cdot C_{k-i}^1\\cdot A_{n-i-1}^{k-i-1}\\)</span></td>\n<td style=\"text-align: center;\"><span class=\"math inline\">\\((f_i-1)\\cdot C_{k-i}^1\\cdot A_{n-i-1}^{k-i-1}+A_{n-i}^{k-i}\\)</span></td>\n</tr>\n<tr class=\"even\">\n<td style=\"text-align: center;\"><span class=\"math inline\">\\(x&gt;a_i\\)</span></td>\n<td style=\"text-align: center;\"><span class=\"math inline\">\\(f_i\\cdot A_{n-i}^{k-i}\\)</span></td>\n<td style=\"text-align: center;\"><span class=\"math inline\">\\(0\\)</span></td>\n<td style=\"text-align: center;\"><span class=\"math inline\">\\(f_i\\cdot C_{k-i}^1\\cdot A_{n-i-1}^{k-i-1}\\)</span></td>\n</tr>\n</tbody>\n</table>\n<p>故，对于任意 <span class=\"math inline\">\\(x\\)</span>，答案为：</p>\n<p><span class=\"math display\">\\[\n\\begin{aligned}\n&amp;1+\\left(\\sum_{i=pos_x+1}^k f_i\\cdot A_{n-i}^{k-i}\\right)\n+\\sum_{i=1}^{pos_x} (f_i-[x&lt; a_i])\\cdot C_{k-i}^1\\cdot A_{n-i-1}^{k-i-1}+[x&lt; a_i]\\cdot A_{n-i}^{k-i}\\\\\n=&amp;1+\\left(\\sum_{i=pos_x+1}^k f_i\\cdot A_{n-i}^{k-i}\\right)\n+\\left(\\sum_{i=1}^{pos_x} f_i\\cdot C_{k-i}^1\\cdot A_{n-i-1}^{k-i-1}\\right)+\\sum_{i=1,a_i&gt; x}^{pos_x}A_{n-i}^{k-i}-C_{k-i}^1\\cdot A_{n-i-1}^{k-i-1}\\\\\n\\end{aligned}\n\\]</span></p>\n<p>预处理出 <span class=\"math inline\">\\(f_i=\\sum\\limits_{j=i+1}^k [a_j&lt; a_i]\\)</span>（需要数据结构）、<span class=\"math inline\">\\(g_i=\\sum\\limits_{j=1}^i f_j\\cdot A_{n-j}^{k-j}\\)</span> 和 <span class=\"math inline\">\\(h_j=\\sum\\limits_{j=1}^i f_i\\cdot C_{k-i}^1\\cdot A_{n-i-1}^{k-i-1}\\)</span>，再用数据结构计算 <span class=\"math inline\">\\(\\sum\\limits_{i=1,a_i&gt;x}^{pos_x}C_{k-i}^1\\cdot A_{n-i-1}^{k-i-1} - A_{n-i}^{k-i}\\)</span> 即可。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 998244353;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, k;\n    std::cin &gt;&gt; n &gt;&gt; k;\n    std::vector&lt;int&gt; a(k + 1), p(n + 1, k + 1);\n    for (int i = 1; i &lt;= k; ++i)\n        std::cin &gt;&gt; a[i], p[a[i]] = i;\n    std::vector&lt;long long&gt; fac(n + 1), inv(n + 1);\n    &#123;\n        fac[0] = inv[0] = 1ll;\n        for (int i = 1; i &lt;= n; ++i)\n            fac[i] = fac[i - 1] * i % mod;\n        auto qkp = [](long long x, int y) &#123;\n            auto res(1ll);\n            for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n                if (y &amp; 1)\n                    (res *= x) %= mod;\n            return res;\n        &#125;;\n        inv[n] = qkp(fac[n], mod - 2);\n        for (int i = n - 1; i; --i)\n            inv[i] = inv[i + 1] * (i + 1) % mod;\n    &#125;\n    auto A = [&amp;](int n, int m) &#123;\n        if (n &lt; m || m &lt; 0)\n            return 0ll;\n        return fac[n] * inv[n - m] % mod;\n    &#125;;\n    std::vector&lt;long long&gt; f(k + 1), g(k + 1), h(k + 1);\n    std::vector&lt;long long&gt; bit(n + 1);\n    auto lowbit = [](int x) &#123;\n        return x &amp; -x;\n    &#125;;\n    auto add = [&amp;](int x, int v) &#123;\n        for (; x &lt;= n; x += lowbit(x))\n            (bit[x] += v) %= mod;\n        return;\n    &#125;;\n    auto ask = [&amp;](int x) &#123;\n        auto res(0ll);\n        for (; x; x -= lowbit(x))\n            (res += bit[x]) %= mod;\n        return res;\n    &#125;;\n    for (int i = 1; i &lt;= n; ++i)\n        if (p[i] == k + 1)\n            add(i, 1);\n    for (int i = k; i; --i)\n        f[i] = ask(a[i]), add(a[i], 1);\n    for (int i = 1; i &lt;= k; ++i) &#123;\n        g[i] = (g[i - 1] + f[i] * A(n - i, k - i)) % mod;\n        h[i] = (h[i - 1] + f[i] * (k - i) % mod * A(n - i - 1, k - i - 1)) % mod;\n        // printf(&quot;%d: f = %lld, g = %lld, h = %lld\\n&quot;, i, f[i], g[i], h[i]);\n    &#125;\n    std::vector&lt;long long&gt; res(n + 1);\n    bit.assign(n + 1, 0ll);\n    auto s(0ll);\n    for (int i = 1; i &lt;= k; ++i) &#123;\n        // printf(&quot;%d: %lld + %lld + %lld\\n&quot;, a[i], 1 + g[k] - g[i], h[i], s - ask(a[i]));\n        res[a[i]] = (1 + g[k] - g[i] + h[i] + (s - ask(a[i]))) % mod;\n        res[a[i]] = (res[a[i]] + mod) % mod;\n        (s += A(n - i, k - i) - (k - i) * A(n - i - 1, k - i - 1)) %= mod;\n        add(a[i], (A(n - i, k - i) - (k - i) * A(n - i - 1, k - i - 1)) % mod);\n    &#125;\n    for (int i = 1; i &lt;= n; ++i)\n        if (p[i] == k + 1) &#123;\n            res[i] = (h[k] + (s - ask(i))) % mod;\n            res[i] = (res[i] + mod) % mod;\n        &#125;\n    for (int x = 1; x &lt;= n; ++x)\n        std::cout &lt;&lt; res[x] &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"c---1-loop-bubble-sort\">C - 1 Loop Bubble Sort</h2>\n<p><a href=\"https://atcoder.jp/contests/arc187/tasks/arc187_c\" class=\"uri\">https://atcoder.jp/contests/arc187/tasks/arc187_c</a></p>\n<p>首先是被考烂了的：对序列进行一次冒泡排序，等价于将序列在前缀最大值处分段，并将其从段首移到段尾；且满足排序前为前缀最大值的元素，排序后仍为前缀最大值。</p>\n<p>考虑用 DP 解决问题。注意状态要从 <span class=\"math inline\">\\(P\\)</span> 的角度出发——假如 <span class=\"math inline\">\\(Q\\)</span> 中不存在 <span class=\"math inline\">\\(-1\\)</span>，发现也需要 DP。此时再设计有关 <span class=\"math inline\">\\(Q\\)</span> 的状态就很扯淡了，考虑令 <span class=\"math inline\">\\(f_{i,j}\\)</span> 表示 <span class=\"math inline\">\\(P\\)</span> 中直到第 <span class=\"math inline\">\\(i\\)</span> 位的前缀最大值为 <span class=\"math inline\">\\(j\\)</span> 的方案数。为什么把前缀最大值作为状态呢？因为它可以表示分段；同时限制段间数的取值。具体地，考虑转移：</p>\n<ol type=\"1\">\n<li>若令 <span class=\"math inline\">\\(P_i=j\\)</span>，则在 <span class=\"math inline\">\\(i\\)</span> 处分段。对应到 <span class=\"math inline\">\\(Q\\)</span> 中，<span class=\"math inline\">\\(i-1\\)</span> 位是上一个前缀最大值，那么这要求 <span class=\"math inline\">\\(Q_{i-1}&lt;j\\)</span>，且 <span class=\"math inline\">\\(Q_{i-1}\\)</span> 是一个前缀最大值。也即：当 <span class=\"math inline\">\\(Q_{i-1}\\ne -1\\)</span> 时，<span class=\"math inline\">\\(f_{i,j}\\gets f_{i-1, Q_{i-1}}\\)</span>；否则，<span class=\"math inline\">\\(f_{i,j}\\gets \\sum\\limits_{k&lt;j} f_{i-1,k}\\)</span>。其中，二式都要求转移来源为前缀最大值。</li>\n<li>若令 <span class=\"math inline\">\\(P_i&lt;j\\)</span>，则 <span class=\"math inline\">\\(i\\)</span> 在 <span class=\"math inline\">\\(Q\\)</span> 中恰好前移一位，即 <span class=\"math inline\">\\(Q_{i-1}=P_i&lt;j\\)</span>。则当 <span class=\"math inline\">\\(Q_{i-1}\\ne -1\\)</span> 时，该位确定，<span class=\"math inline\">\\(f_{i,j}\\gets f_{i-1,j}\\)</span>；否则，<span class=\"math inline\">\\(Q_{i-1}\\)</span> 可选的值为 <span class=\"math inline\">\\(&lt;j\\)</span> 的所有未选数（定值，可预处理）。</li>\n</ol>\n<p>关于初值，可以在 <span class=\"math inline\">\\(P\\)</span> 前加一个 <span class=\"math inline\">\\(0\\)</span> 作为排列的一部分（那么按照冒泡排序的规则 <span class=\"math inline\">\\(Q\\)</span> 的第一位也一定是 <span class=\"math inline\">\\(0\\)</span>）来处理就好了。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 998244353;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;int&gt; q(n + 1), t(n + 1), c(n + 1), pos(n + 1);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; q[i], c[i] = c[i - 1];\n        if (q[i] == -1)\n            ++c[i];\n        else\n            pos[q[i]] = i;\n    &#125;\n    for (int i = 1; i &lt; n; ++i) &#123;\n        // printf(&quot;t[%d] = %d\\n&quot;, i, t[i]);\n        if (!pos[i])\n            for (int j = i + 1; j &lt;= n; ++j)\n                ++t[j];\n    &#125;\n    std::vector&lt;std::vector&lt;long long&gt; &gt; f(n + 1, std::vector&lt;long long&gt; (n + 1)), s(n + 1, std::vector&lt;long long&gt; (n + 1));\n    f[0][0] = 1ll;\n    s[0].assign(n + 1, 1ll);\n    for (int i = 1; i &lt;= n; ++i)\n        for (int j = 1; j &lt;= n; ++j) &#123;\n            if (q[i - 1] == -1)\n                f[i][j] = (s[i - 1][j - 1] + f[i - 1][j] * std::max(0, 1 + t[j] - c[i - 1])) % mod;\n            else if (q[i - 1] &lt; j)\n                f[i][j] = (f[i - 1][q[i - 1]] + f[i - 1][j]) % mod;\n            s[i][j] = s[i][j - 1];\n            if (q[i] == j || !pos[j]) // 满足前缀最大值\n                (s[i][j] += f[i][j]) %= mod;\n            // printf(&quot;f[%d][%d] = %lld\\n&quot;, i, j, f[i][j]);\n        &#125;\n    std::cout &lt;&lt; f[n][n] &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"f---1.-intro\">(F - 1). Intro</h2>\n<blockquote>\n<p>给定一个大小为 <span class=\"math inline\">\\(n\\)</span> 的树，点有点权。给定 <span class=\"math inline\">\\(q\\)</span> 次操作，分为两种：</p>\n<ol type=\"1\">\n<li><code>1 x</code>：查询 <span class=\"math inline\">\\(x\\)</span> 的点权。</li>\n<li><code>2 x d v</code> 对于所有距 <span class=\"math inline\">\\(x\\)</span> 不超过 <span class=\"math inline\">\\(d\\)</span> 的点，将它们的权值加上 <span class=\"math inline\">\\(v\\)</span>。</li>\n</ol>\n<p><span class=\"math inline\">\\(n,q\\le 10^5,d\\le 20\\)</span>。</p>\n</blockquote>\n<p>由于 <span class=\"math inline\">\\(d\\)</span> 很小，我们可能需要枚举与 <span class=\"math inline\">\\(x\\)</span> 距离 <span class=\"math inline\">\\(0\\sim d\\)</span> 的点进行修改；那么对距离 <span class=\"math inline\">\\(x\\)</span> 为 <span class=\"math inline\">\\(i\\)</span> 的点的更改存储在 <span class=\"math inline\">\\(f_{x,i}\\)</span>，查询 <span class=\"math inline\">\\(v\\)</span> 时就可以从 <span class=\"math inline\">\\(\\sum\\limits_i f_{fa(v,i),i}\\)</span> 求得答案。</p>\n<p>考虑修改。记 <span class=\"math inline\">\\(S_{x,d}\\)</span> 为距 <span class=\"math inline\">\\(x\\)</span> 为 <span class=\"math inline\">\\(d\\)</span> 的点集。<span class=\"math inline\">\\(x\\)</span> 子树内是好处理的，但子树外的呢？发现 <span class=\"math inline\">\\(S_{fa,d-1}\\)</span> 中 <span class=\"math inline\">\\(x\\)</span> 子树外的点，就是 <span class=\"math inline\">\\(fa\\)</span> 子树下、<span class=\"math inline\">\\(x\\)</span> 子树外距离 <span class=\"math inline\">\\(x\\)</span> 为 <span class=\"math inline\">\\(d\\)</span> 的所有点。</p>\n<p>由于所有 <span class=\"math inline\">\\(S_{fa(x,i),d-i}\\)</span> 无交，这可能满足我们每个待操作点被不重不漏加一次的要求。考虑将所有 <span class=\"math inline\">\\(S_{fa(x,i),d-i}\\)</span> 标记出来：</p>\n<figure>\n<img src=\"1.png\" alt=\"粉色虚线框是待操作点集\" /><figcaption>粉色虚线框是待操作点集</figcaption>\n</figure>\n<p>然后我们可以一眼发现被叉的点和未被叉的待操作点是交错的！这意味着我们只需要再补充上所有 <span class=\"math inline\">\\(S_{fa(x,i),d-i-1}\\)</span> 即可（显然它们之间、它们和所有 <span class=\"math inline\">\\(S_{fa(x,i),d-i}\\)</span> 之间都不交）。</p>\n<figure>\n<img src=\"2.png\" alt=\"虚线叉为 S_{fa(x,i),d-i-1}\" /><figcaption>虚线叉为 <span class=\"math inline\">\\(S_{fa(x,i),d-i-1}\\)</span></figcaption>\n</figure>\n<p>此时就可以不重不漏。当然，也会存在一些细节：比如说 <span class=\"math inline\">\\(fa(x,i)\\)</span> 不存在之类。只需要在根节点 <span class=\"math inline\">\\(1\\)</span> 处将剩余的 <span class=\"math inline\">\\(S_{1,i\\to 0}\\)</span> 全部更新即可。</p>\n<p>故每次修改操作只需要修改 <span class=\"math inline\">\\(O(d)\\)</span> 坨点。时间复杂度 <span class=\"math inline\">\\(O(qd)\\)</span>。</p>\n<hr />\n<h2 id=\"f.-distance-to-the-path\">F. Distance to the Path</h2>\n<p><a href=\"https://codeforces.com/problemset/problem/1749/F\" class=\"uri\">https://codeforces.com/problemset/problem/1749/F</a></p>\n<p>本例中将单点修改替换为路径修改；考虑树剖解决问题。</p>\n<p>对于路径上的所有点 <span class=\"math inline\">\\(u\\)</span>，容易发现只需要修改所有的 <span class=\"math inline\">\\(S_{u,d}\\)</span> 就可以完成对『<strong>一部分路径内侧的点</strong>』的修改。这『一部分』，是因为不包括距离 LCA <span class=\"math inline\">\\(\\le d\\)</span> 的点。</p>\n<p>而『<strong>另一部分路径内侧的点</strong>（距 LCA <span class=\"math inline\">\\(\\le d\\)</span>：见上一行说明）』及『<strong>路径外侧的点</strong>（距 LCA <span class=\"math inline\">\\(\\le d\\)</span>：因为路径在 LCA 子树内，LCA 能够到最远的外侧点）』，等价于『<strong>距 LCA <span class=\"math inline\">\\(\\le d\\)</span> 的点</strong>』，只需要把 LCA 代入上例中方式修改即可。</p>\n<p>修改路径上所有点 <span class=\"math inline\">\\(u\\)</span> 的 <span class=\"math inline\">\\(S_{u,d}\\)</span> 时，可以对所有 <span class=\"math inline\">\\(f_{*,i}\\)</span> 建立数据结构，由于只需要区间修改、单点查询，使用差分树状数组即可。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt; \nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, m;\n    std::cin &gt;&gt; n;\n    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);\n    for (int i = 1, x, y; i &lt; n; ++i) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y;\n        g[x].push_back(y), g[y].push_back(x);\n    &#125;\n    std::vector&lt;int&gt; siz(n + 1), dep(n + 1), fa(n + 1), son(n + 1);\n    std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int faa) &#123;\n        siz[x] = 1;\n        for (auto i : g[x])\n            if (i != faa) &#123;\n                fa[i] = x, dep[i] = dep[x] + 1;\n                DFS(i, x);\n                siz[x] += siz[i];\n                if (siz[i] &gt; siz[son[x]])\n                    son[x] = i;\n            &#125;\n        return;\n    &#125;;\n    DFS(1, -1);\n    std::vector&lt;int&gt; dfn(n + 1), top(n + 1);\n    DFS = [&amp;](int x, int toop) &#123;\n        static int now = 0;\n        dfn[x] = ++now, top[x] = toop;\n        if (son[x])\n            DFS(son[x], toop);\n        for (auto i : g[x])\n            if (i != fa[x] &amp;&amp; i != son[x])\n                DFS(i, i);\n        return;\n    &#125;;\n    DFS(1, 1);\n    std::vector&lt;std::vector&lt;long long&gt; &gt; bit(21, std::vector&lt;long long&gt; (n + 1));\n    auto lowbit = [&amp;](int x) &#123;\n        return x &amp; -x;\n    &#125;;\n    auto add = [&amp;](auto &amp;bit, int x, int v) &#123;\n        for (; x &lt;= n; x += lowbit(x))\n            bit[x] += v;\n        return;\n    &#125;;\n    auto ask = [&amp;](auto &amp;bit, int x) &#123;\n        auto res(0ll);\n        for (; x; x -= lowbit(x))\n            res += bit[x];\n        return res;\n    &#125;;\n    std::cin &gt;&gt; m;\n    for (int op; m--; ) &#123;\n        std::cin &gt;&gt; op;\n        if (op == 1) &#123;\n            int x;\n            std::cin &gt;&gt; x;\n            auto res(0ll);\n            for (int i = 0; i &lt;= 20 &amp;&amp; x; ++i, x = fa[x])\n                res += ask(bit[i], dfn[x]);\n            std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n        &#125;\n        else &#123;\n            int x, y, v, d;\n            std::cin &gt;&gt; x &gt;&gt; y &gt;&gt; v &gt;&gt; d;\n            for (; top[x] != top[y]; x = fa[top[x]]) &#123;\n                if (dep[top[x]] &lt; dep[top[y]])\n                    std::swap(x, y);\n                add(bit[d], dfn[top[x]], v);\n                add(bit[d], dfn[x] + 1, -v);\n            &#125;\n            if (dep[x] &gt; dep[y])\n                std::swap(x, y);\n            add(bit[d], dfn[x] + 1, v), add(bit[d], dfn[y] + 1, -v);\n            for (x = x, y = d; ~y &amp;&amp; x; x = fa[x], --y) &#123;\n                add(bit[y], dfn[x], v), add(bit[y], dfn[x] + 1, -v);\n                if (y &amp;&amp; fa[x])\n                    add(bit[y - 1], dfn[x], v), add(bit[y - 1], dfn[x] + 1, -v);\n            &#125;\n            if (x == 0)\n                for (; ~y; --y)\n                    add(bit[y], dfn[1], v), add(bit[y], dfn[1] + 1, -v);\n        &#125;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"a---ina-of-the-mountain\">A - Ina of the Mountain</h2>\n<p><a href=\"https://codeforces.com/problemset/problem/1852/C\" class=\"uri\">https://codeforces.com/problemset/problem/1852/C</a></p>\n<p>考虑这么一个简化版的问题：</p>\n<blockquote>\n<p>给定 <span class=\"math inline\">\\(\\{a_n\\}\\)</span>，每次可以进行区间 <span class=\"math inline\">\\(-1\\)</span>，问操作多少次才能将所有元素变为 <span class=\"math inline\">\\(0\\)</span>。</p>\n</blockquote>\n<p>会想到差分；对原数组进行差分，一次操作相当于令 <span class=\"math inline\">\\(d_l\\gets d_l-1\\)</span> 而 <span class=\"math inline\">\\(d_{r+1}\\gets d_{r+1}+1\\)</span>，最后要让 <span class=\"math inline\">\\(\\forall \\,d_i=0\\)</span>。那么答案就是差分数组中正数之和嘛。</p>\n<p>回到原问题。原问题等价于把上述问题变为：</p>\n<blockquote>\n<p>给定 <span class=\"math inline\">\\(\\{a_n\\}\\)</span>，每次可以进行区间 <span class=\"math inline\">\\(-1\\)</span>，每个数的总操作次数对 <span class=\"math inline\">\\(k\\)</span> 取模，问操作多少次才能将所有元素变为 <span class=\"math inline\">\\(0\\)</span>。</p>\n</blockquote>\n<p>怎么套回到刚刚的问题上呢？还原被取模掉的操作即可。具体来说，提前在 <span class=\"math inline\">\\(d\\)</span> 上进行若干次操作（记为操作 1），形如令 <span class=\"math inline\">\\(d_i\\gets d_i+k\\)</span>，同时 <span class=\"math inline\">\\(d_{i+1}\\gets d_{i+1}-k\\)</span>。</p>\n<p>会发现相邻的操作 <span class=\"math inline\">\\(1\\)</span> 对一个数加加减减影响判断；发现可以合并一段连续的操作 1，表现在 <span class=\"math inline\">\\(a\\)</span> 上也就是区间 <span class=\"math inline\">\\(+k\\)</span>。此时可以发现，一个位置上只会剩下若干次 <span class=\"math inline\">\\(+k\\)</span> 或若干次 <span class=\"math inline\">\\(-k\\)</span> （否则可以把 <span class=\"math inline\">\\(+k\\)</span> 和 <span class=\"math inline\">\\(-k\\)</span> 代表的不同操作合并），就不会有互相影响一说了。这也是有的题解说可以提前在 <span class=\"math inline\">\\(a\\)</span> 上区间 <span class=\"math inline\">\\(+k\\)</span> 的原因。</p>\n<p>此时问题变为在 <span class=\"math inline\">\\(d\\)</span> 进行任意次前加 <span class=\"math inline\">\\(k\\)</span> 后减 <span class=\"math inline\">\\(k\\)</span> 的操作，使得 <span class=\"math inline\">\\(\\sum\\limits_{d_i&gt;0}d_i\\)</span> 最大化。那么显然如果要使代价更小，只可能在原本 <span class=\"math inline\">\\(&lt;0\\)</span> 的位置做加法、<span class=\"math inline\">\\(&gt;0\\)</span> 的位置做减法（其他情况会发现一定不优）。考虑两个数 <span class=\"math inline\">\\(d_l,d_r\\)</span>，可以感受到对于一个 <span class=\"math inline\">\\(r\\)</span>，选最小的 <span class=\"math inline\">\\(d_l\\)</span> 是最优的，但什么时候应该选呢？</p>\n<ul>\n<li><span class=\"math inline\">\\(d_l\\le -k,d_r\\ge k\\)</span>：当然可选，<span class=\"math inline\">\\(k\\)</span> 被完全利用，答案减少 <span class=\"math inline\">\\(k\\)</span>。</li>\n<li><p><span class=\"math inline\">\\(d_l&gt;-k,d_r\\ge k\\)</span>：此时 <span class=\"math inline\">\\(k\\)</span> 未被完全利用，但必须选：选择其他更大的数，<span class=\"math inline\">\\(k\\)</span> 的利用率只会更低；如果不选，答案也无法减少。</p>\n<p>Q：此时是否需要尝试找到一个 <span class=\"math inline\">\\(l&#39;&lt;l\\)</span> 与 <span class=\"math inline\">\\(l\\)</span> 做操作，使得 <span class=\"math inline\">\\(l\\)</span> 重新变为负数呢？</p>\nA：否。因为你可以将这两次操作合并，发现相当于是直接对 <span class=\"math inline\">\\((l&#39;,r)\\)</span> 做操作，是更劣的。</li>\n<li><span class=\"math inline\">\\(d_l\\le -k,d_r&lt;k\\)</span>：此时 <span class=\"math inline\">\\(k\\)</span> 未被完全利用，<span class=\"math inline\">\\(d_r\\)</span> 成为负数。这意味着 <span class=\"math inline\">\\(d_r\\)</span> 将会成为某个 <span class=\"math inline\">\\(r&#39;\\)</span> 的可选项。考察 <span class=\"math inline\">\\(d_{r&#39;}\\)</span> 可用的最小值。如果 <span class=\"math inline\">\\(d_r\\)</span> 在当前不应该作为右端点，它就一定会被 <span class=\"math inline\">\\(d_{r&#39;}\\)</span> 选择。具体的有点抽象，但是你可以理解为 <span class=\"math inline\">\\(d_r\\)</span> 选了 <span class=\"math inline\">\\(d_l\\)</span> 的贡献是被整合到 <span class=\"math inline\">\\(d_r\\)</span> 里的；如果 <span class=\"math inline\">\\(d_r\\)</span> 被选了就说明 <span class=\"math inline\">\\(d_{r&#39;}\\)</span> 选 <span class=\"math inline\">\\(d_l\\)</span> 会拥有更大的优势。</li>\n<li><p><span class=\"math inline\">\\(d_l&gt;-k,d_r&lt;k\\)</span>：和上面的情况相似；但这种情况下答案可能反而变得更大，因为没有后效性，所以至少要保证单步最优。此时不能选。</p>\n<p>说到单步最优，就会发现这里就是反悔贪心；单步最优一定是全局最优，但更靠前的局部最优可能被否定掉。而『否定』的方法表现为一次操作。</p></li>\n</ul>\n<p>综上，从前往后扫，优先队列实时维护负数最小值，对于每个正数，check 选最小值是否优于当前答案，有就选。如果正数被减为负，加入队列。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int T;\n    for (std::cin &gt;&gt; T; T--; ) &#123;\n        int n, k;\n        std::cin &gt;&gt; n &gt;&gt; k;\n        std::vector&lt;int&gt; a(n + 1), d(n + 1);\n        long long res(0ll);\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            std::cin &gt;&gt; a[i], a[i] %= k;\n            d[i] = a[i] - a[i - 1];\n            if (d[i] &gt; 0)\n                (res += d[i]);\n        &#125;\n        std::priority_queue&lt;int&gt; q;\n        for (int i = 1; i &lt;= n; ++i)\n            if (d[i] &lt; 0)\n                q.push(-d[i]);\n            else &#123;\n                for (; !q.empty() &amp;&amp; d[i] &gt; 0; ) &#123;\n                    int x = -q.top(), y = d[i];\n                    auto t(res - y);\n                    x += k, y -= k;\n                    if (x &gt; 0)\n                        t += x;\n                    if (y &gt; 0)\n                        t += y;\n                    if (t &gt;= res)\n                        break;\n                    q.pop();\n                    res = t, d[i] = y;\n                    if (d[i] &lt; 0)\n                        q.push(-d[i]);\n                &#125;\n            &#125;\n        std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"b---miriany-and-matchstick\">B - Miriany and Matchstick</h2>\n<p><a href=\"https://codeforces.com/problemset/problem/1852/D\" class=\"uri\">https://codeforces.com/problemset/problem/1852/D</a></p>\n<p>从构造的角度出发，看到『恰好为 <span class=\"math inline\">\\(k\\)</span>』，会想到找到上界和下界并证明中间每一个数都能取到。</p>\n<p>但似乎很容易证伪：例如对于 <code>AAAA</code>，下界为 <span class=\"math inline\">\\(0\\)</span>，上界为 <span class=\"math inline\">\\(4\\)</span>，但有且仅有 <span class=\"math inline\">\\(1\\)</span> 取不到。但该想法并未破产——可以感受到这样的位置很少。进一步地，你 <a href=\"https://www.luogu.com.cn/article/2mmg5rjd\">可以证明只有一个这样的位置</a>，也可以 <a href=\"https://www.luogu.com.cn/article/679cwjgl\">大胆猜想这样的位置一定出现在 <span class=\"math inline\">\\(l+1\\)</span>，<span class=\"math inline\">\\(r-1\\)</span></a>。总之现在我们的状态就减少了（或者说状态变成 DP 值了）。预处理出这个东西之后大力搜索找方案即可。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int T;\n    for (std::cin &gt;&gt; T; T--; ) &#123;\n        int n, k;\n        std::cin &gt;&gt; n &gt;&gt; k;\n        std::vector&lt;int&gt; a(n + 1);\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            char t;\n            std::cin &gt;&gt; t, a[i] = (t == &#39;A&#39;);\n            if (i &gt;= 2)\n                k -= (a[i] ^ a[i - 1]);\n        &#125;\n        std::vector&lt;std::array&lt;std::tuple&lt;int, int, int&gt;, 2&gt; &gt; f(n + 1);\n        f[n][0] = &#123; a[n], a[n], 0 &#125;, f[n][1] = &#123; !a[n], !a[n], 0 &#125;;\n        auto merge = [&amp;](int i, int l0, int r0, int p0, int l1, int r1, int p1) &#123;\n            if (l0 &gt; l1)\n                std::swap(l0, l1), std::swap(r0, r1), std::swap(p0, p1);\n            int l = l0, r = std::max(r0, r1), p = 0;\n            if (!p0 &amp;&amp; !p1) &#123;\n                if (r0 &lt; l1 - 1)\n                    assert(r0 == l1 - 2), p = r0 + 1;\n                else;\n            &#125;\n            else if (p0 &amp;&amp; p1) &#123;\n                if (p0 == p1)\n                    p = p0;\n                else &#123;\n                    int tag0 = (l1 &lt;= p0 &amp;&amp; p0 &lt;= r1), tag1 = (l0 &lt;= p1 &amp;&amp; p1 &lt;= r0);\n                    if (!tag0 &amp;&amp; !tag1);\n                    else if (!tag0)\n                        p = p0;\n                    else if (!tag1)\n                        p = p1;\n                    else;\n                &#125;\n            &#125;\n            else if (p0) &#123;\n                if (l1 &lt;= p0 &amp;&amp; p0 &lt;= r1);\n                else\n                    p = p0;\n            &#125;\n            else &#123;\n                if (l0 &lt;= p1 &amp;&amp; p1 &lt;= r0);\n                else\n                    p = p1;\n            &#125;\n            assert(p != l &amp;&amp; p != r &amp;&amp; l &lt;= r);\n            return std::make_tuple(l, r, p);\n        &#125;;\n        for (int i = n - 1; i; --i) &#123;\n            &#123;\n                auto [l0, r0, p0] = f[i + 1][0];\n                auto [l1, r1, p1] = f[i + 1][1];\n                if (a[i]) &#123;\n                    ++l0, ++r0, ++l1, ++r1;\n                    if (p0) ++p0;\n                    if (p1) ++p1;\n                &#125;\n                ++l1, ++r1;\n                if (p1) ++p1;\n                f[i][0] = merge(i, l0, r0, p0, l1, r1, p1);\n            &#125;\n            &#123;\n                auto [l0, r0, p0] = f[i + 1][0];\n                auto [l1, r1, p1] = f[i + 1][1];\n                if (!a[i]) &#123;\n                    ++l0, ++r0, ++l1, ++r1;\n                    if (p0) ++p0;\n                    if (p1) ++p1;\n                &#125;\n                ++l0, ++r0;\n                if (p0) ++p0;\n                f[i][1] = merge(i, l0, r0, p0, l1, r1, p1);\n            &#125;\n        &#125;\n        std::vector&lt;int&gt; res(n + 1);\n        std::function&lt;bool(int, int, int)&gt; DFS = [&amp;](int x, int cnt, int la) &#123;\n            if (x == n + 1)\n                return cnt == k;\n            auto [l0, r0, p0] = f[x][0];\n            auto [l1, r1, p1] = f[x][1];\n            if (cnt + (la == 1) + l0 &lt;= k &amp;&amp; cnt + (la == 1) + r0 &gt;= k &amp;&amp; (!p0 || cnt + (la == 1) + p0 != k) &amp;&amp; DFS(x + 1, cnt + (la == 1) + a[x], 0))\n                res[x] = 0;\n            else if (cnt + !la + l1 &lt;= k &amp;&amp; cnt + !la + r1 &gt;= k &amp;&amp; (!p1 || cnt + !la + p1 != k) &amp;&amp; DFS(x + 1, cnt + !la + !a[x], 1))\n                res[x] = 1;\n            else\n                return false;\n            return true;\n        &#125;;\n        if (DFS(1, 0, -1)) &#123;\n            std::cout &lt;&lt; &quot;YES\\n&quot;;\n            for (int i = 1; i &lt;= n; ++i)\n                std::cout &lt;&lt; (res[i] ? &#39;A&#39; : &#39;B&#39;);\n            std::cout &lt;&lt; &#39;\\n&#39;;\n        &#125;\n        else\n            std::cout &lt;&lt; &quot;NO\\n&quot;;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n",
            "tags": [
                "DP",
                "容斥原理",
                "树链剖分",
                "反悔贪心"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20250421/",
            "url": "https://xsc062.netlify.app/20250421/",
            "title": "杂题",
            "date_published": "2025-04-21T06:42:31.000Z",
            "content_html": "<figure>\n<img src=\"/20250421/neko.png\" alt=\"猫\" style=\"width: 75px\">\n<figcaption>\n猫\n</figcaption>\n</figure>\n<span id=\"more\"></span>\n<hr />\n<h2 id=\"a---t-shirt\">A - T-shirt</h2>\n<p><a href=\"https://codeforces.com/problemset/problem/183/D\" class=\"uri\">https://codeforces.com/problemset/problem/183/D</a></p>\n<p>如果知道一个衣服序列，怎么算出期望呢？</p>\n<hr />\n<h2 id=\"b---two-melodies\">B - Two Melodies</h2>\n<p><a href=\"https://codeforces.com/problemset/problem/813/D\" class=\"uri\">https://codeforces.com/problemset/problem/813/D</a></p>\n<p>如果设 <span class=\"math inline\">\\(f_{i,j}\\)</span> 表示第一个以 <span class=\"math inline\">\\(i\\)</span> 结尾，第二个以 <span class=\"math inline\">\\(j\\)</span> 结尾的方案数，就会有一个弊端——假设现在有 <span class=\"math inline\">\\(i&gt;j\\)</span>，又假设有 <span class=\"math inline\">\\(j&lt;j&#39;&lt;i\\)</span>，那么就不可以直接把 <span class=\"math inline\">\\(f_{i,j}\\)</span> 转移到 <span class=\"math inline\">\\(f_{i,j&#39;}\\)</span>，因为 <span class=\"math inline\">\\(j&#39;\\)</span> 可能已经被第一个选过了。但如果从 <span class=\"math inline\">\\(i\\)</span> 转移就没有这样的问题（不管 <span class=\"math inline\">\\(i&#39;\\)</span> 是比 <span class=\"math inline\">\\(j\\)</span> 大还是比 <span class=\"math inline\">\\(j\\)</span> 小）。</p>\n<p>那就可以固定从较大的一维转移，也可以枚举所有情况。但是这样就会有一个问题，这是一个 <span class=\"math inline\">\\(n^3\\)</span> 的过程，而且对于不单调的内层 <span class=\"math inline\">\\(j\\)</span>，维护它的数值只能用带 <span class=\"math inline\">\\(\\log\\)</span> 的数据结构优化，似乎不太过得了；但 <span class=\"math inline\">\\(i\\)</span> 却可以前缀优化。</p>\n<p>其实，两个组是无序的，这意味着可以强制 <span class=\"math inline\">\\(i&gt;j\\)</span> 再从 <span class=\"math inline\">\\(i\\)</span> 转移；这个时候转移就和 <span class=\"math inline\">\\(j\\)</span> 没有太大的关系了，可以把 <span class=\"math inline\">\\(j\\)</span> 放到外层，对 <span class=\"math inline\">\\(i\\)</span> 前缀优化。可能需要注意边界的处理。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, res = 0;\n    std::cin &gt;&gt; n;\n    std::vector&lt;int&gt; a(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i];\n    std::vector&lt;std::vector&lt;int&gt; &gt; f(n + 1, std::vector&lt;int&gt; (n + 1));\n    for (int j = 0; j &lt; n; ++j) &#123;\n        std::vector&lt;int&gt; mx(100002), mmx(7);\n        for (int i = 1; i &lt; j; ++i) &#123;\n            mx[a[i]] = std::max(mx[a[i]], f[j][i]);\n            mmx[a[i] % 7] = std::max(mmx[a[i] % 7], f[j][i]);\n        &#125;\n        for (int i = j + 1; i &lt;= n; ++i) &#123;\n            f[i][j] = std::max(&#123; !!i + !!j, mx[a[i] - 1] + 1, mx[a[i] + 1] + 1, mmx[a[i] % 7] + 1, f[j][0] + 1 &#125;);\n            mx[a[i]] = std::max(mx[a[i]], f[i][j]);\n            mmx[a[i] % 7] = std::max(mmx[a[i] % 7], f[i][j]);\n            // printf(&quot;f[%d][%d] = %d\\n&quot;, i, j, f[i][j]);\n            res = std::max(res, f[i][j]);\n        &#125;\n    &#125;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"cf633f-the-chocolate-spree\">CF633F The Chocolate Spree</h2>\n<p><a href=\"https://codeforces.com/problemset/problem/633/F\" class=\"uri\">https://codeforces.com/problemset/problem/633/F</a></p>\n<p>树形 DP 求直径的时候，有一种方法是找到每个点下面的最大两条不交链。</p>\n<p>这里也可以有类似的求法。假设答案出现在子树 <span class=\"math inline\">\\(u\\)</span> 中（下面的 <span class=\"math inline\">\\(v_i\\)</span> 都是 <span class=\"math inline\">\\(u\\)</span> 的直接儿子），可以讨论 <span class=\"math inline\">\\(u\\)</span> 参与构成两条路径的情况：</p>\n<ol type=\"1\">\n<li>不参与构成任何一条路径，答案是 <span class=\"math inline\">\\(v_1,v_2\\)</span> 子树中的最长路径之和。</li>\n<li><p>参与构成其中一条：</p>\n<ol type=\"1\">\n<li>这一条与子树 <span class=\"math inline\">\\(v\\)</span> 完全相离，答案是 <span class=\"math inline\">\\(v\\)</span> 中最长路径，和 <span class=\"math inline\">\\(u\\)</span> 下面不经过 <span class=\"math inline\">\\(v\\)</span> 的最大两条不交链。</li>\n<li>这一条有一支来自 <span class=\"math inline\">\\(v\\)</span> 子树，但和 <span class=\"math inline\">\\(v\\)</span> 中最长路径没有重合的点。答案是 <span class=\"math inline\">\\(u\\)</span> 的点权、<span class=\"math inline\">\\(u\\)</span> 下面不经过 <span class=\"math inline\">\\(v\\)</span> 的最大链、<span class=\"math inline\">\\(v\\)</span> 中一条路径（不经过 <span class=\"math inline\">\\(v\\)</span>）和 <span class=\"math inline\">\\(v\\)</span> 下面一条链之和的最大值；</li>\n<li>这一条两支都来自 <span class=\"math inline\">\\(v\\)</span> 子树：有重合，不可能发生。</li>\n</ol></li>\n<li><p>参与构成其中两条，答案是 <span class=\"math inline\">\\(u\\)</span> 下面最长的四条链：路径重复经过 <span class=\"math inline\">\\(u\\)</span>，不可能发生。</p></li>\n</ol>\n<p><img src=\"2.png\" /></p>\n<p>可以记录 <span class=\"math inline\">\\(u\\)</span> 下方最大的四条不交链、<span class=\"math inline\">\\(u\\)</span> 中选取一条不经过 <span class=\"math inline\">\\(u\\)</span> 的路径和 <span class=\"math inline\">\\(u\\)</span> 下方一条链之和的最大值、<span class=\"math inline\">\\(u\\)</span> 中最长路径求解。</p>\n<details>\n<pre class=\"cpp language-cpp\" data-line=\"42-44\"><code class=\"cpp langauage-cpp\">#include &lt;bits/stdc++.h>\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(\".in\", \"r\", stdin);\n    std::freopen(\".out\", \"w\", stdout);\n#endif\n    int n;\n    std::cin >> n;\n    std::vector&lt;int> a(n + 1);\n    std::vector&lt;std::vector&lt;int> > g(n + 1);\n    for (int i = 1; i <= n; ++i)\n        std::cin >> a[i];\n    for (int i = 1, x, y; i < n; ++i) &#123;\n        std::cin >> x >> y;\n        g[x].push_back(y), g[y].push_back(x);\n    &#125;\n    auto res(0ll);\n    std::vector&lt;long long> s(n + 1), w(n + 1);\n    std::vector&lt;std::vector&lt;std::pair&lt;long long, int> > > f(n + 1, std::vector&lt;std::pair&lt;long long, int> > (4));\n    std::function&lt;void(int, int)> DFS = [&](int x, int fa) &#123;\n        f[x][0] = &#123; 0, x &#125;;\n        w[x] = s[x] = a[x];\n        for (auto i : g[x])\n            if (i != fa) &#123;\n                DFS(i, x);\n                &#123;\n                    if (f[i][0].first + a[i] > f[x][3].first)\n                        f[x][3].first = f[i][0].first + a[i], f[x][3].second = i;\n                    std::sort(f[x].begin(), f[x].end(), std::greater&lt;std::pair&lt;long long, int> > ());\n                &#125;\n                w[x] = std::max(w[x], w[i] + a[x]);\n            &#125;\n        auto mx(0ll);\n        for (auto i : g[x])\n            if (i != fa) &#123;\n                s[x] = std::max(&#123; s[x], s[i], f[x][0].first + f[x][1].first + a[x] &#125;);\n                w[x] = std::max(w[x], (f[x][0].second != i ? f[x][0] : f[x][1]).first + s[i] + a[x]);\n                res = std::max(&#123; res,\n                    mx + s[i], // 情况 1\n                    (f[x][0].second == i ? f[x][1].first + f[x][2].first : (f[x][1].second == i ? f[x][0].first + f[x][2].first : f[x][0].first + f[x][1].first)) + s[i] + a[x], // 情况 2.1\n                    (f[x][0].second == i ? f[x][1].first : f[x][0].first) + w[i] + a[x], // 情况 2.2\n                &#125;);\n                mx = std::max(mx, s[i]);\n            &#125;\n    //     printf(\"%d: res = %lld\\n  f: \\n\", a[x], res);\n    //     for (int i = 0; i < 4; ++i)\n    //         printf(\"    [%d] %lld\\n\", f[x][i].second, f[x][i].first);\n    //     printf(\"  s: %lld\\n  w: %lld\\n\", s[x], w[x]);\n    &#125;;\n    DFS(1, -1);\n    std::cout << res << '\\n';\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"c---巡逻\">C - 巡逻</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P3629\" class=\"uri\">https://www.luogu.com.cn/problem/P3629</a></p>\n<p>你可能需要注意：目的是遍历所有边而非所有点。</p>\n<p><span class=\"math inline\">\\(K=1\\)</span> 的时候，环上除了关键边的所有边经过次数会减 <span class=\"math inline\">\\(1\\)</span>。所以选树的直径就可以最优。</p>\n<p><span class=\"math inline\">\\(K=2\\)</span> 的时候，答案是 <span class=\"math inline\">\\(2\\times (m + 2)\\)</span> 减去两个边构成的环的 <em>并集减交集</em> 大小 <span class=\"math inline\">\\(L\\)</span>。环实际上是不存在的，<span class=\"math inline\">\\(L\\)</span> 其实是两条路径 <em>并集减交集</em> 再加上两条新边的值。</p>\n<p>两条路径有交的时候，可以等效成无交的情况：</p>\n<p><img src=\"1.png\" /></p>\n<p>就化归成上一个问题了。注意此时情况 3 可能发生；同时情况 2.2 可以选取经过 <span class=\"math inline\">\\(v\\)</span> 的路径。</p>\n<details>\n<pre class=\"cpp language-cpp\" data-line=\"55-56,64-67\"><code class=\"cpp langauage-cpp\">#include &lt;bits/stdc++.h>\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(\".in\", \"r\", stdin);\n    std::freopen(\".out\", \"w\", stdout);\n#endif\n    int n, k;\n    std::cin >> n >> k;\n    std::vector&lt;std::vector&lt;int> > g(n + 1);\n    for (int i = 1, x, y; i < n; ++i) &#123;\n        std::cin >> x >> y;\n        g[x].push_back(y), g[y].push_back(x);\n    &#125;\n    int res = 0;\n    if (k == 1) &#123;\n        std::vector&lt;std::vector&lt;std::pair&lt;int, int> > > f(n + 1, std::vector&lt;std::pair&lt;int, int> > (2));\n        std::function&lt;void(int, int)> DFS = [&](int x, int fa) &#123;\n            f[x][0] = &#123; 0, x &#125;;\n            for (auto i : g[x])\n                if (i != fa) &#123;\n                    DFS(i, x);\n                    &#123;\n                        if (f[i][0].first + 1 > f[x][1].first)\n                            f[x][1].first = f[i][0].first + 1, f[x][1].second = i;\n                        std::sort(f[x].begin(), f[x].end(), std::greater&lt;std::pair&lt;int, int> > ());\n                    &#125;\n                &#125;\n            res = std::max(res, f[x][0].first + f[x][1].first);\n        &#125;;\n        DFS(1, -1);\n        std::cout << 2 * n - res - 1 << '\\n';\n    &#125;\n    else &#123;\n        std::vector&lt;int> s(n + 1), w(n + 1);\n        std::vector&lt;std::vector&lt;std::pair&lt;int, int> > > f(n + 1, std::vector&lt;std::pair&lt;int, int> > (4));\n        std::function&lt;void(int, int)> DFS = [&](int x, int fa) &#123;\n            f[x][0] = &#123; 0, x &#125;;\n            for (auto i : g[x])\n                if (i != fa) &#123;\n                    DFS(i, x);\n                    &#123;\n                        if (f[i][0].first + 1 > f[x][3].first)\n                            f[x][3].first = f[i][0].first + 1, f[x][3].second = i;\n                        std::sort(f[x].begin(), f[x].end(), std::greater&lt;std::pair&lt;int, int> > ());\n                    &#125;\n                    w[x] = std::max(w[x], w[i] + 1);\n                &#125;\n            &#123;\n                int t = 0;\n                for (auto [v, id] : f[x])\n                    t += v;\n                res = std::max(res, t); // 情况 3\n                w[x] = std::max(w[x], t - f[x][3].first); // 路径可经过 u\n            &#125;\n            int mx = 0;\n            for (auto i : g[x])\n                if (i != fa) &#123;\n                    s[x] = std::max(&#123; s[x], s[i], f[x][0].first + f[x][1].first &#125;);\n                    w[x] = std::max(w[x], (f[x][0].second != i ? f[x][0] : f[x][1]).first + std::max(s[i], f[i][0].first + 1));\n                    res = std::max(&#123; res,\n                        mx + s[i], // 情况 1\n                        (f[x][0].second == i ? f[x][1].first + f[x][2].first : (f[x][1].second == i ? f[x][0].first + f[x][2].first : f[x][0].first + f[x][1].first)) + s[i], // 情况 2.1\n                        (f[x][0].second == i ? f[x][1].first : f[x][0].first) + w[i] + 1, // 情况 2.2\n                    &#125;);\n                    mx = std::max(mx, s[i]);\n                &#125;\n        &#125;;\n        DFS(1, -1);\n        std::cout << 2 * (n + 1) - res - 2 << '\\n';\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"d---瞬间传送-teleport\">D - 瞬间传送 / Teleport</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P11915\" class=\"uri\">https://www.luogu.com.cn/problem/P11915</a></p>\n<p>需要观察到一个很厉害的贪心策略：如果钦定所有点的距离不大于 <span class=\"math inline\">\\(r\\)</span>，且存在 <span class=\"math inline\">\\(d(i,j)&gt;r\\)</span>。<strong>假设</strong> 一种满足条件的新边是 <span class=\"math inline\">\\((u,v)\\)</span>（由于两者无序，不妨钦定 <span class=\"math inline\">\\(d(i,u)&lt;d(i,v)\\)</span>），可以进行讨论：</p>\n<ol type=\"1\">\n<li><p><span class=\"math inline\">\\(d(j,v)&lt;d(j,u)\\)</span>：</p>\n此时最优路径为 <span class=\"math inline\">\\(i\\to u\\to v\\to j\\)</span>，判断一下这种方案是否不大于 <span class=\"math inline\">\\(r\\)</span> 就可以了。</li>\n<li><p><span class=\"math inline\">\\(d(j,v)\\ge d(j, u)\\)</span>：</p>\n<p>此时不管是走 <span class=\"math inline\">\\(i\\to u\\to v\\to j\\)</span> 还是 <span class=\"math inline\">\\(i\\to v\\to u\\to j\\)</span> 都不如走已经存在的 <span class=\"math inline\">\\(i\\to u\\to j\\)</span> 这条路径，也就是说如果要走新边，代价是一定比原距离大，更是比 <span class=\"math inline\">\\(r\\)</span> 大的；也就是说，<span class=\"math inline\">\\((u,v)\\)</span> 不能解决 <span class=\"math inline\">\\((i,j)\\)</span> 之间的问题，假设就不成立了。</p></li>\n</ol>\n<p>综上，只需要判断 <span class=\"math inline\">\\(i\\to u\\to v\\to j\\le r\\)</span> 是否成立，就可以判断 <span class=\"math inline\">\\((u,v)\\)</span> 是否合法。从大到小枚举 <span class=\"math inline\">\\(r\\)</span>，同时维护当前依然合法的 <span class=\"math inline\">\\((u,v)\\)</span>（显然是有单调性的），对于不合法的 <span class=\"math inline\">\\((i,j)\\)</span>，枚举每个 <span class=\"math inline\">\\(i\\)</span>，维护 <span class=\"math inline\">\\(\\max\\{d(v,j)\\}\\)</span>，精细实现（主要是利用各种均摊）一下就能 <span class=\"math inline\">\\(O(n^3)\\)</span>。</p>\n<p>这里具体提一下需要摊的几个点：</p>\n<ol type=\"1\">\n<li>枚举到 <span class=\"math inline\">\\(r\\)</span> 的时候用所有 <span class=\"math inline\">\\(d(i,j)=r+1\\)</span> 把 <span class=\"math inline\">\\(v\\)</span> 在 <span class=\"math inline\">\\(i\\)</span> 处的最大 <span class=\"math inline\">\\(d(v,j)\\)</span> 更新，方便后面 <span class=\"math inline\">\\(O(n)\\)</span> 地 check。摊出来是 <span class=\"math inline\">\\(O(n^3)\\)</span> 的。</li>\n<li>枚举仍然处在合法队列里的 <span class=\"math inline\">\\((u,v)\\)</span>，如果 check 合法，就说明对于当前 <span class=\"math inline\">\\(r\\)</span> 至少存在一个合法解，就可以 <code>break</code> 了；否则，把 <span class=\"math inline\">\\((u,v)\\)</span> 弹出，继续 check 下一条边。这样每条边只会被弹出一次，而未弹出边的 check 次数最多是 <span class=\"math inline\">\\(O(n)\\)</span>；加上 <span class=\"math inline\">\\(O(n)\\)</span> 的 check，摊出来是 <span class=\"math inline\">\\(O(n^3)\\)</span> 的。</li>\n</ol>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int inf = 0x3f3f3f3f;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int T;\n    for (std::cin &gt;&gt; T; T--; ) &#123;\n        int n;\n        std::cin &gt;&gt; n;\n        std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1, std::vector&lt;int&gt; (n + 1, inf));\n        for (int i = 1; i &lt;= n; ++i)\n            for (int j = 1; j &lt;= n; ++j) &#123;\n                char t;\n                std::cin &gt;&gt; t;\n                if (t == &#39;1&#39; || i == j)\n                    g[i][j] = t - &#39;0&#39;;\n            &#125;\n        for (int k = 1; k &lt;= n; ++k)\n            for (int i = 1; i &lt;= n; ++i)\n                if (i != k)\n                    for (int j = 1; j &lt;= n; ++j)\n                        if (j != i &amp;&amp; j != k)\n                            g[i][j] = std::min(g[i][j], g[i][k] + g[k][j]);\n        std::queue&lt;std::pair&lt;int, int&gt; &gt; q;\n        std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; p(n + 1);\n        std::vector&lt;std::vector&lt;int&gt; &gt; mx(n + 1, std::vector&lt;int&gt; (n + 1));\n        for (int i = 1; i &lt; n; ++i)\n            for (int j = i + 1; j &lt;= n; ++j) &#123;\n                q.emplace(i, j);\n                p[g[i][j] - 1].emplace_back(i, j);\n            &#125;\n        auto check = [&amp;](int u, int v, int r) &#123;\n            for (int i = 1; i &lt;= n; ++i) &#123;\n                if (g[u][i] &gt; g[v][i])\n                    std::swap(u, v);\n                if (g[u][i] + mx[v][i] &gt; r)\n                    return false;\n            &#125;\n            return true;\n        &#125;;\n        for (int r = n; r &gt;= -1; --r) &#123;\n            for (auto [i, j] : p[r])\n                for (int v = 1; v &lt;= n; ++v) &#123;\n                    mx[v][i] = std::max(mx[v][i], g[v][j]);\n                    mx[v][j] = std::max(mx[v][j], g[v][i]);\n                &#125;\n            for (; !q.empty(); ) &#123;\n                auto [u, v] = q.front();\n                if (!check(u, v, r))\n                    q.pop();\n                else\n                    break;\n            &#125;\n            if (q.empty()) &#123;\n                std::cout &lt;&lt; r + 1 &lt;&lt; &#39;\\n&#39;;\n                break;\n            &#125;\n        &#125;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"e.-two-tanks\">E. Two Tanks</h2>\n<p><a href=\"https://codeforces.com/problemset/problem/1809/E\" class=\"uri\">https://codeforces.com/problemset/problem/1809/E</a></p>\n<p>果然还是不会简单 DP <img src=\"/em/ll.gif\" /></p>\n<p>可以观察到如果总水量相同，且某个时刻两种初始状态当前是相同状态，那么以后它们也会是相同状态。但光凭这个好像还是不太能做出来的样子 <img src=\"/em/kt.gif\" /></p>\n<p>这里大概算一个定式，对于类似这种两个元素总和不变的问题，可以把两个元素的容量画到数轴上，原点表示分界，当前水为一条定长线段，倒水就相当于左右平移这条线段：</p>\n<p><img src=\"3.png\" /></p>\n<p>需要意识到，<mark></mark></p>\n",
            "tags": [
                "DP",
                "贪心",
                "均摊"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20250120/",
            "url": "https://xsc062.netlify.app/20250120/",
            "title": "学习笔记：AC 自动机",
            "date_published": "2025-01-20T03:21:15.000Z",
            "content_html": "<p>耳机声音疑似有点小了，用心旷神怡的话来说大致会是「比果蝇↑嗡嗡声还小」。</p>\n<span id=\"more\"></span>\n<p>？卧槽耳机上居然可以调音量 <img src=\"/em/oh.gif\" /></p>\n<hr />\n<h2 id=\"前置知识\">前置知识</h2>\n<p>首先可能需要知道专有名词「自动机」的含义。</p>\n<p>大致可以简单理解为，一个 DAG，其中点表示状态，边表示转移。给进去一个字符串之类，就可以在 DAG 上游走，根据最后所处结点，可以得到字符串相关特征。</p>\n<p>这个定义让我们想到了 Trie。事实上，Trie 就是一种相当基础的自动机。</p>\n<hr />\n<p>接下来，让我们复习 KMP 相关概念。</p>\n<p>假想一个场景：你需要求得 <span class=\"math inline\">\\(T\\)</span> 在 <span class=\"math inline\">\\(S\\)</span> 中的出现次数。</p>\n<p>拥有一定题目经验的你，会使用 KMP 求出 <span class=\"math inline\">\\(T\\)</span> 的 <code>next</code> 数组，令 <span class=\"math inline\">\\(T\\)</span> 在 <span class=\"math inline\">\\(S\\)</span> 上进行匹配，失配或完全匹配时回到 <span class=\"math inline\">\\(T\\)</span> 在该处的 <code>next</code>，<span class=\"math inline\">\\(S\\)</span> 上的指针始终向右，<span class=\"math inline\">\\(T\\)</span> 上的指针如果向右，每次只能移动一位；如果向左，最左移到开头，均摊下来复杂度即为 <span class=\"math inline\">\\(O(|S| + |T|)\\)</span>。</p>\n<p>假如场景变得更复杂：给定 <span class=\"math inline\">\\(\\{T_m\\}\\)</span>，你需要求出每个 <span class=\"math inline\">\\(T_j\\)</span> 在 <span class=\"math inline\">\\(S\\)</span> 中的出现次数。</p>\n<p>那么如果我们对每个 <span class=\"math inline\">\\(T_j\\)</span> 进行一次 KMP，复杂度将会上升到 <span class=\"math inline\">\\(O(m|S|)\\)</span>，难以承受。有没有优化的方法呢？</p>\n<hr />\n<h2 id=\"ac-自动机的建立\">AC 自动机的建立</h2>\n<p>结合上面的知识，我们下意识想到，能不能将 <span class=\"math inline\">\\(\\{T_m\\}\\)</span> 建成一个树状结构，令 <span class=\"math inline\">\\(S\\)</span> 在其上进行 KMP 呢？</p>\n<p>将 <span class=\"math inline\">\\(\\{T_m\\}\\)</span> 全部加入 Trie，由于 <code>next</code> 只会由更深的点指向更浅的点，似乎从直觉上是有规则的。但随之而来的是一个问题：点 <span class=\"math inline\">\\(u\\)</span> 的 <code>next</code> 不一定在 <span class=\"math inline\">\\(\\text{root}\\to u\\)</span> 的链上（由于 Trie 的性质，可知指向的点是唯一的）。鉴于这一点不同，我们结合其「失配指针」的定义，将 <code>next</code> 在 Trie 上的同分异构体唤为 <code>fail</code>。</p>\n<p>考察 Trie 上该 <code>fail</code> 边的性质。现欲求解 <span class=\"math inline\">\\(u\\)</span> 的 <code>fail</code> 指向的 <span class=\"math inline\">\\(c\\)</span>，结合 KMP 中 <code>next</code> 的性质，假设 <span class=\"math inline\">\\(u\\)</span> 的父节点的 <code>fail</code> 边指向 <span class=\"math inline\">\\(v&#39;\\)</span>，那么 <span class=\"math inline\">\\(v\\)</span> 的值为：</p>\n<ul>\n<li><span class=\"math inline\">\\(v&#39;\\)</span> 上有边权相同的边，那么 <span class=\"math inline\">\\(v\\)</span> 就是该边指向的点。</li>\n<li>否则，前往 <span class=\"math inline\">\\(v&#39;\\)</span> 的 <code>fail</code>，重复以上判定。</li>\n</ul>\n<p>那么就完成了失配的处理。相应地，完全匹配时的跳转应如何处理？直接将 <code>fail</code> 的儿子全部接到 <span class=\"math inline\">\\(u\\)</span> 下面即可。如果 <span class=\"math inline\">\\(u\\)</span> 和 <code>fail</code> 具有同一个边权的边时，保留 <span class=\"math inline\">\\(u\\)</span> 的这条边 <span class=\"math inline\">\\(u\\to v\\)</span>，因为 <span class=\"math inline\">\\(v\\)</span> 的 <code>fail</code> 必定指向 <span class=\"math inline\">\\(u\\)</span> 的 <code>fail</code> 的对应儿子。</p>\n<p>两点结合，我们发现从实现上，可以直接令 <span class=\"math inline\">\\(v\\)</span> 的 <code>fail</code> 指向 <span class=\"math inline\">\\(u\\)</span> 的 <code>fail</code> 的对应儿子（那么时间复杂度显而易见是 <span class=\"math inline\">\\(O(26\\sum |T|)\\)</span> 的）。</p>\n<p>匹配时，对于每个点和其返回到根的 <code>fail</code> 链，全部标记。则一个模式串匹配的次数即为被打标记的次数。</p>\n<p>那么可以发现 AC 自动机的本质就是添加了 <code>fail</code> 边的 Trie。</p>\n<hr />\n<p>那么根据上述要求，我们需要按照深度顺序求得 <code>fail</code>，考虑 BFS。</p>\n<details>\n<p>哦哦好神奇复活之后记得啥是 KMP 但忘了啥是 C++ 了。甚至花了一点时间学习怎么创建一个函数？？？</p>\n<p>大家写 AC 自动机 Trie 根节点下标一定要设成 0 啊 <img src=\"/em/ll.gif\" /> 设成 1 被各种细节坑惨了 <img src=\"/em/ll.gif\" /></p>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 2e5 + 5;\nint T[maxn][26], tot, cnt[maxn], fail[maxn];\nint ins(std::string &amp;t) &#123;\n    int p = 0;\n    for (auto i : t) &#123;\n        if (!T[p][i - &#39;a&#39;])\n            T[p][i - &#39;a&#39;] = ++tot;\n        p = T[p][i - &#39;a&#39;];\n    &#125;\n    return p;\n&#125;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;int&gt; tail(n + 1);\n    std::vector&lt;std::string&gt; t(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; t[i], tail[i] = ins(t[i]);\n    &#123;\n        std::queue&lt;int&gt; q;\n        for (int i = 0; i &lt; 26; ++i)\n            if (T[0][i])\n                q.push(T[0][i]);\n        for (; !q.empty(); ) &#123;\n            int u = q.front();\n            q.pop();\n            for (int i = 0; i &lt; 26; ++i)\n                if (T[u][i]) &#123;\n                    int v = T[u][i];\n                    fail[v] = T[fail[u]][i];\n                    q.push(v);\n                &#125;\n                else\n                    T[u][i] = T[fail[u]][i];\n        &#125;\n    &#125;\n    std::string s;\n    std::cin &gt;&gt; s;\n    &#123;\n        int p = 0;\n        for (auto i : s) &#123;\n            p = T[p][i - &#39;a&#39;];\n            for (int fa = p; fa; fa = fail[fa])\n                ++cnt[fa];\n        &#125;\n    &#125;\n    for (int i = 1; i &lt;= n; ++i)\n        std::cout &lt;&lt; cnt[tail[i]] &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<p>肉眼可见该查询方式是极其低效的，故考虑优化跳 <code>fail</code> 打标记的过程。</p>\n<p>既然自动机结构不变，不如将跳 <code>fail</code> 的步骤放在最后统一进行。容易在发现 <code>fail</code> 树上进行拓扑排序转移即可。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 2e5 + 5;\nint T[maxn][26], tot, cnt[maxn], fail[maxn], deg[maxn];\nint ins(std::string &amp;t) &#123;\n    int p = 0;\n    for (auto i : t) &#123;\n        if (!T[p][i - &#39;a&#39;])\n            T[p][i - &#39;a&#39;] = ++tot;\n        p = T[p][i - &#39;a&#39;];\n    &#125;\n    return p;\n&#125;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;int&gt; tail(n + 1);\n    std::vector&lt;std::string&gt; t(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; t[i], tail[i] = ins(t[i]);\n    &#123;\n        std::queue&lt;int&gt; q;\n        for (int i = 0; i &lt; 26; ++i)\n            if (T[0][i])\n                q.push(T[0][i]);\n        for (; !q.empty(); ) &#123;\n            int u = q.front();\n            q.pop();\n            for (int i = 0; i &lt; 26; ++i)\n                if (T[u][i]) &#123;\n                    int v = T[u][i];\n                    fail[v] = T[fail[u]][i], ++deg[T[fail[u]][i]];\n                    q.push(v);\n                &#125;\n                else\n                    T[u][i] = T[fail[u]][i];\n        &#125;\n    &#125;\n    std::string s;\n    std::cin &gt;&gt; s;\n    &#123;\n        int p = 0;\n        for (auto i : s)\n            p = T[p][i - &#39;a&#39;], ++cnt[p];\n    &#125;\n    &#123;\n        std::queue&lt;int&gt; q;\n        for (int i = 1; i &lt;= tot; ++i)\n            if (!deg[i])\n                q.push(i);\n        for (; !q.empty(); ) &#123;\n            int u = q.front();\n            q.pop();\n            cnt[fail[u]] += cnt[u];\n            if (!--deg[fail[u]])\n                q.push(fail[u]);\n        &#125;\n    &#125;\n    for (int i = 1; i &lt;= n; ++i)\n        std::cout &lt;&lt; cnt[tail[i]] &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"ac-自动机的应用与识别\">AC 自动机的应用与识别</h2>\n<p>我们知道其最典型的特征是 <strong>多模式串</strong>、<strong>静态 / 离线</strong>。当碰到类似特点时，大概率就是 AC 自动机。</p>\n<p>其中，可以设置的难点有：</p>\n<ol type=\"1\">\n<li>字符串难点，和其他字符串题可设置的难点相同。</li>\n<li>fail 树维护，可能结合数据结构、拓扑排序、树形 DP 等考察。</li>\n<li>DP 的设计。</li>\n</ol>\n<hr />\n<h2 id=\"字符串难点设计\">字符串难点设计</h2>\n<h3 id=\"eg.-indie-album\">eg. Indie Album</h3>\n<p><a href=\"https://codeforces.com/problemset/problem/1207/G\" class=\"uri\">https://codeforces.com/problemset/problem/1207/G</a></p>\n<p>题目的「可持久化」试图误导我们用操作串建立自动机，但这样就会有一个比较严重的问题，我们没办法求 <span class=\"math inline\">\\(t\\)</span> 的出现次数。</p>\n<p>为了保证答案可求我们仍然在 <span class=\"math inline\">\\(t\\)</span> 上建立 ACAM。容易发现操作串以 Trie 形式给出，我们可以在遍历 Trie 时同时完成游走，通过回溯完成询问。</p>\n<p>假设当前 DFS 中，遍历到 Trie 树中的 <span class=\"math inline\">\\(x\\)</span> 点和自动机中的 <span class=\"math inline\">\\(u\\)</span> 状态，那么对于 <span class=\"math inline\">\\(x\\)</span> 点所对应的一个询问串 <span class=\"math inline\">\\(t\\)</span>，相当于询问经过的所有状态有多少个在 <span class=\"math inline\">\\(t\\)</span> 引导的 fail 树子树中。我们求出 fail 树的 dfn，用树状数组简单统计即可。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 4e5 + 5;\nstd::vector&lt;int&gt; g[maxn], q[maxn];\nint fail[maxn], T[maxn][26], tot, bit[maxn], to[maxn][26], cnt[maxn];\nint ins(std::string s) &#123;\n    int p = 0;\n    for (auto i : s) &#123;\n        if (!T[p][i - &#39;a&#39;])\n            T[p][i - &#39;a&#39;] = ++tot;\n        p = T[p][i - &#39;a&#39;];\n    &#125;\n    return p;\n&#125;\nint lowbit(int x) &#123;\n    return x &amp; -x;\n&#125;\nvoid add(int x, int v) &#123;\n    for (; x &lt;= tot + 1; x += lowbit(x))\n        bit[x] += v;\n    return;\n&#125;\nint ask(int x) &#123;\n    int res = 0;\n    for (; x; x -= lowbit(x))\n        res += bit[x];\n    return res;\n&#125;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, now = 0;\n    std::cin &gt;&gt; n;\n    std::vector&lt;int&gt; id(n + 1);\n    for (int i = 1, op; i &lt;= n; ++i) &#123;\n        char t;\n        std::cin &gt;&gt; op;\n        if (op == 1) &#123;\n            std::cin &gt;&gt; t;\n            if (!to[0][t - &#39;a&#39;])\n                to[0][t - &#39;a&#39;] = ++now;\n            ++cnt[to[0][t - &#39;a&#39;]], id[i] = to[0][t - &#39;a&#39;];\n        &#125;\n        else &#123;\n            int j; \n            std::cin &gt;&gt; j &gt;&gt; t;\n            if (!to[id[j]][t - &#39;a&#39;])\n                to[id[j]][t - &#39;a&#39;] = ++now;\n            ++cnt[to[id[j]][t - &#39;a&#39;]], id[i] = to[id[j]][t - &#39;a&#39;];\n        &#125;\n    &#125;\n    int m;\n    std::cin &gt;&gt; m;\n    std::vector&lt;int&gt; tail(m + 1), res(m + 1);\n    for (int i = 1, x; i &lt;= m; ++i) &#123;\n        std::string t;\n        std::cin &gt;&gt; x &gt;&gt; t, tail[i] = ins(t);\n        q[id[x]].push_back(i);\n    &#125;\n    &#123;\n        std::queue&lt;int&gt; q;\n        for (int i = 0; i &lt; 26; ++i)\n            if (T[0][i])\n                q.push(T[0][i]), g[0].push_back(T[0][i]);\n        for (; !q.empty(); ) &#123;\n            int u = q.front();\n            q.pop();\n            for (int i = 0; i &lt; 26; ++i)\n                if (T[u][i]) &#123;\n                    int v = T[u][i];\n                    fail[v] = T[fail[u]][i];\n                    q.push(v), g[fail[v]].push_back(v);\n                &#125;\n                else\n                    T[u][i] = T[fail[u]][i];\n        &#125;\n    &#125;\n    std::vector&lt;int&gt; dfn(tot + 1), rfn(tot + 1);\n    std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;\n        static int now = 0;\n        dfn[x] = ++now;\n        // printf(&quot;%d &quot;, x);\n        for (auto i : g[x])\n            DFS(i);\n        rfn[x] = now;\n        return;\n    &#125;;\n    DFS(0);\n    std::function&lt;void(int, int)&gt; DFS1 = [&amp;](int x, int u) &#123;\n        add(dfn[u], 1);\n        for (auto i : q[x])\n            res[i] += ask(rfn[tail[i]]) - ask(dfn[tail[i]] - 1);\n        for (int i = 0; i &lt; 26; ++i)\n            if (to[x][i])\n                DFS1(to[x][i], T[u][i]);\n        add(dfn[u], -1);\n        return;\n    &#125;;\n    DFS1(0, 0);\n    for (int i = 1; i &lt;= m; ++i)\n        std::cout &lt;&lt; res[i] &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"fail-树的维护\">fail 树的维护</h2>\n<h3 id=\"eg.-divljak\">eg. Divljak</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P5840\" class=\"uri\">https://www.luogu.com.cn/problem/P5840</a></p>\n<h4 id=\"法一把动态问题离线\">法一：把动态问题离线</h4>\n<p>问题相当于将模式串 <span class=\"math inline\">\\(T:\\{P\\}\\)</span> 动态化，但我们仍可以无脑离线下来解决问题。</p>\n<p>考虑原本的答案计算过程，即在经过的所有状态及其 fail 链上打标记。现在我们需要离线并区分标记的来源（并且标记类型为布尔值），下意识想到使用线段树维护。</p>\n<p>我们对每个状态建立动态开点线段树，最后拓扑排序时使用线段树合并处理信息。容易证明时间复杂度相较原来多了一个 <span class=\"math inline\">\\(\\log\\)</span>。</p>\n<p><del>理论可行，开始实践</del> 出题人似乎不是很喜欢线段树选手所以决定剥夺你的 Memory Limit。想要用这种做法通过本题可见 <a href=\"https://www.luogu.com.cn/article/jaxk3sno\" class=\"uri\">https://www.luogu.com.cn/article/jaxk3sno</a>。</p>\n<h4 id=\"法二转而处理静态问题\">法二：转而处理静态问题</h4>\n<p>注意到题目中的静态的 <span class=\"math inline\">\\(S_x\\)</span> 比起 <span class=\"math inline\">\\(T:\\{P\\}\\)</span> 更适合用来做模式串，我们在 <span class=\"math inline\">\\(S_x\\)</span> 上构建 AC 自动机，考虑在线解决问题。</p>\n<p>在每次 <code>1</code> 操作时，更新模式串信息。对于途径的所有状态 <span class=\"math inline\">\\(\\{u\\}\\)</span>，考虑更新其所在 fail 链上的信息。</p>\n<p>注意到我们需要修改整条 fail 链上的信息，询问则是询问单点。这个时候可以考虑使用树上差分。</p>\n<p>但是 here comes a problem，我们对于这一整个串只能在整个树上每个点上更新一次。怎么消去相同的影响呢？</p>\n<p>这里实现上我们将经过的点按 fail 树上 dfn 排序，并且对于序列中相邻的两点在其 LCA 上减去一次标记。为什么这是正确的呢？参考虚树，我们只需要让序列中相邻的两个点尽量近就可以保证重复的被删除完毕。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 2e6 + 5;\nint tot, bit[maxn], T[maxn][26], fail[maxn];\nint ins(std::string &amp;t) &#123;\n    int p = 0;\n    for (auto i : t) &#123;\n        if (!T[p][i - &#39;a&#39;])\n            T[p][i - &#39;a&#39;] = ++tot;\n        p = T[p][i - &#39;a&#39;];\n    &#125;\n    return p;\n&#125;\nint lowbit(int x) &#123;\n    return x &amp; -x;\n&#125;\nvoid add(int x, int v) &#123;\n    // printf(&quot;add (%d, %d)\\n&quot;, x, v);\n    for (; x &lt;= tot + 1; x += lowbit(x))\n        bit[x] += v;\n    return;\n&#125;\nint ask(int x) &#123;\n    int res = 0, to = x;\n    for (; x; x -= lowbit(x))\n        res += bit[x];\n    // printf(&quot;ask(%d) = %d\\n&quot;, to, res);\n    return res;\n&#125;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, q;\n    std::cin &gt;&gt; n;\n    std::vector&lt;int&gt; tail(n + 1);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::string t;\n        std::cin &gt;&gt; t, tail[i] = ins(t);\n    &#125;\n    std::vector&lt;std::vector&lt;int&gt; &gt; g(tot + 2);\n    &#123;\n        std::queue&lt;int&gt; q;\n        for (int i = 0; i &lt; 26; ++i)\n            if (T[0][i])\n                q.push(T[0][i]);\n        for (; !q.empty(); ) &#123;\n            int u = q.front();\n            q.pop();\n            for (int i = 0; i &lt; 26; ++i)\n                if (T[u][i]) &#123;\n                    int v = T[u][i];\n                    fail[v] = T[fail[u]][i];\n                    q.push(v);\n                &#125;\n                else\n                    T[u][i] = T[fail[u]][i];\n        &#125;\n        for (int i = 1; i &lt;= tot; ++i)\n            g[fail[i] + 1].push_back(i + 1);\n    &#125;\n    std::vector&lt;std::array&lt;int, 22&gt; &gt; f(tot + 2);\n    std::vector&lt;int&gt; dep(tot + 2), dfn(tot + 2), siz(tot + 2);\n    std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;\n        static int now = 0;\n        siz[x] = 1, dfn[x] = ++now;\n        // printf(&quot;%d\\n&quot;, x);\n        for (auto i : g[x]) &#123;\n            dep[i] = dep[x] + 1;\n            f[i][0] = x;\n            for (int j = 1; j &lt;= 21; ++j)\n                f[i][j] = f[f[i][j - 1]][j - 1];\n            DFS(i), siz[x] += siz[i];\n        &#125;\n        return;\n    &#125;;\n    dep[1] = 1, DFS(1);\n    auto askLCA = [&amp;](int x, int y) &#123;\n        if (x == y)\n            return x;\n        if (dep[x] &lt; dep[y])\n            std::swap(x, y);\n        for (int i = 21; ~i; --i)\n            if (dep[f[x][i]] &gt;= dep[y])\n                x = f[x][i];\n        if (x == y)\n            return x;\n        for (int i = 21; ~i; --i)\n            if (f[x][i] != f[y][i])\n                x = f[x][i], y = f[y][i];\n        return f[x][0];\n    &#125;;\n    std::cin &gt;&gt; q;\n    for (; q--; ) &#123;\n        int op;\n        std::cin &gt;&gt; op;\n        if (op == 1) &#123;\n            std::string s;\n            std::cin &gt;&gt; s;\n            int p = 0, len = (int)s.length();\n            std::vector&lt;int&gt; id(len + 1);\n            for (int i = 1; i &lt;= len; ++i)\n                p = T[p][s[i - 1] - &#39;a&#39;], id[i] = p + 1;\n            std::sort(id.begin() + 1, id.end(), [&amp;](int x, int y) &#123; return dfn[x] &lt; dfn[y]; &#125;);\n            // for (int i = 1; i &lt;= len; ++i)\n            //     printf(&quot;%d &quot;, id[i]);\n            // puts(&quot;&quot;);\n            for (int i = 1; i &lt;= len; ++i) &#123;\n                // printf(&quot;%d %d %d\\n&quot;, i, id[i], dfn[id[i]]);\n                // assert(0);\n                add(dfn[id[i]], 1);\n                if (i != 1)\n                    add(dfn[askLCA(id[i], id[i - 1])], -1);\n            &#125;\n        &#125;\n        else &#123;\n            int x;\n            std::cin &gt;&gt; x;\n            x = tail[x] + 1;\n            std::cout &lt;&lt; ask(dfn[x] + siz[x] - 1) - ask(dfn[x] - 1) &lt;&lt; &#39;\\n&#39;;\n        &#125;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"ac-自动机上的-dp\">AC 自动机上的 DP</h2>\n<p>鉴于 AC 自动机的优秀结构与性质，并不经常作为字符串匹配工具出现，其一个应用是作为 DP 的载体。</p>\n<h3 id=\"eg1.-l-语言\">eg1. L 语言</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P2292\" class=\"uri\">https://www.luogu.com.cn/problem/P2292</a></p>\n<p>我们想到要在自动机上匹配，但此时 <code>fail</code> 作为「断句」的唯一手段（断句的位置在链上当前点深度 - <code>fail</code> 深度处），不再仅当失配时才能经过。我们考虑朴素的 DP：在经过的每个状态考虑断句，那么这要求断句处是一个单词的结尾，那么此时 <code>fail</code> 最长匹配长度即可被更新。最后遍历所有单词的末结点，取最大答案。这里的 <code>fail</code> 其实是 <code>fail</code> 链上任意一点。</p>\n<p>考虑复杂度。容易发现对于每一个点我们跳了其整条 fail 链，那么复杂度就是最劣 <span class=\"math inline\">\\(n^2\\)</span> 的。考虑优化这个过程至 <span class=\"math inline\">\\(O(1)\\)</span>。</p>\n<p>题目里有一个很重要的条件还没有用到：单个单词长度 <span class=\"math inline\">\\(\\le 20\\)</span>，这让我们想到状态压缩。对于每一个状态，记录其断出来单词的可能长度。</p>\n<p>我们在 DAG 上游走的时候记录目前可以断的所有位置，如果其和当前可断出来的长度之交不为空，就可以将此处加入「可以断的所有位置」并更新答案。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 2e5 + 5;\nint T[maxn][26], tot, fail[maxn], len[maxn], dep[maxn], tag[maxn];\nint ins(std::string &amp;t) &#123;\n    int p = 0;\n    for (auto i : t) &#123;\n        if (!T[p][i - &#39;a&#39;])\n            T[p][i - &#39;a&#39;] = ++tot, dep[tot] = dep[p] + 1;\n        p = T[p][i - &#39;a&#39;];\n    &#125;\n    ++tag[p];\n    return p;\n&#125;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, m;\n    std::cin &gt;&gt; n &gt;&gt; m;\n    std::vector&lt;int&gt; tail(n + 1);\n    std::vector&lt;std::string&gt; t(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; t[i], tail[i] = ins(t[i]);\n    &#123;\n        std::queue&lt;int&gt; q;\n        for (int i = 0; i &lt; 26; ++i)\n            if (T[0][i])\n                q.push(T[0][i]);\n        for (; !q.empty(); ) &#123;\n            int u = q.front();\n            q.pop();\n            len[u] = len[fail[u]];\n            if (tag[u])\n                len[u] |= (1 &lt;&lt; dep[u]);\n            for (int i = 0; i &lt; 26; ++i)\n                if (T[u][i]) &#123;\n                    int v = T[u][i];\n                    fail[v] = T[fail[u]][i];\n                    q.push(v);\n                &#125;\n                else\n                    T[u][i] = T[fail[u]][i];\n        &#125;\n    &#125;\n    for (; m--; ) &#123;\n        std::string s;\n        std::cin &gt;&gt; s;\n        int p = 0, q = 1, res = 0;\n        for (int i = 0; i &lt; (int)s.length(); ++i) &#123;\n            p = T[p][s[i] - &#39;a&#39;], q &lt;&lt;= 1;\n            if (len[p] &amp; q)\n                q |= 1, res = i + 1;\n        &#125;\n        std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"eg2.-popcount-words\">eg2. Popcount Words</h3>\n<p><a href=\"https://codeforces.com/gym/103409/problem/H\" class=\"uri\">https://codeforces.com/gym/103409/problem/H</a></p>\n<p><del>咋上强度了啊。</del></p>\n<p>先把整个序列写出来，即 <span class=\"math inline\">\\(w=\\texttt{01101001100101}\\cdots\\)</span>，尝试进一步探究形式化的规律，可以得到：</p>\n<ol type=\"1\">\n<li><span class=\"math inline\">\\(w_{[0, 2^n), 0}=w_{[0, 2^{n-1}),0}+w_{[0, 2^n), 1}\\)</span>，其中 <span class=\"math inline\">\\(w_{[l, r], 0/1}\\)</span> 表示 <span class=\"math inline\">\\([l, r]\\)</span> 内，原串 / 取反的值。</li>\n<li>对于不以 <span class=\"math inline\">\\(0\\)</span> 开头的整段，可以从上述规则转化为 <span class=\"math inline\">\\(0\\)</span> 开头的整段。</li>\n</ol>\n<p>接着不难想到一种类似线段树的方式，将待求的 <span class=\"math inline\">\\(w_{[l, r], 0}\\)</span> 分到 <span class=\"math inline\">\\(O(\\log V)\\)</span> 个整段上，那么 <span class=\"math inline\">\\(S\\)</span> 就可以被 <span class=\"math inline\">\\(O(n\\log V)\\)</span> 个整段（也是 <span class=\"math inline\">\\(\\log V\\)</span> 个本质不同整段）描述。</p>\n<p>我们对 <span class=\"math inline\">\\({p_m}\\)</span> 建立 AC 自动机，需要知道这 <span class=\"math inline\">\\(\\log V\\)</span> 个整段在每个点上的出现次数。对于自动机上任意状态 <span class=\"math inline\">\\(u\\)</span>，设 <span class=\"math inline\">\\(to_{u, n, 0/1}\\)</span> 表示 <span class=\"math inline\">\\(u\\)</span> 经过 <span class=\"math inline\">\\(w_{[0, 2^n), 0/1}\\)</span> 后到达的点，则可倍增（嘶，这里是不是应该反过来叫分治啊）简单解决。</p>\n<p>那么接下来我们就可以用 <span class=\"math inline\">\\(to\\)</span> 来进行快速游走了。顺便打个 <span class=\"math inline\">\\(cnt\\)</span> 记录一下每个 <span class=\"math inline\">\\(u\\)</span> 作为不同整段的开头被经过的次数。然后做一个 DP，类似于线段树上 <code>pushdown</code> 的操作把所有整段下放到单点上的单个字符。</p>\n<p>有一说一用 DP 来处理这个东西还挺难想的。可能也是基于前面的倍增吧。最后拓扑排序就行了。</p>\n<details>\n<p>大家数组一定要用 C-style array 啊，<code>std::vector&lt;&gt;</code> 计算的是申请空间包 MLE 的 <img src=\"/em/ll.gif\" /></p>\n<p>大家大数组一定要内存连续访问优化啊，TLE <span class=\"math inline\">\\(\\to\\)</span> 100ms 泪目了 <img src=\"/em/ll.gif\" /></p>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 5e5 + 5;\nlong long sum[maxn], f[2][30][maxn];\nint cnt[2][30][maxn], to[2][30][maxn];\nint T[maxn][2], tot, fail[maxn], deg[maxn];\nint ins(std::string &amp;t) &#123;\n    int p = 0;\n    for (auto i : t) &#123;\n        if (!T[p][i - &#39;0&#39;])\n            T[p][i - &#39;0&#39;] = ++tot;\n        p = T[p][i - &#39;0&#39;];\n    &#125;\n    return p;\n&#125;\nvoid ask(std::vector&lt;std::pair&lt;int, int&gt; &gt; &amp;s, int ql, int qr, int l = 0, int r = (1 &lt;&lt; 30) - 1, int len = 30, int v = 0) &#123;\n    if (ql &lt;= l &amp;&amp; r &lt;= qr) &#123;\n        s.emplace_back(len, v);\n        return;\n    &#125;\n    int mid = l + (r - l) / 2;\n    if (ql &lt;= mid)\n        ask(s, ql, qr, l, mid, len - 1, v);\n    if (qr &gt; mid)\n        ask(s, ql, qr, mid + 1, r, len - 1, v ^ 1);\n    return;\n&#125;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, m;\n    std::cin &gt;&gt; n &gt;&gt; m;\n    std::vector&lt;std::pair&lt;int, int&gt; &gt; s;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        int l, r;\n        std::cin &gt;&gt; l &gt;&gt; r;\n        ask(s, l, r);\n    &#125;\n    std::vector&lt;int&gt; tail(m + 1);\n    for (int i = 1; i &lt;= m; ++i) &#123;\n        std::string t;\n        std::cin &gt;&gt; t;\n        tail[i] = ins(t);\n    &#125;\n    &#123;\n        std::queue&lt;int&gt; q;\n        for (int i = 0; i &lt; 2; ++i)\n            if (T[0][i])\n                q.push(T[0][i]);\n        for (; !q.empty(); ) &#123;\n            int u = q.front();\n            q.pop();\n            for (int i = 0; i &lt; 2; ++i)\n                if (T[u][i]) &#123;\n                    int v = T[u][i];\n                    fail[v] = T[fail[u]][i], ++deg[T[fail[u]][i]];\n                    q.push(v);\n                &#125;\n                else\n                    T[u][i] = T[fail[u]][i];\n        &#125;\n    &#125;\n    for (int i = 0; i &lt;= tot; ++i)\n        to[0][0][i] = T[i][0], to[1][0][i] = T[i][1];\n    for (int j = 1; j &lt; 30; ++j)\n        for (int i = 0; i &lt;= tot; ++i) &#123;\n            to[0][j][i] = to[1][j - 1][to[0][j - 1][i]];\n            to[1][j][i] = to[0][j - 1][to[1][j - 1][i]];\n        &#125;\n    &#123;\n        int p = 0;\n        for (auto [n, i] : s) &#123;\n            // printf(&quot;# %d %d\\n&quot;, n, i);\n            ++cnt[i][n][p], p = to[i][n][p];\n        &#125;\n    &#125;\n    for (int j = 29; ~j; --j)\n        for (int i = 0; i &lt;= tot; ++i) &#123;\n            if (j != 29) &#123;\n                f[0][j][i] += f[0][j + 1][i];\n                f[1][j][i] += f[1][j + 1][i];\n                f[0][j][to[1][j][i]] += f[1][j + 1][i];\n                f[1][j][to[0][j][i]] += f[0][j + 1][i];\n            &#125;\n            f[1][j][i] += cnt[1][j][i];\n            f[0][j][i] += cnt[0][j][i];\n        &#125;\n    for (int i = 0; i &lt;= tot; ++i) &#123;\n        sum[T[i][0]] += f[0][0][i], sum[T[i][1]] += f[1][0][i];\n        // printf(&quot;%d %d\\n&quot;, f[i][0][0], f[i][0][1]);\n    &#125;\n    &#123;\n        std::queue&lt;int&gt; q;\n        for (int i = 0; i &lt;= tot; ++i)\n            if (!deg[i])\n                q.push(i);\n        for (; !q.empty(); ) &#123;\n            int u = q.front();\n            q.pop();\n            sum[fail[u]] += sum[u];\n            if (!--deg[fail[u]])\n                q.push(fail[u]);\n        &#125;\n    &#125;\n    for (int i = 1; i &lt;= m; ++i)\n        std::cout &lt;&lt; sum[tail[i]] &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"eg3.-legen\">eg3. Legen…</h3>\n<p><a href=\"https://codeforces.com/problemset/problem/696/D\" class=\"uri\">https://codeforces.com/problemset/problem/696/D</a></p>\n<p>先在 fail 树上把每个状态的实际价值计算出来。我们发现匹配串是未知的，也就是我们需要主动决定游走路径。注意到 <span class=\"math inline\">\\(l=10^{14}\\)</span>，考虑矩阵。</p>\n<p>令 <span class=\"math inline\">\\(f_{u, i}\\)</span> 表示在 <span class=\"math inline\">\\(u\\)</span> 状态时已经走了 <span class=\"math inline\">\\(i\\)</span> 步，可以得到的最大价值。那么显然有：</p>\n<p><span class=\"math display\">\\[\nf_{v,i+1}=f_{u,i}+s_v.\n\\]</span></p>\n<p>其中 <span class=\"math inline\">\\(v\\)</span> 是自动机上 <span class=\"math inline\">\\(u\\)</span> 的任意出边。图的大小为 <span class=\"math inline\">\\(200\\)</span>，可以放到 <span class=\"math inline\">\\(+\\max\\)</span> 矩阵里加速转移。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 2e5 + 5;\nconst long long inf = 1e18;\nint fail[maxn], T[maxn][26], tot;\nint ins(std::string s) &#123;\n    int p = 0;\n    for (auto i : s) &#123;\n        if (!T[p][i - &#39;a&#39;])\n            T[p][i - &#39;a&#39;] = ++tot;\n        p = T[p][i - &#39;a&#39;];\n    &#125;\n    return p;\n&#125;\nstruct matrix &#123;\n    int n, m;\n    std::vector&lt;std::vector&lt;long long&gt; &gt; a;\n    matrix(int n1, int m1, long long v = -inf, bool op = 0): n(n1), m(m1), a(n + 1, std::vector&lt;long long&gt; (m + 1, v)) &#123;\n        if (op)\n            for (int i = 0; i &lt;= n; ++i)\n                a[i][i] = 0;\n        return;\n    &#125;\n    std::vector&lt;long long&gt; &amp;operator[] (int i) &#123;\n        return a[i];\n    &#125;\n    matrix operator* (matrix &amp;q) const &#123;\n        matrix res(n, q.m);\n        for (int k = 0; k &lt;= m; ++k)\n            for (int i = 0; i &lt;= n; ++i)\n                for (int j = 0; j &lt;= q.m; ++j)\n                    res[i][j] = std::max(res[i][j], a[i][k] + q[k][j]);\n        return res;\n    &#125;\n    matrix&amp; operator*= (matrix q) &#123;\n        return *this = *this * q;\n    &#125;\n    matrix operator^ (long long q) &#123;\n        matrix res(n, n, -inf, 1), x(*this);\n        for (; q; q &gt;&gt;= 1, x *= x)\n            if (q &amp; 1)\n                res *= x;\n        return res;\n    &#125;\n&#125;;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    long long m;\n    std::cin &gt;&gt; n &gt;&gt; m;\n    std::vector&lt;long long&gt; a(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i];\n    std::vector&lt;int&gt; tail(n + 1);\n    std::vector&lt;std::string&gt; t(n + 1);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; t[i];\n        tail[i] = ins(t[i]);\n    &#125;\n    std::vector&lt;long long&gt; s(tot + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        s[tail[i]] += a[i];\n    &#123;\n        std::queue&lt;int&gt; q;\n        for (int i = 0; i &lt; 26; ++i)\n            if (T[0][i])\n                q.push(T[0][i]); \n        for (; !q.empty(); ) &#123;\n            int u = q.front();\n            q.pop();\n            for (int i = 0; i &lt; 26; ++i)\n                if (T[u][i]) &#123;\n                    int v = T[u][i];\n                    fail[v] = T[fail[u]][i], s[v] += s[fail[v]];\n                    q.push(v);\n                &#125;\n                else\n                    T[u][i] = T[fail[u]][i];\n        &#125;\n    &#125;\n    matrix f(0, tot), op(tot, tot);\n    f[0][0] = 0;\n    for (int i = 0; i &lt;= tot; ++i)\n        for (int j = 0; j &lt; 26; ++j)\n            op[i][T[i][j]] = s[T[i][j]];\n    f *= (op * m);\n    std::cout &lt;&lt; *std::max_element(f[0].begin(), f[0].end()) &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;\n</code></pre>\n</details>\n<hr />\n<h3 id=\"eg4.-you-are-given-some-strings\">eg4. You Are Given Some Strings…</h3>\n<p>goto <a href=\"/20250121/#%E4%B8%80%E4%B8%AA%E6%A8%A1%E6%9D%BFcf1202e-you-are-given-some-strings...\">link</a>.</p>\n",
            "tags": [
                "DP",
                "字符串",
                "AC 自动机"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20240906/",
            "url": "https://xsc062.netlify.app/20240906/",
            "title": "动态规划 10 题 - I",
            "date_published": "2024-09-06T07:30:38.000Z",
            "content_html": "<p>现在是 10 题。虽然看着很掉价，但是写够了 10 就改成 20 题。以此类推，免得我摆烂（）</p>\n<p>自用向，不写太详细，把破题点写出来就差不多了。哦哦这里的破题是动词不是名词。</p>\n<span id=\"more\"></span>\n<hr />\n<h2 id=\"字符合并\">1. 字符合并</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P3736\" class=\"uri\">https://www.luogu.com.cn/problem/P3736</a></p>\n<blockquote>\n<p>给定长度为 <span class=\"math inline\">\\(n\\)</span> 的 <span class=\"math inline\">\\(01\\)</span> 串和 <span class=\"math inline\">\\(2^k\\)</span> 条规则，第 <span class=\"math inline\">\\(i\\)</span> 条规则形如：</p>\n<ul>\n<li>对于序列中的 <span class=\"math inline\">\\(k\\)</span> 位二进制数 <span class=\"math inline\">\\(i\\)</span>，可以将它合并为 <span class=\"math inline\">\\(c(c\\in\\{0,1\\})\\)</span>，并产生 <span class=\"math inline\">\\(v\\)</span> 的价值。</li>\n</ul>\n<p>进行任意次合并，求出能取得的最大总价值。<span class=\"math inline\">\\(n\\le 300,k\\le 8\\)</span>。</p>\n</blockquote>\n<p><strong>状压</strong>，<strong>区间 DP</strong>。</p>\n<p>注意到 <span class=\"math inline\">\\(k\\)</span> 只有 <span class=\"math inline\">\\(8\\)</span>，独特的输入方式也引导我们注意到状态数为 <span class=\"math inline\">\\(10^2\\)</span> 级别。合并的背景又让我们本能想到区间 DP，所以刚好盲猜这题是个 <span class=\"math inline\">\\(O(2^k\\times n^2)\\)</span> 的区间状压 DP。</p>\n<ul>\n<li><p>然后我觉得最神的一个地方是什么呢？最后的答案一定是一个长度小于 <span class=\"math inline\">\\(k\\)</span> 的串，<mark>每位展开还原，可以知道，每个合并操作选取的区间可能包含但不相交。</mark></p>\n<p>看起来很蠢很显然，但这是我们 <span class=\"math inline\">\\(n^2\\)</span> 区间 DP 的基础啊（（（</p></li>\n</ul>\n<p>然后我们区间 DP 套路，枚举对于 <span class=\"math inline\">\\([l,r]\\)</span> 最左边一位，然后就可以开始大力转移了。</p>\n<p>但是这里我们会发现，这一位原本的样子有点多，可以是任何一个长度为 <span class=\"math inline\">\\(1 + d\\times (k-1)\\)</span> 的数，所以只能再来一层 <span class=\"math inline\">\\(\\dfrac nk\\)</span> 的枚举，极限情况是个有点难绷的 3e9，作为正解只能说这个数据范围的提示性有点令人难评了。</p>\n<p>实现着实现着把自己整懵了：<code>00000</code> 和 <code>0</code> 压出来都是 <code>0</code>，但二者代表的含义显然不同，又无法简单区别。但其实<mark>长度为 <span class=\"math inline\">\\(1+d\\times (k-1)\\)</span> 的区间和长度为 <span class=\"math inline\">\\(d\\)</span> 的最终结果是一一对应的，所以在我们设计的包含了区间作右端点的状态中，压出来的就是我们想要的那个。</mark></p>\n<details>\n<p>这里的实现比<strong>所有</strong>我找到的题解都更像人打出来的。导致我想对比疗法都找不到合适的代码 <img src=\"/em/lh.gif\" /></p>\n<p>换言之，这最像是一份通常的区间 DP 代码，不存在其他题解中乱七八糟的填表啊相互影响啊之类的恶心 feature。</p>\n<p>sto rybp orz</p>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 305;\nconst int maxm = (1 &lt;&lt; 8) + 5;\nchar a[maxn];\nint c[maxm], w[maxm];\nlong long f[maxn][maxn][maxm];\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    std::cout.tie(nullptr);\n#else\n    freopen(&quot;in.in&quot;, &quot;r&quot;, stdin);\n    freopen(&quot;out.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, k;\n    std::cin &gt;&gt; n &gt;&gt; k;\n    int siz = (1 &lt;&lt; k), si = (1 &lt;&lt; (k - 1));\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i];\n    for (int i = 0; i &lt; siz; ++i)\n        std::cin &gt;&gt; c[i] &gt;&gt; w[i];\n    memset(f, -0x3f, sizeof(f));\n    for (int l = 1; l &lt; k; ++l)\n        for (int i = 1; i &lt;= n - l + 1; ++i) &#123;\n            int j = i + l - 1, now = 0;\n            for (int p = i; p &lt;= j; ++p)\n                now = now * 2 + a[p] - &#39;0&#39;;\n            f[i][j][now] = 0;\n        &#125;\n    for (int i = 1; i &lt;= n - k + 1; ++i) &#123;\n        int now = 0;\n        for (int j = i; j &lt;= i + k - 1; ++j)\n            now = now * 2 + a[j] - &#39;0&#39;;\n        f[i][i + k - 1][c[now]] = w[now];\n    &#125;\n    for (int l = k + 1; l &lt;= n; ++l)\n        for (int i = 1; i &lt;= n - l + 1; ++i) &#123;\n            int j = i + l - 1;\n            for (int p = i; p &lt; j; p += k - 1) &#123;\n                for (int q = 0; q &lt; si; ++q)\n                    if (!(q &gt;&gt; ((l - 1) % (k - 1) + 1)))\n                        f[i][j][q] = std::max(f[i][j][q], f[i][p][q &gt;&gt; ((l - 1) % (k - 1))] + f[p + 1][j][q &amp; ((1 &lt;&lt; ((l - 1) % (k - 1))) - 1)]);\n                if (l % (k - 1) == 1 || k == 2)\n                    for (int q = 0; q &lt; siz; ++q)\n                        f[i][j][c[q]] = std::max(f[i][j][c[q]], f[i][p][q &gt;&gt; (k - 1)] + f[p + 1][j][q &amp; ((1 &lt;&lt; (k - 1)) - 1)] + w[q]);\n            &#125;\n        &#125;\n    std::cout &lt;&lt; *std::max_element(f[1][n], f[1][n] + si) &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<p>其实一开始挺担心会不会因为写博客影响做题时间之类的。</p>\n<p>直到发现我可以看知乎看一个上午然后代码动都不动一下 <img src=\"/em/lh.gif\" /></p>\n<hr />\n<h2 id=\"mod-mod-mod\">2. Mod Mod Mod</h2>\n<p><a href=\"https://codeforces.com/contest/889/problem/E\" class=\"uri\">https://codeforces.com/contest/889/problem/E</a></p>\n<blockquote>\n<p>给定 <span class=\"math inline\">\\(a_{1\\sim n}\\)</span>，对于所有非负整数 <span class=\"math inline\">\\(x\\)</span> 定义 <span class=\"math inline\">\\(f(x,n)=x\\bmod a_n\\)</span>，<span class=\"math inline\">\\(f(x,i)=x\\bmod a_i+f(x\\bmod a_i,i+1)\\)</span>。</p>\n<p>求 <span class=\"math inline\">\\(f(x,1)\\)</span> 最大值。<span class=\"math inline\">\\(n\\le 2\\times 10^5\\)</span>。</p>\n</blockquote>\n<p><strong>技巧 / 特殊性质类 DP</strong>。</p>\n<p>小神题。注意到题意可以转化为，找到一个 <span class=\"math inline\">\\(x\\)</span>，最大化：</p>\n<p><span class=\"math display\">\\[\nx\\bmod a_1 + x\\bmod a_1\\bmod a_2 + \\cdots + x\\bmod a_1\\bmod a_2\\bmod\\cdots\\bmod a_n.\n\\]</span></p>\n<p>简称 <span class=\"math inline\">\\(x\\bmod a_1\\bmod a_2\\bmod \\cdots\\bmod a_i\\)</span> 的值为 <span class=\"math inline\">\\(f_i\\)</span>。</p>\n<p>这个时候我们不难注意到，<span class=\"math inline\">\\(f_i\\)</span> 肯定是<mark>单调不升</mark>的。形象化地，整个 <span class=\"math inline\">\\(f\\)</span> 序列肯定是由若干个单调下降的段组成的。并且，<mark>必定存在至少一个 <span class=\"math inline\">\\(i\\)</span>，使得 <span class=\"math inline\">\\(f_i = a_i-1\\)</span>，否则可以将所有 <span class=\"math inline\">\\(f_i\\gets f_i+1\\)</span>，同时 <span class=\"math inline\">\\(\\sum f\\gets (\\sum f) + n\\)</span></mark>。</p>\n<p>这启示我们关注 <span class=\"math inline\">\\(f_i\\)</span> 的值域。假设已经确定了 <span class=\"math inline\">\\(f\\)</span> 序列的一个前缀 <span class=\"math inline\">\\(f_1\\sim i\\)</span>，对于任意 <span class=\"math inline\">\\(0\\le k\\le f_{\\min}\\)</span>（注意由于单调不降，<span class=\"math inline\">\\(f_{\\min} = f_i\\)</span>），我们可以将所有 <span class=\"math inline\">\\(f_j\\gets f_j-k\\)</span>，得到一个新的合法的 <span class=\"math inline\">\\(f&#39;_{1\\sim i}\\)</span>。</p>\n<p>形象化地，将 <span class=\"math inline\">\\(f_{1\\sim i}\\)</span> 想象为一个逐渐降低的柱状图，任意切去了一个高度的底部，并且这个高度不高于最矮的元素（即第 <span class=\"math inline\">\\(i\\)</span> 个元素）。</p>\n<p>这时候有一个很美妙的性质，就是我们<mark>对于切之前和切之后的柱状图，其 <strong>最矮元素以上的部分</strong> 长得完全相同</mark>。然后就是神中神之 DP 状态设计。很难想象是在什么样的精神状态下凑出来这种神奇状态的，可能是某种我不了解的 trick？</p>\n<p>令 <span class=\"math inline\">\\(dp_{i, j}\\)</span> 表示对于前缀 <span class=\"math inline\">\\(f_{1, i}\\)</span>，当切去的高度为 <span class=\"math inline\">\\(0\\sim j\\)</span> 时，<strong>最矮元素以上的部分</strong> 的和都为 <span class=\"math inline\">\\(dp_{i, j}\\)</span>。那么易得 <span class=\"math inline\">\\(\\sum f_{1\\sim i}=j\\times i + dp_{i, j}\\)</span>。</p>\n<p>考虑转移。假设已知所有 <span class=\"math inline\">\\(dp_{i - 1, j}\\)</span>，需转移到 <span class=\"math inline\">\\(i\\)</span>，我们有三种转移路径：</p>\n<ol type=\"1\">\n<li><p><span class=\"math inline\">\\(j &lt; a_i\\)</span>：</p>\n对 <span class=\"math inline\">\\(a_i\\)</span> 取模取不动，不会产生任何影响。<span class=\"math inline\">\\(dp_{i, j}\\gets dp_{i - 1, j}\\)</span>。</li>\n<li><p><span class=\"math inline\">\\(j\\ge a_i\\)</span>：</p>\n<ul>\n<li><p>让 <span class=\"math inline\">\\(i\\)</span> 承担 <span class=\"math inline\">\\(f_i=a_i-1\\)</span> 的责任。我们从 <span class=\"math inline\">\\(0\\sim j\\)</span> 中找到一个满足 <span class=\"math inline\">\\(j&#39;\\bmod a_i=a_i-1\\)</span> 的 <span class=\"math inline\">\\(j&#39;\\)</span>，<span class=\"math inline\">\\(j&#39;\\)</span> 肯定是越大越好，故 <span class=\"math inline\">\\(j&#39;=(\\left\\lfloor \\dfrac {j}{a_i}\\right\\rfloor-1)\\times a_i+(a_i-1)\\)</span>。</p>\n此时便有 <span class=\"math inline\">\\(dp_{i, a_i-1}\\gets dp_{i - 1, j&#39;} + [j&#39; - (a_i-1)]\\times (i-1)\\)</span>。</li>\n<li><p>盲猜 <span class=\"math inline\">\\(0\\sim i - 1\\)</span> 或 <span class=\"math inline\">\\(i+1\\sim n\\)</span> 中会出现承担 <span class=\"math inline\">\\(f_{i&#39;}=a_{i&#39;-1}\\)</span> 的 <span class=\"math inline\">\\(i&#39;\\)</span>，故按照 <span class=\"math inline\">\\(j\\)</span> 取最大来转移。</p>\n<p>此时有 <span class=\"math inline\">\\(dp_{i, j\\bmod a_i}=dp_{i-1,j}+(j-j\\bmod a_i)\\times (i-1)\\)</span>。</p></li>\n</ul></li>\n</ol>\n<p>答案即为 <span class=\"math inline\">\\(\\max\\{j\\times n+dp_{n, j}\\}\\)</span>。由于不存在 <span class=\"math inline\">\\(f_i=a_i-1\\)</span> 的 <span class=\"math inline\">\\(f\\)</span> 肯定比存在的要劣，所以我们肯定选到的是正确的答案。</p>\n<p>注意到每个 <span class=\"math inline\">\\(i\\)</span> 只会新增 <span class=\"math inline\">\\(a_i-1\\)</span> 一个状态，故状态总数为 <span class=\"math inline\">\\(O(n)\\)</span>。把 <span class=\"math inline\">\\(dp\\)</span> 开成 map 就可以 <span class=\"math inline\">\\(O(n\\log n)\\)</span> 地解决问题。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    std::cout.tie(nullptr);\n#else\n    freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;long long&gt; a(n + 1);\n    std::map&lt;long long, long long&gt; t;\n    std::cin &gt;&gt; a[1];\n    t[a[1] - 1] = 0;\n    for (int i = 2; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; a[i];\n        for (;;) &#123;\n            auto p = t.lower_bound(a[i]);\n            if (p == t.end())\n                break;\n            long long j = p-&gt;first, f = p-&gt;second;\n            t[j % a[i]] = std::max(t[j % a[i]], f + (j - j % a[i]) * (i - 1));\n            if (j &gt;= a[i]) &#123;\n                j = (j / a[i] - 1) * a[i] + a[i] - 1;\n                t[a[i] - 1] = std::max(t[a[i] - 1], f + (j - (a[i] - 1)) * (i - 1));\n            &#125;\n            t.erase(p);\n        &#125;\n    &#125;\n    long long res = 0;\n    for (auto i : t)\n        res = std::max(res, i.first * n + i.second);\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"stalinsort-algorithm\">3. StalinSort Algorithm</h2>\n<p><a href=\"https://qoj.ac/problem/1456\" class=\"uri\">https://qoj.ac/problem/1456</a></p>\n<blockquote>\n<p>给定排列 <span class=\"math inline\">\\(A_{1\\sim n}\\)</span>。从 <span class=\"math inline\">\\(i=2\\)</span> 开始往右扫，每一步执行以下操作：</p>\n<ul>\n<li>若 <span class=\"math inline\">\\(A_i&gt; A_{i-1}\\)</span>，什么也不做。</li>\n<li>否则，你可以删除 <span class=\"math inline\">\\(A_{i-1}\\)</span> 或 <span class=\"math inline\">\\(A_i\\)</span>，但要求删除后，该前缀必须单调递增。</li>\n</ul>\n<p>问最少可以删除多少个数。<span class=\"math inline\">\\(n\\le 10^5\\)</span>。</p>\n</blockquote>\n<p>你会发现<mark>删最少 = 留最多</mark>。</p>\n<p>考虑 <span class=\"math inline\">\\(i\\)</span> 能够转移到的 <span class=\"math inline\">\\(j(j&gt;i)\\)</span> 需满足的条件。若令 <span class=\"math inline\">\\(nex_p\\)</span> 表示 <span class=\"math inline\">\\(p\\)</span> 之后第一个值比 <span class=\"math inline\">\\(a_p\\)</span> 大的元素，则 <span class=\"math inline\">\\(j\\in [nex_i, nex_{nex_i})\\)</span> 且 <span class=\"math inline\">\\(a_j&gt;a_i\\)</span>。</p>\n<p><mark>赛时误认为右端点为 <span class=\"math inline\">\\(i\\)</span> 之后第二个值比 <span class=\"math inline\">\\(a_i\\)</span> 大的元素，导致完全寄掉。</mark></p>\n<p>时间复杂度 <span class=\"math inline\">\\(O(n^2)\\)</span>，考虑优化。<mark>注意到如果只有 <span class=\"math inline\">\\(j\\in [nex_i, nex_{nex_i})\\)</span> 这个条件很容易用线段树维护，考虑消去 <span class=\"math inline\">\\(a_j&gt;a_i\\)</span> 的影响。故考虑按 <span class=\"math inline\">\\(a\\)</span> <strong>从小到大</strong> 的顺序选取 <span class=\"math inline\">\\(i\\)</span>，因为当前最小的 <span class=\"math inline\">\\(i\\)</span> 一定已经被刷完表了</mark>。</p>\n<p>时间复杂度 <span class=\"math inline\">\\(O(n\\log n)\\)</span>。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 5e5 + 5;\nconst int inf = 0x3f3f3f3f;\nstruct _ &#123; int u, d; &#125; t1[maxn &lt;&lt; 2];\nint n, t[maxn &lt;&lt; 2];\n#define lt (p &lt;&lt; 1)\n#define rt (lt | 1)\nvoid upd(int p, int l, int r, int x, int v) &#123;\n    t[p] = std::min(t[p], v);\n    if (l == r)\n        return;\n    int mid = (l + r) &gt;&gt; 1;\n    if (x &lt;= mid)\n        upd(lt, l, mid, x, v);\n    else\n        upd(rt, mid + 1, r, x, v);\n    return;\n&#125;\nint ask(int p, int l, int r, int ql, int qr) &#123;\n    if (ql &lt;= l &amp;&amp; r &lt;= qr)\n        return t[p];\n    int mid = (l + r) &gt;&gt; 1, res = n + 1;\n    if (ql &lt;= mid)\n        res = ask(lt, l, mid, ql, qr);\n    if (qr &gt; mid)\n        res = std::min(res, ask(rt, mid + 1, r, ql, qr));\n    return res;\n&#125;\nvoid pushdown(int p) &#123;\n    if (t1[p].d) &#123;\n        t1[lt].u = std::max(t1[lt].u, t1[p].d);\n        t1[lt].d = std::max(t1[lt].d, t1[p].d);       \n        t1[rt].u = std::max(t1[rt].u, t1[p].d);\n        t1[rt].d = std::max(t1[rt].d, t1[p].d);       \n        t1[p].d = 0;\n    &#125;\n    return;\n&#125;\nvoid upd(int p, int l, int r, int ql, int qr, int v) &#123;\n    t1[p].u = std::max(t1[p].u, v);\n    if (ql &lt;= l &amp;&amp; r &lt;= qr) &#123;\n        t1[p].d = std::max(t1[p].d, v);\n        return;\n    &#125;\n    pushdown(p);\n    int mid = (l + r) &gt;&gt; 1;\n    if (ql &lt;= mid)\n        upd(lt, l, mid, ql, qr, v);\n    if (qr &gt; mid)\n        upd(rt, mid + 1, r, ql, qr, v);\n    return;\n&#125;\nint ask(int p, int l, int r, int x) &#123;\n    if (l == r)\n        return t1[p].u;\n    pushdown(p);\n    int mid = (l + r) &gt;&gt; 1;\n    if (x &lt;= mid)\n        return ask(lt, l, mid, x);\n    return ask(rt, mid + 1, r, x);\n&#125;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    std::cout.tie(nullptr);\n#else\n    freopen(&quot;sort3.in&quot;, &quot;r&quot;, stdin);\n    // freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int res = 0;\n    std::cin &gt;&gt; n;\n    std::vector&lt;int&gt; a(n + 1), ne(n + 1), f(n + 1);\n    std::fill(t + 1, t + 4 * n + 1, n + 1);\n    std::fill(t1 + 1, t1 + 4 * n + 1, (_)&#123; -inf, 0 &#125;);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i];\n    for (int i = n; ~i; --i) &#123;\n        ne[i] = ask(1, 0, n, a[i] + 1, n);\n        upd(1, 0, n, a[i], i);   \n    &#125;\n    std::vector&lt;int&gt; id(n + 1);\n    std::iota(id.begin(), id.end(), 0);\n    std::sort(id.begin(), id.end(), [&amp;](int x, int y) &#123; return a[x] &lt; a[y]; &#125;);\n    f[0] = 0;\n    for (int i = 0; i &lt;= n; ++i) &#123;\n        if (i) &#123;\n            f[id[i]] = ask(1, 0, n, id[i]);\n            res = std::max(res, f[id[i]]);\n        &#125;\n        if (ne[id[i]] &lt;= n)\n            upd(1, 0, n, ne[id[i]], ne[ne[id[i]]] - 1, f[id[i]] + 1);\n    &#125;\n    std::cout &lt;&lt; n - res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"merge-triplets\">4. Merge Triplets</h2>\n<p><a href=\"https://atcoder.jp/contests/agc043/tasks/agc043_d\" class=\"uri\">https://atcoder.jp/contests/agc043/tasks/agc043_d</a></p>\n<blockquote>\n<p>给定 <span class=\"math inline\">\\(A_{1\\sim 3N}=\\{1, 2, \\dots, 3N\\}\\)</span>，从 <span class=\"math inline\">\\(1\\)</span> 开始每 <span class=\"math inline\">\\(3\\)</span> 个数分为一组，每一组初始有一个指针指向第一个元素。执行若干次以下操作：</p>\n<ul>\n<li>在所有指针指向的数中选择一个最小的，把它放到序列末（不会加入末端的组）；将原本指向它的指针后移一位，如果移出原本的组就删除这个指针。</li>\n</ul>\n<p>问任意次操作后，可能得到多少种序列。<span class=\"math inline\">\\(n\\le 2\\times 10^3\\)</span>。</p>\n</blockquote>\n<p>由于要对合法的最终序列进行计数，考虑最终序列的性质。</p>\n<p>若序列中 <span class=\"math inline\">\\(a_{i+1}&lt;a_i\\)</span>，则说明在某一组中，值为 <span class=\"math inline\">\\(a_i\\)</span> 的元素下一个就是 <span class=\"math inline\">\\(a_{i+1}\\)</span>。否则，因 <span class=\"math inline\">\\(a_{i+1}\\)</span> 可选且比 <span class=\"math inline\">\\(a_i\\)</span> 小，<span class=\"math inline\">\\(a_{i+1}\\)</span> 应排在 <span class=\"math inline\">\\(a_i\\)</span> 前面。</p>\n<p>否则，<span class=\"math inline\">\\(a_{i+1}\\)</span> 既可以与 <span class=\"math inline\">\\(a_i\\)</span> 不在同一组，也可以是 <span class=\"math inline\">\\(a_i\\)</span> 的下一个元素。</p>\n<p>一组最多三个元素，也就是说，不能出现 <span class=\"math inline\">\\(a_i&gt;a_{i+1},a_{i+2},a_{i+3}\\)</span> 的情况。而 <span class=\"math inline\">\\(N=1\\)</span> 时序列长度只有 <span class=\"math inline\">\\(3\\)</span>，这就是为什么样例一的答案为 <span class=\"math inline\">\\(3!\\)</span>。</p>\n<p>但这个限制并不能排除所有非法情况。<span class=\"math inline\">\\(N=2\\)</span> 时暴搜我们目前限制下的解，共有 276 个，比答案中的 261 个要多，说明包含了其他非法解。</p>\n<p>暴搜输出并观察，易得这 15 个非法序列即为满足目前限制且存在 <span class=\"math inline\">\\(3\\)</span> 个 <span class=\"math inline\">\\(i\\)</span>，满足 <span class=\"math inline\">\\(a_i&gt;a_{i+1}\\)</span> 且 <span class=\"math inline\">\\(a_i&lt;a_{i+2}\\)</span> 的所有序列，<mark>由前面的推导，必须分为三个长度为 2 的组，而我们要求的是长度为 3 的组。显然无法用前者组合得到后者</mark>。</p>\n<p>在我们第一个条件的限制下，必须被分到同一组的数的连续长度，只有 <span class=\"math inline\">\\(1,2,3\\)</span> 三种。而：</p>\n<ul>\n<li>长度为 3 的对答案合法性无影响；</li>\n<li>而长度为 1 的既可以和 2 组为一组，也可以和其他两个 1 组为一组；</li>\n<li>长度为 2 的只能和 1 组成一组。</li>\n</ul>\n<p><mark>这时，我们发现所有限制都指向长度为 2 的段，其总个数不能比长度为 1 的段多。</mark></p>\n<p>于是乎，上述限制可总结为两点：</p>\n<ol type=\"1\">\n<li>若令所有满足 <span class=\"math inline\">\\(a_l&gt;\\max\\{a_{l\\sim r}\\}\\)</span> 的极大区间为一段（易证每段互不重合且覆盖全序列），那么其长度不能超过 3。</li>\n<li>其中，长度为 2 的个数不能比长度为 1 的个数多。</li>\n</ol>\n<p><mark>令 <span class=\"math inline\">\\(f_{i, j}\\)</span> 表示若当前枚举的最后一段右端点为 <span class=\"math inline\">\\(i\\)</span>，长度为 1 的段比长度为 2 的段多 <span class=\"math inline\">\\(j\\)</span> 的方案数。</mark></p>\n<p>最后答案即为 <span class=\"math inline\">\\(\\sum\\limits_{j=0}^n f_{i, j}\\)</span>。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    std::cout.tie(nullptr);\n#else\n    freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, mod;\n    std::cin &gt;&gt; n &gt;&gt; mod;\n    n *= 3;\n    std::vector&lt;std::unordered_map&lt;int, long long&gt; &gt; f(n + 1);\n    f[0][0] = 1;\n    for (int i = 0; i &lt; n; ++i)\n        for (auto [j, k] : f[i]) &#123;\n            (f[i + 1][j + 1] += k) %= mod;\n            if (i + 2 &lt;= n)\n                (f[i + 2][j - 1] += k * (i + 1) % mod) %= mod;\n            if (i + 3 &lt;= n)\n                (f[i + 3][j] += k * (i + 1) % mod * (i + 2) % mod) %= mod;\n        &#125;\n    long long res = 0;\n    for (int i = 0; i &lt;= n; ++i)\n        (res += f[n][i]) %= mod;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"runaway-quail\">5. Runaway Quail</h2>\n<p><a href=\"https://qoj.ac/problem/5978\" class=\"uri\">https://qoj.ac/problem/5978</a></p>\n<blockquote>\n<p>数轴上有 <span class=\"math inline\">\\(n\\)</span> 只鸡，初始位置为非 <span class=\"math inline\">\\(0\\)</span> 整数 <span class=\"math inline\">\\(p_i\\)</span>，奔跑速度为 <span class=\"math inline\">\\(s_i\\)</span>。你初始在 <span class=\"math inline\">\\(0\\)</span> 位置，奔跑速度为 <span class=\"math inline\">\\(Y(Y&gt;s_i)\\)</span>。你要抓到所有鸡。</p>\n<p>你可以在任意时刻调转方向；鸡总会朝着远离你的方向奔跑；当你的坐标和鸡重合时，你抓到鸡。</p>\n<p>问抓到所有鸡的最短时间（显然是个实数）。<span class=\"math inline\">\\(n\\le 500\\)</span>。</p>\n</blockquote>\n<p>容易发现鸡的奔跑方向从始至终不会变，如果我们要从往左追变成往右追，显而易见地我们会<mark>在追上右边第一只鸡前经过原点</mark>，反之同理。</p>\n<p>那么有一个很神奇的状态设计，设 <span class=\"math inline\">\\(f_{i,j}\\)</span> 为追上了左边速度第 <span class=\"math inline\">\\(1\\sim i - 1\\)</span> 大的所有鸡和右边速度第 <span class=\"math inline\">\\(1\\sim j - 1\\)</span> 大的所有鸡，然后跑回原点的最小时间，这样我们就不用记录这个非常难记录的当前位置信息，对于速度排名 <span class=\"math inline\">\\(\\ge i,j\\)</span> 的所有鸡，当前是否追上我们并不关心——<mark>如果其位置比较远，那么我们会在后续转移中再考虑；如果其位置比较近，在解决速度排名 <span class=\"math inline\">\\(&lt;i,j\\)</span> 的鸡时就已经抓住</mark>。</p>\n<p><mark>我们 <span class=\"math inline\">\\(\\mathcal O(n)\\)</span> 枚举上一次反向是在抓住哪一只鸡时，然后让中间全部同向跑即可</mark>。</p>\n<p>也就是说，假设我们要用 <span class=\"math inline\">\\(f_{i,j}\\)</span> 更新 <span class=\"math inline\">\\(f_{k,j}\\)</span>（<span class=\"math inline\">\\(k&lt;i\\)</span>），那么只需要更新抓住速度排名 <span class=\"math inline\">\\(i\\sim k+1\\)</span> 中跑得最远的一只鸡所需额外时间。按速度排序后可以线性算代价。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst long double eps = 1e-12;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int T;\n    for (std::cin &gt;&gt; T; T--; ) &#123;\n        int v, n;\n        std::cin &gt;&gt; v &gt;&gt; n;\n        std::vector&lt;std::pair&lt;int, int&gt; &gt; a(n + 1);\n        for (int i = 1; i &lt;= n; ++i)\n            std::cin &gt;&gt; a[i].first;\n        for (int i = 1; i &lt;= n; ++i)\n            std::cin &gt;&gt; a[i].second;\n        a.emplace_back(0, 0), ++n;\n        std::sort(a.begin() + 1, a.end());\n        int p = std::lower_bound(a.begin() + 1, a.end(), std::make_pair(0, 0)) - a.begin();\n        std::sort(a.begin() + 1, a.begin() + p, [](std::pair&lt;int, int&gt; x, std::pair&lt;int, int&gt; y) &#123; return x.second == y.second ? x.first &lt; y.first : x.second &gt; y.second; &#125;);\n        std::sort(a.begin() + p + 1, a.end(), [](std::pair&lt;int, int&gt; x, std::pair&lt;int, int&gt; y) &#123; return x.second == y.second ? x.first &lt; y.first : x.second &lt; y.second; &#125;);\n        std::vector&lt;std::vector&lt;long double&gt; &gt; f(n + 1, std::vector&lt;long double&gt; (n + 1, 1e18));\n        f[1][n] = 0.;\n        auto at = [&amp;](int i, long double t) &#123;\n            return std::fabs(a[i].first + t * a[i].second * (i &lt; p ? -1 : 1));\n        &#125;;\n        auto calc = [&amp;](int i, long double t) &#123;\n            return at(i, t) / (v - a[i].second);\n        &#125;;\n        // for (int i = 1; i &lt;= n; ++i)\n        //     printf(&quot;%d: (%d, %d)\\n&quot;, i, a[i].first, a[i].second);\n        for (int i = 1; i &lt;= p; ++i)\n            for (int j = n; j &gt;= p; --j) &#123;\n                if (i == p &amp;&amp; j == p)\n                    break;\n                long double d = 0.;\n                // printf(&quot;[%d, %d]: %lf\\n&quot;, i, j, f[i][j]);\n                for (int k = i; k &lt; p; ++k) &#123;\n                    if (at(k, f[i][j]) &gt;= at(i, f[i][j]) - eps)\n                        d = std::max(d, calc(k, f[i][j]));\n                    // printf(&quot;  k1 = %d, d = %lf\\n&quot;, k, d);\n                    f[k + 1][j] = std::min(f[k + 1][j], f[i][j] + d + (k != j - 1) * d);\n                &#125;\n                d = 0.;\n                for (int k = j; k &gt; p; --k) &#123;\n                    if (at(k, f[i][j]) &gt;= at(j, f[i][j]) - eps)\n                        d = std::max(d, calc(k, f[i][j]));\n                    // printf(&quot;  k2 = %d, d = %lf\\n&quot;, k, d);\n                    f[i][k - 1] = std::min(f[i][k - 1], f[i][j] + d + (k != i + 1) * d);\n                &#125;\n            &#125;\n        &#123;\n            static int casetot = 0;\n            std::cout &lt;&lt; &quot;Case #&quot; &lt;&lt; ++casetot &lt;&lt; &quot;: &quot;;\n        &#125;\n        std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(9) &lt;&lt; f[p][p] &lt;&lt; &#39;\\n&#39;;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"the-great-marathon\">6. The Great Marathon</h2>\n<p><a href=\"https://codeforces.com/problemset/problem/38/H\" class=\"uri\">https://codeforces.com/problemset/problem/38/H</a></p>\n<blockquote>\n<p>给定一个 <span class=\"math inline\">\\(n\\)</span> 个点 <span class=\"math inline\">\\(m\\)</span> 条边的无向连通图，点 <span class=\"math inline\">\\(i\\)</span> 上初始有选手 <span class=\"math inline\">\\(i\\)</span>。为每个选手任意指定终点（可重复），那么最后的排名按照最短路为第一关键字、编号为第二关键字排序。</p>\n<p>现按照排名序列分成前中后三段，记为金银铜牌；满足金牌数在 <span class=\"math inline\">\\([g_1,g_2]\\)</span> 之间，银牌数在 <span class=\"math inline\">\\([s_1,s_2]\\)</span> 之间。任意指定发牌数量和每个人的终点，问最后有多少种方案数；两个方案不同当且仅当有至少一个人拿的牌不一样。</p>\n<p><span class=\"math inline\">\\(n\\le 50,m\\le 1000\\)</span>。</p>\n</blockquote>\n<p><mark><span class=\"math inline\">\\(n=50\\)</span>：可能需要考虑 <span class=\"math inline\">\\(n^5\\)</span> 做法。</mark></p>\n<p>发现是 <mark>需要确定顺序的 DP</mark>。关键位置自然在于『金银、银铜界处』。考虑钦定金牌最后一名、铜牌第一名的人选（不考虑中间的银牌是因为会出现这样那样的问题），还需要枚举他们的路程吗？并不。甚而至于，这样做会算重。</p>\n<p>考虑<mark>『最小化』左右两侧的金牌、铜牌可选集合</mark>。强行让金牌最后一名 <span class=\"math inline\">\\(u\\)</span> 的路程为 <span class=\"math inline\">\\(\\min\\{dis_{u,i}\\}\\)</span>，最小路程小于这个值的所有元素都可以成为金牌；同时让铜牌第一名 <span class=\"math inline\">\\(v\\)</span> 的路程为 <span class=\"math inline\">\\(\\max\\{dis_{v,i}\\}\\)</span>，最大路程大于这个值的所有数都可以成为铜牌。</p>\n<p>Q1: 如果存在一个 <span class=\"math inline\">\\(i\\)</span>，它最小的距离也比 <span class=\"math inline\">\\(u\\)</span> 的最小距离大，但实际上当 <span class=\"math inline\">\\(u\\)</span> 更大一点儿的时候，<span class=\"math inline\">\\(i\\)</span> 可以成为金牌呢？</p>\n<p>A1：这种情况在钦定 <span class=\"math inline\">\\(i\\)</span> 为最后一名的时候讨论过了。</p>\n<p>Q2：是否会算重？</p>\n<p>A2：如上所述，假如在钦定 <span class=\"math inline\">\\(i\\)</span> 的时候统计了 <span class=\"math inline\">\\(u\\)</span>，那么在钦定 <span class=\"math inline\">\\(u\\)</span> 的时候就不会统计 <span class=\"math inline\">\\(i\\)</span>。</p>\n<p>考虑转移。令 <span class=\"math inline\">\\(f_{i,u,v,j,k}\\)</span> 为考虑到 <span class=\"math inline\">\\(i\\)</span>，金牌倒一为 <span class=\"math inline\">\\(u\\)</span>，铜牌第一为 <span class=\"math inline\">\\(v\\)</span>，选了 <span class=\"math inline\">\\(j\\)</span> 个金、<span class=\"math inline\">\\(k\\)</span> 个铜的方案数。转移是 <span class=\"math inline\">\\(O(1)\\)</span> 的。</p>\n<details>\n<p>注意 <code>vector</code> 要开在循环外面，不然申请空间很耗时间 /ll</p>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int inf = 0x3f3f3f3f;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, m;\n    std::cin &gt;&gt; n &gt;&gt; m;\n    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1, std::vector&lt;int&gt; (n + 1, inf));\n    for (int x, y; m--; ) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y;\n        std::cin &gt;&gt; g[x][y], g[y][x] = g[x][y];\n    &#125;\n    for (int i = 1; i &lt;= n; ++i)\n        g[i][i] = 0;\n    for (int k = 1; k &lt;= n; ++k)\n        for (int i = 1; i &lt;= n; ++i)\n            if (k != i)\n                for (int j = 1; j &lt;= n; ++j)\n                    if (i != k &amp;&amp; j != k)\n                        g[i][j] = std::min(g[i][j], g[i][k] + g[k][j]);\n    int g1, g2, s1, s2;\n    std::cin &gt;&gt; g1 &gt;&gt; g2 &gt;&gt; s1 &gt;&gt; s2;\n    for (int i = 1; i &lt;= n; ++i)\n        for (int j = 1; j &lt;= n; ++j)\n            if (g[i][j] != inf)\n                g[i][j] = g[i][j] * n + i;\n    std::vector&lt;int&gt; mx(n + 1), mn(n + 1, inf);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        for (int j = 1; j &lt;= n; ++j)\n            if (j != i)\n                mn[i] = std::min(mn[i], g[i][j]);\n        mx[i] = *std::max_element(g[i].begin() + 1, g[i].end());\n    &#125;\n    auto res(0ll);\n    std::vector&lt;std::vector&lt;std::vector&lt;long long&gt; &gt; &gt; f(n + 1, std::vector&lt;std::vector&lt;long long&gt; &gt; (n + 1, std::vector&lt;long long&gt; (n + 1)));\n    for (int u = 1; u &lt;= n; ++u)\n        for (int v = 1; v &lt;= n; ++v)\n            if (v != u) &#123;\n                f[0][1][1] = 1ll;\n                for (int i = 1; i &lt;= n; ++i)\n                    if (i == u || i == v)\n                        f[i] = f[i - 1];\n                    else &#123;\n                        bool flag = 0;\n                        for (int j = 1; j &lt;= n; ++j)\n                            if (mn[u] &lt; g[i][j] &amp;&amp; g[i][j] &lt; mx[v]) &#123;\n                                flag = 1;\n                                break;\n                            &#125;\n                        for (int j = 1; j &lt;= g2; ++j)\n                            for (int k = 1; k &lt;= n - g1 - s1; ++k) &#123;\n                                f[i][j][k] = 0ll;\n                                if (mx[i] &lt; mn[u])\n                                    f[i][j][k] = f[i - 1][j - 1][k];\n                                else if (mn[i] &gt; mx[v])\n                                    f[i][j][k] = f[i - 1][j][k - 1];\n                                else &#123;\n                                    if (flag)\n                                        f[i][j][k] = f[i - 1][j][k];\n                                    if (mn[i] &lt; mn[u])\n                                        f[i][j][k] += f[i - 1][j - 1][k];\n                                    if (mx[i] &gt; mx[v])\n                                        f[i][j][k] += f[i - 1][j][k - 1];\n                                &#125;\n                            &#125;\n                    &#125;\n                for (int g = g1; g &lt;= g2; ++g)\n                    for (int s = s1; s &lt;= s2; ++s)\n                        res += f[n][g][n - g - s];\n            &#125;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"sorting-pancakes\">7. Sorting Pancakes</h2>\n<p><a href=\"https://codeforces.com/contest/1675/problem/G\" class=\"uri\">https://codeforces.com/contest/1675/problem/G</a></p>\n<blockquote>\n<p>给定盒子 <span class=\"math inline\">\\(1\\sim n\\)</span> 和每个盒子 <span class=\"math inline\">\\(i\\)</span> 里的初始球数 <span class=\"math inline\">\\(a_i\\)</span>，每次可以选择一个球移动到相邻盒子，最后欲使盒子内球数单调不升,求最小移球次数。</p>\n<p><span class=\"math inline\">\\(n,\\sum a_i\\le 250\\)</span>。</p>\n</blockquote>\n<p>简单题！这种『移动元素的题』，会考虑<mark>钦定每个元素最终的值，把前面的元素富余的 / 欠下来的存储起来</mark>。<em>当然也有例外，比如添加了『时间』这一维的限制，goto <a href=\"http://localhost:4000/20250510/#a---pass-to-next\">solu to Pass to Next</a></em></p>\n<p>在如果在 <span class=\"math inline\">\\(i\\)</span> 处富余了 <span class=\"math inline\">\\(x\\)</span>，那么在移动到 <span class=\"math inline\">\\(i+1\\)</span> 的过程中就会产生 <span class=\"math inline\">\\(|x|\\)</span> 的代价。</p>\n<p>令 <span class=\"math inline\">\\(f_{i,k,j}\\)</span> 表示第 <span class=\"math inline\">\\(i\\)</span> 个元素处，钦定它最终为 <span class=\"math inline\">\\(j\\)</span>，富余 <span class=\"math inline\">\\(k\\)</span>，则 <span class=\"math inline\">\\(f_{i,k,j}\\gets \\min\\limits_{j&#39;\\ge j}\\{f_{i-1, k-(j-a_i),j&#39;}\\}\\)</span>。显而易见后缀 min 优化就能 <span class=\"math inline\">\\(O(n\\cdot m^2)\\)</span> 地做了。</p>\n<details>\n<p>DP 数组和后缀 min 数组要合起来，不然会 MLE /ll</p>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int inf = 0x3f3f3f3f;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, m;\n    std::cin &gt;&gt; n &gt;&gt; m;\n    std::vector&lt;int&gt; a(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i];\n    using arr = std::vector&lt;int&gt;;\n    using brr = std::vector&lt;arr&gt;;\n    using crr = std::vector&lt;brr&gt;;\n    crr f(n + 1, brr(2 * m + 1, arr(m + 1, inf)));\n    std::fill(f[0][m].begin(), f[0][m].begin() + m + 1, 0);\n    for (int i = 1; i &lt;= n; ++i)\n        for (int k = 0; k &lt;= 2 * m; ++k)\n            for (int j = std::min(m, k + a[i]); j &gt;= std::max(0, k + a[i] - 2 * m); --j) &#123;\n                f[i][k][j] = f[i - 1][k - (j - a[i])][j] + std::abs(k - m);\n                if (j != m)\n                    f[i][k][j] = std::min(f[i][k][j], f[i][k][j + 1]);\n            &#125;\n    std::cout &lt;&lt; f[n][m][0] &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"complexity\">8. Complexity</h2>\n<p><a href=\"https://atcoder.jp/contests/agc033/tasks/agc033_d\" class=\"uri\">https://atcoder.jp/contests/agc033/tasks/agc033_d</a></p>\n<blockquote>\n<p>给定 <span class=\"math inline\">\\(n\\times m\\)</span> 的 <span class=\"math inline\">\\(01\\)</span> 矩阵。定义其子矩阵的凌乱度：</p>\n<ul>\n<li>若该矩阵中只有一种值，凌乱度为 <span class=\"math inline\">\\(0\\)</span>。</li>\n<li>否则，任意竖直 / 水平切一刀，得到两个小矩阵；若它们的凌乱度分别为 <span class=\"math inline\">\\(a,b\\)</span>，则大矩阵的凌乱度为 <span class=\"math inline\">\\(\\max(a,b)+1\\)</span> 的最小值。</li>\n</ul>\n<p>求给定矩阵的凌乱度。<span class=\"math inline\">\\(n,m\\le 185\\)</span>。</p>\n</blockquote>\n<p>如果暴力枚举 DP，很不幸是 <span class=\"math inline\">\\(n^5\\)</span> 的。考虑优化。发现矩阵的凌乱度大致在 <span class=\"math inline\">\\(O(\\log n)\\)</span> 级别，考虑用<mark>状态交换答案</mark>减小复杂度。具体地，设 <span class=\"math inline\">\\(f_{k,u,d,l}\\)</span> 表示凌乱度 <span class=\"math inline\">\\(\\le k\\)</span> 时，<span class=\"math inline\">\\(r\\)</span> 可取到的最大值，那么有转移：</p>\n<ul>\n<li>竖着切一刀，枚举切点 <span class=\"math inline\">\\(i\\le f_{k-1,u,d,l}\\)</span>，有 <span class=\"math inline\">\\(f_{k,u,d,l}\\gets f_{k-1,u,d,i+1}\\)</span>。发现显然 <span class=\"math inline\">\\(i\\)</span> 取 <span class=\"math inline\">\\(f_{k-1,u,d,l}\\)</span> 的时候最优，这个是 <span class=\"math inline\">\\(O(1)\\)</span> 的。</li>\n<li>横着切一刀，枚举切点 <span class=\"math inline\">\\(i\\in[u,d)\\)</span>，有 <span class=\"math inline\">\\(f_{k,u,d,l}\\gets \\min(f_{k-1,u,i,l},f_{k-1,i+1,d,l})\\)</span>。发现随 <span class=\"math inline\">\\(i\\)</span> 增大左边单调不增，右边单调不降。随着 <span class=\"math inline\">\\(d\\)</span> 的增大，左边不变，右边下移，交出来的交点一直右移。然后就可以优化到均摊 <span class=\"math inline\">\\(O(1)\\)</span>。</li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int inf = 0x3f3f3f3f;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, m;\n    std::cin &gt;&gt; n &gt;&gt; m;\n    std::vector&lt;std::vector&lt;char&gt; &gt; a(n + 1, std::vector&lt;char&gt; (m + 1));\n    for (int i = 1; i &lt;= n; ++i)\n        for (int j = 1; j &lt;= m; ++j)\n            std::cin &gt;&gt; a[i][j];\n    using arr = std::vector&lt;int&gt;;\n    using brr = std::vector&lt;arr&gt;;\n    using crr = std::vector&lt;brr&gt;;\n    std::vector&lt;std::string&gt; res;\n    std::vector&lt;crr&gt; _f(2, crr(n + 1, brr(m + 1, arr(n + 1))));\n    for (int k = 0; ; ++k) &#123;\n        auto &amp;f = _f[k &amp; 1], &amp;f1 = _f[(k &amp; 1) ^ 1];\n        if (k == 0) &#123;\n            crr tag(m + 1, brr(n + 1, arr(n + 1, -1)));\n            for (int l = 1; l &lt;= m; ++l)\n                for (int u = 1; u &lt;= n; ++u)\n                    for (int d = u; d &lt;= n &amp;&amp; a[d][l] == a[u][l]; ++d)\n                        tag[l][u][d] = a[u][l];\n            for (int u = 1; u &lt;= n; ++u)\n                for (int d = u; d &lt;= n; ++d)\n                    for (int l = m; l; --l) &#123;\n                        f[u][l][d] = l - 1;\n                        if (~tag[l][u][d]) &#123;\n                            if (l != m &amp;&amp; tag[l][u][d] == tag[l + 1][u][d])\n                                f[u][l][d] = f[u][l + 1][d];\n                            else\n                                f[u][l][d] = l;\n                        &#125;\n                    &#125;\n        &#125;\n        else\n            for (int u = 1; u &lt;= n; ++u)\n                for (int l = 1; l &lt;= m; ++l)\n                    for (int d = u, pos = 1; d &lt;= n; ++d) &#123;\n                        f[u][l][d] = f1[u][l][d];\n                        if (f[u][l][d] != m) &#123;\n                            f[u][l][d] = std::max(f[u][l][d], f1[u][f1[u][l][d] + 1][d]);\n                            int mx = 0;\n                            for (int i = pos; i &lt; d; ++i) &#123;\n                                if (std::min(f1[u][l][i], f1[i + 1][l][d]) &gt;= mx)\n                                    mx = std::min(f1[u][l][i], f1[i + 1][l][d]), pos = i;\n                                else\n                                    break;\n                            &#125;\n                            f[u][l][d] = std::max(f[u][l][d], mx);\n                        &#125;\n                    &#125;\n        if (f[1][1][n] == m) &#123;\n            std::cout &lt;&lt; k &lt;&lt; &#39;\\n&#39;;\n            return 0;\n        &#125;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"boxes-and-balls\">9. Boxes and Balls</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/CF1845E\" class=\"uri\">https://www.luogu.com.cn/problem/CF1845E</a></p>\n<blockquote>\n<p>给定一个长度为 <span class=\"math inline\">\\(n\\)</span> 的 <span class=\"math inline\">\\(01\\)</span> 序列 <span class=\"math inline\">\\(a_{1\\sim n}\\)</span>。你可以进行恰好 <span class=\"math inline\">\\(k\\)</span> 次如下操作：</p>\n<ul>\n<li>选择序列中一对相邻且值不同的元素，将它们交换。</li>\n</ul>\n<p>问有多少种最终序列。<span class=\"math inline\">\\(n,k\\le 1500\\)</span>。</p>\n</blockquote>\n<p>沿用 <a href=\"#sorting-pancakes\">7. Sorting Pancakes</a> 的思路，考虑令 <span class=\"math inline\">\\(f_{i,j,l}\\)</span> 表示最终序列的前 <span class=\"math inline\">\\(i\\)</span> 个里有 <span class=\"math inline\">\\(j\\)</span> 个 <span class=\"math inline\">\\(1\\)</span>，代价已经有 <span class=\"math inline\">\\(l\\)</span> 的方案数；那么令 <span class=\"math inline\">\\(s_i\\)</span> 为 <span class=\"math inline\">\\(a\\)</span> 的前缀和，显然有：</p>\n<p><span class=\"math display\">\\[\nf_{i+1,j+1,k+|j-s_i|}\\gets f_{i,j,k}\\\\\nf_{i+1,j,k+|j-s_i|}\\gets f_{i,j,k}\n\\]</span></p>\n<p>最后在比 <span class=\"math inline\">\\(k\\)</span> 小且奇偶性和 <span class=\"math inline\">\\(k\\)</span> 相同的 <span class=\"math inline\">\\(l\\)</span> 里找答案。然后想怎么优化。</p>\n<p>答案是不用优化。考虑<mark>有效状态数</mark>，<del>打个表发现每个 <span class=\"math inline\">\\(i\\)</span> 在 <span class=\"math inline\">\\(O(n\\sqrt n)\\)</span> 左右</del>，但有另一种方法是发现有效的 <span class=\"math inline\">\\(|j-s_i|\\)</span> 不会超过 <span class=\"math inline\">\\(O(\\sqrt n)\\)</span>（原因：为了消除 <span class=\"math inline\">\\(|j-s_i|\\)</span> 的欠账，需要 <span class=\"math inline\">\\(|j-s_i|\\)</span> 个位置；每个位置都会有差不多 <span class=\"math inline\">\\(|j-s_i|\\)</span> 的代价），所以枚举时只用枚举 <span class=\"math inline\">\\(O(\\sqrt n)\\)</span> 个 <span class=\"math inline\">\\(j\\)</span>。</p>\n<p>总之只用存有效状态会发现跑不满 <img src=\"/em/bb.gif\" /></p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 1e9 + 7;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, k;\n    std::cin &gt;&gt; n &gt;&gt; k;\n    std::vector&lt;int&gt; a(n + 1), s(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i];\n    std::partial_sum(a.begin() + 1, a.end(), s.begin() + 1);\n    using arr = std::vector&lt;long long&gt;;\n    using brr = std::vector&lt;arr&gt;;\n    using crr = std::vector&lt;brr&gt;;\n    brr tag(n + 1, arr(n + 1));\n    std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; stt(2);\n    stt[0].emplace_back(0, 0);\n    crr _f(2, brr(n + 1, arr(k + 1)));\n    _f[0][0][0] = 1;\n    for (int i = 0; i &lt; n; ++i) &#123;\n        auto &amp;f = _f[i &amp; 1], &amp;f1 = _f[(i &amp; 1) ^ 1];\n        std::vector&lt;std::pair&lt;int, int&gt; &gt;().swap(stt[(i &amp; 1) ^ 1]);\n        for (auto [j, l] : stt[i &amp; 1]) &#123;\n                if (j + 1 &lt;= s[n] &amp;&amp; l + std::abs(j - s[i]) &lt;= k) &#123;\n                    if (tag[j + 1][l + std::abs(j - s[i])] != i + 1)\n                        tag[j + 1][l + std::abs(j - s[i])] = i + 1, stt[(i &amp; 1) ^ 1].emplace_back(j + 1, l + std::abs(j - s[i])), f1[j + 1][l + std::abs(j - s[i])] = 0ll;\n                    (f1[j + 1][l + std::abs(j - s[i])] += f[j][l]) %= mod;\n                &#125;\n                if (l + std::abs(j - s[i]) &lt;= k) &#123;\n                    if (tag[j][l + std::abs(j - s[i])] != i + 1)\n                        tag[j][l + std::abs(j - s[i])] = i + 1, stt[(i &amp; 1) ^ 1].emplace_back(j, l + std::abs(j - s[i])), f1[j][l + std::abs(j - s[i])] = 0ll;\n                    (f1[j][l + std::abs(j - s[i])] += f[j][l]) %= mod;\n                &#125;\n            &#125;\n        std::cout &lt;&lt; (int)stt[i &amp; 1].size() &lt;&lt; &#39;\\n&#39;;\n    &#125;\n    auto res(0ll);\n    for (int i = k &amp; 1; i &lt;= k; i += 2)\n        if (tag[s[n]][i] == n)\n            (res += _f[n &amp; 1][s[n]][i]) %= mod;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"legondary-grandmaster\">10. LEGOndary Grandmaster</h2>\n<p><a href=\"https://codeforces.com/problemset/problem/1615/F\" class=\"uri\">https://codeforces.com/problemset/problem/1615/F</a></p>\n<blockquote>\n<p>给定两个长度为 <span class=\"math inline\">\\(n\\)</span> 的 <span class=\"math inline\">\\(0/1/?\\)</span> 串 <span class=\"math inline\">\\(s,t\\)</span>，你可以对 <span class=\"math inline\">\\(s\\)</span> 进行若干次如下操作：</p>\n<ul>\n<li>选择序列中一对相邻且值相同的元素，将它们取反。</li>\n</ul>\n<p>现任意将 <span class=\"math inline\">\\(s\\)</span> 和 <span class=\"math inline\">\\(t\\)</span> 中的 <code>?</code> 填为 <span class=\"math inline\">\\(0/1\\)</span>，问所有情况中 <span class=\"math inline\">\\(s\\)</span> 转化为 <span class=\"math inline\">\\(t\\)</span> 所需最小操作次数和（规定无解的操作次数为 <span class=\"math inline\">\\(0\\)</span>）。<span class=\"math inline\">\\(n\\le 2000\\)</span>。</p>\n</blockquote>\n<p>如果我们之前做过某些令人心（咬）旷（牙）神（切）怡（齿）的题目，会发现这个操作等价于交换任意两个相邻数，再让他们取反。</p>\n<p>进一步地，可以交换运算顺序，先取反某个位置，再交换，再取反这个位置——把这个操作平均分配到 <span class=\"math inline\">\\(s\\)</span> 和 <span class=\"math inline\">\\(t\\)</span> 上，<mark>结合『相邻两数位置必一奇一偶』这个美妙的性质，想到把 <span class=\"math inline\">\\(s\\)</span> 和 <span class=\"math inline\">\\(t\\)</span> 的奇数位都提前取反，这样就可以转化成直接交换了</mark>，</p>\n<p>接下来就和上一题有点不一样了。这里我们直接算一个位置的贡献——这意味着不需要统计一个序列的代价（此时失去了 <span class=\"math inline\">\\(k\\)</span> 的限制，代价来到 <span class=\"math inline\">\\(n^2\\)</span> 级别）。令 <span class=\"math inline\">\\(f_{i,j}\\)</span> 表示从前往后到了第 <span class=\"math inline\">\\(i\\)</span> 个位置，欠债为 <span class=\"math inline\">\\(j\\)</span> 的方案数；同样地，令 <span class=\"math inline\">\\(g_{i,j}\\)</span> 表示从后到前到了第 <span class=\"math inline\">\\(i\\)</span> 个位置，欠债为 <span class=\"math inline\">\\(j\\)</span> 的方案数。则贡献为 <span class=\"math inline\">\\(\\sum_i \\sum_j f_{i, j}\\times g_{i + 1, -j}\\times j\\)</span>。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 1e9 + 7;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int T;\n    for (std::cin &gt;&gt; T; T--; ) &#123;\n        int n;\n        std::string s, t;\n        std::cin &gt;&gt; n &gt;&gt; s &gt;&gt; t, s = &#39;#&#39; + s, t = &#39;#&#39; + t;\n        for (int i = 1; i &lt;= n; ++i)\n            if (i &amp; 1) &#123;\n                if (s[i] != &#39;?&#39;)\n                    s[i] = &#39;0&#39; + &#39;1&#39; - s[i];\n                if (t[i] != &#39;?&#39;)\n                    t[i] = &#39;0&#39; + &#39;1&#39; - t[i];\n            &#125;\n        using arr = std::vector&lt;long long&gt;;\n        using brr = std::vector&lt;arr&gt;;\n        brr f(n + 1, arr(2 * n + 1)), g(n + 2, arr(2 * n + 1));\n        f[0][n] = 1ll;\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            for (int S = 0; S &lt;= 1; ++S)\n                if ((S == 0 &amp;&amp; s[i] == &#39;1&#39;) || (S == 1 &amp;&amp; s[i] == &#39;0&#39;));\n                else\n                    for (int T = 0; T &lt;= 1; ++T) &#123;\n                        if ((T == 0 &amp;&amp; t[i] == &#39;1&#39;) || (T == 1 &amp;&amp; t[i] == &#39;0&#39;));\n                        else\n                            for (int j = 0; j &lt;= 2 * n; ++j)\n                                if (j - (T - S) &gt;= 0 &amp;&amp; j - (T - S) &lt;= 2 * n)\n                                    (f[i][j] += f[i - 1][j - (T - S)]) %= mod;\n                    &#125;\n        &#125;\n        g[n + 1][n] = 1ll;\n        for (int i = n; i; --i) &#123;\n            for (int S = 0; S &lt;= 1; ++S)\n                if ((S == 0 &amp;&amp; s[i] == &#39;1&#39;) || (S == 1 &amp;&amp; s[i] == &#39;0&#39;));\n                else\n                    for (int T = 0; T &lt;= 1; ++T) &#123;\n                        if ((T == 0 &amp;&amp; t[i] == &#39;1&#39;) || (T == 1 &amp;&amp; t[i] == &#39;0&#39;));\n                        else\n                            for (int j = 0; j &lt;= 2 * n; ++j)\n                                if (j - (T - S) &gt;= 0 &amp;&amp; j - (T - S) &lt;= 2 * n)\n                                    (g[i][j] += g[i + 1][j - (T - S)]) %= mod;\n                    &#125;\n        &#125;\n        auto res(0ll);\n        for (int i = 1; i &lt; n; ++i)\n            for (int j = 1; j &lt;= n; ++j) &#123;\n                (res += j * f[i][n + j] % mod * g[i + 1][n - j] % mod) %= mod;\n                (res += j * f[i][n - j] % mod * g[i + 1][n + j] % mod) %= mod;\n            &#125;\n        std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n",
            "tags": [
                "DP"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20240501/",
            "url": "https://xsc062.netlify.app/20240501/",
            "title": "五一杂题",
            "date_published": "2024-05-01T07:44:48.000Z",
            "content_html": "<p><a href=\"http://222.180.160.110:61235/contest/5169\">SAM 杂题</a> + <a href=\"http://222.180.160.110:61235/contest/5170\">NOIPS8</a> + <a href=\"http://222.180.160.110:61235/contest/5175\">周考</a> 选讲。</p>\n<p>看看这个标签列表长度就知道这三天做的题有多杂。</p>\n<span id=\"more\"></span>\n<hr />\n<h3 id=\"d.-字符串\">D. 字符串</h3>\n<p><a href=\"http://222.180.160.110:61235/contest/5169/problem/4\" class=\"uri\">http://222.180.160.110:61235/contest/5169/problem/4</a></p>\n<p>和 SA 的做法一样，先二分 <span class=\"math inline\">\\(s_{c\\sim d}\\)</span> 的前缀长度 <span class=\"math inline\">\\(mid\\)</span>，只需 check <span class=\"math inline\">\\(s_{c \\sim c + mid - 1}\\)</span> 是否在 <span class=\"math inline\">\\(s_{a\\sim b}\\)</span> 中出现过。</p>\n<p>考虑怎么快速 check。从 <span class=\"math inline\">\\(c\\)</span> 一步一步跳到 <span class=\"math inline\">\\(c+mid-1\\)</span> 显然会起飞，考虑到查询是静态的，我们事先预处理一下然后倍增地跳即可。</p>\n<p>此时只需看当前状态的 <span class=\"math inline\">\\(\\text {endpos}\\)</span> 是否在 <span class=\"math inline\">\\([a + mid - 1, b]\\)</span> 出现过。</p>\n<p>因为这个不能用最大最小简单代替，所以就到了我们喜闻乐见的线段树合并环节。将插入后的每个单点 <span class=\"math inline\">\\(\\text {endpos}\\)</span> 在权值线段树上更新，在 parent tree 上暴力线段树合并即可。</p>\n<p>之前一直有一个误区，就是觉得线段树合并是一次性的，比如用 A 树和 B 树并出来了 C 树之后，A 树和 B 树的数据就无效了。</p>\n<p>但这显然是很荒谬的，同样因为我们的查询是静态的，所以完全可以用一种类似于可持久化的方式，建立一些新的点表示合并后的信息状态点，一些可以保留的点就保留作儿子。</p>\n<p>在对应的状态上查询即可。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxm = 35;\nconst int maxn = 6e5 + 5;\nconst int maxk = 8e7 + 5;\nstruct _ &#123;\n    int l, f;\n    int ne[maxm]; \n    _() &#123;&#125;\n    _(int l1, int f1): l(l1), f(f1) &#123;&#125;\n&#125;;\n_ t[maxn &lt;&lt; 1];\nint vis[maxn &lt;&lt; 1];\nint fa[maxn][maxm];\nint n, la, tot, siz;\nstruct &#123; int l, r, u; &#125; t1[maxk];\nint tab[maxn &lt;&lt; 1], cnt[maxn &lt;&lt; 1];\nvoid Init(void) &#123;\n    la = tot = 1;\n    t[1] = _(0, 0);\n    return;\n&#125;\nvoid ext(int c) &#123;\n    int p = la, np = ++tot;\n    la = tot;\n    t[np] = _(t[p].l + 1, 0);\n    while (p &amp;&amp; !t[p].ne[c])\n        t[p].ne[c] = np, p = t[p].f;\n    if (!p)\n        t[np].f = 1;\n    else &#123;\n        int q = t[p].ne[c];\n        if (t[q].l == t[p].l + 1)\n            t[np].f = q;\n        else &#123;\n            int nq = ++tot;\n            t[nq] = _(t[p].l + 1, t[q].f);\n            std::copy(t[q].ne, t[q].ne + 26, t[nq].ne);\n            while (p &amp;&amp; t[p].ne[c] == q)\n                t[p].ne[c] = nq, p = t[p].f;\n            t[q].f = nq;\n            t[np].f = nq;\n        &#125;\n    &#125;\n    return;\n&#125;\nint now = 0;\nvoid ins(int &amp;p, int l, int r, int v) &#123;\n    if (!p)\n        p = ++now;\n    ++t1[p].u;\n    if (l == r)\n        return;\n    int mid = (l + r) &gt;&gt; 1;\n    if (v &lt;= mid)\n        ins(t1[p].l, l, mid, v);\n    else\n        ins(t1[p].r, mid + 1, r, v);\n    return;\n&#125;\nint ask(int p, int l, int r, int ql, int qr) &#123;\n    if (ql &lt;= l &amp;&amp; r &lt;= qr)\n        return t1[p].u;\n    int mid = (l + r) &gt;&gt; 1, res = 0;\n    if (ql &lt;= mid)\n        res = ask(t1[p].l, l, mid, ql, qr);\n    if (qr &gt; mid)\n        res += ask(t1[p].r, mid + 1, r, ql, qr);\n    return res;\n&#125;\nint merge(int p, int q, int l, int r) &#123;\n    if (!p || !q)\n        return p + q;\n    int np = ++now, mid = (l + r) &gt;&gt; 1;\n    t1[np].u = t1[p].u + t1[q].u;\n    if (l == r) return np;\n    t1[np].l = merge(t1[p].l, t1[q].l, l, mid);\n    t1[np].r = merge(t1[p].r, t1[q].r, mid + 1, r);\n    return np;\n&#125;\nint pos[maxn], rt[maxn &lt;&lt; 1];\nbool check(int x, int a, int b, int c, int d) &#123;\n    assert(c + x - 1 &gt;= 0);\n    int p = pos[c + x - 1];\n    for (int i = siz; ~i; --i)\n        if (fa[p][i] &amp;&amp; t[fa[p][i]].l &gt;= x)\n            p = fa[p][i];\n    return ask(rt[p], 0, n - 1, a + x - 1, b) &gt; 0;\n&#125;\nint solve(int a, int b, int c, int d) &#123;\n    int l = 1, r = std::min(d - c + 1, b - a + 1), res = 0;\n    while (l &lt;= r) &#123;\n        int mid = (l + r) &gt;&gt; 1;\n        if (check(mid, a, b, c, d))\n            l = mid + 1, res = mid;\n        else\n            r = mid - 1;\n    &#125;\n    return res;\n&#125;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    std::cout.tie(nullptr);\n#endif\n    int m;\n    std::string s;\n    std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; s;\n    Init();\n    for (int i = 0; i &lt; n; ++i) &#123;\n        ext(s[i] - &#39;a&#39;);\n        pos[i] = la;\n        ins(rt[la], 0, n - 1, i);\n    &#125;\n    siz = log(tot) / log(2.0);\n    for (int i = 1; i &lt;= tot; ++i)\n        ++cnt[t[i].l];\n    std::partial_sum(cnt + 1, cnt + tot + 1, cnt + 1);\n    for (int i = 1; i &lt;= tot; ++i)\n        tab[cnt[t[i].l]--] = i;\n    for (int i = 1; i &lt;= tot; ++i) &#123;\n        int u = tab[i];\n        fa[u][0] = t[u].f;\n        for (int j = 1; j &lt;= siz; ++j)\n            fa[u][j] = fa[fa[u][j - 1]][j - 1];\n    &#125;\n    for (int i = tot; i; --i) &#123;\n        int u = tab[i];\n        if (t[u].f)\n            rt[t[u].f] = merge(rt[t[u].f], rt[u], 0, n - 1);\n    &#125;\n    while (m--) &#123;\n        int a, b, c, d;\n        std::cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;\n        std::cout &lt;&lt; solve(a - 1, b - 1, c - 1, d - 1) &lt;&lt; &#39;\\n&#39;;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"f.-security\">F. Security</h3>\n<p><a href=\"http://222.180.160.110:61235/contest/5169/problem/6\" class=\"uri\">http://222.180.160.110:61235/contest/5169/problem/6</a></p>\n<p>对我们来说应该是会 D 就会 F 的。所以只打了 10min。</p>\n<p>首先考虑一个大家喜闻乐见的 DFS 求最小字典序。显然地，如果存在和当前位相等的字符，那么优先跳相等字符，进入下一层深搜；否则找到最小的更大字符，然后直接 out。</p>\n<p>此时 SAM 就是我们用来判断 <span class=\"math inline\">\\(S_{l, r}\\)</span> 中是否存在某状态的工具了。甚至比上一题简单，因为不用写二分和倍增。</p>\n<p>值得注意的是如果 <span class=\"math inline\">\\(S_{l, r}\\)</span> 包含 <span class=\"math inline\">\\(T\\)</span> 那么还要在后面随便加一个字符以字典序保证严格大于 <span class=\"math inline\">\\(T\\)</span>。</p>\n<details>\n<p>值得注意的是因为我写的太丑了以至于在 CF 上会光荣 MLE #46。然后分屏左半边看我代码右半边写的 zwb 却没有。啧。为什么呢。</p>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxm = 35;\nconst int maxn = 6e5 + 5;\nconst int maxk = 8e7 + 5;\nstruct _ &#123;\n    int l, f;\n    int ne[maxm]; \n    _() &#123;&#125;\n    _(int l1, int f1): l(l1), f(f1) &#123;&#125;\n&#125;;\n_ t[maxn &lt;&lt; 1];\nint vis[maxn &lt;&lt; 1];\nint fa[maxn][maxm];\nint n, la, tot, siz;\nstruct &#123; int l, r, u; &#125; t1[maxk];\nint tab[maxn &lt;&lt; 1], cnt[maxn &lt;&lt; 1];\nvoid Init(void) &#123;\n    la = tot = 1;\n    t[1] = _(0, 0);\n    return;\n&#125;\nvoid ext(int c) &#123;\n    int p = la, np = ++tot;\n    la = tot;\n    t[np] = _(t[p].l + 1, 0);\n    while (p &amp;&amp; !t[p].ne[c])\n        t[p].ne[c] = np, p = t[p].f;\n    if (!p)\n        t[np].f = 1;\n    else &#123;\n        int q = t[p].ne[c];\n        if (t[q].l == t[p].l + 1)\n            t[np].f = q;\n        else &#123;\n            int nq = ++tot;\n            t[nq] = _(t[p].l + 1, t[q].f);\n            std::copy(t[q].ne, t[q].ne + 26, t[nq].ne);\n            while (p &amp;&amp; t[p].ne[c] == q)\n                t[p].ne[c] = nq, p = t[p].f;\n            t[q].f = nq;\n            t[np].f = nq;\n        &#125;\n    &#125;\n    return;\n&#125;\nint now = 0;\nvoid ins(int &amp;p, int l, int r, int v) &#123;\n    if (!p)\n        p = ++now;\n    ++t1[p].u;\n    if (l == r)\n        return;\n    int mid = (l + r) &gt;&gt; 1;\n    if (v &lt;= mid)\n        ins(t1[p].l, l, mid, v);\n    else\n        ins(t1[p].r, mid + 1, r, v);\n    return;\n&#125;\nint ask(int p, int l, int r, int ql, int qr) &#123;\n    if (ql &lt;= l &amp;&amp; r &lt;= qr)\n        return t1[p].u;\n    int mid = (l + r) &gt;&gt; 1, res = 0;\n    if (ql &lt;= mid)\n        res = ask(t1[p].l, l, mid, ql, qr);\n    if (qr &gt; mid)\n        res += ask(t1[p].r, mid + 1, r, ql, qr);\n    return res;\n&#125;\nint merge(int p, int q, int l, int r) &#123;\n    if (!p || !q)\n        return p + q;\n    int np = ++now, mid = (l + r) &gt;&gt; 1;\n    t1[np].u = t1[p].u + t1[q].u;\n    if (l == r) return np;\n    t1[np].l = merge(t1[p].l, t1[q].l, l, mid);\n    t1[np].r = merge(t1[p].r, t1[q].r, mid + 1, r);\n    return np;\n&#125;\nint pos[maxn], rt[maxn &lt;&lt; 1];\nbool check(int p, int ch, int l, int r) &#123;\n    return ask(rt[t[p].ne[ch]], 0, n - 1, l, r) &gt; 0;\n&#125;\nbool fun(std::string &amp;res, std::string now, std::string &amp;t, int x, int p, int l, int r) &#123;\n    // std::cout &lt;&lt; &quot;x = &quot; &lt;&lt; x &lt;&lt; &quot;, now = \\&quot;&quot; &lt;&lt; now &lt;&lt; &quot;\\&quot;;\\n&quot;;\n    if (x != (int)t.length() &amp;&amp; check(p, t[x] - &#39;a&#39;, l + x, r) &amp;&amp; fun(res, now + t[x], t, x + 1, ::t[p].ne[t[x] - &#39;a&#39;], l, r))\n        return 1;\n    for (int i = (x == (int)t.length()) ? 0 : t[x] - &#39;a&#39; + 1; i &lt; 26; ++i) &#123;\n        if (check(p, i, l + x, r)) &#123;\n            now += i + &#39;a&#39;;\n            res = now;\n            return 1;\n        &#125;\n    &#125;\n    return 0;\n&#125;\nstd::string solve(std::string &amp;t, int l, int r) &#123;\n    std::string res;\n    return fun(res, &quot;&quot;, t, 0, 1, l, r) ? res : &quot;-1&quot;;\n&#125;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    std::cout.tie(nullptr);\n#endif\n    int q;\n    std::string s;\n    std::cin &gt;&gt; s &gt;&gt; q;\n    n = (int)s.length();\n    Init();\n    for (int i = 0; i &lt; n; ++i) &#123;\n        ext(s[i] - &#39;a&#39;);\n        pos[i] = la;\n        ins(rt[la], 0, n - 1, i);\n    &#125;\n    siz = log(tot) / log(2.0);\n    for (int i = 1; i &lt;= tot; ++i)\n        ++cnt[t[i].l];\n    std::partial_sum(cnt + 1, cnt + tot + 1, cnt + 1);\n    for (int i = 1; i &lt;= tot; ++i)\n        tab[cnt[t[i].l]--] = i;\n    for (int i = 1; i &lt;= tot; ++i) &#123;\n        int u = tab[i];\n        fa[u][0] = t[u].f;\n        for (int j = 1; j &lt;= siz; ++j)\n            fa[u][j] = fa[fa[u][j - 1]][j - 1];\n    &#125;\n    for (int i = tot; i; --i) &#123;\n        int u = tab[i];\n        if (t[u].f)\n            rt[t[u].f] = merge(rt[t[u].f], rt[u], 0, n - 1);\n    &#125;\n    while (q--) &#123;\n        int l, r;\n        std::string t;\n        std::cin &gt;&gt; l &gt;&gt; r &gt;&gt; t;\n        std::cout &lt;&lt; solve(t, l - 1, r - 1) &lt;&lt; &#39;\\n&#39;;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"a.-六出祁山\">A. 六出祁山</h3>\n<p><a href=\"http://222.180.160.110:61235/contest/5170/problem/1\" class=\"uri\">http://222.180.160.110:61235/contest/5170/problem/1</a></p>\n<p>是能用贪心拿 60pts 的 DP 题 /tuu</p>\n<p>需要先把暴力的式子写出来。设 <span class=\"math inline\">\\(f_{i, j}\\)</span> 为将 <span class=\"math inline\">\\(i\\)</span> 山修改高度为 <span class=\"math inline\">\\(j\\)</span> 的代价，则：</p>\n<p><span class=\"math display\">\\[\nf_{i, j} = \\min\\limits_{k\\in [j-d, j+d]}\\left\\{f_{i-1, k}\\right\\} + |h_i - j|\n\\]</span></p>\n<p>注意到可以单调队列优化。但是这样做复杂度还是 <span class=\"math inline\">\\(O(nV)\\)</span> 的，根本原因在于第二维这个 <span class=\"math inline\">\\(V\\)</span> 的状态数太多了。</p>\n<p>根据直觉，最后 <span class=\"math inline\">\\(j\\)</span> 的值应为 <span class=\"math inline\">\\(k+d\\)</span> 或 <span class=\"math inline\">\\(k-d\\)</span> 或 <span class=\"math inline\">\\(a_i\\)</span>。也就是说，我们可以认为，合法的状态数为所有的 <span class=\"math inline\">\\(a_i+x\\times d, x\\in[-n, n]\\)</span>。</p>\n<details>\n<p><summary>正确性证明……</summary></p>\n<p>考虑全部更改完后的结束状态，即最后的最优状态。</p>\n<p>考虑所有山中最矮的山 <span class=\"math inline\">\\(i\\)</span>，此山的高度要么为 <span class=\"math inline\">\\(h_i\\)</span>，要么为前一座山的高度 <span class=\"math inline\">\\(-d\\)</span>，要么为后一座山的高度 <span class=\"math inline\">\\(-d\\)</span>。</p>\n<p>考虑第二矮的山，以此类推即可。</p>\n</details>\n<p>将第二维的状态集大小减少为 <span class=\"math inline\">\\(O(n^2)\\)</span>，总时间复杂度为 <span class=\"math inline\">\\(O(n^3)\\)</span>。</p>\n<details>\n<p>需注意到因为 <span class=\"math inline\">\\(a_i+x\\times d\\)</span> 中的 <span class=\"math inline\">\\(x\\)</span> 范围为 <span class=\"math inline\">\\([-n, n]\\)</span> 共 <span class=\"math inline\">\\(2\\times n\\)</span>，所以 DP 数组第二维大小一定要开 <span class=\"math inline\">\\(2\\times n^2\\)</span> 呀！！！</p>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nusing ll = long long;\nconst int maxn = 305;\nconst int maxm = 18e4 + 5;\nconst ll inf = 0x3f3f3f3f3f3f3f3f;\nll d;\nint n;\nll h[maxn];\nll f[maxn][maxm];\nint main() &#123;\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    std::cout.tie(nullptr);\n    memset(f, 0x3f, sizeof (f));\n    std::cin &gt;&gt; n &gt;&gt; d;\n    std::vector&lt;ll&gt; st;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; h[i];\n        for (ll j = -n; j &lt;= n; ++j)\n            st.push_back(h[i] + j * d);\n    &#125;\n    std::sort(st.begin(), st.end());\n    st.erase(std::unique(st.begin(), st.end()), st.end());\n    auto abs = [&amp;](ll x) -&gt; ll &#123; return x &gt;= 0 ? x : -x; &#125;;\n    f[1][lower_bound(st.begin(), st.end(), h[1]) - st.begin()] = 0;\n    for (int i = 2; i &lt;= n; ++i) &#123;\n        int h(1), t(0), p(-1);\n        static int q[maxm];\n        for (int j = 0; j &lt; (int)st.size(); ++j) &#123;\n            while (p &lt; (int)st.size() &amp;&amp; st[p + 1] &lt;= st[j] + d) &#123;\n                ++p;\n                while (h &lt;= t &amp;&amp; f[i - 1][p] &lt;= f[i - 1][q[t]])\n                    --t;\n                q[++t] = p;\n            &#125;\n            while (h &lt;= t &amp;&amp; st[q[h]] &lt; st[j] - d)\n                ++h;\n            if (h &lt;= t)\n                f[i][j] = std::min(inf, f[i - 1][q[h]] + abs(st[j] - ::h[i]));\n        &#125;\n    &#125;\n    ll res = f[n][std::lower_bound(st.begin(), st.end(), h[n]) - st.begin()];\n    std::cout &lt;&lt; (res == inf ? -1 : res) &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"b.-水淹七军\">B. 水淹七军</h3>\n<p><a href=\"http://222.180.160.110:61235/contest/5170/problem/2\" class=\"uri\">http://222.180.160.110:61235/contest/5170/problem/2</a></p>\n<p>容易发现最后连出来一定是没有环的。所以一定是一个 DAG。</p>\n<p>我们知道状态压缩是会遍历到每一种情况的，所以我们可以假设当前的 DAG 就是该状态下的最优。</p>\n<p>至于这个「最优」如何定义就要交给我们了。我们不妨强制认为这个 DAG 是按层序遍历得到的，也就是说连续遍历到的点属于同一层（这里的层是指某点到任意源点的最长路长度）。</p>\n<p>显然只有一组相互之间没有任何连边的点才能组成同一层。不妨枚举点集然后暴力转移，转移时记录路径即可。</p>\n<details>\n<p>注意到在写这玩意儿的时候我还不会 <a href=\"/2024/05/17/20240517/\">状压枚举子集</a>，所以枚举子集的部分可能打得比较抽象。</p>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 25;\nconst int inf = 0x3f3f3f3f;\nconst int maxm = (1 &lt;&lt; 16) + 5;\nint n, res;\nint tag[maxn][maxn];\nint f[maxn], g[maxn];\nint solve(std::vector&lt;int&gt;&amp; a) &#123;\n    static int g[maxn];\n    static int f[maxm], p[maxm];\n    int n(a.size()), siz(1 &lt;&lt; n);\n    std::fill(g, g + n, 0);\n    std::fill(p, p + siz + 1, 0);\n    std::fill(f, f + siz + 1, inf);\n    std::vector&lt;int&gt; st;\n    for (int i = 0; i &lt; n; ++i) &#123;\n        for (int j = 0; j &lt; n; ++j) &#123;\n            if (::g[a[i]] &amp; (1 &lt;&lt; a[j]))\n                g[i] |= 1 &lt;&lt; j;\n        &#125;\n    &#125;\n    for (int i = 1; i &lt; siz; ++i) &#123;\n        int now = 0;\n        for (int j = 0; j &lt; n; ++j) &#123;\n            if (i &amp; (1 &lt;&lt; j))\n                now |= g[j];\n        &#125;\n        if (!(now &amp; i))\n            st.push_back(i), f[i] = 0, p[i] = i;\n        for (auto j : st) &#123;\n            if (!(i &amp; j)) &#123;\n                if (f[i | j] &gt; f[i] + 1)\n                    f[i | j] = f[i] + 1, p[i | j] = j;\n            &#125;\n        &#125;\n    &#125;\n    int now = siz - 1;\n    while (now) &#123;\n        int fa = now ^ p[now];\n        for (int i = 0; i &lt; n; ++i)\n            if (p[now] &amp; (1 &lt;&lt; i))\n                for (int j = 0; j &lt; n; ++j)\n                    if ((fa &amp; (1 &lt;&lt; j)) &amp;&amp; tag[a[j]][a[i]] == 2)\n                        tag[a[j]][a[i]] = 1, tag[a[i]][a[j]] = -1;\n        now = fa;\n    &#125;\n    return f[siz - 1];\n&#125;\nint find(int x) &#123;\n    return x == f[x] ? x : f[x] = find(f[x]);\n&#125;\nint main() &#123;\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    std::cout.tie(nullptr);\n    int m;\n    std::cin &gt;&gt; n &gt;&gt; m;\n    std::vector&lt;std::pair&lt;int, int&gt; &gt; edge;\n    for (int i = 0; i &lt; n; ++i)\n        f[i] = i;\n    while (m--) &#123;\n        int x, y;\n        std::cin &gt;&gt; x &gt;&gt; y;\n        edge.emplace_back(--x, --y);\n        f[find(x)] = find(y);\n        g[x] |= 1 &lt;&lt; y;\n        g[y] |= 1 &lt;&lt; x;\n        tag[x][y] = tag[y][x] = 2;\n    &#125;\n    std::vector&lt;int&gt; ver[maxn];\n    for (int i = 0; i &lt; n; ++i) &#123;\n        ver[find(i)].push_back(i);\n    &#125;\n    for (int i = 0; i &lt; n; ++i) &#123;\n        if (f[i] == i)\n            res = std::max(res, solve(ver[i]));\n    &#125;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    for (auto i : edge) &#123;\n        if (tag[i.first][i.second] == 1)\n            std::cout &lt;&lt; i.first + 1 &lt;&lt; &#39; &#39; &lt;&lt; i.second + 1 &lt;&lt; &#39;\\n&#39;;\n        else std::cout &lt;&lt; i.second + 1 &lt;&lt; &#39; &#39; &lt;&lt; i.first + 1 &lt;&lt; &#39;\\n&#39;;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"c.-煮酒论英雄\">C. 煮酒论英雄</h3>\n<p><a href=\"http://222.180.160.110:61235/contest/5170/problem/3\" class=\"uri\">http://222.180.160.110:61235/contest/5170/problem/3</a></p>\n<p>注意到如果存在串被其他串包含那么直接将其毙掉就可以了。</p>\n<p>对于相互不完全包含的串，我们令 <span class=\"math inline\">\\(mx_{i, j, 0/1, 0/1}\\)</span> 表示将正序 / 逆序的 <span class=\"math inline\">\\(i\\)</span> 串拼到正序 / 逆序的 <span class=\"math inline\">\\(j\\)</span> 串之前，两者共用相接公共部分的串长。这个可以用字符串哈希暴力求。</p>\n<p>用状压枚举拼接顺序，求得最小总串长即可。</p>\n<p>注意如果去掉被包含串后 <span class=\"math inline\">\\(n=1\\)</span> 时需直接输出串的 border；以及答案需和 <span class=\"math inline\">\\(2\\)</span> 取 <span class=\"math inline\">\\(\\max\\)</span>。</p>\n<p>实现起来又臭又长，但实际上思路确实非常简单。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nusing ll = long long;\nconst int p = 131;\nconst int maxn = 25;\nconst int lim = 2e4;\nconst int maxl = 2e4 + 5;\nconst int mod = 998244353;\nconst int inf = 0x3f3f3f3f;\nconst int maxm = (1 &lt;&lt; 16) + 5;\nint n;\nstd::vector&lt;std::string&gt; s;\nstd::vector&lt;std::vector&lt;ll&gt; &gt; h[2];\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    std::cout.tie(nullptr);\n#endif\n    std::cin &gt;&gt; n;\n    s.resize(n);\n    h[0].resize(n);\n    h[1].resize(n);\n    static ll base[maxl];\n    static bool del[maxn];\n    base[0] = 1;\n    for (int i = 1; i &lt;= lim; ++i)\n        base[i] = base[i - 1] * p % mod;\n\n    for (int i = 0; i &lt; n; ++i) &#123;\n        std::cin &gt;&gt; s[i];\n        h[0][i].resize((int)s[i].length());\n        h[1][i].resize((int)s[i].length());\n        ll x = 0;\n        for (int j = 0; j &lt; (int)s[i].length(); ++j, (x *= p) %= mod)\n            h[0][i][j] = ((x += s[i][j]) %= mod);\n        std::reverse(s[i].begin(), s[i].end());\n        x = 0;\n        for (int j = 0; j &lt; (int)s[i].length(); ++j, (x *= p) %= mod)\n            h[1][i][j] = ((x += s[i][j]) %= mod);\n        std::reverse(s[i].begin(), s[i].end());\n    &#125;\n\n    std::vector&lt;int&gt; tab;\n    auto gethash = [&amp;](int i, int l, int r, bool t) -&gt; ll &#123;\n        if (l &gt; r) return 0;\n        ll res = (h[t][i][r] - (l ? h[t][i][l - 1] : 0) * base[r - l + 1] % mod);\n        return (res % mod + mod) % mod;\n    &#125;;\n    // ll now = 0;\n    // for (int i = 0; i &lt;= 4; ++i)\n    //     now = (now * p + s[1][i]) % mod;\n    // printf(&quot;now = %lld\\n&quot;, now);\n    // now = 0;\n    // for (int i = 3; i &lt;= 7; ++i)\n    //     now = (now * p + s[0][i]) % mod;\n    // printf(&quot;now = %lld\\n&quot;, now);\n    // printf(&quot;# %lld\\n&quot;, h[0][0].back());\n    for (int i = 0; i &lt; n; ++i) &#123;\n        tab.push_back(i);\n        for (int j = 0; j &lt; n; ++j)\n            if (!del[j] &amp;&amp; i != j)\n                for (int k = 0; k &lt;= ((int)s[j].length()) - ((int)s[i].length()); ++k) &#123;\n                    // printf(&quot;i = %d, j = %d, k = %d, %lld / %lld\\n&quot;, i, j, k,\n                    //         gethash(i, 0, ((int)s[i].length()) - 1, 0), gethash(j, k, k + ((int)s[i].length()) - 1, 0));\n                    if (h[0][i].back() == gethash(j, k, k + ((int)s[i].length()) - 1, 0)) &#123;\n                        tab.pop_back();\n                        del[i] = 1;\n                        goto outo;\n                    &#125;\n                &#125;\n        outo: ;\n    &#125;\n    n = (int)tab.size();\n    if (n == 1) &#123;\n        int border;\n        for (border = ((int)s[tab[0]].length()) - 1; ~border; --border) &#123;\n            if (gethash(tab[0], 0, border - 1, 0) == gethash(tab[0], ((int)s[tab[0]].length()) - border, ((int)s[tab[0]].length()) - 1, 0))\n                break;\n        &#125;\n        std::cout &lt;&lt; std::max(2, ((int)s[tab[0]].length()) - border) &lt;&lt; &#39;\\n&#39;;\n    &#125;\n    else &#123;\n        static int mx[maxn][maxn][2][2];\n        for (int i = 0; i &lt; n; ++i)\n            for (int j = 0; j &lt; n; ++j)\n                for (int a = 0; a &lt; 2; ++a)\n                    for (int b = 0; b &lt; 2; ++b)\n                        for (int k = std::min((int)s[tab[i]].length(), (int)s[tab[j]].length()); ~k; --k) &#123;\n                            if (gethash(tab[i], ((int)s[tab[i]].length()) - k, ((int)s[tab[i]].length()) - 1, a) ==\n                                                                                            gethash(tab[j], 0, k - 1, b)) &#123;\n                                mx[i][j][a][b] = (int)s[tab[j]].length() - k;\n                                // printf(&quot;%d(%d) + %d(%d) = %d, k = %d\\n&quot;, i, a, j, b, mx[i][j][a][b], k);\n                                break;\n                            &#125;\n                        &#125;\n        static int f[maxm][maxn][2];\n        memset(f, 0x3f, sizeof (f));\n\n        int siz = 1 &lt;&lt; n, res = inf;\n        f[1][0][0] = (int)s[tab[0]].length();\n        for (int i = 1; i &lt; siz; ++i)\n            for (int j = 0; j &lt; n; ++j)\n                if (i &amp; (1 &lt;&lt; j))\n                    for (int a = 0; a &lt; 2; ++a) &#123;\n                        // printf(&quot;f[%d][%d][%d] = %d\\n&quot;, i, j, a, f[i][j][a]);\n                        for (int k = 0; k &lt; n; ++k)\n                            if (!(i &amp; (1 &lt;&lt; k)))\n                                for (int b = 0; b &lt; 2; ++b)\n                                    f[i | (1 &lt;&lt; k)][k][b] = std::min(f[i | (1 &lt;&lt; k)][k][b], f[i][j][a] + mx[j][k][a][b]);\n                        if (i == siz - 1)\n                            res = std::min(res, f[i][j][a] - (int)s[tab[0]].length() + mx[j][0][a][0]);\n                    &#125;\n        \n        std::cout &lt;&lt; std::max(2, res) &lt;&lt; &#39;\\n&#39;;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"a.-捏斑马\">A. 捏斑马</h3>\n<p><a href=\"http://222.180.160.110:61235/contest/5175/problem/1\" class=\"uri\">http://222.180.160.110:61235/contest/5175/problem/1</a></p>\n<p>我甚至不会（）</p>\n<p>翻转 + 拼接本质上就是首尾相接。我们把字符串整个拼到自己后边儿，然后任取一段长度为 <span class=\"math inline\">\\(n\\)</span> 的串就可以得到一个倒过来的操作后的字符串。</p>\n<p>注意到可以操作很多次。但是既然我们操作后的串也可以在这个拼接后的串中找到了，那么其实多次操作后的也行。</p>\n<p>所以呢我们在拼接后的串种枚举每一个长度为 <span class=\"math inline\">\\(n\\)</span> 的串计算答案即可。</p>\n<p>具体怎么算呢？注意到只看开头，也就是在新串中只看离我们当前枚举的右端点最近的那一段，所以我们打一个双指针，看这一段是否在右移后仍然合法，如果非法就把答案区间左端点更新为右端点自己。以及注意到左右端点的距离不能超过 <span class=\"math inline\">\\(n\\)</span>。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint res;\nstd::string s;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    std::cout.tie(nullptr);\n#endif\n    std::cin &gt;&gt; s;\n    int l = 0, r = -1, n = (int)s.length();\n    char la = 0;\n    s += s;\n    while (++r &lt; (int)s.length()) &#123;\n        if (s[r] == la)\n            l = r;\n        while (r - l + 1 &gt; n) ++l;\n        la = s[r];\n        res = std::max(res, r - l + 1);\n    &#125;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"d.-链状闪电\">D. 链状闪电</h3>\n<p><a href=\"http://222.180.160.110:61235/contest/5175/problem/4\" class=\"uri\">http://222.180.160.110:61235/contest/5175/problem/4</a></p>\n<p>莫名其妙且又臭又长的根号做法。</p>\n<p>容易发现一个怪被杀掉了序列就会裂开成两段连续子序列，以及最先被杀掉的怪物一定血量最少。在裂开来的两段连续子序列中也满足此规律，以此类推。</p>\n<p>考虑对序列建立笛卡尔树。令树根为 <span class=\"math inline\">\\(rt\\)</span>，当前攻击力为 <span class=\"math inline\">\\(k\\)</span>，记 <span class=\"math inline\">\\(t_{x, k}=\\left\\lceil \\dfrac {h_x}k \\right\\rceil\\)</span>，即不考虑其他条件时击倒 <span class=\"math inline\">\\(x\\)</span> 所需次数。</p>\n<p>那么对于 <span class=\"math inline\">\\(rt\\)</span> 的左、右儿子 <span class=\"math inline\">\\(l,r\\)</span>，单考虑这三个怪物所需的总击倒次数，容易发现为 <span class=\"math inline\">\\(t_{rt,k}+(t_{l,k}-t_{rt,k})+(t_{r,k}-t_{rt,k})\\)</span>。</p>\n<p>对于 <span class=\"math inline\">\\(l\\)</span> 引导的子树，此时的实际已攻击次数为 <span class=\"math inline\">\\(t_{l,k}\\)</span>；所以对于 <span class=\"math inline\">\\(l\\)</span> 的左右儿子 <span class=\"math inline\">\\(l&#39;,r&#39;\\)</span>，击倒这两个怪物的所需次数为 <span class=\"math inline\">\\((t_{l&#39;,k} - t_{l,k})+(t_{r&#39;,k}-t_{l,k})\\)</span>。<span class=\"math inline\">\\(r\\)</span> 引导的子树同理。</p>\n<p>所以我们就可以知道，如果存在树边 <span class=\"math inline\">\\(u\\to v\\)</span>，那么击倒 <span class=\"math inline\">\\(v\\)</span> 的所需次数为 <span class=\"math inline\">\\(t_{v,k}-t_{u,k}\\)</span>；特别地，击倒 <span class=\"math inline\">\\(rt\\)</span> 的所需次数为 <span class=\"math inline\">\\(t_{rt,k}\\)</span>。</p>\n<p>那么我们就可以通过一次 <span class=\"math inline\">\\(O(n)\\)</span> 的树上 DFS 对于一个 <span class=\"math inline\">\\(k\\)</span> 找到答案了。</p>\n<p>那么对于 <span class=\"math inline\">\\(2\\times 10^4\\)</span> 范围内的所有 <span class=\"math inline\">\\(k\\)</span>，应该怎么办呢？这个时候就要利用 <span class=\"math inline\">\\(t\\)</span> 的性质进行根号分治了。</p>\n<ul>\n<li><p>对于 <span class=\"math inline\">\\(k\\le \\sqrt {2\\times 10^4}\\)</span>，我们大可以直接做这么多次 DFS 得到答案；</p></li>\n<li><p>对于 <span class=\"math inline\">\\(k&gt;\\sqrt {2\\times 10^4}\\)</span>：</p>\n<p>我们容易发现最终的结果是若干个 <span class=\"math inline\">\\(t\\)</span> 的值相加减得到的，而每个 <span class=\"math inline\">\\(t\\)</span> 的权值 <span class=\"math inline\">\\(cnt\\)</span> 取决于其在笛卡尔树上的儿子个数，有多少就在 <span class=\"math inline\">\\(1\\)</span> 的基础上减去多少。</p>\n<p>由于 <span class=\"math inline\">\\(t\\)</span> 实在过于特殊，考虑整除分块 / 数论分块。对于每个 <span class=\"math inline\">\\(x\\)</span>，对于任意 <span class=\"math inline\">\\(k&#39;\\in (\\sqrt {2\\times 10^4}, 2\\times 10^4]\\)</span>，可能的 <span class=\"math inline\">\\(t\\)</span> 值只有 <span class=\"math inline\">\\(\\sqrt {2\\times 10^4 }\\)</span> 种。计算出对于每个 <span class=\"math inline\">\\(t&#39;\\)</span>，满足 <span class=\"math inline\">\\(\\left\\lceil \\dfrac {h_x}{k&#39;} \\right\\rceil=t&#39;\\)</span> 的 <span class=\"math inline\">\\(k&#39;\\)</span> 范围，对该范围 <span class=\"math inline\">\\(k&#39;\\)</span> 的答案区间加上 <span class=\"math inline\">\\(t&#39;\\times cnt\\)</span> 即可，可以使用差分。</p>\n<p>至此，就可以在一次 DFS 内解决这种情况下的问题。</p></li>\n</ul>\n<p>总时间复杂度为 <span class=\"math inline\">\\(O(n\\sqrt {2\\times 10^4})\\)</span>。</p>\n<details>\n<p>值得注意的是，我在做这道题的时候并没有意识到自己用到了笛卡尔树，</p>\n<p>所以代码中笛卡尔树的建树部分可能长得特别抽象（</p>\n<p>这里是使用了下标上的 ST 表带 log 地求解了左右儿子。</p>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxm = 35;\nconst int maxn = 1e5 + 5;\nusing ll = long long;\nll res;\nint n, k, l;\nint g[maxn][2];\nint f[maxn][maxm];\nint a[maxn], t[maxn];\nll dif[maxn], cnt[maxn];\nint ask(int l, int r) &#123;\n    if (l &gt; r) return 0;\n    int k = log(r - l + 1) / log(2.0);\n    return (a[f[l][k]] &lt; a[f[r - (1 &lt;&lt; k) + 1][k]]) ? f[l][k] : f[r - (1 &lt;&lt; k) + 1][k];\n&#125;\nvoid bld(int rt, int l, int r) &#123;\n    if (rt != l) &#123;\n        g[rt][0] = ask(l, rt - 1);\n        bld(g[rt][0], l, rt - 1);\n    &#125;\n    if (rt != r) &#123;\n        g[rt][1] = ask(rt + 1, r);\n        bld(g[rt][1], rt + 1, r);\n    &#125;\n    return;\n&#125;\n// k &lt;= sqrt(lim)\nvoid DFS(int x, int k, int fa) &#123;\n    t[x] = (a[x] + k - 1) / k;\n    res += t[x] - t[fa];\n    for (int i = 0; i &lt; 2; ++i) &#123;\n        if (g[x][i])\n            DFS(g[x][i], k, x);\n    &#125;\n    return;\n&#125;\n// k &gt; sqrt(lim)\nvoid DFS(int x, int fa) &#123;\n    ++cnt[x];\n    --cnt[fa];\n    for (int i = 0; i &lt; 2; ++i) &#123;\n        if (g[x][i])\n            DFS(g[x][i], x);\n    &#125;\n    int l = k + 1, r;\n    // 注意这里 i 的范围判定，如果直接写成 i * i &lt;= k 会少计算一些情况\n    for (int i = 1; (i - 1) * (i - 1) &lt; k; ++i) &#123;\n        r = l - 1;\n        l = (a[x] + i - 1) / i;\n        // fprintf(stderr, &quot;%d: [%d, %d] += %d * %d\\n&quot;, a[x], l, r, cnt[x], i);\n        dif[l] += i * cnt[x], dif[r + 1] -= i * cnt[x];\n    &#125;\n    return;\n&#125;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    std::cout.tie(nullptr);\n#endif\n    std::cin &gt;&gt; n;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; a[i];\n        f[i][0] = i;\n        k = std::max(k, a[i]);\n    &#125;\n    for (int j = 1; (1 &lt;&lt; j) &lt;= n; ++j)\n        for (int i = 1; i + (1 &lt;&lt; j) - 1 &lt;= n; ++i)\n            f[i][j] = (a[f[i][j - 1]] &lt; a[f[i + (1 &lt;&lt; (j - 1))][j - 1]]) ? f[i][j - 1] : f[i + (1 &lt;&lt; (j - 1))][j - 1];\n    int rt = ask(1, n);\n    bld(rt, 1, n);\n    for (int i = 1; i * i &lt;= k; ++i) &#123;\n        res = 0;\n        DFS(rt, i, 0);\n        std::cout &lt;&lt; res &lt;&lt; &#39; &#39;;\n        l = i + 1;\n    &#125;\n    // fputs(&quot;\\n&quot;, stderr);\n    DFS(rt, 0);\n    std::partial_sum(dif + 1, dif + k + 1, dif + 1);\n    for (int i = l; i &lt;= k; ++i)\n        std::cout &lt;&lt; dif[i] &lt;&lt; &#39; &#39;;\n    std::cout &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"f.-弹飞绵羊\">F. 弹飞绵羊</h3>\n<p><a href=\"http://222.180.160.110:61235/contest/5175/problem/6\" class=\"uri\">http://222.180.160.110:61235/contest/5175/problem/6</a></p>\n<p>很棒可持久化分块，使我 lxl 旋转。</p>\n<p>笑话：赛后 5s 才交上去。然后 A 了。</p>\n<p>我们猜大家都会普通的弹飞绵羊这道题。就是块间暴力跳嘛。</p>\n<p>这里给一个我自己整的简单实现方法。</p>\n<p>我们把分出来的块视作若干个无关联的散块并纳入块集合；对于每一个版本，用一个大小为 <span class=\"math inline\">\\(\\sqrt n\\)</span> 的 <span class=\"math inline\">\\(id\\)</span> 数组记录每一位置的块在块集合中对应的位置。</p>\n<p>然后该怎么搞怎么搞即可。</p>\n<p>P.S. zwb 坚定不移信仰 lxl 神教于是决定用可持久化平衡树实现可持久化分块，结果当然是因为多了个 <span class=\"math inline\">\\(\\log\\)</span> 被卡飞了，最后气急败坏慌不择路恼羞成怒抄起了我的代码。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxk = 320;\nconst int maxn = 2e5 + 5;\nclass devicer &#123;\npublic:\n    int l, r;\n    std::vector&lt;int&gt; ne, u, a;\n    int &amp;nex(int x);\n    int &amp;val(int x);\n&#125;;\nint id[maxn][maxk];\nstd::vector&lt;devicer&gt; b;\nint n, q, ty, siz, k, la;\nint a[maxn], tab[maxn], blk[maxn];\nvoid upd(int x, int a, devicer &amp;p) &#123;\n    if (x + a &gt; n)\n        p.nex(x) = -1, p.val(x) = 1;\n    else if (x + a &gt; p.r)\n        p.nex(x) = x + a, p.val(x) = 1;\n    else\n        p.nex(x) = p.nex(x + a), p.val(x) = p.val(x + a) + 1;\n    // printf(&quot;x = %d, a = %d, r = %d, upd ne[%d] to %d\\n&quot;, x, a, p.r, x, p.nex(x));\n    return;\n&#125;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    std::cout.tie(nullptr);\n#endif\n    std::cin &gt;&gt; n &gt;&gt; q &gt;&gt; ty;\n    siz = sqrt(n);\n    k = (n + siz - 1) / siz;\n    b.resize(k);\n    int la = 0, now = k - 1;\n    for (auto &amp;i : b)\n        i.l = la + 1, la = i.r = i.l + siz - 1;\n    b.back().r = n;\n    for (int i = 0; i &lt; k; ++i) &#123;\n        id[0][i] = i;\n        b[i].a.resize(b[i].r - b[i].l + 1);\n        b[i].u.resize(b[i].r - b[i].l + 1);\n        b[i].ne.resize(b[i].r - b[i].l + 1);\n        for (int j = b[i].l; j &lt;= b[i].r; ++j)\n            tab[j] = j - b[i].l, blk[j] = i;\n    &#125;\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; b[blk[i]].a[tab[i]];\n    for (int i = n; i; --i)\n        upd(i, b[blk[i]].a[tab[i]], b[blk[i]]);\n    int ver = 0;\n    while (q--) &#123;\n        int op, pr, x;\n        static int res = 0;\n        std::cin &gt;&gt; op &gt;&gt; pr &gt;&gt; x;\n        if (!ty)\n            res = 0;\n        x ^= res;\n        if (op == 1) &#123;\n            std::copy(id[pr], id[pr] + k, id[++ver]);\n            b.push_back(b[id[ver][blk[x]]]);\n            id[ver][blk[x]] = ++now;\n            std::cin &gt;&gt; b.back().a[tab[x]];\n            b.back().a[tab[x]] ^= res;\n            for (int i = x; i &gt;= b.back().l; --i)\n                upd(i, b.back().a[tab[i]], b.back());\n        &#125;\n        else &#123;\n            int p = x;\n            res = 0;\n            while (~p) &#123;\n                // printf(&quot;p = %d\\n&quot;, p);\n                res += b[id[pr][blk[p]]].u[tab[p]];\n                p = b[id[pr][blk[p]]].ne[tab[p]];\n            &#125;\n            std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n        &#125;\n    &#125;\n    return 0;\n&#125;\nint&amp; devicer::nex(int x) &#123;\n    return ne[tab[x]];\n&#125;\nint&amp; devicer::val(int x) &#123;\n    return u[tab[x]];\n&#125;</code></pre>\n</details>\n",
            "tags": [
                "DP",
                "SAM",
                "状压",
                "分块",
                "可持久化",
                "笛卡尔树"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20240125/",
            "url": "https://xsc062.netlify.app/20240125/",
            "title": "我超！雀！",
            "date_published": "2024-01-25T03:20:57.000Z",
            "content_html": "<p>Solution to <a href=\"http://222.180.160.110:61235/contest/4813/problem/1\">PKUSC2022 Mahjong</a>。</p>\n<span id=\"more\"></span>\n<hr />\n<p><a href=\"https://www.bilibili.com/video/BV1JB4y1R7AP/\" class=\"uri\">https://www.bilibili.com/video/BV1JB4y1R7AP/</a></p>\n<p>这里是 PKUSC 当时的讲解视频。听说可以证明本题一定有 <span class=\"math inline\">\\(\\le 5\\)</span> 的解。好神奇。</p>\n<hr />\n<p>就比如说我们爆搜，<span class=\"math inline\">\\(9^4\\times 13^4\\)</span> 这个显然干不动对吧，所以我们考虑反过来 DP。</p>\n<p>我们先把字符串转化成计数数组，就是每种牌有多少片。不妨将 <code>1m ~ 9s</code> 编号为 <span class=\"math inline\">\\(1\\sim 27\\)</span>，记 <span class=\"math inline\">\\(g_i\\)</span> 为编号为 <span class=\"math inline\">\\(i\\)</span> 的牌的数量。</p>\n<p>为什么我们觉得 DP 不好打呢？因为换牌操作可以将两个毫不相干的牌的数量更改，不好记录状态。我们不妨直接将换牌拆成 <em>丢弃一张牌</em> 和 <em>借取令一张牌</em> 两个操作。很显然这两个操作数量是一样的，因为我们的牌数量自始至终不变。</p>\n<p>对于比较简单的对子作为终局的情况，我们只关心对数是否为 <span class=\"math inline\">\\(7\\)</span>，所以设计状态：<span class=\"math inline\">\\(dp_{i,j}\\)</span> 表示前 <span class=\"math inline\">\\(i\\)</span> 张牌中凑出 <span class=\"math inline\">\\(j\\)</span> 个对子的最小代价。</p>\n<p>那么就分 <em>把当前牌丢一些 / 借一些拿去组对子</em> 和 <em>直接丢弃当前牌</em> 两种方案。因为丢 / 借的数量是不确定的，直接 <code>abs</code> 一下就好。刷表，有：</p>\n<p><span class=\"math display\">\\[\ndp_{i+1,j}=dp_{i,j}+g_{i+1}\\\\\ndp_{i+1,j+1}=dp_{i,j}+|g_{i+1}-2|\n\\]</span></p>\n<p>最后我们的答案就来自 <span class=\"math inline\">\\(dp_{27,7}\\)</span>。然后注意这里我们的终局是 14 张牌 <del>你能秒我</del>，但起手只有 13 张牌，所以其实会有一个额外的借牌操作，假设答案为 <span class=\"math inline\">\\(x\\)</span>，那么其实 <span class=\"math inline\">\\(dp_{27,7}=2\\times x+1\\)</span>。</p>\n<hr />\n<p>有了对子的铺垫，面子手其实也还好。我们需要考虑的是对子和面子的个数。</p>\n<p>但是有个问题，对子只用借 / 丢当前花色，但面子可能是会借 / 丢下一个 / 下下一个花色的。</p>\n<p>所以干脆全部记录到状态里，令 <span class=\"math inline\">\\(f_{i,j,k,a,b}\\)</span> 表示当前在第 <span class=\"math inline\">\\(i\\)</span> 个花色，凑成了 <span class=\"math inline\">\\(j\\)</span> 个面子，<span class=\"math inline\">\\(k\\)</span> 个对子，需要 <span class=\"math inline\">\\(a\\)</span> 个 <span class=\"math inline\">\\(i+1\\)</span>，<span class=\"math inline\">\\(b\\)</span> 个 <span class=\"math inline\">\\(i+2\\)</span>。注意因为表示丢借有负数不太容易，不如就直接设成需要的数量了。</p>\n<p>因为这个需要数量只是前面的花色对当前花色的需要 <span class=\"math inline\">\\(a\\)</span>，我们还要满足当前花色 <strong>自身</strong> 的需要 <span class=\"math inline\">\\(now\\)</span>（也就是说当前花色一共需要 <span class=\"math inline\">\\(a+now\\)</span> 张）。注意这里 <span class=\"math inline\">\\(a\\)</span> 张全部都是拿去借给前面的花色用的，自己不能用。</p>\n<ul>\n<li><p>对于 <span class=\"math inline\">\\(k=0\\)</span> 且 <span class=\"math inline\">\\(now\\ge 2\\)</span>，此时可以从 <span class=\"math inline\">\\(now\\)</span> 里拿两张出来凑对子，剩下的 <span class=\"math inline\">\\(now - 2\\)</span> 因为肯定 <span class=\"math inline\">\\(\\le 2\\)</span>，所以只能全部拿去凑顺子。所以有：</p>\n<span class=\"math display\">\\[\nf_{i+1,j+now-2,1,b+now-2, now-2}=f_{i,j,0,a,b}+|g_{i+1}-(a+now)|\n\\]</span></li>\n<li><p>对于 <span class=\"math inline\">\\(now\\ge 3\\)</span>，拿三张凑一面。有：</p>\n<span class=\"math display\">\\[\nf_{i+1,j+now-2,k,b+now-3,now-3}=f_{i,j,0,a,b}+|g_{i+1}-(a+now)|\n\\]</span></li>\n<li><p>对于 <span class=\"math inline\">\\(now\\ne 0\\)</span>，可以凑顺子，有：</p>\n<p><span class=\"math display\">\\[\nf_{i+1,j+now,k,b+now,now}=f_{i,j,0,a,b}+|g_{i+1}-(a+now)|\n\\]</span></p>\n<p>注意不能跨花色借牌，也就是不能让 <span class=\"math inline\">\\(i=8/9/17/18/26/27\\)</span>。</p></li>\n</ul>\n<p>答案就是 <span class=\"math inline\">\\(f_{27,4,1,0,0}\\)</span>。</p>\n<hr />\n<p>然后这两个情况取一个 <span class=\"math inline\">\\(\\min\\)</span> 就是答案。</p>\n<details>\n<pre class=\"cpp\"><code>namespace XSC062 &#123;\nusing namespace fastIO;\nusing std::cin;\nusing std::getline;\nusing str = std::string;\nint g[30];\nint dp[30][15];\nstr sm, sp, ss;\nint f[30][7][2][7][7];\nint abs(int x) &#123; return x &gt;= 0 ? x : -x; &#125;\nint min(int x, int y) &#123; return x &lt; y ? x : y; &#125;\nvoid upd(int &amp;x, int y) &#123; x = min(x, y); return; &#125;\nint main() &#123;\n    getline(cin, sm, &#39;m&#39;);\n    getline(cin, sp, &#39;p&#39;);\n    getline(cin, ss, &#39;s&#39;);\n    for (auto i : sm) ++g[i - &#39;0&#39;];\n    for (auto i : sp) ++g[i - &#39;0&#39; + 9];\n    for (auto i : ss) ++g[i - &#39;0&#39; + 18];\n    // 打对子\n    memset(dp, 0x3f, sizeof (dp));\n    dp[0][0] = 0;\n    for (int i = 0; i &lt; 27; ++i) &#123;\n        for (int j = 0; j &lt;= 7; ++j) &#123;\n            if (dp[i][j] == 0x3f3f3f3f) continue;\n            upd(dp[i + 1][j], dp[i][j] + g[i + 1]);\n            upd(dp[i + 1][j + 1], dp[i][j] + abs(g[i + 1] - 2));\n        &#125;\n    &#125;\n    // 打飞机\n    memset(f, 0x3f, sizeof (f));\n    f[0][0][0][0][0] = 0;\n    for (int i = 0; i &lt; 27; ++i)\n    for (int j = 0; j &lt;= 4; ++j)\n    for (int k = 0; k &lt;= 1; ++k)\n    for (int a = 0; a &lt;= 4; ++a)\n    for (int b = 0; b &lt;= 4; ++b) &#123;\n        if (i % 9 == 8 &amp;&amp; b) continue;\n        if (i % 9 == 0 &amp;&amp; a + b) continue;\n        for (int now = 0; now &lt;= 4; ++now) &#123; // 对当前的额外需求 \n            if (a + now &gt; 4) continue;\n            int v = f[i][j][k][a][b] + abs(g[i + 1] - (a + now));\n            if (j + now &lt;= 4 &amp;&amp; b + now &lt;= 4) // 直接硬配顺子 \n                upd(f[i + 1][j + now][k][b + now][now], v);\n            if (now &gt;= 2 &amp;&amp; !k &amp;&amp; j + now - 2 &lt;= 4 &amp;&amp; b + now - 2 &lt;= 4) // 借两个去凑对子 \n                upd(f[i + 1][j + now - 2][1][b + now - 2][now - 2], v);\n            if (now &gt;= 3 &amp;&amp; j + now - 2 &lt;= 4 &amp;&amp; b + now - 3 &lt;= 4) // 借两个去凑三不带 \n                upd(f[i + 1][j + now - 2][k][b + now - 3][now - 3], v);\n        &#125;\n    &#125;\n    // 拿来借走会算两次 \n    print(min(dp[27][7], f[27][4][1][0][0]) / 2, &#39;\\n&#39;);\n    return 0;\n&#125;\n&#125; // namespace XSC062</code></pre>\n</details>\n",
            "tags": [
                "DP"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20240111/",
            "url": "https://xsc062.netlify.app/20240111/",
            "title": "杂题别选谈了",
            "date_published": "2024-01-11T03:25:19.000Z",
            "content_html": "<p>Solution to <a href=\"http://222.180.160.110:61235/contest/4665/problem/2\">SP4060 Game with Probability Problem</a>。</p>\n<span id=\"more\"></span>\n<hr />\n<p>设 <span class=\"math inline\">\\(f_i,g_i\\)</span> 分别表示还剩 <span class=\"math inline\">\\(i\\)</span> 个的时候轮到 Alice 和 Bob 时 <strong>Alice</strong> 分别的胜率。</p>\n<p>概率经典倒推。那么显然有 <span class=\"math inline\">\\(f_0=0,g_0=1\\)</span>。</p>\n<p>然后就是一个分讨，讨论这个人想要正面还是反面。很显然，对于同样的剩余棋子数，两个人先手的情况对于这颗棋子的喜爱程度是一样的。也就是说，要么都想要，要么都不想要。</p>\n<p>什么时候想要呢？拿掉过后自己胜率更大，也就是 <span class=\"math inline\">\\(g_{i-1}&gt;f_{i-1}\\)</span>。此时有：</p>\n<p><span class=\"math display\">\\[\nf_i=(1-p)\\times g_i+p\\times g_{i-1}\\\\\ng_i=(1-q)\\times f_i+q\\times f_{i-1}\n\\]</span></p>\n<p>发现是互相影响的，这个时候先不要着急怀疑自己推错了，因为我们这里有两个未知数，又刚好有两个方程，暴解一下就有：</p>\n<p><span class=\"math display\">\\[\nf_i=\\dfrac {(1-p)\\times q\\times f_{i-1}+p\\times g_{i-1}}{1-(1-p)(1-q)}\\\\\ng_i=\\dfrac {(1-q)\\times p\\times g_{i-1}+q\\times f_{i-1}}{1-(1-p)(1-q)}\n\\]</span></p>\n<p>然后 <span class=\"math inline\">\\(g_{i-1}&lt;f_{i-1}\\)</span> 的情况也差不多，把拿的概率和不拿的概率换一下：</p>\n<p><span class=\"math display\">\\[\nf_i=p\\times g_i+(1-p)\\times g_{i-1}\\\\\ng_i=q\\times f_i+(1-q)\\times f_{i-1}\n\\]</span></p>\n<p>解方程组有：</p>\n<p><span class=\"math display\">\\[\nf_i=\\dfrac {(1-q)\\times p\\times f_{i-1}+(1-p)\\times g_{i-1}}{1-p\\times q}\\\\\ng_i=\\dfrac {(1-p)\\times q\\times g_{i-1}+(1-q)\\times f_{i-1}}{1-p\\times q}\n\\]</span></p>\n<p>然后就可以开始 DP 了。最后的答案就是 <span class=\"math inline\">\\(f_{\\min(n,1000)}\\)</span>。</p>\n<p>还有个问题就是 <span class=\"math inline\">\\(n\\)</span> 特别大然后这个看起来也不太能矩乘，但是这个 DP 式有个好处是它的增长趋势是指数级的，所以我们 DP 到 <span class=\"math inline\">\\(1000\\)</span> 就可以了。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nnamespace XSC062 &#123;\nconst int maxn = 1e3 + 5;\nusing db = double;\ndb p, q;\nint T, n;\ndb f[maxn], g[maxn];\nint min(int x, int y) &#123;\n    return x &lt; y ? x : y;\n&#125;\nint main() &#123;\n    scanf(&quot;%d&quot;, &amp;T);\n    while (T--) &#123;\n        scanf(&quot;%d %lf %lf&quot;, &amp;n, &amp;p, &amp;q);\n        f[0] = .0, g[0] = 1.0;\n        for (int i = 1; i &lt;= n &amp;&amp; i &lt;= 1000; ++i) &#123;\n            if (g[i - 1] &gt; f[i - 1]) &#123;\n                f[i] = ((1 - p) * q * f[i - 1] + p * g[i - 1]) / (1 - (1 - p) * (1 - q));\n                g[i] = ((1 - q) * p * g[i - 1] + q * f[i - 1]) / (1 - (1 - p) * (1 - q));\n            &#125;\n            else &#123;\n                f[i] = ((1 - q) * p * f[i - 1] + (1 - p) * g[i - 1]) / (1 - p * q);\n                g[i] = ((1 - p) * q * g[i - 1] + (1 - q) * f[i - 1]) / (1 - p * q);\n            &#125;\n        &#125;\n        printf(&quot;%.6lf\\n&quot;, f[min(n, 1000)]);\n    &#125;\n    return 0;\n&#125;\n&#125; // namespace XSC062\nint main() &#123;\n    XSC062::main();\n    return 0;\n&#125;\n</code></pre>\n</details>\n",
            "tags": [
                "DP",
                "概率期望"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20231003/",
            "url": "https://xsc062.netlify.app/20231003/",
            "title": "杂题",
            "date_published": "2023-10-03T08:42:43.000Z",
            "content_html": "<p><a href=\"http://222.180.160.110:61235/contest/4268\">周考 14</a>。</p>\n<span id=\"more\"></span>\n<hr />\n<p>医生问我对药有什么要求吗，我说我宁死不喝冲剂。</p>\n<p>然后医生给我开了五盒胶囊，告诉我说一天三次，一次六个。</p>\n<p>哈哈哈，我自找的。以此为证，A 一道题磕一片！！！</p>\n<hr />\n<h3 id=\"a.-修改序列\">A. 修改序列</h3>\n<p><a href=\"http://222.180.160.110:61235/contest/4268/problem/1\" class=\"uri\">http://222.180.160.110:61235/contest/4268/problem/1</a></p>\n<p>注意到一增一减，全数列的和 <span class=\"math inline\">\\(s\\)</span> 不变，考虑这一点带来的提示。</p>\n<p>假设最后要求一部分数为 <span class=\"math inline\">\\(p\\)</span>，另一部分为 <span class=\"math inline\">\\(p+1\\)</span>，那么有 <span class=\"math inline\">\\(p = \\lfloor \\dfrac sn \\rfloor\\)</span>，<span class=\"math inline\">\\(p+1\\)</span> 的数量 <span class=\"math inline\">\\(c_r=s\\bmod n\\)</span>，<span class=\"math inline\">\\(p\\)</span> 的数量 <span class=\"math inline\">\\(c_l=n-c_r\\)</span>。</p>\n<p>那么我们让 <span class=\"math inline\">\\(\\le p\\)</span> 的变成 <span class=\"math inline\">\\(p\\)</span>，<span class=\"math inline\">\\(\\ge p + 1\\)</span> 的变成 <span class=\"math inline\">\\(p + 1\\)</span>。直接求两数距离，最后将总和除以二即为答案、</p>\n<details>\n<p><summary>正确性证明…</summary></p>\n<p>这样做的最优性毫无疑问，问题无非就在于这么做的正确性，换言之，为什么一定能找到合法的操作序列还原我们的求解过程。</p>\n<p>将原数列分为两部分，数值 <span class=\"math inline\">\\(\\le p\\)</span> 的（记为 <span class=\"math inline\">\\(X\\)</span>）和数值 <span class=\"math inline\">\\(\\ge p + 1\\)</span> 的（记为 <span class=\"math inline\">\\(Y\\)</span>）。</p>\n<p>再把我们的目标状态分为两部分，数值 <span class=\"math inline\">\\(= p\\)</span> 的（记为 <span class=\"math inline\">\\(A\\)</span>）和 数值 <span class=\"math inline\">\\(=p + 1\\)</span> 的（记为 <span class=\"math inline\">\\(B\\)</span>）。</p>\n<p>那么有 <span class=\"math inline\">\\(\\begin{cases}X+Y=s\\\\A+B=s\\end{cases}\\)</span>，由等式的基本性质得 <span class=\"math inline\">\\(X-A+Y-B = 0\\)</span>，移项得 <span class=\"math inline\">\\(Y-B=A-X\\)</span>。也就是说，<span class=\"math inline\">\\(Y\\)</span> 部分与 <span class=\"math inline\">\\(p+1\\)</span> 的差的总和正好等于 <span class=\"math inline\">\\(X\\)</span> 部分与 <span class=\"math inline\">\\(p\\)</span> 的差的总和。</p>\n<p>这个时候我们的正确性就有了保证。</p>\n<p>这个时候你可能就有疑问了，<span class=\"math inline\">\\(X,Y\\)</span> 中的元素个数和 <span class=\"math inline\">\\(A,B\\)</span> 中的元素个数并不对应，怎么办呢？</p>\n<p>我们发现上面的原理式并不会随元素个数的变化而变化，所以依然可以用它来解答这个问题。没有人规定 <span class=\"math inline\">\\(Y-B\\)</span> 和 <span class=\"math inline\">\\(A-X\\)</span> 不能为负，为负时我们把 <span class=\"math inline\">\\(A\\)</span> 中塞不下的 <span class=\"math inline\">\\(X\\)</span> 拿到 <span class=\"math inline\">\\(B\\)</span> 里面去即可，反之同理。</p>\n</details>\n<p>那么代码还是很好写的。时间复杂度 <span class=\"math inline\">\\(O(n)\\)</span>。</p>\n<details>\n<pre class=\"cpp\"><code>namespace XSC062 &#123;\nusing namespace fastIO;\nconst int maxn = 2e5 + 5;\nint a[maxn];\nint n, s, p, cl, cg, res;\nint main() &#123;\n    read(n);\n    for (int i = 1; i &lt;= n; ++i)\n        read(a[i]), s += a[i];\n    p = s / n, cg = s - p * n, cl = n - cg;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        if (a[i] &lt;= p) &#123;\n            if (cl) res += p - a[i], --cl;\n            else res += p - a[i] + 1, --cg;\n        &#125;\n        else &#123;\n            if (cg) res += a[i] - p - 1, --cg;\n            else res += a[i] - p, --cl;\n        &#125;\n    &#125;\n    print(res / 2, &#39;\\n&#39;);\n    return 0;\n&#125;\n&#125; // namespace XSC062</code></pre>\n</details>\n<hr />\n<h3 id=\"b.-knuth-表示法\">B. Knuth 表示法</h3>\n<p><a href=\"http://222.180.160.110:61235/contest/4268/problem/2\" class=\"uri\">http://222.180.160.110:61235/contest/4268/problem/2</a></p>\n<p>模拟。输入的数用 <code>map</code> 转化为 <span class=\"math inline\">\\(10\\)</span> 的次幂形式，然后幂次直接相加即表示指数相乘。</p>\n<p>最后按位数从大到小将次幂形式转化为字符串、再按位数从小到大输出。</p>\n<p>注意到开头的字符串不是 <code>one</code> 就是 <code>ten</code>，需要在没有抽出来 <code>ten</code> 的时候补 <code>one</code>。</p>\n<details>\n<pre class=\"cpp\"><code>namespace XSC062 &#123;\nusing namespace fastIO;\nusing str = std::string;\nconst str u[] = &#123; &quot;one&quot;, &quot;ten&quot;, &quot;hundred&quot;, &quot;myriad&quot;, &quot;myllion&quot;, &quot;byllion&quot;, &quot;tryllion&quot;,\n                  &quot;quadryllion&quot;, &quot;quintyllion&quot;, &quot;sextyllion&quot;, &quot;septyllion&quot;, &quot;octyllion&quot;,\n                  &quot;nonyllion&quot;, &quot;decyllion&quot; &#125;;\nstr x;\nint res = 0;\nstd::stack&lt;str&gt; s;\nstd::map&lt;str, int&gt; t;\nvoid get(str &amp;x) &#123;\n    str y;\n    std::stringstream p(x);\n    while (p &gt;&gt; y) &#123;\n        if (y == &quot;one&quot;) continue;\n        res += 1 &lt;&lt; (t[y] - 1);\n    &#125;\n    return;\n&#125;\nint main() &#123;\n    for (int i = 0; i &lt;= 13; ++i) t[u[i]] = i;\n    std::getline(std::cin, x), get(x);\n    std::getline(std::cin, x), get(x);\n    for (int i = 13; i; --i) &#123;\n        if (res &amp; (1 &lt;&lt; (i - 1)))\n            s.push(u[i]), res ^= (1 &lt;&lt; (i - 1));\n    &#125;\n    if (s.top() != &quot;ten&quot;) s.push(&quot;one&quot;);\n    while (!s.empty())\n        std::cout &lt;&lt; s.top() &lt;&lt; &#39; &#39;, s.pop();\n    return 0;\n&#125;\n&#125; // namespace XSC062</code></pre>\n</details>\n<hr />\n<h3 id=\"c.-魔力塔\">C. 魔力塔</h3>\n<p><a href=\"http://222.180.160.110:61235/contest/4268/problem/3\" class=\"uri\">http://222.180.160.110:61235/contest/4268/problem/3</a></p>\n<p>神奇的线段树优化建图。这拿来放 T3？不合适吧。</p>\n<p>很好想到对于 <span class=\"math inline\">\\(a_i\\ne -1\\)</span>，连边 <span class=\"math inline\">\\(i\\to a_i\\)</span>；否则，连边 <span class=\"math inline\">\\(i\\to x(x\\in [i+1,\\min(i + k,n+1)])\\)</span>。BFS 遍历，复杂度 <span class=\"math inline\">\\(O(n\\times k)\\)</span>。</p>\n<p>问题在于无用边太多，例如 <span class=\"math inline\">\\(i\\)</span> 和 <span class=\"math inline\">\\(i+1\\)</span> 共同可达的点有整整 <span class=\"math inline\">\\(k-1\\)</span> 个，造成大量浪费。</p>\n<p>考虑到实际进入 BFS 的点只有 <span class=\"math inline\">\\(n\\)</span> 个，及由传送门构成的连通块均呈棒棒糖状（即链套环），我们直接优化掉 <span class=\"math inline\">\\(a_i=-1\\)</span> 时的连边。使用线段树查询 <span class=\"math inline\">\\([i+1,\\min(i + k,n+1)]\\)</span> 内的所有剩余点，连边入队并从线段树中删除。</p>\n<p>这样，每个点只会入队一次（忽视无用环），时间复杂度控制在 <span class=\"math inline\">\\(O(n\\log n)\\)</span>，<span class=\"math inline\">\\(\\log\\)</span> 来源于线段树，写得不好就是 <span class=\"math inline\">\\(\\log^2\\)</span>，写得好一点就只有一个。</p>\n<details>\n<p><summary>然而…</summary></p>\n<p>会 T，因为常数太大了。</p>\n<p>所以我们需要另一种 <span class=\"math inline\">\\(\\log\\)</span> 的做法，并且短小精悍。</p>\n<p>用 <code>set</code> 存储所有未入队的点，每次 <code>lower_bound</code> 并依次弹出、入队。</p>\n</details>\n<p>用迭代器的话代码很短，美汁汁。</p>\n<p>时间复杂度 <span class=\"math inline\">\\(O(n\\log n)\\)</span>，但等我先磕片药先。</p>\n<details>\n<pre class=\"cpp\"><code>namespace XSC062 &#123;\nusing namespace fastIO;\nconst int maxn = 5e5 + 5;\nint a[maxn];\nint n, k, res;\nbool vis[maxn];\nstd::set&lt;int&gt; t;\nstd::vector&lt;int&gt; g[maxn]; \nint max(int x, int y) &#123; return x &gt; y ? x : y; &#125;\nvoid DFS(int x) &#123;\n    res = max(res, x);\n    if (a[x] == -1) &#123;\n        auto p = t.lower_bound(x + 1);\n        while (p != t.end() &amp;&amp; *p &lt;= x + k) &#123;\n            g[x].push_back(*p);\n            t.erase(*p++);\n        &#125;\n    &#125;\n    for (auto i : g[x]) &#123;\n        if (vis[i]) continue;\n        vis[i] = 1, DFS(i);\n    &#125;\n    return;\n&#125;\nint main() &#123;\n    read(n), read(k);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        read(a[i]), t.insert(i + 1);\n        if (~a[i]) g[i].push_back(a[i]);\n    &#125;\n    DFS(1), print(res, &#39;\\n&#39;);\n    return 0;\n&#125;\n&#125; // namespace XSC062</code></pre>\n</details>\n<hr />\n<h3 id=\"d.-卡牌游戏\">D. 卡牌游戏</h3>\n<p><a href=\"http://222.180.160.110:61235/contest/4268/problem/4\" class=\"uri\">http://222.180.160.110:61235/contest/4268/problem/4</a></p>\n<p>怎么说呢，爆搜可以拿 80pts！！！然而正解是区间 DP，哭唧唧。他这个数据范围给得很神奇，让人只会往搜索上面想。</p>\n<p>摧毁操作是一换一，不会更改串长，而入栈操作会增加初始串的长度。</p>\n<p>所以我们考虑 <strong>逆序 DP</strong>，从最终状态入手，用 <span class=\"math inline\">\\(f_{x, i, j}\\)</span> 表示是否可以使用一个字符 <span class=\"math inline\">\\(x\\)</span> 经过一系列操作消掉 <span class=\"math inline\">\\(w_{i\\sim j}\\)</span>。</p>\n<p>那么明显若一条摧毁操作为可用字符 <span class=\"math inline\">\\(a\\)</span> 摧毁 <span class=\"math inline\">\\(w_i\\)</span>，有 <span class=\"math inline\">\\(f_{a, i, i} = 1\\)</span>。</p>\n<p>若一条入栈操作为用字符 <span class=\"math inline\">\\(a\\)</span> 换字符 <span class=\"math inline\">\\(b,c\\)</span>，枚举区间断点 <span class=\"math inline\">\\(k\\)</span>，有 <span class=\"math inline\">\\(f_{a, i, j} = f_{b, i, k} \\times f_{c, k + 1, j}\\)</span>。</p>\n<p>最后答案为 <span class=\"math inline\">\\(f_{\\texttt S,i,|w_i|}\\)</span>。</p>\n<p>注意循环顺序，区间的枚举应在字符的枚举之外。最终时间复杂度 <span class=\"math inline\">\\(O(T\\times |w_i|^3\\times N_2)\\)</span>，注意到字母的枚举属于常数。胶囊好吃滴捏。</p>\n<details>\n<pre class=\"cpp\"><code>namespace XSC062 &#123;\nusing namespace fastIO;\nconst int maxn = 25;\nconst int maxm = 1e3 + 5;\nint n, m, l;\nchar w[maxn];\nbool r1[maxm][maxm];\nbool f[maxm][maxn][maxn];\nstruct &#123; int u, a, b; &#125; r2[maxn];\nint main() &#123;\n    scanf(&quot;%d %d&quot;, &amp;n, &amp;m);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        scanf(&quot;%s&quot;, w + 1);\n        r1[(int)w[1]][(int)w[4]] = 1;\n    &#125;\n    for (int i = 1; i &lt;= m; ++i) &#123;\n        scanf(&quot;%s&quot;, w + 1);\n        r2[i].u = w[1];\n        r2[i].a = w[4], r2[i].b = w[5];\n    &#125;\n    while (~scanf(&quot;%s&quot;, w + 1)) &#123;\n        memset(f, 0, sizeof (f));\n        l = strlen(w + 1);\n        for (int i = &#39;A&#39;; i &lt;= &#39;Z&#39;; ++i) &#123;\n            for (int j = 1; j &lt;= l; ++j) &#123;\n                if (r1[i][(int)w[j]])\n                    f[i][j][j] = 1;\n            &#125;\n        &#125;\n        for (int len = 1; len &lt;= l; ++len) &#123;\n            for (int i = 1; i &lt;= l - len + 1; ++i) &#123;\n                int j = i + len - 1;\n                for (int t = &#39;A&#39;; t &lt;= &#39;Z&#39;; ++t) &#123;\n                    for (int k = i; k &lt; j; ++k) &#123;\n                        for (int p = 1; p &lt;= m; ++p) &#123;\n                            if (r2[p].u != t) continue;\n                            f[t][i][j] |= f[r2[p].a][i][k] &amp;&amp; f[r2[p].b][k + 1][j];\n                        &#125;\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n        puts(f[&#39;S&#39;][1][l] ? &quot;YES&quot; : &quot;NO&quot;);\n    &#125;\n    return 0;\n&#125;\n&#125; // namespace XSC062</code></pre>\n</details>\n<hr />\n<h3 id=\"e.-生长树\">E. 生长树</h3>\n<p><a href=\"http://222.180.160.110:61235/contest/4268/problem/5\" class=\"uri\">http://222.180.160.110:61235/contest/4268/problem/5</a></p>\n<p>一道很菜的题。我们发现有子树操作，第一时间想到树剖，那么接下来要考虑的内容就是线段树如何维护。</p>\n<p>题意换句话说就是往下数 0 代是加，数 1 代是减，数 2 代是加，以此类推。那么不难想到奇偶性。</p>\n<p>如果起点的深度是奇数，那么子树中所有奇数深度权值增加，偶数深度权值减少，反之同理。</p>\n<p>但是我们操作线段树的时候怎么知道点在树中的深度奇偶性呢？我们只能在线段树外才知道呀。</p>\n<p>所以观察询问，询问是单点的，所以我们知道了，可以只在线段树外对奇偶性进行处理。简单来说，假设更改起点深度为奇数，那么增加整个子树的「奇加偶减计数器」；反之，增加整个子树的「奇减偶加计数器」。</p>\n<p>最后查询的时候，如果该点深度为奇，那么答案为对应的「奇加偶减计数器」减去「奇减偶加计数器」的值，反之同理。</p>\n<p>做到最后发现根本不用树剖，就是一个 DFN 上线段树。时间复杂度 <span class=\"math inline\">\\(O(m\\log n)\\)</span>。</p>\n<p>胶囊真好吃！！！</p>\n<details>\n<pre class=\"cpp\"><code>namespace XSC062 &#123;\nusing namespace fastIO;\n#define lt (p &lt;&lt; 1)\n#define rt (lt | 1)\nconst int maxn = 2e5 + 5;\nstruct _ &#123;\n    int l, r;\n    int u1, u2, d1, d2;\n&#125;; \n_ t[maxn &lt;&lt; 2];\nint a[maxn], dep[maxn];\nstd::vector&lt;int&gt; g[maxn];\nint n, m, x, y, tot, typ;\nint end[maxn], dfn[maxn], tab[maxn];\n// u 只用维护最底层信息\n// 所以不用打 pushup \n// 但维护起来好看一些 所以还是打了\nvoid pushup(int p) &#123;\n    t[p].u1 = t[lt].u1 + t[rt].u1;\n    t[p].u2 = t[lt].u2 + t[rt].u2;\n    return;\n&#125;\nvoid pushdown(int p) &#123;\n    if (t[p].d1) &#123;\n        t[lt].d1 += t[p].d1;\n        t[rt].d1 += t[p].d1;\n        t[lt].u1 += t[p].d1 * (t[lt].r - t[lt].l + 1);\n        t[rt].u1 += t[p].d1 * (t[rt].r - t[rt].l + 1);\n        t[p].d1 = 0;\n    &#125;\n    if (t[p].d2) &#123;\n        t[lt].d2 += t[p].d2;\n        t[rt].d2 += t[p].d2;\n        t[lt].u2 += t[p].d2 * (t[lt].r - t[lt].l + 1);\n        t[rt].u2 += t[p].d2 * (t[rt].r - t[rt].l + 1);\n        t[p].d2 = 0;\n    &#125;\n    return;\n&#125;\nvoid bld(int p, int l, int r) &#123;\n    t[p].l = l, t[p].r = r;\n    if (l == r) &#123;\n        if (dep[tab[l]] &amp; 1)\n            t[p].u1 = a[tab[l]];\n        else t[p].u2 = a[tab[l]];\n        return;\n    &#125;\n    int mid = (l + r) &gt;&gt; 1;\n    bld(lt, l, mid), bld(rt, mid + 1, r);\n    pushup(p);\n    return;\n&#125;\nvoid add1(int p, int l, int r, int x) &#123;\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r) &#123;\n        t[p].d1 += x;\n        t[p].u1 += (t[p].r - t[p].l + 1) * x;\n        return;\n    &#125;\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    pushdown(p);\n    if (l &lt;= mid) add1(lt, l, r, x);\n    if (r &gt; mid) add1(rt, l, r, x);\n    pushup(p);\n    return;\n&#125;\nvoid add2(int p, int l, int r, int x) &#123;\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r) &#123;\n        t[p].d2 += x;\n        t[p].u2 += (t[p].r - t[p].l + 1) * x;\n        return;\n    &#125;\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    pushdown(p);\n    if (l &lt;= mid) add2(lt, l, r, x);\n    if (r &gt; mid) add2(rt, l, r, x);\n    pushup(p);\n    return;\n&#125;\nint ask(int p, int x) &#123;\n    if (t[p].l == t[p].r)\n        return t[p].u1 - t[p].u2;\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    pushdown(p);\n    if (x &lt;= mid) return ask(lt, x);\n    return ask(rt, x);\n&#125;\nvoid DFS(int x, int fa) &#123;\n    dfn[x] = ++tot, tab[tot] = x;\n    for (auto i : g[x]) &#123;\n        if (i == fa) continue;\n        dep[i] = dep[x] + 1;\n        DFS(i, x);\n    &#125;\n    end[x] = tot;\n    return;\n&#125;\nvoid add(int x, int y) &#123;\n    g[x].push_back(y);\n    return;\n&#125;\nint main() &#123;\n    read(n), read(m);\n    for (int i = 1; i &lt;= n; ++i)\n        read(a[i]);\n    for (int i = 1; i &lt; n; ++i) &#123;\n        read(x), read(y);\n        add(x, y), add(y, x);\n    &#125;\n    dep[1] = 1, DFS(1, -1);\n    bld(1, 1, n);\n    while (m--) &#123;\n        read(typ), read(x);\n        if (typ == 1) &#123;\n            read(y);\n            if (dep[x] &amp; 1)\n                add1(1, dfn[x], end[x], y);\n            else add2(1, dfn[x], end[x], y);\n        &#125;\n        else &#123;\n            int res = ask(1, dfn[x]);\n            if (dep[x] &amp; 1)\n                print(res, &#39;\\n&#39;);\n            else print(-res, &#39;\\n&#39;);\n        &#125;\n    &#125;\n    return 0;\n&#125;\n&#125; // namespace XSC062</code></pre>\n</details>\n<hr />\n<h3 id=\"f.-单词\">F. 单词</h3>\n<p><a href=\"http://222.180.160.110:61235/contest/4268/problem/6\" class=\"uri\">http://222.180.160.110:61235/contest/4268/problem/6</a></p>\n<p><span class=\"math inline\">\\(n \\le 20\\)</span>，考虑状压。用 <span class=\"math inline\">\\(f_x\\)</span> 表示状态为 <span class=\"math inline\">\\(x\\)</span> 时的最小代价，其中 <span class=\"math inline\">\\(x\\)</span> 是字符串合法情况的状态压缩。</p>\n<p>对于每一个待满足的串，枚举去满足它的哪一位，那么满足方式分两种情况：</p>\n<ul>\n<li>把它变成一个新的值</li>\n<li><p>把和它重合的变成新的值</p>\n<p>我们注意到 <span class=\"math inline\">\\(n \\le 20 \\le 26\\)</span>，所以一定能找到一种方法让每个串的这一位都不一样。</p>\n<p>接着，反正我们都要改这一位了，那就贪心地把要改的全部改成完全不一样的。那么这些要改的串也在这一位上满足了条件。</p></li>\n</ul>\n<p>所以，假设对于状态 <span class=\"math inline\">\\(i\\)</span>，有串 <span class=\"math inline\">\\(j\\)</span> 未满足，枚举位置 <span class=\"math inline\">\\(k\\)</span>，有：</p>\n<pre class=\"cpp\"><code>f[i | (1 &lt;&lt; (j - 1))] = min(f[i | (1 &lt;&lt; (j - 1))], f[i] + a[j][k]); \nf[i | lac[j][k]] = min(f[i | lac[j][k]], f[i] + mx[j][k]);</code></pre>\n<p>其中 <code>lac[j][k]</code> 和 <code>mx[j][k]</code> 都是预处理出来的值。<code>lac[j][k]</code> 表示与第 <span class=\"math inline\">\\(j\\)</span> 个串的第 <span class=\"math inline\">\\(k\\)</span> 位相同串的状态压缩；<code>mx[j][k]</code> 表示通过第二种方式将 <span class=\"math inline\">\\(j\\)</span> 串的第 <span class=\"math inline\">\\(k\\)</span> 位变得合法的最小费用。</p>\n<p><code>lac[j][k]</code> 的求法没有任何疑问，主要是在 <code>mx[j][k]</code> 上。注意到假设这一位上有 <span class=\"math inline\">\\(x\\)</span> 个串与 <span class=\"math inline\">\\(j\\)</span> 串的第 <span class=\"math inline\">\\(k\\)</span> 位相同（包括其本身），而我们只需要将这当中的 <span class=\"math inline\">\\(x-1\\)</span> 个变成两两不同的全新字符就可以同时满足这 <span class=\"math inline\">\\(x\\)</span> 串的条件，那我们为什么不把不动的这一个串设置为 <span class=\"math inline\">\\(x\\)</span> 个串中改这一位代价最大的那个呢？</p>\n<p>那么问题来了。我们枚举状态、枚举状态中的每一个 <code>0</code>，枚举每一个串的每一位，实际上是 <span class=\"math inline\">\\(O(n\\times m\\times 2^n)\\)</span> 的。虽然跑不满，但这个时间复杂度仍然是有问题的。我们需要优化。</p>\n<p>我们枚举的是状态中的每一个 <code>0</code>，假设我们的状态是 <code>000</code>，我们的解决方案是将三个 <code>0</code> 位置的方案共同处理，表示为 <code>'0--'</code> + <code>'-0-'</code> + <code>'--0'</code>。但实际上，我们只用实际求解一个 <code>0</code> 位置的答案，表示为 <code>'0--'</code> + <code>'-00'</code> 。</p>\n<p>也就是说，我们原本需要枚举每一个状态为 <code>0</code> 的 <span class=\"math inline\">\\(j\\)</span> 并用 <span class=\"math inline\">\\(O(m)\\)</span> 的时间进行计算，现在我们碰到一个状态为 <code>0</code> 的 <span class=\"math inline\">\\(j\\)</span> 就开始计算，得到完全相同的答案。</p>\n<p>很 NB 并且很实用的优化，已加入 <a href=\"/20231117/\">下饭操作合集</a>。</p>\n<details>\n<pre class=\"cpp\"><code>namespace XSC062 &#123;\nusing namespace fastIO;\nconst int maxn = 205;\nconst int maxm = (1 &lt;&lt; 25) + 5;\nint f[maxm];\nint n, m, siz;\nchar s[maxn][maxn];\nint lac[maxn][maxn];\nint a[maxn][maxn], mx[maxn][maxn];\nint min(int x, int y) &#123; return x &lt; y ? x : y; &#125;\nint max(int x, int y) &#123; return x &gt; y ? x : y; &#125;\nint main() &#123;\n    while(~scanf(&quot;%d %d&quot;, &amp;n, &amp;m)) &#123;\n        memset(f, 0x3f, sizeof (f));\n        f[0] = 0, siz = 1 &lt;&lt; n;\n        for (int i = 1; i &lt;= n; ++i)\n            scanf(&quot;%s&quot;, s[i] + 1);\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            for (int j = 1; j &lt;= m; ++j)\n                scanf(&quot;%d&quot;, &amp;a[i][j]);\n        &#125;\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            for (int j = 1; j &lt;= m; ++j) &#123;\n                int sum = 0;\n                lac[i][j] = mx[i][j] = 0;\n                for (int k = 1; k &lt;= n; ++k) &#123;\n                    if (s[k][j] == s[i][j]) &#123;\n                        lac[i][j] |= 1 &lt;&lt; (k - 1);\n                        sum += a[k][j];\n                        mx[i][j] = max(mx[i][j], a[k][j]);\n                    &#125;\n                &#125;\n                mx[i][j] = sum - mx[i][j];\n            &#125;\n        &#125;\n        for (int i = 0, j; i &lt; siz - 1; ++i) &#123;\n            for (j = 1; j &lt;= n; ++j) &#123;\n                if (!(i &amp; (1 &lt;&lt; (j - 1))))\n                    break;\n            &#125;\n            for (int k = 1; k &lt;= m; ++k) &#123;\n                f[i | (1 &lt;&lt; (j - 1))] =\n                    min(f[i | (1 &lt;&lt; (j - 1))], f[i] + a[j][k]); \n                f[i | lac[j][k]] =\n                    min(f[i | lac[j][k]], f[i] + mx[j][k]);\n            &#125;\n        &#125;\n        print(f[siz - 1], &#39;\\n&#39;);\n    &#125;\n    return 0;\n&#125;\n&#125; // namespace XSC062</code></pre>\n</details>\n<hr />\n<p>这次暴露出的问题：</p>\n<ul>\n<li>深度乱求，打代码的时候考虑过要放在递归之前，但是由于精力不集中最后还是放在了递归后面。</li>\n</ul>\n<p>没了。这次主要问题出在 T5。T3 估计真的想不到，先不强求自己。</p>\n<p>这次学到的新知识：</p>\n<ul>\n<li>对于子集合并最优性的问题，可以用单点 + 集合代替集合 + 集合枚举。</li>\n</ul>\n",
            "tags": [
                "DP",
                "线段树"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20230716-1/",
            "url": "https://xsc062.netlify.app/20230716-1/",
            "title": "解题报告 匹配数",
            "date_published": "2023-07-16T14:18:06.000Z",
            "content_html": "<p>老题解批量补档。</p>\n<span id=\"more\"></span>\n<hr />\n<p><a href=\"http://222.180.160.110:61235/contest/3887/problem/2\" class=\"uri\">http://222.180.160.110:61235/contest/3887/problem/2</a></p>\n<blockquote>\n<p>求出最小的、不含前导零的 <span class=\"math inline\">\\(n\\)</span> 位数 <span class=\"math inline\">\\(x\\)</span>，满足 <span class=\"math inline\">\\(n-1\\)</span> 条限制，第 <span class=\"math inline\">\\(i\\)</span> 条限制规定 <span class=\"math inline\">\\(x\\)</span> 的第 <span class=\"math inline\">\\(i\\)</span> 位和 <span class=\"math inline\">\\(i + 1\\)</span> 位的关系（小于、大于、等于、不等于）。</p>\n</blockquote>\n<p>如果正着 DP，也就是说先确定前面的数位再向后 DP，后面的数位就没办法决定选择哪个已有状态进行转移，因为我们没有办法仅凭上一位就得到哪个状态拥有最小的字典序。</p>\n<p>但是题解很风轻云淡地给出了一个我一辈子想不出来的 fix：倒着 DP。我们只要保证每次选取最小的可行的下一位即可，这恰好符合字典序的定义。</p>\n<p>记录前驱（or 后继？）后输出即可。</p>\n<details>\n<pre class=\"cpp\"><code>namespace XSC062 &#123;\nusing namespace fastIO;\nconst int maxm = 15;\nconst int maxn = 2e3 + 5;\nint n;\nchar s[maxn];\nint f[maxn][maxm];\nvoid output(int i, int j) &#123;\n    print(j);\n    if (i != n)\n        output(i + 1, f[i][j]);\n    return;\n&#125;\nint main() &#123;\n    scanf(&quot;%s&quot;, s + 1);\n    n = strlen(s + 1) + 1;\n    memset(f, -1, sizeof (f));\n    for (int i = 0; i &lt;= 9; ++i)\n        f[n][i] = 0x3f3f3f3f;\n    for (int i = n - 1; i; --i) &#123;\n        for (int j = 0; j &lt;= 9; ++j) &#123;\n            if (s[i] == &#39;&gt;&#39;) &#123;\n                for (int k = j - 1; k &gt;= 0; --k) &#123;\n                    if (~f[i + 1][k])\n                        f[i][j] = k;\n                &#125;\n            &#125;\n            else if (s[i] == &#39;&lt;&#39;) &#123;\n                for (int k = 9; k &gt; j; --k) &#123;\n                    if (~f[i + 1][k])\n                        f[i][j] = k;\n                &#125;\n            &#125;\n            else if (s[i] == &#39;=&#39;) &#123;\n                if (~f[i + 1][j])\n                    f[i][j] = j;\n            &#125;\n            else &#123;\n                for (int k = 9; ~k; --k) &#123;\n                    if (k == j)\n                        continue;\n                    if (~f[i + 1][k])\n                        f[i][j] = k;\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n    for (int i = 1; i &lt;= 9; ++i)\n        if (~f[1][i]) &#123;\n            output(1, i);\n            break;\n        &#125;\n    return 0;\n&#125;\n&#125; // namespace XSC062</code></pre>\n</details>\n",
            "tags": [
                "DP"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20230203/",
            "url": "https://xsc062.netlify.app/20230203/",
            "title": "美丽的柠檬花！",
            "date_published": "2023-02-03T08:00:59.000Z",
            "content_html": "<p>Solution to <a href=\"https://codeforces.com/problemset/problem/1733/D2\">CF1733D2 Zero-One (Hard Version)</a>。</p>\n<span id=\"more\"></span>\n<hr />\n<p>没做过简单版本，模拟赛上遇到，乍一看是个贪心，但贪心思维太弱想不到怎么贪。所以思考其他方法。</p>\n<p>下文称同时取反 <span class=\"math inline\">\\(a_i\\)</span> 和 <span class=\"math inline\">\\(a_j\\)</span> 的一次操作为「取反 <span class=\"math inline\">\\((a_i, a_j)\\)</span>」，称 <span class=\"math inline\">\\(a_i=b_i\\)</span> 的状态为「匹配」。</p>\n<hr />\n<h3 id=\"思维关键点\">思维关键点</h3>\n<p>若我们想要将 <span class=\"math inline\">\\((a_i,a_j)\\)</span> 取反，我们可以怎么做？</p>\n<p>不难发现，分 <span class=\"math inline\">\\(a_i\\)</span> 与 <span class=\"math inline\">\\(a_j\\)</span> 相邻和不相邻两种情况：</p>\n<ol type=\"1\">\n<li><p><span class=\"math inline\">\\(a_i\\)</span> 与 <span class=\"math inline\">\\(a_j\\)</span> 相邻：</p>\n<ol type=\"1\">\n<li>直接取反，代价为 <span class=\"math inline\">\\(x\\)</span>。</li>\n<li>寻找到一个与 <span class=\"math inline\">\\(a_i\\)</span> 和 <span class=\"math inline\">\\(a_j\\)</span> 都不相邻的 <span class=\"math inline\">\\(a_k\\)</span>，先将 <span class=\"math inline\">\\((a_i,a_k)\\)</span> 取反，再将 <span class=\"math inline\">\\((a_j,a_k)\\)</span> 取反，代价为 <span class=\"math inline\">\\(2\\times y\\)</span>。</li>\n</ol></li>\n<li><p><span class=\"math inline\">\\(a_i\\)</span> 与 <span class=\"math inline\">\\(a_j\\)</span> 不相邻：</p>\n<ol type=\"1\">\n<li>直接取反，代价为 <span class=\"math inline\">\\(y\\)</span>。</li>\n<li>将 <span class=\"math inline\">\\((a_i,a_{i + 1}),(a_{i + 1}, a_{i + 2}),\\cdots,(a_{j - 1}, a_{j})\\)</span> 取反，代价为 <span class=\"math inline\">\\((j - i)\\times x\\)</span>。</li>\n</ol></li>\n</ol>\n<p>接下来考虑另一个问题：我们要取反哪些 <span class=\"math inline\">\\((a_i,a_j)\\)</span> 呢？</p>\n<p>假设现在有 <span class=\"math inline\">\\(a_p\\)</span> 与 <span class=\"math inline\">\\(b_p\\)</span> 不匹配，<span class=\"math inline\">\\(a_q\\)</span> 与 <span class=\"math inline\">\\(b_q\\)</span> 不匹配，那么我们肯定选择将 <span class=\"math inline\">\\((a_p,a_q)\\)</span> 取反。</p>\n<p>原因很简单，假设有 <span class=\"math inline\">\\(a_k=b_k\\)</span>，如果我们将 <span class=\"math inline\">\\((a_p,a_k)\\)</span> 取反，那么 <span class=\"math inline\">\\(a_k\\ne b_k\\)</span>，我们需要额外的一次与 <span class=\"math inline\">\\(a_k\\)</span> 有关的操作将其复原。如果我们挑选一个 <span class=\"math inline\">\\(a_l=b_l\\)</span>，并将 <span class=\"math inline\">\\((a_k,a_l)\\)</span> 取反，那么 <span class=\"math inline\">\\(a_l\\)</span> 与 <span class=\"math inline\">\\(b_l\\)</span> 又会不匹配，又需要一次操作；如果挑选一个 <span class=\"math inline\">\\(a_l\\ne b_l\\)</span>，并将 <span class=\"math inline\">\\((a_k,a_l)\\)</span> 取反，那么为什么不能在一开始就将 <span class=\"math inline\">\\((a_p,a_l)\\)</span> 取反呢？此时的 <span class=\"math inline\">\\(a_k\\)</span> 相当于一个中继，而这种情况我们已经在取反 <span class=\"math inline\">\\((a_p,a_l)\\)</span> 时考虑到了。</p>\n<p>也就是说，我们每次取反 <strong>只</strong> 选择两个无法与 <span class=\"math inline\">\\(b\\)</span> 匹配的 <span class=\"math inline\">\\(a\\)</span>。</p>\n<p>那么，有没有一种情况，让我们无法选择两个无法匹配的值呢？</p>\n<p>那就是不匹配的值的数量有奇数个，才会让我们两个两个选的时候有元素落单。</p>\n<p>不妨思考一次取反操作所有可能的情况（假设不受上面的结论限制）：</p>\n<ol type=\"1\">\n<li><p>取反一个匹配值和一个不匹配值</p>\n此时匹配值变为非匹配，不匹配值变为匹配，不匹配的元素总数不变。</li>\n<li><p>取反两个不匹配值</p>\n两个不匹配值都变为匹配，不匹配元素的总数量增加 <span class=\"math inline\">\\(-2\\)</span>。</li>\n<li><p>取反两个匹配值</p>\n<p>两个匹配值都变为非匹配，不匹配元素的总数量增加 <span class=\"math inline\">\\(2\\)</span>。</p></li>\n</ol>\n<p>综上，一次操作对不匹配元素总数带来的更改只可能为 <span class=\"math inline\">\\(0,2,-2\\)</span>，均为偶数。当不匹配元素为奇数时，必定无法将其更改至刚好为 <span class=\"math inline\">\\(0\\)</span>。此时输出 <span class=\"math inline\">\\(-1\\)</span>。</p>\n<p>我们上面结论的可实现性也得到了保障：只取反两个不匹配的 <span class=\"math inline\">\\(a\\)</span>，不会有元素落单。</p>\n<p>下文记从前往后第 <span class=\"math inline\">\\(i\\)</span> 个与 <span class=\"math inline\">\\(b\\)</span> 不匹配的 <span class=\"math inline\">\\(a\\)</span> 的下标为 <span class=\"math inline\">\\(d_i\\)</span>。</p>\n<hr />\n<h3 id=\"确定实现方法\">确定实现方法</h3>\n<p>发现 <span class=\"math inline\">\\(\\sum n\\le 5\\times 10^3\\)</span>，确定算法复杂度为 <span class=\"math inline\">\\(O(n^2)\\)</span>。</p>\n<p>首先不难想到暴力搜索，每次枚举将哪一对 <span class=\"math inline\">\\((d_i, d_j)\\)</span> 取反。</p>\n<p>亦或是使用 <code>bitset</code> 记录哪些非匹配值已被取反（被取反为 <span class=\"math inline\">\\(1\\)</span>，否则为 <span class=\"math inline\">\\(0\\)</span>），枚举数对暴力 DP 更新最小值。</p>\n<p>但以上两种方法铁定超时。</p>\n<p>受到上面两种方法的启发，扩展思维，我们发现：</p>\n<ul>\n<li><p>取反操作的顺序不会影响最终答案。</p>\n因为每个数被取反的次数一定，最终结果也就一定。</li>\n<li><p>我们可以通过 DP 的方式寻找最小值。</p></li>\n</ul>\n<p>设计状态。</p>\n<p>不妨考虑让问题麻烦起来的是什么，对于 <span class=\"math inline\">\\(d_i\\)</span> 与 <span class=\"math inline\">\\(d_j\\)</span> 不相邻时的取反，我们无法得知 <span class=\"math inline\">\\(d_i\\)</span> 需要哪一个 <span class=\"math inline\">\\(d_j\\)</span>（而对于 <span class=\"math inline\">\\(d_i\\)</span> 与 <span class=\"math inline\">\\(d_j\\)</span> 相邻的情况，<span class=\"math inline\">\\(d_j\\)</span> 就是 <span class=\"math inline\">\\(d_{i + 1}\\)</span>，位置是确定的）。</p>\n<p>但我们同时也发现，与相邻时的代价不同，不相邻时的操作代价与 <span class=\"math inline\">\\(i\\)</span>，<span class=\"math inline\">\\(j\\)</span> 的具体值无关。</p>\n<p>所以不妨用 <span class=\"math inline\">\\(f_{i,j}\\)</span> 表示，已枚举到 <span class=\"math inline\">\\(d_i\\)</span>，前面有 <span class=\"math inline\">\\(j\\)</span> 个数需要后面 <strong>与它们不相邻的数</strong> 用以和它们配对取反。</p>\n<p>假设已枚举到 <span class=\"math inline\">\\(d_i\\)</span>，当前面有 <span class=\"math inline\">\\(s\\)</span> 个数需要配对时，有以下的情况：</p>\n<ul>\n<li><p>当 <span class=\"math inline\">\\(s = 1\\)</span>，即只有一个数需要配对时：</p>\n<ul>\n<li><p>如果这个数是 <span class=\"math inline\">\\(d_{i - 1}\\)</span>，那么代价为 <span class=\"math inline\">\\(2\\times y\\)</span>。</p>\n注意，这里只枚举了需要不相邻的数来配对的情况，相邻的情况将会另外计算，所以代价不能为 <span class=\"math inline\">\\(x\\)</span>。</li>\n<li>否则，代价为 <span class=\"math inline\">\\(y\\)</span>。</li>\n</ul></li>\n<li><p>当 <span class=\"math inline\">\\(s&gt;1\\)</span> 时，即有多个数需要配对时：</p>\n<p>不管 <span class=\"math inline\">\\(d_{i-1}\\)</span> 是否需要配对，我们都不选它。因为选它的代价是 <span class=\"math inline\">\\(2\\times y\\)</span>，而随便选另一个待配对数的代价都只有 <span class=\"math inline\">\\(y\\)</span>。</p></li>\n</ul>\n<p>那么问题来了，我咋知道它们相不相邻？</p>\n<p>再多开一维 <span class=\"math inline\">\\(0/1\\)</span> 状态，记录最后一个需要与其他后面的元素配对值是否是 <span class=\"math inline\">\\(a_{i-1}\\)</span> 即可。</p>\n<p>假设现在已经枚举到 <span class=\"math inline\">\\(f_{i,j,0/1}\\)</span>，即已枚举完 <span class=\"math inline\">\\(d_i\\)</span>，有 <span class=\"math inline\">\\(j\\)</span> 个元素需要配对。</p>\n<p>则更新 <span class=\"math inline\">\\(d_{i+1}\\)</span> 的状态：</p>\n<ul>\n<li><p>若我们想要让 <span class=\"math inline\">\\(d_{i+1}\\)</span> 与后面的元素配对，则代价至少为 <span class=\"math inline\">\\(y\\)</span>。至于是否会因为待配对元素相邻而额外增加 <span class=\"math inline\">\\(y\\)</span> 的代价，我们在待配对元素处计算。</p>\n<span class=\"math display\">\\[\n f_{i+1,j+1,1}\\gets\\min(f_{i,j,0},f_{i,j,1}) + y\n \\]</span></li>\n<li><p>若我们想要让 <span class=\"math inline\">\\(d_{i+1}\\)</span> 与其相邻的 <span class=\"math inline\">\\(a_{i+2}\\)</span> 匹配，那么 <span class=\"math inline\">\\(d_{i+2}\\)</span> 就不需要再与后面的元素配对了，故最后一维为 <span class=\"math inline\">\\(0\\)</span>。</p>\n<span class=\"math display\">\\[\n f_{i+2,j,0}\\gets\\min(f_{i,j,0},f_{i,j,1})+(d_{i+2}-d_{i+1})\\times x\n \\]</span></li>\n<li><p>如果我们想让 <span class=\"math inline\">\\(d_{i+1}\\)</span> 与前面的待配对元素配对：</p>\n<p>在此种大前提下，<span class=\"math inline\">\\(d_{i+1}\\)</span> 一定不需要与后面的元素配对，故最后一维为 <span class=\"math inline\">\\(0\\)</span>。</p>\n<ul>\n<li><p>当 <span class=\"math inline\">\\(j=1\\)</span> 且 <span class=\"math inline\">\\(d_i+1=d_{i+1}\\)</span> 时，即存在其相邻元素，且只有一个配对可选项时：</p>\n<ul>\n<li>如果这个数是 <span class=\"math inline\">\\(d_{i}\\)</span>，则 <span class=\"math inline\">\\(d_{i+1}\\)</span> 必须与相邻元素配对。</li>\n</ul>\n<p><span class=\"math display\">\\[\n f_{i+1,j-1,0}\\gets f_{i,j,1}+y\n \\]</span></p>\n因为在计算 <span class=\"math inline\">\\(f_{i,j,1}\\)</span> 时已计算了一个 <span class=\"math inline\">\\(y\\)</span>，所以此处只用加一个 <span class=\"math inline\">\\(y\\)</span>。\n<ul>\n<li><p>否则，该元素完成配对，不产生任何代价。</p>\n<span class=\"math display\">\\[\n f_{i+1,j-1,0}\\gets f_{i,j,0}\n \\]</span></li>\n</ul></li>\n<li><p>否则，随意选择前面的一个数。</p>\n<p>因为此时，要么前面有除了相邻元素的其他数可选，要么根本没有相邻元素，所以该数完成配对不会产生任何代价（因为 <span class=\"math inline\">\\(y\\)</span> 已经加过了）。</p>\n<p><span class=\"math display\">\\[\n f_{i+1,j-1,0}\\gets \\min(f_{i,j,0},f_{i,j,1})\n \\]</span></p></li>\n</ul></li>\n</ul>\n<p>至此，全部情况讨论完毕。因为不能让最后一个元素再去与后面的元素配对，最终答案为 <span class=\"math inline\">\\(f_{tot,0,0}\\)</span>，其中 <span class=\"math inline\">\\(tot\\)</span> 为 <span class=\"math inline\">\\(d\\)</span> 数组长度。</p>\n<p>时间复杂度 <span class=\"math inline\">\\(O(n^2)\\)</span>，空间复杂度 <span class=\"math inline\">\\(O(n^2)\\)</span>。</p>\n<p>因为 <span class=\"math inline\">\\(x,y\\le 10^9\\)</span>，最坏情况下需要加 <span class=\"math inline\">\\(\\dfrac n2\\)</span> 次，故需要为 DP 数组开 <code>long long</code>。尽管热心人士 @<a href=\"/user/428358\">cqbztzl</a> 帮助我计算得出使用空间约为 300 兆，但仍然会 MLE。</p>\n<p>不难发现，第一维枚举到 <span class=\"math inline\">\\(i\\)</span> 时，只需要更新第一维为 <span class=\"math inline\">\\(i+1\\)</span> 和 <span class=\"math inline\">\\(i+2\\)</span> 状态的值，而不需要其他任何 DP 值，故将第一维模 <span class=\"math inline\">\\(3\\)</span>，滚动为 <span class=\"math inline\">\\(0\\sim 2\\)</span>。</p>\n<hr />\n<pre class=\"cpp\"><code>// 代码里可能有一些赛时的神秘注释 hhh\nnamespace XSC062 &#123;\nusing namespace fastIO;\nconst ll inf = 1e18;\nconst int maxn = 5e3 + 5;\nll x, y;\nint T, n, tot;\nll f[3][maxn][2];\nint diff[maxn], a[maxn], b[maxn];\nll min(ll x, ll y) &#123;\n    return x &lt; y ? x : y;\n&#125;\nvoid upd(int i, int j, int k, ll y) &#123;\n    f[i % 3][j][k] = min(f[i % 3][j][k], y);\n    return;\n&#125;\nint main() &#123;\n    read(T);\n    while (T--) &#123;\n        read(n), read(x), read(y);\n        tot = 0;\n        for (int i = 1; i &lt;= n; ++i)\n            getnum(a[i]);\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            getnum(b[i]);\n            if (a[i] != b[i])\n                diff[++tot] = i;\n        &#125;\n        if (tot &amp; 1) &#123;\n            puts(&quot;-1&quot;);\n            continue;\n        &#125;\n        memset(f, 0x3f, sizeof (f));\n        f[0][0][0] = 0;\n        for (int i = 0; i &lt;= tot; ++i) &#123;\n            for (int j = 0; j &lt;= i; ++j) &#123;\n                // 新增起点\n                if (i + 1 &lt;= tot) &#123;\n                    upd(i + 1, j + 1, 1,\n                        min(f[i % 3][j][0],\n                            f[i % 3][j][1]) + y);\n                &#125;\n                // 碾过去 \n                if (i + 2 &lt;= tot) &#123;\n                    upd(i + 2, j, 0,\n                        min(f[i % 3][j][0],\n                            f[i % 3][j][1]) +\n                            (diff[i + 2] -\n                            diff[i + 1]) * x);\n                &#125;\n                // 使用起点\n                if (j &gt; 0 &amp;&amp; i + 1 &lt;= tot) &#123;\n                    if (j == 1 &amp;&amp; diff[i] + 1 ==\n                                        diff[i + 1]) &#123;\n                        upd(i + 1, j - 1, 0,\n                                f[i % 3][j][1] + y);\n                        upd(i + 1, j - 1, 0,\n                                f[i % 3][j][0]);\n                    &#125;\n                    else &#123;\n                        upd(i + 1, j - 1, 0,\n                            min(f[i % 3][j][0],\n                                f[i % 3][j][1]));\n                    &#125;\n                &#125;\n                if (i != tot) &#123;\n                    f[i % 3][j][0] =\n                        f[i % 3][j][1] = inf;\n                &#125;\n            &#125;\n        &#125;\n        print(f[tot % 3][0][0], &#39;\\n&#39;);\n    &#125;\n    return 0;\n&#125;\n&#125; // namespace XSC062</code></pre>\n",
            "tags": [
                "DP"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20230111/",
            "url": "https://xsc062.netlify.app/20230111/",
            "title": "瑰丽华尔兹",
            "date_published": "2023-01-10T18:21:35.000Z",
            "content_html": "<p>Solution to<a href=\"http://222.180.160.110:61235/problem/8965\">「NOI2005」瑰丽华尔兹</a>。</p>\n<span id=\"more\"></span>\n<hr />\n<p>单调队列优化 DP。</p>\n<p>不难发现，题意可转化为：</p>\n<p>从 <span class=\"math inline\">\\((x,y)\\)</span> 出发，按顺序向 <span class=\"math inline\">\\(d_i\\)</span> 方向移动 <span class=\"math inline\">\\([0,t_i−s_i+1]\\)</span> 距离，问最大移动距离。</p>\n<p>为了方便描述，我们把一次「向 <span class=\"math inline\">\\(d_i\\)</span> 方向移动 <span class=\"math inline\">\\([0,t_i−s_i+1]\\)</span> 距离」的操作称为「一步」。</p>\n<p>设计状态。不难发现位置信息必须出现在 DP 的维度中（因为当前位置会影响下一步滑动的距离），而其他信息均不会对下一步滑动产生影响。</p>\n<p>故可令 <span class=\"math inline\">\\(f_{i,j}\\)</span> 表示完成当前次滑动后，从起点滑动到 <span class=\"math inline\">\\((i,j)\\)</span> 可得到的最大滑动距离。</p>\n<p>以方向上为例，可列 DP 式：</p>\n<p><span class=\"math display\">\\[\nf_{i,j}=\\max_{i&lt;k≤i+(ti−si+1)}\\{f_{k,j}+k−i\\}\n\\]</span></p>\n<p>此时可枚举每一列的所有状态，使用单调队列优化。</p>\n<p>但实际操作中会出现问题。因为单调队列从下向上更新状态时，<span class=\"math inline\">\\(f_{k,j}\\)</span> 会比 <span class=\"math inline\">\\(f_{i,j}\\)</span> 先更新（参考 01 背包倒序枚举容量），导致每一「步」会重复被走很多次。但单调队列的特性限制了我们只能从下向上枚举，此时可新开一个数组记录 <span class=\"math inline\">\\(f\\)</span> 当次被更新之前的值。</p>\n<p>障碍物如何处理呢？我们知道，如果 <span class=\"math inline\">\\((i,j)\\)</span> 下面某一位置有障碍物，那么障碍物下面所有的 <span class=\"math inline\">\\((k,j)\\)</span> 都不能用于更新 <span class=\"math inline\">\\(f_{i,j}\\)</span>（因为被挡住了滑不上来）。所以我们在从下往上枚举时，遇到障碍物就清空单调队列即可。</p>\n<p>下、左、右方向的处理方式类似。</p>\n<p>只需顺序执行操作，根据当前操作方向对应处理即可。</p>\n<details>\n<pre class=\"cpp\"><code>namespace XSC062 &#123;\nusing namespace fastIO;\nconst int maxn = 205;\nconst int inf = 1e18;\nint q[maxn];\nchar a[maxn][maxn];\nint f[maxn][maxn], d[maxn][maxn];\nint n, m, x, y, k, u, h, t, res;\nint max(int x, int y) &#123;\n    return x &gt; y ? x : y;\n&#125;\nint main() &#123;\n    memset(f, -0x3f, sizeof (f));\n    read(n), read(m);\n    read(x), read(y), read(k);\n    f[x][y] = 0;\n    for (int i = 1; i &lt;= n; ++i)\n        scanf(&quot;%s&quot;, a[i] + 1);\n    while (k--) &#123;\n        read(x), read(y), read(u);\n        y = y - x + 1;\n        if (u == 1) &#123;\n            for (int j = 1; j &lt;= m; ++j) &#123;\n                h = 1, t = 0;\n                for (int i = n; i; --i) &#123;\n                    if (a[i][j] == &#39;x&#39;) &#123;\n                        h = 1, t = 0;\n                        continue;\n                    &#125;\n                    while (h &lt;= t &amp;&amp; q[h] - i &gt; y)\n                        ++h;\n                    d[i][j] = f[i][j];\n                    if (h &lt;= t) &#123;\n                        f[i][j] = max(f[i][j],\n                                    d[q[h]][j] + q[h] - i);\n                    &#125;\n                    while (h &lt;= t &amp;&amp; d[i][j] + i\n                                    &gt;= d[q[t]][j] + q[t])\n                        --t;\n                    q[++t] = i;\n                &#125;\n            &#125;\n        &#125;\n        else if (u == 2) &#123;\n            for (int j = 1; j &lt;= m; ++j) &#123;\n                h = 1, t = 0;\n                for (int i = 1; i &lt;= n; ++i) &#123;\n                    if (a[i][j] == &#39;x&#39;) &#123;\n                        h = 1, t = 0;\n                        continue;\n                    &#125;\n                    while (h &lt;= t &amp;&amp; i - q[h] &gt; y)\n                        ++h;\n                    d[i][j] = f[i][j];\n                    if (h &lt;= t) &#123;\n                        f[i][j] = max(f[i][j],\n                                    d[q[h]][j] + i - q[h]);\n                    &#125;\n                    while (h &lt;= t &amp;&amp; d[i][j] - i\n                                &gt;= d[q[t]][j] - q[t])\n                        --t;\n                    q[++t] = i;\n                &#125;\n            &#125;\n        &#125;\n        else if (u == 3) &#123;\n            for (int i = 1; i &lt;= n; ++i) &#123;\n                h = 1, t = 0;\n                for (int j = m; j; --j) &#123;\n                    if (a[i][j] == &#39;x&#39;) &#123;\n                        h = 1, t = 0;\n                        continue;\n                    &#125;\n                    while (h &lt;= t &amp;&amp; q[h] - j &gt; y)\n                        ++h;\n                    d[i][j] = f[i][j];\n                    if (h &lt;= t) &#123;\n                        f[i][j] = max(f[i][j],\n                                    d[i][q[h]] + q[h] - j);\n                    &#125;\n                    while (h &lt;= t &amp;&amp; d[i][j] + j\n                                &gt;= d[i][q[t]] + q[t])\n                        --t;\n                    q[++t] = j;\n                &#125;\n            &#125;\n        &#125;\n        else &#123;\n            for (int i = 1; i &lt;= n; ++i) &#123;\n                h = 1, t = 0;\n                for (int j = 1; j &lt;= m; ++j) &#123;\n                    if (a[i][j] == &#39;x&#39;) &#123;\n                        h = 1, t = 0;\n                        continue;\n                    &#125;\n                    while (h &lt;= t &amp;&amp; j - q[h] &gt; y)\n                        ++h;\n                    d[i][j] = f[i][j];\n                    if (h &lt;= t) &#123;\n                        f[i][j] = max(f[i][j],\n                                    d[i][q[h]] + j - q[h]);\n                    &#125;\n                    while (h &lt;= t &amp;&amp; d[i][j] - j\n                                &gt;= d[i][q[t]] - q[t])\n                        --t;\n                    q[++t] = j;\n                &#125;\n            &#125;\n        &#125;\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            for (int j = 1; j &lt;= m; ++j)\n                res = max(res, f[i][j]);\n        &#125;\n    &#125;\n    print(res);\n    return 0;\n&#125;\n&#125; // namespace XSC062</code></pre>\n</details>\n",
            "tags": [
                "DP",
                "单调队列"
            ]
        }
    ]
}