<?xml version="1.0"?>
<rss version="2.0">
    <channel>
        <title> • Posts by &#34;tarjan&#34; tag</title>
        <link>https://xsc062.netlify.app</link>
        <description></description>
        <language>zh-CN</language>
        <pubDate>Mon, 13 Nov 2023 15:54:34 +0800</pubDate>
        <lastBuildDate>Mon, 13 Nov 2023 15:54:34 +0800</lastBuildDate>
        <category>并查集</category>
        <category>斜率优化</category>
        <category>悬线法</category>
        <category>哈希</category>
        <category>字典树</category>
        <category>DP</category>
        <category>单调队列</category>
        <category>分治</category>
        <category>二分图</category>
        <category>CRT / exCRT</category>
        <category>排列组合</category>
        <category>网络流</category>
        <category>费用流</category>
        <category>二分</category>
        <category>上下界网络流</category>
        <category>容斥原理</category>
        <category>线段树</category>
        <category>树状数组</category>
        <category>区间 DP</category>
        <category>构造</category>
        <category>Tarjan</category>
        <category>数据结构</category>
        <category>下饭</category>
        <category>LCA</category>
        <category>倍增</category>
        <category>鸽巢原理</category>
        <category>概率期望</category>
        <category>调和级数</category>
        <category>差分</category>
        <category>思维</category>
        <category>树形 DP</category>
        <category>最小生成树</category>
        <category>SAM</category>
        <category>状压</category>
        <category>分块</category>
        <category>可持久化</category>
        <category>笛卡尔树</category>
        <category>高维前缀和</category>
        <category>闲话</category>
        <category>欧拉回路</category>
        <category>树链剖分</category>
        <category>长链剖分</category>
        <category>KMP</category>
        <category>border</category>
        <category>字符串</category>
        <category>AC 自动机</category>
        <category>SA</category>
        <category>数学</category>
        <category>树上差分</category>
        <category>FWT</category>
        <category>堆</category>
        <category>树的重心</category>
        <category>二项式定理</category>
        <category>二项式反演</category>
        <category>贪心</category>
        <category>均摊</category>
        <category>计数</category>
        <category>优化建图</category>
        <category>反悔贪心</category>
        <category>调整法</category>
        <category>背包</category>
        <category>博弈论</category>
        <category>DP 优化</category>
        <category>虚树</category>
        <category>点分治</category>
        <category>WQS 二分</category>
        <category>闵可夫斯基和</category>
        <category>slope trick</category>
        <category>四边形不等式</category>
        <category>暴力</category>
        <category>状压 DP</category>
        <category>组合数学</category>
        <category>支配对</category>
        <category>DDP</category>
        <category>平衡树</category>
        <category>容斥</category>
        <category>猫树</category>
        <category>Kruskal 重构树</category>
        <category>李超线段树</category>
        <item>
            <guid isPermalink="true">https://xsc062.netlify.app/20231113/</guid>
            <title>杂题</title>
            <link>https://xsc062.netlify.app/20231113/</link>
            <category>Tarjan</category>
            <pubDate>Mon, 13 Nov 2023 15:54:34 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;&lt;a href=&#34;http://222.180.160.110:61235/contest/4434&#34;&gt;NOIP S&lt;/a&gt; &amp;amp; &lt;a href=&#34;https://vjudge.net/contest/594162&#34;&gt;计数杂题&lt;/a&gt;。&lt;/p&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;a.-卡门&#34;&gt;A. 卡门&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P6370&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P6370&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://222.180.160.110:61235/contest/4434/problem/1&#34; class=&#34;uri&#34;&gt;http://222.180.160.110:61235/contest/4434/problem/1&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我们惊讶地发现全场没多少人会做绿题。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;就是说呢，我们把它「滚动到相邻行然后落下」的过程直接变成「往左下 / 右下滚」。那么球掉下去的过程呢，就可以理解为它是一直一次往下掉一格的，然后每一次掉落呢，会根据实际情况往左 / 往右 / 直着掉。&lt;/p&gt;
&lt;p&gt;所以我们可以直接用 &lt;span class=&#34;math inline&#34;&gt;\(m\)&lt;/span&gt; 个长度为 &lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt; 的序列，记录从每 &lt;span class=&#34;math inline&#34;&gt;\(1\sim m\)&lt;/span&gt; 列扔下去的情况。然后我们很容易可以知道，如果任意两个序列发生了交汇，那么从交汇点开始至序列结束呢，这两个序列的内容都是完全一样的。因为之前序列长什么样子，完全不会对之后产生影响。所以一旦有任意一个状态是一样的，后面都会是一样的。&lt;/p&gt;
&lt;p&gt;所以呢，一旦我们跟着计划好的路线走，却发现走不动了，那就说明从走不动的位置开始，到原定路线结束，这些位置都会被封掉。所以这个时候我们直接重新计算路线就好了。&lt;/p&gt;
&lt;p&gt;对于这 &lt;span class=&#34;math inline&#34;&gt;\(m\)&lt;/span&gt; 列，就算每一列预定路线上的每个位置都被占了一次，也只会被更改 &lt;span class=&#34;math inline&#34;&gt;\(n\times m\)&lt;/span&gt; 次；总体时间复杂度只有 &lt;span class=&#34;math inline&#34;&gt;\(O(nm^2)\)&lt;/span&gt;。然后又由于不可能跑满，其实是完全没有问题，甚至跑得出溜快的。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;namespace XSC062 &amp;#123;
using namespace fastIO;
const int maxm = 35;
const int maxn = 3e4 + 5;
char a[maxn][maxm];
int n, m, q, u, x, y;
std::vector&amp;lt;int&amp;gt; p[maxm]; 
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    freopen(&amp;quot;kamen.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    freopen(&amp;quot;kamen.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#endif
    scanf(&amp;quot;%d %d&amp;quot;, &amp;amp;n, &amp;amp;m);
    for (int i = 1; i &amp;lt;= n; ++i)
        scanf(&amp;quot;%s&amp;quot;, a[i] + 1);
    for (int i = 1; i &amp;lt;= m; ++i) &amp;#123;
        x = 1, y = i;
        for (;;) &amp;#123;
            p[i].push_back(y); 
            if (a[x + 1][y] == &amp;#39;.&amp;#39;) ++x;
            else &amp;#123;
                if (a[x + 1][y] == &amp;#39;X&amp;#39;) break;
                if (a[x][y - 1] == &amp;#39;.&amp;#39; &amp;amp;&amp;amp; a[x + 1][y - 1] == &amp;#39;.&amp;#39;)
                    ++x, --y;
                else if (a[x][y + 1] == &amp;#39;.&amp;#39; &amp;amp;&amp;amp; a[x + 1][y + 1] == &amp;#39;.&amp;#39;)
                    ++x, ++y;
                else break;
            &amp;#125;
        &amp;#125;
    &amp;#125;
    scanf(&amp;quot;%d&amp;quot;, &amp;amp;q);
    while (q--) &amp;#123;
        scanf(&amp;quot;%d&amp;quot;, &amp;amp;u);
        while (a[p[u].size()][p[u].back()] != &amp;#39;.&amp;#39;)
            p[u].pop_back();
        x = p[u].size(), y = p[u].back();
        for (;;) &amp;#123;
            p[u].push_back(y); 
            if (a[x + 1][y] == &amp;#39;.&amp;#39;) ++x;
            else &amp;#123;
                if (a[x + 1][y] == &amp;#39;X&amp;#39;) break;
                if (a[x][y - 1] == &amp;#39;.&amp;#39; &amp;amp;&amp;amp; a[x + 1][y - 1] == &amp;#39;.&amp;#39;)
                    ++x, --y;
                else if (a[x][y + 1] == &amp;#39;.&amp;#39; &amp;amp;&amp;amp; a[x + 1][y + 1] == &amp;#39;.&amp;#39;)
                    ++x, ++y;
                else break;
            &amp;#125;
        &amp;#125;
        a[x][y] = &amp;#39;O&amp;#39;;
    &amp;#125;
    for (int i = 1; i &amp;lt;= n; ++i) puts(a[i] + 1);
    return 0;
&amp;#125;
&amp;#125; // namespace XSC062&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;b.-商人&#34;&gt;B. 商人&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;http://222.180.160.110:61235/contest/4434/problem/2&#34; class=&#34;uri&#34;&gt;http://222.180.160.110:61235/contest/4434/problem/2&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;首先忽略图中的环带来的问题，假设 &lt;span class=&#34;math inline&#34;&gt;\(f_u\)&lt;/span&gt; 表示从 &lt;span class=&#34;math inline&#34;&gt;\(u\)&lt;/span&gt; 点出发的答案，不难想到 DP 式 &lt;span class=&#34;math inline&#34;&gt;\(f_u = \min\{\max(f_v-p_{(u,v)}, r_{(u,v)})\}\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;那么问题来了，图中是会有环的，不能简单地去更新 DP 值。我们首先考虑「根源」，每一个 &lt;span class=&#34;math inline&#34;&gt;\(f_u\)&lt;/span&gt; 一定都是由另一个 &lt;span class=&#34;math inline&#34;&gt;\(f_v\)&lt;/span&gt; 转移得到的，那么一定会存在一个已知的 &lt;span class=&#34;math inline&#34;&gt;\(f_u\)&lt;/span&gt;，不由其他任何 &lt;span class=&#34;math inline&#34;&gt;\(f_v\)&lt;/span&gt; 得到。&lt;/p&gt;
&lt;p&gt;考虑一个环中 &lt;span class=&#34;math inline&#34;&gt;\(r\)&lt;/span&gt; 最大的一条边 &lt;span class=&#34;math inline&#34;&gt;\((u,v)\)&lt;/span&gt;。假设图中只有这一个环，那么 &lt;span class=&#34;math inline&#34;&gt;\(f_u\)&lt;/span&gt; 的值一定为 &lt;span class=&#34;math inline&#34;&gt;\(r\)&lt;/span&gt;，因为 &lt;span class=&#34;math inline&#34;&gt;\(p\)&lt;/span&gt; 只能为非负。这样「根源」就被我们找到了。接下来进一步考虑转移方法。&lt;/p&gt;
&lt;p&gt;一个点 &lt;span class=&#34;math inline&#34;&gt;\(u\)&lt;/span&gt; 只能被其相连的点 &lt;span class=&#34;math inline&#34;&gt;\(v\)&lt;/span&gt; 更新，那么当且仅当所有 &lt;span class=&#34;math inline&#34;&gt;\(f_v\)&lt;/span&gt; 都是确定的，&lt;span class=&#34;math inline&#34;&gt;\(f_u\)&lt;/span&gt; 才能被确定，进而去更新 &lt;span class=&#34;math inline&#34;&gt;\(u\)&lt;/span&gt; 的前驱。这让我们想到了拓扑排序。如果我们将所有边反向，那么上面的过程几乎就是拓扑排序。&lt;/p&gt;
&lt;p&gt;为了保证任意一个环上的「根源」都能最先被确定，我们按照按 &lt;span class=&#34;math inline&#34;&gt;\(r\)&lt;/span&gt; 从大到小遍历每一条边的方式处理问题。对于每一条边 &lt;span class=&#34;math inline&#34;&gt;\((u,v)\)&lt;/span&gt;，我们都假设它是「根源」并用 &lt;span class=&#34;math inline&#34;&gt;\(r_{(u,v)}\)&lt;/span&gt; 更新 &lt;span class=&#34;math inline&#34;&gt;\(f_u\)&lt;/span&gt;。我们其实并不关心 &lt;span class=&#34;math inline&#34;&gt;\(u\)&lt;/span&gt; 是否是我们刚刚定义的形式上的「根源」，毕竟，只要 &lt;span class=&#34;math inline&#34;&gt;\(f_u\)&lt;/span&gt; 能被 &lt;span class=&#34;math inline&#34;&gt;\(r_{(u,v)}\)&lt;/span&gt; 更新，它就能算作广义上的，&lt;strong&gt;当前时刻的&lt;/strong&gt;「根源」。&lt;/p&gt;
&lt;p&gt;我们在一开始将出度为 &lt;span class=&#34;math inline&#34;&gt;\(0\)&lt;/span&gt;（反图上就是入度为 &lt;span class=&#34;math inline&#34;&gt;\(0\)&lt;/span&gt;）的点全部加入队列，在每次加边的时候进行拓扑排序。每次一条边以任意形式被「使用」后，都要打标记删除并不能再访问，以保证转移的正确性和高效。如果一条边被「使用」，分两种情况：&lt;/p&gt;
&lt;ol type=&#34;1&#34;&gt;
&lt;li&gt;&lt;p&gt;更新「根源」：&lt;/p&gt;
这个时候这条边已经发挥了它的所有作用了，作为 &lt;strong&gt;当前时刻的&lt;/strong&gt;「根源」，这条边的源点在未来至少不会再经由这一条边被更新。故可以删除。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;拓扑排序中转移：&lt;/p&gt;
&lt;p&gt;一个点被加入队列，说明它的 DP 值是确定的，那么就不用拿一个已经确定的值多次更新另一个 DP 值。故可以删除。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;所以正确性是可以保证的。类拓扑排序的结构也保证了算法复杂度 &lt;span class=&#34;math inline&#34;&gt;\(O(n+m)\)&lt;/span&gt;。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#define int long long
namespace XSC062 &amp;#123;
using namespace fastIO;
const int inf = 1e18;
const int maxn = 2e5 + 5;
const int maxm = 2e5 + 5;
struct _ &amp;#123;
    int v, r, p, i;
    _() &amp;#123;&amp;#125;
    _(int v1, int r1, int p1, int i1) &amp;#123;
        v = v1, r = r1, p = p1, i = i1;
    &amp;#125;
&amp;#125;;
struct __ &amp;#123;
    int x, y, r, p;
    bool operator&amp;lt; (const __ &amp;amp;q) const &amp;#123;
        return r &amp;gt; q.r;
    &amp;#125;
&amp;#125;;
__ a[maxm];
bool del[maxn];
std::queue&amp;lt;int&amp;gt; q;
int n, m, x, y, r, p;
std::vector&amp;lt;_&amp;gt; g[maxn];
int f[maxn], deg[maxn];
int max(int x, int y) &amp;#123; return x &amp;gt; y ? x : y; &amp;#125;
int min(int x, int y) &amp;#123; return x &amp;lt; y ? x : y; &amp;#125;
void add(int x, int y, int r, int p, int i) &amp;#123;
    g[x].emplace_back(y, r, p, i);
    return;
&amp;#125;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    freopen(&amp;quot;merchant.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    freopen(&amp;quot;merchant.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#endif
    read(n), read(m);
    std::fill(f + 1, f + n + 1, inf);
    for (int i = 1; i &amp;lt;= m; ++i) &amp;#123;
        read(a[i].x), read(a[i].y);
        read(a[i].r), read(a[i].p);
        ++deg[a[i].x];
    &amp;#125;
    std::sort(a + 1, a + m + 1);
    for (int i = 1; i &amp;lt;= n; ++i)
        if (!deg[i]) q.push(i);
    for (int i = 1; i &amp;lt;= m; ++i)
        add(a[i].y, a[i].x, a[i].r, a[i].p, i);
    for (int i = 1; i &amp;lt;= m; ++i) &amp;#123;
        while (!q.empty()) &amp;#123;
            int t = q.front(); q.pop();
            for (auto j : g[t]) &amp;#123;
                if (del[j.i]) continue;
                del[j.i] = 1;
                if (f[t] != inf)
                    f[j.v] = min(f[j.v], max(f[t] - j.p, j.r));
                if (!--deg[j.v]) q.push(j.v);
            &amp;#125;
        &amp;#125;
        if (!del[i]) &amp;#123;
            del[i] = 1, f[a[i].x] = min(f[a[i].x], a[i].r);
            if (!--deg[a[i].x]) q.push(a[i].x);
        &amp;#125;
    &amp;#125;
    for (int i = 1; i &amp;lt;= n; ++i)
        print(f[i] == inf ? -1 : f[i], &amp;#39; &amp;#39;);
    putchar(&amp;#39;\n&amp;#39;);
    return 0;
&amp;#125;
&amp;#125; // namespace XSC062
#undef int&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;a---gerald-and-giant-chess&#34;&gt;A - Gerald and Giant Chess&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://vjudge.net/contest/594162#problem/A&#34; class=&#34;uri&#34;&gt;https://vjudge.net/contest/594162#problem/A&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这个呢，一道简单的数数题，但是因为我忘了 DP 容斥怎么打了所以自行思考了很久很久很久，还差最后一点点想出来的时候放弃了去抄题解 /cf&lt;/p&gt;
&lt;p&gt;就是，这种「限制通行」的 DP 容斥（名字是我现场起的）类型的数数题有一种通法，就是首先我们只计算非法方案然后减掉。&lt;/p&gt;
&lt;p&gt;那么非法方案怎么算呢？令 &lt;span class=&#34;math inline&#34;&gt;\(f_i\)&lt;/span&gt; 表示一个非法点都不经过，到达 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 这个非法点的方案数，那么有 &lt;span class=&#34;math inline&#34;&gt;\(f_i=calc(s,i)-\sum f_j\times calc(j,i)\)&lt;/span&gt;，其中 &lt;span class=&#34;math inline&#34;&gt;\(s\)&lt;/span&gt; 是起点，&lt;span class=&#34;math inline&#34;&gt;\(calc(j,i)\)&lt;/span&gt; 是从 &lt;span class=&#34;math inline&#34;&gt;\(j\to i\)&lt;/span&gt; 的方案数。这样就能不重不漏地枚举完所有情况了。&lt;/p&gt;
&lt;p&gt;我们把 &lt;span class=&#34;math inline&#34;&gt;\((n,m)\)&lt;/span&gt; 也视作一个非法点然后代入 DP 即可得到答案。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#define int long long
namespace XSC062 &amp;#123;
using namespace fastIO;
const int lim = 3e5;
const int mod = 1e9 + 7;
const int maxk = 2e3 + 5;
const int maxn = 3e5 + 5;
struct _ &amp;#123;
    int x, y;
    bool operator&amp;lt; (const _ &amp;amp;q) const &amp;#123;
        return x == q.x ? y &amp;lt; q.y : x &amp;lt; q.x;
    &amp;#125;
&amp;#125;;
_ a[maxk];
int n, m, k, res; 
int f[maxk], fac[maxn];
int qkp(int x, int y) &amp;#123;
    int res = 1;
    while (y) &amp;#123;
        if (y &amp;amp; 1) (res *= x) %= mod;
        (x *= x) %= mod, y &amp;gt;&amp;gt;= 1;
    &amp;#125;
    return res;
&amp;#125;
int inv(int x) &amp;#123; return qkp(x, mod - 2); &amp;#125;
int A(int n, int m) &amp;#123;
    return fac[n] * inv(fac[n - m]) % mod;
&amp;#125;
int C(int n, int m) &amp;#123;
    return A(n, m) * inv(fac[m]) % mod;
&amp;#125;
int calc(int i, int j) &amp;#123;
    int x = a[j].x - a[i].x + 1,
        y = a[j].y - a[i].y + 1;
    return C(x + y - 2, y - 1);
&amp;#125;
int main() &amp;#123;
    fac[0] = 1;
    for (int i = 1; i &amp;lt;= lim; ++i)
        fac[i] = fac[i - 1] * i % mod;
    bool flag = 0;
    read(n), read(m), read(k);
    for (int i = 1; i &amp;lt;= k; ++i) &amp;#123;
        read(a[i].x), read(a[i].y);
        flag |= (a[i].x == 1 &amp;amp;&amp;amp; a[i].y == 1);
        flag |= (a[i].x == n &amp;amp;&amp;amp; a[i].y == m);
    &amp;#125;
    a[0].x = a[0].y = 1;
    if (flag) &amp;#123; print(0, &amp;#39;\n&amp;#39;); return 0; &amp;#125;
    ++k, a[k].x = n, a[k].y = m;
    std::sort(a + 1, a + k + 1);
    for (int i = 1; i &amp;lt;= k; ++i) &amp;#123;
        f[i] = calc(0, i);
        for (int j = 1; j &amp;lt; i; ++j) &amp;#123;
            if (a[j].x &amp;gt; a[i].x || a[j].y &amp;gt; a[i].y) continue;
            (f[i] -= f[j] * calc(j, i) % mod) %= mod;
        &amp;#125;
    &amp;#125;
    f[k] = (f[k] % mod + mod) % mod;
    print(f[k], &amp;#39;\n&amp;#39;);
    return 0;
&amp;#125;
&amp;#125; // namespace XSC062
#undef int&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
 ]]></description>
        </item>
    </channel>
</rss>
