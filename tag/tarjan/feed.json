{
    "version": "https://jsonfeed.org/version/1",
    "title": "null • All posts by \"tarjan\" tag",
    "description": "",
    "home_page_url": "https://xsc062.netlify.app",
    "items": [
        {
            "id": "https://xsc062.netlify.app/20231113/",
            "url": "https://xsc062.netlify.app/20231113/",
            "title": "杂题",
            "date_published": "2023-11-13T07:54:34.000Z",
            "content_html": "<p><a href=\"https://www.becoder.com.cn/contest/4434\">NOIP S</a> &amp; <a href=\"https://vjudge.net/contest/594162\">计数杂题</a>。</p>\n<span id=\"more\"></span>\n<hr />\n<h3 id=\"a.-卡门\">A. 卡门</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P6370\" class=\"uri\">https://www.luogu.com.cn/problem/P6370</a></p>\n<p><a href=\"https://www.becoder.com.cn/contest/4434/problem/1\" class=\"uri\">https://www.becoder.com.cn/contest/4434/problem/1</a></p>\n<p>我们惊讶地发现全场没多少人会做绿题。</p>\n<hr />\n<p>就是说呢，我们把它「滚动到相邻行然后落下」的过程直接变成「往左下 / 右下滚」。那么球掉下去的过程呢，就可以理解为它是一直一次往下掉一格的，然后每一次掉落呢，会根据实际情况往左 / 往右 / 直着掉。</p>\n<p>所以我们可以直接用 <span class=\"math inline\">\\(m\\)</span> 个长度为 <span class=\"math inline\">\\(n\\)</span> 的序列，记录从每 <span class=\"math inline\">\\(1\\sim m\\)</span> 列扔下去的情况。然后我们很容易可以知道，如果任意两个序列发生了交汇，那么从交汇点开始至序列结束呢，这两个序列的内容都是完全一样的。因为之前序列长什么样子，完全不会对之后产生影响。所以一旦有任意一个状态是一样的，后面都会是一样的。</p>\n<p>所以呢，一旦我们跟着计划好的路线走，却发现走不动了，那就说明从走不动的位置开始，到原定路线结束，这些位置都会被封掉。所以这个时候我们直接重新计算路线就好了。</p>\n<p>对于这 <span class=\"math inline\">\\(m\\)</span> 列，就算每一列预定路线上的每个位置都被占了一次，也只会被更改 <span class=\"math inline\">\\(n\\times m\\)</span> 次；总体时间复杂度只有 <span class=\"math inline\">\\(O(nm^2)\\)</span>。然后又由于不可能跑满，其实是完全没有问题，甚至跑得出溜快的。</p>\n<details>\n<pre class=\"cpp\"><code>namespace XSC062 &#123;\nusing namespace fastIO;\nconst int maxm = 35;\nconst int maxn = 3e4 + 5;\nchar a[maxn][maxm];\nint n, m, q, u, x, y;\nstd::vector&lt;int&gt; p[maxm]; \nint main() &#123;\n#ifdef ONLINE_JUDGE\n    freopen(&quot;kamen.in&quot;, &quot;r&quot;, stdin);\n    freopen(&quot;kamen.out&quot;, &quot;w&quot;, stdout);\n#endif\n    scanf(&quot;%d %d&quot;, &amp;n, &amp;m);\n    for (int i = 1; i &lt;= n; ++i)\n        scanf(&quot;%s&quot;, a[i] + 1);\n    for (int i = 1; i &lt;= m; ++i) &#123;\n        x = 1, y = i;\n        for (;;) &#123;\n            p[i].push_back(y); \n            if (a[x + 1][y] == &#39;.&#39;) ++x;\n            else &#123;\n                if (a[x + 1][y] == &#39;X&#39;) break;\n                if (a[x][y - 1] == &#39;.&#39; &amp;&amp; a[x + 1][y - 1] == &#39;.&#39;)\n                    ++x, --y;\n                else if (a[x][y + 1] == &#39;.&#39; &amp;&amp; a[x + 1][y + 1] == &#39;.&#39;)\n                    ++x, ++y;\n                else break;\n            &#125;\n        &#125;\n    &#125;\n    scanf(&quot;%d&quot;, &amp;q);\n    while (q--) &#123;\n        scanf(&quot;%d&quot;, &amp;u);\n        while (a[p[u].size()][p[u].back()] != &#39;.&#39;)\n            p[u].pop_back();\n        x = p[u].size(), y = p[u].back();\n        for (;;) &#123;\n            p[u].push_back(y); \n            if (a[x + 1][y] == &#39;.&#39;) ++x;\n            else &#123;\n                if (a[x + 1][y] == &#39;X&#39;) break;\n                if (a[x][y - 1] == &#39;.&#39; &amp;&amp; a[x + 1][y - 1] == &#39;.&#39;)\n                    ++x, --y;\n                else if (a[x][y + 1] == &#39;.&#39; &amp;&amp; a[x + 1][y + 1] == &#39;.&#39;)\n                    ++x, ++y;\n                else break;\n            &#125;\n        &#125;\n        a[x][y] = &#39;O&#39;;\n    &#125;\n    for (int i = 1; i &lt;= n; ++i) puts(a[i] + 1);\n    return 0;\n&#125;\n&#125; // namespace XSC062</code></pre>\n</details>\n<hr />\n<h3 id=\"b.-商人\">B. 商人</h3>\n<p><a href=\"https://www.becoder.com.cn/contest/4434/problem/2\" class=\"uri\">https://www.becoder.com.cn/contest/4434/problem/2</a></p>\n<p>首先忽略图中的环带来的问题，假设 <span class=\"math inline\">\\(f_u\\)</span> 表示从 <span class=\"math inline\">\\(u\\)</span> 点出发的答案，不难想到 DP 式 <span class=\"math inline\">\\(f_u = \\min\\{\\max(f_v-p_{(u,v)}, r_{(u,v)})\\}\\)</span>。</p>\n<p>那么问题来了，图中是会有环的，不能简单地去更新 DP 值。我们首先考虑「根源」，每一个 <span class=\"math inline\">\\(f_u\\)</span> 一定都是由另一个 <span class=\"math inline\">\\(f_v\\)</span> 转移得到的，那么一定会存在一个已知的 <span class=\"math inline\">\\(f_u\\)</span>，不由其他任何 <span class=\"math inline\">\\(f_v\\)</span> 得到。</p>\n<p>考虑一个环中 <span class=\"math inline\">\\(r\\)</span> 最大的一条边 <span class=\"math inline\">\\((u,v)\\)</span>。假设图中只有这一个环，那么 <span class=\"math inline\">\\(f_u\\)</span> 的值一定为 <span class=\"math inline\">\\(r\\)</span>，因为 <span class=\"math inline\">\\(p\\)</span> 只能为非负。这样「根源」就被我们找到了。接下来进一步考虑转移方法。</p>\n<p>一个点 <span class=\"math inline\">\\(u\\)</span> 只能被其相连的点 <span class=\"math inline\">\\(v\\)</span> 更新，那么当且仅当所有 <span class=\"math inline\">\\(f_v\\)</span> 都是确定的，<span class=\"math inline\">\\(f_u\\)</span> 才能被确定，进而去更新 <span class=\"math inline\">\\(u\\)</span> 的前驱。这让我们想到了拓扑排序。如果我们将所有边反向，那么上面的过程几乎就是拓扑排序。</p>\n<p>为了保证任意一个环上的「根源」都能最先被确定，我们按照按 <span class=\"math inline\">\\(r\\)</span> 从大到小遍历每一条边的方式处理问题。对于每一条边 <span class=\"math inline\">\\((u,v)\\)</span>，我们都假设它是「根源」并用 <span class=\"math inline\">\\(r_{(u,v)}\\)</span> 更新 <span class=\"math inline\">\\(f_u\\)</span>。我们其实并不关心 <span class=\"math inline\">\\(u\\)</span> 是否是我们刚刚定义的形式上的「根源」，毕竟，只要 <span class=\"math inline\">\\(f_u\\)</span> 能被 <span class=\"math inline\">\\(r_{(u,v)}\\)</span> 更新，它就能算作广义上的，<strong>当前时刻的</strong>「根源」。</p>\n<p>我们在一开始将出度为 <span class=\"math inline\">\\(0\\)</span>（反图上就是入度为 <span class=\"math inline\">\\(0\\)</span>）的点全部加入队列，在每次加边的时候进行拓扑排序。每次一条边以任意形式被「使用」后，都要打标记删除并不能再访问，以保证转移的正确性和高效。如果一条边被「使用」，分两种情况：</p>\n<ol type=\"1\">\n<li><p>更新「根源」：</p>\n这个时候这条边已经发挥了它的所有作用了，作为 <strong>当前时刻的</strong>「根源」，这条边的源点在未来至少不会再经由这一条边被更新。故可以删除。</li>\n<li><p>拓扑排序中转移：</p>\n<p>一个点被加入队列，说明它的 DP 值是确定的，那么就不用拿一个已经确定的值多次更新另一个 DP 值。故可以删除。</p></li>\n</ol>\n<p>所以正确性是可以保证的。类拓扑排序的结构也保证了算法复杂度 <span class=\"math inline\">\\(O(n+m)\\)</span>。</p>\n<details>\n<pre class=\"cpp\"><code>#define int long long\nnamespace XSC062 &#123;\nusing namespace fastIO;\nconst int inf = 1e18;\nconst int maxn = 2e5 + 5;\nconst int maxm = 2e5 + 5;\nstruct _ &#123;\n    int v, r, p, i;\n    _() &#123;&#125;\n    _(int v1, int r1, int p1, int i1) &#123;\n        v = v1, r = r1, p = p1, i = i1;\n    &#125;\n&#125;;\nstruct __ &#123;\n    int x, y, r, p;\n    bool operator&lt; (const __ &amp;q) const &#123;\n        return r &gt; q.r;\n    &#125;\n&#125;;\n__ a[maxm];\nbool del[maxn];\nstd::queue&lt;int&gt; q;\nint n, m, x, y, r, p;\nstd::vector&lt;_&gt; g[maxn];\nint f[maxn], deg[maxn];\nint max(int x, int y) &#123; return x &gt; y ? x : y; &#125;\nint min(int x, int y) &#123; return x &lt; y ? x : y; &#125;\nvoid add(int x, int y, int r, int p, int i) &#123;\n    g[x].emplace_back(y, r, p, i);\n    return;\n&#125;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    freopen(&quot;merchant.in&quot;, &quot;r&quot;, stdin);\n    freopen(&quot;merchant.out&quot;, &quot;w&quot;, stdout);\n#endif\n    read(n), read(m);\n    std::fill(f + 1, f + n + 1, inf);\n    for (int i = 1; i &lt;= m; ++i) &#123;\n        read(a[i].x), read(a[i].y);\n        read(a[i].r), read(a[i].p);\n        ++deg[a[i].x];\n    &#125;\n    std::sort(a + 1, a + m + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        if (!deg[i]) q.push(i);\n    for (int i = 1; i &lt;= m; ++i)\n        add(a[i].y, a[i].x, a[i].r, a[i].p, i);\n    for (int i = 1; i &lt;= m; ++i) &#123;\n        while (!q.empty()) &#123;\n            int t = q.front(); q.pop();\n            for (auto j : g[t]) &#123;\n                if (del[j.i]) continue;\n                del[j.i] = 1;\n                if (f[t] != inf)\n                    f[j.v] = min(f[j.v], max(f[t] - j.p, j.r));\n                if (!--deg[j.v]) q.push(j.v);\n            &#125;\n        &#125;\n        if (!del[i]) &#123;\n            del[i] = 1, f[a[i].x] = min(f[a[i].x], a[i].r);\n            if (!--deg[a[i].x]) q.push(a[i].x);\n        &#125;\n    &#125;\n    for (int i = 1; i &lt;= n; ++i)\n        print(f[i] == inf ? -1 : f[i], &#39; &#39;);\n    putchar(&#39;\\n&#39;);\n    return 0;\n&#125;\n&#125; // namespace XSC062\n#undef int</code></pre>\n</details>\n<hr />\n<h3 id=\"a---gerald-and-giant-chess\">A - Gerald and Giant Chess</h3>\n<p><a href=\"https://vjudge.net/contest/594162#problem/A\" class=\"uri\">https://vjudge.net/contest/594162#problem/A</a></p>\n<p>这个呢，一道简单的数数题，但是因为我忘了 DP 容斥怎么打了所以自行思考了很久很久很久，还差最后一点点想出来的时候放弃了去抄题解 /cf</p>\n<p>就是，这种「限制通行」的 DP 容斥（名字是我现场起的）类型的数数题有一种通法，就是首先我们只计算非法方案然后减掉。</p>\n<p>那么非法方案怎么算呢？令 <span class=\"math inline\">\\(f_i\\)</span> 表示一个非法点都不经过，到达 <span class=\"math inline\">\\(i\\)</span> 这个非法点的方案数，那么有 <span class=\"math inline\">\\(f_i=calc(s,i)-\\sum f_j\\times calc(j,i)\\)</span>，其中 <span class=\"math inline\">\\(s\\)</span> 是起点，<span class=\"math inline\">\\(calc(j,i)\\)</span> 是从 <span class=\"math inline\">\\(j\\to i\\)</span> 的方案数。这样就能不重不漏地枚举完所有情况了。</p>\n<p>我们把 <span class=\"math inline\">\\((n,m)\\)</span> 也视作一个非法点然后代入 DP 即可得到答案。</p>\n<details>\n<pre class=\"cpp\"><code>#define int long long\nnamespace XSC062 &#123;\nusing namespace fastIO;\nconst int lim = 3e5;\nconst int mod = 1e9 + 7;\nconst int maxk = 2e3 + 5;\nconst int maxn = 3e5 + 5;\nstruct _ &#123;\n    int x, y;\n    bool operator&lt; (const _ &amp;q) const &#123;\n        return x == q.x ? y &lt; q.y : x &lt; q.x;\n    &#125;\n&#125;;\n_ a[maxk];\nint n, m, k, res; \nint f[maxk], fac[maxn];\nint qkp(int x, int y) &#123;\n    int res = 1;\n    while (y) &#123;\n        if (y &amp; 1) (res *= x) %= mod;\n        (x *= x) %= mod, y &gt;&gt;= 1;\n    &#125;\n    return res;\n&#125;\nint inv(int x) &#123; return qkp(x, mod - 2); &#125;\nint A(int n, int m) &#123;\n    return fac[n] * inv(fac[n - m]) % mod;\n&#125;\nint C(int n, int m) &#123;\n    return A(n, m) * inv(fac[m]) % mod;\n&#125;\nint calc(int i, int j) &#123;\n    int x = a[j].x - a[i].x + 1,\n        y = a[j].y - a[i].y + 1;\n    return C(x + y - 2, y - 1);\n&#125;\nint main() &#123;\n    fac[0] = 1;\n    for (int i = 1; i &lt;= lim; ++i)\n        fac[i] = fac[i - 1] * i % mod;\n    bool flag = 0;\n    read(n), read(m), read(k);\n    for (int i = 1; i &lt;= k; ++i) &#123;\n        read(a[i].x), read(a[i].y);\n        flag |= (a[i].x == 1 &amp;&amp; a[i].y == 1);\n        flag |= (a[i].x == n &amp;&amp; a[i].y == m);\n    &#125;\n    a[0].x = a[0].y = 1;\n    if (flag) &#123; print(0, &#39;\\n&#39;); return 0; &#125;\n    ++k, a[k].x = n, a[k].y = m;\n    std::sort(a + 1, a + k + 1);\n    for (int i = 1; i &lt;= k; ++i) &#123;\n        f[i] = calc(0, i);\n        for (int j = 1; j &lt; i; ++j) &#123;\n            if (a[j].x &gt; a[i].x || a[j].y &gt; a[i].y) continue;\n            (f[i] -= f[j] * calc(j, i) % mod) %= mod;\n        &#125;\n    &#125;\n    f[k] = (f[k] % mod + mod) % mod;\n    print(f[k], &#39;\\n&#39;);\n    return 0;\n&#125;\n&#125; // namespace XSC062\n#undef int</code></pre>\n</details>\n",
            "tags": [
                "Tarjan"
            ]
        }
    ]
}