{
    "version": "https://jsonfeed.org/version/1",
    "title": "null • All posts by \"调和级数\" tag",
    "description": "",
    "home_page_url": "https://xsc062.netlify.app",
    "items": [
        {
            "id": "https://xsc062.netlify.app/20240131/",
            "url": "https://xsc062.netlify.app/20240131/",
            "title": "USACO2024JAN 三组连打",
            "date_published": "2024-01-31T02:30:29.000Z",
            "content_html": "<p>假的，只连打了两组。Ag 没时间了。日后再补吧。</p>\n<span id=\"more\"></span>\n<p><img src=\"https://pic.imgdb.cn/item/65b7b152871b83018ac5e7b7.gif\" /></p>\n<p>无意中存了题面，但代码大部分因为系统还原消失了，只有文字题解，将就着看吧。</p>\n<hr />\n<h3 id=\"cu-a.-majority-opinion\">Cu A. Majority Opinion</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P10131\" class=\"uri\">https://www.luogu.com.cn/problem/P10131</a></p>\n<p><em>省流：任意区间内，若某元素出现个数严格大于区间长度一半，则可将整个区间推平为该值。问最终可以使整个序列被推平为哪些值。</em></p>\n<p>注意到当任意长度 <span class=\"math inline\">\\(\\ge 2\\)</span> 的区间可以被推平为某种元素时，整个数列都可以被推平为该元素。故目标转化为对于某种元素判定是否存在一个可被其推平的区间。</p>\n<p>统计元素个数采用前缀和。令 <span class=\"math inline\">\\(s_i\\)</span> 表示 <span class=\"math inline\">\\(h_i\\)</span> 在前 <span class=\"math inline\">\\(i\\)</span> 项中出现的次数，假设有 <span class=\"math inline\">\\([j,i]\\)</span> 满足条件，贪心可知 <span class=\"math inline\">\\(h_i=h_j\\)</span>。</p>\n<p>那么由定义有 <span class=\"math inline\">\\(i-j+1&lt;2\\times (s_i-s_j+1)\\)</span>。典中典，直接移项分离变量。则有 <span class=\"math inline\">\\(i-2\\times s_i-1&lt;j-2\\times s_j\\)</span>。令 <span class=\"math inline\">\\(t_p\\gets p-2\\times s_p\\)</span>，对于每个 <span class=\"math inline\">\\(h\\)</span> 记录 <span class=\"math inline\">\\(t_j\\)</span> 最大值查看是否有 <span class=\"math inline\">\\(i,j\\)</span> 满足条件即可。</p>\n<h3 id=\"cu-b.-cannonball\">Cu B. Cannonball</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P10132\" class=\"uri\">https://www.luogu.com.cn/problem/P10132</a></p>\n<p><em>省流：有 <span class=\"math inline\">\\(N\\)</span> 个格子，从 <span class=\"math inline\">\\(s\\)</span> 格子开始以 <span class=\"math inline\">\\(1\\)</span> 为初始能量向右跳，跳一步的距离为能量大小。格子分两种，一种经过加一定能量并反向，另一种若当前能量大于一定值则可永久摧毁，问跳出范围或无限长时间后可摧毁格子个数。</em></p>\n<p>不难发现若忽略增加能量为 <span class=\"math inline\">\\(0\\)</span> 的跳板则每经过一个跳板可跳距离增加 <span class=\"math inline\">\\(1\\)</span>，最多增加到 <span class=\"math inline\">\\(n\\)</span>，否则会跳出去。</p>\n<p>注意到调和级数，故直接模拟跳的过程。唯一导致时间无限的情况是存在相邻的增加能量为 <span class=\"math inline\">\\(0\\)</span> 的跳板，但其实它具体是什么并不重要，反正我们跳的次数严格大于调和级数后就可以认为进入死循环，直接结束模拟即可。我这里嫌麻烦直接拿了 <span class=\"math inline\">\\(2\\times 10^8\\)</span> 作阈值。</p>\n<h3 id=\"cu-c.-balancing-bacteria\">Cu C. Balancing Bacteria</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P10133\" class=\"uri\">https://www.luogu.com.cn/problem/P10133</a></p>\n<p><em>省流：定义一次操作为选取一个整数 <span class=\"math inline\">\\(\\Delta\\le N\\)</span>，并从 <span class=\"math inline\">\\(N\\)</span> 到 <span class=\"math inline\">\\(1\\)</span>，令 <span class=\"math inline\">\\(a_i\\gets a_i+\\Delta\\)</span> 并令 <span class=\"math inline\">\\(\\Delta\\)</span> 向 <span class=\"math inline\">\\(0\\)</span> 靠近 <span class=\"math inline\">\\(1\\)</span>，<span class=\"math inline\">\\(\\Delta=0\\)</span> 时停止。问令所有 <span class=\"math inline\">\\(a_i=0\\)</span> 所需最少操作次数。</em></p>\n<p>挺有意思的思维题，首先需要进行一个思维转化。<span class=\"math inline\">\\(\\Delta\\le N\\)</span> 是一个利于解题的限制，这意味着我们想让任何一个 <span class=\"math inline\">\\(a_i\\)</span> 改变 <span class=\"math inline\">\\(1\\)</span> 而不影响到之前的值，从让 <span class=\"math inline\">\\(a_1\\gets 0\\)</span> 入手，进行一次操作后每个 <span class=\"math inline\">\\(a_i\\)</span> 分到的 <span class=\"math inline\">\\(\\Delta\\)</span> 应依次加 1 或依次减 1。则差分数组为 <span class=\"math inline\">\\(0\\)</span> 后跟着一截 <span class=\"math inline\">\\(1\\)</span> 是理想状态。中间每有一项不满足规律都会带来额外的操作次数。</p>\n<p>归纳为差分数组的差分数组绝对值之和即为答案。</p>\n<hr />\n<h3 id=\"ag-a.-cowmpetency\">Ag A. Cowmpetency</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P10134\" class=\"uri\">https://www.luogu.com.cn/problem/P10134</a></p>\n<p><em>省流：有若干条限制，每条形如 <span class=\"math inline\">\\(\\max\\limits_{i=1}^{a_h-1}\\{A_i\\}=\\max\\limits_{i=1}^{a_j}\\{A_i\\}\\)</span> 且 <span class=\"math inline\">\\(A_{a_h}&gt;\\max\\limits_{i=1}^{a_h-1}\\{A_i\\}\\)</span>，部分数已知，构造出符合条件且字典序最小的序列。</em></p>\n<p>是本场最难题吧，但也没啥卡的。画个线段图容易发现，若将 <span class=\"math inline\">\\([a,h)\\)</span> 视作一条线段，那么除非 <span class=\"math inline\">\\(h\\)</span> 相同，否则两条线段不能有交集。不然的话就无解。以及如果存在不满足条件的定值也显然无解。</p>\n<p>从前往后看每个 <span class=\"math inline\">\\(h\\)</span> 并尝试赋值，对于每个 <span class=\"math inline\">\\(1\\sim a\\)</span> 记录一个需要满足的最大值数值，按照此数值从后往前填空格。</p>\n<p>填完过后扫一遍看看是不是全部合法，可以证明若此时不合法则无解。</p>\n<h3 id=\"ag-b.-potion-farming\">Ag B. Potion Farming</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P10135\" class=\"uri\">https://www.luogu.com.cn/problem/P10135</a></p>\n<p><em>省流：一棵树，每个点上有若干个物品，对于每条从根到叶子的简单路径，可以选择路径上的一个物品，每个物品只能被选一次，问最多可选物品数。</em></p>\n<p>如果一个点引导的子树下所有叶子有没有分配到的，就可以把这个点的物品分配给该叶子。</p>\n<p>跑一个树形 DP 即可。</p>\n<details>\n<pre class=\"cpp\"><code>namespace XSC062 &#123;\nusing namespace fastIO;\nconst int maxn = 1e5 + 5;\nint n, x, y;\nint cnt[maxn];\nstd::vector&lt;int&gt; g[maxn];\nint a[maxn], f[maxn], p[maxn];\nint min(int x, int y) &#123;\n    return x &lt; y ? x : y;\n&#125;\nvoid DFS(int x, int fa) &#123;\n    if ((int)g[x].size() == 1)\n        cnt[x] = 1;\n    for (auto i : g[x]) &#123;\n        if (i == fa) continue;\n        DFS(i, x);\n        f[x] += f[i];\n        cnt[x] += cnt[i];\n    &#125;\n    if (f[x] &lt; cnt[x])\n        f[x] = min(f[x] + a[x], cnt[x]);\n    return;\n&#125;\nvoid add(int x, int y) &#123;\n    g[x].push_back(y);\n    return;\n&#125;\nint main() &#123;\n    read(n);\n    for (int i = 1; i &lt;= n; ++i) read(p[i]);\n    for (int i = 1; i &lt; n; ++i) &#123;\n        read(x), read(y);\n        add(x, y), add(y, x);\n    &#125;\n    int tot = 0;\n    for (int i = 2; i &lt;= n; ++i)\n        tot += ((int)g[i].size() == 1);\n    for (int i = 1; i &lt;= tot; ++i) ++a[p[i]];\n    DFS(1, -1);\n    print(f[1], &#39;\\n&#39;);\n    return 0;\n&#125;\n&#125; // namespace XSC062</code></pre>\n</details>\n<h3 id=\"ag-c.-cowlendar\">Ag C. Cowlendar</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P10136\" class=\"uri\">https://www.luogu.com.cn/problem/P10136</a></p>\n<p><em>省流：对于给定的序列 <span class=\"math inline\">\\(a\\)</span>，找出所有满足 <span class=\"math inline\">\\(a_i\\bmod L\\)</span> 的值的种类最多为 3 的 <span class=\"math inline\">\\(L\\)</span>。</em></p>\n<p>也是挺有意思的数学题了。若将 <span class=\"math inline\">\\(a_i\\)</span> 按照模 <span class=\"math inline\">\\(L\\)</span> 的情况分组，则对于任意一个 <span class=\"math inline\">\\(a_i\\)</span>，在 <span class=\"math inline\">\\((a_i,a_i+L)\\)</span> 中最多包含两个分别来自其余两组的数。</p>\n<p>对于去重后 <span class=\"math inline\">\\(n&gt;3\\)</span> 的情况，由鸽巢得必定有两个数可分为一组。故我们枚举可能的组间间隔，而可能的 <span class=\"math inline\">\\(L\\)</span> 就是这些间隔的因数。</p>\n<p>由上面我们推出一个合法组间间隔中最多间隔三个数，我们将所有 <span class=\"math inline\">\\(a_{i+3}-a_i\\)</span>、<span class=\"math inline\">\\(a_{i+2}-a_i\\)</span> 和 <span class=\"math inline\">\\(a_{i+1}-a_i\\)</span> 纳入考虑范围即可。对于所有可能的 <span class=\"math inline\">\\(L\\)</span>，直接 <span class=\"math inline\">\\(O(n)\\)</span> 跑一个 <code>check</code> 检查是否合法。</p>\n<p>因子个数照理来说是 <span class=\"math inline\">\\(\\sqrt{V}\\times n\\)</span> 级别的，但是实测 <span class=\"math inline\">\\(n\\)</span> 最多只有一百多。估计是因为 <span class=\"math inline\">\\(n\\)</span> 太大就很难构造出更多的合法解吧。</p>\n<details>\n<pre class=\"cpp\"><code>#define int long long\nnamespace XSC062 &#123;\nusing namespace fastIO;\nconst int maxn = 1e4 + 5;\nconst int maxm = 3e4 + 5;\nstd::set&lt;int&gt; u;\nint n, res, mn, tot;\nint a[maxn], b[maxm];\nbool check(int x) &#123;\n    int l1 = 0, l2 = 0, l3 = 0;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        if (l1 == 0) l1 = a[i];\n        else if (x &amp;&amp; (a[i] - l1) % x == 0) l1 = a[i];\n        else if (l2 == 0) l2 = a[i];\n        else if (x &amp;&amp; (a[i] - l2) % x == 0) l2 = a[i];\n        else if (l3 == 0) l3 = a[i];\n        else if (x &amp;&amp; (a[i] - l3) % x == 0) l3 = a[i];\n        else return 0;\n    &#125;\n    return 1;\n&#125;\nint main() &#123;\n    read(n);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        read(a[i]);\n        if (!mn || a[i] / 4 &lt; mn) mn = a[i] / 4;\n    &#125;\n    std::sort(a + 1, a + n + 1);\n    n = std::unique(a + 1, a + n + 1) - a - 1;\n    if (check(0)) &#123;\n        print(mn * (mn + 1) / 2, &#39;\\n&#39;);\n        return 0;\n    &#125;\n    for (int i = 2; i &lt;= n; ++i) &#123;\n        b[++tot] = a[i] - a[i - 1];\n        if (i &gt;= 3) b[++tot] = a[i] - a[i - 2];\n        if (i &gt;= 4) b[++tot] = a[i] - a[i - 3];\n    &#125;\n    std::sort(b + 1, b + tot + 1);\n    tot = std::unique(b + 1, b + tot + 1) - b - 1;\n    for (int i = 1; i &lt;= tot; ++i) &#123;\n        if (check(b[i])) &#123;\n            for (int j = 1; j * j &lt;= b[i]; ++j) &#123;\n                if (b[i] % j == 0)\n                    u.insert(j), u.insert(b[i] / j);\n            &#125;\n        &#125;\n    &#125;\n    for (auto i : u) &#123;\n        if (i &gt; mn) break;\n        res += i;\n    &#125;\n    print(res, &#39;\\n&#39;);\n    return 0;\n&#125;\n&#125; // namespace XSC062\n#undef int</code></pre>\n<p></deteails></p>\n",
            "tags": [
                "鸽巢原理",
                "调和级数",
                "差分",
                "思维",
                "树形 DP"
            ]
        }
    ]
}