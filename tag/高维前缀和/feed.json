{
    "version": "https://jsonfeed.org/version/1",
    "title": "null • All posts by \"高维前缀和\" tag",
    "description": "",
    "home_page_url": "https://xsc062.netlify.app",
    "items": [
        {
            "id": "https://xsc062.netlify.app/20250329/",
            "url": "https://xsc062.netlify.app/20250329/",
            "title": "学习笔记：FWT",
            "date_published": "2025-03-29T07:00:21.000Z",
            "content_html": "<p>活了哥们，复活了。</p>\n<span id=\"more\"></span>\n<hr />\n<p>考虑以下问题：</p>\n<ul>\n<li>对于 <span class=\"math inline\">\\(\\forall \\,i\\in U\\)</span>，求 <span class=\"math inline\">\\(c_i=\\sum\\limits_{j\\cup k=i}a_j\\cdot b_k\\)</span>。</li>\n</ul>\n<p>当然这里可以把集合看成二进制状态，那么取并集就是按位或了。</p>\n<p>咕咕咕</p>\n<hr />\n<h2 id=\"emiya-家明天的饭\">Emiya 家明天的饭</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P10242\" class=\"uri\">https://www.luogu.com.cn/problem/P10242</a></p>\n<p>冷知识：<em>Emiya 家明天的饭</em> 和 <em>Emiya 家今天的饭</em> 拥有相同的难度评级 <img src=\"/em/kt.gif\" alt=\"磕头\" /></p>\n<p>考虑暴力的做法，如果我们先钦定必须到达的人（这是 <span class=\"math inline\">\\(O(2^n)\\)</span> 的），再花费 <span class=\"math inline\">\\(O(nm)\\)</span> 的时间依次判定每道菜是否可以被选择，就可以 解决问题。但发现时间是不能承受的，这里我们选择优化 <span class=\"math inline\">\\(O(nm)\\)</span> 的判定。</p>\n<p>现在已知人员集合 <span class=\"math inline\">\\(s\\)</span>，对于一道菜 <span class=\"math inline\">\\(i\\)</span>，设它适配的人员集合为 <span class=\"math inline\">\\(T_i\\)</span>，那么有 <span class=\"math inline\">\\(s\\subseteq T_i\\)</span>。所求即为 <span class=\"math inline\">\\(\\max\\limits_s\\{\\sum\\limits_{T_i\\supseteq s}\\sum\\limits_{j\\in s}a_{i,j}\\}\\)</span>。<span class=\"math inline\">\\(O(nm)\\)</span> 预处理出 <span class=\"math inline\">\\(f_j(u)=\\sum\\limits_{T_i=u}a_{j, i}\\)</span>，那么待求即为 <span class=\"math inline\">\\(\\max\\limits_{s}\\{\\sum\\limits_{j\\in s}\\sum\\limits_{u\\supseteq s}f_j(u)\\}\\)</span>，发现这个东西可以用 FWT 求。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, m, k;\n    std::cin &gt;&gt; k &gt;&gt; m, n = 1 &lt;&lt; k;\n    using arr = std::vector&lt;long long&gt;;\n    std::vector&lt;int&gt; t(m + 1);\n    std::vector&lt;arr&gt; a(k + 1, arr(m + 1)), f(k + 1, arr(n));\n    for (int i = 1; i &lt;= k; ++i)\n        for (int j = 1; j &lt;= m; ++j) &#123;\n            std::cin &gt;&gt; a[i][j];\n            if (a[i][j] &gt;= 0)\n                t[j] |= 1 &lt;&lt; (i - 1);\n        &#125;\n    for (int i = 1; i &lt;= k; ++i)\n        for (int j = 1; j &lt;= m; ++j)\n            if (a[i][j] &gt;= 0)\n                f[i][t[j]] += a[i][j];\n    &#123;\n        std::vector&lt;arr&gt; mT(2, arr(2));\n        mT[0][0] = 1ll, mT[0][1] = 1ll, mT[1][0] = 0ll, mT[1][1] = 1ll;\n        auto calc = [&amp;](arr a, arr &amp;f, std::vector&lt;arr&gt; &amp;w) &#123;\n            f = a;\n            for (int len = 2; len &lt;= n; len &lt;&lt;= 1) &#123;\n                for (int i = 0; i &lt; n; i += len)\n                    for (int p = i, q = i + len / 2; q &lt; i + len; ++p, ++q)\n                        std::tie(f[p], f[q]) = std::make_tuple(f[p] * w[0][0] + f[q] * w[0][1], f[p] * w[1][0] + f[q] * w[1][1]);\n            &#125;\n            return;\n        &#125;;\n        for (int i = 1; i &lt;= k; ++i)\n            calc(f[i], f[i], mT);\n    &#125;\n    long long res = 0ll;\n    for (int s = 0; s &lt; n; ++s) &#123;\n        long long sum = 0ll;\n        for (int i = 1; i &lt;= k; ++i)\n            if ((s &gt;&gt; (i - 1)) &amp; 1)\n                sum += f[i][s];\n        res = std::max(res, sum);\n    &#125;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"nim-counting\">Nim Counting</h2>\n<p><a href=\"https://atcoder.jp/contests/abc212/tasks/abc212_h\" class=\"uri\">https://atcoder.jp/contests/abc212/tasks/abc212_h</a></p>\n<p>即，从 <span class=\"math inline\">\\(A_N\\)</span> 中有放回地选择 <span class=\"math inline\">\\(\\le M\\)</span> 个数，问它们异或起来不为 <span class=\"math inline\">\\(0\\)</span> 的方案数。</p>\n<p>如果令 <span class=\"math inline\">\\(f_{i, j}\\)</span> 表示选了 <span class=\"math inline\">\\(i\\)</span> 次，异或和为 <span class=\"math inline\">\\(j\\)</span> 的方案数，显然 <span class=\"math inline\">\\(f_{1,i}=\\sum [a_j=i]\\)</span> 为关于 <span class=\"math inline\">\\(a\\)</span> 的桶。此时有 <span class=\"math inline\">\\(f_{i,j}=\\sum\\limits_{k=1}^n f_{i-1,j\\oplus a_k}=\\sum\\limits_{k=0}^V f_{i-1,j\\oplus k}\\cdot f_{1,k}\\)</span>，发现把 <span class=\"math inline\">\\(f_1\\)</span> 这个桶在 <span class=\"math inline\">\\(f\\)</span> 上做 <span class=\"math inline\">\\(N\\)</span> 次 xor-FWT 就可以得到 <span class=\"math inline\">\\(f_n\\)</span>。</p>\n<p>但如果直接卷 <span class=\"math inline\">\\(N\\)</span> 次是 <span class=\"math inline\">\\(O(N\\cdot V\\log V)\\)</span> 的，不太美好，但我们看看我们实际上需要做什么：</p>\n<ol type=\"1\">\n<li>求 <span class=\"math inline\">\\(f_i\\)</span> 的 FWT。</li>\n<li>求初始桶 <span class=\"math inline\">\\(f_1\\)</span> 的 FWT。</li>\n<li>对位相乘得到 <span class=\"math inline\">\\(f_{i+1}\\)</span> 的 FWT。</li>\n<li>通过 FWT 求得原本的 <span class=\"math inline\">\\(f_{i+1}\\)</span>。</li>\n</ol>\n<p>当这个操作被放在 <span class=\"math inline\">\\(i=1\\sim n\\)</span> 上依次进行时，我们发现第一步和最后一步会相互抵消，我们只需要求出 <span class=\"math inline\">\\(f_1\\)</span> 的 FWT，<span class=\"math inline\">\\(FWT_{i, j}(f)\\)</span> 即为 <span class=\"math inline\">\\(FWT_{1, j}(f)^i\\)</span>。因为我们要求的是 <span class=\"math inline\">\\(\\sum\\limits_{i, j}f_{i,j}\\)</span> 可以通过等比数列求和求出 <span class=\"math inline\">\\(FWT_j(s)=\\sum f_{i, j}\\)</span>。由前文推导可知直接做一次逆变换求得 <span class=\"math inline\">\\(s_j\\)</span> 即可。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    struct mint &#123;\n        const int mod = 998244353;\n        long long x;\n        mint(): x(0ll) &#123;&#125;\n        mint(long long x1): x((x1 + mod) % mod) &#123;&#125;\n        mint&amp; operator= (const mint q) &#123;\n            x = q.x;\n            return *this;\n        &#125;\n        bool operator== (const mint q) const &#123;\n            return x == q.x;\n        &#125;\n        mint operator* (const mint q) const &#123;\n            return x * q.x % mod;\n        &#125;\n        mint&amp; operator*= (const mint q) &#123;\n            return *this = *this * q;\n        &#125;\n        mint operator+ (const mint q) &#123;\n            return (x + q.x) % mod;\n        &#125;\n        mint&amp; operator+= (const mint q) &#123;\n            return *this = *this + q;\n        &#125;\n        mint operator- (const mint q) &#123;\n            return (x + mod - q.x) % mod;\n        &#125;\n        mint qkp(int y) &#123;\n            mint res(1ll), x(this-&gt;x);\n            for (; y; y &gt;&gt;= 1, x *= x)\n                if (y &amp; 1)\n                    res *= x;\n            return res;\n        &#125;\n        mint inv(void) &#123;\n            return qkp(mod - 2);\n        &#125;\n    &#125;;\n    int n, m, k = 16, l = 1 &lt;&lt; k;\n    std::cin &gt;&gt; m &gt;&gt; n;\n    using arr = std::vector&lt;mint&gt;;\n    arr a(n + 1), c(l);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i].x, c[a[i].x] += 1;\n    std::vector&lt;arr&gt; mT(2, arr(2)), mI(2, arr(2));\n    mT[0][0] = 1ll, mT[0][1] = 1ll, mT[1][0] = 1ll, mT[1][1] = -1ll;\n    mI[0][0] = mI[0][1] = mI[1][0] = mint(2ll).inv(), mI[1][1] = mint(-2ll).inv();\n    auto calc = [&amp;](arr a, arr &amp;f, std::vector&lt;arr&gt; &amp;w) &#123;\n        f = a;\n        for (int len = 2; len &lt;= l; len &lt;&lt;= 1)\n            for (int i = 0; i &lt; l; i += len)\n                for (int p = i, q = i + len / 2; q &lt; i + len; ++p, ++q)\n                    std::tie(f[p], f[q]) = std::make_tuple(f[p] * w[0][0] + f[q] * w[0][1], f[p] * w[1][0] + f[q] * w[1][1]);\n        return;\n    &#125;;\n    calc(c, c, mT);\n    arr s(l);\n    for (int i = 0; i &lt; l; ++i)\n        if (c[i] == 1ll)\n            s[i] = m;\n        else\n            s[i] = c[i] * (mint(1ll) - c[i].qkp(m)) * (mint(1ll) - c[i]).inv();\n    calc(s, s, mI);\n    mint res;\n    for (int i = 1; i &lt; l; ++i)\n        res += s[i];\n    std::cout &lt;&lt; res.x &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"binary-table\">Binary Table</h2>\n<p><a href=\"https://codeforces.com/problemset/problem/662/C\" class=\"uri\">https://codeforces.com/problemset/problem/662/C</a></p>\n<p>发现这个题和 <em>Emiya 家今天的饭</em> 很像，都是有一个很小的维和一个相对比较大的维。</p>\n<p>显然，我们所有的操作顺序都可以任意调换；朴素地，我们枚举 <span class=\"math inline\">\\(2^n\\)</span> 种给这 <span class=\"math inline\">\\(n\\)</span> 行反转的情况；再对于每一列，<span class=\"math inline\">\\(O(n)\\)</span> 选择应该反转还是不反转，这样总共是 <span class=\"math inline\">\\(O(2^n\\cdot nm)\\)</span> 的。</p>\n<p>发现把一列初始状态压成一个二进制数 <span class=\"math inline\">\\(a\\)</span>，假设我们现在枚举的行反转状态为 <span class=\"math inline\">\\(s\\)</span>，显然用 <span class=\"math inline\">\\(s\\oplus a\\)</span> 可以得到当前状态。怎么利用这个去 FWT 呢？这引导我们依然枚举 <span class=\"math inline\">\\(s\\)</span>，用一个和 <span class=\"math inline\">\\(s\\oplus a\\)</span> 有关的量跟一个和 <span class=\"math inline\">\\(a\\)</span> 有关的量相乘得到关于 <span class=\"math inline\">\\(s\\)</span> 的答案。</p>\n<p>容易发现令 <span class=\"math inline\">\\(f_{s\\oplus a}\\)</span> 表示 <span class=\"math inline\">\\(s\\oplus a\\)</span> 这个状态反转和不反转两个选项中可以获取的最少 1 的个数；再令 <span class=\"math inline\">\\(c_s\\)</span> 表示状态为 <span class=\"math inline\">\\(s\\)</span> 的列的个数，那么 <span class=\"math inline\">\\(\\sum\\limits_s c_s\\times f_{s\\oplus a}\\)</span> 就可以得到枚举的反转方案为 <span class=\"math inline\">\\(s\\)</span> 的答案，求最小即可。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    struct mint &#123;\n        const int mod = 998244353;\n        long long x;\n        mint(): x(0ll) &#123;&#125;\n        mint(long long x1): x((x1 + mod) % mod) &#123;&#125;\n        mint&amp; operator= (const mint q) &#123;\n            x = q.x;\n            return *this;\n        &#125;\n        bool operator== (const mint q) const &#123;\n            return x == q.x;\n        &#125;\n        mint operator* (const mint q) const &#123;\n            return x * q.x % mod;\n        &#125;\n        mint&amp; operator*= (const mint q) &#123;\n            return *this = *this * q;\n        &#125;\n        mint operator+ (const mint q) &#123;\n            return (x + q.x) % mod;\n        &#125;\n        mint&amp; operator+= (const mint q) &#123;\n            return *this = *this + q;\n        &#125;\n        mint operator- (const mint q) &#123;\n            return (x + mod - q.x) % mod;\n        &#125;\n        mint qkp(int y) &#123;\n            mint res(1ll), x(this-&gt;x);\n            for (; y; y &gt;&gt;= 1, x *= x)\n                if (y &amp; 1)\n                    res *= x;\n            return res;\n        &#125;\n        mint inv(void) &#123;\n            return qkp(mod - 2);\n        &#125;\n    &#125;;\n    int n, m, l;\n    std::cin &gt;&gt; n &gt;&gt; m, l = 1 &lt;&lt; n;\n    using arr = std::vector&lt;mint&gt;;\n    arr c(l), f(l);\n    std::vector&lt;std::vector&lt;char&gt; &gt; a(n + 1, std::vector&lt;char&gt; (m + 1));\n    for (int i = 1; i &lt;= n; ++i)\n        for (int j = 1; j &lt;= m; ++j)\n            std::cin &gt;&gt; a[i][j];\n    for (int j = 1; j &lt;= m; ++j) &#123;\n        int s = 0;\n        for (int i = 1; i &lt;= n; ++i)\n            s = (s &lt;&lt; 1) + a[i][j] - &#39;0&#39;;\n        c[s] += 1;\n    &#125;\n    for (int i = 0, t; i &lt; l; ++i)\n        t = (__builtin_popcount(i)), f[i] = std::min(t, n - t);\n    std::vector&lt;arr&gt; mT(2, arr(2)), mI(2, arr(2));\n    mT[0][0] = 1ll, mT[0][1] = 1ll, mT[1][0] = 1ll, mT[1][1] = -1ll;\n    mI[0][0] = mI[0][1] = mI[1][0] = mint(2ll).inv(), mI[1][1] = mint(-2ll).inv();\n    auto calc = [&amp;](arr a, arr &amp;f, std::vector&lt;arr&gt; &amp;w) &#123;\n        f = a;\n        for (int len = 2; len &lt;= l; len &lt;&lt;= 1)\n            for (int i = 0; i &lt; l; i += len)\n                for (int p = i, q = i + len / 2; q &lt; i + len; ++p, ++q)\n                    std::tie(f[p], f[q]) = std::make_tuple(f[p] * w[0][0] + f[q] * w[0][1], f[p] * w[1][0] + f[q] * w[1][1]);\n        return;\n    &#125;;\n    calc(c, c, mT), calc(f, f, mT);\n    arr s(l);\n    for (int i = 0; i &lt; l; ++i)\n        s[i] = c[i] * f[i];\n    calc(s, s, mI);\n    int res = 0x3f3f3f3f;\n    for (int i = 0; i &lt; l; ++i)\n        res = std::min(res, (int)s[i].x);\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"hard-nim\">Hard Nim</h2>\n<p><a href=\"https://hydro.ac/p/bzoj-P4589\" class=\"uri\">https://hydro.ac/p/bzoj-P4589</a></p>\n<p><em>Nim Counting</em> 然后缝了个筛子。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 1e9 + 7;\nconst int inv2 = 5e8 + 4;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    std::vector&lt;int&gt; p, tag(50001);\n    for (int i = 2; i &lt;= 50000; ++i)\n        if (!tag[i]) &#123;\n            p.push_back(i);\n            for (int j = 2 * i; j &lt;= 50000; j += i)\n                tag[j] = 1;\n        &#125;\n    auto qkp = [&amp;](long long x, int y) &#123;\n        long long res = 1ll;\n        for (; y; y &gt;&gt;= 1, (x *= x) %= mod)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    for (int n, m; std::cin &gt;&gt; n &gt;&gt; m; ) &#123;\n        int k = std::__lg(m) + 1, l = 1 &lt;&lt; k;\n        using arr = std::vector&lt;long long&gt;;\n        arr c(l);\n        for (auto i : p)\n            if (i &lt;= m)\n                c[i] += 1;\n            else\n                break;\n        std::vector&lt;arr&gt; mT(2, arr(2)), mI(2, arr(2));\n        mT[0][0] = 1ll, mT[0][1] = 1ll, mT[1][0] = 1ll, mT[1][1] = mod - 1ll;\n        mI[0][0] = mI[0][1] = mI[1][0] = inv2, mI[1][1] = mod - inv2;\n        auto calc = [&amp;](arr &amp;f, std::vector&lt;arr&gt; &amp;w) &#123;\n            for (int len = 2; len &lt;= l; len &lt;&lt;= 1)\n                for (int i = 0; i &lt; l; i += len)\n                    for (int p = i, q = i + len / 2; q &lt; i + len; ++p, ++q)\n                        std::tie(f[p], f[q]) = std::make_tuple((f[p] * w[0][0] + f[q] * w[0][1]) % mod, (f[p] * w[1][0] + f[q] * w[1][1]) % mod);\n            return;\n        &#125;;\n        calc(c, mT);\n        arr s(l);\n        for (int i = 0; i &lt; l; ++i)\n            s[i] = qkp(c[i], n);\n        calc(s, mI);\n        std::cout &lt;&lt; s[0] &lt;&lt; &#39;\\n&#39;;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"子集卷积\">子集卷积</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P6097\" class=\"uri\">https://www.luogu.com.cn/problem/P6097</a></p>\n<p>这个是在许多 DP 中都可能见到过的结构，相信大家都深有体会。</p>\n<p>等价于求 <span class=\"math inline\">\\(c_s=\\sum\\limits_{i\\cap j=\\varnothing\\land i\\cup j=s}a_i\\cdot b_j\\)</span>，首先关注 <span class=\"math inline\">\\(i\\cup j=s\\)</span>，可以用 FWT 解决；对于 <span class=\"math inline\">\\(i\\cap j = \\varnothing\\)</span> 呢？</p>\n<p>有一个很聪明的办法，我们发现 <span class=\"math inline\">\\(i\\cap j=\\varnothing\\land i\\cup j = s\\iff \\operatorname{ctz}(i)+\\operatorname{ctz}(j)=\\operatorname{ctz}(s)\\)</span>，其中 <span class=\"math inline\">\\(\\operatorname{ctz}(i)\\)</span> 表示 <span class=\"math inline\">\\(i\\)</span> 中 <span class=\"math inline\">\\(1\\)</span> 的个数，即 <code>popcount(i)</code>。</p>\n<p>显然后者是个简单的加法运算，这里又有一个很聪明又很基本的办法，我们令 <span class=\"math inline\">\\(A_{\\operatorname{ctz}(i),i}=a_i,B_{\\operatorname{ctz}(j),j}=b_j\\)</span>，那么答案就转化为 <span class=\"math inline\">\\(\\sum\\limits_{i}\\sum\\limits_{j\\cup k=s}A_{i,j}\\cdot B_{\\operatorname{ctz}(s)-i,j}\\)</span>，就可以 <span class=\"math inline\">\\(O(n\\log^2n)\\)</span> 地解决问题了。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 1e9 + 9;\nusing arr = std::vector&lt;long long&gt;;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    int l = 1 &lt;&lt; n;\n    std::vector&lt;arr&gt; a(n + 1, arr(l)), b(n + 1, arr(l)), c(n + 1, arr(l));\n    for (int i = 0, x; i &lt; l; ++i)\n        std::cin &gt;&gt; x, a[__builtin_popcount(i)][i] = x;\n    for (int i = 0, x; i &lt; l; ++i)\n        std::cin &gt;&gt; x, b[__builtin_popcount(i)][i] = x;\n    std::vector&lt;arr&gt; mT(2, arr(2)), mI(2, arr(2));\n    mT[0][0] = 1ll, mT[0][1] = 0ll, mT[1][0] = 1ll, mT[1][1] = 1ll;\n    mI[0][0] = 1ll, mI[0][1] = 0ll, mI[1][0] = mod - 1ll, mI[1][1] = 1ll;\n    auto calc = [&amp;](arr &amp;f, std::vector&lt;arr&gt; &amp;w) &#123;\n        for (int len = 2; len &lt;= l; len &lt;&lt;= 1)\n            for (int i = 0; i &lt; l; i += len)\n                for (int p = i, q = i + len / 2; q &lt; i + len; ++p, ++q)\n                    std::tie(f[p], f[q]) = std::make_tuple((f[p] * w[0][0] + f[q] * w[0][1]) % mod, (f[p] * w[1][0] + f[q] * w[1][1]) % mod);\n        return;\n    &#125;;\n    for (int i = 0; i &lt;= n; ++i)\n        calc(a[i], mT), calc(b[i], mT);\n    for (int i = 0; i &lt;= n; ++i) &#123;\n        for (int k = 0; k &lt;= i; ++k)\n            for (int j = 0; j &lt; l; ++j)\n                (c[i][j] += a[k][j] * b[i - k][j]) %= mod;\n        calc(c[i], mI);\n    &#125;\n    for (int j = 0; j &lt; l; ++j)\n        std::cout &lt;&lt; c[__builtin_popcount(j)][j] &lt;&lt; &#39; &#39;;\n    std::cout &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"州区划分\">州区划分</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P4221\" class=\"uri\">https://www.luogu.com.cn/problem/P4221</a></p>\n<p>人话：把 <span class=\"math inline\">\\(n\\)</span> 个点划分成若干个点集，保证每个点集的导出子图不是欧拉回路（每个点的度数为偶且图连通）。</p>\n<p>那么枚举每一个点集判定是否合法，再令 <span class=\"math inline\">\\(f_{i}={w_i}^{-p}\\times\\sum\\limits_{j\\cup k = i\\land j\\cap k=\\varnothing}f_{j}\\times {w_k}^p\\)</span>。</p>\n<p>发现后面那个 sigma 里面是一个简单的子集卷积；但是我们发现前面有一个和 <span class=\"math inline\">\\(i\\)</span> 有关的常数，导致没办法直接卷 <span class=\"math inline\">\\(n\\)</span> 次。</p>\n<p>但我们发现这个 DP 其实是有一定隐含条件的——都是按照 <span class=\"math inline\">\\(\\text{ctz}\\)</span> 从小到大转移。考虑子集卷积的第一维，得到 <span class=\"math inline\">\\(FWT_{f_i}\\)</span> 后先 IFWT 回来，乘上 <span class=\"math inline\">\\({w_i}^{-p}\\)</span>，再 FWT 回去即可。考察子集卷积的结构，发现这个是可以想办法套进去的。</p>\n<p>复杂度 <a href=\"https://atcoder.jp/contests/abc400/tasks/abc400_c\"><span class=\"math inline\">\\(O(n^2\\cdot 2^n)\\)</span></a>。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 998244353;\nusing arr = std::vector&lt;long long&gt;;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, m, p;\n    std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; p;\n    int l = 1 &lt;&lt; n;\n    auto qkp = [&amp;](long long x, int y = mod - 2) &#123;\n        auto res = 1ll;\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    arr w(n), inv(l);\n    std::vector&lt;arr&gt; f(n + 1, arr(l)), s(n + 1, arr(l));\n    std::vector&lt;std::vector&lt;int&gt; &gt; g(n);\n    for (int x, y; m--; ) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y, --x, --y;\n        g[x].push_back(y);\n    &#125;\n    auto check = [&amp;](int s) &#123;\n        std::vector&lt;int&gt; f(n), deg(n);\n        std::iota(f.begin(), f.end(), 0);\n        std::function&lt;int(int)&gt; find = [&amp;](int x) &#123;\n            return x == f[x] ? x : f[x] = find(f[x]);\n        &#125;;\n        auto merge = [&amp;](int x, int y) &#123;\n            f[find(x)] = find(y);\n            return;\n        &#125;;\n        for (int i = 0; i &lt; n; ++i)\n            if ((s &gt;&gt; i) &amp; 1)\n                for (auto j : g[i])\n                    if ((s &gt;&gt; j) &amp; 1)\n                        merge(i, j), ++deg[i], ++deg[j];\n        int fa = -1;\n        for (int i = 0; i &lt; n; ++i)\n            if ((s &gt;&gt; i) &amp; 1) &#123;\n                if (deg[i] &amp; 1)\n                    return 1;\n                if (fa == -1 || fa == find(i))\n                    fa = find(i);\n                else\n                    return 1;\n            &#125;\n        return 0;\n    &#125;;\n    for (int i = 0; i &lt; n; ++i)\n        std::cin &gt;&gt; w[i];\n    for (int i = 0; i &lt; l; ++i) &#123;\n        int ctz = __builtin_popcount(i);\n        for (int j = 0; j &lt; n; ++j)\n            if ((i &gt;&gt; j) &amp; 1) \n                s[ctz][i] += w[j];\n        s[ctz][i] = qkp(s[ctz][i], p);\n        inv[i] = qkp(s[ctz][i]);\n        if (!check(i))\n            s[ctz][i] = 0ll;\n    &#125;\n    std::vector&lt;arr&gt; mT(2, arr(2)), mI(2, arr(2));\n    mT[0][0] = 1ll, mT[0][1] = 0ll, mT[1][0] = 1ll, mT[1][1] = 1ll;\n    mI[0][0] = 1ll, mI[0][1] = 0ll, mI[1][0] = mod - 1ll, mI[1][1] = 1ll;\n    auto calc = [&amp;](arr &amp;f, std::vector&lt;arr&gt; &amp;w) &#123;\n        for (int len = 2; len &lt;= l; len &lt;&lt;= 1)\n            for (int i = 0; i &lt; l; i += len)\n                for (int p = i, q = i + len / 2; q &lt; i + len; ++p, ++q)\n                    std::tie(f[p], f[q]) = std::make_tuple((f[p] * w[0][0] + f[q] * w[0][1]) % mod, (f[p] * w[1][0] + f[q] * w[1][1]) % mod);\n        return;\n    &#125;;\n    f[0][0] = 1ll;\n    for (int i = 0; i &lt;= n; ++i)\n        calc(s[i], mT);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        calc(f[i - 1], mT);\n        for (int k = 0; k &lt; i; ++k)\n            for (int j = 0; j &lt; l; ++j)\n                (f[i][j] += f[k][j] * s[i - k][j]) %= mod;\n        calc(f[i], mI);\n        for (int j = 0; j &lt; l; ++j)\n            (f[i][j] *= inv[j]) %= mod;\n    &#125;\n    std::cout &lt;&lt; f[n][l - 1] &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"b---sum-the-fibonacci\">B - Sum the Fibonacci</h2>\n<p><a href=\"https://codeforces.com/problemset/problem/914/G\" class=\"uri\">https://codeforces.com/problemset/problem/914/G</a></p>\n<p>首先，对于每个元素的 <span class=\"math inline\">\\(cnt\\)</span> 是好做的——做一次子集卷积得到 <span class=\"math inline\">\\(cnt_1(a\\cup b)\\)</span>，做一次 xor-FWT 得到 <span class=\"math inline\">\\(cnt_2(d\\oplus e)\\)</span>，中间的 <span class=\"math inline\">\\(cnt(c)\\)</span> 就是原样。</p>\n<p>值得注意的是可以在一次 and-FWT 后把 <span class=\"math inline\">\\(cnt,cnt_1,cnt_2\\)</span> 直接卷起来——由矩阵乘法结合律得（哈哈大笑了）。但怎么把 <span class=\"math inline\">\\(f\\)</span> 塞进去呢？如果你拥有小学生的数学水平，你可以很容易地想到直接在 <span class=\"math inline\">\\(cnt,cnt_1,cnt_2\\)</span> IFWT 后的结果分别对位乘上 <span class=\"math inline\">\\(f\\)</span> 即可，很可惜我并没有这样的数学能力 <img src=\"/em/kt.gif\" /></p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int N = 17;\nconst int mod = 1e9 + 7;\nusing arr = std::vector&lt;long long&gt;;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, l;\n    std::cin &gt;&gt; n, l = 1 &lt;&lt; N;\n    std::vector&lt;int&gt; a(n + 1);\n    arr f(l), cnt(l), cnt1(l), cnt2(l);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i], ++cnt[a[i]];\n    f[0] = 0ll, f[1] = 1ll;\n    for (int i = 2; i &lt; l; ++i)\n        f[i] = (f[i - 1] + f[i - 2]) % mod;\n    auto qkp = [&amp;](long long x, int y = mod - 2) &#123;\n        auto res = 1ll;\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    const int inv2 = qkp(2ll);\n    std::vector&lt;arr&gt; mT(2, arr(2)), mI(2, arr(2));\n    auto calc = [&amp;](arr a, arr &amp;f, std::vector&lt;arr&gt; &amp;w) &#123;\n        f = a;\n        for (int len = 2; len &lt;= l; len &lt;&lt;= 1)\n            for (int i = 0; i &lt; l; i += len)\n                for (int p = i, q = i + len / 2; q &lt; i + len; ++p, ++q)\n                    std::tie(f[p], f[q]) = std::make_tuple((f[p] * w[0][0] + f[q] * w[0][1]) % mod, (f[p] * w[1][0] + f[q] * w[1][1]) % mod);\n        return;\n    &#125;;\n    &#123; // orFWT\n        mT[0][0] = 1ll, mT[0][1] = 0ll, mT[1][0] = 1ll, mT[1][1] = 1ll;\n        mI[0][0] = 1ll, mI[0][1] = 0ll, mI[1][0] = mod - 1ll, mI[1][1] = 1ll;\n        std::vector&lt;arr&gt; u(N + 1, arr(l)), d(N + 1, arr(l));\n        for (int i = 0; i &lt; l; ++i)\n            u[__builtin_popcount(i)][i] = cnt[i];\n        for (int i = 0; i &lt;= N; ++i)\n            calc(u[i], u[i], mT);\n        for (int i = 0; i &lt;= N; ++i) &#123;\n            for (int j = 0; j &lt; l; ++j)\n                for (int k = 0; k &lt;= i; ++k)\n                    (d[i][j] += u[k][j] * u[i - k][j]) %= mod;\n            calc(d[i], d[i], mI);\n        &#125;\n        for (int i = 0; i &lt; l; ++i)\n            cnt1[i] = d[__builtin_popcount(i)][i] * f[i] % mod;\n    &#125;\n    &#123; // xor FWT\n        mT[0][0] = 1ll, mT[0][1] = 1ll, mT[1][0] = 1ll, mT[1][1] = mod - 1ll;\n        mI[0][0] = mI[0][1] = mI[1][0] = inv2, mI[1][1] = mod - inv2;\n        calc(cnt, cnt2, mT);\n        for (int i = 0; i &lt; l; ++i)\n            (cnt2[i] *= cnt2[i]) %= mod;\n        calc(cnt2, cnt2, mI);\n        for (int i = 0; i &lt; l; ++i)\n            (cnt2[i] *= f[i]) %= mod;\n    &#125;\n    &#123; // andFWT\n        mT[0][0] = 0ll, mT[0][1] = 1ll, mT[1][0] = 1ll, mT[1][1] = 1ll;\n        mI[0][0] = mod - 1ll, mI[0][1] = 1ll, mI[1][0] = 1ll, mI[1][1] = 0ll;\n        for (int i = 0; i &lt; l; ++i) // 这一步要放在 FWT 之前，原因显然 🤗\n            (cnt[i] *= f[i]) %= mod;\n        calc(cnt2, cnt2, mT), calc(cnt1, cnt1, mT), calc(cnt, cnt, mT);\n        for (int i = 0; i &lt; l; ++i)\n            cnt[i] = cnt[i] * cnt1[i] % mod * cnt2[i] % mod % mod;\n        calc(cnt, cnt, mI);\n    &#125;\n    long long res = 0ll;\n    for (int i = 0; i &lt; N; ++i)\n        (res += cnt[1 &lt;&lt; i] % mod) %= mod;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n",
            "tags": [
                "高维前缀和",
                "FWT"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20240517/",
            "url": "https://xsc062.netlify.app/20240517/",
            "title": "状压枚举子集 + 高维前缀和",
            "date_published": "2024-05-17T13:19:38.000Z",
            "content_html": "<p>出现了，但发现没写过，故记之。</p>\n<span id=\"more\"></span>\n<hr />\n<h3 id=\"状压枚举子集\">状压枚举子集</h3>\n<p>需求：对于 <strong>每一个</strong> 长度为 <span class=\"math inline\">\\(n\\)</span> 的二进制状态 <span class=\"math inline\">\\(s\\)</span>，枚举其子状态 <span class=\"math inline\">\\(\\{ t \\mid t \\operatorname{bitand} s = t \\}\\)</span>。</p>\n<p>直接枚举所有长度为 <span class=\"math inline\">\\(n\\)</span> 的状态 <span class=\"math inline\">\\(t&#39;\\)</span>，然后判定是否满足 <span class=\"math inline\">\\(t&#39; \\operatorname{bitand} s = t\\)</span>，总时间复杂度是 <span class=\"math inline\">\\(O(2^{2n})\\)</span> 的。考虑优化。</p>\n<p>考虑对于所有 <span class=\"math inline\">\\(2^n\\)</span> 种状态 <span class=\"math inline\">\\(s\\)</span>，假如有一种方式能够不重不漏地枚举出它们中每一个的所有子状态，那么总时间复杂度是多少呢？</p>\n<p>把所有数对 <span class=\"math inline\">\\((s, t)\\)</span> 排列在一起。那么对于 <span class=\"math inline\">\\(n\\)</span> 位中的每一位 <span class=\"math inline\">\\(i\\)</span>，枚举每一个 <span class=\"math inline\">\\((s&#39;, t&#39;)\\)</span>。</p>\n<p>那么存在以下几种可能性：</p>\n<ol type=\"1\">\n<li><span class=\"math inline\">\\({s&#39;}_i=1,{t&#39;}_i=1\\)</span>；</li>\n<li><span class=\"math inline\">\\({s&#39;}_i=1, {t&#39;}_i=0\\)</span>；</li>\n<li><span class=\"math inline\">\\({s&#39;}_i=0, {t&#39;}_i = 0\\)</span>。</li>\n</ol>\n<p>假如我们用 <span class=\"math inline\">\\(o_i=0,1,2\\)</span> 分别代表第一、二、三种情况，完全可以用长度为 <span class=\"math inline\">\\(n\\)</span> 的三进制状态 <span class=\"math inline\">\\(o\\)</span> 还原数对 <span class=\"math inline\">\\((s, t)\\)</span>。</p>\n<p>由于这个 <span class=\"math inline\">\\((s, t)\\)</span> 序列中肯定没有完全相同的元素，也就是说，对于每一个 <span class=\"math inline\">\\((s, t)\\)</span>，其 <span class=\"math inline\">\\(o\\)</span> 都各不相同。</p>\n<p>因此，<span class=\"math inline\">\\((s, t)\\)</span> 的数目不超过 <span class=\"math inline\">\\(3^n\\)</span>（更准确地，二者值相等）。</p>\n<p>又因为对于 <span class=\"math inline\">\\(3^n\\)</span> 个 <span class=\"math inline\">\\(o\\)</span>，每个都可以还原出合法状态，所以总的 <span class=\"math inline\">\\((s, t)\\)</span> 数目应恰好为 <span class=\"math inline\">\\(3^n\\)</span>。</p>\n<p>也就是说，假如有一种方式能够不重不漏地枚举出每一个 <span class=\"math inline\">\\(s\\)</span> 的所有子状态 <span class=\"math inline\">\\(t\\)</span>，可以做到均摊 <span class=\"math inline\">\\(O(3^n)\\)</span>。</p>\n<p>接下来探讨这种枚举方式。直接给出结论：</p>\n<pre class=\"cpp\"><code>for (int t = s; t; t = (t - 1) &amp; s);</code></pre>\n<p>其实不难理解。从 <span class=\"math inline\">\\(t\\)</span> 的定义出发即 <span class=\"math inline\">\\(t \\operatorname{bitand} s = t\\)</span>，重点理解 <span class=\"math inline\">\\(t\\gets (t - 1)\\operatorname{bitand} s\\)</span> 这一步。</p>\n<p>分两种情况讨论：</p>\n<ol type=\"1\">\n<li><p><span class=\"math inline\">\\(t-1\\)</span> 较 <span class=\"math inline\">\\(t\\)</span> 发生退位：</p>\n<p>因为只减 <span class=\"math inline\">\\(1\\)</span>，所以末位一定发生退位。</p>\n<p>如果发生连续退位，一定是因为末端有连续的 <span class=\"math inline\">\\(0\\)</span>。对于第一个 <span class=\"math inline\">\\(1\\)</span>（记为第 <span class=\"math inline\">\\(j\\)</span> 位），已经枚举完了在 <span class=\"math inline\">\\(j\\)</span> 及更高位固定在当前状态下的所有状态。</p>\n<p>则应有：</p>\n<ul>\n<li>比 <span class=\"math inline\">\\(j\\)</span> 更高的数位，未受到退位带来的连续影响的位不变；</li>\n<li>第 <span class=\"math inline\">\\(j\\)</span> 位 <span class=\"math inline\">\\(1\\to 0\\)</span>；</li>\n<li>从第 <span class=\"math inline\">\\(j\\)</span> 位一直到末位都有 <span class=\"math inline\">\\(0\\to 1\\)</span>。</li>\n</ul>\n<p>此时与 <span class=\"math inline\">\\(s\\)</span> 进行 <span class=\"math inline\">\\(\\operatorname{bitand}\\)</span>，得到比 <span class=\"math inline\">\\(j\\)</span> 更高的数位不变、<span class=\"math inline\">\\(j\\)</span> 位 <span class=\"math inline\">\\(1\\to 0\\)</span>、比 <span class=\"math inline\">\\(j\\)</span> 更低的数位变为抵着 <span class=\"math inline\">\\(s\\)</span> 对应数位的最大状态。</p>\n综上，这是比 <span class=\"math inline\">\\(t\\)</span> 小的第一个合法状态。</li>\n<li><p><span class=\"math inline\">\\(t-1\\)</span> 较 <span class=\"math inline\">\\(t\\)</span> 不发生退位：</p>\n<p>根据上面的讨论，其实就是末位不退位，即末位 <span class=\"math inline\">\\(1\\to 0\\)</span>。显然是比 <span class=\"math inline\">\\(t\\)</span> 更小的第一个合法状态。</p></li>\n</ol>\n<p>综上，实现了从大到小依次枚举合法状态，因此不重不漏。</p>\n<hr />\n<h3 id=\"枚举补集\">枚举补集</h3>\n<p>看了几个比较抽象的博客，但是我觉得不如直接把 <span class=\"math inline\">\\(s\\)</span> 异或一下 <span class=\"math inline\">\\(2^n-1\\)</span> 然后枚举子集。</p>\n<hr />\n<h3 id=\"子集和-高维前缀和\">子集和 / 高维前缀和</h3>\n<p>首先理解一下什么是高维前缀和。实际上全称应为边长为 <span class=\"math inline\">\\(2\\)</span> 的高维空间前缀和。其实就是求所有状态的子集和，运用了前缀和的思想故唤高位前缀和 / 逐维前缀和。</p>\n<p>即在 <span class=\"math inline\">\\(n=2\\)</span> 的情况下，我们发现我们可以将 <span class=\"math inline\">\\(k\\)</span> 维前缀和看作在 <span class=\"math inline\">\\(k\\)</span> 位二进制数上做子集元素求和。显然根据枚举子集有 <span class=\"math inline\">\\(3^k\\)</span> 的做法，但还能更快。</p>\n<pre class=\"cpp\"><code>std::copy(a.begin(), a.end(), s.begin());\nfor (int i = 0; i &lt; k; ++i)\n    for (int j = 0; j &lt; l; ++j)\n        if ((j &gt;&gt; i) &amp; 1)\n            s[j] += s[j ^ (1 &lt;&lt; i)];</code></pre>\n<p>先枚举 <span class=\"math inline\">\\(i\\)</span> 是因为使用高维前缀和的题目一般时限卡得比较死，需要使用内存连续访问尽量减小常数。</p>\n<p>对于状态 <span class=\"math inline\">\\(j\\)</span>，考虑枚举其每一维上的值，则 <span class=\"math inline\">\\(s_j=a_j+\\sum s_{j\\bigoplus 2^i}\\)</span>。易发现这可以不重不漏地覆盖所有子集。</p>\n<p>这种思想在一些状态压缩的题目中也有应用，具体见 <a href=\"/20231117#1\">此</a>。</p>\n<h3 id=\"高维后缀和\">高维后缀和</h3>\n<p>从大往小枚举 <span class=\"math inline\">\\(j\\)</span>，对于 <span class=\"math inline\">\\(j\\)</span> 中值为 <code>false</code> 的维 <span class=\"math inline\">\\(i\\)</span>，令 <span class=\"math inline\">\\(s_j=a_j+\\sum s_{j+2^i}\\)</span> 即可。</p>\n<pre class=\"cpp\"><code>std::copy(a.begin(), a.end(), s.begin());\nfor (int i = 0; i &lt; k; ++i)\n    for (int j = l - 1; ~j; --j)\n        if (!((j &gt;&gt; i) &amp; 1))\n            s[j] += s[j ^ (1 &lt;&lt; i)];</code></pre>\n",
            "tags": [
                "状压",
                "高维前缀和"
            ]
        }
    ]
}