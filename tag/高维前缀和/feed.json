{
    "version": "https://jsonfeed.org/version/1",
    "title": "null â€¢ All posts by \"é«˜ç»´å‰ç¼€å’Œ\" tag",
    "description": "",
    "home_page_url": "https://xsc062.netlify.app",
    "items": [
        {
            "id": "https://xsc062.netlify.app/20250329/",
            "url": "https://xsc062.netlify.app/20250329/",
            "title": "å­¦ä¹ ç¬”è®°ï¼šFWT",
            "date_published": "2025-03-29T07:00:21.000Z",
            "content_html": "<p>æ´»äº†å“¥ä»¬ï¼Œå¤æ´»äº†ã€‚</p>\n<span id=\"more\"></span>\n<hr />\n<p>è€ƒè™‘ä»¥ä¸‹é—®é¢˜ï¼š</p>\n<ul>\n<li>å¯¹äº <span class=\"math inline\">\\(\\forall \\,i\\in U\\)</span>ï¼Œæ±‚ <span class=\"math inline\">\\(c_i=\\sum\\limits_{j\\cup k=i}a_j\\cdot b_k\\)</span>ã€‚</li>\n</ul>\n<p>å½“ç„¶è¿™é‡Œå¯ä»¥æŠŠé›†åˆçœ‹æˆäºŒè¿›åˆ¶çŠ¶æ€ï¼Œé‚£ä¹ˆå–å¹¶é›†å°±æ˜¯æŒ‰ä½æˆ–äº†ã€‚</p>\n<p>å’•å’•å’•</p>\n<hr />\n<h2 id=\"emiya-å®¶æ˜å¤©çš„é¥­\">Emiya å®¶æ˜å¤©çš„é¥­</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P10242\" class=\"uri\">https://www.luogu.com.cn/problem/P10242</a></p>\n<p>å†·çŸ¥è¯†ï¼š<em>Emiya å®¶æ˜å¤©çš„é¥­</em> å’Œ <em>Emiya å®¶ä»Šå¤©çš„é¥­</em> æ‹¥æœ‰ç›¸åŒçš„éš¾åº¦è¯„çº§ <img src=\"/em/kt.gif\" alt=\"ç£•å¤´\" /></p>\n<p>è€ƒè™‘æš´åŠ›çš„åšæ³•ï¼Œå¦‚æœæˆ‘ä»¬å…ˆé’¦å®šå¿…é¡»åˆ°è¾¾çš„äººï¼ˆè¿™æ˜¯ <span class=\"math inline\">\\(O(2^n)\\)</span> çš„ï¼‰ï¼Œå†èŠ±è´¹ <span class=\"math inline\">\\(O(nm)\\)</span> çš„æ—¶é—´ä¾æ¬¡åˆ¤å®šæ¯é“èœæ˜¯å¦å¯ä»¥è¢«é€‰æ‹©ï¼Œå°±å¯ä»¥ è§£å†³é—®é¢˜ã€‚ä½†å‘ç°æ—¶é—´æ˜¯ä¸èƒ½æ‰¿å—çš„ï¼Œè¿™é‡Œæˆ‘ä»¬é€‰æ‹©ä¼˜åŒ– <span class=\"math inline\">\\(O(nm)\\)</span> çš„åˆ¤å®šã€‚</p>\n<p>ç°åœ¨å·²çŸ¥äººå‘˜é›†åˆ <span class=\"math inline\">\\(s\\)</span>ï¼Œå¯¹äºä¸€é“èœ <span class=\"math inline\">\\(i\\)</span>ï¼Œè®¾å®ƒé€‚é…çš„äººå‘˜é›†åˆä¸º <span class=\"math inline\">\\(T_i\\)</span>ï¼Œé‚£ä¹ˆæœ‰ <span class=\"math inline\">\\(s\\subseteq T_i\\)</span>ã€‚æ‰€æ±‚å³ä¸º <span class=\"math inline\">\\(\\max\\limits_s\\{\\sum\\limits_{T_i\\supseteq s}\\sum\\limits_{j\\in s}a_{i,j}\\}\\)</span>ã€‚<span class=\"math inline\">\\(O(nm)\\)</span> é¢„å¤„ç†å‡º <span class=\"math inline\">\\(f_j(u)=\\sum\\limits_{T_i=u}a_{j, i}\\)</span>ï¼Œé‚£ä¹ˆå¾…æ±‚å³ä¸º <span class=\"math inline\">\\(\\max\\limits_{s}\\{\\sum\\limits_{j\\in s}\\sum\\limits_{u\\supseteq s}f_j(u)\\}\\)</span>ï¼Œå‘ç°è¿™ä¸ªä¸œè¥¿å¯ä»¥ç”¨ FWT æ±‚ã€‚</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, m, k;\n    std::cin &gt;&gt; k &gt;&gt; m, n = 1 &lt;&lt; k;\n    using arr = std::vector&lt;long long&gt;;\n    std::vector&lt;int&gt; t(m + 1);\n    std::vector&lt;arr&gt; a(k + 1, arr(m + 1)), f(k + 1, arr(n));\n    for (int i = 1; i &lt;= k; ++i)\n        for (int j = 1; j &lt;= m; ++j) &#123;\n            std::cin &gt;&gt; a[i][j];\n            if (a[i][j] &gt;= 0)\n                t[j] |= 1 &lt;&lt; (i - 1);\n        &#125;\n    for (int i = 1; i &lt;= k; ++i)\n        for (int j = 1; j &lt;= m; ++j)\n            if (a[i][j] &gt;= 0)\n                f[i][t[j]] += a[i][j];\n    &#123;\n        std::vector&lt;arr&gt; mT(2, arr(2));\n        mT[0][0] = 1ll, mT[0][1] = 1ll, mT[1][0] = 0ll, mT[1][1] = 1ll;\n        auto calc = [&amp;](arr a, arr &amp;f, std::vector&lt;arr&gt; &amp;w) &#123;\n            f = a;\n            for (int len = 2; len &lt;= n; len &lt;&lt;= 1) &#123;\n                for (int i = 0; i &lt; n; i += len)\n                    for (int p = i, q = i + len / 2; q &lt; i + len; ++p, ++q)\n                        std::tie(f[p], f[q]) = std::make_tuple(f[p] * w[0][0] + f[q] * w[0][1], f[p] * w[1][0] + f[q] * w[1][1]);\n            &#125;\n            return;\n        &#125;;\n        for (int i = 1; i &lt;= k; ++i)\n            calc(f[i], f[i], mT);\n    &#125;\n    long long res = 0ll;\n    for (int s = 0; s &lt; n; ++s) &#123;\n        long long sum = 0ll;\n        for (int i = 1; i &lt;= k; ++i)\n            if ((s &gt;&gt; (i - 1)) &amp; 1)\n                sum += f[i][s];\n        res = std::max(res, sum);\n    &#125;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"nim-counting\">Nim Counting</h2>\n<p><a href=\"https://atcoder.jp/contests/abc212/tasks/abc212_h\" class=\"uri\">https://atcoder.jp/contests/abc212/tasks/abc212_h</a></p>\n<p>å³ï¼Œä» <span class=\"math inline\">\\(A_N\\)</span> ä¸­æœ‰æ”¾å›åœ°é€‰æ‹© <span class=\"math inline\">\\(\\le M\\)</span> ä¸ªæ•°ï¼Œé—®å®ƒä»¬å¼‚æˆ–èµ·æ¥ä¸ä¸º <span class=\"math inline\">\\(0\\)</span> çš„æ–¹æ¡ˆæ•°ã€‚</p>\n<p>å¦‚æœä»¤ <span class=\"math inline\">\\(f_{i, j}\\)</span> è¡¨ç¤ºé€‰äº† <span class=\"math inline\">\\(i\\)</span> æ¬¡ï¼Œå¼‚æˆ–å’Œä¸º <span class=\"math inline\">\\(j\\)</span> çš„æ–¹æ¡ˆæ•°ï¼Œæ˜¾ç„¶ <span class=\"math inline\">\\(f_{1,i}=\\sum [a_j=i]\\)</span> ä¸ºå…³äº <span class=\"math inline\">\\(a\\)</span> çš„æ¡¶ã€‚æ­¤æ—¶æœ‰ <span class=\"math inline\">\\(f_{i,j}=\\sum\\limits_{k=1}^n f_{i-1,j\\oplus a_k}=\\sum\\limits_{k=0}^V f_{i-1,j\\oplus k}\\cdot f_{1,k}\\)</span>ï¼Œå‘ç°æŠŠ <span class=\"math inline\">\\(f_1\\)</span> è¿™ä¸ªæ¡¶åœ¨ <span class=\"math inline\">\\(f\\)</span> ä¸Šåš <span class=\"math inline\">\\(N\\)</span> æ¬¡ xor-FWT å°±å¯ä»¥å¾—åˆ° <span class=\"math inline\">\\(f_n\\)</span>ã€‚</p>\n<p>ä½†å¦‚æœç›´æ¥å· <span class=\"math inline\">\\(N\\)</span> æ¬¡æ˜¯ <span class=\"math inline\">\\(O(N\\cdot V\\log V)\\)</span> çš„ï¼Œä¸å¤ªç¾å¥½ï¼Œä½†æˆ‘ä»¬çœ‹çœ‹æˆ‘ä»¬å®é™…ä¸Šéœ€è¦åšä»€ä¹ˆï¼š</p>\n<ol type=\"1\">\n<li>æ±‚ <span class=\"math inline\">\\(f_i\\)</span> çš„ FWTã€‚</li>\n<li>æ±‚åˆå§‹æ¡¶ <span class=\"math inline\">\\(f_1\\)</span> çš„ FWTã€‚</li>\n<li>å¯¹ä½ç›¸ä¹˜å¾—åˆ° <span class=\"math inline\">\\(f_{i+1}\\)</span> çš„ FWTã€‚</li>\n<li>é€šè¿‡ FWT æ±‚å¾—åŸæœ¬çš„ <span class=\"math inline\">\\(f_{i+1}\\)</span>ã€‚</li>\n</ol>\n<p>å½“è¿™ä¸ªæ“ä½œè¢«æ”¾åœ¨ <span class=\"math inline\">\\(i=1\\sim n\\)</span> ä¸Šä¾æ¬¡è¿›è¡Œæ—¶ï¼Œæˆ‘ä»¬å‘ç°ç¬¬ä¸€æ­¥å’Œæœ€åä¸€æ­¥ä¼šç›¸äº’æŠµæ¶ˆï¼Œæˆ‘ä»¬åªéœ€è¦æ±‚å‡º <span class=\"math inline\">\\(f_1\\)</span> çš„ FWTï¼Œ<span class=\"math inline\">\\(FWT_{i, j}(f)\\)</span> å³ä¸º <span class=\"math inline\">\\(FWT_{1, j}(f)^i\\)</span>ã€‚å› ä¸ºæˆ‘ä»¬è¦æ±‚çš„æ˜¯ <span class=\"math inline\">\\(\\sum\\limits_{i, j}f_{i,j}\\)</span> å¯ä»¥é€šè¿‡ç­‰æ¯”æ•°åˆ—æ±‚å’Œæ±‚å‡º <span class=\"math inline\">\\(FWT_j(s)=\\sum f_{i, j}\\)</span>ã€‚ç”±å‰æ–‡æ¨å¯¼å¯çŸ¥ç›´æ¥åšä¸€æ¬¡é€†å˜æ¢æ±‚å¾— <span class=\"math inline\">\\(s_j\\)</span> å³å¯ã€‚</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    struct mint &#123;\n        const int mod = 998244353;\n        long long x;\n        mint(): x(0ll) &#123;&#125;\n        mint(long long x1): x((x1 + mod) % mod) &#123;&#125;\n        mint&amp; operator= (const mint q) &#123;\n            x = q.x;\n            return *this;\n        &#125;\n        bool operator== (const mint q) const &#123;\n            return x == q.x;\n        &#125;\n        mint operator* (const mint q) const &#123;\n            return x * q.x % mod;\n        &#125;\n        mint&amp; operator*= (const mint q) &#123;\n            return *this = *this * q;\n        &#125;\n        mint operator+ (const mint q) &#123;\n            return (x + q.x) % mod;\n        &#125;\n        mint&amp; operator+= (const mint q) &#123;\n            return *this = *this + q;\n        &#125;\n        mint operator- (const mint q) &#123;\n            return (x + mod - q.x) % mod;\n        &#125;\n        mint qkp(int y) &#123;\n            mint res(1ll), x(this-&gt;x);\n            for (; y; y &gt;&gt;= 1, x *= x)\n                if (y &amp; 1)\n                    res *= x;\n            return res;\n        &#125;\n        mint inv(void) &#123;\n            return qkp(mod - 2);\n        &#125;\n    &#125;;\n    int n, m, k = 16, l = 1 &lt;&lt; k;\n    std::cin &gt;&gt; m &gt;&gt; n;\n    using arr = std::vector&lt;mint&gt;;\n    arr a(n + 1), c(l);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i].x, c[a[i].x] += 1;\n    std::vector&lt;arr&gt; mT(2, arr(2)), mI(2, arr(2));\n    mT[0][0] = 1ll, mT[0][1] = 1ll, mT[1][0] = 1ll, mT[1][1] = -1ll;\n    mI[0][0] = mI[0][1] = mI[1][0] = mint(2ll).inv(), mI[1][1] = mint(-2ll).inv();\n    auto calc = [&amp;](arr a, arr &amp;f, std::vector&lt;arr&gt; &amp;w) &#123;\n        f = a;\n        for (int len = 2; len &lt;= l; len &lt;&lt;= 1)\n            for (int i = 0; i &lt; l; i += len)\n                for (int p = i, q = i + len / 2; q &lt; i + len; ++p, ++q)\n                    std::tie(f[p], f[q]) = std::make_tuple(f[p] * w[0][0] + f[q] * w[0][1], f[p] * w[1][0] + f[q] * w[1][1]);\n        return;\n    &#125;;\n    calc(c, c, mT);\n    arr s(l);\n    for (int i = 0; i &lt; l; ++i)\n        if (c[i] == 1ll)\n            s[i] = m;\n        else\n            s[i] = c[i] * (mint(1ll) - c[i].qkp(m)) * (mint(1ll) - c[i]).inv();\n    calc(s, s, mI);\n    mint res;\n    for (int i = 1; i &lt; l; ++i)\n        res += s[i];\n    std::cout &lt;&lt; res.x &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"binary-table\">Binary Table</h2>\n<p><a href=\"https://codeforces.com/problemset/problem/662/C\" class=\"uri\">https://codeforces.com/problemset/problem/662/C</a></p>\n<p>å‘ç°è¿™ä¸ªé¢˜å’Œ <em>Emiya å®¶ä»Šå¤©çš„é¥­</em> å¾ˆåƒï¼Œéƒ½æ˜¯æœ‰ä¸€ä¸ªå¾ˆå°çš„ç»´å’Œä¸€ä¸ªç›¸å¯¹æ¯”è¾ƒå¤§çš„ç»´ã€‚</p>\n<p>æ˜¾ç„¶ï¼Œæˆ‘ä»¬æ‰€æœ‰çš„æ“ä½œé¡ºåºéƒ½å¯ä»¥ä»»æ„è°ƒæ¢ï¼›æœ´ç´ åœ°ï¼Œæˆ‘ä»¬æšä¸¾ <span class=\"math inline\">\\(2^n\\)</span> ç§ç»™è¿™ <span class=\"math inline\">\\(n\\)</span> è¡Œåè½¬çš„æƒ…å†µï¼›å†å¯¹äºæ¯ä¸€åˆ—ï¼Œ<span class=\"math inline\">\\(O(n)\\)</span> é€‰æ‹©åº”è¯¥åè½¬è¿˜æ˜¯ä¸åè½¬ï¼Œè¿™æ ·æ€»å…±æ˜¯ <span class=\"math inline\">\\(O(2^n\\cdot nm)\\)</span> çš„ã€‚</p>\n<p>å‘ç°æŠŠä¸€åˆ—åˆå§‹çŠ¶æ€å‹æˆä¸€ä¸ªäºŒè¿›åˆ¶æ•° <span class=\"math inline\">\\(a\\)</span>ï¼Œå‡è®¾æˆ‘ä»¬ç°åœ¨æšä¸¾çš„è¡Œåè½¬çŠ¶æ€ä¸º <span class=\"math inline\">\\(s\\)</span>ï¼Œæ˜¾ç„¶ç”¨ <span class=\"math inline\">\\(s\\oplus a\\)</span> å¯ä»¥å¾—åˆ°å½“å‰çŠ¶æ€ã€‚æ€ä¹ˆåˆ©ç”¨è¿™ä¸ªå» FWT å‘¢ï¼Ÿè¿™å¼•å¯¼æˆ‘ä»¬ä¾ç„¶æšä¸¾ <span class=\"math inline\">\\(s\\)</span>ï¼Œç”¨ä¸€ä¸ªå’Œ <span class=\"math inline\">\\(s\\oplus a\\)</span> æœ‰å…³çš„é‡è·Ÿä¸€ä¸ªå’Œ <span class=\"math inline\">\\(a\\)</span> æœ‰å…³çš„é‡ç›¸ä¹˜å¾—åˆ°å…³äº <span class=\"math inline\">\\(s\\)</span> çš„ç­”æ¡ˆã€‚</p>\n<p>å®¹æ˜“å‘ç°ä»¤ <span class=\"math inline\">\\(f_{s\\oplus a}\\)</span> è¡¨ç¤º <span class=\"math inline\">\\(s\\oplus a\\)</span> è¿™ä¸ªçŠ¶æ€åè½¬å’Œä¸åè½¬ä¸¤ä¸ªé€‰é¡¹ä¸­å¯ä»¥è·å–çš„æœ€å°‘ 1 çš„ä¸ªæ•°ï¼›å†ä»¤ <span class=\"math inline\">\\(c_s\\)</span> è¡¨ç¤ºçŠ¶æ€ä¸º <span class=\"math inline\">\\(s\\)</span> çš„åˆ—çš„ä¸ªæ•°ï¼Œé‚£ä¹ˆ <span class=\"math inline\">\\(\\sum\\limits_s c_s\\times f_{s\\oplus a}\\)</span> å°±å¯ä»¥å¾—åˆ°æšä¸¾çš„åè½¬æ–¹æ¡ˆä¸º <span class=\"math inline\">\\(s\\)</span> çš„ç­”æ¡ˆï¼Œæ±‚æœ€å°å³å¯ã€‚</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    struct mint &#123;\n        const int mod = 998244353;\n        long long x;\n        mint(): x(0ll) &#123;&#125;\n        mint(long long x1): x((x1 + mod) % mod) &#123;&#125;\n        mint&amp; operator= (const mint q) &#123;\n            x = q.x;\n            return *this;\n        &#125;\n        bool operator== (const mint q) const &#123;\n            return x == q.x;\n        &#125;\n        mint operator* (const mint q) const &#123;\n            return x * q.x % mod;\n        &#125;\n        mint&amp; operator*= (const mint q) &#123;\n            return *this = *this * q;\n        &#125;\n        mint operator+ (const mint q) &#123;\n            return (x + q.x) % mod;\n        &#125;\n        mint&amp; operator+= (const mint q) &#123;\n            return *this = *this + q;\n        &#125;\n        mint operator- (const mint q) &#123;\n            return (x + mod - q.x) % mod;\n        &#125;\n        mint qkp(int y) &#123;\n            mint res(1ll), x(this-&gt;x);\n            for (; y; y &gt;&gt;= 1, x *= x)\n                if (y &amp; 1)\n                    res *= x;\n            return res;\n        &#125;\n        mint inv(void) &#123;\n            return qkp(mod - 2);\n        &#125;\n    &#125;;\n    int n, m, l;\n    std::cin &gt;&gt; n &gt;&gt; m, l = 1 &lt;&lt; n;\n    using arr = std::vector&lt;mint&gt;;\n    arr c(l), f(l);\n    std::vector&lt;std::vector&lt;char&gt; &gt; a(n + 1, std::vector&lt;char&gt; (m + 1));\n    for (int i = 1; i &lt;= n; ++i)\n        for (int j = 1; j &lt;= m; ++j)\n            std::cin &gt;&gt; a[i][j];\n    for (int j = 1; j &lt;= m; ++j) &#123;\n        int s = 0;\n        for (int i = 1; i &lt;= n; ++i)\n            s = (s &lt;&lt; 1) + a[i][j] - &#39;0&#39;;\n        c[s] += 1;\n    &#125;\n    for (int i = 0, t; i &lt; l; ++i)\n        t = (__builtin_popcount(i)), f[i] = std::min(t, n - t);\n    std::vector&lt;arr&gt; mT(2, arr(2)), mI(2, arr(2));\n    mT[0][0] = 1ll, mT[0][1] = 1ll, mT[1][0] = 1ll, mT[1][1] = -1ll;\n    mI[0][0] = mI[0][1] = mI[1][0] = mint(2ll).inv(), mI[1][1] = mint(-2ll).inv();\n    auto calc = [&amp;](arr a, arr &amp;f, std::vector&lt;arr&gt; &amp;w) &#123;\n        f = a;\n        for (int len = 2; len &lt;= l; len &lt;&lt;= 1)\n            for (int i = 0; i &lt; l; i += len)\n                for (int p = i, q = i + len / 2; q &lt; i + len; ++p, ++q)\n                    std::tie(f[p], f[q]) = std::make_tuple(f[p] * w[0][0] + f[q] * w[0][1], f[p] * w[1][0] + f[q] * w[1][1]);\n        return;\n    &#125;;\n    calc(c, c, mT), calc(f, f, mT);\n    arr s(l);\n    for (int i = 0; i &lt; l; ++i)\n        s[i] = c[i] * f[i];\n    calc(s, s, mI);\n    int res = 0x3f3f3f3f;\n    for (int i = 0; i &lt; l; ++i)\n        res = std::min(res, (int)s[i].x);\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"hard-nim\">Hard Nim</h2>\n<p><a href=\"https://hydro.ac/p/bzoj-P4589\" class=\"uri\">https://hydro.ac/p/bzoj-P4589</a></p>\n<p><em>Nim Counting</em> ç„¶åç¼äº†ä¸ªç­›å­ã€‚</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 1e9 + 7;\nconst int inv2 = 5e8 + 4;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    std::vector&lt;int&gt; p, tag(50001);\n    for (int i = 2; i &lt;= 50000; ++i)\n        if (!tag[i]) &#123;\n            p.push_back(i);\n            for (int j = 2 * i; j &lt;= 50000; j += i)\n                tag[j] = 1;\n        &#125;\n    auto qkp = [&amp;](long long x, int y) &#123;\n        long long res = 1ll;\n        for (; y; y &gt;&gt;= 1, (x *= x) %= mod)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    for (int n, m; std::cin &gt;&gt; n &gt;&gt; m; ) &#123;\n        int k = std::__lg(m) + 1, l = 1 &lt;&lt; k;\n        using arr = std::vector&lt;long long&gt;;\n        arr c(l);\n        for (auto i : p)\n            if (i &lt;= m)\n                c[i] += 1;\n            else\n                break;\n        std::vector&lt;arr&gt; mT(2, arr(2)), mI(2, arr(2));\n        mT[0][0] = 1ll, mT[0][1] = 1ll, mT[1][0] = 1ll, mT[1][1] = mod - 1ll;\n        mI[0][0] = mI[0][1] = mI[1][0] = inv2, mI[1][1] = mod - inv2;\n        auto calc = [&amp;](arr &amp;f, std::vector&lt;arr&gt; &amp;w) &#123;\n            for (int len = 2; len &lt;= l; len &lt;&lt;= 1)\n                for (int i = 0; i &lt; l; i += len)\n                    for (int p = i, q = i + len / 2; q &lt; i + len; ++p, ++q)\n                        std::tie(f[p], f[q]) = std::make_tuple((f[p] * w[0][0] + f[q] * w[0][1]) % mod, (f[p] * w[1][0] + f[q] * w[1][1]) % mod);\n            return;\n        &#125;;\n        calc(c, mT);\n        arr s(l);\n        for (int i = 0; i &lt; l; ++i)\n            s[i] = qkp(c[i], n);\n        calc(s, mI);\n        std::cout &lt;&lt; s[0] &lt;&lt; &#39;\\n&#39;;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"å­é›†å·ç§¯\">å­é›†å·ç§¯</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P6097\" class=\"uri\">https://www.luogu.com.cn/problem/P6097</a></p>\n<p>è¿™ä¸ªæ˜¯åœ¨è®¸å¤š DP ä¸­éƒ½å¯èƒ½è§åˆ°è¿‡çš„ç»“æ„ï¼Œç›¸ä¿¡å¤§å®¶éƒ½æ·±æœ‰ä½“ä¼šã€‚</p>\n<p>ç­‰ä»·äºæ±‚ <span class=\"math inline\">\\(c_s=\\sum\\limits_{i\\cap j=\\varnothing\\land i\\cup j=s}a_i\\cdot b_j\\)</span>ï¼Œé¦–å…ˆå…³æ³¨ <span class=\"math inline\">\\(i\\cup j=s\\)</span>ï¼Œå¯ä»¥ç”¨ FWT è§£å†³ï¼›å¯¹äº <span class=\"math inline\">\\(i\\cap j = \\varnothing\\)</span> å‘¢ï¼Ÿ</p>\n<p>æœ‰ä¸€ä¸ªå¾ˆèªæ˜çš„åŠæ³•ï¼Œæˆ‘ä»¬å‘ç° <span class=\"math inline\">\\(i\\cap j=\\varnothing\\land i\\cup j = s\\iff \\operatorname{ctz}(i)+\\operatorname{ctz}(j)=\\operatorname{ctz}(s)\\)</span>ï¼Œå…¶ä¸­ <span class=\"math inline\">\\(\\operatorname{ctz}(i)\\)</span> è¡¨ç¤º <span class=\"math inline\">\\(i\\)</span> ä¸­ <span class=\"math inline\">\\(1\\)</span> çš„ä¸ªæ•°ï¼Œå³ <code>popcount(i)</code>ã€‚</p>\n<p>æ˜¾ç„¶åè€…æ˜¯ä¸ªç®€å•çš„åŠ æ³•è¿ç®—ï¼Œè¿™é‡Œåˆæœ‰ä¸€ä¸ªå¾ˆèªæ˜åˆå¾ˆåŸºæœ¬çš„åŠæ³•ï¼Œæˆ‘ä»¬ä»¤ <span class=\"math inline\">\\(A_{\\operatorname{ctz}(i),i}=a_i,B_{\\operatorname{ctz}(j),j}=b_j\\)</span>ï¼Œé‚£ä¹ˆç­”æ¡ˆå°±è½¬åŒ–ä¸º <span class=\"math inline\">\\(\\sum\\limits_{i}\\sum\\limits_{j\\cup k=s}A_{i,j}\\cdot B_{\\operatorname{ctz}(s)-i,j}\\)</span>ï¼Œå°±å¯ä»¥ <span class=\"math inline\">\\(O(n\\log^2n)\\)</span> åœ°è§£å†³é—®é¢˜äº†ã€‚</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 1e9 + 9;\nusing arr = std::vector&lt;long long&gt;;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    int l = 1 &lt;&lt; n;\n    std::vector&lt;arr&gt; a(n + 1, arr(l)), b(n + 1, arr(l)), c(n + 1, arr(l));\n    for (int i = 0, x; i &lt; l; ++i)\n        std::cin &gt;&gt; x, a[__builtin_popcount(i)][i] = x;\n    for (int i = 0, x; i &lt; l; ++i)\n        std::cin &gt;&gt; x, b[__builtin_popcount(i)][i] = x;\n    std::vector&lt;arr&gt; mT(2, arr(2)), mI(2, arr(2));\n    mT[0][0] = 1ll, mT[0][1] = 0ll, mT[1][0] = 1ll, mT[1][1] = 1ll;\n    mI[0][0] = 1ll, mI[0][1] = 0ll, mI[1][0] = mod - 1ll, mI[1][1] = 1ll;\n    auto calc = [&amp;](arr &amp;f, std::vector&lt;arr&gt; &amp;w) &#123;\n        for (int len = 2; len &lt;= l; len &lt;&lt;= 1)\n            for (int i = 0; i &lt; l; i += len)\n                for (int p = i, q = i + len / 2; q &lt; i + len; ++p, ++q)\n                    std::tie(f[p], f[q]) = std::make_tuple((f[p] * w[0][0] + f[q] * w[0][1]) % mod, (f[p] * w[1][0] + f[q] * w[1][1]) % mod);\n        return;\n    &#125;;\n    for (int i = 0; i &lt;= n; ++i)\n        calc(a[i], mT), calc(b[i], mT);\n    for (int i = 0; i &lt;= n; ++i) &#123;\n        for (int k = 0; k &lt;= i; ++k)\n            for (int j = 0; j &lt; l; ++j)\n                (c[i][j] += a[k][j] * b[i - k][j]) %= mod;\n        calc(c[i], mI);\n    &#125;\n    for (int j = 0; j &lt; l; ++j)\n        std::cout &lt;&lt; c[__builtin_popcount(j)][j] &lt;&lt; &#39; &#39;;\n    std::cout &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"å·åŒºåˆ’åˆ†\">å·åŒºåˆ’åˆ†</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P4221\" class=\"uri\">https://www.luogu.com.cn/problem/P4221</a></p>\n<p>äººè¯ï¼šæŠŠ <span class=\"math inline\">\\(n\\)</span> ä¸ªç‚¹åˆ’åˆ†æˆè‹¥å¹²ä¸ªç‚¹é›†ï¼Œä¿è¯æ¯ä¸ªç‚¹é›†çš„å¯¼å‡ºå­å›¾ä¸æ˜¯æ¬§æ‹‰å›è·¯ï¼ˆæ¯ä¸ªç‚¹çš„åº¦æ•°ä¸ºå¶ä¸”å›¾è¿é€šï¼‰ã€‚</p>\n<p>é‚£ä¹ˆæšä¸¾æ¯ä¸€ä¸ªç‚¹é›†åˆ¤å®šæ˜¯å¦åˆæ³•ï¼Œå†ä»¤ <span class=\"math inline\">\\(f_{i}={w_i}^{-p}\\times\\sum\\limits_{j\\cup k = i\\land j\\cap k=\\varnothing}f_{j}\\times {w_k}^p\\)</span>ã€‚</p>\n<p>å‘ç°åé¢é‚£ä¸ª sigma é‡Œé¢æ˜¯ä¸€ä¸ªç®€å•çš„å­é›†å·ç§¯ï¼›ä½†æ˜¯æˆ‘ä»¬å‘ç°å‰é¢æœ‰ä¸€ä¸ªå’Œ <span class=\"math inline\">\\(i\\)</span> æœ‰å…³çš„å¸¸æ•°ï¼Œå¯¼è‡´æ²¡åŠæ³•ç›´æ¥å· <span class=\"math inline\">\\(n\\)</span> æ¬¡ã€‚</p>\n<p>ä½†æˆ‘ä»¬å‘ç°è¿™ä¸ª DP å…¶å®æ˜¯æœ‰ä¸€å®šéšå«æ¡ä»¶çš„â€”â€”éƒ½æ˜¯æŒ‰ç…§ <span class=\"math inline\">\\(\\text{ctz}\\)</span> ä»å°åˆ°å¤§è½¬ç§»ã€‚è€ƒè™‘å­é›†å·ç§¯çš„ç¬¬ä¸€ç»´ï¼Œå¾—åˆ° <span class=\"math inline\">\\(FWT_{f_i}\\)</span> åå…ˆ IFWT å›æ¥ï¼Œä¹˜ä¸Š <span class=\"math inline\">\\({w_i}^{-p}\\)</span>ï¼Œå† FWT å›å»å³å¯ã€‚è€ƒå¯Ÿå­é›†å·ç§¯çš„ç»“æ„ï¼Œå‘ç°è¿™ä¸ªæ˜¯å¯ä»¥æƒ³åŠæ³•å¥—è¿›å»çš„ã€‚</p>\n<p>å¤æ‚åº¦ <a href=\"https://atcoder.jp/contests/abc400/tasks/abc400_c\"><span class=\"math inline\">\\(O(n^2\\cdot 2^n)\\)</span></a>ã€‚</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 998244353;\nusing arr = std::vector&lt;long long&gt;;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, m, p;\n    std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; p;\n    int l = 1 &lt;&lt; n;\n    auto qkp = [&amp;](long long x, int y = mod - 2) &#123;\n        auto res = 1ll;\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    arr w(n), inv(l);\n    std::vector&lt;arr&gt; f(n + 1, arr(l)), s(n + 1, arr(l));\n    std::vector&lt;std::vector&lt;int&gt; &gt; g(n);\n    for (int x, y; m--; ) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y, --x, --y;\n        g[x].push_back(y);\n    &#125;\n    auto check = [&amp;](int s) &#123;\n        std::vector&lt;int&gt; f(n), deg(n);\n        std::iota(f.begin(), f.end(), 0);\n        std::function&lt;int(int)&gt; find = [&amp;](int x) &#123;\n            return x == f[x] ? x : f[x] = find(f[x]);\n        &#125;;\n        auto merge = [&amp;](int x, int y) &#123;\n            f[find(x)] = find(y);\n            return;\n        &#125;;\n        for (int i = 0; i &lt; n; ++i)\n            if ((s &gt;&gt; i) &amp; 1)\n                for (auto j : g[i])\n                    if ((s &gt;&gt; j) &amp; 1)\n                        merge(i, j), ++deg[i], ++deg[j];\n        int fa = -1;\n        for (int i = 0; i &lt; n; ++i)\n            if ((s &gt;&gt; i) &amp; 1) &#123;\n                if (deg[i] &amp; 1)\n                    return 1;\n                if (fa == -1 || fa == find(i))\n                    fa = find(i);\n                else\n                    return 1;\n            &#125;\n        return 0;\n    &#125;;\n    for (int i = 0; i &lt; n; ++i)\n        std::cin &gt;&gt; w[i];\n    for (int i = 0; i &lt; l; ++i) &#123;\n        int ctz = __builtin_popcount(i);\n        for (int j = 0; j &lt; n; ++j)\n            if ((i &gt;&gt; j) &amp; 1) \n                s[ctz][i] += w[j];\n        s[ctz][i] = qkp(s[ctz][i], p);\n        inv[i] = qkp(s[ctz][i]);\n        if (!check(i))\n            s[ctz][i] = 0ll;\n    &#125;\n    std::vector&lt;arr&gt; mT(2, arr(2)), mI(2, arr(2));\n    mT[0][0] = 1ll, mT[0][1] = 0ll, mT[1][0] = 1ll, mT[1][1] = 1ll;\n    mI[0][0] = 1ll, mI[0][1] = 0ll, mI[1][0] = mod - 1ll, mI[1][1] = 1ll;\n    auto calc = [&amp;](arr &amp;f, std::vector&lt;arr&gt; &amp;w) &#123;\n        for (int len = 2; len &lt;= l; len &lt;&lt;= 1)\n            for (int i = 0; i &lt; l; i += len)\n                for (int p = i, q = i + len / 2; q &lt; i + len; ++p, ++q)\n                    std::tie(f[p], f[q]) = std::make_tuple((f[p] * w[0][0] + f[q] * w[0][1]) % mod, (f[p] * w[1][0] + f[q] * w[1][1]) % mod);\n        return;\n    &#125;;\n    f[0][0] = 1ll;\n    for (int i = 0; i &lt;= n; ++i)\n        calc(s[i], mT);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        calc(f[i - 1], mT);\n        for (int k = 0; k &lt; i; ++k)\n            for (int j = 0; j &lt; l; ++j)\n                (f[i][j] += f[k][j] * s[i - k][j]) %= mod;\n        calc(f[i], mI);\n        for (int j = 0; j &lt; l; ++j)\n            (f[i][j] *= inv[j]) %= mod;\n    &#125;\n    std::cout &lt;&lt; f[n][l - 1] &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"b---sum-the-fibonacci\">B - Sum the Fibonacci</h2>\n<p><a href=\"https://codeforces.com/problemset/problem/914/G\" class=\"uri\">https://codeforces.com/problemset/problem/914/G</a></p>\n<p>é¦–å…ˆï¼Œå¯¹äºæ¯ä¸ªå…ƒç´ çš„ <span class=\"math inline\">\\(cnt\\)</span> æ˜¯å¥½åšçš„â€”â€”åšä¸€æ¬¡å­é›†å·ç§¯å¾—åˆ° <span class=\"math inline\">\\(cnt_1(a\\cup b)\\)</span>ï¼Œåšä¸€æ¬¡ xor-FWT å¾—åˆ° <span class=\"math inline\">\\(cnt_2(d\\oplus e)\\)</span>ï¼Œä¸­é—´çš„ <span class=\"math inline\">\\(cnt(c)\\)</span> å°±æ˜¯åŸæ ·ã€‚</p>\n<p>å€¼å¾—æ³¨æ„çš„æ˜¯å¯ä»¥åœ¨ä¸€æ¬¡ and-FWT åæŠŠ <span class=\"math inline\">\\(cnt,cnt_1,cnt_2\\)</span> ç›´æ¥å·èµ·æ¥â€”â€”ç”±çŸ©é˜µä¹˜æ³•ç»“åˆå¾‹å¾—ï¼ˆå“ˆå“ˆå¤§ç¬‘äº†ï¼‰ã€‚ä½†æ€ä¹ˆæŠŠ <span class=\"math inline\">\\(f\\)</span> å¡è¿›å»å‘¢ï¼Ÿå¦‚æœä½ æ‹¥æœ‰å°å­¦ç”Ÿçš„æ•°å­¦æ°´å¹³ï¼Œä½ å¯ä»¥å¾ˆå®¹æ˜“åœ°æƒ³åˆ°ç›´æ¥åœ¨ <span class=\"math inline\">\\(cnt,cnt_1,cnt_2\\)</span> IFWT åçš„ç»“æœåˆ†åˆ«å¯¹ä½ä¹˜ä¸Š <span class=\"math inline\">\\(f\\)</span> å³å¯ï¼Œå¾ˆå¯æƒœæˆ‘å¹¶æ²¡æœ‰è¿™æ ·çš„æ•°å­¦èƒ½åŠ› <img src=\"/em/kt.gif\" /></p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int N = 17;\nconst int mod = 1e9 + 7;\nusing arr = std::vector&lt;long long&gt;;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, l;\n    std::cin &gt;&gt; n, l = 1 &lt;&lt; N;\n    std::vector&lt;int&gt; a(n + 1);\n    arr f(l), cnt(l), cnt1(l), cnt2(l);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i], ++cnt[a[i]];\n    f[0] = 0ll, f[1] = 1ll;\n    for (int i = 2; i &lt; l; ++i)\n        f[i] = (f[i - 1] + f[i - 2]) % mod;\n    auto qkp = [&amp;](long long x, int y = mod - 2) &#123;\n        auto res = 1ll;\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    const int inv2 = qkp(2ll);\n    std::vector&lt;arr&gt; mT(2, arr(2)), mI(2, arr(2));\n    auto calc = [&amp;](arr a, arr &amp;f, std::vector&lt;arr&gt; &amp;w) &#123;\n        f = a;\n        for (int len = 2; len &lt;= l; len &lt;&lt;= 1)\n            for (int i = 0; i &lt; l; i += len)\n                for (int p = i, q = i + len / 2; q &lt; i + len; ++p, ++q)\n                    std::tie(f[p], f[q]) = std::make_tuple((f[p] * w[0][0] + f[q] * w[0][1]) % mod, (f[p] * w[1][0] + f[q] * w[1][1]) % mod);\n        return;\n    &#125;;\n    &#123; // orFWT\n        mT[0][0] = 1ll, mT[0][1] = 0ll, mT[1][0] = 1ll, mT[1][1] = 1ll;\n        mI[0][0] = 1ll, mI[0][1] = 0ll, mI[1][0] = mod - 1ll, mI[1][1] = 1ll;\n        std::vector&lt;arr&gt; u(N + 1, arr(l)), d(N + 1, arr(l));\n        for (int i = 0; i &lt; l; ++i)\n            u[__builtin_popcount(i)][i] = cnt[i];\n        for (int i = 0; i &lt;= N; ++i)\n            calc(u[i], u[i], mT);\n        for (int i = 0; i &lt;= N; ++i) &#123;\n            for (int j = 0; j &lt; l; ++j)\n                for (int k = 0; k &lt;= i; ++k)\n                    (d[i][j] += u[k][j] * u[i - k][j]) %= mod;\n            calc(d[i], d[i], mI);\n        &#125;\n        for (int i = 0; i &lt; l; ++i)\n            cnt1[i] = d[__builtin_popcount(i)][i] * f[i] % mod;\n    &#125;\n    &#123; // xor FWT\n        mT[0][0] = 1ll, mT[0][1] = 1ll, mT[1][0] = 1ll, mT[1][1] = mod - 1ll;\n        mI[0][0] = mI[0][1] = mI[1][0] = inv2, mI[1][1] = mod - inv2;\n        calc(cnt, cnt2, mT);\n        for (int i = 0; i &lt; l; ++i)\n            (cnt2[i] *= cnt2[i]) %= mod;\n        calc(cnt2, cnt2, mI);\n        for (int i = 0; i &lt; l; ++i)\n            (cnt2[i] *= f[i]) %= mod;\n    &#125;\n    &#123; // andFWT\n        mT[0][0] = 0ll, mT[0][1] = 1ll, mT[1][0] = 1ll, mT[1][1] = 1ll;\n        mI[0][0] = mod - 1ll, mI[0][1] = 1ll, mI[1][0] = 1ll, mI[1][1] = 0ll;\n        for (int i = 0; i &lt; l; ++i) // è¿™ä¸€æ­¥è¦æ”¾åœ¨ FWT ä¹‹å‰ï¼ŒåŸå› æ˜¾ç„¶ ğŸ¤—\n            (cnt[i] *= f[i]) %= mod;\n        calc(cnt2, cnt2, mT), calc(cnt1, cnt1, mT), calc(cnt, cnt, mT);\n        for (int i = 0; i &lt; l; ++i)\n            cnt[i] = cnt[i] * cnt1[i] % mod * cnt2[i] % mod % mod;\n        calc(cnt, cnt, mI);\n    &#125;\n    long long res = 0ll;\n    for (int i = 0; i &lt; N; ++i)\n        (res += cnt[1 &lt;&lt; i] % mod) %= mod;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n",
            "tags": [
                "é«˜ç»´å‰ç¼€å’Œ",
                "FWT"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20240517/",
            "url": "https://xsc062.netlify.app/20240517/",
            "title": "çŠ¶å‹æšä¸¾å­é›† + é«˜ç»´å‰ç¼€å’Œ",
            "date_published": "2024-05-17T13:19:38.000Z",
            "content_html": "<p>å‡ºç°äº†ï¼Œä½†å‘ç°æ²¡å†™è¿‡ï¼Œæ•…è®°ä¹‹ã€‚</p>\n<span id=\"more\"></span>\n<hr />\n<h3 id=\"çŠ¶å‹æšä¸¾å­é›†\">çŠ¶å‹æšä¸¾å­é›†</h3>\n<p>éœ€æ±‚ï¼šå¯¹äº <strong>æ¯ä¸€ä¸ª</strong> é•¿åº¦ä¸º <span class=\"math inline\">\\(n\\)</span> çš„äºŒè¿›åˆ¶çŠ¶æ€ <span class=\"math inline\">\\(s\\)</span>ï¼Œæšä¸¾å…¶å­çŠ¶æ€ <span class=\"math inline\">\\(\\{ t \\mid t \\operatorname{bitand} s = t \\}\\)</span>ã€‚</p>\n<p>ç›´æ¥æšä¸¾æ‰€æœ‰é•¿åº¦ä¸º <span class=\"math inline\">\\(n\\)</span> çš„çŠ¶æ€ <span class=\"math inline\">\\(t&#39;\\)</span>ï¼Œç„¶ååˆ¤å®šæ˜¯å¦æ»¡è¶³ <span class=\"math inline\">\\(t&#39; \\operatorname{bitand} s = t\\)</span>ï¼Œæ€»æ—¶é—´å¤æ‚åº¦æ˜¯ <span class=\"math inline\">\\(O(2^{2n})\\)</span> çš„ã€‚è€ƒè™‘ä¼˜åŒ–ã€‚</p>\n<p>è€ƒè™‘å¯¹äºæ‰€æœ‰ <span class=\"math inline\">\\(2^n\\)</span> ç§çŠ¶æ€ <span class=\"math inline\">\\(s\\)</span>ï¼Œå‡å¦‚æœ‰ä¸€ç§æ–¹å¼èƒ½å¤Ÿä¸é‡ä¸æ¼åœ°æšä¸¾å‡ºå®ƒä»¬ä¸­æ¯ä¸€ä¸ªçš„æ‰€æœ‰å­çŠ¶æ€ï¼Œé‚£ä¹ˆæ€»æ—¶é—´å¤æ‚åº¦æ˜¯å¤šå°‘å‘¢ï¼Ÿ</p>\n<p>æŠŠæ‰€æœ‰æ•°å¯¹ <span class=\"math inline\">\\((s, t)\\)</span> æ’åˆ—åœ¨ä¸€èµ·ã€‚é‚£ä¹ˆå¯¹äº <span class=\"math inline\">\\(n\\)</span> ä½ä¸­çš„æ¯ä¸€ä½ <span class=\"math inline\">\\(i\\)</span>ï¼Œæšä¸¾æ¯ä¸€ä¸ª <span class=\"math inline\">\\((s&#39;, t&#39;)\\)</span>ã€‚</p>\n<p>é‚£ä¹ˆå­˜åœ¨ä»¥ä¸‹å‡ ç§å¯èƒ½æ€§ï¼š</p>\n<ol type=\"1\">\n<li><span class=\"math inline\">\\({s&#39;}_i=1,{t&#39;}_i=1\\)</span>ï¼›</li>\n<li><span class=\"math inline\">\\({s&#39;}_i=1, {t&#39;}_i=0\\)</span>ï¼›</li>\n<li><span class=\"math inline\">\\({s&#39;}_i=0, {t&#39;}_i = 0\\)</span>ã€‚</li>\n</ol>\n<p>å‡å¦‚æˆ‘ä»¬ç”¨ <span class=\"math inline\">\\(o_i=0,1,2\\)</span> åˆ†åˆ«ä»£è¡¨ç¬¬ä¸€ã€äºŒã€ä¸‰ç§æƒ…å†µï¼Œå®Œå…¨å¯ä»¥ç”¨é•¿åº¦ä¸º <span class=\"math inline\">\\(n\\)</span> çš„ä¸‰è¿›åˆ¶çŠ¶æ€ <span class=\"math inline\">\\(o\\)</span> è¿˜åŸæ•°å¯¹ <span class=\"math inline\">\\((s, t)\\)</span>ã€‚</p>\n<p>ç”±äºè¿™ä¸ª <span class=\"math inline\">\\((s, t)\\)</span> åºåˆ—ä¸­è‚¯å®šæ²¡æœ‰å®Œå…¨ç›¸åŒçš„å…ƒç´ ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œå¯¹äºæ¯ä¸€ä¸ª <span class=\"math inline\">\\((s, t)\\)</span>ï¼Œå…¶ <span class=\"math inline\">\\(o\\)</span> éƒ½å„ä¸ç›¸åŒã€‚</p>\n<p>å› æ­¤ï¼Œ<span class=\"math inline\">\\((s, t)\\)</span> çš„æ•°ç›®ä¸è¶…è¿‡ <span class=\"math inline\">\\(3^n\\)</span>ï¼ˆæ›´å‡†ç¡®åœ°ï¼ŒäºŒè€…å€¼ç›¸ç­‰ï¼‰ã€‚</p>\n<p>åˆå› ä¸ºå¯¹äº <span class=\"math inline\">\\(3^n\\)</span> ä¸ª <span class=\"math inline\">\\(o\\)</span>ï¼Œæ¯ä¸ªéƒ½å¯ä»¥è¿˜åŸå‡ºåˆæ³•çŠ¶æ€ï¼Œæ‰€ä»¥æ€»çš„ <span class=\"math inline\">\\((s, t)\\)</span> æ•°ç›®åº”æ°å¥½ä¸º <span class=\"math inline\">\\(3^n\\)</span>ã€‚</p>\n<p>ä¹Ÿå°±æ˜¯è¯´ï¼Œå‡å¦‚æœ‰ä¸€ç§æ–¹å¼èƒ½å¤Ÿä¸é‡ä¸æ¼åœ°æšä¸¾å‡ºæ¯ä¸€ä¸ª <span class=\"math inline\">\\(s\\)</span> çš„æ‰€æœ‰å­çŠ¶æ€ <span class=\"math inline\">\\(t\\)</span>ï¼Œå¯ä»¥åšåˆ°å‡æ‘Š <span class=\"math inline\">\\(O(3^n)\\)</span>ã€‚</p>\n<p>æ¥ä¸‹æ¥æ¢è®¨è¿™ç§æšä¸¾æ–¹å¼ã€‚ç›´æ¥ç»™å‡ºç»“è®ºï¼š</p>\n<pre class=\"cpp\"><code>for (int t = s; t; t = (t - 1) &amp; s);</code></pre>\n<p>å…¶å®ä¸éš¾ç†è§£ã€‚ä» <span class=\"math inline\">\\(t\\)</span> çš„å®šä¹‰å‡ºå‘å³ <span class=\"math inline\">\\(t \\operatorname{bitand} s = t\\)</span>ï¼Œé‡ç‚¹ç†è§£ <span class=\"math inline\">\\(t\\gets (t - 1)\\operatorname{bitand} s\\)</span> è¿™ä¸€æ­¥ã€‚</p>\n<p>åˆ†ä¸¤ç§æƒ…å†µè®¨è®ºï¼š</p>\n<ol type=\"1\">\n<li><p><span class=\"math inline\">\\(t-1\\)</span> è¾ƒ <span class=\"math inline\">\\(t\\)</span> å‘ç”Ÿé€€ä½ï¼š</p>\n<p>å› ä¸ºåªå‡ <span class=\"math inline\">\\(1\\)</span>ï¼Œæ‰€ä»¥æœ«ä½ä¸€å®šå‘ç”Ÿé€€ä½ã€‚</p>\n<p>å¦‚æœå‘ç”Ÿè¿ç»­é€€ä½ï¼Œä¸€å®šæ˜¯å› ä¸ºæœ«ç«¯æœ‰è¿ç»­çš„ <span class=\"math inline\">\\(0\\)</span>ã€‚å¯¹äºç¬¬ä¸€ä¸ª <span class=\"math inline\">\\(1\\)</span>ï¼ˆè®°ä¸ºç¬¬ <span class=\"math inline\">\\(j\\)</span> ä½ï¼‰ï¼Œå·²ç»æšä¸¾å®Œäº†åœ¨ <span class=\"math inline\">\\(j\\)</span> åŠæ›´é«˜ä½å›ºå®šåœ¨å½“å‰çŠ¶æ€ä¸‹çš„æ‰€æœ‰çŠ¶æ€ã€‚</p>\n<p>åˆ™åº”æœ‰ï¼š</p>\n<ul>\n<li>æ¯” <span class=\"math inline\">\\(j\\)</span> æ›´é«˜çš„æ•°ä½ï¼Œæœªå—åˆ°é€€ä½å¸¦æ¥çš„è¿ç»­å½±å“çš„ä½ä¸å˜ï¼›</li>\n<li>ç¬¬ <span class=\"math inline\">\\(j\\)</span> ä½ <span class=\"math inline\">\\(1\\to 0\\)</span>ï¼›</li>\n<li>ä»ç¬¬ <span class=\"math inline\">\\(j\\)</span> ä½ä¸€ç›´åˆ°æœ«ä½éƒ½æœ‰ <span class=\"math inline\">\\(0\\to 1\\)</span>ã€‚</li>\n</ul>\n<p>æ­¤æ—¶ä¸ <span class=\"math inline\">\\(s\\)</span> è¿›è¡Œ <span class=\"math inline\">\\(\\operatorname{bitand}\\)</span>ï¼Œå¾—åˆ°æ¯” <span class=\"math inline\">\\(j\\)</span> æ›´é«˜çš„æ•°ä½ä¸å˜ã€<span class=\"math inline\">\\(j\\)</span> ä½ <span class=\"math inline\">\\(1\\to 0\\)</span>ã€æ¯” <span class=\"math inline\">\\(j\\)</span> æ›´ä½çš„æ•°ä½å˜ä¸ºæŠµç€ <span class=\"math inline\">\\(s\\)</span> å¯¹åº”æ•°ä½çš„æœ€å¤§çŠ¶æ€ã€‚</p>\nç»¼ä¸Šï¼Œè¿™æ˜¯æ¯” <span class=\"math inline\">\\(t\\)</span> å°çš„ç¬¬ä¸€ä¸ªåˆæ³•çŠ¶æ€ã€‚</li>\n<li><p><span class=\"math inline\">\\(t-1\\)</span> è¾ƒ <span class=\"math inline\">\\(t\\)</span> ä¸å‘ç”Ÿé€€ä½ï¼š</p>\n<p>æ ¹æ®ä¸Šé¢çš„è®¨è®ºï¼Œå…¶å®å°±æ˜¯æœ«ä½ä¸é€€ä½ï¼Œå³æœ«ä½ <span class=\"math inline\">\\(1\\to 0\\)</span>ã€‚æ˜¾ç„¶æ˜¯æ¯” <span class=\"math inline\">\\(t\\)</span> æ›´å°çš„ç¬¬ä¸€ä¸ªåˆæ³•çŠ¶æ€ã€‚</p></li>\n</ol>\n<p>ç»¼ä¸Šï¼Œå®ç°äº†ä»å¤§åˆ°å°ä¾æ¬¡æšä¸¾åˆæ³•çŠ¶æ€ï¼Œå› æ­¤ä¸é‡ä¸æ¼ã€‚</p>\n<hr />\n<h3 id=\"æšä¸¾è¡¥é›†\">æšä¸¾è¡¥é›†</h3>\n<p>çœ‹äº†å‡ ä¸ªæ¯”è¾ƒæŠ½è±¡çš„åšå®¢ï¼Œä½†æ˜¯æˆ‘è§‰å¾—ä¸å¦‚ç›´æ¥æŠŠ <span class=\"math inline\">\\(s\\)</span> å¼‚æˆ–ä¸€ä¸‹ <span class=\"math inline\">\\(2^n-1\\)</span> ç„¶åæšä¸¾å­é›†ã€‚</p>\n<hr />\n<h3 id=\"å­é›†å’Œ-é«˜ç»´å‰ç¼€å’Œ\">å­é›†å’Œ / é«˜ç»´å‰ç¼€å’Œ</h3>\n<p>é¦–å…ˆç†è§£ä¸€ä¸‹ä»€ä¹ˆæ˜¯é«˜ç»´å‰ç¼€å’Œã€‚å®é™…ä¸Šå…¨ç§°åº”ä¸ºè¾¹é•¿ä¸º <span class=\"math inline\">\\(2\\)</span> çš„é«˜ç»´ç©ºé—´å‰ç¼€å’Œã€‚å…¶å®å°±æ˜¯æ±‚æ‰€æœ‰çŠ¶æ€çš„å­é›†å’Œï¼Œè¿ç”¨äº†å‰ç¼€å’Œçš„æ€æƒ³æ•…å”¤é«˜ä½å‰ç¼€å’Œ / é€ç»´å‰ç¼€å’Œã€‚</p>\n<p>å³åœ¨ <span class=\"math inline\">\\(n=2\\)</span> çš„æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬å‘ç°æˆ‘ä»¬å¯ä»¥å°† <span class=\"math inline\">\\(k\\)</span> ç»´å‰ç¼€å’Œçœ‹ä½œåœ¨ <span class=\"math inline\">\\(k\\)</span> ä½äºŒè¿›åˆ¶æ•°ä¸Šåšå­é›†å…ƒç´ æ±‚å’Œã€‚æ˜¾ç„¶æ ¹æ®æšä¸¾å­é›†æœ‰ <span class=\"math inline\">\\(3^k\\)</span> çš„åšæ³•ï¼Œä½†è¿˜èƒ½æ›´å¿«ã€‚</p>\n<pre class=\"cpp\"><code>std::copy(a.begin(), a.end(), s.begin());\nfor (int i = 0; i &lt; k; ++i)\n    for (int j = 0; j &lt; l; ++j)\n        if ((j &gt;&gt; i) &amp; 1)\n            s[j] += s[j ^ (1 &lt;&lt; i)];</code></pre>\n<p>å…ˆæšä¸¾ <span class=\"math inline\">\\(i\\)</span> æ˜¯å› ä¸ºä½¿ç”¨é«˜ç»´å‰ç¼€å’Œçš„é¢˜ç›®ä¸€èˆ¬æ—¶é™å¡å¾—æ¯”è¾ƒæ­»ï¼Œéœ€è¦ä½¿ç”¨å†…å­˜è¿ç»­è®¿é—®å°½é‡å‡å°å¸¸æ•°ã€‚</p>\n<p>å¯¹äºçŠ¶æ€ <span class=\"math inline\">\\(j\\)</span>ï¼Œè€ƒè™‘æšä¸¾å…¶æ¯ä¸€ç»´ä¸Šçš„å€¼ï¼Œåˆ™ <span class=\"math inline\">\\(s_j=a_j+\\sum s_{j\\bigoplus 2^i}\\)</span>ã€‚æ˜“å‘ç°è¿™å¯ä»¥ä¸é‡ä¸æ¼åœ°è¦†ç›–æ‰€æœ‰å­é›†ã€‚</p>\n<p>è¿™ç§æ€æƒ³åœ¨ä¸€äº›çŠ¶æ€å‹ç¼©çš„é¢˜ç›®ä¸­ä¹Ÿæœ‰åº”ç”¨ï¼Œå…·ä½“è§ <a href=\"/20231117#1\">æ­¤</a>ã€‚</p>\n<h3 id=\"é«˜ç»´åç¼€å’Œ\">é«˜ç»´åç¼€å’Œ</h3>\n<p>ä»å¤§å¾€å°æšä¸¾ <span class=\"math inline\">\\(j\\)</span>ï¼Œå¯¹äº <span class=\"math inline\">\\(j\\)</span> ä¸­å€¼ä¸º <code>false</code> çš„ç»´ <span class=\"math inline\">\\(i\\)</span>ï¼Œä»¤ <span class=\"math inline\">\\(s_j=a_j+\\sum s_{j+2^i}\\)</span> å³å¯ã€‚</p>\n<pre class=\"cpp\"><code>std::copy(a.begin(), a.end(), s.begin());\nfor (int i = 0; i &lt; k; ++i)\n    for (int j = l - 1; ~j; --j)\n        if (!((j &gt;&gt; i) &amp; 1))\n            s[j] += s[j ^ (1 &lt;&lt; i)];</code></pre>\n",
            "tags": [
                "çŠ¶å‹",
                "é«˜ç»´å‰ç¼€å’Œ"
            ]
        }
    ]
}