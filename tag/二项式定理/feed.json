{
    "version": "https://jsonfeed.org/version/1",
    "title": "null • All posts by \"二项式定理\" tag",
    "description": "",
    "home_page_url": "https://xsc062.netlify.app",
    "items": [
        {
            "id": "https://xsc062.netlify.app/20250407/",
            "url": "https://xsc062.netlify.app/20250407/",
            "title": "组合计数",
            "date_published": "2025-04-07T06:57:14.000Z",
            "content_html": "<p>毅毅：统计不是数学（断章取义 ed）。<del>故删掉了数学标签。</del> 其实并没有。</p>\n<span id=\"more\"></span>\n<hr />\n<h2 id=\"a.-二分图染色\">A. 二分图染色</h2>\n<p><a href=\"http://222.180.160.110:61235/contest/6181/problem/1\" class=\"uri\">http://222.180.160.110:61235/contest/6181/problem/1</a></p>\n<p>首先只看红色。显然一个左部点最多只能用红边连接一个右部点，反之同理。把左部点视为下标，其用红边相连的右部点视为值，则一个合法的方案为 <span class=\"math inline\">\\(n\\)</span> 的只保留一部分元素的排列。显然为 <span class=\"math inline\">\\(f(n)=\\sum\\limits_{i=0}^nC_n^i\\cdot A_n^i\\)</span>。</p>\n<p>再加上蓝色，<span class=\"math inline\">\\(f^2(n)\\)</span> 会给一条边涂两种颜色，故钦定有两种颜色的边数，容斥得到 <span class=\"math inline\">\\(\\sum\\limits_{i=0}^n(-1)^i\\cdot C_n^i\\cdot A_n^i\\cdot f^2(n-i)\\)</span>。发现 <span class=\"math inline\">\\(f\\)</span> 的计算可能需要优化一下。考虑已经知道 <span class=\"math inline\">\\(f(n-1)\\)</span>，此时对于新增的第 <span class=\"math inline\">\\(n\\)</span> 对点：</p>\n<ol type=\"1\">\n<li>任意连边（显然两个当中只能有一个点发出边），共有 <span class=\"math inline\">\\(2n-1\\)</span> 种方案，因为 <span class=\"math inline\">\\((n, n)\\)</span> 会被算重。</li>\n<li>不连，共 <span class=\"math inline\">\\(1\\)</span> 种方案。</li>\n<li>发现 1 中可能连到已经有连边的点上了，新边的目的地有 <span class=\"math inline\">\\(n-1\\)</span> 个选项，目的地原本连接的点也有 <span class=\"math inline\">\\(n-1\\)</span> 个选项，去掉两边共 <span class=\"math inline\">\\(4\\)</span> 个点，非法的即为 <span class=\"math inline\">\\((n-1)^2\\cdot f(n-2)\\)</span>。</li>\n</ol>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 1e9 + 7;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;long long&gt; f(n + 1), fac(n + 1), inv(n + 1);\n    f[0] = 1ll, f[1] = 2ll;\n    fac[0] = 1ll, fac[1] = 1ll, inv[0] = 1ll;\n    for (int i = 2; i &lt;= n; ++i) &#123;\n        fac[i] = fac[i - 1] * i % mod;\n        f[i] = (f[i - 1] * 2 * i % mod + mod - f[i - 2] * (i - 1) % mod * (i - 1) % mod) % mod;\n    &#125;\n    auto qkp = [](long long x, int y) &#123;\n        auto res = 1ll;\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    inv[n] = qkp(fac[n], mod - 2);\n    for (int i = n - 1; i; --i)\n        inv[i] = inv[i + 1] * (i + 1) % mod;\n    auto C = [&amp;](int n, int m) &#123;\n        return fac[n] * inv[n - m] % mod * inv[m] % mod;\n    &#125;;\n    auto A = [&amp;](int n, int m) &#123;\n        return fac[n] * inv[n - m] % mod;\n    &#125;;\n    long long res = 0ll;\n    for (int i = 0, k = 1; i &lt;= n; ++i, k = mod - k)\n        (res += k * C(n, i) % mod * A(n, i) % mod * f[n - i] % mod * f[n - i]) %= mod;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"b.-七选五\">B. 七选五</h2>\n<p><a href=\"http://222.180.160.110:61235/contest/6181/problem/2\" class=\"uri\">http://222.180.160.110:61235/contest/6181/problem/2</a></p>\n<p>首先 <span class=\"math inline\">\\(p\\)</span> 固定，钦定有 <span class=\"math inline\">\\(x\\)</span> 个数相等，有 <span class=\"math inline\">\\(C_k^x\\)</span> 个方案，剩下的就是从 <span class=\"math inline\">\\(n-x\\)</span> 个元素里选出 <span class=\"math inline\">\\(k-x\\)</span> 个来错排，考虑钦定相同的个数来容斥：</p>\n<p><span class=\"math display\">\\[\n\\sum_{i=0}^{k-x}(-1)^i\\cdot C_{k-x}^i\\cdot A_{n-x-i}^{k-x-i}\n\\]</span></p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 1e9 + 7;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, k, x;\n    std::cin &gt;&gt; n &gt;&gt; k &gt;&gt; x;\n    std::vector&lt;long long&gt; fac(n + 1), inv(n + 1);\n    fac[0] = 1ll, fac[1] = 1ll, inv[0] = 1ll;\n    for (int i = 2; i &lt;= n; ++i)\n        fac[i] = fac[i - 1] * i % mod;\n    auto qkp = [](long long x, int y) &#123;\n        auto res = 1ll;\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    inv[n] = qkp(fac[n], mod - 2);\n    for (int i = n - 1; i; --i)\n        inv[i] = inv[i + 1] * (i + 1) % mod;\n    auto C = [&amp;](int n, int m) &#123;\n        return fac[n] * inv[n - m] % mod * inv[m] % mod;\n    &#125;;\n    auto A = [&amp;](int n, int m) &#123;\n        return fac[n] * inv[n - m] % mod;\n    &#125;;\n    long long res = C(k, x), sum = 0ll;\n    for (int i = 0, p = 1; i &lt;= k - x; ++i, p = mod - p)\n        (sum += p * C(k - x, i) % mod * A(n - x - i, k - x - i) % mod) %= mod;\n    std::cout &lt;&lt; res * sum % mod &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"d.-硬币购物\">D. 硬币购物</h2>\n<p><a href=\"http://222.180.160.110:61235/contest/6181/problem/4\" class=\"uri\">http://222.180.160.110:61235/contest/6181/problem/4</a></p>\n<p>每次多重背包会超时，考虑用钦定每种硬币是否超额来容斥。令 <span class=\"math inline\">\\(f_s\\)</span> 表示凑出 <span class=\"math inline\">\\(s\\)</span> 的方案数（完全背包），那么 <span class=\"math inline\">\\(f_{s-c_1\\times (d_1 + 1)}\\)</span> 就表示钦定第 1 种硬币超额时凑出 <span class=\"math inline\">\\(s\\)</span> 的方案数，以此类推。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int c[4], T, m = 1e5;\n    std::vector&lt;long long&gt; f(m + 1);\n    f[0] = 1;\n    for (int i = 0; i &lt; 4; ++i) &#123;\n        std::cin &gt;&gt; c[i];\n        for (int j = c[i]; j &lt;= m; ++j)\n            f[j] += f[j - c[i]];\n    &#125;\n    std::cin &gt;&gt; T;\n    for (int d[4], m; T--; ) &#123;\n        for (int i = 0; i &lt; 4; ++i)\n            std::cin &gt;&gt; d[i];\n        std::cin &gt;&gt; m;\n        long long res = 0ll;\n        for (int i = 0; i &lt; (1 &lt;&lt; 4); ++i) &#123;\n            int s = m;\n            for (int j = 0; j &lt; 4; ++j)\n                if ((i &gt;&gt; j) &amp; 1)\n                    s -= (d[j] + 1) * c[j];\n            if (s &gt;= 0) &#123;\n                int k = (__builtin_popcount(i) &amp; 1) ? -1 : 1;\n                res += k * f[s];\n            &#125;\n        &#125;\n        std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"e.-distinct-multiples\">E. Distinct Multiples</h2>\n<p><a href=\"http://222.180.160.110:61235/contest/6181/problem/5\" class=\"uri\">http://222.180.160.110:61235/contest/6181/problem/5</a></p>\n<p>推式子题。题意转化为，给定 <span class=\"math inline\">\\(n\\)</span> 个位置可选的值集合，要求任意两个位置值不等，问方案数。</p>\n<p>如果把两个位置取等视作在团上选中边，那么有朴素做法钦定选边的集合 <span class=\"math inline\">\\(S\\)</span> 然后容斥，考虑它们构成的连通块 <span class=\"math inline\">\\(\\{s\\} \\subseteq S\\)</span>，有 <span class=\"math inline\">\\(res=\\sum\\limits_{S\\subseteq V}(-1)^{|S|}\\cdot \\prod\\limits_{s_i} \\left\\lfloor \\frac m{\\operatorname{lcm} s_i} \\right\\rfloor\\)</span>。</p>\n<p>有个很神奇的操作是把 <span class=\"math inline\">\\(S\\)</span> 丢掉，直接枚举 <span class=\"math inline\">\\(\\{s\\}\\)</span> 尝试子集 DP。有：<span class=\"math inline\">\\(res=\\sum\\limits_{\\{s\\}}\\prod\\limits_s f(s)\\cdot\\left\\lfloor \\frac m{\\operatorname{lcm} s} \\right\\rfloor\\)</span>。其中 <span class=\"math inline\">\\(f(s)\\)</span> 表示选取一个 <span class=\"math inline\">\\(s\\)</span> 的导出子图的容斥系数之和，其中次数为导出子图中边数。</p>\n<p>怎么把 <span class=\"math inline\">\\(f\\)</span> 算出来呢？容易发现其值只与 <span class=\"math inline\">\\(|s|\\)</span> 有关，考虑钦定与 <span class=\"math inline\">\\(1\\)</span> 连通的点数容斥，则有：</p>\n<p><span class=\"math display\">\\[\nf(n)=\\sum\\limits_{i=0}^{n - 1} (-1)^i \\times C_{n-1}^{i-1} \\times f(i) \\cdot \\sum_{j=0}^{m\\gets i\\times (i-1)\\div 2} (-1)^j\\cdot C_m^j\n\\]</span></p>\n<p>我们知道，二项式定理取 <span class=\"math inline\">\\(a=1, b = -1\\)</span> 有 <span class=\"math inline\">\\(0^m=[m=0]=\\sum_{j=0}^m(-1)^j\\cdot C_m^j\\)</span>，代入得：</p>\n<p><span class=\"math display\">\\[\n\\begin{aligned}\nf(n)&amp;=\\sum\\limits_{i=0}^{n - 1} (-1)^i \\times C_{n-1}^{n-i-1} \\times f(n-i)\\cdot [m=0\\iff i=1]\\\\\n&amp;=(1 - n)\\cdot f(n-1)\n\\end{aligned}\n\\]</span></p>\n<p>然后就能线性求出。再用一个子集 DP，为了保证顺序枚举最小的未被确定的点所在连通块进行转移。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 998244353;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, l;\n    long long m;\n    std::cin &gt;&gt; n &gt;&gt; m, l = 1 &lt;&lt; n;\n    std::vector&lt;long long&gt; d(n), f(n + 1), dp(l), g(l);\n    f[1] = 1ll;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; d[i - 1];\n        if (i &gt;= 2)\n            f[i] = (1 + mod - i) * f[i - 1] % mod;\n        // printf(&quot;f[%d] = %lld\\n&quot;, i, f[i]);\n    &#125;\n    for (int i = 0; i &lt; l; ++i) &#123;\n        long long now = 1ll;\n        for (int j = 0; j &lt; n; ++j)\n            if ((i &gt;&gt; j) &amp; 1) &#123;\n                if (now / std::__gcd(now, d[j]) &gt; m / d[j])\n                    goto nosol;\n                now = now / std::__gcd(now, d[j]) * d[j];\n            &#125;\n        g[i] = (m / now) % mod;\n        // printf(&quot;lcm = %lld, g[%d] = %lld\\n&quot;, now, i, g[i]);\n    nosol: ;\n    &#125;\n    dp[0] = 1ll;\n    auto lowbit = [](int x) &#123;\n        return x &amp; -x;\n    &#125;;\n    for (int i = 1; i &lt; l; ++i) &#123;\n        int to = std::__lg(lowbit(i));\n        for (int j = i; j; j = (j - 1) &amp; i)\n            if ((j &gt;&gt; to) &amp; 1)\n                (dp[i] += dp[i ^ j] * f[__builtin_popcount(j)] % mod * g[j] % mod) %= mod;\n    &#125;\n    std::cout &lt;&lt; dp[l - 1] &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"f.-permutation\">F. Permutation</h2>\n<p><a href=\"http://222.180.160.110:61235/contest/6181/problem/6\" class=\"uri\">http://222.180.160.110:61235/contest/6181/problem/6</a></p>\n<p>如果全是 <code>&lt;</code>，方案数为 <span class=\"math inline\">\\(1\\)</span>。</p>\n<p>现在把其中一些 <code>&lt;</code> 变成 <code>?</code>，比如 <code>&lt;&lt;??&lt;?&lt;&lt;&lt;&lt;</code> 的方案数，<del>太好了是多重集排列，我们没救了</del> 显然被 <code>&lt;</code> 连接起来的一段元素只有一种排列方式，所以可以视为多重集排列，方案数为 <span class=\"math inline\">\\(\\dfrac {11!}{3!\\times 2!\\times 5!}\\)</span>。</p>\n<p>似乎只需要枚举把 <code>&gt;</code> 变成 <code>&lt;</code> 或 <code>=</code> 的 <span class=\"math inline\">\\(2^k\\)</span> 种情况再计算就可以了，可惜 <span class=\"math inline\">\\(k\\)</span> 有点大。但我们发现它在一定程度上是没有后效性的，比如 <code>&lt;&lt;??&lt;</code> 和 <code>&lt;&lt;?&lt;&lt;</code>，前面的 <code>&lt;&lt;</code> 不会对后面的内容带来影响。</p>\n<p>故令 <span class=\"math inline\">\\(f_i\\)</span> 表示对于前 <span class=\"math inline\">\\(i\\)</span> 个元素的方案数，枚举最后一个被钦定为 <code>?</code> 的 <code>&gt;</code> <span class=\"math inline\">\\(j\\)</span>（即 <span class=\"math inline\">\\([j + 1, i-1]\\)</span> 间的 <code>&gt;</code> 都被替换为 <code>&lt;</code>），带上容斥系数，有 <span class=\"math inline\">\\(f_i=\\sum\\limits_{s_j=\\texttt{&#39;&gt;&#39;}}(-1)^{cnt_\\texttt{&#39;&gt;&#39;}[j + 1, i - 1]}\\times f_j\\times\\dfrac1{(i-j)!}\\)</span>。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 1e9 + 7;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;long long&gt; fac(n + 1), inv(n + 1);\n    fac[0] = 1ll, inv[0] = 1ll;\n    for (int i = 1; i &lt;= n; ++i)\n        fac[i] = fac[i - 1] * i % mod;\n    auto qkp = [](long long x, int y) &#123;\n        auto res = 1ll;\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    inv[n] = qkp(fac[n], mod - 2);\n    for (int i = n - 1; i; --i)\n        inv[i] = inv[i + 1] * (i + 1) % mod;\n    std::vector&lt;char&gt; s(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; s[i];\n    std::vector&lt;long long&gt; f(n + 1);\n    s[0] = &#39;&gt;&#39;, f[0] = 1ll;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        int cnt = 0;\n        for (int j = i - 1; ~j; --j)\n            if (s[j] == &#39;&gt;&#39;) &#123;\n                long long k = (cnt &amp; 1) ? mod - 1 : 1;\n                (k *= f[j]) %= mod, (k *= inv[i - j]) %= mod;\n                (f[i] += k) %= mod;\n                ++cnt;\n            &#125;\n        // printf(&quot;f[%d] = %lld\\n&quot;, i, f[i]);\n    &#125;\n    std::cout &lt;&lt; f[n] * fac[n] % mod &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<p><em>忳郁邑余侘傺兮，余独穷困乎此时也。</em></p>\n<hr />\n<h2 id=\"h.-k-perm-counting\">H. ~K Perm Counting</h2>\n<p><a href=\"http://222.180.160.110:61235/contest/6181/problem/8\" class=\"uri\">http://222.180.160.110:61235/contest/6181/problem/8</a></p>\n<p>考虑钦定令几个元素不满足条件进行容斥，即答案为 <span class=\"math inline\">\\(\\sum\\limits_{i=0}^n (-1)^i\\cdot f(i)\\)</span>。但我们发现 <span class=\"math inline\">\\([n-k,n+k]\\)</span> 都有两个不能选的值，直接取 <span class=\"math inline\">\\(f(i)=\\prod 2\\)</span> 肯定会选到相同值，一个自然（？）的想法是再容斥一遍，可惜手玩一下发现似乎容不动。考虑把玩意儿拍在棋盘上：</p>\n<figure>\n<img src=\"1.png\" alt=\"以 k=2 为例\" /><figcaption>以 <span class=\"math inline\">\\(k=2\\)</span> 为例</figcaption>\n</figure>\n<p>其中 <span class=\"math inline\">\\(\\times\\)</span> 是非法格子，边是非法格子间的不同选关系，同颜色的边隶属同一条链。容易发现如果棋盘继续扩大，这些链还会继续延长。</p>\n<p>会发现这些链互不干扰，就是说我选了这条链上的某个点和链外的点没有任何关系（显然）。把这些链首尾相连拼起来，要做的就是拼接处可以选相邻，其余位置不能选相邻，选出来 <span class=\"math inline\">\\(i\\)</span> 个的方案数。提前预处理出来整个序列，令 <span class=\"math inline\">\\(tag_j\\)</span> 表示 <span class=\"math inline\">\\(j\\)</span> 是否能和 <span class=\"math inline\">\\(j-1\\)</span> 同选，设 <span class=\"math inline\">\\(dp_{j,i,0/1}\\)</span> 表示 DP 到了 <span class=\"math inline\">\\(j\\)</span>，已经选了 <span class=\"math inline\">\\(i\\)</span> 个数，第 <span class=\"math inline\">\\(j\\)</span> 个元素（不）选的方案数，那么有：</p>\n<p><span class=\"math display\">\\[\ndp_{j,i,0} = dp_{j - 1, i, 0} + dp_{j-1, i, 1}\\\\\ndp_{j,i,1} = \\begin{cases}\ndp_{j-1, i - 1, 1} + dp_{j-1,i - 1,0}&amp;tag_j=1\n\\\\\ndp_{j-1,i,0}&amp;\\text{otherwise}\n\\end{cases}\n\\]</span></p>\n<p>大力 DP 即可。<span class=\"math inline\">\\(f(i)\\)</span> 即为 <span class=\"math inline\">\\((n-i)!\\times (dp_{m, i, 0} + dp_{m, i, 1})\\)</span>，其中 <span class=\"math inline\">\\(m\\)</span> 为总链长。</p>\n<details>\n<p>注意不滚动可能会 MLE <img src=\"/em/kt.gif\" /></p>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 924844033;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, k;\n    std::cin &gt;&gt; n &gt;&gt; k;\n    std::vector&lt;int&gt; tag(1);\n    std::vector&lt;long long&gt; fac(n + 1);\n    std::vector&lt;std::vector&lt;int&gt; &gt; vis(n + 1, std::vector&lt;int&gt; (n + 1));\n    auto calc = [&amp;](int i, int j, int s) &#123;\n        tag.push_back(1);\n        for (; ; s ^= 1) &#123;\n            // printf(&quot;(%d, %d) &quot;, i, j);\n            vis[i][j] = 1;\n            if (!s) &#123;\n                i = j + k;\n                if (i &lt;= n)\n                    tag.push_back(0);\n                else\n                    break;\n            &#125;\n            else &#123;\n                j = i + k;\n                if (j &lt;= n)\n                    tag.push_back(0);\n                else\n                    break;\n            &#125;\n        &#125;\n        // puts(&quot;&quot;);\n        return;\n    &#125;;\n    fac[0] = 1ll;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        fac[i] = fac[i - 1] * i % mod;\n        int j = i - k;\n        if (j &gt;= 1 &amp;&amp; !vis[i][j])\n            calc(i, j, 1);\n        j = i + k;\n        if (j &lt;= n &amp;&amp; !vis[i][j])\n            calc(i, j, 0);\n    &#125;\n    int m = (int)tag.size() - 1;\n    // printf(&quot;m = %d\\n&quot;, m);\n    std::vector&lt;std::vector&lt;std::vector&lt;long long&gt; &gt; &gt; dp(2, std::vector&lt;std::vector&lt;long long&gt; &gt; (n + 1, std::vector&lt;long long&gt; (2)));\n    dp[0][0][0] = 1ll;\n    for (int j = 1, now = 1; j &lt;= m; ++j, now ^= 1) &#123;\n        for (int i = 0; i &lt;= n &amp;&amp; i &lt;= j; ++i) &#123;\n            dp[now][i][0] = dp[!now][i][0];\n            dp[now][i][1] = 0ll;\n            if (i) &#123;\n                (dp[now][i][0] += dp[!now][i][1]) %= mod;\n                dp[now][i][1] = dp[!now][i - 1][0];\n                if (tag[j]) &#123;\n                    (dp[now][i][1] += dp[!now][i - 1][1]) %= mod;\n                    // assert(0);\n                &#125;\n            &#125;\n            // printf(&quot;dp[%d][%d] = %lld / %lld\\n&quot;, j, i, dp[j][i][0], dp[j][i][1]);\n        &#125;\n    &#125;\n    long long res = 0ll;\n    for (int i = 0, p = 1; i &lt;= n; ++i, p = mod - p)\n        (res += p * fac[n - i] % mod * (dp[m &amp; 1][i][0] + dp[m &amp; 1][i][1]) % mod) %= mod;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"a---positions-in-permutations\">A - Positions in Permutations</h2>\n<p><a href=\"https://codeforces.com/problemset/problem/285/E\" class=\"uri\">https://codeforces.com/problemset/problem/285/E</a></p>\n<p><del>（看向上一题）这照片是你吗？</del></p>\n<p>在上一题的基础上，令 <span class=\"math inline\">\\(k=1\\)</span>。但是有个小小的问题——所求的「至少」不为 <span class=\"math inline\">\\(0\\)</span>，无法简单容斥。具体地，如果一个排列一共有 <span class=\"math inline\">\\(p\\)</span> 个非法排列，那么它会被 <span class=\"math inline\">\\(f(i)\\)</span> 统计 <span class=\"math inline\">\\(C_p^i\\)</span> 次。令 <span class=\"math inline\">\\(g(p)\\)</span> 表示非法格子数恰好为 <span class=\"math inline\">\\(p\\)</span> 的排列的真实数量，则 <span class=\"math inline\">\\(f(i)=\\sum\\limits_{j=i}^n C_j^i\\cdot g(j)\\)</span>，二项式反演即可得到真实值 <span class=\"math inline\">\\(g(m)=\\sum\\limits_{j=m}^n (-1)^{j-m}\\cdot C_j^m\\cdot f(j)\\)</span>。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 1e9 + 7;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, k;\n    std::cin &gt;&gt; n &gt;&gt; k;\n    std::vector&lt;int&gt; tag(1);\n    std::vector&lt;long long&gt; fac(n + 1), inv(n + 1);\n    std::vector&lt;std::vector&lt;int&gt; &gt; vis(n + 1, std::vector&lt;int&gt; (n + 1));\n    auto calc = [&amp;](int i, int j, int s) &#123;\n        tag.push_back(1);\n        for (; i &lt;= n &amp;&amp; j &lt;= n; s ^= 1) &#123;\n            vis[i][j] = 1;\n            if (!s) &#123;\n                i = j + 1;\n                if (i &lt;= n)\n                    tag.push_back(0);\n            &#125;\n            else &#123;\n                j = i + 1;\n                if (j &lt;= n)\n                    tag.push_back(0);\n            &#125;\n        &#125;\n        return;\n    &#125;;\n    auto qkp = [&amp;](long long x, int y) &#123;\n        auto res = 1ll;\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    fac[0] = 1ll, inv[0] = 1ll;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        fac[i] = fac[i - 1] * i % mod;\n        int j = i - 1;\n        if (j &gt;= 1 &amp;&amp; !vis[i][j])\n            calc(i, j, 1);\n        j = i + 1;\n        if (j &lt;= n &amp;&amp; !vis[i][j])\n            calc(i, j, 0);\n    &#125;\n    inv[n] = qkp(fac[n], mod - 2);\n    for (int i = n - 1; i; --i)\n        inv[i] = inv[i + 1] * (i + 1) % mod;\n    int m = (int)tag.size() - 1;\n    std::vector&lt;std::vector&lt;std::vector&lt;long long&gt; &gt; &gt; dp(2, std::vector&lt;std::vector&lt;long long&gt; &gt; (n + 1, std::vector&lt;long long&gt; (2)));\n    dp[0][0][0] = 1ll;\n    for (int j = 1, now = 1; j &lt;= m; ++j, now ^= 1) &#123;\n        for (int i = 0; i &lt;= n &amp;&amp; i &lt;= j; ++i) &#123;\n            dp[now][i][0] = dp[!now][i][0];\n            dp[now][i][1] = 0ll;\n            if (i) &#123;\n                (dp[now][i][0] += dp[!now][i][1]) %= mod;\n                dp[now][i][1] = dp[!now][i - 1][0];\n                if (tag[j])\n                    (dp[now][i][1] += dp[!now][i - 1][1]) %= mod;\n            &#125;\n        &#125;\n    &#125;\n    auto C = [&amp;](int n, int m) &#123;\n        return fac[n] * inv[n - m] % mod * inv[m] % mod;\n    &#125;;\n    long long res = 0ll;\n    for (int i = k, p = 1; i &lt;= n; ++i, p = mod - p) &#123;\n        // printf(&quot;%d: %lld\\n&quot;, i, C(i, k) * fac[n - i] % mod * (dp[m &amp; 1][i][0] + dp[m &amp; 1][i][1]) % mod);\n        (res += p * C(i, k) % mod * fac[n - i] % mod * (dp[m &amp; 1][i][0] + dp[m &amp; 1][i][1]) % mod) %= mod;\n    &#125;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"d---all-pairs-similarity-p\">D - All Pairs Similarity P</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P11458\" class=\"uri\">https://www.luogu.com.cn/problem/P11458</a></p>\n<p>省流：求 <span class=\"math inline\">\\(\\forall\\,i,f_i=\\sum\\limits_{j=1}^n \\dfrac{|a_i\\cap a_j|}{|a_i\\cup a_j|}\\)</span>。</p>\n<p>首先分离常数，有：</p>\n<p><span class=\"math display\">\\[\n\\begin{aligned}\nf_i&amp;=\\sum\\limits_{j=1}^n \\dfrac{|a_i\\cap a_j|}{|a_i\\cup a_j|}\\\\\n&amp;=\\sum_{j=1}^n\\dfrac {|a_i|+|a_j|-|a_i\\cup a_j|}{|a_i\\cup a_j|}\\\\\n&amp;=\\sum_{j=1}^n \\dfrac {|a_i|+|a_j|}{|a_i\\cup a_j|}-1\n\\end{aligned}\n\\]</span></p>\n<p>尽量把分子变得更简：</p>\n<p><span class=\"math display\">\\[\n\\begin{aligned}\nf_i&amp;=\\sum_{j=1}^n \\dfrac {|a_i|+|a_j|}{|a_i\\cup a_j|}-1\\\\\n&amp;=|a_i|\\cdot\\left(\\sum_{j=1}^n\\dfrac 1{|a_i\\cup a_j|}\\right)-n+\\sum_{j=1}^n \\dfrac {|a_j|}{|a_i\\cup a_j|}\n\\end{aligned}\n\\]</span></p>\n<p>问题转化为求解 <span class=\"math inline\">\\(\\sum\\limits_{j=1}^n\\dfrac 1{|a_i\\cup a_j|}\\)</span> 和 <span class=\"math inline\">\\(\\sum\\limits_{j=1}^n\\dfrac {|a_j|}{|a_i\\cup a_j|}\\)</span>，以 <span class=\"math inline\">\\(*=\\sum\\limits_{j=1}^n\\dfrac 1{|a_i\\cup a_j|}\\)</span> 为例。令 <span class=\"math inline\">\\(b_i\\)</span> 为 <span class=\"math inline\">\\(a_i\\)</span> 补集，则：</p>\n<p><span class=\"math display\">\\[\n\\begin{aligned}\n*&amp;=\\sum\\limits_{j=1}^n\\dfrac 1{|a_i\\cup a_j|}\\\\\n&amp;=\\sum_{j=1}^n\\dfrac 1{k-|b_i\\cap b_j|}\n\\end{aligned}\n\\]</span></p>\n<p>为什么要做这个转换呢？相比起并集运算，交集运算有着优秀的性质：<span class=\"math inline\">\\(s\\subseteq(b_i\\cap b_j)\\iff s\\subseteq b_i\\land s\\subseteq b_j\\)</span>，<del>直接取或当然也有相似的性质，但是太烧脑了</del>。</p>\n<p>基于这个性质，我们有一个想法：对于所有 <span class=\"math inline\">\\(j\\)</span>，在 <span class=\"math inline\">\\(\\forall \\, s\\subseteq b_j\\)</span> 处放置 <span class=\"math inline\">\\(\\dfrac 1{k-|s|}\\)</span> 的贡献；对于 <span class=\"math inline\">\\(i\\)</span>，将 <span class=\"math inline\">\\(\\forall \\, s\\subseteq b_i\\)</span> 处的贡献求和。但是这样肯定会拿到很多我们不想要的贡献，例如 <span class=\"math inline\">\\(\\forall \\, s\\subset (b_i\\cap b_j)\\)</span>。</p>\n<p>考虑精细布置贡献——构造 <span class=\"math inline\">\\(g(|s|)\\)</span> 满足 <span class=\"math inline\">\\(\\sum\\limits_{j=1}^n\\sum\\limits_{s\\subseteq b_j}g(|s|)=*\\)</span>。</p>\n<p>这里可以二项式反演得到 <span class=\"math inline\">\\(g\\)</span>，具体地，令 <span class=\"math inline\">\\(F(|S|)=\\dfrac 1{k-|S|}=\\sum\\limits_{s\\subseteq S}g(|s|)=\\sum\\limits_{j=0}^{|S|} C_{|S|}^j g(j)\\)</span>，则 <span class=\"math inline\">\\(g(i)=\\sum\\limits_{j=0}^iC_i^j\\cdot \\dfrac {(-1)^{i-j}}{k-j}\\)</span>。</p>\n<p>再令 <span class=\"math inline\">\\(h(s)=\\sum\\limits_{b_j\\supseteq s}g(|s|)=g(|s|)\\cdot \\sum\\limits_{b_j\\supseteq s}1\\)</span>，那么 <span class=\"math inline\">\\(h\\)</span> 就是高维后缀和。我们正在做的事情就是求解 <span class=\"math inline\">\\(*=\\sum\\limits_{s\\subseteq b_i}h(s)\\)</span>，这就又是一个高维前缀和了。</p>\n<p>对于 <span class=\"math inline\">\\(\\sum\\limits_{j=1}^n\\dfrac {|a_j|}{|a_i\\cup a_j|}\\)</span> 呢，令 <span class=\"math inline\">\\(h(s)=\\sum\\limits_{b_j\\supseteq s}g(|s|)\\cdot {\\color{red}{|a_j|}} = g(|s|) \\cdot \\sum\\limits_{b_j\\supseteq s} \\color{red}{k - |b_j|}\\)</span>，改变高维后缀和求和对象即可。</p>\n<p>复杂度就是 <span class=\"math inline\">\\(O(n+k\\cdot 2^k)\\)</span>，其中 <span class=\"math inline\">\\(k\\cdot 2^k\\)</span> 来自整体高维前 / 后缀和，<span class=\"math inline\">\\(n\\cdot k\\)</span> 来自枚举 <span class=\"math inline\">\\(i\\)</span>。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 1e9 + 7;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, k, l;\n    std::cin &gt;&gt; n &gt;&gt; k, l = 1 &lt;&lt; k;\n    std::vector&lt;int&gt; a(n + 1), b(n + 1), cnt(l);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; a[i], b[i] = (l - 1) ^ a[i];\n        ++cnt[b[i]];\n    &#125;\n    std::vector&lt;long long&gt; g(k + 1), fac(k + 1);\n    auto qkp = [&amp;](long long x, int y = mod - 2) &#123;\n        auto res = 1ll;\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    auto C = [&amp;](int n, int m) &#123;\n        return fac[n] * qkp(fac[n - m]) % mod * qkp(fac[m]) % mod;\n    &#125;;\n    fac[0] = 1ll;\n    for (int i = 1; i &lt;= k; ++i)\n        fac[i] = fac[i - 1] * i % mod;\n    for (int i = 0; i &lt;= k; ++i) &#123;\n        for (int j = 0, p = (i &amp; 1) ? mod - 1 : 1; j &lt;= i; ++j, p = mod - p)\n            (g[i] += C(i, j) * p % mod * qkp(k - j) % mod) %= mod;\n        // printf(&quot;g[%d] = %lld\\n&quot;, i, g[i]);\n    &#125;\n    // for (int i = 0; i &lt;= k; ++i) &#123;\n    //     long long F = 0ll;\n    //     for (int j = 0; j &lt;= i; ++j)\n    //         (F += C(i, j) * g[j] % mod) %= mod;\n    //     printf(&quot;%d: %lld / %lld\\n&quot;, i, F, qkp(k - i));\n    // &#125;\n    std::vector&lt;long long&gt; h(l);\n    std::copy(cnt.begin(), cnt.end(), h.begin());\n    for (int i = 0; i &lt; k; ++i)\n        for (int j = l - 1; ~j; --j)\n            if (!((j &gt;&gt; i) &amp; 1))\n                (h[j] += h[j ^ (1 &lt;&lt; i)]) %= mod;\n    auto f1(h);\n    for (int i = 0; i &lt; l; ++i)\n        (f1[i] *= g[__builtin_popcount(i)]) %= mod;\n    for (int i = 0; i &lt; k; ++i)\n        for (int j = 0; j &lt; l; ++j)\n            if ((j &gt;&gt; i) &amp; 1)\n                (f1[j] += f1[j ^ (1 &lt;&lt; i)]) %= mod;\n    for (int i = 0; i &lt; l; ++i)\n        h[i] = cnt[i] * (k - __builtin_popcount(i));\n    for (int i = 0; i &lt; k; ++i)\n        for (int j = l - 1; ~j; --j)\n            if (!((j &gt;&gt; i) &amp; 1))\n                (h[j] += h[j ^ (1 &lt;&lt; i)]) %= mod;\n    auto f2(h);\n    for (int i = 0; i &lt; l; ++i)\n        (f2[i] *= g[__builtin_popcount(i)]) %= mod;\n    for (int i = 0; i &lt; k; ++i)\n        for (int j = 0; j &lt; l; ++j)\n            if ((j &gt;&gt; i) &amp; 1)\n                (f2[j] += f2[j ^ (1 &lt;&lt; i)]) %= mod;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        // fprintf(stderr, &quot;%d: %d * %lld - %d + %lld\\n&quot;, i, __builtin_popcount(a[i]), f1[b[i]], n, f2[b[i]]);\n        std::cout &lt;&lt; (__builtin_popcount(a[i]) * f1[b[i]] % mod + mod - n + f2[b[i]]) % mod &lt;&lt; &#39;\\n&#39;;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"e---prefix-xors\">E - Prefix XORs</h2>\n<p><a href=\"https://atcoder.jp/contests/arc137/tasks/arc137_d\" class=\"uri\">https://atcoder.jp/contests/arc137/tasks/arc137_d</a></p>\n<p>省流：做 <span class=\"math inline\">\\(k\\)</span> 次前缀和，<span class=\"math inline\">\\(k=1,2,\\cdots,m\\)</span>，分别询问：令 <span class=\"math inline\">\\(x_i\\gets a_i\\)</span> 对 <span class=\"math inline\">\\(s_n\\)</span> 的贡献次数，则 <span class=\"math inline\">\\(\\sum a_i\\cdot (x_i\\bmod 2)\\)</span>？</p>\n<p>对于 <span class=\"math inline\">\\(a_p\\)</span>，容易发现第一轮其对任意 <span class=\"math inline\">\\(s_q\\)</span> 有 <span class=\"math inline\">\\(1\\)</span> 次贡献，拉开来就是常数列；第二轮有 <span class=\"math inline\">\\((q-p+1)\\)</span> 次贡献，是公差为 <span class=\"math inline\">\\(1\\)</span> 的等差数列；第三轮是类三角形数——至此，肯定和组合数有关了。手玩可以发现第 <span class=\"math inline\">\\(k\\)</span> 轮 <span class=\"math inline\">\\(a_p\\)</span> 对 <span class=\"math inline\">\\(s_n\\)</span> 的贡献为 <span class=\"math inline\">\\(C_{n-p+(k-2)}^{n-p}\\)</span>，尽量令其中一个不动，得到 <span class=\"math inline\">\\(C_{n-p+(k-2)}^{k-1}\\)</span>。</p>\n<p>但是我们发现直接枚举每轮每个数会起飞，而且模数为 <span class=\"math inline\">\\(2\\)</span> 似乎只能 Lucas（再带个 <span class=\"math inline\">\\(\\log\\)</span>），怎么办呢？</p>\n<p>那就 Lucas 呗。由其观察容易发现 <span class=\"math inline\">\\(C_{n-p+(k-2)}^{k-2}\\bmod2=1\\)</span> 当且仅当 <span class=\"math inline\">\\((k-2)\\subseteq (n-p+k-2)\\iff (k-2)\\subseteq \\complement_U(n-p)\\)</span>，故问题转化为高维后缀和，<del>当然你也可以做一次 and-FWT</del>，那么 <span class=\"math inline\">\\(res_k=\\sum (C_{n-p+(k-2)}^{k-2}\\bmod 2)\\cdot a_p=S_{k-2}\\)</span>，其中 <span class=\"math inline\">\\(S\\)</span> 为高维后缀和，初值为 <span class=\"math inline\">\\(S_{\\complement_u(n-i)}\\gets a_i\\)</span>。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, m, l, k;\n    std::cin &gt;&gt; n &gt;&gt; m, k = std::__lg(n + m) + 1, l = 1 &lt;&lt; k;\n    std::vector&lt;int&gt; s(l);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; s[l - 1 - (n - i)];\n    for (int i = 0; i &lt; k; ++i)\n        for (int j = l - 1; ~j; --j)\n            if (!((j &gt;&gt; i) &amp; 1))\n                s[j] ^= s[j ^ (1 &lt;&lt; i)];\n    for (int i = 1; i &lt;= m; ++i)\n        std::cout &lt;&lt; s[i - 1] &lt;&lt; &#39; &#39;;\n    std::cout &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"b---the-top-scorer\">B - The Top Scorer</h2>\n<p><a href=\"https://codeforces.com/problemset/problem/1096/E\" class=\"uri\">https://codeforces.com/problemset/problem/1096/E</a></p>\n<p>鉴于每种方案等概率（翻译没说，但原题面有提到），考虑计算小明能够取胜的方案数，再对总方案数做除法。先枚举最高分 <span class=\"math inline\">\\(k\\ge r\\)</span>，再枚举包括小明在内恰有 <span class=\"math inline\">\\(c\\ge 1\\)</span> 个人 拿到 <span class=\"math inline\">\\(k\\)</span> 分。但剩下的人呢？显然是不能插板随机分配的，因为存在 <span class=\"math inline\">\\(&lt;k\\)</span> 的限制。</p>\n<p>考虑容斥，钦定剩下的 <span class=\"math inline\">\\(p-c\\)</span> 个人中拿到 <span class=\"math inline\">\\(\\ge k\\)</span> 分的人数后再可空地插板即可，则总方案数为：</p>\n<p><span class=\"math display\">\\[\n\\sum_{k=r}^s\\sum_{c=1}^p\\dfrac {C_{p - 1}^{c-1}}c\\cdot \\sum_{i=0}^{p-c}C_{p-c}^i\\cdot C_{s-k\\cdot (c+i)+(p-c-1)}^{p-c-1}\n\\]</span></p>\n<p>其中分母上的 <span class=\"math inline\">\\(c\\)</span> 来源于等概率分配给最高分，虽然不是整数，但也代表着「小明获胜可行方案数」。最后将答案除上总方案数 <span class=\"math inline\">\\(C_{s-r+p-1}^{p-1}\\)</span> 即可。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 998244353;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int p, s, r;\n    std::cin &gt;&gt; p &gt;&gt; s &gt;&gt; r;\n    std::vector&lt;long long&gt; fac(s + p), inv(s + p);\n    fac[0] = inv[0] = 1ll;\n    for (int i = 1; i &lt; s + p; ++i) &#123;\n        fac[i] = fac[i - 1] * i % mod;\n    &#125;\n    auto qkp = [&amp;](long long x, int y) &#123;\n        auto res = 1ll;\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    inv.back() = qkp(fac.back(), mod - 2);\n    for (int i = s + p - 2; i &gt; 0; --i)\n        inv[i] = inv[i + 1] * (i + 1) % mod;\n    auto C = [&amp;](int n, int m) &#123;\n        if (n == -1 &amp;&amp; m == -1)\n            return 1ll;\n        return fac[n] * inv[n - m] % mod * inv[m] % mod;\n    &#125;;\n    auto res(0ll);\n    for (int k = r; k &lt;= s; ++k)\n        for (int c = 1; c &lt;= p; ++c)\n            if ((p - c) * (k - 1) + c * k &gt;= s) &#123;\n                auto t(0ll);\n                for (int i = 0, now = 1; i &lt;= p - c &amp;&amp; k * (c + i) &lt;= s; ++i, now = mod - now)\n                    (t += now * C(p - c, i) % mod * C(s - k * (c + i) + (p - c - 1), p - c - 1) % mod) %= mod;\n                (res += C(p - 1, c - 1) * qkp(c, mod - 2) % mod * t % mod) %= mod;\n            &#125;\n    std::cout &lt;&lt; res * qkp(C(s - r + p - 1, p - 1), mod - 2) % mod &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"c---sky-full-of-stars\">C - Sky Full of Stars</h2>\n<p><a href=\"https://codeforces.com/problemset/problem/997/C\" class=\"uri\">https://codeforces.com/problemset/problem/997/C</a></p>\n<p>发现用 <span class=\"math inline\">\\(3^{n\\times n}\\)</span> 减去任意一行一列不同色的方案就是答案。</p>\n<p>考虑一元容斥，如令 <span class=\"math inline\">\\(f_i\\)</span> 表示至少 <span class=\"math inline\">\\(i\\)</span> 行 <span class=\"math inline\">\\(i\\)</span> 列同色的方案，但会发现 <span class=\"math inline\">\\(f_0\\)</span> 中包含 <span class=\"math inline\">\\(0\\)</span> 行 <span class=\"math inline\">\\(1\\)</span> 列同色等与预期不符的情况。受此启发考虑令 <span class=\"math inline\">\\(f_{i,j}\\)</span> 表示至少 <span class=\"math inline\">\\(i\\)</span> 行 <span class=\"math inline\">\\(j\\)</span> 列同色进行二元容斥。容易发现当 <span class=\"math inline\">\\(i\\times j\\ne 0\\)</span> 时，被选中的 <span class=\"math inline\">\\(i\\)</span> 行 <span class=\"math inline\">\\(j\\)</span> 列全部连通，应为同一种颜色；将它们挪到角落，可以发现未被选中的格子共有 <span class=\"math inline\">\\((n-i)\\times (n-j)\\)</span> 个。故有：</p>\n<p><span class=\"math display\">\\[\nf_{i,j}=\\begin{cases}\nC_n^j\\times 3^j\\times 3^{n\\times(n - j)}&amp;i=0\\\\\nC_n^i\\times 3^i\\times 3^{n\\times(n-i)}&amp;j=0\\\\\nC_n^i\\times C_n^j\\times 3\\times 3^{(n-i)\\times (n-j)}&amp;\\text{otherwise}\n\\end{cases}\n\\]</span></p>\n<p>令 <span class=\"math inline\">\\(g_{i,j}\\)</span> 表示恰好 <span class=\"math inline\">\\(i\\)</span> 行 <span class=\"math inline\">\\(j\\)</span> 列同色的方案数，那么答案为 <span class=\"math inline\">\\(3^{n\\times n}-g_{0,0}\\)</span>。二项式反演 / 容斥原理得 <span class=\"math inline\">\\(g_{0,0}=\\sum\\limits_{i=0}^n\\sum\\limits_{j=0}^n (-1)^{i+j}\\cdot f_{i,j}\\)</span>。很惊讶地发现这是 <span class=\"math inline\">\\(O(n^2)\\)</span> 的！考虑优化。把 <span class=\"math inline\">\\(f_{1\\to n,1\\to n}\\)</span> 合并同类项，得到：</p>\n<p><span class=\"math display\">\\[\n\\begin{aligned}\ng_{0, 0}\n&amp;=\\left[\\sum_{j=0}^n (-1)^j\\cdot f_{0,j}\\right]+\\sum_{i=1}^n (-1)^i\\cdot f_{i,0}+\\sum_{j=1}^n (-1)^{i+j}\\cdot C_n^i\\times C_n^j\\times 3^{(n-i)\\times (n-j)+1}\\\\\n&amp;=\\left[\\sum_{j=0}^n (-1)^j\\cdot f_{0,j}\\right]+\\sum_{i=1}^n (-1)^i\\cdot f_{i,0}+(-1)^i\\cdot C_n^i\\times 3^{n^2-n\\times i+1}\\times\\sum_{j=1}^n (-1)^j\\cdot C_n^j\\times 3^{j\\times(-n+i)}\\\\\n&amp;=\\left[\\sum_{j=0}^n (-1)^j\\cdot f_{0,j}\\right]+\\sum_{i=1}^n (-1)^i\\cdot f_{i,0}+(-1)^i\\cdot C_n^i\\times 3^{n^2-n\\times i+1}\\times\\left[\\left(\\sum_{j=0}^n (-1)^j\\cdot C_n^j\\times (3^{-n+i})^j\\right)-1\\right]\\\\\n&amp;=\\left[\\sum_{j=0}^n (-1)^j\\cdot f_{0,j}\\right]+\\sum_{i=1}^n (-1)^i\\cdot f_{i,0}+(-1)^i\\cdot C_n^i\\times 3^{n^2-n\\times i+1}\\times\\left[(-3^{-n+i}+1)^n-1\\right]\n\\end{aligned}\n\\]</span></p>\n<p>由此便可 <span class=\"math inline\">\\(O(n\\log n)\\)</span> 计算。担心超时可以把所有 <span class=\"math inline\">\\(3^{-n+i}\\)</span> 和 <span class=\"math inline\">\\(3^{n\\times i}\\)</span> 线性预处理出来，复杂度不会变就是了。</p>\n<p>这里解释一下最后一步的二项式定理，非常遗憾地发现 <span class=\"math inline\">\\(-1\\)</span> 和 <span class=\"math inline\">\\(3^{-n+i}\\)</span> 都是 <span class=\"math inline\">\\(j\\)</span> 次的，没办法把二者相加减做二项式定理；但由于次数相同，这提示我们可以把 <span class=\"math inline\">\\(-1\\)</span> 乘到 <span class=\"math inline\">\\(3^{-n+i}\\)</span> 里去，给每一项配上 <span class=\"math inline\">\\(1^{n-k}\\)</span> 就可以做 <span class=\"math inline\">\\(-3^{n-i}\\)</span>（注意不是 <span class=\"math inline\">\\((-3)^{n-i}\\)</span>） 和 <span class=\"math inline\">\\(1\\)</span> 的二项式定理。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 998244353;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    long long n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;long long&gt; fac(n + 1), inv(n + 1), invn(n + 1), invi(n + 1), powi(n + 1), pown(n + 1);\n    auto qkp = [&amp;](long long x, long long y) &#123;\n        auto res(1ll);\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    const long long pnn = qkp(3ll, n * n), pn = qkp(3ll, n);\n    fac[0] = inv[0] = invn[0] = invi[0] = powi[0] = pown[0] = 1ll;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        fac[i] = fac[i - 1] * i % mod;\n        powi[i] = powi[i - 1] * 3 % mod;\n        pown[i] = pown[i - 1] * pn % mod;\n    &#125;\n    inv[n] = qkp(fac[n], mod - 2);\n    invi[n] = qkp(powi[n], mod - 2);\n    invn[n] = qkp(pown[n], mod - 2);\n    for (int i = n - 1; i; --i) &#123;\n        inv[i] = inv[i + 1] * (i + 1) % mod;\n        invi[i] = invi[i + 1] * 3 % mod;\n        invn[i] = invn[i + 1] * pn % mod;\n    &#125;\n    auto C = [&amp;](int n, int m) &#123;\n        return fac[n] * inv[n - m] % mod * inv[m] % mod;\n    &#125;;\n    long long g = 0ll;\n    auto f = [&amp;](int i, int j) &#123; // make sure (!i || !j)\n        if (i == 0 &amp;&amp; j == 0)\n            return pnn;\n        else if (i == 0)\n            return C(n, j) * powi[j] % mod * pown[n - j] % mod;\n        return C(n, i) * powi[i] % mod * pown[n - i] % mod;\n    &#125;;\n    for (int j = 0, p = 1; j &lt;= n; ++j, p = mod - p)\n        (g += p * f(0, j)) %= mod;\n    for (int i = 1, p = mod - 1; i &lt;= n; ++i, p = mod - p)\n        (g += p * f(i, 0) % mod + p * C(n, i) % mod * pnn % mod * invn[i] % mod * 3 % mod * (qkp(mod - invi[n - i] + 1, n) + mod - 1) % mod) %= mod;\n    std::cout &lt;&lt; (pnn + mod - g) % mod &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"d---去-m-nom\">D - 去 M / NoM</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P11316\" class=\"uri\">https://www.luogu.com.cn/problem/P11316</a></p>\n<p>假设 <span class=\"math inline\">\\(f(i)\\)</span> 为至少有 <span class=\"math inline\">\\(i\\)</span> 对不合法元素的方案数，则容斥得到答案 <span class=\"math inline\">\\(\\sum\\limits_{i=0}^n (-1)^i\\cdot f(i)\\)</span>。考虑怎么计算 <span class=\"math inline\">\\(f(i)\\)</span>。</p>\n<p><mark><span class=\"math inline\">\\(M\\)</span> 整除 <span class=\"math inline\">\\(dis(x, y) \\iff (pos_x - pos_y)\\bmod M=0\\iff pos_x\\equiv pos_y\\pmod M\\)</span>。</mark></p>\n<p>考虑把关于 <span class=\"math inline\">\\(M\\)</span> 同余的位置放在一个组，也就是说需要让一对元素不能选同一组的位置。</p>\n<p>考虑容斥，令 <span class=\"math inline\">\\(f(i)\\)</span> 表示至少有 <span class=\"math inline\">\\(i\\)</span> 对点选到一组的方案数，考虑怎么计算。假设我们要在第 <span class=\"math inline\">\\(k\\)</span> 组（size 为 <span class=\"math inline\">\\(s_k\\)</span>）中选出 <span class=\"math inline\">\\(x\\)</span> 对位置，实际上只需要选择 <span class=\"math inline\">\\(2x\\)</span> 个位置然后任意分配给这 <span class=\"math inline\">\\(x\\)</span> 对数，即 <span class=\"math inline\">\\(A_{s_k}^{2x}\\)</span>。设 <span class=\"math inline\">\\(dp_{i, j}\\)</span> 表示 DP 到第 <span class=\"math inline\">\\(i\\)</span> 个组，已经选了 <span class=\"math inline\">\\(j\\)</span> 对，那么有 <span class=\"math inline\">\\(dp_{i,j}=\\sum\\limits_{k=0}^jC_{n-(j - k)}^{j-k}\\times dp_{i-1,j-k}\\times A_{s_i}^{2k}\\)</span>。乍一看好像是 <span class=\"math inline\">\\(O(n^3)\\)</span> 的，但是别忘了 <span class=\"math inline\">\\(\\sum s_i=2n\\)</span>，所以只有 <span class=\"math inline\">\\(O(n^2)\\)</span>。<span class=\"math inline\">\\(f(i)\\)</span> 即为 <span class=\"math inline\">\\(dp_{m,i}\\times (2n-2i)!\\)</span>。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 1e9 + 7;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, m;\n    std::cin &gt;&gt; n &gt;&gt; m;\n    std::vector&lt;int&gt; s(m + 1);\n    std::vector&lt;long long&gt; fac(2 * n + 1), inv(2 * n + 1);\n    fac[0] = inv[0] = 1ll;\n    for (int i = 1; i &lt;= 2 * n; ++i)\n        ++s[i % m + 1], fac[i] = fac[i - 1] * i % mod;\n    auto qkp = [](long long x, int y) &#123;\n        auto res = 1ll;\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    inv[2 * n] = qkp(fac[2 * n], mod - 2);\n    for (int i = 2 * n - 1; i; --i)\n        inv[i] = inv[i + 1] * (i + 1) % mod;\n    auto A = [&amp;](int n, int m) &#123;\n        return fac[n] * inv[n - m] % mod;\n    &#125;;\n    auto C = [&amp;](int n, int m) &#123;\n        return fac[n] * inv[n - m] % mod * inv[m] % mod;\n    &#125;;\n    std::vector&lt;std::vector&lt;long long&gt; &gt; dp(m + 1, std::vector&lt;long long&gt; (n + 1));\n    dp[0][0] = 1ll;\n    for (int i = 1; i &lt;= m; ++i)\n        for (int j = 0; j &lt;= n; ++j) &#123;\n            for (int k = 0; k &lt;= j &amp;&amp; 2 * k &lt;= s[i]; ++k)\n                (dp[i][j] += C(n - (j - k), k) * dp[i - 1][j - k] % mod * A(s[i], 2 * k) % mod) %= mod;\n            // printf(&quot;s = %d, dp[%d][%d] = %lld\\n&quot;, s[i], i, j, dp[i][j]);\n        &#125;\n    long long res = 0ll;\n    for (int i = 0, p = 1; i &lt;= n; ++i, p = mod - p)\n        (res += p * dp[m][i] % mod * fac[2 * n - 2 * i] % mod) %= mod;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"e---kdoi-11彩灯晚会\">E - 「KDOI-11」彩灯晚会</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P11292\" class=\"uri\">https://www.luogu.com.cn/problem/P11292</a></p>\n<p>考虑 <span class=\"math inline\">\\({cnt_i}^2\\)</span> 的含义，即在所有颜色为 <span class=\"math inline\">\\(i\\)</span>、长度为 <span class=\"math inline\">\\(l\\)</span> 的链中有放回地选两次的方案数。</p>\n<p>显然复杂度里是不能包含 <span class=\"math inline\">\\(k\\)</span> 的，所以放弃直接统计 <span class=\"math inline\">\\(cnt_i\\)</span> 的想法。显然每种颜色是等价的，考虑计算选择两条链可以给答案带来的贡献：答案的形式是个和式；对于两条同色链 <span class=\"math inline\">\\(p,q\\)</span>，假设颜色为 <span class=\"math inline\">\\(i\\)</span>，那么会对 <span class=\"math inline\">\\({cnt_i}^2\\)</span> 带来 <span class=\"math inline\">\\(k^{n-2l-|p\\cap q|}\\)</span> 的贡献，对总答案带来 <span class=\"math inline\">\\(k^{n-2l-|p\\cap q| + 1}\\)</span> 的贡献。</p>\n<p>然而如果要枚举计算 <span class=\"math inline\">\\(|p\\cap q|\\)</span> 就无法避免 <span class=\"math inline\">\\(O(n^5)\\)</span>，考虑更有潜力的方法：将问题转化为对于每个 <span class=\"math inline\">\\(x\\)</span>，求交集大小恰好为 <span class=\"math inline\">\\(x\\)</span> 的链对个数。然而「恰好」是不方便计算的——假如当前两链在 <span class=\"math inline\">\\(u\\)</span> 次重合，如果假设下一次在 <span class=\"math inline\">\\(v\\)</span> 次重合，就需要保证在 <span class=\"math inline\">\\(u,v\\)</span> 之间不能重合——这并不好操作。二项式反演将恰好转化为至少，则限制减弱。</p>\n<p>令 <span class=\"math inline\">\\(f_{u,c,l_1,l_2}\\)</span> 表示 <span class=\"math inline\">\\(p,q\\)</span> 当前在 <span class=\"math inline\">\\(u\\)</span> 处重合，视野内的 <span class=\"math inline\">\\(p,q\\)</span> 长度为 <span class=\"math inline\">\\(l_1,l_2\\)</span>，至少已经重合了 <span class=\"math inline\">\\(c\\)</span> 次的方案数。预处理出走到 <span class=\"math inline\">\\(u\\)</span> 步数为 <span class=\"math inline\">\\(l_1,l_2\\)</span> 的方案数为初始值。枚举可能的后续重合点 <span class=\"math inline\">\\(v\\)</span>（满足 <span class=\"math inline\">\\(v\\)</span> 的拓扑序 <span class=\"math inline\">\\(&gt;u\\)</span>）有 <span class=\"math inline\">\\(f_{v,c+1,l_1&#39;,l_2&#39;}\\gets f_{v,c+1,l_1&#39;,l_2&#39;} + f_{u,c,l_1,l_2}\\)</span>。预处理出 <span class=\"math inline\">\\(u\\to v\\)</span> 长度为 <span class=\"math inline\">\\(\\Delta\\)</span> 的方案数（这是 <span class=\"math inline\">\\(O(n^3l)\\)</span> 的）优化转移，在算出 <span class=\"math inline\">\\(nex_{u,l}\\)</span> 表示从 <span class=\"math inline\">\\(u\\)</span> 出发走 <span class=\"math inline\">\\(l\\)</span> 步的方案数处理答案，则 <span class=\"math inline\">\\(F(i)=\\sum_{u,l_1,l_2}f_{u,l_1,l_2}\\cdot nex_{u,l-l_1}\\cdot nex_{u,l-l_2}\\)</span>，枚举 <span class=\"math inline\">\\(u,c,l_1,l_2,v,l_1&#39;,l_2&#39;\\)</span>，就可以达到优秀的 <span class=\"math inline\">\\(O(n^2l^5+n^3l)\\)</span>！简直是令人震撼 <img src=\"/em/kt.gif\" /></p>\n<p>给出第一个优化：发现 <span class=\"math inline\">\\(l_1\\)</span> 和 <span class=\"math inline\">\\(l_2\\)</span> 的转移彼此不干扰，考虑建立一个临时数组 <span class=\"math inline\">\\(g\\)</span>，先从 <span class=\"math inline\">\\(f_u,c\\)</span> 转移 <span class=\"math inline\">\\(l_1\\)</span> 到 <span class=\"math inline\">\\(g\\)</span>，再从 <span class=\"math inline\">\\(g\\)</span> 转移 <span class=\"math inline\">\\(l_2\\)</span> 到 <span class=\"math inline\">\\(f_{v,c+1}\\)</span>，则复杂度降为 <span class=\"math inline\">\\(O(n^2l^4+n^3l)\\)</span>，仍不足以通过。</p>\n<p>DP 过程上的优化已经万策尽，考虑从式子本身消元减少 DP 维度入手。令 <span class=\"math inline\">\\(h(i)\\)</span> 表示交集大小恰好恰好为 <span class=\"math inline\">\\(i\\)</span> 的方案数，则此时答案式为 <span class=\"math inline\">\\(\\sum\\limits_{i=0}^l k^{n-2l+i+1}\\times h(i)\\)</span>。又 <span class=\"math inline\">\\(F(i)=\\sum\\limits_{j=i}^lC_j^i\\cdot h(j)\\)</span>，二项式反演得：</p>\n<p><span class=\"math display\">\\[\n\\begin{aligned}\nres&amp;=\\sum\\limits_{i=0}^lk^{n-2l+i+1}\\cdot \\sum_{j=i}^l(-1)^{j-i}\\cdot C_j^i\\cdot F(j)\\\\\n&amp;=k^{n-2l+1}\\cdot\\sum_{j=0}^l \\sum_{i=0}^j k^i\\cdot (-1)^{j-i}\\cdot C_j^i\\cdot F(j)\\\\\n&amp;=k^{n-2l+1}\\cdot \\sum_{j=0}^l (k-1)^j\\cdot F(j)\n\\end{aligned}\n\\]</span></p>\n<p><mark>注意这里利用了二项式反演的系数可以和交换求和顺序后的 <span class=\"math inline\">\\(i\\)</span> 次项（或 <span class=\"math inline\">\\(j-i\\)</span> 次项，参见 <a href=\"#c---sky-full-of-stars\">Sky Full of Stars 中最后一步的处理</a>）组成二项式定理的特点</mark>，以便基于式子结构尽可能消元。</p>\n<p>那么此时答案式已经和 <span class=\"math inline\">\\(c\\)</span> 无关，可以丢掉 <span class=\"math inline\">\\(c\\)</span> 这一维，和 <span class=\"math inline\">\\(c\\)</span> 有关的计算已经在转移时处理了。则 <span class=\"math inline\">\\(f_{v,l_1&#39;,l_2&#39;}=\\sum f_{u,l_1,l_2}\\times (k-1)\\)</span>，复杂度降为 <span class=\"math inline\">\\(O(n^2l^3+n^3l)\\)</span>。</p>\n<details>\n<p>记得还要算上 <span class=\"math inline\">\\(F(0)\\)</span>，即任选一条合法链的方案数平方。</p>\n<pre class=\"cpp\"><code>// 兄弟你好香\n// 兄弟你是依托打分，我踏马吃吃吃吃吃\n#include &lt;bits/stdc++.h&gt;\nconst int mod = 998244353;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;party3.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    using arr = std::vector&lt;long long&gt;;\n    using arrr = std::vector&lt;arr&gt;;\n    using arrrr = std::vector&lt;arrr&gt;;\n    int n, k, l, m;\n    std::cin &gt;&gt; n, std::cin &gt;&gt; n &gt;&gt; k &gt;&gt; l &gt;&gt; m;\n    std::vector&lt;int&gt; deg(n + 1), id;\n    std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; g(n + 1);\n    for (int x, y, c; m--; ) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y &gt;&gt; c;\n        ++deg[y], g[x].emplace_back(y, c);\n    &#125;\n    arrrr to(n + 1, arrr(n + 1, arr(l + 1)));\n    arrr pre(n + 1, arr(l + 1)), nex(n + 1, arr(l + 1));\n    &#123;\n        std::queue&lt;int&gt; q;\n        for (int i = 1; i &lt;= n; ++i)\n            if (!deg[i])\n                q.push(i);\n        for (int u; !q.empty(); ) &#123;\n            u = q.front(), q.pop();\n            to[u][u][0] = 1ll, id.push_back(u);\n            for (auto i : id)\n                for (int j = 0; j &lt;= l; ++j) &#123;\n                    (pre[u][j] += to[i][u][j]) %= mod;\n                    // printf(&quot;to[%d][%d][%d] = %lld\\n&quot;, i, u, j, to[i][u][j]);\n                &#125;\n            // for (int j = 0; j &lt;= l; ++j)\n            //     printf(&quot;pre[%d][%d] = %lld\\n&quot;, u, j, pre[u][j]);\n            for (auto [v, c] : g[u]) &#123;\n                for (auto i : id)\n                    for (int j = 1; j &lt;= l; ++j)\n                        (to[i][v][j] += to[i][u][j - 1] * c) %= mod;\n                if (!--deg[v])\n                    q.push(v);\n            &#125;\n        &#125;\n        for (int u = 1; u &lt;= n; ++u)\n            for (int v = 1; v &lt;= n; ++v)\n                for (int i = 0; i &lt;= l; ++i)\n                    (nex[u][i] += to[u][v][i]) %= mod;\n    &#125;\n    arrrr f(n + 1, arrr(l + 1, arr(l + 1)));\n    &#123;\n        for (int i = 1; i &lt;= n; ++i)\n            for (int l1 = 1; l1 &lt;= l; ++l1)\n                for (int l2 = 1; l2 &lt;= l; ++l2)\n                    f[i][l1][l2] = pre[i][l1 - 1] * pre[i][l2 - 1] % mod * (k - 1) % mod;\n        for (auto i = 0; i &lt; n; ++i) &#123;\n            int u = id[i];\n            // for (int l1 = 1; l1 &lt;= l; ++l1)\n            //     for (int l2 = 1; l2 &lt;= l; ++l2)\n            //         printf(&quot;f[%d][%d][%d] = %lld\\n&quot;, u, l1, l2, f[u][l1][l2]);\n            for (auto j = i + 1; j &lt; n; ++j) &#123;\n                arrr g(l + 1, arr(l + 1));\n                int v = id[j];\n                for (int l1 = 1; l1 &lt; l; ++l1)\n                    for (int _l1 = l1 + 1; _l1 &lt;= l; ++_l1) &#123;\n                        auto K = to[u][v][_l1 - l1];\n                        if (K)\n                            for (int l2 = 1; l2 &lt; l; ++l2)\n                                (g[_l1][l2] += f[u][l1][l2] * K) %= mod;\n                    &#125;\n                for (int _l1 = 2; _l1 &lt;= l; ++_l1)\n                    for (int l2 = 1; l2 &lt; l; ++l2)\n                        if (g[_l1][l2])\n                            for (int _l2 = l2 + 1; _l2 &lt;= l; ++_l2)\n                                (f[v][_l1][_l2] += g[_l1][l2] * to[u][v][_l2 - l2] % mod * (k - 1)) %= mod; \n            &#125;\n        &#125;\n    &#125;\n    auto qkp = [](long long x, int y) &#123;\n        auto res(1ll);\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    auto res(0ll);\n    for (int u = 1; u &lt;= n; ++u)\n        for (int v = 1; v &lt;= n; ++v)\n            (res += to[u][v][l - 1]) %= mod;\n    (res *= res) %= mod;\n    for (int u = 1; u &lt;= n; ++u)\n        for (int l1 = 1; l1 &lt;= l; ++l1)\n            for (int l2 = 1; l2 &lt;= l; ++l2)\n                (res += f[u][l1][l2] * nex[u][l - l1] % mod * nex[u][l - l2] % mod) %= mod;\n    res = res % mod * (qkp(k, n + 1) * qkp(qkp(k, 2 * l), mod - 2) % mod) % mod;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"g---小星星\">G - 小星星</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P3349\" class=\"uri\">https://www.luogu.com.cn/problem/P3349</a></p>\n<p>首先考虑比较暴力的做法，那么有 <span class=\"math inline\">\\(f_{i,j,S}\\)</span> 表示在 <span class=\"math inline\">\\(i\\)</span> 这个子树里面选了集合 <span class=\"math inline\">\\(S\\)</span>，且 <span class=\"math inline\">\\(i\\)</span> 的颜色为 <span class=\"math inline\">\\(j\\)</span> 的方案数，维数里之所以有 <span class=\"math inline\">\\(j\\)</span> 是为了满足连边限制。</p>\n<p>然后树上子集 DP，发现是 <span class=\"math inline\">\\(O(n^4\\cdot 2^n)\\)</span> 的，</p>\n<hr />\n<h2 id=\"cf785d-anton-and-school---2\">CF785D Anton and School - 2</h2>\n<p><a href=\"https://codeforces.com/problemset/problem/785/D\" class=\"uri\">https://codeforces.com/problemset/problem/785/D</a></p>\n<p>容易想到枚举每个 <code>(</code> 作为分界点的情况，那么钦定当前枚举的 <code>(</code> 是要选的。对于当前 <code>(</code>，若其左边（不含）的 <code>(</code> 有 <span class=\"math inline\">\\(n\\)</span> 个而右边的 <code>)</code> 有 <span class=\"math inline\">\\(m\\)</span> 个，枚举除了当前 <code>(</code> 还要选 <span class=\"math inline\">\\(i\\)</span> 个 <code>(</code>，那么答案为 <span class=\"math inline\">\\(\\sum_{i=0}C_n^{i-1}\\cdot C_m^i\\)</span>。</p>\n<p>发现这个形式可以范德蒙德卷积：<span class=\"math inline\">\\(\\sum_{i=0}C_n^{i-1}\\cdot C_m^i=\\sum_{i=0}C_n^{n-i+1}\\cdot C_m^i=C_{n+m}^{n+1}\\)</span>。</p>\n<p>关于怎么记忆范德蒙德卷积，发现上下相加，也可以从组合意义记忆：在 <span class=\"math inline\">\\(n\\)</span> 个球中选出 <span class=\"math inline\">\\(k-i\\)</span> 个球，再从 <span class=\"math inline\">\\(m\\)</span> 个球中选出 <span class=\"math inline\">\\(i\\)</span> 个球的总方案就是从 <span class=\"math inline\">\\(n+m\\)</span> 个球中直接选出 <span class=\"math inline\">\\(k\\)</span> 个球的方案。</p>\n<p>注意判断右侧没有 <code>)</code> 的时候贡献为 <span class=\"math inline\">\\(0\\)</span>。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 1e9 + 7;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    std::string s;\n    std::cin &gt;&gt; s;\n    int n = s.length();\n    s = &quot; &quot; + s;\n    std::vector&lt;int&gt; cnt1(n + 1), cnt2(n + 1);\n    std::vector&lt;long long&gt; fac(n + 1), inv(n + 1);\n    fac[0] = inv[0] = 1ll;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        fac[i] = fac[i - 1] * i % mod;\n        cnt1[i] = cnt1[i - 1] + (s[i] == &#39;(&#39;);\n    &#125;\n    auto qkp = [](long long x, int y) &#123;\n        auto res(1ll);\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    inv[n] = qkp(fac[n], mod - 2);\n    cnt2[n] = (s[n] == &#39;)&#39;);\n    for (int i = n - 1; i; --i) &#123;\n        cnt2[i] = cnt2[i + 1] + (s[i] == &#39;)&#39;);\n        inv[i] = inv[i + 1] * (i + 1) % mod;\n    &#125;\n    long long res = 0ll;\n    auto C = [&amp;](int n, int m) &#123;\n        if (n &lt; m)\n            return 0ll;\n        return fac[n] * inv[n - m] % mod * inv[m] % mod;\n    &#125;;\n    for (int i = 1; i &lt;= n; ++i)\n        if (s[i] == &#39;(&#39;)\n            (res += C(cnt1[i] + cnt2[i] - 1, cnt1[i])) %= mod;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"cf1332e-height-all-the-same\">CF1332E Height All the Same</h2>\n<p><a href=\"https://codeforces.com/problemset/problem/1332/E\" class=\"uri\">https://codeforces.com/problemset/problem/1332/E</a></p>\n<p>容易发现第一个操作是用来改变两个数奇偶性的；而第二个操作能在全图奇偶性相同的任何情况下达成要求。</p>\n<p>注意到如果我们想同时仅改变任意两个数的奇偶性，可以在棋盘上任找一条路径一路使用操作一。只要某种奇偶性的元素个数共有偶数个，就能通过若干次操作一把它们全部变成另一种奇偶性。</p>\n<p>令 <span class=\"math inline\">\\(K_1\\)</span> 为 <span class=\"math inline\">\\(L\\sim R\\)</span> 中奇数的个数，<span class=\"math inline\">\\(K_2\\)</span> 为偶数，那么有：</p>\n<p><span class=\"math display\">\\[\nres=\\sum_{i=0}^{nm} C_{nm}^i\\times {K_1}^i\\cdot {K_2}^{nm-i}\\cdot [i\\bmod 2=0]\n\\]</span></p>\n<p>我们发现这个东西和二项式定理简直像得不能再像了！但多了一个系数导致没办法省略枚举过程。如果进行变形呢？</p>\n<p><span class=\"math display\">\\[\nres=(K_1+K_2)^{nm}-\\sum_{i=0}^{nm} C_{nm}^i\\times {K_1}^i\\cdot {K_2}^{nm-i}\\cdot [i\\bmod 2=1]\n\\]</span></p>\n<p>似乎依然没有出路！但这里有个神奇的操作：</p>\n<p><span class=\"math display\">\\[\nres=(-K_1+K_2)^{nm}+\\sum_{i=0}^{nm} C_{nm}^i\\times {K_1}^i\\cdot {K_2}^i\\cdot [i\\bmod 2=1]\n\\]</span></p>\n<p>二式相加就可以<mark>消元</mark>，得到 <span class=\"math inline\">\\(2\\cdot res=(K_1+K_2)^{nm}+(K_1-K_2)^{nm}\\)</span>。<mark>这启示我们二项式定理中的符号和奇偶性的深切联系。</mark></p>\n<details>\n<p>如果你使用费马小定理对次数进行了处理，你可能需要注意次数可能为 <span class=\"math inline\">\\(\\text{mod} -1\\)</span> 的倍数。</p>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 998244353;\nconst int inv2 = 499122177;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    long long n, m, l, r, k1, k2;\n    std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; l &gt;&gt; r, k1 = (r - l + 1) / 2, k2 = (r - l + 1) - k1;\n    auto qkp = [](long long x, long long y) &#123;\n        auto res(1ll);\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    if (n * m % 2)\n        std::cout &lt;&lt; qkp(r - l + 1, n * m) &lt;&lt; &#39;\\n&#39;;\n    else\n        std::cout &lt;&lt; (qkp(r - l + 1, n * m) + qkp((k1 + mod - k2) % mod, n * m)) % mod * inv2 % mod &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"a---交错序列\">A - 交错序列</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P4456\" class=\"uri\">https://www.luogu.com.cn/problem/P4456</a></p>\n<figure>\n<img src=\"2.png\" alt=\"出题人疑似需要加强数学功底（？）\" /><figcaption>出题人疑似需要加强数学功底（？）</figcaption>\n</figure>\n<p>容易想到把答案用二项式定理拆开：</p>\n<p><span class=\"math display\">\\[\n\\begin{aligned}\nres&amp;=\\sum_y f_y\\cdot y^b\\cdot (n-y)^a\\\\\n&amp;=\\sum_y f_y\\cdot y^b\\cdot \\sum_{i=0}^a C_a^i\\cdot n^i\\cdot(-y)^{a-i}\\\\\n&amp;=\\sum_y\\sum_{i=0}^a f_y\\cdot C_a^i\\cdot n^i\\cdot(-1)^{a-i}\\cdot y^{a+b-i}\\\\\n&amp;=\\sum_{i=0}^a C_a^i\\cdot n^i\\cdot(-1)^{a-i}\\cdot \\sum_y f_y\\cdot y^{a+b-i}\\\\\n\\end{aligned}\n\\]</span></p>\n<p>然后发现后面那个 sigma 不太有办法求。一个比较优雅的方法是把 <span class=\"math inline\">\\(y^{a+b-i}\\)</span> 直接作为系数而非下标塞到 <span class=\"math inline\">\\(f\\)</span> 里去，即令 <span class=\"math inline\">\\(f_{i}\\)</span> 表示 <span class=\"math inline\">\\(\\forall \\,y\\)</span>，<span class=\"math inline\">\\(\\sum y^i\\)</span> 之和。</p>\n<p>具体地，令 <span class=\"math inline\">\\(dp_{n,i,0/1}\\)</span> 表示当前 DP 到第 <span class=\"math inline\">\\(n\\)</span> 位，要求幂次为 <span class=\"math inline\">\\(i\\)</span>，最后一位为 <span class=\"math inline\">\\(0/1\\)</span> 的答案。则显然有 <span class=\"math inline\">\\(dp_{n,i,0}=dp_{n-1,i,0}+dp_{n-1,i,1}\\)</span>。对于 <span class=\"math inline\">\\(dp_{n,i,1}\\)</span>，因为此时 <span class=\"math inline\">\\(\\forall\\, k,k\\gets k+1\\)</span>，则 <span class=\"math inline\">\\((k+1)^i=\\sum\\limits_{j=0}^i C_i^j \\cdot k^j\\)</span> 即 <span class=\"math inline\">\\(dp_{n,i,1}=\\sum\\limits_{j=0}^i C_i^j\\cdot dp_{n-1,j,0}\\)</span>。发现 <span class=\"math inline\">\\(i,j\\)</span> 的范围是 <span class=\"math inline\">\\(90\\)</span>，很恐怖的事情是这是可以矩阵的。</p>\n<details>\n<p>就像我们都知道的那样，矩阵在加完之后再取模就会快很多……</p>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint mod;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, a, b;\n    std::cin &gt;&gt; n &gt;&gt; a &gt;&gt; b &gt;&gt; mod;\n    std::vector&lt;std::vector&lt;long long&gt; &gt; C(a + b + 1, std::vector&lt;long long&gt;(a + b + 1));\n    for (int i = 0; i &lt;= a + b; ++i) &#123;\n        C[i][0] = 1ll;\n        for (int j = 1; j &lt;= i; ++j)\n            C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % mod;\n    &#125;\n    struct mat &#123;\n        int n, m;\n        std::vector&lt;std::vector&lt;long long&gt; &gt; a;\n        mat(int n, int m, bool flag = 0): n(n), m(m), a(n, std::vector&lt;long long&gt; (m)) &#123;\n            if (flag)\n                for (int i = 0; i &lt; n; ++i)\n                    a[i][i] = 1ll;\n            return;\n        &#125;\n        mat operator* (const mat &amp;q) const &#123;\n            mat res(n, q.m);\n            for (int i = 0; i &lt; n; ++i)\n                for (int k = 0; k &lt; q.m; ++k) &#123;\n                    for (int j = 0; j &lt; m; ++j)\n                        res.a[i][k] += a[i][j] * q.a[j][k];\n                    res.a[i][k] %= mod;\n                &#125;\n            return res;\n        &#125;\n        mat operator^ (int q) const &#123;\n            mat res(n, n, 1), x(*this);\n            for (; q; x = x * x, q &gt;&gt;= 1)\n                if (q &amp; 1)\n                    res = res * x;\n            return res;\n        &#125;\n    &#125; f(1, 2 * (a + b + 1)), op(2 * (a + b + 1), 2 * (a + b + 1));\n    auto fun = [&amp;](int i, int j) &#123;\n        return i + j * (a + b + 1);\n    &#125;;\n    f.a[0][fun(0, 0)] = 1ll;\n    for (int i = 0; i &lt;= a + b; ++i)\n        op.a[fun(i, 0)][fun(i, 0)] = op.a[fun(i, 1)][fun(i, 0)] = 1ll;\n    for (int i = 0; i &lt;= a + b; ++i)\n        for (int j = 0; j &lt;= i; ++j)\n            op.a[fun(j, 0)][fun(i, 1)] = C[i][j];\n    f = f * (op ^ n);\n    // for (int i = 0; i &lt;= n; ++i) &#123;\n    //     if (i)\n    //         f = f * op;\n    //     for (int j = 0; j &lt;= a + b; ++j)\n    //         printf(&quot;f[%d][%d] = %lld / %lld\\n&quot;, i, j, f.a[0][fun(j, 0)], f.a[0][fun(j, 1)]);\n    // &#125;\n    auto res = 0ll;\n    for (int i = 0; i &lt;= a; ++i) &#123;\n        static auto p(1ll), k((a % 2) ? mod - 1ll : 1ll);\n        (res += C[a][i] * p % mod * k % mod * (f.a[0][fun(a + b - i, 0)] + f.a[0][fun(a + b - i, 1)]) % mod) %= mod;\n        (p *= n) %= mod, k = mod - k;\n    &#125;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"b---different-subsets-for-all-tuples\">B - Different Subsets For All Tuples</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/CF660E\" class=\"uri\">https://www.luogu.com.cn/problem/CF660E</a></p>\n<p>首先你可能需要知道，如果已知一个序列，如何得到答案？</p>\n<p>令 <span class=\"math inline\">\\(f_i\\)</span> 表示在 <span class=\"math inline\">\\(i\\)</span> 处取一个子序列的末尾，枚举上一个元素 <span class=\"math inline\">\\(x\\)</span>，找到 <span class=\"math inline\">\\(i\\)</span> 之前最靠后的一个 <span class=\"math inline\">\\(a_j=x\\)</span>，那么有 <span class=\"math inline\">\\(f_i=\\sum f_j\\)</span>，换言之需要保证 <span class=\"math inline\">\\((j,i)\\)</span> 范围内没有 <span class=\"math inline\">\\(x\\)</span> 出现。</p>\n<p>此时序列未知，令 <span class=\"math inline\">\\(f_{i, x}\\)</span> 表示在 <span class=\"math inline\">\\(i\\)</span> 处取一个子序列末尾，且 <span class=\"math inline\">\\(i\\)</span> 的值为 <span class=\"math inline\">\\(x\\)</span>；按照贡献的视角来看待，每个可以和 <span class=\"math inline\">\\(i\\)</span> 组成新子序列的方案可以带来 <span class=\"math inline\">\\(m^{i-1}\\)</span> 的贡献（因为 <span class=\"math inline\">\\(a_i\\)</span> 已经固定为 <span class=\"math inline\">\\(x\\)</span>，其他位置可以任选），那么有 <span class=\"math inline\">\\(f_{i,x}=m^i\\times \\sum_{j&lt;i,y}f_{j,y}\\times (m-1)^{i-j-1}\\)</span>。</p>\n<p>然后就惊讶地发现式子和 <span class=\"math inline\">\\(x\\)</span> 这一维没有关系了。所以直接带上系数得到：</p>\n<p><span class=\"math display\">\\[\n\\begin{aligned}\nf_i&amp;=m^i\\times \\sum_{j&lt;i} f_j\\times (m-1)^{i-j-1}\\times m\\\\\n&amp;=m^i\\times (m-1)^{i-1}\\times m\\cdot \\sum_{j&lt;i} f_j\\times (m-1)^{-j}\n\\end{aligned}\n\\]</span></p>\n<p>前缀和优化一下就可以快速求了。最终的答案就是 <span class=\"math inline\">\\(res=m^n+\\sum f_i\\times (m-1)^{n-i}\\)</span>。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 1e9 + 7;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, m;\n    std::cin &gt;&gt; n &gt;&gt; m;\n    if (m == 1)\n        std::cout &lt;&lt; (n + 1) &lt;&lt; &#39;\\n&#39;;\n    else &#123;\n        std::vector&lt;long long&gt; f(n + 1), s(n + 1), pm1(n + 1);\n        pm1[0] = 1ll;\n        for (int i = 1; i &lt;= n; ++i)\n            pm1[i] = pm1[i - 1] * (m - 1) % mod;\n        auto qkp = [](long long x, int y) &#123;\n            auto res(1ll);\n            for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n                if (y &amp; 1)\n                    (res *= x) %= mod;\n            return res;\n        &#125;;\n        auto res(qkp(m, n));\n        const auto invm = qkp(m - 1, mod - 2);\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            static long long p(m), inv(invm);\n            f[i] = (p + pm1[i - 1] * m % mod * s[i - 1] % mod) % mod;\n            s[i] = (s[i - 1] + f[i] * inv % mod) % mod;\n            (res += f[i] * pm1[n - i] % mod) %= mod;\n            (p *= m) %= mod, (inv *= invm) %= mod;\n        &#125;\n        std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;; \n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"g---gardens\">G - Gardens</h2>\n<p><a href=\"https://atcoder.jp/contests/abc235/tasks/abc235_g\" class=\"uri\">https://atcoder.jp/contests/abc235/tasks/abc235_g</a></p>\n<p>如果没有『每个人必须有一个元素』这个限制，就可以随便做了。现在加上了这个限制，很容易想到用没得到的人来容斥。钦定至少有 <span class=\"math inline\">\\(i\\)</span> 个人没拿到，得到答案为 <span class=\"math inline\">\\(\\sum\\limits_{i=0}^n (-1)^i\\cdot C_n^i\\cdot \\left(\\sum\\limits_{j=0}^a C_i^j\\right)\\cdot \\left(\\sum\\limits_{j=0}^b C_i^j\\right)\\cdot \\left(\\sum\\limits_{j=0}^c C_i^j\\right)\\)</span>。</p>\n<p>怎么算 <span class=\"math inline\">\\(\\sum\\limits_{j=0}^a C_i^j\\)</span> 呢？当 <span class=\"math inline\">\\(a&gt; i\\)</span> 时，二项式是好求的；当 <span class=\"math inline\">\\(a\\le i\\)</span> 时呢？看到这个式子很容易带到杨辉三角里去，也就是求一行的前 <span class=\"math inline\">\\(a\\)</span> 个数。注意到可以用上一行的前 <span class=\"math inline\">\\(a\\)</span> 个数 <span class=\"math inline\">\\(O(1)\\)</span> 得到（假设第 <span class=\"math inline\">\\(j-1\\)</span> 行前 <span class=\"math inline\">\\(a\\)</span> 个数之和为 <span class=\"math inline\">\\(f_a(j-1)\\)</span>）：<span class=\"math inline\">\\(f_a(j)=f_a(j-1)\\times 2-C_{j-1,a}\\)</span>。<mark>你需要意识到，由于上一行也是答案中要求的，所以可以使用递推解决问题。<strong>在组合计数中，递推 / DP 无论是在化简式子还是求容斥 / 二项式反演里具体某一限制下的方案数都是很有用的，在需要优化复杂度时，可以从递推 / DP、恒等式、前缀和、预处理等方法入手考虑</strong></mark>。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 998244353;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, a, b, c;\n    std::cin &gt;&gt; n &gt;&gt; a &gt;&gt; b &gt;&gt; c;\n    std::vector&lt;long long&gt; fac(n + 1), inv(n + 1), fa(n + 1), fb(n + 1), fc(n + 1), pow2(n + 1);\n    fac[0] = inv[0] = pow2[0] = 1ll;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        fac[i] = fac[i - 1] * i % mod;\n        pow2[i] = pow2[i - 1] * 2 % mod;\n    &#125;\n    auto qkp = [&amp;](long long x, int y) &#123;\n        auto res(1ll);\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    inv[n] = qkp(fac[n], mod - 2);\n    for (int i = n - 1; i; --i)\n        inv[i] = inv[i + 1] * (i + 1) % mod;\n    auto C = [&amp;](int n, int m) &#123;\n        return fac[n] * inv[n - m] % mod * inv[m] % mod;\n    &#125;;\n    for (int i = 0; i &lt;= a; ++i)\n        (fa[a] += C(a, i)) %= mod;\n    for (int i = a + 1; i &lt;= n; ++i)\n        fa[i] = (2 * fa[i - 1] % mod + mod - C(i - 1, a)) % mod;\n    for (int i = 0; i &lt;= b; ++i)\n        (fb[b] += C(b, i)) %= mod;\n    for (int i = b + 1; i &lt;= n; ++i)\n        fb[i] = (2 * fb[i - 1] % mod + mod - C(i - 1, b)) % mod;\n    for (int i = 0; i &lt;= c; ++i)\n        (fc[c] += C(c, i)) %= mod;\n    for (int i = c + 1; i &lt;= n; ++i)\n        fc[i] = (2 * fc[i - 1] % mod + mod - C(i - 1, c)) % mod;\n    auto res(0ll);\n    for (int i = n, p = 1; ~i; --i, p = mod - p)\n        (res += p * C(n, i) % mod * (i &gt;= a ? fa[i] : pow2[i]) % mod * (i &gt;= b ? fb[i] : pow2[i]) % mod * (i &gt;= c ? fc[i] : pow2[i]) % mod) %= mod;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n",
            "tags": [
                "排列组合",
                "容斥原理",
                "数学",
                "二项式定理",
                "二项式反演"
            ]
        }
    ]
}