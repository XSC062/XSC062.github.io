<?xml version="1.0"?>
<rss version="2.0">
    <channel>
        <title> • Posts by &#34;优化建图&#34; tag</title>
        <link>https://xsc062.netlify.app</link>
        <description></description>
        <language>zh-CN</language>
        <pubDate>Mon, 05 May 2025 08:04:36 +0800</pubDate>
        <lastBuildDate>Mon, 05 May 2025 08:04:36 +0800</lastBuildDate>
        <category>并查集</category>
        <category>斜率优化</category>
        <category>悬线法</category>
        <category>哈希</category>
        <category>字典树</category>
        <category>DP</category>
        <category>单调队列</category>
        <category>分治</category>
        <category>二分图</category>
        <category>CRT / exCRT</category>
        <category>排列组合</category>
        <category>网络流</category>
        <category>费用流</category>
        <category>二分</category>
        <category>上下界网络流</category>
        <category>容斥原理</category>
        <category>线段树</category>
        <category>树状数组</category>
        <category>区间 DP</category>
        <category>构造</category>
        <category>Tarjan</category>
        <category>数据结构</category>
        <category>下饭</category>
        <category>LCA</category>
        <category>倍增</category>
        <category>鸽巢原理</category>
        <category>概率期望</category>
        <category>调和级数</category>
        <category>差分</category>
        <category>思维</category>
        <category>树形 DP</category>
        <category>最小生成树</category>
        <category>SAM</category>
        <category>状压</category>
        <category>分块</category>
        <category>可持久化</category>
        <category>笛卡尔树</category>
        <category>高维前缀和</category>
        <category>闲话</category>
        <category>欧拉回路</category>
        <category>树链剖分</category>
        <category>长链剖分</category>
        <category>KMP</category>
        <category>border</category>
        <category>字符串</category>
        <category>AC 自动机</category>
        <category>SA</category>
        <category>数学</category>
        <category>树上差分</category>
        <category>FWT</category>
        <category>堆</category>
        <category>树的重心</category>
        <category>二项式定理</category>
        <category>二项式反演</category>
        <category>贪心</category>
        <category>均摊</category>
        <category>计数</category>
        <category>优化建图</category>
        <category>反悔贪心</category>
        <category>调整法</category>
        <category>背包</category>
        <category>博弈论</category>
        <category>DP 优化</category>
        <category>虚树</category>
        <category>点分治</category>
        <category>WQS 二分</category>
        <category>闵可夫斯基和</category>
        <category>slope trick</category>
        <category>四边形不等式</category>
        <category>暴力</category>
        <category>状压 DP</category>
        <category>组合数学</category>
        <category>支配对</category>
        <category>DDP</category>
        <category>平衡树</category>
        <category>容斥</category>
        <category>猫树</category>
        <category>Kruskal 重构树</category>
        <category>李超线段树</category>
        <item>
            <guid isPermalink="true">https://xsc062.netlify.app/20250505/</guid>
            <title>解题报告 喝醉的兔子</title>
            <link>https://xsc062.netlify.app/20250505/</link>
            <category>优化建图</category>
            <pubDate>Mon, 05 May 2025 08:04:36 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;老题解批量补档。&lt;/p&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;a href=&#34;http://222.180.160.110:61235/contest/6248/problem/2&#34; class=&#34;uri&#34;&gt;http://222.180.160.110:61235/contest/6248/problem/2&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定 &lt;span class=&#34;math inline&#34;&gt;\(q\)&lt;/span&gt; 次询问，每次给定 &lt;span class=&#34;math inline&#34;&gt;\(f(0)\)&lt;/span&gt;，求最小的 &lt;span class=&#34;math inline&#34;&gt;\(t\)&lt;/span&gt;，使得 &lt;span class=&#34;math inline&#34;&gt;\(n | f(t)\)&lt;/span&gt;，其中 &lt;span class=&#34;math inline&#34;&gt;\(f(t)=d\cdot f(t-1) + \Delta_t\)&lt;/span&gt;，&lt;span class=&#34;math inline&#34;&gt;\(n,d,l,r\)&lt;/span&gt; 为常数，&lt;span class=&#34;math inline&#34;&gt;\(\Delta_t\)&lt;/span&gt; 为你自选的 &lt;span class=&#34;math inline&#34;&gt;\([l,r]\)&lt;/span&gt; 间的整数，每次询问独立。&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(q, n\le 10^7\)&lt;/span&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果这是数论题，&lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt; 就不会和 &lt;span class=&#34;math inline&#34;&gt;\(q\)&lt;/span&gt; 同阶了，所以这可能是一道偏模拟的题目。&lt;/p&gt;
&lt;p&gt;很容易想到建同余图（这里说的是从 &lt;span class=&#34;math inline&#34;&gt;\([0-r,0-l]\)&lt;/span&gt; 出发；这样每个点第一次被 BFS 到的时候就能确定答案了）。但如果直接把图建出来，大小就是 &lt;span class=&#34;math inline&#34;&gt;\(O(n^2)\)&lt;/span&gt; 级别的了。每次连的点都是连续的一段，容易想到线段树优化建图。这样就能 &lt;span class=&#34;math inline&#34;&gt;\(O(n\log n)\)&lt;/span&gt; 解决问题了。但是题目要求线性。&lt;/p&gt;
&lt;p&gt;在实现的时候一定会注意到我们会连到一些已经被访问过的点。这样的边是『无效』的——我们不能将访问过的点再次加入队列。能不能规避掉这些点呢？&lt;/p&gt;
&lt;p&gt;&lt;mark&gt;每次被访问过的点一定是连续的、长度为 &lt;span class=&#34;math inline&#34;&gt;\(r - l + 1\)&lt;/span&gt; 的一段——有没有&lt;a href=&#34;/20250202/#texttt-aa-%E5%BC%8F%E5%AD%90%E4%B8%B2%E5%A4%84%E7%90%86&#34;&gt;联想到什么&lt;/a&gt;？类似地，给 &lt;span class=&#34;math inline&#34;&gt;\(0\sim n-1\)&lt;/span&gt; 每隔 &lt;span class=&#34;math inline&#34;&gt;\(r-l+1\)&lt;/span&gt; 打一个标记——或者说 &lt;strong&gt;分一段&lt;/strong&gt;&lt;/mark&gt;，那么每次试图访问 &lt;span class=&#34;math inline&#34;&gt;\([l_0, r_0]\)&lt;/span&gt; 时：&lt;/p&gt;
&lt;ol type=&#34;1&#34;&gt;
&lt;li&gt;&lt;span class=&#34;math inline&#34;&gt;\([l_0,r_0]\)&lt;/span&gt; 为两个相邻段的前后缀。&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;math inline&#34;&gt;\([l_0,r_0]\)&lt;/span&gt; 恰好为一段。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这时我们就发现了，每次访问的是完整的前后缀，利用前后缀和优化建图，由于边数是 &lt;span class=&#34;math inline&#34;&gt;\(O(n)\)&lt;/span&gt; 的，且边权只有 &lt;span class=&#34;math inline&#34;&gt;\(0\)&lt;/span&gt; 和 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt;，就可以做到 &lt;span class=&#34;math inline&#34;&gt;\(O(n)\)&lt;/span&gt; 01BFS 解决问题。&lt;/p&gt;
&lt;details&gt;
&lt;p&gt;注：常数大到必可神机跑不过&lt;/p&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
struct IO &amp;#123;
    static const int N = 1 &amp;lt;&amp;lt; 22;
    char buf[N], pbuf[N], *p1 = buf, *p2 = buf, *pp = pbuf;
#define gc() (p1 == p2 &amp;amp;&amp;amp; (p2 = (p1 = buf) + fread(buf, 1, N, stdin), p1 == p2) ? EOF : *p1++)
    template &amp;lt;typename T&amp;gt;
    void read(T&amp;amp; x) &amp;#123;
        x = 0;
        char ch;
        int f = 0;
        while ((ch = gc()) &amp;lt; &amp;#39;0&amp;#39; || ch &amp;gt; &amp;#39;9&amp;#39;) f |= (ch == &amp;#39;-&amp;#39;);
        while (x = (x &amp;lt;&amp;lt; 1) + (x &amp;lt;&amp;lt; 3) + (ch ^ 48), (ch = gc()) &amp;gt;= &amp;#39;0&amp;#39; &amp;amp;&amp;amp; ch &amp;lt;= &amp;#39;9&amp;#39;)
            ;
        if (f)
            x = ~x + 1;
    &amp;#125;
    void putc(char c) &amp;#123;
        if (pp - pbuf == N)
            fwrite(pbuf, 1, N, stdout), pp = pbuf;
        *pp++ = c;
    &amp;#125;
    void puts(const char* s) &amp;#123;
        while (*s) putc(*s), ++s;
        putc(&amp;#39;\n&amp;#39;);
    &amp;#125;
    template &amp;lt;typename T&amp;gt;
    void print(T x) &amp;#123;
        static int st[20];
        int tp = 0;
        if (x &amp;lt; 0)
            putc(&amp;#39;-&amp;#39;), x = ~x + 1;
        do
            st[++tp] = x % 10, x /= 10;
        while (x);
        while (tp) putc(st[tp--] + &amp;#39;0&amp;#39;);
    &amp;#125;
    ~IO() &amp;#123; fwrite(pbuf, pp - pbuf, 1, stdout); &amp;#125;
&amp;#125; io;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::freopen(&amp;quot;calculate.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;calculate.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#else
    std::freopen(&amp;quot;ex_calculator3.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#endif
    int T;
    for (io.read(T); T--; ) &amp;#123;
        int n, l, r, m, to;
        long long d, len;
        io.read(n), io.read(d), io.read(l), io.read(r), io.read(m);
        len = r - l + 1, to = (n - 1) / len + 1;
        std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; t(n), lid(to), rid(to);
        for (int i = 0; i &amp;lt; n; ++i)
            t[i * d % n].push_back(i);
        std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; g(3 * n);
        for (int i = 0, id = n - 1; i &amp;lt; to; ++i) &amp;#123;
            int at = ((i != to - 1 || !(n % len)) ? len : (n % len));
            lid[i].resize(at), rid[i].resize(at);
            for (int j = 0; j &amp;lt; at; ++j) &amp;#123;
                lid[i][j] = ++id;
                g[id].push_back(i * len + j);
                if (j != 0)
                    g[id].push_back(id - 1);
            &amp;#125;
            for (int j = at - 1; ~j; --j) &amp;#123;
                rid[i][j] = ++id;
                g[id].push_back(i * len + j);
                if (j != at - 1)
                    g[id].push_back(id - 1);
            &amp;#125;
        &amp;#125;
        auto add = [&amp;amp;](int p, int l0, int r0) &amp;#123;
            int p1 = l0 / len, p2 = r0 / len;
            if (p1 == p2)
                g[p].push_back(lid[p1].back());
            else &amp;#123;
                g[p].push_back(rid[p1][l0 % len]);
                if ((p1 + 1) % to != p2) &amp;#123;
                    // fprintf(stderr, &amp;quot;p1 = %d, p2 = %d, to = %d, get %d(%d)\n&amp;quot;, p1, p2, to, (p1 + 1) % to, (int)lid[(p1 + 1) % to].size());
                    g[p].push_back(lid[(p1 + 1) % to].back());
                &amp;#125;
                g[p].push_back(lid[p2][r0 % len]);
            &amp;#125;
            return;
        &amp;#125;;
        for (int i = 0; i &amp;lt; n; ++i)
            for (auto j : t[i]) &amp;#123;
                // printf(&amp;quot;%d -&amp;gt; %d[%d, %d]\n&amp;quot;, i, j, (j + n - r) % n, (j + n - l) % n);
                add(i, (j + n - r) % n, (j + n - l) % n);
            &amp;#125;
        std::list&amp;lt;std::pair&amp;lt;int, int&amp;gt; &amp;gt; q;
        std::vector&amp;lt;int&amp;gt; f(n + 1, -1), tag(3 * n + 1);
        for (int i = l, p = (n - r) % n; i &amp;lt;= r; ++i, (++p) %= n)
            f[p] = 0, q.emplace_back(p, 0), tag[p] = 1;
        for (; !q.empty(); ) &amp;#123;
            auto [u, d] = q.front();
            q.pop_front();
            if (u &amp;lt; n)
                f[u] = d;
            // printf(&amp;quot;u = %d, d = %d\n&amp;quot;, u, d);
            for (auto i : g[u]) &amp;#123;
                // printf(&amp;quot;  i = %d\n&amp;quot;, i);
                if (!tag[i]) &amp;#123;
                    if (i &amp;gt;= n)
                        q.emplace_front(i, d), tag[i] = 1;
                    else
                        q.emplace_back(i, d + 1), tag[i] = 1;
                &amp;#125;
            &amp;#125;
        &amp;#125;
        for (int x; m--; )
            io.read(x), io.print(f[x]), io.putc(&amp;#39;\n&amp;#39;);
    &amp;#125;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;p&gt;或者，发现&lt;mark&gt;每次任意标记前后缀，则一段内未访问的一定是中间的一整截&lt;/mark&gt;。根据这一点可维护每一段内可访问元素，就能 &lt;span class=&#34;math inline&#34;&gt;\(O(n)\)&lt;/span&gt; BFS；&lt;/p&gt;
&lt;p&gt;如果把图建出来了，还可以解决扩展问题：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;假如 &lt;span class=&#34;math inline&#34;&gt;\(\Delta_i\)&lt;/span&gt; 在 &lt;span class=&#34;math inline&#34;&gt;\([l,r]\)&lt;/span&gt; 间的整数中等概率取值，则最优解出现的概率？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;为什么 BFS 不能解决该问题呢？因为同层同代价的点对共同能访问到的点的贡献不会被 BFS 记入（注意到一个点只会被一个点访问到），所以只有建图出来才能解决问题。&lt;/p&gt;
&lt;p&gt;这也侧面反映该图在忽略环后所对应的就是最优解，这其实是有点 BFS 扩展出来的意味在的。&lt;/p&gt;
 ]]></description>
        </item>
    </channel>
</rss>
