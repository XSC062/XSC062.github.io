<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://xsc062.netlify.app</id>
    <title> • Posts by &#34;优化建图&#34; tag</title>
    <link href="https://xsc062.netlify.app" />
    <updated>2025-05-05T00:04:36.000Z</updated>
    <category term="并查集" />
    <category term="斜率优化" />
    <category term="悬线法" />
    <category term="哈希" />
    <category term="字典树" />
    <category term="DP" />
    <category term="单调队列" />
    <category term="分治" />
    <category term="二分图" />
    <category term="CRT / exCRT" />
    <category term="排列组合" />
    <category term="网络流" />
    <category term="费用流" />
    <category term="二分" />
    <category term="上下界网络流" />
    <category term="容斥原理" />
    <category term="线段树" />
    <category term="树状数组" />
    <category term="区间 DP" />
    <category term="构造" />
    <category term="Tarjan" />
    <category term="数据结构" />
    <category term="下饭" />
    <category term="LCA" />
    <category term="倍增" />
    <category term="鸽巢原理" />
    <category term="概率期望" />
    <category term="调和级数" />
    <category term="差分" />
    <category term="思维" />
    <category term="树形 DP" />
    <category term="最小生成树" />
    <category term="SAM" />
    <category term="状压" />
    <category term="分块" />
    <category term="可持久化" />
    <category term="笛卡尔树" />
    <category term="高维前缀和" />
    <category term="闲话" />
    <category term="欧拉回路" />
    <category term="树链剖分" />
    <category term="长链剖分" />
    <category term="KMP" />
    <category term="border" />
    <category term="字符串" />
    <category term="AC 自动机" />
    <category term="SA" />
    <category term="数学" />
    <category term="树上差分" />
    <category term="FWT" />
    <category term="堆" />
    <category term="树的重心" />
    <category term="二项式定理" />
    <category term="二项式反演" />
    <category term="贪心" />
    <category term="均摊" />
    <category term="计数" />
    <category term="优化建图" />
    <category term="反悔贪心" />
    <category term="调整法" />
    <category term="背包" />
    <category term="博弈论" />
    <category term="DP 优化" />
    <category term="虚树" />
    <category term="点分治" />
    <category term="WQS 二分" />
    <category term="闵可夫斯基和" />
    <category term="slope trick" />
    <category term="四边形不等式" />
    <category term="暴力" />
    <category term="状压 DP" />
    <category term="组合数学" />
    <category term="支配对" />
    <category term="DDP" />
    <category term="平衡树" />
    <category term="容斥" />
    <category term="猫树" />
    <category term="Kruskal 重构树" />
    <category term="李超线段树" />
    <entry>
        <id>https://xsc062.netlify.app/20250505/</id>
        <title>解题报告 喝醉的兔子</title>
        <link rel="alternate" href="https://xsc062.netlify.app/20250505/"/>
        <content type="html">&lt;p&gt;老题解批量补档。&lt;/p&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;a href=&#34;http://222.180.160.110:61235/contest/6248/problem/2&#34; class=&#34;uri&#34;&gt;http://222.180.160.110:61235/contest/6248/problem/2&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定 &lt;span class=&#34;math inline&#34;&gt;\(q\)&lt;/span&gt; 次询问，每次给定 &lt;span class=&#34;math inline&#34;&gt;\(f(0)\)&lt;/span&gt;，求最小的 &lt;span class=&#34;math inline&#34;&gt;\(t\)&lt;/span&gt;，使得 &lt;span class=&#34;math inline&#34;&gt;\(n | f(t)\)&lt;/span&gt;，其中 &lt;span class=&#34;math inline&#34;&gt;\(f(t)=d\cdot f(t-1) + \Delta_t\)&lt;/span&gt;，&lt;span class=&#34;math inline&#34;&gt;\(n,d,l,r\)&lt;/span&gt; 为常数，&lt;span class=&#34;math inline&#34;&gt;\(\Delta_t\)&lt;/span&gt; 为你自选的 &lt;span class=&#34;math inline&#34;&gt;\([l,r]\)&lt;/span&gt; 间的整数，每次询问独立。&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(q, n\le 10^7\)&lt;/span&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果这是数论题，&lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt; 就不会和 &lt;span class=&#34;math inline&#34;&gt;\(q\)&lt;/span&gt; 同阶了，所以这可能是一道偏模拟的题目。&lt;/p&gt;
&lt;p&gt;很容易想到建同余图（这里说的是从 &lt;span class=&#34;math inline&#34;&gt;\([0-r,0-l]\)&lt;/span&gt; 出发；这样每个点第一次被 BFS 到的时候就能确定答案了）。但如果直接把图建出来，大小就是 &lt;span class=&#34;math inline&#34;&gt;\(O(n^2)\)&lt;/span&gt; 级别的了。每次连的点都是连续的一段，容易想到线段树优化建图。这样就能 &lt;span class=&#34;math inline&#34;&gt;\(O(n\log n)\)&lt;/span&gt; 解决问题了。但是题目要求线性。&lt;/p&gt;
&lt;p&gt;在实现的时候一定会注意到我们会连到一些已经被访问过的点。这样的边是『无效』的——我们不能将访问过的点再次加入队列。能不能规避掉这些点呢？&lt;/p&gt;
&lt;p&gt;&lt;mark&gt;每次被访问过的点一定是连续的、长度为 &lt;span class=&#34;math inline&#34;&gt;\(r - l + 1\)&lt;/span&gt; 的一段——有没有&lt;a href=&#34;/20250202/#texttt-aa-%E5%BC%8F%E5%AD%90%E4%B8%B2%E5%A4%84%E7%90%86&#34;&gt;联想到什么&lt;/a&gt;？类似地，给 &lt;span class=&#34;math inline&#34;&gt;\(0\sim n-1\)&lt;/span&gt; 每隔 &lt;span class=&#34;math inline&#34;&gt;\(r-l+1\)&lt;/span&gt; 打一个标记——或者说 &lt;strong&gt;分一段&lt;/strong&gt;&lt;/mark&gt;，那么每次试图访问 &lt;span class=&#34;math inline&#34;&gt;\([l_0, r_0]\)&lt;/span&gt; 时：&lt;/p&gt;
&lt;ol type=&#34;1&#34;&gt;
&lt;li&gt;&lt;span class=&#34;math inline&#34;&gt;\([l_0,r_0]\)&lt;/span&gt; 为两个相邻段的前后缀。&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;math inline&#34;&gt;\([l_0,r_0]\)&lt;/span&gt; 恰好为一段。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这时我们就发现了，每次访问的是完整的前后缀，利用前后缀和优化建图，由于边数是 &lt;span class=&#34;math inline&#34;&gt;\(O(n)\)&lt;/span&gt; 的，且边权只有 &lt;span class=&#34;math inline&#34;&gt;\(0\)&lt;/span&gt; 和 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt;，就可以做到 &lt;span class=&#34;math inline&#34;&gt;\(O(n)\)&lt;/span&gt; 01BFS 解决问题。&lt;/p&gt;
&lt;details&gt;
&lt;p&gt;注：常数大到必可神机跑不过&lt;/p&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
struct IO &amp;#123;
    static const int N = 1 &amp;lt;&amp;lt; 22;
    char buf[N], pbuf[N], *p1 = buf, *p2 = buf, *pp = pbuf;
#define gc() (p1 == p2 &amp;amp;&amp;amp; (p2 = (p1 = buf) + fread(buf, 1, N, stdin), p1 == p2) ? EOF : *p1++)
    template &amp;lt;typename T&amp;gt;
    void read(T&amp;amp; x) &amp;#123;
        x = 0;
        char ch;
        int f = 0;
        while ((ch = gc()) &amp;lt; &amp;#39;0&amp;#39; || ch &amp;gt; &amp;#39;9&amp;#39;) f |= (ch == &amp;#39;-&amp;#39;);
        while (x = (x &amp;lt;&amp;lt; 1) + (x &amp;lt;&amp;lt; 3) + (ch ^ 48), (ch = gc()) &amp;gt;= &amp;#39;0&amp;#39; &amp;amp;&amp;amp; ch &amp;lt;= &amp;#39;9&amp;#39;)
            ;
        if (f)
            x = ~x + 1;
    &amp;#125;
    void putc(char c) &amp;#123;
        if (pp - pbuf == N)
            fwrite(pbuf, 1, N, stdout), pp = pbuf;
        *pp++ = c;
    &amp;#125;
    void puts(const char* s) &amp;#123;
        while (*s) putc(*s), ++s;
        putc(&amp;#39;\n&amp;#39;);
    &amp;#125;
    template &amp;lt;typename T&amp;gt;
    void print(T x) &amp;#123;
        static int st[20];
        int tp = 0;
        if (x &amp;lt; 0)
            putc(&amp;#39;-&amp;#39;), x = ~x + 1;
        do
            st[++tp] = x % 10, x /= 10;
        while (x);
        while (tp) putc(st[tp--] + &amp;#39;0&amp;#39;);
    &amp;#125;
    ~IO() &amp;#123; fwrite(pbuf, pp - pbuf, 1, stdout); &amp;#125;
&amp;#125; io;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::freopen(&amp;quot;calculate.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;calculate.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#else
    std::freopen(&amp;quot;ex_calculator3.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#endif
    int T;
    for (io.read(T); T--; ) &amp;#123;
        int n, l, r, m, to;
        long long d, len;
        io.read(n), io.read(d), io.read(l), io.read(r), io.read(m);
        len = r - l + 1, to = (n - 1) / len + 1;
        std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; t(n), lid(to), rid(to);
        for (int i = 0; i &amp;lt; n; ++i)
            t[i * d % n].push_back(i);
        std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; g(3 * n);
        for (int i = 0, id = n - 1; i &amp;lt; to; ++i) &amp;#123;
            int at = ((i != to - 1 || !(n % len)) ? len : (n % len));
            lid[i].resize(at), rid[i].resize(at);
            for (int j = 0; j &amp;lt; at; ++j) &amp;#123;
                lid[i][j] = ++id;
                g[id].push_back(i * len + j);
                if (j != 0)
                    g[id].push_back(id - 1);
            &amp;#125;
            for (int j = at - 1; ~j; --j) &amp;#123;
                rid[i][j] = ++id;
                g[id].push_back(i * len + j);
                if (j != at - 1)
                    g[id].push_back(id - 1);
            &amp;#125;
        &amp;#125;
        auto add = [&amp;amp;](int p, int l0, int r0) &amp;#123;
            int p1 = l0 / len, p2 = r0 / len;
            if (p1 == p2)
                g[p].push_back(lid[p1].back());
            else &amp;#123;
                g[p].push_back(rid[p1][l0 % len]);
                if ((p1 + 1) % to != p2) &amp;#123;
                    // fprintf(stderr, &amp;quot;p1 = %d, p2 = %d, to = %d, get %d(%d)\n&amp;quot;, p1, p2, to, (p1 + 1) % to, (int)lid[(p1 + 1) % to].size());
                    g[p].push_back(lid[(p1 + 1) % to].back());
                &amp;#125;
                g[p].push_back(lid[p2][r0 % len]);
            &amp;#125;
            return;
        &amp;#125;;
        for (int i = 0; i &amp;lt; n; ++i)
            for (auto j : t[i]) &amp;#123;
                // printf(&amp;quot;%d -&amp;gt; %d[%d, %d]\n&amp;quot;, i, j, (j + n - r) % n, (j + n - l) % n);
                add(i, (j + n - r) % n, (j + n - l) % n);
            &amp;#125;
        std::list&amp;lt;std::pair&amp;lt;int, int&amp;gt; &amp;gt; q;
        std::vector&amp;lt;int&amp;gt; f(n + 1, -1), tag(3 * n + 1);
        for (int i = l, p = (n - r) % n; i &amp;lt;= r; ++i, (++p) %= n)
            f[p] = 0, q.emplace_back(p, 0), tag[p] = 1;
        for (; !q.empty(); ) &amp;#123;
            auto [u, d] = q.front();
            q.pop_front();
            if (u &amp;lt; n)
                f[u] = d;
            // printf(&amp;quot;u = %d, d = %d\n&amp;quot;, u, d);
            for (auto i : g[u]) &amp;#123;
                // printf(&amp;quot;  i = %d\n&amp;quot;, i);
                if (!tag[i]) &amp;#123;
                    if (i &amp;gt;= n)
                        q.emplace_front(i, d), tag[i] = 1;
                    else
                        q.emplace_back(i, d + 1), tag[i] = 1;
                &amp;#125;
            &amp;#125;
        &amp;#125;
        for (int x; m--; )
            io.read(x), io.print(f[x]), io.putc(&amp;#39;\n&amp;#39;);
    &amp;#125;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;p&gt;或者，发现&lt;mark&gt;每次任意标记前后缀，则一段内未访问的一定是中间的一整截&lt;/mark&gt;。根据这一点可维护每一段内可访问元素，就能 &lt;span class=&#34;math inline&#34;&gt;\(O(n)\)&lt;/span&gt; BFS；&lt;/p&gt;
&lt;p&gt;如果把图建出来了，还可以解决扩展问题：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;假如 &lt;span class=&#34;math inline&#34;&gt;\(\Delta_i\)&lt;/span&gt; 在 &lt;span class=&#34;math inline&#34;&gt;\([l,r]\)&lt;/span&gt; 间的整数中等概率取值，则最优解出现的概率？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;为什么 BFS 不能解决该问题呢？因为同层同代价的点对共同能访问到的点的贡献不会被 BFS 记入（注意到一个点只会被一个点访问到），所以只有建图出来才能解决问题。&lt;/p&gt;
&lt;p&gt;这也侧面反映该图在忽略环后所对应的就是最优解，这其实是有点 BFS 扩展出来的意味在的。&lt;/p&gt;
</content>
        <category term="优化建图" />
        <updated>2025-05-05T00:04:36.000Z</updated>
    </entry>
</feed>
