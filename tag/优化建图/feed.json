{
    "version": "https://jsonfeed.org/version/1",
    "title": "null • All posts by \"优化建图\" tag",
    "description": "",
    "home_page_url": "https://xsc062.netlify.app",
    "items": [
        {
            "id": "https://xsc062.netlify.app/20250505/",
            "url": "https://xsc062.netlify.app/20250505/",
            "title": "解题报告 喝醉的兔子",
            "date_published": "2025-05-05T00:04:36.000Z",
            "content_html": "<p>老题解批量补档。</p>\n<span id=\"more\"></span>\n<hr />\n<p><a href=\"http://222.180.160.110:61235/contest/6248/problem/2\" class=\"uri\">http://222.180.160.110:61235/contest/6248/problem/2</a></p>\n<blockquote>\n<p>给定 <span class=\"math inline\">\\(q\\)</span> 次询问，每次给定 <span class=\"math inline\">\\(f(0)\\)</span>，求最小的 <span class=\"math inline\">\\(t\\)</span>，使得 <span class=\"math inline\">\\(n | f(t)\\)</span>，其中 <span class=\"math inline\">\\(f(t)=d\\cdot f(t-1) + \\Delta_t\\)</span>，<span class=\"math inline\">\\(n,d,l,r\\)</span> 为常数，<span class=\"math inline\">\\(\\Delta_t\\)</span> 为你自选的 <span class=\"math inline\">\\([l,r]\\)</span> 间的整数，每次询问独立。</p>\n<p><span class=\"math inline\">\\(q, n\\le 10^7\\)</span>。</p>\n</blockquote>\n<p>如果这是数论题，<span class=\"math inline\">\\(n\\)</span> 就不会和 <span class=\"math inline\">\\(q\\)</span> 同阶了，所以这可能是一道偏模拟的题目。</p>\n<p>很容易想到建同余图（这里说的是从 <span class=\"math inline\">\\([0-r,0-l]\\)</span> 出发；这样每个点第一次被 BFS 到的时候就能确定答案了）。但如果直接把图建出来，大小就是 <span class=\"math inline\">\\(O(n^2)\\)</span> 级别的了。每次连的点都是连续的一段，容易想到线段树优化建图。这样就能 <span class=\"math inline\">\\(O(n\\log n)\\)</span> 解决问题了。但是题目要求线性。</p>\n<p>在实现的时候一定会注意到我们会连到一些已经被访问过的点。这样的边是『无效』的——我们不能将访问过的点再次加入队列。能不能规避掉这些点呢？</p>\n<p><mark>每次被访问过的点一定是连续的、长度为 <span class=\"math inline\">\\(r - l + 1\\)</span> 的一段——有没有<a href=\"/20250202/#texttt-aa-%E5%BC%8F%E5%AD%90%E4%B8%B2%E5%A4%84%E7%90%86\">联想到什么</a>？类似地，给 <span class=\"math inline\">\\(0\\sim n-1\\)</span> 每隔 <span class=\"math inline\">\\(r-l+1\\)</span> 打一个标记——或者说 <strong>分一段</strong></mark>，那么每次试图访问 <span class=\"math inline\">\\([l_0, r_0]\\)</span> 时：</p>\n<ol type=\"1\">\n<li><span class=\"math inline\">\\([l_0,r_0]\\)</span> 为两个相邻段的前后缀。</li>\n<li><span class=\"math inline\">\\([l_0,r_0]\\)</span> 恰好为一段。</li>\n</ol>\n<p>这时我们就发现了，每次访问的是完整的前后缀，利用前后缀和优化建图，由于边数是 <span class=\"math inline\">\\(O(n)\\)</span> 的，且边权只有 <span class=\"math inline\">\\(0\\)</span> 和 <span class=\"math inline\">\\(1\\)</span>，就可以做到 <span class=\"math inline\">\\(O(n)\\)</span> 01BFS 解决问题。</p>\n<details>\n<p>注：常数大到必可神机跑不过</p>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nstruct IO &#123;\n    static const int N = 1 &lt;&lt; 22;\n    char buf[N], pbuf[N], *p1 = buf, *p2 = buf, *pp = pbuf;\n#define gc() (p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, N, stdin), p1 == p2) ? EOF : *p1++)\n    template &lt;typename T&gt;\n    void read(T&amp; x) &#123;\n        x = 0;\n        char ch;\n        int f = 0;\n        while ((ch = gc()) &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) f |= (ch == &#39;-&#39;);\n        while (x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ 48), (ch = gc()) &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;)\n            ;\n        if (f)\n            x = ~x + 1;\n    &#125;\n    void putc(char c) &#123;\n        if (pp - pbuf == N)\n            fwrite(pbuf, 1, N, stdout), pp = pbuf;\n        *pp++ = c;\n    &#125;\n    void puts(const char* s) &#123;\n        while (*s) putc(*s), ++s;\n        putc(&#39;\\n&#39;);\n    &#125;\n    template &lt;typename T&gt;\n    void print(T x) &#123;\n        static int st[20];\n        int tp = 0;\n        if (x &lt; 0)\n            putc(&#39;-&#39;), x = ~x + 1;\n        do\n            st[++tp] = x % 10, x /= 10;\n        while (x);\n        while (tp) putc(st[tp--] + &#39;0&#39;);\n    &#125;\n    ~IO() &#123; fwrite(pbuf, pp - pbuf, 1, stdout); &#125;\n&#125; io;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::freopen(&quot;calculate.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;calculate.out&quot;, &quot;w&quot;, stdout);\n#else\n    std::freopen(&quot;ex_calculator3.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int T;\n    for (io.read(T); T--; ) &#123;\n        int n, l, r, m, to;\n        long long d, len;\n        io.read(n), io.read(d), io.read(l), io.read(r), io.read(m);\n        len = r - l + 1, to = (n - 1) / len + 1;\n        std::vector&lt;std::vector&lt;int&gt; &gt; t(n), lid(to), rid(to);\n        for (int i = 0; i &lt; n; ++i)\n            t[i * d % n].push_back(i);\n        std::vector&lt;std::vector&lt;int&gt; &gt; g(3 * n);\n        for (int i = 0, id = n - 1; i &lt; to; ++i) &#123;\n            int at = ((i != to - 1 || !(n % len)) ? len : (n % len));\n            lid[i].resize(at), rid[i].resize(at);\n            for (int j = 0; j &lt; at; ++j) &#123;\n                lid[i][j] = ++id;\n                g[id].push_back(i * len + j);\n                if (j != 0)\n                    g[id].push_back(id - 1);\n            &#125;\n            for (int j = at - 1; ~j; --j) &#123;\n                rid[i][j] = ++id;\n                g[id].push_back(i * len + j);\n                if (j != at - 1)\n                    g[id].push_back(id - 1);\n            &#125;\n        &#125;\n        auto add = [&amp;](int p, int l0, int r0) &#123;\n            int p1 = l0 / len, p2 = r0 / len;\n            if (p1 == p2)\n                g[p].push_back(lid[p1].back());\n            else &#123;\n                g[p].push_back(rid[p1][l0 % len]);\n                if ((p1 + 1) % to != p2) &#123;\n                    // fprintf(stderr, &quot;p1 = %d, p2 = %d, to = %d, get %d(%d)\\n&quot;, p1, p2, to, (p1 + 1) % to, (int)lid[(p1 + 1) % to].size());\n                    g[p].push_back(lid[(p1 + 1) % to].back());\n                &#125;\n                g[p].push_back(lid[p2][r0 % len]);\n            &#125;\n            return;\n        &#125;;\n        for (int i = 0; i &lt; n; ++i)\n            for (auto j : t[i]) &#123;\n                // printf(&quot;%d -&gt; %d[%d, %d]\\n&quot;, i, j, (j + n - r) % n, (j + n - l) % n);\n                add(i, (j + n - r) % n, (j + n - l) % n);\n            &#125;\n        std::list&lt;std::pair&lt;int, int&gt; &gt; q;\n        std::vector&lt;int&gt; f(n + 1, -1), tag(3 * n + 1);\n        for (int i = l, p = (n - r) % n; i &lt;= r; ++i, (++p) %= n)\n            f[p] = 0, q.emplace_back(p, 0), tag[p] = 1;\n        for (; !q.empty(); ) &#123;\n            auto [u, d] = q.front();\n            q.pop_front();\n            if (u &lt; n)\n                f[u] = d;\n            // printf(&quot;u = %d, d = %d\\n&quot;, u, d);\n            for (auto i : g[u]) &#123;\n                // printf(&quot;  i = %d\\n&quot;, i);\n                if (!tag[i]) &#123;\n                    if (i &gt;= n)\n                        q.emplace_front(i, d), tag[i] = 1;\n                    else\n                        q.emplace_back(i, d + 1), tag[i] = 1;\n                &#125;\n            &#125;\n        &#125;\n        for (int x; m--; )\n            io.read(x), io.print(f[x]), io.putc(&#39;\\n&#39;);\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n<p>或者，发现<mark>每次任意标记前后缀，则一段内未访问的一定是中间的一整截</mark>。根据这一点可维护每一段内可访问元素，就能 <span class=\"math inline\">\\(O(n)\\)</span> BFS；</p>\n<p>如果把图建出来了，还可以解决扩展问题：</p>\n<blockquote>\n<p>假如 <span class=\"math inline\">\\(\\Delta_i\\)</span> 在 <span class=\"math inline\">\\([l,r]\\)</span> 间的整数中等概率取值，则最优解出现的概率？</p>\n</blockquote>\n<p>为什么 BFS 不能解决该问题呢？因为同层同代价的点对共同能访问到的点的贡献不会被 BFS 记入（注意到一个点只会被一个点访问到），所以只有建图出来才能解决问题。</p>\n<p>这也侧面反映该图在忽略环后所对应的就是最优解，这其实是有点 BFS 扩展出来的意味在的。</p>\n",
            "tags": [
                "优化建图"
            ]
        }
    ]
}