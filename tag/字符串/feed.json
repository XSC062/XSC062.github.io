{
    "version": "https://jsonfeed.org/version/1",
    "title": "null • All posts by \"字符串\" tag",
    "description": "",
    "home_page_url": "https://xsc062.netlify.app",
    "items": [
        {
            "id": "https://xsc062.netlify.app/20250809/",
            "url": "https://xsc062.netlify.app/20250809/",
            "title": "近期杂题",
            "date_published": "2025-08-09T04:33:17.000Z",
            "content_html": "<p>这段时间比赛的一些题 和 nKessi、duanyu 讲的题目。太偏计数、数学的基本上没办法做了。</p>\n<span id=\"more\"></span>\n<hr />\n<h2 id=\"a.-出关\">A. 出关</h2>\n<p><a href=\"http://222.180.160.110:61235/contest/6462/problem/1\" class=\"uri\">http://222.180.160.110:61235/contest/6462/problem/1</a></p>\n<blockquote>\n<p>给定 <span class=\"math inline\">\\(s\\)</span>，对于一个空串，任意利用下列三种操作，使其变为 <span class=\"math inline\">\\(s\\)</span>，求最小代价：</p>\n<ol type=\"1\">\n<li>在末尾添加字符 <span class=\"math inline\">\\(c\\)</span>，代价为 <span class=\"math inline\">\\(t_{0,c}\\)</span>；</li>\n<li>复制整个字符串并粘贴在末尾，代价为 <span class=\"math inline\">\\(t_1\\)</span>；</li>\n<li>删除末尾字符，代价为 <span class=\"math inline\">\\(t_2\\)</span>。</li>\n</ol>\n<p><span class=\"math inline\">\\(|s|\\le 10^6\\)</span>。</p>\n</blockquote>\n<p>可以预处理出对于每个 <span class=\"math inline\">\\(i\\)</span> 结尾，最多可以复制到哪个地方，发现要求 <span class=\"math inline\">\\(z_i=lcp(s_{1\\dots n},s_{i+1\\dots n})\\)</span>。那么一个 <span class=\"math inline\">\\(i\\)</span> 的最远转移点 <span class=\"math inline\">\\(r_i=i+z_{i+1}\\)</span>，用单调队列就能维护，会 exkmp 就能线性；</p>\n<p>否则可以二分 + 哈希多个 log，后面也有理由偷懒用优先队列了。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int p = 31;\nconst int mod = 998244353;\nint main() &#123;\n    std::freopen(&quot;laozi.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;laozi.out&quot;, &quot;w&quot;, stdout);\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n    std::string s;\n    std::cin &gt;&gt; s;\n    int n = (int)s.length(), t1, t2;\n    std::vector&lt;long long&gt; h(n + 1), base(n + 1);\n    std::vector&lt;int&gt; a(n + 1), t0(27), z(n + 1), r(n + 1);\n    base[0] = 1ll;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        a[i] = s[i - 1] - &#39;a&#39; + 1;\n        h[i] = (h[i - 1] * p + a[i]) % mod;\n        base[i] = base[i - 1] * p % mod;\n    &#125;\n    auto gethash = [&amp;](int l, int r) &#123;\n        return (h[r] - h[l - 1] * base[r - l + 1] % mod + mod) % mod;\n    &#125;;\n    for (int i = 1; i &lt;= n; ++i)\n        for (int l = 1, r = std::min(i - 1, n - i + 1), mid; l &lt;= r; ) &#123;\n            mid = (l + r) &gt;&gt; 1;\n            if (gethash(1, mid) == gethash(i, i + mid - 1))\n                z[i] = mid, l = mid + 1;\n            else\n                r = mid - 1;\n        &#125;\n    for (int i = 1; i &lt; n; ++i)\n        r[i] = i + std::min(i, z[i + 1]);\n    for (int i = 1; i &lt;= 26; ++i)\n        std::cin &gt;&gt; t0[i];\n    std::cin &gt;&gt; t1 &gt;&gt; t2;\n    std::vector&lt;long long&gt; f(n + 1);\n    std::priority_queue&lt;std::pair&lt;long long, int&gt; &gt; q;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        f[i] = f[i - 1] + t0[a[i]];\n        for (; !q.empty() &amp;&amp; r[q.top().second] &lt; i; q.pop());\n        if (!q.empty())\n            f[i] = std::min(f[i], t1 - q.top().first - (long long)t2 * i);\n        if (i != n)\n            q.emplace(-(f[i] + 2ll * t2 * i), i);\n    &#125;\n    std::cout &lt;&lt; f[n] &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"d.-非攻\">D. 非攻</h2>\n<p><a href=\"http://222.180.160.110:61235/contest/6462/problem/4\" class=\"uri\">http://222.180.160.110:61235/contest/6462/problem/4</a></p>\n<blockquote>\n<p>给定 <span class=\"math inline\">\\(n\\)</span>，对于一个 <span class=\"math inline\">\\(1\\sim n\\)</span> 的排列，使用最小的交换次数使得其单增。在该前提下，定义代价为每次交换的两个数之积。对于所有 <span class=\"math inline\">\\(n!\\)</span> 个排列，计算最小代价之和。</p>\n<p><span class=\"math inline\">\\(n\\le 10^7\\)</span>。</p>\n</blockquote>\n<p>转化成，把 <span class=\"math inline\">\\(1\\sim n\\)</span> 分成无标号的若干组，每组的代价是 最小值 <span class=\"math inline\">\\(\\times\\)</span> 其他元素的和，还有一个项链问题的系数，发现组间的符号是求和，考虑计算贡献。</p>\n<p>枚举 <span class=\"math inline\">\\(i,j\\)</span> 并钦定两个同属一个环，且 <span class=\"math inline\">\\(i\\)</span> 为最小值，枚举环大小 <span class=\"math inline\">\\(s+2\\)</span>，那么有：</p>\n<p><span class=\"math display\">\\[\n\\begin{aligned}\nres&amp;=\\sum_{i=1}^{n-1}\\sum_{j=i+1}^n i\\cdot j \\cdot \\sum_{s=0}^{n-i-1}\\binom{n-i-1}s \\cdot (s+1)!\\cdot (n-s-2)!\\\\\n&amp;=\\sum_{i=1}^{n-1}i\\cdot \\dfrac {(i+n+1)(n-i)}2 \\cdot \\sum_{s=0}^{n-i-1}\\binom{n-i-1}s\\cdot (s+1)!\\cdot (n-s-2)!\\\\\n&amp;=\\frac 12\\times\\sum_{i=1}^{n-1}i\\cdot (i+n+1)\\cdot (n-i)!\\cdot\\sum_{s=0}^{n-i-1}\\dfrac {(s + 1)\\cdot (n-s-2)!}{(n-i-1-s)!}\\\\\n\\end{aligned}\n\\]</span></p>\n<p>令 <span class=\"math inline\">\\(T=n-i-1\\)</span>，发现我们需要快速计算 <span class=\"math inline\">\\(f_T=\\sum\\limits_{i=0}^T \\dfrac{(i+1)\\cdot (n-i-2)!}{(T-i)!}\\)</span>。记 <span class=\"math inline\">\\(m=n-2\\)</span>，变形得 <span class=\"math inline\">\\(f_T=(m-T)!\\cdot \\sum\\limits_{i=0}^{T} (i+1) \\binom{m-i}{m-T}\\)</span>，发现似乎可以简化，令 <span class=\"math inline\">\\(k=m-T,t=T+1\\)</span>，则 <span class=\"math inline\">\\(f_T=\\sum\\limits_{i=1}^T i\\cdot \\binom {k+t-i}k\\)</span>。</p>\n<p>然后是经典的组合意义保平安环节，即从 <span class=\"math inline\">\\(k+t\\)</span> 个有标号小球中选择一条分界线，分界线左边选一个球、右边选 <span class=\"math inline\">\\(k\\)</span> 个球的方案数。发现分界线的存在很诡异，故用分界线后方的第一个球代替，在 <span class=\"math inline\">\\(t+1\\)</span> 处新建一个虚球，规定在前 <span class=\"math inline\">\\(t+1\\)</span> 个球中选两个球，并令后一个为分界线，且令前 <span class=\"math inline\">\\(t+1\\)</span> 个中的其他球为实球，就能建立双射。在分界线后再选 <span class=\"math inline\">\\(k\\)</span> 个球，容易发现直接在范围内选 <span class=\"math inline\">\\(k+2\\)</span> 个球就能满足条件，故 <span class=\"math inline\">\\(f_T=(n-T-2)!\\cdot \\binom{t+k+1}{k+2}\\)</span>。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 1e9 + 7;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n    std::freopen(&quot;mozi.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;mozi.out&quot;, &quot;w&quot;, stdout);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;long long&gt; fac(n + 1), inv(n + 1), f(n + 1);\n    fac[0] = inv[0] = 1ll;\n    for (int i = 1; i &lt;= n; ++i)\n        fac[i] = fac[i - 1] * i % mod;\n    auto qkp = [&amp;](long long x, int y) &#123;\n        auto res(1ll);\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    inv[n] = qkp(fac[n], mod - 2);\n    for (int i = n - 1; i; --i)\n        inv[i] = inv[i + 1] * (i + 1) % mod;\n    auto C = [&amp;](int n, int m) &#123;\n        return fac[n] * inv[n - m] % mod * inv[m] % mod;\n    &#125;;\n    int m = n - 2;\n    for (int T = 0; T &lt;= n - 2; ++T) &#123;\n        int k = m - T, t = T + 1;\n        f[T] = C(t + k + 1, k + 2) * fac[m - T] % mod;\n    &#125;\n    auto res = 0ll;\n    for (int i = 1; i &lt;= n - 1; ++i)\n        (res += (long long)i * (i + n + 1) % mod * fac[n - i] % mod * f[n - i - 1] % mod) %= mod;\n    std::cout &lt;&lt; res * inv[2] % mod &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"c---destruction-of-walls\">C - Destruction of Walls</h2>\n<p><a href=\"https://atcoder.jp/contests/arc203/tasks/arc203_c\" class=\"uri\">https://atcoder.jp/contests/arc203/tasks/arc203_c</a></p>\n<hr />\n<h2 id=\"d---insert-xor\">D - Insert XOR</h2>\n<p><a href=\"https://atcoder.jp/contests/arc203/tasks/arc203_d\" class=\"uri\">https://atcoder.jp/contests/arc203/tasks/arc203_d</a></p>\n<hr />\n<h2 id=\"a---记忆\">A - 记忆</h2>\n<p><a href=\"https://ac.nowcoder.com/acm/problem/274793\" class=\"uri\">https://ac.nowcoder.com/acm/problem/274793</a></p>\n<p>需要意识到问题是静态的，并且不能用线段树之类维护；故考虑离线下来，想办法在 LCA 处统计答案。</p>\n<p>这个时候发现需要合并子树状态、整体异或、整体 +1，很容易想到 Trie。把 <span class=\"math inline\">\\(u\\to\\)</span> LCA 的答案保存在 LCA 处，然后再用 DFS + 回溯统计 LCA <span class=\"math inline\">\\(\\to v\\)</span> 的答案。想了半天没想到把上下拆开来做也是神了 😅</p>\n<p>可能比较考验对字典树的理解？做个比喻，字典树的 id 就相当于对这个点上信息的『引用』。</p>\n<details>\n<p>字典树合并的时候可以考虑回收废弃点，不然可能有点卡。</p>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int X = 50;\nconst int maxn = 2e7 + 5;\nlong long d[maxn];\nint tot, T[maxn][2], f[maxn], fa[maxn];\n#define lc(p) T[p][0]\n#define rc(p) T[p][1]\nint find(int x) &#123; return x == f[x] ? x : f[x] = find(f[x]); &#125;\nint newnode(void) &#123;\n    int p = ++tot;\n    assert(p &lt; maxn);\n    d[p] = lc(p) = rc(p) = 0, f[p] = p;\n    return p;\n&#125;\nvoid pushdown(int p) &#123;\n    if (d[p]) &#123;\n        if (d[p] &amp; 1)\n            std::swap(lc(p), rc(p));\n        d[p] &gt;&gt;= 1;\n        if (lc(p))\n            d[lc(p)] ^= d[p];\n        if (rc(p))\n            d[rc(p)] ^= d[p];\n        d[p] = 0;\n    &#125;\n    return;\n&#125;\nint ins(int p, long long x) &#123;\n    for (int i = 0; i &lt; X; ++i) &#123;\n        pushdown(p);\n        if (!T[p][(x &gt;&gt; i) &amp; 1]) &#123;\n            T[p][(x &gt;&gt; i) &amp; 1] = newnode();\n            fa[T[p][(x &gt;&gt; i) &amp; 1]] = p;\n        &#125;\n        p = T[p][(x &gt;&gt; i) &amp; 1];\n    &#125;\n    return p;\n&#125;\nvoid merge(int &amp;p, int q) &#123;\n    if (!q)\n        return;\n    if (!p) &#123;\n        p = q;\n        return;\n    &#125;\n    pushdown(p), pushdown(q);\n    fa[lc(q)] = p, fa[rc(q)] = p;\n    merge(lc(p), lc(q)), merge(rc(p), rc(q));\n    assert(f[p] == p), assert(f[q] == q), f[q] = p;\n    return;\n&#125;\nlong long ask(int p) &#123;\n    std::vector&lt;int&gt; st;\n    for (int i = 0, j = p; i &lt; X; ++i)\n        st.push_back(fa[j]), j = fa[j];\n    for (int i = 0; i &lt; X; ++i)\n        pushdown(st.back()), st.pop_back();\n    long long x = 0;\n    for (int i = 0; i &lt; X; ++i) &#123;\n        x = x * 2 + (p == rc(fa[p]));\n        p = fa[p];\n    &#125;\n    return x;\n&#125;\nvoid add(int p) &#123;\n    for (int i = 0; p &amp;&amp; i &lt; X; ++i) &#123;\n        pushdown(p);\n        std::swap(lc(p), rc(p));\n        p = lc(p);\n    &#125;\n    return;\n&#125;\nvoid del(int p) &#123;\n    for (int i = 0; p &amp;&amp; i &lt; X; ++i) &#123;\n        pushdown(p);\n        std::swap(lc(p), rc(p));\n        p = rc(p);\n    &#125;\n    return;\n&#125;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, m;\n    std::cin &gt;&gt; n &gt;&gt; m;\n    std::vector&lt;int&gt; a(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i];\n    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);\n    for (int i = 1, x, y; i &lt; n; ++i) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y;\n        g[x].push_back(y), g[y].push_back(x);\n    &#125;\n    std::vector&lt;int&gt; siz(n + 1), son(n + 1), top(n + 1), fa(n + 1), dep(n + 1);\n    std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;\n        siz[x] = 1;\n        for (auto i : g[x])\n            if (i != fa[x]) &#123;\n                dep[i] = dep[x] + 1;\n                fa[i] = x, DFS(i);\n                siz[x] += siz[i];\n                if (siz[i] &gt; siz[son[x]])\n                    son[x] = i;\n            &#125;\n        return;\n    &#125;;\n    DFS(1);\n    DFS = [&amp;](int x) &#123;\n        if (son[x])\n            top[son[x]] = top[x], DFS(son[x]);\n        for (auto i : g[x])\n            if (i != son[x] &amp;&amp; i != fa[x])\n                top[i] = i, DFS(i);\n        return;\n    &#125;;\n    top[1] = 1, DFS(1);\n    auto askLCA = [&amp;](int x, int y) &#123;\n        for (; top[x] != top[y]; x = fa[top[x]])\n            if (dep[top[x]] &lt; dep[top[y]])\n                std::swap(x, y);\n        return dep[x] &lt; dep[y] ? x : y;\n    &#125;;\n    struct node &#123; long long x; int u, v; &#125;;\n    std::vector&lt;node&gt; q(m + 1);\n    std::vector&lt;int&gt; id(m + 1);\n    std::vector&lt;long long&gt; res(m + 1), ans(m + 1);\n    std::vector&lt;std::vector&lt;int&gt; &gt; up(n + 1), dn(n + 1), ed(n + 1);\n    for (int i = 1, x, u, v; i &lt;= m; ++i) &#123;\n        std::cin &gt;&gt; x &gt;&gt; u &gt;&gt; v;\n        q[i] = &#123; x, u, v &#125;;\n        up[u].push_back(i), dn[askLCA(u, v)].push_back(i), ed[v].push_back(i);\n    &#125;\n    std::vector&lt;int&gt; rt(n + 1);\n    DFS = [&amp;](int x) &#123;\n        rt[x] = newnode();\n        for (auto i : g[x])\n            if (i != fa[x]) &#123;\n                DFS(i);\n                merge(rt[x], rt[i]);\n            &#125;\n        add(rt[x]);\n        for (auto i : up[x])\n            id[i] = ins(rt[x], q[i].x);\n        d[rt[x]] ^= a[x];\n        for (auto i : dn[x])\n            res[i] = ask(find(id[i]));\n        return;\n    &#125;;\n    DFS(1);\n    tot = 0, rt[0] = newnode();\n    std::fill(id.begin() + 1, id.end(), 0);\n    DFS = [&amp;](int x) &#123;\n        d[rt[0]] ^= a[x];\n        for (auto i : dn[x])\n            id[i] = ins(rt[0], res[i]);\n        for (auto i : ed[x])\n            ans[i] = ask(id[i]);\n        add(rt[0]);\n        for (auto i : g[x])\n            if (i != fa[x])\n                DFS(i);\n        del(rt[0]);\n        d[rt[0]] ^= a[x];\n        return;\n    &#125;;\n    DFS(1);\n    for (int i = 1; i &lt;= m; ++i)\n        std::cout &lt;&lt; ans[i] &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"b---ビーバーの会合-2-meetings-2\">B - ビーバーの会合 2 (Meetings 2)</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/AT_joisc2021_j\" class=\"uri\">https://www.luogu.com.cn/problem/AT_joisc2021_j</a></p>\n<p>定义所求点为『局部重心』；类似树的重心，容易发现当关键点数量为奇时，只存在一个局部重心；否则，局部重心组成一条链。</p>\n<p>即对于每一个 <span class=\"math inline\">\\(i\\)</span>，需要找到一条最长链，使得其两端存在大小为 <span class=\"math inline\">\\(i\\)</span> 的子树（容易发现取后缀 max 即可得到真实答案）。使用点分治，精细实现容易做到 <span class=\"math inline\">\\(O(n\\log n)\\)</span>。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);\n    for (int i = 1, x, y; i &lt; n; ++i) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y;\n        g[x].push_back(y), g[y].push_back(x);\n    &#125;\n    std::vector&lt;int&gt; mx(n + 1), siz(n + 1), p, tag(n + 1), res(n + 1, 1);\n    std::function&lt;void(int, int)&gt; DFS1 = [&amp;](int x, int fa) &#123;\n        p.push_back(x);\n        siz[x] = 1, mx[x] = 0;\n        for (auto i : g[x])\n            if (!tag[i] &amp;&amp; i != fa) &#123;\n                DFS1(i, x);\n                siz[x] += siz[i];\n                mx[x] = std::max(mx[x], siz[i]);\n            &#125;\n        return;\n    &#125;;\n    auto findrt = [&amp;](int x) &#123;\n        p.clear(), DFS1(x, -1);\n        int n = (int)p.size();\n        for (auto i : p)\n            if (mx[i] &lt;= n / 2 &amp;&amp; n - siz[i] &lt;= n / 2)\n                return i;\n        assert(0);\n        return -1;\n    &#125;;\n    struct node &#123;\n        int u1, u2, id1, id2;\n        node(): u1(0), u2(0), id1(0), id2(0) &#123;&#125;\n        void upd(int u, int id) &#123;\n            if (id1 == id)\n                u1 = std::max(u1, u);\n            else if (u &gt;= u1)\n                u2 = u1, id2 = id1, u1 = u, id1 = id;\n            else if (u &gt;= u2)\n                u2 = u, id2 = id;\n            return;\n        &#125;\n    &#125;;\n    std::vector&lt;node&gt; s(n + 1);\n    std::function&lt;void(int, int, int, int)&gt; DFS2 = [&amp;](int x, int fa, int dep, int anc) &#123;\n        s[siz[x]].upd(dep, anc);\n        for (auto i : g[x])\n            if (!tag[i] &amp;&amp; i != fa)\n                DFS2(i, x, dep + 1, anc);\n        return;\n    &#125;;\n    std::function&lt;void(int, int, int, int)&gt; DFS3 = [&amp;](int x, int fa, int dep, int anc) &#123;\n        int v = ((s[siz[x]].id1 == anc) ? s[siz[x]].u2 : s[siz[x]].u1);\n        res[2 * siz[x]] = std::max(res[2 * siz[x]], dep + 1 + v);\n        for (auto i : g[x])\n            if (!tag[i] &amp;&amp; i != fa)\n                DFS3(i, x, dep + 1, anc);\n        return;\n    &#125;;\n    std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;\n        x = findrt(x), p.clear(), DFS1(x, -1);\n        // printf(&quot;rt = %d\\n&quot;, x);\n        for (auto i : g[x])\n            if (!tag[i])\n                DFS2(i, x, 1, i);\n        for (int i = siz[x] - 1; i; --i) &#123;\n            s[i].upd(s[i + 1].u1, s[i + 1].id1);\n            s[i].upd(s[i + 1].u2, s[i + 1].id2);\n        &#125;\n        for (auto i : g[x])\n            if (!tag[i])\n                DFS3(i, x, 1, i);\n        tag[x] = 1;\n        for (int i = 1; i &lt; siz[x]; ++i)\n            s[i] = node();\n        for (auto i : g[x])\n            if (!tag[i])\n                DFS(i);\n        return;\n    &#125;;\n    DFS(1);\n    for (int i = (n &gt;&gt; 1) * 2; i; --i)\n        if (i + 2 &lt;= n)\n            res[i] = std::max(res[i], res[i + 2]);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cout &lt;&lt; res[i] &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"c---the-closest-pair\">C - The Closest Pair</h2>\n<p><a href=\"https://ac.nowcoder.com/acm/problem/262593\" class=\"uri\">https://ac.nowcoder.com/acm/problem/262593</a></p>\n<p><strong>常规方法</strong>：考虑<strong>支配对</strong>，对于每个 <span class=\"math inline\">\\(a_i\\)</span>，找到所有合法的 <span class=\"math inline\">\\(a_j\\)</span>。容易想到枚举 <span class=\"math inline\">\\(a_i\\div a_j\\)</span> 来做；假设存在 <span class=\"math inline\">\\(a_k\\div a_i=a_j\\div a_i\\)</span> 且 <span class=\"math inline\">\\(k&gt;j\\)</span>。</p>\n<p>不妨设 <span class=\"math inline\">\\(a_j=K\\cdot a_i+p,a_k=K\\cdot a_i+q\\)</span>，<span class=\"math inline\">\\((a_i,a_j),(a_i,a_k)\\)</span> 均合法当且仅当下列条件全部成立：</p>\n<ul>\n<li><span class=\"math inline\">\\(a_j\\bmod a_i&gt;a_k\\bmod a_i\\)</span>； 则 <span class=\"math inline\">\\(a_j&gt;a_k\\)</span>。</li>\n<li><span class=\"math inline\">\\(a_j\\bmod a_k&gt;a_k\\bmod a_i\\)</span>；又 <span class=\"math inline\">\\(p-q\\ge a_j\\bmod a_k\\)</span>（<strong>太牛了这一步</strong>），即 <span class=\"math inline\">\\(p-q&gt;q\\iff p&gt;2q\\)</span>。</li>\n</ul>\n<p>证得只关心同一个 <span class=\"math inline\">\\(a_j\\div a_i\\)</span> 时的支配对数量为 <span class=\"math inline\">\\(\\log n\\)</span> 级别；总对数 <span class=\"math inline\">\\(O(n\\log n\\ln n)\\)</span>。离线下来扫描线就行了。</p>\n<details>\n<p>对着 单点修改 区间最值 想了 1h 的单 log 做法 😰 果然小脑掉线太可怕了，第二天早上重置大脑 1s 发现自己是斯波 😓</p>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int LEN = (1 &lt;&lt; 20);\nint nec(void) &#123;\n    static char buf[LEN], *p = buf, *e = buf;\n    if (p == e) &#123;\n        e = buf + fread(buf, 1, LEN, stdin);\n        if (e == buf) return EOF;\n        p = buf;\n    &#125;\n    return *p++;\n&#125;\nbool read(int &amp;x) &#123;\n    x = 0;\n    bool f = 0;\n    char ch = nec();\n    while (ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123;\n        if (ch == EOF) return 0;\n        if (ch == &#39;-&#39;) f = 1;\n        ch = nec();\n    &#125;\n    while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) &#123;\n        x = x * 10 + ch - &#39;0&#39;;\n        ch = nec();\n    &#125;\n    if (f) x = -x;\n    return 1;\n&#125;\nvoid print(int x) &#123;\n    if (x &lt; 0)\n        putchar(&#39;-&#39;), x = -x;\n    if (x &gt;= 10) print(x / 10);\n    putchar(x % 10 + &#39;0&#39;);\n    return;\n&#125;\nvoid print(int x, char ch) &#123;\n    print(x), putchar(ch);\n    return;\n&#125;\nconst int maxn = 4e6 + 5;\nstruct &#123; int l, r, u[2]; &#125; t[maxn];\n#define lt (t[p].l)\n#define rt (t[p].r)\nint tot[2];\nvoid add(int &amp;p, int l, int r, int x, int v, int i) &#123;\n    if (!p)\n        p = ++tot[i], t[p].u[0] = -1, t[p].u[1] = 0x3f3f3f3f;\n    if (i == 0)\n        t[p].u[0] = std::max(t[p].u[0], v);\n    else\n        t[p].u[1] = std::min(t[p].u[1], v);\n    if (l == r)\n        return;\n    int mid = (l + r) &gt;&gt; 1;\n    if (x &lt;= mid)\n        add(lt, l, mid, x, v, i);\n    else\n        add(rt, mid + 1, r, x, v, i);\n    return;\n&#125;\nint ask(int p, int l, int r, int ql, int qr, int i) &#123;\n    if (!p || (ql &lt;= l &amp;&amp; r &lt;= qr))\n        return t[p].u[i];\n    int mid = (l + r) &gt;&gt; 1;\n    if (qr &lt;= mid)\n        return ask(lt, l, mid, ql, qr, i);\n    if (ql &gt; mid)\n        return ask(rt, mid + 1, r, ql, qr, i);\n    if (i == 0)\n        return std::max(ask(lt, l, mid, ql, qr, 0), ask(rt, mid + 1, r, ql, qr, 0));\n    return std::min(ask(lt, l, mid, ql, qr, 1), ask(rt, mid + 1, r, ql, qr, 1));\n&#125;\n#undef lt\n#undef rt\nint main() &#123;\n#ifndef ONLINE_JUDGE\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    const int m = 1e6;\n    int rt[2] = &#123; 0 &#125;, n;\n    t[0].u[0] = -1, t[0].u[1] = 0x3f3f3f3f;\n    read(n);\n    std::vector&lt;int&gt; a(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        read(a[i]);\n    std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; t(n + 1);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        if (i != 1) &#123;\n            for (int K = a[i]; K &lt;= m; K += a[i]) &#123;\n                for (int mx = std::min(a[i] - 1, m - K); ; ) &#123;\n                    int k = ask(rt[0], 1, m, K, K + mx, 0);\n                    if (k == -1)\n                        break;\n                    t[i].emplace_back(k, a[k] - K);\n                    if (k == 1 || !(a[k] - K))\n                        break;\n                    mx = (a[k] - K - 1) / 2;\n                &#125;\n            &#125;\n        &#125;\n        add(rt[0], 1, m, a[i], i, 0);\n    &#125;\n    for (int i = n; i; --i) &#123;\n        if (i != n)\n            for (int K = a[i]; K &lt;= m; K += a[i])\n                for (int mx = std::min(a[i] - 1, m - K); ; ) &#123;\n                    int k = ask(rt[1], 1, m, K, K + mx, 1);\n                    if (k == 0x3f3f3f3f)\n                        break;\n                    t[k].emplace_back(i, a[k] - K);\n                    if (k == n || !(a[k] - K))\n                        break;\n                    mx = (a[k] - K - 1) / 2;\n                &#125;\n        add(rt[1], 1, m, a[i], i, 1);\n    &#125;\n    int q;\n    read(q);\n    std::vector&lt;int&gt; res(q + 1);\n    std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; u(n + 1);\n    for (int i = 1, l, r; i &lt;= q; ++i) &#123;\n        read(l), read(r);\n        if (l &gt; r)\n            std::swap(l, r);\n        u[r].emplace_back(l, i);\n    &#125;\n    std::vector&lt;int&gt; bit(n + 1, 0x3f3f3f3f);\n    auto lowbit = [&amp;](int x) &#123; return x &amp; -x; &#125;;\n    auto add = [&amp;](int x, int v) &#123;\n        for (; x &lt;= n; x += lowbit(x))\n            bit[x] = std::min(bit[x], v);\n        return;\n    &#125;;\n    auto ask = [&amp;](int x) &#123;\n        auto res = 0x3f3f3f3f;\n        for (; x; x -= lowbit(x))\n            res = std::min(res, bit[x]);\n        return res;\n    &#125;;\n    for (int r = 1; r &lt;= n; ++r) &#123;\n        for (auto [l, v] : t[r])\n            add(n - l + 1, v);\n        for (auto [l, i] : u[r])\n            res[i] = ask(n - l + 1);\n    &#125;\n    for (int i = 1; i &lt;= q; ++i)\n        print(res[i], &#39;\\n&#39;);\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<p>求支配对的过程也要带 log（线段树），再加上扫描线的 3log，总共是常数比较大的 3log（卡了一个上午的常也是有了）。所以接下来讲解另一种奇技淫巧。</p>\n<p><strong>暴力分治</strong>：注意到对于比较长（<span class=\"math inline\">\\(len&gt; B\\)</span>）的区间，答案比较小；故考虑分治。</p>\n<ul>\n<li>对于长询问（<span class=\"math inline\">\\(len&gt;B\\)</span>），从小到大枚举答案并 check；预处理某个范围（<span class=\"math inline\">\\(V\\)</span>）内的 <span class=\"math inline\">\\(res\\)</span> 出现的所有位置，平衡的时候还要算上调和级数和 bit。</li>\n<li>对于短询问（<span class=\"math inline\">\\(len\\le B\\)</span>），发现每次区间内暴力是 <span class=\"math inline\">\\(O(B^2q)\\)</span> 的；把询问离线下来，精细实现，利用询问的公共部分使得<strong>每一对数只被枚举一次</strong>就能达到 <span class=\"math inline\">\\(O(B^2 + Bq)\\)</span>。</li>\n</ul>\n<p>最优解取 <span class=\"math inline\">\\(B=333,V=483\\)</span>，不自己实现一遍了。</p>\n<hr />\n<h2 id=\"d---仙人掌\">D - 仙人掌</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P3687\" class=\"uri\">https://www.luogu.com.cn/problem/P3687</a></p>\n<p>把边双从图中删除、问题转化为树上<strong>边</strong>不交的链覆盖，使得<strong>所有链长 <span class=\"math inline\">\\(\\ge 2\\)</span></strong> 的方案数。发现由于<strong>边可以不被覆盖</strong>，常规 DP 会使得在父节点处合并时需要额外的数量维，参考树上背包，复杂度 <span class=\"math inline\">\\(O(n^2)\\)</span>。</p>\n<p>思考时会注意到两个限制可以抵消——如果认为长为 <span class=\"math inline\">\\(1\\)</span> 的链就是不被覆盖的边，覆盖所有树边，显然可以建立和合法解的双射。此时合并是非常方便的，注意到每个儿子的系数一定都参与『分步』，只需要求出『分类』的系数。这个可以预处理（和 <a href=\"/20250407/#a.-二分图染色\">二分图染色</a> 这个题有点像），令 <span class=\"math inline\">\\(f_i\\)</span> 表示一个点度数为 <span class=\"math inline\">\\(i\\)</span> 时的答案，参考错排的思路，则 <span class=\"math inline\">\\(i\\)</span> 可以不参与配对，也可以乱选一个点配对，如果选中了已配对的点就令其和 <span class=\"math inline\">\\(i-1\\)</span> 交换，可以建立和合法解的双射。则 <span class=\"math inline\">\\(f_i=f_{i-1}+(n-1)f_{i-2}\\)</span>。</p>\n<p>首先需要 check 原图是否为仙人掌，顺带回忆一下连通性的知识——在 DFS 树上差分，检查是否有边被覆盖两次即可。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 998244353;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int T;\n    for (std::cin &gt;&gt; T; T--; ) &#123;\n        int n, m;\n        std::cin &gt;&gt; n &gt;&gt; m;\n        std::vector&lt;std::vector&lt;int&gt; &gt; g1(n + 1);\n        for (int x, y; m--; ) &#123;\n            std::cin &gt;&gt; x &gt;&gt; y;\n            g1[x].push_back(y), g1[y].push_back(x);\n        &#125;\n        bool flag = 1;\n        int now = 0, cnt = 0;\n        std::vector&lt;int&gt; st, dfn(n + 1), low(n + 1), col(n + 1), diff(n + 1);\n        std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int fa) &#123;\n            st.push_back(x);\n            dfn[x] = low[x] = ++now;\n            for (auto i : g1[x])\n                if (!dfn[i]) &#123;\n                    // printf(&quot;x = %d, %d -&gt; %d\\n&quot;, x, x, i);\n                    DFS(i, x);\n                    diff[x] += diff[i];\n                    // printf(&quot;x = %d, diff[%d] += diff[%d]\\n&quot;, x, x, i);\n                    low[x] = std::min(low[x], low[i]);\n                &#125;\n                else if (i != fa &amp;&amp; dfn[i] &lt; dfn[x]) &#123;\n                    low[x] = std::min(low[x], dfn[i]);\n                    ++diff[x], --diff[i];\n                    // printf(&quot;x = %d, ++diff[%d], --diff[%d]\\n&quot;, x, x, i);\n                &#125;\n            if (diff[x] &gt;= 2)\n                flag = 0;\n            // printf(&quot;x = %d, diff[%d] = %d\\n&quot;, x, x, diff[x]);\n            if (low[x] == dfn[x]) &#123;\n                ++cnt;\n                for (int p = -1; p != x; ) &#123;\n                    p = st.back(), st.pop_back();\n                    col[p] = cnt;\n                &#125;\n            &#125;\n            return;\n        &#125;;\n        DFS(1, -1);\n        if (!flag) &#123;\n            std::cout &lt;&lt; 0 &lt;&lt; &#39;\\n&#39;;\n            continue;\n        &#125;\n        std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);\n        for (int i = 1; i &lt;= n; ++i)\n            for (auto j : g1[i])\n                if (col[i] != col[j])\n                    g[i].push_back(j);\n        std::vector&lt;long long&gt; f(n + 1), dp(n + 1);\n        dp[0] = 1ll, dp[1] = 1ll;\n        for (int i = 2; i &lt;= n; ++i)\n            dp[i] = (dp[i - 1] + (i - 1) * dp[i - 2]) % mod;\n        std::vector&lt;int&gt; tag(n + 1);\n        DFS = [&amp;](int x, int fa) &#123;\n            f[x] = 1ll, tag[x] = 1;\n            for (auto i : g[x])\n                if (i != fa) &#123;\n                    DFS(i, x);\n                    (f[x] *= f[i]) %= mod;\n                &#125;\n            (f[x] *= dp[(int)g[x].size()]) %= mod;\n            return;\n        &#125;;\n        auto res(1ll);\n        for (int i = 1; i &lt;= n; ++i)\n            if (!tag[i])\n                DFS(i, -1), (res *= f[i]) %= mod;\n        std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<p>E. Many Minimizations 是数学题，跳了。</p>\n<hr />\n<hr />\n<h2 id=\"无名题\">无名题</h2>\n<blockquote>\n<p>背景：给定 <span class=\"math inline\">\\(n,k\\)</span>，对于 <span class=\"math inline\">\\(\\forall\\, 1\\le i\\le n\\)</span>，令 <span class=\"math inline\">\\(a_i=i\\bmod k\\)</span>，问一共有多少个本质不同的子序列？对于 <span class=\"math inline\">\\(k=1,2,\\cdots,n\\)</span> 分别求出答案。</p>\n</blockquote>\n<hr />\n<h2 id=\"maimai\">maimai</h2>\n<p><a href=\"https://ac.nowcoder.com/acm/contest/66112/F\" class=\"uri\">https://ac.nowcoder.com/acm/contest/66112/F</a></p>\n",
            "tags": [
                "字典树",
                "字符串",
                "组合数学",
                "支配对"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20250202/",
            "url": "https://xsc062.netlify.app/20250202/",
            "title": "学习笔记：后缀数组",
            "date_published": "2025-02-02T00:27:44.000Z",
            "content_html": "<p>非常后知后觉地意识到 SA(Suffix Array) 和 SAM(Suffix Automaton) 的 A 不是同一个 A <img src=\"/em/fad.gif\" /></p>\n<span id=\"more\"></span>\n<hr />\n<h2 id=\"定义\">定义</h2>\n<p>显而易见一个长度为 <span class=\"math inline\">\\(n\\)</span> 的字符串中有 <span class=\"math inline\">\\(n\\)</span> 个长度分别为 <span class=\"math inline\">\\(1\\sim n\\)</span> 的后缀，如果我们对其按字典序排序，分别存储下排名 <span class=\"math inline\">\\(i\\)</span> 的后缀 <span class=\"math inline\">\\(sa_i\\)</span> 和每个后缀 <span class=\"math inline\">\\(i\\)</span> 的排名 <span class=\"math inline\">\\(rk_i\\)</span>。虽然看着挺没头没尾的，但是很有用。</p>\n<h2 id=\"求解\">求解</h2>\n<h3 id=\"哈希-排序\">哈希 + 排序</h3>\n<p>直接把所有后缀拿来排序的话，字符串比较是 <span class=\"math inline\">\\(O(n)\\)</span> 的。如果我们用哈希 + 二分优化比较过程，就可以把整个排序优化到 <span class=\"math inline\">\\(O(n\\log^2 n)\\)</span>。</p>\n<h3 id=\"倍增\">倍增</h3>\n<p>先对所有后缀按 <strong>第一个字符</strong> 排序，记排序后排名序列为 <span class=\"math inline\">\\(a\\)</span>。</p>\n<p>那么怎么按 <strong>前两个字符</strong> 排序呢？对于第 <span class=\"math inline\">\\(i\\)</span> 组字符，我们用 <span class=\"math inline\">\\((a_i,a_{i+1})\\)</span> 双关键字排序即可。记此时排名序列为 <span class=\"math inline\">\\(b\\)</span>，那么如果需要按照前四个字符排序，用 <span class=\"math inline\">\\((b_i,b_{i+2})\\)</span> 进行双关键字排序即可。总共需要进行 <span class=\"math inline\">\\(\\log n\\)</span> 次排序。复杂度为 <span class=\"math inline\">\\(O(n\\log^2n)\\)</span>。</p>\n<p>此时我们注意到排名数组的值域为 <span class=\"math inline\">\\(n\\)</span>，那么我们用桶排就能少一个 <span class=\"math inline\">\\(\\log\\)</span>。</p>\n<h2 id=\"实现\">实现</h2>\n<p>哈希很好实现，这里就按下不表，主要讲解倍增法的实现。</p>\n<p>描述起来很简单，实现起来很要命。OI wiki 上的实现算是相对好理解的：</p>\n<p>首先了解双关键字桶排的方法，首先用单关键字桶排完成对 <strong>第二关键字</strong> 的排序；对于第一关键字，令桶 <span class=\"math inline\">\\(i\\)</span> 记录前 <span class=\"math inline\">\\(i\\)</span> 个元素的数量；遍历排序后的第二关键字数组，将元素放到桶中记录数值对应的下标中，并将桶中数值 <span class=\"math inline\">\\(-1\\)</span>。实际上桶 <span class=\"math inline\">\\(c\\)</span> 充当计算下标范围的作用，<span class=\"math inline\">\\((c_{i-1},c_i]\\)</span> 即为 <span class=\"math inline\">\\(i\\)</span> 分布的范围。</p>\n<p>显然，当且仅当排名种类为 <span class=\"math inline\">\\(n\\)</span>，即没有并列排名时，排序完成。设本轮区间长度为 <span class=\"math inline\">\\(w\\)</span>，对于一轮操作：</p>\n<ol type=\"1\">\n<li>计算每个区间按后半段 <span class=\"math inline\">\\(\\frac w2\\)</span> 长度字符排序的结果：<span class=\"math inline\">\\((n-w,n]\\)</span> 开头的区间后半段均为空，直接放在序列首端；接着按照上一轮 <span class=\"math inline\">\\(sa\\)</span> 结果，把能够作为后半段的元素依次放入。</li>\n<li>依照上一轮的 <span class=\"math inline\">\\(rk\\)</span> 作为前半段排名，进行双关键字桶排。</li>\n<li>依照 <span class=\"math inline\">\\(sa\\)</span> 和第二关键字（处理并列），求出 <span class=\"math inline\">\\(rk\\)</span>。</li>\n</ol>\n<details>\n<pre class=\"cpp\"><code>std::vector&lt;int&gt; la(n + 2);\nstd::copy(s.begin(), s.end(), rk.begin());\nint m = 128;\n&#123;\n    std::vector&lt;int&gt; c(m + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        ++c[rk[i]];\n    std::partial_sum(c.begin(), c.end(), c.begin());\n    for (int i = n; i; --i)\n        sa[c[rk[i]]--] = i;\n&#125; \nfor (int w = 1, p; ; w &lt;&lt;= 1, m = p) &#123;\n    std::vector&lt;int&gt; id(1);\n    for (int i = n - w + 1; i &lt;= n; ++i)\n        id.push_back(i);\n    for (int i = 1; i &lt;= n; ++i)\n        if (sa[i] &gt; w)\n            id.push_back(sa[i] - w);\n    std::vector&lt;int&gt; c(m + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        ++c[rk[i]];\n    std::partial_sum(c.begin(), c.end(), c.begin());\n    for (int i = n; i; --i)\n        sa[c[rk[id[i]]]--] = id[i];\n    p = 0;\n    std::copy(rk.begin(), rk.end(), la.begin());\n    for (int i = 1; i &lt;= n; ++i)\n        if (la[sa[i]] == la[sa[i - 1]] &amp;&amp; la[sa[i] + w] == la[sa[i - 1] + w])\n            rk[sa[i]] = p;\n        else\n            rk[sa[i]] = ++p;\n    if (p == n)\n        break;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"纯-sa-的应用\">纯 SA 的应用</h2>\n<h3 id=\"最小表示法\">最小表示法</h3>\n<p>模板：<a href=\"https://www.luogu.com.cn/problem/P1368\" class=\"uri\">https://www.luogu.com.cn/problem/P1368</a>。</p>\n<p>对于循环位移相关要求，首先考虑将字符串重复一遍。</p>\n<p>在 <span class=\"math inline\">\\(ss\\)</span> 中找到排名第一个 <span class=\"math inline\">\\(sa_i\\le n\\)</span> 即为答案。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;int&gt; s(2 * n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; s[i], s[n + i] = s[i];\n    std::vector&lt;int&gt; sa(2 * n + 1), rk(s);\n    &#123;\n        int m = 29;\n        &#123;\n            std::vector&lt;int&gt; c(m + 1);\n            for (int i = 1; i &lt;= 2 * n; ++i)\n                ++c[rk[i]];\n            std::partial_sum(c.begin(), c.end(), c.begin());\n            for (int i = 2 * n; i; --i)\n                sa[c[rk[i]]--] = i;\n        &#125;\n        for (int w = 1, p; ; w &lt;&lt;= 1, m = p) &#123;\n            std::vector&lt;int&gt; id(1);\n            for (int i = 2 * n - w + 1; i &lt;= 2 * n; ++i)\n                id.push_back(i);\n            for (int i = 1; i &lt;= 2 * n; ++i)\n                if (sa[i] &gt; w)\n                    id.push_back(sa[i] - w);\n            std::vector&lt;int&gt; c(m + 1);\n            for (int i = 1; i &lt;= 2 * n; ++i)\n                ++c[rk[i]];\n            std::partial_sum(c.begin(), c.end(), c.begin());\n            for (int i = 2 * n; i; --i)\n                sa[c[rk[id[i]]]--] = id[i];\n            auto la(rk);\n            p = 0;\n            for (int i = 1; i &lt;= 2 * n; ++i)\n                if (i != 1 &amp;&amp; la[sa[i]] == la[sa[i - 1]] &amp;&amp; la[sa[i] + w] == la[sa[i - 1] + w])\n                    rk[sa[i]] = p;\n                else\n                    rk[sa[i]] = ++p;\n            if (p == 2 * n)\n                break;\n        &#125;\n    &#125;\n    for (int i = 1; i &lt;= 2 * n; ++i)\n        if (sa[i] &lt;= n) &#123;\n            for (int j = sa[i]; j &lt; n + sa[i]; ++j)\n                std::cout &lt;&lt; s[j] &lt;&lt; &#39; &#39;;\n            std::cout &lt;&lt; &#39;\\n&#39;;\n            break;\n        &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"字符串匹配\">字符串匹配</h3>\n<p>二分，复杂度 <span class=\"math inline\">\\(O(|S|\\log |T|)\\)</span>。求出现次数则二分左右边界。</p>\n<p>太麻烦了且没有实际应用价值，代码略。</p>\n<hr />\n<h2 id=\"height-数组\">height 数组</h2>\n<p>定义 <span class=\"math inline\">\\(h_i=\\text {lcp}(sa_i, sa_i-1)\\)</span>，特别地，<span class=\"math inline\">\\(h_1=0\\)</span>。</p>\n<blockquote>\n<p>有引理：<span class=\"math inline\">\\(h_{rk_i}\\ge h_{rk_{i-1}}-1\\)</span>。</p>\n</blockquote>\n<p>假设已经求出 <span class=\"math inline\">\\(h_{rk_{i-1}}\\)</span>，那么可以从 <span class=\"math inline\">\\(h_{rk_{i-1}}-1\\)</span> 出发暴力看下一个字符是否相等得到答案。那么我们会发现从前往后 <span class=\"math inline\">\\(h\\)</span> 值每次最多 <span class=\"math inline\">\\(-1\\)</span>，所以复杂度摊下来是 <span class=\"math inline\">\\(O(n)\\)</span> 的。</p>\n<p><mark>记住记住一定是 <span class=\"math inline\">\\(rk_{i-1}\\)</span> 而不是下意识的 <span class=\"math inline\">\\(rk_i-1\\)</span>！！！</mark>所以为了保证求解顺序循环枚举的一定是下标而非排名。但是注意定义却是和 <span class=\"math inline\">\\(rk_i-1\\)</span> 的 lcp！！！所以求 height 的写法是相对固定的，不能觉得好像是对的就随便乱改。</p>\n<hr />\n<h2 id=\"height-数组的应用\">height 数组的应用</h2>\n<p>相当于背板子，因为应用太多且形式大多固定。</p>\n<h3 id=\"求任意两个后缀的-lcp\">求任意两个后缀的 lcp</h3>\n<p>易得 <span class=\"math inline\">\\(\\text{lcp}(sa_i, sa_j)=\\min\\{h_{i+1}, \\cdots, h_j\\}\\)</span>。<strong>故应将一些复杂 lcp 问题的解决方式和 RMQ 联系起来</strong>。</p>\n<hr />\n<h3 id=\"子串大小关系\">子串大小关系</h3>\n<p>即比较 <span class=\"math inline\">\\(S_{l_1, r_1}\\)</span> 和 <span class=\"math inline\">\\(S_{l_2, r_2}\\)</span> 的大小关系。比较导致 lcp 不能继续延伸的元素大小即可。</p>\n<hr />\n<h3 id=\"本质不同子串数量\">本质不同子串数量</h3>\n<p><strong>子串等价于「后缀的前缀」</strong>。按顺序枚举每个后缀，减去和已枚举的所有后缀的 lcp 即可。鉴于 <span class=\"math inline\">\\(\\min\\{h_{j+1},\\cdots,h_i\\}\\)</span> 单调不减，直接减去 <span class=\"math inline\">\\(h_i\\)</span> 即可。</p>\n<p>最后答案即为 <span class=\"math inline\">\\(\\frac {n(n-1)}2 - \\sum\\limits_{i=2}^nh_i\\)</span>。</p>\n<hr />\n<h3 id=\"至少出现-k-次子串的最大长度\">至少出现 <span class=\"math inline\">\\(k\\)</span> 次子串的最大长度</h3>\n<p>模板：<a href=\"https://www.luogu.com.cn/problem/P2852\" class=\"uri\">https://www.luogu.com.cn/problem/P2852</a>。</p>\n<p>出现 <span class=\"math inline\">\\(k\\)</span> 次 <span class=\"math inline\">\\(\\iff\\)</span> 在后缀数组中连续出现 <span class=\"math inline\">\\(k\\)</span> 次 <span class=\"math inline\">\\(\\iff\\)</span> 是任意连续 <span class=\"math inline\">\\(k-1\\)</span> 个 <span class=\"math inline\">\\(h\\)</span> 的最小值，需要最大化该最小值，考虑滑动窗口。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;P2852_7.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, k;\n    std::cin &gt;&gt; n &gt;&gt; k, --k;\n    std::vector&lt;int&gt; s(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; s[i];\n    std::vector&lt;int&gt; sa(n + 1), rk(s), h(n + 1);\n    &#123;\n        int m = 1000001;\n        &#123;\n            std::vector&lt;int&gt; c(m + 1);\n            for (int i = 1; i &lt;= n; ++i)\n                ++c[rk[i]];\n            std::partial_sum(c.begin(), c.end(), c.begin());\n            for (int i = n; i; --i)\n                sa[c[rk[i]]--] = i;\n        &#125;\n        for (int w = 1, p; ; w &lt;&lt;= 1, m = p) &#123;\n            std::vector&lt;int&gt; id(1);\n            for (int i = n - w + 1; i &lt;= n; ++i)\n                id.push_back(i);\n            for (int i = 1; i &lt;= n; ++i)\n                if (sa[i] &gt; w)\n                    id.push_back(sa[i] - w);\n            std::vector&lt;int&gt; c(m + 1);\n            for (int i = 1; i &lt;= n; ++i)\n                ++c[rk[i]];\n            std::partial_sum(c.begin(), c.end(), c.begin());\n            for (int i = n; i; --i)\n                sa[c[rk[id[i]]]--] = id[i];\n            auto la(rk);\n            p = 0;\n            for (int i = 1; i &lt;= n; ++i)\n                if (i != 1 &amp;&amp; la[sa[i]] == la[sa[i - 1]] &amp;&amp; la[sa[i] + w] == la[sa[i - 1] + w])\n                    rk[sa[i]] = p;\n                else\n                    rk[sa[i]] = ++p;\n            if (p == n)\n                break;\n        &#125;\n        for (int i = 1, to = 0; i &lt;= n; ++i)\n            if (rk[i]) &#123;\n                for (to = std::max(to - 1, 0); s[i + to] == s[sa[rk[i] - 1] + to]; ++to);\n                h[rk[i]] = to;\n            &#125;\n    &#125;\n    std::vector&lt;int&gt; q(n + 1);\n    int res = 0;\n    for (int i = 1, l = 1, r = 0; i &lt;= n; ++i) &#123;\n        // printf(&quot;%d\\n&quot;, h[i]);\n        for (; l &lt;= r &amp;&amp; i - q[l] &gt;= k; ++l);\n        for (; l &lt;= r &amp;&amp; h[i] &lt;= h[q[r]]; --r);\n        q[++r] = i;\n        if (i &gt;= k)\n            res = std::max(res, h[q[l]]);\n    &#125;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"最长不重叠多次出现子串\">最长不重叠多次出现子串</h3>\n<p><del>bb：定式太多太杂以至于让人怀疑某些定式是否存在应用场景</del> <img src=\"/em/kt.gif\" /></p>\n<p>发现满足单调性，二分子串长度 <span class=\"math inline\">\\(len\\)</span>，那么显然 <span class=\"math inline\">\\(\\text {lcp}\\ge len\\)</span>；将 <span class=\"math inline\">\\(h\\)</span> 划分为连续 <span class=\"math inline\">\\(\\ge len\\)</span> 的段，在每段内找到下标极差与 <span class=\"math inline\">\\(len\\)</span> 比较即可。</p>\n<p>也可以用于判定是否存在不重叠多次出现子串。</p>\n<p>甚至可以考虑限制至少出现次数为 <span class=\"math inline\">\\(k\\)</span>，那大概多个 <span class=\"math inline\">\\(\\log\\)</span>，看看一段里有没有 <span class=\"math inline\">\\(\\ge k\\)</span> 个相互相差 <span class=\"math inline\">\\(\\ge len\\)</span> 的。排序贪心求解。</p>\n<p>那么上面的至少出现 <span class=\"math inline\">\\(k\\)</span> 次子串也可以用这个方法来解，但是多个 <span class=\"math inline\">\\(\\log\\)</span> 没必要。</p>\n<p>也可以限制多次出现但长度至少为 <span class=\"math inline\">\\(len\\)</span>，那甚至少了二分的 <span class=\"math inline\">\\(\\log\\)</span>，直接跑一遍 check 即可。</p>\n<p><del>？？？到底为什么会有这么多奇怪的定式，是因为真的有题这么出吗？？？</del> <img src=\"/em/oh.gif\" /></p>\n<hr />\n<h3 id=\"最长公共子串问题\">最长公共子串问题</h3>\n<p>求 <span class=\"math inline\">\\(S\\)</span> 和 <span class=\"math inline\">\\(T\\)</span> 的最长公共子串（注意不是 LCS）。设 <span class=\"math inline\">\\(S\\)</span> 长为 <span class=\"math inline\">\\(n\\)</span>，<span class=\"math inline\">\\(T\\)</span> 长为 <span class=\"math inline\">\\(m\\)</span>，那么将 <span class=\"math inline\">\\(S\\)</span> 与 <span class=\"math inline\">\\(T\\)</span> 拼接，答案就是 <span class=\"math inline\">\\(\\max \\{\\text{lcp}(i,j)\\},i\\le n&lt;j\\)</span>。</p>\n<p>但这里不直接枚举 <span class=\"math inline\">\\(i\\)</span> 和 <span class=\"math inline\">\\(j\\)</span>，还是照例先从 <span class=\"math inline\">\\(h\\)</span> 下手再卡条件，若 <span class=\"math inline\">\\(sa_{i-1}\\le n&lt;sa_{i}\\)</span>（或者反过来），就可以用 <span class=\"math inline\">\\(h_i\\)</span> 更新答案。容易证明这样总可以找到最大值。</p>\n<h4 id=\"eg1.-找相同字符\">eg1. 找相同字符</h4>\n<p><a href=\"https://www.luogu.com.cn/problem/P3181\" class=\"uri\">https://www.luogu.com.cn/problem/P3181</a></p>\n<p>要求方案数，那么答案为 <span class=\"math inline\">\\(\\text{lcp}(i,j),i\\le n&lt;j\\)</span>。（我已经帮你们试过了容斥比直接做更麻烦），考虑用单调栈维护左 / 右侧区间 lcp 求解右 / 左侧答案。关于单调栈的描述可见 <a href=\"#结合单调栈\">本页后部内容</a>。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, n1;\n    std::string s, t;\n    std::cin &gt;&gt; s &gt;&gt; t;\n    n = (int)s.length(), n1 = n + (int)t.length() + 1;\n    s = &quot;#&quot; + s + &quot;$&quot; + t;\n    std::vector&lt;int&gt; sa(n1 + 1), rk(n1 + 1), h(n1 + 1);\n    &#123;\n        std::copy(s.begin() + 1, s.end(), rk.begin() + 1);\n        int m = 128;\n        &#123;\n            std::vector&lt;int&gt; c(m + 1);\n            for (int i = 1; i &lt;= n1; ++i)\n                ++c[rk[i]];\n            std::partial_sum(c.begin(), c.end(), c.begin());\n            for (int i = n1; i; --i)\n                sa[c[rk[i]]--] = i;\n        &#125;\n        for (int w = 1, p; ; w &lt;&lt;= 1, m = p) &#123;\n            std::vector&lt;int&gt; id(w + 1);\n            std::iota(id.begin() + 1, id.end(), n1 - w + 1);\n            for (int i = 1; i &lt;= n1; ++i)\n                if (sa[i] &gt; w)\n                    id.push_back(sa[i] - w);\n            std::vector&lt;int&gt; c(m + 1);\n            for (int i = 1; i &lt;= n1; ++i)\n                ++c[rk[i]];\n            std::partial_sum(c.begin(), c.end(), c.begin());\n            for (int i = n1; i; --i)\n                sa[c[rk[id[i]]]--] = id[i];\n            p = 0;\n            auto la(rk);\n            for (int i = 1; i &lt;= n1; ++i)\n                if (i != 1 &amp;&amp; la[sa[i]] == la[sa[i - 1]] &amp;&amp; la[sa[i] + w] == la[sa[i - 1] + w])\n                    rk[sa[i]] = p;\n                else\n                    rk[sa[i]] = ++p;\n            if (p == n1)\n                break;\n        &#125;\n        for (int i = 1, to = 0; i &lt;= n1; ++i) &#123;\n            for (to = std::max(to - 1, 0); s[i + to] == s[sa[rk[i] - 1] + to]; ++to);\n            h[rk[i]] = to;\n        &#125;\n    &#125;\n    std::vector&lt;std::pair&lt;int, long long&gt; &gt; q1, q2;\n    std::vector&lt;int&gt; tot1(n1 + 1), tot2(n1 + 1);\n    for (int i = 1; i &lt;= n1; ++i) &#123;\n        tot1[i] = tot1[i - 1] + (sa[i] &lt;= n);\n        tot2[i] = tot2[i - 1] + (sa[i] &gt; n + 1);\n    &#125;\n    long long res = 0ll;\n    q1.emplace_back(1, 0ll), q2.emplace_back(1, 0ll);\n    for (int i = 1; i &lt;= n1; ++i) &#123;\n        for (; !q1.empty() &amp;&amp; h[i] &lt; h[q1.back().first]; q1.pop_back());\n        q1.emplace_back(i, (tot1[i - 1] - tot1[q1.back().first - 1]) * h[i] + q1.back().second);\n        if (sa[i] &gt; n + 1)\n            res += q1.back().second;\n        for (; !q2.empty() &amp;&amp; h[i] &lt; h[q2.back().first]; q2.pop_back());\n        q2.emplace_back(i, (tot2[i - 1] - tot2[q2.back().first - 1]) * h[i] + q2.back().second);\n        if (sa[i] &lt;= n)\n            res += q2.back().second;\n    &#125;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<h4 id=\"eg2.-公共串\">eg2. 公共串</h4>\n<p><a href=\"https://www.luogu.com.cn/problem/P5546\" class=\"uri\">https://www.luogu.com.cn/problem/P5546</a></p>\n<p>要求多串最长公共子串，仍然考虑将多个串拼在一起。仿照前面二分的方式处理，问题转化为找到最长的 <span class=\"math inline\">\\(len\\)</span>，使得存在一段最小值 <span class=\"math inline\">\\(\\ge len\\)</span> 的区间，其覆盖了 <span class=\"math inline\">\\(n\\)</span> 段串。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, l = 0, r = 0;\n    std::cin &gt;&gt; n;\n    std::string s;\n    std::vector&lt;std::pair&lt;int, int&gt; &gt; lim(n + 1);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::string t;\n        std::cin &gt;&gt; t;\n        lim[i] = &#123; (int)s.length() + 1, s.length() + t.length() &#125;;\n        s += &quot;#&quot; + t;\n        r = std::max(r, (int)t.length());\n        // printf(&quot;[%d, %d]\\n&quot;, lim[i].first, lim[i].second);\n    &#125;\n    int n1 = lim.back().second;\n    std::vector&lt;int&gt; sa(n1 + 1), rk(n1 + 1), h(n1 + 1);\n    &#123;\n        std::copy(s.begin() + 1, s.end(), rk.begin() + 1);\n        int m = 128;\n        &#123;\n            std::vector&lt;int&gt; c(m + 1);\n            for (int i = 1; i &lt;= n1; ++i)\n                ++c[rk[i]];\n            std::partial_sum(c.begin(), c.end(), c.begin());\n            for (int i = n1; i; --i)\n                sa[c[rk[i]]--] = i;\n        &#125;\n        for (int w = 1, p; ; w &lt;&lt;= 1, m = p) &#123;\n            std::vector&lt;int&gt; id(w + 1);\n            std::iota(id.begin() + 1, id.end(), n1 - w + 1);\n            for (int i = 1; i &lt;= n1; ++i)\n                if (sa[i] &gt; w)\n                    id.push_back(sa[i] - w);\n            std::vector&lt;int&gt; c(m + 1);\n            for (int i = 1; i &lt;= n1; ++i)\n                ++c[rk[i]];\n            std::partial_sum(c.begin(), c.end(), c.begin());\n            for (int i = n1; i; --i)\n                sa[c[rk[id[i]]]--] = id[i];\n            p = 0;\n            auto la(rk);\n            for (int i = 1; i &lt;= n1; ++i)\n                if (i != 1 &amp;&amp; la[sa[i]] == la[sa[i - 1]] &amp;&amp; la[sa[i] + w] == la[sa[i - 1] + w])\n                    rk[sa[i]] = p;\n                else\n                    rk[sa[i]] = ++p;\n            if (p == n1)\n                break;\n        &#125;\n        for (int i = 1, to = 0; i &lt;= n1; ++i) &#123;\n            for (to = std::max(to - 1, 0); s[i + to] == s[sa[rk[i] - 1] + to]; ++to);\n            h[rk[i]] = to;\n        &#125;\n    &#125;\n    // for (int i = 1; i &lt;= n1; ++i)\n    //     printf(&quot;h[%d] = %d\\n&quot;, sa[i], h[i]);\n    int res = 0;\n    auto check = [&amp;](int len) &#123;\n        // printf(&quot;check %d: \\n&quot;, len);\n        std::vector&lt;int&gt; cnt(n + 1);\n        for (int i = 1; i &lt;= n1; ++i) &#123;\n            if (h[i] &lt; len) &#123;\n                if (*std::min_element(cnt.begin() + 1, cnt.end()))\n                    return 1;\n                cnt.assign(n + 1, 0);\n            &#125;\n            else\n                for (int j = 1; j &lt;= n; ++j) &#123;\n                    if (lim[j].first &lt;= sa[i - 1] &amp;&amp; sa[i - 1] &lt;= lim[j].second)\n                        cnt[j] = 1;\n                    if (lim[j].first &lt;= sa[i] &amp;&amp; sa[i] &lt;= lim[j].second)\n                        cnt[j] = 1;\n                &#125;\n        &#125;\n        // printf(&quot;\\n%d\\n&quot;, *std::min_element(cnt.begin() + 1, cnt.end()));\n        return *std::min_element(cnt.begin() + 1, cnt.end());\n    &#125;;\n    for (int mid; l &lt;= r; ) &#123;\n        mid = (l + r) &gt;&gt; 1;\n        if (check(mid))\n            l = mid + 1, res = mid;\n        else\n            r = mid - 1;\n    &#125;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<p>但是看了题解发现居然还有线性做法（当然不看建 SA 的 <span class=\"math inline\">\\(\\log\\)</span>），对于覆盖全部 <span class=\"math inline\">\\(n\\)</span> 段串找区间最小值，发现需要最小化区间，考虑双指针。</p>\n<p>区间最小值用单调队列求解，细想可能会觉得不太对劲，但是容易证明答案不大于队首且不小于最大队首，所以最大队首就是答案。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, l = 0, r = 0;\n    std::cin &gt;&gt; n;\n    std::string s;\n    std::vector&lt;std::pair&lt;int, int&gt; &gt; lim(n + 1);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::string t;\n        std::cin &gt;&gt; t;\n        lim[i] = &#123; (int)s.length() + 1, s.length() + t.length() &#125;;\n        s += (char)(&#39;A&#39; + i - 1) + t;\n        r = std::max(r, (int)t.length());\n    &#125;\n    int n1 = lim.back().second;\n    std::vector&lt;int&gt; sa(n1 + 1), rk(n1 + 1), h(n1 + 1);\n    &#123;\n        std::copy(s.begin() + 1, s.end(), rk.begin() + 1);\n        int m = 128;\n        &#123;\n            std::vector&lt;int&gt; c(m + 1);\n            for (int i = 1; i &lt;= n1; ++i)\n                ++c[rk[i]];\n            std::partial_sum(c.begin(), c.end(), c.begin());\n            for (int i = n1; i; --i)\n                sa[c[rk[i]]--] = i;\n        &#125;\n        for (int w = 1, p; ; w &lt;&lt;= 1, m = p) &#123;\n            std::vector&lt;int&gt; id(w + 1);\n            std::iota(id.begin() + 1, id.end(), n1 - w + 1);\n            for (int i = 1; i &lt;= n1; ++i)\n                if (sa[i] &gt; w)\n                    id.push_back(sa[i] - w);\n            std::vector&lt;int&gt; c(m + 1);\n            for (int i = 1; i &lt;= n1; ++i)\n                ++c[rk[i]];\n            std::partial_sum(c.begin(), c.end(), c.begin());\n            for (int i = n1; i; --i)\n                sa[c[rk[id[i]]]--] = id[i];\n            p = 0;\n            auto la(rk);\n            for (int i = 1; i &lt;= n1; ++i)\n                if (i != 1 &amp;&amp; la[sa[i]] == la[sa[i - 1]] &amp;&amp; la[sa[i] + w] == la[sa[i - 1] + w])\n                    rk[sa[i]] = p;\n                else\n                    rk[sa[i]] = ++p;\n            if (p == n1)\n                break;\n        &#125;\n        for (int i = 1, to = 0; i &lt;= n1; ++i) &#123;\n            for (to = std::max(to - 1, 0); s[i + to] == s[sa[rk[i] - 1] + to]; ++to);\n            h[rk[i]] = to;\n        &#125;\n    &#125;\n    int res = 0;\n    std::vector&lt;int&gt; q(n1 + 1), cnt(n + 1);\n    // for (int i = 1; i &lt;= n1; ++i)\n    //     printf(&quot;%d: %d\\n&quot;, sa[i], h[i]);\n    for (int l = 1, r = 0, ql = 1, qr = 0; l &lt;= n1; ++l) &#123;\n        for (; r &lt; n1 &amp;&amp; !*std::min_element(cnt.begin() + 1, cnt.end()); ) &#123;\n            ++r;\n            for (int i = 1; i &lt;= n; ++i)\n                if (lim[i].first &lt;= sa[r] &amp;&amp; sa[r] &lt;= lim[i].second) &#123;\n                    ++cnt[i];\n                    break;\n                &#125;\n            for (; ql &lt;= qr &amp;&amp; h[r] &lt;= h[q[qr]]; --qr);\n            q[++qr] = r;\n        &#125;\n        if (*std::min_element(cnt.begin() + 1, cnt.end())) &#123;\n            // printf(&quot;[%d, %d]: %d\\n&quot;, l, r, h[q[ql]]);\n            res = std::max(res, h[q[ql]]);\n        &#125;\n        for (; ql &lt;= qr &amp;&amp; q[ql] &lt;= l; ++ql);\n        if (l != 1) &#123;\n            for (int i = 1; i &lt;= n; ++i)\n                if (lim[i].first &lt;= sa[l - 1] &amp;&amp; sa[l - 1] &lt;= lim[i].second) &#123;\n                    --cnt[i];\n                    break;\n                &#125;\n        &#125;\n    &#125;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"texttt-aa-式子串处理\"><span class=\"math inline\">\\(\\texttt {AA}\\)</span> 式子串处理</h3>\n<p>即对于连续相同子串问题的处理，有一个定的思路，由例题分析。</p>\n<h4 id=\"eg1.-优秀的拆分\">eg1. 优秀的拆分</h4>\n<p><a href=\"https://www.luogu.com.cn/problem/P1117\" class=\"uri\">https://www.luogu.com.cn/problem/P1117</a></p>\n<p>还是从中间分开，按前后分别处理。这里有个 trick，我们枚举 <span class=\"math inline\">\\(\\texttt B\\)</span> 的长度 <span class=\"math inline\">\\(len\\)</span>，在 <span class=\"math inline\">\\(S\\)</span> 中每隔 <span class=\"math inline\">\\(len\\)</span> 打一个标记。那么显然，任意一个长度为 <span class=\"math inline\">\\(2\\times len\\)</span> 的子串都会经过恰好两个标记（充分的），这样就可以筛选出所有可能的串。</p>\n<p>我们枚举所有连续两个标记（总复杂度为调和级数），求它们对应后缀的 lcp 和对应前缀的 lcs（翻转求 SA 即可），如果二者加起来 <span class=\"math inline\">\\(\\ge len\\)</span> 就说明存在这样的 <span class=\"math inline\">\\(\\texttt {AA}\\)</span>。在 <span class=\"math inline\">\\(\\text {lcs}+\\text {lcp}\\)</span> 中任取 <span class=\"math inline\">\\(len\\)</span> 长度即为一对 <span class=\"math inline\">\\(\\texttt {AA}\\)</span>。用差分给可能的起点和终点区间加即可。</p>\n<p>小细节：lcp 和 lcs 均需要对 <span class=\"math inline\">\\(len\\)</span> 取 <span class=\"math inline\">\\(\\min\\)</span>，否则取到的串可能不会经过当前选中的两个标记。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nclass SA &#123;\npublic:\n    std::vector&lt;int&gt; sa, rk, h;\n    std::vector&lt;std::vector&lt;int&gt;  &gt; st;\n    SA(int n, std::string s): sa(n + 1), rk(n + 2), h(n + 1), st(20, std::vector&lt;int&gt; (n + 1)) &#123;\n        std::vector&lt;int&gt; la(n + 2);\n        std::copy(s.begin(), s.end(), rk.begin());\n        int m = 128;\n        &#123;\n            std::vector&lt;int&gt; c(m + 1);\n            for (int i = 1; i &lt;= n; ++i)\n                ++c[rk[i]];\n            std::partial_sum(c.begin(), c.end(), c.begin());\n            for (int i = n; i; --i)\n                sa[c[rk[i]]--] = i;\n        &#125;\n        for (int w = 1, p; ; w &lt;&lt;= 1, m = p) &#123;\n            std::vector&lt;int&gt; id(1);\n            for (int i = n - w + 1; i &lt;= n; ++i)\n                id.push_back(i);\n            for (int i = 1; i &lt;= n; ++i)\n                if (sa[i] &gt; w)\n                    id.push_back(sa[i] - w);\n            std::vector&lt;int&gt; c(m + 1);\n            for (int i = 1; i &lt;= n; ++i)\n                ++c[rk[i]];\n            std::partial_sum(c.begin(), c.end(), c.begin());\n            for (int i = n; i; --i)\n                sa[c[rk[id[i]]]--] = id[i];\n            p = 0;\n            std::copy(rk.begin(), rk.end(), la.begin());\n            for (int i = 1; i &lt;= n; ++i)\n                if (la[sa[i]] == la[sa[i - 1]] &amp;&amp; la[sa[i] + w] == la[sa[i - 1] + w])\n                    rk[sa[i]] = p;\n                else\n                    rk[sa[i]] = ++p;\n            if (p == n)\n                break;\n        &#125;\n        for (int i = 1, to = 0; i &lt;= n; ++i)\n            if (rk[i]) &#123;\n                for (to = std::max(to - 1, 0); s[i + to] == s[sa[rk[i] - 1] + to]; ++to);\n                h[rk[i]] = to;\n            &#125;\n        for (int i = 1; i &lt;= n; ++i)\n            st[0][i] = h[i];\n        for (int j = 1; (1 &lt;&lt; j) &lt;= n; ++j)\n            for (int i = 1; i + (1 &lt;&lt; j) - 1 &lt;= n; ++i)\n                st[j][i] = std::min(st[j - 1][i], st[j - 1][i + (1 &lt;&lt; (j - 1))]);\n        rk.emplace_back();\n        return;\n    &#125;\nprivate:\n    int ask(int l, int r) &#123;\n        // fprintf(stderr, &quot;l = %d, r = %d\\n&quot;, l, r);\n        int k = std::__lg(r - l + 1);\n        return std::min(st[k][l], st[k][r - (1 &lt;&lt; k) + 1]);\n    &#125;\npublic:\n    int lcp(int l, int r) &#123;\n        return ask(std::min(rk[l], rk[r]) + 1, std::max(rk[l], rk[r]));\n    &#125;\n&#125;;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int T;\n    for (std::cin &gt;&gt; T; T--; ) &#123;\n        std::string s;\n        std::cin &gt;&gt; s;\n        int n = (int)s.length();\n        s = &quot;#&quot; + s;\n        SA p(n, s);\n        std::reverse(s.begin() + 1, s.end());\n        SA q(n, s);\n        std::vector&lt;int&gt; f(n + 2), g(n + 2);\n        for (int len = 1; len &lt;= n / 2; ++len)\n            for (int i = len; i + len &lt;= n; i += len) &#123;\n                int l = i, r = i + len, lcp = std::min(len, p.lcp(l, r)), lcs = std::min(len - 1, q.lcp(n - l + 2, n - r + 2));\n                if (lcp + lcs &gt;= len) &#123;\n                    int t = lcp + lcs - len + 1;\n                    // fprintf(stderr, &quot;(%d, %d), %d, %d\\n&quot;, l, r, lcp, lcs);\n                    ++g[l - lcs], --g[l - lcs + t], ++f[r + lcp - t], --f[r + lcp];\n                &#125;\n            &#125;\n        std::partial_sum(f.begin(), f.end(), f.begin());\n        std::partial_sum(g.begin(), g.end(), g.begin());\n        long long res = 0ll;\n        for (int i = 1; i &lt; n; ++i)\n            res += (long long)f[i] * g[i + 1];\n        std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h4 id=\"eg2.-tandem\">eg2. tandem</h4>\n<p><a href=\"https://www.codechef.com/problems/TANDEM\" class=\"uri\">https://www.codechef.com/problems/TANDEM</a></p>\n<p>注意到多了一个限制，前一个好处理，找到经过 <span class=\"math inline\">\\(3\\)</span> 个标记的串即可。对于后一个限制，画图可以发现对于 interesting ones，每次只会出现最多一个；当且仅当 <span class=\"math inline\">\\(\\text {lcp}&gt;len\\)</span> 时不存在。</p>\n<p>对于 uninteresting ones，用每次能提供的总数减去 interesting ones 的数量即可。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nclass SA &#123;\npublic:\n    std::vector&lt;int&gt; sa, rk, h;\n    std::vector&lt;std::vector&lt;int&gt;  &gt; st;\n    SA(int n, std::string s): sa(n + 1), rk(n + 2), h(n + 1), st(20, std::vector&lt;int&gt; (n + 1)) &#123;\n        std::vector&lt;int&gt; la(n + 2);\n        std::copy(s.begin(), s.end(), rk.begin());\n        int m = 128;\n        &#123;\n            std::vector&lt;int&gt; c(m + 1);\n            for (int i = 1; i &lt;= n; ++i)\n                ++c[rk[i]];\n            std::partial_sum(c.begin(), c.end(), c.begin());\n            for (int i = n; i; --i)\n                sa[c[rk[i]]--] = i;\n        &#125;\n        for (int w = 1, p; ; w &lt;&lt;= 1, m = p) &#123;\n            std::vector&lt;int&gt; id(1);\n            for (int i = n - w + 1; i &lt;= n; ++i)\n                id.push_back(i);\n            for (int i = 1; i &lt;= n; ++i)\n                if (sa[i] &gt; w)\n                    id.push_back(sa[i] - w);\n            std::vector&lt;int&gt; c(m + 1);\n            for (int i = 1; i &lt;= n; ++i)\n                ++c[rk[i]];\n            std::partial_sum(c.begin(), c.end(), c.begin());\n            for (int i = n; i; --i)\n                sa[c[rk[id[i]]]--] = id[i];\n            p = 0;\n            std::copy(rk.begin(), rk.end(), la.begin());\n            for (int i = 1; i &lt;= n; ++i)\n                if (la[sa[i]] == la[sa[i - 1]] &amp;&amp; la[sa[i] + w] == la[sa[i - 1] + w])\n                    rk[sa[i]] = p;\n                else\n                    rk[sa[i]] = ++p;\n            if (p == n)\n                break;\n        &#125;\n        for (int i = 1, to = 0; i &lt;= n; ++i)\n            if (rk[i]) &#123;\n                for (to = std::max(to - 1, 0); s[i + to] == s[sa[rk[i] - 1] + to]; ++to);\n                h[rk[i]] = to;\n            &#125;\n        for (int i = 1; i &lt;= n; ++i)\n            st[0][i] = h[i];\n        for (int j = 1; (1 &lt;&lt; j) &lt;= n; ++j)\n            for (int i = 1; i + (1 &lt;&lt; j) - 1 &lt;= n; ++i)\n                st[j][i] = std::min(st[j - 1][i], st[j - 1][i + (1 &lt;&lt; (j - 1))]);\n        rk.emplace_back();\n        return;\n    &#125;\nprivate:\n    int ask(int l, int r) &#123;\n        // fprintf(stderr, &quot;l = %d, r = %d\\n&quot;, l, r);\n        int k = std::__lg(r - l + 1);\n        return std::min(st[k][l], st[k][r - (1 &lt;&lt; k) + 1]);\n    &#125;\npublic:\n    int lcp(int l, int r) &#123;\n        return ask(std::min(rk[l], rk[r]) + 1, std::max(rk[l], rk[r]));\n    &#125;\n&#125;;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    std::string s;\n    std::cin &gt;&gt; s;\n    int n = (int)s.length();\n    s = &quot;#&quot; + s;\n    SA p(n, s);\n    std::reverse(s.begin() + 1, s.end());\n    SA q(n, s);\n    std::reverse(s.begin() + 1, s.end());\n    long long res1 = 0ll, res2 = 0ll;\n    for (int len = 1; len &lt;= n; ++len)\n        for (int i = len, j = 2 * len, k = 3 * len; k &lt;= n; i += len, j += len, k += len) &#123;\n            int lcp = std::min(p.lcp(i, j), p.lcp(j, k)), lcs = std::min(&#123; len - 1, q.lcp(n - i + 2, n - j + 2), q.lcp(n - j + 2, n - k + 2) &#125;);\n            if (std::min(len, lcp) + lcs &gt;= len) &#123;\n                // printf(&quot;(%d, %d, %d), %d, %d, %d\\n&quot;, i, j, k, lcs, lcp, len);\n                int t = (lcp &lt;= len);\n                res1 += t, res2 += std::min(len, lcp) + lcs - len + 1 - t;\n            &#125;\n            // else\n            //     printf(&quot;# (%d, %d, %d), %d, %d, %d\\n&quot;, i, j, k, lcs, lcp, len);\n        &#125;\n    std::cout &lt;&lt; res1 &lt;&lt; &#39; &#39; &lt;&lt; res2 &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h4 id=\"eg3.-repeats\">eg3. repeats</h4>\n<p><a href=\"https://www.spoj.com/problems/REPEATS/\" class=\"uri\">https://www.spoj.com/problems/REPEATS/</a></p>\n<p>重复次数最多，只需经过标记点最多。显然经过标记点的数量就是该字符串长除以 <span class=\"math inline\">\\(len\\)</span> 向下取整就可以得到重复次数减 <span class=\"math inline\">\\(1\\)</span> 的值。</p>\n<p>选择两个连续标记点，对于 lcp 和 lcs（显然此时不需要对 <span class=\"math inline\">\\(len\\)</span> 取 <span class=\"math inline\">\\(\\min\\)</span>），计算 <span class=\"math inline\">\\(\\dfrac {\\text{lcp}+\\text{lcs}}{len}+1\\)</span> 取最大即可。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nclass SA &#123;\npublic:\n    std::vector&lt;int&gt; sa, rk, h;\n    std::vector&lt;std::vector&lt;int&gt;  &gt; st;\n    SA(int n, std::string s): sa(n + 1), rk(n + 2), h(n + 1), st(20, std::vector&lt;int&gt; (n + 1)) &#123;\n        std::vector&lt;int&gt; la(n + 2);\n        std::copy(s.begin(), s.end(), rk.begin());\n        int m = 128;\n        &#123;\n            std::vector&lt;int&gt; c(m + 1);\n            for (int i = 1; i &lt;= n; ++i)\n                ++c[rk[i]];\n            std::partial_sum(c.begin(), c.end(), c.begin());\n            for (int i = n; i; --i)\n                sa[c[rk[i]]--] = i;\n        &#125;\n        for (int w = 1, p; ; w &lt;&lt;= 1, m = p) &#123;\n            std::vector&lt;int&gt; id(1);\n            for (int i = n - w + 1; i &lt;= n; ++i)\n                id.push_back(i);\n            for (int i = 1; i &lt;= n; ++i)\n                if (sa[i] &gt; w)\n                    id.push_back(sa[i] - w);\n            std::vector&lt;int&gt; c(m + 1);\n            for (int i = 1; i &lt;= n; ++i)\n                ++c[rk[i]];\n            std::partial_sum(c.begin(), c.end(), c.begin());\n            for (int i = n; i; --i)\n                sa[c[rk[id[i]]]--] = id[i];\n            p = 0;\n            std::copy(rk.begin(), rk.end(), la.begin());\n            for (int i = 1; i &lt;= n; ++i)\n                if (la[sa[i]] == la[sa[i - 1]] &amp;&amp; la[sa[i] + w] == la[sa[i - 1] + w])\n                    rk[sa[i]] = p;\n                else\n                    rk[sa[i]] = ++p;\n            if (p == n)\n                break;\n        &#125;\n        for (int i = 1, to = 0; i &lt;= n; ++i)\n            if (rk[i]) &#123;\n                for (to = std::max(to - 1, 0); s[i + to] == s[sa[rk[i] - 1] + to]; ++to);\n                h[rk[i]] = to;\n            &#125;\n        for (int i = 1; i &lt;= n; ++i)\n            st[0][i] = h[i];\n        for (int j = 1; (1 &lt;&lt; j) &lt;= n; ++j)\n            for (int i = 1; i + (1 &lt;&lt; j) - 1 &lt;= n; ++i)\n                st[j][i] = std::min(st[j - 1][i], st[j - 1][i + (1 &lt;&lt; (j - 1))]);\n        rk.emplace_back();\n        return;\n    &#125;\nprivate:\n    int ask(int l, int r) &#123;\n        // fprintf(stderr, &quot;l = %d, r = %d\\n&quot;, l, r);\n        int k = std::__lg(r - l + 1);\n        return std::min(st[k][l], st[k][r - (1 &lt;&lt; k) + 1]);\n    &#125;\npublic:\n    int lcp(int l, int r) &#123;\n        return ask(std::min(rk[l], rk[r]) + 1, std::max(rk[l], rk[r]));\n    &#125;\n&#125;;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int T;\n    for (std::cin &gt;&gt; T; T--; ) &#123;\n        int n;\n        std::cin &gt;&gt; n;\n        std::string s = &quot;#&quot;;\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            char t;\n            std::cin &gt;&gt; t;\n            s.push_back(t);\n        &#125;\n        SA p(n, s);\n        std::reverse(s.begin() + 1, s.end());\n        SA q(n, s);\n        int res = 0;\n        for (int len = 1; len &lt;= n; ++len)\n            for (int i = len, j = 2 * len; j &lt;= n; i += len, j += len) &#123;\n                int lcp = p.lcp(i, j), lcs = q.lcp(n - i + 2, n - j + 2);\n                if (lcp + lcs &gt;= len)\n                    res = std::max(res, (lcp + lcs) / len + 1);\n            &#125;\n        std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"结合并查集\">结合并查集</h3>\n<hr />\n<h3 id=\"结合单调栈\">结合单调栈</h3>\n",
            "tags": [
                "字符串",
                "SA"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20250121/",
            "url": "https://xsc062.netlify.app/20250121/",
            "title": "技巧：字符串拆分",
            "date_published": "2025-01-21T03:47:06.000Z",
            "content_html": "<p>神刘家在走前体育课上问我听没听过 <em>Die For You - The Weekend</em>。我让他哼一段，刘家便展示了自己的天籁之音，我理所当然地连旋律都没辨认出来。</p>\n<span id=\"more\"></span>\n<hr />\n<p>有的时候，对于一个完整的匹配串，我们需要「枚举断点」，分为前半段和后半段分别和模式串匹配解决问题。当然这样的技巧不止局限于字符串，我们在之前的学习中在诸如动态规划等题目中遇到了相似的情景。</p>\n<p>在字符串题目中，一个典型的标志是「模式串的拼接」，将两截模式串拼接到一起，形成的新模式串并不利好我们的处理，我们需要尽量利用已知的模式串。当然我们不会将新模式串重新拆成两半，而是考虑转换，枚举匹配串的断点，将前半段的后缀和后半段的前缀分别匹配。</p>\n<hr />\n<h2 id=\"一个模板cf1202e-you-are-given-some-strings\">一个模板：CF1202E You Are Given Some Strings…</h2>\n<p><a href=\"https://codeforces.com/problemset/problem/1202/E\" class=\"uri\">https://codeforces.com/problemset/problem/1202/E</a></p>\n<p>虽然对于每种不同拼接需要求解分别的出现次数，但是注意到最后只需要输出 <span class=\"math inline\">\\(f\\)</span> 的总和，所以就可以不再顾及不同拼接方式间的区别。</p>\n<p>枚举匹配串的断点。一个自然的想法是将前后缀与 AC 自动机匹配，但如果逐个放进去显然复杂度起飞。这里就又有一个实现小技巧，我们在原串的 AC 自动机上把原串过一遍，每个位置所在的状态就是这个位置对应后缀可能处在的后缀。</p>\n<p>记录每个状态可能处在的模式串末尾个数，这一点直接在 fail 树上从上到下转移即可。反串同理。</p>\n<p>二者相乘即为答案。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 2e5 + 5;\nstruct &#123;\n    int T[maxn][26], tot, cnt[maxn], fail[maxn], deg[maxn];\n    void ins(std::string &amp;t) &#123;\n        int p = 0;\n        for (auto i : t) &#123;\n            if (!T[p][i - &#39;a&#39;])\n                T[p][i - &#39;a&#39;] = ++tot;\n            p = T[p][i - &#39;a&#39;];\n        &#125;\n        ++cnt[p];\n        return;\n    &#125;\n    void bld(void) &#123;\n        std::queue&lt;int&gt; q;\n        for (int i = 0; i &lt; 26; ++i)\n            if (T[0][i])\n                q.push(T[0][i]);\n        for (; !q.empty(); ) &#123;\n            int u = q.front();\n            q.pop();\n            for (int i = 0; i &lt; 26; ++i)\n                if (T[u][i]) &#123;\n                    int v = T[u][i];\n                    fail[v] = T[fail[u]][i], cnt[v] += cnt[fail[v]];\n                    q.push(v);\n                &#125;\n                else\n                    T[u][i] = T[fail[u]][i];\n        &#125;\n        return;\n    &#125;\n&#125; p, q;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    std::string s;\n    std::cin &gt;&gt; s;\n    int n;\n    std::cin &gt;&gt; n;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::string t;\n        std::cin &gt;&gt; t;\n        p.ins(t);\n        std::reverse(t.begin(), t.end());\n        q.ins(t);\n    &#125;\n    p.bld(), q.bld();\n    int len = s.length();\n    std::vector&lt;std::array&lt;int, 2&gt; &gt; f(len + 1);\n    &#123;\n        int u = 0;\n        for (int i = 1; i &lt;= len; ++i) &#123;\n            u = p.T[u][s[i - 1] - &#39;a&#39;];\n            f[i][0] = p.cnt[u];\n        &#125;\n    &#125;\n    &#123;\n        int u = 0;\n        for (int i = len; i; --i) &#123;\n            u = q.T[u][s[i - 1] - &#39;a&#39;];\n            f[i][1] = q.cnt[u];\n        &#125;\n    &#125;\n    long long res = 0ll;\n    for (int i = 1; i &lt; len; ++i)\n        res += (long long)f[i][0] * f[i + 1][1];\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"变式优秀的拆分\">变式：优秀的拆分</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P1117\" class=\"uri\">https://www.luogu.com.cn/problem/P1117</a></p>\n",
            "tags": [
                "字符串"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20250120/",
            "url": "https://xsc062.netlify.app/20250120/",
            "title": "学习笔记：AC 自动机",
            "date_published": "2025-01-20T03:21:15.000Z",
            "content_html": "<p>耳机声音疑似有点小了，用心旷神怡的话来说大致会是「比果蝇↑嗡嗡声还小」。</p>\n<span id=\"more\"></span>\n<p>？卧槽耳机上居然可以调音量 <img src=\"/em/oh.gif\" /></p>\n<hr />\n<h2 id=\"前置知识\">前置知识</h2>\n<p>首先可能需要知道专有名词「自动机」的含义。</p>\n<p>大致可以简单理解为，一个 DAG，其中点表示状态，边表示转移。给进去一个字符串之类，就可以在 DAG 上游走，根据最后所处结点，可以得到字符串相关特征。</p>\n<p>这个定义让我们想到了 Trie。事实上，Trie 就是一种相当基础的自动机。</p>\n<hr />\n<p>接下来，让我们复习 KMP 相关概念。</p>\n<p>假想一个场景：你需要求得 <span class=\"math inline\">\\(T\\)</span> 在 <span class=\"math inline\">\\(S\\)</span> 中的出现次数。</p>\n<p>拥有一定题目经验的你，会使用 KMP 求出 <span class=\"math inline\">\\(T\\)</span> 的 <code>next</code> 数组，令 <span class=\"math inline\">\\(T\\)</span> 在 <span class=\"math inline\">\\(S\\)</span> 上进行匹配，失配或完全匹配时回到 <span class=\"math inline\">\\(T\\)</span> 在该处的 <code>next</code>，<span class=\"math inline\">\\(S\\)</span> 上的指针始终向右，<span class=\"math inline\">\\(T\\)</span> 上的指针如果向右，每次只能移动一位；如果向左，最左移到开头，均摊下来复杂度即为 <span class=\"math inline\">\\(O(|S| + |T|)\\)</span>。</p>\n<p>假如场景变得更复杂：给定 <span class=\"math inline\">\\(\\{T_m\\}\\)</span>，你需要求出每个 <span class=\"math inline\">\\(T_j\\)</span> 在 <span class=\"math inline\">\\(S\\)</span> 中的出现次数。</p>\n<p>那么如果我们对每个 <span class=\"math inline\">\\(T_j\\)</span> 进行一次 KMP，复杂度将会上升到 <span class=\"math inline\">\\(O(m|S|)\\)</span>，难以承受。有没有优化的方法呢？</p>\n<hr />\n<h2 id=\"ac-自动机的建立\">AC 自动机的建立</h2>\n<p>结合上面的知识，我们下意识想到，能不能将 <span class=\"math inline\">\\(\\{T_m\\}\\)</span> 建成一个树状结构，令 <span class=\"math inline\">\\(S\\)</span> 在其上进行 KMP 呢？</p>\n<p>将 <span class=\"math inline\">\\(\\{T_m\\}\\)</span> 全部加入 Trie，由于 <code>next</code> 只会由更深的点指向更浅的点，似乎从直觉上是有规则的。但随之而来的是一个问题：点 <span class=\"math inline\">\\(u\\)</span> 的 <code>next</code> 不一定在 <span class=\"math inline\">\\(\\text{root}\\to u\\)</span> 的链上（由于 Trie 的性质，可知指向的点是唯一的）。鉴于这一点不同，我们结合其「失配指针」的定义，将 <code>next</code> 在 Trie 上的同分异构体唤为 <code>fail</code>。</p>\n<p>考察 Trie 上该 <code>fail</code> 边的性质。现欲求解 <span class=\"math inline\">\\(u\\)</span> 的 <code>fail</code> 指向的 <span class=\"math inline\">\\(c\\)</span>，结合 KMP 中 <code>next</code> 的性质，假设 <span class=\"math inline\">\\(u\\)</span> 的父节点的 <code>fail</code> 边指向 <span class=\"math inline\">\\(v&#39;\\)</span>，那么 <span class=\"math inline\">\\(v\\)</span> 的值为：</p>\n<ul>\n<li><span class=\"math inline\">\\(v&#39;\\)</span> 上有边权相同的边，那么 <span class=\"math inline\">\\(v\\)</span> 就是该边指向的点。</li>\n<li>否则，前往 <span class=\"math inline\">\\(v&#39;\\)</span> 的 <code>fail</code>，重复以上判定。</li>\n</ul>\n<p>那么就完成了失配的处理。相应地，完全匹配时的跳转应如何处理？直接将 <code>fail</code> 的儿子全部接到 <span class=\"math inline\">\\(u\\)</span> 下面即可。如果 <span class=\"math inline\">\\(u\\)</span> 和 <code>fail</code> 具有同一个边权的边时，保留 <span class=\"math inline\">\\(u\\)</span> 的这条边 <span class=\"math inline\">\\(u\\to v\\)</span>，因为 <span class=\"math inline\">\\(v\\)</span> 的 <code>fail</code> 必定指向 <span class=\"math inline\">\\(u\\)</span> 的 <code>fail</code> 的对应儿子。</p>\n<p>两点结合，我们发现从实现上，可以直接令 <span class=\"math inline\">\\(v\\)</span> 的 <code>fail</code> 指向 <span class=\"math inline\">\\(u\\)</span> 的 <code>fail</code> 的对应儿子（那么时间复杂度显而易见是 <span class=\"math inline\">\\(O(26\\sum |T|)\\)</span> 的）。</p>\n<p>匹配时，对于每个点和其返回到根的 <code>fail</code> 链，全部标记。则一个模式串匹配的次数即为被打标记的次数。</p>\n<p>那么可以发现 AC 自动机的本质就是添加了 <code>fail</code> 边的 Trie。</p>\n<hr />\n<p>那么根据上述要求，我们需要按照深度顺序求得 <code>fail</code>，考虑 BFS。</p>\n<details>\n<p>哦哦好神奇复活之后记得啥是 KMP 但忘了啥是 C++ 了。甚至花了一点时间学习怎么创建一个函数？？？</p>\n<p>大家写 AC 自动机 Trie 根节点下标一定要设成 0 啊 <img src=\"/em/ll.gif\" /> 设成 1 被各种细节坑惨了 <img src=\"/em/ll.gif\" /></p>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 2e5 + 5;\nint T[maxn][26], tot, cnt[maxn], fail[maxn];\nint ins(std::string &amp;t) &#123;\n    int p = 0;\n    for (auto i : t) &#123;\n        if (!T[p][i - &#39;a&#39;])\n            T[p][i - &#39;a&#39;] = ++tot;\n        p = T[p][i - &#39;a&#39;];\n    &#125;\n    return p;\n&#125;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;int&gt; tail(n + 1);\n    std::vector&lt;std::string&gt; t(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; t[i], tail[i] = ins(t[i]);\n    &#123;\n        std::queue&lt;int&gt; q;\n        for (int i = 0; i &lt; 26; ++i)\n            if (T[0][i])\n                q.push(T[0][i]);\n        for (; !q.empty(); ) &#123;\n            int u = q.front();\n            q.pop();\n            for (int i = 0; i &lt; 26; ++i)\n                if (T[u][i]) &#123;\n                    int v = T[u][i];\n                    fail[v] = T[fail[u]][i];\n                    q.push(v);\n                &#125;\n                else\n                    T[u][i] = T[fail[u]][i];\n        &#125;\n    &#125;\n    std::string s;\n    std::cin &gt;&gt; s;\n    &#123;\n        int p = 0;\n        for (auto i : s) &#123;\n            p = T[p][i - &#39;a&#39;];\n            for (int fa = p; fa; fa = fail[fa])\n                ++cnt[fa];\n        &#125;\n    &#125;\n    for (int i = 1; i &lt;= n; ++i)\n        std::cout &lt;&lt; cnt[tail[i]] &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<p>肉眼可见该查询方式是极其低效的，故考虑优化跳 <code>fail</code> 打标记的过程。</p>\n<p>既然自动机结构不变，不如将跳 <code>fail</code> 的步骤放在最后统一进行。容易在发现 <code>fail</code> 树上进行拓扑排序转移即可。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 2e5 + 5;\nint T[maxn][26], tot, cnt[maxn], fail[maxn], deg[maxn];\nint ins(std::string &amp;t) &#123;\n    int p = 0;\n    for (auto i : t) &#123;\n        if (!T[p][i - &#39;a&#39;])\n            T[p][i - &#39;a&#39;] = ++tot;\n        p = T[p][i - &#39;a&#39;];\n    &#125;\n    return p;\n&#125;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;int&gt; tail(n + 1);\n    std::vector&lt;std::string&gt; t(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; t[i], tail[i] = ins(t[i]);\n    &#123;\n        std::queue&lt;int&gt; q;\n        for (int i = 0; i &lt; 26; ++i)\n            if (T[0][i])\n                q.push(T[0][i]);\n        for (; !q.empty(); ) &#123;\n            int u = q.front();\n            q.pop();\n            for (int i = 0; i &lt; 26; ++i)\n                if (T[u][i]) &#123;\n                    int v = T[u][i];\n                    fail[v] = T[fail[u]][i], ++deg[T[fail[u]][i]];\n                    q.push(v);\n                &#125;\n                else\n                    T[u][i] = T[fail[u]][i];\n        &#125;\n    &#125;\n    std::string s;\n    std::cin &gt;&gt; s;\n    &#123;\n        int p = 0;\n        for (auto i : s)\n            p = T[p][i - &#39;a&#39;], ++cnt[p];\n    &#125;\n    &#123;\n        std::queue&lt;int&gt; q;\n        for (int i = 1; i &lt;= tot; ++i)\n            if (!deg[i])\n                q.push(i);\n        for (; !q.empty(); ) &#123;\n            int u = q.front();\n            q.pop();\n            cnt[fail[u]] += cnt[u];\n            if (!--deg[fail[u]])\n                q.push(fail[u]);\n        &#125;\n    &#125;\n    for (int i = 1; i &lt;= n; ++i)\n        std::cout &lt;&lt; cnt[tail[i]] &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"ac-自动机的应用与识别\">AC 自动机的应用与识别</h2>\n<p>我们知道其最典型的特征是 <strong>多模式串</strong>、<strong>静态 / 离线</strong>。当碰到类似特点时，大概率就是 AC 自动机。</p>\n<p>其中，可以设置的难点有：</p>\n<ol type=\"1\">\n<li>字符串难点，和其他字符串题可设置的难点相同。</li>\n<li>fail 树维护，可能结合数据结构、拓扑排序、树形 DP 等考察。</li>\n<li>DP 的设计。</li>\n</ol>\n<hr />\n<h2 id=\"字符串难点设计\">字符串难点设计</h2>\n<h3 id=\"eg.-indie-album\">eg. Indie Album</h3>\n<p><a href=\"https://codeforces.com/problemset/problem/1207/G\" class=\"uri\">https://codeforces.com/problemset/problem/1207/G</a></p>\n<p>题目的「可持久化」试图误导我们用操作串建立自动机，但这样就会有一个比较严重的问题，我们没办法求 <span class=\"math inline\">\\(t\\)</span> 的出现次数。</p>\n<p>为了保证答案可求我们仍然在 <span class=\"math inline\">\\(t\\)</span> 上建立 ACAM。容易发现操作串以 Trie 形式给出，我们可以在遍历 Trie 时同时完成游走，通过回溯完成询问。</p>\n<p>假设当前 DFS 中，遍历到 Trie 树中的 <span class=\"math inline\">\\(x\\)</span> 点和自动机中的 <span class=\"math inline\">\\(u\\)</span> 状态，那么对于 <span class=\"math inline\">\\(x\\)</span> 点所对应的一个询问串 <span class=\"math inline\">\\(t\\)</span>，相当于询问经过的所有状态有多少个在 <span class=\"math inline\">\\(t\\)</span> 引导的 fail 树子树中。我们求出 fail 树的 dfn，用树状数组简单统计即可。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 4e5 + 5;\nstd::vector&lt;int&gt; g[maxn], q[maxn];\nint fail[maxn], T[maxn][26], tot, bit[maxn], to[maxn][26], cnt[maxn];\nint ins(std::string s) &#123;\n    int p = 0;\n    for (auto i : s) &#123;\n        if (!T[p][i - &#39;a&#39;])\n            T[p][i - &#39;a&#39;] = ++tot;\n        p = T[p][i - &#39;a&#39;];\n    &#125;\n    return p;\n&#125;\nint lowbit(int x) &#123;\n    return x &amp; -x;\n&#125;\nvoid add(int x, int v) &#123;\n    for (; x &lt;= tot + 1; x += lowbit(x))\n        bit[x] += v;\n    return;\n&#125;\nint ask(int x) &#123;\n    int res = 0;\n    for (; x; x -= lowbit(x))\n        res += bit[x];\n    return res;\n&#125;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, now = 0;\n    std::cin &gt;&gt; n;\n    std::vector&lt;int&gt; id(n + 1);\n    for (int i = 1, op; i &lt;= n; ++i) &#123;\n        char t;\n        std::cin &gt;&gt; op;\n        if (op == 1) &#123;\n            std::cin &gt;&gt; t;\n            if (!to[0][t - &#39;a&#39;])\n                to[0][t - &#39;a&#39;] = ++now;\n            ++cnt[to[0][t - &#39;a&#39;]], id[i] = to[0][t - &#39;a&#39;];\n        &#125;\n        else &#123;\n            int j; \n            std::cin &gt;&gt; j &gt;&gt; t;\n            if (!to[id[j]][t - &#39;a&#39;])\n                to[id[j]][t - &#39;a&#39;] = ++now;\n            ++cnt[to[id[j]][t - &#39;a&#39;]], id[i] = to[id[j]][t - &#39;a&#39;];\n        &#125;\n    &#125;\n    int m;\n    std::cin &gt;&gt; m;\n    std::vector&lt;int&gt; tail(m + 1), res(m + 1);\n    for (int i = 1, x; i &lt;= m; ++i) &#123;\n        std::string t;\n        std::cin &gt;&gt; x &gt;&gt; t, tail[i] = ins(t);\n        q[id[x]].push_back(i);\n    &#125;\n    &#123;\n        std::queue&lt;int&gt; q;\n        for (int i = 0; i &lt; 26; ++i)\n            if (T[0][i])\n                q.push(T[0][i]), g[0].push_back(T[0][i]);\n        for (; !q.empty(); ) &#123;\n            int u = q.front();\n            q.pop();\n            for (int i = 0; i &lt; 26; ++i)\n                if (T[u][i]) &#123;\n                    int v = T[u][i];\n                    fail[v] = T[fail[u]][i];\n                    q.push(v), g[fail[v]].push_back(v);\n                &#125;\n                else\n                    T[u][i] = T[fail[u]][i];\n        &#125;\n    &#125;\n    std::vector&lt;int&gt; dfn(tot + 1), rfn(tot + 1);\n    std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;\n        static int now = 0;\n        dfn[x] = ++now;\n        // printf(&quot;%d &quot;, x);\n        for (auto i : g[x])\n            DFS(i);\n        rfn[x] = now;\n        return;\n    &#125;;\n    DFS(0);\n    std::function&lt;void(int, int)&gt; DFS1 = [&amp;](int x, int u) &#123;\n        add(dfn[u], 1);\n        for (auto i : q[x])\n            res[i] += ask(rfn[tail[i]]) - ask(dfn[tail[i]] - 1);\n        for (int i = 0; i &lt; 26; ++i)\n            if (to[x][i])\n                DFS1(to[x][i], T[u][i]);\n        add(dfn[u], -1);\n        return;\n    &#125;;\n    DFS1(0, 0);\n    for (int i = 1; i &lt;= m; ++i)\n        std::cout &lt;&lt; res[i] &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"fail-树的维护\">fail 树的维护</h2>\n<h3 id=\"eg.-divljak\">eg. Divljak</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P5840\" class=\"uri\">https://www.luogu.com.cn/problem/P5840</a></p>\n<h4 id=\"法一把动态问题离线\">法一：把动态问题离线</h4>\n<p>问题相当于将模式串 <span class=\"math inline\">\\(T:\\{P\\}\\)</span> 动态化，但我们仍可以无脑离线下来解决问题。</p>\n<p>考虑原本的答案计算过程，即在经过的所有状态及其 fail 链上打标记。现在我们需要离线并区分标记的来源（并且标记类型为布尔值），下意识想到使用线段树维护。</p>\n<p>我们对每个状态建立动态开点线段树，最后拓扑排序时使用线段树合并处理信息。容易证明时间复杂度相较原来多了一个 <span class=\"math inline\">\\(\\log\\)</span>。</p>\n<p><del>理论可行，开始实践</del> 出题人似乎不是很喜欢线段树选手所以决定剥夺你的 Memory Limit。想要用这种做法通过本题可见 <a href=\"https://www.luogu.com.cn/article/jaxk3sno\" class=\"uri\">https://www.luogu.com.cn/article/jaxk3sno</a>。</p>\n<h4 id=\"法二转而处理静态问题\">法二：转而处理静态问题</h4>\n<p>注意到题目中的静态的 <span class=\"math inline\">\\(S_x\\)</span> 比起 <span class=\"math inline\">\\(T:\\{P\\}\\)</span> 更适合用来做模式串，我们在 <span class=\"math inline\">\\(S_x\\)</span> 上构建 AC 自动机，考虑在线解决问题。</p>\n<p>在每次 <code>1</code> 操作时，更新模式串信息。对于途径的所有状态 <span class=\"math inline\">\\(\\{u\\}\\)</span>，考虑更新其所在 fail 链上的信息。</p>\n<p>注意到我们需要修改整条 fail 链上的信息，询问则是询问单点。这个时候可以考虑使用树上差分。</p>\n<p>但是 here comes a problem，我们对于这一整个串只能在整个树上每个点上更新一次。怎么消去相同的影响呢？</p>\n<p>这里实现上我们将经过的点按 fail 树上 dfn 排序，并且对于序列中相邻的两点在其 LCA 上减去一次标记。为什么这是正确的呢？参考虚树，我们只需要让序列中相邻的两个点尽量近就可以保证重复的被删除完毕。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 2e6 + 5;\nint tot, bit[maxn], T[maxn][26], fail[maxn];\nint ins(std::string &amp;t) &#123;\n    int p = 0;\n    for (auto i : t) &#123;\n        if (!T[p][i - &#39;a&#39;])\n            T[p][i - &#39;a&#39;] = ++tot;\n        p = T[p][i - &#39;a&#39;];\n    &#125;\n    return p;\n&#125;\nint lowbit(int x) &#123;\n    return x &amp; -x;\n&#125;\nvoid add(int x, int v) &#123;\n    // printf(&quot;add (%d, %d)\\n&quot;, x, v);\n    for (; x &lt;= tot + 1; x += lowbit(x))\n        bit[x] += v;\n    return;\n&#125;\nint ask(int x) &#123;\n    int res = 0, to = x;\n    for (; x; x -= lowbit(x))\n        res += bit[x];\n    // printf(&quot;ask(%d) = %d\\n&quot;, to, res);\n    return res;\n&#125;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, q;\n    std::cin &gt;&gt; n;\n    std::vector&lt;int&gt; tail(n + 1);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::string t;\n        std::cin &gt;&gt; t, tail[i] = ins(t);\n    &#125;\n    std::vector&lt;std::vector&lt;int&gt; &gt; g(tot + 2);\n    &#123;\n        std::queue&lt;int&gt; q;\n        for (int i = 0; i &lt; 26; ++i)\n            if (T[0][i])\n                q.push(T[0][i]);\n        for (; !q.empty(); ) &#123;\n            int u = q.front();\n            q.pop();\n            for (int i = 0; i &lt; 26; ++i)\n                if (T[u][i]) &#123;\n                    int v = T[u][i];\n                    fail[v] = T[fail[u]][i];\n                    q.push(v);\n                &#125;\n                else\n                    T[u][i] = T[fail[u]][i];\n        &#125;\n        for (int i = 1; i &lt;= tot; ++i)\n            g[fail[i] + 1].push_back(i + 1);\n    &#125;\n    std::vector&lt;std::array&lt;int, 22&gt; &gt; f(tot + 2);\n    std::vector&lt;int&gt; dep(tot + 2), dfn(tot + 2), siz(tot + 2);\n    std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;\n        static int now = 0;\n        siz[x] = 1, dfn[x] = ++now;\n        // printf(&quot;%d\\n&quot;, x);\n        for (auto i : g[x]) &#123;\n            dep[i] = dep[x] + 1;\n            f[i][0] = x;\n            for (int j = 1; j &lt;= 21; ++j)\n                f[i][j] = f[f[i][j - 1]][j - 1];\n            DFS(i), siz[x] += siz[i];\n        &#125;\n        return;\n    &#125;;\n    dep[1] = 1, DFS(1);\n    auto askLCA = [&amp;](int x, int y) &#123;\n        if (x == y)\n            return x;\n        if (dep[x] &lt; dep[y])\n            std::swap(x, y);\n        for (int i = 21; ~i; --i)\n            if (dep[f[x][i]] &gt;= dep[y])\n                x = f[x][i];\n        if (x == y)\n            return x;\n        for (int i = 21; ~i; --i)\n            if (f[x][i] != f[y][i])\n                x = f[x][i], y = f[y][i];\n        return f[x][0];\n    &#125;;\n    std::cin &gt;&gt; q;\n    for (; q--; ) &#123;\n        int op;\n        std::cin &gt;&gt; op;\n        if (op == 1) &#123;\n            std::string s;\n            std::cin &gt;&gt; s;\n            int p = 0, len = (int)s.length();\n            std::vector&lt;int&gt; id(len + 1);\n            for (int i = 1; i &lt;= len; ++i)\n                p = T[p][s[i - 1] - &#39;a&#39;], id[i] = p + 1;\n            std::sort(id.begin() + 1, id.end(), [&amp;](int x, int y) &#123; return dfn[x] &lt; dfn[y]; &#125;);\n            // for (int i = 1; i &lt;= len; ++i)\n            //     printf(&quot;%d &quot;, id[i]);\n            // puts(&quot;&quot;);\n            for (int i = 1; i &lt;= len; ++i) &#123;\n                // printf(&quot;%d %d %d\\n&quot;, i, id[i], dfn[id[i]]);\n                // assert(0);\n                add(dfn[id[i]], 1);\n                if (i != 1)\n                    add(dfn[askLCA(id[i], id[i - 1])], -1);\n            &#125;\n        &#125;\n        else &#123;\n            int x;\n            std::cin &gt;&gt; x;\n            x = tail[x] + 1;\n            std::cout &lt;&lt; ask(dfn[x] + siz[x] - 1) - ask(dfn[x] - 1) &lt;&lt; &#39;\\n&#39;;\n        &#125;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"ac-自动机上的-dp\">AC 自动机上的 DP</h2>\n<p>鉴于 AC 自动机的优秀结构与性质，并不经常作为字符串匹配工具出现，其一个应用是作为 DP 的载体。</p>\n<h3 id=\"eg1.-l-语言\">eg1. L 语言</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P2292\" class=\"uri\">https://www.luogu.com.cn/problem/P2292</a></p>\n<p>我们想到要在自动机上匹配，但此时 <code>fail</code> 作为「断句」的唯一手段（断句的位置在链上当前点深度 - <code>fail</code> 深度处），不再仅当失配时才能经过。我们考虑朴素的 DP：在经过的每个状态考虑断句，那么这要求断句处是一个单词的结尾，那么此时 <code>fail</code> 最长匹配长度即可被更新。最后遍历所有单词的末结点，取最大答案。这里的 <code>fail</code> 其实是 <code>fail</code> 链上任意一点。</p>\n<p>考虑复杂度。容易发现对于每一个点我们跳了其整条 fail 链，那么复杂度就是最劣 <span class=\"math inline\">\\(n^2\\)</span> 的。考虑优化这个过程至 <span class=\"math inline\">\\(O(1)\\)</span>。</p>\n<p>题目里有一个很重要的条件还没有用到：单个单词长度 <span class=\"math inline\">\\(\\le 20\\)</span>，这让我们想到状态压缩。对于每一个状态，记录其断出来单词的可能长度。</p>\n<p>我们在 DAG 上游走的时候记录目前可以断的所有位置，如果其和当前可断出来的长度之交不为空，就可以将此处加入「可以断的所有位置」并更新答案。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 2e5 + 5;\nint T[maxn][26], tot, fail[maxn], len[maxn], dep[maxn], tag[maxn];\nint ins(std::string &amp;t) &#123;\n    int p = 0;\n    for (auto i : t) &#123;\n        if (!T[p][i - &#39;a&#39;])\n            T[p][i - &#39;a&#39;] = ++tot, dep[tot] = dep[p] + 1;\n        p = T[p][i - &#39;a&#39;];\n    &#125;\n    ++tag[p];\n    return p;\n&#125;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, m;\n    std::cin &gt;&gt; n &gt;&gt; m;\n    std::vector&lt;int&gt; tail(n + 1);\n    std::vector&lt;std::string&gt; t(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; t[i], tail[i] = ins(t[i]);\n    &#123;\n        std::queue&lt;int&gt; q;\n        for (int i = 0; i &lt; 26; ++i)\n            if (T[0][i])\n                q.push(T[0][i]);\n        for (; !q.empty(); ) &#123;\n            int u = q.front();\n            q.pop();\n            len[u] = len[fail[u]];\n            if (tag[u])\n                len[u] |= (1 &lt;&lt; dep[u]);\n            for (int i = 0; i &lt; 26; ++i)\n                if (T[u][i]) &#123;\n                    int v = T[u][i];\n                    fail[v] = T[fail[u]][i];\n                    q.push(v);\n                &#125;\n                else\n                    T[u][i] = T[fail[u]][i];\n        &#125;\n    &#125;\n    for (; m--; ) &#123;\n        std::string s;\n        std::cin &gt;&gt; s;\n        int p = 0, q = 1, res = 0;\n        for (int i = 0; i &lt; (int)s.length(); ++i) &#123;\n            p = T[p][s[i] - &#39;a&#39;], q &lt;&lt;= 1;\n            if (len[p] &amp; q)\n                q |= 1, res = i + 1;\n        &#125;\n        std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"eg2.-popcount-words\">eg2. Popcount Words</h3>\n<p><a href=\"https://codeforces.com/gym/103409/problem/H\" class=\"uri\">https://codeforces.com/gym/103409/problem/H</a></p>\n<p><del>咋上强度了啊。</del></p>\n<p>先把整个序列写出来，即 <span class=\"math inline\">\\(w=\\texttt{01101001100101}\\cdots\\)</span>，尝试进一步探究形式化的规律，可以得到：</p>\n<ol type=\"1\">\n<li><span class=\"math inline\">\\(w_{[0, 2^n), 0}=w_{[0, 2^{n-1}),0}+w_{[0, 2^n), 1}\\)</span>，其中 <span class=\"math inline\">\\(w_{[l, r], 0/1}\\)</span> 表示 <span class=\"math inline\">\\([l, r]\\)</span> 内，原串 / 取反的值。</li>\n<li>对于不以 <span class=\"math inline\">\\(0\\)</span> 开头的整段，可以从上述规则转化为 <span class=\"math inline\">\\(0\\)</span> 开头的整段。</li>\n</ol>\n<p>接着不难想到一种类似线段树的方式，将待求的 <span class=\"math inline\">\\(w_{[l, r], 0}\\)</span> 分到 <span class=\"math inline\">\\(O(\\log V)\\)</span> 个整段上，那么 <span class=\"math inline\">\\(S\\)</span> 就可以被 <span class=\"math inline\">\\(O(n\\log V)\\)</span> 个整段（也是 <span class=\"math inline\">\\(\\log V\\)</span> 个本质不同整段）描述。</p>\n<p>我们对 <span class=\"math inline\">\\({p_m}\\)</span> 建立 AC 自动机，需要知道这 <span class=\"math inline\">\\(\\log V\\)</span> 个整段在每个点上的出现次数。对于自动机上任意状态 <span class=\"math inline\">\\(u\\)</span>，设 <span class=\"math inline\">\\(to_{u, n, 0/1}\\)</span> 表示 <span class=\"math inline\">\\(u\\)</span> 经过 <span class=\"math inline\">\\(w_{[0, 2^n), 0/1}\\)</span> 后到达的点，则可倍增（嘶，这里是不是应该反过来叫分治啊）简单解决。</p>\n<p>那么接下来我们就可以用 <span class=\"math inline\">\\(to\\)</span> 来进行快速游走了。顺便打个 <span class=\"math inline\">\\(cnt\\)</span> 记录一下每个 <span class=\"math inline\">\\(u\\)</span> 作为不同整段的开头被经过的次数。然后做一个 DP，类似于线段树上 <code>pushdown</code> 的操作把所有整段下放到单点上的单个字符。</p>\n<p>有一说一用 DP 来处理这个东西还挺难想的。可能也是基于前面的倍增吧。最后拓扑排序就行了。</p>\n<details>\n<p>大家数组一定要用 C-style array 啊，<code>std::vector&lt;&gt;</code> 计算的是申请空间包 MLE 的 <img src=\"/em/ll.gif\" /></p>\n<p>大家大数组一定要内存连续访问优化啊，TLE <span class=\"math inline\">\\(\\to\\)</span> 100ms 泪目了 <img src=\"/em/ll.gif\" /></p>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 5e5 + 5;\nlong long sum[maxn], f[2][30][maxn];\nint cnt[2][30][maxn], to[2][30][maxn];\nint T[maxn][2], tot, fail[maxn], deg[maxn];\nint ins(std::string &amp;t) &#123;\n    int p = 0;\n    for (auto i : t) &#123;\n        if (!T[p][i - &#39;0&#39;])\n            T[p][i - &#39;0&#39;] = ++tot;\n        p = T[p][i - &#39;0&#39;];\n    &#125;\n    return p;\n&#125;\nvoid ask(std::vector&lt;std::pair&lt;int, int&gt; &gt; &amp;s, int ql, int qr, int l = 0, int r = (1 &lt;&lt; 30) - 1, int len = 30, int v = 0) &#123;\n    if (ql &lt;= l &amp;&amp; r &lt;= qr) &#123;\n        s.emplace_back(len, v);\n        return;\n    &#125;\n    int mid = l + (r - l) / 2;\n    if (ql &lt;= mid)\n        ask(s, ql, qr, l, mid, len - 1, v);\n    if (qr &gt; mid)\n        ask(s, ql, qr, mid + 1, r, len - 1, v ^ 1);\n    return;\n&#125;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, m;\n    std::cin &gt;&gt; n &gt;&gt; m;\n    std::vector&lt;std::pair&lt;int, int&gt; &gt; s;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        int l, r;\n        std::cin &gt;&gt; l &gt;&gt; r;\n        ask(s, l, r);\n    &#125;\n    std::vector&lt;int&gt; tail(m + 1);\n    for (int i = 1; i &lt;= m; ++i) &#123;\n        std::string t;\n        std::cin &gt;&gt; t;\n        tail[i] = ins(t);\n    &#125;\n    &#123;\n        std::queue&lt;int&gt; q;\n        for (int i = 0; i &lt; 2; ++i)\n            if (T[0][i])\n                q.push(T[0][i]);\n        for (; !q.empty(); ) &#123;\n            int u = q.front();\n            q.pop();\n            for (int i = 0; i &lt; 2; ++i)\n                if (T[u][i]) &#123;\n                    int v = T[u][i];\n                    fail[v] = T[fail[u]][i], ++deg[T[fail[u]][i]];\n                    q.push(v);\n                &#125;\n                else\n                    T[u][i] = T[fail[u]][i];\n        &#125;\n    &#125;\n    for (int i = 0; i &lt;= tot; ++i)\n        to[0][0][i] = T[i][0], to[1][0][i] = T[i][1];\n    for (int j = 1; j &lt; 30; ++j)\n        for (int i = 0; i &lt;= tot; ++i) &#123;\n            to[0][j][i] = to[1][j - 1][to[0][j - 1][i]];\n            to[1][j][i] = to[0][j - 1][to[1][j - 1][i]];\n        &#125;\n    &#123;\n        int p = 0;\n        for (auto [n, i] : s) &#123;\n            // printf(&quot;# %d %d\\n&quot;, n, i);\n            ++cnt[i][n][p], p = to[i][n][p];\n        &#125;\n    &#125;\n    for (int j = 29; ~j; --j)\n        for (int i = 0; i &lt;= tot; ++i) &#123;\n            if (j != 29) &#123;\n                f[0][j][i] += f[0][j + 1][i];\n                f[1][j][i] += f[1][j + 1][i];\n                f[0][j][to[1][j][i]] += f[1][j + 1][i];\n                f[1][j][to[0][j][i]] += f[0][j + 1][i];\n            &#125;\n            f[1][j][i] += cnt[1][j][i];\n            f[0][j][i] += cnt[0][j][i];\n        &#125;\n    for (int i = 0; i &lt;= tot; ++i) &#123;\n        sum[T[i][0]] += f[0][0][i], sum[T[i][1]] += f[1][0][i];\n        // printf(&quot;%d %d\\n&quot;, f[i][0][0], f[i][0][1]);\n    &#125;\n    &#123;\n        std::queue&lt;int&gt; q;\n        for (int i = 0; i &lt;= tot; ++i)\n            if (!deg[i])\n                q.push(i);\n        for (; !q.empty(); ) &#123;\n            int u = q.front();\n            q.pop();\n            sum[fail[u]] += sum[u];\n            if (!--deg[fail[u]])\n                q.push(fail[u]);\n        &#125;\n    &#125;\n    for (int i = 1; i &lt;= m; ++i)\n        std::cout &lt;&lt; sum[tail[i]] &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"eg3.-legen\">eg3. Legen…</h3>\n<p><a href=\"https://codeforces.com/problemset/problem/696/D\" class=\"uri\">https://codeforces.com/problemset/problem/696/D</a></p>\n<p>先在 fail 树上把每个状态的实际价值计算出来。我们发现匹配串是未知的，也就是我们需要主动决定游走路径。注意到 <span class=\"math inline\">\\(l=10^{14}\\)</span>，考虑矩阵。</p>\n<p>令 <span class=\"math inline\">\\(f_{u, i}\\)</span> 表示在 <span class=\"math inline\">\\(u\\)</span> 状态时已经走了 <span class=\"math inline\">\\(i\\)</span> 步，可以得到的最大价值。那么显然有：</p>\n<p><span class=\"math display\">\\[\nf_{v,i+1}=f_{u,i}+s_v.\n\\]</span></p>\n<p>其中 <span class=\"math inline\">\\(v\\)</span> 是自动机上 <span class=\"math inline\">\\(u\\)</span> 的任意出边。图的大小为 <span class=\"math inline\">\\(200\\)</span>，可以放到 <span class=\"math inline\">\\(+\\max\\)</span> 矩阵里加速转移。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 2e5 + 5;\nconst long long inf = 1e18;\nint fail[maxn], T[maxn][26], tot;\nint ins(std::string s) &#123;\n    int p = 0;\n    for (auto i : s) &#123;\n        if (!T[p][i - &#39;a&#39;])\n            T[p][i - &#39;a&#39;] = ++tot;\n        p = T[p][i - &#39;a&#39;];\n    &#125;\n    return p;\n&#125;\nstruct matrix &#123;\n    int n, m;\n    std::vector&lt;std::vector&lt;long long&gt; &gt; a;\n    matrix(int n1, int m1, long long v = -inf, bool op = 0): n(n1), m(m1), a(n + 1, std::vector&lt;long long&gt; (m + 1, v)) &#123;\n        if (op)\n            for (int i = 0; i &lt;= n; ++i)\n                a[i][i] = 0;\n        return;\n    &#125;\n    std::vector&lt;long long&gt; &amp;operator[] (int i) &#123;\n        return a[i];\n    &#125;\n    matrix operator* (matrix &amp;q) const &#123;\n        matrix res(n, q.m);\n        for (int k = 0; k &lt;= m; ++k)\n            for (int i = 0; i &lt;= n; ++i)\n                for (int j = 0; j &lt;= q.m; ++j)\n                    res[i][j] = std::max(res[i][j], a[i][k] + q[k][j]);\n        return res;\n    &#125;\n    matrix&amp; operator*= (matrix q) &#123;\n        return *this = *this * q;\n    &#125;\n    matrix operator^ (long long q) &#123;\n        matrix res(n, n, -inf, 1), x(*this);\n        for (; q; q &gt;&gt;= 1, x *= x)\n            if (q &amp; 1)\n                res *= x;\n        return res;\n    &#125;\n&#125;;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    long long m;\n    std::cin &gt;&gt; n &gt;&gt; m;\n    std::vector&lt;long long&gt; a(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i];\n    std::vector&lt;int&gt; tail(n + 1);\n    std::vector&lt;std::string&gt; t(n + 1);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; t[i];\n        tail[i] = ins(t[i]);\n    &#125;\n    std::vector&lt;long long&gt; s(tot + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        s[tail[i]] += a[i];\n    &#123;\n        std::queue&lt;int&gt; q;\n        for (int i = 0; i &lt; 26; ++i)\n            if (T[0][i])\n                q.push(T[0][i]); \n        for (; !q.empty(); ) &#123;\n            int u = q.front();\n            q.pop();\n            for (int i = 0; i &lt; 26; ++i)\n                if (T[u][i]) &#123;\n                    int v = T[u][i];\n                    fail[v] = T[fail[u]][i], s[v] += s[fail[v]];\n                    q.push(v);\n                &#125;\n                else\n                    T[u][i] = T[fail[u]][i];\n        &#125;\n    &#125;\n    matrix f(0, tot), op(tot, tot);\n    f[0][0] = 0;\n    for (int i = 0; i &lt;= tot; ++i)\n        for (int j = 0; j &lt; 26; ++j)\n            op[i][T[i][j]] = s[T[i][j]];\n    f *= (op * m);\n    std::cout &lt;&lt; *std::max_element(f[0].begin(), f[0].end()) &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;\n</code></pre>\n</details>\n<hr />\n<h3 id=\"eg4.-you-are-given-some-strings\">eg4. You Are Given Some Strings…</h3>\n<p>goto <a href=\"/20250121/#%E4%B8%80%E4%B8%AA%E6%A8%A1%E6%9D%BFcf1202e-you-are-given-some-strings...\">link</a>.</p>\n",
            "tags": [
                "DP",
                "字符串",
                "AC 自动机"
            ]
        }
    ]
}