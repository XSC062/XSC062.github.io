{
    "version": "https://jsonfeed.org/version/1",
    "title": "null • All posts by \"哈希\" tag",
    "description": "",
    "home_page_url": "https://xsc062.netlify.app",
    "items": [
        {
            "id": "https://xsc062.netlify.app/20241021/",
            "url": "https://xsc062.netlify.app/20241021/",
            "title": "杂题选谈：字符串",
            "date_published": "2024-10-21T00:32:59.000Z",
            "content_html": "<p>标题本来叫「哈希」，后来发现第二天的很多题虽然打了哈希的 tag 但是只有 KMP 做法，故忍痛改成「字符串」。</p>\n<span id=\"more\"></span>\n<hr />\n<h2 id=\"a.-two-permutations\">A. Two Permutations</h2>\n<p><a href=\"https://www.becoder.com.cn/contest/5653/problem/1\" class=\"uri\">https://www.becoder.com.cn/contest/5653/problem/1</a></p>\n<p>有个很重要的性质是 <span class=\"math inline\">\\(a\\)</span> 和 <span class=\"math inline\">\\(b\\)</span> 都是排列。然后我们就知道了 <span class=\"math inline\">\\(x\\in [0,m-n]\\)</span>，且每个 <span class=\"math inline\">\\(a_i+x\\)</span> 在 <span class=\"math inline\">\\(b\\)</span> 中有元素与之唯一对应。<mark>于是问题可以转化成，<span class=\"math inline\">\\(b\\)</span> 中在 <span class=\"math inline\">\\([1+x,n+x]\\)</span> 范围中的元素按顺序哈希起来和 <span class=\"math inline\">\\(a\\)</span> 序列是否完全一致</mark>。</p>\n<p>我们就有了一个想法：枚举这个 <span class=\"math inline\">\\(x\\)</span>，通过某种方法快速查询这个长度固定的值域区间按顺序哈希起来的值。<mark>然后就是典中典之线段树维护哈希，只需在枚举 <span class=\"math inline\">\\(x\\)</span> 时滑动窗口，剔除头部元素，新增尾部元素，查询全局哈希值即可</mark>。</p>\n<p>还有一个小细节是关于实时维护全局加 <span class=\"math inline\">\\(x\\)</span> 后的 <span class=\"math inline\">\\(a\\)</span>。由于哈希用乘的肯定拆不开，只能用加哈希了。每次 <span class=\"math inline\">\\(x\\)</span> 加一的时候全局哈希值加上 <span class=\"math inline\">\\(\\sum p_i\\)</span> 即可。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int p = 998244353;\nconst int mod = 1e9 + 7;\nconst int maxn = 2e5 + 5;\nstruct &#123;\n    int l, r, s;\n    long long u;\n&#125; t[maxn &lt;&lt; 2];\nlong long base[maxn];\n#define lt (p &lt;&lt; 1)\n#define rt (lt | 1)\nvoid pushup(int p) &#123;\n    t[p].u = (t[lt].u * base[t[rt].s] % mod + t[rt].u) % mod;\n    return;\n&#125;\nvoid bld(int p, int l, int r) &#123;\n    t[p].l = l, t[p].r = r;\n    if (l == r)\n        return;\n    int mid = (l + r) &gt;&gt; 1;\n    bld(lt, l, mid), bld(rt, mid + 1, r);\n    return;\n&#125;\nvoid add(int p, int x, int v) &#123;\n    t[p].s += (v &gt;= 0 ? 1 : -1);\n    if (t[p].l == t[p].r) &#123;\n        t[p].u += v;\n        return;\n    &#125;\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (x &lt;= mid)\n        add(lt, x, v);\n    else\n        add(rt, x, v);\n    pushup(p);\n    return;\n&#125;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, m;\n    std::cin &gt;&gt; n &gt;&gt; m;\n    std::vector&lt;int&gt; a(n + 1), b(m + 1), pos(m + 1);\n    base[0] = 1;\n    long long s = 1;\n    for (int i = 1; i &lt;= m; ++i) &#123;\n        base[i] = base[i - 1] * p % mod;\n        if (i &lt; n)\n            (s += base[i]) %= mod;\n    &#125;\n    long long now = 0;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; a[i];\n        now = (now * p % mod + a[i]) % mod;\n    &#125;\n    for (int i = 1; i &lt;= m; ++i)\n        std::cin &gt;&gt; b[i], pos[b[i]] = i;\n    int res = 0;\n    bld(1, 1, m);\n    for (int x = 0; x &lt;= m - n; ++x) &#123;\n        for (static int l = 1; l &lt; 1 + x; add(1, pos[l], -l), ++l);\n            // printf(&quot;add %d: %d\\n&quot;, pos[l], -l);\n        for (static int r = 1; r &lt;= n + x; add(1, pos[r], r), ++r);\n            // printf(&quot;add %d: %d\\n&quot;, pos[r], r);\n        (res += (now == t[1].u));\n        // printf(&quot;x = %d, now = %lld, t[1].u = %lld\\n&quot;, x, now, t[1].u);\n        (now += s) %= mod;\n    &#125;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"b.-k-substrings\">B. k-substrings</h2>\n<p><a href=\"https://www.becoder.com.cn/contest/5653/problem/2\" class=\"uri\">https://www.becoder.com.cn/contest/5653/problem/2</a></p>\n<p>我们可以发现这 <span class=\"math inline\">\\(\\left\\lceil\\dfrac n2\\right\\rceil\\)</span> 个串都有共同中点，而<mark>不管其位于元素还是元素间的空隙，两边的 border 都应关于其对称</mark>。啥叫奇 border 呢，就是每个 border 都能取到元素上的中点，<mark>也就是说这俩中点是关于全串中点对称的</mark>。</p>\n<p>我们枚举这 <span class=\"math inline\">\\(\\left\\lfloor\\dfrac n2\\right\\rfloor\\)</span> 对可能的 border 中点，分别二分 border 长度。假设最后该对中点最长合法 border 为 <span class=\"math inline\">\\([l_1,r_1]\\)</span> 与 <span class=\"math inline\">\\([l_2,r_2]\\)</span>，用 <span class=\"math inline\">\\(r_1-l_1+1-2\\times k\\)</span> 更新 <span class=\"math inline\">\\(l_1+k\\)</span> 处的答案即可。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int p = 131;\nconst int mod = 1e9 + 7;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;char&gt; a(n + 1);\n    std::vector&lt;int&gt; res(n + 1, -1);\n    std::vector&lt;long long&gt; h(n + 1), base(n + 1);\n    base[0] = 1;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; a[i];\n        h[i] = (h[i - 1] * p + a[i]) % mod;\n        base[i] = base[i - 1] * p % mod;\n    &#125;\n    auto geth = [&amp;](int l, int r) &#123;\n        return (h[r] + mod - h[l - 1] * base[r - l + 1] % mod) % mod;\n    &#125;;\n    for (int l = n / 2, r = (n + 1) / 2 + 1; r &lt;= n; --l, ++r)\n        if (a[l] == a[r]) &#123;\n            int t = 0;\n            for (int ll = 1, rr = l, mid; ll &lt;= rr; ) &#123;\n                mid = (ll + rr) &gt;&gt; 1;\n                if (geth(l - mid + 1, l + mid - 1) == geth(r - mid + 1, r + mid - 1))\n                    t = mid, ll = mid + 1;\n                else\n                    rr = mid - 1;\n            &#125;\n            res[l - t + 1] = std::max(res[l - t + 1], 2 * t - 1);\n        &#125;\n    for (int i = 1; i &lt;= (n + 1) / 2; ++i) &#123;\n        res[i] = std::max(res[i - 1] - 2, res[i]);\n        std::cout &lt;&lt; res[i] &lt;&lt; &#39; &#39;;\n    &#125;\n    std::cout &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"c.-kefa-and-watch\">C. Kefa and Watch</h2>\n<p><a href=\"https://www.becoder.com.cn/contest/5653/problem/3\" class=\"uri\">https://www.becoder.com.cn/contest/5653/problem/3</a></p>\n<p>一个挺常用的 trick 是，<mark><span class=\"math inline\">\\(S_{l\\sim r}\\)</span> 存在长度为 <span class=\"math inline\">\\(d\\)</span> 的循环节 <span class=\"math inline\">\\(\\iff S_{l\\sim (r-d)}=S_{(l+d+)\\sim r}\\)</span></mark>。而题目要求为混循环节，刚好也可以用这个方法判定。线段树随便维护一下哈希就行。assign 操作就是将长度为 <span class=\"math inline\">\\(len\\)</span> 的区间哈希值更改为 <span class=\"math inline\">\\(t\\times \\sum_{i=0}^{len-1}p^i\\)</span>。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int p = 131;\nconst int mod = 1e9 + 7;\nconst int maxn = 1e5 + 5;\nstruct &#123;\n    int l, r, d;\n    long long u;\n&#125; t[maxn &lt;&lt; 2];\nint a[maxn];\nlong long base[maxn], s[maxn];\n#define lt (p &lt;&lt; 1)\n#define rt (lt | 1)\nvoid pushup(int p) &#123;\n    t[p].u = (t[lt].u * base[t[rt].r - t[rt].l + 1] % mod + t[rt].u) % mod;\n    return;\n&#125;\nvoid pushdown(int p) &#123;\n    if (~t[p].d) &#123;\n        t[lt].d = t[rt].d = t[p].d;\n        t[lt].u = t[p].d * s[t[lt].r - t[lt].l] % mod;\n        t[rt].u = t[p].d * s[t[rt].r - t[rt].l] % mod;\n        t[p].d = -1;\n    &#125;\n    return;\n&#125;\nvoid bld(int p, int l, int r) &#123;\n    t[p].l = l, t[p].r = r, t[p].d = -1;\n    if (l == r) &#123;\n        t[p].u = a[l];\n        return;\n    &#125;\n    int mid = (l + r) &gt;&gt; 1;\n    bld(lt, l, mid), bld(rt, mid + 1, r);\n    pushup(p);\n    return;\n&#125;\nvoid ass(int p, int l, int r, int v) &#123;\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r) &#123;\n        t[p].d = v;\n        t[p].u = v * s[t[p].r - t[p].l] % mod;\n        return;\n    &#125;\n    pushdown(p);\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (l &lt;= mid)\n        ass(lt, l, r, v);\n    if (r &gt; mid)\n        ass(rt, l, r, v);\n    pushup(p);\n    return;\n&#125;\nlong long ask(int p, int l, int r) &#123;\n    // printf(&quot;p = %d, u = %lld, [%d, %d] of [%d, %d]\\n&quot;, p, t[p].u, t[p].l, t[p].r, l, r);\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r)\n        return t[p].u;\n    pushdown(p);\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (r &lt;= mid)\n        return ask(lt, l, r);\n    if (l &gt; mid)\n        return ask(rt, l, r);\n    return (ask(lt, l, r) * base[std::min(r, t[p].r) - mid] % mod + ask(rt, l, r)) % mod;\n&#125;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, m, k;\n    std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;\n    base[0] = s[0] = 1;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        char t;\n        std::cin &gt;&gt; t;\n        a[i] = t - &#39;0&#39;;\n        base[i] = base[i - 1] * p % mod;\n        s[i] = (s[i - 1] + base[i]) % mod;\n    &#125;\n    bld(1, 1, n);\n    for (int q = m + k; q--; ) &#123;\n        int op;\n        std::cin &gt;&gt; op;\n        if (op == 1) &#123;\n            int l, r, t;\n            std::cin &gt;&gt; l &gt;&gt; r &gt;&gt; t;\n            ass(1, l, r, t);\n        &#125;\n        else &#123;\n            int l, r, d;\n            std::cin &gt;&gt; l &gt;&gt; r &gt;&gt; d;\n            // if (d != r - l + 1)\n            //     printf(&quot;%lld / %lld\\n&quot;, ask(1, l, r - d), ask(1, l + d, r));\n            std::cout &lt;&lt; ((d == r - l + 1 || ask(1, l, r - d) == ask(1, l + d, r)) ? &quot;YES&quot; : &quot;NO&quot;) &lt;&lt; &#39;\\n&#39;;\n        &#125;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"d.-misha-and-lcp-on-tree\">D. Misha and LCP on Tree</h2>\n<p><a href=\"https://www.becoder.com.cn/contest/5653/problem/4\" class=\"uri\">https://www.becoder.com.cn/contest/5653/problem/4</a></p>\n<p>一个很显然的做法是，我们二分一个长度，然后在 <span class=\"math inline\">\\(a\\to fa\\)</span> 上正哈希，<span class=\"math inline\">\\(b\\to fa\\)</span> 上反哈希，<span class=\"math inline\">\\(O(1)\\)</span> check。</p>\n<p>笑话：本来想用倍增求 <span class=\"math inline\">\\(a\\to fa\\)</span> 和 <span class=\"math inline\">\\(b\\to fa\\)</span> 的哈希（当然双 <span class=\"math inline\">\\(\\log\\)</span> 肯定是会被卡飞的），后来发现<mark>哈希具有可减性，我们又只需求一条链上的哈希值，直接减掉就行</mark>。</p>\n<p>还有一个点就是 <span class=\"math inline\">\\(O(1)\\)</span> 求 <span class=\"math inline\">\\(k\\)</span> 级祖先，有长剖预处理的做法。<a href=\"/20241021-1\">具体做法</a>。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int p = 131;\nconst int mod = 1e9 + 7;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;int&gt; to(n + 1);\n    std::vector&lt;char&gt; a(n + 1);\n    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);\n    std::vector&lt;long long&gt; base(n + 1), inv(n + 1);\n    auto qkp = [](long long x, int y) &#123;\n        long long res = 1;\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    base[0] = inv[0] = 1;\n    for (int i = 1, mx = 0; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; a[i];\n        base[i] = base[i - 1] * p % mod;\n        inv[i] = qkp(base[i], mod - 2);\n        if (i &gt;= (1 &lt;&lt; mx) * 2)\n            ++mx;\n        to[i] = mx;\n    &#125;\n    for (int i = 1, x, y; i &lt; n; ++i) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y;\n        g[x].push_back(y), g[y].push_back(x);\n    &#125;\n    std::vector&lt;long long&gt; h1(n + 1), h2(n + 1);\n    std::vector&lt;std::array&lt;int, 21&gt; &gt; fa(n + 1);\n    std::vector&lt;int&gt; h(n + 1, 1), son(n + 1), dep(n + 1);\n    h[0] = 0;\n    std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;\n        h1[x] = (h1[fa[x][0]] * p % mod + a[x]) % mod;\n        h2[x] = (h2[fa[x][0]] + a[x] * base[dep[x] - 1]) % mod;\n        for (auto i : g[x])\n            if (i != fa[x][0]) &#123;\n                fa[i][0] = x;\n                for (int j = 1; j &lt;= 20; ++j)\n                    fa[i][j] = fa[fa[i][j - 1]][j - 1];\n                dep[i] = dep[x] + 1;\n                DFS(i);\n                if (h[i] &gt;= h[son[x]])\n                    son[x] = i, h[x] = h[i] + 1;\n            &#125;\n        return;\n    &#125;;\n    dep[1] = 1, DFS(1);\n    std::vector&lt;int&gt; top(n + 1), id(n + 1);\n    std::vector&lt;std::vector&lt;int&gt; &gt; anc(n + 1), des(n + 1, std::vector&lt;int&gt; (1));\n    std::function&lt;void(int, int)&gt; DFS1 = [&amp;](int x, int toq) &#123;\n        top[x] = toq;\n        if (son[x])\n            DFS1(son[x], toq);\n        for (auto i : g[x])\n            if (i != fa[x][0] &amp;&amp; i != son[x])\n                DFS1(i, i);\n        des[toq].push_back(x);\n        id[x] = (int)des[toq].size() - 1;\n        if (x == toq) &#123;\n            anc[x].push_back(x);\n            for (int j = 1, now = x; j &lt;= id[x]; ++j, now = fa[now][0])\n                anc[x].push_back(fa[now][0]);\n        &#125;\n        return;\n    &#125;;\n    DFS1(1, 1);\n    auto getLCA = [&amp;](int x, int y) &#123;\n        if (dep[x] &lt; dep[y])\n            std::swap(x, y);\n        for (int i = 20; ~i; --i)\n            if (dep[fa[x][i]] &gt;= dep[y])\n                x = fa[x][i];\n        if (x == y)\n            return x;\n        for (int i = 20; ~i; --i)\n            if (fa[x][i] != fa[y][i])\n                x = fa[x][i], y = fa[y][i];\n        return fa[x][0];\n    &#125;;\n    auto ask = [&amp;](int x, int k) &#123;\n        assert(dep[x] - 1 &gt;= k);\n        int x1 = x;\n        if (!k)\n            return x;\n        x = fa[x][to[k]];\n        if (dep[x] - dep[top[x]] &gt;= k - (1 &lt;&lt; to[k]))\n            return des[top[x]][id[x] + k - (1 &lt;&lt; to[k])];\n        return anc[top[x]][k - (1 &lt;&lt; to[k]) - (dep[x] - dep[top[x]])];\n    &#125;;\n    auto dis = [&amp;](int x, int y, int fa) &#123;\n        return dep[x] + dep[y] - 2 * dep[fa];\n    &#125;;\n    auto gethash = [&amp;](int x, int y, int f, int k) &#123;\n        if (!k)\n            return 0ll;\n        if (k &lt;= dep[x] - dep[f] + 1) &#123;\n            f = ask(x, k - 1);\n            return (h2[x] + mod - h2[fa[f][0]]) % mod * inv[dep[f] - 1] % mod;\n        &#125;\n        long long h = (h2[x] + mod - h2[fa[f][0]]) % mod * inv[dep[f] - 1] % mod;\n        k -= (dep[x] - dep[f] + 1);\n        y = ask(y, (dep[y] - dep[f]) - k);\n        h = (h * base[dep[y] - dep[f]] % mod + (h1[y] + mod - h1[f] * base[dep[y] - dep[f]] % mod) % mod) % mod;\n        return h;\n    &#125;;\n    int m;\n    std::cin &gt;&gt; m;\n    for (int x, y, a, b; m--; ) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y &gt;&gt; a &gt;&gt; b;\n        int fa1 = getLCA(x, y), fa2 = getLCA(a, b), res = 0;\n        for (int l = 0, r = std::min(dis(x, y, fa1), dis(a, b, fa2)) + 1, mid; l &lt;= r; ) &#123;\n            mid = (l + r) &gt;&gt; 1;\n            if (gethash(x, y, fa1, mid) == gethash(a, b, fa2, mid))\n                res = mid, l = mid + 1;\n            else\n                r = mid - 1;\n        &#125;\n        std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"a.-song-of-the-sirens\">A. Song of the Sirens</h2>\n<p><a href=\"https://www.becoder.com.cn/contest/5658/problem/1\" class=\"uri\">https://www.becoder.com.cn/contest/5658/problem/1</a></p>\n<p>笑话：是 <span class=\"math inline\">\\(s_it_is_i\\)</span> 而不是 <span class=\"math inline\">\\(s_its_i\\)</span>。</p>\n<p>我们发现 <span class=\"math inline\">\\(s_0\\)</span> 很短，所以直接枚举起始位置把 <span class=\"math inline\">\\(s_0\\)</span> 和匹配串大力匹配，把空位挖出来组成新的匹配串再考虑 <span class=\"math inline\">\\(t\\)</span> 的问题（因为所有 <span class=\"math inline\">\\(s_i\\)</span> 最开头都有一个完整的 <span class=\"math inline\">\\(s_0\\)</span>，所以可以随便选断点）。</p>\n<p>我们知道 <span class=\"math inline\">\\(t\\)</span> 的下标是一个自底向上从 <span class=\"math inline\">\\(1\\)</span> 到 <span class=\"math inline\">\\(n\\)</span> 的满二叉树的中序遍历，其中 <mark><span class=\"math inline\">\\(t_1\\)</span> 间隔一位出现；于是我们仿照对 <span class=\"math inline\">\\(s\\)</span> 的处理方式，再把 <span class=\"math inline\">\\(t_1\\)</span> 挖掉。注意到此时 <span class=\"math inline\">\\(t_2\\)</span> 又成为二叉树最底层，间隔一位出现，这就变成了一个 <span class=\"math inline\">\\(O(n\\log n)\\)</span> 递归的问题</mark>。</p>\n<p>至于答案，当 <span class=\"math inline\">\\(t\\)</span> 被删空时，假设删掉的最后一个元素为 <span class=\"math inline\">\\(t_p\\)</span>，<span class=\"math inline\">\\(t\\)</span> 的出现次数即为二叉树中 <span class=\"math inline\">\\(p\\)</span> 层点数，为 <span class=\"math inline\">\\(2^{k-p}\\)</span>。</p>\n<p>有一个细节，就是如果当前删到 <span class=\"math inline\">\\(i\\)</span> 了，<span class=\"math inline\">\\(t\\)</span> 的长度只剩 <span class=\"math inline\">\\(1\\)</span>，就会有一个很尴尬的问题——这个元素不一定就是 <span class=\"math inline\">\\(t_i\\)</span>，而应该是 <span class=\"math inline\">\\(\\{j \\mid j\\ge i\\land t_j=t_i\\}\\)</span>。统计 <span class=\"math inline\">\\(t_{i\\sim k}\\)</span> 中值为 <span class=\"math inline\">\\(t_i\\)</span> 的元素个数（前缀和），乘上对应的层数即可。这个可以用一点小技巧搞定，前缀和时忽略 <span class=\"math inline\">\\(k\\)</span> 乘上 <span class=\"math inline\">\\(k=n\\)</span> 时的系数，统计答案时乘上 <span class=\"math inline\">\\(2^{n-k}\\)</span> 即可。</p>\n<p>不是，那我缺的哈希这块谁来补啊？？？</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 1e9 + 7;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;sirens1.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, q, m;\n    std::string s;\n    std::cin &gt;&gt; n &gt;&gt; q &gt;&gt; s;\n    s = &#39;\\0&#39; + s, m = (int)s.length() - 1;\n    std::vector&lt;char&gt; t(n + 1);\n    std::vector&lt;long long&gt; base(n + 1), inv(n + 1);\n    std::vector&lt;std::array&lt;long long, 26&gt; &gt; a(n + 1);\n    auto qkp = [](long long x, int y) &#123;\n        long long res = 1ll;\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    base[0] = 1ll, inv[0] = 1ll, inv[1] = qkp(2, mod - 2);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; t[i];\n        base[i] = base[i - 1] * 2 % mod;\n        if (i != 1)\n            inv[i] = inv[i - 1] * inv[1] % mod;\n    &#125;\n    for (int i = 1; i &lt;= n; ++i)\n        a[i] = a[i - 1], (a[i][t[i] - &#39;a&#39;] += base[n - i]) %= mod;\n    for (int k; q--; ) &#123;\n        std::string p;\n        std::cin &gt;&gt; k &gt;&gt; p;\n        p = &#39;\\0&#39; + p;\n        long long res = 0;\n        int l = (int)p.length() - 1;\n        std::vector&lt;char&gt; u;\n        std::function&lt;void(int, std::vector&lt;char&gt; &amp;)&gt; calc = [&amp;](int x, std::vector&lt;char&gt; &amp;p) &#123;\n            int m = (int)p.size() - 1;\n            if (m == 0) &#123;\n                // puts(&quot;# 45&quot;);\n                // printf(&quot;0, += %lld\\n&quot;, base[k - x + 1]);\n                (res += base[k - x + 1]) %= mod;\n                return;\n            &#125;\n            if (x &gt; k)\n                return;\n            if (m == 1) &#123;\n                // puts(&quot;# 50&quot;);\n                // printf(&quot;1, += %lld(%lld)\\n&quot;, (a[k][p[1] - &#39;a&#39;] + mod - a[x - 1][p[1] - &#39;a&#39;]) % mod * inv[n - k] % mod, inv[n - k] % mod);\n                (res += (a[k][p[1] - &#39;a&#39;] + mod - a[x - 1][p[1] - &#39;a&#39;]) % mod * inv[n - k] % mod) %= mod;\n                return;\n            &#125;\n            bool flag0 = 1, flag1 = 1;\n            std::vector&lt;char&gt; t0(1), t1(1);\n            for (int i = 1; i &lt;= m; ++i)\n                if (!(i &amp; 1)) &#123;\n                    if (flag0)\n                        t0.push_back(p[i]);\n                    flag1 &amp;= (p[i] == t[x]);\n                &#125;\n                else &#123;\n                    if (flag1)\n                        t1.push_back(p[i]);\n                    flag0 &amp;= (p[i] == t[x]);\n                &#125;\n            if (flag0)\n                calc(x + 1, t0);\n            if (flag1)\n                calc(x + 1, t1);\n            return;\n        &#125;;\n        for (int i = 1; i &lt;= m + 1; ++i) &#123;\n            std::vector&lt;char&gt;(1).swap(u);\n            for (int j = i, now = 1; now &lt;= l; ++now) &#123;\n                if (j == m + 1)\n                    j = 1, u.push_back(p[now]);\n                else if (p[now] != s[j])\n                    goto nosol;\n                else\n                    ++j;\n            &#125;\n            // printf(&quot;u: &quot;);\n            // for (int i = 1; i &lt; (int)u.size(); ++i)\n            //     std::cout &lt;&lt; u[i];\n            // puts(&quot;&quot;);\n            calc(1, u);\n        nosol: ;\n        &#125;\n        std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"b.-prefix-of-suffixes\">B. Prefix of Suffixes</h2>\n<p><a href=\"https://www.becoder.com.cn/contest/5658/problem/2\" class=\"uri\">https://www.becoder.com.cn/contest/5658/problem/2</a></p>\n<p>还是太科幻了。哦哦 border 我的 border。</p>\n<h3 id=\"法一\">法一</h3>\n<p>考虑每次增量，若加入 <span class=\"math inline\">\\(S_i\\)</span> 后有 <span class=\"math inline\">\\(z_j\\)</span> 的值增加 <span class=\"math inline\">\\(1\\)</span>，那么这对 <span class=\"math inline\">\\((i, j)\\)</span> 就会贡献 <span class=\"math inline\">\\(A_j\\cdot B_i\\)</span> 的增量；<mark>反之，<span class=\"math inline\">\\(z_j\\)</span> 在以后也不会增加</mark>。</p>\n<p>我们维护当前没有确定下来的所有 <span class=\"math inline\">\\(z_j\\)</span>，对于每个 <span class=\"math inline\">\\(i\\)</span> 暴力 check <span class=\"math inline\">\\(z_j\\)</span> 是否确定并更新答案，<strong>因为数据比较弱</strong>，在 CF 神机上跑得飞快 <img src=\"/em/dy.gif\" /> 但是 QOJ 上死活过不了 <img src=\"/em/ll.gif\" /></p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    long long res = 0, s = 0;\n    std::cin &gt;&gt; n;\n    std::vector&lt;int&gt; now;\n    std::vector&lt;int&gt; a(n + 1), b(n + 1), t(n + 1);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; t[i] &gt;&gt; a[i] &gt;&gt; b[i];\n        t[i] = (res + t[i]) % n;\n        if (t[i] == t[1])\n            s += b[i], now.push_back(i);\n        std::vector&lt;int&gt; g(std::move(now));\n        for (auto j : g)\n            if (t[i] == t[i - j + 1])\n                now.push_back(j);\n            else\n                s -= b[j];\n        res += a[i] * s;\n        std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n<h3 id=\"法二\">法二</h3>\n<p>依然考虑增量。<mark><span class=\"math inline\">\\(z_j\\)</span> 增加 <span class=\"math inline\">\\(\\iff S_{j\\to i}\\)</span> 为 <span class=\"math inline\">\\(S_{1\\sim i}\\)</span> 的一个 border</mark>。考虑对于每一个 <span class=\"math inline\">\\(S_i\\)</span>，border 的组成。</p>\n<ol type=\"1\">\n<li>若 <span class=\"math inline\">\\(S_1=S_i\\)</span>，那么将会新增一个长度为 <span class=\"math inline\">\\(1\\)</span> 的 border。</li>\n<li>对于在 <span class=\"math inline\">\\(i-1\\)</span> 处合法的 border <span class=\"math inline\">\\(S_{j\\sim i-1}\\)</span>，若 <span class=\"math inline\">\\(S_i=S_{i-j+1}\\)</span>，则该 border 仍合法；否则非法。</li>\n</ol>\n<p>我们的法一其实相当于是暴力 check 了所有合法 border 是否仍然合法，但这显然最坏是 <span class=\"math inline\">\\(O(n^2)\\)</span> 的。我们考虑从 border 角度优化一下。</p>\n<p>我们发现，比如说 <span class=\"math inline\">\\(\\texttt{abababa + b}\\)</span>，我们会进行很多次不必要的 check，当然这个时候我们会本能大力跳 fail，但是这里有一个 <a href=\"https://www.luogu.com/article/e08ebmz6\">border 的等差数列性质</a>，若 <span class=\"math inline\">\\(x+1\\)</span> 与 <span class=\"math inline\">\\(i\\)</span> 能够匹配，那么与 <span class=\"math inline\">\\(x\\)</span> 同属一个等差数列的所有 <span class=\"math inline\">\\(x&#39;+1\\)</span> 都应和 <span class=\"math inline\">\\(i\\)</span> 匹配。</p>\n<p>对于正在 check 的 <span class=\"math inline\">\\(x\\)</span>，如果 check 成功则跳到上一条链的链尾；否则跳到链头。总的复杂度是 <span class=\"math inline\">\\(O(n\\log n)\\)</span> 的。找一下和每个 <span class=\"math inline\">\\(i\\)</span> 匹配不了的第一个链头，甚至可以因为某些我太菜了所以不知道的不明原因整到线性。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n;\n    long long res = 0, s = 0;\n    std::cin &gt;&gt; n;\n    std::vector&lt;int&gt; a(n + 1), b(n + 1), t(n + 1), ne(n + 1), to(n + 1);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; t[i] &gt;&gt; a[i] &gt;&gt; b[i];\n        t[i] = (res + t[i]) % n;\n        if (i == 1)\n            s += b[i], res = (long long)a[i] * b[i];\n        else &#123;\n            int j = ne[i - 1];\n            for (; j &amp;&amp; t[j + 1] != t[i]; j = ne[j]);\n            if (t[j + 1] == t[i])\n                ++j;\n            ne[i] = j;\n            if (t[i] == t[1])\n                s += b[i];\n            to[i - 1] = (t[ne[i - 1] + 1] == t[i] ? to[ne[i - 1]] : ne[i - 1]);\n            for (int j = i - 1; j; )\n                if (t[j + 1] == t[i])\n                    j = to[j];\n                else\n                    for (int at = to[j]; j != at; s -= b[i - j], j = ne[j]);\n            res += a[i] * s;\n        &#125;\n        std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"c.-matching\">C. Matching</h2>\n<p><a href=\"https://www.becoder.com.cn/contest/5658/problem/3\" class=\"uri\">https://www.becoder.com.cn/contest/5658/problem/3</a></p>\n<p>我们发现，如果我们直接要 check 一段 <span class=\"math inline\">\\(a\\)</span> 和 <span class=\"math inline\">\\(p\\)</span>，感觉不太好整。</p>\n<p>然后考虑这么一个问题，假如我们通过神秘方法让我们每次 check 的 <span class=\"math inline\">\\(a\\)</span></p>\n",
            "tags": [
                "哈希",
                "线段树",
                "KMP",
                "border"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20221010/",
            "url": "https://xsc062.netlify.app/20221010/",
            "title": "解题报告：博弈",
            "date_published": "2022-10-10T14:31:28.000Z",
            "content_html": "<p>老题解批量补档。</p>\n<span id=\"more\"></span>\n<hr />\n<h2 id=\"博弈\">博弈</h2>\n<blockquote>\n<p>给定一棵带权树，将 <span class=\"math inline\">\\((u,v)\\)</span> 间简单路径上的边权生成数组，两个人在数组中轮流选数，每次选走的数必须 <span class=\"math inline\">\\(\\le\\)</span> 上一个人选走的数，不能选的人输，问有多少个 <span class=\"math inline\">\\((u,v)\\)</span> 满足先手必胜。</p>\n</blockquote>\n<p>如果在 <span class=\"math inline\">\\((u, v)\\)</span> 的路径上有任何一种边权的数量是奇数，那么就要统计 <span class=\"math inline\">\\((u,v)\\)</span>。</p>\n<p>对于最小的、出现次数为奇数的边权 <span class=\"math inline\">\\(w\\)</span>，先手选择 <span class=\"math inline\">\\(w\\)</span>，此时剩下偶数个可选项。后手选择 <span class=\"math inline\">\\(w&#39;\\)</span>，这会删除 <span class=\"math inline\">\\(&gt;w&#39;\\)</span> 且 <span class=\"math inline\">\\(\\le w\\)</span> 的所有可选项。发现被删掉偶数个选项；剩下奇数个选项。易知先手必胜。</p>\n<p>若不存在出现次数为奇数的边权，从刚刚后手的处境可以看出先手必败。所以，问题就转化为了：统计点对 <span class=\"math inline\">\\((u, v)\\)</span> 的数量，满足 <span class=\"math inline\">\\(u\\)</span> 到 <span class=\"math inline\">\\(v\\)</span> 的简单路径中存在出现次数为奇数的边权。</p>\n<p>给每个边权映射一个值，为 <code>base</code> 的 <code>rand()</code> 次方，自然溢出即可。然后直接按照之前的操作处理就好了。</p>\n<p>如果一个你想找到类似于 <code>1 ^ 2 ^ 3 = 0</code> 的情况，其出现概率与数字的二进制位数有关。因为 <code>xor</code> 只针对于同一位，结果不会被上一位或下一位干扰，所以每一位出现异或起来为 <span class=\"math inline\">\\(0\\)</span> 的概率是 <span class=\"math inline\">\\(\\dfrac 12\\)</span>。只要我们整点比较强力的 <span class=\"math inline\">\\(k\\)</span> 位二进制数，那么出现以上情况的概率就是 <span class=\"math inline\">\\(2^{-k}\\)</span>。</p>\n<p>那么这个比较强力的 <span class=\"math inline\">\\(k\\)</span> 位二进制数，用比较强力的类字符串哈希生成方式，再使用一个很大很大的随机数替代字符串哈希中表示下标的 <span class=\"math inline\">\\(i\\)</span>，用自然溢出让它显得更加稳妥就好。所以现在我们程序寄掉的概率就是 <span class=\"math inline\">\\(\\dfrac 1{2^{64}}\\)</span>，好事情啊好事情。</p>\n<p>时间复杂度 <span class=\"math inline\">\\(O(n\\log n)\\)</span>，<span class=\"math inline\">\\(\\log n\\)</span> 来源于映射。</p>\n<details>\n<pre class=\"cpp\"><code>namespace XSC062 &#123;\nusing namespace fastIO;\nconst int _p = 13331;\nconst int maxn = 5e5 + 5;\nstruct _ &#123;\n    int v;\n    ull w;\n    _ () &#123;&#125;\n    _ (int v1, ull w1) &#123;\n        v = v1, w = w1;\n    &#125;\n&#125;;\null w;\null f[maxn];\nint T, n, x, y, ans;\nstd::map&lt;ull, int&gt; t;\nstd::map&lt;ull, ull&gt; q;\nstd::vector&lt;_&gt; g[maxn];\ninline void Init(int n) &#123;\n    t.clear();\n    q.clear();\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        f[i] = 0;\n        g[i].clear();\n        g[i].shrink_to_fit();\n    &#125;\n    return;\n&#125;\nvoid DFS(int x, int fa) &#123;\n    ++t[f[x]];\n    for (auto i : g[x]) &#123;\n        if (i.v == fa)\n            continue;\n        f[i.v] = f[x] ^ i.w;\n        DFS(i.v, x);\n    &#125;\n    return;\n&#125;\ninline void add(int x, int y, ull w) &#123;\n    g[x].push_back(_(y, w));\n    return;\n&#125;\ninline ull randint(void) &#123;\n    ull res = rand();\n    res *= rand();\n    res *= rand();\n    return res;\n&#125;\ninline ull qkp(ull x, ull y) &#123;\n    ull res = 1;\n    while (y) &#123;\n        if (y &amp; 1)\n            res *= x;\n        x *= x;\n        y &gt;&gt;= 1;\n    &#125; \n    return res;\n&#125;\nint main() &#123;\n    read(T);\n    srand(time(NULL));\n    while (T--) &#123;\n        read(n);\n        Init(n);\n        ans = n * (n - 1) / 2;\n        for (int i = 1; i &lt; n; ++i) &#123;\n            read(x), read(y), read(w);\n            if (!q.count(w))\n                q[w] = qkp(_p, randint());\n            w = q[w];\n            add(x, y, w), add(y, x, w);\n        &#125;\n        DFS(1, -1);\n        for (auto i : t)\n            ans -= i.second * (i.second - 1) / 2;\n        print(ans, &#39;\\n&#39;);\n    &#125;\n    return 0;\n&#125;\n&#125; // namespace XSC062</code></pre>\n</details>\n",
            "tags": [
                "哈希"
            ]
        }
    ]
}