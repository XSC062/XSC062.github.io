{
    "version": "https://jsonfeed.org/version/1",
    "title": "null • All posts by \"树的重心\" tag",
    "description": "",
    "home_page_url": "https://xsc062.netlify.app",
    "items": [
        {
            "id": "https://xsc062.netlify.app/20250404/",
            "url": "https://xsc062.netlify.app/20250404/",
            "title": "杂题选谈",
            "date_published": "2025-04-04T07:31:09.000Z",
            "content_html": "<p>NOI Linux 2.0，拼尽全力无法战胜。</p>\n<span id=\"more\"></span>\n<p>比方说我试图对我一片狼藉的屏幕进行一个图的截，但是我并不知道 where the so-called <code>$PICTURE</code> is <img src=\"/em/kt.gif\" /></p>\n<hr />\n<p>这场有两个题都用到了 <mark>优先队列</mark> + <mark>最优答案扩展</mark> 的思路，可以记录一下。</p>\n<hr />\n<h2 id=\"a.-序列加法机\">A. 序列加法机</h2>\n<p><a href=\"http://222.180.160.110:61235/contest/6174/problem/1\" class=\"uri\">http://222.180.160.110:61235/contest/6174/problem/1</a></p>\n<p>转化题意可以发现，三个不下降的限制拼起来其实就是没有限制。若令 <span class=\"math inline\">\\(c_i=|a_i-b_i|\\)</span>，则题意转化如下：</p>\n<blockquote>\n<p>给定 <span class=\"math inline\">\\(c_{1\\sim n}\\)</span>，定义一次操作为：</p>\n<ul>\n<li>选择一个 <span class=\"math inline\">\\(x&gt;0\\)</span>，再选择 <span class=\"math inline\">\\(c_i\\ge x\\)</span>，令 <span class=\"math inline\">\\(c_i\\gets c_i-x\\)</span>，并花费 <span class=\"math inline\">\\(x^2\\)</span> 的代价。</li>\n</ul>\n<p>现可进行不超过 <span class=\"math inline\">\\(m\\)</span> 次操作，问将 <span class=\"math inline\">\\(c_i\\)</span> 全部置为 <span class=\"math inline\">\\(0\\)</span> 的最小代价。</p>\n</blockquote>\n<p>有一个比较显然的事情，如果给 <span class=\"math inline\">\\(c_i\\)</span> 分配 <span class=\"math inline\">\\(k\\)</span> 次操作机会，那么每次减去 <span class=\"math inline\">\\(\\dfrac {c_i}k\\)</span> 是最优的。具体地，令 <span class=\"math inline\">\\(p=\\left\\lfloor\\dfrac {c_i}k\\right\\rfloor\\)</span>，那么给 <span class=\"math inline\">\\(k\\)</span> 个中的 <span class=\"math inline\">\\(c_i\\bmod k\\)</span> 分配 <span class=\"math inline\">\\(p+1\\)</span>，给剩余的 <span class=\"math inline\">\\(k-c_i\\bmod k\\)</span> 分配 <span class=\"math inline\">\\(p\\)</span> 即可。这个随便用反证什么的证一下即可。</p>\n<p>但是我们怎么知道应该给每个 <span class=\"math inline\">\\(c_i\\)</span> 分配多少次操作次数呢？这里有个 trick：初始先给每个 <span class=\"math inline\">\\(c_i\\)</span> 分配一次次数，<mark>对于每个 <span class=\"math inline\">\\(c_i\\)</span>，记录给其多分配一次后能减少的代价，全部丢进优先队列里，将最优的拿出来之后，记录再给其多分配一次后能减少的代价，再丢进去</mark>。能这样做的根本原因在于：</p>\n<ol type=\"1\">\n<li>每个元素的每一次扩展代价相同。</li>\n<li>对于同一个元素，丢到优先队列里的值是递减的（即无后效性，可以贪心）。</li>\n</ol>\n<details>\n<p>有人对着对的代码调了半个小时，是谁呢 <img src=\"/em/kt.gif\" /></p>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 998244353;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n    std::freopen(&quot;seq.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;seq.out&quot;, &quot;w&quot;, stdout);\n#else\n    std::freopen(&quot;ex_seq2.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, m;\n    std::cin &gt;&gt; n &gt;&gt; m;\n    std::vector&lt;long long&gt; c(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; c[i];\n    struct _ &#123;\n        int k;\n        long long org, d;\n        bool operator&lt; (const _ &amp;q) const &#123;\n            return d &lt; q.d; \n        &#125;\n    &#125;;\n    std::priority_queue&lt;_&gt; q;\n    long long res = 0ll;\n    auto calc = [&amp;](long long x, int k) &#123;\n        auto p = x / k;\n        return (x % k) * (p + 1) * (p + 1) + (k - x % k) * p * p;\n    &#125;;\n    for (int i = 1, x; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; x;\n        c[i] = std::abs(c[i] - x);\n        if (c[i]) &#123;\n            (res += calc(c[i], 1) % mod) %= mod;\n            q.push(&#123; 2, c[i], calc(c[i], 1) - calc(c[i], 2) &#125;);\n        &#125;\n    &#125;\n    // printf(&quot;res = %lld\\n&quot;, res);\n    if ((int)q.size() &gt; m)\n        std::cout &lt;&lt; -1 &lt;&lt; &#39;\\n&#39;;\n    else &#123;\n        m -= (int)q.size();\n        for (; m--; ) &#123;\n            auto [k, org, d] = q.top();\n            q.pop();\n            // printf(&quot;org = %lld, k = %d, d = %lld\\n&quot;, org, k, d);\n            (res += mod - d % mod) %= mod;\n            q.push(&#123; k + 1, org, calc(org, k) - calc(org, k + 1) &#125;);\n        &#125;\n        std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"b.-摸鱼军训\">B. 摸鱼军训</h2>\n<p><a href=\"http://222.180.160.110:61235/contest/6174/problem/2\" class=\"uri\">http://222.180.160.110:61235/contest/6174/problem/2</a></p>\n<blockquote>\n<p>定义一次冒泡排序为：</p>\n<pre class=\"cpp\"><code>for (int i = 1; i &lt; n; ++i)\n    if (a[i] &gt; a[i + 1])\n        std::swap(a[i], a[i + 1]);</code></pre>\n<p>现给定一个排列和 <span class=\"math inline\">\\(m\\)</span> 次询问，问第 <span class=\"math inline\">\\(k\\)</span> 轮冒泡排序后元素 <span class=\"math inline\">\\(x\\)</span> 的位置。</p>\n</blockquote>\n<p>发现一个元素移动的原因有两种：</p>\n<ol type=\"1\">\n<li>前面有个比它大的元素「冒泡」到它后面去了，本轮该元素向前移动恰好一步。</li>\n<li>前面没有比它更大的元素，轮到它来向后面「冒泡」了。找到具体的位置是不容易的，但我们发现每次 <span class=\"math inline\">\\(i\\)</span> 向右移动一步，都一定会有一个比 <span class=\"math inline\">\\(i\\)</span> 更小的元素被它交换到 <span class=\"math inline\">\\(i\\)</span> 左边。找到有多少个在 <span class=\"math inline\">\\(i\\)</span> 右边且比 <span class=\"math inline\">\\(i\\)</span> 小的元素到了 <span class=\"math inline\">\\(i\\)</span> 左边就可以得到这一种情况下 <span class=\"math inline\">\\(i\\)</span> 的位置。</li>\n</ol>\n<p>容易发现，只要前面存在比它大的元素，那么第一条始终成立。树状数组统计 <span class=\"math inline\">\\(f_i\\)</span> 为元素 <span class=\"math inline\">\\(i\\)</span> 前比它大的元素个数，对于询问 <span class=\"math inline\">\\((k,i)\\)</span>，若 <span class=\"math inline\">\\(k\\le f_i\\)</span>，那么答案即为 <span class=\"math inline\">\\(pos_i-k\\)</span>。</p>\n<p>第 <span class=\"math inline\">\\(f_i+1\\)</span> 轮，<span class=\"math inline\">\\(i\\)</span> 向后「冒泡」，碰到一个比它更大的元素 <span class=\"math inline\">\\(j\\)</span> 即停止，此时 <span class=\"math inline\">\\(j\\)</span> 接替 <span class=\"math inline\">\\(i\\)</span> 向后「冒泡」，直到碰到一个 <span class=\"math inline\">\\(j&#39;&gt;j\\)</span> 为止，以此类推。</p>\n<p>如何将 <span class=\"math inline\">\\(k\\)</span> 轮后 <span class=\"math inline\">\\(i\\)</span> 停下的位置对应到原数组上呢？我们发现每一轮 <span class=\"math inline\">\\(i\\)</span> 跨越的元素一定是比 <span class=\"math inline\">\\(i\\)</span> 小的可空极长段，手玩可以发现段的数量不会因为 <span class=\"math inline\">\\(i\\)</span> 之后任何元素的移动而改变，故找到 <span class=\"math inline\">\\(i\\)</span> 后第 <span class=\"math inline\">\\(k\\)</span> 个比 <span class=\"math inline\">\\(i\\)</span> 大的元素，中间比 <span class=\"math inline\">\\(i\\)</span> 小的元素个数就是 <span class=\"math inline\">\\(i\\)</span> 的右移步数。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n    std::freopen(&quot;bubble.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;bubble.out&quot;, &quot;w&quot;, stdout);\n    int n, m;\n    std::cin &gt;&gt; n;\n    std::vector&lt;int&gt; a(n + 1), bit(n + 1), p(n + 1), f(n + 1), bit1(n + 1);\n    auto lowbit = [&amp;](int x) &#123;\n        return x &amp; -x;\n    &#125;;\n    auto add = [&amp;](std::vector&lt;int&gt; &amp;bit, int x, int v) &#123;\n        for (; x &lt;= n; x += lowbit(x))\n            bit[x] += v;\n        return;\n    &#125;;\n    auto qry = [&amp;](std::vector&lt;int&gt; &amp;bit, int x) &#123;\n        int res = 0;\n        for (; x; x -= lowbit(x))\n            res += bit[x];\n        return res;\n    &#125;;\n    auto ask = [&amp;](std::vector&lt;int&gt; &amp;bit, int l, int r) &#123;\n        if (l &gt; n || r &lt; 1)\n            return 0;\n        return qry(bit, r) - qry(bit, l - 1);\n    &#125;;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; a[i], p[a[i]] = i;\n        f[a[i]] = ask(bit, a[i] + 1, n), add(bit, a[i], 1);\n    &#125;\n    struct _ &#123; int k, id; &#125;;\n    std::vector&lt;std::vector&lt;_&gt; &gt; t(n + 1);\n    std::cin &gt;&gt; m;\n    std::vector&lt;int&gt; res(m + 1);\n    for (int i = 1, x, k; i &lt;= m; ++i) &#123;\n        std::cin &gt;&gt; k &gt;&gt; x;\n        t[x].push_back(&#123; k, i &#125;);\n    &#125;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        add(bit, p[i], -1);\n        for (auto [k, id] : t[i])\n            if (k &lt;= f[i])\n                res[id] = p[i] - k;\n            else &#123;\n                int now = n;\n                for (int l = p[i] + 1, r = n, mid; l &lt;= r; ) &#123;\n                    mid = (l + r) &gt;&gt; 1;\n                    if (ask(bit, p[i] + 1, mid) &gt;= k - f[i])\n                        r = mid - 1, now = mid;\n                    else\n                        l = mid + 1;\n                &#125;\n                // printf(&quot;%d: now = %d\\n&quot;, i, now);\n                res[id] = p[i] - f[i] + ask(bit1, p[i] + 1, now);\n            &#125;\n        add(bit1, p[i], 1);\n    &#125;\n    for (int i = 1; i &lt;= m; ++i)\n        std::cout &lt;&lt; res[i] &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"c0.-超级钢琴\">C0. 超级钢琴</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P2048\" class=\"uri\">https://www.luogu.com.cn/problem/P2048</a></p>\n<p>首先做前缀和，容易想到枚举右端点，那么左端点就是一段连续的区间。显然在这里最优选择是选择左端点中 <span class=\"math inline\">\\(s\\)</span> 最小的一个。</p>\n<p>怎么求前 <span class=\"math inline\">\\(k\\)</span> 大呢？这里有一个很固定的 trick：把每个右端点及其对应的左端点区间丢到优先队列里，按照最优解（用 ST 表找一下即可）从优到劣排序。</p>\n<p><mark>每次取出最优解 <span class=\"math inline\">\\([l_1, l_2], r\\)</span>，假设最优决策为 <span class=\"math inline\">\\(x\\in [l_1, l_2]\\)</span>，那么把 <span class=\"math inline\">\\([l_1, x), r\\)</span> 和 <span class=\"math inline\">\\((x, l_2], r\\)</span> 分别丢到优先队列里去</mark>。这个做法成立的根本原因也是：</p>\n<ol type=\"1\">\n<li>任何一个元素都可以贡献一次答案。</li>\n<li>对于同一个 <span class=\"math inline\">\\(r\\)</span>，随着拆分次数的增加，最优解逐渐变劣（无后效性，可贪心）。</li>\n</ol>\n<details>\n<pre class=\"cpp language-cpp\" data-line=\"17\"><code class=\"cpp langauage-cpp\">#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(\".in\", \"r\", stdin);\n    std::freopen(\".out\", \"w\", stdout);\n#endif\n    int n, k, l, r;\n    std::cin >> n >> k >> l >> r;\n    std::vector&lt;long long> a(n + 1);\n    std::vector&lt;std::vector&lt;long long> > st(21, std::vector&lt;long long> (n + 1));\n    for (int i = 1; i <= n; ++i)\n        std::cin >> a[i], st[0][i] = i;\n    std::partial_sum(a.begin() + 1, a.end(), a.begin() + 1);\n    for (int j = 1; (1 << j) <= n + 1; ++j) // 一个优秀的笑话是，你的 ST 表需要从 0 开始。而长度自然也应该为 n + 1。\n        for (int i = 0; i + (1 << j) - 1 <= n; ++i)\n            st[j][i] = (a[st[j - 1][i]] <= a[st[j - 1][i + (1 << (j - 1))]] ? st[j - 1][i] : st[j - 1][i + (1 << (j - 1))]);\n    auto ask = [&](int l, int r) &#123;\n        int k = std::__lg(r - l + 1);\n        return a[st[k][l]] <= a[st[k][r - (1 << k) + 1]] ? st[k][l] : st[k][r - (1 << k) + 1];\n    &#125;;\n    struct _ &#123;\n        int l1, l2, r, x;\n        long long v;\n        bool operator< (const _ &q) const &#123;\n            return v < q.v;\n        &#125;\n    &#125;;\n    std::priority_queue<_> q;\n    for (int i = l; i <= n; ++i) &#123;\n        _ t;\n        t.l1 = std::max(i - r, 0), t.l2 = i - l, t.r = i, t.x = ask(t.l1, t.l2), t.v = a[i] - a[t.x];\n        q.push(t);\n    &#125;\n    long long res = 0ll;\n    for (int to; k--; ) &#123;\n        auto [l1, l2, r, x, v] = q.top();\n        q.pop();\n        res += v;\n        if (x != l1) &#123;\n            to = ask(l1, x - 1);\n            q.push(&#123; l1, x - 1, r, to, a[r] - a[to] &#125;);\n        &#125;\n        if (x != l2) &#123;\n            to = ask(x + 1, l2);\n            q.push(&#123; x + 1, l2, r, to, a[r] - a[to] &#125;);\n        &#125;\n    &#125;\n    std::cout << res << '\\n';\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"c1.-皮卡丘\">C1. 皮卡丘</h2>\n<p><a href=\"http://222.180.160.110:61235/contest/6174/problem/3\" class=\"uri\">http://222.180.160.110:61235/contest/6174/problem/3</a></p>\n<blockquote>\n<p>给定 <span class=\"math inline\">\\(a_{1\\sim n}\\)</span> 和 <span class=\"math inline\">\\(m\\)</span> 个询问，每次问 <span class=\"math inline\">\\([l, r]\\)</span> 中前 <span class=\"math inline\">\\(k\\)</span> 大 <span class=\"math inline\">\\(a_l-a_r\\)</span> 的和。<span class=\"math inline\">\\(\\sum k\\le 3\\times 10^5\\)</span>。</p>\n</blockquote>\n<p>我们发现不能直接按照上一题的方法来做——每次询问都把 <span class=\"math inline\">\\(len\\)</span> 个元素丢进优先队列是不现实的。但我们似乎忽略了什么——这次的初始最优解是否可以直接在 <span class=\"math inline\">\\([l,r]\\)</span> 上全局求解？</p>\n<p>区间修改操作就是在明示线段树。显然我们可以差分过后线段树上求解最大子段和——不差分也可以照样维护答案，方法差不多。假设现在求得的最优解为 <span class=\"math inline\">\\((x, y)\\)</span>。</p>\n<p>但此时我们没有一个端点是固定的！应该怎样拆分呢？这里又要用到另一个经典的 trick——抽象一个矩阵 <span class=\"math inline\">\\(b_{i,j}=a_i-a_j\\)</span>，那么对于一次询问，可用的 <span class=\"math inline\">\\(b\\)</span> 构成一个三角形：</p>\n<p><img src=\"1.png\" /></p>\n<p>这里需要注意一个点，我们之所以可以通过最大子段和求得最优解是因为矩阵的行号范围和列号范围是一致的（记为情况 1）。除此之外，除了行号和列号完全相离（即 <span class=\"math inline\">\\(l_2&lt;r_1\\)</span>，记为情况 2） 时可以直接用 <span class=\"math inline\">\\(l_{\\max}-r_{\\min}\\)</span> 求解，其他情况都无法简单得到答案。</p>\n<p>也就是说，我们的拆分方式要尽可能地贴近上面两种可求解的情况。幸运地是，直觉地划分可以比较轻松地在初始状态下得到一种可能的方式：</p>\n<p><img src=\"2.png\" /></p>\n<p>容易注意到初始状态属于情况 1，可以按照图所示，按照行号与 <span class=\"math inline\">\\(x\\)</span> 的大小关系分类，得到：</p>\n<ol type=\"1\">\n<li>行 <span class=\"math inline\">\\(&lt;x\\)</span>，列 <span class=\"math inline\">\\(&lt;x\\)</span>；</li>\n<li>行 <span class=\"math inline\">\\(&lt;x\\)</span>，列 <span class=\"math inline\">\\(\\ge x\\)</span>；</li>\n<li>行 <span class=\"math inline\">\\(=x\\)</span>，列 <span class=\"math inline\">\\(=x\\)</span>；</li>\n<li>行 <span class=\"math inline\">\\(=x\\)</span>，列 <span class=\"math inline\">\\(\\in (x,y)\\)</span>；</li>\n<li>行 <span class=\"math inline\">\\(=x\\)</span>，列 <span class=\"math inline\">\\(&gt;y\\)</span>；</li>\n<li>行 <span class=\"math inline\">\\(&gt;x\\)</span>，列 <span class=\"math inline\">\\(&gt;x\\)</span>。</li>\n</ol>\n<p>几个 part。</p>\n<p>如果我们要对情况 2 进行划分呢？这也是轻松的，假设当前图形满足行： <span class=\"math inline\">\\([l_1, l_2]\\)</span>，列：<span class=\"math inline\">\\([r_1, r_2]\\)</span>（显然这是个完整的矩形），且最优解 <span class=\"math inline\">\\((x, y)\\)</span>。容易发现任意行、列一定相离，故根据 <span class=\"math inline\">\\((x, y)\\)</span> 划分即可：</p>\n<p><img src=\"3.png\" /></p>\n<p>也即以下几个 part：</p>\n<ol type=\"1\">\n<li>行 <span class=\"math inline\">\\(&lt;x\\)</span>；</li>\n<li>行 <span class=\"math inline\">\\(=x\\)</span>，列 <span class=\"math inline\">\\(&lt;y\\)</span>；</li>\n<li>行 <span class=\"math inline\">\\(=x\\)</span>，列 <span class=\"math inline\">\\(&gt;y\\)</span>；</li>\n<li>行 <span class=\"math inline\">\\(&gt;x\\)</span>。</li>\n</ol>\n<p>复杂度 <span class=\"math inline\">\\(O(\\sum k\\log)\\)</span>。注意到线段树的 <span class=\"math inline\">\\(\\log\\)</span> 和优先队列的 <span class=\"math inline\">\\(\\log\\)</span> 并不会叠起来。</p>\n<details>\n<p>意外的很难写 <img src=\"/em/qd.gif\" /></p>\n<p>主要是线段树写起来有点答辩了 <img src=\"/em/kt.gif\" /></p>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int maxn = 1e5 + 5;\nstruct __ &#123;\n    int l, r;\n    int i0, i1, s0, s1;\n    long long u, d, u0, u1;\n    __ operator+ (const __ &amp;q) const &#123;\n        __ res;\n        res.l = l, res.r = q.r, res.d = 0ll;\n        res.u = std::max(&#123; u, q.u, u1 - q.u0 &#125;);\n        if (res.u == u)\n            res.s0 = s0, res.s1 = s1;\n        else if (res.u == q.u)\n            res.s0 = q.s0, res.s1 = q.s1;\n        else\n            res.s1 = i1, res.s0 = q.i0;\n        if (u0 &lt; q.u0)\n            res.u0 = u0, res.i0 = i0;\n        else\n            res.u0 = q.u0, res.i0 = q.i0;\n        if (u1 &gt; q.u1)\n            res.u1 = u1, res.i1 = i1;\n        else\n            res.u1 = q.u1, res.i1 = q.i1;\n        return res;\n    &#125;\n&#125; t[maxn &lt;&lt; 2];\nlong long a[maxn];\n#define lt (p &lt;&lt; 1)\n#define rt (lt | 1)\nvoid pushdown(int p) &#123;\n    if (t[p].d) &#123;\n        t[lt].d += t[p].d, t[rt].d += t[p].d;\n        t[lt].u0 += t[p].d, t[lt].u1 += t[p].d;\n        t[rt].u0 += t[p].d, t[rt].u1 += t[p].d;\n        t[p].d = 0;\n    &#125;\n    return;\n&#125;\nvoid pushup(int p) &#123;\n    t[p] = t[lt] + t[rt];\n    return;\n&#125;\nvoid bld(int p, int l, int r) &#123;\n    t[p].l = l, t[p].r = r;\n    if (l == r) &#123;\n        t[p].i0 = t[p].i1 = t[p].s0 = t[p].s1 = l;\n        t[p].u0 = t[p].u1 = a[l];\n        return;\n    &#125;\n    int mid = (l + r) &gt;&gt; 1;\n    bld(lt, l, mid), bld(rt, mid + 1, r);\n    pushup(p);\n    return;\n&#125;\nvoid add(int p, int l, int r, long long v) &#123;\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r) &#123;\n        t[p].u0 += v, t[p].u1 += v, t[p].d += v;\n        return;\n    &#125;\n    pushdown(p);\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (l &lt;= mid)\n        add(lt, l, r, v);\n    if (r &gt; mid)\n        add(rt, l, r, v);\n    pushup(p);\n    return;\n&#125;\nauto ask(int p, int l, int r) &#123;\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r)\n        return t[p];\n    pushdown(p);\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (r &lt;= mid)\n        return ask(lt, l, r);\n    if (l &gt; mid)\n        return ask(rt, l, r);\n    return ask(lt, l, r) + ask(rt, l, r);\n&#125;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n    std::freopen(&quot;pi.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;pi.out&quot;, &quot;w&quot;, stdout);\n#else\n    std::freopen(&quot;ex_pi2.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int n, m;\n    std::cin &gt;&gt; n &gt;&gt; m;\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i];\n    bld(1, 1, n);\n    for (int op; m--; ) &#123;\n        std::cin &gt;&gt; op;\n        if (op == 1) &#123;\n            int l, r, x;\n            std::cin &gt;&gt; l &gt;&gt; r &gt;&gt; x;\n            add(1, l, r, x);\n        &#125;\n        else &#123;\n            int l, r, k;\n            std::cin &gt;&gt; l &gt;&gt; r &gt;&gt; k;\n            struct _ &#123;\n                int ty, l1, l2, r1, r2, x, y;\n                long long v;\n                bool operator&lt; (const _ &amp;q) const &#123;\n                    return v &lt; q.v;\n                &#125;\n            &#125;;\n            long long res = 0ll;\n            std::priority_queue&lt;_&gt; q;\n            auto calc = [&amp;](int ty, int l1, int l2, int r1, int r2) &#123;\n                if (l1 &lt;= l2 &amp;&amp; r1 &lt;= r2) &#123;\n                    if (ty == 1) &#123;\n                        auto ts(ask(1, l1, l2));\n                        q.push(&#123; 1, l1, l2, r1, r2, ts.s1, ts.s0, ts.u &#125;);\n                    &#125;\n                    else &#123;\n                        auto ls(ask(1, l1, l2)), rs(ask(1, r1, r2));\n                        q.push(&#123; 2, l1, l2, r1, r2, ls.i1, rs.i0, ls.u1 - rs.u0 &#125;);\n                    &#125;\n                &#125;\n                return;\n            &#125;;\n            calc(1, l, r, l, r);\n            for (; k--; ) &#123;\n                auto [ty, l1, l2, r1, r2, x, y, v] = q.top();\n                res += v;\n                q.pop();\n                if (ty == 1) &#123;\n                    calc(1, l1, x - 1, r1, x - 1);\n                    calc(2, l1, x - 1, x, r2);\n                    if (x != y)\n                        calc(1, x, x, x, x);\n                    calc(2, x, x, x + 1, y - 1);\n                    calc(2, x, x, y + 1, r2);\n                    calc(1, x + 1, l2, x + 1, r2);\n                &#125;\n                else &#123;\n                    calc(2, l1, x - 1, r1, r2);\n                    calc(2, x, x, r1, y - 1);\n                    calc(2, x, x, y + 1, r2);\n                    calc(2, x + 1, l2, r1, r2);\n                &#125;\n            &#125;\n            std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n        &#125;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"d.-银行的崛起\">D. 银行的崛起</h2>\n<p><a href=\"http://222.180.160.110:61235/contest/6174/problem/4\" class=\"uri\">http://222.180.160.110:61235/contest/6174/problem/4</a></p>\n<p>原题：<a href=\"https://www.codechef.com/problems/CTREE?tab=statement\">CodeChef CTREE - Chef and Chefcoin</a>。</p>\n<p>假设只需要一个关键点，那么容易想到换根 DP 的做法。但仅凭这个比较 naive 的思路是无法靠近正解的。找题解的时候看到一个惊为天人的式子：<mark><span class=\"math inline\">\\(res=\\sum\\limits_{(u, v): w} f(v)=w\\cdot \\min(s_v,n-s_v)\\)</span>，其中 <span class=\"math inline\">\\(s_v\\)</span> 表示 <span class=\"math inline\">\\(v\\)</span> 的 size</mark>。</p>\n<p>乍一看是在讨论关键点要选在 <span class=\"math inline\">\\(v\\)</span> 外部还是内部，但是 <span class=\"math inline\">\\(\\min\\)</span> 的含义很奇怪——假如有多个点都觉得应该往自己内部走呢？考虑如下普适场景：</p>\n<p><img src=\"4.png\" /></p>\n<p>假如 <span class=\"math inline\">\\(a\\)</span> 和 <span class=\"math inline\">\\(c\\)</span> 都觉得应该往自己内部走，就会有 <span class=\"math inline\">\\(\\begin{cases}a&gt;b+c\\\\c&gt;a+b\\end{cases}\\Rightarrow 0&gt;2\\times b\\)</span>，由此就反证了。</p>\n<p>那么显然 <span class=\"math inline\">\\(f(v)=w\\cdot s_v\\iff s_v\\le \\dfrac n2\\)</span>，转化成带权重心问题，可以 <span class=\"math inline\">\\(O(n)\\)</span> 一次 DFS 解决。那扩展到两个呢？手玩发现存在一条边作为两个选择倾向的点的分界，不会被任何一方经过（显然），枚举这条分割线切断就可以得到两个子树；在子树上分别作一次一个关键点的做法，加起来就是这条边的答案。</p>\n<p>显然这是 <span class=\"math inline\">\\(O(n^2)\\)</span> 的，需要优化。能够感受到枚举边的过程不太能被优化，考虑优化求解上面式子的过程。容易想到换根，记 <span class=\"math inline\">\\(s&#39;\\)</span> 为当前版本时刻变化的 size，<span class=\"math inline\">\\(s\\)</span> 为初始值，那么有：</p>\n<ul>\n<li><span class=\"math inline\">\\(u\\)</span> 侧，对于 <span class=\"math inline\">\\(u\\)</span> 的所有祖先 <span class=\"math inline\">\\(\\{fa\\}\\)</span>，<span class=\"math inline\">\\(s&#39;_{fa}=s_{fa}-s_v\\)</span>，<span class=\"math inline\">\\(n&#39;=n-s_v\\)</span>。</li>\n<li><span class=\"math inline\">\\(v\\)</span> 侧，所有点 <span class=\"math inline\">\\(\\{son\\}\\)</span> 有 <span class=\"math inline\">\\(s&#39;_{son}=s_{son}\\)</span>，<span class=\"math inline\">\\(n&#39;=s_v\\)</span>。</li>\n</ul>\n<p>我们需要维护所有 <span class=\"math inline\">\\(s&#39;\\)</span> 和 <span class=\"math inline\">\\(\\dfrac {n&#39;}2\\)</span> 的大小关系——发现这是一个类似二维偏序的问题，即求：</p>\n<ol type=\"1\">\n<li>DFN 在 <span class=\"math inline\">\\(v\\)</span> 子树范围内，且 <span class=\"math inline\">\\(s\\le \\dfrac {s_v}2\\)</span> 的权值。</li>\n<li>DFN 在 <span class=\"math inline\">\\(v\\)</span> 之前 / 之后，且 <span class=\"math inline\">\\(s\\le \\dfrac {n-s_v}2\\)</span> 的权值。</li>\n</ol>\n<p>记录询问的 DFN 区间，离线（？）下来按照 <span class=\"math inline\">\\(n&#39;\\)</span> 排序，随便用个 DFN 上的 DS 统计一下即可。但 <span class=\"math inline\">\\(u\\)</span> 侧的 <span class=\"math inline\">\\(s&#39;_{fa}\\)</span> 会发生变化，没办法离线处理，考虑<mark>费用提前计算消除误差——找到比 <span class=\"math inline\">\\(\\dfrac {n-s_v}2\\)</span> 大，但减去 <span class=\"math inline\">\\(s_v\\)</span> 后比之小的 <span class=\"math inline\">\\(fa\\)</span> 提前处理</mark>。</p>\n<p><mark>发现由于 <span class=\"math inline\">\\(s\\)</span> 随着 <span class=\"math inline\">\\(fa\\)</span> 往上是单调递增的，满足这个条件的 <span class=\"math inline\">\\(fa\\)</span> 是连续的。</mark>用树上倍增框出上下端点 <span class=\"math inline\">\\((fa_p\\to fa_q]\\)</span> 进行费用提前计算。那么就可以 <span class=\"math inline\">\\(O(n\\log)\\)</span> 的解决问题了。</p>\n<details>\n<p><summary>具体地，如何提前计算？</summary></p>\n<p>记 <span class=\"math inline\">\\(diw_x\\)</span> 为从 <span class=\"math inline\">\\(1\\)</span> 到 <span class=\"math inline\">\\(x\\)</span> 的路径上所有点 <span class=\"math inline\">\\(s\\cdot w\\)</span> 之和。</p>\n<p>那么有：</p>\n<table>\n<colgroup>\n<col style=\"width: 25%\" />\n<col style=\"width: 25%\" />\n<col style=\"width: 25%\" />\n<col style=\"width: 25%\" />\n</colgroup>\n<thead>\n<tr class=\"header\">\n<th style=\"text-align: center;\">项</th>\n<th style=\"text-align: center;\">真实值</th>\n<th style=\"text-align: center;\">计算值</th>\n<th style=\"text-align: center;\"><span class=\"math inline\">\\(\\sum\\Delta\\)</span></th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td style=\"text-align: center;\"><span class=\"math inline\">\\(x\\notin\\{fa\\}\\land x\\notin\\{son\\}\\)</span></td>\n<td style=\"text-align: center;\"><span class=\"math inline\">\\(w_x\\cdot \\min(s_x,n&#39;-s_x)\\)</span></td>\n<td style=\"text-align: center;\"><span class=\"math inline\">\\(w_x\\cdot \\min(s_x,n&#39;-s_x)\\)</span></td>\n<td style=\"text-align: center;\"><span class=\"math inline\">\\(0\\)</span></td>\n</tr>\n<tr class=\"even\">\n<td style=\"text-align: center;\"><span class=\"math inline\">\\(x\\in[1\\to fa_p]\\)</span></td>\n<td style=\"text-align: center;\"><span class=\"math inline\">\\(w_x\\cdot (s_x - s_v)\\)</span></td>\n<td style=\"text-align: center;\"><span class=\"math inline\">\\(w_x\\cdot s_x\\)</span></td>\n<td style=\"text-align: center;\"><span class=\"math inline\">\\(-dis_p\\times s_v\\)</span></td>\n</tr>\n<tr class=\"odd\">\n<td style=\"text-align: center;\"><span class=\"math inline\">\\(x\\in (fa_p\\to fa_q]\\)</span></td>\n<td style=\"text-align: center;\"><span class=\"math inline\">\\(w_x\\cdot (n-s_x)\\)</span></td>\n<td style=\"text-align: center;\"><span class=\"math inline\">\\(w_x\\cdot s_x\\)</span></td>\n<td style=\"text-align: center;\"><span class=\"math inline\">\\(n\\times(dis_q-dis_p)-2\\times (diw_q - diw_p)\\)</span></td>\n</tr>\n<tr class=\"even\">\n<td style=\"text-align: center;\"><span class=\"math inline\">\\(x\\in(fa_q,v)\\)</span></td>\n<td style=\"text-align: center;\"><span class=\"math inline\">\\(w_x\\cdot (n-s_x)\\)</span></td>\n<td style=\"text-align: center;\"><span class=\"math inline\">\\(w_x\\cdot (n-s_x-s_v)\\)</span></td>\n<td style=\"text-align: center;\"><span class=\"math inline\">\\(s_v\\cdot (dis_u-dis_q)\\)</span></td>\n</tr>\n<tr class=\"odd\">\n<td style=\"text-align: center;\"><span class=\"math inline\">\\(x\\in \\{son\\}\\)</span></td>\n<td style=\"text-align: center;\"><span class=\"math inline\">\\(w_x\\cdot \\min(s_x,n&#39;-s_x)\\)</span></td>\n<td style=\"text-align: center;\"><span class=\"math inline\">\\(w_x\\cdot \\min(s_x,n&#39;-s_x)\\)</span></td>\n<td style=\"text-align: center;\"><span class=\"math inline\">\\(0\\)</span></td>\n</tr>\n</tbody>\n</table>\n<p>即需将答案 <strong>减去</strong> <span class=\"math inline\">\\(n\\times(dis_q-dis_p)-2\\times (diw_q - diw_p)+s_v\\cdot (dis_u-dis_q-dis_p)\\)</span>。</p>\n</details>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#ifdef ONLINE_JUDGE\n    std::freopen(&quot;banking.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;banking.out&quot;, &quot;w&quot;, stdout);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n#endif\n    int T;\n    for (std::cin &gt;&gt; T; T--; ) &#123;\n        int n;\n        std::cin &gt;&gt; n;\n        std::vector&lt;long long&gt; a(n + 1);\n        long long sw = 0ll;\n        for (int i = 1; i &lt;= n; ++i)\n            std::cin &gt;&gt; a[i], sw += a[i];\n        std::vector&lt;std::vector&lt;std::pair&lt;int, long long&gt; &gt; &gt; g(n + 1);\n        for (int i = 1, x, y, w; i &lt; n; ++i) &#123;\n            std::cin &gt;&gt; x &gt;&gt; y &gt;&gt; w;\n            g[x].emplace_back(y, w), g[y].emplace_back(x, w);\n        &#125;\n        struct _ &#123; int l, r, id; long long v; &#125;;\n        int now = 0;\n        std::vector&lt;_&gt; q;\n        std::vector&lt;int&gt; dfn(n + 1), rfn(n + 1);\n        std::vector&lt;std::vector&lt;int&gt; &gt; f(n + 1, std::vector&lt;int&gt; (21));\n        std::vector&lt;long long&gt; dis(n + 1), diw(n + 1), w(n + 1), res(n + 1), s(n + 1);\n        std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int fa) &#123; // 前置工作\n            dfn[x] = ++now, s[x] = a[x];\n            for (auto [i, tw] : g[x])\n                if (i != fa) &#123;\n                    w[i] = tw;\n                    f[i][0] = x;\n                    for (int j = 1; j &lt;= 20; ++j)\n                        f[i][j] = f[f[i][j - 1]][j - 1];\n                    DFS(i, x);\n                    s[x] += s[i];\n                &#125;\n            rfn[x] = now;\n            return;\n        &#125;;\n        DFS(1, -1);\n        DFS = [&amp;](int x, int fa) &#123;\n            for (auto [i, tw] : g[x])\n                if (i != fa) &#123;\n                    dis[i] = dis[x] + tw;\n                    diw[i] = diw[x] + tw * s[i];\n                    q.push_back(&#123; dfn[i], rfn[i], i, s[i] &#125;);\n                    q.push_back(&#123; 1, dfn[i] - 1, i, sw - s[i] &#125;);\n                    q.push_back(&#123; rfn[i] + 1, n, i, sw - s[i] &#125;);\n                    int p, q;\n                    long long t = (sw - s[i]) / 2;\n                    &#123;   // 找上端点（开的）\n                        p = i;\n                        for (int j = 20; ~j; --j)\n                            if (f[p][j] &amp;&amp; s[f[p][j]] - s[i] &lt;= t)\n                                p = f[p][j];\n                        p = f[p][0];\n                    &#125;\n                    &#123;   // 找下端点（闭的）\n                        q = i;\n                        for (int j = 20; ~j; --j)\n                            if (f[q][j] &amp;&amp; s[f[q][j]] &lt;= t)\n                                q = f[q][j];\n                        q = f[q][0];\n                    &#125;\n                    res[i] -= sw * (dis[q] - dis[p]) - 2 * (diw[q] - diw[p]) + (dis[x] - dis[p] - dis[q]) * s[i];\n                    DFS(i, x);\n                &#125;\n            return;\n        &#125;;\n        DFS(1, -1);\n        std::vector&lt;int&gt; id(n + 1);\n        std::iota(id.begin() + 1, id.end(), 1);\n        std::sort(id.begin() + 1, id.end(), [&amp;](int x, int y) &#123; return s[x] &lt; s[y]; &#125;);\n        std::sort(q.begin(), q.end(), [&amp;](_ x, _ y) &#123; return x.v &lt; y.v; &#125;);\n        std::vector&lt;std::pair&lt;long long, long long&gt; &gt; bit(n + 1);\n        auto lowbit = [&amp;](int x) &#123; return x &amp; -x; &#125;;\n        auto add = [&amp;](int x, std::pair&lt;long long, long long&gt; v) &#123;\n            for (; x &lt;= n; x += lowbit(x))\n                bit[x].first += v.first, bit[x].second += v.second;\n            return;\n        &#125;;\n        auto ask = [&amp;](int x) &#123;\n            std::pair&lt;long long, long long&gt; res;\n            for (; x; x -= lowbit(x))\n                res.first += bit[x].first, res.second += bit[x].second;\n            return res;\n        &#125;;\n        auto j = ++id.begin();\n        for (auto &amp;[l, r, x, v] : q) &#123;\n            for (; j != id.end() &amp;&amp; s[*j] &lt;= v / 2; ++j)\n                add(dfn[*j], &#123; w[*j], s[*j] * w[*j] &#125;);\n            auto ls(ask(l - 1)), rs(ask(r));\n            rs.first -= ls.first, rs.second -= ls.second;\n            res[x] += rs.second;\n        &#125;\n        bit.assign(n + 1, &#123; 0ll, 0ll &#125;);\n        std::reverse(q.begin(), q.end());\n        std::reverse(id.begin(), id.end());\n        j = ++id.begin();\n        for (auto &amp;[l, r, x, v] : q) &#123;\n            for (; j != id.end() &amp;&amp; s[*j] &gt; v / 2; ++j)\n                add(dfn[*j], &#123; w[*j], s[*j] * w[*j] &#125;);\n            auto ls(ask(l - 1)), rs(ask(r));\n            rs.first -= ls.first, rs.second -= ls.second;\n            res[x] += rs.first * v - rs.second;\n        &#125;\n        std::cout &lt;&lt; *std::min_element(res.begin() + 2, res.end()) &lt;&lt; &#39;\\n&#39;;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n",
            "tags": [
                "堆",
                "树的重心"
            ]
        }
    ]
}