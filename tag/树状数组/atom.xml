<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://xsc062.netlify.app</id>
    <title> • Posts by &#34;树状数组&#34; tag</title>
    <link href="https://xsc062.netlify.app" />
    <updated>2025-10-10T00:12:01.000Z</updated>
    <category term="悬线法" />
    <category term="斜率优化" />
    <category term="并查集" />
    <category term="哈希" />
    <category term="DP" />
    <category term="单调队列" />
    <category term="字典树" />
    <category term="二分图" />
    <category term="分治" />
    <category term="计数" />
    <category term="容斥" />
    <category term="CRT / exCRT" />
    <category term="排列组合" />
    <category term="网络流" />
    <category term="二分" />
    <category term="容斥原理" />
    <category term="线段树" />
    <category term="树状数组" />
    <category term="区间 DP" />
    <category term="数据结构" />
    <category term="构造" />
    <category term="Tarjan" />
    <category term="下饭" />
    <category term="李超线段树" />
    <category term="树链剖分" />
    <category term="LCA" />
    <category term="倍增" />
    <category term="鸽巢原理" />
    <category term="数学" />
    <category term="调和级数" />
    <category term="差分" />
    <category term="思维" />
    <category term="树形 DP" />
    <category term="最小生成树" />
    <category term="SAM" />
    <category term="状压" />
    <category term="分块" />
    <category term="可持久化" />
    <category term="笛卡尔树" />
    <category term="高维前缀和" />
    <category term="闲话" />
    <category term="欧拉回路" />
    <category term="长链剖分" />
    <category term="KMP" />
    <category term="border" />
    <category term="随机化" />
    <category term="字符串" />
    <category term="AC 自动机" />
    <category term="SA" />
    <category term="树上差分" />
    <category term="FWT" />
    <category term="堆" />
    <category term="树的重心" />
    <category term="贪心" />
    <category term="均摊" />
    <category term="反悔贪心" />
    <category term="优化建图" />
    <category term="调整法" />
    <category term="博弈论" />
    <category term="DP 优化" />
    <category term="虚树" />
    <category term="点分治" />
    <category term="四边形不等式" />
    <category term="背包" />
    <category term="支配对" />
    <category term="DDP" />
    <category term="CDQ 分治" />
    <category term="猫树" />
    <category term="DP 套 DP" />
    <category term="Kruskal 重构树" />
    <category term="高精度" />
    <category term="最短路" />
    <category term="树套树" />
    <category term="二项式反演" />
    <category term="搜索" />
    <entry>
        <id>https://xsc062.netlify.app/20251010/</id>
        <title>学习笔记：树状数组</title>
        <link rel="alternate" href="https://xsc062.netlify.app/20251010/"/>
        <content type="html">&lt;p&gt;我有一个朋友今天才会树状数组（存疑）&lt;/p&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;
&lt;p&gt;因为到了今天还是不会&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;单点修改区间查询&#34;&gt;单点修改，区间查询&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;树状数组本身是一个多叉树结构。每个点 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 上保存 &lt;span class=&#34;math inline&#34;&gt;\([i-\text{lowbit}(i)+1,i]\)&lt;/span&gt; 的和，并指向若干个更小的子区间（彼此不重，且拼起来是自身）&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&#34;image-1.png&#34; alt=&#34;图源 OI Wiki&#34; /&gt;&lt;figcaption&gt;图源 OI Wiki&lt;/figcaption&gt;
&lt;/figure&gt;&lt;/li&gt;
&lt;li&gt;修改 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt;：从包含 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 的最低点（id 为 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 且右端点为 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt;）一直向上修改包含 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 的区间。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;查询 &lt;span class=&#34;math inline&#34;&gt;\([1, x]\)&lt;/span&gt;：从右端点为 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 的区间（id 为 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt;）出发，不断找到前方紧邻的区间（&lt;span class=&#34;math inline&#34;&gt;\(id\)&lt;/span&gt; 差为 lowbit），累加进答案。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;区间修改单点查询&#34;&gt;区间修改，单点查询&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;运用序列问题上的技巧，转化为差分数组上的单点修改、前缀查询。&lt;/li&gt;
&lt;li&gt;事实上除了基本结构以外的内容，树状数组本身并没有参与，只需当作&lt;strong&gt;一个输入单点修改，输出前缀和的黑盒&lt;/strong&gt;即可。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;区间修改区间查询&#34;&gt;区间修改，区间查询&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;考虑沿用差分的方法实现区间修改。考虑数学推导表达区间前缀和。&lt;/p&gt;
&lt;p&gt;已知 &lt;span class=&#34;math inline&#34;&gt;\(d_i=a_i-a_{i-1}\)&lt;/span&gt;，则：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
\begin{aligned}
\sum\limits_{i=1}^x a_i=&amp;amp;\sum\limits_{i=1}^x\sum_{j=1}^i d_j\\
=&amp;amp;\sum\limits_{i=1}^x d_i\cdot (x-i+1)\\
=&amp;amp;(x+1)\cdot \left(\sum\limits_{i=1}^x d_i\right) - \left(\sum\limits_{i=1}^x i\cdot d_i\right)
\end{aligned}
\]&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;故只需要在黑盒中维护 &lt;span class=&#34;math inline&#34;&gt;\(d_i\)&lt;/span&gt; 和 &lt;span class=&#34;math inline&#34;&gt;\(i\cdot d_i\)&lt;/span&gt; 的单点修改即可。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在实现时感到违和：对 &lt;span class=&#34;math inline&#34;&gt;\([l, r]\)&lt;/span&gt; 做区间修改时，对于 &lt;span class=&#34;math inline&#34;&gt;\(l\)&lt;/span&gt; 处的 &lt;span class=&#34;math inline&#34;&gt;\(i\cdot d_i\)&lt;/span&gt; 作出了 &lt;span class=&#34;math inline&#34;&gt;\(l\cdot \Delta\)&lt;/span&gt; 的修改，为何在 &lt;span class=&#34;math inline&#34;&gt;\(r+1\)&lt;/span&gt; 处作 &lt;span class=&#34;math inline&#34;&gt;\((r + 1)\cdot \Delta\)&lt;/span&gt; 的修改（而非也是 &lt;span class=&#34;math inline&#34;&gt;\(l\cdot \Delta\)&lt;/span&gt;？）&lt;/p&gt;
&lt;p&gt;事实上，对于 &lt;span class=&#34;math inline&#34;&gt;\(i\cdot d_i\)&lt;/span&gt; 的修改是对 &lt;span class=&#34;math inline&#34;&gt;\(d_i\)&lt;/span&gt; 修改的字面反映，这个量本身并没有具体的含义。&lt;/p&gt;
&lt;p&gt;感觉有点唐唐的，也就只有我会有这种疑惑了……&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;excercise&#34;&gt;Excercise&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;维护 &lt;span class=&#34;math inline&#34;&gt;\(a_i\)&lt;/span&gt; 的区间加、&lt;span class=&#34;math inline&#34;&gt;\(a_i\)&lt;/span&gt; 的区间和查询、&lt;span class=&#34;math inline&#34;&gt;\(i\cdot a_i\)&lt;/span&gt; 的区间和查询。&lt;/p&gt;
&lt;p&gt;令 &lt;span class=&#34;math inline&#34;&gt;\(d_i=a_i-a_{i-1}\)&lt;/span&gt;，考虑变形：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
\begin{aligned}
\sum\limits_{i=1}^x i\cdot a_i=&amp;amp;\sum\limits_{i=1}^xi\cdot \sum_{j=1}^i d_j\\
=&amp;amp;\sum\limits_{i=1}^x d_i\cdot \left(i+(i+1)+\cdots +x\right)\\
=&amp;amp;\sum\limits_{i=1}^x d_i\cdot \dfrac {(x+i)\cdot (x-i+1)}2\\
=&amp;amp;\sum\limits_{i=1}^x d_i\cdot \dfrac {x^2+x-i^2+i}2\\
=&amp;amp;\dfrac{(x^2+x)\cdot \left(\sum\limits_{i=1}^x d_i\right) + \left(\sum\limits_{i=1}^x i\cdot d_i\right) - \left(\sum\limits_{i=1}^x i^2\cdot d_i\right)}2
\end{aligned}
\]&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;故只需要在黑盒中维护 &lt;span class=&#34;math inline&#34;&gt;\(d_i\)&lt;/span&gt;、&lt;span class=&#34;math inline&#34;&gt;\(i\cdot d_i\)&lt;/span&gt; 和 &lt;span class=&#34;math inline&#34;&gt;\(i^2\cdot d_i\)&lt;/span&gt; 的单点修改即可。&lt;/p&gt;
&lt;p&gt;见 &lt;a href=&#34;/20251007/#c.-相互抵消&#34;&gt;相互抵消&lt;/a&gt;。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;ex.-北校门外的回忆&#34;&gt;Ex. 北校门外的回忆&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://loj.ac/p/510&#34; class=&#34;uri&#34;&gt;https://loj.ac/p/510&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;定义 &lt;span class=&#34;math inline&#34;&gt;\(\text{lowbit}_K(x)\)&lt;/span&gt; 为 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 在 &lt;span class=&#34;math inline&#34;&gt;\(K\)&lt;/span&gt; 进制下最低非零位的值。有一个异或和树状数组，把原本代码中的 &lt;span class=&#34;math inline&#34;&gt;\(\text{lowbit}_2(x)\)&lt;/span&gt; 全部替换为 &lt;span class=&#34;math inline&#34;&gt;\(\text{lowbit}_K(x)\)&lt;/span&gt;，得到一个正确性和复杂度均错误的『树状数组』，现在给定若干次 &lt;code&gt;add&lt;/code&gt; 和 &lt;code&gt;ask&lt;/code&gt; 操作，你需要输出错误的代码运行的结果。&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(m\le 2\times 10^5\)&lt;/span&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;需要意识到并不是真的要用树状数组模拟这个操作，一边转化一边要想办法把这个错误代码用正常 DS 的操作表述出来。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;add&lt;/code&gt; 的本质是对于非零最低位乘二并进位。手玩可以发现，有的时候『非零最低位』的位置是不变的，有的时候『非零最低位』变成 &lt;span class=&#34;math inline&#34;&gt;\(0\)&lt;/span&gt; 了，就会前移。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;这显然是个 &lt;span class=&#34;math inline&#34;&gt;\(x\to 2x\bmod K\)&lt;/span&gt; 的内向基环树森林，且当存在自环 &lt;span class=&#34;math inline&#34;&gt;\(0\)&lt;/span&gt; 时，一个树中的最大跳跃次数为 &lt;span class=&#34;math inline&#34;&gt;\(\log_2K\)&lt;/span&gt;。&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&#34;image-2.png&#34; alt=&#34;mobai Grisses&#34; /&gt;&lt;figcaption&gt;mobai Grisses&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;故这个时候（即 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 包含了『&lt;span class=&#34;math inline&#34;&gt;\(K\)&lt;/span&gt; 除了 &lt;span class=&#34;math inline&#34;&gt;\(2\)&lt;/span&gt; 之外的因子』时 ）暴力跳即可。对于每一位都这么跳是可以接受的。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(0\)&lt;/span&gt; 不在树中，最终会有一个循环节。不妨把经过的所有点拉出来成为一条链。&lt;/p&gt;
&lt;p&gt;这个时候可以停下来想一想题目给的两个操作是在做什么。显然每个叶子会引导一条无限长的链，则 &lt;code&gt;add&lt;/code&gt; 就是给这个链做了一个后缀加（&lt;span class=&#34;math inline&#34;&gt;\(N\)&lt;/span&gt; 的限制是没影响的），&lt;code&gt;ask&lt;/code&gt; 则是问了 log 个点值。&lt;/p&gt;
&lt;p&gt;则如果这个链真的可以被处理出来，只需要 bit 维护差分即可。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;考虑倍增预处理 &lt;span class=&#34;math inline&#34;&gt;\(f(i,j)\)&lt;/span&gt; 表示 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 走了 &lt;span class=&#34;math inline&#34;&gt;\(2^j\)&lt;/span&gt; 步后到的点，模拟跳 &lt;span class=&#34;math inline&#34;&gt;\(0\)&lt;/span&gt;、倍增跳循环节即可。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;bit-上倍增&#34;&gt;BIT 上倍增&lt;/h2&gt;
&lt;p&gt;更偏数据结构技巧了，也重新回到结构上面。&lt;/p&gt;
&lt;p&gt;对标线段树上二分，缺陷在于能维护的数据限制很大，优势在于常数很小。在出题人刻意只放树状数组过，或者&lt;strong&gt;树套树&lt;/strong&gt;外层为树状数组的时候用处比较明显。&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;冰火战士&#34;&gt;冰火战士&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P6619&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P6619&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定初始为空的二元组数组 &lt;span class=&#34;math inline&#34;&gt;\(A, B\)&lt;/span&gt;。对于阈值 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt;，令 &lt;span class=&#34;math inline&#34;&gt;\(s_A\)&lt;/span&gt; 表示 &lt;span class=&#34;math inline&#34;&gt;\(A\)&lt;/span&gt; 中关键字一 &lt;span class=&#34;math inline&#34;&gt;\(\le k\)&lt;/span&gt; 的元素关键字二之和，&lt;span class=&#34;math inline&#34;&gt;\(s_B\)&lt;/span&gt; 表示 &lt;span class=&#34;math inline&#34;&gt;\(B\)&lt;/span&gt; 中关键字一 &lt;span class=&#34;math inline&#34;&gt;\(\ge k\)&lt;/span&gt; 的元素关键字二之和。&lt;/p&gt;
&lt;p&gt;维护若干次 &lt;span class=&#34;math inline&#34;&gt;\(A,B\)&lt;/span&gt; 的加点、删点操作，每次操作后输出：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;自由选取 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt;，求 &lt;span class=&#34;math inline&#34;&gt;\(\min\{s_A,s_B\}\)&lt;/span&gt; 的最大值。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(m\le 2\times 10^6\)&lt;/span&gt;，&lt;span class=&#34;math inline&#34;&gt;\(V\le 10^9\)&lt;/span&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;不妨考虑固定状态下的询问。容易想到将 &lt;span class=&#34;math inline&#34;&gt;\(A,B\)&lt;/span&gt; 按关键字一&lt;strong&gt;升序排序&lt;/strong&gt;。随着 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 的增大，&lt;span class=&#34;math inline&#34;&gt;\(s_A\)&lt;/span&gt; 是 &lt;span class=&#34;math inline&#34;&gt;\(A\)&lt;/span&gt; 关键字二的前缀和，&lt;span class=&#34;math inline&#34;&gt;\(s_B\)&lt;/span&gt; 是 &lt;span class=&#34;math inline&#34;&gt;\(B\)&lt;/span&gt; 关键字二的后缀和。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;我并不会三分，但题解说因为有平台所以三分做不了。&lt;/p&gt;
&lt;p&gt;但由于最高点同时是交点，可以二分找到最值点。离散化元素后维护此处的前缀和即可。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;容易想到线段树上二分，然而常数太大难以通过。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果改用树状数组呢？树状数组有办法进行类似线段树上二分的操作吗？&lt;/p&gt;
&lt;p&gt;事实上，bit 的结构更适合倍增。其出发点和线段树上二分是相同的，在于规避重复询问。&lt;/p&gt;
&lt;p&gt;假设当前在一个合法位置 &lt;span class=&#34;math inline&#34;&gt;\(p\)&lt;/span&gt;，已经累加到 &lt;span class=&#34;math inline&#34;&gt;\(s\)&lt;/span&gt;，要验证 &lt;span class=&#34;math inline&#34;&gt;\(p+2^k\)&lt;/span&gt;（&lt;span class=&#34;math inline&#34;&gt;\(\text{lowbit}(p+2^k)=2^k\)&lt;/span&gt;）是否仍然合法，仅需 check &lt;span class=&#34;math inline&#34;&gt;\(s+c_{p+2^k}\)&lt;/span&gt; 是否合法（结合树状数组结构想一想）。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;p&gt;其实 Peace 是有点难判的…… 我写了个结构题维护了数量用来判断。&lt;/p&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int m;
    std::cin &amp;gt;&amp;gt; m;
    struct query &amp;#123; int op, k, x, y; &amp;#125;;
    std::vector&amp;lt;query&amp;gt; a(m + 1);
    std::vector&amp;lt;int&amp;gt; l(1);
    for (int i = 1; i &amp;lt;= m; ++i) &amp;#123;
        std::cin &amp;gt;&amp;gt; a[i].op &amp;gt;&amp;gt; a[i].k;
        if (a[i].op == 1) &amp;#123;
            std::cin &amp;gt;&amp;gt; a[i].x &amp;gt;&amp;gt; a[i].y;
            l.push_back(a[i].x);
        &amp;#125;
        else &amp;#123;
            int k = a[i].k;
            a[i].op = -1;
            a[i].k = a[k].k, a[i].x = a[k].x, a[i].y = a[k].y;
        &amp;#125;
    &amp;#125;
    std::sort(l.begin() + 1, l.end());
    l.erase(std::unique(l.begin() + 1, l.end()), l.end());
    int n = (int)l.size();
    std::vector&amp;lt;int&amp;gt; cnt(2);
    std::vector&amp;lt;long long&amp;gt; sum(2);
    struct node &amp;#123;
        int c;
        long long v;
        node(void): c(0), v(0ll) &amp;#123;&amp;#125;
        node(int c1, long long v1): c(c1), v(v1) &amp;#123;&amp;#125;
        node operator+ (const node &amp;amp;q) const &amp;#123;
            return node(c + q.c, v + q.v);
        &amp;#125;
        node operator- (const node &amp;amp;q) const &amp;#123;
            return node(c - q.c, v - q.v);
        &amp;#125;
        node&amp;amp; operator+= (const node q) &amp;#123;
            return *this = *this + q;
        &amp;#125;
        node &amp;amp;operator-= (const node &amp;amp;q) &amp;#123;
            return *this = *this - q;
        &amp;#125;
    &amp;#125;;
    std::vector&amp;lt;std::vector&amp;lt;node&amp;gt; &amp;gt; bit(2, std::vector&amp;lt;node&amp;gt; (n + 1)), s(2, std::vector&amp;lt;node&amp;gt; (n + 1));
    auto lowbit = [&amp;amp;](int x) &amp;#123; return x &amp;amp; -x; &amp;#125;;
    for (int i = 1; i &amp;lt;= m; ++i) &amp;#123;
        a[i].x = std::lower_bound(l.begin() + 1, l.end(), a[i].x) - l.begin() + a[i].k;
        cnt[a[i].k] += a[i].op, sum[a[i].k] += a[i].op * a[i].y;
        s[a[i].k][a[i].x] += node(a[i].op, a[i].op * a[i].y);
        for (int j = a[i].x; j &amp;lt;= n; j += lowbit(j))
            bit[a[i].k][j] += node(a[i].op, a[i].op * a[i].y);
        if (std::min(cnt[0], cnt[1]) == 0)
            std::cout &amp;lt;&amp;lt; &amp;quot;Peace\n&amp;quot;;
        else &amp;#123;
            int p = 0;
            node s0(0, 0ll), s1(cnt[1], sum[1]);
            for (int i = 20; ~i; --i)
                if (p + (1 &amp;lt;&amp;lt; i) &amp;lt;= n &amp;amp;&amp;amp; (s0 + bit[0][p + (1 &amp;lt;&amp;lt; i)]).v &amp;lt;= (s1 - bit[1][p + (1 &amp;lt;&amp;lt; i)]).v)
                    p += (1 &amp;lt;&amp;lt; i), s0 += bit[0][p], s1 -= bit[1][p];
            if (p + 1 &amp;lt;= n &amp;amp;&amp;amp; s1.c != s[1][p + 1].c &amp;amp;&amp;amp; (s1 - s[1][p + 1]).v &amp;gt;= s0.v) &amp;#123;
                s1 -= s[1][p + 1], s0 = node(cnt[1], sum[1]), p = 0;
                for (int i = 20; ~i; --i)
                    if (p + (1 &amp;lt;&amp;lt; i) &amp;lt;= n &amp;amp;&amp;amp; (s0 - bit[1][p + (1 &amp;lt;&amp;lt; i)]).v &amp;gt;= s1.v)
                        p += (1 &amp;lt;&amp;lt; i), s0 -= bit[1][p];
                std::cout &amp;lt;&amp;lt; l[p] &amp;lt;&amp;lt; &amp;#39; &amp;#39; &amp;lt;&amp;lt; 2 * s1.v &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
            &amp;#125;
            else if (s0.c)
                std::cout &amp;lt;&amp;lt; l[p] &amp;lt;&amp;lt; &amp;#39; &amp;#39; &amp;lt;&amp;lt; 2 * s0.v &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
            else
                std::cout &amp;lt;&amp;lt; &amp;quot;Peace\n&amp;quot;;
        &amp;#125;
    &amp;#125;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;sails-船帆&#34;&gt;sails 船帆&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/P4647&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/P4647&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;需要意识到&lt;strong&gt;帆的顺序对答案没有影响，同一行帆的个数对答案有影响&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;从这一点出发会有一个比较显然的贪心：把柱状图斜过来，把柱子按 &lt;span class=&#34;math inline&#34;&gt;\(h\)&lt;/span&gt; 从小到大&lt;strong&gt;排序&lt;/strong&gt;，问题变为对于第 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 次操作，选 &lt;span class=&#34;math inline&#34;&gt;\(1\sim h_i\)&lt;/span&gt; 里最矮的几列使其高度 +1。&lt;/p&gt;
&lt;p&gt;其实会有一些其他的贪心方法，比如我一开始想的是不排序，在 &lt;span class=&#34;math inline&#34;&gt;\(1\sim h_i\)&lt;/span&gt; 内，优先使最矮的高度 +1，高度相同的使编号更大的柱子高度 +1。这个的正确性也比较好证明，但是太复杂了，没什么好的优化。&lt;strong&gt;把贪心策略中的偏序关系提前到一次排序&lt;/strong&gt;就会简单很多。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;现在需要找到最矮的这几列。&lt;del&gt;我会文艺平衡树&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;考虑更加天才的做法。如果我们需要用 bit，线段树这样的结构来维护操作，就会有一些问题： 为了快速修改，需要保证修改的元素是连续的。简单的方法是让元素有序地在 ds 中排列。但修改操作本身会破坏这样的偏序关系。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;不妨假设元素降序排列（和后方的 0 衔接），那么需要把 &lt;span class=&#34;math inline&#34;&gt;\([h-k+1,h]\)&lt;/span&gt; 这段元素 +1，但这会造成部分元素的前移，考虑前移的过程到底发生了什么。&lt;/p&gt;
&lt;p&gt;考虑这样的场景：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;由于 delta 为 1，至多只会有一段数发生这样的前移。&lt;/strong&gt;先 ask 一下 &lt;span class=&#34;math inline&#34;&gt;\(h-k+1\)&lt;/span&gt; 处的值，假设这一段的左右端点为 &lt;span class=&#34;math inline&#34;&gt;\([l,r]\)&lt;/span&gt;，只需要修改 &lt;span class=&#34;math inline&#34;&gt;\([l,l+(r-(h-k+1))]\)&lt;/span&gt; 和 &lt;span class=&#34;math inline&#34;&gt;\([r+1,h]\)&lt;/span&gt; 两段区间即可。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\([l,r]\)&lt;/span&gt; 是可以通过 bit 上倍增求出的。复杂度 &lt;span class=&#34;math inline&#34;&gt;\(O(n\log n)\)&lt;/span&gt;。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;insert&#34;&gt;Insert&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/problem/AT_abc392_f&#34; class=&#34;uri&#34;&gt;https://www.luogu.com.cn/problem/AT_abc392_f&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;维护每个数的位置，相当于给值在 &lt;span class=&#34;math inline&#34;&gt;\([P_i,i-1]\)&lt;/span&gt; 的元素做区间 +1，显然右端点是单增的，那么就转化为上一题。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;买宝石&#34;&gt;买宝石&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.becoder.com.cn/contest/6620/problem/4&#34; class=&#34;uri&#34;&gt;https://www.becoder.com.cn/contest/6620/problem/4&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;见 &lt;a href=&#34;/20251007-1/#买宝石&#34;&gt;树套树&lt;/a&gt;。&lt;/p&gt;
</content>
        <category term="树状数组" />
        <category term="倍增" />
        <updated>2025-10-10T00:12:01.000Z</updated>
    </entry>
    <entry>
        <id>https://xsc062.netlify.app/20251007/</id>
        <title>杂题选谈</title>
        <link rel="alternate" href="https://xsc062.netlify.app/20251007/"/>
        <content type="html">&lt;p&gt;近期模拟赛&lt;/p&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;a.-考试&#34;&gt;A. 考试&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.becoder.com.cn/contest/6624/problem/1&#34; class=&#34;uri&#34;&gt;https://www.becoder.com.cn/contest/6624/problem/1&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(m\)&lt;/span&gt; 道题，分数是一个 &lt;span class=&#34;math inline&#34;&gt;\(m\)&lt;/span&gt; 的排列（初始未知），做对得满分，做错得 0 分&lt;/p&gt;
&lt;p&gt;给定 &lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt; 个人对于这 &lt;span class=&#34;math inline&#34;&gt;\(m\)&lt;/span&gt; 个题的过题情况矩阵，且第 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 个人有一个预期分数 &lt;span class=&#34;math inline&#34;&gt;\(x_i\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;求每到题的分数，使得每个人实际得分与期望的分差的绝对值之和最大。输出该排列。&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(n\le 10,m\le 10^4\)&lt;/span&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;绝对值是贪心一个很大的阻碍&lt;/li&gt;
&lt;li&gt;&lt;p&gt;一个典型的『钦定』型贪心，枚举每个人的绝对值是否取反，就可以得到每个题对应的系数。&lt;/p&gt;
&lt;p&gt;因为『就算错了也不会影响最优解』，所以是对的。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
int main() &amp;#123;
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
    std::freopen(&amp;quot;test.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;test.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    int T;
    for (std::cin &amp;gt;&amp;gt; T; T--; ) &amp;#123;
        int n, m;
        std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
        std::vector&amp;lt;int&amp;gt; s(n + 1);
        for (int i = 1; i &amp;lt;= n; ++i)
            std::cin &amp;gt;&amp;gt; s[i];
        std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; pos(n + 1);
        for (int i = 1; i &amp;lt;= n; ++i)
            for (int j = 1; j &amp;lt;= m; ++j) &amp;#123;
                char t;
                std::cin &amp;gt;&amp;gt; t;
                if (t == &amp;#39;1&amp;#39;)
                    pos[i].push_back(j);
            &amp;#125;
        auto res = 0ll;
        int siz = 1 &amp;lt;&amp;lt; n;
        std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; id(2 * n + 1);
        std::vector&amp;lt;int&amp;gt; cnt(m + 1), ans(m + 1), p(m + 1);
        for (int i = 0; i &amp;lt; siz; ++i) &amp;#123;
            std::fill(cnt.begin() + 1, cnt.end(), 0);
            for (int j = 0; j &amp;lt;= 2 * n; ++j)
                id[j].clear();
            for (int j = 1; j &amp;lt;= n; ++j)
                if ((i &amp;gt;&amp;gt; (j - 1)) &amp;amp; 1)
                    for (auto k : pos[j])
                        ++cnt[k];
                else
                    for (auto k : pos[j])
                        --cnt[k];
            for (int j = 1; j &amp;lt;= m; ++j)
                id[cnt[j] + n].push_back(j);
            for (int i = 2 * n, k = m; ~i; --i)
                for (auto j : id[i])
                    p[j] = k--;
            auto now = 0ll;
            for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
                int sum = 0;
                for (auto j : pos[i])
                    sum += p[j];
                now += std::abs(sum - s[i]);
            &amp;#125;
            if (now &amp;gt;= res)
                res = now, ans = p;
        &amp;#125;
        // std::cout &amp;lt;&amp;lt; res &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
        for (int i = 1; i &amp;lt;= m; ++i)
            std::cout &amp;lt;&amp;lt; ans[i] &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
        std::cout &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    &amp;#125;
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;b.-围棋&#34;&gt;B. 围棋&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.becoder.com.cn/contest/6624/problem/2&#34; class=&#34;uri&#34;&gt;https://www.becoder.com.cn/contest/6624/problem/2&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定 &lt;span class=&#34;math inline&#34;&gt;\(n \times n\)&lt;/span&gt; 的棋盘，上面有黑棋、白棋和空地，定义白棋的『气』为四个方向空地的数量，若一个白棋四连通块中所有白棋的『气』都为 0，则认为这个白棋四连通块中的所有白棋是『死的』。&lt;/p&gt;
&lt;p&gt;现枚举每个棋子，并将其反转颜色，问『死的』白棋数量。操作是独立的。&lt;/p&gt;
&lt;p&gt;3s，&lt;span class=&#34;math inline&#34;&gt;\(n\le 10^3\)&lt;/span&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;分讨题，需要想清楚。首先需要一次 floodfill 完成染色，记录哪些连通块死了。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;若反转黑棋：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;若黑棋自己有气，或和黑棋相连的白棋四连通块有气，那么黑棋自己，以及所有和黑棋相连的白棋四连通块都是活的。&lt;/p&gt;
&lt;p&gt;此时需要找到所有和黑棋相连的，且死了的白棋四连通块的大小，答案需要减去之。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;否则，黑棋自身贡献 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt; 的答案。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;若反转白棋：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;若白棋本身是死的：答案 &lt;span class=&#34;math inline&#34;&gt;\(-1\)&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;否则，需要考虑有多少个原本是活的白棋此时与有气的白棋不连通，这种情况发生当且仅当有气的白棋是被反转的白棋自身，或者被反转的白棋是割点。&lt;/p&gt;
&lt;p&gt;很奇妙的一个想法是建立超级源点，向所有空地连边，再建圆方树，这样这个点的所有儿子就是待求。圆方树并不需要显式地建出来。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;代码：不会&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;c.-相互抵消&#34;&gt;C. 相互抵消&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.becoder.com.cn/contest/6624/problem/3&#34; class=&#34;uri&#34;&gt;https://www.becoder.com.cn/contest/6624/problem/3&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定 &lt;span class=&#34;math inline&#34;&gt;\(a_{1\sim n}\)&lt;/span&gt;，维护 &lt;span class=&#34;math inline&#34;&gt;\(m\)&lt;/span&gt; 次操作：&lt;/p&gt;
&lt;ol type=&#34;1&#34;&gt;
&lt;li&gt;区间加。&lt;/li&gt;
&lt;li&gt;给定 &lt;span class=&#34;math inline&#34;&gt;\(l,r\)&lt;/span&gt;，查询 &lt;span class=&#34;math inline&#34;&gt;\(\left(\sum\limits_{i=l}^r\sum\limits_{j=i}^r ((\sum_{k=i}^j a_k)^2 + (r-l+2)\times(j-i)\times a_i\times a_j)\right) \bmod 998244353\)&lt;/span&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(n,m\le 5\times 10^5\)&lt;/span&gt;，强制在线。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;题目名字是真在降低难度吧，强制在线就排除离线历史和了；猜测询问所求可以化成一个比较简单的东西。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;推一下：&lt;/p&gt;
&lt;p&gt;（省略）&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
=-\left(\sum_{i=l}^r i\cdot a_i\right)^2 + (1-l)(r+1)\left(\sum_{i=l}^r a_i\right)^2+(l+r)\left(\sum_{i=l}^r i\cdot a_i\right)\left(\sum_{i=l}^r a_i\right)
\]&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;故线段树维护 &lt;span class=&#34;math inline&#34;&gt;\(\sum a_i\)&lt;/span&gt; 和 &lt;span class=&#34;math inline&#34;&gt;\(\sum i\cdot a_i\)&lt;/span&gt; 即可。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;/20251010/#excercise&#34;&gt;实际上可以用树状数组维护&lt;/a&gt;。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;p&gt;喜提最优解，不得不说 bit 的速度优势还是很明显的。&lt;/p&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int mod = 998244353; 
const int inv2 = (mod + 1) &amp;gt;&amp;gt; 1;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
    std::freopen(&amp;quot;offset.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;offset.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#else
    std::freopen(&amp;quot;./test/20251008/offset/ex_offset5.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int T, n, q;
    std::cin &amp;gt;&amp;gt; T &amp;gt;&amp;gt; n &amp;gt;&amp;gt; q;
    std::vector&amp;lt;long long&amp;gt; bit(n + 1), bit1(n + 1), bit2(n + 1);
    auto lowbit = [&amp;amp;](int x) &amp;#123;
        return x &amp;amp; -x;
    &amp;#125;;
    auto add = [&amp;amp;](long long x, long long v) &amp;#123;
        auto v1 = x * v % mod, v2 = x * x % mod * v % mod;
        for (; x &amp;lt;= n; x += lowbit(x)) &amp;#123;
            (bit[x] += v) %= mod;
            (bit1[x] += v1) %= mod;
            (bit2[x] += v2) %= mod;
        &amp;#125;
        return;
    &amp;#125;;
    auto ask = [&amp;amp;](long long x) &amp;#123;
        auto res = 0ll, res1 = 0ll, res2 = 0ll;
        for (int i = x; i; i -= lowbit(i))
            (res += bit[i]) %= mod, (res1 += bit1[i]) %= mod, (res2 += bit2[i]) %= mod;
        return std::make_pair(((x + 1) * res + mod - res1) % mod, (x * (x + 1) % mod * res % mod + res1 + mod - res2) * inv2 % mod);
    &amp;#125;;
    for (int i = 1, x; i &amp;lt;= n; ++i)
        std::cin &amp;gt;&amp;gt; x, add(i, x), add(i + 1, mod - x);
    for (int op; q--; ) &amp;#123;
        static auto la = 0ll;
        std::cin &amp;gt;&amp;gt; op;
        if (op == 1) &amp;#123;
            int l, r, d;
            std::cin &amp;gt;&amp;gt; l &amp;gt;&amp;gt; r &amp;gt;&amp;gt; d;
            if (T == 1)
                l ^= la, r ^= la, d ^= la;
            add(l, d), add(r + 1, mod - d);
        &amp;#125;
        else &amp;#123;
            long long l, r;
            std::cin &amp;gt;&amp;gt; l &amp;gt;&amp;gt; r;
            if (T == 1)
                l ^= la, r ^= la;
            auto t1 = ask(r), t2 = ask(l - 1);
            auto res1 = t1.first + mod - t2.first, res2 = t1.second + mod - t2.second;
            la = (mod - res2 * res2 % mod + mod - (l - 1) * (r + 1) % mod * res1 % mod * res1 % mod + (l + r) * res1 % mod * res2 % mod) % mod;
            std::cout &amp;lt;&amp;lt; la &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
        &amp;#125;
    &amp;#125;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;a.-happylovelyeveryday&#34;&gt;A. Happy·Lovely·Everyday!&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.becoder.com.cn/contest/6639/problem/1&#34; class=&#34;uri&#34;&gt;https://www.becoder.com.cn/contest/6639/problem/1&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定一个长为 &lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt; 的 01 序列，可以执行任意次（可以为 &lt;span class=&#34;math inline&#34;&gt;\(0\)&lt;/span&gt;）『把相邻两个数合并为其异或值』的操作，问最终能得到的本质不同的序列个数。&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(n\le 2\times 10^6\)&lt;/span&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;对于一个最终序列，如果认为它是由某个存活元素『吞并』它左侧的连续死亡元素得到的，会发现最终序列中，此处的前缀异或值就是原序列的前缀异或值。&lt;/li&gt;
&lt;li&gt;经典 trick：前缀和可以唯一对应原数组。所以『最终本质不同序列』会和『包含第 &lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt; 个元素的，原序列前缀异或和的本质不同子序列』形成双射。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;统计包含第 &lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt; 个元素的，原序列前缀异或和的本质不同子序列即可。复杂度 &lt;span class=&#34;math inline&#34;&gt;\(O(n)\)&lt;/span&gt;。&lt;/p&gt;
&lt;details&gt;
&lt;p&gt;&lt;summary&gt;How to 本质不同子序列？&lt;/summary&gt;&lt;/p&gt;
&lt;p&gt;令 &lt;span class=&#34;math inline&#34;&gt;\(f_i\)&lt;/span&gt; 表示 DP 到 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt;，且强制选 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 的本质不同子序列数量，记 &lt;span class=&#34;math inline&#34;&gt;\(pre_i\)&lt;/span&gt; 为 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 的前驱（没有则为 &lt;span class=&#34;math inline&#34;&gt;\(0\)&lt;/span&gt;）。令 &lt;span class=&#34;math inline&#34;&gt;\(f_0=1\)&lt;/span&gt;，那么：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
f_i\gets \sum\limits_{j=pre_i}^{i-1} f_{j}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;或，令 &lt;span class=&#34;math inline&#34;&gt;\(f_i\)&lt;/span&gt; 表示 DP 到 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 时（不强制选 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt;）本质不同子序列数量，记 &lt;span class=&#34;math inline&#34;&gt;\(pre_i\)&lt;/span&gt; 为 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 的前驱（没有则为 &lt;span class=&#34;math inline&#34;&gt;\(0\)&lt;/span&gt;）。令 &lt;span class=&#34;math inline&#34;&gt;\(f_0=0\)&lt;/span&gt;，那么：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
f_i=\begin{cases}
2\cdot f_{i-1}+1&amp;amp;pre_i= 0\\
2\cdot f_{i-1}-f_{pre_i-1}&amp;amp;\text{otherwise}
\end{cases}
\]&lt;/span&gt;&lt;/p&gt;
&lt;/details&gt;
&lt;details&gt;
&lt;p&gt;&lt;summary&gt;How to 强制选第 &lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt; 个元素的本质不同子序列？&lt;/summary&gt;&lt;/p&gt;
&lt;p&gt;令 &lt;span class=&#34;math inline&#34;&gt;\(f_i\)&lt;/span&gt; 表示 DP 到 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt;，且强制选 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 的本质不同子序列数量，则答案为：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
\sum\limits_{a_i=a_n} f_i
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;或，令 &lt;span class=&#34;math inline&#34;&gt;\(f_i\)&lt;/span&gt; 表示 DP 到 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt;，且不强制选 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 的本质不同子序列数量，则答案为：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
\sum\limits_{a_i=a_n}\begin{cases}
f_{i-1}+1&amp;amp;pre_i= 0\\
f_{i-1}-f_{pre_i-1}&amp;amp;\text{otherwise}
\end{cases}
\]&lt;/span&gt;&lt;/p&gt;
&lt;/details&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int mod = 998244353;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
    std::freopen(&amp;quot;a.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;a.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#else
    std::freopen(&amp;quot;./test/20251014/a/a1.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int T;
    for (std::cin &amp;gt;&amp;gt; T; T--; ) &amp;#123;
        std::string s;
        std::cin &amp;gt;&amp;gt; s;
        int n = (int)s.length();
        s = &amp;quot;#&amp;quot; + s;
        std::vector&amp;lt;int&amp;gt; a(n + 1);
        for (int i = 1; i &amp;lt;= n; ++i)
            a[i] = a[i - 1] ^ (s[i] - &amp;#39;0&amp;#39;);
        auto res = 0ll;
        std::vector&amp;lt;long long&amp;gt; f(n + 1), la(2);
        for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
            if (la[a[i]])
                f[i] = (2 * f[i - 1] + mod - f[la[a[i]] - 1]) % mod;
            else
                f[i] = (2 * f[i - 1] + 1) % mod;
            if (a[i] == a[n]) &amp;#123;
                if (la[a[i]])
                    res += (f[i - 1] + mod - f[la[a[i]] - 1]) % mod;
                else
                    res += f[i - 1] + 1;
            &amp;#125;
            la[a[i]] = i;
        &amp;#125;
        std::cout &amp;lt;&amp;lt; res % mod &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    &amp;#125;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;b.-敬启致那时的我&#34;&gt;B. 敬启，致那时的我&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.becoder.com.cn/contest/6639/problem/2&#34; class=&#34;uri&#34;&gt;https://www.becoder.com.cn/contest/6639/problem/2&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;定义 &lt;span class=&#34;math inline&#34;&gt;\(f_0=f_1=1,f_i=f_{i-1}+f_{i-2}\)&lt;/span&gt;，给定 &lt;span class=&#34;math inline&#34;&gt;\(n,k\)&lt;/span&gt;，求：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
\left(\sum_{i=0}^n f_{i}\cdot [\text{popcount}(i)=k]\right)\bmod 10^9+7
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(n\le 2^{2000},0\le k\le \log_2(n)\)&lt;/span&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;考虑数位 DP，那么需要能够由 &lt;code&gt;...xxx&lt;/code&gt; 向 &lt;code&gt;...0xxx&lt;/code&gt; 和 &lt;code&gt;...1xxx&lt;/code&gt; 转移。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;显然只关心向 &lt;code&gt;...1xxx&lt;/code&gt; 的转移，那么需要再转移 &lt;span class=&#34;math inline&#34;&gt;\(2^{?}\)&lt;/span&gt; 次，记录转移矩阵的 &lt;span class=&#34;math inline&#34;&gt;\(2^{?}\)&lt;/span&gt; 次方即可。&lt;/p&gt;
&lt;p&gt;这一步也可以不用矩阵，而是用斐波那契 &lt;span class=&#34;math inline&#34;&gt;\(f(ab)=...\)&lt;/span&gt; 的性质，但显然二者是等价的，无甚必要&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;根据数位 DP 的实现方式，常数上顺序结构肯定是会吊打递归的。然而并不惯写顺序结构的数位 DP，whatever.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int mod = 1e9 + 7;
struct matrix &amp;#123;
    long long a[2][2];
    matrix() &amp;#123;
        a[0][0] = a[0][1] = a[1][0] = a[1][1] = 0ll;
        return;
    &amp;#125;
    long long* operator[] (const int q) &amp;#123;
        return a[q];
    &amp;#125;
    matrix operator* (matrix &amp;amp;q) const &amp;#123;
        matrix res;
        res[0][0] = (a[0][0] * q[0][0] + a[0][1] * q[1][0]) % mod;
        res[0][1] = (a[0][0] * q[0][1] + a[0][1] * q[1][1]) % mod;
        res[1][0] = (a[1][0] * q[0][0] + a[1][1] * q[1][0]) % mod;
        res[1][1] = (a[1][0] * q[0][1] + a[1][1] * q[1][1]) % mod;
        return res;
    &amp;#125;
    matrix&amp;amp; operator+= (matrix q) &amp;#123;
        if ((a[0][0] += q[0][0]) &amp;gt;= mod) a[0][0] -= mod;
        if ((a[0][1] += q[0][1]) &amp;gt;= mod) a[0][1] -= mod;
        if ((a[1][0] += q[1][0]) &amp;gt;= mod) a[1][0] -= mod;
        if ((a[1][1] += q[1][1]) &amp;gt;= mod) a[1][1] -= mod;
        return *this;
    &amp;#125;
&amp;#125;;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
    std::freopen(&amp;quot;b.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;b.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#else
    std::freopen(&amp;quot;./test/20251014/b/b4.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, k;
    std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; k;
    std::vector&amp;lt;int&amp;gt; up(n);
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        char t;
        std::cin &amp;gt;&amp;gt; t, up[n - i] = t - &amp;#39;0&amp;#39;;
    &amp;#125;
    matrix init, zmat;
    init[0][0] = init[0][1] = 1ll;
    std::vector&amp;lt;matrix&amp;gt; mat(n);
    mat[0][0][1] = mat[0][1][0] = mat[0][1][1] = 1ll;
    for (int i = 1; i &amp;lt; n; ++i)
        mat[i] = mat[i - 1] * mat[i - 1];
    std::vector&amp;lt;std::vector&amp;lt;int&amp;gt; &amp;gt; tag(n, std::vector&amp;lt;int&amp;gt; (k + 1));
    std::vector&amp;lt;std::vector&amp;lt;matrix&amp;gt; &amp;gt; f(n, std::vector&amp;lt;matrix&amp;gt; (k + 1));
    std::function&amp;lt;matrix(int, int, int)&amp;gt; DFS = [&amp;amp;](int x, int k, int fl) &amp;#123;
        if (x == -1) &amp;#123;
            if (k == 0)
                return init;
            return zmat;
        &amp;#125;
        if (!fl &amp;amp;&amp;amp; tag[x][k])
            return f[x][k];
        matrix res = DFS(x - 1, k, fl &amp;amp;&amp;amp; !up[x]);
        if (k &amp;amp;&amp;amp; (!fl || up[x]))
            res += DFS(x - 1, k - 1, fl) * mat[x];
        if (!fl)
            tag[x][k] = 1, f[x][k] = res;
        return res;
    &amp;#125;;
    std::cout &amp;lt;&amp;lt; DFS(n - 1, k, 1)[0][0] &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;c.-lead-to-shine-more&#34;&gt;C. Lead to shine more&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.becoder.com.cn/contest/6639/problem/3&#34; class=&#34;uri&#34;&gt;https://www.becoder.com.cn/contest/6639/problem/3&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;第 &lt;span class=&#34;math inline&#34;&gt;\(0\)&lt;/span&gt; 次操作时变量 &lt;span class=&#34;math inline&#34;&gt;\(x=1\)&lt;/span&gt;，此后每次操作使 &lt;span class=&#34;math inline&#34;&gt;\(x\gets x+\text{popcount}(x)\)&lt;/span&gt;，给定 &lt;span class=&#34;math inline&#34;&gt;\(m\)&lt;/span&gt; 次询问：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;给定 &lt;span class=&#34;math inline&#34;&gt;\(x&amp;#39;\)&lt;/span&gt;，问 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 在第几次操作后变为 &lt;span class=&#34;math inline&#34;&gt;\(x&amp;#39;\)&lt;/span&gt;，或报告 &lt;span class=&#34;math inline&#34;&gt;\(x&amp;#39;\)&lt;/span&gt; 不会被经过。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(m\le 10^5,x&amp;#39;\le 10^{18}\)&lt;/span&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;一个朴素的想法是分高低位，则因为每次操作带来的变化量不超过 60，远远低于低位的 &lt;span class=&#34;math inline&#34;&gt;\(2^30\)&lt;/span&gt;，所以一次操作至多给高位带来 1 的变化量。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;高位对整体的贡献只取决于其 popcount，所以可以枚举高位 1 的数量，再枚举初始值，找到第一次让高位变化花的次数。&lt;/p&gt;
&lt;p&gt;初始值的可能值有 &lt;span class=&#34;math inline&#34;&gt;\(60\)&lt;/span&gt; 个，而外层循环有 &lt;span class=&#34;math inline&#34;&gt;\(30\)&lt;/span&gt; 次，内层循环大概是 &lt;span class=&#34;math inline&#34;&gt;\(\dfrac {2^{30}}{60}\)&lt;/span&gt; 的，总之无法通过。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;题解说方法是对上面的拓展。理解不能。出发点大概是考虑到让第 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 位变化相当于让 &lt;span class=&#34;math inline&#34;&gt;\(i+1\)&lt;/span&gt; 位变化两次，所以会有一个递推的关系。&lt;/p&gt;
&lt;p&gt;令 &lt;span class=&#34;math inline&#34;&gt;\(f_{i, s, d}\)&lt;/span&gt; 为前 &lt;span class=&#34;math inline&#34;&gt;\(i-1\)&lt;/span&gt; 位的 popcount 为 &lt;span class=&#34;math inline&#34;&gt;\(d\)&lt;/span&gt;，初始值为 &lt;span class=&#34;math inline&#34;&gt;\(s\)&lt;/span&gt;，让 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 位变化一次的操作次数；&lt;span class=&#34;math inline&#34;&gt;\(g_{i,s,d}\)&lt;/span&gt; 为上述变化后 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 的值。记 &lt;span class=&#34;math inline&#34;&gt;\(pos=g_{i-1,s,d}\)&lt;/span&gt;，那么有：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
g_{i,pos,d}=g_{i-1,pos,d+1}\\
f_{i,pos,d}=f_{i-1,s,d}+f_{i-1,pos,d+1}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其实是一个类似&lt;strong&gt;倍增&lt;/strong&gt;的结构。但恕我实在无法解释怎么想到的。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;显然这个式子在 &lt;span class=&#34;math inline&#34;&gt;\(i\le 5\)&lt;/span&gt; 时是有问题的，这部分我们暴力跑即可。忽略这一部分常数，预处理总复杂度 &lt;span class=&#34;math inline&#34;&gt;\(O(\log^3 n)\)&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;考虑查询，按照类似数位 DP 的方法从高位到低位模拟进位过程即可。复杂度 &lt;span class=&#34;math inline&#34;&gt;\(O(\log n)\)&lt;/span&gt;。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
int main() &amp;#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
    std::freopen(&amp;quot;c.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;c.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
#else
    std::freopen(&amp;quot;./test/20251014/c/c1.in&amp;quot;, &amp;quot;r&amp;quot;, stdin);
    std::freopen(&amp;quot;.out&amp;quot;, &amp;quot;w&amp;quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    using arr = std::vector&amp;lt;long long&amp;gt;;
    using brr = std::vector&amp;lt;arr&amp;gt;;
    using crr = std::vector&amp;lt;brr&amp;gt;;
    crr f(61, brr(256, arr(61))), g(61, brr(256, arr(61)));
    for (int s = 0; s &amp;lt; 256; ++s)
        for (int d = 0; d &amp;lt;= 60; ++d)
            if (d || s) &amp;#123;
                int x = s, cnt = 0;
                for (; x &amp;lt; 256; x += __builtin_popcount(x) + d, ++cnt);
                f[8][s][d] = cnt, g[8][s][d] = x &amp;amp; 255;
            &amp;#125;
    for (int i = 9; i &amp;lt;= 60; ++i)
        for (int s = 0; s &amp;lt; 256; ++s)
            for (int d = 0; d &amp;lt; 60; ++d) &amp;#123;
                int pos = g[i - 1][s][d];
                g[i][s][d] = g[i - 1][pos][d + 1];
                f[i][s][d] = f[i - 1][s][d] + f[i - 1][pos][d + 1];
            &amp;#125;
    int m;
    std::cin &amp;gt;&amp;gt; m;
    for (long long x; m--; ) &amp;#123;
        std::cin &amp;gt;&amp;gt; x;
        auto pos = 1ll, cnt = 0ll, tot = 0ll;
        for (int i = 60; i &amp;gt;= 8; --i)
            if ((x &amp;gt;&amp;gt; i) &amp;amp; 1) &amp;#123;
                cnt += f[i][pos][tot];
                pos = g[i][pos][tot++];
            &amp;#125;
        for (; pos &amp;lt; (x &amp;amp; 255); pos += __builtin_popcountll(pos) + tot, ++cnt);
        // std::cout &amp;lt;&amp;lt; pos &amp;lt;&amp;lt; &amp;#39; &amp;#39; &amp;lt;&amp;lt; cnt &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
        if (pos == (x &amp;amp; 255))
            std::cout &amp;lt;&amp;lt; cnt &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
        else
            std::cout &amp;lt;&amp;lt; -1 &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
    &amp;#125;
#ifndef ONLINE_JUDGE
    std::cerr &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; std::setprecision(6) &amp;lt;&amp;lt; std::chrono::duration&amp;lt;double&amp;gt; (std::chrono::steady_clock::now() - stime).count() &amp;lt;&amp;lt; &amp;quot;s\n&amp;quot;;
#endif
    return 0;
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;c.-query-on-a-tree-17&#34;&gt;C. Query On A Tree 17&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://codeforces.com/gym/102759/problem/I&#34; class=&#34;uri&#34;&gt;https://codeforces.com/gym/102759/problem/I&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定一个以 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt; 为根的树，点权初始为全 &lt;span class=&#34;math inline&#34;&gt;\(0\)&lt;/span&gt;。维护 &lt;span class=&#34;math inline&#34;&gt;\(m\)&lt;/span&gt; 次修改：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;1 u&lt;/code&gt;，表示把 &lt;span class=&#34;math inline&#34;&gt;\(u\)&lt;/span&gt; 子树内的点权加一。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;2 u v&lt;/code&gt;，表示把 &lt;span class=&#34;math inline&#34;&gt;\(u,v\)&lt;/span&gt; 简单路径上的点权加一。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;每次修改后，输出树深度最小的带权重心。&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(n,m\le 10^5\)&lt;/span&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;考虑链上的问题，考虑一点小奥做法，把所有点重复其出现次数次，从左到右排列，发现答案在中位数上。&lt;/p&gt;
&lt;p&gt;（据组题人所言），这是用来提示正解的。事实上，这是一个和带权重心有关的 trick：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;若一个点 &lt;span class=&#34;math inline&#34;&gt;\(u\)&lt;/span&gt; 是&lt;strong&gt;深度最小的&lt;/strong&gt;带权重心，则其子树权值和必须&lt;strong&gt;严格大于&lt;/strong&gt;总权值的一半。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;证明显然，但结论不显然。Whatever.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;由这一点会得到，（参照链上的做法），把点重复点权次，并按 dfn 排成一行，取中位数，那么取到的一定在&lt;strong&gt;深度最小的&lt;/strong&gt;重心子树内，（这就是组题人说的提示正解）。&lt;/p&gt;
&lt;p&gt;这一点反而没那么显然，推导过程是，&lt;strong&gt;深度最小的&lt;/strong&gt;重心的子树占了大于一半，而其 dfn 又是连续的，（类似滑动窗口），故总能够到中位数。&lt;/p&gt;
&lt;p&gt;考虑非深度最小的重心，此时就从&lt;strong&gt;严格大于&lt;/strong&gt;变为&lt;strong&gt;不严格大于&lt;/strong&gt;，导致没有办法很好地精准找到，需要从中位数左右偏移一位，显然是很丑陋的。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;因此可以考虑线段树上二分找到中位数（容易发现线段树的 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 轴本来就是 dfn），然后从这个中位数往上跳，一直跳到满足『子树权值和严格大于总权值一半』的点，就是最浅的重心。&lt;/p&gt;
&lt;p&gt;这一点采用倍增即可。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
        <category term="DP" />
        <category term="树状数组" />
        <category term="倍增" />
        <category term="贪心" />
        <updated>2025-10-07T08:29:43.000Z</updated>
    </entry>
    <entry>
        <id>https://xsc062.netlify.app/20240106/</id>
        <title>杂题选谈</title>
        <link rel="alternate" href="https://xsc062.netlify.app/20240106/"/>
        <content type="html">&lt;p&gt;想不到好标题了。&lt;/p&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;
&lt;p&gt;有句话怎么说来着，罗马不是一天建成的，是一天天建成的。&lt;/p&gt;
&lt;p&gt;还有什么，Do in Rome as the Romans’ do，还有一句，All roads leads to Rome。&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;a.-连续的零-zero&#34;&gt;A. 连续的零 zero&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.becoder.com.cn/contest/4647/problem/1&#34; class=&#34;uri&#34;&gt;https://www.becoder.com.cn/contest/4647/problem/1&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;做个前缀和，看看任意一个长度为 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 的区间中有几个 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt;。复杂度 &lt;span class=&#34;math inline&#34;&gt;\(O(n)\)&lt;/span&gt;。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;namespace XSC062 &amp;#123;
using namespace fastIO;
const int maxn = 5e5 + 5;
const int inf = 0x3f3f3f3f;
int n, m, res = inf;
int a[maxn], s[maxn];
int min(int x, int y) &amp;#123;
    return x &amp;lt; y ? x : y;
&amp;#125;
int main() &amp;#123;
    scanf(&amp;quot;%d %d&amp;quot;, &amp;amp;n, &amp;amp;m);
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        scanf(&amp;quot;%1d&amp;quot;, &amp;amp;a[i]);
        s[i] = s[i - 1] + a[i];
        if (i &amp;gt;= m)
            res = min(res, s[i] - s[i - m]);
    &amp;#125;
    print(res, &amp;#39;\n&amp;#39;);
    return 0;
&amp;#125;
&amp;#125; // namespace XSC062&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;b.-反回文串-anti&#34;&gt;B. 反回文串 anti&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.becoder.com.cn/contest/4647/problem/2&#34; class=&#34;uri&#34;&gt;https://www.becoder.com.cn/contest/4647/problem/2&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;当 &lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt; 为奇时，中间的元素一定和自己相等，故无解。&lt;/p&gt;
&lt;p&gt;当数量最多的一个字符个数超过 &lt;span class=&#34;math inline&#34;&gt;\(\dfrac n2\)&lt;/span&gt; 时，由鸽巢得无解。&lt;/p&gt;
&lt;p&gt;剩下的情况一定有解。&lt;/p&gt;
&lt;details&gt;
&lt;p&gt;&lt;summary&gt;证明&lt;/summary&gt;&lt;/p&gt;
&lt;p&gt;可以找到一种合法的构造方式。我们列出一个列数为 &lt;span class=&#34;math inline&#34;&gt;\(2\)&lt;/span&gt;，行数为 &lt;span class=&#34;math inline&#34;&gt;\(\dfrac n2\)&lt;/span&gt; 的表格，将所有相同字母排列在一起，按照从左到右，从上到下的方式将字母填入表格，最后将第 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 行第一列的字母填入 &lt;span class=&#34;math inline&#34;&gt;\(a_i\)&lt;/span&gt;，第 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 行第二列的字母填入 &lt;span class=&#34;math inline&#34;&gt;\(a_{n-i+1}\)&lt;/span&gt;，即可完成构造。&lt;/p&gt;
&lt;p&gt;一种字母只在第一列或第二列出现当然合法，如果从第一列持续到第二列，因为任意字母出现次数不超过 &lt;span class=&#34;math inline&#34;&gt;\(\dfrac n2\)&lt;/span&gt; 次，所以同一行的两列不会出现同一种字母。&lt;/p&gt;
&lt;p&gt;这叫什么，有字证明。&lt;/p&gt;
&lt;p&gt;&lt;del&gt;感觉可以拿去出一道类似于「找到字符串字典序最小的反回文串」之类的小水题&lt;/del&gt;&lt;/p&gt;
&lt;/details&gt;
&lt;p&gt;然后现在我们知道有解了，怎么找到最优解呢。&lt;/p&gt;
&lt;p&gt;比如有一组 &lt;span class=&#34;math inline&#34;&gt;\((a_i,a_{n-i+1})=(\texttt a, \texttt a)\)&lt;/span&gt;，还有一组 &lt;span class=&#34;math inline&#34;&gt;\((a_j, a_{n-j+1})=(\texttt b, \texttt b)\)&lt;/span&gt;，那我们直接把 &lt;span class=&#34;math inline&#34;&gt;\(a_i\)&lt;/span&gt; 和 &lt;span class=&#34;math inline&#34;&gt;\(a_j\)&lt;/span&gt; 交换，皆大欢喜。&lt;/p&gt;
&lt;p&gt;这就说明我们需要把值不相等的非法 &lt;span class=&#34;math inline&#34;&gt;\(a_i\)&lt;/span&gt; 与 &lt;span class=&#34;math inline&#34;&gt;\(a_j\)&lt;/span&gt; 配对。&lt;/p&gt;
&lt;p&gt;然后我们就可以沿用证明中的构造方式，分组配对，一定最优，每组代价为 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;同一行两个值 &lt;span class=&#34;math inline&#34;&gt;\(v\)&lt;/span&gt; 相等，因为已经最优了，所以不能再在非法串中寻找答案。应该找合法对中某个值交换，每组代价为 &lt;span class=&#34;math inline&#34;&gt;\(2\)&lt;/span&gt;。具体和谁交换我们不用担心，只要找到一组 &lt;span class=&#34;math inline&#34;&gt;\((a_i,a_{n-i+1})\)&lt;/span&gt; 满足 &lt;span class=&#34;math inline&#34;&gt;\(a_i\ne v\)&lt;/span&gt; 且 &lt;span class=&#34;math inline&#34;&gt;\(a_{n-i+1}\ne v\)&lt;/span&gt; 就可以了，然后我们又知道 &lt;span class=&#34;math inline&#34;&gt;\(v\)&lt;/span&gt; 的个数 &lt;span class=&#34;math inline&#34;&gt;\(\ne \dfrac n2\)&lt;/span&gt;，假设 &lt;span class=&#34;math inline&#34;&gt;\(\dfrac n2\)&lt;/span&gt; 对中每队都有至少一个 &lt;span class=&#34;math inline&#34;&gt;\(v\)&lt;/span&gt;，由于当前这一对有两个相同的 &lt;span class=&#34;math inline&#34;&gt;\(v\)&lt;/span&gt;，那么 &lt;span class=&#34;math inline&#34;&gt;\(v\)&lt;/span&gt; 的个数就会大于 &lt;span class=&#34;math inline&#34;&gt;\(\dfrac n2\)&lt;/span&gt;，矛盾了，所以一定能找到。&lt;/p&gt;
&lt;p&gt;对于非法总对数是奇数的情况，我们要钦定一个非法对强制让其和合法对交换，贪心一下取非法对数量最多的 &lt;span class=&#34;math inline&#34;&gt;\(v\)&lt;/span&gt; 的某一对最优。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;namespace XSC062 &amp;#123;
using namespace fastIO;
const int maxm = 35;
const int maxn = 2e5 + 5;
char s[maxn];
int cnt[maxm], p[maxn];
int T, n, tot, res, now;
int main() &amp;#123;
    scanf(&amp;quot;%d&amp;quot;, &amp;amp;T);
    while (T--) &amp;#123;
        tot = 0;
        scanf(&amp;quot;%d %s&amp;quot;, &amp;amp;n, s + 1);
        if (n &amp;amp; 1) &amp;#123;
            puts(&amp;quot;-1&amp;quot;);
            continue;
        &amp;#125;
        memset(cnt, 0, sizeof (cnt));
        for (int i = 1; i &amp;lt;= n; ++i)
            ++cnt[s[i] - &amp;#39;a&amp;#39; + 1];
        for (int i = 1; i &amp;lt;= 26; ++i) &amp;#123;
            if (cnt[i] * 2 &amp;gt; n) &amp;#123;
                puts(&amp;quot;-1&amp;quot;);
                goto noSol;
            &amp;#125;
        &amp;#125;
        memset(cnt, 0, sizeof (cnt));
        for (int i = 1; i * 2 &amp;lt;= n; ++i) &amp;#123;
            if (s[i] == s[n - i + 1])
                ++cnt[s[i] - &amp;#39;a&amp;#39; + 1], ++tot;
        &amp;#125;
        std::sort(cnt + 1, cnt + 27,
                    std::greater&amp;lt;int&amp;gt;());
        res = now = 0;
        if (tot &amp;amp; 1) &amp;#123;
            res = 1, --cnt[1];
            std::sort(cnt + 1, cnt + 27,
                        std::greater&amp;lt;int&amp;gt;());
        &amp;#125;
        for (int i = 1; i &amp;lt;= 26; ++i) &amp;#123;
            while (cnt[i]--) &amp;#123;
                if (++now &amp;gt; tot / 2) &amp;#123;
                    if (i == p[now - tot / 2])
                        res += 2;
                    else ++res;
                &amp;#125;
                else p[now] = i;
            &amp;#125;
        &amp;#125;
        print(res, &amp;#39;\n&amp;#39;);
        noSol: ;
    &amp;#125;
    return 0;
&amp;#125;
&amp;#125; // namespace XSC062&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;c.-除与减-divsub&#34;&gt;C. 除与减 divsub&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.becoder.com.cn/contest/4647/problem/3&#34; class=&#34;uri&#34;&gt;https://www.becoder.com.cn/contest/4647/problem/3&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;小数学，还好。&lt;/p&gt;
&lt;p&gt;假设 &lt;span class=&#34;math inline&#34;&gt;\(n=d\times k^p\)&lt;/span&gt;，其中 &lt;span class=&#34;math inline&#34;&gt;\(k\nmid d\)&lt;/span&gt;，那么我们分两种情况讨论。&lt;/p&gt;
&lt;ol type=&#34;1&#34;&gt;
&lt;li&gt;&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(p=0\)&lt;/span&gt;，即 &lt;span class=&#34;math inline&#34;&gt;\(k\nmid n\)&lt;/span&gt;，那么 &lt;span class=&#34;math inline&#34;&gt;\(n\bmod k=1\)&lt;/span&gt;，即 &lt;span class=&#34;math inline&#34;&gt;\(k\mid (n-1)\)&lt;/span&gt;。&lt;/p&gt;
这个时候问 &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; 的个数就相当于是在问 &lt;span class=&#34;math inline&#34;&gt;\(n-1\)&lt;/span&gt; 除 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt; 以外的因子个数。假设 &lt;span class=&#34;math inline&#34;&gt;\(n-1={x_1}^{p_1}{x_2}^{p_2}\cdots {x_m}^{p_m}\)&lt;/span&gt;，那么答案为 &lt;span class=&#34;math inline&#34;&gt;\((\prod p_i+1)-1\)&lt;/span&gt;，减去的是 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(p\ne 0\)&lt;/span&gt;，&lt;span class=&#34;math inline&#34;&gt;\(k\mid n\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;这个时候好像并没有什么好的转化。好消息是 &lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt; 的范围是 &lt;span class=&#34;math inline&#34;&gt;\(10^{12}\)&lt;/span&gt;，根号枚举因数复杂度跑得过。所以我们就可以暴力判定 &lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt; 的所有因数是否满足条件。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;时间复杂度，&lt;span class=&#34;math inline&#34;&gt;\(O(\sqrt n\times \log n)\)&lt;/span&gt;，枚举因数是根号，算次数（也就是算 &lt;span class=&#34;math inline&#34;&gt;\(d\)&lt;/span&gt;）是 &lt;span class=&#34;math inline&#34;&gt;\(\log\)&lt;/span&gt;。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#define int long long
namespace XSC062 &amp;#123;
using namespace fastIO;
int n, m, res, cnt;
int main() &amp;#123;
    read(n), m = n;
    for (int i = 2; i * i &amp;lt;= n; ++i) &amp;#123;
        if (n % i == 0) &amp;#123;
            m = n;
            while (m % i == 0) m /= i;
            if (m % i == 1) ++res;
            if (i * i != n) &amp;#123;
                m = n;
                while (m % (n / i) == 0)
                    m /= (n / i);
                if (m % (n / i) == 1) ++res;
            &amp;#125;
        &amp;#125;
    &amp;#125;
    m = n - 1, cnt = 1;
    for (int i = 2; i * i &amp;lt;= m; ++i) &amp;#123;
        if (m % i == 0) &amp;#123;
            int now = 0;
            while (m % i == 0)
                ++now, m /= i;
            cnt *= now + 1;
        &amp;#125;
    &amp;#125;
    if (m != 1) cnt *= 2;
    print(res + cnt, &amp;#39;\n&amp;#39;);
    return 0;
&amp;#125;
&amp;#125; // namespace XSC062
#undef int&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;d.-图书管理员-librarian&#34;&gt;D. 图书管理员 librarian&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.becoder.com.cn/contest/4647/problem/4&#34; class=&#34;uri&#34;&gt;https://www.becoder.com.cn/contest/4647/problem/4&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[SDOI2008] 郁闷的小 J。&lt;/p&gt;
&lt;p&gt;关于这个，我们发现自己不会考场现冲主席树。哎，打 CDQ 又怕写挂。&lt;/p&gt;
&lt;p&gt;我们发现这道题的修改都是单点的，询问也只关于某一种颜色，不同的颜色之间没有影响。&lt;/p&gt;
&lt;p&gt;于是我们可以把操作离线下来，初始视作将某颜色在某位置增加，修改视作将某颜色在某位置删除，将另一颜色在该位置增加，将所有操作按颜色离散化分类然后 &lt;code&gt;vector&lt;/code&gt; 下来，对于所有颜色从前到后树状数组做一遍操作就能 &lt;span class=&#34;math inline&#34;&gt;\(O(n\log n+q\log n)\)&lt;/span&gt; 解决。&lt;/p&gt;
&lt;p&gt;树状数组清空是肯定不能 &lt;code&gt;memset&lt;/code&gt; 的，复杂度不对。那么怎么办呢？把所有操作撤回去就可以了。&lt;/p&gt;
&lt;p&gt;顺带一提我是洛谷上最优解。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;namespace XSC062 &amp;#123;
using namespace fastIO;
const int maxn = 2e5 + 5;
struct __ &amp;#123;
    int ty, l, r, v;
    __() &amp;#123;&amp;#125;
    __(int t1, int l1, int r1, int v1 = 0) &amp;#123;
        if (t1 == 0)
            ty = 0, l = l1, v = r1;
        else ty = 1, l = l1, r = r1, v = v1;
    &amp;#125;
&amp;#125;;
char ty;
std::map&amp;lt;int, int&amp;gt; tab;
std::vector&amp;lt;__&amp;gt; q[maxn];
int n, m, tot, x, y, v, id;
int Bit[maxn], a[maxn], res[maxn];
int lowbit(int x) &amp;#123; return x &amp;amp; -x; &amp;#125;
void add(int x, int v) &amp;#123;
    for (; x &amp;lt;= n; x += lowbit(x))
        Bit[x] += v;
    return;
&amp;#125;
int ask(int x) &amp;#123;
    int res = 0;
    for (; x; x -= lowbit(x)) res += Bit[x];
    return res;
&amp;#125;
int main() &amp;#123;
    read(n), read(m);
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        read(a[i]);
        if (!tab.count(a[i]))
            tab[a[i]] = ++tot;
        a[i] = tab[a[i]];
        q[a[i]].emplace_back(0, i, 1);
    &amp;#125;
    while (m--) &amp;#123;
        scanf(&amp;quot;%1s&amp;quot;, &amp;amp;ty);
        if (ty == &amp;#39;C&amp;#39;) &amp;#123;
            read(x), read(y);
            if (!tab.count(y))
                tab[y] = ++tot;
            y = tab[y];
            q[a[x]].emplace_back(0, x, -1);
            q[a[x] = y].emplace_back(0, x, 1);
        &amp;#125;
        else &amp;#123;
            ++id;
            read(x), read(y), read(v);
            if (!tab.count(v)) continue;
            v = tab[v];
            q[v].emplace_back(1, x, y, id);
        &amp;#125;
    &amp;#125;
    for (int i = 1; i &amp;lt;= tot; ++i) &amp;#123;
        for (auto &amp;amp;j : q[i]) &amp;#123;
            if (j.ty == 0) add(j.l, j.v);
            else &amp;#123;
                res[j.v] =
                    ask(j.r) - ask(j.l - 1);
            &amp;#125;
        &amp;#125;
        for (auto &amp;amp;j : q[i])
            if (j.ty == 0) add(j.l, -j.v);
    &amp;#125;
    for (int i = 1; i &amp;lt;= id; ++i)
        print(res[i], &amp;#39;\n&amp;#39;);
    return 0;
&amp;#125;
&amp;#125; // namespace XSC062&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;p&gt;E 会单独开一篇。&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;f.-树-tree&#34;&gt;F. 树 tree&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.becoder.com.cn/contest/4647/problem/6&#34; class=&#34;uri&#34;&gt;https://www.becoder.com.cn/contest/4647/problem/6&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;CF916E。&lt;/p&gt;
&lt;p&gt;大分讨给我整不会了，更给我整不会的是下来过后发现这只是个小分讨。&lt;/p&gt;
&lt;p&gt;更新子树和子树查询我们都会。换根 DP 我们也都写过，都知道换根并不会对子树结构产生大的影响。所以应当是能根据已知信息推测出子树在原树上对应的点集的。&lt;/p&gt;
&lt;p&gt;记 &lt;span class=&#34;math inline&#34;&gt;\(r\)&lt;/span&gt; 为当前树根，&lt;span class=&#34;math inline&#34;&gt;\(\text {LCA}(x,y)\)&lt;/span&gt; 为 &lt;span class=&#34;math inline&#34;&gt;\(x,y\)&lt;/span&gt; 在 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt; 为根时的 LCA，&lt;span class=&#34;math inline&#34;&gt;\(\text {LCA}&amp;#39;(x,y)\)&lt;/span&gt; 表示 &lt;span class=&#34;math inline&#34;&gt;\(x,y\)&lt;/span&gt; 在 &lt;span class=&#34;math inline&#34;&gt;\(r\)&lt;/span&gt; 为根时的 LCA。&lt;/p&gt;
&lt;p&gt;那么对于 &lt;span class=&#34;math inline&#34;&gt;\(\text {LCA}&amp;#39;(x,y)\)&lt;/span&gt;，肯定是要讨论 &lt;span class=&#34;math inline&#34;&gt;\(x,y\)&lt;/span&gt; 和 &lt;span class=&#34;math inline&#34;&gt;\(r\)&lt;/span&gt; 的位置关系的。&lt;/p&gt;
&lt;ol type=&#34;1&#34;&gt;
&lt;li&gt;&lt;span class=&#34;math inline&#34;&gt;\(\text {LCA}(x,y)\)&lt;/span&gt; 是 &lt;span class=&#34;math inline&#34;&gt;\(r\)&lt;/span&gt; 的子孙。此时 &lt;span class=&#34;math inline&#34;&gt;\(\text {LCA}&amp;#39;(x,y) = \text {LCA}(x,y)\)&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;math inline&#34;&gt;\(\text {LCA}(x,y)\)&lt;/span&gt; 是 &lt;span class=&#34;math inline&#34;&gt;\(r\)&lt;/span&gt; 的祖先。那么说明至少有一个点不是 &lt;span class=&#34;math inline&#34;&gt;\(r\)&lt;/span&gt; 的子孙。此时 &lt;span class=&#34;math inline&#34;&gt;\(\text {LCA}(x,y)&amp;#39;\)&lt;/span&gt; 的值为 &lt;span class=&#34;math inline&#34;&gt;\(r\)&lt;/span&gt; 为另一个点的 LCA。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;整理可得 &lt;span class=&#34;math inline&#34;&gt;\(\text {LCA}&amp;#39;(x,y)\)&lt;/span&gt; 是 &lt;span class=&#34;math inline&#34;&gt;\(\text {LCA}(x,y)\)&lt;/span&gt;、&lt;span class=&#34;math inline&#34;&gt;\(\text {LCA}(x,r)\)&lt;/span&gt; 和 &lt;span class=&#34;math inline&#34;&gt;\(\text {LCA}(y,r)\)&lt;/span&gt; 中的深度最大者。&lt;/p&gt;
&lt;p&gt;对于以 &lt;span class=&#34;math inline&#34;&gt;\(r\)&lt;/span&gt; 为根时的子树 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt;：&lt;/p&gt;
&lt;ol type=&#34;1&#34;&gt;
&lt;li&gt;&lt;span class=&#34;math inline&#34;&gt;\(x=r\)&lt;/span&gt;，此时子树为整棵树。&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;math inline&#34;&gt;\(\text {LCA}(x,r)\ne x\)&lt;/span&gt;，即 &lt;span class=&#34;math inline&#34;&gt;\(r\)&lt;/span&gt; 不为 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 的子孙，此时子树就是以 &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt; 为根是的子树 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;math inline&#34;&gt;\(\text {LCA}(x,y)=x\)&lt;/span&gt;，即 &lt;span class=&#34;math inline&#34;&gt;\(r\)&lt;/span&gt; 为 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 的子孙，此时子树是整棵树除开 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 包含 &lt;span class=&#34;math inline&#34;&gt;\(r\)&lt;/span&gt; 的儿子及其子孙。修改和查询的时候容斥一下就好。这个时候的子树倍增跳一下就能找到。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;然后就是常规线段树维护了。时间复杂度 &lt;span class=&#34;math inline&#34;&gt;\(O(n\log n)\)&lt;/span&gt;。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;namespace XSC062 &amp;#123;
using namespace fastIO;
const int maxm = 35;
const int maxn = 1e5 + 5;
#define lt (p &amp;lt;&amp;lt; 1)
#define rt (lt | 1)
struct _ &amp;#123; int l, r, u, d; &amp;#125;;
_ t[maxn &amp;lt;&amp;lt; 2];
int f[maxn][maxm];
std::vector&amp;lt;int&amp;gt; g[maxn];
int a[maxn], dfn[maxn], rfn[maxn];
int n, q, r, ty, x, y, v, si, now;
int top[maxn], dep[maxn], tab[maxn];
void swap(int &amp;amp;x, int &amp;amp;y) &amp;#123;
    x ^= y ^= x ^= y;
    return;
&amp;#125;
void DFS(int x) &amp;#123;
    dep[x] = dep[f[x][0]] + 1;
    dfn[x] = ++now, tab[now] = x;
    for (auto i : g[x]) &amp;#123;
        if (i == f[x][0]) continue;
        f[i][0] = x;
        for (int j = 1; j &amp;lt;= si; ++j)
            f[i][j] = f[f[i][j - 1]][j - 1];
        DFS(i);
    &amp;#125;
    rfn[x] = now;
    return;
&amp;#125;
void pushup(int p) &amp;#123;
    t[p].u = t[lt].u + t[rt].u;
    return;
&amp;#125;
void pushdown(int p) &amp;#123;
    if (t[p].d) &amp;#123;
        t[lt].d += t[p].d;
        t[rt].d += t[p].d;
        t[lt].u += t[p].d *
                (t[lt].r - t[lt].l + 1);
        t[rt].u += t[p].d *
                (t[rt].r - t[rt].l + 1);
        t[p].d = 0;
    &amp;#125;
    return;
&amp;#125;
void bld(int p, int l, int r) &amp;#123;
    t[p].l = l, t[p].r = r;
    if (l == r) &amp;#123;
        t[p].u = a[tab[l]];
        return;
    &amp;#125;
    int mid = (l + r) &amp;gt;&amp;gt; 1;
    bld(lt, l, mid), bld(rt, mid + 1, r);
    pushup(p);
    return;
&amp;#125;
void add(int p, int x, int v) &amp;#123;
    t[p].u += v;
    if (t[p].l == t[p].r) return;
    pushdown(p);
    int mid = (t[p].l + t[p].r) &amp;gt;&amp;gt; 1;
    if (x &amp;lt;= mid) add(lt, x, v);
    else add(rt, x, v);
    return;
&amp;#125;
void add(int p, int l, int r, int v) &amp;#123;
    if (l &amp;lt;= t[p].l &amp;amp;&amp;amp; t[p].r &amp;lt;= r) &amp;#123;
        t[p].d += v;
        t[p].u += (t[p].r - t[p].l + 1) * v;
        return;
    &amp;#125;
    pushdown(p);
    int mid = (t[p].l + t[p].r) &amp;gt;&amp;gt; 1;
    if (l &amp;lt;= mid) add(lt, l, r, v);
    if (r &amp;gt; mid) add(rt, l, r, v);
    pushup(p);
    return;
&amp;#125;
int ask(int p, int l, int r) &amp;#123;
    if (l &amp;lt;= t[p].l &amp;amp;&amp;amp; t[p].r &amp;lt;= r)
        return t[p].u;
    pushdown(p);
    int res = 0,
        mid = (t[p].l + t[p].r) &amp;gt;&amp;gt; 1;
    if (l &amp;lt;= mid) res = ask(lt, l, r);
    if (r &amp;gt; mid) res += ask(rt, l, r);
    return res;
&amp;#125;
int LCA(int x, int y) &amp;#123;
    if (dep[x] &amp;lt; dep[y]) swap(x, y);
    for (int i = si; ~i; --i) &amp;#123;
        if (dep[f[x][i]] &amp;gt;= dep[y])
            x = f[x][i];
    &amp;#125;
    if (x == y) return x;
    for (int i = si; ~i; --i) &amp;#123;
        if (f[x][i] != f[y][i])
            x = f[x][i], y = f[y][i];
    &amp;#125;
    return f[x][0];
&amp;#125;
void Add(int x, int v) &amp;#123;
    int rlca = LCA(r, x);
    if (x == r) add(1, 1, n, v);
    else if (rlca != x)
        add(1, dfn[x], rfn[x], v);
    else &amp;#123;
        add(1, 1, n, v);
        int p = r;
        for (int i = si; ~i; --i) &amp;#123;
            if (dep[f[p][i]] &amp;gt;= dep[x] + 1)
                p = f[p][i];
        &amp;#125;
        add(1, dfn[p], rfn[p], -v);
    &amp;#125;
    return;
&amp;#125;
void tAdd(int x, int y, int v) &amp;#123;
    int llca = LCA(r, x), rlca = LCA(r, y),
        ulca = LCA(x, y);
    if (dep[llca] &amp;gt;= dep[rlca] &amp;amp;&amp;amp;
        dep[llca] &amp;gt;= dep[ulca]) Add(llca, v);
    else if (dep[rlca] &amp;gt;= dep[llca] &amp;amp;&amp;amp;
        dep[rlca] &amp;gt;= dep[ulca]) Add(rlca, v);
    else Add(ulca, v);
    return;
&amp;#125;
int tAsk(int x) &amp;#123;
    int rlca = LCA(r, x);
    if (x == r) return t[1].u;
    if (rlca != x)
        return ask(1, dfn[x], rfn[x]);
    int p = r;
    for (int i = si; ~i; --i) &amp;#123;
        if (dep[f[p][i]] &amp;gt;= dep[x] + 1)
            p = f[p][i];
    &amp;#125;
    return t[1].u - ask(1, dfn[p], rfn[p]);
&amp;#125;
void add(int x, int y) &amp;#123;
    g[x].push_back(y);
    return;
&amp;#125;
int main() &amp;#123;
    read(n), read(q), r = 1;
    si = log(n) / log(2.0);
    for (int i = 1; i &amp;lt;= n; ++i) read(a[i]);
    for (int i = 1; i &amp;lt; n; ++i) &amp;#123;
        read(x), read(y);
        add(x, y), add(y, x);
    &amp;#125;
    dep[0] = 1, DFS(1), dep[0] = 0;
    bld(1, 1, n);
    while (q--) &amp;#123;
        read(ty);
        if (ty == 1) read(r);
        else if (ty == 2) &amp;#123;
            read(x), read(y), read(v);
            tAdd(x, y, v);
        &amp;#125;
        else &amp;#123;
            read(x);
            print(tAsk(x), &amp;#39;\n&amp;#39;);
        &amp;#125;
    &amp;#125;
    return 0;
&amp;#125;
&amp;#125; // namespace XSC062
#undef int&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
</content>
        <category term="线段树" />
        <category term="树状数组" />
        <category term="LCA" />
        <category term="倍增" />
        <category term="鸽巢原理" />
        <updated>2024-01-06T03:27:39.000Z</updated>
    </entry>
    <entry>
        <id>https://xsc062.netlify.app/20231004-1/</id>
        <title>杂题选谈</title>
        <link rel="alternate" href="https://xsc062.netlify.app/20231004-1/"/>
        <content type="html">&lt;p&gt;&lt;a href=&#34;https://www.becoder.com.cn/contest/4272&#34;&gt;牛客普及&lt;/a&gt;。&lt;/p&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;a.-学习求余&#34;&gt;A. 学习求余&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.becoder.com.cn/contest/4272/problem/1&#34; class=&#34;uri&#34;&gt;https://www.becoder.com.cn/contest/4272/problem/1&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;今天我们来学习求余！这种题放普及 T1 不合适吧！&lt;/p&gt;
&lt;p&gt;令 &lt;span class=&#34;math inline&#34;&gt;\(k=\left\lfloor \dfrac n2 \right\rfloor + 1\)&lt;/span&gt;，直接输出 &lt;span class=&#34;math inline&#34;&gt;\(k\times (n - k)\)&lt;/span&gt; 即可。&lt;/p&gt;
&lt;details&gt;
&lt;p&gt;&lt;summary&gt;我是不是证复杂了…&lt;/summary&gt;&lt;/p&gt;
&lt;p&gt;我们可以简单地发现一个道理，对于任意 &lt;span class=&#34;math inline&#34;&gt;\(\dfrac n2&amp;lt;x\le n\)&lt;/span&gt;，&lt;span class=&#34;math inline&#34;&gt;\(n\bmod x\)&lt;/span&gt; 的值是 &lt;span class=&#34;math inline&#34;&gt;\(n - x\)&lt;/span&gt;；&lt;/p&gt;
&lt;p&gt;根据基本不等式（&lt;del&gt;wjs 直接感动得哭出声来&lt;/del&gt;）或小学知识「和不变，差小积大」，我们可以知道当 &lt;span class=&#34;math inline&#34;&gt;\(x=\left\lfloor \dfrac n2 \right\rfloor + 1\)&lt;/span&gt; 时，&lt;span class=&#34;math inline&#34;&gt;\(x\times (n-x)\)&lt;/span&gt; 取最大值。&lt;/p&gt;
&lt;p&gt;故有：当 &lt;span class=&#34;math inline&#34;&gt;\(x=\left\lfloor \dfrac n2 \right\rfloor + 1\)&lt;/span&gt; 时，&lt;span class=&#34;math inline&#34;&gt;\(x\times (n\bmod x)\)&lt;/span&gt; 取最大值。&lt;/p&gt;
&lt;p&gt;而对于 &lt;span class=&#34;math inline&#34;&gt;\(y\le \dfrac n2\)&lt;/span&gt;，由余数小于除数得，&lt;span class=&#34;math inline&#34;&gt;\(n\bmod y&amp;lt;y\le \dfrac n2\)&lt;/span&gt;。由于 &lt;span class=&#34;math inline&#34;&gt;\(0&amp;lt;y&amp;lt;x=\left\lfloor \dfrac n2 \right\rfloor + 1\)&lt;/span&gt; 且 &lt;span class=&#34;math inline&#34;&gt;\(0\le n\bmod y\le \left\lfloor \dfrac n2 \right\rfloor - 1\le n - \left\lfloor \dfrac n2 \right\rfloor - 1=n\bmod x\)&lt;/span&gt;，由不等式的基本性质得 &lt;span class=&#34;math inline&#34;&gt;\(x\times(n\bmod x)&amp;gt;y\times (n\bmod y)\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;综上，对于 &lt;span class=&#34;math inline&#34;&gt;\(1\le x\le n\)&lt;/span&gt;，当 &lt;span class=&#34;math inline&#34;&gt;\(x=\left\lfloor \dfrac n2 \right\rfloor + 1\)&lt;/span&gt; 时，&lt;span class=&#34;math inline&#34;&gt;\(x\times (n\bmod x)\)&lt;/span&gt; 有最大值。&lt;/p&gt;
&lt;/details&gt;
&lt;p&gt;然后如果你要问我怎么发现这一点的呢，我当时没有思路，然后随手输出了 &lt;span class=&#34;math inline&#34;&gt;\(n=100\)&lt;/span&gt; 时 &lt;span class=&#34;math inline&#34;&gt;\(n\bmod i\)&lt;/span&gt; 的所有值。然后发现 &lt;span class=&#34;math inline&#34;&gt;\(k=51\)&lt;/span&gt; 时余数是 &lt;span class=&#34;math inline&#34;&gt;\(49\)&lt;/span&gt;…… 然后就会了。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#define int long long
namespace XSC062 &amp;#123;
using namespace fastIO;
int n, k;
int main() &amp;#123;
    read(n), k = n / 2 + 1;
    print(k * (n % k));
    return 0;
&amp;#125;
&amp;#125; // namespace XSC062
#undef int&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;del&gt;头一次在题解里贴这么短的代码&lt;/del&gt;&lt;/p&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;b.-提取数字&#34;&gt;B. 提取数字&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.becoder.com.cn/contest/4272/problem/2&#34; class=&#34;uri&#34;&gt;https://www.becoder.com.cn/contest/4272/problem/2&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我被这道题（疑似 T1）坑到了！交了三遍才过！这合理吗？&lt;/p&gt;
&lt;p&gt;首先要开 &lt;code&gt;long long&lt;/code&gt;！然后注意，你的判定条件应为「当前是否已存储数」而非「当前存数变量是否为 0」！因为数据中会有单个 0 的情况出现！&lt;/p&gt;
&lt;p&gt;然后就没有了。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#define int long long
namespace XSC062 &amp;#123;
using namespace fastIO;
const int maxn = 1e5 + 5;
bool flag;
char s[maxn]; 
int n, ans, cnt;
int main() &amp;#123;
    scanf(&amp;quot;%*s %s&amp;quot;, s + 1);
    n = strlen(s + 1);
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        if (s[i] &amp;gt;= &amp;#39;0&amp;#39; &amp;amp;&amp;amp; s[i] &amp;lt;= &amp;#39;9&amp;#39;)
            cnt = cnt * 10 + s[i] - &amp;#39;0&amp;#39;, flag = 1;
        else if (flag)
            ans += (cnt + 5), cnt = 0, flag = 0;
    &amp;#125;
    if (flag) ans += (cnt + 5);
    print(ans, &amp;#39;\n&amp;#39;);
    return 0;
&amp;#125;
&amp;#125; // namespace XSC062
#undef int&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;c.-武器选择&#34;&gt;C. 武器选择&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.becoder.com.cn/contest/4272/problem/3&#34; class=&#34;uri&#34;&gt;https://www.becoder.com.cn/contest/4272/problem/3&lt;/a&gt;&lt;/p&gt;
&lt;details&gt;
&lt;p&gt;&lt;summary&gt;首先是我想了半个小时的狂拽酷炫吊炸天的法一：离线&lt;/summary&gt;&lt;/p&gt;
&lt;p&gt;我当时一边打一边怀疑现在的普及组是什么神仙，T3 考这么神奇的离线，难道是我落后于时代了？&lt;/p&gt;
&lt;p&gt;（之所以认为这是 T3 是因为括号那道题确实是正常 T4 风格）&lt;/p&gt;
&lt;p&gt;我们预处理出对于每一个可能获得武器 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 的位置，应该从哪个位置第一次捡到武器 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt;，由于这一段内的所有武器 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 都需要被拾取，我们将其作为区间 &lt;span class=&#34;math inline&#34;&gt;\([L_i, R_i]\)&lt;/span&gt; 来记录。&lt;/p&gt;
&lt;p&gt;那么询问可以转化为，在 &lt;span class=&#34;math inline&#34;&gt;\([l, r]\)&lt;/span&gt; 内 &lt;strong&gt;不同颜色&lt;/strong&gt; &lt;span class=&#34;math inline&#34;&gt;\([L_i, R_i]\)&lt;/span&gt; 的数量。&lt;/p&gt;
&lt;p&gt;考虑将询问离线。将询问按左端点从大到小排序，信息区间 &lt;span class=&#34;math inline&#34;&gt;\([L_i, R_i]\)&lt;/span&gt; 也按左端点从大到小排序。&lt;/p&gt;
&lt;p&gt;对于每次询问 &lt;span class=&#34;math inline&#34;&gt;\(l, r\)&lt;/span&gt;，在树状数组中将被 &lt;span class=&#34;math inline&#34;&gt;\([l, n]\)&lt;/span&gt; 完全包含的所有 &lt;span class=&#34;math inline&#34;&gt;\([L_i, R_i]\)&lt;/span&gt;（其实就是 &lt;span class=&#34;math inline&#34;&gt;\(l\le L_i\)&lt;/span&gt; 的所有 &lt;span class=&#34;math inline&#34;&gt;\(L_i\)&lt;/span&gt;）在右端点 &lt;span class=&#34;math inline&#34;&gt;\(R_i\)&lt;/span&gt; 处加一，我们就统计到了可以捡到武器的所有位置。&lt;/p&gt;
&lt;p&gt;怎么区分颜色呢？很简单，我们让每个颜色只被算一次。算哪一次呢？就算当前已加入的 &lt;span class=&#34;math inline&#34;&gt;\([L_i, R_i]\)&lt;/span&gt; 内，比选中概率最大的一次。&lt;/p&gt;
&lt;p&gt;我们树状数组统计的是 &lt;span class=&#34;math inline&#34;&gt;\([1, r]\)&lt;/span&gt; 内的值，所以我们要让概率最大的话，就要让 &lt;span class=&#34;math inline&#34;&gt;\(R_i\)&lt;/span&gt; 尽量的小。&lt;/p&gt;
&lt;p&gt;我们记录每个颜色当前合法 &lt;span class=&#34;math inline&#34;&gt;\([L_i, R_i]\)&lt;/span&gt; 的最小右端点 &lt;span class=&#34;math inline&#34;&gt;\(\min_R\)&lt;/span&gt;。加入一个新的 &lt;span class=&#34;math inline&#34;&gt;\([L_i, R_i]\)&lt;/span&gt; 时，如果 &lt;span class=&#34;math inline&#34;&gt;\(R_i\ge \min_R\)&lt;/span&gt;，那么不会产生影响，跳过；否则，当 &lt;span class=&#34;math inline&#34;&gt;\(R_i&amp;lt;\min_R\)&lt;/span&gt; 时，我们就要先消除当前 &lt;span class=&#34;math inline&#34;&gt;\(\min_R\)&lt;/span&gt; 的影响（即在树状数组中将该位置加上的 1 减去），再加上 &lt;span class=&#34;math inline&#34;&gt;\(R_i\)&lt;/span&gt; 的影响（即在树状数组中加上该位置的 1）。&lt;/p&gt;
&lt;p&gt;此时我们对 &lt;span class=&#34;math inline&#34;&gt;\([1, r]\)&lt;/span&gt; 的询问就是答案。&lt;/p&gt;
&lt;p&gt;复杂度 &lt;span class=&#34;math inline&#34;&gt;\(O(n\log n + m\log m + m\log n)\)&lt;/span&gt;，其中 &lt;span class=&#34;math inline&#34;&gt;\(n\log n\)&lt;/span&gt; 来自于对 &lt;span class=&#34;math inline&#34;&gt;\([L_i, R_i]\)&lt;/span&gt; 的排序，&lt;span class=&#34;math inline&#34;&gt;\(m\log m\)&lt;/span&gt; 来自于对询问的排序，&lt;span class=&#34;math inline&#34;&gt;\(m\log n\)&lt;/span&gt; 来自于离线树状数组。&lt;/p&gt;
&lt;/details&gt;
&lt;p&gt;接下来讲题解给的正解…… 这个是真的妙。&lt;/p&gt;
&lt;p&gt;考虑所有种类数，在 &lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt; 个数内满足条件的种类 &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; 最优条件下也不过 &lt;span class=&#34;math inline&#34;&gt;\(\dfrac {x\times (x+1)}2=n\)&lt;/span&gt;，所以满足条件武器的数量最多只有 &lt;span class=&#34;math inline&#34;&gt;\(\sqrt n\)&lt;/span&gt; 级别。&lt;/p&gt;
&lt;p&gt;所以我们对所有合法种类做前缀和，每次询问检查所有合法种类是否在该区间内出现对应次数，然后统计答案。复杂度 &lt;span class=&#34;math inline&#34;&gt;\(O(m\sqrt n + n\sqrt n)\)&lt;/span&gt;。&lt;span class=&#34;math inline&#34;&gt;\(n\sqrt n\)&lt;/span&gt; 是前面前缀和来的，&lt;span class=&#34;math inline&#34;&gt;\(m\sqrt n\)&lt;/span&gt; 是暴力统计来的。&lt;/p&gt;
&lt;p&gt;但是根号可耻，所以我的法一更 NB！！！🤡🤡🤡&lt;/p&gt;
&lt;details&gt;
&lt;p&gt;&lt;summary&gt;狂拽酷炫吊炸天的法一代码&lt;/summary&gt;&lt;/p&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#define int long long
namespace XSC062 &amp;#123;
using namespace fastIO;
const int maxn = 1e5 + 5;
struct _ &amp;#123;
    int l, r, k, i;
    bool operator&amp;lt; (const _ &amp;amp;q) const &amp;#123;
        return l &amp;lt; q.l;
    &amp;#125;
&amp;#125;;
struct __ &amp;#123;
    int l, r, nxt, x;
    bool operator&amp;lt; (const __ &amp;amp;q) const &amp;#123;
        return l &amp;lt; q.l;
    &amp;#125;
&amp;#125;;
_ q[maxn];
__ a[maxn];
std::map&amp;lt;int, int&amp;gt; t;
std::vector&amp;lt;int&amp;gt; u[maxn];
int ans[maxn], now[maxn];
int mnr[maxn], Bit[maxn];
int n, m, tot, x, cnt, pos;
int lowbit(int x) &amp;#123; return x &amp;amp; -x; &amp;#125;
void add(int x, int v) &amp;#123;
    for (int i = x; i &amp;lt;= n; i += lowbit(i))
        Bit[i] += v;
    return;
&amp;#125;
int ask(int x) &amp;#123;
    int res = 0;
    for (int i = x; i; i -= lowbit(i))
        res += Bit[i];
    return res;
&amp;#125;
int calc(int x, int k) &amp;#123;
    int res = 1;
    for (int i = 1; i &amp;lt;= k; ++i)
        res *= x--;
    for (int i = 1; i &amp;lt;= k; ++i)
        res /= i;
    return res;
&amp;#125;
int main() &amp;#123;
    read(n);
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        read(x);
        if (!t.count(x)) t[x] = ++tot;
        int id = t[x];
        u[id].push_back(i);
        if ((int)u[id].size() &amp;gt;= x) &amp;#123;
            a[++cnt].l = u[id][(int)u[id].size() - x];
            a[cnt].r = i, a[now[id]].nxt = cnt;
            a[cnt].x = x, mnr[x] = n + 1;
            now[id] = cnt;
        &amp;#125;
    &amp;#125;
    read(m);
    for (int i = 1; i &amp;lt;= m; ++i) &amp;#123;
        read(q[i].l), read(q[i].r);
        read(q[i].k), q[i].i = i;
    &amp;#125;
    std::sort(q + 1, q + m + 1);
    std::sort(a + 1, a + cnt + 1);
    pos = cnt;
    for (int i = m; i; --i) &amp;#123;
        while (a[pos].l &amp;gt;= q[i].l) &amp;#123;
            if (a[pos].r &amp;lt; mnr[a[pos].x]) &amp;#123;
                if (mnr[a[pos].x] &amp;lt;= n)
                    add(mnr[a[pos].x], -1);
                add(a[pos].r, 1);
                mnr[a[pos].x] = a[pos].r;
            &amp;#125;
            --pos;
        &amp;#125;
        ans[q[i].i] = calc(ask(q[i].r), q[i].k);
    &amp;#125;
    for (int i = 1; i &amp;lt;= m; ++i)
        print(ans[i], &amp;#39;\n&amp;#39;);
    return 0;
&amp;#125;
&amp;#125; // namespace XSC062
#undef int&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我甚至打完了就过了样例然后直接就 A 了，好久没有这么爽地过过这种大码量 &lt;del&gt;正确性还未知&lt;/del&gt; 的题了。&lt;/p&gt;
&lt;/details&gt;
&lt;p&gt;而且我相信全场只有我一个 &lt;del&gt;小丑&lt;/del&gt; 帅哥打离线，所以我是最强的！！！🤡🤡🤡&lt;/p&gt;
&lt;details&gt;
&lt;p&gt;&lt;summary&gt;绝对不如法一的法二代码&lt;/summary&gt;&lt;/p&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#define int long long
namespace XSC062 &amp;#123;
using namespace fastIO;
const int maxm = 505;
const int maxn = 1e5 + 5;
int a[maxn];
int cnt[maxn];
int sum[maxm][maxn];
int n, tot, m, l, r, k, res;
int calc(int x, int k) &amp;#123;
    int res = 1;
    for (int i = 1; i &amp;lt;= k; ++i)
        res *= x--;
    for (int i = 1; i &amp;lt;= k; ++i)
        res /= i;
    return res;
&amp;#125;
int main() &amp;#123;
    read(n);
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        read(a[i]);
        if (a[i] &amp;lt;= n) ++cnt[a[i]];
    &amp;#125;
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        if (cnt[i] &amp;gt;= i) &amp;#123;
            sum[++tot][n + 1] = i;
            for (int j = 1; j &amp;lt;= n; ++j)
                sum[tot][j] = sum[tot][j - 1] + (a[j] == i);
        &amp;#125;
    &amp;#125;
    read(m);
    while (m--) &amp;#123;
        read(l), read(r), read(k);
        res = 0;
        for (int i = 1; i &amp;lt;= tot; ++i)
            res += (sum[i][r] - sum[i][l - 1] &amp;gt;= sum[i][n + 1]);
        print(calc(res, k), &amp;#39;\n&amp;#39;);
    &amp;#125;
    return 0;
&amp;#125;
&amp;#125; // namespace XSC062
#undef int&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;d.-括号序列&#34;&gt;D. 括号序列&lt;/h3&gt;
&lt;p&gt;https://www.becoder.com.cn/contest/4272/problem/4&lt;/p&gt;
&lt;p&gt;呃呃呃，这，有什么好讲的吗？做过原题的应该都会吧……&lt;/p&gt;
&lt;p&gt;反正就是个比较裸的区间 DP，转移的时候注意一下究竟哪些是同一对括号，哪些是相邻括号就好。&lt;/p&gt;
&lt;p&gt;复杂度 &lt;span class=&#34;math inline&#34;&gt;\(O(n^2)\)&lt;/span&gt;。&lt;/p&gt;
&lt;details&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;namespace XSC062 &amp;#123;
using namespace fastIO;
const int maxn = 1e3 + 5;
int n, res;
char s[maxn];
std::stack&amp;lt;int&amp;gt; t;
int mat[maxn], c[5];
int f[maxn][maxn][3][3];
int max(int x, int y) &amp;#123; return x &amp;gt; y ? x : y; &amp;#125;
void upd(int &amp;amp;x, int y) &amp;#123; x = max(x, y); return; &amp;#125;
int main() &amp;#123;
    memset(f, -0x3f, sizeof (f));
    scanf(&amp;quot;%d %d %d&amp;quot;, &amp;amp;n, &amp;amp;c[1], &amp;amp;c[2]);
    scanf(&amp;quot;%s&amp;quot;, s + 1);
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        if (s[i] == &amp;#39;(&amp;#39;) t.push(i);
        else mat[t.top()] = i, t.pop();
    &amp;#125;
    for (int i = 1; i &amp;lt;= n; ++i) &amp;#123;
        if (mat[i] == i + 1) &amp;#123;
            for (int k = 0; k &amp;lt;= 2; ++k)
                f[i][i + 1][k][k] = c[k];
        &amp;#125;
    &amp;#125;
    for (int l = 4; l &amp;lt;= n; l += 2) &amp;#123;
        for (int i = 1; i &amp;lt;= n - l + 1; ++i) &amp;#123;
            int j = i + l - 1;
            if (mat[i] == j) &amp;#123;
                // ((...))
                // xy...zx
                for (int x = 0; x &amp;lt;= 2; ++x) &amp;#123;
                    for (int y = 0; y &amp;lt;= 2; ++y) &amp;#123;
                        if (y == x) continue;
                        for (int z = 0; z &amp;lt;= 2; ++z) &amp;#123;
                            if (z == x) continue;
                            upd(f[i][j][x][x], f[i + 1][j - 1][y][z] + c[x]);
                        &amp;#125;
                    &amp;#125;
                &amp;#125;
            &amp;#125;
            else &amp;#123;
                // ()(...)
                // xxy...z
                for (int x = 0; x &amp;lt;= 2; ++x) &amp;#123;
                    for (int y = 0; y &amp;lt;= 2; ++y) &amp;#123;
                        if (y == x) continue;
                        for (int z = 0; z &amp;lt;= 2; ++z)
                            upd(f[i][j][x][z], f[i][mat[i]][x][x] + f[mat[i] + 1][j][y][z]);
                    &amp;#125;
                &amp;#125;
            &amp;#125;
        &amp;#125;
    &amp;#125;
    for (int i = 0; i &amp;lt;= 2; ++i) &amp;#123;
        for (int j = 0; j &amp;lt;= 2; ++j)
            res = max(res, f[1][n][i][j]);
    &amp;#125;
    print(res, &amp;#39;\n&amp;#39;);
    return 0;
&amp;#125;
&amp;#125; // namespace XSC062&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
</content>
        <category term="树状数组" />
        <category term="区间 DP" />
        <updated>2023-10-04T08:41:40.000Z</updated>
    </entry>
</feed>
