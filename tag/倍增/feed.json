{
    "version": "https://jsonfeed.org/version/1",
    "title": "null • All posts by \"倍增\" tag",
    "description": "",
    "home_page_url": "https://xsc062.netlify.app",
    "items": [
        {
            "id": "https://xsc062.netlify.app/20251010/",
            "url": "https://xsc062.netlify.app/20251010/",
            "title": "学习笔记：树状数组",
            "date_published": "2025-10-10T00:12:01.000Z",
            "content_html": "<p>我有一个朋友今天才会树状数组（存疑）</p>\n<span id=\"more\"></span>\n<p>因为到了今天还是不会</p>\n<hr />\n<h2 id=\"单点修改区间查询\">单点修改，区间查询</h2>\n<ul>\n<li><p>树状数组本身是一个多叉树结构。每个点 <span class=\"math inline\">\\(i\\)</span> 上保存 <span class=\"math inline\">\\([i-\\text{lowbit}(i)+1,i]\\)</span> 的和，并指向若干个更小的子区间（彼此不重，且拼起来是自身）</p>\n<figure>\n<img src=\"image-1.png\" alt=\"图源 OI Wiki\" /><figcaption>图源 OI Wiki</figcaption>\n</figure></li>\n<li>修改 <span class=\"math inline\">\\(x\\)</span>：从包含 <span class=\"math inline\">\\(x\\)</span> 的最低点（id 为 <span class=\"math inline\">\\(x\\)</span> 且右端点为 <span class=\"math inline\">\\(x\\)</span>）一直向上修改包含 <span class=\"math inline\">\\(x\\)</span> 的区间。</li>\n<li><p>查询 <span class=\"math inline\">\\([1, x]\\)</span>：从右端点为 <span class=\"math inline\">\\(x\\)</span> 的区间（id 为 <span class=\"math inline\">\\(x\\)</span>）出发，不断找到前方紧邻的区间（<span class=\"math inline\">\\(id\\)</span> 差为 lowbit），累加进答案。</p></li>\n</ul>\n<hr />\n<h2 id=\"区间修改单点查询\">区间修改，单点查询</h2>\n<ul>\n<li>运用序列问题上的技巧，转化为差分数组上的单点修改、前缀查询。</li>\n<li>事实上除了基本结构以外的内容，树状数组本身并没有参与，只需当作<strong>一个输入单点修改，输出前缀和的黑盒</strong>即可。</li>\n</ul>\n<hr />\n<h2 id=\"区间修改区间查询\">区间修改，区间查询</h2>\n<ul>\n<li><p>考虑沿用差分的方法实现区间修改。考虑数学推导表达区间前缀和。</p>\n<p>已知 <span class=\"math inline\">\\(d_i=a_i-a_{i-1}\\)</span>，则：</p>\n<p><span class=\"math display\">\\[\n\\begin{aligned}\n\\sum\\limits_{i=1}^x a_i=&amp;\\sum\\limits_{i=1}^x\\sum_{j=1}^i d_j\\\\\n=&amp;\\sum\\limits_{i=1}^x d_i\\cdot (x-i+1)\\\\\n=&amp;(x+1)\\cdot \\left(\\sum\\limits_{i=1}^x d_i\\right) - \\left(\\sum\\limits_{i=1}^x i\\cdot d_i\\right)\n\\end{aligned}\n\\]</span></p></li>\n<li>故只需要在黑盒中维护 <span class=\"math inline\">\\(d_i\\)</span> 和 <span class=\"math inline\">\\(i\\cdot d_i\\)</span> 的单点修改即可。</li>\n<li><p>在实现时感到违和：对 <span class=\"math inline\">\\([l, r]\\)</span> 做区间修改时，对于 <span class=\"math inline\">\\(l\\)</span> 处的 <span class=\"math inline\">\\(i\\cdot d_i\\)</span> 作出了 <span class=\"math inline\">\\(l\\cdot \\Delta\\)</span> 的修改，为何在 <span class=\"math inline\">\\(r+1\\)</span> 处作 <span class=\"math inline\">\\((r + 1)\\cdot \\Delta\\)</span> 的修改（而非也是 <span class=\"math inline\">\\(l\\cdot \\Delta\\)</span>？）</p>\n<p>事实上，对于 <span class=\"math inline\">\\(i\\cdot d_i\\)</span> 的修改是对 <span class=\"math inline\">\\(d_i\\)</span> 修改的字面反映，这个量本身并没有具体的含义。</p>\n<p>感觉有点唐唐的，也就只有我会有这种疑惑了……</p></li>\n</ul>\n<hr />\n<h3 id=\"excercise\">Excercise</h3>\n<ul>\n<li><p>维护 <span class=\"math inline\">\\(a_i\\)</span> 的区间加、<span class=\"math inline\">\\(a_i\\)</span> 的区间和查询、<span class=\"math inline\">\\(i\\cdot a_i\\)</span> 的区间和查询。</p>\n<p>令 <span class=\"math inline\">\\(d_i=a_i-a_{i-1}\\)</span>，考虑变形：</p>\n<p><span class=\"math display\">\\[\n\\begin{aligned}\n\\sum\\limits_{i=1}^x i\\cdot a_i=&amp;\\sum\\limits_{i=1}^xi\\cdot \\sum_{j=1}^i d_j\\\\\n=&amp;\\sum\\limits_{i=1}^x d_i\\cdot \\left(i+(i+1)+\\cdots +x\\right)\\\\\n=&amp;\\sum\\limits_{i=1}^x d_i\\cdot \\dfrac {(x+i)\\cdot (x-i+1)}2\\\\\n=&amp;\\sum\\limits_{i=1}^x d_i\\cdot \\dfrac {x^2+x-i^2+i}2\\\\\n=&amp;\\dfrac{(x^2+x)\\cdot \\left(\\sum\\limits_{i=1}^x d_i\\right) + \\left(\\sum\\limits_{i=1}^x i\\cdot d_i\\right) - \\left(\\sum\\limits_{i=1}^x i^2\\cdot d_i\\right)}2\n\\end{aligned}\n\\]</span></p></li>\n<li><p>故只需要在黑盒中维护 <span class=\"math inline\">\\(d_i\\)</span>、<span class=\"math inline\">\\(i\\cdot d_i\\)</span> 和 <span class=\"math inline\">\\(i^2\\cdot d_i\\)</span> 的单点修改即可。</p>\n<p>见 <a href=\"/20251007/#c.-相互抵消\">相互抵消</a>。</p></li>\n</ul>\n<hr />\n<h3 id=\"ex.-北校门外的回忆\">Ex. 北校门外的回忆</h3>\n<p><a href=\"https://loj.ac/p/510\" class=\"uri\">https://loj.ac/p/510</a></p>\n<blockquote>\n<p>定义 <span class=\"math inline\">\\(\\text{lowbit}_K(x)\\)</span> 为 <span class=\"math inline\">\\(x\\)</span> 在 <span class=\"math inline\">\\(K\\)</span> 进制下最低非零位的值。有一个异或和树状数组，把原本代码中的 <span class=\"math inline\">\\(\\text{lowbit}_2(x)\\)</span> 全部替换为 <span class=\"math inline\">\\(\\text{lowbit}_K(x)\\)</span>，得到一个正确性和复杂度均错误的『树状数组』，现在给定若干次 <code>add</code> 和 <code>ask</code> 操作，你需要输出错误的代码运行的结果。</p>\n<p><span class=\"math inline\">\\(m\\le 2\\times 10^5\\)</span>。</p>\n</blockquote>\n<ul>\n<li>需要意识到并不是真的要用树状数组模拟这个操作，一边转化一边要想办法把这个错误代码用正常 DS 的操作表述出来。</li>\n<li><code>add</code> 的本质是对于非零最低位乘二并进位。手玩可以发现，有的时候『非零最低位』的位置是不变的，有的时候『非零最低位』变成 <span class=\"math inline\">\\(0\\)</span> 了，就会前移。</li>\n<li><p>这显然是个 <span class=\"math inline\">\\(x\\to 2x\\bmod K\\)</span> 的内向基环树森林，且当存在自环 <span class=\"math inline\">\\(0\\)</span> 时，一个树中的最大跳跃次数为 <span class=\"math inline\">\\(\\log_2K\\)</span>。</p>\n<figure>\n<img src=\"image-2.png\" alt=\"mobai Grisses\" /><figcaption>mobai Grisses</figcaption>\n</figure>\n<p>故这个时候（即 <span class=\"math inline\">\\(x\\)</span> 包含了『<span class=\"math inline\">\\(K\\)</span> 除了 <span class=\"math inline\">\\(2\\)</span> 之外的因子』时 ）暴力跳即可。对于每一位都这么跳是可以接受的。</p></li>\n<li><p><span class=\"math inline\">\\(0\\)</span> 不在树中，最终会有一个循环节。不妨把经过的所有点拉出来成为一条链。</p>\n<p>这个时候可以停下来想一想题目给的两个操作是在做什么。显然每个叶子会引导一条无限长的链，则 <code>add</code> 就是给这个链做了一个后缀加（<span class=\"math inline\">\\(N\\)</span> 的限制是没影响的），<code>ask</code> 则是问了 log 个点值。</p>\n<p>则如果这个链真的可以被处理出来，只需要 bit 维护差分即可。</p></li>\n<li><p>考虑倍增预处理 <span class=\"math inline\">\\(f(i,j)\\)</span> 表示 <span class=\"math inline\">\\(i\\)</span> 走了 <span class=\"math inline\">\\(2^j\\)</span> 步后到的点，模拟跳 <span class=\"math inline\">\\(0\\)</span>、倍增跳循环节即可。</p></li>\n</ul>\n<hr />\n<h2 id=\"bit-上倍增\">BIT 上倍增</h2>\n<p>更偏数据结构技巧了，也重新回到结构上面。</p>\n<p>对标线段树上二分，缺陷在于能维护的数据限制很大，优势在于常数很小。在出题人刻意只放树状数组过，或者<strong>树套树</strong>外层为树状数组的时候用处比较明显。</p>\n<hr />\n<h3 id=\"冰火战士\">冰火战士</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P6619\" class=\"uri\">https://www.luogu.com.cn/problem/P6619</a></p>\n<blockquote>\n<p>给定初始为空的二元组数组 <span class=\"math inline\">\\(A, B\\)</span>。对于阈值 <span class=\"math inline\">\\(k\\)</span>，令 <span class=\"math inline\">\\(s_A\\)</span> 表示 <span class=\"math inline\">\\(A\\)</span> 中关键字一 <span class=\"math inline\">\\(\\le k\\)</span> 的元素关键字二之和，<span class=\"math inline\">\\(s_B\\)</span> 表示 <span class=\"math inline\">\\(B\\)</span> 中关键字一 <span class=\"math inline\">\\(\\ge k\\)</span> 的元素关键字二之和。</p>\n<p>维护若干次 <span class=\"math inline\">\\(A,B\\)</span> 的加点、删点操作，每次操作后输出：</p>\n<ul>\n<li>自由选取 <span class=\"math inline\">\\(k\\)</span>，求 <span class=\"math inline\">\\(\\min\\{s_A,s_B\\}\\)</span> 的最大值。</li>\n</ul>\n<p><span class=\"math inline\">\\(m\\le 2\\times 10^6\\)</span>，<span class=\"math inline\">\\(V\\le 10^9\\)</span>。</p>\n</blockquote>\n<ul>\n<li>不妨考虑固定状态下的询问。容易想到将 <span class=\"math inline\">\\(A,B\\)</span> 按关键字一<strong>升序排序</strong>。随着 <span class=\"math inline\">\\(k\\)</span> 的增大，<span class=\"math inline\">\\(s_A\\)</span> 是 <span class=\"math inline\">\\(A\\)</span> 关键字二的前缀和，<span class=\"math inline\">\\(s_B\\)</span> 是 <span class=\"math inline\">\\(B\\)</span> 关键字二的后缀和。</li>\n<li><p>我并不会三分，但题解说因为有平台所以三分做不了。</p>\n<p>但由于最高点同时是交点，可以二分找到最值点。离散化元素后维护此处的前缀和即可。</p></li>\n<li>容易想到线段树上二分，然而常数太大难以通过。</li>\n<li><p>如果改用树状数组呢？树状数组有办法进行类似线段树上二分的操作吗？</p>\n<p>事实上，bit 的结构更适合倍增。其出发点和线段树上二分是相同的，在于规避重复询问。</p>\n<p>假设当前在一个合法位置 <span class=\"math inline\">\\(p\\)</span>，已经累加到 <span class=\"math inline\">\\(s\\)</span>，要验证 <span class=\"math inline\">\\(p+2^k\\)</span>（<span class=\"math inline\">\\(\\text{lowbit}(p+2^k)=2^k\\)</span>）是否仍然合法，仅需 check <span class=\"math inline\">\\(s+c_{p+2^k}\\)</span> 是否合法（结合树状数组结构想一想）。</p></li>\n</ul>\n<details>\n<p>其实 Peace 是有点难判的…… 我写了个结构题维护了数量用来判断。</p>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int m;\n    std::cin &gt;&gt; m;\n    struct query &#123; int op, k, x, y; &#125;;\n    std::vector&lt;query&gt; a(m + 1);\n    std::vector&lt;int&gt; l(1);\n    for (int i = 1; i &lt;= m; ++i) &#123;\n        std::cin &gt;&gt; a[i].op &gt;&gt; a[i].k;\n        if (a[i].op == 1) &#123;\n            std::cin &gt;&gt; a[i].x &gt;&gt; a[i].y;\n            l.push_back(a[i].x);\n        &#125;\n        else &#123;\n            int k = a[i].k;\n            a[i].op = -1;\n            a[i].k = a[k].k, a[i].x = a[k].x, a[i].y = a[k].y;\n        &#125;\n    &#125;\n    std::sort(l.begin() + 1, l.end());\n    l.erase(std::unique(l.begin() + 1, l.end()), l.end());\n    int n = (int)l.size();\n    std::vector&lt;int&gt; cnt(2);\n    std::vector&lt;long long&gt; sum(2);\n    struct node &#123;\n        int c;\n        long long v;\n        node(void): c(0), v(0ll) &#123;&#125;\n        node(int c1, long long v1): c(c1), v(v1) &#123;&#125;\n        node operator+ (const node &amp;q) const &#123;\n            return node(c + q.c, v + q.v);\n        &#125;\n        node operator- (const node &amp;q) const &#123;\n            return node(c - q.c, v - q.v);\n        &#125;\n        node&amp; operator+= (const node q) &#123;\n            return *this = *this + q;\n        &#125;\n        node &amp;operator-= (const node &amp;q) &#123;\n            return *this = *this - q;\n        &#125;\n    &#125;;\n    std::vector&lt;std::vector&lt;node&gt; &gt; bit(2, std::vector&lt;node&gt; (n + 1)), s(2, std::vector&lt;node&gt; (n + 1));\n    auto lowbit = [&amp;](int x) &#123; return x &amp; -x; &#125;;\n    for (int i = 1; i &lt;= m; ++i) &#123;\n        a[i].x = std::lower_bound(l.begin() + 1, l.end(), a[i].x) - l.begin() + a[i].k;\n        cnt[a[i].k] += a[i].op, sum[a[i].k] += a[i].op * a[i].y;\n        s[a[i].k][a[i].x] += node(a[i].op, a[i].op * a[i].y);\n        for (int j = a[i].x; j &lt;= n; j += lowbit(j))\n            bit[a[i].k][j] += node(a[i].op, a[i].op * a[i].y);\n        if (std::min(cnt[0], cnt[1]) == 0)\n            std::cout &lt;&lt; &quot;Peace\\n&quot;;\n        else &#123;\n            int p = 0;\n            node s0(0, 0ll), s1(cnt[1], sum[1]);\n            for (int i = 20; ~i; --i)\n                if (p + (1 &lt;&lt; i) &lt;= n &amp;&amp; (s0 + bit[0][p + (1 &lt;&lt; i)]).v &lt;= (s1 - bit[1][p + (1 &lt;&lt; i)]).v)\n                    p += (1 &lt;&lt; i), s0 += bit[0][p], s1 -= bit[1][p];\n            if (p + 1 &lt;= n &amp;&amp; s1.c != s[1][p + 1].c &amp;&amp; (s1 - s[1][p + 1]).v &gt;= s0.v) &#123;\n                s1 -= s[1][p + 1], s0 = node(cnt[1], sum[1]), p = 0;\n                for (int i = 20; ~i; --i)\n                    if (p + (1 &lt;&lt; i) &lt;= n &amp;&amp; (s0 - bit[1][p + (1 &lt;&lt; i)]).v &gt;= s1.v)\n                        p += (1 &lt;&lt; i), s0 -= bit[1][p];\n                std::cout &lt;&lt; l[p] &lt;&lt; &#39; &#39; &lt;&lt; 2 * s1.v &lt;&lt; &#39;\\n&#39;;\n            &#125;\n            else if (s0.c)\n                std::cout &lt;&lt; l[p] &lt;&lt; &#39; &#39; &lt;&lt; 2 * s0.v &lt;&lt; &#39;\\n&#39;;\n            else\n                std::cout &lt;&lt; &quot;Peace\\n&quot;;\n        &#125;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h3 id=\"sails-船帆\">sails 船帆</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/P4647\" class=\"uri\">https://www.luogu.com.cn/problem/P4647</a></p>\n<ul>\n<li><p>需要意识到<strong>帆的顺序对答案没有影响，同一行帆的个数对答案有影响</strong>。</p>\n<p>从这一点出发会有一个比较显然的贪心：把柱状图斜过来，把柱子按 <span class=\"math inline\">\\(h\\)</span> 从小到大<strong>排序</strong>，问题变为对于第 <span class=\"math inline\">\\(i\\)</span> 次操作，选 <span class=\"math inline\">\\(1\\sim h_i\\)</span> 里最矮的几列使其高度 +1。</p>\n<p>其实会有一些其他的贪心方法，比如我一开始想的是不排序，在 <span class=\"math inline\">\\(1\\sim h_i\\)</span> 内，优先使最矮的高度 +1，高度相同的使编号更大的柱子高度 +1。这个的正确性也比较好证明，但是太复杂了，没什么好的优化。<strong>把贪心策略中的偏序关系提前到一次排序</strong>就会简单很多。</p></li>\n<li><p>现在需要找到最矮的这几列。<del>我会文艺平衡树</del></p>\n<p>考虑更加天才的做法。如果我们需要用 bit，线段树这样的结构来维护操作，就会有一些问题： 为了快速修改，需要保证修改的元素是连续的。简单的方法是让元素有序地在 ds 中排列。但修改操作本身会破坏这样的偏序关系。</p></li>\n<li><p>不妨假设元素降序排列（和后方的 0 衔接），那么需要把 <span class=\"math inline\">\\([h-k+1,h]\\)</span> 这段元素 +1，但这会造成部分元素的前移，考虑前移的过程到底发生了什么。</p>\n<p>考虑这样的场景：</p>\n<p><img src=\"image.png\" /></p>\n<p><strong>由于 delta 为 1，至多只会有一段数发生这样的前移。</strong>先 ask 一下 <span class=\"math inline\">\\(h-k+1\\)</span> 处的值，假设这一段的左右端点为 <span class=\"math inline\">\\([l,r]\\)</span>，只需要修改 <span class=\"math inline\">\\([l,l+(r-(h-k+1))]\\)</span> 和 <span class=\"math inline\">\\([r+1,h]\\)</span> 两段区间即可。</p></li>\n<li><p><span class=\"math inline\">\\([l,r]\\)</span> 是可以通过 bit 上倍增求出的。复杂度 <span class=\"math inline\">\\(O(n\\log n)\\)</span>。</p></li>\n</ul>\n<hr />\n<h3 id=\"insert\">Insert</h3>\n<p><a href=\"https://www.luogu.com.cn/problem/AT_abc392_f\" class=\"uri\">https://www.luogu.com.cn/problem/AT_abc392_f</a></p>\n<ul>\n<li>维护每个数的位置，相当于给值在 <span class=\"math inline\">\\([P_i,i-1]\\)</span> 的元素做区间 +1，显然右端点是单增的，那么就转化为上一题。</li>\n</ul>\n<hr />\n<h3 id=\"买宝石\">买宝石</h3>\n<p><a href=\"https://www.becoder.com.cn/contest/6620/problem/4\" class=\"uri\">https://www.becoder.com.cn/contest/6620/problem/4</a></p>\n<p>见 <a href=\"/20251007-1/#买宝石\">树套树</a>。</p>\n",
            "tags": [
                "树状数组",
                "倍增"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20251007/",
            "url": "https://xsc062.netlify.app/20251007/",
            "title": "杂题选谈",
            "date_published": "2025-10-07T08:29:43.000Z",
            "content_html": "<p>近期模拟赛</p>\n<span id=\"more\"></span>\n<hr />\n<h2 id=\"a.-考试\">A. 考试</h2>\n<p><a href=\"https://www.becoder.com.cn/contest/6624/problem/1\" class=\"uri\">https://www.becoder.com.cn/contest/6624/problem/1</a></p>\n<blockquote>\n<p><span class=\"math inline\">\\(m\\)</span> 道题，分数是一个 <span class=\"math inline\">\\(m\\)</span> 的排列（初始未知），做对得满分，做错得 0 分</p>\n<p>给定 <span class=\"math inline\">\\(n\\)</span> 个人对于这 <span class=\"math inline\">\\(m\\)</span> 个题的过题情况矩阵，且第 <span class=\"math inline\">\\(i\\)</span> 个人有一个预期分数 <span class=\"math inline\">\\(x_i\\)</span>。</p>\n<p>求每到题的分数，使得每个人实际得分与期望的分差的绝对值之和最大。输出该排列。</p>\n<p><span class=\"math inline\">\\(n\\le 10,m\\le 10^4\\)</span>。</p>\n</blockquote>\n<ul>\n<li>绝对值是贪心一个很大的阻碍</li>\n<li><p>一个典型的『钦定』型贪心，枚举每个人的绝对值是否取反，就可以得到每个题对应的系数。</p>\n<p>因为『就算错了也不会影响最优解』，所以是对的。</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n    std::freopen(&quot;test.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;test.out&quot;, &quot;w&quot;, stdout);\n    int T;\n    for (std::cin &gt;&gt; T; T--; ) &#123;\n        int n, m;\n        std::cin &gt;&gt; n &gt;&gt; m;\n        std::vector&lt;int&gt; s(n + 1);\n        for (int i = 1; i &lt;= n; ++i)\n            std::cin &gt;&gt; s[i];\n        std::vector&lt;std::vector&lt;int&gt; &gt; pos(n + 1);\n        for (int i = 1; i &lt;= n; ++i)\n            for (int j = 1; j &lt;= m; ++j) &#123;\n                char t;\n                std::cin &gt;&gt; t;\n                if (t == &#39;1&#39;)\n                    pos[i].push_back(j);\n            &#125;\n        auto res = 0ll;\n        int siz = 1 &lt;&lt; n;\n        std::vector&lt;std::vector&lt;int&gt; &gt; id(2 * n + 1);\n        std::vector&lt;int&gt; cnt(m + 1), ans(m + 1), p(m + 1);\n        for (int i = 0; i &lt; siz; ++i) &#123;\n            std::fill(cnt.begin() + 1, cnt.end(), 0);\n            for (int j = 0; j &lt;= 2 * n; ++j)\n                id[j].clear();\n            for (int j = 1; j &lt;= n; ++j)\n                if ((i &gt;&gt; (j - 1)) &amp; 1)\n                    for (auto k : pos[j])\n                        ++cnt[k];\n                else\n                    for (auto k : pos[j])\n                        --cnt[k];\n            for (int j = 1; j &lt;= m; ++j)\n                id[cnt[j] + n].push_back(j);\n            for (int i = 2 * n, k = m; ~i; --i)\n                for (auto j : id[i])\n                    p[j] = k--;\n            auto now = 0ll;\n            for (int i = 1; i &lt;= n; ++i) &#123;\n                int sum = 0;\n                for (auto j : pos[i])\n                    sum += p[j];\n                now += std::abs(sum - s[i]);\n            &#125;\n            if (now &gt;= res)\n                res = now, ans = p;\n        &#125;\n        // std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n        for (int i = 1; i &lt;= m; ++i)\n            std::cout &lt;&lt; ans[i] &lt;&lt; &#39; &#39;;\n        std::cout &lt;&lt; &#39;\\n&#39;;\n    &#125;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"b.-围棋\">B. 围棋</h2>\n<p><a href=\"https://www.becoder.com.cn/contest/6624/problem/2\" class=\"uri\">https://www.becoder.com.cn/contest/6624/problem/2</a></p>\n<blockquote>\n<p>给定 <span class=\"math inline\">\\(n \\times n\\)</span> 的棋盘，上面有黑棋、白棋和空地，定义白棋的『气』为四个方向空地的数量，若一个白棋四连通块中所有白棋的『气』都为 0，则认为这个白棋四连通块中的所有白棋是『死的』。</p>\n<p>现枚举每个棋子，并将其反转颜色，问『死的』白棋数量。操作是独立的。</p>\n<p>3s，<span class=\"math inline\">\\(n\\le 10^3\\)</span>。</p>\n</blockquote>\n<ul>\n<li>分讨题，需要想清楚。首先需要一次 floodfill 完成染色，记录哪些连通块死了。</li>\n<li><p>若反转黑棋：</p>\n<ul>\n<li><p>若黑棋自己有气，或和黑棋相连的白棋四连通块有气，那么黑棋自己，以及所有和黑棋相连的白棋四连通块都是活的。</p>\n<p>此时需要找到所有和黑棋相连的，且死了的白棋四连通块的大小，答案需要减去之。</p></li>\n</ul></li>\n<li><p>否则，黑棋自身贡献 <span class=\"math inline\">\\(1\\)</span> 的答案。</p></li>\n<li><p>若反转白棋：</p>\n<ul>\n<li>若白棋本身是死的：答案 <span class=\"math inline\">\\(-1\\)</span>。</li>\n<li><p>否则，需要考虑有多少个原本是活的白棋此时与有气的白棋不连通，这种情况发生当且仅当有气的白棋是被反转的白棋自身，或者被反转的白棋是割点。</p>\n<p>很奇妙的一个想法是建立超级源点，向所有空地连边，再建圆方树，这样这个点的所有儿子就是待求。圆方树并不需要显式地建出来。</p></li>\n</ul></li>\n</ul>\n<p>代码：不会</p>\n<hr />\n<h2 id=\"c.-相互抵消\">C. 相互抵消</h2>\n<p><a href=\"https://www.becoder.com.cn/contest/6624/problem/3\" class=\"uri\">https://www.becoder.com.cn/contest/6624/problem/3</a></p>\n<blockquote>\n<p>给定 <span class=\"math inline\">\\(a_{1\\sim n}\\)</span>，维护 <span class=\"math inline\">\\(m\\)</span> 次操作：</p>\n<ol type=\"1\">\n<li>区间加。</li>\n<li>给定 <span class=\"math inline\">\\(l,r\\)</span>，查询 <span class=\"math inline\">\\(\\left(\\sum\\limits_{i=l}^r\\sum\\limits_{j=i}^r ((\\sum_{k=i}^j a_k)^2 + (r-l+2)\\times(j-i)\\times a_i\\times a_j)\\right) \\bmod 998244353\\)</span>。</li>\n</ol>\n<p><span class=\"math inline\">\\(n,m\\le 5\\times 10^5\\)</span>，强制在线。</p>\n</blockquote>\n<ul>\n<li>题目名字是真在降低难度吧，强制在线就排除离线历史和了；猜测询问所求可以化成一个比较简单的东西。</li>\n<li><p>推一下：</p>\n<p>（省略）</p>\n<p><span class=\"math display\">\\[\n=-\\left(\\sum_{i=l}^r i\\cdot a_i\\right)^2 + (1-l)(r+1)\\left(\\sum_{i=l}^r a_i\\right)^2+(l+r)\\left(\\sum_{i=l}^r i\\cdot a_i\\right)\\left(\\sum_{i=l}^r a_i\\right)\n\\]</span></p></li>\n<li>故线段树维护 <span class=\"math inline\">\\(\\sum a_i\\)</span> 和 <span class=\"math inline\">\\(\\sum i\\cdot a_i\\)</span> 即可。</li>\n<li><p><a href=\"/20251010/#excercise\">实际上可以用树状数组维护</a>。</p></li>\n</ul>\n<details>\n<p>喜提最优解，不得不说 bit 的速度优势还是很明显的。</p>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 998244353; \nconst int inv2 = (mod + 1) &gt;&gt; 1;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n    std::freopen(&quot;offset.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;offset.out&quot;, &quot;w&quot;, stdout);\n#else\n    std::freopen(&quot;./test/20251008/offset/ex_offset5.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int T, n, q;\n    std::cin &gt;&gt; T &gt;&gt; n &gt;&gt; q;\n    std::vector&lt;long long&gt; bit(n + 1), bit1(n + 1), bit2(n + 1);\n    auto lowbit = [&amp;](int x) &#123;\n        return x &amp; -x;\n    &#125;;\n    auto add = [&amp;](long long x, long long v) &#123;\n        auto v1 = x * v % mod, v2 = x * x % mod * v % mod;\n        for (; x &lt;= n; x += lowbit(x)) &#123;\n            (bit[x] += v) %= mod;\n            (bit1[x] += v1) %= mod;\n            (bit2[x] += v2) %= mod;\n        &#125;\n        return;\n    &#125;;\n    auto ask = [&amp;](long long x) &#123;\n        auto res = 0ll, res1 = 0ll, res2 = 0ll;\n        for (int i = x; i; i -= lowbit(i))\n            (res += bit[i]) %= mod, (res1 += bit1[i]) %= mod, (res2 += bit2[i]) %= mod;\n        return std::make_pair(((x + 1) * res + mod - res1) % mod, (x * (x + 1) % mod * res % mod + res1 + mod - res2) * inv2 % mod);\n    &#125;;\n    for (int i = 1, x; i &lt;= n; ++i)\n        std::cin &gt;&gt; x, add(i, x), add(i + 1, mod - x);\n    for (int op; q--; ) &#123;\n        static auto la = 0ll;\n        std::cin &gt;&gt; op;\n        if (op == 1) &#123;\n            int l, r, d;\n            std::cin &gt;&gt; l &gt;&gt; r &gt;&gt; d;\n            if (T == 1)\n                l ^= la, r ^= la, d ^= la;\n            add(l, d), add(r + 1, mod - d);\n        &#125;\n        else &#123;\n            long long l, r;\n            std::cin &gt;&gt; l &gt;&gt; r;\n            if (T == 1)\n                l ^= la, r ^= la;\n            auto t1 = ask(r), t2 = ask(l - 1);\n            auto res1 = t1.first + mod - t2.first, res2 = t1.second + mod - t2.second;\n            la = (mod - res2 * res2 % mod + mod - (l - 1) * (r + 1) % mod * res1 % mod * res1 % mod + (l + r) * res1 % mod * res2 % mod) % mod;\n            std::cout &lt;&lt; la &lt;&lt; &#39;\\n&#39;;\n        &#125;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"a.-happylovelyeveryday\">A. Happy·Lovely·Everyday!</h2>\n<p><a href=\"https://www.becoder.com.cn/contest/6639/problem/1\" class=\"uri\">https://www.becoder.com.cn/contest/6639/problem/1</a></p>\n<blockquote>\n<p>给定一个长为 <span class=\"math inline\">\\(n\\)</span> 的 01 序列，可以执行任意次（可以为 <span class=\"math inline\">\\(0\\)</span>）『把相邻两个数合并为其异或值』的操作，问最终能得到的本质不同的序列个数。</p>\n<p><span class=\"math inline\">\\(n\\le 2\\times 10^6\\)</span>。</p>\n</blockquote>\n<ul>\n<li>对于一个最终序列，如果认为它是由某个存活元素『吞并』它左侧的连续死亡元素得到的，会发现最终序列中，此处的前缀异或值就是原序列的前缀异或值。</li>\n<li>经典 trick：前缀和可以唯一对应原数组。所以『最终本质不同序列』会和『包含第 <span class=\"math inline\">\\(n\\)</span> 个元素的，原序列前缀异或和的本质不同子序列』形成双射。</li>\n<li><p>统计包含第 <span class=\"math inline\">\\(n\\)</span> 个元素的，原序列前缀异或和的本质不同子序列即可。复杂度 <span class=\"math inline\">\\(O(n)\\)</span>。</p>\n<details>\n<p><summary>How to 本质不同子序列？</summary></p>\n<p>令 <span class=\"math inline\">\\(f_i\\)</span> 表示 DP 到 <span class=\"math inline\">\\(i\\)</span>，且强制选 <span class=\"math inline\">\\(i\\)</span> 的本质不同子序列数量，记 <span class=\"math inline\">\\(pre_i\\)</span> 为 <span class=\"math inline\">\\(i\\)</span> 的前驱（没有则为 <span class=\"math inline\">\\(0\\)</span>）。令 <span class=\"math inline\">\\(f_0=1\\)</span>，那么：</p>\n<p><span class=\"math display\">\\[\nf_i\\gets \\sum\\limits_{j=pre_i}^{i-1} f_{j}\n\\]</span></p>\n<p>或，令 <span class=\"math inline\">\\(f_i\\)</span> 表示 DP 到 <span class=\"math inline\">\\(i\\)</span> 时（不强制选 <span class=\"math inline\">\\(i\\)</span>）本质不同子序列数量，记 <span class=\"math inline\">\\(pre_i\\)</span> 为 <span class=\"math inline\">\\(i\\)</span> 的前驱（没有则为 <span class=\"math inline\">\\(0\\)</span>）。令 <span class=\"math inline\">\\(f_0=0\\)</span>，那么：</p>\n<p><span class=\"math display\">\\[\nf_i=\\begin{cases}\n2\\cdot f_{i-1}+1&amp;pre_i= 0\\\\\n2\\cdot f_{i-1}-f_{pre_i-1}&amp;\\text{otherwise}\n\\end{cases}\n\\]</span></p>\n</details>\n<details>\n<p><summary>How to 强制选第 <span class=\"math inline\">\\(n\\)</span> 个元素的本质不同子序列？</summary></p>\n<p>令 <span class=\"math inline\">\\(f_i\\)</span> 表示 DP 到 <span class=\"math inline\">\\(i\\)</span>，且强制选 <span class=\"math inline\">\\(i\\)</span> 的本质不同子序列数量，则答案为：</p>\n<p><span class=\"math display\">\\[\n\\sum\\limits_{a_i=a_n} f_i\n\\]</span></p>\n<p>或，令 <span class=\"math inline\">\\(f_i\\)</span> 表示 DP 到 <span class=\"math inline\">\\(i\\)</span>，且不强制选 <span class=\"math inline\">\\(i\\)</span> 的本质不同子序列数量，则答案为：</p>\n<p><span class=\"math display\">\\[\n\\sum\\limits_{a_i=a_n}\\begin{cases}\nf_{i-1}+1&amp;pre_i= 0\\\\\nf_{i-1}-f_{pre_i-1}&amp;\\text{otherwise}\n\\end{cases}\n\\]</span></p>\n</details></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 998244353;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n    std::freopen(&quot;a.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;a.out&quot;, &quot;w&quot;, stdout);\n#else\n    std::freopen(&quot;./test/20251014/a/a1.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int T;\n    for (std::cin &gt;&gt; T; T--; ) &#123;\n        std::string s;\n        std::cin &gt;&gt; s;\n        int n = (int)s.length();\n        s = &quot;#&quot; + s;\n        std::vector&lt;int&gt; a(n + 1);\n        for (int i = 1; i &lt;= n; ++i)\n            a[i] = a[i - 1] ^ (s[i] - &#39;0&#39;);\n        auto res = 0ll;\n        std::vector&lt;long long&gt; f(n + 1), la(2);\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            if (la[a[i]])\n                f[i] = (2 * f[i - 1] + mod - f[la[a[i]] - 1]) % mod;\n            else\n                f[i] = (2 * f[i - 1] + 1) % mod;\n            if (a[i] == a[n]) &#123;\n                if (la[a[i]])\n                    res += (f[i - 1] + mod - f[la[a[i]] - 1]) % mod;\n                else\n                    res += f[i - 1] + 1;\n            &#125;\n            la[a[i]] = i;\n        &#125;\n        std::cout &lt;&lt; res % mod &lt;&lt; &#39;\\n&#39;;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"b.-敬启致那时的我\">B. 敬启，致那时的我</h2>\n<p><a href=\"https://www.becoder.com.cn/contest/6639/problem/2\" class=\"uri\">https://www.becoder.com.cn/contest/6639/problem/2</a></p>\n<blockquote>\n<p>定义 <span class=\"math inline\">\\(f_0=f_1=1,f_i=f_{i-1}+f_{i-2}\\)</span>，给定 <span class=\"math inline\">\\(n,k\\)</span>，求：</p>\n<p><span class=\"math display\">\\[\n\\left(\\sum_{i=0}^n f_{i}\\cdot [\\text{popcount}(i)=k]\\right)\\bmod 10^9+7\n\\]</span></p>\n<p><span class=\"math inline\">\\(n\\le 2^{2000},0\\le k\\le \\log_2(n)\\)</span>。</p>\n</blockquote>\n<ul>\n<li>考虑数位 DP，那么需要能够由 <code>...xxx</code> 向 <code>...0xxx</code> 和 <code>...1xxx</code> 转移。</li>\n<li><p>显然只关心向 <code>...1xxx</code> 的转移，那么需要再转移 <span class=\"math inline\">\\(2^{?}\\)</span> 次，记录转移矩阵的 <span class=\"math inline\">\\(2^{?}\\)</span> 次方即可。</p>\n<p>这一步也可以不用矩阵，而是用斐波那契 <span class=\"math inline\">\\(f(ab)=...\\)</span> 的性质，但显然二者是等价的，无甚必要</p></li>\n<li><p>根据数位 DP 的实现方式，常数上顺序结构肯定是会吊打递归的。然而并不惯写顺序结构的数位 DP，whatever.</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 1e9 + 7;\nstruct matrix &#123;\n    long long a[2][2];\n    matrix() &#123;\n        a[0][0] = a[0][1] = a[1][0] = a[1][1] = 0ll;\n        return;\n    &#125;\n    long long* operator[] (const int q) &#123;\n        return a[q];\n    &#125;\n    matrix operator* (matrix &amp;q) const &#123;\n        matrix res;\n        res[0][0] = (a[0][0] * q[0][0] + a[0][1] * q[1][0]) % mod;\n        res[0][1] = (a[0][0] * q[0][1] + a[0][1] * q[1][1]) % mod;\n        res[1][0] = (a[1][0] * q[0][0] + a[1][1] * q[1][0]) % mod;\n        res[1][1] = (a[1][0] * q[0][1] + a[1][1] * q[1][1]) % mod;\n        return res;\n    &#125;\n    matrix&amp; operator+= (matrix q) &#123;\n        if ((a[0][0] += q[0][0]) &gt;= mod) a[0][0] -= mod;\n        if ((a[0][1] += q[0][1]) &gt;= mod) a[0][1] -= mod;\n        if ((a[1][0] += q[1][0]) &gt;= mod) a[1][0] -= mod;\n        if ((a[1][1] += q[1][1]) &gt;= mod) a[1][1] -= mod;\n        return *this;\n    &#125;\n&#125;;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n    std::freopen(&quot;b.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;b.out&quot;, &quot;w&quot;, stdout);\n#else\n    std::freopen(&quot;./test/20251014/b/b4.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, k;\n    std::cin &gt;&gt; n &gt;&gt; k;\n    std::vector&lt;int&gt; up(n);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        char t;\n        std::cin &gt;&gt; t, up[n - i] = t - &#39;0&#39;;\n    &#125;\n    matrix init, zmat;\n    init[0][0] = init[0][1] = 1ll;\n    std::vector&lt;matrix&gt; mat(n);\n    mat[0][0][1] = mat[0][1][0] = mat[0][1][1] = 1ll;\n    for (int i = 1; i &lt; n; ++i)\n        mat[i] = mat[i - 1] * mat[i - 1];\n    std::vector&lt;std::vector&lt;int&gt; &gt; tag(n, std::vector&lt;int&gt; (k + 1));\n    std::vector&lt;std::vector&lt;matrix&gt; &gt; f(n, std::vector&lt;matrix&gt; (k + 1));\n    std::function&lt;matrix(int, int, int)&gt; DFS = [&amp;](int x, int k, int fl) &#123;\n        if (x == -1) &#123;\n            if (k == 0)\n                return init;\n            return zmat;\n        &#125;\n        if (!fl &amp;&amp; tag[x][k])\n            return f[x][k];\n        matrix res = DFS(x - 1, k, fl &amp;&amp; !up[x]);\n        if (k &amp;&amp; (!fl || up[x]))\n            res += DFS(x - 1, k - 1, fl) * mat[x];\n        if (!fl)\n            tag[x][k] = 1, f[x][k] = res;\n        return res;\n    &#125;;\n    std::cout &lt;&lt; DFS(n - 1, k, 1)[0][0] &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"c.-lead-to-shine-more\">C. Lead to shine more</h2>\n<p><a href=\"https://www.becoder.com.cn/contest/6639/problem/3\" class=\"uri\">https://www.becoder.com.cn/contest/6639/problem/3</a></p>\n<blockquote>\n<p>第 <span class=\"math inline\">\\(0\\)</span> 次操作时变量 <span class=\"math inline\">\\(x=1\\)</span>，此后每次操作使 <span class=\"math inline\">\\(x\\gets x+\\text{popcount}(x)\\)</span>，给定 <span class=\"math inline\">\\(m\\)</span> 次询问：</p>\n<ul>\n<li>给定 <span class=\"math inline\">\\(x&#39;\\)</span>，问 <span class=\"math inline\">\\(x\\)</span> 在第几次操作后变为 <span class=\"math inline\">\\(x&#39;\\)</span>，或报告 <span class=\"math inline\">\\(x&#39;\\)</span> 不会被经过。</li>\n</ul>\n<p><span class=\"math inline\">\\(m\\le 10^5,x&#39;\\le 10^{18}\\)</span>。</p>\n</blockquote>\n<ul>\n<li>一个朴素的想法是分高低位，则因为每次操作带来的变化量不超过 60，远远低于低位的 <span class=\"math inline\">\\(2^30\\)</span>，所以一次操作至多给高位带来 1 的变化量。</li>\n<li><p>高位对整体的贡献只取决于其 popcount，所以可以枚举高位 1 的数量，再枚举初始值，找到第一次让高位变化花的次数。</p>\n<p>初始值的可能值有 <span class=\"math inline\">\\(60\\)</span> 个，而外层循环有 <span class=\"math inline\">\\(30\\)</span> 次，内层循环大概是 <span class=\"math inline\">\\(\\dfrac {2^{30}}{60}\\)</span> 的，总之无法通过。</p></li>\n<li><p>题解说方法是对上面的拓展。理解不能。出发点大概是考虑到让第 <span class=\"math inline\">\\(i\\)</span> 位变化相当于让 <span class=\"math inline\">\\(i+1\\)</span> 位变化两次，所以会有一个递推的关系。</p>\n<p>令 <span class=\"math inline\">\\(f_{i, s, d}\\)</span> 为前 <span class=\"math inline\">\\(i-1\\)</span> 位的 popcount 为 <span class=\"math inline\">\\(d\\)</span>，初始值为 <span class=\"math inline\">\\(s\\)</span>，让 <span class=\"math inline\">\\(i\\)</span> 位变化一次的操作次数；<span class=\"math inline\">\\(g_{i,s,d}\\)</span> 为上述变化后 <span class=\"math inline\">\\(x\\)</span> 的值。记 <span class=\"math inline\">\\(pos=g_{i-1,s,d}\\)</span>，那么有：</p>\n<p><span class=\"math display\">\\[\ng_{i,pos,d}=g_{i-1,pos,d+1}\\\\\nf_{i,pos,d}=f_{i-1,s,d}+f_{i-1,pos,d+1}\n\\]</span></p>\n<p>其实是一个类似<strong>倍增</strong>的结构。但恕我实在无法解释怎么想到的。</p></li>\n<li>显然这个式子在 <span class=\"math inline\">\\(i\\le 5\\)</span> 时是有问题的，这部分我们暴力跑即可。忽略这一部分常数，预处理总复杂度 <span class=\"math inline\">\\(O(\\log^3 n)\\)</span>。</li>\n<li><p>考虑查询，按照类似数位 DP 的方法从高位到低位模拟进位过程即可。复杂度 <span class=\"math inline\">\\(O(\\log n)\\)</span>。</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n    std::freopen(&quot;c.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;c.out&quot;, &quot;w&quot;, stdout);\n#else\n    std::freopen(&quot;./test/20251014/c/c1.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    using arr = std::vector&lt;long long&gt;;\n    using brr = std::vector&lt;arr&gt;;\n    using crr = std::vector&lt;brr&gt;;\n    crr f(61, brr(256, arr(61))), g(61, brr(256, arr(61)));\n    for (int s = 0; s &lt; 256; ++s)\n        for (int d = 0; d &lt;= 60; ++d)\n            if (d || s) &#123;\n                int x = s, cnt = 0;\n                for (; x &lt; 256; x += __builtin_popcount(x) + d, ++cnt);\n                f[8][s][d] = cnt, g[8][s][d] = x &amp; 255;\n            &#125;\n    for (int i = 9; i &lt;= 60; ++i)\n        for (int s = 0; s &lt; 256; ++s)\n            for (int d = 0; d &lt; 60; ++d) &#123;\n                int pos = g[i - 1][s][d];\n                g[i][s][d] = g[i - 1][pos][d + 1];\n                f[i][s][d] = f[i - 1][s][d] + f[i - 1][pos][d + 1];\n            &#125;\n    int m;\n    std::cin &gt;&gt; m;\n    for (long long x; m--; ) &#123;\n        std::cin &gt;&gt; x;\n        auto pos = 1ll, cnt = 0ll, tot = 0ll;\n        for (int i = 60; i &gt;= 8; --i)\n            if ((x &gt;&gt; i) &amp; 1) &#123;\n                cnt += f[i][pos][tot];\n                pos = g[i][pos][tot++];\n            &#125;\n        for (; pos &lt; (x &amp; 255); pos += __builtin_popcountll(pos) + tot, ++cnt);\n        // std::cout &lt;&lt; pos &lt;&lt; &#39; &#39; &lt;&lt; cnt &lt;&lt; &#39;\\n&#39;;\n        if (pos == (x &amp; 255))\n            std::cout &lt;&lt; cnt &lt;&lt; &#39;\\n&#39;;\n        else\n            std::cout &lt;&lt; -1 &lt;&lt; &#39;\\n&#39;;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"c.-query-on-a-tree-17\">C. Query On A Tree 17</h2>\n<p><a href=\"https://codeforces.com/gym/102759/problem/I\" class=\"uri\">https://codeforces.com/gym/102759/problem/I</a></p>\n<blockquote>\n<p>给定一个以 <span class=\"math inline\">\\(1\\)</span> 为根的树，点权初始为全 <span class=\"math inline\">\\(0\\)</span>。维护 <span class=\"math inline\">\\(m\\)</span> 次修改：</p>\n<ul>\n<li><code>1 u</code>，表示把 <span class=\"math inline\">\\(u\\)</span> 子树内的点权加一。</li>\n<li><code>2 u v</code>，表示把 <span class=\"math inline\">\\(u,v\\)</span> 简单路径上的点权加一。</li>\n</ul>\n<p>每次修改后，输出树深度最小的带权重心。</p>\n<p><span class=\"math inline\">\\(n,m\\le 10^5\\)</span>。</p>\n</blockquote>\n<ul>\n<li><p>考虑链上的问题，考虑一点小奥做法，把所有点重复其出现次数次，从左到右排列，发现答案在中位数上。</p>\n<p>（据组题人所言），这是用来提示正解的。事实上，这是一个和带权重心有关的 trick：</p>\n<blockquote>\n<p>若一个点 <span class=\"math inline\">\\(u\\)</span> 是<strong>深度最小的</strong>带权重心，则其子树权值和必须<strong>严格大于</strong>总权值的一半。</p>\n</blockquote>\n<p>证明显然，但结论不显然。Whatever.</p></li>\n<li><p>由这一点会得到，（参照链上的做法），把点重复点权次，并按 dfn 排成一行，取中位数，那么取到的一定在<strong>深度最小的</strong>重心子树内，（这就是组题人说的提示正解）。</p>\n<p>这一点反而没那么显然，推导过程是，<strong>深度最小的</strong>重心的子树占了大于一半，而其 dfn 又是连续的，（类似滑动窗口），故总能够到中位数。</p>\n<p>考虑非深度最小的重心，此时就从<strong>严格大于</strong>变为<strong>不严格大于</strong>，导致没有办法很好地精准找到，需要从中位数左右偏移一位，显然是很丑陋的。</p></li>\n<li><p>因此可以考虑线段树上二分找到中位数（容易发现线段树的 <span class=\"math inline\">\\(x\\)</span> 轴本来就是 dfn），然后从这个中位数往上跳，一直跳到满足『子树权值和严格大于总权值一半』的点，就是最浅的重心。</p>\n<p>这一点采用倍增即可。</p></li>\n</ul>\n",
            "tags": [
                "DP",
                "树状数组",
                "倍增",
                "贪心"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20250924/",
            "url": "https://xsc062.netlify.app/20250924/",
            "title": "杂题选谈：最短路",
            "date_published": "2025-09-24T06:27:15.000Z",
            "content_html": "<p>最短路为背景的题 + 做法是最短路的题</p>\n<span id=\"more\"></span>\n<hr />\n<h2 id=\"a---minimum-path\">A - Minimum Path</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/CF1473E\" class=\"uri\">https://www.luogu.com.cn/problem/CF1473E</a></p>\n<ul>\n<li>经典套路，发现可以把 max 和 min 换成任意路径中的边，然后 max 和 min 就会最小化这个式子</li>\n<li>故写一个 Dijkstra + DP，求这个式子的最小值即可</li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, m;\n    std::cin &gt;&gt; n &gt;&gt; m;\n    using arr = std::vector&lt;long long&gt;;\n    using brr = std::vector&lt;arr&gt;;\n    std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; g(n + 1);\n    std::vector&lt;brr&gt; dis(2, brr(2, arr(n + 1, 1e18))), vis(2, brr(2, arr(n + 1)));\n    for (int x, y, w; m--; ) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y &gt;&gt; w;\n        g[x].emplace_back(y, w);\n        g[y].emplace_back(x, w);\n    &#125;\n    dis[0][0][1] = 0;\n    std::array&lt;std::array&lt;std::priority_queue&lt;std::pair&lt;long long, int&gt; &gt;, 2&gt;, 2&gt; q;\n    q[0][0].emplace(0, 1);\n    for (int i = 0; i &lt; 2; ++i) &#123;\n        for (int j = 0; j &lt; 2; ++j) &#123;\n            for (; !q[i][j].empty(); ) &#123;\n                int f = q[i][j].top().second;\n                q[i][j].pop();\n                if (vis[i][j][f])\n                    continue;\n                vis[i][j][f] = 1;\n                for (auto k : g[f]) &#123;\n                    if (dis[i][j][k.first] &gt; dis[i][j][f] + k.second) &#123;\n                        dis[i][j][k.first] = dis[i][j][f] + k.second;\n                        q[i][j].emplace(-dis[i][j][k.first], k.first);\n                    &#125;\n                    if (!i &amp;&amp; dis[1][j][k.first] &gt; dis[i][j][f]) &#123;\n                        dis[1][j][k.first] = dis[i][j][f];\n                        q[1][j].emplace(-dis[1][j][k.first], k.first);\n                    &#125;\n                    if (!j &amp;&amp; dis[i][1][k.first] &gt; dis[i][j][f] + 2 * k.second) &#123;\n                        dis[i][1][k.first] = dis[i][j][f] + 2 * k.second;\n                        q[i][1].emplace(-dis[i][1][k.first], k.first);\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n    for (int i = 2; i &lt;= n; ++i)\n        std::cout &lt;&lt; std::min(&#123; dis[0][0][i], dis[1][1][i] &#125;) &lt;&lt; &#39; &#39;;\n    std::cout &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"b---train-delay\">B - Train Delay</h2>\n<p><a href=\"https://vjudge.net/contest/750645#problem/B\" class=\"uri\">https://vjudge.net/contest/750645#problem/B</a></p>\n<ul>\n<li>简化题目很重要的一个转化是<strong>由于 <span class=\"math inline\">\\(S\\le T\\)</span> 带来的 <span class=\"math inline\">\\(S\\)</span> 和 <span class=\"math inline\">\\(T\\)</span> 地位平等，考虑把出发和到达分别看作一次事件处理。</strong></li>\n<li><p>按照所有事件的发生时刻排序，有：</p>\n<ul>\n<li>对于一次出发事件，可以得到在其之前该站点所有到达事件的 <span class=\"math inline\">\\(\\max\\{T&#39;\\}\\)</span>，用之更新 <span class=\"math inline\">\\(X\\)</span> 即可。</li>\n<li>对于一次到达事件，由于对应的 <span class=\"math inline\">\\(X\\)</span> 已经确定，更新该站点当前最大值即可。</li>\n</ul></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, m;\n    std::cin &gt;&gt; n &gt;&gt; m;\n    std::vector&lt;int&gt; d(m + 1);\n    std::cin &gt;&gt; d[1];\n    struct event &#123;\n        int t, op, id, x;\n    &#125;;\n    std::vector&lt;event&gt; a;\n    std::vector&lt;int&gt; mx(n + 1);\n    for (int i = 1, x, y, s, t; i &lt;= m; ++i) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y &gt;&gt; s &gt;&gt; t;\n        a.push_back(&#123; s, 0, i, x &#125;);\n        a.push_back(&#123; t, 1, i, y &#125;);\n    &#125;\n    std::sort(a.begin(), a.end(), [&amp;](event &amp;x, event &amp;y) &#123; return x.t == y.t ? x.op &gt; y.op : x.t &lt; y.t; &#125;);\n    for (auto [t, op, id, x] : a)\n        if (op == 1)\n            mx[x] = std::max(mx[x], t + d[id]);\n        else if (id != 1)\n            d[id] = std::max(mx[x] - t, 0);\n    for (int i = 2; i &lt;= m; ++i)\n        std::cout &lt;&lt; d[i] &lt;&lt; &#39; &#39;;\n    std::cout &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"c---complete-the-graph\">C - Complete The Graph</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/CF715B\" class=\"uri\">https://www.luogu.com.cn/problem/CF715B</a></p>\n<p>神仙二分</p>\n<ul>\n<li>如果初始把所有白边置为 <span class=\"math inline\">\\(1\\)</span>，那么会想到调整法构造</li>\n<li>但是不知道应该在哪些边上调整，确定调整多少似乎也没有什么简单的做法</li>\n<li><p>故<strong>平均用力</strong>，构造一个 边1 += 1，边2 += 1，边3 += 1, …, 边cnt0 += 1, 边1 += 1, 边2 += 1, … 的操作序列</p>\n容易<strong>发现每次操作最多让当前最短路长度增加 1</strong>，而且有单调性</li>\n<li><p>故二分答案即可</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst __int128 inf = 1e18;\nconst __int128 inff = 1e23;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, m, s, t, l, cnt = 0;\n    std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; l &gt;&gt; s &gt;&gt; t, ++s, ++t;\n    std::vector&lt;std::tuple&lt;int, int, long long&gt; &gt; u(m + 1);\n    std::vector&lt;std::vector&lt;std::pair&lt;int, long long&gt; &gt; &gt; g(n + 1);\n    for (int i = 1, x, y; i &lt;= m; ++i) &#123;\n        long long w;\n        std::cin &gt;&gt; x &gt;&gt; y &gt;&gt; w, ++x, ++y;\n        if (w == 0)\n            w = -(++cnt);\n        g[x].emplace_back(y, w), g[y].emplace_back(x, w);\n        u[i] = &#123; x, y, w &#125;;\n    &#125;\n    std::vector&lt;int&gt; vis(n + 1);\n    std::vector&lt;__int128&gt; dis(n + 1);\n    std::vector&lt;long long&gt; k(cnt + 1);\n    __int128 res = -1;\n    auto check = [&amp;](__int128 x) &#123;\n        for (int i = 1; i &lt;= cnt; ++i)\n            k[i] = x / cnt + (i &lt;= x % cnt);\n        std::fill(vis.begin() + 1, vis.end(), 0);\n        std::fill(dis.begin() + 1, dis.end(), inf);\n        std::priority_queue&lt;std::pair&lt;__int128, int&gt; &gt; q;\n        dis[s] = 0, q.emplace(0, s);\n        for (; !q.empty(); ) &#123;\n            int f = q.top().second;\n            q.pop();\n            if (vis[f])\n                continue;\n            vis[f] = 1;\n            for (auto [v, w] : g[f]) &#123;\n                if (w &lt; 0)\n                    w = k[-w];\n                if (dis[v] &gt; dis[f] + w) &#123;\n                    dis[v] = dis[f] + w;\n                    q.emplace(-dis[v], v);\n                &#125;\n            &#125;\n        &#125;\n        return dis[t] &lt;= l;\n    &#125;;\n    for (__int128 l = cnt, r = cnt * inf, mid; l &lt;= r; ) &#123;\n        mid = (l + r) &gt;&gt; 1;\n        if (check(mid))\n            res = mid, l = mid + 1;\n        else\n            r = mid - 1;\n    &#125;\n    if (res == -1)\n        std::cout &lt;&lt; &quot;NO\\n&quot;;\n    else &#123;\n        check(res);\n        if (dis[t] != l)\n            std::cout &lt;&lt; &quot;NO\\n&quot;;\n        else &#123;\n            std::cout &lt;&lt; &quot;YES\\n&quot;;\n            for (int i = 1; i &lt;= m; ++i) &#123;\n                auto [x, y, w] = u[i];\n                if (w &lt; 0)\n                    w = k[-w];\n                std::cout &lt;&lt; x - 1 &lt;&lt; &#39; &#39; &lt;&lt; y - 1 &lt;&lt; &#39; &#39; &lt;&lt; w &lt;&lt; &#39;\\n&#39;;\n            &#125;\n        &#125;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"a---重力球\">A - 重力球</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P7473\" class=\"uri\">https://www.luogu.com.cn/problem/P7473</a></p>\n<ul>\n<li><span class=\"math inline\">\\(m\\)</span> 相对很小，看看有没有什么基于 <span class=\"math inline\">\\(m\\)</span> 的做法</li>\n<li>每次球停下的位置一定是某个障碍物（或边界）上 / 下 / 左 / 右的格子，故可以在这 <span class=\"math inline\">\\(O(n + m)\\)</span> 个点上建图</li>\n<li>怎么同时维护两个球的信息呢，发现 <span class=\"math inline\">\\(m\\)</span> 还是很小，所以可以把两个球塞一起作为一个状态</li>\n<li><p><span class=\"math inline\">\\(m^2\\)</span> 次 Dij 还是太激进了 进一步思考发现可能的终点共 <span class=\"math inline\">\\(m\\)</span> 个 并且彼此不区分</p>\n<p>故以这 <span class=\"math inline\">\\(m\\)</span> 个终点跑多源最短路即可</p>\n<p>但 5e6 跑 Dij 还是太勉强了。<strong>发现边权为 1，为什么不 BFS 呢 😅</strong></p></li>\n<li><p>发现起点可能不在我们限定的点上，但可以人为选择一次重力方向，然后就回到刚刚的问题了</p>\n<p>或者离线也是一种方法</p></li>\n</ul>\n<p>疑似常数太大，拼尽全力勉强卡过</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int LEN = (1 &lt;&lt; 20);\n#ifdef ONLINE_JUDGE\ninline int nec(void) &#123;\n    static char buf[LEN], *p = buf, *e = buf;\n    if (p == e) &#123;\n        e = buf + fread(buf, 1, LEN, stdin);\n        if (e == buf)\n            return EOF;\n        p = buf;\n    &#125;\n    return *p++;\n&#125;\n#else\n#define nec getchar\n#endif\ninline bool read(int &amp;x) &#123;\n    x = 0;\n    bool f = 0;\n    char ch = nec();\n    while (ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123;\n        if (ch == EOF)\n            return 0;\n        if (ch == &#39;-&#39;)\n            f = 1;\n        ch = nec();\n    &#125;\n    while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) &#123;\n        x = x * 10 + ch - &#39;0&#39;;\n        ch = nec();\n    &#125;\n    if (f)\n        x = -x;\n    return 1;\n&#125;\nvoid print(int x) &#123;\n    if (x &lt; 0) &#123;\n        putchar(&#39;-&#39;);\n        x = -x;\n    &#125;\n    if (x &gt;= 10)\n        print(x / 10);\n    putchar(x % 10 + &#39;0&#39;);\n    return;\n&#125;\nvoid print(int x, char ch) &#123;\n    print(x);\n    putchar(ch);\n    return;\n&#125;\nconst int inf = 0x3f3f3f3f;\nconst int dir[][2] = &#123;&#123; -1, 0 &#125;, &#123; 1, 0 &#125;, &#123; 0, -1 &#125;, &#123; 0, 1 &#125;&#125;;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, m, q;\n    read(n), read(m), read(q);\n    std::vector&lt;std::pair&lt;int, int&gt; &gt; pos(m + 1);\n    std::vector&lt;std::vector&lt;int&gt; &gt; a(n + 1, std::vector&lt;int&gt; (n + 1));\n    for (int i = 1, x, y; i &lt;= m; ++i) &#123;\n        read(x), read(y);\n        pos[i] = &#123; x, y &#125;, a[x][y] = -1;\n    &#125;\n    for (int i = 1; i &lt;= n; ++i)\n        pos.emplace_back(0, i), ++m;\n    for (int i = 1; i &lt;= n; ++i)\n        pos.emplace_back(i, n + 1), ++m;\n    for (int i = 1; i &lt;= n; ++i)\n        pos.emplace_back(n + 1, i), ++m;\n    for (int i = 1; i &lt;= n; ++i)\n        pos.emplace_back(i, 0), ++m;\n    int cnt = 0;\n    std::vector&lt;std::pair&lt;int, int&gt; &gt; u(1);\n    for (int i = 1; i &lt;= m; ++i)\n        for (auto [fx, fy] : dir) &#123;\n            int nx = pos[i].first + fx, ny = pos[i].second + fy;\n            if (nx &gt;= 1 &amp;&amp; nx &lt;= n &amp;&amp; ny &gt;= 1 &amp;&amp; ny &lt;= n &amp;&amp; !a[nx][ny])\n                a[nx][ny] = ++cnt, u.emplace_back(nx, ny);\n        &#125;\n    std::vector&lt;std::vector&lt;std::array&lt;int, 4&gt; &gt; &gt; top(n + 1, std::vector&lt;std::array&lt;int, 4&gt; &gt; (n + 1));\n    for (int j = 1; j &lt;= n; ++j) &#123;\n        for (int i = 1; i &lt;= n; ++i)\n            if (a[i][j] != -1) &#123;\n                if (i == 1 || a[i - 1][j] == -1)\n                    top[i][j][0] = a[i][j];\n                else\n                    top[i][j][0] = top[i - 1][j][0];\n            &#125;\n        for (int i = n; i; --i)\n            if (a[i][j] != -1) &#123;\n                if (i == n || a[i + 1][j] == -1)\n                    top[i][j][1] = a[i][j];\n                else\n                    top[i][j][1] = top[i + 1][j][1];\n            &#125;\n    &#125;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        for (int j = 1; j &lt;= n; ++j)\n            if (a[i][j] != -1) &#123;\n                if (j == 1 || a[i][j - 1] == -1)\n                    top[i][j][2] = a[i][j];\n                else\n                    top[i][j][2] = top[i][j - 1][2];\n            &#125;\n        for (int j = n; j; --j)\n            if (a[i][j] != -1) &#123;\n                if (j == n || a[i][j + 1] == -1)\n                    top[i][j][3] = a[i][j];\n                else\n                    top[i][j][3] = top[i][j + 1][3];\n            &#125;\n    &#125;\n    const int N = cnt * cnt;\n    std::vector&lt;std::vector&lt;int&gt; &gt; g(N + 1);\n    auto encode = [&amp;](int x, int y) &#123;\n        return (x - 1) * cnt + y;\n    &#125;;\n    auto decode = [&amp;](int id) &#123;\n        return std::make_pair((id - 1) / cnt + 1, (id - 1) % cnt + 1);\n    &#125;;\n    for (int i = 1; i &lt;= N; ++i)\n        for (int j = 0; j &lt; 4; ++j) &#123;\n            auto [a, b] = decode(i);\n            g[encode(top[u[a].first][u[a].second][j], top[u[b].first][u[b].second][j])].emplace_back(i);\n        &#125;\n    std::vector&lt;int&gt; dis(N + 1, inf), vis(N + 1);\n    &#123;\n        std::queue&lt;int&gt; q;\n        for (int i = 1; i &lt;= cnt; ++i)\n            dis[encode(i, i)] = 0, q.push(encode(i, i)), vis[encode(i, i)] = 1;\n        for (; !q.empty(); ) &#123;\n            int x = q.front();\n            q.pop();\n            for (auto i : g[x])\n                if (!vis[i])\n                    dis[i] = dis[x] + 1, vis[i] = 1, q.push(i);\n        &#125;\n    &#125;\n    for (int a, b, c, d; q--; ) &#123;\n        read(a), read(b), read(c), read(d);\n        if (a == c &amp;&amp; b == d)\n            print(0, &#39;\\n&#39;);\n        else &#123;\n            int res = inf;\n            for (int j = 0; j &lt; 4; ++j)\n                res = std::min(res, dis[encode(top[a][b][j], top[c][d][j])] + 1);\n            if (res == inf)\n                print(-1, &#39;\\n&#39;);\n            else\n                print(res, &#39;\\n&#39;);\n        &#125;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"b---矩阵游戏\">B - 矩阵游戏</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P7515\" class=\"uri\">https://www.luogu.com.cn/problem/P7515</a></p>\n<ul>\n<li><p>把问题形式化一下，现在有 <span class=\"math inline\">\\(n\\times m\\)</span> 个未知数和 <span class=\"math inline\">\\((n-1)\\times (m-1)\\)</span> 个方程</p>\n<p>那么可以对边上一圈任意赋值，限制是左上角这 <span class=\"math inline\">\\((n-1)\\times (m-1)\\)</span> 个未知数必须落在 <span class=\"math inline\">\\([0,10^6]\\)</span> 上</p></li>\n<li>有一个很容易观察到的性质，对于一个 <span class=\"math inline\">\\(a\\)</span>，选取一个 <span class=\"math inline\">\\(v\\)</span>，并把棋盘黑白染色，那么把所有黑格 <span class=\"math inline\">\\(+=v\\)</span>，白格 <span class=\"math inline\">\\(-=v\\)</span>，对应的 <span class=\"math inline\">\\(b\\)</span> 是不会变的。</li>\n<li><p><strong>这个操作是涉及全局的，太苛刻了</strong>，有没有什么更 mild 的构造？</p>\n<p>发现只对一行 / 列黑白染色并操作也可以得到相同的结果。能感受到<strong>操作无法再简化了</strong>。考虑用这个版本的操作<strong>调整</strong>。</p></li>\n<li>故大力令周围一圈的临时解 <span class=\"math inline\">\\(a&#39;\\)</span> 为 <span class=\"math inline\">\\(0\\)</span>，令每行、列的调整 delta 为 <span class=\"math inline\">\\(r_i,c_i\\)</span>，可以得到若干个关于 <span class=\"math inline\">\\(0\\)</span> 和 <span class=\"math inline\">\\(10^6\\)</span> 的约束。最后建出来一个完全二分图状物，跑差分约束即可，容易发现复杂度正确。</li>\n<li><p>实现技巧：规划一下 <span class=\"math inline\">\\(r\\)</span> 和 <span class=\"math inline\">\\(c\\)</span> 的染色方式，使得它们错开，可以把所有位置都写作 <span class=\"math inline\">\\(a&#39;_{i,j}+c-r\\)</span> 或 <span class=\"math inline\">\\(a&#39;_{i,j}+r-c\\)</span> 的形式，便于差分约束</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code></code></pre>\n</details>\n<hr />\n<h2 id=\"c---tax\">C - Tax</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P6822\" class=\"uri\">https://www.luogu.com.cn/problem/P6822</a></p>\n<ul>\n<li>容易想到分类讨论，如果钦定是入边贡献边权，那么出边边权不能大于入边边权；否则，出边贡献边权。</li>\n<li>考虑把每个点上的出边按边权从小到大排序，显然需要入边贡献的是一段前缀，需要出边贡献的是一段后缀，就可以做一个前后缀优化建图。</li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst long long inf = 1e18;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, m;\n    std::cin &gt;&gt; n &gt;&gt; m;\n    struct edge &#123; int v, w, id, pi, si; &#125;;\n    std::vector&lt;std::vector&lt;edge&gt; &gt; g1(n + 2);\n    std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; g(1);\n    int cnt = 0;\n    for (int x, y, w; m--; ) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y &gt;&gt; w;\n        g1[x].push_back(&#123; y, w, ++cnt, 0, 0 &#125;);\n        g1[y].push_back(&#123; x, w, ++cnt, 0, 0 &#125;);\n        g.emplace_back(), g.emplace_back();\n    &#125;\n    int s = ++cnt, t = ++cnt;\n    g1[0].push_back(&#123; 1, 0, s, 0, 0 &#125;), g1[n].push_back(&#123; n + 1, 0, t, 0, 0 &#125;);\n    g.emplace_back(), g.emplace_back();\n    for (int i = 0; i &lt;= n + 1; ++i)\n        if (!g1[i].empty()) &#123;\n            std::sort(g1[i].begin(), g1[i].end(), [&amp;](edge &amp;x, edge &amp;y) &#123; return x.w &lt; y.w; &#125;);\n            for (int j = 0; j &lt; (int)g1[i].size(); ++j) &#123;\n                g1[i][j].pi = ++cnt, g.emplace_back();\n                if (j != 0)\n                    g[cnt].emplace_back(cnt - 1, 0);\n                g[cnt].emplace_back(g1[i][j].id, 0);\n            &#125;\n            for (int j = (int)g1[i].size() - 1; ~j; --j) &#123;\n                g1[i][j].si = ++cnt, g.emplace_back();\n                if (j != (int)g1[i].size() - 1)\n                    g[cnt].emplace_back(cnt - 1, 0);\n                g[cnt].emplace_back(g1[i][j].id, g1[i][j].w);\n            &#125;\n        &#125;\n    for (int i = 0; i &lt;= n + 1; ++i)\n        for (auto &amp;[v, w, id, pi, si] : g1[i]) &#123;\n            auto to = std::upper_bound(g1[v].begin(), g1[v].end(), w, [&amp;](int x, edge &amp;y) &#123; return x &lt; y.w; &#125;);\n            if (to != g1[v].end())\n                g[id].emplace_back(to-&gt;si, 0);\n            if (to != g1[v].begin())\n                g[id].emplace_back((--to)-&gt;pi, w);\n        &#125;\n    std::vector&lt;int&gt; vis(cnt + 1, 0);\n    std::vector&lt;long long&gt; dis(cnt + 1, inf);\n    std::priority_queue&lt;std::pair&lt;long long, int&gt; &gt; q;\n    dis[s] = 0, q.emplace(0, s);\n    for (; !q.empty(); ) &#123;\n        int f = q.top().second;\n        q.pop();\n        if (vis[f])\n            continue;\n        vis[f] = 1;\n        for (auto [v, w] : g[f])\n            if (dis[v] &gt; dis[f] + w) &#123;\n                dis[v] = dis[f] + w;\n                q.emplace(-dis[v], v);\n            &#125;\n    &#125;\n    std::cout &lt;&lt; dis[t] &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"d---travelling-through-the-snow-queens-kingdom\">D - Travelling Through the Snow Queen’s Kingdom</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/CF685E\" class=\"uri\">https://www.luogu.com.cn/problem/CF685E</a></p>\n<p>目前见过的数据范围提示性极弱（误导性极强）的循环结构题：</p>\n<ul>\n<li>[BZOJ3620] 似乎在梦中见过的样子</li>\n<li><a href=\"/20240906/#字符合并\">字符合并</a></li>\n<li><a href=\"/20250907/#e---subset-product-problem\">[ARC205E] Subset Product Problem</a></li>\n</ul>\n<p>正赛因为有部分分，应该不会出现不敢写的问题</p>\n<ul>\n<li>考虑离线询问，逆序加边；原文无边权；边的通行时刻只决定到达点的时刻。</li>\n<li><p>借鉴 <a href=\"/20231113/#b.-商人\">merchant</a> 中的思路，只需要更新当前边两侧点为起点的 DP 数组。</p>\n<p>需要注意边从某种意义上说是『有向』的。</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int inf = 0x3f3f3f3f;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, m, q;\n    std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;\n    struct query &#123; int r, s, t, id; &#125;;\n    std::vector&lt;int&gt; res(q + 1);\n    std::vector&lt;std::vector&lt;query&gt; &gt; u(m + 1);\n    std::vector&lt;std::pair&lt;int, int&gt; &gt; e(m + 1);\n    for (int i = 1; i &lt;= m; ++i)\n        std::cin &gt;&gt; e[i].first &gt;&gt; e[i].second;\n    for (int i = 1, l, r, s, t; i &lt;= q; ++i) &#123;\n        std::cin &gt;&gt; l &gt;&gt; r &gt;&gt; s &gt;&gt; t;\n        u[l].push_back(&#123; r, s, t, i &#125;);\n    &#125;\n    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1, std::vector&lt;int&gt; (n + 1, inf));\n    for (int i = m; i; --i) &#123;\n        auto [x, y] = e[i];\n        g[x][y] = g[y][x] = i;\n        for (int j = 1; j &lt;= n; ++j)\n            g[x][j] = g[y][j] = std::min(g[x][j], g[y][j]);\n        for (auto [r, s, t, id] : u[i])\n            if (g[s][t] &lt;= r)\n                res[id] = 1;\n    &#125;\n    for (int i = 1; i &lt;= q; ++i)\n        std::cout &lt;&lt; (res[i] ? &quot;Yes&quot; : &quot;No&quot;) &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"e---culture-code\">E - Culture Code</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/CF1197E\" class=\"uri\">https://www.luogu.com.cn/problem/CF1197E</a></p>\n<ul>\n<li>先按 <span class=\"math inline\">\\(out\\)</span> 排序，做一个前缀优化建图。</li>\n<li><p>容易发现除了最外层，每一个套娃都会提供 <span class=\"math inline\">\\(in_i-out_i\\)</span> 的代价，而最外层会提供 <span class=\"math inline\">\\(in_x\\)</span> 的代价。</p>\n<del>好在要求的是最长路，这样就可以 Dij 了</del>，并不需要真正把图建出来，发现这个形式更序列，直接在序列上二分前缀 + DP 即可。</li>\n<li><p>求方案是容易的。最后统计 DP 值最大，<strong>且不能被其他套娃包含的元素</strong>即可。</p>\n<p>Tip：在求解过程中并不用考虑当前元素和前缀 min 元素间能否加入其他套娃，因为保证 <span class=\"math inline\">\\(out&gt;in\\)</span>，如果存在这样的套娃，其 DP 值会比前缀 min 更小，矛盾。</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 1e9 + 7;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;std::pair&lt;int, int&gt; &gt; a(n + 1);\n    int mxi = 0;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::cin &gt;&gt; a[i].first &gt;&gt; a[i].second;\n        mxi = std::max(mxi, a[i].second);\n    &#125;\n    std::sort(a.begin() + 1, a.end());\n    std::vector&lt;long long&gt; g(n + 1), mxg(n + 1), f(n + 1), mx(n + 1);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        int j = std::upper_bound(a.begin() + 1, a.begin() + i, std::make_pair(a[i].second, 0x3f3f3f3f)) - a.begin() - 1;\n        if (j == 0)\n            f[i] = a[i].second, g[i] = 1ll;\n        else\n            f[i] = mx[j] + a[i].second, g[i] = mxg[j];\n        long long now = f[i] - a[i].first;\n        if (now &lt; mx[i - 1])\n            mx[i] = now, mxg[i] = g[i];\n        else if (now == mx[i - 1])\n            mx[i] = now, mxg[i] = (mxg[i - 1] + g[i]) % mod;\n        else\n            mx[i] = mx[i - 1], mxg[i] = mxg[i - 1];\n    &#125;\n    auto now = 0x3f3f3f3fll, res = 0ll;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        if (a[i].first &lt;= mxi)\n            continue;\n        if (f[i] &lt; now)\n            now = f[i], res = g[i];\n        else if (f[i] == now)\n            (res += g[i]) %= mod;\n    &#125;\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"a---awesome-arrowland-adventure\">A - Awesome Arrowland Adventure</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P6233\" class=\"uri\">https://www.luogu.com.cn/problem/P6233</a></p>\n<ul>\n<li>没什么好说的建图，注意只能顺时针转</li>\n<li>代码略</li>\n</ul>\n<hr />\n<h2 id=\"b---地铁线路\">B - 地铁线路</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P6096\" class=\"uri\">https://www.luogu.com.cn/problem/P6096</a></p>\n<ul>\n<li>考虑做一个神秘拆点，把每个点附上线路和运行方向的信息（所以是单向的）</li>\n<li>认为路径代价是二元组，那么同条线路中的点通行代价为 <span class=\"math inline\">\\((0,-1)\\)</span></li>\n<li>换乘需要优化建图，每个点可以花 <span class=\"math inline\">\\((0,0)\\)</span> 的代价走到这个点的『换乘点』，再花 <span class=\"math inline\">\\((1,0)\\)</span> 的代价走到另一个分点</li>\n<li><p>但 <strong>15 年的时候 SPFA 已经死了</strong>，所以需要好好考虑怎么实现最短路。</p>\n<p>分两问是有提示性在的，可以想到 01 BFS 解决第一个关键字，比较对的想法是<strong>把所有最短路拿出来形成 DAG，在 DAG 上对第二关键字 DP</strong>。</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, m;\n    std::cin &gt;&gt; m &gt;&gt; n;\n    std::unordered_map&lt;std::string, int&gt; tab;\n    std::vector&lt;std::vector&lt;int&gt; &gt; l(n + 1);\n    std::vector&lt;std::vector&lt;std::tuple&lt;int, int, int&gt; &gt; &gt; g0(n + 1), g1(n + 1);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        std::string s;\n        std::cin &gt;&gt; s, tab[s] = i;\n    &#125;\n    int tot = n;\n    for (int i = 1, k; i &lt;= m; ++i) &#123;\n        std::cin &gt;&gt; k;\n        int lp = 0, lq = 0;\n        for (std::string s; k--; ) &#123;\n            std::cin &gt;&gt; s;\n            int p = ++tot, q = ++tot, id = tab[s];\n            g0.emplace_back(), g0.emplace_back();\n            g1.emplace_back(), g1.emplace_back();\n            if (lp) &#123;\n                g0[p].emplace_back(lp, 0, 1), g0[lq].emplace_back(q, 0, 1);\n                g1[lp].emplace_back(p, 0, 1), g1[q].emplace_back(lq, 0, 1);\n            &#125;\n            g0[p].emplace_back(id, 0, 0), g0[id].emplace_back(p, 1, 0);\n            g1[id].emplace_back(p, 0, 0), g1[p].emplace_back(id, 1, 0);\n            g0[q].emplace_back(id, 0, 0), g0[id].emplace_back(q, 1, 0);\n            g1[id].emplace_back(q, 0, 0), g1[q].emplace_back(id, 1, 0);\n            l[id].push_back(p), l[id].push_back(q);\n            lp = p, lq = q;\n        &#125;\n    &#125;\n    int s, t;\n    &#123;\n        std::string s1, s2;\n        std::cin &gt;&gt; s1 &gt;&gt; s2;\n        s = ++tot, t = tab[s2];\n        g0.emplace_back(), g1.emplace_back();\n        int p = tab[s1];\n        for (auto i : l[p])\n            g0[s].emplace_back(i, 1, 0), g1[i].emplace_back(s, 1, 0);\n    &#125;\n    std::vector&lt;int&gt; dis0(tot + 1, 0x3f3f3f3f), dis1(tot + 1, 0x3f3f3f3f);\n    auto BFS = [&amp;](decltype(g0) &amp;g, decltype(dis0) &amp;dis, int s) &#123;\n        std::deque&lt;int&gt; q;\n        std::vector&lt;int&gt; vis(tot + 1);\n        q.push_back(s), dis[s] = 0;\n        for (; !q.empty(); ) &#123;\n            int x = q.front();\n            q.pop_front();\n            if (vis[x])\n                continue;\n            vis[x] = 1;\n            for (auto [v, w1, w2] : g[x])\n                if (dis[x] + w1 &lt; dis[v]) &#123;\n                    dis[v] = dis[x] + w1;\n                    if (w1 == 0)\n                        q.push_front(v);\n                    else\n                        q.push_back(v);\n                &#125;\n        &#125;\n        return;\n    &#125;;\n    BFS(g0, dis0, s), BFS(g1, dis1, t);\n    std::cout &lt;&lt; dis0[t] &lt;&lt; &#39;\\n&#39;;\n    std::vector&lt;int&gt; deg(tot + 1);\n    std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; g(tot + 1);\n    for (int i = 1; i &lt;= tot; ++i)\n        for (auto [j, w1, w2] : g0[i])\n            if (dis0[i] + dis1[j] + w1 == dis0[t])\n                g[i].emplace_back(j, w2), ++deg[j];\n    std::queue&lt;int&gt; q;\n    for (int i = 1; i &lt;= tot; ++i)\n        if (!deg[i])\n            q.push(i);\n    std::vector&lt;int&gt; f(tot + 1);\n    for (; !q.empty(); ) &#123;\n        int x = q.front();\n        q.pop();\n        for (auto [v, w] : g[x]) &#123;\n            f[v] = std::max(f[v], f[x] + w);\n            if (!--deg[v])\n                q.push(v);\n        &#125;\n    &#125;\n    std::cout &lt;&lt; f[t] &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"c---droga-do-domu\">C - Droga do domu</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P9402\" class=\"uri\">https://www.luogu.com.cn/problem/P9402</a></p>\n<ul>\n<li>还是做一个和上一题类似的优化建图</li>\n<li>此外就是一个普通的 Dij 上 DP 了。<strong>图没有环</strong>，直接拓扑即可。</li>\n<li>可以滚动优化空间，但似乎并无必要。代码略。</li>\n</ul>\n<hr />\n<h2 id=\"d---tickets-p\">D - Tickets P</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P7984\" class=\"uri\">https://www.luogu.com.cn/problem/P7984</a></p>\n<ul>\n<li>没什么好说的线段树优化建图，难点在于如何同时获取 <span class=\"math inline\">\\(1\\)</span> 和 <span class=\"math inline\">\\(N\\)</span> 的信息</li>\n<li><p>发现从某个点走到 <span class=\"math inline\">\\(1\\)</span> 和 <span class=\"math inline\">\\(N\\)</span>，有一种不劣的走法：</p>\n<img src=\"image.png\" /></li>\n<li><p>维护一下每个点单独走到 <span class=\"math inline\">\\(1\\)</span>，<span class=\"math inline\">\\(N\\)</span> 的最小代价和同时走到 <span class=\"math inline\">\\(1,N\\)</span> 的最小代价</p>\n看到一种更加对的写法是<strong>令 <span class=\"math inline\">\\(f_u\\)</span> 表示 <span class=\"math inline\">\\(v\\)</span> 的答案，那么可以用 <span class=\"math inline\">\\(f_v+w(u,v)\\)</span> 更新 <span class=\"math inline\">\\(f_u\\)</span></strong>。</li>\n<li><p>那么可以从 <span class=\"math inline\">\\(1,N\\)</span> 出发做一个 Dij。代码略。</p></li>\n</ul>\n<hr />\n<h2 id=\"e---监狱\">E - 监狱</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P9520\" class=\"uri\">https://www.luogu.com.cn/problem/P9520</a></p>\n<ul>\n<li><p>注意要走简单路径，也就是说不存在绕路让道的可能性。容易推出：若输入合法，总能找到一种方式使得每个人受到的指令是连续给出的。</p>\n<p>P.S. 这个结论挪到图上就不成立了，很容易举出反例。</p>\n<p><img src=\"image-1.png\" /></p></li>\n<li>若一个人的起点 / 终点在另一个人的路径上，那么这两个人之间存在先后关系。建图后检查是否为 DAG 即可。</li>\n<li><p>但建图显然是比较困难的，容易构造出数据使得边数来到 <span class=\"math inline\">\\(n^2\\)</span> 级别。考虑优化建图。</p>\n<p>发现可以用一个树剖 / 倍增的结构来建图。</p>\nTips：这一点同样是一个树上路径问题。参见 <a href=\"/20231117/#树上问题\">树上问题，倍增和树剖的选择？</a></li>\n<li><p>这里的路径要求两端都是开的，这就导致倍增写着很困难（虽然树剖可能也是），不排除我写丑了</p></li>\n</ul>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int K = 19;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;01-02.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int T;\n    for (std::cin &gt;&gt; T; T--; ) &#123;\n        int n, m;\n        std::cin &gt;&gt; n;\n        std::vector&lt;std::vector&lt;int&gt; &gt; g1(n + 1);\n        std::vector&lt;int&gt; s(n + 1), t(n + 1);\n        for (int i = 1, x, y; i &lt; n; ++i) &#123;\n            std::cin &gt;&gt; x &gt;&gt; y;\n            g1[x].push_back(y), g1[y].push_back(x);\n        &#125;\n        std::cin &gt;&gt; m;\n        std::vector&lt;std::vector&lt;int&gt; &gt; g(m + 1);\n        std::vector&lt;std::pair&lt;int, int&gt; &gt; a(m + 1);\n        for (int i = 1; i &lt;= m; ++i) &#123;\n            std::cin &gt;&gt; a[i].first &gt;&gt; a[i].second;\n            s[a[i].first] = i;\n            t[a[i].second] = i;\n        &#125;\n        int cnt = m;\n        struct node &#123; int fa, i0, i1; &#125;;\n        std::vector&lt;std::array&lt;node, K + 1&gt; &gt; p(n + 1);\n        std::vector&lt;int&gt; i0(n + 1), i1(n + 1), dep(n + 1), deg(m + 1);\n        auto init = [&amp;](void) &#123;\n            g.emplace_back(), deg.emplace_back();\n            return ++cnt;\n        &#125;;\n        auto add = [&amp;](int x, int y) &#123;\n            g[x].push_back(y), ++deg[y];\n            return;\n        &#125;;\n        for (int i = 1; i &lt;= n; ++i)\n            i0[i] = init(), i1[i] = init();\n        std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int fa) &#123;\n            if (s[x])\n                add(s[x], i1[x]);\n            if (t[x])\n                add(i0[x], t[x]);\n            for (auto i : g1[x])\n                if (i != fa) &#123;\n                    dep[i] = dep[x] + 1;\n                    p[i][0].fa = x;\n                    p[i][0].i0 = init(), p[i][0].i1 = init();\n                    add(p[i][0].i0, i0[i]), add(i1[i], p[i][0].i1);\n                    for (int j = 1; j &lt;= K; ++j) &#123;\n                        p[i][j].fa = p[p[i][j - 1].fa][j - 1].fa;\n                        if (!p[i][j].fa)\n                            break;\n                        p[i][j].i0 = init(), p[i][j].i1 = init();\n                        add(p[i][j].i0, p[i][j - 1].i0);\n                        add(p[i][j].i0, p[p[i][j - 1].fa][j - 1].i0);\n                        add(p[i][j - 1].i1, p[i][j].i1);\n                        add(p[p[i][j - 1].fa][j - 1].i1, p[i][j].i1);\n                    &#125;\n                    DFS(i, x);\n                &#125;\n            return;\n        &#125;;\n        dep[1] = 1, DFS(1, -1);\n        for (int i = 1; i &lt;= m; ++i) &#123;\n            auto [x, y] = a[i];\n            if (x == y)\n                continue;\n            if (t[x])\n                add(i, t[x]);\n            if (s[y])\n                add(s[y], i);\n            if (dep[x] &lt; dep[y])\n                std::swap(x, y);\n            x = p[x][0].fa;\n            if (dep[x] &gt;= dep[y]) &#123;\n                for (int j = K; ~j; --j)\n                    if (dep[p[x][j].fa] &gt;= dep[y]) &#123;\n                        add(i, p[x][j].i0), add(p[x][j].i1, i);\n                        x = p[x][j].fa;\n                    &#125;\n                if (x == y)\n                    continue;\n                add(i, p[x][0].i0), add(p[x][0].i1, i);\n                x = p[x][0].fa;\n            &#125;\n            y = p[y][0].fa;\n            if (x != y) &#123;\n                for (int j = K; ~j; --j)\n                    if (p[x][j].fa != p[y][j].fa) &#123;\n                        add(i, p[x][j].i0), add(i, p[y][j].i0);\n                        add(p[x][j].i1, i), add(p[y][j].i1, i);\n                        x = p[x][j].fa, y = p[y][j].fa;\n                    &#125;\n                add(i, p[x][0].i0), add(i, p[y][0].i0);\n                add(p[x][0].i1, i), add(p[y][0].i1, i);\n                x = p[x][0].fa;\n            &#125;\n            add(i, i0[x]), add(i1[x], i);\n        &#125;\n        std::queue&lt;int&gt; q;\n        for (int i = 1; i &lt;= cnt; ++i)\n            if (!deg[i])\n                q.push(i);\n        int tot = 0;\n        for (; !q.empty(); ) &#123;\n            int x = q.front();\n            q.pop(), ++tot;\n            for (auto i : g[x])\n                if (!--deg[i])\n                    q.push(i);\n        &#125;\n        std::cout &lt;&lt; (tot == cnt ? &quot;Yes&quot; : &quot;No&quot;) &lt;&lt; &#39;\\n&#39;;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n",
            "tags": [
                "DP",
                "二分",
                "倍增",
                "调整法",
                "最短路"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20250824/",
            "url": "https://xsc062.netlify.app/20250824/",
            "title": "杂题选谈",
            "date_published": "2025-08-24T07:37:55.000Z",
            "content_html": "<p>不会的东西越来越多了</p>\n<span id=\"more\"></span>\n<hr />\n<h2 id=\"b.-k-set-tree\">B. K-Set Tree</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/CF1691F\" class=\"uri\">https://www.luogu.com.cn/problem/CF1691F</a></p>\n<p>令 <span class=\"math inline\">\\(F_i\\)</span> 表示以 <span class=\"math inline\">\\(1\\)</span> 为根时，<span class=\"math inline\">\\(S\\)</span> 在 <span class=\"math inline\">\\(i\\)</span> 子树内的答案。则：</p>\n<p><span class=\"math display\">\\[\nF_u=\\left(C_{siz_u}^k-\\sum C_{siz_v}^k\\right)\\cdot siz_u+\\sum F_v\\\\\n\\]</span></p>\n<p>直接换根是很复杂的；把 <span class=\"math inline\">\\(\\sum C_{siz_v}^k\\)</span> 记作 <span class=\"math inline\">\\(dp_u\\)</span>，把 <span class=\"math inline\">\\(\\sum F_v\\)</span> 记作 <span class=\"math inline\">\\(f_u\\)</span>，那么：</p>\n<p><span class=\"math display\">\\[\nres=\\sum(C_n^k-dp_u)\\cdot n+f_u\\\\\n\\]</span></p>\n<p><strong>这样做是为了把两个和 <span class=\"math inline\">\\(v\\)</span> 有关的乘项拆开来换根</strong>，实际换根的时候就只用分别换 <span class=\"math inline\">\\(f,dp\\)</span> 两个值，不用考虑二次项等问题，计算量会少很多</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 1e9 + 7;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, k;\n    std::cin &gt;&gt; n &gt;&gt; k;\n    std::vector&lt;std::vector&lt;int&gt; &gt; g(n + 1);\n    for (int i = 1, x, y; i &lt; n; ++i) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y;\n        g[x].push_back(y), g[y].push_back(x);\n    &#125;\n    std::vector&lt;long long&gt; fac(n + 1), inv(n + 1);\n    fac[0] = inv[0] = 1ll;\n    for (int i = 1; i &lt;= n; ++i)\n        fac[i] = fac[i - 1] * i % mod;\n    auto qkp = [](long long x, int y) &#123;\n        auto res(1ll);\n        for (; y; (x *= x) %= mod, y &gt;&gt;= 1)\n            if (y &amp; 1)\n                (res *= x) %= mod;\n        return res;\n    &#125;;\n    inv[n] = qkp(fac[n], mod - 2);\n    for (int i = n - 1; i; --i)\n        inv[i] = inv[i + 1] * (i + 1) % mod;\n    auto C = [&amp;](int n, int m) &#123;\n        if (m &gt; n)\n            return 0ll;\n        return fac[n] * inv[m] % mod * inv[n - m] % mod;\n    &#125;;\n    auto res(0ll);\n    std::vector&lt;int&gt; siz(n + 1), ss(n + 1);\n    std::vector&lt;long long&gt; f(n + 1), dp(n + 1);\n    std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int fa) &#123;\n        siz[x] = 1;\n        for (auto i : g[x])\n            if (i != fa) &#123;\n                DFS(i, x);\n                (f[x] += (C(siz[i], k) - dp[i]) * siz[i] + f[i]) %= mod;\n                (dp[x] += C(siz[i], k)) %= mod;\n                siz[x] += siz[i];\n            &#125;\n        return;\n    &#125;;\n    DFS(1, -1);\n    DFS = [&amp;](int x, int fa) &#123;\n        (res += (C(n, k) - dp[x]) * n + f[x]) %= mod;\n        for (auto i : g[x])\n            if (i != fa) &#123;\n                (f[i] += (C(n - siz[i], k) - (dp[x] - C(siz[i], k))) * (n - siz[i]) + f[x] - f[i] - (C(siz[i], k) - dp[i]) * siz[i]) %= mod;\n                (dp[i] += C(n - siz[i], k)) %= mod;\n                DFS(i, x);\n            &#125;\n        return;\n    &#125;;\n    DFS(1, -1);\n    std::cout &lt;&lt; (res + mod) % mod &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"c.-li-hua-and-path\">C. Li Hua and Path</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/CF1797F\" class=\"uri\">https://www.luogu.com.cn/problem/CF1797F</a></p>\n<p>考虑<strong>容斥</strong>，分别求解满足 1、满足 2、满足 12（注意要减两倍）就能计算答案</p>\n<p>发现题目所求点对形式很符合 Kruskal 重构树的要求，考虑以对应点权为边权，分别建立 min，max Kruskal 点权多叉重构树。</p>\n<details>\n<p><summary>点权多叉重构树？</summary></p>\n<p>在点权上做 Kruskal 重构树时，发现边的虚点是不必要的，可以直接将更优点作为父亲。</p>\n<p>写的时候有点难想清楚…… 可以画画图，仔细确定一下 Kruskal 重构树的具体性质</p>\n<p>这样做的优势是没有虚点，一些问题会方便一些；但同时放弃了二叉树的结构，一些题可能没那么好做。</p>\n<p>这道题只用经典 Kruskal 重构树也可以解决。</p>\n</details>\n<p>发现 1 2 均可以转化成两棵树在两棵树上的祖孙关系要求，可以轻松地分别统计满足 1、满足 2 的点对数量</p>\n<p>考虑怎么处理同时满足 12 的，发现要求在两棵树上二者应该都具有祖孙关系，且是相反的。<del>可以考虑在一棵树上 DFS 的同时用主席树存储祖先，在另一颗树上 ask</del></p>\n<p>考虑从更容易用 dfn 表示的子树问题思考，在 min 树上分配 dfn 后，在 max 树上用 DFS + 回溯得到每个点实时祖先序列，存在树状数组里；ask 该点被分配的 dfn 子树区间就能得到答案。</p>\n<p>考虑询问，由于每次加入的都是编号最大的点，对于满足 1、满足 2 的贡献是显然的，而同时满足 12 的点就是在 min 树上的祖先，都是好做的。</p>\n<p>实现的时候一定要把 min / max 树对应的性质思考清楚，不然会很麻烦</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;int&gt; f1(n + 1), f2(n + 1);\n    std::iota(f1.begin() + 1, f1.end(), 1);\n    std::iota(f2.begin() + 1, f2.end(), 1);\n    std::function&lt;int(int)&gt; find1 = [&amp;](int x) &#123;\n        return x == f1[x] ? x : f1[x] = find1(f1[x]);\n    &#125;;\n    std::function&lt;int(int)&gt; find2 = [&amp;](int x) &#123;\n        return x == f2[x] ? x : f2[x] = find2(f2[x]);\n    &#125;;\n    std::vector&lt;std::vector&lt;int&gt; &gt; g1(n + 1), g2(n + 1), adj1(n + 1), adj2(n + 1);\n    for (int i = 1, x, y; i &lt; n; ++i) &#123;\n        std::cin &gt;&gt; x &gt;&gt; y;\n        if (x &gt; y)\n            std::swap(x, y);\n        adj1[y].push_back(x);\n        adj2[x].push_back(y);\n    &#125;\n    for (int i = 1; i &lt;= n; ++i)\n        for (auto j : adj1[i]) &#123;\n            int fi = find1(i), fj = find1(j);\n            g1[fi].push_back(fj), f1[fj] = fi;\n        &#125;\n    for (int i = n; i; --i)\n        for (auto j : adj2[i]) &#123;\n            int fi = find2(i), fj = find2(j);\n            g2[fi].push_back(fj), f2[fj] = fi;\n        &#125;\n    std::vector&lt;int&gt; bit(n + 1), dfn(n + 1), rfn(n + 1);\n    auto lowbit = [](int x) &#123;\n        return x &amp; -x;\n    &#125;;\n    auto add = [&amp;](int x, int v) &#123;\n        for (; x &lt;= n; x += lowbit(x))\n            bit[x] += v;\n        return;\n    &#125;;\n    auto ask = [&amp;](int x) &#123;\n        int res = 0;\n        for (; x; x -= lowbit(x))\n            res += bit[x];\n        return res;\n    &#125;;\n    int rt1 = 0, rt2 = 0;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        if (f1[i] == i)\n            rt1 = i;\n        if (f2[i] == i)\n            rt2 = i;\n    &#125;\n    int q;\n    std::cin &gt;&gt; q;\n    std::vector&lt;int&gt; dep1(n + 1), dep2(n + q + 1);\n    long long res = 0ll;\n    std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;\n        static int now = 0;\n        dfn[x] = ++now;\n        res += dep1[x];\n        for (auto i : g1[x]) &#123;\n            dep1[i] = dep1[x] + 1;\n            DFS(i);\n        &#125;\n        rfn[x] = now;\n        return;\n    &#125;;\n    DFS(rt1);\n    DFS = [&amp;](int x) &#123;\n        res += dep2[x];\n        res -= 2 * (ask(rfn[x]) - ask(dfn[x] - 1));\n        add(dfn[x], 1);\n        for (auto i : g2[x]) &#123;\n            dep2[i] = dep2[x] + 1;\n            DFS(i);\n        &#125;\n        add(dfn[x], -1);\n        return;\n    &#125;;\n    DFS(rt2);\n    std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    for (int fa; q--; ) &#123;\n        std::cin &gt;&gt; fa;\n        dep2[++n] = dep2[fa] + 1;\n        res += (n - 1) - dep2[n];\n        std::cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"d.-团队选拔\">D. 团队选拔</h2>\n<p><a href=\"https://www.becoder.com.cn/contest/6534/problem/4\" class=\"uri\">https://www.becoder.com.cn/contest/6534/problem/4</a></p>\n<blockquote>\n<p>给定 <span class=\"math inline\">\\(a_{1\\sim n}\\)</span>，从中任选一些互不相交的区间，满足每个区间内元素的 gcd 相同。</p>\n<p><span class=\"math inline\">\\(n\\le 10^5,V\\le 10^7\\)</span>。</p>\n</blockquote>\n<p>注意到固定一个左端点后，移动右端点，gcd 每次至多减小到原来的一半；也就是说，其种类有 <span class=\"math inline\">\\(\\log V\\)</span> 种。故全序列的 gcd 总数是 <span class=\"math inline\">\\(O(n\\log V)\\)</span> 的。</p>\n<p>很容易想到与此原理类似的全局答案求法：对于每个 <span class=\"math inline\">\\(i\\)</span>，向左处理出每一段 <span class=\"math inline\">\\([l,r]\\)</span>，满足 <span class=\"math inline\">\\(\\gcd(a_{l\\cdots i})=\\gcd(a_r\\cdots i)\\)</span>，并记录该 <span class=\"math inline\">\\(\\gcd\\)</span>。这样求出来的 <span class=\"math inline\">\\((i,l,r)\\)</span> 共有 <span class=\"math inline\">\\(O(n\\log V)\\)</span> 段。</p>\n<p>对于每个 gcd 有 <span class=\"math inline\">\\(f_{i}=f_{i-1}+\\sum\\limits_{j=l_i}^{r_i} f_{j - 1}\\)</span>，可以做一个扫描线，得到全局答案；向前向后分别做到 <span class=\"math inline\">\\(i-1,i+1\\)</span>，相乘就能得到 <span class=\"math inline\">\\(i\\)</span> 未被选取时的答案</p>\n<p>考虑怎么完成『相乘』这个动作：最后的 <span class=\"math inline\">\\(f\\)</span> 在每个右端点处发生变化，可以转化成若干段 <span class=\"math inline\">\\(f\\)</span>；反过来的 <span class=\"math inline\">\\(f&#39;\\)</span> 亦可以这样转化。将 <span class=\"math inline\">\\(f\\)</span> 整体后移一位、<span class=\"math inline\">\\(f&#39;\\)</span> 整体前移一位，就可以对齐。二者的端点总数是均摊单 log 的，区间总数也就是均摊单 log 的（归并就能快速寻找到区间），用差分做一个区间加即可。</p>\n<p>用二分勉强单 log 解决了转移；还看到 <span class=\"citation\" data-cites=\"spdarkle\">@spdarkle</span> 疑似在 <span class=\"math inline\">\\(1\\sim n\\)</span> 上直接做的<a href=\"https://www.becoder.com.cn/submission/3108272\">做法</a>，和 <span class=\"citation\" data-cites=\"Rosmist\">@Rosmist</span> 疑似直接在每个 <span class=\"math inline\">\\(i\\)</span> 上做的<a href=\"https://www.becoder.com.cn/submission/3108581\">做法</a>。官解是个看不懂的做法</p>\n<p>呃，好像一不小心拿了最优解。而且优势很明显（怎么总用时比别人一个点还少？），这是为什么？</p>\n<p>可能因为大家都看不懂官解，做法比较多样？除了我之外比较快的 lwz 和 <span class=\"citation\" data-cites=\"GoldSpade\">@GoldSpade</span> 都用归并完成最后一步；我较他们的额外优势大概是用二分换掉了树状数组？迷惑</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int mod = 998244353;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n    std::freopen(&quot;selection.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;selection.out&quot;, &quot;w&quot;, stdout);\n#else\n    std::freopen(&quot;ex_selection2.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;int&gt; a(n + 1);\n    std::vector&lt;std::vector&lt;int&gt; &gt; st(20, std::vector&lt;int&gt; (n + 1));\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i], st[0][i] = a[i];\n    for (int j = 1; (1 &lt;&lt; j) &lt;= n; ++j)\n        for (int i = 1; i + (1 &lt;&lt; j) - 1 &lt;= n; ++i)\n            st[j][i] = std::__gcd(st[j - 1][i], st[j - 1][i + (1 &lt;&lt; (j - 1))]);\n    auto askgcd = [&amp;](int l, int r) &#123;\n        int k = std::__lg(r - l + 1);\n        return std::__gcd(st[k][l], st[k][r - (1 &lt;&lt; k) + 1]);\n    &#125;;\n    std::unordered_map&lt;int, int&gt; tab;\n    struct node &#123;\n        int i, l, r;\n        bool operator&lt; (const int q) const &#123;\n            return i &lt; q;\n        &#125;\n        bool operator&lt;= (const int q) const &#123;\n            return i &lt;= q;\n        &#125;\n    &#125;;\n    std::vector&lt;std::vector&lt;node&gt; &gt; p1, p2;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        for (int to = i; to &gt;= 1; ) &#123;\n            int at = i, g = askgcd(to, i);\n            for (int l = 1, r = to, mid; l &lt;= r; ) &#123;\n                mid = (l + r) &gt;&gt; 1;\n                if (askgcd(mid, i) == g)\n                    at = mid, r = mid - 1;\n                else\n                    l = mid + 1;\n            &#125;\n            if (!tab.count(g)) &#123;\n                tab[g] = (int)p1.size();\n                p1.emplace_back(), p2.emplace_back();\n            &#125;\n            p1[tab[g]].push_back(&#123; i, at, to &#125;);\n            to = at - 1;\n        &#125;\n        for (int to = i; to &lt;= n; ) &#123;\n            int at = i, g = askgcd(i, to);\n            for (int l = to, r = n, mid; l &lt;= r; ) &#123;\n                mid = (l + r) &gt;&gt; 1;\n                if (askgcd(i, mid) == g)\n                    at = mid, l = mid + 1;\n                else\n                    r = mid - 1;\n            &#125;\n            if (!tab.count(g)) &#123;\n                tab[g] = (int)p2.size();\n                p1.emplace_back(), p2.emplace_back();\n            &#125;\n            p2[tab[g]].push_back(&#123; i, to, at &#125;);\n            to = at + 1;\n        &#125;\n    &#125;\n    auto s(0ll);\n    std::vector&lt;int&gt; x1(n + 1), x2(n + 2), pos(2 * n + 3);\n    std::vector&lt;long long&gt; f1(n + 1), f2(n + 2), s1(n + 1), s2(n + 2), diff(n + 1);\n    for (auto [g, id] : tab) &#123;\n        // printf(&quot;g = %d: \\n&quot;, g);\n        int n1 = (int)p1[id].size();\n        x1[0] = 0, f1[0] = s1[0] = 1ll;\n        for (int i = 1; i &lt;= n1; ++i) &#123;\n            auto [x, L, R] = p1[id][i - 1];\n            --L, --R;\n            x1[i] = x, f1[i] = f1[i - 1];\n            int l = std::upper_bound(x1.begin() + 1, x1.begin() + i + 1, L) - x1.begin() - 1,\n                r = std::upper_bound(x1.begin() + 1, x1.begin() + i + 1, R) - x1.begin() - 1;\n            if (l == r)\n                (f1[i] += f1[l] * (R - L + 1)) %= mod;\n            else &#123;\n                f1[i] += s1[r - 1] + mod - s1[l];\n                f1[i] += f1[r] * (R - x1[r] + 1);\n                f1[i] += f1[l] * (x1[l + 1] - L);\n                f1[i] %= mod;\n            &#125;\n            // printf(&quot;  r = %d, l = [%d, %d]: %lld\\n&quot;, x, L, R, f1[i]);\n            if (i != n1)\n                s1[i] = (s1[i - 1] + f1[i] * (p1[id][i].i - x)) % mod;\n        &#125;\n        (s += f1[n1] - 1) %= mod;\n        int n2 = (int)p2[id].size();\n        x2[n2 + 1] = n + 1, f2[n2 + 1] = s2[n2 + 1] = 1ll;\n        for (int i = n2; i; --i) &#123;\n            auto [x, L, R] = p2[id][i - 1];\n            ++L, ++R;\n            x2[i] = x, f2[i] = f2[i + 1];\n            int l = std::lower_bound(x2.begin() + i, x2.begin() + n2 + 1, L) - x2.begin(),\n                r = std::lower_bound(x2.begin() + i, x2.begin() + n2 + 1, R) - x2.begin();\n            if (l == r)\n                (f2[i] += f2[l] * (R - L + 1)) %= mod;\n            else&#123;\n                f2[i] += s2[l + 1] + mod - s2[r];\n                f2[i] += f2[r] * (R - x2[r - 1]);\n                f2[i] += f2[l] * (x2[l] - L + 1);\n                f2[i] %= mod;\n            &#125;\n            // printf(&quot;  l = %d, r = [%d, %d]: %lld\\n&quot;, x, L, R, f2[i]);\n            if (i != 1)\n                s2[i] = (s2[i + 1] + f2[i] * (x - p2[id][i - 2].i)) % mod;\n        &#125;\n        for (int i = 0; i &lt; n1; ++i)\n            x1[i] = x1[i + 1];\n        x1[n1] = n;\n        int t = (x2[1] == 1) + 1;\n        for (int i = 1; i &lt;= n2 + 1; ++i)\n            --x2[i];\n        std::merge(x1.begin(), x1.begin() + n1 + 1, x2.begin() + t, x2.begin() + n2 + 2, pos.begin() + 1);\n        int m = std::unique(pos.begin() + 1, pos.begin() + n1 + n2 + 4 - t) - pos.begin() - 1;\n        for (int i = 1, p1 = 0, p2 = t, la = 0; i &lt;= m; ++i) &#123;\n            for (; p1 + 1 &lt;= n1 &amp;&amp; x1[p1] &lt; pos[i]; ++p1);\n            for (; p2 + 1 &lt;= n2 + 1 &amp;&amp; x2[p2] &lt; pos[i]; ++p2);\n            (diff[la + 1] += f1[p1] * f2[p2] + mod - 1) %= mod;\n            // printf(&quot;  [%d, %d]: %lld, %lld\\n&quot;, la + 1, pos[i], f1[p1], f2[p2]);\n            if (pos[i] + 1 &lt;= n)\n                (diff[pos[i] + 1] += mod - f1[p1] * f2[p2] + 1) %= mod;\n            la = pos[i];\n        &#125;\n    &#125;\n    // std::cout &lt;&lt; s &lt;&lt; &#39;\\n&#39;;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        (diff[i] += diff[i - 1]) %= mod;\n        std::cout &lt;&lt; (s + mod - diff[i]) % mod &lt;&lt; &#39; &#39;;\n    &#125;\n    std::cout &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<p>我一开始将 <span class=\"math inline\">\\(f\\)</span> 定义为单点答案而非前缀和，会导致需要线段树维护等差序列，还丢失了答案段数不多这个性质，非常麻烦。将 <span class=\"math inline\">\\(f\\)</span> 的意义替换为前缀和后，就可以很轻松地做了。</p>\n<hr />\n<h2 id=\"a.-宇宙\">A. 宇宙</h2>\n<p><a href=\"https://www.becoder.com.cn/contest/6535/problem/1\" class=\"uri\">https://www.becoder.com.cn/contest/6535/problem/1</a></p>\n<blockquote>\n<p>给定 <span class=\"math inline\">\\(a_{1\\sim n}\\)</span>，对于 <span class=\"math inline\">\\(k=1,2,\\cdots,n-1\\)</span>，回答：</p>\n<ul>\n<li>令 <span class=\"math inline\">\\(i\\)</span> 从 <span class=\"math inline\">\\(1\\)</span> 开始自增，对于每个 <span class=\"math inline\">\\(i\\)</span>，都可以选取 <span class=\"math inline\">\\(k\\)</span> 个互不相同的下标，并使它们对应的元素增加 1。此时，若存在元素不大于 <span class=\"math inline\">\\(i\\)</span>，停止。输出停止时 <span class=\"math inline\">\\(i\\)</span> 可能的最大值。</li>\n</ul>\n<p><span class=\"math inline\">\\(n\\le 10^6,V\\le 10^9\\)</span>。</p>\n</blockquote>\n<p>发现不大于这个 condition 有些反人类，先将 <span class=\"math inline\">\\(a\\)</span> 全部减 1，转化成小于来考虑</p>\n<p>考虑能坚持到 <span class=\"math inline\">\\(i\\)</span> 的一个必要条件，即 <span class=\"math inline\">\\(\\sum\\limits_{a_j&lt;i} i-a_j\\le k\\cdot i\\)</span></p>\n<p>容易发现该条件同时是充分的，可以朝摩尔投票思考</p>\n<p>对 <span class=\"math inline\">\\(a\\)</span> 排序，停止时参与运算的 <span class=\"math inline\">\\(a_j\\)</span> 是越来越多的，故记录最后一个参与运算的下标，逐步挪动（当发现解出来的 <span class=\"math inline\">\\(i\\)</span> 比下一个更大时就需要挪动），同时解不等式即可。</p>\n<p><span class=\"citation\" data-cites=\"Quack\">@Quack</span> 云我在场上能想出官解对我来说是非常了不起的（其实场上写正解的人少得出奇），我也不得不承认我能做出来确实有一定运气成分，也能从中一窥我令人眼前一黑的数学素养！</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n    std::freopen(&quot;universe.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;universe.out&quot;, &quot;w&quot;, stdout);\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n    int n;\n    std::cin &gt;&gt; n, std::cin &gt;&gt; n;\n    std::vector&lt;int&gt; a(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i], --a[i];\n    std::sort(a.begin() + 1, a.end());\n    int id = 1;\n    long long s = a[1];\n    for (int i = 1; i &lt; n; ++i) &#123;\n        if (id &lt; i + 1)\n            s += a[++id];\n        long long x = s / (id - i);\n        for (; id != n &amp;&amp; x &gt; a[id + 1]; s += a[++id], x = s / (id - i));\n        std::cout &lt;&lt; x &lt;&lt; &#39; &#39;;\n    &#125;\n    std::cout &lt;&lt; &#39;\\n&#39;;\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"b.-跳跃\">B. 跳跃</h2>\n<p><a href=\"https://www.becoder.com.cn/contest/6535/problem/2\" class=\"uri\">https://www.becoder.com.cn/contest/6535/problem/2</a></p>\n<blockquote>\n<p>给定长度为 <span class=\"math inline\">\\(n\\)</span> 的 01 序列和跳跃上限 <span class=\"math inline\">\\(k\\)</span>。给定 <span class=\"math inline\">\\(q\\)</span> 个询问，回答：</p>\n<ul>\n<li>从 <span class=\"math inline\">\\(a\\)</span> 跳到 <span class=\"math inline\">\\(b\\)</span>，保证 <span class=\"math inline\">\\(a,b\\)</span> 的颜色均为 1，每次不能跳超过 <span class=\"math inline\">\\(k\\)</span> 格或跳出去，在最小化踩到 0 数量的前提下，最小化跳跃次数，输出这两个值。</li>\n</ul>\n<p><span class=\"math inline\">\\(n,q\\le5\\times10^5\\)</span>。</p>\n</blockquote>\n<p>容易发现只能往一个方向跳，那么不妨令 <span class=\"math inline\">\\(a&lt;b\\)</span>。有一个贪心的想法是能往右就往右，手玩发现<strong>是对的</strong>（我场上手玩过后坚定地认为是错的；可能和没时间了兵荒马乱有关）。这样就很好想到第二问需要倍增；但把两个问结合起来考虑是有点困难的，赛时就意识到这两问的联系没有看起来那么大，甚至很可能是割裂的。</p>\n<p>单独考虑第一问，发现对于一段长度为 <span class=\"math inline\">\\(len\\)</span> 的 0，需要踩到恰好 <span class=\"math inline\">\\(\\left\\lfloor\\dfrac {len}k\\right\\rfloor\\)</span> 个 0。答案容易计算。</p>\n<p>单独考虑第二问，考虑一个第一问答案固定为 0 的情况，也即每个 len 都比 <span class=\"math inline\">\\(k\\)</span> 小。则问题转化成在不踩 0 的情况下最小的步数。容易用倍增解决。</p>\n<p>本题最令人印象深刻的点在于二者的结合，发现这 <span class=\"math inline\">\\(\\left\\lfloor\\dfrac {len}k\\right\\rfloor\\cdot k\\)</span> 个 0 是无论如何都会被经过的，所以可以在原始数组里删掉它们，转化成只考虑第二问的情况</p>\n<details>\n<p>？？？</p>\n<p>我对于自己莫名其妙跑得比别人快一大截这件事情已经快要见怪不怪了，这次又是什么原理，我预处理写得比较漂亮吗？？</p>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n    std::freopen(&quot;jump.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;jump.out&quot;, &quot;w&quot;, stdout);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, k, q, op;\n    std::cin &gt;&gt; n, std::cin &gt;&gt; n &gt;&gt; q &gt;&gt; k &gt;&gt; op;\n    std::vector&lt;int&gt; tmp(n + 1), a(1), s(1), to(n + 2);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        char t;\n        std::cin &gt;&gt; t;\n        tmp[i] = t - &#39;0&#39;;\n    &#125;\n    tmp.push_back(1), ++n;\n    int cnt = 0;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        if (tmp[i] == 1) &#123;\n            a.push_back(1), to[i] = (int)a.size() - 1;\n            s.push_back(s.back() + cnt), cnt = 0;\n        &#125;\n        else &#123;\n            ++cnt;\n            if (i == n || tmp[i + 1] == 1) &#123;\n                for (int j = 1; j &lt;= cnt % k; ++j)\n                    a.push_back(0), s.push_back(s.back());\n                cnt /= k;\n            &#125;\n        &#125;\n    &#125;\n    n = (int)a.size() - 1;\n    std::vector&lt;std::vector&lt;int&gt; &gt; f(20, std::vector&lt;int&gt; (n + 1));\n    for (int i = 0; i &lt; 20; ++i)\n        f[i][n] = n;\n    for (int i = n - 1; i; --i) &#123;\n        f[0][i] = std::min(&#123; n, i + k, f[0][i + 1] &#125;);\n        for (; !a[f[0][i]]; --f[0][i]);\n        if (a[i] == 1) &#123;\n            for (int j = 1; j &lt; 20; ++j)\n                f[j][i] = f[j - 1][f[j - 1][i]];\n        &#125;\n    &#125;\n    for (int a, b; q--; ) &#123;\n        std::cin &gt;&gt; a &gt;&gt; b;\n        if (a &gt; b)\n            std::swap(a, b);\n        a = to[a], b = to[b];\n        std::cout &lt;&lt; s[b] - s[a];\n        if (op == 1) &#123;\n            int res = s[b] - s[a];\n            for (int i = 19; ~i; --i)\n                if (f[i][a] &lt; b)\n                    a = f[i][a], res += (1 &lt;&lt; i);\n            std::cout &lt;&lt; &#39; &#39; &lt;&lt; res + 1;\n        &#125;\n        std::cout &lt;&lt; &#39;\\n&#39;;\n    &#125;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"d.-jongmah\">D. Jongmah</h2>\n<p><a href=\"https://codeforces.com/contest/1110/problem/D\" class=\"uri\">https://codeforces.com/contest/1110/problem/D</a></p>\n<p>容易发现当连续出现三次 <span class=\"math inline\">\\((i-1,i,i+1)\\)</span> 时，可以被三次相同代替；</p>\n<p>容易发现需要使用 <span class=\"math inline\">\\(f_{i,a,b}\\)</span> 来代表 DP 到 <span class=\"math inline\">\\(i\\)</span> 时，用了 <span class=\"math inline\">\\(a\\)</span> 组 <span class=\"math inline\">\\((i-1,i,i+1)\\)</span> 和 <span class=\"math inline\">\\(b\\)</span> 组 <span class=\"math inline\">\\((i,i+1,i+2)\\)</span> 时的最大组数；</p>\n<p>但是并没有想到要将二者结合起来！感觉应该是能比较快做出来的水平。能察觉到不太认真。悔过！</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nconst int inf = 0x3f3f3f3f;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n, m;\n    std::cin &gt;&gt; n &gt;&gt; m;\n    std::vector&lt;int&gt; cnt(m + 1);\n    for (int i = 1, x; i &lt;= n; ++i)\n        std::cin &gt;&gt; x, ++cnt[x];\n    std::vector&lt;std::vector&lt;std::vector&lt;int&gt; &gt; &gt; f(m + 1, std::vector&lt;std::vector&lt;int&gt; &gt; (3, std::vector&lt;int&gt; (3, -inf)));\n    f[0][0][0] = 0ll;\n    for (int i = 1; i &lt;= m; ++i)\n        for (int a = 0; a &lt;= 2; ++a) // i - 1, i, i + 1\n            for (int b = 0; b &lt;= 2; ++b) // i, i + 1, i + 2\n                for (int c = 0; c &lt;= 2; ++c) &#123; // i - 2, i - 1, i\n                    if (a + b + c &gt; cnt[i]) continue;\n                    f[i][a][b] = std::max(f[i][a][b], f[i - 1][c][a] + b + (cnt[i] - a - b - c) / 3);\n                &#125;\n    std::cout &lt;&lt; f[m][0][0] &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n<hr />\n<h2 id=\"e.-magic-stones\">E. Magic Stones</h2>\n<p><a href=\"https://codeforces.com/contest/1110/problem/F\" class=\"uri\">https://codeforces.com/contest/1110/problem/F</a></p>\n<p>容易想到考察差分数组，发现这个操作就是交换了差分数组的相邻两个元素。故对于 <span class=\"math inline\">\\(c\\)</span> 和 <span class=\"math inline\">\\(t\\)</span> 的差分数组分别排序，然后 check 是否相等即可。</p>\n<details>\n<pre class=\"cpp\"><code>#include &lt;bits/stdc++.h&gt;\nint main() &#123;\n#ifdef ONLINE_JUDGE\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr), std::cout.tie(nullptr);\n#else\n    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);\n    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);\n    const auto stime = std::chrono::steady_clock::now();\n#endif\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;int&gt; a(n + 1), b(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; a[i];\n    for (int i = 1; i &lt;= n; ++i)\n        std::cin &gt;&gt; b[i];\n    if (a[1] != b[1] || a[n] != b[n]) &#123;\n        std::cout &lt;&lt; &quot;No&quot; &lt;&lt; &#39;\\n&#39;;\n        return 0;\n    &#125;\n    std::vector&lt;int&gt; da(n), db(n);\n    std::adjacent_difference(a.begin() + 1, a.end(), da.begin());\n    std::adjacent_difference(b.begin() + 1, b.end(), db.begin());\n    std::sort(da.begin(), da.end());\n    std::sort(db.begin(), db.end());\n    std::cout &lt;&lt; (da == db ? &quot;Yes&quot; : &quot;No&quot;) &lt;&lt; &#39;\\n&#39;;\n#ifndef ONLINE_JUDGE\n    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\\n&quot;;\n#endif\n    return 0;\n&#125;</code></pre>\n</details>\n",
            "tags": [
                "倍增",
                "树形 DP",
                "Kruskal 重构树"
            ]
        },
        {
            "id": "https://xsc062.netlify.app/20240106/",
            "url": "https://xsc062.netlify.app/20240106/",
            "title": "杂题选谈",
            "date_published": "2024-01-06T03:27:39.000Z",
            "content_html": "<p>想不到好标题了。</p>\n<span id=\"more\"></span>\n<p>有句话怎么说来着，罗马不是一天建成的，是一天天建成的。</p>\n<p>还有什么，Do in Rome as the Romans’ do，还有一句，All roads leads to Rome。</p>\n<hr />\n<h3 id=\"a.-连续的零-zero\">A. 连续的零 zero</h3>\n<p><a href=\"https://www.becoder.com.cn/contest/4647/problem/1\" class=\"uri\">https://www.becoder.com.cn/contest/4647/problem/1</a></p>\n<p>做个前缀和，看看任意一个长度为 <span class=\"math inline\">\\(k\\)</span> 的区间中有几个 <span class=\"math inline\">\\(1\\)</span>。复杂度 <span class=\"math inline\">\\(O(n)\\)</span>。</p>\n<details>\n<pre class=\"cpp\"><code>namespace XSC062 &#123;\nusing namespace fastIO;\nconst int maxn = 5e5 + 5;\nconst int inf = 0x3f3f3f3f;\nint n, m, res = inf;\nint a[maxn], s[maxn];\nint min(int x, int y) &#123;\n    return x &lt; y ? x : y;\n&#125;\nint main() &#123;\n    scanf(&quot;%d %d&quot;, &amp;n, &amp;m);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        scanf(&quot;%1d&quot;, &amp;a[i]);\n        s[i] = s[i - 1] + a[i];\n        if (i &gt;= m)\n            res = min(res, s[i] - s[i - m]);\n    &#125;\n    print(res, &#39;\\n&#39;);\n    return 0;\n&#125;\n&#125; // namespace XSC062</code></pre>\n</details>\n<hr />\n<h3 id=\"b.-反回文串-anti\">B. 反回文串 anti</h3>\n<p><a href=\"https://www.becoder.com.cn/contest/4647/problem/2\" class=\"uri\">https://www.becoder.com.cn/contest/4647/problem/2</a></p>\n<p>当 <span class=\"math inline\">\\(n\\)</span> 为奇时，中间的元素一定和自己相等，故无解。</p>\n<p>当数量最多的一个字符个数超过 <span class=\"math inline\">\\(\\dfrac n2\\)</span> 时，由鸽巢得无解。</p>\n<p>剩下的情况一定有解。</p>\n<details>\n<p><summary>证明</summary></p>\n<p>可以找到一种合法的构造方式。我们列出一个列数为 <span class=\"math inline\">\\(2\\)</span>，行数为 <span class=\"math inline\">\\(\\dfrac n2\\)</span> 的表格，将所有相同字母排列在一起，按照从左到右，从上到下的方式将字母填入表格，最后将第 <span class=\"math inline\">\\(i\\)</span> 行第一列的字母填入 <span class=\"math inline\">\\(a_i\\)</span>，第 <span class=\"math inline\">\\(i\\)</span> 行第二列的字母填入 <span class=\"math inline\">\\(a_{n-i+1}\\)</span>，即可完成构造。</p>\n<p>一种字母只在第一列或第二列出现当然合法，如果从第一列持续到第二列，因为任意字母出现次数不超过 <span class=\"math inline\">\\(\\dfrac n2\\)</span> 次，所以同一行的两列不会出现同一种字母。</p>\n<p>这叫什么，有字证明。</p>\n<p><del>感觉可以拿去出一道类似于「找到字符串字典序最小的反回文串」之类的小水题</del></p>\n</details>\n<p>然后现在我们知道有解了，怎么找到最优解呢。</p>\n<p>比如有一组 <span class=\"math inline\">\\((a_i,a_{n-i+1})=(\\texttt a, \\texttt a)\\)</span>，还有一组 <span class=\"math inline\">\\((a_j, a_{n-j+1})=(\\texttt b, \\texttt b)\\)</span>，那我们直接把 <span class=\"math inline\">\\(a_i\\)</span> 和 <span class=\"math inline\">\\(a_j\\)</span> 交换，皆大欢喜。</p>\n<p>这就说明我们需要把值不相等的非法 <span class=\"math inline\">\\(a_i\\)</span> 与 <span class=\"math inline\">\\(a_j\\)</span> 配对。</p>\n<p>然后我们就可以沿用证明中的构造方式，分组配对，一定最优，每组代价为 <span class=\"math inline\">\\(1\\)</span>。</p>\n<p>同一行两个值 <span class=\"math inline\">\\(v\\)</span> 相等，因为已经最优了，所以不能再在非法串中寻找答案。应该找合法对中某个值交换，每组代价为 <span class=\"math inline\">\\(2\\)</span>。具体和谁交换我们不用担心，只要找到一组 <span class=\"math inline\">\\((a_i,a_{n-i+1})\\)</span> 满足 <span class=\"math inline\">\\(a_i\\ne v\\)</span> 且 <span class=\"math inline\">\\(a_{n-i+1}\\ne v\\)</span> 就可以了，然后我们又知道 <span class=\"math inline\">\\(v\\)</span> 的个数 <span class=\"math inline\">\\(\\ne \\dfrac n2\\)</span>，假设 <span class=\"math inline\">\\(\\dfrac n2\\)</span> 对中每队都有至少一个 <span class=\"math inline\">\\(v\\)</span>，由于当前这一对有两个相同的 <span class=\"math inline\">\\(v\\)</span>，那么 <span class=\"math inline\">\\(v\\)</span> 的个数就会大于 <span class=\"math inline\">\\(\\dfrac n2\\)</span>，矛盾了，所以一定能找到。</p>\n<p>对于非法总对数是奇数的情况，我们要钦定一个非法对强制让其和合法对交换，贪心一下取非法对数量最多的 <span class=\"math inline\">\\(v\\)</span> 的某一对最优。</p>\n<details>\n<pre class=\"cpp\"><code>namespace XSC062 &#123;\nusing namespace fastIO;\nconst int maxm = 35;\nconst int maxn = 2e5 + 5;\nchar s[maxn];\nint cnt[maxm], p[maxn];\nint T, n, tot, res, now;\nint main() &#123;\n    scanf(&quot;%d&quot;, &amp;T);\n    while (T--) &#123;\n        tot = 0;\n        scanf(&quot;%d %s&quot;, &amp;n, s + 1);\n        if (n &amp; 1) &#123;\n            puts(&quot;-1&quot;);\n            continue;\n        &#125;\n        memset(cnt, 0, sizeof (cnt));\n        for (int i = 1; i &lt;= n; ++i)\n            ++cnt[s[i] - &#39;a&#39; + 1];\n        for (int i = 1; i &lt;= 26; ++i) &#123;\n            if (cnt[i] * 2 &gt; n) &#123;\n                puts(&quot;-1&quot;);\n                goto noSol;\n            &#125;\n        &#125;\n        memset(cnt, 0, sizeof (cnt));\n        for (int i = 1; i * 2 &lt;= n; ++i) &#123;\n            if (s[i] == s[n - i + 1])\n                ++cnt[s[i] - &#39;a&#39; + 1], ++tot;\n        &#125;\n        std::sort(cnt + 1, cnt + 27,\n                    std::greater&lt;int&gt;());\n        res = now = 0;\n        if (tot &amp; 1) &#123;\n            res = 1, --cnt[1];\n            std::sort(cnt + 1, cnt + 27,\n                        std::greater&lt;int&gt;());\n        &#125;\n        for (int i = 1; i &lt;= 26; ++i) &#123;\n            while (cnt[i]--) &#123;\n                if (++now &gt; tot / 2) &#123;\n                    if (i == p[now - tot / 2])\n                        res += 2;\n                    else ++res;\n                &#125;\n                else p[now] = i;\n            &#125;\n        &#125;\n        print(res, &#39;\\n&#39;);\n        noSol: ;\n    &#125;\n    return 0;\n&#125;\n&#125; // namespace XSC062</code></pre>\n</details>\n<hr />\n<h3 id=\"c.-除与减-divsub\">C. 除与减 divsub</h3>\n<p><a href=\"https://www.becoder.com.cn/contest/4647/problem/3\" class=\"uri\">https://www.becoder.com.cn/contest/4647/problem/3</a></p>\n<p>小数学，还好。</p>\n<p>假设 <span class=\"math inline\">\\(n=d\\times k^p\\)</span>，其中 <span class=\"math inline\">\\(k\\nmid d\\)</span>，那么我们分两种情况讨论。</p>\n<ol type=\"1\">\n<li><p><span class=\"math inline\">\\(p=0\\)</span>，即 <span class=\"math inline\">\\(k\\nmid n\\)</span>，那么 <span class=\"math inline\">\\(n\\bmod k=1\\)</span>，即 <span class=\"math inline\">\\(k\\mid (n-1)\\)</span>。</p>\n这个时候问 <span class=\"math inline\">\\(k\\)</span> 的个数就相当于是在问 <span class=\"math inline\">\\(n-1\\)</span> 除 <span class=\"math inline\">\\(1\\)</span> 以外的因子个数。假设 <span class=\"math inline\">\\(n-1={x_1}^{p_1}{x_2}^{p_2}\\cdots {x_m}^{p_m}\\)</span>，那么答案为 <span class=\"math inline\">\\((\\prod p_i+1)-1\\)</span>，减去的是 <span class=\"math inline\">\\(1\\)</span>。</li>\n<li><p><span class=\"math inline\">\\(p\\ne 0\\)</span>，<span class=\"math inline\">\\(k\\mid n\\)</span>。</p>\n<p>这个时候好像并没有什么好的转化。好消息是 <span class=\"math inline\">\\(n\\)</span> 的范围是 <span class=\"math inline\">\\(10^{12}\\)</span>，根号枚举因数复杂度跑得过。所以我们就可以暴力判定 <span class=\"math inline\">\\(n\\)</span> 的所有因数是否满足条件。</p></li>\n</ol>\n<p>时间复杂度，<span class=\"math inline\">\\(O(\\sqrt n\\times \\log n)\\)</span>，枚举因数是根号，算次数（也就是算 <span class=\"math inline\">\\(d\\)</span>）是 <span class=\"math inline\">\\(\\log\\)</span>。</p>\n<details>\n<pre class=\"cpp\"><code>#define int long long\nnamespace XSC062 &#123;\nusing namespace fastIO;\nint n, m, res, cnt;\nint main() &#123;\n    read(n), m = n;\n    for (int i = 2; i * i &lt;= n; ++i) &#123;\n        if (n % i == 0) &#123;\n            m = n;\n            while (m % i == 0) m /= i;\n            if (m % i == 1) ++res;\n            if (i * i != n) &#123;\n                m = n;\n                while (m % (n / i) == 0)\n                    m /= (n / i);\n                if (m % (n / i) == 1) ++res;\n            &#125;\n        &#125;\n    &#125;\n    m = n - 1, cnt = 1;\n    for (int i = 2; i * i &lt;= m; ++i) &#123;\n        if (m % i == 0) &#123;\n            int now = 0;\n            while (m % i == 0)\n                ++now, m /= i;\n            cnt *= now + 1;\n        &#125;\n    &#125;\n    if (m != 1) cnt *= 2;\n    print(res + cnt, &#39;\\n&#39;);\n    return 0;\n&#125;\n&#125; // namespace XSC062\n#undef int</code></pre>\n</details>\n<hr />\n<h3 id=\"d.-图书管理员-librarian\">D. 图书管理员 librarian</h3>\n<p><a href=\"https://www.becoder.com.cn/contest/4647/problem/4\" class=\"uri\">https://www.becoder.com.cn/contest/4647/problem/4</a></p>\n<p>[SDOI2008] 郁闷的小 J。</p>\n<p>关于这个，我们发现自己不会考场现冲主席树。哎，打 CDQ 又怕写挂。</p>\n<p>我们发现这道题的修改都是单点的，询问也只关于某一种颜色，不同的颜色之间没有影响。</p>\n<p>于是我们可以把操作离线下来，初始视作将某颜色在某位置增加，修改视作将某颜色在某位置删除，将另一颜色在该位置增加，将所有操作按颜色离散化分类然后 <code>vector</code> 下来，对于所有颜色从前到后树状数组做一遍操作就能 <span class=\"math inline\">\\(O(n\\log n+q\\log n)\\)</span> 解决。</p>\n<p>树状数组清空是肯定不能 <code>memset</code> 的，复杂度不对。那么怎么办呢？把所有操作撤回去就可以了。</p>\n<p>顺带一提我是洛谷上最优解。</p>\n<details>\n<pre class=\"cpp\"><code>namespace XSC062 &#123;\nusing namespace fastIO;\nconst int maxn = 2e5 + 5;\nstruct __ &#123;\n    int ty, l, r, v;\n    __() &#123;&#125;\n    __(int t1, int l1, int r1, int v1 = 0) &#123;\n        if (t1 == 0)\n            ty = 0, l = l1, v = r1;\n        else ty = 1, l = l1, r = r1, v = v1;\n    &#125;\n&#125;;\nchar ty;\nstd::map&lt;int, int&gt; tab;\nstd::vector&lt;__&gt; q[maxn];\nint n, m, tot, x, y, v, id;\nint Bit[maxn], a[maxn], res[maxn];\nint lowbit(int x) &#123; return x &amp; -x; &#125;\nvoid add(int x, int v) &#123;\n    for (; x &lt;= n; x += lowbit(x))\n        Bit[x] += v;\n    return;\n&#125;\nint ask(int x) &#123;\n    int res = 0;\n    for (; x; x -= lowbit(x)) res += Bit[x];\n    return res;\n&#125;\nint main() &#123;\n    read(n), read(m);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        read(a[i]);\n        if (!tab.count(a[i]))\n            tab[a[i]] = ++tot;\n        a[i] = tab[a[i]];\n        q[a[i]].emplace_back(0, i, 1);\n    &#125;\n    while (m--) &#123;\n        scanf(&quot;%1s&quot;, &amp;ty);\n        if (ty == &#39;C&#39;) &#123;\n            read(x), read(y);\n            if (!tab.count(y))\n                tab[y] = ++tot;\n            y = tab[y];\n            q[a[x]].emplace_back(0, x, -1);\n            q[a[x] = y].emplace_back(0, x, 1);\n        &#125;\n        else &#123;\n            ++id;\n            read(x), read(y), read(v);\n            if (!tab.count(v)) continue;\n            v = tab[v];\n            q[v].emplace_back(1, x, y, id);\n        &#125;\n    &#125;\n    for (int i = 1; i &lt;= tot; ++i) &#123;\n        for (auto &amp;j : q[i]) &#123;\n            if (j.ty == 0) add(j.l, j.v);\n            else &#123;\n                res[j.v] =\n                    ask(j.r) - ask(j.l - 1);\n            &#125;\n        &#125;\n        for (auto &amp;j : q[i])\n            if (j.ty == 0) add(j.l, -j.v);\n    &#125;\n    for (int i = 1; i &lt;= id; ++i)\n        print(res[i], &#39;\\n&#39;);\n    return 0;\n&#125;\n&#125; // namespace XSC062</code></pre>\n</details>\n<hr />\n<p>E 会单独开一篇。</p>\n<hr />\n<h3 id=\"f.-树-tree\">F. 树 tree</h3>\n<p><a href=\"https://www.becoder.com.cn/contest/4647/problem/6\" class=\"uri\">https://www.becoder.com.cn/contest/4647/problem/6</a></p>\n<p>CF916E。</p>\n<p>大分讨给我整不会了，更给我整不会的是下来过后发现这只是个小分讨。</p>\n<p>更新子树和子树查询我们都会。换根 DP 我们也都写过，都知道换根并不会对子树结构产生大的影响。所以应当是能根据已知信息推测出子树在原树上对应的点集的。</p>\n<p>记 <span class=\"math inline\">\\(r\\)</span> 为当前树根，<span class=\"math inline\">\\(\\text {LCA}(x,y)\\)</span> 为 <span class=\"math inline\">\\(x,y\\)</span> 在 <span class=\"math inline\">\\(1\\)</span> 为根时的 LCA，<span class=\"math inline\">\\(\\text {LCA}&#39;(x,y)\\)</span> 表示 <span class=\"math inline\">\\(x,y\\)</span> 在 <span class=\"math inline\">\\(r\\)</span> 为根时的 LCA。</p>\n<p>那么对于 <span class=\"math inline\">\\(\\text {LCA}&#39;(x,y)\\)</span>，肯定是要讨论 <span class=\"math inline\">\\(x,y\\)</span> 和 <span class=\"math inline\">\\(r\\)</span> 的位置关系的。</p>\n<ol type=\"1\">\n<li><span class=\"math inline\">\\(\\text {LCA}(x,y)\\)</span> 是 <span class=\"math inline\">\\(r\\)</span> 的子孙。此时 <span class=\"math inline\">\\(\\text {LCA}&#39;(x,y) = \\text {LCA}(x,y)\\)</span>。</li>\n<li><span class=\"math inline\">\\(\\text {LCA}(x,y)\\)</span> 是 <span class=\"math inline\">\\(r\\)</span> 的祖先。那么说明至少有一个点不是 <span class=\"math inline\">\\(r\\)</span> 的子孙。此时 <span class=\"math inline\">\\(\\text {LCA}(x,y)&#39;\\)</span> 的值为 <span class=\"math inline\">\\(r\\)</span> 为另一个点的 LCA。</li>\n</ol>\n<p>整理可得 <span class=\"math inline\">\\(\\text {LCA}&#39;(x,y)\\)</span> 是 <span class=\"math inline\">\\(\\text {LCA}(x,y)\\)</span>、<span class=\"math inline\">\\(\\text {LCA}(x,r)\\)</span> 和 <span class=\"math inline\">\\(\\text {LCA}(y,r)\\)</span> 中的深度最大者。</p>\n<p>对于以 <span class=\"math inline\">\\(r\\)</span> 为根时的子树 <span class=\"math inline\">\\(x\\)</span>：</p>\n<ol type=\"1\">\n<li><span class=\"math inline\">\\(x=r\\)</span>，此时子树为整棵树。</li>\n<li><span class=\"math inline\">\\(\\text {LCA}(x,r)\\ne x\\)</span>，即 <span class=\"math inline\">\\(r\\)</span> 不为 <span class=\"math inline\">\\(x\\)</span> 的子孙，此时子树就是以 <span class=\"math inline\">\\(1\\)</span> 为根是的子树 <span class=\"math inline\">\\(x\\)</span>。</li>\n<li><span class=\"math inline\">\\(\\text {LCA}(x,y)=x\\)</span>，即 <span class=\"math inline\">\\(r\\)</span> 为 <span class=\"math inline\">\\(x\\)</span> 的子孙，此时子树是整棵树除开 <span class=\"math inline\">\\(x\\)</span> 包含 <span class=\"math inline\">\\(r\\)</span> 的儿子及其子孙。修改和查询的时候容斥一下就好。这个时候的子树倍增跳一下就能找到。</li>\n</ol>\n<p>然后就是常规线段树维护了。时间复杂度 <span class=\"math inline\">\\(O(n\\log n)\\)</span>。</p>\n<details>\n<pre class=\"cpp\"><code>namespace XSC062 &#123;\nusing namespace fastIO;\nconst int maxm = 35;\nconst int maxn = 1e5 + 5;\n#define lt (p &lt;&lt; 1)\n#define rt (lt | 1)\nstruct _ &#123; int l, r, u, d; &#125;;\n_ t[maxn &lt;&lt; 2];\nint f[maxn][maxm];\nstd::vector&lt;int&gt; g[maxn];\nint a[maxn], dfn[maxn], rfn[maxn];\nint n, q, r, ty, x, y, v, si, now;\nint top[maxn], dep[maxn], tab[maxn];\nvoid swap(int &amp;x, int &amp;y) &#123;\n    x ^= y ^= x ^= y;\n    return;\n&#125;\nvoid DFS(int x) &#123;\n    dep[x] = dep[f[x][0]] + 1;\n    dfn[x] = ++now, tab[now] = x;\n    for (auto i : g[x]) &#123;\n        if (i == f[x][0]) continue;\n        f[i][0] = x;\n        for (int j = 1; j &lt;= si; ++j)\n            f[i][j] = f[f[i][j - 1]][j - 1];\n        DFS(i);\n    &#125;\n    rfn[x] = now;\n    return;\n&#125;\nvoid pushup(int p) &#123;\n    t[p].u = t[lt].u + t[rt].u;\n    return;\n&#125;\nvoid pushdown(int p) &#123;\n    if (t[p].d) &#123;\n        t[lt].d += t[p].d;\n        t[rt].d += t[p].d;\n        t[lt].u += t[p].d *\n                (t[lt].r - t[lt].l + 1);\n        t[rt].u += t[p].d *\n                (t[rt].r - t[rt].l + 1);\n        t[p].d = 0;\n    &#125;\n    return;\n&#125;\nvoid bld(int p, int l, int r) &#123;\n    t[p].l = l, t[p].r = r;\n    if (l == r) &#123;\n        t[p].u = a[tab[l]];\n        return;\n    &#125;\n    int mid = (l + r) &gt;&gt; 1;\n    bld(lt, l, mid), bld(rt, mid + 1, r);\n    pushup(p);\n    return;\n&#125;\nvoid add(int p, int x, int v) &#123;\n    t[p].u += v;\n    if (t[p].l == t[p].r) return;\n    pushdown(p);\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (x &lt;= mid) add(lt, x, v);\n    else add(rt, x, v);\n    return;\n&#125;\nvoid add(int p, int l, int r, int v) &#123;\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r) &#123;\n        t[p].d += v;\n        t[p].u += (t[p].r - t[p].l + 1) * v;\n        return;\n    &#125;\n    pushdown(p);\n    int mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (l &lt;= mid) add(lt, l, r, v);\n    if (r &gt; mid) add(rt, l, r, v);\n    pushup(p);\n    return;\n&#125;\nint ask(int p, int l, int r) &#123;\n    if (l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r)\n        return t[p].u;\n    pushdown(p);\n    int res = 0,\n        mid = (t[p].l + t[p].r) &gt;&gt; 1;\n    if (l &lt;= mid) res = ask(lt, l, r);\n    if (r &gt; mid) res += ask(rt, l, r);\n    return res;\n&#125;\nint LCA(int x, int y) &#123;\n    if (dep[x] &lt; dep[y]) swap(x, y);\n    for (int i = si; ~i; --i) &#123;\n        if (dep[f[x][i]] &gt;= dep[y])\n            x = f[x][i];\n    &#125;\n    if (x == y) return x;\n    for (int i = si; ~i; --i) &#123;\n        if (f[x][i] != f[y][i])\n            x = f[x][i], y = f[y][i];\n    &#125;\n    return f[x][0];\n&#125;\nvoid Add(int x, int v) &#123;\n    int rlca = LCA(r, x);\n    if (x == r) add(1, 1, n, v);\n    else if (rlca != x)\n        add(1, dfn[x], rfn[x], v);\n    else &#123;\n        add(1, 1, n, v);\n        int p = r;\n        for (int i = si; ~i; --i) &#123;\n            if (dep[f[p][i]] &gt;= dep[x] + 1)\n                p = f[p][i];\n        &#125;\n        add(1, dfn[p], rfn[p], -v);\n    &#125;\n    return;\n&#125;\nvoid tAdd(int x, int y, int v) &#123;\n    int llca = LCA(r, x), rlca = LCA(r, y),\n        ulca = LCA(x, y);\n    if (dep[llca] &gt;= dep[rlca] &amp;&amp;\n        dep[llca] &gt;= dep[ulca]) Add(llca, v);\n    else if (dep[rlca] &gt;= dep[llca] &amp;&amp;\n        dep[rlca] &gt;= dep[ulca]) Add(rlca, v);\n    else Add(ulca, v);\n    return;\n&#125;\nint tAsk(int x) &#123;\n    int rlca = LCA(r, x);\n    if (x == r) return t[1].u;\n    if (rlca != x)\n        return ask(1, dfn[x], rfn[x]);\n    int p = r;\n    for (int i = si; ~i; --i) &#123;\n        if (dep[f[p][i]] &gt;= dep[x] + 1)\n            p = f[p][i];\n    &#125;\n    return t[1].u - ask(1, dfn[p], rfn[p]);\n&#125;\nvoid add(int x, int y) &#123;\n    g[x].push_back(y);\n    return;\n&#125;\nint main() &#123;\n    read(n), read(q), r = 1;\n    si = log(n) / log(2.0);\n    for (int i = 1; i &lt;= n; ++i) read(a[i]);\n    for (int i = 1; i &lt; n; ++i) &#123;\n        read(x), read(y);\n        add(x, y), add(y, x);\n    &#125;\n    dep[0] = 1, DFS(1), dep[0] = 0;\n    bld(1, 1, n);\n    while (q--) &#123;\n        read(ty);\n        if (ty == 1) read(r);\n        else if (ty == 2) &#123;\n            read(x), read(y), read(v);\n            tAdd(x, y, v);\n        &#125;\n        else &#123;\n            read(x);\n            print(tAsk(x), &#39;\\n&#39;);\n        &#125;\n    &#125;\n    return 0;\n&#125;\n&#125; // namespace XSC062\n#undef int</code></pre>\n</details>\n",
            "tags": [
                "线段树",
                "树状数组",
                "LCA",
                "倍增",
                "鸽巢原理"
            ]
        }
    ]
}