<!DOCTYPE html>
<html>
<head>
    <!-- 网站图标 -->
<link rel="icon" type="image/png" sizes="32x32" href="/images/icon.svg">
<!-- 其他图标支持 -->
<link rel="stylesheet" href="/css/facss/fa-brands.min.css">
<link rel="stylesheet" href="/css/facss/fa-regular.min.css">
<link rel="stylesheet" href="/css/facss/fa-solid.min.css">
<link rel="stylesheet" href="/css/facss/fontawesome.min.css">
<link rel="stylesheet" href="/css/facss/fontawesome-all.css">
<link href="https://use.fontawesome.com/releases/v5.0.4/css/all.css" rel="stylesheet">
<!-- 网站标题 -->
<title>
	
		DP 凸优化 -
	
	XSC062 的博客
</title>
<!-- js 引入 -->
<script>
const searchPath = "/search.xml"
</script>

<script src="/js/afterloaded.js"></script>


<script src="/js/jQuery.js"></script>

<!-- 载入 Valine -->
<script src="//unpkg.com/valine/dist/Valine.min.js"></script>
<!-- css 引入 -->

<link rel="stylesheet" href="/css/layout.css">


<link rel="stylesheet" href="/css/prcss/prism.css">



<!-- rss -->
<link rel="alternate" type="application/rss+xml" title="" href="https://xsc062.netlify.app/rss.xml" />
<link rel="alternate" type="application/atom+xml" title="" href="https://xsc062.netlify.app/atom.xml" />
<link rel="alternate" type="application/json" title="" href="https://xsc062.netlify.app/feed.json" />

<meta charset="utf-8"> 
<meta name="generator" content="Hexo 7.2.0"></head>
<body class="line-numbers match-braces no-brace-select rainbow-braces">
	
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
          tex2jax: {
            inlineMath: [ ['$','$'], ["\\(","\\)"] ],
            processEscapes: true
          }
        });
      </script>
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
            tex2jax: {
              skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
            }
          });
      </script>
    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
              var all = MathJax.Hub.getAllJax(), i;
              for(i=0; i < all.length; i += 1) {
                  all[i].SourceElement().parentNode.className += ' has-jax';
              }
          });
      </script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.6/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

	<!-- 搜索 -->
<div id="search-bg">
	<div id="search-box">
		<input type="text" id="search-input" placeholder="Type to search...">
		<div id="search-results">键入以搜索</div>
	</div>
</div>
<!-- 顶栏整体导航菜单 -->
<div class="ui top menu">
	<!-- 左对齐 logo -->
	<a class="logo" href="/">
		<img src="/images/icon.png"></img>
		<div id="bartitle">
			XSC062 的博客
		</div>
	</a>
	<!-- 右对齐部分导航 -->
	<div id="rightali">
		<a class="item" id="Search" type="button">
			<i class="btn text-muted fa fa-search" id="search-icon" disabled></i>
		</a>
		<a class="item" id="Home" href="/">
			Home
		</a>
		<a class="item" id="Arch" href="/archives">
			Archives
		</a>
		<!-- <a class="item" id="Cate" href="/categories">
			Categories
		</a> -->
		<a class="item" id="Tags" href="/tags">
			Tags
		</a>
		<a class="item" id="Frie" href="/friends">
			Friends
		</a>
		<a class="item" id="Abou" href="/about">
			About
		</a>
	</div>
</div>
    
<link rel="stylesheet" href="/css/post.css">


<script src="/js/post.js"></script>


<div class="main">
	<div id="sidebar">
		<aside id="toc">
			<span id="toctitle">
				<i class="fas fa-list"></i>
				目录
			</span>
			<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%87%B8%E5%87%BD%E6%95%B0"><span class="toc-text">什么是凸函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-text">定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A4%E5%AE%9A"><span class="toc-text">判定</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%A7%E8%B4%A8"><span class="toc-text">性质</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#wqs-%E4%BA%8C%E5%88%86"><span class="toc-text">WQS 二分</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E4%BB%BB%E5%8A%A1"><span class="toc-text">主要任务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%86%E8%8A%82%E5%A4%84%E7%90%86"><span class="toc-text">细节处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E7%A7%8D%E6%A0%91"><span class="toc-text">例：种树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8Braper"><span class="toc-text">例：Raper</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E9%97%B4%E5%88%86%E6%8B%86%E9%97%AE%E9%A2%98"><span class="toc-text">区间分拆问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%B5%E5%8F%AF%E5%A4%AB%E6%96%AF%E5%9F%BA%E5%92%8C"><span class="toc-text">闵可夫斯基和</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8Bits-mooin-time-p"><span class="toc-text">例：It&#39;s Mooin&#39; Time P</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E5%81%87%E4%BA%BA"><span class="toc-text">例：假人</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#slope-trick"><span class="toc-text">slope trick</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E5%BA%8F%E5%88%97-sequence"><span class="toc-text">例：序列 sequence</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E7%83%9F%E8%8A%B1%E8%A1%A8%E6%BC%94"><span class="toc-text">例：烟花表演</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8Bbuy-low-sell-high"><span class="toc-text">例：Buy Low Sell High</span></a></li></ol></li></ol>
		</aside>
	</div>
	<div class="ui post container">
		<div class="ui text container">
			<span id="postcon">
				<span id="postinfo">
					<div class="ui post title">
						<div id="fortitle" data-content="DP 凸优化">
							DP 凸优化
						</div>
						<div class="ui title background">
						</div>
					</div>
					<span id="date">
						<i class="fas fa-calendar-alt" style="margin-right: 4px;"></i>
						2025-07-07
					</span>
				</span>
			</span>
			<div id="posttags" class="dotted border">
				
					
						<a href="/tags/DP/" class="citem">DP</a>
					
						<a href="/tags/反悔贪心/" class="citem">反悔贪心</a>
					
						<a href="/tags/DP-优化/" class="citem">DP 优化</a>
					
						<a href="/tags/WQS-二分/" class="citem">WQS 二分</a>
					
						<a href="/tags/闵可夫斯基和/" class="citem">闵可夫斯基和</a>
					
						<a href="/tags/slope-trick/" class="citem">slope trick</a>
					
				
			</div>
			<!-- 本来用的是 fromNow 然后字符串判断，没想到可以直接调用 moment() -->
			
			<div id="content">
				<p>袜，这篇文章一下子创建了三个新 tag。</p>
<span id="more"></span>
<hr />
<h2 id="什么是凸函数">什么是凸函数</h2>
<h3 id="定义">定义</h3>
<p>在信息学中研究的凸函数大抵是只在正整数域上有定义的，所以只能直接摒弃导函数的概念了。</p>
<p>若斜率递增，换言之，差分数组递增，认为函数是凸的（好反直觉）。</p>
<p>或者看看符号化的定义：若对于任意 <span class="math inline">\(\lambda\in[0,1]\)</span>，函数 <span class="math inline">\(f(x)\)</span> 均满足：</p>
<p><span class="math display">\[
f(\lambda x+(1-\lambda) y)\le \lambda f(x)+(1-\lambda) f(y).
\]</span></p>
<p>或等价地：</p>
<p><span class="math display">\[
f(x)-f(x - 1)\le f(x + 1) - f(x)
\]</span></p>
<p>那么认为 <span class="math inline">\(f\)</span> 是凸函数。</p>
<p>因为凹凸在性质上没区别，所以 <strong>下文施行暴政，将凹函数和凸函数统称为凸函数</strong>。</p>
<hr />
<h3 id="判定">判定</h3>
<p>对于具体情境下的问题，怎么判断 DP 数组是否关于其某一维为凸函数？</p>
<ul>
<li>相信相信的力量（最常用）。</li>
<li><p>对于分段问题，证明分出来的每一段满足四边形不等式。</p>
<em>值得一提的是，数学上不认为满足四边形不等式能够推出函数为凸。但这是信息学.jpg</em></li>
<li><p>其由两个凸函数线性相加得到：</p>
<p>对于 <span class="math inline">\(\forall\, \lambda,\mu\ge 0\)</span> 和凸函数 <span class="math inline">\(f,g\)</span>，若 <span class="math inline">\(h=\lambda f+\mu g\)</span>，则 <span class="math inline">\(h\)</span> 为凸函数。</p>
此外，此时 <span class="math inline">\(h\)</span> 的差分数组和 <span class="math inline">\(f,g\)</span> 差分数组也满足上述关系。</li>
<li>其是两个凸函数的 <a href="#闵可夫斯基和">闵可夫斯基和</a>。</li>
<li><p>其由两个凸函数线性 max 得到。</p>
<p>对于两个凸函数的线性 min，一般不是凸函数，甚至可能是凹的。</p></li>
</ul>
<hr />
<h3 id="性质">性质</h3>
<ul>
<li>最值为唯一极值。</li>
<li>斜率 / 差分数组具有单调性。</li>
</ul>
<p>在解题中主要用到的大概就是上面两条。</p>
<hr />
<h2 id="wqs-二分">WQS 二分</h2>
<h3 id="主要任务">主要任务</h3>
<blockquote>
<p>例：把 <span class="math inline">\(a_{1\sim n}\)</span> 分为恰好 <span class="math inline">\(k\)</span> 段，每段的代价为 <span class="math inline">\(sum^2+c\)</span>（<span class="math inline">\(c\)</span> 为给定的常数），问最小代价。<span class="math inline">\(n\le 2\times 10^5,a_i\le 10^9\)</span>。</p>
</blockquote>
<p>如果对段数没有要求，可以用斜优 <span class="math inline">\(O(n)\)</span> 做。</p>
<p>加上了 <span class="math inline">\(k\)</span> 的限制，DP 变成二维的，令 <span class="math inline">\(f_{i,j}\)</span> 表示在 <span class="math inline">\(i\)</span> 处分第 <span class="math inline">\(j\)</span> 段，可以在第一维斜率优化，做到 <span class="math inline">\(O(nk)\)</span>；亦或发现 <span class="math inline">\((i,j)\)</span> 有决策单调性，然后四边形不等式优化到 <span class="math inline">\(O(n^2)\)</span>。</p>
<p>我们发现 <span class="math inline">\(f\)</span> 关于 <span class="math inline">\(j\)</span> 这一维是凸的（而非上文的 <span class="math inline">\((i,j)\)</span>），故将 <span class="math inline">\(f(n,j)\)</span> 关于 <span class="math inline">\(j\)</span> 的函数提取出来（记为 <span class="math inline">\(f_n(j)\)</span>）。发现只有最高点是可以一次斜优快速求出来的，故可以认为在当前复杂度限制下，整个函数除了最高点以外都是未知的（注意可以在 DP 时记录极值点的横坐标，即分了几段）。</p>
<p>我们给每个 <span class="math inline">\(f_n(j)\)</span> 加上 <span class="math inline">\(\alpha\cdot j\)</span>（在本题中即将 <span class="math inline">\(c\gets c+k\)</span>），勉强可以认为 <span class="math inline">\(\alpha\cdot j\)</span> 是凸的，所以新函数 <span class="math inline">\(f&#39;_n(j)\)</span> 也是凸的。若 <span class="math inline">\(k&gt;0\)</span>，可以感受到极值点向左偏移，且随着 <span class="math inline">\(k\)</span> 的增大，极值点不会右移；<span class="math inline">\(k&lt;0\)</span> 时同理。</p>
<p>结合几何观点，在 <span class="math inline">\(f_n\)</span> 上的极值点可以用斜率为 <span class="math inline">\(0\)</span> 的直线切到；而加上 <span class="math inline">\(\alpha\cdot j\)</span> 的过程，其实就是切线斜率减去 <span class="math inline">\(\alpha\)</span> 的过程。相当于令切线斜率为 <span class="math inline">\(-\alpha\)</span>，看看能切到哪里。</p>
<p>故可以二分一个合适的 <span class="math inline">\(k\)</span>，使得极值点的横坐标为 <span class="math inline">\(k\)</span>。此时 <span class="math inline">\(f&#39;_n(k)-\alpha\cdot k\)</span> 即为待求。</p>
<hr />
<p>WQS 二分参与的问题一般以如下形式呈现：</p>
<blockquote>
<p>给定序列，将其恰好分为 <span class="math inline">\(k\)</span> 段 / 恰好选 <span class="math inline">\(k\)</span> 个，求最大 / 最小代价。</p>
</blockquote>
<p>题目要求最大 / 最小值一般能够反映函数的凹凸性，可以根据这一点来猜。</p>
<hr />
<h3 id="细节处理">细节处理</h3>
<p>考虑如下凸函数：</p>
<p><img src="1.png" /></p>
<ul>
<li>显然对于『凸出来』的点（即图中除了 <span class="math inline">\(E,H\)</span> 以外的点），能切到的直线斜率为一个范围；而位于直线上的点（途中 <span class="math inline">\(E,H\)</span>），能切到的直线斜率更是定死了。所以这要求你的二分精度需要略高一点。</li>
<li><p>对于 <span class="math inline">\(E\)</span>（或 <span class="math inline">\(H\)</span>），不能找到只过它一点的切线。根据 DP 的写法，记录的横坐标可能是最小的 <span class="math inline">\(D\)</span>，也可能是最大的 <span class="math inline">\(F\)</span>，此时你可以：</p>
<ul>
<li>同时记录最小和最大的横坐标，看看 <span class="math inline">\(k\)</span> 在不在中间。</li>
<li><p>题目要求最大代价时，记录最大横坐标，二分到一个极值点 <span class="math inline">\(k&#39;\ge k\)</span> 时，显然 <span class="math inline">\(\alpha&#39;\ge \alpha\)</span>，用 <span class="math inline">\(f&#39;_n(k&#39;)-\alpha&#39;\cdot k\)</span> 更新答案（是赋值而不是取最值）；求最小代价时同理。</p>
<p>主要是需要记住斜率是 <span class="math inline">\(\alpha\)</span> 的相反数，<del>实在搞不清对应关系可以都试一试</del></p></li>
</ul></li>
</ul>
<hr />
<h3 id="例种树">例：种树</h3>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1484" class="uri">https://www.luogu.com.cn/problem/P1484</a></p>
<p>首先，函数是凸的——感性理解即可。</p>
<p>接着，要求的是 <span class="math inline">\(\le k\)</span> 时的最值。分为两种情况：<span class="math inline">\(k\)</span> 是否右于原函数极值点。</p>
<ul>
<li>若 <span class="math inline">\(k\)</span> 右于原函数极值点，则原函数极值点为答案。</li>
<li>否则，<span class="math inline">\(k\)</span> 为答案。</li>
</ul>
<p>好消息是整数域上一定有解（最后答案为整、倒推即可），所以不用打浮点数二分了。</p>
<details>
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;
const int lim = 1e6;
const long long inf = 1e18;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n, k;
    std::cin &gt;&gt; n &gt;&gt; k;
    std::vector&lt;long long&gt; a(n + 1);
    for (int i = 1; i &lt;= n; ++i)
        std::cin &gt;&gt; a[i];
    auto calc = [&amp;](int c) &#123;
        std::vector&lt;std::pair&lt;long long, int&gt; &gt; f(n + 1);
        auto mx = f.front();
        auto upd = [&amp;](auto &amp;x, auto y) &#123;
            if (y.first &gt; x.first || (y.first == x.first &amp;&amp; y.second &lt; x.second))
                x = y;
            return;
        &#125;;
        for (int i = 1; i &lt;= n; ++i) &#123;
            f[i].first = mx.first + a[i] + c;
            f[i].second = mx.second + 1;
            upd(mx, f[i - 1]);
        &#125;
        upd(mx, f[n]);
        return mx;
    &#125;;
    auto t(calc(0));
    if (t.second &lt;= k) &#123;
        std::cout &lt;&lt; t.first &lt;&lt; &#39;\n&#39;;
        return 0;
    &#125;
    auto res(-inf);
    for (int l = -lim, r = lim, mid; l &lt;= r; ) &#123;
        mid = (l + r) &gt;&gt; 1;
        auto t = calc(mid);
        if (t.second &lt;= k)
            res = t.first - (long long)mid * k, l = mid + 1;
        else
            r = mid - 1;
    &#125;
    std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;</code></pre>
</details>
<hr />
<h3 id="例raper">例：Raper</h3>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P4694" class="uri">https://www.luogu.com.cn/problem/P4694</a></p>
<p>给所有光盘附一个奖励 <span class="math inline">\(mid\)</span>，进行 WQS 二分。</p>
<p>然后内层就和 <a href="#例序列-sequence">sequence</a> 差得不是特别多，所以考虑反悔贪心。（？）</p>
<p>把路过的 <span class="math inline">\(-a_j\)</span> 丢到大根堆里，尝试和 <span class="math inline">\(b_i\)</span> 配对。如果 <span class="math inline">\(mid-a_i-b_i\ge 0\)</span> 那么暂时配对，顺便把 <span class="math inline">\(b_i-mid\)</span> 丢进去用于反悔，若 <span class="math inline">\(b_{i&#39;}\)</span> 选中了 <span class="math inline">\(b_i-mid\)</span> 说明反悔，将 <span class="math inline">\(a_j\)</span> 与 <span class="math inline">\(b_{i&#39;}\)</span> 配对。</p>
<p>贪心的时候需要记录已经配的对数，优先队列中需要对 <span class="math inline">\(-a_j\)</span> 和 <span class="math inline">\(b_i-mid\)</span> 打标记进行区分，匹配到前者时才增加成功对数。</p>
<p>发现整数域上仍然必有解（答案为整，倒推），不用打浮点数二分 neiher.</p>
<details>
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;
const long long inf = 2e9 + 5;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n, k;
    std::cin &gt;&gt; n &gt;&gt; k;
    std::vector&lt;int&gt; a(n + 1), b(n + 1);
    for (int i = 1; i &lt;= n; ++i)
        std::cin &gt;&gt; a[i];
    for (int i = 1; i &lt;= n; ++i)
        std::cin &gt;&gt; b[i];
    auto calc = [&amp;](long long mid) &#123;
        std::priority_queue&lt;std::pair&lt;long long, int&gt; &gt; q;
        int cnt = 0;
        auto res(0ll);
        for (int i = 1; i &lt;= n; ++i) &#123;
            q.emplace(-a[i], 1);
            auto [v, ty] = q.top();
            if (mid + v - b[i] &gt;= 0) &#123;
                q.pop(), cnt += ty;
                res += mid + v - b[i], q.emplace(b[i] - mid, 0);
            &#125;
        &#125;
        return std::make_pair(cnt, res);
    &#125;;
    auto res(inf);
    for (long long l = 1ll, r = inf, mid; l &lt;= r; ) &#123;
        mid = (l + r) &gt;&gt; 1;
        auto t(calc(mid));
        if (t.first &gt;= k)
            r = mid - 1, res = -(t.second - k * mid);
        else
            l = mid + 1;
    &#125;
    std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;</code></pre>
</details>
<hr />
<h3 id="区间分拆问题">区间分拆问题</h3>
<p>目标：尝试将 <span class="math inline">\(a_{1\sim n}\)</span> 分割成恰好 <span class="math inline">\(k\)</span> 段，定义 <span class="math inline">\(w(i,j)\)</span> 为将 <span class="math inline">\([i,j]\)</span> 作为一段的代价，求代价最值。其中 <span class="math inline">\(w(i,j)\)</span> 满足四边形不等式。</p>
<p>不妨设求最小代价。定义 <span class="math inline">\(f(i,j)\)</span> 在 <span class="math inline">\(i\)</span> 处分第 <span class="math inline">\(j\)</span> 段，那么有：</p>
<p><span class="math display">\[
f(i,j)=\min(f(i-1,p-1)+w(p,j)).
\]</span></p>
<blockquote>
<p>有定理：若 <span class="math inline">\(w(i,j)\)</span> 满足四边形不等式，那么有 <span class="math inline">\(f(i-1,j)\le f(i,j)\le f(i,j+1)\)</span>，从 <span class="math inline">\(f\)</span> 定义出发很好感性理解。</p>
</blockquote>
<p>那么可以从这一点出发，<span class="math inline">\(p\)</span> 这一维就可以被摊掉，做到 <span class="math inline">\(O(n(n+m))\)</span>。</p>
<blockquote>
<p>有定理：若 <span class="math inline">\(w(i,j)\)</span> 满足四边形不等式，那么 <span class="math inline">\(f_i(j)\)</span> 是凸函数。</p>
</blockquote>
<p>那很好了。直接冲刺 WQS 即可。</p>
<hr />
<h2 id="闵可夫斯基和">闵可夫斯基和</h2>
<p>给定两个凸函数（当然是指 OI 中那种长得很直的函数），将它们的『边』拆下来过后，以某种方式拼在一起，使得最后得到一个新的凸函数。</p>
<p>按每条『边』的斜率归并一下就可以得到，显然答案存在且唯一，这个过程被称为闵可夫斯基和。可以发现这是一种最值 - 加卷积。</p>
<p>假设我们要求的 DP 数组是两个已知的子数组以类似的方法卷起来的，最后要求完整的 DP 数组（而非 WQS 中的单点值），就可以考虑闵可夫斯基和。</p>
<p>发现这个结构是很适合归并的，使用归并要求状态中含有版本维、因变量维。</p>
<hr />
<h3 id="例its-mooin-time-p">例：It's Mooin' Time P</h3>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P11459" class="uri">https://www.luogu.com.cn/problem/P11459</a></p>
<p>定义 <span class="math inline">\(w_i\)</span> 为将 <span class="math inline">\([i,i+L)\)</span> 改为 <code>MOO</code> 的代价，问题转化为选取 <span class="math inline">\(1\sim \frac nL\)</span> 个不重区间的最小代价和。</p>
<p>尝试归并，每次将 <span class="math inline">\([l,mid]\)</span> 和 <span class="math inline">\((mid, r]\)</span> 卷起来。但是会有一点问题：如果恰好有区间卡在中间呢？</p>
<p>可以令 <span class="math inline">\(f_{l,r,0/1/2,0/1/2}(i)\)</span> 表示在 <span class="math inline">\([l,r]\)</span> 内选了 <span class="math inline">\(i\)</span> 个 <code>MOO</code>，且两侧最远的被选点距离端点为 <span class="math inline">\(0/1/\ge 2\)</span> 的 DP 值。然后可以进行相应的讨论、平移、闵可夫斯基和，最后将所有情况线性取 max 得到这一层的答案，容易发现得到的答案也是凸的。</p>
<details>
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;
const long long inf = 1e18;
int L;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n;
    std::cin &gt;&gt; L &gt;&gt; n;
    std::vector&lt;int&gt; a(n + 1);
    std::vector&lt;char&gt; t(n + 1);
    std::vector&lt;long long&gt; w(n + 1);
    for (int i = 1; i &lt;= n; ++i)
        std::cin &gt;&gt; t[i];
    for (int i = 1; i &lt;= n; ++i)
        std::cin &gt;&gt; a[i];
    for (int i = 1; i &lt;= n - L + 1; ++i) &#123;
        w[i] = a[i] * (t[i] != &#39;M&#39;);
        for (int j = i + 1; j &lt; i + L; ++j)
            w[i] += a[j] * (t[j] != &#39;O&#39;);
        // printf(&quot;[%d, %d]: %lld\n&quot;, i, i + L - 1, w[i]);
    &#125;
    if (L == 1) &#123;
        std::sort(w.begin() + 1, w.end());
        auto s(0ll);
        for (int i = 1; i &lt;= n; ++i) &#123;
            s += w[i];
            std::cout &lt;&lt; s &lt;&lt; &#39;\n&#39;;
        &#125;
        return 0;
    &#125;
    using arr = std::vector&lt;long long&gt;;
    using brr = std::vector&lt;arr&gt;;
    using crr = std::vector&lt;brr&gt;;
    struct node &#123;
        crr f;
        node(int len): f(L, brr(L, arr(len, inf))) &#123;
            for (int i = 0; i &lt; L; ++i)
                for (int j = 0; j &lt; L; ++j)
                    f[i][j][0] = 0ll;
            return;
        &#125;
        brr&amp; operator[] (int q) &#123; return f[q]; &#125;
    &#125;;
    auto upd = [&amp;](arr &amp;x, arr y) &#123;
        if (x.size() &lt; y.size())
            x.resize(y.size(), inf);
        for (int i = 0; i &lt; (int)y.size(); ++i)
            x[i] = std::min(x[i], y[i]);
        return;
    &#125;;
    auto merge = [&amp;](arr l, arr r) &#123;
        arr out((int)(l.size() + r.size()) - 1), dl(l.size()), dr(r.size());
        for (int i = 1; i &lt; (int)l.size(); ++i)
            dl[i] = l[i] - l[i - 1];
        for (int i = 1; i &lt; (int)r.size(); ++i)
            dr[i] = r[i] - r[i - 1];
        std::merge(dl.begin() + 1, dl.end(), dr.begin() + 1, dr.end(), out.begin() + 1);
        out[0] = l[0] + r[0];
        std::partial_sum(out.begin(), out.end(), out.begin());
        return out;
    &#125;;
    std::function&lt;node(int, int)&gt; calc = [&amp;](int l, int r) &#123;
        if (r - l + 1 &lt; 2 * L) &#123;
            node res(1);
            for (int ll = 0; ll &lt; L; ++ll)
                for (int rr = 0; rr &lt; L; ++rr)
                    if (l + ll &lt;= r - rr - L + 1) &#123;
                        res[ll][rr].resize(2, inf);
                        for (int i = l + ll; i &lt;= r - rr - L + 1; ++i)
                            res[ll][rr][1] = std::min(res[ll][rr][1], w[i]);
                        // printf(&quot;[%d, %d]: (%d, %d) = %lld\n&quot;, l, r, ll, rr, res[ll][rr][1]);
                    &#125;
            // for (int i = 0; i &lt; L; ++i)
            //     if (l + i + L - 1 &lt;= r) &#123;
            //         printf(&quot;[%d, %d]: (%d, %d) = %lld\n&quot;, l, r, i, r - (l + i + L - 1), w[l + i]);
            //         res[i][r - (l + i + L - 1)].emplace_back(w[l + i]);
            //     &#125;
            return res;
        &#125;   
        int mid = (l + r) &gt;&gt; 1;
        node tl(calc(l, mid)), tr(calc(mid + 1, r)), res((r - l + 1) / L + 1);
        for (int ll = 0; ll &lt; L; ++ll)
            for (int rr = 0; rr &lt; L; ++rr)
                res[ll][rr] = merge(tl[ll][0], tr[0][rr]);
        for (int ll = 0; ll &lt; L; ++ll)
            for (int rr = 0; rr &lt; L; ++rr)
                for (int i = 1; i &lt; L &amp;&amp; i &lt; mid; ++i)
                    upd(res[ll][rr], merge(merge(tl[ll][i], tr[L - i][rr]), &#123; 0, w[mid - i + 1] &#125;));
        for (int ll = 0; ll &lt; L; ++ll)
            for (int rr = L - 1; rr; --rr)
                upd(res[ll][rr - 1], res[ll][rr]);
        for (int rr = 0; rr &lt; L; ++rr)
            for (int ll = L - 1; ll; --ll)
                upd(res[ll - 1][rr], res[ll][rr]);
        // for (int i = 0; i &lt; L; ++i)
        //     for (int j = 0; j &lt; L; ++j) &#123;
        //         printf(&quot;  (%d, %d): &quot;, i, j);
        //         for (auto p : res[i][j])
        //             printf(&quot;%lld &quot;, p);
        //         puts(&quot;&quot;);
        //     &#125;
        return res;
    &#125;;
    auto res(calc(1, n));
    for (int i = 1; i &lt;= n / L; ++i)
        std::cout &lt;&lt; res[0][0][i] &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;</code></pre>
</details>
<hr />
<h3 id="例假人">例：假人</h3>
<p><a target="_blank" rel="noopener" href="http://222.180.160.110:61235/problem/47728" class="uri">http://222.180.160.110:61235/problem/47728</a></p>
<p>令 <span class="math inline">\(f_{i,j}\)</span> 表示前 <span class="math inline">\(i\)</span> 组选完占了 <span class="math inline">\(j\)</span> 体积的最大价值。那么有 <span class="math inline">\(f_{i,j}=\max\{f_{i-1,k}+a_{i,j-k}\}\)</span>。</p>
<p><em>袜，这个东西好凸的样子！啊？居然不是凸的？</em></p>
<p>事实上，有结论：若干个体积为 <span class="math inline">\(0\sim 4\)</span> 的物品做背包，可以凑出值域内任意 <span class="math inline">\(24\)</span> 的倍数。所以先把体积全部 <span class="math inline">\(-1\)</span>，然后就可以得到体积为 <span class="math inline">\(0\sim 4\)</span> 的物品。然后会发现他们按照模 <span class="math inline">\(12\)</span> 的余数分别是凸的。</p>
<p>能感受到恶意了。然后就可以枚举体积，再闵可夫斯基和了。同样需要在状态中引入作为版本号的 <span class="math inline">\([l,r]\)</span> 维，显然因变量是体积、版本号是组数。</p>
<details>
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;
const long long inf = 1e18;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;fake2.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n, m = 0;
    std::cin &gt;&gt; n;
    std::vector&lt;int&gt; siz(n + 1);
    std::vector&lt;std::vector&lt;int&gt; &gt; a(n + 1);
    for (int i = 1; i &lt;= n; ++i) &#123;
        std::cin &gt;&gt; siz[i], m += siz[i];
        a[i].resize(siz[i] + 1);
        for (int j = 1; j &lt;= siz[i]; ++j)
            std::cin &gt;&gt; a[i][j];
    &#125;
    using arr = std::vector&lt;long long&gt;;
    struct node &#123;
        std::vector&lt;arr&gt; f;
        node(): f(12) &#123;&#125;
        arr &amp;operator[] (int q) &#123;
            return f[q];
        &#125;
    &#125;;
    auto merge = [&amp;](arr &amp;p, arr &amp;q) &#123;
        arr res((int)(p.size() + q.size()) - 1), dp(p.size()), dq(q.size());
        std::adjacent_difference(p.begin(), p.end(), dp.begin());
        std::adjacent_difference(q.begin(), q.end(), dq.begin());
        std::merge(dp.begin() + 1, dp.end(), dq.begin() + 1, dq.end(), res.begin() + 1, std::greater&lt;long long&gt; ());
        res[0] = p[0] + q[0];
        std::partial_sum(res.begin(), res.end(), res.begin());
        return res;
    &#125;;
    auto upd = [&amp;](arr y, arr &amp;x, int tag) &#123;
        if (tag)
            y.insert(y.begin(), -inf);
        if (y.size() &gt; x.size())
            x.resize(y.size(), -inf);
        for (int i = 0; i &lt; (int)y.size(); ++i)
            x[i] = std::max(x[i], y[i]);
        return;
    &#125;;
    std::function&lt;node(int, int)&gt; calc = [&amp;](int l, int r) &#123;
        if (l == r) &#123;
            node res;
            for (int i = 1; i &lt;= siz[l]; ++i)
                res[i - 1].push_back(a[l][i]);
            return res;
        &#125;
        int mid = (l + r) &gt;&gt; 1;
        node tl(calc(l, mid)), tr(calc(mid + 1, r)), res;
        for (int p = 0; p &lt; 12; ++p)
            for (int q = 0; q &lt; 12; ++q)
                if (!tl[p].empty() &amp;&amp; !tr[q].empty())
                    upd(merge(tl[p], tr[q]), res[(p + q) % 12], p + q &gt;= 12);
        return res;
    &#125;;
    auto res(calc(1, n));
    for (int i = 0; i &lt;= m - n; ++i)
        std::cout &lt;&lt; res[i % 12][i / 12] &lt;&lt; &#39; &#39;;
    std::cout &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;</code></pre>
</details>
<hr />
<h2 id="slope-trick">slope trick</h2>
<p>对于一个 OI 中的凸函数，它是由一些斜率单调的线段拼接成的图形。</p>
<p>在这个前提下，发现可以用整个函数的左 / 右端点值（截距）和 <span class="math inline">\((n-1)\)</span> 个斜率 / 差分信息描述函数。而这有时比直接维护 <span class="math inline">\(n\)</span> 个点值有着更优美的性质，唤其为 slope trick。</p>
<p>例如，关于斜率序列，如果定义域不大，可以直接维护；如果它的变化次数不多，可以利用它的单调性质，用单调数据结构维护；如果它的值域很小，可以直接维护拐点。</p>
<p>注意前两种方法一般关注横坐标对应的函数值，所以自变量一般是和操作次数一类有关的；而这里关注函数最值而弱化了具体横坐标，操作次数一般会作为待最优化的因变量，例如：</p>
<ul>
<li>我想要将数列通过若干次单点修改使序列单调，但不关心序列最终形态，问最小操作次数。</li>
<li>我想要让树上所有叶子到根的路径边权和相等，但不关心这个值是多少，问最小操作次数。</li>
</ul>
<p>下面依次解决上述问题。</p>
<hr />
<h3 id="例序列-sequence">例：序列 sequence</h3>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P4597" class="uri">https://www.luogu.com.cn/problem/P4597</a></p>
<p>暴力地，令 <span class="math inline">\(f_{i,j}\)</span> 表示 <span class="math inline">\(a_i\)</span> 最终被修改为 <span class="math inline">\(j\)</span>，容易写出 DP 式子 <span class="math inline">\(f_{i,j}=\min\limits_{k\le j}\{f_{i-1,k}\}+|a_i-j|\)</span>。</p>
<p>然后就会发现它的定义域实在是太大了！那如果关注斜率的变化情况呢？</p>
<p>令 <span class="math inline">\(f_{i-1}(k)\)</span> 的极值点为 <span class="math inline">\(k_m\)</span>，分类讨论拆绝对值和 min：</p>
<ul>
<li><p>当 <span class="math inline">\(j\le a_i\)</span> 时，<span class="math inline">\(f_i(j)=\min\limits_{k\le j}\{f_{i-1}(k)\}+a_i - j\)</span>。</p>
<ul>
<li>当 <span class="math inline">\(j &lt; k_m\)</span> 时，<span class="math inline">\(f_i(j)=f_{i-1}(j)+a_i-j\)</span>，斜率相对于 <span class="math inline">\(f_{i-1}(j)\)</span> 整体减 <span class="math inline">\(1\)</span>。<del>我就说导数没白学吧</del></li>
<li>当 <span class="math inline">\(j \ge k_m\)</span> 时，<span class="math inline">\(f_i(j)=f_{i-1}(k_m)+a_i-j\)</span>，斜率为 <span class="math inline">\(-1\)</span>。</li>
</ul></li>
<li><p>当 <span class="math inline">\(j &gt; a_i\)</span> 时，<span class="math inline">\(f_i(j)=\min\limits_{k\le j}\{f_{i-1}(k)\}+j-a_i\)</span>。</p>
<ul>
<li>当 <span class="math inline">\(j &lt; k_m\)</span> 时，<span class="math inline">\(f_i(j)=f_{i-1}(j)+j-a_i\)</span>，斜率相对于 <span class="math inline">\(f_{i-1}(j)\)</span> 整体加 <span class="math inline">\(1\)</span>。</li>
<li>当 <span class="math inline">\(j\ge k_m\)</span> 时，<span class="math inline">\(f_i(j) = f_{i-1}(k_m)+j-a_i\)</span>，斜率为 <span class="math inline">\(1\)</span>。</li>
</ul></li>
</ul>
<p>如果现在我们掏一个支持区间加斜率、区间推平斜率且维护区间函数最值点的数据结构，那就太逆天了。一个经典的解决方案是用堆维护线段斜率的差分（也就是差分的差分）。</p>
<p>发现整体修改次数是 <span class="math inline">\(O(n)\)</span> 的，且如果只看比 <span class="math inline">\(k_m\)</span> 更左的 <span class="math inline">\(j\)</span>（更靠右的已经与极值无关所以不用维护），那么就只需要维护区间减法。</p>
<p>如果将一次区间前缀减法看作一次前缀右端点入队，显然左侧某点 <span class="math inline">\(a\)</span> 的实际被减次数为 <span class="math inline">\(a\)</span> 入队的次数 + 所有右于 <span class="math inline">\(a\)</span> 点的元素的入队次数。用大根堆维护这些元素，就可以快速维护整个斜率序列。例如 <code>3 2 2 1</code>，代表 <span class="math inline">\(3\)</span> 处斜率为 <span class="math inline">\(-1\)</span>，<span class="math inline">\(2\)</span> 处斜率为 <span class="math inline">\(-3\)</span>，<span class="math inline">\(1\)</span> 处斜率为 <span class="math inline">\(-4\)</span>。</p>
<ul>
<li><p>当 <span class="math inline">\(a_i\ge k_m\)</span> 时（容易发现它会成为新的 <span class="math inline">\(k_m\)</span>），直接把 <span class="math inline">\(a_i\)</span> 加入大根堆，就可以把 <span class="math inline">\(\le a_i\)</span> 的所有位置斜率减去 <span class="math inline">\(1\)</span>。</p>
什么你问在 <span class="math inline">\(k_m\)</span> 和 <span class="math inline">\(a_i\)</span> 之间的推平怎么办？由于唯一右于它们的拐点 <span class="math inline">\(a_i\)</span> 入了一次队，所以中间的元素斜率自然是 <span class="math inline">\(-1\)</span> 啊。</li>
<li><p>当 <span class="math inline">\(a_i&lt;k_m\)</span> 时，我们需要：</p>
<ol type="1">
<li>将 <span class="math inline">\(a_i\)</span> 以左的位置斜率减去 <span class="math inline">\(1\)</span>，直接将 <span class="math inline">\(a_i\)</span> 入队即可。</li>
<li>将 <span class="math inline">\(a_i\)</span> 和 <span class="math inline">\(k_m\)</span> 之间的位置斜率加上 <span class="math inline">\(1\)</span>，把 <span class="math inline">\(k_m\)</span> 弹出（太好了就在队首）再把 <span class="math inline">\(a_i\)</span> 加入即可。由于 <span class="math inline">\(k_m\)</span> 显然是一个拐点，所以删除 <span class="math inline">\(k_m\)</span> 并非虚空索敌，但注意 <span class="math inline">\(k_m\)</span> 可能会变化成其后继。</li>
</ol></li>
</ul>
<p>其实就会发现还有一些有趣的小性质，比如 <span class="math inline">\(k_m\)</span> 与队首等价（用于实现）；<span class="math inline">\(k_m\)</span> 右侧斜率全部为 <span class="math inline">\(1\)</span>，也是唯一可以取到的正斜率。</p>
<details>
<p>袜写起来好简单。</p>
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n;
    std::cin &gt;&gt; n;
    std::vector&lt;int&gt; a(n + 1);
    long long res = 0ll;
    std::priority_queue&lt;int&gt; q;
    for (int i = 1; i &lt;= n; ++i) &#123;
        std::cin &gt;&gt; a[i];
        if (i == 1 || a[i] &gt;= q.top())
            q.push(a[i]);
        else &#123;
            res += q.top() - a[i];
            q.pop(), q.push(a[i]), q.push(a[i]);
        &#125;
    &#125;
    std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;</code></pre>
</details>
<hr />
<h3 id="例烟花表演">例：烟花表演</h3>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3642" class="uri">https://www.luogu.com.cn/problem/P3642</a></p>
<p>设 <span class="math inline">\(f_{u,d}\)</span> 表示在 <span class="math inline">\(u\)</span> 子树中所有叶子距根均为 <span class="math inline">\(d\)</span> 的最小代价。那么有：</p>
<p><span class="math display">\[
f_{u,d}=\sum\limits_{(v, w)\in u}\min\limits_{0\le w&#39;\le d}\{f_{v,d-w&#39;}+|w-w&#39;|\}.
\]</span></p>
<p>可以归纳证明 <span class="math inline">\(f_{u,d}\)</span> 为凸；和上一题相似地，考虑用 <span class="math inline">\(f_v\)</span> 的堆得到 <span class="math inline">\(f_u\)</span> 的堆。</p>
<p>首先最外层是一个线性加，这其实就是把差分数组 / 斜率加起来，放到我们这个堆里面就是合并两个堆。虽然你可能和我一样不认识可并堆，但是你可以和我一样不会 pd_ds。</p>
<p>再看内层，发现和上一题长得像但其实不一样，呜呜呜。发现 <span class="math inline">\(|w-w&#39;|\)</span> 是一个左右斜率分别为 <span class="math inline">\(-1,1\)</span> 的分段函数，而左边类比可得斜率最大为 <span class="math inline">\(1\)</span>。</p>
<p>由闵可夫斯基和，内层函数斜率 <span class="math inline">\(&lt;-1\)</span> 的部分来自 <span class="math inline">\(f_{v,d-w&#39;}\)</span>；<span class="math inline">\(=-1\)</span> 的部分来自 <span class="math inline">\(f_{v,d-w&#39;}\)</span> 和 <span class="math inline">\(|w-w&#39;|\)</span> 的左半边（感谢 <span class="math inline">\(w&#39;\)</span> 是有下确界的）；<span class="math inline">\(=0\)</span> 的部分来自 <span class="math inline">\(f_{v,d-w&#39;}\)</span>；<span class="math inline">\(&gt;0\)</span> 的部分我们不关心。</p>
<p>最终函数图像的变化：水平部分的左端点右移了 <span class="math inline">\(w\)</span>。找到 <span class="math inline">\(f_{v,d}\)</span> 中的水平线段和斜率为 <span class="math inline">\(1\)</span> 的线段，令其在堆中的值 <span class="math inline">\(+w\)</span> 就能达到平移的目的。</p>
<p>但需要注意，此时仍然需要 <strong>保留内层函数中斜率为 <span class="math inline">\(1\)</span> 的部分，但斜率 <span class="math inline">\(&gt;1\)</span> 的部分被删除</strong>。原因如下：</p>
<ul>
<li>绝对值函数与内层函数定义域相同，作闵可夫斯基和后，斜率为 <span class="math inline">\(1\)</span> 的右侧线段会将 <span class="math inline">\(f_{v,d-w&#39;}\)</span> 中原有的 <span class="math inline">\(&gt;1\)</span> 的部分『挤』出定义域，故可以将其直接删除。</li>
<li>斜率为 <span class="math inline">\(1\)</span> 的部分，虽然对内层函数中极值点无贡献，但在外层函数中极值点可能向右偏移，此时会对其产生影响，需要维护。</li>
</ul>
<p>容易发现由于 <span class="math inline">\(w&#39;\)</span> 的取值上限是 <span class="math inline">\(d\)</span>，但 <span class="math inline">\(d\)</span> 没有上界，所以每个内层函数的右侧都一定是一条斜率为 <span class="math inline">\(1\)</span> 的射线；也就是说，每个外层函数一定有（儿子个数）个拐点（堆中元素），弹出这么多个就可以删除外层函数中斜率 <span class="math inline">\(&gt;1\)</span> 的线段，顺便找到斜率为 <span class="math inline">\(0\)</span> 和 <span class="math inline">\(1\)</span> 的线段。</p>
<details>
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;
#include &lt;ext/pb_ds/priority_queue.hpp&gt;
const int inf= 0x3f3f3f3f;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n, m;
    std::cin &gt;&gt; n &gt;&gt; m, n += m;
    std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; g(n + 1);
    auto res(0ll);
    for (int i = 2, fa, w; i &lt;= n; ++i) &#123;
        std::cin &gt;&gt; fa &gt;&gt; w, res += w;
        g[fa].emplace_back(i, w);
    &#125;
    std::vector&lt;__gnu_pbds::priority_queue&lt;long long&gt; &gt; q(n + 1);
    std::function&lt;void(int)&gt; DFS = [&amp;](int x) &#123;
        if (g[x].empty())
            q[x].push(0), q[x].push(0);
        else
            for (auto [i, w] : g[x]) &#123;
                DFS(i);
                for (int j = 1; j &lt; (int)g[i].size(); ++j)
                    q[i].pop();
                long long t1 = q[i].top(), t0;
                q[i].pop(), t0 = q[i].top(), q[i].pop();
                q[i].push(t1 + w), q[i].push(t0 + w);
                q[x].join(q[i]);
            &#125;
        // fprintf(stderr, &quot;size(%d) = %d\n&quot;, x, (int)q[x].size());
        return;
    &#125;;
    DFS(1);
    for (int i = 1; i &lt;= (int)g[1].size(); ++i)
        q[1].pop();
    for (; !q[1].empty(); q[1].pop())
        res -= q[1].top();
    std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;</code></pre>
</details>
<hr />
<h3 id="例buy-low-sell-high">例：Buy Low Sell High</h3>
<p><a target="_blank" rel="noopener" href="https://codeforces.com/problemset/problem/865/D" class="uri">https://codeforces.com/problemset/problem/865/D</a></p>
<p>令 <span class="math inline">\(f_{i,j}\)</span> 表示在第 <span class="math inline">\(i\)</span> 天结束后持有 <span class="math inline">\(j\)</span> 支股票的最大收益。则 <span class="math inline">\(f_{i,j}=\max\{f_{i-1,j},f_{i-1,j-1}-a_i,f_{i-1,j+1}+a_i\}\)</span>。</p>
<p>（由于这里和 max 有关所以需要精细描述凹凸了）发现就是把三个（可能）经过平移的（可能）凹的函数做线性 max。虽然实际上的结论『函数在整点上是凹的』不算太显然，但是可以猜是凹的。</p>
<p>线性 max 在 slope trick 中是不太能体现的，但我们发现这里是同一个凹函数向左上、右下平移同一个向量，希望得到新的凹函数不管是从差分角度还是图象，都能得到新函数由左上部分斜率 <span class="math inline">\(&gt;-a_i\)</span> 的线段、两段斜率 <span class="math inline">\(=-a_i\)</span> 的线段、右下部分斜率 <span class="math inline">\(&lt;-a_i\)</span> 的线段组成。此外，由于向左上平移的函数有一处离开了定义域，还需将其剔除。</p>
<p>值得注意的是，当 <span class="math inline">\(-a_i\)</span> 比最小斜率还要小时会有变化，可以画图看一下。</p>
<p><img src="2.png" /></p>
<p>发现定义域是相对小的（<span class="math inline">\(0\le j\le n\)</span>），故用优先队列维护整个斜率序列就可以快速插入两个 <span class="math inline">\(k=-a_i\)</span> 的线段。容易发现顶点在 <span class="math inline">\(j=0\)</span> 处取得（从图象和定义都易知），最右侧是只买不卖的最劣方案，可以倒推。</p>
<details>
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
#endif
    int n;
    std::cin &gt;&gt; n;
    std::vector&lt;int&gt; a(n + 1);
    auto res = 0ll;
    for (int i = 1; i &lt;= n; ++i)
        std::cin &gt;&gt; a[i], res -= a[i];
    std::priority_queue&lt;int&gt; q;
    q.push(-a[1]);
    for (int i = 2; i &lt;= n; ++i)
        if (a[i] &lt; -q.top())
            q.push(-a[i]);
        else
            q.pop(), q.push(-a[i]), q.push(-a[i]);
    for (; !q.empty(); res -= q.top(), q.pop());
    std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;</code></pre>
</details>

			</div>
			<hr class="dotted">
			<div class="post footer">
				<div id="hitokoto">
					<h3 id="hitokoto-title">
						言论
					</h3>
					<div id="hitokoto-content">
					</div>
					<div id="hitokoto-from">
					</div>
				</div>
				<div class="button flex">
					<div id="prev">
						
							<!-- 吐槽，为啥还需要加 / -->
							<a href="/20250707-1/">
								<i class="fas fa-angle-double-left" style="margin-right: 10px;"></i>
								决策单调性
							</a>
						
					</div>
					<div id="next">
						
							<a href="/20250612/">
								点分治
								<i class="fas fa-angle-double-right" style="margin-left: 10px;"></i>
							</a>
						
					</div>
				</div>
				<div id="vcomments" class="yahei"></div>
<script>
	new Valine({
		el: '#vcomments',
		appId: 'OlmvQ0a2Zw7xo3no2bwabOzx-gzGzoHsz',
		appKey: 'TW6t8mFeGLmhPjWisvmllvvo',
		recordIP: true,
		enableQQ: true, 
		// [EDITED] 目前 Valine 的 QQ 自动获取昵称似乎不可用
		// 该问题在 v1.5.3 中已修复
		pageSize: 10,
		requiredFields:
			
				['nick']
			,
		placeholder: "The world is but a little place after all...\n能够根据邮箱获取你的 Gravatar 头像。昵称是必填项，长度需不低于 3。",
		avatar: 'mp',
		avatar_cdn: 'https://cravatar.cn/avatar/',
		emojiCDN: 'https://xsc062.netlify.app/em/', 
		emojiMaps: {
			
				"微笑": "wx.gif",
			
				"龇牙": "cy.gif",
			
				"流泪": "ll.gif",
			
				"笑哭": "xk.gif",
			
				"流汗": "lh.gif",
			
				"擦汗": "ch.gif",
			
				"亲亲": "qq.gif",
			
				"色": "se.gif",
			
				"疑问": "yiw.gif",
			
				"发呆": "fd.gif",
			
				"晕": "yun.gif",
			
				"鼓掌": "gz.gif",
			
				"憨笑": "hanx.gif",
			
				"快哭了": "kk.gif",
			
				"得意": "dy.gif",
			
				"狂笑": "kx.gif",
			
				"害羞": "hx.gif",
			
				"妈妈生的": "dz.gif",
			
				"糗大了": "qd.gif",
			
				"吃瓜": "cg.gif",
			
				"睁眼": "zy.webp",
			
				"辣眼睛": "lyj.gif",
			
				"酸了": "nm.gif",
			
				"滚": "gun.webp",
			
				"惊恐": "jk.gif",
			
				"幽灵": "youl.gif",
			
				"无聊": "wul.gif",
			
				"吃": "eat.gif",
			
				"你很棒棒": "bb.gif",
			
				"赞": "qiang.gif",
			
				"踩": "ruo.gif",
			
				"握手": "wsh.gif",
			
				"发抖": "fad.gif",
			
				"挥手": "hsh.gif",
			
				"磕头": "kt.gif",
			
				"怄火": "oh.gif",
			
		},
	})
</script>
			</div>
			<script>setHitokoto();</script>
		</div> 
	</div>
</div>
    <!-- 页脚开始 -->
<div id="footer" class="yahei">
    Powered by
    <a target="_blank" rel="noopener" href="https://hexo.io">
        Hexo
    </a>
    &
    <a href="/about-this-theme">
        iwll
    </a>
    <p style="margin-top: 5px;">
        2021 - 2025
    </p>
</div>
<!-- Valine 相关配置 -->
<script>
    const getValineDomTimer = setInterval(() => {
        // 不知道为什么 我从原博客 js 文件粘过来的参数是
        // "#valine .vcards .vcard"
        // DEBUG 了半天才定位到这个问题。。。
        const vcards =
            document.querySelectorAll('#valine, .vcards, .vcard');
        if (vcards.length > 0) {
            let author = 'XSC062';
            for (let vcard of vcards) {
                const vnick_dom = vcard.querySelector('.vhead .vnick');
                if (vnick_dom != null) {
                    const vnick = vnick_dom.innerHTML;
                    if (vnick === author) {
                        vnick_dom.innerHTML =
                        `${vnick} <span id="rootitem" class="fira">root</span>`
                    }
                }
            }
        }
        else {
            clearInterval(getValineDomTimer);
        }
    }, 2000);
    SetActiveItem();
    setDetailsSummary();
    setTitleAnchor();
    setEmptyToc();
    setCodeClassName();
</script>


<!-- js -->
<!-- 搜索功能相关配置 -->

<script src="/js/search.js"></script>


<script src="/js/local-search.js"></script>

</script>
<!-- prism 相关配置 -->
<script type="text/javascript" src="/js/prism.js" defer></script>
<!-- 代码块复制功能 -->
<script type="text/javascript" src="/js/clipboard.min.js"></script>
<script type="text/javascript" src="/js/clipboard-use.js"></script>
<!-- 页脚结束 -->
</body>
</html>