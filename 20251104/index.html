<!DOCTYPE html>
<html>
<head>
    <!-- 网站图标 -->
<link rel="icon" type="image/png" sizes="32x32" href="/images/icon.svg">
<!-- 其他图标支持 -->
<link rel="stylesheet" href="/css/facss/fa-brands.min.css">
<link rel="stylesheet" href="/css/facss/fa-regular.min.css">
<link rel="stylesheet" href="/css/facss/fa-solid.min.css">
<link rel="stylesheet" href="/css/facss/fontawesome.min.css">
<link rel="stylesheet" href="/css/facss/fontawesome-all.css">
<link href="https://use.fontawesome.com/releases/v5.0.4/css/all.css" rel="stylesheet">
<!-- 网站标题 -->
<title>
	
		杂题 -
	
	XSC062 的博客
</title>
<!-- js 引入 -->
<script>
const searchPath = "/search.xml"
</script>

<script src="/js/afterloaded.js"></script>


<script src="/js/jQuery.js"></script>

<!-- 载入 Valine -->

<script src="/js/Valine.min.js"></script>

<!-- css 引入 -->

<link rel="stylesheet" href="/css/layout.css">


<link rel="stylesheet" href="/css/prcss/prism.css">



<!-- rss -->
<link rel="alternate" type="application/rss+xml" title="" href="https://xsc062.netlify.app/rss.xml" />
<link rel="alternate" type="application/atom+xml" title="" href="https://xsc062.netlify.app/atom.xml" />
<link rel="alternate" type="application/json" title="" href="https://xsc062.netlify.app/feed.json" />

<meta charset="utf-8"> 
<meta name="generator" content="Hexo 7.2.0"></head>
<body class="line-numbers match-braces no-brace-select rainbow-braces">
	
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
          tex2jax: {
            inlineMath: [ ['$','$'], ["\\(","\\)"] ],
            processEscapes: true
          }
        });
      </script>
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
            tex2jax: {
              skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
            }
          });
      </script>
    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
              var all = MathJax.Hub.getAllJax(), i;
              for(i=0; i < all.length; i += 1) {
                  all[i].SourceElement().parentNode.className += ' has-jax';
              }
          });
      </script>
    <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS_CHTML"></script>

	<!-- 搜索 -->
<script>
	function closeSearchBox() {
		$("#search-bg").css("transition", "null"); 
		$("#search-bg").css("z-index", "-1"); 
		$("#search-bg").css("opacity", "0%");
		return;
	}
</script>
<div id="search-bg">
	<div id="search-box">
		<button id="close-button" onclick="closeSearchBox()">
			<i class="fas fa-times"></i>
		</button>
		<input type="text" id="search-input" placeholder="Type to search...">
		<div id="search-results">
			<div id="emptyInput">
				<p>键入以搜索…</p>
				<p><i>匹配算法</i>：把输入按空格拆分，单独<strong>匹配</strong>每一段输入（不区分大小写，仅匹配文章文本内容），输出取或后的结果。</p>
				<p>模糊搜索似乎很难搞，目前没有相关打算。</p>
			</div>
		</div>
	</div>
</div>
<!-- 顶栏整体导航菜单 -->
<div class="ui top menu">
	<!-- 左对齐 logo -->
	<a class="logo" href="/">
		<img width="25px" height="25px" style="border: solid transparent 2.5px" src="/images/icon.svg"></img>
		<div id="bartitle" class="text">
			XSC062 的博客
		</div>
	</a>
	<!-- 右对齐部分导航 -->
	<div id="rightali" class="serif">
		<a class="item" id="Search" type="button">
			<i class="btn text-muted fa fa-search" id="search-icon" disabled></i>
		</a>
		<a class="item" id="Home" href="/">
			Home
		</a>
		<a class="item" id="Arch" href="/archives">
			Archives
		</a>
		<!-- <a class="item" id="Cate" href="/categories">
			Categories
		</a> -->
		<a class="item" id="Tags" href="/tags">
			Tags
		</a>
		<a class="item" id="Frie" href="/friends">
			Friends
		</a>
		<a class="item" id="Abou" href="/about">
			About
		</a>
	</div>
</div>
    
<link rel="stylesheet" href="/css/post.css">


<script src="/js/post.js"></script>


<div class="main">
	<div id="sidebar" class="text">
		<aside id="toc">
			<span id="toctitle">
				<i class="fas fa-list"></i>
				目录
			</span>
			<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#a.-%E5%9B%BE-hdu4903-the-only-survival"><span class="toc-text">A. 图 &#x2F; HDU4903 The only survival</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#b.-%E8%B7%AF%E7%BA%BF-arc136e-non-coprime-dag"><span class="toc-text">B. 路线 &#x2F; ARC136E Non-coprime DAG</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#a.-%E5%88%97%E8%BD%A6%E6%89%AB%E9%99%A4"><span class="toc-text">A. 列车扫除</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#b.-%E6%8D%A2%E6%9D%A5%E6%8D%A2%E5%8E%BB"><span class="toc-text">B. 换来换去</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#c.-%E7%94%BB%E5%AE%B6"><span class="toc-text">C. 画家</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#b.-%E7%81%AF%E5%85%89%E7%A7%80-cf1545c-aquamoon-and-permutations"><span class="toc-text">B. 灯光秀 &#x2F; CF1545C AquaMoon and Permutations</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#a.-bot-%E7%9A%84%E8%83%BD%E9%87%8F%E5%A0%86"><span class="toc-text">A. bot 的能量堆</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#b.-bot-%E7%9A%84%E7%9F%A9%E9%98%B5"><span class="toc-text">B. bot 的矩阵</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#a.-%E6%95%B0%E7%A0%81%E4%B8%B2"><span class="toc-text">A. 数码串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#b.-%E8%83%8C%E5%8C%85"><span class="toc-text">B. 背包</span></a></li></ol>
		</aside>
	</div>
	<div class="ui post container">
		<div class="ui text container">
			<span id="postcon">
				<span id="postinfo">
					<div class="ui post title serif">
						<div id="fortitle" data-content="杂题">
							杂题
						</div>
						<div class="ui title background">
						</div>
					</div>
					<span id="date">
						<i class="fas fa-calendar-alt" style="margin-right: 4px;"></i>
						2025-11-04
					</span>
				</span>
			</span>
			<div id="posttags" class="dotted border">
				
					
						<a href="/tags/计数/" class="citem">计数</a>
					
						<a href="/tags/二分图/" class="citem">二分图</a>
					
						<a href="/tags/DP-套-DP/" class="citem">DP 套 DP</a>
					
						<a href="/tags/搜索/" class="citem">搜索</a>
					
				
			</div>
			<!-- 本来用的是 fromNow 然后字符串判断，没想到可以直接调用 moment() -->
			
			<div id="content">
				<p>这么爱计数</p>
<span id="more"></span>
<hr />
<h2 id="a.-图-hdu4903-the-only-survival">A. 图 / HDU4903 The only survival</h2>
<p><a target="_blank" rel="noopener" href="https://vjudge.net/problem/HDU-4903#author=DeepSeek_zh" class="uri">https://vjudge.net/problem/HDU-4903#author=DeepSeek_zh</a></p>
<ul>
<li><p>很容易想到基于按 dis 从小到大枚举的做法</p>
<p>但是发现算方案就必须要知道每个点的具体 dis，就导致难以 DP，只能搜索，这样复杂度就不太好看。</p></li>
<li><p>一个显然的观察：<strong>并不关心 <span class="math inline">\(1,n\)</span> 以外点的标号</strong>，所以可以把 <span class="math inline">\(O(n^k)\)</span> 的暴搜优化到 <span class="math inline">\(O(\binom{n+k}k\cdot (n+k))\)</span>，然后做多重集排列即可。</p>
<p>模数非质时的多重集排列：<a href="/20231117/#数学">link</a></p></li>
</ul>
<details>
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
    std::freopen(&quot;graph.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;graph.out&quot;, &quot;w&quot;, stdout);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n, k, L, mod;
    std::cin &gt;&gt; n &gt;&gt; k &gt;&gt; L &gt;&gt; mod;
    if (L &lt; k) &#123;
        std::cout &lt;&lt; 0 &lt;&lt; &#39;\n&#39;;
        return 0;
    &#125;
    std::vector&lt;std::vector&lt;long long&gt; &gt; C(n + 1, std::vector&lt;long long&gt; (n + 1));
    C[0][0] = 1ll;
    for (int i = 1; i &lt;= n; ++i) &#123;
        C[i][0] = 1ll;
        for (int j = 1; j &lt;= i; ++j)
            C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % mod;
    &#125;
    std::vector&lt;int&gt; dis(n + 1), s;
    int res = 0;
    std::function&lt;void(int, int, long long)&gt; DFS = [&amp;](int x, int d, long long now) &#123;
        if (x == n) &#123;
            auto s0 = now, s1 = now;
            for (int i = 1; i &lt; n; ++i)
                if (dis[i] &gt;= k)
                    (s0 *= L) %= mod, (s1 *= L) %= mod;
                else if (L - (k - dis[i] - 1)) &#123;
                    (s0 *= L - (k - dis[i] - 1)) %= mod;
                    (s1 *= L - (k - dis[i] - 1) - 1) %= mod;
                &#125;
                else &#123;
                    s0 = s1 = 0ll;
                    break;
                &#125;
            dis[x] = k;
            auto u = 1ll;
            int cnt = n - 2;
            for (auto i : s)
                (u *= C[cnt][i]) %= mod, cnt -= i;
            (res += u * (s0 + mod - s1) % mod) %= mod;
            return;
        &#125;
        for (int i = d; i &lt;= k + 1; ++i) &#123;
            auto s0 = now, s1 = now;
            for (int j = 1; j &lt; x; ++j)
                if (dis[j] &gt;= i)
                    (s0 *= L) %= mod, (s1 *= L) %= mod;
                else if (L - (i - dis[j] - 1)) &#123;
                    (s0 *= L - (i - dis[j] - 1)) %= mod;
                    (s1 *= L - (i - dis[j] - 1) - 1) %= mod;
                &#125;
                else &#123;
                    s0 = s1 = 0ll;
                    break;
                &#125;
            dis[x] = i;
            if (dis[x] != dis[x - 1])
                s.push_back(1);
            else
                ++s.back();
            if (i == k + 1)
                s1 = 0ll;
            DFS(x + 1, i, (s0 + mod - s1) % mod);
            if (dis[x] != dis[x - 1])
                s.pop_back();
            else
                --s.back();
        &#125;
        return;
    &#125;;
    DFS(2, 1, 1);
    std::cout &lt;&lt; res % mod &lt;&lt; &#39;\n&#39;;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;</code></pre>
</details>
<hr />
<h2 id="b.-路线-arc136e-non-coprime-dag">B. 路线 / ARC136E Non-coprime DAG</h2>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/AT_arc136_e" class="uri">https://www.luogu.com.cn/problem/AT_arc136_e</a></p>
<ul>
<li><p>做过 <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/CF870F">CF870F Paths</a> 可以很快反应过来：<span class="math inline">\(x\)</span> 和 <span class="math inline">\(y\)</span> 是否可以同时被选，取决于它们各自的最小质因子是否能在 <span class="math inline">\(x,y\)</span> 之间交汇（或用 <span class="math inline">\(2\)</span> 作跳板）。</p>
<p>接着就发现由于 <span class="math inline">\(2\)</span> 间隔出现，此时再分奇偶性就会显得非常合理。</p></li>
<li><p>两个偶数总是不能同时被选；对于奇数 <span class="math inline">\(x\)</span> 和偶数 <span class="math inline">\(y\)</span>，要求 <span class="math inline">\(y\in [x-f(x)+1,x+f(x)-1]\)</span>。</p></li>
<li><p>考察奇数的选取。容易发现，钦定用 <span class="math inline">\(2\)</span> 作跳板，则两个奇数 <span class="math inline">\(x,y(x&lt;y)\)</span> 能同时被选，当且仅当：</p>
<ul>
<li>记 <span class="math inline">\(f(i)\)</span> 为 <span class="math inline">\(i\)</span> 的最小质因子，则 <span class="math inline">\(x+f(x)&gt; y-f(y)\)</span>。</li>
</ul>
<p>发现实际上可以认为 <span class="math inline">\(x\)</span> 代表区间 <span class="math inline">\([x-f(x),x+f(x)-1]\)</span>。那么两个点可以同时被选当且仅当它们代表的区间有交（这样就去掉了 <span class="math inline">\(x,y\)</span> 之间的偏序条件）</p>
<p>这样发现对『代表区间』的定义，在奇数视角和偶数视角下是冲突的，可以发现偶数视角的区间更紧；事实上，应该采用 <span class="math inline">\([x-f(x)+1,x+f(x)-1]\)</span> 这个看似充分不必要的定义，因为端点总是奇数，导致 <span class="math inline">\(x+f(x)&gt; y-f(y)\)</span> 和 <span class="math inline">\(x+f(x)-1&lt;y-f(y)+1\)</span> 不能同时成立。</p></li>
<li><p>进一步推广结论，容易发现多个奇数可以同时被选，当且仅当它们代表的区间有交。故可以枚举值域中的点，找加权覆盖次数最大值。</p></li>
</ul>
<details>
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int n;
    std::cin &gt;&gt; n;
    std::vector&lt;int&gt; fac(n + 1), l(n + 1), r(n + 1);
    for (int i = 2; i &lt;= n; ++i) &#123;
        if (!fac[i]) &#123;
            fac[i] = i;
            for (int j = 2 * i; j &lt;= n; j += i)
                if (!fac[j])
                   fac[j] = i;
        &#125;
        l[i] = std::max(1, i - fac[i] + 1);
        r[i] = std::min(i + fac[i] - 1, n);
    &#125;
    std::vector&lt;int&gt; a(n + 1);
    std::vector&lt;long long&gt; dif(n + 1);
    for (int i = 1; i &lt;= n; ++i) &#123;
        std::cin &gt;&gt; a[i];
        if (i == 1 || i % 2 == 0)
            continue;
        dif[l[i]] += a[i];
        if (r[i] != n)
            dif[r[i] + 1] -= a[i];
    &#125;
    auto res = 0ll;
    std::partial_sum(dif.begin(), dif.end(), dif.begin());
    for (int i = 1; i &lt;= n; ++i) &#123;
        auto now = a[1] + dif[i];
        if (i % 2 == 0)
            now += a[i];
        res = std::max(res, now);
    &#125;
    std::cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;</code></pre>
</details>
<hr />
<h2 id="a.-列车扫除">A. 列车扫除</h2>
<p><a target="_blank" rel="noopener" href="https://www.becoder.com.cn/contest/6708/problem/1" class="uri">https://www.becoder.com.cn/contest/6708/problem/1</a></p>
<blockquote>
<p>绝对聪明的 A, B, C 在一起玩 Nim，有三堆石子 <span class="math inline">\(c_{1,2,3}\)</span>，每次可以任选一堆拿走正整数个，不能拿的人扣一分，他的上一个人加一分。</p>
<p>给定 <span class="math inline">\(q\)</span> 次询问，形如：</p>
<ul>
<li>现在知道 <span class="math inline">\(\forall \, i=1,2,3,c_i\in[l_i,r_i]\)</span>。对于这 <span class="math inline">\(\prod_{i=1,2,3}r_i-l_i+1\)</span> 种可能的情况，对于每个人，求出分数之和。</li>
</ul>
<p><span class="math inline">\(q\le 10^6,V=10^9\)</span>。</p>
</blockquote>
<ul>
<li><p>容易发现，胜，平，负三个状态会被分给三个人，且一共只有三种分配方式。</p></li>
<li><p>当只剩一堆石头时，操作者胜；石头状态为 <span class="math inline">\((0,1,1)\)</span> 时，操作者负。</p></li>
</ul>
<hr />
<h2 id="b.-换来换去">B. 换来换去</h2>
<p><a target="_blank" rel="noopener" href="https://www.becoder.com.cn/contest/6708/problem/2" class="uri">https://www.becoder.com.cn/contest/6708/problem/2</a></p>
<blockquote>
<p>对 <span class="math inline">\(n\)</span> 个有标号的球任意分成任意组，组是无顺序的，且要求每组球个数 <span class="math inline">\(\ge 2\)</span>，求方案数，对质数取模。</p>
<p><span class="math inline">\(n\le 10^7\)</span>。</p>
</blockquote>
<ul>
<li><p>发现这是一个类斯特林数的问题，二项式反演得到答案式为：</p>
<p><span class="math display">\[
\sum_{i=0}^n (-1)^{n-i}\binom ni \sum_{j=0}^i \begin{Bmatrix} i\\ j\end{Bmatrix}
\]</span></p>
<p>用斯特林数通项展开：</p>
<p><span class="math display">\[
\sum_{i=0}^n (-1)^{n-i}\binom ni \sum_{j=0}^i \sum_{k=0}^j(-1)^{j-k}\dfrac {k^i}{(j-k)!\cdot k!}
\]</span></p>
<p>很容易注意到一个二项式定理的结构，故交换求和顺序：</p>
<p><span class="math display">\[
\sum_{j=0}^n \sum_{k=0}^j \dfrac {(-1)^{j-k}}{(j-k)!\cdot k!}\cdot \sum_{i=j}^n \binom ni (-1)^{n-i}k^i
\]</span></p>
<p>发现一个很严重的问题在于 <span class="math inline">\(i\)</span> 的起始范围是 <span class="math inline">\(j\)</span> 而不是 <span class="math inline">\(0\)</span>，但如果我们把一开始的式子改写成这样：</p>
<p><span class="math display">\[
\sum_{i=0}^n (-1)^{n-i}\binom ni \sum_{j=0}^n \begin{Bmatrix} i\\ j\end{Bmatrix}
\]</span></p>
<p>容易发现当 <span class="math inline">\(j&gt;i\)</span> 时 <span class="math inline">\(\begin{Bmatrix} i\\ j\end{Bmatrix}=0\)</span>，和原式的值相同，且斯特林数通项对于 <span class="math inline">\(j&gt;i\)</span> 也是成立的，故原式等价于</p>
<p><span class="math display">\[
\begin{aligned}
&amp;\sum_{j=0}^n \sum_{k=0}^j \dfrac {(-1)^{j-k}}{(j-k)!\cdot k!}\cdot \sum_{i=0}^n \binom ni (-1)^{n-i}k^i\\
=&amp;\sum_{j=0}^n \sum_{k=0}^j \dfrac {(-1)^{j-k}}{(j-k)!\cdot k!}\cdot (k-1)^n\\
=&amp;\sum_{k=0}^n \dfrac {(k-1)^n}{k!}\cdot \sum_{j=0}^{n-k} \dfrac {(-1)^j}{j!}\\
\end{aligned}
\]</span></p>
<p>后者内部与 <span class="math inline">\(k\)</span> 无关，是可前缀和计算的，只需要考虑在 <span class="math inline">\(O(1)\)</span> 内求出 <span class="math inline">\((k-1)^n\)</span> 的值，筛一下，对于质数（约 <span class="math inline">\(\dfrac n{\ln n}\)</span> 个）快速幂，合数用积性函数之类即可。</p></li>
</ul>
<details>
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
    std::freopen(&quot;card.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;card.out&quot;, &quot;w&quot;, stdout);
#else
    std::freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int T;
    for (std::cin &gt;&gt; T; T--; ) &#123;
        int n, mod;
        std::cin &gt;&gt; n &gt;&gt; mod;
        std::vector&lt;int&gt; tag(n + 1), p, pw(n + 1);
        auto qkp = [&amp;](long long x, int y) &#123;
            auto res = 1ll;
            for (; y; (x *= x) %= mod, y &gt;&gt;= 1)
                if (y &amp; 1)
                    (res *= x) %= mod;
            return res;
        &#125;;
        pw[1] = 1ll;
        for (int i = 2; i &lt;= n; ++i) &#123;
            if (!tag[i]) &#123;
                pw[i] = qkp(i, n);
                p.push_back(i);
            &#125;
            for (auto j : p) &#123;
                if (i &gt; n / j)
                    break;
                tag[i * j] = 1;
                pw[i * j] = (long long)pw[i] * pw[j] % mod;
                if (i % j == 0)
                    break;
            &#125;
        &#125;
        std::vector&lt;int&gt; inv(n + 1), s(n + 1);
        inv[0] = 1ll;
        for (int j = 1; j &lt;= n; ++j)
            inv[j] = (long long)inv[j - 1] * j % mod;
        inv[n] = qkp(inv[n], mod - 2);
        for (int j = n - 1; j; --j)
            inv[j] = (long long)inv[j + 1] * (j + 1) % mod;
        s[0] = inv[0];
        for (int j = 1; j &lt;= n; ++j) &#123;
            if (j &amp; 1)
                s[j] = s[j - 1] + mod - inv[j];
            else
                s[j] = s[j - 1] + inv[j];
            if (s[j] &gt;= mod)
                s[j] -= mod;
        &#125;
        auto res = (long long)s[n] * ((n &amp; 1) ? mod - 1 : 1);
        for (int k = 1; k &lt;= n; ++k)
            res += (long long)pw[k - 1] * inv[k] % mod * s[n - k] % mod;
        std::cout &lt;&lt; res % mod &lt;&lt; &#39;\n&#39;;
    &#125;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;</code></pre>
</details>
<hr />
<h2 id="c.-画家">C. 画家</h2>
<p><a target="_blank" rel="noopener" href="https://www.becoder.com.cn/contest/6714/problem/3" class="uri">https://www.becoder.com.cn/contest/6714/problem/3</a></p>
<ul>
<li><p>ARC 特供删十字，故时光倒流，转化成在图上删相同颜色的十字 / 行 / 列。</p></li>
<li><p>令 <span class="math inline">\(f_{i,j}\)</span> 表示合法的 <span class="math inline">\(i\)</span> 行 <span class="math inline">\(j\)</span> 列地图。发现同颜色的删行 + 删列会和直接删十字算重，</p></li>
</ul>
<hr />
<h2 id="b.-灯光秀-cf1545c-aquamoon-and-permutations">B. 灯光秀 / CF1545C AquaMoon and Permutations</h2>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/CF1545C" class="uri">https://www.luogu.com.cn/problem/CF1545C</a></p>
<ul>
<li><p>第一步需要想到，如果某一列的某个数，只有一个排列有，那么这个排列必须被选入拉丁方；</p>
<p>用这个必选的排列，可以排除掉一些与之冲突、不能选入拉丁方的排列。</p></li>
<li></li>
</ul>
<hr />
<h2 id="a.-bot-的能量堆">A. bot 的能量堆</h2>
<p><a target="_blank" rel="noopener" href="https://www.becoder.com.cn/contest/6731/problem/1" class="uri">https://www.becoder.com.cn/contest/6731/problem/1</a></p>
<blockquote>
<p>⚡<strong>超越一切震慑凡人</strong>⚡</p>
<p>给定正整数 <span class="math inline">\(x,y\)</span>，你可以执行下面三种操作：</p>
<ol type="1">
<li>将 <span class="math inline">\(x,y\)</span> 同时加 1；</li>
<li>将 <span class="math inline">\(x,y\)</span> 同时减一；</li>
<li>对于 <span class="math inline">\(\gcd(x,y)\)</span> 的一个质因子 <span class="math inline">\(p\)</span>，将 <span class="math inline">\(x,y\)</span> 同时除以 <span class="math inline">\(p\)</span>。</li>
</ol>
<p>问最少花费多少次操作使得 <span class="math inline">\(\min(x,y)=1\)</span>。多测。</p>
<p><span class="math inline">\(T\le 300,1\le x,y\le 10^9\)</span>。</p>
</blockquote>
<ul>
<li><p>不妨先考虑 <span class="math inline">\(x\ne y\)</span> 的情况，发现三种操作都不会使 <span class="math inline">\(x,y\)</span> 的相对大小关系改变。故令 <span class="math inline">\(x&lt;y\)</span>，考虑让 <span class="math inline">\(x\)</span> 变为 1。</p></li>
<li><p>记 <span class="math inline">\(d=y-x\)</span>， 很容易注意到 <span class="math inline">\(d\)</span> 的值不会在前两种操作中改变，由辗转相减，<span class="math inline">\(\gcd(x,y)=\gcd(d, x)\)</span>，即操作三每次选取的 <span class="math inline">\(p\)</span> 总是 <span class="math inline">\(d\)</span> 的质因子，且总能通过若干次操作 1/2 让 <span class="math inline">\(p\)</span> 能够执行。</p>
<p>每次执行操作 3 后，<span class="math inline">\(d\gets d\div p\)</span>，每次只需让 <span class="math inline">\(x\)</span> 变为 <span class="math inline">\(\lfloor \frac xp\rfloor\)</span> 或 <span class="math inline">\(\lceil \frac xp\rceil\)</span>。</p>
<p>直接记搜的话，容易发现状态总数是 V 因数总数。</p></li>
<li><p>对于 <span class="math inline">\(x=y\)</span> 的情况，答案至多为 <span class="math inline">\(x\)</span> 的质因子数量。暴搜 + 剪枝非常可过。</p>
<details>
<p><summary>有一种神秘的处理方式…</summary></p>
<pre class="cpp"><code>if (x == y) &#123;
    auto calc = [&amp;](int x) &#123;
        int cnt = 0;
        for (int i = 2; i * i &lt;= x; ++i)
            for (; x % i == 0; ++cnt, x /= i);
        return cnt + (x != 1);
    &#125;;
    int to = calc(x), res = to;
    for (int i = std::max(x - to, 1); i &lt;= x + to; ++i)
        res = std::min(res, calc(i) + std::abs(i - x));
    std::cout &lt;&lt; x &lt;&lt; &#39;\n&#39;;
    continue;
&#125;</code></pre>
<p>容易发现这东西没什么道理，反例大概率存在但在小范围内确实难以构造。总之数据没卡到。</p>
</details></li>
</ul>
<hr />
<h2 id="b.-bot-的矩阵">B. bot 的矩阵</h2>
<p><a target="_blank" rel="noopener" href="https://www.becoder.com.cn/contest/6731/problem/2" class="uri">https://www.becoder.com.cn/contest/6731/problem/2</a></p>
<blockquote>
<p>有一个 <span class="math inline">\(n\times n\)</span> 的二维数组，初始只知道 <span class="math inline">\(m\)</span> 个位置的数 <span class="math inline">\(a_{x,y}\)</span>，以及每行、每列的元素和 <span class="math inline">\(sx_{1\cdots n},sy_{1\cdots n}\)</span>。</p>
<p>构造出一个合法的解，每个数在 <span class="math inline">\([-2^63,2^63)\)</span> 内。</p>
<p><span class="math inline">\(n\le 2000\)</span>,<span class="math inline">\(a_{x,y},sx_i,sy_i\in [-10^9,10^9]\)</span>，<span class="math inline">\(m\le n^2\)</span>。</p>
</blockquote>
<ul>
<li><p>听说很容易想到二分图，但实在反应不过来。但在乱填的时候发现，如果出现了『必填』的情况，是一个行列交错的链式反应，这样就很容易想到二分图了</p>
<p>原理是同时影响行 <span class="math inline">\(i\)</span> 列 <span class="math inline">\(j\)</span> 的元素只有 <span class="math inline">\((i, j)\)</span></p></li>
<li><p>相当于给一个 <span class="math inline">\(2n\)</span> 个点 <span class="math inline">\(n^2\)</span> 条边的二分图，其中一些边权是已知的，那么不妨认为这些边被删除了</p>
<p>同时也是一个 <span class="math inline">\(n^2\)</span> 个元，<span class="math inline">\(2n-1\)</span> 个方程的方程组（<span class="math inline">\(sx=sy\)</span> 会消掉一条方程）；故很多元其实可以直接赋 <span class="math inline">\(0\)</span>，只拿 <span class="math inline">\(2n-1\)</span> 个元出来解方程。</p></li>
<li><p>在挖掉已知边的二分图上任意找生成树（森林）就可以满足 <span class="math inline">\(2n-1\)</span> 的限制，结合树上高斯消元，从叶子开始解方程即可。</p></li>
</ul>
<details>
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;
#define int long long
#define nec getchar
void read(int &amp;x) &#123;
    x = 0;
    char ch = nec();
    bool flag = false;
    for (; ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;; ch = nec())
        if (ch == &#39;-&#39;)
            flag = true;
    for (; ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;; ch = nec())
        x = x * 10 + ch - &#39;0&#39;;
    if (flag)
        x = -x;
    return;
&#125;
signed main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
#else
    std::freopen(&quot;matrix3.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int T;
    for (read(T); T--; ) &#123;
        int n, m;
        read(n), read(m);
        std::vector&lt;int&gt; sx(n + 1), sy(n + 1);
        for (int i = 1; i &lt;= n; ++i)
            read(sx[i]);
        for (int i = 1; i &lt;= n; ++i)
            read(sy[i]);
        std::vector&lt;std::vector&lt;int&gt; &gt; vis(n + 1, std::vector&lt;int&gt; (n + 1));
        std::vector&lt;std::vector&lt;long long&gt; &gt; a(n + 1, std::vector&lt;long long&gt; (n + 1));
        std::vector&lt;int&gt; tx(n + 1), ty(n + 1);
        auto work = [&amp;](int i, int j, int c) &#123;
            vis[i][j] = 1;
            ++tx[i], ++ty[j];
            sx[i] -= c, sy[j] -= c, a[i][j] = c;
            return;
        &#125;;
        for (int x, y, c; m--; ) &#123;
            read(x), read(y), read(c);
            work(x, y, c);
        &#125;
        if (std::accumulate(sx.begin() + 1, sx.end(), 0ll) != std::accumulate(sy.begin() + 1, sy.end(), 0ll)) &#123;
            std::cout &lt;&lt; &quot;NoSolution!&quot; &lt;&lt; &#39;\n&#39;;
            continue;
        &#125;
        std::vector&lt;int&gt; fx(n + 1), fy(n + 1);
        std::function&lt;bool(void)&gt; check = [&amp;](void) &#123;
            for (int x = 1; x &lt;= n; ++x)
                if (!fx[x]) &#123;
                    if (tx[x] == n) &#123;
                        if (sx[x] != 0)
                            return false;
                        fx[x] = 1;
                        if (!check())
                            return false;
                    &#125;
                    else if (tx[x] == n - 1) &#123;
                        for (int y = 1; y &lt;= n; ++y)
                            if (!vis[x][y]) &#123;
                                work(x, y, sx[x]);
                                fx[x] = 1;
                                if (!check())
                                    return false;
                            &#125;
                    &#125;
                &#125;
            for (int y = 1; y &lt;= n; ++y)
                if (!fy[y]) &#123;
                    if (ty[y] == n) &#123;
                        if (sy[y] != 0)
                            return false;
                        fy[y] = 1;
                        if (!check())
                            return false;
                    &#125;
                    else if (ty[y] == n - 1) &#123;
                        for (int x = 1; x &lt;= n; ++x)
                            if (!vis[x][y]) &#123;
                                work(x, y, sy[y]);
                                fy[y] = 1;
                                if (!check())
                                    return false;
                            &#125;
                    &#125;
                &#125;
            return true;
        &#125;;
        if (!check()) &#123;
            std::cout &lt;&lt; &quot;NoSolution!&quot; &lt;&lt; &#39;\n&#39;;
            continue;
        &#125;
        std::function&lt;void(int, int)&gt; DFS = [&amp;](int x, int op) &#123;
            if (op == 0) &#123;
                fx[x] = 1;
                for (int i = 1; i &lt;= n; ++i)
                    if (!vis[x][i] &amp;&amp; !fy[i]) &#123;
                        DFS(i, 1);
                        work(x, i, sy[i]);
                    &#125;
            &#125;
            else &#123;
                fy[x] = 1;
                for (int i = 1; i &lt;= n; ++i)
                    if (!vis[i][x] &amp;&amp; !fx[i]) &#123;
                        DFS(i, 0);
                        work(i, x, sx[i]);
                    &#125;
            &#125;
            return;
        &#125;;
        for (int i = 1; i &lt;= n; ++i)
            if (!fx[i])
                DFS(i, 0);
        for (int i = 1; i &lt;= n; ++i)
            if (!fy[i])
                DFS(i, 1);
        std::cout &lt;&lt; &quot;Botany!&quot; &lt;&lt; &#39;\n&#39;;
        for (int i = 1; i &lt;= n; ++i) &#123;
            for (int j = 1; j &lt;= n; ++j)
                std::cout &lt;&lt; a[i][j] &lt;&lt; &#39; &#39;;
            std::cout &lt;&lt; &#39;\n&#39;;
        &#125;
    &#125;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;</code></pre>
</details>
<hr />
<h2 id="a.-数码串">A. 数码串</h2>
<p><a target="_blank" rel="noopener" href="https://www.becoder.com.cn/contest/6736/problem/1" class="uri">https://www.becoder.com.cn/contest/6736/problem/1</a></p>
<blockquote>
<p>给定一个长度为 <span class="math inline">\(n\)</span> 的数字串，现在需要给它分为若干段，问在所有 <span class="math inline">\(2^{n-1}\)</span> 种分段方式中，有多少种满足：</p>
<ul>
<li>在任意相邻的两段中，有至少一段，其对应的十进制数是 <span class="math inline">\(D\)</span> 的倍数。</li>
</ul>
<p>答案对 <span class="math inline">\(10^9+7\)</span> 取模。</p>
<p>多测，<span class="math inline">\(n\le 2\times 10^5,D\le 10^6,T\le 100\)</span>。</p>
<p><strong>部分分特殊性质</strong>：<span class="math inline">\(\gcd(D,10)=1\)</span>。</p>
</blockquote>
<ul>
<li><p>发现若 <span class="math inline">\(a_{l\cdots r}\)</span> 是 <span class="math inline">\(D\)</span> 的倍数，记 <span class="math inline">\(s_i=s_{i+1}+a_i\times 10^{n-i}\)</span>，那么 <span class="math inline">\(\dfrac{s_l-s_{r+1}}{10^{n-r}}\bmod D=0\)</span></p>
<p>题目要求，这个转移点和上个转移点，至少有一个满足该式。显然可以类 DP 地做。</p></li>
<li><p>对于 <span class="math inline">\(D\)</span> 与 <span class="math inline">\(10\)</span> 互质的情况，原条件等价于 <span class="math inline">\(s_l\equiv s_{r+1}\pmod D\)</span>，用一个桶记录 DP 值即可</p></li>
<li><p>记 <span class="math inline">\(D=2^*\times 5^?\times m\)</span>，发现 <span class="math inline">\(m\)</span> 与 <span class="math inline">\(10\)</span> 互质，或许可以套用上方的做法</p>
<p><mark>由于 <span class="math inline">\(D\le 10^6 &lt; 2^{20}\)</span>，对于一个固定的 <span class="math inline">\(r\)</span>，所有 <span class="math inline">\(l\le r-20\)</span> 项的 <span class="math inline">\(a_l\)</span> 对 <span class="math inline">\(a_{l\cdots r}\bmod (2^*\times 5^?)\)</span> 的贡献总是 <span class="math inline">\(0\)</span></mark>，故在只考虑 <span class="math inline">\(2^*\times 5^?\)</span> 时， <span class="math inline">\(l\le r-20\)</span> 的可选性和 <span class="math inline">\(l=r-20\)</span> 的可选性相同。只需要对于 <span class="math inline">\(\bmod m\)</span> 沿用桶做法即可。</p>
<p>对于 <span class="math inline">\(l\ge r-20\)</span>，暴力即可，复杂度 <span class="math inline">\(O(T(n+D))\)</span>。</p></li>
</ul>
<details>
<p>注意 <span class="math inline">\(s_l-s_{r+1}\)</span> 里的 <span class="math inline">\(r+1\)</span>，调成鸲了</p>
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;
const int mod = 1e9 + 7;
int main() &#123;
#ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
    std::freopen(&quot;digit.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;digit.out&quot;, &quot;w&quot;, stdout);
#else
    std::freopen(&quot;./test/20251113/digit/ex_digit1.in&quot;, &quot;r&quot;, stdin);
    std::freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    const auto stime = std::chrono::steady_clock::now();
#endif
    int T;
    std::vector&lt;std::array&lt;long long, 2&gt; &gt; c(1e6);
    for (std::cin &gt;&gt; T; T--; ) &#123;
        std::string a;
        int d, n, m, p;
        std::cin &gt;&gt; a &gt;&gt; d, n = (int)a.length();
        a = &quot;#&quot; + a;
        std::vector&lt;std::vector&lt;long long&gt; &gt; f(n + 1, std::vector&lt;long long&gt; (2));
        f[0][0] = 1ll;
        m = d;
        for (; m % 2 == 0; m /= 2);
        for (; m % 5 == 0; m /= 5);
        p = d / m;
        for (int i = 0; i &lt; m; ++i)
            c[i][0] = c[i][1] = 0ll;
        std::vector&lt;int&gt; s(n + 2);
        for (int i = n, k = 1; i; --i, (k *= 10) %= m)
            s[i] = (s[i + 1] + (a[i] - &#39;0&#39;) * k) % m;
        auto s0 = 0ll;
        for (int i = 1; i &lt;= n; ++i) &#123;
            int now = 0;
            for (int j = i, k = 1; j &gt; i - 20 &amp;&amp; j; --j, (k *= 10) %= d) &#123;
                (now += (a[j] - &#39;0&#39;) * k) %= d;
                if (now == 0)
                    (f[i][0] += f[j - 1][0] + f[j - 1][1]) %= mod;
                else
                    (f[i][1] += f[j - 1][0]) %= mod;
            &#125;
            if (i &gt; 20) &#123;
                (c[s[i - 20]][0] += f[i - 21][0]) %= mod;
                (c[s[i - 20]][1] += f[i - 21][1]) %= mod;
                (s0 += f[i - 21][0]) %= mod;
                int now = 0;
                for (int j = i, k = 1; j &gt;= i - 20; --j, (k *= 10) %= p)
                    (now += (a[j] - &#39;0&#39;) * k) %= p;
                if (now == 0) &#123;
                    (f[i][0] += c[s[i + 1]][0] + c[s[i + 1]][1]) %= mod;
                    (f[i][1] += s0 + mod - c[s[i + 1]][0]) %= mod;
                &#125;
                else
                    (f[i][1] += s0) %= mod;
            &#125;
        &#125;
        std::cout &lt;&lt; (f[n][0] + f[n][1]) % mod &lt;&lt; &#39;\n&#39;;
    &#125;
#ifndef ONLINE_JUDGE
    std::cerr &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::chrono::duration&lt;double&gt; (std::chrono::steady_clock::now() - stime).count() &lt;&lt; &quot;s\n&quot;;
#endif
    return 0;
&#125;</code></pre>
</details>
<hr />
<h2 id="b.-背包">B. 背包</h2>
<p><a target="_blank" rel="noopener" href="https://www.becoder.com.cn/contest/6736/problem/2" class="uri">https://www.becoder.com.cn/contest/6736/problem/2</a></p>

			</div>
			<hr class="dotted">
			<div class="post footer">
				<div id="hitokoto">
					<h3 id="hitokoto-title">
						言论
					</h3>
					<div id="hitokoto-content">
					</div>
					<div id="hitokoto-from">
					</div>
				</div>
				<div class="button flex">
					<div id="prev">
						
							<!-- 吐槽，为啥还需要加 / -->
							<a href="/20251107/">
								<i class="fas fa-angle-double-left" style="margin-right: 10px;"></i>
								一类序列区间排序问题
							</a>
						
					</div>
					<div id="next">
						
							<a href="/20251103/">
								练习：数数 & 容斥
								<i class="fas fa-angle-double-right" style="margin-left: 10px;"></i>
							</a>
						
					</div>
				</div>
				<div id="vcomments" class="text"></div>
<script>
	new Valine({
		el: '#vcomments',
		appId: 'OlmvQ0a2Zw7xo3no2bwabOzx-gzGzoHsz',
		appKey: 'TW6t8mFeGLmhPjWisvmllvvo',
		recordIP: true,
		enableQQ: true, 
		// [EDITED] 目前 Valine 的 QQ 自动获取昵称似乎不可用
		// 该问题在 v1.5.3 中已修复
		pageSize: 10,
		requiredFields:
			
				['nick']
			,
		placeholder: "The world is but a little place after all...\n能够根据邮箱获取你的 Gravatar 头像。昵称是必填项，长度需不低于 3。",
		avatar: 'identicon',
		avatar_cdn: 'https://cravatar.cn/avatar/',
		emojiCDN: 'https://xsc062.netlify.app/em/', 
		emojiMaps: {
			
				"微笑": "wx.gif",
			
				"龇牙": "cy.gif",
			
				"流泪": "ll.gif",
			
				"笑哭": "xk.gif",
			
				"流汗": "lh.gif",
			
				"擦汗": "ch.gif",
			
				"亲亲": "qq.gif",
			
				"色": "se.gif",
			
				"疑问": "yiw.gif",
			
				"发呆": "fd.gif",
			
				"晕": "yun.gif",
			
				"鼓掌": "gz.gif",
			
				"憨笑": "hanx.gif",
			
				"快哭了": "kk.gif",
			
				"得意": "dy.gif",
			
				"狂笑": "kx.gif",
			
				"害羞": "hx.gif",
			
				"妈妈生的": "dz.gif",
			
				"糗大了": "qd.gif",
			
				"吃瓜": "cg.gif",
			
				"睁眼": "zy.webp",
			
				"辣眼睛": "lyj.gif",
			
				"酸了": "nm.gif",
			
				"滚": "gun.webp",
			
				"惊恐": "jk.gif",
			
				"幽灵": "youl.gif",
			
				"无聊": "wul.gif",
			
				"吃": "eat.gif",
			
				"你很棒棒": "bb.gif",
			
				"赞": "qiang.gif",
			
				"踩": "ruo.gif",
			
				"握手": "wsh.gif",
			
				"发抖": "fad.gif",
			
				"挥手": "hsh.gif",
			
				"磕头": "kt.gif",
			
				"怄火": "oh.gif",
			
		},
	})
</script>
			</div>
			<script>setHitokoto();</script>
		</div> 
	</div>
</div>
    <!-- 页脚开始 -->
<div id="footer" class="serif">
    Powered by
    <a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a>
    &
    <a href="/about-this-theme">
        iwll
    </a>
    <p style="margin-top: 5px;">
        2021 - 2025
    </p>
    <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/" id="CCTAG"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/big/by_nc_sa.svg"></a>
</div>
<!-- Valine 相关配置 -->
<script>
    const getValineDomTimer = setInterval(() => {
        // 不知道为什么 我从原博客 js 文件粘过来的参数是
        // "#valine .vcards .vcard"
        // DEBUG 了半天才定位到这个问题。。。
        const vcards =
            document.querySelectorAll('#valine, .vcards, .vcard');
        if (vcards.length > 0) {
            let author = 'XSC062';
            for (let vcard of vcards) {
                const vnick_dom = vcard.querySelector('.vhead .vnick');
                if (vnick_dom != null) {
                    const vnick = vnick_dom.innerHTML;
                    if (vnick === author) {
                        vnick_dom.innerHTML =
                        `${vnick} <span id="rootitem" class="code">root</span>`
                    }
                }
            }
        }
        else {
            clearInterval(getValineDomTimer);
        }
    }, 2000);
    SetActiveItem();
    setDetailsSummary();
    setTitleAnchor();
    setEmptyToc();
    setCodeClassName();
</script>


<!-- js -->
<!-- 搜索功能相关配置 -->

<script src="/js/search.js"></script>


<script src="/js/local-search.js"></script>

</script>
<!-- prism 相关配置 -->
<script type="text/javascript" src="/js/prism.js" defer></script>
<!-- 代码块复制功能 -->
<script type="text/javascript" src="/js/clipboard.min.js"></script>
<script type="text/javascript" src="/js/clipboard-use.js"></script>
<!-- 页脚结束 -->
</body>
</html>